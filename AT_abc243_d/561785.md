### 题目链接
[luogu](https://www.luogu.com.cn/problem/AT_abc243_d)

[atcoder](https://atcoder.jp/contests/abc243/tasks/abc243_d)

### 题目大意

有一个完全二叉树，有 $2^{10^{100}}-1$ 个节点，编号为 $1,2,\dots,2^{10^{100}}-1$。

节点 $1$ 是根。对于每个 $i$ $\forall$ $[1,2^{10^{100}})$，节点 $i$ 有两个子节点：左儿子 $2i$ 和右儿子 $2i+1$。


高桥从节点 $X$ 并执行 $N$ 个移动，由字符串 $S$ 表示。第 $i$ 步遵循如下规则：

+ 如果 $S$ 中第 $i$ 个字符是 `U`，转到他现在所在节点的父节点。
+ 如果 $S$ 中第 $i$ 个字符是 `L`，转到他现在所在节点的左儿子。
+ 如果 $S$ 中第 $i$ 个字符是 `R`，转到他现在所在节点的右儿子。


找到高桥在 $N$ 次移动后所在节点的编号。在给定的情况下，可以保证答案最多为 $10^{18}$。

### 思路

读完题后，发现**答案最多为 $10^{18}$**，但是高桥在移动过程中会到编号大于 $10^{18}$ 的节点？

例如：

```
1000000 1000000000000000000
RRRRRRRR ... RRUU ... UUUUUUUU
```

如果操作列表中有类似 `RU` 或 `LU` 的情况，那么可以将它们去掉（重复操作）。

但是，不能去掉 `UR` 或 `UL`！！！因为可能从一个儿子走到另一个儿子。（反正不处理也不会溢出）

所以，对于上面那个极端数据，将字符放入一个栈里面，每次读到 `U` 是判断栈顶是否是 `L` 或 `R`，是的话就退一次栈，最后按照栈中的字符模拟一遍即可。

复杂度很优秀，$O(N)$。

#### code

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
ll n,x,p;
char c,st[1000100];
//st是栈，p是栈指针
int main(){
	scanf("%lld %lld\n",&n,&x);
	for(ll i=1;i<=n;i++){
		scanf("%c",&c);
		if(i!=1){//防止RE
			if(c=='U'&&(st[p-1]=='L'||st[p-1]=='R')){
				p--;//出现RU或LU情况，退栈
			}else{
				st[p]=c;//否则入栈
				p++;
			}
		}else{
			st[p]=c;
			p++;
		}
	}
	for(ll i=0;i<p;i++){
		if(st[i]=='U')x/=2;
		else if(st[i]=='L')x=x*2;
		else if(st[i]=='R')x=x*2+1;
	}//直接模拟即可
	printf("%lld",x);
	return 0;
}
```