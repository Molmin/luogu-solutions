位运算+DP经典好题。  
具体思路：输入的地图由于只有0和1，很容易想到用2进制来保存。  
例如：$1 0 1$用$5$来保存，即$2^2+2^0$  

输入完地图之后，就可以来生成初始状态，先生成当前行中可能的状态

我们使用位运算来进行初始化，例如$110$不是一种可行的方案，因为 6&(6<<1) != 0 ，为什么！=0就不成立呢？

比如$1 1 0_2$，他左移1位变成了$1100_2$,110$_2$&1100$_2$=$100_2 \neq 0$，

而$101_2$就是一种可行的方案，因为他与他左移一位后做与运算等于0。

解决了初始化，我们再来看看塞入地图的问题，这个简单，将可能性与地图进行或运算，如果结果仍然是地图，那么这就是一种可行的方案。

最后，我们来看看DP的思路，dp[i][j]表示前i行的第j种状态最多的种数，因此答案就是$\sum dp[n]$。

```cpp
int n,m,maps[22],cnt,ans;//cnt表示成立的方案种数
int ok[5555],dp[22][5555];//dp[i][j]表示前i行的第j种状态的最大值（答案就是把最后一行都加起来） ，ok表示成立的状态
int main() {
	ios::sync_with_stdio(0);
	n=read();
	m=read();
	for(int i=0; i<n; i++)
		for(int j=0; j<m; j++)
			if(read())maps[i]+=(1<<j);//读入地图（我这里实际上是反着存的，但是并不影响结果）
	for(int i=0; i<(1<<m); i++)
		if(!(i&(i<<1)))
			ok[cnt++]=i;//检查可能的情况种数
	for(int i=0; i<cnt; i++)
		if((maps[0]|ok[i])==maps[0])dp[0][i]=1;//优先处理第1行（我存图从0开始）
	for(int i=1; i<n; i++) {
		for(int j=0; j<cnt; j++)
			if((maps[i]|ok[j])==maps[i])//如果这种状态可以放进当前地图
				for(int k=0; k<cnt; k++)
					if(!(ok[j]&ok[k]))dp[i][j]+=dp[i-1][k];//如果第j种状态和第k种状态没有冲突，则继承上一状态的答案
	}
	for(int i=0; i<cnt; i++)
		ans+=dp[n-1][i];//把最后一行加起来
	write(ans%100000000);//输出结果
	return 0;
}


```