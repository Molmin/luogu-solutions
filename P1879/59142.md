（非新手向，只是看到似乎没人用记搜，代码也比较长才发的这个）

像这样的状压dp题能用公式填表当然也能用记搜啦~本蒟蒻~~不会递推所以~~比较喜欢记搜

直接上代码吧，很短的，注释打上去了，有疑问欢迎骚扰~~

```cpp
//以下的状态i（或者类似表达）的意思是，将i转化为二进制数后，在1的位置种东西，0的位置不种东西。eg.状态为5（二进制表示为101）表示只有倒数第1,3个位置种草的状态，
#include<cstdio>
#include<cstring>
#define N 12
#define MOD 100000000
int a[N+1];//把每一行肥沃程度压缩成二进制数存储
long long ans[N+2][1<<N];//f[i][j]表示第i行状态为j时其下面几行的总方案数
int n,m;
int dfs(int cur,int p)//正在处理第cur行，上一行状态为p 
{
	if(ans[cur][p])return ans[cur][p];//记忆化搜索核心，搜过的就不搜了，掉了这句会严重超时
	if(cur==n+1)return 1;//已经搜完了一遍，找到了一种方案
	bool book[1<<N];//标记本次搜索中哪些状态已经搜过，由于后期枚举第cur行的合法状态的时候要把不肥沃的地方置零，因此我们在枚举1~1<<n的时候很有可能枚举到一个已经算过的状态，结果会因为重复计算而偏大。具体解释见下方注释。
	memset(book,0,sizeof(book));//初始化
	for(int i=0;i<1<<m;i++)
	{
		if(i&(i<<1)||i&p)continue;//i&(i<<1)==true则表示当前枚举到的状态中有相邻的草，不合法。i&p表示与上面一行的某一块草地相邻，也不合法。两种情况都跳过。
		int t=i&a[cur];//这就是上文提到的把能种草的地方过滤出来，细细一想book的作用就体现出来了。比如当i=2或7时，表示状态分别为10和111，倒数第二位都种上了，当这一行的肥沃程度为010时，i=2与i=7两次都搜到了010，重复计算结果偏大。
		if(book[t])continue;//已经搜过的就跳过
        //此时搜到的状态t就是合法的
		ans[cur][p]+=dfs(cur+1,t);ans[cur][p]%=MOD;//累加方案数并取模，因此函数返回值不必用long long 
		book[t]=true;//标记已经搜过
	}
	return ans[cur][p];
}
int main()
{
	int i,j,t;
	scanf("%d%d",&n,&m);
	for(i=1;i<=n;i++)
		for(j=1;j<=m;j++)
			{scanf("%d",&t);a[i]<<=1;a[i]|=t;}//二进制存图
	printf("%d",dfs(1,0));//上一层状态为0，第一层的搜索不受影响，dfs(1,0)计算出来的自然就是总方案数了
    return 0;
}
```
30ms，还行QWQ