这是个裸状压题，真的很水。。。
 
题目大致意思是说有一块地，每一格都是一块正方形的土 地（什么鬼），有许多奶牛（我也不知道有多少 QAQ ,反正 有很多很多奶牛，一定比地多）。
 
有些地不能用，相当于不能放牛。并且，奶牛们喜欢独占一 块地的感觉（地主），所以两头奶牛不能相邻。
 
在不相邻的情况下，有许多可行方案，当然也可以选择不 放奶牛。问有多少种可行方案。


**从问题与结果出发**

可以很轻松地知道，我们要求的是在第M行、最后一个状 态时，前M行所有可行方案之和。
 
分解成每一个阶段，我们要求的就是第 i 行、第 j 个状态 时，前 i 行所有可行方案之和。
 
于是我们定义一个 f 数组，由于 f[i][j]肯定是从第i-1行转移过来的，所以我们必须在第0行,第1个状态时就要赋好初始值。
 
f[0][0]= 1; / / 第一个状态从下标0开始

**如何找到可行状态？**

我们第一眼看到这题的思路应该是暴力搜索，去以实际 的空间去一步一步搜索回溯。这个思路也是对的。 其实动规与暴搜的思路差不多。只需要判断与左右和上 一行是否冲突。 我们在判断这个状态是否成立的时候，状态被二进制压 缩了，所以位置本身是否可行，就也要用二进制表示。于 是定义一个 map 数组用二进制存储。 用来判断的时候只需要取反即可。 

```cpp
for(int i=1;i<=m;i++)
	for(int j=1;j<=n;j++){
    x=read();
    map[i]=(map[i]<<1)+x; 
 }
```

上代????:

```cpp
//luogu 1879
#include<bits/stdc++.h>
using namespace std;
int n,m,ans,x,mod=1e8;
int mapp[20],f[20][4100];
int read(){
    int x=0,f=1;char ch=getchar();
    while(!isdigit(ch)){if(ch=='-')f=-f;ch=getchar();}
    while(isdigit(ch)){x=x*10+ch-48;ch=getchar();}
    return x*f;
}
signed main(){
    m=read();n=read();
    for(int i=1;i<=m;i++){
        for(int j=1;j<=n;j++){
            x=read();mapp[i]=(mapp[i]<<1)+x;
        }
    }
    f[0][0]=1;
    for(int i=1;i<=m;i++) {
        for(int j=0;j<=(1<<n)-1;j++){
            if(!(j&(j<<1))&&!(j&(j>>1))&&!(j&(~mapp[i]))){
                for(int k=0;k<=(1<<n)-1;k++){
                   if(!(k&(k<<1))&&!(k&(k>>1))&&!(k&(~mapp[i-1]))&&!(j&k)) f[i][j]+=f[i-1][k];
                }
            }
        }
    }
    for(int i=0;i<=(1<<n)-1;i++) ans+=f[m][i];
    printf("%d",ans%mod);
    return 0;
}

```

