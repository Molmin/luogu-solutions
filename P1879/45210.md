解题思路:按照刚才我说的,题目中的m,n最大都只有12,我们要很快想到状压dp,那么如何状压呢?其实状压dp就是一种枚举,是最暴力的一种dp.

在题目中,有1的地方就可以种植,否则不行,在不考虑时间复杂度的情况下,我们是不是会想到打暴搜,枚举每一种情况,如果一块地上已经种了草,那么上下左右就都不能种了.我们经这种思路转化成二进制,1代表在这块地上种植,0代表不种,例如:010就代表在第二块地种植,其他地都不种.

我们枚举每一行的状态,在左右不相邻的情况下,再判断下一行不和本行状态冲突的状态(如:第一行是0 1 0,第二行是0 1 0就冲突了,即上下行同一位置不能同时种植),这样我们只需要预处理出第一行的状态就可以递推出其他行的所有满足条件的状态个数了

下面来分析一下题目样例

1 1 1

0 1 0

第一行满足条件的状态有

1	000

2	100 　

3	010

4	001

5	101

第二行满足条件的状态有

1	000

2	010

根据乘法原理有5*2=10种方法,但其中一种第一行0 1 0和第二行0 1 0是冲突的,所以结果为10-1=9种方案

设计dp数组的状态,状压dp状态应该还是比较好设计的,本题为dp[i][state[j]]表示到第i行到第j种状态满足条件的方案数

满足无后效性原则,下一行的状态只能由前一行转移过来

dp[i+1][state[j]]+=dp[i][state[k]] state[k]表示第i行满足条件的状态

总结一下思路：先枚举第一行，把所有可能的状态和第一行的题目所给环境对比，如果成功，则在循环里继续枚举第二行，把所有可能的状态和第二行的环境对比，如果成功，再和第一行填入的状态对比，如果又匹配成功，则dp[2][000] = dp[2][000] + dp[1][100];方法数加到第二行。这就是一次循环结束了，重新枚举第二行...

欢迎大家来踩博客[real_l](https://www.cnblogs.com/real-l/p/8562834.html)
 