这题我写+调一整天终于搞出来了，心累啊……发篇题解梳理一下，也希望能帮到各位。

## 题意

现在有两个人轮流从 $n$ 瓶被标号为 $0,1,...,n-1$ 的巧克力豆中取豆子，第 $i$ 个瓶子中装有 $p_i$ 颗巧克力豆。每一轮每人选择 $3$ 个瓶子，标号为 $i,j,k$ 并要保证 $i< j,j\leq k$ 且第 $i$ 个瓶子中至少要有 $1$ 颗豆子，随后这个人从第 $i$ 个瓶子中拿走一颗豆子并在 $j,k$ 中各放入一粒豆子，问先手是否有必胜策略，如果有则输出第一步操作中字典序最小的一组解和总方案数，没有则输出输出用一个空格两两隔开的三个 $-1$ 。

## 分析

我们可以在模 $2$ 的意义下考虑所有的巧克力豆，因为后手必须模仿先手的操作。

为什么后手必须模仿先手的操作呢？因为如果本来是先手必败状态，先手操作一次后后手不去模仿，先手就可以再操作一次变成后手的必败状态。

因为这题中每个瓶子不是互相独立的，所以不好用 $SG$ 定理，因为不独立时 $SG$ 定理不成立。我们可以把每个豆子看作这题的基本单位，也就是一个游戏，这样每个游戏之间就是完全独立的了。

接下来按照规则取豆子时我们可以看作把$i$里的一个豆子变成了两个豆子放到 $j,k$ 里，所以我们可以枚举 $i$ 里的豆子放到哪两个$j,k$里再对它们取一个 $mex$ ，这样我们就可以 $O(n^3)$ 求出 $SG$ 值了。

求方案数和第一步解直接暴力枚举就可以了，当进行第一步操作后，后手的状态是必败态即可。

## 代码

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
int t,n,a[100],cnt,flag,sg[100],ans,vis[100];
void qiu_sg(){//求SG
	for(int i=n;i>=1;i--){//因为SG值由后续状态推出，所以从n到1循环
		memset(vis,false,sizeof(vis));
		for(int j=i+1;j<=n;j++){
			for(int k=j;k<=n;k++){
				vis[sg[j]^sg[k]]=true;
			}
		}
		int t=0;
		while(1){
			if(!vis[t]){
				sg[i]=t;
				break;
			}
			t++;
		}
	}
}
int main(){
	scanf("%d",&t);
	while(t--){
		scanf("%d",&n);
		for(int i=1;i<=n;i++){
			scanf("%d",&a[i]);
		}
		qiu_sg();
		ans=cnt=flag=0;
		for(int i=1;i<=n;i++){
			if(a[i]%2){//只有豆子为奇数的瓶子有贡献
				ans^=sg[i];
			}
		}
		for(int i=1;i<=n;i++){
			if(!a[i]) continue;//没豆子就没的可取
			for(int j=i+1;j<=n;j++){
				for(int k=j;k<=n;k++){
					if((sg[i]^sg[j]^sg[k])==ans){//让后手必败就是让SG值为0，因为先手操作一步让整个游戏的SG变成0之后后手就会变成先手，SG值为0就是对于当前先手的必败状态，也就是原来后手的必败状态
						cnt++;
						if(!flag){
							flag=1;
							printf("%d %d %d\n",i-1,j-1,k-1);
						}
					}
				}
			}
		}
		if(!flag){
			printf("-1 -1 -1\n");
		}
		printf("%d\n",cnt);
	}
	return 0;
}
```
