这是一道很考验编程能力的题目，本蒟蒻的方法是先找到一个‘y’，再向8个方向扩张（预处理一个表（花了我半个小时）），如果符合单词‘yizhong’，就标记经过的点，最后输出

附pascal标程

```cpp
var n,i,j,k,l:longint;
    a:array[-5..355,-5..355]of char;
    f:array[-5..355,-5..355]of boolean;
    d:array[1..8,1..6,1..2]of longint=(
    ((-1,0),(-2,0),(-3,0),(-4,0),(-5,0),(-6,0)),
    ((-1,1),(-2,2),(-3,3),(-4,4),(-5,5),(-6,6)),
    ((0,1),(0,2),(0,3),(0,4),(0,5),(0,6)),
    ((1,1),(2,2),(3,3),(4,4),(5,5),(6,6)),
    ((1,0),(2,0),(3,0),(4,0),(5,0),(6,0)),
    ((1,-1),(2,-2),(3,-3),(4,-4),(5,-5),(6,-6)),
    ((0,-1),(0,-2),(0,-3),(0,-4),(0,-5),(0,-6)),
    ((-1,-1),(-2,-2),(-3,-3),(-4,-4),(-5,-5),(-6,-6)));//d[i,j,1]表示从原坐标到第i个方向第j个x坐标需要增加（或减少）的值，d[i,j,2]则是y坐标需要增加（或减少）的值
begin
  readln(n);
  for i:=1 to n do
  begin
    for j:=1 to n do
    read(a[i,j]);//读入
    readln;
  end;                                   
  for i:=1 to n do//暴力四重循环搜索。。。
  for j:=1 to n do
  if a[i,j]='y'then//如果这个点的字符是‘y’
  for k:=1 to 8 do
  if(a[i+d[k,1,1],j+d[k,1,2]]='i')and(a[i+d[k,2,1],j+d[k,2,2]]='z')
  and(a[i+d[k,3,1],j+d[k,3,2]]='h')and(a[i+d[k,4,1],j+d[k,4,2]]='o')
  and(a[i+d[k,5,1],j+d[k,5,2]]='n')and(a[i+d[k,6,1],j+d[k,6,2]]='g')//判断是否符合单词‘yizhong’
  then
  begin
    f[i,j]:=true;//先要标记
    for l:=1 to 6 do
    f[i+d[k,l,1],j+d[k,l,2]]:=true;//把单词每个字母的坐标在布尔数组里标记
  end;
  for i:=1 to n do
  begin
    for j:=1 to n do
    if f[i,j]then//如果这个字母在单词中
    write(a[i,j])//输出字母
    else
    write('*');//否则输出‘*’
    writeln;//记得换行
  end;
end.
```