近段时间比较忙 也没多少时间写程序 我在这也就有一点的优化方案放上来 过一段时间等我把这题A了我在把代码贴上来：

首先这道题算法为纯搜索，当然啦这肯定的

1、首先在读入和输出当中我们可以做一些处理，例如我们可以开2 个数组，一个记录初识状态并且用于搜索 另一个记录输出状态即最终答案 读一个判断一个，如果不是那个单词中的字母那么就在另一个数组中相应的位置直接变成‘\*’号 并且读入的时候可以直接记录一下y的位置在接下来的搜索中会方便很多



```cpp
for i:=1 to n do for j:=1 to n do b[i,j]:='*';
    word:=['y','i','z','h','o','n','g'];
    readln(n);
    for i:=1 to n do
    begin
     for j:=1 to n do
     begin
       read(a[i,j]);
       if a[i,j] in word then b[i,j]:=a[i,j] else b[i,j]:='*';
       if a[i,j]='y' and (k=1)then begin inc(k); x:=i; y:=j; end;
     end;
     readln;
    end;
```
2、关于找方向，那么个人是建议用一个二维常量数组定义起来循环找方向，在搜索的参数表中可以加入搜索的层数和方向，这样总归处理起来会方便很多  然后在下面就直接按照那样搜索就好了
3、在搜索的时候一个比较强力的剪枝

判断这行中还有多少个数没搜，搜索的字符串中还有多少的字母没有搜，如果没搜的字母比后面的要多那么久直接往下一层跳 例如当数据是这样的时候：


asdyizhong

aisuizhong

asdkjnaedj

asdjnfeank

yizhongask

iasdjiongaz

zhongyizho

haskdjongo

ongjasdjkhh

naskdjhasj

gasdjkzhong(随意打的，可能有偏差反正大致就这个意思了啦）


数据是这样的时候这一步剪枝或许也蛮强的


总而言之

先隐去不是字母的

读入时记录y的坐标然后搜索方便

搜索时如上面的强力剪枝

然后慢慢处理最后这道题相信最后的用时应该是很短的

这真的是非常棒的一道练习搜索的好题

在这里可以练习剪枝什么的，反正都加油啦
