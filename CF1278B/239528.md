 _（为小白准备的简单易懂题解）_ 如果感觉其他的题解有些费脑，那这里咱们就从头来分析一遍哦。

### 题意：

给定 $a$、$b$，能进行无数次操作，对于第 $i$ 次操作可以往 $a$ 或 $b$ 上加 $i$（例如，第$1$次向某个数上加$1$，第$2$次向某个数上加$2$，以此类推，第 $n$ 次向某个数上加数字 $n$ ），直到加上某个数后 $a$ 和 $b$ 相等。求能使两数相等的最少步骤数。
### 分析：

首先，大部分人可能会像我一样，第一反应会认为是每一步都向较小数上进行加操作。但是很快我们就能举出反例：

 $a=1$，$b=3$。

 对于这两个数，我们最少步骤为：

 第一步在 $a$ 上加1，这时 $a=2$,$b=3$。

 第二步却是在较大数 $b$ 上加$2$，这时 $a=2$,$b=5$。

 第三步在 $a$ 上加$3$，$a=b=5$，求得最少步骤数为$3$，结束。

那么这样看来，具体第几个数要加在哪里就很玄学，让人摸不到头脑，不着急，咱们来再从头分析一下。

最初，我们对较小数进行加操作是为了缩小 $a$ 与 $b$ 的差，最终使 $a$ 等于 $b$。那么，我们就先不考虑在每一步中哪个数较小，而来考虑较本质的问题：第 $i$ 个数与 $a$ 和 $b$ 的差的关系。

这里，我们默认 $a$ 小于 $b$，那么 $a$ 和 $b$ 的差就为 $b-a$。咱们像别的题解一样，也来画个图看看。就以$1$和$3$为例，我们也把数字模拟为线段，将数一直向 $a$ 上加。
![](https://cdn.luogu.com.cn/upload/image_hosting/xw8w5h2t.png)

为什么我们在加完第$2$步后 $a$ 已经超过 $b$ 了，却没有停止呢？为什么我们加完$3$后又停止了呢？为什么我们要把$2$这个数分配到 $b$ 上去呢？

**为什么呢？这里看，$a$ 加$1$后仍比 $b$ 小；$a$ 加完$2$后，$a$、$b$ 差为$1$；$a$ 再加完$3$，$a$、$b$ 差为$4$！这时，我们是把$4$整除$2$得到的$2$移到了 $b$ 上。（大家可以多找几个数来自己模拟一下）几步模拟下来，我们的思路有点明确了，一直向 $a$ 进行加操作，一直加到 $a$ 大于等于 $b$，如果 $a$ 等于 $b$，问题就解决了；如果 $a$ 大于 $b$，那就把多出来那块平分！如果多出来的是奇数（无法被$2$整除），那就再加数加到多出来的部分为偶数，解决了！！**

所以，我们就从$1$枚举，while 的循环条件为 ```（a<b||(a-b)%2!=1）```
，意思就是，只要 $a$ 小于 $b$ 或 $a$ 大于 $b$ 但 $a$ 与 $b$ 的差不为偶数，那就还要接着枚举，直到满足条件，这时就是正确答案了！

接下来就是代码了，这里有个问题，我们前面的分析是默认 $a<b$ 的，所以我们对于每个 $a$ 和 $b$ 还要判断一下，不符合条件就互换，始终要使加法操作前的 $a<b$。

```
#include<bits/stdc++.h>
using namespace std;
int main()
{
	long long n,a,b;
	cin>>n;
	for(int j=1;j<=n;j++)
	{
	cin>>a>>b;
	int i=0;
	if(a>b)
	swap(a,b);	
	while(a<b||(a-b)%2)//找到第一个满足条件的i
	{
		i++;
		a+=i;  
	}
    cout<<i<<endl;}
}
```
简单明了吧！最后，再解释一下为什么我们只要多出来的部分是偶数就一定可以平分掉：

对于加到第 $i$ 步后，$a>b$，需要平分的情况，多出来的部分 $c$ 是一定小于 $i+i+1$ 的，否则就不是最优解了。
而我们平分的部分就是 $\frac{c}{2}$，奇数不能被$2$整除，所以 $c$ 一定要是偶数，而 $\frac{c}{2}$ 就是是肯定小于等于 $i$ 的正整数，所以在 $i$ 之前，我们一定在 $a$ 上加过能凑成 $\frac{c}{2}$ 的数，进而就把这些数转移到 $b$ 上就行了。


