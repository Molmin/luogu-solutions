## 一、前言

本题算是 **区间dp** 的经典模型了，写篇题解讲讲这种套路。

## 二、题意

有一个长度为 $n$ 的初始序列，你每次可以将一段区间变为同一种颜色，后加的颜色会覆盖原先的颜色。问最少涂几次色能变成目标序列。

## 三、思路

首先很明显是 dp 了。一看 **题目所求**：最小值，是 dp 常见的题目类型（最优解）；二看 **数据范围**： $1 \leq n \leq 300$，非常适合 dp。再一看是在区间上操作，区间 dp 就呼之欲出了。

1. **状态**

	既然是区间 dp，那么状态显然是跟 **区间** 相关的，同时我们还要将状态表示成题目所求。设 $f_{i,j}$ 为变成区间 $i \sim j$ 最少要涂几次。
    
2. **转移**

	通过模拟样例我们容易发现，当出现两端颜色相同的情况时，比如说：
    
| $1$ | $2$ | $1$ |
| :----------: | :----------: | :----------: |

我们就不需要涂 $3$ 次，而只需要涂 $2$ 次。为什会这样呢？因为事实上，后面涂的颜色会覆盖原来的颜色，所以两边的颜色其实相当于是顺带的（可以理解为附赠品），并不需要刻意去涂。而由于大区间是由小区间转移而来，因此在中间找一个中转点。因此得到转移方程：

$$\left\{\begin{matrix}
f_{i,j}=\min(f_{i+1,j},f_{i,j-1}) \ (a_i=a_j)& \\ 
f_{i,j}=\min_{k=i}^{j-1}f_{i,k}+f_{k+1,j} (a_i \ne a_j)& 
\end{matrix}\right.$$

3. **初始化**

$$f_{i,i}=1$$

## 四、代码

```cpp
#include<bits/stdc++.h>
using namespace std;

const int N=307;
int n,a[N],f[N][N];

int main()
{
	memset(f,64,sizeof(f));
			
	scanf("%d",&n);
	
	for(int i=1;i<=n;i++)
		scanf("%d",&a[i]),f[i][i]=1;
	
	for(int len=2;len<=n;len++)
		for(int i=1;i+len-1<=n;i++)
		{
			int j=i+len-1;
			if(a[i]==a[j])
				f[i][j]=min(f[i+1][j],f[i][j-1]);
			for(int k=i;k<j;k++)
				f[i][j]=min(f[i][j],f[i][k]+f[k+1][j]);
		}
	
//	for(int i=1;i<=n;i++)
//		for(int j=1;j<=n;j++)
//			printf("%d %d %d\n",i,j,f[i][j]);
	printf("%d",f[1][n]);
	return 0;
}
```
