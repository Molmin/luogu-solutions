## 题意归纳：

给定一个长度为 $N$ 且数字只会为 $1$ 到 $N$ 的数列，每次可以选取一个子区

间，将其变为任意的数字，数列初始状态为全零，求变为目标状态的最少次数。

## Solution：

先分析一下，需要求的是最小变换次数，每次选择变换区间时，有许多不同的选择

方式，这提示我们要用区间 $DP$ 。

按照一般的区间题的套路，设 $f[i][j]$ 为将区间 $[i,j]$ 变换至目标区间的最

小变换次数，那么最后的答案就是 $f[1][n]$ 了，考虑如何转移。

注意到，如何变换肯定与序列中的数字是有关的，具体地，与区间两端点的数字是有关的，那么我们可以写出如下方程。

设区间两断点值是 $a,b$ 。

当 $a=b$ 时，$f[i][j]=min(f[i+1][j],f[i][j-1])$ ，也就是在第一次整体变换

时把其中一个端点一起变换了，显然是不影响次数的，于是二者取最优即可。

当 $a≠b$ 时，$f[i][j]=min(f[i][k]+f[k+1][j])$ ，枚举一个断点 $k$ ，前面

为一段，后面为一段分开变换即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[1005],f[1005][1005]; 
int main()
{
    scanf("%d",&n);
    memset(f,127/3,sizeof(f));
    for(int i=1;i<=n;i++)
    {
    	scanf("%d",&a[i]);
    	f[i][i]=1;
	}
	for(int l=2;l<=n;l++)
	{
		for(int i=1;i+l-1<=n;i++)
		{
			int j=i+l-1;
			if(a[i]==a[j])
			{
				f[i][j]=min(f[i+1][j],f[i][j-1]);
			} 
			else
			{
				for(int k=i;k<=j-1;k++)
				{
					f[i][j]=min(f[i][j],f[i][k]+f[k+1][j]);
				}
			}
		}
	}
	cout<<f[1][n];
    return 0;
}
```


