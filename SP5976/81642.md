这道题并不难。

### 解法1：                                                             


进行暴力模拟，最后得出答案时间复杂度O(T * n * m)，肯定过不了。

### 解法2（正解）:
首先看n与m相等的情况，这时广场是一个正方形，每次绕完一整圈方向肯定是朝右的，这是等于绕一个边长为n-2的正方形。

所以当n与m相等情况，只有两种输出，一种是当n不是2的倍数时(每次边长建2，最后只剩一个边长为1的正方形)，答案是朝右的，输出R。另一种情况，n是2的倍数时(同理，最后只剩一个边长为2的正方形)，答案是朝左的，输出L。


------------

解决了n与m相等的情况，我们来看n与m不相等的情况。同样我们每次围着广场绕一整圈，使广场变成一个宽为n-2,长为m-2的小广场，最后也只有两种情况。

1.n与m较小的数不是2的倍数,最后只剩一个宽为1的长方型。这样不论长是多少，如果长方形是横着的(n<m)，肯定是朝右的，如果长方形是竖着的(n>m)，肯定是朝下的。

2.n是2的倍数，最后只剩一个宽为2的倍数的长方形。同理，如果长方形是横着的(n<m)肯定朝左。如果长方形是竖着的，肯定朝上。


------------
### 代码
    #include<bits/stdc++.h>
    using namespace std;
    int main()
    {
    	int T,n,m;
    	cin>>T;
    	for(int i=1;i<=T;i++)
    	{
    		cin>>n>>m;
    		int mi=min(n,m);//求较小数
    		if(mi%2==1)
    		{
			    if(n<=m)cout<<'R'<<endl;else
    			cout<<'D'<<endl;
	        	}else
    		{
			    if(n<=m)cout<<'L'<<endl;else 
	       	                cout<<'U'<<endl; //各种情况，如上面解释
	        	}
	        }
            return 0;
    }

