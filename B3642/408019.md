# B3642 二叉树的遍历 題解

**管理员注：**

阅读本文章前，请先阅读[$ \ \texttt{ShanCreeper}$ B 题库题解的声明](https://www.luogu.com.cn/blog/Ru19Free/AboutBProblem)，并了解由于课程需要不展示 C++ 代码。

**如需系统学习相关知识点请报名【[洛谷-基础算法计划](https://class.luogu.com.cn/)】**



***

首先你要知道什么是树。

树形结构：

- 不仅能表示数据间的指向关系；
- 还能表示出数据层次关系；

例如一棵树：

![](https://cdn.luogu.com.cn/upload/image_hosting/4d18etw0.png)

不好意思，放错了，是这棵树：

![](https://cdn.luogu.com.cn/upload/image_hosting/mm0ivcwi.png)


这种结构成为**树**，树有以下概念：

- 结点：这颗树上的每一个数字都是一个**结点**；
- 根结点：这棵树的最顶端叫做**根结点**；
- 叶子节点：除了根结点的节点都是**叶子结点**；

- 父结点：一个结点能指向另一个结点的结点叫做**父结点**；
- 兄弟结点：若干个结点同时拥有同个**父结点**的结点叫做**兄弟结点**；
- 子结点：父结点指向的那个结点叫做**子结点**；
- 祖先：一个结点的父结点及其所有父结点都为该结点的**祖先**；
- 子树：以该结点的子结点为根结点的树叫做**子树**。

可能讲的有点抽象，大概能理解就行了。

***

那么这道题问的是二叉树，那什么是二叉树呢？

**二叉树**是树的一种，是每个结点都**不超过两个子结点**的树。

二叉树的每个结点，可能有：

- **左子结点**和**左子树**；
- **右子结点**和**右子树**；

***

好接下来讲这道题。

对于任意给定结点，可以访问**该结点本身**、**遍历左子树**、**遍历右子树**。

我们就可以分为**前序遍历**、**中序遍历**、**后序遍历**。

**前序遍历**（先序遍历）：

- 先访问**根节点**；
- 然后访问**左子树**；
- 最后访问**右子树**。


例如这棵：

![](https://cdn.luogu.com.cn/upload/image_hosting/kvjugl4m.png)


我们按照**根左右**的顺序遍历：

- 先访问**根结点**，**1**；
- 访问**左子树**，即以 2 为根结点的树：
	- 先访问**根结点**，**2**；
    - 访问**左子树**，即以 3 为根结点的树：
    	- 先访问**根结点**，**3**；
        - 访问**左子树**，即以 4 为根结点的树：
        	- 先访问**根结点**，**4**；
            - 无左子树、无右子树，该树**遍历完成**。
        - 访问**右子树**，即以 5 为根结点的树：
        	- 先访问**根节点**，**5**；
            - 无左子树、无右子树，该树**遍历完成**。
        - 根左右遍历完成，该树**遍历完成**。
    - 访问**右子树**，即以 6 为根结点的树：
    	- 先访问**根结点**，**6**；
        - 无左子树、无右子树，该树**遍历完成**。
    - 根左右遍历完成，该树**遍历完成**。
- 访问**右子树**，即以 7 为根结点的树：
	- 先访问**根结点**，**7**；
    - 根左右遍历完成，该树**遍历完成**。
    
就是这么遍历的，所以前序为 $1 \ 2 \ 3 \ 4 \ 5 \ 6 \ 7 $。

中序遍历为：先遍历**左子树**，然后为**根结点**，最后遍历**右子树**。

后序遍历为：先遍历**左子树**，然后遍历**右子树**，最后为**根结点**。

***

所以（嘿嘿嘿我放非 C++ Code）：

**前序遍历**：

- 首先输出根结点，即 $x$；
- 然后遍历左子树，即 $\text{tree}_i.\text{left}$；
- 最后遍历右子树，即 $\text{tree}_i.\text{right}$；


```go
func pre_order(x int){
	fmt.Print(x)
	if tree[x].left==0{
		pre_order(tree[x].left)
	}
	if tree[x].right==0{
		pre_order(tree[x].right)
	}
}
```

注意，当左子树和右子树存在时，才能继续递归。

**中序遍历**：

- 首先遍历左子树；
- 然后输出根结点；
- 最后遍历右子树；

```go
func in_order(x int){
	if tree[x].left==0{
		in_order(tree[x].left)
	}	
	fmt.Print(x)
	if tree[x].right==0{
		in_order(tree[x].right)
	}
}
```

**后序遍历**：

- 首先遍历左子树；
- 然后遍历右子树；
- 最后输出根结点；

```go
func post_order(x int){
	if tree[x].left==0{
		post_order(tree[x].left)
	}
	if tree[x].right==0{
		post_order(tree[x].right)
	}
	fmt.Print(x)	
}
```