状压+卡常题。其实思维难度不高，所以这篇题解主要来宣传卡常手法了（

[Tips]首先你需要熟悉状压DP需用到的位运算操作

-----

$\Large\textbf{思路}$

$n\le 24$ 几乎就是在暗示我们用状压DP  
使用的数的集合可以用24位无符号整数表示  
设 $f_i$ 为已使用的数的集合为 $i$ 时合法的方案数，为了判断合法，我们再设 $a_i$ 表示已使用的数的总和。  

转移：枚举 $i$ 去掉一个数后还原成的所有集合 $k$（就是二进制表达下去掉一个1），则 $f_i=\sum f_k$ 。  
利用`lowbit`可以很容易地实现  
计算 $a_i$ 比较方便的一种写法是 `a[i]=a[i^lowbit(i)]+a[lowbit(i)]` 。  
$m$ 很小，判断是否合法的耗时可以忽略不计

时间复杂度 $\Theta(n2^n)$  
用计算器算一算就可以知道最坏情况下要运算约4e8次，所以下面我们来谈一谈卡常。

（如果你只是来看个思路，下面的东西你都可以不看了）

-----

$\Large\textbf{有理有据的底层优化}$

篇幅所限，这里不能系统地介绍卡常方法，所以就给几个比较常用的优化套路吧

### 需要知道的C++特性（奇怪的知识）（可跳过）

 - 一个赋值的表达式除了赋值，也会返回这个值。比如 `if (a=1) ...` 等价于 `a=1; if (1) ...`  
 - 形如 `a,b,...,f;` 的式子也有返回值 `f` 
 - `a&&b` 执行时，如 `a=0` ，则**不再计算b**，直接结束。`a||b` 同理。因此 `&&` 和 `||` 被称为短路运算

### 短路运算&三目运算优化if（奇怪的知识）（可跳过）

`if` 的速度比较慢，对于简单的`if`语句，可以用短路运算或三目运算代替。注意并不是说要完全抛弃if  

下面给出几个经典的套路。

```cpp
int sth;
void work() { ... }
int solve() { ... }

...

if (sth) work(); // sth&&(work(),0);
if (sth) solve(); // sth&&solve();
if (!sth) work(); // sth||(work(),0);
if (!sth) solve(); // sth||solve();
if (sth) work(); else solve(); // sth?work(),0:solve();
```

注释内容为优化后的写法。这种写法不仅拥有更快的速度，而且也使语句可以进行更灵活、精巧的组合。  
短路运算要求操作数均为整型，三目运算 `a?b:c` 要求a为整型，b,c同类型。  
为了利用它们加速，有时可以通过补0的方式转变类型。  
顺便说一句，不推荐 `(int)sth` 这样的强制转换，太慢了

### inline&register优化

`inline` 将函数变为内联函数，往往具有不错的效果，但函数本身过于复杂时可能会适得其反。对于函数体较大、循环次数较多的函数不建议使用。（度自己把控吧，我也没找到确定的界限）

`register` 可将变量存入寄存器，从而大幅提升速度。但是注意寄存器非常小，最多存几个循环变量，不要什么都往里面放  
松氏基排的原理也与它类似，通过调整数组大小使数组卡进cache，从而可能获得更快的速度。

另外有听说过register将来会去世的说法。不过平时做题还是照样用吧

### 火车头

这里并不是让你用市面上流传甚广的那个40行火车头。看着厉害其实平均质量不高，除非你能保证你的程序复杂到所有的优化都有用武之地  
较为通用、实用的优化是O2,O3,Ofast。个人喜欢用O2和Ofast

手动开启方法分别如下：

```cpp
#pragma GCC optimize(2)
#pragma GCC optimize(3)
#pragma GCC optimize("Ofast")
```

同时洛谷也提供了O2优化的功能，可以不手动开。  
另外，这三个优化存在改写循环、删除冗余语句等行为，如果你的代码不够规范，可能造成速度变慢，甚至出现错误。  
除非是实在卡不过去，或者测试速度，平时不建议滥用。更不能在考场上用，没多少加分的指望，而且负面效果不可预测。

别的就不讲了，下面代码涉及到的似乎就这么多

----

$\Large\textbf{代码}$

（可跳过）
 
```cpp
#include<cstdio>
const int P=1000000007,N=(1<<24); 
int n,m,s,t,x1,x2,a[N],f[N];
inline void add(int x) { (s+=x)>=P&&(s-=P); } 
inline int lb(int x) { return (-x&x); }
int main() {
	scanf("%d",&n); n=(1<<n),f[0]=1;
	for (int i=1; i<n; i<<=1) scanf("%d",a+i);
	scanf("%d",&m),m&&scanf("%d",&x1),m>1&&scanf("%d",&x2);
	for (int i=1; i<n; ++i,s=0) {
		if ((a[i]=a[i^(t=lb(i))]+a[t])==x1) continue;
		if (m>1&&a[i]==x2) continue;
		for (int j=i; j; j^=t) add(f[i^(t=lb(j))]);
		f[i]=s;
	}
	printf("%d",f[n-1]);
	return 0;
}
```

你可能感觉看不懂，主要是因为代码较多地利用了短路运算和赋值表达式的返回值。不过这些优化学会之后是真的很实用，并且属于对C++语言特性的利用，无需考虑玄学风险。 

----

$\Large\textbf{后话}$

这里有个双倍经验：[P2396](https://www.luogu.com.cn/problem/P2396)

抽象之后模型是一模一样的。。  
理论上把代码复制过去就能AC了，但实际上那题要毒瘤一些

最暴力的方法是直接加O2/Ofast，可以水过去  
但如果你认为这种方法~~谁不会，有本事自己写啊~~太水了，也可以通过一般的卡常方法卡过去

（记得挑个评测量小的时间段交