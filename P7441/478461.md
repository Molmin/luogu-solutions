### 做题前要知道的：
负数的价值是肯定用不上的，并且答案最多只有 $\dfrac{K}{\max(x,y)}$ 个。
### 思路：
显然，有一些部分落叶（或雪花）是没有用的（当 $x$ 不等于 $y$ 时）。也就是说，我们只要关注那些大的落叶（或雪花）即可。

即关注 $x*(x-y+1),x*(x-y+2)\cdots$ 和 $y$ 的全部。（以下证明前提条件均为$x\leq y$）

#### 举个例子：
拿这组样例说：
```
1
3 4 10
```
我们只要关注 $6,9$ 和 $4,8$。

（$x\leq y$ 且 两个数都不为 $0$ ）按照贪心的思想，应该让大的配小的才能配对次数多一些。$x$ 组最后一个数是 $K-K \bmod x$ 这时 $y$ 组的第一个为 $y$ ，因为 
$y\geq x$ ，所以 $y\geq K \bmod x$ ，所以第一组可以，后面每一组和都会加 $y-x$ ，所以后面的组肯定可以，也就是说一共有 $\dfrac{K}{y}$ 组。

但如果你真就按这个思路交了上去，恭喜错3个点。

为什么会错3个点呢，因为忽略了 $0$。

显然，~~粗鄙之语~~当有一组为 $0$ 时， 其他一组必须最大数是 $K$ 时，才能成功一次。也就是判断能不能整除。

知道这些点以后，这题就特别简单了。
### 插一句，别忘开 $\texttt{long long}$
# 代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	int t;
	cin>>t;
	while(t--){
		long long x,y,k;
		scanf("%lld%lld%lld",&x,&y,&k);
        if(x==0||y==0){//特判0
            if(x&&!(k%x))
                puts("1");
            else if(y&&!(k%y))
                puts("1");
            else
                puts("0");
        }
        else
			printf("%lld\n",k/max(x,y));
	}
	return 0;
}
```
~~这是红题就离谱~~

~~麻烦管理再审一下，我补充了一些东西，谢谢~~