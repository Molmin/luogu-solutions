# 这一道题的主要思路是：搜索+模拟

模拟部分：

数独大家应该都玩过，不懂的话看这$\downarrow$

$$\large\textbf{数独的规则}$$
$$\begin{matrix} |\ \ \ \ \text{在一个9}\times\text{9的方格中，给你一些数字，你需要将它填满，}\ \ |\\|\text{使每行，每列，以及每一个3}\times\text{3的小方格中的9个数不重复。}|\end{matrix}$$
$$$$


规则看完后，我们开始模拟。

------------
## $\textbf{模拟部分}$

设$h[i][j]$表示第$i$行的$j$这个数有没有出现过。

$l[i][j]$表示第$i$列的$j$这个数有没有出现过。

$lb[i][j]$表示第$i$个小方格中$j$这个数有没有出现过。

于是我们就需要计算一下一个点在哪一个小方格中。大佬的经验告诉我们，用坐标算会死的很惨。所以我们可以开一个数组$m$.

$m[i][j]$表示$(i,j)$这个点所在小方格的编号。

```cpp
//应该可以看懂
int m[9][9]={1,1,1,2,2,2,3,3,3,
             1,1,1,2,2,2,3,3,3,
             1,1,1,2,2,2,3,3,3,
             4,4,4,5,5,5,6,6,6,
             4,4,4,5,5,5,6,6,6,
             4,4,4,5,5,5,6,6,6,
             7,7,7,8,8,8,9,9,9,
             7,7,7,8,8,8,9,9,9,
             7,7,7,8,8,8,9,9,9,
             };
```


------------
## 搜索部分
使用$posi[i]$表示第$i$个空方格的横坐标，$posj[i]$表示第$i$个空方格的纵坐标坐标。

读入时存储一下，再用$dfs(0)$开始搜索即可，比较好理解

更多详见注释。

```cpp

#include<bits/stdc++.h>
using namespace std;
int a[9][9],h[10][10],l[10][10],lb[10][10],posi[100],posj[100],top=0;
int m[9][9]={1,1,1,2,2,2,3,3,3,
             1,1,1,2,2,2,3,3,3,
             1,1,1,2,2,2,3,3,3,
             4,4,4,5,5,5,6,6,6,
             4,4,4,5,5,5,6,6,6,
             4,4,4,5,5,5,6,6,6,
             7,7,7,8,8,8,9,9,9,
             7,7,7,8,8,8,9,9,9,
             7,7,7,8,8,8,9,9,9,
             };
void prt(){
    for(int i=0;i<9;i++){
        for(int j=0;j<9;j++)
            printf("%d ",a[i][j]);
        printf("\n");
    }
}
void dfs(int dep){
    if(dep>top) prt(),exit(0);//数独已经填满
    int i=dep;
    for(int j=1;j<=9;j++){//轮流枚举1~9。高能警告
        if(h[posi[i]][j]/*j在当前行存在*/||l[posj[i]][j]/*j在当前列存在*/||lb[m[posi[i]][posj[i]]][j]/*j在当前小方格存在*/)continue;
        else{
            a[posi[i]][posj[i]]=j;//填上一个数
            h[posi[i]][j]=l[posj[i]][j]=lb[m[posi[i]][posj[i]]][j]=1;//更新标记
            dfs(dep+1);//继续往下搜
            a[posi[i]][posj[i]]=0;//搜完回来清零
            h[posi[i]][j]=l[posj[i]][j]=lb[m[posi[i]][posj[i]]][j]=0;//清零标记
        }
    }
    
}
int main(){
    for(int i=0;i<9;i++)for(int j=0;j<9;j++){
        scanf("%d",&a[i][j]);
        if(!a[i][j]) posi[++top]=i,posj[top]=j;//记录坐标
        else h[i][a[i][j]]=l[j][a[i][j]]=lb[m[i][j]][a[i][j]]=1;//该数已存在
    }
    dfs(1);
    return 0;
} 
```