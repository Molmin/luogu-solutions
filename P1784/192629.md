## 思路

这道题可以用DFS做，从左上到右下搜索每一个格子。如果数字不为0则跳过，为0则寻找合适的答案，然后记得要回溯。当达到边界时，输出即可。

## 实现

可以用bool数组来记录此行（列）（宫）出现过的数字，而且定义一个int类型的二维数组判断是哪个宫的。

```cpp
int a[12][12], m[12][12] = {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
							{0, 1, 1, 1, 2, 2, 2, 3, 3, 3},
							{0, 1, 1, 1, 2, 2, 2, 3, 3, 3},
							{0, 1, 1, 1, 2, 2, 2, 3, 3, 3},
							{0, 4, 4, 4, 5, 5, 5, 6, 6, 6},
							{0, 4, 4, 4, 5, 5, 5, 6, 6, 6},
							{0, 4, 4, 4, 5, 5, 5, 6, 6, 6},
							{0, 7, 7, 7, 8, 8, 8, 9, 9, 9},
							{0, 7, 7, 7, 8, 8, 8, 9, 9, 9},
							{0, 7, 7, 7, 8, 8, 8, 9, 9, 9}};
bool flag1[12][12], flag2[12][12], flag3[12][12];
```

定义后进行深搜。

```cpp
void dfs(int x, int y)
{
	if(x == 10 && y == 1)//如果到达边界
	{
		for(int i = 1;i < 10;i++)//则输出
		{
			for(int j = 1;j < 10;j++)
				cout << a[i][j] << " ";
			puts("");
		}
		return;
	}
	int xn = x, yn = y + 1;//向右搜索一个格子
	if(yn == 10)//如果到达边界，则换行
	{
		xn++;
		yn = 1;
	}
	if(a[x][y] != 0) dfs(xn, yn);//如果这个格子已经填数，则搜索下一个
	else 
	{
		for(int i = 1;i <= 9;i++)//循环寻找答案
		{
			if(flag1[x][i] == 0 && flag2[y][i] == 0 && flag3[m[x][y]][i] == 0)//如果这个数字在此行此列此宫都没有出现过
			{
				a[x][y] = i;//填入
				flag1[x][i] = 1;//记录已经出现
				flag2[y][i] = 1;
				flag3[m[x][y]][i] = 1;
				dfs(xn, yn);//继续深搜
				a[x][y] = 0;//进行回溯
				flag1[x][i] = 0;
				flag2[y][i] = 0;
				flag3[m[x][y]][i] = 0;
			}
		}
	}
}
```

然后就完成啦。

完整版code

```cpp
#include<cstdio>
#include<iostream>
using namespace std;

int a[12][12], m[12][12] = {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
							{0, 1, 1, 1, 2, 2, 2, 3, 3, 3},
							{0, 1, 1, 1, 2, 2, 2, 3, 3, 3},
							{0, 1, 1, 1, 2, 2, 2, 3, 3, 3},
							{0, 4, 4, 4, 5, 5, 5, 6, 6, 6},
							{0, 4, 4, 4, 5, 5, 5, 6, 6, 6},
							{0, 4, 4, 4, 5, 5, 5, 6, 6, 6},
							{0, 7, 7, 7, 8, 8, 8, 9, 9, 9},
							{0, 7, 7, 7, 8, 8, 8, 9, 9, 9},
							{0, 7, 7, 7, 8, 8, 8, 9, 9, 9}};
bool flag1[12][12], flag2[12][12], flag3[12][12];

void dfs(int x, int y)
{
	if(x == 10 && y == 1)
	{
		for(int i = 1;i < 10;i++)
		{
			for(int j = 1;j < 10;j++)
				cout << a[i][j] << " ";
			puts("");
		}
		return;
	}
	int xn = x, yn = y + 1;
	if(yn == 10)
	{
		xn++;
		yn = 1;
	}
	if(a[x][y] != 0) dfs(xn, yn);
	else 
	{
		for(int i = 1;i <= 9;i++)
		{
			if(flag1[x][i] == 0 && flag2[y][i] == 0 && flag3[m[x][y]][i] == 0)
			{
				a[x][y] = i;
				flag1[x][i] = 1;
				flag2[y][i] = 1;
				flag3[m[x][y]][i] = 1;
				dfs(xn, yn);
				a[x][y] = 0;
				flag1[x][i] = 0;
				flag2[y][i] = 0;
				flag3[m[x][y]][i] = 0;
			}
		}
	}
}

int main()
{
	for(int i = 1;i < 10;i++)
		for(int j = 1;j < 10;j++)
		{
			cin >> a[i][j];//循环输入
			int g = m[i][j];//g为a[i][j]所在的宫
			if(a[i][j] != 0)//如果已经填数
			{
				flag1[i][a[i][j]] = 1;//记录已出现
				flag2[j][a[i][j]] = 1;
				flag3[g][a[i][j]] = 1;
			}
		}
	dfs(1, 1);//从左上角第一个进行深搜
 	return 0;//结束程序
}

```