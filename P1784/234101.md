### 这道题普通搜索也能过
本蒟蒻想法：记录所有的空格子的坐标到数组

然后用桶来判重

但是，粗线格怎么判重呢？

首先粗线格有九个

![](https://cdn.luogu.com.cn/upload/image_hosting/2xcqicae.png)

为了方便，我们开一个【0-3】【0-3】的数组

怎么判断坐标x1,y1在哪个粗线格里呢？

是x1/3 y1/3 里吗，不是

于是，应该调整为（x1-1）/3+1 (y1-1)/3+1

代码（满分），有解释：

```cpp
#include<iostream> 
using namespace std;
int t1[100][100],t2[100][100],t3[20][20][20],i,j,k,x1[1000],y1[1000],n=9,a[100][100];
//t1对行判重，t2对列判重,t3对粗线格判重
bool p;
inline void dfs(int b)//当前已经填好了b格
{
	int i,j;
	if (x1[b]==100&&y1[b]==100)//填完了
	{
		for (i=1;i<=n;++i){
		for (j=1;j<n;++j)
		cout<<a[i][j]<<" ";
		cout<<a[i][n]<<endl;
	}
	p=1;//找到一个正确答案
	}
	if (p) return;//如果有答案了，退出，节省时间
	for (i=1;i<=9;++i)
    //
	{
    
		if (t1[x1[b+1]][i]==0&&t2[y1[b+1]][i]==0&&t3[(x1[b+1]-1)/3+1][(y1[b+1]-1)/3+1][i]==0)
		{
		t1[x1[b+1]][i]=1;//行
		t2[y1[b+1]][i]=1;//列
		t3[(x1[b+1]-1)/3+1][(y1[b+1]-1)/3+1][i]=1;//边界
		a[x1[b+1]][y1[b+1]]=i;
		dfs(b+1);
		a[x1[b+1]][y1[b+1]]=0;
		t1[x1[b+1]][i]=0;
		t2[y1[b+1]][i]=0;
		t3[(x1[b+1]-1)/3+1][(y1[b+1]-1)/3+1][i]=0;	
		if (p)return;
		}
	}
}
int main()
{
	for (i=1;i<=9;++i)
	for (j=1;j<=9;++j)
	{
		cin>>a[i][j];
		if (a[i][j]==0)
		{
        //如果是空的，那么记录行列坐标
			++k;
			x1[k]=i;
			y1[k]=j;
            
		}
		else
		{
        //如果有数
			t1[i][a[i][j]]=1;
         //标记行
			t2[j][a[i][j]]=1;
            //标记列
			t3[(i-1)/3+1][(j-1)/3+1][a[i][j]]=1;
            //标记粗线格
		}
	}
	x1[k+1]=100;
	y1[k+1]=100;
	//边界
	dfs(0);
   //从0开始很重要，否则第一个空格会跳过
}
```
