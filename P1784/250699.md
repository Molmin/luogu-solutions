适合萌新看，代码难度比较低，说明一下如何判断一个数字是否在一个大九宫格内重复出现，设九宫格序号从左往右为012，345，678.九宫格序号=行序号/3*3+列序号/3；因为我这里下标是从0开始的，从1开始就不一样了，这个可以画个图推一下。
```
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
int mp[10][10],vx[10][10],vy[10][10],vc[10][10];//mp存每个框里的数，vx存行上的数，vy存列上的数，vc判断一个大九宫格里有没有重复数字。
void dfs(int x,int y)//x，y为坐标
{
	if(x==9)//到达边界，我是从0开始读入的，所以最后一行的下标是8，x==9时说明填完了，又从下一行开始搜索了，这时候直接输出数独表就行了。
	{
		for(int i=0;i<9;i++)
		{
			for(int j=0;j<9;j++)
			{
				cout<<mp[i][j]<<" ";
			}
			cout<<endl;
		}
		return;
	}
	if(y==9)//我是一行一行搜索的，第一行搜索完的时候最后一列下标是8，y==9时说明这一行已经搜索完了，开始搜索下一行，即dfs(x+1，0)。
	{
		dfs(x+1,0);
	}
	if(mp[x][y])//如果这一个格子有数字了，所以不需要填，从下一列开始搜索
	{
		dfs(x,y+1);
	}
	else for(int i=1;i<=9;i++)//依次枚举1-9
	{
		if(!vx[x][i]&&!vy[y][i]&&!vc[x/3*3+y/3][i])//如果这一行没有i，这一列也没有i，并且i没有在这个九宫格里出现过，那么当前可以选择这个数（不过不能确定是这个数）
		{
			vx[x][i]=1;
			vy[y][i]=1;
			vc[x/3*3+y/3][i]=1;
			mp[x][y]=i;
			dfs(x,y+1);//从下一列开始搜索
			vx[x][i]=0;//回溯
			vy[y][i]=0;
			vc[x/3*3+y/3][i]=0;
			mp[x][y]=0;
			
		}
	}
}
int main()
{
	for(int i=0;i<9;i++)//读入数独表，同时标记
	{
		for(int j=0;j<9;j++)
		{
			cin>>mp[i][j];
			vx[i][mp[i][j]]=1;
			vy[j][mp[i][j]]=1;
			vc[i/3*3+j/3][mp[i][j]]=1;
		}
	}
	dfs(0,0);
	return 0;
} 