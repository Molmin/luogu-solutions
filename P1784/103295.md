本蒟蒻第一次发题解，多多包涵。

经典的深搜，比较简单，分两部分说

一.主程，读入，再命名一个flag数组标记即可


二.dfs函数，这里用一维变量，从左上到右下扫一遍（不用剪枝，数据很小）
   
   1.先判断要不要操作（有没有值）
   
   2.出口（即扫完了）
   
   3.开始用行列九宫格扫，由于是一维，还要生成x，y来代表行列。九宫格打表生成
   
   4.回溯。
   
   
   
   
**在讲一哈深搜b**（资料来自度娘）

深度优先搜索属于图算法的一种，英文缩写为DFS即Depth First Search.其过程简要来说是对每一个可能的分支路径深入到不能再深入为止，而且每个节点只能访问一次；
采用的搜索方法的特点是尽可能先对纵深方向进行搜索。

深度优先遍历图的方法是，从图中某顶点v出发：

（1）访问顶点v；

（2）依次从v的未被访问的邻接点出发，对图进行深度优先遍历；直至图中和v有路径相通的顶点都被访问；

（3）若此时图中尚有顶点未被访问，则从一个未被访问的顶点出发，重新进行深度优先遍历，直到图中所有顶点均被访问过为止。

**再附个基本模板**

void DFS ( int n )

{

     if ( 满足结束条件,即搜索到终点 )
     
         return ;
         
     else
     
         DFS ( n + 1 );
}

**上代码**


#include<bits/stdc++.h>

using namespace std;

int a[10][10];

int m[10][10]={

	{0,0,0,0,0,0,0,0,0,0},
    {0,1,1,1,2,2,2,3,3,3},
    {0,1,1,1,2,2,2,3,3,3},
    {0,1,1,1,2,2,2,3,3,3},
    {0,4,4,4,5,5,5,6,6,6},
    {0,4,4,4,5,5,5,6,6,6},
    {0,4,4,4,5,5,5,6,6,6},
    {0,7,7,7,8,8,8,9,9,9},
    {0,7,7,7,8,8,8,9,9,9},
    {0,7,7,7,8,8,8,9,9,9}
};

bool f1[10][10],f2[10][10],f3[10][10];

void dfs(int t)
{
   
   if(t>81) {
   
    	for(int i=1;i<=9;i++){
        
	       for(int j=1;j<=9;j++){
           
		      cout<<a[i][j]<<" ";
		   }
           
		   cout<<endl;
	       
	    }  
	       return ;
           
	}  
	int x=(t-1)/9+1;
    
	int y=(t-1)%9+1; 
    
    if(a[x][y]){
    
    	dfs(t+1);
        
    	return ;
        
	}
	for(int i=1;i<=9;i++){
    
		if(!f1[x][i]&&!f2[y][i]&&!f3[m[x][y]][i]){
        
			a[x][y]=i;
            
			f1[x][i]=f2[y][i]=f3[m[x][y]][i]=true;
            
			dfs(t+1);
            
			a[x][y]=0;
            
			f1[x][i]=f2[y][i]=f3[m[x][y]][i]=false;
            
		}
	} 
    
}
int main(){

	for(int i=1;i<=9;i++)
    
	   for(int j=1;j<=9;j++){
       
	   	    cin>>a[i][j];
            
	   	    if(!a[i][j]) continue;
            
	   	    else{
	   	  	    f1[i][a[i][j]]=true;
                
				f2[j][a[i][j]]=true;
                
		    	f3[m[i][j]][a[i][j]]=true;
                
		    }
	   }
       
	dfs(1);
	       
	return 0;
}