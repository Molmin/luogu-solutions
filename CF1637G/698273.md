### 前言

此篇文章着重于代码实现而非证明，如果需要明白为什么最终答案一定是大于等于 $n$ 的第一个 $2$ 的正整数幂次可以看小粉兔的题解。

那么现在请记住这个结论：最终所有数一定都是大于等于 $n$ 的第一个 $2$ 的正整数幂次。

### 构造

令 $x$ 为大于等于 $n$ 的第一个 $2$ 的正整数幂次。

定义一个 $Merge$ 函数。

```
Dot Merge(int a,int b,int op)
{
	ans.push_back(Dot(a*op,b*op));
	return Dot(abs(a-b),a+b);
}
```

返回值为一对数字，参数为进行操作的 $2$ 个数字和倍数参数 $op$（在后面介绍）。

每次调用这个函数都要把操作过程记录下来，因为最后要输出操作过程。

#### 简单情况

若现在只剩下 $0$ 和 $2$ 的正整数幂次，如何构造使得所有数都变成 $x$？

对于一个 $2$ 的正整数幂次 $a$，先执行操作 $(0,a)$ 可以得到 $(a,a)$，再执行操作 $(a,a)$ 可以得到 $(0,2a)$，即 $a$ 变成了 $2a$。

由于所有数全都是 $2$ 的幂次，所以经过上述操作很多次后所有数依然为 $2$ 的幂次。每个数可以通过不超过 $\log_2 x$ 次操作变成 $x$，所以操作次数不会太多。

最后执行操作 $(0,x)$ 即可将 $0$ 变为 $x$，达到目标。

此部分代码：

```
for(int i=1;i<x;i++)
{
	while(Cnt[i])
	{
		Merge(0,i,1);
		Merge(i,i,1);
		Cnt[i]--;
		Cnt[2*i]++;
	}
}
Merge(x,0,1);
```

其中 $Cnt_i$ 表示 $i$ 有多少个。

#### 普遍情况

考虑将 $1$ 至 $n$ 的所有非 $2$ 正整数幂次的数通过操作变为 $2$ 的正整数幂次。暂时没有通用方案能够 $O(n)$ 构造完成的，考虑**尽可能多**的凑出 $2$ 的正整数幂次。

在考虑构造的时候发现很奇妙的性质是，如果以小于 $n$ 的最大 $2$ 的正整数幂次作为中轴，向外等距离的两个数字操作一次可以产生 $1$ 个 $x$ 和一段从 $2$ 开始的连续的偶数，且剩下的数为从 $1$ 开始的连续自然数。

举例：

```
n=13
{1,2,3,4,5,6,7,8,9,10,11,12,13}
x=16
中轴：8
配对(7,9)(6,10)(5,11)(4,12)(3,13)
得到：
{16,16,16,16,16}
{2,4,6,8,10}
{1,2}
{8}
```

由上可得若按照这样方式分组将会得到 $4$ 组，分别为：

* 全 $x$ 组，有 $n-\frac{x}{2}$ 个 $x$。
* 连续偶数组：为 $1$ 至 $n-\frac{x}{2}$ 的整数同时乘了个 $2$。
* 连续自然数组：从 $1$ 至 $x-n-1$。
* 中轴：$\frac{x}{2}$

发现这个东西可以递归处理。

如何处理连续偶数组？事实上是一样的，不过 $Merge$ 的时候的倍数参数要乘以 $2$。

具体实现需要在递归函数里传一个当前倍数参数就好。

注：

* 递归到 $n\leq2$ 时则已经全是 $2$ 的正整数幂次，则直接返回。

* 递归到 $n$ 为 $2$ 的正整数幂次时不需要考虑 $n$，直接考虑 $n-1$。

具体代码如下：

```
void Solve(int N,int op)
{
	if(N<=2)
	{
		return;
	}
	if((N&(N-1))==0)
	{
		Solve(N-1,op);
		return;
	}
	int Mid=0;
	while((1<<Mid+1)<N)
	Mid++;
	Mid=(1<<Mid);
	for(int i=1;Mid+i<=N;i++)
	{
		Merge(Mid+i,Mid-i,op);
	}
	Solve(2*Mid-N-1,op);
	Solve(N-Mid,op*2);
}
```

执行完 $Solve$ 函数后，模拟一遍 $Merge$ 的过程即可得到简单情况。

再按照简单情况的构造方法处理即可。

