今天刷题时，无意间见到了这题，就顺便把它刷了。在题解区逛了一圈，发现各位神犇们都在推柿子，找规律。本蒟蒻是一点都看不懂。所以，我看了看数据，发现用模拟也可以解决这题。
### 思路：
我们可以通过读题目发现：如果有多组答案，那只要输出任意一种即可。因此，我们直接从左上角开始放盘子。每放一个盘子，就把它周围的八个格子占领。只要在边缘发现没被占领的格子（即为 $0$ ），就在这里放一个盘子，再把他周围八个格子占领。重复上述步骤，直到没有格子可放为止。然后输出整个数组。注意：我这里占领的地方的话是用负数的方式表现的，而题目要求没盘子的地方输出 $0$，所以输出时特判一下就行了。

### 代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
int i,t,j,n,m,a[102][102];
void zhanling(int x,int y) //占领周围八个格子
{
	if(x-1>=1&&y-1>=1) a[x-1][y-1]--;
	if(x-1>=1) a[x-1][y]--;
	if(x+1<=n&&y-1>=1) a[x+1][y-1]--;
	if(x+1<=n) a[x+1][y]--;
	if(y+1<=m&&x+1<=n) a[x+1][y+1]--;
	if(y+1<=m) a[x][y+1]--;
	if(x-1>=1&&y+1<=m) a[x-1][y+1]--;
	if(y-1>=1) a[x][y-1]--;
}
bool pd(int x,int y) //判断周围八个格子有没有其它盘子
{
	if(a[x+1][y]!=1&&a[x][y+1]!=1&&a[x-1][y]!=1&&a[x][y-1]!=1&&a[x+1][y+1]!=1&&a[x+1][y-1]!=1&&a[x-1][y+1]!=1&&a[x-1][y-1]!=1) return 1;
	return 0;
}
int main()
{
	ios::sync_with_stdio(false);  //去同步，加速cin，cout
	cin>>t;
	while(t--){
		memset(a,0,sizeof(a)); //因为是多组数据，记得初始化
		cin>>n>>m;
		a[1][1]=1; //左上角开始
		zhanling(1,1);
		for(i=1;i<=n;i++)
			for(j=1;j<=m;j++){
				if(!(i==1||j==1||i==n||j==m)) continue; ///如果不是边缘就跳过
				if(a[i][j]==0&&pd(i,j)){ //判断当前位置有没有被占领，以及周围八个位置有有没盘子
					a[i][j]=1;//放置盘子
					zhanling(i,j);
                               }
			}
		for(i=1;i<=n;i++){
			for(j=1;j<=m;j++) 
				if(a[i][j]<0)cout<<"0";  //题目要求空着的输出0
				else cout<<a[i][j];
			cout<<'\n';
		}
		cout<<'\n';
	}
    return 0;
}
```
