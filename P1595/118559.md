# 前言

看各位dalao洋洋洒洒写一大堆，真心表示叹服……可是真的需要这么复杂么？



-------------------------------------------华丽的分割线--------------------------------------------

# 题目简介

这个问题推广一下，就是错排问题，是组合数学中的问题之一。考虑一个有n个元素的排列，若一个排列中所有的元素都不在自己原来的位置上，那么这样的排列就称为原排列的一个错排。 n个元素的错排数记为D(n)。 研究一个排列错排个数的问题，叫做错排问题或称为更列问题。

错排问题最早被尼古拉·伯努利和欧拉研究，因此历史上也称为伯努利-欧拉的装错信封的问题。这个问题有许多具体的版本，如在写信时将n封信装到n个不同的信封里，有多少种全部装错信封的情况?又比如四人各写一张贺年卡互相赠送，有多少种赠送方法?自己写的贺年卡不能送给自己，所以也是典型的错排问题。



------------
# 方法介绍

当n个编号元素放在n个编号位置，元素编号与位置编号各不对应的方法数用D(n)表示，那么D(n-1)就表示n-1个编号元素放在n-1个编号位置，各不对应的方法数，其它类推.

第一步，把第n个元素放在一个位置，比如位置k，一共有n-1种方法;

第二步，放编号为k的元素，这时有两种情况:⑴把它放到位置n，那么，对于剩下的n-1个元素，由于第k个元素放到了位置n，剩下n-2个元素就有D(n-2)种方法;⑵第k个元素不把它放到位置n，这时，对于这n-1个元素，有D(n-1)种方法;



------------
# DUANG！公式！

综上可得

D(n) = (n-1) [D(n-2) + D(n-1)]

D(n) = (n-1) [D(n-2) + D(n-1)]

特殊地，D(1) = 0, D(2) = 1.

下面通过这个递推关系推导通项公式:

为方便起见，设D(k) = k! N(k), k = 1, 2, …, n,

则N(1) = 0, N(2) = 1/2.

n ≥ 3时，n! N(n) = (n-1) (n-1)! N(n-1) + (n-1)! N(n-2)

即 nN(n) = (n-1) N(n-1) + N(n-2)

于是有N(n) - N(n-1) = - [N(n-1) - N(n-2)] / n = (-1/n) [-1/(n-1)] [-1/(n-2)]…(-1/3) [N(2) - N(1)] = (-1)^n / n!.

因此

N(n-1) - N(n-2) = (-1)^(n-1) / (n-1)!,

N(2) - N(1) = (-1)^2 / 2!.

相加，可得

N(n) = (-1)^2/2! + … + (-1)^(n-1) / (n-1)! + (-1)^n/n!

因此

D(n) = n! [(-1)^2/2! + … + (-1)^(n-1)/(n-1)! + (-1)^n/n!].

此即错排公式。


------------

------------
# 容斥原理

用容斥原理也可以推出错排公式:

正整数1, 2, 3, ……, n的全排列有 n! 种，其中第k位是k的排列有 (n-1)! 种;当k分别取1, 2, 3, ……, n时，共有n*(n-1)!种排列是至少放对了一个的，由于所求的是错排的种数，所以应当减去这些排列;但是此时把同时有两个数不错排的排列多排除了一次，应补上;在补上时，把同时有三个数不错排的排列多补上了一次，应排除;……;继续这一过程，得到错排的排列种数为

D(n) = n! - n!/1! + n!/2! - n!/3! + … + (-1)^n*n!/n! = ∑(k=2~n) (-1)^k * n! / k!,

即D(n) = n! [1/0! - 1/1! + 1/2! - 1/3! + 1/4! + ... + (-1)^n/n!].

其中，∑表示连加符号，k=2~n是连加的范围;0! = 1，可以和1!相消。



------------
# 样例对照

怕不对？这里有答案，让你随便对！（因为怕有人打表，所以只列出1~10）

D(0) = 1(所有的元素都放回原位、没有摆错的情况)

D(1) = 0(只剩下一个元素，无论如何也不可能摆错)

D(2) = 1(两者互换位置)

D(3) = 2(ABC变成BCA或CAB)

D(4) = 9

D(5) = 44

D(6) = 265

D(7) = 1854

D(8) = 14833

D(9) = 133496

D(10) = 1334961



------------
# 终极BOSS：代码！

翻了这么久，终于来正经的啦！

11行代码，炒鸡简单！

当然，想用容斥做的宝宝们得自己去打啦~反正都有公式啦~

```
#include<bits/stdc++.h>
using namespace std;
long long d[30],n;
int main(){
    cin>>n;
    d[0]=1; d[1]=0;
    for(int i=2;i<=n;i++)
    d[i]=(i-1)*(d[i-1]+d[i-2]);
    cout<<d[n];
    return 0;
}
```



