## (A) 整数范围

难度：约入门。

### 题目大意

求**八位无符号整型**能表示的最大值。

### 思路分析

相当于求 $11111111_{(2)}$ 的十进制值，得 $255$。

## (B) 带宽

难度：约入门。

### 题目大意

求 $200 \text{Mb}$ 相当于多少 $\text{MB}$。

### 思路分析

注意 $\text{Mb}$ 指的是 $\text{Megabit}$，是 $\text{Megabyte}$ 的 $\dfrac 1 8$。则答案为 $200 \times \dfrac 1 8 = 25$。

## (C) 纯质数

难度：入门～普及-，只是我的代码执行的有点慢……

### 题目大意

求 $1 \ldots 20,210,605$ 中有多少个**每一位（十进制）都是质数**的数，且这个数本身**也要是质数**。

### 代码分析

通过逐个判断质数，可以写出如下代码：

```cpp
#include <bits/stdc++.h>
using namespace std;

bool is_prime(int x) { // 判断质数，也可以用筛的，供读者自行实现
    for (int i = 2; i * i <= x; i++)
        if (!(x % i)) return 0;
    return 1;
}

int main() {
    int cnt = 0;
    for (int i = 2; i <= 20210605; i++) {
        if (is_prime(i)) {
            for (int tmp = i; tmp; tmp /= 10)
                if (tmp % 10 != 2 && tmp % 10 != 3 && tmp % 10 != 5 && tmp % 10 != 7) // 目前这一位不是质数
                    goto not_prime; // 用 goto 来跳过 cnt++;
            cnt++;
        }
        not_prime:;
    }
    cout << cnt;
}
```

通过老爷机上 $15.36$ 秒的执行，得出答案 $1903$。

## (D) 完全日期

难度：约普及-。

### 题目大意

定义「完全日期」为一个日期的年、月、日的**各位数字**之和是**完全平方数**。求从 $2001$ 年 $1$ 月 $1$ 日至 $2021$ 年 $12$ 月 $31$ 日中有多少个「完全日期」。

### 代码分析

可以通过逐个枚举日期各位之和来求个数。

另外，可以使用 `std::map` 来判断是否是完全平方数，由于日期之和不可能很大，所以稍微打表几个就 Okay 了。

```cpp
#include <bits/stdc++.h>
using namespace std;

const int days[13] = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}; // 每一月的天数
map<int, int> pf = {
    {1, 1}, {4, 1}, {9, 1}, {16, 1}, {25, 1}, {36, 1}, {49, 1}
}; // 完全平方数，如果 x 不是完全平方数的话 pf[x] 自动返回 0

int day(int y, int m) { // 根据年份、月份求天数，此处略过
    if (m != 2) return days[m];
    return days[2] + (!(y % 400) || y % 100 && !(y % 4));
}

int main() {
    int cnt = 0;
    for (int i = 2001; i <= 2021; i++) // i、j、k 逐个枚举日、月、年
        for (int j = 1; j <= 12; j++)
            for (int k = 1; k <= day(i, j) /* 注意要判断天数 */; k++)
                if (pf[i / 1000 + i % 1000 / 100 + i % 100 / 10 + i % 10
                    + j / 10 + j % 10
                    + k / 10 + k % 10]) cnt++;
    cout << cnt;
}
```

最后答案：$977$。

## (E) 最小权值

难度：稍微超过普及-。

### 题目大意

对一棵有根二叉树，设当前这个节点为 $v$，定义其权值为：

1. 若是空子树，权值 $W(v) = 0$；
2. 否则，有左子树 $l$（有 $C(l)$ 个节点）和右子树 $r$（有 $C(r)$ 个节点），权值 $W(v) = 1 + 2W(l) + 3W(r) + C(l)^2 \cdot C(r)$。

### 代码分析

虽然说了「二叉树」，但此题可以**不用**二叉树的办法来求。

因为一个节点的权值只与其左子树和右子树相关，所以可以用 dp 来做。

```cpp
#include <bits/stdc++.h>
using namespace std;

long long f[2030];

int main() {
    memset(f + 1, 0x3f, sizeof(f) - sizeof(long long));
    // 注意！上面的 memset 不赋 f[0]！！
    // 此处的大小也应是 f 的大小减一个 long long 的大小。
    f[1] = 1; // 初始化
    for (int i = 2; i <= 2021; i++)
        for (int j = 0; j < i; j++)
            f[i] = min(f[i], 1 + 2 * f[j] + 3 * f[i - j - 1] + j * j * (i - j - 1)); 
            // 代入求权值公式，i 和 i - j - 1 相当于是左右子树
    cout << f[2021];
}
```

得出答案 $2653631372$。

The End!