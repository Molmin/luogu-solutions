## 题解

不难发现答案与$n$无关

在一条直线上似乎很难计算，我们可以把它转化一下：

> 在~~单位~~圆上随机取$k+1$个点，分成的$k+1$段拼起来能否组成多边形

由对称性不难发现上面的题目跟原题答案一样，但是却更方便求解

组不成多边形时当且仅当分成的一小段占了圆周的$\frac{1}{2}$（半圆）

那么另外$k$个点就分布在了另外半圆上，而每个点分布在那里的概率为$\frac{1}{2}$，故由乘法原理知总概率为$\frac{1}{2^k}$

到底选哪一个段去~~作死~~站在（或者说是躺在）半个圆周上呢，显然有$k+1$种

故组不成多边形的概率即为$\frac{k+1}{2^k}$

那么组不成的概率就是$1-\frac{k+1}{2^k}$了，即$\frac{2^k-k-1}{2^k}$

注意：

1. 原题多组数据，输出还有格式要求

2. 注意输出为分数，且为最简分数

3. 因为$k\leq{50}$，超过了$32$，故要开$long\ long$

---

## 代码

```cpp
#include<cstdio>
int t;
long long k,x,y,z;
long long gcd(long long a,long long b) //求最大公约数（约分用）
{
	return b==0ll? a:gcd(b,a%b);
}
int main()
{
	scanf("%d",&t);
	for(register int i=1;i<=t;++i) //多组数据
	{
		scanf("%lld%lld",&k,&k);
		x=(1ll<<k)-k-1ll; //如上分析的分子
		y=1ll<<k; //分母
		z=gcd(x,y); //求分子分母的最大公约数
		x/=z; //约分
		y/=z;
		printf("Case #%d: %lld/%lld\n",i,x,y); //按格式输出
	}
	return 0;
}
```