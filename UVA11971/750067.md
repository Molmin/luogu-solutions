# UVA11971 Polygon

没错，这道题又是在刘汝佳的书上看到的。

而且仅有的一篇题解的思路也跟紫皮书一致。

### 题意

给定一根长度为 $n$ 的木条，求随机选取 $k$ 个点将木条切为 $k + 1$ 段后，这些小木条能组成一个多边形的概率。

### 思路

由于这是个概率问题，所以事实上答案与 $n$ 完全无关。

我们首先要知道 $k + 1$ 条线段能组成多边形的充要条件是什么。

> 任意 $k$ 条线段之和大于第 $k + 1$ 条线段。

根据数学归纳法，上述结论显然成立。
若有任意一条边的长度超过了半周长，那么便无法构成多边形，反之，若任意一边的长度都不超过半周长，那么自然就可以构成一个多边形。

嗯？似乎问题的答案还是没有浮出水面？
我们考虑反向解决这个问题，即考虑计算不能组成多边形的概率。

由于同时最多只有一条边超过半周长，因此剩下的 $k$ 条边之和一定不会超过半周长。也就是说这 $k$ 个分割点**同时全部**位于木棍中点的左侧或右侧，这样才能保证有且仅有一条边超过半周长。不妨设全部落在左侧，一个点落在左侧的概率为 $\frac{1}{2}$，那么由乘法原理， $k$ 个点全部在中点左侧的概率为 $\frac{1}{2 ^ k}$，由于超过半周长的边共有 $k + 1$ 种选择，所以不能组成多边形的概率就为 $\frac{k + 1}{2 ^ k}$。右侧同理，得到的结果是相同的。

那么原问题的答案就为 $\frac{2 ^ k - k - 1}{2 ^ k}$。

### 代码

$k \le 50$，所以要开 ``long long``，求出答案之后记得约分。

```cpp
#include <iostream>
#include <cstdio>

using namespace std;
using ll = long long;

int n, k;
int T;
ll a, b, c;

ll gcd(ll a, ll b) {
	return b ? gcd(b, a % b) : a;
}

void solve() {
	b = 1ll << k, a = b - (k + 1);
	c = gcd(a, b);
	a /= c, b /= c;
	return;
}

int main() {
	cin >> T;
	for (int i = 1; i <= T; i++) {
		cin >> n >> k;
		solve();
		cout << "Case #" << i << ": " << a << "/" << b << endl;
	}
	return 0;
}
```
