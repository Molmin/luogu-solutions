看了前几篇题解，似乎都有点麻烦，下面是本蒟蒻的想法

## 梦雪的思路：

- $V$数组：用来存每一列最快消失的时间。

- $h$数组：用来存每一列的高度。

- $n$：列的数量。

- $s$：存最终结果。

#### 统计每一列最快能在第几次爆炸后消失。

1. 从左边开始，左边的一列都没了，下一次就能把这一列炸掉，即$ v_i=v_{i-1}+1 $。

1. 从右边开始，右边的一列都没了，下一次就能把这一列炸掉，即$ v_i=v_{i+1}+1 $。

1. 从顶端开始一直炸到底部，即$v_i=h_i$。

1. 上面三个值的最小值即每一列最快消失的速度，即$v_i=min(min(h_i,v_{i+1}+1),v_{i-1}+1)$。

1. 所有$v$的最大值即最终结果，即$s$。

## AC代码：

```
#include<bits/stdc++.h>
using namespace std;
int n,s,h[100002],v[100002];
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
		scanf("%d",&h[i]);
	v[1]=1;
	for(int i=2;i<n;i++)
		v[i]=min(v[i-1]+1,h[i]);//先比较从左边和从顶端开始
	v[n]=1;
	for(int i=n-1;i>=0;i--)
		v[i]=min(v[i],v[i+1]+1);//再比较从右边开始
	for(int i=1;i<=n;i++)
		s=max(s,v[i]);//所有v的最大值即最终结果
	printf("%d\n",s);
	return 0;
}
```

望通过QWQ