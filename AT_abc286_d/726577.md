### 简化题意

- 有 $N$ 个物品，有 $B _ i$ 个第 $i$ 种物品，第 $i$ 种物品的体积为 $A _ i$。
- 问是否能从中选出若干个物品的总和为 $X$？如果可以输出 `Yes`，不行输出 `No`。
- $1 \le N \le 50, 1 \le X \le 10 ^ 4, 1 \le A _ i \le 100, 1 \le B _ i \le 50$。

### 解题思路

我们可以把这道题看成一个多重装箱问题：有 $N$ 种物品，第 $i$ 种物品的体积为 $A _ i$，有 $B _ i$ 个第 $i$ 种物品，求能否选出若干个物品使得这些物品的体积和为 $X$。

我们设 $f[i][j]$ 为从前 $i$ 种物品中选出若干个物品使得这些物品的体积和为 $X$，$f[i][j] = 1$ 则可以，$f[i][j] = 0$ 则不行，起初 $f[0][0] = 1$，其它都等于 $0$。则 $f[i][j] = f[i - 1][j - A _ iB _ i] \big | f[i - 1][j - A _ i(B _ i - 1)] \big | \cdots \big | f[i - 1][j - A _ i] \big | f[i - 1][j]$，其中 $|$ 是逻辑或。这代表着如果可以在前 $i - 1$ 种物品的基础上选出 $0 \sim B _ i$ 个 $A _ i$ 来得到 $j$，那么 $f[i][j] = 1$；否则 $f[i][j] = 0$。

我们可以考虑优化。首先，类似多重背包，$j$ 倒序循环 $B _ i$ 次 $f[i][j] = f[i][j] \big | f[i][j - A _ i]$ 可以得到与上面相同的效果。然后可类似背包地倒序循环 $j$，可舍去第一维 $i$。

于是我们对于每一个 $i$ 可执行 $B _ i$ 次如下操作：

>  从 $X$ 到 $A _ i$ 倒序循环 $j$，然后令 $f[j] = f[j] \big | f[j - 1]$。

这样，我们得到求解此题的方法。时间复杂度为 $\text O \big (X \sum B _ i \big)$，空间复杂度 $\text O (X)$。

### AC Code

```cpp
#include <cstdio>
#define M 10005
using namespace std;

int n, m, a, b, f[M] = {1}; // f[0] = 1

int main ()
{
    scanf ("%d%d", &n, &m);
    while (n --)
    {
        scanf ("%d%d", &a, &b);
        while (b --) // 循环 B[i] 次
        {
            for (int i = m; i >= a; i --) // 倒序循环
            {
                f[i] |= f[i - a]; // f[i] = f[i] | f[i - a[i]]
            }
        }
    }
    puts (f[m] ? "Yes" : "No"); // 如果 f[m] = 1，那么可以选出若干个物品的总和为 m；否则不行
    return 0;
}
```