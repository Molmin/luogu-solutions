### 题意简述

- 有 $n$ 种纸币，其中对于第 $i(1\le i\le n)$ 种纸币，它的面值是 $a_i$ 元，我们有 $b_i$ 张这种纸币。
- 请求出在不找零的情况下，用这些纸币能否**正好**付 $x$ 元，如果能则输出 `Yes`，不能则输出 `No`。
- $1 \le n \le 50, 1\le x \le 10^4, 1\le a_i \le 100, 1\le b_i\le 50$。

### 题目分析

仔细看题可以看出，本题与动态规划中的多重背包问题比较相似，具体我们可以这样实现：

我们可以创建一个二维的数组 $f$，这个数组的每一个下标中存放一个布尔值。对于每一个下标 $i, j$，$f_{i, j}$代表使用前 $i$ 种纸币，不找零的情况下能否正好付 $j$ 元。那么问题就转化为了求 $f_{n, x}$ 的布尔值，也就是使用这全部的 $n$ 种纸币，不找零的情况下能否正好付 $x$ 元。

那么如何得到这个答案呢？

首先，我们应设计一个最初状态。显而易见地，在我们不使用任何纸币的情况下，能付的钱数只有 $0$ 元，所以我们设计的最初状态就是将 $f_{0, 0}$ 设置为 true，其他均设置为 false。

其次，我们应该设置 $n$ 个阶段，对于第 $i$ 个阶段，我们用一个变量 $j$ 枚举从 $0$ 到 $b_i$ 的每一个数，代表使用了 $j$ 张这种纸币。我们再使用一个变量 $k$ 从 $0$ 枚举到 $x$，验证在前面的基础上使用 $j$ 张该种纸币的时候，能否正好付 $k$ 元。容易得到，为了在前面的基础上使用 $j$ 张这种纸币能正好付 $k$ 元，应该使得 $f_{i-1, k - a_i\times j}$ 为真（即在加入这些纸币之前能正好付 $k-a_i\times j$ 元），才能使 $f_{i, k}$ 为真。

最后，在第 $n$ 个阶段结束以后，我们就可以得出 $f_{n, x}$ 的值，按要求输出即可。

最坏时间复杂度 $O(n\times b_i\times x)$，这种做法不会超时。

### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
#define Yes cout << "Yes"
#define No cout << "No" // 方便答案输出
const int MAXX = 1e4 + 5, MAXN = 55;
int n, x, a[MAXX], b[MAXX];
bool dp[MAXN][MAXX]; // 第 1 维最大下标为 n，第 2 维最大下标为 x
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin >> n >> x;
	for(int i = 1;i <= n;i++){
		cin >> a[i] >> b[i];
	}
	dp[0][0] = 1; // 设计初始状态
	for(int i = 1;i <= n;i++){
		for(int j = 0;j <= b[i];j++){
			for(int k = 0;k <= x;k++){ // 三重循环，前面有提到
				if(k >= a[i] * j && dp[i - 1][k - a[i] * j]){ // 前一个条件防止越界，后一个条件前文有提到
					dp[i][k] = 1;
				}
			}
		}
	}
	if(dp[n][x]){ // 求出最终答案
		Yes;
	}
	else{
		No;
	}
	return 0;
}
```