赛时最后 10s 网络爆炸，没交上去痛失 AK/fn

## 题意

- 给定一棵 $n$ 个结点的有根树，根为 $1$，每个点有一个颜色 $a_i$，$p_i$ 表示 $i+1$ 的父亲。
- 有 $q$ 次询问，每次询问给定三个正整数 $v,l,k$。
- 你需要统计出 $v$ 到根节点路径上的所有点中，每种颜色的出现次数，然后将出现次数小于 $l$ 的颜色删除。
- 求剩下的颜色中出现次数第 $k$ 少的颜色，若有多个输出任意一个，若剩下的颜色不足 $k$ 个输出 $-1$。
- $t$ 组测试，$\sum n,\sum q\leq 1e6$，$a_i,p_i,v,l,k\leq n$。

## 题解

思路比较简单，所以后面讲优化的部分可能比较多。

大致思路就是先将询问离线挂到对应节点上，然后跑一遍 dfs。

dfs 的时候维护当前结点到根的路径上每种颜色的出现次数，对于每个询问，在出现次数不小于 $l$ 的颜色中找第 $k$ 小。

每种颜色的出现次数可以开个桶直接维护，找区间第 $k$ 小可以用一些数据结构维护。

数据范围和四秒时限，容易想到大常数 $O(n\log{n})$ 或小常数 $O(n\log^2{n})$。

可以对每种出现次数开个 set 记录对应的颜色，每次修改一个颜色的出现次数时相当于将当前颜色在一个 set 中删除，丢进另一个对应的 set。

然后可以用平衡树找第 $k$ 小的出现次数，复杂度 $O(n\log{n})$。

或者可以用二分 + 权值树状数组找第 $k$ 小的出现次数，复杂度 $O(n\log^2{n})$。

现在已经足以通过本题了。但是我们发现它跑得飞慢！！1

这里给出一种小常数（？）$O(n\log{n})$ 的做法。目前在 CF 上是最优解。

实际上大概就是对上面所说的二分 + 权值树状数组的优化。

- set 是不必要的。

可以用队列/栈 + 懒删除代替。

- 二分 + 树状数组可以用树状数组上二分优化掉一只 $\log$。

容易发现出现次数不小于 $l$ 对应的总是一段后缀区间，考虑将它变成一段前缀区间。

容易想到，用 $n+1$ 减去每种颜色的出现次数，它就变成一段前缀区间了！

但是此时所求的就不是出现次数不小于 $l$ 的第 $k$ 小了。

假设之前有 $m$ 种出现次数不小于 $l$ 的颜色，那么我们转化后就变成了求第 $m-k+1$ 小。

其实刚刚我在翻提交记录的时候还看见了一种做法：

就是直接对整个树状数组查询第 $k+ \sum_{i=1}^n[tot_i<l]$ 小，其中 $tot_i$表示颜色 $i$ 的出现次数，但是还是要在树状数组上二分。

具体如何树状数组上二分和找第 $k$ 小可以参考 [P6619 冰火战士 题解](https://www.luogu.com.cn/problem/solution/P6619) 和 [这篇博客](https://www.cnblogs.com/zgmf_x20a/archive/2008/11/15/1334109.html)。

[我的代码](https://www.luogu.com.cn/paste/yjkzwzaw)是用 vector 代替了栈。

如果你被卡常了：

- 加上快读快输。

- vector 的 clear 是 $O(n)$ 的，换成 $O(1)$ 的 resize。

实测会快很多。