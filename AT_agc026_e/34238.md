先讨论只有 ``ab`` 的情况（即所有 ``a`` 都在其对应的 ``b`` 前面），注意到若序列中出现超过连续两个 ``a``，我们总能把这两个 ``a`` 后面的部分删成 ``ab``，使得字典序更大，故最后的序列必然形如 ``ababab...ab``（若干个 ``ab``），我们需要最长的这样的串，贪心取第一个即可。

再讨论只有 ``ba`` 的情况，我们令 ``b`` 为 $1$，``a`` 为 $-1$，可以发现，如果把序列划分成若干段和为 $0$ 的区间，因为每段区间的影响是独立的，我们考虑先求出每段区间的答案再合并。

下面假定我们划分的区间是极小的，也就是它除了开头和结尾的前缀和均 $\gt 0$。考虑这段区间的开头会是一段连续的 ``a`` 和一段连续的 ``b``（形如 ``bbb...aaabb...aa...``），并且 ``a`` 的个数不会多于 ``b`` 的个数。我们注意到，如果删除第一段中的 ``a``，那么必然需要将所有 ``a`` 都删除。如果不删除，那么意味着前面的 ``b`` 一个都不能删除，否则不删除的 ``a`` 会往前，使得字典序更小，但如果这端 ``a`` 之后还有新的一段 ``b`` 和 ``a``，那新的一段中的 ``a`` 实际上是会和这一段的 ``b`` 匹配的（由于前缀和 $\gt 0$），但由于 ``b`` 不能删，那么新一段的 ``a`` 也不能删。以此类推，我们发现，如果某一段 ``a`` 不删了，那么这一段往后的所有 ``a`` 都不能删。我们发现我们删的 ``a`` 只可能是一个前缀，可能的情况只有 $\mathcal O(n)$ 种，可以暴力枚举。

对于区间的合并，我们考虑如果一段最大的字典序都比后面小，那还不如整段全部删掉。于是最终的字典序一定是递减的，就可以用一个单调栈维护了。

然后对于 ``ab``，``ba`` 都有的情况，注意到 ``ab`` 如果后面有一个 ``ba``，我们起码可以把这个后缀变成 ``ba``，于是 ``ba`` 前面的 ``ab`` 全部丢掉，然后后缀的 ``ab`` 按只有的情况处理就好了。