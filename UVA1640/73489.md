这道题不能输出多余空格，可把我害惨了。

我是从多倍经验过来的，正好复习基础的数位DP。

----

### 1. 预处理

我们先允许前导0存在，用$f[i][j][p]$表示“长度为i，以j开头的所有数字里p的次数”。

当我们考虑到第i位时，枚举最高位j和次高位k（从0到9），相同的数字方案都是可以继承的，即$f[i][j][p] = \sum _{p=0} ^ 9 f[i-1][k][p]$。

除了继承以外就是新增的次数，现在的j作为最高位，那么后i-1位共$10^{i-1}$个数字最高位都多了一个j，所以j多了$10^{i-1}$个。

边界情况：$f[1][i][i] = 1$，一位数是没有次高位的，$10^0$也为1，所以这个方程可以直接处理边界。

```cpp
for (int i = 1; i <= 9; i++)
	p10[i] = p10[i-1] * 10;
for (int i = 1; i <= 9; i++)
for (int j = 0; j <= 9; j++)
{
	for (int k = 0; k <= 9; k++)
	for (int p = 0; p <= 9; p++)
		f[i][j][p] += f[i-1][k][p];
	f[i][j][j] += p10[i-1];
}
```

----

### 2. 计算

用$[1,R]$的答案减去$[1,L)$的答案就是正确答案，用一个函数计算即可。答案贡献分为3种。

- 位数小于R的所有数都是可以的，枚举小于`len(R)`的所有i和j，他们都要算入答案。但是首位不能为0，j要从1开始枚举。

- 位数等于`len(R)`，最高位小于R的最高位，从1开始枚举j，枚举到最高位即可。

- 位数等于`len(R)`，前几位都相等，第i位小于R的第i位。仍然枚举小于R对应位的j即可，但是此时不是最高位，0也要算。还有就是前几位相等的数也要算，把每个数都计算一遍即可。

比如：`23456`，当前枚举到第3位`23???`，那么第三位应该取在$[0,4)$内，2，3各出现了400次。

那么显然这个不能计算出R本身，所以$work(R+1)-work(L)$才是答案。

另外$L>R$时不是输出0，是要把两边交换。

```cpp
void work(int x, int *ans)
{
	int cx[10], len = 0;
	do {
		cx[++len] = x % 10, x /= 10;
	} while(x);//十进制分解这个数
	
	for (int i = 1; i < len; i++)
	for (int j = 1; j <= 9; j++)
	for (int p = 0; p <= 9; p++)
		ans[p] += f[i][j][p];//情况1
	for (int j = 1; j < cx[len]; j++)
	for (int p = 0; p <= 9; p++)
		ans[p] += f[len][j][p];//情况2
	for (int i = len-1; i >= 1; i--)
	{
		for (int j = 0; j < cx[i]; j++)
		for (int p = 0; p <= 9; p++)
			ans[p] += f[i][j][p];//情况3
		for (int p = len; p > i; p--)
			ans[cx[p]] += cx[i] * p10[i-1];//情况3
	}
}
```