### PART 0
众所周知，140 是一个奇妙的数字。

所以我有一个不用 ``set`` 的奇妙做法。

## PART 1
题意没什么好解释。

## PART 2
众所周知，形如 ``AAARCCC`` 这样的字符串是可以被循环利用多次的。

众所周知，如果我们对上述字符串执行操作 1，那么它会变为 ``AARCC``，可以继续利用。

但是如果对它执行了操作 2，那么它会变为 ``AAACCC``，无法继续利用。

所以众所周知，我们可以把每个**单独的** ``R`` 拎出来（像 ``AARRCC`` 这种有多个 ``R`` 的不存在 ``ARC`` 子串），求一下左边的 ``A`` 数量与右边的 ``C`` 数量再求个最小值。

这样我们就得到了这个 ``R`` 的最大利用价值，可以将它放进一个数组 $r$ 中。

## PART 3

众所周知，如果我们放任这个 ``R``，让它“自生自灭”，那么它最多只能产生 2 点贡献。

但是如果我们在操作 1 之后，不对它本身进行操作 2，而是由其它的 ``R`` 来进行，那么它还可以“苟活”一段时间，但是代替它执行“死刑”的那个 ``R`` 就死绝了。

这个做法，我们称之为“挡箭”。

它看似是没有用处的，因为虽然你对当前这个 ``R`` 多进行了一次操作 1，但是你让另一个 ``R`` 少了一次操作 1。

但是！

如果在这个整体操作中，代替当前 ``R``（设为 $R_1$）执行死刑的 ``R``（设为 $R_2$），$R_2$ 本身的最大价值就是 1 呢？

那意味着如果我们放任 $R_2$，它只会产生 1 点贡献。

但是如果我们让它不那么平平无奇地死去，而是让它代替 $R_1$ 挡一次“死刑”，那么它也产生了 1 点贡献，但是这可以让 $R_1$ 多产生 1 点贡献。

所以，我们可以在所有的 ``R`` 中，筛选出最大价值为 1 的，让它们去为最大价值更多的 ``R`` 挡死。

但是对于一个最大贡献大于 1 的 ``R``，为了节约宝贵的挡死资源，它只能接受不大于最大贡献减 2 次挡死，剩下的那两次就让它自己死掉。

举个例子：

``AAARCCCARCARC``，第一次在最左边的最大价值为 3 的那个 ``R`` 上进行操作 1，变为 ``AARCCARCARC``。

第二次我们用一个最大价值为 1 的 ``R`` 来代替它挡死，变为 ``AARCCARC``。

第三，第四次为了节约剩下的那个 ``ARC``，我们让这个 ``AARCC`` 自生自灭：

``AARCC`` $\to$ ``ARC`` $\to$ ``AC``

这样剩下的一个 ``ARC`` 就可以去为其它 ``R`` 挡死了。

## PART 4

处理出每个 ``R`` 的最大价值以后排序一下，便成了一个模拟题了。

```cpp
#include<bits/stdc++.h>
using namespace std;
int r[200001];
int n,m,i,j,k,s,ans,now;
char a[200001];
int main()
{
	scanf("%d",&n);
	scanf("%s",a);
	for(i=0;i<n;i++)
	{
		if(a[i]=='R'&&a[i-1]!='R'&&a[i+1]!='R')
		{
			k=s=0;
			j=i-1;
			while(a[j]=='A') k++,j--;
			j=i+1;
			while(a[j]=='C') s++,j++;
			r[++m]=min(k,s);//处理每个R的最大价值
		}
	}k=0;s=m;//这里我们贪心一下，默认挡箭牌优先为最大价值更多的R服务
	sort(r+1,r+m+1);
	for(i=1;i<=m;i++)
		if(r[i]==1) k++,ans++;//找出1，即“挡箭牌”的数量
    //挡箭牌挡箭时会进行一次操作2，把它产生的贡献加上
	while(r[s]>1)
	{
		now=min(r[s]-2,k);//将当前挡箭牌的数量与当前R可接受的挡箭牌数量求个min
		k-=now;s--;//指针下移，为下一个R服务
		ans+=now+2;//2是当前R最后的两次自生自灭的操作
        //每有一个挡箭牌，当前的R就可以多一次操作1
	}
	printf("%d",ans);
	return 0;
}
```
