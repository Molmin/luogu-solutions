这道题不管采用Hash，后缀数组还是自动机，网上大部分的题解都采用了关键点+调和级数这个操作。本蒟蒻想不到关键点这个操作，所以采用的是一种较为繁琐的$O(nlog^2)$做法。

首先肯定将问题转化成对于每个$i$求以$i$为边界的$AA$结构个数，当然前缀后缀分别求一遍，以下默认是前缀。

考虑形式化这个问题，对于某个前缀$i$，求所有的前缀$j(j<i)$,使得$i,j$的最长公共后缀的长度大于$j-i$，也就是$|\{j|j<i,i-j\le |Lcs(S_{1,j},S_{1,i})|\}|$

对于后缀前缀的问题，我们一般将他们放到后缀自动机的$parent$树上考虑，由于后缀自动机的$parent$树相当于是将每个前缀逆序插入$Trie$，所以某两个前缀的$Lcs$对应的就是他们$parent$树上的$Lca$。

所以转化成树上给若干个关键点（对应的是字符串的前缀），对于每个$x$,求$\{y|mx_x-mx_y\le mx_{lca(x,y)}\}$。

考虑采用树上启发式合并，对于每个节点建立一颗动态开点线段树，我们让父亲继承重儿子的线段树，把其他子树中的线段树的节点暴力插入合并。

插入某个节点的时候，考虑线段树内的节点对其的贡献，和它对线段树内节点的贡献。前者用一个区间询问即可，否则在线段树上打标记，但这个线段树要被拆开的时候再把暴力标记推下去贡献到答案上即可。

每个节点插入的之后其所在线段树大小翻倍，所以之多插入$log$次，总复杂度$O(nlog^2)$

[代码请转到原blog食用](https://blog.csdn.net/lvzelong2014/article/details/89048132)
