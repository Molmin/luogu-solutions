## A 跑步训练

小明每分钟损耗 $600$ 的体力，也就是每秒损耗 $10$ 的体力。每分钟增加 $300$ 的体力，也就是每秒增加 $5$ 的体力。用循环模拟小明的跑步过程即可。
编写的处理函数如下。

```c
void work1()
{
    int n=10000;         // 初始体力值
    int i,ans = 0;
    while (1)
    {
        for (i = 1; i <= 60; i++)
        {
            n -= 10;     // 每分钟损耗 600 的体力
            ans += 1;
            if (n == 0)
            {
                printf("%d\n",ans);
                return 0;
            }
        }
        for (i = 1; i <= 60; i++)
        {
            n += 5;     // 每分钟增加 300的体力
            ans += 1;
        }
    }
}

```
执行上面的处理函数，输出结果为：$3880$。

## B 合并检测

预设民众数量 $n$ 为 $10000$，$n$ 值设定更大也可以。在 $1 \sim 99$ 中枚举找出最优的 $k$ 值。编写的函数如下。
```c
void work2()
{
    int n= 10000, ans = 100;      // 预设民众人数和初始的k值
    int k;
	for (k = 1; k < 100; k++)     // 在[1,100)区间进行枚举 k值
    {
        int a=n/k+n/100*k;        // 当前k值需要的试剂盒数量
        int b=n/ans+n/100*ans;    // 求取的最好k值需要的试剂盒数
        if (a < b) ans = k;
    }
	printf("%d\n", ans);
}

```
执行上面的处理函数，输出结果为：$10$。

## C 分配口罩

口罩只有 $15$ 批，分配给两家医院。用一个 $15$ 位的二进制数 $x$ 来表示分配情况。若 $x$ 的第 $i$ 位上为 $1$，表示将第 $i$ 批口罩分配给一医院，若为 $0$，表示将第 $i$ 批口罩分配给二医院。
用循环对 $x(0\le x \le 2^{15}-1)$ 进行枚举即可。

编写的处理函数如下。

```c
void work3()
{
    int a[25]={9090400,8499400,5926800,8547000,4958200,4422600,5751200,4175600,
           6309600,5865200,6604400,4635000,10663400,8087200,4554000};
    int i,j,sum=0;
    for (i=0;i<15;i++)
        sum+=a[i];
    int ans=0x3f3f3f3f;
    for (i =1 ;i<(1<<15) ;i++)   // 对各分配的组合情况进行枚举
	{
	    int tmp=0;
		for (j = 0; j < 15; j++)
			if (i & (1<<j))  tmp += a[j];
        int diff = sum - 2 * tmp;
        if (diff<0) diff=-diff;
		if (diff < ans) ans = diff;
	}
	printf("%d\n", ans);
}

```
执行上面的处理函数，输出结果为：$2400$。

## D 矩阵

从 $2020$ 个数里选 $1010$ 个放入第一行，为了满足同一行中右边的比左边大，只能升序排列。剩下的 $1010$ 个也要升序排列地放入第二行，因此对于任意的 $i(1\le i \le 1010)$ 若都满足第二行第 $i$ 个数大于第一行第 $i$ 个数就是一种合法方案。

用 DP 解决本问题。设 $dp[i][j]$ 表示当前放置了 $i$ 个数，其中 $j$ 个数放入第一行的合法方案数。

编写的处理函数如下。

```c
#define  MOD  2020
int dp[2025][2025]={0};
void work4()
{
    dp[1][1] = 1; // 1必然放在第一行
    int i,j;
    for (i = 2; i <= 2020; i++)
    {
        for (j = 1; j <= i; j++)
        {
            dp[i][j] += dp[i - 1][j - 1];     // 将第i个数放第一行
            if (i - j <= j)                // 保持第一行的个数不能比第二行的少
            {
                dp[i][j] += dp[i - 1][j];
            }
            dp[i][j] %= MOD;
        }
    }
    printf("%d\n", dp[2020][1010]);
}

```
执行上面的处理函数，输出结果为：$1340$。

## E 完美平方数

从 $x=0$ 开始，用循环对每一个完全平方数 $x^2$ 进行枚举，若 $x^2$ 中只含有数字 $0$、$1$、$4$ 或 $9$，则 $x^2$ 是一个完美平方数，计数。直到找出第 $2020$ 个完美平方数。

编写的处理函数如下。

```c
void work5()
{
    int n = 2020, ans = 0;
    while  (n)
    {
        int flag = 1;
        int t=ans*ans;
        while (t!=0)
        {
            int d=t%10;
            if (d!=0 && d!=1 && d!=4 && d!=9) { flag=0; break; }
            t/=10;
        }
        if (flag) n--;
        if (n) ans++;
    }
    printf("%d\n", ans * ans);
}

```
执行上面的处理函数，输出结果为：$1499441040$。

有了上面的求解结果，本题提交的源程序如下。

```c
#include <stdio.h>
#include <string.h>
int main()
{
    char T;
    scanf("%c",&T);
    if (T=='A') printf("3880\n");
    else if (T=='B') printf("10\n");
    else if (T=='C') printf("2400\n");
    else if (T=='D') printf("1340\n");
    else if (T=='E') printf("1499441040\n");
    return 0;
}

```
