填空题的五个空感觉难度确实是从小到大呢。

~~感觉要长脑子了。~~
## A.跑步训练
一道典型的周期问题。

这道题就像是那个蜗牛爬井的题，容易发现每 $2$ 分钟消耗 $300$ 体力，那么前 $64$ 分钟就消耗了 $9600$ 体力，但是剩下的 $400$ 体力 $\lt600$，所以一分钟就能消耗完了，得出每秒钟消耗 $600\div60=10$ 体力，也就是说最后 $400$ 体力用了 $400\div10=40$ 秒消耗完，所以总共锻炼时间为 $64\times60+40=3880$ 秒。
## B.合并检测
也是一道数学题。

设 $A$ 国一共有 $n$ 人，则小阳人有 $\dfrac{n}{100}$ 人，每 $k$ 个人用一盒，共用 $\dfrac{n}{k}$ 盒，由于每有个小阳人会多做 $k$ 次核酸，所以为了小阳人做了 $\dfrac{n}{100}\times k$ 盒，共做了 $\dfrac{n}{k}+\dfrac{n}{100}\times k$ 盒，由于 $n$ 固定，所以做了 $\dfrac{1}{k}+\dfrac{k}{100}$ 盒。

此时，为了让和最小，那么必须使 $\dfrac{1}{k}=\dfrac{k}{100}$，则答案为 $10$。
## C.分配口罩
典型的搜索，没啥可讲的。
```cpp
#include<bits/stdc++.h>
using namespace std;
int ans=0x7fffffff;
int masks[15]={9090400,8499400,5926800,8547000,4958200,4422600,5751200,4175600,6309600,5865200,6604400,4635000,10663400,8087200,4554000};
void dfs(int now,int a,int b){
	if(now>15){
		ans=min(ans,abs(a-b));
		return;
	}
	dfs(now+1,a+masks[now],b);//把当前的这批口罩给a医院 
	dfs(now+1,a,b+masks[now]);//把当前的这批口罩给b医院 
}
int main(){
	dfs(0,0,0);
	cout<<ans;
	return 0;
}

```
~~然鹅还是加上了注释。。。~~
## D.矩阵
典型的 dp。

对于每个数，要不是放在紧挨的第一行，不然就放在紧挨的第二行，注意放在第二行上面必须有数字，也就是说第二行数字数不能大于第一行数字数。得出动态转移方程为：
```cpp
dp[i][j]+=dp[i-1][j];//第一行
dp[i][j]+=dp[i][j-1];//第二行
```
注意取余和特判。
```cpp
#include<bits/stdc++.h>
using namespace std;
int dp[1011][1011];
int main(){
	dp[0][0]=1;
	for(int i=0;i<=1010;i++){
		for(int j=0;j<=1010;j++){
			if(i>j)dp[i][j]+=dp[i-1][j]%2020;
			if(j)dp[i][j]+=dp[i][j-1]%2020;
		}
	}
	cout<<dp[1010][1010];
	return 0;
}
```
## E.完美平方数
有一个小小的疑惑：为什么 $49$ 不是完美平方数呢？

通过观察发现，完美平方数必须满足下列两个条件。
1. 必须是完全平方数。
2. 必须且只能由 $0$、$1$、$4$、$9$ 构成。

接下来找就行了，还是熟悉的配方，还是熟悉的暴力。。。

~~这里就不上代码了。。。~~
## 总代码
虽然不给 E 题的代码了 ~~（因为太丑了）~~，但是这道题还是很好理解并写代码的 ~~（整数转字符串会吧）~~，但是做人不能太绝，我就给大家带来最终答案吧 ~~（依旧是用题目里给的模板）~~！
# AC C++ CODE：
```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
    int ans[5]={3880,10,2400,1340,1499441040};
    char T;
    cin>>T;
    cout<<ans[T-'A']<<endl;
    return 0;
}
```
By ImNot6Dora