最关键的就是这一句话
> N (4 <= N <= 16)

我想呀，这个也太明显了。。。zz先发个代码，按机房大佬的说法代码最直接了。。。
----------------------
```````javascript
#include<bits/stdc++.h>
#define REP(i,a,b) for(int i(a);i<=(b);++i)
using namespace std;
void read(long long  &x){
	x=0; char c=getchar(); int f=1;
	for (;!isdigit(c);c=getchar()) if (c=='-') f=-f;
	for (;isdigit(c);c=getchar()) x=x*10+c-'0';x*=f;}
long long n,k,amap[30],dp[1<<20][20],cow[30];
int main(){
	read(n); read(k); 
	REP(i,1,n) {read(amap[i]); cow[i]=1<<(i-1); dp[1<<(i-1)][i]=1;}
	int limi=(1<<(n))-1;
	REP(i,1,limi) {  REP(j,1,n) {
			if (cow[j]&i)  REP(kk,1,n) {
					if ((cow[kk]|i)!=i) {
						if (abs(amap[j]-amap[kk])>k) {
							dp[(i|(cow[kk]))][kk]+=dp[i][j];}}}}}
	long long ans=0;
	REP(i,1,n) ans+=dp[limi][i]; cout<<ans<<endl;
} 
```````
要注释一波；
先是最基本的快读。。
				蒟蒻不会打封装的读入|><| 我实在是太弱了
amap[]数组的意思是第i只牛的编号。。。
cow[]表示的是第i只牛，加入队列时的要 | 的位置
怎么说呢，比如 10000010 这样一个01串我们表示的就是第二只牛和第，，懒得数了只牛已经放好了的状态，当我们把这个01串与000010000， 相  |  后，几可以得出1---1--1中间的0自动神略（手动滑稽）的状态
dp表示的是 dp[ ][ ]第一个是枚举到的状态，，第二个是这个状态是第几只牛刚发进去，，，为什么要真么dp呢
------------
---------
 1. 首先啊，这是状压而且是n属于1--16的状压，既然给了你那么明显的数据提示那么，dp里面一般就会带有状态表示（我说的是一般，一般，一般！）
 2. 一般这类题型是不会让你直接就一维dp就可以刷爆的。好吧有特例（[你以为我会告诉你？](https://www.luogu.org/problemnew/show/P3052)）但这题也得要一点辅助的，，，
 3. 那么根据题意，看关键限制条件（要大于K），那么如果我们已经把前面的几头牛塞进状态中了，就不会对现在的dp转移有影响有影响的只能是刚放进去的，因为他的编号直接决定了你能否进入这个大家庭，，（we are family!!）
 -------
下面就是常用的提高加 状压dp模板呵呵
```
REP（1,0/1,limi(状态的最后表示形式））
REP（枚举的位置（要变换的编号）<这题中就是第几头牛的>）
		加大判定 IF (这头牛没有放进去（呸呸，这个位置上没有被站位）)  
        继续往下
REP （dp[ ][ ]两个格子中后面的一维中代表的数）再加个大判定
```
然后状态转移 然后输出答案