$\large \text{Solution CF863C}$

这种题怎么能少了倍增题解……

对于这种**进行多次变换，并且下一次变换根据上一次变换结果的**题，如果变换次数较多，一般都能用**倍增**。比如，[P5151 HKE 的小朋友](https://www.luogu.com.cn/problem/P5151)。

不了解倍增的同学也可以往下看。

----

定义 $(i,j)$ 表示一个当前状态（Alice 准备出 $i$，Bob 准备出 $j$）。

我们设四个倍增数组记录：

1. $f_{i,j,k}$ 表示当前状态为 $(i,j)$，进行 $2^k$ 轮比赛后，Alice 下一局准备出的值。
2. $g_{i,j,k}$ 表示当前状态为 $(i,j)$，进行 $2^k$ 轮比赛后，Bob 下一局准备出的值。
3. $s1_{i,j,k}$ 表示当前状态为 $(i,j)$，Alice 在接下来 $2^k$ 轮中的得分。
4. $s2_{i,j,k}$ 表示当前状态为 $(i,j)$，Bob 在接下来 $2^k$ 轮中的得分。

-----

你可能会问，设它们干啥呢？不急，先解决**初始化**，也就是求 $k=0$ 时（进行 $2^0=1$ 轮比赛），四个数组的值。

1. $f_{i,j,0}=a_{i,j}$
2. $g_{i,j,0}=b_{i,j}$ （以上根据题意）
3. 如果在 $(i,j)$ 状态下，Alice 赢了，则 $s1_{i,j,0}=1$；Bob 赢了，则 $s2_{i,j,0}=1$；平局均为 $0$。

---

知道了 $k=0$ 时四个数组的值，也可以按照 $k=1,2,...$ 的顺序往下推！
（由于式子太过复杂，换一种 $\LaTeX$ 书写方式）

1. $f(i,j,k)=f(f(i,j,k-1),g(i,j,k-1),k-1)$

是不是看到这个就一头雾水了？

首先我们知道，$2^{k-1}$ 轮比赛后，状态 $(i,j)$ 变成了状态 $(f(i,j,k-1),g(i,j,k-1))$，**在这个状态的基础上**再进行 $2^{k-1}$ 轮比赛，那么 $2^{k-1}+2^{k-1}=2^k$，上面的那个式子就成功求出了 $f(i,j,k)$！

2. $g(i,j,k)=g(f(i,j,k-1),g(i,j,k-1),k-1)$

和上面的一样的道理。

3. $s1(i,j,k)=s1(i,j,k-1)+s1(f(i,j,k-1),g(i,j,k-1),k-1)$

这个式子我就不说明啦，给读者一点思考的空间（可以结合上面的理解）。

4. $s2(i,j,k)=s2(i,j,k-1)+s2(f(i,j,k-1),g(i,j,k-1),k-1)$

-----


哎呀，计算了这么多，到底有什么用？**敲重点了。**

我们设一共进行了 $K$ 场比赛，对 $K$ 进行二进制拆分，拆成 $K=2^{a_1}+2^{a_2}+2^{a_3}+...+2^{a_n}$ 的形式。

由于我们已经可以通过上面的预处理，快速模拟 $2^x$ 场比赛了。那么我们就可以对上面多项式右边的每一项依次模拟！

现在再分析一下，由于 $K\le10^{18}$，预处理倍增数组的时候，$k$ 最大取到 $\log_2(10^{18}) \approx 62$ 够了。

为了更好地让读者理解，上部分代码。

```cpp
for(ll k=62;k>=0;k--){
	if(K&(1ll<<k)){ // 如果 k 的二进制位上这一位是 1
		ans1+=s1[u][v][k], ans2+=s2[u][v][k]; // 累计答案
		ll TMPU=u,TMPV=v; // 之前的状态
		u=f[TMPU][TMPV][k], v=g[TMPU][TMPV][k]; // 倍增模拟
	}
}
```
答案就这样被统计出来了。

------

看似倍增做法比较复杂，但这题还算是套路题，很多类似题目也可以按照想倍增数组、完成初始化、想递推的方法、想统计的方法的顺序完成，我认为很有比要学会。

$\large \text{Sample Code(C++)}$

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef pair<int,int> P;
typedef pair<ll,ll> PL;
ll K,u,v,a[5][5],b[5][5],ans1,ans2;
ll f[5][5][63],g[5][5][63],s1[5][5][63],s2[5][5][63];
ll pd(ll a,ll b){
    if(a==b) return 0;
    if((a==3 && b==2)||(a==2 && b==1)||(a==1 && b==3)) return 1;
    else return -1;
}
int main(){
    scanf("%lld%lld%lld",&K,&u,&v);
    for(ll i=1;i<=3;i++)
        for(ll j=1;j<=3;j++)
            scanf("%lld",&a[i][j]);
    for(ll i=1;i<=3;i++)
        for(ll j=1;j<=3;j++)
            scanf("%lld",&b[i][j]);
    for(ll i=1;i<=3;i++)
        for(ll j=1;j<=3;j++){
            f[i][j][0]=a[i][j],g[i][j][0]=b[i][j];
            if(pd(i,j)==1) s1[i][j][0]=1,s2[i][j][0]=0;
            else if(pd(i,j)==-1) s2[i][j][0]=1,s1[i][j][0]=0;
            else s1[i][j][0]=0,s2[i][j][0]=0;
        }
    for(ll k=1;k<=62;k++)
        for(ll i=1;i<=3;i++)
            for(ll j=1;j<=3;j++){
                f[i][j][k]=f[f[i][j][k-1]][g[i][j][k-1]][k-1];
                g[i][j][k]=g[f[i][j][k-1]][g[i][j][k-1]][k-1];
                s1[i][j][k]=s1[i][j][k-1]+s1[f[i][j][k-1]][g[i][j][k-1]][k-1];
                s2[i][j][k]=s2[i][j][k-1]+s2[f[i][j][k-1]][g[i][j][k-1]][k-1];
            }
    for(ll k=62;k>=0;k--){
        if(K&(1ll<<k)){
            ans1+=s1[u][v][k], ans2+=s2[u][v][k];
            ll TMPU=u,TMPV=v;
            u=f[TMPU][TMPV][k], v=g[TMPU][TMPV][k];
        }
    }
    printf("%lld %lld\n",ans1,ans2);
    return 0;
}
```