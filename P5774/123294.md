> XXXIII. [P5774 [JSOI2016]病毒感染](https://www.luogu.com.cn/problem/P5774)
>
> 选自 [DP 做题记录](https://www.cnblogs.com/alex-wei/p/simple_DP.html) 例题 XXXIII.

细节巨大多。

一个显然的想法是设 $f_i$ 表示前 $i$ 个村庄的最少代价，但是这样不行，因为前 $i$ 个村庄的最优解不一定是全局最优解：我们可能会花更多的天数达到前 $i$ 个村庄的最优解，但是这会让后面村庄的代价增大。同时，数据范围不允许我们将天数设计到 DP 里面。

因此我们使用**代价提前计算**的 trick 即设 $f_i$ 表示治疗完前 $i$ 个村庄且现在在位置 $i$ 处时，所有村庄代价之和的最小值。转移直接枚举我们忽略的最左端的村庄 $j$，那么代价就是：

- 首先我们从 $j-1$ 处要经过 $4(i-j)+2$ 天才能走完 $j-1\to i\to j\to i$ 的总路程并治疗完所有村庄，因此代价加上 $(4(i-j)+2)(s_n-s_i)$，其中 $s$ 是 $a$ 的前缀和。
- 然后对于 $j+1\sim i$ 的每个位置 $k$，如果我们马不停蹄直接往右赶，则第一次到达该村庄的时间为 $k-j+1$。因此代价加上 $\sum_{k=j+1}^i a_k(k-j+1)$。
- 接下来对于村庄 $k$，若我们选择在 $j\to i$ 的时候治疗，则会花费一天时间，导致 $k+1\sim i$ 的救治时间变晚一天，代价为 $s_i-s_k$。否则必须在 $i\to j$ 的时候治疗，此时村庄 $k$ 会晚被治疗 $3(i-k)$ 天（可以手动模拟一下）。因此代价加上 $\sum_{k=j+1}^i \min(s_i-s_k,3(i-k)a_k)$。
- 最后考虑村庄 $j$ 会在第 $3(i-j)+1$ 天时被治疗，因此代价加上 $(3(i-j)+1)a_j$。
- 别忘了加 $f_{j-1}$。

枚举 $j$ 后对每个结果取个 $\min$ 即可。

这么搞时间复杂度是 $\mathcal{O}(n^3)$ 的，无法接受。但是注意到主要时间浪费在枚举 $k$，考虑怎么优化：首先倒序枚举 $k$，当 $j\to j-1$ 时，case 2 的总代价会加上 $a_j+(s_i-s_{j-1})$，case 3 的总代价会加上 $\min(s_i-s_j,3(i-j)a_j)$。

因此总复杂度为 $\mathcal{O}(n^2)$。**需要特判 $j=1$ 的情况，因为 JYY 第一天早上已经到了村庄 $1$ 而不是 $f_0$ 所表示的在不存在的村庄 $0$ 处。**

```cpp
const int N = 3e3 + 5;

ll n, a[N], s[N], f[N];
int main() {
	cin >> n, mem(f, 63, N), f[0] = 0;
	for(int i = 1; i <= n; i++) cin >> a[i], s[i] = s[i - 1] + a[i];
	f[1] = s[n] - a[1];
	for(int i = 2; i <= n; i++) {
		ll cur = 0;
		for(int j = i; j; j--) {
			ll coef = (4 * (i - j) + (j == 1 ? 1 : 2)) * (s[n] - s[i]);
			coef += (3 * (i - j) + (j == 1 ? 0 : 1)) * a[j];
			f[i] = min(f[i], f[j - 1] + cur + coef);
			cur += (j == 2 ? 0 : s[i] - s[j - 1]) + a[j];
			cur += min(s[i] - s[j], a[j] * 3 * (i - j));
		}
	} cout << f[n] << endl;
	return 0;
}
```

