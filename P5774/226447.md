这种绿色的~~紫题~~省选题对我这种蒟蒻太不友好了。

首先我们观察题目，可以发现以下几点已知：

* $n<=3000$ 我们可以考虑 $O(n^2)$的做法

* 每一个村庄都可能有两种情况：1.顺着走过去时就治疗。2.倒回来的时候再治疗。

* 前面的村庄是否治疗对后面的死亡数有影响。

我们根据上几点，可以很容易的想到用区间DP来解决。

我们发现要解决一个区间(i,j)的治疗问题可以转化为村庄i的治疗处理方式+区间(i+1,j)的解决方法。

那么我们就可以很~~显然~~艰难的写出状态转移方程：

$f_{i,j}=f_{i+1,j}+sum_{i+1,j}+min(3 * (i-j) * a_j,sum_{i+1,j})$

接下来我从左到右分析每一项：

$f_{i,j}:$ 我们要求得的目标。

$f_{i+1,j}:$ 我们将目标分解成$i+(i+1,j)$来分析。

$sum_{i+1,j}:$我们不管对i村庄选择哪种处理方法，都要消耗1的时间来移动到i+1。

$3 * (i-j) * a_j:$i村庄的处理情况1.倒回来处理i村庄：我们从$i+1$移动到$j$再从$j$移动到$i+1$一共消耗$2 * (i-j)$的时间，我们在i+1与j之间来回移动时一定已经把这(i-j)个村庄治疗了，消耗$(i-j)$的时间，所以一共消耗$3 * (i-j) $的时间，而在这一段时间里i村庄是一直在死亡的，所以这一段时间的死亡数就是$3 * (i-j) * a_j$。

$sum_{i+1,j}$i村庄处理情况2.直接处理i村庄：因为处理i村庄需要一点时间，所以这一点时间里(i+1,j)的村庄都要死亡，所以这一段时间的死亡数就是$sum_{i+1,j}$。

然而我们上面处理的都是治疗一段区间的情况，并没有确定最终结束点在哪里，而且每一段都是相互独立的。但是经过这一预处理，我们在计算答案的时候就只需要枚举i村庄掉不掉头就可以了。

所以这里我们也可以经过一段~~很长~~时间的思考写出最终答案的转移方程：

$f_i=min(f_i,f_j+g_{j+1,i}+sum_{i+1,n} * (i* 4-j* 4 -2))$

我仍然分析每一项：

$f_i:$ 解决i左边的村庄的治疗问题的代价。

$f_j:$ 将大的问题拆分为小的子问题$f_j+(j+1,i)$来解决。

$g_{j+1,i}:$ 先单独处理区间(j+1,i)。

$sum_{i+1,n} * (i* 4-j* 4 -2):$因为区间(j+1,i)是独立处理的，所以我们要取消他的独立性：我们在处理(j+1,i)时(i+1,n)是一直存在疾病的，所以我们在这段时间内要一直付出代价。而我们消耗的时间可以分为两个部分1.治疗疾病，一共(i-j)个村庄，每一个消耗1单位时间。2.移动，我们要从$j$移动到$i$，再从$i$移动到$j+1$,再从$j+1$移动到$i$。所以我们处理$(j+1,i)$消耗的时间就是$(2 * (i-j-1)+(i-j)+(i-j)=(4 * i - 4 * j - 2)$。

所以这道绿色省选题解~~完美~~艰难的解决了。

**CODE**

```cpp
#include<bits/stdc++.h>
using namespace std;
#define N 3010
#define int long long
int n,a[N],s[N];
int f[N],g[N][N];
int ans=LLONG_MAX;
signed main(){
	//freopen(".in","r",stdin);
	//freopen(".out","w",stdout);
	cin>>n;
	for(int i=1;i<=n;++i){
		scanf("%lld",a+i);
		s[i]=s[i-1]+a[i];
	}
	for(int i=1;i<=n;++i){
		for(int j=i-1;j;--j){
			g[j][i]=g[j+1][i]+(s[i]-s[j])+min(s[i]-s[j],3*(i-j)*a[j]);
		}
	}
	memset(f,0x3f,sizeof(f));
	f[0]=0;
	for(int i=1;i<=n;++i){
		for(int j=0;j<i;++j){
			f[i]=min(f[i],f[j]+g[j+1][i]+(s[n]-s[i])*(4*i-4*j-2));
		}
	}
	cout<<f[n]<<endl;
	return 0;
}
```
