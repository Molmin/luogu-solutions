# Solution CF549C The Game Of Parity

[题目传送门]: https://www.luogu.com.cn/problem/CF549C

即将退役的蒟蒻的第一篇题解$QwQ$，如有不足请多包涵。



#### 题目大意：

有$n$个城市，每个城市有$a[i]$个人，两人轮流~~屠城~~对城市进行外科手术式的改造，若幸存者城市人口总数为奇数，那么先手胜，否则后手胜。



#### 分析：

题面虽然有亿点血腥，但透过”残忍“的表象我们不难看出这是一道博弈论。题目的关键在于最后幸存者城市人口总数的奇偶。



首先我们应该有一些算不上知识的前置芝士：

1.奇数*奇数=奇数

2.奇数*偶数=偶数

3.偶数*偶数=偶数

是的，这道题需要知道的就是这一点点众所周知的小学数学~~因为本蒟蒻太菜了只能做这种水题嚎啕大哭~~。



我们已知这道~~有手就行的~~题为博弈论，且决定胜负的关键为幸存者城市人口总数的奇偶，因而最后一次操作是谁就尤为重要。这里我们可以进行分类讨论。 

如若最后一次是先手~~屠城~~改造城市(即$m$为奇数)，我们易得：

1.剩下$k+1$个城市人口皆为偶数时，幸存者城市人口总数一定为偶数，后手必胜。

2.剩下$k+1$个城市人口皆为奇数时：

1)若$k$为奇数，幸存者城市人口总数一定为奇数，先手必胜。

2)若$k$为偶数，幸存者城市人口总数一定为偶数，后手必胜。

3.剩下$k+1$个城市人口有奇有偶时，

1)若先手摧毁一个人口为奇数的城市，幸存者城市人口总数一定为奇数，先手必胜。

2)若先手摧毁一个人口为偶数的城市，幸存者城市人口总数还是为奇数，先手必胜。

以上是最后一次为先手改造城市的情况，还是非常简单易懂的。接下来我们就可以类比着推出最后一次为后手改造城市(即$m$为偶数)的情况，如下：

1.剩下$k+1$个城市人口皆为偶数时，幸存者城市人口总数一定为偶数，后手必胜。

2.剩下$k+1$个城市人口皆为奇数时：

1)若$k$为奇数，幸存者城市人口总数一定为奇数，先手必胜。

2)若$k$为偶数，幸存者城市人口总数一定为偶数，后手必胜。

3.剩下$k+1$个城市人口有奇有偶时，

1)若此时城市人口为奇数，后手可以摧毁一个人口为奇数的城市，这样幸存者城市人口总数就变成了偶数，后手必胜。

2)若此时城市人口为偶数，后手可以摧毁一个人口为偶数的城市，这样幸存者城市人口总数也会变成偶数，后手必胜。

特别的，当$n==k$时，没有人有任何操作(城市保住了芜湖)，此时可按后手最后操作的情况来判。

我们可以在读入时顺便处理一下人口总数为奇数的城市数$odd$，人口总数为偶数的城市数$even$和操作数$m$，详见代码。



#### Code

接下来就是喜闻乐见的代码环节。(码风不好，见谅$QwQ$)

~~话说为啥那么多测试点啊喂~~

```cpp
#include<bits/stdc++.h>	//挚爱万能头 
#define re register int //小小优化（不过的确似乎没什么用
using namespace std;
int n,k,m;	//如题解所示 
int odd,even;
void xianshou()	//最后一次操作为先手的情况 
{
	if((m>>1)>=odd)
	{
		printf("Daenerys\n");
		return ;	//因为只有一组数据所以也可以直接exit(0) ,下同 
	} 
	if((m>>1)>=even && !(k&1)) 
	{
		printf("Daenerys\n");
		return ;
	}
    printf("Stannis\n");
}
void houshou()	//最后一次操作为后手的情况 
{
	if((m>>1)>=odd) 
	{
		printf("Daenerys\n");
		return ;
	}
    if((m>>1)>=even && (k&1)) 
    {
    	printf("Stannis\n");
    	return ; 
	} 
	printf("Daenerys\n");
}
inline int qr() //快读板子(其实这道题也不需要，只是个人习惯而已) 
{
	int x=0,f=1;
	char ch=getchar();
	while(!isdigit(ch))
	{
		if(ch=='-') f=-1;
		ch=getchar();
	}
	while(isdigit(ch))
	{
		x=(x<<1)+(x<<3)+(ch^48);
		ch=getchar();
	}
	return x*f;
}
int pre()	//读入及其它预处理 
{
	n=qr(),k=qr();
	m=n-k;	//操作数的计算 
	for(re i=1;i<=n;i++)
	{
		int a=qr();
		if(a&1) odd++;
		else even++; 
	}	//统计人口总数为奇数的城市数和人口总数为偶数的城市数
} 
int main()
{
	pre();	//见上
	if(!m)	//没有操作的情况，可直接根据odd个数判断 
	{
		if(odd&1) printf("Stannis\n");
		else printf("Daenerys\n");
		return 0;
	}
	if(m&1) xianshou();	//见上
	else houshou();	//见上
	return 0;	
}
```

完结撒花~	预祝各位明天$NOIp$   $rp++$!