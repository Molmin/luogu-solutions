#### 前言

挺水的一道题。

#### 思路

因为可以任意交换元素，那么不妨就直接把元素排序。

本着贪心的原则，我们总是希望一个数能够被自己的后继(比它大的最小的数)来填。

**怎么找后继？**

因为是序列是排好序的，拿一个指针，指针从$1$开始。

从$2$到$n$遍历一遍，第一个扫到的大于这个指针的数肯定就是目前指针指到的数的后继。

如果扫到了当前指针指到的数的后继，那么指针往后移动，同时不难发现，指针指的数的后继随着指针的移动不断在变大，所以这样扫是对的。

总的时间复杂度是:O($nlog(n) + n$)，瓶颈在排序上。

### Code

```cpp
#include <bits/stdc++.h>
using namespace std;
int n;
int a[100005];
int main()
{
	cin >> n;
	for(int i = 1 ; i <= n; i ++)cin >> a[i];
	sort( a + 1 , a + 1 + n );
	int now = 1,Ans = 0;
	for(int i = 2 ; i <= n ; i ++)
		if(a[i] > a[now])now ++ , Ans ++;//指针扫描即可
	cout << Ans;
	return 0;
}
```