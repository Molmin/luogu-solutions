这题可以 $O(n)$ 处理，不用二分

首先很明显肯定是大的数对应原本小的数，将数组从大到小排个序先

我们可以认为操作是这样的：第一大的数对应第二大的，第二大的数对应第三大的，以此类推

但是有些数字是相同的，所以我们不能这么做

用一个 $l$ 来表示当前被用来对应的数字用到了第几个， $O(n)$ 扫一遍就行了

如果当前可以对应就对应，如果当前不能就不管这个数了

但是很不幸排序是 $nlog_n$ 的，所以还是 $nlog_n$

代码如下

```cpp
int a[101010];

bool cmp(int a,int b){
	return a>b;
}

int l=1;

int main(){
	int n=read();
	for(int i=1;i<=n;i++){
		a[i]=read();
	}
	sort(a+1,a+n+1,cmp);
	int s=0;//计数
	for(int i=2;i<=n;i++){//第一个数肯定不能被对应
		if(a[l]>a[i]) {//用第 l 个数对应第 i 个数
			s++;
			l++;
		}
	}
	cout<<s;
	return 0;
}

```


