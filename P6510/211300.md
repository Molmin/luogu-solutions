>**题意简述：**
>
>求出最长的区间，使得这个区间最左边的值在这个区间里最小，最右边的值在这个区间里最大。

## 单调栈

单调栈可以找出一个序列中的最大值和最小值，所以我们可以求出输入序列的两个最值，通过计算最大值和最小值之间的距离，再找出最长的就行了。

单调栈找最大值和最小值的思想是一样的，我就用找最大值来举例子。

枚举一遍序列，把序列按从大到小存进栈中，也就是越靠下对应的值越小（注意：栈里存的是下角标），最小值相反。代码实现：

```cpp
for(int i=1; i<=n; i++)
{
	while(t1&&c[s1[t1]]<c[i]) t1--;
	s1[++t1]=i;
}
```


在算最大值的同时，把最小值也算出来，这样我们就有了在任意时刻的最大值和最小值。

用栈 $s1$ 存最大值，$s2$ 存最小值，数组 $c$ 存输入。因为本题求的序列的右端点是最大值，所以我们可以枚举右端点，并算出合法的序列的长度。

假设我们已经算出了 $c_1\text{～}c_i$ 的答案区间的左端点为 $A$，右端点为 $B$，在算 $c_{i+1}$ 时，如果 $c_{i+1}>c_B$，就相当于把 $s1$ 里的元素全都弹出了只剩下 $c_{i+1}$，否则，就进栈顶。然后，我们就需要在 $s2$ 里找到第一个大于 $s1$ 中 $c_{i+1}$ 的前一个数，因为我们要保证区间里的最大值为 $c_{i+1}$ 并且 $s1$ 单调递减，$s2$ 单调递增，所以一定是合法的最小值，也就是长度最长，这里可以用二分。

最后，用 $ans$ 存最长区间的长度就行了。

```cpp
#include<iostream>
#include<cstdio>
#include<stack>

using namespace std;

const int N=1e5+10;
int n,c[N],ans;
int s1[N],t1,s2[N],t2;

int Search()	//二分查找 
{
	int l=1,r=t2;
	while(l<=r)
	{
		int mid=(l+r)>>1;
		if(s2[mid]>s1[t1]) r=mid-1;
		else l=mid+1;
	}
	return l;
}

int main()
{
	scanf("%d",&n);
	for(int i=1; i<=n; i++)
	{
		scanf("%d",&c[i]);
		while(t1&&c[s1[t1]]<c[i]) t1--;
		while(t2&&c[s2[t2]]>c[i]) t2--;
		int pos=Search();	//二分在s2中找第一个大于等于s1中c[i]的前一个数的值 
		if(pos!=t2+1) ans=max(ans,i-s2[pos]+1);	//如果s2中有符合上面条件的数，更新ans 
		s1[++t1]=i;
		s2[++t2]=i;
	}
	printf("%d\n",ans);
	return 0;
}
```
