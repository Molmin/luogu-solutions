最近这几天被树状数组折磨的不轻，发博客来帮自己理顺一下思路。


## 一.引入。

## 问题1：给你一个数列，如何完成快速的单点修改与区间查询？（例题luoguP3374）

#### 1.单点修改指的是：把某个点的值进行修改，且仅涉及这一个点的值的变化。

#### 2.而区间查询指的是查询区间值的和。



好了，以上，我们就顺利的把题目读懂了。一般来说，我们会有以下的思路。

#### （1）暴力相加法。

直接开一个数组，每次单点修改的操作$ O(1)$ 进行修改，查询时暴力相加。
    
我们观察到，区间查询的复杂度为$O(n)$，单点修改的复杂度为$O(1)$.
    
显然，如果查询次数很多，会超时。

#### （2）前缀和数组。

众所周知，前缀和的维护为$O(n)$,查询为$O(1)$，但是如果要是修改，就需要$O(n)$重新维护，有些情况还是会超时。

因此，两种暴力算法都各有利弊，那么我们如何中和一下他们，得到一个更加快捷的方法呢？

树状数组就因此诞生了。
## 二.树状数组入门。

#### 什么是树状数组？

顾名思异，树状数组是以树形结构为思想的一类数据结构，并不是树形结构！！，和线段树相似，不过空间比线段树更优。

树状数组比前面的两种暴力算法之所以更优，是因为树状数组的查询修改操作均为$O(logn)$。

这样看来，树状数组的确比之前两种方法快上不少。

（请自行百度树状数组图片，蒟蒻不会插图。。）

#### 1.树状数组的构建

我们假设a[]为原数组，c[]为树状数组，树状数组的大致对应关系如下

$c[1]=a[1];$

$c[2]=a[1]+a[2];$

$c[3]=a[3];$

$c[4]=a[1]+a[2]+a[3]+a[4];$

$......$

树状数组与原数组宏观之间的关系很难说，我们来观察一下他们二进制下的对应关系。

$c[0001]=a[0001]$

$c[0010]=a[0001]+a[0010]$

$c[0011]=a[0011]$

$c[0100]=a[0001]+a[0010]+a[0011]+a[0100]$

$......$

首先，先扔上一波定义：

对于树状数组的每一个c[i]，其实际意义为：

> 算上其本身的讯息，总共存储了$2^k$个元素的信息，
> 其中k表示i在二进制下，末尾零的个数.


看不懂？再多读几遍试试？

还是看不懂？

没关系，下面我们~~简单的描述一下~~。

#### 由于存储的信息数量为二进制下最后一个1所在位置决定，
#### 我们可以假设最后一个1在倒数第$i$个位置

#### 由此，我们可以得到，对于树状数组中$C[n]$,所存储的区间信息为：

### $C[n] = a[n-2^i] +a[n-2^i+1]+......+a[n].$

### 即$C[n] = \sum_{k=n-2^i}^n{a[k]}.$

下面我们举几个简单的例子便于理解。

如$C[4]=C[0100]$

由于最后一个1在第三位，所以说该数组中存储$2^2=4$个数。

且存储的区间为$a[1]+a[2]+a[3]+a[4]$

又比如$C[9]=C[1001]$

最后一个1在最后一位，所以该数组存储$2^0=1$个数。

即$C[9] = a[9].$

理解了这个，树状数组应该就很简单了。

不过，我们如何获得最后一位1所在位置的值呢？

这早已经被大牛们所研究出来了，即

lowbit(x)=x&-x.

这种方法很玄学，但是可以证明，有兴趣的可以自行百度。

```cpp
//写法1
inline int lowbit (int x)
{
	return x&(-x);
} 
这里，返回的就是x对应二进制中最后的1的值。

//写法2

inline int lowbit(int x)
{
	return (x^(x-1))&x;
}
```
两种写法没有本质的区别，个人比较喜欢写第一种（只是因为好记..

掌握了树状数组与原数组的对应关系，下面我们要对树状数组进行修改和查询了。

单点修改函数如下:
由于我们要把所有包括 x 的树状数组进行修改，因此我们要每次向上找一个lowbit，找到最后一位n的时候停止。

```cpp
inline void add(int x,int k)
{
	for(int i=x;i<=n;i+=lowbit(i))
		tree[i]+=k;
}

```

区间查询函数如下：

和单点修改类似的，我们需要向下找，把这个区间一点点的加起来。

```cpp
inline int sum(int x)
{
	int ans=0;
	for(int i=x;i;i-=lowbit(i))
	{
		ans+=tree[i]; 
	}
	return ans;
}

```
完整代码如下
```
#include <bits/stdc++.h>
using namespace std;
int tree[3000000],n,m;

inline int lowbit(int x)
{
	return x&(-x);
}

inline void add(int x,int y)
{
	for(int i=x;i<=n;i+=lowbit(i))
	{
		tree[i]+=y;
	}
}

inline int sum(int x)
{
	if(x==0) return 0;
	int ans=0;
	for(int i=x;i>0;i-=lowbit(i))
	{
		ans+=tree[i]; 
	}
	return ans;
}

int main ()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;++i)
	{
		int a;
		scanf("%d",&a);
		add(i,a);
	}
	
	for(int i=1;i<=m;++i)
	{
		int x,y,z;
		scanf("%d%d%d",&x,&y,&z);
		if(x==1)
		{
			add(y,z); 
		}
		if(x==2)
		{
			int end=sum(z)-sum(y-1);
			printf("%d\n",end);
		}
		 
	}
	return 0;
 } 
 ```
 
 总之树状数组是一个很有用的数据结构，常数很小，不过有的时候适用的范围可能不是很广。
 
