## 一道贪心题

这道题其实只要想到思路实际上非常的水。它既没有需要输出交换的顺序，还没有让你输出顺序，而甚至只有 $2$ 种字符，也没有各种恶心的字符串操作，在这种特殊的情况下，应该很容易想到可以用贪心做。

### 贪心的思路

因为这道题只有两种简单的操作——直接修改 和 交换位置。目标字符串也只用两种，"$brb...$"和"$rbr...$"。

我们发现，直接修改简单粗暴，可以无脑把全部错误的地方全部改正，那么如果只是直接修改，我们就只需要记录两种排列方式中错误的个数并且比较就能算出在这种情况下需要改多少个才能得到合法的字符

而交换修改较直接修改有一个优点，就是交换一次可能可以得到两个合法的字符，这样的效率就比直接修改快了一倍，所以我们贪心的目的就是要尽可能多地用交换而不用直接修改。

此时非常惊喜的发现，管它交换哪里呢，只要记录好有多少个可以交换的就全部交换不久好了吗。所以我们就直接记下两种情况下错误的"$r$"的个数和错误的"$b$"的个数，用$min(b,r)$次交换使"$b$"或"$r$"全部正确，剩下的也就没得交换了，只能一个一个修改。那么到最后就得到一个推论：

$ans=min(b,r)+max(b,r)-min(b,r)=max(b,r)$

那么由于有两种目标情况，我们就需要分类讨论（其实不过是用多 $2$ 个计数器），取最小值即可，也就是：

$ans=min(max(b1,r1),min(b2,r2))$

_(注：公式中的 $b1,r1,b2,r2,b,r$为需要修改的 "$b$" 或 "$r$" 的个数)_

### 代码实现

（很简单）

```cpp
#include<bits/stdc++.h>
#define rep(a,b,c) for(int c=(a);c<=(b);++c)
using namespace std;
char c[1000001];
int t1wr,t1wb,t2wr,t2wb;
int main()
{
	int n;cin>>n;
	rep(1,n,i)
	{
		cin>>c[i];
		if((i&1)&&c[i]=='r')t2wr++;
		if(!(i&1)&&c[i]=='r')t1wr++;
		if((i&1)&&c[i]=='b')t1wb++;
		if(!(i&1)&&c[i]=='b')t2wb++;
	}
	
	int ans=min(max(t1wr,t1wb),max(t2wr,t2wb));
	cout<<ans;return 0;
}
```
