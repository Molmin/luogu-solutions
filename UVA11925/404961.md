## 思路：
这题刚一看很难下手。首先我们把它变成一个逆向问题：从输入排列变到排列 $1,2,\dots,n$。可以执行两个操作：
- 操作 $1$：交换前两个元素；
- 操作 $2$：把最后一个元素移到最先。

得到答案后反转一下即为原题答案。

我们可以把这个数列看成收尾相接的一个环（数列下标从 $0$ 开始）。更进一步，初始 $pos = 0$，操作 $2$ 使 $pos$ 减 $1$，操作 $1$ 使位于 $pos$ 和 $pos+1$ 的数交换，这样就不需要队列了。

然后这题就非常简单了，使用冒泡排序即可，优化都不用，见代码（没有显式地给出 $pos$，但思路是相通的）：
```cpp
#include <bits/stdc++.h>
using namespace std;
int main()
{
   int n, a[300];
   string s;
   while(scanf("%d", &n), n)
   {
      for(int i = 0; i < n; ++i)
         scanf("%d", a+i);
      s = "";
      for(int i = 0; i < n-1; ++i)
         for(int j = n-1; j >= 0; --j)
         {// 冒泡排序
            s += '2';
            if(j != n-1 && a[j+1] < a[j])
            {
               swap(a[j], a[j+1]);
               s += '1';
            }
         }
      reverse(s.begin(), s.end()); // 反转答案
      cout << s << endl;
   }
   return 0;
}
```
粗略估计，答案长度上界为 $2n(n-1)$，符合题目要求。

事实上，操作 $2$ 共 $n(n-1)$ 次，操作一的次数（冒泡次数）最多是 $(n-1)+\dots+1 = \dfrac{n(n-1)}{2}$ 次，共 $\dfrac{3}{2}n(n-1)$ 次。