[题目传送门](https://www.luogu.com.cn/problem/AT2370)

发现题解都是说的钦定白球到 0 ，我想讲讲容斥的做法。

我们首先考虑只有 $w$ 个白球和 $b$ 个黑球时，由于任何操作之后白球和黑球的总数不会变，所以记进行到第 $i$ 次操作，还剩 $j$ 个白球的情况数为 $f[i][j]$ 即可。

我们取一个球，放两个球，再取一个球的过程总共有四种转移：

1. 取两个黑球：当 $j<n$ 时， $f[i][j]$ 会得到 $f[i][j+1]$ 的一个贡献。
2. 取一个黑球和一个白球：当 $j<n$ 时， $f[i][j]$ 会得到 $f[i][j]$ 的一个贡献。
3. 取一个白球和一个黑球：当 $j>0$ 时， $f[i][j]$ 会得到 $f[i][j]$ 的一个贡献。
4. 取两个白球：当 $j>0$ 时， $f[i][j]$ 会得到 $f[i][j-1]$ 的一个贡献。

上面的四个转移分别对应着四个不同的颜色序列，所以在只枚举这一种其实情况时是不会重复的。

代码实现很好搞，这里加了滚动数组。
```cpp
for(i=1;i<=m;i++)
{
	memset(f[i&1],0,sizeof(f[i&1])); 
	for(j=0;j<=n;j++)
	{
		if(j!=0) (f[i&1][j]+=(f[(i-1)&1][j]+f[(i-1)&1][j-1])%Mod)%=Mod;
		if(j!=n) (f[i&1][j]+=(f[(i-1)&1][j]+f[(i-1)&1][j+1])%Mod)%=Mod;
	}
}
for(j=0;j<=n;j++)
	(ans+=f[m&1][j])%=Mod;
```


现在最大的问题就是在不同的序列之间的重复颜色序列，去重显然易见的一个想法是容斥。

首先我们来考虑一下两个不同的起始条件： $w_1$ 个白球和 $b_1$ 个黑球以及$w_2$ 个白球和 $b_2$ 个黑球。在整个转移的过程中，黑球和白球的个数最小是 $0$ ，不可能到负数，也就是说，我们使用的不是后来加入的白球最多是 $w$ 个，才能让这个颜色序列对于这个初始状态合法；黑球同理。

所以，我们能够同时在两个起始条件都满足的序列，需要满足在以 $\min(w_1,w_2)$ 个白球和 $\min(b_1,b_2)$ 个黑球为的起始条件的满足序列数。

记 $g[w][b]$ 为初始有 $w$ 个白球和 $b$ 个黑球的可行序列数，那么最终答案是（ $S$ 为我们要求的容斥的 $n+1$ 个起始条件的子集）： $\sum\limits_S(-1)^{|S|}g[\min\{w_i;i\in S\}][\min\{b_i;i\in S\}]$ 。

由于 $w_i+b_i=n$ 恒成立，所以 $min\{b_i;i\in S\}=max\{w_i;i\in S\}$ 。我们可以将 $S$ 转化为 $0$ 到 $n$ 的某个子序列。最终答案为： $\sum\limits_S(-1)^{|S|}g[\min\{w_i;i\in S\}][\max\{w_i;i\in S\}]$ 。

转换枚举顺序，从枚举 $S$ 改成枚举 $min$ 和 $max$ ，分类讨论每一组:

1. 当 $min=max$ 时，就只有白球为 $min$ 个的时候，对最终答案的贡献为 $g[min][min]$ 。
2. 当 $min=max-1$ 时，是 $min$ 个白球和 $min+1$ 个白球的公共序列部分，这个部分仅为这一种情况，对最终答案的贡献为 $-g[min][min+1]$ 。
3. 当 $min\leqslant max-2$ 时，$min$ 个白球和 $max$ 个白球必然在里面，所以考虑对集合 $ \{x\in N|min+1\leqslant x\leqslant max-1\} $ 的子集的枚举，对于每一个不包含 $min+1$ 的子集 $S$ ，必然有一个包含 $min+1$ 的集合 $S\cup\{min+1\}$ 与之对应，而且 $|S|$ 和 $|S\cup\{min+1\}|$ 的奇偶性不同，也就是说 $(-1)^{|S|}+(-1)^{|S\cup\{min+1\}|}=0$ 。这种一一对应的关系时不重复也不遗漏的，所以这些部分对最终答案的贡献均为 $0$ 。

综上所述，我们最终的答案是： $\sum\limits_{i=0}^ng[i][n-i]-\sum\limits_{i=0}^{n-1}g[i][n-i-1]$ 。

由于每一个 $g[w][b]$ 的答案是相对独立的，所以所有的答案在转移f数组的时候可以放在一起转移，然后只需要统计所有的f即可。

接下来就是代码实现，第三维是 1 的代表做正贡献的部分，是 0 的代表做负贡献的部分。

```cpp
#include <bits/stdc++.h>
using namespace std;
int Qread()
{
	int x=0;char ch=getchar();
	while(ch<'0'||ch>'9') ch=getchar();
	while(ch>='0'&&ch<='9')
	{
		x=(x<<3)+(x<<1)+(ch^48);
		ch=getchar();
	}
	return x;
}
int n,m,p=1e9+7,ans,i,j,k;
int f[2][3010][2];
int main()
{
	n=Qread(),m=Qread();
	for(i=0;i<n;i++)
		f[0][i][1]=1,f[0][i][0]=p-1;
	f[0][n][1]=1;
	for(i=1;i<=m;i++)
	{
		memset(f[i&1],0,sizeof(f[i&1])); 
		for(j=0;j<=n;j++)
		{
			if(j!=0) (f[i&1][j][1]+=(f[(i-1)&1][j][1]+f[(i-1)&1][j-1][1])%p)%=p;
			if(j!=n) (f[i&1][j][1]+=(f[(i-1)&1][j][1]+f[(i-1)&1][j+1][1])%p)%=p;
			if(j==n) continue;
			if(j!=0) (f[i&1][j][0]+=(f[(i-1)&1][j][0]+f[(i-1)&1][j-1][0])%p)%=p;
			if(j!=n-1) (f[i&1][j][0]+=(f[(i-1)&1][j][0]+f[(i-1)&1][j+1][0])%p)%=p;
		}
	}
	for(j=0;j<=n;j++)
	{
		(ans+=f[m&1][j][1])%=p;
		if(j!=n) (ans+=f[m&1][j][0])%=p;
	}
	printf("%d\n",ans);
	return 0;
}
```