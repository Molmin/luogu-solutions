我们要在 $n$ 棵树中最多选出 $k$ 棵树，并且它（们）的获利最大。

种第一棵树时，显然要选获利最大的那一棵树。假设这棵树的下标是 $x$ （以下的的 $x$ 表示“第 $x$ 棵树”）。

种第二棵树时，有两种选择。第一种是选 $(x + \text{另外一棵树})$ ，第二种是选 $[(x - 1) + (x + 1)]$ 。没有第三种了，因为无论是 $(x + 1)$ 还是 $(x - 1)$ 都没有 $x$ 的获利大。

这时就出现了一种**反悔**的情况，前面选过的我们不要了。

------------
如何实现上述的步骤呢？

存储获利值的变量和 $ans$ 变量都是 $\text{long long}$ 类型的。

第一步，输入 $n$ 个数，把它们全部放进一个大根堆里。

第二步，循环 $k$ 次，每次从大根堆里取 $top$ 值，如果它已经被用过（ $vis[q.top().id] $ ）则从堆里弹出这棵树，直到它没用过（ $!vis[q.top().id] $ ）。这棵树的下标是 $x$ （以下的的 $x$ 表示“第 $x$ 棵树”）。如果这棵树的获利值为负就退出循环，因为把它加到 $ans$ 就是做减法了。再把符合条件的这棵树 $q.top().val$ 加到 $ans$ 中。

第三步，标记 $vis[x - 1]$ 和 $vis[x + 1]$ 为 $1$ ，表示它们已经被用过了。这两棵树和第 $x$ 棵树合体，变成一棵新的树，它的获利值是 $(-val[x] + val[x - 1] + val[x + 1])$ 。再把这棵树放回大根堆中。

那么最开始时 $x$ 的左边是 $(x - 1)$ ，右边是 $(x + 1)$ ，但是假如它们合并成了一棵新的树，那么这棵树的左边不是 $(x - 1)$ ，右边也不是 $(x + 1)$ 了。现在该怎么办？

这时，我们需要两个**类似于指针**的数组。一个是 $l[x]$ ，表示 $x$ 的左边的树的下标；另一个是 $r[x]$ ，表示 $x$ 的右边的树的下标。

在输入时，需要把 $l$ 数组和 $r$ 数组初始化。

第四步，更新 $l$ 数组和 $r$ 数组。新树的左边是原树的左边的左边（ $l[l[x]]$ ），右边是原树的右边的右边（ $r[r[x]]$ ）。新树的左边的右边是原树 （ $x$ ），新树的左边的右边也是原树 （ $x$ ）。

第五步，输出 $ans$ 。