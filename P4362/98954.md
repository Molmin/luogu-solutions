题目简述：

将一棵树中的节点染成M种颜色，每个节点有且只有一种颜色，在满足以下条件下使得两端颜色相同的边的权值和最小，所有边权均非负。

（1）必须有K个1号颜色的点；

（2）1号节点必须是1号颜色；

（3）每种颜色必须至少有一个节点。如无解，输-1。

无解的情况很明显，当且仅当N-K<M-1时无解。

 

考虑用动态规划来解决。

如果以一棵子树作为一个子结构，分析需要考虑的状态：

（1）根节点的颜色。

（2）1号颜色的个数。

（3）树中颜色的分配情况，如何保证每种颜色都有节点。

 

初步分析可以得到一种四维的状态:

f[i][j][k][w]，表示在以i为根的子树中，有j个1号节点，根染k号颜色，树中已有的颜色用w表示（w是一个二进制数）的状态下最小的权值和。

首先，这个方程用到了状态压缩w，因此对于本题300的数据范围是不现实的，需要继续思考。

假设这样一个问题，仍然是对树染色，可以任意染色，那么只要2种颜色，就可以保证任意一条边两端的颜色不同，联想到这道题，因为1号颜色比较特殊，因此单独处理，而余下的颜色如果大于等于2种，那么无论1号颜色如何染色，都可以保证一条边两边不会出现相同的非1号颜色的情况，换言之，如果M>=3，对答案有贡献的只有1号颜色节点之间的边。这样当M>=3时，可以直接按3处理，这样状态压缩是可以承受的。既然有了这样的优化，k也可以只用0,1来表示，1表示1号颜色，0表示非1号颜色。而M=2时就更简单了，0,1就直接把颜色分开了。

初步分析下来，得到了一个状态数为O(N*K*2*2³)，转移为O(K*2*2³)，总复杂度为O(N*K²*256)。由于N,K≤300，理论分析是会超时，但实际操作中可以不用循环到K，因为循环的上限可以设为min(K,子树i的总节点数)。这样的话，这个复杂度还是可以承受的。

本题还有优化吗？答案是肯定的。

如果要优化状态，前3维似乎是无法优化的，考虑第4维。之所以一开始要加入这一维，就是担心会存在有一些颜色无法染上的问题，经过后来的分析，发现除了1号颜色会对答案有贡献之外，其他颜色其实是可以被忽略的，因为我们可以保证它们不会对答案造成影响，那么只要有足够多的节点来染除1外的颜色，就可以确保每一种颜色都可以被染上，至于到底在哪里，其实并不重要。这样想，就会发现其实第四维是完全多余的，可以直接略去。

最终状态:

f[i][j][k], 表示在以i为根的子树中，有j个1号节点，根染k号颜色的状态下最小的权值和。

注意：在具体转移时，要先将原来的f[i]复制一份，然后将f[i]清为无穷大，然后用备份的f[i]结合上述方程来计算f[i]的值。因为计算儿子没计算完时的状态是不能保留的，因为他们没有考虑完所有的情况，严格来讲，可以在上述方程中加上1维，表示计算到当前根的第几个儿子，每一次都是有上一次的状态和儿子的最终状态合并。这样就可以用滚动数组或辅助数组的方式来实现。

设y是i的一个儿子。

f[i][j][1]=min{f[i][j][1],f[y][k][1]+ pref[i][j-k]
[1]+value[i][y],f[y][k][0]+ pref[i][j-k][1]}

f[i][j][0]=min

{f[i][j][0],

f[y][k][0]+ pref[i][j-k][0]+ value[i][y] |if m=2

f[y][k][0]+ pref[i][j-k][0]+ value[i][y] , f[y][k][1]+ pref[i][j-k][0]| if m≠2

}

初始值，对于每一个i，f[i][0][0]=f[i][1][1]=0.

答案为f[1][K][1]。

AC代码：
```cpp
#include<cstdio>
#include<cstring>
using namespace std;
#define N 305
struct node{
    int v,w,next;
}e[N<<1];
int tot,head[N<<1];
int n,m,K;
int sum[N],tmp[N][2],f[N][N][2];
inline void MIN(int &x,int y,int z){
    if(x>y) x=y;
    if(x>z) x=z;
}
inline void add(int x,int y,int z){
    e[++tot].v=y;
    e[tot].w=z;
    e[tot].next=head[x];
    head[x]=tot;
}
void dp(int x,int from){
    f[x][1][1]=f[x][0][0]=0;sum[x]=1;
    int i,j,k,y,t;
    for(i=head[x];i;i=e[i].next){
        if((y=e[i].v)!=from){
            dp(y,x);
            sum[x]+=sum[y];
            t=(m==2?e[i].w:0);
            //MIN(f[i][j][1],f[y][k][1]+pref[i][j-k][1]+val[i][y],f[y][k][0]+pref[i][j-k][1]);
            //MIN(f[i][j][0],f[y][k][0]+pref[i][j-k][0]+val[i][y]{m=2},f[y][k][1]+pref[i][j-k][0]{m!=2});
            memcpy(tmp,f[x],sizeof f[x]);
            memset(f[x],127/3,sizeof f[x]);
            for(j=sum[x];j+1;j--){
                if(j)
                for(k=j-1;k+1;k--) MIN(f[x][j][1],tmp[j-k][1]+f[y][k][0],tmp[j-k][1]+f[y][k][1]+e[i].w);
                for(k=j;k+1;k--) MIN(f[x][j][0],tmp[j-k][0]+f[y][k][0]+t,tmp[j-k][0]+f[y][k][1]);
            }
        }
    }
}
int main(){
    memset(f,127/3,sizeof f);
    scanf("%d%d%d",&n,&m,&K);
    if(n-K<m-1){puts("-1");return 0;}
    for(int i=1,x,y,z;i<n;i++){
        scanf("%d%d%d",&x,&y,&z);
        add(x,y,z);add(y,x,z);
    }
    dp(1,0);
    printf("%d\n",f[1][K][1]);
    return 0;
}
```