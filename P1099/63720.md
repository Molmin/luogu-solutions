## 0. 福利

给出两组样例数据（其实就是题目中所说的树网实例）

![](https://cdn.luogu.com.cn/upload/pic/20270.png)

数据入口： [福利数据#1](https://paste.ubuntu.com/p/SqbGg82jtm/) || [福利数据#2](https://paste.ubuntu.com/p/KwmVG8fX6Y/)

## 1. 题面
### 题目描述
设$T=(V,E,W)$是一个无圈且连通的无向图（也称为无根树），每条边到有正整数的权，我们称$T$为树网（``treebetwork``），其中$V$，$E$分别表示结点与边的集合，$W$表示各边长度的集合，并设$T$有$n$个结点。

路径：树网中任何两结点$a$，$b$都存在唯一的一条简单路径，用$d(a, b)$表示以$a, b$为端点的路径的长度，它是该路径上各边长度之和。我们称$d(a, b)$为$a, b$两结点间的距离。

$D(v, P)=\min\{d(v, u)\}$, $u$为路径$P$上的结点。

树网的直径：树网中最长的路径成为树网的直径。对于给定的树网$T$，直径不一定是唯一的，但可以证明：各直径的中点（不一定恰好是某个结点，可能在某条边的内部）是唯一的，我们称该点为树网的中心。

偏心距$\mathrm{ECC}(F)$：树网T中距路径F最远的结点到路径$F$的距离，即

$\mathrm{ECC}(F)=\max\{d(v, F),v \in V\}$

任务：对于给定的树网$T=(V, E, W)$和非负整数$s$，求一个路径$F$，他是某直径上的一段路径（该路径两端均为树网中的结点），其长度不超过$s$（可以等于s），使偏心距$ECC(F)$最小。我们称这个路径为树网$T=(V, E, W)$的核（``Core``）。必要时，$F$可以退化为某个结点。一般来说，在上述定义下，核不一定只有一个，但最小偏心距是唯一的。

下面的图给出了树网的一个实例。图中，$A-B$与$A-C$是两条直径，长度均为$20$。点$W$是树网的中心，$EF$边的长度为$5$。如果指定$s=11$，则树网的核为路径``DEFG``（也可以取为路径``DEF``），偏心距为$8$。如果指定$s=0$（或$s=1$、$s=2$），则树网的核为结点$F$，偏心距为$12$。

![](https://cdn.luogu.com.cn/upload/pic/20270.png)
### 输入输出格式
#### 输入格式：
共$n$行。
第$1$行，两个正整数$n$和$s$，中间用一个空格隔开。其中$n$为树网结点的个数，$s$为树网的核的长度的上界。设结点编号以此为$1,2,…,n$。
从第$2$行到第$n$行，每行给出$3$个用空格隔开的正整数，依次表示每一条边的两个端点编号和长度。例如，“$2\ 4\ 7$”表示连接结点$2$与$4$的边的长度为$7$。
#### 输出格式：
一个非负整数，为指定意义下的最小偏心距。
### 输入输出样例
#### 输入样例#1：
```plain
5 2
1 2 5
2 3 2
2 4 4
2 5 3
```
#### 输出样例#1：
```plain
5
```
#### 输入样例#2：
```plain
8 6
1 3 2
2 3 2 
3 4 6
4 5 3
4 6 4
4 7 2
7 8 3
```
#### 输出样例#2：
```plain
5
```
### 说明
$40\%$的数据满足：$5 \le n \le 15$  
$70\%$的数据满足：$5 \le n \le 80$  
$100\%$的数据满足：$5 \le n \le 300,0 \le s \le 1000$。边长度为不超过$1000$的正整数  

NOIP 2007 提高第四题

## 2. 理解题目

蒟蒻：这道题目好长啊！不看了不看了。  
大佬：其实这道题目虽然长，但可以翻译成一句话：   
> 给定一棵带边权无根树，在其直径上求出一段长度不超过 $s$ 的路径 $F$ 可以为一个点），使得离路径距离最远的点到路径的距离最短。 

蒟蒻：好像懂了什么。   
蒟蒻：我去做做看。   

## 3. 迈出第一步

蒟蒻：我先打一个求树的直径的子程序。

```
namespace get_treeDiam {
	bool vis[307] = {0};
    // vis 数组：记录是否被访问过
	int fa[307] = {0}, dis[307] = {0};
    // fa 数组：用来记录自己的父亲节点，遍历直径时要用。
    // dis 数组：用来记录自己到父亲的路径长度，在判断长度是否小于 s 时要用。
	
	int maxp, maxlen;	
    // 最远的节点 & 到最远节点的距离
    
	void dfs(int f, int p, int len)
	{
    	// f : 父亲节点
        // p : 本次遍历到的节点
        // len : 本节点到根节点的长度
		if (vis[p]) return;
		vis[p] = 1;
		fa[p] = f;
		dis[p] = len;
		if (len > maxlen) {
			maxlen = len;
			maxp = p;
		}
		for (int i = 0; i < vec[p].size(); i++) {
			dfs(p, vec[p][i].v, len + vec[p][i].w);
		}
	}
	
	void work()
	{
		memset(vis, 0, sizeof(vis));
		dfs(-1, 1, 0);
		int u = maxp;
        // 以上：第一次遍历
		maxlen = 0; 
		memset(vis, 0, sizeof(vis));
		dfs(-1, u, 0);
		int v = maxp;
        // 以上：第二次遍历
        // 以 u, v 为节点的这条路径就是树的直径。
	}
}
```

## 4. 暴力出奇迹

蒟蒻：看数据范围，好像可以…… ~~搞事情~~ ！

于是，在 $10$ 分钟后，蒟蒻敲出了一份代码。

大致思路：

1. 两次遍历求树的直径
2. 暴力遍历直径上所有的子路径
3. 对于每条子路径，进行 $dfs$ ，求出离路径距离最远的点到路径的距离
4. 记录答案

时间复杂度 $O(n^3 \times \text{玄学})$ ， 即 $O(\text{能过})$

## 5. 懵懵懂懂 $AC$ 了
咳咳，没错就是这样，由于数据的 ~~``water 性``~~ ， 我们 $AC$ 了。
 
本人提交记录： [R15356804](https://www.luogu.org/recordnew/show/15356804)

代码就不放了，毕竟核心代码（求直径）已经放出来了。

2019-01-17 upd：更快的算法，能过 [bzoj](https://www.lydsy.com/JudgeOnline/problem.php?id=1999) 毒瘤数据。题解地址：https://hkxa.blog.luogu.org/solution-p1099-v3