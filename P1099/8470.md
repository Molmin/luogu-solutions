#算法楼下已经说得很清楚了哈,但我还是要补充一些:


算法一,就是楼下说的：模拟。

“题目说什么，我们做什么”。这是模拟算法的根本思想。本题中，我们可以通过这样的办法进行模拟：

1、     通过Floyd算法求出顶点对之间的最短路径，并记录下具体的最短路径。

2、     标记所有在直径上的点。

3、     枚举路径的起点，进行DFS穷举路径的终点。

4、     对于一条确定下来的路径，通过直接模拟的方法得出偏心矩。

以上算法非常容易理解，算法的时间复杂度为O(n3). 需要注意的是在第3步中，显然一条路径一定会“走到不能再走为止”，因为路径的包含关系决定了偏心矩的大小关系。


算法二：树形动态规划

这是本题最为标准主流的算法，也是最简捷的同时毫无异议地AC本题的算法。

算法首先要求我们找出一条路径（这可以通过著名的“两次BFS”算法得到），然后，选取任意一个在直径上的点作为根节点建立有根树，通过经典树形动态规划确定节点的最长下降路和次长下降路。

然后，算法枚举路径的起点。然后基于下述事实：合法路径只能向最长下降路方向延伸。（如果不是这样，则最长下降路不能被屏蔽，其偏心矩一定不会是最小；另外，合法路径不能像两条路上延伸，因为我们枚举的是路径的起点）。通过这个事实，很容易进行一个简单的树形动态规划在O(n)的时间内对于每一个确定的起点给出这种情形下的最小偏心矩。

该算法的时间复杂度为O(n2)，且简洁明了，是本题的正统算法。


接下来叙述的两个进阶算法，都需要掌握一些有关本题的贪心性质。

性质一：必然存在一个核，使得该核覆盖树的中心所在的边所连接的两个顶点中的一个。

这个性质还可以做这样的理解：

1、     如果中心在一个节点上，则这个节点一定在某个核上。

2、     如果中心所在边的长度不超过s，则这条边一定在某个核上。

3、     如果中心所在边长度超过s（不可选入），则这条边的两个端点至少有一个在核上。

这个性质其实是不难理解的。如果中心所在的边不被选入，则偏心矩一定超过直径的一半。但是一旦中心所在的边被选入，则偏心矩一定不超过直径的一半。这就用最简捷的语言解释了性质的正确性（当然，对于情形3，严格的证明还需要作进一步的讨论）

根据这个性质，我们就可以直接确定至多2个节点，这些节点一定在核上。只需要对这些节点作出运算，就可以得到符合题意的最小偏心矩。由此产生算法三。

算法三：贪心性质+二分答案。

如果我们已经知道了最小偏心矩，同时也知道指定的有根树中根必然在核上，则我们可以对每一个节点作一次从下到上的遍历，一旦长度超过给出的最小偏心矩，就将接下来的节点进行标记。（当然，这个过程直接进行的复杂度是O(n2)的，但是借鉴算法二中的动态规划，我们可以很轻松地通过自上而下的规划把复杂度降到O(n)）。然后，我们观察被标记的节点（这些节点必须在核上）是否能够形成一条满足题意的核。

要形成满足题意的核，必须满足这样几个条件：

1、     必须形成一条路径，不能有分支。

2、     必须向最长下降路或者是在直径上的次长下降路进行延伸。

3、     路径的长度不能超过s.

以上的3点判断都能在O(n)的动态规划中予以验证。故本题可以在O(n)的时间内完成对某一个已知最小偏心矩的判断。

鉴于最小偏心矩的可行性是单调的，我们采用二分答案的方法可以解决本题，算法得时间复杂度为O(nlogc)，其中c是给定的图中直径的长度。从本题来看，c <= 300,000


性质二：对于图中的每一条直径，都存在一段满足题意的核。

这个性质的证明稍显麻烦。可以这样考虑：假设当前直径上不存在满足题意的核。但是，根据直径与图的连通性，当前直径上一定存在某一条核的某一段，而那条核的剩下的两端位于另一条直径上；换言之，我们认为此事一定存在类似>---<这样的结构。

这时，根据直径的最长性，我们不难给出两端不重合部分的长度对应相等（否则，产生另一条直径）。根据偏心矩的定义，此时直径的剩下两段不管像那个方向进行延伸，偏心矩都是不变的（比方说在>---<形状中的<中，你选择项上面延伸，则下面的长度就会成为偏心矩；反之亦然。由于你无法同时向两个方向延伸，所以偏心矩是不会变的）。这就意味着，对于两条相交的直径，核只与直径相交部分有关。从而证明了我们的断言：对于图中的每一条直径，都存在一段满足题意的核。

这个性质意味着我们不需要关注图中的所有直径，而只需要选择其中的一条直径。这就世界导致了本题的最优算法。

算法四：贪心性质+单调队列

首先还是通过“两次BFS”给出图中的直径长度以及一条具体的直径。然后，对于该条直径而言，将所有的不再这条路径上的点作为“外向树”插在路径上。与之同时，记录路径上每个节点v的外向树中最长边dist[v]以及距离起点（起点可以随意指定，通常以路径起点作为起点）的“绝对坐标”loc[v]，对于路径的终点x来说，假设其起点为st，（显然st越小越好），则其对应的偏心矩ECC(x)可以由下式给出：

其中top表示路径的长度。

不难看出，ECC(x)有三项最大值组成，第二项最大值可以通过打擂台简单地实现，但是第一项和第三项由于有删除操作，必须通过单调队列才能实现。由于删除时从左到右严格升序进行的，所以我们只要维护一个单调递减的队列就可以完成任务了。（如果元素j和i满足 ，则元素i是不必要的。）

[color=red] 该算法的时间复杂度为O(n)，是本题的最好算法。[/color]


摘自度娘..


下面是程序(摘自某位大神的blog）:


```delphi

var
 f:array[0..300,0..300]of longint;
 a:array[1..300]of longint;    b:array[1..300]of boolean;
 n,i,j,k,l,m,s:longint;
function max(a,b:longint):longint;
begin if a>b then exit(a) else exit(b);end;
function min(a,b:longint):longint;
begin if a<b then exit(a) else exit(b);end;
begin
  read(n,s);
  for i:=1 to n do for j:=1 to n do if i<>j then f[i,j]:=$7FFFFFF;
  for i:=2 to n do begin read(j,k,l);f[j,k]:=l;f[k,j]:=l;end;
  for i:=1 to n do for j:=1 to n do for k:=1 to n do
      if f[j,i]+f[i,k]<f[j,k] then f[j,k]:=f[j,i]+f[i,k];
  m:=0;for i:=2 to n do if f[1,i]>m then begin m:=f[1,i];j:=i;end;
  m:=0;for k:=1 to n do if f[j,k]>m then begin m:=f[j,k];i:=k;end;
  m:=maxlongint;
  for k:=1 to n do if f[i,k]+f[k,j]=f[i,j] then
   for l:=1 to n do  if f[i,l]+f[l,j]=f[i,j] then
    if (f[k,l]<=s)and(max(min(f[i,k],f[i,l]),min(f[j,k],f[l,j]))<m) then
    m:=max(min(f[i,k],f[i,l]),min(f[j,k],f[l,j]));
  writeln(m);
end.

```
