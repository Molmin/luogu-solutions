- **NOIP 2007 提高组 第四题**

## 题目描述

设 $T=(V, E, W)$ 是一个无圈且连通的无向图（也称为无根树），每条边到有正整数的权，我们称T为树网（treebetwork），其中 $V$ ， $E$ 分别表示结点与边的集合， $W$ 表示各边长度的集合，并设 $T$ 有 $n$ 个结点。

**路径**：树网中任何两结点 $a$，$b$ 都存在唯一的一条简单路径，用 $d(a, b)$ 表示以 $a, b$ 为端点的路径的长度，它是该路径上各边长度之和。我们称 $d(a, b)$ 为 $a, b$ 两结点间的距离。

$$D(v, P)=min\{d(v, u), u\text{为路径P上的结点}\}$$。

**树网的直径**：树网中最长的路径成为树网的直径。对于给定的树网 $T$ ，直径不一定是唯一的，但可以证明：各直径的中点（不一定恰好是某个结点，可能在某条边的内部）是唯一的，我们称该点为树网的中心。

**偏心距 $ECC(F)$** ：树网 $T$ 中距路径 $F$ 最远的结点到路径 $F$ 的距离，即

$$ECC(F)=max{d(v, F),v ∈ V}$$

**任务**：对于给定的树网 $T=(V, E, W)$ 和非负整数 $s$ ，求一个路径　$F$ ，他是某直径上的一段路径（该路径两端均为树网中的结点），其长度不超过 $s$（可以等于 $s$ ），使偏心距 $ECC(F)$ 最小。我们称这个路径为树网 $T=(V, E, W$ )的核（Core）。必要时， $F$ 可以退化为某个结点。一般来说，在上述定义下，核不一定只有一个，但最小偏心距是唯一的。

下面的图给出了树网的一个实例。图中， $A-B$ 与 $A-C$ 是两条直径，长度均为 ``20``。点 $W$是树网的中心，$EF$ 边的长度为 ``5``。如果指定 $s=11$，则树网的核为路径 $DEFG$（也可以取为路径 $DEF$），偏心距为``8``。如果指定$s=0$（或$s=1$、$s=2$），则树网的核为结点 $F$ ，偏心距为``12``。


![](https://cdn.luogu.com.cn/upload/pic/20270.png)

## 输入输出格式

- 输入格式

输入文件``core.in``包含 $n$ 行：

第 $1$ 行，两个正整数 $n$ 和 $s$ ，中间用一个空格隔开。其中 $n$ 为树网结点的个数， $s$ 为树网的核的长度的上界。设结点编号以此为 $1,2,……,n$ 。

从第 $2$ 行到第 $n$ 行，每行给出 $3$ 个用空格隔开的正整数，依次表示每一条边的两个端点编号和长度。例如，“``2 4 7``”表示连接结点 $2$ 与 $4$ 的边的长度为 $7$ 。

所给的数据都是争取的，不必检验。


- 输出格式

输出文件core.out只有一个非负整数，为指定意义下的最小偏心距。


## 输入输出样例

- 输入样例

```
【输入样例1】
5 2
1 2 5
2 3 2
2 4 4
2 5 3
【输入样例2】
8 6
1 3 2
2 3 2 
3 4 6
4 5 3
4 6 4
4 7 2
7 8 3
```

- 输出样例

```
【输出样例1】
5
【输出样例2】
5
```

## 说明

$40\%$的数据满足：$5 \leq n \leq 15$；

$70\%$的数据满足：$5 \leq n \leq 80$；

$100\%$的数据满足：$5 \leq n \leq 300,0 \leq s \leq 1000$。边长度为不超过 $1000$ 的正整数。

## 简要题意

> 给定一棵带边权无根树，在其直径上求出一段长度不超过 $s$ 的路径 $F$，使得离路径距离最远的点到路径的距离最短。

## 题解

### 一些定义

$f_{i,j}$：结点 $i$ 到结点 $j$ 的最短距离。

### 前置芝士

- **树的直径**怎么求？

对于一棵树 $T$ 可以取它的根节点（其他节点也可以，题中的根节点为 1），然后找到一个离它最远的结点 $x$ ，即满足 $f_{1,x}=\max_{i=1}^n f_{1,i}$。

然后找到离 $x$ 最远的点 $y$ ，它们就是这棵树 $T$ 中的一条直径的两个端点。

- 怎么快速求**多源最短路**？

Floyd！

### 正文

我们可以暴力枚举 $F$ 的两个端点 $i$ 和 $j$ 。然后搞一下答案就可以辣！

时间复杂度 $O(n^3)$ 。

怎么做？对于树 $T$ 中的一条端点为 $i$ 和 $j$ 的路径 $F$，对于树网 $T$ 中的一个点 $k$ ，$dis(k,F)=(f_{i,k}+f_{k,j}-f{i,j})/2$，然后根据这个搞就可以辣。

为什么？看图！

### 举个栗子

首先我们想一下这个柿子是怎么得到的。我们试着用 $f$ 数组来表示一下 $dis(k,F)$ 。

首先我们假设 $k$ 点离这条路径上的点 $l$ 最近，那么 $l$ 的取值只有 3 类情况。

1. 在 $F$ 的一个端点 $i$ 上。

2. 在 $F$ 的另一个端点 $j$ 上。

3. 在 路径 $F$ 上（端点除外）。

画一下图您大概就可以感性理解啦！

(1) ![](https://i.loli.net/2018/12/31/5c2a1a6ac9709.png)

(2) ![](https://i.loli.net/2018/12/31/5c2a1a6acbabb.png)

(3) ![](https://i.loli.net/2018/12/31/5c2a1a6ad836d.png)

## 代码

```
#include <cstdio>
#include <cstring>
int ans=999999999,n=0,s=0;
int f[301][301];
bool flag=false;
int min(int x,int y)
{
    return x<y?x:y;
}
int max(int x,int y)
{
    return x>y?x:y;
}
int main()
{
    memset(f,127/3,sizeof(f));
    scanf("%d %d",&n,&s);
    for(int i=1;i<=n-1;i++)
    {
        int x=0,y=0,c=0;
        scanf("%d %d %d",&x,&y,&c);
        f[x][y]=f[y][x]=c;
    }
    for(int i=1;i<=n;i++)
    {
        f[i][i]=0;
    }
    for(int k=1;k<=n;k++)
    {
        for(int i=1;i<=n;i++)
        {
            for(int j=1;j<=n;j++)
            {
                f[i][j]=min(f[i][j],f[i][k]+f[k][j]);
            }
        }
    }
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=i;j++)
        {
            if(f[i][j]<=s)
            {
                int da=0;
                for(int k=1;k<=n;k++)
                {
                    da=max(da,(f[i][k]+f[k][j]-f[i][j])/2);
                }
                ans=min(ans,da);
            }
        }
    }
    printf("%d",ans);
    return 0;
}
```

## 参考资料

- ``https://sparky.blog.luogu.org/solution-p1099`` 。