# 路过的靓仔看过来！
走过路过，千万不要蒟蒻！

这道题狠友男赌，尻（考）的不仅仅是码力，毒题能力，更是叔上问题功底的检测，无论各位现在是在普及组还是提高组，都十分值得来刷一下这道经典题目。



------------
### 直接切入主题

总结一下题目，其实就是要求在一棵树的直径上的一段路径的离它最远结点的距离。

思路其实很~~简单~~，只是先求出树上**直径**，然后在直径上取**路径**，要求**偏心距**最小。

#### 大家应该树上直径都会做了吧？

什么？不会？

树上直径的做法就是两遍dfs先从o点出发找最远点，在从最远出发，再找最远点。

然后在树上取路径嘛，用树上尺取法。

定义dis[i]表示i点离1号节点，也就是根节点的距离。还有一个奇怪的mark数组，初看好像没有任何用处，其实在后面是一个牛（hei）逼（an）的技巧。


------------
先来看一下这段程序

```cpp
void dfs(int f,int x){
    fa[x]=f;
    if(dis[x]>dis[k])k=x;
    for(int i=head[x];i;i=E[i].nxt){
        int y=E[i].to;
        if(y==f||mark[y])continue;//这行mark[y]是不是看起来毫无厘头？
        dis[y]=dis[x]+E[i].w;
        dfs(x,y);
    }
}

```
Fa数组记录了当前结点的父亲结点，这个技巧很常用吧。但是在后面树上尺取时，它发挥了巨大的作用。

上面的代码除了我标出来的那一行，其他的应该都很好理解吧？树上直径几乎是模版。


------------
```cpp
 scanf("%d%d",&n,&m);
  for(int i=1;i<n;i++){
        scanf("%d%d%d",&x,&y,&z);
        add(x,y,z),add(y,x,z);
   }
  dis[1]=1,dfs(0,1);
  dis[k]=0,dfs(0,k);
  top=k

```
先把根节点标为1，然后以根节点（1号节点）为根节点做最远路，最后k迭代出来的就是最远点。

然后把k点标为0，然后以k结点为根再做一遍树上最远路，现在的k就是直径的第二个端点了，第一个是1（根节点）。


------------
### 然后就是骚得要死的树上吃蛆了

```cpp
for(int i=top,j=top;i;i=fa[i]){
        while(dis[j]-dis[i]>m)j=fa[j];      
        x=max(dis[top]-dis[j],dis[i]); 
        ans=min(ans,x);
 }

```
首先，这条虫子的头（i）和尾（j）都是top，也就是直径的一个端点。

然后，就是循环主体了，这里有是一个容斥，想想看，从根结点到尾部的距离减去根节点到头部的距离，是不是就是头到尾的距离？也就是虫子长度。我们题目中限制了虫子长度为s，于是当长度大于s时，就要尾巴往前缩。X取的是当前头部到根节点的距离。

但是
## 这个就是偏心距了吗？


------------
## 我信你个鬼！
当然不是！举个栗子。下图中，你难道认为路径i~j的偏心距是根节点？（我说的根结点是i上面那个离他距离为1的点）

![no](https://cdn.luogu.com.cn/upload/pic/73536.png)

很明显不是！

所以我们要再做一次，把每个直径上的点的最远距离找出来。

------------
```cpp
for(int i=top;i;i=fa[i])mark[i]=1;
 for(int i=top;i;i=fa[i]){
        k=i,dis[k]=0;
        dfs(fa[i],i);
 }

```
首先把直径上面每一个点都标记在mark中，然后从直径尾部到根节点（就是遍历整个直径）找出每个结点为根是的最远点。最远距离在dis数组中。

```cpp
for(int i=1;i<=n;i++) ans=max(ans,dis[i]);

```
这就很好理解了，每个结点的最远点距离取最大值，就是题目定义的偏心距。

最后输出就可以。


------------
这道题嘛，说难也很难，说简单也蛮简单的，首先

![](https://cdn.luogu.com.cn/upload/pic/73541.png)

先总结题目，然后找准思路

![](https://cdn.luogu.com.cn/upload/pic/73542.png)

这道题就可以迎刃而解了！！