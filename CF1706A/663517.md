## 题意

给你一个长度为 $n$ 的数列 $a$，初始有一个长度为 $m$ 的字符串，初始全为 B，进行 $n$ 次操作，每次操作你可以选择将字符串里第 $a_i$ 位或者第 $m+1-a_i$ 位改为 A，问字典序最小的字符串。

# 分析

很容易想到一种贪心策略：优先改前面的，前面已经改了就该后面的。

证明很容易，字典序是从前往后依次比较的，在前面字典序越小，整个字符串的字典序越小。

在具体实现中，可以用 $c$ 数组记录当前字符种类（$0$ 为 B，$1$ 为 A），每次只读一个 $a$（这样不用开 $a$ 数组了，节省空间），接下来判断 $a_i$ 与 $m+1-a_i$ 是否用过，用过就选另一个，否则 $a_i$ 与 $m+1-a_i$ 哪个小选哪个。

#### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;   
int t, n, m, a, c[1010];
signed main () {
	cin >> t;
	while (t--) {
		memset(c, 0, sizeof(c));//初始化为全 B 
		cin >> n >> m;
		for (int i = 1; i <= n; i++) {
			cin >> a;
			if (c[a])//如果已经被改了
				c[m + 1 - a] = 1;
			else if (c[m + 1 - a])//同上
				c[a] = 1;
			else {
				if (a > m + 1 - a)//选小的
					c[m + 1 - a] = 1;
				else	
					c[a] = 1;
			}
		}
		for (int i = 1; i <= m; i++)
			cout << ((c[i] == 1) ? 'A' : 'B');
		puts("");
	}
	return 0;
}
```
