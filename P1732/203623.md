再发一篇基于数据范围的题解吧（就是做一些优化）

“基于数据范围”其实大致就是这样：

比如：1，2，3，4，5

一开始标记数组都为空

0，0，0，0，0

然后边读边做（第一个数单独输入，把和设为第一个数）

1. 1，0，0，0，0；和：1

后面的数先输入，然后用两个指针（初始值都为这个数）依次向两边递增（减），直到找到标记为止。然后把和增加先找到标记的指针位置于输入的数的差的绝对值。

2. 1，1，0，0，0；和：2

3. 1，1，1，0，0；和：3

4. 1，1，1，1，0；和：4

5. 1，1，1，1，1；和：5

分析优化：

首先，由于只用输出b数组的和，是不用新开一个b数组的，只用一个变量来记录和。

其次，很多dalao都用了memset。其实不用清空数组。把标记数组设为int，然后改变每一组数据的标记即可（比如第t组数据用t来标记）。

还有，越界判断也可以优化：用两个变量记录输入数据的最大值和最小值，然后判断指针是否超出范围。

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[70000];//标记数组
int main() 
{
	int n,p,t,i,j,k,s,m,mn,mx;
	cin>>t;
	for(i=1;i<=t;i++)//必须从1开始，因为标记数组的初始值为0
	{
		cin>>n>>p;
		for(a[p]=i,mn=mx=s=p,j=1;j<n;j++)//特判第一个数
		{
			cin>>p,m=1e9;
			for(k=p;k>=mn&&a[k]!=i;k--);//第一次查找
			if(a[k]==i) m=p-k;//记录差的最小值
			for(k=p;k<=mx&&a[k]!=i;k++);//第二次查找
			if(a[k]==i) m=min(m,k-p);//记录差的最小值
			s+=m,a[p]=i,mx=max(mx,p),mn=min(mn,p);//记录上界和下界，标记
		}
		cout<<s<<endl;
	}
}
```
