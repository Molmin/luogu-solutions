### 题目大意

给定 $n$ 个数 $a_1,\cdots,a_n$。对于排列 $\sigma$，依次确定 $b_1,\cdots,b_n$，其中 $b_i=0$ 或 $m$。若 $b_1,\cdots,b_{i-1}$ 的平均数大于 $a_{\sigma_i}$，则 $b_i=0$，否则 $b_i=m$。求 $\sum b_i$ 的最大值和最小值。

$n,m\le 10^5$，$0\le a_i\le m$。

### 题解

我本来想每道题看一看口胡个解法就完事了，结果这道题代码太简单，~~我忍不住就写了~~

回归正题。官方题解写的对我而言有点难以理解，事实上这道题是一道数学题。

我们先考虑最大值，其实就是让 $b_i=m$ 的 $i$ 尽量多。对于 $a_i$ 较大的，我们不用担心，所以最重要的是拉较小 $a_i$ 的票。注意到开始的平均分是 $0$，所以不妨让最小的 $a$ 放到第一位，这样它会贡献一个 $m$。更进一步地，如果想持续不断地造出 $m$，那么小的 $a$ 一定要放在前面，要不然后面平均值就大了。

所以自然就想到了结论：

- 满足 $a_{\sigma_1}\le \cdots\le a_{\sigma_n}$ 的排列 $\sigma$，即**从小到大排序**，一定取到最大值。

我们对这个结论进行证明。仿照排序不等式的证法，考虑两个相邻项 $a_{\sigma_i},a_{\sigma_{i+1}}$。若前者大于后者，我们将它们交换，证明答案不会更劣。分四种情况讨论。下简称 $a_{\sigma_i}=A_i$。

1. $b_i,b_{i+1}=0$，此时不可能更劣。
2. $b_i=m,b_{i+1}=0$。交换后，若 $b_i$ 仍为 $0$，则 $b_{i+1}$ 一定为 $m$。因为交换前 $b_i=m$，说明 $b_1,\cdots,b_{i-1}$ 的平均值 $avg\le A_i$，而交换后，$b_1,\cdots,b_i$ 的平均值 $avg'\le avg$，且 $A_{i+1}$ 与交换前的 $A_i$ 相等。自然有 $avg'\le A_{i+1}$。
3. $b_i=0,b_{i+1}=m$。仿照上述证明，若交换后 $b_i=0$，一定有 $b_{i+1}=m$。
4. $b_i,b_{i+1}=m$。我们可以先说明 $b_i$ 交换后一定为 $m$（相似于上述证明）。这表明 $b_1+\cdots+b_{i}$ 交换前后都不变，但是 $A_{i+1}$ 增大了，$b_{i+1}$ 更应该是 $m$ 了。

对于不满足从小到大顺序的 $\sigma$，一定可以找到 $A_i>A_{i+1}$，交换后答案一定更佳。仿照冒泡排序调整即证！

同理，我们也可以证明，当从大到小排序的时候，一定取到最小值。毕竟最小值和最大值是对称的嘛。

然后这道题代码就太容易了！

### 代码

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int N=100005;
int n;
ll m;
ll a[N],sum=0;
int main(){
	scanf("%d%lld",&n,&m);
	for(int i=1;i<=n;i++) scanf("%lld",&a[i]);
	sort(a+1,a+n+1);
	sum=0;
	for(int i=1;i<=n;i++){
		if(sum<=a[i]*(ll)(i-1)) sum+=m;
	} 
	printf("%.2lf ",(double)sum/n);
	sum=0;
	for(int i=n;i>=1;i--){
		if(sum<=a[i]*(ll)(n-i)) sum+=m;
	} 
	printf("%.2lf",(double)sum/n);
}
```