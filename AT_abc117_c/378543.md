# 1. 题意概述

利用数轴和$N$个棋子进行一个单人游戏。

初始你可以将棋子放在数轴的任意整数坐标位置，同一个位置可以放置多于一个棋子。

接下来移动棋子，每次移动只能选择一个处于坐标$x$的棋子，移动到$x+1$或者$x−1$坐标。

另有$M$个目标地点$X$，要使每个目标地点都至少被1个棋子访问到，至少需要多少次移动。（最初放置棋子的位置也视作访问到）

# 2. 思路
从$1$颗棋子分析到$M$颗棋子：

## 1颗棋子：
 
 这颗棋子就要从**最小坐标走到最大坐标**，所以答案就是**最大坐标`ma`和最小坐标`mi`的差值**。

## 2颗棋子：
因为最初放置的位置也视作访问到，所以棋子肯定是放在某两个目标点上面，然后再遍历它们之前与之后的所有目标点。

样例1刚好就是2颗棋子：
>2 5
>10 12 1 2 14

### 示意图：
![](https://cdn.luogu.com.cn/upload/image_hosting/5o7b7la5.png)

### 答案是这么来的（橙色的是走过的路）：

棋子的坐标分别为2和10。
![](https://cdn.luogu.com.cn/upload/image_hosting/i143g8zi.png)

观察一下，我们发现这个答案之所以最优，是因为它利用2个棋子相对于1个棋子的优势，少走了2~10这一段路。那为什么最优解是刚好是少走2~10那段路不是别的路呢？因为那段路是相邻两点距离中最长啊！

所以最优解就是不走最长的那段路，即**最大坐标`ma`和最小坐标`mi`的差值再减去距离最大的两个相邻目标点的距离**。

## 3个棋子：
3个就是可以少走两段路。显然此时的最优解一定就是最大坐标`ma`和最小坐标`mi`的差值再减去距离最大与第二大的两个相邻目标点的距离



---
以此类推，$m$个棋子就是$ma-mi-(a[1]+a[2]+a[3]+a[4]+...+a[m])$（`a[i]`是第$i$大的距离）

概括一下就是：存下所有相邻两点间的距离，挑出最大的$m-1$个，减掉。


然后就可以写代码啦！！！


# 3. 代码实现

根据前面的分析，很明显我们需要一个数组存坐标与坐标之间的距离，然后还要记录最大坐标和最小坐标。

另外为了计算最大的$(m-1)$个距离，要用`sort`排序。由于要最大的，所以我写了个`cmp`函数，去让它从大到小排。

剩下的看代码估计就可以看懂了。

###### 注：蒟蒻的马蜂有点难看，大家将就着看吧

```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
using namespace std;
const int MAXN=1e5+5;
int n,m;
int x[MAXN],a[MAXN];
bool cmp(int a,int b){
	return a>b;
}
int main(){
	cin>>n>>m;
	int ma=-1e9,mi=1e9;
	for(int i=1;i<=m;i++){
		cin>>x[i];
		ma=max(ma,x[i]);
		mi=min(mi,x[i]);
	}
	sort(x+1,x+m+1);
	for(int i=1;i<m;i++){
		a[i]=x[i+1]-x[i];
	}
	sort(a+1,a+m+1,cmp);
	int ans=ma-mi;
	for(int i=1;i<n;i++){
		ans=ans-a[i];
	}
	cout<<ans<<endl;
	return 0;
}
```