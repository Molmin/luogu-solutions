我们先来看题。额，看不懂，那我来翻译一下。
### 题意
一开始，你可以把棋子放在数轴的任何位置，可以重叠。
接下来可以把任意一个棋向两边移动一个单位。
最后使得给出的几个点都被旗子踩到过。

### 分析方法
看懂题目，下一步就是分析。

这道题求的是最值，而且是可以认为移动和放置棋子，所以肯定是贪心思想。
问题就来了：怎么个贪法？

这道题有 1 个关键因素，如何放置，才能使路程少走？

必然要开始就放在目标点上。问题又来了：放在哪些点上？

我们来分析一下样例：有 $2$ 颗棋子时，样例放在了 $2$ 和 $10$ 上，而很容易可以想到 $2$ 和 $10$ 是数轴上任意2个相邻点之间最大的一对。放在这一对上是因为这样就可以避免出现一个棋子要跨越很长的一段距离去下一个目标点的情况。

那么我们就可以得出一个结论：当有 $x$ 棋子时，就可以少走 $x$ 段长度。

接下来，很容易可以得知节约的那段长越大越好，所以我们就可以记录每个相邻两点之间的距离，再进行 sort 排序，就可以了。

### 分析如何求解

知道方法，主程序就比较简单了，就是代码能力的问题。这里贴一下核心代码。

```cpp
for(int i=1;i<m;i++) dis[i]=num[i+1]-num[i];//相邻2个目标点的差。
sort(dis+1,dis+m);
ans=num[m]-num[1];//取一头和一尾，再两边和题目无关。
for(int i=m-1;i>=m+1-n;i--) ans-=dis[i];//求解答案。
```

#### 题后总结

这道题，思维能力普及，但是代码能力入门。