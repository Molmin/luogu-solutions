这道题首先一个很显然的贪心思路就是我们必须依次遍历每个目标点，这样不会走回头路，移动次数显然更少，并且因为题目说 “最初放置棋子的位置也视作访问到” ，所以我们放棋子的位置肯定是选择某个目标点。

我们可以把一个棋子移动的范围看作是一段区间，那么问题就被转化为求覆盖所有目标点的区间长度和的最小值。

假如我们多了一个棋子，就可以把一段区间拆成两段区间，这样就能少算这两段区间中间的那一截距离。

那么答案就是每两个目标点之间距离的总和减去最大的 $n-1$ 个距离。

核心代码：

```cpp
const int N=1e5+10;
int n,m,ans,a[N],b[N];
signed main()
{
	n=read();m=read();
	for(ri int i=1;i<=m;++i)
		a[i]=read();
	sort(a+1,a+m+1);//对目标点位置进行排序,方便计算
	for(ri int i=1;i<m;++i)
		b[i]=a[i+1]-a[i];
	sort(b+1,b+m);//计算出每两个目标点之间的距离并排序
	for(ri int i=1;i<=m-n;++i)
		ans+=b[i];
	cout<<ans;
	return 0;
}