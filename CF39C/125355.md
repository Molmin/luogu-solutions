# 题目

[传送门](https://www.luogu.com.cn/problem/CF39C)

# 题解

~~研究了俩小时，终于是看懂了题解~~

首先简化题目：可以将这些在同一直线上的圆看做是在直线上的一些区间，现在我们要求最多能选多少区间使得这些区间不相交，并输出任意一种最多的选择情况。

然后，我们可以构想一下最后的状态是什么样子：选了一些很大的不相交的区间，在这些区间中又分别选一些不相交的次大的区间，一直迭代直到小的区间中没有更小的区间可选

那么，对于某一区间 $[l,r]$ 我们可以**假定**有某一 $[l,i]$ 和 $[i,r]$ 的区间（不一定存在）将其分成两个部分，在这俩部分中我们进行递归在 $[l,i]$ 和 $[i,r]$ 中寻找，显然这个 $i\in [l,r]$，如果我们直接枚举，那么这个算法的复杂度显然为 $\mathcal O(n^3)$

考虑对其进行优化，注意到算法瓶颈在于区间 $[l,i]$ 和 $[i,r]$ 都是我们假定存在的，所以我们需要寻找 $[l,r]$ 中的所有 $i$ 以避免不漏掉小区间，但是我们是否可以直接钦定某一边是存在，另一边是虚构的呢？显然可行，储存以 $l$ 为左边界的所有区间中, 他们的右边界有哪些，只需要在这些右边界中对区间 $[l,r]$ 进行划分即可，这样优化之后，算法整体的复杂度**均摊来算**，是 $\mathcal O(n^2)$ 的

在区间处理完之后，我们需要考虑是否存在 $[l,r]$ 这样的区间，将整个区间框起来（这是合法的），如果存在加上即可

因为题目还要求我们输出方案，所以我们可以用另一个数组记录一下某一个区间的分界线，在输出方案时亦可递归寻找

对于算法的一个优化，因为区间 $[l,r]$ 的最优性是独立的，所以我们可以用 $f$ 记录一下某一区间的最优解，再次访问时可直接返回

为了方便处理，其实我们可以将这些区间的左右端点进行离散化，这里不作过多说明

对于方法，我也不知道该说是 $DP$ 还是记忆化搜索了...

# 代码

```cpp
https://www.cnblogs.com/Arextre/p/13389763.html
```