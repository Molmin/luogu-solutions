### 思路分析

题目意思说的很清楚了。

首先，位数是固定的，$n-k$ 位。在这样的情况下，肯定最大位越大越好。所以我们无论后面，先把最大位找出来。

所以，我们只要找到一位，把这一位前面的数都删去就好了。

开一个栈 $s$ 记录没被删的数位。

先把当前的数存储为 $t$ 然后```pop```出去，接下来往前枚举，知道出现某个数 $p>t$，停止枚举。因为往前再有 $<t$ 的数也会被 $p$ 删掉。

举个例子：

$n=5 \; k=4 \; num=14928$。

| code | $s$ | $t$ | $k$ |
| :----------: | :----------: | :----------: | :----------: |
| ```s.push(1)``` | $\red{1}$ | $-$ | $4$ |
| ```s.push(4)``` | $1\;\red{4}$ | $-$ | $4$ |
| ```s.pop()``` | $1$ | $4$ | $4$ |
| ```s.pop()``` | $-$ | $4$ | $3$ |
| ```s.push(t)``` | $4$ | $-$ | $3$ |
| ```s.push(9)``` | $4\; \color{red}9$ | $-$ | $3$ |
| ```s.pop()``` | $4$ | $9$ | $3$ |
| ```s.pop()``` | $-$ | $9$ | $2$ |
| ```s.push(t)``` | $9$ | $-$ | $2$ |
| ```s.push(2)``` | $9\; \color{red}2$ | $-$ | $2$ |
| ```s.push(8)``` | $9\;2\; \color{red}8$ | $-$ | $2$ |
| ```s.pop()``` | $9\;2$ | $8$ | $2$ |
| ```s.pop()``` | $9$ | $8$ | $1$ |
| ```s.push(t)``` | $9\;8$ | $-$ | $1$ |

此时，我们发现，所有位置都处理完了，但 $k$ 仍然不为 $0$。

这时候的 $s$ 因为所有位置都保证前面没有小于自己的数了，所以此时 $s$ 单调不增。那剩下的 $k$ 位就删小的就可以，也就是末尾的 $k$ 位。

注意到如果直接输出那么会反，所以就倒过来再输出就行了。