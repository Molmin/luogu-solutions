### 其实写着篇题解的目的：帮助Oier们识别数学题，以及怎么想此类题QwQ

~~其实感觉这题解里全讲怎么证明，但未说为何如此做~~

**正文**

思路：

1.暴力枚举，求解可能情况？ 

显然不行。可能性太多，毕竟二十元一次不等式啦。QAQ
      
2.排序+人脑模拟=>剪枝
  
从小到大开始，尽量绝对值相近的正负值抵消？
  
但某一方出现极大值，这种思路显然会被卡掉。

另：

当到了这时，你发现很多算法对不上号；
  
你或许会考虑dp，但dp的状态很多时候就是dfs等的变量；
  
不过我们已在 1. 2. 情况下将其否定，这时就应该考虑数学;
  
(或者数据结构，其实有些数据结构题，根本看不出来，完全就是数学的题面，可你发现用不了数学定理)
    
3.我们已确定是道数学题后，细读题面:

集合{a}总与集合{x}配对，s求最小。

再者，观察样例挖取信息：gcd(4059,-(-1782))=99;

然后，看看是否有mod，逆元之类的，确信没有；

得知以上信息后:

s与a,x的函数有关，而又有gcd影响，考虑：裴蜀定理

**裴蜀定理:**

1. 
```cpp
关于未知数x和y的线性不定方程(称为裴蜀等式):
若a,b是整数,且gcd(a,b)=d;
那么对于任意的整数x,y,ax+by都一定是d的倍数;
特别地，一定存在整数x,y,使ax+by=d成立.
```
(以上摘自[百度百科](https://baike.baidu.com/item/%E8%A3%B4%E8%9C%80%E5%AE%9A%E7%90%86/5186593?fr=aladdin))虽然我想直接写公式的,但怕你们不愿细看.

2. 推论:gcd(a,b)=1时,必然存在:ax+by=1;(可逆)
3. 证明:略去(你谷大佬都写完了)
4. 关于本题运用:
```cpp
当在n=3时:
假使:a1*x1+a2*x2=d,且d=b*y;
那么:d+a3*x3=s>0;
由裴蜀定理:
     d=gcd(a1,a2);
     s=gcd(b,a3);//d与b有关
因为:d由a1,a2计算而来,s由d,a3计算而来;
  又:a1*x1+a2*x2为d的倍数;
所以:本题就变为了:连续数列内的反复的gcd出的d值,
     在条件允许之内,我们当然希望数字越小越好;
```
**Code:**
```cpp
#include<bits/stdc++.h>//当然，注意负数
using namespace std;
int main(){
    int n,ans=0,x;
    scanf("%d",&n);
    for(int i=1;i<=n;++i){
        scanf("%d",&x);
        ans=x>0 ? __gcd(ans,x):__gcd(ans,-x);//三目运算符+__gcd()是C++自带的gcd函数+懒人大法好!
    }
    printf("%d",ans);
}
```
rp++