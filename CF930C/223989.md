# 前言：

本篇只是一个蒟蒻详细的总结，大佬可以自行跳过~~


------------


------------

# 一.审题

### 大意：

给出一个 $1$ ~ $m$ 的数列和 $n$ 个小区间，
    
    
  每次询问一个数会给出这个数在几个小区间内，
    
   问最多访问几次后， 
   仍不能确定**并不存在一个数被所有小区间包含**。
   


------------


### 思考：

初看之下，似乎毫无头绪，但我们看题目所要求的东西 :

不能确定**并不存在一个数被所有小区间包含**。

那什么时候我们能确定存在一个数被所有的小区间包含，什么时候不能确定呢？

对着样例 $2$ 模拟一下：



| 数字 | 1 | 2 | 3 | 4 | 5 | 6 |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| 出现次数 | 1 | 2 | 2 | 1 | 2 | 2 |
当我们知道 $3$ ~ $5$ 的出现次数后，可以确定 $4$ 一定是不被所有区间包含，因为 $4$ **一定不被包含 $3$ 和 $5$ 的区间所包含**。

当我们知道 $1$ ~ $4$ 的出现次数时，并**不能确定** $2$ 和 $3$ 是否被所有区间包含。

因此我们得出规律：

 **若存在数字 $i<j<k$，且出现次数 $N_i>N_j<N_k$，可以确定 $j$ 一定不被所有区间包含（即出现 $j$ 为谷底的向下凸的单峰）**。


 **题目求询问后仍不确定的最多次数，也就是反过来，求向上凸的的单峰的最长长度**

------------

------------



# 二.差分
   前面说要用到每个数出现在不同区间的次数，该如何统计呢？
     
   暴力计算当然不行，便要用到**差分**的技巧。
###  1. **作用**
 
在给定几个区间，统计每个数出现的次数。
       
###  2. **实现**
 
类似于**前缀和**（实际上差分是前缀和的**逆操作**）。

       
  当给定给定区间 $[l,r]$ 时，将差分数组 $diff[l]$ 加上1，将 $diff[r+1]$ 减去1(可以自己列数据发现这种方式的正确性）。
      
   最后类似于前缀和，将差分数组加起来。
       
$$diff[i]+=diff[i-1]$$
       
$diff[i]$ 即为第 $i$ 个数出现次数。
       
###  3.**例题**
- [P3406 海底高铁](https://www.luogu.com.cn/problem/P3406)
- [P1083 [NOIP2012 提高组] 借教室](https://www.luogu.com.cn/problem/P1083)


------------

# 三.最长不下降子序列
  求出最长单峰长度要求出最长不下降子序列，下面介绍一种效率高的方法。
     
### 1.实现
（1）用 $up$ 数组存放最长不下降子序列。
     
   （2）比较 $a[i]$ 和 $up$ 数组最后一位，不下降则直接接在 $up$ 数组的后面。
     
   （3）否则在 $up$ 数组中二分查找第一个大于 $a[i]$ 的数，并用 $a[i]$ 代替其，正确性可以在下面给的例题题解中看。
     
### 2.例题
- [P1020 [NOIP1999 普及组] 导弹拦截](https://www.luogu.com.cn/problem/P1020)

- [P1091 [NOIP2004 提高组] 合唱队形](https://www.luogu.com.cn/problem/P1091)


------------
# 四.代码
```cpp
#include<cstdio>
#include<algorithm>
#include<cstring>
using namespace std;
const int N=100005;
typedef long long ll;

ll n,m,a[N],up[N],s1[N],s2[N],len,ans;

int main()
{
	scanf("%lld%lld",&n,&m);
	//差分求每个数字被几个区间包含 
	for(ll i=1;i<=n;i++)
	{
		ll l,r;
		scanf("%lld%lld",&l,&r);
		a[l]++,a[r+1]--;
	}
	for(ll i=1;i<=m;i++)
		a[i]+=a[i-1];
	//从前往后求一遍最长上升子序列的长度 
	memset(up,0ll,sizeof(up));
	len=1;
	up[1]=a[1];
	s1[1]=1;//s1为每个数在从前往后的最长上升子序列长度
	for(ll i=2;i<=m;i++)
	{
		if(a[i]>=up[len])
		{
			up[++len]=a[i];
			s1[i]=len;
		}
		else
		{
			ll d=upper_bound(up+1,up+len+1,a[i])-up;
			up[d]=a[i];
			s1[i]=d;
		}
	}
	//从后往前求一遍最长不下降子序列的长度
	len=1;
	memset(up,0ll,sizeof(up));
	up[1]=a[m];
	s2[m]=1;//s2为每个数在从后往前的最长上升子序列长度
	for(ll i=m-1;i>=1;i--)
	{
		if(a[i]>=up[len])
		{
			up[++len]=a[i];
			s2[i]=len;
		}
		else
		{
			ll d=upper_bound(up+1,up+len+1,a[i])-up;
			up[d]=a[i];
			s2[i]=d;
		}
	}
	//求最长单峰的长度，即为最后的答案
	for(ll i=1;i<=m;i++)
		ans=max(ans,s1[i]+s2[i]-1);//注；-1是因为把自己算了两次
	printf("%lld",ans); 
	return 0;
}
```

     

