## 题目大意：

给你一个无向图，让你把所有边标记方向，并使其没有距离$>=2$的边，问你是否存在并输出方案。

## 题解：

不是，这题蓝的我可以理解，但是能上紫我是真的不知道啊。。而且一个$div.3$的题，$BCD$居然都能紫？？而且你谷判恶意评分居然是按比例排的，想把它评回黄都不行。。

~~以上扯淡，~~来看这道题。先随手画个样例：

![](https://cdn.luogu.com.cn/upload/pic/55674.png)

1. 图中我们可以看到，那个 `1-3-2` 肯定违法了，因为你无论`2-3`怎么连，要么与`1-3`重，要么与`1-2`重。。

2. 但明显的是，`1-6-5-4`可以通过`1`往外连，`5`往内连边的方式造出符合题意的图。

3. 但我们发现，对于`1-7-8-9`即使有4个顶点，若`7-9`有连边则仍不行。。

### ~~于是我们猜想，只要存在奇数环就肯定不行，否则就行。~~

虽然这个猜想十分正确，但显然您并不能根据这短短的一句话敲出一个正确的代码。因为虽然判环我们可以通过拓扑，但判断连边情况却没有一个体系的方法。。

### 于是考虑柯学证明：

**引入黑白染色法，** 将源点（这里默认为1）涂黑，凡是有边相连的涂白，就这样来回染色，我们的样例就变成这样。

![](https://cdn.luogu.com.cn/upload/pic/55675.png)

我们在来观察能否成功连边的情况：

1. 可以看出，原来不能连边的环里都出现了**同色点有直接连边的情况**，证明也是显然的，由于正常黑点连到白点形成偶数的配对，若同色则必会出现奇数条边。

2. 若没有同色连则也很容易的构造出答案：将所有黑点连向白点即可。这样搞的话边是方向交替变的（就像`1-6-5-4`一样）

然后就没有辣！以上操作均可以在一个DFS内完成，上我丑陋的代码：
```cpp
#include <iostream>
using namespace std;

struct ed{
	int u,next,v;
}e[600000];
int n,m,x,y,st=1,fir[300000],col[300000],v[300000];
bool fal;
void add(int x,int y)
{
	e[++st].u=y; e[st].next=fir[x]; fir[x]=st;
	e[++st].u=x; e[st].next=fir[y]; fir[y]=st;
}

void dfs(int x,int fa)
{
	if (v[x]&&col[x]==col[fa]) {fal=1; return;} //同色直接死。
	col[x]=!col[fa]; v[x]++;
	if (v[x]==1) for (int i=fir[x];i;i=e[i].next)
	{
		int u=e[i].u; if (u==fa) continue; //无向图不走回头路。
		if (col[x]) e[i].v=1,e[i^1].v=0; else e[i^1].v=1,e[i].v=0;
     //i^1表示标记它的反边，从网络流那里学的技巧。。
     dfs(u,x); 
	}
}

int main()
{
	cin>>n>>m;
	for (int i=1;i<=m;i++) cin>>x>>y,add(x,y);
	dfs(1,0);
	if (fal) cout<<"NO"<<endl;
	else 
	{
		cout<<"YES"<<endl;
		for (int i=2;i<=2*m;i+=2) cout<<e[i].v;
	}
}
```