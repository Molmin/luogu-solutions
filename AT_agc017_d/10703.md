在博客园食用更佳：[https://www.cnblogs.com/PinkRabbit/p/AGC017.html](https://www.cnblogs.com/PinkRabbit/p/AGC017.html)。

我们考虑根只有一个孩子的情况：显然 Alice 把这条边断掉即可赢得游戏。

如果有两个孩子呢：那就是谁先把其中一条边断掉谁就输掉游戏，然后就可以看成两个子树的子问题。

如果两棵子树的 SG 值相同，则 Alice 输掉游戏，Bob 赢得游戏。

如果有三个孩子呢？我的思路到这里就卡住了。

最后我是观察了如果三棵子树都是往下挂的链的情况：这完全等价于 Nim 游戏。  
而且对于一般的三子树情况或者更多子树的情况我完全没有思路。

根据 Nim 游戏的结论，我只能猜测整棵树的 SG 值应该等于每棵子树的 SG 值**加上** $\boldsymbol{1}$ **后**的异或和。

对着样例验证发现没错，交上去 AC 了。那么这个结论要如何证明呢？

我们注意到，如果有 $k$ 棵子树，那么我们可以把根节点复制 $k$ 份，每个根节点只下接一棵子树。

这样就分成了独立的 $k$ 个游戏，而每个游戏中，根节点只有一棵子树。显然原树的 SG 值等于这些子游戏的 SG 值的异或和。

但是对于根节点只有一个孩子的游戏，它的 SG 值又如何求出呢——已经无法分解成更小的游戏了。

但我们可以证明这样一个结论：对于根节点只有一个孩子的游戏，其 SG 值为其子树的 SG 值加上 $1$。

我们可以这样证明：如果直接断开了根与其子树相连的边，则下一状态的 SG 值为 $0$。  
否则，也就是断开了子树内的边，此时仍然满足根节点只有一个孩子，而且问题规模更小。  
结合数学归纳法，我们可以证明原树可以转移到每个子树能转移到的状态的 SG 值加 $1$ 的状态，从而证明此结论。

所以只要对这棵树做一次 DFS 即可，某棵树的 SG 值为其所有子树的 SG 值加 $1$ 后的异或和。

```cpp
#include <cstdio>
#include <vector>

const int MN = 100005;

int N;
std::vector<int> G[MN];

int DFS(int u, int p) {
	int ret = 0;
	for (int v : G[u]) if (v != p) ret ^= DFS(v, u) + 1;
	return ret;
}

int main() {
	scanf("%d", &N);
	for (int i = 1, x, y; i < N; ++i)
		scanf("%d%d", &x, &y),
		G[x].push_back(y),
		G[y].push_back(x);
	puts(DFS(1, 0) ? "Alice" : "Bob");
	return 0;
}
```