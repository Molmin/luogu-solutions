### 一、题目


#### 题目背景

阴天傍晚车窗外

未来有一个人在等待

向左向右向前看

爱要拐几个弯才来

我遇见谁会有怎样的对白

我等的人他在多远的未来

我听见风来自地铁和人海

我排着队拿着爱的号码牌

#### 题目描述
城市中人们总是拿着号码牌，不停寻找，不断匹配，可是谁也不知道自己等的那个人是谁。

可是燕姿不一样，燕姿知道自己等的人是谁，因为燕姿数学学得好！燕姿发现了一个神奇的算法：假设自己的号码牌上写着数字 $S$，那么自己等的人手上的号码牌数字的所有正约数之和必定等于 $S$。

所以燕姿总是拿着号码牌在地铁和人海找数字（喂！这样真的靠谱吗）可是她忙着唱《绿光》，想拜托你写一个程序能够快速地找到所有自己等的人。

#### 输入格式

输入包含 $k$ 组数据。 对于每组数据，输入包含一个号码牌$S$。

#### 输出格式

对于每组数据，输出有两行，第一行包含一个整数 $m$，表示有 $m$ 个等的人。

第二行包含相应的 $m$ 个数，表示所有等的人的号码牌。

注意：你输出的号码牌必须按照升序排列。

#### 输入输出样例

输入
```
42
```

输出 
```
3

20 26 41
```
#### 说明/提示

对于$100%$的数据，$k≤100, S≤2×10^9 $。



### 二、问题抽象化：

求约数和等于$S$的数。

### 三、需知定理&推导过程：

#### 1.唯一分解定理：

任何一个大于1的自然数N，都可以唯一分解成有限个质数的乘积

$N=P_1^{a_1}*P_1^{a_1}*P_2^{a_2}*…*P_n^{a_n}$，

$PS$：这里$P_1<P_2<…<P_n$均为质数，其诸指数$a_i$是正整数。
这样的分解称为N的标准分解式。

#### 2.约数和定理：

对于任意一个大于1的正整数N可以分解正整数：$N=P_1^{a_1}*P_2^{a_2}…P_n^{a_n}$，

则由约数个数定理可知N的正约数有$(a_1+1)(a_2+1)(a_3+1)…(a_n+1)$个，

那么$N$的$(a_1+1)(a_2+1)(a_3+1)…(a_n+1)$个正约数的和为

$(P_1^0+P_1^1+P_1^2+…+P_1^{a_1})(P_2^0+P_2^1+P_2^2+…P_2^{a_2})…(P_n^0+P_n^1+P_n^2+…P_n^{a_n})$


用搜索将$N$分解为$(P_1^0+P_1^1+…+P_1^{k_1})(P_2^0+P_2^1+…+P_2^{k_2})…(P_n^0+P_n^1+…+P_n^{k_n})$

每一次成功的分解都会产生一个答案

$P_1^{k_1}*P_2^{k_2}*……*P_n^{k_n}$

### 四、代码:
```cpp
#include<stdio.h>
#include<algorithm>//简约头文件 
int p[500050]/*线筛中记录质数*/,len/*线筛中质数个数*/,m/*题目中m个等的人*/,a[500050]/*记录m个人的号码牌*/,s/*自己的号码牌上写着的数字*/;
bool v[500050];//线筛中记录是否为质数 
inline void prime(){
	v[1]=1;
    for(int i=2;i<=100000;i++) {
        if(!v[i])
            p[++len]=i;
        for(int j=1;j<=len;++j) {
        	if(p[j]*i>100000){
        		break;
			}
            v[i*p[j]]=1;
            if(!(i%p[j])){//i%p[j]==0
                break;
            } 
        }
    }
}//线筛模板，求100000以内质数
inline bool is_prime(int n){//由于v数组的范围有限，不能判断大于100000的数，所以得再写一个判质数的程序 
	if(n<100000){
		return!v[n];
	}//在这里做了一个小小的优化，巧妙利用v数组 
    for(int i=1;p[i]*p[i]<=n;i++){//这里又做了一个优化，只枚举质数 
        if(!(n%p[i])){//n%p[i]==0
			return 0;
        }
    }
    return 1;
}//判质数 
inline void dfs(int x/*第x个质数*/,int k/*还剩k能够分解*/,int num/*当前数为num*/){//功能详见前文 
    if(k==1){
        a[++m]=num;
        return;
    }
    if(k>p[x]&&is_prime(k-1)){
    	a[++m]=(k-1)*num;
	}//特判
    for(int j=x;p[j]*p[j]<=k;j++){//枚举下一次选的质数因子 
        int cnt=p[j]+1,tmp=p[j];//cnt为总次方和，tmp为次方和的最后一个数
        for(;cnt<=k;tmp*=p[j],cnt+=tmp){//枚举有多少个因子
        	if(k%cnt==0){
        		dfs(j+1,k/cnt,num*tmp);
			}
		}
    }//实现分解 
}
signed main(){//因为“#define int long long” 
	prime();//筛质数 
    while(~scanf("%lld",&s)){//用于读入本题数据 
        m=0;//每次赋初值 
        dfs(1,s,1);//实现分解n（详见上文分析） 
        printf("%lld\n",m);
        std::sort(a+1,a+m+1);//为符合题目要求，将a数组排序 
        for(int i=1;i<=m;i++){
        	printf("%lld ",a[i]);
		}//输出a数组
        if(m){
        	printf("\n");
		}//本题逐行评测，没有这一句会全部WA掉 
    }
    return 0; 
}
```


### 五、结果：

分数 100

代码长度 1.63KB

用时 114ms

内存 888.00KB