# Description

有一棵包含 $n$ 个节点的树 $T$，它的所有边依次编号为 $1$ 至 $n-1$。

保证对于 $T$ 中任意一个节点 $u$ ，从 $u$ 到 $n$ 号节点的简单路径都不经过任何编号小于 $u$ 的节点。

按照如下步骤生成一张包含 $n$ 个节点的无向图 $G$：

选取一个 $1 \sim n-1$ 的排列 $p$，然后依次进行 $n-1$ 次操作。在进行第 $i$ 次操作时，首先删除树 $T$ 中编号为 $p_i$ 的边 $(a,b)$，然后，记 $u$ 和 $v$ 分别为当前树 $T$ 中与 $a,b$ 联通的所有点中，编号最大的点，并在图 $G$ 的 $u$ 号点和 $v$ 号点之间连一条边。

求对于给定的树 $T$，按上述方式一共可以生成多少种本质不同的图 $G$。图 $G_1$ 和 $G_2$ 本质不同当且仅当存在 $u$ 和 $v$ 满足在 $G_1$ 中不存在边 $(u,v)$，而 $G_2$ 中存在。 

答案对 $998244353$ 取模。

$n \le 3 \times 10^3$，时限 1s。

# Solution

观察题目中“从 $u$ 到 $n$ 号节点的简单路径都不经过任何编号小于 $u$ 的节点”这句话，可以想到若以 $n$ 为根，则所有根到子树的路径都是单调下降的。

考虑新图的生成过程，可以发现每次操作类似于边分治，无非就是在两个连通块中的最浅点间建边。

那么显然我们构造出来的 $G_2$ 是一棵树。

现在我们手玩几组样例，挖掘一些结论。

有结论：合法的建边必然使得新边两两不交叉，而对于不交叉的新边我们都可以构造出一种合法的建边方案。

这是因为每次操作会把原树劈成两半，从此分成两个互不相干的子问题，不会再有它们之间的连边。

此时问题转化为：每个点都可以向祖先连边，你要使得新边之间两两不交叉，求总方案数。

大力树形 DP，考虑祖先向当前点连的边。设 $f_{u,x}$ 表示 $u$ 的祖先中有 $x$ 个点可以向下连边。

有转移

$$f_{u,x}=\sum_{v \in {\rm son}_u}\sum_{j=1}^x f_{v,j+1}$$

这是因为考虑 $u$ 向第几个祖先连边，若与第 $j$ 个连边，则 $v$ 可选的还有 $1 \sim j$ 和 $u$ 自己。

这个不难把后面部分用前缀和优化。

复杂度 $\mathcal O(n^2)$。

# Code

```cpp
const int N=3e3+5;
const LL mod=998244353;
int n;
LL f[N][N];
vector<int> g[N];
void dfs(int u,int fa,int d) {
	if (g[u].sze()==1) {
		for (int i=1;i<=d;i++) f[u][i]=i;
		return;
	}
	for (int v:g[u])
		if (v!=fa) dfs(v,u,d+1);
	static LL t[N]; 
	for (int i=1;i<=d+1;i++) t[i]=1;
	for (int v:g[u])
		if (v!=fa)
			for (int i=1;i<=d+1;i++)
				t[i]=t[i]*f[v][i]%mod;
	for (int i=1;i<=d;i++) f[u][i]=(f[u][i-1]+t[i+1])%mod;
}
int main() {
	scanf("%d",&n);
	for (int i=1;i<n;i++) {
		int u,v;
		scanf("%d%d",&u,&v);
		g[u].pb(v),g[v].pb(u);
	}
	LL ans=1;
	for (int v:g[n]) {
		dfs(v,n,1);
		ans=ans*f[v][1]%mod;
	}
	printf("%lld",ans);
	return 0;
}
```