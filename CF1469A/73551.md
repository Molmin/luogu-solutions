$\texttt{data-2020-12-29}$

感谢@wqy_03 的提醒，我发现自己读错题，把这道题看复杂了。


那么就请把这篇题解看作一个小小的加强版的做法吧。

---


个人觉得这里的证明部分挺有趣的，所以虽然这道题很水，还是想写一篇题解。

我的考场实现是：从左往右然后从右往左分别找到 **左括号不够** 和 **右括号不够** 的情况，然后判断是否有问号可以填补。

然后最后再加一个长度的奇偶判断。

那么这一部分的代码实现为（证明的话在后面）：

```
inline bool work()
{
    cin>>a;
    int n=a.length();
    if(n&1)return false;
    int s=0;
    int cts=0;
    for(int i=0;i<n;i++)
    {
        if(a[i]=='(')s++;
        if(a[i]==')')
        {
            s--;
            if(s<0)
            {
                if(!cts)return false;
                cts--;
                s=0;
            }
        }
        if(a[i]=='?')cts++;
    }
    cts=0;
    s=0;
    for(int i=n-1;i>=0;i--)
    {
        if(a[i]==')')s++;
        if(a[i]=='(')
        {
            s--;
            if(s<0)
            {
                if(!cts)return false;
                cts--;
                s=0;
            }
        }
        if(a[i]=='?')cts++;
    }
    return true;
}
```

为什么这样是对的呢？这两次有没有可能会将一个问号的贡献多次计算？

- 在第一个过程中，我们找到的是 **失配的右括号**，我们需要一个左边的问号与之匹配。

- 在第二个过程中，我们找到的是 **失配的左括号**，我们需要一个右边的问号与之匹配。


这两件事一定不会使用到同一个问号，不然这两个括号便可以自成一对，不会失配。


那么剩下的问号呢？

我们可以直接两两匹配，虽然最终的匹配对并不一定是它们，但是能够保证这样产生的依然是合法的括号串。


至此，证毕。