这题就是一个括号匹配，但是考虑的情况要多一些

思考一个问题：最基础的括号匹配是咋做的？

首先判断奇偶，括号是一对一对匹配的，序列长度为奇数则不可能成立

用栈，从左往右，遇到左括号则入栈，遇到右括号则出栈（匹配一个括号）

当遇到右括号而栈空时，判定为匹配不成功，因为这时的字符串一定是这样的：

$(已经匹配了的)+一个右括号+(还没匹配的)$

众所周知，当**右括号在最左边**或**左括号在最右边**时，肯定没有办法和他匹配括号，已经匹配的括号没有用了，那就不管它

当遍历结束，如果栈空，判定为匹配不成功，因为这时的字符串一定是这样的：

$(已经匹配了的)+一堆左括号+(也已经匹配了的)$

简单解释了一下括号匹配的做法，那这题可以这样吗？

不行，因为有一些是问号

有问号怎么办呢？

俗话说得好：兵来将挡，水来土掩。

**来一个问号，能和前面的左括号匹配就匹配，不能匹配，就变成左括号和后面的右括号匹配。**

这个思路看上去没啥大问题，但是过不去，为啥呢？

Hack:

```
1
(?)?
```

明显可以(())匹配括号，而我们的程序却输出了NO

我们模拟下程序：$ ())? => ())) $

可以看到，贪心做出了错误的判断

众所周知，一个序列，它正着符合条件，则反过来一定也符合条件

那我们就把序列反过来试一次，最后只要正着试反着试有一种可行，则这个序列一定可行

如 $(?)?$ ， 反过来为 $?(?)$

跑一遍程序：((?) =>(())

可以过一些数据了

但这也过不去，再给一组Hack数据：

```
1
?(??)?
```

我们的程序会输出NO,因为这个字符串**回文**

导致正着来倒着来都会有判断错误，**这种情况只会在回文时出现**

那我们就专门判断回文，如果回文且成立了，直接输出YES，否则进行下面的判断。

怎么判断回文且成立呢？

**如果第i个字符和第len-i+1个字符相等且都不是问号，则不回文**

到这里，所有分析结束，进入代码阶段：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
string a;
int main(){
	scanf("%d",&n);
	getchar();//不getchar的话getline会读你的换行 
	for(int i=1;i<=n;i++){
		getline(cin,a);
		string b=a;
		if(a.size()%2){//序列长度为奇数，则不行 
			printf("NO\n");
			continue;
		}
		if(a[0]==')'||a[a.size()-1]=='('){//开头为')'或结尾为'(',则不行 
			printf("NO\n");
			continue;
		}
		bool vis=false;//回文的标记 
		for(int j=0;j<b.size()/2;j++){//枚举前一半字符 
			if(b[b.size()-j-1]==')'&&b[j]==')'){//开始判断相等 
				vis=true;//若相等，则打标记，退出循环
				break;
			}
			if(b[b.size()-j-1]=='('&&b[j]=='('){//开始判断相等
				vis=true;//若相等，则打标记，退出循环 
				break;
			}
		}
		if(vis==false){//回文且满足条件 
			printf("YES\n");
			continue;
		}
		stack<int>stk;//定义栈 
		bool flag=false;//从左往右，右括号满足条件标记 
		for(int j=0;j<a.size();j++){
			if(a[j]==')'){
				if(stk.size()==0){//右括号不满足条件，打标记并退出循环 
					flag=true;
					break;
				}
				else{
					stk.pop();//匹配一个左括号 
				}
			}
			if(a[j]=='('){//左括号入栈 
				stk.push(1);
			}
			if(a[j]=='?'){
				if(stk.empty()){//栈空，当左括号 
					stk.push(1); 
				}
				else{
					stk.pop();//栈不空，当右括号 
				}
			}
		}
		bool flag2=false;//从左往右，左括号满足条件标记 
		if(!stk.empty()){//还剩下了左括号，则左括号不满足条件 
			flag2=true;
		}
		bool flag1=false;//从右往左，左括号满足条件标记  
		while(!stk.empty()){//清空栈 
			stk.pop();
		}
		for(int j=a.size()-1;j>=0;j--){//倒序遍历，做相反操作 
			if(a[j]=='('){ 
				if(stk.size()==0){
					flag1=true;
					break;
				}
				else{
					stk.pop();
				}
			}
			if(a[j]==')'){
				stk.push(1);
			}
			if(a[j]=='?'){
				if(stk.empty()){
					stk.push(1);
				}
				else{
					stk.pop();
				}
			}
		}
		bool flag3=false;//从右往左，右括号满足条件标记 
		if(!stk.empty()){
			flag3=true;
		}
		if((flag==0&&flag2==0||flag1==0&&flag3==0)){//如果有任意一个方向左右括号都满足条件，则序列匹配成功 
			printf("YES\n");
		}
		else{
			printf("NO\n");//否则不满足条件 
		}
	}
	return 0;
} //别搁这复制代码
```

结束了，喜欢点个赞再走好吧awa