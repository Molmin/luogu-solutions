### 关于题意

总感觉翻译说得不清楚，用引用谷歌翻译的一句话解释就很清楚了：

您的程序应从字符串中删除所有连续的相同**字母对**。如果在删除之后出现了**新的配对**，则程序**也应该删除**它们。

------------

### 正题

既然第一次删除后的串中仍可能可以删除，那就不能用常规方法。

因此可以用栈。

- 从头到尾遍历这个字符串.

- 如果遇到一个字符与栈顶元素相等，
那么这个字符一定属于一个现在或多次操作后存在于字符串中的连续相同字母对，
于是就弹出栈顶，并不将当前元素加入栈，
这也就相当于从删除了这个连续相同字符对。

- 若这个字符不与栈顶元素相等，
则它一定不属于任意一个现在或多次操作后存在于字符串中的连续相同字母对，
于是就把它压入栈顶。

- 因为要使两个字符在若干次操作后靠在一起，
它们中间的所有字符都必须被删除（即被弹出栈），
所以以上方法是可行的。

- 因为栈是先进后出，后进先出，
所以最后输出时要从栈底到栈顶输出，
即按照弹出顺序相反的顺序输出。

------------

### 代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
char str[200001],ans[200001];//str表示原串，ans为逆序的答案 
stack<char>sta;//栈 
int tot;//计数用 
int main()
{
	scanf("%s",str+1);//从第一位开始输入 
	int len=strlen(str+1);//同样从第一位求长度 
	for(register int i=1;i<=len;i++)
	{
		if(!sta.empty()&&sta.top()==str[i])//注意先判空 
		sta.pop();
		else
		sta.push(str[i]);
	}
	while(!sta.empty())
	{
		ans[++tot]=sta.top();
		sta.pop();
	}
	for(register int i=strlen(ans+1);i>=1;i--)
	{
		printf("%c",ans[i]);//逆序输出 
	}
	return 0;
}
```
