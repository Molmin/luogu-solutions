## 思路

### 设计状态

首先考虑最粗暴的状态设计 $[n]$，直接将整个数作为状态，可是看到样例二输出的天文数字，显然此状态设计不合理。

考虑优化，因为题目要求结果各个位数之和为 $s$，所以我们可以先给状态添加一个属性 $x$，表示当前各个位数之和，此时状态为 $[n,x]$ ~~看上去更不可做了~~。

别急，再看到第一个条件，这种对余数有特殊要求的条件都有一个固定的套路，就是直接把余数 $m$ 也加进状态中，此时状态为 $[n,x,m]$，而我们又发现这个数字具体是几与转移没关系，所以可以直接扔掉这个属性。

但题目最后还要输出，可以考虑存下每个状态是由哪一个状态转移过来的，输出时倒着输出当前状态的 $x$ 和前一个状态的 $x$ 的差即可，最终属性为 $[x,m,p]$，其中 $p$ 为前一个状态。

### 设计转移

最直观的想法就是每次在末尾添加一个数，由于题目要求 $n$ 最小，所以需要从小到大对每个数转移一遍，用 BFS 实现更为方便。

于是转移就出来了：

$$ [x,m,p] \Rightarrow [x+i,(10\times m+i)\ \%\ d,h] $$

（设当前状态编号为 $h$，$i$ 从 $0$ 到 $9$ 顺序枚举）

## 实现

```cpp
#include <iostream>

using namespace std;

const int kD = 501;
const int kS = 5001;

struct Q {
  int x, m, p;  // 状态为 [x,m,p]
} q[kD * kS];

int d, s, h = 1, t, ans, st[kD * kS];
bool v[kS][kD];

bool R(int x, int m, int p) {         // 转移状态
  if (x <= s && !v[x][m]) {           // 如果数字和不大于s且此状态是第一次到
    q[++t] = {x, m, p}, v[x][m] = 1;  // 入队，标记状态
    if (x == s && m == 0) {           // 如果出解
      ans = t;                        // 记录
      return 1;
    }
  }
  return 0;
}

bool B() {                                            // 使用 BFS 求解
  for (R(0, 0, 0); h <= t; ++h) {                     // 初始化，初始状态为 [0,0,0]
    for (int i = 0; i <= 9; ++i) {                    // 0到9顺序转移
      if (R(q[h].x + i, (10 * q[h].m + i) % d, h)) {  // 转移，如果出解
        return 1;                                     // 返回有解
      }
    }
  }
  return 0;  // 否则无解
}

int main() {
  cin >> d >> s;
  if (!B()) {    // 如果无解
    cout << -1;  // 输出-1
  } else {
    t = 0;
    for (int i = ans; q[ans].p; ans = q[ans].p) {
      st[++t] = q[ans].x - q[q[ans].p].x;  // 由于需要倒着输出，所以先用一个栈存下来
    }
    for (; t; --t) {  // 输出
      cout << st[t];
    }
  }
  return 0;
}
```
