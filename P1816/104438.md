- ## 题意

    给定$m$个元素的序列，有$n$次询问，每次询问区间$[l,r]$内的最小值。

- ## 分析

  看到题目，判断这是一个**区间查询最小值**问题。

  因为不带修改，用$ST$表即可$AC$，实现$O(N\log N)$的预处理，$O(1)$查询的时间复杂度。

  能不写线段树尽量不写线段树 ~~好吧是我太蒻了~~。
  
  如果你$A$了$ST$表的模版题，可以不要看这篇题解了。

- ## ST表

  - 注意：下文均使用左闭右开区间，区间用表格表示。~~凑合着看。~~
  
  - 预处理

    $ST$表实际上是一个递推的过程。我们设$f[i][j]$为区间$[i,i + 2^j)$内（或者说从第$i$个数开始包括的$2^j$个数中）的最小值。

    若读入了$m$个数字，令它们存储在数组$a[m]$中。
由$ST$表定义可得，$f[i][0]=a[i]$（区间里只有$2^0=1$个数字，该数字就是最小值）。

  - 如何递推？
  
    递推式子：
$f[i][j]=\min(f[i][j-1], f[i+2^{j-1}][j-1])$。

    怎么理解？区间$[i,i + 2^j)$可以看做由两个小区间组成，分别是该区间的前半部分和后半部分。整个区间的最小值由它们的最小值合并得来。

    举个栗子：对于区间$[1,9)$

    | 1|2  |3  |4  |5  |6  |7  |8  |
    | :----------- | :----------- | :----------- | :-----------     | :----------- | :----------- | :----------- | :----------- |
    |这|是|区|间|这|是|区|间|
    可以表示为$f[1][3]$，这个区间的最小值由区间$[1,5)$和$[5,9)$的答案合并得来。

    又$f[1][2]$表示$[1,5)$，
    | 1|2  |3  |4  |
    | :----------- | :----------- | :----------- | :-----------    |
    |这|是|区|间|
    $f[5][2]$表示$[5,9)$。
    |5  |6  |7  |8  |
    | :----------- | :----------- | :----------- | :----------- |
    |这|是|区|间|

    $f[1][3]=\min(f[1][2],f[5][2])$

    $\ \ \ \ \ \ \ \ \ \ \ \ =\min(f[1][3-1],f[1+2^{3-1}][3-1])$。

    把规律推广一下即可。
   
   - 区间查询
 
     我们预处理的区间最小值，区间长度都是$2^n$，如果题目查询的区间长度是$2^n$，那很简单，如果不是呢？
     
     比如 区间$[1,8)$
     
     |  1|  2|  3|  4|  5|  6|  7|
     | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: |
     |这|真|的|是|区|间|啊|
     
     考虑把这个区间分成两个小区间$[1,5)$
     | 1|2  |3  |4  |
     | :----------- | :----------- | :----------- | :-----------    |
     |我|是|区|间|
     和$[4,7)$，
     | 4|5  |6  |7  |
     | :----------- | :----------- | :----------- | :-----------    |
     |我|是|区|间|
     用小区间的答案合并而成。
     
     这两个区间的长度都是$4=2^2$，已经预处理了。合并一下。
     
     令查询区间为$[l,r)$就是要找到一个最小的$k$，满足$2^{k+1}>r-l$。此时必有$2^k\le r-l$。即$2^k\le$区间长。且$2^k>\frac12*$区间长，所以两个长为$2^k$的区间足以覆盖整个大区间。
     
     这里证明的时候用左闭右开区间，但是题目给我们的是闭区间，我们对于询问的区间$[x,y]$，将之分为两个区间，左端点向右$2^k$个元素的区间，和右端点向左$2^k$个元素的区间，即区间$[l,l+2^k],[r-2^k+1,r]$。
     
     你可能会注意到，这两个区间都可能会重叠，是否会对答案有影响？
     
     然而这并没有什么影响。请先自己思考一下原因。
     
     如果最终答案在重叠区间之内，两个区间的$\min$都会是最终答案，再取$\min$对结果没有影响。
     
     如果最终答案不在重叠区间之内，重叠区间对答案更没有影响。
     
     但如果改成区间求和问题就有影响了。区间求和不允许把一个元素计算两次。
     
     综上所述，$query(l,r)=\min(f[l][k],f[r-2^k+1][k])$。
     
     
$AC$代码
~~~cpp
  #include <algorithm>
  #include <cstdio>
  #include <iostream>
  #include <cmath>

  using namespace std;

  const int N = 1e5 + 5, CNT = 20; //常量
  int n, m;
  int f[N][CNT]; //预处理数组

  //自己写一个min函数，会快一点吧……
  //内联+常量引用+三目运算符 加速
  inline int mn(const int& x, const int& y) {
      return x < y ? x : y;
  }

  //快读 不解释
  inline int read(void){
      register int b = 1, c = getchar(), r = 0;
      while (!isdigit(c)) b = c == '-' ? -1 : 1, c = getchar();
      while (isdigit(c))  r = r * 10 + c - '0', c = getchar();
      return r * b;
  }

  //ST表的预处理，原理在前面有，此处不赘述
  inline void build(void) {
      for (int i = 0; i < n; ++i) {
          f[i][0] = read();
      }
      for (int j = 1; (1 << j) <= n; ++j) {
          for (int i = 0; i + (1 << j) - 1 < n; ++i) {
              f[i][j] = mn(f[i][j - 1], f[i + (1 << (j - 1))][j - 1]);
          }
      }
  }

  //查询操作
  inline int query(const int& l, const int& r) {
  //找到最小的k，你也可以用cmath库的log2函数
      int k = 0;
      while ((1 << (k + 1)) <= r - l + 1) {
          ++k;
      }
      return mn(f[l][k], f[r - (1 << k) + 1][k]);
  }

  int main(void) {
      n = read(); m = read();
      build();
      while (m--) {
          int l, r;
          l = read(); r = read();
          //因为我让元素从0开始存储，查询时区间要左移1位。
          printf("%d ", query(l - 1, r - 1));
      }
      return 0;
  }
~~~