# ST算法求区间最值
RMQ问题的经典裸题，知识点是使用ST算法快速求解区间最大值（最小值）

个人认为ST算法是比较数学的一个方法，思想很独特也很好用。

这里简单介绍一下ST算法以及我对ST算法的浅薄理解。

首先我们明确ST算法的适用范围，即给定数列区间求最值。设每个查询区间为[x,y]，那么它的长度就是y-x+1，（很好理解吧）。ST算法的原理是动态规划以及倍增思想，换句话说，假如我们要求解一个区间的最大值最小值，我们可以这样考虑：把一个区间分成两块，求左边那块和右边那块的最值，最后把答案汇总更新即可。那么我们的动归状态就出来了：

设f[i][j]为数列a中a[i]到a[i+2^j-1]这个区间的最值。

状态转移方程：

f[i][j]=max(f[i][j-1],f[i+2^(j-1)][j-1]);

初值很好判断，将f[i][0]置成a[i]即可。

我们可以在O（nlogn）的时间内预处理f数组。

具体过程如下：
```cpp
for(int j=1;(1<<j)<=n;j++)
    for(int i=1;i<=n;i++)
        f[i][j]=max(f[i][j-1],f[i+(1<<(j-1))][j-1]);
```
这里要注意，j一定要写在外层！！

然后对于每个询问，我们可以用O（1）的时间求解。

这里要注意，我们ST算法的原理是倍增和DP，也就是在左区间和右区间分别求最大值，但是我们的询问并不一定是2的n次方个元素，也就是我们再最终计算的时候，一定需要考虑两个区间重合的情况。

对于询问[x,y]，用一个变量k记录log[y-x+1].

所以ans=max(f[x][k],f[y-(1<<k)+1][k]);

很好理解吧！

好好敲模板，这道题不难AC。

Code:
```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
int n,m;
int lg[100010],f[100010][20],ans[100010];
int main()
{
    scanf("%d%d",&m,&n);
    //lg[0]=-1;
    for(int i=1;i<=m;i++)
        scanf("%d",&f[i][0]);
    for(int i=2;i<=m;i++)
        lg[i]=lg[i>>1]+1;
    for(int j=1;(1<<j)<=m;j++)
        for(int i=1;i+(1<<j)-1<=m;i++)
            f[i][j]=min(f[i][j-1],f[i+(1<<(j-1))][j-1]);
    for(int i=1;i<=n;i++)
    {
        int x,y;
        scanf("%d%d",&x,&y);
        int k=lg[y-x+1];
        ans[i]=min(f[x][k],f[y-(1<<k)+1][k]);
    }
    for(int i=1;i<n;i++)
        printf("%d ",ans[i]);
    printf("%d",ans[n]);
    return 0;
}
```
