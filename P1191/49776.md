嗯，这是个不错的题，各种大佬也有低复杂度算法，但是我只有一个勉强卡着能过的$n ^ 3\ log(n)$

首先这个题肯定要枚举矩阵的左上角$(a,b)$

然后这个矩阵还是有很多种可能，不太好做

所以只能再枚举一个右边界$d$

这个时候，矩阵的形状其实已经很确定了，唯一不确定的就是下边界

然后下边界只要$c$是可以的，显然$[a,c]$这个区间都可以

也就是说，只要求出最大的$c$，左上角$(a,b)$，右边界$d$的白色矩形个数就可以求出，为$c - a + 1$个

这个$c$可以二分得到，但是判定矩形$[a,b][c,d]$是不是白色有些困难，因为我们现在的复杂度已经很屑了，再乘点什么东西瞬间爆炸

显然二分换倍增是比较明智的选择，考虑设$W[a][b][c][d]$表示矩形$[a,b][a + 2 ^ d,c]$是否全是白色，这个东西套个倍增板子就可以求了

顺便解释下为什么预处理出来的矩阵，高要为$2 ^ d + 1$，因为倍增往下跳必须跳$2 ^ d$步，不然会无法求出正确答案。往下$2 ^ d$，高度就是$2 ^ d + 1$

代码：

```cpp
#include <cstdio>
int n;
char map[155][155];
int tmp[155][155][155];//i行[j,k]都是白 
int W[155][155][155][10];//W[a][b][c][d]表示矩形[a,b][a + 2 ^ d][c]是否全是白色 
int ans;

int main(){
	scanf("%d",&n);
	for(int i = 1;i <= n;i++){
		scanf("%s",&map[i][1]);
	}
	for(int a = 1;a <= n;a++){
		for(int b = 1;b <= n;b++){
			int tag = 1;
			for(int c = b;c <= n;c++){
				if(map[a][c] == 'B') tag = 0;
				tmp[a][b][c] = tag;
				if(tmp[a][b][c] && tmp[a - 1][b][c]){//根据定义，d = 0时W[a - 1][b][c]是管a - 1行和a行的
					W[a - 1][b][c][0] = 1;
				}
			}
		}
	}
	for(int i = 1;i <= 7;i++){
		for(int a = 1;a <= n;a++){
			if(a + (1 << i) > n) continue;//这里必须判，否则RE，开大数组会MLE……
			for(int b = 1;b <= n;b++){
				for(int c = b;c <= n;c++){
					W[a][b][c][i] = W[a][b][c][i - 1] & W[a + (1 << i - 1)][b][c][i - 1];
				}
			}
		}
	}
	for(int a = 1;a <= n;a++){
		for(int b = 1;b <= n;b++){
			for(int c = b;c <= n;c++){
				if(!tmp[a][b][c]) continue;//有可能自己这一行都不行，得判掉
				int now = a;
				for(int i = 7;i >= 0;i--){//注意这里从大到小
					if(W[now][b][c][i]){
						now += (1 << i);
					} 
				}
				ans += (now - a + 1);
			}
		}
	}
	printf("%d\n",ans);
	return 0;
}
```

不过这么做确实有点麻烦，可能还是因为我懒得找规律，只能暴力上了