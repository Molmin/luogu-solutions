## emm，这题的话我想的是用模拟罗伯法。没错，[罗伯法](http://www.doc88.com/p-281604109616.html)就可以模拟，很简单，现在先介绍一下：

__其实罗伯法适用于基数幻方，正好符合题意，先将1填到第一行的最中间，不断往右上方移动，出格（上变下，右变左，反向亦如此）。位置被占了填到前面的下一个。就这样模拟__

__于是我们可以推到出来：每次移动x++，y++，进行出格的特判（x、y小于0则分别是上出格、右出格，则大于n为下出格与左出格），然后看位置是否被占，这里要很小心，我手算发现了只要x+=2、y--就可以了。但是我们可以看到也许会这样：从__

![](https://cdn.luogu.com.cn/upload/pic/39705.png)

__到__

![](https://cdn.luogu.com.cn/upload/pic/39706.png)

__会发现：6移到3行1列，被4占了，所以要在2行3列放7，这里也要特判。好了，AC模拟代码在此__

```
#include<bits/stdc++.h>//万能头 
using namespace std;
int f[10010][10010] = {0};//基数幻方记录 
int n;
int x,y;//目前行和列 
int main(){
	cin>>n;//输入 
	int k = 1;//初始化 
	f[1][(n / 2) + 1] = 1;//初始化1放在指定位置 
	x = 1;y = (n / 2) + 1;//x,y分别初始化 
	while(k < (n * n)){//如果先有格子数少的话就继续 
		k++,x--,y++;//正常操作 
		if(x <= 0){//判断是否越界(x超过上界) 
			x = n;//处理移位 
		}
		if(x > n){//判断是否越界(x超过下界) 
			x = 1;//处理移位
		}
		if(y > n){//判断是否越界(y超过右界) 
			y = 1;//处理移位
		}
		if(y <= 0){//判断是否越界(y超过左界) 
			y = n;//处理移位
		}
		if(f[x][y]){//开始特判6~7那里，图上的 
			if((x + 2) > n)x = (x + 2) - n;//判断是否越界，越界处理 
			else x += 2;//否则正常 
			if((y - 1) <= 0)y = n;//判断是否越界，越界处理 
			else y--;//否则正常 
		}
		f[x][y] = k;//记录 
	}
	for(int i = 1;i <= n; i++){
		for(int j = 1;j <= n; j++){
			cout<<f[i][j]<<" ";//输出 
		}
		cout<<endl;
	}
	return 0;
}
```