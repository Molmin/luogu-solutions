其实这道题看着条件特别多，稍微理一下就可以变成以下操作：把下一个数放在当前数的右上角，如果越界了，就看成多个重复的矩阵，如果右上角有数，那么就放在当前数的正下方。

因为根据这个方法填充的矩阵定然不会出现冲突（证明略），所以代码就很简单辣=w=

```cpp
#include<bits/stdc++.h>
using namespace std;
int m[44][44];//用来存答案的数组
int n,x,y;//n表示矩阵大小，x，y表示下一个数的位置
int main()
{
    scanf("%d",&n);
    m[1][n/2+1]=1;//第一行中间，第一个数是1
    x=1,y=n/2+1;//从1的位置开始偏移
    for(int i=2;i<=n*n;i++)//循环填充2-n*n
    {
    	int sx=x,sy=y;//保存下初始的位置，如果右上角有数的话方便回退操作
    	x--;
    	if(!x)x=n;//如果越界了，把他当成上面一个矩阵的最后一行
    	y++;
    	if(y>n)
    	y=1;//同理，越界了，当成右边的矩阵第一列
        //------以上完成了向右上角移动的过程-------
		if(m[x][y])//如果右上角有数了
    	x=sx+1,y=sy;//拉到当前位置的下面
    	m[x][y]=i;
	}
	for(int i=1;i<=n;i++)
	for(int j=1;j<=n;j++)
	printf("%d%c",m[i][j]," \n"[j==n]);//奇技淫巧=w=
    return 0;
}

```
