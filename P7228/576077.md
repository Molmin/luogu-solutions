### P7228 [COCI2015-2016#3] MOLEKULE

有向图的代价是一条在这张有向图上的最长通路长度，题目本质上是让你安排一个有向图的方向，使得这个最长通路的长度最短。

其他题解都好复杂啊，其实根本不用搜索的。

我们不妨从每个点的出度考虑：如果图中出边最多的点的出度为 $1$，则这个图中会有环，这样的环显然不满足题目要求；如果图中有出度为 $2$ 的点，可以考虑按照出度为 $0$、$2$、$0$、$2$ 交替的顺序安排每个点，这样的最长通路长度是 $1$，显然是最优的。

关于如何确定每条边的方向，我的思路是将整个图排成从上到下的形式，高度为奇数的点统一向它们的孩子连、高度为偶数的点统一由它们的孩子向它们连，这样安排的顺序会使出度交替排列。代码中我将编号小的结点放在比它们编号大的结点上面，对每一个输入进行即时的构图。

```cpp
#include <bits/stdc++.h>
using namespace std;

int main()
{
	int n, h[100010]; scanf("%d", &n); for (int i = 1; i <= n; i++) h[i] = 1e9;
	for (int i = 1; i <= n - 1; i++)
	{
		int u, v; scanf("%d%d", &u, &v);
		if (h[u] == 1e9 && h[v] == 1e9) h[u] = 0; //开始构造，现在还没有边的方向被确定
		//所在高度为奇数父亲往儿子连，偶数儿子往父亲连 
		if (u > v) //v是u的父亲 
		{
			if (h[u] != 1e9) h[v] = h[u] + 1; else if (h[v] != 1e9) h[u] = h[v] - 1;
			//检查v的高度，确定往上连还是往下连
			//输出1是从u到v，输出0是从v到u
			if (h[v] % 2 == 0) printf("1\n"); else printf("0\n");
		}
		else /*u是v的父亲，同理*/
		{
			if (h[u] != 1e9) h[v] = h[u] - 1; else if (h[v] != 1e9) h[u] = h[v] + 1;
			if (h[u] % 2 == 0) printf("0\n"); else printf("1\n");
		}
	}
	return 0;
}
```

另外，本题是 SPJ，只要保证最长通路长度最短即可，答案不唯一，本题中“奇数向儿子连、偶数向父亲连”的策略也可以反过来，此时结果中的 $0$ 和 $1$ 会反过来，依然正确。