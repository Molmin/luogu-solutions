详细讲重力为```>```的情况,其他类似。

什么情况下元件才会被破坏?肯定左边要有水滴,这样才能流到该元件。

当左边没水的情况下,显然不会有任何水破坏到该元件,元件就保留了下来。

思路很简单,可是代码怎么实现呢?

对于每个元件,需查询左部有没有水滴。对于本题,$n<=100$,所以暴力$O(n\times m^{2})$可以解决,但介绍一个更好的办法,可以做到$O(n\times m)$。

对于每行,从左到右扫一遍。若碰见了水,就把一个临时变量标记为$1$,表示从这个点开始后面所有的元件都会坏掉,这个标记一直会保持到扫完整行。(扫下一行时得把这个变量置零)。若扫的过程中遇到了元件,并且标记为$1$,表示水可以流到这个元件。那么立刻输出``GG``。

若一直没有水碰到元件,那么就输出```OK```就可以了。

对于重力为其它的情况,改变扫描顺序即可,要顺着重力方向扫描,具体见代码。

```cpp
#include<iostream>
using namespace std;
char a[1005][1005];
int main(){
	int n,m,i,j;
	bool ykb;
	char fx;
	cin>>n>>m>>fx;
	for(i=0;i<n;i++){
		cin>>a[i];
	}
	if(fx=='^'){
		for(i=0;i<m;i++){ //逐列枚举。 
			ykb=0;
			for(j=n-1;j>=0;j--){
				if(a[j][i]=='o'){ //有水,后面的格子都会受影响。
					ykb=1;
				}
				if(a[j][i]=='x'&&ykb){ //有元件,并且前面有水。直接返回不可以。
					cout<<"GG";
					return 0;
				}
			}
		}
	}
	if(fx=='v'){
		for(i=0;i<m;i++){ //逐列枚举。 
			ykb=0;
			for(j=0;j<n;j++){
				if(a[j][i]=='o'){
					ykb=1;
				}
				if(a[j][i]=='x'&&ykb){
					cout<<"GG";
					return 0;
				}
			}
		}
	}
	if(fx=='<'){
		for(i=0;i<n;i++){ //逐行枚举。 
			ykb=0;
			for(j=m-1;j>=0;j--){
				if(a[i][j]=='o'){
					ykb=1;
				}
				if(a[i][j]=='x'&&ykb){
					cout<<"GG";
					return 0;
				}
			}
		}
	}
	if(fx=='>'){
		for(i=0;i<n;i++){ //逐行枚举。 
			ykb=0;
			for(j=0;j<m;j++){
				if(a[i][j]=='o'){
					ykb=1;
				}
				if(a[i][j]=='x'&&ykb){
					cout<<"GG";
					return 0;
				}
			}
		}
	}
	cout<<"OK"; //没有任何一个元件有问题,返回可以。
	return 0;
}
```