### 做法 1：boruvka + 线段树

考虑建出生成森林然后统计生成森林中连通块的个数。使用类似 boruvka 的思想。算法每一轮对于每个连通块找到是否存在一条和其他连通块之间的边。这部分可以使用线段树优化。注意一定要正着找一遍倒着找一遍，因为对于一个连通块而言有可能向前找找不到边向后找能找到边而这条边没被枚举导致每轮连通块个数不能减半。复杂度 $O(n\log ^2n)$。

[代码](https://codeforces.com/contest/1691/submission/159139562)

### 做法2：拆事件 + 贪心

考虑一种朴素的连边算法。对于两条有边的线段 $[l_1,r_1],[l_2,r_2]$，如果 $l_1<l_2$，那么一定有 $l_2\in [l_1,r_1]$。即线段 $[l_1,r_1]$ “覆盖”了点 $l_2$，考虑在处理 $[l_2,r_2]$ 时处理这条边。考虑将一条线段 $[l,r]$ 拆成两个在时刻 $l$ 和 $r$ 的事件按时间维扫描线。在扫到左端点时加入一条线段扫到右端点时删掉一条线段。对于点 $k$，将左端点在 $[1,l]$ 范围内的线段都加入后还未删的线段即覆盖点 $k$ 的线段。

那么这里不难想到一个暴力做法：


* 将所有线段拆成两个事件（加入和删除）排序，每个时刻只处理一个事件。开两个集合表示两种颜色线段已经加入但未删除的线段。

* 对于两条相交的线段 $[l_1,r_1]$，$[l_2,r_2]$ 在加入后加入的线段时连边。

* 加入一条线段时扫与该线段颜色相异的集合向集合内的所有线段连边。

令 $f_i$ 表示加入左端点在 $[1,l_i]$ 的线段后有多少条颜色与 $i$ 相异的线段还未被删。暴力算法的复杂度即 $O(\sum f_i)=O(n^2)$。

这里有一个贪心策略：在加入一条线段连边后只保留另一个颜色集合中右端点最大的线段不影响连通性。

考虑对于钦定颜色的线段 $p_1,p_2,...,p_k$ 计算 $\sum f_i$，因为处理完一条线段后 $f$ 变成 $1$。所以 $\sum f_i=O(n)$。

用 set 维护线段集合，复杂度 $O(n\log n)$。

[代码](https://codeforces.com/contest/1691/submission/159156663)

