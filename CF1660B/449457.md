这道题首先我们先从只有两种糖果开始讨论。假设第一种糖果数量为 $x$,第二种数量为 $y$，那么我们容易发现，只有当 $\left|x-y\right| \ge 2$ 时，这个人才会连续吃两块糖果。

为什么？

我们来思考一下，如果 $\left|x-y\right| = 1$，那么这个人一定会吃较多的那一种糖果，此时 $x=y$
- 如果这个人上一次吃的是第一种糖果，那么他这一次可以吃第二种糖果。
- 如果这个人上一次吃的是第二种糖果，那么他这一次可以吃第一种糖果。

此时 $\left|x-y\right| = 1$。

于是我们发现，不管一开始是 $\left|x-y\right| = 1$ 还是 $x=y$，他都可以在这两种情况之间循环且每两次吃的糖果不重复，直到他把所有的糖果吃完。

于是我们延伸到有不止两块糖果的情况。我们把数量最多种类的糖果数量设为 $x$,数量第二多的种类的糖果设为 $y$,则如果 $x-y \ge 2$,这个人才会连续吃两块相同糖果，否则不会。我们也来感性理解一下。

我们设数量第三多的种类的糖果设为 $z$,则我们可以发现如果 $x-y \le 1$，那么我们也会在 $x-y=1$ 和 $x=y$ 之间循环，直至 $z>x$ 或 $z>y$ 为止，由于这个人每次只吃 $1$ 块糖果，所以上述条件也可写为 $z-x=1$ 或 $z-y=1$,而我们又知道 $x,y$ 满足 $x-y=1$ 或 $x=y$,所以不管 $x,y,z$ 中谁是第一、第二、第三大，都有第一大 $-$ 第二大 $\le 1$，直至这个人把糖果全部吃完。

可能你们还是不理解，我们来拿可爱的样例举个例子：

```
2 2 2 1
```

此时 $x=2$（第一种）,$y=2$（第二种）,$z=2$（第三种）。

因为 $x=y$,我们按照上面的流程，$x->x-1$（这个地方令 $y->y-1$ 也没有问题）

得到

```
1 2 2 1
```

此时 $x=2$（第二种）,$y=2$（第三种）,$z=1$（第一种）。

因为 $x=y$,我们按照上面的流程，$x->x-1$（这个地方令 $y->y-1$ 也没有问题）

得到

```
1 1 2 1
```

此时 $x=2$（第三种）,$y=1$（第一种）,$z=1$（第二种）。

因为 $x-y=1$,我们按照上面的流程，$x->x-1$

得到

```
1 1 1 1
```

此时 $x=1$（第一种）,$y=1$（第二种）,$z=1$（第三种）。

因为 $x=y$,我们按照上面的流程，$x->x-1$（这个地方令 $y->y-1$ 也没有问题）

得到

```
0 1 1 1
```

此时 $x=1$（第二种）,$y=1$（第三种）,$z=1$（第四种）。

因为 $x=y$,我们按照上面的流程，$x->x-1$（这个地方令 $y->y-1$ 也没有问题）

得到
```
0 0 1 1
```

此时 $x=1$（第三种）,$y=1$（第四 种）,$z=1$（因为只剩两种糖果了，所以我们假装 $z=0$）。

因为 $x=y$,我们按照上面的流程，$x->x-1$（这个地方令 $y->y-1$ 也没有问题）

得到
```
0 0 0 1
```

此时 $x=1$（第四种）,$y=1$（因为只剩一种糖果了，所以我们假装 $y=0$）,$z=1$（因为只剩一种糖果了，所以我们假装 $z=0$）。

因为 $x=y$,我们按照上面的流程，$x->x-1$（这个地方令 $y->y-1$ 也没有问题）

得到
```
0 0 0 0
```

吃掉了所有糖果，模拟结束。

这样做我们只需要找第一大和第二大，判断一下就行，时间复杂度 $O(tn)$（这里我懒了，用 `sort`,时间复杂度 $O(tnlogn)$，不过也能过，大家不要学我）

另外，如果 $n=1$,这时候我们把第二大看作 $0$ 就行。

代码（话说我一个红题讲那么详细好吗）：
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
int read(){
	int x=0,f=1;
	char c=getchar();
	while(c<'0'||c>'9'){
		if(c=='-') f=-1;
		c=getchar();
	}
	while(c>='0'&&c<='9'){
		x=(x<<1)+(x<<3)+c-'0';
		c=getchar();
	}
	return x*f;
}
bool cmp(int x,int y){
	return x>y;
}
void cf(){
	int n=read();
	int a[n+2];
	for(int i=1;i<=n;i++)
		a[i]=read();
	sort(a+1,a+n+1,cmp);
	a[n+1]=0;
	if(a[1]-a[2]>1) printf("NO\n");
	else printf("YES\n");
	return;
}
int main(){
	int t=read();
	for(int i=1;i<=t;i++)
		cf();
	return 0;
}
```
