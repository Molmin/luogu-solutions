[题目传送门](https://www.luogu.com.cn/problem/P9185)

#### 思路

先拿一个数据来模拟一下：

```
10 3 15
0 3 8

t
0    0 1 2 3 4 5 6 7 8 9
1    8 1 2 0 4 5 6 7 3 9
2    8 9 2 0 1 5 6 7 3 4
3    5 9 8 0 1 2 6 7 3 4
4    5 6 8 9 1 2 0 7 3 4
5    5 6 7 9 8 2 0 1 3 4
6    5 6 7 3 8 9 0 1 2 4
7    5 6 7 3 4 9 8 1 2 0
8    1 6 7 3 4 5 8 9 2 0
9    1 2 7 3 4 5 6 9 8 0
10   1 2 0 3 4 5 6 7 8 9
11   8 2 0 1 4 5 6 7 3 9
12   8 9 0 1 2 5 6 7 3 4
13   5 9 8 1 2 0 6 7 3 4
14   5 6 8 9 2 0 1 7 3 4
15   5 6 7 9 8 0 1 2 3 4
```
不难发现，$0 - 2$ 号牛在每个位置停留 $3$ 次，$3 - 7$ 号牛在每个位置停留 $5$ 次，$8 - 9$ 号牛在每个位置停留 $2$ 次，所以在 $a_i$ 到 $a_{i + 1}$ 
之间的数，如果 $t$ 足够大，就能发现它们每一次会在一个地方停留 $a_{i + 1} - a_i$ 次，下一次会移动到 $(a_{i + 1} - a_i) \bmod n$ 但可能 $t$ 不一定会被 $a_{i + 1} - a_i$ 整除，所以当不能被整除时位置要加上，公式可以去看代码，由于保证 $a_{0} = 0$，所以我们可以使 $a_{k + 1} = n$。


code

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,k,t,a[100010],b[100010],kkk;
int main()
{
	scanf("%d%d%d",&n,&k,&t);
	for(int i = 1;i <= k;i++) scanf("%d",&a[i]);	
	for(int i = 0;i < n;i++) b[i] = i;
	a[k + 1] = n;
	for(int i = 1;i <= k;i++)
		for(int j = 0;j < a[i + 1] - a[i];j++)
			b[((a[i] + j) % n + (t - j + a[i + 1] - a[i]  - 1) / (a[i + 1] - a[i]) * (a[i + 1] - a[i])) % n] = (a[i] + j) % n;
	for(int i = 0;i < n;i++) printf("%d ",b[i]);
	return 0;
}
```

