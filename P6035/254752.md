这道题和下列题目存在“撞题”嫌疑.

https://www.luogu.com.cn/problem/UVA11525

看到$b_i$的定义是在$a_i$之后的逆序对，立刻想到康托展开.

而在康托展开中，每一组合法的$b_i$恰对应着一个排列，所以我们只要对于$b_i=-1$求出它有多少种合法的情况即可.

而$b_i$不大于$i$后面数的个数，也就是$n-i$.这个只要在输入的时候特判即可.

```cpp
for(int i=1;i<=k;i++){
    	scanf("%d",&s[i]);
    	if(s[i]>k-i){
    		cout<<0<<endl;
    		return;
		}
		
```
也可以类似的得出，如果第$i$位是$-1$，那么它有$0,1,...,n-i$共$n-i+1$种可能，只要开一个变量ans存一下即可,也就是

```cpp
		if(s[i]==-1)s[i]=0,sol=one*sol*(k-i+1)%p;
		tree.Insert(1,1,k,i);
	}
```
之后就是逆康托展开的模板了，可以见我前面的链接，用维护$k$大$k$小的数据结构维护即可.

核心代码都在上面了，剩下的都是板子.