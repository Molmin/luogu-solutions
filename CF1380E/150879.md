## 题意稍加描述：
给出半径为 $1\cdots n$ 的 $n$ 个圆环和 $m$ 个塔，要求每个塔上圆环的**半径始终从底向上递减**，一次操作可以将一个塔顶部的若干个盘子移动到另一个塔的顶部，我们定义某一情形下的复杂度为**将所有圆环移动到同一个塔上所需要的最小操作数**。题目给出 $m-1$ 次询问，每次询问时输出**当前塔状态的复杂度**并**合并**两个塔上的圆环到同一个塔上。

------------
## 思路？

我们可以先手玩一下样例～：

```latex
7 4
1 2 3 3 1 4 3
3 1
2 3
2 4
```

$7$ 个圆环， $4$ 个塔。

$1$ 号塔上有 $1,5$ ， $2$ 号塔上有 $2$ ， $3$ 号塔上有 $3,4,7$  ， $4$ 号塔上有 $6$

我们以第一次询问为例：原初情况，$1$ 一定是先花费一步，去找 $2$ ，因为他们两个最后肯定（也只能）贴贴（~~雾~~）。

为什么能找到？想想看，除了 $1$ 以外，谁还能顶替他的位置做吊车尾，只能是 $2$（~~这或许是他们贴贴的原因~~）。

那 $2$ 不得不在最上层。找到 $2$ 以后再找 $3$ ，并以相同的原因找到他。

再找 $4$ ，这时候我们发现一个问题，这个 $4$ 早就已经和 $3$ 贴贴了。怎么样，还需要额外一步让他们贴贴吗？不需要了！

我们大可以跳过 $4$ 去找 $5$ ，而因为 $1$ 的移开我们再回到 $1$ 塔时塔顶已是 $5$ 了，我们找到 $5$ ，再找 $6$ ，再找 $7$ ，大功告成。

这样一波下来，我们发现，本来如果是七个分散的圆环，我们需要 $7-1=6$ 次操作把他们合并，但由于 $3$ 和 $4$ 的**提前贴贴**，导致我们**少用一次操作**，只需要 $5$ 次即可。我们或许可以通过观察归纳法得出一个结论了，我们需要的移动次数 $sum$ ，应该等于最劣移动次数 $m-1$ ，减去提前贴贴的圆环组数 $x$ ，即 $sum=m-1-x$ ，很好理解的吧（~~心虚~~）。

------------
## 实现？
首先，我们如何知道有几组提前贴贴的圆环，这好办，对于一个 $i$ 圆环，看看 $i-1$ 和 $i+1$ 是不是和他一个塔的就是了。

为什么？两个**相邻编号**的圆环要是在一个塔上，他们一定是贴贴的，这很好证，这两个之间再也插不进任何一圆环了（可谓是紧密贴贴）。

我们还需要解决怎么合并的问题，两个塔拖家带口合并，逐个插入，再来个 $\operatorname{sort}$ 必然是 $T$ 到飞起。

怎么解决这种下属很多的两个东西的合并问题？**并查集**就完事辣！最初所有塔的父亲都是自己，合并时只要把两个塔的**祖先合并**，查询时用个 $\operatorname{find()}$ 查这个环在哪个塔， $O(1)$ 合并，爽到。

由于圆环之间的贴贴关系是随着塔的合并而不断更新的，也就是说，如果我们每一次合并都扫一遍 $1\cdots N$，时间复杂度是 $O(nq)$ ，极大可能爆炸，怎么办？我们看看我们扫一遍的这种想法慢在哪。

我们在扫的时候，考虑了一些**位置根本没有改动**的圆环，但毫无疑问的，他们之前是怎么样，现在一样。为什么他们位置没有改动？因为他们压根就不在这次合并的两个塔上。那我们该如何解决？

考虑记录初始状态时，每个塔上都有哪些圆环，由于 $m,n$ 会很大但是圆环总数就那么点， $\mathtt{vector}$ 是个很好的选择。用 $\mathtt{vector[i]}$ 存第 $i$ 个塔上最开始时候的圆环们。合并的时候就把一个 $\mathtt{vector}$ 里的元素全部倒进另一个 $\mathtt{vector}$ 里，由于圆环有限，这里的操作撑死也就运行 $2\cdot 10^5$ 次，不影响大体时间复杂度。

知道了哪个塔上有什么，观察圆环是否贴贴的时候，我们就只用看这个塔上有什么，只对**这次合并的塔上的圆环**讨论即可。

我看到有 $dalao$ 说这是什么**启发式合并**的思想，我太蒻了，一道题目做完才知道用的是这思想。

我还看到有 $dalao$ 采用**线段树合并**的方法碾过去，我太蒻了，只听说过这东西，从来就不会打。

我还是太蒻了。

------------

## 代码？（~~随缘加点注释~~）
```cpp
#include <bits/stdc++.h>
#pragma GCC optimize(2)
#pragma GCC optimize(3)
#pragma GCC optimize("Ofast")
#pragma GCC optimize("inline")
using namespace std;
const int MAX = 2e5 + 7;
int N, M, tower[MAX], 


/*并查集组件*/
int fa[MAX];
inline int find(int n)
{
     if (n == fa[n])
          return n;
     return fa[n] = find(fa[n]);
}
inline void merge(int x, int y)
{
     fa[find(x)] = find(y);
}

/*vector 组件*/
vector<int> son[MAX];
void swap_int(int &a, int &b)
{
     int tmp = a;
     a = b;
     b = tmp;
}

int main()
{
     ios::sync_with_stdio(false);
     cin >> N >> M;
     int sum = N - 1;
     for (register int i = 1; i <= N; i++)
     {
          int tt;
          cin >> tt;
          tower[i] = tt;//i是这个塔的
          fa[i] = i;//并查集处理
          son[tt].push_back(i);//这个塔上有个i
     }
     for (register int i = 2; i <= N; i++)
     {
          if (tower[i] == tower[i - 1])
               sum--;//先看看初始状态总共有多少贴贴
     }
     cout << sum << endl;
     for (register int k = 1; k <= M - 1; k++)
     {
          int x, y;
          cin >> x >> y;
          int fx = find(x);
          int fy = find(y);//先抓到祖先
          if (son[fx].size() > son[fy].size())
          {
               swap_int(fx, fy);//偏偏处理size小的，贪一把
          }
          for (register int i = 0; i < son[fx].size(); i++)
          {
               int v = son[fx][i];
               if (find(tower[v - 1]) == fy)
                    sum--;//他的上位在塔里，sum--
               if (find(tower[v + 1]) == fy)
                    sum--;//他的下位在塔里，sum--
               son[fy].push_back(v);//倒出vector
          }
          merge(fx, fy);//合并
          cout << sum << endl;
     }
}
```
