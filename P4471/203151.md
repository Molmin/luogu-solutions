对于这一题来说最主要的不是反向建立一个trie　　　~~毕竟这是一道紫题~~　　

我觉得这一题最终要的是树上DP(我想了接近半个月)
这一道题的状态转移方程为dp[i]=val[i]+max(dp[j])
其中ｊ是ｉ这一个结点的儿子的编号

我们要在字典树中的结点上标记true or false　ｔｒｕｅ的意思是有一个字符串的最后一个字母终止在这里

```cpp
void build(string s){
    int u=0;
    int l=s.length();
    for(int i=l-1;i>=0;i--){
        if(!ch[u][s[i]-'a']){
            ch[u][s[i]-'a']=++sz;
        }
        u=ch[u][s[i]-'a'];
        if(i==0)
        val[u]++;
    }
}
```


然后我们在寻找的时候只要找到从叶结点到一个ｉ结点的最长链和次最长链
（为什么是链呢？因为题目中说要么上下两个字符串一个字符串是另外一个字符串的子结点，要么两个字符串相差一个字母，这两种情况分别对应兄弟节点和父子节点）
往兄弟节点走的情况就是状态转移方程中的ｖａｌ[i]　　往父子节点走的最优状况就是所有儿子节点中的dp值最大的

好的就是这样，然后我们就能过了