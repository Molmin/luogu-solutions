$\text{Codeforces}$ 的 $\text{tag}$ 真准确啊，这种题被划分成了 $\text{Trees-tag}$，我也是服了

---

题目要求支持以下三种操作：

$1.$ 把区间 $[l,r]$ 的所有数全部变成 $1$

$2.$ 把区间 $[l,r]$ 的所有数全部变成 $0$

$3.$ 把区间 $[l,r]$ 中的 $0$ 变成 $1$，$1$ 变成 $0$

每次操作后询问最左边的 $0$ 的位置

其中操作次数 $\leq 100000$，$l,r \leq 1e18$

因为 $l,r$ 很大，我们可以考虑把所有操作离线下来然后离散化

$3$ 操作和[这题]( https://www.luogu.org/problem/P2574 )中的操作是一样的，我们可以考虑用线段树维护区间和，

区间异或就相当于 $sum=len-sum$，其中 $sum$ 表示这段区间的和，$len$ 表示这段区间的长度

每次操作询问最左边 $0$ 的位置，有一种非常简单的做法，就是二分这个位置，

然后根据起点到这个点的位置这一段的区间和进行判断：

如果这一段的区间和等于这段区间的长度 ，往大的二分

否则往小的二分，记录答案

贴个部分的 $\text{Code}:$

```cpp
while(l<=r)
{
    int mid=(l+r)>>1;
    if(query(1,1,mid)==mid)l=mid+1;
    else ans=mid,r=mid-1;
}
```

但这样的时间复杂度单次操作是 $log^2{n}$ 的，我们有更优秀的做法

容易想到我们在线段树上从根节点往下跳，

如果左儿子区间和小于当前区间长度，那答案就在左儿子，否则就在右儿子

这样的时间复杂度是 $logn$ 的，总时间复杂度为 $O(nlogn)$