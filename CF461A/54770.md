题意：

我们可以把吐司人当成一个计数器，每次苹果人把数字给他之后他就会加上，然后还给他。当数字量=1时，会被他扔掉；当数字量>1时，他会分成两组，**分别**给吐司人。

分析：

CF的普及-题目大多数都是贪心题，这道也不例外。我们可以发现当数量为一的时候会被扔掉，所以我们可以用这个条件把最小的去掉，即每次分出最小的数，然后它就被扔掉了。为什么要扔掉最小的？因为他对整个答案的贡献最小。    

但是为什么要单独分出来一个？不是两个呢？因为一个的时候只会同时删掉一个，而如果分出很多个，就会同时被删掉很多个，这样就会导致每次参加加和的数变少，自然答案也就会变小。    

举个例子：如果每次都分一半出来，就相当于$O(logn)$的速度，很快就会用完，而如果每次分一个出来其实就是顺序遍历，是$O(n)$的速度，自然是后者加的数多一点。   

然后我们会发现如果每次拿出来一个最小的，我们就可以排序一下，每个数$i$会用到$i+1$次，比如第一个数会在第一次给吐司人的时候用到一次，在被苹果人拆开之后又被用一次，即两次。然而，最后一个数值会用到$i$次，因为最后两个数会同时被删掉（因为被分成了两个长度为一的嘛）。

易错点：十年OI一场空，不开long long见祖宗~（所有的数都要用啊）

蒟蒻的破烂代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
long long n,a[300005],sum;
int main(){
	cin>>n;
	for(int i=1;i<=n;i++) cin>>a[i];
	sort(a+1,a+n+1);
	for(int i=1;i<=n;i++)
		if(i==n) sum+=a[i]*i;
		else sum+=a[i]*(i+1);
	cout<<sum<<endl;
	return 0; 
} 
```

