### 题目大意
给定一个数组，得分增加所有数字之和，然后将这个数组拆分成任意长度的两组数，再次相加，若有一组数长度等于一则删除。

### 大体思路
根据样例#1，我们可以得到，得分 $S=(3+5+1)+(1)+(3+5)+(3)+(5)=26$。也就是说，为了保证得分最高，每次只删除最小的一个数。所以先将数组排序。
```cpp
	cin>>n;
    for (int i=1;i<=n;i++) 
		cin>>a[i];
    sort(a+1,a+n+1);//系统自带排序
```
接下来，我们分析每个数被加的次数。
| 数字 | 位置 | 次数 |
| :----------: | :----------: | :----------: |
| $3$ | $2$ | $3$ |
| $1$ | $1$ | $2$ |
| $5$ | $3$ | $3$ |
如果这还没有看出规律，那么我们来分析一下：

最小的数 $(1)$，在第一轮被加后被拆分成独立的数组，因此第二次被加后即删去，次数为 $2$。第二小的数在第二轮后被拆分成独立的数组，因此第三次被加后即删去，次数为 $3$。也就是说，**第 $i$ 大的数在第 $i$ 次后被拆分成独立的数组，因此加了 $i+1$ 次。**

那么问题来了：按照这个规律，表格中数字 $5,i$ 应该等于三，次数应该为四。其实，第 $n-1$ 次后仅剩下两个数，这两个数均被拆分成独立的数组，因此第 $n$ 次后均删去。所以，**当 $i=n$ 时，次数为 $i$ 而非 $i+1$。**

```cpp
	for (int i=1;i<=n;i++){
		if(i==n) S+=a[i]*i;//当 i=n 时，次数为 $i$ 而非 $i+1$。
		else S+=a[i]*(i+1);//第 i 大的数加了i+1次。
	}
```
### 数据范围
显然，由于 $1<=n<=3⋅10^5$，因此数组 $a[300005]$ 这是不会超空间的。我们再来看： $a_i<=10^6$，这说明最大数最多加了 $3⋅10^5$ 次，最大值为 $3e11$ 超过了 `int` 的范围，故用 `long long`。

###  完整代码：
 ```cpp
#include<iostream>
#include<algorithm>//排序头文件
using namespace std;
typedef long long ll;//方便
ll a[300005];
int main(){
    ll n,S=0;
    cin>>n;
    for (int i=1;i<=n;i++) 
		cin>>a[i];//输入
    sort(a+1,a+n+1);//排序
    for (int i=1;i<=n;i++){
        if(i==n) S+=a[i]*i;
		else S+=a[i]*(i+1);//相加
    }
    cout<<S;//输出
    return 0;
}
```
看得这么认真，不点个赞再走嘛qaq