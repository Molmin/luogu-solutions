题解区全是 `cpp` 的大佬，我来水一篇 `py` 的题解。

这道题是一个贪心题，主要思路就是尽量让较大的值组合，我用样例解释一下。

现在苹果人有了 $3, 1, 5$ 这 $3$ 个数，我们先排序，得到 $1, 3, 5$ 这样的组合，全部给土司人，这时土司人已经有了 $1 + 3 + 5 = 9$ 分。

给到苹果人手里后，苹果人要分组，把最小值 $1$ 单独分出来给土司人，剩下 $3, 5$ 一起给土司人，土司人又得到了 $1 + (3 + 5) = 9$ 分，总共得到 $9 + 9 = 18$ 分。

土司人再把数给苹果人的时候，$1$ 会被直接扔掉，留下 $3$ 和 $5$ ，分别给土司人，土司人得到 $3 + 5 = 8$ 分，总共 $18 + 8 = 26$ 分，再给苹果人的时候，全部扔掉。

我们发现，排序后的每个数 $a_i$ 都会被利用 $i + 1$ 次，但有一个特例：最大数 $a_n$ 会被利用 $n$ 次。

所以代码就非常好写了：

```python
n = int(input())//输入n
a = [0] * (n + 1)//先把list开出来，方便读入
a[1 :] = list(map(int, input().split()))//这样可以让数组下标从1开始
a.sort();//排序，由于a[0] = 0，所以不影响
ans = 0//用于记录答案
for i in range(1, n):
	ans += a[i] * (i + 1)//前n-1个数都被利用了i+1次
ans += a[n] * n//第n个数被利用了n次
print(ans)//输出答案
```
