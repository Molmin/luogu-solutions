我的方法是一种类似于Tarjan的思路，也可以看成是KesdiaelKen同学方法的一个优化。

此题的实质就是求图中最小的环路的长度，每个节点有且一条出边。关于是否可以存在自环的问题，我的答案是可以，此时答案应该是1。

考虑一个从1号节点可以联通全图的有向图，我们从1号节点开始，对每个节点进行DFS，对每个节点进行编号（编号的方式即为在DFS树上，该节点到1号节点的距离。对一个连通图的每次DFS遍历都可以得到一个DFS树，这样编号的特点就是

** 如果dfn[a1]==dfn[a2]，那么一定不存在一条路径，可以不通过1号节点从a1到a2（即使把有向图转为无向图） **

，证明是显然的）

根据这个性质，我们会发现在DFS的过程中，如果遇到了已经访问过的节点，那么肯定形成了一个环，这时，环的长度为dfn[cur]-dfn[t[cur]]+1，其中cur代表当前正在访问的节点，t的定义如题目中所示。

现在我们需要考虑的就是不存在一个节点可以连通全图的情况，处理已经访问过但不是当前根节点最先访问的情况，也就是访问到已经被其他DFS标记过dfn的节点。这很简单，只要在每次递归调用结束后标记上就行了，因为在这个节点开始的DFS树中，一定不存在其他的节点同样可以被他的父亲节点访问。

贴代码：（请认真阅读注释）

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
const int maxn=200010;
int n,t[maxn],dfn[maxn],ans;//dfn是时间戳，定义和Tarjan的有些不一样
bool tf[maxn];//tf数组标记在之前第i个节点有没有被其他节点的DFS树访问过
void dfs(int cur,int fa)//DFS主过程，cur表示当前节点，fa表示DFS树上cur的父亲节点
{
    dfn[cur]=dfn[fa]+1;//计算cur在DFS树上的dfn值
    if(dfn[t[cur]]&&!tf[t[cur]])ans=min(ans,dfn[cur]-dfn[t[cur]]+1);//如果cur的出边是已经被访问过并且没有在之前被其他节点开始的DFS树访问过，更新最小环路的长度
    if(!dfn[t[cur]])dfs(t[cur],cur);//如果cur的出边连向的节点并没有被访问过，则继续DFScur的出边连向的节点
    tf[cur]=true;//在递归调用结束后标记cur已经被其他节点开始的DFS过程访问过
}
int main()
{
    scanf("%d",&n);ans=n;//ans的值最大是n，因为在节点数为n的图中存在的长度最长的环的长度不会超过n
    for(int i=1;i<=n;i++)scanf("%d",t+i);
    for(int i=1;i<=n;i++)if(!dfn[i])dfs(i,i);//如果i号节点还没有被访问过，那么以i号节点为DFS数的根节点开始DFS过程
        //之所以调用dfs(i,i)是为了赋值方便，把dfn[i]直接设成1
        //如果想让程序的思路更加清晰和易懂，可以设立一个虚拟节点0，这是惯用套路了，在此不讨论
    printf("%d\n",ans);//输出最小环路的长度
    return 0;
}
```
关于时间复杂度的讨论：

因为每个节点最多访问1次，每次访问都要O(1)的时间处理，所以时间复杂度是线性（O(N)）的

如果想要降低常数（或者害怕栈空间爆炸），可以将DFS过程转化为while()

空间复杂度O(N)
