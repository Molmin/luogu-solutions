###P2661题解


#很可惜15年我做的时候p党堆+拓扑只得九十分，现在重新考虑这个问题...心血来潮，想写一篇大题解。

#其实这个题，如果想明白了，代码小学生难度...

#给大家奉上一份只有**22行**的AC代码和我的思路，本人原创，速度也很快，最后一个点花了240ms。

#代码属于**DFS**。


##思路

对于这个题，一看就明白，就是要寻找**最小的环**，本能的想到拓扑。

但是实际上这个题用不着拓扑，只需要**慢慢“散步”就行了！**

随便取一个点为第一个点，我们顺着路线走下去，一路上我们只需标记两个量，第一个量是这个枝子的起点的编号i，存入s数组，第二个量是走了多少步，存入p数组， 一旦找到了一个s值不为0的点，也就是冲突点，那就说明找到了环。

面对冲突，处理两种情况，第一个是找到新环，第二个是找到已经访问过的点（这些点肯定已经找到了环了）。

1.找到新环

新环特征就是冲突点的s值等于目前的i，那么直接用走的步数，减去这个不为0的点的步数，就是环长。与ans取小。

2.找到已访问的

已访问的特征就是冲突点的s值不等于目前的i，直接跳过。

然后取下一个s值为0的点作为起点，再来一遍。

这样最后输出ans，然后就22行解决问题了。

复杂度不好说。纯理论的说是**O（nk）的，k是一个小常数**，k取决于图的结构状况，个人感觉不超过10，希望有巨擘给证明一下准确的值。

\_时间见1。\_


##关于剪枝

步数大于ans的剪枝，复杂度**变化不明显，略降一点**。我试过了，最后一个点时间没变化，但前面数据稍小的点，时间缩短了一些。求巨擘解释一下。本代码加了此剪枝。\_不加剪枝时间见下2。\_

\_当然还有一个很无聊的剪枝，就是如果ans为1，就不用找了，肯定是它...你要是那这个卡我我也是醉了。但实际上，这个剪枝也会被卡，因为多了一步判断是一，再一个那种自环点真的很无聊，这样的数据简直就是送分，根本不会有。本题中时间更是不降反升，呵呵。\_\_时间见下3。\_


##**注意必须要把所有的点都访问过，不然可能存在更小的环。**


##时间表

1. #8 21ms #9 82ms #10 240ms

2. #8 41ms #9 119ms #10 240ms

3. #8 93ms #9 118ms #10 399ms


```cpp
#include<cstdio>
int n,a[200001],p[200001],s[200001],ans=2147483647,t,tmp,tmp2,check;
int main(){
    scanf("%d",&n);
    for (int i=1;i<=n;i++) scanf("%d",&a[i]);//读入 
    for (int i=1;i<=n;i++){
        if (s[i]!=0) continue;//已经访问过 
        t=i;tmp=0;check=0;
        while (!s[t]){
            p[t]=tmp;//标记步数 
            s[t]=i;//标记s 
            t=a[t];//下一个点 
            tmp++;//步数增加 
            if (tmp>ans) {check=1;break;}//tmp大于ans剪枝 
        }
        if (s[t]!=i||check) continue;//旧环判断 
        tmp2=tmp-p[t];
        if (tmp2<ans) ans=tmp2;//判小 
    }
    printf("%d",ans);
    return 0;
}
```