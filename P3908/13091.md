因为我比较懒，所以我们令$xor!$表示题中要求的东西。

首先打表找规律，比如对于前31个数：

```
dec bin  xor!
00 00000 00000
01 00001 00001
02 00010 00011
03 00011 00000
04 00100 00100
05 00101 00001
06 00110 00111
07 00111 00000
08 01000 01000
09 01001 00001
10 01010 01011
11 01011 00000
12 01100 01100
13 01101 00001
14 01110 01111
15 01111 00000
16 10000 10000
17 10001 00001
18 10010 10011
19 10011 00000
20 10100 10100
21 10101 00001
22 10110 10111
23 10111 00000
24 11000 11000
25 11001 00001
26 11010 11011
27 11011 00000
28 11100 11100
29 11101 00001
30 11110 11111
31 11111 00000
```

我们可以发现，对于x，有：

如果  $(x+1)\equiv 0\ (mod\ 4)$ ，那么他的 $xor!$ 一定是0

如果 $x\equiv 0\ (mod\ 4)$ ，那么他的 $xor!$ 一定是他自己

（别的依次类推？）

所以我们只需要从输入的那个N向下累xor到i%4==0即可

于是代码就很简单了

还有就是：十年OI一场空，不开long long见祖宗

```cpp
#include<cstdio>
#include<iostream>
using namespace std;
int main()
{
    long long a;
    cin>>a;
    long long ans=0;
    while((a+1)%4!=0)
    {
        ans=ans^a;
        a--;
    }
    cout<<ans<<endl;
    return 0;
}
```
他的正确性可以证明？试一试。。。


已知 $a\equiv 0\ (mod\ 4)$~~我咋不直接写4|a啊~~，求证 $(a)\bigoplus (a+1)\bigoplus(a+2)\bigoplus(a+3)=0$

证明，由于a能被4整除，由题意可知，a的二进制为y00，a+1的为y01，a+2的为y10，a+3的为y11，异或之后变为0。(其中y为一段01序列)~~//懒得写公式符号了~~

证毕~(写完了才发现原来这么简单。。)