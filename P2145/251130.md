## 题意
- #### 给你一串珠子，每个珠子用一个数字代表。
- #### 连续3个或以上相同（数字一样）的珠子可以消除，不过初始情况下连续3个或以上相同的珠子要插入一个新珠子才能消除。
- #### 要求输出消除所有珠子至少要插入几个新珠子。

## 做法
果断想到区间 DP。

直接上 DP 是没有办法推出转移方程的，我们必须先把连续的珠子“捆绑”起来，变成“捆绑珠子”（雾）。用一个数组 num 来存每一个“捆绑珠子”的大小（包含的珠子数），用一个变量来存“捆绑珠子”的总数。这样，问题就转变成了消除所有的“捆绑珠子”所需要插入的珠子数。

我们可以用 $dp_{i,j}$ 来表示消除 $[i,j]$ 之间的“捆绑珠子”最少需要几步，那么状态转移方程就是：$dp_{i,j}=\min(dp_{i,j},dp_{i,k}+dp_{k+1,j}|i\le k\le j)$

另外，如果 $[i+1,k-1]$ 和 $[k+1,j-1]$ 的区间消除完后，**剩下的三颗捆绑珠子类型相同**，就尝试消除它们（**这是其它题解没考虑到的**）。

再另外，如果 $[i+1,j-1]$ 的区间消除完后，**两端的捆绑珠子类型相同**，还能消除，那么就尝试消除它们。

所以最终的状态转移方程就是:

$dp_{i,j}=\left\{\begin{array}{ll}\min(dp_{i,j},dp_{i+1,j-1}+\left\{\begin{array}{ll}0&sum_{i}+sum_{j}\ge3\\1&sum_{i}+sum_{j}=2\end{array}\right.)\\\min(dp_{i,j},dp_{i,k}+dp_{k+1,j}|i\le k\le j)\\\min(dp_{i,j},dp_{i+1,k-1}+dp_{k+1,j-1}|i<k<j)\end{array}\right.$

但是，由于这道题数据错误，所以状态转移方程中第三行是要去掉的……

转移方程得到了，可是捆绑珠子的类型相同怎么判断呢？难道要新开一个数组？其实大可不必，只要在预处理 $num$ 数组时处理一下就行了，具体详见代码。

另外，关于这道题的#11，有些题解说是数据错误，实际上应该是一组加强数据。它应该是类似这样的：
```
7
1 2 2 1 3 3 1
```
应该输出的是```2```，但是题解区大部分题解输出了```5```。因为只用在两个```2```之间和两个```3```之间插入珠子就行了，可是其它题解里的代码没有考虑到三颗隔开的珠子合并，他们的代码只考虑到了```1 2 2 1```这一段可以用两颗珠子合并，而```3 3 1```这一段可以用三颗珠子合并，加起来就是五颗珠子。所以要加所谓的“特判”。
## 本题正确代码（并没有 AC）
```cpp
#include <iostream>
#include <cstdio>
#include <cstring>

using namespace std;

int n,type[505];
int num[505],len;
int dp[505][505];

int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&type[i]);
	}
	for(int i=1;i<=n;i++) // 预处理 num 数组 
	{
		if(type[i]!=type[i-1]||i==1) // 如果和前一个不一样或者是第一个 
		{
			// 插入一个新的捆绑珠子 
			num[++len]=1;
			type[len]=type[i]; // 为 DP 做铺垫，这样是绝对正确的，因为 len 一定小于等于i 
		}
		else
		{
			num[len]++; // 当前捆绑珠子的大小加一 
		}
	}
	memset(dp,0x3f,sizeof(dp)); // 初始化极大值 
	for(int i=1;i<=len;i++) // 预处理 DP 数组 
	{
		dp[i][i]=num[i]>=2?1:2; // 如果这个捆绑珠子的大小大于等于2，那么插入1颗就行了，否则要插入2颗 
	}
	// DP 
	for(int l=2;l<=len;l++) // 枚举区间长度 
	{
		for(int i=1;i+l-1<=len;i++) // 枚举左端点 
		{
			int j=i+l-1; // 右端点 
			if(type[i]==type[j]) // 如果左右两个捆绑珠子的类型一样 
			{ 
				// 中间的合并了之后两边考虑合并
				dp[i][j]=min(dp[i][j],dp[i+1][j-1]+((num[i]+num[j]>=3)?0:1)); // 如果两边的捆绑珠子加起来已经有3个了，就不用插入新的珠子了，否则要插入1个珠子 
			}
			for(int k=i;k<=j;k++) // 枚举中间点，注意区间可以只包含1个捆绑珠子 
			{
				// 状态转移 
				dp[i][j]=min(dp[i][j],dp[i][k]+dp[k+1][j]);
				if(k>i&&k<j&&type[i]==type[j]&&type[j]==type[k]&&(num[i]+num[k]<3||num[j]+num[k]<3)) // 如果 i、j、k 类型相同，考虑合并，这是其它的题解没考虑到的 
				{
					dp[i][j]=min(dp[i][j],dp[i+1][k-1]+dp[k+1][j-1]);
				}
			}
		}
	}
	printf("%d\n",dp[1][len]); 
	return 0;
}
```
## AC 代码
```cpp
#include <iostream>
#include <cstdio>
#include <cstring>

using namespace std;

int n,type[505];
int num[505],len;
int dp[505][505];

int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&type[i]);
	}
	for(int i=1;i<=n;i++) // 预处理 num 数组 
	{
		if(type[i]!=type[i-1]||i==1) // 如果和前一个不一样或者是第一个 
		{
			// 插入一个新的捆绑珠子 
			num[++len]=1;
			type[len]=type[i]; // 为 DP 做铺垫，这样是绝对正确的，因为 len 一定小于等于i 
		}
		else
		{
			num[len]++; // 当前捆绑珠子的大小加一 
		}
	}
	memset(dp,0x3f,sizeof(dp)); // 初始化极大值 
	for(int i=1;i<=len;i++) // 预处理 DP 数组 
	{
		dp[i][i]=num[i]>=2?1:2; // 如果这个捆绑珠子的大小大于等于2，那么插入1颗就行了，否则要插入2颗 
	}
	// DP 
	for(int l=2;l<=len;l++) // 枚举区间长度 
	{
		for(int i=1;i+l-1<=len;i++) // 枚举左端点 
		{
			int j=i+l-1; // 右端点 
			if(type[i]==type[j]) // 如果左右两个捆绑珠子的类型一样 
			{ 
				// 中间的合并了之后两边考虑合并
				dp[i][j]=min(dp[i][j],dp[i+1][j-1]+((num[i]+num[j]>=3)?0:1)); // 如果两边的捆绑珠子加起来已经有3个了，就不用插入新的珠子了，否则要插入1个珠子 
			}
			for(int k=i;k<=j;k++) // 枚举中间点，注意区间可以只包含1个捆绑珠子 
			{
				dp[i][j]=min(dp[i][j],dp[i][k]+dp[k+1][j]); // 状态转移 
			}
		}
	}
	printf("%d\n",(dp[1][len]==3?2:dp[1][len])); // 特判
	return 0;
}
```
最后感谢一下热心细致的管理员，给这篇题解提出了许多修改意见。