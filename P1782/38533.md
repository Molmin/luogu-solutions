#本题十分良心，想学好背包都应该做。它包含了较普通背包的大部分知识及多种优化方法

**本人是炒鸡蘑菇（蒟蒻），提交了（20）遍才A了这道题哎，说起来都是泪啊。。。。那废话不多说，进入本题的AC方法As is known to all这道题时间卡的特别紧，朴素代码拿出来样例肯定过，但是提交时却会全都TLE（别问我为什么知道）。先谈一下基本思路吧。这道题一般分为两步，即先处理普通货物，再处理奇货因为奇货最多只有5个，所以可以直接朴素代码带走，主要问题是前面的那些普通货物，我的想法是通过二进制优化多重背包，转成01背包做。**

**方法是：将第i种物品分成若干件（用二进制）物品，其中每件物品都有一个系数2^k，k属于{1,2,4,8，16.......}，因为二进制可以表示所有数，所以我们用一个循环来模拟二进制，因为2^k<=vi\*di，所以不用担心k炸掉**

```cpp
for(int k=1;k<=d;k*=2){
v[++count]*=k;
w[count]*=k;
//进行操作
d[count]-=k}
if(d[count]>0)v[++count]*=d[count];w[count]*=d[count]；
```
**通过以上的一个循环就可以实现二进制,但是由于本题数据奇大，无存储，所以必须每次输入时进行操作，这样，就不用担心存储的问题循环输入时的for，就相当于朴素代码中dp时的第一个for但是即便如此，也还是不能A这道题，还是会tle几个点这时，我们首先想到的当然是输入优化，这是必须有的，否则会tle三个点。那我们还能怎样优化呢？那就是看这种物品是否可以全装到背包中，也就是在输入时先if（v\*d>n）如果是，那这个物件就可以当做完全背包中的一种物品，因为这个物品不可能全取，那就可以视为这种物品无限多，这样就可节省时间。如果v\*d<=n，再按多重背包用二进制做，即用else。这样，这道题就基本能A了**
最后，附上代码（可能有点乱）

```cpp
#include<bits/stdc++.h>//万能文件头
using namespace std;
int  n,m,c;//基本数据
long long f[10005];
int  v,w,d;//货物的v，w，d
int read(){//读入优化，也必须有
    char c=getchar();int x=0,f=1;
    while(c<'0'||c>'9'){if(c=='-')f=-1; c=getchar();}
    while(c>='0'&&c<='9'){x=x*10+c-'0'; c=getchar();}
    return x*f;
}
int main()
{
    n=read();m=read();c=read();
    for(int i=1;i<=n;i++){
        v=read();w=read();d=read();
        if(d*v>c){//判断是不是完全背包
            for(int j=v;j<=c;j++){
                f[j]=max(f[j],f[j-v]+w);
                }
            }
        else {
        for(int k=1;k<=d;k*=2){//二进制优化
            if(c<v*k){//这句没啥用，但我懒得删了，大家无视就行了
                break;}
            for(int j=c;j>=v*k;j--){
                f[j]=max(f[j],f[j-v*k]+w*k);//非常基础的dp背包
            }
            d-=k;
        }
        if(d>0){
        for(int j=c;j>=v*d;j--){
            f[j]=max(f[j],f[j-v*d]+w*d);
        }}
    }}
    int j;
    for(int i=1;i<=m;i++){v=read();w=read();d=read();
        for(int j=c;j>=0;j--){//最后的奇货只用朴素代码就够了
            for(int k=0;k<=j;k++){
                f[j]=max(f[j],f[j-k]+(v*k+w)*k+d);
            }
        }
    }
    printf("%lld",f[c]);
}//本题解结束，祝大家compling快乐
```