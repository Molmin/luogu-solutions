## [***点我获得更好的阅读体验***](https://fanfansann.blog.csdn.net/article/details/113522707)




**Problem D Strange Definition**

两个整数 $x$ 和 $y$ 是 **相邻的** 当 $\frac{lcm(x,y)}{gcd(x,y)}$是完全平方数。

你有一个长度为 $n$ 的序列 $a$。每一秒，所有的 $a_i$都会变成序列中所有和它 **相邻的** 的数的乘积。令 $d_i$为数列中与 $a_i$    **相邻的** 的数的个数

有 $q$ 次询问，每次询问给出一个 $w$，求在 $w$ 秒时的 
$\max\{d_i\}$

**Solution**

首先，我们来学习一个单词：$\tt perfect\ square$：完全平方数...我还以为是完美的正方形，我说哪来的正方形...给我人看傻了...

以及 $\tt adjacent$： adj. 相邻的，毗邻的

然后开始照例分析题目中的性质。

首先是完全平方数，就是指整数 $x$ 存在一个正整数 $y$ ，使得 $x=y^2$，整数 $x$ 就是一个完全平方数。

我们定义两个数是相邻的，是指两个整数 $x$ 和 $y$ ，满足：   $\frac{lcm(x,y)}{gcd(x,y)}$ 是完全平方数。

我们知道 $\gcd(x,y) \times lcm(x,y)=x\times y$。

$$\frac{lcm(x,y)}{gcd(x,y)}=\frac{x\times y}{\gcd(x,y)^2}$$

这个东西是完全平方数，也就意味着它可以被开根。

即

$$\sqrt{\frac{x\times y}{\gcd(x,y)^2}}=\frac{\sqrt{x\times y}}{\gcd(x,y)}$$

也就是说对于任意两个整数 $x$ 和 $y$ 而言，若 $x\times y$ 是完全平方数，则这两个数是相邻的。

由 **数论必备** 唯一分解定理得：

$x=p_1^{\alpha_1}\times p_2^{\alpha_2} \times \cdots\times p_{k}^{\alpha_{k}}$

$y=p_1^{\beta_1}\times p_2^{\beta_2} \times \cdots\times p_{k}^{\beta_{k}}$

$x\times y=p_1^{\alpha_1+\beta_1}\times p_2^{\alpha_2+\beta_2} \times \cdots\times p_{k}^{\alpha_k+\beta_{k}}$

显然，若两个数的乘积是完全平方数，则所有质因子的次幂 $\alpha +\beta$ 均为偶数。

也就意味着所有质因子对应的 $\alpha$ 和 $\beta$ 是同奇偶性的，即 $\alpha$ 是奇数， $\beta$ 也是奇数，或者 $\alpha$ 是偶数， $\beta$ 也是偶数，或者一个是偶数，一个是 $0$ ，这样二者相加才是偶数。

因为我们发现还有 $0$ 的存在，所以我们需要考虑如何把偶次幂与偶次幂，和 $0$ 次幂与偶次幂表示成一个形式。很容易就想到了我们判断奇偶性的时候使用的 `% 2`，这样偶次幂或者本来就是 $0$ 的最后都会变成 $0$ ，而奇次幂最后会变成 $1$ 所以我们将每个数都质因数分解的同时，对于每一个质因子的次幂都 `% 2` ，也就是质因数分解的时候指数一直 `/= 2` 也就是 $/= i^2$ 。最后将 $x=p_1^{\alpha_1}\times p_2^{\alpha_2} \times \cdots\times p_{k}^{\alpha_{k}}$ 变为 $x=p_1^{1}\times p_2^{0} \times \cdots\times p_{k}^{0}$ 的形式。

这样，最后只要是 $0$ 就都是一组。

但是对于奇数而言，不一定。因为虽然都是是 $1$ ，但是奇次幂的话，必须能够配对，才是一组，配对的意思就是 变成 $x=p_1^{1}\times p_2^{0} \times \cdots\times p_{k}^{0}$ 的形式以后，两个数剩余的质因子必须完全相同，也就是拥有相同的 $1$ 次幂的质因子，也就是转换为上面的那个形式以后， 两个数的值完全相同。

我们可以使用 `map` 来储存同一组（相互都相邻）的元素个数。

分析完相邻的性质以后，我们知道如何判断是否相邻，我们可以直接对于每个输入的数，判断一下，存入 `map` 中。

然后再来考虑第二个问题，题目中的操作，合并。

我们从第 $0$ 秒开始，每一秒，每一个数都会变成所有与自己相邻（包括自己）的数的乘积，然后有 $q$ 次询问，每次会问第 $\omega$ 秒，数列中，所有相邻组（全部两两相邻）中元素个数最多的个数。$\omega \le10^{18}$。所以我们瞬间就可以看出点什么东西，就是这个操作修改以后，答案肯定存在一个循环节或者之后的某一时刻就不会再发生变化了。因为询问的数据太大， 啥数据结构都不可能存得下，也不可能快速地求解。

然后我们来分析这个操作，同一组的所有的数都会同时合并，我们根据上面的分析，知道一共有四种组别

1. 个数为偶数的 $0$ 组（偶次幂）
2. 个数为奇数的 $0$ 组（偶次幂）
3. 个数为偶数的 $1$ 组（奇次幂）
4. 个数为奇数的 $1$ 组（奇次幂）

我们来分析这四种组别合并后会发生什么。

- **第一种，第二种**

我们的合并操作是全部数的乘积，对于质因数分解后的 $x$ ，全部数的乘积实际上就是所有数的指数的和，而第一种，第二种，不管组内个数是奇数个还是偶数个，因为都是偶数，所以和仍然是偶数，也意味着还是第一种或者第二种，而第一种和第二种实际上是同一种，因为都是相邻的，这里分开只是两种不同的情况。所以第一第二种任意秒以后，仍然还是第一第二种。

- **第三种**

偶数个全部对应的奇次幂，和为偶数，因为每个次幂都是奇数，也就是 $1$ ，奇数加奇数为偶数，在第一秒第一次合并以后归为第一种或者第二种。

- **第四种**

奇次幂，还是奇数个，那么相乘，也就是指数相加，永远都还是第四种。

分析完我们发现，询问一共分 $\omega=0$ 和 $\omega>0$ 两种情况， $\omega=0$ 的时候，数列中的数一共分为三种

- 第一种就是我们上面说的第一第二种，我们累计所有指数是偶次幂的元素的个数。
- 第二种为我们上面说的第三种，即虽然是 $1$ 组，但是个数是偶数，也就是我们 `map` 存的第二维是偶数。
- 第三种就是我们上面说的第四种，奇数个的奇数次幂，我们用 `map` 来hash一下，对于这一种的每一个值，都分为每一组，取最值。

 $\omega=0$ 时答案就是上述三种的元素个数的最大值。

 $\omega>0$ 时， 第二种全部归为第一种，所以我们只需要用第三种里最大的那一组的个数，与第一种元素个数加上第二种的元素个数，取最大值即可。


**detail**

虽然上面说了那么大一堆，这些实际上只是我当时做题的时候的心理活动，在演草纸上画思维导图来分类讨论，总共花了不到 $10$ 分钟，因为写题解我习惯讲的比较详细，我希望可以把如何思考问题带给大家，所以内容有点多了，请大家见谅 ...

**Code**

实现就非常简单了，照着上面的思路模拟一遍就行了
```cpp
#include <cstdio>
#include <iostream>
#include <cstring>
#include <algorithm>
#include <vector>
#include <unordered_map>

using namespace std;
const int N = 3e5 + 7, mod = 1e9 + 7;
typedef long long ll;
unordered_map<int, int> Hash;
void get_factor(int x)
{
    for(int i = 2; ; ++ i) {
        int even = i * i;
        while(x % even == 0 && x >= even) x /= even;
        if(x < even) break;
    }
    Hash[x] ++ ;////我们实际上只需要知道它是奇还是偶
    //x就是把所有的质因子的次方全部压成0或者1，0就是偶次幂，x=1(被除尽了)，1次就是奇次幂。x=若干一次质因子的乘积

    //偶次幂无所谓，奇次幂必须所含奇次幂的质因子全部完全相同才是一组（能凑成偶数，也就是完全平方数）
}
int n, m, t, q;
int main()
{
    scanf("%d", &t);
    while(t -- ) {
        Hash.clear();
        scanf("%d", &n);
        for(int i = 1; i <= n; ++ i) {
            int a;
            scanf("%d", &a);
            get_factor(a);
        }
        int ans1 = 0, ans2 = 0;
        for(auto it = Hash.begin(); it != Hash.end(); ++ it) {
            //0秒的情况不变
            ans1 = max(ans1, it -> second);//second是个数，0秒没有变化的时候，最大数量的那组就是最大的那组
            //1秒的情况合并
            if(it -> second % 2 == 0 || it -> first == 1)//(组内有偶数个 || 这个组是偶数次幂组)
                ans2 += it->second;//1秒钟后就会全部归为偶组
        }
        ans2 = max(ans2, ans1);//取奇数组和偶数组中的最大值
        scanf("%d", &q);
        for(int i = 1; i <= q; ++ i) {
            ll w;
            scanf("%lld", &w);
            if(w == 0)
                printf("%d\n", ans1);
            else printf("%d\n", ans2);
        }
    }
    return 0;
}
```