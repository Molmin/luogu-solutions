题目让我们求一个二项式系数之和，暴力时间复杂度为 $O(N^2)$，我们考虑能不能把 $i$，$j$ 两部分拆开分别计算后再进行合并。

考虑组合意义，从一堆里面选出若干个可以等价于将堆分成两堆，这两堆选出的物品个数之和为要求的个数的方案数，我们枚举其中一堆选出的物品个数，原式可以化为 $ \sum_{i}^{n} \sum_{j}^{n} \sum_{k} \binom{a_i+b_i}{a_i-k} \binom{a_j+b_j}{a_j+k} $，把求和次序交换，外层枚举 $k$ 内层相当于两个多项式相乘，但是这里预处理的时间复杂度不会超标，直接计算可以做到 $O(nk)$。

还有没有其他做法呢？这看起来就很像个卷积，但是单项计算复杂度就是 $O(n)$ 的，我们只好换个思路，考察二项式系数原本的定义，转化柿子为 $[x^{a_i+a_j}] \sum_{i}^{n} \sum_{j}^{n} (x+1)^{a_i+a_j+b_i+b_j}$，这下可以卷了，除掉 $x$ 后将两边分开可以变成 $[x^0]\left(\sum^{2n}_{k}Q_k\left(1+x\right)^k\right)^2$，其中 $Q_i$ 为所有 $a_i+b_i$ 为 $k$ 的 $x^{-a_i}$ 之和。

由于一个数列每次乘 $(1+x)$ 都是加一遍自己和自己移位之后的数列，我们这里只记录每一项的系数，预处理 $Q_k\left(1+x\right)^k$，倒序循环枚举 $i$ 从 $k$ 到 0，把对应 $-a_i$ 位置加 1 后整体乘上 $(1+x)$，即每个位置向后移一位后加一遍原本的序列即可，这也等价于自己前面每个数加一遍自己前面的系数，这个倒序枚举每次乘 $x$（此处为 $(1+x)$） 的做法也叫作秦九韶算法。最后别忘记去重，我们不能使 $i=j$。

还有没有其他做法呢？考虑原式的组合意义，即从 $(0,0)$ 走到 $(a_i+b_i,a_j+b_j)$ 的方案数，考虑分离两部分，我们平移坐标轴，把起点设为 $(-a_i-a_j)$，之后考虑多个起点的 dp 进行统计即可，这种方法也不要忘记去重。