由于 $0$ 是任何非 $0$ 整数的倍数，一个数本身也是自己的倍数，所以：

+ 如果该字符串中有大于等于 $\lfloor \frac{n}{2} \rfloor$ 的连续子串全为 $0$，那么另找一个长度大于 $\lfloor \frac{n}{2} \rfloor$ 的连续子串即可。

+ 如果该字符串中有两个长度大于等于 $\lfloor \frac{n}{2} \rfloor$ 的连续子串，或者是有一个长度大于等于 $\frac{n}{2}$ 的连续子串且该字串前面一位或数位为 $0$，那么也是一组解。

+ 如果一个字符串有一个长度大于等于 $\lfloor \frac{n}{2} \rfloor$ 的连续子串，它的后面一位或数位为 $0$，说明包括后面的 $0$ 的子串一定是该子串的 $2$ 倍，是一组解。

+ 否则说明该字符串全为 $1$，符合上面的第二种情况。事实上，上面第一种情况也可以归到第二、三两种情况里。

所以本题一定有解。

代码：

```cpp
#include <cstdio>
int t, n;
char s[20003];
int main() {
    scanf("%d", &t);
    while (t--) {
        scanf("%d%s", &n, s + 1);
        bool ok = 0;//0表示符合情况4
        for (int i = 1; i <= n; i++)
            if (s[i] == '0'){
                ok = 1;
                if (i > (n >> 1))//此时[1,i-1]长度大于等于[n/2]
                    printf("1 %d 1 %d\n", i, i - 1);
                else//否则[i+1,n]长度大于等于[n/2]
                    printf("%d %d %d %d\n", i, n, i + 1, n);
                break;
            }
        if (!ok)//此时两个子串[1,n-1],[2,n]长度相同，且数值一样
            printf("1 %d 2 %d\n", n - 1, n);
    }
    return 0;
}
```