对于曼哈顿距离的比较，可以套路地将 $(x,y) \rightarrow (x-y,x+y)$ 转化为切比雪夫距离，一个炸弹的攻击范围变成了矩形。

当然可以用 K-D Tree 优化建边之后 tarjan 缩点来做，但是看起来码量巨大。

注意到此题仅需关于连通性的信息，且攻击关系是双向的，所以大概可以用并查集维护。问题是怎么建边。

考虑用一个 $R\times R$ 的矩形去框，同时被框中的点一定可以互相波及。那这个矩形就有了横坐标和纵坐标的两条限制（均需要 $\leq R$）：

- 横坐标的限制可以先把所有点按照横坐标排序，扫描线动态地维护横坐标相差 $R$ 以内的点集。

- 对于纵坐标的限制，也就是在点集中，每两个纵坐标之差 $\leq R$ 的点必须联通。

第一点很简单，双指针即可；对于第二点，考虑计算 **增量** 的贡献：

- 从集合内删除一个元素，不会对连通性产生改变。

- 从集合内加入一个元素，只可能将 **自己** 与 **某些它能攻击到的连通块** 连起来，而由于纵坐标相差 $\leq R$ 的点在之前必然已经被合并了，所以在它的攻击范围内，最多存在 纵坐标大于它的 和 小于它的 两个连通块。找到其纵坐标的前驱后继即可。

需要注意的是，横/纵坐标坐标有相等的情况，需要钦定编号小的点优先级较高（举例）。

```cpp
for(rgi i=1;i<=n;++i){
	while(!s1.empty()){
		node k=*s1.begin();
		if(p[i].x-R>k.x)s1.erase(k),s2.erase(k);
		else break;
	}
	auto nxt=s2.lower_bound(p[i]);
	if(nxt!=s2.end()&&(*nxt).y-p[i].y<=R)fa[find(p[i].id)]=find((*nxt).id);
	if(nxt!=s2.begin()&&p[i].y-(*--nxt).y<=R)fa[find(p[i].id)]=find((*nxt).id);
	s1.insert(p[i]),s2.insert(p[i]);
}
```
