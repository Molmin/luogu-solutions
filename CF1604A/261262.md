（方法不唯一，在这里提供一种参考做法）

假设我们现在获得了一个序列 $[1,2,4,7,6]$，我们使用一个变量 $now$，代表现在插入了多少个数字，对序列逐个处理

1. 扫到 $1$ 时，$1 \le 1$ 符合要求，不做处理

2. 扫到 $2$ 时，$2 \le 2$ 符合要求，不做处理

3. 扫到 $4$ 时，$4 > 3$，不符合要求，我们在 $2$ 和 $4$ 中间插一个无穷小的数，保证这个数符合要求，同时让 $4$ 也符合要求。注意，此时的 $4 $ 已经挪了位置，我们将 $now+1$，后面的数在判断的时候也要注意挪位置

4. 扫到 $7$ 时，$7 > 4+1$，不符合要求，我们在 $4$ 和 $7$ 中间插 $(7-(4+1))=2$ 个无穷小的数，保证这两个数符合要求，同时让 $7$ 也符合要求。注意，此时的 $7$ 已经挪了位置，我们将 $now+2$ 

5. 扫到 $6$ 时，$6 \le 5+1+2$，符合要求，故不做处理

可以证明，前面插数只会让后面的数需要插的次数减少，故这个做法是正确的。

Code:

```
#include<iostream>
#include<cstdio>
using namespace std;
int t,a[105],n;
int main(){
	cin>>t;
	while(t--){
		cin>>n;
		for(int i=1;i<=n;i++)
			cin>>a[i];
		int now=0;
		for(int i=1;i<=n;i++)
			if(a[i]>i+now)
				now+=(a[i]-i-now);
		cout<<now<<endl;
	}
   return 0;
}
```
