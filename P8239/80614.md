这题真的太妙了！！！！！！！

你能想到的朴素 dp 跟正解都没有关系（确信

什么 $O(n^2k)$ 和 $O(nk\log n)$ 的。

正解不是斜优，也没法斜优。

你会发现划分 $k$ 段很烦人，说白了，这个根本没有前途。

不妨不考虑划分，考虑转化，因为你每个子区间只有最大最小值有用，所以不妨只考虑选最大最小值的情况。

具体怎么选？

抛开划分区间的影响，设 $dp_{i,j,0/1/2}$ 为在第 $i$ 个位置内已经确定好了 $j$ 个区间，第 $(j+1)$ 个区间已经确定了这个区间的/nothing/最小值/最大值。

发现这个其实是好转移的，然后就做完了！！！

注意：一个数可以同时当一个区间内的最小最大值。

时间复杂度：$O(nk)$

# AC code：
```cpp
__int128 dp[5005][3];
int a[5005],b[5005];
int main(){
	int n=read(n),k=read(k),i,j,l;
	for(i=1;i<=n;i++) read(a[i]);
	for(i=1;i<=k;i++) read(b[i]);
	for(i=0;i<=k;i++) dp[i][0]=dp[i][1]=dp[i][2]=-(__int128)1000000000000000000000000000000;
	dp[0][0]=0;
	for(i=1;i<=n;i++){
		for(j=k-1;~j;j--){
			__int128 mul=1;
			for(l=1;l<=b[j+1];l++) mul*=a[i];
			dp[j][1]=max(dp[j][1],dp[j][0]+mul);
			dp[j][2]=max(dp[j][2],dp[j][0]-mul);
		}
		for(j=k;j;j--){
			__int128 mul=1;
			for(l=1;l<=b[j];l++) mul*=a[i];
			dp[j][0]=max(dp[j][0],max(dp[j-1][1]-mul,dp[j-1][2]+mul));
		}
	}
	print(dp[k][0]);
	return 0;
}
```