[广告](http://www.cnblogs.com/wawcac-blog/p/6914837.html)

先来简化一下题意：给定一个数列a[]，求有多少个子序列元素平均值大于等于k。


遍历所有子区间复杂度最小O(n^2)，可用前缀和O(1)得到任意区间和。


想个办法吧，这类题要么用奇奇怪怪的数据结构(可能有这样的数据结构?我不知道)，要么推公式。


那就推公式——


首先取出一段区间吧，设1<=i<=j<=n，然后这段区间（a[i]~a[j]）的平均值为



　　　　(a[i]+a[i+1]+…+a[j]) / (j-i+1)>=k

分母不太好看，乘到右边吧——




　　　　a[i]+a[i+1]+…+a[j] >= k\*(j-i+1)

　　　　a[i]+a[i+1]+…+a[j]>= k+…+k //(j-i+1)个k

接下来有点关键啦




　　　　a[i]+a[i+1]+…+a[j] - k-…-k>=0

　　　　(a[i]-k) + (a[i+1]-k) +……+ (a[j]-k)>=0//哦？那么整齐，有意思

那我们另设一个数组b[]，使b[i]=a[i]-k吧



　　　　b[i]+b[i+1]+…+b[j]>=0

哦？b[]的一段区间和大于等于零？


记得前面想暴力的时候说过用前缀和能O(1)取得任意区间和吗？给b[]套上区间和吧


设s[i]=b[1]+b[2]+b[3]+…+b[i]，特别的，令s[0]=0，那么b[i]+b[i+1]+…+b[j] = s[j]-s[i-1]。



　　　　s[j] - s[i-1]>=0

移项一下



　　　　s[j]>=s[i-1]，哇，快了。

因为之前定义过i<=j，所以i-1<j，这是什么？


是的没错！逆序对（大雾，应该叫顺序对的）！


i-1<j且s[i-1]<=s[j]，对s数组求逆序对顺序对即可。


不会求逆序对的就先掌握这个姿势吧，也挺简单的。


最后说一下，我不知道为什么把求逆序对的程序类比着改一下，求出来“顺序对”就是对的。反正套上去就AC了

[源代码](http://www.cnblogs.com/wawcac-blog/p/6914837.html)
