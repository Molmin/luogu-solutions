## O(1)算法，不用DP、不用循环，甚至变量都只需要两个！


### **先上思路：**

####  _我们一位一位的看。_ 

首先，个位的$1$有几个？ 那就是$n/10+1$,这个很容易；

接着，十位的$1$有几个？这时，可能有朋友就会说了（包括我），那不就是$n/100+1$嘛。且慢，除了$10$、$100$、$1000$这些以外，还有$11$、$12$、$13......$所以，正确的式子应该是$(n/10+1)*10$。

那百位呢？就是$(n/1000+1)*100$。

以此类推$......$


------------


### 注意：

- 这个代码很容易被卡掉，比如数据$12$，这个程序算出来的就是$12$；为什么会这样呢？

  因为$1$~$12$中，$13,14,15,16,17,18,19$中十位的1都不能算入总数，所以，我们还要特判一下这种情况。
  

------------


万事俱备，上代码：
```
#include <bits/stdc++.h>
using namespace std;
long long min(long long a,long long b)
//手写min（可以省略）
{
  if(a>b) return b;
  else return a;
}
int main()
{
  int n,ans=0;
  cin>>n;
  //开始计算~
  if(n>=1)
  {
    ans+=(n/10+1)*1;
    if(n%10<2-1)//上文所说的特判
      ans-=min(1,2-n%10-1);
  }
  if(n>=10)
  {
    ans+=(n/100+1)*10;
    if(n%100<20-1)
      ans-=min(10,20-n%100-1);
      //这里用min，是为了防止出现减去的数过大（比如
      100，可以自己试一试）；
  }
  if(n>=100)
  {
    ans+=(n/1000+1)*100;
    if(n%1000<200-1)
      ans-=min(100,200-n%1000-1);
  }
  if(n>=1000)
  {
    ans+=(n/10000+1)*1000;
    if(n%10000<2000-1)
      ans-=min(1000,2000-n%10000-1);
  }
  if(n>=10000)
  {
    ans+=(n/100000+1)*10000;
    if(n%100000<20000-1)
      ans-=min(10000,20000-n%100000-1);
  }
  if(n>=100000)
  {
    ans+=(n/1000000+1)*100000;
    if(n%1000000<200000-1)
      ans-=min(100000,200000-n%1000000-1);
  }
  if(n>=1000000)
  {
    ans+=(n/10000000+1)*1000000;
    if(n%10000000<2000000-1)
      ans-=min(1000000,2000000-n%10000000-1);
  }
  if(n>=10000000)
  {
    ans+=(n/100000000+1)*10000000;
    if(n%100000000<20000000-1)
      ans-=min(10000000,20000000-n%100000000-1);
  }
  if(n>=100000000)
  {
    ans+=(n/1000000000+1)*100000000;
    if(n%1000000000<200000000-1)
      ans-=min(100000000,200000000-n%1000000000-1);
  }
  if(n>=1000000000)
  {
    ans+=(n/10000000000+1)*1000000000;
    if(n%10000000000<2000000000-1)
      ans-=min(1000000000,2000000000-n%10000000000-1);
  }
  cout<<ans<<endl;
  return 0;
}

```

亲测AC，所有数据$1ms$过。

写题解不易，觉得好的，给个赞再走呗~