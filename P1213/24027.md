```cpp
#include<cstdio>
#include<cstdlib>
//#include<iostream>
//#include<algorithm>
using namespace std;
#define N 262145  //为4^9 一个种有4种状态，有9个钟，所以这整个布局就有4^9个状态 
const int size[9] = {4, 3, 4, 3, 5, 3, 4, 3, 4};
const int dir[9][6] = {{0, 1, 3, 4}, {0, 1, 2}, {1, 2, 4, 5},
                       {0, 3, 6}, {1, 3, 4, 5, 7}, {2, 5, 8},
                       {3, 4, 6, 7}, {6, 7, 8}, {4, 5, 7, 8}};//从0到8 表示从第1个时钟到第9个时钟 
int T,a[4][4],b[4][4],q[N],step[N],op[N][30];//op为序列顺序 
void bfs(int st)
{
    int i,j;
    for(i=0;i<N;i++)//一定要从0开始！因为全是12时就是step[0]要执行后面if(step[]==-1)后面的操作必须先要赋初始值为-1 
        step[i]=-1;//初始化
    int l=1,r=0;
    q[++r]=st;    step[st]=0;//step表示到达这个4进制转成的十进制编码[]的步骤数 
    while(l<=r)
    {
        int cur=q[l++];
        int x=cur;
        for(i=1;i<=3;i++)
            for(j=1;j<=3;j++,x=x/4)//这个=赋值一定要写上 
                a[i][j]=x%4;//倒叙储存转成的4进制——翻译 
        for(int k=0;k<9;k++)//枚举操作
        {
            for(i=1;i<=3;i++)
                for(j=1;j<=3;j++)
                    b[i][j]=a[i][j];//复制棋盘    
            for(i=0;i<size[k];i++)//dir数组是从0开始的 
            {
                int x=dir[k][i]/3+1;
                int y=dir[k][i]%3+1;//注意实际的布局和dir数组有点差异
                //当然我们也可以让实际布局从0开始来使得更加方便 
                b[x][y]=(b[x][y]+1)%4;//使得顺时针旋转90度而且不出这4种情况 
            }
            int code=0,m=1;
            for(i=1;i<=3;i++)
                for(j=1;j<=3;j++,m*=4)
                    code+=b[i][j]*m;
            if(step[code]==-1)//之前没有被遍历过
            {
                step[code]=step[cur]+1;//只多了一步 
                for(i=1;i<=step[cur];i++)//把之前的所有顺序赋值，step已经记录了这些顺序的总量有多少方便枚举轮数
                    op[code][i]=op[cur][i];//后面的i表示这个顺序是第几个
                op[code][step[cur]+1]=k+1;//如果后面写i，那么会错！因为i在最后还加了1！！
                //写k+1是因为题目中是从1开始的，而我们的dir枚举是从0开始的
                q[++r]=code; 
                if(code==0)//这个代表全部是12的情况，我们这里是把12的4进制定义为0 来方便计算
                    return ;
            } 
        }  
    }
}
int main() 
{
    int x;
    for(int i=1,m=1;i<=3;i++)
        for(int j=1;j<=3;j++,m*=4)//注意这是个严格的转4进制的方法 
        {
            scanf("%d",&x);
                T+=((x/3)%4)*m;//我们可以这么操作使得到这个状态的4进制表示 
        }
    bfs(T);
    for(int i=1;i<=step[0];i++)//step[0]表示到全部是12 的步骤数
        printf("%d%c",op[0][i],i==step[0]?'\n':' ');//op前面是指的编码，后面是指的顺序中每一个元素的顺序坐标什么的 
        return 0; 
    }
```
/\*我们在这里用一个4进制串来表示312、3、6、9点的情况
dir代表要进行操作的时钟编码

size表示一次移动要涉及到的时钟个数，方便之后枚举

用step初始值为-1 并之后先判断他是否为-1 再进行更新操作，我们就可以实现一定的记忆化搜索

并且保证第一次到这个状态时的步骤最小

我们从小的开始往大的 枚举，那么就可以解决输出时的连接数最小的问题了 \*/
