## 枚举的时间复杂度可以优化（3个循环）

我们先将输入的每一个数化为它最少还要几次变成12记为c[i]（如：9->1）{公式（4-（输入的数/3）}；

由题意可知：

1钟可受开关1，2，4控制

2钟可受开关1，2，3，5控制

3钟可受开关2，3，6控制

4钟可受开关1，4，5，7控制

5钟可受开关1，3，5，7，9控制

6钟可受开关3，5，6，9控制

7钟可受开关4，7，8控制

8钟可受开关5，7，8，9控制

9钟可受开关4，8，9控制



------------


用p1-p9表示开关使用的次数，所以当

#### （可以影响i钟的开关的总使用次数%4）与c[i]相等时

就可以将钟i移动到12；

我们可以列一个表来表示可以的情况


|号数   |可以的情况|
| :----------- | :----------- |
|  1|c[1]==(p1+p2+p4)%4
| 2 | c[2]==(p1+p2+p3+p5)%4   |
|  3|  c[3]==(p3+p2+p6)%4  |
| 4 |c[4]==(p1+p4+p5+p7)%4    |
|  5|  c[5]==(p1+p3+p5+p7+p9)%4  |
|  6| c[6]==(p3+p5+p6+p9)%4   |
|  7| c[7]==(p8+p4+p7)%4   |
|  8| c[8]==(p5+p7+p8+p9)%4   |
|  9|   c[9]==(p6+p8+p9)%4 |


------------


# 重点

观察可以发现p4与c[1]-p1-p2可能有一些关系

这些关系可以表示为p4=order（c[1]-p1-p2）

其中order是一个函数

int order(int x)

{

   if(x>=0) return x%4;
   
	else return (x+4*1024)%4;//其中1024可以换成任意一个较大的数
}



#### 同理

p5=order(c[2]-p1-p2-p3);

p6=order(c[3]-p2-p3);
                    
p7=order(c[4]-p1-p4-p5);
                    
p8=order(c[7]-p4-p7);
                    
p9=order(c[9]-p6-p8);

### 解释

order函数的意思就是表示最少还要几次才能到12

当pl=order（c[i]-pj-pk-p..）【表示某一种情况】大于零时说明还没有超过12，pl还需（c[i]-pj-pk-p..）%4次才可以到12

当它小于零时，表示它以超过12已经绕了y圈（y>=1）,所以它需要加上一个4的倍数再去模四，因为假如当它为-1与-5时，钟指针是在同一个地方（返回的数相等）

其实
(x+（4* 1024）)%4=(（4*n+x）+(1024-n)*4)%4=（4*n+x）%4+((1024-n)*4)%4==(4*n+x)%4【因为0<=4*n+x<4，所以才要一个较大的数,也说明了为什么要用这个式子】

#### 所以只要枚举p1，p2，p3就可以表示出所有的情况；


------------


#### 至于如何输出：就是从p1-p9使用几次就输几个


------------


上代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int c[10],j;
int order(int x)//函数本体
{
	if(x>=0) return x%4;
	else return (x+4*1024)%4;
}
int main()
{
	for(int p=1;p<=9;p++)
	{
		cin>>j;
		c[p]=4-(j/3);//得c[1]
	}
	for(int p1=0;p1<=3;p1++)//枚举
	{
		for(int p2=0;p2<=3;p2++)
		{
			for(int p3=0;p3<=3;p3++)
			{
					int p4=order(c[1]-p1-p2);//得出其他数据
					int p5=order(c[2]-p1-p2-p3);
					int p6=order(c[3]-p2-p3);
					int p7=order(c[4]-p1-p4-p5);
					int p8=order(c[7]-p4-p7);
					int p9=order(c[9]-p6-p8);
				if(c[1]==(p1+p2+p4)%4&&c[2]==(p1+p2+p3+p5)%4&&c[3]==(p3+p2+p6)%4&&c[4]==(p1+p4+p5+p7)%4&&
				c[5]==(p1+p3+p5+p7+p9)%4&&c[6]==(p3+p5+p6+p9)%4&&c[7]==(p8+p4+p7)%4&&c[8]==(p5+p7+p8+p9)%4&&
				c[9]==(p6+p8+p9)%4)//判断
				{
					for(int p=1;p<=p1;p++) cout<<1<<' ';
					for(int p=1;p<=p2;p++) cout<<2<<' ';
					for(int p=1;p<=p3;p++) cout<<3<<' ';
					for(int p=1;p<=p4;p++) cout<<4<<' ';
					for(int p=1;p<=p5;p++) cout<<5<<' ';
					for(int p=1;p<=p6;p++) cout<<6<<' ';
					for(int p=1;p<=p7;p++) cout<<7<<' ';
					for(int p=1;p<=p8;p++) cout<<8<<' ';
					for(int p=1;p<=p9;p++) cout<<9<<' ';//输出
					return 0;
				}
			}
		}
	}
    return 0；
}
```

                    