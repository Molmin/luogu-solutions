~~Codeforces 紫题现状~~

先补充一点，这道题还有一个前提翻译里没有给出来，就是**数列中所有的数以及任意一个修改完以后的数必须为整数**

**这道题就是让你求出修改一个整数以后这个数列能得到的严格递增子段的最大值。**

首先易知修改肯定比不修改要更优

那枚举修改位置 $i$

对于每个位置，分两类情况讨论：

第一种，修改完后的 $a_i$ 能够与以 $a_{i-1}$ 为结尾的严格递增子段**和**以 $a_{i+1}$ 为起始的严格递增字段共同构成一个严格递增子段。形式化的描述，即 $a_{i+1}-a_{i-1}>1$。

第二种，修改完后的 $a_i$ 无论如何都无法构成上述讨论中的匹配，仅能与以 $a_{i-1}$ 为结尾的严格递增子段**或**以 $a_{i+1}$ 为起始的严格递增子段共同构成一个严格递增子段。形式化地描述，即 $a_{i+1}-a_{i-1} \leq 1$。（这里注意，如果 $a_{i-1}$ 与 $a_{i+1}$ 仅满足 $a_{i-1}<a_{i+1}$ 是不一定可以将两个字段连接在一起的，感性地说，如果这两个元素中间没有足够的缝隙使修改后的 $a_i$ 插入进去的话同样不能完成讨论 1 中的构造。这一情况建立在我补充的前提的基础上提出。）

接下来是预处理部分。

设 $f1_i$ 表示以 $a_i$ 为结尾的严格递增子段的最长长度，$f2_i$ 表示已 $a_i$ 为起始的严格递增子段的最长长度，那么有状态转移方程
$$
f1_i=\begin{cases}f1_{i-1}+1&a_{i-1}<a_i\\1&a_{i-1} \geq a_i\end{cases}
$$

其中 $f1_1=1$

$$
f2_i=\begin{cases}f2_{i+1}+1&a_i<a_{i+1}\\1&a_i \geq a_{i+1}\end{cases}
$$
其中 $f2_n=1$

那么，如果修改 $a_i$，如果满足讨论 1，则修改后含 $a_i$ 的最长严格递增子段为 $f1_{i-1}+f2_{i+1}+1$；反之则满足讨论 2，则修改后含 $a_i$ 的最长严格递增子段为 $\max(f1_{i-1}+1,f2_{i+1}+1)$。修改 $a_1$ 和修改 $a_n$ 需要特判。

这样，我们就能用 $O(1)$ 的时间处理修改每个位置所对应的的严格递增子段的长度，最后将它们取最大值即可。

代码

```cpp
#include <bits/stdc++.h>
using namespace std;

inline int read() {
    int s = 0;
    char ch = getchar();
    while (ch < 48 || ch > 57) {
        ch = getchar();
    }
    while (ch > 47 && ch < 58) {
        s = (s << 3) + (s << 1) + ch - 48;
        ch = getchar();
    }
    return s;
}

int n, ans, a[100015], f1[100015], f2[100015];

int main(void) {
    n = read();
    for (register int i = 1; i <= n; i++) {
        a[i] = read();
    }
    f1[1] = 1; // 预处理
    for (register int i = 2; i <= n; i++) {
        f1[i] = a[i] > a[i - 1] ? f1[i - 1] + 1 : 1;
    }
    f2[n] = 1;
    for (register int i = n - 1; i > 0; i--) {
        f2[i] = a[i] < a[i + 1] ? f2[i + 1] + 1 : 1;
    }
    ans = max(ans, f2[2] + 1);
    for (register int i = 2; i < n; i++) { // 枚举位置分类讨论并更新 ans
        if (a[i + 1] - a[i - 1] > 1) {
            ans = max(ans, f1[i - 1] + 1 + f2[i + 1]);
        }
        else {
            ans = max(ans, max(f1[i - 1] + 1, f2[i + 1] + 1));
        }
    }
    ans = max(ans, f1[n - 1] + 1);
    printf("%d", ans);
    return 0;
}

```

时间复杂度为 $O(n)$，空间复杂度为 $O(n)$。