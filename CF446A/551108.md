### 题目大意

给一个序列 $a$，求最多更改一个数字后，求最长的严格递增子段的长度。

### 题目分析

由于可以更改一个数字，我们可以视为最终的严格递增子段是由两个子段拼接而成的。

于是我们可以枚举断点 $\forall i \in [1,n]$，以这个点为断点,修改这个点后，如果左右最长的严格递增子段可以拼起来，以这个点为断点的最长的严格递增子段长度为左右最长的严格递增子段长度和 $+1$。如果不能，以这个点为断点的最长的严格递增子段长度为左右最长的严格递增子段长度的较大值。

上述方法的时间复杂度为 $O(n^2)$，很明显过不了。

我们可以用 $O(n)$ 的时间，求出以点 $i$ 结尾的最长严格递增子段 $f_i$，再求出以 $i$ 开头的最长严格递增子段 $g_i$，这个可以视为，从右到左以 $i$ 结尾的最长严格下降子段。

然后用 $O(n)$ 的时间求出以 $i$ 为断点的最长的严格递增子段长度（式子如上思路）。最后求所有断点答案的最大值。

最后总的时间效率为 $O(n)$。

### code
```cpp
#include <iostream>
#include <cstdio>
using namespace std;
const int N = 1e5 + 5;
int n, a[N], f[N], g[N], ans;
signed main()
{
	cin >> n;
	for(int i = 1;i <= n;i++)
		cin >> a[i];
	for(int i = 1;i <= n;i++)
	{
		if(a[i] > a[i-1])
			f[i] = f[i - 1] + 1;
		else
			f[i] = 1;
	}
	for(int i = n;i >= 1;i--)
	{
		if(a[i] < a[i+1])
			g[i] = g[i + 1] + 1;
		else
			g[i] = 1;
	}
	for(int i = 1;i <= n;i++)
	{
		if(a[i+1] - a[i-1] > 1)
			ans = max(ans, f[i-1] + g[i+1] + 1);
		else
			ans = max(ans, max(f[i - 1], g[i + 1]) + 1);
	}
	cout << ans;
	return 0;
}

```