# 一、阶段
阶段不难看出是从 $1$ 到 $n$ 枚举每一位改不改变。
# 二、状态
我们用 $f1_i$ 表示以 $a_i$ 为结尾的最长上升子串，用 $f2_i$ 表示以 $a_i$ 开头的最长上升子串。注意，和子序列不同，子串必须是连续的一串。
# 三、策略
如果我们使前后两个子串能连接，则当前的长度为以 $a_i-1$ 为结尾的最长上升子串的长度加上以 $a_i+1$ 为开头的最长上升子串的长度加上 $a_i$ 本身为 $1$ 的长度，即 $f1_{i-1}+1+f2_{i+1}$。当然，由于序列中的全是自然数，所以相邻两数之差最小为 $1$，即 $a_i-a_{i-1}\geqslant1$，故 $a_{i+1}-a_{i-1}\geqslant2$ 时才可以改动 $a_i$。

否则当前的长度为以 $a_{i-1}$ 为结尾的最长上升子串的长度和以 $a_{i+1}$ 为开头的最长上升子串的长度的最大值，即 $\max(f1_{i-1},f2_{i+1})+1$。
# 四、代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[100005],f1[100005],f2[100005],n,ans=1;
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&a[i]);
		f1[i]=f2[i]=1;//初始化
	}
	for(int i=2;i<=n;i++)//f1[i]为以i结尾的最长上升子串 
	{
		f1[i]=a[i]>a[i-1]?f1[i-1]+1:f1[i];
	}
	for(int i=n-1;i>0;i--)//f2[i]为以i开头的最长上升子串 
	{
		f2[i]=a[i]<a[i+1]?f2[i+1]+1:f2[i];
	}
	for(int i=2;i<n;i++)
	{
		if(a[i-1]<a[i+1]-1)//能连接，a[i-1]<a[i+1]-1
		{
			ans=max(f1[i-1]+f2[i+1]+1,ans);
		}
		else//不能连接
		{
			ans=max(ans,max(f1[i-1],f2[i+1])+1);
		}
	}
	ans=max(ans,max(f1[n-1],f2[2])+1);//补上1和n的方案 
	printf("%d\n",ans);
	return 0;
}
```
