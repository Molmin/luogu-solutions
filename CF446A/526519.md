今天的月赛签到题和这个重题了，赛后 AC 的代码被 hack 了所以来搞一下这道题目。

思路其实并不难，我们看到题目里面只需要我们修改一个数字，所以我们可以直接考虑一下如何让收益最大化。

分成两种情况：

1. 当前点修改后与前面的点形成一个严格递增的序列，但是和后面的不会接起来。

2. 当前点修改后可以与前后的点形成严格递增的序列，也就是比如 `1 3 4 1 9 10` 这种的，很显然修改第四个数就可以使序列最长为 $6$。

这时候我们要是一个一个遍历差修改后的序列长度的话肯定是会 TLE 的，所以我们考虑预处理一下以每一个数字为左端和右端的严格递增序列的最大长度，在判断第一种情况的时候，比如当前点为 $i$，我们可以直接用 $l_{i-1}+1$ 来表示修改后的此序列的长度；第二种情况我们需要先判断 $i$ 左右两个数的大小，因为都是整数，所以 $i$ 右边那个数至少比左边那个数大 $2$。

code：

```cpp
#include<bits/stdc++.h>
#define N 1001000 
using namespace std;
int n,a[N],l[N],r[N],ans; 
signed main()
{
	cin>>n;
	l[1]=1,r[n]=1;
	for(int i=1;i<=n;i++)
		cin>>a[i];
	for(int i=2;i<=n;i++)
	{
		if(a[i]>a[i-1])
		  l[i]=l[i-1]+1;
		else l[i]=1;
	}
	for(int i=n-1;i>=1;i--)
	{
		if(a[i]<a[i+1])
		  r[i]=r[i+1]+1;
		else r[i]=1;
	}
	for(int i=1;i<=n;i++)
	{
		ans=max(ans,max(l[i-1]+1,r[i+1]+1));
		if(a[i-1]<a[i+1]-1)
		  ans=max(ans,l[i-1]+1+r[i+1]);
	}
	cout<<ans<<endl;
	return 0;
 } 
 ```