## 01. 题目大意
给一个长度为 $n$ 的序列 $a$，定义$a_i,a_{i+1},a_{i+2}, \cdots,a_j$ 的长度为 $j-i+1$，其中 $1\leqslant i \leqslant j \leqslant n$，你可以最多更改一个数字，求最长的严格递增子段。

## 02. 题目分析
这道题看到之后就觉得可以使用一个三维数组 $f_{i. j. k}$ 来表示状态。其中这个三维数组第一个数表示前 $i$ 个数，第二个数表示是否用掉第 $i$ 个，第三个数表示是否和以前的相连的最长长度。

这样我们就分为两种情况：

当 $a_{i-1} < a_i$ 时，
$$f_{i,0,0} = \max(f_{i,0,0}, f_{i-1,0,0} + 1)$$
$$f_{i,1,0} = \max(f_{i,1,0}, f_{i-1,1,0} + 1)$$
$$f_{i,1,1} = \max(f_{i,1,1}, f_{i-1,0,0} + 1)$$

当 $a_{i-1} > a_i$ 时，
$$f_{i,1,1} = \max(f_{i,1,1}, f_{i-1,0,0} + 1)$$

之后

最后只需要输出 $\max(\max(\max(ans, f_{i,0,0}), f_{i,1,0}), f_{i,1,1})$ 就行了。

## 03. 参考代码
```cpp
#include <bits/stdc++.h>
using namespace std;

const int NR = 1e5 + 10;
int a[NR], f[NR][3][3]; //定义三维数组，f[100010][3][3]就够了

int main()
{
	int n, ans = 0;
	cin >> n;
	for (int i = 1; i <= n; i++)
	{
		cin >> a[i];
	}
	for (int i = 1; i <= n; i++)
	{
		f[i][0][0] = 1;
		f[i][1][1] = 1; //初始化
		if(!(i == 1))
		{
			f[i][1][0] = 2;
		}
		if(a[i - 1] < a[i])
		{
			f[i][0][0] = max(f[i][0][0], f[i - 1][0][0] + 1);
			f[i][1][0] = max(f[i][1][0], f[i - 1][1][0] + 1);
			f[i][1][1] = max(f[i][1][1], f[i - 1][0][0] + 1); //第一种情况
		}
		else
		{
			f[i][1][1] = max(f[i][1][1], f[i - 1][0][0] + 1); //第二种情况
		}
		if ((a[i - 2] + 1 < a[i]) && i != 1)
		{
			f[i][1][0] = max(f[i][1][0], f[i - 1][1][1] + 1);
		}
		ans = max(max(max(ans, f[i][0][0]), f[i][1][0]), f[i][1][1]); //输出最后的ans值
	}
	cout << ans << endl; //完结撒花~
}
```
