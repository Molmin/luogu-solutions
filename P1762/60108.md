#### ~~这题可能是考我的取模能力~~

本题只考虑奇偶性，我们可以用1表示奇数，用0表示偶数打表。

观察前十六行

```cpp
1
1 1
1 0 1
1 1 1 1
1 0 0 0 1
1 1 0 0 1 1
1 0 1 0 1 0 1
1 1 1 1 1 1 1 1
1 0 0 0 0 0 0 0 1
1 1 0 0 0 0 0 0 1 1
1 0 1 0 0 0 0 0 1 0 1
1 1 1 1 0 0 0 0 1 1 1 1 
1 0 0 0 1 0 0 0 1 0 0 0 1
1 1 0 0 1 1 0 0 1 1 0 0 1 1
1 0 1 0 1 0 1 0 1 0 1 0 1 0 1
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1

```

发现这是一个分形图，分型图都能用递归解决。

对于 $2^k$ 行，可直接递归计算：
分成三个 $2^{k-1}$ 行和一个中间大三角形
例如当 $k = 3$
```cpp
1
1 1
1 0 1
1 1 1 1
1 0 0 0 1
1 1 0 0 1 1
1 0 1 0 1 0 1
1 1 1 1 1 1 1 1
分成
1
1 1
1 0 1
1 1 1 1

0 0 0 
  0 0
    0
```

对于其余的行$n$，找到一个小于$n$的最大的$2^k$，分别计算前$2^k$行和$2^k$ ~ $n$行中的零。
对于 $2^k$ ~ $n$行，也可以换成两个小三角形和一个梯形，在此不多赘述，详见代码

给一个不带取模的递归函数


```cpp
ll work(ll n){
    if(n <= 2) return 0;
    if(n == 3) return 1;
    if(n == 4) return 1;
    ll now = 4;
    while((now<<1) <= n) now <<= 1;
    ll rest = ((2 * now - n) + (now - 1)) * (n - now) / 2;
    return (work(now / 2) * 3 + (now / 2) * (now / 2 - 1) / 2) + work((n - now)) * 2 + rest;
}
```

最后该取模的取模，该换逆元的换逆元，搞定。
