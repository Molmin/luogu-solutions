# 思路
**给大家带来一种最快的解法**

首先简化一下问题：如果**允许**出现相同字母，该怎么解呢？

答案很简单：先判断第一位字母，确定一个取值范围，再看第二个字母......一直看到在最后一位字母即可。

举个例子：设字符串 $s=abedb$，$a$ 的长度为 $n$，则在**允许相同**的情况下：
- 通过 $a_1$ 判断答案在 $0\sim624$ 之间；
- 通过 $a_2$ 判断答案在 $125\sim249$ 之间；
- 通过 $a_3$ 判断答案在 $225\sim249$ 之间；
- 通过 $a_4$ 判断答案在 $240\sim244$ 之间；
- 通过 $a_5$ 判断答案在 $241\sim241$ 之间；

答案即为 $241$。

---------------

如果不允许重复呢？

如果是不允许的话，则一个字母若是字母表中的第 $x$ 个，则他只能取**字母表空缺位置中的第 $x$ 个**。就比如如果一个字母为 `D` ，其中 `B` 已经被占了，所以 `B` 这个位置就不是空缺位置。`D` 的实际位置应为 `E` 。

那该如何从输入的字符串中获取在**允许**的情况下的字符串呢？

因为在一个字母若是字母表中的第 $x$ 个，它占到自己的**实际位置**之后会在它前面留下 $x-1$ 个空位。所以只需判断它后面有多少个字母比它小即可。**最后不用加上一，因为第一项是 $0$**。
# AC code
```cpp
#include<bits/stdc++.h>
using namespace std;

long long jc[27]={1},b[27];

void problem_jc()
{
	for(int i=1;i<27;i++)jc[i]=jc[i-1]*i;//初始化。注意第i位要乘上i，因为每往后一位选择都要少一。
    //注意这种写法最后必须倒过来用。
}

int main()
{
	problem_jc();
	char a[26];
	cin>>a;
	for(int i=strlen(a)-2;i>=0;i--)
	{
		for(int j=i+1;j<strlen(a);j++)
		{
			if(a[i]>a[j])b[i]++;//得出允许时的字符串。
		}
	}
	long long num=0;
	for(int i=0;i<strlen(a)-1;i++)
	{
		num+=(b[i])*jc[strlen(a)-1-i];
	}
	cout<<num;
	return 0;
}
```