## 思路
利用康托展开进行求解。

依次考虑每一位，统计已经跳过的排列数量。对于当前位，依次考虑每个可以使用的数。如果当前数小于排列中的数，则累加对应的排列数量。跳过 $x$ 个排列，当前排列是第 $x$ 小的排列。

举个栗子（以下数字 1 对应字母 a，数字 2 对应字母 b，依此类推）：

第 $67$ 小的排列是 $[3, 5, 1, 4, 2]$。

| 序号 | 1 | 2 | 3 | 4 | 5 |
| :--------- | :--------- | :-------- | :-------- | :-------- | :-------- |
| 可用数字 | 12**3**45 $~$ | 124**5** $~$ | **1**24 $~$ | 2**4** $~$ | **2** $~$ |
| 包含排列数 $~$| 24 | 6 | 2 | 1 | 1 |
| 跳过数字数 $~$| 2 | 3 | 0 | 1 | 0 |
| 跳过排列数 $~$| 48 | 66 | 66 | 67 | 67 |

每一位跳过数值的数量就构成了排列进制数，
跳过排列的总和就是排列编号。
## CODE
```cpp
#include <algorithm>
#include <iostream>

using namespace std;

const int kMaxN = 13;

int v[kMaxN];
bool b[kMaxN];
int n, x, s;
string a;

int main() {
  cin >> a;
  v[0] = 1, n = a.size();
  for (int i = 1; i < n; i++) {     // 计算阶乘
    v[i] = v[i - 1] * i;
  }
  for (int i = n - 1; i >= 0; i--) {// 枚举每一位
    x = a[n - i - 1] - 'a' + 1;
    for (int j = 1; j < x; j++) {   // 枚举每个数
      s += !b[j] * v[i];            // 未用的数则累加数量    
    }
    b[x] = 1;  // 标记使用
  }
  cout << s;
  return 0;
}
```