考虑枚举一个点集 $S$，表示钦定 $V\setminus S$ 的点为叶子，计算出方案数，那么答案就是对其执行 IFMT 的结果。

要计算这个，可知只需算出 $S$ 的导出子图的生成树个数，然后为每个 $V\setminus S$ 中的点选择一条连向 $S$ 中的边即可。  
后者只需 $O(n 2^n)$，现在我们来说明前者可以做到 $O(n^2 2^n)$。

考虑枚举 $k=1,\dots,n$，依次计算所有 $S \subseteq \{1,\dots,k\}$ 的答案。  
考虑每次加入一个点 $k+1$，对于 $S \subseteq \{1,\dots,k\}$，我们考虑如何在其中加入 $k+1$。  
自然只需枚举断开 $k+1$ 后会构成哪些连通块，不难发现这就是一个集合幂级数的 exp 操作。

核心代码（执行完后 $f_S$ 为 $S$ 导出子图的生成树个数，$e_u$ 为邻接矩阵，$\exp$ 表示将 $f_{2^k,\dots,2^{k+1}-1}$ 原地 $\exp$）：
```cpp
f[0] = 1;
for (int k = 0; k < lg; ++k) {
  for (int i = 0; i < (1 << k); ++i) f[i + (1 << k)] = (ll)f[i] * popcnt(e[k] & i) % mod;
  Set::exp(f + (1 << k), f + (1 << k), k);
}
```

时间复杂度由 $T(n) = T(n-1) + O(n^2 2^n)$ 得到，为 $O(n^2 2^n)$。  
从而这也叫做**逐点牛顿迭代法**。