看出来是个贪心。但是想错贪心方法了导致很快就把自己做法叉了。

以 $1$ 为根。显然如果存在路径上面只有两个点，那么答案就是 $-1$。否则，注意到一个性质，如果我们选了 $1$，那么所有非祖先-后代链就都会消失。因此我们先考虑处理只有祖先-后代链的情况，那么剩余的非祖先-后代链可以用 $\le 1$ 次操作搞掉。考虑如何处理祖先-后代链，假设 $dep_u<dep_v$，记 $w$ 为 $u\to v$ 路径上第一个点，那么我们只要操作 $w$ 子树内 $-$ $v$ 子树内任何一个点就可以搞掉这条路径。那么如何贪心呢？我们考虑找到当前时刻没有被覆盖的路径中 $w$ 深度最大的那一个，显然对于这样的路径，覆盖 $w$ 是最优的，选择了 $w$，就会进一步覆盖掉更多的路径，以此类推。使用 BIT 维护这个贪心即可。这样我们就解决了只有祖先-后代链的情况。

接下来考虑有非祖先-后代链的情况。有一个结论：此时如果所有非祖先-后代链都被覆盖，那么此时选的点的个数就是答案，否则直接令答案加一即可。我们考虑将所有祖先-后代链按 $w$ 的深度从小到大排序，那么我们选择的 $w$ 一定是字典序最小的组，即，如果在这个条件下，还存在一个非祖先-后代链，满足我们选择的点都在这个非祖先-后代链的端点的子树内，那么我们也无法通过将某些点调整为深度更小的点使其覆盖这个祖先-后代链。因此这个结论是正确的。

时间复杂度 $n\log n$。