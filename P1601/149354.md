##### 输入别用gets！！！   
#### 输入别用gets！！！   
### 输入别用gets！！！   
为啥？因为gets会把回车读进去呗！   
___  
___   

我们先来分析一下下~   
看到如此之大的A、B（501位），我们千万别傻乎乎地搞cout<<a+b; ~   
那么，我们肿么瓣？   
那就是传说中的字符串！   
我们可以把数看成字符串   
把字符串转化成数组（因为处理起来简单）   
再把同一位的两个数字对齐   
像做加法竖式一样加起来。   
#### 注意！  
###### 加法计算时相同数位对齐，若和超过10，则向前进1。   
所以我们把数位对齐……   
问题来了，怎么对齐？
那就是加前辍0！   
加前辍0的话（1234+32=1266）（对位有点不齐，请原谅）：   
                        1 2 3 4  
+0 0 3 2   
——————   
   1 2 6 6   
不加前辍0（1234+32=4434?）：   
                                                                   1 2 3 4  
+3 2   
——————   
   4 4 3 4   
（当然不加也可以，只不过复杂一点）   
再考虑一下进位就可以啦！
```cpp
#include<bits/stdc++.h>
using namespace std;
char sa[505],sb[505];//输入的两个字符串
int a[505],b[505];//转化成的数组
int f[505];//记录和
int main()
{
    scanf("%s%s",sa,sb);//别用gets！别用gets！别用gets！
    int ax=strlen(sa),bx=strlen(sb),d=max(ax,bx);
    int i,j;
    for(i=ax-1,j=0;i>=0;i--,j++)//反向转化，便于进位
        a[j]=sa[i]-48;
    for(;j<d;j++)//加前辍0
        a[j]=0;
    for(i=bx-1,j=0;i>=0;i--,j++)
        b[j]=sb[i]-48;
    for(;j<d;j++)
        b[j]=0;
    int bilibili=0;//进位变量
    for(int i=0;i<d;i++)
    {
        f[i]=(a[i]+b[i]+bilibili)%10;//记录个位
        bilibili=(a[i]+b[i]+bilibili)/10;//进位
    }
    if(bilibili==1)//最高位是否进位
        cout<<1;//输出最高位的1
    for(int i=d-1;i>=0;i--)//输出
        cout<<f[i];
    return 0;
}
```
