# 新-高精度

我们将输入的数每15位就被储存一次，再对这15位相加。若加完后是16位，则将数组下一个位置的数+1，然后这个数  %=$10^{16}$，这样，一个更高级的算法就完了！

这样来做，对于500（$10^{500}$）位的数字，最多会加33次，数组最大是34位！是不是比500少多了呢？

---

For example(15位拆分)
```cpp
Input 111222222222222222333333333333333

拆分后：
a[1]=333333333333333
a[2]=222222222222222
a[3]=111
```

---

For example(拆分后的加法)
```cpp
拆分后的数字1：
a[1]=333333333333333
a[2]=222222222222222
a[3]=111

拆分后的数字2：
b[1]=123456789111111
b[2]=888888888888888
b[3]=3589

c[1]=a[1]+b[1]
c[1]=456790122444444
因为c[1]在15位以内，所以不进位

c[2]=a[2]+b[2]
c[2]=1111111111111110
因为c[2]超过了15位，进位

c[3]=a[3]+b[3]+1  (c[2]有进位)
c[3]=3701

那么最终答案就是从c[3]输出到c[1]。
其中不够15位的要补0！
```

代码如下，更详细的讲解在代码中（~~代码不好看，将就将就吧~~）：

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<string>
#include<cmath>

typedef long long LL;   //define同样效果 

using namespace std;

const LL pow15=999999999999999;  //超过这个数就要进位！！ 
const LL pow10[18]={1,1,10,100,1000,10000,100000,1000000,10000000,100000000,1000000000,10000000000,100000000000,1000000000000,10000000000000,100000000000000,1000000000000000};
//一些预处理着实会节省一些时间 

LL a[37],lena=1,b[37],lenb=1,c[38],lenc;  //a数组-加数1，b数组-加数2，c数组-加数3 
char in1[900],in2[900];   //读入两个数 

void exread(char in[900],LL d[35],LL &len){   //15位拆分！ 
	LL cnt=0;
	LL lenn=strlen(in)-1;
	while(in[lenn]!='\n'&&in[lenn]!='\r'&&lenn>=0){   //要注意，数据可能是在windows环境下造的，windows是'\r\n'，不要把'\r'也看成数组 
		if(in[lenn]==' '){   //处理数据的恶心情况--空格 
			lenn--;continue;
		}
		cnt++;
		if(cnt>15)cnt=1,len++;
		d[len]=d[len]+(in[lenn]-'0')*pow10[cnt];   //这时候，预处理就显得很有帮助 
		lenn--;
	}
}

void print(long long x){    //快输，想要就复制走 
	if(x>=10)print(x/10);
	putchar(x%10+'0');
}

int main(){
	scanf("%s",in1);    //哎，洛谷总是与gets()过意不去。。。 
	scanf("%s",in2);
	exread(in1,a,lena);
	exread(in2,b,lenb);
	
	lenc=max(lena,lenb);
	for(LL i=1,j=1,k=1;i<=lena||j<=lenb;i=(i==lena+1 ? lena+1:i+1),j=(j==lenb+1 ? j+1:j+1),k++){
	//后来发现，这个for应该这么写：
	//for(LL i=1;i<=max(lena,lenb);i++)
	//写麻烦了... 
	//不过顺便一提，三目运算符很重要！！！ 
		
		c[k]+=a[i]+b[j];
		if(c[k]>pow15){   //处理进位 
			c[k+1]+=(c[k]/(pow15+1));   //因为要使数变成10^16。 
			c[k]%=(pow15+1);   //同理 
		}
	}
	if(c[lenc+1]!=0)lenc++;    //如果最后有进位一定要加上，(a+b)的位数不会超过max(|a|,|b|)+1,（|a|表示a的位数） 
	print(c[lenc]);    //首次输出没必要补0 
	for(LL i=lenc-1;i>=1;i--){    //输出后(lenc-1)*15位 
		for(LL j=15;j>=1;j--){    //补0 
			if((LL)(c[i]/pow10[j])==0)putchar('0');   //预处理派上了用场！ 
			else break;
		}
		if(c[i]!=0)print(c[i]);    //如果这15位本身就为0，那么上面已经补完0，没必要输出 
	}
	return 0;   //华丽的结束！ 
}
```

## PS:
 - 灵感来源于位运算（~~可见位运算的重要性~~）
 - 这种方法在位数<30位的时候优势更明显！
 - 高精乘法这种方法同样适用！
 
---

听说NOIP前发题解会rp++???

#### [配合博客食用更佳](https://www.luogu.org/blog/aldrich-7-17-start/#)