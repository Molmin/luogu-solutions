这是第一个笔者正经学习的算法。

众所周知C++的int类型能够储存的数字是有限的,所以有时运算的数过大时会出现溢出的情况导致运算结果错误。C++还可以用long和long long两种类型直接储存比int更大的数字,但如果就算用long long做运算也会溢出该怎么办呢?这时就需要高精度算法了。

解决这种问题的方法可能有多种,笔者用的方法是模拟竖式计算:先用char[] (即char类型数组)储存输入的数字,每个数组元素储存一位数字,然后对储存的两个char[]逐位进行计算,计算结果也用char[]储存。

比如下面是笔者今天刚写的高精度加法程序(已通过洛咕[P1601](https://www.luogu.org/problemnew/show/P1601)):

```cpp
#include<cstdio>
#include<cstring>
using namespace std;

char r[505];  //r[]用来以字符的形式储存读入的数字
int a[505], b[505], c[505];
//将r[]中的各位字符经处理后存入a[]和b[]
//运算结果存入c[]
int cn;       //cn用来记录最高运算到了第几位

int main() {
    scanf("%s", r);
    a[0] = strlen(r);    //a[0]用来储存a[]表示的数字是几位数
    for (int i = a[0] - 1; i >= 0; i--)  a[a[0] - i] = r[i] - '0';
    //上面这个for循环将r[]各位的字符转换为数字后倒序储存在a[]中
    scanf("%s", r);
    b[0] = strlen(r);    //b[0]与a[0]同理
    for (int i = b[0] - 1; i >= 0; i--)  b[b[0] - i] = r[i] - '0';
    //上面这个for循环与前面的for循环同理
    //下面这个for循环将对a[]和b[]逐位计算得到结果并放入c[]中
    for (c[0] = 1; c[0] <= a[0] || c[0] <= b[0]; c[0]++) {
        register int n = c[0]; cn = n; 
        //c[0]用来储存现在运算到了第几位
        //为方便编写和理解,用n来暂时储存c[0]的值
        //并将n声明为寄存器变量提高效率
        c[n] += a[n] + b[n];//此句完成在c[n]这一位上的加法运算
        if (c[n] >= 10) {   //如果c[n]>=10则进位
            c[n + 1]++;
            c[n] -= 10;
            if (n + 1 > a[0] && n + 1 > b[0]) {  
                //特判,若进位后的数字的位数大于输入的两个数位数
                //则cn++防止程序少输出一位数字
                cn++;
            }
        }
    }
    for (int i = cn; i > 0; i--)  printf("%d", c[i]);//输出
    return 0;
}
```

（今天还写了个高精度减法程序,本来想和这个放在一起的不过突然想试试发题解,所以放在soon后的文章里）

~~(本蒟蒻的程序和题解里的其他C++程序相比应该算是比较简短的吧 求过)~~