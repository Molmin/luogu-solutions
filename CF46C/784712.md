这道题主要是把 H 和 T（黑和白）用最少的次数给分开。
 
首先是输入，并且统计 H（黑）的个数（输入和统计）：
```cpp
	cin>>n;
	if(n<=3) cout<<"0",exit(0);
        //其实n<=3就能直接得出答案，exit(0)就是return 0;
	for(int i=1;i<=n;i++)
	{
		cin>>a[i];
		if(a[i]=='H') k++;
	}
```

题目中给了我们一个环，但用环作比较麻烦，所以可以把环变成链，这样就比较方便；分析样例后，发现可以用前缀和的方法做，于是就得出了以下代码（建链和前缀和）：
```cpp
	for(int i=n+1;i<n+k;i++) a[i]=a[(i-1)%n+1];
	for(int i=1;i<n+k;i++)
	{
		if(a[i]=='H') s[i]=++s[i-1];//先加后用
		else s[i]=s[i-1];
	}
```
但是，要用最少的次数，那就要求出最长一段的 H 的个数,代码如下：
```cpp
	for(int i=1;i<=n;i++) m=max(m,s[i+k-1]-s[i-1]);
```
最后，在输出答案就行了：
```cpp
	cout<<k-m;
```