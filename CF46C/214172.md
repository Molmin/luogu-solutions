[可能更好的阅读体验](https://www.luogu.com.cn/blog/woeeeeee/solution-cf46c)

看到本题仅有的一篇题解解释的不太详细，我来详细说明一下思路吧。

## 题目解读

**①字符串是环形，要求黑点全部连在一起**

也就是说，只要把所有的黑点都移到中间，或者将所有的黑点分布在两边，即满足题意。

∴ `TT…THH…HTT…T` 和 `HH…HTT…THH…H` 都满足题目要求。

不难发现，题目中的要求是让我们把白点**或**黑点移到中间连成一整串。

**②每次可以交换任意两个点的位置**

也就是说，要将中间多出来的黑点 / 白点移出去，要满足想要移出去的黑点 / 白点和串外面的白点 / 黑点**一样多**。

自然可以想到前缀和。

**③** $2 \leq n \leq 1000$

明示 $n^2$ 算法。

## 具体实现

我们可以定义两个数组，一个数组记录到 $a_i$ 位置时 `H` 的个数，另一个记录到 $a_i$ 位置时 `T` 的个数。

按照 ② 中提供的解读，套一个两层循环（作为串两端的位置），依次判断串内部的 `T` 或者 `H` 是否跟串外部的 `H` 和 `T` 一样多（因为只有这样才能将串内部的 `H / T` 点移干净），每次取 $\min$ 即可。

## 细节

- 串内部 `H / T` 的个数可以由 $a_j - a_i$ 算得（这样就只需要开2个数组了）。

- 两端 `H / T` 的个数可以由 总数 减去 串内部的个数 算得。

- 注意最后答案比较大小前的初值不能为 `0` （ `2147483647` 欢迎您 ）。

### 代码（含注释）
```
#include <bits/stdc++.h>//万能头
using namespace std;
int a_H[1005];
int a_T[1005];//记录当前位置，H 和 T 的个数
int main()
{
	int n;
	cin>>n;//打酱油的n
    string a;
	cin>>a;
	int ansT=0,ansH=0;//记录 H / T 的总数
	if(a[0]=='T') a_T[0]=1,ansT++;
	else a_H[0]=1,ansH++;//第一位特判
	for(int i=1;i<a.size();i++)
		if(a[i]=='T')
			a_T[i]=a_T[i-1]+1,a_H[i]=a_H[i-1],ansT++;
		else
			a_H[i]=a_H[i-1]+1,a_T[i]=a_T[i-1],ansH++;//前缀和记录
	int ans=2147483647;//ans值初始化
	for(int i=0;i<a.size();i++)
		for(int j=a.size()-1;j>=0;j--)
			if(i<=j)//串的两端不能反
			{
				int T1=a_T[j]-a_T[i];//串内部T的个数
				int T2=ansT-T1;//串两端T的个数
				int H1=a_H[j]-a_H[i];//串内部H的个数
				int H2=ansH-H1;//串两端H的个数
				if(T1==H2)//H连成一串
					ans=min(ans,T1);
				if(T2==H1)//T连成一串
					ans=min(ans,H1);
			}
	cout<<ans<<endl;//打擂台，输出
    return 0;//完结撒花
}
```
$dalao$ 们，点个赞再走呗~