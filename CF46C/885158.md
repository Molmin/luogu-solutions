## 题目意思

给你个环，环上有 $n$ 个点，每个点为黑色 $h$ 或白色 $t$ ，你每次可以交换两个点的位置，要使得黑点连续，中间没有白点，求最少交换次数。

## 解题思路

我们用前缀和来做这道题，

因为在最后转换完成的时候肯定会有一串连续的 $h$  ，因此我们在最开始的时候，只需要找到一段长度为 $h$ 的总数量的连续序列，但记住一定要使得在这串数列中 $h$ 的数量是最多的，然后再用 $h$ 的总数量减掉这串数列中 $h$ 的数量就好啦。

既然我们已经知道了方法，所以我们要先算出 $h$ 也就是仓鼠的数量。然后将环转换成链的形式来算。转换后我们算出前缀和。最后一个循环用来算答案就可以了。

## 代码部分

```
#include<bits/stdc++.h>
using namespace std;
int n,h,ans,sum[10005];char a[100005];//定义变量
int main(){
	cin>>n;//输入
	for(int i=1;i<=n;i++){
		cin>>a[i];
		if(a[i]=='H')//统计h的数量
			h++;
	}
	for(int i=n+1;i<n+h;i++) 
		a[i]=a[(i-1)%n+1];
	for(int i=1;i<n+h;i++) 
		sum[i]=sum[i-1]+(a[i]=='H');
	for(int i=1;i<=n;i++) 
		ans=max(ans,sum[i+h-1]-sum[i-1]);
	cout<<h-ans;
	return 0;
}
```