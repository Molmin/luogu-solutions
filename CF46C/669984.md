## [题 目 传 送 门](https://www.luogu.com.cn/problem/CF46C)

### [题意解析]
给你一个环，在这个环上有 $n$ 个点，点的颜色只有 $2$ 种：$H$ 或者 $T$。你每次可以交换两个点的位置，求最少交换次数使得黑点白点分离。

### [思路分析]
**黑点白点分离**的意思是连续的一段 $H$ 中，没有 $T$。而题目中说给出的数据是一个环形时，我们就要应用一种思想，叫**破环为链**。我们可以 $H$ 做一个前缀和，然后利用前缀和求出连续一段最长的 $H$，最后用整个数列中的 $H$ 的个数减去我们找出的最长 $H$ 的个数就好了。

### **[贴上代码]**

```cpp
#include <bits/stdc++.h>
using namespace std;
char a[100010];
int n,k,ans,s[10010];
int main()
{
	cin>>n>>(a+1);
	for(int i=1; i<=n; i++)
		k+=(a[i]=='H');
	/* H 的总个数*/
	for(int i=n+1; i<n+k; i++)
		a[i]=a[(i-1)%n+1];
	/*破环为链*/
	for(int i=1; i<n+k; i++)
		s[i]=s[i-1]+(a[i]=='H');
	/*前缀和找出各个部分 H 的个数*/
	for(int i=1; i<=n; i++)
		ans=max(ans,s[i+k-1]-s[i-1]);
	/*算出最长一段 H 的个数*/
	cout<<k-ans;
	/*最少交换次数*/
	return 0;
}
```
