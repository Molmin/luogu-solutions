应该算是树形dp的入门题了吧...

上课的时候直接把代码抄下来改了改名字，回家又乱搞半天终于理解这种做法。

树形dp，就是在（二叉）树上~~搞~~做dp。

因为这题保证输入为二叉树（这种做法好像n叉数也可以），所以会方便一些。

我们定义dp[i][j]为保留了i号节点和j条边时最大保留apple数。

为了给大家~~提神醒脑~~巩固基础，我们重复一下以上定义。



#### 我们定义dp[i][j]为保留了i号节点和j条边时最大保留apple数。

（划重点！~~做笔记！~~）

可得dp[1][m]即为答案。

转移方程...不太好想。当时课上完全是懵逼的状态。



枚举子节点nxt，计算这个节点为根的子树的边的个数d

设当前节点为now，已经枚举到了节点nxt，共统计了sum条边，那么转移方程：

dp[now][j]=max(dp[now][j],dp[now][j-k]+dp[nxt][k-1]+w[now][nxt])

(1<=j<=min(d,m),1<=k<=min(d,j),w[now][nxt]代表节点i到j的边的权值)



接下来我们来解释这个方程。

首先，去max是必然。

dp[now][j-k]，为什么是j-k呢？

因为我们枚举了子树的边数k，总边数j。

既然我们的子树已经占去了k条边，留给剩余边的数量自然只剩j-k条了。



接下来是这个dp[nxt][k-1]，为什么是k-1？

这里我们应该将k具体定义一下。

j定义为：目前节点now保留的边数，是没问题的。

k要怎么定义呢？

想一想：



k：nxt节点为根的子树保留的边数再+1(nxt到now这条边)

因为我们的nxt节点的子树的边数只有k-1条，所以dp数组的第二维就是[k-1]



最后，为什么要加上w[now][nxt]?

我们来看一下，dp[now][j-k]中有j-k条边，dp[nxt][k-1]有k-1条边。

两数相加，我们有j-1条边。为什么还差一条边？

就是now~nxt这条边。

那为什么不直接用dp[now][j-k]+dp[nxt][k]?

因为nxt子树并没有k条边......



至此，我们完成了这个dp方程的解析。

（建树方式？你要用邻接矩阵都行啊。）

main code：


```cpp
    int dfs(int now,int fa)
    {
        int d=0;
        for(int i=head[now];i;i=e[i].l)
        {
            int nxt=e[i].t,ow=e[i].v;//nxt为下一个枚举的子树，ow为当前节点与nxt的边的权值
            if(nxt==fa)continue;//如果找到父节点则跳过
            d+=dfs(nxt,now)+1;//计算以now为根的树有几条边
            for(int j=min(d,m);j;--j)//当前节点留j条边
                for(int k=min(d,j);k;--k)//当前子树留k-1条边，加上两点所连的一边
                    dp[now][j]=max(dp[now][j],dp[now][j-k]+dp[nxt][k-1]+ow);
            //子树留k-1条边，当前节点还能再留j-k条边，还有当前节点与枚举的节点边的权值
        }
        return d;
}
```

# #UPD1 (2019/3/16)  
现在重新复习树dp发现打错了。。。  
```dp[i][j]```代表的就是以$i$为根节点的子树中，保留$j$条边的答案  
转移方程为```dp[i][j]=max{dp[son][k]+dp[i][siz-k-1]+v[k][son]}```   
```son为i的子节点,siz为 以i为根的子树所包含的边数```  
```0<=k<siz```