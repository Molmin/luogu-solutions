#### 本弱鸡经过自闭、自我怀疑、心态爆炸等状态以及在看了大佬题解还依旧认为自己是正确的解题思路情况下，发现由于边界问题导致的题一直通不过后，决定写该题的题解。

##### 第二次写题解，写的不好还望各位大佬见谅。

看了题解很多都是用了一些我看不懂的方法/规律去解题，我觉得我的思路还是蛮容易懂得。但是写这道题之前要弄清楚斐波那契数列。

这道题不在是当k=2的情况下，而是k在一定范围内变化，既然当k=2
a[0]=1,a[1]=1,a[2]=2,,,,第i项等于前两项之和。

我们来研究一下当k=3的情况：a[0]=1,a[1]=2,a[3]=3,,,发现第i项等于前3项之和，而a[2]=a[1]+a[0]+1.末尾加上的这个1是由于可以一步跨上3阶台阶。

（由于第i项=前3项之和，所以我们要保证前3项都得存在，所以有了递推的边界）

有了以上的规律发现之后就可以有一个大概的思路：

1、求出a[0]~a[k]

2、用递推式：第i项=前k项之和。

（注意边界、负数）

代码如下：

```cpp
#include <bits/stdc++.h>

using namespace std;
const int maxn=1e5+100;
long long a[maxn];
int mod=100003;

int main()
{
    int n,k,i,j;
    cin>>n>>k;
    a[0]=1;
    for(i=1; i<=k; i++)
    {
        for(j=1; j<=k; j++)
        {
            if(i>j)
            {
                a[i]=(a[i]+a[i-j])%mod;
            }
        }
        a[i]+=1;
    }
    for(i=k+1; i<=n; i++)
    {
        for(j=1; j<=k; j++)
        {
            a[i]=(a[i]+a[i-j])%mod;
        }
    }
    cout<<(a[n]+mod)%mod;
    return 0;
}

```
