# 这道题数据有点坑

## 我把结果+100003的和再模100003输出的。

## 首先看1-k的种数：当有一阶台阶时，fb[i]=1，两级台阶时， fb[i]=2，三级台阶时，fb[i]=4……

## 也就是fb[1-k]=2^0-k-1.所以我们先算出来它。

## 大家注意，有两位同学使用2重循环解题，代码量虽少，但时间复杂度很高。于是课上讲做最大子段和DP发的前缀和思想，将sum数组先在第一个循环中当作前缀和数组，第二个循环中则当队列来进行操作——虽然我没学队列。


```cpp
### #include<iostream>
### using namespace std;
### int main()
### {
###     int n,k;
###     cin>>n>>k;
###     long long fb[n+2];
###     long long sum[100000+1]={0};
###     fb[1]=1;
###     sum[1]=1;
###     fb[2]=2;
###     sum[2]=3;
###     for(int i=3;i<=min(n,k);i++)
###     {
###         fb[i]=((fb[i-1]%100003)*2)%100003;
###         sum[i]=(sum[i-1]%100003+fb[i]%100003)%100003;
###     }
###     int l=1;
###     fb[k+1]=sum[k]%100003;
###     for(int i=k+1;i<=n;i++)
###     {
###         fb[i]=sum[i-1]%100003;
###         sum[i]=(sum[i-1]%100003-fb[l]%100003+fb[i]%100003)%100003;
###         l++;
###     }
###     cout<<(fb[n]+100003)%100003;
###     return 0;
### }
```