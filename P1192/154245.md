关于这个要用递推就不解释了，否则必定TLE

（C语言）

最好的办法就是用一个数组来存数

那么关于这个存数也有几点需要注意：

代码改了又改我们可以发现：

当i从1递增到K时，对应的数就是2的几次方！

当i=K+1时，是2^(K+1)-1，因为此时不能一次走上K+1个台阶

当i从K+2递增到N时，s[N]即s[N-K]到s[N-1]的和，那么如果K大于N也没关系，这个时候循环条件根本不满足嘛~
而这时为了减少运算量，其实s[i]就是s[i-1]加上一个s[i-1]减去一个s[i-1-K]得到的，一次循环搞定！

最后说到整数溢出的问题：建议算一个，求一次余数，最后的最后加一步判断，s[N]可能<0,这时候加上100003就好了~

第一篇题解，恳请通过！
希望对大家有所帮助，如有不妥之处，欢迎大家指正！
最后上代码：
```c
//找规律
//注意几点：K之前是等比，之后s[i]是s[i-K]加到s[i-1]的和，但处理要注意
//最大的问题是处理溢出的问题 
#include <stdio.h>
#include <math.h>
long N,K,s[100005]={0};//递推数组 
int main()
{
	int i;
	scanf("%ld%ld",&N,&K);
	s[1]=1;
	for(i=2;i<=K;i++) 
	{
		s[i]=2*s[i-1];
		s[i]%=100003;
	}
	for(i=1;i<=K;i++)
	{
		s[K+1]+=s[i];
		s[K+1]%=100003;
	}
	for(i=K+2;i<=N;i++)
	{
		s[i]=2*s[i-1]-s[i-1-K];//这一步有可能减出一个负数
		s[i]%=100003;
	}
	while(s[N]<0) s[N]+=100003;
	printf("%ld\n",s[N]);
	
	return 0;
}
```

