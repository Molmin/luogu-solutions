    本蒟蒻做此题时偶有一得之愚，便发布了本蒟蒻的第一篇题解。希望能给大家带来些许帮助。
    鄙人才疏学浅，文辞拙劣，若文章有不足之处请您包涵。
          *^ω^*


------------

    刚拿到这道题的时候并没有什么思路，看了看数据范围觉得用暴力搜索可能会超时；

    弱弱的我点开了算法标签，发现了有斐波那契（Fibonacci）的标签；

    于是，便花了一些时间去写了个表格：
    

------------

![P1192 表格](https://cdn.luogu.com.cn/upload/image_hosting/v2n9hfpb.png)

------------

    表格打好了，现在就是观察这个表格和斐波那契的关系了；
    
    显而易见：表格的左下半部分都是2的n次方；
    
    所以我们就将表格分为两部分：
    

------------

- Part 1：[左下半部分]
	对于第K行，前K项为**2的(N-1)次方**；
    
- Part 2：[右上半部分]
	对于第K行，从第K+1项开始，每项都是**前K项的和**（这不就是斐波那契的变式嘛！）；
	

------------

    
    找出来规律之后就好办了，接下来：
    

------------

* 第一步：开一个数组，代表第K行的数列，然后用一个For循环（From 1 To K）将前K项赋值为2的(N-1)次方；

* 第二步：再开一个For循环（From K+1 To N），对每一项进行赋值为前K项的和并**取模**；
    

------------

    好了，到此输出数组的第N项模100003的值，本题便可以结束了。
    
    最后，弱弱地献上本蒟蒻的蒟蒻代码（蒟蒻码风）：
	（对于本题可AC，不保证其他题不会爆。）
    
```cpp
#include<iostream>

using namespace std;
int h[100001],mod=100003;

int main() {
	int N,K,er=1;
	cin>>N>>K;
	for(int i=1; i<=K; i++) {
		h[i]=er;
		er=er*2%mod;
	}
	for(int i=K+1; i<=N; i++) {
		for(int j=i-K; j<i; j++) {
			h[i]+=h[j];
			h[i]%=mod
		}
	}
	cout<<h[N]%mod;
	return 0;
}

```
