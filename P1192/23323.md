比较容易的AC方法：

对于每个台阶，累加之前K个台阶的答案并模

最后输出答案，时间复杂度O(N\*K)=10^8

因为常数比较小所以可以过。

----------------------------分割线----------------------------

上面的算法是大家都很容易想到的，

以下介绍一种更优的方法，

时间复杂度可以降到O(N)，也就是说N=5000000的时候也是可以过的

算法思想：

总体的思路还是更普通的方法一样，

其实只是维护了一个数组的前缀和，

使计算之前k个阶梯的时候，复杂度降为O（1），总共是O（N）

统计前缀和是算一个记一个，所以复杂度是O（N）

循环计算N个解题，复杂度也是O（N）

显然，O(N)+O(N)+O(N)=O(N)，常数也小的很

亲测了一下， 耗时3ms/5个点

稍微翻了一下评测记录，不知道为什么好像很少人想到这样的方法

满贴一下代码：

----------------------------分割线----------------------------

```cpp
#include<cstdio>
#define mod 100003
using namespace std;
int k,n;
int num[100005];
int sum[100005];//维护Num的前缀和 
int max(int a,int b){return a>b?a:b;}
int min(int a,int b){return a<b?a:b;}
int main()
{
    scanf("%d%d",&n,&k);
    k=min(n,k);//一点点优化，k>n时没有用
    num[0]=sum[0]=0;
    num[1]=sum[1]=1;
    for(register int i=2;i<=n;i++)
    {
        num[i]=(sum[i-1]-sum[max(i-k-1,0)]+(int)(i<=k)+mod)%mod;//这一句的“+mod”很重要，因为这里的前缀和不是递增的
        sum[i]=(sum[i-1]+num[i])%mod;//维护前缀和
    }
    return !printf("%d\n",num[n]);
}
```