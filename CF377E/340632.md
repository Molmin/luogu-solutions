若 $c_i\ge c_j$ 且 $v_i\lt v_j$ 则 $i$ 永远不会用到，去掉这样的 $i$ 以后按照 $c$ 排序，我们肯定是按照这个顺序去用一些人，最后激活某个人然后一直用它。

由于 $c,v$ 都是递增的，所以如果有两种方案：第一种花了 $x$ 秒激活了 $i$，第二种花了 $y$ 秒：假设 $x\lt y$ 则第二种方案不管此时有多少金币一定没有第一种方案优：因为差的这 $(y-x)$ 秒，第一种方案用工厂 $i$ 转；第二个人用 $v_j\lt v_i$ 的一些工厂 $j$ 转，显然没有第一种方案优秀。所以我们的第一关键字是激活时间，第二关键字是激活时剩下的金币数，这样直接暴力转移就可以设计出一个 $n^2$ 的 dp。这个 trick 在 CF1801D 里也出现了。

由于转移是双关键字比较的所以一些拆贡献之类的优化方法就不太行得通，但是注意到有决策单调性在：考虑两个状态 $i\lt j$，若 $j$ 在 $k$ 处比 $i$ 优秀，则对于更大的 $k'$ 一定是 $j$ 比 $i$ 来的优秀。

然后就可以二分队列进行优化，但是第一次写二分队列炸了半天心态没了，有几个注意点：

- 若 $i\ge j$ 则认为 $i\rightarrow j$ 的转移代价是 $\infty$。

- 若 $i$ 在 $n$ 处都不比队尾优就不要加了，我的实现里把他的边界设成了 $n+1$，然后任何一个人转移到 $n+1$ 的结果都是一样的所以这样这个人就永远赖在队列里，前面弹不掉他后面人也干不掉他......然后会 WA 116.

时间复杂度 $O(n\log n)$。

[代码](https://codeforces.com/contest/377/submission/207935628)