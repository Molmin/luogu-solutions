对于每一个数，记录下它能变成什么数，以及变成该数需要多少步，

那么如果某一个数在某一时刻，有恰好 $k$ 个数能变为它，则更新答案。

注意，假设有两数 $x,y$ 且 $x>y$ ，对于它们要转化到的那个目标数字，肯定 $x$ 除 $2$ 的次数比 $y$ 多，

所以为了让答案最小，需要先对输入的数组从小到大排序qwq

```cpp
//部分代码
int n,k,x,minn=2e9+7,i,a[N],s[N],b[N];//si表示目前数转化成i需要多少步 bi表示有多少个数能转化成i
int main()
{
	n=read(),k=read();
	for(i=1;i<=n;i++) a[i]=read();
	sort(a+1,a+n+1);//排序
	for(i=1;i<=n;i++)
	{
		int t=0,x=a[i];
		while(x)
		{
			s[x]+=t,b[x]++;//对现在的x更新s[x]和b[x]
			if(b[x]==k)//如果有恰好k个数能变为x
            minn=min(minn,s[x]);//更新答案
			t++,x/=2;//步数++，x变为原来1/2
		}
	}
	printf("%d\n",minn);
	return 0;
}

```
