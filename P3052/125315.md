## 状压dp

### 扫一眼数据范围,铁定状压
### 根据状压的标准套路,我们的数组 f 肯定有一维是与状态有关
### 那么怎么压缩状态呢？
### 我们用1代表这个奶牛已经在电梯里了,0则还没坐电梯
### 那么我们可以直接定义一维的数组,f[i]就代表当前状态为i时最小的乘电梯次数
### 最终的答案就是f[(1<<n)-1];
### 我们可以开一个数组g来记录当前状态下电梯内剩余的体积
## Code：

```cpp
//洛谷P3052,提高+,省选- 
// 2018-09-20 22:05:49
// 状压dp 
#include<iostream>
#include<cstdio>
#include<cstring>
#include<noip2018 rp++>

using namespace std;

int n,w;
int a[20];
int f[1<<18];//f[i]状态为i的最小次数
int g[1<<18];//g[i]状态为i时,最后一个电梯的剩余体积

int main()
{
	scanf("%d%d",&n,&w);
	
	for(int i=1;i<=n;i++) scanf("%d",&a[i]);
	
	memset(f,63,sizeof(f));
	f[0]=1;
	g[0]=w;
    //初始化
	
	for(int i=0;i<(1<<n);i++)
	//枚举状态 
	{
		for(int j=1;j<=n;j++)
		//枚举每一头奶牛 
		{
			if(i & (1<<(j-1))) continue;//如果这头奶牛已经在电梯里了
			if(g[i]>=a[j] && f[i | (1<<(j-1))]>=f[i])
			//如果这个电梯坐得下
			{
				f[i | (1<<(j-1))]=f[i];
				//让奶牛坐电梯
				//合并答案 
				g[i | (1<<(j-1))]=max(g[i | (1<<(j-1))],g[i]-a[j]);
				//更新剩余体积 
			}
			else if(g[i]<a[j] && f[i | (1<<(j-1))]>=f[i]+1)
			//如果这个电梯坐不下 
			{
				f[i | (1<<(j-1))]=f[i]+1;//电梯次数+1 
				g[i | (1<<(j-1))]=max(g[i | (1<<(j-1))],w-a[j]);
			}
		}
	}
	
	printf("%d",f[(1<<n)-1]);
	
	return 0;
}
//By Yfengzi
```