首先说一下翻译问题，可以交换一次，也可以不换。

法一：

暴力枚举交换每两个数后的情况，~~很明显~~超时，不放代码了。

法二：

明显如果已经是全部在自己的位置上，则不交换，答案为n。

如果只有一个不在-----------怎么可能？

剩下情况:

如果一个数已经在自己的位置上，则不让它交换，因为这样只会变少。

交换一次，可以使两个数都归位，当且仅当
```cpp
a[i]==j && a[j]==i
```
这样增加了2个。

如果没有，那么只要还有没归位的，则会增加1个。

所以我们只需枚举每个数，如果有与他成对的，则答案为已经在自己的位子上的+2，如果都没有，则+1。

上代码：
```cpp
#include<stdio.h>
#define MAXN 100005
using namespace std;
int a[MAXN];
int ans;//全局变量自动设为0 
int main()
{
	int n;
	scanf("%d",&n);
	for(int i=0;i<n;++i)
	{
		scanf("%d",a+i);
		if(a[i]==i)//如果已经在自己位置上 
			++ans;//+1 
	}
	if(ans==n)	//全在自己位置上
	{
		printf("%d",n); 
		return 0;
	}
	for(int i=0;i<n;++i)
		if(a[i]!=i&&a[a[i]]==i)//如果有和他成对的
		{
			printf("%d",ans+2);//+2
			return 0;//程序结束 
		} 
	printf("%d",ans+1);//无对，只能+1
	return 0;
}
```
珍爱生命，远离抄袭！