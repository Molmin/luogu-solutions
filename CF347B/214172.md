其实一开始，蒟蒻我拿到这题时，还是很懵逼的qaq

然后就发现了这样的一句话：

> 可以交换两个数的位置**一次**

em……我谔谔

那么思路就非常显然了，共有$3$种情况。

> 第一种，每个数都在其位置上。

那就很`happy`了，一次也不用换了，直接输出$n$即可。

> 第二种，有两个数互换了位置。

那也很`happy`啊，就把这两个数换过来就行了。

> 最后一种，数列跟样例差不多。

`over`，那就随便找个不在位置上的数跟它该在的位置上换，由于任意两个数互换至少会有两个数不在其位置上，所以答案就为已在位置上数的个数再$+1$即可。

有了思路，代码还是不难理解吧~

```
#include <bits/stdc++.h> 
using namespace std;
int n;
int a[100005];//定义
int main()
{
	cin>>n;
	int p=0;
	for(int i=0;i<n;i++)
	{
		cin>>a[i];
		if(a[i]==i) p++;//如果这个数在其位置上，就标记一下
	}
	if(p==n)//第一种情况
	{
		cout<<p<<endl;
		exit(0);
	}
	for(int i=0;i<n;i++)
		if(a[a[i]]==i&&(a[i]-i))//第二种情况
		{
			cout<<p+2<<endl;
			exit(0);
		}
	cout<<p+1<<endl;//第三种情况
	return 0;
}