# 题意及注意点

- 给一个 $0$ 到 $n-1$ 的全排列，只能将任两个数交换 **$1$** 次位置，求有多少个数能与自己所在的位置对应。

-    **是 $0$ 到 $n-1$ 的全排列而不是 $1$ 到 $n$！**

- **只能**交换 $1$ 次。

- 直接暴力模拟一遍**会T飞**。

# 思路

**P.S.**   如果拿到题时没有思路，可以先画图整理一下思路qwq

我们可以先画出 $3$ 种可能的情况

![](https://cdn.luogu.com.cn/upload/image_hosting/h4ljpw6i.png)

如上图，在第 $2$ 列中，黄色圆中的数字在正确的位置，蓝色圆中则是不在正确位置的数字。

那么，假设在正确位置上的数字个数为 $sum$，我们可以总结出 $3$ 种情况：

- 第一种：所有数字都在正确的位置上，可以直接输出 $n$。

- 第二种：有 $2$ 个数字**互换**了位置，可以用**仅有的**一次交换两数位置的机会将这两个数字交换位置，所以答案为 $sum+2$。

- 第三种：~~数字排的乱糟糟的，~~ **没有任何两个数能够在交换后全部变为正确位置。** 这时候，由于只能交换 $1$ 次位置，所以最好的方案是让其中 $1$ 个数回到正确位置。因此，答案为 $sum+1$。


那么现在，我们就可以“对症下药”，对仅有的 $3$ 种情况分别判断输出啦qwq

# 珂爱的代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[1000005],sum,n;
int main()
{
    cin>>n;
    for(int i=0;i<n;++i) cin>>a[i];//输入
    for(int i=0;i<n;++i) if(a[i]==i) sum++;//记录在正确位置上的数字个数
    if(sum==n)
     {
         cout<<n;
         return 0;//第一种情况
     }
    for(int i=0;i<n;i++)
     if(a[a[i]]==i&&i!=a[i])
      {
          cout<<sum+2;
          return 0;//第二种情况
      }
    cout<<sum+1;//第三种情况
    return 0;
}
```

完结撒花awa