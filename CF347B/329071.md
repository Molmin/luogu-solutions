求管理员手下留情(╥﹏╥...)！！！

[点我看题](https://www.luogu.com.cn/problem/CF347B)

思路一：暴力枚举位置

时间复杂度： $O(n^2)$ 。

再一看数据范围： $1\le n \le 10^5$ ，肯定会TLE。

~~果不其然~~

![](https://cdn.luogu.com.cn/upload/image_hosting/yo8ugkpa.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

那么，暴力很明显是行不通了，还有什么办法呢？

思路二：转化为数论题

经过画图分析总结，我们可以发现原排列一共有 $3$ 种情况：

- $1.$ 当所有的数都在自己的位置上时：

	例如： $0$ $1$ $2$ $3$ $4$ $5$
    
	方法：直接输出 $n$ 就行了（不需要变动）；

- $2.$ 有两个数互相交换了位置：

	例如： $5$ $4$ $2$ $0$ $1$ $3$（ $1$ 和 $4$ 互换了位置）

	方法：只要把这两个数交换回来就行了（让归位数 $+2$ ）；

- $3.$ 都没有（其他情况）：

	例如： $5$ $4$ $0$ $2$ $3$ $1$

	方法：任意交换两个数，让其中一个归位（让归位数 $+1$ ，比如 $4$ 和 $3$）。
    
细节：数列是从 $0$ 开始的（~~我就在这里栽了一回~~）

完整代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[100005],ans;//n，a如题意，ans用来统计原本就在自己位置上的数的个数
int main()
{
	cin>>n;//输入
	for(int i=0;i<n;i++)//从0开始
	{
		cin>>a[i];
		if(a[i]==i)//如果原本就在自己位置上
		{
			ans++;//统计数++
		}
	}
	if(ans==n)//全部都在自己的位置上（第一种情况）
	{
		cout<<n;//直接输出
		return 0;//结束程序
	}
	for(int i=0;i<n;i++)
	{
		if(a[a[i]]==i&&a[i]!=i)//如果这两个数刚好交换了位置（第二种情况）
		{
			cout<<ans+2;//当这两个数交换后，在自己位置上的数的个数会+2，所以输出ans+2
			return 0;//结束程序
		}
	}
	cout<<ans+1;//都不是（第三种情况），输出个数+1
	return 0;//结束程序
}
```

修改记录：

$2020.8.10$ ：修改了一部分 $\LaTeX$ ，增加了注释并精简了一部分语言。

$2020.12.20$ ：增加了一部分 $\LaTeX$ ，增加了注释并精简了一部分语言。