好毒的题啊。。

一开始看 CF 的官方题解，上来就是一个奇妙的 dp 糊我一脸。。

后来找人一问发现一个[良心题解](https://yhx-12243.github.io/OI-transit/records/cf643F%3Bcf674F.html)。这里大概记录一下我个人的理解。

---

首先我们考虑先安排好，每头熊每天喝哪些酒。

然后我们发现，我们只能根据每天醉的是哪些熊去判断哪一桶是酒。

那么我们考虑给每一桶液体写一个 $q_i$ 行 $n$ 列的表格，表格中第 $i$ 行第 $j$ 列中填入的是 $0/1$ 表示第 $i$ 天，第 $j$ 头熊是否喝了这桶酒。

由于我们需要根据每天醉的是哪些熊来**唯一确定**哪一桶装的是酒，那么桶与桶之间的表格一定是不同的。

既然这样，我们只需要计算出有多少张本质不同的表格，就最多能辨别出多少桶液体中酒的位置。

考虑如何计数：

注意到表格中，每一列只可能有 $0$ 个或者 $1$ 个 $1$，那么我们可以先枚举在所有的 $q_i$ 行中，一共有 $k$ 列有 $1$。这里的方案数就是 $\binom{n}{k}$。然后注意到我们确定了它们的列，行还没有固定。而行没有特殊要求，所以每一列都有 $q_i$ 种方案，用乘法原理不难得到 $k$ 列有 $1$ 的方案数为 $\binom{n}{k} \times q_i^{k}$。

并且由于规定醉倒的熊的数量不能超过 $\min(p,n-1)$，那么我们就得到了答案为下面这个式子：

$$ Ans_{i} = \sum_{k=0}^{\min(p,n-1)} \binom{n}{k} \times i^{k}$$

然后直接暴力 $O(pq)$ 计算即可。

---

可能有人对于上面组合数的计算有点问题。我们考虑这样一个预处理的方式：

首先将 $\binom{n}{k}$ 写成 $\frac{n^{\underline{k}}}{k!}$。

然后考虑将分子和分母的下降幂和阶乘拆成若干数的乘积，然后用数组存起来。

比如将 $4!$ 拆成 $1,2,3,4$，然后数组里面存 $1,2,3,4$。

设分子拆出来的数组的第 $i$ 个数为 $a_i$，分母拆出来的数组的第 $j$ 个数为 $b_i$。

那么考虑枚举 $i$ 和 $j$，然后让 $a_i,b_j$ 都除掉一个 $\gcd(a_i,b_j)$ 进行约分。

不难发现，最后所有的 $b_i$ 都会是 $1$。那么我们只需要做若干次乘法，让 $a_i$ 乘起来就行了。这样就避免了求逆元。

直接做是 $O(p^3)$ 的。

每次如果保留 $\binom{n}{k}$ 计算的 $a$ 数组，然后继续计算 $\binom{n}{k+1}$，就可以做到 $O(p^2)$。不过这里不是复杂度瓶颈，问题不大。

当然也可以通过约去 $2$ 的整次幂，然后用 exgcd 求解逆元计算，复杂度更加优秀。

$\rm Code$

```cpp
template<typename T>
inline T gcd(T a, T b) { return !b ? a : gcd(b, a % b); }

uit C[160];
int mul[160];

int main() {
	int n = ri, p = ri, q = ri;
	chkmin(p, n - 1), C[0] = 1;
	for(int i = 1; i <= p; i++) {
		mul[i] = n - i + 1;
		int t = i;
		for(int j = 1; j <= i && t > 1; j++) {
			int d = gcd(t, mul[j]);
			t /= d, mul[j] /= d;
		} C[i] = 1;
		for(int j = 1; j <= i; j++) C[i] *= mul[j];
	} uit res = 0;
	for(int i = 1; i <= q; i++) {
		uit ans = 0, mul = 1;
		for(int j = 0; j <= p; j++) {
			ans += C[j] * mul;
			mul *= i;
		} res ^= ans * i;
	} printf("%u\n", res);
	return 0;
}
```