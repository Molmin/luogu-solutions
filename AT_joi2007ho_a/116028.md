  题目不难理解，给出一段数列，再给出一个不大于数列长度的区间大小，求所有区间中元素的最大和
  

  这里要强调一下题目范围（这里题目翻译不全，参考根据原址的PDF）
  

  对于100%的数据，有1≤n≤100000,1≤k≤n，对1≤i≤n有abs（ai）≤10000，那么真·最大和就是1e9，所以显然int整型即可满足题目需求，无需耗费更大空间
  

  这道题因为确实难度比较捉鸡，所以比较适合初学者，而初学者一开始做很容易遇到tle（超时，即超过1000ms）或者WA（wrong answer答案错误）的问题，在这里贴一段非常典型且兼具WA与tle的核心代码
  
```
	for (int i = 1; i <= n-k; i++)
	{
		for(int j=i;j<=i+k;j++)
        {
        
             s=s+a[j];
        }
        
        if(s>max)max=s;
	}
```
WA错误1：这段代码的思路就是将区间以数列首元素为起点开始遍历整个数列，每一次求和，打擂法求出最大和max，但是在范围上，n-k是n往前推k位，而非实际上应该取的最后一个区间起点，如果要使终起点到数列终点的区间大小为k，实际上应取【n-k+1】，才能使区间中有k个元素，而内循环的i+k也是同理，应为i+k-1（例如显然1到k有k个元素，n-k+1看作（n-k）+1，n看作（（n-k）+k），是不是好理解了？）

WA错误2：一次内循环结束后，想想s还要继续累加吗？显然每个区间都是分开来求和的，因此一次内循环结束时，应将s的值初始化为0

tle错误：可以看出此算法的时间复杂度为O（(n-k)*k）而根据题目范围，可以用基本不等式得出其最小值为≤n^2/4，此时n-k=k则n=1e5，为O（2.5*1e9），显然超时，必须进行优化

仔细观察核心代码每次都在做什么，发现每一次区间往后移一位时，都直接重新从头到尾算一遍其元素和，但实际上根据我们遍历的规律，每次移动一格，那么其中可以有大量的元素不用重新累和，而每次移动和的变化实际上是加上移动后尾部的元素，再减去移动前头部的元素，这样只需要一层循环，时间复杂度降为O（n），显然不超时，修改后的核心代码如下

```
	for(int i=1;i<=k;i++)s+=a[i];
	max=s;
	for (int i = k+1; i <= n; i++)
	{
		s+=a[i]-a[i-k];
		if(s>max)max=s;
	}
```

当然这里也可以在输入时就计算好从第一位到每一位的和并用数组存储，然后将s+=a[i]-a[i-k];改为s=sum[i]-sum[i-k];这样就无须定义a数组，直接定义sum数组，时间和空间复杂度和原解是一致的

附上完整AC代码

```
#include <cstdio>
using namespace std;
int a[100001],n,k;//开辟数组保存数列，全局变量可以直接用于函数中
int maxs()//求最大和函数
{
	int max,s=0;
	for(int i=1;i<=k;i++)s+=a[i];//i尾第一区间元素
	max=s;给max一个初值
	for (int i = k+1; i <= n; i++)//i为区间尾
	{
		s+=a[i]-a[i-k];//当前区间和
		if(s>max)max=s;//打擂
	}
	return max;
}
int main()
{
	scanf("%d%d",&n,&k);
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&a[i]);//输入数组
	}
        printf("%d",maxs());//输出结果
	return 0;
}
```

PS:其实这里可以不用#include<cstdio>而是#include <iostream>，然后把下面的scanf改为cin，printf改为cout，本来我用的就是iostream但是原日本网站测试的时候不知道是什么bug用iostream头文件和cin/out就会WA，实际上是没有问题的。