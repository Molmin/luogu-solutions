## 思路
按照我的习惯，一般先讲这道题的思路。首先需要明白，这道题是要让我们求出一段连续的长度为k的子序列之和的最大值。首先最容易想到的就是朴素算法——暴力枚举。但这道题数据范围是n<=100000，如果每次在枚举长度为k的子序列之和时，都去跑一遍k的循环，时间复杂度就为n*k，必定超时。这是就要思考优化。

## 引入概念
这道题需要用到前缀和。这里为萌新们引入前缀和的概念。我们可以用一个数组（如s[i]）存下从1到i个数的总和。而s数组的值可以通过递推得到。公式即s[i]=s[i-1]+a[i]。应该很好理解。那么这个前缀和有什么用呢？下面就是这道题的重点。举个栗子，现在我们已经得到了所有的前缀和，要算出从第a个数到第b个数的和，是不是只需要用s[b]-s[a-1]即可？因为用第1个数到第b个数的和减去到第a-1个数的和，就是第a个数到第b个数的和

## 总结
为什么前缀和可以优化这道题的时间复杂度？仔细想想，如果用朴素算法，求出每一个子序列的和需要循环k次，而加入前缀和进行预处理之后，我们可以在O(1)的时间求出这段和。这道题可以说是一道前缀和的例题。而前缀和的应用也不止这些。最主要的应用就是直接求出一段序列（或矩阵）的和，可以应用在区间dp等题目中（不知道什么是区间dp也没关系，~~反正我也不是很熟悉~~，只要坚持学下去，以后总会学到并掌握的。）

## 代码
```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int n,k,a[100005],s[100005],ans=-0x7fffffff/2;//s[]数组就是前缀和，a[]数组是序列，因为要打擂台，所以提前把ans赋为无穷小（说是无穷小，其实是接近int型最小，除以2是防溢出，不除也没事）
int main(){
    scanf("%d%d",&n,&k);
    for(int i=1;i<=n;i++){
        scanf("%d",&a[i]);
        s[i]=s[i-1]+a[i];//前缀和公式
    }
    for(int i=k;i<=n;i++) ans=max(ans,s[i]-s[i-k]);//打擂台，ans为答案，每次求出最大值，循环枚举的是子序列
    printf("%d\n",ans);//此处一定注意加上换行，之前没加错了2次
    return 0;
}
```