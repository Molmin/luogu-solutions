## 其实这道题可以用尺取法来做

尺取法，顾名思义，就像用尺子取一段区间，用i表示区间的左端点，j表示右端点，然后不断移动区间，每次移动区间时，不断更新答案即可。

尺取法需要限定范围。这道题，已经规定区间长度为k，即**j-i+1=k**，这是一个限定范围，同时，显而易见的是**j<=n**,这便是另一个限定范围。

有了限定范围，就只需要不断移动区间更新答案了。尺取法的时间复杂度近似为O(n)，这是完全可以接受的。

具体实现详见代码。

代码实现：
```cpp
#include <cstdio>

const int MAXN = 100000;

int a[MAXN + 5];

int main() {
	int n, k;
	scanf("%d %d", &n, &k);
	for(int i = 1; i <= n; i++)
		scanf("%d", &a[i]);
	int i = 1, j = 1, sum = a[1], ans = 0; 
	//一开始将左右端点的值都赋为1，sum一开始为a[1]，ans记录最终答案，初值赋0 
	while(true) {
		while(j - i + 1 < k && j < n) //两个限制范围，注意不取等(因为是先判断再++) 
			sum += a[++j]; //右端点后移，注意前置的++优先级比+=高 
		if(j - i + 1 < k) break; //如果最后都无法满足条件，就直接退出 
		ans = ans > sum ? ans : sum; //更新答案 
		sum -= a[i++]; //左端点右移，则需减去a[i]，注意这里使用后置++，即先-=后++ 
	}
	printf("%d\n", ans); //最后输出答案 
}
```
