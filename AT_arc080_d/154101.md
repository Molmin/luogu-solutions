做这道题的时候脑子有点不清醒，最后一步转化一直没想出来，看了题解又觉得这个题很套路。。

看见有区间取反这个操作就可以想到了差分。设 $a[i]$ 表示第 i 个硬币的状态，然后再设一个 f 数组表示 $a[i]$$^$$a[i-1]$，然后就可以发现一次 $i\to i+x-1$ 的取反相当于让 $b[i]$ 和 $b[i+x]$ 这两项取反。

对于每一对 i 和 j，分 3 种情况讨论，不妨设 i>j，del=i-j，把一次取反操作写成 (i,j)：

1.del 是奇质数，一步到位。

2.del 是偶数，若 del=2，$(j,j+5),(j+2,j+5)$；若 del=4，$(j,j+11),(j+4,j+11)$；若 del>4 根据哥德巴赫猜想，必然可以分解成 2 个奇质数（哥德巴赫猜想在这个数据范围是成立的）所以偶数情况操作最少是 2。

3.del 是奇非质数，如果 del=1，至少 3 次，$(j+1,j+4),(j+4,j+7),(j,j+7)$；若 del >3，就可以拆成 3 和一个偶数（3可以一步到位），所以至少三次。

一个显然的结论就是类型 1 尽量多，类型 3 尽量少。

最后一步转化我没想到，按奇偶分类，如果一个奇数和一个偶数的差是质数，那就连一条边，最后跑一遍二分图匹配求出最多的类型 1。

设答案为 ans，奇数个数为 x，偶数个数为 y，则最终答案是 ans\*1+(x-ans)/2\*2+(y-ans)/2\*2+[x+y=2]\*3，因为操作 3 的次数只能是 0 或 1。

main code:

```cpp
	int tott=0;
	n=read();
	up(i,1,n)a[i]=read();
	b[++tott]=a[1];
	up(i,2,n)
	{
		if(a[i]-a[i-1]>1)
		{
			b[++tott]=a[i-1]+1;
			b[++tott]=a[i];	
		}
	}
	b[++tott]=a[n]+1;
	s=0,t=tott+2;
	int x=0,y=0;
	up(i,1,tott)
	{
		if(b[i]%2==1)
		{
			add(s,i,1);
			++x;
			up(j,1,tott)
			{
				if(ispri(abs(b[j]-b[i])))
				{
					add(i,j,1);
				}
			}
		}
		else
		{
			add(i,t,1);
		}
	}
	int ans=solve();
	cout<<ans+(x-ans)/2*2+(tott-x-ans)/2*2+3*((x-ans)&1);
```
