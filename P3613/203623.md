## 前置芝士：动态查找表

查找分为两种：**动态查找**和静态查找

意思就是：

给你一个序列，然后……

静态查找：支持这个操作：

* 给定一个数$key$，**求$key$在序列中的位置**

而动态查找除了静态查找的功能，还支持另一个操作：

* 给定一个数$key$，**把$key$插入到序列中**

* 静态查找一般用二分查找等算法实现

* 动态查找一般用数据结构实现

**而支持动态查找的数据结构，就被称为动态查找表**

动态查找表一般用**BST**、**HASH**等数据结构实现

BST的时间复杂度：$O(log_2n)$

HASH的时间复杂度：近似$O(1)$

动态查找表STL里都有

BST：`map`

HASH：`unordered_map<int,int>`

> ~~原理请自行百度~~

## 转入正题：这题怎么做

PS：本题的![](https://cdn.luogu.com.cn/upload/image_hosting/entwi8zf.png)不用管它，容易引起歧义

~~傻子才开二维数组~~

正常人一般会想到先开一个`int a[100000]`，然后就蒙了:第二维不知道怎么开，开二维会很浪费空间

那么不妨先想一想：为什么开二维会浪费空间呢？

答案显而易见：有很多“寄包格子”是没有用上的

那么用`vector`呢？

显然可以，但显然会TLE

这时候前置芝士就派上用场了：**动态查找表**

把每个“寄包柜”都当做一个动态查找表即可，每个“寄包格子”作为动态查找表里的元素

同理,有很多“寄包柜”也是没有用上的，同样可以把“超市”当作一个动态查找表，每个“寄包柜”作为动态查找表里的元素

~~那么超市就成了这个奇怪的东西：~~

```cpp
unordered_map<int,unordered_map<int,int>>
```
其他的操作就很简单了：当二维数组用

```cpp
#include<bits/stdc++.h>
using namespace std;
unordered_map<int,unordered_map<int,int>> a;//HASH的时间复杂度略低于BST
int main() 
{
	int n,p,i,j,k;
	cin>>n>>n;//寄包柜个数无关紧要，直接吃掉
	while(n--)
	{
		cin>>p>>i>>j;
		if(p==2) cout<<a[i][j]<<endl;//查询第i个柜子的第j个格子中的物品是什么
		else//在第i个柜子的第j个格子存入物品k
		{
			cin>>k;
			a[i][j]=k;
		}
	}
}
```
