# Solution

首先，每个数出现两次，意味着含有这个数的两个集合的交集就是它；反过来说，一个集合中的**每个数**都会作为这个集合和其他集合的交集**恰好一次**。

也就意味着每个集合的元素个数是**一样**的，并且**集合总数**刚好比**单个集合的元素个数**大 $1$。

由此可以判断：

- 当 $n$ 可以表示成 $m \times (m + 1)$ 的形式时，输出 $\text{Yes}$。

- 否则输出 $\text{No}$。

那如何构造合法解呢？

由于每个数的地位平等，我们可以令第一个集合为 $\{ 1, 2, ..., m \}$，在此基础上进行构造。

举个栗子：$n = 10$，$m = 4$。

第一个集合：

- $1, 2, 3, 4$

第二个集合要和第一个集合有刚好一个公共元素，为方便就取个 $1$ 吧。剩下 $3$ 个位置给还没用过的元素：

- $1, 5, 6, 7$

第三个集合和前两个集合都要有公共元素。显然 $1$ 已经不能再用了，因此前两个位置取 $2$ 和 $5$：

- $2, 5, 8, 9$

此时我们可以发现：第 $i$ 个集合与前 $i - 1$ 个集合的公共元素就是前面的集合组成的矩阵中第 $i - 1$ 列的 $i - 1$ 个元素。

于是第四个同理：

- $3, 6, 8, 10$

第五个无脑：

- $4, 7, 9, 10$

构造完毕：

- $1, 2, 3, 4$

- $1, 5, 6, 7$

- $2, 5, 8, 9$

- $3, 6, 8, 10$

- $4, 7, 9, 10$

当然，我们需要一个指针记录当前已经用过的数。

# Code

```cpp
#include<bits/stdc++.h>
#define N 455
using namespace std;
int n;
int m;
int ans[N][N];
int tot;// 指针
int main(){
    scanf("%d",&n);
    m=sqrt(n*2);
    if(m*(m+1)!=n*2){
    	printf("No");
    	return 0;
	}
	printf("Yes\n%d\n",m+1);
	for(int i=1;i<=m;i++) ans[1][i]=i;
	tot=m;
	for(int i=2;i<=m+1;i++){
		for(int j=1;j<i;j++) ans[i][j]=ans[j][i-1];
		for(int j=i;j<=m;j++) ans[i][j]=++tot;
	}
	for(int i=1;i<=m+1;i++){
		printf("%d ",m);
		for(int j=1;j<=m;j++)
			printf("%d ",ans[i][j]);
		printf("\n");
	}
    return 0;
}
//20=4*5
//1 2 3 4
//1 5 6 7
//2 5 8 9
//3 6 8 10
//4 7 9 10
```
