题目分析：

由题目条件1：xyz 是整数, x<y<z,**y−x=z−y**

### 可以知道 y 为 x z之间的中点 

1. 编号1与编号4 之间有编号2、编号3这两个点，没法找到中点
（1为奇数4为偶数，它们之间的点有偶数个，没法找到中点）

2. 编号1与编号5 之间有编号2、编号3、编号4这三个点，中点为编号3. （1、5都为奇数，它们之间的点有奇数个，可以找到中点）


### 综上，只有奇偶性相同的编号之间才会找到中点y 

由题目条件2：colorx=colorz

### 可知xz这两个格子的颜色必须相同 


看到：三元组的分数计算公式为 (x+z)×(number_x+number_z)

可知：y没有参与计算，也就没什么用了，三元组变为了二元组


所以挑出来的集合（三元组，即二元组）需要满足

### 1.编号的奇偶性相同
### 2.color相同



------------

样例分析：

##### 样例1分析：
满足上面两个条件，可以有这么几种组合

ps:以下格式为：(编号,number)

蓝色 奇数下标 （1,5） （5,2）

蓝色 偶数下标 （2,5）

红色 奇数下标 （3,3）

红色 偶数下标 （4,2） （6,2）

### 颜色相同、编号奇偶性相同的两两组合：

所得分数为：
蓝色 奇数下标 （1+5） * （5+2） = 42

蓝色 偶数下标  = 0 （没有组合方式）

红色 奇数下标  = 0 （没有组合方式）

红色 偶数下标 （4+6） * （2+2） = 40

所以，三元组的分数和为 42 + 0 + 0 + 40 = 82


------------


##### 样例2分析：
|  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |
| -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: |
|编号|1|2|3|4|5|6|7|8|9|10|11|12|13|14|15
|number|5|10|8|2|2|2|9|9|7|7|5|6|4|2|4|
|color|2|2|3|3|4|3|3|2|4|4|4|4|1|1|1
满足上面两个条件，可以有这么几种组合

ps:以下格式为：(编号,number)

颜色1 奇数下标 （13,4） （15,4）

颜色1 偶数下标 （14,2）

颜色2 奇数下标 （1,5） 

颜色2 偶数下标 （2,10） （8,9）

颜色3 奇数下标 （3,8）  （7,9）

颜色3 偶数下标 （4,2）  （6,2）

颜色4 奇数下标 （5,2）  （9,7） （11,5）

颜色4 偶数下标 （10,7）  （12,6）

### 颜色相同、编号奇偶性相同的两两组合：

所得分数为：
颜色1 奇数下标  28 * 8 = 224

颜色1 偶数下标  0

颜色2 奇数下标  0 

颜色2 偶数下标  10 * 19 = 190

颜色3 奇数下标  10 * 17 = 170

颜色3 偶数下标  10 * 4 = 40

颜色4 奇数下标  14*9 + 16*7 + 20*12 = 126 + 112 + 240 = 478（这里有三种组合）

颜色4 偶数下标 22 * 13 = 286

所以，三元组的分数和为 224 + 0 + 0 + 190 + 170 +  40 + 478 + 286 = 1388


------------

暴力计算三元组的分数（超时）：
```cpp
#include <iostream>
using namespace std;
struct data{
	int id,number; //id为下标
}stu[100005];
int main(){
for(int i = 0; i < n; i++)
	for(int j = i+1; j < n; j++)
		ans += （stu[i].id + stu[j].id） * (stu[i].number + stu[j].number)
	return 0;
}
```


------------
#### 正解：

最多**100000**种颜色，格子又分奇数格子、偶数格子。

例如：颜色1  奇数下标
		   
            偶数下标
### 所以，一共有200000个集合（三元组）

在一个集合里，假设这个集合的大小为n

c代表格子的编号（下标），d代表number（格子上写的数字）

 (c0+c1)(d0+d1) + (c0+c2)(d0+d2) + …… + （c0+cn-1）(d0+dn-1)

(c1+c2)(d1+d2) + (c1+c3)(d1+d3) + …… + （c1+cn-1）(d1+dn-1)

……

……

(cn-2+cn-1)(dn-2+dn-1)

对于(c0+c1)(d0+d1) + (c0+c2)(d0+d2) + …… + （c0+cn-1）(d0+dn-1)

=c0( (n-1)d0 + d1+d2+ …… +dn-1 ) + c1(d0 + d1) +c2(d0+d2) + ……

=c0( (n-1)d0 + d1+d2+ …… +dn-1 ) + d0( c1+c2+c3+……+cn-1) + c1d1 + c2d2 + …… + cn-1dn-1

=(n-1)c0d0 + c0(d1+d2+ …… +dn-1) + d0(c1+c2+……+cn-1) + c1d1 + c2d2 + …… + cn-1dn-1

类比得出：(n-2)c1d1 + c1(d2+d3+ …… +dn-1) + d1(c2+c3+  …… +cn-1) + c2d2 + c3d3 + …… + cn-1dn-1

### 用后缀和优化

a[10] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};

pre[10] = {0, 1, 3, 6, 10, 15, 21, 28, 36, 45};

las[10] = {45, 44, 42, 39, 35, 30, 24, 17, 9};

下面的C、D表示后缀和,CD表示编号*number的后缀和

(n-1)c0d0 + c0D1 + d0C1 + CD1

(n-2)c1d1 + c1D2 + d1C2 + CD2

(n-3)c2d2 + c2D3 + d2C3 + CD3

……

……

(n-(n-1))cn-2dn-2 + cn-2Dn-1 + dn-2Cn-1 + CDn-1

//cn-2dn-2 + cn-2Dn-1 + dn-2Cn-1 + CDn-1


------------
### 代码如下：
```cpp
#include <iostream>
#include <cstring>
#include <cstdlib>
#include <cstdio>
#include <cmath>
#include <algorithm>
#include <vector>
using namespace std;

#define MOD 10007
#define MAXN 100000 //最多的格子数
#define MAXM 100000 //最多的颜色种类数

struct Data {
	int c, d; //c、d分别表示每个集合（三元组）的奇偶、编号（下标）
};

int n, m, ans;

int number[MAXN+5], color[MAXM+5];
vector <Data> sets[MAXM+5][2];
vector <int> C[MAXN+5][2], D[MAXM+5][2], CD[MAXM+5][2]; //编号的后缀和、颜色的后缀和、编号与颜色乘积的后缀和

int main()
{
	scanf("%d%d", &n, &m);
	for(int i = 1; i <= n; i++) {
		scanf("%d", number+i);
		number[i] %= MOD;            //输入取模,边输入边取模
	}
	for(int i = 1; i <= n; i++) {
		scanf("%d", color+i);
		color[i] %= MOD;
	}

	//分组,按照颜色-奇偶放到不同的集合
	for(int i = 1; i <= n; i++) {
		Data tmp;
		tmp.c = i, tmp.d = number[i];
		sets[color[i]][i&1].push_back(tmp); //颜色相同,奇偶相同放在同一集合    i&1 等价于 i%2 结果为0代表偶数，1代表奇数
		//下列三条语句为开辟内存空间，为下面求后缀和提供空间
		C[color[i]][i&1].push_back(0);
		D[color[i]][i&1].push_back(0);
		CD[color[i]][i&1].push_back(0);
	}

	//预处理  后缀和  O(N) 复杂度
	for(int i = 1; i <= m; i++)	{
		for(int j = 0; j <= 1; j++)	{
			//处理集合sets[i][j]的后缀和
			int sz = sets[i][j].size(); //求该集合中格子的数量
			if(sz == 0) continue;  //跳出本次循环

			C[i][j][sz-1] = sets[i][j][sz-1].c; //最后一个集合的后缀和就是它本身
			D[i][j][sz-1] = sets[i][j][sz-1].d;
			CD[i][j][sz-1] = sets[i][j][sz-1].c * sets[i][j][sz-1].d % MOD;

			for(int k = sz - 2; k >= 0; k--) {//计算时间复杂度：主要看最内层执行次数,由于每次sz很小，执行的总次数接近N:100000 
				C[i][j][k] = (C[i][j][k+1] + sets[i][j][k].c) % MOD;
				D[i][j][k] = (D[i][j][k+1] + sets[i][j][k].d) % MOD;
				CD[i][j][k] = (CD[i][j][k+1] + sets[i][j][k].c * sets[i][j][k].d) % MOD;
			}
		}
	}

	//     计算ans  (利用上面推导的式子)
	for(int i = 1; i <= m; i++) {
		for(int j = 0; j <= 1; j++) {
			int sz = sets[i][j].size();
			for(int k = 0; k < sz-1; k++) {
				//完全套公式
				ans += (((sz-k-1) * sets[i][j][k].c % MOD) * sets[i][j][k].d % MOD);
				ans %= MOD;
				ans += sets[i][j][k].c * D[i][j][k+1] % MOD;
				ans %= MOD;
				ans += sets[i][j][k].d * C[i][j][k+1] % MOD;
				ans %= MOD;
				ans += CD[i][j][k+1];
				ans %= MOD;
			}
		}
	}

	printf("%d\n", ans);
 	return 0;
}


```