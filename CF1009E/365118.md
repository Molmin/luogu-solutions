## $ \texttt{CF1009E} $  

---

### 思路：  

这里分享我的猜结论做法及结论证明。感觉这题评 $ 2000 $ 略低了？  

首先发现可以直接计算每个 $ a_i $ 的贡献次数，最后加起来。  

然后发现 $ a_n $ 的贡献次数是 $ 1 $，并且从 $ n $ 到 $ 1 $ 贡献次数逐渐减少。所以设 $ dp_i $ 表示 $ a_{n-i+1} $ 的贡献次数，$ dp_1=1 $。  

这时套入 $ n=4 $，手算得到 $ dp $ 数组：  

$ 1,3,8,20 $  

这里就大概尝试一下，应该是比较容易发现规律的，$ dp_i=2dp_{i-1}+2^{i-1} $。  

然后浅写一下交上去发现过了，很神奇。于是开始尝试证明。以下为证明。  

首先，对于 $ dp_{i-1} $ 的每一种合法方案中出现的 $ a_1 $ 到 $ a_{n-i+2} $ 这一段，$ a_1 $ 到 $ a_{n-i+1} $ 这一段显然也同样地出现了一次。因此 $ dp_i $ 要加上 $ dp_{i-1} $。  

然后，我们将 $ dp_{i-1} $ 的每一种合法方案中出现的所有 $ a_1 $ 到 $ a_{n-i+2} $ 这一段中的最后一段的最后一步，即 $ a_{n-i+2} $，改为休息，即 $ a_1 $，这样必定产生不同的合法的方案且贡献次数相同。因此，$ dp_i $ 再次加上 $ dp_{i-1} $，至此，$ dp_i=2dp_{i-1} $。  

那么这个 $ 2^{i-1} $ 是怎么来的呢？以上的统计还有一点缺漏，比如 $ a_1 $ 到 $ a_{n-i+1} $ 这一段被放在最后，这就是 $ dp_{i-1} $ 考虑不到的情况，这种情况下前面的 $ i-1 $ 位可以任意选择休息或者不休息，所以是 $ 2^{i-1} $ 次的贡献。  

感觉好像很对，但是仔细想又会发现这样的统计似乎有问题，比如：  

$ \cdots,a_{1},\cdots,a_{n-i+1},a_1,\cdots,a_{n-i+2} $  

这种情况下 $ dp_{i-1} $ 不会考虑到前面这段 $ a_1 $ 到 $ a_{n-i+1} $ 的贡献。这个问题我想了很久，然后发现一件事情，我们统计改变后序列的贡献和是与改变前序列的贡献无关的，也就是说对于这种情况，会存在另一种方案，比如：  

$ \cdots,a_1,\cdots,a_{n-i+2},a_1,\cdots,a_{n-i+1} $  

这样两种情况将 $ a_{n-i+2} $ 改为 $ a_1 $ 后是一样的，就是说前面所有的 $ a_1 $ 到 $ a_{n-i+1} $ 段都有对应的序列使得改变后可以计算到贡献。讲得可能不太好，实在不懂可以自己拿样例推一次，我就是这么干的。  

那么就结束了，直接用式子实现即可，我写的 $ O(n\log n) $，事实上直接预处理 $ 2^{i-1} $ 就可以 $ O(n) $。  

---

### 代码：  

```cpp
#include<bits/stdc++.h>
using namespace std;
const int mod = 998244353;
const int N = 1e6 + 5;
int s1[N], n, ans;
int qpow(int x, int k);
int main() {
	int T1 = 1;
	scanf("%d", &n);
	for (int i = 1; i <= n; i++) {
		scanf("%d", &s1[i]);
	}
	for (int i = 1; i <= n; i++) {
		ans = (ans + 1ll * T1 * s1[n - i + 1] % mod) % mod;
		T1 = (2ll * T1 % mod + qpow(2, i - 1)) % mod;//此时T1即为dp_i
	}
	printf("%d", ans);
	return 0;
}
int qpow(int x, int k) {
	int Ans = 1;
	for (int i = k; i; i >>= 1, x = 1ll * x * x % mod) {
		if (i & 1) {
			Ans = 1ll * Ans * x % mod;
		}
	}
	return Ans;
}
```
