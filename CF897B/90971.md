### 提供广东部分地区最适合的码风+最简单的理解方式

---

### 题目理解

这道题，题目意思很简单。就是要你求出前k个数位个数是偶数的回文数的和mod p。

数据范围：k<=100000，p是int范围以内

---

### 明确思路

首先，根据k可以确定，绝对不可以暴力查找回文数。因为第100000个回文数是非常大的。

那我们不妨把我们要的回文数做出来。（构造就是这个意思）

一个数：123

反过来：321

可以拼成回文数：123321

因为回文数这里局限与偶数为，所以大大降低了构造的难度。

从1~100000范围内进行构造即可，由于数据太大，（最大的回文数：100000000001）要开long long。

### code

#### 红蝶在此，抄袭可耻。

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,q,f[100000+5],fn,ans;
long long s,t;
int main()
{
  scanf("%d%d",&n,&q);
  for(int i=1;i<=100000;i++)//最大范围
  {
    s=i,t=i;
    while(s>0)
    {
      t=t*10+s%10;
      s/=10;
    }
    fn++;
    f[fn]=t;//构造
    if(fn==n)//如果当前回文数个数达到k
    {
      for(int j=1;j<=n;j++)ans=(ans+f[j])%q;
      cout<<ans;//累加并输出
      return 0;//over
    }
  }
  return 0;
}
```
