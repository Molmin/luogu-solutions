## 题意简述

给定正整数 $n$，每次可以进行如下两种操作中的一种：

1. 将 $n$ 除以 $n$ 的因数（**不包括 $n$ 本身**）；

2. 将 $n$ 减去 $1$。

问最少多少次可以将 $n$ 变为 $1$。

## 分析+题解

显然这是一道贪心题，我们先从最简单的情况入手。

**问：若 $n$ 为偶数，如何进行操作最优？**

相信聪明的你一定能想出答案——

**答：将 $n$ 除以 $\dfrac{n}{2}$ 之后变为 $2$，然后减 $1$ 就行了，答案是 $2$。**

再考虑下面这个问题：

**问：若 $n$ 为奇数，如何进行操作最优？**

有了前一个问题的铺垫，这个问题变得简单起来——

**答：先将 $n$ 减去 $1$，然后就转化成了 $n$ 为偶数的情况，答案是 $3$。**

到这里这道题就基本做完了，不过请再思考：

**问：上述策略对于一些特殊的数字，有没有可以省略的操作呢？**

答案也不难——

**答：**

**1. 对于第一种情况（$n$ 为偶数），若 $n=2$ 则不用进行第一步操作，答案为 $1$；**

**2. 对于第二种情况（$n$ 为奇数），若 $n=1$ 不用进行任何操作，答案为 $0$；若 $n=3$ 会转化成 $n=2$ 的情况，答案为 $2$。**

## 代码实现

先特判 $n \le 3$ 的情况，然后判断 $n$ 的奇偶性即可。

代码如下：

``` cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
	int t;
	scanf("%d",&t);
	while(t--)
	{
		int n;
		scanf("%d",&n);
		if(n<=3)
            printf("%d\n",n-1);//对n<=3情况的归纳
		else if(n%2==0)
			puts("2");//n为偶数
		else
			puts("3");//n为奇数
	}
	return 0;
}
```

## 有关本题的思考

请注意：**本题的正确解法已经讲解完毕，这里是用来简述一下我第一眼想到的错误解法，以及对这种错误的思考。**

事实上，我一开始想到的**错误解法**如下：

求出 $n$ 的不为 $1$ 或 $n$ 的最小因数 $d$，考虑第一步将 $n$ 除以 $\dfrac{n}{d}$，将其变为 $d$，之后花费 $d-1$ 步将其变为 $1$。

具体实现只用枚举 $1$ 至 $\lfloor \sqrt{n} \rfloor$，若没有找到 $n$ 的因数则 $n$ 为质数，不进行第一步操作。

与正解相对比，这个做法显然不优，请你思考以下问题：

**问：在没有想到正解前，如何说明这种做法不优呢？**

我猜你心里或许已经有了答案，来看一下我的想法吧：

**答：在将 $d$ 逐步减 $1$ 的过程中，可能会出现其他的大于 $1$ 的因数，可以用来进行第一种操作。而第一种操作的变化速率远大于第二种（至少都会除以 $2$）。**

上述事实说明，贪心不是盲目的乱贪，是需要一定理论基础和逻辑来证明的。（事实上，这正是不少人对贪心的错误印象）大多数贪心应从简单的方面入手，一步一步剖析问题，尤其是需要分类讨论的题。