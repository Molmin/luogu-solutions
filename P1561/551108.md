### 题目大意

有 $n$ 头牛，第 $i$ 头牛上山所用的时间为 $u_i$，下山所用的时间为 $d_i$。

每一时刻最多只有一头牛正在上山，一头牛正在下山。

问最少需要多少时间使得每头牛都过山。

### 题目分析

我们可以将这道题拆成两步想。

1. 还没上山的奶牛需要上山。
2. 已经上山了的奶牛需要下山。

也就是说上山和下山是互不干预的，所以如果山上一直有奶牛等着下山，也就是所下山的奶牛几乎不间断的话，答案肯定是最优的。

于是我们可以想到如下策略：

1. 上山的顺序按照上山时间少的先上。（这样可以使山顶有更多的牛等待或直接下山）
2. 下山顺序按照下山时间长的先下。（这样可以有效地拖慢时间等后面的牛，但是下山的奶牛基本上不会间断所以总的时间是更优的）

但是我们发现这样并不能使下山的奶牛尽可能不间断，如果一头牛的 $u_i > d_i$，就说明上下山的时间会有空当，如果连续多头牛都是这样就有可能间断下山队列。

于是我们可以考虑按照奶牛分类：

1. 第一种奶牛 $u_i \le d_i$，这种奶牛的上山时间小于下山时间，我们按照 $u_i$ 升序排列，既能保证山顶奶牛尽可能多，又不会出现时间空当。
2. 第二种奶牛 $u_i > d_i$，这些奶牛下山时间小于上山时间，我们按照 $d_i$ 降序排列，尽可能拖慢下山速度，为后面奶牛及时到达山顶争取时间。
3. 第一声奶牛排在第二种奶牛前面，因为第一种奶牛能更好的使山顶有更多的奶牛。

按照这样排序后就可以 dp 求解了，我们设 $f_i$ 为第 $i$ 头奶牛过山后的最少时间，转移方程为：

$$f_i = \max(f_{i-1}, \sum_{j=1}^{j\le i} u_i) + d_i$$

对于 $\sum_{j=1}^{j\le i} u_i$，我们可以记一个 $sum$ 然后就可以 $\mathcal O(1)$ 求值了，总时间复杂度是 $\mathcal O(n)$ 的。
### code
```cpp
#include <cstdio>
#include <algorithm>
#define int long long
using namespace std;
const int N = 3e4 + 5;
struct node{
	int u, d, opt;
}p[N];
int T, n, f[N], now;
bool cmp(node x, node y)
{
	return (x.opt != y.opt) ? x.opt < y.opt : ((x.opt <= 0) ? x.u < y.u : x.d > y.d);
}
signed main()
{
	scanf("%lld", &n);
	for(int i = 1;i <= n;i++)
	{
		scanf("%lld %lld", &p[i].u, &p[i].d);
		p[i].opt = p[i].u < p[i].d ? -1 : (p[i].u > p[i].d ? 1 : 0);
	}
	sort(p + 1, p + 1 + n, cmp);
	for(int i = 1;i <= n;i++)
	{
		now += p[i].u;
	    f[i] = max(f[i-1], now) + p[i].d;
	}
	printf("%lld", f[n]);
	return 0;
}
```