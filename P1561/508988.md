贪心。

首先考虑什么样的奶牛得先上坡。很明显，上坡耗时短的奶牛先上坡。为什么？因为如果耗时长的奶牛先上坡的话，那么后面的奶牛就会被全部拖慢，同时下坡的开始时间也被延后。所以这时我们将上坡耗时短的奶牛排在前面。

其次考虑什么样的奶牛得先下坡。很明显，下坡耗时长的奶牛先下坡。为什么？因为如果耗时短的奶牛先下坡的话，那么越到后面，上坡了在山顶上的奶牛就会被全部拖慢，同时下了坡的奶牛也会因等待而浪费时间。所以这时我们将下坡耗时长的奶牛排在前面。

但是我们还要考虑一个问题：如果上坡慢的奶牛下坡很快，我们怎么办？

所以，我们应该将奶牛归为两类。第一类是上坡时间小于下坡时间的，第二类是上坡时间大于等于下坡时间的。

很明显，我们应该将第一类排在第二类前，按上坡时间升序，这个在我们的第一个讨论中很显然。同理，在第二种情况中，我们应该把下坡时间长的排在前面。因为在第二种情况中，上坡时间大于等于下坡时间，那么我们就必须把下坡时间长的排在前面。这样就能尽量避免下坡已经下完了但下一头牛还没上来这样的情况。

所以最后的计算过程就是：
$$
ans = \max(\sum_{j=1}^nup_j,ans)+down_i
$$
读者自证不难。

最后的代码：
```cpp
#include <iostream>
#include <algorithm>
using namespace std;
struct node
{
	int a,b;
}x[100010];
bool cmp(node a,node b)
{
	if(a.a < a.b)
	{
		if(b.a < b.b)return a.a < b.a;
		return 1;
	}
	else 
	{
		if(b.a < b.b)return 0;
		return a.b > b.b;
	} 
}
int main()
{
	int n;
	cin >> n;
	for (int i = 1;i <= n;i++)
	{
		cin >> x[i].a >> x[i].b; 
	}
	sort(x + 1,x + n + 1,cmp);
	int ut = 0,dt = 0,ans = 0;
	for (int i = 1;i <= n;i++)
	{
		ut += x[i].a;
		dt = max(ut,dt) + x[i].b;
	}
	cout << dt << endl;
} 
```