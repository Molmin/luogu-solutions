算法构造：

1.设置集合F、M、S：先让F中奶牛的爬山，再让M中奶牛的爬山，最后让S中奶牛的爬山。

2.对第i件，若U[i]>D[i]，则归入S；若U[i]=D[i]，则归入M，否则归入F。

3.对F中的元素按U[i]升序排列，S中的按D[i]降序排列。

证明思路：

1.F中的能“拉开”John、Don让同一头奶牛上下山的结束时刻，为后面的奶牛爬山“拉开时间差”，利于节省总时间。S中的刚好相反。因而，F中元素放在最前一定是最优策略之一。

2.F中U[i]小的前置，可以缩短开始时B的空闲时间，但会使F所有奶牛“拉开的时间差”缩短。不过可以证明，后者带来的损失不大于前者获得的优势。对称地，对S也一样。因而步骤3是可行的。

思路很简单，就是实际编写比较麻烦。
