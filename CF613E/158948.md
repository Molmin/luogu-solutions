这是一个和题解区清一色的分三段不同的算法，区别在于竖着的过程在转移中体现。

以下均看做 $n,k$ 同阶，故只用 $n$ 进行分析复杂度。

一眼看到 $2\times n$ 的网格图只能上下左右走，不难想到[P4740](https://www.luogu.com.cn/problem/P4740)。

类似的思路，我们设 $f_{i,j,0/1,0/1}$ 表示在第 $i$ 列，字符串从第 $j$ 个位置匹配**并且不能回头**的方案数，后面的 $0/1$ 表示在上一行/下一行，是否进行了左右翻转。

这里**不能回头**不好说，但如果做了[P4740](https://www.luogu.com.cn/problem/P4740)肯定能理解，我用下图解释一下：

![](https://cdn.luogu.com.cn/upload/image_hosting/owdrp64h.png?x-oss-process=image/resize,m_lfit,h_150,w_200)

$f_{x,y,0,0}$ 表示的就是从红色箭头处出发，**但不能走到蓝色的线以左的黑色部分**，只能在白色部分进行匹配的方案数。

先考虑一个 naive 的转移，我们考虑枚举在当前行横着匹配了多长，假设匹配了 $k$，钦定就匹配了这么长，下一步必须转弯，即竖着走。

竖着走了过后要不向左，要不向右，即要不反着往回走，要不顺着往后走。

反着走只有一种走法，而且必须恰好匹配。

顺着往后走就可以直接用 $f_{i+k,j+k+1,f1\hat\ 1,f2}$ 转移到 $f_{i,j,f1,f2}$，注意这里 $j+k+1$ 多加了 $1$ 是因为竖着走了一步.

总复杂度 $O(n^3)$，状态 $O(n^2)$，转移 $O(n)$。

这个转移 naive 的地方在于横着能匹配多长可以预处理出来，但是还得考虑竖着能走才能转移，发现竖着能走的条件有两种：

- 横着下一位匹配且竖着下一位与横着下一位相等
- 横着下一位不匹配但竖着下一位匹配

第二种只会有一处，即失配的位置，特殊考虑即可。

第一种可以预处理带权前缀和，权为竖着下一位与横着下一位是否相等。

反着走的转移及其类似，同样可以用特殊处理和带权前缀和处理，然后只取过半的转移。

然后只要知道能匹配多长就能 $O(1)$ 转移了，而能匹配的长度显然可以随便预处理，至此可以处理出 $f$ 数组。

然后就可以直接统计答案了，我们枚举起始位置并向某个方向走 $O(n)$，再枚举第一次横着走了多长 $O(n)$，显然反着走过后和顺着走都可以直接使用 $f$ 数组转移，然后就做完了。

预处理 $O(n^2)$。

处理 $f$ 数组 $O(n^2)$，因为状态数为 $O(n^2)$，转移 $O(1)$。

统计答案 $O(n^2)$，其实用转移 $f$ 数组的技巧可以做到 $O(n)$，但没必要。

[代码](https://www.luogu.com.cn/paste/ifhrymkx)

亿些细节：

- 如果匹配串 $w$ 只有一个字符直接算很容易重，直接特判找这种字符有多少个。
- 矩阵的串与匹配串能匹配多长的预处理其实就是求两串任意两后缀的 LCP。
  
  在 CF 的标解中列举出了处理这个问题的拉胯算法：Hash、suffix structures（后缀结构）
  
  然后推荐了一个更拉胯的算法：扩展 KMP，~~更喜剧的是我没看 CF 标解然后和标解想一块去了~~。
  
  实际上用一个 DP 就可以轻松解决：$f_{i,j}$ 表示 $i,j$ 两后缀的 LCP，判断当前位置然后用 $f_{i+1,j+1}$ 直接转移即可。
  
- 如果第一次横着走了 1 的长度，即直接往上走，会和反转后的贡献算重，所以特判贡献乘 $\frac12$。
- 前缀和优化部分容易挂，同时 $f$ 转移和统计答案有**很多特判**，建议先写个暴力再对着改，也可以参考我的实现。

Upd：重构了部分拉胯的地方，补充了代码。