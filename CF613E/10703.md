对于 $|w| \le 2$ 的情况，我们进行特判，这是为了之后写起来分类讨论可以简洁一些。

观察一下最终的行走方式可能会变成啥样：

![](https://cdn.luogu.com.cn/upload/image_hosting/fkecjfml.png)

很多情况下，会变成这个样子。

注意到可以分成三段，左边一个 U 形，中间一个只会向右走的形状，右边又一个 U 形。

啊，为啥说中间是只会向右走？因为我们是这么钦点的，当然也可能是从右边出发往左走，这时只要把 $w$ 反转，再求一次就行。

我们可以处理出，从一个地方分段，会不会产生向左的，长度为某个值的 U 形。

这可以通过预处理 LCP 做到。

同理可以处理出，从一个地方分段，会不会产生向右的，长度为某个值的 U 形。

处理上述两个数组，它们就能够作为第一部分和第三部分。

我们把第二部分接在第一部分后，记 $f(i, j, k)$ 表示，当前第二部分走到了 $(i, j)$，并且匹配了 $w$ 的前 $k$ 个字符，并且不是从同一列走来的方案数。

类似地，记 $g(i, j, k)$ 为必须从同一列走来的方案数。则 $f, g$ 之间可以互相转移，这部分可以 $\mathcal O (n |w|)$ 处理。

然后考虑在 DP 到 $(i, j, k)$ 时，接上第三部分即可，可以直接判断接不接得上。

当然还有一些其他情况没有讨论的，比如三个部分中的某一部分并不存在，甚至是两个部分不存在之类的，仔细讨论一下即可。

注意要不重不漏，特别注意 $w$ 反转后不要统计重复了。

时间复杂度为 $\mathcal O (n |w|)$，[评测链接](https://codeforces.com/contest/613/submission/70898060)。