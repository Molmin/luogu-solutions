分类讨论和简单思维。

显然，为了使和最大化，我需要使的所有元素都等于序列中的最大元素。

无论给定的数组是怎样的，都可以通过使最后两个元素 $(n-1,n)$ 进行两次操作，使他变成 $0$，然后对 $[m,n]$ 进行运算，使其所有元素等于 $mx$。

然后再让前两个元素 $(1,2)$ 为零，再对整个数组操作，使所有元素都等于 $mx$。因此，最终数组的最大和总是 $n\cdot mx$（当 $m$ 恰好等于 $n-1$ 或 $n$，也是同理的，可以先从左边开始操作。

考虑 $n\le 3$ 的情况。

$n=2$ 时，要么操作让所有元素都变成 $|a_1-a_2|$，要么就啥都不干保持 $a_1,a_2$，答案就是 $\max(a_1+a_2,2\cdot|a_1-a_2|)$。

$n=3$ 时，当最大元素是 $a_1$ 或 $a_3$，我们还是可以将所有元素都变成最大，当最大元素是 $a_2$ 时，有以下几种情况：

1. 选择 $(1,2)$ 操作，此时每个数的最大值为 $\max(a_3,|a_1-a_2|)$。
2. 选择 $(2,3)$ 操作，此时每个数的最大值为 $\max(a_1,|a_3-a_2|)$。
3. 选择 $(1,3)$ 操作，所有元素变成 $|a_3-a_1|$，显然不需要这个，因为我们的讨论是在 $a_2>a_1,a_3$ 之上的，而 $a_2 - \min(a_1,a_3) > \max(a_1, a_3) - \min(a_1, a_3)$。


考虑情况 $1$ 和情况 $2$，如果操作完和还变小了，那操作就没用，干脆就别操作了。

所以 $n=3$ 时答案是 $\max(3\cdot a_1, 3\cdot a_3, 3\cdot |a_2-a_1|, 3\cdot |a_3-a_2|, a_1+a_2+a_3)$。


核心代码（完整代码见 [此](https://www.luogu.com.cn/paste/d76i3xcu)）：

```cpp
void solve() {
   int n; cin >> n;
   rep (i, 1, n) cin >> a[i];
   if (n == 1) printf("%d\n", a[1]);
   else if (n == 2) {
      printf("%lld\n", max(2 * abs(a[1] - a[2]), a[1] + a[2]));
   } else if (n == 3) {
      printf("%lld\n", max({3 * abs(a[1] - a[2]), 3 * abs(a[3] - a[2]), 3 * a[1], 3 * a[3], a[1] + a[2] + a[3]}));
   } else { sort(a + 1, a + n + 1);
      printf("%lld\n", a[n] * n);
   }
}
```