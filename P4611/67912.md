### 题意

一个人从 $k$ 号楼开始向相邻的且比当前矮的大楼跳（如果当前楼没有蹦床且相邻的楼都比当前高就停止了），若跳至一个有蹦床的楼，就可以跳向任意一楼，问这人能到达多少高楼。
### 解题
#### 解法一、
蹦床肯定是要用的（因为蹦床可以多去一些楼，蹦床间可以相互到达），那么现在来考虑蹦床可以怎么跳。

**1.如果 $k$ 号楼到不了蹦床，那就找最长的一段往下跳吧。**

**2.如果 $k$ 号楼能到蹦床，那蹦床怎么跳？**

看下图（手抖求原谅）
![能跳到蹦床T的楼](https://cdn.luogu.com.cn/upload/image_hosting/wibmbw2u.png)

蹦床右边这一段绿色的（既能跳至蹦床的高楼）都能使用到蹦床，那么我们都可以把绿色这一段看成蹦床。

如果是以下这种情况，绿色这一段依旧可以使用到（跳到）蹦床。
![绿色这一段依旧可以使用到蹦床](https://cdn.luogu.com.cn/upload/image_hosting/8xjzruyd.png)

你可以先跳至蹦床，再使用蹦床跳至最高点，然后再跳下来，因此蹦床可以覆盖到绿色这一段。

于是这一段绿色的都可累加到答案里。
![](https://cdn.luogu.com.cn/upload/image_hosting/09125dot.png)
如图，我们先累加能跳到蹦床的。
>> 跳完绿 ② 这一段，再通过蹦床跳至绿 ① 这一段，再跳至绿 ③ 这一段。


最后再跳至某一点选择最长的一段粉色跳（注意这一段不能包含能用蹦床的，否则会重复算）。

**具体做法**

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,k,a[300005],b[300005],c[300005],ans1,ans2;
string s,ss;
int main()
{
	cin>>n>>k;
	for(int i=1;i<=n;i++)
		cin>>a[i];
	cin>>s;
	s=" "+s;//下标从1开始
	for(int i=2;i<=n;i++)
		if(a[i]>=a[i-1])
		{
			b[i]=b[i-1]+1;//向左能到哪儿
			if(s[i-1]=='T') s[i]='T';//如果能到蹦床，那么它就当作蹦床用
		}
	for(int i=n-1;i>0;i--)
		if(a[i]>=a[i+1])
		{
			c[i]=c[i+1]+1;//向右能到哪儿
			if(s[i+1]=='T') s[i]='T';//如果能到蹦床，那么它就当作蹦床用
		}
	if(s[k]=='T')k能到蹦床
	{
		for(int i=1;i<=n;i++)
		{
			if(s[i]=='T') ans1++;//蹦床都可以跳到
			else ans2=max(ans2,max(b[i],c[i])+1);//跳不到蹦床就选最长一段最后来跳
         //注意b[i]和c[i]需要取max而不是加起来（一去不回头）
		}
		cout<<ans1+ans2<<endl;
	}
	else 
	{
		ans1=ans2=k;
		while(ans1>1 && a[ans1]==a[ans1-1]) ans1--;
		while(ans2<n && a[ans2]==a[ans2+1]) ans2++;
		cout<<max(c[ans1],b[ans2])+1<<endl;//向左拓展或者向右拓展
	}
	return 0;
} 
```
#### 解法二、
刚开始想到的是缩点，但是如果每个蹦床都向其它点连边，连边都用去 $O(n^2)$ 了，会 T。

于是看到题解区有大佬建立一个虚点，虚点连向所有点，这样之后把蹦床连向虚点，就相当于把蹦床连向所有点，方便快捷。