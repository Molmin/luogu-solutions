	首先想到dp，但是不能支持修改。~~听某些大佬说是动态点分治，然而本蒟蒻并不会。~~
	普通的点分治是静态的，可以nlogn的时间求解。动态点分治中先按各层分治的中心建一个点分树。可以证明，这棵树的深度不超过logn级别然后在这棵树上修改或求解即可。
	回到这道题，先建点分树。如果不加说明，所有操作都是在点分树上进行的。通过观察，发现最优的补给站是这棵树的带权重心，即如果现在节点的子树d的和*2大于总节点ｄ的和，那么向那个方向过去一定比原方案好。所以对于每个节点，记f[i]为以ｉ为根的子树d的和。先从根开始，如果f[s]*2>f[r]（ｓ是ｒ的儿子），则向ｓ搜索。然而有一个问题，f[s]只包含一部分的结点，所以要把剩余部分加到里面。因此在建树的时候要把根向原树每个块的第一个点记下来（记为u），然后找带权重心的时f[u]+=f[r]-f[s]，向上更新。
    另外还要对每个结点记：
   	h[i]表示以i为根的子树的d*dis的和。
    g[i]表示以i为根的子树到i的父亲的d*dis的和。
    每个点到每个祖先的dis。
   	向上更新时，自己YY。