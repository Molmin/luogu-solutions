

我们可以理解为先对总序列取反以后再询问，每次删除一个数，相当于删掉该位置，并且将后缀所有数取反。

然后发现一个性质，就是原序列中 `++` ，在取反后会变成 `+-` 或者 `-+` ，当删除某个数时，他都不会产生新的贡献，总是 $0$ 

所以对于取反后的序列，相邻符号不同的都可以直接删除（此处的删除不带取反），因为不会产生贡献。删除后发现，由于每次删除的都是偶数，那么两个原本不相邻的数相邻后，二者依旧保持一奇一偶的形式。所以我们可以接着删。

直到序列只剩下 `+++` 或者 `---` ，然后观察序列长度，当偶数时，由**相邻位删除后奇偶性不变**的结论也就是上面的话，我们可以删除（此处题目含义删除）顶端，变成 `-+-` 或者 `+-+`，此时我们再删除尾部，那么就符合条件了，即 `+-`。

奇数的时候更加显然，`+++` 删除顶端后就变成了 `-+`或者 `+-`，这一切都基于每次相邻位删除，奇偶性不变的结论。

然后就可以通过本题目了

```cpp
#include <bits/stdc++.h>
using namespace std;
int T;
int sum[300009];
int a[300009];
int n,m;
char c[300009];
void solve()
{
	cin>>n>>m;
	cin>>c+1;
	for (int i=1;i<=n;i++)
	{
		if (c[i]=='+') a[i]=1;
		if (c[i]=='-') a[i]=-1;
		if (!(i&1)) a[i]=-a[i];
		sum[i]=sum[i-1]+a[i];
	}
	while (m--)
	{
		int l,r; cin>>l>>r;
		if (sum[r]-sum[l-1]==0) {printf("0\n");}
		else if ((r-l+1)&1) {printf("1\n");}
		else printf("2\n");
	}
}
int main()
{
	ios::sync_with_stdio(0);
	cin>>T;
	while (T--) solve();
}

```