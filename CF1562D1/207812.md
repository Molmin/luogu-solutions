~~为什么CF这么喜欢构造和结论题……~~

一看样例明显是结论题。很显然，把“+”看成 $1$，“-”看成 $-1$，然后根据题目的要求做一遍前缀和，记为 $sum_i$。

如果连续出现两个相同的符号，则和为 $0$，所以本题真正有用的是连续两个不相同的符号。如样例的第一组“+--++---++-++-”，真正对前缀和做出贡献的只有“+-+-”。所以本题变成了：在做出贡献的符号中删去最少的符号，使得剩下的符号相同且有偶数个。每次删除一个符号时，剩下的符号的系数都会变成相反数。

因此在每次询问时，记询问的那一段的和为 $ans$。则：

+ $ans = 0$ 时，不用修改。

+ $ans$ 是奇数时，只需要修改一次。

+ 否则需要修改两次。

代码：

```cpp
#include <cstdio>
int t, n, q, sum[300003];//sum是前缀和数组
char s[300003];
int main() {
    scanf("%d", &t);
    while (t--) {
        scanf("%d%d%s", &n, &q, s + 1);
        for (int i = 1; i <= n; i++)
            sum[i] = sum[i - 1] + (i & 1 ? 1 : -1) * (s[i] == '+' ? 1 : -1);//处理前缀和
        while (q--) {
            int l, r, ans;
            scanf("%d%d", &l, &r);
            ans = sum[r] - sum[l - 1];//对ans的奇偶性讨论
            if (!ans)//情况1
                puts("0");
            else if (ans & 1)//情况2
                puts("1");
            else//情况3
                puts("2");
        }
    }
    return 0;
}
```