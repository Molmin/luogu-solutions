### 解题思路：

结论是这样的：对于一段区间，如果这一段区间本身就已经满足条件了，那么不需要动；否则根据区间长度判断结果，若为偶数则需要操作两次，奇数则只需要操作一次。

考虑如何证明这个结论：

首先发现，一个形如 $++$ 或 $--$ 的序列是一定不会影响最后的结果的，那么考虑将所有的这样的序列删去（这里可以感性理解为两个相同电荷碰到一起相互抵消），也就得到了形如 $+-+-+-+-...$ 这样的一个序列。

在这个序列中，若长度为奇数，则首尾相同，只需要删除正中间的哪一个节点就可以了。这样的话，两边的节点相互抵消，最后序列就“空了”，也就是得到了一个满足条件的序列。

而长度为偶数时，如果删去中间的那一个（中间靠左和中间靠右都可以），就会发现在这个序列的头或者尾（取决于删的是中间靠左的还是靠右的）上多了一个电荷，这个电荷无法消去，所以也得手动删掉。

---
### 代码：

```cpp
#include<cstdio>
using namespace std;
int T,n,num[300005],q,l,r;
char c;
int main(){
	scanf("%d",&T);
	while(T--){
		scanf("%d%d",&n,&q);
		for(int i=1;i<=n;i++){
			c=getchar();
			while(c!='+'&&c!='-')c=getchar();
			if(c=='+')num[i]=1;
			else num[i]=-1;
			if(i%2==0)num[i]*=-1;
			num[i]=num[i]+num[i-1];
		}
		for(int i=1;i<=q;i++){
			scanf("%d%d",&l,&r);
			if(num[r]-num[l-1]==0){printf("0\n");continue;}
			if((r-l)%2==0)printf("1\n");
			else printf("2\n");
		}
	}
	return 0;
}
```
