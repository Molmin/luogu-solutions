分类讨论一下。

如果一段奖牌全都是金牌，那么直接用这段奖牌的数量来更新答案即可。

如果是两段金牌中间夹了一块银牌 **并且** 在这两段金牌之外还有多余的金牌，那么我们就把中间这块银牌与多余的金牌交换位置，从而把两段金牌拼起来更新答案。

其他情况的话就不能更新答案了。

实现的话可以用前缀和快速求出一段金牌的数量，双指针扫一遍就行了。

核心代码：

```cpp
const int N=2e5+10;
int n,s[N],ans;//s为前缀和数组
char a[N];
signed main()
{
	cin>>n>>a+1;
	for(ri int i=1;i<=n;++i)
		s[i]=s[i-1]+(a[i]=='G');
	ri int l=1,r=1;
	while(r<=n)
	{
		while(s[r]-s[l-1]+1<r-l+1) ++l;//如果区间[l,r]之间银牌数量大于1显然是不合法的
		if(s[r]-s[l-1]+1==r-l+1&&s[n]-s[r]+s[l-1]-s[0])
			ans=max(ans,r-l+1);//两段金牌中间夹银牌的情况
		else if(s[r]-s[l-1]==r-l+1) ans=max(ans,r-l+1);//一段金牌的情况
		++r;
	}
	cout<<ans;
	return 0;
}
```