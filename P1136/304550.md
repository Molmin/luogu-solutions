### 我在这里提供一种新的做法（优化）

----
思路：

既然是 $DP$ ,那么从以下两个角度出发：

+ 我从哪里来？（当前状态可以由哪些状态得到？）

+ 我到哪里去？（当前状态可以去到哪几个状态？）

很容易的出楼上大佬们的状态：

设 $f[i][j][k][l]$ 表示考虑前 $i$ 位，交换 $j$ 次 $j$，$k$次 $z$ ，$l=0$ 表示当前位为 $j$，$l=1$表示当前位为 $z$，所得的最大 $jz$ 个数。

----

但是，我想了一想，这里可不可以优化一下，把后面的 $l$ 给去掉呢？

（去掉的话可以把空间复杂度降到原来的 $\frac{1}{2}$ 呢）。

所以设 $f[i][j][k]$ 表示考虑前 $i$ 位，交换 $j$ 次 $j$，$k$次 $z$，所得的最大 $jz$ 个数。


那我们考虑一下四种情况：

+ 扫到的子串是 $jz$:

这个时候不用交换，直接继承状态再加一，$i-2$ 是因为，我们扫的是一个 $2$ 位的字符串。

即是：$f[i][j][k]=f[i-2][j][k]+1$


+ 扫到的子串是 $zz$:

这时候需要交换一次，相当于将第一个字符变为 $j$ ，也就是要交换一次 $j$， 那么就有：

$f[i][j][k]=f[i-2][j-1][k]+1$

+ 扫到的子串是 $jj$:

思路同 $zz$ 情况，只是改变的位置不同，则有：

$f[i][j][k]=f[i-2][j][k-1]+1$

+ 扫到的子串是 $zj$:

这个时候只需要内部交换一下，所以 $j$ 和 $k$ 都要变化。所以有：

$f[i][j][k]=f[i-2][j-1][k-1]+1$

------

方程推出来了，自己理解一下，应该是可以写出来的了。

