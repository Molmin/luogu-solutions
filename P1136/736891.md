这道题思路不是很好想，~~我也是看了题解才会的菜死了~~。
## 题意概述
给你一个只有字母 $z$ 和 $j$ 的串和 $k$ 次任意交换两个字母的机会，让你求最后串中最多有多少个 $jz$。
## 思路概述
大部分人一开始想这道题可能想的是用 $f_{i,j,k}$ 表示交换了 $i$ 次，第 $i$ 次交换了 $j$ 和 $k$ 上的字母，所能得到的最多的数量，但是发现很难转移，因为没有记录之前修改的状态，（如果你每次都记录状态也不是不行，除非题目给你几个 $G$ 的空间），~~于是我就看了题解~~，于是应该想别的状态。

首先交换的一定是两个不同的字母，相同的字母交换没有意义。

而且最后的状态一定是有几个 $j$ 换成了 $z$ 就有几个 $z$ 换成了 $j$。

#### 重点：而且只要 $j$ 换成 $z$ 的次数和 $z$ 换成 $j$ 的次数一样，就一定存在这样的调换方案，因为 $j$ 和 $z$ 是随意调换。这样只需要关心修改了多少个 $j$，修改了多少个 $z$，最后答案在这两个次数相等的情况取即可。

明确了这些以后就可以设计状态了，上面说的不是废话，肯定需要记录当前多少个 $j$ 换成 $z$，多少个 $z$ 换成 $j$ 了，最后直接在这两个次数相等的情况取答案。因为是随便换的，所以前 $i$ 个字母中改了多少个 $j$ 和改了多少个 $z$ 对后边怎么改是没有影响的，且当前位只与前一位有关,因为 $jz$ 是两个字母。

状态表示: $f_{i,j,k,1}$ 表示前 $i$ 个字母改了 $j$ 个 $j$，改了 $k$ 个 $z$，且当前位目前是 $z$ 的最大数量， $f_{i,j,k,0}$ 表示前 $i$ 个字母改了 $j$ 个 $j$，改了 $k$ 个 $z$，且当前位目前是 $j$ 的最大数量。

初始化：先初始化为负无穷，否则可能会从某些根本不存在的情况转移过来，（比如第一位是 $z$，你如果不初始化，那么 $f_{1,0,0,0}$ 会是零，这样的话 $f_{2,0,0,1}$ 就会等于 $f_{1,0,0,0}$ 加一，很显然这种情况不存在，而你却统计了个 $1$ 出来），然后把第一位的所有状态都先写出来，可以参考我下面的代码

#### 还有，因为都是从上一位转移过来，所以可以滚掉一维，不然就超内存了

## code
#### 原代码
```cpp
#include<bits/stdc++.h>
using namespace std;

const int N=510;
int n,m;
char s[N];
int f[N][N][N][2];
int maxx;

int main()
{
	scanf("%d%d%s",&n,&m,s+1);
	memset(f,128,sizeof f);
	if(s[1]=='j')
	{
		f[1][0][0][0]=f[1][1][0][1]=0;
	}else 
	{
		f[1][0][0][1]=f[1][0][1][0]=0;
	}
	for(int i=2;i<=n;i++)
	{
		for(int j=0;j<=m;j++)
		{
			for(int k=0;k<=m;k++)
			{
				//j:
				if(s[i]=='j')f[i][j][k][0]=max(f[i-1][j][k][0],f[i-1][j][k][1]);
				else if(k>0)f[i][j][k][0]=max(f[i-1][j][k-1][0],f[i-1][j][k-1][1]);
				//z:
				if(s[i]=='z')f[i][j][k][1]=max(f[i-1][j][k][0]+1,f[i-1][j][k][1]);
				else if(j>0)f[i][j][k][1]=max(f[i-1][j-1][k][0]+1,f[i-1][j-1][k][1]);
				if(j==k)maxx=max(maxx,f[i][j][k][0]>f[i][j][k][1] ? f[i][j][k][0] : f[i][j][k][1]);
			}
		}
	}
	cout<<maxx;
	return 0;
}
```

#### 滚掉一维之后的
```cpp
#include<bits/stdc++.h>
using namespace std;

const int N=510;
int n,m;
char s[N];
int f[2][N][N][2];
int maxx;

int main()
{
	scanf("%d%d%s",&n,&m,s+1);
	memset(f,128,sizeof f);
	//初始化1的所有状态: 
	if(s[1]=='j')
	{
		f[1][0][0][0]=f[1][1][0][1]=0;
	}else 
	{
		f[1][0][0][1]=f[1][0][1][0]=0;
	}
	for(int i=2;i<=n;i++)
	{
		for(int j=0;j<=m;j++)
		{
			for(int k=0;k<=m;k++)
			{
				int d=i%2;
				//j:
				if(s[i]=='j')f[d][j][k][0]=max(f[1-d][j][k][0],f[1-d][j][k][1]);
				else if(k>0)f[d][j][k][0]=max(f[1-d][j][k-1][0],f[1-d][j][k-1][1]);
				//z:
				if(s[i]=='z')f[d][j][k][1]=max(f[1-d][j][k][0]+1,f[1-d][j][k][1]);
				else if(j>0)f[d][j][k][1]=max(f[1-d][j-1][k][0]+1,f[1-d][j-1][k][1]);
				if(j==k)maxx=max(maxx,f[d][j][k][0]>f[d][j][k][1] ? f[d][j][k][0] : f[d][j][k][1]);
			}
		}
	}
	cout<<maxx;
	return 0;
}
```