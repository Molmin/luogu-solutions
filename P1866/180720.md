luogu后台编号：$133811$

 _注：此题解之前已通过，但本蒟蒻发现有些地方因Markdown使用问题导致显示出来没有达到想要的效果，容易混淆，故略微修改_ 

**首先不得不说的事，这位出题者应该是为pascal选手。这一点在他出的另一道题中很清晰：[P1634](https://www.luogu.org/problemnew/show/P1634)**

这道题核心思想还是 **递推** 。

具体代码实现在另外几位大佬的题解中已经很清楚了，不过这里来仔细讲一下递推式推导的过程。

 _**首先要利用一个数学原理：乘法原理**大意如下：有两类元素，分别有m，n个，那么从两类里各取一个元素，共有$mn$种取法。_ 

假设一共有n只兔子，每个兔子想要的最大编号为$m_1$，$m_2$，。。。，$m_n$。我们先将其排序形成一个从小到大的有序数列。

我们先来看第1只兔子，很明显，这时有m1种方法。

这时又来了一只兔子，根据乘法原理， **这时的取法数应为 第一只兔子可能的取值×第二只兔子可能的取值。** 第一只兔子的取值共有$m_1$种，由于第一只已取了一个号，第二只不能再取这个号。所以第二只兔子的取值数共有$m_2-1$种。这时共有$m_1(m_2-1)$种取值。

我们将情况扩展到第n只兔子。

此时前$(n-1)$只兔子已取号完毕，共有s种情况，根据乘法原理， **这时的取法数应为 前（n-1）只兔子可能的取值×第n只兔子可能的取值。** 前n-1只兔子取走了n-1个编号，第n只不能再取这些号。所以共有$s(m_n-n+1)$种情况。

所以我们推完了递推式。

**那么什么情况下不可能实现编号呢？**

当$m_n-n+1<=0$时，第n只兔子可选的编号都被用过了，第n只兔子就没有编号可选了，这时就要输出0.

## 代码：
```cpp
#include <iostream>
#include <algorithm>//此库包含排序函数
using namespace std;
bool cmp(int x,int y)//比较函数，供排序函数使用（这里是从小到大）
{
	return x<y;
}
int n;
int m[51];
int main()
{
	cin>>n;//input
	for(int i=1;i<=n;i++)
	{
		cin>>m[i];
	}
	sort(m+1,m+n+1,cmp);//排序（用sort函数）
	long long s=m[1];//s记录取值数
	for(int i=2;i<=n;i++)//递推开始
	{
		if((m[i]-i+1)<=0)//判断是否出现上述情况，如果是，输出0.
		{
			cout<<0<<endl;
			return 0;
		}
		s*=(m[i]-i+1);//否则，递推
		s%=1000000007;//避免溢出
	}
	cout<<s<<endl;//output
	return 0;
}
```
