###      ~~话说编号不直接按1234编不就行了吗~~
###   这就是一道纯数学问题，~~各位不会连乘法原理都不知道吧......~~
####  好啦，首先理清一下思路，第一只兔子肯定有他需求喜好的个数种可能，第二只兔子有他需求喜好-1的个数种可能，以此类推，第n只兔子有他需求喜好-n+1的个数种可能。
#### 那问题来了，假设前一只兔子选的在这只兔子的编号喜好范围之外呢？那就不用-兔子数+1了，如果直接判断又太麻烦了，怎么办呢？好办，使用sort排序就行了。使用sort将需求少的兔子排前面，完美！
#### 首先是伪代码，代码构成能力强的可以找这些代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
  申明变量
  输入
  sort(数组名+开始下标，数组名+结束下标）
  for(...;i<=n;...)
  {
   种数乘需求个数-i+1
   种数求余
   }
   判断是否是负数或0，因为如果没得选的话乘数就会变成0或负数，那就要输出0
   否则输出种数
  return 0;
```
#### 接着是核心代码——for循环之内：
```cpp
for(i=1;i<=n;i++)
	{
		zs*=(xq[i]-i+1);//乘
		zs%=1000000007;//模
	}
```
#### 献上你们最爱的完整代码：
```cpp
#include<bits/stdc++.h>//万能头文件
using namespace std;
int main()
{
	int n,xq[51],i;
	long long zs=1;//这个很重要，记住，以后要求模都要开long long
	cin>>n;
	for(i=1;i<=n;i++)
	{
		cin>>xq[i];
	}//输入
	sort(xq+1,xq+n+1);//sort排序
	for(i=1;i<=n;i++)
	{
		zs*=(xq[i]-i+1);//乘
		zs%=1000000007;//就算开了long long也不保险,万一乘着乘着就爆了呢
	}
	if(zs<=0)//判断是否小于等于0，如果是就找不到任何办法排出编号，输出0
	{
		cout<<0;
	}
	else//反之，输出zs
	{
		cout<<zs;
	}
	return 0;
}
```
#### 最后，补充一点，sort排序如果像上面一样只能默认从小到大排序，如果要从大到小排序就要改排序语句并加一个函数
#### 语句：
```cpp
sort(数组名+开始下标，数组名+结束下标,函数名）
```
#### 函数部分：
```cpp
bool 数组名(int a,int b)
{
	return a>b;
}
```
#### 求过！求过！