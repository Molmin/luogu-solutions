# 前言
还是讲详细点好啊……
# Solution
光看题的话，~~像我一样的蒟蒻~~看不出什么名堂来。
当然根据题目规定的操作方法，我们很容易把这道题转义。

以样例数列 $-1,1,1,-1,1$ 为例。
### 第 $1$ 次操作

将第 $4$ 项，第 $5$ 项和为 $-2$：

$-1,1,1,-2$ 也就是 $-1,1,1,(-1-1)$。

### 第 $2$ 次操作

将第 $3$ 项，第 $4$ 项和为 $3$：

$-1,1,3$ 也就是 $-1,1,(1-(-1-1))$。

~~以下省略。~~

从以上的合并我们可以得出，原问题就等价于：给定一个由 $n$ 个数组成的数列，在每个数之间加上加号，减号**以及括号**，组成一个合法的表达式，求表达式的最大值。

样例数列 $-1,1,1,-1,1$ 的最大值就是 $-1+1+1-(-1-1)=3$ 。

但是我们突然想起来有加法结合律 $a+(b+c)=a+b+c$ ，减法的性质 $a-(b+c)=a-b-c$ 。

这样可以把这个表达式的所有括号去掉，而表达式仍然由原数列，加减号组成。

原问题就又等价于：给定一个由 $n$ 个数组成的数列，在每个数之间加上加号，减号，组成一个合法的表达式，求表达式的最大值。

这个时候，因为没有括号，我们就可以按照正常的计算顺序，从左到右依次计算了。

## 于是就回到了各大题解的熟悉配方
考虑当前的数 $a$ 和数列的下一个数 $b$ ：

如果 $b>0$ ，最大值为 $a+b$ ；

如果 $b<0$ ，最大值为 $a-b$ 。

总结成一句话：**加绝对值！**

注意在数列的第 $1$ 个数前面是没有符号的，那个位置就不能加绝对值而要保持原数，后面的所有位置，都可以加其绝对值。
#  AC代码
```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,a,i,ans;
int main()
{
	scanf("%lld",&a);
	scanf("%lld",&ans);  //此处就是对不能加绝对值的第一个数的特殊处理
	for(i=2;i<=a;i++)
	{
	scanf("%lld",&n);
	ans+=abs(n);
	}
	cout<<ans;
	return 0;
} 
```
最后奉劝一句话：**十年OI一场空……**