设 $f(x)=\mathrm{kmex}(\{a_i\},x)$（第 $x$ 小的不在 $\{a_i\}$ 中的正整数），则答案为 $f^k(x)$。如果 $a_i\le 10^5$，直接倍增即可。然而 $a_i\le 10^9$。

事实上有一个奇妙的性质：对于足够大的 $I$，区间 $[I,I+n)$ 在不停操作后经过的位置会不重覆盖 $[1,I+n)$ 所有值。证明应该挺简单，但很容易理解。

所以只需要对于某个 $[I,I+n)$ 快速模拟它在操作后的变化，可以维护出当前剩下的点所在的区间，设在 $a_i,a_{i+1}$ 之间，则往前操作（如果不经过 $a_i$，显然所有数都是减去 $i$）直到经过 $a_i$，这时暴力抠去在 $a_i$ 上的点。如果 $t$ 时刻区间经过了询问 $(x,k)$ 的 $x$，那么就是询问原区间内现在到了 $x$ 的那个数，在 $t-k$ 时刻在哪里。

把所有询问都变成：$x\in[I,I+n)$ 在 $t$ 时刻在哪里 这种形式之后，重新模拟一遍所有操作便能回答询问。总复杂度单 log。（不需要树状数组之外的数据结构：开一个 $[1,n]$ 的树状数组维护开始的那 $n$ 个位置哪些被抠掉了即可。

这个题并不是 consider it backwards；它就是直接 consider it forwards，但第一个结论发现才是关键。