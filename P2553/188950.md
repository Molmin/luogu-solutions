本题主要考查的是字符串处理。

***

题目有**多组数据**，每一组数据都是一个多项式或者一个多项式乘法。为了方便，下文统称“表达式”。

因为在表达式中可能存在空格，所以直接在字符串里递归要处理的细节会比较多，而我们就采取逐字符处理的方式计算。根据题目所说，**只会存在一个** `*` **号**，因此考虑分左右半边处理。

如果要对这个表达式进行计算，必然要分离出每一个项，这些项包含系数与指数，是解题所需要的。如果舍去常数项（即 `2a^2+5` 中的 `5`），不难发现，每个项被 `a^` 这两个字符分成了系数与指数两部分，如下图所示：

![](https://i.bmp.ovh/imgs/2022/01/220d960b3d958b6d.png)

利用好这个特征就不难分离系数和指数。

接下来加入对常数项的处理。常数项与非常数项最大的区别就在于**数字后面紧跟着的字符是否是字母**，也就是说，读入一个数字之后，可以判断一下其后面的字符是否为 `a`，如果是则为非常数项，否则为常数项。

这就是逐字符处理的难点，但是还要注意一些细节：

- 当读入乘号 $*$ 的时候，说明已经由左半边到了右半边。这可以使用一个标志变量来解决；
- **不需要**读入其他的符号，比如加号 $+$ 和括号。因为本题只会出现两个多项式相乘，并且多项式内部一定不会出现乘法，判断 $*$ 已经足够分辨左右半边；
- 对于每一个表达式，要重置上一个表达式遗留下来的无效数据。

当分离出了系数和指数之后，就可以进行卷积了。本题的数据范围是 $n \leq 30$，数据很小，暴力卷积也可以通过此题。

（虽然数据小，但是不知道表达式的数量有多少，为了避免可能的超时，还是采用了 FFT。）

关于 FFT 的算法介绍有很多，在这里就不展开详细讲述了，可以到[【P3803 】](https://www.luogu.com.cn/problem/P3803)进行相关练习。主要精力将会集中在如何处理输入串上，完整代码请到[剪贴板](https://www.luogu.com.cn/paste/4syjwduo)查看：

```

int main() {
	string s;
	int x = 0, y = 0;
	bool side = false;
	while(getline(cin, s)) {
		n = m = 0;
		side = false; // side 为 false 表示左边，反之为右
		memset(f, 0, sizeof(f));
		memset(p, 0, sizeof(p));
		for(int i = 0; i < s.length(); i++) {
			x = 0, y = 0;
			if(isdigit(s[i])) { // 发现数字
				while(isdigit(s[i])) { // 一直读入数字，读到不是数字为止
					x = x * 10 + (s[i++] - '0'); // 转化为数字
				}
				if(s[i] == 'a') { // 发现下面一个字符为字母，说明是非常数项
					i++; i++; // 跳过 'a' 和 '^' 
					while(isdigit(s[i])) { // 同理，一直读入指数
						y = y * 10 + (s[i++] - '0');
					}
					i--; // 由于现在 s[i] 是第一个非数字字符，需要回退来方便下一次处理
				}
				if(!side) {
					n = max(n, y);
					f[y].x += x; // 可能存在没有同类项合并的情况
				}
				else {
					m = max(m, y);
					p[y].x += x;
				}
			}
			else if(s[i] == '*') { // 发现乘号，左边转移到右边
				side = true;
			}
		}
		run(); // 执行 FFT 函数并且输出，详细见剪贴板
	}
	return 0;
}

```

最后，这份代码是经过了三次重构后的最终 AC 代码，所以大家写代码的时候一定要有一颗持之以恒的心~

求通过~

