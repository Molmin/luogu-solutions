## 题意

在 $n \times m$ 的网格中放置 $k$ 颗石子，求有多少个四边形恰好四个角上都放了石子。

## 思路

### 解法一：暴力枚举

这一道题目看似简单，但是如果我们直接使用暴力枚举的方法来做，当 $N$ 和 $M$ 较大时，时间复杂度将会达到 $O(N^2 M^2 K)$，代码将会超时。

### 解法二：枚举长方形

一个长方形需要四个顶点的支持。考虑枚举这四个顶点，以左下角的点为例，如果左下角的点是 $(i, j)$，那么这个长方形的右上角就是 $(p, q)$，其中 $i≤p≤N$，$j≤q≤M$。枚举四个点的复杂度是 $O(N^2M^2)$，因此时间复杂度仍然达到了 $O(N^2M^2K)$，无法通过本题。

### 解法三：用前缀和优化枚举

我们可以先预处理出一个前缀和数组，以便我们在 $O(1)$ 时间内计算出石子数量。

设 $s_{i,j}$ 表示 $(1, 1)$ 到 $(i, j)$ 这个矩形内的所有石子数量的总和。

接下来，我们枚举这个长方形的左下角 $(i, j)$，并枚举右上角 $(p, q)$ 的位置。

如果 $(i, j)$ 和 $(p, q)$ 的行数或列数相等，则说明 $(i, j)$ 和 $(p, q)$ 已经在同一行或同一列上了，此时不能构成一个长方形。

因此我们只需要枚举左下角和右上角的位置，满足 $(i, j)$ 和 $(p, q)$ 的行数和列数不相等，然后用前缀和计算出 $(i, j)$ 和 $(p, q)$ 之间有多少个石子。

时间复杂度为 $O(N^2M^2)$。

### 解法四：用哈希表优化枚举

我们可以使用哈希表来存储每个矩形 $(i, j, p, q)$ 中石子的数量。枚举所有可能的矩形并用哈希表记录石子的数量。由于哈希表的查找是 $O(1)$ 的，因此总时间复杂度为 $O(N^2M^2)$。

------------
但是我们会悲催的发现，这复杂度都高到没边儿啊……

所以，请出我们的数学大神！
### 解法五：数学推导
首先可以证明，一个只有一个缺口的石子阵可以摆成接近矩形的形状，而且在这种情况下，放新的石子到缺口处可以让新石子和其他 $9$ 个位置的石子组成一个矩形，而在其它位置放新石子不能组成矩形。

接着可以推导出一个 $n \times m$ 的矩形石子阵有多少个不同的矩形。具体地，可以将每个矩形的右下角作为基准点，然后枚举左上角，这样每个右下角有 $i \times j$ 个左上角与之对应，从而有以下式子：

$$\sum_{i=1}^{n}\sum_{j=1}^{m}(i \times j)$$

将其展开得到：

$$\sum_{i=1}^{n}(i \times \sum_{j=1}^{m}j)$$

继续展开，可以得到：

$$\sum_{i=1}^{n}(\frac{i \times m \times (m+1)}{2})$$

化简后得到：

$$\frac{m(m+1)}{2} \times \frac{n(n+1)}{2}$$

这个式子可以用类似二维前缀和的方法计算一个不是矩形的石子阵。

最后，枚举不完全矩阵的长度，分别计算即可。
### 代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
inline ll read(){
    ll x=0,f=1;
    char c=getchar();
    while(c<'0'||c>'9'){
        if(c=='-')
            f=-1;
        c=getchar();
    }
    while(c>='0'&&c<='9'){
        x=(x<<1)+(x<<3)+(c^48);
        c=getchar();
    }
    return x*f;
}
inline void write(ll x){
	if(x<0){
		putchar('-');
		x=-x;
	}
	if(x>9)
	  write(x/10);
	putchar(x%10+'0');
}
ll n,m,k,x=0,y=0,t,a,b;
int main() {
	n=read(),m=read(),k=read();
	if(!k){
		write(0);
		exit(0);
	}
	if(n<m) 
	  swap(n,m);
	a=(sqrt(k)>m?m:sqrt(k)),b=(k/a>n?n:k/a);
	for(;a>=2&&b<=n;--a,b=k/a){
		y=a*(a-1)*b*(b - 1) >> 2;
		t=k-a*b;
		if(t>1)
		  y+=(b<n?(t*(t-1)*b)>>1:(t*(t-1)*a)>>1);
		x=max(x,y);
	}
	write(x);
	return 0;
}
```
大家要自己推一遍哦，不要直接“盲目”的复制提交……