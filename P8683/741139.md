### 思路（详细！）

如果 $M$ 是 $0$ 则没有减号，全是加号，全加起来即可。如果 $M$ 大于 $0$ 我们从后缀表达式特征入手：以二叉树后序遍历顺序描绘，则很明显有下面的特征。当我们将新的数放到左子树上且新的符号为负数时，会将原有的数据全部取反。因此，对于 $M$ 个负号，我们可以构造出 $1$ 到 $M$ 个负号，而如果在负号的过程中加入了加法，那么相当于括号外是减法，括号内是加法，去括号后，加法也能变成减法，从而增加了负号的数量，因为有 $N$ 个加号，故而可以增加 $0$ 到 $N$ 个负号，所以 $N$ 个加号和 $M$ 个减号可以构成 $1$ 到 $N+M$ 个负号因为有 $N+M+1$ 个数，而可以构造的负号数范围在 $1$ 到 $N+M$，所以至少会减一个数，至少会加一个数，为了使结果最大，我们应该减去最小的数，加上最大的数，也就是将序列排序后的序列两端，减去左端，加上右端。

而序列中间的数，依据这个特征，我们的数据负号实际上可以自由更改加减，又因为题目要求求最大值，则我们只需要根据以上反转的特性，合理构造负号，利用一个负数将多个负数都尽可能转换为正值，也即将序列中负数前面的符号构造为负号，以负负得正，正数前面就是加号，最后的效果其实就是序列中间的数全部取绝对值。

从而我们就能得到最优代码。

### 代码
```
#include <bits/stdc++.h>
using namespace std;
const int N = 2e5 + 10;

long long cnt;
int main() {
	int a[N];
	int n, m;
	cin >> n >> m;
	for (int i = 0; i < n + m + 1; i++)
		cin >> a[i];
	if (m == 0) {
		for (int i = 0; i < n + m + 1; i++)
			cnt += a[i];
	} else {
		stable_sort(a, a + n + m + 1);
		cnt -= a[0];
		cnt += a[n + m];
		for (int i = 1; i < n + m; i++)
			cnt += abs(a[i]);
	}
	cout << cnt << endl;
	return 0;
}
```