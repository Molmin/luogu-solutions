咳咳,这里介绍一种稀奇古怪的解法，可以处理m很大时候的问题哦~~（开个小玩笑QAQ，理论上m<2^63或更大,需要再加一点小优化~）~~

首先我们不难看出题意，给定一个1~n的排列，求比这个排列在全排列中的次序（构成的n位数的大小，这算字典序嘛。。）大m的另一个排列;

容易想到的做法是连续m次使排列的次序加1，楼下各位已经讲的很全面了，这里不再赘述——-

不过，既然唯一的次序对应唯一的排列，我们当然也可以建立两个映射，一个将次序映射向排列，另一个反向即可;

那么开始一波胡乱分析....


------------


- **从排列向次序的映射**

事实上，1~n共有n!种排列，每个排列在全排列中对应唯一的次序，我们这里以n = 5为例：

5
1 2 3 4 5

这个排列的次序是1

显然，n <= 10000时遍历是不可行的，在n = 12时，全排列共有479001600种，已经超过了时空界限;

现在我们看看排列的内容是如何体现次序的：

如果我们在第一个位置填1，那么剩余的4个位置有 4! = 24 种填法；这意味着当我们将2作为第一个元素时改排列的次序下界为 4!+1 ;同理，3开头时下界为 2\*4!+1 ..以此类推;

而假设我们固定3为第一个元素，剩余的4个数为1 2 4 5,排列的次序在 2\*4!+1 ~ 3\*4! 之间；这时我们发现，如果在第二个位置填1，则对次序下界无影响，若填2，则下界

增加 3! ,填4则增加 2\*3! ...以此类推

值得注意的一点是，此时由于4是剩下的数中第3大的，所以填4时不再使下界增加 3\*3! ,而是 2\*3! ,也就是4代替了原来3的位置，这说明下界的增量仅与所填数在当前所剩数中的大小序数有关；

很显然，若我们已填好i个数，剩余的数为n-i，那么在填第i+1位置时，若我们使用的数在剩余的数中排列的序数为j（1<=j<=n-i）,则会使下界增加 j\*(n-i)! ,此处我们计0!为1；

问题转化为**求排列中的每一个数在从当前位置到数组尾这个序列中的序数**，依次累加下界，当累加到数组尾时，显然**上界 = 下界 = 次序**；在这个问题中，我们每确定一个数的序数，

需要将比该数大的所有数的序数－1，也就是区间修改，单点查询，参见：[模板]树状数组2；

例如排列 3 4 1 5 2 处理后的数据为 3 3 1 2 1 ，代表着次序为2\*4! + 2\*3! + 0\*2! + 1\*1! + 0\*0! + 1 = 62的排列；

- 累加问题

目前我们的目标为次序为62+m的排列，观察一下次序的计算方法，我们不难看出这是一种加法(认为33121是一个5位数)，对于第i位采取i+1进制，即满i+1进1(每一位至少为1)；

将m也处理成阶乘形式:以 m = 35 为例，m = 4! + 3! + 2\*2! + 1!;

累加后得到新的次序序列: 4 4 3 3 1

从后往前处理一遍，满i+1进1，第i位向前进位后减去的数为i: 5 1 1 1 1

- 从次序到排列的映射

我们建立一个1~n的优先队列。。初始时每个元素的值为元素的序数，显然我们在取掉某个数之后，其后的元素序数加1；

不过，这个队列是无法用简单树状数组做的。。(这里我就不介绍什么平衡树和离散化树状数组了= =)

干脆打个标记依次选取好了，由于常数很小和上述算法的优化，最后一步（n^2）也没什么关系（无需O2~）；


------------


接下来贴代码咯

```cpp
    #include<cstdio>
    #include<cstring>
    #include<algorithm>
    #include<cstdlib>
    using namespace std;
    int n,m,t;
    int v[10005],trv[10005],ord[10005],ans[10005],chan[10005];
    int read()
    {
        char ch = getchar();
        int re = 0;
        while(ch<'0'||ch>'9') ch = getchar();
        while(ch>='0'&&ch<='9')
          {
              re = (re<<3) + (re<<1) + ch - '0';
              ch = getchar();
          }
        return re;
    }
    int lowbit(int x)
    {
        return x&-x;
    }
    void add(int loc,int x)
    {
        while(loc<=n)
          {
              trv[loc]+=x;
              loc+=lowbit(loc);
          }
    }
    int vfind(int loc)
    {
        int re=0;
        while(loc>=1)
          {
              re+=trv[loc];
              loc-=lowbit(loc);
          }
        return re;
    }
    void solve(int re)
    {
        if(re == 0) return;
        int sta=1,cnt=0;
        while(sta<=re) {cnt++;sta*=cnt;}
        sta/=cnt; chan[++t] = cnt-1;
        changeit(re-sta);
    }
    int main()
    {
        int del;
        n = read(); m = read();
        for(int i=1;i<=n;++i) {v[i] = read();add(i,1);}
        for(int i=1;i<=n;++i) 
          {
            ans[i] = vfind(v[i]);
            add(v[i],-1);
```
}//提取出原排列的选取序
```cpp
        solve(m);//拆分m 
        for(int i=1;i<=t;++i) ans[n-chan[i]]++;//模拟进制式加法
        for(int i=n;i>=1;--i)
          while(ans[i] > n+1-i)
              {ans[i-1]++; ans[i] -= n+1-i;}//制表出新排列的选取序
        bool vis[10005] = {false};
        for(int i=1;i<=n;++i)//n^2水一水~ 
          {
              for(int j=1,ord=0;i<=n;++j)
                {
                    if(!vis[j]) ord++;
                    if(ord == ans[i]) {vis[j] = true; ans[i]=j;break;}
              }
            printf("%d ",ans[i]);
          }
        return 0;
}
```