放在最前面：暴力求叉或证明时间复杂度的正确性。

***

提供一种在线的很简单的不费脑子的~~但是不知道正确性的~~方法。（仅供参考）

首先，既然是在线的，我们容易想到对于每个 $k$，进行一次尺取法，那么显然，我们对于 $[l,r]$ 的指针，在无解的情况下可以移动 $O(n)$ 次，所以最坏复杂度 $O(nm)$。

考虑优化。

***

优化 $1$：当 $k$ 比较大的时候，直接从左往右移动 $r$ 的时间复杂度开销比较大，所以可以考虑在尺取前记录一个数组 $S$ 表示价格的前缀和。因为 $S$ 具有单调性，那么我们就可以直接二分找到 $l=1$ 时对应的左端点。

此时最坏的时间复杂度仍然是 $O(nm)$。

***

优化 $2$：发现此时 $r$ 的移动优化了，我们可以考虑直接优化 $l$ 的移动或者直接移动 $[l,r]$ 这个整体。

记 $c_i$ 表示 $i$ 及 $i$ 后共 $c_i$ 个元素与 $i$ 相同，$s_i$ 为第 $i$ 个字符所对应的值。

此时仍然是 $l=1$ 时求出 $r$，但是 $r$ 应该要保证 $S_r-S_{l-1}<k$ 且 $S_{r+1}-S_{l-1}\ge k$。

此时我们对不同的情况进行分类讨论：

第一种情况：只移动 $r$。

由于 $S_{r+1}-S_{l-1}\ge k$ 且 $s_i$ 的价格一定是有值的，于是 $S_{r+2}-S_{l-1}>k$，所以我们扩展右端点时最多扩展一个元素。如果 $S_{r+1}-S_{l-1}$ 即 $[l,r+1]$ 的和为 $k$，那么此时 $[l,r+1]$ 显然为可行解。

此时我们只移动 $r$ 是显然不可能的了，因为 $S_r-S_{l-1}<k$。并且此时能保证 $S_r-S_{l-1}=k-1$。因为 $S_r-S_{l-1}$ 只能为 $k-1$ 或 $k-2$，但是当 $S_r-S_{l-1}=k-2$ 时，若 $s_{r+1}=1$，那么 $r$ 可以继续向右移动，若 $s_{r+1}=2$，那么此时我们就在只移动右端点的情况下特判掉了。同时，当 $S_r-S_{l-1}=k-1$ 时，若 $s_{r+1}=1$，那么也会被特判掉，于是 $s_{r+1}=2$。此时，若只移动 $l$，那么 $S_{r}-S_{l}\ge2$，是可以取 $s_{r+1}$ 的，所以我们不能只移动 $l$。于是，我们考虑移动 $[l,r]$ 这个整体。

因为 $s_{r+1}$ 已经确定了，所以可以对 $s_l$ 进行分类讨论。

第二种情况：$s_l=2$。

因为同时移动 $l,r$ 会使 $[l,r]$ 的和不变，容易发现为了保证 $S_r-S_{l-1}=k-1$ 的特殊性质，我们只能将 $[l,r]$ 移动相同的数。

此时，我们移动 $\min\{c_l,c_{r+1}\}$ 次后，才暂时不会出现这种情况，所以我们此时可以直接 $val=\min\{c_l,c_{r+1}\},l\gets l+val,r\gets r+val$。

第三种情况：$s_l=1$。

此时注意到 $S_r-S_{l-1}=k-1$，由于 $s_{r+1}=s_l+1$，所以 $S_{r+1}-S_l=k$，那么此时 $[l+1,r+1]$ 就是一组可行解。

时间复杂度？

最坏的话个人认为是 $O(nm)$，但是实际上远远跑不满，~~清纯少女~~ tzl 认为这个东西的时间复杂度是 $O(m)$ 乘上一个大常数，这个意见保留。时间复杂度姑且记作 $O(km)$ （$k$ 是大常数），暂时不知道最坏能不能卡到 $O(nm)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=1e6+5;
int n,m,k,c[maxn],mp[26],S[maxn];
string s;
inline void work(int x){
	int l=1,r=lower_bound(S+1,S+n+1,x)-S-1;
	while(r<n){
		if(S[r+1]-S[l-1]==x){
			printf("%d %d\n",l,r+1);
			return;
		}
		if(s[l]==s[r+1]){
			int val=min(c[l],c[r+1]);
			l+=val,r+=val;
		} else{
			if(s[l]=='T'){
				int val=min(c[l],c[r+1]/2);
				l+=val,r+=val*2;
			} else{
				printf("%d %d\n",l+1,r+1);
				return;
			}
		}
	}
	puts("NIE");
}
int main(){
	mp['T'-'A']=2,mp['W'-'A']=1;
	scanf("%d%d",&n,&m);
	cin>>s;
	s=' '+s;
	c[n]=1;
	for(int i=1;i<=n;++i)
		S[i]=S[i-1]+mp[s[i]-'A'];
	for(int i=n-1;i;--i)
		if(s[i]==s[i+1])
			c[i]=c[i+1]+1;
		else
			c[i]=1;
	while(m--){
		scanf("%d",&k);
		work(k);
	}
	return 0;
}
```