看到没有大佬发题解,本蒟蒻来水一发题解.

一看这道题,直接给人的感觉就是用斐波那契数列建图,然后求最近公共祖先(我旁边的同学真的是这么做的,花了半晚上找了规律建了图,又调了一会lca,最后三个点RE 70分)

但按照惯例,noip第一题不应该是普及-的难度吗,所以蒟蒻的我自然不会往lca上考虑(其实是不会....),如果仅仅只是普及难度的话,应该只用斐波那契数列就能A掉,带着这个想法,我们开始看题干给出的图;

通过观察,我们不难发现,孩子与父亲直接的差值是一个斐波那契数列里面的数,准确一点的规律似乎我没有用到,给你们贴过来    (第i个月出生的第j只图子的编号为fei[i-1]+j,他的father为j,fei表示斐波那契数列;)本蒟蒻只是发现每一个子节点减去一个刚好小于他的编号的斐波那契数列的值,得出的结果就是他的father；

输入进一组数据之后，找到较大的那个，只需要枚举出刚好比他小的那个斐波那契数列的值，减去那个值，让他往上跳，让这个节点往上跳，类似于暴力lca一步一步跳，但这棵树的深度不超过60（可以自己算一下），所以暴力跳并不超时；

##蒟蒻代码贴在这里

```cpp
//by   我是大傻逼 
#include<iostream>
#include<cstdio>
using namespace std;
long long fei[71],answer[301010],m,z;//fei表示斐波那契数列,answer为结果,m为方案数,z为answer的个数; 
int main()
{
    scanf("%lld",&m);
    fei[1]=1;fei[2]=1;
    for(int i=3;i<=70;i++)
        fei[i]=fei[i-1]+fei[i-2];
    //算出斐波那契数列 ,不过好像不需要到70就过了1e12了,但是无所谓了,对复杂度影响不大; 
    for(int i=1;i<=m;i++)
    {
        long long a,b;
        scanf("%lld%lld",&a,&b);
        long long q,w,e=a,r=b;//q,w为枚举用的指针,e,r分别表示两个要找lca的节点目前跳到了那里; 
        //别问我为什么用q w e r作变量; 
        while(e!=r)
        {
            if(e>r)
            {
                for(q=1;q<=70;q++)
                    if(fei[q]>=e)    break; 
                //这一句其实可以用二分优化,不过好像对复杂度影响不大,我懒得写了;    
                e-=fei[q-1]; //找到刚好比他小的数,并一步一步往上跳; 
            }
            if(e<r)
            {
                for(w=1;w<=70;w++)
                if(fei[w]>=r)    break;
                r-=fei[w-1];
            }//同上; 
        }
        answer[++z]=e;//当两者相等时,即找到了最近公共祖先,记录答案; 
    }
    for(int i=1;i<=z;i++)
        printf("%lld\n",answer[i]);
    //输出; 
    return 0;
} 
```


