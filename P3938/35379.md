看完这道题，我深思许久，终于找到了这道题的规律

每一个子节点和父节点的差都是一个斐波那契数，且这个数比他的父亲节点和他父亲节点的父亲节点的差和，他父亲的父亲……就是他父亲到节点1的路径上的所有差值的和都要大（也就是他父亲节点的编号-1的值），因为这个子节点和父亲节点的差的斐波那契数包含了前面的所有差，因为它是由前面的数推来的，所以，只需要找斐波那契中最大的但是比他小的那个数就好了（不能等于！他总不能是0节点的儿子吧！），然后减掉，慢慢往上找就好了。





```cpp
#include <cstdio>
#include <cstring>
int n;
long long a[110];
int main()
{
    scanf("%d",&n);
    a[0]=a[1]=1;
    for(int i=2;i<=59;i++)//差不多到10^12就好了
    a[i]=a[i-1]+a[i-2];
    for(int i=1;i<=n;i++)
    {
        long long x,y;
        scanf("%lld %lld",&x,&y);
        while(x!=y)
        {
            if(y<x)//只对较大的数做处理，也就是比较深的那个，把他放到y中
            {
                long long t=x;
                x=y;y=t;
            }
            int l=1,r=59;
            while(l<=r)//优化，二分查找
            {
                int mid=(l+r)/2;
                if(a[mid]<y)l=mid+1;
                else r=mid-1;
            }
            y-=a[l-1];//减一是因为上面l=mid+1，所以他肯定比我们要的那个大1，那假如根本就没执行过l=mid+1呢？也就是说一直满足a[mid]>y的条件，那么l最后的值一定为1，其实f[1]和f[0]的值一样，所以这里减一并不会影响结果
        }
        printf("%lld\n",x);
    }
}
```