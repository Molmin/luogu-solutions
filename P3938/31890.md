其实这道题是一道数学题,跟图论LCA之类的一点关系都没有.

虽然据说有JuLao用各种优化AK了,不过写LCA的大部分都炸了,所以还是安安心心数学推理吧.

求编号为A,B的兔子的LCA,可以先求出各自的各辈祖先.

根据Fibonacci数列,最高辈分不会超过61辈,那么求出来后随便怎么暴力都行.

至于存放各自祖先的容器,个人感觉开两个vector<龙龙>就行了.

那么问题来了:怎么求各辈祖先?

首先预处理出Fibonacci表,前两个元素0,1不要了,或加特判.

在容器中加入A.

不难发现,A兔子的父亲编号为C,C==A-Fibonacci[K],K满足(Fibonacci[K]<A&&A<=Fibonacci[K+1]).

那么首先一个O(log(logA))二分查找,其实用O(logA)暴力查找也是很容易过的,找到他的父亲.

在容器中加入C.

为了尽量做到最优,接下来不用O(log(logA))的二分查找,而是O(1)的暴力查找.

由于Fibonacci数列的性质,必然有(Fibonacci[K-1]<C&&C<=Fibonacci[K]).

那么C兔子的父亲编号为D,D==C-Fibonacci[K-1],就这样直到找到最高祖先(编号为1的兔子).

在容器中加入D.

就这样以此继续暴力查找A兔子的祖先们.B兔子同上.

两次总时间复杂度O((logA-1+log(logA))+(logB-1+log(logB)))即为O(LogA).

然后从各自的最高辈(即容器顶)比较,过程很简单就一句带过.

找到不一样的就输出他们的祖先(一定是同一个).

若其中一个的容器找完了还没找到,即一个是另有规定祖先,那就输出该容器底.

比较的时间复杂度O(log(min(A,B)+1))即为O(LogA).

全题O(mlogA),用了数学方法后拿几个特殊条件可以高傲地无视.

另:重要:

一定要开long long!!!!!

不然会像我一样卡在70分DeBug几个小时还找不出错.
