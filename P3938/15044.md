看到没人贴代码，本蒟篛就过来贴一波我的,写的不好看，大佬表喷的太厉害、、、

#本题关键就是要推出父亲和儿子的关系

因为有了这个关系就可以让两个点一步一步往父亲那里找，直到两个点是相同时说明就是最近公共祖先了

首先每个月兔子出生后，所有兔子的数量用一个数组**f[i]**表示，那么不难发现f[i] = f[i-1] + f[i-2]也就是斐波那契数列（相当于上个月兔子数量加上 上上个月兔子 的数量（只有上上个月的兔子长大了又生育能力。。。））。然后我们就要去找儿子和父亲的编号的关系了。

然后我们发现儿子和父亲的编号我们不能记录下来（a\_i最大有10……12）,所以我们只能在线查询。设某个儿子编号为**x**，那么易的他的父亲的编号为**x-f[i]**,其中f[i]为小于x的最大的那个数。举个栗子，第3月有一堆兔子，1，2，3，4，5；2是第一个月出生的兔子，3是第2个月出生的兔子，4和5是第3个月出生的兔子，那么4这个兔子的父亲其实就等于4-f[i]，f[i]就等于3，说明1是4的父亲。为什么是这样的呢？首先我们发现4和1，5和2是一一对应关系，而他们的距离其实就是上个月兔子的数量，所以说一个兔子的父亲编号其实就是该兔子编号减去上个月兔子的数量，即x-f[i]，其中f[i]是上个月兔子的数量，但是我们也不会记录每个兔子是哪个月出生的，所以我们用二分查找一个最大的f[i]，使得f[i]小于x,就是父亲的编号了。

那么有了父亲的编号，我们就可以往回查找了。

这里我同时记录的该点的辈分，也就相当于深度这个东西，至于这个辈分怎么求，其实就是刚才求到的f[i]的i

如果a的深度大就让a往上调，如果b的深度大就让b往上跳，否则一起往上跳，直到两个点是同一个点就停止并且返回相同时的答案

对了不要混用数据类型，会错掉。。。还有本蒟篛真的感觉这个绿题比别的绿题更难想更难写。。

...cpp
```cpp
#include <cstdio>
#include <iostream>
using namespace std;
typedef long long LL; // 定义一个数据类型，简化程序 
LL f[61],x ,y;
int i , m ;
int ef(LL x){                        //二分查找上个月兔子的数量，也就是比他小的最大值f[i] 
    int l = 1,r = 60,mid=60;    
    while(l<=r){
        mid = (l+r) / 2;
        if(f[mid] >= x)
            r = mid - 1;
        else
            l = mid + 1;
    }
    while(f[mid] >= x)
        mid -- ;
    return mid;                    //返回的是该点的辈分 也就是f[i]中的i 
}
LL lca(LL x,LL y){            
    if(x == 1 || y == 1)    return 1;        //特判的话可以骗分。。 
    if(x == y+1 || y == x+1) return 1;
    int depx,depy;
    depx = ef(x);        //得到这个点的辈分（深度） 
    depy = ef(y);
    while(1){
        while(depx != depy){        //如果两个点深度不同就让深度大的点往上跳 
            while(depy>depx && y!=1){
                y -=f[depy];    
                while(depy>0 && f[depy] >= y)    //跳完只有要再找f[i]也就是方便下次跳，为什么不是他的上一辈？呵呵，你的祖先一直在生产。。鬼晓得你是哪一辈，所以还是暴力找f[i] 
                    depy--;
            }
            while(depx>depy && x!=1){
                x -= f[depx];
                while(depx>0 && f[depx] >= x)
                    depx--;
            }
            if(x == y)        // 如果这里已经找到了就返回这个值 
                return x;
        }
        while(x != y){            //如果两个是同一辈的，就一起往上跳 
            if(x!=1){        // 1不用跳。。。 
                x = x-f[depx];
                while(depx>0 && f[depx] >= x)    
                    depx--;    
            }    
            if(y!=1){
                y = y-f[depy];
                while(depy>0 && f[depy] >= y)    
                    depy--;
            }
            if(depy != depx)    // 如果发现跳着不是同一辈了就再退出返回上面那个不是同一辈的查找 
                break;
        }
        if(x == y)
            return x;
    }
}
int main(){
    scanf("%d",&m);
    f[0] = 1;
    f[1] = 1;
    f[2] = 1;             //初始化 
    for(i = 3;i <= 60; i++)        //f[60] > 10……12，够用 
        f[i] = f[i- 1] + f[i- 2];
    for(i = 1;i <= m; i++){
        scanf("%lld%lld",&x,&y); 
        printf("%lld\n",lca(x,y));//在线查询 
    }
    return 0;
}
...cpp
```