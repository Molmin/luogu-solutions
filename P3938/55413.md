本来这题后三个点我是过不了的


开O2后AC


这题。。。。看眼数据范围就知道是数学题了（掩面


手动列一下各点的爹：


1 2 3 4 5 6 7 8 9 10 11 12 13


1 1 1 1 2 1 2 3 1 2 3 4 5


你会发现，就是个斐波那契。。。。。。


然后，因为fib是指数级增长的，所以打一下fib小于1e12的前缀和的表：


ll biao[59]={0,3,4,6,9,14,22,35,56,90,145,234,378,611,988,1598,2585,4182,6766,10947,17712,28658,46369,75026,121394,196419,317812,514230,832041,1346270,2178310,3524579,5702888,9227466,14930353,24157818,39088170,63245987,102334156,165580142,267914297,433494438,701408734,1134903171,1836311904,2971215074,4807526977,7778742050,12586269026,20365011075,32951280100,53316291174,86267571273,139583862446,225851433718,365435296163,591286729880,956722026042,1548008755921};


然后查找的时候只要二分:biao[mid]<=a<biao[mid+1]就可以了，复杂度log


后面的话用set维护链，爬链查找就可以了


注意要及时退出，并且清空set


附AC代码：



```cpp
#include<cstdio>
#include<iostream>
#include<set>
#define ll long long
using namespace std;
template<typename T>
inline void read(T &x){
  char ch;while((ch=getchar()),(ch>'9'||ch<'0'));
  x=ch-'0';while((ch=getchar()),(ch>='0'&&ch<='9')) x=x*10+ch-'0';
}
int m;
ll biao[59]={0,3,4,6,9,14,22,35,56,90,145,234,378,611,988,1598,2585,4182,6766,10947,17712,28658,46369,75026,121394,196419,317812,514230,832041,1346270,2178310,3524579,5702888,9227466,14930353,24157818,39088170,63245987,102334156,165580142,267914297,433494438,701408734,1134903171,1836311904,2971215074,4807526977,7778742050,12586269026,20365011075,32951280100,53316291174,86267571273,139583862446,225851433718,365435296163,591286729880,956722026042,1548008755921};
inline ll find(ll a){
    if(a==1||a==2||a==3||a==4) return 1;
    int l=0,r=58,mid;
    while(l-r){
        mid=l+((r-l)>>1);
        if(a>=biao[mid]&&a<biao[mid+1]){return a-biao[mid]+1;}
        if(a>biao[mid]) l=mid;
        if(a<biao[mid]) r=mid;
    }
}
set<ll> t;
int main(){
    //freopen("in","r",stdin);
    //freopen("out","w",stdout);
    read(m);
    register int i;
    register ll a,b;
    for(i=1;i<=m;++i){
        read(a),read(b);
        t.insert(a);
        while(true){a=find(a),t.insert(a);if(a==1)break;}
        if(t.count(b)){printf("%lld\n",b),t.clear();continue;}
        while(true){
            b=find(b);
            if(t.count(b)){printf("%lld\n",b);break;}
        }
        t.clear();
    }
    return 0;
}
```
顺便吐槽几句：

1.这题NOIp D1T1。。。。。。清真！


2.大样例可真是大啊（掩面


3.我的电脑太垃圾了，开O2 1.3s，吓得我还以为我挂了


4.我这么垃圾，看来只会写T1了

![](https://cdn.luogu.com.cn/upload/pic/9424.png)
