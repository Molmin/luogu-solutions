## $\text{Description}$

约翰有一架用来称牛的体重的天平。与之配套的是 $N$  ( $1 \leq N \leq 1000$ )个已知质量的砝码（所有砝码质量的数值都在 ``32`` 位带符号整数范围内）。

每次称牛时，他都把某头奶牛安置在天平的某一边，然后往天平另一边加砝码，直到天平平衡，于是此时砝码的总质量就是牛的质量（约翰不能把砝码放到奶牛的那边，因为奶牛不喜欢称体重，每当约翰把砝码放到她的蹄子底下，她就会尝试把砝码踢到约翰脸上）。

天平能承受的物体的质量不是无限的，当天平某一边物体的质量大于 $C$ ( $1 \leq C \leq 2^{30}$ ) 时，天平就会被损坏。砝码按照它们质量的大小被排成一行。并且，这一行中从第3个砝码开始，每个砝码的质量至少等于前面两个砝码（也就是质量比它小的砝码中质量最大的两个）的质量的和。

约翰想知道，用他所拥有的这些砝码以及这架天平，能称出的质量最大是多少。由于天平的最大承重能力为 $C$ ，他不能把所有砝码都放到天平上。

现在约翰告诉你每个砝码的质量，以及天平能承受的最大质量，你的任务是选出一些砝码，使它们的质量和在不压坏天平的前提下是所有组合中最大的。

## $\text{Solution}$

观察一下题目的限制。

> 并且，这一行中从第3个砝码开始，每个砝码的质量至少等于前面两个砝码（也就是质量比它小的砝码中质量最大的两个）的质量的和。

$Fib()?$

于是我们就可以得出

$$\text{第}\;i\;\text{个砝码的重量}>fib(i)$$

$$fib(1)=fib(2)=1$$

$$fib(n)=fib(n-1)+fib(n-2)\;\;\;|\;\;\;n>2$$

然后这道题的 $N$ 就可以成功缩小了。

然后就用最优化剪枝和前缀和维护一下就可以啦！

## $\text{Code}$

```cpp
#include <cstdio>
#include <cstdlib>
#include <cmath>
long long su[1000001],a[1000001],t[1000001];
long long ans=0,n=0,c=0;
long long max(long long x,long long y)
{
	return x>y?x:y;
}
void dfs(long long x,long long y)
{
	if(y+su[x]<=ans)
	{
		return ;
	}
	if(y>c)
	{
		return ;
	}
	ans=max(ans,y);
	if(x==0)
	{
		return ;
	}
	dfs(x-1,y+a[x]);
	dfs(x-1,y);
}
int main()
{
	scanf("%lld %lld",&n,&c);
	su[0]=0;
	for(long long i=1;i<=n;i++)
	{
		scanf("%lld",&a[i]);
		su[i]=su[i-1]+a[i];
	}
	while(a[n]>c)
	{
		n--;
	}
	dfs(n,0);
	printf("%lld",ans);
	return 0;
}
```