[CF1540A](https://www.luogu.com.cn/problem/CF1540A)

**upd on 21/8/3：修正评论区中提出的一些错误。**

------------

题目大意：给定从节点 1 出发到所有节点的最短路，求构造一个图，使得满足最短路的前提下所有边权和最小。

---------

首先，有一个显然的结论：**最终答案不大于 0**。

我们可以用一种简单的构造造出答案是 0 的情况。构造方法就是从源点向每个节点按边权为最短路连一条边，并按边权为最短路的相反数连一条反边。如此构造答案为 0，且显然合法。（感谢 [wxy_](https://www.luogu.com.cn/user/317459) 同学指出之前的证明有误）

------------

然后，有一个不太好想的结论：构造的负权边只需满足下式，即可保证所有负权边和最小且满足题意。

在 $d$ 序列**从小到大排序后**，连负权边满足 边权 $w=d_i-d_j,1 \le i<j \le n$，即可使所有负权边和最小且满足题意。

为什么这是合法的？

考虑连接负权边时需要注意什么：**不能出现负环**。

而上面那个解法的负权边集是个 DAG，自然不可能出现负环。重边就更不可能了。

如何证明其边权和最小呢？

考虑对于每一条边权和为 $w$ 正向路径（注意不是正向边） $i \to j$，你需要把所有的 边权和为 $-w$ 的反向路径 $j \to i$ 都构造出来。而上式恰好满足这个最优情况。

------------

既然最优负权边和最小值是定值，那么我们只需要使正向边之和最小即为答案最优情况。

那么就显然了，在 $d_i$ 从小到大排序后，顺序连边形成一条链，边权即相邻两点 $d$ 值之差。

于是这题构造方法就结束了。

------------

但是你这时候发现一个问题：正向边权和可以 $O(n)$ 求，反向边权和这个是什么鬼鬼。

通过手玩，你发现每条反向边经过次数并不相同，而且看上去没有一点规律。

那就打表来看看！

打出来的表长这个样子：

```
n
2: 1
3: 2  2
4: 3  4  3
5: 4  6  6  4
6: 5  8  9  8  5
7: 6  10 12 12 10 6
8: 7  12 15 16 15 12 7
9: 8  14 18 20 20 18 14 8
10:9  16 21 24 25 24 21 16 9
11:10 18 24 28 30 30 28 24 18 10
12:11 20 27 32 35 36 35 32 27 20 11
13:12 22 30 36 40 42 42 40 36 30 22 12
14:13 24 33 40 45 48 49 48 45 40 33 24 13
15:14 26 36 44 50 54 56 56 54 50 44 36 26 14
```

这是什么？

横着看是一个回文单边二阶等差数列（感谢 [⚡LYR_⚡](https://www.luogu.com.cn/user/110319) 同学的提醒），但求起来有点麻烦。可是你一竖着看……

等差数列！

$i$ 表明了公差，$n-i+1$ 表明了项数。

然后这题就做完了。


```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;

long long t,n,a[100010],b[100010],ans;

long long calc(long long x,long long y){
	long long gc=y,xs=x-y+1;
	return gc*xs-1;
}

int main(){
	long long i,j,u,v;
	cin>>t;
	while(t--){
		ans=0;
		memset(a,0,sizeof(a));
		memset(b,0,sizeof(b));
		cin>>n;
		for(i=1;i<=n;i++){
			cin>>a[i];
		}
		sort(a+1,a+n+1);
		for(i=1;i<=n;i++){
			b[i]=a[i]-a[i-1];
		}
		for(i=1;i<=n;i++){
			ans+=(b[i]*calc(n-1,i-1));
		}
		cout<<-ans<<endl;
	}
	return 0;
}
```