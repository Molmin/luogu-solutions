[题目传送门](https://www.luogu.com.cn/problem/P8324)

（如有错误请指出）

# 题意
给定 $n$ 个~~化学~~类化学方程式，判断其是否配平。

**温馨提示：** 本题中读入的所有数字都是一位数，不会出现多位数。

# 分析
根据质量守恒定律，一个方程式配平当且仅当方程左右两边原子数量相等。

因此，我们只要以 `->` 为分隔，分别遍历左右两边，用两个桶数组记录每个元素（就是 $26$ 个英文字母）出现的次数，最后再次遍历一遍两个桶数组，依次判断每个数是否相同，一旦不同输出 `NE`，否则输出 `DA`。

## 注意
（以下类似 `"中文"` 的代码块中，`" "` 不用加）
1. 建议使用 `string` 来读入，如果你想用 `char` 数组来读入，请注意，如果当前读入字符串长度为 $l_2$，上一次读入长度为 $l_1$（$l_2 < l_1$），数组会保留第 $l_2+1$ 到 $l_1$ 位的内容。为此有以下两种解决方法：
- 每次读入前清空数组；
- 读到 `\0` 后跳出遍历。
2. 计算字符串长度时，`char` 数组请用 `strlen("数组名")`，`string` 变量请用 `"字符串名".size()`；
1. `char` 数组可以用 `\0` 作为遍历结束标志，但这个在 `string` 类型变量末尾并不存在，我们可以用 `"字符串名".push_back('要插入的字符')` 将括号中的字符插入到该字符串的末尾，以此来结束遍历，本题中注意要插入一个输入中不可能出现的字符，例如 `'0'` 或 `'1'` 等；
1. 本题有多组输入，因此用桶数组时注意每次清空数组；
1. 当读到数字时，转换为整型时请注意不要使用类似于 `(int)s[i]`（s 为 `string` 类型）的代码，因为它返回的是 `s[i]` 的 ASCII 值，数据会很大（因为 A 到 Z 的 ASCII 值为 $65$ 到 $90$，且会有乘法运算），所以建议使用 `s[i]-'0'` 来转换数字，这样子当你 debug 的时候也方便；
1. 注意遍历时候下标的变化情况及退出循环的条件；
1. 下面的参考代码中，`i++` 表示使用完 $i$ 后再将 $i$ 加 $1$，而 `++i` 是先将 $i$ 加 $1$ 再使用，请注意区分。

## 扩展
本题中字符串的读入比较简单，没有空格，因此只要用 `cin` 来读取一行字符；但如果以后我们碰到读入多行字符，并且每行字符串中可能存在空格，那怎么办呢？这时候就不能用 `cin` 了，因为 `cin` 是以空格为分隔读入的。可以使用 `getline`，读入 `char` 数组使用 `cin.getline("数组名","数组长度")`，`string` 用 `getline(cin,"变量名")`；另，使用 `getline` 后，请注意把 $n$ 后面的换行符过滤掉，不然读入也会有问题，具体也有两种方法：
1. 输入 $n$ 后用一个 `char` 类型变量加 `getchar` 读入换行符；
1. 使用 `cin.ignore(INT_MAX,'\n')`，括号中的 `INT_MAX` 可以换成一个很大的整数，也可以使用 `numeric_limits<int>::max()` 替换 `INT_MAX`。 

习题：[P8506 标题计数](https://www.luogu.com.cn/problem/P8506)

# 代码实现
具体实现请看注释。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int t1[50],t2[50];//桶数组 
signed main()
{
 	cin.tie(NULL)->sync_with_stdio(false);//加速读入，相当于用 scanf，不过 scanf 不太方便 
	int n;
	string s;
	cin>>n;
	//cin.ignore(INT_MAX,'\n')      如果用 getline，这句话别忘了 
	while(n--)
	{
		int flag=0;
		memset(t1,0,sizeof(t1));
		memset(t2,0,sizeof(t2));//注意每次读入前清空 
		cin>>s;
		s.push_back('1');//在 s 末尾插入一个标记字符 
		int l=s.size(),l1=0;//l 为字符串长度，l1 为方程右边开始下标 
		for(int i=0;i<l;i++)//看似遍历全部，实则只遍历了左边 
		{
			if(s[i]=='-'&&s[++i]=='>')//分隔，退出循环条件 
			{
				l1=++i;
				break;
			}
			if(s[i]>='0'&&s[i]<='9')//如果读到系数，例如 3H2O 中的 3 
			{
				int x=(s[i++]-'0');//存下系数 
				while(s[i]!='+')//遍历一个物质 
				{
					if(s[i]>'9')//如果是字母，因为 '9' 的 ASCII 码值是 57，而 'A' 是 65 
					{
						if(s[i+1]>='0'&&s[i+1]<='9')t1[s[i]-'A']+=(s[i+1]-'0')*x;
						//看当前字母后面是否有数字，是就乘上系数 x 存入答案中 
						else t1[s[i]-'A']+=x;//否则直接加 
					}
					i++;
					if(s[i]=='-')
					//读到 '-' 后先 i--，因为跳出 while 后 i 会先 +1 再跳到判断是否跳出 for 循环 
					{
						i--;
						break;
					}
				}
			}
			else//若整个物质系数为 1，其它和上面一样 
			{
				while(s[i]!='+')
				{
					if(s[i]>'9')
					{
						if(s[i+1]>='0'&&s[i+1]<='9')t1[s[i]-'A']+=(s[i+1]-'0');
						else t1[s[i]-'A']++;
					}
					i++;
					if(s[i]=='-')
					{
						i--;
						break;
					}
				}
			}
		}
		for(int i=l1;i<l;i++)
		//遍历方程式右边，这里的代码只是上面代码的修改，只要将跳出循环条件改为判断是否读到 '1' 即可 
		{
			if(s[i]=='1') 
			{
				break;
			}
			if(s[i]>='0'&&s[i]<='9')
			{
				int x=(s[i++]-'0');
				while(s[i]!='+')
				{
					if(s[i]>'9')
					{
						if(s[i+1]>='0'&&s[i+1]<='9')t2[s[i]-'A']+=(s[i+1]-'0')*x;
						else t2[s[i]-'A']+=x;
					}
					i++;
					if(s[i]=='1')
					{
						i--;
						break;
					}
				}
			}
			else
			{
				while(s[i]!='+')
				{
					if(s[i]>'9')
					{
						if(s[i+1]>='0'&&s[i+1]<='9')t2[s[i]-'A']+=(s[i+1]-'0');
						else t2[s[i]-'A']++;
					}
					i++;
					if(s[i]=='1')
					{
						i--;
						break;
					}
				}
			}
		}
		for(int i=0;i<26;i++)//遍历两个桶 
		{
			//cout<<i<<" "<<t1[i]<<" "<<t2[i]<<"\n";
			if(t1[i]!=t2[i])
			{
				cout<<"NE"<<"\n";
				flag=1;//标记变量，若不加会不清楚是因为不符合条件还是正常退出循环 
				break;
			}
		}
		if(flag==0)cout<<"DA"<<"\n";
	}
	return 0;
}
```
