这是一题很好的dp题

首先我们需要明白几个事实

1. A和B的策略都是尽可能使得自己的得分减去对手的得分更大（也就是A 和 B都很聪明）换句话说在你来我往的取数间最大差值的对象是一直都在变化的。
2. 如果你要取走一个数，比它大的数一定是不能留下的，举个栗子：如果一个单调数列 1 2 3 5 7 9 你看中了5这个数那么取走7和9并不会影响你的得分（得分为最小数值），反而留下来还会给对手带来机会所以要一起取走。
3. 一定是从大向小取，我们假设你的对手从小向大取数，那么你从大向小取，你就赢定了。而题目中的A B都非常聪明，都会采用最佳策略。那么，由于A是先手，A留给B的肯定是比自己取的小的数（2 给予证明）。

接下来我们可以做题了

为了方便做题，我们将取的顺序反转，也就是从小到大取（结果并不影响）
```cpp
sort(a+1,a+n+1);
```
很快就会能写出第一个转移方程


```cpp
for(int i=1;i<=n;i++){
	   //枚举i就是A取到i的最大差值（A-B）
   	for(int j=0;j<i;j++){
       //这里枚举j就是A将取到j的机会让给了B,这里的dp[j]变为(B-A)的最大差值（1给予证明）。
//这时A取的是a[j+1]~a[i]，由于是单调数列，取得的就是最小值a[j+1].
    	dp[i]=max(dp[i],a[j+1]-dp[j]);
       }
}
```
但是O(n^2)会超时

所以需要优化。这是我们有了第二个转移方程
```cpp
for(int i=1;i<=n;i++){
    	dp[i]=max(dp[i-1],a[i]-dp[i-1]);
}
```
那这个怎么来理解。

由于取到第i个数只有两个可能1：单独就取i这个数，2：和前面的连在一起。

dp[i-1]就可以理解为和前面连在一起，由于单调数列，连在一起并不影响得分。

a[i]-dp[i-1]可以理解为单独取 所以dp[i-1]变为B-A的最大值（1证明）。

我们还可以继续优化，我们发现dp[i]只与dp[i-1]有关,所以我们可以省去数组。

好现在上CODE
```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAXN=1000000+10;
int n,a[MAXN],ans;
int main(){
	scanf("%d",&n);
    for(int i=1;i<=n;i++) scanf("%d",&a[i]);
    sort(a+1,a+n+1);
    for(int i=1;i<=n;i++){
    	ans=max(ans,a[i]-ans);
    }
    printf("%d\n",ans);
	return 0;
}
```
