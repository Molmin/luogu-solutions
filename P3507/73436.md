```cpp
// 先把a数组从小到大排序，可以肯定的是， 每一次取，肯定要取从当前的最大值开始的连续一段
// f[i]表示从第一个数取到第i个数先手的最大分数，（也同时会成为后手的最大分数）
// 转移： 
//1.假设f[i-1]的价值是通过取  al,al+1,al+2...,ai-1得到的，那么这次的f[i]的价值，就是通过取 al,al+1,al+2...,ai得到的
//  那么f[i]=f[i-1] 
//  2. 这次只取一个a[i],那么后手就会取f[i-1]的价值，所以此刻的价值应为 :a[i]-f[i-1]
//  比如，有这个数据   1,100
// 方案就是这两种 1.先手就只取个100，那么后手会取1，这样价值为99 ,这个思路可以理解为："你好我好大家好“
// 因为先手会加一个值，后手也会加一个值，这时候，如果先手增加的值比后手增加的值多很多，就说明拉开差距了
// 方案2就是先手直接取掉1,100，那么后手没得取了，这样价值为1，这个思路可以理解为：“杀敌一千自损八百”
// 就是说， 我通过取掉一个比较小的数， 使得对方去取一个更小的数，或者直接没得取，那么这也是一种情况
//  所以，答案就是这两种情况里的 更优解
//   那么代码实现，就是把a数组从小到大排序完以后，1-n维护一遍最优解，因为f[i]是由f[i-1]转移过来的。 
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int N=1e6+5;
int n;
int a[N],f[N];
signed main(){
	scanf("%lld",&n);
	for (register int i=1; i<=n; ++i) scanf("%lld",&a[i]);
	sort(a+1,a+n+1);
	for (register int i=1; i<=n; ++i) f[i]=max(f[i-1],a[i]-f[i-1]);
	printf("%lld\n",f[n]);
return 0;
}
```
