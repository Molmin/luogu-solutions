中文翻译不全，可以补上，如果翻译完整了指向性就特别明确了，注意题目中有这句话：

> 字母 `t`, `r`, `y`, `g`, `u`, `b` 不会出现在给出的字符串中。

显然就是告诉我们只有 20 种字符，那么考虑状压。

设 $F_S$ 表示 $S$ 代表的字符组成的 **子集** 是否可以到达并且可以继续转移，即可以通过若干操作全部变成另外某种 **其他** 字符。

如样例中 $F_{\text{'i'}}=1,F_{\text{'i','o'}}=1,F_{\text{'i','o','m'}}=1$ 等。

这里有个前提是被操作过后的字符不会被操作回去，因为只能转化为局面上有的字符。

所以就保证了一些性质如每个字符只转化了一次，转化过程对应了一棵树，当然这都是帮助理解。

更重要的有 $F_{U\setminus \text{'x'}}=1$ 代表最后能转化为 `x` 字符，于是我们只要得到了 $F$ 的值就可以简单得到答案。

这里 $U$ 指出现的字符全集，$\setminus$ 是除去某个元素。(本人符号表达能力较弱，下面不懂的意会一下)

设 $G_S$ 表示 $S$ 代表的字符组成的 **子集** 是否可以继续转移，辅助 $F$ 的转移，预处理一下可以由题目给的条件直接推出。

然后考虑转移，求 $F_S$，一种 naive 的想法就是枚举子集 $T$ 转移，显然地有 $F_S|=F_T\&F_{S\setminus T}$。

有特殊情况，虽然这才是转移基础，是统一到一个字符上转移，此时 $T$ 仅代表某种字符，有 $F_S=G_S\&F_{S\setminus T}$。

瓶颈在枚举子集，信仰 $O(3^{20})$ 是不可能过得去的，考虑优化。

我们一步步转移是不好看出来的，考虑 $F_S|=F_A\&F_B\&F_C\&...\&F_T$ ，这里 $A,B,C,...$ 的最左出现位置递增排列。

为了表达清楚我们设字符 $x$ 最左出现位置为 $l_x$，最右为 $r_x$，一个子集的范围为 $R(S)=\left[\operatorname{min}_ {x \in S}l_x,\operatorname{max}_ {x\in S}r_x\right]$。

我们希望证明如果 $R(A)\cap R(B)\not= \varnothing$，$F_A,F_B$ 一定可以转移得到 $F_{A|B}$。

也就是说，我们希望可以只枚举范围不交的子集来转移，左右一划分就可以只枚举一个区间而不是子集了。

~~然后我就随便证证~~，设子集对应的字符个数为 $T(x)$ ，以下没考虑转以后统一为某个字符：

因为每个字符只转化一次，那么 $A\cap B=\varnothing$，有 $T(A|B)=T(A)+T(B)$.

由条件知 $T(A)+T(B)\ge k\cdot|R(A)|+k\cdot|R(B)|$。

又由于 $R(A)\cap R(B)\not= \varnothing$，那么 $k\cdot|R(A)|+k\cdot|R(B)|\ge k\cdot|R(A|B)|$

即 $T(A|B)\ge k\cdot|R(A|B)|$ ，故得证。

然后我们就根据 字符最左出现位置递增排列 枚举一个左区间，和右区间与一下即可。

注意还要特殊考虑一下统一到一个字符上的情况，这样会出现俩区间有交，可能不被考虑到。

状态 $O(2^{20})$ 乘上枚举每种字符/区间位置转移 $O(20)$，复杂度足以通过此题。

核心(转移部分)代码：

```cpp
	for(F[0]=i=1;i<(1<<top);i++)
	{
		for(j=k=0;j<top;j++)
		{
			if((i>>j)&1)
			{
				if(!lft[j]){F[i]=0;goto nxt;}
				k|=(st=1<<j);
				if(!L[i])L[i]=Min(L[st],L[i^st]);R[i]=Max(R[st],R[i^st]);T[i]=T[st]+T[i^st];
//我比较毒瘤，所以在这里，也就是在转移中间处理的子集信息。
				if((F[k]&&F[i^k])||(F[i^st]&&a*(R[i]-L[i]+1)<=b*T[i])){F[i]=1;goto nxt;}
//核心转移部分：由 左右两区间并成 或 统一到一个字符上的情况。
			}
		}
	nxt:;}
```