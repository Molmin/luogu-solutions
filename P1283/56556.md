**本蒻看到那么多大佬用状压DP，深有感触**

**决定用广搜优化一下~~(逃)~~**

------------
首先来看一下DP的做法，发现状态好像~~很难~~设计

但是看一看数据范围，只有16个矩形，又因为每个矩形只有涂和不涂两种状态，用0/1分别表示这两种状态，于是我们就可以用n个有序的0/1来表示整个的状态了，也就是二进制数。

#### 进一步说，也就是一个状态只要用一个整数来表示。

但是，还要记一下最后一次拿起刷子的颜色。

**那么这样状态的设计就很~~显而易见~~了，设f[s][c]表示当前的状态用s表示，最后拿起刷子的颜色为c。**

**转移也比较容易，用转出式(方便广搜优化)，枚举在当前状态s下能涂的块j**
```cpp
f[j][color[j]]=max{f[s][c]+(color[j]!=c)};
```

###  接下来是广搜优化（手动划重点）

观察发现，如果第一维状态用枚举，会有许多状态是不合法的，浪费了一些时间，当然对于本题是不会炸的，但是本蒟蒻深得某骗分大佬胡** 真传，决定优化一下。

既然会有冗余，我们就用合法情况的状态来转移，首先起始状态肯定是合法的，一个状态转移出的状态也一定是合法的，而且可以证明这些就是所有合法的情况。所以用广搜搜出转移出的所有状态，其他具体细节看代码吧~~，手累~~。

代码比较压行~~（还挺丑）~~，勿喷
```cpp
#define main mian //防作弊
#include<cstdio>
#include<queue>
#include<cstring>
using namespace std;
const int N=17;
int x0[N],y0[N],x1[N],y1[N];
	//矩形左上角坐标(x0,y0)，右上角坐标(x1,y1)
int n,pre[N],color[N],f[1<<N][21],ans=30;
	//n为矩形个数，color[i]为第i个矩形的颜色。
	//pre[i]是一个二进制数，表示要放第i个矩形至少要的矩形组成的状态，
	//比如第i个矩形上方的矩形分别是第3，4个矩形，pre[i]=1100=12。
	//ans是最终的答案。
bool txt[1<<N][21];
	//txt[s][c]=true表示f[s][c]这个状态在队列中，false反之，就是用来判重的。
struct zt {int x,c;};
	//表示队列中的一个状态，记录f数组的两维是什么就行了。
queue < zt > Q;
	//用来实现广搜的队列，存状态。
int main() {
    scanf("%d",&n);
    for(int i=1;i<=n;++i)	scanf("%d%d%d%d%d",&x0[i],&y0[i],&x1[i],&y1[i],&color[i]);
    //预处理第i个矩形上方的矩形组成的状态。
    for(int i=1;i<=n;++i)
        for(int j=1;j<=n;++j)
            if(i!=j&&x0[i]==x1[j]&&y0[i]<y1[j]&&y1[i]>y0[j])
            //如果下方重合并且水平方向相交就是的。
                pre[i] |= 1<<(j-1);
            	//1<<j表示二进制中第j+1位是1，其它位是0
    memset(f,0x7f,sizeof f);//极大求最小
    for(int i=1;i<=n;++i)
        if(pre[i]==0) {
            zt t=(zt){1<<(i-1),color[i]};
            f[t.x][t.c]=txt[t.x][t.c]=1;
            Q.push(t);
        }//如果没有前置要求，直接涂，赋初值并放入队列。
    while(!Q.empty()) {
        zt t=Q.front();Q.pop();
        for(int i=1;i<=n;++i)
            if((t.x&(1<<(i-1)))==0&&(t.x&pre[i])==pre[i]) {
          	//如果没放过并且能放
                zt tt={t.x|(1<<(i-1)),color[i]};
                f[tt.x][tt.c]=min(f[tt.x][tt.c],f[t.x][t.c]+(t.c!=tt.c));
                //转移
                if(!txt[tt.x][tt.c])	Q.push(tt),txt[tt.x][tt.c]=true;
            }
    }//广搜模板
    for(int i=1;i<=20;++i)	ans=min(ans,f[(1<<n)-1][i]);
    printf("%d\n",ans);return 0;//代码什么的都去死吧
}
```
实测好像比没用广搜快一点~~（20ms）~~
# 蒟蒻第一篇题解，写得不好请见谅
# よろしくお願いします