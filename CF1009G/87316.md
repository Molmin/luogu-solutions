看到题的天然想法是维护一下字符集每个子集覆盖到的A集合中的元素的数量，每次贪心放一下，然后什么容斥啊啥的判定是否可行。

想了半天没感觉，然后感觉这题可以网络流，就可以顺着做下去。

首先建立一个网络流模型，A集合是位置，B集合是字符集，B到超级汇连边size是字符数。天然的思路是不断地贪心放下去，每次最最大流查看剩余的位置是否还有完备匹配。这个复杂度显然不能接受，那么考虑其他的判定方法。

各种匹配在算法复杂度已经有一个n的情况下已经算是死了，不过我们知道有hall定理，它是这样说的：

>设二分图的两部分为X、Y，且|X|≤|Y|。则定理描述为：二分图存在完美匹配，等价于对于X的任意子集X′，与它们中任意点相连的Y的结点个数≥|X′|。

顺口胡一下证明

>**必要性：** 因为存在完备匹配，所以X中每个点的出边数大于等于1，必要性得证。

>**充分性：**

>假定当前不存在完备匹配，那么X中有元素$a_0$没有匹配。

>$a_0$必定有至少一条出边，如果这条出边不在匹配中，那就匹配上了，矛盾；因此a的出边全部在匹配中。

>假定$a_0$存在出边$b_1$，我们强制令两者匹配上，那么$b_1$原先的匹配$a_1$失去匹配，因为我们有$a_0$和$a_1$的相邻点集合大小≥2，所以$a_1$必定可以找到$b_1$之外新的匹配。

>我们把这个操作过程中X集合的元素加入$A$，Y的元素加入$B$，假定此时$|A|=|B|$。当前落单的元素$a_k$加入$A$，此时$A$集合的邻居集合$|S|≥|A|>|B|$，$S$中必定存在$B$中没有的点。这样一路操作下去，由于$|X|<|Y|$,于是最终停止在Y，完成匹配。

>这里还没解决$|X|=|Y|$的问题，既然集合大小相等，那么在最大匹配里，Y集合中必定也有个落单点。如果在操作中Y被连上就太好了，如果没有，那么X中所有元素都被遍历，都不和Y连边，那么X全集的邻居数就为$|Y-1|$，不符合条件。

>于是充分性得证。


看着一头雾水，因为A那个大小枚举子集没任何意义啊。

不过有B嘛。

B集合已经被压成6个了，信息有点乱。假设原来的多重集合是$B_0$,$B$实则是把$B_0$压缩起来，我们说$B$中元素$x$的$size$是$x$在$B_0$里出现的次数。

那么$B_0$的子集实际上等价于B的所有子集S，并且S的所有元素x的大小选择$[1,size_x]$的全部方案。这样算来，对于一个子集S而言，无论元素大小如何选择，与A集合中相连的边的数量是确定的，那么最坏的情况无非是大小取满。

所以还要每次都询问出一个集合覆盖到了A集合里的多少点。

ps:突然发觉自己绕回了自己最开始想到的那个结论

考虑贪心过程中要每次删一个点和它导出的所有边，在线改有点难受，那么预处理出每个后缀的这个东西就完了。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=100005;
int n,m,sz[maxn],link[maxn][1<<6],x,cover[maxn];
char s[maxn],ans[maxn];
vector<int>t[maxn];
bool check(int x)
{
    for(int i=0;i<1<<6;i++)
    {
        int a=link[x][i],b=0;
        for(int j=0;j<6;j++)
            if((i>>j)&1)b+=sz[j];
        if(a<b)return 0;
    }
    return 1;
}
int main()
{
    scanf("%s",s+1);
    n=strlen(s+1);
    for(int i=1;i<=n;i++)sz[s[i]-'a']++;
    cin>>m;
    for(int i=1;i<=m;i++)
    {
        scanf("%d%s",&x,s+1);
        int len=strlen(s+1);
        for(int j=1;j<=len;j++)
            t[x].push_back(s[j]-'a'),cover[x]+=1<<(s[j]-'a');
    }
    for(int i=1;i<=n;i++)
        if(t[i].size()==0)
        {
            cover[i]=(1<<6)-1;
            for(int j='a';j<='f';j++)t[i].push_back(j-'a');
        }
            
    for(int i=n;i>=1;i--)
    {
        for(int j=0;j<1<<6;j++)
        if(j&cover[i])link[i][j]=link[i+1][j]+1;
        else link[i][j]=link[i+1][j];
    }
    for(int i=1;i<=n;i++)
    {
        sort(t[i].begin(),t[i].end());
        for(auto c:t[i])
        {
            sz[c]--;
            if(check(i+1)){ans[i]=c+'a';break;}
            sz[c]++;
        }
    }
    if(strlen(ans+1)<n)cout<<"Impossible";
    else printf("%s",ans+1);
}
```