# 线性基

## 线型基在成功插入后要写break！！！

## 简介

你有一个原集合T;

线性基是一个集合，里边的元素通过异或，可以不多不少的凑出T，且线型基最小；

## 性质

1.设线性基的异或集合中不存在0。

2.线性基的异或集合中每个元素的异或方案唯一，其实这个跟性质1是等价的。

3.线性基二进制最高位互不相同。

4.如果线性基是满的，它的异或集合为[1,2n−1]。

5.线性基中元素互相异或，异或集合不变。

## 用途

给定n个整数（数字可能重复），求在这些数中选取任意个，使得他们的异或和最大。

## 实现

因为0是^的单位元，所以在插入时，对于二进制的每一位，我们只需要让集合中的唯一一个数的最高位时它就好（因为再多一个没有用，只会更麻烦）

插入：

从高到低检查该数，如果此位为1，查一下线型基中该位有没有被占用过，如果为空，插入到线型基中；如果不为空，用当前位的数异或它（即废掉它的这一位），继续插入；

这样一个数只有两种下场：插入/被^成0；

求最大值：

从高位到低位贪心，如果异或上该数使答案变大，就异或；

若要求出线性基内的元素与一个给定的数M的最大异或值，只需在求解时把x的初值设为M即可；

### 代码


```cpp
struct LBase {
    ll d[61];
    LBase() {memset(d, 0, sizeof d);}
    bool insert(ll x) {
        for (ri i = 60; i >= 0; --i)
            if (x & ((ll)1 << i)) {
                if (d[i]) x ^= d[i];
                else {d[i] = x; break;}
            }
        return x > 0;
    }
    ll qmax() {
        ll x = 0;
        for (ri i = 60; i >= 0; --i)
            if (d[i])
                if ((x ^ d[i]) > x) x ^= d[i];
        return x;
    }
    void merge(const LBase &a) {
        for (ri i = 60; i >= 0; --i)
            if (a.d[i]) insert(a.d[i]);
    }
};
```

## 线性基求第k小

这是，我们使用的线性基就和上面的构造方法不太一样了，因为上面只是求最大值；而这里我们要求第k大；

首先讨论边界情况：设线性基的大小为cnt，那么除去0外，它能表示的数字个数就是$2^{cnt}-1$个；

为什么把0单独说呢？因为大部分情况下，题目是不允许我们不选的；所以要特殊记录一下线性基中是否有0；

求第k小（除去0以外的，如果有0，就$--k$）

**如果k的第i位=1，答案就异或线性基中从小到大第i+1个数**

## 注意是线性基有值的第...位

类似二进制的证明；

![](https://cdn.luogu.com.cn/upload/pic/28626.png)

HDU 3949

```
int bas[64], cnt, sz;
void insert(int x) {
	for (ri i = 60; i >= 0; --i) {
		if ((x >> i) & 1) {
			if (bas[i]) x ^= bas[i];
			else {
				++cnt;
				bas[i] = x;
				for (ri j = i - 1; j >= 0; --j)
					if (bas[j] && ((bas[i] >> j) & 1)) bas[i] ^= bas[j];
				for (ri j = 60; j > i; --j)
					if ((bas[j] >> i) & 1) bas[j] ^= bas[i];
				break;
			}
		}
	}
}
vector<int>v;
bool zero;
int getk(int k) {
	if (zero) --k;
	if (k > sz) return -1;
	int res = 0;
	for (ri i = 0; i < v.size(); ++i)
		if ((k >> i) & 1) res ^= v[i];
	return res;
}
```