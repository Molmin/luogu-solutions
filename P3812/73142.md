似乎洛谷的题解没有和蓝书做法相同的。。那我来介绍一下蓝书的做法。  
先来一些定义：  
考虑将n个数（二进制下）看成n个向量，每个向量中的每个元素仅有0、1两种取值。  
如果向量$X$能被$a_1,a_2..a_n$这些向量通过异或运算得到，则称$X$能被$a_1,a_2..a_n$**表出**。如果某个向量集合中存在若干个向量能被其它向量表出，则这些向量**线性相关**，否则**线性无关**  
**定义一个向量集合的线性基为其极大线性无关子集**（可能有多个线性基，但这没有关系）（显然线性基可以表出这个向量集合）  
**线性空间**是对异或运算封闭的向量集合。

另外，异或高斯消元仅有向量间的异或操作，所以消元不会改变这些向量能表出的线性空间。因此，高斯消元可以求得一组线性基。

现在回到本题。（为了简便，可以将向量压缩为一个整数）先用高斯消元求得一组线性基。由高斯消元可得（没有学习过高斯消元的请出门左转高斯消元题解区），该线性基中，主元所在位为1的向量是唯一的。接下来我们可以从高位到低位贪心了。假设现在在考虑第$i$个向量$a_i$（向量降序），其最高位是$x$,前$i-1$个向量异或得到的最大整数为$res$。
1. 如果$res$的第$x$位是0，则令$res\ xor\ a_i$
2. 否则不改变$res$

接下来考虑这种做法的正确性。  
如果$res$的第$x$位是0但不改变$res$，而改变得到$res'$。由于向量降序，比x更高的位和x这一位无法再改变。即使$res$接下来的位全部是1，也没有x这一位是1大，即得到$res<res'$.因此操作1正确。  
如果$res$的第$x$位是1但改变res，得到$res'$.由于向量降序，比x更高的位和x这一位无法再改变。即使$res'$接下来的位全部是1，也没有x这一位是1大，即得到$res'<res$.因此操作2正确。  
证毕。  
对线性基中的向量（降序）做这两种操作即可。时间复杂度瓶颈在于高斯消元，将向量压缩为整数优化后为$O(n^2)$ （因此请求管理加大数据范围至$n\le 5000$）
```cpp
/**********/
typedef unsigned long long ull;
#define MAXN 5011
ll a[MAXN];
int main()
{
	ll n=read(),t=n;//t是线性基大小
	for(ll i=1;i<=n;++i)a[i]=read();
	for(ll i=1;i<=n;++i)//异或高斯消元
	{
		for(ll j=i+1;j<=n;++j)
			if(a[j]>a[i])std::swap(a[j],a[i]);
		if(!a[i])
		{
			t=i-1;break;
		}
		for(ll j=51;j>=0;--j)
			if(a[i]&(1ull<<j))
			{
				for(ll k=1;k<=n;++k)
					if(i!=k&&(a[k]&(1ull<<j)))a[k]^=a[i];
				break;
			}
	}
	ll ans=0;
	for(ll i=1;i<=t;++i)
	{
		for(ll j=51;j>=0;--j)//找最高位
			if(a[i]&(1ull<<j))
			{
				if(!(ans&(1ull<<j)))ans^=a[i];//操作1
				break;
			}
	}
	printf("%lld",ans);
	return 0;
}
```