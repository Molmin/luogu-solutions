~~其实吧，我个人觉得这题比较水，难度最多就橙吧...~~

## 题意简述
这题，就是给你一个 $1 \sim N$ 的打乱的排列，其中有若干个元素可以与其后一个元素交换。

题目就是问你，给定这几个可以交换的元素，进行若干次操作后，这个排列可不可以变得有序。

拿样例 1 举例，这个排列是 ```1 2 5 3 4 6```，其中元素 ```2 5 3``` 可以进行操作。

然后我们可以依次交换 ```3,5``` 的位置，排列就变成了 ```1 2 3 5 4 6```，我们再交换 ```5,4``` 的位置，排列就变成了 ```1 2 3 4 5 6```，可以发现它是有序的，所以就输出 ```YES```。

## 思路
既然在指定的范围内可以任意交换元素以达到升序的目的，那我们就可以找到几个**连续的**可交换的数，在这个**连续区间**内进行升序排序，到最后再检查最后得到的序列是否有序。比如下面这个输入样例：
```
7
1 6 5 4 3 2 7
011011
```
我们可以先将**连续的1区间** $[2,3]$ 进行排序，得到新的序列：```1 5 6 4 3 2 7```，然后再将**连续的1区间** $[5,6]$ 进行排序，得到最终的序列：```1 5 6 4 2 3 7```，而这个区间不是有序的，所以这个样例的输出是 ```NO```。

这里要注意一个小小的坑，因为题目要求说的是若干个元素可以和**它后面的元素**交换位置，所以我们对**连续区间**进行排序的时候应该在区间右端点多排一个元素。例如 ```5 4 1 6 2 3``` 中，```4 1 6``` 是可排序的元素，那么我们排序时应该向右多排一个元素，即需要对 ```4 1 6 2``` 进行排序，因为序列中 ```6,2``` 也可以互相交换位置。

## 代码实现
1. 输入不多讲，用 ```n``` 存储元素的个数，$a_{i}$ 存储排列中的第 $i$ 个元素，用 $b_{i}$ 存储 $a_{i}$ 中第 $i$ 个元素是否可以与第 $i+1$ 个元素进行交换。我们这部分代码首先输入 ```n``` 和数组 $a_{i}$，再在第二部分单个读入 $b_{i}$，分别处理。

```cpp
int n,a[200002]={0},b[200002]={0};
cin>>n;
for(int i=1;i<=n;i++)
	cin>>a[i];
getchar();//因为待会迎接的是几个 getchar()，所以这里要吃换行
```


2. 按照思路里的步骤，我们可以定义一个 ```left``` 存储一个**连续的1区间**的左端点，用 ```i``` 去枚举右端点，然后等到 ```i``` 跳出这个区间时 ```sort()``` 一遍区间 $[left,i]$。 那我们怎么找到元素的 1 的左端点呢？我们只要判断一下，如果 $b_{i}=1$ 且 $b_{i-1}=0$，就代表着读到了一个连续的区间，而判断右端点反之即可。

```cpp
int left=0;
for(int i=1;i<n;i++)
{
    char ch=getchar(); //用 getchar() 读入一个 '1' 或 '0'
    b[i]=ch-'0';  //用 b 数组存储 ch
    if(b[i]&&!b[i-1]) left=i; //进入一个连续的区间，判断区间左端点
    if(!b[i]&&b[i-1]) sort(a+left,a+i+1);//跳出一个连续的区间，判断区间右端点
}
//注意这里要特判最后一个端点，因为最后一个端点没有对应的字符可以读入了
if(!b[n]&&b[n-1]) sort(a+left,a+n+1);
```



3. 最后判断一下数组是不是有序的（即数组中有没有[逆序对](https://baike.baidu.com/item/%E9%80%86%E5%BA%8F%E5%AF%B9/11035554?fr=aladdin)）。

```cpp
for(int i=1;i<n;i++)
{
	if(a[i]>a[i+1]) //这是逆序对的情况，即任意一个数大于它后面的数，所以这个数组不再可能是完全的升序，直接输出 NO，然后结束
	{
		puts("NO");
		return 0;
	}
}
puts("YES");//如果数组中没有逆序对了，那么输出 YES。
```


因为代码都一步一步给出了，所以完整代码就不贴了~
###### ~~（抄题解的：呜呜呜呜呜...）~~

