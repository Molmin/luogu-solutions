考虑**矩阵快速幂**。

但是只有**6**分。

考虑到矩阵有**循环节**，本题为**1e9+6**。即每$10^9+6$个数循环一次。

所以可以将$n$缩小到$10^9+7$范围内。

此时大概是$22s$。显然是不可以的。

考虑**分块**。

我们将$\sqrt{Mod}$内的**答案**矩阵**预处理**出来，然后将$\ k\sqrt{Mod}\ ,\ 0\le k \le \sqrt{Mod}\ $的**递推**矩阵**预处理出来**。

对于一个询问$\ n=v\sqrt{Mod}+u$，我们就可以将$u$的答案矩阵与$v\sqrt{Mod}$的递推矩阵乘一次，直接得到答案。

复杂度$O(T+20..30\sqrt{Mod})$。可以通过本题

~~代码比较丑陋，因为我卡常数来着~~

~~嫌太长可以不看，毕竟理解了原理自己码就行了~~

```
d[0][i][][]存第i个的答案矩阵
d[1][i][][]存i*sqrt{Mod}的递推矩阵

答案只与答案矩阵的第一行和递推矩阵的第一列有关
所以我只存了这两个。

#include<cstdio>
typedef unsigned long long LL;
const int mod=1e9+7;
const int N=31625;
LL SA,SB,SC,t,n;
int a[2][2],b[2][2],ans,T;
LL c[2][2];
int d[2][N+1][2][2];
int main(){
    scanf("%d%llu%llu%llu",&T,&SA,&SB,&SC);
    register int i,j,k,p,u,v;
    a[0][0]=a[1][0]=a[1][1]=0;
    a[0][1]=1;
    b[0][0]=0;
    b[1][0]=1;
    b[0][1]=666;
    b[1][1]=233;
    d[0][0][0][1]=1;
    for(n=1;n<=N;n++){
        c[0][0]=c[0][1]=c[1][0]=c[1][1]=0;
        for(j=0;j<2;++j)
        for(k=0;k<2;++k)
        for(p=0;p<2;++p)
        c[j][k]=(c[j][k]+1ll*a[j][p]*b[p][k]);
        a[0][0]=c[0][0]%mod;
        a[0][1]=c[0][1]%mod;
        a[1][0]=c[1][0]%mod;
        a[1][1]=c[1][1]%mod;
        d[0][n][0][0]=a[0][0];
        d[0][n][0][1]=a[0][1];
    }
    //暴力计算答案矩阵
    a[0][0]=a[1][1]=1;
    a[1][0]=a[0][1]=0;
    b[0][0]=0;
    b[1][0]=1;
    b[0][1]=666;
    b[1][1]=233;
    n=N;
    for(;n;n>>=1){
        if(n&1){
            c[0][0]=c[0][1]=c[1][0]=c[1][1]=0;
            for(j=0;j<2;++j)
            for(k=0;k<2;++k)
            for(p=0;p<2;++p)
            c[j][k]=(c[j][k]+1ll*a[j][p]*b[p][k]);
            a[0][0]=c[0][0]%mod;
            a[0][1]=c[0][1]%mod;
            a[1][0]=c[1][0]%mod;
            a[1][1]=c[1][1]%mod;
        }
        c[0][0]=c[0][1]=c[1][0]=c[1][1]=0;
        for(j=0;j<2;++j)
        for(k=0;k<2;++k)
        for(p=0;p<2;++p)
        c[j][k]=(c[j][k]+1ll*b[j][p]*b[p][k]);
        b[0][0]=c[0][0]%mod;
        b[0][1]=c[0][1]%mod;
        b[1][0]=c[1][0]%mod;
        b[1][1]=c[1][1]%mod;
    }
    //计算sqrt{Mod}的答案矩阵
    b[0][0]=a[0][0];
    b[0][1]=a[0][1];
    b[1][0]=a[1][0];
    b[1][1]=a[1][1];
    d[1][1][0][0]=a[0][0];
    d[1][1][1][0]=a[1][0];
    d[1][0][0][0]=1;
    //0时为单位矩阵
    for(n=2;n<=N;n++){
        c[0][0]=c[0][1]=c[1][0]=c[1][1]=0;
        for(j=0;j<2;++j)
        for(k=0;k<2;++k)
        for(p=0;p<2;++p)
        c[j][k]=(c[j][k]+1ll*a[j][p]*b[p][k]);
        a[0][0]=c[0][0]%mod;
        a[0][1]=c[0][1]%mod;
        a[1][0]=c[1][0]%mod;
        a[1][1]=c[1][1]%mod;
        d[1][n][0][0]=a[0][0];
        d[1][n][1][0]=a[1][0];
    }
    //计算k*sqrt{Mod}的递推矩阵
    for(i=1;i<=T;++i){
        SA^=SA<<32,SA^=SA>>13,SA^=SA<<1;
        t=SA;
        SA=SB,SB=SC,SC^=t^SA;
        n=SC%(mod-1);u=n%N;v=n/N;
        //循环矩阵-取模
        ans^=((1ll*d[0][u][0][0]*d[1][v][0][0]+1ll*d[0][u][0][1]*d[1][v][1][0])%mod);
        //计算答案。
    }
    printf("%d\n",ans);
}
```