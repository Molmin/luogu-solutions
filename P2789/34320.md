我们将n条直线编号,分别称为直线1、直线2、…、直线n。直线2 与直线1 最多有一个交点，直线3与直线1和直线2最多有2个交点，……，直线n与其它 (n-1) 条直线最多 (n-1) 个交点。

由此看出,n条无三线共点的直线最多的交点数 max=1+2+…+(n-1)=n(n-1)/2。

但本题我们要求解的是：这 n 条直线共有多少种不同的交点数？ 仍然从举例出发。下面列举了 n=1、2、3、4 四种情况各自的交点情况：



 ![](https://cdn.luogu.com.cn/upload/pic/5786.png) 

具体分析一下 n=4 的情况：

1)4 条直线全部平行，则 0 交点 { =4\*(4-4)}。

2)其中 3 条直线平行，则 3 交点 { =3\*(4-3) }。

3)其中 2 条直线平行，则这2条直线与另2条直线的交点数为4,而另2条直线之间可能有0个或1个交点（见 n=2 的情况,共 4 个交点或 5 个交点。{=2\*(4-2)+0 或 1 }

4)4 条直线均不平行（可看成 1 条直线平行），这 1 条直线与其它 3 条直线的交点数为 3，而其 它 3 条直线之间的交点数为 3，共 6 个交点。{ =1\*(4-1)+3 }


经过以上分析，我们可以得如下结论：

m 条直线的交点方案=r 条平行线与（m-r）条直线交叉的交点数+（m-r）条直线本身的交点方案

=r\*(m-r)+(m-r)条直线本身的交点方案 （1<=r<=m）

在具体编程时，我们设置一个标志数组 f[0..max]，在使用上述结论递归求解的过程中，每得到一种交点数 k，则置 f[k]为 true（初始 f[0]~f[max]均为 false）。

参考程序如下：




```cpp
#include <iostream>
#include <memory.h>
#include <algorithm>
using namespace std;
int n,MAX=-1,ans=0;
bool f[11000];
void g(int n,int k)
{
        if (n==0) {f[k]=true;MAX=max(k,MAX);}
        else for (int r=n;r>=1;r--)g(n-r,r*(n-r)+k);
}
int main()
{
        cin>>n;
        memset(f,false,sizeof(f));
        g(n,0);
        for (int i=0;i<=MAX;i++)
                if (f[i]) ans++;
    cout<<ans;
        return 0;
}

```