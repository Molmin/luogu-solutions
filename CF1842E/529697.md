## 题目分析

看起来很板，事实上暴力线段树优化也确实很无脑。

首先考虑围三角形的代价为什么要与边长线性，然后你会发现这其实保证了任意两个三角形不会有交（否则换成更大的三角形把二者都围起来显然不劣），于是我们套路地想到 $\text{dp}$。

设 $f_i$ 表示对 $y$ 值从上到下考虑完 $y\geq i$ 这个部分，并且当前最后一个围的三角形的下边界在 $y=i$ 时的最小代价（注意这个三角形可以边长 $=0$）。那么转移的时候就只需枚举当前三角形的上边界在哪里，并加上没有被三角形围住的孤立点代价，得到：

$$f_i=\min\{f_j+(j-i-1)\times A+\sum_{p=1}^n c_p[x_p<k-i][i\leq y_p<j]\}$$

接下来考虑优化，这种区间取 $\min$ 的常见套路是把与 $i$ 有关的东西提出去，然后数据结构维护最小值。所以我们变成 $f_i+A(i+1)=\min\{f_j+jA+\sum c\}$ 之后尝试对每个位置 $j$ 维护 $f_j+jA+\sum c$。

前两项是简单的，下面看最后一项。我们只需要注意到在 $i$ 逐渐变小的过程中，需要考虑的 $c$ 只会不断变多，于是就一边转移一边把新扫到的点的贡献加进去：一个在 $(x,y)$ 的点会且仅会对 $y<j\leq k-x$ 的 $j$ 产生贡献，那么从上到下扫的时候每考虑到一个点 $(x_p,y_p,c_p)$ 就对 $[y+1,k-x]$ 所维护的东西区间加 $c$ 即可。

于是做完了，我们需要支持：单点修改，区间加，区间取 $\min$。暴力上线段树，时间复杂度线性对数。

## 代码

```cpp
// 线段树板子，cz单点修，czadd区间加，ask区间取min

signed main()
{
	cin>>n>>k>>A;
	for(int i=1;i<=n;i++)
	{
		cin>>x[i]>>y[i]>>c[i]; e[y[i]].pb(mp(x[i],c[i]));
	}
	build(1,k,1); dp[k]=0; cz(1,k,k,k*A,1);
	for(int i=k-1;i>=0;i--)
	{
		for(auto j:e[i])
		{
			int ll=i+1,rr=k-j.fi; czadd(1,k,ll,rr,j.se,1);
		}
		dp[i]=min((k-i)*A,ask(1,k,i+1,k,1)-(i+1)*A);
		cz(1,k,i,dp[i]+i*A,1);
	}
	cout<<dp[0]<<endl;
}
```
