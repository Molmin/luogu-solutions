## 一道贪心题目

目测本题为普及—难度

**分析**

刚刚看到题马上想到 DP ，然而再仔细分析一下就会发现，因为要让字符串数量最少，所以就必须尽量让每个字符串最长。

具体来说，从前往后扫一遍字符串 $\operatorname{S}$ ，如果第  $\operatorname{i}$ 个字符  $\operatorname{S_i}$ 可以加到前面的字符形成的字符串末尾，那么直接添加，否则重新建立一个字符串，并将答案加一。这样的贪心显然可以使答案最小。

要注意两点：一个是要在字符串前面加一个空格，否则无法判断第一个字符；第二个就是一定要判断已经建立的字符串长度，如果大于 5 就必须重新开一个字符串，我做题的时候差点没看到。

**代码**

代码很短，如下：

```cpp
#include<bits/stdc++.h>  //万能头
using namespace std;
string s;           //直接使用STL里的string
int l=0,tot=0;
int main()
{
	cin>>s;
	s=' '+s;         //注意点一
	for(int i=1;i<s.size();++i)
	{
		if(s[i]==s[i-1])
			++l;
		else
			l=1,++tot;
		if(l>5)      //注意点二
			l=1,++tot;
	}
	cout<<tot;
	return 0;        //结束程序
}
```
