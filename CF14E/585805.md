[CF14E题目传送门](https://www.luogu.com.cn/problem/CF14E)
# 题目大意
输入 $n$ , $t$ ，求出所有满足：

1. 对于所有 $i$ $(1<i<n)$ 有 $t$ 个位置满足 $a_{i-1}<a_{i}>a_{i+1}$ 。

2. 对于所有 $i$ $(1<i<n)$ 有 $t-1$ 个位置满足 $a_{i-1}>a_{i}<a_{i+1}$ 。

3. 对于所有 $i$ $(1<=i<=n)$ ，满足 $1<=a_{i}<=4$ 。 

的序列 $a$ 的情况数量。

其中 $3<=n<=20$ ， $1<=t<=10$ 。
# 题目分析
这道题目数据范围比较小，最最暴力的方法就是搜索，时间复杂度为 $O(4^n)$ ，似乎差了一些。

那么接下来考虑dp解决，首先我们需要考虑怎么开dp数组的问题。

经过我的深思熟虑，既然数据范围这么小，那我们完全可以开一个五维数组。

则 $dp [i][j][flag][k][l]$ 为推到第 $i$ 位，这时填入数据为 $j$ ，有 $k$ 个位置满足条件1， $l$ 个位置满足条件2， $flag=1$ 表示这个位置数据比上个位置大， $flag=0$ 表示比上个位置小的情况数。

开好了数据，就可以推状态转移方程了。

若 $k>0$ ，就有 $dp[i][j][0][k][l]+=dp[i-1][f][1][k-1][l]$ 。 $(j<f<=4)$

若 $l>0$ ，就有 $dp[i][j][1][k][l]+=dp[i-1][f][0][k][l-1]$ 。 $(1<=f<j)$

$dp[i][j][1][k][l]+=dp[i-1][f][1][k][l]$ 。 $(1<=f<j)$

$dp[i][j][0][k][l]+=dp[i-1][f][0][k][l]$ 。 $(j<f<=4)$

状态转移方程有了，接下来给个初始值，dp还不是轻轻松松？

时间复杂度约为 $O(nt^2)$ 。
#  _**Code**_ 
```c
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,t,dp[21][6][2][15][15];
signed main()
{
	cin>>n>>t;
	if(n<3)
	{
		cout<<0;
		return 0;
	}
	dp[2][1][0][0][0]=3;
	dp[2][2][0][0][0]=2;
	dp[2][3][0][0][0]=1;
	dp[2][2][1][0][0]=1;
	dp[2][3][1][0][0]=2;
	dp[2][4][1][0][0]=3;//给初始值
	for(int i=3;i<=n;i++)
	{
		for(int j=1;j<=4;j++)
		{
			for(int k=0;k<=t;k++)
			{
				for(int l=0;l<t;l++)
				{//状态转移
					if(l)
					{
						for(int f=1;f<j;f++)
						{
							dp[i][j][1][k][l]+=dp[i-1][f][0][k][l-1];
						}
					}
					if(k)
					{
						for(int f=j+1;f<=4;f++)
						{
							dp[i][j][0][k][l]+=dp[i-1][f][1][k-1][l];
						}
					}
					for(int f=1;f<j;f++)
					{
						dp[i][j][1][k][l]+=dp[i-1][f][1][k][l];
					}
					for(int f=j+1;f<=4;f++)
					{
						dp[i][j][0][k][l]+=dp[i-1][f][0][k][l];
					}
				}
			}
		}
	}
	int ans=0;
	for(int i=1;i<=4;i++)
	{
		ans+=dp[n][i][0][t][t-1]+dp[n][i][1][t][t-1];//统计答案
	}
	cout<<ans;
 	return 0;
}//码完收工

```

