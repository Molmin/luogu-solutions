- 数轴上顺次有 $n$ 个点 $a_1 < a_2 < \cdots < a_n$。
- 有一只小青蛙，初始时在 $a_s$ 处。小青蛙有两个参数：步长 $d$ 和灵活程度 $k$。其中，步长 $d$ 是确定的，而灵活程度 $k$ 是可以调整的。
- 小青蛙可以从某个点跳到另一个点。但这是有要求的：小青蛙能从 $a_i$ 跳到 $a_j$，当且仅当 $d-k\leq |a_i-a_j|\leq d+k$。
- 给定 $a_1,...,a_n$ 和 $d$。你需要回答 $q$ 次询问，每次询问给定一个灵活程度 $k$ 和一个下标 $i$，你需要回答：此时的小青蛙能否跳到 $a_i$？
- 保证 $1\leq n,q\leq 2\times 10^5$，$1\leq s,i\leq n$，$1\leq a_i,d,k\leq 10^6$，$a_1 < a_2 < \cdots < a_n$。

初步分析，认为模型是最短路，即求出到每个 $a_i$ 所需的 $k_{\min}$，但是发现转移实际上需要的 $k$ 是 **路径上每条边对应 $k$ 的最大值**，所以其实是一个 Kruskal 重构树模型。

现在面临的问题实际上是一个 **完全图 MST**，常见的做法有 Boruvka 算法，先考虑这个怎么做。其实就是要求每个点（不方便对于连通块整体考虑）连出去的最短非同色边，也就是在 $a_i+d,a_i-d$ 找到前驱后继中第一个和自己不同色的，那么第一个辅助工具是 **并查集启发式合并+线段树维护区间内颜色的 $\min,\max$ 并支持线段树二分**，这样就能做到 2log，但是瓶颈有一个启发式合并+线段树单点修改，还有一个 Boruvka+线段树二分，常数较大；另一个易于实现得多的做法就是，每轮把每个点所属连通块编号写成序列，只需要找某个位置向前向后第一个不同色的，那么维护一个全局可用点的 `std::set`，对于每个颜色先删掉其中所有这个颜色的点，再对每个该色点进去找对应位置的前驱后继，完事再重新塞回去，这样的复杂度也是 2log，复杂度瓶颈只有 Boruvka+set 一处，但是  set 的常数也比较大。

另外，完全图 MST 还有一个分治求法：求 $G=(V,E)$ 的 MST，把 $V$ 划分为 $S,T$，只保留 $S,T$ 之间的 MST 需要的边（丢掉 Kruskal 过程中一定不会被使用的边），然后再保留 $S,T$ 内部的 MST，这些边一定包含原图的 MST。注意这个过程是可以递归处理的，除非能方便地求出 $S,T$ 内部的 MST。同时，求出之间 MST 的超集也是可以的。在本题中，可以证明，对于每个 $i\in S$，找到 $a_i+d$ 前后第一个和自己不同点集的点之间的边并保留，对每个 $j$ 找 $a_j-d$ 的前驱后继，这 $2n$ 条边一定是 MST 的超集。用这种方法找到的边足够小，因为根据 Kruskal 的过程，如果证明了连通性，那么更远的边权值更大一定会被丢掉。连通性的证明考虑把 $i\in S$ 的 $a_i+d$ 和 $j\in T$ 的 $a_j$ 放在一起排序，那么对于相同类型的一段 $i$，其找到的 $j$ 是同一个；$a_i$ 和 $a_j-d$ 也是同一个序列，那么同一段 $j$ 找到的 $i$ 也是同一个，所以内部联通，相邻段连通，整图联通。依然是 2log，但是常数比较小。复杂度瓶颈之一在于把找到的 $O(n\log n)$ 条边排序并建立 Kruskal 重构树/最小生成树，可以桶排+离线双指针维护连通性，可以拓展到 $s$ 不固定的情况；另一个瓶颈是如何快速对每个 $i$ 找到对应的 $j$，发现按照上面的流程归并就好了，这样比 2log 难写一些，但是做到了 1log。[Submission](https://codeforces.com/contest/1550/submission/204185717)