
### Subtask 1

我会枚举！

### Subtask 2

$n=1$ 直接输出 $v_1$。否则我们观察到，最大的剩下的数即为最大的 $n-1$ 个数之和减去最小的一个数。证明如下：

不难发现每个数对答案的贡献只可能是 $-v_i$ 或者 $v_i$。首先最终的数不可能为序列中所有数之和，因为考虑任何时刻序列中的一个数，它必然是由至少一个 $v_i$（正的）再加上一堆可正可负的 $v_j$ 构成的，这个可以简单归纳证明。然后如果最后的数是 $v_1+v_2+\cdots+v_n$ 的话，考虑最后一次操作，必然是将 $v_i$ 减去 $\left(-\sum_{j\ne i}v_j\right)$，但是根据上面我们的结论后面那个数是不可能存在的，构成矛盾。

然后我们构造一种方案得到这个最大的数。很简单：不妨令 $v$ 从小到大有序，我们取出 $v_1,v_2$ 得到 $(v_1-v_2)$，取出 $(v_1-v_2),v_3$ 得到 $(v_1-v_2-v_3)$，以此类推，直到最后得到 $v_1-v_2-\cdots-v_{n-1}$，最后用 $v_n$ 减去这个数就可以得到 $-v_1+v_2+\cdots+v_n$。

### Subtask 3

推广上面的结论：在 $n\ne 1$ 时，对于任意整数 $1\le k<n$，我们都存在一种方案使得最终的数是最大的 $(n-k)$ 个数减去最小的 $k$ 个数。

这里直接构造证明：令 $v$ 从小到大有序，取出 $v_1,v_{k+1}$ 得到 $(v_1-v_{k+1})$，取出 $(v_1-v_{k+1}),v_{k+2}$ 得到 $(v_1-v_{k+1}-v_{k+2})$，重复直到得到 $(v_1-v_{k+1}-v_{k+2}-\cdots-v_{n-1})$，然后用 $v_n$ 减去它得到 $(v_{k+1}+v_{k+2}+\cdots+v_n-v_1)$，最后再用这个数依次减去 $v_2,v_3,\cdots,v_k$ 即可得到 $(v_{k+1}+v_{k+2}+\cdots+v_n-v_1-v_2-\cdots-v_k)$。

于是我们直接对 $v$ 排序。如果全是正数，则输出前 $n-1$ 大的减去最小的；如果全是负数，则输出最大的减去前 $n-1$ 小的；否则直接输出所有数的绝对值之和即可。

[mivik.h](https://mivik.gitee.io/mivik.h) / [代码](https://paste.ubuntu.com/p/rC5fpppKst/)
