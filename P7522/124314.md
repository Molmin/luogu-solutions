题目描述：你有一个长度为 $n$ 的序列 $v$，你每次可以 **取出** 两个数 $a,b$，并把 $a-b$ 添加到序列中。重复操作直到序列中只剩下一个数，你需要求出这个数的最大值。

显然这个可以看成序列通过任意排列之后添加减号和小括号所组成的表达式，由于减法不满足交换律和结合律，我们将此表达式转换为所有元素添加符号之后求和。不妨我们将前者叫做**减号表达式**，后者叫做**符号表达式**。两个表达式**等价**当且仅当减号表达式拆开所有括号后所有元素前面的符号与符号表达式中该数的符号一致。

下面我们证明这个结论：一个长度大于1的符号表达式能表示成减号表达式，当且仅当符号表达式中所有元素符号不同。

证明：必要性：当 $n=2$ 时，减号表达式和符号表达式均只有 $v_1-v_2$ 和 $v_2-v_1$ 两种。

$n>2$ 时，减号表达式有三种构成方法：（下文中 $A,B$ 均为长度大于 $1$ 的减号表达式）：

1. $v_i-A$
2. $A-v_i$
3. $A-B$

由于 $A$ 和 $B$ 对应的符号表达式均有不同符号的元素，所以得到的减号表达式对应的符号表达式中也存在不同符号的元素。

充分性：将符号表达式构造为减号表达式即可。具体的，当项数大于 $2$ 时分离出符号不与其他符号全不相同的一项，然后构造成 1 式或 2 式的形式即可。

综上，我们只需要找到一个符号不全相同的符号表达式，使得它的值最大。

先考虑如果不考虑符号不全相同的条件怎么做，将每个数字最大化，也就是取绝对值，答案就是它们的和。

这时只有全为正或者全为负的情况一定违背符号不全相同的性质。对于全正，找出最小的取负；对于全负，找出最大的取正。上述两条应用于一般情况也能得出最优解。

于是，只需要找出最小值和最大值，将其他值绝对值求和加最大值减最小值就是答案了。

```cpp
#include <cstdio>
#include <cmath>
#include <iostream>

using namespace std;
int Read() {
    int res = 0;
    int f = 1;
    char c = getchar();
    while (c < '0' || c > '9') {
        if (c=='-') f = -1;
        c = getchar();
    }
    while (c >= '0' && c <= '9') {
        res = res*10+(c^'0');
        c = getchar();
    }
    return res*f;
}
int main() {
    int n = Read();
    if (n==1) {
        printf("%d\n", Read());
        return 0;
    }
    int mini = Read();
    int maxi = Read();
    long long res = 0;
    int cur;
    if (mini > maxi) swap(mini, maxi);
    for (int i = 2; i < n; i++) {
        cur = Read();
        if (cur < mini) swap(cur, mini);
        if (cur > maxi) swap(cur, maxi);
        res+=abs(cur);
    }
    printf("%lld\n", res+maxi-mini);
    return 0;
}
```

时间复杂度：$\Theta(n)$

空间复杂度：$\Theta(1)$

~~要是我放这个题我会数据范围给9e6空间1MB~~