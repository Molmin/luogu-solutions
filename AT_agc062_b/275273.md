妙妙题。

像这种最优化问题，数据范围又比较小，大概率不是贪心，想 dp。

正着做不好做，因为你无法知道序列变成了什么样子，没有任何信息能记录到状态里面。

考虑逆序操作。每次相当于取出一个子序列，放到后面。最终目标是将数组排成升序。

考虑区间 dp，设 $f_{k,i,j}$ 为进行完第 $k \sim K$ 次操作，已经把数组中**值为 $i \sim j$ 的数排好序**。有转移：

- $f_{k,i,j} \gets f_{k+1,i,j}$，表示这次操作可以不动；
- $f_{k,i,j} \gets f_{k+1,i,x} + f_{k+1,x+1,j} + c_k \times (j - x), x \in [i,j)$，表示选权值在 $[x + 1, j]$ 之中的数，拎到最后面，花费是 $c_k \times (j - x)$。

初值是 $f_{m+1,i,j} = 0$，其中权值在 $[i,j]$ 之中的数已经在原排列中排好序。

答案就是 $f_{1,1,n}$。

时间复杂度 $O(n^3k)$。

[code](https://atcoder.jp/contests/agc062/submissions/41618049)