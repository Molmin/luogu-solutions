~~此篇题解是给像我一样的蒟蒻看的垃圾题解，大佬估计也不会刷黄题~~
## 题目大意
找到区间 ```{i,j}``` 使 ```j-i```最大，且区间 ```{i,j}``` 中男女数量相等

## 一些想法

### 这是最先想到的部分

很明显要存个前缀和，若```sum[i]=sum[j]```，说明区间```{i,j}```满足条件

我们不妨看个表格

| num[i]（当前数值，男生为1，女生为-1） | -1 | 1 | -1 | -1 | -1 | 1 | 1 | -1 | -1 |
| :----------- | :----------- | :----------- | :----------- | :----------- | :----------- | :----------- | :----------- | :----------- | :----------- |
| sum[i]（前缀和数组） | -1 | 0 | -1 | -2 | -3 | -2 | -1 | -2 | -3 | 

显然，当```sum[j]-sum[i]==0```的时候，区间中间的男生女生一正一负刚好抵消，区间 ```{i,j}``` 符合条件

### 最关键的部分来了
我们要寻找```sum[i] == sum[j]```，很明显，我们不能用O(n^2)的方式去爆搜

#### 我们怎么把时间降到O(n)呢？
我们想要找到符合条件的数对，为什么不以一种近似哈希~~实则就是哈希~~的东西吧每个前缀和最开始出现的位置和最后出现的位置记下来呢？

```
hash[sum[i]]._min表示前缀和sum[i]最先出现的位置

hash[sum[i]]._max表示前缀和sum[i]最后出现的位置
```

因为```i```是往前跑的，所以不用```max()```
最后遍历```i```：

## 一些代码段

```cpp
for(int i = 1; i < n + 1; i++) {
   hash[sum[i]]._min = min(hash[sum[i]]._min, i);
   hash[sum[i]]._max = i;
}
```
但是，这里会出现一些问题，比如这个样例，```sum```数组全都是负数，访问一个负数下标会RE或者出一些奇奇怪怪的数，所以要修改一下，加上100010（其实比n大就可以）

```cpp
for(int i = 1; i < n + 1; i++){
   hash[sum[i]+100010]._min = min(hash[sum[i]+100010]._min, i);
   hash[sum[i]+100010]._max = i;
}
```
最后输出一下就行了，用```ans```记录最大差值，最后如果是0就直接输出，否则输出```ans+1```

代码就不摆了（~~毕竟黄题~~），码风奇丑，望理解

## 一些需要注意的地方
1. 初始化hash数组的时候要从0跑到```2n```，~~保险起见我用了```2n+5```~~
2. 初始化hash数组的._min和._max一定得是```±100000```以上

3. 如果你的```i```是从0开始跑的，注意，在填充```sum```数组的时候要特判```i==0```

4. 加一个多少以便把负的加成非负的数的时候，一定小心你的```i```是从哪里跑的，一不小心就容易出一堆烂七八糟的东西
###### ~~悄悄说一句，就这一道黄题我调了快40分钟~~