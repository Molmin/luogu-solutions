**这题和P1250种树相似**  
大概题意就是给你一些区间的约束，然后求最小的元素个数  
一看到这个题就想到可以用查分约束来做，因为看到很多大佬都是用**查分约束**做的所以我在这里介绍用**贪心**做  
首先贪心嘛，一定就要有贪心策略噻，所以我们来枚举一下  
简单把样例的图画出来!
```
1   2   3   4   5   6   7   8   9   10
	        |-1-|
		            |---------3---------|
		               |-------3-------|
		         |-1-|
```
然后观察一下发现啥都不能看出来，因为太乱了，所以我们排序呗，排序就不乱了，我是按右端点排序的（左右都可以呀）排完序后就是下面这样啦
```
1   2   3   4   5   6   7   8   9   10
	        |-1-|
		        |-1-|		 
 		            |---------3---------|
		               |-------3-------|

``` 
这样就很直观了，我们就可以发现相邻两个线段有些公共的地方，我们就可以尽量在这些地方放元素，保证元素的总个数最少，这就是贪心策略啦  
所以我们每次枚举的时候就可以从每个区间的后面开始往这个区间前面开始枚举，如果这个地方可以放元素并且这个区间的元素个数还没有到达上限就放在这里呀 

举个例子  
```
3   4   5   6
    |-1-|
        |-1-|
```


这样我们在枚举上一条边的时候先看这区间已经有多少个元素了，如果已经满足这个区间就不用再看啦     
如果没有满足那么就从后往前看，5个地方有没有元素，5没有元素所以放在这里这个区间的元素个数就加一，再看看发现已经达到这个区间的上限啦，所以开始枚举下面的这个区间  
先从5到6扫一遍看看有多少个元素了，发现5已经有一个了就加一，最后整个区间看完后在对比这个区间的元素上限，发现已经大于等于了就不用再考虑了  

很简单吧，接下来是代码
```
#include<bits/stdc++.h>
using namespace std;

struct node{
	int from,to,s;//from表示这个区间的前段点所在位置，to表示这个区间的后断点的位置，s是区间元素的上限 
}a[20000];
bool cmp(node x,node y)
{
	return x.to<y.to;//按右端点开始排序 
}
int sum=0,n,v[20000];//sum表示所选元素总数，也就是答案，v数组记录这个位置放没放元素 
int main()
{
	cin>>n;//读入 
	for(int i=1;i<=n;i++)cin>>a[i].from>>a[i].to>>a[i].s;//读入 
	sort(a+1,a+1+n,cmp);//简简单单排个序 
	for(int i=1;i<=n;i++)
	{
		int ans=0;//临时记录这个区间现在有多少个元素了 
		for(int j=a[i].from;j<=a[i].to;j++)if(v[j])ans++;//先全部扫一遍这个区间有多少个元素了 
		if(ans>=a[i].s)continue;//如果已经满足这个区间的约束，那么就不用再加了，开始看下一个区间 
		for(int j=a[i].to;j>=a[i].from;j--)//从右往左扫 
		{
			if(!v[j])//如果这个地方没有放，就放在这里 
			{
				ans++;//总个数加一 
				sum++;//当前区间的元素个数加一 
				v[j]=1;//有元素了，改变状态 
				if(ans==a[i].s)break;//每次加的时候都判断的时候就判断一下达到上限没有 
			}
		}
	}
	cout<<sum;//输出答案 
} 
```
