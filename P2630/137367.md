[获得更好的阅读体验](https://shenyouran.github.io/P2630/)

这道题要求是输出最短、字典序最小的操作序列。对于这种最优解问题，使用$\text{BFS}$再好不过。

然而，在搜索之前，我们发现有这样的一句话：

> 保证长度不超过 $10^8$

这句话会导致我们认为本题非常的困难，但同时也给了我们一个暗示，即是否能够满足下面两点之一：

- 任何一个有解的答案长度必定不超过$s(s \lt 10^8)$

- 变换的过程有规律，可以找到周期进行计算

在考虑这些问题之前，我们来看一下变换的方式——题目中给出了四种。

显然，做$3$次$B$就等价与执行$1$次$A$，反之亦然。因此，$A$和$B$的任意一种执行次数$\ge 3$的时候，就必定可以转化为更少的执行次数。

例如：如果我们执行$3$次$B$，那么就等同于将图像逆时针旋转$90\times 3=270^{\circ}$，即把图像顺时针旋转$360-270=90^{\circ}$。这样就转化为了执行$1$次$A$。

为了更直观地呈现规律，我们不妨列出执行对应次数$B$时图像的变化：

|执行次数|旋转方向|旋转角度|转化操作|
| :----------: | :----------: | :----------: | :----------: 
|$1$|逆时针|$90^{\circ}$|$B1$|
|$2$|逆时针/顺时针|$180^{\circ}$|$A2$
|$3$|顺时针|$90^{\circ}$|$A1$
|$4$|/|$0^{\circ}$|/|
|$5$|逆时针|$90^{\circ}$|$B1$|
|$...$|$...$|$...$|$...$|

观察上表可发现，规律为每$4$个为一周期。因此，任何次数的$B$操作，都可以被转化为执行次数$\le 2$的$A$操作。反之亦然。

根据操作规律可知，$C$和$D$操作在分别执行$2$次后等价于不执行。也就是说，执行了$n$次这两种操作中的一种，都等同于操作$n\bmod 2$次。而$n\bmod 2$的最大值为$1$，所以“最坏情况”就是$C$和$D$各执行$1$次，即共执行$2$次。

综上所述，如果题目有解，那么总执行次数必定$\le 4$。这样一来，$10^8$的迷惑就被识破了。

因为总执行次数为$4$次，所以最终的字符串就有$4+4^2+4^3+4^4=340$种可能（全排列）。这样，队列元素下标只需要$341$个就足够了（~~其实开一千个也无妨~~）。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int front=1,rear=1;//定义队列的队头和队尾
struct matrix
{
    int a[4][4];//图像大小为3*3
}first,goal;//这里直接定义该类型的变量，其中first表示初始图像，goal表示目标状态
struct node
{
    matrix m;//表示对应状态下的图像
    string seq;//表示对应状态下的字符串
}q[341];//上面提到，341个元素已经足够了
matrix change(matrix x,char opt)
{
    matrix y;//定义即将被替换的图像
    switch(opt)//每一个字符对应着题目中的操作类型
    {
        case 'A':
        {
            /*
            123     741
            456 ->  852
            789     963
            可以通过下列方式变换：
            123     147     741
            456 ->  258 ->  852
            789     369     963
            即先将图像横纵坐标交换，再将每一行倒置
            */
            for(int i=1;i<4;i++)
            {
                for(int j=1;j<4;j++)
                {
                    y.a[i][j]=x.a[4-j][i];
                }
            }
            break;
        }
        case 'B':
        {
            /*
            123     583
            456 ->  472
            789     361
            可以通过下列方式变换：
            123     147     369
            456 ->  258 ->  258
            789     369     147
            即先将图像横纵坐标交换，再将每一列倒置
            */
            for(int i=1;i<4;i++)
            {
                for(int j=1;j<4;j++)
                {
                    y.a[i][j]=x.a[j][4-i];
                }
            }
            break;
        }
        case 'C':
        {
            /*
            可以理解为，将每一行的数字进行翻折（两个图像成轴对称，列不变）
            123     321
            456 ->  654
            789     987
            */
            for(int i=1;i<4;i++)
            {
                for(int j=1;j<4;j++)
                {
                    y.a[i][j]=x.a[i][4-j];
                }
            }
            break;
        }
        case 'D':
        {
            /*
            可以理解为，将每一列的数字进行翻折（两个图像成轴对称，行不变）
            123     789
            456 ->  456
            789     123
            */
            for(int i=1;i<4;i++)
            {
                for(int j=1;j<4;j++)
                {
                    y.a[i][j]=x.a[4-i][j];
                }
            }
            break;
        }
    }
    return y;
}
bool check(matrix x)//判断是否符合目标状态，具体方法是比较目前图像和目标图像
{
    for(int i=1;i<4;i++)
    {
        for(int j=1;j<4;j++)
        {
            if(x.a[i][j]!=goal.a[i][j])
            {
                return false;
            }
        }
    }
    return true;
}
int main()
{
    //输入初始图像
    for(int i=1;i<4;i++)
    {
        for(int j=1;j<4;j++)
        {
            scanf("%d",&first.a[i][j]);
        }
    }
    //输入目标图像
    for(int i=1;i<4;i++)
    {
        for(int j=1;j<4;j++)
        {
            scanf("%d",&goal.a[i][j]);
        }
    }
    q[1]=(node){first,""};//初始化队头，其中图像为初始图像，字符串为空
    while(front<=rear)
    {
        node f=q[front++];//取队头并出队
        for(char c='A';c<='D';c++)//注意可以进行字符的循环（ASCII码可以直接使用）
        {
            node cur=(node){change(f.m,c),f.seq+c};//新的元素是上一个元素在经过对应操作之后得到的，而字符串是在原来的基础上加上该字符得到的
            if(cur.seq.size()<5)q[++rear]=cur;//如果字符串长度<5，即<=4就入队。注意一旦长度大于4，就不再入队，很快宽搜的循环就将结束（因为rear不变，而front一直在变大）
            if(check(cur.m))//判断是否到达目标状态
            {
                cout<<cur.seq;
                return 0;//宽搜找到的是最优解，所以可以直接结束程序
            }
        }
    }
    puts("Poland cannot into space!!!");//无解就输出对应信息
    return 0;
}
```