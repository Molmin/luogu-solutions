### 注意！不开 long long 见祖宗！

咳，记住要开 long long ，不然会 WA 。

然后这题的思路其实也很简单，主要其实就是要计算组合方法有几种。（建议dalao们先跳过，和我一样的小蒟蒻们一定要认真看哦~）

因为 n 的范围比较大，多以暴力枚举很有可能（或者说肯定）会 TLE ，所以就需要用一些其他的算法了。

题目中也明确说明了 $-10 \leqslant a_i \leqslant 10$ 所以~~很容易~~就能想出需要的算法：桶排序！

对于负数下标，我们可以将其存储在它的绝对值加 10 的桶里。

然后就是组合方式的计算。

我们先假设 x 和 y 是一对相反数，也就是 $x + y = 0$ 且 $x \ne y$。

再假设在输入中有 p 个 x 和 q 个 y。

那么我们不难推导出：

对于每个 x ，都可以和 所有即 q 个 y 形成一对组合。而我们总共有 p 个 x ，也就是说，关于 x 与 y 的组合个数为 $x \times y$ 。

其次，因为 0 与 0 相加就是零，但按照上述的方法计算，0 的组合个数就会变成 ${t_0}^2$ （假设存储 0 的桶为 $t_0$ ），很显然这样的个数是不对的。

而对于 0 的组合方法数的推导和上述的方法类似：每个 0 都可以和其他的 0 进行组合，但是由于题目要求对于下标 i 和 j ， $i < j$ 所以为了避免出现 $i \geqslant j$ 的现象，我们就不能将已经与目前的 0 已经计算过的 0 再次组合了，也就是前面的 0 都不能再算了。

那么此时 0 的组合方法数就很容易得出来了： $1 + 2 + 3 + ... + (t_0 - 1)$ 。

是个等差数列，一眼就看出来了对吧？

那么就可以得出 0 的组合方法数就为 $[0 + (t_0 - 1)] \times t_0$ 。

终于要上代码啦！

#### **Code：**
```cpp
#include<bits/stdc++.h>
using namespace std;
long long ans,n,a,t[55];
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a;
		if(a<0)t[abs(a)+10]++;//放入存负数的桶中 
		else t[a]++;//放入存正数的桶中 
	}
	for(int i=1;i<=10;i++)ans+=t[i]*t[i+10];//计算除了0以外的组合 
	ans+=(t[0]-1)*t[0]/2;//最后加上0的组合数 
	cout<<ans;
	return 0;//结束 
}
```
###### 卑微地~~求个赞~~