//程序特点：纯C语言编写，可以C或C++提交。 目标：大家花时间尽量能看懂的代码(跟踪程序，更容易看懂代码) 。

//题解：该程序的编写，建立在3个样例上(m-1指的是m的前一位)，提供给大家：

```cpp
//样例1
//输入:456 397
//输出:456
//样例2
//输入:456 398
//输出:1000
//样例3
//输入:10 10
//输出:0
//样例1：
//对于456而言，从100~455 都可以，有456-100=356个。
//从10~45 也可以 有45-10+1 =36个 //45是可以的，以为456还有后面的数，所以45也小于456（字典序）
//从1~4中也都可以，有更正4-1+1=4//原因同上
//最大数到456，比456字典序小的个数为(456-100+1)-1+(45-10+1)+(4-1+1)个,即 (456-100+1)+(45-10+1)+(4-1+1)-1个,即396个，getcount函数因此算法编出 
//样例2：
//同样例1思路，但第397个数在小于456里面找不到了，只能从1000~(4560-1)里面进行寻找，可寻找的数目(4560-1)-1000+1=3560个，while(cnt<m-1)里面的内容由此编出
//多算个数cnt-(m-1)，如样例2，cnt=396+3560 m-1=398-1 cnt-(m-1)=3560+396-(398-1)=3599。
//多算个数的数字，属 1000~(4560-1)区间，故m-1位置处数字是，(4560-1)-(3560+396-(398-1))=1000, 过m-1位置处数字是(c-1)-(cnt-(m-1)) 
//在m-1，m位数字间取最大值，即为答案,如样例2,1000 456最大值为1000;样例1 455 456 最大值为456
//样例3的原因是，10最多只能有1字典序比10小，再也找不到满足题意的其他数，字典序比10小了，故要添加 k==base&&cnt<m-1的判断，否则 测试点9,14,16,34,48TLE
#include <stdio.h>
long long base,cnt=0;//如456 base=100 
void getcount(long long x){//获得小于x的，且字典序小于x的数的个数
    long long base1=1,x1=x,x2=x;
    while(x1){//数出x的位数，如456 计算得出base1=100
        x1/=10;
        base1*=10; 
    }
    base1/=10;//因为多 一次*10，故此处 一次/10 
    base=base1;//如456 base=100  
    while(x2){//最大数到456，比456字典序小的个数为(456-100+1)-1+(45-10+1)+(4-1+1)个,即 (456-100+1)+(45-10+1)+(4-1+1)-1个,即396个，getcount函数因此算法编出 
        cnt+=x2-base1+1;
        x2/=10;
        base1/=10;
    }
    cnt-=1;//cnt计算小于x，且字典序小于x的数的个数 
}
long long max(long long a,long long b){
    return a>b?a:b;
}
int main(){
    long long k,m,c,p;
    scanf("%lld%lld",&k,&m);
    getcount(k);
    if(cnt>m-1||k==base&&cnt<m-1){//1 此处写成 if(cnt>m-1)漏了一种情况 10 10 无输出结果。 
        printf("0\n");//无解 
        return 0;
    }
    c=k,p=k-base;
    while(cnt<m-1){//计算大于x，且字典序小于x的数的个数。 //同样例1思路，但第397个数在小于456里面找不到了，只能从1000~(4560-1)里面进行寻找，可寻找的数目(4560-1)-1000+1=3560个，while(cnt<m-1)里面的内容由此编出
        c*=10;
        p*=10;
        cnt+=p;
    }
    printf("%lld\n",max(k,(c-1)-(cnt-(m-1))));
    return 0;
}

```