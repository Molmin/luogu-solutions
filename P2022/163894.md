**题解都好玄啊。。说一个（可能）好理解一点的。**

首先理解一下题意：在K前面按字典序从小到大插入M-1个字典序小于K的数，**求最后一个插入的数的字典序**；若**不存在M-1个字典序小于K的数字**或者**最后一个数在数值上小于K**，则输出0。

暂先不考虑输出0的情况。

显然，我们需要先把数值上小于K的数字算出来，因为这些数字必须要被插入到K前。这个应该不困难，按数位去算就好了。

算出来之后**更新M**，进而考虑**找出M个数值大于K但字典序小于K的数**。

若M = 0，输出K就好了。

考虑所有位数和K相同且字典序小的数，显然我们可以**在这些数后面加0~9来得到一个字典序同样小于K的数**。

```cpp
例如 24 ， 和它位数相同且字典序小的数有
10, 11, 12, ..., 19
20, 21, 22, 23
在上面两行数中任选一个，在其后添上任何数字，字典序都小于K。
如20，可以通过添加0~9变为200,201,202,...,209,都字典序小于24。
注意在24后添加数字，所得到的数字字典序定大于K。
```
那么我们记这些“位数且字典序小”的数个数为fulllen，显然fulllen也容易算出来。

那么我在(K-1)的字符串后面添加x个"9"，就**相当于在K前插入了fulllen \* 10^x 个字典序小于K的数字**。

```cpp
例如，24的fulllen = 14, 那么在23后面添加一个9，得到N=249，则相当于插入了
1 : 100, 101, ..., 109,
2 : 110, 111, ..., 119,
...,
14: 230, 231, ..., 239
总计插入了14 * 10 个数字
```
显然如果添"9"可以解决问题，那么这个解是最优的。但同样显而易见的是，**只添"9"并不一定能恰好插入M个数, 而这也并不意味着无解**。

假定每次添加"9"之后**更新M为还剩下要插入的数**，若添加了一些"9"之后，再添加所插入的数大于了M，那么答案一定是10000....0 + M - 1。

```cpp
例如，在24后添加了一定的9之后，得到了
23999999999
而还剩下233个数字没有插入，那么最优解就是
100000000000 + 233 - 1

放在一起比较两者的位数能方便理解：
A = 23999999999
B = 100000000000
C = 233
D = B + C - 1
首先B大于A，而再加上(C-1)后在24前新插入了C个数字，这些数字是：
100000000000
100000000001
100000000002
...
100000000222
恰好补上了所缺的233个数字。
```

那么，只要能在K-1后添加9就添加9，还有剩下的就用10000...0 + M - 1的方式补上，若有解的话就能得到最优解了。

考虑无解。

最容易想到的当然是取出数值小于K的数后，M小于0.

其次，类似10000的数字是不存在“数值上大于它而字典序小于它”的数字的，特判掉就好了。

```
#include <ctime>
#include <cstdio>
#include <cstdlib>
#include <cstring>

#include <algorithm>

namespace kyel {
	typedef long long lint;
	lint n, m, pow[20];
	int num[20];
	int getnum(lint v, int num[]) {
		int len(0);
		while (v) num[len++] = v % 10, v /= 10;
		return len;
	}
	void work() {
		int len(getnum(m, num));
		lint fulllen(0), tem(m);
		for (int i(len - 1); i; --i) {
			tem /= 10;
			n -= tem - pow[i - 1] + 1;
		} n -= (fulllen = m - pow[len - 1]) + 1;
		if (n < 0) { printf("0\n"); return; }
		if (n == 0) { printf("%lld\n", m); return; }
		lint sub(fulllen * 10), cnt(0);
		if (sub == 0) { printf("0\n"); return; }
		while (n > sub) {
			n -= sub, sub *= 10, ++cnt;
		}
		if (n == sub) printf("%lld\n", pow[cnt + 1] * m - 1);
		else printf("%lld\n", pow[len + cnt] + n - 1);
	}
	void kyel() {
		scanf("%lld%lld", &m, &n);
		pow[0] = 1;
		for (lint i(1); i <= 19; ++i) {
			pow[i] = pow[i - 1] * 10;
		}
		work();
	}
}
int main() {
	kyel::kyel();
	return 0;
}
```
