## P1536 村村通
[题目链接](https://www.luogu.org/problemnew/show/P1536)  
这题粗略地看了一下，其实主要思想就是把已经连好的城镇看成一个点。那么，接下来定义一个数组（用作桶），来记录有多少个不同的点。设有$n$个点，那么就输出$n-1$就好啦。

$\mathcal{Code:}$  
```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int n=1,m;//n代表有多少个村庄，m是代表已有多少条路
int f[10000];//储存每个节点的“祖先”
void init()//预处理，一开始把每个结点的祖先设为自己
{
	for(int i=1;i<=n;i++)f[i]=i;
    //千万不能在输入前用此函数（n都没输入怎么预处理）
}
int find_(int x)//用到了路径压缩，比单纯的while更快
{
	if(f[x]==x)//如果x的祖先是自己
    	retrun x;//那么返回x就好了。
    return find_(f[x]);//如果不是的话，x的祖先的祖先就是x的祖先
}
void union_(int x,int y)//合并x,y两个结点
{
	f[find_(y)]=find_(x);//让x的祖先成为y的祖先的祖先，这样y所在的集合里所有结点的祖先全变为x的祖先。
}
int main()
{
	while(n!=0)
	{
		scanf("%d",&n);//输入n
		if(n!=0)//判断n是否等于0
			scanf("%d",&m);//是就输入m
		else//否则就跳过
			continue;
		if(m==0)//如果m（路的条数）等于0的话，那么想必就没有路了
		{
			printf("%d\n",n-1);//连起n个节点最少就要n-1条线
			continue;
		}
		init();//预处理
		int x,y;//定义x城镇的y城镇的编号
		int sum=0;//用于存储最少的路径条数
		int a[10000]={0};//桶，用于记录有多少个没有路径的城镇
		for(int i=1;i<=m;i++)
		{
			scanf("%d%d",&x,&y);//输入x and y的编号
			union_(x,y);//因为x y之间有路线了，就合并它们
		}
		for(int i=1;i<=n;i++)//开始判断
		{
			int c=find_(i);//判断编号为c的城镇的“祖先”
			if(!a[c])//如果这个“祖先”的编号没有被记录过的话
				a[c]++,sum++;//那么就记录它，节点数加一。
		}
		printf("%d\n",sum-1);//因为有n个不同的集合，那么就至少要n-1条边才能把它们连起来。
	}
    return 0;
}


```
以上就是本题的主要思想，其他巨佬们也可以用各种玄学数据结构来~~玩~~做这道题了。其实这道题可以用于给并查集入门的萌新们打基础，那么我来通俗地讲讲```并查集```到底是什么吧。

假设最开始，有一堆无依无靠的结点（可以把它们都看作一棵树），如下:  
![](https://cdn.luogu.com.cn/upload/pic/52115.png)

它们都很伤心，因为它们都很孤独。这时，上帝来了，他说:“$2$号有个朋友，它的名字叫$1$号！”这时，$1$号和$2$号便被一条边连了起来，成为了同一棵树（$1$号是$2$号的朋友，所以$1$号储存的值更改为$2$，其实反过来也可以）。如下：  
![](https://cdn.luogu.com.cn/upload/pic/52116.png)  

这时，上帝又说：“$1$号有个朋友，它的名字叫$5$号！”，这时，$1$号就为难了，它是该“归顺”$5$号，还是该“归顺”$2$号呢？这时，$1$号想到了一个办法：直接跟他的大哥（祖先：$2$号）谈！因为我们知道，朋友的朋友就是朋友，那么直接将$2$号的值赋值为$5$就好了（反过来也可以）！如下：  
![](https://cdn.luogu.com.cn/upload/pic/52120.png)  
接着，上帝说:“$3$号有个朋友，它的名字叫$7$号！”这时，我们运用刚才所说的方法，把$3,7$合并。如下:  
![](https://cdn.luogu.com.cn/upload/pic/52121.png)  
后来，上帝说：“$7$号有个朋友，它的名字叫$4$号！”这时，$7$号为难了，它是该“归顺”$4$号，还是该“归顺”$3$号呢？没关系，运用之前的方法，我们可以解决掉这个问题！  
![](https://cdn.luogu.com.cn/upload/pic/52163.png)  
上帝又说：“$8$号有个朋友，它的名字叫$6$号！”这时，你是不是觉得很$easy$?只需把$6,8$合并就好了！  
![](https://cdn.luogu.com.cn/upload/pic/52164.png)  
这时，稍微有点难度的来了，上帝说:“$2$号有个朋友，它的名字叫$6$号！”呀，是两个结点有$2$个以上的集合合并！该怎么办呢？不要慌，只需把$6$的祖先（$8$）设为$2$的祖先（$5$）即可！  
![](https://cdn.luogu.com.cn/upload/pic/52168.png)  
并查集中的“并”是不是很容易？那么让我们来看一看另一个操作———“查”吧！

让我们回到之前的内容———现在，每个人都有朋友了^_^，上帝现在想知道，谁和谁是（或者不是）朋友？  
此时，上帝问道：“$1$和$6$是朋友吗？”这时候，我们刚赋的值派上用场了！  
![](https://cdn.luogu.com.cn/upload/pic/52169.png)  
如图，红色箭头代表$6$号寻找祖先之路，绿色箭头代表$1$号寻找祖先之路，然后，他们找到了共同的祖先，“朋友的朋友就是朋友”，既然他们有共同的朋友（祖先），那么他们就是朋友了！  
然后，上帝又问道：“$2$和$7$是朋友吗？”再次运用刚才的方法，可得到如下图：  
![](https://cdn.luogu.com.cn/upload/pic/52167.png)  
橙色箭头代表$2$号寻找祖先之路，蓝色箭头代表$7$号寻找祖先之路，最终，他们的祖先并不一样（分别是$5$和$4$）。既然他们的祖先都不一样，那么他们就绝对不是朋友（不在同一集合）。   
如果你理解了以上讲的内容，那么你就理解了并查集的精髓了！并查集的“并”、“查”操作可以在上面找到。去看一看吧！  
但是，聪明的人会问：找$1$和$6$的朋友时，其实可以建一条边，使$8$可以直接到达$5$。对，没错！这就是———路径压缩！  
其实，路径压缩只需在“查”时加五个字符即可！  
$\mathcal{Code}$
```cpp
int find_(int x)
{
    if(f[x]==x)
        return x;
    return f[x]=find_(f[x]);
}
```  
这样，寻找$1$和$6$的祖先时，就会变成下图！  
![](https://cdn.luogu.com.cn/upload/pic/52172.png)  
同理，寻找$2$和$7$祖先时，就会变成下图！  
![](https://cdn.luogu.com.cn/upload/pic/52166.png)  
是不是感觉快了很多？其实，并查集是很简单的。以下是我给大家推荐的题目：  
- [P3367 【模板】并查集](https://www.luogu.org/problemnew/show/P3367)
- [P1551 亲戚 ](https://www.luogu.org/problemnew/show/P1551)
- [P2256 一中校运会之百米跑](https://www.luogu.org/problemnew/show/P2256)    