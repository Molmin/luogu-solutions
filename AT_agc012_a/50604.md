### [题目链接qaq](https://www.luogu.org/problemnew/show/AT2361)  

看一遍题，会很自然地联想到这道题是贪心，很显然会用到排序（小声）  

~~sort真好用~~


------------

# 正文部分

我们要求的是每3个人一组，每组中位数之和的最大值既然是中位数，而第3n个数又是这组数中最大的。那第3n个数一定对答案**没有贡献**（任何排列都无法使最大值成为某三个数的中位数）  

既然最大值没用，那就尽量让第二大的有用（大哥走了二哥上），而最小值又是我们最不想要的（小弟去勾引），所以很显然第一个三个数的排列就是【最小值，第二大的值，最大值】，答案增加的就是第二大的值。将这三个数去掉后又有了一组新的序列，和刚才做法一样对新序列进行操作，依此类推最后的边界就是第n-1个数。  


------------

下面给出一组例子（样例1）：  
n=2  
5 2 8 5 1 5  
标号：  
n-1，n，3 , 4 , 3n-1 , 3n；  
对应代码进行理解吧各位TT

排序过后：  
1 2 **5** 5 **5** 8  

排列方式：  
【1,5,8】
【2,5,5】  

答案：  
ans=5+5;  


------------

上代码咯：   
```cpp
#include<bits/stdc++.h>
using namespace std;

const int maxn=300000+10;
//因为n是100000，所以有300000个人，数组记得开够emm 
long long n,a[maxn],ans=0;//下意识开long long

int main()
{
	scanf("%lld",&n);
	for(int i=1;i<=3*n;i++){
		scanf("%lld",&a[i]);//输入也要3*n 
	}
	sort(a+1,a+1+3*n);//排序也要3*n 
	for(int i=(3*n)-1;i>=n+1;i-=2){
//		枚举也要3*n 
		ans+=a[i];
//		从倒数第二位开始向前枚举，每次跳过一个再加上一个 
	}
	printf("%lld\n",ans);
}
```  

呜呜呜我被这个“3倍”坑了好几次qaq  

结束。