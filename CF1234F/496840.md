关键词：状态压缩 DP。

题意很简单易懂，给定字符串 $S$，可以翻转 $S$ 的任意一个子串，求翻转后 $S$ 的子串中每一个字符都不相同的最长子串长度。其中 $|S|\le 10^6$，记字符集为 $V$，有 $|V|\le 20$。

看到 $|V|\le 20$ 我们一般往高维 DP 或者状压 DP 上想。注意到通过翻转操作我们可以把任意两个不相交的子串拼接在一起，这里给一个构造解，假设现在有串 $abcde$，欲使子串 $d$ 与 $b$ 拼接，只需翻转 $bc$ 或 $cd$ 即可，对于更长不相交子串都可以规约到这个模型上。有了这个结论，我们发现我们无需关心子串的位置，而只要看子串内部含有的字符种类即可，我们使用状态压缩记录串内是否出现某种字符即可。

设计状态 $f(x)$ 为串内出现字符状态为 $x$ 的每一个字符都不相同的子串的长度，我们考虑 $O(|S||V|)$ 枚举每一个字符都不相同的子串 $T$（下标从 $0$ 开始），即对 $\forall i,j\in [0,|T|)\cap \mathbb{Z}$，若 $i\ne j$，都有 $T_i\ne T_j$，可以用下面这种方法处理出 $f(x)$ 的初值（即翻转之前各状态对应的值）：

```cpp
for(int cx=0;cx<n;++cx){
  int S=0;
  for(int cy=0;cy<B&&cx+cy<n;++cy){
    //B 为字符集大小，即题解中的 V
    int ch=s[cx+cy]-'a';
    if(S&(1<<ch)) break;
    S|=(1<<ch);
    dp[S]=cy+1;
  }
}
```

接下来考虑对串的翻转，我们要的是翻转后没有相同字符的最长子串长度，所以在全集 $U=2^V$ 上枚举，可以得知 $f(x)$ 的状态转移方程：

$$
f(x)=\max_{x\subseteq U} \{ f(x),\max_{y\subseteq x } f(y) \} 
$$

其中 $\oplus$ 为按位异或。而 $\max_{y\subseteq U\oplus x } f(y)$ 正是我们之前预处理出的 $f$ 的初值，代码如下：

```cpp
for(int S=0;S<U;++S)
  for(int cx=0;cx<B;++cx)
    if(S&(1<<cx)) dp[S]=std::max(dp[S],dp[S^(1<<cx)]);
```

统计答案时直接在全集上枚举即可，答案即 $\max_{x\subseteq U} (f(x)+f(U\oplus x))$。

由此，我们有了一个 $O(|S||V|+|V||U|)$ 即 $O(|S||V|+|V|2^{|V|})$ 时间复杂度的做法，可以通过本题。

另附：[提交记录](https://www.luogu.com.cn/record/76697804)，想要完整代码可以找我。