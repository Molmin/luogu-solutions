与其他题解结论相同，但证明更加符号化。

[传送门](https://www.luogu.com.cn/problem/P5794)

#### 前置知识：

后缀排序。

#### 分析：

记原串为 $s$，题目给出的字符串为 $a$；记 $rk_i$ 表示以 $i$ 为起始位置的后缀的排名，$sa_i$ 表示排名为 $i$ 的后缀的起始位置。注意这里的后缀是包含空后缀的。

由于字符 `.` 的字典序小于任何字符，所以题目中的排序相当于后缀排序。所以有 $s_{sa_i-1}=a_i$。

同时，由于题目中的排序相当于后缀排序，所以 $a_i$ 在 $s$ 中的后 $n$ 个字符，即为后缀排序后的第 $i$ 个后缀。

而后缀排序，即按照 $rk_i$ 排序，等价于按 $s_i$ 为第一关键字，$rk_{i+1}$ 为第二关键字排序。我们将 $i$ 替换为 $sa_i-1$，这就等价于按 $s_{sa_i-1}=a_i$ 为第一关键字，$i$ 为第二关键字排序。同时由于 $a_i$ 已知，我们就知道了排序后每个字符串的首字母。

这样我们就获得了 $n+1$ 条形如 $a_i$ 在 $s$ 中的后 $n$ 个字符的首字母为 $a_j$ 的关系，注意这里所知的是下标的关系而非字符的关系。所以我们就可以求出 $s$ 了。

放出关键部分的代码。

```cpp
n=read(), m=read();
rep(i, 0, n) a[b[i]=i]=read();
sort(b, b+n+1, [](int x, int y) {return a[x]^a[y]? a[x]<a[y]: x<y;});
//以 a[i] 为第一关键字，i 为第二关键字排序
//排序后 a[i] 的下一个字符是 a[b[i]]
for(int i=b[b[0]]; a[i]; i=b[i]) printf("%d ", a[i]);
```