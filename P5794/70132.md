update：更换了跑得更快的题解代码。

这里不妨先设“原来的串”就是加上 0 的串，最后去掉 0 就是答案。

显然，最后得到的串一定是原来的串的一个排列。  
我们先把串当做环考虑。  
如果串里面的每个字符各不相同，那么我们就知道了排序后的串每个串的第一个字符是什么。  
移位之后可以发现 **排序后的**每个字符串的**最后一个字符**，一定是**第一个字符**的前面的那个字符，下文称作“前继”。  
同时我们也知道排序后每个串的最后一个字符是什么，那么我们得到了 $n+1$ 组前继关系，可以构建出环了。  
注意到最开始 0 是在最前面的，那么我们以 0 作为起点破环成链就是答案。

如果串里面的每个字符不相同。我们依然得到了 $n+1$ 组相邻关系，只是分不清哪个是哪个了。  

那我们考虑一件事情，有两个相同的字符 $a$，并且我们得到了 $(a \leftarrow b)$，$(a \leftarrow c)$两组前继关系，那么显然是 $b$ 前面的那个 $a$ 排名更加前面。  

由此我们可以得到一个结论，越早出现的前继为 $x$ 的字母，在排名中也出现得更早。  
既然如此，我们重新定义一下：**排序后的字符串的排名为这个字符串开头的字母的排名**。  
注意这里的“字母”不仅包括它是什么，还包括它的位置等元素。  

那么我们可以得到，前继为 $x$ 越早出现，那么前继的排名越小。

具体看代码。

代码很短：  
`a[i]` 表示读入的串。  
`b[i]` 表示排名为 $i$ 的字符是啥。  
`c[i]` 表示是 $i$ 的字符有几个。  
`d[i]` 是答案串。  
`pre[i]` 是排名为 $i$ 的字符的前一个字符的排名。
```cpp
#include<bits/stdc++.h>
#define rd(x) x=read()
using namespace std;
const int N=2e5+5;
inline int read(){int x=0,f=1;char ch=getchar();while(ch>'9'||ch<'0'){if(ch=='-')f=-1;ch=getchar();}while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}return x*f;}
int a[N],b[N],c[N],d[N];
int n,m,t;
int pre[N];
int id[N];
signed main()
{
   rd(n);rd(m);n++;
   for (int i=1;i<=n;i++) rd(a[i]),c[a[i]]++;
   for (int i=0;i<=m;i++) for (int j=1;j<=c[i];j++) {b[++t]=i;if (!id[i]) id[i]=t;}
   for (int i=1;i<=n;i++) pre[i]=id[a[i]]++;
   for (int i=1,x=1;i<=n;i++) d[n-i+1]=b[x],x=pre[x];
   for (int i=1;i<n;i++) cout<<d[i]<<" ";cout<<endl;
}
```