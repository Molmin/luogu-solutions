为了使改动后的数字尽量小，那么我们就需要**从高位到低位**修改，让原数除第一位以外尽可能多的为零（注意最高位不能为零）。但如果这个位置上的数本身就是零，那么就直接跳过，节约修改次数。

以上为贪心策略，但此策略不能全面解决一些特殊问题：比如整个数只有一位。
因此我们需要一些特判（见代码）：

**Code:**
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,k;//n为长度，k为修改次数
string a;
int main()
{
	int i;//在这里定义便于修改
	scanf("%d%d",&n,&k);
	cin>>a;
	if(!k) cout<<a,exit(0);//若k为0，直接输出并退出
	if(a.length()==1)
	{
		puts("0");
		exit(0);
	}//若n=1,直接输出0并退出
	if(a[0]=='1')
	{
		i=1;//若第一位已经为1，则直接从第二位开始修改，节约修改次数
	}
	else 
	{
		a[0]='1';
		k--;
	}//否则直接修改，也从第二位开始
	for(;i<a.length();i++)
	{
		if(k>0&&a[i]!='0')//可修改
		{
			a[i]='0';
			k--;
		}
		if(!k) break;//修改次数用完
	}
	cout<<a;//输出已经修改的字符串
	return 0;
}
```