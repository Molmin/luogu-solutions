这道题不是很难，却坑点极多，我被坑了有四五次，我真是太菜了。。。

# 思路

给大家总结一下比较重要的坑点和思路吧。

- 不能有前导零，即更改后的字符串开头不为 $0$。

- 如果遍历到字符串第一个字符，只能更改为 $1$，但如果本来就是 $1$，则不需要做出任何改变，避免重复浪费更改机会。

- 遇到非零的数时（前提不是开头），果断改为 $0$。

- 如果遇到 $0$ 的时候，不用做任何改变，避免重复浪费更改机会。

- 注意判断字符串长度为 $1$ 的时候。

说了这么多点，大家可能脑子稍微有点绕不过来，那么下面就给大家放代码，这样就能理解思路了。

# 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
	//定义
	
	 
	int n,i,cnt,k;// cnt 表示现在替换了多少个数。 
	char s[200001];
	
	//输入
	 
	scanf("%d %d %s",&n,&k,s);
	
	//处理
	 
	if(n==1)//特判字符串长度为 1. 
	{
		if(k==0)//如果不给我们机会更改 
			printf("%s\n",s);//输出原字符串。 
		else
			printf("0\n");//否则直接输出 0。 
		return 0;//及时结束程序，避免进入下面的操作。 
	}
	
	//字符串长度不为 1
	
	cnt = 0;// cnt 初始设为 0。 
	for(i=0;i<n;i++)
	{
		if(cnt<k&&s[i]!='0')//如果我们还有机会替换且当前字符不为 0 
		{
			if(i==0&&s[i]!='1')//如果是开头且开头的数不为 1 
				s[i] = '1',cnt++;//把开头替换成 1，操作次数 cnt++。 
			else if(i!=0)//否则就是不开头的情况 
				s[i] = '0',cnt++;//设为 0，操作次数 cnt++，此时不用担心把原来的 0 替换成 0 而浪费，因为我们在前面的 if 判断中已经刨去了当前字符为 0 的情况。 
		}
	}
	printf("%s\n",s);//输出更改后的字符串。 
	return 0;//结束 
}
```
