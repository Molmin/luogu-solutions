由于我太菜了不会长剖，所以只能给这个题写个暴力 DP 做法了。

---

首先这个 $>k$ 我们可以转化为 $\geq k+1$。后文的 $k$ 默认已经 $+1$。

我们考虑以 $u$ 为根的子树。不难发现，我们只需要知道 $u$ 子树内距离 $u$ 最近的点距离为 $i$ 即可按照题目限制进行转移了。

所以令 $dp_{u,i}$ 表示以 $u$ 为根的子树内，距离 $u$ 最近的点的距离 $\geq i$ 的时候，答案的最大值。

转移的话，按照树形背包的常用套路，我们考虑从 $u$ 的儿子 $v$ 向上转移。

由于不考虑重复贡献的话，我们选定的强制对距离做出贡献的点只会有一个，我们每次转移的添加过程中可以决策当前的 $v$ 是否强制做出贡献，进而分类讨论。

$dp_{u,i}=\max\begin{cases}dp_{u,i}+dp_{v,\max(i-1,k-i-1)}\\dp_{u,\max(i,k-i)}+dp_{v,i-1}\end{cases}$

由于每次 dfs 之后得到的 dp 数组中，$dp_{u,i}$ 只考虑了恰好为 $i$ 的情况，所以要跑一遍后缀最大值使 dp 数组记录的数是符合我们的定义的。

最终的答案为 $dp_{1,0}$。复杂度 $O(n^2)$。

[Code & Submission](https://codeforces.com/contest/1249/submission/211250455)