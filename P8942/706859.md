#### 题外话
~~为啥我的方法那么复杂~~

### 题意
有一个密码共 $n$ 位，每个数都在 $[1,m]$ 之间，并且单调不减。如算出前缀异或和，那么前缀异或和也单调不减。如算出后缀异或和，那么后缀异或和仍然单调不减。给定 $n,m$ 的值，让你构造出一组密码，以满足所有特征。对于每组数据，如不存在满足要求的密码，输出 `No`。否则输出 `Yes`，并在下一行输出一种合法方案。

### 分析
首先我们得知道**前缀异或和**与**后缀异或和**的含义。异或是一种逻辑运算，通常以 $\text{xor}$ 来表示，其**相当于不带进位的二进制加法**。例如 $1$ 异或 $2$ 等于 $3$。详细资料可查看[百度百科](https://baike.baidu.com/item/%E5%BC%82%E6%88%96/10993677?fr=aladdin)。这里前缀异或和就表示：
$$
a_1\le \ a_1\ \text{xor}\ a_2\ \le \ a_1\ \text{xor}\ a_2\ \text{xor}\ \cdots\ \text{xor}\ a_{n-1}\ \text{xor}\ a_{n}
$$

后缀异或和也是一个道理，从后往前。

既然这是道构造题，那我们来枚举一下：如果一个 $3$ 位的密码是 $1,2,3$，那么 $1\ \text{xor}\ 2\ \text{xor}\ 3$ 的结果就是 $0$ 了。那我们把第 $3$ 位改成 $4$ 呢？这样 $1\ \text{xor}\ 2\ \text{xor}\ 4$，结果是 $7$，满足上面的条件。再接着往下枚举，我们很容易就能发现构造一个为 $1,2,4,8,16\cdots$ 的密码是可行的。

再看一眼数据范围，$1\le m\le2^{63}-1$，要开 `long long`。同时出题人写 $2^{63}-1$ 而不是 $10^{18}$ 可能也是想提示我们从 $2$ 的角度去思考。那我们就可以把 $2$ 的 $64$ 次方以内的表先打出来，然后按照上面讲的模拟即可。其实还是比较好理解的。

最后注意 $2^{64}$ 会爆 `long long`，所以我们把 `long long` 换成 `unsigned long long` 就可以过了。


------------


### 打表代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
	unsigned long long n=1;
	cout<<n<<",";
	for(int i=2;i<=64;i++)
	{
		n*=2;
		cout<<n<<",";
	}
    return 0;
}
```


### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
unsigned long long a[65]={0,1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,262144,524288,1048576,2097152,4194304,8388608,16777216,33554432,67108864,134217728,268435456,536870912,1073741824,2147483648,4294967296,8589934592,17179869184,34359738368,68719476736,137438953472,274877906944,549755813888,1099511627776,2199023255552,4398046511104,8796093022208,17592186044416,35184372088832,70368744177664,140737488355328,281474976710656,562949953421312,1125899906842624,2251799813685248,4503599627370496,9007199254740992,18014398509481984,36028797018963968,72057594037927936,144115188075855872,288230376151711744,576460752303423488,1152921504606846976,2305843009213693952,4611686018427387904,9223372036854775808};
int main()
{
	int t;
	cin>>t;
	while(t--)
	{
		int n;
		long long m;
		cin>>n>>m;
		bool flag=0;
		for(int i=2;i<=n;i++)
		{
			if(a[i]>m)//如果1~m范围内放不下这个2的几次方，就是无解的。 
			{
				flag=1;
				break;
			}
		}
		if(flag)
		{
			puts("No");
		}
		else
		{
			puts("Yes");
			for(int i=1;i<=n;i++)
			{
				cout<<a[i]<<" ";
			}
			puts("");
		}
	}
    return 0;
}
```
