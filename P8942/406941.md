签到题。

不减是假的，否则会出现相邻两数相同或数列中数为 $0$ 的情况。

容易发现有构造 $a_i=2^{i-1}$，正确性显然，现在证明其最优性。

先证明一个推论：二进制位递增是该数列递增且前缀异或和递增的充要条件。

必要性证明：设 $s_i$ 为 $a_{1\sim i}$ 的异或和，在数列中有两个相邻的数 $a_i,a_{i+1}$ 满足 $2^k\le s_i<a_{i+1}<2^{k+1}$，根据异或的性质，最高位必定变为 $0$，则 $a_i\ \text{xor}\ a_{i+1}<2^k$，与递增性质矛盾。归纳后得证。

充分性证明：当数列满足该条件时，由于异或运算中高位不受低位影响，所以递增性质与低位无关。

由于该条件，将除最高位外所有位置 $0$ 为值域最小的解法：$\{1,10,100,1000,\cdots\}_2=\{2^0,2^1,2^2,2^3,\cdots\}_{10}$。并且，该构造同时满足第二条性质。所以其最优性得证。

具体解法：当 $m<2^{n-1}$ 时判断无解，否则输出 $a_i=2^{i-1}$。

# AC 代码
```cpp
#include <bits/stdc++.h>

using namespace std;

typedef long long ll;

int t, n; ll m; 

int main() {
	for (scanf("%d", &t); t--;) {
		scanf("%d%lld", &n, &m);
		if (__lg(m) + 1 < n) puts("No");
		else { puts("Yes"); for (int i = 0; i < n; i++) printf("%lld ", 1ll << i); puts(""); }
	}
}
```