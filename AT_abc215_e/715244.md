## 思路
考虑状压 DP，我们设 $dp[i][ch][st]$ 表示在前 $i$ 个里面选 $ch$ 表示选的序列以 $ch$ 结尾，$st$ 表示选的字母的状态，范围是 $2^{10}$。

先转移不选第 $i$ 个点的，可以写出转移式 $dp[i][ch][st]=dp[i-1][ch][st]$。

然后转移选第 $i$ 个点的，枚举转移的状态 $st$，我们再分成两种情况，如果选过那一种字符，就只存在一种转移 $dp[i][ch][st]=dp[i][ch][st]+dp[i-1][ch][st]$，表示将第 $i$ 个字符接在后面，显然只能最后一个字符是 $ch$ 才能进行转移，然后考虑没有选过的情况，这种好想的多就不解释了，$dp[i][ch][st|(1<<ch)]=dp[i][ch][st|(1<<ch)]+dp[i-1][x][st]$，这里的 $x$ 表示的是暴力枚举的字符串的最后的那一个字符。

最后一步就是初始化，我们可以想到当我们不选时显然是有一种情况的 $dp[0][0][0]=1$，最后记得减去 $dp[0][0][0]$，因为不能有空串。

当然这个 DP 还可用滚动数组来优化掉一维，但因为没有超空间就没优化。

[代码](https://atcoder.jp/contests/abc215/submissions/39559766)