# 新手友好七十行代码
[题目传送门](https://www.luogu.com.cn/problem/P1225)

 这道题大体的思路比较简单，就是用 bfs 模拟方阵的变化。对于每一步操作**暴力枚两个数交换的所有方案（如果有重复的就跳出）**，然后判断是否与答案相符，**如果匹配成功就输出，如果不成功就将其压入 bfs 大队列继续搜索。** ~~想必本蒟蒻都能想出来~~ ，我在这里就不详细解释了。

 但是作为一道蓝题，它的代码还是有亿点点长的。本蒟蒻为了减少代码量，本蒟蒻在这里使用了一些小优化：
1. **使用函数 work 将新的状态压入队列**，这个函数可以同时代替队列初始化时和 bfs 时的入队操作，十几行代码瞬间蒸发。

2. 在运行时把矩阵的第一行第一个数当作状态的最高位，记为 16 位，第一行第二个当做状态的第二高位，记为 15 位······以此类推。**这样矩阵表示的二进制与状压值是完全相等的**,由此实现状压会更加简便，大家在下面的程序里可以看到。


3. **在bfs 过程中加入位运算，代替将状态转为数组，再将数组转为状态的操作**。这也是本程序的最大特色，具体操作如下：
- 	一号操作：求 $x$ 在二进制中的第 $k$ 位： $a=(x>>(k-1))\&1;$
- 	二号操作：将 $x$ 的第 $k$ 位由 $0$ 变为 $1$ : $x=x\bigoplus(1<<(k-1);$
- 	三号操作：将 $x$ 的第 $k$ 位反转： $x=x(1<<(k-1));$



读入并初始化时，只需要使用操作 $2$ 对数据进行累加，就能得到最初状态对应的整数了；如果要交换两个相邻的数，先用操作 $1$ 判断两个数是否相同，如果不同的话（如果相同交换就没有意义了，在这里只考虑不同的情况）就将两个数分别反转得到下一状态。

这种方法比较好想到，比较好理解（就是对于新手比较友好），而且**不用在整数与数组之间来回切换**，减少了大量的代码量，同时节约了时间，大家可以参考一下这个方法。


## 贴代码咯：
```cpp
#include<bits/stdc++.h>
using namespace std;
int a,b,f[100000];//a:原始状态 b：目标状态  f：状态标记 去重
int c[3][905];//空数组 备用 
struct st
{
	int way[3][905],num,s;//way记录此状态以前的过程，num记录步骤数，s是当前状态 
};
queue<st>q;
void work(int now,int x,int y,int nu,int w[3][905])//当前状态，两个要交换的所在位置，步骤，以前的步骤 
{
	int x2=(now>>(x-1))&1;
	int y2=(now>>(y-1))&1;
	if(x2==y2)return;
	now=now^(1<<(x-1));
	now=now^(1<<(y-1));//交换x位置和y位置的数 
	if(f[now])return;//去重 有点类似于记忆化搜索 
	f[now]=nu;
	st fr;//更新情况 
	fr.num=nu;
	fr.s=now;
	w[1][nu]=x;
	w[2][nu]=y;//更新步骤 
	memcpy(fr.way,w,sizeof(fr.way));//将新步骤加入 
	q.push(fr);//入队 
}
int main()
{
	for(int i=1;i<=16;i++)
	{
		char x;
		cin>>x;
		if(x=='1')a+=1<<(16-i);//初始状态初始化 
	}
	for(int i=1;i<=16;i++)
	{
		char x;
		cin>>x;
		if(x=='1')b+=1<<(16-i);//目标状态初始化 
	}
	f[a]=1;
	for(int i=1;i<=16;i++)
	{
		if(i%4!=0)work(a,i,i+1,1,c);//如果没有越界，则i和左边的交换 
		if(i%4!=1)work(a,i,i-1,1,c);//如果没有越界，则i和右边的交换 
		if(i<=12)work(a,i,i+4,1,c);//如果没有越界，则i和上面的交换 
		if(i>4)work(a,i,i-4,1,c);//如果没有越界，则i和下面的交换 //ps:此图的左上角是第16位，右下角是第1位 
	}
	while(!q.empty())
	{
		st now=q.front();
		q.pop();
		if(now.s==b)//如果与目标状态重回，则输出 
		{
			cout<<now.num<<endl;
			for(int i=1;i<=now.num;i++)
			{
				cout<<(16-now.way[1][i]+1-1)/4+1; 
				cout<<(16-now.way[1][i]+1-1)%4+1;
				cout<<(16-now.way[2][i]+1-1)/4+1;
				cout<<(16-now.way[2][i]+1-1)%4+1<<endl;//分别表示要交换的两个数所在的行，列 
			}
			return 0;//如果找到直接升天 
		}
		for(int i=1;i<=16;i++)
		{
			if(i%4!=0)work(now.s,i,i+1,now.num+1,now.way);//如果没有越界，则i和左边的交换 
			if(i%4!=1)work(now.s,i,i-1,now.num+1,now.way);//如果没有越界，则i和右边的交换 
			if(i<=12)work(now.s,i,i+4,now.num+1,now.way);//如果没有越界，则i和上面的交换 
			if(i>4)work(now.s,i,i-4,now.num+1,now.way);//如果没有越界，则i和下面的交换 //ps:此图的左上角是第16位，右下角是第1位 
		}
	}
}
```



------------

## THE END