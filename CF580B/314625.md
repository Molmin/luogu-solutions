
~~楼上大佬题解写得太深奥了，像我这样的小蒟蒻看不懂啊。所以我来写一篇题解，让和我一样弱的人都能够看懂。~~

------------

> 没人想觉得自己穷，所以 Kefa 邀请的朋友中两两工资差小于 $d$。

针对这个问题，我们要对 $n$ 个人的 **工资** 排序。接下来我们对工资差的问题就很好控制了。

由于还要求友谊和，所以我们还要对友谊值算前缀和。

接下来就是滑动窗口了。

滑动窗口这个算法十分简单，拿这道题来说：

首先有两个指针 $l$ 和 $r$。

然后 $l,r$ 移动过程中分两种情况：

* $r$ 和 $l$ 的工资差小于 $d$，那么 $r \gets r + 1$。

* $r$ 和 $l$ 的工资差大于等于 $d$，那么 $l \gets l + 1$。

那么这个算法的时间复杂度是多少？它为什么是正确的？

这题滑动窗口对于每一个点 $l$，极限的 $r$ 就是 $l$ 的最优值（就是说从 $l$ 开始选，最多只能选到 $r$）。等到 $r$ 和 $l$ 的工资差大于等于 $d$， 马上开始算的就是 $l + 1$ 的最优值了。这也有一点点贪心的思想（能选的朋友尽量选）。

这题滑动窗口的时间复杂度是 $O(n)$，因为每个数最多进窗口一次、出窗口一次（众所周知，时间复杂度是忽略常数的）。

```cpp
#include<iostream>
#include<algorithm>
using namespace std;
int n,d,l=1,r=1;
long long s[100010],ans;
struct node{
	int m,s;
}a[100010];
bool cmp(node x,node y){ //按工资升序排序。 
	return x.m<y.m;
}
int main(){
	cin>>n>>d;
	for(int i=1;i<=n;i++){
		cin>>a[i].m>>a[i].s;
	}
	sort(a+1,a+n+1,cmp);
	for(int i=1;i<=n;i++){
		s[i]=s[i-1]+a[i].s;//友谊值算前缀和。 
	}
	while(l<=n&&r<=n){//滑动窗口。 
		if(a[r].m-a[l].m<d){ans=max(ans,s[r]-s[l-1]);r++;}//如果可以从 l 选到 r 的话，就可以那它们的友谊和跟 ans 取 max。
		else l++;
	}
	cout<<ans;
	return 0;
}
```