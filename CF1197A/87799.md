我们要k尽可能大,要尽可能选大的数。

之后可以发现:无论选几个比第二大小的数,第二大的不变,于是我们只需要找到第二大的数就可以了。

怎么查找第二大的数呢?如果要排一遍序,显得非常的麻烦,而且非常的耗时。我们可以记录两个变量,一个是第一大的,一个是第二大的。

如果当前输入的数比最大的还要大,更新最大的,旧的最大值就变成了次大值,更新次大值。

如果当前输入的介于次大值和最大值之间(**一定不能比最大值大**),就更新次大值。

把数组遍历完,次大值就找到了。这里看似最大值没有用,可需要它来保证次大值不和最大值重复。
```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
    int t,n,i,j,k,a,max1,max2; //max1:最大值 max2:次大值。
    cin>>t;
    for(i=1;i<=t;i++){
        cin>>n;
        max1=0; //多组数据记得赋值。
        max2=0;
        for(j=0;j<n;j++){
            cin>>a;
            if(a>max1){
                max2=max1; //先赋值,不然更新的就是新的最大值
                max1=a;
            }else if(a>max2){
                max2=a;
            }
        }
        k=min(max2-1,n-2); //注意至多只能到n-2,不然就取不了了。
        cout<<max(0,k)<<endl; //如果比0小,就是没有符合要求的数,所以对0取最大值。
    }
    return 0;
}
```