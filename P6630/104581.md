考虑对于线段树的每个节点，有多少种方案使这个节点有标记。

记 $t=\dfrac{n(n+1)}{2}$，设 $a_i,b_i,c_i,d_i,e_i$ 分别表示 **能直接给第 $i$ 个节点打上标记的区间操作数，能直接将第 $i$ 个节点的标记拆掉的区间操作数，不能直接给第 $i$ 个节点打上标记但能将其祖先的标记传给该节点的区间操作数，不会对该节点标记情况有影响的区间操作数，能给第 $i$ 个节点或其祖先打上标记的区间操作数**。

那么根据样例一我们能列出这样的表格：

![](https://cdn.luogu.com.cn/upload/image_hosting/yy0ga2qf.png)

| $i$ | $a_i$ | $b_i$ | $c_i$ | $d_i$ | $e_i$ |
| -----------: | -----------: | -----------: | -----------: | -----------: | -----------: |
| $1$ | $1$ | $5$ | $0$ | $0$ | $1$ |
| $2$ | $2$ | $0$ | $3$ | $1$ | $3$ |
| $3$ | $1$ | $3$ | $1$ | $1$ | $2$ |
| $4$ | $2$ | $0$ | $1$ | $3$ | $4$ |
| $5$ | $1$ | $0$ | $2$ | $3$ | $3$ |

比如对于 $3$ 号节点，区间 $(2,3)$ 可以直接给它打上标记；区间 $(1,2),(2,2),(3,3)$ 能将它的标记拆掉；区间 $(1,1)$ 不能直接给它打上标记，但如果它的祖先（$1$ 号点）有标记，那么它祖先的标记会被传给它；区间 $(1,3)$ 在本次操作时不会改变它的标记情况；区间 $(1,3),(2,3)$ 可以将其或其祖先打上标记。

可以得到：

$\begin{cases}a_i+b_i+c_i+d_i=t\\a_i=e_i-e_{fa_i}\\d_i=e_{fa_i}+\dfrac{l_{fa_i}(l_{fa_i}-1)}{2}+\dfrac{(n-r_{fa_i})(n-r_{fa_i}+1)}{2}\\e_i=l_i\times(n-r_i+1)\end{cases}$

其中 $l_i,r_i$ 分别为该节点所记录线段的 $l,r$，$fa_i$ 为该节点父亲的编号。

（特别的，$a_1=e_1=1,b_1=t-1,c_1=d_1=0$）

问题就在于如何计算 $b_i$ 和 $c_i$ 了。

发现如果一个区间满足 不能直接给第 $i$ 个节点打上标记但能将其祖先的标记传给该节点，一定有某个端点在第 $i$ 个节点的兄弟表示的线段内，并且两个端点在第 $i$ 的节点的同侧。于是就可以求出 $c_i$ 了。

利用 $b_i=t-a_i-c_i-d_i$ 就可以求出 $b_i$ 了。

简(fu)单(za)来讲就是：
```cpp
//ca,cb,na,nc,cfa依次对应上面的a,b,c,d,e
void csh(int &w,ll L,ll R)
{
	w=++tot,cfa[w]=L*(n-R+1)%p;
	if(L==R)return;
	ll m=dr();
	csh(ls[w],L,m),csh(rs[w],m+1,R);
	ca[ls[w]]=L*(R-m)%p,ca[rs[w]]=(m+1-L)*(n-R+1)%p;
	nc[ls[w]]=nc[rs[w]]=(cfa[w]+((L*(L-1))>>1)+(((n-R)*(n-R+1))>>1))%p;
	na[ls[w]]=((((n<<1)-m-R+1)*(R-m))>>1)%p,na[rs[w]]=(((L+m)*(m-L+1))>>1)%p;
	cb[ls[w]]=(t-ca[ls[w]]-nc[ls[w]]-na[ls[w]]+p*3)%p,cb[rs[w]]=(t-ca[rs[w]]-nc[rs[w]]-na[rs[w]]+p*3)%p;
}
int main()
{
	/* 代码 */
	csh(rt,1,n);
	ca[rt]=cfa[rt]=1,cb[rt]=(t-1+p)%p;
}
```


记 $f_{i,j},g_{i,j}$ 分别为第 $i$ 个节点在 $j$ 次操作后 自己/自己或其某个祖先 有标记的方案数。

可得：

$\begin{cases}f_{i,j}=t^{j-1}\times a_i+g_{i,j-1}\times c_i+f_{i,j-1}\times d_i\\g_{i,j}=t^{i-1}\times e_i+g_{i,j-1}\times(t-b_i-e_i)\end{cases}$

（$g_{i,j}$ 中最后 $-e_i$ 是因为和上面有重复所以减去，其他由定义可得）

特别的，$f_{i,1}=a_i,g_{i,1}=e_i$。

然后就容易想到用矩乘做了。

复杂度 $O(27n\log k)$。