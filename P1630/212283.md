首先，提出性质 $1.0$：

$$(a+b)^x\equiv a^x\pmod b$$

为什么？用二项式定理展开后发现除了 $a^x$ 项以外，都带有 $b$，可以整除消掉。

那么上式显然成立，同时题目让我们求：

$$\left(\sum\limits_{x=1}^{a}x^b\right)\bmod 10^4$$

怎么办呢？从暴力开始。

## Sol.1 暴力

每次乘法 $O(b)$，总共循环 $a$ 次，一共 $N$ 组数据，复杂度 $O(Nab)$。

什么概念呢？$10^2\times 10^9\times 10^9=10^{20}$，挺快的，跑个几万年也许能出来吧。

## Sol.2 快速幂

快速幂是二分的思想，这里引用我一年前写的文字：

> 用递归或循环的方式将 $a^n$ 二分转化为 $a^{n\div 2}\times a^{n\div 2}$。
>
> 我们可以用答案自乘之类的办法实现二分。
>
> 从而将 $O(n)$ 优化为 $O(\log n)$。

```cpp
inline int quickpow(int a,int b){
	int s=1;
	while(b){
		if(b&1)s=(s*a)%mod;
		a=(a*a)%mod;
		b>>=1;
	}return s%mod;
}
```

我们很容易把这个 $b$ 优化成 $\log b$，那么复杂度就是 $O(Na\log b)$，可以么？

$\log(10^9)$ 大致是 $30$ 这个样子，那就是 $3\times 10^{12}$ 次运算了，还是受不起。

考虑我们文章开头的那个优化吧。

## Sol.3 数论

$$(a+b)^x\equiv a^x\pmod b$$

$$(a+10^4)^x\equiv a^x\pmod{10^4}$$

因为模数是 $10^4$ 一个很小的数，那就考虑这么办——这意味着，超过 $10^4$ 就会出现循环节，而这个数我们已经求过了。

预处理吧。

那是怎么样呢？也就是说，求出 $10^4$ 以内的 $x^b$。

这时候我们要求 $(x+10^4)^b$ 时，我们就不用再求了。

从头到尾来一遍，一共 $a$ 个数，每个统计一遍，是 $O(a)$，再说，如果我们要求 $10^4$ 个快速幂，复杂度：

$$a+10^4\times\log b\to O(a)$$

显然不行，就凭这 $a\le 10^9$。

## Sol.4 统计

继续优化，显然可以优化的是统计部分。

直觉发现，重复的部分一共出现了 $\left\lfloor\dfrac{a}{10^4}\right\rfloor$ 次，可以直接乘上去。

多余的部分再统计就行了。

大概就只需要 $O(\log b)$ 这样子，当然有一个 $\times 10^4$ 的常数加持，但不影响。

也就是说，你总共要运行 $10^4\times\log b+a\bmod 10^4$ 次运算。

还可以再快么？

## Sol.5 前缀和

你发现这是一个求和，你发现可以直接调用，你发现多余部分不用再统计了，前缀和可以解决烦恼。

于是常数又小了一点，你只需要作 $10^4\times\log b$ 的快速幂了。

当然还有更多的优化方法，但是没必要，是么？

代码容易实现，不给了。