这道题真的是一个大水题，按照正常的思路此题应该用数学知识来化简复杂度，但暴力的复杂度仅仅有$O(N\sqrt{N})$，而数据范围为$n <= 10000 $，这个复杂度肯定能过去

而代码的思路又是什么呢？

已知要通过$1-n$个正方形来组成长方形，而又因长方形的面积公式为：

## $S=a*b$

所以可以暴力枚举1-n个正方形组成长方形的长和宽也就是$a$和$b$

记住千万要去重，因为$a$跟$b$的数值交换位置算同一种

但这样的话复杂度不是$O(N^3)$吗？

$nonono$，有太多的地方可以优化了

第一级别：$O(N^3)$暴力

```cpp
for(int i = 1; i <= n; i++){
	for(int a = 1; a <= n; a++){
		for(int b = 1; b <= n; b++){
			if(a * b == 1) cnt++;
		}
	}
} 
//去重... 
```
这个级别真的是一点优化没有，更别说去重了，所以在这么弱的数据下也会超时（$O(N^3)$怎么可能过一万的数据吗）

第二级别：$O(N^2)$优化

```cpp
for(int i = 1; i <= n; i++){
	for(int a = 1; a <= n; a++){
		if(a % i == 0) cnt++; 
	}
} 
//去重... 
```
虽然这个级别的复杂度已经能过的了此题了，但还要去重也很麻烦，也是不推荐

第三级别：$O(N\sqrt{N})$优化

```cpp
for(int i = 1; i <= n; i++){
	for(int a = 1; a  * a <= i; a++){//此处跟a<=sqrt(i)效果一样
		if(a % i == 0) cnt++; //如果a是i的因数，计数器+1
	}
} 

```
优化到这一步已经算是胜利了，首先是复杂度稳过这道题，其次还免去了去重的问题

现在就要来讨论一下这个代码的准确性

答案肯定是对的，但为什么呢？

因为既然$i$肯定是要变为$a*b$的形式，那么就相当于只要求出$i$的因数就行了，而枚举到$\sqrt{i}$的原因是首先去重，因为大于$\sqrt{i}$的因数肯定被计算过了一次了，假如再算的话就重复了

这个代码的难度不高，也很容易想出来，是我比较推荐的类型

第四级别：$O(N)$或更低优化

此级别的代码需要有一定的数学功底（因为肯定是李勇数学优化的解法），不太容易想出来，除非数据范围很刁钻，我不太建议大家写这种代码。（其实一楼大佬写了好多第四级别的数学优化代码，如果感兴趣的话大家可以去看看）

要结束....

别别别，还没上代码呢~~差点忘记正事~~

### 放代码！

```cpp
#includ <bit/stdc++.h>
#define ull unsigned long long
#define ll long long
#define reg register
using namespace std;
//by szkzyc 
int cnt = 0;
void fic(int n){ //这里利用了比较好想的N*根号N级别的复杂度 
	for(int i = 1; i  <= n; i++){
		for(int j = 1; j * j <= i; j++){
		if(n % j == 0) cnt++;
		}
	}
	return ;
}
int mian(){
    int n;
	cin >> n;
	fic(n);
	cout << cnt << endl;
	return 1;
}
//请勿抄袭，营造洛谷的美好环境！（抄袭后果自负） 
```
### ---end---

这个题解蒟蒻写了好久，求通过qaq

