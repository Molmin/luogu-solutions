## 题目：
[传送门](https://www.luogu.com.cn/problem/CF1682A)
## 思路：
  由于问的是删去**单个**字符仍能保持回文的方案数，若从回文字符串的两侧删单个字符，则不能保持回文的性质（除非字符串中的字符全部相同，否则另外一侧必定有一个和被删字符相同的字符剩下），所以要从中间开始删。所以问题就变成了求该回文字符串中间字符连在一起的相同字符的数量（因为只能删掉单个字符），如样例中的 `acaaaaca`，从第 $3$ 个字符到第 $6$ 个字符，无论删掉哪个，都能保持回文的性质。就从中间的字符分别向两边遍历，记录相同字符的数量。需要注意的是：第二次遍历需要从中间字符右边的字符开始遍历，否则中间字符会被统计 $2$ 次。
## 代码：
```cpp
#include <bits/stdc++.h>
  using namespace std;
int m,n,s,i;
char c[100005];
int main()
{
	scanf("%d",&m);
	while (m--)
	{
		scanf("%d\n%s",&n,c);
		s=0;//记得初始化。
		for (i=n/2;i>=0;i--)//从中间字符向左遍历。
		{
			if (c[i]==c[n/2]) s++;
			else break;//若不相同就退出循环。
		}
		for (i=n/2+1;i<n;i++)//从中间字符的右边字符向右遍历。
		{
			if (c[i]==c[n/2]) s++;
			else break;//若不相同就退出循环。
		}
		cout<<s<<endl;
	}
	return 0;
}


```
