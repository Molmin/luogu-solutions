### 题意简述

给定 $n$ 和 $n$ 个单词，从中选一些单词组合使得组合的单词只有2个及以下的不同字母，问这种组合单词的最大长度是什么？

### 方法

这道题有两个方法，一个是对每个字符串分析取或不取，另一个是枚举组合后单词拥有的那两个不同字符。

这里讲一下第二种方法（~~其实是因为不会第一种~~）。

基本思路就是首先在读入每个单词的时候将这个单词所包含的每种字母的个数和不同字母的个数都记录下来。

然后枚举 $a$ ~ $z$ 的字符两个。

对于任意一种情况，我们把每个字符串都扫过去，如果这个字符串所含不同字母个数小于等于2，并且所含的两个字母正好是枚举到的两个字母或者只有其中一个字母是枚举到的字母但是这个字符串所含的不同字母数为1。

如果符合条件，$sum$ 加等于此字符串的长度。

答案为 $ max(sum)$。

如果没听懂，就看代码理解吧。

```cpp
#include <bits/stdc++.h>
using namespace std;
int n,b[105][30],pd[105],sum,ans;
//b储存某字符串每种字母的个数，pd是某字符串不同字母的个数。
string s[105];
int main()
{
	cin >> n;
	for (int i = 1; i <= n; i++)//在这里sum是某字符串不同字母的个数。
		{
			cin >> s[i];
			for (int j = 0; j < s[i].length(); j++)
				{
					if (b[i][s[i][j] - 'a' + 1] == 0) sum++;//如果之前没有统计到，sum++ 。
					b[i][s[i][j] - 'a' + 1]++;
				}
			pd[i] = sum;	
			sum = 0;
		}
	for (int i = 1; i <= 26; i++)
		{
			for (int j = i + 1; j <= 26; j++)//枚举 。
				{
					sum = 0;
					for (int k = 1; k <= n; k++)
						{
							if (((b[k][i] > 0 && b[k][j] > 0) || ((b[k][i] > 0 || b[k][j] > 0) && pd[k] == 1)) && pd[k] <= 2)
							//如上文的判断条件	。
								{
									sum += b[k][i] + b[k][j];
									//活用变量，这里的sum是当前枚举的情况的组合字符串最大长度 。
									//这里还可以写 sum += s[k].length();	
								}	
						}
					ans = max(ans,sum);		
				}	
		}
	cout << ans;		
	return 0;//AC!	
}
```
