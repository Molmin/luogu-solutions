第一次首杀！激动。。。

## 题意

找所有 $i$ 的后面的第一个大于 $a_i$ 的数，求他们的乘积，若没有则为 $1$。

## 思路

第一想法肯定是暴力，直接从 $i$ 开始枚举，只要找到一个数大于 $a_i$ 就停止。但这样是可以被卡到 $O(n^2)$ 的，所以不行。

这时候，就需要 **单调栈** 来优化。

首先，
## 单调栈是什么？

顾名思义，单调栈就是一个单调的栈，一般分两种，递增和递减。为了维护单调性，我们会弹出一些不需要的元素。

举个栗子，我们维护一个单调递减的栈，开始为空，$\{5,2,1,4\}$ 要依次入栈。

首先，$5$ 要入栈。因为栈是空的，所以 $5$ 直接入栈，栈中元素为 $\{5\}$。

然后，$2$ 要入栈。因为我们是维护递减的栈，$2$ 比栈顶 $5$ 要小，所以 $2$ 也直接入栈，栈中元素变为 $\{5,2\}$。

然后，$1$ 要入栈。同理，$1$ 比栈顶 $2$ 要小，所以 $1$ 也直接入栈，栈中元素变为 $\{5, 2, 1\}$。

然后，$4$ 要入栈。此时，$4$ 比栈顶 $1$ 要大，所以 $1$ 就可以再见了。再比较栈顶 $2$，$4$ 还是比 $2$ 大，所以 $2$ 也可以拜拜了。然后再与栈顶 $5$ 比较，发现 $4$ 比 $5$ 小，所以 $4$ 入栈，栈中元素变为 $\{5, 4\}$。

过程就是这么个过程，然后我们在来看这个题，你就会发现，这就是个大水题。

#### 还是以上面那个栗子为例。

首先，前三个数的过程不变。但当 $4$ 入栈时，他弹出了 $1$ 和 $2$。这说明了什么？大家可以想一想。

答案就是：
### $1$ 和 $2$ 后面比他们大的第一个数就是 $4$！
相信大家可以通过自己的思考得出这个结论。

那么代码就简单了。

## Code

```cpp
#include <iostream>
#define int long long//一定要开long long！！！
#define mod 1000000007
using namespace std;

int n;
int a[100005], b[100005];
int s[100005], top = 0;

signed main(){
	cin >> n;
	for (int i = 1; i <= n; i++)
		b[i] = 1;//初始化b数组
	for (int i = 1; i <= n; i++){
		scanf("%lld", a + i);
        //核心部分 
		while (top > 0 && a[i] > a[s[top]])//维护单调性，切记一定要先判断栈非空！
			b[s[top]] = a[i], top--;//弹出栈顶，并更新b数组 
		s[++top] = i;
	}
	int ans = 1;
	for (int i = 1; i <= n; i++)
		ans = (ans * b[i]) % mod;
	cout << ans;
	return 0;
}
```
