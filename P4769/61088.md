结论题还是要理性理解一下的嘛。

考虑题目里面给的那个下界显然要求每一个元素都不能多走一步，必须沿那个方向走到自己排好序之后所在的位置。

那么如果一个元素要向右走，那么它左边就不能有一个元素需要跨过它，否则它至少需要向左走一步。反之也一样：如果一个元素要向左走，那么它右边就不能有一个元素需要跨过它。特殊的，如果一个元素位于原位，那么它两边都不能跨过它。

但是这个结果的形式并不友好，考虑能不能简化一下。

首先最后一种的简化是很明显的：如果一个元素位于原位，那么左边不能有比它大的，右边不能有比它小的。

那么考虑剩下两种有没有相同的形式。观察到，如果一个元素要向右走，那么它的右边一定有比它小的，因为所有比它小的全放到左边它就不可能需要向右走了；而如果左侧有要跨过它的，那么这个元素一定比它大，否则不需要跨过它。对于向左走的是类似的。

整合一下，可以得到结论：**如果出现了长度为 3 的下降子序列，那么一定无法达到下界。**

而如果没有长度为 3 的下降子序列，那么每一个元素的贡献都可以达到下界，因此整个排列就可以达到下界。

~~当然我个人认为这一步打表还是比直接看出来要容易，至少我是通过打表搞出来的。~~

到这一步，我们有一个简单的状压 DP，可以得到 44 分。

然后由 dilworth，这样的排列一定可以被拆分成两个上升子序列。考虑对这样的排列进行多项式复杂度的计数。

设计 $O(n^2)$ DP：$f_{i,j}$ 表示填了排列的前 $j$ 个数，最大值是 $i$。有两种转移：

- 填个比最大值更大的，对 $k>i$ 转移到 $f_{k,j+1}$。
- 填个目前没填进去的最小的，如果 $i>j$，则转移到 $f_{i,j+1}$。

前缀和优化可以做到 $O(n^2)$。考虑一下这个前缀和的形式，它本质是把转移改成了 $f_{i,j}$ 向 $f_{i+1,j}$ 和 $f_{i,j+1}$ 转移。

这玩意看起来非常格线游走。$f_{i,j}$ 表示的是从 $(0,0)$ 开始，每次向上或向右移动 1 单位距离，不能走到 $y=x$ 上侧，走到 $(i,j)$ 的方案数。

套用卡特兰数的通项的证明方式可以类似得到 $f_{i,j}=\dbinom{i}{j}-\dbinom{i}{j-1}$。

那么现在就可以 $O(n)-O(1)$ 计算 $f$ 了。

最后考虑 $q$ 的限制。枚举一段前缀 $[1,i]$ 强制其和 $q$ 一样，然后强制 $i+1$ 放个比 $q_{i+1}$ 大的，然后后面就跟 $q$ 没关系了。

首先前面的部分需要合法。考虑递增枚举 $i$。如果 $q_i$ 比它前面所有 $q$ 都大，那么显然可以放。如果 $q_i$ 是前 $i-1$ 个数里面没出现过的数里面最小的数，那么也可以放。别的都不能放。如果发现需要放一个不能放的就 break 掉就可以了。

如果能放，那么计算强制 $i+1$ 放个比它大的数的方案数。显然不能放没出现过的最小的（因为前面都和 $q$ 一样，所以这个数一定 $\leq q_{i+1}$），所以方案数就是从 $(i,\max\limits_{j\leq i}q_j+1)$ 游走到 $n,n$，而且不走到线以上的方案数。这个稍微对称一下就能用上面的方法算了。

那么这题就做完了，复杂度 $O(\sum n)$。

```cpp
const long long mod = 998244353;
const int N = 1200005, mxN = 1200000;
int n, a[N];
long long f[N], fac[N], ifac[N];
bool vis[N];

inline void Prefix() {
    ifac[1] = 1;
    for (int i = 2;i <= mxN;i++) ifac[i] = (mod - mod / i) * ifac[mod % i] % mod;
    fac[0] = fac[1] = ifac[0] = 1;
    for (int i = 2;i <= mxN;i++) {
        fac[i] = fac[i - 1] * i % mod;
        ifac[i] = ifac[i - 1] * ifac[i] % mod;
    }
}

inline void Read() {
    n = qread();
    for (int i = 1;i <= n;i++) a[i] = qread();
}

inline long long C(int n, int r) {
    if (n < r || r < 0) return 0;
    return fac[n] * ifac[r] % mod * ifac[n - r] % mod;
}

inline long long Walk(int n, int m) {
    if (n < m || m < 0) return 0;
    return (C(n + m, m) - C(n + m, m - 1) + mod) % mod;
}

inline void Solve() {
    memset(vis, 0, sizeof(vis));
    long long ans = 0, minx = 1, mxv = 0;
    for (int i = 1;i <= n;i++) {
        if (a[i] > mxv) {
            ans = (ans + Walk(n - i + 1, n - a[i] - 1)) % mod;
            mxv = a[i];
            vis[mxv] = 1;
            while (vis[minx]) minx++;
        } else if (a[i] == minx) {
            ans = (ans + Walk(n - i + 1, n - mxv - 1)) % mod;
            vis[minx] = 1;
            while (vis[minx]) minx++;
        } else {
            ans = (ans + Walk(n - i + 1, n - mxv - 1)) % mod;
            break;
        }
    }
    cout << ans << endl;
}
```

总之感觉这题最难的地方还是在于猜出那个两个上升子序列的结论。这里我通过从简单的情况，尝试用类似的形式进行推广的方式解决了这个问题。

其实这个方法挺通用的。我相信数学应该是简单的，是优美的，而不应该是繁杂的分类讨论。所有的答案最终都应能够整合到一个统一、简洁、漂亮的形式。因而也可以从一个统一的形式来寻求一个猜测答案的方向。可能正是这种由简单推至复杂而最终又回归于简单的结论，才是 OI 最美妙的一面吧。











