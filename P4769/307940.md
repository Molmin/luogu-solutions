前言：本人水平较差，在做这道题的时候查阅题解时很困难，每篇都只能看懂一点，因为有些东西题解默认会或者对最终形态影响不大就略过了，所以本篇尽可能详细的写，如果各位看到本身会的可以跳过。

-------------------------

### 题目大意

给定一个长度为 $n$ 的排列 $q$，求排列的个数，满足：

- 字典序大于给定排列。

- 对序列进行冒泡排序时没有多余操作（即操作个数达到下界）。

-------

### 题目分析

首先考虑第二个限制可以转化成哪种我们可以使用的形式。

没有多余操作也就是每一个数都只向目标位置方向走，不换向。

如果一个数前面有比它大的数，后面有比它小的数，那么它一定会和大的数交换而往前走一次，和小的数交换往后走一次，换向了一定代表是多余的。

所以第二个限制也就是要求一个排列，其中每个数不同时存在前面比他大的和后面比他小的，规范的说是该排列没有长度大于二的下降子序列，也就是由两个上升序列组成，这两个序列**不需要**连续。

根据第二条限制考虑构造一个序列，假设现在构造到了第 $i$ 位，数为 $a_i$，取 $mx = \max(a_1 ……a_i)$ 如果下一个放比 $mx$ 大的数，那么随便放，如果放一个比 $mx$ 小的数，那么必须放目前没放的最小的数。

这种构造方法一定符合限制。因为考虑如果放了一个数，和之前的某两个数构成长度为三的下降序列，那么中间那个数一定小于第一个数，那么在放中间那个数的时候就应该放最小的数，与第三个小于中间这个数矛盾。

接下来根据构造，用平常的思路，设 $f_{i,j}$ 为当前考虑第 $i$ 位，此时还未放置的，大于 $mx$ 的数有 $j$ 个。

初始为 $f_{0, n} = 1$，结束为 $f_{n, 0}$。

考虑状态转移，对于 $f_{i - 1, j'}$ 怎么转移到 $f_{i, j}$。

有构造可得，有两种情况：

1.放一个大于当前最大值的数，此时 $mx$ 变成 $a_i$，大于 $mx$ 的数有 $j = n - mx \in [j' - 1, 0]$ 个。即 $f_{i - 1, j'}$ 转移到 $f_{i, j} (j \in [j' - 1, 0])$。

2.放最小的数，$j$ 不变，即 $f_{i - 1, j'}$ 转移到 $f_{i, j'}$。

综合上述两种情况，即 $f_{i - 1, j'}$ 转移到 $f_{i, j'}(j \in [j', 0])$。

即 $f_{i, j} = \Sigma_{s=j}^{n}f_{i-1,s}$

考虑 $f_{i, j+1} = \Sigma_{s=j+1}^{n}f_{i-1,s}$

所以 $f_{i, j} = f_{i, j+1} + f_{i-1,j}$。

即前缀和优化，可以做到 $O(n^2)$。看着不习惯就把 $j$ 的定义反过来即可。

考虑第一个字典序限制，我们可以从第一位枚举，把最后的答案分成两部分，一是对于当前枚举的这一位，填比给定排列这一位更大的数的方案，二是填给定排列这一位上数的方案，考虑下一位的时候默认之前和给定排列一样，稍微想一下可以想出来这是可以不重不漏的包含所有方案的选法。

具体来说，对于 $f_{i,j}$，枚举 $i$，通过给定的排列限制 $j$ 的范围，根据之前求出的 $f$ 得到现在的 $f$ 累加到 $ans$ 里即可。

以上是 80pts 做法。

-------

### 优化

看状态转移方程 $f_{i, j} = f_{i, j+1} + f_{i-1,j}$，等效于走格子的时候，只能由 $(i, j + 1)$ 或 $(i - 1, j)$ 走到 $(i,j)$ 即向下向右走的方案数。再观察 $i, j$ 特性，对于一个状态 $i, j$，设 $i$ 位上的数为 $a_i$，此时 $j$ 为 $n-mx$，当 $mx = ai = i$ 时取得。

形象的理解是，对于某个随机的排列，在第 $i$ 位时 $j$ 能取得理论最大值只有排列为 $1,2,3,……n$，此时 $j = n-1, n-2, ……0$，对于其他形式的排列，第 $i$ 位 $j$ 的值只能对应的小于这些值，结合到走格子的思想上，只考虑第二限制，答案就是从点 $(0, n)$ 到 $(n, 0)$ 且不穿过直线 $y = -x + n$ 的最短路径方案数, 也就是 $Catalan$ 数。但是想到格子就行，由于第一个限制，这道题不完全是 $Catalan$ 数，不过用到了 $Catalan$ 数的计算思路。

在这里联想的时候注意，**一次转移不代表在格子上走了一步，而是由当前列转移到下一列。**

如何把格子这种形式优化上去呢？

看上文的最后做法，“对于 $f_{i,j}$,枚举 $i$，通过给定的排列限制 $j$ 的范围，根据之前求出的 $f$ 得到现在的 $f$ 累加到 $ans$ 里即可。”

和“对于其他形式的排列，第 $i$ 位 $j$ 的值只能对应的小于这些值。”

即求点 $(i,j-1∼0)$ 到 $(n,0)$ 的路径数量之和，其实就相当于 $(i-1,j-1)$ 到 $(n,0)$ 的路径数量。(上一列可以往下走到 $i-1, j-1∼0$)，同时为不穿过直线 $y=-x+n$ 的最短路径数量。

对于 $(i,j)$ 到 $(n, 0)$ 的路径数量为 $C(n - i + j, j)$。

把 $(i, j)$ 关于直线 $y=-x+n-1$ 对称，易得其坐标为 $(n-j+1,n-i+1)$，可以发现，$(i, j)$ **穿过**直线 $y=-x+n$ 的最短路径数量。就等于 $(n-j+1,n-i+1)$ 到 $(n, 0)$ 的最短路径数量。

于是 $(i, j)$ 的贡献为 $C(n-i+j,j)-C(n-i+j,n-i+1)$。

总算法流程是:

1.枚举 $i$。

2.由给出的排列得出 $j$ 的范围。

3.把 $i, j$ 看做点的坐标，把 $i-1, j-1$ 带入式子统计答案。

-------

### 代码

```
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#define Mod 998244353ll

using namespace std;

inline int read(){
	register int x = 0, f = 1; register char ch = getchar();
	for(; ch < '0' || ch > '9'; ch = getchar()) if(ch == '-') f = -1;
	for(; ch >= '0' && ch <= '9'; ch = getchar()) x = (x << 1) + (x << 3) + (ch ^ '0');
	return x * f;
}

const int N = 2000001;

int T, n, ans;
int mul[N], inv[N];
int arr[N];
int vis[N]; 

void init(){
	mul[1] = inv[1] = inv[0] = 1;
	for(int i = 2; i <= 2000000; ++ i) {
		inv[i] = 1ll * (((-(Mod / i) * inv[Mod % i]) % Mod) + Mod) % Mod;
		mul[i] = 1ll * mul[i - 1] * i % Mod;
	}
	for(int i = 2; i <= 2000000; ++ i) inv[i] = 1ll * inv[i] * inv[i - 1] % Mod; // 预处理阶乘逆元O1求组合数 
}

int C(int n, int m){ // n! * (1/m!) * (1/(n-m)!
	return ((n < m) ? 0 : (1ll * mul[n] % Mod * inv[m] % Mod * inv[n-m] % Mod));
}

void clear(){
	memset(vis, 0, sizeof vis);
	ans = 0;
}

signed main(){
	init();
	T = read();
	while(T --){
		n = read();
		if(n == 0) {printf("0\n"); continue;}
		clear();
		for(int i = 1; i <= n; ++ i) arr[i] = read();
		int j = n, mi = 1, s = -1; // 可以在下一位随便填的数的个数，最小值 
		for(int i = 1; i <= n; ++ i){
			int g = n - arr[i];
			if(g < j) j = g, s = g, vis[arr[i]] = 1;
			else if(arr[i] == mi) s = j, vis[arr[i]] = 1;
			else s = j, j = -1;
			if(s != -1) ans = 1ll * (((ans + C(n - (i - 1) + (s - 1), (s - 1)) - C(n - (i - 1) + (s - 1), n - (i - 1) + 1)) % Mod) + Mod) % Mod;
			while(vis[mi]) mi ++;
		}
		printf("%d\n", ans);
	}
} 
```