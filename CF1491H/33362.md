将 $a$ 序列分块，假设块长为 $B$，对于每一个节点，预处理出它的祖先中编号最大的和它不再同一个块的祖先，为了方便，在下文中我们称其为当前点的前驱，我们先考虑如何求两个点的 LCA。

分两种情况考虑：
1. $u,v$ 不属于同一个块：将属于编号较大的一个块的节点跳至它的前驱。
1. $u,v$ 属于同一个块：接下来还是要分两种情况：
   1. $u$ 的前驱和 $v$ 的前驱不同：将 $u,v$ 同时跳至各自的前驱。
   1. $u$ 的前驱和 $v$ 的前驱相同：此时可以轮流跳 $u,v$ 中编号较大的点的父亲直至两个点相等。

接下来分析查询的时间复杂度：因为前驱最多不超过 $\frac{n}{B}$ 个，而暴力跳父亲不超过 $B$ 次，所以时间复杂度是 $O(B+\frac{n}{B})$。

然后我们再来考虑修改：按照序列分块的惯例，我们分整块和散块来考虑，对于散块，直接暴力修改然后暴力重构前驱即可。

但是对于整块，我们需要打懒惰标记，但是这种时候无法维护前驱的修改，因为修改一个块的前驱是需要遍历整块的。

但是我们发现，一个块最多在经过 $B$ 次修改之后，块中每一个数的父亲都会在这个块之前，也就是说，我们对于一个块需要暴力重构前驱的次数最多是 $B$ 次，之后的可以直接通过懒标记直接减来解决。

那么分析修改的复杂度，对于散块修改是 $O(B)$ 的，对于整块修改（不考虑重构前驱）是 $O(\frac{n}{B})$ 的，对于重构前驱的总时间复杂度是 $O(nB)$ 的。

综上，若取 $B=\sqrt{n}$，则可以获得 $O(n\sqrt{n}+q\sqrt{n})$ 的时间复杂度，可以通过本题。

代码可以去我的博客查看：[Codeforces 1491H. Yuezheng Ling and Dynamic Tree 题解](https://www.cnblogs.com/withhope/p/14462136.html)