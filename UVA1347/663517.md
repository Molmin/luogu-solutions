#### 先言

紫书上的例题，借用刘汝佳大神的思路进行讲解。

## 分析

从左到右再回来不太方便思考，可以改成：两个人同时从最左点出发，沿着两条不同的路径走，最后都走到最右点，且除了起点和终点外其余每个点恰好被一个人经过。这样，就可以用 $d_{i,j}$ 表示第一个人走到 $i$，第二个人走到 $j$，还需要走多长距离。

状态如何转移呢？仔细思考会发现：好像很难保证两个人不会走到相同的点。例如，计算状态 $d_{i,j}$ 时，能不能让 $i$ 走到 $i+1$ 呢？不知道，因为从状态里看不出来 $i+1$ 有没有被 $j$ 走过。换句话说，状态定义得不好，导致转移困难。

下面修改一下：$d_{i,j}$ 表示 $1\sim\max(i,j)$ 全部走过，且两个人的当前位置分别是 $i$ 和 $j$，还需要走多长的距离。不难发现 $d_{i,j}=d_{j,i}$，因此从现在开始规定在状态中 $i>j$。这样，不管是哪个人，下一步只能走到 $i+1,i+2,\dots$ 这些点。可是，如果走到了 $i+2$，情况变成了 $1\sim i$ 和 $i+2$，但是 $i+1$ 没走过，无法表示成状态！那么就禁止这样的决策。也就是说，只允许其中一个人走到 $i+1$，而不能走到 $i+2$ 或更远。换句话说，状态 $d_{i,j}$ 只能转移到 $d_{i+1,j}$ 和 $d_{i+1,i}$（第二个人走到 $i+1$ 时本应转移到 $d_{i,i+1}$，但是根据此处规定，必须写成 $d_{i+1,i}$）。

故状态转移方程如下：

$$d_{i,j}=\min(d_{i+1,j}+dist_{i+1,i},d_{i+1,i}+dist_{i+1,j})$$

此强制做法并不会丢失解。因为如果第一个人直接走到了 $i+2$，那么他再也无法走到 $i+1$ 了，只能靠第二个人走到 $i+1$。既然如此，现在就让第二个人走到 $i+1$，并不会丢失解。

边界是 $d_{n-1,j}=dist_{n-1,n}+dist_{j,n}$，其中 $dist_{a,b}$ 表示点 $a$ 和 $b$ 之间的距离。因为根据定义，所有点都走过了，两个人只需直接走到终点。所求结果是 $dist_{1,2}+d_{2,1}$，因为第一步一定是某个人走到了第二个点，根据定义，这就是 $d_{2,1}$。

状态总数有 $O(n^2)$ 个，每个状态的决策只有两个，因为总时间复杂度为 $O(n^2)$。

#### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n, x[1003], y[1003];
double d[1003][1003], dist[1003][1003];
signed main() {
	while(cin >> n) {
		for (register int i = 1; i <= n; i++)
			cin >> x[i] >> y[i];
		for (register int i = 1; i <= n; i++)
			for (register int j = 1; j <= n; j++)
				dist[i][j] = sqrt((x[i] - x[j]) * (x[i] - x[j]) + (y[i] - y[j]) * (y[i] - y[j]));// 计算dist数组	 
		for (register int i = 1; i < n - 1; i++)
			d[n - 1][i] = dist[n - 1][n] + dist[i][n];//初始化 d 数组
		for (register int i = n - 2; i >= 1; i--)
			for (register int j = 1; j < i; j++)
				d[i][j] = min(d[i + 1][j] + dist[i + 1][i], d[i + 1][i] + dist[i + 1][j]);// 状态转移
		printf("%.2lf\n", dist[2][1] + d[2][1]);//输出
	}
	return 0;
}
```
