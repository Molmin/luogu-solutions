记录一下这题的神仙状态设计吧qwq。

讲一下我的心路历程：

一开始：回路？搜索？不可能吧，这是蓝题啊（

经过思考：嗯这大概貌似是个 dp 吧，好像 LIS 的做法？变成两个人的相遇问题。但是很快我发现写不出来。

后来，经过某书的悉心指导，终于体悟了这道题对于无后效的处理。

首先我们考虑为什么能变成相遇问题，去时向右单调，回程向左单调，回程正走反走显然是等价。

接下来进入最精彩的部分。

## 状态！

思考一下类比 LIS 的做法为什么不行，你会发现这个状态的缺陷在于你不知道是否选了一样的点，可能走到了当前的 $i,j$ 时你的 $i$ 和 $j$ 都从 $j-1$ 走了过来，这是不行的。

所以我们要设计一个状态，巧妙的避开这个问题：$dp(i,j)$ 代表从 $1$ 到 $\max{i,j}$ 全部恰好被选过一次，且当前两个人分别在 $i,j$ 两点，最少还需要再走多远。好神仙的状态！但还没完！我们可以继续优化，因为这两个人是对称的，所以 $dp(i,j) = dp(j,i)$ 所以我们可以直接令 $dp(i,j),i > j$ 这样就更方便了一些。

一个好的状态是很容易设计出转移方程的，对于 $i,j$ 两个人，显然只能从 $i+1$ 这个点走过来（根据是我们的状态），所以 $i+1$ 要么走到了 $i$，要么走到了 $j$，所以转移方程就是 $dp(i,j) = \min{dp(i+1,j)+dis(i,i+1),dp(i+1,i)+dis(j,i+1)}$ 

边界就是在 $i = n - 1$ 的时候，因为二者的相遇点必然是 $n$，且根据状态，除了 $n$ 所有的点我们都走过了，所以边界就是 $dp(n-1,j) = dis(n-1,n) + dis(j,n)$ 让他们两个各走一步，在 $n$ 相遇。

答案呢就是 $dp(2,1) + dis(1,2)$ 没毛病啦。

[代码在这里！](https://www.luogu.com.cn/paste/1mnwycop)