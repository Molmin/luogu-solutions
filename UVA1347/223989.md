## 一、前言

这是紫书上的例题，思路大体与其相同，但我认为本题的**状态设计**十分精彩也很值得学习，因此本篇题解以**设计状态**为重，尽量讲清楚，也让自己更好地掌握这种 DP 技巧。

## 二、题意

在一个直角坐标系中，有 $n$ 个点。要求先从左往右走，再从右往左走，**不重复**的经过**每一个**点。求出**最短路径**（距离为**两点间直线距离**）。

## 三、思路

### 1.审题

- 题目要求有些奇怪：从左走到右，再从右走到左。我们可以将其转换一下：**两个人同时从最左边走到最右边，同时除了起点和终点，每个点都被其中一个人走过一次**。类似于这样的思路转换我们在[P1006 [NOIP2008 提高组] 传纸条](https://www.luogu.com.cn/problem/P1006)也已经见过了。

### 2.状态（重点）

- **$f(i,j)$表示第一个人走到 $i$，第二个人走到 $j$，还需要走多少距离**。相信这是大家脑海里浮现的第一个状态。但很可惜，这样的状态是**错误**的。因为当我们要转移时，会发现很难保证**两个人不会走到同一个点**。比如说：$f(i,j)$ 这个状态，我们很难说 $i$ 能不能到 $i+1$，因为 $i+1$ 可能已经被第二个人走过了。显然，这样的状态时有**后效性**的，转移难以进行。

**_PS_** : 无后效性是指当前的**决策**只与过去的**结果**有关，而与过去的**决策**无关。而这里的决策与过去的决策有关，显然是有后效性。

- **$f(i,j)$ 表示 $1 \sim max(i,j)$ 全部走过，且两人当前位置分别在 $i$ 和 $j$，还需要走多少距离**。很好！我们又向前了一大步。我们又发现 $f(i,j)=f(j,i)$，那么不妨令 $i>j$。如此设计，不管是那个人，下一步都只能走 $i+1,i+2,…$。就避免了重复的情况。

- 已经结束了吗？不！因为在转移时，若是一个人直接走到 $i+2$，那又变成了“$1 \sim i$ 和 $i+2$ 走过了，但 $i+1$ 却没走过”，无法形成状态。怎么办呢？我们可以**禁止**这样的状态，让无论是第一个人还是第二个人，都只能走到 $i+1$。

### 3.转移

$$f[i][j]=min(dis[i][i+1]+f[i+1][j],dis[j][i+1]+f[i+1][i]$$

- $dis[i][j]$ 表示 $i$ 到 $j$ 的距离。

- 为什么是这样的转移呢？因为前面的规定，当到 $(i,j)$ 这样的状态时，可能是第一个人从 $i$ 到 $i+1$，因此是 $dis[i][i+1]+f[i+1][j]$。也可能是第二个人从 $j$ 走到 $i+1$，本应是 $f[i][i+1]$，但因为规定了 $i>j$，所以是 $dis[j][i+1]+f[i+1][i]$，两者取 $min$ 即可。

**_PS_** : 我们的转移和状态都是**倒过来**的。

### 4.边界

$$f[n-1][j]=dis[n-1][n]+dis[j][n]$$

- 第一个人从 $n-1$ 走到 $n$，第二个人从 $j$ 走到 $n$ 的距离和。

### 5.答案

$$ans=dis[1][2]+f[2][1]$$

## 四、代码

```cpp
#include<cstdio>
#include<cmath>
#include<algorithm>
using namespace std;

const int N=1e3+7;
int n;
struct node
{
	int x,y;
}a[N];
double f[N][N];//f[i][j]表示走过了1~i,还需走多少距离 
double dis[N][N];//dis[i][j]表示i到j的距离 

void init()
{
	for(int i=1;i<=n;i++)
		scanf("%d%d",&a[i].x,&a[i].y);
	
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
			dis[i][j]=sqrt((a[i].x-a[j].x)*(a[i].x-a[j].x)+(a[i].y-a[j].y)*(a[i].y-a[j].y));			 

	for(int i=1;i<n-1;i++)//边界条件 
		f[n-1][i]=dis[n-1][n]+dis[i][n];
}

int main()
{
	while(scanf("%d",&n)==1)
	{
		//读入、预处理 
		init();
				
		for(int i=n-2;i>=1;i--)
			for(int j=1;j<i;j++)
				f[i][j]=min(f[i+1][j]+dis[i+1][i],f[i+1][i]+dis[i+1][j]);
		
		printf("%.2lf\n",dis[2][1]+f[2][1]);
	}
	return 0;
}
```

## 五、后记

本题说实话在确立状态后还是简单的，重点是如何设计出**无后效性的状态**。之前我们学过**将决策写进下标**的方法，如[P1541 [NOIP2010 提高组] 乌龟棋](https://www.luogu.com.cn/problem/P1541)，这次我们有见识过了这种**强制规定状态**的方法（不过要**不重不漏**）。岂不妙哉？