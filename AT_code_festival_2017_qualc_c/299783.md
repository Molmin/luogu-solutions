#### 题意
给定一个字符串，每次可以插入一个小写字母 $x$（注意 $x$ 的意思是**只能**插入 $x$ 这个字符而不是任意小写字母），求最少多少次操作后，可以得到一个回文串。如果永远无法满足，则输出 $-1$ 。

#### 思路
对于如何判断回文串，我们采取双指针判断。

我们不妨把字符串设为 $s$ ，两个指针设为 $l $和 $r$ 。

将 $l$ 初始值定为 $0$ ， $r$ 定为字符串最后一位的位置。

每一次判断 $s[l]$ 和$s [r]$ ，如果相等就将 $l$ 加 $1$ ， $r$ 减 $1$ 。

重复至$ l$ 和 $r$ 交错为止。

那么对于 $s[l]$ 和 $s[r]$ 不相等的情况，有$3$种。

#### 第一种：$s[l]$等于$x$

此时，我们就需要在 $s[r+1]$ 的地方放一个 $x$ ，并将 $r+1$ ，然后就变回了相等的情况。

因为 $r+1$ 和我们之后会进行的 $r-1$ 相互抵消，所以只要将$l$加$1$并累加计数器就好了。

```
else if(s[l]=='x') {
	ans++;
	l++;
}
```

#### 第二种：$s[r]$等于$x$

和第二种思路相同，只不过这次要修改的变成了 $r$ 。

```
else if(s[r]=='x') {
	ans++;
	r--;
}
```

#### 第三种：$s[l]$和$s[r]$都不等于$x$

此时，无论怎么增加 $x$ ，也不可能让 $s[l]=s[r]$ 。输出 $-1$ 。

这里就不放代码片段了。

最后，上完整代码：
```
#include<iostream>
#include<cmath>
#include<cstdio>
using namespace std;
int main() {
	int l,r,ans=0;
	string s;
	cin>>s;
	l=0;
	r=s.size()-1;
	while(l<=r) {
		if(s[l]==s[r]) {//相等情况
			l++;
			r--;
		}
		else if(s[l]=='x') {
			ans++;
			l++;
		}
		else if(s[r]=='x') {
			ans++;
			r--;
		}
		else {//不相等且都不等于x
			printf("-1\n");
			return 0;
		}
	}
	printf("%d\n",ans);
	return 0;
}
```
完结撒花~