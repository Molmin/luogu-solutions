本题是一道双指针的模拟题。

### 题意

给你一个字符串 $s$，你可以在 $s$ 的任意位置插入 $x$，是 $s$ 变为回文。

### 解决

定义双指针 $l$ 和 $r$，$l$ 和 $r$ 初始化为 $s$ 的两端。

定义一个计数的 $ans$，用来计算到底需要插入多少个 $x$。

模拟规则如下：

- 如果 $l$ 所在的位置的值和 $r$ 所在的位置的值相同，则构成回文，不用插入 $x$，可忽略这个位置，跳过 $l$，向前跳过 $r$。

- 如果 $l$ 所在位置的值是 $x$，则我们要把 $r$ 所在位置的值插入一个 $x$，现在 $l$ 和 $r+1$ 对称构成回文，然后跳过 $l$。

- 如果 $r$ 所在位置的值是 $x$，则我们要把 $l$ 所在位置的值插入一个 $x$，现在 $-1l$ 和 $r$ 对称构成回文，然后向前跳过 $r$。

- 如果都不满足，则原串无论如何也无法构成回文，则输出 $-1$，跳出程序。

### 样例解释

首先 $l$ 指向 $0$，$r$ 指向 $4$，两个位置的数值不等，满足上述第 $2$ 条，所以要向末尾插入 $x$，$ans$ 自增 $1$，$l$ 自增 $1$。

现在 $l$ 指向 $1$，$r$ 指向 $4$，两个位置的数值相等，$l$ 自增 $1$，$r$ 自减 $1$。

现在 $l$ 指向 $2$，$r$ 指向 $3$，两个位置的数不同，满足上述第 $3$ 条，所以在 $l$ 前插入一个 $x$，$ans$ 自增 $1$，$r$ 自减 $1$。

现在 $l$ 指向 $2$，$r$ 指向 $2$，两个位置的数值相等，$l$ 自增 $1$，$r$ 自减 $1$。

现在 $l$ 指向 $3$，$r$ 指向 $1$，不满足循环条件，退出程序。

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
string s;
int l,r,ans;
int main()
{
	ios::sync_with_stdio(false);
	cin>>s,r=s.size()-1;
	while(l<=r)//这个双指针越看越像二分 
	{
		if(s[l]==s[r]) l++,r--;
		else if(s[l]=='x') l++,ans++;
		else if(s[r]=='x') r--,ans++;
		else
		{
			cout<<-1;
			return 0;
		}
	}
	cout<<ans;
	return 0;
}
```
