### **题意**：

输入一个字符串$S$，您可以重复执行以下操作：

在$S$的任意位置（包含开头和结尾），插入一个小写字母 $x$ ， 使其变成回文的字符串。

请输出所需的最少操作次数 ，如果不能变为回文 ，输出 $-1$ 。

**输入格式**：

输入文件仅有一行，一个仅包含小写字母的字符串$S$。

**输出格式**：

如果目标可实现 ，则输出所需的最少操作次数。如果不行，请输出$-1$。

$$\texttt{---------------------}$$

其实，根据题目意思我们可以知道只能通过添加$x$来使其变成回文。

那么我们可以用一个十分基础的判回文的方法，从左右两端找：

```cpp
	int L=0,R = st.size() - 1;
	while ( L <= R )
	{
    	...
    }
```

如果左右两边字母相同，则左、右端点往中间走：

```cpp
	if ( st[L] == st[R] ) {L++,R--;continue;}
```

如果不同，我们就要通过添加字母$x$来构造回文。

但是有一个**前提**：

就是当前所判断字母为$\color{red}x$时，才能通过添加字母$x$来使其对称。

那么我们判断一下即可

```cpp
	if ( st[L] == 'x' ) {L++,ans++;continue;}
```

右端同理

```cpp
	if ( st[R] == 'x' ) {R--,ans++;continue;}
```

如果左、右端都没有x且不相同的话，那么即使添加$x$也不能构造回文惹...所以我们就可以跳出循环，输出$-1$即可。

完整代码如下：
```cpp
#include <bits/stdc++.h>	//万能头文件
using namespace std;
string	st;
int	ans;		//记录次数
bool	flag = true;	//用来标记是否能构造回文
int main()
{
	cin >> st;
	int L=0,R = st.size() - 1;	//定义左、右端
	while ( L <= R )	//运行到字符串中间
	{
		if ( st[L] == st[R] ) {L++,R--;continue;}	//相同则不管它
		if ( st[L] == 'x' ) {L++,ans++;continue;}	//判断左端是否为x
		if ( st[R] == 'x' ) {R--,ans++;continue;}	//同理
		flag = false; break;	//上面方法都行不通，标记，退出循环
	}
	ans = flag ? ans : -1;	
	cout << ans ;	//输出
	return(0);	//记得打return 0
}
```
