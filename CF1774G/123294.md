非常好的题目！

不在区间上挖一些性质是很难做的，而区间最常见且最有用的一个性质就是 **不包含**。

考虑两个区间 $[x', y']\subset [x, y]$，则对于任意包含 $[x, y]$ 的方案，是否选择 $[x', y']$ 对答案没有影响，总贡献一正一负抵消掉了，相当于钦定不包含 $[x, y]$，即将其删去。最终区间互不包含，满足 $x_i$ 递增且 $y_i$ 递增。

注意是删去较大的区间而不是删去较小的区间，这保证了对于任意区间 $[l, r]$，对所有包含于 $[l, r]$ 的区间做上述操作等价于对所有区间做上述操作后包含于 $[l, r]$ 的区间。

现在考虑一次询问以及所有相关区间 $I_1, I_2, \cdots, I_k$。设 $f_i$ 表示选择 $I_i$ 覆盖 $[x_1, y_i]$ 的区间数为偶数的方案数减去区间数为奇数的方案数，则 $f_i = -\sum_{j = 1} ^ {i - 1} f_j [x_i\leq y_j]$。

分析：

$f_1$ 显然为 $-1$。

如果 $y_1 < x_2$，则 $f_2 = 0$，且根据端点单调的性质，接下来所有 $f$ 也等于 $0$。否则 $f_2 = 1$。

接下来，对于所有 $x_i\leq y_1$ 的 $i$，其 $f_i$ 等于 $\sum_{j = 1} ^ {i - 1} f_j = 0$，可以跳到第一个使得 $y_1 < x_i$ 的 $i$。如果 $y_2 < x_i$，说明 $f_i = 0$，且接下来所有 $f$ 也等于 $0$，否则 $f_i = -f_2 = -1$。进入了形式相同但规模更小的子问题。

我们尝试描述上述过程的核心思想，即维护 $(u, v) = (1, 2)$，每次交替令 $u\gets p_u$ 和 $v \gets p_v$，其中 $p_i$ 表示使得 $y_i < x_j$ 的最小的 $j$。任何时刻，若 $v\gets p_v$ 后出现 $y_u < x_v$，或 $u\gets p_u$ 后 $y_v < x_u$ 则无解。不妨设使得第一次出现无解的情况是 $y_v < x_u$，则接下来令 $v\gets p_v$ 将使得 $v = u$，如下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/4tpfzymu.png)

不断执行操作，直到 $x_{p_u} > r$ 且 $x_{p_v} > r$。若 $u = v$，说明出现了断开的情况，无解。否则，若 $x_u < r$ 且 $x_v < r$，说明 $f_k = 0$。否则若 $x_u = r$ 则 $f_k = -1$，因为 $u$ 维护了过程中所有 $f_u = -1$ 的位置。同理，若 $x_v = r$ 则 $f_k = 1$。

加入多组询问，$i\to p_i$ 连边后树上倍增即可。

注意：

- 若不存在 $i$ 使得 $x_i = l$，无解。
- 若不存在 $i$ 使得 $y_i = r$，无解。
- 注意特判初始情况，$y_u = r$ 时答案为 $-1$，$y_u > r$ 时答案为 $0$。

时间复杂度 $\mathcal{O}((n + q)\log n)$。[代码](https://codeforces.com/contest/1774/submission/185763315)。