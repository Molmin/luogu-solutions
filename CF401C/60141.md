很荣幸第一次提交题解，还是第一份题解。

首先我们可以先判断一下在什么时候这个序列不存在，那么根据题意，最多有连续的2个1，一个0，这个序列一定由110和10或01组成，那么我们可以得出，当n>m+1或者m>2*n+2 时，无解，可以直接输出-1，即：
```cpp
    if(n>m+1||m>2*n+2)	cout << "-1";
```
然后，我们在有解的前提下再分类讨论，分为1比0多和0比1多两种情况。

当1比0多时并且1的个数小于2倍的0的个数时，我们可以用k个110来弥补多的1，k=m-n，剩下的用10补全。如果1的个数比2倍的0的个数还大，由于上面的条件限制，我们只需要输出0的个数个110和一个1或11即可。

当0比1多时，因为0只会比1多1，所以我们只需要输出0的个数个01和一个0即可。

所以，我想这道题还算简单，而且可能有更好的办法做吧，但是，能捉到耗子的猫就是好猫。

完整代码双手奉上：
```cpp
#include<iostream> 
using namespace std;

int main() {
    int n, m;
    cin >> n >> m; //n为0的个数,m为1的个数
    if(n>m+1||m>2*n+2)	cout << "-1";
    else {
    	//分类讨论!! 
        int k;
        if(m>=n&&m<=2*n) {
            k=m-n;
            for(int i=1;i<=k;i++) cout<<"110";
            for(int i=1;i<=(n-k);i++) cout<<"10";
            }
        else if(m>=n&&m>2*n) {
            for(int i=1;i<=n;i++) cout<<"110";
			if(m%2==1) 
				cout<<"1";
			else if(m%2==0)
				cout<<"11";
            }
        else if(m<n) {
            for(int i=1;i<=m;i++) cout<<"01"; //这里跟上面不一样的哈！
			cout<<"0";
        }
    }
    return 0;
}
```

--【END】--