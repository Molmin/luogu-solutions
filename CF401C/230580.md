# **日拱一卒，功不唐捐**


------------



### 本人今天刚学数论，因此来水一片题解（逃


------------

## [-->题目传送门<--](https://www.luogu.com.cn/problem/CF401C)
## [-->博客食用更佳<--](https://www.luogu.com.cn/blog/Silymtics/cf401c-team-ti-xie)

------------
相信大家对这道题都有或多或少的想法，那么在这里由本蒟蒻来分享一下自己的思路

------------

# Solution：

题意还是十分简单的，构造一个01序列，并且要求满足不能有两个连续的0或者三个连续的1.

那么先让我们看一下不满足的情况，最后再进行构造

这里我提供两种不满足情况：
## 情况一
```cpp
钦定我们已知有n个0，那么最多可以在序列里填1的方式是：
110110110……11011
我们可以发现，在这种填法下，这个序列已经饱和，且m有一个最大值，即2（n+1）
所以我们可以得出，只要
m > 2 * (n + 1)
那么便不能构造
```

## 情况二
```cpp
钦定我们已知有m个1，按照同样的思路，我们最多可以这样填0：
01010101……01010
此时序列已经达到饱和（指不能再填0了），且0的个数有最大值m+1，所以如果
n > m + 1
那么便不能构造
```

### 下面是判断不能构造的情况的代码
```cpp
	if(m > 2 * n + 2 || n > m + 1) {
		printf("-1");
		return 0;//防止以后出意外，本人喜欢在这里直接结束程序
	}
```

## 下面让我们开始构造序列

我们按“10”和“110”这两个串来输出

### 输出110的条件：

这里有个条件m-1>n，意思是如果m比n多1个以上，只能构造一个110串来减小m和n的差距，同时这个可以保证，当m-1<=n时不去浪费1来构造整个串（大家可以自行考虑一下这个的正确性）
```cpp
if((m-2) <= 2 * n && (m-2) >= 0 && n-1 >= 0 && m - 1 > n) printf("110"),m-=2,n--;
```
### 输出10的条件：
```cpp
if((n-1) <= m && (m-1) >= 0 && n-1 >= 0)	printf("10"),n--,m--;
```
### 考虑到最后可能以1结尾：
```cpp
if(m-1 >= 0) printf("1"),m--;
```
### 如果以0结尾（其实因为我们构造的串是“10”和“110”，所以0结尾的情况已经被包含了）：
```cpp
if(n-1 >= 0) printf("0"),n--;
```
### 然后我信心满满的提交，结果WA声一片，看一眼代码，原来自己忘记考虑以0开头的情况了

通过大量实例我们不难发现，必须以0开头的情况只有n==m+1时

```cpp
if(n - 1 == m) printf("0"),n--;
```

下面是AC代码（自我感觉是所有题解中最简洁的）：
```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int n,m;
int main()
{
	scanf("%d%d",&n,&m);
	if(m > 2 * n + 2 || n > m + 1) {
		printf("-1");
		return 0;
	}
	while(n>0||m>0){
		if(n - 1 == m) printf("0"),n--;
		if((m-2) <= 2 * n && (m-2) >= 0 && n-1 >= 0 && m - 1 > n) printf("110"),m-=2,n--;
		else if((n-1) <= m && (m-1) >= 0 && n-1 >= 0)	printf("10"),n--,m--;
		else if(m-1 >= 0) printf("1"),m--;
		else if(n-1 >= 0) printf("0"),n--;
	}
	return 0;
}
```

### 最后，如果您在阅读过程中有什么不理解的地方或者发现本蒟蒻的思路有误，可以直接私信或评论告诉我

