# 题目

[传送门](https://www.luogu.com.cn/problem/CF1257F)

# 题解

考虑先将每一位上单独异或一个 $1$ 所有数会使 $a[i]$ 发生什么变化，可以这样预处理出来：

```cpp
inline void Getcnt(){
    rep(i,0,MAXK){
        rep(j,1,n)if((a[j]^(1<<i))<a[j])cnt[i][j]=-1;
        else cnt[i][j]=1;
    }
}
```

并且，我们可以得到 $a[i]$ 的 $1$ 的个数，这样：

```cpp
inline void Getbitcnt(){
    rep(i,1,n){
        rep(j,0,MAXK)if((a[i]>>j)&1)
            ++bitcnt[i];
    }
}
```

而我们的目标就是，尝试将一些 $cnt[i]$ 影响在 $a$ 数组上，最后使得每一个 $a[j]$ 都一样

如果我们直接暴力，时间复杂度无疑是 $\mathcal O(2^{30}n)$ 会超时，想到一个优化——折半搜索

尝试以 $[0,14]$ 和 $[15,29]$ 分开组合 $cnt[i]$，最后我们枚举答案中所有数的 $1$ 的个数为 $k$，再枚举第一个暴力部分的组合，在第二个部分中用 `map` 或者其他数据结构找到是否存在这样的组合即可

可以有一个小优化，省掉 $30$ 的常数：

由于我们最后的数的 $1$ 个数相同，那么我们可以维护差分数组，那么最后的差分数组一定全为 $0$，然后用相同方法去找即可

时间复杂度 $\mathcal O(2^{15}\times 2+2^{15}\times 15)$

# 代码

```cpp
https://www.cnblogs.com/Arextre/p/13343252.html
```

