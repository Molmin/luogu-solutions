最近在刷单调队列的题目的时候做到了这道题目，看了一些大佬的题解才明白这道题的 DP 思路的，写篇题解纪念一下（并且给像我一样的萌新解释一下楼上大佬的一些结论如何推得）。

[原题链接](https://www.luogu.com.cn/problem/P2954)

### 题目大意

每头奶牛有一个初始位置 $Pi$，将奶牛们重新排列，使得每两头奶牛距离与 $d=(s-1)/(n-1)$ 之差不大于 $1$。

### 解题思路

首先，$d$ 是一个确定的值。那么每两头奶牛的距离只能是 $n-1$，$n$，$n+1$ 中的一个。

既然要让尽可能多的奶牛间距为 $n$，那么可以用一个 $n-1$ 和一个 $n+1$ 换成两个 $n$。根据 $d$ 的定义可以知道 $d-1$ 的数量一定小于 $n+1$ 的数量。

因此，所有奶牛之间距离只能是 $n$ 或者是 $n+1$。

因为要让所有奶牛之间距离尽可能大，所以 $1$ 号牛棚与 $n$ 号牛棚一定都有奶牛。换句话说，这若干个 $d$ 和若干个 $d+1$ 的和总为给定的值 $s-1$。

那么 $n-1$ 的数量就是 $s-1-d*(n-1)$，其余的就是 $n$ 的数量（不解释）。

现在，我们已经知道了所有奶牛之间的间距的所有情况。可以想到 DP 的思路。

令 $f_{i,j}$ 表示前 $i$ 个间距中有 $j$ 个是 $n+1$，$i-j$ 个是 $n$，$f_{i,j}=\min(f_{i-1,j},f_{i-1,j-1})  +$ 当前点到现在的位置的距离。

转移方程的意思很好理解，即要么当前的间距是 $n$（相当于 $j$ 的数量不变），要么当前间距是 $n+1$（相当于 $j$ 的数量加了 $1$）。

初始定义：第一头奶牛一定在第一位，移动其他奶牛需要更多代价，$f_{1,0}=a_{1}-1$。

另外，不要忘记初始排序。

### 代码

```cpp
#include<stdio.h>
#include<algorithm>
#include<string.h>
#include<iostream>
using namespace std;
const int N=2e3+5;
int a[N],f[N][N],n,s,d;
int main()
{
    memset(f,63,sizeof f); //初始化 
    scanf("%d %d",&n,&s);
    for(int i=1;i<=n;i++)  scanf("%d",&a[i]);
    sort(a+1,a+n+1);
    d=(s-1)/(n-1),f[1][0]=a[1]-1;
    for(int i=2;i<=n;i++)
        for(int j=0;j<=min(i-1,s-1-d*(n-1));j++)
        //注意一下j的取值不可能大于目前间距总数的数量 
            f[i][j]=min(f[i-1][j],f[i-1][j-1])+abs(a[i]-1-((i-1)*d+j));
    printf("%d",f[n][s-1-d*(n-1)]);
return 0;          
}
```
