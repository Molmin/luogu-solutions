# [Common Subsequence](https://www.luogu.com.cn/problem/AT_abc130_e)
这是一道水的很的 DP 题。
# 题意简明
题面已经说得很清楚了，这里就简单说一下子序列吧。

$A$ 的子序列是指通过从 $A$ 删除零个或多个元素而不改变顺序而获得的序列。简单点说，就是在 $A$ 中选一些元素，可以跳着选，但不能倒着选。

此题中，对于序列 $S,T$ 而言。只有 $S,T$ 的某两个子序列中的每个元素的**值**和**位置**对应相同，才称它们拥有一对相同的子序列。求 $S,T$ 中相同子序列的个数。
# 思路分析
直接开始推状态转移方程，设 $dp_{i,j}$ 为 $S_{1,i}$ 与 $T_{1,j}$ 中相同子序列的对数。显然 $dp_{i-1,j}$ 和 $dp_{i,j-1}$ 中包含的相同子序列 $dp_{i,j}$ 都包含。但是 $dp_{i-1,j}$ 和 $dp_{i,j-1}$ 都包含 $dp_{i-1,j-1}$ 中的相同子序列。所以，根据容斥原理可得：
$$dp_{i,j}=dp_{i-1,j}+dp_{i,j-1}-dp_{i-1,j-1}$$
但是，这样就结束了吗？

我们发现，当 $S_i = T_j$ 时，$S_{1,i-1}$ 与 $T_{1,j-1}$ 中包含的相同子序列同时加上 $S_i,T_j$ 会构成 $dp_{i-1,j-1}$ 个新的相同子序列。所以，当 $S_i = T_j$ 时：
$$dp_{i,j}=dp_{i-1,j}+dp_{i,j-1}$$
到此，方程算是推完了，最后答案为 $dp_{n,m}$。
# 注意事项
- 空集与任何序列的相同子序列数都是 $1$，所以初始化 $dp_{i,0}=1,dp_{0,j}=1,dp_{0,0}=1$。
- 最终答案要先取模再加 $1000000007$ 再取模，否则有可能出现负数答案。
# 代码实现
```cpp
#include <bits/stdc++.h>
using namespace std;
#define mod 1000000007
int n,m,a[2005],b[2005],dp[2005][2005];
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&a[i]);
		dp[i][0]=1;//初始值 
	}
	for(int i=1;i<=m;i++)
	{
		scanf("%d",&b[i]);
		dp[0][i]=1;
	}
	dp[0][0]=1;
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			dp[i][j]=(dp[i-1][j]+dp[i][j-1]-dp[i-1][j-1])%mod;//方程 
			if(a[i]==b[j])
				dp[i][j]=(dp[i][j]+dp[i-1][j-1])%mod;//特判 
		}
	}
	printf("%d",(dp[n][m]%mod+mod)%mod);//注意取模 
	return 0;
}
```
希望本篇题解可以帮到大家！！！