由于是拓扑图结构，从起点最多经过N-1条边必定会到达终点，因此最大长度也就是(N-1)\*MAXL，这里MAXL是边的最大长度，本题中为100。楼下的解题思路也都是基于这个的。我这里提出另一种用最短路求解的方法。


用D[u][v][w]表示第一个人走到了节点u，第二个人走到了节点v，第一个人走的长度减去第二个人走的长度的差为w(-MAXL<=w<=MAXL)的情况下，第一个人走的最短路长度。那么根据w的正负值，来判断下一个谁走。如果w为负数，也就是当前第一个人落后，所以这时候就是第一个人走一条边; 同理，如果w为非负，那就第二个人走。


Dijkstra求解的伪代码

```cpp
while (!vis[n][n][0] && !heap.empty()) {
    (u, v, w) = heap.top();
    vis[u][v][w] = true;
    if (w < 0) {
        for (int i = 1; i <= n; i ++) {
            if (e[u][i] > 0) update( (i, v, w+e[u][i]), dis[u][v][w]+e[u][i]) );
        }
    } else {
        for (int i = 1; i <= n; i ++) {
            if (e[v][i] > 0) update( (u, i, w-e[v][i]), dis[u][v][w]);
        }
    }
}
```

在这个方法中，节点总数为O(N\*N\*MAXL)，每个节点都连出去最多N条边，用Dijkstra求解的话，就是O(N^3\*MAXL\*log(N))。虽然复杂度看上去比楼下的方法高，但是这个方法不需要拓扑图结构，是个更一般的解法。例如下面这个例子（一般的有向图）：

```cpp
3 3
1 2 100 99
2 3 100 99
3 1 1 1
```
这个图的答案为39998，如果点数增多，答案会变得更大。
