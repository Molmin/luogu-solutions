这是道紫色的构（da）造（du）题（liu）

不过我都能get到的想必也不是啥难题

[题目链接](https://www.luogu.org/problemnew/show/CF468C)

看完题目先去看$a$的取值范围

嗯?$10^{18}$?什么数字位数和会大于等于$10^{18}$?

再看看$l,r$的取值范围顿时明白

**$r$的取值一定大于$10^{18}$**

先不管$l$,先利用**前缀和思想**

设$g(x)=f(1)+f(2)+f(3)+...+f(x)$

则$g(r)=f(1)+f(2)+f(3)+...+f(10^{18})+...$

暂时不知道右边要加到哪里，先放着

则$g(10^{18})=f(1)+f(2)+f(3)+...+f(10^{18})$

设$g(10^{18})\equiv b(mod \; a)$

**注意$a$和$b$是唯一确定的可以求的**

则$g(r)\equiv b+...(mod\; a)$

这有个$b$!

很显然我们**要消去$b$**

再引申出一个很显然的推论

$f(x+10^{18})=f(x)+1(x<=10^{18})$

所以

$g(r)=f(1)+f(2)+...+f(10^{18})+f(10^{18}+1)+...+f(10^{18}+a-b)$

$g(r)=b+1*(a-b)+f(1)+f(2)+f(3)+f(a-b)$

$g(r)=a+g(a-b)$

如此**消去了$b$**

这又有个$g(a-b)$,只有把它消去我们才能使$g(r)$在模$a$意义下为$0$

回到题目要求的是一个区间，**用$g(l-1)=g(a-b)$**，就能使这段区间之和模$a$意义下为$0$

总结一下

$g(l-1)=g(a-b)$

$g(r)=g(10^{18}+a-b)$

则

$l=a-b+1$

$r=10^{18}+a-b$

如此构造出了答案

什么你问我$b$怎么求？

~~随缘填坑（因为我现在在上课）~~

我来填坑了！

从小往大先用$for$循环枚举大法推一波规律

$1-9$的和为$45=45*1$

$1-99$的和为$900=45*20$

$1-999$的和为$13500=45*300$

$1-9999$的和为$180000=45*4000$

豁然开朗！

$g(10^t-1)=45*t*10^{t-1}$

$g(10^t)=45*t*10^{t-1}+1$

如此可以简便算出$g(10^{18})=45*18*10^{17}+1=81*10^{18}+1$

至于证明。。。

我感性思考一下:

首位每个数字会出现$t$次

其他位置都有$10$种可能一共$10^{t-1}$个可能

且$0-9$数字的和为$45$

附：我的blog书写次序是按我的理解思路来的，如果有逻辑混乱的地方，恳请指正

```cpp
#include<bits/stdc++.h>
#define LL long long
using namespace std;

LL a,inf=1e18;

int main()
{
    cin>>a;
    LL b;
    b=(inf%a*9%a*9%a+1%a)%a;//拆成9*9是害怕爆炸
    LL l=a-b+1,r=1e18+a-b;
    //cout<<b<<endl;
    cout<<l<<" "<<r;
    return 0;
} 
```
