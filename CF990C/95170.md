这题数据大，明显不能暴力枚举。那要怎么做呢？可以根据每个串不配对的括号个数来配对。

那怎么找不配对的个数呢？简单的比较数量是不行的，因为可能有这种序列：
```
)(
```
虽然左右括号数量相等，但并不合法。

所以我们可以考虑用栈来判断。如何判断我就不多说了，详情参考[UVA673 平衡的括号 Parentheses Balance](https://www.luogu.com.cn/problem/UVA673)。

如果一个串左右括号都不比配，就不能用。如：

```
)()(
```
如果一个串只有左括号不匹配，那对答案的贡献就是：不匹配右括号的数量和这个串不匹配左括号的数量相等的串的数量（~~好拗口~~）。如：
```
((
```
如果一个串只有右括号不匹配，那对答案的贡献就是：不匹配左括号的数量和这个串不匹配右括号的数量相等的串的数量。如：
```
))
```
如果一个串所有括号都是匹配的，那对答案的贡献就是：所有括号全匹配的串的数量。如：
```
()
```
思路大概就是这样啦~接下来附上代码：
```
#include<bits/stdc++.h>
using namespace std;
stack<char> st;//一个栈
struct data
{
	int l,r;//l是不匹配左括号数量，r是不匹配右括号数量
	string c;
}s[300005];
long long ans=0;
int n,tl[300005],tr[300005];//tl,tr是存数量的桶，tl是左括号，tr是右括号
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>s[i].c;
		for(int j=0;j<s[i].c.size();j++)
		{
			if(s[i].c[j]=='(')//左括号进栈
				st.push('(');
			else
			{
				if(!st.empty())//出现右括号且有可以配对的左括号
					st.pop();
				else
					s[i].r++;//这个右括号是不匹配的
			}
		}
		while(!st.empty())//还有剩的左括号
		{
			st.pop();//清空栈
			s[i].l++;//这个左括号是不匹配的
		}
		if(s[i].l==0)//进桶（此处合法串在tr[0]和tl[0]都有记录）
			tr[s[i].r]++;
		if(s[i].r==0)
			tl[s[i].l]++;
	}
	for(int i=1;i<=n;i++)//加上
		if(s[i].l==0)
			ans+=tl[s[i].r];//只记一种括号，不然会重复
	cout<<ans;//输出答案
	return 0;//拜了个拜~
}

```
最后，安利一下我的洛谷博客：[一只仓鼠的小窝](https://www.luogu.com.cn/blog/lucy2008/)，dalao们给我点个赞吧~