### 废话
参加了这场CF，算是打的为数不多的CF中最好的一次——做出了两个题（新鲜蒟蒻），这个是第三个，当时比赛的时候没想出来，现在过了好长时间重新去看，发现还是很简单的。  
### 正题
要求是计算括号序列两两匹配合法的方案数。  
经过分析括号序列，我们珂以发现，所有合法的括号序列珂以分为以下3种：  
1. 只能放在左边的括号序列，记为序列A。例如：((
2. 只能放在右边的括号序列，记为序列B。例如：))
3. 两边都珂以放的括号序列，记为序列C。例如：()  

那么我们就珂以知道，如果想要用两个括号序列拼出合法的序列，就必须让左边序列中没有配对的左括号的个数和右边序列中没有配对的右括号的个数相等。  
有点绕口，举个栗子：  
假如左边的序列是((())，这个序列中没有配对的左括号有一个，计算方法是左括号个数-右括号个数(3-2=1)  
那么右边的序列中没有配对的右括号必须只能有一个，类似于())。  
这样他们就可以拼出合法序列了，对答案的贡献是`没有配对的左右括号个数相等的序列A的个数*序列B的个数`。  
那两边都珂以放的序列呢？所有的这种序列两两之间都珂以配对。所以对答案的贡献是`序列C个数的平方`。  
然后我们的目标就很明确了，只要把所有的括号序列在读入的时候都处理一下，去除不合法序列，把每个序列分类，并且求出他没有配对的左括号或者右括号的个数，最后计算贡献即可。  
这里我用l[i]数组记录没有配对的左括号数量为i的序列A的个数，用r[i]数组记录没有配对的右括号数量为i的序列B的个数，把序列C的个数记录到l[0]里。  
最后答案就是$l[0]^2+\sum\limits _{i=1}^nl[i]*r[i],n=min(maxl,maxr)$,其中maxl和maxr分别为l[i]和r[i]中最后一个不为0的元素的下标，因为之后相乘的结果都是0。  
那么怎么判断括号序列属于哪一种呢？  
经过观察，我们发现，如果一个序列在某个位置，使得前面的右括号个数>左括号个数，记max为所有这种位置中前面的右括号个数-左括号个数的最大值，那么如果满足$max=右括号个数-左括号个数$这个括号序列一定是序列B，r[max]++记录下来，如果不满足，那么这个序列就是不合法序列。  
如果不存在上述位置，那么括号一定是序列A或C，直接l[右括号个数-左括号个数]++记录下来即可。  
### code
``` cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=3*1e5+1;
int n,rmax=0,lmax=0;
long long ans=0,l[maxn],r[maxn];
char s[maxn];
int main()
{
    memset(l,0,sizeof(l));
    memset(r,0,sizeof(r));
    scanf("%d",&n);
    for(register int i=1;i<=n;i++)
    {
        scanf("%s",s);
        int len=strlen(s);
        int ll=0,rr=0,tag=0,maxr=0;
        //ll为左括号个数，rr为右括号个数
        //tag用来记录是否为序列B，maxr为前面说的max
        for(register int j=0;j<len;j++)
        {
            if(s[j]=='(')ll++;
            else 
            {
                rr++;
                if(rr>ll)tag=1,maxr=max(maxr,rr-ll);
            }
        }
        if(tag)
        {
            if(ll==rr-maxr)
            {
                r[rr-ll]++;
                if(rr-ll>rmax)rmax=rr-ll;
            }
        }
        else
        {
            l[ll-rr]++;
            if(ll-rr>lmax)lmax=ll-rr;
        }
    }
    lmax=min(lmax,rmax);//这个就是去求n啦~
    for(register int i=1;i<=lmax;i++)
        ans+=l[i]*r[i];
    ans+=l[0]*l[0];
    printf("%lld",ans);
    return 0;
}
```
### 后记
敲题解真是件费时间的事啊...