### 提供一个在线的不用线段树的 `set` 做法。

我并没有把这题看作序列问题，而一直在图论方面思考这题。

为什么这题**只有横边和竖边**，而不是一般的图呢？肯定是横边和竖边有性质。于是我在挖性质。

横边很好处理，难搞的在竖边。为什么**竖边都是竖直的**，而没有斜着的呢？很特殊，记下来，后面有用。

考虑图中连通的两个点，它们之间的路径有几种情况。

- 它们在同一行内，直接从这一行走过去；
- 在它们之间，经过一些竖边，上上下下地走过去，如图（$1\rightarrow 10$）：

![](https://s2.loli.net/2022/07/30/yDPvRHgCxqXYoJt.png)

- 其中一个或两个点，先回头走一些，经过一条竖边，再往前走，如图（$3\rightarrow 8$）：

![](https://s2.loli.net/2022/07/30/WLVefPlAMZpxqjK.png)

对于第一种情况，将同一行内的一个个连通块看作一条条线段，用两个 `set`（代码中叫 `seg[2]`）分别维护第一行和第二行里每个线段的起点，通过 `lower_bound` 和 `upper_bound` 判断同一行内的两点是否在一条线段中。

对于第三种情况，有一个性质：若从起点往回走，那么**一定会在经过第一条竖边（的某个端点）时沿着竖边走下去/走上去**。因为如果走到了更远的一条竖边，那么在回来时，一定会经过更近的那条竖边的另一个端点，没必要。如图（$5\rightarrow 10$）：

![](https://s2.loli.net/2022/07/30/6lNZi8pGThgPdKB.png)

显然没必要走红路径绕一大圈，走蓝路径就够了。

此时竖边一定竖直的作用就凸显出来了。可以用另一个 `set`（代码中叫 `key`）存哪些位置上有竖边，用 `lower_bound` 和 `upper_bound` 找到离起点和终点最近的一条竖边。另外，可以把竖边所在位置的上下两个点看作同一个点（称作竖点），这样一条上上下下的路径就被拆分了很直的三部分：起点到左边或右边最近的竖点；这个竖点经过一些竖点，到另一个竖点（也必须是终点左边或右边最近的竖点）；另一个竖点到终点。

第一部分和第三部分的路径都在同一行内，可以用上面说的 `seg` 数组判断；对于第二部分，它只跟竖点有关，于是可以再开一个 `set`（代码中叫 `cant`）表示有哪些竖点与**下一个竖点，也就是它在 `key` 中的后继**不连通。查询时用 `lower_bound` 和 `upper_bound` 看 `cant` 内有没有在 起点的竖点 与 终点的竖点 之间的点即可。

对于加边和删边，不难发现每次操作只会对一个竖点产生影响，于是直接维护这四个 `set` 即可。

在线，时间复杂度 $\mathcal O(n\log n)$。

[代码](/paste/3229zo8h)又臭又长，全是分讨和 `set` 的操作，看不懂的估计加了注释也没啥用，就不加了。