###### 蒟蒻的第一篇题解……

------------

虽然标签里没有深搜，但我个人认为 _**深搜和广搜都可行**_ ，这里只是提供思路和一份用bfs的ac代码

------------


### 思路

这道题看上去像裸的搜索，但如果直接用常规的方法~~可能~~ _**连样例都过不了**_

当我们稍微思考一下，就会发现一个问题：

假如Bessie在（a，b）处打开了（c，d）的灯，但（c，d）的四周不是黑屋子就是已经被访问过了，那么按常规方法它是 _**无法被访问**_ 的。

怎么解决问题呢？这时候肯定有人想，只要Bessie能 _**往回走**_ ，或者 _**多搜索几遍**_ 就可以了。首先，往回走是 _**不可能实现的**_ ，因为完全无法用vis判重；那么，如果多搜索几遍可行，至少要搜索多少次？我没有准确计算，但n^2/4是必须的 ~~(大概)~~ ，所以 _**100%会TLE**_ 

既然上述方法都不可行，就必须选择一个更好的方案。试想一下，假如你要从家里去A地游玩，在制定计划时，通过哪一条路去到那里重要吗（假如有~~缺德地图~~）？ _**显然不是**_ ，我们只需要知道， _**有没有路**_ 可以走到A地即可。在知道有了路之后，我们就可以直接开始指定在A地游玩的计划了

现在，把目光转回题目，问题 _**并没有要求输出行走的路径**_ ，那么，刚刚的假设完全可以套用在题目上：假如Bessie点亮了某个点的灯，然后判断是否能从现在的点走到它，怎么判断呢？遍历一下它的四周（或者多开一个vis数组），如果有一个点通往（1，1）（也就是被访问过），就是有路的，那么Bessie可以直接 _**“瞬移”**_ 过去，然后遍历完再 _**“瞬移”**_ 回来。如果那个点不能到达（1，1），则表示它尚未被访问，不需要多余的处理，先点亮就好

------------


### 细节
看到这里，就可以直接开始打代码了，但是，如果看一下数据范围，就会发现1 <= n <= 100 < 2^7 也就是说，对于每个坐标，我们只需要用一个 _**七位整形**_ 存储。那么，我们可以用一个状压的思想，用一个int，值为(x<<7)+y表示其坐标。这样不仅节省了空间，同时也美化了代码。

当然还有一些更小的细节，就直接在代码上注释出来了。


------------

### 上代码！
```cpp
#include <cstdio>
#include <vector>
using namespace std;
int n, m, ans = 1;//ans为1是因为（1，1）本来就是亮的
int dx[5] = {0, 1, -1, 0, 0}, dy[5] = {0, 0, 0, 1, -1};
bool vis[105][105][3];
//这里vis[i][j][0,1,2]分别是：是否被点亮，是否访问，旁边是否有已访问的点
int que[105*105];//手写队列
vector<int> map[105][105];//懒得写邻接表直接用vector
inline int read();//我有把函数写在main后面的习惯，往下翻就看到了
void bfs();
int main()
{
	n = read(), m = read();
	int x1, y1, x2, y2;
	for(register int i = 1;i <= m;++i)
	{
		x1 = read(), y1 = read(), x2 = read(), y2 = read();
		map[x1][y1].push_back((x2<<7)|y2);
		//读取后用状压存储同时也用到了位或，等同于(x2<<7)+y2
	}
	bfs();
	printf("%d", ans);
	return 0;
}
inline int read()
{
	int x = 0;
	char c = getchar();
	while(c < '0' || c > '9')
		c = getchar();
	while(c >= '0' && c <= '9')
		x = (x<<3)+(x<<1)+c-48, c = getchar();
	return x;
}//快读这里我没有写读取负数的情况，因为不会读到负数
void bfs()
{
	int head = 1, tail = 1;
	que[1] = 129;
	vis[1][1][0] = vis[1][1][1] = vis[1][1][2] = true;//压入开头
	while(head <= tail)
	{
		int tmp = que[head++], x = tmp>>7, y = (x<<7)^tmp;
		vis[x][y][1] = true;
		int nx, ny;
		for(register int i = 0;i < map[x][y].size();++i)
		{//遍历所有开关
			int nx = map[x][y][i]>>7, ny = (nx<<7)^map[x][y][i];
			//这里用了异或，等同于ny=map[x][y][i]-(nx<<7)
			if(vis[nx][ny][0])//判重，因为多个开关可能对应一个房间
				continue;
			vis[nx][ny][0] = true, ++ans;
			if(vis[nx][ny][2])
				que[++tail] = (nx<<7)+ny;//如果有路可以走，压入队列
		}
		for(register int i = 1;i <= 4;++i)//往四周走
		{
			int xx = x+dx[i], yy = y+dy[i];
			if(xx < 1 || x > n || y < 1 || y > n)//边界
				continue;
			vis[xx][yy][2] = true;//表示这个点的四周有路可以走
			if(!vis[xx][yy][0] || vis[xx][yy][1])//判重&判断是否被点亮
				continue;
			vis[xx][yy][1] = true;
			que[++tail] = (xx<<7)+yy;//压入队列
		}
	}//这里遍历开关与遍历四周的顺序可以调换，不影响结果
	return;
}
```

------------

## 不要复制！！！