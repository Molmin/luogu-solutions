此题虽简单，可是必须要有必要的解释，而其它几篇题解都没有。这里就来写一篇个人认为好一点的。

### 分析：
先令**向右跳**的跳动格数为**题目中所述跳动格数**，**向左跳**的跳动格数为**题目中所述跳动格数的相反数**。
##### **首先来分析一下怎么样会死循环**：
当蚱蜢从 $a$ 点跳了 $b$ 次时，再次回到 $a$ 点，会出现死循环。因为它再跳 $b$ 次任然会回到 $a$ 点，再跳 $b$ 次栽回到 $a$ 点。以次类推，它会永远执行这个循环，**跳动永不停止**。

更近一步：若蚱蜢已经跳了若干次，其中有两次的出发点一样，则会出现死循环。
##### **下面来证明只会有死循环能让蚱蜢永不停止**：
当蚱蜢跳了 $n$ 次（$n$ 为题目所述），一共会产生 $n+1$ 个的出发点（第 $n+1$ 次的也产生了）。若跳出了边界，则不是“永不停止”，不用讨论。根据抽屉原理（不知道的往下看），必然会有两个出发点相同，则是死循环。

因此，**死循环与跳动永不停止是等价的**。
### 代码实现：
方法与证明刚刚已经说过了。**只用模拟 $n$ 次跳动，看有没有跳出边界**。

##### 主体代码：
```cpp
int g=1;
for(int i=1;i<=n;++i){
	g+=p[g];
	if(g<=0||g>n){
		printf("FINITE");
		return 0;//结束程序
	}
}
printf("INFINITE");
```
##### 读入部分代码：
```cpp
int read(){
	char ch=getchar();int res=0;
	while(ch<'0'||ch>'9')ch=getchar();
	while(ch>='0'&&ch<='9'){
		res=(res<<1)+(res<<3)+ch-'0';
		ch=getchar(); 
	}
	return res;
}//速度函数，返回数值为读入的数，速度很快。也可以换成scanf或cin

//p数组存储每个格子的跳动格数
n=read();scanf("\n");
for(int i=1;i<=n;++i){
	char ch=getchar();
	if(ch=='>')p[i]=1;
	else p[i]=-1;
}
for(int i=1;i<=n;++i)p[i]*=read();
```

**附：抽屉原理及其证明：（重要程度：4星）**

1. 有 $k$ 个人与 $k+1$ 块糖，每块糖分给一个人，则必然有人分到了 $2$ 块糖及以上。

证明：

若每个人都分不到 $2$ 块糖，则每人最多有 $1$ 块糖，一共最多有 $k$ 块糖。则 $k+1$ 块糖必然会让某人分到了 $2$ 块糖及以上。

2. 有 $k$ 个人与 $k \times m+1$ 块糖，每块糖分给一个人，则必然有人分到了 $m+1$ 块糖及以上。

证明留给读者去想，方法和上面一样。