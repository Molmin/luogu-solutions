# [**[ABC209F] Deforestation**](https://www.luogu.com.cn/problem/AT_abc209_f)

## **初探题面**

阅读完这道题之后，我们发现它没有叫你计算最小的花费是多少，而是计算有多少种方案能够达到最小的花费。

遇到这种类型的题目，首先要明确**在什么条件下能够达到最小的花费**。

因为任意一个 $i$ 产生的权值与 $i-1$，$i$，$i+1$ 有关，说人话就是相邻的元素选择的顺序会影响到它的权值，所以我们考虑对于 $i$，$i+1$，哪个先选比较好。

- 如果先选 $i$，权值为：$a_{i-1}+a_i+a_{i+1}+a_{i+1}+a_{i+2}$。
- 如果先选 $i+1$，权值为：$a_i+a_{i+1}+a_{i+2}+a_i+a_{i-1}$。

用第一个式子减去第二个式子得：$2a_{i+1}-2a_i$。

所以当 $a_{i+1} > a_i$ 时，先选 $i+1$ 更好；当 $a_i > a_{i+1}$ 时，先选 $i$ 更好；如果两者相等，那么我们可以任意抉择。

很明显的，对于每组 $i$，$i+1$ 我们都可以这么抉择并且至少有一种方案满足这种选择，所以这种局部最优性可以扩展到全局，因此，我们只要求出满足这种顺序的方案数就行了。

## **状态设计**

既然最优解是限制了元素插入进去的顺序的，那么我们可以使用插入 DP 的相关套路解决这个题目。

我们发现如果按照这个关系减出来的图其实是一个 TAG，不好维护插入顺序。因此我们只能考虑从 $1 \sim n$ 依次考虑插入。

因为 $i$ 可以插入的方案数仅与 $i-1$ 所插入的位置有关系，而且题目允许 $O(n^2)$ 的空间和时间，因此我们设计两维 DP 数组：$dp_{i,j}$ 表示第 $i$ 个数插入到了第 $j$ 个位置满足条件的方案。

**说明一下，这里的第 $j$ 个位置并不是最终操作序列上的位置，而是操作序列只保留 $1\sim i$ 的子序列的相对位置。**

## **转移方程**

- 对于 $a_i > a_{i-1}$ 先选 $i$，所以 $i$ 的相对位置一定在 $i-1$ 的相对位置的前面，故 $dp_{i,j} = \sum_{k=j}^i dp_{i-1,j}$。

- 对于 $a_i < a_{i-1}$ 先选 $i-1$，所以 $i$ 的相对位置一定在 $i-1$ 的相对位置的后面，故 $dp_{i,j} = \sum_{k=1}^{j-1} dp_{i-1,j}$。

- 对于 $a_i = a_{i-1}$ 都可以先选，所以全部情况都可以转移，故 $dp_{i,j} = \sum_{k=1}^{j-1} dp_{i-1,j}$。

注：
- 第一个转移方程从 $j$ 开始循环到 $i$ 是因为如果 $i-1$ 在 $1 \sim i-1$ 的第 $j$ 个位置，那么 $i$ 就可以插入到第 $j$ 个位置的前面使得 $i$ 在 $i-1$ 的前面并且相对位置也是 $j$。
- 第二个转移方程循环到 $j-1$ 的道理同上。
- 这种方法为什么能不重不漏，是因为两个不同的最终操作序列一定有一个 $i$ 在 $1\sim i$ 中的相对位置不同；两个相同的最终操作序列一定满足每一个 $i$ 在 $1\sim i$ 中的相对位置相同。
- 初始化 DP 的时候需要注意 $1$ 在 $1\sim 1$ 中的相对位置只有 $1$ 这一个。

综上，代码就可以写出来了。

```cpp
#include<bits/stdc++.h>
#define ll long long
#define mod 1000000007
using namespace std;
ll n,a[4005],dp[4005][4005],m[4005][4005],i,j;
int main(){
	ios::sync_with_stdio(false);
	cin>>n;
	for(i=1;i<=n;i++) cin>>a[i];
	dp[1][1] = 1;
	for(i=1;i<=n;i++) m[1][i]=1;
	for(i=2;i<=n;i++){
		for(j=1;j<=i;j++){
			if(a[i]==a[i-1]) dp[i][j]=m[i-1][i-1];
			if(a[i]>a[i-1]) dp[i][j]=((m[i-1][i-1]-m[i-1][j-1])%mod+mod)%mod;
			if(a[i]<a[i-1]) dp[i][j]=m[i-1][j-1];
		}
		for(j=1;j<=n;j++) m[i][j]=(m[i][j-1]+dp[i][j])%mod;
	}
	cout<<m[n][n]<<endl;
}
```