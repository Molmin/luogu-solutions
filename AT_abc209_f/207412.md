## ABC209F - Deforestation(*2307)

### Problem
给出 $n$ 棵树，第 $i$ 高 $a_i$，砍走一棵树的代价为 $a_{i-1}+a_i+a_{i+1}$，并且砍走后 $a_i$ 清零，特别的 $a_0=a_{n+1}=0$，问使得代价最小的方案数。
### Solution
考虑对于每个 $a_i$ 对于答案的贡献是多少，很明显，当 $a_i$ 先砍，再砍 $a_{i-1}$ 或 $a_{i+1}$ 时，$a_i$ 不会对 $a_{i-1}$ 或 $a_{i+1}$ 的代价有贡献，那么分情况讨论一下什么时候先砍 $a_i$。

有三种情况（只考虑 $a_i$ 和 $a_{i-1}$，因为 $a_{i+1}$ 也是同一种情况）

+ $a_i=a_{i-1}$，这时候不管顺序，代价都是一样的。

+ $a_i>a_{i-1}$，这时候应该先砍 $a_i$，再砍 $a_{i-1}$，这种代价为 $(a_{i-1}+a_i+a_{i+1})+(a_{i-2}+a_{i-1}+0)=2* a_{i-1}+a_i+a_{i+1}+a_{i-2}$，相反，如果先砍 $a_{i-1}$，再砍 $a_i$，代价为 $(0+a_i+a_{i+1})+(a_{i-2}+a_{i-1}+a_i)=a_{i-1}+2*a_i+a_{i+1}+a_{i-2}$，显然前者更优。

+ $a_i<a_{i-1}$，同理，应该先砍 $a_{i-1}$，再砍 $a_i$（注意上面都是考虑 $a_i$ 和 $a_{i-1}$，与 $a_{i+1}$ 的先后无关，如果是中间砍 $a_{i+1}$，那么当枚举到下一个的时候也会考虑，像这样的局部最优肯定是最优解，所以用这个贪心策略可以得到最低代价）。

题目还要求求方案的数量，我们可以根据贪心原则设计 DP，设 $f_{i,j}$ 表示将前 $i$ 棵树看完并且第 $j$ 次砍第 $i$ 棵树的方案数，依旧分三种情况：

+ $a_i=a_{i-1}$，那么 $f_{i,j}=\sum_{k=1}^{i-1}f_{i,k}$，也就是说 $i$ 与 $i-1$ 间没有位置关系要求，但 $k\le i-1$，注意此处砍 $a_i$ 不会对除了 $a_{i-1}$ 和 $a_{i+1}$ 其外的树有影响，所以第 $1$ 次到第 $i$ 次砍 $a_i$ 都可以。

+ $a_i>a_{i-1}$，那么 $f_{i,j}=\sum_{k=1}^{j-1}f_{i-1,k}$，也就是说 $a_i$ 要在砍 $a_{i-1}$ 之前。

+ $a_i<a_{i-1}$，那么 $f_{i,j}=\sum_{k=j}^{i-1}f_{i-1,k}$，也就是说 $a_i$ 要在砍 $a_{i-1}$ 之后，并且 $k\le i-1$。

这样时间复杂度是 $O(n^3)$ 的，用前缀和优化一下就是 $O(n^2)$。

### Code
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int N=5007;
const int M=1e9+7;
int a[N],f[N][N],sum[N][N];
main() 
{
	int n,ans=0;
	scanf("%lld",&n);
	for(int i=1;i<=n;i++)
	scanf("%lld",&a[i]);
	f[1][1]=sum[1][1]=1;
	for(int i=2;i<=n;i++)
	{
		for(int j=1;j<=i;j++)
		{
			if(a[i]==a[i-1])f[i][j]=sum[i-1][i-1]%M;
			if(a[i]>a[i-1])f[i][j]=sum[i-1][j-1]%M;
			if(a[i]<a[i-1])f[i][j]=(sum[i-1][i-1]-sum[i-1][j-1])%M+M;//前缀和是sum[i-1][i-1]-sum[i-1][j-1]而不是sum[i-1][i-1]-sum[i-1][j]，后者减去了f[i-1][j]
		}
		for(int j=1;j<=n;j++)sum[i][j]=(sum[i][j-1]+f[i][j])%M;
	}
	for(int i=1;i<=n;i++)
	ans+=f[n][i],ans%=M;
	printf("%lld",ans);
	return 0;
}
```