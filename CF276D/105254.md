这里再补充说明下代码最短的做法把。

## 解析

其实我觉得这种做法本质就是贪心。

首先从 `long long` 最高位开始向低位比较 $l, r$，从最高位到第一个不同的位置之间的位置（不包含这个不同的位置）是不可能有贡献的：因为如果要产生贡献，就意味着 $a, b$ 有一个数在这位为 $0$，那么那个数一定比 $l$ 小，是**不在范围内**的。

并且我们设答案两个数在这范围内的二进制位也都和 $l, r$ 相同。

对于第一个不同的位置，可以保证此时 $r$ 这位为 $1$，$l$ 这位为 $0$，否则 $l$ 就会小于 $r$。因此我们可以设答案的某个数这位为 $1$，剩下的位（注意高位上面设过了）均为 $0$，可知道这个数一定是**在范围内**的（因为在不同的这位它大于 $l$，于是后面位怎样都保证大于 $l$；而我们将后面位都设为 $0$ 就保证了它一定小于或等于 $r$）。

对于另外一个数，设不同的这位为 $0$，剩下的位都为 $1$，也可知道这个数一定是在范围内的（因为在不同的这位它小于 $r$，于是后面位怎样它也仍小于 $r$；而我们将后面位都设为 $1$ 就保证了它一定大于或等于 $l$）。

&nbsp;

举个例子，我们有 $l=001101101, r=011011010$（二进制），就可以按上面的贪心构造出一组答案 $a=010000000, b=001111111$。

~~（输出大概就不用说了吧（~~

## CODE

（真的超短）

```cpp
#include <cstdio>

int main(){
	long long a, b; scanf("%lld%lld", &a, &b);
	long long p =(1ll<<62);
	while(p && ((a&p) == (b&p))) p >>=1;
	if(p) printf("%lld", (p<<1)-1);
	else putchar('0');
}
```
