这题是一道构造题。

首先先翻译一下题面：

现在有 $n$ 张纸，你可以在 $n$ 张纸上写上 $k$ 个数（ $n,k$ 自己决定 ），需要满足以下条件：

- 所有数的值都在 $[1,n]$ 以内。

- 每张纸上的数互不相同。

- 所有 $[1,n]$ 内的数恰好出现 $k$ 次。

- 任何两张纸上有且仅有一个数相同。

你需要构造一种满足这些条件的写数方法。

构造方案必须满足 $1000\leq n\leq 2000$

首先可以发现， $k$ 定小并不高效。

比如说当 $n$ 较大时，若 $k$ 设为 $2$ ，则显然无法满足条件。

那么考虑一种 $n=7,k=3$ 的构造方案：

```
7 3
1 2 3
1 4 5
1 6 7
2 4 6
2 5 7
3 4 7
3 5 6
```
可以发现，因为每两张纸只能有一个数相同，且每个数出现 $k$ 次。

那我们可以以最小为 $1$ ，最小为 $2$ …… 最小为 $k$ 来分类。

可以先在一张纸上写下 $1,2,3,\cdots,k$ ，然后再分组，就像这样：

```
7 3
1 2 3
1
1
2
2
3
3

```
这样每组之间只要互不相同就行了。

所以可以得到：$k+(k-1)^2=k^2-k+1 \leq n$ 时可以满足互不相同的条件。

那我们就考虑 $n=k^2-k+1$ 的情况最为轻松。

然后为了互不相同，我们可以先将 $1$ 开头的填完。

```
7 3
1 2 3
1 4 5 
1 6 7
2
2
3
3

```
那么接下来若要取数，则就必须满足在一张纸上写的数不同时取到前 $k$ 张上的数。

那么可以构造一个矩阵

```
4 5
6 7
```
然后接下来对于 $2$ 来讲，只要取不同行的就行。那可以直接取 $4,6$ 和 $5,7$ 作为其它两个数。

然后再对于 $3$ 来讲，因为不能与前面重叠，所以必须取 $4,7$ 和 $5,6$ 作为其它两个数。

也就是错开 $1$ 位。

那接下来若有的话，那错 $2$ 位，错 $3$ 位……就行了。

那这样不会导致不同的两组有大于两个的重复吗？

如只有 $4$ 个数时，那当我们取错 $2$ 位时会有重复。

那这种问题的解决方案就是当 $k+1$ 为质数时就不会冲突了。

所以必须要取 $k+1$ 为质数，才不会发生冲突。

那接下来就没什么难度了，代码也很简短，具体细节看代码吧。

### Code：

```cpp
#include<bits/stdc++.h>
using namespace std;
inline int read()
{
	int sum=0,nega=1;char ch=getchar();
	while(ch>'9'||ch<'0'){if(ch=='-')nega=-1;ch=getchar();}
	while(ch<='9'&&ch>='0')sum=sum*10+ch-'0',ch=getchar();
	return sum*nega;
}
int n,k=38,s[50][50],cnt,pos;
int main()
{
	n=1+k*(k-1);
	cout<<n<<" "<<k<<endl;
	for(int i=1;i<=k;i++)
	{
		cnt=0;
		printf("1 ");
		for(int j=2+(k-1)*(i-1);j<=1+i*(k-1);j++)
		{
			cnt++;
			printf("%d ",j);
			if(i>=2)s[i-1][cnt]=j;
		}
		puts("");
	}
	for(int i=2;i<=k;i++)
		for(int j=1;j<=k-1;j++)
		{
			printf("%d ",i);
			pos=i-2;
			for(int p=1;p<=k-1;p++)printf("%d ",s[p][(pos*(p-1)+j-1)%(k-1)+1]);
			puts("");
		}
	return 0;
}
```
