## 前言
首紫，按照惯例，来篇题解。

~~话说做出这道题的其他人都是身经百战的大佬，就我一个人把这题当做首紫吗？~~

看了看做对的人数，这题挺难的，建议升黑。~~这样我就有首黑题了。~~

# Solution
## 1、特判
1、$\min(n,m)=1$。这个时候只能从头到尾按一个方向走，$k>m-1$ 时有解。

2、$\min(n,m)=2$。这个时候只能蛇形走位，$k>1$ 时有解。

如图：

| ↓ | → | ↓ | → | …… | 
| -----------: | -----------: | -----------: | -----------: | -----------: |
| → | ↑ | → | ↑ |  |

3、$\min(n,m)=3$。这个时候同样只能蛇形走位，$k>2$ 时有解。此处与上一项同理。

## 2、非特判

按照这种构造题的套路，我们能够知道，这种题肯定不会去做搜索。肯定是在 $n$、$m$、$k$ 满足什么条件的时候固定有解。

根据我们绝不小心求证，只管大胆胡说的原则，我们猜 $k≥3$ 时有解。

同时我们又知道有这么一种经典的绕路方式：

| ↓ | → | ↓ | → | ↓ |
| -----------: | -----------: | -----------: | -----------: | -----------: |
| → | ↑ | → | ↑ | ↓ |
| ↓ | ← | ↓ | ← | ↓ |
| ↓ | ↑ | ← | ↑ | ↓ |

此时 $k≥4$。但是这种绕路的首尾段其实是很不合理的，我们可以把它改成 $k≥3$。而如果都采用这种方式或者它的类似，**那么分类讨论就只跟 $n$ 和 $m$ 的奇偶有关。**

### 1、$n$ 和 $m$ 一奇一偶

这个是最简单的情况，先默认把行调成偶数列调成奇数，然后再对上方的绕路法每两行的首尾稍稍修改即可在 $k≥3$ 之内完成。具体完成方法如图：

| ↓ | ← | → | → | ↓ |
| -----------: | -----------: | -----------: | -----------: | -----------: |
| → | → | ↑ | ↓ | ← |
| ↓ | ← | ← | → | ↓ |
| → | ↓ | ↑ | ← | ← |

注意起始点是 $(2,1)$，如果之前交换过 $n$ 和 $m$ 的话，起始点是 $(1,2)$。

### 2、$n$ 和 $m$ 都是偶数

我们发现在这种情况下没有特别简单的绕路了，但是可以用一种绕法，每次消掉两行两列。最后必然剩下两行和许多列，再进行蛇形走位即可。

这样仍然可以在 $k≥3$ 之内完成。

消去两行两列的方法如图：

| ↓ | → | ↓ | → | → | ↓ |
| -----------: | -----------: | -----------: | -----------: | -----------: | -----------: |
| → | ↑ | → | ↑ | ↓ | ← |
|  |  |  |  | → | ↓ |
|  |  |  |  | ↓ | ← |
|  |  |  |  | → | ↓ |
|  |  |  | … | ← | ← |

### 3、$n$ 和 $m$ 都是奇数

与第二种情况非常相似，用类似的方法可以消去两行两列，最后剩下三行多列，仍然可以在 $k≥3$ 之内完成。

消去两行两列的方法如图（与上面的略有不同）：

| ↓ | → | ↓ | → | ↓ |
| :----------- | :----------- | :----------- | :----------- | :----------- |
| → | ↑ | → | ↑ | ↓ |
|  |  |  | ↓ | ← |
|  |  |  | → | ↓ |
|  |  | … | ← | ← |

**综上所述，在非特判的情况下，在 $k≥3$ 时可以解决。**

## 3、一点小建议

这样的蛇形走位方式理解起来很容易，而输出却很难。

我所采用的方式是定义一个三维数组 $o$，来表示在是否交换过 $n$ 和 $m$，是否旋转过（第二次消两行两列时有旋转的情况）时，各个方向真实对应的是哪个方向。

同时定义一大堆数组，来模拟不同蛇形走位对应的方向，这样或许比较方便输出。各位如果有更好的方法也可以使用自己的。

## 4、AC代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,k,sw,i,j,l,two[4]={2,1,0,1},tw[4]={2,3,0,3},dt[4]={3,2,1,2},three[6]={2,2,1,0,0,1};char o[2][2][4]={{{'U','R','D','L'},{'D','L','U','R'}},{{'L','D','R','U'},{'R','U','L','D'}}};
//two，tw，three，dt表示不同的蛇形走路绕路方法。
int main()
{
	cin>>n>>m>>k;
	if(n>m)
	{
		swap(n,m);
		sw=(sw+1)%2;
	}
	if(n==1)
	{
		if(k<m) cout<<"NO";
		else
		{
			cout<<"YES"<<endl;
			for(i=1;i<m;i++) putchar(o[sw][0][1]);
			cout<<endl<<"1 1";	
		}
		return 0;
	}
	if(n==2)
	{
		if(k<2) cout<<"NO";
		else
		{
			cout<<"YES"<<endl;
			for(i=0;i<2*m-1;i++) putchar(o[sw][0][two[i%4]]);
			cout<<endl<<"1 1";
		}
		return 0;
	}
	if(n==3)
	{
		if(k<3) cout<<"NO";
		else
		{
			cout<<"YES"<<endl;
			for(i=0;i<3*m-1;i++) putchar(o[sw][0][three[i%6]]);
			cout<<endl<<"1 1";
		}
		return 0;
	}
	if(k<3)
	{
		cout<<"NO";
		return 0;
	}
	else cout<<"YES\n";
	if(m%2==0&&n%2)
	{
		swap(n,m);
		sw=(sw+1)%2;
	}
	if(n%2==0&&m%2)
	{
		for(i=1;i<=n/2;i++)
		{
			if(i%2)
			{
				putchar(o[sw][0][3]);putchar(o[sw][0][2]);putchar(o[sw][0][1]);putchar(o[sw][0][1]);putchar(o[sw][0][0]);putchar(o[sw][0][1]);
				for(j=0;j<2*(m-5);j++) putchar(o[sw][0][two[j%4]]);
				putchar(o[sw][0][1]);putchar(o[sw][0][2]);putchar(o[sw][0][3]);
				if(i!=n/2) putchar(o[sw][0][2]);
			}
			else
			{
				putchar(o[sw][0][1]);putchar(o[sw][0][2]);putchar(o[sw][0][3]);putchar(o[sw][0][3]);putchar(o[sw][0][0]);putchar(o[sw][0][3]);
				for(j=0;j<2*(m-5);j++) putchar(o[sw][0][tw[j%4]]);
				putchar(o[sw][0][3]);putchar(o[sw][0][2]);putchar(o[sw][0][1]);
				if(i!=n/2) putchar(o[sw][0][2]);
			}
		}
		if(sw) cout<<"\n2 1";
		else cout<<"\n1 2";
		return 0;
	}
	if(n%2&&m%2)
	{
		for(i=0;i<(n-3)/2;i++)
		{
			for(j=0;j<2*m-1-4*i;j++) putchar(o[sw][i%2][two[j%4]]);
			putchar(o[sw][i%2][2]);
			for(j=0;j<2*n-5-4*i;j++) putchar(o[sw][i%2][dt[j%4]]);
			putchar(o[sw][i%2][3]);
		}
		for(l=0;l<(m-2*i)*3-1;l++) putchar(o[sw][i%2][three[l%6]]);
		cout<<"\n1 1";
		return 0;
	}
	for(i=0;i<(n-2)/2;i++)
	{
		for(j=0;j<2*m-4-4*i;j++) putchar(o[sw][i%2][two[j%4]]);
		for(j=2;j<2*n+1-4*i;j++) putchar(o[sw][i%2][dt[j%4]]);
		putchar(o[sw][i%2][3]);
	}
	for(l=0;l<(m-2*i)*2-1;l++) putchar(o[sw][i%2][two[l%4]]);
	cout<<"\n1 1";
	return 0;
}
```

# The End.