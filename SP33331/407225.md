## [SP33331](https://www.luogu.com.cn/problem/SP33331) 题解
**还没有读题的童鞋点击上方传送门传送哦**
### 前置知识
- **数据结构-树**
- **STL-set**

### Step 1

首先看到样例：给出节点的父亲节点并非按照顺序，故第一步将树的节点进行排序。

排序规则：**由父亲节点从大到小排序**

原因很好理解。如果按照原数据，或是从小到大排序的话，就会出现遍历不全的情况。由于接下来我们要统计每一个节点对应树的水果种类，所以，如果我们先遍历到一个节点的对应父节点，再遍历该节点的话，种类的顺序就被打乱了。虽然也可以通过多次循环的方法查找，但那样时间复杂度很高。

然后要注意的是，节点的编号为数据的输入顺序，所以我们进行排序后，节点的编号就被打乱了。因而我们在初始化时，要记录该节点在输入时的位置。

根节点没有父节点，将其父节点定为 $-1$，方便我们进行排序。

排序完成后，我们将现在节点的位置存储一下即可。

### Step 2

进行上述操作之后，我们就要进入最关键的一步，统计子树中的水果种类。

题目中明确的告诉我们，子树中水果的种类数量为对应子树根节点的值。也就是说，我们不能重复统计一个相同的种类。这时候请出我们的重磅嘉宾：**SET**。

由于其自带优秀的去重功能，所以我们可以很好地利用它。每次将一个节点的水果种类赋给其父节点，经过去重后，**set** 的大小就是我们要的值(注意到一个节点的孩子节点可能不只一个)。

**P.S**: **set** 不能以下标的方式遍历，必须用到其自带的迭代器。具体方法见下方代码。

### 代码实现
```cpp
#include<bits/stdc++.h>
using namespace std;
const int mod = 1000000007;
struct node{
	int fa, x;
	int index;//输入时节点的下标 
	set<int> kind;//统计这个节点的子树的种类有哪些 
}a[100005];//定义结构体 
int n, ans = 1, temp[100005];//temp:排序后节点的位置 
bool cmp(node x, node y){
	return x.fa > y.fa;
}//自定义排序规则 
int main(){
	scanf("%d", &n);
	a[0].fa = -1;
	for (int i = 1; i < n; i++)
		scanf("%d", &a[i].fa);
	for (int i = 0; i < n; i++)
		scanf("%d", &a[i].x), a[i].kind.insert(a[i].x), a[i].index = i;
	//注意将这个节点本身的水果种类加入子树 
	stable_sort(a, a + n, cmp);
	//排序
	//stable_sort:稳定的sort排序 
	for (int i = 0; i < n; i++)
		temp[a[i].index] = i;
	//传入当前位置 
	for (int i = 0; i < n; i++){
		ans = (ans * (a[i].kind.size() % mod)) % mod;
		//乘法的模运算 
		for (set<int>::iterator j = a[i].kind.begin(); j != a[i].kind.end(); j++)
			a[temp[a[i].fa]].kind.insert(*j);
		//敲黑板:set的遍历方式 
	}
	printf("%d", ans);
	return 0;
}
```

做一点小小的修改：如果你用的是 **C++11** 版本或更高，可以用以下代码遍历：
```cpp
for(auto j : a[i].kind){
	//中间部分略
}
```