做的时候发现这题充满了奥妙重重的各种情形，越是想把情况合并就越是想的太复杂，那干脆暴力点好了：

很容易发现最终连接 $u,v$ 两个点的权值只可能是 $a_u,a_v,m$ 三者之一，那么我们的DP状态定义为：

定义`f[u][0/1/2]` 表示`u`这个子树中，`u`的父边权值为 $a_{fa}/a_u/m$ 的满足题意要求的最大值（包括父边）。

对于一个度数为 $d$ 的点，其周围要满足至少有 $t=\lfloor {d\over2}\rfloor+1$ 条边的权值小于等于 $a_u$，那么可以根据父边的权值分成两种情况：儿子中的边有 $t$ 条满足或者 $t-1$ 条满足权值小于等于 $a_u$。

很容易写出一个 $O(n^2)$ 的做法（~~除了菊花图和最后一个数据点都能过了~~）：

对当前结点 $u$ 的某个儿子 $v$，其能产生  $1$ 的贡献的最大值为 $g_1$，不一定产生 $1$ 的贡献的最大值为 $g_0$，具体计算见下面的代码，很好理解。最终目的是所有儿子产生 $t$ 或者 $t-1$ 个贡献，这个做法其实就是个背包，但其实可以优化:

显然 $g_0\ge g_1$ ，现在的目的是选 $t$ 个儿子（选 $t-1$ 个儿子的情况不赘述 ），那么我们可以先假设都不选，即加的都是 $g_0$，得到一个较大的值 $s$，最后再减去 $t$ 个差值 $g_0-g_1$。因为求的是最大值，所以希望减得数值越小越好，那么通过排序把最小的 $t$ 个找出来减去就好了。

要注意的是，如果 $t>$ 儿子个数，要特殊判断：通过儿子产生 $t$ 个贡献是不可能的，记为负无穷。

最后根节点特殊处理下，`f[1][0]`就是答案。

参考代码如下：

```cpp
void dfs(int u, int fa) {
    int t = G[u].size() / 2 + 1;
    for (auto v : G[u]) {
        if (v == fa) continue;
        dfs(v, u);
    }
    LL s = 0;
    int tot = 0;
    for (auto v : G[u]) {
        if (v == fa) continue;
        LL g0 = max(f[v][2], max(f[v][0], f[v][1]));             // 不一定有1贡献
        LL g1 = a[u] <= a[v] ? f[v][0] : max(f[v][0], f[v][1]);  // 一定有1贡献
        s += g0;
        b[tot++] = g0 - g1;
    }
    sort(b, b + tot);
    for (int i = 0; i < t - 1; i++) {
        s -= b[i];
    }
    LL s1 = s;
    if (t - 1 < tot) {
        s -= b[t - 1];
    } else {
        s = -1e18;
    }
    if (u == 1) {
        f[u][0] = s;
        return;
    }
    f[u][0] = a[fa] <= a[u] ? s1 + a[fa] : s + a[fa];
    f[u][1] = s1 + a[u];
    f[u][2] = m <= a[u] ? s1 + m : s + m;
}
```




