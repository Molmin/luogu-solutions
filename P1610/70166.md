这道题我同学很快就想出了思路，但是他没有用~

（原话：哎呀估计一下这个思路代码太长了我再写一个**8行**的吧）（orz奆佬）

（所以这个思路用到了我的代码里O(略略略)O~）

### 这个思路是一个非常奇葩的思路：

1.防止题目有坑**先排序**！

2.把$p[i]$加上$dist$，再另开一个$j$循环往后搜索，一旦发现有小于当前$p[i]$的$p[j]$，$sum$就++，并且标记$p[j]$(这一条可能有点难理解，往后有代码解释).

3.然后就可以输出了！

# 然而

这个思路还有很多的BUG

下面上代码并一一解释那些年我们没跳过去的坑：

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
int n,dist,p[100100],sum;
int main()
{
	cin>>n>>dist;
	for(int i=1;i<=n;i++)
	  cin>>p[i];
	sort(p+1,p+n+1);//数据范围不怂
	for(int i=1;i<n;i++)//坑1：i并不能等于n
	{
		if(p[i]>0)//这个地方就是个判断标记（见下方）
		{
			p[i]+=dist;//没错这个就是思路的核心
			for(int j=i+2;j<=n;j++)//坑2：其实这个地方即使j超出了n的范围，但也不碍事因为循环会自动停止
			{
				if(p[j]<=p[i])
				{
					p[j-1]=-100;//标记在此！（接上方）
					sum++;
				}//坑2.5：emmm其实这里我没写括号导致“莫名其妙”WA
			}
		}
	}
	cout<<sum;
	return 0;
}
```

对了，关于这里——

```cpp
for(int j=i+2;j<=n;j++)
```

以及这里——

```cpp
p[j-1]=-100;
```

坑3：（其实一开始我对题目有些误解）题目是让我们关掉两盏灯之间的那盏，所以我们用大循环中的$i$代表前一盏灯，$j$（也就是$i+2$）代表后一盏灯，$j-1$才是我们要关掉的灯.

## 最后，特别感谢坐在我旁边的同学提供了一个BUG而又wonderful的思路给我！orz！

（然而他早就已经8行代码AC了。。。）