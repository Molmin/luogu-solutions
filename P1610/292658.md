本蒟蒻来发题解啦！

这道题我第一次做PA，再看原来是数组开的不够大，改了就AC了……

所以说数组大小很重要啊！
------------
其实这道题是一道标准的贪心题目，贪心策略，排序，选择一应俱全（~~那我为什么还PA~~）

用一个数组确定开关灯的状态，初始都设定为1，再用排序把灯的位置排一下，最后遍历数组（从2到n），看离i左边与右边最近的灯的距离是否<=dist就行了，如果可以的话ans++，再把状态数组中灯的位置的状态置为0，最后输出ans就行了。

~~其实可以最后遍历整个数组，每碰到0就ans++的，但我嫌太麻烦没用~~

上代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
int n,dist,a[100001],ans=0; 
bool b[100001];//确定开关灯状态的数组 
int main()
{
	cin>>n>>dist;
	for(int i=1;i<=n;i++)
	{
		cin>>a[i];
		b[i]=1;
	}
	sort(a+1,a+n+1);//快速排序 
	for(int i=2;i<n;i++)//从2到n，（因为洞口和洞穴最深处不能关灯） 
	{
 		int p,q;//设定两个变量来记录离i左边与右边最近的灯 
		for(int j=i-1;j>=1;j--)//寻找左边离i最近的灯 
		{
			if(b[j]==1)//如果是离i左边最近的灯，将q设为j
			{
				q=j;
				break;
			}
		}
		for(int j=i+1;j<=n;j++)//寻找右边离i最近的灯 
		{
			if(b[j]==1)//如果是离i右边最近的灯，将p设为j
			{
				p=j;
				break;
			}
		}
		if(a[p]-a[q]<=dist)//判断左右两盏灯之间的距离是否大于安全距离 
		{
			b[i]=0;//置零很重要！！！ 
			ans++;//调整计数器 
		}
	}
	cout<<ans;//输出 
	return 0;//撒花！*★,°*:.☆(￣▽￣)/$:*.°★* 。 
}
```
本蒟蒻第一次发题解，求管理员大大给过！