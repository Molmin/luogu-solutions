# 题目大意
有 $n$ 个连续的宽度为 $1$ 高度为 $a_i$ 的矩形，要求给它全部涂上颜色，有两种涂法，一种横着涂，一种竖着涂，只能涂一个连续的区域，每涂一次代价为 $1$。
# 思路
第一眼看到题目发现 $n$ 的范围很小，打算暴力枚举涂底下的行数，剩下的全部竖着涂，最后算出最小的代价，时间复杂度为 $O(n^2)$，看起来貌似可以过。但是这种算法是一种假贪心，只能拿到 $10$ 分（悲）。

很容易就能举出反例，当其中有几个区间所涂的横行高度不同时，这种假贪心就废了。可以被以下这个简简单单的样例卡掉：
```
10
3 7 5 4 8 2 10 4 7 7
```
那么正确的写法是怎么样的？

我们可以借上面这种错误写法继续发挥，很快想到了另一种 ~~Bigger , Better , Stronger~~ 的正确写法。

其实一个区间可以分为两部分，下面所有矩形都包括的横行以及上面的若干个更小的区间。马上就能发现涂完这个区间的代价为这个区间种的矩形数量和涂掉下面横行的代价加上上面若干个小区间的代价中的最小值。

其实这就是一种分治的写法，使用深搜来计算每一个从 $l$ 到 $r$ 区间的最小代价，当 $l$ 与 $r$ 相等时，返回代价为 $1$，代码很短，主要考察了分治的思想。
# 代码

```
#include<bits/stdc++.h>
using namespace std;
const int N=5e3+5;
int n,a[N];
int dfs(int l,int r){
	if(l==r)return 1;
	int mi=1e9+7,sum=0;
	for(int i=l;i<=r;i++){
		mi=min(mi,a[i]);
	}
	for(int i=l;i<=r;i++){
		a[i]-=mi;
	}
	for(int i=l;i<=r;i++){
		if(a[i]!=0){
			int now=i;
			while(a[now]!=0)now++;
			now--;
			sum+=dfs(i,now);
			i=now;
		}
	}
	return min(r-l+1,sum+mi);
}
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		scanf("%d",&a[i]);
	}
	printf("%d",dfs(1,n));
	return 0;
}
```