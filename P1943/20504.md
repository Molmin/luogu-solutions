**UPD:增加了分块图示**

先膜一波调和级数爷%%%

欧拉常数什么的我都还没学过。但是我可以**分块打表**呀！

题意就是让我们求：

$$\sum_{i=1}^n 1/i$$

就是:

$$\frac {1}{1}+\frac {1}{2}+\frac {1}{3}+\frac {1}{4}+....+\frac {1}{n}$$

然后$n<=1000000$那部分可以直接$O(n)$做，但是$n$的最大范围是$2147483647$,显然用$O(n)$做会超时，这时我们就可以分块打表，每隔$10000000(1e7)$个数输出一次。这样我们就只需输出$214$个数，那么剩下来我们也就最多只需加上$10000000$个数就行了，复杂度正确。

举个例子：如果我们要求$n=31.7*1e7$时，我们已经把$31*1e7$给预处理出来了，那么我们只需再计算$(31*1e7,31.7*1e7]$即可。

如图所示，只需多计算红色部分即可。
![](https://cdn.luogu.com.cn/upload/pic/61561.png)

那么接下来就是**打表程序**，每六个换一行。（打表时建议开一些优化开关来加速，我打出这些表大概只需要5秒）

```cpp
#pragma GCC optimize(2)
#pragma GCC optimize(3)
#pragma GCC optimize("inline")
#pragma GCC optimize("Ofast")
#include<bits/stdc++.h>
#define R register
using namespace std;
double sum;
int cnt;
const int size=10000000;
int main(){	
	freopen("biao.out","w",stdout);
	for(R int i=1;i<=2140000000;i++){
		sum+=1.0/(double)i;
		if(i%size==0){
			cnt++;
			if(cnt==1) printf("	  ");//手动TAB
			printf("bol[%d]=%.8lf; ",i/size,sum);
			if(cnt==6){//每六个换行
				puts("");
				cnt=0;
			}
		}
	}
	return 0;
}
```

然后**提交代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int size=10000000;
double bol[300];
int n;
int main(){
	  scanf("%d",&n);
	  bol[1]=16.69531137; bol[2]=17.38845852; bol[3]=17.79392362; bol[4]=18.08160569; bol[5]=18.30474924; bol[6]=18.48707079; 
	  bol[7]=18.64122147; bol[8]=18.77475286; bol[9]=18.89253590; bol[10]=18.99789641; bol[11]=19.09320659; bol[12]=19.18021797; 
	  bol[13]=19.26026068; bol[14]=19.33436865; bol[15]=19.40336152; bol[16]=19.46790004; bol[17]=19.52852466; bol[18]=19.58568308; 
	  bol[19]=19.63975030; bol[20]=19.69104359; bol[21]=19.73983376; bol[22]=19.78635377; bol[23]=19.83080553; bol[24]=19.87336515; 
	  bol[25]=19.91418714; bol[26]=19.95340786; bol[27]=19.99114818; bol[28]=20.02751583; bol[29]=20.06260715; bol[30]=20.09650870; 
	  bol[31]=20.12929852; bol[32]=20.16104722; bol[33]=20.19181888; bol[34]=20.22167184; bol[35]=20.25065938; bol[36]=20.27883026; 
	  bol[37]=20.30622923; bol[38]=20.33289748; bol[39]=20.35887296; bol[40]=20.38419077; bol[41]=20.40888338; bol[42]=20.43298094; 
	  bol[43]=20.45651143; bol[44]=20.47950095; bol[45]=20.50197381; bol[46]=20.52395271; bol[47]=20.54545892; bol[48]=20.56651233; 
	  bol[49]=20.58713161; bol[50]=20.60733432; bol[51]=20.62713695; bol[52]=20.64655504; bol[53]=20.66560323; bol[54]=20.68429536; 
	  bol[55]=20.70264450; bol[56]=20.72066301; bol[57]=20.73836258; bol[58]=20.75575433; bol[59]=20.77284876; bol[60]=20.78965588; 
	  bol[61]=20.80618518; bol[62]=20.82244570; bol[63]=20.83844604; bol[64]=20.85419440; bol[65]=20.86969859; bol[66]=20.88496606; 
	  bol[67]=20.90000394; bol[68]=20.91481902; bol[69]=20.92941782; bol[70]=20.94380656; bol[71]=20.95799119; bol[72]=20.97197744; 
	  bol[73]=20.98577076; bol[74]=20.99937641; bol[75]=21.01279943; bol[76]=21.02604466; bol[77]=21.03911674; bol[78]=21.05202014; 
	  bol[79]=21.06475917; bol[80]=21.07733795; bol[81]=21.08976047; bol[82]=21.10203056; bol[83]=21.11415192; bol[84]=21.12612812; 
	  bol[85]=21.13796257; bol[86]=21.14965861; bol[87]=21.16121944; bol[88]=21.17264813; bol[89]=21.18394769; bol[90]=21.19512099; 
	  bol[91]=21.20617082; bol[92]=21.21709989; bol[93]=21.22791081; bol[94]=21.23860610; bol[95]=21.24918821; bol[96]=21.25965951; 
	  bol[97]=21.27002230; bol[98]=21.28027880; bol[99]=21.29043117; bol[100]=21.30048150; bol[101]=21.31043183; bol[102]=21.32028413; 
	  bol[103]=21.33004030; bol[104]=21.33970222; bol[105]=21.34927167; bol[106]=21.35875041; bol[107]=21.36814015; bol[108]=21.37744254; 
	  bol[109]=21.38665920; bol[110]=21.39579168; bol[111]=21.40484152; bol[112]=21.41381019; bol[113]=21.42269914; bol[114]=21.43150976; 
	  bol[115]=21.44024344; bol[116]=21.44890151; bol[117]=21.45748525; bol[118]=21.46599594; bol[119]=21.47443481; bol[120]=21.48280306; 
	  bol[121]=21.49110186; bol[122]=21.49933236; bol[123]=21.50749567; bol[124]=21.51559288; bol[125]=21.52362505; bol[126]=21.53159322; 
	  bol[127]=21.53949840; bol[128]=21.54734158; bol[129]=21.55512372; bol[130]=21.56284577; bol[131]=21.57050864; bol[132]=21.57811324; 
	  bol[133]=21.58566044; bol[134]=21.59315112; bol[135]=21.60058609; bol[136]=21.60796620; bol[137]=21.61529224; bol[138]=21.62256500; 
	  bol[139]=21.62978525; bol[140]=21.63695374; bol[141]=21.64407121; bol[142]=21.65113837; bol[143]=21.65815595; bol[144]=21.66512462; 
	  bol[145]=21.67204506; bol[146]=21.67891794; bol[147]=21.68574390; bol[148]=21.69252359; bol[149]=21.69925762; bol[150]=21.70594661; 
	  bol[151]=21.71259115; bol[152]=21.71919184; bol[153]=21.72574924; bol[154]=21.73226392; bol[155]=21.73873643; bol[156]=21.74516732; 
	  bol[157]=21.75155712; bol[158]=21.75790635; bol[159]=21.76421552; bol[160]=21.77048513; bol[161]=21.77671568; bol[162]=21.78290765; 
	  bol[163]=21.78906152; bol[164]=21.79517774; bol[165]=21.80125679; bol[166]=21.80729910; bol[167]=21.81330513; bol[168]=21.81927530; 
	  bol[169]=21.82521003; bol[170]=21.83110975; bol[171]=21.83697487; bol[172]=21.84280579; bol[173]=21.84860291; bol[174]=21.85436662; 
	  bol[175]=21.86009729; bol[176]=21.86579531; bol[177]=21.87146105; bol[178]=21.87709487; bol[179]=21.88269712; bol[180]=21.88826817; 
	  bol[181]=21.89380835; bol[182]=21.89931800; bol[183]=21.90479747; bol[184]=21.91024707; bol[185]=21.91566714; bol[186]=21.92105799; 
	  bol[187]=21.92641993; bol[188]=21.93175328; bol[189]=21.93705833; bol[190]=21.94233539; bol[191]=21.94758474; bol[192]=21.95280669; 
	  bol[193]=21.95800151; bol[194]=21.96316948; bol[195]=21.96831087; bol[196]=21.97342598; bol[197]=21.97851505; bol[198]=21.98357835; 
	  bol[199]=21.98861614; bol[200]=21.99362868; bol[201]=21.99861622; bol[202]=22.00357901; bol[203]=22.00851730; bol[204]=22.01343131; 
	  bol[205]=22.01832130; bol[206]=22.02318749; bol[207]=22.02803011; bol[208]=22.03284940; bol[209]=22.03764557; bol[210]=22.04241885; 
	  bol[211]=22.04716945; bol[212]=22.05189759; bol[213]=22.05660348; bol[214]=22.06128733; 
	  int gs=n/size;//现在向下是哪一块
	  double ans=bol[gs];
	  for(long long i=gs*size+1;i<=n;i++){//剩下的暴力算
          	ans+=1.0/(double)i;
	  }
	  printf("%.8lf",ans);
	  return 0;
}
```
