我一开始看这道题时很崩溃，但其实这道题并不难(也许吧).下面是一篇比较容易理解的题解~~（看不懂就算了^_^）~~

首先为像我一样的初中生解释一下集合：简单地来说，这道题就是要求嵌套for循环

```cpp
for(int i=a;i<=b;i++)
      for(int j=1;j<=i;j++)
        if（j&1）
          s+=-i/j;
        else
          s+=i/j;
```
    
   中s的结果。~~（求和符号的本质就是循环）（至少我是这么认为的）~~    
   
   但是，这样硬做会超时（我就是这样水了55分）。其实，只要换一种方式做就可以了：
   
   当a=1,b=8时，要求的就是以下这些数的和：
   
|1
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
|1  |2  
|1  |2  |3  
|1  |2  |3  |4  
|1  |2  |3  |4  |5  
|1  |2  |3  |4  |5  |6  
|1  |2  |3  |4  |5  |6  |7  
|1  |2  |3  |4  |5  |6  |7  |8

   
仔细观察就会发现，**一般情况下**（a=1），1会重复加b次，2会重复加（b-1）次，3会重复加（b-2）次……
那么，我们只要用for循环枚举就行了（当让是与上面不同方法）


```cpp
	#include<cstdio> 
  
	#include<iostream>
  
	using namespace std;

	int a,b,k,i,l;
	
	unsigned long long s;

	int main(     )

	{

    scanf("%d%d",&a,&b);
    
    for(int j=1;j<=b;j++)
    
    {
    	if(j%2==1)
    	  l=-1;
    	else
    	  l=1;//判断奇偶
    	if(j<a)//特殊情况1：当j<a时，j重复加的次数就不是（b-j+1）次了。
	  {
	  	  if(a%j==0)//特殊情况2：（我也忘了是什么）
		  {
	  	  	 k=a/j;
             for(i=a;i<=b;i+=j)
             {
        	    s+=k*l*j;
        	    k++;
		     }
		     if((b+1)%j!=0)//特殊情况3：多加了，要减去重复的。
		       s=s-(i-b-1)*(k-1)*l;
		  }
		  else
		  {
		  	 k=a/j+1;
		  	 s+=(a/j)*(k*j-a)*l;
		  	 for(i=k*j;i<=b;i+=j)
		  	 {
        	    s+=k*l*j;
        	    k++;
		     }
		     if((b+1)%j!=0)
		       s=s-(i-b-1)*(k-1)*l;
		  }
	  }
	  else
	  {
	   	  k=1;
	   	  for(i=j;i<=b;i+=j)
	   	  {
	   	  	   s+=k*l*j;
	   	  	   k++;
		  }
		  if((b+1)%j!=0)
		  	s=s-(i-b-1)*(k-1)*l;
	  }
	} 
    printf("%lld",s);
    return 0;
}
```


假如这个方法有问题，那就是数据太水了~~（管它呢，我就这么过了 ）~~

**~~若题解的某些部分与程序不符，请见谅，因为我是做出来很久之后才写题解的。~~**