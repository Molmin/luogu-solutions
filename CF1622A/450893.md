题目大意：

>有$T$组数据，每组有$a$,$b$,$c$三个数，现在然你将$a$,$b$,$c$三个数中的一个数分为两个正整数，问是否将这$4$个数作为边长，拼成一个矩形，能拼成输出$YES$，反之输出$NO$。

思路：

首先这题不可以暴力一个一试着拆 ~~（也可能我就没想暴力）~~ 那么我们需要找出规律首先看第一个数据:

输入：$6,1,5$  
输出 ：$YES$

那我们先发现，我们要的数一定是最大的数（如果不拆最大的数，因为是矩形所以最大的数不拆的话，那么一定有一个数要等于最大的数，那要拆的数拆完一定小于最大的数，那就拼不成矩形）。

现在我们知道了拆最大的数，要拆成剩下两个数，那么剩下的两个数的和等于最大数(因为只有等于了最大数，才能刚好拆分成另外两个数，组成矩形)。

那么我们看第2，4个数据：

输入：$2,5,2$  
输出 ：$NO$

输入：$5,5,4$  
输出 ：$YES$

这样看来第4个样例并不能用我们刚刚发现的规律，但是他有两个数是一样的：$5,5$，那这样就刚好可以组成矩形的两边，那么就看另外的数$4$，因为我们已经有可以拼成的两个边，那么那个数就要分成两个一样的数，可以拼成另两个边，那这个数必须是偶数，那么第2，4个数据就可以解释了（有三条边一样其实也一样）。

经过两个的判断，那么其他的可以发现出都不可组成。

那么这道题就可以实现代码了：

```cpp
#include "iostream"
#include "algorithm"
using namespace std;
int T,a[4];//数据数，3个数
int main(){
    cin>>T;
    while(T--){
        cin>>a[1]>>a[2]>>a[3];
        sort(a+1,a+3+1);//排下序
        if(((a[1]==a[2])&&(a[3]%2==0))||((a[2]==a[3])&&(a[1]%2==0)))//因为排过序后只有第一第二，或第二第三相等（有两个数相同）
            cout<<"YES"<<endl;//第二种情况
        else if(a[1]+a[2]==a[3]) cout<<"YES"<<endl;//第一种情况
        else cout<<"NO"<<endl;//都不符合就是NO
    }
    return 0;
}
```
感谢大家的阅读，以及管理员的审核。


