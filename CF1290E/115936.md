感觉这个题有 *3300 还是挺奇怪的，但是毕竟是经过时代更迭的题，就好像若干年前的神仙题到现在都变成板子题了一个道理。

其实老早就想个大概了，但是前前后后悠哉游哉半个小时愣是刚刚才想出来怎么维护。

考虑笛卡尔树上一个点 $u$ 的子树大小相当于在原序列上找到一个 $L$ 和 $R$ 满足 $L$ 是左边第一个大于 $a_u$ 的位置，$R$ 是右边第一个大于 $a_u$ 的位置。那么这个子树对应的就是区间 $[L+1,R-1]$，所以贡献为 $R-L-1$。

问题转换为维护这个 $L$ 和 $R$，考虑每次加点的时候，新加的数实际上是当前的最大值，所以只需要一个前缀的 $R$ 对当前位置取 $\min$ 和一个后缀的 $L$ 对当前位置取 $\max$ 即可，这个可以吉老师线段树去做。

还有一个问题在于这里的 $[L,R]$ 不是原序列上的编号，而是当前这个动态加点的序列。考虑每次加点的时候对这个编号的影响，显然对左边没影响，对右边集体 +1。

那么因为前缀对当前点取 $\min$ 了，所以前缀的 $R$ 是不会受到影响的，而后缀的 $R$ 一定在当前的点的后面，所以直接区间加即可。后缀同理，有影响的是后缀的 $L$，但是因为取了 $\max$，所以全部都有影响，只需要一个区间加即可，复杂度 $O(n\log^2n)$。

因为涉及到还未加入的点，这里我选择平衡树实现。

平衡树比线段树恶心的地方在于 update 的时候记得考虑这个点自己的值。

https://codeforces.com/contest/1290/submission/170455586