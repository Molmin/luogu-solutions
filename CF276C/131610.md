## 思路
如果不能改变 $a$ 数组的顺序的话，那么我们完全可以用前缀和把它一次秒了。但它可以改变，那我们只能换种思路了。（~~这不是废话吗~~）。

---
首先，我们用贪心思路来看它，因为能改变 $a$ 数组的值，所以我们可以把值大的作为要询问次数多的，这样它的总和就会大（原理：在排序不等式中顺序之积大于乱序之积，乱序之积大于逆序之积）。而询问次数我们可以通过差分来计算。
## 代码
```
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,m,a[200100],d[200100],l,r;
signed main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		cin>>a[i];      //输入数值
	}
	for(int i=1;i<=m;i++){
		cin>>l>>r;      //输入查询范围，
		d[l]++;
		d[r+1]--;   	 //并进行差分来求得每个位置的数的询问次数。
	}
	for(int i=1;i<=n;i++){
		d[i]+=d[i-1];  	 //前缀和辅助差分的实现
	}
	sort(d+1,d+n+1);	 //将数值进行排序
	sort(a+1,a+n+1);	 //将询问次数进行排序
	int ans=0;
	for(int i=1;i<=n;i++){
		ans+=a[i]*d[i]; //此时已经是顺序排列了，求出来的值自然就是最大值了
	}
	cout<<ans<<endl;
	return 0;
}
```