这是一道数学题。

题目大意是给你一个大整数k（位数范围为1000000），让你找到最小的回文数x，使得x>k。

根据定义由k+1开始枚举每个数字，判断其是否是回文数，显然太慢，我们需要考虑其他的方法。

回文数的定义就是正着读和倒着读都一样的数，也就是说以中间为对称轴（如果是奇数个数位就是正中间的数字，偶数个数位就是中间两个数字之间的空隙），两侧是对称的，知道了半边就可以反转求出另外半边。

我们由给出的数字k的左半边进行反转，就可以得到一个回文数t，有两种情况：

1.t>k，那么这个t就是我们所求，因为比t小的第一个回文数是数字的左半边-1进行翻转后的数（左半边是个10的幂就不是这样，需要特殊处理），但是这个回文数一定是小于k的；

2.t<=k，那么我们把k的左半边+1进行翻转，如果+1后左半边不是10的整数次幂，得到的这个值一定大于k，为所求答案。如果+1后左半边是10的整数次幂时左半边原来一定是形如9...99的形式，观察可得他下一个回文数一定是10...01，如此可进行特殊处理。

代码：
```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
const int maxn=1000010;//最大位数
int T,a[maxn],l,c[maxn];
char s[maxn];
inline bool cmp(int x[],int y[])//判断大整数x是否小于等于y
{
	for(int i=0;i<l;i++)if(x[i]!=y[i])return x[i]<y[i];
	return false;
}
int main()
{
	scanf("%d",&T);
	while(T--)
	{
		scanf("%s",s);//以字符串形式输入，方便转换
		if(strcmp(s,"9")==0){printf("11\n");continue;}//特判
		l=strlen(s);
		for(int i=0;i<l;i++)a[i]=s[i]-'0';//字符串转化为整数数组进行处理
		for(int i=0;i<=(l-1)/2;i++)c[i]=c[l-i-1]=a[i];//计算k的左半边反转过去后得到的值t
		if(!cmp(a,c))//进行比较，如果k<=t
		{
			a[(l-1)/2]++;//左半边加一
			for(int i=(l-1)/2;i;i--)a[i-1]+=a[i]/10,a[i]%=10;//处理进位
			for(int i=0;i<=(l-1)/2;i++)c[i]=c[l-i-1]=a[i];//反转过去
		}
		for(int i=0;i<l-1;i++)printf("%d",c[i]);//输出
		if(c[l-1]==10)printf("1\n");//特判，因为进位后第一位可能是10
		else printf("%d\n",c[l-1]);
	}
	return 0;
}
```