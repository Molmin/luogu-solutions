## 题解 CF1536E 【Omkar and Forest】

### 题意

+ 一个 $n\times m$ 的方格图；
+ 其中一部分格子必须填 $0$，其它格子必须填非负整数；
+ 两个格子相邻当且仅当两个格子有公共边；
+ 任意两个相邻的格子上的数的绝对差不超过 $1$；
+ 任意有正整数的格子 $(x1,y1)$，必须存在一个和它相邻的另一个格子 $(x2,y2)$，使 $(x1,y1)$ 上的数大于 $(x2,y2)$ 上的数；
+ 求有多少种不同的填数法；
+ 多组数据，$n,m\le2\times10^3$。

### 做法

对于每个可以填非负整数的格子，设共有 $k$ 个，可以填 $0$ 或填正整数。选其中一部分填 $0$，另一部分填正整数，有 $2^k$ 种选法，每种选法贡献独立。

对于每个原来就是 $0$ 或选后是 $0$ 的格子，它们周围不是 $0$ 的格子只能填 $1$，因为只能填非负整数，且已经不能填 $0$，填的数字如果大于 $1$，与 与它相邻有 $0$ 的格子 的绝对差就大于 $1$。

同理可填出 $2,3,4,\dots$。

发现每种选法的贡献都只有 $1$，所有答案就是选法的总数，特判全图原来没有填 $0$ 个字的情况。

### 代码

```cpp
#include <cstdio>

using namespace std;

const int mod = 1e9 + 7;

const int N = 2e3 + 5;

char s[N];

void solve() {
	int n, m;
	scanf("%d%d", &n, &m);
	int cnt = 0;
	for (int i = 0; i < n; ++i) {
		scanf("%s", s);
		for (int j = 0; j < m; ++j) {
			cnt += (s[j] == '#');
		}
	}
	int ans = 1;
	for (int i = 1; i <= cnt; ++i) {
		ans = (ans << 1) % mod;
	}
	printf("%d\n", ans - (cnt == n * m));
}

int main() {
	int t;
	scanf("%d", &t);
	while (t--) {
		solve();
	}
}
```