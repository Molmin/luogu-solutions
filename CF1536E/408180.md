此题解基本基本为官方题解的翻译，其中一些证明与现有题解不同。

首先我们不妨确定哪些 ```#``` 为 $0$，可以证明，在所有 $0$ 的位置确定时，有且仅有一种方案去填其他的 ```#```。

我们可以对于所有的 $0$ 做一个多源 BFS，每一个非 $0$ 格子的值即为到最近的 $0$ 的距离，且只有这一种构造的方式合法，证明如下：

首先证明相邻两个格子值的差不超过 $1$。如果相邻两个格子的差超过了 $1$，那么值较大的那个格子的值显然可以通过值小的格子的值加一更新。

其次一个格子周围显然至少有一个格子的值小于它，因为在 BFS 的过程中它一定是从一个格子走来的。

最后证明只有这一种合法构造方式。如果一个格子的值小于离它最近的 $0$ 的距离，那么他周围就不会有值比它小的格子；如果强制令一个他周围的格子比它小，那么这个格子的周围也不会有值比它小的格子，如此循环，最后至少会令一个原本值不应该为 $0$ 的格子权值等于了 $0$。如果一个格子的值大于离它最近的 $0$ 的距离，那么他与相邻格子值的差至少有一个大于 $1$，如果强制令相邻的差大于 $1$ 的格子值加一，那么像上面一样，最终会令原本的一些值为 $1$ 的格子的值变为了 $2$。

因为每个 ```#``` 的状态相互独立，所以设 ```#``` 的个数为 $x$，那么答案即为 $2^x$。特殊地，当 $x=nm$ 时，答案为 $2^x-1$，因为此时有一种情况是所有的 ```#``` 都不为 $0$ ，但这时没有初始的 $0$，因此这种情况不存在。

程序只给出主体部分，主要是前面一部分的模板有一些影响观感，而且给出主体已经能够辅助理解。

```cpp
//Linkwish's code
const int N=2005,mod=1e9+7;
int n,m;
char mp[N][N];
inline void solve(){
	read(n),read(m);
	for(int i=1;i<=n;i++)
		scanf("%s",mp[i]+1);
	int cnt=0,ans=1;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			if(mp[i][j]=='#')cnt++;
	for(int i=1;i<=cnt;i++)ans=ans*2%mod;
	writeln((ans-(cnt==n*m)+mod)%mod);
}
```
