### 翻译：

原翻译中已经给出数学模型了，但是想要用那么抽象的东西分析问题难度好像反而上升了不少，这里给出原本的题意：

在农夫约翰的农场上，有 $n$ 头奶牛，现在这些奶牛正在举办一场 CTOP 比赛，每头奶牛在入座前需要和其他单独写代码的奶牛打招呼，在任意时候，每三个奶牛可以组成一队（也可不组）,这样就不用打招呼了。组队操作不可撤销。

已知每一只奶牛想要打招呼的次数，求一种可行的入场方案使得所有的奶牛都能满足这个特定的打招呼次数。

---
### 解题思路：

考虑贪心，做法不难，但想完整地证明还是有一点难度的。

在分析问题前，可以先将所有的人按照打招呼的需求数量从小到大排序，显然这种仅仅改变编号的变换不会造成任何影响，而且可以方便分析。

然后发现每一个人在加入后就失去了特征，所以只需要维护当前未组队的有多少人，每一次组队直接将这个值减少 $3$ 就行了。
再考虑加入操作，当未组队的人确定的时候，每一次可能的加入人的打招呼次数是唯一且确定的。、

这样问题就简单多了，每一次只需要考虑是加入一个人或者减少 $3$ 个人让其组队就行了。

不过直接这样做还是不太好处理（直接做复杂度 $O(2^n)$），考虑再次发掘其性质。

注意到如果在可以将一个人加入时，不加入而将三个人组队可以直接不考虑，也就是说在当前能加入时一直加入，当无法加入时让其中一些人组队。

这样做的证明思路是当削减人数可行时，证明不削减而优先让要求打招呼多的人进入一定可行，然后再反过来证明先让打招呼多的人进入，最后削减人数可行时先削减人数可能不可行。也不是很难。

---
### 代码：

```cpp
#include<cstdio>
#include<vector>
using namespace std;
int n,a[200005],t[200005],now,flag=1,cnt[200005],pri[200005];
vector <int> ans[200005];
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++)scanf("%d",&a[i]),t[a[i]]++;
	for(int i=1;i<=n;i++){
		while(t[now]==0&&now>=3)now-=3;
		if(t[now]==0&&now<3)flag=0;
		t[now]--;
		ans[now].push_back(i);
		cnt[now]++;
		now++;
	}
	if(flag==0)printf("Impossible\n");
	else{
		printf("Possible\n");
		for(int i=1;i<=n;i++)
		pri[ans[a[i]][--cnt[a[i]]]]=i;
		for(int i=1;i<=n;i++)
		printf("%d ",pri[i]);
		printf("\n");
	}
	return 0;
}
```
