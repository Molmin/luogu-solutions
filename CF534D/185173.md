我来完善一下其他题解的想法。

题意：一群学生会去参加比赛，然后三人一组，每个人会和场馆中还未组队的 $a[i]$ 个人进行握手，可以自己一个人一组，求给出一个可行排列。

我们来看一下样例二，可以很容易的模拟出一个过程：

$$
0\ \ \ \ 2\ \ \ \ 3\ \ \ \ 4\ \ \ \ 1\ \ \ \ 1\ \ \ \ 0\ \ \ \ 2\ \ \ \ 2
$$

然后你肯定让 $0$ 的先进去，然后因为要让后面数字大的人进去，所以前面的不要组队，先是能进去肯定先进去。

然后等到进不去了，就开始三人组队。

那么假设你这一次进去了 $x$ 人，即一个 $1,2,\dots,x$ 的序列，那么组完队就是 $x-3$ 人。

那么接下来从 $x+1-3$ 的序号开始进人。

所以限制只有，当前要进去的这个人的数字，是否小于等于当前场馆内未组队人数，为了让后面的人进去，场馆中一定要有一些未组队的人来当基石。

在这样的情况达到最后组队的人数字是 $0,1,2$ 时，就成功了。

比如第二个样例，如果加上一个 $5$ ，就完蛋了，因为这样模拟最后的序列是：

$$
0\ \ \ \ 1\ \ \ \ 2\ \ \ \ 2
$$

然后你从 $0$ 开始拿，最后就留了一个 $2$ 拿不了了。

那么由上面的过程，可以想到用一个桶来维护人，代码如下：

```cpp
#include <bits/stdc++.h>

using namespace std;

const int N = 2e5 + 1;

int n, a[N], cur = 0, tot, ans[N];

vector <int> cnt[N];

int main () {
	scanf ("%d", &n);
	for (int i = 1; i <= n; i ++) {
		scanf ("%d", &a[i]);
		cnt[a[i]].push_back (i); // 桶，为了构造答案方便所以用 vector  
	}
	while (tot < n) {
		if (cnt[cur].size () > 0) { // 能继续让人进来就先让人进 
			ans[++ tot] = cnt[cur].back (); // 就是构造答案  
			cnt[cur ++].pop_back (); // 用完就扔掉不然要出事  
		}
		else { // 如果不存在可以继续进的了  
			if (cur < 3) // 取完以后结果这一批队伍都不到三个 
				return puts ("Impossible"), 0;
			cur -= 3; // 先让里面的人组成一只队伍，cur 就是当前等待人数（进去了但是没组队） 
		}
	}
	puts ("Possible");
	for (int i = 1; i <= tot; i ++)
		printf ("%d ", ans[i]);
}
```