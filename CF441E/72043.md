## 题意
给定一个数  $x$，需要进行  $k$ 次操作，每次操作有  $p\%$ 的概率对它  $\times2$， $(1-p\%)$ 的概率对它  $+1$，求操作完后，该数二进制状态下末尾的最大连续 $0$ 的个数的期望值。
## 分析
**思路 $1:$**
- 考虑期望 $DP$，我们先考虑一种比较暴力的状态，设 $f_{i,x}$ 表示 $i$ 次操作之后变成 $x$ 的概率。转移方程：
$$
+1:f_{i+1,j+1}+=(1-p)\times f_{i,j}
$$
$$
\times2:f_{i+1,j\times2}+=p\times f_{i,j}
$$

则答案为 $\sum_i f_{k,i} \times g_i$，其中 $g_i$ 表示 $i$ 的末尾的 $0$ 的个数，然后我们发现这个转移很容易，但是不管是空间和时间都不在我们能接受的范围内，因为 $x$ 实在是太大了。

**思路 $2:$**
- 既然 $x$ 不能当作我们的状态，那我们换个思路，考虑 $x$ 的增量，我们发现对于每个 $\times2$ 操作，就是在结尾多了个 $0$，所以比较容易维护。对于 $+1$ 操作，虽然它的变化我们很难动态维护，但是它的增量很小，只有 $k$ 的大小，所以我们可以预处理出来。

- 我们设一个新的状态 $f_{i,j}$，表示 **$i$ 次操作后的 $x+j$** 的末尾的 $0$ 的个数的期望值，注意，这里的 $x$ 是指操作后的 $x$，而非最初给定 $x$， 我们不妨设它为 $x'$。则新的转移方程就是
$$
+1:f_{i+1,j-1}+=(1-p)\times f_{i,j}
$$
$$
\times2:f_{i+1,j\times2}+=p\times (f_{i,j}+1)
$$
- 先分析第一种转移，对于第 $i+1$ 次操作后的 $x'$，它的值已经为 $x+1$ 了，所以 $x'+j-1$ 的末尾的 $0$ 的个数是和 $x+j$ 的末尾的 $0$ 的个数是相同的，所以是从 $f_{i,j}$ 转移到 $f_{i+1,j-1}$。

- 再分析第二种转移，也是同理，我们对 $x+j$ 整体 $\times2$，所以第 $i+1$ 次操作后的 $x'$，它的值为 $x\times2$，所以 $x'+2\times j$ 的末尾的 $0$ 的个数是比 $x+j$ 的 $0$ 的个数要多 $1$，所以 是从 $f_{i,j}$ 转移到 $f_{i+1,j\times2}$。

- 综上，我们就可以解法了，我们先预处理出不进行操作时的 $x+i$ 的末尾的 $0$ 的个数，然后直接转移，最后的答案就是 $f_{k,0}$，就是 $k$ 次操作之后的 $x+0$ 的末尾的 $0$ 的个数的期望值。总的时间复杂度为 $O(k\ log\ x+k^2)$。

## 代码
```cpp
#include<bits/stdc++.h>
#define fre(x) freopen(#x".in","r",stdin);freopen(#x".out","w",stdout)
#define ll long long
using namespace std;
inline int read()
{
	int x=0,f=1;char c=getchar();
	while(c<'0'||c>'9') {if(c=='-') f=-1;c=getchar();}
	while(c>='0'&&c<='9') x=(x<<3)+(x<<1)+(c^'0'),c=getchar();
	return x*f;
}
const int N=305;
int x,k;
double p,f[N][N];
int main()
{
	x=read(),k=read(),p=read();
	p/=100;
	for(int i=0;i<=k;i++)
		for(int j=x+i;!(j&1);j>>=1)
			f[0][i]++;
	for(int i=0;i<k;i++)
		for(int j=0;j<=k;j++)
		{
			if(j) f[i+1][j-1]+=(1-p)*f[i][j];
			if(j*2<=k) f[i+1][j*2]+=p*(f[i][j]+1);
		}
	printf("%.10lf\n",f[k][0]);
	return 0;
}
```
