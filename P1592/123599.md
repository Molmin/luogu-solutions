### 算法：数论$+$找规律

------------

- 我们发现，当$n=10$时，与$n$互质的数为：$1,3,7,9,11,13,17,19,......$,若将其分组：$\{1,3,7,9\},\{11,13,17,19\},......$，可以发现，每组相同位置上的数字$mod10$竟是一样的！！！
- 再举一例，当$n=12$时，与$n$互质的数为：$1,5,7,11,13,17,19,23......$,再将其分组：$\{1,5,7,11\},\{13,17,19,23\},......$，可以发现，每组相同位置上的数字$mod12$也是一样的！！！
- 经过不断地探究，我们终于发现：每组的数字个数为$\varphi(n)$(即$n$以内与$n$互质的数的个数)。
- 另外，我们还发现：若$a$与$n$互质，那么$a+n$必与$n$互质，即：若$gcd(a,n)=1$，则$gcd(a+n,n)=1$。
- 有些同学就要问了，为什么以上结论成立呢？实际上，这是用到了一个公式：$gcd(a,b)=gcd(a+b,b)$，证明如下：

------------

**证明**：设$gcd(a,b)=c$，则存在两个互质的数$m,n$，使得$mc=a,nc=b$, 则$gcd(a+b,b)=gcd((m+n)c,nc)$，由于$m$与$n$互质，则$m+n$与$n$也互质，所以$gcd(a+b,b)=c=gcd(a,b)$。

**证毕。**

------------

- 根据以上的结论，若定义$tot=\varphi(n)$，则最后的答案就为$(k-1)/tot*n+a[k\%tot]$，$a[i]$表示$n$以内第$i$个与$n$互质的数。
- 且慢，因为$a$数组是从$1$开始，然而$k\%tot$可能等于$0$，所以我们要稍微改变一下，最后答案为：$(k-1)/tot*n+a[(k-1)\%tot+1]$
- 接下来，就是代码了（~~似乎压行后有点短~~）

------------

```cpp
#include <cstdio>
using namespace std;
void in(int &n) //快读
{
		n=0;int f=1;char c=getchar();
		while (c<'0'||'9'<c){if (c=='-')f*=-1;c=getchar();}
		while ('0'<=c&&c<='9'){n=n*10+(c-'0');c=getchar();}
		n*=f;
}
int gcd(int a,int b){return a%b?gcd(b,a%b):b;} //求gcd
int a[1000005]; //定义a数组
int main()
{
		int n,k,tot=0;in(n);in(k); //定义和读入
		for (int i=1;i<=n;i++)(gcd(n,i)==1)?a[++tot]=i:0;//0是占位的
		printf ("%d",(k-1)/tot*n+a[(k-1)%tot+1]);//输出
		return 0;//这就没了
}
```
-----------
### 广告
- 推荐一下两位同学的博客：
- $1. $[azy巨佬的博客](https://www.luogu.com.cn/blog/3355406081azy/)
- $2. $[yzc巨佬的博客](https://www.luogu.com.cn/blog/ytxnqwl/)