观察样例，可以发现答案的一种构造方法：

首先显然数组的顺序不影响答案，于是先排序。

定义一个极长区间为一个不能往两端扩展的区间，例如如果选定元素为 $ [2,3,4] $ 且数组内没有 $ 1 $ 和 $ 5 $，则这些元素被称为极长区间。

一个做法是不断找出极长区间后删除，最后统计一共删除了多少次即可。

我们思考为什么这样是对的：

如果原数组中极长区间间没有公共元素则显然上述做法正确。

设原数组中有两个极长区间有公共元素，则我们可以构造出另一种方案：设两个极长区间为 $ a,b $，则可以取 $ a \cap b,a \cup b $ 为新的答案即可使得新区间不含公共元素，不难证明上面两个集合仍然是极长区间。

于是排序后每次找出仍存在的最小元素，暴力扩展极长区间，扩展的过程中删除，直到区间右端点不存在，统计这个过程执行的次数即为答案。

因为每个元素最多插入一次删除一次则总时间复杂度 $ \mathcal{O}(n\log{n}) $，来自排序的时间复杂度。

因为值域 $ 10^9 $ 可以离散化，这里用 map 实现。

代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
int a[2000020];
map<int,int>cnt;
main()
{
int T;
cin>>T;
while(T--)
{
	int n;
	cin>>n;
	cnt.clear();
	for(int i=1;i<=n;i++)
		cin>>a[i],cnt[a[i]]++;
	sort(a+1,a+n+1);
	int ans=0;
	for(int i=1;i<=n;i++)
	if(cnt[a[i]])
	{
		int now=a[i];
		while(cnt[now])
			cnt[now]--,now++;
	ans++;
	}
	cout<<ans<<'\n';
}
}
```
