有生之年，你谷终于爬到新题了（（（

---

**题意：**

给你一颗有根树，每个节点是黑色或白色，初始全为白色。

每次询问给出一个点集 $S$，把点集中的点全部染成黑色，问至少需要翻转多少个节点使整棵树全为白点，无解输出 `-1`。

翻转的定义为：将节点 $u$ 及其子树中所有节点颜色翻转。

**输入：**

第一行 $N$，$Q$ 表示节点数和询问次数；

第二行 $N-1$ 个整数 $P_i$ 表示节点 $i$ 的父节点；

之后 $Q$ 行，每行第一个整数 $M_i$ 表示点集 $S$ 大小，余下 $M_i$ 个整数 $v_{i,j}$ 表示点集 $S$。

---

**题解：**

非常显然的性质是：

- 对一个节点操作一次以上是没有意义的；

- 操作的顺序没有影响；

- 一定有解并只有一种可行方案；

好，我们可以枚举每个节点操作或不操作，时间复杂度是 $O(2^n)$。

这是暴力的解法，我们考虑正解：

首先预处理每个顶点的儿子节点数 $t$，然后对于每次询问，$ans=m_i+\sum_{j=1}^{m_i} t_{v_{j}}$，需要注意的是更改父节点是会更改子节点的状态，如果子节点也需要更改，就减去它的贡献。

```cpp
int main() {
    scanf("%d %d", &n, &q);
    for (int i = 2; i <= n; i++) {
        scanf("%d", &p[i]), t[p[i]]++;
    }
    for (int i = 1; i <= q; i++) {
        scanf("%d", &m), ans = m;
        for (int j = 1; j <= m; j++) {
            scanf("%d", &v[j]), t[p[v[j]]] -= 2;
        }
        for (int j = 1; j <= m; j++) {
            ans += t[v[j]];
        }
        for (int j = 1; j <= m; j++) {
            t[p[v[j]]] += 2;
        }
        printf("%d\n", ans);
    }
}
```