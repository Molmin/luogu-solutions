[题目](https://www.luogu.com.cn/problem/P3214)

~~出题人是觉得OIer都没学过乐理吗~~

题意：选出$m$个集合，每个集合里可以选$1-n$，问满足以下条件的方案数：

- 这$m$个集合是互不相同的且不能为空

- 所有出现过的数字在$m$个集合里总共需要出现偶数次

- $m$个集合不考虑顺序

$1\leq n,m\leq 10^6$

### 大致思路

注意到$n,m$都很大，应该是$O(n)$递推

接下来有两种方向：每一个数放到哪个集合里面/每个集合里面放哪些数

然后第一种明显不可做，因为难以保证满足限制，所以考虑第二种

### 简化题目

对于计数题来说，肯定是限制越少越容易做。然后发现第三个限制其实可以直接去掉，也就是我们考虑顺序来计数，最后再除以一个$m!$就得到不考虑顺序的方案了

第二个限制目前并不清楚，但是第一个限制很显然是要充斥的了，因为不可能记下来前面$m$个集合到底是什么

### 具体做法

设$f[i]$表示前$i$个集合里面合法的方案数

- 首先只考虑满足第二种限制的方案数

前$i-1$个集合中出现了偶数的数，在$i$集合中一定不能出现，出现了奇数次就一定要在$i$集合中出现，也就是说前$i-1$个集合是什么就决定了$i$集合是什么，并且每一个前$i-1$个集合的排列都决定了一个$i$集合

所以对应着$i$集合的方案数就是：$A(2^n-1,i-1)$

- 然后考虑减去不满足第一种限制的方案数：

空集的方案数：$f[i-1]$，也就是$i$啥都不选都能合法，那么前$i-1$就一定要合法

相同的方案数：

这里也是很常见的一个套路，直接强制让$i$与其中一个集合相同，剩下地"随便选"就行了，这些方案数都是不合法的

去掉相同的这两个集合，方案数就是$f[i-2]$，$i$能和前$i-1$个集合中的某一个集合$j$相同，$j$有$i-1$中选取方案

因为$f[i-2]$就已经让$i-2$个集合是满足第二种限制了，再加上两个相同的集合肯定也还是满足第二种限制的

所以方案数就是$f[i-2]\times (i-1)\times (2^n-1-(i-2))$

为什么后面要减掉$i-2$？不妨反过来考虑，如果没有减掉$i-2$，那么对于$j_1,j_2$就有可能会有重复的计算，因为$i,j_1$和$i-2$中的某一个相同，其中可能包括$j_2$，然后对于$j_2$来说也会计算到$j_1$，就导致了重复计算

所以总共要减掉的方案数就是：$f[i-1]+f[i-2]\times (i-1)\times (2^n-1-(i-2))$

最后递推式就为：$f[i]=A(2^n-1,i-1)-f[i-1]-f[i-2]\times (i-1)\times (2^n-1-(i-2))$

### 一些细节

- 边界$f[0]=1,f[1]=0$

考虑其意义：

前$0$个集合合法的方案数，因为什么都不能选，注意不是空集。$0$个是不能选集合，而空集是集合，所以方案数是$1$

因为第一个集合怎么选每个数都出现了奇数次，又不能选空集，所以方案数是$0$

- 计算$A(2^n-1,i-1)$

$A(2^n-1,i-1)=\dfrac{(2^n-1)!}{(2^n-i)!}=(2^n-i+1)(2^n-i+2)...(2^n-1)$

注意到$n$都是不变的，所以可以直接对每一个$i$先递推出$A(2^n-1,i-1)$

```cpp
#include <iostream>
#include <cstdio>
#define ll long long
using namespace std;
const int N=1e6+10;
const ll mod=1e8+7;
ll A[N],f[N];
inline ll power(ll a,ll b)
{
	ll res=1;
	for(;b;b>>=1,a=a*a%mod)
		if(b&1) res=res*a%mod;
	return res;
}
int main()
{
	int n,m; ll fp=1,inv=1;
	scanf("%d%d",&n,&m);
	A[0]=1,f[0]=1,f[1]=0; 
	for(int i=1;i<=n;i++) fp=fp*2%mod;
	for(int i=1;i<=m;i++) inv=inv*i%mod;
	for(int i=1;i<=m;i++) A[i]=A[i-1]*(fp-i+mod)%mod;
	for(int i=2;i<=m;i++) f[i]=((A[i-1]-f[i-1]-f[i-2]*(i-1)%mod*(fp-1-(i-2))%mod)%mod+mod)%mod;
	printf("%lld\n",f[m]*power(inv,mod-2)%mod);
	return 0;
}
```
