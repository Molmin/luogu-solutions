### [题目链接](https://www.luogu.com.cn/problem/CF802C)

第一道自己独立切掉的黑题，还是应该记录一下。

题目很好理解，相比同场比赛的前两道题（easy,medium），这道题最大的区别是每本书的**价格并不相同**，因此不是很好考虑贪心。~~因为看起来有点奇怪，~~ 所以想到了网络流（**最小费用最大流**）。

首先我们用网络流的常见套路拆出 $n$ 天，对于每天有 $n+1$ 个点，通过前 $1\sim n$ 个点的流量分别表示每种书在第 $i$ 天有几本，由于书架并不一定要装满，所以我们用通过第 $n+1$ 个点的流量表示书架**剩余的容量**。这样我们只需要保证通过每天的 $n+1$ 个点的**流量和**为 $k$ 就可以保证任何时候书架中的书都不超过 $k$ 本。

我们用 $(i,j)$ 表示第 $i$ 天的第 $j$ 个点，我们从源点向 $(0,n+1)$ 连一条容量为 $k$，费用为 $0$ 的边，这样我们就可以保证每天的流量和为 $k$。

然后我们思考如何表示在某天开始时买入某种书，某种书某天结束时是扔掉还是保留。

对于 $\forall i\in[1,n],j\in[1,n+1]$，从 $(i-1,n+1)$ 向 $(i+1,j)$ 连一条容量为 $INF$ ，费用为 $a_j$ 的边，表示在第 $i$ 天一开始的时候买入了若干这种书。

对于 $\forall i\in[1,n],j\in[1,n]$，从 $(i,j)$ 向 $(i,n+1)$ 连一条容量为 $INF$，费用为 $0$ 的边，表示这些书选择丢弃。

对于 $\forall i\in[1,n-1],j\in[1,n]$，从 $(i,j)$ 向 $(i+1,j)$ 连一条容量为 $INF$ ，费用为 $0$ 的边，表示将这些书选择保留到下一天；

接下来我们才要处理真正的问题，就是那 $n$ 个请求，如何限制第 $i$ 天时书架里有第 $c_i$ 本书，我们可以通过**最大流**来限制。

对于 $\forall i\in[1,n]$，从 $(i,c_i)$ 向汇点连一条容量为 $1$，费用为 $0$ 的边。这样我们可以保证每天都可以满足请求。

但是这时迎来了一个新的问题，第 $c_i$ 本书相当于被丢弃了，并没有被置回，这时下一天的流量和就变成了 $k-1$。

所以对于 $\forall i\in[1,n]$，从源点向 $(i,n+1)$ 容量为 $1$，费用为 $0$ 的边，来保证每一天除去从源点流向第 $n+1$ 个点和从 $c_i$ 流出到汇点的流之外，流量和是 $k$。

同时对于 $\forall i\in[1,n-1]$，从 $(i,n+1)$ 向 $(i+1,c_i)$ 连一条容量为 $1$，费用为 $0$ 的边，表示如果并没有选择丢弃，我们还可以用 $0$ 元重新让它置回书架。为什么这里不能直接从源点向 $(i+1,c_i)$ 连边，因为如果那样的话，这本书就不能选择**丢弃**了。

最后在这个网络上跑最小费用最大流的费用和就是完成 $n$ 个请求的最少价钱。

其实上述一些范围**不需要**取的这么精确，多一条边或许无所谓，但是为了严谨还是都写出来了。

```cpp
int main()
{
	cin.tie(0),cout.tie(0);
	ios::sync_with_stdio(0);
	cin>>n>>k;s=n*(n+1)+1,t=s+1;
	for(register int i=1;i<=n;++i) cin>>C[i];
	for(register int i=1;i<=n;++i) cin>>a[i];
	add(s,0,k,0),add(0,s,0,0);//s to (0,n+1) 
	for(register int i=1;i<=n;++i)
	{
        //(i,c[i]) to t
		add((i-1)*(n+1)+C[i],t,1,0);
		add(t,(i-1)*(n+1)+C[i],0,0);
        //s to (i,n+1)
		add(s,i*(n+1),1,0);
        add(i*(n+1),s,0,0);
        for(register int j=1;j<=n+1;++j)
        {
            //(i-1,n+1) to (i,j)
			add((i-1)*(n+1),(i-1)*(n+1)+j,INF,a[j]);
			add((i-1)*(n+1)+j,(i-1)*(n+1),0,-a[j]);
        }
        for(register int j=1;j<=n;++j)
        {
            //(i,j) to (i,n+1)
			add((i-1)*(n+1)+j,i*(n+1),INF,0);
			add(i*(n+1),(i-1)*(n+1)+j,0,0);
        }
        if(i==n) break;
        //(i,n+1) to (i+1,c[i])
		add(i*(n+1),i*(n+1)+C[i],1,0);
		add(i*(n+1)+C[i],i*(n+1),0,0);
        for(register int j=1;j<=n;++j)
		{
            //(i,j) to (i+1,j)
			add((i-1)*(n+1)+j,i*(n+1)+j,INF,0);
			add(i*(n+1)+j,(i-1)*(n+1)+j,0,0);
		}
	}
	while(SPFA()) cost+=dis[t]*dfs(s,INF);
	cout<<cost<<'\n';return 0;
}
```