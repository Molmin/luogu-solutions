## 前言

想暴力者，可以看看数据君： $1\le X \le 10^9,0\le K\le 9$ ，所以请靠边站，否则直接 T 飞。

## 思路

我们知道不能暴力枚举每个数，但是我们换个角度思考一下，不暴力枚举每个数，可以枚举数位啊，再看一看数据，我们发现，如果枚举每个数位，最多只到 $9$ 位，时间肯定是允许的，所以我们先把 $X$ 拆分，但是得到的是从个位开始，一直到最高位的数字，换句话说，它是原输入的倒序，所以我们拆分时用一个数组把答案记好，然后在倒序排列，这样就是正序了，我们知道，题目要求我们后 $K$ 位都要是 $0$ 那我们就把这些位都预留出来，直接枚举总位数减去后 $K$ 位所得到的位数，但是我们是倒序循环的，所以我们在循环时再加一个变脸限制，在循环时，我们把不用变为 $0$ 的位数上的数存到 $sum$ 变量中，实现就是：

```cpp
sum = sum * 10 + a[i];
```

由于我们得到的答案必须要比 $X$ 大，所以我们输出时需要加个一，然后我们再把 $K$ 位 $0$ 补上。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 15;  //由于是在搞数位，所以开到10以上就好了
int x, k;
int cnt;
int sum;
int a[N];
int main() {
  cin >> x >> k;
  while (x > 0) {
    a[++cnt] = x % 10;  //取出每位数
    x /= 10;
  }
  int tmp = cnt - k;
  for (int i = cnt, s = 1; i >= 1 && s <= tmp; i--, s++) {  //把除了后k位的数都存入sum变量中
    sum = sum * 10 + a[i];
  }
  cout << sum + 1;                //必须要大写，所以+1
  for (int i = 1; i <= k; i++) {  //补上后k位
    cout << "0";
  }
  return 0;
}
```
