# 生成树 AC
### 照样排坑
- 其实没啥坑，，注意数组范围就好
- 边的条数不是点的个数，所以求边的数组要开到

[数组开小了就这样了(我一开始边的条数是点的个数)](https://www.luogu.org/recordnew/show/16243026)

### 方法


------------
	
#### 小优化：
求两点之间距离是
```cpp
sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2))
```
我们可以不进行开根处理，反而将猴子跳跃的距离平方，其结果是相同的，直接去掉开根，使边的长度便于存储和计算

------------

#### 然后正式讲说一下怎么做的
- 先输入猴子数量以及每只猴子能跳多远
- 对每只猴子的跳跃距离进行平方处理
- 输入每个点
- 每两个点之间建立一条边(每条边的长度是两点的距离的平方)(因为只是最小生成树问题，所以[i][j]与[j][i]是一样的，只建立一条边就够了)
- 将所有边从小到大排序
- 判断每条边两点是否在一棵树上，如果不在就将两个点合并，如果在就不用管
- 如果所有点都已经在树上了就退出输出树中最大的边(因为排过序所以最大的边就是最后进入树的边)
- 对所有的猴子跳过的距离进行比较
- 输出
### 具体AC代码
[具体AC情况](https://www.luogu.org/recordnew/show/16243288)
```cpp
#include<bits/stdc++.h>//头文件
using namespace std;
int n,m,q=0;
int o[501];
int f[1001];
int d[1001][1001];
struct point{//记录点的横纵坐标
    int x,y;
} h[1001];
struct edge{//记录边的开始(s)结束(e)长度(w)
    int s,e,w;
} g[1001000];
int cmd(edge a,edge b){return a.w<b.w;}//按边的长短从小到大排序
int find(int s){if(f[s]==s||f[s]==0)return f[s]=s;//如果这个点没有加入任何一棵树(f[s]==0)或者这个点的树是自己(f[s]==s)，那么这个点的树是它自己
else return f[s]=find(f[s]);}//如果这个点已经加入一个树了，那么输出这个树的树根
int k(){//最小生成树函数
    int cnt=0;//记录树上已经有几条边
    for(int i=1;i<=q;i++){//每条边都进行判断
        int x=find(g[i].s);//看看起点在哪棵树上
        int y=find(g[i].e);//看看终点在哪棵树上
        if(x!=y){//如果起点终点不在同一棵树上
            f[x]=y;//合并成为一棵树
            if(++cnt>=m-1)return g[i].w;//如果合并后边的个数是点的个数减一那么代表所有点都在树上了，返回最后一条加入的边的长度(因为排过序，所以一定是最长的)
        }
    }
}
int main(){
    cin>>n;
    for(int i=1;i<=n;i++){
        cin>>o[i];
        o[i]=o[i]*o[i];//对每个猴子的跳跃距离进行平方处理
    }
    cin>>m;
    for(int i=1;i<=m;i++){//输入点的坐标
        cin>>h[i].x>>h[i].y;
    }
    for(int i=1;i<=m;i++){//每两个点行程一条边
        for(int j=1;j<=m;j++){
            if(i>=j)continue;//因为是生成树所以点的顺序方向没有要求(例：[1][2]和[2][1]没有区别所以可以去掉一条边)
            int u=(h[i].x-h[j].x)*(h[i].x-h[j].x)+(h[i].y-h[j].y)*(h[i].y-h[j].y);//两点距离的平方方便运算不开根
            if(u!=0)g[++q]=(edge){i,j,u};//记录边的起始和结束以及距离
        }
    }
    sort(g+1,g+1+q,cmd);//从小到大排序
    int p=k();//进入最小生成树函数
    int t=0;
    for(int i=1;i<=n;i++){
        if(o[i]>=p)t++;
    }
    cout<<t;
    return 0;
}
```
感谢大家能看我的题解！