这一题结论好题。

----

显然，不可能使用暴力，因为最多循环次数为 $s^{2}$，
而![](https://cdn.luogu.com.cn/upload/image_hosting/oyqa1zib.png)。

~~（暴力党：放弃）~~

那正解是什么呢？

### 猜想

可以发现，`ABC`中真正可以重复用的只有`A`和`BC`，单独的`B`和`C`与不是`ABC`字串的`CB`直接略去。

而像这样：`AABC`，经过一次转换后变为`ABCA`,还能转换一次！

所以只要发现一个`ABC`，就判断之前的字符是不是`A`,因为转换后`ABC`中的`AB`就变成了`BC`，如果之前是`A`，又能重新组合。

但走回头路显然没有直接一次循环好，正解就来了！

先用数据说话：

`AAABCBC`

第一次转换：

`AABCABC` 

我们发现了最后一个做出了一个贡献，并且前面的`A`也及时的搭配上，这就是理想组合！后面也多出了一个`A`与后面的搭配！

### 做法

先遍历一遍字串，如果找到连续的`A`，那么看后面，如果后面是`BC`，那么之前有多少个`A`就加多少的方案数，否则重新计数，周而复始。

### 验证

为保证正确性，我们再手算一组数据。
数据：

```
AAABCCAAB
```
1. 找到第一组连续的`A`，并且后面是`BC`，方案数加上`A`的个数，即`sum+=3`。
2. 到第二个`C`的时候，由于后面接不上，计算连续`A`数量的变量归零。
3. 找到第二组连续的`A` ，但后面不是`BC`，不算，计算连续`A`个数的变量归零。
4. 最后输出 $sum$。

注意：开`long long`！不然会错！

用这种方法，先编码，后对照程序修改！

### 代码

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
signed main()
{
	string s;
	cin>>s;
	int sum=0;//方案数
	int tot=0;//计算连续A的个数 
	for(int i=0;i<s.size();i++)
	{
		if(s[i]=='A')
			tot++;
		else
			if(s[i]=='B')//有B
			{
				if(i+1<s.size()&&s[i+1]=='C')//有BC并且下标不越界
				{
					sum+=tot;
					i++;//下表顺延 
				}
				else tot=0;//后面顺延不了，归零 
			} 
			else//没有操作
				tot=0;
	} 
	cout<<sum<<endl;
	return 0;
}


```

完结，点个赞呗~~