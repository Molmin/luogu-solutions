> 伟大中蕴含着简洁。

#### _2020/03/01_

作为一名初中 OIer，第一眼看不明白这句话：

> **连续曲线反射规律** : 入射光线与出射光线关于入射点在曲线上切线夹角相等。

但不管怎样，我至少学过光的反射定律：

> 反射光线、入射光线与法线在同一平面上；反射光线和入射光线分居在法线的两侧；反射角等于入射角。

~~你谷甚可论物理。~~

这是一张光的反射示意图：

![图片有点糊见谅](https://cdn.luogu.com.cn/upload/image_hosting/4pjp97ie.png)

既然光图有美感，那么它的本质——光的反射——也会有美感：对称！

反射光线与入射光线关于法线对称。

那么，在光图中截取两次连续的反射（这里直接用题面的图）：

![](https://cdn.luogu.com.cn/upload/image_hosting/x7j0roeg.png)

想象出反射面，它垂直于入射点与圆心的连线（一条半径）。再结合圆的轴对称性，可知，这个光图也是对称的。那么对应的圆弧长也相等。所以反射一次“越过”的弧长为定值。

把握反射的含义，这个题目可以理解成：

把 $N$ 个点围成一个圈，逆时针标号 $A_0$，$A_1$，$A_2$，$\cdots$，$A_{n-1}$。从 $A_0$ 开始，逆时针通过 $p$ 个点，重复 $k$ 次后到达一个点 $A_t$，求 $t$ 的值。

可以模拟走一遍。一个变量 `x` 记录当前点的坐标，重复 $k$ 次更新 `x`，大致这样写：

```cpp
	int x=0;
	for(int i=1; i<=k; i++)
		x = (x+p)%n ;
```

当然，$k$ 最大为 $10^9$，这样可能会超时。其实无需加一次就取模，全部加起来再取模能得到同样的效果。$k$ 个 $p$ 相加，相当于 $k\cdot p$，省一层循环。

最后注意数据范围，开一下 `unsigned long long` 就结束了：

```cpp
#include <bits/stdc++.h>
using namespace std;
unsigned long long n, p, k;
int main(){
	cin >> n >> p >> k;
	cout << (p*k)%n << endl; 
	return 0;
}
```

End.
