首先 $O(n^2m)$的作法是 naive 的，对于所有 $(i,v)$ 暴力地枚举（共有 $O(nm)$ 种）并 $O(n)$ 地暴力模拟。可以获得 16分。

从直觉上来看，似乎这么多方案中，其中有很多种最后的结果都是完全相同的，如果手动模拟一下的话就会发现确实如此。我们做了很多多余的工作。

那么哪些方案一定会有相同的结果呢？对于 $(i,v)$ 这个二元组，每个方案的变量有“kill 谁“ 和 “什么时候kill“ 。

其中对"kill 谁"的讨论似乎不能够减少我们的方案数。但是一旦我们确定了要杀谁，早杀还是后杀，在某些情况下似乎是一样的。

我们具体的分析，对于 $(i,v)$ 和 $(i + 1,v)$，容易知道如果 $v \neq a_i$ 并且 $v \neq b_i$，这两种方案是不会有任何不同的~~三体进攻致远星不会影响地球上法国投降~~

其次，对于原本就无效的追杀（我们定义追杀 $i$ 是无效的当且仅当 $a_i$ 或 $b_i$ 在第 $i$ 次追杀时已经公认死亡），这两种方案肯定也不会有任何区别~~攻击前摇与攻击后摇~~。

对于 $v = b_i$ ，这两种方案其实同样也不会有任何影响。~~无非就是 $b_i$ 先被谁捅一刀，人头归谁~~。（如果想不清楚的话可以简单分类讨论一下。实在无法理解的话，这个优化不要也罢。）

那么只剩下 $v = a_i$ 的情况需要讨论了。乍一看似乎是 $O(n)$ 的，但是我们之前提到过，无效的追杀是不予考虑的。那么有多少次有效的追杀呢？

我们从整体分析这个问题，因为每次有效的追杀都会导致某位受害者死一次，而每个人最多死 3 次，因此至多有 $3m$ 次有效的追杀。

~~观察数据范围可得，~~ 我们可以对每个 $(i, a_i)$ 进行 $O(n)$ 的模拟，复杂度是 $O(nm)$ 的。对于其他的 $(i, v)_{v \ne a_i}$  直接沿用 $(i + 1, v)$ 

（当然首先你得算出某一时刻所有的 $(i, v)$，这也是 $O(nm)$ 的）。

另外有个小优化，其实只需考虑 $v = a_i$， 并且此时 $a_i$ 只有一条命的情况。感性理解一下，只有在这种情况下才能以暴制暴，阻止悲剧发生。其他情况~~也依然只是内卷看谁先背刺谁~~。当然复杂度还是不变的。

Code:
```cpp
#include<algorithm>
#include<cstdio>
#include<cstring>
#include<iostream>
#include<queue>
#include<vector>
using namespace std;
int n, m;
int f[1007], lf[1007], cnt[1007], drill[1007];
int a[60007], b[60007];
//提醒一下O(nm)的空间复杂度是会爆炸的
inline int calc() {
    drill[0] = 0;
    for(int i = 1; i <= m; ++i) {
        if(drill[i] > 0) ++drill[0];
    }
    return drill[0];
}
signed main() {
    scanf("%d %d", &n, &m);
    for(int i = 1; i <= m; ++i) lf[i] = 3;
    //这里我算出了所有的 (n + 1, v)
    //其实算出(1, v)会更加方便，别的题解貌似采用的是(1, v)写法。
    for(int i = 1; i <= n; ++i) {
        scanf("%d %d", a + i, b + i);
        if(a[i] == b[i] || lf[a[i]] > 0) lf[b[i]]--;
        //为了后面还原方便采用了这种与题面等效（但实现不同）的判断条件
    }
    for(int i = 1; i <= m; ++i) {
        if(lf[i] > 0) ++f[0];
    }
    for(int i = 1; i <= m; ++i) {
        if(lf[i] == 1) f[i] = f[0] - 1;
        else f[i] = f[0];
        cnt[f[i]]++;
    }
    for(int i = n; i; --i) {
        if(a[i] == b[i] || lf[a[i]] > 0) lf[b[i]]++;
        //如果直接模拟，判断b[i]何时“复活”需要额外记录
        for(int j = 1; j <= m; ++j) {
            if(j != a[i] || lf[a[i]] != 1 || lf[b[i]] <= 0) {cnt[f[j]]++; continue;}
            //三个优化，尤其是第一个和第三个不能少
            memcpy(drill, lf, sizeof(lf)); //防止干扰
            drill[a[i]]--;
            for(int k = i; k <= n; ++k) {
                if(a[k] == b[k] || drill[a[k]] > 0) --drill[b[k]];
            } //暴力模拟
            cnt[f[j] = calc()]++;
        }
    }
    for(int i = 0; i <= m; ++i) printf("%d ", cnt[i]);
    putchar('\n');
    return 0;
}

```
