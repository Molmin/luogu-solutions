## 分析

我们可以先用一个二维的字符数组来存储这个表示天气状况的矩阵，再用双重循环枚举矩阵上的每一个字符，从后往前枚举它本身以及在它前面的每一个字符，如果其中有一个或多个字符是 `c`，则输出最近的那个到它的距离（如果是它本身则输出 $0$），若没有则输出 $-1$。但有一点需要特别注意，就是去掉行末空格，所以，我们可以做一些处理：如果在双重循环枚举时，枚举到的数是在第一列，则直接输出结果；否则，在输出结果之前，先输出一个空格。

程序代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
char mapp[110][110];//创建二维数组来存储矩阵
int main()
{
	int h,w;
	cin>>h>>w;
    for (int i=1;i<=h;i++)//输入整个矩阵
	{
		for (int j=1;j<=w;j++)
		{
			cin>>mapp[i][j];
		}
	}
	for (int i=1;i<=h;i++)//用双重循环枚举矩阵中的每一个元素
	{
		for (int j=1;j<=w;j++)
		{
			if (j>1)//如果枚举到的元素不是在第1列
			{
				cout<<" ";//则先输出空格
			}
			int sum=0;//计数变量清零
			bool flag=0;//标记变量，用来标记这个元素及它前面有没有c
			for (int k=j;k>=1;k--)//从j枚举到1（需要先枚举它本身）
			{
				if (mapp[i][k]=='c')//如果这个字符是c
				{
					cout<<sum;//输出它们之间的距离
					flag=1;//标记一下，表示已经出现过c
					break;//退出循环
				}
				else
				{
                    sum++;//否则计数变量+1
				}
			}
			if (flag==0)//如果在循环结束后，都没有出现过c
			{
				cout<<-1;//则输出-1
			}
		}
		cout<<endl;//注意换行
	}
	return 0;
}
```