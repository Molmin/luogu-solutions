## Content
给定一个 **十六进制颜色码**（一个长度为 $7$ 的字符串，意义详见题面），请输出其反色的十六进制颜色码。

**数据范围：颜色的 R,G,B 值保证在 $255$ 以内。**
## Solution
我们不妨设给定的两个特殊的限制为 Subtask 1 和 Subtask 2，其余的数据分为 Subtask 3。然后我们来按照三个 Subtask 分别讲解。
### Subtask 1
这个对于萌新来说都很容易上手，直接输出 `#000000` 即可。
### Subtask 2&3
开始之前我们有必要讲一讲十六进制。当然如果对此很熟悉的话可以跳过去。

正如题面所说，十六进制数码从小到大包括 $\textsf{0,1,2,3,4,5,6,7,8,9,A,B,C,D,E,F}$ 十六个数码，正如其名，这样的数字 **满十六进一**，而不像我们通常所用的十进制一样 **满十进一**，而又因为没有这么多的数字可以存十六进制数码，因此借用了字母表中的大写字母。

那么如何将十六进制转换成十进制呢？我们知道，十六进制的数 **满十六进一**，那么我们如果进了一，这一位上面的十六个单位全部转化为了它前面这一位上的一个单位。所以，我们不妨假设最低位为第 $0$ 位，那么一个十六进制数第 $i$ 位上的数字就可以转化为 $num_i\times16^i$。那么，十进制转换成十六进制的话也就很简单了，直接从大到小提取出一个数乘以 $16$ 的次幂，最后拼合在一起就好。

这么说可能不是很友好，我就拿样例 $2$ 来具体操作一番吧。

```
input:
#EBA932
output:
#1456CD
```

然后我们来看如何操作：

首先是 R 值。提取出来的话就是 $\text{EB}$，然后我们清楚，$\text{E}$ 代表 $14$，$\text{B}$ 代表 $11$，所以 $(\text{EB})_{16}=14\times16^1+12\times16^0=14\times16+12=235$。然后他的反色就是 $255-235=20$。所以我们提取出 $1\times16$ 的 $1$ 次幂和 $4\times 16$ 的 $0$ 次幂，那么最终的 R 值就是 $14$。

G 值和 B 值的操作同上，想必无需多讲了。

那么对于 Subtask 2，我们的任务就很简单，直接将十六进制数字转化成十进制数字连特判字母都不需要，然后再根据题目里面给出的式子，我们拿这个数去减 $255$，得到的就是反色的十进制数码。Subtask 3 就需要特判一下是不是字母了。然后我们再把十进制的反色数码转换成十六进制的就好了。而且特别良心的是，这里的数字都只有两位，所以特别好直接模拟操作。

---

所以说这道题目就做完了

……吗？

虽然说问题不大，但是从十六进制转到十进制再转回十六进制是不是太麻烦了？

能否直接十六进制之间互相转换呢？

也就是说，相当于一个，**十六进制减法**之类的东西？

我们再来看看，我们可以自己手玩一下，发现 $(255)_{10}=(\text{FF})_{16}$。那么不就可以弄个减法直接减一下就好了？而且可以很惊喜的发现，这减法居然还不需要考虑退位！那么对于每个数位直接拿 $15$（$\text{F}$ 代表 $15$）减去这个数码就好了。

最后给刚学 OI 的萌新们弄个温馨提示：C++ 里面是可以直接给一个变量赋值为一个十六进制数的，方法是在这个十六进制数之前加一个 $\textsf{0x}$，然后所有在这道题目里面大写的字母全部都要转化为小写。还给你们几个数，用来以后初始化最小值用的：$\textsf{0x3f3f3f3f},\textsf{0x7fffffff}$，这种类型的数将会伴随着你们整个 OI 生涯，直到 AFO（Away from OI，也就是退役）。当然，至少对于快要 AFO 的我是这样子的。

最后，祝各位 NOIP2020 RP++！
## Code 1
赛时代码，使用了 map 来映射，各位也可以尝试不使用 map 来实现这种做法。

```cpp
const string ans = "0123456789ABCDEF";
string s;
map<char, int> mp;

int main() {
	for(int i = 0; i < 16; ++i) mp[ans[i]] = i;
	cin >> s;
	int r1 = mp[s[1]] * 16 + mp[s[2]], r2 = mp[s[3]] * 16 + mp[s[4]], r3 = mp[s[5]] * 16 + mp[s[6]];
	int g1 = 255 - r1, g2 = 255 - r2, g3 = 255 - r3;
	printf("#%c%c%c%c%c%c", ans[g1 / 16], ans[g1 % 16], ans[g2 / 16], ans[g2 % 16], ans[g3 / 16], ans[g3 % 16]);
	return 0;
}

```
## Code 2
怕各位看不懂这么长的一大串三目运算符，特地在下面写了等效语句，并附上详尽注释。
```cpp
string s;

int main() {
	cin >> s;
	F(i, 0, 6) putchar(i == 0 ? '#' : (isdigit(s[i]) ? (s[i] - '0' <= 5 ? 'A' + (5 - (s[i] - '0')) : 15 - (s[i] - '0') + '0') : 5 - (s[i] - 'A') + '0'));
	//以下为等效语句 
	F(i, 0, 6) {
		if(i == 0) putchar('#');	//第一位要输出# 
		else if(isdigit(s[i])) {	//判断是否是数字，可以直接调用isdigit函数 
			if(s[i] <= '5') putchar('A' + (5 - (s[i] - '0')));	//如果数字小于等于5，那么反色数码肯定是一个字母，所以需要特判一下
			/*
				我们发现，这个数码比 0 差多少，反色数码比 A 就要多多少 
				所以直接加上这个差值即可 
			*/ 
			else putchar(15 - (s[i] - '0') + '0'); 	//直接拿这个数去减 15 然后再转化为字符 
		} else putchar(5 - (s[i] - 'A') + '0');		//否则肯定会是一个大写字母
		/*
			我们发现，这个数码比 A 差多少，反色数码比 0 就要多多少 
			所以直接加上这个差值即可 
		*/
	}
	return 0;
}
```

都看到这里了，点个赞再走呗qwq。