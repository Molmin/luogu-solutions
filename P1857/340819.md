# P1857
## [题目传送门](https://www.luogu.com.cn/problem/P1857)   
## 题意简述
题面很清晰，就不复述了，那么我们直接开始分析题目。  
## 题目分析
题面要求，每次取掉的数都是质数，那么我们先不想什么，写一个质数筛。因为我懒，所以写了个暴力遍历判断的筛，当然也可以写欧拉筛。
```cpp
for(int i=2;i<=20000;i++)
{
	tot++;
	p[tot]=i;//p是素数列表
	for(int j=2;j*j<=i;j++)
	{
		if(i%j==0)
		{
			tot--;
			break;
		}
	}
}
```
那么接下来，我们再看一下题，很明显，这道题应该要把每个 $Q_i$ 的答案给预处理出来。那么对于每一个数，它最重要的性质就是在该点时先手是否必赢。  
如果一个值先手必赢，也就意味着它可以通过取掉一堆石子后，让后一个人面对剩余的局势时必输，而必赢的最小步数就是在对面必输的所有可能中，对面可以拖延的所有最长步数取 $\min$（有点绕，建议多读反复理解，因为这挺关键的）。  
必然地，我们也要考虑必输性质。对于每一个值取先手，如果无论怎么取，下一个人都是必赢，那这个人就必输了。而必输情况下的最大可拖延步数，就是所有取法中对面最短步数的 $\max$。  
到这里，我们就可以写代码了，对每一个值维护两个 $dp$ 值，一个是必输最大步数，一个是必赢最小步数，如果不必输或不必赢，就放个 $-1$ 进去。  
初始化时把 $0$ 和 $1$ 手打上去，再 $dp$ 就可以了。   
没了，上代码。
```cpp
#include<bits/stdc++.h>
using namespace std;
int lose[200003],win[200003],n,x,tot,p[200003];
int main()
{
	for(int i=2;i<=20000;i++)
	{
		tot++;
		p[tot]=i;
		for(int j=2;j*j<=i;j++)
		{
			if(i%j==0)
			{
				tot--;
				break;
			}
		}
	}
	lose[0]=0;
	win[0]=-1;
	lose[1]=0;
	win[1]=-1;
	for(int i=2;i<=20000;i++)
	{
		for(int j=1;j<=tot&&p[j]<=i;j++)
		{
			if(win[i-p[j]]==-1)
			{
				lose[i]=-1;
				break;
			}
			lose[i]=max(lose[i],win[i-p[j]]+1);
		}
		win[i]=-1;
		for(int j=1;j<=tot&&p[j]<=i;j++)
		{
			if(lose[i-p[j]]!=-1)
			{
				win[i]=214748364;
				break;
			}
		}
		if(win[i]==214748364)
		{
			for(int j=1;j<=tot&&p[j]<=i;j++)
			{
				if(lose[i-p[j]]!=-1)
				{
					win[i]=min(win[i],lose[i-p[j]]+1);
				}
			}
		}
	}
	scanf("%d",&n);
	while(n--)
	{
		scanf("%d",&x);
		printf("%d\n",win[x]);
	}
	return 0;
}
```
