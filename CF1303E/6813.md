一道谔题。

字符串 $t$ 是由 $s$ 的两个子序列拼接起来的。我们可以枚举这个分隔点 $p$，然后检验 $t(1,p)$ 和 $t(p+1,|t|)$ 是否能从 $s$ 中分离出来。

设布尔变量 $f_{i,j,k}$ 表示当前匹配完 $s$ 的前 $i$ 个字符，两部分子序列**能否**分别匹配 $j$ 个字符和 $k$ 个字符。

有三个转移：

1. 第 $i$ 个字符不匹配，则 $f_{i,j,k}=f_{i-1,j,k}$。
2. 第 $i$ 个字符匹配第一个子序列。则 $f_{i,j,k}=f_{i-1,j-1,k}$。需要满足 $s_i=t_{j}$。
3. 第 $i$ 个字符匹配第二个子序列。则 $f_{i,j,k}=f_{i-1,j,k-1}$。需要满足 $s_i=t_{p+k-1}$。

多个转移取 or 的值。

边界 $f_{0,0,0}=1$。

这是一个 $O(n^3)$ 的 dp，加上外层的枚举，时间复杂度为 $O(n^4)$，不能通过。

由于 dp 转移时使用的都是布尔运算，可以自然地想到尝试使用 bitset 进行优化。

首先这个 dp 的第一维可以滚掉。

然后令 $b_i$ 为一个大小为 $|t|$ 的 bitset，$b_{i,j}$ 的含义和 $f_{\star,i,j}$ 相同。

我们分别考虑上面的三个转移。

1. 第 $i$ 个字符不匹配。则 $b_i=b_i$。
2. 第 $i$ 个字符匹配第一个子序列。则 $b_i=b_{i-1}$。
3. 第 $i$ 个字符匹配第二个子序列。我们考虑再用一个大小为 $|t|$ 的 bitset $d$，其中 $d_i$ 为 $1$ 就表示 $t(p+1,|t|)$ 的第 $i+1$ 个字符能与当前考虑的 $s$ 中的这个字符匹配。  
不难发现，我们转移需要满足 $b_{i,j-1}=1$ 且 $d_{j-1}=1$，那么所有可以往后转移的位置，就是 $b_i\ \&\ d$ 中为 $1$ 的位置。  
我们也不难得出此时的转移为 $b_i=(b_i\ \&\ d)\lt\lt1$。

多个转移取 or 的值，这里直接用 bitset 进行按位或即可。

对枚举的每个位置 $p$，我们只要检查 $b_{p,|t|-p}$ 是否为 $1$ 即可。

时间复杂度 $O(\frac{n^4}{\omega})$，可以通过。