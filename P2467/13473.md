想了好久...姑且算是自己做出来了吧

dp状态比较容易想到： _dp[i][j]_ 表示用前i个数字，存在j个不合法段的方案数。

例如：1 2 3    有1个不合法段

1 2 3 4 5 有3个不合法段

1 2 3 6 5 4 有3个不合法段（1 2 3 6算两个，6 5 4算一个）

那么转移分三种：1.合法->合法，2.合法->不合法，3.不合法->合法

（大家操作一下会发现不合法->不合法是不存在的）

大力观察了一下，转移1每次都有两个位置可以放新数字（手玩一下！），转移3可取位置数就是 _dp[i][j]_ 中的j，剩下的位置就是转移2的位置。

~~啊啦啊啦，马上就上大学了好快乐呀~~




```cpp
//luogu P2467 [SDOI2010]地精部落
#include<bits/stdc++.h>
#define LL long long
using namespace std;
const int mxn=4205;
LL dp[mxn][mxn]; //前i个数字，有j个不合法段的方案数 
int main()
{
	int n,p;
	scanf("%d%d",&n,&p);
	dp[3][0]=4,dp[3][1]=2;
	for(int i=4;i<=n;i++)
	  for(int j=0;j<=i-2;j++)
	  {
	  	  dp[i][j]=(dp[i][j]+2*dp[i-1][j])%p;  //合法变合法
		  dp[i][j]=(dp[i][j]+dp[i-1][j+1]*(j+1))%p; //不合法变合法 
		  if(j) dp[i][j]=(dp[i][j]+dp[i-1][j-1]*(i-j-1))%p; //合法变不合法 
	  }
	printf("%lld\n",dp[n][0]);
	return 0;
}
```