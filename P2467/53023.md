# 题意：
求有多少$1--n$的排列$a$满足对于任意$a_i$

要么$a_{i+1}>a_i\&\&a_i<a_{i-1}$

要么$a_{i+1}<a_i\&\&a_{i}>a_{a-1}$

# $solution:$
假设题目的问题不是对于一个排列而是对于一个元素可以重复的数组来说的话。

我们考虑$dp[i][j][0/1]$表示在第$i$个位置，上一项的数字是$j$,上一项数字是否大于它的前面一项的方案数。

转移就是

$dp[i][j][0]=\sum_{x=j+1}^{n} dp[i-1][x][1]$

$dp[i][j][1]=\sum_{x=1}^{j-1}dp[i-1][x][0]$

但现在的问题是对于一个排列来讲的，那么上述转移必然会产生一些重复的数字。

我们考虑一个类似于离散化的操作。每个数只代表着它在当前区间的**排名**。

那么对于我们往区间后面插入一个数，带来的影响就是把原本比它大的数的排名$+1$，而比它小的数排名不变。

比如说我们原来的排名数列是$\{5,3,4,2,1\}$

我们插入了一个原本大小在第二大到第三大之间的数

那么我们得到的排名数列是$\{6,4,5,2,1,3\}$

并且我们发现，进行一次这样的改变是**不会影响**到原来的约束条件的。就是说原来为山峰的依旧是山峰，山谷的依旧是山谷。

我们利用这样的一种方法进行转移的话就可以去除数字重复的影响了。

我们枚举后面插入的数在数列中的排名，就可以$O(n^2)$转移了

转移方程

$dp[i][j][0]=\sum_{x=j}^{i-1} dp[i-1][x][1]$

$dp[i][j][1]=\sum_{x=1}^{j-1}dp[i-1][x][0]$

然后因为本题卡空间，$dp$用滚动数组记录

滚动数组就是在进行
$dp[i][j][0/1]$的转移时，我们发现$dp[i][j][0/1]$是只和$dp[i-1][j][0/1]$有关的。所以我们只需要存前一项和当前项就好了。

# $code$
```cpp
#include<bits/stdc++.h>
using namespace std;
#define maxn 4208
#define int long long
bool vis[maxn];
int dp[2][maxn][2];
int sum[2][maxn][2];
int n,mod;
int ans=0;
/*
比我小的排名都不变
比我大的排名都+1
*/
signed main(){
    scanf("%lld%lld",&n,&mod);
    if(n==1){
        cout<<1%mod<<endl;
        return 0;
    }
    dp[1][1][1]=1;
    dp[1][1][0]=1;
    sum[1][1][0]=1;
    sum[1][1][1]=1;
    for(int i=2;i<=n;i++){
        for(int j=1;j<=i;j++){
            int now=i&1,last=!now;
            (dp[now][j][0]=(sum[last][i-1][1]-sum[last][j-1][1]+mod))%=mod;
            (dp[now][j][1]=sum[last][j-1][0])%=mod;
            (sum[now][j][0]=sum[now][j-1][0]+dp[now][j][0])%=mod;
            (sum[now][j][1]=sum[now][j-1][1]+dp[now][j][1])%=mod;
        }
    }
    cout<<(sum[n&1][n][1]+sum[n&1][n][0])%mod<<endl;
    return 0;
}
```