翻了一翻题解，发现没有人用**组合数**之类的东西做这题，所以决定发一份题解。

这题因为要求出波动山脉的数量，所以应该不难看出是**DP**(不得不说这题的正解实在是太神了)，然而我一眼看下去总觉得是跟数论中的**组合数**有关，所以就有了这份**组合数加DP**奇怪的题解。

首先把波动山峰分成两种类型，一种第一位为山峰，一种第一位为山谷，分别表示为f[i][1]和f[i][0]。f[i][0]表示长度为i的波动山脉数量，第一位为山峰，f[i][1]表示长度为i的波动山脉数量，第一位为山谷。

不难得出在一段波动山脉中，如果**不考虑山峰和山谷**的限制，可以按照最大的那个数分成两段，一段的方案数和另一段的方案数的乘积再乘以组合数就是最大的数在某个位置时的方案数，再暴力枚举最大的数所在的位置，将所有方案数加起来，就是最大数确定时的总方案数。具体代码可以写成这样：

```cpp
for(int i=1;i<=n;i++)//f[i]表示长度为i的波动山脉数量
	for(int j=0;j<=i-1;j++)//j暴力枚举最大数的位置
		f[i]+=f[j]*f[i-1-j]*C[i-1][j];//C[i-1][j]表示i-1个数中取j个
```

这是显然成立的，所以接下来就是要将山峰和山谷考虑进去。

假设我们知道一段波动山脉的长度和第一位的状态(为山峰或山谷)，那么我们就不难得出最后一位的状态，同样倒过来也成立，所以一开始的分类就起了关键的作用。当**最大的数放在偶数位后**时，它前面的一段山峰数为偶数，又因为最大的数前的一定是山谷，所以前面的山脉的开头就一定是山峰，后面的山脉开头显然是山谷，所以就可以得到一个正确的转移方程：

```
if(j%2==0)f[i][1]+=f[j][1]*f[i-1-j][0]*C[i-1][j];
```

同理就可以得出另外一个**j为奇数**时的转移方程：

```
if(j&1)f[i][0]+=f[j][0]*f[i-1-j][0]*C[i-1][j];
```

接下来就不难打出能够AC的代码了。

```
cin>>n>>p;
f[1][1]=1;f[1][0]=1;f[0][1]=1;f[0][0]=1;
c[0][0]=1;//杨辉三角求组合数，听说用EX卢卡斯好像也可以过
for(int i=1;i<=n;i++){
	c[i][0]=1;
	for(int j=1;j<=i;j++)c[i][j]=(c[i-1][j-1]+c[i-1][j])%p;
}
for(int i=2;i<=n;i++){
	for(int j=0;j<=i-1;j++){//转移方程
		if(j&1)f[i][1]=(f[i][1]+(long long)c[i-1][j]*f[j][1]%p*f[i-1-j][0])%p;
		else   f[i][0]=(f[i][0]+(long long)c[i-1][j]*f[j][0]%p*f[i-1-j][0])%p;
	}
}
cout<<(f[n][0]+f[n][1])%p<<endl;
```

其实题解到这里已经好了，但是看了别的题解后我意识到了可以对这份代码进行优化。
因为波动山脉的对称性(即山峰和山谷的位置变化)，简单的说山峰开头的方案数和山谷开头的方案数是一样的，这一应该也不难得出，所以f[i][0]其实就是f[i][1]，所以可以将方程合并，就有了一下这份代码：

```
for(int i=2;i<=n;i++)
	for(int j=0;j<=i-1;j++)
		if(j&1)f[i]=(f[i]+(long long)c[i-1][j]*f[j]%p*f[i-1-j])%p;
```

然后因为bzoj上会MLE，所以对杨辉三角进行**滚动数组**优化，可以大大的减小空间，然后就有了以下代码：

```
#include<iostream>
#include<cstdio>
using namespace std;

int n,p,f[5000],c[2][5000];

int main(){
    ios::sync_with_stdio(false);
    cin>>n>>p;
    f[0]=1;f[1]=1;
    c[0][0]=1;
    c[1][0]=1;c[1][1]=1;
    for(int i=2;i<=n;i++){
    	for(int j=1;j<=i;j++)c[i&1][j]=(c[i&1^1][j-1]+c[i&1^1][j])%p;
        for(int j=0;j<=i-1;j++){
            if(j&1){
                f[i]=(f[i]+(long long)c[i&1^1][j]*f[j]%p*f[i-1-j])%p;
            }
        }
    }
    cout<<f[n]*2%p<<endl;
    return 0;
}
```