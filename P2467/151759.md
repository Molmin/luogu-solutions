写在前面：学dp不久，感觉自己dp掌握的不熟，同学就安利了这题，晚22:30开始想，0:30才通过；本题解希望尽量降低读者的理解难度（看了前面的一些题解感觉理解难度并不低），也算是希望与各位共同学习吧～


一开始方向错了，大概过了快1小时才写出正确的状态转移方程，下面写出完整的思维过程：

一种合法方案一定是山峰（下称summith）和山谷（下称valley）交替出现的，或者说一定是一个波动数列（下面可能多次出现“合法方案”和“波动数列”混用的表述）。观察前几组数据可以猜想（也是直观的）每一个数字都可以放在开头。下面，我们考虑summit(i,n)表示以数字i开头长度为n，且i为山峰的合法方案数。类似地，定义vally(i,n)表示以i开头长度为n，且i为山谷的合法方案数。总的合法方案数就是:
![](https://cdn.luogu.com.cn/upload/pic/48349.png)

接下来我们发现，如果一种合法方案以i开头，长度为n，且i作山峰，后面一定跟着一段开头是山谷的长度为n-1的合法方案（波动数列），并且后面这段波动数列的开头数字一定要小于i。似乎只要把valley(k,n-1)从1到i-1求和即可。然而后面这段波动数列的数字是从1到n-1的，并且有可能已经包含了i！

这时候只要想到一种长度为n-1的合法方案事实上是代表了n-1个互不相同的数的一种排列，即：最小的数排在哪里，第二小的数排在哪里……而不仅仅代表1排在哪里，2排在哪里。理解了这点，我们做一个操作：对于每个长度为n-1的合法方案，把i变成i+1，然后把i+1变成i+2……把n-1变成n，这样，位于该合法方案中任何位置的数的“第几小”是不会改变的。对每个i，每次把一种长度为n-1的合法方案按照这样操作，然后把i插入这个方案的最开头，就得到了一种长度为n的合法方案。

于是有dp方程：
![](https://cdn.luogu.com.cn/upload/pic/48350.png)

接下来要求valley(i,n)，其实也是一样的思想，一种合法方案以i开头，长度为n，且i为山谷的话，后面就要接上长度为n-1且开头为山峰的波动数列，并且开头的数要比i大。对于每一段长度为n-1的合法序列，把i变成i+1，把i+1变成i+2……把n-1变成n。就能使得这种连接成立。由于这里做了这个操作，要注意到实际上我们是把summit(k,n-1)从 _**i 到 n-1**_ 求和。

dp方程如下：
![](https://cdn.luogu.com.cn/upload/pic/48352.png)

另外，i=1和i=n的特殊情况下，容易发现这样求出来的summit(1,n)和valley(n,n)都是0，所以不会有问题。

下面就可以码代码了。我用f表示valley，用g表示summit，由于N>=3，只要从2开始赋初值就行。这是第一版代码：
```cpp
#include <iostream>
using namespace std;

int f[4300][4300];
int g[4300][4300];
int main()
{
    int n,p;
    cin >> n >> p;
    f[1][2]=1%p;
    g[2][2]=1%p;
    for(int i=3;i<=n;i++)
    {
        for(int a=1;a<=i;a++)
        {
            for(int b=a;b<=i-1;b++) f[a][i]=(f[a][i]+g[b][i-1])%p;
            for(int b=1;b<=a-1;b++) g[a][i]=(g[a][i]+f[b][i-1])%p;
        }
    }
    int res=0;
    for(int i=1;i<=n;i++) res=(res+f[i][n]+g[i][n])%p;
    cout << res;
    return 0;
}
```

不过这代码是过不了这题的，会TLE三个点。这是因为对f(k,n-1)和g(k,n-1)的求和效率过低。只要想到对f(k,n-1)和g(k,n-1)做一个对k的前缀和就能解决了。于是加入fsum和gsum数组，这里要小心在赋初值的时候，f(2,2)为0，但是你要为fsum(2,2)赋一个初值1。

进一步你会发现其实f和g数组都已经没用了……把它们删掉防止MLE。我的AC代码如下：
```cpp
#include <iostream>
using namespace std;

//int f[4300][4300];
int fsum[4300][4300];
//int g[4300][4300];
int gsum[4300][4300];
int main()
{
    int n,p;
    cin >> n >> p;
    //f[1][2]=1%p;
    fsum[1][2]=1%p;
    fsum[2][2]=1%p;
    //g[2][2]=1%p;
    gsum[2][2]=1%p;
    for(int i=3;i<=n;i++)
    {
        for(int a=1;a<=i;a++)
        {
            int fai,gai;
            fai=(gsum[i-1][i-1]-gsum[a-1][i-1]+p)%p;
            fsum[a][i]=(fsum[a-1][i]+fai)%p;
            gai=(fsum[a-1][i-1])%p;
            gsum[a][i]=(gsum[a-1][i]+gai)%p;
        }
    }
    int res=(fsum[n][n]+gsum[n][n])%p;
    cout << res;
    return 0;
}
```

这个代码优化得显然没有前面发题解的dalao们好。如果再深入探讨，fsum和gsum之间是有关系的，可以不需要两个这么大的数组，以进一步优化空间。