此题解对第一的题解进行完善，原题解有几处小错误

首先，有三个性质：

1. 在一个满足条件的数列中，如果 $x$ 和 $x+1$ 不相邻，那么直接交换这两个数字也可以得到一个满足条件的数列，比如：5 2 3 1 4 $→$ 4 2 3 1 5

2. 把满足条件的数列中的每个数字 $H_i$ 变成 $N-H_i+1$ 会得到另一个满足条件的数列，且新数列的山峰与山谷情况相反，比如：1 4 2 5 3（1，2，3 是山谷，4，5 是山峰）$→$ 5 2 4 1 3（2，1 是山谷，5，4，3是山峰）

3. 满足条件的数列反转后得到的数列也合法。比如：
   1 4 2 5 3 $→$ 3 5 2 4 1
  
考虑 DP，设 $dp(i,j)$ 表示选择 $1∼i$ 这些数字，第一个数为山峰，且第一个数为 $j$ 的方案数，根据性质 2，答案为 $2×∑_{i=1}^Ndp(N,i)$。

   我们要求 $j$ 放在第一个时满足条件的方案数。分两种情况：

   1. $j$ 与 $j-1$ 不相邻，根据性质 1，将 $j$ 放在第一个时的方案数与将 $j-1$ 放在第一个时的方案数是相同的，因为将 $j$ 和 $j-1$ 交换也能得到合法方案并且 $j-1$ 放在第一个时 $j$ 不可能放在第二个，所以两个方案数相同。
      即 $dp(i,j-1)→dp(i,j)$。

   2. $j$ 与 $j-1$ 相邻，那么显然 $j$ 为山峰，$j-1$ 为山谷，且去掉第一位之后的数都属于 $[1,j-1]∪[j+1,i]$，问题转化为 $j-1$ 为第一位且为山谷，有 $i-1$ 个数，由性质 2 可得：当 $j-1$ 作为山谷的方案数与 $(i-1)-(j-1)+1$ 作为山峰的方案数是相同的，现在的问题变成 $dp(i-1,(i-1)-(j-1)+1)$ 所对应的区间与我们想求的区间不同，但是不影响，因为山峰山谷考虑的只是相对大小关系，所以我们将 $[j+1,i]$ 全部减去 $1$ 对当前方案的可行性也不产生影响，并且处理之后对应的区间就是 DP 方程所代表的含义了。
		即 $dp(i-1,(i-1)-(j-1)+1)→dp(i,j)$。
      
初始 $dp(2,2)=1$（因为 $1$ 不能为山峰），时间复杂度 $\mathcal O(n^2)$。

考虑到空间为 125 MB 且 $dp(i,j)$ 只与 $dp(i-1,k)$ 有关，所以滚动数组优化空间复杂度即可，空间复杂度 $\mathcal O(n)$。
      
code：
```cpp
#include <bits/stdc++.h>

const int N = 4200; 

using namespace std;

int n, p, ans;
int dp[2][N];

int main()
{
	cin >> n >> p;
	dp[2 & 1][2] = 1;
	
	for (int i = 3; i <= n; ++ i)
		for (int j = 2; j <= n; ++ j)
			dp[i & 1][j] = (dp[i & 1][j - 1] + dp[(i - 1) & 1][(i - 1) - (j - 1) + 1]) % p;
	
	for (int i = 1; i <= n; ++ i) 
		ans = (ans + dp[n & 1][i]) % p;

	cout << ans * 2 % p << endl;
	
	return 0;
} 
```