## 题解索引
1. **题目大意**
2. **Solution**
3. **AC code**
4. **类似题型**

代码类型： C++（cpp）

是否吸氧：否

不压行代码长度：24

------------

## 题目大意
题面： [<传送门>](https://www.luogu.com.cn/problem/P2467)

题意：给出 $n,p$，所有序列长度为 $n$，某个序列中的元素就是 $1\sim n$ 的排列。已知一个合法方案满足以下要求之一：

1. 序列中存在 $i$，使得 $a_{i-1}<a_i>a_{i+1}$。

2. 序列中存在 $i$，使得 $a_{i-1}>a_i<a_{i+1}$

求出合法方案数 $\bmod\,p$ 的值。

~~术语理解： DP+组合数。~~

## Solution

首先，我们看到题目，一看到有关排列的问题，就能知道与排列组合有关。

观察一下序列，~~易知~~按数大小分化，可划分为两种：

1. 降升降升降升……

2. 升降升降升降……

等等，这不是波动数列么？而且，因为是排列，所以我们只需要考虑其中一种，因为它是对称的！

状态：设 $f_i$ 表示序列长度为 $i$ 的可行方案数 $\bmod\,p$ 值（其实这里取不取模都一样，最好是取模防止爆，反正时间够）

那最后我们输出 $f_n\times 2$ 即可！

可是初始化和转移？

首先手推一下初始化，$f_1=1$。那么 $f_0$ 怎么设定？算了不管了，初始化是取决于转移的，转移后我们再考虑即可。

既然我们是利用的组合数，就要先把组合数求出来。数组开 `long long g[4209][4209]` 指定没希望了，因为这题数据卡的很严。

我们就没办法了吗？不，我们可以压到一维，然后算到哪用到哪！

接着考虑转移，既然我们选用了类似前缀和的状态，那么我们也可以利用一下前缀和的思想！

通过研究~~易知~~，我们发现合法方案一定会出现在奇数位（别问，问就玄学）。对于长度为 $i$ 的合法方案数，我们需要倒序遍历枚举最大值（倒序是为了先算下标小的，我的方法是倒序，其实也可以正序），跑转移，而且这个位置还要是奇数位。

有人可能问，为啥只算奇数位？因为奇数位是一种序列，而偶数位也是一种序列，我们完全可以根据之前说的对称性来合并两种情况。

那么转移方程究竟是啥？先丢后讲：

设当前枚举位置为 $j$，序列长度为 $i$ ：

$$f_i=(f_i+C_{i-1}^{j-1}\times f_{j-1}\times f_{i-j})\bmod p$$

我们以 $j$ 为分界点，左边的方案数是 $f_{j-1}$，右边为 $f_{i-j}$（注意序列右端点为 $i$），至于那个组合数嘛……是排列的方案数。

为啥是 $C_{i-1}^{k-1}$ （$i-1$ 中选 $k-1$ 个的排列数）？因为我们要得到 $1\sim i$ 排列，不考虑位置 $j$，那么剩下就是 $i-1$ 个情况。左边有 $j-1$ 个位置，所以我们要选 $j-1$ 个数。为啥不算右边的？因为我这里是根据右边的情况来确定的，所以右边是固定的。

当然，你也可以固定左边，把式子写成：

$$f_i=(f_i+C_{i-1}^{i-j}\times f_{j-1}\times f_{i-j})\bmod p$$

不过要注意组合数求出来的时机。

最后注意求得 $f_n$ 后 $\times 2$ 然后取模！

式子过程中可以多取几次模，

## AC code

```cpp
#include<iostream>
#include<cmath>
#include<cstdio>
using namespace std;
const int MAX=4e5+9;
typedef long long ll;
inline ll read(){
    register ll x=0,f=1;register char ch=getchar();
    while(!isdigit(ch)){if(ch=='-')f=-1;ch=getchar();}
    while(isdigit(ch)){x=x*10+ch-'0';ch=getchar();}
    return x*f;
}ll n,mods,f[MAX],g[MAX];
int main(){
    n=read();mods=read();
    f[0]=1,f[1]=1;g[1]=1;
    for(int i=2;i<=n;i++){
        for(int j=i;j>=1;j--){
            g[j]+=g[j-1];
            g[j]%=mods;
            if(j&1)f[i]=((g[j]%mods*(f[j-1]%mods*f[i-j]%mods)%mods)%mods+f[i]%mods)%mods;
        }
    }printf("%lld\n",(f[n]*2)%mods);
    return 0;
}
```

AC 记录 [<传送门>](https://www.luogu.com.cn/record/57378760)