#### 题目分析：

做法：前缀和DP。很容易想到，不用复杂的性质分析。

设计状态： $f(i,j,0/1)$  表示使用了前 $i$ 
个数字，末尾数为 $j$ ，且末尾处为山峰或山谷时，方案数的总和。

**以下是重点：**

当末尾的山峰值为 j 时，每一个值低于 j 的山谷都有可能转移至 $f(i,j)$ 。这是一个从 $1$ 到 $j-1$ 的区间。考虑前缀和。定义 $s(i,j)$ 表示使用了第 $i$ 个数字时， $1$ 到 $j$ 的方案数总和。那么我们有：

$f(i,j,0/1) = s(i-1,j-1,1/0)$

我们不需要考虑值为 $i$ 的点在哪里。 $i$ 之所在必为山峰，因为 $i$ 最大。

从而可以写出如下代码：

```cpp

for(int i=1;i<=n;i++)
	for(int j=1;j<=i;j++){
		f[i][j][0]=s[i-1][j][1];
  		f[i][j][1]=s[i-1][j][0];
		s[i][j][0]+=f[i][j][0];
  		s[i][j][1]+=f[i][j][1];
	}
	
```

转移方程已经基本完成。随后：
* 不妨令末尾都为山峰，避免打两次代码
* 加入滚动数组和取模
* 初始化

就得到了最终代码：

**CODE:**

```cpp
#include<bits/stdc++.h>
using namespace std;

int n,p,f[2][4505],s[2][4505];

int main(){
	scanf("%d%d",&n,&p);
	s[0][2]=1;//可以确定，此时方案有且只有一种，就从这初始化
	for(int i=3;i<=n;i++)
		for(int j=2;j<=i;j++){
			f[i&1][j]=(s[(i-1)&1][i-1]-s[(i-1)&1][i-j]+p)%p;//避免负数
			s[i&1][j]=(s[i&1][j-1]+f[i&1][j])%p;
		}
	printf("%d\n",(s[n&1][n]<<1)%p);
	return 0;
}
```