设f[i][j]表示i个数中j个数不符合序列,且第二个数比第一个数大

如5 1 2 3 4中3应比2小，4应比3小 此则j=2

f[1][0]=1,(1);

f[2][0]=1,(1,2);f[2][1]=1,(2,1);

推导出f[i+1][j]=f[i+1][j]+f[i][j];（将新加入的最大值插入到最后或倒数第二，如5 1 2 3 4->5 1 2 3 6 4,5 1 2 4 3->5 1 2 4 3 6)

f[i+1][j-1]=f[i+1][j-1]+f[i][j]\*j;(将新加入的最大值插入到不符合序列的数前，如5 1 2 3 4->5 1 2 6 3 4,5 1 2 3 6 4)

f[i+1][j+1]=f[i+1][j+1]+f[i][j]\*(i-j);(将新加入的最大值插入到剩下的数前）

```cpp
#include<cstdio>
long long i,j,k,n,m,p,f[4205][4205];
int main(){
    scanf("%lld%lld",&n,&p);
    f[1][0]=1;
    for(i=1;i<=n;++i)
        for(j=0;j<=i;++j){
     k=f[i][j];
     f[i+1][j]=(f[i+1][j]+k)%p;
     f[i+1][j+1]=(f[i+1][j+1]+k*(i-j)%p)%p;
     if(j)f[i+1][j-1]=(f[i+1][j-1]+(k*j)%p)%p;
}
printf("%lld",(f[n][0]<<1)%p);
}
```