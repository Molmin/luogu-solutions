蒟蒻有一个神奇的想法，跟其他的题解有些不同（虽然比较相似），代码简单，无需分类讨论，但是有一些神奇的处理办法

首先直接大力令f[i]为长度为i的山脉的个数，不讨论第一个是修建瞭望台或酒馆的情况

首先很容易发现如果n为偶数，那么将一个长度为n的情况左右反转（类似将一个 1 3 2 4 的序列变为 4 2 3 1），由于开头和末尾修建的设施不同，那么可以通过左右反转来得到末尾相反的一种情况，且一一对应，则有开头/末尾为瞭望台和开头/末尾为酒馆的情况相等。

类似的，如果n为奇数，那么将一个长度为n的情况上下反转并且将对应下标a[i]改为n+1-a[i]（类似将一个 5 1 3 2 4 的序列变为 1 5 3 4 2），由于开头和末尾修建的设施相同，那么可以通过上下反转来得到末尾相反的一种情况，且一一对应，则有开头/末尾为瞭望台和开头/末尾为酒馆的情况相等。

所以，我们枚举最后一个高度所在的位置，可以轻松地得到转移
```
    for(int i=3;i<=n;i++)
    {
        for(int j=0;j<i;j++)
            dp[i]+=(1ll*c[i-1][j]*dp[j]/2)*dp[i-j-1]/2;
    }

```
其中$c[i][j]$为组合数，可以用杨辉三角轻松处理
$dp[j]$是第i个左边的情况，由于最后一个一定为酒馆，所以要将$dp[j]/2$,$dp[i-j-1]/2$也是。

当然，如果你这么写会样例都过不去。$dp[i]$虽然大多数都是偶数，但也有特例。当$i=1$是$dp[i]=1$,上下反转后保持不变，所以不能直接$/2$,这里可以令$dp[1]=2$，直接视其为两种情况，就可以$/2$。类似的，$dp[0]=0$，但是当最高峰左边无元素时，也会产生贡献，也令$dp[0]=2$。

好的，还剩最后一个问题，那就是取模。如果直接每一步$mod p$，将会收获40分的好成绩。这是因为$a=b(mod p)$不等价于$a/2=b/2(mod p)$。我的第一想法是费马小定理处理逆元，但是p不一定为质数，所以很可能在模p意义下2的逆元不存在，依然不能解决问题。

但是我们发现由于每次只需要$/2$,所以我们在每次操作时考虑不$mod p$，而是$mod p*2$.显然有$a%p=a%（p*2）%p$,而在$mod p*2$意义下的偶数x，有$(x/2)%(p*2)=(x%(p/2))/2$，所以可以在运算中先$mod p*2$，最后输出时再$mod p$，即可$AC$。

附上代码
```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<iostream>
#include<vector>
#include<queue>
#include<cmath>
#include<stack>
using namespace std;
int c[4201][4201];
long long dp[4201];
signed main()
{
    int n,mod;
    scanf("%d%d",&n,&mod);
    for(int i=0;i<=n;i++)
        c[i][0]=c[i][i]=1;
    for(int i=1;i<=n;i++)
        for(int j=1;j<=i;j++)
            c[i][j]=((long long)c[i-1][j]+c[i-1][j-1])%(mod*2);
    dp[0]=dp[1]=dp[2]=2;
    if(n==1){printf("1");return 0;}
    for(int i=3;i<=n;i++)
    {
        for(int j=0;j<i;j++)
            dp[i]+=(1ll*c[i-1][j]*dp[j]/2)%(mod*2)*dp[i-j-1]/2,dp[i]%=(mod*2);
    }
	printf("%d\n",dp[n]%mod);
    return 0;
}

```
