其实这个题第一眼是没有任何思路的


强行无视题解，经过漫长的找规律，终于推出了一个可行的方法：


f[i][0/1]i表示最高位的数字，0表示开始是上升，1表示开始是下降。


为什么会推出这个？


1、因为所谓抖动序列和每个数的具体值没有关系，只与它的大小有关系，


2、在下一个循环中，枚举开头数字，所以只和上一种情况的最高位有关，在数位依次递增的时候循环开头的每个情况即可。


例：        若为1、 2、 3、 4、 5：


开始是2，    后面是1、 3、 4、 5，分别对应4个数时的1 、2、 3、 4；


转移条件即为上一次递推 <2 上升 作为最高位为 2 的下降方案数


上一次递推 >=2 下降 作为最高位为 2 的上升方案数


在搞上前缀和+后缀和优化，减掉一维 就可以n^2出解   （强行无视巨大的常数）


代码：


```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int n,p,dowh,ans,i,f[2][5000][2],j;
int main()
{
    scanf("%d%d",&n,&p);
    dowh=1;
    f[0][1][0]=1;
    f[0][1][1]=1;
    f[0][2][1]=1;
    f[0][2][0]=1;
    for(i=3;i<=n;i++,dowh^=1)
    {
        for(j=1;j<=i;j++)
        f[dowh][j][0]=f[dowh^1][j][1];
        for(j=1;j<=i;j++)
        f[dowh][j][1]=f[dowh^1][j-1][0];
        if(i!=n)
        {
        for(j=i;j>=1;j--)
        f[dowh][j][1]=(f[dowh][j][1]+f[dowh][j+1][1])%p;
        for(j=1;j<=i;j++)
        f[dowh][j][0]=(f[dowh][j][0]+f[dowh][j-1][0])%p;
}
    }
    dowh^=1;
    for(i=1;i<=n;i++)
    {
        ans+=f[dowh][i][0];
        ans%=p;
        ans+=f[dowh][i][1];
        ans%=p;
    }
    cout<<ans%p;
}
```