大家好啊，我是扫描线枚举分割点说的道理。今天给大家来点想看的东西。

[题目链接](https://www.luogu.com.cn/problem/P6163)。给你数轴上 $n$ 个区间，每个区间选一个点，问你这些点两两距离差的和的最小值。

这个题和 [ARC147](https://atcoder.jp/contests/arc147/tasks/arc147_c)[ ](https://vdse.bdstatic.com//192d9a98d782d9c74c96f09db9378d93.mp4)[C](https://atcoder.jp/contests/arc147/tasks/arc147_c) 基本是完全一样的，就是答案差个 2 倍，数据范围有少许差异而已；[AtCoder](https://atcoder.jp/contests/arc147/editorial/4764)[ ](https://vdse.bdstatic.com//192d9a98d782d9c74c96f09db9378d93.mp4)[官方题解](https://atcoder.jp/contests/arc147/editorial/4764)非常的神奇，但是它也是非常的难想到，所以我们带来一个“每一步都比较好想基本，而思维路径稍微长一点，代码稍微难写一点”的做法。

首先我们考虑一下最优解大概是个什么形式。

题目要求点的两两距离差最小，那我们考虑对于某个 $n$ 个点的状态，把最右边的点尽可能往左移，把最左边的点尽可能往右移一定最优；除了最值点外，我们也可以抽象的把区间分成左中右三部分，右边尽可能往左，左边尽可能往右。

于是我们可以枚举一下每个分割点，然后对于每个分割点可以确定每个区间具体选哪个点，然后我们就有了一个优秀的 $O(Vn^2)$ 解法。

我们发现对于 $n$ 个点算距离和其实不需要平方级算法，只要增量式，记录当前有的点数和位置和，考虑每个点加进来时对已有点的贡献就可以了。这个后面有用。然后我们就有了一个优秀的 $O(Vn)$ 解法。

观察到如果包含分割点的区间情况一样，分割点对应的答案也是一样的，于是只需要考虑分割点作为区间左右端点的情况即可，其它的情况要不然不够优要不然答案与已计算的一样。然后我们就有了一个优秀的 $O(n^2)$ 解法。

我们回头想一下对于一个已知的分割点怎么计算答案的来着：右端点在分割点左边的区间，取右端点；包含了分割点的区间，取分割点本身；左端点在分割点右边的区间，取左端点。

也就是说，如果我们从左往右的自然顺序考虑所有分割点，取右端点的区间数量会不断增加；取左端点的区间数量会不断减少；而包含了分割点的区间可以动态维护。

这启发我们把区间和分割点排个序，扫一遍就得了。

那贡献怎么维护呢？类比之前增量式考虑点的贡献的算法，可以解决左中右三部分内部自己的贡献；而几个部分之间的贡献也可以类比三个点之间的贡献计算。

然后就做完了。时间复杂度 $O(n \log_2 n)$，瓶颈在于纯纯的排序。不过就像开头说的，代码难度还是有一些的，做好心理准备。

双倍经验的时候别忘了改改 `*2`。

[Code](https://www.luogu.com.cn/paste/6uckaijz)[ ](https://vdse.bdstatic.com//192d9a98d782d9c74c96f09db9378d93.mp4)[link](https://www.luogu.com.cn/paste/6uckaijz)


[剪贴板](https://www.luogu.com.cn/paste/gms3tgmj)[ ](https://vdse.bdstatic.com//192d9a98d782d9c74c96f09db9378d93.mp4)[备份](https://www.luogu.com.cn/paste/gms3tgmj)