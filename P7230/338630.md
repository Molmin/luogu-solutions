先说当 $1\le n,m\le 5\times 10^3$ 的做法。由于这是暴力，放弃维护一切信息。直接修改数组中的值，查询时二分长度，然后相当于一个固定长度的区间从左往右扫，当区间内 $1$ 到 $k$ 都包含时说明可行。单次修改复杂度为 $O(1)$，单次查询复杂度最坏为 $O(nk\log n)$。总时间复杂度最坏为 $O(mkn\log n)$，理论上过不去这部分数据，实际上可过。

我觉得上面那个部分和正解没啥关系。注意到 $1\le k\le 50$，这个数据范围仿佛在暗示我们些什么。

1. 升维。将 $k$ 作为一维放到我们要维护的信息中。
2. 二进制优化。用二进制数记录连续子数组中含数字 $1$ 到 $k$ 的情况，当该数等于 $2^k-1$ 时说明满足。

下面具体说明如何实现：类似于带修最大连续和的线段树求法，我们维护线段树上每个区间的前缀、后缀信息。那么答案为左区间最短长度、右区间最短长度、左区间后缀与右区间前缀拼接成的区间最短长度中的最小值。

难点在于左右区间合并的这一部分。直接合并前后缀信息，要枚举左区间所有后缀和右区间所有前缀，复杂度直接上天。改成维护前后缀第一次出现 $i$ 种不同颜色时的位置以及其颜色的状态。考虑如何维护：

对于前缀信息，我们先将左儿子对应信息复制，然后再根据右儿子的前缀进行扩展。双指针，一个指针 $i$ 为右区间所含颜色种类，一个指针 $j$ 为当前前缀所含颜色种类。如果出现新的颜色，我们就更新状态。

```cpp
for(int i=1,j=Sum[ls];i<=Sum[rs];i++)
    if((t[p].pre[j]&t[rs].pre[i])!=t[rs].pre[i])
    {
        t[p].pre[j+1]=t[p].pre[j]|t[rs].pre[i];
        t[p].P[j+1]=t[rs].P[i];
        j++,Sum[p]=j;
    }
```

后缀信息的处理同理。注意两个指针仍然是从小到大，因为我们枚举的是种类，而不是下标。

```cpp
for(int i=1,j=Sum[rs];i<=Sum[ls];i++)
    if((t[p].suf[j]&t[ls].suf[i])!=t[ls].suf[i])
    {
        t[p].suf[j+1]=t[p].suf[j]|t[ls].suf[i];
        t[p].S[j+1]=t[ls].S[i];
        j++;
    }
```

上面两部分代码中出现的 $P$ 和 $S$ 数组分别为前缀、后缀第一次出现 $i$ 种不同颜色时的位置。比如一个序列 $\{1,4,3,3,2,1\}$，它的 $S[3]$ 就等于 $4$，而不是 $3$。而它的 $S[4]$ 则等于 $2$。

为何要维护第一次的位置？因为我们需要最短的连续子数组。而上面例子中，当 $k=3$ 时我们得到的为 $3$ 而不是 $4$。再次使用双指针，$i$ 表示左区间后缀中含的颜色种类数，$j$ 表示右区间前缀中含的颜色种类数。为了具备单调性，$i$ 从大到小，$j$ 从小到大，这就相当与左区间后缀的左端点在不断右移，右区间前缀的右端点也在不断右移，两个指针都在右移，具有单调性。

```cpp
for(int i=Sum[ls],j=1;i>0;i--)
{
    while(j<=Sum[rs]&&((t[ls].suf[i]|t[rs].pre[j])!=(1ll<<k)-1))j++;
    if(j<=Sum[rs])
        Ans[p]=min(Ans[p],t[rs].P[j]-t[ls].S[i]+1);
}
```

剩余的就是普通的线段树操作，查询只需查全局即可。

[具体代码实现](https://www.luogu.com.cn/paste/g06xc1q5)

