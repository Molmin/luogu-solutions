# 一些闲扯
这道题说实话可以当作模板。  
我习惯称这类题为~~线段树左右前缀区间维护模板~~  
这种题的思想就是维护一个区间的前缀max和后缀max，然后转移的时候就判mid和mid + 1的条件，假如O了，那么就继续转移。其实这个思想挺有意思的，再加上这类题的思想又和最大子段和的分治做法很相似，所以……就没有所以啦！至少得熟练这种做法吧，毕竟用了这种思想的线段树题还是很多的（洛谷也还有只不过我忘了在哪里……）  
# 正题  
首先转人言，题目是要让我们搞一个维护最大不连续01的连续子串。  
我们要维护的东西我罗列一下
```cpp
一、一个区间的最大01连续子串
二、一个区间的前缀最大01连续子串
三、一个区间的后缀最大01连续子串
四、一个区间的左端点、右端点、总长
```  
对于四，我们只要在update的时候给push_up里面加个l,r参数就好了没必要单独开个数组啥的去维护。（不过你这样做也无妨，反正线段树的大部分题也不会刻意卡你空间）  
对于二、三我们要分类讨论：
```cpp  
一、左右区间不能合并：  
那么我们该区间的前缀最大01连续子串不就是左区间的前缀最大01连续子串？该区间的后缀最大01连续子串不就是右区间的后缀最大01连续子串？因为你没有新的可以合并的方法产生对吧，相当于左边还是左边右边还是右边，我即使合并了也互不影响；  
二、左右区间可以合并：
这时候就需要细心一点，假如左区间的最大01子串就是他本身的长度，换句话说就是这个区间很给力直接就把他自己全部拿出来贡献给答案了，这时由于合并了我们就要考虑右区间。现在右区间不是也可以合并了吗？那么我们直接加上有区间的前缀最大01连续子串就行了。后缀也是同理。
```
对于一也是类似的分类讨论：
```cpp
一、左右区间不能合并：  
既然不能合并的话那还管啥？我们直接把左右区间里面最大01连续子串长的那个给赋值过去不就完了？你又不能产生新的方法我鸟你有何用？  
二、左右区间可以合并：  
这时候我们思考：两个区间合并到底改变的是什么？其实就是他们的首尾相连，我们考虑一下左区间的最大后缀和右区间的最大前缀，这两个既然能合并那还等啥？赶紧判断一波max。
```
~~讲的貌似有点口水话不过我个人感觉挺详细的~~  
# 附上push_up代码：
```cpp
void push_up(int p,int l,int r)
{
	int mid = (l + r) >> 1;//求左儿子的右端点，推之则mid + 1是右儿子的左端点对吧 
	int L = (mid - l + 1),R = r - mid;//左孩子的长、右孩子的长 
	lsum[p] = lsum[ls(p)],rsum[p] = rsum[rs(p)],sum[p] = max(sum[ls(p)],sum[rs(p)]);//我们先全部都从左右孩子身上扒他们的最值，保证我们操作的正确性 
	if(a[mid] != a[mid + 1])//考虑连接情况 
	{
		sum[p] = max(sum[p],rsum[ls(p)] + lsum[rs(p)]);//维护最大值，这个应该都看的懂吧 
		if(sum[ls(p)] == L) lsum[p] = L + lsum[rs(p)];//如果等于了左孩子的长度，则说明我们大区间的max前缀01需要更大的空间，那就从右儿子那里扒他的max前缀01 
		if(sum[rs(p)] == R) rsum[p] = R + rsum[ls(p)];//如果等于了右孩子的长度	则说明我们大区间的max后缀01需要更大的空间，那就从左儿子那里扒他的max后缀01 
	} 
}
```
其他的函数其实就很简单了，要是这都搞不懂说明你连线段树最基本的一些东西都是没搞懂……当然也不是说你撇，至少也要先搞懂原理你再来做题……吧？  
# 附上代码~~供各位拍拍?~~
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
using namespace std;
const int Len = 3e5 + 5;
int n,m,opt,a[Len],sum[Len << 2],lsum[Len << 2],rsum[Len << 2];//分别对应一个区间的最大01连续子串，一个区间前缀最大01连续子串、一个区间后缀最大01连续子串 
int ls(int x){return x << 1;}
int rs(int x){return x << 1 | 1;}//懒得打<<1了…… 
void push_up(int p,int l,int r)
{
	int mid = (l + r) >> 1;//求左儿子的右端点，推之则mid + 1是右儿子的左端点对吧 
	int L = (mid - l + 1),R = r - mid;//左孩子的长、右孩子的长 
	lsum[p] = lsum[ls(p)],rsum[p] = rsum[rs(p)],sum[p] = max(sum[ls(p)],sum[rs(p)]);//我们先全部都从左右孩子身上扒他们的最值，保证我们操作的正确性 
	if(a[mid] != a[mid + 1])//考虑连接情况 
	{
		sum[p] = max(sum[p],rsum[ls(p)] + lsum[rs(p)]);//维护最大值，这个应该都看的懂吧 
		if(sum[ls(p)] == L) lsum[p] = L + lsum[rs(p)];//如果等于了左孩子的长度，则说明我们大区间的max前缀01需要更大的空间，那就从右儿子那里扒他的max前缀01 
		if(sum[rs(p)] == R) rsum[p] = R + rsum[ls(p)];//如果等于了右孩子的长度	则说明我们大区间的max后缀01需要更大的空间，那就从左儿子那里扒他的max后缀01 
	} 
}
void build(int p,int l,int r)
{
	sum[p] = lsum[p] = rsum[p] = 1;//赋初始值，别忘了三个都要赋值…… 
	if(l == r) return;//递归结束 
	int mid = (l + r) >> 1;
	build(ls(p),l,mid);
	build(rs(p),mid + 1,r);
	push_up(p,l,r);//基本建树操作^ 
}
void update(int p,int l,int r,int idx)
{
	if(l == r && l == idx){a[l] ^= 1;return;}//找到了需要更改的节点 
	int mid = (l + r) >> 1; 
	if(idx <= mid) update(ls(p),l,mid,idx);
	else update(rs(p),mid + 1,r,idx);//类似于折半查找操作，也就是我们二分里面的找数那操作 
	push_up(p,l,r);
} 
int query(){return sum[1];}//直接return最大区间的sum值就好了 
int main()
{
	scanf("%d %d",&n,&m);
	build(1,1,n);//别忘了建树 
	while(m --)
	{
		scanf("%d",&opt);
		update(1,1,n,opt);
		printf("%d\n",query());
	}
	return 0;
}//完结撒花！！！
```
# 完结撒花！！！