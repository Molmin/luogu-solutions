真不超纲

首先先考虑k=1的情况。

首先模拟出这些点的位置，一个个存入数组。

然后按照x为第一关键字、y为第二关键字排序。

我们需要找到多少组$[(p,q),(p+1,q),(p,q+1),(q+1,p+1)]$的四元组。

可以乱搞。一种办法是二分查找。复杂度(NlogN)

让K很大时怎么办呢？

我们知道，机器人运行一段程序是相同的，也就是说，以后的每一次都是平移平移平移。

我们假设第一次程序运行结束后从(0,0)走到(a,b)

对于一个点$(p,q)$被标记,是不是可能$(p+ra,q+rb)$也被标记呢？

可以证明，对于任意${p,q}，0\le p < a$，如果有被标记的话，一定存在若干整数对$(s,t)$，当$s \le r \le t$时，$(p+ra,q+rb)$也被标记。我们计算出这些s和t.

于是又返回了上面一种情况。只要记录有多少对$[(p,q,r),(p+1,q,r),(p,q+1,r),(q+1,p+1,r)]$的四元组就好，也就是说，在4对s和t中，找最大的公共部分。

我们可以假设$a,b>0$，如果不是这样，可以进行旋转翻转操作。

不过有2个点数据是a=0也就是说返回了源点，我们直接根据最上面的一情况就好啦。

思路就是这样，程序实现稍微麻烦一些。可是如果使用stl则会简化代码（比如set）

C++大法好，退pas保平安。
