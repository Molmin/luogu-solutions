## 1.编程思路。

本题采用树形 DP 求解。

根据题意，有 $m$ 棵形态相同的树，每棵树上都有 $n$ 个结点。现在要求对这 $m\times n$ 个结点赋值，赋值要求要满足 $3$ 点：

1）每个结点可以赋值为 $0$ 或 $1$。

2）处于同一位置的结点若某棵树中赋值为 $1$，则其他 $m-1$ 棵树中该同一位置都只能赋值为 $0$。

3）在任一棵树中，任意一条边所连接的两个结点不能同时赋值为 $1$。

为了较好地理解后面的公式，先以 $m=3,n=2$，即有 $3$ 棵树，每棵树上有 $2$ 个结点，每棵树上的两个结点编号为 $1$（表示根结点）和 $2$（表示叶子结点）。

先看编号为 $2$ 的结点的赋值情况，$3$ 棵树有 $4$ 种赋值方法：$3$ 棵树中的编号为 $2$ 的结点均赋值为 $0$，记为 $(0,0,0)$；第 $1$ 棵树中编号为 $2$ 的结点赋值为 $1$，其余两个结点赋值为 $0$，记为 $(1,0,0)$；第 $2$ 棵树中编号为 $2$ 的结点赋值为 $1$，其余两个结点赋值为 $0$，记为 $(0,1,0)$；第 $3$ 棵树中编号为 $2$ 的结点赋值为 $1$，其余两个结点赋值为 $0$，记为 $(0,0,1)$。

在这 $4$ 种情况中，第 $1$ 种情况是所有 $3$ 棵树中编号为 $2$ 的结点全部赋值为 $0$，其情况数用 $\mathit{dp}_{2,0}$ 来表示，则有 $\mathit{dp}_{2,0}=1$。

后面三种情况是类似的，就是某一棵树的 $2$ 号结点赋值为 $1$，其余树中 $2$ 号结点赋值为 $0$，将这 $3$ 种情况视为一种类型，其类型数用 $\mathit{dp}_{2,1}$ 来表示，则有 $\mathit{dp}_{2,1}=1$。

再看编号为 $1$ 的结点的赋值情况，若编号为 $1$ 的结点全部赋值为 $0$，则编号为 $2$ 的结点可随意赋值 $0$ 或 $1$。 因此，$\mathit{dp}_{1,0}=\mathit{dp}_{2,0}+3\times \mathit{dp}_{2,1}=4$。

某一棵树编号为 $1$ 的结点赋值为 $1$，其余树中 $1$ 号结点赋值为 $0$，则编号为 $2$ 的结点赋值全部为 $0$ 肯定是符合要求的；若某一棵树中的 $2$ 号结点赋值为 $1$，则一定不能在 $3$ 棵树中选 $1$ 号结点也赋值为 $1$ 的那棵树。因此，$\mathit{dp}_{1,1}=\mathit{dp}_{2,0}+(3-1)\times \mathit{dp}_{2,1}=3$。

总的赋值方法数为 $\mathit{dp}_{1,0}+3\times \mathit{dp}_{1,1}=13$。

更一般地，设 $\mathit{dp}_{u,0}$ 表示所有 $m$ 棵树中编号为 $u$ 的结点全部赋值为 $0$ 的方案数，$\mathit{dp}_{u,1}$ 表示某一棵树中编号为 $u$ 的结点赋值为 $1$，其余 $m-1$ 棵树中编号为 $u$ 的结点赋值为 $0$ 的同一类型数，则有状态转移方程如下：

$$ \mathit{dp}_{u,0}= \prod(\mathit{dp}_{v,0}+m\times \mathit{dp}_{v,1})$$

$$ \mathit{dp}_{u,1}= \prod(\mathit{dp}_{v,0}+(m-1)\times \mathit{dp}_{v,1})$$
状态方程中，$v$ 是 $u$ 的子结点。

若 $u$ 是叶子结点，则有 $ \mathit{dp}_{u,0}= \mathit{dp}_{u,1}= 1$。

所求的答案为 $\mathit{dp}_{1,0}+m\times \mathit{dp}_{1,1}$。

## 2.源程序。
```c
#include <stdio.h>
#define MOD 1000000007
struct Edge
{
    int to,next;
}e[2000005];
int head[1000005]={0};
long long dp[1000005][2];
int n,m;
void dfs(int u, int fa)
{
    dp[u][0] = dp[u][1] = 1;
	int i;
    for (i=head[u];i;i=e[i].next)
    {
        int v = e[i].to ;
        if (v==fa) continue;
		dfs(v, u);
		dp[u][0] = dp[u][0] * (dp[v][0] + dp[v][1] * m % MOD) % MOD;
		dp[u][1] = dp[u][1] * (dp[v][0] + dp[v][1] * (m - 1) % MOD) % MOD;
    }
}
int main()
{
	scanf("%d%d",&n,&m);
	int i,cnt=0;
	for (i = 1; i < n; i++)
    {
		int u,v;
        scanf("%d%d",&u,&v);
        e[++cnt].next = head[u];   // 边数组中加入2条边
        head[u] = cnt;
        e[cnt].to = v;
        e[++cnt].next = head[v];
        head[v] = cnt;
        e[cnt].to = u;
	}
	dfs(1, 0);
	printf("%lld\n", (dp[1][0] + dp[1][1] * m % MOD) % MOD);
	return 0;
}

```
