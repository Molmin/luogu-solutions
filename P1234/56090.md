## 呵呵

我随手打出来了1234，然后我发现这题，然后发现还是比较水的。

俗话说的好，做题先看数据：1≤n,m≤1000

啊，好舒服的数据啊，一看就知道可以O(nm)模拟
让我们再看看输入样例


```
5 5
heheh
heheh
heheh
heheh
heheh

```
~~刚开始我以为斜的也算，然后交上去就WA了~~

核心思想：枚举起点即可，然后判断它与后面3个字母有没有组成hehe（行），再判断它与下面3个字母有没有组hehe（列）,
然后再反的找一遍(下面代码已经转化成正着找了）{反着找hehe=正着找eheh}

接下来是代码时间
```
#include<bits/stdc++.h>
using namespace std;
char a[1500][1500];
int n,m,i,j,k,t,x,y;
int ans;
int main()
{
    cin>>n>>m;
for (i=1; i<=n; i++)
  for (j=1;j<=m; j++)
    cin>>a[i][j];
for (i=1; i<=n; i++)
  for (j=1; j<=m; j++)
  {
    if ((a[i][j]=='h'&&a[i][j+1]=='e'&&a[i][j+2]=='h'&&a[i][j+3]=='e')) 
      ans+=1;//找到行里面的正hehe
     if (a[i][j]=='h'&&a[i+1][j]=='e'&&a[i+2][j]=='h'&&a[i+3][j]=='e')
     ans+=1;//找到列里面的正hehe
   }
for (i=1; i<=n; i++)
  for (j=1; j<=m; j++)
  {
    if ((a[i][j]=='e'&&a[i][j+1]=='h'&&a[i][j+2]=='e'&&a[i][j+3]=='h')) 
      ans+=1;//找到行里面的反hehe，我这里直接转化为找eheh了      
    if (a[i][j]=='e'&&a[i+1][j]=='h'&&a[i+2][j]=='e'&&a[i+3][j]=='h')
      ans+=1;//找到列里面的反hehe，我这里直接转化为找eheh了
  }
  cout<<ans;
  return 0;
}
```
总之，这题还是比较水的，至于为什么是黄题，我也不知道。

附赠noip用数据来判断的表格：

```
20：2^20=一百万，O(2^n)，搜索

100：100^3=一百万，O(n^3)，Floyd/搜索

1000：1000^2=一百万，O(n^2)，动态规划/图论

500000：O(nlog(2,n))，二分答案/二分查找/快排/归并

1000000：O(n)或 O(1)，数学问题/改变思维方向/贪心
```

（哦，在某位大佬的CSDN里面可以找到的）