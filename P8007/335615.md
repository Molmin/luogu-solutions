#### 题目大意


------------
给定一个长度为 $n$ 的只含有左括号、右括号和问号的括号序列，可以在问号处填上左括号或者右括号使得整个序列成为一个**无限长的**合法的括号序列，输出所有可能的方案数对 $998244353$ 取模的结果。

- 这里的无限长的合法的括号序列指的是可以由一个长度为 $n$ 的括号序列 $S_0$ 经过无限次重复得到的（如果实在理解不了这句话可以仔细阅读原题中的样例解释部分）


#### 思路分析


------------


首先考虑在一般情况下的括号序列需要满足以下条件：

- 对于每一个左括号，在它的右边都有唯一的右括号与它对应

再看这道题，题目描述看似唬人，实则是大大降低了此题的难度。

由于一个括号序列是无限长的，所以只要使得在 $S_0$ 中的左括号数量等于右括号数量。~~就这么简单？没错，这题还真就这么简单~~

所以答案就呼之欲出了，只需要统计出问号的数量、当前已经有的左括号数量和当前已经有的右括号数量。所以题目就转化成了在问号中填上整个序列长度一半减去当前已经有的左括号数量或者当前已经有的右括号数量。

最后，由于题目中存在分数且存在取模运算，故不能直接对分数进行取模，只需求出逆元即可。

~~别忘了开 `long long`~~

#### 代码实现


------------
```cpp
int quick_power(int x,int k){
	long long tmp = 1;
	while(k > 0){
		if(k & 1) tmp = tmp * x % mod;
		x = x * x % mod;
		k >>= 1;
	}
	return tmp;
}
int main(){
	n = read();
	scanf("%s",s+1);
	for(int i=1;i<=n;i++){
		if(s[i]=='(') cnt1++;
		if(s[i]==')') cnt2++;
	} 
	res = n - cnt1 - cnt2;
	if(cnt1 > n/2 || n % 2 == 1 || res + cnt1 < n/2){
		printf("0\n");
		return 0;
	}
	int sum = 1, ans = 1;
	for(int i=1;i<=res;i++){
		sum = sum * i % mod;
		if(i == n / 2 - cnt1) ans = ans * quick_power(sum , mod - 2) % mod;
		if(i == res - n/2 + cnt1) ans = ans * quick_power(sum , mod - 2) % mod;
	}
	ans = ans * sum % mod;
	printf("%lld\n",ans);
	return 0;
}
```
