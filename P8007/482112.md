## P8007 「Wdsr-3」永远与须臾的走廊
我爱数数题。
## 1.Analysis
首先你只需要考虑什么样的括号符合条件。

我们按照正常的思路把 $\texttt($ 视为 $+1$，$\texttt{)}$ 为 $-1$。

然后你会发现如果左括号和有括号的数目不相等，那么我们的数列前缀和将会越来越大或小，永远不会到 $0$。

所以左括号和右括号的数目一定要相等。

但是这个时候就会有人问了：要是他不是一个合法括号序列怎么办？

没有关系。我们考虑到数列前缀和会在某个地方产生最低点 $-x$。因为最后的前缀和还是 $0$，所以在前缀和数列跌到最低谷后，一定会再提升 $x$。这个时候我们只需要让他先提升这个 $x$，再跌 $x$，就可以让它成为合法括号序列了。那么怎么先提升 $x$ 捏？因为这个序列是无限的，你可以永远相信前面一个括号序列，他会给你补给 $x$。

如果我这么说很抽象，你可以把问题转换成：

> 把一个括号序列的最左面的一个串扔到最右面去，让它为合法括号序列。比如我们把 $\texttt{\red{()())}(()}$ 变换成 $\texttt{(()\red{()())}}$。

原因很简单，相当于你只是更改了这个无穷的括号序列的分段罢了，原来是按照给定的括号序列分段，但是现在用新的分段使其为合法括号序列，本质是一样的。

所以问题就很自然的变成了简单的配对。如果有 $q$ 个问号，$l$ 个左括号，$r$ 个右括号，那么答案就是：

考虑计算左括号的出现次数。

首先只有 $r-l$ 个需要配对的括号，其他的都配对好了。

然后你会发现还有 $q-r+l$ 个位置没有填充，这些都是一对对的括号，所以要除以 $2$。

也就是说，我们只需要在 $q$ 个位置中选出 $\dfrac{q-r+l}2$ 个位置填充左括号。剩下的都是右括号。

如果其中算出来有负数，说明不存在答案。注意判断奇。
## 2.Code
```cpp
// quick_power
ll qpow(ll a, ll b = mod - 2, ll p = mod) { ll res = 1; a %= p; while(b) { if(b & 1) res = res * a % mod; a = a * a % p; b >>= 1; }
ll fac[MAXN];
ll C(ll n, ll m, ll p = mod) {
    return (m < 0 || n < m) ? 0 : fac[n] * qpow(fac[m]) % p * qpow(fac[n - m]) % p;
}
int main(){
   	fac[0] = fac[1] = 1;
	rre(i, MAXN) fac[i] = fac[i - 1] * i % mod;
	int n;
	cin >> n;
	if(n % 2 == 1) {
	    cout << 0 << endl;
	    return 0;
	}
	string str;
	cin >> str;
	int cntl = count(str.begin(), str.end(), '(');
	int cntq = count(str.begin(), str.end(), '?');
	int cntr = count(str.begin(), str.end(), ')');
	return print<ll>(C(cntq, (cntq + cntl - cntr) >> 1)), 0;
}
```