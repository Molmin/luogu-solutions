题面很简洁，这里不做多说。

## Part 1

可以想到暴力枚举每一条鱼，是否能吃掉所有的鱼。

假设现在枚举第 $i$ 条鱼能否成为最后一条鱼，接下来应该一次一次地枚举鱼 $i$ 能否吃掉哪些鱼，直到第 $i$ 条鱼无法再吃掉其它的鱼或者只剩它一条鱼。

如果特别构造一些数据，使得每一次枚举只能枚举出一条鱼，那么时间复杂度将会达到 $\mathcal{O}(n^3)$。

## Part 2

我们需要避免每一次枚举只枚举一条鱼的状况，不难看出，先吃掉能吃的鱼显然不劣，于是可以将鱼按照其质量 $a_i$ 升序排序。

接下来进行枚举，枚举每一条鱼 $i$ 时，只需要按照顺序依次每一条鱼能否被鱼 $i$ 吃掉，最后判断吃掉的鱼的数量是否达到 $n-1$ 即可。

如果构造数据使得许多的鱼都能吃掉其它所有鱼，那么时间复杂度将会达到 $\mathcal{O}(n^2)$。

## Part 3

可以证明，如果一条鱼 $i$ 的质量 $a_i$ 小于另一条鱼 $j$ 的质量 $a_j$，且鱼 $i$ 可以成为最后一条鱼，那么鱼 $j$ 一定可以成为最后一条鱼。

用一个（可能）易于理解的方式说明：因为鱼 $j$ 的初始质量就比鱼 $i$ 大，原本能吃的鱼的数量就不会比鱼 $i$ 更少，所以若鱼 $i$ 可以成为最后一条鱼，鱼 $j$ 就一定能成为最后一条鱼。

知道了这个结论，我们就可以确定：将鱼按照质量升序排序后，有一个分界点 $k$，使得前 $k$ 条鱼无法成为最后一条鱼，后 $n-k$ 条鱼一定可以成为最后一条鱼。

于是只需要排序后二分分界点 $k$ 即可，时间复杂度为 $\mathcal{O}(n\log n)$。

核心代码（个人码风，不喜勿喷）

```c++
inline bool check(int mid)	//检查当前二分的鱼能否成为最后一条鱼。
{
	long long sum=a[mid].val;
	int num=0;
	for(int i=1;i<mid;i++)
		if(sum>a[i].val)
		{
			sum=sum+a[i].val;
			num++;
		}
	for(int i=mid+1;i<=n;i++)
		if(sum>a[i].val)
		{
			sum=sum+a[i].val;
			num++;
		}
	return num==n-1;
}
```