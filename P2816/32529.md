Ps.
昨天写题解的时候发明了一种格式233以后的题解就都是这个形式了。

居然没有人写题解啊~既然今天考试题是这个那就写一下思路吧（前后没有任何联系的一句话2333）。

————————————————————————————

**题目要求**

每块积木都被用上，并且积木列数最少。

**思路分析**

很容易想到贪心的解法。但既然是道绿题（绿题怎么了！绿题招你惹你啦！），那么肯定不会是排个序取最大值能解决的。

开始的时候我是认为只要从下往上累加的时候放最大的就好了，但是对于这样一组样例：

-7
-4 3 2 2 1 0 0

如果一直取最大值，那么得到的ans是3：

-4 3 2 2 1

-0
-0
但很显然正解是2：

-4 3 2 1 0

-2 0
所以我们需要稍微的思考一下，如何对这个贪心方案进行优化？

首先，将x[]数组按从大到小的顺序sort一遍，然后使用一个vis[]数组来记录积木的使用情况（因为只能使用一次），记使用过为1，未使用过为0。从头开始枚举，定义一个计数器temp，如果还有能够塞到底部的积木就加1，直到不能再放，然后重新枚举，同时ans++，计数器temp清零即可。

代码如下：（不要直接复制了交，有坑233）

```cpp
#include<algorithm>
#include<iostream>
#include<iomanip>
#include<cstring>
#include<cstdio>
#include<cmath>
using namespace std;
int n,temp=0,ans;
//temp用来记录第i个积木前累积的积木个数，ans记录列数 
int x[5003],vis[5003]={0};
//用vis[]来对已经使用过的积木进行标记 
int main()
{
    freopen("box.in","r",stdin);
    freopen("box.out","w",stdout);
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
    {
        scanf("%d",&x[i]);
    }
    sort(x+1,x+n+1);//将x[i]从小到大进行排序 
    for(int i=1;i<=n;i++)
    //从上往下枚举 
    {
        if(!vis[i])//未被标记
        {
            vis[i]=1;//使用，将其标记 
            ans++;//开始形成新的一列 
            temp=0;//计数器清零 （也可以让temp=1,这时下面的特判要改成temp<=x[j]）
            for(int j=i+1;j<=n;j++)//从i开始往后枚举 
            {
                if(!vis[j]&&temp+1<=x[j])
                //如果未被使用并且将它放入这列积木底部不会使其不高兴 
                {
                    vis[j]=1;//使用 
                    temp++;//计数器加一 
                }
            }
        }
    }
    cout<<ans<<endl;
    fclose(stdin);
    fclose(stdout);
    return 0;
}
···