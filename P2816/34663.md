当我看到这题时，心中贪心，脑中DP。

但后来我发现这题太傻逼了。

##首先明确，只要某积木上方的积木情绪值小于它，它就一定不会生气（不会不合法）。##

那么对于某块积木来说，如果他很小，他肯定喜欢最小的那一堆放在自己身上（开始讲哲理了）。

那么我们把输入的排序一下，在用一个数组来存现在每一堆的个数。

把最小的一堆放在现在最小的积木上，一定是最优的，也是最稳定的，为什么呢？讲完过程你或许会明（meng）白（bi）。

首先最小的一堆都放不到这块积木上肯定要开新堆（ken）。

放得下的话就放，这个更新后的堆一定也能再次放到下一个最大的上面（不清楚的看第三排文字），但是这样就会出现一个非常大的堆（贼不好，差距太大），所以我们在放之前都要从小到大排序，这样每次都是最小堆放上最小积木，一定程度上使每个堆平衡。

代码如下（看不懂还是算了，我写题解时也很懵逼（啊，我在写啥？怎么过的？））

```cpp
#include <iostream>
#include <cstring>
#include <cstdio>
#include <algorithm>
using namespace std;

int a[10005];
int b[10005];
int p=1;


int main()
{
    int n;
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
    {
        scanf("%d",&a[i]);
    }
    b[1]=1;
    sort(a+1,a+1+n);
    int ans=1;
    for(int i=2;i<=n;i++)
    {
        if(b[1]<=a[i])
        {
            b[1]+=1;
        }
        else
        {
            p++;
            b[p]=1;
        }
        sort(b+1,b+p+1);
    }
    cout<<p<<endl;
    return 0;
}