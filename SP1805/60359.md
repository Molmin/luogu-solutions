## 题解 SP1805 【HISTOGRA - Largest Rectangle in a Histogram】

题目传送门：：

https://www.luogu.org/problemnew/show/SP1805#sub

**原题**：poj 2559

===================分割线===================

本人感想：**真是一道好题**~~~！！！

本题是**单调栈**好题哦！~~（老师语）~~

===========================================

#### 题面~~（人性）~~翻译：：

给定从左到右多个矩形，已知这此矩形的宽度都为1，长度不完全相等。

这些矩形相连排成一排，求在这些矩形包括的范围内能得到的面积最大的矩形，输出该面积。

**所求矩形可以横跨多个矩形**，但不能超出原有矩形所确定的范围。


===========================================

## **算法分析&&具体操作：**

对于此题，我们需要**从左向右求出每个矩形向右能够扩展到的最大连续宽度**

**能够扩展的条件**：**矩形高度大于等于当前矩形高度**

那么我们求完之后算出面积取 max 即可

显然朴素算法是不行的，我们需要用到**单调栈**

（听说DP也可以，只是很慢，可能不过）

准确的说是：

**单调栈维护从起点矩形到当前矩形的高度递增序列**

如果**当前矩形高于栈顶矩形**，我们就一直将栈中元素弹出，**直到遇到低于当前点的矩形**，**以此来维护栈的递增性**，显然**此时的点最远可以扩展到当前栈元素的位置top-1**，即我们找到了**当前点的扩展边界**，同时**把弹出的矩形合并再压入栈**。

建立一个单调（递增）栈，所有元素各进栈和出栈一次。**每个元素出栈的时候更新最大的矩形面积**。

设栈内的矩形为一个二元组（h, w），h表示矩形的高度，w表示矩形的宽度。

如何**入栈并更新**呢？

① 如果**当前元素比栈顶元素大或者栈为空**，则直接压栈（h，1）；

② 如果**当前元素小于等于栈顶元素**，则**出栈合并矩形**，**直到当前元素大于栈顶元素或者栈为空时**，**合并矩形**（h,sum_width）**入栈**。

③在出栈的过程中**更新最大面积和累积宽度**

那么重复上述①~③操作，我们可以线性O(n)求出每一组数据的解

### **注意事项：**

单调栈要维护两个信息，一个是**高度**，另一个是**宽度**（便于计算矩形面积）

同时令H[n+1]=0，以保证所有矩形全部弹出栈
（最后没有矩形剩余在栈中）

**~~分析到此结束~~**

下面上代码~~~（code里也有解释）


===========================================

    #include<iostream>
    #include<cstdio>
    #include<cmath>
    #include<algorithm>
    using namespace std;
    typedef long long ll;
    const int inf=1e9+7;
    inline ll read()
    {
  	    ll p=0,f=1;char c=getchar();
  	    while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}
  	    while(c>='0'&&c<='9'){p=p*10+c-'0';c=getchar();}
  	    return 1ll*f*p;}
    struct rect
    {
	    ll h,w;//定义矩形(rectangle)高度h,宽度w
    };
    ll n,H[200050],ans;
    void Monotone_stack_solve()//单调栈算法
    {
    	ans=0;
	    rect S[100050]={(rect){0,0}};
	    //数组模拟矩形的高度单调栈
	    int top=0;//栈顶 
	    H[n+1]=0;
	    //保证第n+1个矩形高度为0,能保证扫描1~n矩形结束后栈内没有剩余矩形 
	    for(int i=1;i<=n+1;i++)//1~n+1个矩形扫描一遍 
	        {
	    	    if(H[i]>S[top].h)
			    //如果当前矩形高于栈顶直接入栈,宽度为1(符合高度单调递增性质)
	    	       S[++top]=((rect){H[i],1});
			    else//否则就持续弹出栈顶矩形合并 
			       {
			   	    ll width=0;//弹出的栈顶矩形合并总宽度 
			   	    while(S[top].h>H[i])//不满足高度单调递增继续弹出 
			   	          {
			   	      	    width+=S[top].w;//累计宽度 
			   	      	    ans=max(ans,1ll*width*S[top].h);//面积取max 
			   	      	    //更新面积(长乘宽)
			   	      	    top--;//弹出堆顶矩形
					         }
			   	    S[++top]=((rect){H[i],width+1});
			   	    //把合并好的新矩形入栈(高为H[i],宽为width+1)
			       }
		    }
	    printf("%lld\n",ans); 
    }
    int main()
    {
        while(1)//多组数据
              {
          	    n=read();
          	    if(!n)break;
          	    memset(H,0,sizeof(H));
          	    //初始化
          	    for(int i=1;i<=n;i++)//读入每个矩形高度 
			          H[i]=read();
          	    Monotone_stack_solve();//单调栈算法求解 
		      }
  	   return 0;
    }

===========================================

没啦~~~感谢阅读>=<

希望大家好好理解一下本题，这题还是比较经典的**单调栈**（Monotone_stack）听说紫书上也有

最后推广一下我的博客：

https://www.luogu.org/blog/new2zy/

拜拜~~~


