一道毒瘤计数题。

首先我们可以将题意转化一下，就是说：每次操作所有的气球都会 $-1$,现在可以选择一种 $+k$。不能出现负数。求最后的颜色序列数。

形式化地，设每一种颜色选择了 $k_i$ 次，求

$$\forall a_i,a_i+k\times k_i\geq\sum_{i=1}^k{k_i}$$

$\{k_i\}$ 的方案数。

记 $\sum_{i=1}^k{k_i}$ 为 $Sumk$。

发现这个东西比较难做，因为和 $Sumk$ 有关。

于是我们想到，是否是通过枚举 $Sumk$ 来完成计数？

那么一个重要且显然的问题就是:**$Sumk$ 的取值范围是多少？**

这将会是解题的关键。

---

先来看一下其它一些结论。

对于每一个元素，它不会不合法的充要条件是：

在前 $a_i+1$ 轮，它至少选择一次；在前 $a_i+k+1$ 轮，至少选择两次；在前 $a_i+pk+1$ 轮中，它至少选择 $p+1$ 次。当然如果操作数量是有限的，保证在所有操作中都符合即可。

因为每一次都只能选择且必须选择一种颜色，仔细想想会有两种情况：一是到一定范围就再也无法续命，有太多的颜色需求；另一种是可以无限地操作下去。

有一个结论：如果是前一种情况，则总操作数不会超过 $k - 1$。

因为：每种颜色最迟的选择点是 $a_i+k+1$，是大于 $k$ 的，我们在前 $k$ 轮就可以将所有颜色都选一遍，$k$ 轮之后也同理，保证不会去世。所以如果不是这样的话，必然在 $k$ 轮之前游戏结束。

**注意：下面称一个操作为"轮"或"次"，称一段 $k$ 次操作为回合。不要混淆。**

---

考虑有限轮怎么做。

首先需要找到最多可以多少轮。

显然就是当所有请求相加大于目前考虑到的轮数时，这个右端点就无法取到了。

因为值域不大，$10^6$，这个可以在数轴上标记，然后做前缀和。具体是：

```cpp
	k = read();
	n = k + MAXN;
	for(int i = 1;i <= k;i++) {
		a[i] = read();
		for(int j = a[i] + 1;j <= n;j += k) p[j]++;
	}
	for(int i = 1;i <= n;i++) {
		p[i] = p[i - 1] + p[i];
		if(p[i] > i) n = i - 1;
	}
```

其中 $n$ 就是取到轮数的右边界。一开始取到 `k + MAXN` 相当于无穷大，但是有特殊意义，后面提到。

我们现在就可以喜闻乐见地枚举 $Sumk$，并统计方案数了。

设当前我们枚举到 $Sumk = x$。

那么如何统计呢？发现，在全部 $x$ 个操作中，有若干个（可以像前面所说用前缀和统计，即 $p_x$ 个）操作的对象是固定的，他们带来的影响也是固定的。注意操作顺序和结果不相关。而剩下 $x - p_x$  个操作对象随便。

要求的就是 $k$ 种颜色中无序安排 $x - p_x$ 个操作的方案数（可以不放），这就是经典模型了,答案即为

$$\binom{x - p_x + k - 1}{k - 1}$$

---

现在考虑一下无穷多个操作的情况。

无穷多个操作！是否就是无穷多个情况呢？肯定不是的~~不然怎么做~~。也就是说，在一定范围以外的操作，取到的方案都已经在前面取到过了。因此我们认为可能有一个循环节。

下面试图说明这个循环节为 $k$。即：对于一个 $Sumk = p$ 和 $Sumk = p + k$，前者取到的方案一定包含在后者中。**注意这个循环并不是从 $0$ 就开始的。**

则对于 $Sumk = p$ 时的一种操作序列，每种颜色的操作次数为 $k_i$，我们可以在接下来的 $k$ 轮（直到第 $p + k$ 轮）中每种颜色选一次，这样就可以使 $Sumk = p$ 时的**全部**方案对应到 $Sumk = p + k$ 时的**一些**方案。**因为之前的无限回合判定的结论，这样的一个过程中不会出现负数。**

不过反过来是不一定行的。因为有些颜色可能一次也没有选择，也就不能取消选择了。

但是，在 $\max\{a_i\}$ 以外的方案每种颜色肯定都取过一次了。所以如果取 $\max\{a_i\}$ 之后不包含 $\max\{a_i\}$ 的一个回合统计，如果让其中的方案每种颜色都取掉一次操作，也就对应了之前所有回合的方案。而且显然并不一定需要取一个完整的回合。

再往后？显然也是等价的。在代码里取了 $(10^6 + 1,10^6 + 1 + k]$ 来统计。 $\sum_{i = 1}^k{a_i}\leq 10^6$ 也就是 $\max\{a_i\}\leq 10^6$。

如何统计？和前面的组合式是一样的。

于是就是这么毒瘤的了。

---

于是就可以上代码了。

```cpp
#include <cstdio>
#include <iostream>
#include <cstring>
#include <algorithm>

inline int read() {
	int x = 0, f = 1; char ch = getchar();
	while(ch > '9' || ch < '0') { if(ch == '-') f = -1; ch = getchar(); }
	do x = x * 10 + ch - 48, ch = getchar(); while(ch >= '0' && ch <= '9');
	return x * f;
}

typedef long long ll;
const int MAXN = 1000001;
const int mod = 998244353;

int k,n,a[MAXN << 1],p[MAXN << 1];
ll fac[MAXN << 1],ifac[MAXN << 1];

ll C(int n,int m) {
	if(n < m || n < 0 || m < 0) return 0;
	return fac[n] * ifac[m] % mod * ifac[n - m];
}

int main() {
	k = read();
	n = k + MAXN;
	for(int i = 1;i <= k;i++) {
		a[i] = read();
		for(int j = a[i] + 1;j <= n;j += k) p[j]++;
	}
	for(int i = 1;i <= n;i++) {
		p[i] = p[i - 1] + p[i];
		if(p[i] > i) n = i - 1;
	}
	fac[0] = 1;
	for(int i = 1;i <= n + k;i++) fac[i] = fac[i - 1] * i % mod;
	ifac[0] = ifac[1] = 1;
	for(int i = 2;i <= n + k;i++) ifac[i] = (mod - mod / i) * ifac[mod % i] % mod;
	for(int i = 1;i <= n + k;i++) ifac[i] = ifac[i - 1] * ifac[i] % mod;
	ll ans = 0;
	for(int i = n;i > n - k && i >= 0;i--) {
		ans = (ans + C(i - p[i] + k - 1,k - 1)) % mod;
	}
	std::printf("%lld\n",ans);
	return 0;
}
```

### 最后

关于评分：建议紫黑。

还有，这题网上题解较少， cf 的官方题解感觉太晦涩...希望这篇题解能给一点帮助。

如果有问题可以私信本人。