## CF873B Balanced Substring 题解 ##
### 0x00 开始之前 ###
理解题意：  
给出一个整数 $ n $ 和一个长度为 $ n $ 的 $ 01 $ 串，求一个最长的为“平衡串”的子串 **（注意是字串不是子序列）**。     
平衡串的定义：平衡串是一个 $ 01 $ 串，里面 $ 0 $ 的个数与 $ 1 $ 的个数相等。    
判断个数相等暴力是 $ O(n) $ 的。   
枚举区间的两端又是 $ O(n^2) $ 的。   
合起来就是 $ O(n^3) $ 的。   
TLE可是再正常不过了。
### 0x01 前缀和速度优化 ###
这样，有了区间两端之后，经过**前缀和**优化后的暴力变成了 $ O(n^2) $ ，还是有所优化的。  
但是要想明白如何将区间和转化成判断平衡串。   
我们只要把 $ 01 $ 串变成 $ -1 $ 和 $ 1 $ 的串（ $ 0 $ 变为 $ -1 $ ），然后如果区间双端的前缀和相等就说明这个区间是“平衡串”。
### 0x02 时间复杂度优化 * 2 ###
- 假如我们的字符串全为 $ -1 $ ，前缀和数组将会最小，第 $ n $ 项为 $ -n $ 。    
- 假如我们的字符串全为 $ 1 $ ，前缀和数组将会最打，第 $ n $ 项为 $ n $ 。   

我们既然要判断**最长**串，就应该让前缀和中两个相等元素距离最长，而元素在 $ -n $ 到 $ n $ 之间。   
先枚举 $ 0 $ 到 $ n $ 算出对于每一个前缀和的起始点和结束点，再枚举 $ -n $ 到 $ n $ 求最大长度。   
时间复杂度是 $ O(n) $ 的。
### 0x03 代码实现 ###
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[114514],f[114514*2],l[114514*2];
string s;
int main(){
    memset(f,0x3f,sizeof(f));//注意设为0的话开始下标为0的点再待会判断的时候不会被算入（这样了之后判断的就是0x3f3f3f）
    memset(l,0x3f,sizeof(l));
    int n;
    cin>>n>>&s[1];
    //解释：a前缀和数组下表为i，l和f数组下表为前缀和的值
    for(int i=1;i<=n;i++){
        a[i]=((s[i]=='0')?(-1):(1));//将01串改变为-1和1的字符串
        a[i]+=a[i-1];//前缀和
    }
    for(int i=0;i<=n;i++){
        if(f[a[i]+n]==0x3f3f3f3f)f[a[i]+n]=i;//如果枚举到现在还没有枚举到那就设置起始点
        //下标+n因为a[i]的值是在-n到n之间，下标必须非负
        l[a[i]+n]=i;//结束点的设置：i越来越大，不需要max函数设置结束点
    }
    int maxl=0;
    for(int i=0;i<=n*2;i++)maxl=max(maxl,l[i]-f[i]);
    cout<<maxl;
    return 0;
}//结束啦！
```