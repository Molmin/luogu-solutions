emmm……

字符串hash好题
__________________

首先我们先来想一个十分正常的暴力

我们把第二个数字的集合(就是那个最多有1e9个元素的集合)看成一个长度为$m$的01串,如果数字$i$出现在了第二个集合当中那这一位就是1否则就是0

接下来我们将整个集合加上$p$之后的得到的集合其实就是将这个01串循环右移$p$位之后的串

那么我们可以枚举第一个集合(就是那个最多有2e5个元素的集合)中的所有元素,然后让这个01串循环右移一下，最后把这些01串or起来得到一个新的01串,如果这个01串的第x位是0的话我们就无法表示出x这个数字了(因为刚才的暴力事实上是在枚举所有可能的相加情况)

接下来让我们想办法把这个$O(nm)$的暴力变成一个$O(n^2)$的暴力

我们把第二个数字的集合取一下补集(也就是把01串01翻转一下),接下来我们依然枚举一下第一个集合中所有的元素，然后让这个01串循环右移一下,最后把这些01串and一下之后的得到一个新的01串，如果这个01串的第x位是1的话我们就无法表示出x这个数字了(刚才的做法为什么是对的呢？根据德摩根律,一堆数or起来等于一堆数的补集and起来再取补)

那么我们看一下第二个数字的集合01翻转之后什么，显然这就是第一个数字的集合了

而刚才枚举第一个数字集合中的元素然后让这个01串循环右移的行为，其实是枚举了$O(n^2)$个数字相互相加然后对m取模的行为,而我们发现刚才的算法中我们的得到的新的01串中有一位是1当且仅当这个这一位在我们的$n$个01串当中都是1,换句话说，我们$O(n^2)$的枚举这些数字两两相加然后对$m$取模,如果一个数字在这个过程中出现了$n$次那么它不可以被成功表示(因为如果它出现了$n$次就说明它在$n$个01串中都是1)

那么我们现在得到了一个优秀的$O(n^2)$暴力,它有什么用呢？

首先我们会得到一个没什么用的结论是每个数字最多出现$n$次

十分显然，因为在模m剩余系下$a+x$和$a+y$肯定是不一样的(如果x,y小于m并且他俩不一样)

所以如果我们最后得到了一个数字$V$它出现了$n$次,假设有n对二元组$(i,j)$使得$a_{i}+a_{j} \equiv V (\mod m)$的话你会发现这些二元组的$i$值互不相同并且$j$值互不相同

那这又有什么用呢？

接下来的事情就比较玄学了

我们把这些二元组按照$a_{i}$值从小到大排个序

那么我们发现这些二元组的$a_{j}$一定是从大到小的一段和从大到小的一段拼到一起的

为什么呢？

因为我们发现一个十分重要的事实是$a_{i},a_{j} \leq m-1$

所以尽管我们的限制条件是$a_{i}+a_{j} \equiv V (\mod m)$,但是这两个数字的和最多有$V$和$V+m$两种取值

因此我们发现肯定是这个序列前一段$a_{j}$和它对应的$a_{i}$加起来是$V$的

然后后半段$a_{j}$加上它对应的$a_{i}$加起来就变成了$V+m$

我们的$a_{i}$是从小到大排序的，因此我们第一段j和第二段j都是从大到小排好序的并且第二段的最小值应该比第一段的最大值大(觉得不对的话可以自己画个图手玩一下)

换句话说我们的$a_{j}$应该是从大到小排好序的序列一个**轮换**，那么这样的轮换只有$O(n)$种我们可以挨个枚举一下进行验证(对了这样我们顺便证明了不能被表示的数最多$n$个)

那怎么验证呢？

我们现在相当于问你两个数组加起来是否是同一个数字

这个问题不是很好解决啊……

不过如果让我们牺牲一下正确率的话我们还是能办到的

那就是字符串$hash$

如果我们知道一个数组$A$的hash值和数组$B$的hash值的话，那么我们是可以计算出数组$A$和数组$B$按位相加的数组的$hash$值的，直接把A的hash值和B的hash值相加就可以了，同理我们无脑的把hash值相减就可以得到两个数组按位相减的hash值了

好了问题来了我们现在枚举了一个$a_{j}$从大到小排序的轮换，并且根据我们刚才的推倒过程来讲，前一半从大到小的$a_{j}$加上对应的$a_{i}$的结果应该是$V$，后一半从大到小的$a_{j}$加上对应的$a_{i}$的结果应该是$V+m$

问题来了处理$V+m$的时候我们的base明显是要炸掉的，此时我们将两个数组按位相加的得到的hash值没一点意义

怎么办呢？

转化一下

$$a_{i}+a_{j}=V+m$$

$$a_{i}-(m-a_{j})=V$$

好了现在我们的base就不会炸掉了，所以我们分别维护轮换的前半部分(这部分的字符串依然是$a_{j}$)和后半部分(这个时候的字符串中的值就变成了$m-a_{j}$)了

然后我们生成两个串按位相加后模m的hash值的时候就将前半部分的hash值相加，后半部分的hash值相减最后两个拼一起就可以生成我们想要的字符串了

好了最后一个问题，我们总算是得到了两个字符串按位相加的字符串的$hash$值了，怎么判断它是否是一个合法的串呢？

换句话说我们希望知道这个串是否是一个全部是一个数值比如说"xxxxxx"构成的串，并且如果它满足条件的话我们希望可以把$x$反解出来

怎么做呢？

假设这个字符串的hash值是$T$

那么这个字符串直接在最高位补x和将整个字符串右移一位后在末尾加x所得的应该是同一个字符串

所以我们可以列出这样的一个方程

$$baseT+x=T+base^{n}x$$

稍稍做一下变换就可以解出$x$了

$$x=\frac{(base-1)T}{base^{n}-1}$$

问题来了

就算我们的字符串是一个非法的字符串我们照样可以根据上面的式子解出一个$x$来……，但是我们知道此时的$x$一定是非法的,该怎么判断解的合法性呢？

~~双哈希一下比较一下解出来的两个x是不是一样就行了~~

嗯，解决方案就是如此的粗暴,不放心这个解法的正确性可以上三哈希

然后这题就做完了

所以我们的算法流程就是枚举轮换,按位相加，最后通过双哈希解出两个x来看一下是不是一样的，是一样的就是我们要的一个解

上代码~

```C
#include<cstdio>
#include<algorithm>
#include<map>
using namespace std;const int N=2*1e5+10;typedef long long ll;
inline ll po(ll a,ll p,ll mod){ll r=1;for(;p;p>>=1,a=a*a%mod)if(p&1)r=r*a%mod;return r;}
const ll mod1=1e9+7;const ll mod2=1e9+9;const ll bas=1e9+3;int n;int m;
ll a[N];ll b[N];ll pa1;ll pa2;ll sa1;ll sa2;ll pb1;ll pb2;ll sb1;ll sb2;
ll mi1[N];ll mi2[N];ll imi1[N];ll imi2[N];ll ans[N];int tp;ll inv1;ll inv2;
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++)scanf("%lld",&a[i]);sort(a+1,a+n+1);
    for(int i=1,j=n;i<=n;i++,j--)b[j]=a[i];
    mi1[0]=1;for(int i=1;i<=n;i++)(mi1[i]=mi1[i-1]*bas)%=mod1;
    mi2[0]=1;for(int i=1;i<=n;i++)(mi2[i]=mi2[i-1]*bas)%=mod2;
    //imi1[0]=1;for(int i=1;i<=n;i++)(imi1[i]=imi1[i-1]*750000005)%=mod1;
    //imi2[0]=1;for(int i=1;i<=n;i++)(imi2[i]=imi2[i-1]*166666668)%=mod2;
    for(int i=n;i>=1;i--)
        pa1=(pa1*bas+a[i])%mod1,pa2=(pa2*bas+a[i])%mod2,pb1=(pb1*bas+b[i])%mod1,pb2=(pb2*bas+b[i])%mod2;
    inv1=po(po(bas,n,mod1)+mod1-1,mod1-2,mod1);inv2=po(po(bas,n,mod2)+mod2-1,mod2-2,mod2);	
    for(int i=n;i>=0;i--)
    {
        ll t1=((pa1+pb1)+(sa1+mod1-sb1))%mod1;ll x1=(bas-1)*t1%mod1*inv1%mod1;
        ll t2=((pa2+pb2)+(sa2+mod2-sb2))%mod2;ll x2=(bas-1)*t2%mod2*inv2%mod2;
        if(x1==x2&&x1<m)ans[++tp]=x1;
        pa1=(pa1+mod1-a[i]*mi1[i-1]%mod1)%mod1;pa2=(pa2+mod2-a[i]*mi2[i-1]%mod2)%mod2;
        sa1=(sa1+a[i]*mi1[i-1])%mod1;sa2=(sa2+a[i]*mi2[i-1])%mod2;
        pb1=(pb1+mod1-a[i])*750000005%mod1;pb2=(pb2+mod2-a[i])*166666668%mod2;
        sb1=(sb1*750000005+mi1[n-1]*(m-a[i]))%mod1;sb2=(sb2*166666668+mi2[n-1]*(m-a[i]))%mod2;
    }printf("%d\n",tp);
    //for(int i=1;i<=tp;i++)ans[i]%=m;
    sort(ans+1,ans+tp+1);
    for(int i=1;i<=tp;i++)printf("%lld ",ans[i]);return 0;
}

```





