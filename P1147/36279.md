看看前面各位dalao的方法，感觉都比较高端，我这个蒟蒻来自告奋勇的说一下我的暴力方法（真的很暴力/doge）

这道题因为是要的是连续的自然数，即为等差数列，所以他的中项一定是一个整数（奇数）或是两个相邻整数的平均数即n.5（偶数）且等于平均数。

所以我们就暴力的循环所分分出数字的个数，用总数相除就是中间那个数。若组数是奇数，则中间那个数必须是整数，若组数是偶数，则中间的那个数一定得是 n.5 。

如果判中了，就意味着我们知道了一个连续自然数列的中间的数且知道了这个数列的长度，所以就可以轻松的输出首相和末项了。

```cpp
#include<stdio.h>
#include<stdlib.h>
int main()
{
    int i,j,n;
    double ans;
    scanf("%d",&n);
    for(i=n-1;i>1;i--)
    {
        ans=(double)n/(double)i;
        if(i%2==1&&ans-(int)ans==0&&ans>=i/2+1&&n-ans+1>=i/2+1)
        printf("%d %d\n",(int)ans-i/2,(int)ans+i/2);
        if(i%2==0&&ans-(int)ans==0.5&&(int)ans>=i/2&&n-(int)ans>=i/2)
        printf("%d %d\n",(int)ans-i/2+1,(int)ans+i/2);
    }
}
```
注：记得要判断这一列数会不会出界。
虽然复杂度是O（n),但是我觉得i循环的其实和结尾应该是可以缩小不少的，但我懒得算了，反正Nmax也就2,000,000
