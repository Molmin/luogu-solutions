 ### 本蒟蒻又想发题解了~~（怕是不能过）~~
 各位神犇记得小学学过等差数列求和公式吗？

- 等差数列之和等于其首项加末项的和乘以项数除以2。

 ~~（我是个听话的蒟蒻，背的可熟练了）~~

假如以i表示本题要求的首项的值，j表示本题要求的末项的值，可以带入公式（因为知道等差数列的两数之间的差等于1，故项数可求）

**我的化简~~（复杂化）~~如下**

------------

```cpp
(i+j)*(j-i+1)/2=n //原公式,需要保证j>i
i*j-i*i+i+j*j-i*j+j=2*n //嗯,拆开括号,移项
2*n+i*i-i=j*j+j //随意化简一下之后
```
------------
本蒟蒻比较垃圾,只知道可以暴力嵌套循环来求i和j,但是可以依靠已知的条件化简一下过程：

1. j>i,故内嵌的求j循环可以直接从**i+1**开始循环

2. 在内嵌求j循环中,**2\*n+i\*i+i**的值是不变的，所以只用在进入内嵌循环前求一遍,不必反复求（特别是在用于判断时，由于进行判断次数奇多，肯定超时）

3. 在内嵌求j循环中,如果符合**2\*n+i\*i+i=j\*j+j**便可以直接输出，并且开始求下一个i值去了，因为此i值最多只能有一种解

4. 在内嵌求j循环中,如果**2\*n+i\*i+i>j\*j+j**则说明j值小了，则继续循环;反之,如果**2\*n+i\*i+i<j\*j+j**则说明j值已经过大,此i值没有解了，便可以去下一个试i值了。

### 那么上代码，代码很短......~~也很暴力。~~

------------


```cpp
#include<cstdio>
int n;
int main()
{
	scanf("%d",&n);
	for(int i=1,tmp=2*n+1*1-1;i<=n/2;++i,tmp=2*n+i*i-i)
		for(int j=i+1;j<n;++j)
		{
			if(tmp<j*j+j)
				break;
			else 
				if(tmp==j*j+j)
				{
					printf("%d %d\n",i,j);
					break;
				}
		}
	return 0;
}
```
------------

代码还有很多可以优化的,比如算出更接近的j值，减少内嵌求j循环的循环次数，思路如下（只有思路，没写代码...）

------------
```cpp
2*n+i*i-i=j*j+j //上面的化简代码
j=sqrt(2*n+i*i-i-j) //移项,开根
j<sqrt(2*n+i*i+i) //因为j>0,2*n+i*i-i>j*j
j>i //已知
//所以j可以由ceil(sqrt(2*n+i*i+i))循环到i+1
```
------------

就这些，希望可以帮上各位神犇...