# 题解

其实，我这道题写了很久，但是并不是不会，而是被题面卡住了。

说实话，我觉得这个题面有点差错，下面是我根据自己的理解重新写的题面。

## 题面

总共有 $ N+1 $ 个城镇，每个城镇都被一定数量的怪兽攻击，有 $ N $ 个英雄。

每个英雄可以攻击到自己对应的 $ N_i $ 和 $ N_{i+1} $ 城镇中的怪兽。

问最多可以击败多少个怪兽。

输入共三行，第一行一个数 $ N $，表示英雄的数量。

第二行 $ N+1 $ 个数，分别为 $ A_1,A_2,A_3 \cdots A_{n+1}  $ 表示每个城镇有多少个怪物袭击。

第三行有 $ N $ 个数，分别是 $ B_1,B_2\cdots B_n $，表示第 $ i $ 个英雄可以击败几个怪兽。

输出一个数，最多可以击败多少怪兽。

## 思路

这题的正解应该是 $O(n)$ 算法，~~因为我就是最优解~~ ，因为每个英雄只能攻击自己这个城镇和下一个城镇，所以，很容易就可以想到贪心。

因为如果按顺序扫，自己先打别人的，就没有人打自己的了。

### 证明 
设两个城镇的英雄可以打败的怪兽数量分别是 $\texttt x$ 和 $\texttt y $，若可以打完自己的，显然继续去打别人的是一定最优的~~总不能待着看戏吧~~。

若 $\texttt x $ 先打别人的，并且自己还不能够将自己的打完。

将别人的打完了，那等到 $\texttt y $ 时，$\texttt y $只能打下一个人的怪兽了。

显然，若 $\texttt y $ 足够大，将会剩下许多，而 $\texttt x$ 那边又没打完。这样就会浪费很多。

这里需要注意有一些坑点需要打 `long long` ，数据最大可以到 $ 10^{14} $ 会爆 `int` 。

## 代码（请勿抄袭）
```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,i,j,a[100010],b[100010],ans,here;
int main(){
	ios::sync_with_stdio(false);//读入优化
	cin>>n;
	for(i=1;i<=n+1;i++)cin>>a[i];//每个城镇的怪兽数量 
	for(i=1;i<=n;i++)cin>>b[i];//每个城镇怪物的数量
	for(i=1;i<=n;i++){//循环英雄
		if(a[i]<=0)goto here;//怪兽已为 0 直接打下一个城镇的怪兽 
		if(b[i]>a[i]){//英雄多一些
			b[i]-=a[i];
			ans+=a[i];
			here: 
			ans+=min(a[i+1],b[i]);//若a[i+1]<b[i] 说明能全部击败显然答案架上怪兽数量 
			//若a[i+1]>b[i] 说明不能全部击败，答案加上英雄可以打败的数量 
			a[i+1]-=b[i];
		}
		else ans+=b[i];
	} 
	cout<<ans;
}
```
