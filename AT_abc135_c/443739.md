山雨欲来风满楼，不开……见祖宗

以上为本人发离骚不过确实是本题的一个坑点。

#### 题目

题目的意思可以理解为若英雄序号为 $i$,那么他可以击打序号为 $i$ 与 $i+1$ 的怪兽。但双方皆两败俱伤，都会扣去自身的能量，所以请求出英雄们最多能打败多少怪兽。

刚看题目的翻译，我根本不知道后半段，~~这里恕我吐槽一下~~。

#### 分析

此题难度不大，用到了一点点贪心——英雄一定要先打序号与自己相同的怪兽，再打败序号为 $i+1$ 的怪兽。因为，如果英雄先打 $i+1$ 的怪兽，没打赢，但序号为 $i+1$ 的英雄可以碾压它，但却打不了比序号为 $i$ 的英雄还逊色的 $i$ 的怪兽，也就是说，我们能打败的怪兽能量就少了。

所以本题贪心很简单，英雄先打序号与自己相同的怪兽，再打败序号为 $i+1$ 的怪兽。

不过要看一下数据范围每个怪兽的能量为十亿，但是数量却是有十万，如果英雄可以打败他们，那么他们相乘会很打，所以数据类型要开大。

那么我们就可以愉快的做题。

#### 代码
```cpp
#include<bits/stdc++.h>
const int luogu=100010;
using namespace std;
int monster[luogu],hero[luogu];
int main(){
	int n,i,j;long long ans=0;//ans指的是怪兽的能量
	scanf("%d",&n);
	for(i=1;i<=n+1;i++)
		scanf("%d",&monster[i]);
	for(i=1;i<=n;i++)
		scanf("%d",&hero[i]);
	for(i=1;i<=n;i++){
		for(j=0;j<=1;j++){
			if(hero[i]>=monster[i+j]){//分情况讨论
				hero[i]-=monster[i+j];
				ans+=monster[i+j];
				monster[i+j]=0;
			}
			else{
				ans+=hero[i];
				monster[i+j]-=hero[i];
				hero[i]=0;
			}
		}
	}
	printf("%lld\n",ans);
	return 0;
}
```
//不用说谢谢，不因客套，只因能见您的笑容，以及您电脑上的 AC，您已经回报。

//祝大家信息学越来越棒哦！