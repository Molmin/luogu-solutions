看题目有点难，尤其是数据范围小的让人怀疑。但结合一下左偏树的特别，就很容易理解了，其实就是一道递归的水题。


首先要理解一点，不会出现结点只有右子树的情况，也就是一个结点如果有右子树就必须要有左子树。


因此最后插入的那个点一定是从根节点开始一直沿着左边往下的，并且没有右子树。


但满足这个条件的结点可能很多。


如果符合要求的结点x的左子树中包含两个及以上结点并且还有满足条件的结点y，最后插入的一定是x，否则插入y的之前x只有右子树而没有左子树。因此选取满足条件的结点中深度最小的一个。


如果符合要求的结点x的左子树中只包含一个结点y，那么x和y都可以。但在字典序最小的情况下，后插入的点选y。


下面是代码，看不懂可以私信我。


```cpp
    #include<cstdio>
    int a,b,c,d,e,f,g,i,m,n,x[100][10]={0};
    int main()
    {
    scanf("%d",&a);
    for(i=0;i<=a;i++)
    {
        x[i][1]=x[i][2]=x[i][3]=-1;
    }
    for(i=1;i<=a;i++)
    {
        scanf("%d",&b);
        if(b<100)
        {
            x[b][1]=i;
            x[i][3]=b;
        }
        else
        {
            x[b-100][2]=i;
            x[i][3]=b-100;
        }
    }
    c=0;
    for(i=0;i<=a;i++)
    {
        d=c;
        e=-1;
        while(e<0)
        {
            if(x[d][2]==-1) e=d;
            d=x[d][1];
        }
        if((x[e][1]>=0)&&(x[x[e][1]][1]<0)) e=x[e][1];
        x[i][4]=e;
        if(e==c) c=x[e][1];
        else
        {
            x[x[e][3]][1]=x[e][1];
            if(x[e][1]>=0) x[x[e][1]][3]=x[e][3];
            d=x[e][3];
            while(d>=0)
            {
                b=x[d][1];
                x[d][1]=x[d][2];
                x[d][2]=b;
                d=x[d][3];
            }
        }
    }
    for(i=a;i>=0;i--)
    {
        printf("%d ",x[i][4]);
    }
}
```