这题挺好玩的））

话说这题的题面是真的难懂，懂了之后你就会觉得这东西真挺好玩的。

斜队支持的操作非常有个性，你不难发现它几乎每种操作都和左子树有关。然后它插入节点时根节点变为左节点真的是非常的好玩。你理性理解一波，这样下来这棵树是不是越来越像**左偏树**。

然后你就~~非常自然地~~想到左偏树的一些性质，很巧，斜堆也支持。

1. 一个节点如果有右子树，就一定有左子树。

2. 最后插入的节点一定没有右子树。

说一下吧。第一个性质还是非常感性理解的，你既然有了右子树，左子树的优先级都比右子树高那既然右子树有了左子树必须有啊不然那个右子树变左子树了））

第二个性质结合一下斜堆的插入操作理性理解一发也行。你每次插入的时候都是把原来的子树作为新结点的左子树，那样就会产生新的左子树，然后对于新增的那个节点它的原来的根节点跑到左子树上了那不就没有右子树了嘛））

然后你不妨考虑**最后插入的点**。显然如果一个节点没有右子树那么它有可能是最后插入的点。但是满足这样性质的节点不少，所以就这样判断还不行。

看它的左子树，如果它的左子树中还有满足条件（无右子树）的点，则取深度**最浅**的节点更新。

~~为什么不是最深的节点你画个图手玩一下就行了。~~

好吧还是口胡一下。

首先因为我们对于每个节点都搜索它的左子树，所以最终节点肯定在**极左链**上（就是从根节点往下全是左子树的一条链），这非常显然。


不妨令现有两个在极左链上位于同一左子树中的满足条件的节点 $x,y$，然后 $x$ 深度小于 $y$。（即 $x$ 在 $y$ 上面）

那么，如果 $y$ 是最后插入的，又因为 $y$ 比 $x$ 深， $y$ 插入时一定经过了 $x$，则 $x$ 定交换过左右子树。而 $x$ 又满足最终只有右子树的性质，所以在 $y$ 经过前，易知 $x$ 只能有右子树或者没有子树，显然不行。

~~我口胡错了别 d 我。~~

然后字典序排序，如果左子树只有一个节点，那么两个节点都行，按字典序排则权值大的就 dddl 了，扔后面去。

$O(n\log n)$ 的时间复杂度在 $n\le 50$ 的数据上丝毫不带慌的。

话说为什么这题数据这么弱啊暴力应该都能艹过去了（不过会有人用暴力吗）。。

跑一遍 $m \to 1$ ，然后对于每次查询一下最终节点，更新一下，时间复杂度 $O(\log n)$，所以总的时间复杂度 $O(n\log n)$。

$O(n\log n)$ 的时间复杂度还是非常优秀的。