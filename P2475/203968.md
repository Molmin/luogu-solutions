稍微参考了一下题解的做法

发现大致是一个分类讨论的过程！

感觉正着模拟做这个过程非常麻烦，我们处理不了

首先我们倒推一下，尝试根据当前树的结构推出当前最后一个节点是那个

我们不妨在草稿纸上画一下

发现大致是这样的：

一个点往下插入是一直走左儿子，直到结束！

并且这个点只有左儿子！因为根据题意可知最后一个点没有右儿子！

一个点满足条件，有两种情况

1 这个点没有左儿子和右儿子，这点是显然的

2 这个点有左儿子，并且它的左儿子还有左儿子！那么也是可以的！

但是考虑有多个点满足条件，根据字典序原因，我们肯定去深度最小的，因为这是一个

小根堆，深度越小字典序自然越小！

然后我们倒推一下，就可以得出答案！

程序最好递归一下，不断往下的过程递归实现可以理解为插入的反操作！

核心代码如下：

```cpp
inline void Get(int x, int now) {
	if ((!ls[x] && !rs[x]) || (!rs[x] && ls[x] && ls[ls[x]])) {
		ls[fa[x]] = ls[x];
		if (ls[x]) fa[ls[x]] = fa[x];
		ans[now] = x;
		if (!fa[x]) root = ls[x];
		return;
	}
	Get(ls[x], now); swap(ls[x], rs[x]);
}
```


