这题明显是一个深搜

当然我们知道苹果数的顺序不同是算作一种方案的，所以本题最中心的就在于如何去重。

那么我们就可以选取可行方案的一个特殊苹果数序列来搜索，来达到去重的目的。

很容易就能想到不下降（或不上升）的序列吧。

接下来就看一下代码怎么实现。

------------
* 第一点：如何找寻深搜中的$ max i $和 $min i$

深搜的步骤里有枚举的过程，在这里面必须找$i$的最大值和最小值，最小值显然就是上一个盘子里放的苹果，最大值就要保证后面的也能是一个不下降序列。

那不就是剩余苹果在剩余盘子中的平均值吗？

所以得到$maxi=(n-sum)/(m-k+1)$

* 第二点：搜索的次数能否再少一些？

因为和是一定的，所以在搜到第$m-1$个盘子的时候，最后一个盘子的苹果数就已经知道了，所以在放最后一个盘子之前搜索就结束了。

所以结束条件就是$k==m$(而非$k>m$)

最终代码
```
#include<cstdio>
using namespace std;
int ans,n,m,t,sum=0,nextmin=0;
int read()//快读 
{
	int x=0,y=1;
	char c=getchar();
	while(c>'9'||c<'0')
	{
		if(c=='-')y=-1;
		c=getchar();
	}
	while(c<='9'&&c>='0')
	{
		x=x*10+c-'0';
		c=getchar();
	}
	return x*y;
}
void dfs(int k)//放第k个盘子的苹果 
{
	if(k==m) 
	{
		ans++;//方案数加一 
		return;
	}
	for(int i=nextmin;i<=(n-sum)/(m-k+1);i++)//从最小到最大枚举 
	{
		nextmin=i;//将当前盘子放入的水果数记录，保证不下降 
		sum+=i;//总苹果数加上当前盘子的苹果 
		dfs(k+1);//搜索下一个盘子 
		sum-=i;//回溯 
	}
}
int main(){
	t=read();
	for(int i=1;i<=t;i++)
	{
		ans=0;nextmin=0;sum=0;//清零（因为可以不放所以nextmin为0） 
		n=read();m=read();
		dfs(1);
		printf("%d\n",ans);//输出 
	} 
	return 0;//开开心心地结束 
}
```