这个题目我看到后马上就想到了一个题 P1025 【数的划分】，就是那个可以不放有一点烦人，于是我想到了一种可以避开这个问题的办法，具体请看代码
```
#include<bits/stdc++.h>
using namespace std;
int ans,m,n,a;//ans:表示每次的答案 m:表示苹果的数量 n:表示盘子的个数 a:表示计算的次数 
void dfs(int num,int p,int s)
{
    if(s+n-p>m) return;//剪枝，原理：因为苹果的个数都是正整数，所以当现在的数字大于剩下的苹果数量时，直接跳出 
    if(p==n&&s<m) return;//当盘子数量达到n，已放的苹果却不到m个，不满足，跳出 
    if(p==n&&s==m)//当条件满足，累加方案数量 
    {
        ans++;
        return;
    }
    for(int i=num;i<=m-s;i++)//继续搜索，利用后面的苹果数量小于或等于前面的苹果数量，去除重复 
    {
        dfs(i,p+1,s+i);
    }
    return; 
}
```
以上为头文件和递归函数，这里和之前提到的 P1025 【数的划分】是没有什么区别的，接下来才是重点。
```
int main()
{
	cin>>a;//输入计算次数 
	for(int x=1;x<=a;x++)
	{
		cin>>m>>n;//输入苹果和盘子的个数 
		while(n>0)
		{
			for(int i=1;i<=m-n+1;i++)
			{
				dfs(i,1,i);
			}
			n--;
		}//处理一下，解释在代码后面。 
		cout<<ans<<endl;
		ans=0;//清空方案数 
	}
	return 0;
}
```
下面我来解释一下之前的运算代码：
    目中说，可以有盘子不放苹果，也就是说，当有P个盘子不放时，就相当于将m个苹果，放入剩下的（n-p）个盘子中。这样想来，只需枚举所有不放苹果的盘子的个数的情况，运算后再把方案数相加就可以将题目转化为“求将m个苹果，放入1,2……n个盘子中的方案数量之和，且每个盘子至少放一个苹果”。