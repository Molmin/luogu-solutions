看了一下已经发的题解，大部分都是用递归写的

毕竟这题的测试数据有点水

如果这道题的数据大一点呢

所以我这里提供一个递推的代码

这里简单说一下我的思想

其实和很多人思路都是一样的

先建立一个二维数组

只有一个盘子或一个苹果的时候当然只有一种方法啦

所以我们就可以将边界条件建立好了

而当苹果数量m小于盘子数n，这时候肯定放不满盘子

此时最多也只能放m个盘子

而如果苹果数量m大于等于盘子数n，我们此时有两种方法存放苹果

1.每个盘子里放一个苹果

2.空置一个盘子，再对剩下的盘子进行处理

如果我们提前处理好二维数组，就可以在快速的输出答案了

下面贴出代码


      
```cpp
#include<cstdio>
using namespace std;
int a[205][205],t,n,m; 
//a就是我们对存放方法进行处理的二维数组，t是测试的次数，200是我随手打的，还是要看题目数据范围啊
int main()
{
    scanf("%d",&t);
    for(int i=0;i<=200;i++)
     for(int j=0;j<=200;j++)
     {
         if(i==1||j==1||i==0) a[i][j]=1;
         else if(i<j) a[i][j]=a[i][i];
         else a[i][j]=a[i-j][j]+a[i][j-1];
     } //对我们的数组进行预处理，处理思想上面已经说清了
    for(int i=1;i<=t;i++)
     {
         scanf("%d%d",&m,&n);
         printf("%d\n",a[m][n]);
     } // 处理完之后输出的时候就可以直接输出了
    return 0;
}
```