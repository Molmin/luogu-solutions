### 注意：这道题要不能用排列组合的方法做。

先理解一下题意：

参看输入样例1、7个苹果，三个盘子：

```cpp
0 0 7
0 1 6
0 2 5
0 3 4
1 1 5
1 2 4
1 3 3
2 2 4
```
总共有8种放法。

那么具体是怎么算出来的呢？

题中写了5,1,1和1,1,5是同一种方法，所以如果是三个盘子，假设为

a,b,c，要保证不重不漏的话，必须满足a<=b<=c。

放完第一个盘子，假设放了0个，那么此时还剩下7-0=7个苹果，还有

两个盘子，每个盘子至少放0个，记为（7,2,0）

如果放了一个，此时还剩下7-1=6个苹果，还有两个盘子，每个盘子至

少放1个，记为（6,2,1）

以此类推，考虑使用递归。

整体思路：使用递归，定义一个有返回值的函数，直接返回答案。

其余的参考代码注释。

```cpp
#include<iostream>
using namespace std;
int cal(int m,int n,int minn){//定义三个参数 
	if(n==1) return 1; //简单情况 
	int sum=0; 
	for(int i=minn;i<=m/n;i++)//最少放minn个，最多放m/n个 
	sum+=cal(m-i,n-1,i);//还剩m-i个苹果，n-1个盘子，最少放i个
	return sum; 
}
int main(){
	int t;
	int m,n;
	cin>>t;
	while(t--){//注意多组数据，使用while或for循环 
	cin>>m>>n;
	cout<<cal(m,n,0)<<endl;
	}
	return 0;
}
```
整体来说，递归部分不算很难，可以采用以小博大的思路。