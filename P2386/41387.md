
### 题目描述


把M个同样的苹果放在N个同样的盘子里，允许有的盘子空着不放，问共有多少种不同的分发（5,1,1和1,1,5是同一种方法）

##### 输入输出格式

输入格式：


第一行是测试数据的数目t（0 <= t <= 20），以下每行均包括二个整数M和N，以空格分开。1＜=M，N＜=10


输出格式：


对输入的每组数据M和N，用一行输出相应的K。


##### 输入输出样例

输入样例#1：


1
7 3

输出样例#1：


8

这题可以用递归来做，定义一个函数fun(m,n)返回在n个盘子里放m个苹果的值。


#### 返回值：

- 我可以把m个苹果都放入n个盘子中，但也可以留着1个或几个盘子不放苹果，即把m个苹果放入n-1或n-？个盘子。

- 假设我 **在n个盘子中都放苹果**，那么我先一个盘子放一个，那么剩下的m-n个苹果的放法，就和 **把m-n个苹果放进n个盘子中** 一样了

- 但要是我 **只放n-1或n-?个盘子** 呢？我们可以发现，n-？其实也可以等于n-1-1-1-……，这样我们就可以只考虑 **把m个苹果放入n-1个盘子** 的情况就好了。

- 综上所述，f(m,n) 的返回值:

        return fun(m-n,n)+fun(m,n-1);

#### 边界条件：

- 如果我没有苹果只有盘子，那算不算是1种放法？

- 如果我只有一个盘子，那我只能把所有的苹果放进同一个盘子里，也只有一种放法。

- 当盘子多于苹果的时候，m-n会是个负数，这时就没有意义了，所以返回0。当然对于这点来说，如果当n>m时，其实我们最多也只能放m个盘子，剩下的留空，这种情况与 **将m个苹果放入m个盘子中** 相同，故返回fun(m,m)，并且这样可以保证不会出现苹果是负数的情况。

- 所以，边界条件有:

        if(m==0||n==1) return 1;

        if(m<0) return 0;

        // 可以换成 if(n>m) return fun(m,m);

那~这题就写完了呗√


最后附上代码：

```cpp
        #include <stdio.h>
        int t,m,n;
        int fun(int m,int n){
            if(m==0||n==1) return 1;
            if(m<0) return 0;
            //if(m<n) return fun(m,m);
            return fun(m,n-1)+fun(m-n,n);
        }
        int main()
        {
            scanf("%d",&t);
            while(t--){
                scanf("%d%d",&m,&n);
                printf("%d\n",fun(m,n));
            }
            return 0;
}
```