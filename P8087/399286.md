### 题目大意

给两个序列 $a,f$，$a$ 为 $1$ 到 $n$ 的一个排列，求一个最短的区间 $[l,r]$，满足该区间内没有出现过的最小正整数大于 $f_{r-l+1}$。

### 分析

先评价一下：放在 J 组第二题难度比较合适，但可能部分分给的不够充足~~导致没打暴力直接打正解~~

---

看到这题第一反应应该是枚举区间，但是从 $a$ 数组入手无论如何都会超时，于是考虑从 $f$ 数组入手。

首先需要明确几个概念：

- 设区间长度为 $x$，则题目要求这个区间内没出现的最小正整数大于 $f_x$。

- 由上一条可得，$[1,f_x]$ 的**所有数**都必须在这个区间内出现。

- 如果 $f_x > n$，可以直接排除。代入不等式即可。（优化 $1$）

- 如果 $f_x > x$，也可以直接排除。因为无论如何，没出现的最小正整数都会小于等于 $f_x$。（优化 $2$）

明确了这几点，这题就基本做完了。首先我们需要排序，要从小区间推大区间。我们遍历 $f$ 数组，对于 $i \in [1,n]$，分别用一个指针从 $f_{i-1}$ 走到 $f_i$，统计其中的数在 $a$ 中的最小位置和最大位置。由于 $\forall a_i \le 4 \times 10^6$，故可以用桶来记录每一个 $a_i$ 对应的位置。

由我们的遍历方式可以知道，对于每一个 $f_i$，我们已经寻找到了 $[1,f_i]$ 中的数在 $a$ 的最小位置和最大位置，所以这个区间一定是**合法的最小区间**。由于这个区间往外拓宽一点也没关系，所以只需满足这个区间的长度**小于等于** $f_i$ 在原序列中对应的位置，即对应的区间长度即可。

但这个方法需要两重循环，每一个 $i$ 中还要 $j$ 从 $f_{i-1}$ 推到 $f_i$。但由于第二重循环在整个过程中最多只执行了 $n$ 次，即 $i$ 从 $1$ 到 $n$，$j$ 最多从 $1$ 到 $n$（因为通过优化 $1$ 已经把大于 $n$ 的情况全部排除了），所以加上排序的复杂度，最终时间复杂度为 $\mathcal{O}(n\log n+2n)$，可以通过。

补充说一句：寻找最小值和最大值其实是可以预处理的，但直接这样寻找也不会超时。故在此从略。还有本题数据有些水，导致不加两个优化也可以过。理论上不加优化最多要跑 $10^9$ 次。

### Code:
```cpp
#include <bits/stdc++.h>
using namespace std;
int n, minn=1e9+7, maxx, ans=1e9+7;
struct node{
	int p, x;
}a[4000010];
struct F{
	int num, id;
	bool operator < (const F &A) const{
		return num < A.num;
	}
}f[4000010];
inline int read(){
	int s=0, w=1; char ch = getchar();
	while (ch < '0' || ch > '9'){if (ch == '-') w=-1; ch=getchar();}
	while (ch >= '0' && ch <= '9'){s=(s<<1)+(s<<3)+ch-48; ch=getchar();}
	return s * w;
}
int main(){
	n = read();
	for (int i=1; i<=n; i++){
		a[i].x = read();
		a[a[i].x].p = i;//记录每一个数的位置 
	}
	for (int i=1; i<=n; i++){
		f[i].num = read();
		f[i].id = i;//由于要排序故记录位置，即对应的区间长度（这点很重要） 
	}
	sort (f+1, f+n+1);
	for (int i=1; i<=n; i++){
		for (int j=f[i-1].num+1; j<=f[i].num; j++){//从上一个数推到这一个数 
			minn = min(minn, a[j].p);//记录最小位置 
			maxx = max(maxx, a[j].p);//记录最大位置 
		}
		if (f[i].num > n) break;//优化1，排序后这个大于n剩下的都大于n 
		if (f[i].num > f[i].id) continue;//优化2 
		if (maxx - minn + 1 <= f[i].id) ans = min(ans, f[i].id);
		//判断是否符合，小于等于要特别注意（本质上是包含和被包含的关系），题解中有解释 
	}
	printf ("%d\n", ans == 1e9+7 ? 0 : ans);//不符合记得输出0 
	return 0;
}
```