为明确划分已求解部分和未求解部分的轮廓，我们对这些线段按左端点进行排序，这是动态规划的一个思想。

排序之后，就只需要将这些线段按顺序逐渐加入已求解的部分，也就是说，只需要计算出每一条线段对答案的贡献，就完成的求解。

一条线段对答案的贡献可以分为两种：

1. 不使用这一条线段，显然此时直接继承上一次的答案即可

2. 重点在于使用这一条线段。如果加入这一条线段，对于和它有重合部分的线段集合，无论怎么选都会和新线段形成一个等大的并，也就是说**对于有重合线段的集合，新线段对连通块数量没有影响**。而对与它没有重合的线段集合，任意一个子集都不与新线段重合，都是两个连通块，也就是说，**没有重合的线段集合的子集数量，就是新线段对答案的贡献**。

至此，我们可以写出到第 $i$ 条线段时的复杂度之和：

$f_i=f_{i-1}+(f_{i-1}+S)=2f_{i-1}+S$

其中 $S$ 表示内个子集的数量。

这时，排序的作用就显现出来了。我们只要统计有几个右端点小于新线段的左端点，就能算出与新线段无重合的线段集合的大小。具体就是，开一个桶存储每一个位置作为右端点的次数，再求一次前缀和即可。

知道了集合大小，如何求子集数量呢？题目告诉我们，大小为 $N$ 的集合，有 $2^N$ 个子集（含 $\varnothing$）。这是为什么呢？

子集可以认为是从原集合中选取了一些元素。所以大小为 $1$ 的子集数量就是 $C_N^1$，大小为 $2$  的子集数量是 $C_N^2$，以此类推。所以子集的总数就是：


$C_N^1+C_N^2+...+C_N^N=\sum\limits_{i=0}^N C_N^i$

逆用二项式定理：

$\sum\limits_{i=0}^N C_N^i=\sum\limits_{i=0}^N C_N^i \cdot 1=(1+1)^N=2^N$

从而得证。

有了思路，代码也就很容易了。

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int N=2e6+7;
const int mod=1e9+7;
struct line{int l,r;}a[N];
int f[N],s[N];
int n,tmp[N];
inline bool cmp(line x,line y){return x.l<y.l;}
inline void istmp(int k)	{
	tmp[0]=1;
	for(int i=1;i<=k;i++)	{
		tmp[i]=tmp[i-1]<<1;
		tmp[i]%=mod;
	}
	return;
}
inline int Qpow(int k){return tmp[k];}
signed main(void)
{
	scanf("%lld",&n);
	istmp(n<<1);
	for(int i=1;i<=n;i++)	{
		scanf("%lld%lld",&a[i].l,&a[i].r);
		s[a[i].r]++;
	}
	sort(a+1,a+n+1,cmp);
	for(int i=1;i<=n<<1;i++)  //注意是 N<<1 ,题目规定 1<=l,r<=2N 
		s[i]+=s[i-1];
	for(int i=1;i<=n;i++)	{
		f[i]=2*f[i-1]+Qpow(s[a[i].l-1]);
		f[i]%=mod;
	}
	printf("%lld\n",f[n]);
	return 0;
}
```

我这里选择预处理处 $2^k$，算是一个小优化。

如果数据进一步加强，我们可以使用基数排序，桶排序等非比较排序结合预处理，复杂度可以降到 $O(n)$ ，来通过 $10^7$ 规模的数据。