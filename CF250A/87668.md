这道题的题目描述之简洁实为洛谷罕见( •̀ ω •́ )

由于题目中不需要求每组的数，只需要求每组的数的个数，所以可以先明确一点：

### 只要分正负数就行啦

~~这谁都能看出来~~

题目说每堆最多只能有两个负数，为了使堆数尽量少，那就让负数分配得尽量密集，即尽量每组两个。

所以就可以确定一个基本的分类策略了：

- 直接往后遍历整个序列
- 每遍历到一个负数，计数器的值+1
- 当计数器的值达到3时，在下一个前缀和里记录当前遍历的数的数量-1（即不计当前的这个负数）
- 把当前最后一个前缀和的下一个位置里的数设为总数
- 套路输出

~~我这可悲的解释能力~~

还是代码比较能说明解法吧：

```cpp
#include<bits/stdc++.h>
using namespace std;
int as[110],cnt=1,k;//k是计数器，cnt是堆数,as是前缀和数组
int main()
{
	int n,x;
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&x);
		if(x<0) k++;
		if(k==3) as[cnt++]=i-1,k=1;
	}
	as[cnt]=n;
	printf("%d\n",cnt);
	for(int i=1;i<=cnt;i++)
		printf("%d ",as[i]-as[i-1]);
	return 0;
}
```