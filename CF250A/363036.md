## 题意
题意即题目翻译，本题言简意赅，故不提供简述题意。

## 做法
先提供一个**错误做法**（题目翻译中没有说**同一堆元素要连续**，但是题解中有人提到）。

如果没有括号内的内容，直接统计负数个数 $cnt$，堆数肯定就是 $\lceil \frac{cnt}{2}\rceil$。**将所有正数放在一堆中，其余输出 $2$ 即可**（再判断一下**是否有 $1$ 个负数）**。

代码就不放了，有兴趣的自己打打吧。
### 正解
~~看到 $n\leq 100$，其实什么沙雕做法都可以了~~。

直接在线处理，一旦 $cnt > 2$ 了，就一定要新开一堆了，将 $2$ 个负数和正数个数加起来作为一堆，并且负数个数改为 $1$**（不是 $0$）**，正数改为 $0$（全部被放进去了）。

最后还要**判断一下是否还有剩余的数**没有被放进来，如果有就新开一堆。

剩下的就是输出了。

## 代码
以下是 AC 代码。珍爱生命，远离抄袭。

Code：
```cpp
#include<bits/stdc++.h>
using namespace std;

const int N = 100 + 10;
int n, m, cnt, cnt1, x, ans[N];

int main(){
	scanf("%d", &n);
	for(int i=1;i<=n;i++){
		scanf("%d", &x);
		if(x < 0)	cnt++;
		else	cnt1++;
		if(cnt == 3){
			ans[++m] = cnt1 + 2;
			cnt = 1, cnt1 = 0; 
		}
	}
	if(cnt || cnt1)	ans[++m] = cnt + cnt1;
	printf("%d\n", m);
	for(int i=1;i<=m;i++)	printf("%d ", ans[i]);
	return 0;
}
```
