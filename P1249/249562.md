
我的方法是：【模拟】找序列 + 分配。

题目要求：
- 1、找最大序列
- 2、输出相乘结果

### 分析1 找序列：
根据题目要求，所求序列一定是递增序列，不包括最后两位，例如$7(25),8(26),9(234)$，仔细观察可以看出，到了$9$本应该是$27$却可以分成$234$，这其中便隐含了如下的规律:

从$2$开始，设$pre$表示上一个数，设$x$表示现在要插入的数，设n表示剩下能插入的数的和。当$(pre+1)*2 > n$ 时，$n$就是插入的最后一个数了，否则，插入的数是上一个数+$1$
#### Code:
```cpp
if((pre+1)*2 > n ) pre=n; //* 插入最后一个数
else pre++;//* 插入上一个数+1
```

思考：假如输入$13$，如果按照上面的方法。$13$的序列应该是$(238)$因为到了$8$，它跟$(3+1)*2 = 8$相等，所以就直接放上去了,然而实际上其实是$(345)$。

结论：这时候明显最后一个数过大了，把最后一个数分配给前面，上面把$8$分配给$3$和$2$就能变成$345$。
### 分析2 分配：
 分配最后一个数，保证最后一个数大于前面的数+1，例：序列$(246)$不能分成序列$(255)$！但是$(236)$可以分成$(245)$。
 
 这里有个特例：$10$的序列不是$(235)$，而是$(244)$，说明在比较最后一个与前一个时，要判断分配前后的乘积大小，取大的即可。
 
 例：$(237)$，得出分配后的序列应是$(345)$。所以分配应从前一个数开始一直往前分配，只要满足条件就一直分配。

#### Code:
```cpp	
   for(i=1;;i++){//js表示序列的长度 (从1开始)
	if(a[js]>a[js-i]+1 && a[js]>a[js-1]+1){//得保证后面的数比前面所有的数大
	a[js]--;
	a[js-i]++;
	}
  	else break;
   }
   /*特判最后一位*/ 
    int lastOne=a[js],lastTwo=a[js-1];  //分别存序列最后一个 和倒数第二个数 
    int temp=lastOne*lastTwo;			//存序列最后两个数的乘积 ，分配时用于判断大小 
    if(lastOne==lastTwo && temp < (lastOne-1) * (lastTwo+1))  
    	a[js]--,a[js-1]++;
```
#### AC Code:
```cpp
#include<bits/stdc++.h>             
using namespace std;
int a[10000],js,b[10000],len=1;     
//a存序列  b存相乘结果  js存序列位数 len存结果长度 

/*高精度与低精度相乘运算*/ 
void cal(int x){
    int carry=0,i,j,k=x,lenx=0;     //carry存进位，k用作求位数，lenx保存x的位数  
    while(k!=0) lenx++,k/=10;       //计算x的位数 
    for(i=0;i<10000;i++){           //防止错误直接全部乘 
        b[i]=b[i]*x+carry;
        carry=b[i]/10;
        b[i]%=10;
    }
    len+=lenx;
    while(b[len-1]==0) len--;       //除掉前面多余的0 
}
int main(void){
    long long i,j,n,pre=2,k,ans=1;
    cin>>n;
    /* 特判 1~4 */ 
    if(n<=4) printf("%d\n%d\n",n,n);
    else{
    /* Step 1 、找序列 */ 
    while(n){
        k=(pre+1)*2+1;                  //k存判断范围 
        n-=pre;                         //步骤1 
        a[++js]=pre;                    //步骤2 
        if(k>n) pre=n;                  //不够分了就直接插入 
        else pre++;                     //还能分，就插入上一个数+1 
    }
    /* Step 2、分配  */ 
    for(i=1;;i++){
        if(a[js]>a[js-i]+1 && a[js]>a[js-1]+1){//保证最后一个数比前面所有的数大
            a[js]--;a[js-i]++; //分配过程
		}
		else break;
    }
    /*特判最后一位*/ 
    int lastOne=a[js],lastTwo=a[js-1];  //分别存序列最后一个 和倒数第二个数 
    int temp=lastOne*lastTwo;			//存序列最后两个数的乘积 ，分配时用于判断大小 
    if(lastOne==lastTwo && temp < (lastOne-1) * (lastTwo+1))  
    	a[js]--,a[js-1]++;
    /* 输出序列 + 高精度乘法 */ 
    b[0]=1;
    for(i=1;i<=js;i++) {
    cout<<a[i]<<' ';
    cal(a[i]);
    }
   /* 输出结果 */
    cout<<endl;                         
    for(i=len-1;i>=0;i--) cout<<b[i];       //因为是倒序计算的所以就倒序输出 
    cout<<endl;
    }
}
```