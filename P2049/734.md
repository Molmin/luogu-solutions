吐槽（可以无视）：好久没有写题解了吧。。因为学业的缘故。不过还是要练一练。

    <hr>

初看这一道题目，好像没有什么思路。其实搜索也是能够写的。显然，这一道题目不用动规是不行的。像这一类的题目，**[color=red]一定要关注数据[/color]**，比如说取模的K，只有100。于是我们很容易联想到背包问题的剩余容量的可能性。**[u]我们可以用一个布尔型三维数组f[i,j,x]（由于K已经作为了取模数，所以不再重复），表示第i行j列在mod  K后能否取到。[/u]**

由于这一道题目规定只能向下或者向右，所以具有明显的无后效性，可以用动态规划。显然，对于f[i,j,x]，我们只需要知道f[i-1,j,l]或者f[i,j-1,l]满足l\*a[i,j] mod K=x即可。但是我们发现，对于f[i,j,x]，需要用O(K)的时间来进行状态转移，同时又有MNK个状态，时间复杂度为O(MNK^2)，当取到极限值100时，极易超时，所以需要改进。

[u]我们发现，有许多l都是不满足条件的。而当l满足条件时，一定能找到符合条件的。只要枚举所有符合的l，就能找到所有符合条件的x。显然，我们可以通过枚举l来实现，这样时间复杂度就下降到了O(MNK)，可以通过全部的测试点。[/u]

    <hr>

通过以上我们可以发现，动态规划也不是一定就能高时效，还需要通过优化。比较明显的有比如说上海省选的的一道“吃豆豆”，有兴趣的同学可以探讨一下。

    <hr>

标程（核心代码）：

```delphi
begin
  readln(m,n,k);
  for i:=1 to m do
    begin
      for j:=1 to n do
        begin
          read(x);
          x:=x mod k;//直接取余，显然不会影响结果，但可以降低数据量
          if i+j=2 then
            begin
              f[i,j,x]:=true;
              continue;
            end;//对于i=j=1的情况，无需转移。
          for l:=0 to k-1 do//枚举l
            f[i,j,x*l mod k]:=
              f[i,j,x*l mod k] or f[i-1,j,l] or f[i,j-1,l];//状态转移
        end;
      readln;
    end;
end.
```
最后附一句（可以无视）：动态规划是个好东西，一定要学好。
