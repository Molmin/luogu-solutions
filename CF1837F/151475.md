首先有个简单的双 $\log$ 做法：先二分答案，然后枚举分段点，前后都尽可能选小的，比较个数和 $k$ 的大小，用堆维护即可。

两 $\log$ 看起来太蠢了，跑起来还巨慢，能不能优化一下呢？感觉上二分去不掉，考虑能不能把堆去掉。我们用堆其实维护了这么个事情：

- 加入一个元素；
- 弹出最大的元素。

同时我们要做 $\log A$ 轮这个事情，并且每轮加入元素的顺序是一样的。这启示我们对每个元素 $a_i$ 预处理一次，找到它加入后会在哪个元素前面（也就是找到最大的 $a_j$ 满足 $j<i$ 且 $a_j\le a_i$），这样就可以用双向链表维护这个事情了。也就是用双向链表时刻维护有序的结构。

这样做会有个问题，就是如果你发现你应该加在 $x$ 前面，但是此时 $x$ 已被删除，怎么办？注意到这题中，如果 $x$ 被删除，说明 $x$ 及以上的元素都是无效的。所以这种情况我们直接不加入这个元素即可。

瓶颈在二分答案，复杂度 $O(n\log A)$。