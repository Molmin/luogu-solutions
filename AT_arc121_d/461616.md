# [ARC121D] 1 or 2

## 题面翻译


你有 $n$ 个糖果，第 $i$ 个糖果的美味值为 $a_i$。

你需要吃糖，每次你可以选择吃 $1$ 个或 $2$ 个糖，并将你这一次吃的糖的总和写在黑板上。

你需要求出吃完所有糖果的所有可能的情况中，黑板上数字最大值和最小值之差最小是多少。

# 题解

是一道不错的思维题，值得一做。

后文所说的序列都表示 $n$ 个糖果排成一排所形成的序列 $a$，且序列每一项的值为 $a_i$。

## 1. 题面分析

数据范围 $n \le 5000$，盲猜是 $n^2$ 的做法。

看见最大值和最小值，考虑先将原序列升序排序一定是不亏的。


现在考虑在上面做区间 DP，有了乱搞做法。

这样能在 Atcoder 上获得过掉绝大多数点的好成绩。

但是这样是不够的

## 2. 猜测结论

默认已经对序列排序。

首先，如果当前元素 $a_i$ 选择被单独吃掉，可以看作与一颗值为 $0$ 的糖一起被吃掉。

这样就将所有的被单独吃掉的糖都转化为了两颗一起吃。然而有一个问题：我们不知道应该往序列中加入多少颗值为 $0$ 的糖。这时我们选择暴力枚举 $n'$ 表示添加后的糖果数量（$n \le n' \le 2n$），算出每种 $n'$ 下最小的**最大值与最小值之差**。

所以我们现在需要考虑的问题只是对于一个元素数量为 $n'$ 的升序序列，全部使用两两消除的方式，如何取得最小的最大值与最小值之差。

感性理解一下，我们肯定希望最大值和最小值差距越小越好，所以就让最大和最小匹配、次大和次小匹配……，这样应该可以取得最小的差值。


## 3. 总结

枚举补充的 $0$ 的数量，对于补充好了的序列，对它排序，选两个数时，两头取，最后算出这样的最大值和最小值，做差，用差值更新答案。

## 4. AC Code

```cpp
#include<bits/stdc++.h>
#define int long long
#define N 10009
using namespace std;
int nn,a[N],b[N],ans=0x3f3f3f3f;
signed main(){
	ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
	cin>>nn;
	for(int i=1;i<=nn;i++){
		cin>>a[i];
		b[i]=a[i];
	}
	for(int n=nn;n<=nn*2;n++){
		for(int i=nn+1;i<=n;i++){
			a[i]=0;
		}
		sort(a+1,a+n+1);
		int maxx=-0x3f3f3f3f,minn=0x3f3f3f3f;
		for(int i=1;i<=n/2;i++){
			maxx=max(maxx,a[i]+a[n-i+1]);
			minn=min(minn,a[i]+a[n-i+1]);
		}
		if(n%2==1){
			maxx=max(maxx,a[n/2+1]);
			minn=min(minn,a[n/2+1]);
		}
		ans=min(ans,maxx-minn);
		for(int i=1;i<=nn;i++){
			a[i]=b[i];
		}
	}
	cout<<ans;
	return 0;
}
```

## 5. 结论证明

设元素 $a$，$a+x$，$a+y$，$a+z$，满足 $x \le y 
\le z$，求如何组合成两组每组元素数量为 $2$ 的二元组能让两组的每组和的最大值和最小值之差最小。

有点绕，其实就是有 $4$ 颗糖，如何用吃两颗的方式让题目的要求最小。

设差值为 $t$，有如下分类讨论：

1. $a$ 和 $a+x$ 一组，$a+y$ 和 $a+z$ 一组，这样 $t=y+z-x$。

2. $a$ 和 $a+y$ 一组，$a+x$ 和 $a+z$ 一组，这样 $t=x+z-y$。

3. $a$ 和 $a+z$ 一组，$a+x$ 和 $a+y$ 一组，这样 $t=|x+y-z|$。

显然第三种最小。