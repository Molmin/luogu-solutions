其实这道题非常简单，只要找对了方法，作为橙题也不为过。

根据题意，前缀和后缀都覆盖的地方相当于不变，不用考虑。

在剩下的情况中，我们假设所有的数都进行变化，现在想要达到最大的总和，我们需要筛选出一段数不变化，即我们要求出所有数都变化后的数列中的最小子段和。

在换一句话来说，就是求出原数列中最大子段和的相反数。

这里设原数列总和为 $sum$，最大子段和为 $ans$，我们不难发现最终的答案就是 $ans - (sum - ans)$，即最大子段和（不变化的那段数）与变化的那段数总和（$sum - ans$）的相反数的和。

至此，我们可以推出极简代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
int n,a[100005],sum,ans,ans2;//原数列总和为sum，最大子段和为ans。
int main()
{
    cin >> n;
    for(int i = 1; i <= n; i++)
    {
        cin >> a[i];
        sum += a[i],ans2 = max(ans2 + a[i],0),ans = max(ans,ans2);
        //求出最大子段和和原数列总和。
    }
    cout << ans - (sum - ans);//输出答案。
    return 0;//AC！
}
```
