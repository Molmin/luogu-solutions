## 第一步 读题

>给你一个数字序列，你可以选择它的一些前缀或后缀(可能是空的)中的每个数字都乘以 $-1$。前缀和后缀可以交叉也可以为空。问能得到的最大序列和是多少。

简化一下就是我们可以把一个序列的前面连续几个数和后面连续几个数（可以不取）换成相反数，然后求这个序列的和。问这个和最大是多少。

## 第二步 思路

由于一个数乘 $-1$ 后再乘 $-1$，则结果为原数。那么我们就可以不考虑交叉的情况（因为交叉的情况与不选交叉这一部分的情况相同）。

首先，我们分析一下本题： $n \le 10^5$，所以这道题我们的时间复杂度不可能为 $O\left(n^2\right)$，因为会超时。那么由于这个题是一个序列问题，所以我们大概就想到了一个思路：预处理。最常见的预处理，前后缀和，在这道题里大概用的上。所以我们考虑前后缀和。

我们可以先求出序列的前后缀和（如果大于 $0$ 就可以改为$0$，因为我们还要乘 $-1$），再求出原序列的总和。时间复杂度 $O\left(n\right)$。

现在我们有两种思路：

- 直接暴力，当位置为 $i$ 时，求出 $i$ 后面的后缀和中最小的一个（因为最小的一个乘以 $-1$ 就变成最大的了。）那我们就需要两重循环，时间复杂度 $O\left(n^2\right)$，上面我们也说了 $n \le 10^5$，明显超时。我们考虑优化。

- 由于我们每次都要查找**当前位置的后面的后缀和最小的一个，所以我们可以选择把后缀和改成当前位置后面的最小的后缀和。** 那么时间复杂度就是 $O\left(n\right)$ 。最后，我们可以考虑当前位置的前缀和与后缀最优结果的加和最小的情况（还是乘 $-1$ 的缘故）。那么这部分的时间复杂度也是 $O\left(n\right)$。然后最后我们用原序列的总和减去这个最小结果（如果最小结果为正数的话我们就取 $0$）。那么最后的总时间复杂度为 $O\left(n\right)$，完全不会超时。

## 第三步 代码

终于到了你们最喜欢的部分了。。（请勿抄袭！）

```
#include<bits/stdc++.h>
using namespace std;
int last[100005],first[100005],p[100005],n,result,ans;//first和last分别存储前后缀和，p读入，n为序列长度，result表示最后的答案，ans存储原序列和。 
int main(){
	cin>>n;//读入
	for(int i=1;i<=n;i++) cin>>p[i];//读入序列
	for(int i=1;i<=n;i++) first[i]=first[i-1]+p[i],ans+=p[i];//前缀和和序列和同时求出来233
	for(int i=n;i>=1;i--) last[i]=last[i+1]+p[i];//后缀和。由于是后缀和，所以从倒序遍历
	for(int i=n;i>=1;i--) last[i]=min(last[i],last[i+1]);//求出当前后缀最优结果。我们可以从后面一项中直接寻找过来，就像动态规划的转移方程（本来就是。。）
	result=ans;//赋值，用来存储
	for(int i=0;i<=n;i++)//记得从0开始啊。。前面也说了要多算一遍0
		result=max(result,ans-2*(first[i]+last[i+1]));//这里是转移方程，我们要最大值，那就用max，max第二个参数的意思就是当前的前缀和和后面的最优情况。
	cout<<result<<endl;//输出
	return 0;//bye~
}
```

### 第四步 其他

- 撰文不易，大佬勿喷！
- 文章若有`bug`请私信作者，感激不尽！
- 如果有帮助，请帮忙点下赞，感谢！
