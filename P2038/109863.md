#### ~~我来挑战最短代码了！！~~

# 俗话说得好，短代码看着爽

咳咳，进入正题

## 思路 

为什么要用二维数组存图呢？我可以设置三个~~课代表~~数组：x[maxn],y[maxn],z[maxn];

### x数组->->存输入点的横坐标

### y数组->->存输入点的纵坐标

### z数组->->存输入点点权值

好了，定义完这三个数组后完我来讲讲如何~~带飞~~应用这三个数组

- 先上两个**for**循环枚举信号塔的位置（ i ， j ）。

- 这个信号塔的**横向**信号范围就是从 **i-d**（左） 到 **i+d**（右）

- 这个信号塔的**纵向**信号范围就是从 **j-d**（上）到 **j+d**（下）

- 我再来一个**for**枚举这**n**个点然后判断这**n**个点中是否有符合范围的点，如果有，那么加上这个累加上这个点点的权值

下面是对代码中难懂变量的解释

| 	| pu(上) |  |
| :----------: | :----------: | :----------: |
| pl(左） | <-方位-> | pr（右） |
|  |  pd(下)|  |


下面见代码：美滋滋

```cpp
# include <iostream>
# include <cstdio>//没有恶意压行，营造优美环境 
using namespace std;//你可以不带这个试试 
int x[130],y[130],z[130];//三个数组 
int main()
{
	int d,n;
	scanf("%d%d",&d,&n);
	for(int i=1;i<=n;i++)scanf("%d%d%d",&x[i],&y[i],&z[i]);
	int ans=0,maxn=0;
	for(int i=0;i<=128;i++) 
	for(int j=0;j<=128;j++)//遍历信号塔可以放的位置 
	{
		int pl=i-d,pr=i+d;
		int pu=j-d,pd=j+d;
		int sum=0;
		for(int k=1;k<=n;k++)//枚举n个点 
			if(pl<=x[k]&&x[k]<=pr&&pu<=y[k]&&y[k]<=pd)//如果处于范围内 
				sum+=z[k]; 
		if(sum==maxn)//碰到一样大的++ 
		ans++; 
		if(sum>maxn)//找到更大的值那就重新计数 
		{
			ans=1;
			maxn=sum;
		}
	}
	printf("%d %d",ans,maxn);//美滋滋的答案 
	return 0;
	//到这才三十行  喵喵喵！！！！ 
	puts("QWQ");//表达做出题后心中的欢喜 
}

```


