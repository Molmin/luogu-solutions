感觉不是很简单的结论+构造题。讲讲我的做法。

首先 $k$ 为偶数时容易发现满足异或值要求的序列中所有元素的 $\operatorname{popcount}$ 必然奇偶性相同，故不可能构成排列。另外 $n \le k$ 且 $n>1$ 时显然也无法构造满足要求的排列。

然后大胆猜测其他情况都可以。尝试构造。看着一脸格雷码加强版的长相。所以感觉做法和格雷码差不多。

~~那格雷码 `k^(k>>1)` 这个题是不是就随便异或一下就完啦~~

也许可以，但是我不行，我做不到。

那怎么个差不多法呢？我们回想 CSPS2019 D1T1 格雷码题面里描述的格雷码构造方法。

> 1. 1 位格雷码由两个 1 位二进制串组成，顺序为：0，1。
> 2. $n + 1$ 位格雷码的前 $2^n$ 个二进制串，可以由依此算法生成的 $n$ 位格雷码（总共 $2^n$ 个 $n$ 位二进制串）按**顺序**排列，再在每个串前加一个前缀 0 构成。
> 3. $n + 1$ 位格雷码的后 $2^n$ 个二进制串，可以由依此算法生成的 $n$ 位格雷码（总共 $2^n$ 个 $n$ 位二进制串）按**逆序**排列，再在每个串前加一个前缀 1 构成。  
> 综上，$n + 1$ 位格雷码，由 $n$ 位格雷码的 $2^n$ 个二进制串按顺序排列再加前缀 0，和按逆序排列再加前缀 1 构成，共 $2^{n+1}$ 个二进制串。另外，对于 $n$ 位格雷码中的 $2^n$ 个 二进制串，我们按上述算法得到的排列顺序将它们从 $0 \sim 2^n - 1$ 编号。

容易发现事实上我们可以看作将 $n$ 位格雷码前面补 $0$ 后最高 $1$ 位取反再翻转接在后面形成 $n+1$ 位格雷码。格雷码满足的条件是相邻数二进制差 $1$ 位。推广到差 $k$ 位，我们是不是只要把最高 $k$ 位取反再翻转就可以了呢？

我们非常开心地发现，这是正确的。证明也很简单，由于 $0 \sim 2^n-1$ 的排列二进制前 $k-1$ 位取反后仍然得到 $0 \sim 2^n-1$ 的排列，而两个这样的排列分别加上最高位 $0,1$ 各一次，故形成的确实是一个 $0 \sim 2^{n+1}-1$ 的排列。

然后由于前后两半之内相差位数是对应相同的，由归纳假设均相差 $k$ 位，中间接口处由定义恰相差前 $k$ 位。所以相邻数确实相差恰好 $k$ 位。

现在我们还剩下最后一个问题，就是边界（或者说归纳奠基）。根据刚才的分析，我们现在的任务是 $n=k+1$。下面给出我的构造方法。

容易发现此时的要求是相邻两数二进制只有一位相同。我们考虑找出这个相同位。

事实上，当第 $x$ 与第 $x+1$ 个数的相同位为 $\operatorname{lowbit}(x)$ 时整个序列能够构成一个排列。

这是我的第一个想法。而在我试图证明它的时候，我发现了一件事。它的本质就是对格雷码的奇数下标位置整体取反（下标从 $0$ 开始）。这是因为不同位为 $\operatorname{lowbit}(x)$ 时构造出来的东西就是格雷码，再回顾上面的过程会发现这是显然的。又由于此时 $k$ 为奇数，故 $n$ 为偶数，所以取反前奇数位下标取遍所有 $\operatorname{popcount}$ 为奇数的值，取反后仍然如此。

这时就得到了 AC 代码：
```cpp
#include<cstdio>
#define rg register
int n,m,k,l,s;
int ans[1048576];
inline void solve(int x)
{
	if(x==k+1)
	{
		m=1<<x;
		for(rg int i=1;i<m;++i)
		{
			ans[i]=i^(i>>1);
			(i&1)&&(ans[i]^=m-1);
		}
		return;
	}
	solve(x-1),m=1<<(x-1),l=m<<1,s=((1<<k)-1)<<(x-k);
	for(rg int i=0;i<m;++i)ans[i^(l-1)]=ans[i]^s;
}
int main()
{
	scanf(" %d %d",&n,&k);
	if(n==1&&k==1)return puts("1"),puts("0 1"),0;
	if(!(k&1)||n<=k)return puts("0"),0;
	puts("1"),solve(n),l=1<<n;
	for(rg int i=0;i<l;++i)printf("%d ",ans[i]);
	return 0;
}
```

但是这已经是一堆东西随便异或一下就出来了。事实上应该有更简单的形式但是我懒得搞了。

~~所以我又行了（？）~~