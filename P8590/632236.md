## 分析

题中有两个很重要的性质，
- 序列满足每一项都不小于前一项
- 可以有空段

对于每一个 $m$ ，如何构造出分段方式使  $\sum_{i=1}^{n}a_i^2$ 最大？

先考虑序列所有数大于等于 $0$ 的情况。$a_i$ 在第 $j$ 段就加上 $j$ ，显然 $a_i+j$ 越大，它的平方就越大。所以将所有数都划分到最后一段是最大的。

如果序列中存在了负数，不难想出，对于每个 $a_i$  ，如果 $(a_i+1)^2<(a_i+m)^2$ ，那么就将它划分到最后一段，否则划分到第一段。因为序列是单调不降的，所以如果 $(a_i+1)^2<(a_i+m)^2$ ，  $(a_{i+1}+1)^2<(a_{i+1}+m)^2$ 也满足。

这样一个最优的划分方案就出现了，**对于每个 $m$ ，将所有满足 $(a_i+1)^2>=(a_i+m)^2$ 的 $a_i$ 划分到第一段，将所有满足 $(a_i+1)^2<(a_i+m)^2$ 的划分到最后一段。只有第一段和最后一段里有数**。

我们就可以用一个变量 $t$ 来记录中间这个分割点。对于每个$m$ 可以先更新 $t$ ，然后分别算出 $\sum_{i=1}^{t}(a_i+1)^2$和$\sum_{i=t+1}^{n}(a_i+m)^2$ 。 

计算复杂度 $O(n)$ ,枚举 $k$ 次，
直接这样做复杂度 $O(kn)$ ，会超时，考虑优化。

## 优化

如何 $O(1)$ 计算 $\sum_{i=1}^{t}(a_i+1)^2$ 和  $\sum_{i=t+1}^{n}(a_i+m)^2$ ？

我们展开一下 $\sum_{i=t+1}^{n}(a_i+m)^2$ ，可得。
$$\sum_{i=t+1}^{n}(a_i+m)^2=\sum_{i=t+1}^{n}a_i^2+\sum_{i=t+1}^{n}2a_im+m^2(n-t-1)$$

$\sum_{i=1}^{t}(a_i+1)^2$ 也同理。

所以
$$q_j=\sum_{i=1}^{n}a_i^2+2\sum_{i=1}^{t}a_i+2\sum_{i=t+1}^{n}a_im+m^2(n-t-1)+t$$

**我们可以使用前缀和来优化。使用两个变量，令 $S_1=\sum_{i=1}^{t}a_i$ ， $S_2=\sum_{i=t+1}^{n}a_i$ ，每次随着 $t$ 的更新，更新 $S_1$ 和 $S_2$ 。** 而每个 $q_j$ 的 $\sum_{i=1}^{n}a_i^2$ ，直接在输出时加上 $k\sum_{i=1}^{n}a_i^2$ 就行了。

前缀和优化后，此题复杂度变成了$O(k+n)$，足以过掉此题。

最后，**一定要注意及时取模！**

~~取模不当见祖宗~~

## 代码
```cpp
#include<bits/stdc++.h>
#define int long long
#define mod 998244353
using namespace std;
//long long也是要开的
int n,k;
int ans;
int a[1000005];
int s1,s2;
signed main(){
    ios::sync_with_stdio(0);
    cin>>n>>k;
    int t=n;
    for(int i=1;n>=i;i++)cin>>a[i];
    for(int i=1;n>=i;i++){
        ans=(ans+(a[i]*a[i])%mod)%mod;
        s1=(s1+a[i])%mod;//前缀和
    }
    ans=(ans*k)%mod;//直接在最开始就将序列平方和乘上k，在循环时不用单独计算。
    for(int i=1;k>=i;i++){
        while((a[t]+1)*(a[t]+1)<(a[t]+i)*(a[t]+i)&&t){
            s1=(s1-a[t]+mod)%mod;s2=(s2+a[t])%mod;
            t--;//对于每个m，更新t和s1，s2。            
        }
        ans=(ans+(((i*i)%mod)*(n-t))%mod+t+(2*s1)%mod+(2*i*s2)%mod+mod)%mod;
        //注意取模。
    }
    cout<<ans<<endl;
    return 0;
}
```
