**【题目分析】**

首先我们要想的是，要求的值什么时候最大。首先好理解的是，肯定要把若干个负数放到最左边，中间放空区间，右边放整数，这样可以让负数的平方减得最少，正数的平方加得最多。有一种常见的错误思路：把负数全都放在左边第一个，然而这是错的。例如：$-10\quad -1\quad5 $，这组数据显然，当 $m$ 较大时，应该把 $-1$ 放在右边那一组。所以我们要修改贪心策略：当 $a+m \ge -a-1$ 时，就将它放在右边那一组。这个式子的意思是当把这个负数放在右边加的比在左边加的结果的绝对值还大时就放在右边。那么思路已经很清晰了，考虑如何计算。

以下用 $p$ 表示左边的最后一个负数。

先看左边，左边的平方和就等于 $(a_1+1)^2+(a_2+1)^2+...+(a_p+1)^2 = (a_1^2+a_2^2+...+a_p^2)+2(a_1+a_2+...+a_p)+p$。我们可以用前缀和维护平方和以及一次项的和。

再看右边，右边的平方和等于 $(a_{p+1}+m)^2+(a_{p+2}+m)^2+...+(a_n+m)^2 = (a_{p+1}^2+a_{p+2}^2+...+a_n^2)+2m(a_{p+1}+a_{p+2}+...+a_n)+(n-p)m^2$。这个式子同样可以使用前缀和维护。

在处理的时候注意细节，例如哪里要取余、哪里要开 `long long`。然而为了避免乘的时候爆 `long long` 还得到处取余，我选择开了 `__int128`，就不用处理很多杂乱的细节。

具体的处理方法见代码。

**【关键代码】**

为了方便，省略 `__int128` 需要的读入（`r()` 函数） 和输出 （`pri()` 函数）。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll __int128
ll mod = 998244353;
ll n,m,sum1[10000005],sum2[10000005],a[10000005],p,ans;
//sum1是平方前缀和，sum2是一次项前缀和,p是最后一个负数
//省略输入输出的 r() 和 pri() 函数
int main(){
	n = r(),m = r();
	for(ll i = 1;i <= n;i ++){
		a[i] = r();
		if(a[i] < 0){
			p = i;//记录第一个负数的位置
			sum2[i] = (sum2[i-1] + a[i]+mod)%mod;
		}
		else sum2[i] = (sum2[i-1] + a[i]+mod)%mod;
		sum1[i] = (sum1[i-1] + a[i]*a[i]) % mod;
	}
	for(ll i = 1;i <= m;i ++){//注意，i 也要开 __int128！！！
	    while(-a[p]-1 < a[p]+i && p > 0) --p;
		ans = (ans + (sum1[p]+2*sum2[p]+p+mod)%mod+((sum1[n]-sum1[p])+2*i*((sum2[n]-sum2[p]+mod))+i*i*(n-p)))%mod;
	}
	pri((ans+mod)%mod);
	return 0;
}