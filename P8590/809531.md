## 大体方向

根据样例可知，我们可以贪心地把负数划到第一段，正数划到最后一段，接着简单拆式子计算即可？

**但是如果你这么想只有 60 pts**，~~和我赛时一样~~。

这是为什么呢？注意到当 $a_i<0$ 并且 $m \geq -2a_i$ 时 $a_i$ 也要划到最后一类，这样才是满分做法，我们在 $a_i<0$ 时分类讨论即可。具体的见「具体思路」的末尾。

## 具体思路

可能会讲的标准一些，但是已经尽力讲的通俗易懂了。

希望大家都有所收获，一些简单的化简就不展开来说了。

### 定义 $f$ 函数

我们为了方便计算，定义函数 $f$。

令 $f(x, b, e) = (x + b) ^ 2 + (x + (b + 1)) ^ 2 + ... + (x + e) ^ 2$，其中 $b,e\leq k$。

经过简单化简可得：

$f(x,b,e)=\textcolor{blue}{(e-b+1)x^2+x(b+e)(e-b+1)}+ \textcolor{red}{b^2+(b+1)^2+...+e^2}$。

很显然蓝字部分可以 $O(1)$，而红字部分 $O(e-b)$。我们考虑优化红字部分。

记 $sum_i = \sum\limits_{j=1}^{i}j^2$。很显然 $\{sum_n\}$ 可以前缀和 $O(k)$ 求出，那么红字部分就可以转化为 $sum_e-sum_{b-1}$。

所以我们最终的 $f$ 函数为：

$f(x,b,e)=(e-b+1)x^2+x(b+e)(e-b+1)+sum_e-sum_{b-1}$。

那么经过前缀和优化后，显然 $f$ 的计算是 $O(1)$ 的。

### 计算

#### 仅考虑非负数

假设我们去掉 $\{a_n\}$ 中所有的负数，那么答案即为 $\sum\limits_{i=1}^{n}\space (a_i)^2 + (a_i+1)^2+...+(a_i+k)^2$，手算样例正数部分即可理解。

运用 $f$ 函数，原式可以化简为：$\sum\limits_{i=1}^{n}f(a_i,1,k)$。

#### 考虑负数

如果 $a_i < 0$，我们分两种情况。

- $k < -2a_i$：我们直接把它每一次都划分到第一段。答案增加 $(a_i+1)^2\times k$。

- $k \geq -2x$：

> 对于 $m = 1,2,...,-2a_i-1$，我们把它划分到第一段里。答案增加 $(a_i+1)^2\times (-2a_i-1)$，根据样例手推即可。

> 对于 $m=-2a_i,-2a_i+1,...,k$，我们把它划分到最后一段，答案增加 $(a_i+(-2a_i))^2+(a_i+(-2a_i+1))^2+...+(a_i+k)^2=f(a_i,-2a_i,k)$。这是为什么呢？请参见下文「WA 60pts 原因」。

#### WA 60pts 原因

我们把以下的数据，展开手算：

```
2 10
-4 1
```

当 $m = 1$ 时，最优策略是 $[-4,1]$，$q_1=(-3)^2+2^2=13$，

当 $m = 2$ 时，最优策略是 $[-4][1]$，$q_1=(-3)^2+3^2=18$，

当 $m = 3$ 时，最优策略是 $[-4][][1]$，$q_1=(-3)^2+4^2=25$，

当 $m = 4$ 时，最优策略是 $[-4][][][1]$，$q_1=(-3)^2+5^2=34$，

当 $m = 5$ 时，最优策略是 $[-4][][][]1]$，$q_1=(-3)^2+6^2=45$，

当 $m = 6$ 时，最优策略是 $[-4][][][][][1]$，$q_1=(-3)^2+7^2=58$，

当 $m = 7$ 时，最优策略是 $[-4][][][][][][1]$，$q_1=(-3)^2+8^2=73$，

**当 $m = 8$ 时，最优策略是 $[][][][][][][][-4,1]$，$q_1=4^2+9^2=97$，**

当 $m = 9$ 时，最优策略是 $[][][][][][][][][-4,1]$，$q_1=5^2+10^2=125$，

当 $m = 10$ 时，最优策略是 $[][][][][][][][][][-4,1]$，$q_1=6^2+11^2=157$。

答案即为 $\sum\limits_{i=1}^{10}q_i \bmod 998244353=645$。

我们看向加粗部分，发现这个时候当前负数也被划分到了最后，这是因为 $(-4+1)^2<(-4+8)^2$，于是放到后面比放到前面更好。

我们假设当 $m$ 到达阈值 $x$ 时需要放到后面，那么显然不等式 $(a_i+1)^2<(a_i+x)^2$ 成立，那么化简后得 $x \geq -2a_i$。正好与上文的阈值 $8 = -2 \times -4$ 对应。

于是我们就证明了上文的结论。

#### 复杂度计算

显然正数负数都可以单次 $O(1)$ 回答。有 $n$ 个数，那么答案计算就是 $O(n)$ 的了。

加上 $\{sum_n\}$ 的预处理 $O(k)$，总的时间复杂度为 $O(n+k)$，可以通过。

## 代码

写的略丑，还望见谅。

```cpp
#include <bits/stdc++.h>
using namespace std;

int MOD = 998244353;
int sum[10000010];

int add(int x, int y) {
	x %= MOD;
	y %= MOD;
	return (x + y) % MOD;
} 

int mul(int x, int y) {
	x %= MOD;
	y %= MOD;
	return ((long long)x * y) % MOD;
}

int f(int x, int b, int e) {
	return add(
		mul(e - b + 1, mul(x, x)),
		add(
			mul(x, mul(b + e, e - b + 1)),
			sum[e] - sum[b - 1]
		)
	);
}

int main() {
    int n, k, ans = 0;
    cin >> n >> k;
    sum[0] = 0;
    for (int i = 1; i <= k; i++) {
        sum[i] = add(sum[i - 1], mul(i, i));
    }
    while (n--) {
        int x;
        cin >> x;
        if (x >= 0) {
            ans = add(ans, f(x, 1, k));
        } else if (k < -2 * x) {
        	ans = add(ans, mul(mul(x + 1, x + 1), k));
        } else {
        	ans = add(ans, mul(mul(x + 1, x + 1), -2 * x - 1));
        	ans = add(ans, f(x, -2 * x, k));
        }
    }
    cout << ans << endl;
    return 0;
}
```

## 结语

- 菜死了，考场上挂分，被嘲讽了。

- 这大样例给了和没给一样。