题目是让你对一个矩阵进行修改：

1. 列翻转

2. 行翻转

3. 单点翻转

由于我们的目的是使用最少次数的 $3$ 操作将矩阵变为全 `0`。

而且容易发现一个性质，操作的先后顺序不影响最终结果，所以我们容易想到，使用 $1,2$ 操作，将 `1` 的数量最小化，最后统计 `1` 的数量，就知道了最少的操作次数。

那么如何操作能够保证我们的 `1` 的数量最少。

如果你仔细观察数据范围，容易发现：

对于 $100\%$ 的数据，保证 $0\le k\le n$。

要知道，$k$ 是能容忍的 $1$ 的数量最多的情况，我们可以非常容易的构造出一个 $k>n$ 的矩阵。

$$\begin{bmatrix}0&1&0&1&0\\0&0&0&0&0\\0&0&0&0&0\\0&0&1&1&0\\0&0&1&0&1\end{bmatrix}$$

容易发现，上面的矩阵最少 `1` 的数量就是 $6$。

因此对于这种特殊的性质，我们需要仔细思考并且利用。

以下称最佳状态为只进行 $1,2$ 操作后 `1` 的数量最少的矩阵。

我们分讨

1. $k<n$，这个情况有什么优美的性质？根据鸽巢原理，一定有一行没有 `1`，所以我们考虑以此为关键下手，我们枚举全是 `0` 的行是哪一个，对于这一行，我们是不能进行 $3$ 操作的，所以我们只能使用列翻转，将这一行全部变为 `0`，那么我们只剩下了行操作和单点操作，容易发现，我们的每个操作只会影响某一行，行与行之间已经无关了，所以对于某一行，我们看他进行行翻转和不进行哪一个 `1` 的数量更少即可，最后的上限就是所有行的答案之和。
    
2. $k=n$，这个情况依然需要进行上面的操作，但是他多了一种情况，每一行都恰好有一个 `1`，那么我们枚举第一行的这个 `1` 的位置，显然其他位置只能通过列操作将它们变为 `0`，那么我们依然只有行操作和单点了，再沿用上面的方法即可。

容易发现两种情况的复杂度都是 $O(n^3)$，但是发现我们进行的操作只有单点/行/列翻转，统计 `1` 的个数，所以我们使用 $\text{bitset}$ 优化即可。

正解复杂度 $O\left(\dfrac{n^3}{w}\right)$