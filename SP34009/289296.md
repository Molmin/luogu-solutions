看见各路大佬都是用的栈，本蒟蒻就来一发用递归的题解吧。

其实这个题目不用管他什么遍历顺序，看他的样例其实就能看懂了。

题目所指的其实就是一个嵌套。

这是第一个样例：

```1 2 2 3 3 1```

发现了什么吗？

两个 $1$ 包含了 $2$ 和 $3$ 所以可以发现它们俩是 $1$ 的子节点。

第二个样例更好的说明了这一点：

```1 2 4 4 2 3 5 5 6 6 3 1```

其中```2 4 4 2```中的两个 $2$ 包含了$4$，所以它有一个子节点: $4$ 。

其他也是如此 但是注意形如```1 2 4 4 2 3 3 1```这种的，其根节点 $1$ 只能包含节点 $2$ 和 $3$，节点 $4$ 是 $2$ 的子节点，不包括在 $1$ 的子节点中。

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int t,n,sd;
int a[110],b[210];
int dfs(int p){
	while(b[++sd]!=p){
		a[p]+=dfs(b[sd]);
	}
	return 1;
}
int main(){
	cin>>t;
	for(int i=1;i<=t;i++){
		memset(a,0,sizeof(a));
		sd=1;
		cin>>n;
		for(int j=1;j<=n*2;j++){
			cin>>b[j];
		}
		dfs(1);
		cout<<"Case "<<i<<":\n";
		for(int j=1;j<=n;j++){
			cout<<j<<" -> "<<a[j]<<"\n";
		}
		cout<<endl;
	}
	return 0;
}
```

结合我的上述思路来看，效果更佳！