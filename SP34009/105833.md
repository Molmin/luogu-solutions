### 对此题的一些看法
这是一道很适合初学者，考察栈应用，树的DFS遍历和欧拉序的题。

### 相关知识的介绍
阅读完题面，看过李煜东蓝皮书的同学们应该都知道树DFS的欧拉序是什么，对没有阅读过的同学，我们在这里介绍一下。

一般来说欧拉序分为两种，我们对此分别进行介绍。

### 欧拉序其一
一般来说，我们在对节点数为$N$的树进行DFS遍历时，对于每个节点，在**刚进入递归时**，以及**即将回溯前**，**各记录一次节点的编号**（即当前遍历到该点的编号），最后产生的**长度为$2N$** 的节点序列即为树DFS的欧拉序。

这一种欧拉序相当于是在dfs的时候，如果某个节点入栈，就把这个节点记录下来，直到后面的操作中这个节点出栈，再记录一次这个节点

也就是说，每个节点严格会在记录中出现两次，第一次是搜索到它的时候，第二次是它的子树完全被搜索完的时候

除根节点外，每个节点严格两个入度两个出度

在树上的移动过程为

![](https://cdn.luogu.com.cn/upload/image_hosting/w3ragvo7.png)

则它的搜索顺序便是

![](https://cdn.luogu.com.cn/upload/image_hosting/tebc2fom.png)

可以发现，这种欧拉序有一个特点：**每个节点x的编号在序列中恰好出现两次**。

我们将这两次出现的位置记为$L[x]$和$R[x]$，则闭区间$[L[x],R[x]]$就是以$x$为根的子树的欧拉序。

### 欧拉序其二
另一种欧拉序相当于是在dfs的时候，如果储存节点的栈变化一次，就把栈顶的节点编号记录下来

也就是说，每当访问完一个节点的子树，则需要返回一次该节点，再继续搜索该节点的其余子树

在树上的移动过程为

![](https://cdn.luogu.com.cn/upload/image_hosting/orf04tnc.png)

则它的搜索顺序便是

![](https://cdn.luogu.com.cn/upload/image_hosting/ewbkjsa5.png)

相似地，我们可以发现，**某个节点在顺序中出现的两次所围成的区间，就表示这个节点与它的子树**。

### 题目求解
了解了上述欧拉序的性质，我们便可以知道，一个点**会且只会**在序列中出现两次，第一次，即递归开始，第二次，即回溯前。

那么显然，我们可以使用一个数据结构——栈，来维护这个遍历的过程。

根据题意，可以设计出具体流程如下的算法：

1. 遍历题目给出的序列，在编号为$x$的点第一次出现时（即对$x$或以$x$为根子树进行递归时，此时$x$未在栈中），则将其入栈。
2. 在编号为$x$的点第二次出现时（即回溯前，$x$此时在栈中），将其出栈，并累加其父亲的子节点数量。

这样我们的问题就解决了，若还有不明白的地方或细节，具体请看下面的代码注释。

```cpp
/*
 * @Author: 樱洛CHANGE 
 * @Date: 2021-01-30 21:21:25 
 * @Last Modified by: 樱洛CHANGE
 * @Last Modified time: 2021-01-30 21:21:57
 */

#include<bits/stdc++.h>

using namespace std;

const int N=105;
int T,n,stk[N],top,num[N];//stk为栈，top为栈顶 
bool ins[N];//入栈标记，ins[i]表示元素i在栈中 

void init()
{
	memset(stk,0,sizeof(stk));
	top=0;
	memset(num,0,sizeof(num));
	memset(ins,0,sizeof(ins));
}

int main()
{
	scanf("%d",&T);
	for(int C=1;C<=T;++C)
	{
		init();//多组数据一定不要忘记初始化 
		scanf("%d",&n);
		for(int i=1;i<=n*2;++i)
		{
			int a;
			scanf("%d",&a);
			if(!ins[a])//若当前节点不在栈中，即第一次出现，则将其入栈 
			stk[++top]=a,ins[a]=1;
			else //若在栈中，即为回溯时，则将其出战，并给其父节点的儿子个数++ 
			{
				if(top==1)
				//特判，若栈中仅有一个节点，即根节点，则不应弹出栈  
				continue;
				num[stk[--top]]++;
				//先累计其父节点儿子个数，然后将堆顶的儿子出栈  
			}
		}
		printf("Case %d:\n",C);
		for(int i=1;i<=n;++i)
		printf("%d -> %d\n",i,num[i]);
		puts("");//SPOJ的题严格保证格式，不要忘记最后的换行  
	}
	return 0;
}
```
