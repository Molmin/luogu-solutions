```cpp
/*
题号：P3467
题目简述：N个矩形,排成一排. 用尽量少的矩形覆盖它们.
数据范围：N<=250005(注意数据范围！我就是因此RE了) 
		  （O(NlogN)或许可行？线性更好）
数据结构：单调栈
		  单调:单调递增或单调递减（元素随下标持续缩小/扩大） 
		  （顺便说一句，答案满足单调性的题目可以考虑二分） 
		  栈？？是一个先进后出（FILO）的数据结构(就像洗盘子，先洗的叠在下面，拿的时候先拿上面的)
		  栈的基本操作： 入栈，出战
		  展示用的两种方式：1.STL:stack<int> st; 定义一个元素类型为int的栈 
		  						  empty() 栈为空则返回真
		  						  pop() 移除栈顶元素
		  						  push() 在栈顶增加元素
		  						  size() 返回栈中元素数目
		  						  top() 返回栈顶元素(不删除) 
		  					2.手写栈:int stack[N];  定义一个元素类型为int的栈 
		  						  top==0 栈为空则返回真
		  						  top-- 移除栈顶元素
		  						  st[++top]=a 在栈顶增加元素
		  						  top 返回栈中元素数目
		  						  st[top] 返回栈顶元素(不删除)
		  由此可以看出，手写栈其实写起来并不困难，甚至十分简单，建议使用 （当然也可以用STL） 
基本思路： 分析题目，容易得出如果两个建筑物高度相等，那么只需要一张海报
		   还记得单调栈吗？我们围欧胡一个单调不减（注意，这里并不是严格单调递增，可以相等） 的单调栈,
		    			   如当前的高度与栈顶的元素相等时，需要的海报数量-1就行了 (O(N)搞定)
*/ 				
#include<bits/stdc++.h>//万能头，再也不用写一大堆头文件啦 
using namespace std;//命名空间 
const int N=250005;//N<=250005 
int stack[N];//定义一个手写栈 
int top=0,n,rubbish,ans;
//top是栈顶，n是建筑个数，ans表示最少需要几张海报,rubbish顾名思义就是垃圾数据，比如建筑物的高w 
int main()//主函数 
{
	int ans=n;//先假设每一个建筑物都需要贴海报 
	scanf("%d",&n);//输入建筑个数 
	scanf("%d%d",&rubbish,&stack[0]);//输入第一个建筑的高，初始化栈 
	for(int i=1,h;i<n;i++)//依次输入高（这里i<n是因为我的下表是从0开始的） 
	{
		//在线操作 
        scanf("%d%d",&rubbish,&h);//输入建筑物的高（scanf比cin快，建议使用） 
        while(top>0&&stack[top]>h) top--;//为了维持单调性，我们必须把小于h的所有栈内元素都弹出 
	    if(h==stack[top])	ans--;//当有两个建筑等高时，原来的两张海报可以替换为一张海报，海报数量就可以减少一个了 
	    stack[++top]=h;//h加入队列 
	}
	printf("%d",ans);//输出answer 
	return 0;//善始善终，retrun 0返回0不可或缺
}
```
