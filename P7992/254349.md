## 题目大意
给你 $N$ 个区间，对于每个 $k$ $( 0≤k≤2M )$，输出满足条件的区间组数。

当两个区间的 **开头之和** $≤k≤$ **结尾之和**，那么这两个区间在当前 $k$ 时满足条件。

## 思路
我们拿样例来说。

```cpp
2 5
1 3
2 5
```

开数组 $a$ 存每个区间的开头，数组 $b$ 存每个区间的结尾。

得到：

```cpp
a[1] = 1
a[2] = 1

b[3] = 1
b[5] = 1
```
开数组 $ha$，$hb$。$ha[i] = j$ 表示两个区间开头之和为 $i$ 有 $j$ 种选择方法，$hb[i]=j$ 表示两个区间结尾之和为 $i$ 有 $j$ 种选择方法。

可得：

```cpp
ha[2]  = 1 : (1,1)
ha[3]  = 2 : (1,2) & (2,1)
ha[4]  = 1 : (2,2)

hb[6]  = 1 : (3,3)
hb[8]  = 2 : (3,5) & (5,3)
hb[10] = 1 : (5,5)
```
使用查分的思想得到差分数组 $f$，然后统计一下输出即可。

$f$ :

| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
0| 0 | +1 | +2 | +1 | 0 | 0 | -1 | 0 | -2 | 0 | -1 |  |


$ans$：

| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| 0 | 0 | 1 | 3 | 4 | 4 | 4 | 3 | 3 | 1 | 1 |

## 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
int n,m;
int a[200010],b[200010];
long long ha[5010],hb[5010];
long long f[100010],ans[100010];
int main ()
{
	ios::sync_with_stdio(false);
	cin>>n>>m;
	for(int i=1;i<=n;i++)cin>>a[i]>>b[i];
	for(int i=1;i<=n;i++)ha[a[i]]++,hb[b[i]]++;
	for(int i=0;i<=m;i++)
		for(int j=0;j<=m;j++)
			if(ha[i]!=0&&ha[j]!=0)f[i+j]+=ha[i]*ha[j];
	for(int i=0;i<=m;i++)
		for(int j=0;j<=m;j++)
			if(hb[i]!=0&&hb[j]!=0)f[i+j+1]-=hb[i]*hb[j];
	ans[0]=f[0];
	for(int i=1;i<=2*m;i++)ans[i]=ans[i-1]+f[i];
	for(int i=0;i<=2*m;i++)cout<<ans[i]<<endl;
	return 0;
}
```

