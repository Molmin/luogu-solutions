# 题意：找出最多出现的两位子串。
注意：如有数量相同，输出字典序最小的两位子串

------------
## 方案一：硬枚举

枚举的方法有2种，一是枚举子串。
```cpp
//手打程序没有把握
for (char i='A';i<='Z';i++)
for (char j='A';j<='Z';j++)   //进行枚举前一个和后一个的字母
{
	int ans=0;
	for (int k=1;k<st.size();k++)
    if (st[k]==j&&st[k-1]==i) ans++;    //通过一维枚举，枚举所拥有的个数
    if (Max<ans)     //注意：这里不要打‘<=’，因为就无法达到字典序小的输出
    {
    	Max=ans;   //覆盖
        c1=i;		//记录前一个。
        c2=j;		//记录后一个
	}
}
```
时间复杂最重要：26²*n=676*100=67600不超时

### 通过枚举子串来道出这里的个数，从而进行累加判断。

二是枚举字符串内的字符，
```cpp
for(int i=1;i<st.size();i++)   //枚举后一点
{
	int ans=0;
	for(int j=1;j<st.size();j++)     //通过一维枚举，枚举所拥有的个
    if (st[i-1]==st[j-1]&&st[i]==st[j]) ans++; //累加
    if (Max<ans)     //注意：这里不要打‘<=’，因为就无法达到字典序小的输出
    {
    	Max=ans;   //覆盖
        c1=i;		//记录前一个。
        c2=j;		//记录后一个
	}
}
```
时间复杂最重要：n²=100*100=10000不超时

### 通过枚举子串来道出这里的个数，从而进行累加判断。


------------
## 方案二：数组计数
把所有情况列入数组内，然后进行查找，输出。
```cpp
	for (int i=1;i<st.size();i++)	//枚举后一个点
	{
		a[st[i-1]-'A'][st[i]-'A']++;	//放入一个数组内
		Max=max(Max,a[st[i-1]-'A'][st[i]-'A']);		//找出最大的数值
	}
	for (int i=0;i<26;i++)
	for (int j=0;j<26;j++)      //已知最大值，用字典序查找
	if (a[i][j]==Max)
	{
		cout << (char)(i+'A')<<(char)(j+'A');输出
		return 0;
	}
```
时间复杂最重要：n+26²=100+676=776(其实在第一循环优化中加入计算字符可以把时间复杂度降低为100)


# **反思：全把大写写成小写，请大家注意一下**