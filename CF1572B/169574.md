### 前言：立志写一篇清晰、简洁的题解。

----

### 题意：

给你一个由 $0$ 和 $1$ 组成的序列 $a$ ，要求你对这个序列进行不超过序列长度 $n$ 次的如下操作：

选定一个 $i$ ，满足 $1\le i \le n-2$ ，将 $a_i,a_{i+1},a_{i+2}$ 三个元素的值都更改为 $a_i\bigoplus a_{i+1}\bigoplus a_{i+2}$ 的值。问你如何操作使得 $a$ 中所有元素的值都变成 $0$ 。如果可行，输出任意方案，否则输出 `NO` ，表示无解。

### 思路：

蒟蒻根本不会巨佬们的方法，于是进行了普通的分类讨论。

第一部肯定要将 $a_1$ 变成 $0$ 。

-	如果 $a_1=0$ ，直接跳开着一步。

-	如果 $a_1=1$ ，那么分情况：

	-	如果前三个数分别是 $1,1,0$ 或者 $1,0,1$ ，那么直接将前面三个数字进行操作即可。
    
    -	如果前三个数分别是 $1,1,1$ 或者 $1,0,0$ ，那么发现没办法直接将第一个元素变为 $0$ ，那么就要先改变后面的（第二、三个）元素。如果二、三个元素同时改变，那么改变后他们的值也一定相同，异或后也一定是 $0$ ，并无法改变第一个元素的值。因此只能在第三个元素上做文章。
    
    	如果第三个元素的后面两个元素（即第四、五个元素）异或的结果为 $1$ ，那么他们就能改变第三个元素的值，进而能将第一个元素改变为 $0$ 。如果不能，那么就继续往后找，找到为之，再往前一组组进行操作。如果找到最后也找不到，那么一定是 `NO` 了。
        
现在第一个元素已经变为 $0$ 了。

好，接下来我们假设数组前面已经有了一堆连续的 $0$ （至少一个），接下来分4种情况讨论（以下情况均令第一个 $1$ 的位置为 $i$ ，且满足 $1\le i \le n-2$ ）：

-	序列为： $0,0\dots 0,1,0,0$ 。

	操作方法：将 $i,i+1,i+2$ 三个位置进行一次操作，变成 $0,0\dots 0,1,1,1$ ，再将 $i-1,i,i+1$ 三个位置进行一次操作，变成 $0,0\dots 0,0,0,1$ 。
    
    2次操作在序列后面多了2个 $0$ 。

-	序列为： $0,0\dots 0,1,0,1$ 。
	
    操作方法：将 $i,i+1,i+2$ 三个位置进行一次操作，变成 $0,0\dots 0,0,0,0$ 。
    
    1次操作在序列后面多了1个 $0$ 。

-	序列为： $0,0\dots 0,1,1,0$ 。

	操作方法：将 $i,i+1,i+2$ 三个位置进行一次操作，变成 $0,0\dots 0,0,0,0$ 。
    
    1次操作在序列后面多了1个 $0$ 。

-	序列为： $0,0\dots 0,1,1,1$ 。

	操作方法：将 $i-1,i,i+1$ 三个位置进行一次操作，变成 $0,0\dots 0,0,0,1$ 。
    
    1次操作在序列后面多了2个 $0$ 。
    
最后，经过操作，能保证序列的前 $n-2$ 个元素都是 $0$ 。

至于最后两个元素：

-	为 $0,0$ ，不用动。

-	为 $1,0$ ，无解，输出 `NO` 。

-	为 $0,1$ ，无解，输出 `NO` 。

-	为 $1,1$ ，将 $n-2,n-1,n$ 三个元素进行一次操作即可。

最后，统计操作次数时发现，每次操作均摊下来，要么能是序列后面多1个 $0$ ，要么能是序列后面多1.5个 $0$ 。至于前面的将第一个元素变为 $0$ 的操作来看，假如他最后搜到了第 $pos$ 个元素才能找到能行的操作，那么退回来的操作次数不会超过 $\frac{pos}{2}$ 次，然而继续往后增加 $0$ 的那个操作，操作到 $pos$ 位置的操作次数也不会超过 $\frac{pos}{2}$ 次。因此，最终的操作次数一定是小于等于 $n$ 次的。因此就不用担心操作次数的问题了qwq。

一些细节还是看代码吧：

```cpp
int n,a[200010];
vector<int> ans;//存储操作方法
void work(){
    ans.clear();//多测清空
    scanf("%d",&n);
    for(int i=1;i<=n;i++){
        scanf("%d",&a[i]);//不想写快读
    }
    if(a[1]==1){
        int i=1;
        while(1){
            if(i+2>n){//找不到能行的位置，直接NO
                puts("NO");
                return;
            }
            if(a[i+1]^a[i+2]==1){//找到的能行的位置
                break;
            }
            i+=2;
        }
        while(i>=1){//回撤操作
            a[i]^=a[i+1]^a[i+2];
            a[i+1]=a[i+2]=a[i];
            ans.push_back(i);
            i-=2;
        }
    }
    for(int i=2;i<=n-2;i++){//逐渐往后加0
        if(a[i]==0){
            continue;
        }
        if(a[i]==1&&a[i+1]==1&&a[i+2]==0){//四种情况
            ans.push_back(i);
            a[i]=a[i+1]=0;
        }else if(a[i]==1&&a[i+1]==0&&a[i+2]==1){//四种情况
            ans.push_back(i);
            a[i]=a[i+2]=0;
        }else if(a[i]==1&&a[i+1]==1&&a[i+2]==1){//四种情况
            ans.push_back(i-1);
            a[i]=a[i+1]=0;
        }else if(a[i]==1&&a[i+1]==0&&a[i+2]==0){//四种情况
            ans.push_back(i);
            ans.push_back(i-1);
            a[i]=0;
            a[i+2]=1;
        }
    }
    if(a[n-1]==1&&a[n]==0){//判断最后两个元素的情况
        puts("NO");
        return;
    }else if(a[n-1]==0&&a[n]==1){
        puts("NO");
        return;
    }else if(a[n-1]==1&&a[n]==1){
        ans.push_back(n-2);
    }
    puts("YES");
    printf("%d\n",(int)ans.size());//输出答案
    for(auto p:ans){
        printf("%d ",p);
    }puts("");
}
```

**完结散花！**