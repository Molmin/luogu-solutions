## 区间DP

看到区间分数最大值就想到区间DP咯qwq

定义 $f_{l,r,k}$ 表示di第 $r$ 个方块后面跟了 $k$ 个颜色相同的方块时，区间 $[l,r]$ 的分数最大值。

为什么这样定义状态呢？假如说定义 $f_{l,r}$ 为区间 $[l,r]$ 的分数最大值，由于区间内可能存在方块能与区间外的方块消除得分，因此这种方法是错误的。为了能与前后建立联系，同时也方便转移，所以定义这样一个奇怪的状态qwq

再假设 $len[i]$ 表示第 $i$ 个颜色串的长度。

现在考虑转移方程，对于 $f_{l,r,k}$ ，我们有两种处理方法：

- 1.直接将第 $r$ 个方块和后面跟的 $k$ 个颜色相同的方块消掉，贡献为 $(len_r+k)^2$ ，再加上前面一段就是当前状态的得分；

- 2.枚举分割点 $i$ ，如果第 $i$ 个方块与第 $r$ 个方块颜色相同，则后面一段可以先算出得分，再加上前面一段，就是当前状态的得分。

还有一种特殊情况：若 $l=r$ ，则当前状态得分为 $(len_r+k)^2$ 。

此处我们采用记忆化搜索，思路比较清晰qwq

```cpp
//搜索部分
int dfs(int l,int r,int k)
{
	if(f[l][r][k]) return f[l][r][k];//记忆化，如果到过这个状态，直接转移
	if(l==r) return (len[r]+k)*(len[r]+k);//l=r,返回(len_r+k)^2
	f[l][r][k]=dfs(l,r-1,0)+(len[r]+k)*(len[r]+k);//第一种方案
	for(int i=l;i<r-1;i++)//枚举中间点
		if(color[i]==color[r])//如果和第r个方块颜色相同
			f[l][r][k]=max(f[l][r][k],dfs(l,i,len[r]+k)+dfs(i+1,r-1,0));//得分取max
          		//第一个dfs的k，是r所在的那一段的长度加上后面的k个方块；
           		//第二个dfs的k是0，因为后面k个方块的贡献在第一个dfs计算完了
	return f[l][r][k];//回溯
}//完结撒花awa
```