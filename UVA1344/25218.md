# 贪心

先将田忌的马和齐王的马排一下序，然后按照以下策略进行贪心 
1. 当田忌最慢的马比齐王最慢的马快，赢一场
2. 当田忌最慢的马比齐王最慢的马慢，和齐王最快的马比，输一场
3. 当田忌最慢的马和齐王最慢的马一样时，比较他们最快的马 
4. 当田忌最快的马比齐王最快的马快时，赢一场先。
5. 否则，拿最慢的马和齐王最快的马比。

## 证明

1、2就不解释了

当情况3时，如果我们不比，则少一个平局，但会多赢若干(可能为0)局

所以我们先比较田忌最快的马和齐王最快的马

如果田忌最快的马快，反正田忌最快的马所在那局一定赢，就耗掉齐王最快的马

否则齐王最快的马所在的那局肯定赢不了，就用最慢的马耗掉它。但是这可能会出现本来是平局，用最慢的马就输了的情况，从而不是最优。

仔细想想，发现本来最慢的马是平局(平局才比最快的马)，也就是两个平局，现在最慢的马输了，但其他局至少会多赢一局(比如直接拿田忌最快的马和齐王最慢的马比肯定赢，其他局还不影响)所以是最优解

### 压行不是很严重的代码?
```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
#define maxn 1005
#define inf 0x7fffffff
int n,a[maxn],b[maxn];
void work(){
	for(int i=0;i<n;i++)scanf("%d",a+i);
	for(int i=0;i<n;i++)scanf("%d",b+i);
	sort(a,a+n);sort(b,b+n);
	int ans=0;
	for(int l=0,r=n-1,l1=0,r1=n-1;l<=r&&l1<=r1;){
		if(a[l]>b[l1])l++,l1++,ans++;
		else if(a[l]<b[l1])l++,r1--,ans--;
		else if(a[r]>b[r1])r--,r1--,ans++;
		else ans-=a[l]!=b[r1],l++,r1--;
	} 
	printf("%d\n",ans*200);
}
int main(){
	while(~scanf("%d",&n)&&n)work();
	return 0;
}
```