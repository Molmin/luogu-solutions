# 写在前面

这是学校留的作业。思路大致与第一篇题解相似，都是二分套二分，只是求法略微不同。本来好高骛远，想着把 ```__int128``` 写通后自己写高精度的，但是因为玄学二分调了很久。同时我觉得第一篇题解的解释太模糊了，我看不懂，所以写一篇题解加入我的理解，希望对后人有所帮助。

与此同时，介绍另一种方法，也是我突发奇想找到的。

## 前置知识

- 二分答案

- 位运算及相关知识

- 高精度 或 ```__int128``` 使用方法

- 前缀和思想

- 计数原理（补充）

## 题目描述（戳这里[查看原题](https://www.luogu.com.cn/problem/SP2319)）

- 给定 $K$，定义一个序列 $\{ 0,1,2, \cdots, 2^K-1 \}$。

- 给定 $M$，要求将原序列恰好分成 $M$ 个**连续子序列**。定义 $N$ 是划分出的每个子序列中的**所有数在二进制表示下 $1$ 的个数**的**最大值**。

- 求 $N$ 的最小值。答案可能爆 ```long long```。

- $1 ≤ K,M ≤ 100$，保证 $M ≤ 2^K$。

# 正文

首先一点：一眼**最小化最大值**，鉴定为**二分**。即二分可能的最大值，然后判断这个最大值是否可能。也就是对原序列拆分时尽可能在满足小于等于最大值的情况下多包含一些数，是一个小贪心。

## 分析

现在来考虑一下如何快速求出**任意区间中所有数二进制表示下 $1$ 的个数和**。

任意区间、询问区间没有单调性，这使我们想到用**前缀和**预处理出所有在 $i$ 位置及其之前的数二进制表示下 $1$ 的个数总和 $sum_i$。那么对于区间 $[l,r]$ 总共 $1$ 的个数就是 $sum_r - sum_{l-1}$。

然而，如果要求出这个前缀和，最直接的方法是直接递推预处理。但是观察到 $2^K$ 最大达到了约 $10^{30}$。不论是空间还是时间都是不可接受的。又有同学会想到用**矩阵快速幂**加速递推，也就是每次需要的时候就快速幂一次矩阵。乍一看似乎可以，但是仔细思考发现 $sum_i$ 除了与 $sum_{i-1}$ 的值有关，其增加的值还与 $i$ 这个数本身的二进制表示有关，矩阵很不好实现。

所以直接预处理前缀和是不太行的。

硬解不行，我们退而求其次。前缀和对于区间查询的时间优势太明显了，我们不想舍弃。如果我们能只通过查询数 $i$ 的**二进制表示**和一些**容易预处理的信息**得到 $sum_i$，那么查询时间复杂度是 $O(K)$，$K$ 很小，可以接受。

因为要查询二进制表示，根据经验我们想到**对每一位分开研究**。所以对于容易预处理的信息，我们定义 $f_i$ 表示 $\{ 0,1,2, \cdots, 2^i \}$ 这个序列中所有数二进制表示下 $1$ 的总和。这样每一位都有可用的信息。

来考虑如何求 $f_i$。直接手算我们得出 $f_0 = 1$、$f_1 = 2$、$f_2 = 5$、$f_3 = 13$、$f_4 = 33$。接下来我们思考如何从 $f_{i-1}$ 递推到 $f_i$，以 $f_2$ 推 $f_3$ 为例。观察下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/2bdaf0ef.png)

$f_3$ 的值（红色）除了 $f_2$ 值（绿色）的累加，还多出了 $(2^2,2^3]$ 二进制表示中 $1$ 的个数。增加的值中，图中紫色方框内所有的 $1$ 都来自 $f_2$ 相同区域。（$0$ 没有任何贡献，不考虑）此时 $f_2$ 对增加值的贡献是 $f_2 - 1$（除去了最高位的那个 $1$）。同时还要加上二进制表示中不同部分（蓝）的 $1$，也就是 $(2^2,2^3]$ 中每个数一个，即 $2^3 - 2^2$。故我们可尝试写出递推方程：

$$\begin{aligned}
f_i &= f_{i-1}+f_{i-1}-1+2^i-2^{i-1} \\
	&= 2\times f_{i-1} + 2^{i-1} -1
\end{aligned}$$

带入 $f_3$ 得 $f_4 = 2\times 13+8-1 = 33$。验证无误。

------------

有了 $f$，我们再看看 $sum_i$ **（引用为 $g_i$）** 怎么求。比如我们来求 $[0,7]$ 中所有数二进制表示下 $1$ 的个数 $g_7$。如下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/az6ajns0.png)

仿照求 $f$ 的方法。$7$ 的第 3 位（蓝）是 $1$。则 $7$ 首先包含 $f_2$ 所表示的所有情况，且这一位多了 $7 - 2^2 = 3$。同理，第 2 位（紫）是 $1$。则未统计的部分（全部在红框左）还被 $f_1$ 包含，同时加上这一位多出的 $7-2^2-2^1 = 1$ 个 $1$。同理在第一位的贡献是 $f_0+7-2^2-2^1-2^0 = 1$。所以 $g_7 = f_2+f_1+f_0+3+1+0=12$。

我们尝试推出一般的计算方法。对于数 $x$，它的第 $i$ 位如果是 $1$，则首先对 $g_x$ 有 $f_i$ 的贡献，除此之外，这一位多出来的 $1$，一定就是因为右面还存在某些位是 $1$ 造成的（比如在上面例子中计算蓝色部分时，多出来的 $1$ 右边的位都不是全 $0$），因为序列连续，所以多出来的这些 $1$ 的总数一定是 $x$ 减去**二进制下第 $i$ 位及其左侧不变，右侧都是 $0$ 所表示的数**。例如例子中在第 $2$ 位多出来的 $1$ 就是 $x$ 减去 ```0110```，即 $7-6=1$。

形象化地写出来，我们首先定义集合 $S$ 表示 $x$ 在二进制表示下所有表示 $1$ 的位置（**0 作为最右（低）位**）。则有：

$$ g_x = \sum_{i\in S}{(f_i+x-\sum_{j\in S}^{j ≥ i}{2^j})} $$

注意**枚举时要倒序**。这样保证了高位先做贡献，不会丢位。最后写出代码很简单，也是应用了前缀和的思想，具体看代码。这样，我们就在 $O(K)$ 下求得了任意数 $x$ 的 $g_x$（$sum_x$）。

这块是本题的难点，也很难形象化的描述，画图加解释是我自己成功理解的方法，但是表述出来还是有些模糊，如果读不懂可以多读几遍或者自己画个图探究一下求法。

## 细节与实现

1. 对于 $f$ 和 $2$ 的所有幂，我们可以在程序开始前 $O(K)$ 预处理得出。

2. 对于二分答案的 ```check()``` 函数，我们要尽可能多取数，也就是让取数区间的右侧尽可能大。这也是一个具有单调性的问题。故我们可以再次用二分实现找到最大右端点的操作（也就是前面说的二分套二分）。

   具体的，对于左端点 $now$，二分出的位置 $mid$，根据我们 $g$ 的求法，如果 $g_{mid} - g_{now-1} ≤ mx$，也就是小于等于外层二分的答案时，最终位置还可以靠右，否则只能靠左。
   
3. 注意二分的范围。（我因为范围错了玄学 WA 调了一天）

   - 对于外层的二分。答案最大可以把整个序列都分在一起，即最大是 $f_{K}$。而最小值，为了让分出来的序列合法，也就是至少包含一个数，则答案的最小值就是所有数中二进制表示下 $1$ 的个数最多的个数。也就是 $K$（对应十进制是 $2^K-1$）。最后二分答案区间是 $[K,f_{K}]$。
   
   - 对于内层的二分。显然为了合法（至少有一个数）最小值是 $now$。最大能划分的数不超过 $2^K-1$。

4. 注意类型溢出。简单估算一下 $f_K$ 的最大值。根据上文的递推式，对答案影响最大的是 $2$ 的幂。通过找规律（这块不重要，大概就是只观察幂，抹去 $-1$ 等操作，每次翻倍后合并，能发现最后有一定的关系；或者直接算几个小数也行），$f_K \approx K \times 2^{K-1} \approx 6\times 10^{31} $。可以用 ```__int128``` 或者手写高精度。但是手写高精度位运算不好实现，所以代码中对与运算最好替换为其他方法。

最后分析一下时间复杂度。根据刚才的估算，外层二分复杂度 $O(\log (K\times 2^K))= O(K+\log K)\approx O(K)$（偏大）。内层单次最坏复杂度是 $O(\log 2^K) = O(K)$，最多进行 $M$ 次，内层是 $O(KM)$ 的，在乘上每次计算 $g$ 的 $O(K)$。最终总复杂度 $(K^3M)$，当然跑不满，因为分析的都是最坏复杂度，但是一次运行中最坏情况不可能出现多次，所以随机数据还是很快的。

# 代码

代码没有使用位运算，如果想换高精度应该也很容易。

```cpp
#include <iostream>
#include <algorithm>
#include <cstring>

using namespace std;
typedef __int128_t Big;
const int maxm = 105;

Big f[maxm];
Big Pow[maxm];
int k, m;

void init(){
    Pow[0] = f[0] = 1;
    for (int i = 1; i < maxm; i ++){
        Pow[i] = Pow[i-1] * 2;
        f[i] = f[i-1] * 2 + Pow[i-1] - 1;
    }
}

Big g(Big x){
    if (x < 0) return 0;
    Big res = 0;
    for (int i = k; i >= 0; i --){
        if (Pow[i] <= x){
            x -= Pow[i];
            res += f[i] + x;
        }
    }
    return res;
}

void print(Big x){
    int stk[40], top = 0;
    while (x){
        stk[++ top] = x % 10, x /= 10;
    }
    for (int i = top; i > 0; i --){
        cout << stk[i];
    }
    cout << endl;
}

bool check(Big mx){
    Big now = 0;
    int cnt = 0;
    while (now <= Pow[k]-1){
        Big l = now, r = Pow[k] - 1, ans = now, mid;
        while (l <= r){
            mid = (l + r) / 2;
            if (g(mid) - g(now - 1) <= mx){
                ans = mid, l = mid + 1;
            }
            else r = mid - 1;
        }
        now = ans + 1;
        if (++ cnt > m) return false;
    }
    return true;
}

int main(){
    ios::sync_with_stdio(false);
    cin.tie(0), cout.tie(0);
    init();
    
    cin >> k >> m;
    
    Big l = k, r = f[k], ans = f[k], mid;
    while (l <= r){
        mid = (l + r) / 2;
        if (check(mid)){
            ans = mid, r = mid - 1;
        }
        else l = mid + 1;
    }

    print(ans);

    return 0;
}
```

# 补充

是否觉得上文中的解法实在不好理解？下面再介绍另一种方法，实话说是因为看到估算的那个式子 $K \times 2^{K-1}$ 进而推出的（这真的是估算）。最后用搜索实现，常数偏大。

## 引理

$$ \sum_{i=0}^{n}{C_n^i} = 2^n $$

两种理解：

- 根据二项式定理。$\sum_{i=0}^{n}{C_n^i} = \sum_{i=0}^{n}{C_n^i}\times 1^i\times 1^{n-i} = 2^n$。
- 每一位都有选或不选两种情况，全部方案 $2^n$。而上式也表示所有情况，所以相等。

## 探究

上面那个式子，可否应用到前文所求的 $f$ 数组中？结合数组的定义。对于 $f_i$，它表示的是二进制表示下前 $i$ 位任意取 $1$ 或 $0$，再加上一种前 $i$ 位全是 $0$，第 $i+1$ 位取 $1$ 的情况下 $1$ 的总数。因此：

$$\begin{aligned}
	f_i &= \sum_{j=0}^i{j\times C_i^j}+1 \\
        &= \sum_{j=0}^i{j\times\dfrac{i!}{j!\times{(i-j)!}}}+1 \\
        &=\sum_{j=0}^i{\dfrac{i\times (i-1)!}{(j-1)!\times{(i-j)!}}}+1 \\
        &=i\times\sum_{k=-1}^{i-1}{C_{i-1}^k}+1\\
        &= i\times{2^{i-1}}+1
\end{aligned}$$

而给定 $i$ 位二进制任意表示下 $1$ 的个数和就是 $i\times{2^{i-1}}$。

------------
接下来考虑如何求 $g$？

对于一个数 $x$，我们从高位到低位考虑，对于第 $i$ 位分类讨论：

- 原数第 $i$ 位是 $1$。根据 $g$ 的定义：

	- 如果考虑其前面的数这一位是 $0$，则该数无论前 $i-1$ 位如何取都一定比原数小。此时对答案的贡献是 ${(i-1)}\times{2^{i-2}}$。对前一位取数方案数的贡献是 $2^{i-1}$。
    
    - 如果考虑其前面的数这一位是 $1$，又要满足考虑的数一定不大于原数，因此仅靠这一位无法决策，与后面的二进制表示有关。但是这位 $1$ 对答案的贡献一定是后面所有合法取法的方案数总和乘以 $1$。

- 原数第 $i$ 位是 $0$。同理，无法决策，需要继续根据下一位决定，不同的是此时这一位不具有贡献但可以传递后面取法的方案数。

是不是很像递归？确实如此，下面给出 $g_6$ 的搜索树，具体搜索写法请读者思考。

![](https://cdn.luogu.com.cn/upload/image_hosting/7oiy532e.png)

其中红色是对答案的贡献，紫色是对方案数的贡献。

因为每次搜索对同一位可能决策两次，但是对于 $0$ 是即求即返回，所以复杂度仍然是 $O(K)$，常数是前面递推方法的两倍。

## 核心代码

```cpp
Big DFS(Big x, int bit, Big &res){
    if (bit < 0){
        return 1;
    }
    if (Pow[bit] & x){
        Big temp = DFS(x, bit - 1, res);
        res += temp;
        if (bit){
            res += Pow[bit-1] * bit;
        }
        temp += Pow[bit];
        return temp;
    }
    return DFS(x, bit - 1, res);
}
```

# 总结

本文介绍的两种方法都很有意思。一种需要组合数学，一种是直接根据定义观察递推，两种方法理解了都会有很多益处，第二种方法是估算时突发奇想研究出来的，所以导致这篇题解篇幅过长，还望谅解。

谢谢观看！

