### 关于题目
[题面传送门](https://www.luogu.com.cn/problem/CF379B)

这又是一道水绿题，实际难度应该只有红到橙左右。

### 思路分析

这道题比较方便的地方时不要求求出最短方案，而是合理即可。观察数据范围 $2≤n≤300$ 且 $1≤k≤10^6$。很容易可以发现我们从第一位开始一个数位一个数位的放钱，把一个数位放完后在去放下一个。但是，由于不能连续两步放钱，所以我们需要在放一次钱后来回走两步。举个例子，比如说现在第 $1$ 位需要放 $2$ 块钱。
我们可以先放 $1$ 块钱，再走到第 $2$ 位， 再走回第 $1$ 位， 再放 $1$ 块钱。放完了过后就向右走，找下一个需要放钱的地方。

### 细节注意

- 不能越界，也就是不能在第 $1$ 个点向左走， 第 $n$ 个点向右走。
- 就算所有的钱都放完了，也还可以继续移动。
- 其他细节详见代码。

### 代码实现
```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 1010;

int n;
int a[N];

int main()
{
	scanf("%d", &n);
	for (int i = 1; i <= n; i++)
		scanf("%d", &a[i]);
	for (int i = 1; i <= n; i++)
	{
		if (!a[i])//如果不用放钱，就直接往右走。
		{
			if (i != n)//如果在最右边，就不能往右走了。
				printf("R");
			continue;
		}
		while (a[i]--)//放钱
		{
			if (i < n)//不同的徘徊凑步数方式，为了防止越界。
				printf("PRL");
			if (i == n)//最左边不能往最左边走，最右边不能往最右边走。
				printf("PLR");
		}
		if (i != n)//如果不是最右边，继续往右边走。
			printf("R");
	}

	return 0;
}
```
