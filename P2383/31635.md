呵呵，这是![搜狗截图20180930164005.png](https://i.loli.net/2018/09/30/5bb08c86e91b0.png)的题目，其实是一道暴搜题，相信大家都会写。

但是，它之所以能被评为![搜狗截图20180930164005.png](https://i.loli.net/2018/09/30/5bb08c86e91b0.png)是因为纯粹的暴搜是无法过了这题的，需要加一些 **剪枝**。

---

![搜狗截图20180930164758.png](https://i.loli.net/2018/09/30/5bb08dca30930.png)

这是我的提交记录，可以看到，从一开始的 `TLE` 到 `AC`，时间差距是巨大的，甚至同样 `AC` 的代码也有 5 倍时间的差距。这都是剪枝的操作所导致的。

---

先来讲讲怎么从 `TLE` 到 `AC`，这是我暴搜最初的版本：
```c++
bool dfs(int t, int l1, int l2, int l3, int l4){ //t 表示当前到第几个棍子了，l1,l2,l3,l4分别是正方形的四条边的长度，返回值表示是否可行
    if (t == n + 1){return (l1 == l2 && l2 == l3 && l3 == l4);}
    if (dfs(t+1, l1 + a[t], l2, l3, l4)) return true;
    if (dfs(t+1, l1, l2 + a[t], l3, l4)) return true;
    if (dfs(t+1, l1, l2, l3 + a[t], l4)) return true;
    if (dfs(t+1, l1, l2, l3, l4 + a[t])) return true;
    return false;
}
```

这个暴搜没有经过任何优化，我们需要考虑优化的动机。我们发现，有一些状态是 **没有必要枚举下去的**，举个例子，如果 $sum = \Sigma a_i$，$sum$ 不是 4 的倍数，那么显然不能拼成正方形；进一步，如果 `l1,l2,l3,l4` 中的某个数大于 $sum \over 4$，显然应该返回 `false`，没有必要枚举下去。

加了这两个优化，代码就 `AC` 了哈。

---

还能不能进一步优化呢？
思考刚才那个剪枝，因为剪枝肯定是越早越好，如果我们把棍子按照长度降序排列，那么剪枝的时间肯定会有所提前。这个优化可以把时间优化到原来的 $1 \over 5$。
至于我的那个 `CE`，是因为降序排序时 `sort(a+1, a+1+n, greater<int>() )` 写成了 `sort(a+1, a+1+n, greater<int> )`，话说难道我以前都写错了QAQ？