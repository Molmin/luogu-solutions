- Subtask 1

  直接 $O(nm)$ 暴力
  
- Subtask 2

  显然如果没有强制在线，我们可以在进行完所有操作二后再处理查询
  
  然后我们按照 $a_i$ 进行排序，按 $a_i$ 从小到大加入每个 $b_i$，使用线段树动态维护每次加入后序列的颜色段信息
  
  然后对查询按照 $x$ 从大到小排序，处理 $x = a_i$ 的查询即可
  
- Subtask 3

  因为修改操作很神奇，是在末尾插入，所以可以考虑维护前缀信息
  
  我们对于每个前缀 $[1,i]$，动态维护所有 $x$ 的答案
  
  考虑如何由 $[1,i - 1]$ 推及 $[1,i]$：加入 $a_i$ 的信息，只会使 $x \ge a_i$，且 $lst_x \neq b_i$ 的 $x$ 答案增加 $1$，$lst$ 是我们维护的每个 $x$ 对应的最后一个颜色的值
  
  乍一看如果要维护，复杂度会相当高。但是在进行完这次操作后，所有 $x \ge a_i$ 的 $lst_x$ 都会变为 $b_i$，这意味着我们可以使用颜色段均摊
  
  具体来说，我们将 $lst$ 相同的一些连续的 $x$ 缩成一个段，放到一个 set 里，每次在末尾插入时，遍历所有涉及的段，看是否需要给这一段的 $x$ 答案 +1，最后删掉所有涉及的段，放入一个大段即可
  
  给这一段 $x$ 答案 + 1 的操作，可以使用可持久化线段树，先让 $[1,i]$ 的答案继承 $[1,i - 1]$ 的信息，然后给需要 +1 的那些段进行区间加操作
  
  这样查询就是一个单点查询
  
  实际上没有必要真的写区间加，单点查询，可以通过差分支持单点加，区间求和
  
- Subtask 4

  给一些 $O(m \log^2 n)$ 或 $O(m \sqrt n)$ 的解法
  
- Subtask 5

  区间颜色段数实际上具有一定的可减性，$[l,r]$ 的答案相当于 $[1,r] - [1,l - 1] + [lst = fst]$，$lst$ 表示 $[1,l - 1]$ 中最后一个 $a_i \le x$ 的 $b_i$，$fst$ 表示 $[l,r]$ 中第一个 $a_i \le x$ 的 $b_i$
  
  那么只要能够找到 $lst,fst$ 就解决问题了
  
  我们可以写一个数据结构，维护 $a_i$ 的区间 $\min$，然后从 $l$ 分别向左，向右二分，就可以找到第一个 $a_i \le x$ 的位置
  
  因为二分有一个 $\log$，所以要支持 $O(1)$ 查询才能保证复杂度，因为只在末尾插入，可以使用 ST 表，$ST_{i,j}$ 维护 $[j - 2^i + 1,j]$ 的 $\min$（这个东西貌似有些人叫做动态ST表）
  
  当然你写个线段树上二分之类也是可以的
  
  综上，这是一个时间复杂度为 $O((n' + m) \log n)$，空间复杂度为 $O(n' \log n)$ 的算法
  
- Subtask 6

  我们来分析一下空间常数
  
  首先，加入 $i$ 的信息会增加 $1$ 个颜色段，因此一共会有 $n'$ 个颜色段，每个颜色段可能引起两次单点修改
  
  而加入 $i$ 的信息需要一次单点修改，于是你一共需要 $3n'$ 次单点修改
  
  （如果你实现不太好，分裂 $a_i$ 所在段得到的后半部分恰巧 $lst = b_i$ 的话，会达到 $5n'$）
  
  因此你需要 $4.5 \times 10^7$ 个节点，每个节点需要三个 `int`，然后你挂了
  
  考虑怎么优化，首先可以合并相邻同色颜色段，这样你推掉 $s$ 个段，至多只有 $\left \lceil \frac{s}{2} \right \rceil$ 个段需要进行两次单点修改，修改数是 $s + 1$ 级别的
  
  什么时候能卡到 $s + 1$ 呢？答案是开头与结尾都是 $lst = y$ 的情况，特判掉开头就可以了
  
  于是只要 $2n'$ 次单点修改，这样会有 $3.1 \times 10^7$ 个节点
  
  但是这样你还是过不去，大概需要 343M 的样子
  
  考虑主席树的结构，如果你使用的标号方式是开一个 $cnt$，每次分配第 $cnt$ 个位置的话，你会发现对于树上每个节点 $rt$，其左右儿子中，必定有一个的编号是 $rt + 1$
  
  于是我们只存不是 $rt + 1$ 那个位置的编号 $x$，加一位标示哪个儿子是 $rt + 1$
  
  剩下存区间和是无法避免的，这样的信息量是 $5 \times 10 ^ 5 \times 3.1 \times 10^7 \times 2 = 3.1 \times 10^{13} < 2^{48}$
  
  于是可以使用一个 `unsigned int` 和一个 `unsigned short` 压缩存储信息
  
  具体分配：`unsigned int` 的 $0 \sim 24$ 位存储 $x$，第 $25$ 位是标示符，$26 \sim 30$ 位存 $val \bmod 2^5$，$31$ 位存储 $val$ 正负性，`unsigned short` 存 $\left \lfloor \dfrac{val}{2^5} \right \rfloor$ 
  
  主席树部分需要 172M 左右，剩下的数组的空间开销并不大
  
  本场比赛应该只有这个 Subtask 算是卡常的