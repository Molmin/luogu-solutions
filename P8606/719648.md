每两个和尚之间看做一堆,转换为 Nim 博弈即可.

如果将棋子两两成对当作整体考虑，就可以看作 Nim，每对棋子看做一堆石子，石子数相当于棋子间的距离，向上移相当于取走石子；另一方面，将上面的棋子向上移动相当于增加了棋子数量，对手只要把和它成对的另一个石子移动到它的后面就又回到了原来的状态，奇数时特殊处理.

1)  是否可胜.

2)  若可胜，暴力第一步.
```cpp
#include<iostream>
#define N 102
using namespace std; 
int main(){
  int a[N],b[N];
    int n = 0,i,j,k,sum = 0;
      while(cin>>a[n])n++;//存储又有多少个小和尚 
     for(i=1; i<n; i++)b[i-1] = a[i] - a[i-1] - 1;// 进行Nim博弈的转换 
       for(i=0; i<n-1; i+=2) sum ^= b[i];//进行异或 
    if(sum==0)cout<<-1<<endl;//若开始局面为 0 则必输 
    else//若非0 则必赢，因此 需要找到第一步 将局面变为 0 的步骤 
    {
        for(i=0; i<n-1; ++i)//枚举移动第 i 堆  使得剩下的局面异或等于0，
            for(j=1; a[i]+j<a[i+1]; ++j) {//枚举可以移动的步数  保证 前项移动j 步后 不会超过后项 
                b[i] -= j;//拿走 j 个 ，这里代表 前一个向上移动j步 
                if(i!=0)b[i-1] += j;//它的后一堆b[i]向取走了j个，那莫前一堆 b[i-1] 则要增加 j 个 第一堆除外 
            sum = 0;
            for(k=0; k<n-1; k+=2) sum ^= b[k];//重新计算局面， 
           if(sum==0) {cout<<a[i]<<" "<<a[i]+j<<endl; break;}//若变成 0  则后手必败，先手必赢。跳出即可； 
            b[i] += j;//回溯 这不是必赢的操作 
            if(i!=0) b[i-1] -= j; 
          }
    }
    return 0;   
}
```
