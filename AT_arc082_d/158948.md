口胡一个严格被优于 $O(K+Q)$ 的分段函数解法的解法（悲）

形式化的转化一下题意就是：

- 只考虑一个沙漏的沙，初始为一个数 $a$。

- 每次对这个数进行 $+v_i$ 或 $-v_i$ 的操作，但时刻保证 $a\in[0,X]$。

  也就是每做完一次后对 $0$ 取 $\max$，对 $X$ 取 $\min$。
  
  其中 $v_i$ 可以由初始给定的值推出。
  
- 询问在某个操作中途 $t$ 时刻 $a$ 的值。

考虑一次询问，发现 $a$ 的行走过程只与第一次碰 $0$ 的底或是碰 $X$ 的顶有关。

后面就转化为了询问从某个操作后的 $0$ 出发或是某个位置的 $X$ 出发的答案，就可以在预处理上下功夫了。

先假设这个数一直没有触顶或底，那么第 $i$ 个操作完后的值为 $a+\sum_{j=1}^iv_j$，不妨令 $S_i=\sum_{j=1}^iv_j$，也就是 $a+S_i$。

如果一个数在 $i$ 之前触底了，也就是 $\exists j\le i,a+S_i\le0$，不难看出就是 $a+\min\limits_{1\le j\le i}S_j\le0$。

于是我们可以预处理出 $S_i$ 的前缀 $\min$，然后二分来判断在哪里第一次触底，触顶也是同理，处理前缀 $\max$ 即可。

第一次触边界显然就是第一次触底和第一次触顶中更小的那个。

现在考虑从一个操作 $i$ 后从 $0$ 或 $X$ 开始的行走过程，我们又发现它只与下一次碰 $0$ 的底或是碰 $X$ 的顶有关。

于是我们同上一个做法处理出它第一次触底或触顶的位置，注意这里就要用 RMQ 来处理区间最小/最大值了。

用 $(i,0/1)$ 表示操作 $i$ 后为 $0$ 或 $X$ 的状态，$nxt_{(i,0/1)}$ 表示第一次触边界后的状态，显然是可以预处理的。

然后我们直接设 $N_{(i,0/1),j}$ 表示第 $2^j$ 次触边界的状态，就可以倍增了。

令 $T_{(i,0/1)}$ 为 $i$ 操作后的时间，对于一次询问直接倍增到 $T_{nxt_{(x,0/1)}}\ge t$ 的第一个 $(x,0/1)$ 的状态就可以直接回答了，因为从这个状态走到 $t$ 都不会触边界，直接算位置就是对的。

上述算法复杂度 $O((K+Q)\log K)$，顺便口胡一下分段函数，真的是严格优于上述算法。

考虑函数 $f_{t}(a)$ 表示在时间 $t$ 时，初始为 $a$ 的答案，是以 $a$ 作为变量的一个函数，也就是固定了 $t$。

发现这个函数的样子一定形如：

初始 $t=0$：

![](https://cdn.luogu.com.cn/upload/image_hosting/3wg7qyiq.png)

操作一次 $t=T_{(1,0/1)}$：

![](https://cdn.luogu.com.cn/upload/image_hosting/9lr7v5sm.png)

操作两次 $t=T_{(2,0/1)}$：

![](https://cdn.luogu.com.cn/upload/image_hosting/x44nenud.png)

操作三次 $t=T_{(3,0/1)}$：

![](https://cdn.luogu.com.cn/upload/image_hosting/mfxoee4i.png)

不难发现就是个只有两个转折点的简单分段函数，对于从头模拟一遍，对于每个时间 $t$ 记录一下两个转折点的位置即可快速回答答案。

发现这个算法离线时显然就是 $O(K+Q)$ 的了，在线也是 $O(K+Q\log K)$ 优于之前的倍增算法。