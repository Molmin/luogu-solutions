# 后缀数组的做法

注意：

1. 这题字符串是从当前节点向上，编号却是从根向下！
1. 比较相当于比较（当前节点到根的字符串，根到当前节点的编号）的二元组！

考虑倍增时的比较顺序：

1. 当前字符串的大小。
1. 祖先字符串的大小。
1. 祖先字符串编号的大小。
1. 当前字符串编号的大小。

可以将2,3合并，将4前面增加一个1（因为如果比较到了第4关键字，第1关键字必然相等，可以随意添加），如下：

1. 当前字符串的大小。
1. 祖先字符串（字符串，编号）的大小
1. 当前字符串（字符串，编号）的大小

## 实现

在排序时：需要保证第一个数组`rk`是第一关键字，第二个数组`tp`是第二关键字''的逆''。返回的结果是排名的''逆''`sa`。

### 预处理

以字符大小为第一关键字，以当前节点编号（其逆为本身）为第二关键字，排序即可。

### 倍增

考虑前一轮已经完成对字符串前`1<<k`个字符的排序，设顺序为`sa`，字符串大小为`rk`（可重），（字符串，编号）大小为`rkk`（不重）。

那么，可以顺序按照如下的关键字来排序，得到`1<<(k+1)`的答案：

1. 当前字符串的大小`rk`
1. 祖先（字符串，编号）的大小（由`rkk`得到，存储在`rk2`中）。
1. 当前字符串的（字符串，编号）的大小`rkk`（其逆为`sa`）。

排序时可以先合并后两个关键字，再将得到的逆排名与第一关键字合并。

### 代码

（参考[xht37大佬的题解](https://www.luogu.com.cn/blog/xht37/p5353-mu-ban-shu-shang-hou-zhui-pai-xu)）


```cpp
inline void tsort(int *sa, int *rk, int *tp, int m) {
	for (int i = 0; i <= m; ++i) tx[i] = 0;
	for (int i = 1; i <= n; ++i) tx[rk[i]]++;
	for (int i = 1; i <= m; ++i) tx[i] += tx[i-1];
	for (int i = n; i; --i) sa[tx[rk[tp[i]]]--] = tp[i];
}


	for (int k = 0; (1<<k) < n; ++k) {
		for (int i = 1; i <= n; ++i) {
			rk2[i] = rkk[fa[k][i]];
		}
		tsort(tp, rk2, sa, n);
		tsort(sa, rk, tp, n);
		swap(rk, tp);
		p = rk[sa[1]] = rkk[sa[1]] = 1;
		for (int i = 2; i <= n; ++i) {
			rk[sa[i]] = (#cmp(sa[i], sa[i-1], k)) ? ++p : p;
			rkk[sa[i]] = i;
		}
	}
```

### 注

为了卡常，可以在倍增的时候将`f[i][k]`（`i`表示当前节点，`k`表示层数）的下标顺序交换，变成`f[k][i]`，实测快了200+ms。