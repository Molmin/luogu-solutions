这个题其实相当水，主要难度在于阅读理解。题目中“找到在它左边最靠近它的左括号匹配，如果没有就放弃。”的意思其实是对于任意一个右括号（  “）”或者“]”  ），从他开始向前遍历找到第一个任意形式的左括号（“（”或者“[” ）进行匹配，即使两个括号不匹配（“（]”或者“[)”）也停止遍历，直接给该右括号打“不能匹配”的标签然后大循环继续向后遍历。

这样就好办了。先给所有括弧初始化不匹配的标签，然后建一个栈，大循环从前向后遍历，找到任意形式的前括号（“[”或“（”）就把这个前括号入栈，遇到任意后括号就把该后括号与当前栈顶的前括号匹配，如果匹配就给两个括弧打上成功匹配的标签，让栈顶的前括号出栈然后继续遍历；如果两个括弧不匹配就直接保留该括弧的不匹配标签然后大循环继续向后遍历。最后在输出的时候如果字符有成功匹配的标签就直接输出，否则将其补全（"("or")"-->"()"，"["or"]"-->"[]"）然后再输出。


```cpp
#include<bits/stdc++.h>
using namespace std;
string a;
bool pd[10000000];
struct zh{
	char k;
	int ad;
}z[10000000];//模拟栈
int top=0;
int main(){
	cin>>a;
	memset(pd,0,sizeof(pd));
	for(int i=0;i<a.length();i++){
		if(a[i]=='['||a[i]=='(')	z[top].k=a[i],z[top].ad=i,top++;//入栈
		if(a[i]==')'&&z[top-1].k=='(')	pd[i]=1,pd[z[top-1].ad]=1,top--;//出栈
		if(a[i]==']'&&z[top-1].k=='[')	pd[i]=1,pd[z[top-1].ad]=1,top--;//出栈
	}
	for(int i=0;i<a.length();i++){
		if(pd[i]==1)	cout<<a[i];
		else{//补全括号
			if(a[i]=='('||a[i]==')')	cout<<"()";
			if(a[i]=='['||a[i]==']')	cout<<"[]";
		}
	}
	return 0;
}
```
