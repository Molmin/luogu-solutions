## 题目描述
定义如下规则序列(字符串)：

1. 空序列是规则序列；
2. 如果 $S$ 是规则序列，那么 $(S)$ 和 $[S]$ 也是规则序列；
3. 如果 $A$ 和 $B$ 都是规则序列，那么 $AB$ 也是规则序列。

例如，下面的字符串都是规则序列：

`()`，`[]`，`(())`，`([])`，`()[]`，`()[()]`

而以下几个则不是：

`(`，`[`，`]`，`)(`，`())`，`([()`

现在，给你一些由`(`，`)`，`[`，`]`构成的序列，你要做的，是补全该括号序列，即扫描一遍原序列，对每一个右括号，找到在它左边最靠近它的左括号匹配，如果没有就放弃。在以这种方式把原序列匹配完成后，把剩下的未匹配的括号补全。

## 样例数据
输入
```
([()
```
输出
```
()[]()
```

## 思路
每一个括号有以下四种可能：
- `(` 左括号直接加入匹配栈
- `)` 右括号如果是左括号的匹配括号（`()()`） 就将右括号和左括号一起匹配，否则（`))`）将其加入匹配栈
- `[` 左括号直接加入匹配栈
- `]`右括号如果是左括号的匹配括号（`[][]`） 就将右括号和左括号一起匹配，否则（`]]`）将其加入匹配栈

剩下的括号匹配栈里的内容我们直接将其加入到一个待匹配数组之中，然后将其排序并按照原括号输出。

## 代码
题不难，但是坑多，下面简单说下在实现过程当中遇到的坑：
1. 括号匹配栈有可能空着：例如：`]]]]]]]]]]]]]]`解决过程：判定`s.empty()`在执行循环
（参考代码 line 16~line 49）
2. 注意此时`s.empty()` 的时候也是要进入匹配的（参考代码 line 32~34 , 45~47）
3. 需要排序一遍然后输出（参考代码 line 60）
4. 即使这样也不能立刻欢乐的输出并`return 0` ，当时我们的已匹配括号不是自动忽略了吗？现在要补回来(参考代码 line 77 ~ line 79)

```cpp
#include <bits/stdc++.h>
using namespace std;
const int maxn = 10001;
typedef pair <int, char > as;
stack <as > s;
int main() {
	std::string ss;
	cin >> ss;

	int a = 0;
	int sslen = ss.length();

	int dd[10001];
	memset(dd, 0, sizeof(dd));
	
	for (int i = 0; i < sslen; ++i) {
		// 先扫一遍，找到没有匹配的括号，塞进 dd 里面。
		if (ss[i] == '(' || ss[i] == '[') {
			// 把左括号塞进匹配栈里面 
			s.push(make_pair(i, ss[i]));
		} else if (ss[i] == ']'){
			// 此处用来判定右括号 ']' 是“待匹配括号” 还是 “已匹配括号” 
			// 此处坑点 1 ： s 有可能是空栈 
			if (!s.empty()) {
				as tmp = s.top();
				if (tmp.second == '[') {
					// 已经匹配到了，就不管了
					s.pop();
				} else {
					dd[a++] = i;
				}
			} else {
				dd[a++] = i;
			}
		} else {
			if (!s.empty()) {
				as tmp = s.top();
			//	cout << endl << "pause:" <<tmp.second << endl; 
				// 已经匹配到了，就不管了
				if (tmp.second == '(') {
					s.pop();
				} else {
					dd[a++] = i;
				}
			} else {
				dd[a++] = i;
			}
		}
	}
	// 把所有 "括号匹配栈" 中的元素位置全塞进 dd 里面
	// 之后 s 就可以废弃了 
	
	while (!s.empty()) {
		as tmp = s.top();
		dd[a++] = tmp.first;
		s.pop();
	}
	
	// 此处坑点 2 ：  按顺序匹配括号 
	sort(dd, dd + a);

	// 此处逐一进行括号匹配
	// 在这里使用 cur 作为当前待匹配括号在 dd 中的位置 
	// dd[cur] 为当前待匹配括号位置 

	int cur = 0;
	for (int i = 0; i < sslen; ++i) {
		if (cur < a && dd[cur] == i) {
			cur++;

			// 根据源括号类型输出匹配括号
			if (ss[i] == '(' || ss[i] == ')') {
				cout << "()";
			} else {
				cout << "[]";
			} 
		} else {
			cout << ss[i]; // 其他字符照样输出即可 
		}
	}
}
```
