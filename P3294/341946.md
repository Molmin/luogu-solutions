### 题意简化

我们要填入 `n` 个单词。

1. 如果有单词作为当前单词的后缀但并未填入，将花费 `n*n` 的代价。
2. 如果单词中没有当前单词的后缀，代价为当前填入单词序号 `x` 。
3. 如果所有作为该单词的后缀的单词之前都已填入，那么代价等于当前编号 `x` 减去最后一个作为当前单词的后缀的单词的编号 `y` 。

求最小代价。

### 思路剖析

#### 大致步骤

对于后缀处理是不是很麻烦？我们考虑把单词翻转，用前缀处理（毕竟这样处理不会影响答案的正确性，只是更好处理了）。

所以我们在这里翻转所有字符串，后面说的所有字符串都是翻转后的字符串。

说到单词的前缀，除了 `KMP` 以外，就能想到字典树了，所以我们考虑用字典树来处理。

我们的根节点代表的就是空（ `0` 或 `1` ，按个人写字典树的习惯来）。下面连接的是所有长度为 `1` 的前缀，再下面就是长度为 `2` 的前缀……以此类推。所以我们先建立一颗字典树。

建立完字典树呢，我们要找到一个放入单词的顺序，所以我们考虑用一颗树来处理，而遍历顺序算答案中呢，我们只需要每个给定的单词的 **末尾节点** ，那样我们就可以在只有单词末尾节点的情况下还可以保证父节点都是子孙节点的前缀，所以这里就需要把所有的非末尾节点删除。在这我们就要把所有非末尾节点的第一个是末尾结点的祖宗指向它那些末尾结点的孩子们。

举个例子：

```cpp
                                                   (1)
                                                   / \
                                                  2   5
                                                 / \   \
                                               (3)  4  (6)
                                                     \
                                                     (7)
假设这棵树中，用括号括起来的是末尾结点，所以我们删的时候的步骤就是（假设我们用fa[i]来表示删完后i的父亲，原来fa[i]指向字典树中i的父亲）：
fa[3]=1;
fa[7]=1;
fa[6]=1;
删完后变成：
    												1
    											  / | \
    											 3  7  6
    									
```

但对于这样的操作我们该怎么处理呢？我们能发现，并查集就可以实现！！！

所以我们把所有是单词的末尾的节点的父亲指向 `find(fa[i])` ，建立所有都是末尾结点的一棵树。然后按照 `dfs` 的顺序算代价和。

所以大体的思应该是这样的：

1. 对于输入的字符串，建立一颗字典树
2. 去掉所有非单词的末尾的节点，建立新的树
3. 按子树的大小把所有子树从小到大排序
4. 按照 `dfs` 序计算代价

#### 算法证明

我们可以想，我们按照 `dfs` 序的话，顺序靠前面的那颗子树先被统计。我们假设那颗子树中有一个非子树根的节点 `x` ，它和当前子树后面一颗子树的根 `y` 应该那个先统计呢？答案显然是 `x` 先搜好。因为 `y` 在前面，那么按照这个顺序 `y` 与其孩子的距离每个孩子都会增加 `1` ，而所有子树的孩子与其父亲的距离都会增加，那么总代价将会增加很多。但是如果 `x` 在 `y` 前面，增加的无非就是根节点的代价是前面子树的大小，其它节点就是里根节点的距离，而且我们按照子树的大小排序的，所以可以保证最优。

而子树从小到大的证明呢？因为第 `i` 个根节点的贡献是前面所有树的 `size` 之和，为了是总和最小化，我们从小到大排序。

### 代码实现

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=500010;
char x[N];
int n,cnt,bo[N],tot=1,trie[N][27],fa[N],id[N],son[N],num;
long long ans=0;
vector<int>g[N];
int find(int x){
	return fa[x]==x?x:fa[x]=find(fa[x]); 
}
void insert(char s[],int num){//字典树的必备函数
    int l=strlen(s),u=1;
    for(int i=l-1;i>=0;i--){
        int c=s[i]-'a';
        if(!trie[u][c])
			trie[u][c]=++tot;
        u=trie[u][c];
    }
    bo[u]=num;
}
void make_tree(int x){//建立一颗只有末尾节点的树
    for(int i=0;i<26;i++){
        int v=trie[x][i];
        if(v){
            if(!bo[v])
                fa[v]=find(x);
            else
                g[bo[find(x)]].push_back(bo[v]);
            make_tree(v);
        }
    }
}
int cmp(int x,int y){//按子树大小排序
    return son[x]<son[y];
}
void sonsum(int x){//算每颗子树的大小
    son[x]=1;
    for(int i=0;i<g[x].size();i++){
        int v=g[x][i];
        sonsum(v);
        son[x]+=son[v];
    }
    sort(g[x].begin(),g[x].end(),cmp);
}
void dfs(int x){//计算代价和
    id[x]=num++;
    for(int i=0;i<g[x].size();i++){
        int v=g[x][i];
        ans+=num-id[x];
        dfs(v);
    }
}
int main(){
	scanf("%d",&n);
    for(int i=1;i<=n;i++){
        scanf("%s",x);
        insert(x,i);
    }
    for(int i=1;i<=tot;i++)
		fa[i]=i;
    make_tree(1);
	sonsum(0);
	dfs(0);
    printf("%lld",ans);
    return 0;
}
```

