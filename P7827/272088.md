## 前言

联考要讲这题，所以写了篇题解。~~然后太菜了做了一两天才做出来。~~

## 测试点 $1$

交换两个数 $a,b$ 的一种方式为： `a^=b^=a^=b` 。直接暴力操作即可 $5$ 次完成。

## 测试点 $2$

首先不难想到先将 $a$ 取反，算出 $a+b$ 后再取反即为所求。因为 $2^{64}-1-(b+(2^{64}-1-a))=a-b$ 。

想到经典的形式： $a+b=2(a\ \&\ b)+(a\oplus b)$ ，因为 $a\ \&\ b$ 为 $1$ 的位就相当于进位的位，其余位均不进位。

由于对 $2^{64}$ 取模，而 $a$ 每次变为 $2(a\ \&\ b)$ ，即末尾 $0$ 的个数至少增加一个，也就是只需执行 $64$ 次如上变换。

由于求得 $a\ \&\ b$ 或 $a\oplus b$ 之一无法推得另一个，故需要复制一遍 $a$ 或 $b$ 再交换过去，常数很大。

~~由于你要拿最优解~~，又发现最优解常数只有 $3$ ，故基本可以排除该做法，考虑直接在减法上思考。

继续考虑减法的经典形式： $a-b=(a\oplus b)-2(((2^{64}-1)\oplus a)\ \&\ b)$ 。

如果直接做的话常数依旧非常大，考虑改一下 $(((2^{64}-1)\oplus a)\ \&\ b)$ ，即改成 $(a\oplus b)\ \&\ b$ 。

现在常数成功变成了 $3$ ，稍加优化可以拿到最优解。通过类似第一行的变换可以将减法转化成加法。

## 测试点 $3$

根据经典快读写法： `x=(x<<1)+(x<<3)+(ch^48)` ，直接运用 `测试点2` 的加法即可。

直接加的话常数太大，发现值域非常小，可以默认对 $2^k$ 取模，最后移一下位即可减少非常多操作。

~~由于卡不满，可以适量减少减法递归的次数，这样就可以超过最优解。~~不大清楚当前最优解怎么做的。

## 测试点 $4$

发现可以每次将后半部分和前半部分异或，此时答案不变。

由于每次值域开根，故只需要进行 $6$ 次上述操作，再稍微优化一下即可拿到最优解。

## 测试点 $5$

由于限制很紧，不大能拆位做，考虑整体运算。

先将 $a,b$ 异或一下，第一个为 $1$ 的位是比较大小的关键，考虑将它提出来。

提出来的方式就是让它不断右移然后或，此时 $1$ 扩散到后面所有位，此时再右移异或即可。

然后提取出来 $a$ 或 $b$ 的那一位，分 $0$ 或 $1$ 讨论一下再将 $1$ 扩散到 $2^{64}-1$ 再或上即可。

## 测试点 $6$

考虑先将 $a\times b$ 在模 $2^{64}$ 意义下的值算出来，再对 $p$ 取模。

考虑将乘法拆成若干次加法，即提取出来某一位 $b$ 是 $0$ 还是 $1$ 再将 $1$ 扩散到 $2^{64}-1$ 。

此时让扩散后的数或上 $a$ 再左移若干位加上当前答案。操作次数为 $64\times 64\times 3$ 左右。

现在考虑如何对 $p$ 取模，直接将 $p$ 右移一位再将那个 $1$ 扩散到后面再与上答案即可。

## 测试点 $7$

一个初始的思路是将 $p$ 的那个 $1$ 扩散到后面再拿 $11$ 不断与上它再左移右移和异或。

具体的，由于直接扩散会有奇数个 $1$ ，故考虑先左移一位再扩散。

提出来 $1$ 的个数除以 $2$ 个 $11$ ，然后让它们依次异或起来，最后再右移一位即可。

## 测试点 $8$

根据经典结论： $\gcd(a,b)=\gcd(\max(a,b)-\min(a,b),\min(a,b))$ 。

每次找一下最大值和最小值，这两个可以合并一起求，然后再调用减法不断递归即可。

注意值域比较小可以节省非常多的操作次数，而总共要递归差不多值域那么多次。