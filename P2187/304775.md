[**原题链接**](https://www.luogu.com.cn/problem/P2187)

感谢[这篇博客](https://www.luogu.com.cn/blog/Lazyhurryup/solution-p2187)对我的启发，使我彻底明白了这题,我也决定把一些说的不太清楚的地方写清楚。

首先，我发现目前题解中有一些$O(26 \times n)$的做法有一点问题，未曾考虑删除头尾的情况，过不了[这组Hack](https://www.luogu.com.cn/discuss/show/273605)。建议管理员把这组数据加入。

我的做法是$O(26^2 \times n)$和$O(26 \times n)$，下面来看一下我是如何实现的。

# 1、题意理解


给你一个字符串，并给你一些不能相邻的字符，让你求出这个字符串最少要删几个字符才合法。

这是一道典型的动规题，我们来分析一下为什么。

- 首先，这题有后效性，前面删的很可能影响到后面删的。

- 这时可以根据数据来做一个简单判断，发现可以用动归做。

# 2、算法实现

**处理技巧$1$:** 

我们对字符发现不好处理，我们就干脆把每个字符都变成一个数。其中`a`对应$0$，`z`对应$25$。我们就把$0$到$25$这些数与字符建起了联系。

------------
**处理技巧$2$:**

我们开一个数组$d$记录两个字符能否相邻，初始所有值均为零，若$d_{i,j}$ $=$ $1$则表示$i$, $j$两个字符不能相邻，反之则表示可以。这样我们处理起来就方便多了。
## 想法1
设$f_i$表示字符串中前$i$个字符最少要删字符的数量。

显然上来可以先推出简单的动归方程：

$f_i$ $=$ $min(f_j+i-j-1)$   

其中$0 \leq j \le i$且第$i$个字符和第$j$个字符可以相邻。

这个转移方程的基本意思就是枚举所有可以相邻的字符$i$和$j$，然后删掉中间所有的字符，更新答案的最小值。

这个算法复杂度正常是$O(n^2 \times m)$，加上处理技巧$2$之后是$O(n^2)$的，绝对超时了。

## 想法2
我之后决定对想法一进行优化，但当我看到[君のNOIP。](https://www.luogu.com.cn/user/250469)的题解后，我改变了主意。我决定采用$O(26^2 \times n)$的做法来试一下。

当从前向后依次删字符时，我们发现这个字符该不该删只与上一个字符有关，这时我们设$f_{i,j}$表示字符串中前$i$个字符，且最后一个字符为$j$时最少删字符的个数。

初始值：$f_{i,j}$ $=$ $INF$

显然边界值为:  $f_{0,i}$ $=$ $0$ 其中$0 \leq i \leq 25$

动归转移方程：$f_{i,j}$ $=$ $min(f_{i-1,k})$，其中$0 \leq k \leq 25$

步骤如下：

1. 枚举$i$，然后枚举这一位上可能的字符$j$，$f_{i,j}$考虑最大值也就是$f_{i-1,j}$ $+$ $1$，即直接将这一位上的字符删去。

2. 若原字符串第$i$位$s_i$等于$j$，即这一位字符合法有效，则枚举$s_{i-1}$。

3. 若枚举的$s_i$与$s_{i-1}$可以相邻，那么执行动归转移方程。

4. 答案为$min(f_{n,i})$，其中$0 \leq i \leq 25$（这很显然吧）。

## 想法3
在用想法二过了这道题后，我决定回头去仔细的想一想为什么想法一优化后过不了[这组Hack](https://www.luogu.com.cn/discuss/show/273605)。

首先我先来说一下怎样对想法一进行优化。

$f_i$ $=$ $min(f_j+i-j-1)$

由上式得到：

$f_i$ $=$ $min(f_j-j)$ $+$ $i$ $-$ $1$

我们令$k_i$ $=$ $f_i-i$，于是我们对字符串中每一个`a`到`z`的字符都维护一个$k_i$的最小值。由于这一步可以与动归转移同步进行，所以复杂度就简化到了$O(26 \times n)$。

后来发现是因为未考虑删除头尾的情况。我们在想法一中所提到的转移方程是把区间$[j+1,i-1]$中的字符都删掉，其中$1 \leq i,j \leq n$，所以显然无法对头尾字符进行操作的。

于是解决方法就油然而生了：在头尾各加上一个任意字符，再进行操作。

步骤如下：

1. 枚举$i$，将$f_i$先设为$INF$。

2. 枚举`a`至`z`的所有字符，利用$k_i$进行动归转移。

3. 求当前字符的$k_i$，更新$k_i$。

结果：$min(f_{n,i})$

# 3、代码

代码中有注释欧。

$Code$想法二:
```cpp
#include <iostream>
#include <cstring>
using namespace std;
const int N=1e5+5;
const int INF=0x7f7f7f;
char s[N],p,q;//s[i]为字符串 
int a[N],n;
int f[N][27],ans=INF;//初始化ans为无限大 
bool d[27][27];
int m;
int min(int a,int b)//手写min函数，应该更快一些 
{
	return a<b?a:b;
}
int main()
{
	int i,j,k;
	cin>>n;
	for(i=1;i<=n;i++)
	{
		cin>>s[i];
		a[i]=s[i]-'a';//用处理技巧1转化一下 
	}
	cin>>m;
	for(i=1;i<=m;i++)
	{
		cin>>p>>q;
		d[p-'a'][q-'a']=1;
		d[q-'a'][p-'a']=1;//处理技巧2 
	}
	memset(f,INF,sizeof(f));//初始化f为无限大 
	for(i=0;i<=26;i++)
	{
		f[0][i]=0;//显然边界值为(0,i) 
	}
	for(i=1;i<=n;i++)
	{
		for(j=0;j<=26;j++)//枚举这一位上的字母 
		{
			f[i][j]=min(f[i][j],f[i-1][j]+1);//f[i][j]最大的情况：这一位必须删 
			if(a[i]==j)//如果j是这一位上的字母，才能转移 
			{
				for(k=0;k<=26;k++)//枚举上一位的字母 
				{
					if(!d[j][k]) f[i][j]=min(f[i][j],f[i-1][k]);
					//如果这两个字符能挨在一起，转移 
				}
			}
		}
	}
	for(i=0;i<=26;i++)
	{
		ans=min(ans,f[n][i]);//答案更新 
	}
	cout<<ans;
	return 0;
}
```

$Code$想法三：

```cpp
#include <iostream>
#include <cstring>
using namespace std;

const int N=1e5+5;
const int INF=0x7f7f7f;
int f[N],k[N],d[40][40];//k[i]如原文所述，d开大一点 
int a[N],n,m;
char c1,c2;

int min(int a,int b)
{
	return a<b?a:b;
}

int main()
{
	int i,j;
	cin>>n;
	n+=2;
	a[1]=35,a[n]=35;//在首尾各加一个字符 
	for(i=2;i<n;i++)//在中间读入真的字符串 
	{
		cin>>c1;
		a[i]=c1-'a';
	}
	cin>>m;
	for(i=1;i<=m;i++)
	{
		cin>>c1>>c2;
		d[c1-'a'][c2-'a']=d[c2-'a'][c1-'a']=1;
	}
	for(i=1;i<=n;i++)
	{
		f[i]=INF;//f[i]初始化无限大 
		for(j=0;j<=35;j++)//枚举字符 
		{
			if(!d[a[i]][j])  f[i]=min(f[i],k[j]+i-1);//转移 
		}
		k[a[i]]=min(k[a[i]],f[i]-i); //维护k[i]最小值 
	}
	cout<<f[n];
	return 0;
}
```

创作不易，管理员大大求通过，同时求一下置顶！

**若有错误，欢迎指出！**