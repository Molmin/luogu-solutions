[题目链接](https://www.luogu.com.cn/problem/CF1691B)

## 题意解释：
给定 $n$ 个人的原本的鞋子码数，需要构造一个拿取鞋子的错排（每个人不拿到自己的鞋子），使得每个人目前得到的鞋子码数不小于自己鞋子的码数。
## 思路 & 方法：

以下提供两个我本人打比赛时的思路，两种思路都可以最终推向一个结论，各位可以选择性的参考。

------------

对于一个编号为 $i$ 的人，他原本的鞋子码数为 $a_i$，

那我们就需要找到一个编号为 $j$ 的人使得 $a_j\ge a_i$。

上述条件对于每个人都要成立，这个问题看似不好解决，但我们可以顺着思路往下想。

### 思路一：

显然，我们可以很容易想到一个结论：**拥有最大鞋码的人一定要拿和自己相同鞋码的鞋。** 因为根本就没有比他穿的鞋码还大的鞋了！

我们设最大鞋码为 $d_1$。

那么对于 $k$ 个鞋码为 $d_1$ 的人，他们需要轮换着使用别人的鞋子，此刻鞋码为 $d_1$ 的鞋子就已经被拿完了。

那么我们接着设次大鞋码为 $d_2$。

此时最大鞋码已经被拿光了！次大鞋码就变成了最大鞋码，那么和上面一样的思路，也只能拿与自己鞋码相同的鞋子。

（换种说法，那就是此时已经没有鞋的鞋码比 $d_2$ 大了）

### 思路二：

我们可以这样问自己：

把 $j$ 的鞋子给 $i$ 穿，那 $j$ 穿谁的鞋子？

假设 $j$ 穿 $k$ 的鞋子，下面我们假设一下：

如果 $a_k>a_j$，那么顺着下去，$k$ 又穿谁的鞋子？

很明显，这么下去，那么其中一个拥有最大鞋码的人的鞋子就会被一个鞋码小于他的人穿走，那么就肯定会有一个最大鞋码的人没有合适的鞋子穿了。

我们来举个例子：

 $n$ 个人的鞋码分别为 $a = \{1,1,5,5,5\}$。    
 
对于两位鞋码为 $1$ 的人来说：
 
+ 一种方法是则两位鞋码为 $1$ 的人可以互换鞋子穿。

+ 当然也可以第一个 $1$ 去穿第二个 $1$，然后第二个 $1$ 去穿第一个 $5$。此时的每个人拿到鞋子码数的数组即为 $b = \{1,5,-,-,-\}$。那我们很容易可以知道，因为有一个 $5$ 被一个 $1$ 给穿了，所以肯定有一个 $5$ 没有鞋子可以穿了。所以这样子是无法构造出合法答案的。所以只能是 $a_i=a_j=a_k$。

------------

通过以上两个思路，我们可以推出一个简单的结论，即：**每个人只会拿与他相同鞋码的人的鞋**。

那么到这里代码就很好写了，我们只需要各自求出每个鞋码出现的人有哪些，然后将他们轮换错排即可。

那么显然，当某个鞋码的人只有一人，那么他无法和别人换鞋，那么就无解。

补充：我的轮换方法是在鞋码相同的人中，第 $j$ 个人去穿第 $j+1$ 个人的鞋，最后一个人去穿第 $1$ 个人的鞋。

## Code：
```cpp
#include <bits/stdc++.h>

#define LL long long

using namespace std;

inline int Read() {
    int x = 0, f = 1;
    char c = getchar();
    while (c < '0' || c > '9') {
        if (c == '-') f = -1;
        c = getchar();
    }
    while (c >= '0' && c <= '9') {
        x = (x << 1) + (x << 3) + (c ^ '0');
        c = getchar();
    }
    return x * f;
}

const int N = 1e5 + 10;

vector<pair<int, int> > v;

pair<int, int> p;

int t, n, tot, i, j;

int a[N];

int main() {
    t = Read();
    while (t--) {
        v.clear();
        memset(a, 0, sizeof a);
        n = Read();
        for (i = 1; i <= n; i++) a[i] = Read();
        sort(a + 1, a + 1 + n);
        for (i = tot = 1; i <= n; i++) {
            if (a[i] != a[i + 1]) {
                if (tot == 1) break;
                v.push_back(make_pair(i - tot + 1, i));
                tot = 1;
            }
            else tot++;
        }
        if (i <= n) printf("-1\n");
        else {
            for (i = 0; i < v.size(); i++) {
                for (j = v[i].first; j < v[i].second; j++)
                    printf("%d ", j + 1);
                printf("%d ", v[i].first);
            }
            printf("\n");
        }
    }
    return 0;
}
```