## 题意:

你有一个如下图构造的三角矩阵.

![1.jpeg](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1506F/2590a689fe7bd1eeca079bb14e0735bc33acbbf0.png)

它有无限层, 其中, 有些边是可以 **免费** 走的, 有些边要走需要有 $1$ 花费. (这些边都是有向的)

有 $T$ 组数据, 每组数据中有 $n$ 个点, 对于每组数据你需要输出, 不论顺序, 从 $(1, 1)$ 开始, 访问所有点的最小花费.

## solution

显然, 是有向图, 所以我们必须按照 $r_i$ 从小到大的顺序访问完所有的点.

我们考虑连续两点之间的路径的价值怎么算.

题目给的图点太少了, 看不出点啥东西, 这里手绘了一个. (很丑勿喷)

![1.png](https://i.loli.net/2021/03/28/TE9VKmAz5UvdeID.png)

这里的每个点所对应的 $(r_i, c_i)$ 都标在了点的右边. 那些被用黄笔涂过的边, 是题中 **免费** 走的边. 

我们可以注意到, 如果两点 $(r_1, c_1), (r_2, c_2)$ 的 $r - c$ 相同, 那么他们必然是处于同一条从左上到右下的链上. 而这些边中, 因为我们是无法从左下到右上的, 所以这样的两点之间路径是唯一的.

显然可得, 若 $(r - c) \% 2 == 0$ , 从 $(r_1, c_1)$ 到 $(r_2, c_2)$ 的花费为 $r_2 - r_1$ . 否则, 花费为 $0$

我们考虑如果两个点 $r-c$ 不相同该怎么做.

我们肯定是可以从 $(r_1, c_1)$ 走一段向右下的边再走一段向左下的边到达 $(r_2, c_2)$ 的. ~~(证明很简单, 留作习题)~~

那么我们必然可以找到一段从左上到右下的路径, 它是免费的, 而且我们可以途径它从 $(r_1, c_1)$ 走到 $(r_2, c_2)$

比如, 从 $(1, 1)$ 到 $(5,3)$ 可以 从 $(1, 1)$ 到 $(3,3)$ 到 $(5,3)$ 也可以从 $(1, 1)$ 到 $(2, 1)$ 到 $(4, 3)$ 到 $(5,3)$

所以我们结果就应该是走的从右上到左下, 不是免费的边的边数.

从 $(r, c)$ 向右走, 会到 $(r + 1, c + 1)$ 向左走会到 $(r + 1, c)$ 我们要求的是向左走的边数, 可以看出,  $\Delta c = c_2 - c_1$ 比 $\Delta r = r_2 - r_1$ 少的一部分就是向左走的边数.

因为 $r_1 + c_1$ 的奇偶性不同, 所以从 $(r_1, c_1)$ 出来的第一条向左走的边也会不同

- 若 $r_1 + c_1$ 为偶数, 第一条边是免费边, 而免费边和非免费边依次出现, 所以, 此时免费边个数 $\ge$ 非免费边个数
- 若 $r_1 + c_1$ 为奇数, 第一条边是非免费边, 所以此时 非免费边个数 $\ge$ 免费边个数

## Code : 

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;

const int N = 2e5 + 5;
int n;
struct poi {
    int r, c;
} e[N];
bool cmp(poi a, poi b) {
    return a.r < b.r;
}
LL ans;

int main() {
    int t; scanf ("%d", &t);
    while (t--) {
        scanf ("%d", &n);
        int pos = -1;
        for (int i = 1; i <= n; ++i) {
            scanf ("%d", &e[i].r);
            if (e[i].r == 1) pos = i;
        }
        for (int i = 1; i <= n; ++i) {
            scanf ("%d", &e[i].c);
            if (e[i].c == 1 && pos == i) pos = 0;
        }
        if (pos != 0) {
            n++;
            e[n].r = e[n].c = 1;
        }
        sort(e + 1, e + n + 1, cmp);
        ans = 0;
        for (int i = 2; i <= n; ++i) {
            if (e[i].r - e[i].c == e[i - 1].r - e[i - 1].c) {
                if ((e[i].c + e[i].r) % 2 == 0) {
                    ans += e[i].r - e[i - 1].r;
                }
            } else {
                int r = e[i].r - e[i - 1].r + 1, c = e[i].c - e[i - 1].c + 1;
                if ((e[i - 1].r + e[i - 1].c) % 2 == 0) {
                    ans += (r - c) / 2;
                } else ans += (r - c + 1) / 2;
            }
        }
        printf ("%lld\n", ans);
    }
    return 0;
}
```

