先看看我提交的翻译OwO

**题目描述**

给一个长度为 $n$（$1\le n \le50$）仅由 a 和 b 组成的字符串（字符的编号由 $1$ 到 $n$），找到任意一对 $l$ 和 $r$（$1\le l<r \le n$），使得 $l$ 到 $r$ 的连续子串中 a 和 b的数量相同。

**输入格式**

第一行为一个正整数 $t$（$1\le t\le1000$），表示有 $t$ 组数据。

接下来 $2\times t$ 行，输入每组数据。

每组数据一共两行。第一行为一个正整数 $n$，表示字符串长度；第二行为一个长度为 $n$ 仅由 a 和 b 组成的字符串。

**输出格式**

对于每组数据，输出一行两个数 $l$ 和 $r$。若找不到满足条件的 $l$ 和 $r$，输出两个 $-1$。（两个数之间用空格隔开，两组数据之间需换行）

Translated by @银杉水杉秃杉

2021.9.13

这道题未免也太水了一点吧，任意一段子串满足 a 和 b 数量相同，那不就找个子串为 'ab' 或 'ba' 就可以了吗

但是为了尊重这道CF的题，我写了一个通用性较高的代码，暴力直接找。

哦对了，要注意找不到要输出两个 $-1$ 哦

```
#include <bits/stdc++.h>
using namespace std;
int T, n;
char s[60];
int main()
{
    scanf("%d", &T);
    while (T--)
    {
        scanf("%d", &n);
        scanf("%s", s + 1);
        int l = -1, r = -1;//小技巧：直接初始化为-1
        for (int i = 1; i <= n; i++)
            for (int j = i + 1; j <= n; j++)
            {
                int a = 0, b = 0;
                for (int k = i; k <= j; k++)//统计a、b个数
                    if (s[k] == 'a')
                        a++;
                    else
                        b++;
                if (a == b)
                    l = i, r = j;//这里可以不急着退出循环，因为我们随便找一对l和r即可
            }
        printf("%d %d\n", l, r);
    }
    return 0;
}
```
