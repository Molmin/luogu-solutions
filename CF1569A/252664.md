模~拟~题~

[CF 1569A  题目](https://www.luogu.com.cn/problem/CF1569A)

首先来看一下题目，要找一个子串，使得子串中两个字母的数量相等。

我们发现，本来是暴力，但是要求的是连续区间内某个东西的总和，所以可以敏感地意识到前缀和优化。（不过数据也是很良心啊，$n≤50$）

T循环内的代码（即外面还要套一个多组数据的循环）在这里：

```cpp
bool f=1;
scanf("%d",&n);
cin>>s;
int cnt[50]={};
for(int i=1;i<=n;i++)
	if(s[i-1]=='a') cnt[i]=cnt[i-1]+1;
	else cnt[i]=cnt[i-1];
for(int i=1;i<=n;i++)
{
	for(int j=i+1;j<=n;j+=2)
		if(cnt[j]-cnt[i-1]==(j-i+1)/2)
		{
			f=0;
			printf("%d %d\n",i,j);
			break;
		}
	if(!f) break;
}
if(f) printf("-1 -1\n");
```
很短是不是？下面详细说明。

首先，$cnt[]$ 数组的作用就是前缀和思想，$cnt[i]$ 表示的就是到 $i$ 为止，即 $1-i$ 的区间内字符 `‘a’` 的数量。

然后会发现，内层 $j$ 循环是每次加 2 的。为什么呢？因为长度必须得是偶数，才有可能两字母数量相等。

判断语句中的 $cnt[j]-cnt[i-1]$ 其实就是计算出了 $i-j$ 区间内字符 `‘a’` 的数量，如果等于总个数的一半，则题设成立直接输出。

讲的还是比较慢的 ~~，求通过~~。
