居然没有人来发一波暴力？那就让菜鸡FCBM71来补上好了。

### 暴力思路

我们可以把三个子序列各看作被包含在一个区间中。我们需要做的就是寻找两个分界点，作为挡板，把整个数列一分为三，然后再在三个子区间中寻找符合条件的子序列。我们假设分出来的区间分别是 $[1,l]$，$(l,r]$，$(r,n]$，将它们命名为 $ls,ms,rs$。

对于区间 $ms$ 很好处理，因为题目中没有要求 $b$ 与 $a$ 有任何关系，所以在区间 $ms$ 中就只需要寻找一个整数 $b$ 使得 $b$ 在 $ms$ 中出现的次数最多。

那么区间 $ls,rs$ 呢？由于题目中有明确的要求，要求左子序列和右子序列元素个数相等，所以我们需要寻找一个整数 $a$ 使得 $\min(\text{a 在左区间中出现的次数，a在右区间中出现的次数})$ 有最大值。

### 代码流程

说到这里整个流程就呼之欲出了。

使用一重循环枚举 $l$，使用第二重循环枚举 $r$，第三重循环同时枚举 $a,b$。至于统计区间中 $a,b$ 的出现次数，可以使用前缀和快速解决。

核心代码。其中 `cnt[i][x]` 表示数 $i$ 在 $[1,x]$ 中出现的次数
```
inline void tomax(const int &a,const int &b){if(a<b)a=b;}

for(int l=1;l<=n;++l)
 for(int r=l;r<=n;++r){
 	int maxlr, maxmid=0;
 	for(int i=1;i<=26;++i){
 		tomax(maxlr, min(sum[i][l-1],sum[i][n]-sum[i][r]));
 		tomax(maxmid, min(sum[i][r]-sum[i][l-1]));
	}
	tomax(ans, maxlr*2+maxmid); //不要忘记*2
 }
```