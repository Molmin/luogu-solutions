极简代码

当时没看提示，用的栈模型，超时得厉害（哦多么痛的领悟）

假设我们用1来表示手拿50元的钞票的人，0代表拿100元的人，求解的问题转化为从左到右1的累计个数总是不小于0的累计方案，求满足这个条件的数

所以说总方案数为$C_{2n}^{n}$。

根据我们的假设，又假设我们现在制造出来的数是不符合要求的，某一奇数位（双假设这个位置为$2m+1$）首先出现了m+1个0和m个1，而后的$2(n-m)-1$位上有$n-m-1$个0和$n-m$个1，叒假设把后面这一部分$2(n-m)-1$位中的1余0互换，结果就会得到一个由$n+1$个0与$n-1$个1组成的$2n$位数。

反之，由$n+1$个0与$n-1$个1组成的$2n$位数绝对存在一个不符合要求的数（可以试着自己证一下，~~很简单~~）

综上所述，不符合要求的数的总数为$C_{2n}^{n+1}$，所以原问题的解为$C_{2n}^{n}$-$C_{2n}^{n+1}$=$\frac{C_{2n}^{n}}{n+1}$

因为~~太懒~~手太累不打代码注释了哦
```cpp
#include<cstdio>
int main(){
	int n;
	scanf("%d",&n);
	long long tot=1;
	for(int i=0;i<n;++i)	tot=tot*(2*n-i)/(i+1); 
	printf("%lld",tot/(n+1));
	return 0;
}
```