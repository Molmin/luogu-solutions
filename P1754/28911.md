开始天真地以为可以直接用高中的排列组合公式算（想想发现忘光了T\_T），后来算了下才发觉不对劲。后面换了种想法。


Q1:假设抽屉里面没有钱，那么只能将一个50的排第一位。


Q2:假设抽屉有50元钱，那么这次可以随意排50或者100的在第一位。


问题可以抽象成，假设抽屉有money 的钱，有n1个人拿着50元，n2个人拿着100元待排队，求排队的方式数。开始是 money == 0, n1 == n2 == n。


很好的一个递归模型了，自顶向下，采用备忘录方法优化。


函数定义:



 

int GetCount(int n1, int n2, int  money);

对于Q1：



count = GetCount(n1 - 1, n2, money + 50) ;

即抽屉没钱，只能先排一个50的在前面


 

对于Q2:


count = GetCount(n1 - 1, n2, money + 50) + GetCount(n1, n2-1, money-50);


即抽屉有钱的话，排序总数量是两种子问题的总和。


 

 

然后讨论问题的递归出口。


由上面分析可以看出，最终出口肯定是 n1 不断减少，直到0， money不断增加，增加到跟n2相等的情况。这种时候相当于，抽屉有 x 张50元，刚好有 x 个人拿着100元过来买票。那么很好理解，只有一种排队方法。
