## 分析题目

首先看题目。球票价格是$50$元，而有$n$个人手中有$50$元，另外$n$个人手上有$100$元~~(其实让他们两两配对一起买就好了)~~，要求不会没钱找零的排列方案数。

既然售票点开始没有零钱~~(那你还出来卖票？？)~~，那么后来找给$100$元的$50$元只能从之前买票的人手里来，
所以当一个手中握着$100$元的球迷买票时，只要之前收到的$50$元没有找完，也就是是说$50$的个数要比$100$多(因为他也要用，所以是大于)。

如果我们用$A$表示拿着$50$的人，用$B$表示拿着$100$的人，那么问题就变成了：

有$N$个$A$，$N$个$B$，求符合条件的排列的个数。在符合条件的排列中，对于所有的$B$，他前面的$A$的个数要大于等于他以及他前面所有$B$的个数。

到这里，我就想到了之前看过的一道题(我忘记是哪本书上的了QWQ)。那道题与转换后的问题一模一样，然后他给出了一种特别。。。特别。。。特别(sao?)的做法：

如果我们用$\nearrow$表示$A$，用$\searrow$表示$B$，那么我们可以得到这样的图

($n=3$)

(用TIM截屏得到的箭头再一个个贴到GGB上的QWQ，我太蒟了求勿喷)

![](https://cdn.luogu.com.cn/upload/pic/39768.png)

如果我们顺着箭头走的话，那么沿着$\nearrow$走到$(x,y)$（坐标）就相当于在排列的第$x$位选了$A$，不然就是选了$B$（沿着$\searrow$过来）。根据图示，我们可以看到这样子是肯定符合的，而且如果在左半部分的外面再加$\searrow$肯定不符合(因为$B$会比$A$多)。

综上所述，从$(0,0)$走到$(2n,0)$的方法数即为所求。

---

## 代码实现

我们用$f[i][j]$表示按照规则从$(0,0)$走到$(i,j)$的方法数，那么就可以得到状态转移方程
(其实和[P1002 过河卒](https://www.luogu.org/problemnew/show/P1002)
的递推差不多)：

$f[i][j] = f[i-1][j-1]+f[i][j+1] (i \in [1,2n], j \geq 1)$

和

$f[i][j] = f[i-1][j+1] (j = 0)$

显然这一层只与上一层有关，所以就可以优化空间，详细见代码。

```cpp

#include <iostream>
#include <cstdio>
using namespace std;
const int N = 105, INF = 1e9;

int n;
ll f[2][N];

int main() {
	scanf("%d", &n);
	f[0][0] = 1;
	for (reg int i = 1; i <= n<<1; ++i) {//n<<1就是右移一位，即n*2
		f[i&1][0] = f[(i-1)&1][1];
		for (reg int j = 1; j <= n ++j) {
			f[i&1][j] = f[(i-1)&1][j+1] + f[(i-1)&1][j-1];  //x&1其实就是x%2，&是位运算，意思是按位与。
            //其实由于位运算优先级较低，i-1前后不加括号也是可以的，但是平时用的时候一定要注意括号，不然因为优先级问题可能会出现很难调试的错误
		}
	}
	printf("%lld\n", f[0][0]); //因为2n肯定是偶数，对二取余肯定是0
	return 0;
}

```

然后就解决这道题啦