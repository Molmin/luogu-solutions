既然楼下的大佬已经提到了`复制`数组的这种做法，我就来好好的剖析一下（滑稽）

首先，如何判断`-1`？我们把所有数字塞到一个`set`里面，看看`set`的`size`是否小于$k$，也就是说看看不同的数的个数是否小于$k$，如果不，那就`puts("-1");`即珂。

剩下的思路就是我们把那些不同的数字（就是塞到`set`里面的数字）复制$n$遍，然后要是这些数字不足$k$个怎么办？~~凉拌~~我们就随便输出一些数字，比如说~~114514,1919810~~ 1,2,2147483647之类的（但是要在$1$~$n$之内！）。不明白？那就自己举个栗子呗！

$for\ example:$
$k=3,n=5,a={1,3,4,5,4}$

此时就`puts("-1")`

$for\ example:$
$k=5,n=5,a={1,3,4,5,4}$

此时就输出：
`1 3 4 5 5 1 3 4 5 5 1 3 4 5 5 1 3 4 5 5 1 3 4 5 5`
(我倒是很好奇它怎么spj的……)

那么这题就愉快的解完啦！
```
#include <bits/stdc++.h>
using namespace std;
int n,k,T;
set<int> S;
int main(){
	scanf("%d",&T);
	while(T--){
		scanf("%d%d",&n,&k);
		for(int i=1;i<=n;i++) {
			int q;
			scanf("%d",&q);
			S.insert(q);//全部塞到set里
		}
		//多出k个不同的数就是-1！
		if(S.size()>k) puts("-1");
		else {
			printf("%d\n",n*k);
			for(int i=1;i<=n;i++) {//复制n遍
				for(auto it=S.begin();it!=S.end();++it) printf("%d ",*it);
				for(int j=1;j<=k-S.size();j++) printf("1 ");//不足k个就随便输出其他的数字
			}
			puts("");
		}
		S.clear();//千万要清空！
	}
	return 0;
}
```
有的小伙伴珂能会问了：为啥要复制$n$遍呢？

1. 首先题目的数据说不能超过10000，而$n*k$的最大值是$10000$所以复制$n$遍 ~~（瞎扯）~~
2. 因为我们考虑数组$4\ 4\ 4$如果说我们不复制$n$遍`set`的话，那么原来的三个$4$就不足了，那么也不符合题意的“插入”了，所以只能正正好好复制$n$遍（也不能多，不然长度会超过$10000$滴！）