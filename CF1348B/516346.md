### 题目翻译

有一个长度为 $n$ 的数组，里面有 $n$ 个元素，$a_1,a_2,a_3,...a_n$。

给定一个 $k$，可以通过在 $a$ 数组中插入 $[1,n]$ 之间的数字，使**任意** $k$ 个连续的元素之和相等。

如无解，输出 $-1$。

### 题目思路

我们可以考虑，把这个数组分成很多段，也就变成 $b_1,b_2,b_3,...,b_k,b_1,b_2,b_3,...,b_k,b_1,b_2,b_3......$ 这样的数组。

可以很明显的发现，任意 $k$ 个肯定是 $b_1,b_2,b_3,...,b_k$ 出现一次。

那么也就满足了和相等。

当然，如果我们输入的 $a$，**去重**后元素数量大于 $k$，肯定无法构造。

那么我们需要输出几次 $b_1,...b_k$ 呢？

答案很简单，$n$ 次。

我们用一个例子解释一下。

```
5 5
5 3 2 4 1
```

```
注：原数组元素会在下方标注，‘|’分割每组
1 2 3 4 5|1 2 3 4 5|1 2 3 4 5|1 2 3 4 5|1 2 3 4 5
        ^     ^       ^             ^   ^
```

当然，我们要进行去重。

```
5 5
5 5 5 5 5
```

```
5|5|5|5|5
^ 
```

但是，不要忘了刚才说的：
>如果我们输入的 $a$，**去重**后元素数量大于 $k$，肯定无法构造。

所以，像下组数据：

```
5 3
5 3 2 4 1
```

就得输出 $-1$。

### AC 代码

```cpp
void solve()
{
    set<int>s;
    int n, k;
    cin >> n >> k;
    for (int i = 1; i <= n; i++)
    {
        int x;
        cin >> x;
        s.insert (x);
    }
    if (s.size() > k)
    {
        puts ("-1");
        return;
    }
    cout << n * k << endl;
    for (int i = 1; i <= n; i++)
    {
        for (int it : s)
        {
            cout << it << " ";
        }
        for (int j = 1; j <= k - s.size(); j++)
        {
            cout << n << " ";
        }
    }
    cout << endl;
}
```



