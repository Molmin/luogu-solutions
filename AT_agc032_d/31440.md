## AGC032D

这个做法应该比较简洁吧。

首先每一个数至多跑一次（从左往右或者从右往左或者不跑）因为如果让它跑两次相当于第一次就跑到第二次结束那地方就行，位置是可以任意选择的。  

我们先假定左移和右移**费用相同**，然后把数分成两类，**被移动**了和**未被移动**。显然，未被移动的数必须构成一个**上升子序列**，那些移动的数分为三种情况，我们对每一个移动的数分别考虑，假设这个移动的数为第 $i$ 个数 $a_i$。  

先任意找一个可行方案（已经把所有数分为被移动和未被移动）出来。

- 1.未被移动的数中存在 $j$，$j<i$ 且 $a_j>a_i$  
这个数应该往左移  
- 2.未被移动的数中存在 $j$，$j>i$ 且 $a_j<a_i$  
这个数应该往右移  
注意：由于子序列是上升的，**上面两种情况不可能同时出现**。  
- 3.上两种情况均不出现
这种情况在最优解种不可能出现，因为可以把这个数归到子序列里去，把它变成未被移动的数。

答案就是被移动的数的数量最小值乘以费用，前者等于总数减去最长上升子序列长度。

然后看左右移不同的情况，可以 dp 了，状态 $dp_i$ 代表将第 $i$ 个数选为**未被移动的数**，且前 $i$ 个数能够构成上升子序列（也就是这些数都已经被决定是哪一类了）时，最小需要的总花费。

决策变量 $j$ 枚举上一个处在上升子序列中的数是哪个，然后统计 $j$ 和 $i$ 中该左移和该右移的数分别有多少个。  

对于这个统计，只要倒序枚举 $j$，两个变量就完事，左移的数看起来不好统计，其实只要把上文所述的第一种、第三种情况都当成左移的数就可以了，也就是 $a_k<a_i$ 即左移 $k$。

然后代码出奇的短。

```cpp
using namespace std;
typedef long long LL;
const LL INF = 0x3f3f3f3f3f3f3f3f;

LL n,l,r;
LL a[5005],dp[5005];

int main(){
	memset(dp,0x3f,sizeof(dp));
	cin >> n >> r >> l;
	for(LL i = 1;i <= n;i ++){ cin >> a[i]; a[i] ++; }
	a[0] = 1; dp[0] = 0; a[n + 1] = n + 2;
    // 这里为了方便做把排列种每个数都加上 1 了
	for(LL i = 1;i <= n + 1;i ++){
		LL sr = 0,sl = 0;
		for(LL j = i - 1;j >= 0;j --){
			if(a[j] < a[i]) dp[i] = min(dp[i],dp[j] + r * sr + l * sl);
			if(a[j] > a[i]) sr ++; if(a[j] < a[i]) sl ++;
		}
	}
	cout << dp[n + 1] << endl;
	return 0;
}
```