其实。。。此题的数据范围如此之水，以至于成了洛谷不多的打表神题中的一员。。不仅可以打表，打表用的数据还可以自己手算。。。

以下是打表代码：

```
#include<bits/stdc++.h>

using namespace std;

int main()
{
	int a;
	scanf("%d", &a);
	if(a==1)
	{
		printf("1");
	}
	else if(a==2)
	{
		printf("2");
	}
	else if(a==3)
	{
		printf("6");
	}
	else if(a==4)
	{
		printf("20");
	}
	else if(a==5)
	{
		printf("70");
	}
	else if(a==6)
	{
		printf("252");
	}
	else if(a==7)
	{
		printf("924");
	}
	else if(a==8)
	{
		printf("3432");
	}
	else if(a==9)
	{
		printf("12870");
	}
	else if(a==10)
	{
		printf("48620");
	}
	return 0;
}
```
但是，这道题还有另一个解法。
经过细腻的观察，可以发现，矩阵右上方的数字永远是最大的那个，并且如果矩阵大小为n*n，那么最大的那个数就是（2n）×(2n-1)×(2n-2)×...×(n+1)÷n÷(n-1)÷(n-2)÷...÷2÷1.

这个解法可以实现时间复杂度为O（n）的算法（上面的那个是O（1）——只要如果数据范围扩大到100你能算完这些数就行了。。。当然，如果数据范围扩大到100，这个解法好像需要高精度。）

由于这样的思路实现起来如此简单，同时为了防止抄袭，就不贴代码了。