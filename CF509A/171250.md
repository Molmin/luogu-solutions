本题是一道不折不扣的裸题。看到这道题目，大家一定会想起另一道如出一辙的题：在一个M*N的迷宫内，只允许向右走或向上走，求出从左下角走到右上角共有几种方案。

这道题的正解思路显然是动规：由于只允许向右走或向上走，所以走到点(i,j)的方案数f[i][j]=f[i][j-1]+f[i-1][j]，从而得出走到点(n,n)的方案数。

```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{int n,a[11][11];//本题数据范围较小，不必开太大
 cin>>n;//读入N的值
 for(int i=1;i<=n;i++) a[1][i]=1,a[i][1]=1;//初始化
 for(int i=2;i<=n;i++)
   for(int j=2;j<=n;j++) a[i][j]=a[i-1][j]+a[i][j-1];
   //通过状态转移方程求方案数
 cout<<a[n][n];//输出点(n,n)的方案数
 return 0;
}

```

同时我还想到了另一种方法，从点(1,1)走到(n,n),需要向上走(n-1)步，向右走(n-1)步，总共(2n-2)步。而哪几步向上走，哪几步向右走是不确定的，在(2n-2)步中选取(n-1)步向右走，其他几步向上走，故总方案数为：
###  n……(2n-2)/(n-1)……*1

```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{long long int n,k=1,t=1;//由于要算阶乘所以开大点，k为(n-1)……*1的值，t为n……(2n-2)的值
 cin>>n;//读入N的值
 for(int i=1;i<=n-1;i++)k*=i,t*=2*n-i-1;//本题数据范围较小，无需计算最小公约数约分
 cout<<t/k;//输出总方案数n……(2n-2)/(n-1)……*1
 return 0;
}
```