[题目传送门](https://www.luogu.com.cn/problem/P5560)

由于本人水平有限，数学不太好，因此证明可能有所缺漏，请见谅。

------------
题目大意：有 $n$ 个点，对于第 $i$ 个点，其权值为 $(i+1)^2-1$，两点之间的边的权值为两点权值的最大公约数，求这 $n$ 个点的最小生成树。

看一看样例，$n\le 10^{18}$，还有一个 $O(T)$ 的复杂度，那么就是要在 $O(1)$ 或者 $O(logn)$ 的时间内算出每个询问，于是：

找规律！！！

题目中说 $f_i=(i+1)^2-1$，化简一下：$f_i=i\times(i+2)$

同理，$f_{i-1}=(i+1)(i-1)$。

而我们发现，$i-1$ 与 $i$ 互质，$i$ 与 $i+1$ 互质，$i+1$ 与 $i+2$ 互质，那么，如果 $f_i$ 不与 $f_{i-1}$ 互质，只可能是 $i+2$ 不与 $i-1$ 互质。

如果 $i+2$ 不与 $i-1$ 互质，他们的公因子只可能是 3，而且 $i$ 除以 3 的余数一定是 1。

所以，我们可以就 $i$ 除以 3 的余数来对 $i$ 分类。

情况 1：$i\equiv0\pmod3$：此时只需要将 $i$ 与 $i-1$ 连边，这样边权为 1，总边权为 $i-1$。

情况 2：$i\equiv2\pmod3$：同情况 1。

情况 3：$i\equiv1\pmod3$：此时又分为 2 种情况：

情况 3.1：$i\equiv1\pmod6$：此时因为 $i$ 是奇数，与 2 连边即可，此时总边权还是 $i-1$。

情况 3.2：$i\equiv4\pmod6$：这个嘛……通过一些~~非正常~~做法我们发现，还要分两种情况：

情况 3.2.1：$i=4$ 或者 $i=10$：此时，所有比 $i$ 小的数的 $f$ 值都不与 $i$ 互质，那么这条边的权值就要取到 3 ，而前 $i-2$ 条边的权值都是 1，所以总共的权值和就是 $i+1$。

情况 3.2.2：其他：那么，这些值可以找到前面与他互质的数，边权为 1，总边权同样也是 $i-1$。

最终，通过分情况的讨论我们发现，除了 $i=4$ 与 $i=10$ 的答案是 $i+1$，其他的 $i$ 答案都是 $i-1$。

~~个人觉得证明得还算严谨~~

最后附上未极限压行后的11 行，长度 172 的 AC 代码：

```cpp
#include<iostream>
using namespace std;
main(){
	long long t,n;
	cin>>t;
	while(t--){
		cin>>n;
		if(n==4||n==10)cout<<n+1<<endl;
		else cout<<n-1<<endl;
	}
}
```
不过忠告一句，正常做题时一定不要省略 main 前面的 int 和 return 0 哦

看完如果觉得对你有帮助就点个赞呗qwq