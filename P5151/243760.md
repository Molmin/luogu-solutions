- 题意：
给定一个置换群 $P$\
初始序列为 $a_i=i$\
询问：初始序列进行 $k$ 次置换后，每个位置的元素为几
- 置换是什么？\
$P[i]$ 就是表示目前位置为 $i$ 的元素在下一次置换后的位置为 $P[i]$
- 不是一个暴力 $dfs$ 就可以解决了嘛！\
首先我们知道，对于一个置换群，其内部有许多循环着的位置。比如：\
置换群 $P=[1,2,3,5,4]$，元素 $A=[1,2,3,4,5]$ 的置换操作如下：\
$[1,2,3,4,5]$\
$[3,1,2,5,4]$\
$[2,3,1,4,5]$\
$[1,2,3,5,4]$\
$\cdots$\
尽管对置换群有许多有用的结论，我们只要记住：**总的置换由许多循环的小置换形成**。\
于是，我们可以找到每一个**循环置换的循环节$cnt$**，因为你移动 $k$ 步，所以相当于移动了 $cnt\%k$步。\
这样，我们就找到了**该循环置换的第一个元素的最终置换位置 $tmp$**。\
那么该循环置换的下一个元素的最终位置，不就是 $tmp$ 位置的**下一个置换位置嘛！**
- 综上，我们可以$O(n)$ 找到每一个位置 $i$ 的置换最终位置 $ans[i]$\
(｀・ω・´)

```c
/*
 _            __   __          _          _
| |           \ \ / /         | |        (_)
| |__  _   _   \ V /__ _ _ __ | |     ___ _
| '_ \| | | |   \ // _` | '_ \| |    / _ \ |
| |_) | |_| |   | | (_| | | | | |___|  __/ |
|_.__/ \__, |   \_/\__,_|_| |_\_____/\___|_|
        __/ |
       |___/
*/
int nxt[MAX];
bool vis[MAX];
int ans[MAX];
void solve(int x,ll k){
    int cnt = 0;
    while(!vis[x]){		/// 找循环节长度
        vis[x] = 1;
        x = nxt[x];
        cnt++;
    }
    k = k % cnt;

    int tmp = x;
    for(int i = 1;i <= k;++i)	/// 找到位置 x 的初始元素经过 k 次置换后的最终位置 tmp
        tmp = nxt[tmp];

    while(!ans[tmp]){
        ans[tmp] = x;		/// 位置 tmp 的元素为 x
        x = nxt[x];			/// 元素下一置换
        tmp = nxt[tmp];		/// 位置下一置换
    }
    return ;
}
int mian()
{
    int n;ll k;
    scanf("%d%lld",&n,&k);
    for(int i = 1;i <= n;++i)scanf("%d",&nxt[i]);
    for(int i = 1;i <= n;++i){
        if(!ans[i])solve(i,k);
        printf("%d ",ans[i]);
    }
    return 0;
}
```
