upd: 给出的是一个排列，没有基环树，wssb

但是这题倍增也是可行的（

而且如果是基环树的话感觉倍增更好写（

---

如果将这个排列（置换）看作一张有向图，显然会出现环，环的部分可以将 $ k $ 模上环的长度来做，然后就分成了若干基环树…… 草 太麻烦了（

为什么不直接倍增呢？

**设 $ st_{i, j} $ 为 $ i $ 走了 $ 2^j - 1 $ 步后到达的位置**，即，**该点走过的路径上含起点和终点一共有 $ 2^j $ 个点**

边界条件：$ st_{i, 0} = i $（走了 $ 0 $ 步）

转移：

## $ st_{i, j} = st_{a_{st_{i, j - 1}}, j - 1} $

或者写得清楚一点—— `st[i][j] = st[ a[ st[i][j - 1] ] ][j - 1]`

~~也不怎么清楚~~

解释：如果要让 $ i $ 走 $ 2^j - 1 $ 步，可以先让她走 $ 2^{j - 1} - 1 $ 步（最内层 `st[i][j - 1]`），再走一步（中层的 `a[...]`），最后再走 $ 2^{j - 1} - 1 $ 步（最外层 `st[...][j - 1]`）

这样总步数 $ = 2^{j - 1} - 1 + 1 + 2^{j - 1} - 1 = 2^j - 1 $ 满足定义

那么如何求出从某点 $ u $ 走 $ k $ 步后的终点呢？

众所周知，一个数必定有一个二进制表达方式；如果 $ k $ 的二进制第 $ i $ 位（最右是第 $ 0 $ 位开始）是 `1`，则应该走 $ 2^i $ 步，也就是 $ u = a_{st_{u, i}} $

即 `u = a[ st[u][i] ]`

（因为 `st[u][i]` 是走了 $ 2^i - 1 $ 步，再补一步才能到 $ 2^i $ 步)

这样利用二进制拆分就可以实现快速跳转 $ k $ 步了

具体实现中，可以从大到小枚举 $ i $，如果当前的 $ k \geqslant 2^i $，则跳转 $ 2^i $ 步并将 $ k $ 减去 $ 2^i $；否则不操作。这样也可以实现二进制拆分 $ k $ 并跳转的功能。

**题目中求的是每个位置最后是几号点，所以输出的时候要反一下，具体可以参考代码。**

```cpp
#include <bits/stdc++.h>
using namespace std;
int a[100001], st[100001][32];
int ans[100001];
int main()
{
	int n, k;
	scanf("%d %d", &n, &k);
	for(int i = 1; i <= n; i++)
	{
		scanf("%d", &a[i]);
		st[i][0] = i;
	}
	for(int j = 1; j <= 30; j++)
		for(int i = 1; i <= n; i++)
			st[i][j] = st[a[st[i][j - 1]]][j - 1];
	for(int i = 1; i <= n; i++)
	{
		int u = i, kk = k;
		for(int j = 30; j >= 0; j--)
			if(kk >= (1 << j))
			{
				u = a[st[u][j]];
				kk -= (1 << j);
			}
		ans[u] = i;
	}
	for(int i = 1; i <= n; i++)
		printf("%d ", ans[i]);
	putchar('\n');
	return 0;
}
```