## 思路

神仙思维题。

首先可以发现操作 2 和 3 都是无意义的。因为操作 2 可以转化成两次操作 1（翻转左下角为 $(n,1)$，右上角为 $(x,y)$ 的矩阵可以转化为翻转 $(1,1),(n,y)$ 再翻转 $(1,1),(x-1,y)$），操作 3 同理。

然后就是最重要的一步。令 $a_{i,j} = [s_{i,j} = \texttt{B}]$，$b_{i,j} = a_{i,j} \oplus a_{i+1,j} \oplus a_{i,j+1} \oplus a_{i+1,j+1}$。那么要让 $a$ 全变为 $0$，就是让 $b$ 全变为 $0$。操作 1（翻转左上角为 $(1,1)$，右下角为 $(x,y)$ 的矩阵）就转化成翻转 $b_{x,y}$，操作 4（翻转左上角为 $(x,y)$，右下角为 $(n,m)$ 的矩阵）就转化成翻转 $b_{x-1,y-1}$，$b_{x-1,m}$，$b_{n,y-1}$ 和 $b_{n,m}$。这一步可以自己手动模拟一下就明白了。

显然我们只会贪心地当 $b_{x,y}$ 为 $1$ 时才执行操作 1，$b_{x-1,y-1}$，$b_{x-1,m}$，$b_{n,y-1}$ 和 $b_{n,m}$都为 $1$ 时才执行操作 2。

然后又发现执行两次及以上操作 4 不优，可以转化为执行 $6$ 次操作 1，因为花了 $6$ 代价只翻转了 $6$ 个元素。所以只用特判是否执行一次操作 4。

## 代码

```cpp
const int maxn = 510;

int n, m, a[maxn][maxn], b[maxn][maxn];
char s[maxn][maxn];

void solve() {
	scanf("%d%d", &n, &m);
	for (int i = 1; i <= n; ++i) {
		scanf("%s", s[i] + 1);
		for (int j = 1; j <= m; ++j) {
			b[i][j] = (s[i][j] == 'B');
		}
	}
	int ans = 0;
	for (int i = 1; i <= n; ++i) {
		for (int j = 1; j <= m; ++j) {
			a[i][j] = (b[i + 1][j + 1] ^ b[i + 1][j] ^ b[i][j + 1] ^ b[i][j]);
			if (a[i][j]) {
				++ans;
			}
		}
	}
	for (int i = 2; i <= n; ++i) {
		for (int j = 2; j <= m; ++j) {
			if (a[i - 1][j - 1] && a[i - 1][m] && a[n][j - 1] && a[n][m]) {
				printf("%d", ans - 1);
				return;
			}
		}
	}
	printf("%d", ans);
}
```
