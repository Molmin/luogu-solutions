## 思路
首先，略微观察之后可以得到一个结论：翻转包含 $(n,1),(1,m)$ 的矩形必定不优，因为它们可以用 $2$ 个包含 $(1,1)$ 的矩形构造出来。

于是题目变成了只能翻转包含 $(1,1)$ 或 $(n,m)$ 的矩形。

将矩形做一个二阶差分，我们发现翻转包含 $(n,m)$ 的矩形相当于在差分矩阵上修改一个点（注意修改的点一定不在第一行第一列），而在这些位置翻转包含 $(1,1)$ 的矩形会修改 $(1,1),(x,1),(1,y),(x,y)$。

在反转完 $x,y>1$ 的位置后，我们会接着回去翻转 $x=1$ 或 $y=1$ 的矩形，就完成了整个过程。

也就是说，我们记 $f_i$ 为第 $i$ 行是否翻转，$g_j$ 为第 $j$ 行是否翻转，$h$ 为 $(1,1)$ 是否需要最后翻转。一次 $(1,1)$ 的操作等价于翻转 $f_i,g_j,h$，消耗 $1$；而一次 $(n,m)$ 的操作什么都不翻转，消耗 $3$。

也就是说，如果我们翻转 $(n,m)$ 的矩形，可能会比翻转 $(1,1)$ 的矩形多花 $+3,+1,+1$ 的费用。

不难发现 $+1$ 和 $+3$ 的费用最多只能创造一次 $-1$，因此我们一定只执行 $-1$。

而 $-1$ 只会出现最多一次，枚举每个位置即可。
## 代码
```cpp
char s[503][503];
bool a[503][503];
bool b[503][503];
bool f[503],g[503];
signed main()
{
	int n=read(),m=read();
	for(int i=1; i<=n; ++i) scanf("%s",s[i]+1);
	for(int i=1; i<=n; ++i)
		for(int j=1; j<=m; ++j) a[i][j]=(s[i][j]=='B');
	for(int i=1; i<=n; ++i)
		for(int j=1; j<=m; ++j) b[i][j]=(a[i][j]!=a[i][j-1]);
	for(int i=n; i>=1; --i)
		for(int j=1; j<=m; ++j) b[i][j]=(b[i][j]!=b[i-1][j]); 
	// for(int i=1; i<=n; ++i,puts(""))
		// for(int j=1; j<=m; ++j) printf("%d",b[i][j]);
	int c=b[1][1];
	int ans=0;
	for(int i=2; i<=n; ++i)
		for(int j=2; j<=m; ++j)
			ans+=b[i][j],f[i]^=b[i][j],g[j]^=b[i][j],c^=b[i][j];
	for(int i=2; i<=n; ++i) f[i]^=b[i][1];
	for(int j=2; j<=m; ++j) g[j]^=b[1][j];
	for(int i=2; i<=n; ++i)
		ans+=f[i],c^=f[i];
	for(int j=2; j<=m; ++j)
		ans+=g[j],c^=g[j];
	ans+=c;
	int flg=0;
	for(int i=2; i<=n; ++i)
		for(int j=2; j<=m; ++j)
			if(b[i][j]&&f[i]&&g[j]&&c)
				flg=1;
	printf("%d\n",ans-flg);
	return 0;
}
```