## 题意
给出一个长度为 $2n$ 的 $01$ 序列，我们定义「左边」为前 $n$ 个数的序列，「右边」为后 $n$ 个数的序列。  
你需要求出最少进行几次交换才能使左边和右边的逆序对数相同。  

$1\le n\le10^5$
## 题解
首先我们考虑永远不会交换 $n,n+1$ 这两个位置的数时该怎么统计答案。  

当原序列存在一对相邻的 $0,1$ 时，若 $0$ 在前，则交换这两个数会让序列的逆序对数 $+1$，反之，则 $-1$。容易发现实际上除非原序列构成了形如 $aaaaaabbbbbb$ 的形状的话，我们是总有办法通过 $1$ 次交换来使得逆序对数发生 $1$ 的改变。

同时，基于上面这个性质，我们会发现总是可以将一个序列的逆序对数量操作到某个和这个序列中 $1$ 的数量有关的区间内。  

这意味着我们如果不交换 $n,n+1$，那就只需要考虑左右两边的逆序对数，记为 $x,y$，然后令逆序对数多的那一边不断操作直到两边相同为止，这时答案是 $\mathrm {abs}(x-y)$。  

但是不交换 $n,n+1$ 却依然能获得最优解的概率并不高，所以我们还是要考虑需要交换的情况。  

很明显的，需要交换 $n,n+1$ 当且仅当我们想让左右两边的 $1$ 的数量发生变化。  

因此我们考虑枚举左右两边的每一个 $1$，然后尝试将它交换到另一边，然后统计答案案。这里我们以想要将左边的 $1$ 交换到右边为例。  

我们定义 $pre[i][j],las[i][j],cnt[i][j]$ 分别为 $i$ 这一边中第一个出现的 $j$ 的位置，$i$ 这一边中最后一个出现的 $j$ 的位置，$i$ 这一边中 $j$ 的出现次数。  

那么尝试将一个 $1$ 放到右边时，我们当然是想要让左边的最后一个 $1$ 交换到 $n$，将右边的第一个 $0$ 交换到 $n+1$，再交换 $n,n+1$。  
于是我们可以计算出这样做的代价就是 $n-las[0][1]+pre[1][0]$。  

但是我们只是仅仅计算出了交换的代价而已，交换的过程中还会对左右两边的逆序对数产生影响。

对于左边来说，其逆序对数发生的变化是：最后一个 $1$ 被放到了 $n$ 这个位置，$n$ 这个位置变成了 $0$，前者会使逆序对数减少 $n-las[0][1]$，后者会使逆序对数增加 $cnt[0][1]-1$。  

剩下三种情况（从左边把 $1$ 换到右边时右边的变化，从右边把 $1$ 换到左边时左右两边的变化）可以尝试自己讨论一下，难度并不大。  

注意一下尝试从左边换 $1$ 到右边和从右边换 $1$ 到左边中间需要还原一下数据。  

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long int_t;

int_t read() {
    int_t x = 0, w = 1; char ch = 0;
    while(!isdigit(ch)) {ch = getchar(); if(ch == '-') w = -1;}
    while(isdigit(ch)) x = x * 10 + ch - '0', ch = getchar();
    return x * w;
}

const int_t maxn = 100010;

int_t A[maxn], B[maxn];
queue<int_t> pre[2][2];
stack<int_t> las[2][2];

int main() {
    int_t n = read();
    for(int_t i=1;i<=n;i++) A[i] = read();
    for(int_t i=1;i<=n;i++) B[i] = read();
    int_t x = 0, y = 0, tmp = 0, tans = 0;
    for(int_t i=1;i<=n;i++) if(A[i]) ++tmp; else x += tmp; 
    tmp = 0;
    for(int_t i=1;i<=n;i++) if(B[i]) ++tmp; else y += tmp;
    int_t cnt[2][2] = {0}, tx = x, ty = y;
    for(int_t i=1;i<=n;i++) ++cnt[0][A[i]], pre[0][A[i]].push(i), las[0][A[i]].push(i);
    for(int_t i=1;i<=n;i++) ++cnt[1][B[i]], pre[1][B[i]].push(i), las[1][B[i]].push(i); 
    int_t ans = abs(x-y);
    while(cnt[0][1] && cnt[1][0]) {
        tans += pre[1][0].front() + n - las[0][1].top();
        x = x - n + las[0][1].top() + cnt[0][1] - 1;
        y = y - pre[1][0].front() + cnt[1][0];
        las[0][1].pop(); pre[1][0].pop(); cnt[0][0]++; cnt[0][1]--; cnt[1][0]--; cnt[1][1]++;
        ans = min(ans, abs(x-y) + tans);
    } 
    tans = cnt[0][1] = cnt[1][0] = cnt[0][0] = cnt[1][1] = 0;
    for(int_t i=1;i<=n;i++) ++cnt[0][A[i]];
    for(int_t i=1;i<=n;i++) ++cnt[1][B[i]];
    x = tx; y = ty;
    while(cnt[0][0] && cnt[1][1]) {
        tans += pre[1][1].front() + n - las[0][0].top();
        y = y - cnt[1][0] + pre[1][1].front() - 1; 
        x = x - cnt[0][1] + n - las[0][0].top();
        pre[1][1].pop(); las[0][0].pop(); cnt[0][0]--; cnt[0][1]++; cnt[1][0]++; cnt[1][1]--;
        ans = min(ans, abs(x-y) + tans);
    }
    cout << ans;
}
```
## 证明
*这部分写的比较复杂，因此我们放到最后来说*  

首先我们最初所说的那个有关于 $\mathrm{abs}(x-y)$ 的结论，容易发现你无论如何交换，都不可能在一次交换中让逆序对数产生大于 $1$ 的变化，因为你的交换只会影响所交换两个数之间的位置关系，无法影响到其他数，那么 $\mathrm{abs}(x-y)$ 就是交换次数的下界了。  

其次是另一个问题，我们如何保证在交换 $1$ 的时候不会产生冗余的操作？换句话说，我怎么知道先把 $1$ 换来换去是不是最优解？~~手模发现不可能~~

我们需要知道的是，实际上我们是在枚举左右两边 $1$ 的数量，只是直接这么做比较麻烦所以改为尝试将 $1$ 换边而已。那么当我们确定左右两边中 $1$ 的数量以后，我们也就能确定需要交换多少个 $1$ 了。  

我们在题解中进行的交换实际上是将与中间最近的数个 $1$ 交换到另一侧，这一部分的操作是必须进行的，而且代价不会变少，在其他合法方案中也是必须进行的，差别只是进行的时间。  

而为什么换最靠中间的数个 $1$ 是最优的，我们可以考虑反证，如果换这几个 $1$ 不是最优的，那么我们依然需要换足够数量的 $1$，只能从不那么靠近中间的 $1$ 中代替。  

考虑某个在原方案中需要交换的第 $i$ 个 $1$，现在它不能被交换，而要去交换另一个比这个 $1$ 靠外的 $1$。在交换的过程中，总会使得存在一个时间，我们需要交换这两个 $1$，而我们知道交换两个 $1$ 的操作一定是冗余的，因此这样的操作方案一定不会是最优秀的。