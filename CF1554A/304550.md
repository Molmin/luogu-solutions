题目大意：
问你一个序列的所有长度不小于 $2$ 的子区间的最大值和最小值**乘积的最大值**。

从数据范围就能发现，一定是个 $\text{O}(T\times n)$ 的算法。

所以想到了单调队列或者单调栈维护。

但是仔细想想，这个子区间的长度只能为 $2$。

为何？

我们就先从长度为 $2$ 的区间开始考虑。

那么很明显权值就是 $a[l] \times a[r]$ 。

考虑一个长度为 $3$ 的区间，且里面的元素是 $\{a,b,c\}$ （按顺序）。

+ 假设 $b$ 是最大的，那么它就会和 $\min(a,c)$ 结合，那么就和长度为 $2$ 的没有任何区别。

+ 假设 $a$ 是最大的，那么有如下两种情况。

	1. $b$ 比 $c$ 小，那么这个区间的权值一定是 $a \times b$ ，转化成了长度为 $2$ 的情况。
    2. $b$ 比 $c$ 大，那么这个区间的权值就是 $a \times c$ ，但是很明显， $a\times b $ 也就是长度为  $2$ 的时候绝对比这个 $a\times c$ 更优（因为我们最终要求的是最大值）

反过来同理，然后把这个结论扩展到 $n=4,5,6...$ 就能证明结论正确。

所以现在只需要读入的时候让相邻的元素两两相乘，求乘积的最大值，这个最大值就是答案。