### 题目大意
本题为CF177B2的数据略微削弱版。

给你 $N (2 \le N \le 10^{9})$ 个棋子，将它们排列为 $a$ 行 $b$ 列的矩形，拿走 $a-1$ 行，用剩下的 $b$ 个棋子作为新一轮的 $N$ 循环进行该操作直到无法再分解。输出每轮结束后的剩余棋子数（包括一开始的棋子数）。

### 分析

看这个操作，发现该问题是不断将原问题的规模缩小之后进行循环求解的，符合递归的性质，考虑用递归模拟实现。

我们发现，对于 $N$ 个棋子，想要在操作后保留尽可能多的棋子数，应该让行数尽可能少。因此，从小到大枚举 $N$ 的因数作为行数，模拟操作即可（然而似乎其他题解都没有使用递归求解。。。我认为递归更符合题目操作本身的意图）。

特别地，对于 $N$ 是 $1$ 或者质数，它就只能排列为纵向的 $N$ 行 $1$ 列。

### AC CODE

```c
#include <bits/stdc++.h>
using namespace std;
int N;
int ans;
void Func(int x)
{
//	printf("%d\n",x);
	if(x==1)
	{
		ans++;
		return;
	}//如果只有1个，不能再分解
	for(int i=2;i*i<=x;i++)//枚举因数
	{
		if(x%i==0)//满足条件
		{
			x/=i;//拿掉a-1行棋子
			ans+=x;
	//		printf("%d %d %d\n",x*i,i,ans);
			Func(x);//展开新一轮递归
			return;
		}
	}
	ans++;//如果没有被枚举到因数，那么x是质数
	return;
}
int main()
{
	scanf("%d",&N);
	ans=N;
	Func(N);
	printf("%d\n",ans);
	return 0;
}
```
