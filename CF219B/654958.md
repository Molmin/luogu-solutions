### 贪心

这题解区的题解怎么全是暴力，这肯定会超时的，因此我们采用贪心解法。

首先题目求的是数字末尾 $9$ 的数量最多，而不是数字总共 $9$ 的数量最多，那么我们可以从个位开始遍历，如果这一位数字本来就等于 $9$，我们就跳过，否则我们就拿 $n$ 把这一位数字补成 $9$。

但是这道题目有很多细节：

- 数字可能会有负数，需要特判退位。

- 字符串输入，颠倒字符串。

- 高位以 $0$ 开头的特殊处理。

但是最重要的是：$n$ 的进位影响。

对于第一位，$n$ 对数位的影响是 $n$。

对于第二位，$n$ 对数位的影响是 $n\div10$。

对于第三位，$n$ 对数位的影响是 $n\div100$。

发现了吗，$n$ 对第 $i$ 位的影响其实就是将 $n$ 除以 $(i-1)$ 个 $10$，也就是我们在遍历的时候，每遍历一次，$n$ 就要除以 $10$，这样就可以保证 $n$ 大于 $0$ 时可以对这一位数字做出影响。

最后因为我们颠倒了字符串，所以记得倒叙输出，下面是完整代码：

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
ll n,m,k,ans=0,len;
string s;
ll a[20];
void f(){//退位特判 
	for(int i=1;i<len;i++){
		while(a[i]<0){
			a[i]+=10;
			a[i+1]--;
		}
	}
}
int main(){
	cin>>s>>n;
	len=s.size();
	for(int i=1;i<=len;i++){//字符串颠倒 
		a[i]=s[len-i]-'0';
	}
	for(int i=1;i<len;i++){
		f();//退位 
		if(a[i]==9){//不需要补 
			n/=10;
			continue;
		}		
		if(n>=a[i]+1){//补 
			n-=(a[i]+1);//数字减少 
			a[i]=9;
			a[i+1]--;//退位 
		}
		else{//n无法对 a[i] 做出影响，遍历停止 
			break;
		}
		n/=10;//见文字 
	}
	while(!a[len]&&len>1){//高位0特判 
		len--;
	}
	for(int i=len;i>=1;i--){//倒叙输出 
		cout<<a[i];
	}
	return 0;
}

```

最后，让我们一起膜拜 [creation_hy](https://www.luogu.com.cn/user/576378) 吧。