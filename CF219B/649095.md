# 题意
给你一个 $p$ 和一个 $d$ 让 $p$ 减去尽可能小且小于 $d$ 的正整数数，使结果的末尾的 $9$ 最多。
# 思路
显然，我们可以枚举末尾的 $9$ 的个数进行贪心。由于 $p \le 10^{18}$ 所以，只需要枚举 $18$ 种情况即可。（之前题解区的题解有枚举 $d$ 的，这是显然行不通的，因为 $d \le 10^{18}$ 会 T 到飞起）（注：这里是为了避开思路误区，错误题解现已被爆破）
# 实现
## 1、枚举
让 $i$ 从 $18$ 到 $p$ 本身末尾有的 $9$ 的个数，如果找到符合的情况直接输出并结束程序，如果最终没找到那么输出 $p$ 本身即可。
```cpp
	t=p;
	while(t)
	{
		if(t%10==9)sum++;
		else break;
		t/=10;
	}//统计p本身末尾有的9的个数 
	for(int i=18;i>sum;i--)//枚举末尾9的个数 
	{
		if(check(i))//判断是否成立 
		{
			long long ans=p/(long long)pow(10,i)-1;//不是末尾9的部分 
			if(ans>0) cout<<ans;//如果有输出 
			for(int j=1;j<=i;j++)//输出末尾的9 
				cout<<9;
			return 0;
		}
	}
```

## 判断
我们先算出末尾 $9$ 的大小并算出末尾 $9$ 前面的数将其拼接并判断其是否大于 $p-d$ 且小于 $p$ 即可。
```cpp
bool check(int i)
{
	long long a=pow(10,i)-1;//末尾的9组成的数 
	long long c=p/(long long)pow(10,i)-1;//截取前面的数 
	if(c<0) c=0;//防止出锅 
	long long b=c*(long long)pow(10,i);//给9空位 
	return p-d<=b+a&&p>=b+a;//判断 
}
```