T1题解

Easy和normal：随便搜索都可以过的啊这个不说了啊

Hard:你可以用先用sort排序一遍然后依次记录使用每一瓶缩小药水最大打多少然后再用Easy和normal的方式搜索这一层就够。

Extra：根据Hard的想法我们可以很清晰的得到我们是要搜索使用每一瓶缩小药水最大能打多少伤害，而且最大的伤害量也不大，那么可以用到一个很冷门的排序方式 桶排序  就是输入的时候直接把全部的数据读入然后用桶读入

接下去用for循环每次给i增加3计算到 i = 29998就可以

然后每丢一个缩小药水就计算一次如果攻击大于m则跳出循环 然后用3个while判断先把3攻的随从去掉 其次是1攻的最后是2攻的这样答案就很明显出来了。如果看不懂的话可以看代码。


//at1 at2 at3用来记录你拉了多少个可以造成多少伤害随从。

```cpp
//ans表示造成的伤害
//snum记录使用多少缩小药水
#include<cstdio>
int to[30010],snum = -1,at1,at2,at3,n,m,ans;
int main ()
{
    scanf("%d%d",&n,&m);
    for (int i = 1; i <= n; i ++)
    {
        int p;
        scanf("%d",&p);
        to[p] ++;
```
}//读入数据然后桶排
```cpp
    for (int i = 1; i+2 <= 30001; i +=3)
    {
        ans += to[i];     at1 += to[i];//桶内有多少个可以打出1点伤害的 
        ans += to[i+1]*2; at2 += to[i+1];//桶内有多少个可以打出2点伤害的
        ans += to[i+2]*3; at3 += to[i+2];//桶内有多少个可以打出3点伤害的
        snum ++;//多使用一瓶缩小药水  第一次进入的时候是不使用 
        if(ans >= m) break;//如果伤害大于则退出循环寻找 
    }
    while(ans >= m+3 && at3) {at3 --; ans -= 3;}//如果伤害溢出超过3点则先把3攻随从去掉 因为3攻需要用到4费显然是十分不值得 
    while(ans >= m+1 && at1) {at1 --; ans -= 1;}//其次是删除掉1点攻击力的，因为同样的耗费显然是2攻打得多 
    while(ans >= m+2 && at2) {at2 --; ans -= 2;}//最后才是把2费剔除掉。 
    if(ans >= m) printf("%d %d",snum,at1+at2+at3*4+snum);
    else printf("Human Cannot Win Dog");
}
```