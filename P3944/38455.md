### 思路:排序

先排序，不难发现，要使得「缩小药水」数最小，你只需要从小到大拉过来就行了。于是从小到大扫一遍，可以拉就拉，不能就用「缩小药水」再拉，直到攻击力总和大于对手血量。

如果你认为就这样就行了，那么恭喜，你会惊奇地发现你连样例1都过不去。就样例1而言，如果你按如上方法，你会同时选了`1`,`2`,`3`,输出结果(最小费用)是`6`,可是其中无需选`1`,也就是说，按上述方式选好后，还得"还"一些回去。

下面考虑究竟"还"哪些回去。观察得，每次可以拉一个攻击小于等于3的，每次「缩小药水」也是降低3点，可以发现其实只要讨论模3之后的3种情况。要使费用最小，就要使"还"回去的费用大。
1. 先看`3`,"还"一个`3`回去可减少4费，同时减少3点攻击；如果"还"一个`1`和一个`2`,减少的攻击还是3点，可是却只减少2费，可得先尽可能(不能让总和小于$\texttt{m}$)把`3`"还"回去。
2. 再看`1`和`2`,"还"2个`1`或1个`2`都减少2点攻击，但前者减少2费而后者只减少1费，所以优先"还"`1`,最后"还"`2`。

最后说一下关于排序的事$:$
1. 如果你比较懒，排序可以直接用$\operatorname{sort}$,但记得开O2.
2. 如果你不懒，你可以写桶排序(其实也没几行)，因为`0<ki<=30000`.

$\mathbb{CODE:}$
```cpp
#include <bits/stdc++.h>
const int MAXN=5000005;
int n,m,i,j,k=3,x,y,a[MAXN],b[MAXN];
//x是「缩小药水」数量,y是最小费用,b是用来桶排序的 
inline void read(int &x)   //快读 
{
	short negative=1;
    x=0;
    char c=getchar();
    while(c<'0' || c>'9')
    {
    	if(c=='-')
			negative=-1;
		c=getchar();
	}
    while(c>='0' && c<='9')
        x=(x<<3)+(x<<1)+(c^48),c=getchar();
    x*=negative;
}
inline void print(int x)   //快输 
{
    if (x<0)
        putchar('-'),x=-x;
    if (x>9)
        print(x/10);
    putchar(x%10+'0');
}
signed main(void)
{
	read(n),read(m);
	for (i=1;i<=n;i++)
		read(a[i]),b[a[i]]++;
	for (i=1;i<=30000;i++)   //桶排序 
		while (b[i])
			a[++j]=i,b[i]--;
	for (i=1;i<=n;i++)
	{
		bool f=false;
		while (a[i]>k)    //不得不使用「缩小药水」时 
		{
			if (m<=0) //尽量发挥「缩小药水」的效果,在一次结束时在退出而不是在m一旦小于等于0时就退出 
			{
				f=true;
				break;
			}
			x++,y++,k+=3;   //使用一次「缩小药水」
		}
		if (f)
			break;
		y+=(a[i]<k)?1:4;    //判断一下是1费还是4费 
		m-=(a[i]%3)?(a[i]%3):3;    //这里采用的是直接从m上扣 
	}
	if (m>0)   //拉了所有随从还是A不暴它 
		return printf("Human Cannot Win Dog"),0;
	for (i=1;i<=n && m<0;i++)
		if (a[i]%3==0 && a[i]<=k && m+3<=0)
			y-=4,m+=3;
	for (i=1;i<=n && m<0;i++)
		if (a[i]%3==1 && a[i]<=k && m+1<=0)
			y-=1,m+=1;
	for (i=1;i<=n && m<0;i++)
		if (a[i]%3==2 && a[i]<=k && m+2<=0)
			y-=1,m+=2;
	//先3,再2,最后1
	print(x),putchar(' '),print(y);
	return 0;
} 
```