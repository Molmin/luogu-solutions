[题目传送门！](https://www.luogu.com.cn/problem/AT_joi2014ho3)

[更好的阅读体验？](https://www.luogu.com.cn/blog/sincerin520/solution-at-joi2014ho3)


**前言**：模拟赛出了这题原题，但是当时的我沉迷于推导前一题组合数的柿子并在上面花费了两个半小时然后成功爆蛋了![](//图.tk/1)。赛场上没来得及读这题，结果考完一看发现他喵的这题比上一题简单多了。心态有点炸裂，于是我就决定了要写这篇题解。



## 题意

雪豹排了很长很长时间的队才买到了传说中雪市最美味的年轮蛋糕。但是这种蛋糕太硬了，所以雪豹在切蛋糕时只能按照老板娘切好的 $n$ 个切口把蛋糕切成 $n$ 块（因为蛋糕是环形的，所以 $n$ 个切口可以分成成 $n$ 块）。蛋糕的形状是均匀的，第 $i$ 块与 第 $i+1$ 块之间有一块体积为 $a_i$ 的蛋糕。这时，同住雪市的食雪汉和東雪莲来蹭饭了。出于我中华传统文化的待客之道，雪豹想用三刀将蛋糕切成三块，自己吃最小的那块。但是他又想吃的尽可能多，那你能帮帮他吗？

- $3 \leq n \leq 10^5$ 
- $1 \leq a_i \leq 10^9(i \in [1,n])$ 


## 解析

首先题目明确说了要求三块中的最小值尽可能的大，也就是最小值最大化一类的题目，一眼二分。我们可以二分雪豹分到的蛋糕的体积，即最小值的大小，然后判断这个值是否合法（是否可以由其中连续的一段蛋糕“拼”出来）。

首先就是预处理部分，我们可以在输入时求出 $a$ 的前缀和数组 $sum$，即  $sum_i=\sum_{j=1}^i a_j$，同时 $\sum_{i=l}^r a_i=sum_r-sum_{l-1}$。处理出前缀和数组对于每一段体积和的计算和码长的减少都有很大帮助。

还有一个问题就是这个蛋糕是个环。对环的处理方式一般分为两种，第一个就是在变量循环到 $n$ 时特判一下，再次回到开头。还有一种方法就是“破环为链”，也就是把原序列复制一份放到末尾，使得原序列变为长度为 $2n$ 的序列，造成伪环。在这里我采用了方法二来处理。

前戏差不多了，那么二分判断函数 `check(mid)` 该怎么写呢？

首先大家肯定都能想到两层循环来枚举前两刀的位置，这样第二三块的长度也可以确定了(只要让第二块蛋糕的体积大于等于 `mid`，判断第三块即可)。时间复杂度为 $\Theta(n^2)$。算上最外层的二分，总时间复杂度在 $\Theta(n^2 \log_2 \sum_{i=1}^n a_i)$ 级别，只能过掉前两个总共 $20$ 分的子任务。

既然内层枚举过不了，我们可以思考一下，由于每一块蛋糕的体积都是正整数，加上一块蛋糕只会让整段蛋糕的总体积变大，所以符合单调递增函数的单调递增性，我们可以考虑在后两刀的选择时进行二分，时间复杂度降为 $\Theta (n  \log_2 n )$，总时间复杂度为 $\Theta(n \log_2 n \log_2 \sum_{i=1}^n a_i)$，已经足够通过本题了。

但是这还没完，如果有同学比较熟悉双指针，那么他一定能发现，当我们最外层 $\Theta(n)$ 枚举第一刀的时候，每次都会确定后两刀的位置。但其实第一次确定第一刀位置时，我们就可以确定第一对合法的后两刀，使得切出的前两块蛋糕的体积均大于等于 `mid`。随着第一刀的后移，第一块的体积会减小。我们要确保第一块和第二块蛋糕的体积均大于等于 `mid`，则第二刀和第三刀都是要么原地不动，要么后移，不可能往前移。这样一来，后两刀的位置也不需要每次都从头枚举，其实就相当于两个指针在外层的 $\Theta(n)$ 循环中各移动 $n$ 次，时间复杂度还是 $\Theta(n)$。总时间复杂度为 $\Theta(n \log_2 \sum_{i=1}^n a_i)$。


## AC Code

```cpp

//C++14(GCC 9)  1.05KB  43ms  5.76MB 
#include<iostream>
#include<cstdio> 
using namespace std;
#define ri register int
#define _ 0
const int N=100005;
long long n,m,l,r,a[N];//开long long! 
long long sum[N<<1],ans;
inline bool check(long long x)
{
	long long  k1=1,k2=1;
	for(ri i=1;i<=n;++i)
	{
		ri lt=i,rt=i+n;//注意a[i]表示第i~i+1个切口之间的距离,sum[i+n]-sum[i]表示第i+1~i+n+1个切口之间的距离
		while(sum[k1]-sum[lt]<x&&k1<rt) ++k1;//加上"k1<rt",防止数据极小，一直累加导致越界RE 
		while(sum[k2]-sum[k1]<x&&k1<rt) ++k2;
		if(sum[rt]-sum[k2]>=x) return true;//剩下的还够mid，可以继续增加mid
	} 
	return false;
} 
signed main(void)
{
	std::ios::sync_with_stdio(false);
	cin.tie(NULL); cout.tie(NULL); //cin,cout优化 
	cin>>n;
	for(ri i=1;i<=n;++i) 
	{
		cin>>a[i];
		sum[i]=sum[i-1]+a[i];//前缀和 
	}
	for(ri i=n+1;i<=(n<<1);++i) sum[i]=sum[i-1]+a[i-n];//破环为链
	l=0,r=sum[n]/3;//由于最短的一段不可能超过sum[n]/3,故上界r=sum[n]/3 
	while(l<=r)//二分最短段的长度 
	{
		long long  mid=(l+r)>>1; //(l+r)>>1相当于(l+r)/2向零舍入 
		if(check(mid)) 
		{
			l=mid+1;
			ans=mid;
		}
		else r=mid-1;
	}
	cout<<ans<<"\n";//AT好像必须换行？ 
	return ~~(0^_^0);//完结撒花！ 
}
```

[AC Record](https://www.luogu.com.cn/record/116675408)


