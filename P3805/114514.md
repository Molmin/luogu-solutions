
参见了第一位大佬写的题解，使我从一个从未听闻Manacher算法的蒟蒻，到现在对这个神奇的算法有了一定的了解。

以下就是我对Manacher算法的一些个人的感受，补充以及总结。

#### 首先对于一个回文串有两种情况
### 1.abba
### 2.ababa
第一种情况的对称轴在中间，第二种情况的对称轴在a字符上。

我想排除这样的干扰，我就要对原图做点手脚
### 就像这样：
### ~|a|b|b|a|。
从而把两种情况并成了一种情况。这个步骤可以在读入是处理出来

##  _ _ _ _ _ _ _ __ _ _  __1.definition_ _ _ _ _ _ _ _ _ _ 
#### Manacher算法主要处理的是回文字符串的长度问题。它可以在线性的复杂度范围内处理出一个字符串中最长的回文子串，真是一个妙不可言的算法。见识了Manacher算法后，我感受到了信息学的博大精深以及其无穷的乐趣！\(^o^)/~

##  _ _ _ _ _ _ _ _ _ _ _ _2.thought_ _ _ _ _ _ _ _ _ _ _ _ 
#### Manacher算法主要就是几个步骤，它最主要的一步就是枚举每一个点的回文串时，它可以先“吸取先前的经验”，获得一个初始长度，这就使得Manacher算法不用在枚举这方面花费大量的时间，从而达到很快的效果。

##  _ _ _ _ _ _ _ _ _ _ _3.explanation_ _ _ _ _ _ _ _ _ _ 
#### Manacher算法主要使针对回文串的一些性质而得出的高效的算法。
####  对于一个回文串，肯定是有一个对称轴的，那么这个对称轴就具有了很多的性质。
#### 1.这个回文串关于中间的对称轴是左右对称的。
#### 2.我们令对称轴为x，假设在长度范围内，那么(x-len)的字符串区间和(x+len)的字符串区间也是对称的。也就是说在一个回文串内，任选一段区间 X ，一定存在关于"回文对称中心"对称的一个区。
#### 3.若一个区间的对称区间是回文串，这个区间必定是一个回文串。在大的回文串内，它们回文半径相等。（引自楼顶大佬）

我们求最长的回文串是通过枚举的方式得到的。从左往右扫一遍，从而得到最长的长度。

我们定义一个数组len[i]表示以i为中心的最长的回文串的长度是多少。

现在我们再结合前面的结论，我们假设现在有一个较长的回文串，我们已知它的对称轴，可以把它表示成————x————-，（即以x为中心的一个回文串.

假设我们已经处理完了左半边的最长回文串的长度

可以把回文串转化成 ------yyyyy------x-------z-------;

，我们现在想要求出len[z]的值，（假设z和中间的y关于x对称），那么根据回文串的性质，两边要满足对称的关系，那么我们可以直接确定右边的部分情况。

右边肯定和左边一样，就能转化为----yyyyy------x----yyyyy----------。
很好，这样我们相当于是不用费脑就知道了右边至少回文长度为5（由前面的性质3可以确定）

在这基础上，我们在向外扩展，就省掉了前面没有必要的操作。
在这期间，我们可以用mid和r来维护。

### mid和r
同时记录一个mid，一个r，分别代表 已经确定的右侧最靠右的回文串的对称中心和右边界。
### 重要结论：
### 保持r是最右的才能保证我们提前确定的部分回文半径尽量多。（想一想，为什么？\(^o^)/~）

这样Manacher算法就彻底地完成了！！！

如果你没有看懂没有关系，因为真正的主角还没登场！

### 真正精彩的部分在代码哦\(^o^)/~

### 相信你看完了代码，会对Manacher算法有更深的了解
！！！

# 前方高能！！！
##  CODE：


```cpp


//Manacher算法总结： 
//Manacher算法用来处理字符串中的回文字符串
//它可以很快地求出一个字符串中最大的回文串的长度。 
#include<\(^o^)/~>
#include<cmath>
#include<cstring>
#include<cstdio>
#include<iostream>
#include<algorithm>
using namespace std;
//每一个字符数组都有其自己的含义 
const int maxn=11000005;
//解释一下: 
char data[maxn<<1]; //这是data的字符串数组，包括处理后的字符串 
int p[maxn<<1];//p[i]记录了以i这个节点作为回文中心的回文串的最长的长度 
int cnt;//cnt是字符串数组的长度 
int ans;//ans是最终的答案，需要通过p[]数组更新 
inline void read()
{
    char c=getchar();//一个一个字符地读入 
    data[0]='~';
    //初始状态赋值为‘~ ’ 
    cnt=1;
	data[cnt]='|';//在最前面先插一个板子。 
    while(c<'a' || c>'z') 
	c=getchar();//输入字符 
    while(c>='a' && c<='z')
	{
		data[++cnt]=c;//现将这个字符读入 
		data[++cnt]='|';//边读就边吧‘| ’插入进去，便于之后的求值 
		c=getchar();
	} //这里是读入字符串的部分 
}
int main()
{
	read();//读入加处理 
	//读完了字符串，同时也预处理了，插入了很多板子。
	//接下来将要进入manacher算法的核心部分 
	int r=0;
	int mid=0;//先把r和mid赋值初始值都是0； 
	for(int i=1;i<=cnt;i++)
	{
		//现在进入manacher的算法流程，i从1到cnt枚举的是每一个回文中心 
		//因为我们处理的时候已经插了板子，于是在两个数之间的和在某一个字符上的
		//回文子串就都能考虑到 
		//p[i]肯定要从一个初始值开始判断。 
		if(i<=r)
		{
			p[i]=min(p[(mid<<1)-i],r-i+1);
		}
		//r是当前的右区间 
		//(mid<<1)的意思就是mid*2。
		//我们这样得到了一个p[i],可以保证在这段p[i]的长度中一定是回文的
		//但有可能回文的长度更大，这就需要我们去枚举 
		while(data[i-p[i]]==data[i+p[i]]) 
		++p[i]; 
		//这里是一个暴力枚举的过程。
		//从中间向外展开，看以i为回文中心的回文字符串最大的长度 
		if(p[i]+i>r) 
		{
			r=p[i]+i-1;
			mid=i;
		}//这里是更新的操作，我们更新回文到达的地方 以及mid 
		if(p[i]>ans) 
		ans=p[i];//把答案更新 
	}
	printf("%d\n",ans-1);
	return 0;
} 
```
