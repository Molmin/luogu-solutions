# Manacher算法
问题：对于1个字符序列，我们如何求得它得最长回文子序列

	     容易想到，枚举它所有的子序列，然后依次判·断，但是显然我们不能接受这种方
         法的时间复杂度；
         实际上我们有一种叫Manacher的算法，俗称马拉车算法，它可以在O(N)的时间里
         解决这个问题
## Manacher算法流程
首先，容易知道，当字符个数为奇数时，回文对称中心也会是一个字符，这样我们便容易得到回文中心的坐标(将这个字符序列看成一个以是s[0]为原点的数轴)
	
    	如：ABABA(假设我们是从s[1]开始存储字符的)
   那么它的对称中心坐标显然是3，最长回文半径也是3，如果字符个数为偶数呢，为方便
   操作，我们常常向原序列中插入一些不影响结果的相同字符(隔板)，将原序列转化为一个便于操作的序列
   		
        	如：ABBA  我们向这个序列中插入｜；
            
       就变成了:  ~|A|B|B|A|^(下面再说为什么两边混入了奇怪的东西)
       
    它的对称中心坐标显然是5，最长回文半径也为5，由于我们并不知道所给数据是奇数还是
    偶数，所以我们无论奇偶，都给原序列插入隔板(包括两端之外)，
    这样一来，如果原序列是偶数，那么我们插入的隔板数就是奇数；如果原序列是奇数，
    那么我们插入的隔板数就是偶数，
    
    	而显然：奇数+偶数=奇数；
    这样我们就将原序列变成了我们想要的序列，现在我们维护下面几个东西：
    	mid：已扫描序列中最长回文序列对称中心坐标
        	r：已扫描序列的右边界坐标
       	rt[i]：以i为对称中心的最长回文半径
    设r关于mid的对称点坐标为l，i关于mid对称点坐标为j。
那么，当i<r时，必然有rt[i]>=rt[j],因为他们关于mid对称，取>是因为我们不知道r外面是什么情况，所以我们更新rt[i]时要保证它没有超出r，

		即是：rt[i]=min(r-i，r[mid*2-i])；
        
  如果i第一次访问到r，那么不妨先给rt[i]赋值为1，再次它也有一个吧，然后我们就尝试去看看r外面的世界
  
  	即是：while(b[i]-rt[i]==b[i]+rt[i])
    	rt[i]++;//以i为中心同时向两边拓展，若相同则rt[i]+1，
        		//这也是为什么两端会混入奇怪的东西；
 当i走向外面的世界时，如果i+rt[i]>r;
 	
    	更新：mid=i，r=i+rt[i];
 最后答案为max(rt[1]，rt[2]....，rt[n])-1(假设n为处理之后字符的长度)
 
##  上代码：
 
 ```
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
const int inf=11000005;
char a[inf<<2],b[inf<<2];
int rt[inf<<2];
int insert()
{
	int len=strlen(a);
	int j=2;
	b[0]='~';
	b[1]='｜';
	for(int i=0;i<len;i++)
	{
		b[j++]=a[i];
		b[j++]='｜';
	}
	b[j]='^';
	return j;
}
void manacher()
{
	int len=insert(),mid=1,r=1,ans=-1;
	for(int i=1;i<len;i++)
	{
		if(i<r)
			rt[i]=min(r-i,rt[mid*2-i]);
		else rt[i]=1;
		while(b[i-rt[i]]==b[i+rt[i]]) rt[i]++;
		if(r<i+rt[i])
		{
			mid=i;
			r=i+rt[i];
		}
		ans=max(ans,rt[i]-1);
	}
	printf("%d",ans);
}
int main()
{
	scanf("%s",a);
	manacher();
	return 0;
}
```
