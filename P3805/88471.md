## manacher 算法小结

### 前言

 感觉 $manacher$ 和 $kmp$ 算法的主要想法差不多

 都是用之前匹配过的信息去做后面的事情, 这样才不会浪费之前的操作

 一个回文串可以进行快速匹配当然会有一些**优秀的性质**

### 从性质入手

 关于 **中点*mid*** 回文 *(性质 1)* ~~废话~~

 那么 **在一个回文串中**, 两个关于中点对称的点, **在这个回文串内** 回文长度就是相等的 *(要点 1)*

 从左往右遍历字符串, 我们想办法找到当前位置可以匹配的, 已经处理完的 **对称位置** *(步骤 1)*

 我们此时根据之前的处理完的位置 得到了当前位置的一个较长的 **回文半径**, 但可能这不是这个点的 **最长回文半径**, 仍然需要继续往后扩大 **回文半径** *(步骤 2)*

 那么问题来了, 我们应该找哪一个点作为*(要点 1)*中的 "这个回文串" 呢?

 我们选取 **回文串右端点** 最往右的的回文串作为 "这个回文串", 并记录 **中点*mid*** 这样就可以最大利用之前匹配的信息 *(步骤 3)*

 最右的端点最多往右移动 *n* 次, 所以算法复杂度是 $O(n)$ 的 *(性质 2)*

 特别的, 长度为偶数的回文串没有 **整数的回文中点**, 我们需要倍长原串

### 具体要点操作

 #### 1. 利用之前信息得到当前位置的回文半径

 $r[cur] = min(r[2*cur-mid],\ right_{max} - i)$
 
 不能超过当前处理完的右端点(*cur* 其实相当于 *i* 啦)

 #### 2. 往右继续扩大回文半径

 $if(s[cur-r[cur]-1]==s[cur+r[cur]+1])\ ++r[cur]$ 
 
 我这个是闭区间的回文, 所以要 +1 / -1

 #### 3.更新答案

 发现倍长后的右端点 **闭区间的回文半径** 就是答案 (感性理解)

### Code

 看 *dalao* 们写的都是开区间的回文, 那我就贴一个闭区间的回文吧...

 ~~代码很丑~~

 [$\color {DeepSkyBlue} {Code}$](https://www.luogu.org/paste/sj83wyld)