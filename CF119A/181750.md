这道题是一道求最大公因数的水题啊。蒟蒻我迅速用gcd秒掉这道题后，顺便看了看题解，结果惊奇地发现，发题解的人似乎都对STL很感兴趣，用一些STL里的奇奇怪怪的函数做这道题，因此我就发一篇~~正常点的~~题解吧

求最大公因数是数学里的一个重要思想，在计算机编程里也有重要的~~坑人~~作用，在以前，我们很可能会把他们的因数直接暴力枚举，这样也确实能在一些水题中靠数据的水成功通过，但是，时代在变化，枚举因数的方法现在在大部分题目中行不通，并以其低效容易TLE的特性被我们摒弃在求最大公因数的方法之外，因此，我们引进更高效的算法——辗转相除法，又名欧几里德算法。

算法来源：
设两数为 a、b(a>b)，求 a 和 b 最大公约数(a，b)的步骤如下：用 a 除以
b，得 a÷b=q......r1(0≤r1)。若 r1=0，则(a，b)=b；若 r1≠0，则再用 b 除
以 r1，得 b÷r1=q......r2 (0≤r2）.若 r2=0，则(a，b)=r1，若 r2≠0，则继
续用 r1 除以 r2，……如此下去，直到能整除为止。其最后一个为被除数的余数的
除数即为(a, b)。
例如：a=25, b=15，a/b=1......10, b/10=1......5,10/5=2.......0,
最后一个为被除数余数的除数就是 5,5 就是所求最大公约数。

现在我们就可以用辗转相除法来编写求最大公约数的程序，代码如下
```cpp
#include <bits/stdc++.h>
using namespace std;
int n, a, b;
int gcd(int a,int b)  //定义 gcd 函数 
{
	while (a%b!=0){
		int k=a%b;  //k 是 a 除以 b 的余数
		a=b;  //类似于迭代
		b=k;  
	}
	return b;  //返回b
}
int main ()
{
	int a, b;
    cin>>a>>b;
    cout<<gcd(a,b)<<"\n";
    return 0;
}
```
现在我们可以做这道题了
```cpp
#include <bits/stdc++.h>
using namespace std;
int n, a, b;
int gcd(int a,int b)  //定义 gcd 函数 
{
	while (a%b!=0){
		int k=a%b;  //k 是 a 除以 b 的余数
		a=b;
		b=k;
	}
	return b;
}
int main ()
{
	scanf("%d %d %d",&a,&b,&n); //标准输入 
	bool k=true;
	while(n>0)  //开始循环
    {
		if(k) n-=gcd(n,a);  //根据题意模拟
		else n-=gcd(n,b);  
		k=!k;  //把k的值颠倒，代表到下一个人了
	}
	if(!k) printf("0");  //输出0
	else printf("1");   //输出1
	return 0;  //完美结束
}
```
是不是很简单呢？
对了，再多说一句这种算法的时间复杂度是O(logN)

顺便吐槽一下，CF的题UKE的几率真的太高了