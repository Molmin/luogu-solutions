## 状态定义

注意到共 $i$ 台电脑的情况下，第 $i$ 台一定是手动打开的。

我们定义：

- $f_{i, j, k}$ 表示共 $i$ 台电脑的情况下，手动打开次数为 $j$ ，其中第 $k$ 次打开了第 $i$ 台，此前第 $i-1$ 台未打开。

- $g_{i, j, k}$ 表示共 $i$ 台电脑的情况下，手动打开次数为 $j$ ，其中第 $k$ 次打开了第 $i$ 台，此前第 $i-1$ 台已打开。

## 转移方程

边界条件：$f_{1, 1, 1} = 1$，$f_{2, 2, 1} = g_{2, 2, 2} = 1$，$f_{2,2,2} = g_{2, 2, 1} = 0$。

$$ f_{i, j, k} = \sum_{l=k}^{j} f_{i-1, j-1, k} + \sum_{l = 1}^{j-1}(f_{i-2, j-1, l} + g_{i-2, j-1, l})$$

$$ g_{i, j, k} = \sum_{l=1}^{k-1}(f_{i-1, j-1, l} + g_{i-1, j-1, l}) $$

### 第一个 $\sum$

考虑第 $i-1$ 台是手动打开的情况。

则手动打开第 $i-1$ 台时，第 $i-2$ 台未打开。否则，由于第 $i$ 台在第 $i-1$ 台前打开，第 $i-1$ 台将被自动打开。矛盾。 

对于打开前 $i-1$ 台且打开第 $i-1$ 台在第 $i-2$ 台前打开的操作序列，在打开第 $i-1$ 台之前的某一时刻插入开第 $i$ 台的操作可得到一个新的操作序列。

### 第二个 $\sum$

考虑第 $i-1$ 台是自动打开的情况。

第 $i-2$ 台和第 $i$ 台一定手动打开。

对于打开前 $i-2$ 台的任意操作序列，在任意时刻插入开第 $i$ 台的操作可得到一个新的操作序列。

### 第三个 $\sum$

第 $i-1$ 台一定是手动打开的。

对于打开前 $i-1$ 台的任意操作序列，在打开第 $i-1$ 台之后的某一时刻插入开第 $i$ 台的操作可得到一个新的操作序列。

## 代码实现

使用滚动数组压掉第一维以节约空间。

使用前缀和的思想可以 $O(1)$ 转移。

时间复杂度 $O(n^3)$，空间复杂度 $O(n^2)$。

参考代码：
```
#include <bits/stdc++.h>
using namespace std;
 
typedef long long ll;
const int N = 400 + 10;
 
ll sum[N][N];
ll f[2][N][N], g[2][N][N];
int main() {
	int n, MOD;
	cin >> n >> MOD;
	f[1][1][1] = 1, sum[1][1] = 1;
	f[0][2][1] = g[0][2][2] = 1, sum[2][2] = 2;
	for (int i = 3; i <= n; ++i) {
		for (int j = 1; j <= i; ++j) {
			ll sumf, sumg;
			sumf = sumg = 0;
			for (int k = j; k >= 1; --k) {
				sumf = (sumf + f[(i&1)^1][j-1][k]) % MOD;
				if (k != i) f[i&1][j][k] = (sumf + sum[i-2][j-1]) % MOD;
			}
			sumf = sumg = 0;
			for (int k = 1; k <= j; ++k) {
				if (k != 1) g[i&1][j][k] = (sumf + sumg) % MOD;
				sumf = (sumf + f[(i&1)^1][j-1][k]) % MOD;
				sumg = (sumg + g[(i&1)^1][j-1][k]) % MOD;
			}
			for (int k = 1; k <= j; ++k) {
				sum[i][j] = (sum[i][j] + f[i&1][j][k] + g[i&1][j][k]) % MOD;
			}
		}
	}
	ll ans = 0;
	for (int j = 1; j <= n; ++j) {
		ans = (ans + sum[n][j]) % MOD;
	}
	cout << ans;
	return 0;
}
```