刷计数 $dp$ 遇到一年前上分场的题，发现这个题完全可以 $O(n^2)$，然而数据范围是 400。。。

发现一个方案相当于：划分成若干段，段之间空一个位置，段长和加空格数为 $n$。段内元素是先选择其中一个，段中位置选的时间是先递减再递增，不同段中位置选的顺序没有关系。

那么直接 $f_{i,j}$ 表示开的前 $i$ 台机器构成了 $j$ 段的方案数。

转移是：

- 新开一段：$f_{i+1,j+1}\leftarrow (j+1)f_{i,j}$

- 在原来某一段的左边或者右边加一台：$f_{i+1,j}\leftarrow 2jf_{i,j}$

初值 $f_{1,1}=0$。满足 $i+j-1=n$ 的 $f_{i,j}$ 向答案做贡献。

复杂度 $O(n^2)$。

code:

```
	f[1][1] = 1;
	long long ans = 0;
	Rep(i, 1, n) Rep(j, 1, n){
		f[i][j] %= P;
		if(i + j - 1 == n) ans += f[i][j];
		f[i + 1][j] += f[i][j] * (j << 1) % P;
		f[i + 1][j + 1] += f[i][j] * (j + 1) % P;
	}
	cout<<ans % P<<'\n';
```

不知道能不能用代数重工业搞到更优复杂度