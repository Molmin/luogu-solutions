可以发现最终序列一定会分为：

一段手动点亮 $+$ 一个自动点亮 $+$ 一段手动点亮 $+\dots+$ 一段手动点亮

设 $f_{i,j}$ 表示点亮了 $i$ 盏灯，有 $j$ 段手动点亮的方案数。

则 $f_{i,j}=f_{i-1,j}\times2j+f_{i-2,j-1}\times j$

每一次开灯可以看做在原来的基础上插入序号 $i$ 表示第 $i$ 次开灯。

表示第 $i$ 次开灯可以开 **每一段开头或结尾的灯** 或 **新开一段**。

Q：方案算少了吗？

A：没有，只是表示当前开启的灯分成 $j$ 段，并没有一定连续，这 $j$ 段可以散落在原序列各个位置，插入 $n$ 个数后，自然对应上了每个位置。

Q：插入新一段时为什么要 $+2$ 盏灯？

A：如果新开了一段，必然与前后段形成一个自动打开，所以不仅要加本身，还要加自动打开的灯。

[![LeQP5n.png](https://s1.ax1x.com/2022/04/12/LeQP5n.png)](https://imgtu.com/i/LeQP5n)

Q：为什么乘 $2j$、$j$？

A：
1. 有 $j$ 段可以手动打开，可以选择开每段开头或结尾。
2. 新开一段可以开在头/尾/中间。

Q：加段能加中间，为什么开灯不能开中间？

A：
1. 加段加中间是因为保证开灯顺序不同
2. 但是如果加的话加在段中间，那么当前没加的序列中间段中间一定是空的，这意味着这个点将自动打开。


复杂度 $O(n^2)$

```cpp
int n,M,ans,f[405][405];
signed main(){
	cin>>n>>M;
	f[1][1]=1;//一个点只有一种开灯法
	for(int i=2;i<=n;i++)
		for(int j=1;j<=((i+1)>>1);j++)
			f[i][j]=(2ll*f[i-1][j]*j+1ll*f[i-2][j-1]*j)%M;
	for(int i=1;i<=((n+1)>>1);i++)ans=(ans+f[n][i])%M;
	//答案就是 n 个点，分成 1...n 段的方案数
	//但是不难发现，分成段数 ≤ n/2向上取整，所以就有了以上代码
	cout<<ans;
	return 0;
}
```
