考虑一个贪心策略：一开始选空集，然后每次选一个不在集合中的数加入集合，具体选哪个数呢？选择让新的答案最大的数即可。

然后集合大小从 $0$ 逐渐增大到了 $n$，得到了 $n + 1$ 个答案，我们选取其中最大的一个输出。

我们发现这样做成功 TLE 了（悲），但是并没有 WA，说明贪心是对的（确信）。

具体证明请下载 [徐翊轩的题解](https://files.cnblogs.com/files/PinkRabbit/Solution_to_CF573E_by_cz_xuyixuan.zip) 查看。

那么我们只需要快速维护这个贪心，具体地说，每个位置有一个权值 $b_i$ 和一个固定的值 $a_i$，需要支持四种操作：

1. 前缀 $b_i$ 加相同值。
2. 后缀 $b_i$ 加 $a_i$。
3. 查询 $b_i$ 的全局最大值。
4. 删除一个位置。

一般线段树没法做，我们考虑分块。（其实这是一种经典分块类型）

每 $\sqrt{n}$ 个元素分一块，那对于每一块就要实现：

1. 整体加。
2. 整体加 $a_i$。
3. 查询整体最大值。
4. 重构。

可以发现大概是类似斜率优化那套式子，维护上凸壳即可。

注意到 $a_i$ 始终不变，而要求的斜率不断递减，可以用单调队列维护，重构的时候也不用重新排序了。

本题还有 $\mathcal O (n \log n)$ 的做法，在题解中同样可以看到。不过因为要手写平衡树，我比较懒就不写了。

时间复杂度为 $\mathcal O (n \sqrt{n})$，[评测链接](https://codeforces.com/contest/573/submission/70984127)。