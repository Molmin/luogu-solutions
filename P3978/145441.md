## [题意](https://www.luogu.com.cn/problem/P3978)

设$f_i$表示$i$个点的有根二叉树个数，$g_i$表示所有$i$个点有根二叉树的叶子个数和，答案即为$\frac{g_n}{f_n}$。

学过卡特兰数的都知道$f_i$就是卡特兰数，其通项为$\frac{C_{2n}^n}{n+1}$。

对于$g_i$，有结论：$g_n=nf_{n-1}$，证明方法有生成函数和不用生成函数的方法，下面是不用生成函数的方法：  
对于所有节点数为$n$的有根二叉树，假设其有$k$个叶子。对于每个叶子，我们将其去掉后都会产生一颗$n-1$个节点的有根二叉树，我们使这棵树的标记$+1$，最后查询所有$n-1$个节点的二叉树的标记和即为答案。

下面考虑每个$n-1$个节点的有根二叉树会被标记几次，答案是恰好$n$次。  
证明：  
对于一颗$n$个节点的有根二叉树，其能添加的叶子节点分为两种：  
1.叶子节点的左右儿子。  
2.左右儿子缺一个的点，将缺的那个补上。  
从度数角度考虑，对于原来的$n$个节点，度数和为$2(n-1)$（每条边对度数和的贡献为$2$），而补一个叶子节点度数和（原来$n$个节点的）会增加$1$，补完后除了根节点，剩下的$n-1$个节点度数都为$3$（一个父亲两个儿子），总度数为$3n-1$，于是可以补的叶子结点个数为$3n-1-2(n-1)=n+1$。

之后代入原式算一算就可以得到一个式子，$O(1)$求解即可。

code:
```
#include<bits/stdc++.h>
using namespace std;
double n;
int main()
{
	cin>>n;
	printf("%.12lf",n*(n+1)/(2*(2*n-1)));
	return 0;
}
```
