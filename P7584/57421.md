首先我们发现，**对于每个选手是否能累计到最高分，必须在这个选手在一个回合中得到第一名的情况下来考虑。**

因为，当一个选手拿到第一名时，这个选手能加的分是最多的，那么拿到第一名的概率就是最大的。

进一步考虑一个选手拿到第一名时，其它选手的情况。**想要让一个选手的分数最高，那么其它选手累计的分就要尽可能低。** 但是又因为比赛规则的限制，每个选手在一个回合后一定会加分。因此，我们要考虑每个选手的加分状况。

把每个选手都扫一遍显然是过不了 $3 \le N \le 3 \times 10^5$ 的数据范围。重新分析，我们发现，对于一个选手在新的一个回合得到第一名后是否能让这个选手的累计分最高，关键在于这个选手的累计分能否比其它选手在新的一个回合后的累计分的**最大值**高，而我们要做的就是在短时间内确定这个最大值，同时让这个最大值尽可能小。

从加分规则入手，我们考虑如何加分才能让累计分中的最大值最小。可以先按原始累计分排序，然后把大的加分尽可能赋给累计分小的选手。这样就可以让每个选手的累计分尽可能小。

再考虑如何统计有多少选手能做到累计分最高。可以按原始累计分从大到小考虑，每次考虑完成后更新其它选手累计分的最大值，把 $N$ 个选手全考虑一遍统计得到答案。

本题思路如上，下面放出代码：

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#define ll long long
#define rgt register int
#define qmx(a,b) a<b?b:a
using namespace std;

const int mxn = 3e5+5;
int ans,b[mxn],n,mx;

int main(){
	scanf("%d",&n);
	for(rgt i=0;i<n;i++)
		scanf("%d",&b[i]);
  
	sort(b,b+n);  //排序
  
	for(rgt ad=1,i=n-1;i>=0;i--,ad++){
		if(b[i]+n>=mx)  //比较统计答案
			ans++;
		mx=qmx(mx,b[i]+ad);  //更新最大值
	}
  
	printf("%d",ans);  
	return 0;
}

```
