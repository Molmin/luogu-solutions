我又来优化了（滑稽

先讲BFS的基本原理（会的可以跳过）：

现有一个队列，一开始只有一个元素：初始状态。

然后每次对队首的元素进行判断。

1. 如果符合条件：

搜索结束。

2. 如果不符合条件：

将这个状态可能延伸的多种状态添加到队尾，并让队首出队。

是不是还是感觉很玄乎？来道真题试试：

现在有一个变量的初始值为0，你每次可以选择把它加1或加2。那么最少几次才能把它变成5

如果用BFS做是这样的：

```cpp
0

1 2

2 2 3

2 3 3 4

3 3 4 3 4

3 4 3 4 4 5//虽然搜索已经完毕，但是还要等到5出队时才知道

4 3 4 4 5 4 5

3 4 4 5 4 5 5 6

4 4 5 4 5 5 6 4 5

4 5 4 5 5 6 4 5 5 6

5 4 5 5 6 4 5 5 6 5 6

搜索完毕。
```


那么怎么才能记录次数呢？定义一个结构体，其中有步数和状态。当然，每次添加元素时也要把步数加1；

进入正题（优化）：

1. 不一定要等到出队时才判断。事实上，在入队时判断即可。

2. 这题要判重（要不然会T）。具体是：开一个标记数组，每次入队时同时把标记入队的状态（即位置）。在以后如果有相同的位置则不入队。

3. 这题最烦的地方是有多组数据，我看有很多大佬每次都清空标记数组。其实没必要，每次更换标记即可。最简单的标记是第1组数据用1标记，第2组数据用2标记……第i组数据用i标记。

4. 确定范围。首先，我们要知道：加1，减1和乘2的范围是不同的。设初始位置为想x，终止位置为y，那么：加1的范上限是y-1，减1的下限是1，乘2的上限是y+1。

还有，为了~~偷懒~~减少码量，我定义了一个生成结构体的函数。

```cpp
#include<bits/stdc++.h>
using namespace std;
int pc[100005];
struct z
{
	int w,c;
};
queue<z>a;
z f(int e,int u)
{
	z s;
	s.w=e,s.c=u;
	return s;
}
int main() 
{
	int t,i,x,y,sw,sc;
	cin>>t;
	for(i=1;i<=t;i++)
	{
		cin>>x>>y;
		while(a.size()) a.pop();
		a.push(f(x,1));
		for(;;)
		{
			sw=a.front().w,sc=a.front().c;
			if(sw+1==y||sw-1==y||sw*2==y)
			{
				cout<<sc<<endl;
				break;
			}
			if(sw+1<y&&pc[sw+1]!=i)
				a.push(f(sw+1,sc+1)),pc[sw+1]=i;
			if(sw-1>0&&pc[sw-1]!=i)
				a.push(f(sw-1,sc+1)),pc[sw-1]=i;
			if(sw*2<=y+1&&pc[sw*2]!=i)
				a.push(f(sw*2,sc+1)),pc[sw*2]=i;
			a.pop();
		}
	}
}
```
