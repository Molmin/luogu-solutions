### P.S.
高质量好题。  
### Discription.
给你一颗**二叉**树，每个叶子节点有一个权值 $V_i$，每个非叶子节点有一个概率 $P_i$。  
现在对于每一个叶子节点，它有 $P_i$ 的概率取它**儿子**的最小值，有 $1-P_i$ 的概率取最大值。  
现在求根节点的取所有值的概率，并把它们按照题目中的 Hash 函数 Hash 起来输出 Hash 值。  
### Solution.
题目重点或容易读错的（至少笔者读错了）的地方已加粗。  

首先，我们考虑朴素递推，假设 $F_{x,i}$ 为第 $x$ 点取权值 $i$ 的概率。  
那么因为它是棵二叉树，所以我们直接分类讨论。  
#### Case 1.
如果它没有孩子。  
很显然，那么只有权值为 $V_x$ 的地方概率为 $1$，其他地方概率为 $0$。  
#### Case 2.
如果它只有一个孩子。  
也很显然，那么它的权值肯定是它孩子的权值，直接把孩子的信息复制过来就好了。  
#### Case 3.
如果它有两个孩子，假设两个孩子是 $a$ 和 $b$。  
我们考虑分类：当前这个权值是从那个孩子转移过来的以及是被当作最大值还是最小值转移过来的。  
1. From a & Max : $(1-P_x)\times F_{a,i}\times\sum_{j=i+1}^{+\infty}F_{b,j}$
2. From b & Max : $(1-P_x)\times F_{b,i}\times\sum_{j=i+1}^{+\infty}F_{a,j}$
3. From a & Min : $P\times F_{a,i}\times\sum_{j=-\infty}^{i-1}F_{b,j}$
4. From b & Min : $P\times F_{b,i}\times\sum_{j=-\infty}^{i-1}F_{a,j}$

别看那里有一个 $\infty$，但是由于这题的操作只会取最小值最大值，所以最终的 $i$ 肯定只会在不超过 $\max_{i=1}^n V_i$ 的范围内有作用。  
***
但是，暴力转移显然是 $O(n\times \max_{i=1}^nV_i)$ 的，离散化一下后还是 $O(n^2)$ 的。  
因为这个方法的瓶颈是在状态数，状态数量就是 $O(n^2)$ 的了。  
那么我们考虑怎么优化状态数，显然这里有很多无用的状态（空状态。  

遇到分布地无规律的空状态，我们肯定能想到一个优良的做法——**线段树合并**。  
~~于是这题就做完了，完结撒花~~

在线段树合并中，对于每个区间，我们都需要考虑分别递归合并左区间和右区间。  
此时，我们就需要按照上面 4 类分类讨论分别计算左区间对右区间、右区间对左区间的贡献。  
然后我们会惊奇地发现，贡献是以倍数形式增加的，于是我们的线段树需要维护一个区间乘积操作。  
然后这题就真做完了，注意给 $V_i$ 离散化一下，毕竟值域这么大。  
~~不过不离散化也能做？毕竟是动态开点线段树，只是复杂度从 logn 变成了 log值域了qwq~~
### Coding.
在这里给出笔者认为最重要的线段树合并操作的代码，其他就不给了（
```cpp
inline int Mrg(int x,int y,int a,int b,int p)
{
	if(!x) return allc(y,b),y;else if(!y) return allc(x,a),x;else down(x),down(y);
	int sxl=t[t[x].ls].sm,sxr=t[t[x].rs].sm,syl=t[t[y].ls].sm,syr=t[t[y].rs].sm,p1=p,p2=(1+P-p)%P;
	t[x].ls=Mrg(t[x].ls,t[y].ls,(a+1ll*p2*syr%P)%P,(b+1ll*p2*sxr%P)%P,p);
	t[x].rs=Mrg(t[x].rs,t[y].rs,(a+1ll*p1*syl%P)%P,(b+1ll*p1*sxl%P)%P,p);
	return up(x),x;
}
```