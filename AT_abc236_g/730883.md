# 思路
显然的，我们可以用 dp 解决问题，我们很容易地设计出：

$f_{i,j,l}$ 表示 $i$ 到 $j$ 用 $l$ 步的最少操作次数。很明显，时间和空间都不允许我们这么做。

## 优化1
我们考虑题目只用节点 1，所以我们可以优化掉一维。然后转移方程为：

$f_{j,l}=\min(\max(f_{k,l-1},v_{j,k}))$

矩阵加速经常用于优化部分递推式简单且固定的 dp 式子，而且用了矩阵可以进一步优化空间。

$$
\begin{bmatrix} 
f_{1,l-1} \\ f_{2,l-1} \\ ... \\f_{n,l-1}
\end{bmatrix}
\times
\begin{bmatrix} 
t_{1,1} & t_{1,2} & ... & t_{1,n-1} & t_{1,n}\\
t_{2,1} & t_{2,2} & ... & t_{2,n-1} & t_{2,n}\\
\vdots & \vdots & \ddots & \vdots & \vdots \\
t_{n,1} & t_{n,2} & ... & t_{n,n-1} & t_{n,n}
\end{bmatrix}
=
\begin{bmatrix} 
f_{1,l} \\ f_{2,l} \\ ... \\f_{n,l}
\end{bmatrix}
$$

当然我们的**矩阵乘法**得换成 $c_{i,j}=\min(\max (a_{i,k},b_{k,j})),(1\le k \le n)$。

最终算法时间复杂度为 $O(n^3\log L)$。

## 优化2
我们考虑优化数量较大的维数，也就是 $L$。

我们可以使用倍增，也就是：

$f_{i,j,l}$ 表示 $i$ 到 $j$ 用 $2^l$ 步的最少操作次数。

转移方程为：

$f_{i,j,l}=\min(\max(f_{i,k,l-1},f_{k,j,l-1}))$

然后我们为了满足题意要走 $L$ 步，我们就把 $L$ 进行二进制拆分，走有贡献的每一步，显然的我们需要另两个数组，存答案和进行更新，即：

$g_{i,j}=\min(\max(t_{i,k},f_{k,j,l}))$，这里的方程代表我在走，意思就是 $t_{i,k}$ 代表我前面走过的，$f_{k,j,l}$ 代表我现在要走的。最后把 $g$ 复制给 $v$ 即可。

时间复杂度为 $O(n^3\log L)$。

# 后记
其实这就是最短路。