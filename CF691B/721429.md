


# 前言

我的这篇题解应该比其他大佬的题解要好理解一点点吧，毕竟是被坑了 $10$ 次的代价。

这道题只要细心找找规律就行，但我还是被坑了至少 $10$ 次。。。。

# 题目描述 & 思路

一个字符串，要你判断是不是呈对称的关系，但这里却和普通的规则有所不同。

注意事项：

- 这道题不是回文串，例如 $\verb!abba!$ 虽然是回文串，但是在此题却**不成**对称关系。

- 在这道题中，判断的标准是**完全对称，也就是是呈镜像**（很像小学所学的轴对称图形）。

- 注意诸多字母的判断，例如 $n$ 严格来说并不是完全镜像，而 $m$ 同理。但是 $b$ 和 $d$ 是完全镜像的，$p$ 和 $q$ 也是完全镜像的。~~我被他们俩坑了有三四次。~~

- 有些字母大小写皆可成为镜像。

- 注意 $p$ 和 $q$ 是镜像的，反过来，$q$ 和 $p$ 也是镜像的。（啥也没说）。

- 注意要把全部呈镜像的都要找出来

以上几点为重要注意事项，弄明白了以后就可以来轻松水掉此题了。

# 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
	//定义
	 
	int l,i,f;// l 表示字符串长度, f 表示是否成完全镜像的字符串。 
	char s[1001],x,y;
	
	//输入
	 
	scanf("%s",s);
	
	//变量赋初值
	 
	l = strlen(s);
	f = 1;//假设一开始成立 
	
	for(i=0;i<=l/2;i++)//我们只需找到字符串的一半就可以了，注意 i <= l/2 ，不然遇上 a 这种数据就会被卡掉。 
	{
		x = s[i];//用 x 更方便表示 s[i]。 
		y = s[l-i-1];//用 y 更方便表示 s[l-i-1]。
		//x 和 y 也可以不用，只不过这样看的更方便。 
		 
		//根据x 和  y 来判断是否镜像，这里是按字母表的顺序来列出的。
		//注意有些字母大小写、或者反过来都是成立镜像的。 
		if(x=='A'&&y=='A')
			;
		else if(x=='b'&&y=='d'||x=='d'&&y=='b')
			;
		else if(x=='H'&&y=='H')
			;
		else if(x=='I'&&y=='I')
			;
		else if(x=='M'&&y=='M')
			;
		else if(x=='o'&&y=='o'||x=='O'&&y=='O')
			;
		else if(x=='q'&&y=='p'||x=='p'&&y=='q')
			;
		else if(x=='T'&&y=='T')
			;
		else if(x=='U'&&y=='U')
			;
		else if(x=='v'&&y=='v'||x=='V'&&y=='V')
			;
		else if(x=='w'&&y=='w'||x=='W'&&y=='W')
			;
		else if(x=='x'&&y=='x'||x=='X'&&y=='X')
			;
		else if(x=='Y'&&y=='Y')
			;
		//以上满足条件，啥也不用做。 
		else
		{
			f = 0;//不满足条件，f 设置成 0。 
			break;//及时跳出循环。 
		}
	}
	//根据 f 的值来输出。
	//注意是 NIE 而不是 NTE ！！！ 
	printf("%s\n",f?"TAK":"NIE");
	return 0;
}
```
