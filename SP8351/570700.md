## 前言

由于这道题的题目描述的不完整，所以我去 SPOJ 上看了一下格式，是这样的:

#### 输入格式

输入的第一行包含一个整数 $N \ (1 \leq N \leq 100)$。接下来的 $N$ 行描述了队伍得分的事件。每个描述包含一个得分的队伍，可以是 $1$ 或 $2$ 及一个时间戳（格式为分：秒），表示队伍得分的时间。分钟和秒都是用零填充的，范围分别为 $[00, 47]$ 和 $[00, 59]$（包含端点）。给定的时间戳都是唯一的。

#### 输出格式

输出的第一行必须包含第一队领先的时长。

输出的第二行必须包含第二队领先的时长。

所有的时长都应该以分：秒的格式表示，且需要有前导零。


#### 样例输入

```
3
1 01:10
2 21:10
2 31:30
```

#### 样例输出

```
20:00
16:30
```

## 题解

这道题让我们根据 NBA 比赛的进球记录，计算出两队各自领先的时间。

这道题我们可以模拟比赛的过程，也就是说，我们需要记录每个进球的时间和进球的队伍，并根据这些信息来更新两队的得分和领先的时间。

#### 具体实现

首先读入进球的数量 $n$，然后创建几个数组来存储进球的队伍、进球的分钟数和进球的秒数。注意我们要将分钟数转换为秒数，以方便计算。

然后我们创建两个数组来存储两队的得分和领先的时间，这两个数组都初始化为 $0$。

接着我们只要遍历每个进球事件就可以了。

对于每个事件，我们首先增加进球队伍的得分，然后根据得分情况来更新领先的时间。也就是说，如果第一队的得分大于第二队的得分，那么我们就将当前进球的时间和上一个进球的时间的差值加到第一队的领先时间上，反之则加到第二队的领先时间上。

在处理完所有进球事件后，我们还需要处理在最后一个进球之后到比赛结束这段时间，这段时间应该加到得分高的队伍的领先时间上。

最后，我们输出两队的领先时间，注意要将秒数转换为分钟和秒数的形式，并且需要有前导零。

这道题目我们只要理解了题意，就可以马上做出来了。

## 代码

```
#include<bits/stdc++.h>
using namespace std;

int main() {
    int n;
    cin >> n;
    int team[101], minute[101], second[101];
    for (int i = 1; i <= n; i++) {
        char ch;
        cin >> team[i] >> minute[i] >> ch >> second[i];
        minute[i] = minute[i]*60+second[i];//转换
    }

    int score[3] = {0}, time_in_lead[3] = {0};
    team[0] = 0; minute[0] = 0;
    for (int i = 1; i <= n; i++) {
        score[team[i - 1]]++;
        if (score[1] > score[2]) {
            time_in_lead[1] += minute[i] - minute[i - 1];
        } else if (score[1] < score[2]) {
            time_in_lead[2] += minute[i] - minute[i - 1];
        }
    }

    score[team[n]]++;
    if (score[1] > score[2]) {
        time_in_lead[1] += 48 * 60 - minute[n];
    } else if (score[1] < score[2]) {
        time_in_lead[2] += 48 * 60 - minute[n];
    }

    printf("%02d:%02d\n", time_in_lead[1] / 60, time_in_lead[1] % 60);
    printf("%02d:%02d\n", time_in_lead[2] / 60, time_in_lead[2] % 60);
}
```