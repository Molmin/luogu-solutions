### 解方程
#### Solution
　　注意这个题目直接暴力判断$[1,m]$中的解, 是肯定会TLE的(50分).然后可以用一些方法来加快.

　　注意我是用Py写的, 通过不了这个题可能只是因为Py太慢了.

- 高精+暴力判断, 50分.
- 高精+秦九韶算法, 50分.
- 取模+暴力判断, 60分.
- 取模+秦九韶算法, 70分.

#### 取模
　　下面介绍一下**取模**这种思路, 因为会涉及到**高精乘法,高精加法**这种东西, 而且高精常数极其感人.

　　如果整个运算过程对一个特定的整数$p$取模, 会发现对于一个数$x$, 如果$$nm= 0, n+m= 0$$.那么$$nm\equiv 0 \mod p,n+m\equiv 0 \mod p$$.然后会发现如果这个**多项式**$$a_0+a_1x+a_2x^2+\cdots+a_nx^n= 0$$, 那么$$a_0+a_1x+a_2x^2+\cdots+a_nx^n\equiv 0\mod p$$.

　　这使得能保证**不会遗漏每个使得多项式为0的解**, 但是有没有可能会**将不是解的数判定为解**呢, 这是肯定的, 但是与数$p$的选择有关.

　　如果我们将$p$选择为2, 那么可想而知, 大约有一半的数会被判定为解.一般的方法是选择一个**大质数**, 像 1000000007 , 很大几率能通过这个题目.

#### 秦九韶公式
　　接下来还需要一种东西叫**秦九韶公式**的东西来帮助我们,它将多项式
$$a_0+a_1x+a_2x^2+\cdots+a_nx^n$$变为
$$\cdots((a_nx+a_{n-1})x+a_{n-2})x\cdots+x_0$$
的形式, 我们这样只需要进行$2n$次运算, **每次加上一个数$a_k$, 再乘上$x$**, 这样就**将非常麻烦的$x_k$转化为了$k$次乘$x$的操作**.

　　这一步操作写成代码的形式如下,
```
j=n
while j>0://从a^n到a^1
        an+=a[j]//加上系数a^j
        an*=x//乘上一个x
        j-=1
        an%=1000000007

    an+=a[0]// 最后需要加上常数项的系数
    an%=1000000007// 取模
```
#### Code
完整代码, 注意只能得到70分, 可能是因为Py3的效率问题.
```
nm=range(3)
nm=list(map(int,input().split()));
n=nm[0]
m=nm[1]
i=0
a=[]
ans=[]
tot=0
while i<n+1:
    j=int(input())
    j%=1000000007
    a.insert(i,j)
    i+=1

i=1
while i<=m:
    an=0
    j=n
    while j>0:
        an+=a[j]
        an*=i
        j-=1
        an%=1000000007

    an+=a[0]
    an%=1000000007
    if an==0:
        ans.insert(tot,i)
        tot+=1
    i+=1

print(tot)
i=0
while i<tot:
    print(ans[i])
    i+=1
```