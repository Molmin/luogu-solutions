一道$dp$题（当然考试时候我并没有想出来）

由于数据太水，你只需要
```cpp
printf("%d\n", read());
```
就有20分。。。。。。

## 正解：
设$f[i][j]$，表示第$i$列，状态是$j$可获得的最大长度设第一行为A， 第二行为B， 第三行为C

那就有从A过来的，从B过来的，从C升序过来的，从C降序过来的四种情况，考虑转移

如果是A，$f[i][A]$就需要在A时候判断能不能加，否则就和其他的取个MAX，B同理，C的话，看看是从升或降哪一个

升的和降的取MAX就行，$m$比较大，所以先离散化，之后用线段树维护一下就好了，这是转移方程，其中$j$是你枚举的状态

```cpp
f[i][0] = max(f[i][0], query(1, j, 1, cnt, 1, a[i][0]) + 1);
f[i][1] = max(f[i][1], query(1, j, 1, cnt, a[i][1], cnt) + 1);
if(j != 3) f[i][2] = max(f[i][2], query(1, j, 1, cnt, 1, a[i][2]) + 1);
if(j != 2) f[i][3] = max(f[i][3], query(1, j, 1, cnt, a[i][2], cnt) + 1);
```
之后再分别$Change$一遍就完了，应该好理解吧
```cpp
Change(1, 0, 1, cnt, a[i][0], f[i][0]);
Change(1, 1, 1, cnt, a[i][1], f[i][1]);
Change(1, 2, 1, cnt, a[i][2], f[i][2]);
Change(1, 3, 1, cnt, a[i][2], f[i][3]);
```
完结撒花？