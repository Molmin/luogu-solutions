> 第一次独立做出 *2500 纪念。

一个显然的情况是如果 M 取到最大值，那肯定是他赢了，因为 G 必须取和他曼哈顿距离 $k$ 以外的，所以他一直取这个最大的就行了。

同样，如果 M 第一次取的位置和最大值所在位置曼哈顿距离大于 $k$，那么 G 直接取最大值 M 无论如何也不可能赢。  
那么考虑 M 取了和最大值曼哈顿距离在 $k$ 以内的情况，此时 G 如果不同样取和最大值在曼哈顿距离在 $k$ 以内的点，那么 M 就直接取最大值，无论 G 暂时捡了怎么样的便宜，都会被 $10^{100}$ 次的漫长时光给击败，所以 G 不能取和最大值相距 $k$ 以上的。同样如果之后某一步 M 取到外面去了，G 取到最大的也一定会获得胜利，所以 M 不会取距离最大值曼哈顿距离超过 $k$ 的点。

那么就不用考虑距离最大值曼哈顿距离 $k$ 以上的点了，可以把那些点从网格中删除变成一张新的网格。  
这时可以惊喜地发现，问题变成了一个和原问题形式相同，规模更小的问题，那么只要找到一个递归的边界就可以解决问题了。  
注意 G 的取值还有一个限制，即和 M 的曼哈顿距离必须大于 $k$，如果某一个时刻剩余的网格大小不足以给 G 这样一个选项，M 必然获得胜利。

那么就有了一个做法：对于 M 的每个开局，都这样模拟网格不断缩小的过程。  
但是这样时间复杂度太高了。可以发现对于一个范围内的所有点，棋盘缩小的过程是一样的，所以可以转换一下求答案的顺序，将所有数排序，从大到小如果点已经被删除，则标记为 G 赢，否则缩小网格。  
维护棋盘的删除可以将曼哈顿距离转换成切比雪夫距离，这样剩余网格就变成了方形，可以很方便地维护。

提交记录：[#153099044](https://codeforces.com/contest/1658/submission/153099044)。