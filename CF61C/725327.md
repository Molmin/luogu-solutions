**题意**

给定一个 $ n $ 进制的数，将它转换为 $ m $ 进制或罗马进制



------------


**大致思路**

容易想到，可以分两种情况来处理。判断 $ m $ 是否等于 $ R $ 。如果 $ m=R $ ，输出罗马进制，否则转换为 $ m $ 进制 $ (m{=}\mathllap{/\,}R) $ 。

首先我们处理转换为 $ m $ 进制的情况。将 $ n $ 进制转换为 $ m $ 进制，需要把 $ n $ 进制先转化为 $ 10 $ 进制，再从 $ 10 $ 进制转化为 $ m $ 进制。

$ n $ 进制转 $ 10 $ 进制的方法：

** _按权相加法_ **

把 $ n $ 进制数先写成加权系数展开式，

然后再按 $ 10 $ 进制的加法求和，

得到 $ 10 $ 进制数。

例:将 $ 8 $ 进制数转为 $ 10 $ 进制，计算过程如下:

$$ (1234)_8=1\times8\times8\times8+2\times8\times8+3\times8\times8+4 $$

即:

$$ (abcde......)_n=a\times(n^{len-1})+b\times(n^{len-2})+...... $$


```
int to_10(string s,int n){
	int _10=0;//存储转换为十进制后的结果
	for(int i=0;i<s.size();i++){
		if(s[i]>='0'&&s[i]<='9') _10+=(s[i]-'0')*pow(n,s.size()-i-1);//当这一位在0到9之间,直接套进制转换模板
		else _10+=(s[i]-'A'+10)*pow(n,s.size()-i-1);//否则处理后再使用按权相加法
	}
	return _10;
}
```

以上便是 $ n $ 进制转换为 $ 10 $ 进制的示例代码

接下来要处理 $ 10 $ 进制转换为 $ m $ 进制



------------



$ 10 $ 进制转 $ m $ 进制,须除 $ m $ 取余,逆序排列:

用 $ m $ 除要进行转换的 $ 10 $ 进制数,

得到一个商和余数,

再用 $ m $ 除以商得到又一个商和余数

一直继续下去,直到商为 $ 0 $ ,

逆序排列,

得到 $ m $ 进制数

```c
string change(string s,int n,int m){
	vector<int>t;//用于存储n进制转换为10进制后的数
	int _10=to_10(s,n);//处理十进制
	while(_10){
		t.push_back(_10%m);
		_10/=m;
	}//存入vector,除n取余
	int l=0,r=t.size()-1;
	while(l<r){
		l++,r--;
		swap(t[l],t[r]);
	}
	string res;//存储转换结果
	for(int i=0;i<=t.size()-1;i++){
		char x;
		if(t[i]>=10) x=t[i]-10+'A';
		else x=t[i]-0+'0';
		res+=x;
	}
	return res;//转化为m进制,逆序排列
}
```


------------


处理完 $ n $ 进制转化为 $ m $ 进制,现在处理 $ R $ 进制



------------


```c
vector<int>ten={1,4,5,9,10,40,50,90,100,400,500,900,1000};//存储十进制数字
vector<string>R={"I","IV","V","IX","X","XL","L","XC","C","CD","D","CM","M"};//存储罗马进制
string change2(int _10){//十进制转罗马进制
	string res;
	for(int i=ten.size()-1;i>=0;i--){
		while(_10>=ten[i]) res+=R[i],_10-=ten[i];
	}//由于是正序储存,所以需要倒序枚举
	return res;
}
```



------------


**读入**

下面给出一种处理方式:

```c
string s;
int n;
char m;
cin>>n>>m>>s;
if(m=='R'){
	cout<<change2(to_10(s,n));
	return 0;
}
s=change(s,n,m-'0');
cout<<s;
```

拒绝 Ctrl+C 

------------

如果你还没有看到这里就将代码复制并且提交,你会发现出现了 MLE 。显然,上述程序的空间并不是最优。


关于更优处理 ( 参考  Confringo ) :


首先去除开头空格，


是负号则记录，


然后删去，转为 $ 10 $ 进制。


最后把 $ 10 $ 进制转化为目标进制，


然后如果记录过负号,


则再连接一个负号


当然，对于空间复杂度优化的方式并不是只此一种，在此处就不一一赘述了。


文末附上题目链接：


https://www.luogu.com.cn/problem/CF61C





------------



**The End**

