[题目链接](https://www.luogu.com.cn/problem/CF886D)  
这题看起来有点棘手，其实还是很好做的，并不需要什么高深的算法。  

首先很容易想到当给出的一个 most frequent 子串中有两个及以上的相同字符时是找不出符合条件的原串的。  
假设该情况下有符合条件的原串，那么原串中该重复字符出现次数肯定是比给出的这个 most frequent 子串多的，矛盾了。   
    
得出合法原串中每个不同字符最多出现一次也很容易。  
假设每个 most frequent 子串在原串中出现 $t$ 次。  
那么可以得出原串中每种出现了的不同字符都出现了 $t$ 次。   
当 $t=1$ 时，如果满足条件，那么肯定是最短。  
如果不满足条件，那么一定是有两个 most frequent 子串**相同的字符**不能**完全重合**。  
该种情况下，当 $t>1$ 时，两个 most frequent 子串相同的字符仍然不能完全重合，即仍然不能满足条件，没有合法原串。  
所以如果有原串，每个不同字符最多出现一次。    

我们可以把给出的字符串看成一个个条件。  
例如这个字符串 abc，
我们可以得出在原串中，  
字符 a 在 b 前一个，  
字符 b 在 a 后一个，字符 b 在 c 前一个，  
字符 c 在 b 后一个。  
显然，当给出条件矛盾时要输出 NO。  
然后，根据这些条件我们就可以生成出原串了。  
需要注意的是，这样得到的原串可能有好几块，最后需要进行排序才行。  
还有，给出的条件可能会构成环，需要判断，如果有环，那么就输出 NO。

## code：
```cpp
#include<bits/stdc++.h>
using namespace std;
int x[2][10000];
//x[0][i],表示ASCLL码为i的字符前面的字符
//x[1][i],表示ASCLL吗为i的字符后面的字符
string st[120001],s[120001];
int tt[12001],t[1201],v[12001];
int n,i,j,k[120001],ii,kk;
int main(){
	cin>>n;
	for(i=1;i<=n;++i){
		cin>>st[i];
		k[i]=st[i].length();
		for(j=0;j<k[i];++j){
		tt[st[i][j]]=1;//tt表示一个字符是否出现过
		if(t[st[i][j]])//t表示一个字符是否在这个串中出现过
        {
        cout<<"NO";return 0;
        /*如果原串中有相同的字符*/
        }
		t[st[i][j]]=1;
	}
			for(j=0;j<k[i];++j)t[st[i][j]]=0;
	}
	for(i=1;i<=n;++i){
		for(j=0;j<k[i];++j){
			if(j!=0){
				if(x[0][st[i][j]]>0&&x[0][st[i][j]]!=st[i][j-1]){
                //条件矛盾
					cout<<"NO";return 0;
				}
				x[0][st[i][j]]=st[i][j-1];
			}
			if(j!=k[i]-1){
				if(x[1][st[i][j]]>0&&x[1][st[i][j]]!=st[i][j+1]){
                //条件矛盾
				cout<<"NO";return 0;
				}
				x[1][st[i][j]]=st[i][j+1];
			}
		}
	}
	for(i=0;i<=200;++i){
	if(tt[i]&&x[0][i]==0){
    //如果ASCLL码为i的字符出现过且他前面没有任何字符
    //那么说明这个字符是一个新的"块"的开始
		ii=i;++kk;v[ii]=1;
		while(ii){	
		s[kk]+=char(ii);
		v[ii]=1;
		ii=x[1][ii];
		}
        
	}
}
for(i=0;i<=200;++i)
if(tt[i]&&!v[i]){
	cout<<"NO";
    //如果出现过得字符没有被加入到原串中
    //那么此时一定是出现了环
	return 0;
}
	sort(s+1,s+kk+1);//排序，取字典序最小
	for(i=1;i<=kk;++i)
	cout<<s[i];
}
```
太菜了，可能会有错误。  
所以大家有什么问题尽管提出。