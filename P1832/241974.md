显而易见，此题是一道背包题。

首先要注意：

### 若干个素数之和

所以，可以先筛出 $n$ 以下的所有素数。

### 下面进入入门级科普环节（神犇请忽略）：

这里提供几种筛法，请自行选择：

①欧拉筛
```cpp
for(int i=2;i<=n;i++) 
{
	if(!v[i]) 
	{
		p[++p[0]]=i;    //记录质数，p[0]用来计数 
	}
	for(int j=1;j<=p[0]&&i*p[j]<=n;j++) 
	{
    	v[i*p[j]]=1;	//把p数组中记录的素数，升序依次作为需消去的合数的最小质因子
    	if(!(i%p[j])) 		//若i为p[j]的倍数，则i=a*p[j]（a为常数），如果直接进入下一轮循环，j=j+1，i*p[j+1]=a*p[j]*p[j+1]，这里p[j]是最小的质因子，当i=a*p[j+1]时会重复，所以应该跳出循环
    	{
      		break;
    	}	
	}
}
```


②埃氏筛	
```cpp
for(int a=2;a<=sqrt(k);a++)				 
{
   	if(pd[a]==0)		//如果a是质数，那么a的所有倍数都不为质数
	{
   		for(int b=2;a*b<=k;b++)
   		{
   			pd[a*b]=1;
		}
	}
}
```
埃氏筛法的缺陷：对于一个合数，有可能被筛多次，浪费时间


③整数唯一分解定理：STL大法好

整数的唯一分解定理：一个大于1的整数一定可以被分解成若干质数的乘积。这个是数论知识，下面的代码基于这个定理，就不注释了

```cpp
vector<int> k;
for(int a=2;a*a<=m;a++)
{
	while(!(m%a))
	{
		k.push_back(a);
		m=m/a;
	}
}
if(m>1)
{
	k.push_back(m);
}
return k;
```

筛完质数，下面就是完全背包最为基础的版本。那么完全背包是什么呢？

### 下面进入普及级科普环节（神犇仍请忽略）：

与01背包一样，完全背包也是一个经典的动规问题，不同的地方在于01背包中，每件物品最多选择一件；而完全背包反之：只要装得下，每件物品可选择多件。所以解决策略已经不再是选或者不选的逻辑选择，而是取$n$（$0≤n≤\frac{T}{Vi}$）件。

~~但是完成这题似乎不需要理解那么多~~……

至于这题怎么用完全背包解决，已在代码后注释。

------------


Code：
```cpp
#include<bits/stdc++.h>
using namespace std;

int k;

int main()
{   
    cin>>k;
    int pd[k+1];					//bool类型亦可 
    long long whole[k+1];			//不开long long见祖宗 
    
    memset(pd,0,sizeof(pd));
    memset(whole,0,sizeof(whole));
    whole[0]=1;						//这里必须要特殊赋边界值（属于完全背包的环节） 
    
	//筛法求素数（上文已述，请自行补充）
        
    for(int m=2;m<=k;m++)			//最基础的完全背包代码 
    {
    	if(pd[m]==0)			//与筛法求质数一样，判断是否为质数
    	{
    		for(int n=m;n<=k;n++)
    		{
    			whole[n]=whole[n]+whole[n-m];		//总数=当前一轮循环的总分解方式数+当前二轮循环质数减去一轮循环的单独分解方式数
			}
		}
	}
        
    cout<<whole[k];
    return 0;
}
```
