###### 首先讲一下素数筛法，虽说这道题的数据不是很大，但是总有需要的时候，我们用一个数组，v[i]为真的时候代表不是素数，为假当然就是素数了。那么很显然，2x2，2x3，2x4……3x3，3x4……就都不是素数，我们就可以将其标为1.这样，我们只需要从2开始，走一遍程序，就可以得到所有的素数了。代码如下：
```cpp
int m=sqrt(n);
	for(int i=2;i<=m;i++)
	{
		if(!v[i])
		{
			for(int j=i;j<=n/i;j++)
			{
				v[i*j]=1;
			}
		}
	}
```
###### 其中的n就是题中的数据范围了。


###### 如果对背包熟悉的话，其实这就是一道类似于装箱问题的背包问题，其中正整数n是总容量，而不大于n的所有素数就相当于物品了，这样模型就抽象出来了，接下来，装箱问题已经明白的请自行忽略orz，

我们就对样例进行一下分析，看看究竟怎么实现；
n=7；所有的素数是2，3，5，7；
首先要明确的是0是初始状态（很重要），同时用ans[i]表示和为i的种类数，显然ans[i]=1.

第一步，就是对第一个素数2的操作，首先0就是初始状态，所以加上第一个素数就是2，所以ans[2]=1,再运行到和为2的时候再加上2就是4了(因为题目没有说素数不可以重复，所以同一个素数可以用多次，运行完之后和为0，2，4，6都有一种情况了)，所以ans[4]=1;如下所示

| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| 1 | 0 | 1 | 0 | 1 | 0 | 1 | 0 |

第二步，对第二个素数3的操作，类似于第一步，初始0，加上3，所以ans[3]=1,运行到2的时候，ans[5]=1,运行到3的时候ans[6]=1,运行到4的时候ans[7]=1,

| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| 1 | 0 | 1 | 1 | 1 | 1 | 1 | 1 |

第三步，同理把所有ans值为真的加上这个素数之后的数就会有一种新的拆分方法；

| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| 1 | 0 | 1 | 1 | 1 | 2 | 1 | 2 |

第四步，素数7

| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| 1 | 0 | 1 | 1 | 1 | 2 | 1 | 3 |

所以答案就愉快的出来了。

附上代码
```cpp
#include<iostream>
using namespace std;
bool f(int x){
	for(int i=2;i<x;i++){
		if(x%i==0){
			return 0;
		}
	}
	return 1;
}
long long ans[1005];
int main()
{
	int n;
	cin>>n;
	ans[0]=1;
	for(int i=2;i<=n;i++){
		if(!f(i)){
			continue;
		}
		for(int j=0;j<=n;j++){
			if(ans[j]&&j+i<=n){
				ans[j+i]+=ans[j];
			}
		}
	}
	cout<<ans[n];
}
```

需要说明的是，我自己写的时候没有用素数筛法，只是用了最朴素的方法，orz，如果有什么不对的可以在评论区提醒我一下哦，谢谢大家