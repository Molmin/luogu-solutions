## 简要题意

$N$ 个链（类似铁索），每个链由若干环组成，每次操作可以打开任意链中任意环，然后分开或串联另一部分，操作完成后将环闭上。

## 分析

若不考虑其他因素，要想合并 $N$ 个链至多需要 $N-1$ 次操作（显然）。

为什么实际操作次数会减少呢？我们考虑拆一条指定的链，用该链拆出的环作为中介合并另外两个链，依然 $N-1$ 次操作只能合并 $N$ 个链，但是若 $N>L_{i}$（$L_i$ 为指定的链），这条链就会被拆光，也就是 $N$ 少了一个，所以操作次数减少了。

于是我们要尽可能多地拆光链条，可以每次选取最短的链来拆，链接最长的两条链，就可以达到最优。

## CODE

```cpp
int n,a[N],ans;
signed main()
{
	read(n);
	rep(i,1,n) read(a[i]);
	sort(a+1,a+1+n);
	rep(i,1,n-1) while(a[i]&&i<n)
	{
		a[i]--;a[n-1]+=a[n];
		a[n--]=0;ans++;
	}
	if(a[n]&&a[n-1]) ans++;//最后两条链合并 
	printf("%d\n",ans);
	return 0;
}
```
