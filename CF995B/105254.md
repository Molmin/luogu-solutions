## 解析

考虑一种移动方案：

1. 找到最右侧（或最左侧，策略基本同）的元素 $x$
2. 找到 $x$ 对应（值相同）的另一元素 $x'$
3. 将 $x'$ 向右移动直到与 $x$ 相邻
4. “抹去” 这组元素，再如此循环

接下来我们证明这种方案一定是不劣的（即至少移动次数最少）

考虑每次找到的一对的元素 $x, x'$。由于将 $a_i$ 向右移动也可视为将 $a_{i+1}$ 向左移动，因此在某个的移动方案中，一定**至少**包含将 $x$ 向左移动 $i$ 次，将 $x'$ 向右移动 $j$ 次，直至 $x, x'$ 相邻

现在我们指出，将 $x$ 向左移动的 $i$ 次，全部转化为 $x'$ 向右的移动（即 $x$ 少向左移动 $i$ 次，而 $x'$ 多向右移动 $i$ 次），一定是不劣的

首先无论是将 $x'$ 向右移动或将 $x$ 向左移动，都会拉近 $x, x'$ 这一对的距离

再考虑第一次移动 $x$ 对其它元素对的影响。由于 $x$ 是在最边缘的（“抹去” 的元素不记），因此移动 $x$ **一定**会拉远另一对的距离（即和 $x$ 交换的元素所属的对）；而移动 $x'$ 有可能可以拉近另一对的距离

于是用归纳法不难得出，不移动 $x$ 一定是不劣的（即刚才的结论）

（证明可能有些细节问题，但大体思路就是这样X）

## CODE

直接模拟即可

```cpp
#include <cstdio>

int a[200];

int main(){
	int n;
	scanf("%d", &n);
	n *=2;
	for(int i =0; i < n; ++i)
		scanf("%d", &a[i]);
	int end =n-1, ans =0;
	while(end >= 1 && a[end] == a[end-1])
		end -=2;
	while(end >= 1){
		int pos =end-1;
		while(a[pos] != a[end])
			--pos;
		ans +=end-pos-1;
		for(int i =pos; i < end; ++i)
			a[i] =a[i+1];
	//	a[end-1] =a[end];
		end -=2;
	}
	printf("%d", ans);
}
```