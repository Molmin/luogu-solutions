第一篇题解交上去后洛谷没给过，说方法重复，不过那也是情理之中的事，因为我只是用那篇题解充实我的博客。

一次我打codeforce比赛，看到一道题，怎么也想不出来。这时爸爸叫我吃一个苹果，我吃完后，灵光一闪，终于想出了这道题。

这次我发现这道题居然还没人发题解，所以我就写了这么一篇题解。
## 题目意思
一个数列有$2n(1\leq n\leq 100)$个数，两两相同，但是是打乱的，每一次操作可以交换相邻两个数，要求把每一对相同的数都交换到一起，例如：
$$11233244→11323244→11332244$$
输出最少操作次数。（上面的例子是$2$）

[题目传送门](https://www.luogu.org/problemnew/show/CF995B)
## 分析
首先，我们发现无论交换过程多么复杂，对于每一对数来说，都是要交换到一起的，一步也少不了。所以说，看起来十分复杂的操作过程就被分解成每一对数交换到一起的过程。

再看下面的例子：
$$(1)1212→1122$$
$$(2)1212→1221$$
上面两种方法哪个更好？

很显然第一种好，第二种不好的原因在于操作以后，被交换到一起的一对把另一对隔开了，这样就需要耗费更多操作次数才能将隔开的一对换到一起。

所以，移到一起的一对不能隔开任何一对数，而只有它们在被交换到一起时在边上，才不会隔开别的数。

再想一种情况，如果把左边的向左移，或把右边的向右移，会使这一对之间的距离更远，会白白增加操做次数，得不偿失。

只有其中一个就在边上的时候，才能做到最优。

综合以上分析，我们终于找到了贪心策略：
1. 找到最右边的数
2. 找到和它配对的数
3. 把这个数一直和它右边的数交换，直到和最右边的数交换到一起。
4. 每一次和右边的数交换都算一次交换，计入次数中。
5. 然后最右边的两个数就可以抹去了。

输入样例#3：
```
3
3 1 2 3 1 2
```
输出样例#3：
```
3
```
我们用以上方法走一遍样例3，看看对不对：
$$312312$$
首先找到最右边的$2$。
$$31231\underline 2$$
找到另一个$2$。
$$31\underline 231\underline 2$$
交换到一起。（操作$2$次）
$$312312→313212→313122$$
最右边的$2$就可以抹去了。
$$3131(22)$$
再找到最右边的$1$。
$$313\underline 1(22)$$
找到另一个$1$。
$$3\underline 13\underline 1(22)$$
交换。（操作一次）
$$3131(22)→3311(22)$$
抹去右边的两个$1$。
$$33(1122)$$
而两个$3$也可以抹去了。
$$(331122)$$
加起来$2+1=3$，刚好$3$步，再想一下有没有反例，嗯……好像没有，然后写程序，提交程序……AC。
代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
	int n,i,j,tot=0;
    //n对数，操作tot次。
	cin>>n;
	n*=2;
    //2n个数
	int a[n];
	for(i=0;i<n;i++)
		cin>>a[i];
    //输入
	while(n!=0)
	{
		for(i=0;i<n-1;i++)
			if(a[i]==a[n-1])
				break;
        //找到和最后一个一样的数配对
		tot+=n-i-2;
        //n-i-2是操作次数（不信你数数看，用样例3）
		for(j=i;j<n-1;j++)
			swap(a[j],a[j+1]);
        //操作
		n-=2;
        //其实这就相当于把最后两个数抹去
        //因为下标大于n的数我们压根不看
	}
	cout<<tot<<endl;
    //输出
	return 0;
}
```
另外，其实向左移并从左边抹去数也是可以的，这里就不发代码了。

本来还有一些要写的，不过忘了，所以到这里就结束了。