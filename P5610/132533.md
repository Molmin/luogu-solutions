卡常大赛/tuu。                         

我们考虑每个数的因数不超过 $O(\sqrt[3]{a_i})$ ，这启发我们可以对于每个数开一个 vector 存储序列它是序列中哪些数的因数。               

接着我们可以知道，我们进行的除法操作卡满了是 $O(n \log a_i)$ 的。我们可以这么思考，当前的极限情况是 $a_i$ 为 $2$ 的整数次幂，此时就算一直除以 $2$ 也至多除 $log_{a_i}$ 次，所以总的除法操作时间复杂度上线是 $O(n \log a_i)$ 得证。                      

接着我们考虑我们的实现，我们不难发现我们完全可以做：               

- 对于操作 $1$ 我们直接去对应因数的 vector 中查找，然后从在区间中的第一个点开始往后面扫一直到扫出 r 为止，然后动态的修改这个点的值后考虑把这个点删除。              

其中找到区间中的第一个点可以在 vector 中元素有序的情况下二分查找，动态修改点的值结合操作 $2$ 是一个比较弱的区间求和，我们可以暴力树状数组就好了。         

现在的难点在于做到动态删点。                     

我们考虑用并查集维护，我们发现我们只要可以支持快速跳到下一个没被删除的点就好了，那么在每次修改完点值后我们判断一下这个点要不要删，要删的话就把它和下一个点合并，这样就可以做到 $O(a(n))$ 维护动态删点的过程了。               

时间复杂度 $O(a_i \sqrt {a_i} + n \log ^ 2 n)$ ，空间复杂度 $O(n \sqrt[3] a_i)$ 。
 
此题最恶心的地方在于卡常，我的代码不管怎么搞都要 T 第 $5$ 个点，所以打了个表（                

不过其他点都还是有技巧不难卡过去的，这里罗列几个此题的卡常点：          

1. 我们在并查集合并的时候不要直接把两个点找到根后合并，我们直接```fa[i] = i + 1```就好了，因为你也不知道后面还要不要用这个点所以我们直接先搁在这里，到时候要用再去路径压缩；              

2. 在找完初始点后，在遍历要更改的数时直接从它的根开始遍历就好了；        
3. 不要 vector ，直接先内存池；               

4. 刚开始的时候用 $O(n \ln n)$ 把每个数需要占用的内存池大小求出来后再用 $n \sqrt n$ 的质因数分解；             

基本这么实现后，就可以只 T 第 5 个点了，如果还过不了就真的得打表了，毕竟这道题现在确实卡常太严重了。