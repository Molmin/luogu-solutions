首先我们看这个题目,显然是可以用 **LIS** 和 **LDS** 的 **O(nlogn)** 的方法做的

但是有没有更好的办法呢？

当然是有的，在其他的题解中已经给出了 **O(n)** 的做法

~~但是我过于蒟蒻开始根本没看懂~~

于是这里就大概说一下 **O(n)** 做法的状态是怎么转移的

首先我们定义**up1 up2 up3**分别是在单调递增的情况下以1 2 3结尾的最小费用
而**down1 down2 down3**则是单调递减下的最小费用

那么假设目前最新的一个数字是1的时候

**up1**显然是不变的，因为它不需要额外的费用也能保证自己仍然是以1结尾单调递增的

而对于**up2**，首先它要把结尾变成2，于是费用铁定要+1，但是对于结尾是2的单调递增序列，它的倒数第二位既可以是1也可以是2，于是它就应该从**up1**和**up2**中较小的一位加上1转移过来

同理**up3**则是由**up1 up2 up3**中的最小者转移过来再加个1

单调递减情况下的转移也差不多，此处就不再阐述了

还有一个需要注意的点就是转移的顺序

因为**up3**的转移涉及到**up2**和**up1**，而**up2**也涉及到了**up1**所以单调递增的转移顺序应该是3 2 1，同理单调递减的转移顺序应该是1 2 3

代码就不贴了，~~毕竟和其他题解写得几乎一模一样~~