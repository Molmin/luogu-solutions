贪心。为了方便，我们认为 slime 每移动一格会将所在格完全吞并，格子的总数减少 $1$，这样数轴上所有格子都不空（我们认为初始时 $a_i=0$ 的格子不是空的）。

在这样的情况下，每次操作就是将 slime 向左或向右移动一格，可记为一个由左右组成的操作序列。在不让 slime 死掉的情况下任意调换操作序列的顺序是没有影响的。此时我们想让 slime 尽可能地规律行动，则操作序列由若干有规律可循的连续向左或向右序列组成。

考虑一段连续向左的序列（向右同理）为何终止。第一种情况即到达 $0$，此时已经逃出。第二种情况即再走一步会死亡，此时接下来必须向右。但是假设我们在面临死亡之前走到的若干格子贡献为负（即 $\sum a_i<0$），此时显然不走这几个格子直接转向右边能走的距离更远（或者不近）。因此我们的贪心策略希望我们每次往一个方向连续走时会在不死亡的情况下尽可能地增加自己的体重。

接下来我们实现这个贪心策略，容易想到用两个指针维护向左和向右走到的位置，每次向左（或向右同理）一直走到逃离或者会死亡为止，如果会死亡则记录下路上到哪个格子时体重变为最大，在此基础上哪个格子走得最远，然后将向左的指针移到这个最大的格子，然后转向。当向两个方向都无法增加体重也无法逃离时，就一定被困住了。

这个实现过程中每个指针更新位置时走到的最远的位置（即“会死亡”的位置）相对实际更新到的位置（即“取到最大值”的位置）的贡献一定为负，但此方向下次若能更新则一定贡献不小于 $0$，故一定能跳过这次走不通的位置。而若一个方向上已经不能为 slime 增加体重，那在另一个方向上 slime 也无法走得更远，slime 将会被困住。因此每个位置至多有一次走不通并返回，第二次便一定会路过或被困住而结束。从而总操作次数不超过 $2n$。每次操作复杂度为 $O(1)$，故时间复杂度为 $O(n)$。

Code:
```cpp
#include<cstdio>
#define rg register
#define ll long long
int n,k,p;ll v,s,m;
ll a[2000003];
int t;int main(){
	scanf(" %d",&t);while(t--){
		scanf(" %d %d",&n,&k);
		for(rg int i=1;i<=n;++i)scanf(" %lld",&a[i]);
		v=a[k];if(a[k]<0){puts("NO");continue;}
		int l=k-1,r=k+1;while(l&&r<=n){
			ll pv=v;
			s=m=0;p=r-1;for(;r<=n;++r){
				s+=a[r];if(s>m)m=s,p=r;
				if(s<-v)break;
			}if(r<=n)v+=m,r=p+1;
			else break;
			s=m=0;p=l+1;for(;l;--l){
				s+=a[l];if(s>m)m=s,p=l;
				if(s<-v)break;
			}if(l)v+=m,l=p-1;
			else break;
			if(v==pv)break;
		}if(l&&r<=n)puts("NO");
		else puts("YES");
	}return 0;
}
```