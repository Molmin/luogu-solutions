## 疑似本题最短dfs（无压行加上两行大括号和一行定义共8行）
### 一直WA的同学千万不要错过本题解末尾的坑点整理
#### 题意简述：
输入一幅图并输入N个命令，从“*”点开始向命令所指的方向（以下简称命令方向）探索，输出所有可能的重点

先贴代码：（代码看起来很长，但是如果把注释删掉只有45行，1.06KB）
```cpp
#include <iostream>
using namespace std;
int dx[5] = { 0,-1,1,0,0 }, dy[5] = { 0,0,0,-1,1 };// dx, dy用来控制车的上下左右移动
int n, m, k;//n,m地图的长宽，k命令的个数
int dir[1000010], x, y;//dir是每条命令所指的方向；x,y是车初始位置
bool s[110][110][2010] = { false };//剪枝用的三维数组，第三个2010一定要开够！我因为这个WA了将近十次！
char ma[110][110];//地图
void dfs(int stp, int xx, int yy, bool flag)//stp当前到达的步数；xx,yy当前到达的坐标；flag是当前可不可以尝试下一步
/*PS:当前命令执行过了，就有两种选择：一是继续执行当前命令，二是尝试下一步,但是你如果当前命令还没有执行过，就只能执行当前命令
坑点：当前命令需要且必须要执行
flag就是记录当前命令是否执行过的bool变量*/
{
	if (xx<1 || yy<1 || xx>n || yy>m || stp > k || s[xx][yy][stp] || ma[xx][yy] == 'X') return;
	//xx<1||yy<1||xx>n||yy>m 判断是否越界，越界就return;
	//stp>k 看看当前的步数有没有走超（比如一共3步，你现在已经到了第4步），如果走超就return;
	/*s[xx][yy][stp] 看看当前坐标处有没有来过
	注意：这里是s[xx][yy][stp]而不是s[xx][yy][dir[stp]]
	WA例分析：
	3 3
	*..
	.X.
	...
	5
	EAST SOUTH WEST NORTH EAST
	这时你需要两次以“EAST”方向经过（1,1）和（1,2），所以不能用方向剪枝，要用当前步数
	*/
	//ma[xx][yy]=='X' 你总不能从障碍物上开过去吧
	if (stp == k) ma[xx][yy] = '*';
	/*如果现在的步数已经等于要求的步数，就把当前坐标标记为“*”
	注意：
	这里不能直接return;
	WA例分析：
	3 2
	*.
	X.
	X.
	2
	EAST SOUTH
	如果你在这里直接return,那么你在(1,2)就会直接结束dfs,(2,2)和(3,2)就都不会被标记为“*”
	*/
	dfs(stp, xx + dx[dir[stp]], yy + dy[dir[stp]], true);//如果当前命令方向可以继续走，就继续探索
	if (flag) dfs(stp + 1, xx + dx[dir[stp + 1]], yy + dy[dir[stp + 1]], true);
	//如果当前命令方向已经走过了，即flag==true，就可以尝试下一个命令方向
	s[xx][yy][stp] = true;
	//剪枝方法：s[当前x坐标][当前y坐标][当前步数]=true，一定注意是当前步数而不是当前方向，原因参见代码17行WA例
}
int main()
{
	cin >> n >> m;//输入长宽
	for (int i = 1; i <= n; i++)//输入地图
		for (int j = 1; j <= m; j++)
		{
			cin >> ma[i][j];
			if (ma[i][j] == '*')//输入时存储初始点x，y坐标，并把初始点设置为'.'
				//必须设置成'.'的原因：初始点是“*”，结束点也是“*”，初始点就会影响结果
				//但是初始点必须在dfs前设置为'.'，因为车有可能停在原始区域（如行走了一个环形）
				x = i, y = j, ma[i][j] = '.';
		}
	cin >> k;//命令数
	for (int i = 1; i <= k; i++)
	{
		string str;
		cin >> str;
		switch (str[0])//比较首字符，重复比较用switch更方便
		{
			case 'N':dir[i] = 1; break;
			case 'S':dir[i] = 2; break;
			case 'W':dir[i] = 3; break;
			default: dir[i] = 4;
		}
	}
	dfs(1, x, y, false);//开始探索
	for (int i = 1; i <= n; i++)//输出地图
	{
		for (int j = 1; j <= m; j++)
			cout << ma[i][j];
		cout << endl;
	}
	return 0;
}
```


## 坑点和建议：（本人WA的经历，自认为非常全面，一直WA的同学不要错过）

1.这个代码如果不剪枝会有太多重复搜索，所以**必须剪枝**，剪枝要**用步数剪枝而不能用方向**，WA例及分析请看代码17行（不剪枝只能AC#1,3,5，剩下全部TLE，30分）（如果剪枝用了方向只能AC#1,3，20分，没错，还不如不剪枝）

2.**每个步骤需要且必须要执行**，这个是dfs函数中flag的作用（这个没写会WA#3，90分）

3.**每个步骤一定要重复尝试直到不能再继续**，不然会漏非常多可能的终点

4.**数组不能越界**，不然访问错误会卡机，0分

5.剪枝用的**s数组一定要开够**！我刚开始开的是s[110][110][110]，会WA#2,10，80分

6.**初始点在dfs前需要改成“.”**，不然会影响输出，参见main函数第8行（不然只能AC#2,3,10）

7.输入输出千万**不能用getchar()和putchar()**，这个我试过，输出全部正确也0分

8.**搜到可能的终点时不能直接return**，WA例及分析在代码30行

9.此题存储方向**用switch判断**很方便，但是看到之前的大佬没有用的，在这里提醒一句，switch里千万**别忘了写break**，（没写0分）

10.这里有一个小建议：**用dx，dy来控制小车的转弯**，这样就可以有效避免很多判断，我用这种方法成功把我的dfs函数长度减少到8行，还让代码比较优美可读

希望我的题解能够帮助到你

感谢管理大大审核！感谢大家耐心阅读！