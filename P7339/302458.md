# 分治+归并排序

## 题目大意
不难发现，本题中每个人的厨团就是他的实力，然后我们可以给两两 PK 的人其中之一加上 $M$ 的实力值。

## 题目分析
首先，我们很容易发现这题不存在一个贪心策略(但是可以用随机化贪心乱搞），目前无法证明任何一个贪心策略的正确性。
所以，按照最暴力的解法（暴力解法往往是正确的）本题应该将所有可以赢的情况枚举一次，最后把所有最后可以赢的人存起来看有没有 Shido。

可是，这题有 $ 2^{18} \times 10 $ 的数据，肯定不能用简单的 $ 2^n$ 枚举过，考虑优化。\
因为这题给的数据都是 $ 2^n $ 级别的，并且我们发现，这题求解的问题是可分割，可合并的，比如一个 $2^k$ 的区间内，所有胜者就是左边的可能胜者加右边的可能胜者，可以我们可以很自然想到用 `分治` 的策略来递归求解。
### 分治是什么

首先简单介绍一下分治，如果会了可以直接跳过这一段。

`分治`，即分而治之，就是把问题分割成子问题，再把子问题分割成孙子问题（此处略去 $ logn$ 次），
最后分割成一个不可分的子问题（递归边界），然后再分别对这个子问题的解进行合并的过程。

通过以上的描述，不难发现分治与头递归（也就是先递归后处理）的相通性，在头递归中我们可以便捷地对问题进行分割
到达边界后返回，然后对于分割完的结果进行合并。

在思考分治问题的时候，我们要深入理解这种头递归的思想，在考虑如何合并的时候要预设我们合并的对象本身是已经具备最优性的（在前面的递归已经处理好了），然后对这个最优的子结构进行最优的合并从而得出解。

通过分治的定义，不难发现，想要使用分治，这个问题就必须得具备**可分性**，存在**分治边界**，**可合并性**，**最优子结构性**，**子问题不互相影响**等性质。这里面的很多性质都是我们的老朋友了，比如最优子结构性，这个在 `贪心算法` 与 `DP` 中也是适用的，但是这些算法不需要具备**可合并性**。另一方面，如果一个问题的子问题要重复计算，那么分治就会很浪费时间，而且合并也有可能会合并错，这时候就不应该选用分治，比如 [数字三角形问题](https://www.luogu.com.cn/problem/P1216) ，像这类题目如果分治会重复计算很多次，这时应该选用 `DP` 来求解。又，因为我们比较常用二分的分治，所以子问题不互相影响通常可以从题目的 $2^n$ 的数据中得到暗示，比如完全二叉树，比如比赛的晋级这类问题。

回到本题，我们可以把区间不断分割，最后的递归边界就是只剩一个人，这个人自己作为可能胜者，然后向上合并。每个区间内保存了这个区间内的可能胜者，注意一个区间内的可能胜者不一定是父区间内的可能胜者，需要经过合并时的判断操作。

那么换句话说，这个区间可以派这个人出战，那么只需要考虑这个人能否打的过右边派出的任何一个人，如果打得过说明这个人可能作为这个区间胜者。

可以暴力枚举右区间的人，不过太慢了，考虑对于每个人都只需要找出对面最小的那个人来比较，只要打得过对方最小的人就可以胜利，不过我们需要对双方都进行排序。排序考虑堆排或者快排都是 $nlogn$ 的复杂度，外加分治的  $log n$ 总复杂度是 $ O(nlog^2n) $ 。既然已经想到了分治，何不考虑分治排序呢？分治排序不仅可以辅助排序，还可以顺便把赢的算出来复杂度是 $ O(nlogn)$ ，至此，本题就做完了。

## 代码
实现细节，参见代码注释 (代码在 std 的基础上改的，原谅我懒得打（捂脸））

```cpp
#include<bits/stdc++.h> 
using namespace std;

inline int read()//快读
{
	register int x=0;
	register char ch=getchar();
	while(ch<'0'||ch>'9')
    {
		ch=getchar();
	}
	while(ch>='0'&&ch<='9')
    { 
		x=(x<<1)+(x<<3)+ch-48;
		ch=getchar();
	}
	return x;
} 

const int maxn = 1<<18|5;//这里 |5 其实就是在 1<<18 的情况下加 5，因为 1<<18 后面一大块都是 0
int T,n,k,a[maxn],b[maxn],c[maxn];
//a 数组是实力数组；b 数组记录了赢家在 a 数组的下标，便于我们获取，也是我们归并的数组
//c 数组是归并排序的辅助数组

int merge(int l,int r)//这里是主归并，返回值是这里面有几个赢家
{
	if(l == r)//如果只有一个人，那么赢家肯定是自己
	{
		return 1;
	}
	int mid = (l+r)>>1;
	int tl = merge(l,mid)+l-1//左半边的归并，tl 是左半边的上界，所有赢家都储存在 [nl,tl] 中，(t1,n2)是无意义信息
	int tr = merge(mid+1,r)+mid;//同理，是 [nr,tr]
	int nl = l,nr = mid+1;//这里是访问下界
    
    //由于归并到此处的时候，左半边的有意义部分是有序的，所以从小到大来删除那些一定会输的就可以了
	if(a[b[nl]] < a[b[nr]])//如果左边的第一个小于右边的第一个，那么右边整块肯定都比左边大，右边就不需要比较了
	{                  //这个地方用小于号，因为等于的时候我们可以裁决，所以可能打得过
		while(nl <= tl && a[b[nl]] + k < a[b[nr]])//这里是为了删去那些打不过(右边最小的人)的人
		{
			nl++;
		}
	}
	else//同理，反之左边不需要比较
	{
		while(nr <= tr && a[b[nr]] + k < a[b[nl]])//更新到可以打得过
		{
			nr++;
		}
	}
	int top = l-1;//这里的top+1，也就是 l 是 c 数组的存放起点，因为后面都是 ++top 存的
	while(nr <= tr && nl <= tl)//这里是一个归并排序的过程
	{
		if(a[b[nl]]<a[b[nr]])
		{
			c[++top] = b[nl++];
		}
		else
		{ 
			c[++top] = b[nr++];
		}
	}
	while(nl<=tl)//把剩下还没有移过去的移过去
	{
		c[++top] = b[nl++];
	}
	while(nr<=tr)
	{
		c[++top] = b[nr++];
	}
	for(int i = l;i <= top;i++)//最后，把 c 数组的移动回来
	{
		b[i] = c[i];
	}
	return top-l+1;//这里是返回有多少个人赢了，两端都是闭区间长度要+1
}

int main()
{
	int T = read();
	while(T--)//主程序
    {
		n = 1<<read();
		k = read();
		for(int i = 1; i <= n; i++)
        {
			a[i] = read();
			b[i] = i;//这里的 b 数组原始状态下保存的都是自己
		}
		
		int t = merge(1,n);//t 是最后一次合并的上界，[1,t]中保存的就是所有可能赢的人
		
		bool flag = false;
		for(int i = 1; i <= t; i++)
		{
			if(b[i] == 1)//
			{
				puts("Kotori");
				flag = true;
				break;
			}
		}
		if(!flag)
        {
			puts("Yoshino");
		}
		
	}
	return 0;
}
```
### 后记

考试的时候想了两个小时的贪心，一直没做出来，考完试才做出来

为毒瘤出题者点赞！！！
