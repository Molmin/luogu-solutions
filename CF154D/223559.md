### $\text{Difficulty : 2400}$
---
尝试用 $\text{SG}$ 函数硬推，感觉有点玄乎，有问题还请指出。

---
### 解题思路：

首先转化问题。其实 $x_1$ 和 $x_2$ 到底是多少并不重要，真正重要的是 $x_2-x_1$，也就是两者之间的位移，注意这是有符号的，不妨设 $d=x_2-x_1$。

每一次操作，无论是先手玩家还是后手玩家，都是从 $d$ 中减去任意一个 $x\in[a,b]$。

那么就根据这个构建一个 $\text{SG}$ 函数，不妨设这个函数为 $g_i$，表示 $d=i$ 的时候的情况。显然有：$g_0=0$。但如果只是这样似乎不太好设计平局的情况，尝试做出一点改动：令$g_x=-1$ 其中 $x<0$，定义 $-1$ 出现且仅出现在 $\text{MEX}(a)$，$a$ 是一个集合，且这个集合中存在 $-1$ 且不存在 $0$，可以这样理解，如果 $0$ 会尽量取 $0$，让自己得到胜利，否则只能退而求其次，也就是找平局。

然后每一个人能取到的范围是 $[i-a,i-b]$，也就是说 $g_i=\text{MEX}(g_{x})$，其中 $x\in[i-a,i-b]$。

---
此时发现，如果 $a$ 和 $b$ 异号，会出现环，似乎不太好处理，不妨直接特殊地考虑一下。

在这种情况下每一个人都是可以选择停留在原地的，那么如果某一个距离 $d$ 在一个玩家看来能够获胜，在另一个玩家看了也一定能够获胜，只是取决于谁先手。

所以要不然就是玩家一一开始就能获胜，要不然就是平局。

---
然后就能正常地推导下去了，最后可以得到：

$\begin{matrix}\underbrace{-1,\cdots,-1}\\<0\end{matrix}\ 0 \ \begin{matrix}\underbrace{-1,\cdots,-1}\\(0,a-1]\end{matrix}\  \begin{matrix}\underbrace{1,\cdots,1}\\ [a,b] \end{matrix}  \ \begin{matrix}\underbrace{-1,\cdots,-1}\\ (b,a+b) \end{matrix} \ 0 \cdots$

接下来又是这样的循环（注意上面范围的开闭），每一个循环节的长度为 $a+b$，所以直接取模然后对应位置即可，当为 $0$ 的时候即为后手必胜，$-1$ 平局，$1$ 先手必胜。

如果 $a$ 和 $b$ 都是负的，同样满足以上的规律，不过循环的方向是向左，不太好理解。

但是可以发现，如果将两者的符号都取反，并将两者的位置交换，也就得到了和之前类似的结果，可能会简单一点。

---
最后还要求输出第一步的移动情况，如果是 $a,b$ 异号的情况，那么直接移动到对应的位置就好了，否则的话需要移动到上面对应 $0$ 的位置就行了。

注意符号取反的时候移动的位位移也要取反，而且输出的是坐标。

---
### 代码：

```cpp
#include<cstdio>
using namespace std;
int x,y,a,b,d,swap=1;
int main(){
	scanf("%d%d%d%d",&x,&y,&a,&b);
	d=y-x;
	if(a<0&&b<0){a=-a;b=-b;d=-d;swap=-1;}
	if((a<=d&&d<=b)||(b<=d&&d<=a)){
		printf("FIRST\n");
		printf("%d\n",x+swap*d);
		return 0;
	}
	if((a<=0&&b>=0)||(a>=0&&b<=0)){
		printf("DRAW\n");
		return 0;
	}
	if(d<0){
		printf("DRAW\n");
		return 0;
	}
	d%=(a+b);
	if((a<=d&&d<=b)||(b<=d&&d<=a)){
		printf("FIRST\n");
		printf("%d\n",x+swap*d);
		return 0;
	}
	if(d==0){
		printf("SECOND\n");
		return 0;
	}
	printf("DRAW\n");
	return 0;
}
```


