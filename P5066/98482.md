[在我的个人博客中阅读以获得更佳阅读体验](https://www.macesuted.cn/article/lg5066/)

---

[题目链接](https://www.luogu.com.cn/problem/P5066)

## 题意

维护一个长为 $n$ 的 0/1 序列 $a$，有 $m$ 个操作：

1. `1 l r`：把区间 $[l,~r]$ 的数变成 $0$。
2. `2 l r`：把区间 $[l,~r]$ 的数变成 $1$。
3. `3 l r`：$[l,~r-1]$ 内所有数 $a_i$，变为 $a_i$ 与 $a_{i+1}$ 按位或的值，这些数同时进行这个操作。
4. `4 l r`：$[l+1,~r]$ 内所有数 $a_i$，变为 $a_i$ 与 $a_{i-1}$ 按位或的值，这些数同时进行这个操作。
5. `5 l r`：$[l,~r-1]$ 内所有数 $a_i$，变为 $a_i$ 与 $a_{i+1}$ 按位与的值，这些数同时进行这个操作。
6. `6 l r`：$[l+1,~r]$ 内所有数 $a_i$，变为 $a_i$ 与 $a_{i-1}$ 按位与的值，这些数同时进行这个操作。
7. `7 l r`：查询区间 $[l,~r]$ 内的元素和。

强制在线。

$n,~m \le 3 \times 10^6$

## 分析

我们显然无法使用平衡树直接维护每个点的单点信息，因为题目中给出的操作对于区间中的每一个元素均与它两边的元素进行了运算，难以直接维护每个单点的信息。

所以我们考虑将原序列拆分为一些区间，使之可以较方便地处理题目中给出的这些操作。

一个比较显然的想法是将原序列拆分为若干段同色的极长段。比如将 $0,~1,~1,~0,~0,~1$ 划分为 $[0]~[1,~1]~[0,~0]~[1]$。容易发现这样划分之后，如果一个操作覆盖了某一个区间，我们可以方便地计算出该操作对该区间的影响：

1. 1 操作： 所覆盖的 1 区间均变为 0 区间。
2. 2 操作： 所覆盖的 0 区间均变为 1 区间。
3. 3 操作： 所覆盖的 0 区间右端点 $-1$，所覆盖的 1 区间左端点 $-1$。
4. 4 操作： 所覆盖的 0 区间左端点 $+1$，所覆盖的 1 区间右端点 $+1$。
5. 5 操作： 所覆盖的 0 区间左端点 $-1$，所覆盖的 1 区间右端点 $-1$。
6. 6 操作： 所覆盖的 0 区间右端点 $+1$，所覆盖的 1 区间左端点 $+1$。

同时，由于我们需要在下放标记前计算出某个询问区间对应的元素和，所以我们需要保证每一个区间均为极长区间，也就是不能让空区间留在平衡树中。

由于在整个过程中于平衡树上出现的区间数量是 $O(n+m)$ 级别的，所以我们可以在每个平衡树结点上记录其子树内最短的 0/1 区间的长度，在该长度达到 0 时暴力地向下搜索找到空区间并删除，对于每个空区间我们需要花费 $O(\log n)$ 的时间复杂度，因此总共花费在删除空区间操作上的时间是 $O((n+m)\log n)$ 级别的，可以接受。

根据上面提到的方法维护平衡树即可。

## 代码

[View on GitHub](https://github.com/Macesuted/Code/blob/main/Luogu/5066.cpp)

编写代码用时 3h，调试用时 2h，使用指针版 FhqTreap，由于卡常使用了内存池并省去了回收内存操作。

下面是一些注意事项和建议：

1. 写代码时务必多画图，仔细考虑每一个操作的边界情况。（即操作区间的左右端点所在区间是否需要被修改的情况）
2. 由于代码较长建议每写完几个操作就进行简单的测试以检验其正确性。
3. 如果 WA 并且找不到显然的错误，可以在每次操作结束后输出整棵平衡上的所有区间的信息，配合手动模拟或是暴力代码测试几组数据。
