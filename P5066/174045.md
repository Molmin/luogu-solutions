从当初听说 @万万没想到 神仙切了这题，到跟 @ClCN 的风立下 flag，写了三天到现在终于 A 了……泪目啊。写篇题解加加 rp。

首先大概做法不用我多说了吧，就是用平衡树去手写珂朵莉树，然后维护一大堆东西，打标记等等。

~~然后你听到这里估计还是一脸懵逼。~~

首先大概思想是像上面那样的，12 操作比较简单就不讲了，讲 3456 操作。

然后你就会发现是没法做的因为与和或完之后的结果与两边的两个段的颜色都有关……这就没法搞了。所以我们规定：相邻的两个段的颜色一定不能相同。

这样你就发现这几个操作的本质是：

3：左端点在 $[l+1,r]$ 内的 $1$ 段的左端延伸一格。

5：右端点在 $[l,r-1]$ 内的 $1$ 段的右端收缩一格。

这样。

这样就可以打标记实现，记录 $1$ 段左右端点伸长了多少格。

但是这样有时可能会把有些段给缩没掉，然后就会出锅。这个时候 dfs 一下找到一个 长度为零的段删掉然后合并两边的段就行了。最开始有 $O(n)$ 个段，然后每次 12 操作只增加 $O(1)$ 个段，所以这样暴力删段最多只会出现 $O(n)$ 次，所以复杂度是对的。

然后还有一个问题，就是 12 操作由于要保证段是极长的，所以要把两边连着取出来然后分类讨论。

下面讲一下实现方法以及细节问题。

首先考虑我们要维护哪些东西。和肯定是要维护的，然后最好要维护一下节点代表的区间的左端点和右端点。由于打标记时要快速更新区间和所以维护一下 $1$ 段的个数（我傻了维护了两种段分别的个数）。打标记时不好更新最短的段的长度，所以分别维护两种段最短的长度。然后方便分类讨论可以再去维护一下左右端点的颜色。就这些了。

再就是细节问题。查询的时候要把区间端点所属的段都取出来，然后看要不要减掉一些。

区间赋值的时候要把 $l-1$ 和 $r+1$ 所属的段一起取出来，然后使劲分类讨论看要不要合并。注意特别讨论一下 $l=1$ 和 $r=n$ 的情况。

最头痛的就是 3456 操作……这里以 3 操作为例，首先如取出来的段最左边是 $1$，就要再在左边取一段，因为不然的话这个段的右端点就没有被修改。然后右边如果是 $0$，就要删掉，不然的话这个右端点就会收到影响。

就是这样了……改时限以后根本不需要卡常，我开 O2 交了两遍就过了，是目前最短解~~然而是第二慢~~。

代码嘛……就先不放。有问题的可以私信找我要。什么时候如果洛谷学术环境好了可能会放上来吧。

然后……就这样了，应该就没什么问题了。

最后纪念一下，洛谷用户 @FZzzz 于 2020-04-20 12:04:53，AC [Ynoi2014]人人本着正义之名。