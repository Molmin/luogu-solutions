**2020年2月14日更新：修复题解排版问题**

--------

题目中要求最后结果的最大值，所以此题采用**贪心**算法。

想要求最大值，就要让 $(C+R)/2$ 尽可能大，就是要让 $C+R$ 的值尽可能大，那么如何做到这一点呢？

我们举个例子：

设有四个 $R$ 分别为 $R_{1}$、$R_{2}$、$R_{3}$、$R_{4}$，初始的速率是 $C$。

按顺序算每个 $R$。

得到最终速率为 $((((C+R_{1})/2+R_{2})/2+R_{3})/2+R_{4})/2$。

拆开括号化简得到：$\frac{C}{16}+\frac{R_{1}}{16}+\frac{R_{2}}{8}+\frac{R_{3}}{4}+\frac{R_{4}}{2}$。

我们观察发现：

**如果我们想要最终速率最大，我们就要使 $\frac{R_{1}}{16}+\frac{R_{2}}{8}+\frac{R_{3}}{4}+\frac{R_{4}}{2}$ 最大**。

显然，当 $R_{1}<R_{2}<R_{3}<R_{4}$ 时，这个式子有最大值。

那么我们推广到一般情况：

**当 $R_{1}<R_{2}<R_{3}<...<R_{N-1}<R_{N}$ 时，最终速率最大！**

我们要使所有的 $R$ 符合上面这个条件，这就是我们的贪心策略。

怎么做到呢？

排序啊！

把所有的 $R$ **从小到大排序**，然后按顺序把每个 $R$ 和 $C$ 运算一遍，就能得到最大的最终速率。

 AC 代码如下：
 
 ```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
int main(){
    int n,k;   
    scanf("%d%d",&n,&k);
    //读入n和k
  
    double r[n],c=0; 
    for(int i=0;i<n;i++)
        scanf("%lf",&r[i]);
    //读入每个r[i]
                         
    sort(r,r+n);  //排序，sort默认从小到大排序
    for(int i=n-k;i<n;i++)
        c=(r[i]+c)/2;   //运算
    printf("%0.6lf\n",c);   //输出
    return 0;
}
```
