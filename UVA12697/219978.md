这是一道较为基础的单调队列题。

### 1. 朴素思路的产生

题目需要求出最短的，元素之和大于等于 $X$ 的连续子序列的长度。既然提到了连续子序列之和，我们很容易想到通过**前缀和**之差来表示。对于每个 $i$， 我们可以将其作为子序列的结尾位置，寻找最短的，符合要求的子序列。

### 2. 贪心思想与单调栈

对于在 $i$ 处结尾的子序列，其元素和可以用 $Si-Sj$ 表示。我们想要找到在满足 $Si-Sj \ge X$ 的情况下，尽量大的 $j$。显然，我们希望  $Sj$ 尽量小（这样子序列的和会大），同时 $j$ 尽量大（这样子序列会尽量短）。

如果存在 $j, k$，在满足 $j>k$ 的同时有 $Sj \le Sk$，那么我们就可以彻底丢弃$Sk$。因为对于在 $i$ 处结尾的子序列，选 $j+1$ 处作为子序列的开头**一定优于**以$k+1$ 处作为子序列的开头（不仅和更大，而且子序列更短）。我们在循环的过程中可以使用**单调栈**来维护 $Sj$。当我们处理完 $i$，将 $Si$ 入栈时，我们只需不断弹出栈顶大于等于 $Si$ 的 $Sj$（这些 $Sj$ 可以被彻底丢弃）即可。

那么，对于在 $i$ 处结尾的子序列，我们通过二分查找，可以找到满足 $Si - Sj \ge X$（即满足 $Si - X \ge Sj$）的最大的 $j$。而 $i-j$ 就是在 $i$ 处结尾且满足要求的最短子序列的长度。

这么做的时间复杂度显然为 $O(NLogN)$。

### 3. 单调队列优化

虽然上面的做法已经可以应对题目给出的数据规模。然而我们还可以进一步进行优化。对于 $Sj$，如果 $Si - Sj \ge X$，那么事实上 $Sj$ 将永远不会再被考虑。因为子序列 $j$ ~ $i$ 已经能够满足题目要求。对于任何大于 $i$ 的数 $k$，即便序列 $j$ ~ $k$ 也能满足题目要求，其长度必定大于序列 $j$ ~ $i$。

我们可以将单调栈优化为单调队列。对于在 $i$ 处结尾的子序列，我们不断从队首弹出 满足 $Si - Sj \ge X$ 的 $Sj$（这些 $Sj$ 将永远不会再被考虑），直到队列为空，或者队首的 $Sj$ 不能满足 $Si - Sj \ge X$。最后一个弹出的 $Sj$ 对应的下标 $j$ 即为所求。

这样，每个 $j$ 最多入队一次，出队一次，整个算法时间复杂度为 $O(N)$。

### 4. 代码实现

```c++
#include <iostream>
#include <cstdio>
using namespace std;
#define MAXN 500005
int T, n;
long long X;
long long sum[MAXN];
int pos[MAXN], head, rear;
int main()
{
    scanf("%d", &T);
    while (T--)
    {
        scanf("%d %lld", &n, &X);
        long long s = 0, a;
        int ans = n + 1;
        sum[0] = 0, pos[0] = -1;
        head = 0, rear = 1;
        for (int i = 0; i < n; i++)
        {
            scanf("%lld", &a);
            s += a;
            // 不断弹出队首符合要求的Sj
            while (head < rear && s - sum[head] >= X)
            {
                // i - j即为所求，顺便更新答案
                if (ans > i - pos[head])
                    ans = i - pos[head];
                head++;
            }
            // 不断弹出队尾大于等于Si的Sj
            while (head < rear && sum[rear - 1] >= s)
                rear--;
            // Si以及对应的下标i入栈
            sum[rear] = s, pos[rear] = i;
            rear++;
        }
        printf("%d\n", ans <= n ? ans : -1);
    }
	return 0;
}
```
