这个题目，个人认为，不需要拓扑，直接dfs寻找能否在无环的前提下从单个点通过一条路径经过所有的点就可以了  
只上核心代码  
link邻接矩阵  
vis表示当前dfs搜索的路,  
返回值0是优先判断矛盾,  
而1则包括两种情况1.寻找到有效路;2.不能判断关系;  
那么在没有环的情况下，每次回溯之前都要先把vis[u]改为0，而cnt记录的经过的点，不满足条件时回溯前要去掉当前点（cnt--）  
一旦cnt==n，也就意味着大功告成了，保持cnt的值回溯，在全图无环的情况下，跳出dfs并输出结果
（其实后面都是证明，写算法的时候没考虑这些XD）
```cpp
int dfs(int u){
    cnt++;
    vis[u]=1;
    for(int i=1;i<=n;i++){
        if(link[u][i]){
            if(vis[i]||(!dfs(i))) return 0;//0 找到环
        }
    }
    vis[u]=0;
    if(cnt==n) {
    	ans[++t]=u;//记录字母顺序
        return 1;
    }//1 找到所有点 也就意味着此时所有点都在路里面
    cnt--;
    return 1;
}
```