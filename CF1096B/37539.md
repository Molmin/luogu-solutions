先将给定的字符串分类  

1. 首尾字符不同  
2. 首尾字符相同  

这两种类型的字符串用不同方法做  

----

首先，对于任意的字符串，由于需要删去的是子串，必须连续，所以最后剩下的要么是空串，要么一定含有最左边或最右边的字符，也就是说，最后剩下的只有3种情况，空、若干与首字符相同的字符、若干与尾字符相同的字符  
（题目保证至少2种字符）

----

然后按照上面的分类来看：  

#### 1.首尾字符不同

举个栗子

> 7  
> aacdeee

根据前面的说法，中间的`cd`必须删去，于是可以简化成  

> 5  
> aaeee

要求所有字符相同，所以最后要么剩下`a`，要么为`e`

- 当剩a时，为`aa`，`a`，所有`e`都要删，由于要连续，所以第一个一定留，也就是有2种情况（2删，2不删）。可以发现，有$n$个`a`时方法数一定为$n$

- 剩e时同理

- 最后加上空串

总结一下，方法数一定是两种字符数之和加一，可以自己验证一下


#### 2. 首尾字符相同 

栗子  

> 4  
> abaa

显然，中间的其他字符必须删去

然后来看左半部分（以中间的其他字符为基准，下同）  
有2种情况，即`a`删或不删  

看右边  
有3种情况（显然，不细说了）

似乎有一点规律？

假设某侧有$n$个`a`，可以删去$[0,n]$任意个字符，也就是有$n+1$种删法  
两侧都一样，于是相乘即可，同时注意，这里包括了空串的情况，不用加  

----

最后，注意答案要取模，~~血的教训~~

```cpp
#include <bits/stdc++.h>
using namespace std;
int main() {
    int n;
    string s;
    cin >> n >> s;
    if (s[0] == s[n - 1]) {
        char t = s[0];
        long long c1 = 1, c2 = n - 2;
        while (s[c1] == t) { ++c1; }
        while (s[c2] == t) { --c2; }
        c2 = n - c2;
        cout << (c1 + 1) * c2 % 998244353 << endl;
    } else {
        long long c1 = 1, c2 = n - 2;
        while (s[c1] == s[0]) { ++c1; }
        while (s[c2] == s[n - 1]) { --c2; }
        cout << (c1 + (n - c2)) % 998244353 << endl;
    }
    return 0;
} 
```

