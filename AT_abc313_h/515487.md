蒟蒻第一篇题解，写得不好/有误请见谅。

[原题传送门](https://atcoder.jp/contests/abc313/tasks/abc313_h)
[洛谷传送门](https://www.luogu.com.cn/problem/AT_abc313_h)

### 题意

有 $2n+1$ 个人要拍照，其中 $n$ 个人在第一排，身高为 $a_1,a_2,...,a_n$，$n+1$ 个人在第二排，身高为 $b_1,b_2,...,b_{n+1}$。

定义一种方案是好的当且仅当以下条件成立：

* $b_1>a_1$。
* $b_i>a_i$ 或 $b_i>a_{i-1}$，其中 $2\le i\le n$。
* $b_{n+1}>a_n$。

求有多少将 $a$ 重排的方案，使得可以将 $b$ 重排后得到一组好的方案。

* $n\le5000$。
* $a_i,b_i\leq10^9$，且任意 $a,b$ 元素不相等。

### 解法

挺神的 dp 题，但官方题解有些地方讲得不好（可能是我太菜了），我来做点补充，同时也参考了一下。

首先，转换一下条件。

令 $c$ 为一个长度为 $n+1$ 的序列，满足：

$$c_i=\begin{cases}a_1,i=1\\
\min\{a_{i-1},a_i\} ,2\leq i\leq n\\
a_n,i=n+1
\end{cases}$$

显然当且仅当把 $b$ 重排后满足任意 $c_i<b_i$ 的方案是好的，这又等价于 $b,c$ 升序排列后满足 $c_i<b_i$。若有 $c_i>b_i$，则满足大于 $c_i$ 的 $b_i$ 只有 $n+1-i$ 个，而 $c_i$ 有 $n+2-i$ 个，显然无论如何排列都不成立。以下默认 $c$ 已经升序排列。

对于一个 $a_i$，它作为 $c_i$ 当且仅当它比 $a_{i-1}$ 更小，也就是比 $a_{i-1}$ 更早加入。$c_{i+1}$ 同理。

所以，考虑从小到大找到 $a$ 中元素的位置。

设 $dp_{i,j}$ 是填完前 $i$ 个元素，共有 $j$ 个**连续段**的方案数。记录 $j$ 这一维是为了方便看出更新的 $c_k$ 是否满足要求。

填 $a_{i+1}$ 时，有以下三种情况：

* $a_{i+1}$ 在一个连续段的左或右侧，$dp_{i+1,j}\leftarrow  dp_{i+1,j}+dp_{i,j}\times 2\times j$。
* $a_{i+1}$ 将两个连续段连接起来，$dp_{i+1,j-1}\leftarrow dp_{i+1,j-1}+dp_{i,j}\times (j-1)$。
* $a_{i+1}$ 新建一个连续段，$dp_{i+1,j+1}\leftarrow dp_{i+1,j+1}+dp_{i,j}\times (j+1)$。因为后面的操作会唯一确定 $a_i$ 的位置，所以实际上只用分插到哪两个连续段的中间或者开头、结尾，有 $j+1$ 种方案。

然后再考虑限制，在 $a_{i+1}$ 被填前面已经有 $i+j$ 个被确定的 $c$ 中的元素。先将 $b$ 升序排序，同样分三种情况：

* $a_{i+1}$ 在一个连续段的左或右侧，此时新确定了 $c_{i+j+1}=a_{i+1}$，要比 $b_{i+j+1}$ 小，即 $a_{i+1}<b_{i+j+1}$。

* $a_{i+1}$ 将两个连续段连接起来，此时没有新确定的元素，就是没有限制。

* $a_{i+1}$ 新建一个连续段，此时 $c_{i+j+1}=c_{i+j+2}=a_{i+1}$ 要分别小于 $b_{i+j+1},b_{i+j+2}$。注意到 $b_{i+j+1}<b_{i+j+2}$，所以限制相当于 $a_{i+1}<b_{i+j+1}$。可以和第一种情况整合。

答案就是 $dp_{n,1}$，初值自然是 $dp_{0,0}=1$。

时空复杂度 $O(n^2)$。

顺便说一句，建议评紫。

### 代码
其实还挺短的。代码中 $p$ 表示连通块的变化量。
```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int mod = 998244353;
int n, dp[5005][5005], a[5005], b[5005];
signed main(){
    cin >> n;
    for(int i = 1; i <= n; i++)
    	cin >> a[i];
    for(int i = 1; i <= n + 1; i++)
    	cin >> b[i]; 
    sort(a + 1, a + n + 1);
    sort(b + 1, b + n + 2);
    dp[0][0] = 1;
    for(int i = 0; i < n; i++)
    	for(int j = 0; j <= i; j++)
			for(int p = -1; p <= 1; p++){
				if(p + j <= 0 || p + j + i > n + 1) continue;
				if(p >= 0 && b[i + 1 + j] < a[i + 1]) continue;
				int l;
				if(p == -1) l = j - 1;
				else if(p == 0) l = 2 * j;
				else l = j + 1;
				(dp[i + 1][j + p] += dp[i][j] * l) %= mod;
			}
    cout << dp[n][1];
    return 0;
}
```