# 前言：

~~本蒟蒻的第一篇题解，瑟瑟发抖......~~


言归正传，这道题其实还有一个思路好像没有提到，就是不去考虑周期，
直接在每一步里都上循环一步步模拟，并且通过取模运算实现少分两类的目的。

（亦不失为一种新的思路，~~虽然会慢很多就是了~~。）


------------



### 简单来说就是这样的：利用取模运算，在移动距离前乘上一个表示移动方向的参数。

- 其中对于横向移动，其移动距离表达式为：

```cpp
int n,x; 
scanf("%d", &n);
//定义 n 为时间，x 为 x 轴坐标。

x+=n*(2-n%4); 
//当余数为 1 时，参数值为 1 ，而当余数为 3 时，参数值为 -1。
```

- 而对于纵向移动，其表达式为：


```cpp
int n,y; 
scanf("%d", &n);
//定义 n 为时间，y 为 y 轴坐标。

x+=n*(n%4-1); 
//当余数为 2 时，参数值为 1，而当余数为 0 时，参数值为 -1。
```
这样，就可以利用取模运算判定移动的正负方向，从而达到少分两类的目的啦。





# AC 代码：


```cpp
#include<bits/stdc++.h>
using namespace std;
int n[101], x=0, y=0;//定义 x,y 坐标。
int main(){
	int t; scanf("%d", &t);
	for(int i=1;i<=t;i++) scanf("%d", &n[i]);
	for(int i=1;i<=t;i++){ for(int e=1; e<=n[i]; e++){//双循环模拟每次的移动，此为精髓所在。
            if (e%2==1) x+=e*(2-e%4);//利用取模功能判断 x 轴移动正负。
            else y+=e*(e%4-1);//同上，只不过是 y 轴。
        }
        printf("%d %d\n", x, y);//依据题意输出坐标。
        x=0; y=0;//清零 x,y 坐标。
    }
    return 0;
 } 
```

最后，希望各位大佬能多多指教进步空间~~~