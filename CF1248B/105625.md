### CF1248B

有$n$个木棍，从$(0,0)$点开始，每次你可以选一根木棍平行于$x$轴或$y$轴的摆，但不能有连续两个或以上的木棍是选择同一状态的（只能横竖横竖或竖横竖横地摆）。每次木棍摆的起始位置是上一根木棍的结束位置，问最后一条木棍的终点距离$(0,0)$点最远的距离的平方最大是多少。

###### 这是一道比较经典的数学问题（
首先我们发现无论这几根木棍怎么摆，总长度一定是相等的，在这个前提下，我们要求出的最大值是将这些木棍分为两组，这两组的和的平方的和。因为无论怎么分，都可以将摆的木棍平移，使所有的木棒成为一个没有斜边的直角三角形，而我们就要使斜边的长度最大，就要用到一个数学推论：
- 对于$a+b=k(k$为定值$)$，要使$(a^2+b^2)$尽可能大，则$|a-b|$尽可能小。

这样的话，我们只需要将最短的$\lfloor \frac{n}{2} \rfloor$个木棍放在一条边，最长的$\lceil \frac{n}{2} \rceil$个木棍放在一条边，这样就能保证斜边最大。

代码记得排序然后注意一下上下取整（~~其实不需要~~），对了！还要介绍一个函数：

~~sort（误~~
```
pow(x,a);
```
其中$x$为底数，$a$为指数，可计算出$x^a$的值。

code：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int n,a[100010],tot=0,ans=0;
signed main ()
{
    scanf("%lld",&n);
    for(int i=1;i<=n;i++)
    scanf("%lld",&a[i]);
    sort(a+1,a+1+n);
    for(int i=1;i<=n/2;i++)
    ans+=a[i];
    tot+=pow(ans,2);
    ans=0;
    for(int i=n/2+1;i<=n;i++)
    ans+=a[i];
    tot+=pow(ans,2);
    printf("%lld",tot);
    return 0;
}
```
##### The End--2019/10/24 21:03