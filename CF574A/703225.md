## 题目大意
`Limak`参加竞选，为了赢得竞选，他要贿赂投票的市民。

现在给出参加竞选的人数、`Limak`的票数以及其他人的票数。

求`Limak`至少需要几颗糖果才能赢得选举。

这里要补充一下：输入第二行的第一个数据是`Limak`的票数

## 题目解法
这是一道比较水的题目，策略就是一直贿赂给当前票数最高的人投票的市民，每次贿赂一位，直到`Limak`的票数是最高的为止。

实现方法可以每次贿赂完都用`sort`排一遍序，由于这道题的数据比较水，所以不会超时。但是这样复杂度太高了。

这里我用的是另外一种方法，就是用优先队列`priority_queue`。这是C++里的一种数据结构，在头文件`queue`里，它有两种类型，一个是大根堆（默认是大根堆），一个是小根堆。（详细介绍可以自行百度）

这里我们用到的是大根堆，它有一个特性，就是它会把最大的数据放在最前面。所以我们可以用的这个特性，省去每次排序。具体用法看参考代码。

### 参考代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a,z,ans;
int main()
{
    priority_queue<int>p;//定义一个int类型名字为p的大根堆
    cin>>n>>z;//z是Limak的票数，我们单独读入，方便后面使用。
    for(int i=2;i<=n;i++){
        cin>>a;
        p.push(a);//push是将数据放入到p中
    }
    while(z<=p.top()){//top指的是队列中的第一个数据(在这里是最大的)
        int maxn=p.top();//代表的是当前最高票数的人
        p.pop();//pop是将队列的第一个数据删除。
        p.push(maxn-1);//贿赂了一位市民那个人的票数就少了一票
        ans++;//贿赂的人数加1
        z++;//Limak的票数加1
    }
    cout<<ans;
}
```
