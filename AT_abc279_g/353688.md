没有场切，wtcl。赛后看到了一个很妙的题解，于是来记录一下。

## 思路

设 $dp_{i,1/2}$ 表示到第 $i$ 个位置，**最后 $k-1$ 个**（如果不够就算全部）中有 $1/2$ 种颜色的方案数。

首先思考一下，为什么要用 $k-1$ 个而不是 $k$ 个作为状态？这样其实是为了更好地转移。对于一个位置 $i$，如果我们知道了 $i$ 的选择和 $i-1$ 的最后 $k-1$ 个的颜色个数，就能知道 $i$ 的最后 $k$ 个的颜色个数。但是如果只知道 $i-1$ 的最后 $k$ 个的颜色个数，放到 $i$ 这里来，$i-k$ 的颜色已经不算做 $i$ 的颜色个数里了，就会出现问题（比如 $i-k$ 是 $i-1$ 的最后 $k$ 个唯一的颜色）。

对于 $dp_{i,1}$，有如下的转移：

$$dp_{i,1}=C+\sum\limits_{j=1}^{i-k+1} \left( dp_{j,1} \times (C-1) + dp_{j,2}\right)$$

解释一下。首先一种方案是最后 $i$ 个都为一种颜色，方案数为 $C$。否则**枚举最后一个不相同的位置 $j$**。如果 $j$ 的最后 $k-1$ 个为一种颜色，则 $j+1$ 的颜色（它的颜色即为后面到 $i$ 所有的颜色）可以是剩下的 $C-1$ 种（颜色不能相同，因为枚举限制了不相同）。如果 $j$ 的最后 $k-1$ 个有两种颜色，则 $j+1$ 只能选择这两种颜色了。而 $j$ 一定是这两种的一种，所以 $j+1$ 只能是另一种。

对于 $dp_{i,2}$，有如下的转移：

$$dp_{i,2}=\sum\limits_{j=i-k+2}^{i-1} \left( dp_{j,1} \times (C-1) + dp_{j,2}\right)$$

可以发现它的转移和上面的转移类似。思路仍然是枚举最后一个不相同的位置 $j$。因为这一段要有两种颜色，所以枚举的范围变成了 $i$ 前面的 $k-1$ 个位置。转移的意义等与上面相同。

转移时需要使用前缀和优化，复杂度为 $\mathcal O(n)$。

最后的答案即为两种情况之和，$dp_{n,1}+dp_{n,2}$。

## 代码

```cpp
#include<bits/stdc++.h>
#define int long long
#define mod 998244353
using namespace std;
int n,k,c;
int dp[1000010][3],sum[1000010][3]; // 到 i 最后 k-1 个颜色个数为 1/2 的方案
signed main()
{
	cin>>n>>k>>c;
	dp[1][1]=c%mod,dp[1][2]=0;
	sum[1][1]=c%mod,sum[1][2]=0;
	for(int i=2; i<=n; ++i)
	{
		dp[i][1]=(c+(i-k+1<=0?0:sum[i-k+1][1]*(c-1)+sum[i-k+1][2]))%mod;
		// c 为全都为一个颜色，否则枚举最后一个不同的位置
		// 如果这个位置前面只有一种颜色，那么这个位置加一的颜色（即为后面所有颜色）有 c-1 种
		// 如果这个位置前面有两种颜色，那么这个位置加一的颜色只有两种选择，而它不能和前面的相同，所以只有一种
		dp[i][2]=((sum[i-1][1]-sum[max(i-k+1,0ll)][1]+mod)*(c-1)+(sum[i-1][2]-sum[max(i-k+1,0ll)][2]+mod))%mod;
		// 这里同理，枚举最后一个不同的位置，区别是枚举的范围
		sum[i][1]=(sum[i-1][1]+dp[i][1])%mod;
		sum[i][2]=(sum[i-1][2]+dp[i][2])%mod;
	}
	cout<<(dp[n][1]+dp[n][2])%mod;
	return 0;
}
```