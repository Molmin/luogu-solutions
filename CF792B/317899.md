## 前言
期末考试后窝又来写题解了！
## 题面
$n$ 个孩子在玩一个游戏。 孩子们站成一圈，按照顺时针顺序分别被标号为 $1$ 到 $n$。开始游戏时，第一个孩子成为领导。 游戏进行 $k$ 轮。 在第 $i$ 轮中，领导会从他顺时针方向下一个孩子开始数 $a_i$ 个孩子。最后数到的那个孩子出局，再下一个孩子成为新的领导。

举个例子， 现在圈内还剩 $[8, 10, 13, 14, 16]$ $5$个孩子，领导编号为 $13$ ， $a_i = 12$。那么出局的孩子为 $16$ 。$8$ 孩子成为下一个领导。

你需要写一个代码模拟这个过程，求出每轮比赛出局的孩子。

第一行包含两个整数 $n$ 和 $k$ $(2 \leq n \leq 100, 1 \leq k \leq n - 1)$。

第二行包含 $k$ 个整数 $a_1, a_2, ..., a_k$ $(1 \leq a_i \leq 10^9)$。

输出 $k$ 个整数，第 $i$ 个整数表示第 $i$ 轮出局的孩子。
## 思路
模拟。
题目中最显眼的就是那个 $(2 \leq n \leq 100, 1 \leq k \leq n - 1)$。很明显，$n$ 只有 $100$，可以直接暴力。

这个暴力可以接受 $\operatorname{O}\left(n^3\right)$ 的超高复杂度，所以做这道题的时候就放下心来。除非你太暴力否则就不会超时。

模拟题，按照我的习惯，我就带着大家讲代码。
```cpp
/* Generated by powerful Codeforces Tool
 * You can download the binary file in here https://github.com/xalanq/cf-tool
 * Author: OI-Master
 * Time: 2020-07-20 14:08:59
 */
#include<bits/stdc++.h>
using namespace std;
#define int long long
signed main(){
    ios::sync_with_stdio(false);
    cin.tie(0);
    int n,k;
    cin>>n>>k;
    int a[k+1];
    for(int i=1;i<=k;++i)
    	cin>>a[i];
```
这里是输入、头文件，和我的一大堆注释。这里说一下一个小要点，如果使用 `#define int long long` 的话，`int main()` 就会被替换成 `long long main()`。可是在标准 C++ 中，`main()` 只能是 `int` 类型。这时候就需要使用与 `int` 同义的 `signed` 才可以避免 CE。
```cpp
int now=1;  
set<int>out;
```
这两行代码是定义两个重要的东西。相信读过题面的同学都可以猜到，$now$ 是现在谁是领导，而 $out$ 是目前谁被淘汰了。
```cpp
for(int i=1;i<=k;++i){       
	int p=now;               
	a[i]%=n-out.size();      
	while(a[i]--){           
		++p;                 
		if(p>n)              
			p=1;             
		while(out.count(p)){ 
			++p;             
			if(p>n)          
				p=1;         
		}                    
	}
```
首先注意一下，这里大的 `for` 循环还没有结束。我们暂时亮出来的只是一部分。

这一部分的意思也是比较明显的。只是把下一个被淘汰的人找出来，存在 $p$ 里面。

要注意一点，$(1 \leq a_i \leq 10^9)$，所以如果你直接一个一个 `next` 肯定爆掉，我们先要把环都 `mod` 一下，这样才能水过这一部分。
```cpp
out.insert(p);        
cout<<p<<' ';         
now=p+1;              
if(now>n)             
	now=1;            
while(out.count(now)){
	++now;            
	if(now>n)         
		now=1;
}
```
这一段话指的是求出下一位领导是谁。在这位淘汰的人后面，可能紧跟的几位同学也被淘汰了，要使用 `while` 跳过。

这一段和上一段均用了一个 `set` 里面的函数 `count()`。它的返回值是 $0$ 或 $1$，表示 `set` 里有没有。与 `s.find(x)!=s.end()` 类似。

搬上 <http://cplusplus.com/> 的解释：

---
**std::set::count**
```cpp
size_type count (const value_type& val) const;
```
*Count elements with a specific value*

Searches the container for elements equivalent to *val* and returns the number of matches.
 Because all elements in a [set](http://cplusplus.com/set) container are unique, the function can only return *1* (if the element is found) or zero (otherwise).
 
 Two elements of a [set](http://cplusplus.com/set) are considered equivalent if the container's [comparison object](http://cplusplus.com/set::key_comp) returns `false` reflexively (i.e., no matter the order in which the elements are passed as arguments).

**Parameters**
- val
  Value to search for.  Member type `value_type` is the type of the elements in the container, defined in [set](http://cplusplus.com/set) as an alias of its first template parameter (`T`).

**Return value**

`1` if the container contains an element equivalent to *val*, or zero otherwise.
 Member type `size_type` is an unsigned integral type.

**Example**
```cpp
// set::count
#include <iostream>
#include <set>

int main ()
{
  std::set<int> myset;

  // set some initial values:
  for (int i=1; i<5; ++i) myset.insert(i*3);    // set: 3 6 9 12

  for (int i=0; i<10; ++i)
  {
    std::cout << i;
    if (myset.count(i)!=0)
      std::cout << " is an element of myset.\n";
    else
      std::cout << " is not an element of myset.\n";
  }

  return 0;
}
```
**Output**
```
0 is not an element of myset. 
1 is not an element of myset. 
2 is not an element of myset. 
3 is an element of myset. 
4 is not an element of myset. 
5 is not an element of myset. 
6 is an element of myset. 
7 is not an element of myset. 
8 is not an element of myset. 
9 is an element of myset. 
```

---
接下来，您已经不知不觉完成了本题！
所以写这道题要以下知识点：
1. 有熟练的代码能力
2. 复杂度分析
3. 调试代码
4. STL 基本运用

## 代码
```cpp
/* Generated by powerful Codeforces Tool
 * You can download the binary file in here https://github.com/xalanq/cf-tool
 * Author: OI-Master
 * Time: 2020-07-20 14:08:59
 */
#include<bits/stdc++.h>
using namespace std;
#define int long long
signed main(){
    ios::sync_with_stdio(false);
    cin.tie(0);
    int n,k;
    cin>>n>>k;
    int a[k+1];
    for(int i=1;i<=k;++i)
    	cin>>a[i];
    int now=1;
    set<int>out;
    for(int i=1;i<=k;++i){
    	int p=now;
    	a[i]%=n-out.size();
    	while(a[i]--){
    		++p;
    		if(p>n)
    			p=1;
    		while(out.count(p)){
    			++p;
    			if(p>n)
    				p=1;
    		}
    	}
    	out.insert(p);
    	cout<<p<<' ';
    	now=p+1;
    	if(now>n)
    		now=1;
    	while(out.count(now)){
    		++now;
    		if(now>n)
    			now=1;
    	}                     
    	/*
    	cout<<' '<<now<<endl;
    	for(int i=1;i<=n;++i)
    		if(!out.count(i))
    			cout<<i<<' ';
    	cout<<endl;
        这一段是我调试的，请忽略。
    	*/
    }
    return 0;
}
```
## 结语
自己 WA 了不少次，结果居然是低级错误呜呜呜。

现在看来，还真的挺简单呢！