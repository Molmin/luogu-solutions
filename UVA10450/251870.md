- 如果你无论是找大佬求助，修改所开的数据范围，更换算法乃至对拍都无法找到错因时，请注意，**每两组询问之间还要有一个换行**，即
     ```cpp
     Scenario #1:
     5

     Scenario #2:
     2
     ```

## 题意简述
- 输入一个数字，代表询问的次数。
- 对于每一次询问，输入一个整数 $ N\ ( N <51)$ 代表某一个由 $0$ 与 $1$ 组成的数字串的长度，规定两个 $1$ 不可以相邻，求该字符串有多少种可能性。



## 解题思路
- 从有 $n$ 位的字符串看起，如果末尾是 $0$ ，说明它可以由任何一个 $n-1$ 位的数字串在末尾添加一个 $"0"$ 得到。
- 而如果末尾是 $1$ ，则它的前一位一定是 $0$ ，$0$ 再前面的一位又可以是任何一个数字，也可以视作是由任何一个 $n-2$ 位的数字串在末尾添加一组 $"01"$ 得到。  
- 所以长度为 $n$ 的字符串数量等于长度为 $n-1$ 与 $n-2$ 的字符串数量之和。不难列出关系式，$f_i=f_{i-1}+f_{i-2}$ ,边界：$f_1=2$ , $f_2=3$。


## 参考代码如下
```
#include<bits/stdc++.h>
using namespace std;
long long f[110];//用long long开数组万无一失
long long t;//询问次数
int main(){
	cin>>t;
	f[1]=2,f[2]=3;//for循环的基础，由枚举得到
	for(long long i=3;i<=60;i++)
	{
		f[i]=f[i-1]+f[i-2];
	}
    //斐波那契数列,求出每种长度的字符串的个数
	long long n;
	for(long long i=1;i<=t;i++){
		cin>>n;
		cout<<"Scenario #"<<i<<":\n"<<f[n]<<"\n\n";
	}
	return 0;
} 
```
