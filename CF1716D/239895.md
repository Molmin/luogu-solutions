## 题意

给出 $n,k$，对于所有在 $[1,n]$ 范围内的 $x$，求出在数轴上用如下走法从 $0$ 走到 $x$ 的方案数：第一步的长度须为 $k$ 的倍数，第二步的长度须为 $k+1$ 的倍数，第三步的长度须为 $k+2$ 的倍数，以此类推。

## 做法

首先这是一个计数类问题，其次这是一个计数类问题，以及对于所有 $[1,n]$ 范围内的 $x$ 都需要求方案数，那么转化一下容易想到用完全背包来解决。

具体一点，就是有 $k,k+1,k+2,\cdots,n$ 这样若干个物品，每个物品都可以拿无穷多次（因为每步可以走其中一个数的若干倍），求填满容量为 $[1,n]$ 的背包的方案数。

但是发现直接套模板做的复杂度最坏是 $O(n^2)$，无法承受。考虑优化。

我们看到由于题目要求，我们的背包里会有一个依赖关系，即必须先拿了 $k$ 才能拿 $k+1$，拿了 $k+1$ 才能拿 $k+2$，因此上面的做法非但时间不对，而且答案错误。

但是建立在这个依赖关系的基础上，可以发现在最坏情况下最多也仅需走 $
\sqrt n$ 步。设当前已走 $m$ 步，最坏情况即当 $k=1$，且每一步都只走 $k+m$ 的一倍时，可以发现有 $1+2+\cdots+m=n$，那么 $m$ 就是 $
\sqrt n$ 级别的数。

因此可以使用完全背包解决。不过需要注意，由于依赖关系的存在，完全背包不能压缩空间，每一个物品的选择取决于上一个物品有没有选。设当前选择到第 $j$ 个物品（费用即为 $w_j=k+j-1$），背包的第 $i$ 个位置，则

$$dp_{i,j}=dp_{i,j}+dp_{i-w_j,j}+dp_{i-w_j,j-1}$$

其中 $dp_{i-w_j,j}$ 表示在当前这步已走过的情况下再走一个 $k+j-1$，$dp_{i-w_j,j-1}$ 表示在当前这步还没走的情况下**在走了上一步的基础上**走一个 $k+j-1$。

## 代码

注意到 DP 只取决于当前位和上一位，使用滚动数组优化。特别要注意边界处理。

```
#include<bits/stdc++.h>
using namespace std;
#define N 200003
#define LL long long
#define INF 0x3f3f3f3f
#define MOD 998244353
int n,k,dp[2][N],ans[N];
int main(){
    scanf("%d%d",&n,&k);
    int nw=k,id=1;  //使用nw记录当前所有物品的费用和（保证复杂度）
    dp[0][0]=1;
    for(int i=k;nw<=n;++i){  //枚举当前物品的费用
        id^=1;
        for(int j=i;j<=n;++j)  //枚举背包位置
            dp[id][j]=(dp[id][j]+dp[id^1][j-i]+dp[id][j-i])%MOD;
        dp[id][0]=0,nw+=i;  //注意边界处理，除了第一步之后的0都不能置为1
        for(int l=1;l<=n;++l){  //因为可以走任意步终止，每次统计答案
            ans[l]=(ans[l]+dp[id][l])%MOD;
            dp[id^1][l]=0;
        }
    }
    for(int i=1;i<=n;++i)
        printf("%d ",ans[i]);
    puts("");
    return 0;
}
```