### Part 1：dp 状态设计与暴力 dp。
由于这一道题中步数和目前到达的位置至关重要，考虑将这两个量设为状态。故设 $f_{i,j}$ 为走了 $i$ 步之后到达 $j$ 的方案数。

根据这个状态，我们不难想到临界状态为 $f_{0,0}=1$，毕竟在最开始时，chip 的位置就在原点上。

考虑一个十分暴力的 dp 转移，对于任意的 $i$ 和 $j$，设 $l$ 为在第 $i-1$ 步时从 $l$ 点出发，能够到达点 $j$ 的坐标。依照题意，$l$ 便满足 $l\in [0,j-(k+i-1)]$，且 $l=j-num\times(k+i-1),num\in\mathbb{N}^+$。设满足以上条件的任意数组成的集合为 $S_{i,j}$，则状态转移方程如下：

$f_{i,j}=\sum_{l\in S_{i,j}}f_{i-1,l}$

这个方法需要我们枚举步数，枚举目前所在的下标，还要枚举出发点，总的时间复杂度为 $\mathop{O(n^3)}$，不能通过本题。

### Part 2：缩小值域优化时空复杂度。

~~貌似我们能走的步数并不会很多，所以考虑从这个地方入手。~~ 设 $m$ 为 chip 可以走的步数，则有下式：

$k+(k+1)+(k+2)+...+(k+m-1)=\frac{(k+k+m-1)\times m}{2}\le n$

当 $k=1$ 时 $m$ 可以取最大值。我们发现 $m$ 的最大值不会超过 $\sqrt{2n}$，也就是说，我们可以把步数的值域缩小到根号级别的，这样时间复杂度就会达到 $\mathop{O(n^2\sqrt{n})}$，还是无法通过本题。

### Part 3：利用前缀和优化时间复杂度。

考虑把原先的状态转移方程拆开：

$f_{i,j}=f_{i-1,j-(k+i-1)}+f_{i-1,j-2\times(k+i-1)}+...+f_{i-1,j-num\times(k+i-1)}$

~~这个状态转移方程好刁钻，貌似不太好用前缀和优化欸。~~

确实，不同于传统的前缀和 $pre_j=pre_{j-1}+a_j$，这一个状态转移方程并非是一步一步转移的，而是以 $k+i-1$ 为一步转移的。这样看似就困难了不少，其实不然。因为当 $i$ 定下来后，$k+i-1$ 是一个定值，就像原来的前缀和公式中，$1$ 是个定值一样。

所以这里我们就可以稍微更改一下前缀和的公式，改成 $pre_j=pre_{j-(k+i-1)}+a_j$。设 $a_j=f_{i-1,j}$，那么我们便可以提前将状态转移右边的那一堆提前利用前缀和预处理出来，这样我们就不用再枚举 $l$ 来进行转移了。$f_{i,j}$ 便等于 $pre_{j-(k+i-1)}$。

时间复杂度为 $\mathop{O(n\sqrt n)}$。

### Part 4：利用滚动数组优化空间复杂度。

然而这一道题还没有做完。$\mathop{O(n\sqrt n)}$ 的空间复杂度是我们接受不了的，观察发现第 $i$ 步的状态只和第 $i-1$ 步有关，所以我们可以利用滚动数组滚掉一维，空间复杂度便能降到 $\mathop{O(n)}$，可以通过本题。

### Part 5：Code
```cpp
#include<bits/stdc++.h>
using namespace std;
const int mod=998244353,MAXN=2e5+5;
void MOD(int &x)
{
	if(x>=mod)x-=mod;
}
int k,n,f[2][MAXN],sum[MAXN],ans[MAXN],pre[MAXN];
signed main()
{
	cin>>n>>k;
	f[0][0]=1;
	int cnt=k,m=0,x=0;
	while(x<=n)
	{
		x+=cnt;
		cnt++;
		m++;
	}
	for(int i=1;i<=m;i++)
	{
		memset(pre,0,sizeof(pre));
		for(int j=0;j<=n;j++)if(j>=(k+i-1))MOD(pre[j]=pre[j-(k+i-1)]+f[(i-1)&1][j]);else pre[j]=f[(i-1)&1][j];
		for(int j=0;j<=n;j++)if(j>=(k+i-1))MOD(f[i&1][j]+=pre[j-(k+i-1)]);//注意数组下标不能为负。
		memset(f[(i-1)&1],0,sizeof(f[(i-1)&1]));
		for(int j=1;j<=n;j++)MOD(ans[j]+=f[i&1][j]);
	}
	for(int i=1;i<=n;i++)cout<<ans[i]<<" ";
}
```
感谢阅读！