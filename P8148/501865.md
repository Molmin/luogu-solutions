## Description

给出**可重集** $S=\left\{ \sum^r_{k=l}a_k|1\leq l \leq r \leq n \right\}$，求原来的 $\{a\}$。

## Solution

### Subtask 1-2

简单模拟一下即可。

### Subtask 3-4

首先对输入的数组 $S$ 进行排序，容易想到，$S_1$ 和 $S_2$ 必定也是 $a_1$ 和 $a_2$，因为这两个元素显然不可能通过两个比它更小的元素相加得到。接下来考虑 $S_3$。

1. $S_3=a_1+a_2$，此时应当略过 $S_3$，继续向后找 $a_3$。
2. $S_3 \neq a_1+a_2$，此时的 $S_3$ 就是 $a_3$。

拓展开来，对于每一个 $S_i$，假设已经找到了 $k$ 个元素，我们要先判断这个数是否是之前已经确定的 $a$ 数组中某段区间的和，如果是，就跳过。不是就加进 $a$ 数组中。那么，如何判断它是否是某个区间的和呢?

暴力枚举区间的左端点和右端点？复杂度为 $O\left(n^2\right)$，算上外层的一个循环和统计直接变成 $O\left(n^4\right)$，会 TLE。即使加上前缀和优化，也还是 $O\left(n^3\right)$，怎么办？用桶。

我们每当找到一个 $a_i$，就扫一遍 $a$ 数组的后缀和，并把桶内当前后缀和的值减 $1$。这样，我们就做到了 $O\left(n\right)$ 预处理，$O\left(1\right)$ 查询了。


------------

- Q：为什么不用前缀和要用后缀和？
- A：前缀和无法处理后缀的和，但后缀和却可以处理任意一段的和。对于区间和 $\sum^r_{k=l}a_k|1 \leq l \leq k \leq r$，它一定会在扫描到 $a_r$ 的时候做 $r-l+1$ 次后缀和得到。

如果还没有搞懂，来看一组数据：
```cpp
6
1 2 3 5 7 8 9 11 14 16 17 20 20 25 27 28 31 40 45 47 48
```
正确输出是```1 2 5 9 11 20```。

如果做前缀和，则前缀和为```1 3 8 17 28 48```。

最后输出的答案为 ```1 2 5 7 9 11```。

注意到了吗？前缀和把 $7$ 这个漏网之鱼给放过去了。

而后缀和呢？（上面一行为后缀和，下面一行为 $a$ 数组）
```cpp
1 2 3 5 7 8 9 14 16 17......
^ ^   ^     ^
1 2   5     9         ......
```
完美解决。

------------

- Q：为什么要把桶内扫到的值减 $1$ 而不是直接赋值为 $-1$？
- A：为了处理有重复元素的情况。

## Code
```cpp
#include<bits/stdc++.h>
using namespace std;

inline int calc(int n){
	return n*(n+1)/2;
}

int n,a[2500000],ans[2005],j;
int h[100005],sum;

int main(){
	cin>>n;
	for(int i=1;i<=calc(n);i++) cin>>a[i];
	sort(a+1,a+calc(n)+1);
	for(int i=1;i<=calc(n);i++){
		h[a[i]]++;//当前数出现过，就把它在桶里面的值加一
		if(h[a[i]]>0){//出现的次数大于不该出现的次数
			ans[++j]=a[i];
			if(j==n) break;
			sum=0;
			for(int k=j;k>=1;k--){
				sum+=ans[k];
				if(sum>100000) break;//最大不应该超过限制，而且不加会 RE
				h[sum]--;//这个元素不应该出现，所以减一
			}
		}
	}
	for(int i=1;i<=n;i++) cout<<ans[i]<<' ';
	return 0;
}
```
时间复杂度 $O\left(n \log n + n^2\right)$，[AC](https://www.luogu.com.cn/record/69238395)。

## Conclusion

看不懂官方题解的过来集合！

敲了一个小时的题解，给个赞吧 qwq。