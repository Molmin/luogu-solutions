# P8148 题解

## 题目大意

给你一个长度为 $n$ 的单调不下降非负整数序列 $a$ 的所有区间和，求原序列 $a$。

## 题目分析

手玩一下样例#2。

```
5
1 3 4 7 8 9 10 11 15 17 18 19 24 27 28
```

注意样例是帮我们排过序的，实际数据点可能无序。

因为 $a$ 单调不下降，所以 $a_1$ 肯定是这些区间和中最小的，那么 $a_1=1$。

把 $a_1$ 舍弃，剩下的数中要不然包含 $a_2$ 要不然包含比 $a_2$ 大的数，所以说此时 $a_2$ 最小，那么 $a_2=3$。

把 $a_2$ 舍弃，剩下的数除了 $a_1+a_2$，肯定 $a_3$ 最小，所以我们可以先找到 $a_1+a_2$，即 $4$，把它舍弃，然后找到当前最小值赋给 $a_3$，所以 $a_3=7$。

把 $a_3$ 舍弃，找到 $a_2+a_3$ 和 $a_1+a_2+a_3$，舍弃，找最小值赋给 $a_4$……

当数据规模扩展到 $n$，我们在寻找 $a_i$ 时，就需要把所有 $a_1$ 到 $a_{i-1}$ 的后缀和舍弃，找到当前最小值赋给 $a_i$。

具体实现可以把所有数先排一下序，要舍弃一个数的话就把这个数加入一个小根堆 $q$，找最小值时用一个指针，如果当前数在小根堆中（注意因为当前数是最小值，所以肯定是堆头），那么指针后移一位，同时把推头 pop 掉，重新寻找最小值。说的不清楚可以看看代码。

瓶颈在于把每个数加入小根堆，时间复杂度 $O(n^2\log n)$。

## 代码

```cpp
#include<cstdio>
#include<algorithm>
#include<queue>
using namespace std;
int n,m;
int a[2001001],ans[2001];//这里 a 指输入数组，ans 是原数组
priority_queue<int,vector<int>,greater<int> > q;//小根堆
int main()
{
	scanf("%d",&n);
	m=n*(n+1)/2;
	for(int i=1;i<=m;i++)scanf("%d",&a[i]);
	sort(a+1,a+m+1);
	int now=1;
	for(int i=1;i<=n;i++)
	{
		while(!q.empty()&&a[now]==q.top())now++,q.pop();//找最小值
		ans[i]=a[now];
		int sum=0;
		for(int j=i;j;j--)sum+=ans[j],q.push(sum);//计算后缀和，舍弃
	}
	for(int i=1;i<=n;i++)printf("%d ",ans[i]);
	return 0;
}
```

谢谢观看！