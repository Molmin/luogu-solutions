	本题除了预处理有点麻烦，本质就是道裸的01背包
    数据也是真水，二维数组都不会炸,碰巧也没有人写c++二维的背包
    下面上代码：
    #include <bits/stdc++.h>//懒人标配万能头
	using namespace std;
	int f[5005][5005],c[5005],w[5005],e[5005];
    //f存最终结果，w存时间（相当于物品质量），c存每题的奖励（相当于物品价值），e是每个知识点的奖励
	int max(int q,int d){
	return q>d? q:d;
	}//自定义比较函数
	int main()//开始主程序
	{
	int a,b;
	cin>>a>>b;//输入两人的水平值
	int m,n;
	cin>>m>>n;//输入题目的总数m和知识点的总数n
	for(int i=1;i<=n;i++){
		cin>>e[i];
		e[i]*=(b/a);
	}//将老王用的时间转为WKY用的时间（其实就是用老王的时间去除以WKY的时间）
	for(int i=1;i<=m;i++){
		cin>>w[i]>>c[i];
	}//输入每题的知识点(后面会改为每题的所需时间)和每题的奖励
	for(int i=1;i<=m;i++){
		w[i]=e[w[i]];
	}//预处理，将每题所需要的时间存进数组，因为w先存了题目对应的知识点，e又存了每个知识点需要的时间，所以e[w[i]]就是每题的所需时间
	n=m;//先将n改为时间
	cin>>m;//再输入总时间（相当于背包容量）
	for(int i=1;i<=n;i++){
		for(int v=m;v>=0;v--){
			if(v>=w[i])f[i][v]=max(f[i-1][v],f[i-1][v-w[i]]+c[i]);//01背包标准状态转移方程(普及一下，一般带max或min的都是dp，直接赋值的一般是递推)
		}
	}
	cout<<f[n][m];//输出结果（01背包的特点，结果永远存在f[时间][容量]这里）
    return 0;//华丽的结束程序
	}
	已经改三遍了，详细许多了，管理员大大求过啊！！！
