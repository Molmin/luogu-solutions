# 题意
给定一个火柴棒等式，问你能不能在最多移动一根火柴棒的情况下使这个等式成立
# 思路
先读入左边等号前的火柴棒数，记作 $a$，代表第一个加数，再读加号与等号之间的火柴棒个数，记作 $b$,代表第二个加数，最后读和，记作 $c$。

在这里能成立的条件就只有两种：

  - 1、无需移动小棒：$a+b=c$，左右两边无需变动。

  - 2、需要移动一根小棒：

	- 在这种情况中，两边的差必须为 $2$。很好证明：将小的一边的一根小棒移到右边，这时这个等式小的一边多了 $1$，大的一边少了 $1$，这个等式就恒成立了。
    
	- $a+b+2=c$，也就是 $c$ 比 $a+b$ 大 $2$,这种情况也很好处理，只需将 $c$ 的一根小棒移到 $a$。
    
	- $a+b=c+2$，这种情况是不是直接将 $a$ 的一根小棒移到 $c$ 呢？并不是，这里有一处细节，题目中的数据 $1\leqslant a \leqslant 100$，也就是说 $a$ 是可能等于 $1$ 的，在 $a = 1$，的情况下把 $a$ 减去 $1$，$a$ 的位置就空了。所以对于 $a$ 等于 $1$ 的情况，将 $b$ 的一根小棒移到 $c$ 即可。
# code
```c
#include<bits/stdc++.h>
using namespace std;
int a1,b,c;
int main(){
	char ch; 
	while(ch!='+'){ch=getchar(); a++;} //第一个加数
	while(ch!='='){ch=getchar(); b++;} //第二个加数
	do{ch=getchar(); c++;}while(ch=='|'); //和
	a--;b--;c--; //每次统计都会多读一个字符所以需要-1
	if(a+b!=c){ 
		if(abs(a+b-c)^2){ //在a+b!=c且两边的差不等于2就无解
			puts("Impossible");
			return 0;
		}else{
			if(a+b<c){ //只需移动一根小棒的第一种情况，将和的减去1，第一个加数加上1
				a++;
				c--;
			}else{
				if(a^1){ //第二种情况，需要特判
					a--; //如果a不等于1，就把它的1移到c
					c++;
				}else{
					b--; //如果a等于1，移了它就空了，所以把b的1移到c
					c++;
				}
			}
		}
	}
	while(a--) printf("|");	
	printf("+");
	while(b--) printf("|");
	printf("=");
	while(c--) printf("|"); 
	return 0;
}
```

