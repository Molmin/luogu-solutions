### 思路：

这个题目让我们通过画直线来构造正三角形

题目说这个平面无穷大，但是样例图片给的好像不算太大，那我就提供一张比较大的图片吧。

![空白蜂巢](https://cdn.luogu.com.cn/upload/image_hosting/8aomys7e.png)

现在让我们开始画线。

有一点要注意的是：只能沿着正六边形的边画线，也就是说，**直线的方向只有三种**：水平、60°、120°

这是我想出这个题的解的关键。

现在考虑画一条线：

![一条线](https://cdn.luogu.com.cn/upload/image_hosting/zdxrpiv5.png)

很显然，没办法构成任何三角形。

但是，此时水平方向的线的数量由 $0$ 变成了 $1$

接着，第二条线

![两条线](https://cdn.luogu.com.cn/upload/image_hosting/z5euu6fe.png)

第二条线，为了能产生三角形，我们肯定不能平行画，因为这样他们不能相交，情况就和一条线一样了，没办法构成三角形。

那我们就斜着画，方向无所谓，因为这个图片可以看成是**对称的**。

斜着画我们使两条线相交于六边形内部，这样的话就形成了两个黄色的正三角形，如图。

接下来就是三条线的情况了

如图：

![三条边](https://cdn.luogu.com.cn/upload/image_hosting/1vc1sna7.png)

水平方向我们在第一次的时候画过了，120°的线我们在第二次的时候画了，那么60°的线我们就在第三次画。

这样的话，**它能够与我们先前画的两条线都相交**。

还是让这两个交点分别落在两个不同的正六边形里面，于是，对于每一个交点，都**分别产生了两个三角形**，也就是图中的紫色和橙色三角形。

我们发现一个规律：

### 一条直线，每与另外一条直线产生交点时，就会多生成两个三角形

因为蜂巢是无穷大的，因此，我们能够保证每个交点都能位于六边形之内。

为什么要是交点位于六边形之内呢？

因为交点如果在六边形的顶点上，构不成三角形，我们就是在做无用功。

还有一种情况是三个直线相交在六边形里面一点（中心），其实和两个交点的情况是一样的，都是增加了 $4$ 个三角形，因此我们只考虑两两相交的情况。

那么一条线，可以与多少条其他的线相交呢？

**图中已有的且与之不平行的线**

因此三个方向我们轮流划线，这样的话总的交点数最多。

严格证明的数学方法我不是很懂，欢迎补充，但是我们可以通过列举前几次的样例来确保我们的构造方式的正确性。

这样的话，我们就可以预处理出画 $n$ 条线能产生的最多三角形，随着 $n$ 的增大，三角形必定是增多的，因此我们可以二分找出答案。

### 代码实现：

用三个数代表三个方向的直线数量，每次画都从直线数量最少的那个方向画，这样的话，对于当前这一轮能产生的交点数最多，也能保证三个方向的数量只差不超过 $1$ ，三个方向的数量尽量平均，保证了交点总数也是最大的。

也就是说，其实就是贪心地最大化当前步骤的交点数，总体的交点数量就是最大的。

知道了每个方向的直线数量就能很方便的计算出新生的交点数，那么新生成的三角形的个数就是新生成的交点数乘以 $2$

### 上代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int mmax = 1e9+7;
vector<int>tar;
int t,n;
void init()
{
    priority_queue<int,vector<int>,greater<int> >q;
    for(int i=0;i<3;i++) q.push(0);
    int x = 0;
    int sum = 0;
    while(x<mmax)
    {
        tar.push_back(x);
        int mmin = q.top();
        q.pop();
        x += 2*(sum-mmin);
        sum++;
        mmin++;
        q.push(mmin);
    }
}
signed main()
{
    cin.sync_with_stdio(false);
    init();
    cin >> t;
    cin.tie(0);
    while(t--)
    {
        cin >> n;
        cout << lower_bound( tar.begin() , tar.end() , n ) - tar.begin()  << '\n';
    }
    return 0;
}

```
