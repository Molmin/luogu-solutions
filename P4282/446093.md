### [题目传送门](https://www.luogu.com.cn/problem/P4282)

------------

首先拿到这道题，我们看到数据范围和进位制的东西，不难想到高精度去写这道题，就是说在进位或者借位的时候要注意去弄进位制。

熟悉并且做过这道题的童鞋们肯定知道，这道题的难点就在于对 $ m $ 取模对吧，如果我们按照正常的思路，肯定是把每一位变成十进制然后取模然后再转回来，但是这样毕竟有些麻烦，于是我们来思考一下。

那么我们从 $ m $ 上来思考，~~既然这道题出出来了~~，肯定是可以找的 $ m $ 的特殊性的。

我们假设一共有 $ n $ 个数，根据题意，我们不难得到，给的操作数 $ a , b $ 一定是小于 $ m $ 的，所以最后不论是加还是减，肯定是不会大于 $ m \times 2 $ 的，这个不难理解，因此，我们只需要按照正常思路进位到第 $ n + 1 $ 位，然后，我们只输出 $ n $ 位就可做到模 $ m $ 的效果。

主要代码如下:

```cpp
int jz[maxN],a[maxN],b[maxN];
int n;
char op;
void jia(){//加法 
	int x=0;//记录进位数 
	for(int i=n;i>=1;i--){//总共n个进位值，每一个都算一次 
		int t=x;
		x=(t+a[i]+b[i])/jz[i];//进位 
		a[i]=(t+a[i]+b[i])%jz[i];//记住，一定要模 
	}//这里类似于高精度加法 
	for(int i=1;i<n;i++){//因为最后不输出空格，所以到循环到n-1 
		printf("%d ",a[i]);
	}
	printf("%d\n",a[n]);//最后不输出空格 
}
void jian(){//减法 
	for(int i=n;i>=1;i--){
		while(a[i]<b[i]){//这里有个借位的操作，记得留神while 
			a[i-1]--;//借位 
			a[i]+=jz[i];//计算减法 
		}
		a[i]-=b[i];//当不需要进位的时候，就直接减 
	}
	for(int i=1;i<n;i++){
		printf("%d ",a[i]);
	}
	printf("%d\n",a[n]);//27~30行同加法 
}

```