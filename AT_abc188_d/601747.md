# 题目翻译

Snuke 开了一家公司，提供各种各样的服务。并且公司推出了一个称作 Snuke Prime 的会员方案。
在每天的开始，用户可以支付 $C$ 元，购买一天会员资格。拥有会员资格的期间，可以自由使用公司提供的所有服务。
高桥君想要使用这个公司的 $N$ 种服务。使用第i种服务的期间是从第 $a_{i}$ 天的开始到第 $b_{i}$ 天的结束。在没有会员资格的期间，要使用第 $i$ 种服务，每天需要支付 $c_{i}$ 元。
求出高桥君需要支付的最小合计金额。

# 题目分析
1. 利用 map 容器记录每一个服务的起始和结束时间点，将时间点作为 key，每天需要的费用作为 value。

2. 通过改变起始时间点和结束时间点的 value，即在服务开始时增加每日费用，在服务结束后减少每日费用，得到了一个时间-费用变化的映射。

3. 进行遍历处理，对于每一个时间段，比较每日费用和会员费用，选择较小的一个作为该时间段的每日费用。

4. 最后，计算并输出所有时间段的总费用，这就是需要支付的最小合计金额。

总结：这个程序使用了贪心算法的思想，即在每一个时间段都做出在当前最优的选择（选择每日费用和会员费用中的较小者），从而得到全局最优的解（支付的最小合计金额）。同时，它利用了 map 容器方便处理时间和费用的特性，降低了问题的复杂性。


# 满分代码（含详细注释）
```cpp
#include<iostream>
#include<map>
using namespace std;

int n, C; // 定义n和C为整数变量，n代表服务的种数，C代表购买一天会员资格的费用
long long last, sum, ans; // 定义last、sum、ans为长整型变量，last表示上一个处理的时间点，sum表示当前累积的每日费用，ans表示总费用
map<int, long long> s; // 定义一个map，key为int类型，value为long long类型，表示时间点与每日费用的映射关系
map<int, long long> :: iterator it; // 定义一个迭代器，用来遍历map
 
int main()
{
	cin >> n >> C;
	for(int i = 1; i <= n; i++) // 对每一种服务进行处理
	{
		int a, b, c;
		cin >> a >> b >> c; // 输入服务的开始时间、结束时间和每日费用
		s[a] += c; // 在服务开始的时间点，每日费用增加
		s[b+1] -= c; // 在服务结束的时间点的下一天，每日费用减少
		//这两行代码是在进行"差分"操作，常用于优化时间复杂度。
//s[a] += c; 这一行是表示从第 a 天开始，每天的服务费用会增加 c 元。它在 map 中对应 a 时间点增加了 c 的值，表示这一天开始的服务的费用。
//s[b+1] -= c; 这一行表示在第 b+1 天，也就是第 i 种服务结束后的第一天，每天的服务费用会减少 c 元。实际上，这是撤销前面在 a 时间点增加的 c 的费用，因为在 b+1 这一天，第 i 种服务已经结束，不再需要这部分费用。
//使用这种差分的方法，我们可以很方便地知道在任何特定的时间点，每日服务的费用是多少。我们只需要遍历 map，并累加每个时间点的值（包括正值和负值），就可以得到这一天的服务费用总和。
	}

	for(it = s.begin(); it != s.end(); it++) // 遍历整个时间线
	{
		ans += min(sum, 1ll*C) * (it->first - last); // 计算当前时间段的费用，取每日费用和会员费用的较小值，乘以时间段的长度，加到总费用中
		last = it->first; // 更新上一个处理的时间点
		sum += it->second; // 更新当前累积的每日费用
	}
	cout << ans << endl; // 输出总费用
 
	return 0;
}

```
