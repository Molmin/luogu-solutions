精神污染题。。。不过要是用结构体写就还好。

括号平衡显然可以代数化，就把 `(` 当 $1$​ 把 `)` 当 $-1$​​​。考虑点分治，需要计算连通块中每个点到重心、以及重心到每个点的代数和、最小 / 最大前缀和等等信息，可以使用结构体很轻松地更新。如下代码给出了括号序列接上一段括号序列的更新方法：

```cpp
struct Tuple{
	int sum,mx,mn;
	Tuple(int x=0,int y=0,int z=0){sum=x,mx=y,mn=z;}
	friend Tuple operator+(Tuple x,Tuple y){return Tuple(x.sum+y.sum,max(x.mx,x.sum+y.mx),min(x.mn,x.sum+y.mn));}
};
```

然后求最大值不能一阶差分，只能动态更新。考虑当前子树内所有点与之前子树的所有点进行匹配，的所有路径之和。我们先考虑前面的点到当前点这个方向怎么做。枚举当前点 $y$，构成合法括号串当且仅当 $sum_x+sum_y=0$ 且 $\min(mn_x,sum_x+mn_y)\geq 0$。根据前者，由于我们已经知道 $sum_y$，那么唯一的合法 $sum_x$ 可以很轻松解出来，这样 $sum_x$ 也是常数了。对后者，min 的右元是常数可以直接判，左元的话，说明 $x$ 入选必须满足 $mn_x\geq 0$。考虑更新的值 $\max(mx_x,sum_x+mx_y)$，右元是常数，最大化左元的话，容易知道我们只需要对所有 $sum_x=v$ 的 $x$ 求最大的 $mx_x$ 即可，用桶维护即可。

考虑反方向路径？不想分类讨论了，我们可以把重心的儿子序列反过来 CV 一遍就行了。总复杂度线对。