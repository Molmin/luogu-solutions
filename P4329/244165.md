# 算法：状压 $DP$
## 题目大意
有 $n$ 个人选 $n$ 个位置，每个人选每个位置有不同的权值，求一种选择方案使权值之积最大。

## 思路
因为这题的 $n$ 很小，所以我们可以用状压做。$f_{i}$ 表示当任务完成情况为 $(i)_2$ 时的最大成功率。

---
## 一些小问题

- ### $Q$：为什么只要一维就可以完成该题了呢？

- ### $A$：因为我们可以顺序安排任务，而轮到哪一个人只要数 $(i)_2$ 中 $1$ 的个数就可以了。

- ### $Q$：题目中给的是百分数，怎么处理呢？

- ### $A$：我们读入时除以一百，输出时在乘回来就可以了。

---
## code：
```cpp
#include<bits/stdc++.h>
#define ri register int
#define N 25
#define M 1<<20
using namespace std;
int n;
double f[M],a[N][N],ans;
int main(){
	cin>>n; 
	for(ri i=1;i<=n;i++){
		for(ri j=1;j<=n;j++){
			double x;
			cin>>x;
			a[i][j]=x*0.01;//因为题目给的是百分数，所以我们要除以一百使它变为小数
		}
	}
	f[0]=1;//初始化
	for(ri i=0;i<(1<<n);i++){//第一层枚举所有状态
		int cnt=0;
		for(ri x=i;x;x>>=1){
			if(x&1){
				cnt++;
			}
		}//统计已完成任务个数
		for(ri j=1;j<=n;j++){
			if(i&(1<<(j-1))){//如果当前状态完成了该任务
				f[i]=max(f[i],f[i^(1<<(j-1))]*a[cnt][j]);//从未完成该任务的状态转移过来
			}
		}
	}
	printf("%0.6lf",f[(1<<n)-1]*100);//记得乘回来
	return 0;
}

```
