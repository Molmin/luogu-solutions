如何使得所有点位置平均，并且使得原来的点移动的距离最短呢。


首先我们每个点原来有n个，那么我们设此时总长度为1，那么第一个点做原点，距原点距离为$0$。第二个点距原点距离就是 $\frac{1}{n}$ ，第三个点就是$\frac{2}{n}$，一直到$\frac{n-1}{n}$ 。我们加入$m$个点，使得总点数为$n+m$，那么我们平均之后每一个点的位置就跟刚刚一样，$\frac{1}{n+m}$，$\frac{3}{n+m}$，$\frac{3}{n+m}$...，我们如何找到最近的位置让我们原来的点都移动过去呢，很直观的想法是原来每个点是 $\frac{1}{n}$ ,$\frac{2}{n}$...，我们将所有最后应该到达的位置$\frac{1}{n+m}$，$\frac{3}{n+m}$，$\frac{3}{n+m}$...存在$set$里，然后二分`low_bound`找到第一个大于他和第一个小于他的位置，取最小差值即可（直接模拟）。但是这样是不是太麻烦了（而且除以$n+m$之后可能会有精度误差）。我们思考有没有什么方便的操作可以取代二分找最短距离。我们可以除以$n+m$，为什么不乘以$n+m$试试呢，乘以$n+m$以后，总距离变成了$n+m$，使得所有点均匀放置的话我们每个点的最终位置就应该是$1,2,3...n+m$，那么我们最开始的位置从总长度为1的$\frac{1}{n}$，$\frac{2}{n}$变成了$\frac{1*（n+m）}{n}$，$\frac{2*（n+m）}{n}$，这样都变成了总长度为$n+m$的形式。我们发现最终的位置都是整数，这样就有了一个大胆的想法，直接四舍五入不就是一个分数到达整数的最短距离嘛，那么我们最终位置是整数，我们移动的过程就是从分数移动到整数的最短距离，那么我们的答案就利用四舍五入，累加距离，即是最终的答案。

至于代码就非常简单了

```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
#include<cmath>

using namespace std;

int n, m;
int main()
{
    while(scanf("%d%d", &n, &m) != EOF){
        double ans = 0.0;
        for(int i = 1; i < n; ++ i){//一共n-1个点需要移动
            double pos = (double)i / n * (n + m);
            ans += fabs(pos - floor(pos + 0.5)) / (n + m);
        }
        printf("%.4f\n", ans * 10000);
    }
    return 0;
}


```
