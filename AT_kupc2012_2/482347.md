### 这一题呢，我们先来分析一下操作：
+ 首先判断是否有一方将棋盘两端都下了一枚棋子，因为只要出现了这种情况就能把对方连杀。

| 1 | 2 | 3 | 4 | 5 | 6 | 7 |
| -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: |
| o | ~~x~~ | ~~x~~ | ~~x~~ | ~~x~~ | ~~x~~ | o |

或者

| 1 | 2 | 3 | 4 | 5 | 6 | 7 |
| -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: |
| x | ~~o~~ | ~~o~~ | ~~o~~ | ~~o~~ | ~~o~~ | x |

+ 如果没有上种情况，那再看一看先出棋的 `o` 方是否占据了一端。
~~因为先下手为强~~，`o` 方可以在原基础的另一端加上自己的棋子 `o`，这下就会由原本的

| 1 | 2 | 3 | 4 | 5 | 6 | 7 |
| -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: |
| o | x | x | x | x | x | x |

变成

| 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 |
| -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: |
| o | ~~x~~ | ~~x~~ | ~~x~~ | ~~x~~ | ~~x~~ | ~~x~~ | o |

就又变回了上一种形式，又可以消消乐了。

一共就只会有以上的两种情况，因为，总会有棋子占据一边，如果是 `o` 连杀对方就行，是 `x` 只有站两端才能连杀对方，除非就有是由 `o`  收场。

### ACcode:
```cpp
#include <bits/stdc++.h>
using namespace std;
string s;
int main() {
  cin >> s;
  if (s[s.size() - 1] == 'x' && s[0] == 'x') {  //判断x方是否有占据两方。
    cout << "x\n";
  } else {  //不管无论如何也是o赢。
    cout << "o\n";
  }
  return 0;
}
```
好心补充样例：

输入#1
```
xxxooxxoo
```
输出#1
```
o
```

最后说一句，日本题大多都要换行，我直接上 `cout<<"内容（未换行）";` 就会 WA！！！