#### 题意简述

1. 首先要理解：所谓的树是[无根树](https://baike.baidu.com/item/%E6%97%A0%E6%A0%B9%E6%A0%91/10017543?fr=aladdin)。

2. 要求树的直径（通俗理解就是树上最长链）、树的重心（以重心这个节点为根时，最大子树最小）、树的直径的重心唯一。

3. 要求树的重心与树的直径的重心不同。

#### 题目分析

1. 确定这是一个构造题

2. 我们先确定树的直径及其重心：既然树的直径是一条链，那么为了保证树的重心唯一，则直径长必须是奇数，同时确定了重心为链最中间的点。

3. 我们在以这条链为树之时，链的重心即为树的重心。既然直径的重心已经确定了，那么，我们下一步要做到就是让树的重心偏移。

4. 不断向直径重心的右儿子（深度除直径外最小，最容易将重心转移）加儿子（有多少加多少），导致原链的右子树变大，而右儿子的最大子树不变，重心转移。

5. 可行性：为了保证在加儿子操作时，满足要求 $2$ 的唯一性，直径的长要为 $\geq 7$ (首先保证有右儿子，在给右儿子加儿子时，如果右儿子没有孙子，那么直径数量会增加)，然后在加儿子时，必须要加 $2$ 个及以上的儿子才能导致重心发生偏移，所以算法可行的条件是：节点数 $\geq 9$。

代码：
```
#include<cstdio>
using namespace std;
int n;
int read(){
	int x=0,f=1;
	char c=getchar();
	while(c>'9'||c<'0'){
		if(c=='-')f=-1;
		c=getchar();
	}
	while(c<='9'&&c>='0'){
		x=x*10+c-'0';
		c=getchar();
	}
	return x*f;
}
void print(int x){
	if(x<0)putchar('-'),x=~x+1;
	if(x>9)print(x/10);
	putchar(x%10+'0');
}
int main(){
	n=read();
	if(n<9){
		printf("-1");
		return 0;
	}
	print(n);
	printf("\n1 2\n2 3\n3 4\n1 5\n5 6\n6 7\n");
	for(int i=8;i<=n;i++){
		putchar('2');
		putchar(' ');
		print(i);
		putchar('\n');
	}
	return 0;
}
```
谢谢大家！！！