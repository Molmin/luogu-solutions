我其实对用田忌赛马的方法做这道题比较疑惑，不过能这么做的话，应该自有道理，我就不多说了。

我采用的是一种比较奇怪但也很容易理解的方法（以下把 Elsie 简称为 E，把 Bessie 简称为 B）：

前 $N/2$ 轮是谁的牌大谁赢，那就把 E 的牌从大到小排，而 B 的牌要尽可能大，所以从她的牌中选出最大的前 $N/2$ 张牌，然后从大到小排序。

对接下来 $N/2$ 轮也是同样的做法，把 E 的牌从小到大排，把 B 剩下的 $N/2$ 张牌也从小到大排。

排序完了，接下来就是比较。

以前 $N/2$ 轮为例，我的比较方法是：把 B 的第一张牌与 E 的第一张牌比，如果 B 的牌大，就怼掉 E 的牌，然后换下一张；如果怼不掉，就接着用这张牌和 E 的第二张牌比，能怼掉就怼掉，怼不掉再和第三张比……

正确性也是很明显的。当 B 的一张牌与 E 的一张牌比较能怼掉时，有两种情况：B 的下一张牌也能怼掉 E 的这张牌，或 B 的下一张牌怼不掉 E 的这张牌了。

对于第二种情况，很明显这局应该怼，机不可失时不再来，过了这个村就没这个店了，肯定得怼掉。而对于第一种情况，既然 B 的下一张牌能怼掉 E 的这张牌，那 B 的下一张牌肯定也能怼掉 E 的下一张牌，所以不如干脆按顺序来，一个一个怼，亏不了的。

而如果 B 的牌怼不掉 E 的牌，后面的任意一张牌肯定都怼不掉这张牌，所以不如放过它，而且因为 B 的这张牌是目前她有的牌中最大的（前面更大的都怼掉了），价值最高，不妨留到后面，说不定能发挥用处。

对于后 $N/2$ 轮也同理，如果 B 的牌小就怼掉 E 的牌，如果怼不掉就往后顺顺，找机会再怼。

接下来上代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,l,ans,b[50003],e[50003];
bool f[100003];
bool cmp(int a,int b){
	return a>b;
}
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;++i){
		scanf("%d",&e[i]);
		f[e[i]]=true;
	}
	for(int i=n*2;i>=1;--i)
		if(!f[i]) b[++l]=i;
	sort(e+1,e+n/2+1,cmp);
	sort(e+n/2+1,e+n+1);
	reverse(b+n/2+1,b+n+1);
   //以上都是在给双方排序，sort和reverse的用法请自行搜索
	int bl=1,el=1;
	while(el<=n/2&&bl<=n/2){
		if(b[bl]>e[el]) ans++,bl++;
		el++;
	}
   //前N/2轮，能怼就怼，怼不掉就往后顺
	bl=n/2+1,el=n/2+1;
	while(el<=n&&bl<=n){
		if(b[bl]<e[el]) ans++,bl++;
		el++;
	}
   //后N/2轮，规则改变，思路同理
	cout<<ans<<endl;
	return 0;
}
```