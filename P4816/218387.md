首先让我们读懂题意

>现在有$B$与$E$在玩牌，一共$2n$局，牌的点数是$1$~$2n$，互补重复，前$n$局点数大者胜，后$n$局相反，现在已知$E$先手出牌，试问如何能让$B$获得最高分

读入的话，我们用一个bool型数组记录，然后读入完后遍历一遍，顺便排序，代码如下

```cpp
for(int i=1;i<=n;i++)
{
	cin>>a;
	b[a]=false;//如果e出了这张牌，b不可能拥有
	e_[now2++]=a;//将这张牌记录进e所拥有的牌中，now2表示e数组中现在牌放到哪里了
}
```
转换为数字

```cpp

for(int i=n*2;i>=1;i--)
{
	if(b[i])b_[now++]=i;//如果b有这张牌，记录进去
}
    
```

接着该怎么办呢？

如果一个一个查找，每次最快(用二分)也要$O(\logn)$才能查找出来，我们需要更快怎么办？

类似于田忌赛马的思想，我们先把$B$,$E$数组前后段分别排好序然后逐一比较，拿前半部分举例，如果$B$目前的数小，那么用下一个，否则就用这个数得分。

正确性证明

假设有两个有序上升数列$B$，$E$，且这两个数列没有交集。

假设有情况刚好$B_i>E_j$，设此时不是最优，那么设$B_{i-n}$或$B_{i+n}$与$E_j$配对可以更优，如果用$B_{i-n}$，那么根据条件，比$E_j$小，比原有可获得分数少$1$分，与原有假设不符；若选用$B_{i+n}$，那么$E_{j+n}$中可能存在比$B_i$大而比$B_{i+n}$小的数，此时也会使可获得分数减少，与假设不符。

因此这种算法正确。在打代码时，不仅要知道这个算法是对的，更要知道为什么是对的，知其然，更要知其所以然。

正确代码如下

```cpp
#include<bits/stdc++.h>
using namespace std;
bool b[100010];
int main()
{
	int b_[100010],e_[100010];
	int n;
	cin>>n;
	int a;
	memset(b,1,sizeof(b));
	int now2=1;
	for(int i=1;i<=n;i++)//读入
	{
		cin>>a;
		b[a]=false;
		e_[now2++]=a;
	}
	int now=1;
	for(int i=n*2;i>=1;i--)//将其转换一下，之所以倒着排，因为前半部分用较大数一定比较小数好
	{
		if(b[i])b_[now++]=i;
	}
	int ans=0,bnow=1,enow=1;
	sort(b_+1,b_+n/2+1);
	sort(b_+n/2+1,b_+n+1);//前后段分别排序 
	sort(e_+1,e_+n/2+1);
	sort(e_+n/2+1,e_+n+1); 
	for(int i=1;i<=n/2;i++)//前半部分数的比较
	{
		if((bnow<=n/2)&&(enow<=n/2)&&(b_[bnow]>e_[enow]))//如果没有超过牌的一半并且点数大，就用这牌
		{
			ans++;
			bnow++;
			enow++;
		}
		else if((bnow<=n/2)&&(enow<=n/2))//否则用其他牌抵消，用下一张牌赢
		{
			bnow++;
		}
	}
	bnow=n,enow=n;
	for(int i=n;i>n/2;i--)//因为这里是小的赢，所以从大往小比
	{
		if((bnow>n/2)&&(enow>n/2)&&(b_[bnow]<e_[enow]))//同前
		{
			ans++;
			bnow--;
			enow--;
		}
		else if((bnow>n/2)&&(enow>n/2))
		{
			bnow--;
		}
	}
	cout<<ans;//输出
  	return 0;
}
```

### 代码仅供对拍，请勿直接复制