## 解题思路
本题考虑贪心做法。

首先可以想到位数越小的数作为其他数的子串的概率越大，所以我们可以从较大的数开始考虑。

当 $l$ 和 $r$ 的位数相同时，显然在 $l$ 到 $r$ 中的任何数都不能作为其他在此区间的数的子串，因为其中任意两个不同的数位数相同，而它们不同说明至少有一位上的数字不同。

当 $l$ 和 $r$ 的位数不同时，又要分两类讨论。  
1.$r$ 的最高位为 $1$ 时，假设 $l=12,r=123456$，则大于 $23456$（$r$ 的后五位）的数都能被选，因为从 $100000$ 到 $r$，$r$ 的第二高位并没有轮完一轮 $1$ 到 $9$ 的轮回。  
同理，当 $r=1000001$ 时，大于 $10000$（$r$ 的前五位）的数都能被选。  
还有就是 $l=99999,r=110001$，$r$ 的前五位和后五位组成的数都比 $l$ 小，所以此时能选的数是 $l$ 到 $r$。

2.$r$ 的最高位大于 $1$ 时，此时已经经历了至少一次 $1$ 到 $9$ 的轮回，所以不能选比 $r$ 位数低的数，例如当 $r=234567$ 时能选的数是 $100000$ 到 $r$。

## AC 代码
```cpp
#include <cstdio>
#include <algorithm>
#define int long long
//保险一点开了long long
using namespace std;
int lg[15]; // 用于快速求出n位的最小数即10的n - 1次方
signed main()
{
	int t; scanf("%lld", &t);
	//预处理
	lg[1] = 1;
	for(int i = 2; i <= 12; ++ i)
		lg[i] = lg[i - 1] * 10;
	for(int i = 1; i <= t; ++ i)
	{
		int l, r;
		scanf("%lld%lld", &l, &r);
		int x = l, y = r, s1 = 0, s2 = 0; //s1是l的位数，s2是r的位数
		//求出位数
		while(x) s1 ++ , x /= 10;
		while(y) s2 ++ , y /= 10;
		if(s1 == s2) printf("%lld\n", r - l + 1); //位数相同时
		else
		{
			if(r / lg[s2] == 1) printf("%lld\n", r - max(r % lg[s2], max(r / 10, l - 1)));
			//r最高位是1时                              后s2 - 1位   前s2 - 1 位  l的值
			else printf("%lld\n", r - lg[s2] + 1);
		}
	}
}
```
