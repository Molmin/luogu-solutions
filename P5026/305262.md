## 题意

　　在一个长度为$m$的序列中，每次给一个下标$x$，和一个权值$v$，然后从$x-v*3$到$x-v*2$单调递增，从$x-v*2$到$x$单调递减，从$x$到$x+v*2$再次递增，然后$x+v*2$到$x+v*3$递减，递增递减都是斜率绝对值为1的直线。
## 分析
　　刚学了差分趁现在还没忘赶紧把自己想的写下来
  
　　看到这个其实很容易想到，对于每次修改，将其分为四个区间进行修改，由于它是单调递增的，所以让每个点对应的差分数组加一就行，这样就用到了线段树维护差分数组，但这样还是效率不是很高，我们仍然可以优化，对于同一区间内的每个点与前一个点的差值也是一定的，所以只要修改区间的两端就可以使整个区间内的差值改变，这样两个点的差值就可以构成一个差分数组，然后通过对这个差分数组求前缀和，可以得到每个点与前一个点的差值，再然后更新每个点值的前缀和数组，然后就可以得到这个点的值，输出就行，也就是，差分套差分。

　　其实这个挺简单的，仔细想想也  很容易  ~~困难~~  想得出来

　　最后是关于负数的问题，数组下标是不能为负数的，会$RE$，某大佬的做法是将原点左移，我试了试也是可以的，后来在洛谷上学习了一篇题解的做法，觉得这个很不错，直接用一个指针来代替数组，其实数组的实质也是指针，比如数组$aa_{10}$->从指针$aa$开始往后数10个，所以只要让一个指针指向数组中间就能实现负下标的数组，感觉挺~~实用~~ 好玩。
　
```
#include<cstdio>
const int N=2e6;//记得开大点，不然会被一些极大的数据RE掉
int aa[N<<1],bb[N<<1];
int main(){
    int *a=aa+N,*b=bb+N;
    int m,n;
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++){
        int v,x;
        scanf("%d%d",&v,&x);
        a[x-v*3+1]++;
        a[x-v*2+1]-=2;
        a[x+1]+=2;
        a[x+v*2+1]-=2;
        a[x+v*3+1]++;
    }
    for(int i=-40000;i<=40000+m;i++)
        a[i]+=a[i-1],b[i]+=b[i-1]+a[i];
    for(int i=1;i<=m;i++)
        printf("%d ",b[i]);
    return 0;
}
```
 

 

