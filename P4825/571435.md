[题目传送门](https://www.luogu.com.cn/problem/P4825)


# 题目大意


一头奶牛从 $(1,1)$ 到 $(r,c)$，要求数字和现在的不相同且每次要走到比现位置的行和列都要大才能算合法。

求一头牛按合法地跳跃使自己到 $(r,c)$ 的方案数。

# 思路

拿到这个题，看到 $R$ 和 $C$ 都是 $\le1000$，脑子里便蹦出来暴力，准备用四层循环，时间复杂度为 $n^{\smash{4}}$ 最多为 $1$ 亿，并不会爆时间。可以使用暴力，那就很简单。


我们使用四层循环暴力解法，枚举从哪开始跳，用 $i$ 就表示行，用 $j$ 就表示列，再枚举这头奶牛跳跃到哪里，用 $s$ 就表示跳跃到的行，用 $k$ 就表示跳跃到的列。

有这样的思路，那么 $\mathit{f}_{i,j}$ 就表示跳到 $i$ 行 $j$ 列有多少种方案。

初始化：$\mathit{f}_{1,1}=1$

表示跳到 $1$ 行 $1$ 列有 $1$ 种方案，那就是不跳。

状态转移方程：$\mathit{f}_{s,k}=\mathit{f}_{s,k}+\mathit{f}_{i,j}$。

因为 $\mathit{f}_{i,j}$ 能跳到 $\mathit{f}_{s,k}$，所以 $\mathit{f}_{s,k}$ 应加上 $\mathit{f}_{i,j}$ 的方案数。

注意：$s$ 应从 $i+1$ 开始枚举，$k$ 应从 $j+1$ 开始枚举，因为跳到的行和列一定要比现在的行和列都大才算合法！

代码很丑，勿喷。

# 代码


```cpp
#include<iostream>
using namespace std;
int r,c,k;
int a[110][110],f[110][110];
int main(){
	cin>>r>>c>>k;
	for(int i=1;i<=r;i++)
		for(int j=1;j<=c;j++)
			cin>>a[i][j];
	f[1][1]=1;
	for(int i=1;i<=r;i++) 
		for(int j=1;j<=c;j++)
			for(int s=i+1;s<=r;s++) //枚举奶牛位于 (i,j) 能跳到的行。
				for(int k=j+1;k<=c;k++) //枚举奶牛位于 (i,j) 能跳到的列 。
					if(a[i][j]!=a[s][k]){//判断数字是否一样。
						f[s][k]+=f[i][j];
						f[s][k]%=1000000007;
					}
	cout<<f[r][c];//答案存在 f[r][c]。
	return 0;
}
```


债见。