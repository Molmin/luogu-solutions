####  $   $ $  $数据范围水，直接暴力递推就能过。

#### $   $ $  $ 设$f[i][j]$表示从起点到第$i$行,第$j$列的格子合法跳跃的方案数。

#### $   $ $  $ 根据题意知，每次应该至少向右跳一格，向下跳一格，那么当牛在第$i$,$j$个格子时（不包括在起点）,它上一次所在的格子一定是在$1$ ~ $i$-$1$,$1$ ~ $j$-$1$之内的。

#### $   $ $  $ 所以，就可以直接把$1$ ~ $i$-$1$, $1$ ~ $j$-$1$的所有格子全都枚举一遍，如果第$i$,$j$个格子上的数与这个格子上的数不一样，那么就说明上一次可能在$f[i][j]$加上这个格子的方案数，即
	
   $f[i][j]$ $+$ $=$  $f[k][l];$
   
#### 其中$k$,$l$分别表示上一次所在格子的行与列。

#### 最终，答案为$f[r][c]$。注意：边界为$f[1][1]=1;$ 累加时要取模。


#### 复杂度O(N^4),是不会TLE的(~~暴力是最好的算法~~)。


#### 下面送代码：
```
#include <iostream>
using namespace std;
const int mod=1e9+7;
int a[1010][1010];//存入每个格子上的数
long long f[1010][1010];
int main()
{
	int n,m,x;
	cin>>n>>m>>x;
	f[1][1]=1;//边界，因为从起点到起点方案数为1
	for(int i=1; i<=n; i++)
	{
		for(int j=1; j<=m; j++)
		{
			cin>>a[i][j];
			for(int k=1; k<i; k++)//暴力枚举
			{
				for(int l=1; l<j; l++)
				{
					if(a[k][l]!=a[i][j])
					{
						f[i][j]=(f[i][j]+f[k][l])%mod;//注意取模
					}
				}
			}
		}
	}
	cout<<f[n][m];
	return 0;
}
```






 