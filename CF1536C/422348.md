## 这是一道黄题？确实！
## 题目传送门
戳[这里](https://www.luogu.com.cn/problem/CF1536C)
## 分析
这道题标准来讲呢他是动态规划的分组问题，能写出方程

$$f_i=\max{f_j}+1$$

$f_x$表示到 $x$ 能划分多少组

相当于这一刀划在 $i$ 上一刀划在 $j$ ，1到$j$ 内满足题目且1到 $i$ 满足要求然后自然 $i$ 到 $j$ 这段区间j就满足要求了，然后就可以 $dp$ 了。
我们举个例子：

![例子1](https://cdn.luogu.com.cn/upload/image_hosting/vp2r4t8u.png)


比如说第一次划到 80:32 比值是 5:2，第二次滑倒 100:40，比值还是 5:2，那么两者相减，20:8，比值依然没变，所以验证了这个方程是正确的。

### 所以怎么选呢？

![选法](https://cdn.luogu.com.cn/upload/image_hosting/k86deztz.png)

如图，划到第 $i$ 段，比值是 2:1，前面有 3 个$j$比值都是 2:1，分别是 $j_1\ j_2\ j_3$ 那肯定选 $j_3$ 喽，因为 $j_3$ 包含了 $j_1\ j_2$ 

这可能给你感觉像什么决策单调啊，长的式子啊，什么的，那为什么要用一个数组去存这个 $f$ 呢？直接用一个 $map$ 不就完了吗？那 $map$ 怎么存比例呢？如下:
```cpp
map<pair<int,int>,int>m;
```

第一个 $pair$ 可以存储比值并且当作关键字进行查询。多好啊！
**STL万岁**

## 代码
代码还要给吗？
这里给个核心部分吧：
```
for(i->n)
	if(s[i]=="0")
		nD++;
	else
		nK++;
	make_pair<nD/gcd,nK/gcd>
cout<<++m[nD/gcd,nK/gcd]
```
望通过，谢谢
