蒟蒻来发一个新的解法：

假设输入中没有相同数字，那么我们可以直接贪心从小到大排序。

但是因为输入中可能出现相同数字，所以直接贪心会产生错误。

例如：20 30 30 20 40 20，直接贪心是20 20 20 30 30 40，结果为2，但是20 30 40 20 30 20的结果更优，结果为3。

所以我们就需要把重复的去掉重新再做，一直到所有数取完。这里有一个简单的方法就是计数排序。

还是举20 30 30 20 40 20，我们首先把所有的数先放进一个数组：

![404](https://cdn.luogu.com.cn/upload/image_hosting/m17m71uh.png)

接下来每次从1到1000扫描一遍，找到非0的点记录其个数，再将其个数减1，直到所有的点都为0是停止。

这样既可以保证取的数是有序的，又可以保证答案最大，~~代码又非常短~~。

我们令数据个数为n，所有数的最大值为m，则此程序的复杂度在所有数相等时达到O(nm)最大,因为这2个数的积最大为1000000，所以不会超时，~~而多数情况下是跑不到这个时间的~~ 。

代码如下：
```pascal
var n,i,s,t,x,sum:longint;
f:array[0..100001] of longint;
begin
readln(n);
for i:=1 to n do
  begin
  read(x); inc(f[x]);    //记录每一个数出现的次数
  end;
while s<n do
  begin
  t:=0;                 //取的数个数归零
  for i:=1 to 1000 do      //枚举每个值的数
    if f[i]>0 then        //如果这种数没有取完
      begin
      inc(t);          //增加取的个数
      dec(f[i]);            //将其个数减一
      end; 
  s:=s+t;            //记录总个数
  sum:=sum+t-1;         //记录高兴次数
  end;
writeln(sum);       //输出结果
end.
```

PS:在CF的数据下，此程序最慢的一个点跑了31ms，可以说是比较快了。