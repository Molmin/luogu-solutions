**本篇题解讲解较为细致，大佬可略过**

### 题意

初始状态 $1\sim N$ 的一个序列，执行 $M$ 个翻转区间操作 $K$ 次。

### 算法1

暴力翻转，时间复杂度 $O(NMK)$ 。 
期望得分：$20$ 分。

### 算法2

我们来仔细观察一下翻转变换，来看一下样例执行第一次的结果：

![](http://study.xndxfz.com/wp-content/uploads/2020/03/批注-2020-03-01-172104.jpg)

一次执行有两种含义：
1.一次执行后序列的值(废话)
**2.一次执行后位置的变化情况(可以知道一个位置的数在一次执行后会跑到哪个位置)**

上图中的箭头即表示位置的变化情况。

还不理解？让我们再来看看第二次执行：

![](http://study.xndxfz.com/wp-content/uploads/2020/03/批注-2020-03-01-172336.jpg)

这下明白了吧，所以我们可以建立 $b$ 数组，

$b_i$ 表示位于 $i$ 位置的数执行一次后会移动至 $b_i$ 位置。

```cpp
for (int i = 1; i <= n; i++) b[a[i]] = i; //建立b数组,a数组为原序列执行一次后的结果
```

|  $i$  |  1   |  2   |  3   |  4   |  5   |  6   |  7   |
| :---: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
| $b_i$ |  1   |  5   |  6   |  7   |  2   |  4   |  3   |

接下来我们只需要 $O(N)$ 就可以完成一次执行。

时间复杂度 $O(N(M+K)) $。

时间复杂度瓶颈在于 $K$ 过大。

期望得分：$50$ 分。

### 算法3

发现执行是会出现循环的，执行若干次后会变回原数列，

只要出现循环，我们对循环节取模就可以得到最终的序列了，

看起来是一个很好的优化，然而循环节长度其实非常长，甚至远超过 $K$ ，达到了指数级别(之后会证明)。

所以时间复杂度依然是 $O(N(M+K)) $，期望得分：$50$ 分。

### 算法4

虽然算法3得分没有提高，但给了我们一个很好的思路，**找循环**。

整体的循环节长度很长，但我们来考虑下对于每个数的循环节。

我们再来看一下 $b$ 数组

|  $i$  |  1   |  2   |  3   |  4   |  5   |  6   |  7   |
| :---: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
| $b_i$ |  1   |  5   |  6   |  7   |  2   |  4   |  3   |

可以发现有三组循环 $(1\to),(2\to 5 \to),(3 \to 6 \to 4 \to 7 \to)$。

每个数必定都会有且仅属于一个循环，

或者这样理解，把 $i \to b_i$ 看作一条边，每个位置看作点，所有点的入度和出度均为 $1$ 。

因为根据定义可得，一个位置只可能移动至一个位置，是一个一对一映射的关系。

可以看作在图中找环。

我们可以得到所有循环的循坏节长度之和为 $N$ ， $O(N)$  时间就能找到所有循环。

找到循环后简单计算就可以知道全部执行完成后的位置了。

时间复杂度 $O(NM+N)=O(NM)$。

期望得分：$100$ 分。

同时发现整体的循环节长度即为各组循环节长度的最小公倍数，为指数级别。

code：

```cpp
#include <bits/stdc++.h>
#define maxn 200000
using namespace std;

int a[maxn], b[maxn], c[maxn];
bool f[maxn]; //代表数是否已经访问过
int main()
{
	freopen("swap.in", "r", stdin);
	freopen("swap.out", "w", stdout);
	int n, m, k;
	scanf("%d%d%d", &n, &m, &k);
	for (int i = 1; i <= n; i++) a[i] = i;
	for (int i = 1, l, r; i <= m; i++) {
		scanf("%d%d", &l, &r);
		reverse(a + l, a + r + 1);
	}
	for (int i = 1; i <= n; i++) b[a[i]] = i;
	for (int i = 1; i <= n; i++) {
		if (f[i]) continue;
		int p = b[i];
		vector<int> v;  //储存循环节
		v.push_back(i);
		while (p != i) v.push_back(p), p = b[p];
		int q = k % (v.size());
		int sz = v.size();
		for (int i = 0; i < sz; i++) {
			f[v[i]] = true;
			c[v[q]] = v[i];
			q++;
			if (q >= sz) q = 0;
		}
	}
	for (int i = 1; i <= n; i++) printf("%d\n", c[i]);
}
```

### 算法5

算法4前半部分序列翻转用平衡树优化，

时间复杂度 $O(M \log N+N)$。

（当然这题完全不需要）

期望得分：$100$ 分。