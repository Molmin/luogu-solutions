这道题刚入手，我的第一反应就是：~~暴力~~**模拟**!

没啥好说的，直接`reverse` $k$ 遍，**时间复杂度 $\operatorname{O}(nmk)$ ，还似乎吃得消。**

结果我看了看数据范围，就吓得一身冷汗。。。

$k\le 10^9,n\le10^5,m\leq10^2$

这模拟只能**骗到 $20$ 分（以内）啊**？

我于是开始**找规律**，结果啥规律也找不出，对于每个数据，都有不同的规律，**循环节**也不好计算。

那——要不使用**判断循环节**？用哈希判重？

不行。如果循环节**太长了**，就大于 $100$ ，**也会把这算法卡掉**。这个大概是$30-40$分的思路。

欸？能不能一次做**多组**操作？能不能**一次做 $l$ 组**？使得时间复杂度大大降低？

理论上可行。比如说你把这个 $l$ 设成 $10^5$ 以上，效率就会大大提升。

但是，实际上这个算法还是很慢。$O(\frac{nmk}{l})$ 这个复杂度其实还是很高，而且万一这个循环节不在第 $l$ 的整数倍位上，这样还要加上一个 $nml$ 。

其实把 $l$ 设成 $\sqrt{k}$ 这种数，时间复杂度会大大减少，到达 $O(nm\sqrt{k})$这种级别。

既然一次做均匀的 $\frac{k}{l}$ 次操作不行，我能不能做不均匀的操作？**比如对于 $i$ 次，就做 $2^i$ 组操作？能否实现？**

恭喜你，你懂得了这道题要使用**倍增**。

这个**倍增**，顾名思义，就是**成倍增长**。

举个例子：**倍增求`LCA`**。

`LCA`是啥？就是树上**两个点的最近公共祖先。**

然后我们就可以使用**倍增。**

指定两个节点，让你每个节点往上跳$2^i$辈（更准确的说法是每个节点往上$2^i$代祖先），如果碰到了，就可以更加细化，往下继续二分。

推荐做`LCA`模板题嗷。

倍增必要的小工具：

把一个数二进制分解。

首先，可以 $O(1)$ 求出这个数的二进制最高位（也可以不用求，对于$10^9$以内的数据，从$30$往下搜就可以，对于$10^{18}$数量级，$63$往下搜绰绰有余）。

然后让 $i$ 指针往下搜，如果这个数**大于等于**$2^i$，就**减去**$2^i$。顺便让另外求值的那个变量与这个$f[i]$有关联。

我们可以确定一个倍增数组$f[i][j]$，

表示 $a$ 数组在经过了 $2^i$次操作后所生成的新的$a_j$。

然后预处理完成后，就开始二进制拆分。

具体看代码。

```cpp
	in(n,m,k);
	Fu(i,1,n)f[0][i]=i;
	Fu(i,1,m)in(t1,t2),reverse(a+t1,a+t2+1);
	Fu(i,1,30)Fu(j,1,n)f[i][j]=f[i-1][f[i-1][j]];
	Fu(i,1,n)
	{
		int t=k,x=i;
		Fd(j,30,0)
		if(t>=(1<<j))t-=(1<<j),x=f[j][x];
		out(x);
	}
```

