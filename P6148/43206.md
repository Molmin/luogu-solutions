先回顾一下比赛时候的心路历程。

每一个区间翻转，复杂度是$O(n)$，每次有最多$100$次翻转，所以一次操作是$100n$的复杂度，题目中n的范围是$1 \leq n \leq 10^5$，那么每次操作都是$10^7$，而总共要做$k$次，$k$的范围是$1 \leq k \leq 10^9$，如果我们真的做$k$次，必然超时。按照这个数据量，真实操作不能超过100次，否则会有超时的风险。

那么第一反应是是否有循环节？理论上确实有，因为一旦走到一个之前见过的完全相同的局面，再往下走就循环了，一共有$n$个数字，最多走$n!$次肯定能走到一个重复的局面，但是这个循环节太长了。也无法证明100步以内一定会循环。

既然$1 \leq k \leq 10^9$，所以$log_2k$在$30$左右，是符合我们的要求的。所以考虑能否类似倍增的思想，把操作“合并”在一起，设一次操作为$f$，那么在$f$的基础上再做一次$f$，得到$f^2$操作。在$f^2$的基础上再做一次$f^2$，得到$f^4$操作……这样我们依次得到每一个这种$2$的幂次操作，把$k$次操作拆成这些$2$的幂次操作连做的形式，就能在$log$时间内完成。（有同学问我：“老师，你是怎么想到这样做的？”多做点题吧，学过矩阵加速DP的话，思路比较像，就容易想到了）

举个例子，看看样例。
```
7 2 2
2 5
3 7
```
初始序列为
```
1 2 3 4 5 6 7
```
按照题意模拟一轮操作以后，得到
```
1 5 7 6 2 3 4
```
表示原来1到7的序列，经过一轮操作会被换成这样。注意这个序列我们要换一种思路来看，这个序列第二个位置上是5，还可以表示，“操作完以后，原来5位置的数，被写到了2位置。”原来如果5位置就是5，当然可以。但是如果原来5位置上是别的数字，还是把那个位置上的数字拿过来。这是后面算法的关键思路。

继续看，在
```
1 5 7 6 2 3 4
```
基础上，我们再做一轮操作。但是这次我们**不按照题意模拟了**。我们直接把它**平方**。为了方便，我们设这个序列为a序列，下标从1开始。设平方之后的结果是b数组。

因为a[1]是1，表示$b[1]$的位置是原来a[1]上的数，所以b[1]=1

因为a[2]是5，表示b[2]是a[5]，所以b[2]=2

因为a[3]是7，表示b[3]是a[7]，所以b[3]=4

以此类推，我们可以求出来b数组，即操作两轮以后的序列是

```
1 2 4 3 5 7 6
```

这和直接按照题目模拟翻转来翻转去得到的结果是一样的！看明白了么？

所以我们在
```
1 2 4 3 5 7 6
```
的基础上，再平方一遍，就能得到操作4遍的结果是什么，然后再把4遍的结果平方一遍，得到8次操作的结果。其实这个结果也可以看成是一种规则，即对于一个原始数组，按照一个规则走一遍，得到一个结果数组。之前我们的原始数组和规则是同一个，但是不是同一个完全可以。

再举一个例子，我们想知道$k=3$的时候的结果。我们已经知道了一步的结果是：（为了方便设为f[1]）
```
1 5 7 6 2 3 4
```
然后做两遍的规则是：(为了方便设为f[2])
```
1 2 4 3 5 7 6
```
那么把f[1]当做原始数组，f[2]当成规则，在f[1]上应用一次f[2]，

因为f[2]的第1个数字是1，所以f[3]的第1个数字是f[1]的第1个数1

因为f[2]的第2个数字是2，所以f[3]的第2个数字是f[1]的第2个数5

因为f[2]的第3个数字是4，所以f[3]的第3个数字是f[1]的第4个数6

以此类推，可以得到f[3]，即三次操作的结果是：
```
1 5 6 7 2 4 3 
```
可以看到，和我们暴力模拟3次的结果是一样的。

因此，我写了一个函数用来做一次运算：

```cpp
//计算从a数组，根据rule的规则，返回运算的结果
vector<int> trans(vector<int> a, vector<int> rule) {
    //定义一个vector来装结果，0位置空着不用，所以申请n+1的长度，初始都给0
    vector<int> ans(n + 1, 0);
    for (int i = 1; i <= n; ++i) {
        //结果的i位置是原数组的rule[i]位置上的数
        ans[i] = a[rule[i]];
    }
    return ans;
}
```

第一个问题解决了。我们再来看第二个问题，如何进行k次运算？这里的算法类似于快速幂，如果不懂快速幂请移步先学习一下。写一个init函数，来计算一次运算出来的规则，存在一个vector里面，这个就按照题意模拟就行，初始化一个1到n的序列，然后模拟m次翻转操作。

```cpp
vector<int> init() {
    vector<int> a(n + 1, 0);
    for (int i = 0; i <= n; ++i) {
        a[i] = i;
    }
    for (int i = 0; i < m; ++i) {
        for (int x = l[i], y = r[i]; x < y; ++x, --y) {
            swap(a[x], a[y]);
        }
    }
    return a;
}
```

之后定义一个变量base等于一轮的规则，即init的结果。定义一个a数组表示目前为止的结果。然后看k的最末位，如果是1，在结果上应用一次base，然后base自己平方，再把k除以2，整体看起来特别像快速幂

```cpp
vector<int> a;
    for (int i = 0; i <= n; ++i) {
        a.push_back(i);
    }
    vector<int> base = init();
    while (k) {
        if (k & 1) {
            a = trans(a, base);
        }
        base = trans(base, base);
        k >>= 1;
    }
```

总的代码如下：
```cpp
#include <iostream>
#include <vector>
#include <cstdio>
#include <algorithm>

using namespace std;
int n, m, k, l[105], r[105];

vector<int> init() {
    vector<int> a(n + 1, 0);
    for (int i = 0; i <= n; ++i) {
        a[i] = i;
    }
    for (int i = 0; i < m; ++i) {
        for (int x = l[i], y = r[i]; x < y; ++x, --y) {
            swap(a[x], a[y]);
        }
    }
    return a;
}

//计算从a数组，根据rule的规则，返回运算的结果
vector<int> trans(vector<int> a, vector<int> rule) {
    //定义一个vector来装结果，0位置空着不用，所以申请n+1的长度，初始都给0
    vector<int> ans(n + 1, 0);
    for (int i = 1; i <= n; ++i) {
        //结果的i位置是原数组的rule[i]位置上的数
        ans[i] = a[rule[i]];
    }
    return ans;
}

int main() {
//    freopen("swap.in", "r", stdin);
//    freopen("swap.out", "w", stdout);
    cin >> n >> m >> k;
    for (int i = 0; i < m; ++i) {
        cin >> l[i] >> r[i];
    }
    vector<int> a;
    for (int i = 0; i <= n; ++i) {
        a.push_back(i);
    }
    vector<int> base = init();
    while (k) {
        if (k & 1) {
            a = trans(a, base);
        }
        base = trans(base, base);
        k >>= 1;
    }
    for (int i = 1; i <= n; ++i) {
        cout << a[i] << endl;
    }
    return 0;
}
```