考虑一个问题，每个点只会向编号大于它的点连边。

那么也就是说，从 $i$ 到 $j$ 的路径上**只会**经过编号大于等于 $i$ 且小于等于 $j$ 的点。

那么这个时候处理不经过 $i$ 的最短路就很好说了。

所以说可以找一个点 $k$ 它连着 $w$ 使得 $k < i$  且 $w > i$，答案就是 $dis_{1,k} + dis_{w,n} + 1$。

因为边上点编号差最多为 $m$ 所以可以从 $i-m$ 开始枚举。

最短路就用 BFS 解决就可以了（因为每条边边权都是 $1$）。

最后复杂度是 $O(n \times m)$ 的，代码实现很简单，就不放了。