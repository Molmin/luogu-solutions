### 题目大意
$M$ 和 $J$ 在 $n$ 堆石子轮流取任意数量的石子， $M$ 先手。如果当前玩家取的是第 $i$ 堆，那么下一个玩家就要从第 $i\bmod n + 1$ 堆中取石子。并且石子堆的堆数始终保持为 $n$ ，即取完该堆石子后，该堆石子也不会被移走。哪个玩家面临没有石子可取的情况就输掉比赛。
### 解题思路
如果 $n$ 为奇数时， $M$ 将在前 $n$ 轮拿奇数位置的石子，$J$ 则需要在第 $n+1$ 轮中拿 $1$ 号堆的石子。因此 $M$ 只需要在第 $1$ 轮把第 $1$ 堆的石子全部拿走即可保证必胜。  
如果 $n$ 为偶数时， $M$ 将一直拿奇数位置的石子， $J$ 一直拿偶数位置的石子，为了保证拿的次数尽可能的多，所以要保证每次拿的石子尽可能少，即每次都只取 $1$ 个。因此只需要找出数组中的最小值 $minn$ ，并且找到第一个等于 $minn$ 的 $a_i$ ，如果 $i$ 为奇数，则 $J$ 必胜，反之则 $M$ 必胜。
###  代码实现
```
void solve()
{
    cin >> n;
    for(int i=1;i<=n;i++)
    cin>>a[i];
    if(n&1)
    cout<<"Mike"<<endl;
    else
    {
        int minn=*min_element(a+1,a+1+n);
        int p;
       for(int i=1;i<=n;i++)
        {
            if(a[i]==minn)
            {
             p=i;
             break;             
            }
        }
        if(p&1)
        cout<<"Joe"<<endl;
        else
        cout<<"Mike"<<endl;
    }
}