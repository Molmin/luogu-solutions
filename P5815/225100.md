这是一道被冷落的蓝题？其实这道题在贪心算法中有一样的题目，只不过数据不同导致正解算法不同，二分算法，楼上大佬讲得很好。~~我也不自取其辱了~~，我这里提供一种带点贪心思想的暴力算法，虽然没过，但是我也想借题解区各位~~同学~~大佬，帮忙想想有没有优化。而且作为题目，我觉得我这个部分的写法也是值得参考的，题解区应该不差我这个位置吧~~逃~~。
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
ll s[100];
int main()
{
	ll i,n,m,ans=0;
	cin>>n>>m;
	for(i=1;i<=n;i++)
	cin>>s[i];
	sort(s+1,s+1+n);//让少的在前，多的在后，先放着最少的，用 joker替代最小的
	while(m)
	{
		for(i=2;i<=n;i++)
		s[i]--;
		ans++;
		m--;//每次取一副， joker就-1，ans就+1
		sort(s+1,s+1+n);//重新排序
		if(s[1]==0&&s[2]==0)
		break;//如果有两堆牌没了就不可了，
	}
	ans+=s[1];//如果joker用完了，那就还可以凑最少的那堆牌的整副牌
	cout<<ans;
 	return 0;
}

```
代码，写完了，名人不说暗话：70分，时间复杂度O(mlogn+nm)->O(m)因为m≤5×10^8，n≤50，所以时间达到了10^10自然是过不了的，但是，这里有一些优化方案供大家参考：

一、while中的sort可以用插排替代，最坏的时间复杂度为O(n),但一般不会达到，如果达到了，那么后面的时间就会低

二、每一次的减牌，可以不只-1。               我们这里要先了解，虽然m很大，但是n却很小，所以，s[ ]的跨度会很大，如果跨度小，那么暴力肯定能接，如果跨度大，利用这一点，就可以节省很多时间。所以每一次可以减去s[2]-s[1]的差值。

三、一方面这是取n张牌，反过来想，就是留1张牌，让s[2]~s[n]-1，就是让s[1]+1，这样就用O(1)的时间代替了原本O(n)的操作，这样就真的将O(mlogn+mn)降到了O(m)

以上就是我个人的想法，理论上能实现，但是我自己一直没实现就想发个题解。

原因①：部分分的写法应该也是对做题有帮助的，尤其是比赛

原因②：集思广益，如何实现

不喜勿喷，有意见请发评论或私信，大家一起看看能不能实现。
