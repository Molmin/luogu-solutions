这是一个常数很大的 $O(n\log^2 n)$ 解法。信仰 polylog 拒绝根号谢谢喵。

经过一些归纳整理，我们的行走路径一定是 $u\rightarrow v$ 的最短路径，其中最多在一个点 $w$ 的时候，会反复来回在 $w$ 和它的一个同高度邻居间横跳，最后回到 $w$，一口气走到 $v$。且满足 $w\rightarrow v$ 这一段的高度是不断严格下降的。

设 $f(u)$ 是从 $u$ 出发，不断严格下降高度，所能走的最大步数；那么上面的路径，可以看成 $u\rightarrow w$，然后反复横跳回到 $w$，然后加上 $f(w)$。这样我们就可以用简单路径的形式描述我们的行走，把所有简单路径以外的部分用一个简单的贡献形式来描述。

我们把路径上，势能增加的边给上 $+1$ 的权，势能减少的边给上 $-1$ 的权（当然有一些边禁止通行）。那么合法的充要条件是最小前缀和非负，设最后总共的和是 $d$（也就是走到 $w$ 后余下的势能），如果我们要进行反复横跳，那么我们应该是可以走 $\lfloor \frac{d}{2} \rfloor\times 2$ 也就是 $d-[2\nmid d]$ 这么多步。

首先考虑点分。这样我们可以对每个点 $u$，处理 $u$ 上行到 $rt$ 以及从 $rt$ 下行到 $u$ 的信息。我们考虑拼接两部分，那么只需要分别维护两端的 $(premin,endv)$，分别表示最小前缀和以及最后总共的和。

然后设上行段是 $L$，下行段是 $R$，那么最小前缀和非负的话，也就是：

$$
\begin{cases}
premin_L\ge 0 \\
endv_L+premin_R\ge 0
\end{cases}
$$

看上去是一个二维数点的形式。实际上如果 $premin_L\lt 0$ 我们直接忽略这个点，这样就只剩下一个维度的限制了，可以直接 bit 上解决。（点分治为了解决相同子树问题，要正着反着遍历一遍，这个过程决定了它是一个“在线”的数点，因此这个一维数点也必须用 BIT 维护前缀 $\max$）。

贡献可以拆成 $depth_u+depth_v+f(v)$，然后我们还要分类：也就是到底是否进行反复横跳（因为不是所有的点 $w$ 都可以反复横跳的）。

如果不能横跳，那么直接 $depth_u+depth_v+f(v)$ 完事（事实上 $depth_u+depth_v$ 也是可以的）。

如果可以横跳，那么我们发现 $d=endv_L+endv_R$，暴力枚举两个 $endv$ 的奇偶性就可以确定 $d$ 的奇偶性。所以我们加入一个点的时候要加入到其 $endv$ 所属奇偶性的 bit（还要根据是否能成为反复横跳点分类，所以实质上有 $4$ 个 bit）。然后查询 bit 的时候再去暴力枚举 $4$ 种 case，此时的贡献是容易统计的。

时间复杂度确实是 $O(n\log^2 n)$ 但是常数也确实很大。

[记录](https://codeforces.com/contest/1654/submission/186411542)