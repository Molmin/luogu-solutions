算是入门的一道期望dp。


不妨设 $l$ 为当前最末位 o 的**期望**个数 , $f(i)$为前 $i$ 位的**期望**得分。

- 当前位置为 o 时
	
    显然 `f[i] = f[i - 1] +(l + 1) * (l + 1) - l * l`
    
    并且 `l = l + 1`。 不再赘述。
    
- 当前位置为 x 时
	
    即当前位置对答案无贡献，`f[i] = f[i - 1]` 即可。
    
    当然不要忘了令`l = 0`
    
- 当前位置为 ? 时
	
    重点。
    
    我们首先考虑$f(i)$的取值，显然当前位置为 x 或 o 的概率是相同的。
    
    于是期望得分就很好算了。
    
    `f[i] = (f[i - 1] +　(l + 1) * (l + 1) - l * l + f[i - 1]) / 2` 即可。
    
   即前两个的得分的均值。
   
   考虑此时我们的期望长度。
   
   在第一和第二种情况时，长度分别为 $l+1$和$0$
   
   考虑期望长度就为这两个的均值，令 `l = (l + 1 + 0) / 2` ，即`(l + 1)/2`即可。
   

$Code:$

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 3 * 1e5 + 10;

char s[N + 10];
int n;
long double f[N];

int main () {
 	scanf("%d" , &n);
 	scanf("%s" , s + 1);
	f[1] = 0;
	double l = 0.0;
 	for(int i = 1 ; i <= n ; i ++) {
		if(s[i] == 'o') {
			f[i] = f[i - 1] - l * l + (l + 1.0) * (l + 1.0);
			l ++;
		} else if(s[i] == 'x') {
			l = 0.0; f[i] = f[i -  1];
		} else if(s[i] == '?') {
			f[i] = (f[i - 1] - l * l + (l + 1.0) * (l + 1.0) + f[i -  1]) / 2.0;
			l = (l + 1) / 2;
		}
	}
	printf("%.4Lf" , f[n]);
	return 0;
}
```
	