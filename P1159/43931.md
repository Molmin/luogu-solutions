**C++选手看这里**

# 方法介绍

## 首先介绍一下STL里面的queue

它可以实现一个无限长度的序列,还可以保存他们的顺序,并且可以用他们进入的顺序调用.

在这里我们就使用了两个queue.

## bool数组标记法

考虑到有SAME的存在,我们不能对它进行排序,因此,我们把它标记出来,特殊处理特殊对待.

# 具体思想

## 审题可得信息

通过题目输出提示的后面的话,"每组数据有大于一个的解",再结合样例,我们可以看出来,只要一组解就可以了.

所以,我就只处理了一组解QWQ

## 对于UP

显然,UP的歌曲,原来一定在目前位置的下面,所以,我们假设他上周是最后几名.

## 对于SAME

上文提到过的bool数组标记法,当我们输出的时候,如果i这位置已经确定,那么就输出这个i位置上面的歌曲,否则在考虑从UP,DOWN里面选.

## 对于DOWN

他一定在前面,不妨假设他是第一个,然后向后排.

# 细节处理

如果我们使用STACK来存储,那么假设有一个总共5个点的数据,1,2,4都是UP,如果使用STACK,4号排的位置一定是第三个或之前,因此我们使用双QUEUE.一个来储存应该排在前面的歌曲(标记为DOWN的),另一个来存应该排在后面的歌曲(标记为UP的),对于SAME的我们就直接标记到BOOL数组里面.这样既可以保存进入的顺序,又可以先后排序.

# 可行性优化

对于正式比赛中,如果不开O2的话,STL可能会很慢,所以我们可以考虑使用数组,对于最坏情况,开100,所以,我们只需要开200个数组,1~100,存原来的应该排在前面的,101~200存原来应该放到后面的,这样,在中间就判定一下是不是到了中间空着的0,跳过就可以了.(全局变量大法好).

```cpp
#include<bits/stdc++.h>
using namespace std;
string name[101],dos;
queue<int> fr,en;
int n;bool sa[101];
int main(){
    cin>>n;for(int i=1;i<=n;i++){
        cin>>name[i]>>dos;
        if(dos=="UP")en.push(i);
        if(dos=="DOWN")fr.push(i);
        if(dos=="SAME")sa[i]=1;
    }
    for(int i=1;i<=n;i++){
        if(sa[i]==1)cout<<name[i]<<endl;
        else{
        if(!fr.empty()){cout<<name[fr.front()]<<endl;fr.pop();}
        else if(!en.empty()){cout<<name[en.front()]<<endl;en.pop();}
        }
    }
    return 0;
}
```