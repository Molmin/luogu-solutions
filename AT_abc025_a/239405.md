这个题实际上很**水**，就是有人看不懂题意，这里我先来解释一下：有一个**长度为5的字符串（已经按升序排好了）**，把它**随便取两个字符得到一个新的字符串**，由小学数学知识可知：第一个**这样的字符串一共有5\*5=25种**，我们把这25个字符串**按字典序排个序，取其中的第n个输出**

举个栗子：“abcde”输出第8个：

首先按字典序把各个字符串写出来（~~列表求概率？！~~），再找出第8个，然后就是“bc”啦！：

|  | a | b | c | d | e |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| a | aa | ab | ac | ad | ae |
| b | ba | bb |**bc** | bd | be |
| c | ca | cb |cc  | cd | ce |
| d | da | db | dc | dd |de  |
| e |  ea| eb | ec | ed | ee |


但是毕竟是道蓝题，所以直接把它水过就太没价值了，咱们来玩点新花样：比如......**一题多解**？

（在讲解各种解法之前，先提醒一下：**AT里的题目，最后一定要打一个换行，否则会听取WA声一片**

## 方法1：一个个枚举，时间复杂度$O(n^2)$

依照刚才的思路，我们可以一个个**枚举**字符串，最多也就循环25次，所以我们就可以解决这道题啦~！

```
#include<iostream>
#include<cstring>
using namespace std;
int main(){
	int n;
   string s;
   cin>>s>>n;
	int cnt=0; //cnt来控制这是第几个字符串
  	for(int i=1;i<=5;i++){ //一个个循环
   	  for(int j=1;j<=5;j++){
  			if(cnt==n){  //如果到第n个就输出
  				cout<<a[i]<<a[j]<<endl;
  				break;
  			}
  			cnt++; //cnt加1
  		}
   }
   return 0;
}
```
我刚想到这个思路，准备开干的时候，对面大佬vectorwyx看了看我的代码说：“可以不用循环做，我有$O(1)$的方法！”

## 方法2：打表，时间复杂度$O(1)$

O（1）的方法？？？我又看了几组样例，有了一个惊奇的发现：**对于不同的字符串，只要n相同，那它输出的都是相同的**

比如n=8，无论字符串怎么变，输出固定是第2和第3个字符（下标为1和2）

那么n一共只有25种情况，那我们是不是可以通过**打表**来解决呢？？？

确实可以，于是我总结了规律，写出了代码，$O(1)$代码get!!!

```cpp
#include<iostream>
#include<cstring>
//开一个25*2的二维数组，a[n][0]表示字符串的第1个字符，a[n][1]表示第2个字符
int a[26][2]={0,0,0,0,0,1,0,2,0,3,0,4,1,0,1,1,1,2,1,3,1,4,2,0,2,1,2,2,2,3,2,4,3,0,3,1,3,2,3,3,3,4,4,0,4,1,4,2,4,3,4,4};
using namespace std;
int main(){
	string s;
	int n;
	cin>>s>>n;
	cout<<s[a[n][0]]<<s[a[n][1]]<<endl;
	return 0;
} 
```

## 方法3：找规律，时间复杂度$O(1)$

结果......vectorwyx并不是用打表做的，而是用了找规律的方法，这里我就不详细解释了，想了解的可以去膜拜这位大佬


------------

以上3种方法楼上的大佬们都已经做过啦，这里蒟蒻在贴一个自己发明的方法：

## 方法4：利用进制转化解决问题，时间复杂度$O(1)$

话说我被vectorwyx大佬实力碾压之后，我心里那个不爽呀，正悲愤之时，我又发现了我在打表的时候画的那张**把每个n用字符串下标表示**的表格：

|  | a | b | c | d | e |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| a | 00 | 01 | 02 | 03 | 04 |
| b | 10 | 11 | 12 | 13 | 14 |
| c | 20 | 21 | 22 | 23 | 24 |
| d | 30 | 31 | 32 | 33 | 34 |
| e | 40 | 41 | 42 | 43 | 44 |

顺着读一遍：00，01，02，03，04，然后是10，11，12......发现了什么，**这个表中貌似没有5出现，满4就进一位**......等会，这不就是**5进制**吗！

再看看n和对应序号的关系，我们可以发现：**减1，再转化成5进制，就是对应的值**

还是拿8来操作：8-1=7，把7转化成5进制，还记得十进制怎么转n进制吗？**除以n取余再倒写！**

|除以5的商|除以5的余数|
| :----------: | :----------: | 
|7| 2|
|1|1|
|0|0|
余数是0就不除啦！把余数倒写，得到“012”正好是输出字符s[1]和s[2]

由于$n<25=5^2$，这个5进制数一定是个两位数，这样取余两次，倒着转化到字符串里，也能$O(1)$解决，Perfect！！！
```cpp
#include<iostream>
#include<cstring>
using namespace std;
int main(){
	string s;
	int n;
	cin>>s>>n;
	n--;  //根据规律，n先减1
	int a=n%5; //第一次÷5取余
	n/=5;
	int b=n%5; //再取余
	cout<<s[b]<<s[a]; //倒着输出（先s[b]后s[a]）
	return 0;
}
```
 The End!