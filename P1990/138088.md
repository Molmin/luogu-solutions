先看题意，给你长为n的墙壁，一共有几种覆盖方法？

这道题看完后很容易联想到走楼梯那道题（P1255）

可以通过递推（dp）来完成这道题

根据题意，覆盖墙壁的方法有
![](https://cdn.luogu.com.cn/upload/pic/51535.png )

画出来之后，能知道 


**长为N的墙壁覆盖方法数=长为N-1的墙壁覆盖方法数+2✖长为N-2多一个格子的墙壁覆盖方法数+长为N-2的墙壁的覆盖方法数**

所以我们得考虑多余一个格子的情况

之后我就想，既然要考虑多余的格子的情况，

**那我不如考虑已有N条边，我可以**

**（1）竖着摆2*1的砖头 **

         
                                           图1
**（2）横着摆两个2*1的砖头 **                            
                     
                                           图4

**（3）摆L型覆盖3个单元的砖头（有两种摆法）** 
         
                                           图2、3
                                           
                                          
                                          
**而在N条边多一个格子时候，我可以**

**（1）横着摆2*1的砖头 考虑N-1条边多一个格子的情况            （只有一种摆法）图5**

**（2）根据多余的格子位置摆一个摆L型覆盖3个单元的砖头（只有一种摆法） 没画图**

**想一想为什么**

下来这样做会TLE，想一想为什么，所以我们就要加上记忆化搜索
                                          
这样这道题的dp方程就出来了

if(不多余格子)

x[已覆盖的边长][判定是否有多余格子]=(dp(已覆盖的边长+1,没有多余格子)+**2**（L型砖块两种摆法）*dp(已覆盖的边长+1,有多余格子)+dp(已覆盖的边长+2,没有多余格子))%10000（题目要求输出覆盖方法的最后4位，如果不足4位就输出整个答案。）;

else if(多余格子）
x[已覆盖的边长][判定是否有多余格子]=(dp(已覆盖的边长+2,没有多余格子)+dp(已覆盖的边长+1，有多余格子))%10000;



然后这道题就做出来了

```cpp

#include<bits/stdc++.h>
using namespace std;
int n;
long int x[1000002][3];
long int dp(int ge,int pan)
{
    if(x[ge][pan]!=0)
    return x[ge][pan]%10000;
    if(ge==n&&pan==0)
    return 1;
    else if(ge>=n)
    return 0;
    if(pan==0)
    return x[ge][pan]=(dp(ge+1,0)+2*dp(ge+1,1)+dp(ge+2,0))%10000;
    if(pan==1)
    return x[ge][pan]=(dp(ge+2,0)+dp(ge+1,1))%10000;
    return 0;
}
int main()
{
    cin>>n;
    cout<<(dp(0,0))%10000;
    return 0;
} 
```

                                           
                              