**解题思路：状压DP，以宽为行长为列从左到右dp，dp [ i ] [ j ]表示第 i 列状态为 j 的情况共有多少种情况。为描述方便，我用1代表格子被覆盖，0代表未被覆盖**

初始化：
              
              dp[1][0]=0;   //不会出现这种情况；
              dp[1][1]=0;   //不会出现这种情况；
              dp[1][2]=0;   //不会出现这种情况；
              dp[1][3]=1;   //放一块第一种砖头；
              dp[2][0]=1;   //放一块第一种砖头；
              dp[2][1]=1;   //放一块第二种砖头；
              dp[2][2]=1;   //放一块第二种砖头；
              dp[2][3]=2;   //放两块第一种砖头，有横着放和竖着放两种；
```cpp
#include<cstdio>
#include<cstring>
const int maxn=1000000+10;
int dp[maxn][4];
int main(void)
{
	int n;
	scanf("%d",&n);
	dp[1][0]=0;
	dp[1][1]=0;
	dp[1][2]=0;
	dp[1][3]=1;
	dp[2][0]=1;
	dp[2][1]=1;
	dp[2][2]=1;
	dp[2][3]=2;
	for(int i=3;i<=n;i++)
	{
		dp[i][0]=(dp[i-1][3])%10000;
		dp[i][1]=(dp[i-1][2]+dp[i-1][0])%10000;
		dp[i][2]=(dp[i-1][1]+dp[i-1][0])%10000;
		dp[i][3]=(dp[i-1][3]+dp[i-1][1]+dp[i-1][2]+dp[i-1][0])%10000;
	}
	printf("%d\n",dp[n][3]%10000);
}
```