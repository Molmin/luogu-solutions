# 潇洒の开始

（又一次写纯理论提交QWQ）

[问题评估]

 

此题或许大多数人会觉得很麻烦。或许有人会选择搜索来做，显然，50000的数据量不可能允许搜索不超时。或许有人会用贪心，但是却无从下手。

动态规划？怎么划阶段更是一个难题。然而，此题却不是考察选手的算法的，而是考察你从题目中找出基本核心的能力。

 

  [题目实现]

题目给你的初始状态是一个回路，从第一个同学前断开，不难看出这是一个严格的上升序列。而输入的数据也可以将之构成一个包含所有同学的回路，否则就达不到没个人的愿望。

 

我们可以用两的数组来储存两个数组的状态，初始状态为st，目标状态为en。st[i]=i,

i<=n。而输入数据我门可以先用一个二维E数组储存，E[I，1]即表示第I 个人的第一个愿望。我们将目标状态数组en的第一个元素赋值为1，然后就可以把s[1]的第一个愿望加入数组为s[2]，依次我们可以逐个加入，加入没个元素的时候，还要判断一下每个元素是否在数组当中，如果在，那就取第2个愿望。如果第二个愿望也在数组当中，那么我们的目标状态的数组也就构造完成了。

 

如果每个人的愿望都能实现，显然，目标状态的数组的元素必定是N，而假如不是，那么就可以输出-1了。

此时，问题就显的简单些了，如何让一个数组从一中状态变成另一种状态，相信有很多方法，可还是个麻烦事。

从目标状态转换成初始状态的步数是等同于初始状态转换成目标状态，而此时再看看初始状态的数组，相信你已经看出些疑端了吧！

 

排序！！！

 

对，其实从目标状态转换成初始状态的过程就是一个排序的过程，而且还是一个最简单的冒泡排序的过程！

到了这了，问题已经明了了，题目所求就是每次进行连续交换的人数总和，这样，一个看似复杂的题目就变的异常的简单了！而题目2秒的时间限制更是保证了冒泡排序经过一些优化以及剪枝后不会超时。

但是，千万不能用其他的排序法来解决。虽然能让你的程序变的更快，却同时你也得不正确的解！


# 完美の结束