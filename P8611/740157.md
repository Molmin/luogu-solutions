## 题意
第一行输入一个整数 $n(1<n<50)$ 表示蚂蚁的总数。

接着的一行是 $n$ 个用空格分开的整数 $X_i(-100<X_i<100)$，$X_i$ 的绝对值，表示蚂蚁离开杆子左边端点的距离。正值表示头朝右，负值表示头朝左，数据中不会出现 $0$ 值，也不会出现两只蚂蚁占用同一位置。其中，第一个数据代表的蚂蚁感冒了。

要求输出 $1$ 个整数，表示最后感冒蚂蚁的数目。

## 分析
首先，我们自然而然的想到和 [P1007独木桥](https://www.luogu.com.cn/problem/P1007) 的机制是一样的，我们只需要把蚂蚁的相遇并掉头视作互相穿过，这里不再赘述，因为我要来讲一种新的方法。

### 做法
显然，~~因为这是一道简单的入门题，所以~~我们首先想到的就是靠公式推导。但是，对于这一题并不可取。虽然可以通过此题，但若是数据毒瘤一点，就会出错。

这一题对于公式法，只需要一种数据即可推翻：就是满足有一只蚂蚁和另一只蚂蚁碰面，但是此时并没有生病，反而是穿过之后的某一时间点被传染。就和我在讨论版发出的[帖子](https://www.luogu.com.cn/discuss/517576)一样，找出了对于前两篇题解的 hack 数据，所以我就立即排除掉了公式法推算数目的程序。所以此题正解就只能大模拟或者加一点技巧的搜索。

我们首先自然要用结构体记录每一只蚂蚁的各种状态，需要储存蚂蚁的绝对位置，朝向，被感染时的时间，以及是否被感染。
```cpp
struct node{
	int x,cx,t,ill;//x记录位置，cx记录朝向，t记录被感染时的时间，ill记录是否被感染。
}a[55];
```

我们可以先根据题意写出两个相遇的条件。（或者只写一个，调用时把参数交换就行）
```cpp
bool onleft(node a,node b){//前者在左侧，后者在右侧
	if(a.x<b.x&&a.cx>b.cx){//cx是 0,1 记录，所以大于就代表了前者为 1，后者为 0 
		return 1;
	}
	return 0;
}
bool onright(node a,node b){//前者在右侧，后者在左侧
	if(a.x>b.x&&a.cx<b.cx){//cx是 0,1 记录，所以小于就代表了前者为 0，后者为 1 
		return 1;
	}
	return 0;
}
```

然后，我们可以开始构思程序主体。

首先，我们一定要把第一位的病原数据设置为已感染。接下来就可以写出读入数据的转化：
```cpp
for(int i=1;i<=n;i++){
	scanf("%d",&x1);
	a[i].x=abs(x1);//取绝对位置 
	if(x1>0){//往右走 
		a[i].cx=1;//朝向标记为 1 
	}
}
```
接下来，我们整理数据，可以将数据按绝对位置排序。因为是结构体，所以要手写 `cmp` 函数进行排序的标准。但是没必要对第一位排序，因为我们以后对第一位都是直接调用，否则需要另一个参数判断是否为病原。
```cpp
bool cmp(node a,node b){//结构体排序要用手写 cmp 函数 
	return a.x<b.x;
}
```
接下来，对于每一个数据都存在两种情况：已生病和未生病。
所以对情况进行分条判断。

若是已生病的情况，则在所有数据中扫描（可以除去第一位）。若满足传染条件且扫描的那一位没有被感染（如果已被感染还要继续扫描就需要取 $t$ 的最小值）：当前已感染的蚂蚁被感染的时间要小于这两只蚂蚁的相遇时间：`a[i].t<abs(a[i].x-a[j].x)`

且两只蚂蚁可以相遇：
```cpp
(onleft(a[i],a[j])||onright(a[i],a[j]))
```

就把这一只蚂蚁算出感染时间并标记：
```cpp
a[j].t=abs(a[i].x-a[j].x)/2;//算出被感染的时间
a[j].ill=1;//打上已被感染的标记
```

否则就是没有生病。那么我们需要将所有数据（是否去除第一个不影响，若是追求极限时间，可以去掉）进行判断。

如果枚举的那一位是已生病的，则可以进行判断感染时间和是否可以相遇，和上文相同。

若找到了可以使这个蚂蚁被感染的方法，算出时间，打上标记，立即跳出循环。

最后，我们判断一下有几只蚂蚁被感染，如果已经被感染了，就累加答案。
```cpp
for(int i=1;i<=n;i++){//统计被感染的数目 
	if(a[i].ill==1){//如果被感染 
		ans++;//累加答案 
	}
}
```

时间复杂度：$O(n^2)$，足已通过此题。

最终代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,x1,ans;
struct node{
	int x,cx,t,ill;//x记录位置，cx记录朝向，t记录被感染时的时间，ill记录是否被感染。
}a[55];
bool cmp(node a,node b){//结构体排序要用手写 cmp 函数 
	return a.x<b.x;
}
bool onleft(node a,node b){//前者在左侧，后者在右侧
	if(a.x<b.x&&a.cx>b.cx){//cx是 0,1 记录，所以大于就代表了前者为 1，后者为 0 
		return 1;
	}
	return 0;
}
bool onright(node a,node b){//前者在右侧，后者在左侧
	if(a.x>b.x&&a.cx<b.cx){//cx是 0,1 记录，所以小于就代表了前者为 0，后者为 1 
		return 1;
	}
	return 0;
}
int main(){
	//freopen("t1.in","r",stdin);
	//freopen("t1.out","w",stdout);
	scanf("%d",&n);
	a[1].ill=1;
	for(int i=1;i<=n;i++){
		scanf("%d",&x1);
		a[i].x=abs(x1);//取绝对位置 
		if(x1>0){//往右走 
			a[i].cx=1;//朝向标记为 1 
		}
	}
	sort(a+2,a+n+1,cmp);//排序使数据有序 
	for(int i=1;i<=n;i++){
		if(a[i].ill==1){
			for(int j=2;j<=n;j++){
				if(a[j].ill==0){
					if(a[i].t<abs(a[i].x-a[j].x)&&(onleft(a[i],a[j])||onright(a[i],a[j]))){
						a[j].t=abs(a[i].x-a[j].x)/2;//算出被感染的时间
						a[j].ill=1;//打上已被感染的标记
					}
				}
			}
		}
		else{
			for(int j=1;j<=n;j++){
				if(a[j].ill==1){
					if(a[j].t<abs(a[i].x-a[j].x)&&(onleft(a[i],a[j])||onright(a[i],a[j]))){
						a[i].t=abs(a[i].x-a[j].x)/2;//算出被感染的时间
						a[i].ill=1;//打上已被感染的标记
						break;//已被感染可以不用继续枚举 
					}
				}
			}
		}
	}
	for(int i=1;i<=n;i++){//统计被感染的数目 
		if(a[i].ill==1){//如果被感染 
			ans++;//累加答案 
		}
	}
	printf("%d",ans);
	return 0;
}
```
其实这一题如果此种做法是唯一正解的话，难度还是不低的，但是可能是数据的缘故，可以用公式法推导答案，在此就不奉上啦。