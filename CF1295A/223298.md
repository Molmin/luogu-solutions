还是比较水的

## 题意分析
**题目翻译：**

我们要用一个个段去拼数字

用段拼数字的规则如图所示，拼每个数字都需要用到不同数量的段。

T组数据，对于每组数据给我们n个段，求用这n个段能拼出的最大的数字

**分析：**

首先，用贪心的思想思考，想要让拼出的**数最大**，就要让这个数的**位数最多**，也就说我们要尽可能地多拼数字，让位数尽可能大，所以我们要尽量去拼那些需要**用到段少**的数字。

![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1295A/f1bf3e3ee1e01404b7c2f218b7a8b65c071d6967.png)

| 数字 | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |
| -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: |
| 所需段数 | 6 | 2 | 5 | 5 | 4 | 5 | 6 | 3 | 7 | 6 |

需要段数最少的是“1”，用到2个段

显然，如果n是偶数的话，我们直接输出n/2个“1”就行了

那如果n是奇数呢？我们总不能扔下一个段不管吧，此时我们应减少一定的“1”，去凑一个用奇数个段拼成的数字，那么用奇数个段拼成的数字，用到段最少的就是“7”了。

所以如果n是奇数的话，我们先输出一个“7”，然后再输出n/2-1个“1”就好了

这个思路还是很简单的，注意如果n是奇数的话，一定是先输出“7”再输出“1”，因为如果想要数大，大的数字要放在前面

##  _Code:_ 

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int T,n;
int main()
{
	scanf("%d",&T);
	while(T--)
	{
		scanf("%d",&n);
		if(n&1){
			printf("7");
			for(int i=1;i<=n/2-1;i++)
			   	printf("1");
			puts("");
		}
		else{
			for(int i=1;i<=n/2;i++)
			   	printf("1");
			puts("");
		}
	}
	return 0;
}
```
