### 题意

[P9151 计数题](https://www.luogu.com.cn/problem/P9151)

个人很喜欢这种题，不失思考的乐趣。

思路构建 $\text{with}$ [$\text{Solystic}$](https://www.luogu.com.cn/user/61088)。

### 思路

考虑操作的性质，每次是相邻三个变为中位数。

也就是说最后得到的字符串中的每一个字符都是由一段区间操作得来的。

为了答案不计算重复，我们让最后得到的字符串每一个字符对应的区间尽量靠前匹配，这样每一个字符串都能被一个状态唯一对应。

具体的，记 $f_i$ 表示贪心匹配 $1 \sim i$ 中字符得到的字符串数量。

比如样例 $111000$ 中的 $f_4$ 包含字符串 $10$，因为 $111$ 可以操作得到 $1$，$0$ 可以操作得到 $0$，而且这组匹配是尽量靠前的。

现在我们考虑如何转移，记 $c$ 表示下一位要转移的字符，为了仍满足贪心策略，我们需要找到最小的 $j>i$ 使得 $[i+1,j]$ 能操作得到字符 $c$，并有 $f_j \leftarrow f_i$。

而计算答案时，我们需要知道 $[i+1,n]$ 中的字符能不能操作没（实际上不能操作没，至少留一个，这么写只是方便大家理解），也就是 $[i,n]$ 能不能操作变成 $s_i$，随后 $ans \leftarrow f_i$。在上面的例子中，因为 $000$ 可以操作变成 $0$，所以 $f_4$ 的所有答案都能取得，并且 $f_4=2(10,1110)$。

现在我们只需要知道如何判定 $[l,r]$ 能否操作变成 $c$，因为 $c=0,1$ 是对称的情况，我们只考虑 $c=0$，另一种情况可以通过所有值取反来处理。

因为操作是取中位数，所以我们要尽可能的让序列中的 $0$ 多，$1$ 少，多余连续 $2$ 个 $1$ 可以操作一次减少 $2$ 个 $1$。

我们考虑 $l \sim r$ 顺次加入，维护一个栈，这个栈仅有栈顶最多两个值为 $1$。

若新加入的字符是 $1$，则加入后判断栈顶是否为 $111$，若是则弹出 $11$。

若新加入的字符是 $0$，则加入后判断栈顶是否为 $10$，若是则弹出 $10$。

最后进需要判断栈的大小是否是奇数并且 $1$ 的个数是否严格少于 $0$ 的个数即可，复杂度 $O(n)$。

这个做法的正确性比较容易感性理解，具体正确性说明如下。

首先，在栈底的 $0$ 可以随时与在栈顶的 $1$ 匹配消去，所以留到最后再匹配最优，因为后续操作中栈顶可能会 $111$ 弹出 $11$，这种方式是最符合 $0$ 多 $1$ 少的策略的，最后匹配的方式是在 $0,1$ 分界线弹出 $01$，所以就是谁多剩谁。

其次，在出现 $111$ 时直接弹出是最符合策略的，而在出现 $10$ 时直接弹出是考虑到无论下一位字符是 $0$ 还是 $1$，对它们操作一次都等效于直接弹出 $10$，而且弹出栈顶堆积的 $0$ 有利于底部被压住的 $1$ 与后面的 $1$ 相遇，从而以 $111$ 的方式弹出，也是符合策略的。

举个例子，$01100$ 如何操作变成 $0$，首先前三个字符直接加入变成 $011$，在加入下一个 $0$ 时看到 $10$ 弹出，变为 $01$，最后一位同理，变为 $0$。构造方案就是考虑消去 $10$ 时若栈不为空考虑跟上一项一起操作，否则等下一项进栈时再操作。

这个部分代码如下：

```cpp
inline bool check2(int pos,int val)
{
    hd=0;
    
    for(int i=pos;i<=n;i++)
    {
        q[++hd]=(s[i]-'0')^val;
        if(hd>=2&&q[hd-1]==1&&q[hd]==0)
            hd-=2;
        if(hd>=3&&q[hd-2]==1&&q[hd-1]==1&&q[hd]==1)
            hd-=2;
    }

    return ((pos&1)==(n&1))&&(hd-(hd&&q[hd]==1)-(hd>1&&q[hd-1]==1)>(hd&&q[hd]==1)+(hd>1&&q[hd-1]==1));
}
```


这个策略在判定后缀时是正确的，但是其实在前面贪心时是错误的。

还是原来的例子，$111000$，我们发现 $f_4$ 其实不会计入 $10$，因为 $1$ 在 $f_1$ 中计入，而 $[2,4]$ 是 $110$，确实不能操作成为 $0$，所以我们需要改良一下。

我们发现改良的思路其实是前一位的字符可以充当 $111$ 最开头的 $1$，而且不会被消去，所以我们直接在开头加入到栈中即可。需要注意的一点是，这个字符不应该被消去，也就是说我们不应该弹出最开头的 $10$ 将栈弹空。

这样我们可以把判定和贪心找最靠前的位置结合到一起，具体的，第一位是 $s_{i-1}$，也就是说若栈大小为 $2$ 且 $q_2=0$ 则说明当前位置 $j$ 满足 $[i+1,j]$ 可以操作为 $0$，直接返回位置即可。

这个部分代码如下：

```cpp
inline int check1(int pos,int val)
{
    hd=0;
    
    for(int i=pos;i<=n;i++)
    {
        q[++hd]=(s[i]-'0')^val;
        if(hd>=3&&q[hd-1]==1&&q[hd]==0)
            hd-=2;
        if(hd>=3&&q[hd-2]==1&&q[hd-1]==1&&q[hd]==1)
            hd-=2;
        if(hd==2&&q[hd]==0)
            return i;
    }

    return n+1;
}
```

我们需要注意 $s_1$ 的前一位也就是 $s_0$ 不应该操作，也就是说我们需要将它赋值为一个毫不相干的数（或者 $s_1$ 取反，比较推荐这个，因为好优化）。

从这个函数中我们可以看出若 $[i,j],[i,k]$ 都能操作成 $0$，并且 $j$ 是最靠前的那个，则操作 $[i,k]$ 贪心到 $j$ 时栈里仍是仅有 $s_{i-1}$ 和 $0$，所以 $[i,k]$ 可行说明 $[j,k]$ 可行，这样也就说明了贪心匹配可以不重不漏的计数。

具体代码如下：

```cpp
inline void work()
{
    cin>>(s+1);
    n=strlen(s+1);

    ans=0;
    for(int i=0;i<=n;i++)
        f[i]=0;

    f[0]=1,s[0]='0'+((s[1]-'0')^1);
    for(int i=1;i<=n;i++)
    {
        int p=check1(i-1,0);
        f[p]=(f[p]+f[i-1])%mod;
        p=check1(i-1,1);
        f[p]=(f[p]+f[i-1])%mod;
        if(check2(i,s[i]-'0'))
            ans=(ans+f[i])%mod;
    }

    cout<<ans<<'\n';
}
```

复杂度 $O(n^2)$，```check2``` 函数是卡满的，所以只能拿 $40$ 分。

考虑优化这个算法，首先对于后缀的判断可以倒序加数优化，$vis_{i,0/1}$ 表示 $[i,n]$ 是否能操作成 $0/1$，代码如下：

```cpp
inline void sol(int val)
{
    hd=0;

    for(int i=n;i;i--)
    {
        q[++hd]=(s[i]-'0')^val;
        if(hd>=2&&q[hd-1]==1&&q[hd]==0)
            hd-=2;
        if(hd>=3&&q[hd-2]==1&&q[hd-1]==1&&q[hd]==1)
            hd-=2;

        vis[i][val]=(hd&1)&&(hd-(hd&&q[hd]==1)-(hd>1&&q[hd-1]==1)>(hd&&q[hd]==1)+(hd>1&&q[hd-1]==1));
    }
}
```

仅加上这个优化，会多过几个点，也就是说 ```check1``` 函数跑的不是很满，但是仍需要优化。

我们发现贪心时的这个栈不会很大。第 $1$ 位是 $s_{i-1}$，第 $2$ 位若是 $0$ 则找到了最靠前的位置，结束算法，所以第 $2$ 位只能为 $1$，同理，第 $3$ 位若为 $0$，则 $10$ 会匹配消去，所以第 $3$ 位也只能为 $1$，第 $4$ 位不管为 $0$ 还是 $1$ 都会消去，所以集合大小最多为 $3$。

具体的，集合内的数其实只有 $5$ 种情况（算上找到位置结束是 $6$ 种），我们按如下方式编号，$\Delta$ 表示找到最靠前的位置。

```
delta: 00 & 01
+0 = none
+1 = none
0: 0
+0 = delta
+1 = 2
1: 1
+0 = delta
+1 = 3
2: 01
+0 = 0
+1 = 4
3: 11
+0 = 1
+1 = 1
4: 011
+0 = 2
+1 = 2

```

这样的话，我们记 $g_{i,X}$ 表示加入 $s_i$ 之前栈的情况为 $X$ 的最靠前的位置的编号，则加入 $s_i$ 之后栈的情况会变为 $X'$，若 $X'=\Delta$ 则 $g_{i,X} \leftarrow i$，否则 $g_{i,X} \leftarrow g_{i+1,X'}$，倒序转移即可做到 $O(n)$。

加一些取模优化可以增加效率，具体实现细节看代码。

有不理解的地方可以在博客或者讨论区问我本人。

### 代码

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;

const int mod=998244353;

int _,n,hd,ans;
int f[5000005],g[5000005][5],h[5000005][2],q[5000005];
bool vis[5000005][2];
char s[5000005];

inline void update(int &x,int y)
{
    x+=y;
    if(x>=mod)
        x-=mod;
}

inline int check(int pos,int val)
{
    hd=0;
    
    for(int i=pos;i<=n;i++)
    {
        q[++hd]=(s[i]-'0')^val;
        if(hd>=3&&q[hd-1]==1&&q[hd]==0)
            hd-=2;
        if(hd>=3&&q[hd-2]==1&&q[hd-1]==1&&q[hd]==1)
            hd-=2;
        if(hd==2&&q[hd]==0)
            return i;
    }

    return n+1;
}

inline void sol(int val)
{
    hd=0;

    for(int i=n;i;i--)
    {
        q[++hd]=(s[i]-'0')^val;
        if(hd>=2&&q[hd-1]==1&&q[hd]==0)
            hd-=2;
        if(hd>=3&&q[hd-2]==1&&q[hd-1]==1&&q[hd]==1)
            hd-=2;

        vis[i][val]=(hd&1)&&(hd-(hd&&q[hd]==1)-(hd>1&&q[hd-1]==1)>(hd&&q[hd]==1)+(hd>1&&q[hd-1]==1));
    }

    g[n+1][0]=g[n+1][1]=g[n+1][2]=g[n+1][3]=g[n+1][4]=n+1;

    for(int i=n;i;i--)
    {
        if((s[i]-'0')^val)
        {
            g[i][0]=g[i][4]=g[i+1][2];
            g[i][1]=g[i+1][3];
            g[i][2]=g[i+1][4];
            g[i][3]=g[i+1][1];
        }
        else
        {
            g[i][0]=g[i][1]=i;
            g[i][2]=g[i+1][0];
            g[i][3]=g[i+1][1];
            g[i][4]=g[i+1][2];
        }

        h[i][val]=g[i][(s[i-1]-'0')^val];
    }
}

inline void work()
{
    cin>>(s+1);
    n=strlen(s+1);

    for(int i=0;i<=n;i++)
        f[i]=0;
    ans=0,f[0]=1,s[0]='0'+((s[1]-'0')^1);
    sol(0),sol(1);

    for(int i=1;i<=n;i++)
    {
        update(f[h[i][0]],f[i-1]);
        update(f[h[i][1]],f[i-1]);
        if(vis[i][s[i]-'0'])
            update(ans,f[i]);
    }

    cout<<ans<<'\n';
}

int main()
{
    ios::sync_with_stdio(0);
    cin.tie(0),cout.tie(0);

    cin>>_;

    while(_--)
        work();

    return 0;
}
```
