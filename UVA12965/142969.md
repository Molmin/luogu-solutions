## 题目大意：
有一个产品价格，有 $N$ 个工人，其中第 $i$ 个人希望这个价格不小于 $a_i$。另有 $M$ 个顾客，其中第 $j$ 个人希望这个数不大于 $b_j$。求出最少有多少人的愿望不能被满足，以及这个价格在愿望不能被满足人数最小时的最小值（注：价格最低为 $0$）。

## 思路：
最简单的思路是暴力，但此题数据范围是 $10^4$，所以我们不能去暴力求解。

经过观察我们可以发现，**这个价格的最小值必然为工人中一人所期望的值，或者为 $0$ 元**。

为什么呢？因为题目表明，需要最小值。而工人们的要求是最低值，所以最终答案选择工人们是最佳的，如果将价钱降低一元，这个工人就必然不满意。如果这样做能够取悦多于 $1$ 个的消费者，那么比这个要求低一个的那个工人将是更优的答案。特别地，如果不考虑工人的需求，则答案为零。

## 代码实现：
我们只需给工人的要求从小到大排序，顾客的要求从大到小排序，这样当排序后第 $i$ 个工人条件被满足时，会有 $i$ 个工人的要求被满足（不用考虑重复，因为后面重复的同样会计算），然后再二分查找能满足的要求最高的顾客，会有查找到顾客的编号个顾客的条件被满足，复杂度 $\rm O(\log n)$。当不考虑工人时，我们可以多一位第 $0$ 个工人，让他的需求为 $0$。这样也可以满足我们上面的计算方式而不需要特判。

## 上代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int t;
bool cmp(int x, int y) {
	return x > y;
}
int main() {
	cin >> t;
	while (t--) {
		int n, m, a[10010], b[10010], human = -1, money = -1;
		cin >> n >> m;
		a[0] = 0;
		for (int i = 1; i <= n; i++)cin >> a[i];
		for (int i = 1; i <= m; i++)cin >> b[i];
		sort(a + 1, a + n + 1);
		sort(b + 1, b + m + 1, cmp);
		for (int i = 0; i <= n; i++) {
			int l = 1, r = m, ans = 0;
			while (l <= r) {
				int mid = (l + r) >> 1;
				if (a[i] <= b[mid]) {
					ans = mid;
					l = mid + 1;
				} else r = mid - 1;
			}
			if (ans + i > human)human = ans + i, money = a[i];
		}
		cout << money << " " << n + m - human << endl;
	}
	return　0;
}
```










