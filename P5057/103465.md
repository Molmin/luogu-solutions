~~**这道题确实有点水**~~

看各位大佬解法不一，我也来提供一种较为容易理解的解法，前提是会**树状数组和前缀和，差分**

~~（不会的可以去刷一下板子题）~~

首先我们看题，发现最后结果**只有0或者1**（只有两种输出情况），我们就可以想到 **“ %2 ”**。

然后我们可以用一波简单的**差分**：

设d[x] 为**从1到x每一个数的总和**

假设初始一串数据 0 0 0 0 0  ~~（共五个）~~

我们要将（1，3）反过来，我们就可以将第一个数**加上1**，即：

**1 0 0 0 0**

然后我们在将第四个数**加上1**，即：

**1 0 0 1 0**

然后我们可以发现：

查询第一个数 == d[1] **% 2** = 1 **% 2** =1;

查询第二个数 == d[2] **% 2** = (1+0) **% 2**  =1;

查询第三个数 == d[3] **% 2** = (1+0+0) **% 2**  =1;

查询第四个数 == d[4] **% 2** = (1+0+0+1)  **% 2** =0;

查询第五个数 == d[5] **% 2** = (1+0+0+1+0)  **% 2** =0;

话不多说，直接上代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
long long d[100010], n ,m;

long long lowbit( long long x ){
	return x & (-x);
}

//树状数组的lowbit 运算，可以百度一下

void add(long long x,long long v){
	while(x<=n){
		d[x]+=v; //给每一个数的前缀和加上v;
		x+=lowbit(x); //下一个祖先
	}
}
                
long long res; //定义在函数内部容易超时
                
//询问a的前缀和
long long ask(long long a){
	res=0;
	while(a!=0){
		res+=d[a];
		a-=lowbit(a);
	}
	return res;
}
                
long long h,x,y;
                
int main(){
	cin>>n>>m;
	while(m--){
		cin>>h;
		if(h==1) {
			cin>>x>>y;

  			//后面两步是重点！！！
			add(x,1); 
			add(y+1,1);
  
		}
		if(h==2){
			cin>>x;
			cout<<ask(x)%2<<endl;
		}	
	}
}
```
就这样，这道题难度中等，可以试着用线段树做一下。
