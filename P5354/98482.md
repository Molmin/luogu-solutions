[在我的个人博客中阅读以获得更佳阅读体验](https://www.macesuted.cn/article/lg5354/)

---

[题面](https://www.luogu.com.cn/problem/P5354)

## 题意

给定一棵 $n$ 个点的树，每个节点上均有一个二进制运算符（`&`、`|` 或 `^`）和一个在 $[0,~2^k-1]$ 之间的数值。

接下来给定 $m$ 个操作，每个操作分为两类：

1. 修改某个结点上的运算符与数值。
2. 给定 $x,~y,~z$，你可以先任意指定一个值 $val \in [0,~z]$，然后在树上沿 $x$ 与 $y$ 之间的简单路径从 $x$ 向 $y$ 移动，每次到达一个结点后将 $val$ 变为 $val~op[i]~a[i]$，$op[i]$ 为该节点上运算符，$a[i]$ 为该节点上数值。最大化到达 $y$ 结点时的 $val$ 值并输出。

$n,~m \le 10^5,~0 \le k \le 64$

## 分析

由于询问时询问的是树上两点间路径的信息，不难想到通过树链剖分将每条路径转化为 $\log n$ 个区间。

由于每个结点上的运算符均为二进制位运算符，运算过程中不同二进制位之间互不影响。我们可以考虑对于每一个二进制位分开来考虑其运算结果，即对于每一个二进制位都求出其为 $0/1$ 时经过路径后的结果，最后通过类似数位 DP 的计算方法即可求出 $[0,~z]$ 区间内的初值可产生的最大运算结果。

而由于询问时两点间的路径是有向的，从 $x \to lca$ 的路径是向上的，从 $lca \to y$ 的路径是向下的。将树上移动的顺序对应到区间上移动的顺序，不难发现 $x \to lca$ 的路径对应的区间都是从右向左经过的，$lca \to y$ 的路径对应的区间都是从左向右经过的。因此我们需要对于每一个区间都求出每一个二进制位初始为 $0/1$ 时从左向右或是从右向左经过该区间之后的值。

考虑如何维护，建立一棵线段树，每个线段树结点都记录 $l0[i],~l1[i],~r0[i],~r1[i]$ 分别表示：

1. 二进制第 $i$ 位为 $0$ 时从左向右经过该区间后该位的值。
2. 二进制第 $i$ 位为 $1$ 时从左向右经过该区间后该位的值。
3. 二进制第 $i$ 位为 $0$ 时从右向左经过该区间后该位的值。
4. 二进制第 $i$ 位为 $1$ 时从右向左经过该区间后该位的值。

每次合并两个结点 $a,~b$ 的信息时令：

1. `ans.l0[i] = a.l0[i] && b.l1[i] || !a.l0[i] && b.l0[i]`
2. `ans.l1[i] = a.l1[i] && b.l1[i] || !a.l1[i] && b.l0[i]`
3. `ans.r0[i] = b.r0[i] && a.r1[i] || !b.r0[i] && a.r0[i]`
4. `ans.r1[i] = b.r1[i] && a.r1[i] || !b.r1[i] && a.r0[i]`

即枚举某一位在经过第一个区间后的值，将其以初值代入第二个区间得到结果。

此时对于每一个询问我们将路径拆为 $\log n$ 个区间，每个区间对应 $\log n$ 个线段树结点，每次合并结点需要花费 $O(k)$ 的时间，因此此时的总时间复杂度为 $O(m \times k \times \log ^2n)$，无法通过本题。

## 优化

我们仔细分析上面的时间复杂度，发现两个 $\log n$ 在该算法中都难以去除，因此我们考虑优化掉 $O(k)$ 的时间复杂度。容易发现 $O(k)$ 的时间复杂度来自线段数结点合并。

仔细观察我们发现对于 $k$ 位分别进行逻辑运算是非常浪费的，我们考虑将四个大小为 $k$ 的数组压为四个大小为 $2^k$ 的数字，将逻辑运算转变为二进制位运算即可。对应的四个转移变为：

1. `ans.l0 = (a.l0 & b.l1[i]) | (~a.l0[i] & b.l0[i])`
2. `ans.l1 = (a.l1 & b.l1[i]) | (~a.l1[i] & b.l0[i])`
3. `ans.r0 = (b.r0 & a.r1[i]) | (~b.r0[i] & a.r0[i])`
4. `ans.r1 = (b.r1 & a.r1[i]) | (~b.r1[i] & a.r0[i])`

因此合并结点信息的复杂度优化到 $O(1)$，总复杂度达到 $O(m \times \log ^2n)$，足以通过此题。

## 代码

[View on GitHub](https://github.com/Macesuted/Code/blob/main/Luogu/5354.cpp)