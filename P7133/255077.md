这是本蒟蒻的第一篇题解。

出题人题解个人感觉讲得比较简单，这篇题解对细节部分进行一些更细致的解释和说明。

由题意不难发现，本题主要有两个需要实现的部分。对所有的星星按照**逆时针排序**（顺时针也可以），利用**二分查找**计算出一次逆转动过程中他可以让多少星星出现在他正前方。我们知道顺时针转动和逆时针转动看到的星星之和为 $n$，因此可以按逆时针排序二分算得后用 $n$ 作差比较即可。

这篇题解主要介绍逆时针排序的实现。对于点 $P(x,y)$ 先判断其象限（轴线），再将 $x,y$ 取绝对值。对于不同象限的点，可以直接比较即可。同一轴线上的点不用比较，同一象限的点比较斜率的绝对值（x 和 y 已经取过绝对值了）。该部分代码如下，具体看注释。
```cpp
struct Node{
	int x,y;
	int pos; //象限 
}p[N];
//重载运算符
bool operator <(const Node a,const Node b){
	//都在轴线
	if(a.pos==b.pos && a.pos%2==0) return false;
        //都在一或三象限
	else if((a.pos==1||a.pos==5) && (a.pos==b.pos) 
		return (ll)a.y*b.x<(ll)b.y*a.x; //double会掉精度
        //都在二或四象限
	else if((a.pos==3||a.pos==7) && (a.pos==b.pos))
		return (ll)a.y*b.x>(ll)b.y*a.x;
	else return a.pos<b.pos;
}
//判断象限轴线
Node getPos(Node x)
{
	Node p=x;//临时变量
	if(p.y==0 && p.x>0) p.pos=0; //x正半轴  
	if(p.x>0 && p.y>0) p.pos=1;	//第一象限 
	if(p.x==0 && p.y>0) p.pos=2; //y正半轴  	
	if(p.x<0 && p.y>0) p.pos=3; //第二象限 
	if(p.y==0 && p.x<0) p.pos=4; //x负半轴  
	if(p.x<0 && p.y<0) p.pos=5; //第三象限 
	if(p.x==0 && p.y<0) p.pos=6; //y负半轴 
	if(p.x>0 && p.y<0) p.pos=7; //第四象限 
	p.x=abs(p.x);
	p.y=abs(p.y);
	return p;
}

```
二分查找部分只要记录每个方向上星星的数量，该方向上第一颗星星的下标，最后一颗星星的下标存入结构体中，通过lower_bound 和 upper_bound 即可实现获得下标。

最后在线处理转动，记录前一个方向和当前方向。

注意：

1：第一、三象限和二。四象限比较斜率是不同的。

2：统计时可能会小于0，要加 $n$。

3：不要忘记开始和结束的两个方向的星星。

完整代码参见第一篇题解（出题人题解）。