
序：为啥要发这个题解呢 ， 因为我有一些小优化 ， 跑的速度只比开了 $O_{2}$的慢 ， 话说这空间卡的那么死吗(

step1:求出所有每个韵脚再最后的方案数。
考虑性质 由于一行的方案数只和最后一个单词有关系 ， 再看一眼$n 和 k$的数据范围,可以轻松跑dp. 设$f_{i , j}$当前长度为i的方案数 ， 且若$i=k，j$就表示最后一个单词的韵脚。

初始化：$f_{0,0}=1$

$if(i + length_{j}\ne k)\Longrightarrow f_{i + length_{j} , 0} +=f_{i,0}$
$if(i + length_{j}= k)\Longrightarrow f_{i + length_{j} , c_{j}} +=f_{i,0}$

这样我们就愉快的求出来了以每个韵脚当结尾的方案数 。
友情提示：若按照我的状态转移直接做 ， 会MLE因为要开一个二维数组 ， 其实只要再拿一个一位数组来代替第二维就可以惹~（雾。

```cpp
	f[0] = 1 ;
	for (int i = 0 ; i <= k ; i ++) {
		for (int j = 1 ; j <= n ; j ++) {
			if (i + p[j].len > k) continue ;
			else if (i + p[j].len == k) {
				G[p[j].c] = (f[i] + G[p[j].c]) % mod ;  
			}
			else if (i + p[j].len < k) {
				f[i + p[j].len] = (f[i] + f[i + p[j].len]) % mod ;

			}
		}
	}
```


 step2:求出答案。
对于每行的韵脚要求 ， 我们可以知道对于$ch_{i}$可以是任意一个韵脚 ， 只需要简单的乘法原理就可以轻松求出惹 
即：
$ans = \prod_{i=1}^{m} {\sum_{j = 1}^{n}G_{j}^{cnt_i}}$ 当然对于每种字母 ， 我们只能算一次。
 快速幂优化即可求出ans~
 
这个小优化其实很简单 ， 也就是说我们对于相同字母的$cnt_{i}$贡献自然也是一样的 ， 我们可以用记忆话搜索的思想进行优化即可。
