非常 naive 的完全背包求方案数的问题。

这题的转移太过明显，而我的做法人菜常数大，所以有点 naive。

由于一个单词的韵脚只决定最后一个单词，所以倘若你有一个转移，如果你是将韵脚与方案数为参数的方程，那么它可以非常好的从任意韵脚的方案转移。

所以，我们的转移应该有两个：

1. $f[i]$ 表示长为 $i$ 的诗句方案数。
	
   这个是次要的转移，用于辅助我们的主转移。
   
   状态转移非常显然：
   
   ```cpp
	f[i]+=f[i-a[j]]
	```

2. $s[i][j]$ 表示长为 $i$ 的诗句韵脚为 $j$ 的方案总数。

	由于 $s[i][j]$ 可以从任何韵脚转移，所以需要弄一个 $f$ 数组来统计。
    
    状态转移可以像这样：
    
    ($f,s$ 数组如上所述，$a$ 数组为单词长度)
    
    ```cpp
	s[i][c[j]]+=f[i-a[j]]

	```
然后对于后面描述的 Bessie 的想要的押韵模式搞一个桶装进去。

然后等状态转移完后将 $i$ 从 $'a'\to 'z'$ 跑一遍，看看桶内是否有东西，若有，则将 $j$ 从 $1\to n$ ，查询 $s[k][j]$ 是否为空，若行则返回 $s[k][j]$ 的某次方，这里的“某”指当前 $i$ 所指向的桶内的要求个数。$ans$ 累乘。

然后是这道题恶心的地方。

可能是我的做法太 naive 了，不知道为什么总是 $\mathtt{MLE}$。

一开始 ```#define int long long```的，然后 $\mathtt{MLE}$了 $6$ 个点，然后去掉后又 $RE$，最后将 $ans$ 和快速幂 开 $long\ long$后过了。

可是空间依旧大的离谱，$\mathtt{96.13MB}$。我看了一下其他人的提交记录全几乎没有（好吧还是有一两个）像我这样空间特大时间也是压线过的。不过能过就行。

人菜常数大，naive 的做法。
    
