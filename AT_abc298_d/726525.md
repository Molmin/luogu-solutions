博客体验区：https://www.luogu.com.cn/blog/zhangjinxuan/solution-at-abc298-d


本蒟蒻的第一篇题解，若什么地方不太正确，欢迎批评指出\~



## 原题大意

[原题链接](https://www.luogu.com.cn/problem/AT_abc298_d)

你要维护一个数字 $S$，起初，$S = 1$

现在你要按顺序来处理以下 $Q$ 次其一操作：

1. `1 x`  在 $S$ 的末尾添加非零数字 $x$
2. `2` 删掉 $S$ 的首位数字
3. `3` 输出 $S$ 的十进制表示，对 $998244353$ 取摸

最关键的数据范围：$1 <= Q <= 600000$

## 题目分析

首先，我们可以想一想，如果没有对 $998244353$ 去摸，也假设 C\+\+ 可以给我们存储很大的数字，我们该怎么做呢？

我们可以先记一个变量 `ans`，表示答案，**`ans` 一开始肯定要设为 $1$**。

- 如果是 1 操作，我们直接执行 `ans = ans * 10 + x` 就行。

- 如果是 2 操作，我们先获取 `ans` 的首位数字，并且获取它的所在位(从右往左），分别存储到 $x, y$，最后 `ans` 减去 `x * pow(10, y - 1)` 即可。

例如，我们设现在 `ans` 为 $114514$，我们得到的 $x, y$ 也就是 $1, 6$，`ans` 就减去 $1 \times 10^{6 - 1}$，也就是 $100000$，`ans` 减去这个数，刚好就是 $14514$。

- 如果是 3 操作，直接输出即可。



现在我们就有 1 个大问题：

**直接获取的复杂度是线性的，而线性会 TLE，所以，如何用 $O(1)$ 的时间复杂度获取 2 操作所需的首位数字以及所在位？**

这种情况我们就要使用一个新的容器来维护这个数字了，可以用什么呢？

对了！是**队列**！

我们获取首位数就是 `queue[front]`，而所在位数就是 `rear - front + 1` !

只要我们在操作一顺便 `queue[++rear] = x`，操作二执行完 `++front` 就能愉快地维护起这个队列啦！

同时，**不要忘了**一开始要 `queue[rear = front = 1] = 1` ……

然后加上取摸运算，也很简单，只要在适当的位置对 $998244353$ 取余即可。

例如，操作 1 执行完 `ans %= 998244353`，操作 2 中的 `x, y` 分别对它取余，`ans` 减了之后也对它取余……

不过，这样做仍然有一个问题，`ans` 执行操作 2 是可能会变成**负数**，但 C++ 普通的取余运算得到的结果也不是我们想的那样，所以，**我们还要自己写一个取余的函数**，具体实现见代码。

## 正解代码

本人在获取二操作的 $y$ 索性直接建了个变量 `len`，获取 `x * pow(10, y - 1)` 这一步骤也用了一个 $p$ 数组来算 ($p_i = 10^i \mod 998244353$，这样是为了更加方便，效率更高。

```cpp
#include <bits/stdc++.h>
using namespace std;

int q, st[600005], front, rear; // st 为队列
long long p[600005]; // p[i] = 10^i % 998244353
const long long mod = 998244353;
long long ans = 1; // 答案
int opt, n, len = 1; //len 表示当前数字长度，也就是 floor(log10(ans)) + 1

long long mymod(long long x) { //自定义的 mod 函数
	if (x >= 0) return x % mod; // 整数直接 mod
	else {
		return mod - (labs(x) % mod); //否则，就应该用绝对值来 mod，还要被模数减
	}
}

int main() {
	p[0] = 1; //10^0 = 1
	for (int i = 1; i <= 600004; ++i) {
		p[i] = p[i - 1] * 10;
		p[i] %= mod;
	}
	st[rear = front = 1] = 1; //一开始的数字是 1
	scanf("%d", &q);
	long long x = 0;
	while (q--) {
		scanf("%d", &opt);
		if (opt == 1) {
			scanf("%d", &n);
			ans = ans * 10 + n;
			ans %= mod; //注意模，这里无需考虑正负数
			st[++rear] = n;
			++len; //长度加了一个
		} else if (opt == 2) {
			x = st[front++]; //获取第一个数字
			x *= p[len - 1]; //获取应该要减去的数（这里似乎忘了 %，但好像没问题）
			--len; //长度减了一个
			ans -= x; 
			ans = mymod(ans); //这里可能是负数，必须用自定义的来模
		} else {
			printf("%lld\n", ans); //直接输出
		}
	}
	return 0; //愉快AC
}
```

本人 AC 记录：https://www.luogu.com.cn/record/108220243

### 注意 long long ！因为可能会爆 int！


## 总结

还是一道很普通的数学题，对取余运算这一块得要充分掌握，例如取余运算的分配律等等。