[题面传送门](https://www.luogu.com.cn/problem/CF317A)

**简要题意：**

定义一对数 $(x,y)$，若 $x$，$y$ 中至少有一个大于等于 $m$，则称 $(x,y)$ 对 $m$ 完美。

现在给定一对数 $(x,y)$，允许把其中的一个数换成 $x+y$，问把 $(x,y)$ 变成对 $m$ 完美的数对至少需要几次操作，如无解，输出 $-1$。

**解题思路：**

首先需要两个特判：

- 如果 $x$ 和 $y$ 均小于 $m$ 且小于等于 $0$，那么无论怎么加都无法大于等于 $m$，直接输出 $-1$。

- 如果 $x$ 和 $y$ 本身就有至少一个数大于等于 $m$，那么不用加，直接输出 $0$。

此部分代码：

```cpp
if(x>=m || y>=m) {
	cout << 0 << endl;
	return 0;
}
if(x<=0 && y<=0) {//这里因为前面判断 x 或 y 大于等于 m 就 return 0,所以不用判断 x<m && y<m 
	cout << -1 << endl;
	return 0;
}
```

然后易知，两数相加应把大数加到小数上，举例：

样例 $2$：$x=-1$，$y=4$，如果把 $x$ 加到 $y$ 上，$y=-1+4=3$，不大反小，不可行。而如果把 $y$ 加到 $x$ 上，$x=-1+4=3$，将负数 $x$ 变成了正数，使操作次数减小。

样例 $1$：虽然 $x$ 与 $y$ 都是正数，但如果对 $y$ 进行操作，$y=1+2=3$，此时 $x+y=1+3=4$。如对 $x$ 进行操作，$x=1+2=3$，此时 $x+y=3+2=5$，$5>4$，所以对 $x$ 操作更优。

综上所述，易证进行操作时将大数加到小数上为更优解。

然后，`while` 循环，当 $max(x, y) < m$ 时，执行操作，将大数加到小数上，次数计数器加一。

最后输出次数计数器即可。

但是，注意数据范围：$-10^{18} \leq x, y, m \leq 10^{18}$，十年 OI 一场空，不开 `long long` 见祖宗！

**AC Code:**

```cpp
#include <bits/stdc++.h>
using namespace std;
int main() {
	long long x, y, m, ans=0;
	cin >> x >> y >> m;
	if(x>=m || y>=m) {
		cout << 0 << endl;
		return 0;
	}
	if(x<=0 && y<=0) {//这里因为前面判断 x 或 y 大于等于 m 就 return 0,所以不用判断 x<m && y<m 
		cout << -1 << endl;
		return 0;
	}
	while(max(x, y)<m) {
		if(x<=y)
			x += y;
		else
			y += x;
		ans++; 
	}
	cout << ans << endl;
	return 0;
}
```

最后的最后，切勿抄袭，棕名两行泪！