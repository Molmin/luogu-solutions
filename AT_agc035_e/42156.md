题意可以转化为，删掉的数 $x\to x-2,x+K$ 连边，不存在环（若不存在，按逆拓扑序删除即可；若存在，这些数都不能删除）

如果 $K$ 是偶数，奇偶分别 dp 即可，以下默认 $K$ 是奇数。

可以发现，不存在环等价于，把所有删了的数在一个长度为 $n$ 的 01 串中设为 1，不存在形如 `1*1*1*..1*11..11*1*1*1...*1` 的子串（`*` 匹配任意**一个**字符，中间 `1` 的个数为大于等于 $3$ 的奇数，上面字符串中不算 `*`，总 `1` 数恰为 $K+2$）

把奇数位置、偶数位置排成两行，那么就是不能存在以下图形（也不能存在以下图形反过来）：

```
... 1 1 1 1 1 1 1 ... 
(m 个 1)
... ? 1 1 1 1 ? ? ... 
(至少有 K+2-m 个 1，下面的对称中心是上面的对称中心左移 0.5 格)
```

或者

```
... ? ? 1 1 1 1 ? ... 
(至少有 K+2-m 个 1，下面的对称中心是上面的对称中心左移 0.5 格)
... 1 1 1 1 1 1 1 ... 
(m 个 1)
```

这个做法的后半部分是神仙 crn 教我的，orz crn！

设 $f(p,i,j,k)$ 表示现在算到了第 $p$ 个位置，和 $p$ 奇偶性相同的一行自从 $i$ 以来就全是 1，和 $p$ 奇偶性不同的一行从 $j$ 以来就全是 1 的前 $p$ 个位置，

- $i<j$：目前的限制是和 $p$ 奇偶性相同的一行最右边至多能填到 $k$ 的方案数。
- $i>j$：目前的限制是和 $p$ 奇偶性不同的一行最右边至多能填到 $k$ 的方案数。

转移：

- $f(p,i,j,k)\to f(p+1,n+1,i,?)$（不填第 $p+1$ 个位置，$?$ 的位置如果 $i<j$ 就是 $k$ 否则是 $n+1$）
- $f(p,i,j,k)\to f(p+1,\min(p+1,j),i,\min(k,R))$（$i<j$，填第 $p+1$ 个位置，拿 $[i,p]$ 和 $[j,p+1]$ 算出来 $p$ 这一行最多能填到 $R$ ）（$i>j$，填第 $p+1$ 个位置，拿 $[i,p]$ 和 $[j',p+1]$ 算出来 $p+1$ 这一行最多能填到 $R$，要求 $\min(k,R)\ge p+1$）

这里附一个有详细注释 dp 的代码，因为真的很容易写错！（调了一晚上）

```cpp
for(int i=n+1;i>=1;i--){
	if(i!=n+1&&(i%2!=p%2||(i<=n&&i>p)))continue;//=n+1 表示没限制
	for(int j=n+1;j>=1;j--){
		if(j!=n+1&&(j%2==p%2||(j<=n&&j>p)))continue;
		for(int k=1;k<=n+1;k++){
			if(!f[P][i][j][k])continue;//P,Q 是滚动数组，其实 P=p,Q=p+1
			if(i<j){//假如限制在 i 这个奇偶性上，那么就算不填 p+1 这个限制仍然存在
				if(p<k)upd(f[Q][n+1][i][k],f[P][i][j][k]);
			}
			else upd(f[Q][n+1][i][n+1],f[P][i][j][k]);//否则就没限制了
			int R=n+1,J=min(j,p+1);
			if(i<J){//这里是算 R 的过程，i<J 说明 p 这边长一些
				int s=(p+1-J)/2+1;//算出 [J,p+1] 之间有几个 1
				int u=K+2-s,s2=(p-i)/2+1;//还剩 u 个 1 要填在 p 这边，已经填了 s2 个
				if(s2-s>=(u-s-1)/2)R=p+(u-s+1);
				//s2-s 是 p 这边左边延伸出去的长度，(u-s-1)/2 是需要的长度
				//只有已经填上的 >= 需要的，才会有限制
				//经过观察可以发现，左边需要伸出去 (u-s-1)/2，右边需要伸出去 (u-s+1)/2
				//“伸出去 x” 其实在坐标上相当于坐标 +2x，所以新限制是 p+(u-s+1)/2*2
			}
			else if(i!=n+1){//下面同理
				int s=(p-i)/2+1;
				int u=K+2-s,s2=(p+1-J)/2+1;
				if(s2-s>=(u-s+1)/2)R=p+1+(u-s-1);
			}
			if(min(k,R)<=p+1)continue;
			upd(f[Q][J][i][min(k,R)],f[P][i][j][k]);
		}
	}
}
```

时间复杂度 $O(n^4)$。（这好像是 AGC 标算）