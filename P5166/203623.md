线段树板子了，区间推平 $0$ 区间求和。

好恶心啊，，tag 习惯变 $0$，然后这道题因为有 $0$ 所以不行。。。

最后说说自己的想法：手写平衡树维护珂朵莉树区间长度和或许可以做到随机数据单次操作 $O(\log\log n)$？即只维护极长连续段为 $1$ 的，然后对于区间查询直接求 $[l,r]$ 内的极长连续段长度和（边角分类讨论）。复杂度在最差数据下似乎都是对的 $O(\log n)$。。。

---

UPD：次天想到一种树状数组做法。

原本树状数组可能很难（？维护区间推平操作，但是这题有个很好的性质：区间推平的是 $0$。这就意味着对于每个数只用操作一次（因为 $0$ 对区间和没有影响）。这就意味着可以把区间所有的 $1$ 提取出来然后树状数组暴力修改。

因为每个数最多被操作 $1$ 次，所以修改的总复杂度为 $O(n\log n)$，均摊下来每次修改操作 $O(\log n)$。至于查询操作直接上求和严格 $O(\log n)$。

如何取出区间中所有的 $1$?这个用个并查集就好了。

关键代码：

```cpp
w=f[n+1]=n+1;
	for(i=n;i>=1;i--)
		f[i]=w=(a[i]=!a[i])?i:w;
	for(i=1;i<=n;i++)
		bit[i]=(pre[i]=pre[i-1]+a[i])-pre[i-lowbit(i)];
	sum=pre[n];
	while(m--)
	{
		opt=read(),l=read(),r=read();
		if(opt==2)
		{
			for(read(),i=find(l);i<=r;i=find(i))
				sum--,add(i,-1),f[i]=find(f[i+1]);
		}
		else
			printf("%d\n",sum-(ask(r)-ask(l-1)));
	}
```

好写好记常数小哟~