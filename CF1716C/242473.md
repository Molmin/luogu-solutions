本来以为这道题蛮简单的，结果调了半天（~~好吧是因为我菜~~）

这道题有两个关键点，还需要一点点想象力。

$Update\ 2022/8/8$ 这题不用开`long long`，下文有关内容请忽视。

### Num 1

第一步考虑怎么走。

因为一个格子不能走两遍及以上，而且只有两行，说明走网格的时候是**不能中途往回走**的，所以可以想到只有两种走法：

第一种两行同时走，具体地说，就是先向下、向右、向上、向右，再向下、向......这样扭曲地走；

第二种就是某一行一直向右走，碰到边界调头从另一行一直往左走。

因为**不能中途往回走**，所以一定是先按第一种方法走，再按第二种方法走。

### Num 2

第二个关键点是如何消除 $a_{i,j}$ 的影响。

先不考虑第一种走法，只考虑第二种（因为第一种走法路线是确定的，所用的时间可以一边走一边算）。

某个格子经过 $a_{i,j}$ 时间后才开启，开启后就不会再关上，所以我们可以不用走到格子面前再等格子解锁，而是先等一段时间，再按路线前进，**确保我们走到任何一个格子时都已经解锁**。

这样的好处就是不用走一会儿等一会儿，可以先等然后一直走——换句话说，这样就可以预处理等的时间，然后直接加上路程就是总时间。

这样这道题目就比较明朗了：预处理从第 $a$ 行第 $b$ 列这个格子开始实行第二种走法至少需要等待多少时间，然后枚举按第一种走法走到哪一列，沿途计算答案。

### Num 3

下文 $f_{i,j}$ 代表从第 $i$ 行第 $j$ 列开始使用第二种走法需要等待的最少时间，我把向右走再调头向左走按两个部分拆开计算。

预处理：

```cpp
a[0][1]=-1;//方便计算
f[0][n]=a[0][n],f[1][n]=a[1][n];
for(int i=0;i<=1;i++)
	for(int j=n-1;j>=1;j--)
		f[i][j]=max(f[i][j+1]-1,a[i][j]);
```
到这里为止处理了从第 $i$ 行开始一直向右走需要的等待时间
```cpp
f[0][n]=max(a[1][n]-1,a[0][n]);
f[1][n]=max(a[0][n]-1,a[1][n]);
for(int i=0;i<=1;i++)
	for(int j=n-1;j>=1;j--)
		f[i][j]=max(f[i][j+1]-1,max(a[i^1][j]-2*(n-j)-1,a[i][j]));
```
到这里为止就是完整的 $f_{i,j}$ 计算过程，其中

`f[i][j]=max(f[i][j+1]-1,max(a[i^1][j]-2*(n-j)-1,a[i][j]))`

这一步需要读者自己理解一下，我语文比较差，说不清楚。

接下来就是从头按第一种走法边走边计算时间，其中的 $p$ 记录现在在第 $p$ 行。
```cpp
int ans=f[0][1]+2*n,rec=a[1][1]+1;
for(int i=2,p=1;i<=n;i++,p^=1)
{
	rec=max(rec+1,a[p][i]+1);
	rec=max(rec+1,a[p^1][i]+1);
}
```
所以，只需要在上面的过程中顺便计算答案并记录最小答案即可。

### Num4

完整代码如下，没有挖坑，码风丑陋，凑活着看吧。


```cpp
#include<iostream>
#include<cstdio>
#define int long long
using namespace std;
const int N=2e5+5;
int T,n,a[2][N],f[2][N];
int G(int x){ return x>0?x:0ll; }
void solve()
{
	scanf("%lld",&n);
	for(int i=0;i<=1;i++)
		for(int j=1;j<=n;j++)  scanf("%lld",&a[i][j]);
	a[0][1]=-1;
	f[0][n]=a[0][n],f[1][n]=a[1][n];
	for(int i=0;i<=1;i++)
		for(int j=n-1;j>=1;j--)
			f[i][j]=max(f[i][j+1]-1,a[i][j]);
	f[0][n]=max(a[1][n]-1,a[0][n]);
	f[1][n]=max(a[0][n]-1,a[1][n]);
	for(int i=0;i<=1;i++)
		for(int j=n-1;j>=1;j--)
			f[i][j]=max(f[i][j+1]-1,max(a[i^1][j]-2*(n-j)-1,a[i][j]));
	int ans=f[0][1]+2*n,rec=a[1][1]+1;
	for(int i=2,p=1;i<=n;i++,p^=1)
	{
		ans=min(ans,rec+G(f[p][i]-rec)+2*(n-i+1));
		rec=max(rec+1,a[p][i]+1);
		rec=max(rec+1,a[p^1][i]+1);
	}
	ans=min(ans,rec);
	printf("%lld\n",ans);
}
signed main()
{
	scanf("%lld",&T);
	while(T--)  solve();
return 0;
}
```
撒花。