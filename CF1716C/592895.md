题意：
>在 $2\times n$ 的网格中，$(i,j)$ 格子需要时间超过 $a_{i,j}$ 才能踏上。你（机器人）一开始在 $(0,0)$，每一秒钟你可以上下左右在网格中移动（也可以不动），问你把所有格子经过一次且只经过一次所花的最少时间是多少。

（为了方便，横纵下标均从 $0$ 开始。）

考场思路。

首先考虑机器人怎么走才能做到题目要求：把所有地方经过一次且只经过一次。

简要分析后 $%~~（分析过程略）~~$ 可以得出以下结论：

机器人需先盘旋前进若干格，然后一条路往右走到尽头，掉头，把剩下的一条路走完。如下图是 $n=8$ 时机器人可能的 $4$ 种路线：

![](https://cdn.luogu.com.cn/upload/image_hosting/e7cl69yx.png)


$%容易发现，$终点只能在如下所示未染色格子里，且位置 $(i,j)$ 满足 $(i+j)\operatorname{and}1=1$。
（$\operatorname{and}\text{为 位与 运算符}$）

![](https://cdn.luogu.com.cn/upload/image_hosting/lz65tmnu.png)



**那么我们就可以预处理出盘旋前进到某个格子最少花费的时间，和笔直走花费的时间。**

设 $d_{i,j}$ ~~kstra~~ 为盘旋前进到达该点所花时间（仅限染色格子）；

$m_{i,j,k}=\begin{cases}\text{从 (i,0)点 从左往右走到该点所花时间},k=0\\\text{从 (i,n-1)点 从右往左走到该点所花时间},k=1\end{cases}$
```cpp
n=read();
for(int i=0;i<2;i++)for(itn j=0;j<n;j++)a[i][j]=read();
for(int i=0;i<2;i++)for(itn j=0;j<=n;j++)
	d[i][j]=M[i][j][0]=M[i][j][1]=0;//清零，但实际上大部分并没有什么用
for(int j=1;j<n;j++)// **d=0.
	d[j&1][j]=max(max(
	a[j&1][j]+1,a[j&1][j-1]+2),d[!(j&1)][j-1]+2);
***M=0;
for(int i=0;i<2;i++)for(int j=0;j<n;j++)//适当越点界应该没事吧（
	if(i||j)M[i][j][0]=max(M[i][j-1][0]+1,a[i][j]+1);
//if(i||j)：避免计算M[0][0][0],因为一旦计算其值就会变成1。
for(int i=0;i<2;i++)for(int j=n-1;~j;j--)
	M[i][j][1]=max(M[i][j+1][/*0*/1]+1,a[i][j]+1);
```
关于上面越界部分无影响的证明：**（越界肯定有风险，正规比赛请勿轻易尝试！）**

越界只会在 $i=1,j=0$ 时发生，此时访问 `M[i][j-1][0]` 应该越到了 `M[0][N-1][0]`（~~《应该》~~），这里是肯定没用到的，所以值为初始值（$0$）；又 $a_{i,j}+1\geqslant1$ 所以 `M[i][j][0]=max(M[i][j-1][0]+1,a[i][j]+1);` 中 `M[i][j-1][0]+1`（其值为 $1$）肯定没贡献。

然后枚举终点统计答案即可。
```cpp
int ans=0x3f3f3f3f;
for(int j=0;j<n;j++){//枚举终点：(!(j&1),j)
	int _1_=d[j&1][j],//先盘旋前进若干格
		_2_=max(_1_+(n-1-j),M[j&1][n-1][0]),//然后一条路往右走到尽头
		_3_=max(_2_+(n-1-j+1),M[!(j&1)][j][1]);//掉头，把剩下的一条路走完
	ans=min(ans,_3_);
}
return printf("%d\n",ans);
```
证明：因为盘旋前进到一个点然后直着往右走的时间肯定不小于直接走过去的时间，因为盘旋前进走的格数会更多。

所以在上面 `_2_` 直接取 $\max$ 的决策是正确的：盘旋前进到一个点然后直着往右走到头的时间就是等于 `M[j&1][n-1][0]`，或者前面耗的时间多，等于 `_1_+(n-1-j)`。

`_3_` 同理。

总时间复杂度为 $\mathcal O(n)$，足以通过此题。

最后，警钟长鸣！复制代码后看一下是不是所有地方都改过来了！
```cpp
for(int i=0;i<2;i++)for(int j=0;j<n;j++)
	if(i||j)M[i][j][0]=max(M[i][j-1][0]+1,a[i][j]+1);
for(int i=0;i<2;i++)for(int j=n-1;~j;j--)
	M[i][j][1]=max(M[i][j+1][   0   ]+1,a[i][j]+1);
```
这个地方调了半小时qwq