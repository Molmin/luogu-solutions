# 题意

给定$n$个非负整数 $a_1,\dots,a_n$ ，每次操作可以选定任意两个下标不同的非负整数 $a_i,a_j$ ，向序列中加入两个新的数 $a_i\text{ AND } a_j,a_i\text{ OR } a_j$ 并删除原来的两个数。其中 $\text{AND,OR}$ 分别是按位与，按位或操作。

求若干次操作后 $\sum_{i=1}^na_i^2$ 的最大值

# 思路

考虑二进制下任意两个数

$$
\begin{matrix}
a=(1010111)_2&a \text{ AND } b=(0000100)_2 \\
b=(0101100)_2&a \text{ OR }b=(1111111)_2
\end{matrix}
$$

可以发现，对于每次操作，相当于每一位上的$1$都“往下坠”落到了或的结果上。只有两个数那一位上都是$1$的那一位与的结果才会是$1$

~~（感觉在说废话）~~

记 $c=a\text{ AND } b,d=a\text{ OR } b$ ，那么操作一次之后平方和就会增加 $c^2+d^2-a^2-b^2=(d^2-b^2)-(a^2-c^2)=(d+b)(d-b)-(a+c)(a-c)$

观察，发现 $d-b=a-c$。因为 $d$ 拥有 $a,b$ 所有的 $1$ ，减去 $b$ 就剩下仅 $a$ 拥有的 $1$ 。同样 $c$ 拥有 $a,b$ 共有的 $1$ ，用 $a$ 减它就剩下仅 $a$ 拥有的 $1$ 。

因此记 $d-b=a-c=x$，显然或的结果不会小于原数，与的结果不会大于原数，因此 $x\geq 0$

那么平方和增量可以表示为 $(d+b-a-c)x$，只要 $b-a$ 非负那么这次操作就是不亏的。

同样，如果在拆平方和增量的时候我们写成 $(d^2-a^2)-(b^2-c^2)$，并记 $d-a=b-c=y$ 的话，我们可以得到 $y\geq 0$ ，并且平方和增量可以表示为 $(d+a-b-c)y$ 。只要 $a-b$ 非负那么这次操作也不亏。

所以说，每次操作都是不亏的，只要能操作就一直操作好了。

怎么样操作就是无效的呢？比如 $a,b$ 有其中一个是 $0$ 时，操作就没有必要了。或者按位或的结果等于原来某一个数时，无论哪一位上的 $1$ 都不能落下来，所以操作也是无效的。

那么当一个数拥有能拥有的所有的 $1$ 时，他就可以被宣判无效了。这个时候他已经做出了最大贡献。对于 $n$ 个数，都做它的最大贡献，得到的结果就是最大的。

这么说我们可以把 $n$ 个数的二进制位有多少个 $1$ 存下来，然后能取 $1$ 就取，最后得到的总和就是最大的。

期望时间复杂度 $\mathcal O(n\log_2n)$

```cpp
#include <cstdio>

int n,a[21],x;
long long int ans;

int main() {
	scanf("%d",&n);
	for(int i=1;i<=n;++i) {
		scanf("%d",&x);
		for(int j=0;x;++j) {
			a[j]+=x&1;
			x>>=1;
		}
	}
	for(int i=1;i<=n;++i) {
		x=0;
		for(int j=0;j<21;++j) if(a[j]) x|=1<<j,--a[j];
		ans+=1ll*x*x;
	}
	printf("%lld\n",ans);
	return 0;
}
```

