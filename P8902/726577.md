构造题。我们不妨设 $a _ 1 = 0, a _ 2 \ge a _ 1$。

我们可以从第 $2$ 列入手，即 $r _ {i - 1, i} = |a _ i - a _ {i - 1}|$，我们把这个值设为 $c _ i$。

### 法一

我们知道当 $i \ge 2$ 时，$a _ i = a _ {i - 1} \pm c _ i$。我们枚举其中的 $\pm$ 符号，即加减都试一遍。

试验时可以暴力计算输入数据 $1 \sim i - 1$ 行的第 $i$ 项（$\max a[j \cdots i] - \min a[j \cdots i]$），用来确定 $a _ i$ 取此值时是否满足输入性质。

时间复杂度 $\Theta (n ^ 3)$，因为 $1 \le n \le 300$ 所以可以过。

### 法二

先来看一组样例：

```
5
0 1 3 3 3
0 2 2 2
0 1 2
0 1
0
```

我们可以先设 $a _ 1 = 0$。

![](https://s1.ax1x.com/2022/12/18/zqi66s.png)

因为我们设 $a _ 2 \ge a _ 1$，所以 $a _ 2 = a _ 1 + c _ 2 = 0 + 2 = 2$。

因为 $a _ 3 = a _ 2 \pm c _ 3$，所以 $a _ 3 = 1 \pm 2 = -1$ 或 $3$。

$a _ 3$ 的位置需结合第 $1$ 行（箭头）来确定。可以看出，当 $a _ 3 = 3$ 时，$r _ {1, 3} = 3$；而当 $a _ 3 = -1$ 时，$r _ {1, 3} = 2$。故 $a _ 3 = a _ 2 + c _ 3 = 1 + 2 = 3$。

**这启发我们一种思路，先试一试 $a _ i = a _ {i - 1} + c _ i$ 时 $r _ {1, i}$ 是否等于 $a _ i - a _ 1$，如果等于那么 $a _ i = a _ {i - 1} + c _ i$，否则 $a _ i = a _ {i - 1} - c _ i$（题目保证有解）。**

按照这个道理，$a _ 4 = a _ 3 - c _ 4 = 3 - 1 = 2$。

但是这种思路并不一定正确，例如下面例子：

![](https://s1.ax1x.com/2022/12/18/zqihkT.png)

$a _ 5$ 已经不能用这种思路来做了，因为 $r _ {1, 5}$ 不一定等于 $a _ 5 - a _ 1$！**我们发现此时 $a _ 1 \sim a _ 4$ 不再是依次从左到右或从右到左排开，于是我们决定舍去 $a _ 1$ 和 $a _ 2$，这样 $a _ 3 \sim a _ 4$ 又变成从右到左依次排开了**。

既然舍弃 $a _ 1, a _ 2$，$a _ 5$ 则要结合第 $3$ 行（箭头）来确定，具体来说就是 $r _ {3, 5}$。由于此时是从右往左依次排开，这时则要与上文的思路 **相反，先试一试 $a _ i = a _ {i - 1} - c _ i$ 时 $r _ {1, i}$ 是否等于 $a _ 3 - a _ i$，如果等于那么 $a _ i = a _ {i - 1} - c _ i$，否则 $a _ i = a _ {i - 1} + c _ i$（题目保证有解）。**。

很显然，$a _ 5 = a _ 4 - c _ 5 = 2 - 1 = 1$。

这启发我们一个完整的思路：**刚开始 $a _ 1$“参照行”第 $k$ 行中 $k = 1$，方向为数轴上正方向。当方向为正方向时，先将 $a _ i$ 定为 $a _ {i - 1} + c _ i$，判断 $r _ {k, i}$ 是否为 $a _ i - a _ k$，是则 $a _ i = a _ {i - 1} + c _ i$；否则 $a _ i = a _ {i - 1} - c _ i$，并令 $k = i - 1$，把方向调为负方向。当方向为负方向时，先将 $a _ i$ 定为 $a _ {i - 1} - c _ i$，判断 $r _ {k, i}$ 是否为 $a _ k - a _ i$，是则 $a _ i = a _ {i - 1} - c _ i$；否则 $a _ i = a _ {i - 1} + c _ i$，并令 $k = i - 1$，把方向调为正方向**。这样就能保证 $k \sim i$ 为依次从左往右或从右往左排开。

时间复杂度 $\Theta (1)$，加上输入就是 $\Theta (2)$。

### AC Code

```c++
#include <cstdio>
#define N 305
using namespace std;

int n, pos = 1, c[N], ans[N], a[N][N];

int main ()
{
	scanf ("%d", &n);
	for (int i = 1; i <= n; i ++)
	{
		for (int j = i; j <= n; j ++)
		{
			scanf ("%d", &a[i][j]);
		}
		if (i < n)
		{
			c[i + 1] = a[i][i + 1]; // 处理 c 数组
		}
	}
	for (int i = 2; i <= n; i ++)
	{
		if (ans[i - 1] >= ans[pos]) // 正方向
		{
			if (ans[i - 1] + c[i] - ans[pos] == a[pos][i])
			{
				ans[i] = ans[i - 1] + c[i]; // 符号为“+”
			}
			else
			{
				ans[i] = ans[i - 1] - c[i], pos = i - 1; // 符号为“-”，并将 k 调为 i - 1
			}
		}
		else // 负方向
		{
			if (ans[pos] - (ans[i - 1] - c[i]) == a[pos][i])
			{
				ans[i] = ans[i - 1] - c[i]; // 符号为“-”
			}
			else
			{
				ans[i] = ans[i - 1] + c[i], pos = i - 1; // 符号为“+”，并将 k 调为 i - 1
			}
		}
	}
	for (int i = 1; i < n; i ++)
	{
		printf ("%d ", ans[i]);
	}
	printf ("%d", ans[n]);
	return 0;
}
```