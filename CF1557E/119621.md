这一个可以踩标算的做法。

考虑维护一个 $8\times 8$ 的 $01$ 矩阵表示当前国王可能在的位置，目标即为把它变成全 $0$。

初始将皇后放在 $(1,1)$。

假设当前皇后的位置为 $(x,y)$，那么考虑两种情况：

- 如果第 $x+1$ 行没有 $1$，那么让皇后走到 $(x+1,y)$。

- 如果第 $x+1$ 行有 $1$，设为 $(x+1,p)$，那么让皇后走到 $(x,p)$。

重复这个过程即可。

**正确性证明：**

设 $\phi_1$ 为剩下 $1$ 的个数，$\phi_2=8-x$。

- 如果第 $x+1$ 行没有 $1$，此时我们花费 $1$ 步的代价使 $\phi_2$ 减少 $1$。

- 如果第 $x+1$ 行有 $1$：

  - 如果国王的行动是 `Down-Left` 或者 `Down-Right`，那么此时第 $x+1$ 行一定没有 $1$，于是下一步中皇后会走到 $(x+1,y)$。此时我们花费 $2$ 步的代价使 $\phi_2$ 减少 $1$。

  - 如果不是，那么说明原来的 $(x+1,p)$ 位置一定不是国王。此时我们花费 $1$ 步的代价使 $\phi_1$ 减少至少 $1$。
  
初始 $\phi_1=63,\phi_2=7$，因此这个算法的理论步数上界为 $\phi_1+2\phi_2=77$。实际上这个上界根本不可能达到，不进行任何细节优化的情况下在官方数据下 $20$ 步以内完全能够解决，大部分都在 $15$ 步以内。

此算法的细节处还有可以进行优化的地方（没有必要）：

- 如果有多行都全 $0$，直接全部跳过。

- 第二种情况中如果国王的行动是 `Down-Left` 或者 `Down-Right`，那么直接模仿它的行动。

代码写的很丑陋，放上来有失优美性（

真的看懂了的话代码实现一点难度都没有吧（