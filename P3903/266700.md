我感觉这道题比导弹拦截简单的多，可能是因为当初优化导弹拦截200考虑的比较多吧。不废话，我们需要考虑的其实只是已拦截的最后一刻导弹。为什么？给你一个5 2 8的序列，你肯定会拦截5 2 8，而不是只拦8，原因就是中间有2作为缓冲，2前面是多少对后面都不影响。不如利用一个数组保存当下可拦截的最优解（可以不用的，楼主懒得写了），然后用一个变量记录拦截的导弹数目，如果能拦截就予以拦截（毕竟我们求最多拦截多少），不能拦截就更新，以便拦截到更多。
上代码
```
#include<iostream>
using namespace std;
int a[1001];
int main() {
	int x=0,n=1,N=0;
	cin>>N;cin>>a[1];
	for (int i=2;i<=N;++i) {
		cin>>x;
		if(n%2==0) 
			if(x>a[n]) a[++n]=x;
			else a[n]=x;	
		else if(x<a[n]) a[++n]=x;
			else a[n]=x;
	}
	cout<<n;
	return 0;
} 
```

举个例子 1 5 3 8 7
第一轮  1        n=1
第二轮  5        n=1
第三轮  5 3       n=2
第四轮  5 3 8      n=3
第五轮  5 3 8 7    n=4（绝对是最多的，时间上应该也是最优的）
 第一次发题解，留个纪念