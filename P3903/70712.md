## 前言
这道题用DP或贪心都行，不过看题解里的DP时间复杂度都是 $O(n^2)$ ，补充一种 $O(n)$ 的方法。
如有不当之处，请指正。
## 基本思路
定义二维数组 $f[5][1005]$ 记录状态。

状态 $f[x][y]$ 表示在拦截前 $y$ 颗导弹时能拦截的最大数量。 $x=1$ 意为在前 $y$ 颗导弹中拦截奇数颗最大拦截数量； $x=0$ 意为在前 $y$ 颗导弹中拦截偶数颗最大拦截数量。

题目中提到拦截的奇数颗导弹比前一颗更高，偶数颗比前一颗更低。为了方便理解，不妨想象在输入数据之前还有一颗高度为 $0$ 的导弹，记作第 $0$ 颗。

### 状态转移方程

设当前导弹高度为 $a[i]$ ，前一颗高度为 $a[i-1]$ ,存在三种可能。

1. 当 $a[i]>a[i-1]$ 时。
- 如果在前 $i$ 颗导弹中拦截奇数颗，有两种可能。
- 如果要拦截此颗导弹，那么此颗导弹将是奇数颗被拦截的,这种情况下最大拦截数为在前 $i-1$ 颗导弹中拦截偶数颗的最大值 $+1$ ,即， $f[1][i]=f[0][i-1]+1;$
- 当然也可以不拦截这颗导弹，这种情况下最大拦截数与前     $i-1$ 拦截奇数颗的最大拦截数相等，为 $f[1][i]=f[1][i-1]; $
- 还可以在前 $i$ 颗导弹中拦截偶数颗，仅有一种可能，拦截颗数与在前i-1颗导弹中拦截偶数颗的最大值相等,即 $f[0][i]=f[0][i-1];$
2. 当 $a[i]<a[i-1]$ 时，思路与 $a[i]>a[i-1]$ 相似，不做详细说明，具体见代码。
3. 当 $a[i]==a[i-1]$ 时，在前 $i$ 颗导弹中拦截奇数或偶数颗导弹的最大值与在前 $i-1$ 颗中拦截无异,即 $f[0][i]=f[0][i-1];f[1][i]=f[1][i-1];$

由此归纳出状态转移方程，目标值为 $max(f[0][n],f[1][n]);$

## 代码
```cpp
//以下程序仅供参考，如有不当之处请指正。
#include<bits/stdc++.h>
using namespace std;
int n,f[5][1005],i,j,a[1005];//f[0][x]下降f[1][x]上升
int main()
{
    cin>>n;
    for(i=1;i<=n;i++)
    {
        cin>>a[i];
    }
    //读入
    for(i=1;i<=n;i++)
    {
        if(a[i]<a[i-1])
        {
            f[0][i]=max(f[1][i-1]+1,f[0][i-1]);
            f[1][i]=f[1][i-1];
        }
        else if(a[i]>a[i-1])
        {
            f[0][i]=f[0][i-1];
            f[1][i]=max(f[0][i-1]+1,f[1][i-1]);
        }
        else
        {
            f[0][i]=f[0][i-1];
            f[1][i]=f[1][i-1];
        }//状态转移方程
    }
    cout<<max(f[0][n],f[1][n])<<endl;
    return 0;
}

```