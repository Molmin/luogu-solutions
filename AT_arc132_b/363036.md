## 题意简述 & 翻译
给定一个 $1\sim n$ 的排列 $a$，每次可以对其进行下面两种操作的其中之一：
1. 取反整个数列，即 $\{a_1,a_2,\cdots,a_n\}\rightarrow\{a_n,a_{n-1},\cdots,a_1\}$。
2. 将第一个数挪到最后面，即 $\{a_1,a_2,\cdots,a_n\}\rightarrow\{a_2,a_3,\cdots,a_n,a_1\}$。

问若要将 $a$ 变成 $\{1,2,\cdots,n\}$，至少需要多少次操作。数据保证有解。

## Question
首先，有解的情况是什么？

假设我们现在的目标是把原数组变成完全升序或完全降序（降序时再翻转一次即可得到升序，所以是等价的）。

这样可以不用考虑操作 1。我们再以升序为例。

此时，若 $\exists i\in[1,n)$ 满足 $a_i>a_{i+1}$，那么我们需要通过很多次 2 操作交换 $i,i+1$。

但是，若 $\exists k\in[1,i),a_k>a_i$，那么 $i$ 被挪到最后之后，它一定在 $i$ 的前面。你会发现 $i,i+1$ 合法了，但是 $k',i'$ 又挂了（$i',k'$ 表示移位后 $i,k$ 对应的位置）。

因此，我们一定需要满足至多存在一对 $(i,i+1)$，有 $a_i>a_{i+1}$。换言之，$\forall j\in[1,i),a_j<a_{j+1}$。同理，$\forall j\in[i+2,n),a_j<a_{j+1}$。

显然只有当 $a_i=n,a_i=1$ 时才能满足条件。此时 $a=\{\cdots,n-2,n-1,n,1,2,\cdots\}$。

同理，你可以推出剩下几种情况类似。

所以，我们得出结论：**当且仅当 $a$ 半有序的时候才能有解。**

## Solution
根据 `question` 中的推论，我们发现 $1$ 和 $n$ 的位置尤为重要。

设 $1$ 的初始位置为 $p$。讨论以下 4 种情况（并且以 $n=6$ 作为例子）：
- $p$ 在数组**前**半边且数组**升**序排列（如 $\{5,6,1,2,3,4\}$）。此时直接把它前面的东西挪到后面去即可，操作次数 $p-1$。
- $p$ 在数组**前**半边且数组**降**序排列（如 $\{2,1,6,5,4,3\}$）。将 $p$ 和它前面的全部挪到后面，此时就递减了，直接翻回来即可，操作次数 $p+1$。
- $p$ 在数组**后**半边且数组**升**序排列（如 $\{3,4,5,6,1,2\}$）。翻转之后就是第二种情况。记翻转之后的位置为 $p'=n-p+1$，操作次数 $1+p'+1=n-p+3$。

- $p$ 在数组**后**半边且数组**降**序排列（如 $\{4,3,2,1,6,5\}$）。翻回来之后就是第一种情况，操作次数 $1+(p'-1)=n-p+1$。

但是注意一下两种情况情况：
1. 当 $n$ 为奇数且 $p$ 刚好在正中央时，我把它归到后半部分了。这可以正确地解决 $\{2,1,3\}$ 这种降序的情况。但对于 $\{3,1,2\}$ 这种情况，它会把序列转到 $\{2,1,3\}$ 再操作。但实际上，只需要把 $3$ 挪到后面就行了。因此，在这种情况下需要特判。
2. $n=2$ 特判。

判断一下就行，贴代码收工。

```cpp
#include<bits/stdc++.h>
using namespace std;

const int N = 1e5 + 10;
int n, p, op1, op2, a[N];

int main(){
	scanf("%d", &n);
	for(int i=1;i<=n;i++)
		scanf("%d", &a[i]);//数组一定半有序
	if(n == 2)
		return printf("%d\n", (a[1] == 1 ? 0 : 1)), 0; 
	for(int i=1;i<=n;i++){
		if(a[i] == 1){
			p = i;
			op1 = (p <= n / 2 ? 0 : 1);//前半 0，后半 1 
			if(i > 1)
				op2 = (a[i - 1] == n ? 0 : 1);//升序 0 降序 1 
			else
				op2 = (a[i + 1] == 2 ? 0 : 1);
		}
	}
	if(!op1 && !op2)//前半部分 & 升序（5 6 1 2 3 4），直接往后挪 
		printf("%d\n", p - 1);
	else if(op1 && !op2)//后半部分 & 升序（3 4 5 6 1 2），取反、挪位、取反 
		printf("%d\n", min(n - p + 3, p - 1));//特判，{3,1,2} 类型的操作次数是p-1
	else if(!op1 && op2)//前半部分 & 降序（2 1 6 5 4 3），挪位 + 取反 
		printf("%d\n", p + 1);
	else if(op1 && op2)//后半部分 & 降序（4 3 2 1 6 5），取反 + 移位 
		printf("%d\n", n - p + 1);
	return 0;
}
```

好题，适合提升思维。