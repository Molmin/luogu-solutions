题意即对每个点j，询问有多少条路径i满足：1 Si与j距离为Wj，2 经过j。


N,M较小时，我们可以以每个点j为根建树，之后1<=>deep(Si)=Wj,

2<=>deep(Si)+deep(Ti)=len(i)。其中len(i)可以预处理出来。时间O(N(N+M))


退化为链时，1<=>|Si-j|=Wj,即Si=j+-Wj;2<=>Si<j时,Ti>=j,反之Ti<=j。只要对每个Si相同的Ti排一下序，就可以二分查找了。时间O(NlogM)

所有Si=1时，我们以1为根建树，1<=>Wj=deep(j),2<=>Ti>=j。也就是问子树里有多少个Ti(当然，如果1不满足就=0)，我们给每个Ti处+1，之后遍历一遍即可。


所有Ti=1时，我们也以1为根建树，1,2<=>deep(Si)=deep(j)+Wj。也就是问子树里有多少个deep=deep(j)+Wj的Si。给每个Si打标记，经过时+1；遍历时记录deep，计算进出j的子树时对应deep的变化量即可。


我们高兴的看到可以骗80分(然而我时间不够只打了60)。后来学长教了我正解。


对于自下向上的路径，我们给Si打deep(Si)+1标记的同时，要给f(Ti)打deep(Si)-1的标记。每个点j计算deep(j)+Wj变化量。

对于自上向下的路径，我们给Ti打deep(Si)+1标记，给f(Si)打deep(Si)-1的标记。每个点j计算deep(j)-Wj变化量。


对于一般的先上后下的路径，我们拆成向上与向下的两条。向上的Si不变；向下的我们可以将Si翻上去，也就是deep(S)=2\*deep(lca)-deep(Si)。


考虑tarjan求lca是O(N+M)的，总时间O(N+M)。
