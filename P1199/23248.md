这道题真的没有像其所说的那么难，无论是从理解、想法还是代码方面都是非常容易的，就想法和代码来说完全可以给入门的同学当作业来写。


一开始我拿到这道题的时候，“这不就是模拟一下吗？！”


后来我去稍微理解了一下题意，哦，也差不多，复杂度几乎可以等同。


首先第一个问题，看不出来的人可能会被这个困扰很久，或者是直接去写程序来判小涵究竟能不能赢，我估计那些部分分就是为这个设计的（要不然我真想不到什么不是乱做的暴力做法）。小涵是肯定能赢的（除非ta脑子一昏或是故意乱下），因为ta每次挑选一个当前可挑选的最大默契值的一对武将中的其中一个，而电脑知识应付一下，把另外一个挑走，而小涵只要选择可能的第二大默契值的另一个武将就赢了，因为电脑无论怎么取都没有ta大，因为最大和次大都被选了，电脑要想赢只有一种情况：有两个或以上的次大武将，然而题目已经给出了限制：保证对于不同的武将组合，其默契值均不相同。所以，这一个问题就不用管了，直接输出1即可。


那么第个问题其实也很容易，在解决第一个问题的时候，其实就已经把第二个问题顺带解决了，选择了任意一位武将后，由于电脑必定会选择可选最大默契值武将的另一位，那么小涵能选的就只有次大的，那么我们知道这个最大的选择的是什么？很明显就是那n个次大值中的最大值。这样我们就得到了这道题的正解，然而这道题写法挺多的，每个写法之间时间可能也会有些差异，不过都能过，

代码如下：


```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
int n,a[501][501],ma=0; 
int main()
{
    scanf("%d",&n);
    for(register int i=1;i<=n;i++)
        for(register int j=i+1;j<=n;j++)
        {
            scanf("%d",&a[i][j]); 
            a[j][i]=a[i][j];//存图
        }
    for(register int i=1;i<=n;i++)
    {
        sort(a[i]+1,a[i]+n+1);//由于个人比较懒，用sort求次大值
        ma=ma>a[i][n-1]?ma:a[i][n-1];//更新目前所有次大值的最大值
    }
    printf("1\n%d",ma);
    return 0;
}
```
我们就看n，显然O(n^2)是能过的，那么这个算法就没问题了。
那我们再来看看模拟，模拟每一位先挑选的武将，然后去除电脑选的一名，再取其最大值，其实也就是求次大值的另一种求法，所以肯定也是能过的。所以这道题非常有趣，暴力模拟和正解是一样的，或者有一些大佬觉得代码、难度都抵不上t3、t4，于是就写了线段树（当然到底有没有这样的人我也不知道）

代码如下：


```cpp
#include<cstdio>
#define max(a,b) a>b?a:b
using namespace std;
int n,a[501][501],maxn;
int main()
{
    scanf("%d",&n);
    for(register int i=1;i<=n;i++)
        for(register int j=i+1;j<=n;j++)
        {
            scanf("%d",&a[i][j]);
            a[j][i]=a[i][j];
        }
    for(register int i=1;i<=n;i++)
    {
        register int max=0,p,mm=0;
        for(register int j=1;j<=n;j++)
            if(max<a[i][j]){max=a[i][j];p=j;}
        for(register int j=1;j<=n;j++)
            if(j!=p) mm=max(mm,a[i][j]);
        maxn=max(maxn,mm);
    }
    printf("1\n%d",maxn);
    return 0;
}
（然后突然发现后者更难写，码更长。。。）
```