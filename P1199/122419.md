首先，该计算机并没有人聪明

即，这位同学永远是赢的（请看下面分解）

既然计算机不让我们那最大默契值的一组，那么我们就拿与已选武将默契值第二大的

在以上条件下时，我们所能做的只有选到与各个武将配对时默契值第二大的之中最大的那一个。

此时计算机很被动，每次拿都晚于我们。在最好情况下，计算机后一次拿到的武将与前一个配成的默契值仅次于最大的（最大的已被分开了），即第二大。但这已在第一条中被拿走了。So，我们只需贯彻执行第二点。

################################### 我仿佛是分割线 ##############################################
```
#include<cstdio>
#include<algorithm>
using std::sort;
int a[510][510];
int main()
{
    int n;
    scanf("%d",&n);
    for(int i=1;i<n;i++)
        for(int j=i+1;j<=n;j++)
        {
            scanf("%d",&a[i][j]);
            a[j][i]=a[i][j];
        }
    int ans=0;
    for(int i=1;i<=n;i++)
    {
        sort(a[i]+1,a[i]+1+n);
        ans=ans>a[i][n-1]?ans:a[i][n-1];//选出排名第二中最大的那个
    }
    printf("1\n%d\n",ans);//一定有解
    return 0;
}
```