#### ~~我们来了解一下博弈论~~

（进入正题专用表情）



------------

题目很长，看似很复杂，但是经过一番冷静分析后，发现题目并不难。

初步分析。

    1.计算机拿走的武将都与小涵所拿走的武将的默契值最大。
      所以小涵永远拿不到与自己所选武将默契值最高的武将。
    2.既然两个武将的默契值相等，那么f（A,B）=f（B,A）。
 
接下来，我们继续分析

    假设有 A1,A2,A3,A4 共4个武将。且f（A,B）>f（A,C）>f（A,D）>f（B,D）
    我们来做一个假设：
    如果小涵选择了A，则计算机必定选择B。那么小涵无法得到最优解，该怎么办呢？
    没错，我们可以选择与A默契值第二大的C，那么计算机只能选择D，所以小涵必赢。
    
一番冷静地分析后，长长的题目就被简化了。

### 简化后的题目：给你一堆数，请找出其中第二大的数。

那么，代码便完成了。

打上代码

```cpp
#include<bits/stdc++.h>
#define N 1000 
using namespace std; 
int f[N][N],ans; 
int main() 
{ 	
	int n;
	cin>>n;
	for(int i=1;i<n;i++) 
		for(int j=i+1;j<=n;j++) 
		{ 
			cin>>f[i][j];//输入
			f[j][i]=f[i][j]; //存入数组中 
		} 
	for (int i=1;i<=n;i++) 
	{ 
		sort(f[i]+1,f[i]+n+1); 
		ans=ans>f[i][n-1]?ans:f[i][n-1]; //三元运算，寻找答案
	} 
	printf("1\n%d",ans);//输出答案 
	return 0; 
}
```

提示：

    1.注意输入时的终止变量。
    2.不要忘记排序是需要有一层循环


