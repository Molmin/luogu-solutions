~~似乎我和大佬们的想法都不太一样，所以来水一篇题解~~

首先题目保证默契值没有重复的，这一点很重要。

这个题要同时满足两个条件：

1.我们要尽可能地取得胜利

2.我们要尽可能取得较大值

看到这两个条件，很容易想到排序，这样按照每一组的默契值从大到小排序，就可以同时满足两个条件。具体做法就是，从大到小排序，每次将当前场上最大默契值的两个武将标记，当我们处理到一组数据有至少一个或两个点被标记时，就是我们的答案。

正确性？

由于我们是从大到小排序，我们每次选到一个武将的时候就相当于锁掉这个值，所以不可能出现机器人误打误撞选到一组很大的值，保证了我们至少不会输。

而且我们发现一件事情，假设我们选的集合为S，机器人选的为T

我们每次选完一个点A加入T都有一个对应确定的点B加入T，所以我们不管选A还是B都是等价的

因此当我们处理到一组有标记的数据时：

1.有一个标记

一个标记无非就是我们选的或者机器人选的，如果是我们的点，我们选剩下那个，如果是机器人的点，根据上述结论，显然可以是我们选这个点，机器人选对应的另一个点，也就是说这个点是谁的根本无所谓，这样就保证了这个值是我们的。

2.有两个标记

两个自己的，一个自己的一个机器人的，两个机器人的，处理方式及证明同上

所以我们发现，我们根本不需要在意我们选了那些点，我们只需要在意当前场上的点有哪些被选过了就行，通过策略的调整，我们可以保证拿到自己所需要的点。

判断是否必胜？

显然我们必胜

正确性？

题干中已经给了对应的数学模型，根据那个模型，我们发现最终一定会处理到一组有标记的数据，由于比这个大的数被我们锁掉了，而且我们有先手权，我们一定能取到这个数，所以一定有解且我们必胜。

Code：
```cpp
 #include <iostream>
 #include <cstdio>
 #include <algorithm>
 
 using std:: sort;
 
 int n, d, cnt;
 struct Node {
 	int val;
 	int x;
 	int y;
 }s[500005];
 bool vis[500005];
 
 int cmp (Node x, Node y){return x.val > y.val;}
 
 int main (){
 	scanf ("%d", &n);
 	for (int i = 1; i < n; ++i){
 		for (int j = i + 1; j <= n; ++j){
 			scanf ("%d", &d);
 			s[++cnt].val = d;
 			s[cnt].x = i;
 			s[cnt].y = j;
		 }
	 }
	 sort (s + 1, s + cnt + 1, cmp);
	 for (int i = 1; i <= cnt; ++i){
	 	if (vis[s[i].x] || vis[s[i].y]){
	 		printf ("1\n%d", s[i].val);
	 		return 0;
		 }
		 vis[s[i].x] = vis[s[i].y] = 1;
	 }
 }
```
