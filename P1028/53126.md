## 发一篇Dp的题解。

复杂度大概O(n^2 log n)但不是严格的（废话 --_--|||）

93ms/824KB

------------


我们设F[i][j]表示：

### 当前在原数左边添加了i个数，且这个数为j
的方案数。

那么所有符合条件的f[i][j]之和就是答案。

而转移方程很好想，当前的方案数是上一位所有可能的情况的方案数之和，即

### f [ i ] [ j ] = ∑ f [ i-1 ] [ k ]
### k ∈ [ j * 2 , n / ( 1 << ( i - 1 ) ) ] , 即从当前值的两倍到上一位的最大值

------------


这么说可能不好理解，我们用样例来解：

当n=6，且左边添加了2个数字时，有两种情况：1 2 6 和 1 3 6 

而这两种情况分别是由情况 2 6 和情况 3 6 转移来的，所以这时有

### f [ 2 ] [ 1 ] = f [ 1 ] [ 2 ] + f [ 1 ] [ 3 ] ;

------------

综上，我们只需要预处理出左边最多能加多少个数字，

如n=6时，最多能加2个数字，

然后枚举每一位上的所有可能情况，再进行上述转移即可。

最后把 f 数组累加起来，再加上原数的一种方案即为答案。


------------


上代码：
```cpp
#include<iostream>
#include<cstdlib>
#include<cmath>
using namespace std;

long long ans,f[10][1001]={0};//2^10已经超过1000，最多能加9个数
int n,max_,i,j,k;

int main()
{
    cin>>n;
	f[0][n]=1;//记得要把原数赋为1
    max_=(int)(log2(n));//这个方法可以一步求出最多能加几个数
    for(i=1;i<=max_;i++)
      for(j=1;j<=n/(1<<i);j++)
        for(k=j*2;k<=n/(1<<(i-1));k++)
        { 
          f[i][j]+=f[i-1][k];
          ans+=f[i-1][k];//累加的过程可以在循环内进行
        }
   cout<<ans+1;//不要忘记原数，答案要+1
   return 0;
}

```

一个 普及- 的题想了我半天，真是耻辱……