本人的第一篇代码！

其实方法很简单：首先将数组初始化为1，然后逐个与比它的下标一半小的元素相加。简单DP就可以了。

以前3位为例，0自然只有它本身1个，1也只有它本身一个。2则有2个：12和2；3有2个：13和3。（这些还不能说明问题）

4就很有意思了，首先它自己是1个；经过一次操作会生成：14,24两个。然后“24”的“2”又可经过操作生成“12”和“2”，这个“2”的思考方式和数组下标为2的元素的思考方式一模一样，所以可以借用之前的a[2]。
详见程序。
```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
int a[1001];//定义
int main()
{
	a[0]=1;
	a[1]=1;
	a[2]=2;//初始化前3位
	for(int i=3;i<=1000;++i)//开始循环
	{
		a[i]=1;//初始化4-1001位
		for(int j=1;j<=i/2;++j)//题中要求的“不能超过原数的一半”
			a[i]+=a[j];//将之前的方法数进行叠加。
	}
	cin>>n;//Input
	cout<<a[n];//Output
	return 0;
}
```