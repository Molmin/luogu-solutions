# 干货：五种做法及优化步骤

以下代码为python3，可以当作伪代码看
## 递归算法

完全依照题意做的，没有任何优化。时间复杂度为$O(ans)$。水平有限，证不出来。用spss回归分析得到 $ans \approx -109247983.3461499 $
$~~~~~~~~~~~~~~+1914784.941480415 x$
$~~~~~~~~~~~~~~- 6963.611684685798 x^2$
$~~~~~~~~~~~~~~+ 6.947761014361296 x^3$

姑且认为，在题目所给范围内，dfs算法为$O(n^3)$的

```python3
ans = 0
def dfs(i):
    global ans
    ans += 1
    for ii in range(1, i // 2 + 1):
        dfs(ii)
s = int(input())
dfs(s)
print(ans)
```

## 打表算法
本题数据范围较小，输入和输出值单一，可以打表做。部分如下，不多说了。
```python3
[0, 1, 2, 2, 4, 4, 6, 6, 10, 10, 14, 14, 20, 20, 26, 26, 36, 36, 46, 46, 60, 60, 74, 74, 94, 94, 114, 114, 140, 140, 166, 166, 202, 202, 238, 238, 284, 284, 330, 330, 390, 390, 450, 450, 524, 524, 598, 598, 692, 692, 786, 786, 900, 900, 1014, 1014, 1154, 1154, 1294, 1294, 1460, 1460, 1626, 1626, 1828, 1828, 2030, 2030, 2268, 2268, 2506, 2506, 2790, 2790, 3074, 3074, 3404, 3404, 3734, 3734, 4124, 4124, 4514, 4514, 4964, 4964, 5414, 5414, 5938, 5938, 6462, 6462, 7060, 7060, 7658, 7658, 8350, 8350, 9042, 9042, 9828]
```
复杂度$O(1)$
## dp做法1
设$f_i$表示i的数有$f_i$种摆法，根据题意，易知

$f_i=1+\sum^{\lfloor i/2 \rfloor}_{j=1}{f_j}$

1表示只放自己是一种方案，$\sum$后面的表示可以分别放的方案，可以累加。用纸笔演算不难得到
```python3
n = int(input())
dp = [0]*(n+1)
for i in range(1, n+1):
    for j in range(1, i//2 + 1):
        dp[i] += dp[j]
    dp[i] += 1

print(dp[n])

```

双重循环，显然复杂度$O(n^2)$
## dp做法2
根据打表算法，我发现了一个神奇的规律，相邻两个i的$f_i$是一样的，于是可以将n除以2，得到新的$f_i$
```python3
[1, 2, 4, 6, 10, 14, 20, 26, 36, 46, 60, 74, 94, 114, 140, 166, 202, 238, 284, 330, 390, 450, 524, 598, 692, 786, 900, 1014, 1154, 1294, 1460, 1626, 1828, 2030, 2268, 2506, 2790, 3074, 3404, 3734, 4124, 4514, 4964, 5414, 5938, 6462, 7060, 7658, 8350, 9042, 9828]
```

然后会发现，$f_i$是递增的，而且是在$f_{i-1}$的基础上加一个数。加的数从2开始，每个加的数加两次，之后加下一个数。具体见程序


```python3
n = int(input())
nn = n//2
dp = [0]*max(3, nn+1)
dp[0] = 1
dp[1] = 2
j = 1
jc = 0
for i in range(2, nn+1):
    dp[i] = dp[i-1] + dp[j]
    jc += 1
    if jc == 2:
        j += 1
        jc = 0

print(dp[nn])

```
由于是单层循环，时间复杂度为$O(n)$

## 回归公式法
把打出的表，输入回归计算器中，得到详尽的回归公式。然后将公式写入程序，到时候直接运算即可，时空复杂度都是$O(1)$，常数应该比较大，而且对精度的要求比较高。考试时不会有现成的回归计算器，所以不推荐此写法。