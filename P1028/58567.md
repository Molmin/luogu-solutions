楼下大牛正解！

但为了各位和我一样第一眼看不懂的蒟蒻，本人决定再把楼下大牛的思路讲得再清楚一些。

首先，我们设h[i]就是当n=i时本题的答案，当然，h[0]=0，而s[i]就是h[1]+h[2]+……+h[i]的和。

那么，显然我们可以给前面n=1~i/2中产生的每一个数的左边都加上一个n，然后我们再加上n自己这一个数（不做任何操作也是允许的）即

h[i]=s[i/2]+1.

那么，我们，每次再将s[i]更新一下，s[i]=s[i-1]+h[i]，这道题就可以不用递归轻松地用递推完成辣~时间复杂度也显然是线性的，对于这道n<=1000的题来说绰绰有余了。

~~那为什么这道题还要放在过程函数与递归这个试炼场呢~~

最后附上c++代码。~~所以你写这篇题解的用意还是只是让那些c++党有抄的机会？？~~

抄题解的对不起了，代码有坑。

    
    
        
        
```cpp
    #include<bits/stdc++.h>
    using namespace std;
    int h[1000001];
    int s[1000001]; //数组开大总是好的
    int main()
    {
        int n;
        cin>>n;
        for(int i=1;i<=n;i++)  //不断递推出答案
        {
            h[i]=s[i/2];
            s[i]=s[i-1]+h[i];  //题解中讲的递推公式
        }
        cout<<h[n];  //直接输出就可以了
}
```