### 前言

这个菜鸡 Little09 连 Z 函数都不会，但是 Little09 还是想做 CF1537E2。

### 转化后题意

给定长度 $n$ 的字符串 $s$，选择 $s$ 的一个前缀，它的无限循环构成的字符串的字典序最小。输出前 $k$ 位。

### 分析

我们考虑现在考虑第 $i$ 位的前缀，$i$ 位以前的答案是第 $ans$ 位的前缀。

如果这一位比目前的答案要大，那么直接退出，因为再往后也不可能更大了。

如果这一位比目前的答案要小，那么把这一位保存为答案，继续往下找下一位。

如果这一位与目前的答案相同，怎么办？

我们先不考虑相同的情况（就是相同的时候不存做答案，也不退出），写出如下的代码：

```cpp
n=read(),m=read();
cin >> a;
ans=0;
for (int i=1;i<n;i++)
{
	int tot=i%(ans+1);
	if (a[tot]<a[i]) break;
	if (a[tot]>a[i]) ans=i;
	//else do something..
}
for (int i=0;i<m;i++) cout << a[i%(ans+1)];

```

令人意料之外的是它一发就过了。

### 为什么这样是对的

想手玩构造出 Hack 数据，经过我半个小时的尝试后失败。我们用随机程序把它和 E1 做个对拍，我跑了 $40000$ 多组仍然没有差异，所以我们可以认定它是正确的算法。

具体的证明 Little09 认为比较麻烦，感觉有种数学归纳的思想，带上几次分类讨论，~~也不确定有没有假了~~，所以不再赘述，请读者自己尝试证明。如果有简单的证明方法，欢迎在评论区提出或者私信我。也欢迎来 Hack！