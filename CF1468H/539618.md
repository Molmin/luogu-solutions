# CF1468H 题解



## 思路分析

首先，一次操作会删除 $k-1$ 个数，因此如果 $(n-m)\bmod (k-1)\ne 0$，那么必然无解。

假设 $d=\dfrac{k-1}2$，那么一次操作可以看在 $\{a_i\}$ 中选定一个下标 $x$，并在 $x$ 的左边和右边各删除 $d$ 个元素。

注意到如下的观察：

> 观察：
>
> 若 $(n-m)\bmod(k-1)=0$，那么当且仅当存在一个 $i\in[1,m]$ 使得 $1\sim n$ 的待删除元素中 $<b_i$ 和 $>b_i$ 都至少有 $d$ 个时，原问题有解。
>
> 对待删除元素数量进行归纳，显然当待删除元素数量为 $0$ 时一定有解。
>
> 否则，考虑最后一次操作，保留的中位数一定是某个 $b_i$，而这就要求 $<b_i$ 和 $>b_i$ 的待删除元素都至少有 $d$ 个，如果存在这样的 $b_i$，假设操作时删除了 $a_{i_1}\sim a_{i_{k-1}}$，那么在这次操作之前，我们可以把 $a_{i_1}\sim a_{i_{k-1}} $ 全部看成需要保留的元素。
>
> 那么我们只需要删除剩下的的 $(n-m)-(k-1)$ 个元素，由于 $(n-m)\bmod (k-1)=0$，那么一定能归纳到待删除元素数量为 $0$ 的情况。
>
> 因此我们只需要证明，在保留 $a_{i_1}\sim a_{i_{k-1}}$ 之后，若 $(n-m)>(k-1)$，我们依然能够找到一个合法的操作位置来删除 $k-1$ 个元素即可。
>
> 不妨假设原本 $<b_i$ 的待删除元素有 $x$ 个，$>b_i$ 的待删除元素有 $y$ 个，而在保留 $a_{i_1}\sim a_{i_{k-1}}$ 后 $<b_i$ 的还剩 $x-d=x'$ 个，而 $>b_i$ 的还剩 $y-d=y'$ 个。
>
> 由于 $x+y=n-m,2\times d=k-1$，因此 $x+y\ge 4d$ 即 $x'+y'\ge 2d$，因此 $x'\ge d$ 和 $y'\ge d$ 中至少有一个成立，而同时成立的情况只需要继续操作 $b_i$ 即可，故我们假设 $x'> d>y'$：
> 
> 设 $d-y'=r$，则 $x'\ge d+r$，那么 $x\ge 2d+r$，那么我们在最后一次操作时选择恢复这 $x$ 个元素中的第 $d+1\sim 2d$ 个待删除元素即可，此时在这些被恢复的元素中任选一个，其左侧剩下 $d$ 个带删除元素，右侧剩下 $x'-2d+y'\ge d$ 个元素，因此我们构造出了一种方法使得在剩下的 $(n-m)-(k-1)$ 个待删除元素中也能找到一个分界点，使得其左右的待删除元素都不少于 $d$ 个，故原命题得证。

因此先判断 $(n-m)\bmod (k-1)$ 的值，然后找到一个这样的 $b_i$ 即可。

时间复杂度 $\Theta(n)$。

## 代码呈现

```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAXN=2e5+1;
bool vis[MAXN],del[MAXN];
inline void solve() {
	int n,k,m;
	scanf("%d%d%d",&n,&k,&m);
	for(int i=1;i<=n;++i) del[i]=vis[i]=false;
	for(int i=1;i<=m;++i) {
		int x;
		scanf("%d",&x);
		vis[x]=true;
	}
	if((n-m)%(k-1)!=0) {
		puts("NO");
		return ;
	} 
	int pre=0,suf=n-m,d=(k-1)/2;
	for(int i=1;i<=n;++i) {
		if(vis[i]) {
			if(pre>=d&&suf>=d) {
				puts("YES");
				return ;
			}
		} else ++pre,--suf;
	}
	puts("NO");
}
signed main() {
	int T;
	scanf("%d",&T);
	while(T--) solve();
	return 0;
}
```

