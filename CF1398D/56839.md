根据排序不等式，肯定是大的相乘贡献更大。

但是涉及到三个颜色两两组合，直接让大的互相组合，有可能会出现某种颜色剩下很多没有用的情况。

但是贡献的原则不变，同种颜色先按照大小排序，然后DP。

`f[i][j][k]` 表示用了前 `i` 对红色，前 `j` 对绿色，前 `k` 对蓝色的最有答案，转移就讨论最后一个矩形怎么构成的就行了。

注意从0开始循环，否则会漏掉用 `f[0][0][0]` 更新形如 `f[1][1][0]` 的情况。

```C++
for (int i = 1; i <= r[0]; ++i) r[i] = rd();
sort(r + 1, r + 1 + r[0], cmp);
for (int i = 1; i <= g[0]; ++i) g[i] = rd();
sort(g + 1, g + 1 + g[0], cmp);
for (int i = 1; i <= b[0]; ++i) b[i] = rd();
sort(b + 1, b + 1 + b[0], cmp);
for (int i = 0; i <= r[0]; ++i)
  for (int j = 0; j <= g[0]; ++j)
    for (int k = 0; k <= b[0]; ++k) {
      if (i > 0 && j > 0) f[i][j][k] = max(f[i][j][k], f[i - 1][j - 1][k] + 1ll * r[i] * g[j]);
      if (i > 0 && k > 0) f[i][j][k] = max(f[i][j][k], f[i - 1][j][k - 1] + 1ll * r[i] * b[k]);
      if (j > 0 && k > 0) f[i][j][k] = max(f[i][j][k], f[i][j - 1][k - 1] + 1ll * g[j] * b[k]);
      ans = max(ans, f[i][j][k]);
    }
```