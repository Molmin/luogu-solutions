
### 直接讲关于普通路径的建图
1.易证从任意 $i$ 城市到 $j$ 城市直接走路，从 $i$ 直接走过去是最近路径之一（也就是说不会有比直接走更近的了）

~~事实上我不会证明，但感性理解应该是这样的~~

2.对于某些 $i$ 到 $j$，有其它路径可以使此路径的长度也等于 $ixorj$。

3.假设 $1$ 为起始点，任意点为终点，可以生成一棵树使得从 $1$ 到任意点的最短路径之一都在这棵树上。

4.理解 $xor$ 的作用，按位相同为 $0$，不同为 $1$ 可以证明           $(2^n+1)xor1$ 是不可能有除直接走过去之外其它相同长度的路径的。

##### 那么如果这道题的起始点为 $1$，可以直接这样写代码：
```cpp
inline void BuildTree(int x,int n)
{
	if(x>N)
		return;
	if(x==1)
	{
		if(x+(1<<n+1)<=N)
			BuildTree(x,n+1);
		Add(x,x+(1<<n),(x^(x+(1<<n)))*C);
		Add(x+(1<<n),x,(x^(x+(1<<n)))*C);
		BuildTree(x+(1<<n),n-1);
	}
	else
	{
		Add(x,x-1,C);
		Add(x-1,x,C);
		for(int i=n;i>=1;i--)
		{
			if(x+(1<<i)<=N)
			{
				Add(x,x+(1<<i),(x^(x+(1<<i)))*C);
				Add(x+(1<<i),x,(x^(x+(1<<i)))*C);
				BuildTree(x+(1<<i),i-1);
			}
			
		}
	}
}
```
 5.事实上题目要求从任意一点到另一点的最短路。
 
 6.所以要跑 $n$ 次这样的操作…………？
 
 先处理一下。
 
 对于 $1$：到 $(2^n+1)xor1$ 这个点没有最短路径，到其它点可以通过这几个点走出跟直接走过去长度相同的路径。
 
 推广：对于任意一个 $i$,有到 $(2^n+i)xor i$ 这个点直接走是唯一最短路径。
 
 所以只需要对任意 $i$ 号点都连 $(2^n+i)xori$ 这个点，这样建图跑出来最短路跑出来的一定是跟原图一样的长度。
 所以正确的建图代码是这样的：
 ```cpp
inline void BuildTree(int n)
{
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=n;j<<=1)
		{
			if((i^j)>n)
				continue;
			Add(i,i^j,j*C);
		}
	}
}
```
建图完成之后再输入快捷通道再跑最短路就行了。

###### 附：堆优化跑 $Dijkstra$ 也许会超时，加个快读吧！



