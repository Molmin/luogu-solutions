很久以前胡了解法一直放着没来管，最近想起来了就来补一下。             

其实和 [P4696](https://www.luogu.com.cn/problem/P4696) 的 hash 做法没有太大的区别。                 

我们考虑这个东西用 kmp 的角度来思考并不怎么优秀，不过这东西本质感觉仍然是字符串匹配，所以猜测用字符串匹配相关思想解决。               

我们发现题目提示的很明显，用两个信息就可以刻画一个长度为 $n$ 的字符串：相应排名的数的相应位置。               

考虑字符串匹配里面常用的 hash，这样做有两个原因：一是文本串不做改动，那么我们直接把所有长为 $m$ 的子串 hash 值存下来就可以静态询问一系列字符串匹配数量的问题；二是这个修改只是单点修改，感觉就很好维护的样子。     

刚开始自己设计的 hash 是 $\sum_{i = 1} ^ n pos_i \times Base^{rank_i}$，但是后来发现好像不是很好处理文本串就换成了 $\sum_{i = 1} ^ n rank_i \times Base^{pos_i}$ 了。            

这个东西很好维护。用值域线段树，倒着枚举所有长度为 $m$ 的子串做区间乘单点改就可以处理文本串了，对于匹配串就只有单点修改。            

时空复杂度 $O(n \log n)$，平衡树做法同理只是会少个空间上的 $\log n$。

