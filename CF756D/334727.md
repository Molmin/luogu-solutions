~~被 Daniel_lele 在伟大的神圣的 OICon 给 D 了，深深感受到自己的 $\mathcal{O}(26 n^2)$ 做法的逊色以及我自己的可耻的菜。~~

### Step1. 观察性质

定义 $f(s)$ 表示字符串 $s$ 相邻去重后的结果。

若 $s$ 可以变换得到 $t$，当且仅当 $\exists a $ 为 $s$ 的子序列，$s.t.$ $f(a) = f(t)$。

### Step.2 大致方向

我们不难想到一个很容易的 DP，通过简单的计数在 $\mathcal{O}(n^2)$ 的时间复杂度内解决。但是我们发现一个很重要的问题：若相同的字符 **分开成为多段**，那么在计数的过程中，相同的方案会以其不同的 **段数编号** 为理由算重，这是我们要解决的问题。

### Step.3 解决问题

我们再次大致想出这样的方法：设 $f(i,j)$ 表示方案串的第 $i$ 个位置，最后的字符为 $j$ 的方案数，接下来暴力枚举这一段的长度以及下一个与之不同字符（放心，可以前缀和优化，所以先这样想着），貌似可以转移。

这个不大行。或者说，如果我们 **先枚举** $i$，这个思路是行不通的：比如字符串 ``aabaa``，这个字符 ``a`` 是在 ``b`` 前还是 ``b`` 后就不得而知，整个串中有多个字符 $j$，你怎么知道这是哪一段的？

咦，上面的问题能否通过 **按照段的顺序依次考虑** 解决？答案是肯定的。我们设 $f(i,j)$ 表示第 $i$ 个位置，最后的字符是 $j$ 的方案数。

我们在第一层循环枚举段，假设这一段的字符为 $k$，我们作以下步骤更新 $f$ ：

1. 按顺序枚举一个位置 $i$；
2. 将原有的 $f(i,k)$ 清零，重新计算；
3. 枚举这一段的长度以及上一个**不同的字符**进行转移。注意是字符，不是对应的段。特殊情况是 $1\sim i$ 位置上均是该字符。

为什么这样就不会算重了呢？首先，我们做到了按照字符本身考虑；其次，我们通过一次枚举段进行扩展，遵循了原字符串要求的顺序。

即使我们这样，可以发现，同一个字符在方案串 $t$ 中出现多次的情况依然可以被计算，因为我们仅仅保证了它们中间有隔开的字符。

### Step.4 代码实现

不建议观看，因为经过了前缀和优化。建议笔者自行考虑。

```cpp
ll n, f[26][5005]; char str[5005];
ll table[256]; 
vector<char>vec;
ll node(ll x){
	if(x>=mod) return x-mod;
	return x;
}
void solve(){
	scanf("%lld%s",&n,(str+1));
	ll lst = 1, cnt = 0;
	vec.push_back('\0');
	for(ll i=1;i<=n;i++)
		if(i>1 && str[i]!=str[i-1]){
			vec.push_back(str[i-1]);
			++ cnt; table[str[i-1]] = cnt;
			lst = i;
		}
	vec.push_back(str[n]);
	ll sz = vec.size()-1;
	++ cnt; table[str[n]] = cnt;
	for(ll i=1;i<=sz;i++){
		long long all = 0;
		for(ll j=1;j<=n;j++){
			f[vec[i]-'a'][j] = node ( 1 + all ) ;
			for(ll l=0;l<=25;l++) if(vec[i] != l+'a') all += f[l][j];
			all %= mod;
		}
	}																
	ll ans=0;
	for(ll j=0;j<=25;j++){
		ans = (ans + f[j][n]) % mod;
	}
	printf("%lld\n", ans);
}
```