**这是蒟蒻我写的第二篇题解（~~当然第一篇没过...~~）**

**欠缺处望指正 谢谢...**


------------

# **高能时间**

 ~~真相只有一个~~，此题的~~猪脚~~算法就是——

**贪心+双向链表+堆优化（优先队列）！**




------------

# **思路**：

## **错误的思路**

**好了回归正题**

先来讲一个**错误**的贪心思路（我一开始也这么想的，~~当然我不会说是大佬们的题解让我打消了这个念头...~~）：

每次从堆里取最大的美观度种树 然后标记一下它两旁的树都不种

当然，反例一抓一大把！举个栗子：

4 7 8 9四个美观度 种2棵树

错误的贪心是种4 9 然鹅**显然**7 8的组合更优啦！

所以我们得出一个结论！

那就是——（~~请不要卖关子了 会被打的...~~）

**要给我们的贪心反悔的机会！！！**




## **正题—— ~~这个世界其实有后悔药~~ 反悔的规则：**

所以先请我们的第二~~猪脚~~算法**双向链表**出场！（~~拜托普通话标准一点ok？~~）

我们可以先对于每棵树建立双向链表

比如说我们种了i这棵树 从堆取出i时把两边的树与这棵树（中间的树）合并

美观度就为两边的树的美观度之和减去中间的树的美观度 也就是$A[l]+A[r]-A[i]$（l和r是两边的树） 合并得的美观度丢进堆里

## **解释：**
为什么这种贪心是正确的呢？

那不妨假设选l和r比选i更好，那我们加上的是$A[l]+A[r]-A[i]$，于是我们发现$A[l]+A[r]-A[i]$中的 $-A[i]$ 与原来加上的$A[i]$抵消

也就是 $(A[l]+A[r]-A[i])+A[i]=A[l]+A[r]$

还可以这样理解：我们把i这棵树拔了 种上了l和r两棵树（~~好残忍...~~）

有的~~童鞋~~可能会问：那如果l和r没有i好呢？

我会~~认真~~的回答：那就和合并后的美观度没有关系，反正都不种...

所以这个贪心的正确性也就被证明了！

## **一个~~不重要~~的~~猪脚~~算法优化**
当然，暴力枚举最大的美观度当然是不可取的（不信你试试）

我前面其实也讲到了，使用**大根堆**就可以完美地解决这个问题啦！

~~当然我偷懒调用的优先队列~~

## **~~突然想起的~~无解情况**
此题的无解情况应该很好判，假设我们每隔一棵树种一棵树（也是题目所能允许的种的最多的树） 都无法种到m棵

也就是$n/2<m$

那么就输出"Error!"

------------
        
## **代码时间到——**

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,ans;bool vis[200005];
struct P{
	int val,l,r;
}p[200005];
struct node{
	int val,id;
	bool operator <(node it) const{return val<it.val;}
};
priority_queue<node> q;
void del(int x){
	p[x].l=p[p[x].l].l;
	p[x].r=p[p[x].r].r;
	p[p[x].l].r=x;
	p[p[x].r].l=x;
}
int main(){
	scanf("%d%d",&n,&m);
	if (n/2<m){printf("Error!");return 0;}
	for (int i=1;i<=n;i++){
		scanf("%d",&p[i].val);
		p[i].l=i-1,p[i].r=i+1;
		q.push((node){p[i].val,i});
	}
	p[1].l=n,p[n].r=1;
	for (int i=1;i<=m;i++){
		while (vis[q.top().id]) q.pop();
		node now=q.top();q.pop();
		vis[p[now.id].l]=vis[p[now.id].r]=1;
		p[now.id].val=p[p[now.id].l].val+p[p[now.id].r].val-p[now.id].val;
		q.push((node){p[now.id].val,now.id});
		ans+=now.val;del(now.id);
	}
	printf("%d\n",ans);
	return 0;
}
```

# **最后**
**各位大佬们点个赞支持一下嘛...**

**有疑问的也可以LG私信或评论区问我...**