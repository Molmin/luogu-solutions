这题的 $n$ 真的~~好大啊~~。

所以不可能乱搞的，乱搞是不可能的，这辈子都不可能的。

于是猜测到要颓柿子。

首先，区间分为 $[1,k],[k+1,n]$。

我们先解决后一个区间。

后一个区间的要求是不能连到第一个区间。

不然最终是一定可以走到1的，对吧？

那么只要**在后一个区间内自己连自己**，就可以保证一定不会走到第一个区间，这样子是符合题目要求的。

**所以后一个区间的方案数是 $(n-k)^{n-k}$。**

套一个快速幂就行了，不过有一点注意一下。

题目说：
>1 <= k <= min(8，n)

为什么要定义这个呢？

其实是为了告诉我们，**$n-k$ 很大**（好像只有我一人提到了 $n-k$ 很大呀）。

根据有取模的快速幂的定义，我们**把底数先取模不影响结果**。

所以底数要取模。

现在回到第一个区间。

这里说一种很好理解的解释：

区间1可以当成一个**无根树**（从任何节点出发，都可以走到树上的某个点--1，此时这个出发点当作根），而**有 $n$ 个节点的有编号的无根树有 $n^{n-2}$ 种构建**（Cayley公式）。

又因为每个点都可以作为根，所以还要乘上个 $k$。

**答案为：$k^{k-2}*k=k^{k-1}$。**

没错吧？

然后代码随便写写就过了。

两个区间相乘可以先模一下，不模也能过就是。

加了防复制的AC代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
ll n,k;
const ll mod=1e9+7;
ll qpow(ll a,ll b,ll mod){
	ll res=1;
	while(b){
		if(b&1) {res=res*a%mod;}
		a=a*a%mod;b>>=1;  
	}
	return res;
}//快速幂
int main(){
	scanf("%lld%lld",n,k);
	printf("%lld",qpow(k,k-1,mod)%mod*qpow((n-k)%mod,n-k,mod)%mod);
	return 0;
}
```

写得还算简单易懂且详细吧？

不懂可以问我qwq，谢谢阅读！