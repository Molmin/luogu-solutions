我们不想用智商做此题，于是我们考虑打表找规律。
# Sotution
## Part 1
首先对于第一种，打表得$n$为奇数时无解，当$n=20$时，答案为：

```
2 1 4 3 10 9 8 7 6 5 20 19 18 17 16 15 14 13 12 11
```

这暗示我们把相邻的下降的块合并，于是我们对于$2~30$的偶数，打出相邻块合并后每一块的数的个数的表：
```
2

2 2
6

6 2
2 2 6
2 10
14

14 2
2 10 6
2 2 6 10
6 2 14
6 18
2 2 22
2 26
30

```

乍一看似乎没有规律，但是通过观察我们发现，16~30是由2~14加一个数$x$得到，而上面的同一块内的$x$的公差恰好为$4$。
即：$n$拆分的最后一个数$p$的值为$(n-t+1)*2$，其中$t$为$n$二进制表示下的最大的$1$。

于是我们可以在$O(lgn+n)$时间内解决第一个问题。

## Part 2
第二种稍麻烦一些，我们发现第二种的$dfs$打表代码速度极快，甚至可以在$5s$内跑出$100000$的数据。

但显然我们不会想着卡常通过此题，我们还是打表，发现$n<=5$时无解，$n=2^t$时无解，我们来看表：
```
3 6 1 5 4 7 2 9 8
3 6 1 5 4 2 9 10 7 8
3 6 1 5 4 2 9 10 7 11 8
3 6 1 5 4 2 9 10 7 8 12 11
...
```
我们发现它们有一段前缀相同，通过验证也确实如此，并且对于$n=89$这样的数据：
```
3 6 1 5 4 2 9 10 7 8 12 11 14 13 17 18 15 16 20 19 22 21 24 23 26 25 28 27 30 29 33 34 31 32 36 35 38 37 40 39 42 41 44 43 46 45 48 47 50 49 52 51 54 53 56 55 58 57 60 59 62 61 65 66 63 64 68 67 70 69 72 71 74 73 76 75 78 77 80 79 82 81 84 83 86 85 88 89 87
```

我们发现它的方案到$n$大于$36$时，都是$+3,-1,+3,-1,+3,-1...$的，除了在经过$2^t$或者接近$n$时会发生变化，如$61,65,66,63,64,68,67$。

当经过$2^t$次时，规律也是固定的，我们直接特判即可。

因此我们可以考虑先打出前$36$的表，然后递推得出$n$的表，最后暴力$dfs$后$6+(n\%6)$位。

时间复杂度$O(n)+O(dfs)$，（但是$dfs$可以跑n=100000？？？）。

# Code
打表代码：
```cpp

int flag[MAXN],a[MAXN],n;
void dfs(int x)
{
	if (x==n+1) { for (int i=1;i<=n;i++) printf("%d ",a[i]); exit(0); }
	for (int i=1;i<=n;i++)
		if (!flag[i]&&(x&i)!=0&&i!=x) //改成x&i==0时就是第一种
		{
			flag[i]=1,a[x]=i;
			dfs(x+1);
			flag[i]=0;
		}
}
signed main()
{
	n=read();
	dfs(1);
	return 0;
}

```
真正的代码：
```cpp

int a[MAXN]={0,3,6,1,5,4,2,9,10,7,8,12,11,14,13,17,18,15,16,20,19,22,21,24,23,26,25,28,27,30,29,33,34,31,32,36,35};
void solve(int x)
{
	if (!x) return;
	int t=x;
	while (t-(t&(-t))!=0) t-=t&(-t);
	int p=(x-t+1)*2;
	solve(x-p);
	for (int i=x;i>x-p;i--) printf("%d ",i);
}
int flag[MAXN],b[MAXN],n;
void dfs(int x)
{
	if (x==n+1) 
	{
		puts("YES");
		for (int i=1;i<=n-n%6-6;i++) printf("%d ",a[i]);
		for (int i=n-n%6-5;i<=n;i++) printf("%d ",b[i]);
		exit(0); 
	}
	for (int i=n-(n%6)-5;i<=n;i++)
		if (!flag[i]&&(x&i)!=0&&i!=x)
		{
			flag[i]=1,b[x]=i;
			dfs(x+1);
			flag[i]=0;
		}
}
signed main()
{
	n=read();
	if (n&1) puts("NO");
	else
	{
		puts("YES");
		solve(n);
		puts("");
	}
	for (int i=37,nw=64;i<=n;i+=2) 
	{
		a[i]=a[i-1]+3,a[i+1]=a[i]-1;
		if (a[i]==nw) nw*=2,a[i]++,a[i+1]=a[i]+1,a[i+2]=a[i]-2,a[i+3]=a[i]-1,a[i+4]=a[i]+3,a[i+5]=a[i]+2,i+=4;
	}
	if (n<=5) { puts("NO"); return 0; }
	dfs(n-n%6-5);
	puts("NO");
	return 0;
}


```

