### 前言

实际上这题已经做完很久了，突然想起来这道题。

这实际上是一道很有意义的题目，考察了一种将抽象问题转化为具体操作的能力。

那我们废话不多说了，开始这道题目的分析：


------------
### 题意分析

相信大家都已经先看过题面了，接下来我对题目做简化分析，也就是把数学符号转化为文字。

每次操作会选择一个区间 $[l,r]$，且 $l, r \in (1, n)$。对它做如下操作：

如果区间和（令其为 $S$）小于零，左端点左边的数加上 $S$，右端点右边的数加上 $S$。并且左端点和右端点都减去 $S$。

其实我们分析到这一步，仍然对我们解题帮助很少，面对这种题，我们仍需要对于题目中所给的样例做出分析。



------------

### 题解思路

首先题目中提到，完美的序列连续子段和都为正，所以我们需要处理前缀和 $sum$。

就能得到：

$$
(\sum_{i = l}^{r}{A_i})=sum[r]-sum[l-1]
$$

这是很基础的处理前缀和的操作，大家应该都会的。

对于样例：

```
13 -3 -4 -5 62
```

处理它的前缀和，前缀和序列为：

```
13 10 6 1 63
```

根据我们上面求连续子段和的思路，要使得任意子段和为正，就必须保证它的前缀和序列是严格上升。

既然下来按照样例，他会对区间 $[2,4]$ 进行一次操作,变成了如下：

```
1 9 -4 7 50
```

处理他的前缀和序列：

```
1 10 6 13 63
```

**仔细观察** 这样的一次操作对于他的前缀和序列的改变是什么？

显然，我们发现序列中的 第 $1$，$4$ 发生了调换。再观察，操作是对 $[2,4]$ 进行的，显然，每次操作，可以转化为对前缀和序列中第 $l-1$ 和 $r$ 进行调换。

我们的目标就是讲前缀和序列变成一个 **严格上升子序列**。

最后我们注意一些细节：
    
1. 原前缀和序列中不能出现负数，因为出现负数，则永远构造不出目标序列。

2. 原前缀和序列中不能出现相同的数，因为若出现，则只能构造出非严格上升子序列，而我们目标是严格上升子序列。

3. 注意到操作区间区间左端点不能取到 $n$ ，所以我们无法对前缀和序列的最后一个数进行操作，所以必须保证 $sum[n]$ 最大。

4. 我们用离散化的方式，来构造我们的目标序列。



------------
### 代码展示


接下来展示一下丑陋的代码：


```cpp
#include<bits/stdc++.h>
#define ll long long
#define inf 1e9
#define rep(i,l,r) for(register int i=l;i<=r;++i)
#define per(i,r,l) for(register int i=r;i>=l;--i)
using namespace std;
const int N=1e5+5;

int n;
int a[N];
int s1[N],pos[N],tmp[N];
int maxn,max_num;
int ans;
inline bool exist(){//处理是否有解 
	sort(tmp+1,tmp+n+1);
	if(max_num!=n||tmp[1]<0)return true;
	rep(i,2,n)
	    if(tmp[i]==tmp[i-1])
	        return true;
	return false;
}
inline bool cmp(int a,int b){return s1[a]<s1[b];}//离散化的函数 
int main(){
	scanf("%d",&n);
	rep(i,1,n){
		scanf("%d",&a[i]);
		pos[i]=i;
		tmp[i]=s1[i]=s1[i-1]+a[i];//处理前缀和序列和目标序列 
		if(maxn<=tmp[i])maxn=tmp[i],max_num=i;
	}
	//判断是否有解，以及离散化 
	if(exist()){printf("-1\n");return 0;}
	sort(pos+1,pos+n+1,cmp);
	rep(i,1,n)s1[pos[i]]=i;
	//用贪心的思路，只要和目标序列不同，就调换 
	rep(i,1,n){
		if(s1[i]!=i){
			//这两步调换，实际上是同时改变序列中数的位置和值
			//比较难以理解，大家可以多加思考 
			swap(pos[s1[i]],pos[i]);
			swap(s1[pos[s1[i]]],s1[i]);
			ans++;
		}
	}
	printf("%d\n",ans);
	return 0;
}
```


------------

### 结尾

最后提一句，这道题是一道很有思维含量的题，如果大家还想练习类似的题。我可以推荐大家一道题

[NOIP2021 方差](https://www.luogu.com.cn/problem/P7962)

这道题比较难，量力而行吧。


------------
### UPDATE
已经重新修改 $\LaTeX$ 公式 + 标点
