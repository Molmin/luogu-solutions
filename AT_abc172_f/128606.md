非常有趣的小构造。

首先根据 nim 规则可知，后手必胜当且仅当每堆石子数异或和为 $0$。

由于只有前两堆会变，我们直接预处理出后 $n-2$ 堆石子异或和，记为 $p$。

关注到前两堆无论怎么倒腾石子总和是不变的，记为 $q=a_1+a_2$。

那么我们的任务相当于构造一组 $(x,y)$，满足：

$$
\begin{cases}x\;\operatorname{bitxor}\;y=p\\x+y=q\\1\le x\le a_1\end{cases}
$$

在此基础上，我们需要最大化 $x$。

首先处理最麻烦的：异或。令 $x=p$，$y=0$。

将 $x$，$y$ 拆成二进制，对每一位考虑：

1. 若第 $i$ 位构成为 $(1,0)$，我们可以将其变成 $(0,1)$，和不变。
2. 若第 $i$ 位构成为 $(0,0)$，我们可以将其变成 $(1,1)$，和加上 $2^{i+1}$。

那么就很明显了。若 $p>q$ 直接无解，否则记 $\Delta_1=q-p$，若 $\Delta_1$ 二进制第 $i$ 位为 $1$，那么把 $x,y$ 的 $i-1$ 位都变成 $1$。如果这一位不存在，或者 $x$ 这一位已经是 $1$，那么无解。

至此，我们的 $(x,y)$ 已经满足前两个条件了。不难发现，我们构造的 $x$ 是此时所有满足条件一二的点对中，最大的一个。那么如果 $x\le a_1$，直接输出即可。

否则记 $\Delta_2=x-a_1$，这时候我们就要利用第一条性质了。

记录所有的 $(1,0)$ 位，对第 $i$ 位操作的话 $x$ 会减少 $2^i$，我们的目标，就是从这些 $2^i$ 中选出一些数，使其和 $\ge \Delta_2$ 且最小。

大冤种可以考虑转成二进制后二分跑数位 dp，我们考虑更优的解法。

关注到二进制每一位要么是 $0$ 要么是 $1$，从高往低考虑每一位：

1. 可填 $0/1$，$\Delta_2$ 对应位为 $1$；或可填 $0$，对应位为 $0$：这一位没得选，直接填上。
2. 可填 $0/1$，$\Delta_2$ 对应位为 $0$：存在一种可行方案，即这一位填 $1$，后面全填 $0$。
3. 可填 $0$，$\Delta_2$ 对应位为 $1$：不管怎么填都只会小于后者，不再考虑后面。

换而言之，我们要找到一个位置，使得这个位置满足条件 $2$，并且前面位置填的数和 $\Delta_2$ 完全一致。

为了最小化，这个位置自然越小越好，枚举即可。

如此，我们就构造出了解。需要注意若最后的 $x\le 0$ 或找不到合法位置，依旧无解。

```cpp
#include<cstdio>
bool p[41];
int main(){
	int n,i;
	long long xr=0,sm=0,a1;
	scanf("%d",&n);
	for(i=1;i<=n;i++){
		long long x;
		scanf("%lld",&x);
		if(i<=2)sm+=x;
		else xr^=x;
		if(i==1)a1=x;
	}
	if(xr>sm)return printf("-1"),0;
	long long dlt=sm-xr,x=xr,y=0;
	for(i=0;i<=40;i++){
		if(!(dlt&(1ll<<i)))continue;
		if(!i||(x&(1ll<<i-1)))return printf("-1"),0;
		y|=1ll<<i-1;
	}
	x|=y;
	if(x<=a1)return printf("%lld",a1-x),0;
	for(i=0;i<=40;i++){
		if(!(x&(1ll<<i)))continue;
		if(y&(1ll<<i))continue;
		p[i]=1;
	}
	dlt=x-a1;
	long long res=-1,sum=0;
	for(i=40;i>=0;i--){
		bool p1=p[i],p2=dlt&(1ll<<i);
		if(!p1&&p2)break;
		else if(!p1&&!p2)continue;
		else if(!p2)res=sum+(1ll<<i);
		else sum+=1ll<<i;
	}
	x-=res;
	if(x<=0||x>a1)printf("-1");
	else printf("%lld",a1-x);
}
```