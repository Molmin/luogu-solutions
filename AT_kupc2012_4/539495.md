~~首先吐槽一下这可憎的题意~~

### 题目大意

已知 $M$ 个子区间，求至少要多少个子区间才能覆盖区间 $[1,n]$。

### 题目思路

其实刚看到这题，很多人都想到 DP，其实可以不用 DP。

我们把目标区间 $[1,n]$ 想成一串长轴。

首先，我们要判断怎样的情况是**不可能**的。

这个好办，**不可能**的情况就是把所有的选上还没覆盖 $[1,n]$ 的情况，我们用一个标记数组 $u$，记录是否每个数都在区间里出现过。我们可以把它和输入放一起。

```cpp

	for(int i=1;i<=m;i++){
		cin>>p[i]>>q[i];
		for(int j=p[i];j<=q[i];j++)
		u[j]++;
	}
	for(int i=1;i<=n;i++)
	if(u[i]==0){
		cout<<"Impossible"<<endl;
		return 0;
	}
    
```

接下来考虑，怎么去求最小呢？

不妨维护一个变量 $l$，表示在当前的选择中，已经选择了 $[1,l]$。

然后在已知的子区间中，找出左端在 $[1,l+1]$ 内的，右端最右的，这样可以达到最优。

有人会问，不应该是 $[1,l]$ 吗？但实际上，这里的 $l$ 是已覆盖区间的极限，所以左端在 $[1,l+1]$ 的都可以满足条件。

样例:

```
8 4
3 7
1 5
2 5
4 8
```

当前 $l$，刚开始我们初始化为 $0$。

第一次找最优，我们要寻找左端为 $[1,1]$ 中的数，找到 $[1,5]$ 符合条件， $l$ 重置为 $5$。

接下来，$[1,5]$，$[3,7]$，$[2,5]$，$[4,8]$ 都满足条件，但 $[4,8]$ 右端更靠右，所以选 $[4,8]$。

此时刚好覆盖了 $[1,8]$，答案为 $2$。



实现起来就不难了。

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int n,m,l=0;
int maxn=0;
int p[101],q[101],u[101],ans;//p为左端点，q为右端点，u为标记数组
int main(){
	cin>>n>>m;
	for(int i=1;i<=m;i++){
		cin>>p[i]>>q[i];
		for(int j=p[i];j<=q[i];j++)
		u[j]++;
	}
	for(int i=1;i<=n;i++)
	if(u[i]==0){
		cout<<"Impossible"<<endl;
		return 0;
	}
	while(1){
		maxn=0;
		for(int i=1;i<=m;i++){
			if(p[i]<=l+1)//左端点在区间内，更新l
				maxn=max(q[i],maxn);//找最大右端点
		}
		ans++;
		l=maxn;
		if(maxn==n)break;//符合了就结束
	}
	cout<<ans<<endl;
}

```

时间复杂度 $O(nm)$。