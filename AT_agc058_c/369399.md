校内赛后讲题分到这阴间玩意了。。。

[$Link$](https://www.luogu.com.cn/problem/AT_agc058_c)

## 题目大意

给定一个环，环上有 $n$ 个点，每个点有点权 $a_i$，保证 $1\leq a_i\leq 4$ 且每种权值都至少出现一次，若两个点点权相差 $1$ 则可以直接连边，问在边不相交的前提下是否存在生成树。

$T$ 组询问。

$1\leq T\leq 75000,\sum n\leq 3\times 10^5$。

## 题目分析

我们先从环上相邻两项开始考虑。

最朴素的，假设相邻两项相等会怎样？因为保证所有权值均至少出现一次，所以这两个点一定能通过一个中间点间接连起来。

但由于两点相邻，所以不管怎么连这三个点都会形成一个三角，即边没有相交，所以可以删掉其中一个点（注，删掉指在当前剩余节点的生成树作为叶子节点，显然叶子节点后续无贡献，等价于删掉，而删除连锁的父子关系，可以视作整体生成树的父子关系）。

但是删掉会少一条边，那如果有其他边经过了这条边怎么办呢？因为被删的点和原本的点相邻，所以任意一条经过其中一个边的其他边，都会经过另外一条，所以这两条边中的一条可以直接忽略掉。

现在考虑第二种情况，相邻两项能够直接连边，这时就要分类讨论了。

不难发现由于 $1$ 只能直接匹配 $2$，或者通过一次间接匹配 $1$，$2$ 能直接匹配 $1,3$，一次间接 $2$，而且由于两者相邻，所以一次间接匹配和直接匹配所交的边依旧等价，我们可以直接将 $1$ 向 $2$ 连然后删掉，因为 $2$ 所能匹配的范围更加广泛。

同理 $(3,4)$ 可以删掉 $4$。

那么现在剩余节点只会连接 $2,3$，若删掉两者其中一个形成了新的满足上面两种的情况，则接着进行上面的操作即可。

我们发现这个过程重复去做不好做，原本我们只需要维护一个能记录头和尾的信息的结构即可，现在要维护每个位置（可能可以链表直接暴力），那我们试着考虑优化这一步。

考虑我们每次连接 $2,3$ 会删掉哪些点对。

令 $g(a,b,c)$ 表示三个相邻项，$b,c$ 分别是 $2$ 或者 $3$，其它不符合条件的情况可以调转顺序变成这种，易证（指把图画出来）可以删除 $(a,b)$ 这个点对，因为相邻所以不需要考虑其他边连导致相交的情况，我们将所有的情况列出来。

$(4,2,3),(3,2,3),(1,3,2),(2,3,2)$，发现能够删除的点对只有 $(4,2),(1,3),(2,3)$，不难发现想要删掉 $1$ 必须要有一个 $3$，删掉 $4$ 同理，所以最后只会剩余若干 $2,3$，我们可以删掉若干点对，使得 $2,3$ 其中一个只剩最后一个，将另外一个全部连过去即可。

所以我们只要保证删除掉最前面两种情况之后，满足 $2$ 次数大于 $4$，$3$ 次数大于 $1$ 即可，注意不能相等，要留着最后匹配剩余的。

## Code

注意一下是环，所以最后要处理头尾的关系，具体写可以直接分讨，但是很丑陋，所以选择了用其它题解的写法维护一个数组 $f={2,2,3,3}$ 方便分讨。

```cpp
#include <iostream>
#include <algorithm>
#include <cstdio>
#include <cstring>
#include <cmath>
#include <queue>
using namespace std;
int read(){
	int x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
	return x*f;
}
const int N = 3e5+5; 
int f[5] = {0,2,2,3,3};
int cnt[5];
int top,num[N],n,x;
int main(){
	int t = read();
	while(t--){
		n = read();
		top = 0;
		num[++top] = read();
		for(int i=2;i<=n;i++){
			x = read();
			if(f[num[top]]!=f[x]){
				num[++top] = x;
			}else if(f[x]==x){
				num[top] = x;
			}
		}
		if(f[num[top]]==f[num[1]]){
			if(num[top]==f[num[top]]){
				num[1] = num[top];
			}
			top--;
		}
		cnt[1] = cnt[2] = cnt[3] = cnt[4] = 0;
		for(int i=1;i<=top;i++){
			cnt[num[i]]++;
		}
		if(cnt[3]>cnt[1]&&cnt[2]>cnt[4]){
			cout<<"Yes\n";
		}else{
			cout<<"No\n";
		}
	}
	return 0;
}

```

可能有哪里理解错了或者讲的有问题，欢迎指出。