非常棒的题，我发一下题解应该不是很过分（

一般性的做法是半平面莫队，应该可以做到 $O(n\sqrt m)$。

抛开技术不谈，用一些比较简单精巧的做法。

考虑维护一个 $n$ 个点的平面。以解决下半平面的询问为例，考虑一条斜率为 $k$ 的直线从下往上扫过平面时经过的点的顺序。

注意到一对点的顺序会发生反转，当且仅当 $k$ 从小于这两点的斜率变成大于这两点的斜率。

所以求出 $n^2$ 个斜率，将询问按照斜率排序，然后单调扫描，维护点的顺序之后询问的就是一个前缀的若干个点。

通过简单的反证可以发现，如果斜率通过恰当的方式排序，可以使得每次交换的两点都相邻。

那么就只影响两个前缀，贡献是容易算的。

解法已经呼之欲出了：

每次处理若干种数，数的数量总和为 $\Theta(B)$，若存在出现次数 $>B$ 的数，则也是每次处理 $\Theta(B)$ 个这种数，算出每个询问中该数的贡献。

数的值域为 $O(v)$，那么两个斜率之差为 $\Omega(1/v^2)$，可以基数排序。时间复杂度 $O(nB+\dfrac {nm\log n} B)$，取 $B=\sqrt{m\log n}$，时间复杂度为 $O(n\sqrt{m\log n})$。