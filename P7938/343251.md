## 1 题意
将一个长度为 $n$ 的字符串 $S$ 分为 $2m$ 个子序列 ，问是否可以做到在 $2m$ 个子序列中，有至少 $m$ 个是合法的。
## 2 分析
由于我们要让尽量多的子序列合法，那么可以考虑贪心。  
一个合法的括号序列最少是 $ () $ ，那么，我们就可以在字符串里寻找有多少个这样的子序列。  
可以使用类似于括号匹配的思想，每次找到一个左括号就把它压进栈里，如果遇到一个右括号并且栈是非空的，那么就找到了一个合法的 $()$ ，就将左括号出栈的同时记录答案。  
最后判断是否有大于等于 $m$ 个合法括号对即可。  
时间复杂度 $O(Tn)$ 。
## 3 code
```cpp
#include<bits/stdc++.h>
using namespace std;
string s;
int n,m,T;
int main(){
	cin>>T;
	while(T--){
		cin>>n>>m;
		cin>>s;
		int ans=0,now=0;//ans记录合法括号对的个数，now记录栈中左括号的个数，
		for(int i=0;i<n;i++){
			if(s[i]=='('){//左括号就压进栈里
				now++;
			}
			if(s[i]==')'&&now){//右括号如果栈中还有左括号，就记录答案，出栈
				now--;
				ans++;
			}
		}
		if(ans>=m) cout<<1<<endl;//判断
		else cout<<0<<endl;
	}
	return 0;
} 
```
