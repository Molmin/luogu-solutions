笛卡尔树模板。

### 关于笛卡尔树

如题面中所说，笛卡尔树是一棵二叉树，每个结点有两个权值，满足以下性质：

1. 按第一个权值看满足二叉搜索树性质（BST性质）；

2. 按第二个权值看满足小根堆性质。

有关性质解释：

这棵树的每个结点有两个子树，分为左右子树，子树可以为空；

一个结点的左子树中的所有结点的第一个权值都小于其第一个权值（空子树也满足）；

一个结点的右子树中的所有结点的第一个权值都大于其第一个权值（空子树也满足）；

一个结点的两棵子树中的所有结点的第二个权值都大于其第二个权值（空子树也满足）。

题目结出了$1$至$N$的一个排列$p$，表示$i$号结点的第一个权值为$i$，第二个权值为$p_i$，要求我们构造出对应的笛卡尔树，标出每个结点的左儿子和右儿子的编号。

如题目样例给出的排列构造出的树是这样的：

![笛卡尔树.png](https://i.loli.net/2019/12/27/LYTJBA8NnvHhxXC.png)

我们知道由于有堆性质，每个结点到根的链上深度从小到大第二个权值是单调递增的。

又因为BST性质，所以每个结点在第一个权值比其小的结点都被插入后肯定没有右子树，而且肯定不在任意一个已有结点的左子树上。

于是我们想到按第一个权值，在题目中即结点编号，从小到大每次插入一个结点，肯定会插入到从根开始一直访问右儿子直到没有右儿子为止的一条链上某个位置，满足这个位置原来的结点第二个权值大于新插入的结点的第二个权值，且原来结点的父亲结点的第二个权值小于新插入的结点的第二个权值。

我们只要用单调栈处理这样的一条链，找到这个结点后将它的位置设置为新插入的结点并将其变成新插入的结点的左子树即可。

时间复杂度$O(n)$。

Code:
```cpp
#include<cstdio>
#define rg register
#define ll long long
int N;
int a[10000007],d[10000007];
int s[10000007],top;
int ch[10000007][2];
ll lrs,rrs;
inline char rc()
{
	static char buf[1000000],*pn=buf,*pe=buf;
	return (pn==pe)&&(pe=(pn=buf)+fread(buf,1,1000000,stdin),pn==pe)?EOF:*pn++;
}
inline int read()
{
	int f=0;
	char cc=rc();
	while(cc<'0'||cc>'9')cc=rc();
	while(cc>='0'&&cc<='9')f=f*10+cc-'0',cc=rc();
	return f;
}
int main()
{
	N=read();
	for(rg int i=1;i<=N;++i)a[i]=read();
	top=0;
	s[++top]=0;
	for(rg int i=1;i<=N;++i)
	{
		while(top&&a[s[top]]>a[i])ch[i][0]=s[top--];
		if(s[top])ch[s[top]][1]=i;
		s[++top]=i;
	}
	lrs=rrs=0;
	for(rg int i=1;i<=N;++i)
	{
		lrs^=1ll*i*(ch[i][0]+1);rrs^=1ll*i*(ch[i][1]+1);
	}
	printf("%lld %lld\n",lrs,rrs);
	return 0;
}
```