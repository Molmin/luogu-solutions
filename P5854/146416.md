### P5854 【模板】笛卡尔树 题解

------------

前置知识：悬线法

#### 思路

约定：本文中的“笛卡尔树”指权值满足**小根堆**性质的笛卡尔树，称一个点的左边距离它最近的权值比它小的结点为 **“最近左祖先”**，右边距离它最近的权值比它小的结点为 **“最近右祖先”**，点 $i$ 的权值为 $p_i$；为了方便，加入一个**哨兵节点** $0$，满足其权值小于其他所有节点的权值，如果某个节点的没有某个关系对应的节点，将其设为哨兵节点。

我们发现，一个点在笛卡尔树上的父亲必定是其“最近左祖先”与“最近右祖先”中**权值较大的一个**（记为 $f_i$）。

证明：若不满足上述条件，则记其父亲为 $f'_i$，则 $p_{f_i}>p_{f'_i}$。若 $f'_i$ 为 $f_i$ 儿子，则 $f'_i$ 有两个位于其同一侧的儿子，不满足笛卡尔树的二叉搜索树性质。于是 $f'_i$ **不是 $f_i$ 儿子**。$f_i$ 位于 $f'_i$ 与 $i$（在 $f'_i$ 子树中）之间，但是**不在 $f'_i$ 子树中**，不满足笛卡尔树的二叉搜索树性质。

于是，我们只需要求出每个节点的“最近左祖先”与“最近右祖先”，再选择权值较大者作为该节点的父亲即可。

悬线法可以胜任这个问题，并且时间复杂度为 $O(n)$，可以通过本题。

代码（这道题卡常，需把 `cin` 换为 `fread` 快读方可通过）：


```cpp
#include<bits/stdc++.h>

typedef long long ll;

const int N=10001000;
int p[N];
//分别是这个节点“最近左祖先”，“最近右祖先”，左儿子，右儿子的位置，若不存在设为0
int la[N],ra[N],lc[N],rc[N];

signed main(){
	std::ios::sync_with_stdio(0);
	std::cin.tie(0);
	
	int n;
	std::cin>>n;
	for(int i=1;i<=n;i++)std::cin>>p[i],la[i]=i-1,ra[i]=i+1;
	ra[n]=0,p[0]=-0x3f3f3f3f;
	
	for(int i=1;i<=n;i++)while(la[i]&&p[i]<p[la[i]])la[i]=la[la[i]];
	for(int i=n;i;i--)while(ra[i]&&p[i]<p[ra[i]])ra[i]=ra[ra[i]];
	for(int i=1;i<=n;i++)(p[ra[i]]>p[la[i]]?lc[ra[i]]:rc[la[i]])=i;
	ll ans1=0,ans2=0;
	for(int i=1;i<=n;i++){
//		std::cerr<<i<<' '<<lc[i]<<' '<<rc[i]<<'\n';
		ans1^=i*(lc[i]+1ll),ans2^=i*(rc[i]+1ll);
	}
	std::cout<<ans1<<' '<<ans2;
	return 0;
}
```