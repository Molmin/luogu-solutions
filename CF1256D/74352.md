#### 1 题目描述（[传送门](https://www.luogu.com.cn/problem/CF1256D)）

##### 1.1 题目大意

给你一个长度为 $n$ 的二进制串，要求你最多进行 $k$ 次交换相邻两个字符的操作，使得操作后的字符串字典序最小。共有 $q$ 组提问。

##### 1.2 输入格式

第一行一个整数 $q(1\leq q \leq 10^4)$ 。

对于每组提问，第一行两个整数 $n,k(1 \leq n \leq 10^6,1 \leq k \leq n^2)$ 。分别表示二进制数的长度和允许的最大操作数。

第二行是一个由 $n$ 个' $0$ '或' $1$ '组成的字符串。为给定的二进制串。

##### 1.3 输出格式

共 $q$ 行。

每行一个长度为 $n$ 的二进制串，为最多 $k$ 次操作后字典序最小的二进制串。

#### 2 解题思路

贪心。字典序最小，我们需要让前面的数尽可能是 $0$ 。因此，我们的目标是将当前状态下的第一位 $1$ 变成 $0$ 。但是是用哪个 $0$ 去变这个 $1$ 呢？我们来考虑一个例子： $1010$ 。

如果我们用第一个 $0$ ，则可变成 $0110$ 。

如果我们用第二个 $0$ ，则需变成 $0011$ 。但我们发现，在这个过程中，其实是包含 $0110$ 这个过程的，即我们想变成 $0011$ ，就必须经历 $0110$ 。原因很简单，我们考虑第一个 $1$ ，要想变成 $0011$ ，它一定要向后动。它向后动的时候首先变成 $0110$ ，然后才会一点点变成 $0011$ 。

所以，虽然我们用第二个 $0$ 变成的 $0011$ 比用第一个 $0$ 变成的      $0110$ 字典序要小，但是变 $0011$ 的过程可以视作先变成 $0110$ ，再用第一个 $0$ 去替换第一个 $1$ ，将其分解成两部分。因此，我们每一步做的都是将当前状态下第一个 $1$ 和第一个 $0$ 进行交换。

最后考虑 $k$ 这个量。我们每次大交换其实都进行了第一个 $0$ 的下标减第一个 $1$ 的下标的小交换。因此我们只需要判断当前 $k$ 值支不支持我们进行这样的大交换。如果支持，我们直接进行交换，然后修改 $k$ 的值。如果不支持，则将当前状态的第一个 $0$ 尽可能的往前移，用光所有操作次数为止。

#### 3 解题代码

```cpp
#include <iostream>
using namespace std;
int q,n;
long long k;
char s[1000010];
int main()
{
    scanf("%d",&q);
    while(q--)
    {
        scanf("%d%lld%s",&n,&k,s);
        int one=0,zero=0;
        while(one<n&&zero<n&&k)
        {
            while(s[one]=='0'&&one<n)one++;
            zero=max(zero,one);
            while(s[zero]=='1'&&zero<n)zero++;
            if(one>=n||zero>=n)break;
            if(zero-one<k)
            {
                s[one]='0';
                s[zero]='1';
                k-=(zero-one);
            }
            else
            {
                s[zero-k]='0';
                s[zero]='1';
                k=0;
                break;
            }
        }
        printf("%s\n",s);
    }
    return 0;
}
```

#### 4 解题心得

代码部分没有写注释，按照思路模拟即可。

 $zero$ 要取 $zero$ 和 $one$ 中大的那个，否则如果只取 $one$ 的话会    $TLE$ 。

开 $long\ long$ ，开 $long\ long$ ，开 $long\ long$ 。 $k$ 到 $n^2$ ，没开 $long\ long$ 调了半个小时。