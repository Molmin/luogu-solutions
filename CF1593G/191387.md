题意：有小括号和中括号共 $n$ 个，可以任意翻转其方向。求至少需要将多少个中括号变为小括号以使该括号序列合法。

核心思想：前缀和

解：

首先，可以发现，只要中括号序列合法并且所有中括号内部都有偶数个小括号，则可以将中括号内的小括号两两分组，并将中括号外的小括号围绕中括号安排使序列合法。如：在 $12$ 个括号长的序列中 $2,7,10,11$是中括号，则有：

| 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11| 12|
| -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | 
| ( | [ | ( | ( | ) | ) | ] | ( | ) | [ | ] | ) |  |  |  |  |  |  |

然后可以发现，只要奇数位与偶数位上中括号数量相等，就可以将它们一一对应以满足上述条件。对于每个初始序列，可以用前缀和来存储中括号位置（奇数位记为 $1$，偶数位记为 $-1$），再求出奇偶位置中括号数量差的绝对值即可。

代码：
```
#include <bits/stdc++.h>
using namespace std;
long long t, n, q, l, r, s[1000001];
char ch[1000001];
int main()
{
	cin>>t;
	for(int i=1; i<=t; i++)
	{
		memset(ch, 0, sizeof(ch));
		memset(s, 0, sizeof(s));
		cin>>ch+1>>q;
		n=strlen(ch+1);
		for(int j=1; j<=n; j++)
			if(ch[j]=='[' || ch[j]==']')
				if(j%2==1)
					s[j]=s[j-1]+1;
				else
					s[j]=s[j-1]-1
			else
				s[j]=s[j-1];//计算前缀和
		for(int j=1; j<=q; j++)
		{
			cin>>l>>r;
			cout<<abs(s[r]-s[l-1])<<endl;//计算差值
		}
	}
	return 0;
}
```