### [**前置芝士**](https://oi-wiki.org/dp/probability/)

这道题其实是很好的一道期望 $dp$ 题（~~其实我是奔着  OSU 来的~~），至于什么是 `期望dp` ,上面有/cy。

设 $f_i$ 为点到 $i$ 位置时的期望分数，再设 $k_i$ 为点到 $i$ 位置时的期望长度，然后将 $k_i$ 状态转移就是

$$k_i=(k_{i-1}+1) \times p_i$$

（$p_i$ 为第 $i$ 次点击成功的概率）

那么我们就将点到 $i$ 位置时的期望分数（也就是 $f_i$）进行状态转移。

于是就会出现如下的两种情况：

1. $i$ 位置上的字母为 $X$：期望分数应该为~~上一个~~$f_{i-1}$。
2. $i$ 位置上的字母为 $O$：由于不能直接求解，所以我们需要设 $cnt$ 为连续的字母个数，解得 $(x+1)^2$，利用完全平方公式可得 $x^2+2x+1$，所以最终解得期望分数应该为 $(f_{i-1}+2 \times k_{i-1}+1) \times p_i$。

所以把以上几种情况集中到一起便是：

$$f_i=f_{i-1} \times (1-p_i)+(f_{i-1}+2 \times k_{i-1}+1) \times p_i$$

最终把这个状态转移方程代入代码里就可得到最终的答案。

```
#include <bits/stdc++.h>
using namespace std;
int n;
double p[100005],f[100005],k[100005];
int main(){
    cin>>n;
    for(int i=1;i<=n;i++)
		cin>>p[i];
    for(int i=1;i<=n;i++){
		k[i]=(k[i-1]+1)*p[i];
		f[i]=((f[i-1]+2*k[i-1]+1)*p[i])+(f[i-1]*(1-p[i]));
	}
	printf("%.15lf\n", f[n]);
    return 0;
}
```