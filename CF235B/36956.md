# 题意
有$n$个操作，每个操作有$p_i$几率成功，连续$k$次成功会给总分贡献$k^2$，求最后总分的期望。

# 解题思路
前置：
- 期望的线性性质：$E[aX+b] = aE[X]+b$。
- 区别：$E[X^2]$和$E[X]^2$


先考虑线性情况，即每$i$个连击贡献$i$分值的这种情况。
设$X_i$为经过$i$个操作的**总分**，那么$E[X_i]$经过$i$个操作的**期望总分**，对于第$i$个操作而言，如果成功了，那么总贡献就是上一次的期望总分+1，如果失败了那么总分就不变。求$E[X_i]$可以写成
$$
\begin{aligned}
E[X_i] &= p_iE[X_{i-1}+1] + (1-p_i)E[X_{i-1}] \\
E[X_i] &= p_iE[X_{i-1}] + p_i + E[X_{i-1}] - p_iE[X_{i-1}] \\
E[X_i] &= E[X_{i-1}]+p_i
\end{aligned}
$$

但是如果每个$i$连击贡献$i^2$个，那么此时对于期望总分的贡献就不能只是+1了。
假设经过$i-1$号操作后的连击数为$Y_{i-1}$，那么$i$号操作成功它会对**总分**的贡献是$(Y_{i-1}+1)^2-Y_{i-1}^2 = 2Y_{i-1} + 1$。则对于**期望总分**的贡献是$E[2Y_{i-1} + 1]$。
根据期望的线性性质，我们需要求的就是$2E[Y_{i-1}] + 1$。
$E[Y_i]$翻译成人话就是**经过$i$号操作后的连击数的期望**，这个东西很好求。从$i-1$开始推，如果$i$成功，那么期望连击数就是$E[Y_i]+1$，如果失败直接变成0。于是有：
$$
E[Y_i] = p_i(E[Y_{i - 1}] + 1)
$$
于是我们可以事先求出$E[Y_i]$，然后应用到平方贡献里。设$Z_i$为经过$i$个操作以后的**总分**（此时使用的是连击数的平方)，那么所求就是$E[Z_i]$，即经过$i$个操作以后的**期望总分**
$$
\begin{aligned}
E[Z_i] &= p_i(E[Z_{i-1}+2Y_i+1]) + (1-p_i)E[Z_{i-1}]\\
E[Z_i] &= E[Z_{i-1}] + p_i(2E[Y_i] + 1)
\end{aligned}
$$
那么$E[Z_n]$就是答案了。

注意$X,Y,Z$是三个不同的随机变量

# 拓展
假设每段长度为$i$的连击贡献$f(i)$的分数，那么设（我也不知道该用什么字母）$A_i$为为经过$i$个操作以后的**总分**，所求是$E[A_i]$
$$
E[A_i] = p_iE[A_{i-1} + f(Y_{i-1}+1)-f(Y_{i-1})] + (1-p_i)E[A_{i-1}]
$$
那么假设$f(i) =i^3$，展开后可得
$$
\begin{aligned}
E[A_i] &= p_iE[A_{i-1} + (Y_{i-1}+1)^3 - Y_{i-1}^3] + (1-p_i)E[A_{i-1}] \\
E[A_i] &= p_i(E[A_{i-1}] + E[(Y_{i-1}+1)^3 - Y_{i-1}^3]) + (1-p_i)E[A_{i-1}] \\
E[A_i] &= E[A_{i-1}] + p_iE[Y_{i-1}^3+3Y_{i-1}^2+3Y_{i-1}+1-Y_{i-1}^3]\\
E[A_i] &= E[A_{i-1}] + p_iE[3Y_{i-1}^2+3Y_{i-1}+1]\\
E[A_i] &= E[A_{i-1}] + p_i(3E[Y_{i-1}^2]+3E[Y_{i-1}] + 1)
\end{aligned}
$$
$E[Y_{i-1}]$我们之前求过，那么问题就在于怎么求$E[Y_{i-1}^2]$。
$$
\begin{aligned}
E[Y_i^2] &= p_i(E[(Y_{i-1}+1)^2])\\\\
E[Y_i^2] &= p_i(E[Y_{i-1}^2+2Y_{i-1}+1])\\\\
E[Y_i^2] &= p_i(E[Y_{i-1}^2]+2[Y_{i-1}]+1])
\end{aligned}
$$
到这里，我们就应该会求$E[Y_i^2]$了吧。
搞清楚到底是总分还是总分的期望应该就是这道题最关键的一点了。

# 时间复杂度
$O(n)$
# 参考代码
```cpp
int main() {
#ifdef LOCALLL
    freopen("in", "r", stdin);
    freopen("out", "w", stdout);
#endif
    scanf("%d", &n);
    for (int i = 1; i <= n; i++) {
        scanf("%lf", &p[i]);
        EY[i] = (EY[i - 1] + 1) * p[i];
    }
    for (int i = 1; i <= n; i++) {
        EZ[i] = EZ[i - 1] + (2 * EY[i - 1] + 1) * p[i];
    }
    printf("%lf", EZ[n]);
    return 0;
}
```