我用了一种比较简单想的方法:直接开一个数组记录每种删除方式得到的剩下和,最后排下序即可

上代码:
```cpp
#include<iostream>
#include<algorithm>
using namespace std;
int main()
{
	int a[6],i,s=0,t[11]={},p=0;//t记录每次结果,p记录t数组下标,s记录一下全部的和
	for(i=1;i<=5;i++)
	{
		cin>>a[i];
		s+=a[i];//s记录全部和
	}
	sort(a+1,a+6);//要对a数组排下序才能判断是否有重复
	for(i=2;i<=4;i++)//不能取两边
	{
			if(a[i]==a[i-1]&&a[i]!=a[i+1])//如果只删两个
				t[++p]=s-a[i-1]-a[i];//总和减去这两个
			if(a[i]==a[i-1]&&a[i]==a[i+1])//如果删三个
				t[++p]=s-a[i-1]-a[i]-a[i+1];//总和减去这三个
	}
	if(a[4]==a[5])//要判断一下最后两个是否有删的可能
		t[++p]=s-a[4]-a[5];//总和减去最后两个
	sort(t+1,t+p+1);//对结果数组排序
	if(t[1]==0)//如果没有赋过值(最开始初值为0)
		cout<<s;//就不删,输出总和
	else//如果有删的方案
		cout<<t[1];//输出剩下最小的
	return 0;//完美结束
}
```
# 请勿抄袭