我们可以考虑一种最基本的情况，如果 $n$ 是偶数，$m$ 也是偶数，我们自然可以正好放置偶数张骨牌。因为我们可以把这张 $n\times m$的矩阵分成 $\frac{n}{2}\times\frac{m}{2}$ 的 $2\times 2$ 的子矩阵，对于每个子矩阵中的两张骨牌，骨牌既可以竖着放置，也可以横着放置。而放置奇数张骨牌就不行。因为如果要凑出偶数的高度，需要有若干张竖着放置的骨牌，和若干张（偶数）横着放置的骨牌。如果有奇数张骨牌，也就必然有一张骨牌无法与别的骨牌配对，也自然凑不出偶数的高度。

对于这道题除了这个最基本的情况还有两种情况，$n$ 是奇数的情况和 $m$ 是奇数的情况，对于前者，我们可以把这个矩阵分成最后一列和剩余的部分，最后一列有 $\frac{m}{2}$ 个横着的骨牌，而剩余的部分可以凑出任意偶数数目的横着的骨牌。所以我们可以证得当 $0\leq k-\frac{m}{2}\leq\frac{(n-1)m}{2}$   且 $k-\frac{m}{2}$ 为偶数时，有满足条件的方案。要凑出奇数的高度，就必须有若干张竖着放置的骨牌，和若干张（奇数）横着放置的骨牌。因为一张横着放置的骨牌的宽度为 $2$，所以至少要 $\frac{m}{2}$ 张骨牌才能使每列都满足条件，所以可以证明上述条件是正确的。对于后者，我们也可以类似地证明，当 $0\leq k \leq \frac{n(m-1)}{2}$ 且 $k$ 为偶数时，有满足条件的方案。

所以代码如下：

```cpp
// User: xinchengo
// Fear cuts deeper than swords.

#include<iostream>
using namespace std;
int t;
int n, m, k;
int main()
{
    cin >> t;
    while (t--)
    {
        cin >> n >> m >> k;
        if (n % 2 == 0 && m % 2 == 0)
        { // n, m, 均为偶数，最基本的情况
            if (k % 2 == 0)
            { // 如果 k 是偶数则有解
                cout << "YES" << endl;
            }
            else
            { // 反之则无解
                cout << "NO" << endl;
            }
        }
        else if (n % 2 != 0 && m % 2 == 0)
        { // n（行数）为奇数的情况，前者
            if ((k - m / 2) % 2 == 0 && k - m / 2 >= 0 && (n - 1) * m >= k - m / 2)
            { // 前面证明的判断条件
                cout << "YES" << endl;
            }
            else
            {
                cout << "NO" << endl;
            }
        }
        else if (n % 2 == 0 && m % 2 != 0)
        { // m（列数）为奇数的情况，后者
            if (k % 2 == 0 && n * (m - 1) / 2 >= k)
            { // 前面证明的判断条件
                cout << "YES" << endl;
            }
            else
            {
                cout << "NO" << endl;
            }
        }
    }
}
```
