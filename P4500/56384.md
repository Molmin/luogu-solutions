STO jry Orz

~~吉老师带我飞~~

由于官方题解省略了全部的细节而std是拿指数生成函数写的，官方题解半句话没提这事，所以可能有些人会像我一样对着标算里的polyexp和polyln无限懵逼……而且更加nb的是std里的polyln和exp是极为罕见的$O(n^2)$暴力实现，然后我就更加懵逼了

~~所以写一篇题解来纪念一下这道烧了我3天的毒瘤题~~

~~另外感谢_rqy,rqy是我们的红太阳没有它我们会死~~
_______________

## 前置芝士:burnside引理/polya定理

如果您不会这东西的话请设法百度/看博客学会这个东西

并且这篇题解为了描述方便我们将使用群论术语~~放弃说人话~~

所以您必须知道这些名词是什么，如果不懂的话请自行百度

**群,子群,置换群,置换,轮换,置换环,群G作用于集合X,轨道,稳定化子,轨道-稳定集定理，burnside引理，polya定理**

# 本题题解

## 整理题意

按照大家一种常用的方式random k棵有根树，问random出来的有根树全部同构的概率

~~真是毒瘤出题人，一个点居然有1e9棵树~~

那么我们知道这样一共可以生成$(n-1)!$种不同的有根树，由于我们生成了k棵树所以总方案数就是$(n-1)!^k$

那么一个非常暴力的思路就是枚举所有可能的树然后用树hash判同构，然后算出每一种hash值的出现次数，所有hash值出现次数的k次方之和就是生成的k棵树全部同构的方案数了，我们把这个数字除以$(n-1)!^k$就可以得到答案了

以下为了方便起见，我们认为一个等价类是指一堆**标号不同**但是彼此同构的有根树，这篇题解中出现的**等价类size的xx次幂之和**这样的东西是指所有不同的等价类的大小的xx次幂的和

## 从一个naive的dp开始

我们来尝试一个非常诡异的dp状态，$dp(i,j)$表示size为i的树的等价类size的jk次幂之和

说人话就是$dp(i,j)$表示生成$j×k$棵大小为$i$的树，并且这些树全部同构的方案数

此时我们发现这个状态十分的诡异，从j这一维的定义来看我们看不到什么成功转移的可能性，因为我们的答案是$dp(n,1)$所以答案明显是从$j$比较大的维度转移过来的，但是好像这样转移j会无限增大下去……

不过值得庆幸的是这个状态至少有边界$dp(1,x)=1$所以我们抱着一丝希望开始推这个dp的转移……

由于j这一维我们暂时不知道怎么处理，所以我们暂时考虑只考虑i这一维的转移

我们发现把一个大小为i的树的树根删掉之后我们会得到一堆树

那么我们不妨设$tmp(i,j,p)$表示仅用大小不超过$i$的树凑出size和为p的一堆树的等价类size的jk次幂

说人话就是$dp(i,j)=tmp(i-1,j,i-1),tmp(1,xxx,xxx)=1$

当然这样的话空间似乎开不太下所以我们的tmp是滚动数组实现的，我们把$i$那一维滚掉，然后用$tmp(i-1,j,i-1)$求出来$dp(i,j)$之后我们就直接迭代到$tmp(i,j,xxx)$这一个数组上


那么假如我们知道了$tmp(i-1,j,xxx)$这个数组，我们怎么转移到$tmp(i,j,xxx)$这个数组上呢？

答案是做背包，我们可以列出来这样一个转移式子

$$tmp(i,j,t)=\sum_{i×v+k=t}tmp(i-1,j,k)f(i,v,j){t\choose i×v}^{jk}$$

其中$f(i,v,j)$表示选择$v$棵$size$为$i$的树产生的等价类size的jk次幂之和

说人话就是我们枚举size为i的子树有几个然后大力做背包

然后我们的转移式子中出现了一个令人迷惑的组合数……，

值得注意的是处于同一个等价类的数彼此之间同构，所以区别他们的只有标号

那么$f(i,v,j)tmp(i-1,j,k)$表示的是令$f(i,v,j)$这些树的标号全部大于$tmp(i-1,j,k)$中的树的标号所产生的等价类size的jk次幂之和

但是事实上我们并没有$f(i,v,j)$的标号必须更大这个限制，我们其实只需要保证$f(i,v,j)$和$tmp(i-1,j,k)$这两堆树内部编号的大小关系不变即可……(如果内部的编号顺序改变会影响父子关系)，所以我们有${t\choose i×v}$中方式重新混合标号，因此等价类的size会扩大${t\choose i×v}$倍，那么等价类size的jk次幂就会扩大${t\choose i×v}^{jk}$倍了

好了至此为止我们看起来只需要计算出$f(i,v,j)$然后把这东西喂进去我们就能得到令人满意的答案了

然后这就是噩梦的开始，因为接下来我们会意识到$f(i,v,j)$令人吃鲸的难算……

这里先说一个后面会有用的结论:$iv$的乘积绝对不会超过$n$

## 计算$f(u,v,j)$

也就是无序的选择$v$棵$size$为$u$的树所产生等价类$size$的$jk$次幂之和

注意这里有个限制叫**无序**，过一会我们会深刻认识到这东西对dp产生的干扰效果有多强烈

首先我们需要认识到一件事情是答案并不是

$$dp(u,vj)(\frac{(uv)!}{(u!)^v})^{jk}$$

先来解释一下上面式子的组合意义，我们单纯的把$v$棵$dp(u,j)$这样的树放在一起会产生$dp(u,vj)$这么大的等价类，然后重新分配标号之后等价类的size扩大$\frac{(uv)!}{(u!)^v}$这么多倍，就得到了上面这个式子

然鹅我们犯了两个致命的错误……$dp(u,vj)$表示的是v棵彼此同构的树放到一起的方案数，因为我们将次数提升了v次的意思每个等价类直接复制v份，换句话讲生成的v棵树就会全部同构

另一个致命的错误是，当有些树是同构的时候我们不能直接重新分配标号

比如考虑这样两颗树

![](https://cdn.luogu.com.cn/upload/pic/48222.png)

![](https://cdn.luogu.com.cn/upload/pic/48223.png)

一个正常人都会发现就算是带标号这两个树长得也是一膜一样……

但是如果我们重新分配标号的时候这两个树就会被算成两种不同的方案

为什么呢？因为左右子树是**同构**的,如果左右子树不同构，那么我们就不会出现这个问题，比如下面的两颗树标号就不相同

![](https://cdn.luogu.com.cn/upload/pic/48224.png)

![](https://cdn.luogu.com.cn/upload/pic/48225.png)

同样是交换了左右子树的编号但是如果被交换标号的树是同构的就其实一种方案了



那么我们总结一下我们现在想干什么

由于$\frac{(uv)!}{(u!)^v}$这种分配标号的方式非常的蠢，他会认为所有的子树互不同构，但是其实有些子树是同构的，此时我们分配标号就会出现偏差……

那么我们可以用一组整数拆分$\{a_{1},a_{2},a_{3}...a_{m}\}$来描述一组树的同构情况,表示一共有m种不同形状的树，第i种形状有$a_{i}$棵

那么答案就是

$$\sum_{a_{1}+a_{2}...a_{m}=v}f(a_{1},a_{2}..a_{m})\prod_{i=1}^{m}\frac{1}{(a_{i}!)^k}$$

其中$f(a_{1},a_{2}..a_{m})$表示同构情况为这种整数拆分的等价类size的jk次幂之和

关于求$f(a_{1},a_{2}...a_{m})$有一个精妙的容斥做法可以处理它，然鹅我们发现容斥的复杂度和整数拆分数有关,根本过不去$n=2000$的大数据……

关键是我们为什么会重复呢？,是因为如果我们直接计算

$$\prod_{i=1}^{m}dp(u,a_{i}j)$$

他是不等于$f(a_{1},a_{2}...a_{m})$的，因为两个dp之间会包含一模一样的等价类，换句话说，我们的树组当中，有些同构的树没有排在一起，而我们仅仅希望计算那些同构的树都挨在一起的树组

用群论的语言说一遍就是:

我们令一个置换群$G$中的元素为全体长度为$m$的置换，

我们定义一种集合$X$,$X$中的元素是一个长度为$v$的树的向量，并且向量中每颗树大小为u,每颗树的标号都在$[1,u]$之间，(因为此时我们还没有重新分配标号)

现在令$G$作用于$X$上，设$Orbit(x)$表示一个特定元素x的轨道

我们令一个元素的权值为

$$w(x)=\prod_{i=1}^{m}dp(u,a_{i}j)$$

假设这个元素的同构情况为$\{a_{1},a_{2},a_{3}...a_{m}\}$

显然$Orbit(x)$中的元素权值全部等于$w(x)$，因此我们令一个轨道的权值为其中任意一个元素的权值，也就是$w(x)$

换言之

$$w(Orbit(x))=w(x)$$

现在我们希望计算所有轨道的权值之和，也就是这个式子

$$\sum_{x \in X}\frac{w(Orbit(x))}{|Orbit(x)|}\prod_{i=1}^{m}\frac{1}{(a_{i}!)^k}$$

所以此时我们点别的方式来帮助我们去重，说到去重，置换群，轨道，我就想起了burnside引理

## burnside引理的加权形式

显然这里我们统计的根本不是什么方案数，所以平常的burnside引理看起来不能用了

还好我们的burnside引理是有拓展形式的，令$w(orbit(x))=w(x)$，其中$w$是一个特定的权重函数

那么**所有轨道的权值之和等于所有置换的不动点权值之和平均数**

即burnside引理在权重形式下依然成立

$$\sum_{x \in X}\frac{w(Orbit(x))}{|Orbit(x)|}=\frac{1}{|G|}\sum_{f}w(fix(f))$$

等会啊……这个和我们刚才的式子还是有差距……

刚才的式子还有一个系数……

不好意思，这东西已经塞不到轨道的权重函数里去了……(虽然你乍一看能塞进去但是其实塞不进去，会影响后面的dp)

所以让我们来折腾稳定化子好了，我们让稳定化子也带上权

令$w(stab(x))$为x的所有稳定化子的权值之和

那么只要等式

$$|Orbit(x)|w(stab(x))=\prod_{i=1}^{m}\frac{1}{(a_{i}!)^k}$$

成立，根据burnside引理的证明过程我们就可以推出

$$\sum_{x \in X}\frac{w(Orbit(x))}{|Orbit(x)|}\prod_{i=1}^{m}\frac{1}{(a_{i}!)^k}=\frac{1}{|G|}\sum_{f}w(f)w(fix(f))$$

好了擦亮你的眼睛，中间连的是个**等号**

所以这个式子是成立的

$$f(u,v,j)=\frac{1}{v!}\sum_{f}w(f)w(fix(f))$$

wow f函数终于能算了！

接下来我们需要请出polya定理了，polya定理告诉我们每一个置换环是独立的，所以假设一个置换f可以被分解为${a_{1},a_{2},a_{3}...a_{m}}$这样的置换环(意思是一共m个置换环第$i$个size为$a_{i}$)

那么我们会有这样的一个式子

$$w(f)w(fix(f))=\prod_{i=1}^{m}dp(u,a_{i}j)w(a_{i})$$

（此时你会发现我们的j这一维终于有边界了！转移的时候两维的乘积越来越小，所以状态$dp(i,j)$合法当且仅当$ij\leq n$）

这里为什么$dp$之间可以乘起来呢？因为我们算的就是不动点权值之和，这里当两个dp对应的树有重复的时候造出来的是一个有序的向量，并且由于同底数幂相乘等于指数相加，所以权值函数还是对的，因此自然也是一个不动点了

这也是为什么我们不能把阶乘丢到权值函数里，因为阶乘会导致不动点权值的计算不能套polya定理……，所以我们只能忍痛把权值放到稳定化子里去了……

好了现在唯一的问题就是置换环的权值怎么算

~~这个一会再说~~，让我们假装自己知道了每个置换环的权值，当然随着$j$的不同置换环的权值是不同的，假设$xs(j,i)$表示jk次幂时大小为i的置换环的权值，那么我们计算置换权值乘不动点权值之和的时候就是用$f(i)=xs(j,i)dp(u,ij)$这些单个环的权值去拼整个置换的权值

那么我们设$g(i)$表示所有长度为$i$的权值之和，那么我们可以列出这样一个和式

$$g(n)=n!\sum_{1a_{1}+2a_{2}+3_a{3}...ma_{m}=n}\prod_{i=1}^{m}\frac{f(i)^{a_{i}}}{i^{a_{i}}a_{i}!}$$

解释一下和式就是我们枚举置换环的分布情况，然后这里有一个结论是如果长度为i的置换环出现了$a_{i}$次那么置换环分布为$\{a_{1},a_{2}...a_{m}\}$的排列个数为

$$\frac{n!}{\prod_{i=1}^{m}i^{a_{i}}a_{i}!}$$

那么我们再一看刚才那个式子其实就是套路的枚举分布情况算贡献了

具体来讲我们计算$g(i)$可以大力$dp(i,j)$表示用不超过$i$的置换环拼成长度为$j$的置换的方案数,转移的时候大力枚举长度为$i+1$的置换环出现了几次然后背包就行了

这样去做背包我们可以把长度为$1$到$n$的【置换权值乘不动点权值】之和都给刷出来,并且背出来的数组就是权值和除过$|G|$的结果,所以我们也不用除$|G|$了

换句话讲假如我们需要$f(u,1,j),f(u,2,j),f(u,3,j)...f(u,v,j)$的值的话，我们把这些值全部刷出来的复杂度是$O(v^2logv)$的

~~其实你会发现那东西就是polyexp~~

好了现在让我们来考虑置换环的权值是什么……

置换环的权值$xs(j,i)$应该能让我们满足这个恒等式

$$\frac{|Orbit(x)|w(stab(x))}{|G|}=\prod_{i=1}^{m}\frac{1}{(a_{i}!)^{jk}}$$

让我们来考虑$|Orbit(x)|=1$的状态,这种情况下x其实是一个非常特殊的状态，这个向量里的所有树都同构，那么显然任意一个长度为m的置换都是这个状态的稳定化子

换句话讲我们用一个特殊的状态把长度为$m$的置换权值之和给套出来了……，长度为m的置换的权值之和就是

$$\frac{1}{m!}\sum_{f}w(f)=\frac{1}{(m!)^{jk}}$$

那么我们知道所有置换环的权值还等于各个置换环做背包的结果

也就是说

$$\sum_{1a_{1}+2a_{2}+3_a{3}...ma_{m}=n}\prod_{i=1}^{m}\frac{xs(j,i)^{a_{i}}}{i^{a_{i}}a_{i}!}=\frac{1}{m!}\sum_{f}w(f)=\frac{1}{(m!)^{jk}}$$

那么假设我们推出了前$i-1$项置换环的系数，我们就可以背包背出来用不超过$i-1$的置换环凑出来的置换的系数和,我们知道这东西加上长为$i$的置换环的权值就是$\frac{1}{(i!)^{jk}}$所以减一下就行了

所以我们算置换环的系数就是边背包边容斥，如此这般就能求出来了

~~其实你会发现这东西就是poly_ln~~

## 复杂度分析

如果你把上面的算法实现出来你会发现他的复杂度是

$$\sum_{i=1}^{n}O((n/i)^2log(n/i))=O(n^2log^2n)$$

这个复杂度已经可以丑陋的通过这题了

标算的使用了polyexp和polyln的组合意义，复杂度为

$$\sum_{i=1}^{n}O((n/i)^2)=O(n^2logn)$$

这东西相当快，大概600ms左右

~~但是全程指数生成函数对调试极端不友好……~~

上代码~

```C
// luogu-judger-enable-o2
// luogu-judger-enable-o2
#include<algorithm>
#include<cstdio>
using namespace std;const int N=2*1e3+10;typedef unsigned long long ll;ll mod;
inline ll po(ll a,ll p){ll r=1;for(;p;p>>=1,a=a*a%mod)if(p&1)r=r*a%mod;return r;}
int n;int k;ll dp[N][N];ll tmp[N][N];ll ck[N][N];ll tr[N];ll f[N];ll xs[N][N];
ll cjk[N][N];ll fac[N];ll ifac[N];ll inv[N];
inline void pre()//处理一些该处理的东西 
{
    fac[0]=1;for(int i=1;i<=n;i++)fac[i]=fac[i-1]*i%mod;
    inv[0]=1;inv[1]=1;for(int i=2;i<=n;i++)inv[i]=(mod-mod/i)*inv[mod%i]%mod;
    ifac[0]=1;for(int i=1;i<=n;i++)(ifac[i]=ifac[i-1]*inv[i])%=mod;
    for(int i=0;i<=n;i++)
    {
        ck[i][0]=ck[i][i]=1;
        for(int j=1;j<i;j++)ck[i][j]=(ck[i-1][j-1]+ck[i-1][j])%mod;
    }for(int i=0;i<=n;i++)for(int j=0;j<=i;j++)ck[i][j]=po(ck[i][j],k);
    for(int i=1;i<=n;i++)xs[i][1]=1;
    for(int j=1;j<=n;j++)//背包加容斥处理出置换环系数 
    {
        int lim=n/j;
        for(int i=0;i<=lim;i++)f[i]=ifac[i];
        for(int i=2;i<=lim;i++)
        {
            xs[j][i]=(po(ifac[i],(ll)j*k)+mod-f[i])%mod;ll ret=xs[j][i];ll val=ret;
            for(int p=0;p<=lim;p++)tr[p]=f[p];
            for(int p=1,si=i;si<=lim;p++,si+=i,val=val*ret%mod*inv[p]%mod)
                for(int t=lim;t>=si;t--)(tr[t]+=f[t-si]*val)%=mod;
            for(int p=0;p<=lim;p++)f[p]=tr[p];
        }
    }
}
inline void calcf(int siz,int lim,int pw)//计算f函数就是大力背包 
{
    for(int i=1;i<=lim;i++)f[i]=0;f[0]=1;
    for(int i=1;i<=lim;i++)
    {
        ll ret=xs[pw][i]*dp[siz][i*pw]%mod;ll val=ret;
        for(int j=1;j<=lim;j++)tr[j]=f[j];
        for(int j=1,si=i;si<=lim;j++,si+=i,val=val*ret%mod*inv[j]%mod)
            for(int t=lim;t>=si;t--)(tr[t]+=f[t-si]*val)%=mod;
        for(int j=1;j<=lim;j++)f[j]=tr[j];
    }for(int i=1;i<=lim;i++)
        (f[i]*=po(fac[siz*i],(ll)pw*k)*po(ifac[siz],(ll)i*pw*k)%mod)%=mod;
}
int main()
{
    scanf("%d%d%lld",&n,&k,&mod);pre();
    for(int i=1;i<=n;i++)dp[1][i]=1;
    for(int i=1;i<=n;i++)for(int j=0;j<=n;j++)tmp[i][j]=1;
    for(int i=2;i<=n;i++)//大力dp转移即可 
    {
        for(int j=1;j<=(n/i);j++)dp[i][j]=tmp[j][i-1];
        for(int p=1;i*p<=n;p++)
            for(int t=n,siz=i*p;t>=siz;t--)cjk[t][siz]=1;
        for(int j=1;i*j<=n;j++)
        {
            for(int p=1;i*p*j<=n;p++)
                for(int t=(n/j),siz=i*p;t>=siz;t--)(cjk[t][siz]*=ck[t][siz])%=mod;
            calcf(i,n/(i*j),j);
            for(int t=0;t<=(n/j);t++)tr[t]=tmp[j][t];
            for(int p=1;i*j*p<=n;p++)
            {
                for(int t=(n/j),siz=i*p;t>=siz;t--)
                    (tr[t]+=tmp[j][t-siz]*f[p]%mod*cjk[t][siz])%=mod;
            }for(int t=0;t<=(n/j);t++)tmp[j][t]=tr[t];
        }
    }printf("%lld",dp[n][1]*po(ifac[n-1],k)%mod);return 0;//拜拜程序~ 
}
```








































