# CF1415C Bouncing Ball

设删掉 $l$ 块，等价于让球从 $p + l$ 开始弹，为了方便编程和思考，接下来将以这种模型分析本题。

因为 $k$ 是固定的，所以只要 $l$ 确定了，最后的花费就确定了，所以每组数据只有 $n - p + 1$ 种方案 ($0 \leq l \leq n - p$)，只要枚举每种方案的花费即可。

首先打出暴力，枚举删除块数 $l$，然后模拟弹跳，需要加平台就加平台，从每一种方案的花费中选出最小花费。单组数据时间复杂度 $O(\frac{n^2}k)$。

然后思考优化，发现枚举 $l$ 和 $l + k$时，除了对于删 $l$ 时第一个讨论的落点以外，其它落点都时重复计算的，而且对于每一个 $l$ 都是这样，周期固定为 $k$。

不妨新建一个数组 `f[l]`，存储每一个满足 $0 \leq l < k$ 的方案增加平台的总花费。预处理复杂度 $O(\frac{nk}k)$，即 $O(n)$。

预处理后开始枚举每一个 $l$，先看看已经删掉的 $l + p - k$ 是否要加一个平台，即是否原来没有平台，如果本来没有，那么在 `f[l % k]` 中一定计算了给 $l + p - k$ 加平台的花费，由于当前方案这个块被删除了，所以不能再计算给 $l - p + k$ 加平台的花费了，要减掉。

不要忘记特判 $l < k$ 的情况，由于一开始不删点也不会落到 $l + p - k$ 上，所以 `f[l % k]` 本来就没有计算 $l + p - k$ 是否加平台的花费，所以不进行上一段提出的对 `f[l % k]` 的修正。

有了预处理后的枚举过程被优化到了 $O(n - p)$，所以单组数据总复杂度为 $O(n)$，总复杂度 $O(sum_n)$，符合要求。

## 代码

```cpp
int n, p, k, t, ans, b, c, tmp, f[100005];
char S[100005];
bool a[100005];
void Clr() {  //初始化变量和数组
  n = RD();   //读入优化已省略
  p = RD();
  k = RD();
  gets(S);
  b = RD();
  c = RD();
  for (register int i(0); i < n; ++i) {
    a[i + 1] = S[i] - '0';  //将字串转化为 bool 数组, 存某一位上是否有平台
  }
  memset(f, 0, sizeof(f));
  ans = 0x7f3f3f3f;
  return;
}
int main() {
  t = RD();
  for (register int T(1); T <= t; ++T) {
    Clr();
    for (register int i(0); i < k; ++i) {  //枚举符合 0 <= l < k 的 l
      for (register int j(p + i); j <= n; j += k) {  //模拟弹跳
        if (!a[j]) {                                 //无平台
          f[i] += b;                                 //加平台
        }
      }
    }
    for (register int i(0); i <= n - p; ++i) {  //枚举每个方案中的 l
      tmp = c * i;                              //删除 i 块需要的花费
      if (i >= k) {
        if (!a[i + p - k]) {  // f[i % k]中计算了给 i + p - k 加平台的花费
          f[i % k] -= b;  //不用给已经删掉的块加平台
        }
      }
      tmp += f[i % k];  //删除 i 块的花费 + 加平台的花费 = 总花费
      ans = min(ans, tmp);  //更新最优方案
    }
    printf("%d\n", ans);
  }
  return 0;
}
```