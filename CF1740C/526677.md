### 题目大意

有一堆物品，每个物品有一个价值。一个人把这堆东西放进三个袋子里（每个袋子不为空，且保证至少有三个物品），另一个人要在三个袋子中分别取一个物品。设这三个物品价值为 $x$、$y$ 和 $z$，总价值为 $\left\vert x-y\right\vert+\left\vert y-z\right\vert$。取出时会**最小化**总价值，求怎么放能使总价值**最大**。

### 分析

因为总价值和绝对值有关，所以可以分类讨论绝对值的正负，也就是值的大小关系。我们看到式子里 $y$ 出现了两次，就可以讨论 $y$ 的大小。

可以先设 $x \geqq z$，则有以下三种情况：

1. $y$ 小于 $x$ 和 $z$，总值为 $x+z-2y$。 

1. $y$ 大于 $x$ 和 $z$，总值为 $2y-x-z$。 

1. $y$ 在 $x$ 和 $z$ 之间，总值为 $x-z$。

而第三种情况明显不是最优，因为把 $x$ 和 $y$ 的值交换就能得到更优的方案，所以只需要枚举 $y$，求出第一种和第二种情况的最大值，然后比较即可。

具体实现在代码里。

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define N 114514
#define M 1919810
#define ll long long
#define INF 2147483647000000
ll t,n,a[M];
int main(){
	cin>>t; //注意t组数据 
	while(t--){
		cin>>n;
		ll ans=-INF,ans_=-INF;
		for(int i=1;i<=n;++i) cin>>a[i];
		sort(a+1,a+n+1);
		//因为取出时要最小化总值，所以直接取排序后的数组里的前或后一个值 
		for(int i=1;i<=n-2;++i) ans_=max(ans_,a[n]+a[i+1]-2*a[i]);  //第一种，若要最大化总值则肯定要取最大值 
		for(int i=3;i<=n;++i) ans=max(ans,2*a[i]-a[1]-a[i-1]);      //第二种，相反与第一种，取最小值 
		//注意枚举范围（第二种情况理论上应从3开始枚举，但亲测2也可以）
		cout<<max(ans,ans_)<<'\n';
	}
	return 0;
}
```
