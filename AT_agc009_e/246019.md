> - 黑板上有 $n$ 个 $0$ 和 $m$ 个 $1$，每次操作擦掉其中 $k$ 个数，然后写上它们的平均数，直到黑板上只剩下一个数。
> - 求最后这个数有多少种不同的可能，答案对 $10^9 + 7$ 取模。
> - $1 \leq n,m \leq 1000$，$2 \leq k \leq 2000$，保证最后只剩下一个数。

下文认为 $n,m$ 同阶。

把擦除的过程表示成 $k$ 叉树的结构（类似于 Kruskal 重构树），那么共有 $n + m$ 个叶子，其中 $n$ 个叶子权值为 $0$，$m$ 个叶子权值为 $1$。对于一个非叶节点，其权值为 $k$ 个儿子权值的平均值，则根节点的权值就是剩下的那个数。

考虑每个叶子节点对根节点权值的贡献：设第 $i$ 个权值为 $1$ 的叶子深度为 $x_i$，第 $i$ 个权值为 $0$ 的叶子深度为 $y_i$，那么根节点的权值为 $\sum_{i = 1}^m (\frac{1}{k}) ^ {y_i}$。并且显然当所有叶子的权值均为 $1$ 时根节点的权值也为 $1$，因此还需满足条件：

$$ \sum_{i= 1}^n (\frac{1}{k})^{x_i} + \sum_{i = 1}^m (\frac{1}{k})^{y_i} = 1$$

必要性也是显然的，对于任意一组合法的 $x_i,y_i$ 我们都可以根据 $k$ 进制小数的进位构造出一棵合法的 $k$ 叉树。于是问题转化为求有多少个 $z$ 满足 $z$ 可以写成 $\sum_{i = 1}^m (\frac{1}{k}) ^ {y_i}$ 的形式，且 $1-z$ 可以写成 $\sum_{i = 1}^n (\frac{1}{k}) ^ {x_i}$ 的形式。

将 $z$ 写成 $k$ 进制小数 $0.c_1c_2\cdots c_p$，在不考虑进位的情况下，$c_i$ 表示深度为 $i$ 的权值为 $1$ 个叶子的个数。因此显然有：

$$ \sum_{i = 1}^p c_i = m $$

而对于一次进位操作，其相当于将 $c_{i}$ 的值减去 $k$，然后将 $c_{i-1}$ 的值加 $1$。这相当于将 $\sum c$ 的值减去 $k-1$。由此可知：

$$ \sum_{i = 1}^p c_i \equiv m (\mathrm{mod} \ k-1)$$

将 $1-z$ 也写成 $k$ 进制小数 $0.d_1d_2 \cdots d_p$，容易得到其各位数之和：

$$ \sum_{i = 1} ^p d_i = p \times(k -1) - \sum_{i = 1} ^ p c_i + 1$$

并且同理我们有：

$$ \sum_{i = 1}^p d_i \equiv n (\mathrm{mod} \ k-1)$$

据此我们可以设计 dp：设 $f_{i,j,0/1}$ 表示当前在小数点后第 $i$ 位，位数和为 $j$，最后一位是/不是 $0$ 的方案数。转移时考虑当前位放什么数即可，容易发现这可以用前缀和优化，最终时间复杂度 $O(n^2)$。

```cpp
int N, M, K, Ans, f[2][MN][2], s[MN];

signed main(void) {
    N = read(), M = read(), K = read();
    int o = 0;
    f[o][0][0] = 1;
    for (int i = 1; i <= max(N, M) * 2; i++) {
        o ^= 1;
        s[0] = (f[o ^ 1][0][0] + f[o ^ 1][0][1]) % Mod;
        for (int j = 1; j <= N; j++) {
            s[j] = (s[j - 1] + f[o ^ 1][j][0] + f[o ^ 1][j][1]) % Mod;
        }
        for (int j = 0; j <= N; j++) {
            f[o][j][0] = (s[j] - s[j - 1] + Mod) % Mod;
            if (j) f[o][j][1] = (s[j - 1] - (j >= K ? s[j - K] : 0) + Mod) % Mod; 
        }
        for (int j = 0; j <= N; j++) {
            if (j % (K - 1) == N % (K - 1) && (i * (K - 1) - j + 1) % (K - 1) == M % (K - 1) && i * (K - 1) - j + 1 <= M) {
                Ans = (Ans + f[o][j][1]) % Mod;
            }
        }
    }
    printf("%lld\n", Ans);
	return 0;
}
```
