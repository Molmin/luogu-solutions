考虑取平均数的过程会形成一个树形结构，叶子结点为初始的 $0,1$，每个非叶子结点都是 $K$ 叉的，表示将其所有孩子合并为一个数。则深度为 $i$ 的 $1$ 对答案的贡献即为 $\dfrac 1{K^i}$，且我们注意到最后的结果只和每层叶子中 $1$ 的个数有关，而与 $1$ 具体的摆放顺序无关。

记 $d=\dfrac{N+M-1}{K-1}$，即该树的深度，不难注意到所有数都可化为 $\dfrac{A}{K^d}$ 的形式（其中 $A$ 为一个整数）。

直接枚举每一层的 $1$ 的个数来统计会导致算重，因为某一层的 $K$ 个 $1$ 等价于上一层的 $1$ 个 $1$，于是我们考虑枚举进行了 $x$ 次把 $K$ 个 $1$ 变成了一个 $1$ 的操作，那么我们会令新的 $d'\gets d - x$，$M'\gets M - x(K - 1)$，并且如果某一层有大于等于 $K$ 个 $1$，那么我们可以把它们调整顺序（因为顺序不改变结果）后“合并”为一个 $1$，使得其在枚举 $x+1$ 次把 $K$ 个 $1$ 变成了一个 $1$ 的操作时再统计。

于是若要统计不重复，每一层都必须只有不超过 $K - 1$ 个 $1$，不难发现此时最终的平均数 $\dfrac A{K^d}$ 中的 $A$ 满足：$\dfrac AK$（因为第 $0$ 层不可能有叶子结点，所以要除个 $K$）是一个 $d'$ 位的 $K$ 进制数，且每位数值之和恰为 $M'$（因为此时 $1$ 的总数为 $M'$），不难验证该条件是充要的。

不难用一个朴素的背包 dp 做到 $\mathcal O(N^2)$（假设 $N,M,K$ 同阶）的时间复杂度。

```cpp
const int N = 4000 + 5, MOD = 1e9 + 7;

int n, m, K, d, f[N][N];

int main() {
    rd(n, m, K); d = (n + m - 1) / (K - 1);
    f[0][0] = 1;
    for(int i = 1; i <= d; ++i)
        for(int j = 0; j < K; ++j)
            for(int k = j; k <= i * K && k <= m; ++k)
                f[i][k] = (f[i - 1][k - j] + f[i][k]) % MOD;
    int ans = 0;
    for(; m >= 1; m -= K - 1, --d)
        ans = (ans + f[d][m]) % MOD;
    printf("%d\n", ans);
	return 0;
}
```