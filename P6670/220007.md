题意：找一条链，使其平均权值与$k$的差值最小。

出题人给出的做法是二分+树分治，$nlog^3n$ 的复杂度，可能有点卡常

这里提供一种和正解完全不同的做法。

首先,平均权值与$k$的差值最小，这等价于先将每条边的边权减去$k$,再最小化平均权值的绝对值。

考虑我们找到的答案链为两条链合并而成的，对于第$i$条链，记其权值和为$y_i$ ,其经过的链的数目为 $x_i$ ,我们实际上是在最小化 $ | \frac{y_i+y_j}{x_i+x_j} | $ 

这个形式似乎不太好处理，如果我们是最小化 $ | \frac{y_i-y_j}{x_i-x_j} | $呢？这就将问题转化成了，在一个**二维平面内给定一个点，最小化两点斜率的绝对值**

对于两个子树$a,b$，它们分别对应了点集$A,B$，我们现在将A合并到B上，需要这样几个步骤：

一：因为又经过了一条边，我们需要 $A$ 中的点全部更新，即全局修改

二：将$A$中的所有点在$B$中询问更新答案

三：将$A$中的点暴力插入到$B$中

显然，这些操作都可以启发式地进行

现在我们需要一种能支持这些全局修改、单点插入、询问斜率最小值的数据结构

因为在这题中，询问的点对应的$x$不小于0,且被问的点集中任一点的x不大于0

故这些操作可以用KDT来实现

于是我们就有了一个**KDT的启发式合并的做法**

乍一看这个做法的复杂度是$O(n\sqrt n logn )$的

但实际上，我们对KDT的剪枝是全局进行的，也就是询问部分的常数会小的很夸张

而插入和修改部分的复杂度不会超过$log^2n$

所以这个做法会跑的非常快，并成为了此题（暂时）的最优解

考场代码比较简陋，就贴一下核心部分吧

```cpp
il void dp(int x,int FA){
	for(re i=head[x],v;i;i=e[i].nex)
		if((v=e[i].to)!=FA){
			dp(v,x);//处理子树
			tag[rt[v]].x[0]-=1,a[rt[v]].x[0]-=1,mx[rt[v]].x[0]-=1,mn[rt[v]].x[0]-=1;//全局修改子树
			tag[rt[v]].x[1]-=e[i].w,a[rt[v]].x[1]-=e[i].w,mx[rt[v]].x[1]-=e[i].w,mn[rt[v]].x[1]-=e[i].w;
			ask(rt[v],(P){0,0});//更新答案
			if(siz[rt[v]]>siz[rt[x]]) swap(rt[x],rt[v]);
			dfs(rt[v]);//将子树中的所有点dfs出来
			for(auto y:vec)
				ask(rt[x],(P){-a[y].x[0],-a[y].x[1]});//更新答案
			for(auto y:vec)
				ins(rt[x],1,a[y]);//暴力合并
			for(auto y:vec) del(y);//回收空间
			vec.clear();
		}
	if(x!=1) ins(rt[x],1,(P){0,0});
}
```


