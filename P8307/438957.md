## 题目简述

rin 和 len 两个人，轮流从初始为 $[1,n]$ 的区间中选整数，ren 先选。其中某个整数 $t$ 是炸弹，谁先选中谁输。如果没选中，区间会被选出的数分为两半，只保留包含 $t$ 的那一半。两人都要将自己的胜率最大化，求 rin 的胜率。

## 题目分析
题解里已经有详细的归纳法证明了，本蒟蒻就不写了 ~~我不会~~。
说说比赛时的思考历程吧，每步都很简单，保证你能读懂。

刚读完题，看一眼数据范围，哇 $10^{18}$，大概率是数学题。
先来手算数据，$p(x)$ 表示 $n$ 为 $x$ 时 rin 的胜率：

| $x$ | $1$ | $2$ | $3$ | $4$ | $5$ | $6$ |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| $p(x)$ | $0$ | $\frac{1}2$ | $\frac{2}3$ | $\frac{1}2$ | $\frac{2}5$ | $\frac{1}2$ |

通过观察，我们大胆猜测 $x$ 为偶数时，$p(x)$ 都是 $\frac{1}2$，并且 **subtask 里有个分值为 $10$ 分的 $n$ 为偶数的数据点**。赌一波，直接输出 $\frac{1}2$ 交上去，真的得了 $10$ 分！说明我们猜对了。

除了骗分，$\frac{1}2$ 还能告诉我们更重要的事，**那就是 $p(x)$ 一定是个有规律的函数**，只要找到了规律，正解就出来了。

手算的过程中我们发现每次**最大的胜率都是选择区间中第二个数**。也就是说无论是 rin 还是 len，上去都会直接选第二个数。

选第二个数胜率的计算为：

$p(x)=\frac{x-1}{x}\times(\frac{1}{x-1}+\frac{x-2}{x-1}\times(1-p(x-2)))$

$\frac{x-1}{x}$ 的意思是，去掉第二个数就是 $t$然后直接输掉的概率，也就是 $1-\frac{1}{x}$ 。

括号内的 $\frac{1}{x-1}$ 的意思是 $t$ 在第二个数左边，也就是第一个数，直接赢了。

$\frac{x-2}{x-1}\times(1-p(x-2))$ 的意思是 $t$ 在第二个数右边的概率，乘以这个区间中rin赢的概率，因为下次轮到len了，所以要用len赢的概率的补集来算，也就是 $1-p(x-2)$。

用这个公式我们就能快速递推 $p(x)$ 的值了，因为 $x$ 为偶数时 $p(x)$ 一直都是 $\frac{1}{2}$，所以我们只看 $x$ 为奇数时的值，试图找到规律：

| $x$ | $3$ | $5$ | $7$ | $9$ | $11$ | $13$ |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| $p(x)$ |$\frac{2}3$ | $\frac{2}5$ | $\frac{4}7$ | $\frac{4}9$ | $\frac{6}{11}$ | $\frac{6}{13}$ |


规律显而易见，$p(x)$ 分母为 $x$，分子每次加 $2$。
用公式表示出来就是从 $1$ 开始 $\frac{n-1}{2n}$, $\frac{1}2$, $\frac{n+1}{2n}$,  $\frac{1}2$ 这样一直循环。

题目中告诉了我们如何对有理数取模，其实就是求逆元，具体可以看[这里](https://www.luogu.com.cn/problem/solution/P3811)。

计算逆元的过程中用到了快速幂，恐怖的是**直接乘会爆long long，所以还得写个快速乘法**，用加法替代乘法，原理和快速幂是一样的。

## code:
```cpp
#include<bits/stdc++.h>
#define mod 998244353
#define ll unsigned long long
using namespace std;

ll n;

ll mult(ll a,ll b){ //快速乘法
    if(!b)return 0;
    if(b==1)return a;
    if(b&1)return (mult(a,b-1)+a)%mod;
    return 2*mult(a,b/2)%mod;
}

ll power(ll a,ll b){ //快速幂
    if(b==1)return a;
    if(!b)return 1;
    if(b&1)return mult(power(a,b-1),a)%mod;
    ll buf=power(a,b/2);
    return mult(buf,buf)%mod;
}

int main(){
    cin>>n;
    ll m=power(n,mod-2); //n的逆元
    if(n%2==0)cout<<499122177<<endl;  //这玩意儿就是0.5取模
    else if(n%4==1)cout<<mult((n-1),499122177)%mod*m%mod<<endl;
    else if(n%4==3)cout<<mult(n+1,499122177)%mod*m%mod<<endl;
    return 0;
}
```

