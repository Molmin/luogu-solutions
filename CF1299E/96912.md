有一个长为 $n$ 的排列（$2\mid n$），你可以进行不超过 $18n$ 次询问，每次询问可以指定一个下标集合 $s$（不可重），会回答你 $|s|$ 是否整除这些下标对应的数的和，求原排列。由于 $p_i\leftrightarrow n+1-p_i$ 的回答总是相等，所以输出这两个排列中 $p_1\leqslant \dfrac{n}{2}$ 的即可。$n\leqslant 800$。

来讲一个倍增做法。

首先发现 $\dfrac{n(n+1)}{2}\equiv \dfrac{n}{2}(n-1)+n\equiv 1\pmod {n-1}$，于是如果我们每次去掉一个数，询问其它数，返回 1 当且仅当这个数是 $1$ 或者 $n$，由于有两种可能的排列，随便钦定到底哪一个是 $1$ 最后不对再改回去即可。
和上面同理，如果我们知道了 $1\sim k$ 和 $n-k+1\sim n$ 的位置，每次删掉还不知道的数中的一个，如果返回 $1$ 说明这个数是 $k+1$ 或者 $n-k$。这引出了一个 $O(n^2)$ 次询问的做法。

接下来的做法基于一个剪枝：假设我们当前在寻找 $k$ 的值，设 $t=\lfloor\log_2 k\rfloor$，且我们知道每个数 $\bmod 2^{t}$ 的值，那么我们只需要询问那些和 $k$ 在 $2^t$ 意义下同余的数即可。

首先我们通过 $n$ 次询问找到 $1,n$ 后，把每个数和 $1$ 询问一遍就知道了每个数 $\bmod 2$ 的值，然后再通过 $n$ 次询问找到 $2,n-1$。这一部分询问次数不超过 $4n$。

我们考虑倍增，已知每个数 $\bmod 2^k$ 的值和 $1\sim 2^k$ 的位置，倍增到每个数 $\bmod 2^{k+1}$ 的值和 $1\sim 2^{k+1}$ 的位置。

求位置根据我们刚才所说，询问所有 $2^k$ 个数会把每个数询问两次，需要花费约 $2(n-2^k)$ 次。考虑怎么求值：设当前数 $a_i\equiv r\pmod {2^k}$，把其和 $\{1,\dots,2^{k+1}\}-\{r\}$ 询问一遍。如果询问结果是 1，则其模 $2^{k+1}$ 等于 $r+2^k$，反之为 $r$（证明依旧是求和）。这一部分是 $n-2^k$ 的。

所以这样的话复杂度大概是 $3n\log n-kn$（$k$ 在 $4\sim 8$ 左右，不想分析了）的，看上去过不去但是它实际上过了（想到的一种优化方法是询问数的位置的时候 random_shuffle 一下顺序，这样期望下只造成一半贡献，大概能变成 $2n\log n$ 左右，实测最多需要约 12800 次询问，但平均情况只需要 12000 次左右。希望有懂哥来给一个更紧的界或者优化方法（

