题目大意是，有N阶楼梯，一次只能走一步或者两步，共有几种走法。

这是一道很典型的线性DP，我们可以这样想，现在有N阶楼梯来走，我可以一次走一步或者两步，那么这个楼梯的走法就是    
第一步走一阶的方法+第二步走一阶的方法。
知道走完整个楼梯。
那么状态转移方程就是

```cpp
		x[n]=x[n-1]+x[n-2];              //加法原理
```


分类加法原理：
做一件事，完成它可以有n类办法，在第一类办法中有m1种不同的方法，在第二类办法中有m2种不同的方法，……，在第n类办法中有mn种不同的方法，那么完成这件事共有N=m1+m2+m3+…+mn种不同方法。

走楼梯的最后边界条件是

（1）剩余阶梯数为0        return 1

（2）剩余阶梯数为1        return 2

（3）剩余阶梯数 < 0         return 0  //本题可不考虑（3），想一想，为什么

以上可以得到40分（Dp的40分）

然后你会发现走法随着这楼梯数爆炸性增长  当N=39时  走法为9位数(102334155)

然后就需要开高精，我最开始想开数组 [5005][2005]

然后发现空间肯定会爆

于是我就想到既然这道题当前状态只与前两个状态有关，那我就只用保留前两个状态。


于是我开了[4][2005]

在函数中我只需保留三个值即可 （1）x:当前已走的阶梯数（2）y:当前的数字位数（3）c:当前需要在那个数组中储存数字
```cpp

int z[4][5005];
void zou ( int  x , int y , int c )
{
    z[c][1] = 0;
    for ( int t = 1 ; t <= y ; t ++ )
    {
        if (c == 3 ) 
        {
         z[c][t] += z[c-1][t] + z[c-2][t];
        }
        else if (c == 2)
        {
            z[c][t] += z[c+1][t] + z[c-1][t];   
        }
        else
        {
            z[c][t] += z[c+1][t] + z[c+2][t];
        }
        z[c][t+1] = 0;
        if ( z[c][t] > 9)
        {
            z[c][t] %= 10 ;
            if (t == y)
            y ++ ;
            z[c][t+1] ++ ;
        }
    }
    if (x == n)
    {
        ans = y ;
        ans1 = c ;
        return ;
    }
    if ( c == 3 )
    c = 1 ;
    else if ( c == 1 )
    c = 2 ;
    else if ( c == 2 )
    c = 3 ;
    zou ( x+1 , y , c ) ;
}
```
以下附上总代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,ans,ans1;
int z[4][5005];
void zou ( int  x , int y , int c )
{
    z[c][1] = 0;
    for ( int t = 1 ; t <= y ; t ++ )
    {
        if (c == 3 ) 
        {
         z[c][t] += z[c-1][t] + z[c-2][t];
        }
        else if (c == 2)
        {
            z[c][t] += z[c+1][t] + z[c-1][t];   
        }
        else
        {
            z[c][t] += z[c+1][t] + z[c+2][t];
        }
        z[c][t+1] = 0;
        if ( z[c][t] > 9)
        {
            z[c][t] %= 10 ;
            if (t == y)
            y ++ ;
            z[c][t+1] ++ ;
        }
    }
    if (x == n)
    {
        ans = y ;
        ans1 = c ;
        return ;
    }
    if ( c == 3 )
    c = 1 ;
    else if ( c == 1 )
    c = 2 ;
    else if ( c == 2 )
    c = 3 ;
    zou ( x+1 , y , c ) ;
}
int main()
{
    cin>>n;
    z[1][1]=1;
    z[2][1]=2;
    if(n>=3)
    zou(3,1,3);
    if(n==0)
    cout<<0;
    if(n==1)
    cout<<1;
    if(n==2)
    cout<<2;
    if(n!=1&&n!=2&&n!=0)
    for(int t=ans;t>=1;t--)
    {
        cout<<z[ans1][t];
    }
}
```