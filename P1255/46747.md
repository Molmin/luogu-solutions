首先，这道题如果把 $n\le 5000$ 变成 $n\le 64$ 就成了大水题了，用个斐波那契数列就行，也不会炸 $\text{long long}$。

但是现在 $n$ 到了 $5000$ 的级别，而斐波那契数列基本上是以指数级增长的。即使是用 $\text{long long}$ 也只能对几乎达到 $2^{5000}$ 的数据而感到无能为力了。

所以我们要写个高精加来解决这个（**看似**）棘手的问题。

我将程序中主要的内容封装到了一个`add`函数里，那么我先把`add`函数放上来，再慢慢分析其内容。

```cpp
void add() {
	a[1] = 1;
	b[1] = 2;
	m = 1;
	for(int i = 3; i <= n; ++i) {
		for(int j = 1; j <= m; ++j) ans[j] = a[j] + b[j];
		for(int j = 1; j <= m; ++j)
			if(ans[j] > 9) {
				ans[j] -= 10;
				++ans[j + 1];
				if(j == m) ++m;
			}
		for(int j = 1; j <= m; ++j) a[j] = b[j], b[j] = ans[j];
	}
}
```

首先，我定义了三个数组，分别是`a[]`，`b[]`和`ans[]`。

大家首先来回忆一下，如果像题解开头所说的那样，$n\le 64$，你会怎么写这道题呢？


------------
很显然地，我们利用加法定理，第 $i$ 层楼梯一定可以从第 $i-1$ 层和第 $i-2$ 层走到（$i>2$），而走到第 $1$ 层和第 $2$ 层楼梯的方案数也显然分别为 $1$ 和 $2$。

所以，我们可以得到一个递推（动态规划？）的做法。设 $\rm{dp}_i$ 为走到第 $i$ 层楼梯的方案数，则在 $i>2$ 的情况下，有公式
$$\rm{dp}_i=\rm{dp}_{i-1}+\rm{dp}_{i-2}$$
边界条件为 $\rm{dp}_1=1,\rm{dp}_2=2$。

但因为 $\rm{dp}_i$ 只和 $\rm{dp}_{i-1}$ 和 $\rm{dp}_{i-2}$ 有关系，所以我们可以利用**滚动数组**来优化空间。

初始时，设 $a=1,b=2$（此时 $a$ 就相当于 $\rm{dp}_1$，$b$ 就相当于 $\rm{dp}_2$），我们再定义一个变量 $ans$，则我们跑 $n-2$ 次循环，在每一次循环中：
$$ans=a+b$$
接着，$a\leftarrow b,b\leftarrow ans$，起到滚动数组的效果（~~虽然根本就没有数组~~）。


------------
好，当你看懂了上面有关滚动数组的内容后，`add`函数中`a[]`，`b[]`和`ans[]`的道理也许你已经懂了。

`a[i]`，`b[i]`和`ans[i]`表示的就是在**倒序**的情况下，原本的 $a$，$b$ 和 $ans$ 的**第 $i$ 位**！

请注意，在**倒序**的情况下，而不是**顺序**！

比如说斐波那契数列中的第 $6$ 个数字：$13$。

放进`a[]`后，`a[1]=3,a[2]=1`。

这样，我们就利用滚动数组，将原来的二维数组变成了一维数组。

接下来的代码解释？

自己摆个加法的竖式，一位一位对齐，然后进位...个人认为理解上并不困难（~~潜台词：咕咕咕~~）。

哦，还有一个**很小的**空间优化的地方。

大家还记不记得题解刚开头讲的一段话？

>但是现在 $n$ 到了 $5000$ 的级别，而斐波那契数列基本上是以指数级增长的。即使是用 $\text{long long}$ 也只能对几乎达到 $2^{5000}$ 的数据而感到无能为力了。

几乎达到 $2^{5000}$，而不是达到 $5000$ 位！

所以，，

$a$，$b$ 和 $ans$ 三个数组根本不用像很多题解里那样开到 $5000$ 位！

$2^8=256$，三位数，$8\div 3>2$；

$2^{10}=1024$，四位数，$10\div 4>2$；

$2^{31}=2147483648$，十位数，$31\div 10>3$。

所以，即使从最保险的角度来看，那三个数组最大也只用开到 $\frac{5000}{2}$ 的级别，也就是 $2500$ 就行了。

最后要注意一点，当 $n<3$ 时，直接输出 $n$，退出程序。~~不要问我为什么，自己看下面的清晰无码的程序。~~

$\rm code$

```cpp
# include <bits/stdc++.h>
using namespace std;
# define EXIT cout << n, exit(0)
const int maxN = 2505;
int n, m;
int a[maxN], b[maxN], ans[maxN];
void add();
int main() {
	cin >> n;
	if(n < 3) EXIT;
	add();
	for(int i = m; i; --i) cout << ans[i];
	return 0;
}
void add() {
	a[1] = 1;
	b[1] = 2;
	m = 1;
	for(int i = 3; i <= n; ++i) {
		for(int j = 1; j <= m; ++j) ans[j] = a[j] + b[j];
		for(int j = 1; j <= m; ++j)
			if(ans[j] > 9) {
				ans[j] -= 10;
				++ans[j + 1];
				if(j == m) ++m;
			}
		for(int j = 1; j <= m; ++j) a[j] = b[j], b[j] = ans[j];
	}
}
```

带上贴的代码，一共打了 $3000+$ 个数的字。完整代码长 $589$ 字节。

码字不易，求管理员通过qaq