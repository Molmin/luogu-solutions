走楼梯，要么一次走一格，要么一次走两格，那我每次的走法就等于=上一格的方案数+上上格的方案数咯，这就推出了方程：

$$f[i]=f[i-1]+f[i-2]$$
-

因为此方程只用到了i，i-1，i-2，所以可以滚动压缩，得到

$$f[i\mod3]=f[(i+1)\mod3]+f[(i+2)\mod3]$$
-

然后用了一下各种类型
>int 40分

>long long 50分

>unsigned long long 50分。。。

>__int128 0分，编译错误了。。。

然后，就打了高精度。。。

想想，普通的高精度，我们伟大的管理怎么可能会给通过呢？于是，我打了个压位高精加。。。

# 概念
压位高精加，顾名思义，就是将高精度数组的每个位存多点。

# 优点
因为高精度其实是模拟竖式计算的方法，一个变量存一位，也就是0..9，这样有点浪费时间，而当n，m太大时则会超时，这个时候，就引申除了压位高精加。

# 实现
对高精度略作修改，将原来的%10、/10，改成了%100000000，/100000000，但是输出的时候要记得处理前面的0，例如
9999999999999999+2=10000000000000001

在数组里面它是这样的

101

所以，要判断当它不是第一个数字的时候，要添加0，至于添加几个，则看它有多大。判断可以直接暴力，也可以数学方法（log）去算，从而添加0

例如

1=7个0+1 10=6个0+1,100=5个0+1……以此类推
# 代码
```cpp
#include<bits/stdc++.h>
#define N 250//2000位够了，250*8
using namespace std;
int  f[3][N+10],g;
int n;
int main()
{
	f[0][N]=1;f[1][N]=1;scanf("%d",&n);if(!n){puts("0");return 0;}//0要特判
	for(int i=2;i<=n;i++)
	 for(int j=N;j>0;j--)
	  {
	 	f[i%3][j]=(f[(i+1)%3][j]+f[(i+2)%3][j]+g)%100000000;
	    g=(f[(i+1)%3][j]+f[(i+2)%3][j]+g)/100000000;//8个0，别漏了
	  }
	int j=1;
	while(!f[n%3][j]&&j<N) j++;//处理前导0
	for(int i=j;i<=N;i++)
	{
		if(i!=j){//一定别漏了前面这句
		if(f[n%3][i]<1e7) putchar(48);
		if(f[n%3][i]<1e6) putchar(48);
		if(f[n%3][i]<1e5) putchar(48);
		if(f[n%3][i]<1e4) putchar(48);
		if(f[n%3][i]<1e3) putchar(48);
		if(f[n%3][i]<1e2) putchar(48);
		if(f[n%3][i]<1e1) putchar(48);}//补足前导0
		printf("%d",f[n%3][i]);//输出
	}
}
```