我的blog：http://blog.csdn.net/jzq233jzq/article/details/77231143

我的做法好像比较傻。。。

看到这种题首先想到前缀。首先前缀xor是不是很资辞？

我的做法呢就是先把所有数按二进制位拆开，然后每一位都做两次前缀。

首先对数位做一次前缀xor，记到$s$数组里，再对s数组做一次前缀和，记到$ss$里。

然后我们可以对于每一位枚举起始位置i，然后从i开始向后到n统计答案。

首先考虑到$s$数组非0即1，所以这里处理将会非常方便。

我们可以看到$s$数组和$ss$数组的关系就像这样（这里的"^"都是xor的意思）：

![](http://img.blog.csdn.net/20170816103548222?)

可以发现$ss[i]$就对应了以s[i]为底的三角形是不是？

所以首先我们差分求出$ \sum_{j=i}^ns_j$之后我们得到了一个等腰梯形（以3~5为例）：

![](http://img.blog.csdn.net/20170816104030050?)

我们发现最前面两个是一样的，所以我们把这个作为公共部分。而且我们要求答案的也是这个梯形减掉左边的公共部分。

我们发现如果公共部分的xor值为1的话，右边的答案就需要整体翻转一下，如果为0，就不变。

这样我们就$O(1)$得到了从i开始的所有答案。

最后乘上当前在第几位的底数就好了。时间复杂度$O(n log n)$

代码在我blog里>\_<
