膜拜 hqztrue，太神仙了。本文的思路来自于这位老鸽。

考虑这个问题：

**给出若干个整数。$w$ 为字长，$\forall i\in [0,w)$，求出这些整数的二进制表示在第 $i$ 位有多少个 $1$。**

### 法一：位分块

因为 $w=\Theta(\log n)$，所以将整数每 $k=\Theta(\log n)$ 分一块，分成常数块。

所以我们只用处理常数次值域为 $m=2^k$ 的问题。即每个数 $\in [0,m)$。

考虑 01trie 结构。具体的，我们对于每个整数 $x$，在 $t_{x+m}$ 上计数一次，然后进行递推 $t_w =t_{2w}+t_{2w+1}$。

最终对每层计数一次。$ans_i =\sum _{x \bmod 2=1 \land x\in [2^{k-i},2^{k-i+1})} t_x$。

这样我们做到了 $O(m)$ 处理这个问题。时间复杂度即线性。

[代码实现](https://www.luogu.com.cn/paste/5zjv7sti)

### 法二：分治

设计 $01$ 计数数组 $a$，$a_{i,j}(i\in [1,\log n], j\in [1,w])$ 表示**第 $j$ 位的 $1$ 的数量的二进制表示的第 $i$ 位**。

考虑分治。处理两个规模为 $\dfrac n 2$ 的子问题后合并左右的计数数组 $a,b$，设其得到 $c$。

考虑这里合并的本质：并行计算 $w$ 个二进制加法。

我们对计数数组的第二维压位，因为 $j\in [1,w]$ 所以每个第二维均可以压进一个 word 里面。

同理，每一位是否进位也可以压进一个 word 里，还有一个原因就是这里至多进位一次，设其为 $t$。

计算 $c_i$：显然为 $t \oplus a_i \oplus b_i$。

计算 $t$：即判断两次加法的过程中是否有任何一个进位了。即 $(a_i \land b_i)|((a_i \oplus b_i)\land t)$。

每次合并的时间复杂度为 $O(\log n)$。时间复杂度式子即 $T(n)=2T(\dfrac n 2)+O(\log n)$。

时间复杂度显然为线性了。证明见下：

得到式子 $T(n)=\sum _{i=0}^{\log n} (\log n -i+1) 2^i$。我们尝试证明 $T(n)=O(n)$。为了方便，我们断言，证明 $T(2^n)=O(2^n)$ 即可。

设 $f(n)=T(2^n)=\sum_{i=0}^n (n-i+1)2^i$。$f(n+1)-f(n)=2^{n+1}+\sum_{i=0}^n 2^i=2^{n+2}-1$。

所以显然，$f(n)=O(2^n)$。

所以 $T(n)=O(n)$。

进行分治之后，暴力 $O(\log n w)$ 地得出每一位的答案即可。

时间复杂度线性。

[代码实现](https://www.luogu.com.cn/paste/zf0ov9fj)