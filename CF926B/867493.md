[题目传送门](https://www.luogu.com.cn/problem/CF926B)


------------
**题意**：

在一条数轴上有 $n$ 个点，已知每个点所代表的数，现在需要添加若干个点，要求添加的点的个数最小，使 **相邻的两个点的距离全部相同**。


------------
**思路**：

看到 **相邻的两个点的距离全部相同** 这句话时，就不难想到一个数学知识，就是 **等差数列**，所以题目就是让我们将一条数列分割成相等的若干个区间，使给出的点都是该数列的 $x$ 等分点。这样，我们只需要 **将原数列从小到大排序，再用一个数组求出并存储两两相邻点之差，最后求所有差值的最大公约数** 就能完成该题了。

那为何求出每个差值的最大公约数就可以了呢，我们不妨设每个差值的最大公约数为 $m$，这样，**每两个相邻的点的距离就一定是** $m$ **的** $k$ **倍**，且各个 k 的最大公约数为 $1$，所以，只要插入 **差值除以 $m$ 再减去 $1$** 个点即可。

------------
小芝士：
```cpp
C=__gcd(A,B); //__gcd用于求出数A与数B的最大公约数，即数C
```


------------
**完整代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;

const int qwq=2e6+5;
int n,k,a[qwq],ans[qwq];
//ans数组存储数列中相邻两个数的距离 

int main(){
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>a[i];
	}
	sort(a+1,a+n+1);
	k=a[n]-a[1];
	for(int i=2;i<=n;i++)
	{
		ans[i]=a[i]-a[i-1];
	}
	for(int i=2;i<=n;i++)
	{
		ans[i]=__gcd(ans[i],ans[i-1]);
	}
	int QAQ=1+k/ans[n]-n;
   	cout<<QAQ<<endl;
	return 0;
}
```


------------

本人只是一名小蒟蒻，若有错误请指正，谢谢大家。