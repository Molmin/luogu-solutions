思路非常好想：只要找出每对相邻的点距离差的最大公约数k，然后在每对点之间插入 差值/k-1个点。即可满足要求。

拿样例举例：

```cpp
3

-5 10 5
```
先排序：
```cpp
-5 5 10
```
$\text{5-(-5)=10，10-5=5，}$10和5的最大公约数是5，所以在-5和5间插入$\text{10/5-1}$，也就是一个点；在5和10之间插入$\text{5/5-1}$，也就是0个点，所以一共插入1个点。

正确性也很明显：既然k是每个差值的最大公约数，那么每两个点之间的距离一定是k的倍数，因而插入 差值/k-1个点，一定可以把每个区间分成相等的几部分。n<=100000，所以这样不会超时。

附代码！


```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
int gcd(int x,int y) {return x%y?gcd(y,x%y):y;}//求最大公约数
int n,s,k,i,a[100001];//n:点数，s:要加入的点数，k:最大公约数
int main()
{
	scanf("%d",&n);
	for(i=1;i<=n;i++) scanf("%d",&a[i]);
	sort(a+1,a+n+1);//排序
	for(i=2;i<=n;i++) k=gcd(k,a[i]-a[i-1]);//找最大公约数
	for(i=2;i<=n;i++) if(a[i]-a[i-1]>=k) s+=(a[i]-a[i-1])/k-1;//s+=每一段要加入的点的个数
	printf("%d",s);
	return 0;
}
```
