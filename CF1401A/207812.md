### 简单题意：

数轴正半轴上点 $A$ 的表示的数为 $n$ 。在数轴正半轴上找到一个整数点 $B$ ，使得从 $O$ 到 $B$ 的距离与从 $A$ 到 $B$ 的距离之间的绝对值之差等于 $k$。

另外，可以将 $A$ 的坐标增加或减少 $1$，算作 $1$ 步。求使该点 $B$ 存在的最少步数。

### 思路：

因为 $0 \le n, k \le 10^6$ 而且还有多组数据 （$1 \le t \le 6000$) ,所以只能用O(1)的方法做（~~这不是废话吗~~

因为要求 $|OB-AB|$ ，而 $n$ 与 $k$ 的位置不确定，所以**一定**要对它们分类讨论：

+ $n \le k:$

  **此时 $|OB-AB|$ 最大也只能为 $n$ ，** 因为 $B$ 只   有 取 $0$ 或 $n$ 才能使 $|OB-AB|$ 最大（很显然）。所以此时 $A$ 一定需要移动，直到 $|OB-AB|=k$ 为止，此时 $A$ 最小为 $k$（好好想想为什么）。

+ $n \gt k:$

  根据题目描述中的图可以看出 $n$ 为奇数、偶数时的情况是不一样的，所以对 $n$ 的奇偶性分类讨论：
  
  - $n$ 为奇数：
    
    此时如果 $B$ 选偶数，则 $OB$ 为偶数、$AB$ 为奇数， $|OB-AB|$必然为奇数。此时如果 $k$ 为偶数则 $A$ 需要移动 $1$ 步，为奇数则不用。反之亦然。
  
  - $n$ 为偶数：
  
  	此时如果 $B$ 选偶数，则 $OB$ 为偶数、$AB$ 为偶数数， $|OB-AB|$必然为偶数数。此时如果 $k$ 为奇数则 $A$ 需要移动 $1$ 步，为偶数则不用。反之亦然。
    
所以代码就很好写了：

### 代码

```cpp
#include <cstdio>
int main(){
    int t,n,k;
    scanf("%d",&t);
    while(t--){
        scanf("%d%d",&n,&k);
        if(n<=k) printf("%d\n",k-n);//n<=k的情况
        else{//n>k的情况
            if(n&1) puts(!(k&1)?"1":"0");//n为奇数
            else puts(k&1?"1":"0");//n为偶数
        }
    }
    return 0;
}
```
