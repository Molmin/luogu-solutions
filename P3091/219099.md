Update 8/18:

刚发完题解没两天就看到有两个xxs抄了代码，于是把代码改成函数的形式呈现

------------


对着题解理解了好一会才搞明白，这边来解释一下这题一些不容易理解的东西：

**P1:为啥要做切线**

切线定义为一条直线仅在一个点接触某个圆。

易证从圆外一点出发只会存在两条到圆的切线。

现在需要感性理解一下：当两点能互相看见时，他们的切线范围在圆上必然有重合部分。

![](https://cdn.luogu.com.cn/upload/image_hosting/skoupbh7.png?x-oss-process=image)

上图表示了三点对直径为 1 的圆所做的切线。这三点分别为 (0,2), (-1,-1),(3,1)

可以发现，图中只有 2,3 两点能够互相看见。

观察下他们的切线和圆的交点，发现如果两个点能互相看见，那么他们在圆上代表的区间一定存在包含关系。

假设把圆摊开来看作一条直线，那么这题就会变为以一个点的切线的两个端点做线段，求最终多少个区间存在包含关系。

**P2：怎么将圆转化为直线**

我们可以用角度来表示左右端点，易证在圆上角度不同位置也不同，因此我们直接把角度算出即可。

```cpp
struct Segment{
  double l,r;
  bool operator < (const Segment &oth) const{
    return l< oth.l;
  }
}seg[MAXN];

struct Node{
  double l,r;
  bool operator < (const Node &oth) const{
    return r>oth.r;
  }
};
inline void get(double x, double y){
  double l = atan2(y,x)*180.0/pi, flu = acos(k/sqrt(x*x+y*y))*180/pi;//l为当前点跟圆心产生的角度,flu为左右端点跟l产生的角度
  if (l-flu<0) l +=360.0;//先保证他非负,要不然某些角度因为tan和cos的特性会出错
  seg[++cnt] = (Segment) {l-flu,l+flu};//加两条线段,也就是两个环
  seg[++cnt] = (Segment) {l-flu+360.0,l+flu+360.0};
}
```
**P3：怎么计算答案**

在将角度变换为点之后，我们可以按左端点进行排序这些节点，然后保证其他点在左端点比他大且不超过他右端点的大小。如果存在这样的点，那么这个区间一定有重合。

由于是一个环，此做法会导致我们漏算了一部分的左区间。为了避免这种情况，我们对这个圆判断两次即可。

我们维护一个堆，记录右端点最小的点。目前点的左端点比堆上的点的右端点还大时，这个点肯定不会产生贡献。

原因很简单：由于后面的角度单调递增，假设目前线段为 [4,6]，之前线段为 [1,3]，那么在计算 4 之前我们一定已经完成计算 [1,3]。 而 [1,3] 既然跟 [4,6] 没有重合，那么当左端点继续增加时，右端点也会增加，因此他们不可能存在交点。

```cpp
inline void solve(){
  priority_queue<Node> q;
  for (int i=1;i<=2*n;i++){
    while(q.size() && seg[i].l>=q.top().r) q.pop();//不断的删边
    ans += q.size();
    if (i<=n) q.push((Node){seg[i].l,seg[i].r});//当i<=n时,我们一定在第一个环内,因此每条线段只会被加入一次
  }
}
```
说起来挺复杂，但是实现并不难(**完整代码已删，会的自然会**)