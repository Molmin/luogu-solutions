## 大致题意
JOI国有n个岛屿，国家正在修建各岛之间的航线，每个航线都要收一定的费用。JOI国有很多旅客想坐船在各岛之间旅行，他们会把出发地和目的地发给你，要你求出费用最低的一个旅行路线并告诉旅客。但是根据现有的修建工程进度有时这两个岛屿之间不能通航，这时需要告知旅客不能通航。

请编一个程序，求出每个订单的最小费用。
## 输入格式
输入第一行有两个整数$n$和$k(1\leq n\leq 100,1\leq k\leq5000)$，表示$n$个岛屿和$k+1$条航线通航的信息或旅客的订单。

接下来$k$行，每行三个或四个整数。

- 如果这行的第一个整数是0，那么后面有两个整数$a$和$b(1\leq a\leq n,1\leq b\leq n,a\neq b)$表示旅客的订单，即出发地和目的地。
- 如果这行的第一个整数是1，那么后面有三个整数$c,d,e (1\leq c\leq n,1\leq d\leq n,c\neq d,1\leq e\leq 1000000)$表示航线通航的信息，即$c$和$d$之间建立了航线，在这以后这条航线可以永久通航，费用为$e$。

最开始没有任何航线。在输入中，表示航线通航的信息的行数在$1000$行以下。另外，要注意在相同的两个岛之间，可能有多条航线。
## 输出格式
对于每个旅客的订单，输出一行一个整数，若能通航则输出从出发地到目的地最低的费用，若不能通航则输出$-1$。
## 输入样例1
```
3 8
1 3 1 10
0 2 3
1 2 3 20
1 1 2 5
0 3 2
1 1 3 7
1 2 1 9
0 2 3
```
## 输出样例1
```
-1
15
12
```
## 输入样例2
```
5 16
1 1 2 343750
1 1 3 3343
1 1 4 347392
1 1 5 5497
1 2 3 123394
1 2 4 545492
1 2 5 458
1 3 4 343983
1 3 5 843468
1 4 5 15934
0 2 1
0 4 1
0 3 2
0 4 2
0 4 3
0 5 3
```
## 输出样例2
```
5955
21431
9298
16392
24774
8840
```
## 题解
本题是一道最短路的题目，可以用$Dijkstra$、$SPFA$等算法实现，这里主要讲的是$SPFA$的实现方法。

思路是将每个岛看成一个点，每条航线看成一条双向边，每新建一条航线就加一条边，而订单就是求两点之间的最短路，若不能到达则输出$-1$。

期望时间复杂度为$O(km)$，$k$为查询的次数，$m$为边数。

具体实现过程见代码
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
struct NODE
{
	int next,to,sum;//next表示下一个连这个起点的边，to表示这条边的终点，sum表示边权
}b[2010];//链式前向星建无向图的边要开两倍边数
int n,k,a[110],t=0;
void add(int x,int y,int z)
{//以下为链式前向星建边，x为起点，y为终点，z为边权
	t++;//边加一
	b[t].next=a[x];//储存下一条出边
	b[t].to=y;//储存终点
	b[t].sum=z;//储存边权
	a[x]=t;//记录这个点的出边情况，放在a里
}
void spfa(int x,int y)
{//以下为SPFA算法，x为起点，y为终点
	int f[110],c[110]={0},i;//f表示以x为起点到达任意其他点的最短路，c表示这个点在不在队列里
	queue<int> q;//建立队列q
	for(i=0;i<=n;i++) f[i]=-1;//将所有点都设为未访问
	f[x]=0;//将起点的最短路设为0
	q.push(x);
	c[x]=1;//标记入队
	while(!q.empty())
	{
		int u=q.front();//取出队头
		q.pop();//弹出队头
		c[u]=0;//标记u不在队列里
		for(i=a[u];i;i=b[i].next)//遍历出边
		{
			int v=b[i].to;//v为这条边的终点
			if(f[v]==-1||f[u]+b[i].sum<f[v])//若v未访问或通过这条路到达v的最短路比之前的最短路更短
			{
				f[v]=f[u]+b[i].sum;//设置v的最短路
				if(!c[v])//若v不在队列里
				{
					c[v]=1;//标记
					q.push(v);//入队
				}
			}
		}
	}
	cout<<f[y]<<endl;//输出结果，若f[y]等于-1则不能到达
}
int main()
{
	cin>>n>>k;//输入点数n和信息条数k
	int i;
	for(i=1;i<=k;i++)
	{
		int x,y,z,g;
		cin>>g;//输入标记
		if(g==0)//如果标记为0则输出x到y的最短路
		{
			cin>>x>>y;
			spfa(x,y);
		}
		if(g==1)//如果标记为1则建x到y的双向边
		{
			cin>>x>>y>>z;
			add(x,y,z);
			add(y,x,z);
			//因为要建双向边所以x到y要建一次，y到x也要建一次
		}
	}
	return 0;
}

```
