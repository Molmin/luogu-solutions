我们考虑每次操作是将一段路径染色，然后贪心地再找到一个到染过色的点最近距离最远的点再染色它和其它点的路径，然后我们不难发现一个性质，就是以直径上任意一个点做根后，如果 $u$ 没被染色，则 $u$ 的子树都没被染色，然后我们就用线段树维护每个点到染色过色的点的最近距离。

然后线段树上二分找到最近距离最远的点，一直跳 $father$ 直到 $father$ 被染过色，跳的过程中线段树权值清零并更新它儿子的子树的答案即可。

代码：[https://codeforc.es/problemset/submission/958/199635294](https://codeforc.es/problemset/submission/958/199635294).