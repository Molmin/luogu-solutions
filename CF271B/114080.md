蒟蒻又来水CF的题了。

这道题可以用素数筛+暴力枚举解决。

前面一个素数筛，判断一个数是否为素数。

中间一个循环，判断对于一个整数$i$，大于且最接近于$i$的素数，将每个这样的素数记录到$b$数组中。

后面依次枚举每行和每列，对于每个数，无需再去重复计算大于且最接近于这个数的素数，直接调用$b[i]$即可。

下面，放代码吧，小编在做此题的时候也犯了一些低级错误，我会在代码里指出来：

```cpp
#include<bits/stdc++.h>
using namespace std;
bool a[101001];
int b[101001],c[501][501],tmp,s,mn=INT_MAX;
int main()
{
	for (int i=2;i<=sqrt(101000);++i)
	   for (int j=i;j<=101000/i;++j)
	      a[i*j]=true;//素数筛部分，这里小编犯了第一处错误，应该开到101000，否则统计99991以上素数的时候就会变成0
	b[0]=b[1]=2;//小编犯了第二处错误，0和1以上最小的素数是2
	for (int i=101000;i>=2;--i)//小编犯了第三处错误，应该倒着循环，否则找的是小于i且最大的素数
	{
		if(!a[i])
		  tmp=i;//如果这个数是素数，那么先把tmp替换成这个数，以便赋值给下面的数
		b[i]=tmp;
	}
	int n,m;
	cin>>n>>m;
	for (int i=1;i<=n;++i)
	   for (int j=1;j<=m;++j)
	      cin>>c[i][j];
	for (int i=1;i<=n;++i)
	{
		s=0;//累加器赋值为0
	   for (int j=1;j<=m;++j)
	      s+=b[c[i][j]]-c[i][j];//无需往上计算，这样最坏情况的时间复杂度就从O(n*n*100000)到了O(n*n),大大减少了时间消耗
	    if(s<mn)
	      mn=s;//如果这一行（一列)全部变成素数的步数小于现有的最小值，那么就替换
    }
    for (int i=1;i<=m;++i)
	{
		s=0;
	   for (int j=1;j<=n;++j)
	      s+=b[c[j][i]]-c[j][i];//同理，注意这里要先j再i，前面i循环做到m，j循环做到n
	    if(s<mn)
	      mn=s;
    }
    cout<<mn;//输出答案
	return 0;
}
```
附带：不要抄代码