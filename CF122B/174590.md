### 题目大意

```
Petya喜欢幸运数字。 每个人都知道幸运数字是正整数，其小数表示仅包含幸运数字4和7。例如，数字47、744、4是幸运数字，而5、17、467不是。

一天Petya收到了一个仅包含数字的字符串s。 他需要找到一个字符串——

代表没有前导零的幸运数字，
不为空，
在s中作为子字符串包含s的最大次数。

在满足以上三个条件的所有字符串中，Petya仅需按字典顺序的最小条件即可。 查找Petya的字符串。
```

（以上为机翻但意思差不多）

然后 我因为**没有注意到**`在s中作为子字符串包含s的最大次数。
`写出了以下**错误代码**
```cpp
#include<bits/stdc++.h>
using namespace std;
char s;

int main()
{
	while(cin >> s)
	{
		if(s == '4')
		{
			cout << 4;
        return 0;
		}
		if(s == '7')
		{
			cout << 7;
        return 0;
		}
	}

	cout << -1;
	return 0;
} 
```
~~实际上样例3没过~~

那么 `在s中作为子字符串包含s的最大次数。`是什么意思呢

> 说白了 就是这个幸运数字在字符串中出现次数最多才可以

所以**要点如下**——

* 大思路——因为`47`,`744`等都出现了$4$和$7$ 而$4$和$7$在字典序中最小 因此肯定在有解时输出$4$或$7$

* 当$4出现次数>=7$出现次数$输出4$ 否则$输出7$（$4,7出现次数>0$）

* 当$没有出现4,7$就输出`-1`

### 代码
```
#include<bits/stdc++.h>
using namespace std;
char s;//输入的字符（你也可以用string代替）
int n4,n7;//4，7各出现的次数
int main()
{
	while(cin >> s)//当还没有输完
	{
		if(s == '4')
		{
			n4 ++;
		}
		if(s == '7')
		{
			n7 ++;
		}
	}
	if(n4 >= n7&&n4 != 0) cout << 4;//当4出现次数>=7出现次数输出4
	else if(n7 != 0) cout << 7; //否则输出7（4,7出现次数>0）
	else cout << -1;//当没有出现4,7就输出-1
	return 0;
} 
```
最后[宣传博客](https://lzwblog.tk/)