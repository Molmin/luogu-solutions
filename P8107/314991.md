~~给一种 OEIS 解法~~

首先不管模 $k$ 的限制，直接把样例解释里的逆序对数扔到 OEIS 上，我们发现这个玩意儿的 GF 是：
$$\prod_{i=1}^n\sum_{j=1}^ix^j$$
然后考虑怎么算。由于乘出来的式子的项数是 $n^2$ 数量级的，因此任何多项式做法都不用想了。于是我们考虑把模 $k$ 的限制拿回来做 dp。$f_{i,j}$ 表示在第 $i$ 个因式处，所有次数模 $k$ 余 $j$ 的项的系数和。于是直接写出转移方程：
$$f_{i,j}=\sum_{l=1}^i f_{i-1,(j-l)\bmod k}$$
然而暴力转移的复杂度是 $O(nk^2)$，显然不行。所以我们需要加速转移过程。不难发现，$\sum\limits_{l=1}^if_{i-1,(j-l)\bmod k}$ 的第二维是在模意义下是连续的。因此你维护一个前缀和，就把复杂度压到 $O(nk)$ 了。关于空间，上个滚动数组压掉第一维即是 $O(k)$。具体见 Code：
```cpp
dp[0][0] = 1;
for(int i = 1; i <= k; ++i) sum[0][i] = 1;
for(int i = 1; i < n; ++i){
	int t = (i & 1), p = i % k;
	sum[t][0] = 0;
	for(int j = 0; j < k; ++j){
		dp[t][j] = sum[t ^ 1][k] * (i / k) % MOD;
		if(j >= p) dp[t][j] = (dp[t][j] + sum[t ^ 1][j + 1] - sum[t ^ 1][j - p]) % MOD;
		else dp[t][j] = (dp[t][j] - sum[t ^ 1][j - p + k] + sum[t ^ 1][j + 1] + sum[t ^ 1][k] + MOD) % MOD;
		sum[t][j + 1] = (sum[t][j] + dp[t][j]) % MOD;
	}
}
```
最后，统计答案时不要忘了乘上 $n!$ 的逆元。

upd：其实这个 GF 是我自己推出来的。本质上它就是在枚举每一位所选的数与之前的相对大小关系，因此直接 dp 也没有任何问题。~~不过假托 OEIS 之手更有意思~~