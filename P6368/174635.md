## 从零开始的P6368题解
本题解对于用到的知识介绍较为详实，非常适合刚开始接触字符串的萌新，同时可以了解巩固字符串相关知识。
#### 01 字符串的翻转问题
作为本题的知识背景，这一问题值得一提，题面即做出以下变换。
```latex
#..#.->.#..#
```
在一个字符串中，若以1为下标起点，我们不难发现中心对称的两个元素下标之和，总是比字符串个数多一，因此我们得到了以下代码。
```
#include<iostream>
using namespace std;
char w[20];
int length;
int main() {
	cin >> length;
	for (int i = 1; i <= length; i++) cin >> w[i];
	for (int i = 1; i <= length / 2; i++) swap(w[i], w[length - i + 1]);//这就是我们所得到的关系的具体体现
	for (int i = 1; i <= length; i++) cout << w[i];
}
```
$\operatorname{swap}$ 函数在 $C++$ 中可以对目标元素进行交换。但本题并用不到，因此不做详细介绍。
#### 02 本题思路
基于 01 中提到的思路，我们发现在本题的对称变换中，相当于是对多行同时进行了字符串反转。

但是值得注意的是，本题的目的并不是直接地反转得到处理后的字符串，而是要将反转后的字符串连接在原串之后，因此我们并不需要调用 $\operatorname{swap}$ 函数。

同时千万不要忘记了对题目所给出的 $(X,Y)$ 做出反符号处理，具体的措施详见03。
#### 03  代码实现
```cpp
for (int i = 1; i <= r; i++) {
		for (int j = 1; j <= c; j++) {
			a[i + r][j] = a[r - i + 1][j];
		}
	}//对于右边的图形进行轴对称
```
此处及以下以样例一进行示范

```latex
#. ->#..#
.# ->.##.
```

我们构建了一个二维数组来实现对于原矩阵的储存和连接。而为了实现连接而不覆盖原矩阵，应当注意下标是 $ a[i+r][j] $ 而不是 $ a[i][j] $ 否则会导致答案的错误。

而左下方的子矩阵与右矩阵相似，不再赘述。
```cpp
for (int i = 1; i <= r; i++) {
		for (int j = 1; j <= c; j++) {
			a[i + r][j+c] = a[r - i + 1][c-j+1];
		}
	}//对于右下方的图形进行中心对称
```
```
#. ->  #.
.# ->  .#
          #.
          .#
```
如果上图发生错位，应是浏览器缩放问题。

而右下方进行的是中心对称，而不再是轴对称，因此要对下标格外注意。

$ a[i + r][j+c] = a[r - i + 1][c-j+1] $

相当于同时进行了两次轴对称，因此下标是前两次轴对称变换的综合。

然后对于需要改变符号的 $(X,Y) $ 我们只需要在输出时单独处理即可。
####  04 AC代码
```cpp
#include<cstdio>
#include<algorithm>
#include<iostream>
#include<cstring>
#include<cmath>
using namespace std;
int r, c;
char a[500][500];
int x, y;
int main() {
	cin >> r >> c;
	for (int i = 1; i <= r; i++) {
		for (int j = 1; j <= c; j++) {
			cin >> a[i][j];//此处完全可以使用单重循环来进行字符串输入
						  //但是单个字符输入更不易搞混下标，体验友好
		}
	}
	cin >> x >> y;//输入处理以及左上方矩阵初始化
	for (int i = 1; i <= r; i++) {
		for (int j = 1; j <= c; j++) {
			a[i + r][j] = a[r - i + 1][j];
		}
	}//对于右上方的图形进行轴对称
	for (int i = 1; i <= r; i++) {
		for (int j = 1; j <= c; j++) {
			a[i][j+c] = a[i][c-j+1];
		}
	}//对于左下方的图形进行轴对称
	for (int i = 1; i <= r; i++) {
		for (int j = 1; j <= c; j++) {
			a[i + r][j+c] = a[r - i + 1][c-j+1];
		}
	}//对于右下方的图形进行中心对称
	for (int i = 1; i <= 2 * r; i++) {
		for (int j = 1; j <= 2 * c; j++) {
			if (i == x && j == y && a[i][j] == '#') a[i][j] = '.';
			else if (i == x && j == y && a[i][j] == '.') a[i][j] = '#';//对于题中所给坐标进行特殊处理
			cout << a[i][j];
		}
		
		cout << endl;
	}//对于题目所给出的(X,Y)坐标进行处理并输出
}
```

这样的题目耗时并不多，希望看到题解的各位不要复制代码，这样的AC毫无意义。
#### 05 总结

这是一道字符串的经典例题，同时也可以锻炼对于二维数组下标的使用能力，值得一刷。这也是本蒟蒻的第一篇题解。

本题解从背景知识开始，同时语法使用简单，适合新手阅读，求管理员大大通过。

 _题解001_ 
