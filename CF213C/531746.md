# 前置内容

这一道题是一道很经典的题，~~本人卡了好久才过~~，故发篇题解纪念一下。

建议在做之前做一下：
[P1002过河卒](https://www.luogu.com.cn/problem/P1002#submit)
[P1004方格取数](https://www.luogu.com.cn/problem/P1004)（本题弱化）
[P1006传纸条](https://www.luogu.com.cn/problem/P1006)（本题弱化）

- 注：P1004与P1006相同

------------

# 思路

我们发现本题中，回来再走一遍与直接走两遍**等价**。于是我们可以用数组 $ans_{i, j, k, l}$ 来记录当前一个走到 $(i, j)$ ，一个走到 $(k, l)$ 的**最优答案**，也就是**最大值**。

分析之后，我们很快就可以发现：难道这题和 P1004 以及 P1006 一样！？当然不是！这题是它们两题的**强化版**。 $n$ 的**数据范围**要大的很多，导致 $O(n ^ 4)$ **空间复杂度**算法点名被卡。

既然 $ans$ 数组数据量太大，就要想办法**降维**。可以发现 $\max(i + j - 1)=\max(k + l - 1) = 2 * n + 1$，何必**再花一维来储存**呢？于是可以想出 $O(n ^ 3)$ **空间复杂度**算法——用数组 $ans_(i, j, k)$ 来记录走了 $i$ 步，一个走到第 $j$ 行，一个走到第 $k$ 行。

完结撒花！ (〃￣︶￣)人(￣︶￣〃) 

------------

# 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=305;
int n,a[N][N],f[2*N][N][N];//我就是在定义数组上挂了……
int main(){
    cin>>n;
    for(int i=1;i<=n;i++)
        for(int j=1;j<=n;j++)
            cin>>a[i][j];
    memset(f,-0x3f,sizeof(f));//数据范围中声明 a 可能为负
    f[1][1][1]=a[1][1];
    //------预备————走！------//
	for(int i=2;i<=2*n-1;i++)
		for(int j=1;j<=n;j++)
            if(i-j+1>=1&&i-j+1<=n)//防止越界
			    for(int k=1;k<=n;k++)
                    if(i-k+1>=1&&i-k+1<=n){//防止越界
                        int t;//两个同时取在一个地方只加一次
        				if(j!=k)t=a[j][i-j+1]+a[k][i-k+1];
        				else t=a[j][i-j+1];
        				f[i][j][k]=max(f[i][j][k],f[i-1][j][k]+t);
        				f[i][j][k]=max(f[i][j][k],f[i-1][j-1][k-1]+t);
        				f[i][j][k]=max(f[i][j][k],f[i-1][j-1][k]+t);
        				f[i][j][k]=max(f[i][j][k],f[i-1][j][k-1]+t);
                    }
    cout<<f[2*n-1][n][n]<<endl;
    return 0;//功德圆满
}//Fgx出品，勿抄
```

千山万水总是情，给个点赞行不行~~