这道题95分好拿，但剩下5分不好拿，需要开unsigned long long，首先我来讲一下我的思路：

我是把编号k加上个1，这样的话就可能有这一种情况当k=2^64-1时，加上1就溢出了，没关系，unsigned long long是没有符号是会自然溢出的。我们先把2^64-1转化成二进制形式：
```
1111111111111111111111111111111111111111111111111111111111111111（64个1）
```
当我们在加上1时，就会变成:
```
10000000000000000000000000000000000000000000000000000000000000000(64个0)
```
其中unsigned long long只保留64位，而这64位都是0，所以前面的1是要省略掉的，所以只剩下：
```
0000000000000000000000000000000000000000000000000000000000000000(64个0)
```
化成十进制，那不就是0吗？？？

直接if等不等于0即可

那剩下的怎么办？？？

根据读题，我们可以得出在n+1位格雷码中如果前缀是0，后面就正序，反之倒序。

而且读题我们可以得出规律，n+1位格雷码中前半部分一定是前缀是0的，后半部分一定是前缀是1的

然后我们可以判断出在n+1位中前2^n个格雷码一定是前缀为0的，反之为1。

再一个if就行了。。。

好了,接下来前缀为0的没有啥事了输出0即可（**因为在n+1位格雷码中，前2^n个格雷码除前缀0以外第i个格雷码与n位格雷码第i个格雷码一定相同**），前缀为1要倒序怎么办???

首先，在n+1位格雷码中，第2^n+1个格雷码除前缀1以外它所在的n位格雷码中排序一定是最后一个，第2^(n+1)个格雷码除前缀1以外它所在的n位格雷码中排序一定是第一个，**第2^n+i个格雷码除前缀1以外它所在的n位格雷码中排序一定是第2^n+1-i个。**（根据前两个例子和普遍规律得出）

那不就是把编号2^n+i变成2^n+1-i吗
（**温馨提示：在变换的时候一定注意边界，灵活运用，防止溢出，一会儿看我的代码你就明白了**）

至于乘方，你用for循环解决还是用快速幂解决随你便（~~这不是重点，反正都不超时~~）

代码：
```cpp
#include<cstdio>
using namespace std;
int main(){
    unsigned long long a,k=1,o=2;
    int i,n,l;
    scanf("%d%llu",&n,&a);
    a++;
    if(!a){
    	printf("1");
		for(i=1;i<=63;i++){
			printf("0");
		} 
	}
	else{
		l=n-1;
		while(l){
			if(l%2){
				k*=o;
			}
			l/=2;
			o*=o;
		}
		while(k){
			if(a>k){
				printf("1");
				a=k-a+k+1;//如果写成k*2-a+1会溢出
			}
			else{
				printf("0");
			}
			k/=2;
		}
	}
	return 0;
}
```