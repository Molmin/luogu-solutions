考场上被数据坑了一个小时的我。。。

本题可以直接模拟（找规律）。

```
1位：
1
0

2位：
00
01
11
10

3位：
000
001
011
010
110
111
101
100

4位：
0000
0001
0011
0010
0110
0111
0101
0100
1100
1101
1111
1110
1010
1011
1001
1000

```
让我们竖过来康康——

可以发现，最后一位总是$0, 1, 1, 0$四个一组循环

倒数第二位是$0, 0, 1, 1, 1, 1, 0, 0, $循环

倒数第三位是$0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0$循环

以此类推，倒数第n位就是 $2^{n-1}$ 个 0  ,  $2^{n-1}$ 个 1  ,  $2^{n-1}$ 个 1  ,  $2^{n-1}$ 个 0 循环

然后就可以：

```
int num[4] = {0, 1, 1, 0};
```

**所以第k个数在第i位上就是num$[(k / $  $2^{n-1}$   $ $)$ $%4$ $ $]$**

然后代码就出来辣

下面奉上我丑陋的code：

```
#include <bits/stdc++.h>
#define re register
using namespace std;

int num[4] = {0, 1, 1, 0};

int main(){
	unsigned long long n, k;
	cin >> n >> k;//输入不说
	for(re unsigned long long i = n-1; i > 0; i--){
		cout << num[(k/((unsigned long long)(1)<<i))%4];//由于我是从n-1开始循环，所以在计算下标时不需要-1
        //1<<i相当于pow(2, i)
        //位运算时1必须要强制转换类型，要不然拿不到全分（我一开始code3.ans不一致就是因为没有强制转换花了半个小时
	}
	cout << num[k%4];//最后要单独输出，否则会出现inf
	return 0;
}

```

~~~
CSP2019 rp++
~~~