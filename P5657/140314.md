看到这数据规模，加上这是Day1 T1,第一反应就是找规律~~当然大佬们已经用5行代码秒切了~~。但直接从十进制上似乎很难找到规律，于是考虑按位找规律。

[不过这里有一份十进制规律的代码](https://www.luogu.org/paste/h588dn5q)

### 读题开始

题目中已经给出了n为3时的整个排列，把排列和k一一对应，得到如下结果


```
code: 000 001 011 010 110 111 101 100
   k: 000 001 010 011 100 101 110 111
```


嗯……似乎看不出什么对应关系，但如果我们一位一位来，似乎可以找到一些有联系的地方。

例如，第1位(编号从右往左，从0开始)的对应如下

```
code: 0 0 1 1 1 1 0 0
   k: 0 0 1 1 0 0 1 1
```


似乎0的个数和1的个数有一些对应关系？
然而并没有卵用，按着这个思路想了半天还是没有结果，于是我推了一下N为4时的排列和对应关系：

```
code: 0000 0001 0011 0010 0110 0111 0101 0100 1000 1001 1011 1010 1110 1111 1101 1100
   k: 0000 0001 0010 0011 0100 0101 0110 0111 1000 1001 1010 1011 1100 1101 1110 1111
```


再来按位找一下对应关系似乎就可以了，不难发现，若 $k >= 2$ ，则第k个格雷码的第 $1$位是 $k - 2$ 的第 $2$ 位取反的结果，否则格雷码的第 $1$ 位为0。

但是，这个 $k - 2$ 中的 $2$ 是哪来的呢？可以猜测是 $2^i$ 。于是验证一下第2位(即从右往左第3个bit)，发现猜想成立。

于是得到如下结论~~完全没有证明的结论~~：

### 若 $k >= 2^i$，则第 $k$ 个格雷码的第i位是 $k - 2^i$ 的第 $i + 1$ 位(编号从右往左，从0开始)取反的结果，否则格雷码的第 $i$ 位为0。

那最高位怎么处理呢？稍微观察一下可以发现，在最高位上，格雷码和k相等，所以做一下特殊处理就ok了。

**当然还要注意用ULL，不然拿不到满分。**

emmm说了这么多，似乎已经有大佬发过递归版了？那我发一个非递归的吧，AC代码如下：

```cpp
#include <iostream>
typedef unsigned long long ULL;
using namespace std;
ULL N,K;
int main()
{
	cin >> N >> K;
	cout << bool(K & (1LL << N - 1));
	for (int i = 2;i <= N;++i)
	{
		if (K >= (1LL << (N - i)))
			cout << bool(!((K - (1LL << (N - i))) & (1LL << (N - i + 1))));
		else
			cout << 0;
	}
}
```



