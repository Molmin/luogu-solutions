OI真理：
模拟猜题意，
骗分过样例。
暴力出奇迹，
打表出省一。

------------

本人一上来就被华丽的辞藻迷惑住了。都是这样，题目总是很玄乎。但我们还是要耐心把题看完。

------------

题目上已经给我们生成格雷码的算法了，但如果你按照他给的算法来模拟，这题你就写到茄子地里去了。因为我们可以观察到数据范围特别得大，已经达到了非高精的极限，所以我们首先猜测这可能是一道数论题。

------------

于是可以回想数论的内容有哪些：快速幂、同余、扩展欧几里得、素数。但这些昔日为王的算法在这里就是一群废物，丝毫用不上。

------------

当一个方向走不通时，千万不要一条道走到黑。数论走不通，就该换思路了。我们应该坚信它不会是像去年的填数游戏一样的一道数学题，因为它是第一题，不可能那么难。
我们再细细地读一遍题，可以发现“二进制”在题目中居然出现了13次！这就在暗示我们往二进制的方向去想。

------------

而本人做题一般是把三道题全部看完，再做打算。
观察到第二题出现了 XOR，第一题又有二进制。这不仅令人回想起去年day2的第一题和第二题的字典序。于是我就拿起手中的笔，开始人工打表。

------------

我们可以把四位格雷码列出来并按题目编上号：


------------
编号      - - - - -  0- - - 1 - - - 2- - - 3- - - 4- - - 5- - - 6- -- - 7
------------
格雷码   - - -  0000 0001 0011 0010 0110 0111 0101 0100
------------
编号二进制 0000 0001 0010 0011 0100 0101 0110 0111
------------
码XOR编号  0000 0000 0001 0001 0010 0010 0011 0011
------------
及其值  - - -  0- - - 0- - - 1- - - 1-- - -  - 2- --  2- -  - 3--  -- 3
------------


------------


------------


编号      - -- - -  - 8- - - 9- - -10- - 11 - - 12 - - 13- - 14 - - 15
------------
格雷码    - - - 1100 1101 1111 1110 1010 1011 1001 1000
------------
编号二进制 1000 1001 1010 1011 1100 1101 1110 1111
------------
码XOR编号  0100 0100 0101 0101 0110 0110 0111 0111
------------
及其值	- - - - 4- - - 4- - - 5 - - - 5- - - 6- - - 6- - - 7 - - - 7
------------



观察表格，我们发现一个天大的秘密：
编号为k的格雷码异或k居然是k/2！

我们不妨设编号为k的格雷码为G于是有：
G XOR k = k/2(这里是整除，也可记做k>>1)（1）

而异或的逆运算还是异或，即：
(A XOR B) XOR B = A

对于（*）式两边同时异或k就有：
G = (k >> 1) XOR k

如果你非要问我怎么证明的话，我只能是无可奉告。就像我们熟知的开普勒三定律一样，以上一切都是观察所得。本人参加了CSP，在有限的时间内没有时间也不会证明。不过本人的算法和百度百科上的算法居然不谋而合。

------------

https://baike.baidu.com/item/%E6%A0%BC%E9%9B%B7%E7%A0%81/6510858?fr=aladdin#5_4

https://baike.baidu.com/pic/%E6%A0%BC%E9%9B%B7%E7%A0%81/6510858/0/6a211233302c95d71a4cffbd?fr=lemma&ct=single#aid=0&pic=6a211233302c95d71a4cffbd

这题讲到这里也没什么意思了，最后给题解敷上一层代码（本人有个喜欢空格和空行的习惯，请勿模仿，不然改都改不过来）：
```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>

using namespace std;     // 不写爆零 

unsigned long long n,k,c,b;    //一定要开 unsigned long long 
int ans[107],t;

int main(){
	
	
	cin >> n >> k;
	
	c = (k>>1);      //由于位运算的优先级很低，						//所以写到括号里是最保险的。 
	b = (k^c);
	
	while (b != 0){
		ans[++t] = (b&1);
		b = (b>>1);
	}
	for (int i = n;i > 0;i --){    //注意位数，位									//数不够要补零 
		printf ("%d",ans[i]);
	}
	return 0;
}
```

