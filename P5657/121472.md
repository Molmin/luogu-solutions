# 赛后总结
弱，就是弱（~~那干嘛发题解~~）
# 正片
这道题，“列出数字来找”这种高空间，高时间的算法，其实没必要。

因为，这道题想起来难，做起来水。

**其实就是找规律。**


------------

## 解释
这道题如果给出下一组（n=4）的所有格雷码，是这样的：
```
0000 0001 0011 0010 0110 0111 0101 0100 1100 1101 1111 1110 1010 1011 1001 1000
```
我们可以这样分组：
```
0000 0001 | 0011 0010 || 0110 0111 0101 0100 ||| 1100 1101 | 1111 1110 || 1010 1011 | 1001 1000
```
仔细观察，可以得出如下结论：
**当选择了同级的左组数据时，所生成数码下一位将会按照0，1排列，当选择了右组时，则相反。**

## 举个栗子
当我们要求`n=4,m=11`（第十二个）时，可按照如下方法：

第一步，判断`11`是否大于或等于`2^4/2`，可见结果真。则输出1（或：flag的初始值的反值），并立一个flag,设为真。（可以理解为`!flag`）

第二步，将`11-2^4/2`（为3），并对`2^4/2`再次`/2`（为4）

第三步，判断`3`是否大于或等于`2^4/2/2`，可见结果为假。则输出flag，并设为假。

后面步骤以此类推。

最终的答案应该是`1110`
## AC代码（提示：根据洛谷规则，禁止抄袭）
```cpp
#include<bits/stdc++.h>
using namespace std;
bool flag=false;
int main()
{
    int n;
    cin>>n;
    unsigned long long m;//一定要unsigned！否则会炸#20！
    cin>>m;
    unsigned long long x=pow(2,n-1);//取半，防止超出范围
    string ans="";//其实可以直接cout，可是我考场没写qwq
    if(m>=x)
    {
        ans=ans+char(!flag+'0');
        flag=true;
        m=m-x;
    }else 
    {
        ans=ans+char(flag+'0');
        flag=false;
    }//第一次的判断
    for(long long i=1;i<n;i++)
    {
        x=x/2;
        if(m>=x)
        {
            ans=ans+char(!flag+'0');
            flag=true;
            m=m-x;
        }else 
        {
            ans=ans+char(flag+'0');
            flag=false;
        }
    }//上述步骤，应该不用多解释了
    cout<<ans;
    return 0;
}
```
# 糗事
考场我最开始想的是用递归列出所有数，然后找。花了一个半小时，~~最后还错了~~。

~~（这就是我开头说那个方法的原因）~~

这是我第一篇带详解的题解，写的不是特别好，希望谅解！谢谢！
# 常见错误
1.爆#20：只开了 `long long` ，没开 `unsigned long long`

2.全红：真假写反了~~（我就犯了）~~