# CSP2019 D1T1
TIPS：不开`unsigned long long`直接见鬼。

今年T1一看还是水，乍一看以为延续Day1延续了往年的风格，根据经验，简单题必上`long long`，再一看数据范围2^64果然稳了，没多想直接`ll`往上怼……可是没想到今年出题人变本加厉都要开`unsigned long long`才罢休，还好只有5分。。万幸。

咳咳，言归正传。题目一开始直接给了格雷码的递推构造公式，不难看出格雷码总数每次增加一倍（废话），那么每个格雷码必然与其编号$k$存在二进制对应关系，现在我们只需找到其对应规律。（其实接下来打个表就ok了。。我手推$n=4$情况然后直接就看出来了。。。）

对于一个$n$位的格雷码，其由$n-1$位的码前导添$0$或$1$构成。显然将$k$转成二进制后首位为$0$则对应前区正序$n-1$位格雷码首位添$0$的情况，反之对应后区$n-1$位格雷码逆序首位添$1$的情况。但是发现处理$n-1$位时就得考虑正反的情况，即前区添$1$，后区添$0$，这时想到设立一个flag异或取反，但若是再往后考虑$n-2$时可以发现，抹掉$n-1$位所留下来的是个回文序列，正反看都一样，便不再需要考虑取反，这时将flag归零，问题就解决了。

例如输入`3 5`时，5的二进制为101，对应格雷码为111。

首位为1，由于未设标记，照搬1，并立flag。

次为为0，发现已设flag，取反添1，消除flag。

末尾为1，flag之前已消除，照搬1。

连起来得111

程序很短，ull很毒，另外推荐cin/cout省的%d%u%lld%llu傻傻分不清

```
#include <bits/stdc++.h>
#define ull unsigned long long
using namespace std;
ull N, K;

string gray(ull n, ull k) {
	string s;
	bool f = 0;
	for (int i = n - 1; i >= 0; i--) {
		ull d = (1ull << i) & k;//取出第2^i位上的二进制
		d = (bool)d;//把d变成0和1
		s += d ^ f ? "1" : "0";
		f = d ? 1 : 0;
	}
	return s;
}
int main() {
	cin >> N >> K;
	cout << gray(N, K) << endl;
}
```