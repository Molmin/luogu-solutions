这道题的难度其实并不是很大，由于购买方式**只有两种：**

方式一：在**同一天**购买**正好两个**披萨，

方式二：在**连续的两天各购买一个**披萨，

因此大体思路上只需要进行**奇偶性的判断**并做处理就可以了。
## 思路：
**注意：我们是按照从第一天开始一天一天处理的，所以有可能处理到第i天时，并不是题目中所给的数据，而是处理过后的。**
首先我们需要处理掉需要奇数个披萨的时候（因为如果是偶数个就可以直接采用方式一购买完），我们需要选择方式二，在当天与当天的后一天各购买一个披萨。

代码：
```cpp
if(abs(a[i]%2)==1)
{
	a[i]--;
	a[i+1]--;
}
```
不过需要注意，有可能在减小的过程中会出现负数的情况，这就会直接影响模运算的结果（使之变为负数），因此我们需要对取模的数加上**绝对值**，~~本蒟蒻就在这里错了~~ 。

当然，如果减小之后出现负数，即出现了样例二中无法分配的情况，显然是不满足题意的，就可以直接输出并终止程序了。

代码如下：
```cpp
if(a[i]<0)
{
	cout<<"NO";
	return 0;
}
```




------------

以上循环的内容结束之后，之前**所有项都会变为偶数**（即都可用方式一购买完），因此我们只需要判断一下**最后一项的奇偶性**即可。

如果最后一项是偶数则满足题意，如果是奇数则不满足题意，因为这已经是最后一天了，无法采用方式一也无法采用方式二购买完所有披萨。

## 最后附上完整代码：
```cpp
#include <iostream>
#include <cmath>
using namespace std;
int main()
{
	int n;
	cin>>n;
	int a[n];
	for(int i=0;i<n;i++)
	{
		cin>>a[i];
	}
	for(int i=0;i<n-1;i++)
	{
		if(abs(a[i]%2)==1)
		{
			a[i]--;
			a[i+1]--;
		}
		if(a[i]<0)
		{
			cout<<"NO";
			return 0;
		}
	}
	if(abs(a[n-1]%2)==1) cout<<"NO";
	else cout<<"YES";
	return 0;
}

```
