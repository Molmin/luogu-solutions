## [洛谷传送门](https://www.luogu.com.cn/problem/P6150)
## 思路
路径的可能性太多，难以入手。

但我们只需要求起点的数量，所以需要分析路径的特性，对问题进行化简。

⾸先考虑路径的范围，我们可以让路径必然经过所有的点。

假定存在⼀条路径没有经过所有的点。

那么找到离路径最近的未到点 $A$ ，令它在路径中的邻点为 $B$ 。

我们可以在路径到达时，额外来回走过 $AB$ $12$ 次。

这样答案不变，但是路径会经过 $A$ 。

然后考虑路径的终点，如果起点到终点的距离⼤于1。

令终点到起点的路径为 $T , A , B ...$ ，那么我们可以延伸终点到 $B$ 。

然后反复⾛过 $11$ 次，这样答案不变，但是终点离起点更近了。

最终我们可以确保终点和起点距离不超过 $1$ 。

综上所述，如果⼀个点可以作为起点。

必然可以从它开始遍历完所有的节点并回到起点。

此时所有节点的值都为 $0$ ，⽽起点的值可以为 $0$ 或 $1$ 。

那么枚举起点，再遍历求解即可。
## 复杂度分析
### 时间复杂度
枚举起点 $O(N)$ 。

遍历 $O(N)$ 。

总共 $O(N^2)$ 。

本题还可以使用换根的方式做到 $O(N)$ ， 但没有必要， $O(N^2)$ 完全能过。
### 空间复杂度
存储树 $O(N)$ 。
## $code$
~~~cpp
#include <cstdio>
#include <iostream>
#include <vector>
using namespace std;
const int kMaxN = 2501;
struct V {
  int _v, v;
  vector<int> p;  // 邻点
} v[kMaxN];
int n, x, y, s;
void T(int f, int x) {
  v[x].v = (v[x]._v + 1) % 12;  // 第一次到达
  for (int i = 0; i < v[x].p.size(); i++) {
    if (v[x].p[i] != f) {
      T(x, v[x].p[i]);                               // 遍历儿子
      v[x].v = (v[x].v + 13 - v[v[x].p[i]].v) % 12;  // 将儿子调好
    }
  }
}
int main() {
  cin >> n;
  for (int i = 1; i <= n; i++) {
    cin >> v[i]._v;
  }
  for (int i = 1; i < n; i++) {
    cin >> x >> y;
    v[x].p.push_back(y);
    v[y].p.push_back(x);
  }
  for (int i = 1; i <= n; i++) {
    T(0, i);
    s += v[i].v == 1 || v[i].v == 2;  // 不回起点或者回到起点，起点多算了一次
  }
  cout << s;
  return 0;
}

~~~