## 前言
下面我只会说算法思路，具体的代码细节我就不赘述了，我贴出AC代码，希望能给各位一点帮助！由于我在不同oj上提交，代码会有些改动，我不知道会不会搞混了。如有错误，请各位指正。
为确保题解不要太长，代码我就不在这里贴。需要参考代码烦请移步：https://blog.csdn.net/qq_43290318/article/details/102764787
（~~打广告~~）

良心题解，能过么..QAQ.。求过么么哒

## 版本1
#### 单向bfs + stl set容器判重

（洛谷）总用时：7.53s

但过不了蓝桥杯那题，那题的数据点比洛谷强。。。

## 版本2
#### 单向bfs + 字典树判重 

将判重和插入分开：（洛谷）总用时：3.38s

在判重的同时实现插入：（洛谷）总用时：2.59s 

《算法竞赛入门经典》里面是以整数形式存储每种状态，我以字符串形式存储，感觉操作方便一点

手写字典树，如非必要，不要装×。在确保了我的bfs主算法正确后，我才试着手写字典树的，虽然心里还是有点虚。但很庆幸，调了2次就过了。之前师兄曾给我们展示过一个用数组实现字典树的模板，但由于这学期学数据结构，老师介绍了树的左兄弟右孩子表示法，于是我就试着用链表实现字典树。 

## 版本3
#### 单向bfs + 手写哈希表判重

（洛谷）总用时：2.67s

在判重的同时进行插入，队列我用数组模拟，但效率没有明显提高，建议都用stl提供的队列。

额，是不是觉得我很无聊。又手写哈希表。。。这学期学Java，了解了HashSet的底层实现，于是就自己模仿Java的实现原理尝试用C++写个简单的哈希表。其实这也不是我第一次手写哈希表，23333。。。

在3个oj上实测，效率一般来说比字典树高，但不太稳定。哈希表的效率主要取决于哈希函数的优略和哈希表的大小。我用的这个字符串的哈希函数是从网上找的，别人测试过的。另外哈希表的大小1000003，最好不要动它，我试过我一旦动了它，用时就边长了。至少，假如你用这个哈希函数，这个哈希表的大小就建议用1000003！针对其他哈希函数我不知道。

## 版本4
#### 双向bfs + map标记

（洛谷）总用时：351ms

大一参加蓝桥杯省赛之前，师兄曾开过一场培训，那时师兄就介绍过双向bfs，当时也讲了哈希表。。但当时听个懵懵懂懂。双向bfs，就是从起点和从终点“同时”bfs，这个同时并不是真的同时，只是两棵bfs树交替向外扩展，相当于你扩展一层后，然后轮到我扩展一层。当两棵bfs树相遇，最短路为相遇的两个状态的步数之和+1。开一个队列也可以实现！

如何判断两棵bfs树相遇呢？这个标记就很巧妙了。。这个标记我是借鉴了其它题解的。

看的出来，综合考虑，在赛场上这是首选！代码简短，效率还高。

## 版本5
#### 双向bfs优化 + map判重

（洛谷）总用时：358ms

每次出队，元素少的那个队列的对头元素出队！ 所有只能开两个队列了。

详情见大神博客：https://blog.csdn.net/ww32zz/article/details/50755225

好像用时没有减少。。但我在蓝桥杯题库和学校oj上提交，用时少了一点点。原因我盲猜一下，造成两个队列里面元素个数不相等的原因，就是其中一个bfs在扩展状态结点时碰到边界了。所以这个优化是否明显还要却决于两个bfs的起点的位置。蓝桥杯那题的终点状态不是固定的，可能这个优化对于蓝桥杯那题会比较明显吧。。快了十几ms。。如果我没记错。。当然，上述纯是我盲猜。。。也有可能我代码写错了，所以不明显。。

## 版本6  终极版本
#### 双向bfs优化 +  字典树判重

（洛谷）总用时：178ms

由于在使用双向bfs时要进行特殊标记，所以字典树要进行改动！具体实现我就不赘述了，参见代码。

在学校oj测试，最高用时：16ms

在蓝桥杯题库，最高用时：23ms
