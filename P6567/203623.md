upd 2021.6.22

我们在 word-RAM model 中，认为 $w=\Theta(\log n)$（或 $w=\Omega(\log n)$），所以二进制优化的复杂度为 $O(\dfrac {nk\log a} w)=O(nk)$。

---

今天在李煜东的《算法竞赛进阶指南》上看到一种 $O(nk)$ 的方法。

众所周知这道题可以二进制优化达到 $O(nk\log a)$ 的复杂度。（对不起，上已修正）

但是这道题比较特殊，只用判定每个物品是否能被表示出来。

那么考虑一种贪心的思想：

对于放入第 $i$ 个物品，在表示 $j$ 时，有两种可能

1. 状态 $j$ 已经被前 $i-1$ 个物品表示出来，即 $dp_j=1$。

2. 状态 $j$ 没有被前 $i-1$ 个物品表示出来，但状态 $j-i$ 已经被不多于 $a-1$ 个物品表示出来，即 $dp_j=0 \ \text{and} \ dp_{i-j}=1 \ \text{and} \ t_{i-j}<a$。

显然对于情况 $1$ 要尽量选择，迫不得已才选择情况 $2$。

那么我们再设置一个 $t$ 数组用于存放状态被多少个物品表示出来。

```cpp
dp[0]=1;
	while(n--)
	{
		k=read(),a=read();
		memset(t,0,sizeof(t));
		for(i=k;i<=500000;i++)
			if(!dp[i]&&dp[i-k]&&t[i-k]<a)
				t[i]=t[i-k]+1,dp[i]=1;
	}
```
这样的话，虽然理论复杂度优于二进制优化，但是由于其常数大、无法用 `bitset` 优化的原因，速度却远慢于二进制优化了。