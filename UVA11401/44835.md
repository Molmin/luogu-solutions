题意：从 $1,2,...n$ 中选出三个数，使其能构成三角形，求方案总数。

观察$N$的范围，易知需要使用数学方法或$O(N)$、$O(N  logN)$的递推。

数学方法？~~推不出来~~

于是先手算出$N$较小情况时的解 $ans[N]$：

$ans[3]=0$
$ans[4]=1$
$ans[5]=3$
$ans[6]=7$
$ans[7]=13$
$ans[8]=22...$

再算一下相邻解之间的差 $x[i,j]$：

$x[3,4]=1$
$x[4,5]=2$
$x[5,6]=4$
$x[6,7]=6$
$x[7,8]=9...$

这个时候，已经有大佬找出 $x$ 数组的数学规律了，然而由于当时并没有认真找规律，只是发现这个 $x$ 数组相邻两数的差有较明显的规律：

$x[4,5]-x[3.4]=1$

$x[5,6]-x[4,5]=x[6,7]-x[5,6]=2$

$x[7,8]-x[5,6]=x[8,9]-x[7,8]=3$

最后将其优化至一维： $x[i]=x[i-1]+(i+1)/2$

于是也可得到 $ans$ 数组的递推式： $ans[i]=ans[i-1]+x[i-3], i>3$

具体的证明可以用数学方法证出。

代码：
```cpp
#include <bits/stdc++.h>
#define int long long //数据很大，需要long long
using namespace std;
int x[1000005],ans[1000005],n;
signed main()
{
	for(int i=1;i<=1000005;i++)x[i]=x[i-1]+(i+1)/2;
	for(int i=4;i<=1000005;i++)ans[i]=ans[i-1]+x[i-3];//O(n)预处理ans数组
	scanf("%lld",&n);
	while(n>=3)
	{
		printf("%lld\n",ans[n]);//对于每一次询问，直接输出答案
		scanf("%lld",&n);
	}
	return 0;
}
```