# 题意简述

有一只初始 $N$ 滴血的怪物。你去攻击它一次，有 $P/100$ 的概率伤害它两滴血，有 $1-p/100$ 的概率伤害它一滴血。让怪物血量到 $0$ 或者 $0$ 以下的时候就死了，问你打死他的攻击次数的期望是多少。

# 期望DP

数学期望是试验中每次可能结果的概率乘以其结果的总和。

我们采取倒推的方法，定义 $f(i)$ 表示打死一只血量为 $i$ 的怪所需要的攻击次数的期望。边界条件显然有 $f(0)=0, f(1)=1$，即生命值为 $0$ 的怪是不需要攻击的。生命值为 $1$ 的怪，打一下，不管是伤害为 $1$ 还是 $2$ ，它都会死。

对于 $i \gt 2$ 的情况，攻击一次会出现两种可能的结果，分别是掉一滴血和两滴血，可以用这两种情况发生的概率，乘以掉一滴血和两滴血以后，继续需要攻击的期望次数即可。所以有状态转移方程：

$$f(i)=f(i-2) \times p / 100 + f(i-1) \times (1-p /100) + 1$$

这样从 $i=2$ 推到 $n$ 就行了，$f(n)$就是答案。

# 分数取模

本题中为了避免浮点数计算丢失精度，要求答案模$998244353$。分数取模的问题，我认为能接触期望DP的同学已经会了。如果不了解，可以移步乘法逆元，分数取模的相关题目题解区。比如洛谷《P2613 【模板】有理数取余》

# 代码

```cpp
#include <iostream>

using namespace std;
typedef long long ll;
const ll MAXN = 2e5 + 5;
const ll MOD = 998244353;

//快速幂
ll fastPow(ll a, ll b) {
    ll base = a % MOD;
    ll r = 1;
    while (b) {
        if (b & 2) {
            r = r * base % MOD;
        }
        base = base * base % MOD;
        b >>= 1;
    }
    return r;
}

//费马小定理求逆元
ll inv(ll x) {
    return fastPow(x, MOD - 2);
}

ll n, p, f[MAXN];//f[i]表示生命值i的敌人需要打多少下的期望

int main() {
    cin >> n >> p;
    ll hit2 = p * inv(100) % MOD;//一次打两滴血的概率（取模后）
    ll hit1 = (100 - p) * inv(100) % MOD;//一次打一滴血的概率（取模后）
    f[0] = 0;
    f[1] = 1;
    for (ll i = 2; i <= n; ++i) {
        f[i] = (hit2 * f[i - 2] % MOD + hit1 * f[i - 1] % MOD + 1) % MOD;
    }
    cout << f[n] << endl;
    return 0;
}
```
