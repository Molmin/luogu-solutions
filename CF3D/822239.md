~~看到带括号的题，我们的第一反应就是开个栈QwQ~~

首先需要知道一切一切的前提是括号序列合法，所以不能单纯的浅浅贪心求出代价最小的放法。

对于一个合法的序列来说，左右括号的数量一定相等，并且在当前位置，左括号的数量一定不小于右括号的数量，于是可以开一个栈来存左括号，遇到右括号就弹栈，栈空则不合法。

然而其实我们并不需要一整个栈，只需要留下栈顶即可，因为栈中元素相同。

然后就可以考虑贪心了，扫描整个序列：

如果是问号，就替换成右括号，然后判断能否配对，显然，这样的想法是正确的，因为左括号的数量一定不小于右括号的数量，所以在右括号数量多于左括号时，取出左括号代价最少的那个即可。

于是乎，每一步都保证了当前括号序列合法且最优，贪心的合理性也显而易见。

代码主体如下（要自己思考哟qwq）：
```cpp
	for(int i=0;i<l;i++)
	{
		if(s[i]=='(') top++;
		else 
		{
			top--;
			if(s[i]=='?')
			{
				int a,b;
				cin>>a>>b;
				q.push(node(a-b,i));
				s[i]=')';
				ans+=b;
			}
		}
		if(top<0)
		{
			if(q.empty())
				return printf("-1\n"),0;
			top+=2;
			node u=q.top();q.pop();
			s[u.id]='(';
			ans+=u.val;
		}
	}
```