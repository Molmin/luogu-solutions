先考虑什么是合法的括号序列。

设一个 $det$ ，如果碰到一个 `(` ，就 `det++` ，如果是 `)` ，就 `det--`。

那么一个括号序列合法当且仅当在任意未知的 $det$ 都满足 $det \ge0$

下面接着考虑怎么让代价最小。

因为要保证合法性，所以当遍历到一个位置的时候出现了 $det<0$ 的情况，我们就需要在当前位置的前面将一个 `?` 变成 `(`。

这个时候我们只需要取出来 $a_i-b_i$ 最小的就行。

具体来说，我们先假定每个 `?` 都被替换成了 `)` ，如果当前位置上的字符是 `?` ，我们将 $a_i-b_i$ 加入小根堆中。

每次 $det<0$ 时让当前答案加上堆顶权值，把堆顶元素 `pop` 掉，再 `det+=2`。

最后注意初始答案是所有 `?` 替换为 `)` 的权值之和。

时间复杂度： $O(n \log n)$ 。