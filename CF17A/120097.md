$1000$的数据范围是黄题？？

我的本题主要思路：统计出$n$以内的所有的好素数，用计数器累加，最后与$k$比较。

由于我要找出所有的好素数，所以我要把$n$以内的质数都找出来，~~由于本人不会O(n)的欧拉筛~~，就用$O(nlog^2n)$的埃拉托斯特尼筛法。~~但1000以内的数据范围根本没必要这么干~~，但是$OI$之路有很多有关质数的题目，所有还是敲一遍$O(nlog^2n)$的埃拉托斯特尼筛法再熟悉熟悉，码量多不了多少。~~那你怎么不敲欧拉筛~~

其他说明都在代码里：
```cpp
#include<cstdio>
int prime[171] = {2};//存储质数的数，2是第一个质数（唯一一个偶质数），1000以内有168个质数，但习惯多开几个防爆
bool p[1001] = {true, true};//true指不是质数，false是质数，全局变量初始0.
void find_prime()//预处理1000所有的质数
{
    int t = 1;//存质数的计数器
    for(int i = 4;i < 1001;i += 2) p[i] = true;//2的倍数不是质数
    for(int i = 3;i < 33;i += 2)//sqrt(1001)约等于32，+2避免又筛2的倍数
        if(!p[i])//是质数（为false）
        {
            prime[t++] = i;//第t个质数为i，并将t+1
            for(int j = i * i;j < 1001;j += i) p[j] = true;//t的倍数不是质数
        }
    for(int i = 33;i < 1001;i += 2) if(!p[i]) prime[t++] = i;//将>=33的质数放到存储质数的数组里
}
int main()
{
    find_prime();//预处理
    int n, k, ans = 0;//ans存答案
    scanf("%d%d",&n,&k);
    for(int i = 1;prime[i - 1]  + prime[i] + 1 <= n;i++)//质数和+1要小于等于n
    	if(!p[prime[i] + prime[i - 1] + 1])//质数的和+1是质数,那就是好质数
        	ans++;//就加1
    if(ans >= k) puts("YES");//大写字母！！！
    else puts("NO");//大写字母！！！
    return 0;
}
```
结语：其实还可以进行很多剪枝，但$1000$的数据范围真的没必要优化了