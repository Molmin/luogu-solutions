题目传送门：[CF1155D](https://www.luogu.com.cn/problem/CF1155D)
# 思路
这道题一看就是 **dp**。

**状态表示**：$f_{i,0}$ 表示在第 $i$ 位，没有使用魔法 $f_{i,1}$表示在第 $i$ 位，正在使用魔法 $f_{i,3}$ 表示表示在第 $i$ 位，已经使用完魔法。
**状态转移**：

$f_{i,0}$ 转移：

由于没有使用魔法，直接从上一个转移即可，注意要加上现在的数,就是 $f_{i-1,0}+a_{i}$。

所以方程为：  $ f_{i,0}=\max(f_{i-1,0}+a_{i},0) $。

至于为什么要加上 $0$,是因为有可能是负数，比如样例 $3$,取 $0$ 更划算。

$f_{i,1}$ 转移：

从没有使用魔法即 $f_{i,0}$ ,与上一个数进行用正在用魔法的值即 $f_{i-1,1}$ 加上当前值获得魔法的值即 $a_i\times x$ ，最后取最大值即可。

所以方程为： $f_{i,1}=\max(f_{i,0},f_{i-1,1}+a_i\times x)$。

$f_{i,2}$ 转移：

从正在使用魔法即 $f_{i,0}$ ,与上一个数进行用已经用完魔法的值即 $f_{i-1,2}$ 加上当前值获得值即 $a_i$ ，最后取最大值即可。

所以方程为： $f_{i,2}=\max(f_{i.1},f_{i-1,2}+a_i)$。

最后答案就是前三种的最大值即： $ans=\max(ans,f_{i,0},f_{i,1},f_{i,2})$。
# 代码
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int f[1234567][3],a[1234567]; 
main(){
	int n,x,ans=-1e9;
	cin>>n>>x;
	for (int i=1;i<=n;i++) cin>>a[i];
	for (int i=1;i<=n;i++){//方程转移
		f[i][0]=max(f[i-1][0]+a[i],(int)0);
		f[i][1]=max(f[i][0],f[i-1][1]+a[i]*x);
		f[i][2]=max(f[i][1],f[i-1][2]+a[i]);
		ans=max(ans,max(f[i][0],max(f[i][2],f[i][1])));//计算最大值
	}
	cout <<ans;
    return 0;
}

```