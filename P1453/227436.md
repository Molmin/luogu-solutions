# 题目大意
给你一颗基环树（比普通树多一条边形成一个环），每一个点有一个权值，要求相邻的两个点不能同时选，求所有方案中权值最大为多少，最后再乘一个实数。
# 方法
![](https://cdn.luogu.com.cn/upload/image_hosting/i9u4h6ow.png)

上面是一个基环树的图，圆表示一个点，三角形表示一颗树。

我们要在基环树上做$dp$，其实可以转化为对以在环上每一个点为根的树中做树形$dp$，最后在环上做环形$dp$。

## 步骤
1.找环，用$dfs$，用$book$标记已经走过的点，如果从一个点走到了一个被标记过的点并且这个点不是他的父亲，证明找到环了，然后从这个点一直往上跳到被标记的点，就找到了环，并用数组记录环上的点。
```
bool dfs(int u,int fa)
{
	f[u]=fa;
	book[u]=1;
	for(int i=head[u];i;i=e[i].next)
	{
		int y=e[i].to;
		if (y==fa)continue;
		if (book[y])
		{
			int x=u;
			while(x!=f[y])
			{
				cnt++;
				s[cnt]=x;
				v[x]=1;
				x=f[x];
			}
			return 1;
		}
		else
		{
			if (dfs(y,u))return 1;
		}
	}
	return 0;
}
```
2.在每一个树上做树形$dp$，不会的可以先去做没有上司的舞会。
```
for (int i=1;i<=cnt;i++)dfs_dp(s[i],0);
```

```
void dfs_dp(int x,int fa)
{
	for (int i=head[x];i;i=e[i].next)
	{
		int y=e[i].to;
		if (v[y]||y==fa)continue;
		dfs_dp(y,x);
		dp[x][0]+=max(dp[y][0],dp[y][1]);
		dp[x][1]+=dp[y][0];
	}
	dp[x][1]+=a[x];
}
```
3.在环上做$dp$，我们用$g[i][1/0][1/0]$表示当前点，当前点选不选，第一个点选不选（因为是环，最后一个点与第一个点相连）。

我用$s[i]$记录的环上的点。

```
g[s[i]][1][1]=g[s[i-1]][0][1]+dp[s[i]][1];//当前点选，上一个点就不选，第一个点选。
g[s[i]][0][1]=max(g[s[i-1]][0][1],g[s[i-1]][1][1])+dp[s[i]][0];//当前点不选，上一个点可以选也可以不选，第一个点选。
g[s[i]][1][0]=g[s[i-1]][0][0]+dp[s[i]][1];//当前点选，上一个点就不选，第一个点不选。
g[s[i]][0][0]=max(g[s[i-1]][1][0],g[s[i-1]][0][0])+dp[s[i]][0];//当前点不选，上一个点可以选也可以不选，第一个点不选。
```


4输出答案，我们输出最后一个点不选，第一个点不选，最后一个点选，第一个点不选，最后一个点不选，第一个点不选三个方案中权值最大的，再乘$k$（我用$m$表示，我用了滚动数组）。
```
printf("%.1lf",(double)max(max(g[cnt%2][0][1],g[cnt%2][1][0]),g[cnt%2][0][0])*m);
```