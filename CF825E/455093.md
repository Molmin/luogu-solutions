# CF825E Minimal Labels 题解

## 题意简述

求有向图最小字典序拓扑排序。

## 做法

建反图，从小到大赋值，每次取出当前入度为 $0$ 结点中编号最大的点进行赋值，最后反转拓扑序，即 $topo_i\leftarrow n+1-topo_i$。

## 正确性证明

归纳。我们希望原图拓扑排序字典序最小，则其等价于反图字典序最大，这是因为任意一个原图拓扑排序 $topo_i$ 都可以唯一对应一个反图上的拓扑排序 $topo'_i=n+1-topo_i$。首先考虑初始情况，原图上可赋值为 $n$ 的点为所有的出度为零的点，即反图上可赋值为 $1$ 的点为所有的入度为零的点。从感性理解的角度而言，编号较小的结点一定希望编号较大的结点先填好，这样子它能够填上的标记就会更大，从而拓扑序更大。而所有结点都希望编号最大的结点先填好，这不会违背任何结点的“利益”，换句话来说无后效性，即局部最优解不妨碍达成全局最优解，因此，编号最大的结点一定会被优先填入。

理性证明的话，我们考虑设当前出度为 $0$ 的所有点的编号为 $x_1,x_2,x_3,…,x_m$，按照单调递增顺序列出。不妨设我们将 $x_k,k<m$ 位置填成了 $1$，而 $x_m$ 位置填成了 $w$，然后对于剩下的残图按照最优的方式（即字典序尽可能大）完成了整个拓扑排序过程，我们称一个点 $u$ **支配**另一个点 $v$，当且仅当存在一条反图上的路径 $u\rightarrow v$。一个点 $x$ **支配**的所有点构成它的**支配集合** $S_x$。容易发现，$u$ **支配** $v \Leftrightarrow S_v\subset S_u$。现在考虑 $S_{x_k}\cup S_{x_m}$，这一集合中的每一个元素代表一个位置，它们都唯一对应一个填入的值。设位置序列为 $pos_1,pos_2,…,pos_{|S_{x_k}\cup S_{x_m}|}$，值序列为 $val_1,val_2,…,val_{|S_{x_k}\cup S_{x_m}|}$，其中 $pos_i$ 对应 $val_i$，按照值升序进行排序，即 $val_i>val_j\Leftrightarrow i>j$。那么我们从位置序列中去除掉 $x_m$，再从值序列中去除掉 $1$，将去除掉的位置之后的后缀整体在数组中向前挪动一位，得到新的位置序列和值序列  $pos'_1,pos'_2,…,pos'_{|S_{x_k}\cup S_{x_m}|-1}$，$val'_1,val'_2,…,val'_{|S_{x_k}\cup S_{x_m}|-1}$。容易发现，除了位置 $x_w$ 以外，对于一个原本的位置 $p$，其所对应的新的值 $v'$ 一定大于等于其原先所对应的 $v$，又因为存在 $x_k<x_w$ 而 $x_k$ 所填入的值增大，故拓扑序的字典序增大。那么此时考虑这样进行调整后是否仍然满足拓扑关系约束，即若 $u$ 支配 $v$，则 $u$ 填入的值小于 $v$ 填入的值。

- 对于 $x_w$ 之外的位置 $p$：因为 $S_{x_k}\cup S_{x_m}$ 内的所有元素进行的是值域平移，所以对于集合内部的约束关系，其值仍然符合条件；而由于 $u$ **支配** $v \Leftrightarrow S_v\subset S_u$，故在 $S_{x_k}\cup S_{x_m}$ 之外的位置与 $p$ 之间的关系一定是 $p$ 被**支配**，又因为其填入的值没有变小，故仍然符合条件。

- 对于 $x_w$：显然不会变为不合法，因为其入度为 $0$。

特别注意，调整后字典序严格变大。因此，我们说明对于 $n$ 个点的情况，我们必须将 $1$ 填入零度的编号最大的点，显然只有 $1$ 个点的图也应这样做，故不断地将当前的可以赋值的编号最大的点进行赋值即可完成整个过程，证毕。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
vector<int>edge[100005];
vector<int>fedge[100005];
priority_queue<int>q;
int deg[100005];
int lab[100005];
int main(){
	int n,m,u,v;
	cin>>n>>m;
	for(int i=1;i<=m;i++){
		scanf("%d%d",&u,&v);
		edge[u].push_back(v);
		deg[u]++;
		fedge[v].push_back(u);
	}
	int done=0;
	for(int i=1;i<=n;i++) if(!deg[i]) q.push(i);
	while(done<n){
		int qt=q.top();
		q.pop();
		lab[qt]=n-(done++);
		for(int j=0;j<fedge[qt].size();j++){
			int v=fedge[qt][j];
			deg[v]--;
			if(!deg[v]) q.push(v);
		}
	}
	for(int i=1;i<=n;i++) printf("%d ",lab[i]);
	return 0;
}
```