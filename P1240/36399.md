# Analysis

初次遇见这种题，很有困难。

一开始我的思考方式是棋盘多项式的思考方式。绝望。

那么正确的递推递归思路是什么呢？还记得约瑟夫问题吗。

首先定义状态，根据经验和题目意思，显然是，f(n,k)，表示在大小为n的棋盘里放k个。

然后“强制”联系它和之前状态（因为这不是我现在可以一眼发现的，需要有一个思维方向，如果可以一眼发现就不需要了，一切迎刃而解）。很显然，我们可以猜到，上一个状态是f(n-1,?)

现在要思考这个“?”是什么。

以n=3为例，画出n-1即n=2的图

对比和n=3的图，发现了什么？

n=2与n=3相比相差的是两列

于是乎就有了灵感。f(n,k)这个状态和f(n-1,？)这个状态的差距就是在这两个杠掉的行。在这两个杠掉的行有三种情况:
在这两个相差的行放0个；对应的上一个状态时f(n-1,k)

在这两个相差的行放1个；对应的上一个状态时f(n-1,k-1)

在这两个相差的行放2个；对应的上一个状态时f(n-1,k-2)

三种情况互不重复，加法原理直接加起来，这就是状态转移的路径。

但是，怎么计算呢？这是这题又一个难点。

ans=&f(n,k);

当放0个的时候，只有1种选择:放0个。

ans+=f(n-1,k)*1.

当放1个的时候呢？这个时候不止一种选择。发现我们没有办法确定这一个会不会对之后产生影响，因为，放在两行的最上面和放在两行的中间是不一样的！

到这里又怎么办呢？转化枚举方向，倒过来思考，在两个杠掉的行里放1个，相当于在其他行里放k-1个。在其它行放k-1个对现在杠掉的这两行的影响是可以被控制的：一定会产生影响。去掉被影响的格子，剩下的格子都可以选。这里是分步计算，所以利用乘法原理：
ans+=f(n-1,k-1)*（4*n-2*k-2）

利用相同的思想方法，可以很容易推出放2个的时候的情况：

ans+= f(n-1,k-2)*(2*n-k-1)*(2*n-k)。

于是打出程序。不要忘记求模。

# Code

```cpp
#include<bits/stdc++.h>

 

using namespace std;

 

int dp[101][20001];

 

int dfs(int n,int k){

   if (dp[n][k]!=-1)

      return dp[n][k];

   if (n==1){

      if (k==1 or k==0)

         return 1;

      else

         return 0;

   }

   int ans=0;

   ans=dfs(n-1,k)+dfs(n-1,k-1)*(4*n-2*k-2);

   ans+=dfs(n-1,k-2)*(2*n-k-1)*(2*n-k);

   return dp[n][k]=ans%504;

}

    

int main(){

   freopen("test.in","r",stdin);

   freopen("test.out","w",stdout);

   int n,k;

   cin>>n>>k;

   int ans=0;

   memset(dp,-1,sizeof(dp));

   ans=dfs(n,k);

   cout<<ans<<endl;

   return 0;

}

```
# Conclusion

转换思维方式，逆向思维，这很重要。这有点像C的计算方法：

C(n,k)=C(n,n-k)

n个里面选k个等价于n个里面选n-k个。有时候先n-k个比直接选k个更加好选。