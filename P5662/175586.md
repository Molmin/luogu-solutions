[博客食用更佳](https://www.luogu.org/blog/zxcblog/ti-xie-p5662-ji-nian-pin-post)

看到这道题，首先想到的肯定是暴力，但肯定过不了。  
注意到一个纪念品今天不动与卖掉再买是一样的，所以我们不妨假设每一天的一开始，小伟会卖掉所有手上的纪念品。  

先考虑$N=1$时的情况。每天卖掉纪念品后，买不买呢？  
由于第二天要卖掉，所以就看如果买了，第二天赚不赚就好了。  
如果赚，就用手上的钱买尽可能多的纪念品，否则不买。

$N\ge2$呢？  
$N\ge2$时，只用考虑如何找到一种合适的搭配方案，使第二天卖掉后收益最大。  
所以怎么选呢？自然想到背包啦。  
每一种纪念品都能买很多次，所以用完全背包好了。  
这时发现，$N=1$时，完全背包也是对的。

具体怎么背包呢？  
每一天，背包容量为钱数，每个物品的体积为对应纪念品今天的价格，价值为如果买一个对应的纪念品，明天会赚的钱。  
最后把钱数加上本次背包的结果即可。  

## 你们想看的东西：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define endl '\n'
int t[110][110];							//t[i][j]:第i个物品第j天的价格
int dp[11000];								//dp用的数组（这里压缩了一维）
int main()
{
	int d,n,m;								//d:天数,n:纪念品数,m:持有钱数
	cin>>d>>n>>m;
	for(int i=1;i<=d;i++)
	{
		for(int j=1;j<=n;j++)
		{
			cin>>t[i][j];
		}
	}
	for(int T=1;T<d;T++)					//只需dp n-1天，因为最后一天不买纪念品
	{
		memset(dp,0,sizeof(dp));			//初始化
		for(int i=1;i<=n;i++)
		{
			for(int j=1;j<=m;j++)			//完全背包，正着dp
			{
				dp[j]=max(dp[j],dp[j-1]);
				if(j>=t[T][i])
				{
					dp[j]=max(dp[j],dp[j-t[T][i]]+t[T+1][i]-t[T][i]);
				}							//上一行的t[T+1][i]-t[T][i]即为如果买，明天赚的钱。
			}
		}
		int pls=dp[m];						//钱数+=今天dp的答案
		m+=pls;
	}
	cout<<m<<endl;
	return 0;
}
```