## CF1195E 【OpenStreetMap】
**[去博客阅读](https://imlqz.wind-flower.cn/archives/cf574-div2-1195/)**

**题意**

给定一个 $ n\times m $ 的矩阵 $ h $ ,求出所有大小为 $ a\times b $ 的子矩形中的最小值的和.

矩阵的给定方式: 给定 $ g_0,x,y,z $ ,它们表示一个序列 $ g_i=(g_{i-1}\cdot x+y)\bmod z $ ,而 $ h_{i,j}=g_{(i-1)\cdot m+j-1} $. 

**思路** 

**单调队列模板题**  

首先生成这个矩阵（这应该不用我说了吧。。。）

由于矩阵是二维的，不能直接用单调队列，因此可以先预处理出每行的情况$f_{i,j}$表示$h_{i,j}$,$h_{i,j+a-1}$中的最小值（很明显用单调队列）

这样就把原来的$a * b$的矩阵转换成了$1 * b$的矩阵，然后再求出每个1 * b矩阵中的最小值，求和即可（还是用单调队列）

单调队列具体实现方法：

以第一次操作为例，对于每一行

1. 首先建立一个双端队列(STL deque)，双端队列中存一个int类型，表示该元素对应是第i行的第几个。然后扫描该行，设扫到该行第j个元素
2. 首先检查对头的元素与j的距离是否大于a（如果大于说明这个最小值已经“过期”，弹出队头，并再次检查）
3. 最后剩下的队头就是$j-a+1$,$j-1$之间的最小值，与当前的$h_{i,j}$取个min即得到了一个最小值，累加到答案中
4. 检查队尾元素值是否大于$h_{i,j}$，如果大于，弹出队尾并重复这一步（因为这些元素在j之前就被加入，且值比j大，未来肯定没用，为了维护队列的单调性，直接弹出即可）
5. 把j插入到队尾

为什么这样可行？原因在于维护了一个队列，其中队列中每个下标对应的元素值递增，这样每次取出队头就得到了该次的最小值。每个元素平均出队/入队1次，因此复杂度为$O(nm)$

**Code请见博客**  