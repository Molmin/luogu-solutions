## xxs发题解 第 $8$弹

发现了一件奇奇怪怪的事情：全场**清一色**的C++题解！

所以我要来一篇C语言题解！

---

思路：

1.从左边开始遍历先找 `[`，再找 `:`  

2.从右边开始遍历先找 `:`，再找 `]`

3.遍历两个 `:` 之间有多少个 `|`，+4输出。

做做看吧！

注意：**这题有超多坑点**！

---

如果你样例过了，但WA了，来看看我的自造 Hack 数据：

\#1

input: `[:]`

ans: `-1`

\#2

input: `:]:|:[:`

ans: `-1`

\#3

input: `|[|:|:|]|`

ans: `5`

\#4

input: `[|[|:|:|:|:|]|]`

ans: `7`

---

### 现在是讲解时间~

直接上代码，讲解都在注释里
```
#include<stdio.h>//不解释
char a[500005];//字符串数组
int l,r,m1,m2,length;//变量，分别对应'[',']'和两个冒号的位置
#define OVER {printf("-1");return 0;}//一个宏，作用是输出无解并结束程序
int main()
{
	scanf("%s",a);//输入（不要“&”！）
	
	for(length=0;length<500001&&a[length]!=0;length++);//寻找'\0'(结束位置，刚好也是字符串长度)
	
	for(l=0;l<length&&a[l]!='[';l++);//找左括号
	
	if(l>=length)OVER//判断边界，后面的同理
	
	for(m1=l+1;m1<length&&a[m1]!=':';m1++);//找第一个冒号
	
	if(m1>=length)OVER
	
	for(r=length-1;r>=m1&&a[r]!=']';r--);//找右括号 
	
	if(r<m1)OVER//位置错乱，再见
	
	for(m2=r-1;m2>m1&&a[m2]!=':';m2--);//找第二个冒号
	
	if(m2<=m1)OVER//注意：两个冒号一定不能在一起！
	
	int ans=4;//先把[::]四个字符算上
	
	for(int i=m1+1;i<m2;i++)if(a[i]=='|')ans++;//找两个冒号直接有多少'|'
	
	printf("%d",ans);//输出
	
	return 0;
}
```
如果你AC了，记得点个赞再走8~