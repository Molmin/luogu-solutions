此题青青草原的美誉真不是白来的，绿色果然让眼睛舒适~

我的微压行代码 15 行，不压行也不超 20 行。

### 思路

找到最左边的 `[` 和最右边的 `]`，再找到这两个符号之间的两个 `:`，然后输出两个 `:` 之间 `|` 的数量加 $4$。  

如果**有某个字符找不到或数量不够**，输出 $-1$；

### 前置知识

1. $\texttt{reverse}$ 函数。  
该函数无返回值，其作用是将某个字符串翻转。  
用法：``reverse(s.begin(), s.end());``
1. $\texttt{find}$ 函数。  
该函数有两个参数，会返回字符串中某个位置之后的**第一个**要找的字符串或字符的位置，如果**不存在**，返回 $-1$，若第二个参数不填，默认为 $0$。  
用法：``s.find(':', 3);`` 将会返回下标 $3$ 开始**第一个**出现的 `:` 的下标，不存在返回 $-1$(string :: npos 亦可)。

### 代码细讲

输入后，我们就能进行第一个判断：注\*1
```cpp
cin >> s; int len = s.length();
if (len < 4 || !~s.find('[') || !~s.find(']') || !~s.find(':'))
	return puts("-1"), 0;
```
如果 $len < 4$ 或找不到 `:`、`[`、`]`、`:` 中的任意一个，直接输出 $-1$ 并返回 $0$。

接下来拿另一个字符串存储翻转后的字符串。这里我的处理是这样的：  
``s2 = s, reverse(s.begin(), s.end()); swap(s, s2);``   

**这样 $s$ 还是输入的原字符串，$s2$ 是翻转后的字符串。**  

现在我们用 $l$ 表示最左边的 `[`，$r$ 表示最右边的 `]`。但我们知道，$\texttt{find}$ 函数只会返回最左边的，这时候翻转的字符串的作用就是：**翻转后的字符串最左边的那个就是翻转前最右边的。**  

``int l = s.find('['), r = len - s2.find(']') - 1;``

而找到后要用 ``len - s2.find(']') - 1`` 才能得到这个位置在原字符串中的位置。  

接下来我们用 $l2$ 表示 `:` 在 $l$ 之后的第一个位置，$r2$ 表示 `:` 在 $r$ 之前的最右的一个位置。 

``int l2 = s.find(':', l), r2 = len - s2.find(':', -r - 1 + len) - 1;``  

为什么 $\texttt{s2.find}$ 函数的第二个参数是 $-r - 1 + len$ 呢？这个参数不该是 $\texttt{s2.find(']'))}$ 吗？  
我们来看看：``r = len - s2.find(']') - 1``，看到这里就明了了：``s2.find(']') = -r - 1 + len``。我们不用**浪费 $O(n)$ 的时间复杂度**去重复计算。  

现在迎来第二个判断：  
``if (l > r || !~l2 || !~(-r2+len-1) || l2 >= r2) return puts("-1"), 0;``  

如果 $l > r$ 或在 $l$ 之后找不到 `:` 或在 $r$ 之前找不到 `:` 或 $l2 \geqslant r2$，直接输出 $-1$ 并返回 $0$。  

$l$ 不可能等于 $r$，因为这两个符号不一样，不会在同一个位置出现。  

$l2 = r2$ 时说明两个中括号之间**有且仅有**一个 `:`；$l2 > r2$ 时说明两个 `:` 中**至少有一个**在两个中括号外。  

判断 $-r2+len-1 \neq -1$ 相当于 $\texttt{s2.find(':', -r - 1 + len)} \ne -1$，其道理前面已经解释过。  

到现在，这个串就**一定是合法的**了。那就寻找两个 `:` 之间有多少 `|`，用 $cnt$ 表示，再将 $cnt + 4$ 输出即可。  

#### 注：判断中写到的符号，`!~x` $\Leftrightarrow$ `x == -1`。

[AC code记录](https://www.luogu.com.cn/record/51430454)

```cpp
#include <bits/stdc++.h>
using namespace std;
string s, s2; int cnt;

int main()
{
	cin >> s; int len = s.length();
	if (len < 4 || !~s.find('[') || !~s.find(']') || !~s.find(':')) return puts("-1"), 0;
	s2 = s, reverse(s.begin(), s.end()); swap(s, s2);
	int l = s.find('['), r = len - s2.find(']') - 1,
		l2 = s.find(':', l), r2 = len - s2.find(':', -r - 1 + len) - 1;
	if (l > r || !~l2 || !~(-r2+len-1) || l2 >= r2) return puts("-1"), 0;
	for (int i = l2; i <= r2; ++i) cnt += s[i] == '|';
	return printf("%d", cnt + 4), 0;
}
```