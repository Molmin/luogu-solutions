[青青草原](https://www.luogu.com.cn/record/54669388)名不虚传。

### 思路：

模拟即可，坑也不多，但要注意以下几点：

1. 从前往后和从后往前找 `:` 的时候,要先找到过 `[` 或 `]` 后再找到的，才算是合法的。

2. 最后答案要加 $4$（原因注释中有详细解释）。

### 代码：

```cpp
#include<bits/stdc++.h>//万能头 
#define re register int//宏定义register int为re
using namespace std;
char s[500005];
int main(){
	int l,fz=-1,fm=-1,lz=-1,lm=-1,ans=0;
	cin>>s;
	l=strlen(s);
	for(re i=0;i<l;i++){//从前往后遍历 
		if(s[i]=='['&&fz==-1)fz=i;
		//如果找到了'['且之前没有找到过它,就说明找到了第一个它,储存它的位置 
		if(s[i]==':'&&fm==-1&&fz!=-1)fm=i;
		//如果找到了':'且之前没有找到过合法的它,且之前已经找到了第一个'[',就说明找到了第一个合法的它,储存它的位置 
		if(fz!=-1&&fm!=-1)break;//如果都找到了,就退出循环 
	}
	if(fz==-1||fm==-1){//如果没有找到'['或合法的':'就输出-1,结束程序 
		printf("-1");
		return 0;
	}
	for(re i=l-1;i>=0;i--){//从后往前遍历
		if(s[i]==']'&&lz==-1&&i!=fz)lz=i;
		//如果找到了'['且之前没有找到过它,就说明找到了最后一个它,储存它的位置 
		if(s[i]==':'&&lm==-1&&i!=fm&&lz!=-1)lm=i;
		//如果找到了':'且之前没有找到过合法的它,且之前已经找到了最后一个']',就说明找到了最后一个合法的它,储存它的位置
		if((lz!=-1&&lm!=-1)||i<=fz)break;//如果都找到了或i已经小于第一个'[',就退出循环
	}
	if(lz==-1||lm==-1){//如果没有找到最后一个的']'或非第一个的合法的':'就输出-1,结束程序
		printf("-1");
		return 0;
	}
	for(re i=fm+1;i<lm;i++)//在第一个合法的':'和最后一个合法的':'中间找'|' 
		if(s[i]=='|')ans++;
	printf("%d",ans+4);//输出找到的'|'的个数加4(第一个'['和最后一个']'还有第一个和最后一个合法的':') 
	return 0;//好习惯 
}``
