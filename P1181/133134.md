萌新感觉其实还不太简单啊。。。代码不难写但感觉想起来其实还是有点难的。。// dalao们别喷我5555  
直觉得到的思路就是从左到右累加，加到超过m就再分一组，萌新想了很久这个事情的正确性……  
我试着用反证法证明了一下这个的确是最优解……  
证明：  
设k[i]来记录第i个分组的位置，其中k[1]=1，这个数列的第j项为a[j]，通过上面的方法，得到a[k[1]], a[k[1]+1], ...a[k[2]-1]位于第一组，a[k[2]], a[k[2]+1], ...a[k[3]-1]位于第二组，a[k[3]], a[k[3]+1], ...a[k[4]-1]位于第三组，以此类推，最后一个元素可表示为a[k[p]+t]。(即一共被分成了p组)    
则任取i<p，有：   
a[k[i]+1]+a[k[i]+2]+...+a[k[i+1]-1] <= m ①,  
a[k[i]+1]+a[k[i]+2]+...+a[k[i+1]-1]+a[k[i+1]] > m ②。  
假设存在更优的解，即这个解的分组数量比p少，这个解的产生过程一定可以视为合并了至少两个相邻的分组之后移动分组的边界。不妨设只合并了两个分组a[k[i]]~a[k[i+1]+t]。由于②，这个合并的区间一定不能满足题目条件，所以需要移动左侧或右侧分组的边界。  
假设移动右侧的边界，由于②，右侧边界要一直移动到合并前的两个分组的边界处才能符合要求，而这时右侧的分组相当于吞并了一整个分组，由于②，这样操作不能满足要求。  
假设移动左侧的边界，因为②，左侧的边界即使移动1个元素也会超出范围。
所以不存在更优的解，对于这个问题的最优解就是直觉hhh  
可以结合这个图理解一下……  
![示意图233](https://cdn.luogu.com.cn/upload/pic/50916.png)

代码的话就比较简单了，实现思路就可以了……
```c
#include <cstdio>

using namespace std;

// s:sum，题里的m
int n, s;
// 缓存的当前组的数字和
int ts;
// 分组数目
int ans;

int main() {
	scanf("%d%d", &n, &s);
	int t;
	for (int i = 0; i < n; ++i) {
		scanf("%d", &t);
		ts += t;
        // 是否超过s
		if (ts > s) {
        	// 超了，新的数字只能放在新的组里
			ts = t;
			++ans；
		}
	}
	
    // 最后一组不会被计数，所以要+1
	printf("%d", ans + 1);

	return 0;
}
```