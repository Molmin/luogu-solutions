可以边读边做，可以全读完在做（写法都是一样的），但既然边读边做省时间，那就边读边做了

用sum记录当前的和，ans记录分的段数


外面套一个循环读入新数

sum先加上去，看看与规定的每段的和比较怎么样

1.大于规定的和

说明新数和之前的数要分段了，sum记为新数（因为要继续操作啊），段数ans++

2.等于规定的和

说明新数与之后的数要分段了，sum记为0（重新记段了），段数ans++

3.小于规定的和

继续做呗，这里可以不用写continue

```cpp
#include<iostream>
using namespace std;
int n,m,a[100007],ans,sum;//一开始没看见数据范围RE了
//sum是计算当前每一段的和，ans是分的段数
int main()
{
    cin>>n>>m;//直接读入，边读边做
    for(int i=1;i<=n;i++)//也可以是while循环
    {
        cin>>a[i];//每次读入一个新的数
        sum+=a[i];//加上试试
        if(sum>m)sum=a[i],ans++;//比限制的数大了，要分一段，记住此时总和是新的一段，所以sum等于这个数
        else if(sum==m)sum=0,ans++; 
        //如果刚刚好，要分一段，此时总和就是0了
    }
    if(sum)ans++;//如果还有剩余的，记住要再分一段
    cout<<ans;//输出
    return 0;//记得要写
}
```
~~竟然嫌我说明少~~