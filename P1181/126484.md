## 作为一个突然想~~浪费人生中的美好10分钟~~复习一下贪心的人
### 我点开了```贪心```标签，于是乎就水了这道题……
#### 不多说了，其实这道题就是一个理解贪心正确性然后AC的题，不过这里有几点**小建议**要给大家：
### 1. 有时候在读入一个数据后立即进行处理能够让你的~~main函数变长~~程序更省空间，比如这道题，就不必开存储物品的大数组了，当然，这种水题也不必省空间吧……记住这点，只要是可以边读边操作的，都这样做！所以我的码风经常是这样的?
```
for(int i=1;i<=something1;i++)
{
	something2=read();
    solve();
}
```
### 2.贪心题的正确性判断，比如本题，一个新读入的数你要么放进原有的容器，要么放不进去就~~算了~~再来一个，正确性是显然的。当然，贪心的正确性在较大型的题目中是需要加以反复考虑的!
```
if(bucket+num[i]>lim)
//桶放不下了(在桶排序之后忘不了bucket了QwQ)
{
	cnt++;
    //多加一个桶，为什么只开一个桶？?
    bucket=0;
}
bucket+=num[i];
```
### 3.有时候你的处理就得比较巧妙了:
#### Q:为什么只开一个桶？
#### A:本题并不要求记录咋装的，不问过程就可以~~过河拆桥~~反复利用一个桶
## 又是那个思路，反复用一个不计路径的int数，用完再覆盖着用，都是为了省下空间
好吧，我也不期望你们能够有耐心看我在上面扯，放代码：
```
#include <bits/stdc++.h>
#define ll long long
using namespace std;
const int maxn=100010;
int n,lim;
int num[maxn];
ll bucket=0,cnt=1;
int main()
{
　　cin>>n>>lim;
　　//并不需要快读:个数，容量上限
　　for(int i=1; i<=n; i++)
　　{
　　　　cin>>num[i];
 　　  //并不需要快读:大小
　　　　if(bucket+num[i]>lim)
　　　　{
		　　bucket=0;
		　　cnt++;
          　//放不下加个桶重装
　　　　}
　　　　bucket+=num[i];
    　　//比较巧妙的放在外面，两个情况一次满足
　　}
　　cout<<cnt;
  　//一次完美的AC
}
```
### 听我一句劝:别抄我的题解，有毒！(亲测CE)
# 撒花✿✿ヽ(°▽°)ノ✿