令 $dp_i$ 表示现在抛出的序列与 $S$ 的的前 $i-1$ 个匹配，想要抛到有 $i$ 个匹配的期望步数。$p_{i,0}$ 表示抛一次等于 $S_i$ 的概率，$p_{i,1}$ 表示抛一次不等于 $S_i$ 的概率。

转移考虑讨论这一次抛出的结果是否与 $S_i$ 相等。

如果相等：期望步数 $1$，概率 $p_{i,0}$。

如果不等：

那么现在抛出的结果的一个后缀可能与 $S$ 的一个长为 $len_i$ 的前缀相等，可以把目前状态当成抛对了 $len_i$ 个去转移。期望步数 $(\sum\limits_{k=len_i+1}^{i}dp_k)+1$，概率 $p_{i,1}$。

可以得出状态转移方程：

$$dp_i=p_{i,0}+p_{i,1}\times((\sum\limits_{k=len_i+1}^{i}dp_k)+1)$$

把 $dp_i$ 全部移到左边：

$$p_{i,0}\times dp_i=p_{i,0}+p_{i,1}\times((\sum\limits_{k=len_i+1}^{i-1}dp_k)+1)$$

把 $p_{i,0}$ 再除过去，用前缀和维护即可。

$len_i$ 容易用 KMP 在 $O(|S|^2)$ 的时间求出。

但是这题要输出分数，分子和分母需要高精度存储，需要支持高精 $\gcd$、高精除。

然后发现 $dp$ 的分母每次只会乘 $a,b-a,b$ 中的一个，于是不用写 $\gcd$ 了，直接一个个试除。试除 $x$ 时直接除 $x^3$，这样普通高精就能跑过去了。

时间复杂度 $O(|S|^3)$，但是卡常后能过。[代码](https://www.luogu.com.cn/paste/ze9p65dj)。