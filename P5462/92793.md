题目描述

“X龙珠”是一款益智小游戏。游戏中有 n(2∣n)个编号互不相同龙珠按照给定的顺序排成一个队列，每个龙珠上面都有一个编号。每次操作时，选择并取出龙珠队列中相邻的两个龙珠，放到目标队列的末尾（目标队列最开始是空的，且这两个龙珠的前后顺序不变），然后去除原龙珠队列的空隙。反复多次，直到原龙珠队列为空。可见，因为决策不一样导致目标队列顺序不一样。现在请求出所有方案中、目标队列字典序最大的方案。只需要给出目标队列即可。

例如，当原龙珠队列是 [1,3,2,4] 时，可以先取出 3 和 2，此时目标队列是 [3,2]，原龙珠队列是 [1,4]；再将剩下两个龙珠放入目标队列，得到目标队列是 [3,2,1,4]

思路：用双向链表来保存原龙珠队列。用优先队列来维护最值，从而使字典序最大。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=1000000+10;
int n,a[maxn],l[maxn],r[maxn];//用数组模拟链表。l是左指针，r是右指针。
map<int,bool> used;//用来判断数字是否已经进入目标队列。
priority_queue<int> PQ;//用优先队列（大根堆）维护最大值。
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;++i)
	{
		scanf("%d",a+i);
		if(i<n) PQ.push(a[i]);//将所有的相邻编号的二元组中的左边元素入堆。左元素可通过指针找到右元素。故无需让最后一个元素入堆。
		r[a[i-1]]=a[i];//   构造链表。
		l[a[i]]=a[i-1];
		used[a[i]]=false;
	}
	r[a[n]]=0;
	while(!PQ.empty())
	{
		int x=PQ.top();
		if(used[x]){PQ.pop(); continue;}//如果堆顶元素已经用过（可能它的前一个元素连它一起用过），直接弹出。
		if(r[x]==0){PQ.pop();}
		if(r[x]!=0 && !used[x])
		{
			used[x]=true;
			used[r[x]]=true;//从原队列取出两个元素。
			r[l[x]]=r[r[x]];
			l[r[r[x]]]=l[x];//维护双向链表。
			PQ.pop();
			printf("%d %d ",x,r[x]);
		}
	}
	return 0;
}
```
这种方法更倾向于使用数据结构。用STL后对算法的要求并不高。
