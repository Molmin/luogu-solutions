首先说我太菜了， 看了题解，要么链表，要么线段树，还有排序的，看的懵逼。

那我就发一个适合像我这样菜的人看的题解吧。全是数组实现，不用到合并和删除操作，只有输出，不吸氧总耗时435ms。不算快

PS：A题战俘是橙色题，而这道龙珠是绿色题，我不会A题。。我真的太菜了。

思路：题目说n个龙珠，而且龙珠编号互不相同， **龙珠编号是1到n**， 题目说字典序要最大，那么很容易想到我只要把最大的那个编号，看看它能不能现在输出，而能不能输出就是看这个最大编号的球右边还有没有没输出过的球！有就输出这两个球！ （输出的话要标记着两个球已经输出过了，比如标记为true）如果没有就判断编号是n-1的球能不能输出，.....一直到编号为1的球结束程序。
**模拟一遍这个过程:**
比如样例 4 2 3 6 5 1 并且弄一个标记数据bool mark[maxn]
简单来说就是从N到1判断能不能输出

判断编号6， 6可以输出，因为6右边的5没有输出过，所以输出6 5 
同时mark[6] = mark[5] = true，即输出过了

判断编号5， 不可以，因为5输出过了。

判断编号4 ，发现4没有输出过，且4右边有一个没有输出过的2，所以输出4 2 ，同时标记mark[4] = mark[2] = true，现在打印了6 5 4 2 

判断编号3， 3没有输出过，在3右边找一个没有输出过的数字和它一起输出， 发现1没有输出过，所以输出3 1 标记mark[3]=mark[1]=true 这时候程序打印了6 5 4 2 3 1 

判断编号2， 因为2已经输出了，所以不输出，程序直接下一步
判断编号1， 因为1已经输出了，所以不输出，因为是编号1最后一个球了，程序结束。
所以最终输出是6 5 4 2 3 1 

代码和注释如下
```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int n;
int a[100005];//储存输入的序列
int  mark[100005];//标记数字是否输出，1为已经输出，比如mark[10]=1表示数字10已经输出
int pos[100005];//记录数字在序列出现的位置，比如pos[2]=1,表示2出现在序列第1个位置

int check(int p)//判断序列a[]的第p个数字右边有没有数字没有输出的
{
    for(int i = p +1;  i <= n; i++)//检查p的右边，即从p+1枚举
    {
        if(!mark[a[i]])//如果第i个数字也就是a[i]没有输出过
            return i;//返回p右边没有输出过的下标
    }
    return -1;//第p个数字右边没有“还没输出过的数字”

}
int main()
{
    ios::sync_with_stdio(false);
    scanf("%d", &n);
    for(int i = 1; i <= n; i++)
    {
        scanf("%d", &a[i]);
        pos[a[i]] = i;//记录数字a[i]出现在第几个位置
    }
 
    int temp; 
    for(int i = n; i>=1; i--)//从编号n开始直到1检查编号i是否可以输出
    {
        temp = check(pos[i]);//编号i的位置是pos[i]，检查pos[i]这个位置右边有没有还没有输出过的球的位置
        if(!mark[i] && temp != -1)//如果编号i没有输出且右边有可以和他输出的编号
        {
            
			printf("%d %d ", i, a[temp]);//输出编号i和他相邻的编号a[temp]
            mark[i] = 1;//标记编号已经输出i
            mark[a[temp]] = 1; //标记编号a[temp]已经输出
        }//if
    }//for

    printf("\n");
    //system("pause");
   
    
}
```


菜鸟第一次发题解，花了一个多钟，眼睛都疼，写的差不要喷。求管理大大通过