有趣的一道题

这道题刚拿到手的时候我还以为是一个环，但是重新审题后发现这是一条链。个人认为这道题链相对环来说稍微好做一点。

题目要求的字典序最大很明显是这题的关键。在这里很明显可以用到贪心，就是从大到小一个一个取。举个例子：

一开始数列长这样：

| 6 | 4 | 2 | 3 | 1 | 5 |
| -----------: | -----------: | -----------: | -----------: | -----------: | -----------: |

可以自己脑补出最终答案应该长这样：

| 6 | 4 | 3 | 1 | 2 | 5 |
| -----------: | -----------: | -----------: | -----------: | -----------: | -----------: |

到这里你可能会想：我从 $n$ 开始一直取到 $\frac {n} {2} + 1$ 不就可以了吗？

但是如果一开始数列长这样：

| 2 | 3 | 1 | 4 | 5 | 6 |
| -----------: | -----------: | -----------: | -----------: | -----------: | -----------: |

很明显， $6$ 是取不了了，如果先取 $5$ ，那 $4$ 也取不了了。

所以这题贪心的正确打开方式是每次取所有能取的数中的最大值。

但是你可能想问：每一次都查询，时间复杂度不就是 $O(n^2)$ 吗？

这时就应该想一想可行的优化了。

~~本蒟蒻的优化可能比较烂，大佬勿喷~~

我们可以定义一个数组 $f$ ， $f_i$ 代表 $i$ 在原数组中的位置。

加下来定义两个数组，每个数组的每一个元素都是一个指针，第一个数组的每个元素都是指向这个位置的在原数组中还没有被拿走的上一个元素的位置，第二个数组则是下一个。

然后我们再定义一个尾指针，指向数组中最末一个没有被拿走的元素的位置，每次判断尾指针要不要移动以及最大值是否在尾指针上。

好啦，废话不多说，直接上代码啦：

```cpp
#include <cstdio>

using namespace std;

const int MAXN = 100000;

int a[MAXN + 5], f[MAXN + 5], nxt[MAXN + 5][2];
bool b[MAXN + 5];
int main() {
	int n;
	scanf("%d", &n);
	for (int i = 1; i <= n; ++ i) {
		scanf("%d", &a[i]);
		f[a[i]] = i;
		if (i ^ n) {
			nxt[i][1] = i + 1;
		}
		if (i ^ 1) {
			nxt[i][0] = i - 1;
		}
	}
	int tail = n;
	int cnt = n;
	for (int i = n; i && cnt; -- i) {
		if (f[i] == tail || b[f[i]]) {
			continue;
		}
		if (nxt[f[i]][1] == tail) {
			tail = nxt[f[i]][0];
		}
		else {
			nxt[nxt[f[i]][0]][1] = nxt[nxt[f[i]][1]][1];
			nxt[nxt[nxt[f[i]][1]][1]][0] = nxt[f[i]][0];
		}
		b[f[i]] = b[nxt[f[i]][1]] = true;
		printf("%d %d ", i, a[nxt[f[i]][1]]);
		cnt -= 2;
	}
	return 0;
}
```