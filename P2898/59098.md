楼下老哥的并查集操作好是巧妙，但是并没有讲具体如何用并查集来

覆盖区间以至于我查了好多资料才搞明白。。。（也许是因为我⑨）

所以，在此将并查集实现这题的原理讲一讲。

---

有如下问题：

长为$n$的序列，开始均无颜色，

有$m$个操作，每次将$l$到$r$的数全染成$c$色，

求最终的序列。


我们考虑将染色反着来，则一个数若被染色一次，

则这就是它的最终颜色，不会改变。

所以下次若在遇到这个数则需要跳过，

也就是对已经染色的区间$[l,r]$，我们令其中的所有数都有一个指针，

以指向右边第一个还没有操作的数。

于是我们令$father[i]$表示$i$右边（包括$i$本身）第一个没有染色的数，

将$i$染色后，令$father[i] = find(i + 1)$,

之后就是正常的并查集操作了。

-----------------

然后这题是个特例，染色虽然是正着来的，但染的颜色全是一种，

只存在$0 - >1$，染一次则以后不变色，所以也可用这种方法做。