## 分析
有趣的找规律题目，我想不会有人用递归的办法去暴力破解吧？一拿到题，我当时就懵了，想了好久没有理出头绪来。后来觉得光靠空想根本不可能解决问题，便找来尘封已久的棋盘来摆了一下，结果豁然开朗。强烈建议您先别急着看解析，想办法摆一下棋盘，或着在坐标纸上画一下。这是个锻炼思维的好机会，直接看解析就很没意思了。

摆的方法是非常直接的，第一行直接摆在前面，下面每行在不于上面的行冲突（构成矩形）的情况下，尽量往前摆就可以了。下图是 $k=5$ 的情况：

![](https://cdn.luogu.com.cn/upload/image_hosting/jonrd6jf.png)

仔细看看，应该发现规律了吧。还没有？再看下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/5ynmv6d9.png)

从第 $6$ 行开始，以下每4行为一组，每组编号用 $i$ 表示，$i=(0, 1, 2, 3)$；每组中的 $4$ 行用 $j$ 表示，$j=(0, 1, 2, 3)$；每行中从第 $6$ 列开始，右边每 $4$ 列为一组，每组编号用 $s$ 表示，$s=(0, 1, 2, 3)$。这里用 $s$ 是为了避免和上面已经出现的 $k$ 产生混淆。

$(i, j, s)$ 为一个三元组，现在要求的就是$(0, 0, 0)$ 到 $(3, 3, 3)$，一共 $4 \times 4 \times 4=64$ 个值。$i=0$ 时，规律很明显，$(0, j, s)=5 + s \times (k - 1) + 1$。式中第一个 $5$ 是空出前面的 $5$ 个格，$s \times (k - 1)$ 计算当前 $4\times4$ 方块的起点，后面加 $1$ 是为了保证数字从 $1$ 开始，而不是$0$。

再看 $(1, 0, k)$ 到 $(2, 0, k)$，第一个 $4 \times 4$ 方块（橙色）和上面的（黄色）排列是一样的，只是第二个方块（蓝色）比上面的（青色）向右移动了一格。由此可推知公式：
$$(j + (s \times i)) \% m + s \times m + k + 1$$

再用下面的两排验证此公式，都成功。现在才明白为什么 $n=k2-k+1$，原来  $n=k+(k-1)(k-1)$，展开即得原式。
## 代码
```cpp
#include <iostream>
using namespace std;
int main() {
    //循环处理每一组输入
    for (int k, nFirst = 1; cin >> k; nFirst = 0) {
        //不是第一次输出时，前面要加空行
        if (nFirst == 0) {
            cout << endl;
        }
        int m = k - 1;
        //输出头部的k行
        for (int i = 0; i < k; ++i) {
            cout << 1;
            for (int j = 1; j < k; ++j) {
                cout << ' ' << i * m + j + 1;
            }
            cout << endl;
        }
        //以下算法请参照图示
        for (int i = 0; i < m; ++i) {
            for (int j = 0; j < m; ++j) {
                cout << i + 2;
                for (int s = 0; s < m; ++s) {
                    cout << ' ' << (j + (s * i)) % m + s * m + k + 1;
                }
                cout << endl;
            }
        }
    }
    return 0;
}
```