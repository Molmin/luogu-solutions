### 前言

这篇题解我是觉得，没啥希望过（因为优质题解已经很多了，而且我这个蒟蒻写的也一般般），所以只要是写给自己复习一下的（当然能过我更开心）

### 正题
其实这道题就是裸01背包  
so，我们先从普通的01背包二维做起：

我们很容易就知道，01背包的状态转移方程是这样的：

$$f[i][j]=max(f[i-1][j],f[i-1][j-w[i]]+c[i])(j>=w[i])$$

为什么呢？

想一想就明白，max内第一项是指不选这个物品，为这个重量的最大值  
而第二项是选这个物品，从$j-w[i]$这个重量加上当前重量$w[i]$的最大值加上本次选的物品的价值

听起来可能有点绕哈，多读几遍其实就懂了

那么，本次介绍的是一维数组（会的大佬请移步）

我们将$f$数组降成一维，还好写一点~~（什么玄学东西）~~

改进一下思路，如果我们以$f[j]$储存原来的$f[i][j]$，是否可行呢？

想想，原来我们的最大值是由$f[i-1][j],f[i-1][j-w[i]]+c[i]$两个状态中的最大值转移过来的，所以，这个问题就转化成，能否在求$f[i][j]$时就求出了上面两个状态的值？

其实是可以的，但有个细节，一维数组中j的扫描顺序应该从大到小(m到0)，否则前一次循环保存下来的值将会被修改，从而造成错误——变成♂$van$♂全背包

好了，方程推完了，接下来上代码：

```cpp
#include <cstdio>
using namespace std;
int f[10001],c[10001],w[10001],n,t;
int main()
{
	scanf("%d %d",&n,&t);
	for(int i=1;i<=t;i++)
		scanf("%d %d",&w[i],&c[i]);
	for(int i=1;i<=t;i++)
		for(int j=n;j>=w[i];j--)
			if(f[j]<f[j-w[i]]+c[i])
				f[j]=f[j-w[i]]+c[i];
	printf("%d",f[n]);
	return 0;
}
```