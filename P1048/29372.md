定义：
f[i][j]表示在前i个药物里拿出需要的总时间小于j的最大药物价值。

状态转移方程：

每一次可以拿走第i种药物(用去v的时间得到w的价值)

f[i][j-v]+w

也可以不拿(拿前i-1种药物最大价值)

f[i][j-v]+w

取两者的最大即

f[i][j]=max(f[i-1][j],f[i-1][j-v]+w)

降维：(对于这题可以省略)

既然每次转移的时候都是用f[i-1][...]。那么可以干脆直接在一个一维数组上直接做n次。这样就可以节省下1000\*(n-1)=99000个int的空间。

**但是在做的时候必须反过来做，否则后面的状态会根据f[i][...]的状态制作，而不是f[i-1][...]了**

*/
```cpp
#include<bits/stdc++.h>
using namespace std;
int T,n,v,f[1010],w;
int main(void){
    scanf("%d%d",&T,&n);
    for(int i=1;i<=n;i++){
        scanf("%d%d",&v,&w);        //由于f的定义合理，因此可以边读边做。
        for(int j=T;j>=v;j--)        //降维必须反过来做
            f[j]=max(f[j],f[j-v]+w);
    }
    printf("%d",f[T]);
    return 0;
}
```