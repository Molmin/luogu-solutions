通过这道题说一下我对动态规划的理解。
其实动态规划就是记忆化搜索， 首先我们把这道题当成搜索来做。

------------
# 题意
在一定时间内， 从n种价值和花费时间不同草药中， 选出价值最大的草药。
### 转移条件
花费时间小于当前时间
### 终止条件
搜索到第n+1种草药

```
void dfs(int i)
{
	if(i == m+1)
	{
		ans = max(ans, sum);
		return;
	}
	if(t >= c[i])
	{
		sum += w[i];
		t -= c[i];
		dfs(i+1);
		sum -= w[i];
		t += c[i];
	}
	dfs(i+1);
}

```






------------

# 优化一


我们发现这样的话耗时很长， 所以需要**剪枝**。 其实我们发现， 如果两次**搜索到 dfs(x) 时**， 如果**当前的 t 相同**的话， 后面的搜索**sum的增加量肯定是相同**的， 那么当前的 sum 大的那次搜索最终得到的sum肯定也是越大的。所以我们可以设一个数组dp[x][t], 保存搜索到dfs(x)时， 时间为 t 时 sum 的大小。 当后面搜索到这个状态的时候， 如果sum更大， 则更新sum， 继续搜索； 否则直接返回

```
void dfs(int i)
{
	if(i == m+1)
	{
		ans = max(ans, sum);
		return;
	}
	if(sum > dp[i][t])
	{
		dp[i][t] = sum;
	}
	else
		return;
		
	if(t >= c[i])
	{
		sum += w[i];
		t -= c[i];
		dfs(i+1);
		sum -= w[i];
		t += c[i];
	}
	dfs(i+1);
}
		
```





------------


# 优化二


这样的话， 就能省去很多时间了， 但是还可以优化。 因为我们发现， 在搜索到**dfs(x) 时**， **t相同**时， 后面**sum的增量是相同的**， 也就是说如果第二次搜索到这个状态的时候， 直接加上这个增量值就好了， 不用继续计算。 而这个增量也就是ans-当前sum,  所以dfs过程中**这个增量其实是已经计算出来过的**， 只是没有记录。 所以我们需要记录这个最大价值，那么我们就可以让 dfs 返回一个值，即 sum 的增量， 然后**把 dfs 看成求在 x 到最后一种草药选取的最大价值**。

**那怎么记录这个增量值呢？**

我们先看看这个增量值所代表的含义， 其实就是用 t 时间， 在第 x 种到最后一种草药种能获取的最大价值， 他其实也就等于采第 x 种草药和不采第 x 种草药的最大值。 所以我们可以通过递归来获取这个增量值。


------------


# **我们来最终整理一下思路：**
  
   最开始， 我们用最普通的搜索， 然后发现有很多重复运算， 那么想把这些重复运算给剪掉， 就需要设一个数组来保存前面运算得到的值。 最开始我们是保存搜索到一个位置时的价值， 后面再搜索到这个位置的时候， 我们就进行比较， 如果第二次搜索到这个位置时的价值较小， 就停止这次搜索（因为后面价值的增量最大值一定是相同的）， 如果价值较大， 则继续搜索。 然而我们又发现这样还是会重复运算， 因为搜索到一个位置的时候， 后面价值的增量一定是相同的， 那么我们干脆直接记录后面增量的值，就可以直接得到答案。 然后我们就通过递归的方式记录后面增量的值。这个就是记忆化搜索了， 那什么是动态规划呢， 其实就是把递归改成递推， 但本质是一样的。


------------
   
# 下面是代码
    
## 递归版
```
#include<bits/stdc++.h>
using namespace std;

int t, m;
int c[105]; //费用
int w[105]; //价值
int dp[105][1005];

int dfs(int i, int t) //用 t 时间从第 I 种到最后一种草药中能获得的最大价值  
{
	if(i == m+1)
	{
		return 0;
	}
	if(dp[i][t] != -1) //如果已经搜索过 
	{
		return dp[i][t];
	}
	
	int v;
	if(t >= c[i])
	{
		v = max( dfs(i+1, t-c[i]) + w[i], dfs(i+1, t) );
	}
	else
		v = dfs(i+1, t);
	dp[i][t] = v;
	
	return v;
}
 
int main()
{
	cin >> t >> m;
	for(int i = 1; i <= m; i++)
	{
		cin >> c[i] >> w[i];	
	}	
	memset(dp, -1, sizeof(dp));
	
	cout << dfs(1, t);
}
```
## 递推版
```
#include<bits/stdc++.h>
using namespace std;

int t, m;
int c[105]; //费用
int w[105]; //价值
int sum, ans;
int dp[105][1005];

 
int main()
{
	cin >> t >> m;
	for(int i = 1; i <= m; i++)
	{
		cin >> c[i] >> w[i];	
	}	
	memset(dp, 0, sizeof(dp));

	for(int i = m; i >= 1; i--) //也可以从1到m, 最后输出 dp[m][t]就好了
		for(int j = 0; j <= t; j++)
		{
			if(j >= c[i])
				dp[i][j] = max(dp[i+1][j], dp[i+1][j-c[i]]+w[i]);
			else
				dp[i][j] = dp[i+1][j];
		}
	cout << dp[1][t];
}
```

## 动态规划做题步骤
1. 找出**状态**
1. 找出**递归关系式**
1. 写出**递推方程**
## 什么样的题才是动态规划？
1.  多次搜索到dfs(x)时， t相等。 也就是**重叠子问题**。
1. 多次搜索到 dfs(x)时， t相等时， 后面的sum增量相同， 也就是**无后效性**。 

