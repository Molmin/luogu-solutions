### 这几乎是一道和01背包例题一模一样的水题！！！


动态规划是一种强大的计算模式，其解决问题的方式是首先定义一组子问题，按照从小问题解决大问题的模式，依次解决所有子问题并最终求解原问题。
所以我们来回顾一下

#### 步骤

第一步：确定子问题。 在这一步重点是分析那些变量是随着问题规模的变小而变小的， 那些变量与问题的规模无关。 

第二步：确定状态：根据上面找到的子问题来给你分割的子问题限定状态

第三步：推到出状态转移方程：这里要注意你的状态转移方程是不是满足所有的条件， 注意不要遗漏。 

第四步：确定边界条件：先根据题目的限制条件来确定题目中给出的边界条件是否能直接推导出， 如果不行也可以尝试从边界条件反推（举个例子：a(n)→a(2)有递推关系， 但是a(2)→a(1)不符合上述递推关系， 我们就可以考虑用a(1)来倒推出a(2)， 然后将递推的终点设置为a(2)）; 

第五步：确定实现方式：这个依照个人习惯 就像是01背包的两层for循环的顺序 

第六步：确定优化方法：很多时候你会发现走到这里步的时候你需要返回第1步重来。首先考虑降维问题（优化内存）， 优先队列、四边形不等式（优化时间）等等。



#### 几个背包的模板

1.无优化
```cpp
for(int i=1;i<=n;i++){  
	for(int j=1;j<=m1;j++){   
		if(j>=t[i]){
        f[i][j]=max(f[i-1][j-t[i]]+m[i],f[i-1][j]);
		}
		else{
			f[i][j]=f[i-1][j];
		}
	}
}
```
2.空间优化

```cpp
for(int i=1;i<=n;i++){  
	for(int j=m;j>=0;j--){  //--是为了防止叠加 
		if(j>=w[i]){  
		 	f[j]=max(f[j],f[j-w[i]]+c[i]);
		}	 
	}
}
```
3.常数优化
```cpp
for(int i=1;i<=n;i++){
    sum+=w[i];
    b=max(m-sum,w[i]);
    for(int j=m;j>=bound;j--){
		if(j>=w[i]){
  			f[j]=max(f[j],f[j-w[i]]+c[i]);
  		}
  	  }
}
```
4.完全背包

```
for(int i=1;i<=n;i++){  
		for(int j=0;j<=m;j++){  
			if(j>=w[i]){  
				f[j]=max(f[j],f[j-w[i]]+c[i]);
			}	 
		}
	}
```

### 回到正题
这道题吧，本蒟蒻认为用最简单的无优化版二维数组就可以，当然空间优化的也可以。

### 状态转移方程：
1.无优化版```cpp
f[i][j]=max(f[i-1][j-t[i]]+m[i],f[i-1][j]); ```

2.空间优化版
```cpp
f[j]=max(f[j],f[j-w[i]]+c[i]);
```

所以，上源代码。

1.最简单的
```cpp
int t[1001],m[101],f[1001][1001];  //t:时间  m:草药数量 
int main(){
	int m1,n;
	cin>>m1>>n;
	for(int i=1;i<=n;i++){
		cin>>t[i]>>m[i];
	} 
	for(int i=1;i<=n;i++){  //时间 
		for(int j=1;j<=m1;j++){  //数目 
			if(j>=t[i]){
				f[i][j]=max(f[i-1][j-t[i]]+m[i],f[i-1][j]);
			}
			else{
				f[i][j]=f[i-1][j];
			}
		}
	}
	cout<<f[n][m1];
	return 0;
}
```
2.比较难理解的空间优化版

```
int w[200],c[200],f[200];  //w:重量 ,c:价值 , f:最优解。 
int main(){
	int m,n;//m包的容量  n物品数量 
	cin>>m>>n;
	for(int i=1;i<=n;i++){
		cin>>w[i]>>c[i];
	}
	for(int i=1;i<=n;i++){  //循环物品 
		for(int j=m;j>=0;j--){  //循环容量,--是为了防止叠加 
			//判断当前物品是否可以放入包中
			if(j>=w[i]){   //能放进去的话就判断哪一种价值大 
				f[j]=max(f[j],f[j-w[i]]+c[i]);//状态转移方程 
			}	 
		}
	}
	cout<<f[m];
	return 0;
}
```

既然你已经读了这么长的文章了，就顺手点个赞吧！

想要看更多题解记得来[我的博客](https://252112.blog.luogu.org/)