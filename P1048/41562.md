弱鸡一个献出微薄的意见。

这是一道简单的背包题，100,1000的数据范围也不用背包优化，直接建立二维数组储存就行了；

大概思路就是：bag[i][j]表示在消耗j时间取前i颗药草最多可以获得的价值；

当j比i的时间小的时候，我们就从j-1份时间和上一轮的j时间取出较大的（这两个是已经处理过的最大值）；

当所用时间j可以取i的时候，就考虑之前的最大值[i][j-1]（如果不能同时取得i和之前的最大值所需要判断的情况）和[i-1][j-time[i]]+value[i](当前时间去除取i所花时间所能达到的最大值加上i的价值)

提供一组数据

————————————————————————————————————————————————————————————

IN:
100 5
77 92
22 22
29 87
50 46
99 90
OUT：
133
————————————————————————————————————————————————————————————

参考代码：（没有处理观感，请谅解）

————————————————————————————————————————————————————————————

    
```cpp
#include<cstdio>
#include<string>
#include<vector>
#include<iostream>
#include<algorithm>
using namespace std;
int bag[101][1001];
void r0()（先将背包化为0，不然第一行或每行第一个可能会出现5343138这种诡异的数字）
{
    int i,j;
    for(i=0;i<=100;i++)
    {
        for(j=0;j<=1000;j++)
        {
            bag[i][j]=0;
        }
    }
    return ;
}
int main()
{
    int t,m;
    int time[101],value[101];（打代码的应该看得懂英文吧，我就不翻译了）
    cin>>t>>m;
    for(int i=1;i<=m;i++)
        cin>>time[i]>>value[i];
    r0();
    for(int i=1;i<=m;i++)
    {
        for(int j=1;j<=t;j++)
        {
            bag[i][j]=max(bag[i-1][j],bag[i][j-1]);
            if(j>=time[i]) bag[i][j]=max(bag[i][j],bag[i-1][j-time[i]]+value[i]);
        }
    }
    printf("%d",bag[m][t]);
    return 0;
}
```