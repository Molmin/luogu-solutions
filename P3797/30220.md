安利博客<https://mk703.cn/%e6%b4%9b%e8%b0%b7%e5%a6%96%e6%a2%a6%e6%96%a9%e6%9c%a8%e6%a3%92%e9%a2%98%e8%a7%a3/>

说来惭愧，这道题居然用了一天才A。四肢无力，头脑昏沉，应该是已经步入老年时期。


好吧，这题搭眼一看sb线段树，但是评级好高。所以就要切这道题。信心满满写一发，WA，再来，又WA。最后写了暴力对拍，用了好长时间。


首先定义线段树节点：


1. num 在区间中有多少木棍

2. fr 在区间最后是否是“（”

3. en在区间首位是否是“）”


接下来开始推：肯定seg[i].num += seg[i << 1].num + seg[(i << 1) + 1].num。但是这样就对吗？？很显然不是因为我们还有fr和en没有用所以要判断seg[i << 1].fr 和 seg[(i << 1) + 1].en是否为真，真则num++。


又来活了，fr和en怎么推。好像这就是这题最难的地方辣。


以en为例有两种情况：


1.     seg[i]的en来自左儿子，则seg[i << 1].en == true

2. 否则，seg[i]的en来自右儿子，则右儿子seg[(i << 1) + 1].en == true 左儿子啥也没有全是“X” ——!seg[i << 1].fr && !seg[i << 1].num


同理推fr。


对于单点修改时也如此。


如何区间查询。好像这就是这题第二难的地方辣。


首先要定义end表示在上一次t选择时左边有没有多的“（”，fro表示在上一次s选择时右边有没有多的“）”。


这里fro和end的推法与上面类似就不再赘述。


最后是在s和t爬到停止的时候，要判断一下s所代表区间右端和t所代表区间左端是否是匹配。就是在循环外加

if(fro && end)ans++;
