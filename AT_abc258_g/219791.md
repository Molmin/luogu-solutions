

显然我们可以想到枚举 $i,j,k$ 然后判断是否可行，但是时间复杂度是 $O(n^3)$ 的，不可以被接受，考虑优化。

当我们枚举 $i, j$ 后，若一个 $k$ 满足要求，那么显然一定有 $(i, k)$ 和 $(j, k)$ 这两条边。

回到题目，可以发现在存在 $(i, j)$ 的情况下，我们只需要判断若 $A_{i, k} = A_{j, k} = 1$，那么这个 $k$ 就是可以的。 

不难发现只需要将第 $i$ 行与第 $j$ 行进行按位与运算，然后统计有多少个 $1$ 就可以了。

这个过程可以使用 `bitset` 进行，最后调用 `(A[i] & A[j]).count()` 即可。

具体细节见代码。

代码：*[37553455](https://atcoder.jp/contests/abc258/submissions/37553455)*。