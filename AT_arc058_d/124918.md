这道题很罕见地题解数达到了通过数的 $\frac{1}{5}$ 。

> 从 $n$ 个字符串中选出一些字符串，在不改变相对位置的情况下将其拼接起来，使其长度为 $k$ 。求字典序最小的方案。

对于每个长度 $i$ ，求出 $r_i$ 表示 **利用 $r_i+1$ 到 $n$ 的字符串能拼出长度为 $i$ 的最右位置**。即取了一些字符串后，想让剩下的字符串能拼出 $i$ 的最远位置。

这个部分我们用 bitset 求解。设 bitset $b_i$，$b_{i,j}=1$表示前 $i$ 个串拼起来的长度为 $j$ 时，用后面的串能拼到 $k$ 。初始值设 $b_{n,k}=1$，设第 $i$ 个串的长度为 $l_i$ ，那么 $b_i=b_{i+1}|(b_{i+1}<<l_i)$ 。如果 $b_{i,j}=0$ 且 $b_{i+1,j}=1$ ，那么 $r_j=i$。

考虑设 $f_i$ 为选取一些串，拼成长度为 $i$ 的串所能拼出的最小串， $g_i$ 为选取一些串，拼成长度为 $i$ 的串所能拼出的最小串的最右位置。

考虑 dp。枚举 $i$，枚举一个长度 $len$ ，在 $g_i+1$ 到 $n$ 中找出字典序最小的长度为 $len$ 的串，并用此更新 $f_{i+len}$。最后输出 $f_k$ 即可。

问题变成了求一个区间内长度相同的串中的最小串。枚举每个长度，对所有这个长度的串倍增 RMQ 预处理即可。

复杂度高，但常数较小，能过。至此本题全部完成。