给出 $n$ 个小写字符串 $s_{1\sim n}$，从中选出一个以字符串作为元素的子序列按顺序拼接，要求拼接出来的串长度恰为 $k$，求这些串里面字典序最小的，保证有解。

$n\leq 2000$，$k\leq 10^4$，$\sum |s_i|\leq 10^6$。

暴力 dp：$f_{i,j}$ 表示前 $i$ 个串，长度是 $j$ 的字典序最小的字符串，时空复杂度都不能接受。

挖掘性质：如果只保留能转移到 $(n,k)$ 的 $(i,j)$，固定 $i$，所有 $f_{i,j}$ 都是 $f_{i,j_{\max}}$ 的前缀。

于是先倒着背包出这样合法的 $(i,j)$，然后 $f_{i,*}$ 就只用记录一个母串（$f_{i,j_{\max}}$）以及 $g_{i,j}=0/1$ 表示当前状态是否合法，即能否转移出 $f_{i,j}$ 是 $f_{i,*}$ 的前缀。

考虑从 $i$ 到 $i+1$ 的转移，我们先找到所有 $g_{i,j}=1$ 的 $j$ 以及母串 $S=f_{i,*}$，$T=s_{i+1}$。把所有长度仍然合法的 $S[:j]$ 和 $S[:j]+T$ 先扔到 $i+1$ 的位置，考虑如何确定最终 $i+1$ 位置保留的母串以及 $j$。不难发现本质是在这些串中把字典序比自己严格大（真前缀关系忽略）的都丢掉，求最终留下了哪些。如果能快速比较串的大小，那么可以通过维护一个字典序的类单调栈（不优的可能不加入）来完成这部分。接下来的问题就是如何比较字典序，如果同时不加 $T$ 或同时加 $T$ 是容易的，否则形如 $S[:i]+T$ 和 $S[:j]$ 比较，满足 $i<j$，因为如果 $i\ge j$ 的话后者一定是前者的真前缀；那么相当于比较 $S[i+1:j]$ 与 $T$，只需要对 $T+S$ 做个 Z 函数就能 $O(1)$ 比较了。[代码](https://atcoder.jp/contests/arc058/submissions/40979110)细节比较多。