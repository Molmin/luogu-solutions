~~多次 WA 还不知道自己哪里错了~~

# 题意

你玩俄罗斯方块时手机坏了，现在你只能眼睁睁看着那个方块落下去。求方块落地时的影像。

# 思路

这个题就是一个简化版的俄罗斯方块。

对于一个大方块，我们知道当它的一个小方块落地后整个的大方块也就固定了。所以这道题可以通过找其中哪一个小方块先落地，再整体处理。

最接近地面的小方块一定最快落地（这里说的最近指的是竖直距离最近）。对于每一列，最快落地的小方块一定是这一列中纵坐标最小的那个（前提是这一列有方块），落地位置便是这一列中纵坐标最大的地面。所以我们可以枚举每一列，扫一遍找出这一列中纵坐标最小的小方块和纵坐标最大的地面，它们的竖直距离便是对于当前列的最快落地所需距离。

最后，我们再从每一列中找出这个距离的最小值，即整体最快落地的小方块即可。时间复杂度 $O(nm)$。

# 代码实现

先放完整代码，代码下方有讲解，如果理解了就可以跳过讲解了。

***

#### 完整代码

```
#include<bits/stdc++.h>
using namespace std;
const int N=3e3+10;
int n,m,fall=N;
char a[N][N],ans[N][N];
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++) scanf("%s",a[i]+1);
	for(int i=1,tx,ty;i<=m;i++)
	{
		for(tx=n;tx&&a[tx][i]^'X';tx--);
		for(ty=1;ty<=n&&a[ty][i]^'#';ty++);
		if(tx) fall=min(fall,ty-tx-1);
	}
	for(int i=1;i<=n;i++) for(int j=1;j<=m;j++)
	{
		if(a[i][j]^'#') ans[i][j]='.';
		else ans[i][j]='#';
	}
	for(int i=1;i<=n;i++) for(int j=1;j<=m;j++) if(a[i][j]=='X') ans[i+fall][j]='X';
	for(int i=1;i<=n;i++) printf("%s\n",ans[i]+1);
	return 0;
}
```

***

#### 代码讲解

~~其实也没什么好讲的~~

枚举 $1\sim m$ 每一列。对于当前列：从下往上找起，找到了小方块就退出，即保证找到的方块是最低的；从上往下找起，找到了地面就退出，即保证找到的地面是最高的。如果没有找到小方块，即代码中 $tx=0$，说明这一列不影响答案，不取这一列的值；如果找到了，这一列的落地距离便是找到的小方块和地面的距离，记得减一（代码中的 $ty-tx$ 是因为数组存储与实际平面相反）。

统计答案时，只需要改变每一个小方块纵坐标即可。与上面一样，也要注意数组存储与实际平面相反，当然如果嫌麻烦的话，输入时也可以倒着输入。

统计答案有两种方法（代码方法为方法一）：

1. 正着搜，需要重建一个 $ans$ 数组。如果用原来那个数组会出现数组被覆盖的情况。
2. 倒着搜，普通下标加法即可，这样可以保证一个方块落下去后，如果有另一个方块要补上来就不会被重复覆盖，比较方便。也贴上部分代码：

~~~
for(int i=n;i;i--) for(int j=m;j;j--)
{
	if(a[i][j]=='X') a[i+fall][j]='X',a[i][j]='.';
	else if(a[i][j]=='#') a[i][j]='#';
	else a[i][j]='.';
}
~~~

***

完结撒花owo。

