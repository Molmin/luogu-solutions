**题目：CF1203B**

题意很好理解，直接讲思路

思路：

因为要组成矩形，由于矩形对边相等，所以，先对所有木棍的长度从小到大排序

```cpp
cin>>n;
for(int i=1;i<=n*4;i++)
{
	cin>>a[i];
}
sort(a+1,a+4*n+1);
```
然后再for一遍，找有没有相邻的两根木棍长度不等，若有，则有一种长度的木棍只有一根

此时显然不能构成矩形，直接输出NO

```cpp
for(int i=1;i<=4*n;i+=2)
{
	if(a[i]!=a[i+1])
	{
		cout<<"NO"<<endl;
		goto flag;
	}
}
```
找完以后，我做了一步可有可无的操作：去重，这样可以方便后面的分析

```cpp
int kkk=0;
for(int i=1;i<=4*n;i+=2)
{
	a[++kkk]=a[i];
}
```
注意，此时，a数组里存的是所有矩形的可能边长

简单分析一下，要使矩形面积都相同，则要找出一种方法使$a[i]$两两成对，每对乘积相等

要使乘积相等，则较小的$a[i]$必须要和大的成对，所以，显然$a[1]$要和$a[kkk]$成对,$a[2]$要和a[kkk-1]成对

那么解法就很明显了，二分或者直接一遍for，找数组a两端元素乘积是否相等

```cpp
int temp=a[1]*a[kkk];
for(int i=2;i<=kkk/2;i++)
{
	if(a[i]*a[kkk+1-i]!=temp)
	{
		cout<<"NO"<<endl;
		goto flag;
	}
}
cout<<"YES"<<endl;
```
