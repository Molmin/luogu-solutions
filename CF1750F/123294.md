### [CF1750F Majority](https://www.luogu.com.cn/problem/CF1750F)

很棒的题目。

我们称合并两个极长 $1$ 段 $[a, b], [c, d] (a\leq b < c \leq d)$ 为操作 $(a, d)$。显然，它们可合并当且仅当 $(b - a + 1) + (d - c + 1) \geq (c - b - 1)$。

首先，如果我们操作 $(i, j)$ 且 $[i, j]$ 有三段 $1$，则至少存在一对相邻的段可以合并。设交替的 $1$ 段和 $0$ 段长分别为 $o_1, z_1, o_2, z_2, o_3$，假设 $o_1, o_2$ 不可合并，$o_2, o_3$ 不可合并，则 $z_1 > o_1 + o_2$，$z_2 > o_2 + o_3$，不等式同侧相加后两侧加上 $o_1 + o_2 + o_3$ 得 $2(o_1 + o_2 + o_3) + o_2$ 小于总长，与 $2(o_1 + o_2 + o_3)$ 不小于总长的限制矛盾。对于更多段 $1$，可以类似证明。

考虑一个串合法的充要条件。则它一定可以通过若干次合并相邻的 $1$ 段，使得最终全为 $1$。

直接对合法串计数，我们无法优秀地描述所有 $1$ 段合并的过程。

正难则反，考虑对非法串计数。这样有一个非常大的好处，就是对于非法串，在尽可能地合并后，总存在一个态，使得任意相邻两段 $1$ 均无法合并。每个无法继续合并的态对应的非法串数量，等于每个 $1$ 段长度对应的合法串数量之积，这是因为，我们需要合并得到每个极长 $1$ 段，相当于长度为该极长 $1$ 段长度的合法串数量。这就是子结构，启发我们进行 DP。

为了避免转移时较繁琐地化简不等式，我们可以这样刻画合并操作：将所有 $1$ 段向左向右延伸它的长度，此时若两个 $1$ 段相邻或重合，则它们可合并。

设 $f_i$ 表示 $n = i$ 的答案，则首先两端必须是 $1$，有 $2 ^ {i - 2}$ 种方案。再减去两端为 $1$ 段但非法的串的数量。

具体地，设 $g_{i, j}$ 表示长为 $i$ 的串，以 $1$ 段开头，合并完（此时任意相邻两端均不可合并）以长度为 $j$ 的 $1$ 段结尾的方案数。则 $f_i$ 需要减去所有 $g_{i, j}$。

若 $g_{i, j}$ 从 $g_{i', j'}$ 转移，因为前一个 $1$ 段向右延伸到 $i' + j'$，而当前 $1$ 段向左延伸到 $i - 2j + 1$，为避免它们相邻或重合，显然要有 $i' + j' + 1 < i - 2j + 1$。此外还有贡献系数 $f_{j}$。为此，设 $h_i$ 表示 $i' + j' + 1 \leq i$ 的 $g_{i', j'}$ 之和，即可做到 $\mathcal{O}(n ^ 2)$。

注意 $g_{i, i} = f_i$，且初始值 $f_1 = 1$。

```cpp
#include <bits/stdc++.h>
using namespace std;
using ull = unsigned long long;
using L = __uint128_t;
struct FastMod {
  ull b, m;
  FastMod(ull b): b(b), m(ull((L(1) << 64) / b)) {}
  ull R(ull a) {
    ull q = ull((L(a) * m) >> 64), r = a - q * b;
    return r >= b ? r - b : r;
  }
};
constexpr int N = 5e3 + 5;
int n, m, pw[N], f[N], h[N << 1];
void add(int &x, int y) {x += y, x >= m && (x -= m);}
int main() {
  cin >> n >> m;
  FastMod F(m);
  for(int i = pw[0] = 1; i < N; i++) pw[i] = F.R(pw[i - 1] + pw[i - 1]);
  f[1] = 1, h[3] = 1;
  for(int i = 2; i <= n; i++) {
    add(h[i], h[i - 1]), f[i] = pw[i - 2];
    for(int j = 1; j < i >> 1; j++) {
      int val = F.R(1ll * h[i - 2 * j] * f[j]);
      add(f[i], m - val), add(h[i + j + 1], val);
    };
    add(h[i * 2 + 1], f[i]);
  }
  cout << f[n] << "\n";
  return 0;
}
```