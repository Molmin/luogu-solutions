很好玩的 dp 题，自己想出来的话会很爽。

第一眼看这道题，每次操作选择的子串可能有多种，操作顺序也可能有多种，看起来很难直接计算合法的方案数。这时候必须冷静下来，思考一下其中的性质。

- 1. 合法串的 $s_1,s_n$ 为 $1$。这个很显然。


- 2. 我们任意一次操作选择一个子串 $[l,r]$ 时，一定可以调整左右端点保证 $s_{l-1},s_{r+1}=0$。

这是因为如果该串的边缘还有一些 $1$ 的话，我们把子串的区间往 $1$ 那边扩展一个位置，$1$ 的占比肯定更大，若原先区间合法，则新的区间也必然合法。


- 3. 设一个合法串的连续相同数字构成了 $2c+1$ 个连续段：$c+1$ 段 $1$ 和 $c$ 段 $0$（$c\geq 0$），我们每次操作一定可以只包含其中三段。采用反证法：

假如某次操作包含了 $2k+1$ 段，长度分别为 $l_1,l_2,\cdots l_{2k+1}$ 且 $k\geq 2$，则必然有 $l_1+l_3+\cdots +l_{2k+1}\geq l_2+l_4+\cdots l_{2k}$。假设其中的任意三段都不能操作，则 $l_1+l_3<l_2,l_3+l_5<l_4\cdots l_{2k-1}+l_{2k+1}<l_{2k}$。将左右两边分别求和得 $l_1+2l_3+\cdots +2l_{2k-1}+l_{2k+1}<l_2+l_4+\cdots l_{2k}$，与 $l_1+l_3+\cdots +l_{2k+1}\geq l_2+l_4+\cdots l_{2k}$ 矛盾。故命题得证。

- 4. 考虑一个非法串 $S$，其经过若干次操作后不为全 $1$ 且不能再进行任何操作，得到串 $T$，称其为最终串。则一个 $S$ 仅对应唯一一个最终串 $T$。

这是最关键的结论，但我不太会证明，可以感性理解一下？

在以下过程中，由于任何合法串的 $s_1$ 和 $s_n$ 都为 $1$，因此我们将只考虑所有满足 $s_1=s_n=1$ 的 $2^{n-2}$ 个串以便于计数。

正难则反。既然有很好的性质 $4$，那么我们不妨考虑求出不合法的串的数量，即所有最终串 $T$ 所对应的原始串的数量的总和。

有什么性质可以刻画这个最终串 $T$ 呢？设一个原始串 $S$ 有 $2c+1(c>0)$ 个连续段，长度分别为 $l_1,l_2,\cdots l_{2c+1}$，则 $l_1+l_3<l_2,l_3+l_5<l_4\cdots l_{2k-1}+l_{2k+1}<l_{2k}$ 是 $S$ 为最终串的充要条件。

- 设 $g_i$ 表示长度为 $i$ 的合法串的数量，初始值 $g_1=g_2=1$，我们需要求的是 $g_n$。

- 设 $f_{i,j,1}$ 表示长度为 $i$ 的，最后一段为 $j$ 个 $1$ 的非法串的数量；$f_{i,j,0}$ 表示长度为 $i$ 的，以若干个 $0$ 结尾的，最后一段 $0$ 的数量与最后一段 $1$ 的数量差值为 $j$ 的非法串的数量。注意状态的定义，必须满足 $j>0$。

根据状态的定义，有 $g_i+\sum_{j=1}^{i}f_{i,j,1}=2^{i-2}$（再强调一次，我们始终只考虑所有满足 $s_1=s_n=1$ 的串）。于是当我们算完所有 $f_{i,,1}$ 时，即可立刻得出 $g_i$。

考虑对 $f$ 的两种状态分别转移：

枚举之前的最后一段 $0$ 的数量减去最后一段 $1$ 的数量 $x$：

$$f_{i,j,1}=g_j\sum_{x=j+1}^{i}f_{i-j,x,0}$$

枚举最后加入的这一段的 $0$ 的数量 $x$，则之前的最后一段 $1$ 的数量为 $j-x$：

$$f_{i,j,0}=\sum_{x=j+1}^{i}f_{i-x,x-j,1}$$

第一种转移可以用后缀和优化；

第二种转移我们记 $p_{i}=\sum_{j=1}^{i-1}f_{j,i-j,1}$ 也可轻松完成。

列完转移方程后会发现在第二种转移中可能会遇到之前是整个一段全 $1$ 的情况，需要特判，这不好。所以我们不妨在计算完 $g_i$ 后，将 $i$ 个 $1$ 所构成的串也假设为一个最终串，即令 $f_{i,i,1}=g_i$，就不需要特判了。

时空复杂度均为 $O(n^2)$，注意初始化。

关键 code：

```cpp
int g[5005], f[5005][5005][2], n;
int p[10005], q[5005][5005];
void solve(){
	scanf("%d%d", &n, &mod);
	g[1] = g[2] = 1;
	f[1][1][1] = 1;
	f[2][2][1] = 1;
	p[2] = p[4] = 1;
	for(int i = 3; i <= n; ++i){
		for(int j = 1; j <= i - 2; ++j)
			f[i][j][0] = p[i - j];
		for(int j = 1; j <= i - 2; ++j)
			f[i][j][1] = mul(g[j], q[i - j][j + 1]);
		for(int j = 1; j <= i - 2; ++j)
			p[i + j] = add(p[i + j], f[i][j][1]);
		q[i][n + 1] = 0;
		for(int j = n; j >= 1; --j)
			q[i][j] = add(q[i][j + 1], f[i][j][0]);
		int tmp = 0;
		for(int j = 1; j <= i - 2; ++j)
			tmp = add(tmp, f[i][j][1]);
		g[i] = minus(Qpow(2, i - 2), tmp);
		f[i][i][1] = g[i];
		p[i + i] = add(p[i + i], f[i][i][1]);
	}
	printf("%d\n", g[n]);
	return ;
}
```

