这篇题解主要是来介绍知识点的。

主要是有向图中的DFS树和DFS森林。关于如何用DFS树证明只需要（最多）用两种颜色染色已经有题解证明过了，末尾可能会提一下。

在有向图从某个未进入过的点开始DFS时，会产生一个一个以该点为根的DFS“树”，这个树并不是严格意义上的树，因为它不仅有可能拥有超过n-1条边，而且可能出现环。树边，返祖边（前向边），横叉边，后向边是这棵树进行DFS时对具有不同性质的边进行分类时产生的概念。

树边的定义是：它是一条最平常的边，与普通树的边相类似（也就是，不指向一个兄弟，不指向一个祖先，不越级指向一个儿子）。

返祖边的定义是：从子孙节点指向祖先节点的边。

横叉边的定义是：指向兄弟节点，或其子树内的点的边。

后向边的定义是：指向一个子孙节点的边。（后向边确切定义其实不太重要，重要的是这些边的实现。）

《算法导论》中的实现包括：对于每个节点有一个编号vis[i]，其可能的值有0，1，2，分别对应“尚未被访问到”，“已经被访问到，但是其子树（儿子节点）尚未被访问完”，“已经被访问到，整棵子树都被访问完了”。对于一条边(u,v)，如果vis[v]==0，那么这条边是一条树边，显然的；如果vis[v]==1，那么说明，v在以u为根的子树内，这条边指向一个祖先节点，那么这条边是一条返祖边（前向边）；如果vis[v]==2，那么v已经在u的子树内了，这条边是一条后向边。

![](https://cdn.luogu.com.cn/upload/image_hosting/6vgjsjl5.png)

>树边和后向边有时可以互换，如图中3-7和1-7。

应用：一个有向图可以被划分为多棵DFS树组成的DFS森林（非严格意义，树之间仍然有可能相互指向），而其中的每一个环，它必然由至少一条的返祖边与至少一条的树边组成（在没有自环的情况下）并且，一个返祖边边至少被包含在一个环里面。一条边只会是这四种边中的一种，不会出现某一条边同时是树边还是返祖边，当然，互换不算。横叉边和后向边都不能组成一个环，也就是，横叉边和后向边不会被包含在任意一个环里面。

相比拓扑排序，用DFS树找环实现更加方便，代码更加简短，不容易出错。同时还可以实现环的遍历，后面会稍微提一下（有什么用啊）。

这样，如果能使所有的树边染同一个颜色，所有的返祖边染另一个颜色，由于一个环至少包含一个树边一个返祖边，则所有的环都不会是相同颜色的。横叉边和后向边随便染一个颜色，反正它们不在任何一个环里面，但是默认染和树边一样的颜色（树边肯定存在，但是返祖边不一定存在。）

对于一个节点保存其所有的父亲节点的信息，对于一个返祖边，从它的起始点开始回溯，有多个父亲节点的边就分叉，直到终点。

就这样咯。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,vis[5005],ans[5005];
vector<pair<int,int> >to[5005];
void dfs(int p){
    vis[p]=1;
    for(int i=0;i<to[p].size();i++){
        if(vis[to[p][i].first]==0){//树边为1.
            dfs(to[p][i].first);
            ans[to[p][i].second]=1;
        }else if(vis[to[p][i].first]==1){//返祖边和横叉边，后向边为2
            ans[to[p][i].second]=2;
        }else ans[to[p][i].second]=1;
    }
    vis[p]=2;
}
int main(){
    cin>>n>>m;
    for(int i=1,x,y;i<=m;i++){
        cin>>x>>y;
        to[x].push_back(make_pair(y,i));
    }
    for(int i=1;i<=n;i++)
        if(vis[i]==0)dfs(i);
    bool flag=0;
    for(int i=1;i<m;i++)
        if(ans[i]!=ans[i+1])
            flag=1;
    if(flag){
        cout<<"2\n";
        for(int i=1;i<=m;i++)
            cout<<ans[i]<<" ";
    }else {
        cout<<"1\n";
        for(int i=1;i<=m;i++)
            cout<<"1 ";
    }
}
```

I'm Schwarzkopf Henkal.