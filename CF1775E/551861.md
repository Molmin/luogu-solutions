**题目大意：** 给定一个长度为 $n$ 的序列 $a$，每次操作可以选出 $a$ 的任意一个非空子序列。可以使得该**子序列的所有奇数项加一，所有偶数项减一**；或者使得该子序列的所有奇数项**减一**，所有偶数项**加一**。求最少使用多少次操作，能使得 $a$ 中的元素全部变为 $0$。

### Solution

一道很好的妙题，较可惜的是结论比较好猜测。

方便起见，我们将奇数项加一，偶数项减一的操作叫做操作一；奇数项减一，偶数项加一的操作叫做操作二。

首先，对于一些很奇怪的数列操作，原序列不好维护的时候，可以转为前缀和或者差分来看性质。

这题目明显不是差分，在差分之后，整个差分序列为 $0$ 很显然不能告诉我们原序列也为 $0$。这提示我们**观察原序列的前缀和的性质。**

对第三个较强一点的样例，手玩一下，$[2,-4,3,-5,4,1]$ 的前缀和是 $[2,-2,1,-4,0,1]$。如果我们选取子序列为 $[2,-5,1]$ 进行操作一。会将前缀和变为 $[2,-2+1,3+1,-5,4,1+1]$。

观察一下，发现如果我们选取子序列 $[p_1,p_2,\dots,p_k]$ 进行操作一，假设子序列单调递增。则会导致 $[p_1,\,p_2-1]$ 的前缀和全部加上一；$[p_2,\,p_3-1]$ 被之前的加一抵消，不变；$[p_3,\,p_4-1]$ 的前缀和也全部加上一。换句话说，每次我们改变了 $\{[p_1,\,p_2-1],\,[p_3,\,p_4-1],\,[p_5,\,p_6-1],\,\dots\}$ 的前缀和，并将其全部加一。（若子序列长度为 $1$，则改变 $[p_1,\,n]$）

这意味着什么呢？我们**每次可以选取任意多个不相接的区间，并将区间内的前缀和加一。操作二同理，不过是将区间内的前缀和减一。**

那有什么用呢？这意味着我们每次可以选任意个数加一，或者任意个数减一。换句话说，我们将正数一直减到 $0$，将负数一直加到 $0$，最少的次数就是将前缀和全部变为 $0$ 的最小次数。

而前缀和序列的元素全部为 $0$，显然是 $a$ 的元素全部为 $0$ 的充要条件。 

那么问题就转化为在序列中每次任意选取一些数，将这些数同时加一，或者同时减一，求最少将序列元素全部变为 $0$ 的个数。

这就很简单了，假设 $a$ 中正数和负数都有。将正数全部变为 $0$，最少次数当然是 $|\max a|$。而将所有负数全部变为 $0$，最少次数也当然是 $-|\min a|$。将二者加起来就是答案。

如果不一定都有呢？那么最大值和最小值的极差就是答案了。

时间复杂度 $\Theta(n)$。

参考代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long int ll;
const int maxn = 2e5 + 10;
int t, n; ll a[maxn];
int main() {
    scanf("%d", &t);
    while (t--) {
        scanf("%d", &n); ll mi = 0, mx = 0;
        for (int i = 1; i <= n; i++)scanf("%lld", &a[i]), a[i] += a[i - 1];
        for (int i = 1; i <= n; i++)mi = min(mi, a[i]), mx = max(mx, a[i]);
        printf("%lld\n", mx - mi);
    }
    return 0;
}
```
