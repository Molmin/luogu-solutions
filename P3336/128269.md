考虑依靠 $x$ 对点进行排序，然后计算相邻两点之间的方案数。（以下叙述中，$(x1,y1)$ 为靠左点的坐标，$(x2,y2)$ 为靠右点的坐标）

因为这个函数只要向下走就会一直走到 x 轴，所以需要对上升到靠右点和下降到靠右点的情况分开考虑，以便下一个区间的技术。

令 $f[i][0]$ 表示符合前 $i+1$ 个点且上升直到第 $i+1$ 个点的方案数，$f[i][1]$ 表示符合前 $i+1$ 个点且下降直到第 $i+1$ 个点的方案数。

这时候就需要分类讨论了。

显然，当两点之间直线的斜率绝对值大于1时无解，斜率绝对值等于1时只能一直上升或下降，斜率绝对值小于1时需要反复上升下降。

先考虑最简单的一种，斜率绝对值等于1：

1. 当 $x1-x2=y1-y2$ 时，前面上升时可以继续上升或在 $y1=0$ 时，从下降变为上升。

$f[i+1][0]=f[i][0]+(a[i].y?0:f[i][1])$

2. 当 $x1-x2=y2-y1$ 时，前面上升或下降都可以变为下降。

$f[i+1][1]=f[i][1]+f[i][0]$


当斜率小于1时：

先考虑两点之间的函数能否接触一次 $x$ 轴。

这是一个小学数学题，设出刚好下降后上升时最低点纵坐标 $y$，可以解得 $y=(x1+y1+y2-x2)/2$。

当 $y>0$ 时，意味着下降后上升不能接触 $x$ 轴，也就意味着中间这段函数不能先下降后上升，所以只能下降到靠右的点，也只允许下降一次（只有一种方案）。


$f[i+1][1]=f[i][0]+(a[i].y?0:f[i][1])$

当 $y=0$ 时，刚好可以先下降到 $x$ 轴再上升（只有一种方案），当然也可以先上升后下降（只有一种方案）。

$f[i+1][0]=f[i][1]+f[i][0],f[i+1][1]=f[i][0]$

当 $y>0$ 时，过靠左点斜率为-1的直线和过靠右点斜率为1的直线与 $x$ 轴交点的距离显然为 $-2y$。这段距离就需要反复上升和下降来填补。

从 $f[i][1]$ 到 $f[i+1][0]$ 或 $f[i+1][1]$：

由于每次下降时，都会下降到 $x$ 轴，所以一定对应一段等长的上升，所以方案数就为向  $y$ 个球间（$-y-1$ 个空中）插入 $k$ 个板。（0<=k<=-y-1）。

即 $\sum_{i=0}^{-y-1} \binom{-y-1}{i}=2^{-y-1} $ 。

从 $f[i][0]$ 到 $f[i+1][0]$ 或 $f[i+1][1]$：

这里考虑最开始上升的情况，讲最开始上升和下降到处高度的一段放到最后去，就是开始讨论的那种情况，显然这两种情况是一一对应的，所以方案数为 $2*2^{-y-1}=2^{y}$。

注意只有 $y2$ 不等于0时才能更新 $f[i+1][0]$ 。

$f[i+1][0]=f[i][1]+2*f[i][0]*2^{-y-1}$
$f[i+1][1]=f[i][1]+2*f[i][0]*2^{-y-1}$

现在来做第二问，和之前求刚好下降后上升时最低点纵坐标时类似求出先下降后上升一次的最高点纵坐标。只有当可以下降到达靠右点时更新。

放代码：
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int mod=19940417,Maxn=1e6+5;
inline int read(){
	int s=0,w=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
	while(ch>='0'&&ch<='9')s=(s<<1)+(s<<3)+ch-'0',ch=getchar(); 
	return s*w;
}
struct node{
	int x,y;
}a[Maxn];	
bool operator<(node a,node b){return a.x<b.x;}
bool operator==(node a,node b){return a.x==b.x&&a.y==b.y;}
int n,k,f[Maxn][2],ans;
inline int power(int a,int b){
	int dat=1;
	for(;b;b>>=1){
		if(b&1)dat=dat*a%mod;
		a=a*a%mod;
	}
	return dat;
}
signed main(){
	n=read(),k=read();
	for(int i=1;i<=k;i++)a[i].x=read(),a[i].y=read();
	k++,a[k].x=0,a[k].y=0;
	k++,a[k].x=n,a[k].y=0;
	sort(a+1,a+k+1);
	k=unique(a+1,a+k+1)-a-1;
	f[1][1]=1;
	for(int i=1;i<k;i++){
		int w=(a[i+1].x-a[i].x-a[i+1].y-a[i].y)>>1;
		if(a[i+1].y-a[i].y==a[i+1].x-a[i].x)f[i+1][0]=(f[i][0]+(a[i].y?0:f[i][1]))%mod;
		else if(a[i+1].y-a[i].y==a[i].x-a[i+1].x)f[i+1][1]=(f[i][1]+f[i][0])%mod;
		else if(w<0)f[i+1][1]=(f[i][0]+(a[i].y?0:f[i][1]))%mod;
		else if(w==0)f[i+1][0]=(f[i][1]+f[i][0])%mod,f[i+1][1]=f[i][0];
		else{
			int p=power(2,w-1);
			if(a[i+1].y)f[i+1][0]=(f[i][1]+2*f[i][0])%mod*p%mod;
			f[i+1][1]=(f[i][1]+2*f[i][0])%mod*p%mod;
		}
		if(f[i+1][1]||a[i+1].y==0)ans=max(ans,(a[i+1].x-a[i].x+a[i].y+a[i+1].y)>>1);
	}
	printf("%lld %lld",f[k][1],ans);
	return 0;
}
```
