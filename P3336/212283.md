- Update：修整了一些内容。
- Update：修复了 LaTeX 不妥当的部分。

----------

有些好玩的一道题。

## 题意

给定 $k$ 个整点的函数值，问有多少个在 $[1,n]$ 中满足一定条件的函数，恰好都经过这些点。具体地，要求：

- 该函数的 **极小值** 均为 $0$。
- 该函数在任意两个相邻整点 $[i,i+1]$ 范围的斜率为 $a$，满足 $a\in\{1,-1\}$。

同时求这些函数中能够取得的最大的函数值是多少。

## 方案个数

实际上，极小值是 $0$ 意味着每次下降都必须到 $0$ 为止。

对于每一个遇到的给定整点时，我们都应该考虑当前行进的方向，且用 $0$ 表示向上，用 $1$ 表示向下，那么我们可以设计状态，令 $f(i,0)$ 表示在经过第 $i$ 个整点 $(x_i,y_i)$ 的时候向上，反之向下。

我们可以分类讨论。

从上一个整点 $(x_1,y_1)$ 到达现在的 $(x_2,y_2)$，一共会有多少种情况？

如果 $\Delta x=\Delta y$，那么我们一定只能按着唯一的方向才能走到，因此这时候有且只有一种选择（一条路走到黑），这种情况是显然的。但是如果这两者不相等，我们就需要再次去考虑其他的情况。


不妨设 $l=x_2-x_1-y_1-y_2$。如果 $l<0$ 的话，也就是说我们要先向上后向下，只有先向上后向下一种方案——因为如果不这样，我们向下走是走不到 $0$ 的。

反之，如果 $l>0$，实际上就相当于对于目前这一段路程，我们需要选择不同的分解方式，将其裂解为数段向下或向上的路径，方案数显然应该是 $2^{l-1}$。而对于前一点上升的方案来说，它还可以继续上升，选择其它位置斜率转为下降，因此在数组转移时前一个上升的方案要乘 $2$ 再赋值。

## 最大值

考虑贪心的思想，尽可能往上跑。

在这之后，我们会发现不存在方案的时候，我们可以令其为 $-\inf$ 这一最小值，尽可能上升的方法如果不成立，那么就要去考虑其他的情况，简单处理一下就好了。

## 代码实现

```cpp
#include<bits/stdc++.h> 
#define int long long
#define mod 19940417
#define N 1000005
using namespace std;
int ksm(int b,int p){
	int s=1;
	while(p){
		if(p&1)s=s*b%mod;
		b=b*b%mod;p>>=1;
	}return s;
}struct num{
	int x,y;
	bool operator <(const num &a)const{return x<a.x;}
	bool operator ==(const num &a)const{return a.x==x&&a.y==y;}
}a[N];
int n,k,ans,f[N][2];
signed main(){
	scanf("%lld%lld",&n,&k);
	for(int i=1;i<=k;++i)
		scanf("%lld%lld",&a[i].x,&a[i].y);
	a[k+1].x=0;a[++k].y=0;
	a[k+1].x=n;a[++k].y=0;
	sort(a+1,a+k+1);
	k=unique(a+1,a+k+1)-a-1;//去重后的有效元素个数  
	f[1][1]=1;
	for(int i=1;i<k;i++){
		int l=(a[i+1].x-a[i].x-a[i+1].y-a[i].y)>>1;
		if(a[i+1].y-a[i].y==a[i].x-a[i+1].x)
			f[i+1][1]=(f[i][1]+f[i][0])%mod;
		else if(a[i+1].y-a[i].y==a[i+1].x-a[i].x)
			f[i+1][0]=(f[i][0]+(a[i].y?0:f[i][1]))%mod;
		else if(l<0)
			f[i+1][1]=f[i][0];
		else if(!l){
			f[i+1][0]=(f[i][1]+f[i][0])%mod;
			f[i+1][1]=f[i][0];
		}else{
			int g=ksm(2,l-1);
			if(a[i+1].y)f[i+1][0]=(f[i][1]+(f[i][0]<<1))*g%mod;
			f[i+1][1]=(f[i][1]+(f[i][0]<<1))*g%mod;
		}
		if((f[i+1][1]||!a[i+1].y)&&(f[i][0]||!a[i].y))
			ans=max(ans,(a[i+1].x+a[i+1].y-a[i].x+a[i].y)>>1);
	}printf("%lld %lld\n",f[k][1],ans);
	return 0;
}
```