其实这道题理解了逻辑思路,就可以写出来了。


------------

其实这道题理5先,题目中要求我们使所有的线段都不相交,而且在圆上有2n个不同的点。这就涉及到一个知识叫卡特兰数。卡特数大概就是这个形式：
$C_{n+1}=C_0C_n+C_1C_{n-1}+......+C_nC_0$


------------

设$h(n)$为卡特兰数的第$n+1$项，令$h(0)=1,h(1)=1$，卡特兰数满足递推式：

$h(n)= h(0)h(n-1)+h(1)h(n-2) + ... + h(n-1)h(0)$

**但前提是$(n>=2)$**。

例如：$h(2)=h(0)*h(1)+h(1)*h(0)=1*1+1*1=2$
$h(3)=h(0)*h(2)+h(1)*h(1)+h(2)*h(0)=1*2+1*1+2*1=5$

卡特兰数的前几项是$1, 1, 2, 5, 14, 42, 132, 429, 1430, 4862, 16796, 58786, 208012, 742900, 2674440, 9694845, 35357670, 129644790, 477638700, 1767263190, 6564120420, 24466267020, 91482563640, 343059613650, 1289904147324, 4861946401452, ...$

发现他们$mod100000007$后正好与题目相符。
所以，这道题马上就解出来了。


------------
$AC$代码：
```
#include<bits/stdc++.h>//万能头文件
using namespace std;
int main()
{   ios::sync_with_stdio(false);//黑科技加速
   cin.tie(0);
   cout.tie(0);
	int n;
	long long a[3005]={1,1};//前提是(n>=2)，且第一项和第二项都为1
	cin>>n;
	for(register int i=2;i<=n;i++)//因为有众多两项乘积之和，所以用两次，register为加速和科技
	{for(register int j=0;j<i;j++)
			a[i]+=a[j]*a[i-j-1];//运用卡特兰数递推式
		a[i]%=100000007;//这里要先mod，要不然的话只能得60分
	}
	cout<<a[n];//输出第n项
	return 0;
}
```
完美结束，谢谢大家！
