## 题目及算法分析
这题，打开一看，呦，这不 $01$ 背包板子题嘛，几天不见，难度都到绿了！

然而，仔细看这个神奇的数据范围 $n,m \le 10^5 $ ，好家伙，这还真不能用 $O(nm)$ 的01背包了，所以我们考虑其他算法。

想了一圈，这就是个 $01$ 背包问题，于是糊涂地又读了读数据范围，嘿！ $ 0 ≤a_i ,b_i ≤ 10 $ ，我们就可以想到，有很多很多个男仆的属性是一样的，嗯......这不就是多重背包嘛！

想到这里，这道题就变成了一个多重背包的「模板题」而可以轻松解决，那么，如何解决一个多重背包？

有很多多重背包的解决方法，这里我们使用二进制优化的方法，它速度快、好理解且代码量少。

### 具体做法分析
我们可以用一个二维数组 $A_{ij}$ 存储一个质量是 $i$ 且战斗力是 $j$ 的男丁的数量，在之后用一个数组 $a_i$ 作为多重背包的标准数据（ $a_i$ 并不是一个单纯的一维数组，应是一个 $pair$ 或二维等能存下两个数值的数组），可以用 $A_{ij}$ 求出 $a_i$ 的每一个值。注意， $i$ 和 $j$ 的值是从 $0$ 到 $10$ ，一定要防止忽视了质量为 $0$ 的男丁，在循环 $i$ 和 $j$ 时从0开始就可以避免。

在求 $a_i$ 时，可以直接把多重背包的优化带上，多重背包的二进制优化请参考 [hnjzsyjyj的多重背包问题（二进制优化）](https://blog.csdn.net/hnjzsyjyj/article/details/109363826)
，主体思路就是将物品的数量分为 $1,2^1,2^2,2^3...sum-2^k$ ，如果大佬您会多重背包，那这道题的难度便会瞬间降低。

### 代码及其分析
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 3e6;
int n, m, k, A[20][20], a[N][3], nn, b, c, d, f[N], ans, ma;
int main(){
	memset(f, -1, sizeof(f));
	f[0] = 0;
	scanf("%d%d%d", &n, &m, &k);
	for(int i = 1; i <= n; i ++){
		int aa, bb;
		scanf("%d%d", &aa, &bb);
		A[aa][bb] ++;
		ma += bb;
	}
	for(int i = 0; i <= 10; i ++){
		for(int j = 1; j <= 10; j ++){
			c = A[i][j];	//c是数量，b是战斗力，d是质量 
			b = j;
			d = i;
			for(int k = 1; 1; k *= 2){
				if(c <= k){
					a[++ nn][1] = c * b;	//1是战斗力，2是质量 
					a[nn][2] = c * d;
					break;
				}
				else{
					a[++ nn][1] = k * b, a[nn][2] = k * d;
					c -= k;
				}
			}
		}
	}
	n = nn;
	for(int i = 1; i <= n; i ++){
		for(int j = m; j >= a[i][2]; j --){
			if(f[j - a[i][2]] != -1)
			f[j] = max(f[j], f[j - a[i][2]] + a[i][1]);
		}
	}
	for(int i = 1; i <= m; i ++){
		if(f[i] != -1)
		ans = max(ans, f[i]);
	}
	if(ans >= k)
	printf("yes\n");
	else
	printf("no\n");
	printf("%d", ans);
	return 0;
}
```
~~此代码仅供参考，因为它仅能供参考~~

忽视作者神奇的码风，此代码还是很好理解的。