### 题意：

给你 $n$ 个物品，质量和价值分别为 $a_i,b_i$，求大小为 $m$ 的背包能承载的物品最大总价值能否超过 $k$，并输出总价值。

$1\le n,m\le 10^5,0\le a_i,b_i\le10$。

### 解法：

- **第一部分：直觉**

  一眼看过去，这是一个比较普通的背包问题。
  
  我们可以按照一般的思路，开一个动态规划数组，通过 $\mathcal O(nm)$ 时间复杂度求出每个背包质量对应的最大价值。
  
  最后便可求出求大小为 $m$ 的背包能承载的物品最大总价值。这里不再过多赘述。
  
  于是，高高兴兴提交去，惶惶恐恐 TLE 来。
  
  ![](https://s4.ax1x.com/2021/12/25/TUNEJH.gif)
  
- **第二部分：三思**

  TLE 之后的我完全不知道为什么，直到我翻到数据范围：$1\le n,m\le 10^5$。显然，$\mathcal O(nm)$ 算法会被卡出加了 `Sleep` 之感。
  
  不过，我们发现 $a_i$ 和 $b_i$ 都很小，这可能成为我们的突破点。
  
  考虑开一个桶，`b[x][y]` 记录质量为 $x$，价值 $y$ 的数量。这样我们要做的由 01 背包变为多重背包。
  
  哎，多重背包可以二进制优化（即将 $x$ 个物品拆成 $\log x+1$ 个，使这些物品能够拼凑成 $1\sim m$ 个原物品的质量和价值，详见代码）。于是物品数量由 $n$ 变为 $\log n$ 多一点。
  
  由此，时间复杂度变为 $\mathcal O(m\log n)$，可以通过本题。
  
  ```cpp
  namespace{
	  const int lim=1e5+2;
	  int n,m,k,cnt[11][11],ans,f[lim];
	  struct node{
		  int a,b;
	  };
	  vector<node> b;
	  void work(){
		  n=read();m=read();k=read();
		  F(i,1,<=n){
			  Int x=read(),y=read();
			  ++cnt[x][y];//记录质量为 x，价值为 y 的物品个数
		  }
		  F(i,0,<=10){//如果质量为 0，血赚
			  F(j,1,<=10){//如果价值为 0，加进背包也没用，直接不枚举
				  if(!cnt[i][j]) continue;
				  Int s=1;
				  while(s<cnt[i][j]){
					  b.push_back({s*i,s*j});//加入一个物品
					  cnt[i][j]-=s;//减少物品数量
					  s<<=1;//拆成 2 的整数次幂
				  }
				  b.push_back({i*cnt[i][j],j*cnt[i][j]});//最后剩下的独立成为一个物品
			  }
		  }
		  F(i,0,<b.size()){//经典 01 背包
			  R(j,m,>=b[i].a){
				  f[j]=max(f[j],f[j-b[i].a]+b[i].b);
			  }
		  }
		  puts(f[m]>=k?"yes":"no");
		  put("%d",f[m]);
	  }
  }
```