[题目传送门](https://www.luogu.com.cn/problem/SP3409)

[原 OJ 传送门](https://www.spoj.com/problems/SAMER08E/)

[本题双倍经验](https://www.luogu.com.cn/problem/UVA12148)

由于[ SPOJ 的测评机制](https://www.luogu.com.cn/discuss/590681)，请各位使用 c++98 语言在洛谷上提交代码。

---

是一道简单模拟。本题主要考察各位对于年、月、日的掌握。

题目各位都能看懂，我们来讲一讲如何来判断是否为“相邻的两天”。

首先，如果年月相同，且日期正好相差一天，则满足相邻。

又或者是，如果年相同，月不相同，但是这两个月相邻，且上一天正好是一个月的月底，这一天又是下一个月的一号时，也满足相邻。

但在这里如何表述“月底”呢？我们可以先打一个包含 $12$ 个月每个月的日期的表：

```cpp
int a[13]={0,31,28,31,30,31,30,31,31,30,31,30,31};
```

然后直接判断天数是否等于其对应月份的天数即可。不过这里还需注意判断闰年，如果是闰年就将 $a_2$ 赋值为 $29$。

但如果年也不同呢？那就只有一种情况，年份相邻，且两天分别为 $12.31$ 和 $1.1$。同上判断即可。

综上所述，一共有三种情况（可以归为两种），其他情况则一律不统计。我们再来总结一下这三种情况：

- 年月相同，日期正好相差一天。

- 两月相邻，上一天是一个月的月底，这一天是下一个月的一号。

- 年份相邻，且两天分别为 $12.31$ 和 $1.1$。

最后，由于要看“上一天”和“这一天”，所以循环统计答案的变量 $i$ 取值应为 $2\sim n$。且注意，每次循环后，$a_2$ 要复原回 $28$。

题解很长，但代码似乎很好理解。

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[13]={0,31,28,31,30,31,30,31,31,30,31,30,31};
int d[1001],m[1001],y[1001],c[1001];
inline bool chk(int x)
{
	if(y[x]==y[x-1])
	{
		if((y[x]%4==0&&y[x]%100!=0)||(y[x]%400==0))
		{
			a[2]=29;
		}
		if(m[x]==m[x-1]&&d[x]-d[x-1]==1)
		{
			return 1;
		}
		else if(m[x]-m[x-1]==1&&d[x-1]==a[m[x-1]]&&d[x]==1)
		{
			return 1;
		}
		else
		{
			return 0;
		}
	}
	else if(y[x]-y[x-1]==1&&m[x-1]==12&&d[x-1]==31&&m[x]==1&&d[x]==1)
	{
		return 1;
	}
	else
	{
		return 0;
	}
}
int main()
{
	int n;
	while(cin>>n&&n!=0)
	{
		for(int i=1;i<=n;i++)
		{
			cin>>d[i]>>m[i]>>y[i]>>c[i];
		}
		int cnt=0,ans=0;
		for(int i=2;i<=n;i++)
		{
			if(chk(i)) // 传入下标
			{
				cnt++;
				ans+=(c[i]-c[i-1]); 
			}
			a[2]=28;
		}
		cout<<cnt<<" "<<ans<<endl;
	}
    return 0;
}
```