一看到三个操作。。。诶？！什么数据结构。。打上一波线段树，嗯，修改，嗯，查询。。原地爆炸，查询甚至比暴力查询还慢。凉凉（也许是我的智商不够高吧）。

还是先老老实实看部分分怎么做。当然，这很简单————模拟，用一个n^2的数组存一下图，对于操作1和2，每次O(1)进行修改，对于操作3，每次用O(n^2)进行查询。显然这个时间复杂度。。可能30分都拿不了。

还是想正解吧，（这也许是一道考思维的题（脑筋急转弯？！））。在不断的草稿和手算的时候，我们发现：

1.在i!=j的情况下，a[i][j]+a[j][i]和a[j][i]+a[i][j]都会被记录到，也就是说((a[i][j]×a[j][i])+(a[j][i]×a[i][j]))%2==0，对答案毫无影响。

2.在i==j的情况下，a[i][j]+a[j][i]就是a[j][i]+a[i][j]，而且只会记录一次，所以a[i][j]×a[j][i]%2对答案的影响即为a[i][j]本身。（注意只有0/1两种状态就好想了）

对于两个修改操作，不管是改行还是列，都只对对角线的一个元素造成影响（就是0变1,1变0）。

下面上代码：（对0/1的转换，我用的是+1%2）

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,Q,t;
int ans;
int a,b;
int main()
{
	cin>>n>>Q;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
		{
			cin>>t;
			if(i==j)
			{
				ans+=t;
				ans%=2;
			}
		}
	while(Q--)
	{
		cin>>a;
		if(a==1||a==2)
		{
			cin>>b;
			ans+=1;
			ans%=2;
		}
		else
			cout<<ans;
	}
	return 0;
}
```