[Fish](https://www.luogu.com.cn/problem/CF16E)

可以去看我整理的[学习笔记](https://www.luogu.com.cn/blog/140643/zhuang-ya-dp-xue-xi-bi-ji)鸭~

**题意简述**：有 $n$ 条鱼，编号从 $1$ 到 $n$。每对鱼相遇的概率是一样的。如果两条标号为 $i$ 和 $j$ 的鱼见面，第一只吃了第二只的概率为 $p[i][j]$，则第二只吃掉第一只的概率为 $1 - p[i][j]$。求每只鱼最后存活在湖里的可能性。

**思路**：

概率 + 状压 $dp$


先看题目范围，明显**状压**，因为题目求每只鱼最后存活的状态，所以把鱼的存活状态压进状态里，因此定义 $dp[i]$ 为出现 $i$ 的局面时的概率（第 $i$ 位为 $0$ 表示第 $i$ 条鱼**死亡**，反之为**存活**）

- 因为顺序递推会因为概率的不确定因素影响结果，所以考虑逆推。

- 先枚举整体状态 $i$，在确定该轮被吃的鱼的编号 $j$，判断是否满足已经被吃的条件(即状态中第 $j$ 位为 $0$)

- 满足上条件后，再枚举吃掉 $j$ 的鱼的编号 $k$，判断是否满足依然存在的条件（即状态中第 $k$ 位为 $1$）

因为任意两条鱼之间的存活概率已经得知，然后任意在存活中的鱼里选择两条鱼的概率为 $(cnt +１) * cnt / 2 $。($cnt$ 为 $i$ 状态下 $1$ 的数量)，因为是倒退，所以前一状态下，鱼 $j$ 是活着的，因此实在 $cnt + 1$ 条雨中选两条鱼。

就可以得出递推式，$i$ 状态的概率加（即前一状态的概率） $*$ （$k$ 吃掉 $j$ 的概率）$*$ (选出 $j$、$k$ 的概率)

所以：
$$ 

dp[i] += dp[i | (1 << (j - 1))] * p[k][j] / (1.0 * (cnt + 1) * cnt / 2.0);
$$

其他讲解都在代码里啦~

**完整代码**：

```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
int n;
double p[25][25],dp[1 << 20];//dp[i],出现i状态的概率（1:这条鱼活着/0:它被吃啦） 
int c(int x) {//计算1的个数 
	int res = 0;
	while(x) {
		res += (x & 1);
		x >>= 1;
	}
	return res;
}
int main() {
	scanf("%d",&n);
	for(int i = 1; i <= n; i ++)
		for(int j = 1; j <= n; j ++)
			scanf("%lf",&p[i][j]);
	int num = (1 << n) - 1;
	dp[num] = 1;//初始状态，全部鱼都活着的概率为1
	for(int i = num - 1; i; i --) {//倒序枚举状态，鱼越吃越少，1的数量也越来越少……这残忍的现实！ 
		int cnt = c(i);//活着的鱼的数量 
		for(int j = 1; j <= n; j ++) {//枚举这一轮被吃到的鱼的序号 
			if((i & (1 << (j - 1)))) continue;//如果在当前状态下，j为1（鱼没有被吃了），跳过
			for(int k = 1; k <= n; k ++) {//枚举k条鱼吃掉的鱼的编号 
				if(!(i & (1 << (k - 1)))) continue;//如果在当前状态下，k为0（鱼已经被吃了,k吃不到j），跳过
				dp[i] += dp[i | (1 << (j - 1))] * p[k][j] / (1.0 * (cnt + 1) * cnt / 2.0);
				//否则，概率为 当前概率 加上 j位存活时的概率 * k条鱼吃掉j条鱼的概率 * 在所有活着的鱼中恰好选到j,k的概率。 
			}
		}
	}
	for(int i = 0; i < n; i ++) printf("%.6lf ",dp[1 << i]);//只有当前位为1的状态 
	return 0;
}
```

