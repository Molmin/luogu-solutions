一道披着数论题外衣的DP题

我们首先可以想到一个三次方的暴力DP，用dp[i][j]表示数列最后两个位置分别是i，j时的方案数，每次去枚举dp[k][i]，判断公差是否相等进行转移

那么怎么进行优化呢？

可以看出，复杂度的主要瓶颈在于我们枚举了dp[k][i]，进行了O(n)的转移，因此我们可以对这里进行优化

出题人在这里给了提示：v<=20000，因此我们就有了这样一个思路：用v[i][j]表示在第i个位置，它上一个与它的差为j时的方案数，这样就可以O(1)转移，总复杂度是二次方

但是这个只能处理三座塔以上的情况（两座塔的情况真恶心。。。），由于任意一座或两座都肯定成立，所以我们只要在最后加上一座和两座的情况就可以了
```cpp
#include<iostream>
using namespace std;
int const M=20000;
long long dp[1010][1010],v[1010][40010],h[1010];
int main()
{
	int n,i,j;
	long long ans=0;
	cin>>n;
	for(i=1;i<=n;i++)
	 cin>>h[i];
	for(i=1;i<=n;i++)
	 {
	 	for(j=i-1;j>0;j--)
	 	 {
	 	  dp[i][j]=(dp[i][j]+v[j][h[i]-h[j]+M])%998244353;
		  v[i][h[i]-h[j]+M]=(v[i][h[i]-h[j]+M]+v[j][h[i]-h[j]+M]+1)%998244353;
	 	 }	
	 }
	for(i=1;i<=n;i++)
	  for(j=1;j<=i;j++)
	    {
	    	ans+=dp[i][j];
	    	ans%=998244353;
	 	}
	cout<<(ans+(n*n+n)/2)%998244353;
	return 0;
}
```