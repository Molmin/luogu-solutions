一道动态规划，我的时间复杂度是$O(n^2)$，比楼上略优，但是空间复杂度为$O(nv)$。  

首先看数据范围，$n \leq 1000$，显然是$O(n^2)$。$v \leq 20,000 \; +$ 空间限制 $512 \text{MB}$ 在提醒我们可以考虑把等差数列的方差放到状态里面（不难发现无论是一维$O(n)$还是两维$O(n^2)$都难以进行状态转移）。  

接着想如何状态转移。设$f_{i,j}$表示公差为$i$，以数列第$j$位**结尾**的等差数列的数量。则状态转移如下：  
$$f_{a_{\tiny i}-a_{\tiny j}, i} = \begin{cases} \sum f_{a_i-a_j, j} + 1 & i > 1 \\ 0 & i=1\end{cases} \large , \; j \in [1, i)$$  
注：$i>1$求和时要$+1$是为了包含两个元素组成的序列。  
最后的答案就是 $\sum_{i=1}^n(1 + \sum_{j=-v}^v f_{j,i})$。  
$+1$同样是因为动态规划时没有包含单元素数列的情况。  

最后是代码实现。为了方便，我们用$v[i]$存储$\sum_{j=-v}^v f[j][i]$：  
```cpp
    for (int i = 2; i <= n; ++i)
    for (int j = 1; j <  i; ++j)
        f[a[i] - a[j]][i] += f[a[i] - a[j]][j] + 1,
        f[a[i] - a[j]][i] %= mod,
        v[i] += f[a[i] - a[j]][j] + 1,
        v[i] %= mod;
```
同样地，为了方便，$f$实际上是一个行指针，指向存储状态的数组的正中间以避免公差为负数带来的影响。  
```cpp
long long __f[40005][1005];
long long (*f)[1005] = __f + 20003;
```