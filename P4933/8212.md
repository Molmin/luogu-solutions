### Prelude

比较简单的DP题，考察选手的基本DP能力，和合理枚举能力。

大概是D1T2的难度。

idea：ljt12138

造数据：__stdcall

---

### 30 pts

$n \le 20$

暴力分。

首先你要读懂题，题目的意思是，给你一个数组，求出有多少个非空子序列是等差数列。

所以可以用$O(2^n)$枚举一个子序列，再用$O(n)$判断她是不是等差数列。

总复杂度$O(2^n * n)$。

---

### 60 pts

$n \le 100, v \le 2000$

从这里开始就需要DP了。

我们观察到值域很小，这提示我们把和值域相关的量记入状态表示。

用$f(i,j)$表示以位置i结尾，公差为j的等差数列有多少个。转移的时候，枚举一个小于i的k，满足$h_k = h_i - j$，然后从$f(k,j)$转移到$f(i,j)$。

注意，公差可以是负数，因此这里的j也可以是负数。

转移的时候要小心，不要重复或者遗漏某些情况。

复杂度$O(n^2k)$。

---

### 80 pts

$n \le 1000, v \le 20000$

整个数组是一个等差数列。

在公差不为0的时候，任何几个相邻相隔k个位置的数字都可以组成一个等差数列。

这时候，我们只要枚举首项的位置和k，就可以很轻松地计算出答案。

注意，在公差等于0，也就是所有数字都相等的时候，答案是$2^n-1$，这一点需要特判，否则你会WA掉第13个点。

---

### 100 pts

$n \le 1000, v \le 20000$

考虑在60分的算法基础上继续优化。

我们可以把这个算法简化为，枚举一个公差d，然后统计有多少个公差为d的等差数列。

枚举公差的时间复杂度是$O(v)$，观察数据范围可以猜测，统计的时间复杂度是$O(n)$，总复杂度是$O(nv)$。

我们考虑60分的那个$O(n^2)$的DP，用到这个统计上来，用$f(i)$表示以i结尾的，公差为d的等差数列有多少个，转移的时候枚举一个小于i的k，然后当$h_k = h_i - d$的时候从$f(k)$转移到$f(i)$。

状态已经不可能再简化了，但是转移可以。

我们发现，转移相当于一个求和，对小于i的所有高度等于$h_i - d$的位置的DP值求和。

我们可以维护一个数组g来记录这个和，这样转移就只有两行了。

$f(i) = g(h_i - d)$

$g(h_i) = g(h_i) + f(i)$

总复杂度是$O(nv)$。
