这是本蒟蒻第三十一次写的题解，如有错误点请好心指出！

## 问题简述

给定一个包含 $n$ 个点和 $m$ 条边的无向图，每个点的颜色要么是黑色，要么是白色。你可以选择一个点作为起点出发，沿着边走到下一个不同颜色的点，并且改变走之前的那个点的颜色。问在走的过程中是否存在一个起点，出发后还会回到这个点。

## 解法综述

首先我们要在图上找到一个环，因为如果我们要从点 $u$ 走到点 $v$，必须先满足这两点的颜色不同，而走了之后要改变点 $u$ 的颜色，此时这两点的颜色相同，也就意味着我们走了之后就不能往回走，只能通过走环来回到起点。

其次，假设这个环存在一条合法路径，那么这条路径一开始两端的颜色一定相同，因为在走的过程中起点的颜色会被改变，此时路径两端的颜色就不同了，也就意味着我们可以从一端走到另一端了。而且这条路径一开始相邻两点的颜色一定不同，因为我们要保证走到的下一个点必须是不同颜色的点。

于是我们可以在图中找出相邻的且颜色相同的两个点，看它们能否成为一条合法路径的两端。

## 代码描述
```cpp
#include<cstdio>
int n,m,nxt[400005],to[400005],h[200005],cnt;
int a[200005],b[200005],c[200005];
bool bz[200005],bj;//数组bz用来判环，防止被卡死
void add(int x,int y)
{
	nxt[++cnt]=h[x];
	to[cnt]=y;
	h[x]=cnt;
}
void dfs(int x,int fa,int y)
{
	if(x==y||bj)//如果存在两个点能成为一条合法路径的两端
	{
		bj=1;
		return;
	}
	for(int i=h[x];i;i=nxt[i])
	if(to[i]!=fa&&!bz[to[i]]&&c[x]!=c[to[i]])//要求这条路径中相邻两点的颜色不同
	{
		bz[to[i]]=1;
		dfs(to[i],x,y);//遍历该路径
		bz[to[i]]=0;
	}
}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=m;i++)
	{
		scanf("%d%d",&a[i],&b[i]);
		add(a[i],b[i]);add(b[i],a[i]);//建图
	}
	for(int i=1;i<=n;i++) scanf("%d",&c[i]);
	for(int i=1;i<=m;i++)
	{
		if(c[a[i]]==c[b[i]]&&!bz[a[i]]&&!bz[b[i]])//找出相邻的且颜色相同的两个点
		{
			bz[a[i]]=1;
			dfs(a[i],b[i],b[i]);//看它们能否成为一条合法路径的两端
			bz[a[i]]=0;
		}
		if(bj)//如果存在两个点能成为一条合法路径的两端
		{
			printf("Yes");
			return 0;
		}
	}
	printf("No");
	return 0;
}
```