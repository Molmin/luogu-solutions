很容易可以想到把字符串当作一个${p}$进制数，
每次在最后以为加${1}$，再判断回文，
如果没有就输出，如果最高位溢出就一定不存在解。

------------

出现新的回文串只有${2}$种可能：

1、长度为${2}$的回文串，即当前位与它的前一位或后一位相等（${str[i]=str[i-1]}$或${str[i]=str[i+1]}$）。

2、长度为${3}$的回文串，即当前为与它前面的第二位或后面的第二位相等。（${str[i]=str[i-2]}$或${str[i]=str[i+2]}$）。

因为原串中不含长度为${2}$或长度${>2}$的回文串，
而长度${>3}$的回文串中心一定有一个长度大于${1}$的回文串，
所以不需要判断长度更长的回文串是否存在

------------

很显然如此优秀的暴力是很难通过的。。。

------------

如果某一位不符合要求（即与其它位构成了回文串），
那么就可以直接修改这一位，
如果还是每次在最末一位${+1}$，
除非进位修改了这一位，
那当前串一定不符合要求。

为了让下一次循环可以修改这一位，
可以把这一位后面的所有位都置为最大值（即${'a'+p-1}$），
这样下一次就可以通过进位直接处理不符合要求的字符

------------

**代码**

```cpp
#include<bits/stdc++.h>
using namespace std;
char str[1001];
int n,p;
int main()
{
	scanf("%d%d",&n,&p);
	scanf("%s",str+1);//从第一位开始输入
	bool ans=0; 
	register int i,j;
	while(1)
	{
		j=n;
		str[j]++;
		while(j>1&&str[j]>='a'+p)//进位
		{
			str[j]-=p;
			str[--j]++;
		}
		if(j==1&&str[j]>='a'+p)//如果最高位溢出
		{
			ans=0;//标记
			break;
		}
		bool f=0;
		for(i=j;i<=n;i++)
		{
			if(i>2&&str[i]==str[i-2])//长度为3的回文串
			{
				f=1;
				break;
			}
			if(i>1&&str[i]==str[i-1])//长度为2的回文串
			{
				f=1;
				break;
			}
		}
		if(f)//如果不符合要求
		{
			for(j=i+1;j<=n;j++)//赋予最大值
			{
				str[j]='a'+p-1;
			}
		}
		else
		{
			ans=1;//符合要求就退出
			break;
		}
	}
	if(ans==0)//没有解输出NO
	printf("NO\n");
	else
	printf("%s\n",str+1);
	return 0;
}
```
~~又是恶评题~~