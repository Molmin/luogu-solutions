### 前言

这道题目真的是绿的吗。。。

我怎么那么不信呀！

### 分析

这道题目实际上就是问你一个，完全竞赛图是什么？

完全竞赛图是一种有向边完全图，就是说，每个点之间都会有一个有向边。

当然，如果你说这道题目就是问你完全竞赛图少了哪条边，那是不对的！

如果你好好阅读了英文的题面，就会发现，实际上这个图是可以间接比出他们两个的能力值。

举个例子吧！

就比如说：
```
1 <- 2 

2 <- 3

4 -> 3

4 -> 2

3 -> 1
```
箭头后面的那个人是偏弱的人。

我们可以间接的发现 `4 -> 1`。

那么为什么呢？

~~这个自己推一下不就好了吗？~~

我们可以发现某种神奇的规律：

就是说，如果一个点的出度大于另一个点的出度那么一个点就比另一个点要强！

那么这又是为什么呢？

就假设，这个是一张缺了一条边的完全竞赛图，那么如果说点 $a$ 的出度为 $2$ ，点 $b$ 出度为 $1$ 。

那么我们可以发现，必定点 $a$ 是至少存在一个点比点 $b$ 强！

如果说，一个点被点 $b$ 给对掉了，就像下面这种情况：

```
a -> c
b -> c
```

那么点 $a$ ，还是存在着一条边间接的可以大于点 $b$ 的！

因为点 $b$ 不存在着另一条出度可以对掉！

哦，对了，如果说点 $b$ 间接大于了 点 $a$ ，那么就会产生矛盾的形式！

所以规律也就得出了！

**如果说一个点的出度大于另一个点那么这个点就是要先输出，那个点其次输出**。

如果等于呢？

~~那就随便输出呀，反正 CF 有 SPJ！~~

还是从小到大输出吧，保险一点！

### 代码

代码真的没有什么好看的了 。。。。

```
#include <iostream>
#include <cstdio>
using namespace std;
const int INF=55;
int n,vis[INF];
bool Map[INF][INF];
signed main()
{
	scanf("%d",&n);
	int m=n*(n-1)/2-1;//计算边数。
	for (int i=1;i<=m;i++) {
		int x=0,y=0;
		scanf("%d %d",&x,&y);
		Map[x][y]=Map[y][x]=1;//防止有某种玄学的情况出现。
		vis[x]++;//统计出度。
	}
	for (int i=1;i<=n;i++)
		for (int j=i+1;j<=n;j++) {
			if (!Map[i][j]) {//如果没有比较过。
				if (vis[i]>vis[j]) printf("%d %d\n",i,j);//如果大于那么先输出大于的那个点。
				else printf("%d %d\n",j,i);//否则输出另一个大于的点。
				return 0;
			}
		} 
	return 0;
}//提交同样的代码会 UKE！
```

### 写在后面的话

我这篇题解如果有错误请在评论区指出，我将非常感谢指出的人！

**谢谢观赏！**