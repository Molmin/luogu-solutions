憨批题



------------
首先我们知道，这个图是一个完全图对吧，所以他的边数显然就是 $n * (n - 1) / 2$ ，每一个点连 $n - 1$ 条边。

然后我第一次交的时候就判断，看看哪两个点的度数小于 $n - 1$ 。

但这是错的

嗯其实这个竞赛图呢，就是说给完全图的每一条边标了方向

完全竞赛图呢，网上找不到任何资料。我个人的理解就是完全竞赛图是一个有向完全图，且图中每一个点入度都不一样。

然后就发现这道题可以说是很憨了，建议大家回去再想想，毕竟数据范围 50 。

我们按入度排个序，如果入度相同出度大的往前排（想一想，如果不这么干会会怎么样），每次判断出度加入度（也就是边数）是不是等于 $n - 1$ 。不等于时查看当前点的入度是不是按 $0$ 到 $n - 1$ 排列的。如果是把点加入有向边的起点，否则加入终点。

看起来很麻烦，但复杂度就是排序的复杂度，为 $O(nlog(n))$ 目前 (2021/11/19) 最优解，开 O2 能更快

如果看不明白可以看代码

```cpp
#include<bits/stdc++.h>
using namespace std;
struct node{
    int chu, ru, id;
}p[55];
int n;
bool cmp(node u, node v){
    return u.ru < v.ru || (u.ru == v.ru && (u.ru + u.chu == n - 1));//不会找到终点时将他归到起点的位置
}
int id[55];
int main(){
    scanf("%d", &n);
    int u, v;
    for(int i = 1;i < n * (n - 1) / 2;i ++){
        scanf("%d%d", &u, &v);
        p[u].ru ++;
        p[v].chu ++;
    }
    for(int i = 1;i <= n;i ++)
        p[i].id = i;
    sort(p + 1, p + n + 1, cmp);
    for(int i = 1;i <= n;i ++){
        if(p[i].chu + p[i].ru != n - 1){
            if(p[i].ru != i - 1)
                u = p[i].id;
            else
                v = p[i].id;
        }
    }
    cout << u << ' ' << v << endl;
    return 0;
}
```
