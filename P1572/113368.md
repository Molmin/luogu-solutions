字符串大模拟纯暴力写法QAQ
废话不多说
## 思路：
### ①既然要把这些分数加起来就要判断好分母分子。
在这里我们把所有数存入一个专门的数组，输入格式已经确定，那就是
 ### 数字---‘/’---数字---‘+或-’。
 我们把所有相连的数字看为一个编号，‘+或-’所对应的编号一定是3+4*n（n>=0）（从0开始编号）计算是只需计算‘+或-’前面两个数字串和后面两个数字串所组成的分数即可。
### ②分数计算要通分。
我采用的计算方法是 （分子1×分母2+分子2×分母1）/（分母1×分母2），也是最直接的计算方法，最后分子分母在同时除以公因数即可。
### ③判负很关键。
因为两个分数计算后不一定是正的，所以要判断好负号出现的情况。
### ④整数输出。
如果一个分数的分母==1，那么直接输出分子就好了。（在分数化简完全的情况下）
## 附AC代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
char a[101];
int b[101],num,num1;
int gcd(int x,int y)
{
	return y==0?x:gcd(y,x%y);
}// 求最大公因数。
int ans=1;
int main()
{
	cin>>a;
	int lena=strlen(a);
	for(int i=0;i<lena;i++)
	{
		if(a[i]>='0'&&a[i]<='9')
		{
			b[num]=b[num]*10+a[i]-'0';
		}
		else num++;
	}// 把数字全都剥离开来，存放入一个新的数组中。
	for(int i=0;i<lena;i++)
	{
		if(a[i]=='+')
		{
			int p=2*num1;// ‘+’号和‘-’号一定出现在每四个数字的中间位置。
			num1++;
			b[p+2]=b[p]*b[p+3]*ans+b[p+2]*b[p+1];
			b[p+3]*=b[p+1];
            	// （分子1*分母2+分子2*分母1）/（分母1*分母2）,计算方法。 
			if(b[p+2]<0) ans=-1,b[p+2]*=-1;
			else ans=1;// 判负条件。
			int k=gcd(b[p+3],b[p+2]);
			while(k!=1)
			{
				b[p+3]/=k;b[p+2]/=k;
				k=gcd(b[p+3],b[p+2]);
			}
			
		}
		if(a[i]=='-')
		{
			int p=2*num1;
			num1++;
			b[p+2]=b[p]*b[p+3]*ans-b[p+2]*b[p+1];
			b[p+3]*=b[p+1];
			if(b[p+2]<0) ans=-1,b[p+2]*=-1;
			else ans=1;
			int k=gcd(b[p+3],b[p+2]);
			while(k!=1)
			{
				b[p+3]/=k;b[p+2]/=k;
				k=gcd(b[p+3],b[p+2]);
			}
		}
	}
	if(ans==-1) cout<<'-';// 如果最终结果是负的，要先输出一个‘-’号。
	int k=gcd(b[2*num1],b[2*num1+1]);
	b[2*num1]/=k;b[2*num1+1]/=k;
	cout<<b[2*num1];
	if(b[2*num1+1]!=1) cout<<'/'<<b[2*num1+1];// 判断是否为整数输出。
	return 0;
}// AC！！
```