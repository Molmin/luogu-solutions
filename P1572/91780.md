
这道题表面上是一道普及/提高-的题目，实际上，它估计也就普及-的难度，至于它为什么会被洛谷评为这样的难度，估计是因为它的坑点实在是太多、太多、太多了！！！（重要的事情说三遍，不为什么，只因为我经历了一个30-50-70-90-100的过程，也许是我太菜了吧……）

粗粗地看了看题解，发现有用字符串，也有用循环读入的，这两种其实本质上都一样，要用通分的方法，所以就无所谓了，这里我用的是循环读入，感觉可能代码好懂一些。

在看代码之前，我们先来看看这题有哪些坑点：
#### 1
~~这题要输出分数，所以不能用小数，而要运用小学通分大法~~（废话）
#### 2
题目中说只会输入最简分数，但是，分子分母不一定是个位数，所以要处理（这点可以当作屁话，觉得也没有谁会在这里栽跟头）。
#### 3
题目要求输出是整数或最简分数。也就是说，最后要判断一下，算完之后不仅要约分，而且约分之后，可能是整数。
#### 4
众所周知，分数的分母不能是负数，所以，还要判断。


然后再看看代码，也许会更有所帮助。

#### 代码带注释：
```
#include<bits/stdc++.h>
using namespace std;
int a[1005],b[1005];  //a，b用来储存每个分子分母。 
char d;
int gcd(int a,int  b)  //最大公约数递归实现。 
{
	if (a%b==0)
		return b;
	else
		return gcd(b,a%b);
}
int main()
{
	int x=1,cnt=0,sum=0,t=0,flag=1;  
	//x用来保存所有分母的最小公倍数。 
	//cnt用来保存分数个数。
	//sum用来保存通分完所有分子之和。
	//t用来保存分子或分母。
	//flag用来记录这个分数是正是负。 
	while (cin>>d)  //这里是循环读入的方法。 
	{
		if (d>='0' && d<='9')
			t=t*10+d-'0';
		if (d=='/')  //分子读完了，存一下，接着去读分母。 
			a[++cnt]=t*flag,t=0;
		if (d=='+')  //存分母。 
			b[cnt]=t,t=0,flag=1;
		if (d=='-')  //负数判断一下，用flag改变下个分数符号。 
			b[cnt]=t,t=0,flag=-1;
	}
	b[cnt]=t;  //最后一个分数是a/b的格式，后面没有加号或减号，所以还得再存下分母。 
	for (int i=1;i<=cnt;++i)
		x=x*b[i]/gcd(x,b[i]);  
	//众所周知，最小公倍数LCM（a，b）=a*b/GCD（a，b）（小学知识）。
	//LCM为最小公倍数，GCD为最大公约数。 
	for (int i=1;i<=cnt;++i)
		a[i]*=x/b[i],sum+=a[i];
	//通分计算过程（分子分母同时乘以一个非0自然数，分数大小不变。小学知识）。 
	int z=gcd(sum,x);  //最终结果分子分母的最大公约数。 
	int m=sum/z,n=x/z;  //最后的约分。 
	if (n<0)  //判断分母为负数的情况。 
		m=-m,n=-n;
	if (m%n==0)  //判断结果为整数的情况。 
		cout<<m/n<<endl;
	else
		cout<<m<<"/"<<n<<endl;
	return 0;
}
```

本蒟蒻知道的就这么多了，由于才识疏浅错了很多次，希望大家引以为戒。