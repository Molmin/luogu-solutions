听说有大佬用宽搜切了这一题，我在此深表敬意。

## 题意：
给你一个 $n$ 位的锁的初始状态和目标状态， 问：最少需要转动多少下才能成为目标状态。

## 思路：
开始看的时候感觉很像江苏 $2017$ 小学信息与未来里的一题。

我们可以分为两种情况讨论。

1. 正着转

这样的话是最好思考的，总结出规律：从数字 $x$ 转到数字 $y$ 会转 $|x-y|$ 次。

2. 反着转

根据前面的规律，可以推出这种情况的规律：从数字 $x$ 转到数字 $y$ 会转 $10-|x-y|$ 次。

最后模拟比个小即可 AC 。

### 注意事项：

1. 比较时要用 abs/fabs 。
2. 输入时要用 string/char 数组 读入。

## CODE：
```
#include<bits/stdc++.h>
using namespace std;

int n,m,i,j,k,t,ans[205];
char s[103],s1[103];

int main()
{
	cin >> t; 
	for(k=1;k<=t;k++)
	{
		int sum=0;
		cin >> n >> s >> s1;
		for(i=0;i<n;i++)
		{
			sum+=min(abs(a[i]-b[i]),10-abs(a[i]-b[i]));//两种方法比小，注意abs 
		}
		ans[k]=sum;
	}
	for(k=1;k<=t;k++)
	{
		printf("Case %d: %d\n",k,ans[k]);
	}
	return 0;
}
//没提交，不知道对不对，不过思路应该对的
```
比较简洁，球管理通过。