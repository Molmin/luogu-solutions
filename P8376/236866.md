给一个比较简单的随机化做法，与现有两篇题解都不同，没证出正确性

---

核心思想是二进制拆分，从小到大加数

记 $n=\log k$。考虑一个 $2n$ 的做法:

1. 初始有 $n$ 的递增数列
2. 如果 $k-2^{n}$ 的第 $i$ 位为 $1$，就在第 $i$ 位后加入一个数（前面的数都比新加的数小因此恰好贡献 $2^i$）

冷静一下发现这个做法实际上是 $n+\text{popcount}(k)$ 的，题目要求的长度为 $90=\frac{3}{2}n$，因此 $\text{popcount}$ 只能有 $\frac{1}{2}n$。随机情况下是恰好能过的，考虑打乱 $k$ 的二进制表示

第一步的作用主要是为第二步提供足够多的数（显然第二步中 $i<n$），而贡献 $2^n$ 只是顺带的。可以考虑在第一步后 `shuffle` 数列的前缀，$\text{popcount}(k-\text{现有上升子序列数})$ 期望只有 $\frac{1}{2}n$  
此时第二步不能直接构造（放到第 $i$ 位后不一定贡献 $2^i$），新加入数贪心往后放即可  
时间复杂度 $O(q\text{ poly }n)$，根据调参可以得到 $[97,100]$ pts

现场选手没拿到代码就不放了，很好写但还是懒得再写一遍了

> Cyber_Tree: 我能用 < 1KB 写完，赌不赌？