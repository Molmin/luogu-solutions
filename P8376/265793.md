# P8376 [APIO2022] 排列
## 题目大意

寻找一个长度为 $n$ 的数列，数列是 $0,1,\dots,n-1$ 的一个排列，使它的递增子序列数恰好是 $k$。注意 **$n$ 并没有给定**，因此本题还要求在得到数列的同时使其长度 $n$ 最小。

## 前置引入

1. 当一个数列 $p[0],p[1],\dots,p[n-1]$ 正好是顺序的时，它有着所有由 $n$ 个元素组成的数列中最多的递增子序列数量，数量为 $2^n$。

   至于为什么是最多，感觉一下就知道了。

   $Eg:$ 对于数列 $0,1,2,3$，它的递增子序列有：

   	1. $(Empty)$ **是的空串也是递增子序列**
   	1. $[0],[1],[2],[3]$
   	1. $[0,1],[0,2],[0,3],[1,2],[1,3],[2,3]$
   	1. $[0,1,2],[0,1,3],[0,2,3],[1,2,3]$
   	1. $[0,1,2,3]$

   共 $2^4=16$ 个

2. 一个长度为 $n$ 的顺序数列的递增子序列的个数为 $2^n$ 的本质是：

   在该数列中，每个数都有 **选择被递增子序列包括** 与 **选择不被递增子序列包括** 两个选项，根据排列组合的乘法原理，$n$ 个 $2$ 相乘即为 $2^n$。

##  题解

### 正解思路的根基：91分做法

我们首先把 $k$ 化为二进制，在这里以 $k=(21)_{10}$ 为例

因此 $k=(10101)_2=2^4+2^2+2^0$

根据前置引入，我们**希望将 $k$ 用多个顺序数列整合在一起处理掉**

这里以上述 $k=21$ 为例，具体这样做：

1. 为了处理掉 $2^4$，我们先列开一个长度为 $4$ 的顺序数列：

   $$[1,2,3,4]$$

2. 接下来我们想处理掉 $2^2$，这时我们在数列的第二个数后面加上数字 $5$：

   $[1,2,5,3,4]$

   这样，尽管 $[1,2,3,4]$ 被隔开，但仍有 $2^4$ 个递增子序列，而 $[1,2,5]$ 又担起了提供 $2^2$ 个递增子序列的责任。

   可是，明明 $[1,2,5]$ 有三个数，为什么不是提供 $2^3$ 个而是 $2^2$ 个递增子序列呢？

   因为在 $[1,2,5]$ 中，$5$ **必须被包括在递增子序列中**，否则去掉 $5$ 后，$[1,2]$ 的取值和 $[1,2,3,4]$ 是重复的。

3. 处理 $2^0$ 的方法与处理 $2^2$ 一致，不再赘述。

上面所述的操作可以被画成一个图，如下：

![](https://cdn.luogu.com.cn/upload/image_hosting/kluw02b6.png)

这样做的信息复杂度是 $O(\log k)$ ，这已经是本题最优级别的复杂度了（因为 $n$ 个元素的数列最多有 $2^n$ 个递增子序列；反之，想要得到 $k$ 个 递增子序列，至少需要 $\lceil\log_2 k\rceil$ 个元素）。但是该做法常数太大：

$\log_2 10^{18}\approx60$，根据题目，$n$ 要在 $90$ 之内，这意味着信息复杂度的常数最大只能是 $1.5$。当前做法在类似于 $k=(11111111\dots111)_2$ 的情况下信息复杂度 $\approx \log_2k+\log_2k=2\log_2k$，常数为 $2$，超了。

至于为什么，画一个和上一张图类似的图就明白了（这里以 $k=(111111)_2$ 为例）

![](https://cdn.luogu.com.cn/upload/image_hosting/zg99a60q.png)

二倍常数的罪魁祸首就是，由于 $k$ 在二进制下每一位都是 $1$，为此需要为除了第一个 $1$ 的所有 $1$ 都新增一个数。而刚好 $k$ 又有 $\log_2k$ 个二进制位，常数就多了 $1$。

### 正解

于是，顺理成章地，正解就成了**卡常**



![](https://cdn.luogu.com.cn/upload/image_hosting/ydh8h7h5.png)

仍以 $k=(111111)_2$ 为例。维护两个值，$MAX$ 和 $SECONDMAX$，分别指向当前数列中最大数和次大数的位置。

**仍是从后往前处理**

后三个 $1$ 仍按照老方法处理，这样做的目的是 用为了维护第 $5,4$ 个 $1$ 而新建的点维护 $MAX$ 和 $SECONDMAX$（处理最后一个 $1$ 时不需要额外增加数）。

前面的 $1$，**如果存在有两个 $1$ 连续**，则将这两个 $1$ 以一组处理。

具体处理方法是：如上面例子的第 $2,3$ 个 $1$，它们分别代表着 $2^1$ 和 $2^2$ 个递增子序列。先将 $MAX$ 和 $SECONDMAX$ 处的数增加 $1$，然后在第一个数后面插入一个 比 $MAX$ 和 $SECONDMAX$ 处小，比其他值大的（即第三大的）数。

这样就产生了个新的子数列：$[0,5,7]$ 和 $[0,5,6]$。其中 $5$ 必须在递增子序列里，$6,7$ 在不在皆可，$0$ 以及 $0$ 前面的数（如果在其他情况下有的话）则负责产生贡献。

因此，产生递增子序列现在去三个情况分类讨论：

1. 递增子序列中取 $6$
2. 递增子序列中取 $7$
3. 递增子序列中既不取 $6$ 也不取 $7$

而 $0$ 以及 $0$ 前面的数（如果在其他情况下有的话），即产生贡献的部分处在全部三个情况中。这样，在这里就能产生 $3*2^0=2^0+2*2^0=2^0+2^1$ 的贡献。

更一般的，对于两个连续的，分别在位置 $a,a+1$ 的 $1$ ，想要共增加 $2^{a-1} +2^{a}$ （注意在位置 $a$ 的 $1$ 的实际值是 $2^{a-1}$ 次方！）个递增子序列，只需先将 $MAX,SECONDMAX$ 处的值加一，再在当前数列的位置 $a-1$ 后面加入一个数 $\alpha$，使其成为当前数列第三大数，即可获得 $3*2^{a-1} =2^{a-1}+2*2^{a-1}=2^{a-1}+2^{a}$ 的 递增子序列贡献。

**如果两个 $1$ 非延续，或仅剩一个 $1$**，处理方式和老方法基本相同，按老方式插入数 $\alpha=当前数列最大数+1$，并更新 $MAX,SECONDMAX$ 使它们正确指向当前最大值和次大值。

这样，即可使 增加新数 的信息复杂度常数缩减到原来的一般，是信息复杂度 $O(\log k)$ 的常数将至 $1+0.5=1.5$，刚好通过此题。

有些东西文字讲不清楚，看代码。

```cpp
#include <vector>
#include<bits/stdc++.h>
using namespace std;

std::vector<int> construct_permutation(long long k)
{
	vector<int> vc;
	vector<int> ans;
	int MAX,SEM;//即 MAX 和 SECONDMAX
	vc.clear();
	while(k){
		vc.push_back(k&1);
		k>>=1;
	}
	int n=vc.size();
	for(int i=0;i<n-1;i++) ans.push_back(i);
	int mi=n-2;
	n-=2;
	//初始化最大、次大值的位置
	int count=0;
	while(count<2&&mi>=0){
		while(mi>=0&&!vc[mi]) mi--;
		if(mi>=0&&vc[mi]){
			ans.insert(ans.begin()+mi,++n);
			if(count==0) SEM=mi;
			else{
				MAX=mi;
				SEM++;
			}
			count++;
			mi--;
		}
	}
	//继续往后
	int synic=0;
	while(mi>=0){
		while(mi>=0&&!vc[mi]) mi--;
		//两个1一起
		if(mi>0&&vc[mi]&&vc[mi-1]){
			ans[SEM]++,ans[MAX]++;
			ans.insert(ans.begin()+mi-1,ans[SEM]-1);
			SEM++,MAX++;
			mi-=2;
		}
		//一个1
		else if(mi>=0&&vc[mi]){
			ans.insert(ans.begin()+mi,ans[MAX]+1);
			SEM=MAX;
			MAX=mi;
			SEM++;
			mi--;
		}
	}
	for(int i=0;i<ans.size();i++){
		if(ans[i]<0){
			ans[i]=ans[MAX]-ans[i];
		}
	}
	return ans;
}
```

