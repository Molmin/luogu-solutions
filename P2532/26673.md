##思路概述

下面的题解都直接指出是卡特兰数，那么这题到底为什么是卡特兰数呢？我来解释下 2 种方法：

###1 . 玄学方法

看到样例输入 3 输出 5，索性想到卡特兰数，但还不能完全确定，先分别枚举大小为 1 和大小为 2 的树屋阶梯：

 ![](https://cdn.luogu.com.cn/upload/pic/9048.png) 

确实有点像卡特兰数，接下来再一一枚举大小为 4 的树屋阶梯所有的方案数，不要遗漏，就基本上能猜出是卡特兰数了。

不过这种方法过于玄学，缺少正确性，具体推理过程请看下一个方法。

###2 . 正常方法

我们发现对于任何大小为 $i$ 的树屋阶梯，都可以由左上角放一块大小为 $j$ 的以及右下角放一块大小为 $i - j - 1$ 的树屋阶梯，再在空缺的地方由单个大块的矩形填充即可构成，这个构成的树屋阶梯一共有 $(j) + (i - j - 1) + 1$ 个钢材，正好是 $i$ 个。因为 j 可以在 0 到 $i - 1$ 取且可以证明每一个构成的树屋阶梯一定各不相同，所以我们可以得到树屋阶梯方案与大小关系的递推式$f_i$ = $f_{i - 1}$ × $f_0$ + $f_{i - 2}$ × $f_2$ + ... + $f_0$ × $f_{i-1}$。同时，我们规定 $f_0$ = $f_1$ = 1。哦，这不就是卡特兰数的递推式吗？于是我们就可以安心将这道题当作卡特兰数的模板题食用了。

举个例子，我们可以怎么构成大小为 4 的树屋阶梯呢？首先有第 1 种构成方法：在左上角放上 1 个任意大小为 0 的树屋阶梯（唔，干脆说就是不放），在右下角放上 1 个任意大小为 3 的树屋阶梯，并在左下角的空缺用单个矩形填充。如图下所示：

 ![](https://cdn.luogu.com.cn/upload/pic/9050.png) 

这种构成方法下，我们能构成可行的树屋阶梯 $f_0$ × $f_3$ = 1 × 5 = 5 个。

第 2 种构成方法：在左上角放上 1 个任意大小为 1 的树屋阶梯，在右下角放上 1 个任意大小为 2 的树屋阶梯，并在左下角的空缺用单个矩形填充。如图下所示：

 ![](https://cdn.luogu.com.cn/upload/pic/9053.png) 

这种构成方法下，我们能构成可行的树屋阶梯 $f_1$ × $f_2$ = 1 × 2 = 2 个。

类似地，还有 2 种构成方法，本质上是和上面的 2 种构成方法是一样的。所有方案数加在一起，得 $f_4 = 14$，正是卡特兰数了。

###求答过程

如果我们按递推来求，复杂度可能会很大，因此，这里使用卡特兰数的通项公式：

$h(n)=\frac{(2n)!}{(n + 1)!\cdot n!}$

使用高精度，实现高精乘单精、高精除单精以及输出高精就可以啦！

##代码实现

```cpp
#include <cstdio>

struct HighPrec{
    int L , A[10001];
};
inline HighPrec Init(){
    // 函数作用： 返回一个初值为 1 的高精度 
    HighPrec H;
    H.L = 1 , H.A[1] = 1;
    return H;
}
HighPrec Mul(HighPrec A , int k){
    // 函数作用： 高精度乘上单精度
    HighPrec H;
    for(int i = 1 ; i <= A.L ; i++)
        H.A[i] = A.A[i] * k; // 乘
    for(int i = 2 ; i <= A.L ; i++)
        H.A[i] += H.A[i - 1] / 10,
        H.A[i - 1] %= 10; // 进位
    H.L = A.L;
    while(H.A[H.L] > 10) // 看原先最高位能不能进位 
        H.A[H.L + 1] = H.A[H.L] / 10,
        H.A[H.L] %= 10, // 进位 
        H.L++; // 增加长度
    return H; 
}
HighPrec Div(HighPrec A , int k){
    // 函数作用： 高精度除以单精度
    HighPrec H;
    int t = 0;
    for(int i = A.L ; i >= 1 ; i--)
        t = t * 10 + A.A[i], // 小学竖式
        H.A[i] = t / k , t %= k;
    H.L = A.L;
    while(H.A[H.L] == 0)
        H.L--; // 看原先最高位有没有被除为 0 并不断退位 
    return H;
}
void OutPut(HighPrec A){
    // 函数作用：输出高精度
    for(int i = A.L ; i >= 1 ; i--)
        printf("%d" , A.A[i]); // 正常套路，逆序输出 
}

HighPrec T;
int n;

int main(){
    scanf("%d" , &n);
    T = Init(); // 赋初值 1
    // 下面的乘除是原公式简化的结果，大家请手动去简化 
    for(int i = n + 2 ; i <= n * 2 ; i++)
        T = Mul(T , i);
    for(int i = 1 ; i <= n ; i++)
        T = Div(T , i);
    OutPut(T); // 输出 
    return 0;
}
```