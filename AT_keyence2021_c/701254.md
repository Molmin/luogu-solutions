# [洛谷题面](https://www.luogu.com.cn/problem/AT_keyence2021_c)

## [Atcoder题面](https://atcoder.jp/contests/keyence2021/tasks/keyence2021_c)

### [题面翻译]
有 $H$ 行 $W$ 列的格点。从上到第 $i$ 行，从左到第 $j$ 列的格写为 ($i$，$j$)。每个格子都可以写入 $R$，$D$，$X$ 中的任意一个字符。首先，每个格子都没有写文字。

你可以选择了 $K$ 个格写了文字。第 $i$ 个写入文字的格（$H_i,W_i$）,写入的文字是 $C_i$。在剩余的格上写文字的方法有 $3^{HW-K}$。

对于每种情况，请计算以下问题的答案：

求出其总和除以 $998244353$ 的余数。

有可在上述网格上移动的机器人。机器人在（$i,j$）时，可以移动到（$i+1,j$），($i,j+1$），（$i+1,j$），（$i,j+1$）中的任意一个。但是，如果（$i,j$）中写着 $R$，则只能在（$i,j+1$）中移动，如果写着 $D$，则只能在（$i+1,j$）中移动。写着 $X$ 的情况下都可以移动。

当机器人在（$1,1$）时，机器人不出网格而到达（$H,W$）的移动路径有几种？

注意：机器人在到达（$H,W$）时停止。

### [思路]


很容易知道：

机器人在所有字母填空方式中从（$1,1$）到（$H,W$）可采用的路径数之和等于以下值：

对于从（$1,1$）到（$H,W$）的所有路径，机器人可采用的字母书写方式数之和。

### （这里有点绕，可以先理解一下，再看后面的）

让我们试着找到后者，而不是处理前者。我们假设，从一个空正方形开始，两种移动都可用：向右和向下。

设 $dp[H][W][K]$ 是机器人可以从（$1,1$）到（$H,W$）穿过 $K$ 个空正方形的路径数，我们需要写下与机器人从该方块走的方向相对应的字母，对应机器人从该方格走过的方向。

#### 在其他方格上，我们可以写任何字母。

因此，答案是
 $$\sum_{1 \leq k \leq H+W} \mathrm{dp}(H,W,k) 2^{k}3^{HW-K-k}$$ 
可以发现是枚举 $3$ 个维度。

所以，一眼就看出发现时间会炸，于是：

考虑将 $3$ 维化为 $2$ 维。

在这里，我们可以在转换中将数字乘以 $\frac{1}{2}$。

而不是将 $k$ 作为状态的一部分最后，我们可以在 $O(H \times W)$ 时间内找到它。

可以发现这对于 $H,W \leq 5000$ 完全足够的。

### 特殊的：

可以尝试使用快速幂优化，再加上一点点组合数，同样可以 AC 这道题哦。

------------
这里只贴了使用快速幂优化的版本哦。

对于前面提到的基础版的二维数组就交给各位去处理了。

## $Code:$

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const ll mod=998244353;
ll n,m,k,f[5010][5010],a[5010][5010];
ll ksm(ll x,ll y){
	ll ans=1;
	for(int i=y;i;i>>=1){
		if(i&1)ans=ans*x%mod;
		x=x*x%mod;
	}
	return ans;
}
int main(){
	ll i,j,x,y,op;
	char s[10];
	scanf("%lld%lld%lld",&n,&m,&k);
	for(i=1;i<=k;i++){
		scanf("%lld%lld%s",&x,&y,s);
		if(s[0]=='R')a[x][y]=1;
		else if(s[0]=='D')a[x][y]=2;
		else a[x][y]=3;
	}
	f[1][1]=ksm(3,n*m-k);
	op=ksm(3,mod-2);
	for(i=1;i<=n;i++){
	 	for(j=1;j<=m;j++){
		 	if(i+j>2){
			 	if(i>1){
			 		if(!a[i-1][j])f[i][j]=(f[i][j]+f[i-1][j]*op%mod*2)%mod;
			 		 else if(a[i-1][j]!=1)f[i][j]=(f[i][j]+f[i-1][j])%mod;
			 	}
			 	if(j>1){
			 		if(!a[i][j-1])f[i][j]=(f[i][j]+f[i][j-1]*op%mod*2)%mod;
			 		 else if(a[i][j-1]!=2)f[i][j]=(f[i][j]+f[i][j-1])%mod;
			 	}
		 	}
		}	 
	}
	
	printf("%lld",f[n][m]);
}
```
