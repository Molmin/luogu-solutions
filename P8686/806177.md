# 题目大意：
给定一个长度为 $ N $ 的数组，数组中可能会有重复出现的整数，需要依次修改数组，如果重复则加 $ 1 $，直到数组不再重复。
# 本题思路：
## 并查集
因为是查找是否有相同数据，所以想到用并查集做。

### 方法：
1. 输入，然后将 $ b $ 数组（存储父亲节点值的数组）依次赋值（并查集需要）。

2. 开一重循环，直接套用并查集函数，去查找哪一个答案符合情况（答案不会错误，因为后面要将父亲节点值加 $ 1 $），然后直接输出答案。

3. 在并查集过程中，每次查找后要把当前数字的父亲节点值加 $ 1 $，避免之后出现数据重复。

# 本题代码：
### 暴力代码（会超时）：
```cpp
	cin>>n;
	for(int i=1;i<=n;i++)  cin>>a[i];
	b[a[1]]++;
	for(int i=2;i<=n;i++){
		while(b[a[i]])  a[i]++;
		b[a[i]]++;
	}
	for(int i=1;i<=n;i++) cout<<a[i]<<" ";
```
### 并查集代码：
#### 并查集函数：
```cpp
int bcj(int i){
	if(b[i]==i) return i;
	else return b[i]=bcj(b[i]);
}
```
#### 主程序：
```cpp
	cin>>n;
	for(int i=1;i<=200000;i++)  b[i]=i; //赋值
	for(int i=1;i<=n;i++){//并查集代码（核心代码）
		cin>>a[i],a[i]=bcj(a[i]);//并查集找答案
		cout<<a[i]<<" "; //输出
		b[a[i]]++;//将父亲节点值加上1
	}
```
注意：这样写可能 $ b_1 $ 到 $ b_n $ 会因存储数据太大，这里的 $ n $ 没有太大，那么便可以这样做。