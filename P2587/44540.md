# 题解P2587
>两人竞技类题很多是田忌赛马

左转[田忌赛马模板题](https://www.luogu.com.cn/problem/P1650)

## 田忌赛马
>采用贪心思想

维护四个指针 $i, j, x, y$,
分别表示田忌还能比赛的最好的马、最差的马以及对手最好最差的马。
为了方便，我们可以对马排序，这样就可以让指针直接滑动

对于那题，我们需要知道的思想是：如果能赢，一定要赢；
实在不行，也不能平。要输也得输的有尊严。去和人家最好的马打。打不过也没关系，谁叫人家是最好的马。但是，你至少浪费了人家的一匹好马

比赛一定会进行 $n$次。因此每次循环肯定要决出胜负  
正常情况下，先让最好的马和对方最好的马打。
如果打得过，那最好；  
如果打不过就让最差的马和对方最差的马打，如果还是打不过，~~说明你的马真的太差了~~，就用你最差的马有尊严的输一场  
反正不能赢（如果能赢不至于在这里赢）。不管如何，都得决出胜负。但是平局就是在这里产生的。
由于那题平局不加分，因此在代码里没有体现。但这题不同。

## 回到本题
很明显，最优策略类似于田忌赛马。  
但是需要注意：
> 这题的平局是有分数的，因此代码上要稍作修改
>
> 输了不扣分，因此与模板有差异

### 最劣策略
>“不怕神一样的对手，就怕猪一样的队友”。

如果想要输，只要猪队友即可。

假设你想要输，你就可以成为对方派来的卧底。千方百计想要对方赢。因此只需要找到对手的最优策略即可。但是需要注意计分规则。
我们更关心平局的情况，实在不行，我们再赢

## 代码
>有注释
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 100010;
int n;
int a[N], b[N];
int i, j, x, y;
long long ans = 0;
bool cmp(int u, int v)
{
	return u > v;
}
int main()
{
	scanf("%d", &n);
	for(int i = 1; i <= n; i++) scanf("%d", &a[i]);
	for(int i = 1; i <= n; i++) scanf("%d", &b[i]);
	sort(a + 1, a + 1 + n, cmp);
	sort(b + 1, b + 1 + n, cmp);
	i = 1, j = n; x = 1, y = n;
	for(int k = 1; k <= n; k++) // 最优策略
	{
		if(a[i] > b[x]) // 最好的马的对决
		{
			ans += 2;
			i++, x++;
		}
		else if(a[j] > b[y]) // 最差的马的对决
		{
			ans += 2;
			j--, y--;
		}
		else
		{
			if(a[j] >= b[x]) // 无法有尊严的输掉，就平局
				ans += 1;
			j--, x++;
		}
	}
	printf("%lld ", ans);
	i = 1, j = n; x = 1, y = n;
	ans = 0;
	for(int k = 1; k <= n; k++) // 转化视角：你现在是b的人了
	{
		if(b[i] > a[x])
		{
			i++, x++;
		}
		else if(b[j] > a[y])
		{
			j--, y--;
		}
		else
		{
			if(b[j] < a[x]) // 不得不赢再赢
				ans += 2;
			else // 能平就平
				ans += 1;
			j--, x++;
		}
	}
	printf("%lld\n", ans);
	return 0;
}
```

~~完结撒花哦~~~