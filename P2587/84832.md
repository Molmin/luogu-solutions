读完这题后，我们可以想到一个贪心策略：每次操作，将己方最low的和对面最犇的进（song）行（ren）PK（tou），这样，就构成了田忌赛马的策略。
    
### 但是，田忌赛马的策略是正确的吗？
    
比如说有一组数据：
```
5
4 5 6 7 8
3 4 5 6 7
```

按照田忌赛马的策略，我方最low的要去和对面最犇的千里送，然后构造最优条件，也就是赢4次，输1次。但是，我们可以很明显的看出，就按照输入顺序打的话，其实我方是可以全胜的（1打1,2打2,3打3……）。所以可以看出，田忌赛马的策略并不完全正确。
    
注意，我说的是不完全正确。因为AC程序的策略也是来自于田忌赛马。我们可以看出，如果我方最low的，可以把对方最low的虐爆，那我们就没有必要让其去送人头（因为贪心思想就是以小搏大，既然有更小的代价获取同样的价值，那么就没有必要让战力更高的去虐）。如果我方最low的打不过对面最low的或者说只能打平，那么，我们就应该让最low的去送人头了。
    
但是，这样的话，我们就得不到分了。如果我们最犇的可以虐对面最犇的呢？所以，我们还要比较我方最犇的能不能**虐**（注意哦，是**虐**）对面最犇的。如果虐的过，就没必要送人头。如果平手或打不过，再去送人头也不迟。
    
如果你已经想到上面的策略了，那么，你还不能够AC。因为，如果对方的全队战力是一样的，而你最low的刚好等于对面的战力呢？所以，我们还要做一个特殊判断：当我方最low的去送人头的时候，还要判断一下是否平手。
    
### 所以说，我们的总策略如下：
```
1、判断最弱的能否完胜对方最弱的，不能就跳2.
2、判断最强的是否能完胜对方最强的，不能就跳3.
3、判断最弱的和对方最强的是否平手.

```

### AC代码如下：
```cpp
#include <bits/stdc++.h>
using namespace std;
int work(int a[],int b[],int n)
{
	int h=1,t=n,l=1,r=n;
	int ans=0;
	while(h<=t&&l<=r)
	{
		if(a[h]>b[l]) {ans+=2;h++;l++;}
		else if(a[t]>b[r]) {ans+=2;t--;r--;}
		else {ans+=a[h]==b[r];h++;r--;}
	}
	return ans;
}
int a[100000],b[100000];
int main()
{
	int n;
	scanf("%d",&n);
	for(int i=1;i<=n;i++) scanf("%d",&a[i]);
	for(int i=1;i<=n;i++) scanf("%d",&b[i]);
	sort(a+1,a+n+1);
	sort(b+1,b+n+1);
	printf("%d ",work(a,b,n));
	printf("%d",2*n-work(b,a,n));//我方最坏情况即对方最好情况。只需把对方当成我方计算即可。
}
/*
 4
 1 2 3 4
 2 3 4 5 
 */

```
