### 思路:
  读完题目后很自然的就想到田忌赛马的策略，用我方最蒻的去怼对方最强的，然后裸贪心。但是这一题田忌赛马的策略并不是完全正确，比如下面这组数据：
4
2 3 5 7
1 2 3 4
  按田忌的策略，答案是：5 5，但是仔细一看就能发现，最优答案是：8 4。所以这一题不可以用田忌赛马的策略求解。
  
   我们可以看出，如果我方最蒻的，能怼得过对方最蒻的，那我们就没有必要让其去带走对面最犇的（因为贪心思想就是以小换大，我们优先让蒻的去怼）。
   
   如果我方最蒻的怼不过对面最蒻的或者说是平手，那么，我们就应该让最蒻的去带走对面最强的了。

   但是，如果我们目前最犇的可以怼爆对面最犇的呢?所以，如果我们最犇的可以怼爆对面最犇的，这时就没有必要让最蒻的去送人头。

### 算法：
  将我方和对方的人排序后，逐个进行判断：
  
  如果我方目前剩下的最蒻的能怼掉对面最蒻的，就把双方最蒻的从队伍中去掉，并修改得分。
  
  如果我方目前剩下的最蒻的能和对面最蒻的打平手，此时应该判断：
    如果我方最犇的怼不掉对面最犇的或者能打平手，就让我方最蒻的带走对面最犇的，并将他们从队伍中除去（还要特判我方最蒻的是不是能和对面最犇的打平手）;
    如果我方最犇的能怼掉对面最犇的，就让我方最犇的带走对面最犇的，并将他们从队伍中除去。
    最后修改得分即可。
  
  如果我方最蒻的不能怼掉对面最蒻的，果断让他带走对面最犇的。
### 代码：
```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
int D[2][100005],n;
int find(int i,int j){
    int l=1,r=n,ans=0,h=1,e=n;
    while(h<=e && l<=r){
        if(D[i][l]>D[j][h])
            ans+=2,h++,l++;
        else if(D[i][l]==D[j][h]){
            if(D[i][r]<=D[j][e]){
                if(D[i][l]==D[j][e]) ans++;
                e--,l++;
            }
            else e--,r--,ans+=2;
        }
        else l++,e--;
    }
    return ans;
}
int main(){
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
        scanf("%d",&D[0][i]);
    for(int i=1;i<=n;i++)
        scanf("%d",&D[1][i]);
    sort(D[0]+1,D[0]+1+n);
    sort(D[1]+1,D[1]+1+n);
    printf("%d ",find(0,1));
    printf("%d\n",2*n-find(1,0));
    return 0;
}
```