提高+的题解好激动啊；

这个题据说是道哈希的模板题，不过我用字典树做的把这题AC了，而且效率也不低；

人生第一道字典树的题，权当刷模板了；

（废话有点多）言归正传

#具体思路

首先明确一点，你得在要背单词最多的情况下输出最短长度，即你不能因为最短长度而放弃更多要背的单词。

##字典树预处理

首先，把要背的单词生成一棵字典树，其次，对要读入的每个单词进行查询，如果在树上，就把a[i]赋值为这个单词最后一个字母在树上的指针，为什么这样做呢，学过字典树的同学应该都知道，每个单词的最后一个字母在字典树中的位置是独一无二的，所以可以记录单词的后缀字母来表明这个单词是否要背以及这个单词具体是哪一个，以备下一次查询之用。这些预处理都做完以后，就可以开始尺取法了；

##尺取法
先解释一下几个变量的含义，bo[]数组用来标明某个单词是否是要背的单词，这个的预处理我已经在生成树的时候把每个单词的后缀字母都做好标记了，num[]数组表示在当前长度中某个单词的具体数量，sum表示这段区间内要背单词的最多数量，ans[i]则表示在区间内目标单词数量为i时，区间的最短长度（其实这个说法并不准确，只有ans[sum]是符合这个定义的，但是这并不影响正确性（因为我A了所以肯定是正确的（手动划掉））比如当i为4时，i=1,2,3时的结果就与正确答案毫无关系了），head和tail则是这个尺子的头和尾

尺取法的思路：
遍历a[i]数组，如果这个单词是目标单词（对应if(bo[a[i]]==1)），且这个单词是第一次出现（对应if(num[a[i]]==0)），那么sum就要+1表示尺子里又多一个要背的单词，接着这个单词在尺子里的数量也要+1（对应num[a[i]]++;）。

那么什么时候缩小尺子长度呢？其实只要开头的单词不是要背的（a[head]==0）或是尺子里多次出现的目标单词（num[a[head]]>1），那么这些单词都可以删去（head++），即在保证sum不会--的情况下，开头单词都可以被删掉，注意你删掉这个单词以后别忘了把num--。对于上面的解释，有的同学就有疑问了，开头没用的单词可以删，那末尾的单词怎么办呢，比如5123000005，后面的00005完全可以不要，但是单纯head++是不可能把后面的单词删掉的，这时候我采用ans记录最小值的办法（对应ans[sum]=min(i-head+1,ans[sum])），即当ans[4]遍历到5123000005的3时，就已经把最优解赋值了，之后只要没有比它小的答案就绝对不会被更新，注意一定要有这一步："if(ans[sum]==0) ans[sum]=i-head+1;"否则你输出的结果全是零；

以上就是我的思路了

接下来上代码(60多行代码很简洁)
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
char bo[10010],s[15];
int tr[10010][30],num[10010],l,n,m,tot,a[100010],sum,head,tail,ans[1010];
void cr()//字典树插入 
{
	int u=0,c;
	for(int i=0;i<l;++i)
	{
		c=s[i]-'a';
		if(tr[u][c]==0)tr[u][c]=++tot;
		u=tr[u][c];
	}
	bo[u]=1;
}
int cx()//字典树查询 
{
	int u=0,c;
	for(int i=0;i<l;++i)
	{
		c=s[i]-'a';
		if(tr[u][c]==0) return 0;
		u=tr[u][c];
	}
	if(bo[u]==0) return 0;
	return u; 
}
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;++i)
	{
		scanf("%s",s);
		l=strlen(s);
		cr();
	}
	scanf("%d",&m);
	for(int i=1;i<=m;++i)
	{
		scanf("%s",s);
		l=strlen(s);
		a[i]=cx();
	}
	for(int i=1;i<=m;++i)
	{
		if(bo[a[i]]==1)
		{
			if(num[a[i]]==0) sum++;
			num[a[i]]++;
			if(head!=i)
			while(num[a[head]]>1||a[head]==0) 
			{
				num[a[head]]--;
				++head;
			}
			if(ans[sum]==0) ans[sum]=i-head+1;
			ans[sum]=min(i-head+1,ans[sum]);
		}
	}
	printf("%d\n%d",sum,ans[sum]);
	return 0;
}
```