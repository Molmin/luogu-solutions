这道题目看起来很复杂，让我们慢慢分析。首先，最终每个人的金币数量可以计算出来，它等于金币总数除以人数n。接下来我们用M来表示每人最终拥有的金币数。

　　假设有4个人，按顺序编号为1, 2, 3, 4。假设1号给2号3枚金币，然后2号又给1号5枚金币，这实际上等价于2号给1号2枚金币，而1号什么也没给2号。这样，可以设x2表示2号给了1号多少个金币。如果x2<0，说明实际上是1号给了2号-x2枚金币。x1，x3和x4的含义类似。注意，由于是环形，x1指的是1号给4号多少金币。 
现在假设编号为i的人初始有Ai枚金币。对于1号来说，他给了4号x1枚金币，还剩Ai-x1枚；但因为2号给了他x2枚金币，所以最后还剩A1-x1+x2枚金币。根据题设，该金币数等于M。换句话说，我们得到了一个方程：A1-x1+x2=M。 
同理，对于第2个人，有A2-x2+x3=M。最终，我们可以得到n个方程，一共有n个变量，是不是可以直接解方程组了呢？很可惜，还不行。因为从前n-1个方程可以推导出最后一个方程（想一想，为什么）。所以，实际上只有n-1个方程是有用的。 
尽管无法直接解出答案，我们还是可以尝试着用x1表示出其他的xi，则本题就变成了单变量的极值问题。 

　　对于第1个人，A1-x1+x2=M  x2=M-A1+x1=x1-C1（规定C1=A1-M，下面类似）
  
　　对于第2个人，A2-x2+x3=M  x3=M-A2+x2=2M-A1-A2+x1=x1-C2 
  
　　对于第3个人，A3-x3+x4=M  x4=M-A3+x3=3M-A1-A2-A3+x1=x1-C3 
… 

　　对于第n个人，An-xn+x1=M。
  
　　我们希望所有xi的绝对值之和尽量小，即|x1|+|x1-C1|+|x1-C2|+…+|x1-Cn-1|要最小。注意到|x1-Ci|的几何意义是数轴上点x1到Ci的距离，所以问题变成了：给定数轴上的n个点，找出一个到它们的距离之和尽量小的点。不难猜到，这个最优的x1就是这些数的“中位数”（即排序以后位于中间的数），因此只需要排个序就可以了。


```cpp
#include<bits/stdc++.h>
using namespace std;
int n;//n个人 
long long a[1000005];//每个人的初始金币数 
long long c[1000005];//递推数组 
long long tot;//记录总金币数 
long long m;//中位数 
long long x1;
long long ans;//转手金币数 
int main()
{
	while(scanf("%d",&n)!=EOF)//多组数据 
	{
		tot=0;
		ans=0;
		memset(a,0,sizeof(a));
		memset(c,0,sizeof(c));//初始化 
		for(int i=1;i<=n;i++)
		{
			scanf("%lld",&a[i]);
			tot+=a[i];//记录总金币数 
		} 
		m=tot/n;//每个人最后得到的金币数 
		for(int i=1;i<n;i++)
			c[i]=c[i-1]+a[i]-m;//递推 
		sort(c,c+n);//c数组从小到大排序，以便求中位数 
		x1=c[n/2];//x1是中位数 
		for(int i=0;i<n;i++)
			ans+=abs(x1-c[i]);//公式累加得答案 
		printf("%lld\n",ans);//输出 
	}
	return 0;
}
 
```
------------
