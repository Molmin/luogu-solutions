## UVA11300 Spreading the Wealth
### 题目描述

圆桌旁边坐着 $n$ 个人，每个人有一定数量的金币，金币的总数能被 $n$ 整除。每个人可以给他左右相邻的人一些金币，最终使得每个人的金币数量相等。您的任务是求出被转手的金币的数量的最小值。

### 输入格式

输入包含多组数据。每组数据第一行为一个整数 $n(n<=1000000)$ ,以下 $n$ 行每行为一个整数，按逆时针顺序给出每个人拥有的金币数。输入结束标志为文件结束符($EOF$).

### 输出格式

对于每组数据，输出被转手的金币的数量的最小值。输入保证这个值在 $64$ 位无符号整数的范围之内。


### 题目分析
每个人最终的金币数 $\red {m =  \frac{\sum_{i = 1}^{n}a_i}{n}}$


------------

问题转化为第 $i$ 个人只会给第 $i-1$ 个人 , 假设他给了第 $i-1$ 个人 $x_i$ 个金币 , 那么有

```
for(int i = 1; i <= n; i++)
	m = a[i] - x[i] + x[i+1]
 ```
即，$m$ = 任意原数 $-$ 给掉的 $+$ 得来的


------------

然后移项得，$x_{i+1} = m - a_i + x_i$

$x_2 = m - a_1 + x_1 $

$x_3 = m - a_2 + x_2 = m - a_2 + (m - a_1 + x_1)$

整理得，$x_2 = x_1 - (a_1 - m)$

 $x_3 = x_1 - (a_1 + a_2 - 2m)$
 
$x_4 = x_1 - (a_1 + a_2 + a_3 - 3m)$

$......$

$\red{x_i = x_1 - (\sum_{j=1}^{i-1} a_j - (i-1) * m)}$


------------

发现除了 $x_1$，括号里面的值都是已知的 ,而题目其实是**最小化$ \sum_{i = 1}^{n}|x_i|$**.

### 正确解法
$x_i = x_1 - (\sum_{j=1}^{i-1} a_j - (i-1) * m)$ 

也就是数轴上 $x_1$ 到 $\sum_{j=1}^{i-1} a_j - (i-1) * m$ 的距离

所以问题就变成了取括号里面的数，找一个 $x_1$ 到它们的**距离和最短**，那么显然 $x_1$ 是这些东西的**中位数**， 通过排序求出中位数后，统计每个 $x_i$ 的绝对值之和即可。

### 代码
```
#include <iostream>
#include <cmath>
#include <algorithm>
using namespace std;
const int N = 1000001;
typedef long long LL;
LL n, a[N], m, x[N], ans, sum;
int main()
{
    while(cin >> n)
    {
		m = ans = 0;
        for(int i = 1; i <= n; i++)
            cin >> a[i], m += a[i];
        m /= n;
        x[1] = 0;
        for(int i = 2; i <= n; i++)  
            x[i] = x[i - 1] - m + a[i];
        sort(x + 1, x + 1 + n);  
        sum = x[n / 2 + 1];
        for(int i = 1; i <= n; i++)  
           ans += abs(sum - x[i]);
        cout << ans << endl;
    }
    return 0;
}

```
