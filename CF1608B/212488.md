## Description
构造一个长度为 $n$ 的 $[1, n]$ 的排列，要求恰有 $a$ 个“波峰”和 $b$ 个“波谷”。

一个波峰是如下定义的：若 $p_{i - 1} < p_i > p_{i + 1}$，则称其为一个“波峰”。波谷的定义反之亦然。

## Solution
一个小清新构造。

首先我们思考一下波峰和波谷的性质。可以发现一个波峰肯定是对应一个波谷，因为遇到一个波峰之后肯定是下降，要么降到最右边，要么就要重新回升产生一个波谷。

即，有解的一个必要条件是 $|a - b|\le 1$。多出来的那一个是放在排列的首端或尾端的。

另外，我们满打满算，波峰和波谷加起来一定不超过 $n - 2$ 个，因为排列的首端和尾端是构不成波峰/波谷的。所以有解的另一个必要条件是 $a + b \le n - 2$。

综上，有解的充要条件是 $|a - b|\le 1$ 且 $a + b\le n - 2$，必要性上面已证，下面通过直接构造解的方式说明充分性。

### $a = b$ 的情况
先从这个最好考虑的情况开始。

我们发现需要的是 $a$ 个波峰和 $b$ 个波谷。故不难发现我们可以在一开始反复横跳将方案构造出来，即 谷-\[峰-谷\]-单调上升。第一个谷不会被计算在内，因此峰和谷的数量相等。

我们拿 $[1, 2n + 2]$ 出来构造这 $a$ 个波峰/波谷，后面的数字让他单调上升，故这一部分的代码如下：

```cpp
if (a == b) {
    FOR(i, 1, a + 1) ans[i * 2 - 1] = i;
    FOR(i, 1, a) ans[i * 2] = i + a + 1;
    FOR(i, 2 * a + 2, n) ans[i] = i;
}
```

### $a - b = 1$ 的情况
波峰比波谷多一个，可以发现我们可以构造出 谷-\[峰-谷\]-峰-单调下降 的形式，第一个谷不会被计算在内，因此峰会比谷刚好多一个。这部分的代码如下：

```cpp
else if (a > b) {
    FOR(i, 1, b + 1) ans[i * 2 - 1] = i;
    FOR(i, 1, a - 1) ans[i * 2] = i + b + 1;
    ans[a * 2] = n;
    FOR(i, a * 2 + 1, n) ans[i] = n - (i - a * 2);
}
```

### $b - a = 1$ 的情况
像上面一样，只需要构造出 峰-\[谷-峰\]-谷-单调上升 的形式，第一个峰不会被计算在内，代码如下：

```cpp
else if (a < b) {
    FOR(i, 1, b) ans[i * 2] = i;
    FOR(i, 1, a + 1) ans[i * 2 - 1] = i + b;
    FOR(i, 2 * b + 1, n) ans[i] = i;
}
```

于是代码不难实现，充要性得证。