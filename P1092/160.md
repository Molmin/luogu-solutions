这题可以利用类似高精度的方法来计算不同进制的加法，这样进行回溯搜索。

利用**从上到下，从右到左**的搜索顺序，如果搜索到的这个字母所代表的数字已经求出，则直接搜索下一个，要不然就用两种方案：利用这一列另两个数（如果已经搜出）来求出这个字母所代表的数字；或者直接从n-1到0搜索。

代码君，上！

```cpp
void search(int t,int k,int s) //t表示第几个字母，k表示两个加数或是和，s用来储存余数
{
    if(搜索完毕)
      {打印;退出;}
    if(搜索的是和(k==2))
    {
      计算这一列三个数字的和与余数;
      if(和的这一位字母所代表的数已经求出)
      {
        if(通过加数算出的这位数字与和的这一位字母所代表的
           数相等)  继续下一列的搜索;
        return;
      }
      递归回溯;
    }
    //当搜索的是加数的时候
    计算这一列三个字母所代表的数字（包括未求出）;
    if(三个数字都已求出，并且加数加上余数%n不等于和)
      return;
    用一个变量now来储存现在的这一位字母;
    if(now所代表的数字还未求出)
    {
      if(另一个加数以及和所代表的数字都已经求出)
        利用加数以及和求出这个数;递归回溯;

      else
        从n-1循环到0，递归回溯；
      ans[now]复原至-1;
    }
    else 搜索下一个;
}
```

**by Huangc**
