这道题我的这种解法相信已经有大佬想到并发布了题解了，所以我写这个题解只是为了向大家介绍一种更为高效好用的解题方式而已。不过既然是一道题解，那就还是说一说逻辑吧。

首先这道题数据范围很小，所以可以直接模拟不用考虑时间复杂度超出的情况。在此我想到可以先用scanf得到全部的轰炸范围，然后再一个一个得到目标点的坐标，遍历轰炸范围数组判断是否被轰炸，被炸了几次和最后一次被炸是第几次，代码如下：
```
#include<iostream>
#include<cstdio>
using namespace std;

//目标点对象 
struct targetF{
	int lastba;//lastbang最后一次轰炸
	int cishu;//这个简单易懂，总共被轰炸的次数
	int x,y;//坐标 
}target[10000];

//轰炸的位置对象 
struct bangPF{
	int x1,y1,x2,y2;//就是两个坐标，没什么难的 
}bangP[10000];

//把变量x和i的声明放到这里是因为bang函数中要用到它必须提前声明，这是由C++语言特点决定的(具体可以上网查找，实在不理解也不影响这个题) 
int x,i;

void bang(){
	//把每次轰炸在每一个关键点上重演(感觉好恐怖……) 
	for(int j=0;j<x;j++){
		//如果刚好炸到了当前目标点，就增加这个点被炸的次数，并保存最后一次轰炸是第几次 
		if(target[i].x >= bangP[j].x1 && target[i].x <= bangP[j].x2 && target[i].y >= bangP[j].y1 && target[i].y <= bangP[j].y2){
			target[i].cishu += 1;
			target[i].lastba = j + 1;
		}
	}
}

int n,m,y;
int main(){
	//分别得到这座城市的大小(虽然没什么用)，轰炸的次数和目标点的个数 
	scanf("%d%d%d%d",&n,&m,&x,&y);
	//得到所有轰炸的区域 
	for(i=0;i<x;i++){
		scanf("%d%d%d%d",&bangP[i].x1,&bangP[i].y1,&bangP[i].x2,&bangP[i].y2);
	}
	//得到所有的目标点，并用bang函数处理(函数体在前面) 
	for(i=0;i<y;i++){
		scanf("%d%d",&target[i].x,&target[i].y);
		bang();
	}
	//输出结果 
	for(i=0;i<y;i++){
		if(target[i].cishu == 0){
			printf("N\n");
		}else{
			printf("%c %d %d\n",'Y',target[i].cishu,target[i].lastba);
		}
	}
	return 0;
}
```
相信大家都看懂了。接下来我说一说我真正想说的东西——比较高效的解题方式，这也能让你的代码更具有可读性：

大家可以看到，我的代码中写了一个函数两个结构体。当然我们可以一个函数或结构体也不用，所有代码全部在主函数里面写。但是这样的话会让整段代码看起来逻辑相对比较混乱。

当然这道题看不出来什么，但如果要写一个非常大的模拟的话，那这么做的优势就很容易显现出来了，看到调用函数的表达式直接看前面的函数，这可以让你的代码更具有语义性和可读性，看起来也更加清爽。

最后，其实我只不过是想
### 强烈安利
这种代码方式。如果大家觉得不好也没关系，毕竟这只是我自己的习惯，觉得很好就想跟大家说一说而已。