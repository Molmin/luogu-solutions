
（~~或许是蒟蒻脑回路和楼下大佬不一样~~）

蒟蒻第一次想到的是二维数组模拟整个地图然后每次炸到就加1并且记下这是第几次轰炸。


再仔细想想蒟蒻才绕过来（~~脑回路清奇~~）

## 可以直接比较坐标

#### 如果目标点夹在轰炸x轴坐标和y轴坐标之间就代表轰炸到了如果目标点夹在轰炸x轴坐标和y轴坐标之间就代表轰炸到了，次数加1并记下这是第几次轰炸

最后输出就可以了

上代码

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~分割线~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

`

```cpp
    #include<bits/stdc++.h>
    using namespace std;
    int a[1000000][4],b,c,d,e,f,g,sum,ans;//坏习惯，喜欢定义没有意义的字母，大佬多多见谅
    int main()
    {
        scanf("%d%d",&f,&g);//不知道地图大小有啥用。。。。。。
        scanf("%d%d",&b,&c);//题目中的x和y
        for(int x=0;x<b;x++)scanf("%d%d%d%d",&a[x][0],&a[x][1],&a[x][2],&a[x][3]);//二维数组分别储存坐标
        for(int x=0;x<c;x++){
            scanf("%d%d",&d,&e);
            for(int y=1;y<=b;y++){
                if(a[y-1][0]<=d&&a[y-1][2]>=d&&a[y-1][1]<=e&&a[y-1][3]>=e){//如果目标夹在轰炸范围内
                //因为我喜欢直接从0开始用，所以减一
                    sum++;//次数++
                    ans=y;//记录最后轰炸波数
                }
            }
            if(ans==0)printf("N\n");//输出
            else printf("Y %d %d\n",sum,ans);
            sum=0;ans=0;//别忘清零
        }
        return 0;
    }
`
```