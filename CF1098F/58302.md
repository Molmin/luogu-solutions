
给出一个字符串s，定义函数f(l,r)为s[l,r]的每个后缀与s[l,r]的lcp之和。现在询问q次，每次给出l,r，请输出f(l,r)

其实就是给出一棵树，求$\sum _{i=l}^{r} \min(len[lca(i,l)],r-i+1)$

题解给出的做法...好像很恶心...给一下我自己的做法~~一定写一定写~~

首先，我们分类讨论两种大情况。

## 若$len[lca]>r-l+1$

那么$\min$一定取到$r-i+1$，所以我们要统计编号在一个区间里的点的权值和——随便做。

## 若$len[lca]<r-l+1$

如果我们能够枚举$lca$，那么$\min$取到前者的限制变成了

$$i\le r-len[lca]+1$$

这显然满足$i\le r$的限制，但是不一定满足$i\ge l$的限制，我们先只考虑前一个限制。如何减去不满足后者限制的待会在说。

树剖，离线，把询问挂在重链上，对每个重链分别考虑。

我们对重链建立一棵线段树，维护所有轻儿子的信息。

我们遍历重链上点u的轻子树，把点v变成二维平面上的点$(rk[u],v)$（rk是u在重链从上到下第几个）

根据树剖的性质，总点数不超过$O(n\log n)$

我们把询问按r排序。设当前询问的r为$r$。

那么，对重链上每个点u，限制是：

$$i\le r-len[u]+1$$

考虑我们的查询，是查询重链的一个前缀，［满足重链前缀上的点u的编号限制］的v，的权值（$len[u]+v$）

假设我们之前已经维护好了，现在$r\to r',r<r'$，考虑信息的变化，每个点的限制变成$i\le r'-len[u]+1$，限制变松了，有一些平面上的点会满足要求，我们把它们加入即可。因为一个点只会被加入一次，所以复杂度有保证。

但是别忘了一个问题：除了这个前缀，其他横坐标的点也是有贡献的！只不过它们的lca都不是自己的u了，而是这个前缀的最后一个点。

简单的说，就是前缀最后一个点的重儿子的信息都没有被统计。现在问题变成了，求一个子树里的，满足$i\le r-len[lca]+1$的点的权值和。因为$len[lca]$确定，所以很简单实现。

还有轻儿子去重。这个和上面差不多。

### $i<l$的限制

相当于求$\sum _{i<l} len[lca(l,i)]$，[LNOI]LCA即可。

----------

如果min取到后者，那么也差不多。

所以说我们一共要写3,4种线段树。总复杂度$O(n\log ^2n)$