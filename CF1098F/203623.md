提供一个基于全局平衡二叉树的解法。

通过简单的 SAM 转化，我们得到这样一个问题：

一棵树，点带权 $v$；存在映射关系 $rk$（从 $id \in [1,n]$ 映射到树上的节点）。每次给 $l,r,u$，求

$$\sum _{i=l}^r \min (v_{lca(u,rk_i)},r-i+1)$$

如果没有 $\min$ 就是经典问题。考虑差分后扫描线。

从 $u$ 向上跳重链。考虑链 $(x,top_x)$。

对于 $x$：

1. $v_x \le r-i+1$ 即 $i \le r-v_x +1$。

即子树扣掉了某子树中满足条件的 $i$ 的数量。

2. $v_x > r-i+1$

同理。求满足条件的 $i$ 和。

对于 $p\in fa_x \to top_x$：

$v_p\le r-i+1$ 即 $v_p +i-1 \le r$。分成 $v_p +i-1 \le r$ 和 $v_p +i-1 > r$ 即可。

上面两个东西都是三维偏序模型（因为扫描线要加点）。一般来说，轻重链剖分会造成 $O(n\log n)$ 次查询。

所以时间复杂度为 $O(n\log ^3 n)$。

考虑优化。

有一个叫“全局平衡二叉树”的东西，可以帮助我们将时间复杂度优化至 $O(\log ^2 n)$。

不会的可以看一下：

如果我们对每条重链建立平衡二叉树结构，那么每个重链的前缀就可以在二叉树结构上搜索出来。

然而这并没有优化时间复杂度。

所以考虑给每个点加权。权为其子树大小减去重儿子子树大小。

然后建立带权平衡二叉树结构。理解一下，发现一定存在一个点满足将序列划分为两半，使得每一半的和均不超过总和的一半。

那么每个点在带权平衡二叉树和轻边上跳子树大小均翻倍。所以跳 $O(\log n)$ 次。

我们重新考虑。

对于 $x$：

我们发现查询的本质上是他的到链底的点的轻子树和他到链底上的点减去他的某个子树。这个也是可以在带权平衡二叉树上搜索出来的。

那么在加点的时候就对所有轻子树包含他的 $O(\log n)$ 个点加贡献。在全局平衡二叉树上跳，用平衡树维护即可。

对于 $fa_x \to top_x$：

变成了前缀而已。是同理的。

时间复杂度 $O(n\log ^2 n)$。

真的很难写。。还要稍微地卡下常。我用的是 AVL 勉强能过。AVL 插入较慢（对于红黑树而言）但查询较快。本题的瓶颈在于查询，所以 AVL 比较合适。我是擦着边过的，其他平衡树可能难以通过或者要大力卡常。

[CF 评测记录](https://codeforces.com/contest/1098/submission/152275041)