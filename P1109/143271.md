#### 前言

乍一看没有读懂题目。

[题目链接](https://www.luogu.com.cn/problem/P1109)

#### 正文

题目题意没有读懂，这里给一个容易读懂一点的抽象化的题意。大概长成这样：

给出一个包含了 $n$ 个数的数列 $a$，你可以进行一种操作，这种操作支持：对于任意的 $i,j∈\{1,2,3,...,n\}$，可以让 $a_i$ 变大为 $a_i+1$，并且 $a_j$ 变小为 $a_j-1$。问的是最多需要多少步操作，才能使对于任意的 $i∈\{1,2,3,4,..,n\}$，都有 $l\leq a_i\leq r$。

这个应该足够容易理解了吧。

---

好了我们继续来看。

那么这题让我们计算最少需要多少步操作，那么我们珂以直接自然的想到，如果我进行 dfs，每次选到的是哪两个下标 $i,j$，直接来判断如果进行了操作是否对结果**有益**。如果有益那么继续搜，如果**有害**那么不进行这一步。每一步搜完都需要判断一下现在是否满足 $l\leq a_i\leq r$，如果满足了就不用搜了，直接返回。而且我们珂以阈值，大概到了 1000 步就不用搜了。

但是思考一下，这样做真的是最优的吗？

显然不是。原因？

是因为，当你进行 dfs 的时候，显然进行了不必要的判断。这道题目只需要求出最少的步数就行了，没有必要再去判断每一步具体如何移动。

那么我们有没有不需要判断如何移动就能够求出移动总步数的方式呢？

显然有。

既然不要对具体的操作进行，那么我们珂以从宏观上来看。

现在，我们记录两个变量：$x$ 和 $y$，

$$x=\sum_{i=1}^{n}a_i\text{ need to move}$$

$$y=\sum_{i=1}^{n}a_i\text{ need to be in}$$

中文翻译：$x$ 表示每个班级需要移出班级以达到在范围内的人数总和。同样的，$y$ 表示这个班还需要加进来才能达到范围的人数总和。


如果我们计算出了 $x$ 和 $y$，那么就很好办了。我们只需要比较 $x$ 和 $y$ 的大小，并且取其较大者作为答案。

如果取的是较小者，那么会出现的一个问题是：这个序列还没有完全符合题意，如果 $x$ 大而取 $y$ 那么会出现至少有一个班级还是人太多，反之亦然。

然后我们来考虑 `-1` 这个东西的问题。如果输出 `-1` 那么代表我不能进行有限步操作使得我的每一个班级都在范围内。

我尽量使每一个班级都在范围内，那么如果出现全部都取到最大值，然而还有人大于阈值的，显然输出`-1`，同样的反之亦然。

但是这样比较难写进代码，我们继续抽象化的思考这个问题。

如果全部都是最大值，仍然有数大于阈值，那么显然，总人数大于总人数最大值，根据上面讲的，这种情况输出`-1`。反之亦然。（因为是对称的）

我们尝试抽象化为数学表达式：总人数为 $\sum^{n}_{i=1} a_i$，而总人数最大值为 $n\cdot r$，总人数最小值为 $n\cdot l$。

我们甚至还珂以写一个函数表达式来表示结果：

$$f_a=\begin{cases}-1\text{ ($\sum_{i=1}^n a_i<n\cdot l$ or $\sum^{n}_{i=1}a_i>n\cdot r$)}\\ \max\{x,y\}\text{ ($n\cdot l\leq\sum_{i=1}^n a_i\leq n\cdot r$)}\end{cases}$$

昂，就是这样。所以我们的程序只需要先计算 $\sum^{n}_{i=1}a_i$，如果它不在范围内，那么直接愉快的输出 `-1`。如果在范围内，那么计算 $x$ 和 $y$，并打印出他们两个中的较大值。

贴代码：
```cpp
#include<bits/stdc++.h>
#define HohleFeuerwerke using namespace std
#pragma GCC optimize(3)
#define MAXN 55
HohleFeuerwerke;
int n;//n个组
int gr[MAXN];//就是上文提到的a数组，这里用了group的缩写gr
int l,r;//上界与下界
int tot;
int away,newin;//这两个就是上文提到的x和y，分别表示总共需要离开班级的，和总共需要进入班级的。
int main()
{
	ios::sync_with_stdio(false);
	cout.tie(0);cin.tie(0);
	cin>>n;
	for(int i=1;i<=n;i++) cin>>gr[i],tot+=gr[i];
	cin>>l>>r;
    //到上面为止都是读入
	if(!((l*n<=tot)&&(r*n>=tot))){cout<<-1<<endl;return 0;}//如果不在范围内，那么直接输出-1然后结束。
	for(int i=1;i<=n;i++){
		if(gr[i]<l) newin+=l-gr[i];//计算y
		if(gr[i]>r) away+=gr[i]-r;//计算x
	}
	cout<<max(newin,away)<<endl;//这个输出较大值，应该很清楚的
	return 0;
}
```




