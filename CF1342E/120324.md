大家好，我不会斯特林数，于是我用容斥通过了本题。

手玩可以发现：

- 要想覆盖满整个棋盘，只可能是以下两种情况之一：
	- 每一列都有一个棋子；
    - 每一行都有一个棋子。
    - 显然这两种情况是旋转等价的。可以只算一种。

> 可以形象地理解。先构造出每一列都有棋子的情况，再把其中一列的棋子移动到另一列。
>
> 这时候，新增一列无法被攻击。当移动前不同时满足情况 1、2 时（即每行、每列都有一个棋子），总存在一行没有棋子。该行该列即无法被攻击。

其次，可以暂且把棋子按行的顺序开摆。

- 直接 $O(nk$) 进行 dp 是显然的。
- 相邻的、行相同的棋子可以互相攻击，行不同的则不能。任意重新排列，这些行相同的棋子仍然可以互相攻击。
- 那么要使恰好 $k$ 对互相攻击，则有 $n-k$ 个“间隔”，即 $n-k$ 种行。
- 由此可得 $k \ge n$ 时无解。

于是问题转化为：**把 $n$ 个不同棋子放入 $n-k$ 个不同盒子，每个盒子至少放一个**。

大力容斥，枚举有多少个空的，并把这些空的选出来，即可：

$$\sum_{i=0}^{n-k}\binom{n-k}{i}(-1)^i(n-k-i)^n$$

最后乘上 $\binom{n}{n-k}$ 选出哪些行即可。

当 $k=0$，情况 1、2 相同。否则答案需要乘 $2$。

```cpp
int main() {
    genFac();
    rd(n, k);
    if (k >= n) return puts("0"), 0;
    ll p = n - k;
    
    ll v = 0;
    U (i, 0, p) 
        (v += C(p, i) * qpow(p - i, n) % P * ((i & 1) ? (P - 1) : 1)) %= P;
    (v *= C(n, p)) %= P;
    if (k) (v *= 2) %= P;
    printf("%lld", v);
}
```

时间复杂度 $O(n \log n)$，瓶颈是快速幂。把 $i^n$ 用线性筛筛出来可以做到 $O(n)$，谔谔。