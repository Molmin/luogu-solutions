
#O(N)的算法

这个题，真够坑的。


题目一共有两个主操作，即比较和计算后缀最大值。


但是

题目的数据范围和时限让我们只能用O(N)的算法。


因此，比较和计算后缀最大值只能在同一个循环里。。。


具体方法如下：


输入---->快排---->边比较边计算---->输出结果


比较方法：我们假设最低分拿了第1，再假设比他高的分拿了比他低的名次，相差越大名次越低，再找这些里面最大的，


也就是后缀最大和，再和最低分拿了第1比较，如果最低分拿了第1>=后缀最大和，则结果，最后输出结果即可。


具体见代码：

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;
int i,j,a[300000]/*存分数的数组*/,sum/*存结果*/,n,k,bigs/*后缀最大值*/;
int main()
{
    cin>>n;
    for(i=0;i<n;i++)
    {
        cin>>a[i];
    }
    sort(a,a+n);
    bigs=a[n-1]+1;//后缀最大值默认为最大的分数+1
    for(j=n-1;j>0;j--)//从后往前比较，因为还要同时计算后缀最大值，所以只能从后往前计算，不能从前往后。
    {
        if((a[j]+n)>=bigs)//比较部分
        {
            sum++;
        }
        bigs=max(bigs,a[k+1]+n-j+1);//计算后缀最大和，即原来的和比他分数低一级但拿了比他高一名的分数比较。
    }
    cout<<sum;//输出结果
}
```