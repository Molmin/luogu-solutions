#### 题意

给出一个字符串 $S$ ，判断其中是否有子串 `AB` 和 `BA` 且 `AB` 和 `BA` 不重叠。

#### 分析

因为不能计算重叠的，所以对于 `ABA` 和 `BAB` 只能算作一个 `AB` 或是 `BA` 来判断，将其个数记作 $p$ 。

然后我们计算去除 `ABA` 和 `BAB` 的 $S$ 中 `AB` 和 `BA` 的个数，分别记作 $a$ 和 $b$ 。

当 `AB` 与 `BA` 存在于 $S$ 时，必有 $a,b>0$ 或是 $p\geq2$ ，以及需要 $p$ 补齐缺少的子串时的情况 $(p>0)$ 。

#### 实现

先计算 $p$ 的值，并在计算过程中去除 `BAB` 和 `ABA`。
```
for (int i = 0; i < in.length() - 2; i++) {
    if ((in[i] == 'A' && in[i + 1] == 'B' && in[i + 2] == 'A') || (in[i] == 'B' && in[i + 1] == 'A' && in[i + 2] == 'B')) {
        in[i] = in[i + 1] = in[i + 2] = '#'; // 去除 ABA 和 BAB
        p++;
    }
}
```

因为已经去除了 `BAB` 和 `ABA` 所以剩下的都是单独的 `AB` 与 `BA`，直接计算个数即可。
```
for (int i = 0; i < in.length() - 1; i++)
    if (in[i] == 'A' && in[i + 1] == 'B')
        a++;
for (int i = 0; i < in.length() - 1; i++)
    if (in[i] == 'B' && in[i + 1] == 'A')
        b++;
```

最后判断是否存在
```
if ((a && b) || (a && p) || (b && p) || (p >= 2))
    puts("YES");
else
    puts("NO");
```