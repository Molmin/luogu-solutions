观察样例，可以发现第 i-1 步选择的地点总是被包含在第 i 步选择的地点中。因此这题很可能具有贪心的可行性。仔细论证一下，可以证出这个结论是正确的。（可以运用反证法，类似 dijkstra算法 的证明方法）。

明白这一点后，算法的步骤即为：令 S 一开始为全体地点，sum=0。每一步从集合 T 中选取一个具有最大化利益 E[i] 的点 i，令 sum += E[i]，输出 sum，并将 i 点从 T 中删除。这里的利益指的是走到一个点能增加的的疲惫值。

那么利益 E[i] 如何计算呢？很显然，一开始时 E[i] 由下式给出

E[i] = A[i] + 2\*S[i]

然而当选取了一个点后，E[i]需要进行相应的更改。以下的讨论中，

假设之前被选中的 S 最大的点（即最靠右的点）为 prev，当前被选中的点为 this 。

1) 为了让 this 不再被选中，令

E[this] = -INF

2) 对于 prev 和 this 之间（不含端点）的所有点 i，若 S[this] > S[prev]：

E[i] -= 2 \* (S[i]-S[prev])

否则 E[i] 不变。意思是：若 this 比起 prev 还往前走了一段距离，那么显然在后续过程中这些点所能获得的利益将减少两倍的 i 与 prev 间的距离——因为这一次已经把这一段走过了。若没有往前走，那么对于利益是没有影响的。

3) 对于 this 右边的所有点 i，若 S[this] > S[prev]：

E[i] -= 2 \* (S[this]-S[prev])

否则 E[i] 不变。解释同情况 2。不明白的可以画图验证。

接下来需要考虑的问题是如何快速更新利益的值，并快速地找出其中的最大值。如果是纯暴力，每次需要 O(n) 来查询最大值与更新，总计是 O(n^2)，60分左右；如果用堆，每次查询需要 O(log n)，但更新需要 O(n log n)。还不如暴力。

因为涉及区间修改和查询，想到用线段树，维护区间最值，并需要支持区间更新。平摊下来查询与更新都是 O(log n)。之所以说是平摊，是因为第二种情况中，无法进行整段区间的更新，而只能单点更新（因为每个点减去的值不同），具体的时间复杂度是不定的。但是由于第二种情况对于每个点来说至多出现一次，单点更新的总次数是 O(n)，故平摊下来还是 O(log n)。
