我这个蒟蒻都不知道树状数组是什么鬼……话说为什么要用树状数组？？？

思路如下：

这道题我用的是贪心的算法，对于每个疲劳值都定义一个数组，算法的步骤很显然即为：一开始定义sum=0，每一步都计算出能够增加的最大的疲劳值maxn，将sum+=maxn，输出，并将这个点从表中删除。

那么最大的利益maxn如何计算呢？

很显然，一开始的maxn即为距离（a数组）\*2+推销的疲劳值（j）。但接下来公式即不同了。

我们将当前被选中的点的距离称为this，之前的最大点的距离称为prev。那么就会有两种情况：

1.this>prev，也就是当前到达的是一个新的，距离比之前更远的点，那么新增的疲劳值即为（this-prev）\*2+j；

2.this<prev，也就是当前点的距离包含在之前走过的距离内，那么新增的疲劳值即为j。

最后还有几点需要考虑：

1.考虑到可能会有几户人家的推销疲劳值相同，则我们需要额外开一个数组来存储。而在删除点时只需将这个数组的值自减即可；

2.我们每次搜索时都要保存下maxn所对应的疲劳值和最大距离；

3.需要建立一个根据推销疲劳值来存储人家的数组。


```cpp
#include <iostream>
using namespace std;
int n,maxn,sum,a[100001],b[100001],c[100001][101],t,p=0,x,y;
int main()
{
    cin>>n;
    for (int i=1;i<=n;i++) cin>>a[i];
    for (int i=1;i<=n;i++)
    {
        cin>>t;
        b[t]++;//存储每种疲劳值有几户人家
        c[t][b[t]]=i; //根据疲劳值找户 
    }
    for (int i=1;i<=n;i++)
    {
        maxn=0;x=0;y=0;
        for (int j=0;j<=999;j++)
          if (b[j]>0)
            if (a[c[j][b[j]]]>p&&(a[c[j][b[j]]]-p)*2+j>maxn)//如果当前点大于之前最大点
            {
                maxn=(a[c[j][b[j]]]-p)*2+j;//计算增加的疲劳值
                x=j;  
                y=a[c[j][b[j]]]; 
            }
            else if (a[c[j][b[j]]]<=p&&j>maxn)//小于
            {
                maxn=x=j;  
                y=p;
            }
            p=y;b[x]--;//记录最大点，删除当前点
            sum+=maxn;//累加
            cout<<sum<<endl;//输出
    }
    return 0;
}
```