如果能够统计区间 $[0,n]$ 内整数二进制表示中 $1$ 的个数，令结果为 $dp[n]$，那么题目所求即为 $dp[b]-dp[a-1]$。

朴素的方法是对于区间 $[0,x]$ 中的每个整数，逐一确定二进制表示中 $1$ 的个数然后求和，显然，这是低效的做法，对于题目所给定的测试数据规模，无法获得 `Accepted`。

需要寻找规律，提高效率。

列出区间 $[0,15]$ 内整数的 $4$ 位二进制表示：

```
 8 -> 1000  0 -> 0000
 9 -> 1001  1 -> 0001
10 -> 1010  2 -> 0010
11 -> 1011  3 -> 0011
12 -> 1100  4 -> 0100 0 -> 0000
13 -> 1101  5 -> 0101 1 -> 0001
14 -> 1110  6 -> 0110 2 -> 0010 0 -> 0000
15 -> 1111  7 -> 0111 3 -> 0011 1 -> 0001
```

可以容易观察到以下规律：

- 从 $8$ 到 $15$ 的二进制表示，从左往右计数，除了第 $1$ 位是 $1$ 以外，剩余的右侧 $3$ 位与 $0$ 到 $7$ 的二进制表示一一对应相同；

- 从 $4$ 到 $7$ 的二进制表示，从左往右计数，除了第 $2$ 位是 $1$ 以外，剩余的右侧 $2$ 位与 $0$ 到 $3$ 的二进制表示一一对应相同；

- 从 $2$ 到 $3$ 的二进制表示，从左往右计数，除了第 $3$ 位是 $1$ 以外，剩余的右侧 $1$ 位与 $0$ 到 $1$ 的二进制表示一一对应相同；

根据上述规律，在统计区间 $[0,15]$ 内整数二进制表示中 $1$ 的个数时，可以将其分成两个部分分别进行统计：先统计 $[0,7]$ 中整数的二进制表示 $1$ 的个数，然后再统计 $[8,15]$ 中整数的二进制表示中 $1$ 的个数。假设 $[0,7]$ 中整数的二进制表示中 $1$ 的个数为 $x$，根据上述规律，$[8,15]$ 中整数的二进制表示中 $1$ 的个数为 $8 + x$，亦即 $2^3 + x$。

将上述规律进一步推广，对于区间 $[0,2^n - 1]$ 内的整数，可以将其分成两个区间来统计其二进制表示中 $1$ 的个数，即分成区间 $[0,2^{n-1}-1]$ 和 $[2^{n-1},2^n-1]$ 分别予以统计，假设区间 $[0,2^{n-1}-1]$ 内整数的二进制表示中 $1$ 的个数为 $x$，那么区间 $[2^{n-1},2^n-1]$ 内整数的二进制表示中 $1$ 的个数为 $2^{n-1} + x$。而区间 $[0,2^{n-1}-1]$ 又可以进一步划分为区间 $[0,2^{n-2}-1]$ 和 $[2^{n-2},2^{n-1}-1]$ 分别进行统计……按照如此继续分解，最终区间会变成 $[0,1]$。

如果问题能够分解为一系列的子问题而且子问题互不重叠，那么这往往提示可以应用动态规划思想，而上述分析中，问题符合这一性质。

那么应该如何应用动态规划思想呢？

对于给定的整数 $n$，将其转换为二进制表示，假设为：

```
1001001111001111
```
那么可以将其分成两个区间进行统计，区间
- $[0000000000000000_2,0111111111111111_2]$

- $[1000000000000000_2,1001001111001111_2]$

对于区间 $[0000000000000000_2,0111111111111111_2]$ 内 $1$ 的个数，可以应用前述的规律予以分解进行求和。对于区间 $[1000000000000000_2,1001001111001111_2]$，其不满足前述规律，需要进行适当转换。

对于区间 $[1000000000000000_2,1001001111001111_2]$，可以将其视为区间 $[0000000000000_2,1001111001111_2]$ 内的每个二进制数前面附加 `100`，也就是说，区间 $[1000000000000000_2,1001001111001111_2]$ 内二进制数中 $1$ 的个数等于区间 $[0000000000000_2,1001111001111_2]$ 内二进制数 $1$ 的个数再加上 $1001111001111_2 + 1$ 个。

至此，求区间 $[0_2,1001001111001111_2]$ 内整数二进制表示中 $1$ 的个数转化为求解区间 $[0_2,1001111001111_2]$ 内整数二进制表示中 $1$ 的个数，问题是类似的，继续按照前述方法继续分解即可。

参考代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define FAST_IO cin.tie(0), cout.tie(0), ios::sync_with_stdio(false)
long long ones[32];
long long dfs(int n) {
    if (n <= 0) return 0;
    // 获取 n 的二进制表示中最高位 1 所在的位置。
    int offset = 31 - __builtin_clz(n);
    // 分解统计。
    return ones[offset] + (n - (1 << offset) + 1) + dfs(n - (1 << offset));
}
int main(int argc, char *argv[]) {
    FAST_IO;
    // 预先计算区间 [0, 2^i - 1] 中整数二进制表示 1 的个数。
    ones[0] = 0;
    for (int i = 1; i < 32; i++) ones[i] = (1 << (i - 1)) + 2 * ones[i - 1];
    int a, b, cases = 1;
    while (cin >> a >> b, a || b) {
        cout << "Case " << cases++ << ": ";
        cout << dfs(b) - dfs(a - 1) << '\n';
    }
    return 0;
}
```