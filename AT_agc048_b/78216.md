神奇但合理的人类智慧。做出来这道题的人思维能力肯定不差。

---

首先，我们令答案对应的括号序列中，所有填入中括号的位置集合 $\left\{x_1, x_2, x_3, x_4, \cdots\right\}$。

括号序列中，对于一对配对的中括号 $(l, r)$，中间一段长度为 $r - l + 1$ 的括号序列应当可以匹配，所以 $r - l + 1$ 一定是偶数。也就是说，$l$ 与 $r$ 的奇偶性必定不相同。对应到 $x_i$ 序列中，就是奇数项与偶数项数量相同。

而反过来考虑，是不是 $x_i$ 序列中奇数项与偶数项数量相同，就必定有解呢？

让我们来尝试对这样一组序列 $x_i$ 构造一组合法的括号序列。

* 将 $x_i$ 升序排序。
* 对于所有相邻两项奇偶性不同的位置，我们填入 ```[()()...()()]```，然后把这两个数删掉，再找下一个相邻两项奇偶性不同的位置。
  * 如果发现要填的段已经有部分被填充也没有关系，只要把没有填充的部分提取出来再填入 ```[()()...()()]``` 即可，这样就不会影响到已经填充的部分。
  * 此时总长度和已被填充的部分长度都是偶数，所以剩余未填部分长度也为偶数，必定可以填充。
* 所有 $x_i$ 都被使用过后，可能还有空缺部分，我们同样把没有填充的部分提出，按照 ```()()...()()``` 的方式填入。

由于 $x_i$ 中奇数项与偶数项数量相同，所以必定可以把 $x_i$ 中所有数都使用一次。

有了这样的构造，我们只要把奇数项和偶数项从大到小成对丢进 $x_i$，直到填圆括号更优为止。

---

在代码实现的时候，我们可以把题目给定的 $A_i$ 与 $B_i$ 作差，再讨论是否要使用中括号。

> Talk is cheap, show me the code.

```cpp
ll n, a[2][100010], t, Ans;
int main ()
{
	std::cin.tie (nullptr), std::ios::sync_with_stdio (false);
	cin >> n;
	For (i, 1, n) cin >> t, Ans += t, a[i & 1][(i + 1) >> 1] = -t;
	For (i, 1, n) cin >> t, a[i & 1][(i + 1) >> 1] += t;
	sort (all (a[0], n / 2), greater<ll> ());
	sort (all (a[1], n / 2), greater<ll> ());
	For (i, 1, n / 2)
		if (a[0][i] + a[1][i] > 0) Ans += a[0][i] + a[1][i];
		else break;
	cout << Ans << endl;
	return 0;
}
```