一看到这个题感觉数据很少，很符合我的打表风格，那么我来讲讲如何使用程序打表。  
不管怎么样，这个~~标准~~程序还是要写的，虽然不敢说是正解，但是却可以运行出正确的答案，我的程序就是一个枚举，不断地枚举T型骨牌所在的位置，不过还要枚举方向，那这个怎么枚举呢？  
我们只要枚举T型骨牌的中间点就好了，就是这个点：  
                          #..
                          #@#
                          #..
在T型骨牌的```@```点上，例如在一个```5*5```的矩阵内，我们要这样枚举，首先在边上肯定是不可能有中间点的存在的，那么我们就这样：  
从```2,2```开始枚举到```m-1,n-1```,然后我们就枚举，先在```2,2```号放上一个，移动到```2,3```，但是```2,3```放不了，怎么办，那么我们就移动到```2,4```，发现可以放了，就马上放，以此类推，最后走到```m-1,n-1```的下一个节点时，我们就用一个计数函数数一下图内的所有```@```符号，最后输出我们的结果，但是为了使用方便，不用手动打表，我们就用一个循环自动枚举所有的```9*9=81```种情况，然后以打表的方式输出就可以了
```
printf("dabiao[%d][%d]=%d;\n",i,j,work(i,j));
```
是不是很方便？
那么直接给出我的打表程序好了
```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
int dabiao[10][10];
int db()
{
	dabiao[1][1]=0;
	dabiao[1][2]=0;
	dabiao[1][3]=0;
	dabiao[1][4]=0;
	dabiao[1][5]=0;
	dabiao[1][6]=0;
	dabiao[1][7]=0;
	dabiao[1][8]=0;
	dabiao[1][9]=0;
	dabiao[2][1]=0;
	dabiao[2][2]=0;
	dabiao[2][3]=0;
	dabiao[2][4]=0;
	dabiao[2][5]=0;
	dabiao[2][6]=0;
	dabiao[2][7]=0;
	dabiao[2][8]=0;
	dabiao[2][9]=0;
	dabiao[3][1]=0;
	dabiao[3][2]=0;
	dabiao[3][3]=1;
	dabiao[3][4]=1;
	dabiao[3][5]=2;
	dabiao[3][6]=2;
	dabiao[3][7]=3;
	dabiao[3][8]=3;
	dabiao[3][9]=4;
	dabiao[4][1]=0;
	dabiao[4][2]=0;
	dabiao[4][3]=1;
	dabiao[4][4]=2;
	dabiao[4][5]=2;
	dabiao[4][6]=3;
	dabiao[4][7]=4;
	dabiao[4][8]=4;
	dabiao[4][9]=5;
	dabiao[5][1]=0;
	dabiao[5][2]=0;
	dabiao[5][3]=2;
	dabiao[5][4]=2;
	dabiao[5][5]=4;
	dabiao[5][6]=4;
	dabiao[5][7]=5;
	dabiao[5][8]=6;
	dabiao[5][9]=7;
	dabiao[6][1]=0;
	dabiao[6][2]=0;
	dabiao[6][3]=2;
	dabiao[6][4]=3;
	dabiao[6][5]=4;
	dabiao[6][6]=5;
	dabiao[6][7]=6;
	dabiao[6][8]=7;
	dabiao[6][9]=8;
	dabiao[7][1]=0;
	dabiao[7][2]=0;
	dabiao[7][3]=3;
	dabiao[7][4]=4;
	dabiao[7][5]=5;
	dabiao[7][6]=6;
	dabiao[7][7]=8;
	dabiao[7][8]=9;
	dabiao[7][9]=10;
	dabiao[8][1]=0;
	dabiao[8][2]=0;
	dabiao[8][3]=3;
	dabiao[8][4]=4;
	dabiao[8][5]=6;
	dabiao[8][6]=7;
	dabiao[8][7]=9;
	dabiao[8][8]=10;
	dabiao[8][9]=12;
	dabiao[9][1]=0;
	dabiao[9][2]=0;
	dabiao[9][3]=4;
	dabiao[9][4]=5;
	dabiao[9][5]=7;
	dabiao[9][6]=8;
	dabiao[9][7]=10;
	dabiao[9][8]=12;
	dabiao[9][9]=13;
}
int n,m;
int main()
{
	db();
	scanf("%d%d",&n,&m);
	printf("%d",dabiao[n][m]);
	while(1);	//防抄袭 
	return 0;
}
```
大家可以手动推一下，如果推不出可以看一下我的代码，也许你会恍然大悟，但是真正的打表程序还是要自己写了，本人只提供代码，以方便读者大大们检验推导的正确性