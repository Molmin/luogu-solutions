### 题意简述

- 有 $n$ 个六面骰子，其中第 $i$ 个骰子的点数为 $a_i$，这 $n$ 个骰子的点数之和为 $s$。
- 拿走一个点数最大的骰子，剩余 $n-1$ 个骰子的点数之和为 $r$。
- 给定 $n, s, r$，请输出任意一个可能的序列 $a$。
- 本题有 $t$ 组数据。
- $1\le t\le 1000, 2\le n \le 50, 1\le a_i\le 6, 1\le r < s \le 300$。

### 题目分析

我们拿走了一个点数最大的骰子，拿走之前点数之和为 $s$，拿走之后点数之和为 $r$，那么很明显地，这个骰子的点数就为 $s-r$，由于我们可以输出任意一个序列，所以可以首先输出 $s-r$。

那么如何输出剩下的 $n-1$ 个骰子呢？

我们可以尝试将点数平均分配到每一个骰子上，防止 $a_i$ 越界。首先，我们应该计算出 $\lfloor \frac{r}{n-1} \rfloor$ 的值，表示这 $n-1$ 个骰子的点数之和除以 $n-1$ 向下取整后的结果，那么假如我们输出了 $n-1$ 个这个值，点数之和就与 $r$ 相差 $r \bmod (n -1)$ 的结果（因为 $r-\lfloor \frac{r}{n-1} \rfloor \times (n-1)=r \bmod (n-1)$）。为了让这 $n-1$ 个骰子的点数之和刚好等于 $r$，我们就应该将其中 $r \bmod (n-1)$ 个骰子的点数加上 $1$，最后直接输出即可。

其他的小细节在代码注释内。

### 代码

```cpp
/*
 * Author: Allen_123
 * Name: CF1790B
 * Time: 2023/1/27
 * Lang: C++11
 */
#include <bits/stdc++.h>
using namespace std;
int t, n, r, s;
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin >> t;
	while(t--){
		cin >> n >> s >> r;
		cout << s - r << " "; // 输出被拿走的那个骰子的点数
		n--; // n 在这里已经减 1，所以下一行计算不需要再让 n 减 1
		int av = r / n, num = r % n; // 计算平均值，和需要输出多少个比平均值多 1 的数
		for(int i = 1;i <= num;i++){ // 先输出 r % n 个平均值 + 1
			cout << av + 1 << " ";
		}
		for(int i = num + 1;i <= n;i++){ // 剩下的直接输出平均值即可
			cout << av << " ";
		}
		cout << "\n";
	}
	return 0;
}
```