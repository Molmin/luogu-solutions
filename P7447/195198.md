听完了 lxl 讲的倍增值域分块，感觉大受震撼。

下文令 $W$ 为值域范围。使用 $\log_k$ 而不是 $\log$ 是因为倍增值域分块可以选不同的底数进行分块，从而平衡复杂度。一般来讲，$k$ 增加 $1$ 倍，预处理复杂度减小 $1$ 倍，查询复杂度增加 $50\%$。

首先我们发现这个限制条件是一个二维条件，而且并不是树套树能够维护的，因为涉及到一个比大小问题。

因此考虑把值域进行压维：对 $i \in [0,\log_k n]$，把 $a$ 值在 $[k^i,k^{i+1}]$ 范围内的放在一个块中，每个块分别维护一个 $1 \sim n$ 的线段树。那么每次修改分成三种情况：

假设修改的参数为 $l,r,x$，令 $p=\log_k x$。

1. 对 $i<p$ 的块：无变化，不需要处理。

2. 对 $i=p$ 的块：维护一个最大值 $mx$，如果 $mx > x$ 那么说明这里是存在可以减掉的数的。由于 $k^p \leq x < mx \leq k^{p+1}$，所以一定有 $mx-x<k^p$。

	我们可以直接暴力找到这个数，减去 $x$ 之后放到对应值域的块上的线段树中。由于一个数每次这样操作完至少缩小 $k$ 倍，而我们每次操作这个数的复杂度为 $\log n$，所以单次操作均摊为 $O(\log n \log_k W)$。
    
3. 对 $i>p$ 的块：肯定是全部要减掉了。然后我们考虑维护一个最小值 $mn$，如果 $mn-x < k^i$ 说明有数字需要改变到更低的块内。我们直接暴力找到那个块。同上，每次复杂度 $O(\log n)$，一个数最多减小 $\log_k W$ 次，所以单次均摊复杂度 $O(\log n \log_k W)$。

因此我们直接分块之后维护线段树，每次修改按照上面三个步骤执行即可。

复杂度 $O(m \log n \log_k W)$。

但是空间会被卡，所以我们考虑把线段树底层的长度 $\leq L$ 的区间直接暴力处理。这样空间会大大降低，复杂度理论不变（只要 $L$ 在一个可接受的常数范围内。）。然后就做完了。