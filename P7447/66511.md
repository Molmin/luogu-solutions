## 简要题意
两个操作
1. 区间中 $> x$ 的数减去 $x$
2. 区间和，区间最大值，区间最小值

## 思路
首先这东西咋看之下像是一个第二分块。

然后一看值域人傻了，发现这不是第二分块的做法能承受的值域。

所以我们考虑一个 **与值域无关** 或 **log值域** 的做法，本题是后者。

这题不难发现是一复杂度分析的题目，我们考虑怎样使得它的复杂度正确。

首先有一种 naive 的想法就是对值域分块，假设 **块数** 为 $B$ 。每一个块开一棵 **序列线段树** ，每一个结点记录一个区间内的 $\max, \min, \sum$ 还有出现的数的个数，显然这些信息可以 $O(B\log n)$ 查询并合并得到。

然后每一次修改，我们考虑会出现 **值域块之间数值的移动** ，每一个值会至少移动 $O(B)$ 次，所以均摊下来就是 $O(Bn)$ 次查找。由于我们在线段树上修改，我们 **每次** 找一个数的复杂度应该是 $O(\log n)$ ，所以 **块间移动** 这部分的总复杂度是 $O(Bn\log n)$ 的。

但是这有一个前提，那就是我们找一个数的时候要能够 **准确找到所有会被移动的数** ，即我们不会在线段树上往下查询到一定深度了，才发现这个区间里没有会被移动的数。

然而我们不可能详细记录区间信息，我们还是只记录 $\min, \max$ ，现在就是要求我们通过这两个信息判断一个结点内是否有需要被修改的数。

这里我们可以分类讨论，首先假设我们修改的是 $x$，当前结点是 $\min = l, \max = r$ （注意这里是最大值最小值）。

我们显然可以分三类：

1. $x \ge r$ 显然对于这一个区间什么都不会发生，直接退出。
2. $x < l$ 这里我们显然只需要考虑 $l$ 是否会掉到其他的块里面。如果会，那么就暴力往下遍历，不难发现这样一定会最终遍历到需要 **块间移动** 的位置；如果不会，我们就给这个区间打上一个区间减的 $tag$ 就行了。
3. $x \in [l, r)$ 这里就比较难办了，不难发现 $[l, x]$ 之间的数并不会发生改变，而且仅凭一个 $r$ 并不能完全判断这个区间中是否有会掉到其他块内去的数，因为可能 $r$ 并不会掉到其他块中，但存在一个 $(x, r)$ 之间的数会掉到下一个块中，而且这样的数是否存在我们并不知道。

那么我们考虑怎么处理 $3$ 问题，我们回头看看，我们有什么地方还有改动的空间呢？

不难发现我们还没有定块长，而且这道题的复杂度似乎和块长没有关系，故 **块数越少越好** 。

并且，我们需要使得 $3$ 情况可以被判断，一个有效的思路是 **一旦** $x \in [l, r)$ **成立，那么这个块一定需要被修改** 。

即我们需要满足 $r-x<l$ 对 **同一块内** 一切 $(l, r)$ 的二元组成立。

不难发现 $r < l + x$ ，故 $r_{\max}=l+x-1$ ，又因为我们要保证这个式子对于任意 $x\in [l, r)$ 成立，故取最劣情况 $x=l$ 即 $r_{\max}=2l-1$ 。由于我们要使得块数尽可能少，我们取 $r=r_{\max}=2l-1$ 。

所以我们进行的就是类似 **倍增** 的 **不均匀分块** ，这个思路是真的妙。

不难发现块数 $B= \log V$ （ $V$ 为值域），所以总复杂度为 $O((n+m)\log n\log V)$ ，空间复杂度 $O(n\log V)$ 。

~~没错，一道分块题拥有了 polylog 的复杂度，没想到吧（（~~

但是赛后 lxl 卡空间了。。。毒瘤石锤了。

我们发现空间会炸的原因在于 $B$ 比较大，所以我们不得不把 $B$ 变小。

但是根据刚才的分析，这不已经是 $B$ 的最小值了吗？

此时就需要我们牺牲时间换空间了。

不难发现，我们之前讨论 $3$ 情况时直接钦定了 $r < l + x$ ，因为这样 $r$ 不会被多算。

那么，如果我们允许多算呢？

不难发现，若 $r \ge l + x$ ，那么每一次 **多算** $r$ 都会产生 $O(\log n)$ 的复杂度。

但是不难发现，每一次 **多算** ，$r$ 都会减少 $x$ ，而 $x$ 至少也是 $l$ 。

所以我们假设 $r < bl$ 即取 $r=bl-1$ ，此时 $B=\log_b V$ ，空间得到了优化。但是时间上要多一个 $O(b)$ 的常数，不过同样的我们可以少跳几次，故时空复杂度分别为 $O(Bb(n+m)\log n)$ ，$O(Bn)$ 。

简单算一算就会发现 $b=8$ 比较合适，时间退化不是很大的情况下把空间缩小到了原来的 $1\over 3$ 的样子。

但是这么一算还是要 $500 \text{MB}$ 的样子，不太行。

不过我们意识到我们用的数据结构是线段树，我们可以采取 **小于某个阈值即暴力** 的操作手段来进行空间优化，具体来说就是一个叶子结点表示的是一段长度为一个阈值 $k$ 的区间而非一个长度为 $1$ 的区间。

不难发现，$k$ 每扩大一倍，总空间就缩小一半（因为叶子结点被删没了，故一半结点没了），故 $k$ 足够大时空间会大大缩小。

发现 $k=16=2^4$ 时，总空间也除以 $16$ ，然后就没什么问题了。而且由于本来线段树跑最后几层也需要一定的常数，故时间上退化不会非常严重。

~~然而实测~~ $k=32$ ~~时效率更高（（~~

另外，如果使用动态开点的话，可能还要多维护一下左右儿子的标号，所以本题中对空间优化意义不大，故不选用。

~~这东西复杂度算起来感觉会非常屎，就当是个优化吧（（~~

~~据说叫什么 “底层分块” ？~~