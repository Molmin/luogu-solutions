个人认为难度在于想到倍增和卡常卡空间。                  

那时候打月赛的时候一直认为是分块，后来才知道有 polylog 做法并且是套了倍增？现在重想此题不得不说能想到倍增做这道题的人确实厉害，赛时好像是 EA 切掉的，膜拜。                   

对于此题我们考虑将值域分段，每个值域段下开一个普通的序列线段树维护操作 2 。               

考虑倍增值域分段，令数 $B$ 为我们的进制，那么将所有的 $[B ^ i , B^{i + 1})$ 作为我们的值域段，每个值域段的线段树只能维护值域在这个值域段里面的数。

考虑操作 $1$ 的 $x$ 的大小对于每个值域段里面的线段树的影响，分为三类：             

- 当前值域段上界 $\leq x$ 。此时我们的操作 $1$ 对该值域段无影响，直接跳过；              

- 当前值域下界超过 $\leq x$ 。此时我们的操作就相当于对这些值域段里面的数都要减去 $x$ ，也就是一个暴力的区间减是 $O(\log n)$ 级别的；                

- $x$ 在当前值域段上下界之间。可以证明当前只有一个值域段满足这个条件，并且此时的 $x$ 至少为值域段的下界。令值域段的上下界为 $R,L$，可以证明此时当前值域段里面的所有数在当前这个值域段里面只会进行 $O(\frac{R}{L} = B)$ 次的修改，所以我们暴力修改即可。           

不过我们发现这中间会涉及到一些数会变到另一个值域段里面去，这时候我们也暴力改就好了。           

我们来分析一下这么做的时间复杂度：           

对于情况一不说，情况二是正常的线段树，所以我们只分析情况三和所有的一个数从一个值域段换到另一个值域段里的过程：                    

- 令值域为 $v$ 。

- 对于情况三，一个数最多会走入 $O(\log_B v)$ 个值域段，那么一个数暴力更改的时间复杂度也就是 $O(\log_B v \times B)$ ，所有数的暴力修改时间复杂度就是 $O(n \log_B v \times B)$ 。            

- 对于所有的数更换值域段的时间复杂度是 $O(n \log n \times \log_B v)$ 的，单次插入 $O(\log n)$ ，共经历 $\log_B v$ 个值域段。

不过最后实现时，我们无法做到 $O(1)$ 查找一个数是否要更换值域段，所以只能线段树上面再暴力跑，这会导致总的时间复杂度大概是 $O(n \log_B v \times \log n \times B)$ 换算下来大约是一个小常数的 $O(n \log ^ 3 n)$，所以需要精细卡常调参。                   

对于卡空间，我们可以把线段树靠近叶子节点的点都不再细分，令阈值为 $Size$ 表示当当前节点如果表示的区间长不大于 $Size$ 我们就不再往下面新建节点，直接在这个节点下面调用 $a$ 数组即可，这就基本上把线段树的空间又卡回线性了。翻了下题解发现有人说这是底层分块，个人认为也倒不能算作分块吧，只是一种比较巧妙的运用题目性质的卡空间技巧？                 

个人把 $B,Size$ 都取的 $32$ 才勉强跑过，大家可以拿这个参数卡。

upd:2023/2/21

怎么以前的题解都长这么丑。

最优理论时间复杂度根据 $O(nB \log n \log_B V)$ 来调可以把 $B$ 调到 $2$ 使时间复杂度为 $O(n \log ^ 2 n)$，然后实现用动态开点之类的都行，空间可以卡到 $O(n)$。

但是以前我比较愚蠢，那时候这道题完全没什么自己的思考。所以实现的时候开了 $B$ 棵线段树，然后还莫名套了个底层分块，时间复杂度就高了点可能还需要反卡常一下才能过。但这道题确实让我学到了底层分块（