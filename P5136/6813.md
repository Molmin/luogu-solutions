~~打表找规律~~

既然都打出表来了，规律就不用手找了，直接扔OEIS上（逃

没错就是它！[A169986](http://oeis.org/A169986)

好我们直接拉那个递推公式：$a_n=a_{n-1}+2a_{n-2}-a_{n-3}-a_{n-4},a_1=2,a_2=3,a_3=5,a_4=7$。

接着对它矩阵快速幂。时间复杂度$O(4^3T\log n)$。看起来很不能过的样子。

对于这种底数不变的求幂，分块然后$O(1)$求是基本套路。

本题的$n$高达$10^18$，所以考虑分成$4$块，每块$\sqrt{\sqrt{n}}$个。然后每次求幂的复杂度降为$O(1)$，用初始状态左乘，常数大约$4\times 4^2=64$。

这样就砍掉一个$\log$，复杂度$O(64T)$。

当然用其他的矩阵小的转移方法可以做到更优的常数。

## Code：
```cpp
#include<cstdio>
#define md 998244353
#define M 32767
typedef long long LL;
struct matrix{
    int a[4][4];
    int r;
    matrix operator*(const matrix&b)const{
        matrix c;
        c.r=r;
        for(int i=0;i<r;++i)
        for(int j=0;j<4;++j){
            LL tmp=0;
            for(int k=0;k<4;++k)
            tmp+=LL(a[i][k])*b.a[k][j];
            c.a[i][j]=tmp%md;
        }
        return c;
    }
}_1[32769],_2[32769],_3[32769],_4[32769],a;
void init(){
	_1->r=_1[1].r=4;
	_1[1].a[0][0]=_1[1].a[0][1]=_1[1].a[1][2]=_1[1].a[2][3]=_1[0].a[0][0]=_1[0].a[1][1]=_1[0].a[2][2]=_1[0].a[3][3]=1;
	_1[1].a[1][0]=2;_1[1].a[2][0]=_1[1].a[3][0]=md-1;
	for(int i=2;i<=32768;++i)_1[i]=_1[i-1]*_1[1];
	*_2=*_1;_2[1]=_1[32768];
	for(int i=2;i<=32768;++i)_2[i]=_2[i-1]*_2[1];
	*_3=*_1;_3[1]=_2[32768];
	for(int i=2;i<=32768;++i)_3[i]=_3[i-1]*_3[1];
	*_4=*_1;_4[1]=_3[32768];
	for(int i=2;i<=32768;++i)_4[i]=_4[i-1]*_4[1];
}
int main(){
	init();
	a.r=1;
	a.a[0][0]=7,a.a[0][1]=5,a.a[0][2]=3,a.a[0][3]=2;
	int t;
	for(scanf("%d",&t);t--;){
		LL x;
		scanf("%lld",&x);--x;
		printf("%d\n",(a*_1[x&M]*_2[x>>15&M]*_3[x>>30&M]*_4[x>>45]).a[0][3]);
	}
	return 0;
}
```