容易分析，当
n = 1 或者 m = 1的时候，必然有策略（第二个接着第一个，之后的每一个都拿着凹口对着前一个）

当n != 1 且 m != 1的时候，只有n = 2 且m = 2的时候存在方案

因为一个方块只有一个凹槽，意思就是说方块的交接面一定不会多于方块个数，容易得到当方块不是线性排布的时候交接面个数仅有`2*2`的时候可行

（可以考虑：其他所有情况都是在`2*2`的基础上展开的，而每增加一列或者一行，增加的交接面个数除了每一个新增的和2*2的交接面，还有它们自己相互的交接面，必然超过4个）

```cpp
int T,n,m;

int main(){
    //std::ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
    //freopen("in.in", "r", stdin);
    cin >> T;
    while(T--){
        cin >> n >> m;
        if(n == 1 || m == 1) cout << "YES\n";
        else {
            if(n == 2 && m == 2) cout << "YES\n";
            else cout << "NO\n";
        }
    }


    return 0;
}
```