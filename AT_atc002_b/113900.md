此题就是快速幂取模

先简单讲一讲快速幂

首先，快速幂的目的就是做到快速求幂，假设我们要求a^b,按照朴素算法就是把a连乘b次，这样一来时间复杂度是O(b)也即是O(n)级别，快速幂能做到O(logn)，快了好多好多。它的原理如下：

　　假设我们要求a^b，那么其实b是可以拆成二进制的，该二进制数第i位的权为2^(i-1)，例如当b=11时

　　　　　　　　　　　　　　　　　　　　　　　　　　   a11=a(2^0+2^1+2^3)
                             
　　11的二进制是1011，11 = 2³×1 + 2²×0 + 2¹×1 + 2º×1，因此，我们将a¹¹转化为算 a2^0   *   a2^1   *   a2^3，也就是a1* a2* a8 ，看出来快的多了吧原来算11次，现在算三次，但是这三项貌似不好求的样子....不急，下面会有详细解释。                                
  
  由于是二进制，很自然地想到用位运算这个强大的工具：&和>>     &运算通常用于二进制取位操作，例如一个数 & 1 的结果就是取二进制的最末位。还可以判断奇偶x&1==0为偶，x&1==1为奇。 >>运算比较单纯,二进制去掉最后一位，不多说了，先放代码再解释。
  
  ```
int poww(int a, int b) {
    int ans=1,base=a;
    while(b!=0){
        if (b & 1 != 0)
            ans *= base;
            base *= base;
            b >>= 1;
    }
    return ans;
}
```
代码很短，死记也可行，但最好还是理解一下吧，其实也很好理解，以b==11为例，b=>1011,二进制从右向左算，但乘出来的顺序是 a^(2^0)* a^(2^1)* a^(2^3)，是从左向右的。我们不断的让base*=base目的即是累乘，以便随时对ans做出贡献。

　　其中要理解base* =base 这一步：因为 base* base==base2，下一步再乘，就是base2* base2==base4，然后同理  base4*  base4=base8，由此可以做到base-->base2-->base4-->base8-->base16-->base32.......指数正是 2^i ，再看上面的例子，a¹¹= a1* a2* a8，这三项就可以完美解决了，快速幂就是这样。
  
  
### 于是可得以下AC代码

```
#include<bits/stdc++.h>
using namespace std;
long long n,m,p;
long long quick_pow(){
    long long ans=1;//记录结果
    while(p){
        if(p%2){//如果p%2是1，那么我们的结果是要参与运算的
            ans*=n;
            ans%=m;
        }
        p/=2;//每次除以2
        n=n*n%m;//不断的加倍
    }
    return ans%m;
}
int main(){
    cin>>n>>m>>p;
    cout<<quick_pow()<<endl;
    return 0;
}
```
