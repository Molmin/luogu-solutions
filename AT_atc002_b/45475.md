~~既然没人，我来写吧~~


------------
# 显然，这是一道同余问题。



------------
## 针对此题，我先来举个栗子。
### 以下的=代表同余（蒟蒻不会打同余符号）

如何求3^89 mod 7呢？

3^1=3(mod 7)

3^2=3^2(mod 7)=2(mod 7)

3^4=(3^2)^2(mod 7)=2^2(mod 7)=4(mod 7)



------------
## 请谅解，实在太长了，之后的mod 7省略了。

3^8=(3^4)^2=4*2=2=2；

3^16=(3^8)^2=2^2=4;

3^32=(3^16)^2=4^2=2;

3^64=(3^32)^2=2^2=4;

3^89=(3^64)(3^16)(3^8)(3^1)=4x4x2x3=96=5;(没错，x是乘号。。。）

------------
## 下面开始文字解说 

所以，首先将p分解成2的幂次方，存放在一个数组r中，r【i】=1表示有n^i这一项。然后用递推的方法从小到大逐个求出n^i mod m 的值（j从i到1）存放在数组d中。



------------

## 然而，我们还可以利用以下递归公式进行求解：

x^y=

1、1(如果y=0)

2、x*x^(y-1)  (如果y是基数）

3、(x^2)^(y div 2)  (如果y是偶数)



### 刚才的div是除法的意思'/'

### 即y div 2=y/2；


------------
#### 也就是递归地对n进行二进制分解，同时计算。等价于将表达式分解成下面的形式：


------------
# 前方高能，做好准备！！！


------------
3^89

=(3^44)^2*3

=((3^22)^2)^2*3

=(((3^11)^2)^2)^2*3

=((((3^5)^2*3)^2)^2)^2)*3

=(((((3^2)^2*3)^2)^2)^2)*3



------------
###### 讲解结束，下面就是大家期待的代码 


```
#include<cstdio>
using namespace std;
long long m,n,p;
int main()
{
	scanf("%lld%lld%lld",&n,&m,&p);
	//n^p%m
	int ans=1;
	for(;p;p>>=1,n=n*n%m)
	{
		if(p&1)
			ans=ans*n%m;
	} 
	printf("%d\n",ans);
	return 0;
}
```

求过求赞