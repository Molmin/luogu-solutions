### 首先，在这道题里提及到了一些专业术语~~（好高深啊）~~，我们先来弄懂这些术语的意思：

#### 1.勾股数

度娘：勾股数又名毕氏三元数 。勾股数就是可以构成一个直角三角形三边的一组正整数。勾股定理：直角三角形两条直角边a、b的平方和等于斜边c的平方（a²+b²=c²）

[附百度百科链接](https://baike.baidu.com/item/勾股数/2674064?fr=aladdin)

#### 2.正弦值

度娘再一次出现：正弦值是在直角三角形中，对边的长比上斜边的长的值。 任意锐角的正弦值等于它的余角的余弦值，任意锐角的余弦值等于它的余角的正弦值。

附一张图：

![](https://pic.baike.soso.com/ugc/baikepic2/17464/20160809180643-1034329991.jpg/0)

说白了在本题中较小锐角的正弦值就是在同一个直角三角形中最长的那条边除以最短的那条边的商

[附百度百科链接](https://baike.sogou.com/v7662080.htm?fromTitle=正弦值)

### 好，那现在我们就来看看题目：

#### 题目描述

输入一组勾股数a,b,c（a≠b≠c），用分数格式输出其较小锐角的正弦值。（要求约分。）

较小锐角的正弦值在上面已经讲过了，但这里还有一个要求：
### 要求约分
这道题目还要求我们要约分，那用什么方法来约分呢？我在这里~~郑重地~~向大家推荐辗转相除法。

度娘的说法：两个数的最大公约数是指能同时整除它们的最大正整数。  设两数为a、b(a≥b)，求a和b最大公约数  的步骤如下： (1)用a除以b(a≥b)，得  。 (2)若  ，则  ； (3)若  ，则再用b除以  ，得  . (4)若  ，则  ；若  ，则继续用  除以  ，......，如此下去，直到能整除为止。 其最后一个余数为0的除数即为  的最大公约数。

这实在是太高深了，大家都听不懂，那我就换一个说法吧；

#### 1.辗转相除法是用来求两个数的最大公因数的。

#### 2.操作方法

副自制的一张图来帮助大家理解：（重复该过程）

![](https://cdn.luogu.com.cn/upload/pic/41807.png)

注：a为两数中的小数，b为两数中的大数。

### 上代码：（不要急着复制粘贴，不然你会后悔的）
```cpp
#include<bits/stdc++.h>
using namespace std;
long long d[10],a,c,t;
int main()
{
	cin>>d[1]>>d[2]>>d[3];
	sort(d+1,d+1+3);
	a=d[1];
	c=d[3];
    while(c!=0)
    {
        t=a;
        a=c;
        c=t%c;
    }
    d[1]=d[1]/a;
    d[3]=d[3]/a;
    cout<<d[1]/a<<"/"<<d[3]/a;
	return 0;
}
```
这是我第一次提交时的80分代码，大家认真看看，是不是有点不对？
```cpp
d[1]=d[1]/a;
d[3]=d[3]/a;
```
和
```cpp
cout<<d[1]/a<<"/"<<d[3]/a;
```
这两段代码中的d[1]/a和d[3]/a必须删掉一组，不然会错误。

吐槽：这题真应该加强数据，就我这错的那么离谱的程序，居然都可以拿到80分...（逃）

第二次提交时就删掉了上述两段程序中的一段，就AC了。

### 100分AC代码（附说明）：
```cpp
#include<bits/stdc++.h>//万能头文件
using namespace std;
long long d[10],a,c,t;
int main()
{
	cin>>d[1]>>d[2]>>d[3];
	sort(d+1,d+1+3);//我比较懒，输入数组，直接sort快排
	a=d[1];//a是对边
	c=d[3];//c是斜边
    while(a!=0)
    {
        t=c;
        c=a;
        a=t%a;
    }//辗转相除法，上面讲过了
    d[1]=d[1]/c;
    d[3]=d[3]/c;//约分
    cout<<d[1]<<"/"<<d[3];//输出
	return 0;//程序拜拜
}
```