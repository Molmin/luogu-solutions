> 给出串 $S$ ，请问满足 $A_{n-1}$ 在 $A_n$ 中出现至少两次且都是 $S$ 子串的字符串序列 $A$ 的最长长度是多少？
>
> $1\le n\le 2\times 10^5$

这道题是 TLE_Automat 大佬给我的题。~~（在线膜 TAM %%）~~ 然后看了眼，好啊，不会啊，这看起来完全不可做啊。

但是稍微想一想之后，就可以从基本贪心取得一个结论：$A_{n-1}$ 必定是 $A_n$ 的后缀，因为如果不是的话你可以将 $A_n$ 的一个后缀删去。

接着从后缀链的性质可以看出来，$A_{n-1}$ 和 $A_n$ 必定在同一后缀链上的两个等价类中出现，这也就意味着 $A$ 序列上的字符串必定都在同一后缀链的等价类中出现。

在这个方向开始构想之后，就有几个结论便需要我们证明。

​		$\text{Conclusion 1}$  不可能存在 $A_n$ 和 $A_n-1$ 在同一个等价类出现的情况。

​	证明：如果存在这种情况的话，那么由 $A_n$ 和 $A_{n-1}$ 在同一等价类的条件可以得出 $A_n$ 有一个 $\text{endpos}$ 恰好在自己内。所以，这个模式会一直向左右延伸，直到串的尽头，而这时，$A_n$ 和 $A_{n-1}$ 也不可能 $\text{endpos}$ 相同，因此结论成立。

这个结论其实也说明，一个等价类内的任意两个字符串最多以某一方向包含 $1$ 次。

​		$\text{Conclusion 2}$  在后缀链上跳跃时，只要选定了一个起点，总是向上跳最矮的高度总是最优的。

​	证明：显然，不证了。

通过这两个结论，我们发现，我们要做的其实就是对于每一个等价类，找到一个离它最近的 parent 树上祖先满足它的这个祖先可以在它出现两次。现在的问题也许你已经发现了，我们刚刚的描述对于字符串和等价类十分混淆，这其实是因为我们还没有确定等价类和字符串在这个问题中的关系。换言之：给你两个等价类，你怎么在每一个等价类内选出一个字符串然后判定它们两个是否以某种方向出现两次呢？

​		$\text{Conclusion 3}$  为一个等价类作代表的字符串是恰好是这个等价类中最长的字符串，即，

​		如果 $\text{str}(u)\mathop{\not\subset}\limits^\text{Twice}str(v)$ ，那么不存在 $s\in u$ 使得 $s\mathop{\subset}\limits^\text{Twice}str(v)$ ，最短的也不行。

​	证明：首先，等价类 $v$ 选出自己最长的字符串 $str(v)$ 是很明智的。我们现在只需要证明无论等价类 $u$ 选出最长的或是最短的字符串都无关结果即可。

​	若存在这么两个等价类 $u$ 和 $v$ ，$\text{str}(u)=A+B$ ，$B$ 在 $\operatorname{str}(v)$ 中出现两次，而 $A+B$ 则只有一次。

​	我们考虑两种情况：第一种情况是 $\text{str}(v)$ 的所有出现只有一次前面恰好有 $A$  。这种情况下，$A+B$ 的 $\text{endpos}$ 显然跟 $B$ 的$\text{endpos}$ 不同，等价类 $u$ 不存在；第二种情况是 $\text{str}(v)$ 的所有出现前面都恰好有 $A$  ，此时 $A+str(v)$ 的 $\text{endpos}$ 恰好与 $v$ 的 $\text{endpos}$ 一致，等价类 $v$ 不存在，结论一定成立。

至于刚刚的这个结论以及其证明是怎么想出来的，实际上我是瞎 jr 找例子试出这个结论之后再想办法构造证明的，这个结论非常不显然。

于是，我们用每个等价类的 $\text{str}$ 来代替这个等价类是正确的，这也暗示 $A_{-1}$ 一定是某一个等价类的 $\text{str}$ 。

现在，我们假设给定两个节点的 $\text{str}$ 我们判定其中一个是否在另一个出现两次的时间复杂度为 $f(n)$ 。我们现在只关心我们最少要判定多少次才能对每一个点都找到它的最近可以跳的祖先。

![](https://cdn.luogu.com.cn/upload/image_hosting/0ai8uq79.png?x-oss-process=image/resize,m_lfit,h_1000,w_400)

我们考虑这么一棵 parent 树。请问，节点 $4$ 的跳跃边有没有可能指向 $3$ 呢？那有没有可能指向 $1$ 呢？

答案是，不可能指向 $3$ ，但是可能指向 $1$ 。具体为什么请您独立思考，这个问题非常简单，写出证明是在这里浪费空间。

或者，我们形式化地表达这个规律：我们设 $\text{jump}(x)$ 表示节点 $x$ 的跳跃边的最终节点。那么
$$
\text{dep}(\text{jump}(x))=\min_{e\in son_x}\{\text{dep}(\text{jump}(e))\}
$$
所以，这个式子有什么用吗？你会发现，如果 parent 树恰好是条链，这个式子的意义就是尺取算法，而尺取算法的判定数是 $O(n)$ 级别的。那么，我们把尺取放到树上，这个算法的时间复杂度是什么呢？这里可以使用势能法来证明，但是扰动法却更简单一点。

由于树是一条链时判定数是 $O(n)$ 的，并且在你加入了一条新链之后，除了新链以外的其他部分的判定数只减不增，而新链这个部分的判定数仍是 $O(size)$ 的，于是添加一条链后判定数仍为 $O(n)$ ，其中 $n$ 为现在树的节点个数。

现在我们考虑如何进行判定。像 3.6 的套路一样，维护 $\text{endpos}$ 集，判定是否 $u$ 两次包含 $v$ 时只需要在 $u$ 的 $\text{endpos}$ 中随便找出来一个值 $x$ ，然后看是否在 $[x-\text{len}(u)+1,x]$ 内存在两个 $\text{endpos}(v)$ 的元素即可，上述操作均可在 $O(\log |S|)$ 内完成，而 parent 树的节点数又是 $O(|S|)$ 的，于是总时间复杂度为 $O(|S| \log |S|)$ ，是可接受的范围。

找到 $\text{jump}$ 链接之后的 dp 非常简单，我觉得大家都会，所以不再浪费空间了。

~~最后吐槽：为什么要用玄学 DP 呢，势能分析数据结构多香啊~~
