子串重复出现的问题，自然要考虑 SAM。

为了更契合 SAM 以及 $\mathrm{endpos}$ 相关的性质，我们发现如果把 $s_{i-1}$ 在 $s_i$ 中第一次出现的开头到第二次出现的结尾这一部分作为新的 $s_i$ 一定是不劣的，这样的 $s_i$ 更短，更好满足下一次匹配。

比较显然的事情是答案（指根据上面修改后的答案）一定位于后缀链接树的一条链上，且同一个节点最多出现一次（$\mathrm{endpos}$ 相同，不可能有题目要求的关系），于是从短到长，即从根到叶子计算。

首先常规地用线段树合并维护出 $\mathrm{endpos}$ 集合，剩下的算法流程在此基础上展开。

容易看出，如果拿出 $u$ 节点 $\mathrm{endpos}$ 的第一个元素，即可判断 $u$ 节点是否存在子串可以作为下一个 $s_i$。

贪心地思考，如果某一节点有多个子串满足条件，那么选取最短的一个是最优的。

根据上面两条信息，注意到在已知 $s_{i-1}$ 的来源 $u$ 的基础上，判断 $v$ 能否作为 $s_i$ 的信息实际是 $O(1)$ 的，即拿出 $v$ $\mathrm{endpos}$ 中的第一个元素与 $u$ 中满足条件的最短子串判断。

判断其实相当简单，设 $v$ $\mathrm{endpos}$ 中的一个元素为 $j$，找到 $j$ 在 $u$ $\mathrm{endpos}$ 中的前驱 $pre$，如果 $[pre-|s_{i-1}|+1,j]$ 这个子串是在 $v$ 内的，就说明 $v$ 可以作为 $s_i$，且 $s_i$ 最优选择就是上面这个子串，反之则不能。

所以只需要线段树查询前驱，复杂度是 $O(n\log n)$。