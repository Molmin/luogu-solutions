### 本蒟蒻第一次写题解，如有问题，请多多包涵

这道题有几个要注意的点：  

1. 注意输入的坐标是包括本身的，也就是说，**自己也要删除**。~~我看题时就半天没有看懂为啥是删除8个~~

1. 一个位置被删除了之后是不能再次删除的，**所以要创建一个三维数组来判断是否已经删除了**。（本人测试过，**每一个**数据点都有这样的情况）

所以根据上面的要点，我们可以推出步骤：  

1. 用一个**三维**的布尔类型数组存储是否删除过。

1. 创建一个**结构体**，里面存储要删除的位置。（当然可以不用，直接6个数组也好，个人喜好）

1. 输入完了以后直接四层for循环。第一层从1循环到 q ，表示有多少个需要删除的数据。第二、第三、第四层分别从删除的起点循环到删除的终点，同时判断该点**是否已经被删除**，如果是，跳过；否则删除该点。

更详细的解释在代码里面有，所以上代码啦！

```
#include<bits/stdc++.h>//万能头文件不解释

#define maxx 20//多用 define 你会发现特别方便

using namespace std;

struct node{//创建结构体
	int x1;
	int y1;
	int z1;
	int x2;
	int y2;
	int z2;
}l[101];//用来存要删除的点的数组

int x,y,z,q;//题目要求的变量
int ans;//存答案
bool a[maxx + 1][maxx + 1][maxx + 1];//判断是否已经被删除

int main(){
	memset(a,true,sizeof(a));//先重置，true表示没有删除，false表示已删除
	cin>>x>>y>>z>>q;//输入数据
	ans = x * y * z;// ans 设为立方体的大小，删除一块减去一
	for(int i = 1;i <= q;i ++){//输入数据不解释
		int xx1,yy1,zz1,xx2,yy2,zz2;
		cin>>xx1>>yy1>>zz1>>xx2>>yy2>>zz2;
		l[i].x1 = xx1;
		l[i].y1 = yy1;
		l[i].z1 = zz1;
		l[i].x2 = xx2;
		l[i].y2 = yy2;
		l[i].z2 = zz2;
	}
	for(int i = 1;i <= q;i ++)
		for(int j = l[i].x1;j <= l[i].x2;j ++)
			for(int k = l[i].y1;k <= l[i].y2;k ++)
				for(int p = l[i].z1;p <= l[i].z2;p ++)if(a[j][k][p] == true){//如果还没有删除的话
					a[j][k][p] = false;//设为已删除
					ans --;//从总数里减去一块
				}
	cout<<ans;//输出答案
	return 0;//养成好习惯使用 return 0
}
```

好了，这道题就是这样。最后，跟我一起念：

### 共建文明洛谷，抵制抄袭行为！！！

蒟蒻第一次写题解，管理员大大求给通过QAQ。

~~拜拜~~