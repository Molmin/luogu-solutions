6种不同做法。

# 1.dfs做法

从初始点出发，不断寻找通往终点的路径。

小剪枝：

标记每个点，$b[x][y][flag]$ 表示 $(x,y)$ 点跨过障碍 $flag(flag∈[0,1])$ 次时有没有访问过。

时间复杂度 $O(nm)$ 。

# 2.bfs做法

两次宽搜，一次从起始点出发，一次从终点出发，遇到障碍停下来。

再枚举每个障碍的两侧，看看翻过这个障碍能否到达终点宽搜的这颗搜索树的某个节点。

换句话说，从起始点染色，从终止点染上另一种颜色，枚举每个障碍物的两侧，判断两侧是否是访问过而且染上了不同颜色。

时间复杂度 $O(nm)$ 。

# 3.SPFA做法

建图：对于每个枚举的点，往4个方向判断，如果碰到障碍就当它边权为1，没有碰到就是边权为0。

然后直接跑SPFA。。。

---

或者说在SPFA的过程中直接处理边权，更香。

---

这个SPFA应该不会被卡（

时间复杂度 $O(tnm)$  ，$t$ 应该是非常小的一个常数。

# 4.dijkstra做法(1)

考虑使用SPFA框架。

使用优先队列进行优化，在松弛周围4个节点时算出边权，然后跑普通的dijkstra。

时间复杂度 $O(nm \log(4nm))$ 。

# 5.dijkstra做法(2)

使用普通dijkstra框架。

老规矩，松弛时算出边权，然后发现选 $dis[i][j]$ 最小值还是要使用暴力。怎么办呢？

线段树/zkw线段树/堆 呗。

使用线段树，只用解决单点修改、全局查询即可。

使用堆，只用支持任意元素修改操作即可。注意堆中的值不是dist值。

时间复杂度 $O(nm\log(nm))$ 。

# 6.bfs/SPFA+LLL/SLF（？）

双端队列bfs，权值为0丢到队首，权值为1丢到队尾。

或者开两个队列，一个权值为 0 的，一个权值为1的。

处理完权值为 0 的再处理权值为1的。

时间复杂度 $O(nm)$ 。