重点在于证明：

因为每个钱袋只有两种状态——取或不取，取则总钱数+1\*该钱袋钱数，不取则总钱数+0\*该钱袋钱数,。**裸裸的二进制！**

当每个钱袋的钱数取**二进制每一位的权值**时，若有k个，则能表示**2^k-1个数**（从0~2^k-1，即从0（二进制）到11…1（还是二进制））。

并且，很明显，每个钱袋**钱数不重复**，从而为**最优解**！

当然，数据没那么弱，还会**多出一些钱**，\_但不能丢掉\_（手动滑稽），于是还需处理（重复则**左--，右++**即可，因为**有1**，但因此**不能动1**，需**特判**）

贴一下代码，不加注释了，相信你们看得（bu）懂，也方便你们抄，但我开了防作弊（通通划掉）

···cpp

```cpp
#include<iostream>
#include<algorithm>
using namespace std;
long long m,s,k=0,a[50];
int main()
{
    cin>>m;
    for (long long i=1;i<=(m+1)/2;i*=2)
    {
        a[k]=i;
        k++;
        s+=i;
    }
    if (m!=s) a[k]=m-s; else k--;
    sort(a,a+k);
    for (int i=0;i<=k;i++)
        if (i!=0&&a[i]==a[i+1])
        {
            a[i]--;
            a[i+1]++;
        }
    cout<<k+1<<endl;
    for (int i=0;i<=k;i++) cout<<a[i]<<' ';
    return 0;
}
```
```cpp