
这题其实很水

只要学了快排和二分（二进制）就可以了

思路有点难：（就是想二分有点难）

1，二分

为什么要二分呢？

本题题意是：

不能有钱数相同的钱袋。

二分n，就可以解决。

2，快排（保险）

我的二分后，有几个数不是从小到大排的

核心代码:


```cpp
while(t)
{
    if(t-l>0){a[++c]=l;t-=l;l*=2;}//如果可以分下去到下个2的c+1次方 
    else if(t!=0) //否则t就要进行处理（t==0就已经分完了） 
    {
        if(t==1){a[c]++;t=0;}//如果t==1，把剩下的1加到最后一个就数可以了 
        else if(t%2==1){a[++c]=t;t=0;}//如果t是奇数，把 t存下 
        else if(t>a[c]){a[++c]=t;t=0;}//如果t是大于最后一个数又是偶数，把 t存下  
        else {a[c]++;a[++c]=t-1;t=0;}// 如果t是小于最后一个数又是偶数，把剩下的t加到最后一个数 
    }
}
```
**完整代码：**
```cpp
#include<cstdio>
int a[110];
void dfs(int x,int y)//快排（也可以用sort） 
{
    int l=x,r=y,m=a[(l+r)/2];
    while(x<=y)
    {
        while(a[x]<m)x++;
        while(a[y]>m)y--;
        if(x<=y)
        {
            int t=a[x];a[x]=a[y];a[y]=t;
            x++;y--;
        }
    }
    if(x<r)dfs(x,r);
    if(y>l)dfs(l,y);
}
int main()
{
    int n;scanf("%d",&n);//输入 
    int l=1,c=0,t=n;//二分会破坏n所以用t存n
    //t表示2的c次方，c表示2的第几次方（从2的0次方开始） 
    while(t)
    {
        if(t-l>0){a[++c]=l;t-=l;l*=2;}//如果可以分下去到下个2的c+1次方 
        else if(t!=0) //否则t就要进行处理（t==0就已经分完了） 
        {
            if(t==1){a[c]++;t=0;}//如果t==1，把剩下的1加到最后一个就数可以了 
            else if(t%2==1){a[++c]=t;t=0;}//如果t是奇数，把 t存下 
            else if(t>a[c]){a[++c]=t;t=0;}//如果t是大于最后一个数又是偶数，把 t存下  
            else {a[c]++;a[++c]=t-1;t=0;}// 如果t是小于最后一个数又是偶数，把剩下的t加到最后一个数 
        }
    }
    dfs(1,c);//快排 
    printf("%d\n",c);//输出钱袋个数 
    for(int i=1;i<=c;i++)//从小到大输出第i个钱袋 
    {
        printf("%d ",a[i]);
    }
}
```