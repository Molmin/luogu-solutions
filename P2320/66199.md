# ~~来个神奇的解法~~
蒟蒻题解，大佬勿喷
### 首先，如果可以有任意重复的袋子，怎么做呢
**既然是求最小袋数**

**那我们就换个问题**~~（手动滑稽）~~

如果给你固定数量的袋子，最多能够给出多少种不同价值的组合呢？

既然不同价值的组合要多，那么就要让同种价值组合的解法尽量少

 _举个栗子_ ：如果给你5个袋子，这么分：1，2，3，4，5；

那么如果你要拿5的价值，就会有三种解法:1+4，2+3，5，显然是浪费

究竟怎么样才能使每一种价值只有一种解法呢？

考虑二进制的思想：**任何一种01串都有不同的值**

于是就可以发现：如果分成1，2，4，8，16，那么每种价值只有一种解法，可以任意分配1~31的价值，显然是个好分法

这样就可以解答前面的问题了：**以1，2，4，8，16等2^n的数分，直分不了为止**

## 现在让我们回到原题
按照上面的玩法，先按照1，2，4，8，16……设剩下的为x

题目说除了1以外不可以有别的重复价值袋子

如果x不是>1的2^n数，那么直接装一袋，好办

**关键是考虑x是>1的2^n数的情况**

因为需要保证每个1~n的数都可以有解法，所以需要一个可以组合成x的替代品

试试看1+(x-1)，如果这么做，那么另一个x就变成了x+1

看看还可不可以组成1~n的所有数（设该数=a）

1：a的二进制中x值的位=0，则没有关系

2：a的二进制中x值的位=1但第一位=0，则x可以用1+(x-1)替代掉

3：a的二进制中x值的位=1但第一位=1，则可以x+1替代掉

_举个栗子_ ：19=1+2+4+8+4，于是x=4=2^2，

那么就可以分成1，2，3，5，8（4+4被拆成3+5）

如果a的二进制中用到4但不用到1，可以用1+3代替

如果a的二进制中用到4而且用到1，可以用5代替

**综上**，上代码~~（手动滑稽）~~//代码中x用m代替
```cpp
#include<iostream>
#include<cmath>
using namespace std;
#define int long long
int m,lg;
signed main(){
    cin>>m,lg=log2(m+1),m-=(1<<lg)-1;//求出分成1,2,4,8……的数量和m=x
    cout<<lg+(m?1:0)<<endl;//如果刚好分完当然不用加了
    for(int i(0);i<lg;++i){//考虑所有2^n
        if(m&&m==(1<<i))cout<<m-1<<' '<<m+1<<' ',m=0;//撞上了，分成x-1和x+1
        else if(m&&(1<<i)<m&&m<(1<<(i+1)))cout<<(1<<i)<<' '<<m<<' ',m=0;//没撞上，直接输
        else cout<<(1<<i)<<' ';
    }
    return 0;
}
```