## 题面描述

输入 $n$ 个数 $a_1, a_2, \dots, a_n$，保证严格递增。

如果一个序列 $x_1, x_2, \dots, x_k$ 能够满足条件，那就是一个好序列：

- $\forall i \in [1, k)$，有 $x_i < x_{i+1}$；
- $\forall i \in [1, k)$，有 $\gcd(x_i, x_{i+1}) > 1$；
- $\forall i \in [1, k]$，有 $x_i \in a$。

问序列最长是多少。

$1 \le n, a_i \le 10^5$

## 分析

考虑 `DP`。

一共有 $3$ 个条件，其中条件 $1, 3$ 提示了我们需要找一个 $a$ 中的上升子序列。由于 $a$ 本身就是严格递增的，所以题目可以简化成从 $a$ 中找出一个子序列，满足相邻两项不互质。

我们可以通过类似找最长上升子序列的方法，定义状态 $f_i$ 表示以 $i$ 结尾的满足条件的最长子序列，那么转移即：
$$
f_i = \max_{\gcd(a_i, a_j) > 1} (f_j + 1)
$$
总时间复杂度为 $\Theta(n^2\log n)$。

这样是不可行的。接下来考虑优化。

如果两个数不互质，那么它们必定有一个相同的**质因子**。在上面的转移中实际上就是在找与 $a_i$ 有相同质因子的 $a_j$ 的 $f_j + 1$，而这个值可以直接统计出来。

具体地，定义 $g_i$ 表示表示含有质因子 $i$ 的 $a_j$ 的 $f_j$ 的最大值，那么转移时只需要枚举 $a_i$ 的所有质因子 $j$，并找到最大的 $g_j + 1$ 即可。转移为：
$$
f_i = \max_{j \mid i, j\text{ is a prime}} (g_j + 1)
$$
同时，在更新完 $f_i$ 的答案后，还需要尝试更新 $i$ 的质因子 $j$ 的 $g_j$ 的值。然后统计最大的 $f_i$ 即可。

上述转移中寻找 $i$ 的质因子可以 $\Theta(\sqrt n)$ 的复杂度求解，因此整个算法的时间复杂度为 $\Theta(n\sqrt n)$。

[$\text{Code}$](https://www.luogu.com.cn/paste/yf4eflt8)