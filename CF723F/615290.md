将边分为三类：

1. 不与 $s$ 和 $t$ 相连；
2. 只与 $s$ 和 $t$ 中的任意一个相连；
3. 连接 $s$ 和 $t$。

对于第一类边，加入时不会对结果产生影响，可以任意加入，且越多越好。

对于第二和第三类边，加入时均会占用 $d_s$ 和/或 $d_t$ 的剩余容量，且第三类边会同时占用。

考虑对边加权，使每条边的边权等于其连接的两个点中的 $s$ 和 $t$ 的数量（即，第一类边边权为 $0$，第二类边为 $1$，第三类边为 $2$）。

接下来再跑 Kruskal，就可以做到优先加入第一类边，然后第二类，再是第三类。加边过程中同时维护 $d_s$ 和 $d_t$，若加入后无法满足则跳过这条边。最后再判定加入边数是否为 $n-1$。

[代码](https://codeforces.com/problemset/submission/723/190987337)

然而这样贪心会 WA on 68。

以下是第 68 组数据：

```
5 5
1 3
1 4
1 5
2 3
2 4
1 2 2 2
```

上述代码错判了无解。

观察数据，因为每条边都属于第二类边，上述代码会直接按读入顺序进行加边，导致结点 3,4 被占用，结点 2 只连出一条边，结点 1 却连出了 3 条。

但是，不难发现，只需要换一个读入顺序就不会出错。

于是，在加上 ``random_shuffle`` 之后，我们通过了此题。

[代码](https://codeforces.com/problemset/submission/723/190988287)

~~（这就是这道简单题能评 2300 的原因？）~~

咳咳，上面的只是一种基于随机化的乱搞而已，请勿模仿。下面来说说正解。

一开始的错误代码错在了加边的顺序。我们对加边权的策略进行一点调整：对于所有与点 $s$ 直接相连的边，将其边权加上 1；对于所有与点 $t$ 直接相连的边，将其边权加上 2。这样就保证了只与点 $s$ 相连的边会比所有只与 $t$ 相连的边更早尝试加入。

将加边策略反过来，就可以保证只与点 $t$ 相连的边会比所有只与 $s$ 相连的边更早尝试加入。

跑两遍 Kruskal 即可。

代码不难，在原来的基础上改改就行，此处不作展示。~~（因为我懒得写了）~~