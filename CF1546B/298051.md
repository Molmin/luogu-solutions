考虑去掉 1 个字符串之后的 $n-1$ 个字符串和交换字符+随机重排后的 $n-1$ 个字符串。由于两种操作均不改变字符所处的位置。  
举个例子，假如原来有一个字符是某个字符串中的第三个，那么这一波操作完了之后它一定还在某个字符串（可能不是原来的字符串）中的第三个。  

那么答案就呼之欲出了：对于每一位，找到原来 $n$ 个字符串比 $n-1$ 个字符串多的一个字符填进去即可。考虑对于每一位，将这 $2n-1$ 个字符串联在一起，那么一定是被去除的那个字符出现奇数次，其它的都出现偶数次。  
由于异或在满足交换结合律的同时还满足 $a ⊕ a =0$ ，那么全部 $2n-1$ 个字符的异或一定就是唯一一个出现了奇数次的字符。  

*总结：对于 $2n-1$ 个字符串的每一位，异或这一位上所有的字符并输出结果*

代码：  
```cpp
/*
    Code by xkcdjerry
    Time: 2021-07-11
    Generated by cf-tools
*/
#include <cstdio>
#include <cstdlib>

#define int long long
/*
   实际也把原来的可以全部加起来然后减去所有交换过的
   但是这样需要把两者分开处理，会增加复杂度
   而且在某些题中还可能会爆long long
   所以异或代码量低速度快而且还不容易错
   
   代码复杂度：O(sum(nm)) < 1e5
*/
#define N 100010
#define M 100010
char s[M];
int XOR[M];
void once()
{
    int n,m;
	scanf("%lld%lld",&n,&m);
	for(int i=1;i<2*n;i++)
	{
		scanf("%s",s);
		for(int j=0;j<m;j++)
			XOR[j]^=s[j];
	}
	for(int i=0;i<m;i++)
	{
		putchar(XOR[i]);
		XOR[i]=0;
	}
	putchar('\n');
	fflush(stdout);
}
#undef int


int main()
{
    int t;
    scanf("%d",&t);
    while(t--) once();
    return 0;
}
```