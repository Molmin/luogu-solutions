这题我们首先考虑将所有点都放在一个集合里，然后取出 $\frac{n}{2}$ 个点放入另一个集合。这一步骤可以用 dfs 来实现。  

**先不考虑时间**，我们可以想到做 $\dfrac{n}{2}$ 次，每次取出一个在原集合中的点放入第二个集合中，然后计算贡献，贡献为取出的这个点与原集合的点的连边数减去与另一个集合的点的连边数。  
但是这个算法太慢了，无法通过此题。

考虑优化上面的那个算法，从数据范围入手，发现 $n \le 26$，可以使用状压，将点 $i$ 的连边压缩成一个二进制数 $g_i$，第 $j$ 位为 $1$ 代表 $i$ 与 $j$ 有边。我们再将两个集合压缩成二进制数 $S_1$ 和 $S_2$，第 $i$ 位为 $1$ 代表点 $i$ 在集合中。  
可以发现的，$g_i$ 与 S_1 做 `&` 操作得到的结果就是点 $i$ 与 $S1$ 中的点的连边数，$g_i$ 与 $S_2$ 同理。  
如果我们能预处理出所有需要用到的数在二进制下 $1$ 的个数，则可以大大优化这个算法。  
可惜，这个数最大有 $2^{26}=67108864$，太大了，预处理不来。  
但是我们可以分段，将它分为前 $13$ 位和后 $13$ 位，那么只需要预处理出 $2^{13}=8192$ 即可。

但是出题人太毒瘤了，这样优化后依然会大面积 TLE，我们还需要对 dfs 进行剪枝。  
如果上一个取出的数是 $i$，那么如果再去取 $1$~$i-1$ 中的数，与之前取 $1$~$i-1$ 中的数，再取 $i$是同一个方案。也就是说，取数的顺序不会影响结果。那么，若前一次取 $x$，则下一次只要在 $x+1$~$n$ 中取，可以砍掉许多无用的方案。

加上上面两个优化，即可通过此题。
```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
int n,m,ans=1e9;
int S,S1,S2,g[30];
int one[1<<13];
int Calc(int _S)
{
	return one[_S>>13]+one[_S^((_S>>13)<<13)];
}
void dfs(int p,int now,int sum)
//p是上一个取的点，now是当前S2中点的个数，sum为贡献
{
	if(now==n/2+1)
	{
		if(sum<ans) ans=sum,S=S1;
		return ;
	}
	for(int i=p+1;i<=n;i++)
		if(S1&(1<<(i-1)))
		{
			S1^=1<<(i-1);
			S2|=1<<(i-1);
			dfs(i,now+1,sum+Calc(g[i]&S1)-Calc(g[i]&S2));
			S1|=1<<(i-1);
			S2^=1<<(i-1);
		}
	return ;
}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<(1<<13);i++)
		one[i]=one[i>>1]+(i&1);
	for(int i=1;i<=m;i++)
	{
		int u,v;
		scanf("%d%d",&u,&v);
		g[u]|=1<<(v-1);
		g[v]|=1<<(u-1);
	}
	S1=(1<<n)-1;
	dfs(0,1,0);
	for(int i=1;i<=n;i++)
		if(S&(1<<(i-1))) printf("%d ",i);
	return 0;
}
```

这里稍微提一下，有一种错误的方法是 dfs 每次枚举一个点选获不选，然后去抉择下一个点，这样的复杂度是 $O(2^n)$ 的，是无法通过此题的。