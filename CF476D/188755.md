[传送门](https://www.luogu.com.cn/problem/CF476D)

前置芝士：

1. 对于一个四元组 $ {a,b,c,d} $ 若其最大公约数为 $m$，则四元组 $ {ak,bk,ck,dk} $ 的最大公约数为 $mk$。

2. 任意两个偶数的最大公约数最小为 $2$。

3. 对于连续的 $n$ 个正整数，有且仅有一个为 $n$ 的倍数。

由 $1$ 可易将本题 $k>1$ 的情况转化为 $k=1$，那么就只需考虑 $k=1$ 时的情况。

然后由 $2$ 可得，满足题面要求的四元组中最多只能有一个偶数，考虑一个四元组包含三个奇数和一个偶数。

假设该四元组为 $ {3i-2,3i-1,3i,3i+2} $，$i$ 为正奇数，即 $3i-2$，$3i$，$3i+2$ 为奇数，$3i-1$ 为偶数，那么结合 $3$ 可证该四元组中最多只有一个数为 $5$ 的倍数，并且只有 $3i$ 为 $3$ 的倍数，根据 $3$ 可进一步推出该四元组中任意两个数不可能同时为大于 $5$ 的整数的倍数，从而可得该四元组符合要求。

因为构造该四元组奇数的增长速度比偶数快，故要使方案最优只需确保相邻四元组奇数连续。易证 $(3i+2)+2=3(i+2)-2$，所以这种构造方案为最优解。

同理，所有四元组中的最大数为 $3\times(2n-1)$。

时间复杂度为 $O(n)$。

------------

```cpp
//いつもこのような人がいます。優しくしてあげたいです。
#include <bits/stdc++.h>
using namespace std;
int n,k,i,p;
inline int read()//快读
{
	int s=0,f=1;
	char c=getchar();
	while(c<'0'||c>'9')
	{
		if(c=='-') f=-1;
		c=getchar();
	}
	while(c>='0'&&c<='9')
	{
		s=(s<<3)+(s<<1)+c-'0';
		c=getchar();
	}
	return s*f;
}
signed main()
{
	n=read(),k=read();
	printf("%d\n",((n*2-1)*3+2)*k);
	for(i=1;i<=n;i++)
	{
		p=(i*2-1)*3;
		printf("%d %d %d %d\n",(p-2)*k,(p-1)*k,p*k,(p+2)*k);
	}
	return 0;
}
```
