假设一共有 $c$ 个 $1$ ，$2^{d-1}<c \leq 2^d$ （先把 $c=0$ 判掉）。

然后划分方案很多种，连续 $x$ 个 $1$ 划分到同一段对最终总和的增加量大约是 $2^x$ 。

这个感觉就是很容易有解（因为划分的自由度极高）。

大概分析一下连续 $x$ 个 $1$ 内部划分能够得到什么结果。

$x>10$ 时一定能得到 $x$ 到 $2x$ 范围内的任何数，因为 $2^d<2c$ 我们自然猜想一定存在一种划分使得总和为 $2^d$ 。

但是 $x$ 很小的时候就非常麻烦，看起来要大分类讨论，况且中间的 $0$ 也不好处理，一不小心还会把复杂度写高了。

------------

但是啊，我们还有一种神奇的算法。我们在很久之前就学过它，但是现在用的越来越少，而且使用它会被当成无能的表现。

回忆一下几年前普及组训练的时候，自己最拿手的是什么？最常用的是什么？最喜欢的是什么？？？

每一位教练都会强调它的重要性，但是我们肯定都记不得了。

**dfs+剪枝**

没错，伟大的dfs往往能够避免各种分类讨论。

dfs(i,rem)

表示目前从第 $i$ 位开始，后面还需要 $rem$ 的总和。

如果序列第 $i$ 位是 $0$ 就跳过连续的 $0$ 到下一个 $1$ 。

其它情况：

因为连续 $x$ 个 $1$ 划分到同一段对最终总和的增加量大约是 $2^x$ 。

所以我们最多允许长度 $15$ 的划分。

直接枚举 $j=1->15$ 搜索，在判一下末尾。

但是这样会tle。

如果所需要的**增加量**（即 $2^d-c$ ）非常大的话就会在最后一段几个位置一直搜，导致tle。

所以，当所需增加量大于20的时候倒过来搜（ $j=15->1$ ）。

最后再加个特判：前面一堆连续的 $0$ 最后连续 $5$ 个 $1$ 的情况。

这个凑不出 $8$ ，于是直接 $15+1$ 。

做完了。

代码：

https://codeforces.com/contest/1684/submission/157757076