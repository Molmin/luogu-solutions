本题是典型的完全背包题目。
## 题目大意
有 $N$ 种物品和一个容量为 $V$ 的背包，每种物品都有无限件可用。第 $i$ 种物品的费用是 $w_i$，价值是 $c_i$。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。 
## 大体思路
这个问题非常类似于 01 背包问题，所不同的是每种物品有无限件。也就是从每种物品的角度考虑，与它相关的策略已并非取或不取两种，而是有取 $0$ 件、取 $1$ 件、取 $2$ 件……等很多种。如果仍然按照解 01 背包时的思路，令 $f(i,v)$ 表示前 $i$ 种物品恰放入一个容量为 $V$ 的背包的最大权值。仍然可以按照每种物品不同的策略写出状态转移方程，像这样：$f(i,v)=\max{f[i-1][v-k\times w[i]]+k\times c[i] | 0\le k\times w[i]\le  v}$。

将 01 背包问题的基本思路加以改进，得到了这样一个清晰的方法。这说明01背包问题的方程的确是很重要，可以推及其它类型的背包问题。

这个算法使用一维数组，先看伪代码：
```cpp　
  for i=1..N 
　　　for v=0..V
　　　　 f[v]=max{f[v],f[v-w[i]]+c[i]}; 
```
你会发现，这个伪代码与 01 背包问题的伪代码只有v的循环次序不同而已。为什么这样一改就可行呢？首先想想为什么 01 背包问题中要按照 $v=V\sim 0$ 的逆序来循环。这是因为要保证第i次循环中的状态 $f(i,v)$ 是由状态 `f[i-1][v-w[i]]` 递推而来。换句话说，这正是为了保证每件物品只选一次，保证在考虑“选入第 $i$ 件物品”这件策略时，依据的是一个绝无已经选入第 $i$ 件物品的子结果 `f[i-1][v-w[i]]`。而现在完全背包的特点恰是每种物品可选无限件，所以在考虑“加选一件第 $i$ 种物品”这种策略时，却正需要一个可能已选入第i种物品的子结果 `f[i][v-w[i]]`，所以就可以并且必须采用 $v= 0\sim V$ 的顺序循环。这就是这个简单的程序为何成立的道理。
　　   
这个算法也可以以另外的思路得出。例如，基本思路中的状态转移方程可以等价地变形成这种形式：`f[i][v]=max{f[i-1][v],f[i][v-w[i]]+c[i]}`，将这个方程用一维数组实现，便得到了上面的伪代码。

### 一个简单有效的优化 
　 完全背包问题有一个很简单有效的优化，是这样的：若两件物品 $i$ 、$j$ 满足 $w_i\le w_j$ 且 $c_i\le  c_j$，则将物品 $j$ 去掉，不用考虑。这个优化的正确性显然：任何情况下都可将价值小费用高的 $j$ 换成物美价廉的 $i$，得到至少不会更差的方案。对于随机生成的数据，这个方法往往会大大减少物品的件数，从而加快速度。然而这个并不能改善最坏情况的复杂度，因为有可能特别设计的数据可以一件物品也去不掉。

## 完整代码
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long//注意开 long long
int w[100005],c[100005];
int dp[10000005];//数组 1e7
signed main(){
    int v,n;
    cin>>v>>n;
    for(int i=1;i<=n;i++){
        cin>>w[i]>>c[i];
    }//输入
    for(int i=1;i<=n;i++){
        for(int V=w[i];V<=v;V++){
            dp[V]=max(dp[V],dp[V-w[i]]+c[i]);//状态转移方程
        }
    }
    cout<<dp[v];//输出
    return 0;
}
```