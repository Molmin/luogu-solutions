## 题意

根据题意，不难看出一个很直观的写法，维护前缀和后缀。

再算一下复杂度，居然是$~O(n)~$的。

显然，可能这就是正解。

## 思路

观察题目染色规则，可以发现这些：

1. 对于一个十分浅的颜色，只要之前有过这个颜色，那么就只需要染一次；

1. 我们可以用一个标记数组，储存之前出现过得颜色，接着就是维护这个数组；

1. 根据一，就有一个显而易见的结论，只要遍历到了一个颜色，那么，所有比它深的颜色的标记，就要全部删除，这里大家可以感性理解一下；

1. 想完了这几点，就可以直接来两次遍历，一次维护前缀，一次维护后缀。

## Code

```
#include<bits/stdc++.h>
using namespace std;
int n , q , l , r , v[30] , f[100010] , f2[100010];
char a[100010];
int main()
{
	cin >> n >> q >> (a + 1);
	for(int i = 1;i <= n;i++)
	{
		f[i] = f[i - 1];
		for(int j = a[i] - 'A' + 1;j < 26;j++) v[j] = 0;
		if(v[a[i] - 'A'] == 0) v[a[i] - 'A'] = 1 , f[i] += 1;
	}
	memset(v , 0 , sizeof(v));
	for(int i = n;i >= 1;i--)
	{
		f2[i] = f2[i + 1];
		for(int j = a[i] - 'A' + 1;j < 26;j++) v[j] = 0;
		if(v[a[i] - 'A'] == 0) v[a[i] - 'A'] = 1 , f2[i] += 1;
	}
	for(int i = 1;i <= q;i++)
	{
		cin >> l >> r;
		cout << f[l - 1] + f2[r + 1] << endl;
	}
	return 0;
}

```
完结撒花！！！