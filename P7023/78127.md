分析性质，对于一个数我们有两种对它的操作：

1. 将它变成它的倍数，且这个倍数在原数组中出现过.
2. 将它变成所有数的**最小公倍数**.

由于数的顺序并不重要，因此为了方便将相同大小的数成为同**一类数**.

再将所有数类按照能否执行操作 $2$ 分成两个集合 $A$ 和 $B$ ，显然 $|B|=\text{原本序列中不同数的个数}$ ，因为所有数都可以执行操作 $2$ .

对于操作 $1$ ，显然对于某一类数，要么全部操作完，要么操作时乘上 $1$ ，因为只操作部分对答案没有贡献.

设这样操作了 $k$ 类数，那它的答案就是 $tot-k$ ，$tot$ 指的是原序列中数的类数.

对于操作 $2$ ，等价于在操作 $1$ 的基础上新增一类数，所以如果操作了 $k$ 类的话，它的答案就是 $tot-k+1$ .

那将原本操作 $1$ 乘 $1$ 的那些操作拿来做操作 $2$ 会不会更优？

对于同一种操作，显然是优先操作所含个数更小的数类更优，下面也秉持这种思想。

注意到 $\forall i\in [1,\min(|A|,|B|)] \ , \ cnt_A[i]\ge cnt_B[i]$ ，于是推出 $A$ 中可操作的类数 $k_A$ 必定小于等于 $B$ 中的操作类数 $k_B$ .

假设等于，那么剩余的操作数显然不能在 $B$ 中完整地操作一类.

如果小于，那么剩余的操作数**最多**只能在 $B$ 中完整地操作一类，由于这样又会新增一类，所以对答案的贡献不变.

否则导致 $k_B>k_A+1$ ，此时全部执行操作 $2$ 更优.

综上，对于一个 $i$ 最多只会执行上述其中一种操作.

于是对于两个集合分别打标记维护即可，时间复杂度 $O(n\log n)$ .