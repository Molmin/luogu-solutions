## 在这里介绍一种思路清奇~~鬼畜~~的dp做法



题意：给定一个环状序列，求两段不相交的连续子区间的最大和。

当时我做这道题的思路是设$f[i][2][2]$ 表示前i个元素

第一段没有开始选（0），开始选但是没有结束（1），选了并且结束了（2）

第二段没有开始选，开始选但是没有结束，选了并且结束了。

那么dp方程就变得比较显然了，对于每一种状态，我们可以轻易地求出能转移的状态

```cpp
f[0][0][0]=0;
f[i][2][1]=max(f[i-1][2][0]+a[i],f[i-1][2][1]+a[i]);
f[i][2][2]=max(f[i-1][2][1]+a[i],max(f[i-1][2][2],f[i][2][1]));
f[i][1][0]=max(f[i-1][0][0]+a[i],f[i-1][1][0]+a[i]);
f[i][2][0]=max(f[i-1][2][0],max(f[i-1][1][0]+a[i],f[i][1][0]));
```



~~然后我就开开心心地把环拆成俩然后过了样例交上去他就wa了~~

为什么呢，因为里面的元素可能会有一部分重复选了。

我们发现：**首尾相接的区间实际上可以拆成必须选择头和尾的两段区间**

那实际上，我们的问题就变成了：**求1-n中两段连续区间的最大值，或强制选择第首元素和尾元素的三段连续区间的最大值**

那么我上面那个非常鬼畜的dp，还要多加一维.........~~（虽然有的状态实际上是多余的不过也懒得改了，而且这样会更好理解一些）~~

于是就出现了下面神奇的ac代码


```cpp
#include<iostream>
#include<cstdio>
#include<cstring>

const int ss=5*1e5+7;
using namespace std;

int f[ss][3][3][3],a[ss];
main(){
	memset(f,-0x3f,sizeof(f));
	f[0][0][0][0]=0;
	int n;cin>>n;
	for(int i=1;i<=n;i++){cin>>a[i];a[n+i]=a[i];}
	for(int i=1;i<=n;i++){
	    f[i][0][0][0]=0;
		f[i][2][1][0]=max(f[i-1][2][0][0]+a[i],f[i-1][2][1][0]+a[i]);
		f[i][2][2][0]=max(f[i-1][2][1][0]+a[i],max(f[i-1][2][2][0],f[i][2][1][0]));
		f[i][1][0][0]=max(f[i-1][0][0][0]+a[i],f[i-1][1][0][0]+a[i]);
		f[i][2][0][0]=max(f[i-1][2][0][0],max(f[i-1][1][0][0]+a[i],f[i][1][0][0]));
	}
	int ans=f[n][2][2][0];
	memset(f,-0x3f,sizeof(f));
	f[1][1][0][0]=a[1];
	for(int i=2;i<=n;i++){
	   f[i][1][0][0]=f[i-1][1][0][0]+a[i];
	   f[i][2][0][0]=max(f[i-1][1][0][0]+a[i],max(f[i-1][1][0][0],f[i-1][2][0][0]));
	   f[i][2][1][0]=max(f[i-1][2][0][0]+a[i],f[i-1][2][1][0]+a[i]);
	   f[i][2][2][0]=max(f[i-1][2][2][0],max(f[i-1][2][1][0]+a[i],f[i][2][1][0]));
	   f[i][2][2][1]=max(f[i-1][2][2][0]+a[i],f[i-1][2][2][1]+a[i]);
	   if(i!=n) f[i][2][2][2]=-1060633226;
	   else f[i][2][2][2]=max(f[i-1][2][2][1]+a[i],f[i-1][2][2][0]+a[i]);
	}
	printf("%d\n",max(f[n][2][2][2],ans));
}
```
