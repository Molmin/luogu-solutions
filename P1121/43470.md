
环状最大两段子段和(luogu 1121)

第一道不看题解A掉的紫题！庆祝一下！

解法：一看就是DP啊

首先能想到破环为链，然而并不是这样

思路是用f[i][1/2][0/1]表示到第i个分成0/1/2个子段选或不选第i个的最大和

状态转移方程：

到i只选一个子段，不选第i个

f[i][1][0]=max(f[i-1][1][0],f[i-1][1][1]);

到i只选一个子段，选第i个

f[i][1][1]=max(f[i-1][1][1]+a[i],a[i]);

到i选两个子段，不选第i个

既然这个不选，那

f[i][2][0]=max(f[i-1][2][1],f[i-1][2][0]);

到i选两个子段，选第i个

那得好好考虑一下

如果上一个没选

就可以用f[i-1][1][0]（上一个没选，截止到上一个选了一个子段）转移

但不能用f[i-1][2][0]（上一个没选，截止到上一个选了两个子段）

因为上一个没选，这一个选了，不就选了三个了吗

如果上一个选了

就可以用f[i-1][1][1]（上一个选了，截止到上一个选了两个子段）

和f[i-1][2][1]（上一个选了，截止到上一个选了两个子段）转移

方程大概是

f[i][2][1]=max(f[i-1][1][0],max(f[i-1][1][1],f[i-1][2][1]))+a[i];

但是有一个很恶心的地方需要考虑

因为这个环不能绕回去，所以推某一个状态的时候最多考虑它后面的n个

然后突然想到

可以考虑一种分成三个子段的情况，但是第一个和最后一个必须选

这样不就视为能绕回去的情况了吗

这个想是摘出来单独算

就是直接加上a[1]和a[n]，然后从2到n-1循环

但是有一个方程要改一下，就是f[i][1][1]=f[i-1][1][1]+a[i]

因为第一个必须选，所以到第i个想要保持一个子段就要一只加

剩下的仔细想想，不改也都没毛病

再想想初始化，由于有负数所以先把f memset成128

然后再f[1][1][1]=a[1];

之后从2开始算就好咯

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
int n,a[200001],f[200001][4][2],ans1,ans2;
int main()
{
    cin>>n;
    for (int i=1;i<=n;i++)
        cin>>a[i];
    memset(f,128,sizeof(f));
    f[1][1][1]=a[1];
    for (int i=2;i<=n;i++)
    {
        f[i][1][0]=max(f[i-1][1][0],f[i-1][1][1]);
        f[i][1][1]=max(f[i-1][1][1],0)+a[i];
        f[i][2][0]=max(f[i-1][2][0],f[i-1][2][1]);
        f[i][2][1]=max(f[i-1][1][0],max(f[i-1][1][1],f[i-1][2][1]))+a[i];
    }    
    ans1=max(f[n][2][0],f[n][2][1]);
    memset(f,128,sizeof(f));
    f[1][1][1]=a[1];
    for (int i=2;i<=n;i++)
    {
        f[i][1][0]=max(f[i-1][1][0],f[i-1][1][1]);
        f[i][1][1]=f[i-1][1][1]+a[i];
        f[i][2][0]=max(f[i-1][2][0],f[i-1][2][1]);
        f[i][2][1]=max(f[i-1][1][0],max(f[i-1][1][1],f[i-1][2][1]))+a[i];
        f[i][3][0]=max(f[i-1][3][0],f[i-1][3][1]);
        f[i][3][1]=max(f[i-1][2][0],max(f[i-1][2][1],f[i-1][3][1]))+a[i];
    }
    ans2=f[n][3][1];
    cout<<max(ans1,ans2); 
}
```