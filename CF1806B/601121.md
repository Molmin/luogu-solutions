## 思路
这道题不涉及到任何算法，仅仅就是一道分类讨论的题。

但是我们会发现，$2\le n \le 2\times 10^5$ 并且 $1\le t\le  10^4$，而又因为输入的原因复杂度只能 $O(nt)$ 所以不能完全暴力。

我们可以把数据的情况分为以下几种并求出对应的答案：

- 序列中 $0$ 的个数小于等于序列总长度的一半（奇数自动加一），此时所有不为 $0$ 的数的数量一定大于 $0$ 的数量，这样就可以将每个 $0$ 都和一个不为 $0$ 的数挨着，这样只会出现 $0$ 和不为 $0$ 挨着，或者不为 $0$ 和不为 $0$ 的挨着，这样和永远大于 $0$，所以答案就为 $0$。
- 如果不是第一种方法且有大于 $1$ 的元素，那么答案就是 $1$。因为只需要将 $0$ 都放在最左边，$1$ 都放在最右边，中间隔着一个大于 $1$ 的，这样只会出现 $0$ 和大于 $1$ 的和，所以答案为 $1$ 。
- 再一种就是全为 $0$，很显然这样答案为 $1$ 。
- 剩下的所有情况就都是一个 $0$ 的个数大于总长度一半的 $01$ 字符串了。这样因为 $1$ 的个数小于 $0$ 的个数，所以可以把所有 $1$ 用至少 $1$ 个 $0$ 给隔开，这样只会出现 $0$ 和 $1$ 的和，故答案为 $2$。
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[200010];
int main()
{
	int t,n;
	cin>>t;
	while(t--)//多组数据 
	{
		int zero,moreone;//来记录0和大于1的数的数量 
		zero=moreone=0;//初始为0 
		cin>>n;
		for(int i=1;i<=n;i++)
		{
			cin>>a[i];
			zero+=(a[i]==0);//判断是否为0，为0加1 
			moreone+=(a[i]>1);//同理，判断是否大于1，大于1加1 
		}
		//第一种情况 
		if(zero<=n/2 and n%2==0) cout<<0<<endl;
		else if(zero<=(n+1)/2 and n%2==1) cout<<0<<endl;
		//if(zero<=(n+1)/2) cout<<0<<endl;
		else if(moreone!=0) cout<<1<<endl;//第二种 
		else if(zero==n) cout<<1<<endl;//第三种 
		else cout<<2<<endl;//剩下的即最后一种 
	}
	return 0;
}
```
完结撒花！