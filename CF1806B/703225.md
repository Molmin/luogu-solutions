## 题目大意
有 $t$ 个长度为 $n$ 的序列，求重新排列后的最小`mex`值。
## 题目解法
一道比较简单的思维题，分情况讨论一下。

我们把序列中 $0$ 的数量定义为 $a_0$，把序列中 $1$ 的数量定义为 $a_1$，$(n+1) \div 2$ 定义为 $b$。

若 $a_0=n$，也就是序列中全部都是 $0$，此时最小`mex`值肯定是 $1$，因为任意两个数字相加结果都是 $0$。

若 $a_0 \le b$，也就是序列中一半或者一少半的数字是 $0$ 时，我们将所有的 $0$ 与一个非零的数放在一起相加，这样序列中的两个数的和全都 大于 $0$ 了，最小`mex`值就是 $0$ 了。

若 $b < a_0 < n$，此时有两种情况：

- 若 $a_0+a_1=n$，也就是序列中只有数字 $0$ 或 $1$，且 $0$ 的数量比 $1$ 多。此时我们把所有的 $1$ 分别与 $0$ 放在一起，无论如何都有剩余的 $1$，所以此时最小`mex`为 $2$。

- 否则，我们把所有非零的数两两结合，$0$ 互相结合，这样就能使最小`mex`值为 $1$ 了。

### 参考代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int T,n,a0,a1,s;
int main()
{
    cin>>T;
    while(T--){
    	a0=a1=0;
        cin>>n;
        for(int i=1;i<=n;i++){
            cin>>s;
            if(s==1) a1++;
            if(s==0) a0++;
        }
        if(a0==n) puts("1");
        else if(a0<=(n+1)/2) puts("0");
        else if(a0+a1==n) puts("2");
        else puts("1");
    }
    return 0;
}
```
