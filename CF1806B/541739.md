## 前言。
一道比较简单的分类讨论题。
## 分析。
首先我们先统计出非 $0$ 的数有多少个，下文中用 $sum$ 表示，然后统计出为 $0$ 的数有多少个，下文中用 $cut$ 表示。

第一种情况：  
当 $sum$ 大于等于 $cut-1$ 时，此时因为要求最小的权值，所以我们可以将每一个非零数穿插在每两个 $0$ 之间，此时在新序列中，任意两个相邻的数之和都是非零数，没有在新序列中出现的最小整数即为 $0$。

第二种情况：  
当 $sum$ 小于 $cut-1$ 时，此时易证有两个 $0$ 相邻，那就一定在新序列中有至少一个 $0$。  
为了使答案最小，我们可以将所有非零数在同一个区间内以升序相加使其加出来的数尽量大，那此时的答案就在非 $0$ 数与 $0$ 的交界处。在这种情况下，还有两种情况:

- 若存在非零数且所有非零数都是 $1$ 时，注意到我们可以尽可能将 $1$ 穿插到两个 $0$ 之间时更优，新序列交界处就一定为 $0$ 与 $1$ 相接，答案为 $2$。
- 若存在大于 $1$ 的非零数，就将它作为与 $0$ 的分界线，新序列中不存在 $1$ 的结果，此时答案为 $1$。

代码如下，仅供参考：
```
#include<iostream>
using namespace std;
int t,n,a[200005],pd,pd2,flag;
int main(){
    cin>>t;
    while(t--){
    	pd=pd2=flag=0;
        cin>>n;
        for (int i=1;i<=n;i++){
            cin>>a[i];
            if (a[i]) pd++;
            else pd2++;
            if (a[i]>1) flag=1;
        }
        if (pd>=pd2-1) cout<<"0\n";
        else if (pd&&!flag) cout<<"2\n";
        else cout<<"1\n";
    }
    return 0;
}
```
## 后记。
大家如有疑问，可以在评论区提出，我会尽力解答的。