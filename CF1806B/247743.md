# 题意
给定 $n$ 长的数组 $a$，要求输出该数组的**最小**得分。

求出数组的得分：
- 第一步，可以任意重新排序原数组 $a$；
- 第二步，将排序后的数组构造出新数组 $a_1+a_2,a_2+a_3,\ldots,a_{n-1}+a_n$；
- 第三步，新数组中未出现的**最小非负整数**就是该数组的得分。

# 分析
因为得分为最小非负整数，而不考虑数组的情况下，最小的非负整数为零，所以我们要尽量使得分尽可能接近零。

令 $num_0,num_1,ng_1$ 分别为原数组值为零的个数，值为一的个数，以及值大于一的个数。

### 答案为零
由于新数组各项是排序后的 $a$ 数组中**为邻居的两元素之间的和**，所以要让零在新数组中不出现，需要把原数组的零与正整数做邻居。

当 $num_0 \le \frac{n+1}{2}$ 时，表示有足够的正数与值为零的元素做邻居，从而使零在新数组中未出现，那么答案就为零。

### 答案为一
当不满足答案为零的情况，即值为零的元素过多，那么我们要尽量使得分接近一。

当 $num_1=0$ 时，即在值为零的元素出现了的情况下，值为一的元素没有出现，那么答案就是一。

当 $ng_1>0$ 时，则即便值为一的元素在原数组中出现了，都有比一大的数与一做邻居，使两者加和大于一，在新数组中就不会出现值为一的元素了，所以答案也是一。

### 答案为二
当都不满足上述情况，答案就是二，构造不出更大的答案了。

# 代码
```cpp
#include<bits/stdc++.h>
#define LL long long
using namespace std;
const int N = 1e6+6;
LL _,n,a[N];
void work(){
	cin>>n;
	for(LL i=1;i<=n;i++){
		cin>>a[i];
	}
	LL num0=0,num1=0,ng1=0;
	for(LL i=1;i<=n;i++){
		num0+=(a[i]==0);
		num1+=(a[i]==1);
		ng1+=(a[i]>1); 
	}
	if(num0<=(n+1)/2){
		cout<<"0\n";
		return;
	}
	if(!num1){
		cout<<"1\n";
		return;
	}
	if(ng1){
		cout<<"1\n";
		return;
	}
	else{
		cout<<"2\n";
	}
}
int main(){
	ios::sync_with_stdio(false);
	cin>>_;
	while(_--){
		work();
	}
}
```
