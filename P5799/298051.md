~~一个代码更加简单但是思维极为神秘的做法~~

---

首先随手证个结论：  
如果任意一个字母都仅在一个连续段中出现，则一定不会出现由多个字母构成的重复串。

证明显然，我们考虑相同段的第一个与前缀连续段不同的字母，显然这个字母只能是对应连续段的第一个，又因为两个串相同所以前缀连续段长度也相同，即两个串的起始位置相同。所以不可能出现重复串。


同理可得，若只有某些字母在多于一个连续段中出现，那么重复串一定满足第二个非重复字母在多于一个连续段中出现，且合法的重复串的这个字母必定出现在不同的连续段中。

---

我们现在可以阐述构造算法了：

由于若存在一个长度 $>n$ 的连续段，那么一定会有重复串（分别是长度为 $n$ 的前缀和后缀）。所以易想到我们给出如下构造方式：

首先按照在**初始字符串**中出现的次数赋予权值（即权值不会随着字符被使用改变），然后在保证连续段长度 $\leqslant n$ 的情况下按权值从大到小的顺序填入。（避免需要用其他值打断的时候没有了） 然后如果不合法就 `puts("NO");`。 

~~完结撒花……才怪，还没证明呢~~

显然，在所有字母的出现次数均 $\leqslant n$ 时，每个字母都只会在一个连续段中出现，由初始定理可得这种情况下一定满足要求。因此我们只需要证明存在字母出现次数 $>n$ 的情况时的正确性。

---

不失一般性地，令字母按出现次数从大到小分别为 a,b,c,...,z，并定义字母 x 重复 $n$ 次构成的字符串记为 $x^n$，字母 x 重复若干次（可能为 $0$ 次）构成的串为 X。  
以下为了区分~~和方便写上标~~，若干个串相邻写出来连接时会用 LaTeX 标注。


显然，最多有一个字母出现次数 $>n$，且其为 a。那么按照该算法构造出的最终字符串一定形如 $a^nbABCD...XYZ$。

为了说明其的正确性，我们只需要证明在任何有解的情况下该算法构造的解均为合理的，或者说，该算法构造出来的解非法的时候也不存在合法解。

经过分析可得，该算法当且仅当下面这三种情况之一出现时不合法：

* b 出现了 $0$ 次。（会导致一个长度 $>n$ 的 A 出现）
* $BCD...XYZ$ 为空。（同上）
* b 出现了恰好 $2$ 次且 $CD...XYZ$ 为空。（会导致 $aba^{n-2}$ 出现两次）

接下来会说明为什么除了这三种情况之外所有情况均合法：

---

若 b 出现了至少 $1$ 次且 $BCD...XYZ$ 非空，那么：  

由上面的第二个定理可得要么是 $BCD...XYZ$ 的一段后缀加上若干个 a，要么是 $bA$ 加上 $BCD...XYZ$ 的一段前缀。  
又因为 b 出现至少 $1$ 次且 $BCD...XYZ$ 非空，所以 a 最多出现 $2n-2$ 次，即 $A$ 的长度 $\leqslant n-2$，所以 $bA$ 后接的前缀一定非空，即这段不以 a 结尾，与另一段以 a 结尾矛盾，所以合法。

---

若 b 出现了至少 $3$ 次，那么：

与上面同理可得要么为 $BCD...XYZ$ 的一段后缀加上若干个 a，要么是 $bA$ 加上 $BCD...XYZ$ 的一段前缀。

又因为已知 $b$ 出现至少 $3$ 次，所以第二个可以被转化为 $bAbb$ 加上 $B'CD...XYZ$ 的一段前缀，但由于 $BCD...XYZ$ 的后缀加上若干个 a 显然不可能出现 $bAbb$ 的前缀所以也一定合法。

---

故得出了上面两种情况外，该程序构造的解均合法，而上文这几种情况也显然无法得出合法解。（详见后注）

由此，我们证明了这个贪心的正确性。

---

AC 代码：~~推了一车神秘玩意但是代码很清新~~

```c++
#include <cstdio>
#include <cstring>
#include <algorithm>
#define N 2000010
int n; char s[N];
int ans[N]; int c[26],a[26];
bool cmp(int x,int y) {return c[x]>c[y];}
bool solve()
{
    for(int i=1;i<=n;i++) c[s[i]-'a']++;
    for(int i=0;i<26;i++) a[i]=i;
    std::sort(a,a+26,cmp);
    if(c[a[0]]>n/2)
    {
        if(!c[a[1]]||(!c[a[2]]&&c[a[1]]<=2)) return false;
    }
    int run=0,last=-1;
    for(int i=1;i<=n;i++)
    {
        int ban=-1,now=-1;
        if(run==n/2) ban=last;
        for(int j=0;j<26;j++) if(a[j]!=ban&&c[a[j]])
            {now=a[j]; break;}
        if(now!=last) run=0;
        ans[i]=now,c[now]--,last=now,run++;
    }
    return true;
}
int main()
{
    scanf("%s",s+1); n=strlen(s+1);
    if(!solve()) return puts("NO"),0;
    puts("YES"); for(int i=1;i<=n;i++) putchar(ans[i]+'a');
}
```

---

后记：

在推理中给出的三个条件并不好直接判断，我们可以作如下转化：

在 a 出现次数 $>n$ 的前提下：  
* b 出现 $0$ 次：等效于 b 出现 $0$ 次。
* $BCD...XYZ$ 为空：等效于 c 出现 $0$ 次*且* b 最多出现 $1$ 次。
* b 出现了恰好两次且 $CD..XYZ$ 为空：等效于 b 出现 $2$ 次且 c 出现 $0$ 次。

第一个和第二个显然不存在合法解：所有 a 一定形成一个连续段。

对于第三个，两个 b 一定会把环切为两个（可能为空）的 a 连续段，由于其中一段长度 $>n$ 的话一定不合法。
所以要么两个长度均为 $n-1$，要么是一个长度为 $n-2$ 一个长度为 $n$。而这两种情况下均存在重复段 $a^{n-2}ba$，所以也无法构造出合法解。

到此得证：这个贪心能够得到满足题目要求解当且仅当题目有解。

---

温馨提示：比赛的话就不用推这么一大车了，目测这个贪心没问题就扔上去然后写个哈希判一下是否满足题目要求，不满足就 `puts("NO");` 满足就 `puts("YES");` 然后输出答案就行了，这题记得写双哈希否则容易被卡。

