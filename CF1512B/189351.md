## 题意

一句话题意：给出 $T$ 个矩阵，每个矩阵由 $N$ 行 $N$ 列个 `.` 和 `*` 组成，保证矩阵中有且只有两个 `*`，要求你再在矩阵上将两个 `.` 改成 `*` 使得 $4$ 个 `*` 可以是一个矩阵的 $4$ 个角（提示：两个 `*` 可能在同一行）。

## 分析

这是一道构造题。

其实没必要把图存下来，因为只有两个 `*` 所以我们只需要把两个 `*` 的下标 get 到就行啦。

我们先定义 $4$ 个点中点 $i$ 的坐标 $P_i$ 为 $(x_i,y_i)$，其中 $P$ 的下标从 $0$ 开始，$P_0$、$P_1$ 是读入时读取的，而 $P_2$、$P_3$ 是需要构造的。

先考虑有同行同列的情况出现：

```cpp
if (x[0] == x[1]) {
    y[2] = y[0]; y[3] = y[1];
    x[2] = x[1] + 1; if (x[2] > N) x[2] -= N;
    x[3]= x[2];
}
```

当 $x$ 相同时 $P_2$ 和 $P_3$ 的 $x$ 可以随便取（只要不要与 $x_0$ 相同）那么我设 $x_2 = x_1 + 1$ 可以保证不在同一行，然后再判断有没有出界，如果有的话减去 $N$ 就可以保证它在矩阵范围内。

这里只放 $x$ 相同时的情况， $y$ 相同不作赘述。

而如果没有同行同列的话那就更简单了，因为边平行坐标轴的矩阵可以由对角线上的两个点确定，我们令 $x_2 = x_0, y_2 = y_1, x_3 = x_1, y_3 = y_0$ 交错赋值就好了。

## 代码

```cpp
# include <bits/stdc++.h>
using namespace std;

int T, N, x[4], y[4], check;

bool get_bool () {
    // 读数据用
    for (char ch = getchar (); ; ch = getchar ())
    if (ch == '.' || ch == '*') return ch == '*';
}

int main () {
    cin >> T;
    while (T--) {
        cin >> N; check = 0;// check 表示第几个出现的 *
        for (int i = 1; i <= N; i++)
        for (int j = 1; j <= N; j++)
        if (get_bool ()) {
            x[check] = i; y[check] = j;
            check = 1;
        }
        if (x[0] == x[1]) {
            y[2] = y[0]; y[3] = y[1];
            x[2] = x[1] + 1; if (x[2] > N) x[2] -= N;
            x[3]= x[2];
        }   else
        if (y[0] == y[1]) {
            x[2] = x[0]; x[3] = x[1];
            y[2] = y[1] + 1; if (y[2] > N) y[2] -= N;
            y[3] = y[2];
        }   else // 这里前面有说过
        {
            x[2] = x[0]; y[2] = y[1];
            x[3] = x[1]; y[3] = y[0];
        }
        for (int i = 1; i <= N; i++) {
            for (int j = 1; j <= N; j++) {
                check = 0; // 输出时判断是否应该输出 *
                for (int k = 0; k <= 3; k++) if (i == x[k] && j == y[k]) check = 1;
                putchar (".*"[check]);
                // 这里编译时会将 ".*" 看做一个字符串
            }
            putchar ('\n');
        }
    }
    return 0;
}
```