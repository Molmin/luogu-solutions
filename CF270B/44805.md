### P.S.
这篇题解已经写的事无巨细了，如果还不能过审那就是我水平太低了。  

### Problem.
给定一个初始序列，初始状态为 $\{1,2,...,n\}$。  
每次可以选择一个数把他提到最前面。  
求至少进行多少次操作来把这个序列变成 $\{a_1,a_2,...,a_n\}$。  

### Solution.

#### Step1. 转化题意
首先，我们倒过来考虑，我们考虑把 $\{a_1,a_2,...,a_n\}$ 这个序列变成 $\{1,2,...,n\}$。  
那么这样操作就应该是把当前这个序列地第一号元素插到序列的任意一个地方  

#### Step2. 观察性质
我们发现，最终序列是单调递增的，初始序列不一定是。  
同时，根据贪心地思想，我们对于每个第一个元素，如果存在它后面有一个比它小的 $a_k$，那么当前这个序列还没变成最终的 $\{1,2,...,n\}$ 序列。  
又因为转化后的题意告诉我们，当前只能对第1个数进行操作，所以此时我们必须操作。  
然后，由于题目保证了 $a_i$ 之间互不相同，那么我们总能找到当前 $a_1$ 的最终位置，然后把 $a_1$ 插入到最终位置。  
所以对于每个不符合条件的 $a_i$，我们至多只需要一次把它变对。  

#### Step3. 得出结论
由于转化后的题意只允许我们操作第一个元素，所以即使当前这一位已经满足了，它后面还有没有满足地元素，那它也必须被操作。  
所以我们只需要找出最后一个不满足题意的数，那它之前地所有数必须要被操作。  

### Coding.
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,r,a[100005];
int main()
{
	scanf("%d",&n),r=0;//答案
	for(int i=1;i<=n;i++) scanf("%d",a+i);//读入
	for(int i=2;i<=n;i++) if(a[i-1]>a[i]) r=i-1;//找到最后面的不满足它后面的小于它的位置
	return printf("%d\n",r),0;//那个位置就是答案
}
```