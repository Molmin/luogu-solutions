在一个块里，访问全局仅会有 $O(\sqrt N)$ 不同的答案，于是考虑 P4118 的套路：逐块处理，线段树维护分段函数。

这个分段函数就是 $f(x)=$ 区间里 $\le x$ 数标为 1，$>x$ 的数标为 0，区间 tag 值是什么。tag 会保存（区间内答案，区间前缀 1 个数，区间后缀 1 个数，区间是否全是 1）这四个东西，可以快速合并 tag 得到答案。

我们可以维护分段函数的段的左端点，访问 $\le x$ 答案时候在分段函数上面二分。线段树叶子节点对应的分段函数就会是 $f(0)=(0,0,0,0)$ 和 $f(a_i)=(1,1,1,1)$。

两个分段函数合并时候会产生的新左端点等于原来的两个左端点序列的归并，可以用双指针同时爬两个分段函数来合并。

线段树节点内的分段函数会存 $|L|$ 个值，其中 $|L|$ 是区间大小。合并是 $O(n)$，所以建立线段树时空是 $O(\log n\sqrt n)$。

考虑最 naive 做法：在一个块的所有询问都二分，每一次在一个块里修改都 rebuild。定义 $q$ 为询问，$m$ 为修改。这样：

 - 整块询问 $O(\log n)$，总共有 $O(q\sqrt n)$ 个，对时间复杂度贡献 $O(q\log n\sqrt n)$
 - 散块询问 $O(\log^2 n)$，总共有 $O(q)$ 个，对时间复杂度贡献 $O(q\log^2 n)$
 - 单点修改 $O(\log n\sqrt n)$，总共有 $O(q)$ 个，对时间复杂度贡献 $O(m\log n\sqrt n)$
 - 块初始化 $O(\log n\sqrt n)$，总共有 $O(\sqrt n)$ 个，时间复杂度 $O(n\log n)$

$$O(n\log n+(q+m)\log n\sqrt n)$$

炸 出 翔

我们可以离线，然后已经在逐块处理，可以在一个块内两个修改之间的整块询问对 $x$ 排序，根的询问就可以单调爬了。整块询问降到均摊 $O(1)$。

发现单点修改仅仅会影响 $O(\log n)$ 个节点，更具体仅仅会影响每一层的一个节点。只对这些节点重构达到 $O(B+B/2+B/4+...)=O(B)=O(\sqrt n)$ 的单点修改时间复杂度。

于是做到了一个 $O(n\log n+(q+m)\sqrt n)$ 的巨大常数做法。