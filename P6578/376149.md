痛苦题，重构第4遍才过。

序列分块赛高！！！

考虑序列分块，由于单点修改难度并不大，先考虑查询需要维护什么信息。

我们发现查询的本质是询问在区间中将小于等于 $x$ 的标1，查询极长连续 1 段的子区间数，那么散块就非常简单，记录当前块第一个 0 的位置，直接扫即可。由于整块需要 $O(1)$ 查询，考虑维护处理所有 $x$ 在块内的答案和。发现一个块内只有 $\sqrt{n}$ 个不同取值，于是答案也只有 $\sqrt{n}$ 个不同值，所以我们可以预处理出每个答案。

考虑如何预处理：将整块递增排序，每次一个一个加入元素，所以极长连续段只增不减。那么考虑如何快速计算加入当前点的贡献，显然我们需要极长段端点有关的信息，这提示我们可以建立一个类似链表的结构，$L_i, R_i$ 分别表示以 $i$ 为端点时另一侧端点是哪里。显然就可以 $O(1)$ 加入，分类讨论两边是否存在连续段即可，这里答案的本质是块内值域相邻的两个元素间答案是多少。以下为预处理代码。

```
inline void build(int n){
    memset(L,0,sizeof L),memset(R,0,sizeof R);
    for(int i=1,ps;i<=n;++i){
    	assert(p[i].val>=p[i-1].val);
        ps=p[i].pos;ans[i]=ans[i-1];
        if(L[ps-1]&&R[ps+1]){
            ans[i]-=F(ps-L[ps-1])+F(R[ps+1]-ps);
            ans[i]+=F(R[ps+1]-L[ps-1]+1);
            R[L[ps-1]]=R[ps+1],L[R[ps+1]]=L[ps-1];
        }else if(L[ps-1]){
            ans[i]+=ps-L[ps-1]+1;
            R[L[ps-1]]=ps,L[ps]=L[ps-1],R[ps]=ps;
        }else if(R[ps+1]){
            ans[i]+=R[ps+1]-ps+1;
            L[R[ps+1]]=ps,R[ps]=R[ps+1],L[ps]=ps;
        }else ans[i]++,L[ps]=R[ps]=ps;
        al[i]=R[1];
        ar[i]=L[n]==0?0:n-L[n]+1;
    }
}
    
```


段内信息维护完成，考虑如何回答询问。即需要知道询问的 $x$ 是在哪一段，即需要维护共 $m\sqrt{n}$ 次 rank，$n+m$ 次单点插删。这部分可以用值域分块平衡。

继续考虑如何合并两个块的信息。我们发现块间可能会有两部分连续段拼接成更长的连续段，此时我们简单将块内信息累加就忽略了区间在不同块的答案。此时我们应该维护块两端的极长连续段，以快速合并。这样答案就变为所有整块的答案和减去两端内部贡献，加上合并所得的区间贡献。我们可以维护一个 $las$ 代表当前询问的上一个 $>x$ 元素的位置，这样也可以快速计算了。（写题解时突然发现可以累加贡献，然后将相邻块的左右直接相乘。这样更加简便但是我并没有实现，不保证正确性。）以下代码实现：

```
				l=max(kl[b],ll[q]),r=min(kr[b],rr[q]);
				if(l==kl[b]&&kr[b]==r){
                    x=ds.ask(xx[q]);
                    if(x==0){out[q]+=hc[q];hc[q]=0,las[q]=kr[b];continue;}
                    else if(x==kr[b]-kl[b]+1){hc[q]=F(kr[b]-las[q]);continue;}
                    out[q]+=F(kl[b]+al[x]-las[q]-1);
                    hc[q]=F(ar[x]);
                    out[q]+=ans[x]-F(ar[x])-F(al[x]);
                    las[q]=kr[b]-ar[x];
				}else if(l==kl[b]){
                    for(int i=l;i<=r;++i) o[i]<=xx[q]?out[q]+=i-las[q]:las[q]=i;
				}else{
                    for(int i=l;i<=r;++i) o[i]<=xx[q]?out[q]+=i-las[q]:las[q]=i;
                    out[q]-=F(r-las[q]);
                    hc[q]+=F(r-las[q]);
				}
```

单点修改就十分简单。需要修改的只有值域分块和排序数组。值域分块正常实现不难，排序数组可以 $O(\sqrt{n})$ 找到修改点在排序后的位置，改后以冒泡的方式 swap 到正确位置。因为只有一次冒泡，故复杂度单次 $O\sqrt{n})$，排序后重构一遍维护的信息即可，总复杂度 $O((n+m)\sqrt{n})$，并不卡常，微调块长即可通过，细节很多。完整代码不放需要私信。