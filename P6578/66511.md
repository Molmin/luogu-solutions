提供一种分散层叠的写法，居然拿了最优解。

可以应对大值域和强制在线，甚至支持区间加。

~~所以我现在怀疑这东西直接上二分会不会也能松过去~~

## 前置知识

关于分散层叠算法可以先看[这道题](https://www.luogu.com.cn/problem/P6466)。

或者也可以看看我写的这篇[博客](https://www.luogu.com.cn/blog/DPair2005/fen-san-ceng-die-suan-fa-xue-xi-bi-ji)。

当然，你也可以直接阅读这篇题解。

## 思路

首先我们看到这种 **“最大值小于”** 的问题，不难想到我们要求的就是和 **“全部元素小于给定数的极长连续段”** 有关的一些信息。

所以我们要维护这些连续段，考虑对序列分块，块长为 $b$ ，我们不妨设 $> x$ 的数为 $1$ , $\le x$ 的数为 $0$ ，那么我们得到的就是一个 $01$ 序列。我们要求的就是每一块的 **块内答案、块的最长全 0 前缀和块的最长全 0 后缀** 的长度。

但是对于不同的 $x$ ，这个序列不同。

不过显然对于某一个块，不同的块内信息最多 $O(b)$ 种，并且每一种对应一个 $x$ 的连续段，不难想到我们可以二分。

然后我们发现，这东西显然可以方便地重构，一次重构也是 $O(b)$ 的。

散块查询显然是 $O(b)$ 的，但是整块需要二分的话查询复杂度为 $O({n\over b}\log b)$ ，这是我们所不能接受的。

我们使用分散层叠算法在线段树上的应用（其实哪怕不知道这个东西往下看也能看懂），即先对于所有 **块** 建立线段树，每一个节点维护一个 **有序序列** 便于二分，其中所有叶子节点（即我们分好的块）维护的就是块内的元素 **带信息排序** 后的结果。

然后对于每一个父亲节点，维护的信息为两个儿子的序列 **每隔 p 个取出一个后形成的序列** 归并排序后的结果，并且对于每一个位置维护其在两个儿子中对应的后继。这里 $p$ 是一个我们自由选取的阈值。

举个例子，假设
$$
p=3, lson=\{1, 2, 5, 6, 7, 9\}, rson=\{3, 6, 7, 12, 15, 18\}
$$

那么
$$
fa=\{1,3,6,12\}
$$
其中 $1, 6$ 来自第一个序列， $3, 12$ 来自第二个序列。

这样子的话，我们在区间查询的时候可以对于这一个区间的根节点二分，然后得到两个儿子中的后继，不难发现这里得到的后继与 $x$ 在其儿子中的真实后继差距不超过 $p$ ，这部分暴力即可。由于 $p$ 是常数，复杂度 $O(1)$ 。

然后线段树节点个数为 $O({n\over b})$ ，故一次查询的复杂度变为 $O(\log {n\over b} \log b+{n\over b})$ 。

取 $b=\sqrt{n}$ 得到复杂度 $O(n\sqrt{n})$ 。

最后我们不难发现这个算法可以应对更大的值域，并且做到了强制在线，而且可以利用在线段树上打 tag 的方式实现区间加，这里不多赘述了。

代码不放了，有需求的可以私信问我要。