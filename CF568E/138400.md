我们只需要考虑最终答案的 LIS 里的空缺位置填了哪些值，然后把剩下的数随便填到剩下的位置里。

一个观察是：给的 $m$ 个候选数中，每个数可能出现多次，这其实是个幌子。因为 LIS 里不会有相同的数。甚至不用考虑重复不重复的事情，因为求出来的 LIS 自然是没有重复数的，就当成可以重复也无所谓。于是可以把候选数去个重。顺便排个序，把所有数离散化。

这样一来，所有空缺位置填的数便是互相独立的了，不存在某个格子填某个数会影响其他格子能不能填哪个数的情况。那就好办了，可以考虑一个线性 DP，而非状压 DP。

设 $f_i$ 表示把 $1 \sim i$ 的所有空缺位置任意填好后，以 $i$ 为结尾的 LIS 的最大长度。若位置 $i$ 是空缺，再记录一维 $j$，$g_{i, j}$ 表示这一位填 $j$ 的 LIS。这样状态数是 $\mathrm O(nk)$，$10^8$，这个量级作为时间还好，作为空间就爆炸了。不过容易解决，任意时刻显然只有当前最后一个空缺的位置的 DP 值是有用的，空间降为 $\mathrm O(n)$。

转移比较容易。计算 $f_i$ 的话，转移到非空缺可以用 BIT 维护，转移到上一个空缺位置只要二分出候选数集合里最大的小于 $a_i$ 的转移即可，毕竟 $g_{i, j}$ 关于 $j$ 递增。计算 $g_{i, j}$ 的话，转移到上一个空缺位置可以直接跟 $g_{last, j - 1}$ 取 max，转移到非空缺可以暴力枚举前面的非空缺放到桶里，再做一个前缀 max，复杂度 $\mathrm O(nk)$，可以承受。

看上去是不是比较简单，思路很自然吧。然而这题最恶心的地方在于还原方案。一般来说，DP 还原方案的方法是记录从哪儿转移来的。然而这题连 DP 数组都记不下了，又怎么记转移路径呢？

考虑在空间允许的情况下尽可能记录尽量多的信息。非空缺位置的转移前驱显然可以记吧。现在问题在于空缺位置，到底是从 $g_{last, j - 1}$ 转移过来的，还是从前面哪个非空缺位置转移来。如果是后者，具体是哪个位置我们不知道，但可以自己重新找啊，毕竟非空缺位置的 DP 值是完整记录的！直接找非空缺里最大的 DP 值就行了。那么问题来了，如何确定到底是从非空缺还是上个空缺转移来的呢？这是个 `bool` 就能储存的，还可以用 `bitset` 优化！于是这题就做完了。

时间复杂度 $\mathrm O(nk)$，空间复杂度 $\mathrm O\!\left(\dfrac{nk}{w}\right)$，[code](https://codeforces.com/contest/568/submission/189302419)。

---

看了眼题解区，发现正常做法好像不用 `bitset`……那如何确定空缺位置是否是从前面的非空缺位置转移来呢？设当前的 DP 值为 $c$，扫描一遍前面的非空缺位置，看是否有 DP 值为 $c - 1$，如果有就直接定位到了，否则只能是从 $g_{last, j - 1}$ 转移来。我是憨憨……