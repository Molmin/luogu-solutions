费用流好题。

首先应该注意到一个事情：$\sum v_i>m$。相当于每个人要多跑几个国家，否则答案就是0——直接玩一个国家没有路费的问题了。

错误做法：这个题一开始我还以为建图挺简单的：中间每个国家拆点限制流量，汇点也拆开继续限制容量，然后每个点和源汇一连，中间那些航线双向建边。结果爆零（双重）——**这么建边源点到汇点距离恒为0。** 为什么？因为国家（正经点）经过拆点后**零费用边**的流量总和大于$m$（由上面分析），此处还尚未考虑国家之间的带费用的边；然后由于每个点的入点和源点相连，流量无穷，费用为0；出点和汇点相连，唯一限制只有总流量小于等于$m$，费用还是零。那么，我们就有一个全0的走法：s->一个国家入点->对应出点->t。因而错误。

下面来讲正解。

先拆分整个问题：**先把这$m$个人起点给放好了，再让他们互相的坐飞机去别的地方玩。**

首先考虑$\sum v_i$的意义：出游的**人次**。由于$m$必然会小于人次数，则要求一个人要出游多个国家（这不是废话）。但是，**一个人出游的第一个国家显然是不会收费的——即，一个人可以从任意国家出发**，那么首先应该处理的是这一部分问题，也就是前半句。

这一部分应该如何处理呢？因为他们无论在哪里开始，都是免费的，那么我们就应该先让**源汇之间连一些（一条只串联一个正经节点，费用为0）的边，这些边的总容量为$m$**。 因为这里只关心这$m$个人从哪里开始，因而只能让这些边连接**一个节点**；同时由于一个人只能从一个地方开始，总容量就只能有$m$了；同时，一个国家**必须**有$v[i]$个人去玩，那么最多不能超过$v[i]$个人去，因而进出这个节点的总容量要进行限制。

这个地方处理方法非常简单：每个点和源和汇各连**流量为$v[i]$，费用为0**的边，最后在源点或者汇点附近搞一个限制节点就可以了（每个点和限制节点连，限制节点最后牵出一个容量为$m$的边到汇点/源点）。

那么考虑第二部分问题：**如何让他们互相转移**。

转移的次数应该为$\sum v_i-m$——总人次减去第一波游览的。那么，这部分的总容量应该是$\sum v_i-m$。但是，一个人如果要玩很多个城市，好像处理起来有点复杂；我们把问题转化为**坐飞机**——即，$\sum v_i-m$人去在这些国家之间坐飞机，使得每个国家到着人次符合要求。这样处理的合理性在于：我们不关心单个人的旅程，而关心宏观的总费用。那我们从宏观上看，如果每个人游玩时间为0，我们眼前的图景其实就是这么多人在不停坐飞机从这儿到那儿，因而不妨让$n$人次变成$n$个人坐**一次飞机**。

那么我们的方法就变成了：**我再给图上$\sum v_i$的总流量（人），从一层节点（记为层1）出发到另一层节点（记为层2，即第一波操作与源汇相连的那些节点）坐飞机付钱，然后直接结束旅程，连入汇点**。因为只坐一次飞机，那么只需要两层图即可解决；此外，**我们不再新增从层2到汇点的流量**——注意到我们在第一波操作中已经让这一层节点连向汇点总流量为$\sum v_i$，显然这个东西是包含了这两个操作中的所有人次的，因而不能再次连边扩容。**这样我们就控制了总容量为$\sum v_i$**。同时基于费用流的特征——流要优先最大，因而我们必然可以保证每个点被到了$v_i$次——这些点到汇点都连了个$v[i]$的边。

下面给出样例对应建出的图，非常密集。

[![yt1GAe.png](https://s3.ax1x.com/2021/02/07/yt1GAe.png)](https://imgchr.com/i/yt1GAe)

解释一下：7为起点，8为终点，9为第一次操作的限制节点，控制总容量为$m$。10-15为层1，1-6为层2，它们之间建立航线。

其中流量关系为：$7\to 9$：$m$。$9 \to \text{层2}$与$\text{层2} \to 8$：各国家限额。$\text{层1} \to \text{层2}$：无穷。

费用关系：除了层1与层2有航线费用其余全部为0。

附上建立这个图的代码，其余部分就是费用流的板子了。

```cpp
    int m, maxflow = 0, mincost = 0, s, t, a, tot = 0;
    scanf("%d%d", &n, &m);
    tot = n;
    s = ++tot;
    t = ++tot;
    tot++;//第一辅助点，限制总流量的点
    add(s, tot, m, 0);
    add(tot, s, 0, 0);
    for (int i = 1; i <= n; i++)
    {
        scanf("%d", &v[i]);
        add(tot, i, inf, 0);//限额点到每个国家，可以为inf——反正后面还要限制出口的
        add(i, tot, 0, 0);
        add(i, t, v[i], 0);//出口记得限制
        add(t, i, 0, 0);
    }
    //以上为第一步操作
    for (int i = 1; i <= n; i++)
    {
        tot++;
        add(s, tot, v[i], 0);//tot为层1，代表国家，所以要限额
        add(tot, s, 0, 0);
        for (int j = i + 1; j <= n; j++)
        {
            scanf("%d",&a);
            if(a==-1)
                continue;
            add(tot, j, inf, a);//两层点之间的航线
            add(j, tot, 0, -a);
        }
    }//第二步操作
```
