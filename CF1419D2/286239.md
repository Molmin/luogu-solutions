#### [弱化版](https://www.luogu.com.cn/problem/CF1419D1)

#### [加强版](https://www.luogu.com.cn/problem/CF1419D2)

如果想做出加强版的话，建议不要看弱化版浪费时间，因为弱化版错误贪心也能过 ~~别问我怎么知道的~~

### 题意：

只有1组数据，一个n表示长度，n个数字[1,1e9]，要求任意排列n个数字，使得“严格小于左右两个数字的数字”个数最大

输出最大个数 和 排列， spj

### Solution：

先看样例：

```
3
3 1 4 2 4 2 5
```

~~是不是什么都没看出~~ ~~你看了结论就咋看咋觉得不应该看不出了~~

#### 结论（~~自己找~~）：

```
3 # 4 # 4 # 5
# 1 # 2 # 2 #
```

代码就不难写啦~

#### 简单口胡一下为什么是对的：

1. 首先分出“上下”两行，即“胜者组”跟“败者组”，败者组个数即为答案

这样为什么优呢？

首先明确：胜者一定大于等于败者

假如最后答案不是这样的，让一个“放错位置的胜者组”和一个“放错位置的败者组”交换位置：

之前败者能干的事，胜者也能，所以败者夹的数仍有贡献

胜者两边的数比它大，一定也比败者大，所以之前胜者的贡献也不会减少

2. 再让小的胜者匹配小的败者，大的胜者匹配大的败者

假如将这样得到的方案改动一下：

如果能力小的人有一件事做不了（证明这个“败者”和它一样大），而能力大的胜者可以做，

能力大的人一定严格大于所有败者，所以将它们换位置，能力大的人能做的事没有变多，能力小的人能做的事也没有变多

### Code:

```cpp
int n,a[N],b[N],ans,j;
signed main(){
	cin>>n;
	for(int i=1;i<=n;++i)cin>>a[i];
	sort(a+1,a+n+1);
	for(int i=1;i<=n;++i)if(!(i&1))b[i]=a[++j];
	for(int i=1;i<=n;++i)if(i&1)b[i]=a[++j];
	for(int i=2;i<n;++i)if(b[i]<b[i-1]&&b[i]<b[i+1])++ans;
	cout<<ans<<endl;
	for(int i=1;i<=n;++i)cout<<b[i]<<' ';
}
```

你可以去交弱化版~~随便AC~~啦！