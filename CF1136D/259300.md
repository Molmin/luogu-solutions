upd(2022.11.19)：更新了latex和部分描述。
## 前言
一道不错的思维题，但颜色偏高。

## 题意简述
- 有一个 $1\sim n$ 的排列。
- 给定 $m$ 对点对 $(u,v)$，表示若 $u,v$ 相邻，且 $u$ 在 $v$ 的前面，则可以交换 $u,v$ 的位置。（下文称 $u$ 可以往后跳，或 $v$ 可以往前跳）
- 求最后一个点最多可以往前跳几步。

## 题目分析
我们将除了 $n$ 号点（即最后一个点）以外的点分为两部分，一部分是可以跳到 $n$ 号点后面的点（称为**蓝点**），其他的称为**红点**。

显然，题目要求的就是最终能跳到 $n$ 号点后面的蓝点的个数。我们考虑这样一个问题：一个**最右边**的蓝点要跳到 $n$ 号点后面去，必定要先跳过这两个点中间的所有红点，并且中间的点既不能跳到 $n$ 号点后面去（~~它们是红点，它们没有资格qwq~~），他们中间的前后关系也不重要。**所以只要判断每个蓝点能否跳过中间的所有红点**。

怎么样判方便呢? 我们从后往前遍历，记录 $n$ 号点和当前点之间的红点个数 $cnt$，和每一个数能跳过这之间红点的个数 $num_i$。

- 如果新遍历到一个红点，我们将 $cnt \gets cnt+1 $，并更新所有能跳过这个红点的点 $i$，将 $num_i\gets num_i+1$，因为所有的关系总共只有 $m$ 个，所以复杂度是对的。

- 如果新遍历到一个蓝点，我们看看他能不能跳到 $n$ 号点后面去，换句话说，能不能跳过它和 $n$ 号点之间的所有红点（即 ```num[i]==cnt``` ）。如果可以，$ans \gets ans+1$，并默认把它赶到 $n$ 号点后面去（这样不会挡住后面蓝点的路径）；如果不行，**就把它变成红点**，并执行上述红点的操作。

时间复杂度为 $O(n+m)$。

## 代码
```cpp
int a[300005];	//点的编号
vector<int> mp[300005];		//存关系，mp[x]中为能跳到x后面的数
bool blue[300005];	//是否是蓝点（见上文）
int num[300005];	//（含义见上文）
int mian()
{
	int n=rd(),m=rd();
	for(int i=1;i<=n;i++)
		a[i]=rd();
	for(int i=1;i<=m;i++)
	{
		int u=rd(),v=rd();
		mp[v].push_back(u);
		if(v==a[n])
			blue[u]=1;
	}
	int ans=0;
	int cnt=0;
	for(int i=n-1;i>=1;i--)   //从后往前遍历
	{
		if(blue[a[i]])
		{
			if(num[a[i]]==cnt)  //可以跳
				ans++;	
			else
				blue[a[i]]=0;   //把它变成红点
		}
		if(!blue[a[i]])
		{
			for(int j=0;j<mp[a[i]].size();j++)   //更新所有点的num
			{
				int v=mp[a[i]][j];
				num[v]++;
			}
			cnt++;
		}
	}
	cout<<ans<<endl;
	return 0;
}
```
