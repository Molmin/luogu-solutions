## 原文阅读

[**重学最短路：步步递进，层层紧逼**](https://www.luogu.com.cn/blog/LinearExpectation/shortest-path-in-another-sight)

由于本题并不涉及那么多种的最短路算法，这里只介绍 Dijkstra 一种。

## Dijkstra 基础

现在我们一共有 $n$ 个节点，$m$ 条边（大概是有向边），以及一个初始节点 $s$，要求我们求出从 $s$ 到其他所有节点的最短路，怎么办呢？

首先我们需要一个数组 $d$，用于存储从 $s$ 到 $1\sim n$ 的最短路长度，表示为 $d_1\sim d_n$。于此类似的，我们需要一个 $e$ 数组来存储整张图，$e_{u,v}$ 表示从 $u$ 到 $v$ 的路径长度。此外，我们还需要一个数组 $vis$ 来确定从 $s$ 到一个节点的最短路是否被确定了。

首先，我们可以把 $s$ 的所有出边都加入到 $d$ 数组中，譬如这个图：

![](https://cdn.luogu.com.cn/upload/image_hosting/d3qg0843.png)

如果令 $s=1$，那么它的 $d=\{0,5,3,2,\infty,\infty\}$

接着我们需要在这个数组中找到最小的那个节点——也就是离出发点最近的那个节点，你会发现，这个记得点是 $4$，那么我们考虑走向 $4$ 号节点。

这时这个 $4$ 号节点的最短路就已经确定了，为什么？因为如果走任何一条其他路，刚走第一步就会比这条最短路要长，所以，直接走到 $4$ 必然比绕其他的路要来的短。那么，我们标记 $4$ 为已经确定最短路的点

接着我们要做的是考察 $4$ 号节点的所有出边，这时你需要看一看的是，如果我们从 $4$ 经过再到某个节点 $x$，会不会比直接从 $1$ 到 $x$ 更近？如果是的，那么更新最短路就可以了。

你发现 $1\to 4\to 5$ 长度为 $8$，比 $d_5=\infty$ 要小多了，那么更新吧！此时的的 $d=\{0,5,3,2,8,\infty\}$

这时，未确定最短路的点中，最小的是 $3$ 了，那就走向 $3$ 吧，并且把他标记为已经确定。$3$ 的出边指向 $4,5$，此时执行如下：

- $(1\to 3\to 4)>(1\to 4)$，不需要更新。
- $(1\to 3\to 5)<(1\to 4\to 5)$，需要更新。

这时候发现有一条路比原有的 $d_5$ 更小！那么就可以更新了更新完是这样：$d=\{0,5,3,2,7,\infty\}$。此时的 $vis$ 数组中 $1,3,4$ 都已经被确定了。我们把目光投向 $2$。

继续更新！此时的 $2$ 一共有 $3,6$ 两个出边，作类似的判断之后我们发现只有 $6$ 可以更新，那么 $d=\{0,5,3,2,7,10\}$，$vis={1,2,3,4}$。

接着的更新内容就简单地概述了：

- 看向 $5$ 号节点。
- 更新不了节点，$5$ 号设为确定。
- 看向 $6$ 号节点。
- 更新不了节点。

算法结束。这时候你会发现，有一部分边是没有走过的，我们只遍历了一些点，并且一直在走“权值最小”的那条路。这似乎是贪心，那么，他为什么正确呢？

对于一个不含负边的图，全局最小值不可能再被其他节点更新，因为每当 $x$ 被纳入了 $vis$ 数组，他的最短路就已经确定了，正如前文所说：“如果走任何一条其他路（走已经更新的最短路），所使用长度必然的比当前这条最短路要长，所以，现在这条老路不可能再被其他已确定最短路更长的路径更新了。”

由于这种算法不包含后悔的情况，所以不能应对含负权边的图。

由于有 $n$ 个节点，每个节点必然走过一次，且每次都需要在 $n$ 个 $d_i$ 中找最小值，且每次都要在找所有的出边，所以时间复杂度是 $O(n^2)$ 的。

## Dijkstra 优化

我们发现，在 $d$ 数组中找到最小值的这个过程可以优化，怎么优化呢？

如果用堆优化是 $O(m\log n)$，如果用优先队列时 $O(m\log m)$。但是也有说法说堆优化是 $O((n+m)\log n)$，似乎还挺优秀的。

由于 $m$ 最大时可以达到 $n^2$ 级别，所以时间复杂度看着办吧。似乎对于普通的数据并不容易出现 $m=n^2$ 这种情况（稠密图），所以对于随机数据，你可能可以选择卡常而不优化，但是面对刻意为之的数据，你不得不承认：这个优化是广泛而且有效的。

接下来的代码用链式前向星存图，如果不会请回到本文开头找资料。

首先你需要一个 $\rm\small node$ 类型，这种类型包含两个信息：$\rm\small id,dis$，分别是上文所说的“下标”和“距离起点的长度”。下标也就是这个节点的编号。接着我们重载运算符，让 $<$ 比较的“依据”是距离起点的长度，这样我们导入优先队列时，就自然按照距离排序，我们也就能够很容易取出“距离最短”的那个点了。

这一段的参考代码：

```cpp
struct node{
    int dis,id;
    bool operator <(const node &x)const{
        return x.dis<dis;
    }//重载运算符，比较节点的方式是比较其相距起点的距离
	//便于之后使用优先队列比较 
};
```

然后我们每次取出队头、弹出就行了。注意一些小优化：

- 处理 $x$ 节点时，如果他已经被处理过，就跳过。

为什么“已经确定”的节点还会再遇到一次？这是因为优先队列只能对队头进行操作，不能够实现删除任意元素，所以我们每次松弛都要压入。那这样为什么不会影响正确性呢？因为我们每次取出节点，都是取它“所有在队列中值”最小的那个，而既然“最小”，必定更符合要求，所以是正确的的。

- 遍历 $x$ 的出边 $y$ 的时候，如果处理过，就跳过。

没什么有用的优化，但是看着代码逻辑更清晰。

这里给出全文代码，可以结合注释理解。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define MAXN 1000005
#define MAXM 3000005
#define INF 4557430888798830399
struct edge{
	int to,w,nxt;
}e[MAXM];
int head[MAXN],dis[MAXN];
int n,m,s,cnt;
bool sure[MAXN];//通往该节点的最短路是否确定 
struct node{
    int dis,id;
    bool operator <(const node &x)const{
        return x.dis<dis;
    }//重载运算符，比较节点的方式是比较其相距起点的距离
	//便于之后使用优先队列比较 
};
void addedge(int u,int v,int w){
    e[cnt].w=w;//权值为 w 
    e[cnt].to=v;//终点为 v 
    e[cnt].nxt=head[u];//接到 u 的 "邻居链表" 开头 
    head[u]=cnt++;//把 "开头 " 更新为这条边 
}void init(){//初始化
    for(int i=0;i<=n;i++){
    	head[i]=-1;//尚未连边 
    	e[i].nxt=-1;//每个节点都没连边 
	}cnt=0;//一条边都没有 
}priority_queue<node>q;
void Dijkstra(){
	dis[1]=0;q.push((node){0,1});//压入起点 
	while(!q.empty()){
		node cur=q.top();q.pop();//当前处理的节点 
		int x=cur.id,d=cur.dis;
		if(sure[x])continue;//如果这个节点的最短路已经确定，跳过
		sure[x]=1;//否则标记为确定，并且开始着手确定
		for(int i=head[x];~i;i=e[i].nxt){//遍历出边 
			int y=e[i].to;//取出这条边 
			if(sure[y])continue;//如果取出了，就跳过 
			if(dis[y]>dis[x]+e[i].w){//如果路径更短 
				dis[y]=dis[x]+e[i].w;//松弛 
				q.push((node){dis[y],y});//加入队列 
			}
		}
	}
}signed main(){
	scanf("%lld%lld",&n,&m);
	init();//初始化 
	for(int i=0;i<=n;i++)dis[i]=INF;//全部设为 INF 
	for(int i=0;i<m;i++){
		int u,v,w;
		scanf("%lld%lld%lld",&u,&v,&w);
		if(u!=v)addedge(u,v,w);
	}Dijkstra();
	for(int i=1;i<=n;i++){
	    if(dis[i]==INF)printf("-1 ");
	    else printf("%lld ",dis[i]);
	}
	return 0;
}
```

之所以能应对重边，因为你存储的时候会把两个边都存下来。

这道题目需要注意 $\inf$ 的设置需要足够大。