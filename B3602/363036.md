Upd 2022.7.25：增加 SPFA 的解法。

Upd 2023.2.23：修改正确性证明中部分错误内容。


# 题目描述
题意很简单，就是让你通过程序求出从结点 $1$ 到其他节点的最短距离。

# 思路
本题做法颇多，这里重点介绍效率最高的 Dijkstra 堆优化算法。

## Dijkstra 堆优化算法
Dijkstra 堆优化算法是一种在**有向无环图**上求最短路的算法，是目前求**最短路效率最高的算法**。

在讲 Dijkstra 堆优化算法前，我们要先了解一个操作：**松弛操作**。

设 $d_i$ 为从结点 $1$ 到结点 $i$ 的最短路，并且现在有两个结点 $u$,$v$，且 $u$ 有一条边连向 $v$。设这条边的权值为 $w$。则松弛算法是这样实现的：

``if(d[u] + w < d[v])	d[v] = d[u] + w;``

这个松弛算法应该很好理解，就是**基于动态规划思想**实现的，应该算是初步的动态规划。

了解了松弛算法之后，我们就可以正式来看 Dijkstra 算法的实现了：

下面是一个有向无环图：

![](https://cdn.luogu.com.cn/upload/image_hosting/bwao3so4.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

我们将 d 数组全部初始化为正无穷，并知道 ``d[1]=0``，之后该算法主要重复两个步骤：

1. 在目前未确定最短路的点中找到最小的点，将其染成红色。
1. 枚举这个点的所有出边，看看能否松弛其他点。

如果不清楚的话，结合我的文字看看下面的图吧：

1. 将结点 $1$ 染红，然后遍历出边，松弛结点 $2$ 和结点 $3$。

![](https://cdn.luogu.com.cn/upload/image_hosting/zd6d65a1.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

2. 将结点 $3$ 染红，遍历出边，松弛结点 $2$ 和结点 $5$，其中结点 $2$ 不能松弛。

![](https://cdn.luogu.com.cn/upload/image_hosting/egrqy3px.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

3. 将结点 $2$ 染红，遍历结点 $4$ 和结点 $5$，因为结点 $5$ 之前是 $9$，现在是 $6$，所以可以被松弛。

![](https://cdn.luogu.com.cn/upload/image_hosting/lorghip1.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

4. 现在，结点 $4$ 和结点 $5$ 都为 $6$，我这里就直接一步把两个点都染红了。但实际上应该是先染结点 $4$ 再染结点 $5$。大家懂就好（不影响结果）。遍历结点 $1$，结点 $3$ 和结点 $5$。三者都已经确定，所以全部不能松弛。全部节点的最短路都已确定，程序结束。

![](https://cdn.luogu.com.cn/upload/image_hosting/ctmm4v1h.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

## 正确性证明

- **已选取节点不改性**

对于一直在更新迭代的距离数组 $d$，它的值**只会增加而不会减少**。因为**边的权值都是非负**的，每次更新距离只会在**已选取节点的距离上增加**，不可能存在另一条更短的路。正因如此，**Dijkstra 堆优化算法只能用于非负权图中**，如果出现负权，则该算法可能得出**错误答案**。

- **为什么贪心思路可行？**

设源点（即上图中的 $0$）为 $S$，距离 $S$ 最近的点为 $B$（即上图中的 $3$）。

1. 从 $S$ 直接确定 $B$ 的权值一定是正确的（不难证明）。

**反证法**：假设 $B$ 距离**不是最短**，**那么必定存在一个点 $C$，使得 $S\rightarrow C\rightarrow B$ 这条路比 $S\rightarrow B$ 这条路距离要短**。但是这样**违背了贪心步骤**：假如存在这样的 $C$ 点 我们选取到的**第一个点应该是 $C$ 而不是 $B$。**（因为全是非负权，易得 $S\rightarrow C$ 的距离会比 $S\rightarrow B$ 的距离小）。

2. 对于已经选取过的点，不妨把它看作为一个大的源点 $S$，那么新考虑的点符合上述的情况，归纳得证。

2.1. 为什么可以把选过的点看成一个更大的 $S$？
根据算法步骤 $2$，我们对**每一个选取过的结点的邻接点都尝试了松弛操作**，那就**不存在有大源点 $S$ 向外部的点的连边丢失**。如果大源点 $S$ 内有**多条边指向同一个外部节点 $x$**，其实最终也只会**保留最短的边**，因为其他更长的边权**被松弛替代了**。

3. 为什么不能负权？

这个比较好证明：如果有一条边权为负（设两个端点分别为为 $u$，$v$），那么就会出现这种情况：当全部点的最短路确定后，我们惊讶地发现：如果**在 $v$ 的最短路确定的情况下**，通过**走 $v\rightarrow u$ 这条路**，可以**使 $u$ 的最短路更短**。贪心思路失败，**因此不能出现负权**。

为什么松弛的时候不会直接走负权？很简单，负权的那条边对应的起点**不一定是当前点中到起点距离最小**的。而松弛其它边的时候有可能**把负权边的另一头也松弛掉了**。一旦终点那头被松弛，按照 dijkstra 的贪心思路，这一定是它的最短路，所以不会再动，就忽略了那条负权。

我们使用优先队列优化，每次都取距离最小的节点进行松弛。每个节点都**只会入队一次**，相应的**每条边也只会遍历一次**，加上优先队列单次插入、查询的复杂度，总时间复杂度是 $O((n+m)\log n)$。

------------
## SPFA 算法
SPFA 没有 dijkstra 稳定，最优效率也不如后者，但是它可以处理负权的情况，也可以判断负环，在某些情况下也要快于 dijkstra 的堆优化版本。

所以在一年后的今天，我加上了 SPFA 的解法（~~主要是学网络流，写一写当复习~~）。

SPFA 的原理与 dijkstra 很像，都是利用了松弛操作求最短路。但它程序执行的步骤不一样：
1. SPFA 使用普通队列，这意味着无法保证当前节点是距离最小的那个，所以一个点可能出队之后又再次进队。
2. 使用 $inque$ 数组标记节点是否在队列中。
3. 使用 $cnt$ 数组记录每个节点入队次数。如果某个节点进队次数大于等于 $n$，证明图中存在负环（这个待会会提到）。

其它就与 Dijkstra 很像了，放个带注释模板供大家参考理解：
```cpp
bool spfa(int s){
	memset(d, 127, sizeof(d));
	memset(inque, 0, sizeof(inque));//初始化
	d[s] = 0;
	q.push(s);
	inque[s] = 1, cnt[s]++;//登记起点信息
	while(!q.empty()){
		int u = q.front();
		q.pop();
		inque[u] = 0;//pop 掉以后把u标记为未入队
		for(int i=0;i<g[u].size();i++){
			int v = g[u][i].v;
			int w = g[u][i].w;
			if(d[u] + w < d[v]){
				d[v] = d[u] + w;//松弛
				if(inque[v] == 0){
					q.push(v);
					inque[v] = 1, cnt[v]++;//进队、进队标记、进队次数的变化
					if(cnt[v] == n)	return false;//存在负环，返回无解
				}
			}
		}
	}
	return true;//程序顺利结束，有解
}
```
### SPFA 判断负环
为什么某个节点进队次数大于等于 $n$ 就证明有负环？

首先我们明确负环的定义：图上的一个环，其边权之和为负。我们知道，这样的环是不存在最短路解的，因为可以越走越小。

一个节点的入度最多只有 $n-1$，即其他节点都与该节点有连边。当一个节点入队次数为 $n$ 时，证明有 $n$ 条路径都通向该节点。又因为入度最多只有 $n-1$，根据鸽笼原理，至少有两条路是重复的，即存在环。

存在环还不算什么，要是边权和是正的，走完整个环距离还是会变大。我们的程序是不会傻乎乎地看到环就撞进去的。所以只有一种可能：那就是出现了一个边权之和为负的环，也就是负环。



最后是时间复杂度：由于一个点可能进队多次，即一条边可能会被遍历多次，所以 SPFA 的时间复杂度是 $O(KE)$（$K$ 是常数，$E$ 为边数）。但是最坏情况下（好像是菊花图），SPFA 的时间复杂度可以被卡到 $O(VE)$（$V$ 是节点数）的。

在本题的弱化版（即 B3601）可用 SPFA 通过，但是本题就不行。尽管如此，SPFA 相比于 Dijkstra 却更重要。因为它在很多后续算法中都需要使用，因此务必牢记该算法（~~为什么不用 DIjkstra？还不是因为那该 s 的负权~~）。

~~归程：关于 SPFA，它死了……~~

## 一些小坑
- 输出时记得判断自环。
- 输入时注意重边。
- **五年 OI 一场空，不开 ``long long`` 见祖宗**。一定要记得开 ``long long``。
- 在本题中，用 ``memset`` 来初始化为 $127$ 是不行的，因为数据范围可能超出 ``int`` 范围，$127$ 并不是最大值。所以，应该用最朴素的循环手动赋一个很大的值。

## 代码
我使用 dijkstra 堆优化算法。以下是参考代码，珍爱生命，远离抄袭。

Code：
```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;

struct edge{
	ll u, v, w;
};

const int N = 2000 + 10;
vector<edge> g[N];
priority_queue<pair<ll, ll> > q;
int n, m, u, v, w, d[N], visit[N];
//d[i]表示每个点到起点的距离，visit[i]表示是否确定最短路 

void dijkstra(ll s){//s为起点 
	memset(d, 127, sizeof(d)); 
	memset(visit, 0, sizeof(visit));//初始化 
	d[s] = 0;
	q.push(make_pair(0, s));//起点信息入队 
	while(!q.empty()){
		ll u = q.top().second;//取出队头元素的编号 
		q.pop();
		if(visit[u] == 1)	continue;//这里是堆优化算法的核心，如果已经染色了，就不用再循环了 
		visit[u] = 1;//模拟将最小的点染成红色 
		for(int j=0;j<g[u].size();j++){//枚举所有出边 
			ll v = g[u][j].v;//出边所指的点 
			ll w = g[u][j].w;//v的权值 
			if(d[u] + w < d[v]){//松弛操作 
				d[v] = d[u] + w;
				q.push(make_pair(-d[v], v));//为什么是-d[v]？自己思考一下~ 
			}
		}
	}
}

int main(){
	cin >> n >> m;
	for(int i=1;i<=m;i++){
		cin >> u >> v >> w;
		g[u].push_back((edge){u, v, w});
	}
	dijkstra(1);
	for(int i=1;i<=n;i++){
		if(d[i] == 2139062143)	cout << -1 << ' ';
		else	cout << d[i] << ' ';
	}
	cout << endl;
	return 0;
}
```
本篇题解到此结束，如果对你有帮助记得点个赞哦！