## 题解 CF1485B 【Replace and Keep Sorted】

### 题意

+ 给定 $k$ 和长度为 $n$ 的严格递增数列 $a$，$a_i\le k$；
+ 两个数列 $k$ 相同当且仅当：两个数列长度相等，都严格递增，有且仅有一个数不同；
+ $q$ 次询问，求有 $a_l,a_{l+1},\dots,a_{r}$ 和多少个数列 $k$ 相同。

### 做法

其实可以看成在 $a_l,a_{l+1},\dots,a_{r}$ 中修改一个数，使其还是严格递增，有多少种方案。

因为只修改一个数，所以每个位置对答案的贡献独立，根据加法原理，就可以计算每个数可以修改为多少个数，然后加起来，注意特判两端。

时间复杂度 $O(qn)$，显然无法通过。

---

然后很多大佬就开始做什么前缀和优化，然后推出一个在我这种蒟蒻看来很复杂的式子。

---

但我这里有一种更好理解的算法。

只修改一个数，每个位置对答案的贡献独立；只修改出一个新的数，所以每个修改出的数也对答案的贡献独立。

对于任意 $j=a_i(l\le i\le r)$，$j$ 的贡献为 $0$。因为如果改的是 $a_i$，绝不可能还是 $j$；如果不是 $a_i$，改成 $j$，严格递增就被破坏了。

对于任意 $j(a_l\le j\le a_r,j\ne a_i)$，$j$ 的贡献为 $2$，分别是从它左右两边的数修改而成，如果从其他数修改，也会破坏严格递增。

对于任意 $j(j<a_l \operatorname{or} a_r<j)$，显然 $j$ 的贡献为 $1$。

那式子就不难推出了。

### 代码

```cpp
#include <cstdio>

using namespace std;

const int N = 1e5 + 5;

int arr[N];

void run() {
	int n, q, k;
	scanf("%d%d%d", &n, &q, &k);
	for (int i = 1; i <= n; ++i) {
		scanf("%d", &arr[i]);
	}
	for (int i = 1; i <= q; ++i) {
		int l, r;
		scanf("%d%d", &l, &r);
		int ans = arr[l] + k - arr[r] - 1;
		ans += ((arr[r] - arr[l] + 1) - (r - l + 1)) * 2;
		printf("%d\n", ans);
	}
}

int main() {
	run();
}
```