又是一个难度虚高的无思维难度题。

树上子树操作直接搞 dfs 序下来，那么 u 的子树区间在 dfs 序上对应 $[dfn_u,dfn_u+siz_u-1]$。

问题转变为区间操作，注意到 m 很小，而我们只关心有多少种并不关心具体数量，所以直接对线段树上每个结点开一个 bitset 即可。

区间加就相当于这个区间的 bitset 集体左移，注意还有最左边的一部分位要移到最右边。

这里口胡一下 bitset 的区间清 0 的操作，比如要将后 len 位清零就先右移 len 位再左移回来即可。

在外面预处理一个质数的 bitset，那么答案为区间的 bitset 或起来，然后再与上质数的 bitset，答案就是 1 的个数。

复杂度 $O(\frac{nm\log n}{w})$。实测跑得不慢，只用了 1.2s。

https://codeforces.com/contest/633/submission/167127754