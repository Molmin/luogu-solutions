题意简述：黑板上有一个 $p$ 进制数 $x$。每次可以从黑板上任意拿出一个数，加一后写到黑板上去。问操作多少次之后可以让黑板上出现从 $0$ 到 $p$ 的所有**数位**。

主要考察思维的严谨全面性。建议评绿或蓝。

***

首先，如果盯紧某个数，对它操作 $p-1$ 次，显然就可以得到所有的数位。不过，有些数字已经存在了，操作的次数可以不需要这么多。

考虑这个 $10$ 进制数：$124567890$。此时唯独 $3$ 没有出现。虽然 $1,2$ 都已经出现了，但是因为每次只能递增 $1$，所以仍然需要操作 $3$ 次。

也就是说可以从两端向中间考虑。首先找到最大的 $x$ 和最小的 $y$ 使得 $[1,x]$、$[y,p-1]$ 都已存在。然后看个位，记作 $a_1$。

- 如果 $a_1<x$，说明只要一直递增上去到 $y$ 就完事了。
- 如果 $a_1>x$，此时你需要一直加，加到进位，然后你才能去解决那些 $[x,a_1)$ 的部分。

两种情况都是好处理的：第一种直接算；第二种需要注意：进位之后可能会产生新的数字，所以必须模拟高精度进位的过程，并且把新的数字统计进去。

可能会有人问：有没有更优解？为什么 $a_1<x$ 一定要递增到 $y$ 呢？建议自行思考后再看文末的解释。~~（能做 *1800 大概都有这个水平自己思考了吧~~

```cpp
void sol(){
	set<int>s;
	cin>>n>>p;
	for(int i=n;i;i--)cin>>a[i],s.insert(a[i]);
	a[n+1]=0;
	if(s.size()==p)return cout<<0<<endl,void();
	int L=0,R=p-1;
	while(s.count(R))R--;
	while(s.count(L))L++;
	if(a[1]<L)return cout<<R-a[1]<<endl,void();
	int ans=0,v=a[1];
	ans+=p-a[1],a[1]=p;
	for(int i=1;i<=n;i++){
		if(a[i]>=p){
			a[i+1]+=a[i]/p,a[i]%=p;
		}
		s.insert(a[i]);
	}
	if(a[n+1])s.insert(a[n+1]);
	while(s.count(v))v--;
	cout<<ans+max(v,0)<<endl;
}
```
解释：显然从 $x$ 到 $y$ 的过程中不可能发生进位。所以唯一的制造新数位的方式就是在个位不停加一。就算 $a_1$ 和 $y$ 中间已经有数字出现过了，但是不经过这些数字你照样到不了 $y$。所以只能一步一步走过去，即 $y-a_1$ 步。