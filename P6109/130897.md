考虑对 $x$ 轴扫描线：当扫到矩形的 $l_x$ 的时候，将 $[l_y,r_y]$ 加上 $w$，而当扫到 $r_x+1$ 的时候，将 $[l_y,r_y]$ 减去 $w$；相当于实时维护了，扫描线所在的那一行上的 $a$ 值.

若询问仅有一行，利用线段树直接查询区间最大值即可.

若询问在 $x$ 轴上是一个前缀，可以再维护历史最大值信息，直接查询历史最大值即可.

考虑分治，按照指定位置 $\lambda$ 划分，让线段树从位置 $\lambda$ 开始记录历史最大值；这样，对于询问矩形 $[l_x,r_x]$，就能够处理掉 $[\lambda,r_x]$ 这些行这部分的询问.

利用猫树来刻画这个分治，在 $x$ 轴上开猫树：对于每个结点 $[l_x,r_x]$，令其从 $l_x$ 开始记录历史最大值，一直记录到 $r_x$ 为止；每个询问矩形 $[l_x,r_x]$，会在猫树上被反映为，一个结点代表区间的一段后缀、和另一个结点代表区间的一段前缀，以这个前缀为例，相当于扫描线在 $[l_x,i]$ 这些时刻中，在 $[l_y,r_y]$ 这段区间上的历史最大值；由于该结点正是从 $l_x$ 开始记录的，在 $i$ 时刻对该结点代表的线段树进行查询即可.

在具体实现中，不能对每个结点开一棵线段树，可以考虑对猫树的每一层开一棵线段树，共计 $\log n+1$ 棵：扫描线扫到 $i$ 时，对于所有满足「该层上存在结点，其左端点恰好为 $i$」的层，让该层代表的线段树“忘记历史”，即将历史最大值清零；查询时，只对查询区间所挂结点所在层，代表的那一棵线段树进行查询即可.

此题时限较紧，维护历史最大值最好不写矩阵而是写下传标记；对于“忘记历史”的操作，只需要对序列中的所有值都加上充分大 $+\Delta$，随后询问时再 $-\Delta$ 即可，即可让以前的历史最大值湮没.

该算法的时间复杂度为 $\mathcal{O}(m\log^2 n+(n+q)\log n)$，空间复杂度为 $\mathcal{O}(n\log n)$.

代码实现(具有极其严重的个人风格)：https://www.luogu.com.cn/paste/qn046lm7.