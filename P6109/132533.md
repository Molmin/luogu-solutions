**P6109** 题解。

难度主要集中在实现与想到猫树两个环节。

~~毕竟想到猫树这个题就结束了，至少个人是这样的。~~

---------------------------------------------------------

考虑问题看似三维，**但是修改操作全在查询操作前面，所以问题是二维的。**

观察 $n \leq 5 \times 10 ^ 4,m \leq 5 \times 10 ^ 5$，猜测正解复杂度是 $O(n \log ^ 2 n + m \log n)$ 之类的，至少 $n,m$ 摊的不平衡。

考虑若询问形式是一个一维为前缀的矩形 $[(1,r),(L,R)]$，我们可以对于所有修改拆分成 $(l,n,L,R,x)$ 以及 $(r + 1,n,L,R,-x)$ 的形式，即**将第一维看成时间维，维护第二维在每个时刻时的情况**。

那么对于一个一维前缀矩形，这东西就是一个区间历史最值，可以通过吉司机线段树维护。

这里需要注意的是，由于吉司机线段树维护的历史版本是基于每一次操作的历史信息，可是我们在这道题**需要的是每个时刻的序列信息，而每个时刻可能存在很多次操作**。考虑到我们维护的是区间最大值，而操作只有区间加减，所以我们让一个时刻加的数是负数的操作先进行，正数的操作后进行，才可以保证最后维护的信息是正确的。个人在这里调了 1h 左右，希望看到这篇题解的同学能留个心。

一维前缀矩形能做，一维后缀矩形一定也能做，考虑到猫树的使用条件：支持快速的二区间合并，并且合并的是前缀信息与后缀信息，于是直接往上套就好了。

对于查询，显然放在 $[l,r]$ 一个猫树节点上回答，并且该节点的中点被 $[l,r]$ 所跨越，该查询的答案拆成了 $[l,mid]$ 的后缀信息与 $[mid + 1,r]$ 的前缀信息。

对于修改，我们可以利用一个区间在线段树上经过的节点不超过 $O(\log n)$ 个的性质。若当前修改操作的 $[l,r]$ 完全覆盖了左/右节点，就直接不回撤这个修改操作继续向下走；若未完全覆盖左/右节点就看与左右节点是否有交，将操作拆开继续下放。

在每个节点前缀矩形/后缀矩形查询的操作即可。不过在一个节点往下走时，我们要回撤当前节点进行的所有非完全覆盖下走节点的修改操作，并打上一个将当前节点历史版本最大值更新为当前节点节点最大值的标记（即删除当前节点的所有历史信息，因为下一个节点不需要用到当前节点的历史最值信息）；同理，在处理完一个节点要回溯时，我们也要打上一个将当前节点历史版本最大值更新为当前节点最大值的标记。

关于这个标记怎么打，我们可以让当前节点下放到儿子，儿子下放到孙子，进行两层下放，这里给出一个简短但常数极大的实现：

```cpp
inline void upd(int p,int fa)
{
	if(!t[fa].histag && !t[fa].tag) return;
	t[p].hismaxn = max(t[p].hismaxn , t[p].maxn + t[fa].histag);
	t[p].histag = max(t[p].histag , t[p].tag + t[fa].histag);
	t[p].maxn += t[fa].tag , t[p].tag += t[fa].tag;
}
inline void reg(int p,int fa)
{
	upd(p , fa);
	t[p].hismaxn = t[p].maxn , t[p].histag = 0 , t[p].clr = 1;
}
inline void Upd(int p,int fa)//对一个点打上父亲的标记，注意对整体打历史信息删除时要顺手写一个 Upd(1 , 0) 
{
	if(t[p].clr)//表示当前是否有将当前节点历史版本最大值更新为当前节点最大值的标记
	{
		reg(ls(p) , p);
		reg(rs(p) , p);
		t[p].clr = t[p].tag = t[p].histag = 0;
	}
	upd(p , fa);
}
inline void push_down(int p)
{
	Upd(ls(p) , p) , Upd(rs(p) , p);
	t[p].tag = t[p].histag = 0;
}
void Base()//对整体打一个将当前历史版本最大值更新为节点最大值的标记
{
	t[1].clr = 1 , t[1].hismaxn = t[1].maxn , t[1].histag = 0;
	Upd(1 , 0);
}
```

按照上述操作模拟题意即可。

存在 $O(n)$ 空间复杂度的实现方法，但为图方便可以对每层节点开一个 vector 存放操作。

如果被卡常，可以尝试加快读，inline。

时间复杂度 $O(n \log ^ 2 n + m \log n)$。