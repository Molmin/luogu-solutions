前缀和

这道题实际上是本蒟蒻的学校模拟赛的题F   ~~出题老师请用点心~~

然后写了个暴力   ~~之前做过的最大正方形都做过的呢（尴尬）~~

实际上暴力是需要加一个小优化

不然是会超时的

## 算法以及优化

两重循环枚举牛棚的左上坐标

一重循环枚举长度

两重循环判断有没有树

O（n^5) ~~（1 <= N <= 1000）~~ 显然会超时QAQ

那么来优化吧

稍微有一点经验的OIER也知道

最后两重循环实际上可以用前缀和

sum [  i  ]   [  j  ] 表示（1，1）~（i，j）有多少棵树

求 (x1,y1)~(x2,y2) 有多少棵树 (x2>x1, y2>y1)

易得 用容斥原理 

sum[  x2   ] [ y2 ] - sum[ x1-1 ] [ y1 ]-sum[ x1 ][ y1-1 ] +sum [ x1-1 ] [ y1-1 ]

那么代码就出来啦 

就是枚举长度不要出界

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,T,ans,a[1005][1005],sum[1005][1005];
int main() {
    int x,y;
    cin>>n>>T;
    for(int i=1;i<=T;i++) 
    {
         cin>>x>>y;
         a[x][y]=1; 
    }
    for(int i=1;i<=n;i++)
      for(int j=1;j<=n;j++)
       sum[i][j]=sum[i-1][j]+sum[i][j-1]-sum[i-1][j-1]+a[i][j];
    for(int i=1;i<=n;i++)
      for(int j=1;j<=n;j++)
       {
           int l;
           for(l=1;i+l-1<=n&&j+l-1<=n;l++)
           if(sum[i+l-1][j+l-1]-sum[i-1][j+l-1]-sum[i+l-1][j-1]+sum[i-1][j-1]!=0) break;
           ans=max(ans,l-1);//因为当lbreak时是放不下的，所以要-1
       }
    cout<<ans<<endl;
    return 0;
} 
```
~~想AC没那么容易————says  O（n^3) （1 <= N <= 1000）~~

嗯 这个是会超时的

实践证明

但是我们只需要再改几个字就够了

l可以从ans开始循环 （1~ans） 可以不用枚举

有点像最优解剪枝

跑出来最慢的只有27ms dp肯定更快

但是对于暴力来说已经足够了

实际上可以更快

枚举长度还可以用二分

读入数据大用快读

但是蒟蒻没心情弄了（题E还没打好就来打题解）

各种更快优化等你来拿
