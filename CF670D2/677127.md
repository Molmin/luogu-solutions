# Part 1 题目意思
今天我们要来造房子。造这个房子需要 $n$ 种原料，每造一个房子需要第 $i$ 种原料 $a_{i}$ 个。现在你有第 $i$ 种原料 $b_{i}$ 个。此外，你还有一种特殊的原料 $k$ 个，每个特殊原料可以当作任意一个其它原料使用。那么问题来了，你最多可以造多少个房子呢？
# Part 2 思路分析
这道题先分析一下数据，作为一名信息学竞赛的学生，分析数据就是一件必不可少的事情。根据题目答案最大 $2\times10^9$ 推出，必定要使用二分答案，那二分答案是什么呢？我就来好好说到说到。
# Part 3 二分查找
在说二分答案之前，先要来说一说二分查找。先来一道题目：有一个由小到大的数列，从中搜索一个数的下标。根据这道题目，我们就来看一下二分查找的模板。
```cpp
while(l<r){
    mid=lt+(r-l)/2;
	if(num[mid]>=s){ //这里的s就是我们要搜索的数
		r=mid;
	}else{
		l=mid+1;
	}
}
```
就是我们从这个数列的中间这个数开始比较，是中间这个数大还是我们要找的这个数大，所以就有三种情况：

|情况|  做法|
| :----------- | :-----------|
|  中间的数=要找的数|      向数列的左边搜索，因为要找到第一次出现这个数的下标|
|  中间的数>要找的数|     向数列左边搜索 |
| 中间的数<要找的数 |  	向数列右边搜索|

这个时候我们不断去重复上述操作，我们可以用 $l$ 来存储这个数列开始的坐标，$r$ 来存储这个数列结束的坐标，$mid$ 来存储这个数列中间这个数的坐标。
#### 注意：找 $mid$ 的值我们最好使用 $l+(r-l)/2$ 而不是 $(l+r)/2$，因为假如这个数列很大, $l+r$ 有可能直接爆了。
那么最后我们就可以找到这个数的下标了，我们要这个数的下标如果简单的遍历，那么时间复杂度就是 $O(nm)$,用二分就可以把时间缩短到 $\log\times n$。
# Part 4 二分答案
  那么接下来，我们在知道了二分搜索的前提下，我们来看一看二分答案，二分答案的实质就是把前面二分搜索的数列变为我们答案的所有可能性，$mid$ 就是我们尝试的答案，二分答案的前题就是答案具有单调性，直接将有点难以理解，还是直接上[题](https://www.luogu.com.cn/problem/P1577)。

首先是看一下题目，是符合单调性的，然后这些长度都是两位小数，非常不方便我们二分，这边就把所有的长度都 $\times100$，最后把答案再 $/100$，就可以避免了。
  
我们这里假设，绳子最长是题目里给的 $100000.00\times100$ 后就是 $10000000$，这就是答案的最大值，不可能会比这个大，那么答案的最小值就是 $0$，所以 $l=0,r=10000000$，所以我们这里把这个数组开始二分，那么现在的难点就是验证这个答案能不能取到。
  
我们现在用每一个长度去除以 $mid$，把每一个段数加起来，然后把这个总段数和我们要的段数 $K$ 进行比较，我们假设这个总段数为 $num$，结论：



 情况| 做法
| :----------- | :----------- |
| $num>K$| 向右搜索| 
|  $num=K$|  向右搜索|
| $num<K$ |  向左搜索|


向右搜索，我们就把 $l=mid$ 向左搜索，我们就把 $r=mid$ 然后不断收缩，这个 $mid/100$ 就是最终的答案。
# Part 5 代码部分
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int maxn=1e6+5;
ll n, k, a[maxn], b[maxn];
bool check(ll mid) 
{
	ll kk=k;
	for(int i=1;i<=n;i++) 
	{
		if(mid*a[i]-b[i]>0) 
		{
			kk-=mid*a[i]-b[i];
			if(kk<0)return false;
		}
	}
	return true;
}
int main()
{
	cin>>n>>k;
	for(int i=1;i<=n;i++)
	{
		cin>>a[i];
	}
	for(int i=1;i<=n;i++)
	{
		cin>>b[i];	
	}
	ll l=0,r=2e9;
	while(l<r) 
	{
		ll mid=l+(r-l+1)/2;
		if(check(mid))
		{
			l=mid;
		}
		else 
		{
			r=mid-1;
		}
	}
	cout<<l<<endl;
}
```
