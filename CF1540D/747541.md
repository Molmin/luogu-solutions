> 然而没有看见树状数组……

在这道题的启发下，我写了关于逆序对的这篇文章：[算法学习笔记(22): 逆序对与原序列](https://www.cnblogs.com/jeefy/p/17447403.html)。~~安利一下博客 QwQ~~。

这里，$O(nq)$ 的算法我就不说了，以下相当于通过分块优化这个算法。

考虑以下事实：

- 对于一定的序列 $b_i$，如果初始值为 $r$，则经过操作后 $r \to r'$ 的结果是一定的。这启发我们可以分块。
  
- 而考虑对于每一个 $r \in [1, n]$，对应的结果 $r'$ 一定是不下降的。也就是说 $r$ 越大，$r'$ 越大。~~或者是说我们令 $f(r)$ 表示 $r$ 经过了序列之后变成的值，$f$ 是一个单调不下降序列。~~

于是对于每一块，考虑用线段树（或者树状数组等神秘数据结构）维护（需要支持区间加和二分求某个值的位置），初始 $T_i= i$。

按顺序加入 $b_j$，考虑先找到**所有** $\ge b_j$ 的 $T_i$ ，并整体加 $1$。不难发现，其实每一次只是后缀 $+1$，又由于原序列的**单调**的，所以新的序列是**单调**，这为二分查找提供了保障。

> 补充一下关于使用树状数组这件事。
> 
> 复杂度为 $O(B \log^2 n)$ 是单纯的二分 + 树状数组。然而如果使用**树状数组上二分**的操作可以避免一个 $\log$，也就是复杂度成为 $O(B \log n)$。这样可以过。
> 
> 提交：<https://codeforces.com/contest/1540/submission/211432601>
>
> 因为树状数组的下标我整体加了 $1$，所以二分那个地方可能有点难以理解。

于是我们可以在 $O(B \log n)$ 的复杂度中处理出 $T_i$，并可以在 $O(\log n)$ 内找到变换对应的值。于是查询的复杂度为 $O(\frac nB \log n)$。

修改？暴力重构每一块就是了。复杂度为 $O(B \log n)$。

块长设为 $\sqrt n$ 即可，总复杂度为 $O(n \sqrt n \log n)$。毕竟是 5s 时限，还是可以过的。

> 然而肯定会有更优秀的做法，参考其他大佬的题解或博客。
>
> 还有一位大佬的：[CF1540D. Inverse Inversions - jz_597 - 博客园](https://www.cnblogs.com/jz-597/p/14956261.html)
> 
> 虽然我看不懂它……