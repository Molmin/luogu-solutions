## 题目大意
给定二维数组 $A$ 以及 $Q$ 组询问，问对于每组询问，除 $-1$ 外（$-1$ 可以代替任何数，即询问的 $-1$ 忽略不计)，$A$ 中存在多少行与它完全相同（包括数字的位置相同和数的大小相等）。
## 思路
数据范围较小，可以枚举解决。既然 $-1$ 忽略不计，那就直接判断除 $-1$ 外的数就好了，因为询问的数组长度与二维数组的列宽（即 $M$）是一样的，所以直接一行行扫就好了，因为读入数的位置就等于需要在二维数组里找的位置。
## 解法
那么我们可以每读入一个数（每一组共读入 $M$ 次），就将他与二维数组中所有行中和它的处在同一个位置（同一列）的数进行比较（每一个数比较 $N$ 次），我们不妨开 $vis$ 数组来记录（注意初始化为 $1$），如果当前数不等于 $-1$ 且不等于当前行的那个数，那么把这一行标记为 $0$ 就好了。一直重复执行直到所有数输入完，此时统计 $vis$ 为 $1$ 的个数，那么这个个数就是这一组询问的结果了（共重复 $Q$ 次）。

------------
#### 时间复杂度
通过上文括号内的解释，不难发现时间复杂度为 $O(nmq)$，完全可以接受。
## AC代码
```cpp
  #include<bits/stdc++.h>
  using namespace std;
  int n,m,q,a[1005][1005],vis[1005];
  int main()\mathcal{O}
  {
      cin>>n>>m;
      for(int i=1;i<=n;i++)
          for(int j=1;j<=m;j++)
              cin>>a[i][j];
      cin>>q;//以上为读入 
      for(int ii=1;ii<=q;ii++)
      {
          memset(vis,1,sizeof(vis));//记住初始化 
          int ans=0,b;
          for(int j=1;j<=m;j++)//j表示列，也就是这组询问的这个数对应的列 
          {
              cin>>b;//单个读入节省空间 
              for(int i=1;i<=n;i++)//n代表一行行扫 
              {
                  if(a[i][j]!=b&&b!=-1)//不相同且不为-1，则该行排除，标记为0 
                      vis[i]=0;
              }
          }
          for(int i=1;i<=n;i++)
              if(vis[i])
                  ans++;//统计为1的（即满足条件的） 
          cout<<ans<<endl;
      }
  }
```
感谢各位能看完，在这给大家拜个晚年（~~真·晚~~）
## THE END