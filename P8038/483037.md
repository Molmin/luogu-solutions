## 题意
~~我语文不好，硬是看了半天才懂。。。~~

给你一个二维数组，询问 $Q$ 次，每次询问给你一个序列，问有**多少行**（注意是多少行，不是第几行）的每个数不是和序列中的这个位置的相同，就是序列中这个位置的数是 $-1$ 。

如果你题意理解了，那么恭喜你，这个题你已经做完一大半了。

但还剩一个重点，就是**比对**。

看其他题解都是直接在主函数中逐一比对，但其实那样会非常麻烦，还要引入一个变量来判断是否成功。所以建议把比对的过程**包装成函数**，写起来会方便许多。

由于这是个入门的题，所以做出来不难，但养成良好的**代码习惯**非常重要！例如逗号、符号前后打上空格、重点语句后面打上空格、打上主函数的结束等。题目变难后，码风好的优势就会发挥出来。

## 代码：

```cpp
#include <iostream>
using namespace std;

int n, m, q;
int a[1005][1005], b[1005];

bool chk(int h){
	for (int i = 1; i <= m; i++)
		if (b[i] != -1 && b[i] != a[h][i])//判断条件
			return false;//此时就会退出函数了，不需要多余的判断，所以方便。
	return true;
}

int main(){
	cin >> n >> m;
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= m; j++)
			scanf("%d", &a[i][j]);
	cin >> q;
	while (q--){
		for (int i = 1; i <= m; i++)
			scanf("%d", b + i);
		int ans = 0;
		for (int i = 1; i <= n; i++)
			if (chk(i))//包装成函数更方便！
				ans++;
		printf("%d\n", ans);
	}
	return 0;
} 
```
