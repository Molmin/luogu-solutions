## 算法选择

本题可以使用动态规划解题。

为什么选择动态规划算法解决本题？

动态规划问题的三要素为：**阶段**、**状态**、**决策**。而这三个要素在本题的题面中已经有了较为明显的暗示：

- 菜是一道一道上的，这自然地将用餐流程划分成了不同**阶段**。
- 高桥君的身体状况有好有坏，这可以作为动态规划算法设计的**状态**。
- 对于每道菜，高桥君都要做出品尝或跳过的**决策**。

看懂了这些暗示，自然而然就会想到动态规划算法解决本题。

## 动态规划算法设计

设 $ dp[i][j] (i \in [1, N], j \in \{0, 1\}) $ 的含义如下：

- $ dp[i][0] $ 表示在对第 $ i $ 道菜做出决策后，高桥君感到舒适，此时他所品尝的菜肴的美味程度之和的最大值。
- $ dp[i][1] $ 表示在对第 $ i $ 道菜做出决策后，高桥君感到不适，此时他所品尝的菜肴的美味程度之和的最大值。

不难设计出状态转移方程：

- 当 $ X_i = 0 $ 时，
    - 如果高桥君在对这道菜做出选择后感到舒适，有以下三种情况：
        - 在这道菜上菜之前，高桥君感到舒适，而且他选择跳过这道菜。
        - 在这道菜上菜之前，高桥君感到舒适，而且他选择品尝这道菜。
        - 在这道菜上菜之前，高桥君感到不适，而且他选择品尝这道菜。
    - 综合上述三种情况，可以得出状态转移方程：
    $$
    dp[i][0] = \max\{dp[i - 1][0], dp[i - 1][0] + Y_i, dp[i - 1][1] + Y_i \}
    $$
    - 如果高桥君在对这道菜做出选择后感到不适，只有一种情况：
        - 在这道菜上菜之前，高桥君感到不适，而且他选择跳过这道菜。
    - 故状态转移方程为：
    $$
    dp[i][1] = dp[i - 1][1]
    $$
- 当 $ X_i = 1 $ 时，
    - 如果高桥君在对这道菜做出选择后感到舒适，只有一种情况：
        - 在这道菜上菜之前，高桥君感到舒适，而且他选择跳过这道菜。
    - 故状态转移方程为：
    $$
    dp[i][0] = dp[i - 1][0]
    $$
    - 如果高桥君在对这道菜做出选择后感到不适，有以下两种情况：
        - 在这道菜上菜之前，高桥君感到不适，而且他选择跳过这道菜。
        - 在这道菜上菜之前，高桥君感到舒适，而且他选择品尝这道菜。
    - 综合上述两种情况，可以得出状态转移方程：
    $$
    dp[i][1] = \max\{ dp[i - 1][1], dp[i - 1][0] + Y_i \}
    $$

起初，高桥君什么也没吃，故边界条件为：
$$
dp[0][0] = dp[0][1] = 0
$$

在高桥君对所有 $ N $ 道菜都做出选择后，我们也得到了最终答案：
$$
ans = \max\{ dp[N][0], dp[N][1] \}
$$

时间复杂度与空间复杂度均为 $ \mathcal{O}(N) $，足以通过。

根据以上分析，不难写出程序。

## 进一步优化

从上面的状态转移方程可以看出，一个阶段的答案仅需从上一个阶段的答案推出，故我们可以使用滚动数组技巧，对空间复杂度进行优化。

将上面的 $ dp[i][0] $ 改为 $ healthy $，将 $ dp[i][1] $ 改为 $ upset $，新的状态转移方程如下：

- 当 $ X_i = 0 $ 时，
    - $ healthy = \max\{ healthy, \max\{ upset, healthy \} + Y_i \} $
    - $ upset $ 无需更新。
- 当 $ X_i = 1 $ 时，
    - $ healthy $ 无需更新。
    - $ upset = \max\{ upset, healthy + Y_i \} $

边界条件为：
$$
healthy = upset = 0
$$

最终答案为：
$$
ans = \max\{ healthy, upset \}
$$

时间复杂度仍为 $ \mathcal{O}(N) $，但是空间复杂度已经被优化到了 $ \mathcal{O}(1) $。

## 代码

这里仅给出滚动数组优化后的代码。

```cpp
#include <iostream>
using namespace std;

int main() {

    long long healthy = 0, upset = 0;
    int n;
    scanf("%d", &n);
    for (int i = 1; i <= n; ++i) {
        long long type, tastiness;
        scanf("%lld %lld", &type, &tastiness);
        if (type) {
            upset = max(upset, healthy + tastiness);
        }
        else {
            healthy = max(healthy, max(upset, healthy) + tastiness);
        }
    }

    printf("%lld\n", max(upset, healthy));

    return 0;
}
```
