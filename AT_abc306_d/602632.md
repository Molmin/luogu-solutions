# 题目大意
Takahashi 在一家餐厅享用一顿由 $N$ 道菜组成的特别菜单。

第 $i$ 道菜有以下定义。

- 如果 $X_i=0$，那么是一道有着 $Y_i$ 美味度的解毒菜。
- 如果 $X_i=1$，那么是一道有着 $Y_i$ 美味度的有毒菜。 

当 Takahashi 吃一道菜时，他的状态会发生以下变化。

初始状态下，Takahashi 的胃很健康。
>当他的胃很健康时，如果他吃了一道解毒菜，他的胃仍然很健康。如果他吃了一道有毒菜，他的胃会不舒服。

>当他的胃不舒服时，如果他吃了一道解毒菜，他的胃会变得健康。如果他吃了一道有毒菜，他会死亡。

就餐时按照顺序重复以下过程，对于 $i=1,2,3,\dots N$。
首先，第 $i$ 道菜被端到 Takahashi 面前。
然后，他选择是否“吃下”或“跳过”这道菜。
- 如果他选择“吃下”，他会吃掉第 $i$ 道菜。
- 如果他选择“跳过”，他不会吃掉第 $i$ 道菜。

**他的状态也会根据所吃的菜而改变。**

求进行 $N$ 轮后，没有死亡的 Takahashi 能吃到的最大美味值。
# 思路
这道题一眼就可以看出来使用动态规划。

对于每道菜我们有选或不选两种情况自然想到 01 做法。

我们定义 $dp_{i,j}$ 其中 $i$ 表示当前胃是否健康，健康为 $0$，不健康为 $1$。$j$ 表示在第 $j$ 道菜时，最大美味和。

我们分情况，分类讨论。

如果是解药。那么 $dp_{0,j}$ 就有三种情况。
- 不选，即 $dp_{0,j}=dp_{0,j-1}$。
- 选，并且胃是健康的，上一个的最大美味和加上当前的美味和，即 $dp_{0,j}=dp_{0,j-1}+y_i$。
- 选，并且胃是不健康的，上一个的最大美味和加上当前的美味和，即 $dp_{0,j}=dp_{1,j-1}+y_i$。

$dp_{1,j}$ 不变，因为是当前解药，选就是上面的最后一种情况，不选，就等于前面的。即 $dp_{1,j}=dp_{1,j-1}$。

最后 $dp_{0,j}$ 就是我们取这三种情况的最大值。

如果是毒药，同理，需要注意的一点，如果胃是不健康的那么不能再选了，因为再选就会死亡。

最后答案就是最后一个胃健康，胃不健康的最大值。即 $\max(dp_{0,n},dp_{1,n})$。
# ACcode
```cpp
#include<bits/stdc++.h>
#define int long long
#define INF 0x3fff
using namespace std;
const int maxn=3e5+5;
int n;
struct node {
	int x,y;
} a[maxn];
int dp[5][maxn];
signed main() {
	ios::sync_with_stdio(false);
	cin.tie(NULL);
	cout.tie(NULL);
	cin>>n;
	for(int i=1; i<=n; i++) cin>>a[i].x>>a[i].y;
	for(int i=1; i<=n; i++) {
      //分类讨论
		if(a[i].x==0) {//解药
			dp[0][i]=max(dp[0][i-1],max(dp[0][i-1]+a[i].y,dp[1][i-1]+a[i].y));//上述三种情况
			dp[1][i]=dp[1][i-1];
		} 
		else {//毒药
			dp[1][i]=max(dp[0][i-1]+a[i].y,dp[1][i-1]);//上述两种情况
			dp[0][i]=dp[0][i-1];
		}
//        cout<<dp[0][i]<<endl<<dp[1][i]<<endl<<endl;
	}
	if(max(dp[1][n],dp[0][n])>=0) cout<<max(dp[1][n],dp[0][n])<<endl;
	else cout<<0<<endl;
	return 0;
}

```