### 题意

给定 $n$ 个长度不超过 $lim=600$ 的括号序列。

对于所有 $i,j$，求出 $s_i+s_j$ 的非空合法子序列数量对 $10^9+7$ 取模的值。

其中 $s+t$ 表示将字符串 $t$ 接到 $s$ 后面形成的字符串。

### 思路

将左括号记为 $1$，右括号记为 $-1$。

序列合法当且仅当所有前缀权值和 $\ge 0$，并且整个序列权值和 $=0$。

而这个子序列会划分为两个区间，前缀给 $i$，后缀给 $j$。

我们考虑拼接一个前缀和后缀。

对于 $i$ 的子序列，提供前缀序列，需要任意一个前缀权值和 $\ge 0$。

对于 $j$ 的子序列，提供后缀序列，我们发现翻转 (reverse) 再反转 (flip) 后跟前缀一样，也就是任意一个后缀和 $\le 0$。

子序列不能重复，于是我们记 $f_{i,j,0/1/2}$ 表示前 $i$ 个数，前缀和为 $j$，强制以左括号，右括号或是空序列结尾的方案数。

容斥是十分简单的，大概就是 $f_{i,j,0} \leftarrow f_{i,j-1,0/1/2}$ 这样的，后缀同理。

接下来就是容斥分界点。

我们考虑什么时候能将后缀的开头移动到前缀末尾。

记 $h_{i,0/1,0/1}$ 表示权值和为 $i$ 的序列尽量往当前序列的前端匹配，当前序列末尾是否有左括号，是否有右括号的方案数。

如果当前有左括号的空余，那么 $j$ 的子序列不能以左括号开头，右括号同理。

统计答案就非常简单了，记得减去空集。

总复杂度 $O(n^2lim+lim^2n)$。

### 代码

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;

const ll mod=1e9+7;

int n,len,x,y;
ll ans,f[605][605][3],g[605][605][3],h[605][605][2][2];
char s[605];

int main()
{
    ios::sync_with_stdio(0);
    cin.tie(0),cout.tie(0);

    cin>>n;

    for(int i=1;i<=n;i++)
    {
        cin>>(s+1);
        len=strlen(s+1);

        for(int j=1;j<=len;j++)
        {
            if(s[j]=='L')
                x++;
            
            if(s[j]=='P')
                y++;
        }

        f[i][0][2]=1;
        h[i][0][x>0][y>0]=1;
        for(int j=1;j<=len;j++)
        {
            if(s[j]=='L')
            {
                x--;
                for(int k=600;k;k--)
                {
                    h[i][k][x>0][y>0]=(h[i][k][x>0][y>0]+f[i][k-1][0]+f[i][k-1][1]+f[i][k-1][2]-f[i][k][0]+mod)%mod;
                    f[i][k][0]=(f[i][k-1][0]+f[i][k-1][1]+f[i][k-1][2])%mod;
                }
            }

            if(s[j]=='P')
            {
                y--;
                for(int k=0;k<600;k++)
                {
                    h[i][k][x>0][y>0]=(h[i][k][x>0][y>0]+f[i][k+1][0]+f[i][k+1][1]+f[i][k+1][2]-f[i][k][1]+mod)%mod;
                    f[i][k][1]=(f[i][k+1][0]+f[i][k+1][1]+f[i][k+1][2])%mod;
                }
            }
        }

        g[i][0][2]=1;
        for(int j=len;j;j--)
        {
            if(s[j]=='L')
            {
                for(int k=0;k<600;k++)
                    g[i][k][0]=(g[i][k+1][0]+g[i][k+1][1]+g[i][k+1][2])%mod;
            }

            if(s[j]=='P')
            {
                for(int k=600;k;k--)
                    g[i][k][1]=(g[i][k-1][0]+g[i][k-1][1]+g[i][k-1][2])%mod;
            }
        }
    }

    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=n;j++)
        {
            ans=mod-1;

            for(int k=0;k<=600;k++)
            {
                ans=(ans+(h[i][k][0][0]+h[i][k][0][1])*g[j][k][0])%mod;
                ans=(ans+(h[i][k][0][0]+h[i][k][1][0])*g[j][k][1])%mod;
                ans=(ans+(h[i][k][0][0]+h[i][k][0][1]+h[i][k][1][0]+h[i][k][1][1])*g[j][k][2])%mod;
            }

            cout<<ans<<' ';
        }

        cout<<'\n';
    }

    return 0;
}
```
