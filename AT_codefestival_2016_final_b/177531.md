## AT2129题解

题目大意：给一个正整数，把它分解成若干个**互不相同**的正整数的和，并输出。

------------

### 思路

令$ S $为从$ 1 $到$ k $的**所有自然数之和**（相当于一个等差数列）。

即：

$$ S=\frac{k\cdot (k+1)}{2} $$

这里有一个结论就是（归纳能力不好请见谅）：

**任何一个数都可以被表示为上述的$ S $减去任意一个在闭区间$ [1,k] $的自然数。**

当然，这里的$ k $是要与$ S $对应的。

下面我就举几个例子来看看：

当$ k=2 $时：

$$ 1+2=3 $$

$$ \ \ \ \ \ \ 2=2 $$

$$ 1\ \ \ \ \ \ =1 $$

同理，当$ k=3 $时：

$$ 1+2+3=6 $$

$$ \ \ \ \ \ \ 2+3=5 $$

$$ 1\ \ \ \ \ \ +3=4 $$

$$ 1+2\ \ \ \ \ \ =3 $$

很显然，这一段“$ 1+2\ \ \ \ \ \ =3 $”已经从$ k=3 $回到了$ k=2 $。

这样一来，我们把$ 1,2,3,4,5,6 $这些值都构造了出来，可以推理得知当$ k $的值增大时，这一理论依然成立。

------------

### 代码实现

首先来确定$ S $的具体值，这个好办，只需要求出比$ n $大的最小的$ S $值就可以了。

例如样例中的$ n=4 $，那么对应的$ S $值就应该是$ 1+2+3=6 $。

那如果$ n=6 $呢？求$ S $的这一过程其实已经把这道题给做完了，直接输出即可。

这个过程的代码如下：

```cpp
int k=1;
while(k*(k+1)/2<=n)  //这个式子表示S的值 
{	
	k++;  //满足条件，继续往大试探 
	if(k*(k+1)/2==n)  //如果S恰好等于n 
	{
		for(re i=1;i<=k;i++)
			std::cout<<i<<endl;
		return 0;  //直接输出1~k 
	}
}
```

------------

好了，由于我们已经推得了上述结论：

**任何一个数都可以被表示为上述的$ S $减去任意一个在闭区间$ [1,k] $的自然数。**

所以我们令一个变量$ s $代表退出循环时的$ k $所对应的$ S $的值。

然后从$ 1 $到$ k $一次枚举，从$ s $中扣除枚举到的数字，如果扣除后恰好等于$ n $，就输出。

这个过程的代码如下：

```cpp
s=k*(k+1)/2;  //计算出s的值 	
for(re i=1;i<=k;i++)  //依次枚举 
	if(s-i==n)  //如果恰好等于n 
	{
		for(re j=1;j<=k;j++)
			if(j!=i)  //被减去的不能输出 
				std::cout<<j<<endl;
		return 0;
	}

```

------------

### 完整代码：

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#define re register int
using namespace std;

int n,s,k=1,ans[1001];

int main()
{
	std::cin>>n;
	
	while(k*(k+1)/2<=n)
	{	
		k++;
		if(k*(k+1)/2==n)
		{
			for(re i=1;i<=k;i++)
				std::cout<<i<<endl;
			return 0;
		}
	}
	
	s=k*(k+1)/2;
	
	for(re i=1;i<=k;i++)
		if(s-i==n)
		{
			for(re j=1;j<=k;j++)
				if(j!=i)
					std::cout<<j<<endl;
			return 0;
		}
}
```

------------

如果有锅，欢迎评论区或私信指正 $QwQ$