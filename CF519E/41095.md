代码以及更好的阅读效果请参见我的[博客](https://www.cnblogs.com/qixingzhi/p/9302038.html)

思路分析：

   题意：询问给出一棵无根树上任意两点a,b，求关于所有点i，\(dist(a,i) = dist(b,i)\)的点的数量。要求每一次询问在O(log n)的时间复杂度内完成。

　　由于在树上求距离，并且还要O(log n)，自然会联想到LCA。由于边权是1，那么点到根的距离就是该点的深度。这个深度可以在dfs预处理的过程中处理完成。那么两个点之间的距离就是两个点到根节点的距离减去两点的LCA到根节点距离的两倍。这个随便yy一下就好了。

　　得到a,b间的距离D以后，分类讨论。（设a的深度>=b的深度）

　　（1）若D为奇数，则一定不存在任何一个点到a,b的距离相等。因此得到0.

　　（2）若D为偶数：

 　　（一）a,b两点分别在LCA的两棵子树上。

　　　①a,b两点深度相同。此时很简单，最近的一个距离相等的点就是a,b的LCA。也很容易想到LCA的祖先也全都符合。但真的只有这些吗？LCA的祖先的其他儿子好像也满足诶……LCA的其他子树（除了a,b）好像也满足诶……因此我们得到结论，在这种情况下得到的答案应当是\(n - size[LCA的左子树] - size[LCA的右子树]\)。

　　　②深度不同。那么我们找到中间节点Mid，Mid里除有a的子树外其他子树都符合，并且Mid以上的节点都不会符合，因此答案是\(size[Mid] - size[有a的那棵子树]\)

　　　（二）a,b在同一条链上，即b就是LCA

　　　这时候和（一）①的情况简直一模一样。（想一想，为什么？）

　　因此我们要做的不过是在dfs的过程中维护好size和dep。但一直困惑我的是由a的那个子树怎么快速得到？答案其实很暴力……再倍增一遍……

代码注意点：

　　太坑了！调试了一个多小时竟然是因为LCA的预处理dfs中(1<<i)打成了i，导致TLE得莫名其妙。还是LCA板子不熟啊……