# 写在前面

本篇题解主要是记录我对卡特兰数及其公式的一些理解，同时通过这道题深入理解它的变式即思考方法。

## 前置知识

- 乘法逆元求组合数
- 容斥
- Catalan 数列

## 题目描述（戳这里[查看原题](https://www.luogu.com.cn/problem/SP19148)）
两个人 A，B 比赛，总共 $n$ 轮。要求任意时刻 A 击杀数都比 B 多，求总共的方案数。有多组数据。

# 正文

## 卡特兰数

一般的相等情况也比较简单，现在为了使情况一般，我们让两个次数不一样。比如[P1641 [SCOI2010] 生成字符串](https://www.luogu.com.cn/problem/P1641)。题目大意不多描述了。现在 0 和 1 的总次数分别为 $m$、$n$，要求组成的数列任意前缀中 1 出现的次数都不少于 0 的次数。

卡特兰数最经典常见的提问方式就是**任意前缀一种东西的出现次数多于另一种数，求方案数**。通常对这种问题我们抽象成以下模型。

![卡特兰数模型](https://cdn.luogu.com.cn/upload/image_hosting/n2qfs3so.png)

简单描述一下，x 轴表示 1 的数量，y 轴表示 0 的数量。我们可以把求原数列总方案数理解成从 $(0,0)$ 走到 $(n,m)$ 点处所有走法方案的总数。

显然，原问题中的约束条件在这里变为：   
对于路径上的点 $\forall (x,y) \ \ (0≤x≤n,\ 0≤y≤m,\ x,y \in Z)$，满足 $x≥y$。

通过观察图片我们发现，只要路径上的点（第一象限）在直线 $y = x$ 下方或其边界上，就一定满足约束条件，但只要 $\exists (x,y)$，$y = x+1$，也就是路径与图中的红线有交点，就一定不满足。

接下来考虑求方案数。仔细想想没啥思路，**正难则反**，考虑**容斥**。我们暂定 合法的总方案数 = 所有方案数 - 不合法方案数。

首先求总方案数。因为路径不掉头，所以总共是 $n+m$ 步。在这些步中**有且仅有** $m$ 步沿 y 轴正方向走，所以总方案数 $P = C_{n+m}^m$（如果考虑 x 轴则 $P = C_{n+m}^n$，两者是等价的）。

接下来我们想一想不合法的方案数怎么求。首先不满足就一定需要路径中至少有一个点在直线 $y = x$ 上方。所以我们找到了下面这个点（这部分重在理解后运用，所以我没有留思考空间）：

![](https://cdn.luogu.com.cn/upload/image_hosting/iop4tns9.png)

这个 $E'$ 如何找到的呢？对于我们构造的不合法数据（图中紫色线），我们将路径第一个不合法点（图中 $P$ 点）后的路径沿不合法线（图中的红线 $y = x+1$）对称。则 $E(n,m)$ 点的对称点为 $E'(m-1,n+1)$（具体求解不说了，中考抛物线必备知识）。

这个 $E'$ 点有什么特殊的呢？首先，从原点到 $E'$ 的路程仍然是 $n+m$；其次，**原点到 $E'$ 的路径，一定会至少经过绿线和红线 1 次**，那么我们再将第一次穿过红线后的所有路径与红线对称，易知翻折后的路径**终点是 $E$ 点**。而此时路径至少经过红线一次，我们成功**构造了不合法的情况**。

则此时不合法的方案数就是原点到 $E'$ 点的总方案数。      
$Q = C_{n+m}^{m-1}$（考虑 y 轴则 $Q = C_{n+m}^{n+1}$，二者同上依然等价）。

因此，最后的答案：     
$H_{n,m} = P - Q = C_{n+m}^m - C_{n+m}^{m-1} = C_{n+m}^n - C_{n+m}^{n+1}$。

## 回归本题

通过构建模型证明了卡特兰数的公式，这道题只是一个变式，区别就在于大于等于变成了大于。

**由于字母冲突，原题中的 $n$ 引用为 $k$，下文中的 $n$ 定义同标题卡特兰数内容的定义。**

按照我们刚才的思路构建模型，则第一步一定是横向的，满足大于，之后其实就是上面的问题了。

![](https://cdn.luogu.com.cn/upload/image_hosting/f970zpxq.png)

注意，$E$ 点坐标满足 $n+m = k$。所以这种情况的总方案数就是 $C_{k-1}^{m} - C_{k-1}^{m-1}$（总路程是 $n+m-1 = k-1$，因为第一步已经确定）。

现在的问题是，$E$ 点似乎不唯一，那么我们上面的公式只跟纵坐标有关，我们考虑一下 $m$ 的范围（横坐标也是可以考虑的）。

考虑 $m$ 的含义，就是得分少的那个人得多少分。所以首先，那个人可以不得分；其次，最大不能比 $n$ 多，所以平分 $k$ 后取较小的一部分，这里通过向下取整巧妙解决，进而得出 **$m \in [0, \lfloor \frac{k-1} 2 \rfloor]$。** 

简单解释一下右端点： 
- $k$ 是奇数，则 $\lfloor \frac{k-1} 2 \rfloor$ 一定比 $\frac k 2$ 小。多出来的小数通过相减使 $n-m = 1$。
- $k$ 是偶数，同理，请自己思考，最终满足 $n-m = 2$。

因此，最终的答案是：   
$\displaystyle \sum_{i = 0}^{k} (C_{k-1}^{i} - C_{k-1}^{i-1})$。

因为相邻项能消，这里手算一下就能明白，最后答案就是 $C_{k-1}^{\lfloor \frac {k-1} 2 \rfloor}$。

之后就是通过逆元之类的求组合数了，这里不多赘述。

# 代码

直接看吧，没什么补充了

```cpp
#include <iostream>
#include <algorithm>
#include <cstring>

using namespace std;
typedef long long ll;
const int maxn = 1000005;
const int mod = 1e9+7;

int inv[maxn]; //乘法逆元
int fact[maxn], infact[maxn]; //阶乘和阶乘乘法逆元
int T, n;

void init(){
    inv[1] = 1;
    for (int i = 2; i < maxn; i ++){
        inv[i] = (ll)(mod - mod / i) * inv[mod % i] % mod;
    }

    fact[0] = infact[0] = 1;
    for (int i = 1; i < maxn; i ++){
        fact[i] = (ll)fact[i-1] * i % mod;
        infact[i] = (ll)inv[i] * infact[i-1] % mod;
    }
}

int C(int a, int b){
    if (a < b) return 0;
    return (ll)fact[a] * infact[b] % mod * infact[a-b] % mod;
}

int main(){
    ios::sync_with_stdio(false);
    cin.tie(0), cout.tie(0);
    init();

    cin >> T;
    while (T --){
        cin >> n;
        cout << C(n - 1, (n - 1) / 2) << endl;
    }

    return 0;
}
```
# 总结

这里理解卡特兰数的方法也不是我独创的，而是我当时不懂翻阅了大量博客和视频后增加了自己的理解，碰巧看到这道题很好而且没啥题解，就过来补上了。

画图工具 GeoGebra。如果表述不清或者错误欢迎指出。   
谢谢观看！

