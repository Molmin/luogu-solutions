## 题目考点判断
- 有依赖的背包问题

## 解决过程
1. 判环
2. 缩点
3. dfs 套 DP

### 1.判环
Floyd 判环,如果 $k$ 到 $i$ 有一条路径且 $i$ 到 $j$ 有一条路径,就代表 $i$ 和 $j$ 是联通的。

```cpp
for(int i=1; i<=n; i++)   //以i为转载点
	 for(int j=1; j<=n; j++)
	  for(int k=1; k<=n; k++)
	   if(mapp[k][i]==1&&mapp[i][j]==1)
	     mapp[k][j]=1;
```
### 2. 缩点

#### 情况1.

 点 $i$ 所在的环之前没有判断过，是**新环**。
 那么，我们将这个新环放到**数组最后**，即新加一个点，
 然后让这两个点的空间标记为**负值** $tmpw$，且 $tmpw+tmpn$（新点的**下标**）**等于原来的点数**，
 这样，我们就可以通过某个点的空间迅速找到他所在的新点。
 像钥匙一样**一一对应**；

```cpp
if(mapp[i][j]==1&&mapp[j][i]==1&&i!=j&&w[j]>0&&w[i]>0)
 {
	jsn++;
	v[jsn]=v[i]+v[j];  //统计空间，价值
	w[jsn]=w[i]+w[j];
	jsw--;
	w[i]=jsw,w[j]=jsw;
 }
```

#### 情况2. 
点 $i$ 所在的环之前已经判断过了，
是**旧环（已合成新点）**，且 $i$ 是环的一部分。
那么我们就把 $i$ 也加到这个新点里面，
即**体积，价值相加**即可；
```cpp
  if(mapp[d[j]][j]==1&&mapp[j][d[j]]==1&&w[j]>0&&w[d[j]]<0)
	{
	  w[n-w[d[j]]]+=w[j]; //将当前点加入它依赖点所在的环
	  v[n-w[d[j]]]+=v[j];
	  w[j]=w[d[j]];
   }
```


#### 情况3. 
点 $j$ 所在的环是旧环，
但是 $i$ 不是环的一部分

`（例如1依赖2，2依赖3,3依赖1。4也依赖1，那么，4所在的是个环，但4不属于环的一部分）`。

那么，把 $j$ 的**父亲转到新点**上 $d[j]= n-w[d[j]]$。
```cpp
if(w[j]>0&&w[d[j]]<0)
 if((mapp[d[j]][j]==0&&mapp[j][d[j]]==1)||(mapp[d[j]][j]==1&&mapp[j][d[j]]==0))
	 d[j]=n-w[d[j]];
```


### 3.树形DP
以上缩点的工作做完之后，
剩下的就是**一棵树**。
就可以在这上面动规了：

先将其转换成一棵**左孩子右兄弟的二叉树**，
之后**记忆化**。

如果 $i$ 的孩子不取 ，则：

$f[b[x]][k]=dfs(b[x],k)$;

如果 $i$ 的孩子取，则：

$f[c[x]][y-i]=dfs(c[x],y-i);$

$f[b[x]][i]=dfs(b[x], i);$

$f[x][k]=\max(f[x][k],v[x]+f[c[x]][y-i]+f[b[x]][i]);$

最后答案是 $f[c[0]][m]$ （从没有依赖的点开始）
