首先，我们思考：什么时候无解？

当所有橙汁品牌数 $\geq k$ 时，我们总能把 $k$ 种品牌不同的橙汁移到 $a_1$ 至 $a_k$ 去，但是当品牌数 $\leq k$ 时，我们无论如何也做不到。

那么，对于一个位置靠左的且之前没有出现过的品牌的橙汁，我们把它移到 $a_{p+1}$（$p$ 为之前出现过的品牌数），这样是次数最小的（因为我们每一次移动肯定是要让这个橙汁离目标更近的，这样才能最优，所以我们不能往右移），次数就是 $i-(p+1)$，拆括号得 $i-p-1$。

时间复杂度 $O(n)$。

```cpp
#include<iostream>
using namespace std;
bool f[500001];
long long p,c,n,k,a;
int main(){
	cin>>n>>k;
	for(int i=1;i<=n;i++){
		cin>>a;
        if(!f[a]){
            c+=i-p-1;
            p++;
            f[a]=1;
        }
		if(p==k){
		    cout<<c;
		    return 0;
		}
	}
	cout<<-1;
}
```
