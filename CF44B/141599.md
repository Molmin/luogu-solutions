这道题的核心思想主要还是暴力,可以稍微分析一下时间复杂度

我们会发现如果我们使用双层 $for$ 循环枚举,是不会超时的

因此我们有了这样的思路:

1.第一种$0.5$升不好枚举,我们枚举第二种和第三种

2.如果 $n$ 减去第二种的数量加上第三种的数量$*2$ 之后剩下的能被第一种凑够,$ans ++ $

我们考虑如何判断剩下的能不能被第一种凑够:

一个数除以 $0.5$ 等于这个数乘 $2$ 因此没必要定义$double$

如果剩下的是负数$($也就是第二种第三种加起来超过了$n$$)$ , 显然是不行的

于是有了下述代码:

```
#include<bits/stdc++.h>
using namespace std;
int n, a, b, c;
int ans;
int main() {
	scanf("%d%d%d%d", &n, &a, &b, &c);
	for(int i = 0;i <= b;i++) {//第二种
		for(int j = 0;j <= c;j++) {//第三种
			int count = i + j * 2;//第二种和第三种加起来
			if((n - count) * 2 <= a && (n-count) * 2 >= 0) {//除以0.5等于乘2
				ans++;
			}
		}
	}
	cout << ans << endl;
}
```
