**题目大意**：一次操作是将这个数的每一位都加一。求将 $n$ 进行 $m$ 次操作后有几位。

这一道题如果暴力枚举，时间复杂度是 $O\left(mt\right)$ ，过不了这一道题。

仔细分析题目可以发现，每一次操作只对当前位数有影响，所以可以一位一位考虑。

可以发现，每一位本来都是一位数，如果变成两位数，那么一定是一个是 $1$，一个是 $0$。

这样，就可以只考虑对 $1$ 和 $0$ 进行操作了。

所以，这有一个递推的性质，可以使用 DP 解决。

用 $d_{i,j}$ 表示当前位置的数是 $i$，经过 $j$ 次操作之后的数的位数。

如果 $i+j<10$，那么操作之后还是一位。

如果 $i+j\ge10$，那么操作之后就变成了两位，一位是 $1$，一位是 $0$，而从 $i$ 到 $10$ 需要 $10-i$ 步，还剩 $i+j-10$ 步。

所以，就有一个 DP 方程：

如果 $i+j<10$ ，那么 $d_{i,j}=1$ 。

如果 $i+j\ge10$ ，那么 $d_{i,j}=d_{0,i+j-10}+d_{1,i+j-10}$。

还有一些细节。

1. 要开 long long。

2. DP 时先枚举 $j$ 再枚举 $i$ 。否则转移时 $d_{0,i+j-10}$ 和 $d_{1,i+j-10}$ 可能没有初始化。

**代码：**
```cpp
#include<cstdio>
#include<iostream>
long long d[10][200001];
//注意开long long
//d[i][j]表示这一位是i，操作j次后的位数
int main()
{
	int i,j,m,n,t;
	long long a;//注意开long long
	for(j=0; j<200001; ++j)
	//从0开始枚举
	//先枚举j防止d[0][i+j-10]和d[1][i+j-10]没有被初始化
	{
		for(i=0; i<10; ++i)
		//从0开始枚举
		{
			if(i+j>9)
				d[i][j]=(d[0][i+j-10]+d[1][i+j-10])%1000000007;
			else
				d[i][j]=1;
		}
	}
	scanf("%d",&t);
	while(t--)
	{
		a=0;
		scanf("%d%d",&n,&m);
		while(n)
		{
			a=(a+d[n%10][m])%1000000007;
			n/=10;
		}
		printf("%lld\n",a);
	}
	return 0;
}
```