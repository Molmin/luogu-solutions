## 壹 题目大意

给出正整数 $a, b\ (1 \leq a, b \leq 10^4)$ 的所有因数的无序排列，还原出 $a,b$ （任意一组）

## 贰 题解

### 一 思路

这道题是一个类似脑经急转弯的题，想出来了就很简单，想不出来就很难 （比如我一开始以为是通过 *若两个数是同一个数的因数，则它们的最小公倍数也应该出现在这个排列中* 从而维护两个并查集，分离出两个数各自的因数，事实证明虽然正确性是可以保证的，但细节却很多，导致我半途就弃疗了）

其实不难发现，最大的因数一定是 $a,b$ 中的一个

证明如下：

- 一个数的最大因数是它本身
- $a,b$ 中有至少有一个最大值
- 所以因数中的最大值就是 $a,b$ 中的一个

发现了这个就不难做出这道题了，因为你已经确定出 $a,b$ 中的一个了，假定我们使 $a$ 为给出的因数中最大的那个，接下来我们只需要去掉给出的因数中所有为 $a$ 的因数的数，余下的必定是 $b$ 的因数，找到这些数中的最大值，就是 $b$ 了。

### 二 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
const int maxn = 128 + 10, maxm = 1e4 + 10;
int a[maxn], n, ans1, ans2, m, cnt[maxm], b[maxn];
void discrete() { // 离散化，便于处理。m记录的是去重后的总个数
	sort(a + 1, a + n + 1);
	for (int i = 1; i <= n; ++i) if (i == 1 || a[i] != a[i - 1]) b[++m] = a[i];
}
int main() {
	scanf("%d" , &n);
	for (int i = 1; i <= n; ++i) {
		scanf("%d", &a[i]);
		ans1 = max(ans1, a[i]); // 更新最大因数，找到 第一个答案
		cnt[a[i]] ++; // cnt[i]记录的是 数 i 在给出的 n 个数中出现的次数
	}
	discrete(); // 离散化
	for (int i = 1; i <= m; ++i) {
		if (cnt[b[i]] && ans1 % b[i] == 0) cnt[b[i]] --; // 如果当前这个数在 cnt数组中的值为正且是第一个答案的因数，那么就去掉这个数，让他出现的次数--
	}
	for (int i = 1; i <= m; ++i) {
		if (cnt[b[i]]) ans2 = max(ans2, b[i]); // 求最大值
	}
	printf("%d %d", ans1, ans2);
	return 0;
}
```