## Upd:
- 22.10.6 修一些锅，并且 CF 的 RMJ 好了，不用交两次了。

[CF1108A Divisors of Two Integers（两个整数的约数） の 题目传送门。](https://www.luogu.com.cn/problem/CF1108B)

## 题目简化
> 给定 $n$ 个数，都为 $x$ 和 $y$ 的约数之一。
>
> 求 $x$ 和 $y$ 的可能解之一。

题目翻译差评！根本没翻译全。

## 思路简析

水黄，非常简单（但我卡了很久（（

易知，$x$ 和 $y$ 中一定有一个为此数列中最大的数，即 $\max\limits_{i = 1}^{n}\{a_i\}$。

证：

> 因为 $x$ 与 $y$ 的因数全部在列，所以这列数中一定有 $x$ 和 $y$。
>
> 若 $x, y$ 全部小于数列中的某一个数 $a$，则 $a$ 必然不是 $x$ 或 $y$ 的因数，与题面不符。

E.D.Q.

不妨设 $x$ 为数列中最大的数，同理可证，$y$ 即为除去 $x$ 的约数之外的数的最大数。

---
## 代码实现

看到题解里很多大佬都写带排序的代码，$O(n\log n)$ 起步，我希望有 $\Theta(n)$ 的算法。

可以使用上上部分所述思路求出 $x$，。

然后挨个枚举，如果是 $x$ 的约数，则数量 $-1$，若还存在或不是 $x$ 的约数，就说明这是 $y$ 的约数，然后取最大值。

当 $y = 0$ 时，也就是所有的数都是 $x$ 的约数时，那 $y$ 随便，只要是 $x$ 约数就行，这里取随意取个 $1$。

而且这样就不用排序了，$\Theta(n)$ 搞定。

然后最优解。

#  _CODE_：
```cpp
#include <bits/stdc++.h>
using namespace std;

int n, x, y;
int a[150], v[10010];
int main () {
	scanf("%d", &n);
	for (int i = 1; i <= n; ++ i) {
		scanf("%d", a+i);
		++ v[a[i]];
		x = max(x, a[i]);
	} for (int i = 1; i <= n; ++ i) {
		v[a[i]] -= !(x%a[i]);
		if (v[a[i]]) y = max(y, a[i]);
	} printf("%d %d\n", x, y?y:1);
	return 0;
}
```
## E.N.D.