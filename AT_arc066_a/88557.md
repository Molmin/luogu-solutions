题意其实可以转化成这样，有一段无序序列，需要你去排序后判断是否满足一定的递增规律——
## 不懂？

我们可以这样想，每个人的位置是不确定的，但他们有一个相对位置，举个例子：

# 1 1    _**1**_    1 1 1 1 1 1 1 1

看到那个歪了的‘1’吗（你一定看到了对吧），由题意我们可以知道此处的Ai=|2-8|=6

那这个呢：

# 1 1 1 1 1 1 1 1  _1_  1 1

此处的Ai=|8-2|=6



因为给出了每个点的Ai，我们可以知道——


# 1 1  _1_  1 1 1 1 1  _1_  1 1

在排列的时候这两个Ai相等的点是可以互换的，总方案时应该为2^（n/2）。如果n为奇数，即有个人在最中间，它的Ai就为0，所以它没有可以互换的位置，n/2刚好把它舍掉了。

我们再看组样例：

		       5

		       2 4 4 0 2
               
答案为4，正好就是2^（n/2）个。但是为什么下一组样例会输出0呢？因为它不一定给的就是正确的Ai，然后需要你去判断。判断很简单，细心点你会发现，越中间的人的Ai就越小，直到最中间，只有可能是0或1，再往外推一点点，你就会发现： 

## 0 2 2 4 4 8 8……


## 1 1 3 3 5 5 7 7……

没错，就是开头所说的递增序列！我们只要给输入的Ai排个序，在一一与正确序列比较就行了

弱弱地献上蒟蒻的代码：
```cpp
#include<stdio.h>
#include<algorithm>
using namespace std;
const int mod=1e9+7;
int num[100005],a[100005];
void init(int x)
{
	if(x%2==0)
		for(int i=1;i<=x;i+=2) 
		{
			a[i]=i;
			a[i+1]=a[i];
		}
	else
		for(int i=2;i<=x;i+=2)
		{
			a[i]=i;
			a[i+1]=a[i];
		}
		
}
int main()
{
	int n,k=1;
	scanf("%d",&n);
	init(n);
	for(int i=1;i<=n;i++)
		scanf("%d",&num[i]);
	sort(num+1,num+1+n);
	for(int i=1;i<=n;i++)
		if(a[i]!=num[i])
		{
			printf("0");
			return 0; 
		}
			
	long long ans=1;
	n/=2;
	while(n--)
		ans=ans*2%mod;
	printf("%lld",ans);
	return 0;
}
```





