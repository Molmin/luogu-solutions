**sol of CF1517F**

其实不是很难的一道题。

很考察基础 dp 状态设定的 trick 与套路的好题。

思考的过程连续性比较长。

参考了 aw 的题解。

------------------------------------------------------

这是该题个人的解题步骤：

- 发现性质，确定性质；

- 状态设定（被卡了/ll）

- 转移方程

期望是水的，本质还是求和。

定义白点是有空的，黑点是没空的。

我们发现这道题相当于就是问树上每个点等概率保留的情况下可能产生的所有连通块直径长和。

一个初步的想法是：在 dp 的时候对于每一个连通块的贡献尝试记在一个节点上以达到去重的目的。最初你可能想的是枚举每个直径的端点。

我们不妨先保留一个初步想法：将 dp 设定成二维 $dp_{x}$ 表示点 $x$ 作为连通块的贡献记录点时的贡献之和。但是你发现这样去重的状态也难以继续添加并设定。

然后重新推性质。先对于全没空和全有空的贡献当成全有空的贡献是 $n - 1$，设 $s(U)$ 表示的是联通块 $U$ 的直径长，我们想要算的就是：$\sum_{r = 1} ^ {n - 1} r\sum[s(U) == r]$。

观察一下，这个好像我们做期望题的时候 $\sum_{x} xP(x)$ 之类的形式啊，我们也尝试做成容斥的形式，即求 $\sum_{r = 1} ^ {n - 1} \sum[s(U) \geq r]$。


这一步不用容斥理解其实也不困难，就是把前面系数 $r$ 的贡献重新分配了一下。


继续做，先枚举 $r$。


我们先只考虑子树，假设 $f_{x,i}$ 表示 $x$ 子树内，半径 $\geq i$ 的方案数。很恶心的定义，我们不妨直接换成，$f_{x,i}$ 表示子树内距离 $x$ 最近的黑色节点距离 $> i$ 时的方案数，两者显然是等价的。

这个东西确实很好转移，但是我们发现这个状态下子树外的信息啥也不知道啊，那难道做个换根吗？显然不是的。

我们定义满足子树内/外限制的贡献记录点为完全合法点，只满足子树内的为子树合法点（即上文中的 $f$）。

我们知道 $f$ 数组算的是子树合法的方案数，我们称这些满足子树限制的点是子树合法的，定义 $g_{x,i}$ 表示 $x$ 子树内距离 $x$ 为 $i$ 的**最远**子树合法，且**仅考虑在 $x$ 子树内是完全合法**的贡献记录点贡献的联通块方案数。

同时最重要的是，$f,g$ 数组**是两个完全独立的状态**，即任意一种连通块方案要么记在 $f$ 数组里面要么记在 $g$ 数组里面。

这是高度压缩的划分状态，请没完全理解的读者仔细理解。

定义 $g$ 数组的目的是将子树 $x$ 内的子树合法点都从下往上转移上来，在这个过程中检查子树合法点是否在子树外合法，这个暂时没看懂没关系，你看完下面的状态转移在上来看看，这是帮助理解的。

我们写出转移方程并逐一解释，以下的转移方程的形式都是将一棵儿子子树 $v$ 合并到 $u$ 上去：

- $f_{u,i},f_{v,j}$ 的合并。这个简单，根据定义我们直接向 $f_{u,\min(i,j+1)}$ 转移即可；

- $g_{u,i},g_{v,j}$ 的合并。根据定义，我们知道我们记的是距离最远的子树合法点，所以向 $g_{u,\max(i,j + 1)}$ 转移即可；

- $f_{u,i},g_{v,j}$ 的合并。这个稍微困难一些，我们发现若 $i + j + 1 > r$ 就得向 $g_{u,j+1}$ 转移，否则就得向 $f_{u,i}$ 转移。前一个好理解，合法就转移，并且由于划分是独立的所以只能向 $g$ 转；对于后一个，我们发现此时出现了不合法的情况，那么这个子树合法点就寄了，由于在 $g_{v,j}$ 内部满足任意的链长 $m$，$m + j > r$，而又由于 $i + j + 1 \leq r$，所以显然 $i < m$，则在向 $f$ 转移时还是应该取距离为 $i$ 的那个距离最近的黑色节点；

- $g_{u,i},f_{v,j}$ 的合并。类似上面的，如果 $i + j + 1 > r$ 就得向 $g_{u,i}$ 转移；否则就得向 $f_{i,j + 1}$ 转移。原理和上面差不多。

看完这里你再返回上面设定 $g$ 数组的目的那里去看一下应该也能理解了。

最后对于每一个 $r$ 的答案是 $\sum_{i=0}^{n-1}g_{1,i}$。

关于不算重其实还好说，因为可能最后对于每个 $r$ 算出来的连通块可能记录了多个子树合法点，但是每次都是在子树之间做方案乘积时候计入的，所以不会算重。

这样的转移总是能让 $f,g$ 封闭独立转移，我们可以理解成 $g$ 其实相较于 $f$ 是应被优先统计的，即若一个连通块满足 $g$ 与 $f$ 两者的限制那么我们优先算在 $g$ 上面，这样所有的连通块方案就被划分为了两种情况：记在 $g$ 上的所有满足 $g$ 的连通块方案以及不满足 $g$ 但满足 $f$ 限制的联通块方案。

时间复杂度 $O(n ^ 3)$。

```cpp
/*
考虑一次贡献是记在 x 连通块直径端点上的。 
不懂。不懂啊。
计数题还是做不来，乐死了。计数题还是做不来，乐死了。计数题还是做不来，乐死了。 
*/
#include "bits/stdc++.h"
using namespace std;
const int Len = 305 , mod = 998244353;
int n,m,head[Len],cnt,f[Len][Len],g[Len][Len],siz[Len],as;
struct node
{
	int next,to;
}edge[Len << 1];
inline void add(int from,int to)
{
	edge[++ cnt].to = to;
	edge[cnt].next = head[from];
	head[from] = cnt;
}
int recf[Len],recg[Len],r;
inline void Mod(int &x){if(x < 0) x += mod;if(x >= mod) x -= mod;}
inline void Add(int &x,int y){x += y;Mod(x);}
inline void Sub(int &x,int y){x -= y;Mod(x);}
void dfs(int x,int fa)
{
	for(int i = 0 ; i <= n ; i ++) f[x][i] = g[x][i] = 0;
	f[x][0] = g[x][0] = 1;siz[x] = 1;
	for(int e = head[x] ; e ; e = edge[e].next)
	{
		int to = edge[e].to;
		if(to == fa) continue;
		dfs(to , x);
		for(int i = 0 ; i <= siz[x] + siz[to] ; i ++) recf[i] = recg[i] = 0;
		for(int i = 0 ; i < siz[x] ; i ++) 
		{
			for(int j = 0 ; j < siz[to] ; j ++)
			{
				//f_{x,i} + f_{to,j}
				Add(recf[min(i , j + 1)] , 1ll * f[x][i] * f[to][j] % mod);
				//g_{x,i} + g_{to,j}
				Add(recg[max(i , j + 1)] , 1ll * g[x][i] * g[to][j] % mod);
				//f_{x,i} + g_{to,j}
				Add((i + j + 1 > r) ? recg[j + 1] : recf[i] , 1ll * f[x][i] * g[to][j] % mod);
				//g_{x,i} + f_{to,j}
				Add((i + j + 1 > r) ? recg[i] : recf[j + 1] , 1ll * g[x][i] * f[to][j] % mod);
			}
		}
		siz[x] += siz[to];
		for(int i = 0 ; i <= siz[x] ; i ++) f[x][i] = recf[i] , g[x][i] = recg[i];
	}
}
inline int qpow(int a,int b)
{
	int res = 1;
	while(b)
	{
		if(b & 1) res = 1ll * res * a % mod;
		a = 1ll * a * a % mod;
		b = b >> 1;
	}
	return res;
}
int main()
{
	scanf("%d",&n);
	for(int i = 1 ; i < n ; i ++)
	{
		int x,y;scanf("%d %d",&x,&y);
		add(x , y) , add(y , x);
	}
	r = 1;
	while(r < n)
	{
		dfs(1 , 0);
		for(int i = 0 ; i < n ; i ++) as += g[1][i] , Mod(as);
		r ++;
	}
	//printf("%d\n",as);
	printf("%lld\n",1ll * as * qpow(qpow(2 , n) , mod - 2) % mod);
	return 0;
}
```