这道题是一道很简单的模拟题，题意也表达得很明确，主要是思路要清晰。
### 主要思路
这道题主要考察我们的贪心策略，让我们求的是 $m$ 天后可以获得的最多积分，经过思考我们可以发现，把所有的步数集中在一天去行走，往往是最佳情况，因为这样可以做到不会被另外一天的需求步数所浪费，只盈不亏。所以我们可以开一个数组把分别每一天的肯以赚的积分存储起来，然后输出最大的。注意，有些激励措施是在同一天的，要把同一天可以获得的积分加起来。模拟以上思路，打起代码就很轻松啦！（详解见代码注释）

上 AC 代码 （c++）
```cpp
#include<bits/stdc++.h>
using namespace std ;
long long n , m , k ; //注意：因为数据非常大，所以每一个数据都得开long long，不然会炸的 
long long a , b , s ;
long long c[99999999] ; //观察数据范围，不想RE就开大点数组 
long long maxn ; //用来记录最大值 
int main()
{
	cin >> n >> m >> k ; //输入相关数据 
	for ( int i = 1 ; i <= k ; i++ ) //分别输入每一个激励措施 
	{
		cin >> a >> b ;
		if ( n - b > 0 ) //判断是否能拿到积分 
		{
			c[a] += ( n - b ) ; //存储这一天可拿积分，同时也处理了激励策略是同一天的情况 
		}
	}
	for ( int i = 1 ; i <= m ; i++ ) //注意是要在有限天数m内查找，不要打成k 
	{
		maxn = max ( maxn , c[i] ) ; //查找m天之中可以拿的最多积分数 
	}
	cout << maxn ; //输出 
	return 0 ; //好习惯 
}
```
希望能帮到大家！
