根据乘法对加法的分配律，我们最终值的贡献拆成所有加法的贡献之和。每个加法的贡献形如 $a_i$ 乘以在它后面的所有乘法的积，即 $a_i \prod\limits_{i < j \land s_j = \texttt *} a_j$。这个拆贡献的思想非常重要，是本题的核心。

因为加法总和与乘法之积的和不超过 $2\times 10 ^ 9$，所以答案不超过 $x (2\times 10 ^ 9 - x)$ 的最大值，即 $10 ^ {18}$。

进一步地，为了让每个加法的贡献最大，如果选择移动加法运算，一定会把它放在最前面；如果移动乘法运算，一定会把它放在最后面。

将所有乘 $1$ 删去，这样乘法数量不超过 $\log_2 V \approx 31$。直接枚举选中哪些乘法无法接受，但是如果两个乘法数值相等，我们一定会优先将位置较前的乘法移动到最后面，调整法容易证明。根据上述结论，可能更新答案的情况数为 $\prod (cnt_i + 1)$。因此，假设有 $31$ 个乘 $2$，那么可能更新答案的情况数不是 $2 ^ {31}$，而是 $32$。

感性理解这个值的最大值在所有情况下的最大值是很小的，即在 $\prod x_i ^ {c_i} \leq 2 \times 10 ^ 9$ 的限制下 $\prod (c_i + 1)$ 的最大值不会很大，比约数个数数量级多一点。设最大值为 $F$，爆搜可知 $F = 4608$。

在已经确定选择哪些乘法移动的前提下，我们会尽可能多地移动加法，这样一定不劣。设还可以进行 $rem$ 次加法。去掉选择的所有乘法，设它们的乘积为 $move$。

首先求出不移动任何加法的当前值 $sum$。

考虑每个加法移动到最前面的贡献，形如 $a_i \times (pre_i - 1) \times suf_i$，其中 $pre_i$ 表示 $i$ 前面没有被选择的乘法之积，$suf_i$ 表示 $i$ 后面没有被选择的乘法之积。我们只需求出贡献前 $rem$ 大的权值之和。二分找到最小的 $k$ 使得贡献 $\geq k$ 的加法数量 $plus \leq rem$，同时求出对应贡献之和 $cont$，则可以用 $(sum + cont + (rem - plus) (k - 1)) \times prod$ 更新答案。当 $k$ 不存在（即 $rem$ 过大）时，可以令 $k = 1$，刚好消去 $rem - plus$ 的不正确的贡献。

对于原序列，如果两个加法 $a_i$ 和 $a_j$ 之间没有乘法，那么任意情况下 $(pre_i - 1) \times suf_i = (pre_j - 1) \times suf_j$。所有乘法将序列分成不超过 $\log V$ 段加法，每段对于当前二分值 $k$ 都会选择最大的若干个数。将每段按 $a$ 从大到小排序后做前缀和，容易二分得到使得乘上当前 $(pre - 1) suf$ 后不小于 $k$ 的加法数量，以及这样的数的贡献之和。

时间复杂度 $\mathcal{O}(F\log ^ 2 V\log n + n\log n)$。[代码](https://codeforces.com/contest/1753/submission/177704858)。