为了方便，令 $V=2\times 10^9$ 表示值域。

要求结果最大，那么第一反应就是加法直接移到最前面，乘法直接移到最后面。

考虑按加法算贡献，那么每个加法的贡献就是它的值 $\times$ 后面所有乘法的值的积。

容易发现乘法其实非常少，我们将 `* 1` 的操作先去掉，那么乘法操作只有 $m\le\log V$ 个。

我们可以考虑一个暴力的做法，暴力枚举每个乘法是否移，然后再放到加法里贪心地选。但是这样外面就有个 $O(2^m)$ 的复杂度，不满足我们的要求。

考虑按照乘的数值去分类。对于同一类里，假设我们枚举这一类移动的个数，那么一定是优先将靠前的乘法操作，因为它能增大更多加法的贡献。

考虑这样爆搜的复杂度，设这个复杂度为 $O(d)$。因为 $2\times 3\times 4\times 5\times 6\times 7\times 8\times 9\times 10\times 11\times 12\times 13>2\times 10^9$，所以 $d$ 大概是 $2^{12}$ 级别的。

问题转化为对于所有加法操作，计算它们移到前面后新增的贡献，并求出前 $k$ 大的和。

然后我们可以暴力扫一遍加法，直接贪心即可，复杂度为跑不满的 $O(dn)$ 或 $O(dn\log n)$。似乎有人是用这个方法过的。

我们发现我们按照这 $m$ 个乘法操作将加法操作分成了 $m+1$ 段。这个段的性质在于无论你的乘法选了哪些，原本在一段内的数他们后面要乘的数的积永远都是一致的。

那么我们将每一段内部自己从大到小排个序，每一段显然是优先选较大的。

这样就在复杂度中去除了 $n$。我们考虑每一段直接暴力维护一个 $suf$ 表示这一段里的数后面要乘的数的积。然后可以做到很简单地查询一个加法的新增贡献。

怎么求前 $k$ 大？我们可以直接二分第 $k$ 大的新增贡献是多少，并放进去看看有多少个数的新增贡献比这个二分的值大并统计这些贡献的和，那么需要每一段再维护一个排序后的前缀和。

需要注意的是有多个第 $k$ 大的情况，然后只能选取其中的几个。

复杂度是 $O(n\log n+dm^2+dm\log n\log V)$。可以非常轻松地跑过去。

https://codeforces.com/contest/1753/submission/189725356