首先这个题是若干个树。特征很明显：1.路径无环 2.$m<n$ 3.已经联通的点不再处理。

然后，题目里基本挑明了要维护树的直径。先摆上树的直径的树形DP版本（感觉没什么人写这种因而放上代码）。这样主函数中就比较简洁。

```cpp
//本质就是维护最长和次长延申出去的距离。
void dfs(int place,int fa)
{
    d1[place] = d2[place] = 0;//d1表示这个节点延申出去的最长路径，d2表示这个节点延申出去次长的路径。
    for (int i = headers[place]; i;i=que[i].next)
        if(que[i].to!=fa)
        {
            dfs(que[i].to, place);
            int now = d1[que[i].to] + 1;//注意+1：因为从子节点到该节点还有1的路径长
            //注意：一个儿子只能更新一个值，不能两个同时变成全新的值，保证不会一个儿子延申出去的被计算两次导致错误
            if (now > d1[place])//now比最长的还长
            {
                d2[place] = d1[place];//移动位置，更新次长
                d1[place] = now;//更新最长
            }
            else
                if (now > d2[place])//比次长长
                    d2[place] = now;//更新次长
        }
    diameter = max(diameter, d1[place] + d2[place]);//diameter指树的直径。显然，树的直径可以由它的不同儿子延申出去的长度的和来更新。这种路径才是必然经过place节点
}
```

上述操作要对每个树进行。

然后看下面的操作。1是查询，这没话说，直接打印就好，统计下每棵树的直径然后存起来。麻烦的是2，合并操作。但是这里只有合并没有拆分操作。**并查集的用处就是维护不断合并的一些节点的可加和信息**，因此这里应该使用并查集。

有了并查集，我们判断这个点走过没走过都变得方便起来：只需要在计算树的直径的时候多加一句：

```cpp
	father[place] = fa;
```
就行。初始化的时候连那个循环都省了。没访问的节点的father为0，而走过的节点father的祖先必为根节点。

这是处理后的并查集初始化部分：

```cpp
    for (int i = 1; i <= n; i++)
        if(!father[i])//还没访问过
            dfs(i, i);//注意：此时的第二个参数不可赋为-1，因为这是并查集的初始化
```

然后就是合并操作。我们如何求两个树合并后的最小树的直径呢？

这里其实是一个贪心，结论就是**尽量取直径上的中点**。凡贪心，必证明。因而在下面进行证明：

在树上操作的时候我们通常可以画这样的一个图来进行分析：

[![sjD1A0.png](https://s3.ax1x.com/2021/01/26/sjD1A0.png)](https://imgchr.com/i/sjD1A0)

记1-4为树的直径，不妨令$dis[1][3]<dis[3][4]$。同时，1，2，4只是叶子节点，3为这两个边的交汇点。1-3，3-4，2-3中还有大量的节点未画出。那么由定义，$dis[2][3]<dis[1][3]<dis[3][4]$。

我们在合并的时候只用考察这一边的情况，另一边的情况和这边是一样的。我们需要贪心的，是让这个点到树上其他点的最大距离最小。

考虑待链接的点$x$的位置，有三种情况：在1-3上，在3-4上，在2-3上。

如果在2-3上，那么最长距离必会大于$dis[3][4]$——考虑4的贡献。

如果在1-3上，那么最长距离也会大于$dis[3][4]$——考虑4的贡献。

如果在3-4上，最长距离**可能不会大于**$dis[3][4]$——因为本身在这条边上，那么到4的距离就不会大于$dis[3][4]$。考虑1和2，由于到2的距离等于$dis[2][3]+dis[3][x]$，小于到1的距离$dis[1][3]+dis[3][x]$，因而只考虑1对答案的贡献。

显然我们只需要最小化$\max{dis[1][x],dis[x][4]}$了。那么显然，在中点的时候上述值最小（这应该是显然了），因而**每次尽量取直径上的中点**。

那么，新的直径在这颗树上的长度就应该是$\frac{diameter[1]+1}{2}$了——直径长度为偶数的时候对半取，长度为奇数的时候取一半更长的那一部分。

因此合并的时候的新直径长为$\frac{diameter[1]+1}{2}+\frac{diameter[2]+1}{2}+1$——别忘了连接的长度1。

但是！有可能一棵树很大，另一棵树很小，以至于新长度还小于大树的老长度，因而最后的合并方程（2向1合并）为：

$$diameter[1]=\max \{ \max \{diameter[1],diameter[2]\},\frac{diameter[1]+1}{2}+\frac{diameter[2]+1}{2}+1 \} $$

合并函数如下：

```cpp
void merge(int x,int y)
{
    diameter[getfather(y)] = max(max(diameter[getfather(y)], diameter[getfather(x)]), 1 + (diameter[getfather(y)] + 1) / 2 + (diameter[getfather(x)] + 1) / 2);//合并方程解释如上
    father[getfather(x)] = getfather(y);//一定注意次序！更新的信息一定要在归并前进行！
    return;
}
```
剩下的部分代码较为基础，请读者自行完成。