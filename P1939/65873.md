//本蒟蒻的第一篇题解，希望可以审核过吧qwq欢迎各位大佬来找错（有些是个人理解，可能有误）

首先说一下我这个蒟蒻对于矩阵加速的理解吧，我觉得这个加速是借助了矩阵乘法利用了快速幂，加快了状态之间的转移，有点像“倍增”吧，对于寻找某个目标状态有很大的加速作用。我觉得实现矩阵加速比较重要的一方面就是快速幂，快速幂是利用二进制实现的，不会的同学可以看一下代码，声明：快速幂在矩阵加速中很重要！建议先掌握快速幂。(参考例题P1226)：
~~~cpp
long long quick(long long a,long long b)
{
	long long base=a,ans=1; 
	while(b!=0)  
	{
		if((ans*base)%k!=0) 
		if(b&1!=0) ans=(ans*base)%k;     
		base=base*base%k;      
		b>>=1;
	}
	return ans;
}

~~~
很明显的是，这道题的关键之处绝对是找出状态转移用的矩阵，看题我们可以知道，**a[i]=a[i-1]+a[i-3]**;要求得 _**a[i]**_ 的话，我们需要 _**a[i-1**]_ 以及 _**a[i-3]**_ 这两个状态。那我们不妨设置一个3×1的矩阵记录a[i-1],a[i-2],a[1-3]这三个状态，
![](https://cdn.luogu.com.cn/upload/pic/37980.png)

然后我们在由这三个状态向目标状态推。
好的，现在重点来了，我们要考虑如何将这三个状态推为 _**a[i],a[i-1],a[i-2]**_  ;
由于矩阵乘法的性质（矩阵乘法的话，这里就不多说了，可以去百度一下），我们需要一个3×3矩阵，由这个3×3的矩阵与我们上面那个3×1的初始矩阵进行相乘。由此来找到我们的状态转移矩阵（就是这个3×3的矩阵，后面也会这样称呼，hah）。
这是我们的目的

将：

![](https://cdn.luogu.com.cn/upload/pic/37980.png)

转为：

![](https://cdn.luogu.com.cn/upload/pic/37981.png)

很明显：
a[i]=a[i-1]×1+(a[i-2]×0)+a[i-3]×1

那我们的3×3矩阵第一行就是1 0 1了

a[i-1]=a[i-]]×1+(a[i-2]×0+a[i-3]×0)

a[i-2]=(a[i-1]×0)+a[i-2]×1+(a[i-3]×0)

所以3×3矩阵的第二、三行就是1 0 0和 0 1 0了；
（第二、三种状态的转移说明在矩阵加速找转移状态的矩阵时，不一定一定要由它前面的某几种状态转移来，也有可能由它后面的状态直接转过来，我刚开始做矩阵加速时没往这种情况上想，就很浪费时间了。QAQ）

由此矩阵开始，我们可以知道，当前状态转到下一状态只需要进行初始矩阵与我们1×3的那个初始矩阵（暂且这样称呼，知道是哪个就好了qwq）进行n-3次矩阵乘法，为什么是n-3次呐？因为我们的“初始矩阵”开始有三个状态（即a[i-1],a[i-2],a[i-3]），每次矩阵乘法之后，“状态矩阵”的第一个元素就是a[i]了，那我们要寻找的a[n]就只需要n-3次矩阵乘法咯。

好的，我们初始矩阵找到了，那我们就要借助矩阵乘法了，由a[1],a[2],a[3]向后转移知道a[n]就好了，需要注意的一点是，因为快速幂的时候，有时需要我们处理状态转移矩阵，而我们的状态转移矩阵与我们的初始矩阵大小不一，所以我设置了一个结构体（为什么要用结构体，这样的话便于在各个函数之间转移），其中除了矩阵变量以外，再加了一个border的变量来处理边界问题，边界一个是1，另一个边界是3（由矩阵的大小决定的ya）。有一道类似的矩阵加速题叫做斐波那契额公约数，有兴趣的同学可以去试一下，那是一个2×2的状态转移矩阵。

AC代码：

~~~cpp
#include <cstdio> 
#include <iostream>  
using namespace std;
#define INF 1000000007
long long n,q[105];
struct mat{
	long long s[3][3],border;   
};
mat mem(mat a,mat b)//矩阵乘法
{
	mat q;
	for(int i=0;i<3;i++)
	  for(int j=0;j<3;j++)
	    q.s[i][j]=0;
	for(int i=0;i<3;i++)
	  for(int j=0;j<a.border;j++)
	    for(int k=0;k<3;k++)
	      q.s[i][j]=((q.s[i][j]%INF)+(a.s[k][j]%INF)*(b.s[i][k]%INF))%INF;
	q.border=a.border;//处理边界
	return q;
}
void ksm(long long x)//快速幂
{
	mat xx,ans;ans.border=1;xx.border=3;
	ans.s[0][0]=ans.s[1][0]=ans.s[2][0]=1;
	for(int i=0;i<3;i++)
	  for(int j=0;j<3;j++) xx.s[i][j]=0;
	xx.s[0][0]=xx.s[0][2]=xx.s[1][0]=xx.s[2][1]=1;
	while(x)
	{
		if(x&1) ans=mem(ans,xx);
		xx=mem(xx,xx);
		x>>=1;
	}
	cout<<ans.s[0][0]%INF<<endl;//n-3次矩阵乘法之后这个就是a[n]了！
}
int main()
{
	cin>>n;   
	for(int i=1;i<=n;i++)  
	cin>>q[i];   
	for(int i=1;i<=n;i++)
    {   
		if(q[i]<=3) {cout<<1<<endl;continue;}  
    ksm(q[i]-3);  
	} 
	return 0;
}
~~~