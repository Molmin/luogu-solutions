


### 标签： 树状数组 结论
---

#### 前言

一个极具思维难度的题目，做线段树正好碰见了，就用树状数组把他艰难地A掉了（雾

#### 思路

**结论一**：对于冒泡排序，可以知道，有实际意义的最多是循环 $n-1$ 次 。

**结论二**：对于每一遍冒泡排序，手模几组样例可以发现，对于某一个位置的**某一个数的逆序对**，只要它当前的逆序对个数不为 $0$，那么一遍冒泡排序以后，它贡献的逆序对数量必定减一。

几个例子： $4 \ 3 \ 1 \ 2 $，$1$ 贡献的逆序对为 $2$ ,经过一遍冒泡排序成为 $3\ 1\ 2\ 4$, $1$ 贡献的逆序对为 $1$。

**结论三**：对于交换两个位置的数,分为两种情况：

$$a[x]>a[x+1]$$

这种情况下交换以后，原先 $a[x]$ 代表的数贡献的逆序对的数量不变，原先 $a[x+1]$ 代表的数贡献的逆序对的数量 $-1$。

$$a[x]<a[x+1]$$

这种情况下交换以后，原先 $a[x]$ 的数贡献的逆序对的数量 $+1$，原先 $a[x+1]$ 代表的数贡献的逆序对的数量不变。

**结论四**：如果一个数贡献的逆序对的数量为 $k$ 的话，那么他只会对前 $i$ 次冒泡排序有贡献。

#### 做法

**第一阶段**为预处理初始序列的值，用权值树状数组求出每个位置的数贡献的逆序对的数量。并且记录每一个贡献的个数，（比如贡献为 $3$ 的有 $2$ 个，就把他们存桶里）。

**第二阶段**为初始化树状数组：可以把树状数组的每个位置 $i$ 定义为第$i-1$ 次操作的修改值，为了方便处理，$1$ 位置暂且放上初始的逆序对值。

**第三阶段**来上传每次冒泡排序的修改值，可以用这么一个思维来处理他:把我们刚才存的桶拿过来用一下，循环枚举 $0…n-1$ 的值，并用一个变量 $cnt$ 记录前 $i$ 个的总和，有什么用呢？模拟一下就知道了。

假设枚举到了 $i=0$ 此时 加上这个值之后，$cnt=3$，假设 $n=5$,那么可推出第一轮的需要修改的值为 $-(n-cnt)$，因为 $0$ 的一定不会有贡献了，一次类推即可。

**第四阶段**是最重要的修改操作了，根据上面的结论，可以不考虑位置了，只用考虑逆序对的个数来修改。

当一个数贡献的逆序对个数 $+1$ 之后，如果本来贡献的逆序对个数为 $0$ ,那么现在可以给 $i=2$ 也就是第一轮贡献一个 $-1$ 修改值了。

当一个数贡献的逆序对个数 $-1$ 之后，如果本来贡献的逆序对个数为 $3$ 那么就要对 $i=4$ 的贡献就没有了，就 $+1$ 。

**第五阶段**查询，输出 $sum(x+1)$

#### 代码实现

```cpp
/*
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<queue>
#include<stack>
#include<vector>
#include<map>
#define int long long 
using namespace std;
const int N=2e5+9;
int t[N];
int a[N];
int n,m; 
int biger[N];//记录一下每个位置逆序对的个数的个数，桶存每个个数的数量
//K个一定会在第k次冒泡中全部消去 
int ans;//初始序列逆序对的个数 
int imp[N];//每个位置逆序对的个数 
int read()
{
	int f=1,x=0;
	char s=getchar();
	while(s<'0'||s>'9'){if(s=='-')f=-1;s=getchar();} 
	while(s>='0'&&s<='9'){x=(x<<1)+(x<<3)+(s^'0');s=getchar();}
	return f*x;
} 
int lowbit(int x)
{
	return x&(-x);
}
void add(int x,int val)
{
	while(x<=n)
	{
		t[x]+=val;
		x+=lowbit(x);
	}
}
int query(int x)
{
	int ret=0;
	while(x)
	{
		ret+=t[x];
		x-=lowbit(x);
	}
	return ret;
}
signed main()
{
	n=read();
	m=read();
	//考虑到记录逆序对的问题，序号从0开始 
	for(int i=0;i<n;i++)
	{
		a[i]=read();
		imp[i]=i-query(a[i]);//查找逆序对个数
		ans+=imp[i];//记录逆序对总个数 
		biger[imp[i]]++;//桶存这个数量
		add(a[i],1);//上传	 
	} 
	memset(t,0,sizeof(t));//一次不清空，OI一场空
	//从现在开始t数组，定义改变，为 query(x) 为x次冒泡排序后的逆序对个数
	add(1,ans);//1 为 没有操作，为了方便，用 0 不行，所以都把操作数+1
	int cnt=0;
	for(int i=0;i<n;i++)//预处理实现差分
	{
		cnt+=biger[i];
		add(i+2,-(n-cnt));//用于计算第k轮会有多少个减少
		/*
		
		cnt 所记录的是逆序对数<=i的，则大于i的就是在第i轮中减去的数量
		就比如，知道了逆序对为0的数量num，则在第一轮中减去的个数一定是 （n-num）;
		其他的同理可得 
		
		*/	
	}  
	while(m--)
	{
		int opt=read();
		int x=min(read(),n-1);//最多会有n-1轮排序
		if(opt==1)
		{
			x--;
			if(a[x]<a[x+1])//解析看上面
			{
				swap(a[x],a[x+1]);
				swap(imp[x],imp[x+1]);
				add(1,1);//这种情况会多一个逆序对
				add(imp[x+1]+2,-1);
				/*
				
				假设imp[x+1]=0，通过转换，多了个1。
				那么就会在第一轮发挥作用，下标从0开始的，所以 
				会在+2轮发挥作用，多减去个1 
				
				*/	
				imp[x+1]++;
			}	
			else 
			{
				swap(a[x],a[x+1]);
				swap(imp[x],imp[x+1]);
				add(1,-1);
				imp[x]--;
				add(imp[x]+2,1);
				/*
				
				假设本来imp[x]=1，那么 会在第一轮（i=2）的时候会被-1
				而现在 imp[x]=0,了，那么 就要在 (i=0+2) 轮的时候+1 减去这个效应 
				
				*/
			}
		} 
		else printf("%lld\n",query(x+1)); 
	} 
	return 0;
}
```