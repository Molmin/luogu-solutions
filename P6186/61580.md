（这个题我觉得非常锻炼思维能力~~当然我当时考试冥思苦想1个多小时想不出来~~）

（本篇题解可能说有抄袭之嫌，但我想说，这些话都是我自己很通俗的理解（因为自己的OI能力还太弱），希望给予大家更多的帮助，仅此而已）

[冒泡序列](https://www.luogu.com.cn/problem/P6186)

题目的难点：在O（logn）（~~不然绝对T飞~~）的时间内求出第k次冒泡排序后数组的逆序对，并且还有相邻交换数值的操作要处理。

乍一看要在O（logn）内处理操作，瞬间脑子里蹦出了线段树树状数组的这些数据结构，然后由于之前写过了树状数组求逆序对（可参考这篇博客[树状数组的小整理](https://www.luogu.com.cn/blog/wqqakioi/shu-zhuang-shuo-zu-bit-di-xiao-zheng-li)），于是就想到了用树状数组来写这道题。

但是，我们要注意，写题不应该是**拿数据结构去套题目所给的操作，先去想了优化再踌躇满志地去想题目该怎么写**。我们应该做的（仅作者一家之言），是先去想**如何处理题目给出的问题，想一个解决办法，再联想到对这个解决办法有帮助的工具，即数据结构**。我想这种想法，应该适用于我们所有的题目中，不仅仅只是数据结构的题目。

所以，自己以后得改正这种想法，并多多练习啦！

好我们来看这道题。为了方便，我们先不做任何交换的修改操作，光是这个O（logn）时间复杂度内求k次冒泡排序后的逆序对就够我们喝一壶了。

### 一.思路初探

一个一个去换肯定是不行的，不过我们可以想到，**我们可能要存一下k次冒泡排序对每个数的影响**，这样才能不受k数值的限制，才不会一直苦想怎么在这k次变换的方式里做文章。

那么，既然是要存起来每个数的影响，我们就可以先去求出原数组的逆序对数量，然后再处理影响，输出答案。**这就是一个大致的思路，也就是说，我们相当于要先算出原数组的逆序对（假设有tot个），再去标记，每一轮冒泡排序给每个数造成的影响，算上影响后再输出答案**。

### 二.处理每个数的影响

怎么去处理k次冒泡排序对每个数的影响呢？
先来举个例子玩玩，，，

1 4 5 2 3 （这是原数组）

向下经过1轮排序——

1 4 2 3 5 （分析一下，2,3 动了，总逆序对失去了2个（5,2和5,3），并且2和3都是**前面有2个数比它大**的数。

向下，第2轮——

1 2 3 4 5 （还是2,3在动，他们是**前面有2个数比它大**的数）

诶，好像有点规律，似乎跟**该数字前面（也就是左边）有多少个数比它大有关**？

再来看：

5 1 2 4 3

第1轮后——

1 2 4 3 5 （**前面有1个数比它大的1,2，4 和前面有2个数的3动了，，，**）

第2轮——

1 2 3 4 5 （**在原数组里看，前面有2个数比它大的3动了**）

诶好像真的与这个有关系耶！
我们尝试着想到一般上去。

对于一个数，如果说**它前面有多少个数比它大，那么它将会在这个数值的那一轮里最后记一次影响，然后停下来**。为什么会这样呢？不妨讨论一下，，，

case 1，假设这个数左边相邻的数比它大，那么这个相邻的数必然会记到原数的影响里；

case 2 左边相邻的数比它小，仔细一想发现不影响啊！比原数大的数必然可以换到这里来，除非出现一个数挡住它（那个比原数大的数），那这个数不也比原数大，记到影响里了嘛！

所以，到这里似乎有了点感觉，似乎明白该怎么去处理这个影响了。我们的做法是：

1.用before[i]表示**位置i的数a[i]的前面，有多少个数比它大**。显然，总逆序对数的每一个i的before[i]的和。那么对于每一次冒泡排序，before[i]的变化是，

### before[i] = max(before[i]-1,0)

这里一定要想明白这个方程式为啥哦！

2.用record[i]表示，**有i个数在前面比它大的数 的数量**。这里想清楚哦！

3.记record[i]是干啥的？就是为了计算**当前这一轮会有多少个数处于影响范围内，丢失一个逆序对**。我们利用前缀和的形式（即注意点1的操作，好好体会一下）能够记下，**前面有小于等于i个数比它大的数的数量**，记做tot，那么**前面有大于i个数比它大的数的数量，即在本轮会丢失1个逆序对的数的数量**，就是（n-tot）啦！

此时再联想到，我们可以利用树状数组进行一个O（logn）的差分操作，把第一位的值赋上初始的总逆序对数，从第二位开始（第二位表示进行第一轮冒泡排序）O（logn）的时间复杂度内，存下每轮的总影响。
嗯，就这些！没事的，这里可能要多想想咯。

### 三.执行交换操作，我该怎么搞

因为只是交换相邻两项，所以我们想，**除这两项以外的其他项的逆序对数和其他信息不会有变化**。
那么我们来看，

1.a[x] < a[x+1]。

首先交换x和x+1的a值和before值。

然后注意，x+1的位置上多了一个比它大的数。所以before[x+1]++;

总逆序对数+1，即add（1，1）；

**我们还得考虑第k轮冒泡排序的影响。before[x]不会受到影响，所以到第before[x+1]轮时冒泡排序，我们得把这个1再减回来，即add(before[x+1] + 1,-1)，注意一下树状数组内的坐标哦**！

2.a[x] > a[x+1]。同上反过来咯，注意细节！

这里可能要详细解释一下注意点2。

在a[x] < a[x+1]的时候，我们要明白，before[x] 必然 >= before[x+1],那么在交换位置时，因为多了一个比它大的数，beforex[x+1]（原来的a[x]的信息）++,那么原来的a[x]的before[x] > before[x+1]（原来a[x+1]的信息），即现在的before[x] < before[x+1]，但这个操作并没有影响到**原来a[x+1]的信息，所以要处理的是原来的a[x]的信息的影响,即处理现在的before[x+1]。**  比如1,2,3，若交换2,3，换过来以后变成1,3,2，那么2的影响值便在**当前的**before[2]轮上，所以有先before[x+1]++,再add(before[x+1]+1,-1）；

同样，在a[x] > a[x+1]的时候，我们和上面同理意会一下，是不是**原来a[x]的信息（现在交换后的a[x+1],before[x+1]）是不是没有动**呀。那么这个交换，同样，就对**冒泡排序对这个数的影响**没有任何作用在上面。**有影响的就变成原来的a[x+1]（现在的a[x],before[x]）了**。至于具体影响在哪一轮，这个说老实话确实非常非常不好想，我们可以结合下面的例子去理解就行，

比如6,5,4,3,2,1，交换3,2，变成6,5,4,2,3,1，那么在原来的第before[2] （原来before[2] = 4）轮上，原来因（3,2）在树状数组里给到的一个逆序对的影响**在新的数组里没有了，不在算总逆序对时再算上一遍，这个，在现在的数组里不存在的一个逆序对**。 所以，在这里，先add(before[x]+1,1),再before[x]--；

如果小结一下上面这段话是想提醒什么，那就是：

### 交换操作，是需要去在最初始时的数组里的影响里修改。

好啦，本题大功告成，还得多加训练！

附上代码：

```
#include<bits/stdc++.h>
using namespace std;
typedef long long LL;
const int MAXN = 2e5 + 7;
inline LL read(){
	LL f=1,r=0;char c=getchar();
	while(!isdigit(c)){if(c=='-') f=-1;c=getchar();}
	while(isdigit(c)){r=r*10+c-'0';c=getchar();}
	return f*r;
}
LL a[MAXN];
LL t[MAXN];
LL n,m;
inline LL lowbit(LL x){return x & (-x);}
void add(LL x,LL v){
	for(;x <= n;x += lowbit(x)) t[x] += v;
}
LL ask(LL x){
	LL res = 0;
	for(;x > 0;x -= lowbit(x)) res += t[x];
	return res;
}
LL x,op;
LL tot,record[MAXN],before[MAXN];
int main(){
	n = read();m = read();
	for(LL i = 1;i <= n; i++) a[i] = read();
	for(LL i = 1;i <= n; i++)
	{
		before[i] = i-1-ask(a[i]);
		tot += before[i];
		record[before[i]]++;
		add(a[i],1);
	}
	memset(t,0,sizeof(t));
	add(1,tot);
	tot = 0;
	for(LL i = 1;i <= n; i++)
	{
		tot += record[i-1];//注意点1
		add(i+1,-(n-tot));
	}
	for(LL i = 1;i <= m; i++)
	{
		op = read();x = read();
		x = min(x,n-1);
		if(op == 2){cout<<ask(x+1)<<endl;}
		else if(op == 1)
		{
			if(a[x] < a[x+1])
			{
				swap(a[x],a[x+1]);
				swap(before[x],before[x+1]);
				
				before[x+1]++;
				add(before[x+1]+1,-1);
				add(1,1);
			}
			else{
				swap(a[x],a[x+1]);
				swap(before[x],before[x+1]);
				//注意点2
				add(before[x]+1,1);//注意一下这里和上面的顺序，多想想！
				before[x]--;
				add(1,-1);
			}
		}
	}
	return 0;
}

```



 _这次没什么名言了，_
 
 _不过在这个特殊的时期里，还是想，_
 
  _向此时此刻仍然奋战在抗疫一线的医护人员致敬。_ 