2log 和 1log 的点分、链分做法相信大家都会了。这里讲一下线性做法。

其实就是这位老哥的[做法](https://codeforces.com/contest/1575/submission/134392242) ，他现在还是速度榜第一。

考虑 $f,g_{u,0/1,d}$ 表示 $u$ 子树，最上面的连续段颜色，有几个连续段，的方案数以及和。

这玩意跟深度有关，所以可以直接长剖。

时间空间复杂度 $\mathcal O(n)$。

这里只讲我的实现方法。（部分参考了上面那位老哥实现）。

对每个节点开四个 `std::deque<std::pair<int,int> >` 来存 $f,g_{u,0/1}$ 和对应的前缀和。 

继承长儿子的时候就是要把两种颜色 dp 值合并，把 size 大的那个 swap 过来，

另一个暴力，因为每个颜色被干完后又会清零，所以复杂度对的。

选 size 大的原因是不用扩大空间，保证复杂度的正确性。

然后剩下的轻儿子怎么暴力怎么来就好了。

有一些小细节：

别真去用 `std::deque` 了，那玩意初始化空间常数毛估估有 100 倍（反正我是这样）

解决方法两个： 

1. 用传统方法手写内存池先根据算出的信息开好 dp 数组内存（参考磁暴）
2. 手写 deque（大致就是动态分配一些循环队列，然后满了就重构，开大 $\alpha$ 倍）

另外，请注意各种 $\mathcal O(1)$ 的小细节，

但是不影响正确性和整体复杂度而减少代码复杂度的 $\mathcal O(1)$ 小细节不用在意了，

~~否则可能真的调不出来了~~

[我的实现](https://codeforces.com/contest/1575/submission/140139766)