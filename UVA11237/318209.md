### 题意分析

“他们想要糖果能够平分”，即孩子数量能整除选择去的邻居给的糖果数量总和。于是问题能够转化为，已知 $n$ 个正整数，从其中选出若干个数，使得选出的数的总和是 $c$ 的倍数，求一种方案。

### 思路

#### 1.简化版题目
因为要求和，所以可以考虑用前缀和。但是，答案有可能是选择不连续的数，这种方法**可能**会得到错误的答案。既然这样，我们还是先考虑选择连续的情况。问题就被转化成了，已知 $n$ 个正整数，从中选出**连续的一段**（即一个区间），使得选出的数字之和是 $c$ 的倍数。

所以，如果对于正整数 $i$ 和 $j(1\leq j\leq i\leq n)$，满足 $s_i-s_j$ 是 $c$ 的倍数，那么区间 $(j,i]$ 中的元素之和就是 $c$ 的倍数，此时就找出了一种方案可以输出。

然而，如果朴素地枚举 $i$ 和 $j$，时间复杂度将高达 $O(n^2)$，对于 $n\leq1e5$ 的数据，显然会超时。可以用一个桶标记每个前缀和 $s_i\bmod c$ 的结果是否出现过，如果当前前缀和 $\bmod c$ 的结果之前出现过，说明 $s_i \equiv s_j \pmod{c}$，即 $(s_i-s_j) \bmod c=s_i \bmod c -s_j \bmod c=0$，也就是说，存在 $j(1\leq j\leq i)$ 使得 $s_i-s_j$ 是 $c$ 的倍数，从而有解。为了找到这个 $j$，我们可以把 $i$ 记录下来，再在遍历完后再次从 $1$ 开始遍历一次，遇到的第一个 $s_j=s_i$ 的 $j$ 就是区间左端点，记录的 $i$ 就是右端点(左开右闭)。
代码如下：
```cpp
for (int i = 1; i <= n; ++i) {
	s[i] = (s[i - 1] + a[i]) % m;//计算前缀和并取模
	if (b[s[i]]) {
		t = i; break;//如果出现过，标记并退出
	}
	b[s[i]] = 1;//标记出现过
}
for (int i = 1; i <= n; ++i) {
	if (s[i] == s[t] && i != t) {//如果两个前缀和取模结果相同
		ans = i + 1; break;//记录区间左端点
	}
}
```
#### 2.所有情况

我们刚刚研究了取连续一段区间数的情况，接下来，就要考虑更多的情况。然而，非连续的取数的确难以研究，那就考虑证明**1.** 的可行性。

注意到 PDF 版中的数据范围给出了一个东西：
![](https://cdn.luogu.com.cn/upload/image_hosting/lp3gci2x.png)

$$\color{red}\boxed{c\leq n}$$

~~所以说给翻译的人没认真读题，连数据范围都不给！(bushi)~~

看到这个东西，似乎和某原理的限制范围有点像...

没错，就是鸽巢原理(抽屉原理)！

> 将 $n+1$ 个物体，划分为 $n$ 组，那么有至少一组有两个（或以上）的物体。这个定理看起来比较显然，证明方法考虑反证法：假如每个分组有至多 $1$ 个物体，那么最多有 $n$ 个物体，而实际上有 $n$ 个物体，矛盾。

我们可以对其进行推广，即：
> 将 $n$ 个数字，以对 $c(c<n)$ 取模的结果划分为 $c$ 组($0$ ~ $c-1$)，那么有至少一组有两个（或以上）的数字。证明：假如每个分组有至多 $1$ 个数字，那么最多有 $c$ 个数字，而实际上有 $n$ 个数字$(n>c)$，矛盾。

相当于是把 $n$ 个前缀和当做上文的 $n$ 个数字，把它们以对 $c$ 取模的结果分组，因此可以得到，至少有 $2$ 个前缀和对 $c$ 取模相同，即一定有解。

完结~

唉不对，题目给的是 $\color{red}{c\leq n}$，刚才的情况只满足于 $\color{red}{c<n}$，那 $c=n$ 时有可能没有解(即输出 `no sweets` ，再次批评翻译)？

好吧，其实对于 $c=n$ 的情况下，最坏是没有相同的前缀和(取模后)，即前缀和(取模后) $0$ ~ $c-1$ 都有。但是既然有了取模后为 $0$ 的前缀和，那从 $1$ 到这一位不就是一种解嘛？

所以本题**没有**输出 `no sweets` 的情况。

完结撒花~