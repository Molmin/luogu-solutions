看了看题解都是用的数学归纳法，本蒟蒻决定写一篇SG函数题解以佐证归纳出来的规律。

什么是$SG$函数？

定义：对于一个给定的有向无环图，定义关于图的每个顶点的$Sprague-Grundy$函数$g$如下：$g(x)=mex$ {$g(y)$}。其中$y$为$x$的后继。

是不是一脸懵？没事，通俗的说：将x这个状态可以转移到的其他状态$(y)$的$g(y)$看为一个集合，$g(x)$的值就是在集合中没有出现的最小非负整数。

还是没懂？举个例子：

我现在有0颗石子，因为$g(0)$是转移不到任何其他点的，所以$g(0)=0$。

我现在有1颗石子，$g(1)$可以从0转移过来，所以集合里为{0}，所以$g(1)=1$。

我现在有2颗石子，$g(2)$可以从0,1转移过来，所以集合里为{0,1}，所以$g(2)=2$。

我现在有3颗石子，$g(3)$可以从0,1,2转移过来，所以集合里为{0,1,2}，所以$g(3)=3$。

我现在有4颗石子，$g(4)$可以从1,2,3转移过来，所以集合里为{1,2,3}，所以$g(4)=0$。

我们现在再引入一个定理：当$g(i)=0$时，先手必败。

怎么证明的？~~我也不知道~~，就连NOI金牌选手zhx大佬也不知道，我们只需要记住就好了。

那么很显然，所有可以由4转移过去的数的$SG$函数必定不为0。

所以问题就是找到所有$g(i)=0$的状态。也就是无法被0和4转移到的状态，显然，所有质数必定可以转移到0，所以所有质数是必胜状态。无法被0和4转移到的状态又哪些呢？没错，就是$4x(x\in Z)$，4的倍数，扩展下去，必胜的状态就是0和$4x(x\in Z)$们可以转移到的数（也就是它们与质数的和）。

我们可以明显发现，所有自然数都可以被此表示出来。所以没有其它的必败状态了。

即证。

那么代码就是：

```cpp
#include<cstdio>
using namespace std;
int main()
{
    int n;
    scanf("%d",&n);
    for(int i=1;i<=n;i++) 
    {
        int x;
        scanf("%d",&x);
        if(x%4==0) printf("Roy wins!\n");
        else printf("October wins!\n");
    }
}
```
