这题貌似只需要最简单的语法知识，完全是一道 ~~乱搞的~~ 构造题。

但是需要 ~~强大的~~ 数学能力。

言归正传：

#### 1.

首先想一个最简单的思路：dfs。

就是在每次询问时把两个数用 dfs 填到每个符号里去，再判断 $\verb!YES!$ 或 $\verb!NO!$。

但很明显，$O(2^nT)$，这是过不去的。

#### 2.

首先可以分析给定的 $n$ 个符号。

又根据加减法的交换律和结合律得知，符号的顺序可以任意调换，那么就可以直接**统计加号与减号的个数**。

那么就可以把 dfs 变成简单的遍历，

分别求出 $a,b$ 分别与加减配对的个数，遍历其中两个，另外两个就可以求得。

很明显，$O(n^2T)$，还是过不去。

#### 3.

再看一眼数据范围，得知只有 $O(T)$ 才能过。

简单来说，就是不能用遍历，要把每次询问压成 $O(1)$。

现在就需要数学才能了。

------------

(下面为了讲述方便，把加号个数记为 $n$，减号个数记为 $m$）

最简单的就是可以把 $a$ 全填一个符号，$b$ 同理，使正负能互相抵销，直接:

```if(n==m){cout<<"YES";continue;}```

那么假如 $a,b$ 有正有负呢？

$-a,+a$ 会抵消，同理，$-b,+b$ 也会。

来看看抵消过程。

不难发现：抵销去的加号个数等于减号个数。

那么最后就一定会有 $±ax±by$（$x$，$y$ 为常数）。

换而言之，就是指 $n-x=m-y$。

因为 $1<=a,b<=10^9$，所以排除 $ax$ 与 $by$ 同号的情况，具体证明如下：

- 因为 $a,b>0$ 且 $x,y>0$
- 所以 $ax+by>0$ 且 $-ax-by<0$
- 所以排除同号情况

那么接下来的问题就是如何求 $x,y$ 了。

显而易见的，有 $±ax±by=0$。

后面为了简化问题，可以使一个大小关系固定，那么就只需要考虑一种情况了。

可以考虑 $ax-by=0$。

即 $ax=by$。

因为 $x,y$ 必须符合 $ax=by$,

所以如果存在合法的 $x,y$，那么它们一定是由 $ax=by$ 中最小的 $x,y$ 乘倍得来的。

把“最小的 $x,y$”翻译一下，就是 $a,b$ 的最小公倍数。

遍历一遍所有可能的乘倍是可行的，但是时间应该不够。

可以再优化一下，直接把 $x,y$ 作差，把 $n,m$ 作差，比较两者所差的倍数，就可以知道要乘多少倍了。

最后是输出：

1. 如果加号个数等于减号个数，全为 $\verb!YES!$。 （直接全部填一个数抵销掉）
2. 如果 $a=b$，那么在1不成立时，全为 $\verb!NO!$。 （相当于只有一个数，肯定不行）
3. 如果 $(n-m)/(x-y)$ 不为整数，即乘倍不为整数时，输出 $\verb!NO!$。 （不是整数倍，如果还想抵消的话，$x,y$ 就会变成小数）
4. 如果最后需要的 $x,y$ 比 $n,m$ 多，输出 $\verb!NO!$。

------------

### code

感觉前面讲的不是很清楚，多加了一些注释。

还有就是讲解的变量名和代码里的不太一样，代码是以前写的，懒得改了，多看看注释。

```cpp
#include<cmath>
#include<iostream>
#include<algorithm>
using namespace std;
#define int long long

int u,d;

signed main(){
    int n,T;
    cin>>n;
    for(int i=1;i<=n;i++){
        char ch;
        cin>>ch;
        if(ch=='+') u++; //统计个数
        else d++;
    }
    cin>>T;
    int cha=abs(u-d);//作差
    if(u<d) swap(u,d);//固定大小关系，简化问题
    if(cha==0){
    	while(T--) cout<<"YES\n";//加号个数等于减号个数，全部抵消
    	exit(0); //相当于 return 0;
    }
    while(T--){
        int a,b;
        cin>>a>>b;
        int gcd=__gcd(a,b);//求最小公倍数中的一个过程。
        //最小公倍数其实是 a*b/gcd，但那只是为了求x,y所经历的过程，不用写
        a/=gcd,b/=gcd; //把a,b当做x,y，下同
        int ct=abs(a-b);//作差
        if(ct==0||cha/ct!=cha*1.0/ct){ //a=b或者不是整数倍
            cout<<"NO\n";
            continue;
        }
        if(a<b) swap(a,b);//固定大小关系
        //为什么到这里才固定呢？因为前面没有用到x,y，即使用到也加了绝对值，所以其实前面固定也是可以的
        if(cha/ct*a<=u&&cha/ct*b<=d) cout<<"YES\n"; //x,y < n,m，同时a,u都是大的，b,d都是小的，一一对应
        else cout<<"NO\n";
    }
    return 0;
}
```