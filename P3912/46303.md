本来题解已经过审核了，再小小优化了一下，撤回重新发一遍（笑哭）。
有的人开不了一亿的素组建议可以用register，最后附加了register的用法

## 线性筛素数

#### 什么是线性筛

对于求多个质数时与其一个个判断不如用排除法，用空间换取大量时间。

原理：筛去一定范围内的所有合数。

#### 基本实现

合数可以分解成质数相乘，所以用质数相乘筛一遍，枚举质数并且一路用i乘过去，标记一轮。

#### 快速线性筛

简单来说，上面的算法会导致一个数筛多次而减慢效率，如6=2*3，明显2和3都会筛去6。于是换思路>>

原理：对于任意合数，必定可以有最小质因子乘以最大因子的分解方式。因此，对于每个合数，只要用最大因子筛一遍，枚举时只要枚举最小质因子即可。

求最大因子的方法：对于最大因子i，最小质因子p，如果i > p且i % p ≠ 0即为最大因子。

用反证法证明：若i%p=0， 则i=p*k，那么当pi为p的下一个质数时，有pi*i=p*pi*k，此时有pi*k>i,也就是筛去的不是用i，而是pi*k，若用i则会重复筛选。

#### EG如下：

14%7=0 14=7*2 14*11=154=7*11*2=77>14
```cpp
#include<iostream>
using namespace std;
bool hsb[100000000];//0为质数，1为合数
int ssb[100000000];//质数表，小了会RE 
int main()
{
     int n,j,cut=0,i;
    cin>>n;
    ssb[1]=2;//初始化，第一个质数为2
    hsb[1]=1;//初始化虽然1不是质数也不是素数 
    for(i=2;i<=n;i++)
	{    
        if(hsb[i]==0)
		{
		    cut++;
            ssb[cut]=i;//如果是质数，添加到质数表
        }
        for(j=1;j<=cut&&i*ssb[j]<=n;j++)//前提限制为p<i,i*p<n
		{
            hsb[i*ssb[j]]=1;
            if(i%ssb[j]==0)//该最大因子i已枚举完毕
                break;
        }
    }
    cout<<cut;
return 0;
}
```
## 附加：

如果是RE
可以在int前面加register也可以加快速度只能放在函数里面（包括主函数）
register：修饰符暗示编译程序相应的变量将被频繁地使用，如果可能的话，应将其保存在CPU的寄存器中，以加快其存储速度
ps：但是使用register修饰符有几点限制

[详细内容](http://blog.csdn.net/21aspnet/article/details/257511)