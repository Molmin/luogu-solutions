### 1.题目大意
有一个长度为 $n$ 的数组 $a$，对于序列 $a$ 中的 $a_i$，每次可以加或减去 $1$，有 $q$ 次询问，求需要进行多次操作，使得序列 $a$ 中的每一个数均为 $x$。
### 2.思路分析
对于每一次把序列 $a$ 变成 $x$ 的操作，显然使用绝对值进行模拟是不对的，但是，不难发现，对于每一次变为 $x$ 的操作，其实可以分为 三种情况：

1.$a_i=x$，此时不用管，不用进行操作。

2.$a_i<x$，只需要把 $a_i$ 多次加 $1$，直至 $a_i=x$。

3.$a_i>x$，只需要把 $a_i$ 多次减 $1$，直至 $a_i=x$。

对与这三种情况，显然会考虑前缀和 $sum$，可得 $ans=\left|sum_n-\left(n\times x \right)\right|$，显然，在本题中，样例不会通过，因为在上文的三种情况中，第二和第三种情况会互相冲突，因为一个是加，而另一个是减。

举个例子，设序列 $a$ 为 ```1 2 4 5 7```，$x$ 为 $5$，则用上文公式可得 $ans=6$，但答案为 $10$，显然考虑每次对序列 $a$ 进行枚举，显然是用二分查找，枚举出中间的分界点 $l$，使得 $a_l<x,a_{l+1}\ge x$，此时即可通过。
### Code
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int maxn=2e5+10;
int n,q;
int a[maxn];
int sum[maxn];
signed main(){
	cin >> n >> q;
	for(int i=1;i<=n;++i){
		cin >> a[i];
	}
	sort(a+1,a+n+1);
	for(int i=1;i<=n;++i){
		sum[i]=sum[i-1]+a[i];
	}
	while(q--){
		int x;
		cin >> x;
		int p=lower_bound(a+1,a+n+1,x)-a;
//		cout << p << " " << (p-1)*x-sum[p-1] << "  " << (sum[n]-sum[p-1])-(n-p+1)*x << endl;
		cout << (p-1)*x-sum[p-1]+(sum[n]-sum[p-1])-(n-p+1)*x << endl;
	}
	return 0;
}
/*
5 3
6 11 2 5 5
5
20
0

10 5
1000000000 314159265 271828182 141421356 161803398 0 777777777 255255255 536870912 998244353
555555555
321654987
1000000000
789456123
0

*/
```
