## 思路解析

很简单，我们只要让被染色的字母越多越好（红色越多，绿色也越多）。

假设我们拿到了一个字母，它在这个单词里面出现了 $n$ 次，我们分两类讨论

 
1.	$n\ge1$ 

显然当 $n\ge2$ 时，有两个字母将被进行染色，一红一绿（越多越好策略），而剩下的 $n-2$ 个字母，由于规定了同色的任两个字母不相同，所以只能不被染色。

2.	$n=1$

而当 $n=1$ 时，它得拉一个跟他一样只出现一个的字母，一个染绿，一个染红，才能达到红色与绿色的个数相同。

## code:
```cpp
#include<bits/stdc++.h>
using namespace std;
char ch[10001];
int a[30],i;
void work()
{
	memset(a,0,sizeof(a));//清零计数数组 
	int l=strlen(ch);
	for(i=0;i<l;i++) a[ch[i]-'a'+1]++;//将每一个字母出现的次数累加 
	int f1=0,f2=0;//f1代表单个出现的字母，f2代表出现大于等于两次的字母 
	for(i=1;i<=26;i++)
	{
		if(a[i]>=2) f2++;
		else if(a[i]==1) f1++;
	}
	int sum=0;
	sum=f2+f1/2;//f2可以直接加入，一红一绿，单个出现则要找搭档，才能保证红色个数等于绿色个数 
	cout<<sum<<"\n";
}
int main()
{
	int T;
	cin>>T;
	while(T)
	{
		cin>>ch;
		work();
		T--;
	}
} 
```
