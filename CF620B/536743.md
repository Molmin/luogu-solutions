观察数据范围，$1\leq l\leq r\leq10^6$，所以毫不犹豫开始**模拟**。

## 思路

显然，一个数一个数来求“贡献”是不现实的，所以我们可以进行递推。

如何递推呢？

我们可以发现，一个数字的贡献可以表示为每个数位的贡献之和。设 $f(x)$ 表示 $x$ 的贡献，则有：

$$f(x)=f\left(\left\lfloor\dfrac{x}{10}\right\rfloor\right)+f\left(x\bmod10\right)$$

也就是 $x$ 的贡献就是 $x$ 的最后一位的贡献加前面的贡献，而 $x$ 前面的贡献有相当于 $x$ 的前面的最后一位的贡献加 $x$ 的前面的前面的贡献……

所以这时候就可以递推了，初始条件为 $f_0,f_1,\dots f_9$ 的贡献，一直递推到 $f_{100000}$。

**初始条件：**

|$f_0$|$f_1$|$f_2$|$f_3$|$f_4$|$f_5$|$f_6$|$f_7$|$f_8$|$f_9$|
|-|-|-|-|-|-|-|-|-|-|
|$6$|$2$|$5$|$5$|$4$|$5$|$6$|$3$|$7$|$6$|

## 完整代码
```cpp
#include<iostream>
#include<cstdio>
using namespace std;
long long f[2000005],ans;
int l,r;
int main() {
	f[0]=6;
	f[1]=2;
	f[2]=5;
	f[3]=5;
	f[4]=4;
	f[5]=5;
	f[6]=6;
	f[7]=3;
	f[8]=7;
	f[9]=6;    //初始条件
	for(int i=10;i<=1000000;i++) f[i]=f[i/10]+f[i%10];    //递推式
	scanf("%d%d",&l,&r);
	for(int i=l;i<=r;i++) ans+=f[i];    //直接累加就可以
	printf("%lld\n",ans);
	return 0;
}
```
