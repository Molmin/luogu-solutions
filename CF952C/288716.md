## 题意

**由于题面暂时没有很好的翻译，所以这里明确一下翻译**

**单纯翻译的话，题面如下**：

```

按相应数字在输入数组中出现的顺序将数字堆排成一行（数字越大数字堆越高）。
找到最高的一个（如果有几堆最高的，用最左边的一个）。
将其移动到输出数组的末尾。
重复此过程，直到所有数字堆都已排序。

一开始你对你的算法很满意，但是当你在更多的输入上尝试时，
你意识到它并不总是产生正确的排序数组。
结果发现，当两堆相邻的数字堆高度相差两个或两个以上时，
高一堆的顶部就会滑到低一堆的顶部。

给定一个输入数组，找出所描述的算法是否能正确排序
```

首先，第一段很明显就是选择排序，可以忽略不看；

可是第三段中的 ```是否能正确排序``` 是什么意思呢？选择排序难道无法正确排序？显然不是的。

然后我们来看第二段：

>结果发现，当两堆相邻的数字堆高度相差两个或两个以上时，高一堆的顶部就会滑到低一堆的顶部。

这时我们应该就明了了——如果有相邻两堆高度差大于 $1$ 时，数字堆会被打破，就无法排序成功了。

**分析了那么多，重新总结一下题意**：

```
如果给定的数列里，有相邻数字的差大于1，
输出‘NO’，否则输出‘YES’。
```

## 实现

**这道题难就难在分析题意，题意明了了，实现自然就不难了。**

我们只需要将数组从头到尾扫一遍，对于每一个 $i$，只要$|a_i-a_{i-1}|>1$ 的情况出现，则输出 NO，否则输出 YES。

具体实现看代码：

```
#include <bits/stdc++.h>
using namespace std;
int a[100001],n;
int main()
{
  cin>>n;
  for(int i=1; i<=n; i++)
    cin>>a[i];
  //读入
  for(int i=2; i<=n; i++)
  {
    if(abs(a[i]-a[i-1])>1)
    //abs函数即取绝对值
    {
      cout<<"NO\n";
      return 0;//输出NO后可直接结束程序
    }
  }
  //若没有程序没有结束，
  //那么就说明任意相邻两数差不大于2，可直接输出YES
  cout<<"YES\n";
  return 0;
}

```

## Tipes：

- 第二个循环从2开始。（原因：由于是$a_i$与$a_{i-1}$比，所以要从 $2$ 开始）。

- abs函数当然也可以自己写，这里为了方便，就直接调用了。

- 两个循环其实可以合并起来，因为数据不大，为了好理解，我便分开写了。

# 祝大家AC愉快！