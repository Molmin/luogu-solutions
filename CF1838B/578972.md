### 题意

给定一个长度为 $n$ 的排列，任选两个元素（可以相同）并交换，使得其所有子段中排列（长度不一定为 $n$）的个数最少。

### 思路

首先，我们发现至少有两个排列，分别包含 $[1]$ 和 $[1, 2, ..., n]$，那么我们需要想办法构造一种方法，使得所有子段里面包含的排列只有这两种。

首先，如果一个排列不是 $[1]$，那么它肯定含有 $2$，而如果一个排列不形如 $[1, 2, ..., n]$，那么它肯定不含有 $n$。那么我们只需要让任何一个长度不为 $1$ 或 $n$ 的子段要么不包含 $2$，要么 $2$ 和 $n$ 都包含即可。

要做到这一点，我们只需要保证 $n$ 处于 $1$ 和 $2$ 之间。所以我们只需要找到 $1, 2, n$ 这三个数，并判断是否符合要求，若符合要求，直接随便进行一个原地的操作，如果不符合要求，调换两个元素使之符合要求即可。

### 伪代码参考

```cpp
int n = read();
int pos1, pos2, posn;
for (int i = 1; i <= n; i++)
{
  int t = read();
  if (t == 1) pos1 = i;
  if (t == 2) pos2 = i;
  if (t == n) posn = i;
}

if (pos1 > pos2) swap(pos1, pos2); // 交换一下方便操作

if (posn > pos2) cout << pos2 << ' ' << posn; // 形如 2 1 n, 1 2 n
else if (posn < pos1) cout << posn << ' ' << pos1; // 形如 n 1 2, n 2 1
else cout << "1 1";
```