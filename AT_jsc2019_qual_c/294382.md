## 题目大意

有 $2\times n$ 个格子排成一排，每个格子非黑即白。定义一次操作为选择 $1\le l<r\le n$，将 $[l,r]$ 之间的格子全部反色（黑变白，白变黑）。求每个格子恰好均被选择一次作为端点且最终格子全为白色的操作方案数。

## 思路

显然每个格子均恰好被选择一次作为端点意味着一共只有 $n$ 次操作。若一个格子最初是黑色，那么它必须被进行奇数次反色，否则需要偶数次。

首先不难发现，操作之间的顺序不会影响最终格子的颜色。因为对于固定的操作 $[l_1,r_1],[l_2,r_2],\ldots,[l_n,r_n]$，每个格子被包含于对应操作区间的个数是一定的，即 $\forall i$，满足 $i\in [l_x,r_x]$ 的 $x$ 的个数是一定的，所以每个格子被反色的次数也是一定的，这也就意味着最终结果是一定的。

其次，若确定了每个格子作为左端点或右端点，最终的结果也是一定的。因为操作 $[l_i,r_i],[l_j,r_j]$ 和 $[l_i,r_j],[l_j,r_i]$ 的效果是一样的（假设 $l_i<l_j<r_i<r_j$，画图可得，两种方案的效果均为将 $[l_i,l_j)\cap(r_i,r_j]$ 反色）。所以现在的问题就是确定每个格子是作为左端点还是右端点。

对于格子 $i$，假设其左边有 $l$ 个格子作为左端点，$r$ 个格子被作为右端点（$l+r = i-1$）。那么，若格子 $i$ 为左端点，就有 $(l-r+1)$ 个操作区间“穿过”了格子 $i$，否则有 $(l-r)$ 个。注意到它们的奇偶性不同，所以两种只有一种可取，也就是说，此时 $i$ 作为左端点还是右端点被唯一确定了。又因为第 $1$ 个格子一定是左端点，所以我们用这种类似归纳法的方法确定了每个格子会作为左端点还是右端点。

对于左起第 $i$ 个作为右端点的格子，假设其左边作为左端点的格子数量为 $p_i$。那么，对于左起第 $1$ 个作为右端点的格子，其有 $p_1$ 种左端点的选法；第 $2$ 个作为右端点的格子就有 $(p_2 - 1)$ 种，如此下去。所以一共有 $\prod\limits_{i=1}^n(p_i - i + 1)$ 种左右端点配对的方法。又因为这 $n$ 个操作有 $n!$ 种排列顺序，所以一共的方案数就是 $n!\times\prod\limits_{i=1}^n(p_i - i + 1)$。

```cpp
#include<iostream>
#include<cstdio>
#define maxn 100005
#define ll long long
#define mod 1000000007
using namespace std;
int n,a[maxn*2],numl,numr,totl; char x; ll ans=1LL;
// numl 表示左起还有多少个左端点未被配对，即上文中的穿过 i 的区间数量 (l-r)
// numr 表示左起有几个格子作为右端点
// totl 表示一共有几个格子作为左端点
int main(){
      scanf("%d\n",&n); for(int i=1;i<=n*2;i++){scanf("%1c",&x); a[i]=(x=='B'); if(i<=n) ans=ans*i%mod;}
      numl=totl=1; for(int i=2;i<n*2;i++){
            if(a[i]!=numl%2){numl++; totl++;} // a[i] 应为左端点
            else{numl--; numr++; ans=(ans*(totl-numr+1)%mod)%mod;} // a[i] 应为右端点
      } numr++; ans=(ans*(totl-numr+1)%mod)%mod;
      if(totl!=n||!a[1]||!a[2*n]) printf("0"); else printf("%lld",ans);
      // 若 a[1] 或 a[2*n] 是白色或左右端点数量不等则不可能全为白
      return 0;
}
```