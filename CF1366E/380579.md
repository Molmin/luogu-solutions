首先观察到 $b_i$ 单调递增，即，我们能不能用 $\mathcal{O}(n)$ 左右的时间解决这个问题，而不是选择 DP。

考虑到其实对于每个 $b_i$，它“控制”的范围是有限的。设 $\min\limits_{i\to n}\{a_i\}=suf_i$，$suf_i$ 被称作 $b_j$ 可选的数的最大范围。

假设我们现在有一个序列 $a=\{80,80,10,40,40,40,20,25,30\},b=\{10,20,30\}$。

不难得到 $suf=\{10,10,10,20,20,20,20,25,30\}$。

我们首先看 $b_1=10$ 对答案的贡献，很显然 $a_1\sim a_3$ 必须都分到第一组，这是因为 $a_3$ 必须分到第一组，$a_3$ 假如分到第二组则第二组最小值必定小于 $b_2$。

接下来可以看到 $a_4\sim a_6$ 分到第一组还是第二组都无所谓，但是这里必须切一刀，也就是说我有四种切法可以将这三个 $40$ 分到第一组或第二组。（注：假设最多有 $k$ 个 $suf_i=b_j$，则我至少要留下一个 $suf_i$ 给 $b_j$ 这一组，于是上一组与这一组可以被切开的方案数就是 $k-1+1=k$）

因为 $a_7=20$，所以 $a_7$ 必须分到第二组，此时可以发现 $a_8=25$ 必须分到第二组来，所以第二组的贡献是 $1$。

最后我们就得到答案为 $4$。

接下来对于结论 $ans=\prod\limits_{i=2}^m\operatorname{cnt}(b_i)$ 的推导，对于每一组的方案数，其最多可以扩张到下一组的最后一个最小值的前一位，不理解可以看刚刚的例子，这么多数的切割方案就是 $\operatorname{cnt}(b_{i+1})$。我们再举个例子：

$$
10,10,10,10,12,12,15,15,15,15,15
$$

对于上面的 $suf$ 序列，如果 $b=\{10,15\}$ 的话，首先可以得到那两个 $12$ 必须被分到前一组 $b_1=10$，因为他们被分到 $b_2=15$ 会拉低最小值。剩下的五个 $15$ 中，至少要留一个 $15$ 给第二组，故剩下四个 $15$ 可以切 $5$ 刀，即 $b_1$ 与 $b_2$ 共同能带来 $5$ 种方案。

所以就是说，相邻的两组答案为后一组 $suf_i=b_j$ 的 $suf_i$ 个数。

提醒：

1. 一定要开 `long long`
2. 第一组 $b_1$ 判的时候要看 $suf_1=b_1$，如果不符合马上答案为 $0$，你可以理解为，若小于，则我就是取再多数给第一组，最小值也不会是 $b_1$，若大于，则我无论取多少数都取不到 $b_1$。

查找 $suf_i=b_j$ 个数时，由于 $suf_i$ 的值域很广，可以用 `map` 做桶，总时间复杂度 $\mathcal{O}(n\log n)$。

代码如下：

```cpp
//CF1366-E
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=2e5+5;
const int mod=998244353;
int a[N],b[N],n,m,suf[N],ans=1;
map<int,int> f;
signed main(){
    scanf("%lld %lld",&n,&m);
    for(register int i=1;i<=n;i++) scanf("%lld",&a[i]),suf[i]=2e9;
    suf[n+1]=2e9;
    for(register int i=n;i>=1;i--){
        suf[i]=min(a[i],suf[i+1]);//后缀最小
        f[suf[i]]++;
    }
    scanf("%lld",&b[1]);
    if(suf[1]!=b[1]){
        printf("0");
        return 0;
    }
    for(register int i=2;i<=m;i++){//乘法原理
        scanf("%lld",&b[i]);
        ans=(ans%mod*f[b[i]]%mod)%mod;
    }
    printf("%lld",ans);
}
```