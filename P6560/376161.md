经典有向图博弈。

假设先手现在在点 $x$，那么有如下几种情况：

- $x$ 为终点：这种情况虽然不会出现，但是考虑到前一步是先手必胜，故我们认为此时先手必败。
- $x$ 无出边：不能进行有效移动，先手必败。
- 出边中有一个点使得先手必败：由于我们认为先后手都是博弈带师，那么只要有一种走法能让另一个人必败，我们就一定会这样走使得自己必胜，故先手必胜。
- 出边中所有点都会使得先手必胜：无论怎么选都会导致另一个人必胜，故先手必败。

在 DAG 中这样就够了，但此题给出的有向图是有环的，所以我们还要考虑平局的情况：

- 若出边中没有点使得先手必败且有点使得平局：那么我们一定会选择平局而不是让另一个人获胜。此时平局。

于是考虑使用一个队列维护当前已经处理出答案的点，依次处理，对当前点：

- 若当前点先手必败：那么能到达它的所有点都是先手必胜。
- 若当前点平局：啥都不用考虑。
- 若当前点先手必胜：那么考虑维护每个点有多少条出边使得先手必胜，对所有能到达它的点更新此值，若所有出边都使得先手必胜则该点先手必败。

但这样是有问题的，考虑下面这组 hack 数据：

```
4 3 1

1 2
2 3
2 4

1 2
```

显然先手必胜，但由于 $3,4$ 这两个先手必败的点冲掉了 $2$ 这个先手必败的点的状态，使得我们认为 $2$ 是先手必胜的，导致答案错误。强制约定不能更新已有答案的点即可。

```cpp
#include <iostream>
#include <vector>

using namespace std;

const int kN = 1e5 + 1;

int n, m, q, f[kN], qx[kN], h, t, c[kN];
vector<int> e[kN], ie[kN];

int main() {
  ios_base::sync_with_stdio(0), cin.tie(0);
  cin >> n >> m >> q;
  for (int i = 1, x, y; i <= m; ++i) {
    cin >> x >> y;
    e[x].push_back(y);
    ie[y].push_back(x);  // 建反向边
  }
  for (int sx, tx; q--;) {
    cin >> sx >> tx;
    h = 1, t = 0;
    for (int i = 1; i <= n; ++i) {
      c[i] = 0;                           // c[i] 维护点 i 的出边中有多少点是已经确定为必胜态的
      f[i] = -(e[i].empty() || i == tx);  // 若没有出边或位于终点时先手必败
      if (f[i]) {
        qx[++t] = i;
      }
    }
    for (; h <= t; ++h) {
      int x = qx[h];
      for (int y : ie[x]) {
        if (!f[y]) {
          if (f[x] == -1) {  // 若当前点先手必败，那么能到达它的所有点都是先手必胜
            f[y] = 1, qx[++t] = y;
          } else if (++c[y] == e[y].size()) {  // 若所有出边都使得先手必胜则该点先手必败
            f[y] = -1, qx[++t] = y;
          }
        }
      }
    }
    cout << f[sx] << '\n';
  }
  return 0;
}
```
