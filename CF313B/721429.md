# 思路

看到这题，脑子里有一个念头：暴力！

但是第二眼看数据范围时，蔫了，字符串长度 $\le 10^{5}$，最坏情况下 $n^2$ 能达到 $10^{10}$，肯定会超时。那怎么办？我们发现题目说要找出 $s_i = s_i+1$ 的有几位，那我们是不是可以用前缀和来做？前缀和可以很好地解决静态查询区间，对于这道题来说不就是道板子题吗？那我们来研究一下前缀和公式有没有什么改变。

原式：$sum_b - sum_{a-1}$

变成 $sum_{b-1} - sum_{a-1}$

为什么呢？因为题目说明了前缀和的计算公式，$sum_i = sum_{i+1}$，而不是 $sum_i = sum_{i-1}$，所以我们要往前推一格，需要按照题目的要求来推导公式。

有了这个公式，我们就能轻松解决此题了。

# 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
	//定义
	 
	char s[100001];
	int t,a,b,i,l,sum[100001]={0};
	
	//输入
	 
	scanf("%s",s);
	
	//变量初值 
	sum[0] = 0;//前缀和第 0 项要赋值，不然计算时很容易超出边界，从而 WA 或 RE。 
	l = strlen(s);//字符串长度 
	
	//处理 
	for(i=0;i<l;i++)
	{
		sum[i+1] = sum[i];//根据前缀和公式 
		if(s[i]==s[i+1])//如果s[i] == s[i+1],说明字符串中两个字符相等 
			sum[i+1]++;//那么前缀和数组 sum[i+1] 就要 +1，这是根据题目来做出操作的， 
	}
	scanf("%d",&t);
	while(t--)
	{
		scanf("%d %d",&a,&b);
		printf("%d\n",sum[b-1]-sum[a-1]);//套用公式，推导过程见前文 
	}
	return 0;
}
```

