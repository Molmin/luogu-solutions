# 题目

[传送门](https://www.luogu.com.cn/problem/CF377C)

# 题解

刚开始我以为这是个贪心，然后打了这样一个代码

``` cpp
inline void Solve(){
    int pts=1,ans=0;
    char opt[5];int team;
    while(m--){
        scanf("%s %d",opt,&team);
        if(opt[0]=='p')ans+=(team==1?1:-1)*val[pts];
        ++pts;
    }writc(ans,'\n');
}
```

然后 $WA$ 穿了......

显然贪心是不对的，因为如果一个人有很多个操作，他在 $ban$ 的回合，不一定会 $ban$ 掉战力最高的英雄

如何解决这个问题？

由于每个队长执行的操作是保证最优的，我们可以定义 `dfs(now,s)` 为执行到操作 $now$，剩下的英雄状态为 $s$ 时，当前操作的队伍能让差变得多大（返回值），那么，对于一个操作 $i$，如果操作 $i$ 和 $i+1$ 是同一队执行，那么差值显然是叠加，否则，最大差值肯定是作差。

为什么这样设计？因为我们要保证每一队都进行最优选择。

**在很多类似的题目中，都保证双方执行最优解时，我们都可以这样进行处理，这是一个很好的方法——线交替先后手地位，用作和或作差对解进行叠加。**

对于每一个操作，我们可以暴力枚举我们应该 $pick/ban$ 掉哪个英雄，为降低复杂度，我们可以定义 $f[i][j]$ 为 `dfs(i,j)` 的返回值。

而我们有四个操作，$pick,ban,miss\space pick,miss\space ban$，但是对于 $pick$ 的回合，选择一定比不选择更优，对于 $ban$，如果是 $miss\space ban$ 也相当于 $ban$ 掉一个最差的英雄，对结果不影响，也就是说，我们只需要考虑 $pick$ 和 $ban$ 两种操作即可。

对于时间复杂度的分析，因为两队都进行最优选择，那么一定不会选择差的英雄，也相当于，只有前 $m$ 个战力最大的英雄有用，那么时间复杂度为 $\mathcal O(20\times 20\times 2^{20})=\mathcal O(419430400)$？（为什么还可以过）

# 代码

```cpp
https://www.cnblogs.com/Arextre/p/13442574.html
```

