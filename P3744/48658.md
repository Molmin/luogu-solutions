内啥。。既然现在还没有题解（其实是没有多少提交），我就先发一个。。

首先，看见这个题，身为蒟蒻的我第一想法是**枚举**。枚举出任意三个点A, B, C，那么很显然，**当点B移动到直线AC另一侧时，这个多边形凹进去了。**（我不是为了迷信起名叫AC的，真的不是！你们要相信我！）

那么这种情况的答案D是多少呢？想让B移动到AC的另一侧，那么它至少要移动的距离，应该是点B到直线AC的距离。可是答案并不是这个距离，而是应该除以二！为什么呢？因为由题意可知，每个点都可以移动不超过D的距离。那么，我只要让直线AC（即点A和点C）向B方向移动，而B向直线AC方向移动，才能得到最小的D，也就是**B到AC距离的二分之一**。

那么问题就转化成了枚举A，B，C，计算出B到AC的距离，最小的那个距离再除以二，就是最终的答案。

注意，为什么这样是正确的呢？毕竟由题意，每个点都是可以动的，而我们的计算却把其它点的移动忽略了。这是因为，不论其它点如何移动，都不会对我们现在枚举的三个点产生影响。而这样会不会造成漏解呢？并不会，因为其它点的移动情况我们会在其它地方枚举到。

那么接下来就是实现了。然而我们尴尬地发现：我们并不能做到枚举三个点——会迎来我们最讨厌的——TLE，这可能意味着我们需要更改算法。不过幸运的是，我们并不需要对思路进行什么修改（要不然前面我不就白说了。。），而是对枚举进行一定的优化——一个小**贪心**——就可以。

**对于一个点B，我们只需要枚举与它相邻的两个点作为A和C就可以！**

这又是为什么呢？我们很容易通过反证法得知：不存在其他直线，比直线AC到点B的距离更短。不熟悉反证法也没有关系，我们可以对图进行观察得到这一结论。

这就大大减少了我们的工作量，接下来我们就要找到和点B相邻的点。然后，我们幸运地发现：我们不必自己寻找了。这是因为出题人的良心——它的点是按照顺时针给的。我们可以把每个点存储在一个结构体数组里，然后直接按顺序枚举，因为下标为i的点，它相邻的点是i-1和i+1。

于是我们可以看到：TLE的风险不存在了。因为我们只需要枚举A，B，C中任意一个点即可，复杂度成功将至O（n）！（‘！’号只是感叹，请不要将其理解为阶乘）

最后的关键就是如何求点到直线的距离。我个人是求出叉积再除以边长——相当于平行四边形面积除以底。方法来源于刘汝佳蓝书。

AC代码如下（亲测0ms，毕竟O（n）复杂度）

```cpp
#include <cstdio>
#include <cmath>
#include <algorithm>

#define INF 1000000000.0

using namespace std;

struct Point {
    double x, y;  //横纵坐标
    Point (double x = 0, double y = 0) : x(x), y(y) {}
};
Point point[1010];

Point operator - (Point x, Point y) {
    return Point(x.x-y.x, x.y-y.y);
}

double Cross (Point x, Point y) {
    return fabs(x.x*y.y - x.y*y.x);
}

double Len (Point x, Point y) {
    return sqrt((x.x-y.x)*(x.x-y.x)+(x.y-y.y)*(x.y-y.y));
}

double solve (int i) {     //计算点到直线距离，i即A，i+1即B，i+2即C
    Point x1 = point[i]-point[i+2];
    Point x2 = point[i]-point[i+1];
    return Cross(x1, x2)/Len(x1, Point(0, 0));
}

int main () {
    int n;
    double ans = INF;
    scanf ("%d", &n);
    for (int i = 0; i < n; i++) {
        scanf ("%lf %lf", &point[i].x, &point[i].y);
    }
    point[n] = point[0];     //由于要枚举下标n-1，所以把n和n+1也填上，避免取模
    point[n+1] = point[1];
    for (int i = 0; i < n; i++) {   //枚举点A
        ans = min(ans, solve (i));
        //printf ("%.10lf\n", ans/2);  用于调试的代码
    }
    printf ("%.10lf\n", ans/2);
    return 0;
}
```