直接对于每个 $k$ 计数的话肯定 $O(n^3)$ 起步，但我们发现一个事实就是一个大正方形框住的每个小正方形都一定合法。

但这道题是计数，为了不重不漏，我们在每个正方形的右上角的那个点处统计它。

容易发现对于每个右上角我们只用找到它能满足条件的最大的正方形即可。

![](https://cdn.luogu.com.cn/upload/image_hosting/s5q3fjk0.png?x-oss-process=image/resize,m_lfit,h_170,w_125)

如上图，我们相当于向外每一层，也就是图中红色的一层一层的，累加颜色。

直到去重后颜色都达到 $q+1$，说明已经超了，于是我们只用想办法按层为关键字排序后取前 $q+1$ 种颜色。

但是我们要对每一个右上角求，每次重新求的话要 $O(n^2)$ 血亏，于是就可以注意到它和左下一个作为右上角的点有很多重复的地方。

![](https://cdn.luogu.com.cn/upload/image_hosting/tnlfxeo6.png?x-oss-process=image/resize,m_lfit,h_170,w_125)

于是我们在求红色点时利用左下的黑色点求出来的前 $q+1$ 个颜色的位置，把新可能加入的颜色，也就是黄色的线段处扔进来更新。

显然只用保留 $O(q)$ 个，同时每次只用加入 $O(q)$ 个，所有合并去重并排序时可以做到 $O(q)$，故复杂度为 $O(n^2q)$。

细节：

- 如果要做到更严格的 $O(q)$ 合并，应该用类似归并的办法往里丢。

  但你发现是上次的红色和这次的两段黄色，总共三段做归并，比较麻烦。
  
  所有直接用一个堆或者直接 sort 一下，$\log 30$ 也不大（？）。
  
- 注意是不超过 $q$ 种，应该是在 $q+1$ 前的位置停下。

- 注意正方形不能超出边界，因为实际实现的时候可能顶到边界的时候还没超过 $q$ 种，于是把超出的也算进来了。

  记得顺便把左下总共都不满 $q$ 种颜色情况的处理了。

- 不用怎么注意常数，随便过（每个点 4s+ 的人这么说）。

  但是每次做合并的时候一定记得是 $O(q)$ 的复杂度，不能全局清空，复杂度挂了别来找我。

- 后缀和大家都会吧，那就完了。

[代码](https://www.luogu.com.cn/paste/8bu2r1z1)