我用的是单调队列，很容易理解，一遍过，跑测试点最快的3ms,最慢的20ms

用deque去维护一个单调递减队列q，拿样例来说

3，2，6，1，1，2 

给他们编号，成这样

（3,1），（2,2），（6,3），（1,4），（1,5），（2,6）

首先（3,1）入队（从队尾入，下面一样）

##### q:（3,1）

（2,2）入队，队列不变

##### q:（3,1），（2,2）

（6,3）入队，因为6比3和2都大，所以6是他们的第一个仰望对象，把3和2删除，记录他们的答案就是6的编号3，此时

##### q:（6,3）

（1,4）入队，队列不变

##### q:（6,3），（1,4）

（1,5）入队，队列不变

##### q:（6,3），（1,4），（1,5）

（2,6）入队，因为2比队里的两个1都大，所以2是他们的第一个仰望对象，把两个1删除，记录他们的答案就是2的编号6，此时

##### q:（6,3），（2,6）

没有新的数字入队，结束，6和2的答案没有更新，说明他们没有仰望对象

#### code:
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,f[100010];
struct node{
	int num;
	int id;
}e;
deque <node> q;
int main()
{
	scanf("%d",&n);
	for (int i=1;i<=n;i++)
	{
		int a;
		scanf("%d",&a);
		while (!q.empty()&&q.back().num<a) f[q.back().id]=i,q.pop_back();
		//找比它小的数，成为这些数的仰望对象 
		e.num=a; e.id=i;
		q.push_back(e); //入队 
	}
	for (int i=1;i<=n;i++) printf("%d\n",f[i]);
	return 0;
}
```


