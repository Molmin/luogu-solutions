### 题目大意：
有一个正整数序列 $a_1,a_2,a_3,...,a_n$ 。

可以对这个序列执行以下两个操作：

- 融合：它可以把这个序列中的两个正整数相加，得到一个新的正整数。
- 减少：它可以把这个序列中的一个偶数 $x$ 除以 $2$，得到 $\dfrac{x}{2}$。

最少要操作多少次后，才能让所有元素都**变为奇数**？

样例解释：

对于第一组数据，$a$ 已全部是奇数。

对于第二组数据，只需将 $1$ 和 $3$ 相加，此时 $a=[1,3]$，都是奇数了，搞定。 

对于第三组数据：
1. 先将 $2$ 和 $8$ 相加，得到 $a=[4,10]$。
2. 再把 $10$ 除以 $2$，得到 $a=[4,5]$。
3. 最后把 $4$ 和 $5$相加，得到 $a=[9]$，已全是奇数。

### 题目总评
乍一看上去，BFS? 不，其实不用。

这题是练习思维的，了解它的真正含义后，这题实现还是比较简单的。

### 解题方案

奇数是什么？就是质因子里面不含 $2$ 的数。

我们的目的是把所有的元素都变成奇数，就相当于把所有质因子 $2$ 给干掉。

回过头来看那两种操作的本质是什么：

先看 `减少`，这个操作比较好理解。$\dfrac{x}{2}$ 不就是相当于干掉一个质因子 $2$ 吗？

再看 `融合`，打个比方，$90$ 和 $60$。$90=2\times3^2\times5,\ 60=2^2\times3\times5$。

$\begin{aligned}90+60& =2\times3^2\times5+2^2\times3\times5\\ & = 2\times(3^3+5+2\times3\times5)\\&=2\times75\end{aligned}$

发现没，少了一个质因子 $2$？

扩展到一般，现有 $2$ 个数，分别为 $2^{p_1}\times p_2$ 和 $2^{q_1}\times q_2$，不妨令 $p_1\ge q_1$

那它们相加就有：
$\begin{aligned}2^{p_1}\times p_2 +2^{q_1}\times q_2 & =2^{q_1}\times(2^{p_1-q_1}\times p_2+ q_2)\\\end{aligned}$

显然，$q_2$ 里没有质因子 $2$，故 $2^{p_1-q_1}\times p_2+ q_2$ 不含质因子 $2$。

所以，`融合` 这个操作就是生成一个质因子 $2$ 的个数为两个被融合数的质因子 $2$ 的个数较小值的数。

~~超长定语。语文不好，没办法缩句了。~~

先让一个数一直除以二，直到质因子 $2$ 的个数为零，再让它和其他每个数相加，让其他每一个数都变成零就可以了。可以证明，这是最优解。

明白了这两个操作的本质就好做题了。
### 代码实现
这里是最朴素的做法，没有用到高大的数据结构。

首先手写一个函数，返回质因子 $2$ 的个数。

这里我取名 `poww()` ~~非常不会取名的样子~~

就一直除以二直到除不了为止，计数。
```cpp
long long poww(long long num){
	long long cnt=0;
	while(num%2==0){
		cnt++;
		num/=2;
	}
	return cnt;
}
```
首先你要让一个数一直除以二，再去和别人相加。又因为要求操作次数的最小值，所以这个数就是质因子 $2$ 最少的数了。当然本来就没有质因子 $2$ 的你为什么要和别的数加呢？所以要记一下零的个数，免得重复加。
```cpp
for(int i=1;i<=n;i++){
	cin>>ques;
	p=poww(ques);	//质因子2的个数
	if(minn>p) minn=p;	//找质因子2的最小值
	if(!p) o++;	//记录没有质因子2的个数
}
```
分析了这么多，答案是什么呢？

首先，先把以个数除成奇数，这需要 $minn$ 次，再把和其他数挨个相加 $n-1$ 次。但有一些数本来就是奇数不需要处理，这样的数有 $o$ 个。但是如果有这种奇数情况存在的话，就要刨掉那个之前处理过的最小值，就剩下 $o-1$ 个奇数，记住 `o--`。

这样，答案就是 $minn+n-o-1$。

输出完事。

**无注释代码：**
```cpp
#include<bits/stdc++.h>
using namespace std;
long long t,n,minn,ques,p,o;
long long poww(long long num){
	long long cnt=0;
	while(num%2==0){
		cnt++;
		num/=2;
	}
	return cnt;
}
int main(){
	cin>>t;
	while(t--){
		o=0;
		minn=1e9;
		cin>>n;
		for(int i=1;i<=n;i++){
			cin>>ques;
			p=poww(ques);
			if(minn>p) minn=p;
			if(!p) o++;
		}
		if(o) o--;
		cout<<minn+n-o-1<<endl;
	}
	return 0;
} 
```

对于每次询问，时间复杂度 $O(n)$ 。