## 题意
给你 $n$ 个数和 $x$，进行 $10^{100}$ 次操作，每次操作从这 $n$ 个数中选一个，让 $x$ 加上 $a_i$，并且不能让 $x=0$，判断是否能完成这 $10^{100}$ 操作。
## 思路
首先我们举个栗子：
```
1
2 10
-3 -5
```
可以看到如果 $10$ 加了两次 $-5$，就会变成 $0$，但可以在每次要变成 $0$ 之前加 $-3$，就不会变成 $0$。

只要这 $n$ 个数中有两个不同的数，每当 $x$ 加上其中一个等于 $0$ 时，加上另一个数，$x$ 永远不为 $0$。

输出 ```Yes```。

于是我们就可以在代码中先进行特判：
```cpp
cin>>a[1];
for(int i=2;i<=n;i++){
	cin>>a[i];
	if(a[i-1]!=a[i])b=1;
}
if(b){
	cout<<"Yes\n";
	continue;
}
```

之后的代码就不用再把这 $n$ 个数用循环枚举了，只用 $a_1$ 去判断就行了，因为经过这次特判，所有的数都是相等的。

------------
再举一个栗子：
```
1
1 10
1
```
这种情况下 $10$ 一直加 $1$，但无论加多少次，$x$ 都不为 $0$，因为 $10$ 和 $1$ 的符号相等。

当 $a_1$ 和 $x$ 符号相同时，正数加正数等于正数，负数加负数等于负数，$x$ 永远不会为 $0$。

输出 ```Yes```。

------------
再再举一个：
```
1
1 10
-3
```
这种情况 $10$ 虽然符号和 $-3$ 相反，但无论 $10$ 加几个 $-3$，也不会为 $0$，因为 $10$ 不是 $-3$ 的倍数。

当 $x$ 和 $a_1$ 符号相等，但 $x$ 不是 $a_1$ 的倍数时，$x$ 也永远不为 $0$。 

输出 ```Yes```。

------------
所以只需要在代码中把以上情况进行判断，就很简单了。
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
long long t,n,x,a[10];
int zf(long long a){ //用来判断符号的函数。
    if(a>0)return 1;
    else if(a<0)return 2;
}
int main(){
    cin>>t;
    while(t--){
        cin>>n>>x;
        long long xx=zf(x),b=0;
        memset(a,0,sizeof(a)); 
        cin>>a[1]; 
        for(int i=2;i<=n;i++){
            cin>>a[i];
            if(a[i-1]!=a[i])b=1;
        }
        if((xx==zf(a[1])||x%a[1]!=0)||b){ //这里我把三种情况放在了一起。
            cout<<"Yes\n";
            continue;
        }
        cout<<"No\n"; //如果没进入下一次循环，就输出“No”。
    }
    return 0;
}
```
