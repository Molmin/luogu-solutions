首先发现当 $b_i$ 全部都为 $1$ 的时候一定满足条件，所以所谓 $\texttt{ambiguous array}$ 就是除了这种方式以外还有至少一种方式满足条件的数列，发现我们可以在 **进行了若干次（可以为 $0$）的 $1$ 操作** 之后进行任意一个 **非 $1$ 操作**，然后一直进行 $1$ 操作就可以了。

发现正着统计难以排除重复情况，考虑补集转换。只需要保证在进行了 **任意次 $1$ 操作后** 都没有其余可操作位置即可。所以 $i$ 这个位置的数必须满足 **$a_i$ 是 $[1,i]$ 中每一个质数的积的整数倍。** 也就是说，定义 $\le i$ 的质数之积为 $mul_i$ ，那么可以填在 $i$ 这个位置的数的数量是 $\lfloor\frac{m}{mul_i}\rfloor$ 。

注意 $m$ 不能直接 $\bmod\ p$ ，要开 `long long` ，当计算到 $mul_i \ge m$ 就可以 `break` 了。

[代码在此处。](https://codeforces.com/contest/1749/submission/180198357)