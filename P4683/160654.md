这个题，应该没有到紫题水平吧。。。

很容易看出来，这就是把字符串全插入后$dfs$一遍，然后他又说操作次数

最小，其实很容易想到，最长的那个词最后输就完了，啥？有不懂的吗？

你看，你要是把词全输出来，肯定整棵树都要遍历没得跑，实际上，这样

一来$P$与单词的操作数量就已经确定了，剩下的只有退格，那要想退格次

数最少，是不是要让最长的最后输（因为最后输就不用退格了）

因此我们在插入到时候，找到最长的一个单词，给它打个标记强制让它最

后输出，就完了。

值得一提的是，这个题很卡空间，我机房大dalao都是因为这个s掉了，所

以数组可千万别乱开哦

这里就给个$dfs$的代码吧，反正其他它也就是个套路

## code

```cpp
void dfs(int x) {//f记录打印顺序，v是判断最长单词上的一个值
	int v = -1;
	if(End[x]) f[++ ans] = 'P';//走到末尾要打印‘P’
	for(R int i = 0;i < 26;++ i) {
		if(vis[Trie[x][i]]) v = i;
		else if(Trie[x][i]) {//走不是最长的一个单词
			f[++ ans] = i + 'a';
			dfs(Trie[x][i]);
		}
	}
	if(v != -1) {
		f[++ ans] = v + 'a';
		dfs(Trie[x][v]);
	}
	else if(vis[x]) flag = false;//如果这个词有标记，就不打印‘-’
	if(flag) f[++ ans] = '-';
}
```
