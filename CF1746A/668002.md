## 题意简析

给定一个 01 序列 $a\ (|a|=n,n>0$ 且 $\forall i\in [1,n]$，$a_i\in[0,1])$ 和一个整数 $k\ (2\le k\le n)$，有两种操作：
- 选择一个长度为 $2$ 的子段，用它们的较小值替换；
- 选择一个长度为 $k$ 的子段，用它们的最大值替换；

问这个序列能否在执行一定数量的操作后变成 $\{1\}$。

考虑两种情况：
1. 这个序列的元素全部为 $0$。则无论留下哪一个元素，这个序列最后一定为 $\{0\}$，无解。
2. 这个序列的元素中含有 $1$。因为 $k\le n$，所以一种通解就是选定一个长度为 $k$、含有 $1$，且对于所有能与这个 $1$ 执行第一种操作（即与这个 $1$ 相邻）的元素，都在这个子段中的子段后，对于剩下的 $n-k$ 个元素使用第一种操作将它们全部删除（可以证明，对于任意一个 01 序列，只使用第一种操作一定能将它们变成 $\{0\}$（如果这个序列的元素中含有 $0$）或 $\{1\}$（如果这个序列的元素全部为 $1$），然后与选定子段中在原序列对应的相邻元素执行第一种操作即可删除）。然后对这个长度为 $k$ 的子段执行第二种操作。因为这个序列含有没有被第一种操作删除过的 $1$，所以执行第二种操作后序列一定为 $\{1\}$，有解。

## 代码/解释
```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
    int t,n,k,a,i;
    bool f;
    cin>>t;
    while(t--)
    {
        cin>>n>>k;f=false;
        for(i=1;i<=n;i++)
        {
            cin>>a;
            if(a) f=true;
        }
        printf(f?"YES\n":"NO\n");
    }
    return 0;
}
```