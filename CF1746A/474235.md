## 题意

简化版题意已经有了。

## 思路

因为串中只有 $0$ 和 $1$，最后又希望剩下的数字是 $1$，所以这个求最小的操作**跟没有一样**。

这个操作只能消除 $1$，我们又需要 $1$，那这个操作有啥用呢？

再想一想，因为 $k \le n$，也就是说每次操作至少可以干掉序列中的一个数字，又因为这个操作取得是最大值，所以：

**只要序列中有一个 $1$**，在经过若干次操作后，一定可以将序列变为一个满足题目要求的序列。

怎么判断序列中有没有 $1$ 呢？读入的时候顺便扫一遍就行啦。

事实上完全不需要开数组将数组存下来，直接用一个变量记录有没有 $1$ 就行了。

注意事项：

- 多组数据；

- 建议使用较快的输入输出方式；

- 注意 `YES` 和 `NO` 均需大写。

----

*code*

```cpp
#include<bits/stdc++.h>
int t,n,k;
bool is_1;
int main ()
{
	scanf("%d",&t);
	while(t--){
		scanf("%d%d",&n,&k);
		is_1=false;
		for(int i=1,tmp=0;i<=n;i++){
			scanf("%d",&tmp);
			if(tmp==1)
			{
				is_1=true;
			}
		}
		if(is_1)
		{
			printf("YES\n");
		}
		else
		{
			printf("NO\n");
		}
	}
	return 0;
}
```
