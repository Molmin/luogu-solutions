翻了翻楼下的大佬们写的全是神仙级别的 `DP` 或者 `搜索` ，暴力很伤心的QwQ！其实这道题的数据范围只有可爱的 2500\*2500，所以即使是  $\color{red}O(n^4)$ 的暴力稍加优化也是可以过的（虽然可能会被特 du 殊 liu 数据 hack）。

评测记录（C++ 不开O2）：总用时562ms，用时最高测试点（#10）278ms

$\ $

## 分析

大体思路是遍历每一个有鱼的点，对每一个点都展开一次暴力搜索，分别向它的左下方和右下方拓展，寻找以该点为起点的最大的满足条件的正方形，再更新答案。当然单纯是这样肯定不可能过，因为时间复杂度已经达到了 $O(n^4)$ 。我们需要加上一些优化才能避免TLE。

### Part I. $\ \ \ $ 搜索答案

首先简单地谈一下如何实现对每一个点的搜索，我们就以向右下方搜索在为例（向左下方搜索可以完全对称）  

$\ \ $设置一个计数器变量，由于孤单的一个点就满足条件，所以计数器初值设为1。  
$\ \ $之后我们向右下方逐个点搜查，我们需要检查目标点1是否满足，首先第一步就是要判断 橙色目标点1 是否有鱼。如果没有，直接返回答案，退出。  
$\ \ $如果有鱼，我们就可以进行第二步判断，就是判断两个粉红色的小格子是否有鱼，如果他们都没有鱼，就说明 橙色目标点1 可行。此时 计数器变量+1  
$\ \ $在接下来检查 黄色目标点2 是否可行时，在检查完其本身有鱼之后，就只需要检查四个淡黄色小格子是否有鱼。这样可以提高检查的效率。同样的道理，检查 蓝色目标点3 时只需要检查六个蓝色小格子 .... 以此类推

![](https://cdn.luogu.com.cn/upload/pic/69081.png)

在代码实现时，要注意加上边界特判，不然可能会出现奇怪的 `WA` 或者 `RE`

附上这一部分的代码实现，具体的表达式大家也可以自己尝试着推导一下，略微有点复杂 

```cpp
int x2=p,y2=q,flag2=0,num=1;  //其中(p,q)表示出发点
do{
	++x2;++y2;           //(x2,y2)表示正在检查的目标点
	if(x2==n+1||y2==m+1){
		flag2=1;
		goto ending2;      //判断边界
	}
	if(!a[x2][y2]){
		flag2=1;
		goto ending2;      //检查目标点是否有鱼
	}
	for(register int i=p;i<x2;++i)
		if(a[i][y2]){
			flag2=1;
			goto ending2;   //检查竖向
		}
	for(register int i=q;i<y2;++i)
		if(a[x2][i]){
		 	flag2=1;
        goto ending2;    //检查横向
	   }
	++num;             //如果以上都检查通过，更新答案
	ending2:;
}while(!flag2);       //如果都检查通过，继续检查下一个目标点

```

这是搜查右下方向的实现代码，搜查左下方向大家可以完全类比着来写一遍。

## Part II. $\ \ \ $优化

前一部分所讲的就是 $O(n^4)$ 的暴力的核心了，但是这显然不可能通过 2500 的数据。你可以大胆的加上 $O_3$ 或者 $Ofast$ 一类的buff·~~（虽然洛咕评测机会把它们忽略掉）~~正解是，我们可以加上一些剪枝，免去不必要的暴力搜索，节约时间。

### 小优化：跳过后期的其它检查

这个在上一部分 `Part I` 里面已经提到了，就是那一系列的 `goto ending`。虽然不太建议使用 `goto` 但是它确实比 `if+else+break` 三件套在此时要方便很多。这里就不详细展开。

### 大优化：剪枝

$\ \ $这也是整个代码通过的核心，大致的思路是避免对一些点展开一些不必要的搜索。然而这个剪枝卡了我整整两天，先前还`WA`了一次。

$$\text{先前WA掉的80分做法}$$

$\  \  $大家可以看到下面的这幅图，浅橙色格子代表有鱼。假设 (1,1) 为出发点，那么按照刚才的搜索思路可以搜索到 (3,3) 都是合法的，但搜索到 (4,4) 时就不符合了。于是我们就可以将 (2,2) 和 (3,3) 做一个标记，一会儿遍历到这两个点时，就不再需要向右下方搜索。 **一定要注意区分标记，因为他不能向右下方搜索，不代表不能向左下方搜索。所以每个点需要两个标记**

![]( https://cdn.luogu.com.cn/upload/pic/69124.png)

这部分的实现代码其实很简单，就只需要在我刚刚的那段代码上做一些小小的改动

```cpp
if(!f[p][q][1]){       //先判断是否要进入搜索
		int x2=p,y2=q,flag2=0,num=1;
		do{
			++x2;++y2;
			
          //  中间的省略了

			++num;
			f[x2][y2][1]=1;   //做标记
			ending2:;
		}while(!flag2);
	}
    ans=max(ans,num);
```

看起来很完美，是不是？但是现实把这个剪枝卡的不要不要的。我们可以看到下面的这幅图，在对 (1,1) 展开搜索时，我们标记过了 (2,2)  (3,3)。在 (4,4) 时不满足条件，结束搜索。然而我们可以很容易的看出，答案最大时其实是 (2,2) 到 (5,5) 这个矩阵。但是 (2,2) 却被我们标记过了，并没有展开过搜索。因此我们的这个剪枝需要修改，即对于一些已经标记过的点，要在这种情况时取消标记。

![]( https://cdn.luogu.com.cn/upload/pic/69139.png)

$$\text{解决方案与AC做法}$$

$\  \ $我们就以横向为例，纵向可以完全类比。我们观察到这个搞事的点坐标是 $(4,1)$ ，所以他只能影响到$ (1,1)$。 对于 $(2,2)$ 和 $(3,3)$ 都无法影响到，我们需要取消 $(2,2)(3,3)$ 的标记。如果这个搞事的点坐标是 $(4,2)$，那么它依然可以影响到 $(2,2)$，我们就只需要取消$ (3,3) $的标记。  
$\  \ $接下来归纳一下表达式，假设出发点坐标是$ (p,q)$，当前正在判断 $(x2,y2)$。假设在 $(x2,i)$ 发现有鱼，我们就需要对第 $i+1$ 至 $y2-1$ 列的对角线上的点取消标记。如果是在 $(i,y2)$ 发现有鱼，那么我们就需要对 $i+1$ 至 $x2-1$ 行的对角线上的点取消标记。     

![](https://cdn.luogu.com.cn/upload/pic/69335.png)

$\ \ $这样就结束了吗？我们还需要对代码做一些修改。因为在之前的代码中我们在竖向的检查中，只要检查到了有鱼，就直接 `goto ending` 。而实际上横向可能会有更具有限制性的情况。比如**下面右边的这幅图**中，红色格子需要重设两个点，黄色格子只需重设一个点。

$\ $

$\  \ $在取消标记时还有非常重要的提高效率的一点，就是在暴力搜索检查 $(x2,y2)$ 的横向和纵向时，要按照**下面左边这幅图的箭头所示的方向**检查。还是以横向为例，假设 $(5,1)(5,3)$ 都有鱼，如果我们从左往右查，那么查到 $(5,1)$ 时会自动跳出，然后取消 $(2,2)$ 到 $(4,4)$ 标记。但是事实上由于有 $(5,3)$ 的限制，我们完全不必要取消对 $(2,2)(3,3)$ 的标记。这样做可以进一步的提高效率。     

![]( https://cdn.luogu.com.cn/upload/pic/69338.png)

具体的代码实现，表达式大家也可以自己推导一下：
```cpp
	if(!f[p][q][1]){
		int x2=p,y2=q,flag2=0,num=1;
		do{
			++x2;++y2;
			if(x2==n+1||y2==m+1){
				flag2=1;
				goto ending2;
			}
			if(!a[x2][y2]){
				flag2=1;
				goto ending2;
			}
			for(register int i=x2-1;i>=p;--i)
			 if(a[i][y2]){                     //检查横向
			 	flag2=1;
			 	for(register int j=i;j<x2;++j)
			 	 f[j][j-p+q][1]=0;        //重设标记
			 	break;                  //注意这里就要break而不是goto
			 }
			for(register int i=y2-1;i>=q;--i)      //检查纵向
			 if(a[x2][i]){
			 	flag2=1;
			 	for(register int j=i;j<y2;++j)
			 	 f[j+p-q][j][1]=0;        //重设标记
			 	goto ending2;           //这里就一定要goto了
			 }
            If(flag2)goto ending2;    //如果刚才是因为break了，特判
			++num;
			f[x2][y2][1]=1;
			ending2:;
		}while(!flag2);
	}
ans=max(ans,num);
```

讲到这里基本上就大功告成了，当然这只是 solve 函数的一半，因为我们还需要对称着写搜索左下方的另一半，下面会把完整代码贴出来。

$\ $

$\ $

##  完整代码

代码中的注释就比较少了，因为讲解主要在上面。略长，大约1.6k，仅供参考。

```cpp
#include<cstdio>
#define rg register

const int N=2505;
bool a[N][N],f[N][N][2];
int n,m,ans;

inline void read(bool &x){   //较快的快读
	char ch=getchar();
	while(ch!='0'&&ch!='1')ch=getchar();
	if(ch=='1')x=true;
}

inline void tomax(int &a,int b){if(a<b)a=b;}  //手写max可以加速
inline void solve(int p,int q){
	rg int num=1;
	if(!f[p][q][0]){                              //搜索左下方
		int x1=p,y1=q,flag1=0;
		do{
			++x1;--y1;
			if(x1==n+1||y1==0){
				flag1=1;
				goto ending1;
			}
			if(!a[x1][y1]){
				flag1=1;
				goto ending1;
			}
			for(rg int i=x1-1;i>=p;--i)
			 if(a[i][y1]){
			 	flag1=1;
			 	for(rg int j=i+1;j<x1;++j)
			 	 f[j][p+q-j][0]=0;
			 	break;
			 }
			for(rg int i=y1+1;i<=q;++i)
			 if(a[x1][i]){
			 	flag1=1;
			 	for(rg int j=i-1;j>y1;--j)
			 	 f[p+q-j][j][0]=0;
			 	goto ending1;
			 }
  			if(flag1) goto ending1;
			++num;
			f[x1][y1][0]=1;
			ending1:;
		}while(!flag1);
	}
	tomax(ans,num);
	num=1;
	if(!f[p][q][1]){                        //搜索右下方
		int x2=p,y2=q,flag2=0;
		do{
			++x2;++y2;
			if(x2==n+1||y2==m+1){
				flag2=1;
				goto ending2;
			}
			if(!a[x2][y2]){
				flag2=1;
				goto ending2;
			}
			for(rg int i=x2-1;i>=p;--i)
			 if(a[i][y2]){
			 	flag2=1;
			 	for(rg int j=i+1;j<x2;++j)
			 	 f[j][j-p+q][1]=0;
			 	break;
			 }
			for(rg int i=y2-1;i>=q;--i)
			 if(a[x2][i]){
			 	flag2=1;
			 	for(rg int j=i+1;j<y2;++j)
			 	 f[j+p-q][j][1]=0;
			 	goto ending2;
			 }
			if(flag2) goto ending2;
			++num;
			f[x2][y2][1]=1;
			ending2:;
		}while(!flag2);
	}
    tomax(ans,num);
	return;
} 
int main(){
	scanf("%d%d",&n,&m);
	for(rg int i=1;i<=n;++i)
	 for(rg int j=1;j<=m;++j)
	  read(a[i][j]);    //读入
	for(rg int i=1;i<=n;++i)
	 for(rg int j=1;j<=m;++j)
	  if(a[i][j]) solve(i,j);     //有鱼就开搜
    printf("%d",ans);
	return 0;
}
```

完成啦！   
于2019.12.15更新了代码，效率更高
