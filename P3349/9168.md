我们要求的是树中点的对应的集合恰好为n个点的方案数，

如果要dp，我们必须记录对应的集合，

考虑x从儿子y转移时，一个点要么在x的集合中，要么在y的集合中，要么两个不在，

时间是O(3^n)的。

而通过容斥，可以将问题转化为求对应集合<=某i个点的方案数，

这样dp时就只用记录当前点对应了哪个点，就是O(2^n\*n^3)。

怎么容斥？

比如我们一开始求出来了<=n个点的，这样大小恰好为n的已经加了，

但有可能存在实际上个数是<n的，我们就把<=n-1个的都减掉，

这样把恰好n-1个点的都减了，但这样每个<=n-2个的就会被减两次，多减了一次，所以我们再加上去，

类似这样，直到集合大小<=1的时候，我们不会再算重了。
