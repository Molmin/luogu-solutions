一道比较简单的bfs题，翻题解发现各位大佬好像都是用数组来记录状态~~？？？~~其实感觉用字符串来记录会比较简单些。

------------
16个格子分别记为

| 0 |  1| 2 |  3|
| :----------: | :----------: | :----------: | :----------: |
| 4 | 5 | 6|  7|
| 8| 9 | 10 | 11 |
| 12 | 13 | 14 | 15 |

有玩具为状态为1，无玩具状态为0，玩具的移动实质是状态的交换
### 字符串记录状态
输入时从0开始将状态加入到字符串中：
```cpp
for(int i=0;i<=3;i++){
          string s;       
          cin>>s;         
          a+=s;           
      }    
```
样例用字符串记录为：
1111000011100010 

### 开数组记录位移
事先开两个数组来记录位置的移动：
```cpp
  int x[24]={0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,0,1,2,4,5,6,8,9,10};
  int y[24]={1,2,3,7,5,6,7,11,9,10,11,15,13,14,15,4,5,6,8,9,10,12,13,14};//用x,y数组来记录可以发生的移动，如从0号格子可以跳到一号和4号
```
### 广搜代码
```cpp
while(!q.empty()){  
      string c=q.front();
      q.pop();        
      if(c==b){       
         cout<<m[c]; 
         return 0;   
      }//如果字符串与目标状态字符串相等，则输出答案               
      for(int i=0;i<24;i++){
          string d=c; 
          if(d[x[i]]==d[y[i]])continue;//如果两个位置的状态相同则无须交换
          swap(d[x[i]],d[y[i]]);
          if(m[d])continue;//如果交换后该状态的字符串已存在则不必再次搜索
          q.push(d);  
          m[d]=m[c]+1;//所用步数加一                                                  
     }               
 }             
```
## 完整代码
```cpp
#include<bits/stdc++.h> 
  using namespace std;    
  int x[24]={0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,0,1,2,4,5,6,8,9,10};
  int y[24]={1,2,3,7,5,6,7,11,9,10,11,15,13,14,15,4,5,6,8,9,10,12,13,14};//记录可交换位置
  map<string,int>m;//开map记录所用步数       
 queue<string>q;         
  string a,b;             
 int main(){             
      for(int i=0;i<=3;i++){
          string s;       
          cin>>s;         
          a+=s;           
      }//记录初始状态                   
      for(int i=0;i<=3;i++){
          string s;       
         cin>>s;         
          b+=s;           
      }//记录目标状态                   
      m[a]=0;             
      q.push(a);          
      while(!q.empty()){  
          string c=q.front();
          q.pop();        
          if(c==b){       
              cout<<m[c]; 
             return 0;   
         }//判断是否已到目标状态               
          for(int i=0;i<24;i++){
              string d=c; 
              if(d[x[i]]==d[y[i]])continue;
              swap(d[x[i]],d[y[i]]);
              if(m[d])continue;
              q.push(d);  
              m[d]=m[c]+1;                                                  
         }//判断是否交换位置               
      }                   
      return 0;           
  }                       

```
------------
萌新第一次写题解，如有讲述不周到处还望提出QwQ