**题意：**

- 高桥先生参加了一个共有 $N(2\leq N\leq 50)$位选手参与的编程竞赛。每位选手的编号为$1,2,3,\cdots,N$，而高桥先生的编号是$1$号，他获得了$M(1\leq M\leq 50)$条“选手 $A_i$ 的排名比 $B_i$ 高”的消息。
- 保证不提供自相矛盾的信息。保证同样的信息不重复$2$次以上。

**思路：**

我们可以定义一个`vector`数组`s[55]`，`s[i]`用来储存排名比编号为`i`的人高的人的编号。
这样的话，一开始的读入就是:
```cpp
scanf("%d%d",&n,&m);
for(i=0; i<m; ++i)
{
  scanf("%d%d",&u,&v);
  s[v].push_back(u);
}
```
之后我们再定义一个队列，用来储存我们要推出的那些人的编号（所以一开始一定要储存$1$），我拿样例一解释一下：

因为找到了比$1$高的$2$，所以储存$2$，寻找比$2$更高的，找到的一定比$1$高。之后操作一样：

$1$ $\rightarrow$ $2$（储存$2$）$\rightarrow$ $3$（储存$3$）

到了$3$，我们发现没有比$3$高的了，又因为推出了$2$个数，所以他排名最高是第$2+1=3$名（还要加上他自己）。又因为没有自相矛盾的信息，所以这个总能结束，我们再用一个`set`来储存之后推出的数（去重），最后输出`.size()+1`即可。

上代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
set<int>f;//储存比1高的
vector<int>s[55];
queue<int>q;//储存需要往后推的数
int n,m,i,u,v,x;
int main()
{
  scanf("%d%d",&n,&m);
  for(i=0; i<m; ++i)
  {
    scanf("%d%d",&u,&v);
    s[v].push_back(u);//因为是储存比自己高的，所以要反过来
  }
  for(q.push(1); !q.empty(); )//一开始先放高桥先生的编号
  {
    x=q.front();
    q.pop();
    for(i=0; i<s[x].size(); ++i)
    {
      f.insert(s[x][i]);
      q.push(s[x][i]);
    }
  }
  printf("%d\n",f.size()+1);//或者一开始f.insert(1);就不用+1
  return 0;
}
```