感觉许多题解并没有讲清楚线段树在存什么。

第一棵线段树存的是一列中的被染色数量。

第二棵存的是一行中被染色数量。

另外，对于容斥原理的推导。

给出三种容斥的情况：

$1$

![](https://cdn.luogu.com.cn/upload/pic/53826.png)

该组数据：

```
5 5 10
1 2 3
1 2 3
2 1 1 5 5
```

此处散发红烟的点在同一行同一列，所以全部被消除了。

所以此处询问 $1$ $1$ $5$ $5$

第一棵线段树的回答就是 $0$ ，第二棵也是。

答案就是 $0$

再看第二种情况：

$2$

![](https://cdn.luogu.com.cn/upload/pic/53825.png)

该组数据：

```
5 5 10
1 2 3
1 4 3
2 1 1 5 5 
```

此处两的发散红烟的点在同一行，所以如果询问 $1$ $1$ $5$ $5$

第一棵线段树的回答就是 $2$ ，第 $2$ 棵就是 $0$ 。

所以就没有重复算的点，答案就是 

$$( x2-x1+1 ) * query( 1, y, yy ) + ( y2-y1+1 ) * query ( 1, x, xx )$$

$3$

![](https://cdn.luogu.com.cn/upload/pic/53827.png)

该组数据：

```
5 5 10
1 2 3
1 4 4
2 1 1 5 5
```

此处散发红烟的点在不同的行列，是普遍的情况，所以我们观察被消除的点，发现重合到一起的就被消除了，也即有几行重合在一起的点，就被多算了 $2$ 次，因为这些点本身是没有被染上颜色的，却把它们作为染了色的点算了两次。

所以答案就是：

$$( x2-x1+1 ) * query( 1, y, yy ) + ( y2-y1+1 ) * query ( 1, x, xx ) - query ( 1, y, yy ) * query ( 1, x, xx ) * 2$$

也就知晓了是如何得出这个公式的。

最后，放上询问部分的代码：

```cpp
		switch ( opt ) {
			case 1: 
				x = read(), y = read();
				update1 ( 1, x, x ); update2 ( 1, y, y ); 
				break;
			case 2: 
				x = read(), y = read(), xx = read(), yy = read();
				zz = query1 ( 1, x, xx ); zzz = query2 ( 1, y, yy );
				wln ( zz * ( yy - y + 1 ) + zzz * ( xx - x + 1 ) - ls ( zz * zzz ) );
				break;
		}
```

