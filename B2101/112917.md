## Content
给定一个 $m\times n$ 的矩阵，求矩阵边缘元素之和。

**数据范围：$1\leqslant m,n\leqslant 100$。**
## Solution
对于新手来说，看到这题就感觉我们以前用的一维数组是肯定不够的。没错，既然有一维数组肯定就有二维数组（甚至还有 $\geqslant 3$ 维数组）。这篇题解首先向新手介绍一下二维数组和多维数组，如果对于这部分已经很熟悉了不妨跳过这个部分。

二维数组的定义方法即为 `a[][]`，没错，就是在原来的一维数组上面多加上一对中括号。然后在每对中括号之间填上数字，就可以定义数组的大小，以此类推，$n$ 维数组的定义方法即为数组名后面加上 $n$ 对中括号，然后在每对中括号之间填上数字。但请注意：如果数组的大小太大，会造成计算机空间不足，会造成空间超限。这也就是评测状态中常见的一种：MLE。因此，**请在定义数组的时候先计算数组的大小，以免造成不必要的空间超限**。具体如何计算数组大小请自行上网搜索查看。

那么回到本题，我们如何判断矩阵中的某一个元素 $a_{i,j}$ 是否是边缘元素？稍微分析一下不难发现，只要满足 $i\geqslant 1$、$i\leqslant m$、$j\geqslant 1$、$j\leqslant n$ 四个条件中的一个，这个元素就是边缘元素。因此我们循环查找每一个元素，判断是否是边缘元素，是的话累加进答案即可。

但是，有没有不用二维数组，甚至不用数组就可以得到正确答案的方法呢？答案是肯定的。我们可以发现，我们可以一边读入，一边判断是否是边缘元素，是的话累加进答案。因此可以直接开一个变量读入 $m\times n$ 次，然后直接同时判断累加进答案即可。

下面的代码仅给出用单个变量的方法。
## Code
```cpp
#include <cstdio>
using namespace std;

int n, m;
long long ans;

int main() {
	scanf("%d%d", &n, &m);
	F(int, i, 1, n) F(int, j, 1, m) {
		int x; scanf("%d", &x);
		if(i == 1 || j == 1 || i == n || j == m) ans += x;
	}
	printf("%lld", ans);
	return 0;
}
```