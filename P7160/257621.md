疯狂刷 $\text{dp}$ 题&&写 $\text{dp}$ 题题解$\text{.jpg}$

本题解主要就解题思路方面进行分析。

------------

首先读题。

我们从题目中的一个小细节——第一行和最后一行必须选——可以发现，我们的这个矩阵环不能将列分割开来。什么意思呢？意思就是说，对于一列的元素，是不会有的框入矩阵环，有的不框的。

所以根据这个细节，我们可以很自然地将该矩阵分为 $3$ 个部分：左侧部分，中侧只选首尾部分，右侧部分。拿样例为例，可以分割成：

```
++|+|+
++|-|+
++|-|+
++|+|+
```

对应的，我们可以将矩阵预处理一下，提前求出每一列的和以及首尾元素和。

下面就开始进行 $\text{dp}$ 了。

------------

因为我们设置了三个部分，所以我们也可以对应将 $dp$ 数组设置成三个，或者多加一维。$dp_{i,0}$ 表示前 $i$ 列化为第一部分时的最大值，$dp_{i,1}$ 表示前 $i$ 列化为第一、二部分时的最大值，$dp_{i,2}$ 表示前 $i$ 列化为第一、二、三部分时的最大值。下面我们来考虑一下转移方程。（下面设第 $i$ 列之和为 $sum_i$，第 $i$ 列的首尾和为 $sw_i$）

首先先来思考第一个 $dp$ 数组的转移方程。它的值的由来应该可以分为两种情况，一种是接着前面选的（即前面已经有几列），一种是新选的（即成为左侧部分的第一列）。那么将这两种情况选一个最大值就可以了。即：

$$dp_{i,0}=max\left\{dp_{i-1,0}+sum_i,sum_i\right\}$$

由于两边都有 $sum_i$，所以可化为：

$$dp_{i,0}=max\left\{dp_{i-1,0},0\right\}+sum_i$$

再来思考第二个 $dp$ 数组。它的值的由来也可以分为两种情况，一种是前面一列为左侧部分，一种是前面一列为中侧部分。将这两种情况取一个最大值即为该数组的转移方程，即：

$$dp_{i,1}=max\left\{dp_{i-1,0},dp_{i-1,1}\right\}+xw_i$$

第三个 $dp$ 数组与第二个同理，即：

$$dp_{i,2}=max\left\{dp_{i-1,1},dp_{i-1,2}\right\}+sum_i$$

最终的答案即为所有的第三个 $dp$ 数组的最大值。

哦，对了，别忘了特判当矩阵任意一边长小于等于 $2$ 时，答案为 $-1$。

------------

### AC 代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define N 100005
#define INF 999999999
int n,m,l[N],sw[N],dp[N][3],ans=-INF;
int read(){//快读
	int w=0,f=1;
	char c=getchar();
	while (c>'9'||c<'0'){
		if (c=='-') f=-1;
		c=getchar();
	}
	while (c<='9'&&c>='0'){
		w=(w<<3)+(w<<1)+(c^48);
		c=getchar();
	}
	return w*f;
}

int main(){
	n=read(),m=read();
	for (int i=0;i<3;i++) dp[0][i]=-INF;//初始化
	if (n<=2||m<=2){//特判
		puts("-1");
		return 0;
	}
	for (int i=1;i<=n;i++)//读入+预处理
		for (int j=1;j<=m;j++){
			int a=read();
			if (i==1||i==n) sw[j]+=a;
			l[j]+=a;
		}
	for (int i=1;i<=m-2;i++)//转移
		dp[i][0]=max(dp[i-1][0],0)+l[i];
	for (int i=2;i<=m-1;i++)
		dp[i][1]=max(dp[i-1][1],dp[i-1][0])+sw[i];
	for (int i=3;i<=m;i++){
		dp[i][2]=max(dp[i-1][2],dp[i-1][1])+l[i];
		ans=max(dp[i][2],ans);
	}
	printf("%d\n",ans);
    return 0;
}
```
