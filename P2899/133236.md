介绍一个转移的技巧 **&&** 详细的状态转移解释

### 题目分析：

考虑树的一条枝干的任意子段，出现以下 $3$ 三种情况是允许的：

1. 建 --- 建

2. 建 --- 不建 --- 建

3. 建 --- 不建 --- 不建 --- 建

竖着看，对于一个节点，最远不建站的节点是自己的儿子的儿子，这时候，自己必须要建站，不然儿子将没有信号。

那么对于节点我们就可以设三种状态，分别是：

1. $f[i][0]$ 自己建站

2. $f[i][1]$ 自己不建，儿子至少有一个建站（这种状态的意义是 **可以不需要父亲建站**，因为自己的儿子已经给了自己信号）

3. $f[i][2]$ 自己不建，儿子也不建（这种状态要求儿子必须要已经有信号，父亲必须要建站）

现在来分条考虑转移：

#### 1. 自己建站：

- 自己动手，丰衣足食，可以由儿子的所有状态转移而来

$$f[i][0]=\sum_{i->j}\min(f[j][0],f[j][1],f[j][2])$$

#### 2. 自己不建，儿子至少有一个建站（最烦人的状态）:

- 首先这个状态肯定不能由儿子的 $3$ 状态转移而来（想想为什么）。因为可多个儿子建站，我们先不管是否存在至少一个儿子最优状态是 $1$ 状态（建站状态），每次贪心取儿子 $1,2$ 状态最小的代价转移，同时记录儿子从 $2$ 状态改取为 $1$ 状态的最小花费，如果最后最小花费为负，说明存在至少一个儿子最优状态是 $1$ 状态，贪心正确，不需要改取。否则说明所有儿子的最优状态都是 $2$ 状态，将这个最小改取费用加上即可。

$$f[i][1]=(\sum_{i->j}\min(f[j][0],f[j][1]))+\max(0,\min(f[j][0]-f[j][1]))$$

#### 3. 自己不建，儿子也不建：

- 因为自己不建，还要求儿子不能建，所以儿子要有信号来源必须要向它自己的儿子要，所以此状态只能从儿子的 $2$ 状态转移而来。

$$f[i][2]=\sum_{i->j}f[j][1]$$

#### 边界条件 -> 对于叶子节点：

$f[i][0]=1,f[i][1]=INF,f[i][2]=0$ 。 ~~（显然）~~

**最后，根节点没有父亲，它不能吃父亲的本，就只能自己建或者靠儿子的信号度日。**

终上所述，我们就可以很容易的写出非常简短的代码。

### 代码实现：

```cpp
#include <bits/stdc++.h>
#define N 10005
using namespace std;

int n, f[N][3];
int head[N], to[N << 1], nxt[N << 1], cnt = 1;

void addedge(int u, int v) {
	to[cnt] = v;
	nxt[cnt] = head[u];
	head[u] = cnt++;
}

void dfs(int p, int fa) {
	f[p][0] = 1;//自己建有一份初始花费
	int minn = n + 1;//极大值（对于状态而言已经最大了）
	for(int i = head[p];i;i = nxt[i]) {
		int v = to[i];
		if(v == fa) continue;
		dfs(v, p);
		f[p][0] += min(min(f[v][0], f[v][1]), f[v][2]);
		f[p][1] += min(f[v][0], f[v][1]);
		f[p][2] += f[v][1];
		if(f[v][0] - f[v][1] < minn) minn = f[v][0] - f[v][1];
	}
	if(minn > 0) f[p][1] += minn;
}

int main() {
	scanf("%d", &n);
	int a, b;
	for(int i = 1;i < n;i++) {
		scanf("%d%d", &a, &b);
		addedge(a, b);
		addedge(b, a);
	}
	dfs(1, -1);//1没有父亲，随便设不存在的点
	printf("%d", min(f[1][0], f[1][1]));//保证1有信号
	return 0;
}
```

### 后记：

很有意思的树上DP，一定要好好理解，与此类似的题可见讨论区，去多刷几道 ~~n倍经验~~ 的题吧。