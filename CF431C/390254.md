- 状态设计：
设 $f[i][0/1]$ 为总和为 $i$ （ $0$ 为不符合要求的路径， $1$ 反之）, 所以最后答案就为 $f[n][1]$ 。

- 转移：
$f[i][0/1]$ 显然可以从 $f[i-j][0/1],j\in [1,k]$ 转移。

1. $f[i][0]+=f[i-j][0],j<d$ , 当总和为 $i$ 时要不符合，那么只能从之前不符合的转移过来，不然就为符合的路径了，还有 $j$ 要小于 $d$ 不然转移的这条路径符合了要求。

2. $f[i][1]+=f[i-j][1]$ , 当总和为 $i$ 时要符合，那么只要从之前符合的转移过来就行了。

3. $f[i][1]+=f[i-j][0],j\ge d$ , 当 $j\ge d$ 时，转移的路径大于 $d$，所以之前不符合的经过这条路径也成了符合的，之前符合的在（2）中已经加过了。

- 初始化：
因为 $d$ 大于 $1$ ，所以当总和为 $0$ 时肯定没有一条路径是大于 $d$的，所以 $f[0][1]=0,f[0][0]=1$ 。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAXN = 1e2 + 10;
const int mod = 1e9 + 7;
int n, k, d;
int f[MAXN][2];
int main ()
{
	cin >> n >> k >> d;
	f[0][0] = 1;
	for (int i = 1; i <= n; i++)
	{
		for (int j = 1; j <= min (i, k); j++)
		{
			if (j < d)
				f[i][0] = (f[i][0] + f[i - j][0]) % mod;
			f[i][1] = (f[i][1] + f[i - j][1]) % mod;
			if (j >= d)
				f[i][1] = (f[i][1] + f[i - j][0]) % mod;
		}
	}
	cout << f[n][1] << endl;
	return 0;
}

```