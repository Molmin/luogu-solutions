## 题目分析

**此题不必最小化步数**

既然不必最小化步数，我们只需要保证每一个芯片都能把这所有的格子都遍历一遍即可，再加上$n,m<=200$，我们甚至不需要输入$k$个芯片。

那么我们怎样实现让所有芯片遍历所有的格子呢？因为一个格子里面可以放多个芯片，所以我们可以把所有芯片利用墙壁把它们堆到一个格子里面，然后再$nm$遍历所有格子即可。

我选择的是把所有芯片堆在左上角，离左上角最远的芯片最远只能在右下角，而右下角到达左上角只需要$(n-1)$个$\texttt{U}$和$(m-1)$个$\texttt{L}$即可。这时我们移动了$(n-1+m-1)$步。

然后遍历所有格子，如果在第$i$行第$j$列。我选择蛇形走，一行一行处理。如果在第奇数行，则输出$(m-1)$个$\texttt{R}$到达右边缘；如果在第偶数行，则输出$(m-1)$个$\texttt{L}$到达左边缘。如果当前在左右两边缘的格子，也就是我们这一行已经走了$(m-1)$步了，我们输出一个$\texttt{D}$。这时我们走了$(n*m)$步。

所以总步数为$(n-1+m-1+n*m)$。

### Code:

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int n,m;
int main()
{
	scanf("%d%d",&n,&m);
	printf("%d\n",n-1+m-1+n*m);
	for(int i=1;i<n;i++)
		printf("U");
	for(int i=1;i<m;i++)
		printf("L");
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<m;j++)
			printf("%c",i%2==1?'R':'L');
		printf("D");
	}
	return 0;
}
```