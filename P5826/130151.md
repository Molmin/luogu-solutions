# 浅谈子序列自动机
本篇文章同时作为 P5826 的题解。

子序列自动机，顾名思义，就是用来匹配子序列的自动机。
## 1-为什么要有它
我们先来看另外一个问题：多次子串匹配。
> 给定一个字符串 $T$ ，$q$ 次询问，每次给定另外一个字符串 $S$，询问 $T$ 在 $S$ 中出现了多少次。
> 
> $len(T)\le10^3,\sum len(S)\le10^6$，字符集为 $1$ 到 $10^6$的正整数。

很显然我们可以先对 $T$ 构造出 $next$ 数组，然后对于每个 $S$ 跑一遍 KMP 即可。

于是，我们自然就会问：上面的是子串匹配，那么如果我们改成子序列匹配呢？

经过一系列的魔改，我们有了下面这道题（[P5826 【模板】子序列自动机](https://www.luogu.com.cn/problem/P5826)）：
> 给定一个字符串 $S$ ，$q$ 次询问，每次给定另外一个字符串 $T$，询问 $T$ 是否是 $S$ 的字序列。
> 
> $len(S)\le10^5,q\le10^5,\sum len(T)\le10^6$，字符集为 $1$ 到 $10^5$的正整数。

我们发现这个时候就不能用上面的方法做了，于是我们发明出了子序列自动机。
## 2-怎么写它
接下来我们会详细剖析它的产生过程。
### 1
先考虑最朴素的想法：如何将所有子序列表示出来，然后像 trie 一样查询就好了？

首先，建一个超级源点，指向所有点；然后，因为每个点的后继可以是任意点，所以要有一条边指向后面的所有点；最后每个点都可以打结束标记。

于是我们画出了下面这张鬼畜的图片：  
![](https://cdn.luogu.com.cn/upload/image_hosting/3h2rieg0.png)  
其中，绿边是表示字符串开始/结束的边，蓝边表示字符之间的边，从 S 到 T 的每一条路径上的黑点排成的字符串就是原字符串的一个子序列。

如此建完图后我们就可以 $O(\text{玄学})$ 搜索了。
### 2
我们发现一个问题：每个点可能有很多条出边指向同一个字符的结点。难道我们要一个个去试吗？这样搜索的时间非常慢。

答案显然是**否定**的。事实上，我们贪心选取最前面的一个点就可以了，简单证明一下就是：如果选后面的可以，改成选前面的显然也可以；如果选前面的不行，那么选后面的会跳过更多也许有用的结点，更加不行。所以，我们直接选最近的点就ok了。

于是，我们就有了一个 $O(len(S)^2)$ 建图+$O(\sum len(T))$ 查询的~~优秀~~算法，但其实实现起来（也许）有些困难。~~（毕竟我懒得写）~~
### 3
我们发现这个算法还是不够快，怎么办呢？

于是我们改进一下：对于每种字符，开个数组记录一下它在哪些地方出现过，然后对于待匹配串的所有字符，一一匹配，保证位置比上一次的位置后，这样和上一种做法其实是等价的，但好写一些。

然后我们就又得到了一个 $O(len(S)+q\times len(S)+\sum len(T))$ 的~~优秀~~算法，好像比上一种还慢。

等等，不对。。。我们把查找的过程改为二分查找不就是 $O(len(S)+\log len(S)\times\sum len(T))$的了吗？机智如我！

于是，~~伟大的~~子序列自动机就诞生了！
### 4
下面给出伪代码（带注释，请放心食用）：
```cpp
vector<int> pos[N]
//使用vector是为了动态分配空间防止空间爆炸
int main()
{
	输入字符串S
	for(i=1->len(S)) pos[S[i]].push_back(i)
	输入询问次数q
	for(i=1->q)
	{
		flg=true
		lstpos=0
		输入T
		for(j=1->len(T))
		{
			vector<int>::iterator y=upper_bound(pos[b[j]].begin(),pos[b[j]].end(),lstpos)
			//为了偷懒这里直接用了stl的二分查找，当然你自己写我也不拦你
			if(y==pos[b[j]].end()) flg=false,break
			//如果找不到说明没有，可以直接break掉
			lstpos=*y;
			//更新目前匹配到的位置
		}
		puts(flg?"Yes":"No")
		//输出对应结果
	}
}
```
据@[一扶苏一](https://www.luogu.com.cn/user/65363) 大佬说，还可以用可持久化线段树来干。下面也讲讲这种做法。

由于我们希望找到最近的下一个字符，所以越靠前的应该越靠后修改，这样才会把后面的覆盖掉，所以我们倒着构造主席树，然后每次查询后面的最近的点。

代码大概是这个样子：
```cpp
[主席树板子]
int main()
{
	输入S
	root[len(S)]=空树(字符集)
	for(i=len(S)->1) root[i-1]=root[i]修改a[S[i-1]]=i-1
	输入q
	for(i=1->q)
	{
		flg=true,pos=0
		输入T
		for(j=1->len(T))
		{
			t=query(root[pos],T[j])
			if(t==-1) flg=false,break
			else pos=t
		}
		puts(flg?"Yes":"No")
	}
}
```
其实区别不大，主要是如何实现查找最近的同字符。
## 3-它有什么用？
当然是做子序列匹配了。

由于你谷上貌似还没有相关的题，我先放几道我口胡的题吧。
### 1
你通过某种方式了解到，敌军有一个长长的密文串 $S$ 以及一个同样长的明文串 $S^\prime$，发送消息时会在 $S$ 中删去一些位得到一段密文发送，然后依据 $S$ 和 $S^\prime$ 解密，结果就是在 $S^\prime$ 中删去对应位的结果。现在你得到一些可能是敌方密文的消息，请判断是不是，如果是请再输出明文。保证得到的结果唯一。

Solution：直接套即可，附加一个找到时记录明文。
### 2
~~想不出来了，咕咕咕~~
## 4-一些拓展
### 1 它可以带修吗？
~~恕我直言，要真有人这么出那就tm是个大毒瘤~~

我们看看单修需要哪些操作：先分别从两个 vector 中定位，然后删一个加一个。

然后我们发现这是 $O(n)$ 的，不太行。

等等，vector 不好像是平衡树的替代品来着？

vector 换成平衡树，于是单修就直接变成 $O(\log n)$ 了，搞定。

如果你非要支持区间推平，请右转珂朵莉树（

还有，主席树版本是不支持修改的。
### 2 它可以查询次数吗？
也许可以，但我不会（

如果要查询有多少个子序列是这样的话，我觉得可能有必要用到玄学dp/组合数学的内容。
### 3 （带修基础上）可以持久化吗？
大概是不行的？

就算你手写可持久化平衡树，一次回溯你需要回溯多个平衡树，其实也不太行。
# 完结撒花！
求赞qwqwq