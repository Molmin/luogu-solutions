# 一个简洁的题解# 
**** 这是一道考思维的题****

拿到这道题，首先应该要用用DP或贪心的思维，毕竟它是求最值问题。

第一部要排序，想到这点的应该有不少，因为对于一道不知道方法的最值题来说，~~没思路就排个序吧~~.......假的，别次次都信！！！

拍完序后，可以自己枚举样例，样例还是比较良心的，给4个不大的数据，既不麻烦，也不是特殊情况干扰思想。

做出样例之后，下一步的思路就是两个类似DP，或者就是DP的简略方程。

dp[x]=dp[x-2]+a[x]+a[x-1]+2*a[1],a[1]+2*a[2]+a[x]

这个方程的总体思路就是先把最慢的人送到对岸，这应该不难想到，因为贪心动归题只能要么从最大要么从最小出发做。对于这题来说，由于最小的人需要不断地来回划船，所以从最大的开始做。   这一点想不到，我也没办法......

然后就是推方程，对于动态方程这个玄学的问题，只可意会不能言传，就靠你自己了。

下面放代码

```cpp
#include <bits/stdc++.h>
using namespace std;
int a[100001],ans;
int jay(int x){
	if (x==1) return a[1];
	if (x==2) return max(a[1],a[2]);
	if (x==3) return a[1]+a[2]+a[3];
	return jay(x-2)+min(a[x]+a[x-1]+2*a[1],a[1]+2*a[2]+a[x]);
}      //个人觉得递归调用比较有意思
int main(){
	int n;
	cin>>n;
	for (int i=1; i<=n; i++) scanf("%d",&a[i]);
	sort(a+1,a+n+1);
	ans=jay(n);    //jay数组就是递归，猜猜为什么写jay？？？
	cout<<ans;
return 0;	
}

```
**
思维题我是觉得挺有趣的，无需任何算法，只需自己推导** 