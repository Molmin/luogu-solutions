纪念AC第101道题暨橙名发表这一篇题解。

不说废话了，不知道为什么，这道题明明是很经典的贪心，但是却只有那么少的人做。。。(另外，这道题中的主人公的名字和我的德语名一样。。。)

其实这道题有两种思路来贪心，我的培训老师曾经讲了一种方式，而当时我又想到了另一种思路，也实现了一下。。。

读完题之后，就会发现这道题的最优方案无非两种：
1.  最快的人一个一个送：a[0]带着a[i]去去来来，每一趟要花(a[i] + a[0])的时间
2.  两个最大的一起过去：先让a[1]带着a[0]过去，再让a[1]回来，再让a[i]和a[i - 1]过去，最后让a[0]回来，每一次要花(a[1] + a[1] + a[i] + a[0])的时间


方式一：枚举分界线。。。

我们会发现，上述的两种情况其实是被一个分界线分开的，也就是说存在这么一条线，它的左边(比他小的部分) 使用第一种方法过河，它的右边(比他大的一边)使用第二种方法过河，所以直接枚举这根线就可以了。。。

代码如下：

```cpp
#include <bits/stdc++.h>
using namespace std;
int main()
{
	int n, i, j, ans, ANS = 0x3f3f3f3f, a[100005];
	cin>>n;
	for(int i = 1; i <= n; i++)
		scanf("%d", &a[i]);
	for (i = 2; i <= n; i++)//枚举每一条分界线。。。
		if ((n - i) % 2 == 0)
		{
			ans = 0;
			for (j = i + 1; j <= n; j += 2)//求和，可以用前缀和优化。。。
				ans += a[2] + a[1] + a[j + 1] + a[2];
			for (j = 2; j <= i; j++)//同上。。。
				ans += a[j] + a[1];
			ANS = min(ANS, ans - a[1]);//求最小。。。
		}	 
	cout<<ANS;
	return 0;
}
```
但是这个代码有一个很大的问题：太慢了，不难发现，这个代码的时间复杂度是O(n ^ 2),因此在洛谷上交上去只有70分，其他的都TLE了。。。所以还是要下一个代码：
P.S.其实这里可以用前缀和优化哦，有兴趣可以自己试一试。。。我为了验证自己的想法，没有进行优化，做了下一种方法的代码发上来。。。(优化之后时间复杂度为O(n))

方法二：两个一组进行考虑。。。
其实在一开始，我们就可以直接从后向前扫一遍，看每两个是按照第一种方案还是第二种方案。。。应该比第一个简单。。。

代码如下：
```cpp
#include <bits/stdc++.h>
#define Max 100005
using namespace std;
int n, ans = 0, a[Max];
int main()
{
	cin>>n;
	for(int i = 0; i< n; i++)
		scanf("%d", &a[i]);
	for(int i = n; i > 3; i -= 2)//从后向前扫一遍。。。
        ans += min((a[0] + a[i - 1] +a[0] +  a[i - 2]), a[1] + a[0] + a[i - 1] + a[1]);//取最小。。。
	if(n % 2 == 1)//看看最后剩的是需要那一种情况。。。
		ans += a[1] + a[0] + a[2];
	else
		ans += a[1];
	cout<<ans<<endl;
	return 0;
}
```
这里的复杂度就只有O(n)了。。。