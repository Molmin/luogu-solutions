#### P1：理论知识

设两个质数为 $p,q$ ，它们的差越小，即与 $\dfrac{s}{2}$ 越接近，乘积越大。

证明：

不妨设 $p \leq q$，即 $p \le \dfrac{s}{2}$。

$p \times q = p  \times (s-p) = p \times s - p^2 = \dfrac{s^2}{4} - (\dfrac{s^2}{4}- 2 \times \dfrac{s}{2} \times p + p^2) = (\dfrac{s}{2})^2 - (\dfrac{s}{2} - p)^2$

$p$ 增大时，$(\dfrac{s}{2} - p)^2$ 减小，$p \times q$ 增大。此时 $p,q$ 与 $\dfrac{s}{2}$ 更接近。

证毕

#### P2：实现方法

1：**入门选手适合**。从 $\dfrac{s}{2}$ 开始逐一枚举每个每个比它小的数（用循环实现），判断是不是质数。当它与 $s$ 和它的差全是质数时，输出乘积并**结束程序**。时间复杂度 $O(s\sqrt{s})$。

2：发现我们判断的所有质数都在 $1 - s$ 范围内，所以可以先预处理次范围内所有质数（用一个长度为 $s$ 的真假（bool）数组存储），再从 $\dfrac{s}{2}$ 开始枚举（和方法 1 一样）。时间复杂度 $O(s)$。需要用到线性筛质数的知识，不会的话也可以 $O(s\log{s})$ 或 $O(s\sqrt{s})$ 做出来。

3：同样先预处理出质数（同样用 bool 数组）。不按照以上理论，从 1 开始枚举每个数，并记录最大乘积。当一个数与 $s$ 和它的差全为质数时，更新最大乘积。时间复杂度同样为 $O(s)$，但是常数比方法 2 高。

注：以上三种方法均可以通过测试数据。建议选一种自己喜欢的并打一遍代码。~~有兴趣可以都写一遍。~~
#### P3：代码
这里只亮出判断质数和线性筛的代码：

```cpp
//判断质数
bool prime(int a){//质数返回真，否则返回假
	for(int i=2;i*i<=a;++i)if(a%i==0)return false;
	return true;
}
```
```cpp
//线性筛质数
int pri[10005],ans;
int k[10005];//记录最小质因子,k[i]==i:i为质数
 
for(int i=2;i<=s;++i){
	if(!k[i])pri[++ans]=i,k[i]=i;
	for(int j=1;pri[j]<=min(k[i],n/i)&&j<=ans;++j)k[pri[j]*i]=pri[j];
}
```