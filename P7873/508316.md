根据测试点我们逐个讨论。

## Testcase #0
输出样例，不用我多说了吧。

## Testcase #1
$n=1$，所以肯定不会有人使这个人失落。


所以输出一行 ~~乱七八糟~~ $0-m$ 就可以了。

## Testcase #2

$m=1$，所以无论怎么构造，除了 $n=1$ 的时候，都会有人失落，所以输出 $\text{NO}$。

## Testcase #3
距离正解很近的一个测试点。

既然有两个科目，那么就让这个矩阵第一列从小到大递增，第二列从大到小递减即可，这样就能保证任意两行中的一行不会出现没有一个数大于等于另一行的情况。

## Testcase #4
没看懂这个测试点的设置意义，不知道干吗的。

## Testcase #5

要上正解了。

从 Testcase #3 我们发现，当矩阵只有两列时我们可以轻松构造出方案。

那么，对于任何两行的前两列，保证第一列递增，第二列递减，所以矩阵已经满足条件，所以对于一行中后面的 $m-2$ 个数字我们就可以不管它了，全为 $0$ 即可。

所以其实正解就是 Testcase #3！

## 核心代码：
```
int t1 = 0, t2 = 100;
			
for (int i = 1; i <= n; i ++) {
	ans[i][1] = t1 ++;//第一列递增。
	ans[i][2] = t2 --;//第二列递减。
    //其余的都为0即可。
}
			
for (int i = 1; i <= n; i ++) {
	for (int j = 1; j <= m; j ++) {
		printf ("%d ", ans[i][j]);
	}
				
	printf ("\n"); 
}
```
