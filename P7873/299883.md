其实感觉这题可以降红。

### 题意：
构造一个矩阵，对于矩阵的每一行，都有一个元素大于其他每一行的这个元素。
### 思路：
只要有了构造思路，只需直接循环输出即可。

首先我们发现，如果人数 $\gt1$ 但是却只有一门学科，那么必有一人分数大于等于其他人，于是输出 `NO`。

对于其他的情况，我们直接开始构造。

我们便可以给每一个人构造一个分数了，我们使某一科分数在编号增加的时候递减，其它分数递增：

#### 语言表述：

第一个人的最后一科分数比其他人都高。

第二个人最后一科分数高于大于他编号的人，其它科分数高于第一个人。

...

第 $n$ 个人除最后一科，其它分数都比别人高。

#### 数列：

第 $1$ 个人：$0,0, ... ,0,100$；

第 $2$ 个人：$1,1, ... ,1,99$；

第 $3$ 个人：$2,2, ... ,2,98$；

$...$

第 $n$ 个人：$n-1,n-1, ... ,n-1,100-n+1$。

于是就一目了然，可以证得每一行都有大于其他行的分数。

我们构造的分数必须满足 $0\le score \le 100$，但是由于 $n \le100$，我们表中出现的分数便不可能 $\lt0$ 或者 $\gt 100$。

每一次循环构造即可。

### 程序如下：
```cpp
#include<cstdio>
#define ri register int
using namespace std;
int T,t,n,m;
int main(){
	scanf("%d%d",&T,&t);//大T没啥用
	while(t--){
		scanf("%d%d",&n,&m);
		if(n>1&&m==1)printf("NO\n");//不可能的情况
		else{
			printf("YES\n");
			for(ri i=0;i<n;i++){
				for(ri j=1;j<m;j++)printf("%d ",i);//输出递增的分数
				printf("%d\n",100-i);//和最后那个递减的分数
			}
		}
	}
	return 0;
}
```

### THE END