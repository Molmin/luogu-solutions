update on 2023.5.24 补充了一个式子的变换过程。

## 解题思路

我们观察题面后可以得到几个很直观的连接约束：

1. 每次连边一定是从 $1 \sim n-1$ 中连一条边到 $1$，否则无法最大化边数。

2. 不可能从 $n$ 出发连边，因为到了 $n$ 之后就不可能继续走了。

3. 先从 $n-1$ 开始连边，再考虑从 $n-2$ 开始连边，以此类推。

那么接下来我们来考虑一下，假设仅可以连两条边，从 $n-1$ 连两条边到 $1$ 对答案贡献大一点还是从 $n-1$ 与 $n-2$ 各连一条边到 $1$ 对答案的贡献大。

应该是两个各连一条对答案的贡献更大，因为这样的话，只花 $n-1$ 步就可走到终点的概率为 $\frac{1}{4}$，另一种方式的概率为 $\frac{1}{3}$。

但我们能不能通过计算出两种方式的期望值来进行比较呢，应该是可以的，不过式子是什么呢？

我在草稿纸上列了一下，发现搞出了一个有限微积分的式子，比较复杂，虽然可以算，但是计算方式应该比较难搬到 OI 上，因此我们来考虑另一个方向。

既然从数学方式比较难搞出来，那么它有没有可能用状态转移方程搞出来呢？（感谢 dxw 提供的思路）。

根据我们的连接约束，我们可以列出如下的状态转移方程：

$$
x_i=\frac{1}{a_i+1}x_{i+1}+\frac{a_i}{a_i+1}x_1+1
$$

其中 $x_i$ 表示从第 $i$ 个点出发到第 $n$ 个点的期望步数，$a_i$ 表示这个点往 $1$ 连的边数。$x_n=0,a_n=0$。

由于第 $i$ 点出去实际上有 $a_i+1$ 条边，而题目说了从这 $a_i+1$ 条边中等概率地选择一条边走，则有 $\frac{1}{a_i+1}$ 的概率走到第 $i+1$ 个点，有 $\frac{a_i}{a_i+1}$ 的概率走到 $1$。

然后我开始推通项公式，推出来这样的式子：

$$
x_1=\frac{1}{a_1+1}x_2+\frac{a_1x_1}{a_1+1}+1
$$

$$
x_1=x_2+a_1+1
$$

$$
(a_2+1)x_2=x_3+a_2(x_2+a_1+1)+a_2+1
$$

$$
x_2=x_3+a_1+2a_2+a_1a_2+1
$$

$$
\cdots
$$

如下这么推下去我推出了一个极其复杂的式子，很难去简化，就不展示给大家看了。

但实际上我们观察一下便可以发现：

$$
x_1=\sum_{i=1}^{n-1}\prod_{j=i}^{n-1}(a_j+1)
$$

具体推导方式如下，运用了倒推的方式（之前应该是因为思维惯性一直无法脱离正着推的魔爪）：

$$
x_{n-1}=\frac{a_{n-1}x_1}{a_{n-1}+1}+1
$$

$$
x_1=\frac{(a_{n-1}+1)(x_{n-1}-1)}{a_{n-1}}=x_{n-1}-1+\frac{x_{n-1}-1}{a_{n-1}}
$$

$$
x_{n-2}=\frac{x_{n-1}}{a_{n-2}+1}+\frac{a_{n-2}x_1}{a_{n-2}+1}+1
$$

$$
(a_{n-2}+1)x_{n-2}=\frac{a_{n-1}x_1}{a_{n-1}+1}+1+a_{n-2}x_1+a_{n-2}+1
$$

$$
x_1=\frac{1}{a_{n-1}+(a_{n-1}+1)a_{n-2}}((a_{n-1}+1)(a_{n-2}+1)x_{n-2}-2(a_{n-1}+1)-(a_{n-1}+1)a_{n-2})
$$

设 $t=
\frac{1}{a_{n-1}+(a_{n-1}+1)a_{n-2}}$，

$$
x_1=x_{n-2}+tx_{n-2}-2+t(a_{n-1}+1)a_{n-2}
$$

$$
\cdots
$$

限于篇幅，剩下的推导过程留给大家。

不过由于这个东西比较数学，身为 OIer，我们要有找规律与运用特例总结式子的思维与能力。

如我们对 $n=4,m=5$，进行手动计算。

不过在计算之前，我们需要用模拟得出 $a$ 数列的最佳方案。

最终的最优 $a$ 数列为：

```
1 2 2 0
```

我们将数据代入 $x_i=\frac{x_{i+1}+a_ix_1}{a_{i}+1}+1$ 得：

$$
x_3=\frac{2x_1}{3}+1
$$

$$
x_2=\frac{\frac{2x_1}{3}+1+2x_1}{3}+1=\frac{8x_1}{9}+\frac{4}{3}
$$

$$
x_1=\frac{\frac{8x_1}{9}+\frac{4}{3}+x_1}{2}+1=\frac{17x_1}{18}+\frac{5}{3}
$$

也即 $x_1=30$。

根据刚才的推导我们可以发现最终答案的形式可以表现为：

$$
\prod_{i=1}^{n-1}(a_i+1) \cdot\sum_{i=0}^{n-2}(\prod_{j=0}^i(a_j+1))^{-1}
$$

其中 $a_0=0$，经过小型的变换，上式与

$$
x_1=\sum_{i=1}^{n-1}\prod_{j=i}^{n-1}(a_j+1)
$$

是等价的。

（这里补充一下变换过程）

$$
\sum_{i=1}^{n-1}\prod_{j=i}^{n-1}(a_j+1)=\sum_{i=1}^{n-1}\frac{\prod_{j=0}^{n-1}(a_j+1)}{\prod_{j=0}^{i-1}(a_j+1)}
$$

$$
=\prod_{i=1}^{n-1}(a_i+1) \cdot\sum_{i=0}^{n-2}(\prod_{j=0}^i(a_j+1))^{-1}
$$

因此我们可以列出一个计算期望步数的 $O(n)$ 算式。

这样的话我们可以通过 dfs 通过前面的 2 个 Subtask。

所以接下来重要的问题就是 $a$ 数列的形式。

不过我们瞄一眼数据范围，看到了一个 $m<n-1$，这一部分肯定是从 $n-1$ 到 $n-m$ 各放一条边到 1 是最好的，这样我们可以 $O(\log n)$ 计算出期望步数，时间复杂度瓶颈在于快速幂。

我们在通过多组数据模拟后，我们可以发现如下规律：

1. $a_1$ 必然是 $a_1 \sim a_{n-1}$ 中的最小值，且是唯一的最小值。

2. $\max\limits_{i=1}^{n-1}a_i-\min\limits_{i=1}^{n-1}a_i \le 2$。

3. $a_1 \sim a_{n-1}$ 单调不降。

4. $a_n=0$。

可以从我们的连接原则或说是连接约束以及期望步数计算公式可以推导出来。大家可以具体做一个推导。

最后的合法 $a$ 数列具体表现形式有可能如下：

```
2 4 4 4 4 0
```

也有可能是

```
4 6 6 6 6 6 6 0
```

样例的第二个数据的 $a$ 数列如下：

```
1 3 3 3 3 3 3 3 3 0
```

样例的第三个数据的 $a$ 数列如下：

```
2468 2469 2469 2469 2470 0
```

进行手动模拟计算发现正确。

当 $m\ge n-1$ 时，$a_1=\lfloor\frac{m-n+2}{n-1}\rfloor,m=m-a_1-(n-2)(a_1+1),a_{2 \sim n-m-1}=a_1+1,a_{n-m \sim n-1}=a_1+1$。

那么现在我们就可以得到最后的代码，时间复杂度为 $O(T\log m)$，瓶颈在于快速幂。

## 解题代码


```cpp
#include<cstdio>
typedef long long ll;
inline ll read(){
	ll x=0,f=0,ch=0;
	while(ch<48||ch>57) f=(ch=='-'),ch=getchar();
	while(ch>47&&ch<58) x=(x<<3)+(x<<1)+(ch&15),ch=getchar();
	return f?-x:x;
}
inline void write(ll x,char end=' '){
	if(x==0){
		putchar('0');
		putchar(end);
		return;
	}
	if(x<0) putchar('-'),x=-x;
	int ch[70]={0},cnt=0;
	while(x){
		ch[cnt++]=x%10;
		x/=10;
	}
	while(cnt--) putchar(ch[cnt]+48);
	putchar(end);
}
ll n;
ll m,p;
ll a[1005],b[1005];
ll ans;
inline ll max(ll x,ll y){return x>y?x:y;}
inline ll fp(ll x,ll y){
	ll s=1;
	while(y){
		if(y&1) s=s*x%p;
		x=x*x%p;
		y>>=1;
	}
	return s;
}
inline ll dv(ll x,ll y){return x*fp(y,p-2)%p;}
int main(){
	int T=read();
	while(T--){
		n=read();
		m=read(),p=read();
		if(n==1){
			write(0,'\n');
			continue;
		}
		if(m<n-1){
			ll prod=fp(2,m);
			m%=p;
			ans=prod*(n-m+p)%p;
			ans=(ans+prod-2)%p;
			ans=(ans+p)%p;
			write(ans,'\n');
			continue;
		}
		ans=0;
		a[1]=(m-n+2)/(n-1);
		m-=a[1];
		m-=(n-2)*(a[1]+1);
		a[1]%=p;
		ll prod=fp(a[1]+3,m);
		ll sum=0;
		if(m>0)
			sum=dv(((prod*(a[1]+3)%p-a[1]-3)%p+p)%p,a[1]+2);
		ll prod2=fp(a[1]+2,n-2-m);
		if(n-2-m>0)
			sum=(sum+prod*dv(((prod2*(a[1]+2)-(a[1]+2))%p+p)%p,a[1]+1)%p)%p;
		prod=prod*prod2%p;
		sum=(sum+prod*(a[1]+1)%p)%p;
		sum=(sum%p+p)%p;
		ans=sum;
		write(ans,'\n');
//		for(int i=1;i<=n;++i) write(a[i]);
//		puts("");
	}
}
```