首先拿到这一题，对于一些萌新来说一点思路也没有~~例如我~~，然后看到这是一道红题，智商瞬间被侮辱（

## 整体思路

举个例子：`2 3 4 1 5 6`。

显然这个序列是不能全部归零的，怎么判断呢？我们可以先把第一项归零：

`0 1 4 1 5 6`

然后把第二项归零：

`0 0 3 1 5 6`

然后，我们可以发现第三项无法归零了，因为最多我们只可以把序列做成这样：

`0 0 2 0 5 6`

所以这个序列是不能归零的。

看出来思路了吗？我们可以遍历数组，然后把相邻的两项同时减少 $x$，令前一项为 $0$，如果后一项为负数，那么不能归零。

再举个例子：`2 3 1 5`。

按照上面的思路，步骤依次是：

`0 1 1 5`

`0 0 0 4`

然后发现，最后一项没有归零，所以我们又可以知道，如果操作完成后最后一项不为 $0$，那么就无法归零数组。

## 代码

对于每组测试样例给出代码：


```cpp
int a[10006]={0},flag=0,n;
cin>>n;
for(int i=1; i<=n; i++) cin>>a[i];
for(int i=2; i<=n; i++) 
    if(a[i]<a[i-1])
    {
        flag=1;
        break;
    } 
    else 
        a[i]-=a[i-1];
if(flag!=0 || a[n!=0]) cout<<"NO"<<endl;
else cout<<"YES"<<endl;

```
## ~~优化~~代码

瞎折腾的，**学术模式请跳过以下内容。**

- 优化 $1$：把变量名更改，例如 `flag` $\to$ `f`

- 优化 $2$：压行。

- 优化 $3$: 输出，用 `puts()` 换行。

然后，代码就变成了一份全咕最短代码：


```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	int T; cin>>T;
	while(T--){
		int a[10006]={0},f=0,n;
		cin>>n;
		for(int i=1;i<=n;i++) cin>>a[i];
		for(int i=2;i<=n;i++) if(a[i]<a[i-1]){f=1;break;} else a[i]-=a[i-1];
		if(f||a[n]) puts("NO");
		else puts("YES");
	}
	return 0;
}
```
