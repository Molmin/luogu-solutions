## 题目大意

~~粗劣的~~翻译：对于 $T$ 组数据，每次给定一个长度为 $n$ 的序列 $a_{1...n}$,对这个序列进行操作，每次可以选取一个 $i(0<i<n)$，并把 $a_i$ 和 $a_{i+1}$ 同时减一。操作次数无限，问最终是否可以使序列中的所有数成为 $0$。


------------
## 解决问题

由于每次操作只针对相邻的两个数，而且以此操作放在任何时候都无所谓，因此题目中的减一操作我们可以看作减去任意数。

对于任何一个数 $a_i$，除了 $a_1$ 和 $a_{n}$，它的值只可能跟随 $a_{i+1}$ 或 $a_{i-1}$ 一同变化。突破口便是 $a_1$ 和 $a_{n}$。以 $a_{1}$ 为例，由于 $a_{1}$ 左边没有数，那么它的值若要变化，只能和 $a_{2}$ 一起变。我们的目标是让它们全变成 $0$，我们知道操作的顺序没有影响，那我们如果要改变 $a_{1}$ 的值，必然要将 $a_{1}$ 和 $a_{2}$ 同时减去 $a_{1}$，否则 $a_{1}$ 没有机会变成 $0$。这样操作一次，$a_{1}$ 变成了 $0$,$a_{2}$ 变成了 $a_{2}-a_{1}$。由于 $a_{1}$ 已经是 $0$ 了，$a_{1}$ 便可以丢掉不管，此时我们相当于得到了一个长度为 $n-1$ 的新序列，我们只用不停地从左到右重复操作，即对于每个 $a_{i}$ ,把 $a_{i}$ 和 $a_{i+1}$ 都减去 $a_{i}$，如果某一时刻减出负数，则最终不可能全为 $0$。特别的，操作完成后还要检查一下 $a_{n}$ 是否为 $0$。

------------

## 上代码

```
#include<bits/stdc++.h>
using namespace std;
int main(){
	int T;
	int n;
	int a[10010];
	cin>>T;
	for(int i=1;i<=T;i++){
		cin>>n;
		for(int i=1;i<=n;i++)
			cin>>a[i];
		int z=0;//标记一下是否已经输出过NO 
		for(int i=1;i<=n-1;i++){//n-1次操作 
			a[i+1]-=a[i];//其实a[i]和a[i+1]都要减去a[i],但是a[i]的值之后就没用了，没有减的必要 
			if(a[i+1]<0){//减出负数 
				cout<<"NO"<<endl;//输出NO，做下标记 
				z=1;
				break;
			}
		}
		if(z==0){//标记未改变，说明没有减出负数，现在来判断a[n] 
			if(a[n]!=0){
				cout<<"NO"<<endl;
				continue;
			}
			cout<<"YES"<<endl;
		}
	}
	return 0;
}
```
