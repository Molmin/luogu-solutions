## 题解

样例非常多，模拟完之后差不多就知道解法了。

首先最优解只有三种可能。

1. 删掉相邻的数
2. 删掉间隔一格的数
3. 删掉最小的两个但不一定属于上述两种的数

当不属于 1 和 2 的时候，删掉的两个数互相没有影响，所以最优解一定是贪心删除最小的两个。

对于这三种，再暴力分讨。下文说的 $-1$，$-2$，$-3$ 指对 $x+y$ 的改变。

1. 相邻，不妨设 $x<y$。
	1. $\lceil\frac{y}{2}\rceil\ge x$，此时暴力单独删 $y$ 即可，$x$ 会自己消掉。
	2. 否则，会发现对 $y$ 进行操作后，$x$ 和 $y$ 的差值固定 $-1$，并且当 $x$ 和 $y$ 相等后不会出现 $x,y$ 是负数。同时，对 $y$ 操作会总共造成 $-3$ 的贡献，是最优的。那么可以先把 $x,y$ 减到相同，然后交替操作，这样每步操作都是 $-3$ 的。最后会剩下 $1,1$ 或 $1,0$，这时候只能被迫 $-2$ 或 $-1$。可以证明这样的操作方式一定是最优的。可以转化成你有一个数 $x+y$，每次可以 $-1$、$-2$ 或 $-3$，那么如果能一直 $-3$ 最后再 $-1$ 或 $-2$ 一定是最优的。
2. 间隔一，不妨设 $x<y$。
	1. $x,y$ 都为奇数，此时在 $x,y$ 中间那个数操作可以使两者同时 $-1$。接下来两个偶数，可以分别单独操作，每一步都是 $-2$ 的，必定是最优解。因为在间隔一的限制下每一步最多 $-2$。
	2. 不均为奇数，那么对每个数单独减即可。如果一奇一偶会出现最后一步是 $-1$，其他步是 $-2$，可以证明这一定是最优的。因为一步只能 $-1$ 或 $-2$，但 $x+y$ 是奇数，最优解一定是一堆 $-2$ 和一个 $-1$。
3. 暴力改，没有更优，证明同上。

一句话概括解法就是**构造出一种合法的操作方案**，然后证明**这种构造足够优，并且没有更优的**。

~~这凭什么是绿啊~~

~~这凭什么*2000啊~~

## 代码

```cpp
// Problem: E. Breaking the Wall
// From: Codeforces - Codeforces Round #786 (Div. 3)
// URL: https://codeforces.com/problemset/problem/1674/E
// Time: 2022-05-14 17:03
// Author: lingfunny

#include <bits/stdc++.h>
using namespace std;
const int mxn = 2e5+10;

int n, a[mxn], res = 1e9, x, y;

signed main() {
    scanf("%d", &n);
    for(int i = 1; i <= n; ++i) scanf("%d", a+i);
    for(int i = 1; i < n; ++i) {
		x = a[i], y = a[i+1];
        if(x > y) swap(x, y);
        if(x <= (y+1)/2) res = min(res, (y+1)/2);
        else res = min(res, (x+y+2)/3);
    }
    for(int i = 1; i + 2 <= n; ++i) res = min(res, (a[i]+a[i+2]+1)/2);
	auto it = min_element(a+1, a+n+1);
	x = *it; *it = 1e9; it = min_element(a+1, a+n+1);
	y = *it; res = min(res, (x+1)/2+(y+1)/2);
    printf("%d\n", res);
    return 0;
}
```