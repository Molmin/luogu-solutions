# 题目：P4753 River Jumping 2018 洛谷7月月赛 T2
## 题目描述
$\ \ \ \ \ \ $有一条宽度为 $N$ 的河上，小$D$位于坐标为 $0$ 的河岸上，他想到达坐标为 $N$ 的河岸上后再回到坐标为 $0$ 的位置。在到达坐标为 $N$ 的河岸之前小$D$只能向坐标更大的位置跳跃，在到达坐标为 $N$ 的河岸之后小$D$只能向坐标更小的位置跳跃。在河的中间有 $M$ 个岩石，小$D$希望能跳到每个岩石上恰好一次。由于小$D$的跳跃能力太强，小D的跳跃长度有个下限 $S$ ，但没有上限。现在请你判断他是否能够完成他的目标。   
$\ \ \ \ \ \ $如果小$D$可以完成他的目标，第一行输出$YES$, 下一行输出踩石头的编号 。**如果有多种解法，允许输出任意一种。**  
$\ \ \ \ \ \ $如果小$D$不能完成他的目标，第一行输出$NO$。
## 分析
$1$ . 看完题目，你极可能想起某NOIP提高组跳石头，你会想起贪心和二分算法，但是很明显，本题不符合二分的单调条件，所以应使用贪心 ( 这个题的贪心思想只是黄题水平）。  
$2$ . 我们不太好处理去和回两次走，应该想出一种策略，使去或回尽量偏向一方。     
$3$ .输入的 $w$ 序列有序。(但是出题人的题解$sort$了一遍)  
## 解答
$1$ . 首先啊，我们要把 $w_0$ 赋成 $0$, $w_{m+1}$赋成 $n$ ,也就是方便我们接下来的处理。  
$2$ . 细节，我们发现，如果离起点最近的石头距离起点( 即$w_1$ )小于 $s$ ,或者离终点最近的石头距离终点( 即$w_m$ )小于 $s$ ,那么可以直接判成$NO$。因为在这种情况下，去时无法踩到离起点最近的石头，回时也踩不了离终点最近的石头，就会有石头遗漏, 即:  
$\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ if(w[1]<s\ or\ n-w[m]<s)\ then\ NO$  
$3$ . 细节$again$, 数据范围中有一种毒瘤的情况 ( $m=0$ ), 那么如果最短跳跃距离小于了河宽，那么简单输出即可， 反之就输出$NO$, 即:  
$\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ if(m=0\ and\ n<s)\ then\ YES$  
$\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ else\ then \ NO$  
$4$ . 我们的策略：去时跳所有离我们最近的可跳的石头，剩下没跳时就回时跳，如果回时跳不了，就是 $NO$ 的情况。其正确性，简单可证，假如我们一定能跳上所有的石头，就需要去和回各跳一部分，我们去时尽量放缓步伐，跳尽量多的石头，回时就能大跨步，迅速完成问题，如果回时跳不了，那么去时就应该多跳几个，一直影响到去时的最后一次，就必定$N)$。  
$5$ . 我们用两个指针 $l$ , $r$ 来实现，一个指向现在脚下的石头的编号，另一个指向下一次我们要尝试的石头编号 , 将满足条件 $ w_l-w_r<s$ 时记下标号，那是我们回时要踩的石头，不满足，也记下，这是去时的石头，具体看代码。
```cpp
int n,m,s,w[N],go[N],cnt_1,come[N],cnt_2,l,r;//指针初始为0。
bool flag=false;
int main()
{
  n=read(),m=read(),s=read();
  for(int i=1;i<=m;i++)w[i]=read();
  w[0]=0,w[m+1]=n;
  if(w[1]<s||n-w[m]<s||(m==0&&n<s)){printf("NO\n");return 0;}//对应着分析2，3。
  else if(m==0&&n>=s){printf("YES\n1 0");return 0;}
  while(r<=m+1)//限制循环，记住可以模拟到最后一位(当然也可以枚举解决问题)
  {
    if(w[r]-w[l]>=s){go[++cnt_1]=r;l=r;r++;}//对应着解答5，先更新l到r，在把r向后移动。
    else {come[++cnt_2]=r;r++;}//记下回来时(其实可以优化)
  }
  for(int i=cnt_2;i>=2;i--)
    if(w[come[i]]-w[come[i-1]]<s){flag=true;break;}//回来时，判定临近两点间的距离是否成立，打标退出。
  if(flag){printf("NO\n");return 0;}
  //有些同学的代码还要输出m+1和0，上面从0开始推避免了这个问题，回的序列中一定有个0(因为l==r==0)
  printf("YES\n");
  for(int i=1;i<=cnt_1;i++)printf("%d ",go[i]);//正序输出去。
  for(int i=cnt_2;i>=1;i--)printf("%d ",come[i]);//倒序输出回。
  return 0;
```
但是，就如我所说，其实可以小小优化，但数据范围太小，题也比较水，其实没什么必要，但还是说一下。
```cpp
while(r<=m+1)
{
  if(w[r]-w[l]>=s){go[++cnt_1]=r;l=r;r++;}
  else {come[++cnt_2]=r;r++;}
  if(cnt_2>=2&&w[come[cnt_2]]-w[come[cnt_2-1]]<s){printf("NO\n");return 0;}//优化在此，处理时就可以比较，得出结论，少一个循环，虽然复杂度On没有变。
}
```
## 总结
$1$ .题目是真的水，不管是思想还是代码，但是我在比较时 $come[cnt]$ 没有套上 $w$ ,调了一上午。  
$2$ .这个故事告诉我们，贪心时尽量使用下标，思路清晰，不易错。