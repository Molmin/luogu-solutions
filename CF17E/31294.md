一道挺奇妙的字符串题目，要你求一个字符串的所有有交集的回文子串有多少对。

统计回文子串的重复情况好像没法在线性时间内做到。

我们可以先用manacher求出回文串个数n。

则答案就是$ C_n^2-$没有交集的回文子串对数。

现在来想想怎么在线性时间内求出没有交集的回文子串对数


可以发现，如果两个回文子串没有交集，那么他们俩一定有一个分割点。

对于一个分割点，他左边的回文子串和右边的回文子串必然都没有交集。

也就是我们对于一个点，要统计有多少回文子串的右端点不超过他，

也要统计有多少回文子串的左端点不超过他。

但是这就够了吗？ 不，我们可以发现上面那种计算方式有大量重复。

为了避免重复，我们只能枚举一遍，分别用结尾在该点的回文子串数量乘以在起点在
该点右侧的回文串的数量，这样就没有重复了，而且能统计到所有无交集回文子串对。

我们设$tou[i]$为以i号点为开头的回文子串数量，$wei[i]$为以i号点结尾的回文子串数量。

现在怎么求tou和wei呢？我们的manacher只能求出每个点的回文半径。

对于i号点为回文串中心时，可以发现产生了很多个回文串

               i-r[i]+1   i    i+r[i]-1
               
               i-r[i]+2   i    i+r[i]-2
               
               i-r[i]+3   i    i+r[i]-3
               
               . . . . . .
               
注意回文半径的定义$i-r[i]$和$i+r[i]$是不同的字符哦。

tou 被从$i-r[i]+1$到$i$ 区间+1 wei 被从$i$到$i+r[i]-1$区间+1

多次区间修改，最后询问一次，这不就是差分+前缀和吗？

注意，现在我们求出来的wei和tou都是被扩展过的字符串的。

最后枚举的时候我们只枚举字符位就好了。因为以字符为开头/结尾的回文子串一定

也会在字符位终止，而原串上的回文子串一定也能对应到扩展串上，占位符不影响。
               
               

用样例举个例子

              0   1   2   3   4   5   6   7   8   9   10

              ^   &   b   &   a   &   b   &   b   &   % 
    
回文半径 r[i]
                     
              \   1   2   1   4   1   2   3   2   1   \
       
以i号点开头的回文串数量tou[i] 差分/前缀和
           
              \   3  -1   0  -1   2  -1   0  -1   0   \
 
              \   3   2   2   1   3   2   2   1   1   \

以i号点结尾的回文串数量wei[i] 差分/前缀和

              \   1   0   1  -1   1   0   1  -1   1   \ 

              \   1   1   2   1   2   2   3   2   3   \


只统计偶数字符位

manacher求出共有6个回文子串

1.分割点在3号 $ wei[2]*tou[4]=1*1=1 $

2.分割点在5号 $ (wei[2]+wei[4])*tou[6]=(1+1)*2=4 $

3.分割点在7号 $ (wei[2]+wei[4]+wei[6])*tou[8]=(1+1+2)*1=4 $

答案为$ C_6^2-(1+4+4)=15-9=6$

大家都懂了吗？下面是代码

```cpp

#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
char a[2200000],s[4400000];
typedef long long ll;
ll p=51123987,sum,maxn,i0,all,r[4400000],tou[4400000],wei[4400000],len,ans,num;
int main()
{
	scanf("%lld %s",&len,a);
	s[0]='^';s[1]='$';
	for(int i=0;i<=len-1;i++)
	    s[2*i+2]=a[i],s[2*i+3]='$';
	s[2*len+2]='%';r[1]=i0=1,maxn=2;
	for(int i=2;i<=2*len+1;i++)
	{
	   r[i]=maxn>i?min(maxn-i,r[2*i0-i]):1;
	   while(s[i-r[i]]==s[i+r[i]])r[i]++;
	   if(i+r[i]>maxn)maxn=i+r[i],i0=i;
	   num=r[i]/2;all=(all+num)%p;
    }//正常manacher 
    for(int i=1;i<=2*len+1;i++)tou[i-r[i]+1]++,tou[i+1]--;
    for(int i=1;i<=2*len+1;i++)wei[i]++,wei[i+r[i]]--;
	for(int i=1;i<=2*len+1;i++)tou[i]+=tou[i-1],wei[i]+=wei[i-1];
//差分与前缀和 
	ans=(all-1)*all/2%p;
	for(int i=2;i<=2*len-2;i=i+2)
	{//注意上面的模拟过程，wei是要记录前缀和的 
		sum=(sum+wei[i])%p; 
		ans=(ans-sum*tou[i+2]%p)%p;
	}
    cout<<(ans%p+p)%p<<endl;
	return 0;
}


```
       
补充：突然想起来，其实我们要求得$tou[i]$和$wei[i]$可以用回文自动机在$O(n)$时间内解出来，具体代码就是回文自动机的模板题目，求的是$wei[i]$。你只要把串倒置一遍就可以求出$tou[i]$了，这样做的好处是省去了差分过程，也不用在原串上加入‘#’占位符,这里就不放代码了，因为思路已经很明确了。
      

