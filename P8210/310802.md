~~赛事压哨过特来水一发题解纪念一下。~~

一道构造。

> 题目大意：给定一个长度为 $n$ 的数组，你可以使用若干个寄存器，里面有互不相同的值，要求构造出一种方案，每次交换两个位置的数（两个位置中至少有一个是寄存器），使最终数组有序，但是要求最后寄存器的值不变。同一对位置只能执行一次操作，要求构造出的方案使用的寄存器数量最少。

我们发现 $k$ 的限制是 $1e6$，而 $n$ 最大是 $1e5$，所以寄存器数量上线肯定不高，否则 $k$ 会变得特别大。

因此，我们可以合理猜测最终答案的 $m$ 是一个常数。

我们发现交换两个位置 $u,v$ 的值需要用到两个寄存器：（假设 $x,y$ 是两个不同的寄存器）

`swap` $(u,x)$

`swap` $(v,y)$

`swap` $(u,y)$

`swap` $(v,x)$

所以只要不是数组原来就有序（那样答案为 $0,0$），那么答案下界就是 $2$，我们能否构造一种方案使得 $m=2$？

答案是肯定的。

我们发现如果把每一个位置上的数最终要去到的位置连一条边，最终会连成若干个环。我们只需要按着环把元素一个一个换下去就好了。

我们发现每一个环之间互相独立，我们只需要保证不对两个寄存器进行操作，就能一直进行下去。

对于一个大小为 $s$ 的环 $d_1,d_2,\dots,d_s$，我们进行这样的操作：

`swap` $(d_1,x)$

`swap` $(d_2,x)$

$\dots$

我们发现这样之后原本在 $d_1$ 的元素就成功归位了，所以我们继续下去。

但如果最后，$x$ 里存的是 $d_1$ 的值，$d_1$ 里面存的是 $x$ 的值，但我们无法再次直接交换两者，所以我们退回一步：

$\dots$

`swap` $(d_{s-1},x)$

`swap` $(d_s,y)$

`swap` $(d_1,y)$

`swap` $(d_s,x)$

这样子就能在保证上述条件的情况下完成一个环的归位。

但是这样会使 $x$ 和 $y$ 里的值交换一下。

所以我们最后判断一下 $x$ 和 $y$ 里的值是否交换过，如果交换过花一次换回来就行了。

因为此题对时间复杂度要求不高，直接报搜 $O(n)$ 就行了。

## code

赛时代码实现比较粗糙吗，看看就好了：

代码里的输出 $m,k$ 被我吃了。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e6+10;
int n,m,k,a[N],st[N],tp,vis[N];
struct upt{
	int x,y;
}ans[N];
void dfs(int x){
	st[++tp]=x,vis[x]=1;
	if(!vis[a[x]])dfs(a[x]);
}
signed main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++)scanf("%d",&a[i]);
	a[n+1]=n+1,a[n+2]=n+2;
	for(int i=1;i<=n;i++){
		if(!vis[i]){
			if(i==a[i])continue;//只有一个就没必要了
			tp=0;
			dfs(i);
			m=2;
			ans[++k]={st[1],n+1};swap(a[st[1]],a[n+1]);
			for(int j=2;j<tp;j++)ans[++k]={st[j],n+1},swap(a[st[j]],a[n+1]);
			ans[++k]={st[tp],n+2},swap(a[st[tp]],a[n+2]);
			ans[++k]={st[tp],n+1},swap(a[st[tp]],a[n+1]);
			ans[++k]={st[1],n+2},swap(a[st[1]],a[n+2]);
		}
	}
	if(a[n+1]!=n+1)ans[++k]={n+1,n+2};
	for(int i=1;i<=k;i++)printf("%d %d\n",ans[i].x,ans[i].y);
}
```