非常精巧的构造。


------------

首先我们发现，如果 $a \leq b$ ，那么一定无解，因为只要 $b$ 中 $a$ 个人假扮 $a$ ，就一定不可能。

那么我们只需考虑 $a>b$ 的情况。因为其实我们只要找出一个诚实的人就可以 $n$ 判断出所有人的答案。


------------

那么问题就变为，怎么 $ n$  次找出一个诚实的人。

我们假设有两个人 $x,y$ ，我们询问 query(x,y) ，我们考虑每种情况的输出答案。

什么情况会输出  ```Y```：1. $x$  真，$y$ 真。2. $x$  假，$y$ 真。3. $x$  假，$y$ 假。

什么情况会输出 ```N``` ：1. $x$  真，$y$ 假。2. $x$  假，$y$ 真。3. $x$  假，$y$ 假。

那么我们发现只要输出  ```N```  ，那么二者一定有一个是假的。

我们考虑用一个栈，每次拿栈顶与下一个数询问，如果是   ```N```  ，就把这两个数都删了，否则就加上。最后栈顶的人一定是诚实的。


------------

考虑正确性，由于 $a>b$ ，而每次删除都至少删一个假的，最后的栈里剩下的人也肯定是诚实的多，而又因为不诚实的人一定只能在诚实的人前面，不然当时就肯定会返回   ```N```  将二者弹出栈。故栈顶一定是诚实的。

然后问题就很好的解决了。


------------

询问次数 $2n-1$。（稍微特判一下可以 $2n-2$ 不过没必要）。 



------------
[代码](https://www.luogu.com.cn/paste/xuz4kzzo)

