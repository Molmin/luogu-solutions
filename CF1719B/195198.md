如果 $4\mid k$，那么 $1$ 到 $n$ 中 $4$ 的倍数只有 $n/4$ 个，显然无法构造。

如果 $k \equiv 2(\bmod\ 4)$，那么我们把所有模 $4$ 余 $2$ 的偶数放前面，所有 $4$ 的倍数的数放后面，把它们和奇数配对即可。具体化地：

- $2 \bmod 4=2$，所以 $2$ 放前面，这样 $(2+k) \bmod 4=(2+2) \bmod 4=0$，于是就有了 $4$ 的倍数。显然在这里放奇数是最优选择，所以匹配之后就是 $(2,1)$。

- $4 \bmod 4=0$，所以 $4$ 放后面，这样就已经有 $4$ 的倍数了，显然放奇数仍然最优，因此是 $(3,4)$。

我们发现每个偶数和它前面那个奇数直接匹配即可。得到代码：

```cpp
for(int i=2;i<=n;i+=4) cout<<i<<" "<<i-1<<endl;
for(int i=4;i<=n;i+=4) cout<<i-1<<" "<<i<<endl;
```

否则，说明 $k$ 一定是奇数。显然，奇数加奇数就是偶数了，偶数至少有一个 $2$，两个偶数乘起来就至少有一个 $4$。所以，我们把奇数放前面，偶数放后面就好了。得到代码：

```cpp
for(int i=1;i<=n;i+=2) cout<<i<<" "<<i+1<<endl;
```

于是把这三种情况拼起来即可。

```cpp
#include <bits/stdc++.h>
using namespace std;
int main(){
	int T; cin>>T;
	while(T--){
		int n,k; cin>>n>>k;
		if(k%4==0) puts("No");
		else{
			puts("Yes");
			if(k&1)	for(int i=1;i<=n;i+=2) cout<<i<<" "<<i+1<<endl;
			else{
				for(int i=2;i<=n;i+=4) cout<<i<<" "<<i-1<<endl;
				for(int i=4;i<=n;i+=4) cout<<i-1<<" "<<i<<endl;
			}
		}
	}return 0;
}
```

p.s. 很简单的思维题，目测难度 `*1300` 以下，但我思考了足足 10 分钟，可以考虑退役了。