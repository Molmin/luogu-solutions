很好的一道同余题。

通过数据范围我们不难发现，构造答案只能 **$O(1)$** 的复杂度才可以，也就是说我们需要提前想好如何构造，不能进行太复杂的运算。

### 构造
所以我们就开始想构造方法，具体来讲就是根据 $k$ 除以 $4$ 的余数构造，在考试期间就意味着找规律，具体如下：
1. 如果 $k$ 除以四余零，那么一定无解。
2. 如果 $k$ 除以四余一或三，那么构造方法就是一奇一偶。
3. 如果 $k$ 除以四余二，那么比较复杂，分为两部分，第一部分是一个奇数和一个四的倍数，第二部分是两个除以四余二的数分一组。

其实到这里就可以开始敲代码了。（不想看证明的可以跳过证明部分）

### 论证
#### 一、$k$ 是四的倍数时无解
$k$ 是四的倍数也就是说 $k$ 对最终的余数没有实质贡献，说白了就是乘了等于白乘。

所以我们要求数对中的两个数中有一个是四的倍数，或者两个都是二的倍数。

但是很显然，$1 - n$ 中奇数个数远远少于四的倍数的个数，也就是说配不成对，即无解。

#### 二、$k$ 除四余一或三可以一奇一偶构造
很显然，余数可以相加，假设这个数对为 $i\times2$，另一个是 $i\times2+1$，那么就有 $i\times 2+k\equiv i\times 2\equiv 0\space\pmod 2$，这时二者的乘积肯定是四的倍数。

#### 三、$k$ 除以四余二可以如上构造
第一种：一个奇数一个四的倍数，这个不用废话了吧。

第二种：一个除四余二的数和另一个除四余二的数很明显也可以。

具体见代码：
```cpp
#include <iostream>
#include <cstdio>
using namespace std;

inline int read() {
	int x = 0, f = 1;
	char ch = getchar();
	while (ch < '0' || ch > '9') {
		if (ch == '-') f = -1;
		ch = getchar();
	}
	while (ch >= '0' && ch <= '9') {
		x = (x << 1) + (x << 3) + (ch ^ 48);
		ch = getchar();
	}
	return x * f; 
}

int t, n, k;

int main() {
	t = read();
	while (t--) {
		n = read(), k = read();
		if (k % 4 == 0) {
			cout << "NO" << endl;
			continue;
		}
		if (k % 2 != 0) {
			cout << "YES" << endl;
			for (int i = 1; i <= n - 1; i += 2) cout << i << " " << i + 1 << endl;
			continue;
		}
		cout << "YES" << endl;
		for (int i = 1; i * 4 <= n; i++) cout << i * 4 - 1 << " " << i * 4 << endl;
		for (int i = 1; i * 4 - 2 <= n; i++) cout << i * 4 - 2 << " " << i * 4 - 3 << endl;
	}
	return 0;
}
//结尾警告：理解思路，杜绝抄袭
```