## CF1556C

首先考虑将括号作为折线，左括号段对应一段斜向上的直线（上坡），右括号向下（下坡）。

像这样:

![1](https://cdn.luogu.com.cn/upload/image_hosting/kls8ha7p.png)

观察这段折线，容易发现一段合法序列，就像上面绿色的一段一样，两端点齐平且为整个绿段的最低的（即中间没有大“山谷”凹下来）。

考虑每个下坡，计算以祂结尾的答案。

对于下坡上每一个点，向右水平碰到的第一个点一定是祂对应的一个右端点。

同时如果碰到的点是拐点（即继续向右不会和轮廓线直接相交而是相切），可以继续向左走。

在折线图上画一画，可以发现一个下坡跟若干个上坡匹配。

![2](https://cdn.luogu.com.cn/upload/image_hosting/hso8kn5n.png)

可以发现，设绿箭头指的山峰高 $h$ ，则不包括空心蓝点的区间有 $h-\max(h-a_i,low)$ ，
其中 $low$ 指前面最低的山谷。

这是第一类贡献，考虑蓝点的贡献。

再看一张图

![3](https://cdn.luogu.com.cn/upload/image_hosting/0mecqfnb.png)


所有空心蓝点都在山谷里

我们从左往右依次看每一个山谷，向右扫到当前考虑的下坡都没有阻拦，即祂后面山谷的海拔都比祂高，且海拔 $\ge$ 下坡右端点，那么祂有 $1$ 的第二类贡献。

可以发现这个能用单调栈维护。

维护一个单增的栈，栈内的元素是可能做二类贡献的点，即扫过的部分中后面山谷的海拔都比自身高的山谷。

扫到一个元素，先算二类贡献答案，即栈内海拔 $\ge h-a_i$ 的元素。

再维护单调栈，发现正好需要弹掉 $> h-a_i$ 的元素。

注意要把海拔相等的点压起来，否则复杂度有问题。

时间复杂度 $O(n)$ 。

---

$\color{orange}{code}\color{green}{:}$

```cpp
//h[i]即海拔。
//st[*].fs:海拔。
//st[*].sc:这个海拔点的个数。
int ans=0;
for(int i=1;i<n;i+=2){
	ans+=h[i]-max(h[i]-a[i+1],st[1].fs);
	while(top>0&&st[top].fs>h[i+1]){
		if(top>1)ans+=st[top].sc;//注意low这个点
		top--;
	}
	if(st[top].fs!=h[i+1])st[++top]=pii(h[i+1],1);
	else ans+=st[top].sc,st[top].sc++;
}
printf(ans);
```
