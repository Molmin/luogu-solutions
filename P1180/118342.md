## 题目概括：
驾驶员要从起点开向终点。中途如果油不够到达下一个加油站会去加油，或有少于总容量的一半，也可能会加油。
加油是要收费的，同时还要叫饭费。
让你求出最少的开销。
驾驶员的车一开始的总容量告诉你了，加油站数告诉你了……万事俱备，只缺思路……。

------------

## 解题思路：
dfs搜索每个加油站，每个有两种选择加油或不加油。 用dfs(当前开销，当前加油站，剩余容量)表示。从起点到第1个加油站，从第1个加油站到第2个……深度优先搜索最小值，将最小值保存在答案中。

------------

## 标准程序：
```cpp	
#include <bits/stdc++.h>
using namespace std;
double ans,cost[10010];
double dis,L,km,first_cost;//总长，总容量，每升行驶km（km），n个加油站，准备工作时的开销，答案。 
int a[10010],s[10010],n;//每个加油站相距路程，每个加油站的价格（我包了）。 
void dfs(double payed,int i,double oil) {//当前开销，当前所在加油站，剩余石油 
	if(payed >= ans) {
		return ;//如果当前开销大雨了历史最小开销，肯定不能成功破纪录。 
	}
	if(i == n + 1) {
		ans = min(ans,payed);//更新历史记录。 
		//我不服，再试一次！（回到上一次的第15或18行if）。 
		return ; 
	}
	if(oil * km >= a[i + 1]) {
		if(oil * 2 >= L){//大于等总容量的一半，等同于oil > L / 2，但是更好地保留了精度。 
			dfs(payed,i + 1,oil - a[i + 1] / km);//不用加油。
			//因为题目中说在油箱里还有不少于最大容量一半的汽油时，驾驶员从不在加油站停下来。 
			//当前开销，油还剩下（当前剩余容量 - 消耗的能量）。 
		}else {
			dfs(payed,i + 1,oil - a[i + 1] / km);//不加油的情况。
			//当前开销，油还剩下（当前剩余容量 - 消耗的能量）。 
			dfs(payed + 20 + (L - oil) * cost[i],i + 1,L -  a[i + 1] / km);//加油的情况。 
			//当前开销 + 饭费 + 加油费，油还剩下（总容量 - 消耗的能量），因为在加油站里充满油了。 
		}
	}else {
		dfs(payed + 20 + (L - oil) * cost[i],i + 1,L - 	a[i + 1] / km);//要加油。 
		//当前开销 + 饭费 + 加油费，油还剩下（总容量 - 消耗的能量），因为在加油站里充满油了。 
	}
}
int main() {
	ans = 10000000.000000;//取最大值 
	cin >> dis >> L >> km >> first_cost >> n;//服务员~点单。 
	for(int i = 1;i <= n;i++) {
		cin >> s[i] >> cost[i];//再来一份 
		a[i] = s[i] - s[i - 1];//要存储的时加油站之间的路程，不是到起点的路程，用这个加油站到起点的距离-上一个加油站到起点的距离=从上一个加油站到这个加油站的距离。
	}
	a[n + 1] = dis - s[n];//将终点也加入加油站，方便操作。 
	//但cost不用赋值，本来初始化就是0。
	dfs(first_cost,1,L - a[1] / km);//深度优先搜索，开始从起点到达第一个加油站，剩余L - a[1] / km（L），开销为first_cost。 
	printf("%.1lf",ans);//嗯……是时候买单了…… 
	return 0;
}
```