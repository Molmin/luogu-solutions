标程用高超的 DFS 技巧像我们展示了重排信息存储方式从而达到简化维护信息的过程。而我们考虑继续沿用树剖的方式维护信息。

考虑一次毛毛虫所覆盖的信息为：
1. 一条链上本身的信息。
1. 链上所有点不再链上的轻儿子。
1. 一些不再链上的重儿子。
1. 链端点的 LCA 的父亲。

其中 $3$ 不超过 $\log$ 个，总体而言，$1$、$3$、$4$ 是比较好维护的。那么重点就来到了如何维护 $2$ 上。

我们考虑从动态 DP 的角度维护这个东西，即对于每条重链分治，而非对于整棵树的 DFS 序或者子树分治。

考虑 $2$ 所具有的重要特殊性质：一定是一条重链的链顶。那么我们可以将这个修改标记先打到其父亲上。即对于所有轻儿子的标记。

考虑到标记是覆盖，我们想办法将标记下放。用二叉树的结构将所有轻儿子维护，将标记下放，那么每次链查询先由上至下将所有链上轻儿子的标记下放，那么此时就可以维护出一个节点及其轻儿子构成的答案。

考虑查询的构成部分：一些重链的节点及其轻儿子信息的区间答案，这个可以用线段树进行维护，注意对于一条重链的链顶和当前查询的轻边转移特判。

那么此时我们已经能够在 $\mathcal O(n\log^{2} n)$ 的时间复杂度对本题进行维护，对每一条重链开数据结构维护区间答案，查询跳的时候特判链顶即可和链尾。

考虑一些更好的优化，其实上面那个算法有很多不好看的地方。

我们考虑将轻重链剖改成虚实链剖。那么这下的毛毛虫信息就比较好看了：
1. 一条链本身。
2. 这条链的所有虚儿子的链顶。

所以我们考虑将标记对应集合的信息分离。本题链修会调用换根。所以考虑将一条实链的信息分为：
1. 链顶及链顶的虚儿子
2. 链尾及链尾的虚儿子
3. 中间部分

那么对于一次修改就可以操作为：对于一条链直接打覆盖标记，其中覆盖标记往下传时对每个轻儿子的传一个链顶修改标记。同时维护链及其轻儿子最大子段和信息及取 reverse 信息。

如此优化，实现复杂度达到 $\mathcal O(n\log n)$。

对于给出的 hard version 也可以维护：

3. 多维护一个链信息。
4. 在 rake tree 上搞一下就行了。