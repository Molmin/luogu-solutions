## 题意：

掷 $n$ 个硬币，每个硬币有 $a_i$ 的概率是正面，求这 $n$ 个硬币中有 $m$ 个是正面的概率。

## 解法：

首先模拟一下：

![](https://cdn.luogu.com.cn/upload/image_hosting/kp1iaauk.png)

图中每个节点旁边括号中的 $(i,j)$ 表示投了前 $i$ 个中有 $j$ 个是正面。

那么这个结构是一棵二叉树，如果暴力枚举每个状态(DFS)的话复杂度是 $O(2^n)$ 的。

但是发现这里有重复的状态，比如 $(2,1)$。这时可以考虑记忆化搜索或者 DP。这里写了DP。

状态是比较显而易见的，$dp_{i,j}$ 表示投了前 $i$ 个中有 $j$ 个是正面的概率。

结合上面图考虑转移，发现一个状态 $(i,j)$ 都会由状态 $(i-1,j)$ 和 $(i-1,j-1)$ 转移过来。它的概率就等于这两个的概率经过转移之后的和。

那么对于 $(i-1,j-1)$，说明这第 $i$ 个投中了，那么投中的概率是 $a_i$，贡献的概率就是 $dp_{i-1,j-1}\times a_i$。$(i-1,j)$ 同理，贡献为 $dp_{i-1,j-1}\times (1-a_i)$。

观察图，初始化 $dp_{0,0}=1$。这道题就解决了。

## 代码：

核心代码：

```cpp
int n,m;
double a[N],dp[N][N];
signed main(){
  int kkk=rd();
  while(kkk--){
    n=rd(),m=rd();
    pfor(i,1,n) scanf("%lf",a+i);
    dp[0][0]=1;
    pfor(i,1,n){
      pfor(j,0,i){
        dp[i][j]=dp[i-1][j-1]*a[i]+dp[i-1][j]*(1-a[i]);
      }
    }
    printf("%.10lf\n",dp[n][m]);
  }
	return 0;
}
```