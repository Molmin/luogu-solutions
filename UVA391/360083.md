## 题目大意

有```\b```、```\i```、```\s```、```\\```、```\*```五个关键字，让你模拟出一段文本经过题目中关键字的功能后的文本。

## 题目思路

我们先了解几个```cin```的成员函数：

```
cin.unsetf(ios::skipws);
```

在读入时忽略空格，也就是说永远读入的不是空格，如果当前输入是空格，则读入下一个非空格字符。

```
cin.putback(c);
```

将当前输入的位置退一个位置，将指定字符放入输入流的当前位置使得可以读入该字符。

接下来，问题就迎刃而解了：

- 忽略读入的空格，每次一个一个字符读入。
- 对于当前读入的字符如果是```\```，再读入一个字符，以便判断是否为关键字，反之，直接输出读入的字符。
- 对于第二个读入的字符，先要判断它是否为```*```，因为这代表着 Mark-up 是否开启，可以用一个变量维护，如果 Mark-up 开启了，再判断这个字符是否为```b```、```i```、```s```，如果为```b```或```i```则直接跳过，如果为```s```会麻烦一点，需要一直输入一个字符，如果是数字则跳过，如果是小数点就要注意了，只会有一个小数点，不存在```\s```后有两个小数点的情况，所以这里也要用一个变量维护，当上面两种情况均不满足时，则把当前读入位置往前一格，如果这个字符不是```b```、```i```、```s```时，直接输出这个字符。
- 对于 Mark-up 没有开启的情况，输出这个当前字符，并把读入位置往前一格。

## 题目代码

```cpp
#include<bits/stdc++.h>
using namespace std;
char s,c;
bool isopen=1;//Mark-up默认开启
int main(){
    cin.unsetf(ios::skipws);//不读入空格
    while(cin>>s){
        bool f=0;//小数点是否超过1
        if(s=='\\'){
            cin>>c;
            if(c=='*'){
                isopen=!isopen;//取反
                continue;
            }
            if(isopen){//如果Mark-up开启了
                if(c=='b'){
                    continue;
                }
                else if(c=='i'){
                    continue;
                }
                else if(c=='s'){
                    while(cin>>c){
                        if(c<='9'&&c>='0'){//数字
                            continue;    
                        }
                        else if(c=='.'&&!f){//小数点
                            f=1;
                        }
                        else{ 
                            cin.putback(c);//往回一个格子
                            break;
                        }
                    }
                }
                else{
                    cout<<c;//直接输出
                }
            }
            else{ 
                cout<<s;
                cin.putback(c);//这里记得往回一个格子
            }
        }
        else{
            cout<<s;
        }
    }
}
```

完美撒花~