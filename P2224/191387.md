题意：给定 $n$ 个物品和两机器，求用机器加工物品的最短耗时。

核心思想：DP

解：

由于题目并未给定加工的顺序，可以把所有共同加工的任务排到一起以规避等待造成的影响。这样，DP 时就无需考虑顺序了。

设 $f(i)$ 为机器 A 加工 $i$ 时间时机器 B 最少加工的时间，则对于每个物品有三种转移：

1. 予 A 加工，有 $f(i)=f(i-t_1)$；
2. 予 B 加工，有 $f(i)=f(i)+t_2$；
3. 共同加工，有 $f(i)=f(i-t_3)+t_3$。

对每个物品对每个值比较三者最小值即可。注意处理的方向应该与状态转移方向相反（从小到大转移，从大到小处理）以保证每个物品仅被计算一次。对于无法加工的情况，将其赋值为极大值 $30001$（因为结果显然小于该值）。

注意要将 DP 数组除第 $0$ 项外初始化为极大值 $30001$。

代码：
```
#include <bits/stdc++.h>
using namespace std;
int n, t[4], sum, a[30001], res=30001;
int main()
{
	ios::sync_with_stdio(false);
	memset(a+1, 30001, sizeof(a+1));//初始化
	cin>>n;
	for(int i=1; i<=n; i++)
	{
		cin>>t[1]>>t[2]>>t[3];
		for(int j=1; j<=3; j++)
			if(t[j]==0)
				t[j]=30001;//变更0
		for(int j=30000; j>=0; j--)
		{
			a[j]+=t[2];
			if(j>=t[1])
				a[j]=min(a[j], a[j-t[1]]);
			if(j>=t[3])
				a[j]=min(a[j], a[j-t[3]]+t[3]);
		}//状态转移
	}
	for(int i=0; i<=30000; i++)
		res=min(res, max(i, a[i]));
	cout<<res;//输出
	return 0;
}
```
