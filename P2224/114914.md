#### Description

> 有 $n$ 个任务，第 $i$ 个任务可以给 A 机器做，用时 $t_1[i]$；给 B 机器做，用时 $t_2[i]$；给 A 机器和 B 机器同时做，用时 $t_3[i]$；求最小用时。当对应 $t[i]=0$ 时，代表不能给这个机器或这两个机器做。

#### Solution

首先考虑暴力 dp，设 bool 数组 $f_{i,j_1,j_2}$ 为执行第 $i$ 个任务时，A 机器已经连续做了 $j_1$ 个时间，B 机器已经连续做了 $j_2$ 个时间，是否存在这么一个节点。

可以从题目中对应的三个方面转移过来：

- 交给 A 机器做：$f_{i-1,j1-t_1[i],j2}$；
- 交给 B 机器做：$f_{i-1,j_1,j_2-t_2[i]}$；
- 交给 A 机器和 B 机器一块做：$f_{i-1,j_1-t_3[i],j_2-t_3[i]}$。

初始化先不考虑了，这种方法肯定超时，已经飙到 $\mathcal O(n^3)$ 了，还带个常数。

因此我们考虑降维，设 $f_{i,j}$ 为执行第 $i$ 个任务时，A 机器已经连续做了 $j$ 个时间，求 B 机器最少连续做了多少个时间。

还可以从三个方面转移过来：

- 交给 A 机器做：$f_{i-1,j-t_1[i]}$；
- 交给 B 机器做：$f_{i-1,j}+t_2[i]$；
- 交给 A 机器和 B 机器一块做：$f_{i-1,j-t_3[i]}+t_3[i]$。

$f_{i,j}$ 就直接从这三个方面取个最小值即可，初值要都设为 $\infty$，除了 $f_{0,0}=0$，最终答案为 $\min\limits_{i=1}^{up}\{\max\{i,f_{n,i}\}\}$。

问题是上面这个程序可能会 TLE 接着 MLE，我们要考虑优化。

优化 MLE：滚存，因为状态方程只从 $i-1$ 转移过来，并且 $j$ 只会从小于等于他的一个数转移过来，因此像 01 背包一样倒着存成一维数组即可。

优化 TLE：上面这个枚举上限 $up$ 如果是 $5 \times n$ 就会坏掉，我们可以在枚举 $i \in [1,n]$ 中考虑 $up \leftarrow up+\max\{t_1[i],t_3[i]\}$，然后直接枚举 $up$ 即可，即设我们枚举到了第 $i$ 个任务，上限应为：

$$up=\sum\limits_{k=1}^i \max\{t_1[k],t_3[k]\}$$

具体细节比较多，放一下代码。

#### Code

```cpp
memset(dp, 0x3f, sizeof(dp));
dp[0] = 0;
for (int i = 1; i <= n; i++) {
	up += max(t1[i], t3[i]);
	for (int j = up; j >= 0; j--) {
		int p = 0x3f3f3f3f;
		if (j >= t1[i]) p = dp[j - t1[i]];
		int q = dp[j] + t2[i];
		int r = 0x3f3f3f3f;
		if (j >= t3[i]) r = dp[j - t3[i]] + t3[i];
		if (t1[i] == 0) p = 0x3f3f3f3f;
		if (t2[i] == 0) q = 0x3f3f3f3f;
		if (t3[i] == 0) r = 0x3f3f3f3f;
		dp[j] = MIN(p, q, r);
	}
}
```