### 题意：
初始 $T_1=T_2=0$。

有 $n$ 组 $t_1,t_2,t_3$，你需要从这三个数中选一个数（如果为 $0$ 表示不能选，保证不全为 $0$）。

- 如果选 $t_1$，$T_1\gets T_1+t_1$。
- 如果选 $t_2$，$T_2\gets T_2+t_2$。
- 如果选 $t_3$，$T_1\gets T_1+t_3$，$T_2\gets T_2+t_3$。

找到一种选择方案，使 $\max\{T_1,T_2\}$ 最小，输出最小值。
#### 数据范围：
$1\le n\le 6×10^3,0\le t_1,t_2,t_3\le5$。
### 思路：
首先一个很明显的 $O(3^n)$ 的爆搜，这里就不说这个方法了，稳 T。

这道题容易想到背包，用 $f_{i,j,k}$ 表示前 $i$ 个产品中有无 A 机器生产 $j$ 个，B 机器生产 $k$ 个的情况。状态转移方程是这样的：（用 $1$ 表示存在，$0$ 表示不存在）
$$f_{i,j,k}=\max\{f_{i,j,k},f_{i-1,j-t_1,k},f_{i-1,j,k-t_2},f_{i-1.j-t_3,k-t_3}\}$$
~~其实有 1 就可以转移，由于想不到好的书写方式，只能用 max~~

这个很好理解，就按题面讲的方法转移就行了，但时间复杂度为 $O(n^3t^2)$（$nt$ 的值域，所以是 $n^2t^2$ 的转移）空间复杂度为 $O(n^3t^2)$（后面两维均是 $nt$），空间与时间均会爆炸，考虑优化。

一个显然的优化就是第一维可以滚掉。

再思考慢在哪里。

不难看出，有很多状态是转移不了的，就像如果有了 $f_{i,3,3}$，$f_{i,3,5}$ 就转不出去了，因为它的这个方案没有 $f_{i,3,3}$ 优。

于是我们就可以只用记 A 机器的所有情况，B 机器的我们只用记 A 机器的所有情况下 B 机器的**最优**时间。这里可以用 $f_i$ 表示 A 机器生产 $i$ 个，B 机器生产最少的个数。（这里把 A 和 B 反过来也可以）此时状态转移方程为
$$f_i=\min\{f_i,f_{i-t_1},f_i+t_2,f_{i-t_3}+t_3\}$$
时间复杂度为 $O(n^2t)$，空间复杂度为 $O(nt)$。

这时候，还是会 T，需要加一个上界优化，每次不从 $nt$ 开始，而是当前最大的值，详情见代码。
### 代码：
```cpp
int n,t1,t2,t3,ans,s=0;
read(n);
while(n--){
	read(t1),read(t2),read(t3);
	s+=max({t1,t2,t3});//上界优化，s 为上界（C++11 新特性）
	for(int i=s;i>=0;--i){
		ans=1e9;//设个极大的数为初值，其实答案是不会超过 30000。
		if(t1&&t1<=i)
			ans=min(ans,f[i-t1]);
		if(t2)
			ans=min(ans,f[i]+t2);
		if(t3&&t3<=i)
			ans=min(ans,f[i-t3]+t3);
		f[i]=ans;
	}
}
for(int i=0;i<=s;++i)
	ans=min(ans,max(f[i],i));//统计每种情况的用时
writeln(ans);
```