# 毒瘤题目
### 1. DP方程

这一题有三个参数，A机器用的时间，B机器用的时间，和第几个物品。

那么三个参数怎么处理呢？首先，一维的数组一定不够，那有人就想要不开三维数组？也不行。第一，超空间，第二，如果三个下标表示三个参数，那数组保存的空间就浪费了。

所以，我们想到用二维数组。

**用dp[i][j]表示第i个物品，A机器用j时间时，B机器用的时间**

所有DP题都是三部曲：表示状态，初始化，转移方程。一旦我们表示好了状态，就开始想转移方程。初始化，因为有Min，所以初始化inf，dp[0][0]=0

```cpp
//借鉴wjyyy大佬的方程：
if(a&&j-a>=0) //用A机器
  dp[i][j]=min(dp[i][j],dp[i-1][j-a]);
if(b)//用B机器
  dp[i][j]=min(dp[i][j],dp[i-1][j]+b);
if(c&&j-c>=0)//用A，B同时加工
  dp[i][j]=min(dp[i][j],dp[i-1][j-c]+c);
```

### 2. 优化

第一，可以发现第i个物品的状态只和第i-1个物品的状态有关，所以可以用**滚动数组**或者背包的思想(逆序)转化到一维。我采用更好理解的滚动数组。

第二，枚举j（使用时间）时的边界不用从0枚举到30000（5*6000）。

首先，在转移完后，如果前k个状态的值都是默认的无限大，意味着这几个状态在下一个物品转移是也无法用到，所以可以调整枚举下限。

其次，枚举的上限就是前i个物品，每个物品最大的时间之和记为sum。因为这样前i个物品所用时间一定不会超过sum。

第三，也是最重要的（我被这个坑了一个上午）。首先要用scanf。其次，**一定要开O2优化！！**

### 3. 代码和细节

```cpp
#include <bits/stdc++.h>
#define maxn 6005
#define inf 0x3f3f3f3f
using namespace std;
int a,b,c,dp[2][30150],sum;
int main()
{
	int n,ans,start,i,j;
	while(scanf("%d",&n)==1)//scanf成功输入几个数返回几
	{               //不加有风险
		sum=0;//初始化
		for(i=1,dp[0][0]=0,start=0;i<=n;i++)//start前边界
		{
			scanf("%d%d%d",&a,&b,&c);
			sum+=max(a,max(b,c));//后边界
			memset(dp[i&1],0x3f,sizeof(dp[i&1]));//i&1=i%1，相当于0,1交替
                        //每次执行前赋值无穷大，防止这一次的状态用到更之前的状态。
                        //比如之前是1，这一次算出来5,6,7，最小的应该是5,但不初始化无限大，结果就是之前算出来的1
			for(j=start;j<=sum;j++)
			{
				if(a&&j-a>=0) 
					dp[i&1][j]=min(dp[i&1][j],dp[(i-1)&1][j-a]);
				if(b) 
					dp[i&1][j]=min(dp[i&1][j],dp[(i-1)&1][j]+b);
				if(c&&j-c>=0)
					dp[i&1][j]=min(dp[i&1][j],dp[(i-1)&1][j-c]+c);
			}
			for(j=start;j<=sum;j++)//扩大前边界
			{
				if(dp[i&1][j]==inf) start++;
				else break;
			}
		}
		ans=0x3f3f3f3f;
		for(i=0;i<=sum;i++)//答案，A和B用时更长的那个
			ans=min(ans,max(dp[n&1][i],i));
		printf("%d\n",ans);
	}
	return 0;
}
```



