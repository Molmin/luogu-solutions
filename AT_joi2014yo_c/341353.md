先来说一下简化题意：

一个人想在一个城市里头玩，这个城市可以看成 $w \times h$ 个单位方块，每个方块的四边都有路，并且还有一条斜着的路从左下连到右上。比如，$w=4$ 且 $h=3$ 时，这个城市是这样的：

![](https://img.atcoder.jp/joi2014yo/2014-yo-t3-fig01.png)

现在这个人有 $n$ 个要去的地方，每个地方用上图所示的数对表示，输入 $w,h,n$ 和这个数对，输出他最少需要走多少才能完成这次旅行。

例：输入：

```cpp
4 3 3
1 1
3 3
4 1
```

输出：

```cpp
5
```

这组样例的意思是，用上图，这个人要去 $(1,1)$，$(3,3)$ 和 $(4,1)$，最少可以先从 $(1,1)$ 一直往右上走 $2$ 个单位路段到 $(3,3)$，然后向下走 $2$ 个单位路段到 $(3,1)$，最后向右 $1$ 个单位路段到终点 $(4,1)$。

第二组样例跟这个差不多，我就不赘述了。

这道题目就是一个简单的[曼哈顿距离](https://baike.baidu.com/item/%E6%9B%BC%E5%93%88%E9%A1%BF%E8%B7%9D%E7%A6%BB/743092)练习题，只需要每一次加上相邻两个输入数对的曼哈顿距离就可以啦。下面是代码：（我没有用 `pair`，可以自行使用 `pair` 做一下，有可能比我做的要快哦）

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
int w, h, n;
ll tot = 0;
int p[1010][2]; // 输入数对

int main(){
    cin >> w >> h >> n;
    for (int i = 0; i < n; i ++) cin >> p[i][0] >> p[i][1];
    for (int i = 0; i < n - 1; i ++){
        int a = p[i][0] - p[i + 1][0]; // 曼哈顿距离里的 x1-x2
        int b = p[i][1] - p[i + 1][1]; // y1-y2
        tot += (a * b >= 0) ? max(abs(a), abs(b)) : (abs(a) + abs(b)); // 如果ab异号才使用曼哈顿距离，否则取max(|a|,|b|)，详细在下面解释
    }
    cout << tot << endl; // 输出
    return 0;
}
```

同号（我们使用 $(1,1)$ 和 $(4,3)$ 为例）：

$|a|$ 在这里其实是向上走需要多少步，$|b|$ 是向右走需要多少步。而 $max(|a|,|b|)$ 我们分几种情况考虑：

- 当一直向上走就可以到达终点：此时不难发现 $a=0$，$b$ 为正，所以答案为 $max(|a|,|b|)=|b|$。
- 当一直向右走就可以到达终点：此时不难发现 $b=0$，$a$ 为正，所以答案为 $max(|a|,|b|)=|a|$。
- 当一址向右上走就可以到达终点：此时不难发现 $a=b$，所以答案为 $max(|a|,|b|)=|a|$ 或 $|b|$。
- 当需要向上向右向右上走到达终点：此时不难发现一直是向上右走的，所以 $a,b$ 均为正，且 $a \ne b$，这时必须三种方向全部用上，所以比较小的那一个是不成立的，需要用到大的那一个。

所以同号的时候结果为 $max(|a|,|b|)$。

这篇题解是我写的时间最长写的最认真的一篇。可能有好多地方我很啰嗦，但是我写的很详细，勿喷，谢谢大家。