这个题有两个重点：  
1. 如何判断一个数字以另一个数字结尾。  
2. 如何从满足的数字中找到最小值。

解决第一个问题有很多种解法，如果你想不到好的解法，至少应该想到求逆序数字时拆卸末尾数字的办法，只不过这次我们需要待比较的两个数字一起拆卸比较：  
```cpp  
//a的长度>=b
bool check(int a,int b) {
    while(b!= 0){
        if(a%10 != b%10)
            return false;    
        else
            a /= 10,b/=10;
    }    
    return true;
}  
```  
如果足够细心，会发现使用这种方案的时候，输入样例中的需求码的长度是用不到的。样例本身也是一种解题思路的提示，很多时候我们可以从样例反推解法，从四则运算的角度来思考，判断 b 是否是 a 的尾数时，可以用相减再取模的办法：  
```cpp  
  (1234 - 34)%100 //返回 0，说明 34 是 1234 的尾数
  (1234 - 123)%1000 //返回非 0，说明 123 不是 1234 的尾数  
``` 
这个解法中模运算的数字和需求码的位数相对应，刚好是每一组需求码输入样例中的第一个数字，比如 2 34 中的2。想要把 2 和 100、3 和 1000 对应起来，可以创建一个工具数组，这个数组的功能是提供“10的数组下标次方”，可以直接用C++中的pow函数求10的n次方：  
```cpp  
for(int i = 1;i<=8;i++)
    b[i] = pow(10,i);  
```  
具体的解法会在后面的完整代码中展示。

解决了第一个问题，我们来解决第二个关键问题：如何找到符合条件的书籍编号的最小值。
这个问题其实并不难，如果你想不到巧妙的办法，你可以用最容易想到的办法：  
1. 设置一个临时变量，初始值为编号范围内的最大值
2. 遍历书籍号，判断某个编号是否以当前需求的数字结尾
3. 如果上一步通过了，再判断该编号是否比临时变量小，如果小的话更新临时变量。
4. 遍历结束后输出临时变量。

具体代码就不写了。我要说的是方案2：
1. 把所有书籍编号一次性排好序
2. 遍历书籍号，判断某个编号是否以当前需求的数字结尾
3. 如果满足那么当前编号就是所有满足编号中的最小值，结束循环。

完整代码如下：  
```cpp  
#include <bits/stdc++.h>
using namespace std;
int n,q,books[1010],b[10],len,need;

int check(){
    //check根据当前的len和need进行检查
    for(int j =1;j<=n;j++){
        if((books[j] - need)%b[len] == 0)
            return books[j];    
    }  
    return -1;     
}

int main()
{

    cin>>n>>q;
    //填充工具数组b
    for(int i = 1;i<=8;i++)
        b[i] = pow(10,i);
    //填充书籍编号
    for(int i =1;i<=n;i++)
        cin>>books[i];
    //对书籍编号整体排序
    sort(books+1,books+n+1);
    //检查每个学生的需求，边输入边判断
    for(int i =1;i<=q;i++){
        cin>>len>>need;
        cout<<check() <<endl;
    }

    return 0;
}  
```  
#### 关爱生命，拒绝抄袭