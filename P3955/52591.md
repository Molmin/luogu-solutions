
这一题，我们首先将书的编号全部读入，存在一个数组里。

接下来我们需要对这个数组进行一个操作，那就是用sort排序，因为题目中说要求符合条件的编号最小的一本书，这样的话，排完序，操作会更方便，在后面就能体现。

排完序，我们采取在线处理，因为如果把需求全部读入后，再做，纯属浪费空间。所以我们边读边做。

那么接下来我们要做的就是把需求编号和书的末尾几个数字进行对比，首先排除用字符去处理的思想，太麻烦了，所以我们采用对数字取模的办法，来处理，也就是说我们如果要取书的编号的后l位，我们只需要将该书的编号对10^l取模即可。

但是如果每次都计算未免显得有些麻烦，所以我们可以用一个m数组去处理，这样就可以了，具体怎么用见代码。

最后，还有一个小技巧，就是说，存在找不到的情况，要输出-1，所以为了避免额外的判断，我们可以将a的初始值设置为-1，这样不用判断直接输出即可。

还有注意找到符合条件的就记录为a，然后break，因为我们只要最小的，这就可见当初排序的方便之处。

下面给代码：


```cpp
#include<bits/stdc++.h>
using namespace std;
int m[8]={1,10,100,1000,10000,100000,1000000,10000000};//传说中的m数组，需要多长的，直接带入下标即可。
int n,q;
int b[1005];//记录图书
int main(){
    scanf("%d%d",&n,&q);
    for(int i=0;i<n;i++){
        scanf("%d",&b[i]);
    }
    sort(b,b+n);//排序
    while(q--){
        int l,n;
        scanf("%d%d",&l,&n);
        int a=-1;      //初始值设置为-1
        for(int i=0;i<n;i++){
            int g=b[i]%m[l];  //直接带入对应的截取长度，这就是m的好处
            if(g==n){
                a=b[i];
                break;         //注意break
            }
        }
        printf("%d\n",a);
    }
    return 0;
}
```