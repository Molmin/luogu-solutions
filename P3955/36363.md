蒟蒻的第一篇Noip题解~

本人今年参加了2017Noip的复赛……那个被虐的惨啊……回过头来看这些题目，真是……不考到200对不起自己（泪奔）

这一道题卡了2个小时……回来以后花了20分钟……为什么……为什么……

作为ZJ的蒟蒻，既然比赛没有了希望，那么就乖乖的为大家献上自己的思路好了，有益于促进共同进步……

----------------------------分割线-----------------------------------

## Part1 首先要确定自己的思路

** 一开始想到的是利用字符串可以排序的特点来读入+排序+判断，这是比较容易跳出来的思路。但是，字符串排序利用的是字典序，但是题目要求则是号码的大小，就是比较数字的大小，那么我们可以选择用int的数组来存放每一本书的号码，然后用sort函数直接升序排序，非常的简单明了。然后开始读入每一个读者需要的书号码的位数以及数字进行一个一个的判断。**

## Part2 然后开始想要如何进行判断

**看到这里相信大家会有一个比较简单的思路，就是可以利用求模来进行判断。没错，利用pow函数计算出读者需要的号码所在的十的某一个幂的范围里，命名为po（这里有些含糊可以去看下面代码），然后for循环从小到大枚举过去判断，如果某一个书号的对po求模的值刚好等于读者所需要的号码，那么直接用ans数组存放这个书的号码，并且break（ans数组要提前赋值为-1哦~可以省不少事）**

## Part3 注意一些小小的格式限制

**没错，这道题在lg上交了两次才过，原因是输出的格式哟！一输出一换行，不能直接输空格……**


## Part4 开始着手构建你的代码吧

全部分析完了以后我们就会有了下面的神奇伪代码

输入n，q

for（1...n）输入书的号码

sort（号码数组[1...n]）

      for(1...q){

输入 位数 ，需要的书的号码

      po = pow(10,位数)

     for(1...n){

if(号码数组[]%po == 需要的书的号码){

             ans[] = 号码数组[]

break

```cpp
                 }
          }
     }
     for(1...q)输出ans输出回车
```
## Part5 把它从伪代码变成编程的代码
有了这么多的分析，那么很轻松的就可以把所有的代码写出来了！


  
```cpp
        for(int j = 1;j<=q;j++){
        scanf("%d %d",&lo,&red);
        po = pow(10,lo); 
        for(int k = 1;k<=n;k++){
            if(bok[k]%po == red) {
                ans[j] = bok[k];
                break;
                } 
        }
    }
```
上面是核心的判断代码，就是对于每一个读者所需要的号码从所有的书号中寻找的过程

----------------------分割线 -------------------------

那么以上就是这道题的基本思路+解题过程了，下面附上代码仅供各位客官参考，请配合注释使用~

//防伪标志，建议Noip 比赛中不要使用万能头文件

```cpp
#include<cstdio>//使用scanf&printf需要调用这个
#include<iostream>//比较基本的库
#include<cmath>//使用pow函数需要调用数学库
#include<cstring>
#include<string>
#include<algorithm>//使用sort函数需要调用本库
#define MAX 1001 //开数组用的，大小根据数据范围变化
using namespace std;
int bok[MAX],red; //bok存放书号，red为读者需要的号码
int lo;//读者需要的号码的长度
int ans[MAX],po; //ans为存放答案的数组
int main(){
    memset(ans,-1,sizeof(ans));//将ans初始化为-1
    int n,q;
    scanf("%d %d",&n,&q);
    for(int i = 1;i<=n;i++)
        scanf("%d",&bok[i]); //以上为最基本的输入
    sort(bok+1,bok+n+1);
    for(int j = 1;j<=q;j++){
        scanf("%d %d",&lo,&red);//获取读者所需要的东西
        po = pow(10,lo); //计算求模的除数
        for(int k = 1;k<=n;k++){ // 暴力枚举进行判断
            if(bok[k]%po == red) {
                ans[j] = bok[k];
                break;//由于已经对bok进行升序排序，找到的第一个即为最小的一个，存储并跳出循环
                } 
        }
    }
    for(int i = 1;i<=q;i++){
        printf("%d\n",ans[i]);
    } //输出
    return 0; //这一句话千万不要忘掉！！
}
```