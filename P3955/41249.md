我相信很多选手在看到这道题的第一反应就是字符串处理


安妮007同学由于犯懒不想写字符串（划掉）所以想到了一种整数处理的方法


主要是通过观察样例发现，如果这本书是被读者所需要的话，那么：


书的编码-读者需求码=balabala...0000


我们注意到应该是有一串0的，0的个数不难发现是最少是读者需求码的长度


这个是满足样例的（如，2123-123=2000，正好有3个0，因为需求码那里正好被减掉了，只剩下一串0~）


用严谨的数学语言来表述一下，就是 W=书的编码，Y=读者需求码，T=读者需求码长度



(W-Y)%pow(10,T)==0;(pow(10,T) 表示10的T次方)

那么我们可以先把这些编码存起来，再按照大小排个升序，每当拿到一个读者需求码的时候，我们从小到大找起，直到找到满足条件的一个数就跳出循环，输入这个满足条件的数。


可行性分析：


算法复杂度在最坏情况下是O（N²）量级，对于1000\*1000的小数据稳过！


对于编码或者需求码都在10,000,000以内，我们甚至都可以使用int计算！


基于以上分析，该算法可行。




需要注意：


1、安妮007在寻找满足条件使用的循环内局部变量，不习惯这么开的朋友注意初始化变量


2、在找到答案之后一定记得break掉


AC代码（仅供参考）：


```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
int w[1007];
bool cmp(int a,int b)//其实这个函数不用也可以，sort默认升序，但是安妮007还是习惯这么写
{
    return(a<b);
}
int index(int d)
{
    int ans=1;
    for(int i=1;i<=d;i++)
    {
        ans*=10;
    }
    return ans;
} 
int main(){
    int n=0,q=0;
    scanf("%d%d",&n,&q);
    for(int i=1;i<=n;i++)
    {
        scanf("%d",&w[i]);
    }
    sort(w+1,w+1+n,cmp);//排序过程
    for(int i=1;i<=q;i++)
    {
        int a=0,x=0,ans=-1;//ans初始值设成-1，没有更新就是没有需要的书，直接输出即可
        scanf("%d%d",&a,&x);
        int y=index(a);//手动写一个int的power函数
        for(int l=1;l<=n;l++)
        {
            if(w[l]>=x&&(w[l]-x)%y==0)
            {
                ans=w[l];
                break;
            }
        }
        printf("%d\n",ans);
    }
    return 0;
}
```