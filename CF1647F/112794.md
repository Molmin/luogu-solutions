显见全部 $a_i$ 中的最大值一定是最后两个最大值中的一个，我们只需要计算另一个最大值的可能取值即可。

假设全部 $a_i$ 中的最大值为 $a_k$，我们现在要判断某个 $a_p$ 能不能成为另一个最大值。不失一般性，我们可以假定 $p < k$（$p > k$ 的情形可以类似地计算）。此时原序列被自然地分成三段：$[1,p)$，$(p,k)$ 以及 $(k,n]$，我们需要分别将这三段中的元素分配给两个序列。

首先来考察 $[1,p)$ 这段元素的分配。可以发现，我们希望尽可能使得这些元素中和 $k$ 同一个序列的最大元素尽可能小，这样最有可能构造出符合条件的序列。可以考虑 DP，设 $f(i)$ 表示将 $a_1\sim a_i$ 划分为两个上升序列，其中不以 $a_i$ 结尾的序列的结尾元素的最小值。转移的时候，如果 $a_i < a_{i+1}$，我们用 $f(i)$ 更新 $a_{i+1}$；如果 $f(i) < a_{i+1}$，我们用 $a_i$ 更新 $a_{i+1}$。

$(k,n]$ 这段元素的分配也类似，我们希望尽可能使得这些元素中和 $p$ 同一个序列的最大元素尽可能小。可以仿照上面的算法同样 DP。注意由于 $k$ 是固定的，所求出来的最大元素也是不变的，下面记为 $a_v$。

接下来解决 $(p,k)$ 之间的元素分配。我们需要找到一个下降序列，所有元素大于 $a_v$、小于 $a_p$；另一个上升序列所有元素大于 $f(p)$、小于 $a_k$。由于 $a_k$ 是原序列的最大值，“小于 $a_k$”这个条件无需考虑。我们再来设计 DP：用 $g(i)$ 表示将 $a_i\sim a_k$ 划分为一个下降序列、一个上升序列，其中下降序列的末尾元素大于 $a_v$，且 $i$ 属于下降序列时，上升序列开头元素的最大可能值；$h(i)$ 表示将 $a_i\sim a_k$ 划分为一个下降序列、一个上升序列，其中下降序列的末尾元素大于 $a_v$，且 $i$ 属于上升序列时，下降序列开头元素的最小可能值。判断是否有 $f(i) < g(i)$ 即可。这两个 DP 值可以从大到小依次递推计算，具体细节略去。

总时间复杂度 $O(n)$。

```cpp
#include<cstdio>
#include<algorithm>

using namespace std;

const int INF=1e9+1;

int a[1000000],f[1000000][2],g[1000000],h[1000000];

int main()
{
	int n=0;scanf("%d",&n);for(int i=1;i<=n;i++)scanf("%d",&a[i]);
	int k=1;for(int i=2;i<=n;i++)if(a[i]>a[k])k=i;
	f[0][0]=f[n+1][1]=-INF,a[0]=a[n+1]=-INF;
	for(int i=1;i<=k;i++)
	{
		f[i][0]=INF;
		if(a[i]>f[i-1][0])f[i][0]=min(f[i][0],a[i-1]);
		if(a[i]>a[i-1])f[i][0]=min(f[i][0],f[i-1][0]);
	}
	for(int i=n;i>=k;i--)
	{
		f[i][1]=INF;
		if(a[i]>f[i+1][1])f[i][1]=min(f[i][1],a[i+1]);
		if(a[i]>a[i+1])f[i][1]=min(f[i][1],f[i+1][1]);
	}
	//for(int i=1;i<=k;i++)printf("%d ",f[i][0]);puts("");
	//for(int i=k;i<=n;i++)printf("%d ",f[i][1]);puts("");
	
	int ans=0;
	g[k]=-INF,h[k]=f[k][1];
	for(int i=k-1;i>=1;i--)
	{
		g[i]=-INF,h[i]=INF;
		if(a[i]<a[i+1])h[i]=min(h[i],h[i+1]);
		if(a[i]>h[i+1])g[i]=max(g[i],a[i+1]);
		if(a[i]>a[i+1])g[i]=max(g[i],g[i+1]);
		if(a[i]<g[i+1])h[i]=min(h[i],a[i+1]);
		if(g[i]>f[i][0])ans++;
	}
	g[k]=-INF,h[k]=f[k][0];
	for(int i=k+1;i<=n;i++)
	{
		g[i]=-INF,h[i]=INF;
		if(a[i]<a[i-1])h[i]=min(h[i],h[i-1]);
		if(a[i]>h[i-1])g[i]=max(g[i],a[i-1]);
		if(a[i]>a[i-1])g[i]=max(g[i],g[i-1]);
		if(a[i]<g[i-1])h[i]=min(h[i],a[i-1]);
		if(g[i]>f[i][1])ans++;
	}
	printf("%d",ans);
}
```

**后记**

~~为啥 CF Div.2 F 的质量比 Div.1 F 还要高了~~