# 狗哥采矿
额。。。~~看不懂题什么意思~~ 感觉挺简单的，其实就是建立一个**像平面直角坐标系**一样的框架，然后坐标轴上矿的最大数量,看dalao们说是```棋盘DP```（好像是的）;

## 基本思路：
#### 状态：
设 ``` f[i][j]``` 为 ```(1,1)``` 到 ```(i,j)``` 的子矩阵中的最大采矿量。
#### 核心思路：
由题意我们可知，如果点 ```(i,j)``` 的传送带向左，**那么点 ```(i,j-1)``` 及其左边一定是向左**，同理，如果  ```(i,j)``` 的传送带向上，**那么点``` (i-1,j) ```及其上边的点,一定也是向上**。
#### 数组：
于是我们可以用前缀和去维护一段区间的采矿量。  
- ```a[i][]```为矿```yeyenum```(第```i```行)**向右（即向西）**的前缀和;(前缀和应该是知道的)
-  ```b[i][]```为矿```bloggium```(第```i```行)**向上（即向北）**的前缀和;

#### 状态转移方程：
在状态转移时，**我们只考虑```(i,j) ```的两种方向**。设``` a数组记录向左``` 的前缀和， ```b数组记录向上``` 的前缀和，那么转移方程为:

$
f[i][j]=max(f[i-1][j]+a[i][j],f[[i][j-1]+b[i][j]);
$

#### 注意：
1. 读入顺序：先 ```yeyenum（向西）后 bloggium （向北）```。
2. 结果 ```（ans）``` 为 ```f[1][1]``` 到 ```f[n][m]``` 的最大值，为了减少一遍搜索时间，**可以在每次状态转移方程后对ans取最大值。**
3. 建议会写快读的写快读，**能减少好几倍的时间**。

## 代码：
#### Code:
```cpp
#include <stdio.h>
#include <cstring>

int f[505][505],a[505][505],b[505][505];
inline int max(int a,int b){
    return a>b?a:b;
}

int read(){
	int a1=0,k1=1;char c1=getchar();
	while(c1<'0'||c1>'9'){
		if(c1=='-')k1=-1;c1=getchar();
	}
	while(c1>='0'&&c1<='9'){
		a1=a1*10+c1-'0';
		c1=getchar();
	}
	return a1*k1;
}

int main(){
    int n,m,ans,x;
    while(1){
    	n=read();m=read();
    	if(!n||!m)break;
        memset(f,0,sizeof(f));
        ans=0;
        for(int i=1;i<=n;++i){
            for(int j=1;j<=m;++j){
            	x=read();
		a[i][j]=a[i][j-1]+x;//向西;
            }
        }
        for(int i=1;i<=n;++i){
        	for(int j=1;j<=m;++j){
        		x=read();
			b[i][j]=b[i-1][j]+x;//向北;
        	}
        }
        for(int i=1;i<=n;++i){
        	for(int j=1;j<=m;++j){
                        f[i][j]=max(f[i-1][j]+a[i][j],f[i][j-1]+b[i][j]);
		        ans=max(ans,f[i][j]);
            }
        }
        printf("%d\n",ans);
    }
    return 0;
}

```

## 原题：
[【洛谷】P2380 狗哥采矿](https://www.luogu.com.cn/problem/P2380)