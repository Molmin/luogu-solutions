~~本蒟蒻~~又双叒叕来写贪心题题解了！！！

先说一个题意方面的易错点，本题要求的是序列 $b$ 中的数替换序 $a$ 中的 0 后的序列是否不为递增序列。所以如果最后是递增序列，输出 `Yes` ，否则输出 `No`。

这次介绍本题的两种方法：

一.搜索

注明：如果想练习搜索再用，并不推荐。

本题如果思考的暴力一点的话，就是把 $b$ 序列中的数填入 $a$ 序列的 $0$ 的所有情况求出来,然后在判断是否满足“不是递增序列”的条件，只要有一个不是，就输出： `yes` 。

但搜索时间复杂度会比贪心时间复杂度大很多，本题是数据小，若数据大一些就过不了，所以不建议使用。

若写搜索的话，代码请参考 [P1036 的题解](https://www.luogu.com.cn/problem/solution/P1036) ，这里就不放代码了。

 二.贪心

首先说一下本题为什么可以使用贪心吧，因为本题只需求出一种把 $b$ 序列中的数填入 $a$ 中，使 $a$ 序列不为递增序列的方案就可输出 `yes` 了。

所以我们只需在填 $0$ 的过程中从大到小填序列 $b$ 中的数字，保证尽可能让填之后的序列不为递增序列，最后记得判断被填后的序列 $a$ 是否为递增序列。

最后， 上贪心代码

code：

```
#include<bits/stdc++.h>
using namespace std;
int cmp(int x,int y){
    return x>y;
}
    int n,k,num;
    int a[110],b[210];
int main(){
    cin>>n>>k;
    for(int i=1;i<=n;i++)
        cin>>a[i];
    for(int i=1;i<=k;i++)
        cin>>b[i];
    sort(b+1,b+k+1,cmp);//从大到小排序列b 
    for(int i=1;i<=n;i++)
        if(a[i]==0)//找序列a中的0，并填入此时b中最大的数字 
            a[i]=b[++num];//num表示此时填了多少个数字了 
    for(int i=2;i<=n;i++)//循环判断序列a是否为递增序列 
        if(a[i]<a[i-1]){//如果不是递增序列 
            cout<<"Yes"; //输出Yes 
            return 0;
        }
    cout<<"No";//如果没结束说明是递增序列，就输出No 
return 0;//完结撒花！ 
}
```