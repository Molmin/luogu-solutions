破环成链。考虑一次询问。

对于没有被任何区间覆盖的位置，它们对答案产生 $1$ 的贡献，这是显然的。扫描线计算这部分的答案。

对于被某个区间覆盖的位置，它们产生贡献的必要条件是为某个区间的左端点，这也是显然的。这使得我们可以将位置对答案的贡献转化为一个区间左端点对答案的贡献。

现在问题来了，一个区间左端点 $l_i$ 对答案产生贡献的充要条件是什么？

首先，这个左端点不能被之前的区间覆盖掉。因此，我们设 $f_i$ 表示上一个覆盖 $l_i$ 的区间，容易线段树维护。

其次，这个区间内所有位置不能被其它区间覆盖掉。因此，我们设 $g_i$ 表示区间所有位置被彻底覆盖掉的时刻。如何维护呢？

设 $v_j$ 表示从当前时刻，位置 $j$ 上的颜料被彻底覆盖掉的时刻，那么有 $g_i = \max_{p = l_i} ^ {r_i} v_p$。然后考虑 $[l_i, r_i]$ 产生的影响。根据实际意义，有 $v_{l_i}\gets g_i$，而 $v_{l_i + 1}\sim v_{r_i} \gets i$，同样线段树维护。

求出 $f_i, g_i$ 之后，可知 $l_i$ 对询问 $[L, R]$ 产生贡献当且仅当 $f_i < L$，$R < g_i$ 且 $L\leq i\leq R$。这是三维偏序，但由于 $R - L + 1$ 为定值，所以 $l_i$ 产生贡献的询问是一段区间，树状数组维护即可。

视 $n, m, k$ 同级，时间复杂度 $\mathcal{O}(n\log n)$。[代码](https://codeforces.com/contest/1764/submission/193007440)。

官方题解太抽象了，说得不是很清楚。

大概理解了一下，就是固定断点 $p$，批量处理所有跨过断点 $p$ 的询问。如何处理呢？一个 set 维护前半部分的连续段 $[*, p]$，另一个 set 维护后半部分的连续段 $[p + 1, *]$。前半部分左端点每次向左扩展 $1$，这个修改是容易处理的。后半部分右端点每次向右缩减 $1$，怎么维护呢？先从 $[p + 1, p + 1]$ 开始，右端点不断向右扩展，记录修改，这样就可以撤销了。每次对任意 set 的修改都可以在另一个 set 通过 $\mathcal{O}(1)$ 次查询得到修改对答案的影响。再加上离散化，单组处理 $\mathcal{O}(k\log k)$。总时间复杂度也是 $\mathcal{O}(n\log n)$。写起来稍微有点抽象，细节一大堆。感觉不如子睿五郎黄的做法。