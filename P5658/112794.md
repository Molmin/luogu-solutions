趁着还没有人发题解，让蒟蒻我来讲讲思路……

首先很自然想到只统计**以某个点结尾的合法括号串的个数**。对于树上的点$i$，不妨记从根节点到$i$的串中，以节点$i$结尾的合法括号串个数为$cnt_i$，则所求$k_i$即为$\sum_{anc\text{是}i\text{祖先}}cnt_{anc}$。

下面考虑$cnt_i$的求法。

记第$i$个点的字符权值为$brc_i$。

若$brc_i='('$，则很明显$cnt_i=0$。

若$brc_i=')'$，可以看出，若能匹配，这个右括号一定和祖先中的某左括号匹配，而且不论在尾部截取的长度，这个左括号是固定的。不妨设这个左括号节点编号为$pos_i$，特别地，当不存在这样的左括号时，令$pos_i=0$。

如果我们求出了$pos_i$，那么可以知道，$cnt_{i}=cnt_{fa_{pos_i}}+1$。因为$i$的右括号要和$pos_i$的左括号匹配，剩下的要么是空串，要么是以$fa_{pos_i}$结尾的合法括号串。接下来讨论$pos_i$的求法。

对于每个$brc_i=')'$：

- 若$brc_{fa_i}='('$，则很明显$pos_i=fa_i$；

- 若$brc_{fa_i}=')'$，令$t=pos_{fa_i}$，若$t=0$，说明$fa_i$匹配不到左括号，那$i$更匹配不到左括号，$pos_i=0$；若$t\neq 0$，则再取$fa_t$，若$brc_{fa_t}='('$，则有$pos_i=fa_t$；否则再取$t'=pos_t$，不断循环往复，直到$t=0$或$brc_{fa_t}='('$为止。

这样就可以求出$pos_i$数组。鉴于时间紧迫，尚未严格证明这个算法是$O(n)$的，如果证出来会及时发出，也欢迎各位大佬在评论区补充。

代码蒟蒻我还没拿到，也懒得再打（其实是怕打错然后发慌），就不贴了。