# 给大家提供两种方法:

## 法1：

问题实际就是给定F束花和V个花瓶，以及各束花放到不同花瓶中的美学值，要求你找出一种摆放的方案，使得在满足编号小的花放进编号小的花瓶中的条件下，美学值达到最大
。
        将问题进行转化，找出问题的原型。首先，看一下上述题目的样例数据表格。
        
将摆放方案的要求用表格表现出来，则摆放方案需要满足：每行选且只选一个数(花瓶)；摆放方案的相邻两行中，下面一行的花瓶编号要大于上面一行的花瓶编号两个条件。这时可将问题转化为：给定一个数字表格，要求编程计算从顶行至底行的一条路径，使得这条路径所经过的数字总和最大(要求每行选且仅选一个数字)。同时，路径中相邻两行的数字，必须保证下一行数字的列数大于上一行数字的列数。

看到经过转化后的问题，发现问题与“数学三角形”问题十分相似，数字三角形问题的题意是：
      
  给定一个数字三角形，要求编程计算从顶至底的一条路径，使得路径所经过的数字总和最大(要求每行选且仅选一个数字)。同时，路径中相邻两行的数字，必须保证下一行数字的列数与上一行数字的列数相等或者等于上一行数字的列数加1。
       
   上例中已经知道：数字三角形中的经过数字之和最大的最佳路径，路径的每个中间点到最底层的路径必然也是最优的，可以用动态规划方法求解，对于“花店橱窗布置”问题经过转化后，也可采取同样的方法得出本题同样符合最优性原理。因此，可以对此题采用动态规划的方法
       
```
#include<iostream>
#include<cstring>
#include<cstdio>
using namespace std;
int main()
{
  int a[101][101],b[101][101],c[101][101],d[101];   //a[i][j] 花束i放在花瓶j中的美学值
                                        //b[i][j] 前i束花放在前j个花瓶中的最优解
                                        //c[i][j] 在b[i][j]的最优解中，花束i-1的位置
  int f,v,i,j,k,max;                         //f , v 花束和花瓶的数目
  cin>>f>>v;
  for (i=1;i<=f;i++)
   for (j=1;j<=v;j++)
cin>>a[i][j];
  memset(b,128,sizeof(b));                  //这样处理，可以保证每束花都放进花瓶
  for (i=1;i<=v-f+1;i++)                    //初始化第1束花放在第i个花瓶的情况
   b[1][i]=a[1][i];
  for (i=2;i<=f;i++)
   for (j=i;j<=v-f+i;j++) 
    for (k=i-1;k<=j-1;k++)                  //枚举花束i-1的位置
     if (b[i-1][k]+a[i][j]>b[i][j])
      {
        b[i][j]=b[i-1][k]+a[i][j];             //更新当前最优解
        c[i][j]=k;                         //前一个花束的位置为k
      } 
      max=-2100000000;
   for (i=f;i<=v;i++)
    if (b[f][i]>max)
     {
       max=b[f][i];                       //选择全局最优解
       k=i;                              //k最后一束花的位置
     }   
    cout<<max<<endl;                     //打印最优解
    for (i=1;i<=f;i++)
     {
       d[i]=k;
       k=c[f-i+1][k];
     } 
    for (i=f;i>=2;i--)
     cout<<d[i]<<" ";
    cout<<d[1]<<endl;
}


```
 ## 法2：
 
 flower一题是IOI99第一天第一题，该题如用组合的方法处理，将会造成超时。正确的方法是用动态规划，考虑角度为一束一束地增加花束，假设用b[i][j]表示1～i束花放在1到j之间的花瓶中的最大美学值，其中i<=j ，则b[i][j]=max(b[i-1][k-1]+A[i][k])，其中i<=k<=j，A[i][k]的含义参见题目。输出结果时，显然使得b[F][k]取得总的最大美观值的第一个k值就是第F束花应该摆放的花瓶位置，将总的最大美观值减去A[i][k]的值即得到前k-1束花放在前k-1个瓶中的最大美观值，依次使用同样的方法就可求出每一束花应该摆放的花瓶号。由于这一过程是倒推出来的，所以程序中用递归程序来实现。 。
 
```
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
void print(int,int);
int max(int a,int b) { return a>b?a:b; }
int a[101][101],b[101][101];
int main()
{
  int f,v;
  cin>>f>>v;
  for (int i=1;i<=f;i++)
    for (int j=1;j<=v;j++)
      cin>>a[i][j];
  memset(b,128,sizeof(b));            //初始化b数组
  for (int i=0;i<101;i++) b[0][i]=0;      //没有放花时，美学值为0。这也是初始化
  for (int i=1;i<=f;i++)
    for (int j=i;j<=v-f+i;j++)
    {
      for (int k=i;k<=j;k++)
	        b[i][j]=max(b[i][j],b[i-1][k-1]+a[i][k]);
 }  
    int c=-1000000;
    for (int i=f;i<=v;i++)
      if (b[f][i]>c)
        c=b[f][i];
    cout<<c<<endl;   
    print(f,c);
}
void print(int i,int j)
{
  int n;
  if (i>0)
    {
      n=i;
      while (b[i][n]!=j)
      {
        n++;
      } 
      print(i-1,j-a[i][n]);
      cout<<n<<" "; 
    }  
}
```
# by  一本通

求过