## 瞎扯部分

这道题卡了我好长时间（我太菜了QWQ）：

瞬间做出3条件发现忘了考虑 $2$ 条件；

然后做2条件发现又忘了考虑 $3$ 条件；

怎么也想不出来了去看题解结果没有看懂，抄上了式子依旧 $\textcolor{red}{WA}$；

最后打算自己想，结果训练时间到了，这道题依旧没想出来 QAQ。

当天晚上在脑子里“脑玩”了几个数据总结出来一个奇奇怪怪的规律，最后竟然 $\textcolor{green}{AC}$ 了。

## 奇怪的正解部分

由于这个矩阵是对称的，我们可以考虑只求出右上那一半然后对称下去（当然求左下也可以 QWQ）。

先不考虑对称后行列不相同的情况：

我把第一行的数按顺序排，然后之后每次就往前挪一个数字，因此第 $1$ 行第 $2$ 列的数是 $1$ （第一列是 $0$ ），之后第 $i$ 行第 $i+1$ 列就应该是第 $i-1$ 行第 $i$ 列的数 $+2$ （因为第 $i-1$ 行第 $i+1$ 列的数是第 $i-1$ 行第 $i$ 列的数加 $1$ ，第 $i$ 行第 $i+1$ 列是第 $i-1$ 行第 $i+1$ 列的数 $+1$ ）。

（别忘了 $\%n!\space$ $\%n$ 后等于 $0$ 要变成 $1$ ！）

然后在考虑对称后的情况：

对称后，第 $i$ 行第 $j$ 列的数就到了第 $j$ 行第 $i$ 列，这时我们考虑那一半中第 $i$ 行的所有数就要和第 $i$ 列的所有数是不同的（应该很好懂吧，想不懂的同学可以往死里想）。这是维护一个二位的 $visit$ 的桶，如果已经填过了就直接加 $1$ 跳过这个数。另外同时也要判断列之间是否重复，也是用 $visit$ 判断并跳过，这样就完成了。

时间复杂度自己算的是 $O(n^2)$ ，应该没算错，$n=1000$ 可以过。

感觉上面讲的不是太好懂，那就贴代码康康吧：
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#define rep(i,a,b) for(int i=(a);i<b;i++)
using namespace std;
int n,nw,j,v[1001][1001],mp[1001][1001];//v是visit，mp是答案
int main(){
	scanf("%d",&n);
	mp[0][1]=-1;
	rep(i,1,n){
		j=i+1;//当前要填的数的第二位
		nw=(mp[i-1][i-1+1]+1)%n;//现在要填的数，+1而不+2是因为循环中有一次加1
		while(j<=n){
			nw++;
			nw%=n;//nw加1，%n
			while(v[i][nw]||v[j][nw]){
				nw++;
				nw%=n;
				if(!nw)	nw=1;//如果变为0就强制变为1
			}//如果跟行有冲突或跟列有冲突就接着加
			mp[i][j]=nw;
			v[j][nw]=1;
			j++;
		}
	}
	rep(i,1,n){
		rep(j,1,n){
			if(j<i)	printf("%d ",mp[j][i]);
			else printf("%d ",mp[i][j]);
		}
		printf("\n");
	}//输出
	return 0;
}
```
感觉代码可能有点 bug（打的有点心浮气躁），希望大家发现能指出QWQ

当然有避免抄袭故意改的 $2$ 处 QWQ

希望看这篇题解的人都能理解并自己做出来