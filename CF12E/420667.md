# 思路

题我就不多说了，大家自己看

看见这个题，我第一反应是为什么 $n$ 必须是偶数，为什么不能是奇数呢。

后来发现，如果 $n$ 是奇数的话这题直接无解，因为无论如何都做不到在满足条件一和条件三的情况下满足条件二（这步自己想，我就不讲了）。最后只能做到两种情况——中轴轴本身不能对称并且中轴上的数字互不相同，或者除了中轴数字全是 0 并且其他都不对称

```cpp
0 1 2
2 0 1
1 2 0

2 1 0
1 0 2
0 2 1

```

那让我们仔细看看第二个矩阵，规律是每行都是上一行的第一个元素挪到了最后一个，这个矩阵好像有可能把这个 $3*3$ 的矩阵转换成一个  $4*4$ 矩阵

先变成这个样子

```cpp
3 2 1 ?
2 1 3 ?
1 3 2 ?
? ? ? ?
```

之后把中轴全填上 0

```cpp
0 2 1 ?
2 0 3 ?
1 3 0 ?
? ? ? 0
```

现在我们会发现，每行每列正好缺少在中轴上的那些被 0 覆盖的数字，而那被覆盖的数字正好互不相同，那么我们就可以把那些被 0 覆盖的数字填到现在问号的位置

那么

```cpp
0 2 1 3 
2 0 3 1
1 3 0 2
3 1 2 0

```

虽然这个结果好像跟样例不太一样

但不是都说了有多个答案吗，只要符合就行，而且这个挺符合的


# AC CODE
```cpp
#include <iostream>
using namespace std;
int n;
int s[1005][1005];
int main()
{
	int i,j;
	cin>>n;
	n--;//先构造奇数列的矩阵，所以n先减一
	for(i=1; i<=n; i++)//先把第一行赋值了
		s[1][i]=i;
	for(i=1; i<n; i++)
	{
		s[i+1][n]=s[i][1];//把上一行的第一个元素挪到最后一个
		for(j=1; j<n; j++)
			s[i+1][j]=s[i][j+1];//其他元素都往前挪一个元素因为第一个元素被移走了
	}
	n++;
	for(i=1; i<=n; i++)
		s[n][i]=s[i][i],s[i][n]=s[i][i],s[i][i]=0;//把中轴的元素挪到两边，中轴添上0
	for(i=1; i<=n; i++)
	{
		for(j=1; j<=n; j++)
			cout<<s[i][j]<<" ";
		cout<<endl;
	}
	return 0;
}
```








