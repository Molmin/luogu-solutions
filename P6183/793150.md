## 法一：深搜

看到数据范围 $n \le 15$，便很容易想到要用搜索，首先把 O 看成 $0$，把 X 看成 $1$，即将其看为一个二进制数，尝试修改这个数，判断是否重复即可。

代码就不贴了，可以参考题解区其他大佬的代码。我主要想说一下第二种方法。

## 法二：用格雷码

首先来道可以参考的 [题](https://www.luogu.com.cn/problem/P5657)，做这道题之前可以先把那道题做完。

格雷码：如果将 $2^n$ 个长为 $n$
 的二进制串组成一个序列，使得将序列按圆形排列时一对相邻的二进制串只有一位不同，则称这些序列为 **$n$ 阶格雷码**或简称**格雷码**。在格雷码中，任意两个相邻的代码只有一位二进制数不同，最大码与最小码之间也仅一位不同，即首尾相连，因此又称**循环码**或**反射码**。

格雷码的生成算法：在刚才所说的那一题中已经明确写出了，这里就不多叙述。

附代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
char a[50000][20] = {};
int n, cnt = 1;
int main()
{
	a[0][0] = 'O';
	a[1][0] = 'X';
	cin >> n;
	for(int i = 1; i < n; i++)
	{
		cnt *= 2;
		for(int j = 0; j < cnt; j++)
		{
			strcpy(a[2 * cnt - j - 1], a[j]);
			a[j][i] = 'O';
			a[2 * cnt - j - 1][i] = 'X';
		}
	}
	for(int i = 0; i < 2 * cnt; i++)
		cout << a[i] << endl;
	cout << a[0] << endl;
	return 0; 
} 
```
