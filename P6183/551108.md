### 题目大意

有 $n$ 个孔，每个孔可以覆盖或开启，求所有覆盖状态。

### 题目分析

本题可以使用递归求解。

首先来想暴力一点的，我们直接枚举每种情况就好了，但是根据题意，我们要顺序输出每个状态，换句话说，就是相邻的两个状态只能有 $1$ 位不同。

于是我们可以回归最开始的思路——递归。我们可以考虑对于每个状态，枚举不同的那一位，然后判断如果改变这位后的状态没经历过就往下走。

不难证明这样找下去一定会找到一组解。

### 优化

- 状态：

最原始的存状态的方法就是用二进制存，我们可以使用数组或字符串，对于重复的情况，可以开 `map` 来记录。

我将在这里补充十进制存储。

我们可以直接将状态中的 `O` 记为 $1$，`X` 记为 $0$，再讲二进制转为十进制存储，然后使用位运算进行原有的二进制操作。

对于输出：我们可以考虑暴力一点的方法，枚举二进制中的倒数第 $i$ 位，对应到十进制中就是 $2^i$，在输出这一位是我们可以将其转换为 `x & (1 << (i-1))`。很容易理解，`&` 符，相同为 $1$，否则为 $0$，`(1 << (i-1))` 中只有第 $i$ 位为 $1$，于是，当 $x$ 的第 $i$ 位为 $1$ 时，返回 $1$，否则为 $0$。

对于更改，可以写成 `x ^ (1 << (i-1))`，同理，异或符号，相同返回 $0$，不同返回 $1$。第 $i$ 位，`1 << (i-1)` 的第 $i$ 位为 $1$，相当于翻转了 $x$ 的第 $i$ 位。对于其他位，`1 << (i-1)` 的其他位为 $0$，相当于 $x$ 的其他位没动。

- 递归：

对于每个状态，我们只需要找到下一个状态就可以了，不用考虑当前状态，所以递归甚至可以优化为 $\operatorname{while}$ 循环，从而节省时间。

理论上来讲，总的时间复杂度都是 $\mathcal O(2 ^ n \times n)$ 的（每个状态 $\mathcal O(n)$ 输出）。

### code
```cpp
#include <iostream>
#include <cstdio>
using namespace std;
int n;
bool cnt[(1 << 15) + 5];
void out(int x)
{
	for(int i = n - 1;i >= 0;i--)
		printf((x & (1 << i)) ? "X" : "O");
	printf("\n");
	return ;
}
bool dfs(int x)
{
	if(cnt[x])	return false;
	cnt[x] = true, out(x);
	for(int i = 0;i < n;i++)
		if(dfs(x ^ (1 << i)))
			return true;
	return true;
}
int main()
{
	scanf("%d", &n);
	dfs(0);
	for(int i = 1;i <= n;i++)
		printf("O");
	printf("\n");
	return 0;
}
```