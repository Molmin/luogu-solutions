这道题在考场上被坑了好几波。

听说有不少人FST了，还好我没有FST。值得庆祝的是本蒟蒻这场比赛加了217分，上绿了。


------------
### 题意：

就是将一个长度为 $n$ 的 $a$ 数组分成 $m$ 个长度为 $n$ 的数组。而且每个数组最多有 $k$ 个不同的数。同时，使这 $m$ 个数组的第 $i$ 位加起来等于 $a_i$ 。问 $m$ 最小是多少？



------------
### 思路：

首先考虑什么时候输出 $-1$，当 $k=1$ 且 整个数组有两种不同的数，那么就输出 $-1$ 。那么除此之外 $k=1$ 时就应该输出 $1$ 。

然后考虑普通的，我们先统计所有不同数字的数量。然后每一轮可以减掉 $k-1$ ，因为我们还需要留一个给不变的（也就是减 $ 0$ 的）用。最后如果数量已经小于 $k$ 了就输出 $ans+1$ ，因为最后一次就可以了。


------------

### 代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,k,t,a[105];
int main() {
	cin>>t;
	while(t--) {
		cin>>n>>k;
		bool f[105];
        int cnt=0;
        for(int i=0;i<105;i++)f[i]=0;//清0
		for(int i=1;i<=n;i++) {
			cin>>a[i];
			if(f[a[i]]==0) f[a[i]]=1,cnt++;//统计数量
		}
		if(k==1&&cnt>1)cout<<-1<<endl;//特判
		else if(k==1)cout<<1<<endl;
		else {
            int ans=0;
            while(1) {
                if(cnt<=k) {
                    cout<<ans+1<<endl;//小于就输出
                    break;
                }
			    cnt=cnt-(k-1);//每次减k-1
                ans++;
            }
		}
	}
}
```
