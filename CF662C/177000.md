结合题意，不难发现**同一行/列进行两次操作等于啥也没干**。

也就是说，对于每一行/列，我们只需要决定要进行 $0/1$ 次操作，即对于每一行/列，我们**只需要决定是否进行翻转操作**。

看一眼数据范围：

$$n\leq 20,m\leq 10^5$$

好耶！行数小于等于 $20$，这不妥妥暴力枚举嘛。QwQ

显然我们通过暴力枚举决定每一行是否翻转就可以在 $O(2^n)$ 的时间复杂度内枚举出仅进行**翻转当前行**的操作所能的得到的所有状态。

但是**翻转当前列**的操作显然是不能直接枚举得到的。

此时我们似乎找不到解决该题的突破点了，于是我们从最质朴的解题方式：暴力，开始进行新的思考。

设第 $i$ 列的状态为 $Line_i$，第 $i$ 列的状态为 $Column_i$，每一个状态都为一个二进制数。

对于“状态”的解释，拿样例来举例子。

```
n=3，m=4

0110
1010
0111
```

我们称第 $1$ 行的状态 $Line_1$ 为 $(0110)_2$，第 $1$ 列的状态 $Column_1$ 为 $(010)_2$。

翻转一行显然会对每一列都产生影响，于是我们开始考虑进行若干次行操作会对每一列产生什么样的影响。

我们设一个 $n$ 位二进制数 $k$，$k$ 的第 $i$ 位为 $1$ 表示我们对第 $i$ 行进行翻转操作，第 $i$ 位为 $0$ 则表示我们对 $i$ 行不进行操作。

还是拿样例进行解释。

$k=(000)_2$ 表示我们对 $3$ 行都不进行翻转操作，$k=(111)_2$ 表示我们对 $3$ 行都进行翻转操作，$k=(011)_2$ 表示我们对第 $2$、$3$ 行进行翻转操作。

我们经过思考便不难发现，对于每一个原来的列状态 $Column_i$，我们在不进行任何**列翻转操作**，进行了若干次**行翻转操作**之后，当前列状态都会变为 $Column_i\text{ xor } k$。

证明也很简单，若我们对第 $j$ 行进行了翻转操作，那么对应的每一列的第 $j$ 位也会被翻转，我们可以利用异或的性质 $\text{1 xor 0=1,1 xor 1= 0}$ 对 $Column_i$ 进行翻转，每当我们翻转了第 $j$ 行的时候，每一个列状态 $Column_i$ 的二进制第 $j$ 位也需要进行翻转，此时我们将 $k_j$ 设为 $1$，即可通过异或将 $Column_i$ 的二进制第 $j$ 位翻转过来。

~~我觉得这应该是这道题最难的地方了，但是似乎其它奆佬们都认为这十分的显然阿……~~

~~是我拉低 OIer 的平均智商了。~~

接下来的部分其实只要对 $FWT_{xor}$ 有较正确且深刻的认识就不难想到了。

设经过若干操作，我们能得到的最少的 $1$ 的个数为 $ans$，对于一个行/列的二进制状态，我们设该状态 $1$ 的个数为 $bit(i)$，且在最初始的状态下，二进制列状态 $Column_i$ 的个数为 $num(Column_i)$。

暴力求解 $ans$ 的思路是十分显然的，我们只需要枚举每一行是否翻转（$k:0\sim 2^n-1$），然后枚举每一种原来的列状态（$state:0\sim 2^n-1$），暴力计算在翻转了若干行的局面下，每一种列状态最少贡献多少个 $1$，对于一种列状态 $Column_i$，它最少贡献的 $1$ 的个数为它 $0$ 的个数和 $1$ 的个数的最小值，即每一种列状态最少贡献的 $1$ 的个数为 $min\_bit(state)=\min(bit(state),n-bit(state))$。

$$ans=\left(\sum\limits_{state=0}^{2^n-1}num(state)\times min\_bit(state\text{ xor }k)\right)_{\min}$$

考虑优化式子。

发现只有一个求和符号，故似乎不可交换求和符号得到进一步推导。

但发现 $num(state)$ 和 $min\_bit(state\text{ xor }k)$ 都可以通过预处理分别存进数组 $num$ 和 $min\_bit$ 中，求和时直接调用两个数组的值即可。

这个时候我们发现什么？

求和过程中调用的两个数组下标异或值固定为 $k$！

更清晰地阐述，即在计算 $num_{state}\times min\_bit_{state\text{ xor }k}$ 时数组 $num$ 和 $min\_bit$ 的下标 $state$ 和 $state\text{ xor }k$ 异或得到的结果为 $state \text{ xor } (state\text{ xor }k)=k$。

学过异或卷积的各位或多或少都能反应过来了吧。

$$ans=\left(\sum\limits_{state=0}^{2^n-1}num_{state}\times min\_bit_{state\text{ xor }k}\right)_{\min}[0\leq k\leq 2^n-1]$$

$$=\left(\sum\limits_{i\text{ xor }j=k}num_i\times min\_bit_j\right)_{\min}[0\leq k\leq 2^n-1]$$

这啥？这不 $FWT$ 板题嘛？

不会 $FWT$ 的建议先看看这个：[P4717 【模板】快速莫比乌斯/沃尔什变换(FMT/FWT)](https://www.luogu.com.cn/problem/P4717)。

那么此时思路就很显然了吧，求异或卷积 $C=num\times min\_bit$。

那么 $C_k=\sum\limits_{i\text{ xor }j=k}num_i\times min\_bit_j$。

直接预处理出 $num$ 和 $min\_bit$，然后跑一次 $FWT$，从 $0$ 到 $2^n-1$ 枚举 $k$ 求 $C_k$ 的最小值即可。

渐进时间复杂度 $O(n2^n)$，能过。

一点小细节：

记得开 ```long long``` QwQ。

详情请见 [this](https://www.luogu.com.cn/discuss/606734)。

代码在上面的帖子里面也有了，这里就不放来占位置了。