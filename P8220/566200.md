## 题目分析：

这道题完美地诠释了，**读题**和**数据范围**是多么的重要。

我们首先看题，知道了几个重要的信息（其实出题的都标出来了）：

1. 他们仅可以在第一象限活动。
2. 任何时候 $x > 0$，$y > 0$。
3. 他们可以上下左右走。
4. 起始点终点纳入计算。

数据范围也说明了，不可能有 $a = 1$ 和 $b = n$ 的情况，也就是起始点上面没有 $B$ 类点。这就排除了很多的可能性了。于是我们有了想法：如果 $c < n$，那么直接往上走到 $(1 , n)$，再走到 $(n , n)$ 便是最优解，路上只有 $A$ 类点；如果 $c \ge n$，那么就计算这条路上的总共的用时就行了。这样做，你就可以得到[这样的结果](https://www.luogu.com.cn/record/72081928)。 

WA 的两个点是什么呢？这就是读题的重要了，题目说了可以在第一象限移动，且数据范围中 $c$ 是可以大于 $n$ 的（这就是前的 $c \ge n$ 的分类讨论），我们又有了一个大胆的想法：何不绕过 $B$ 类点，这样的秒数可能会是最小的。

![图](https://cdn.luogu.com.cn/upload/image_hosting/0ti8jyp0.png)

走法如上，蓝线为直接穿过 $B$ 类点，红线绕路，但是此图的最优解还是直接穿过去。那么答案就出来了，我们把之前的分类讨论改一改，只需要判断，当 $c \ge n$ 时，判断一下，是直接穿过 $B$ 类点的时间短，还是绕路短。代码很好写。

## Code:

```cpp
#include<cstdio>
#include<cmath>
using namespace std ;
long long n , a , b , c ; 
int main(){
	scanf("%d%d%d%d" , &n , &a , &b , &c) ; 
	if(c >= n){
		long long sum = c + n + (c - n + 1) ; //绕路的走法，当时没有化简
		long long ans = n - 1 + (b - a + 1) * 2 + (n - (b - a + 1)) ; //直接穿过 B 类点的走法，无化简
		if(sum > ans) printf("%d" , ans) ; 
		else printf("%d" , sum) ; //判断谁最小
	}
	else printf("%d" , n + n - 1) ; //当 c < n 时的走法
	return 0 ;
}
```
