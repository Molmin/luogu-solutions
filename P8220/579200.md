# P8220题解

## 思路

这题是一道**贪心**题。

我们先假设所有点都是 A 点。那么经过所有点的用时相等，怎么走最近呢？当然是不返回。kid 从 $(1,1)$ 走到 $(n,n)$，最短要经过 $2n-1$ 个点（包括起点和终点）。

现在，我们按照题目叙述的方式，将一些 A 点变成 B 点。可以分为以下几种情况：

- $c<n$
	
	这种情况，B 点没有穿过 Y 坐标为 $1\sim n$ 的区域，kid 可以先从 $(1,1)$ 走到 $(1,n)$，再走到 $(n,n)$，不会经过任意一个 B 点，时间最短。
    
	```cpp
	if(c<n)printf("%lld",n*2-1);
	```
	
	注意：**题目中** $n$ **的范围是** $n\le10^9$**，我们推导的公式** $2n-1$ **的数据范围是** $2n-1\leq2\times10^9-1$，超过了 `int` 的范围，要开 `long long`！

- $n\le c$
	
	这时候就又有两种办法了：
	
	1. 穿过 B 点，到达终点，
		
		**额外**耗时：$b-a+1$ 秒；
		
	2. 绕过 B 点，到达终点，
		
		**额外**耗时：$2(c-n+1)$ 秒。~~（我被这种方法的两个测试点坑了半小时）~~
	
	那么，我们要采取哪种方案呢？**怎样快，怎样走！**
	
	```cpp
	if(c>=n)printf("%lld",n*2+1+(2*(c-n+1)>b-a+1?b-a+1:2*(c-n+1)));//同样，记得开long long。
	```
这题是不是很简单？

## 完整代码

```cpp
#include<cstdio>
int n,a,b,c;
int main()
{
	scanf("%d%d%d%d",&n,&a,&b,&c);
	if(c<n)printf("%lld",n*2-1);
	else printf("%lld",n*2+1+(2*(c-n+1)>b-a+1?b-a+1:2*(c-n+1)));
	return 0;
}
```