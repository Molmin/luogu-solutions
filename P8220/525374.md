### 题意描述
有一个矩阵，一开始每个点都是 $A$ 类点。再给定三个数 $a$，$b$，$c$，如果有一个点 $(x,y)$ 满足 $a\leq x\leq b$ 且 $0<y\leq c$ 时，他就变成了 $B$ 类点。保证所有点都在第一象限内。

kid 现在在 $(1,1)$，他要去终点 $(n,n)$。经过 $A$ 类点需要 $1$ 秒，$B$ 类点需要 $2$ 秒。问耗费的最少时间为多少。

### 解题思路
根据样例，得出 $c$ 可能不小于 $n$，但 $a$ 和 $b$ 都比 $1$ 大。所以我们分下面两种情况讨论：

若 $c<n$，很明显，先从点 $(1,1)$ 走到 $(1,n)$，再走到终点 $(n,n)$，经过的点全部都一定是 $A$ 类点，是最优方案。所以，直接输出 $2n-1$ 即可。

若 $c\ge n$，那么就有两种走法。一种是横向穿越 $B$ 类区域，还有一种是不经过 $B$ 类区域，向上越过它。

第一种走法可以描述为：先从点 $(1,1)$ 走到点 $(1,n)$，再走到终点 $(n,n)$。其中，点 $(a,n)$ 到点 $(b,n)$ 都是 $B$ 类点。所以耗时是 $2n-1+(b-a+1)=(2n+b-a)$ 秒。

第二种走法可以描述为：先从点 $(1,1)$ 走到点 $(1,c+1)$，再走到点 $(n,c+1)$，最后再向下走到终点 $(n,n)$。显然所有点都是 $A$ 类点。点 $(1,1)$ 到点 $(1,c)$ 共耗时 $c$ 秒，从点 $(1,c+1)$ 到点 $(n,c+1)$ 共耗时 $n$ 秒，从点 $(n,c)$ 到点 $(n,n)$ 共耗时 $(c-n+1)$ 秒。所以，共耗时 $c+n+(c-n+1)=(2c+1)$ 秒。

然后比较两种走法，选出其较小值即可。
### 参考代码
```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,a,b,c;
long long ans1,ans2;
int main(){
	cin>>n>>a>>b>>c;
	if(c<n){
		cout<<2*n-1<<endl;
		return 0;
	}
	ans1=2*n+b-a;
	ans2=2*c+1;
	cout<<min(ans1,ans2)<<endl;
	return 0;
}
```