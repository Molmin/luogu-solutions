啊虽然很简单但是坑贼多。

~~比赛一开始以为这是一道天真无邪的 `BFS`~~

在下面的所有示意代码块中，`-`表示 $\texttt{B}$ 类点，`.`表示 $\texttt{A}$ 类点。

不难发现 $\texttt{B}$ 类点一定是一个长方形。

例如这样：

```
. . . . .
. . . . .
. . - - .
. . - - .
. . - - .

n=5,a=3,b=4,c=3示意代码块。
```
然后发现只要不是 $c=n$ 的情况就可以直接以最短路走到 $(n,n)$，答案是 $2 \times n-1$。

在我们仔细观察数据范围之后找到了一个坑。

$1<n<10^9$，$0<c<10^9$；

也就是说 $c$ 可能大于 $n$。

举例：

```
. . - - .
. . - - .
. . - - .
. . - - .
. . - - .

n=5,a=3,b=4,c=5示意代码块
```

所以我们需要把源代码 `c==n` 改为 `c>=n`。

这样就有 $90$ 分的好成绩了。

不过剩下那  $10$ 分在哪里呢？

仔细阅读题面，我们知道了只要在第一象限内移动都是合法的。所以没有必要只在 $n \times n$ 的正方形里面移动。

当 $c<n$ 时，出正方形反而浪费时间。

当 $c>=n$ 时，唯一可能减少时间的方案就是从 $c+1$ 行绕过去。接下来就是推式子然后比大小了。

举例：

```
  - - -
. - - - .
. - - - .
. - - - .
. - - - .
. - - - .
n=5,a=2,b=4,c=6示意代码块

 _______
| - - - |
| - - - |
| - - - .
| - - - .
| - - - .
| - - - .
n=5,a=2,b=4,c=6的一种走法
```
此时左边是 $c$，顶面与右面 $c+1$，总共 $2 \times c+1$。


所有最后就能快乐地写程序啦！

最终程序的主函数：

```cpp
	//;;;;;
	read(n,a,b,c);
	int ans=n+n-1;
	if(c>=n) ans+=b-a+1;
	if(c<n){
		write(ans);
		return 0;
	}
	int tmp=c+n;
	tmp+=c-n+1;
	int k=min(ans,tmp);
	write(k);
```