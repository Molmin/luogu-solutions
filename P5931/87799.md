本文使用大量latex,如果炸了,请看[这里](https://www.luogu.com.cn/training/8647)。

## algorithm

1.一次函数求解析式(建议学习)

2.三分。(与算法3任选一个学习,建议学习算法2)

3.均值不等式,即求分式函数$y=\frac ax+b\times x$的最值。

## solution
会讲得比较慢,所以有些大佬会的部分可以跳过。

一定影子要投在墙上,这样才能使影子更长。但是我太菜了不知道证明。

很显然要设人到灯的距离为x。然后列出关于x的代数式然后求min。

我们发现射出的光线是直线。然后我们现在想求出L。

首先地面上的影子长度很好求,就是(D-x)。然后我们要求出墙壁上的长度,就必须知道高。先求一次函数解析式。

先建立平面直角坐标系,我认为 以地面作为x轴,y轴过灯做x轴的垂线 这个方法最方便,因为任意一关键点(即有用的点)都可以很快的表示成坐标了。

现在找2个点就可以求出解析式。首先,灯的位置很容易求出是(0,H)。人的位置也很容易求出是(x,h)。

然后开始求解析式。设这个解析式为y=ax+b;

列出方程$\begin{cases}H=0\times a+b ①\\h=x×a+b②\\\end{cases}$ 

至于解方程我不在这里解,结果为:$a=\frac{h-H}{x},b=H$

现在我们知道这个光设在墙壁上的坐标为(D,?),要求?,所以把x=D代入。

然后就可以知道坐标为$(D,H-\frac{(H-h)\times D}{x})$

现在我们就列出了代数式:$D-x+H-\frac{(H-h)\times D}{x}$。

然后求这个代数式的最值有2种方法:

方法1:数学,求分式函数的最值。这里我不做演示,具体看[我发的讨论](https://www.luogu.com.cn/discuss/show/217337?page=3),第4条回复。

方法2:三分。

肯定在x向右移时,墙上的影子增长速度特别快,>地面影子减少速度。可一直向右移会发现墙上影子增长越来越慢,到某点=地面影子,然后再向右移就<地面影子减少速度了。我们就是要求这个点。会发现这是单峰的,所以可以三分。

## ac.code
```cpp
#include<iostream>
#include<cmath>
using namespace std;
#define eps 0.000000000001 //精度误差,建议在10~13位小数。视情况而定。
double H,h,D;
double f(double x){ //计算长度。
	return D-x+H-(H-h)*D/x;
}
int Main(){
	cin>>H>>h>>D;
	double l=(H-h)/H*D,r=D,m1,m2; //必须投在墙上,并且最多不能超过房子。
	while(l+eps<=r){ //三分。
		m1=l+(r-l)/3.0;
		m2=l+(r-l)/1.5; //相当于m2=l+(r-l)/3.0*2.0;
		if(f(m1)>=f(m2)){
			r=m2;
		}else{
			l=m1;
		}
	}
	printf("%.3f\n",f(l)); //注意是求长度!!!
	return 0;
}
int main(){ //多组数据我喜欢把main函数写简短。
	int t,i;
	cin>>t;
	for(i=0;i<t;i++){
		Main();
	}
	return 0;
}
```
欢迎提出问题吊打我!