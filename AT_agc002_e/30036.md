
### 1.前置芝士：

博弈论，当然这道题不需要 SG 函数之类的东西

我们只需要知道这样一个**引理**？

对于一场游戏，假设先后手公平，那么一个状态为必胜，当前仅当其能转移的状态有一个为必输，而一个状态为必输，当前仅当其能转移的状态均为必赢。

我们不妨用 $0$ 表示必输， $1$ 表示必赢

### 2.本题如何做？

**$Step1.$转化**

考虑转化问题模型，我们将 $a$ 值排序，我们将这些连续的 $a$ 铺在网格图上，可以得到一个连续的图形，第$i$个矩形的高度为$a_i$

那么初始没有操作我们就在$(1,1)$这个位置

那么两种操作可以分别理解成为你向右/向上走一步

谁先走出去谁输

所以不难发现，边界都是必输$(0)$的状态，接下来有一个比较好玩的性质


**对于任意一个点，它的右上方点的状态与其相同**

#### 证明：

不妨假设此点为$0$且其右上方的点状态为$1$

那么它两边的点应该长这个样子：因为$0$只能走到$1$，所以图应该

$$1~~1$$

$$0~~1$$

我们可以尝试把这张图继续画下去

$$0 ~~1~~..$$

$$1~~1~~1$$

$$0~~1~~0$$

很快你发现矛盾了，这说明好像情况有些不对，所以如果一个点是$0$那么它右上方的点的状态也是$0$

当然对$1$也类似套路就可以推出矛盾，所以我们可以得出结论**对于任意一个点，它的右上方点的状态与其相同**

--------------------------

**$Step2.$解法**

我们考虑先$O(n\log n)$的排序，构造出模型

然后发现$(1,1)$的状态等同于$(2,2)...(x,x)$

于是我们可以$O(N)$的扫一遍，找到边界（即$y=x$这条直线上最外面的点）

然后此点可能可以向上走也可能可以向右走

于是只要判一下两边是否存在$0$就可以知道$(1,1)$的状态了

至于如何判？我们发现最边界一定是$0$（比如这个点最上面和它最右边）

那么因为现在这个点已经是$y=x$的边界了，也就是说它最多长这样：

$x$

$(x)~~x~~x$

于是我们只要判一下与两边的距离$\%2$的值就可以了

```cpp
#include<bits/stdc++.h>
using namespace std;
#define rep( i, s, t ) for( register int i = s; i <= t; ++ i )
#define re register
int read() {
	char cc = getchar(); int cn = 0, flus = 1;
	while(cc < '0' || cc > '9') {  if( cc == '-' ) flus = -flus;  cc = getchar();  }
	while(cc >= '0' && cc <= '9')  cn = cn * 10 + cc - '0', cc = getchar();
	return cn * flus;
}
const int N = 1e5 + 5 ;
int a[N], n ;
bool cmp( int x, int y ) {
	return x > y ; 
}
signed main()
{
	n = read(); rep( i, 1, n ) a[i] = read() ; 
	sort( a + 1, a + n + 1, cmp ) ; 
	int ans ; 
	rep( i, 1, n ) {
		if( a[i + 1] < ( i + 1 ) ) {
			ans = ( a[i] - i ) % 2 ;
			int flag = 0 ; 
			for( re int j = i + 1; j <= n; ++ j ) {
				if( a[j] == ( i ) ) ++ flag ; 
			}
			ans = max( ans, flag % 2 ) ;
			break ;
		}
	}
	if( ans ) puts("First");
	else puts("Second");
	return 0;
}
```