### Preface  
经典博弈论转化为走网格的题目，但是本蒟蒻一开始搞成了删除头尾数目的网格。  
### Problem   
给你 $n$ 堆糖果，两个人轮流吃糖果，有两种吃糖果的方法：  
1.每堆分别吃一个。  
2.吃掉最多的那堆。  
问谁不会吃掉最后一个糖果。  

### Solution  
我们先按常规套路将糖果按数目降序排序，然后我们发现第二种吃糖方法等于直接删除没删除的最前面一堆，第一种方法就是将所有堆全部减一糖果。  

于是我们可以设状态：$G_{i,j}$ 为 $i$ 前面的糖果堆悉数删除，并且所有糖果堆都分别被吃了 $j$ 个糖果后这手能否赢下游戏。  
状态转移方程为 $G_{i,j}\leftarrow(\neg G_{i+1,j})\lor (\neg G_{i,j+1})$

我们现在已经可以利用该状态进行 dp 了，但是这样的时间复杂度过高，我们需要再在状态形成的网格上面找规律。  

众所周知，找规律要从结束状态开始倒退来找，于是我们从最后一堆开始倒退来找规律。最后一堆仅受自己一堆的上面状态影响，所以这是一个交叉的 01 串。  
这时为 0 的状态就会影响前面一堆相同高度的状态，那个状态一定为 1。  
根据归纳法总结，处于同一对角线上的状态其答案一致，于是我们只需要找同对角线上最高的状态就行了，其转移只受上面的一连串与右边的一连串状态影响。这跟其奇偶性相关。  
code：  
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=1e5+10;
int n;int a[N];
int main(){
	ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);
	cin>>n;
	for(int i=1;i<=n;i++)cin>>a[i];
	sort(a+1,a+1+n,greater<int>());
	for(int i=1;i<=n;i++){
		if(i+1>a[i+1]){
			int j=0;
			while(a[i+j+1]==i)j++;
			if(((a[i]-i)%2==1)||(j%2==1))
				cout<<"First";
			else cout<<"Second";
			return 0;
		}
	}
	return 0;
}
```
