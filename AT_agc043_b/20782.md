## AGC043B

赛时做法：

手玩样例 + 合理推理之后，不难发现，$k>1$ 的时候就一定不存在 $3$ 了。也就是说，除了 $N=1$ 的情况，答案只能在 $0,1,2$ 三个数中产生。

那么问题来了：怎么判断是谁呢？

冷静分析之后，我们发现，如果不直接计算出最后是谁，而是排除最后一定不是谁，就能从另一个角度知道结果了。

然后再想想，如果 $\exists x \in[1, N - 1], f(2,x)=1$，则不难发现最后结果一定只能是 $0$ 或者 $1$。考虑 $0$ 和 $2$ 只要碰到 $1$ 就会变成 $1$，也就是说，只要 $1$ 旁边存在 $0$ 或者 $2$， $1$ 就一定会存在。所以，只要不是到了某一层全是 $1$ 的情况，$1$ 就一定会存在。所以 $2$ 就一定不能撑到第 $N$ 层。

然后这时候我们就只需要判定答案是 $1$ 还是 $0$ 了。也就是，我们只需要断定答案的奇偶性就可以了。

不难发现，模 $2$ 意义下，减法等价于加法（单指运算结果）。则可以将原递推式变为：

$$f_{k,x} = f_{k-1, x} + f_{k-1,x+1} \pmod 2$$

不难发现是类似组合数递推的，只不过转移方向反过来而已。利用组合数可以得到：

$$f_{N,1}=\sum_{i=1}^{N} a_i \times \binom{N-1}{i-1} \pmod 2$$

利用 `Lucas` 定理，就能 $O(\log n)$ 快速求解了。

当然，对于 $\bmod\ 2$ 意义下，有 $\binom{n}{m} \equiv[n\ \mathrm{and}\ m=m] \pmod2$。利用这个可以 $O(1)$ 求这个题要求的组合数。

然后再考虑没有 $1$ 的情况：这时候这层中仅可能有 $0$ 和 $2$。在 $\bmod\ 4$ 意义下，此时的减法也等价于加法。不妨将 $a_i$ 除掉一个 $2$ 之后，用求解 $0$ 和 $1$ 的方法来求解 $0$ 和 $2$，这样就解决了这个题了。

```cpp
char s[1000010];

inline int C(int n, int m) { return (n & m) == m; }

int main() {
	int n;
	scanf("%d%s", &n, s + 1);
	if(n == 1) putchar(s[1]), puts("");
	else {
		--n;
		int find1 = 0;
		for(int j = 1; j <= n; j++)
			s[j] = abs(s[j] - s[j + 1]), find1 |= s[j] == 1;
		if(!find1) for(int i = 1; i <= n; i++) s[i] >>= 1;
		find1 ^= 1;
		int t = 0;
		for(int j = 1; j <= n; j++) t ^= C(n - 1, j - 1) * (s[j] & 1);
		cout << (int(t) << find1) << endl;
	}
	return 0;
}
```