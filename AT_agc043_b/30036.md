注意到 $n\ge 2$，所以我们可以给整个序列全体 $-1$，容易发现这对于答案没有影响。

这样的话，问题等价于只有 $0,1,2$，求最后的值。

注意到最后的答案显然也只有 $0,1,2$ 三种。

注意到绝对值可以看作给相邻两项添加符号，正号或者负号

我们不妨看作两边都是正号，然后再把部分位置变成负号。

于是假设最后的序列，$1$ 被加了奇数次，那么答案必然为 $1$，因为无论怎么修改符号，答案的奇偶性不会改变。

然后如果初始序列中同时有 $1,2$ 那么最后的答案肯定不会是 $2$

大概就从 $2$ 开始反推 $2\to (2,0)\to (...)$ 因为 $2$ 必然是由 $2,0$ 产生的，同时 $0$ 只能补充一个和之前相同的数，所以不会出现 $1$ 

所以如果序列中同时有 $1,2$ 且 $1$ 被计算次数为偶数，那么答案肯定是 $0$

否则，如果 $1$ 没有出现过，且 $2$ 被计算次数为奇数，那么答案肯定是 $2$。这是因为修改 $0$ 前面的符号对于答案没有影响，修改 $2$ 前面的符号每次对于答案的变化是 $\pm 4$

所以我们只需要知道，每次操作令 $x_{i,j}=x_{i-1,j}+x_{i-1,j+1}$ 这样操作之后，最后 $1,2$ 的被计算次数即可。

手玩小部分的点会发现，最后的计算次数恰好是杨辉三角。第 $i$ 位会被计算 $\binom{n-1}{i-1}$ 次。

证明的话也非常 naive，可以考虑归纳法。

假设 $x_{k,i} = a\times x_{1,i}+b\times x_{1,i+1}...+z\times x_{1,i+k}$

然后每次合并两项会发现恰好是一个错位相加的形式，加上初始系数是 $1$ 是杨辉三角的第一项，所以最后每个数被计算的次数仍然是杨辉三角。

于是我们的问题只是判断组合数的奇偶性而已了。

考虑 Lucas 定理，注意到 $\binom{n}{m}\equiv 1\pmod 2$ 等价于 $2$ 进制下每一位组合数都是 $1$，所以只能有 $\binom{1}{1},\binom{1}{0},\binom{0}{0}$ 的出现，这等价于 $n\&m=m$

所以我们直接用 $n\& m$ 是否等于 $m$ 来判断组合数的奇偶性即可，复杂度 $O(n)$

$Code:$

```cpp
#include<bits/stdc++.h>
using namespace std ;
#define rep( i, s, t ) for( register int i = s; i <= t; ++ i )
#define re register
int gi() {
	char cc = getchar() ; int cn = 0, flus = 1 ;
	while( cc < '0' || cc > '9' ) {  if( cc == '-' ) flus = - flus ; cc = getchar() ; }
	while( cc >= '0' && cc <= '9' )  cn = cn * 10 + cc - '0', cc = getchar() ;
	return cn * flus ;
}
const int N = 1e6 + 5 ; 
int n, a[N], w[10], bk[10] ; 
char s[N] ; 
signed main()
{
	n = gi(), scanf("%s", s + 1 ) ;
	rep( i, 1, n ) a[i] = s[i] - '1', bk[a[i]] = 1 ; 
	rep( i, 1, n ) if( ( ( i - 1 ) & ( n - 1 ) ) == ( i - 1 ) ) w[a[i]] ^= 1 ; 
	if( w[1] ) { puts("1") ; exit(0) ; }
	if( w[2] && ( !bk[1] ) ) { puts("2") ; exit(0) ; }
	puts("0") ; 
	return 0 ;
} 