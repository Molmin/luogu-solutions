```cpp
/*在火车从起点到终点的所有站点中，停靠的站点的车站级别一定比不停靠的高,设起点为s
，终点为t,如果只有一趟火车，那么所有停靠的站的等级只需要比不停靠的站的最高值多1即可.
如果再增加一趟火车，这趟火车在上一趟火车的起始点之内，那么还要再+1,如果在起始点之外
那么就和一趟火车一样处理
站向可以停靠的站连有向边,然后找到入度为0的点(没有边指向的点),删除这个点和这个点所连
出去的所有路径，路径指向的点的入度-1，当所有入度为0的点（撤销原入度为0后入度变为0在
第一轮不解决）都解决了之后，进行下一轮，进行一轮就累加一下计数器，最后输出结果即可..*/
#include<bits/stdc++.h>
using namespace std;
int bj[100001],n,m,l,a[100001],vis[1001][1001],lu[100001],bj1[100001],b[100001],ans;
int main()
{
	cin>>n>>m;
	for(int i=1;i<=m;i++)
	{
		memset(bj,0,sizeof(bj));//每次标记清零； 
		cin>>l;
		for(int j=1;j<=l;j++)
		{
			cin>>a[j];
			bj[a[j]]=1;//标记停靠的站点； 
		}
		for(int z=a[1];z<=a[l];z++)
		{
			if(!bj[z])//表示没有停靠的站点； 
			for(int j=1;j<=l;j++)
			{
				if(!vis[z][a[j]])
				{
					vis[z][a[j]]=1;//没停靠的站点向停靠的站点连边； 
					lu[a[j]]++;//停靠的站点的等级++； 
				}
			}
		}
	}
	int p=0,flag=1;
	while(p!=0||flag)
	{
		flag=0;//让第一次进来； 
		p=0;
		for(int i=1;i<=n;i++)
		{
			if(!lu[i]&&!bj1[i])//找入度为0的点； 
			{
				b[++p]=i;//记下； 
				bj1[i]=1;//防止有重复的点； 
			}
		}
		for(int i=1;i<=p;i++)
		{
			for(int j=1;j<=n;j++)
			if(vis[b[i]][j])//将它所有能连的点的边都删除； 
			{
				vis[b[i]][j]=0;
				lu[j]--;// 将它所有能连的点的入度--； 
			}
		}
		ans++; 
	}
	ans--;//因为当最后一轮时还会做；
	cout<<ans;
	return 0;
}
```