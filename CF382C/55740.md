## 思维题
------------
本题主要是分类讨论的思想

当$n=1$时，此时一定无解，输出$-1;$

当$n=2$时，最左端和最右端必然有解，此时还需要判断两数之间是否可以插入一个数构成等差数列

当$n\ge3$时，首先从小到大排序，如果可以从中插入一个数（这时一定不是两端），那么两个相邻的数之差$ = $公差的次数会是最多的。只要这个差出现不少于$2$次，这个差就是公差。

 确定公差之后，后面就比较容易了。插入该数的两个相邻数之间的差不可能等于公差，而该数是否合法，可以通过这两个相邻数中较小的一个$+2$倍公差，能否得到较大的数来判断。

 如果插入的数不在中间，那么有可能是无解（输出$0$）或者是从两端插入（输入的序列已经是等差数列）。

  还有一种情况要特别注意，当序列只有$3$个数的时候，并且可以从中插入一个数成为等差数列的情况。此时公差取较小的那个差。例如：$1,2,4$，我们会取$1$作为公差,因为此时可在$2$和$4$之间插入$3$来构成等差数列。
  
 

------------
代码：
```cpp

#include <stdio.h>
#include <algorithm>
using namespace std;
int a[100005];
main(){
    int cnt, n, d, ans, td, td1, c1, c2;
    scanf("%d", &n);
		for (register int i = 1; i <= n; i++) scanf("%d", &a[i]);
        sort (a + 1, a + n + 1);
        d = a[2] - a[1];
        if (n == 1)	puts ("-1");
        else if (a[1] == a[n] && n >= 2)/*常数列*/ printf("1\n%d\n", a[1]);
        else if (n == 2) {
			if ((a[1] + a[2]) % 2)/*判断两数之间是否也可以插入*/  printf("2\n%d %d\n", a[1] - d, a[2] + d);
			else printf("3\n%d %d %d\n", a[1] - d, (a[1] + a[2]) / 2,  a[2] + d);
        }
        else {
			c2 = c1 = 1;
			td1 = a[3]-a[2];
			if (td1 != d) {
				for (register int i = 4; i <= n; i ++){
					int td = a[i] - a[i-1];
					if (td == td1) c2++;
					else c1++;
					if (c1 >= 2 || c2 >= 2) break;//出现次数>=2的差即为整个序列的公差
				}
			}
            if (c2 >= c1 && n >= 3 && d > td1)/*最终确定公差*/ d = td1;
            cnt = 0;
            for (register int i = 2; i <= n; i++) {
			td = a[i] - a[i-1];
			if (d != td) {
				cnt++;
				if ((a[i-1]+a[i]) % 2 || a[i-1]+2*d != a[i]) {
					cnt++;
					break;
                }
            	else ans = a[i-1] + d;
			}
		}
		if (!cnt) printf("2\n%d %d\n", a[1]-d, a[n]+d);//本身已经是等差数列了 
		else if (cnt == 1) printf("1\n%d\n", ans); 
		else puts ("0");//无解 
	}
    return 0;
}

```


