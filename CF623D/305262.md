### 题目大意

一个人将眼睛蒙起来，然后随机游走，每抓住一个人就猜是谁，直到所有人都曾经被猜过一次后，游戏结束，求最小的期望步数。

### Solution

首先可以发现如果钦定游戏至多到第 $k$ 局结束，此时第 $i$ 个人被猜了 $c_i$ 次，一定有对于任意的 $i$ ， $ c_i > 0$， ~~废话~~。假设知道了到第 $k$ 局的时候任意 $c_i$ 的值，那么是否可以试着算出来至多到当前局结束的概率呢？答案是显然的。

因为最晚到当前局就结束了，所以对第 $i$ 个人猜的 $c_i$ 次里边至少有一次猜中了，这个概率直接算不好算，可以反过来算，用 $1$ 减去就行，即 $1-(1-p_i)^{c_i}$  ，容易得到当前的答案，

$$
ans_k=\prod_{i=1}^n1-(1-p_i)^{c_i}
$$

注意这个答案是至多到第$k$局结束的概率，它还包含着之前结束的概率，所以实际上对答案的贡献是$(ans_k-ans_{k-1})\times k$。

接下来的问题就是怎么得到$c_i$ ，很多题解都是用的贪心写法，事实上也是对的，做法就是首先全部猜一遍，因为任意$c_i>0$，所以最优的策略一定会先将所有人猜一遍，接着就每次枚举选择猜哪个人，然后用选择**当前**最优的选择更新答案 。

如果略微思考一下，不得不怀疑这个贪心的正确性，原因在于用当前局面最优解得到全局最优解是否合理，答案是合理，~~不然为什么能A~~，证明如下(借鉴了官方题解)。

假设在第$k$ 步，贪心得到第$i$ 个人被猜了$x_i$ 次，而实际上这一步里边最优的做法是第$i$ 个人被猜了$y_i$ 次，不妨令$p_i=1-p_i$，那么一定会存在两个数$a,b$ 满足以下两个条件
$$
1-p_a^{x_a}>1-p_a^{y_a}
$$
$$
1-p_b^{x_b}<1-p_b^{y_b}
$$

原因在于$\sum_{i=1}^n x_i=\sum_{i=1}^n y_i=k$ ，这个条件实际上还等价于$y_a<x_a\  \&\&\ x_b<y_b$ 。

不妨令$y_a=y_a+1$，那么此时最优解一定还是它，因为$1-p_a^{y_a+1}>1-p_a^{y_a}$，不过它就不满足$\sum_{i=1}^n y_i=k$，所以令$y_b=y_b-1$，那么这个式子虽然值变小了，但是$1-p_b^{x_b}\leq 1-p_b^{y_b}$ 仍然成立，所以这个仍然是最优解，于是就是一直变变变，最后就会发现对于任意的$i$ ，有$x_i=y_i$，证毕。

由于$p_i$是两位小数，所以这个式子收缩的估计会很快，事实的确如此，~~实践证明~~模拟大概$3\times10^5$ 次就够了。

```cpp

#include<queue>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
typedef double db;
db p[110],nowp[110],res;
int main(){
	int n;
	scanf("%d",&n);
	res=1.0;
	for(int i=1;i<=n;i++){
		int x;
		scanf("%d",&x);
		p[i]=nowp[i]=(100-x)/100.0;
		res=res*(1-nowp[i]);
	}
	db ans=res*n;
	for(int i=n+1;i<=3e5;i++){
		int pos=1;db now=res/(1-nowp[1])*(1-nowp[1]*p[1]);
		for(int j=2;j<=n;j++){
			db tmp=res/(1-nowp[j])*(1-nowp[j]*p[j]);
			if(tmp>now){
				now=tmp;
				pos=j;
			}
		}
		ans+=(now-res)*i;
		res=now;
		nowp[pos]*=p[pos];
	}
	printf("%.10lf\n",ans);
	return 0;
}
```
