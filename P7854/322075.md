### 题外话

这题原本的数据范围是 $1\le n\le 3\times 10^3$，值域 $V$ 开到了 $10^{18}$，由于当时的解法无法避免使用 $\gcd$ 函数，时间复杂度为 $O(n^2\log V)$。

不过 @[小粉兔](https://www.luogu.com.cn/user/10703) 审题时一直在研究，当 $V$ 较小时是否存在 $O(n^2)$ 或 $O(n^{2-\text{eps}})$ 的解法。

这启发了我，于是经过一番思考，我便口胡出了一种 $O(n\log n\log V+n\sqrt V)$ 的奇怪解法。

后经 @[小粉兔](https://www.luogu.com.cn/user/10703) 点拨，我们成功将复杂度降至 $O((n+V)\log n+V)$，本题也随之诞生。

本题解法颇多，但由于数据极其难造，故不能保证可以卡掉所有错解，还请大家谅解。

感谢 @[小粉兔](https://www.luogu.com.cn/user/10703) 对加强本题~~以及让我体会到重写一份 5KB 数据生成器的快感~~做出的所有贡献！

---
### 题解

相同权值的节点必定只能形成一个连通块，故只需考虑去重后的节点即可。

**先申明一下：下文中的推理均是在节点去重后的基础上进行的。**

一个**可能不是那么重要**的结论：

- 树的形态是唯一的。

两个**显然**的结论：

- $a_u$ 必为 $u$ 子树中所有节点权值的因数。

- $u$ 子树中不能出现两个节点 $v_1,v_2$，使得 $\gcd(v_1,v_2)>a_u$ 且它们出现在 $u$ 某两个不同子节点的子树中。

**我们可以先建树，再判断是否合法。**

若 $a_{p_1},a_{p_2},\dots,a_{p_k}\ (a_{p_1}<a_{p_2}<\dots<a_{p_k})$ 均为 $a_i$ 的因数，那么能够作为 $i$ 父亲的只可能是 $p_k$。

故可以按照权值从大到小遍历 $a$ 数组，若当前遍历到了 $i$，那么再找到权值为 $a_i$ 倍数、且还未有父节点的所有节点，并将它们的父节点设置为 $i$。

实现过程中，可以记录一个权值所对应的节点编号，接着枚举 $a_i$ 的倍数，看对应的节点是否存在，若存在就看其当前是否有父节点。

排序 + 建树过程的时间复杂度为 $O(n\log n+V\log n)$。

接下来考虑如何判断建出来的树是否合法。

一种朴素的想法是直接枚举 $\text{lca}$ 暴力判断，但这是 $O(n^2\log V)$ 的，显然不能接受。

换个思路，假设建出的树不合法，那么这棵树会有什么性质呢？

为了方便表述，我们称满足题目条件的点对是**友好的**，否则是**不友好的**，同时定义 $l_{i,j}$ 表示 $\text{lca}(i,j)$，$fa_u$ 表示 $u$ 的父节点。

若树**不合法**，那我们必定能找到一个**不为祖孙关系**的点对 $(i,j)$，使得 $i$ 到 $l_{i,j}$ 上的所有点，与 $j$ 到 $l_{i,j}$ 上的所有点两两之间都是友好的，而只有 $(i,j)$ 不友好。

不妨设 $r_1$ 为 $i$ 到 $l_{i,j}$ 这条路径上的某一点，$r_2$ 为 $j$ 到 $l_{i,j}$ 这条路径上的某一点。当然，$(r_1,r_2)\neq (i,j)$。

由于 $(r_1,r_2)$ 是友好的，那么可推得 $\gcd(\dfrac{a_{r_1}}{a_{l_{i,j}}},\dfrac{a_{r_2}}{a_{l_{i,j}}})=1$，记为 ① 式。

又 $(fa_{r_1},fa_{r_2})$ 是友好的，故 $\gcd(\dfrac{a_{fa_{r_1}}}{a_{l_{i,j}}},\dfrac{a_{fa_{r_2}}}{a_{l_{i,j}}})=1$，记为 ② 式。

将 ① 式与 ② 式相除，得到 $\gcd(\dfrac{a_{r_1}}{a_{fa_{r1}}},\dfrac{a_{r_2}}{a_{fa_{r2}}})=1$（注意到这里参与 $\gcd$ 运算的所有分式的值均为整数，故能够保证其正确性）。

相类似地，由于 $(i,j)$ 是不友好的，而 $(fa_i,fa_j)$ 是友好的，那么可推得 $\gcd(\dfrac{a_i}{a_{fa_i}},\dfrac{a_j}{a_{fa_j}})>1$。

说人话，就是如果出现了一个**不为祖孙关系**的点对 $(i,j)$，满足 $\gcd(\dfrac{a_i}{a_{fa_i}},\dfrac{a_j}{a_{fa_j}})>1$，那么这棵树就是**不合法的**。

再稍微转化下。

具体地，对于每个非根节点 $u$，定义 $c_u=\dfrac{a_u}{a_{fa_u}}$。

对于一个质数 $p$，定义 $S_p$ 表示满足 $p\mid c_u$ 的所有结点 $u$ 构成的集合。

那么，建出来的树是**合法的**，当且仅当对于所有质数 $p$，$S_p$ 中的所有节点两两均为祖孙关系。

由于树的深度最多为 $\log V$，故每枚举一个质数 $p$，直接从最深的节点往上遍历，看能否遍历到 $S_p$ 中的所有节点即可。

质数个数为 $O(\frac{V}{\log V})$ 个，遍历一次 $O(\log V)$，则判断部分的时间复杂度为 $O(V)$。

综上，我们便用 $O((n+V)\log n+V)$ 的时间复杂度解决了本题。

代码可读性不高，就不放了。