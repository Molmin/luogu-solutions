前言：


这份代码 RE 了 7 次， WA 了两次，在兔神~~和 UVA 评测机~~的不懈努力下调出了 6+ 个 bug ，于 2021 年 7 月 19 日凌晨 1:54 最终 AC 。


总结：srO 兔神nb Orz。


------------


题目翻译：


有 **T** 组测试数据，每组测试数据中有 **N** 个可能重复的数字，求最长连续不重复片段。~~（这个名字是我编的）~~


思路：


本题输入的数字可能很大，无法直接使用数组进行存储。这个时候我们就需要一个叫做 **map** 的东西。关于它的详细用法可以自行 Baidu First Search ，在此就不赘述了。


简单来说，你可以把它当成是一个可以开非常大下标的数组。


存储完数据之后，我们就可以开始跑核心程序了:（我采用的是一边存储一边处理，代码会相对短一些）


**m** 是一个 **map** 变量，判定当前数字是否出现在当前的连续不重复片段中。如果这个数字之前没有出现，我们就把它加到当前的连续不重复片段当中。


如果出现了，我们就要找到上一次出现是什么时候，将其从我们的不重复片段中去除。值得注意的是，因为要求的是 **连续** 不重复片段，所以上一次出现的数字之前的数字也必须全部去除。 **cnt**  实时存储当前连续不重复片段的长度。



```
if(m[a[i]]==0){
	m[a[i]]++;
	cnt++;
}
else{
	while(m[a[i]]!=0){
		m[a[l]]--;
		cnt--;
		l++;
	}
	m[a[i]]++;
	cnt++;
}
```

正因为上一次出现的数字之前的数字也必须全部去除，所以当前状态不一定是最优解，所以我们需要实时判定 **cnt** 的最长长度，用 **ans** 来保存。


```
ans=max(ans,cnt);
```

进行完上述操作之后，我们就可以将最长长度——即 **ans** 输出了！

```
cout<<ans<<endl;//注意需要endl
```



必须说一嘴，各位大佬的讲解也非常清楚，但是码风可能对某些 OIer 不太友好（比如我），~~喜欢这种码风的大佬们且看且珍惜~~。

代码中有注释：

```
#include<map>
#include<iostream>
#include<cstring>
using namespace std;
int t,ans=0,n,a[10000005];
map <int,int> m;//声明map变量 
int l=1;//注意l初始化不为0 
int main(){
	cin>>t;
	while(t--){
		cin>>n;
		int cnt=0;
		for(int i=1;i<=n;i++){
			cin>>a[i];
			if(m[a[i]]==0){//这个数字没有出现在当前的连续不重复片段中 
				m[a[i]]++;
				cnt++;
			}
			else{
				while(m[a[i]]!=0){//这个数字出现在当前的连续不重复片段中 
					m[a[l]]--;
					cnt--;
					l++;
				}
				m[a[i]]++;
				cnt++;//注意，当前数字被加入了，所以要将长度cnt+1 
			}
			ans=max(ans,cnt);
		}
		cout<<ans<<endl;//注意需要endl
		memset(a,0,sizeof(a));
		m.clear();
		ans=0;
		l=1;
      		//一定要记得初始化
	}
	return 0;
} 
```
如果有不懂的或者 hack 代码，欢迎私信或者评论。

（孩子凌晨写的代码，差点猝死 bushi ，求过）