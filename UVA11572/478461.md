### 题意：
找最长的**无重复数**的**子段**。
### 思路：
双指针。

定义两个指针 $l$ 和 $r$。

显然，如果 $[l,r]$ 是合法的，且如果 $a_{r+1}$ 没有出现过， 那么 $[l,r+1]$ 显然要好一些。

所以我们可以从位置 $1$ 开始，看 $a_{r+1}$ 是否在 $[l,r]$ 出现过。出现过就用 $r$ 向外拓展，否则就把 $l$ 指针指向 $a_{r+1}$ 在 $[l,r]$ 中出现的位置加 $1$（因为不能有重，所以要再加 $1$）。

如果暴力查找 $a_{r+1}$ 在 $[l,r]$ 中的位置最坏是 $O(n^2)$ 的，所以需要优化。

这里用 hash 可以做到单次查找 $O(1)$，总复杂度 $O(n)$。
### 代码：
~~有些懒~~代码中用 `unordered_map` 实现 hash。
```cpp
read(T);
while(T--){
	unordered_map<int,int>m;
	read(n);
	ans=0;
	l=1;
	for(int i=1;i<=n;++i){
		read(x);
		if(m[x])
			l=max(l,m[x]+1);
		m[x]=i;
		ans=max(ans,i-l+1);
	}
	write(ans,"\n");
}
return 0;
```
