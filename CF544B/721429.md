# 前言

这道题非常有思维含量，我足足 $\verb!WA!$ 了三次才 $\verb!AC!$！！！

# 题目描述

给定 $n$ 和 $k$，求在 $n\times n$ 的矩阵中能否填出 $k$ 座岛。$S$ 表示海，$L$ 表示岛，当一个或多个 $L$ 被 $S$ 围起来就叫做一个岛。

# 思路

还是那句话，不要被样例迷惑了！！！

我们可以先根据 $n$ 和 $k$ 来判断是否可以填出 $k$ 个岛。

岛的个数越大越好，要保证最大，我们可以交替来填充。

画个图来找找规律：

当 $n$ 为奇数

例如 $n = 5$：

我们可以画出下面这张图

LSLSL

SLSLS

LSLSL

SLSLS

LSLSL

注意：以下式子如果不懂可直接跳至“发现的规律”一段。

发现一三五行 $L$ 的数量为 $3$，也就是 $5/2+1$。

一共有三行的 $L$ 的数量为 $3$，也就是 $5/2+1$。

结合起来，也就是 $(5/2+1) \times (5/2+1)$。



发现二四行 $L$ 的数量为 $2$，也就是 $5/2$。

一共有两行的 $L$ 的数量为 $2$，也就是 $5/2$。

结合起来，也就是 $(5/2) \times (5/2)$。

把二者相加，就是 $9+4 = 13$。


再举个例子吧，例如 $n = 7$：

根据我们的公式，容易得出 $L$ 的个数为 $25$。


当 $n$ 为偶数

例如 $n = 4$：

我们可以画出下面这张图

LSLS

SLSL

LSLS

SLSL



发现每行 $L$ 的个数都为 $2$，也就是 $4/2$。

一共有 $n$ 行，那么 $L$ 的个数轻松得出来是 $2n$，也就是 $8$。



再举个例子吧，例如 $n = 6$：

根据我们的公式，容易得出 $L$ 的个数为 $18$。


发现的规律？


如果 $n$ 为偶数时，发现每行都有 $n/2$ 个 $L$ 和 $n/2$ 个 $S$，所以当 $n$ 为偶数时，$L$ 的个数为 $n^2/2$。

如果 $n$ 为奇数时，发现除去最后一个字符，其他字符两两一组，每个小组里都有一个 $L$ 和一个 $S$，例如下图：

LSL

SLS

LSL

第一二个字符一组，第三四个字符一组，第五六个字符一组，第七八个字符一组，第九个字符单独一组。

所以当 $n$ 为奇数时，$L$ 的个数为 $n^2/2+1$。



于是我们可以轻松判断是否能填充出 $k$ 个岛屿。

如何实现填充岛屿？

我们可以定义一个 $cnt$，表示现在填充了多少个岛屿。

定义一个 $t$，表示现在该填充海还是岛屿。

如果 $t$ 是偶数，就填充一个岛屿，否则填充海。

注意行与行之间的判断。

# 上代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
	//定义
	 
	int n,k,i,j,cnt,t,is;
	
	//输入
	 
	cin>>n>>k;
	
	//判断是否能填充 k 个岛屿，推导过程在前文。 
	is = (n%2==0)?n*n/2:n*n/2+1;
	if(k>is)//如果超出了填充限制,输出 NO。 
		return printf("NO\n"),0;
	else//否则输出 YES，并开始填充。 
	{
		printf("YES\n");
		//这两个变量意义参见前文。 
		cnt = 0;
		t = 1;
		for(i=1;i<=n;i++)
		{
			t += (n%2==0);//注意此时的判断，不然就无法达到两行交替输出的需求，参见下面
			/*问题的严重性 
			LSLSL
			LSLSL
			LSLSL
			LSLSL
			LSLSL
			*/ 
			for(j=1;j<=n;j++)
			{
				t++; // t 每次加一，交替的输出。 
				if(t%2==0&&cnt<k)//如果要填岛且还能继续填
					printf("L"),cnt++;//填充一个岛屿，且 cnt + 1。
				else//否则要不是填满了，要不是本该填充海 
					printf("S");//不管什么原因，都填充海洋。 
				
			}
			puts("");//换行 
		}
	}
	return 0;
}
```