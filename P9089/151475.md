先把所有串翻转。对 $n$ 个串建 AC 自动机，那么每个子串合法的条件等价于把这个子串拎出来在 AC 自动机上走，除了起点以外没有走到 $0$。证明可以考虑调整，讨论一下每步是否沿着 Trie 边走。

由于数据水，赛时直接写暴力即可通过，而且可以获得最优解。事实上 $n=1$ 一个长度较大的全 `a` 的串就可以卡飞。

考虑什么时候会走到 $0$。假设对于一个串，起点为 $l$，但在走到节点 $r$ 时走到了 $0$，我们希望计算 $l$ 的范围。我们在 fail 树上从 $1\to r$ 走到的节点开始往上跳父亲，那么跳到 $0$ 的时候应该是满足 $r-l+1<len$，其中 $len$ 表示最上面一个非 $0$ 祖先状态的长度。

也就是每个 $r$ 对应的会到 $0$ 的 $l$ 是一段区间，那么就是每次对一段区间取 $\min$，最后查询每个位置的值。

用堆或 set 或并查集或你喜欢的数据结构维护。时间复杂度 $O(c\sum |S|+\sum |S|\log \sum |S|)$，其中 $c$ 为字符集大小。