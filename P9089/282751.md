官方题解。


### subtask1

暴力即可。

### subtask2

显然所有字符串都可以表示出来。

### subtask3

$n=1$
 
留给一些贪心。 
 
### subtask4，5


下文未说明均是对于每个串分别考虑答案。

注意到对于每个 $i$ 可以预处理 $f_i$ 表示 $S_{f_i...i}$ 是以 $i$ 为右端点中最长的一个可以被表示为其中一个后缀的，则左端点在 $[f_i,i]$ 之间的子串均可以表示为其中一个后缀。也就是说，$f_i$ 具有单调性。

因此可以二分 $f_i$，存下每个后缀的哈希值，看是否跟有 $[f_i,i]$ 相同哈希值的，根据 check 复杂度在 $O(|S|^2)$ 到 $O(|S| \log |S|)$ 不等，如果想要通过本题全部测试点，可以使用 `map` 判断，复杂度 $O(|S| \log^2 |S|)$。

考虑如何不重的 dp，一种办法是，对 $f_i$ 进行一点微妙的改动，在一遍求 $f_i$ 后，如果存在 $j<i,f_j \le f_i$ 就把 $f_i$ 改变为 $j+1$，就是说再往后可以拿 $j$ 去替代 $i$。这样一来，记 $ans_i$ 表示以 $i$ 结尾的有价值子串数量，有 $ans_i=ans_{f_i-1}+(i-f_i+1)$。

通过一些简单的数据结构技巧，可以在一个 $\log$ 的复杂度内完成一个 $f_i$ 的更新，所以不影响复杂度。

### subtask 6

如果你会 SAM，SA 之类的后缀数据结构，可以直接做到 $c \sum |S|+\sum |S| \log \sum |S|$ ，$c$ 为字符集大小。~~但是超纲了。~~

考虑 $f_i$ 变化之后的性质，我们相当于去除了所有 $[f_i,i]$ 相交的部分，因此有任意两个 $[f_i,i]$ 不交或包含。据此提出一个更快的算法
：

从左往右考虑，维护当前没有被覆盖的 $[f_i,i]$ ，假设当前考虑到一个 $i$，往前扫未覆盖的连续段，因为不存在相交，所以只有目前的 $[f_i,i]$ 覆盖原来的或者停在某个地方不动，中间未被覆盖的可以暴力往前扫，具体可以参考代码实现。

分析复杂度，每个连续段只会被删一次，每个未被覆盖的地方也只会被扫一次，瓶颈在于查询一个子串，所以复杂度为 $O(\sum |S|\log |S|)$。当然 std 通过挂链哈希能做到线性，不过不在本题考察范围之内。