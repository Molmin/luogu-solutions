我们考虑什么样的情况没有环。

首先，有一个性质是这样的：对于任意的 $i(i\geq 3)$，如果 $a_i$ 是前 $i$ 个数中的最大数或最小数，就必定没有环。

如果证明呢？我们考虑反证法。

假设对于任意一个 $z(z\geq 3)$ 如果它不是前 $z$ 个数中的最大数或最小数的话，就必定有一个 $x$ 是最小的满足 $a_x<a_z$ 的数，$y$ 是最大满足 $a_y>a_z$ 的数。那么 $x \leftrightarrow z,y \leftrightarrow z$。

下面，我们分情况讨论：

- 如果 $x>y$，那么 $y$ 必定为最大的满足 $a_y > a_x$ 的数，因为 $a_y > a_z$ 然后 $a_z > a_x$；

- 如果 $x<y$，那么 $x$ 必定为最小的满足 $a_x < a_y$ 的数，因为 $a_x < a_z$ 然后 $a_z < a_y$。

证毕。

然后我们考虑这样的序列有多少种，我们这么考虑，第 $n$ 个数可能是 $1\sim n$ 中的最大数或最小数。

- 如果是最大数，那么剩余的数为 $1\sim n-1$；
- 如果是最小数，那么剩余的数位 $2\sim n$。

我们把剩下的数想象成一个双端队列，问题等价于让你求这个队列让你从左边取或右边取，一共有多少种取法。

我们每次可以从左边取或右边取，一共去 $n$ 次，所以答案为 $2^n$。

所以，这题的答案为总的排列数 $n!$ 减去不合法的排列数 $2^n$。

```cpp
const ll mod=1e9+7;
ll pw(ll x,ll y){
	ll ans=1;
	while(y){
		if(y&1)ans=ans*x%mod;
		y>>=1;
		x=x*x%mod;
	}return ans;
}
int work(){
	ll n,ans=1;read(n);
	for(int i=1;i<=n;i++)ans=ans*i%mod;
	ans=(ans-pw(2,n-1)+mod)%mod;//防止负数
	cout<<ans<<endl;
	return 0;
}
```