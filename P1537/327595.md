# 分析
本题要求出能否将弹珠平均分配，也就是能否拿出一些弹珠是总数的一半，可以理解为求多重背包方案数，只是方案数只需要1就行

# 实现（多重背包）
时间复杂度明显过高，我们得用优化，先把多组背包转换成01背包，将其转成$log_2N_1+......+log_2N_6$个弹珠：

```

for (int i=1;i<=6;i++){
	x=a[i];//上面输入过a[i]
	v+=x*i;//顺便为下面求弹珠总价值
	t=1;//从1开始枚举2的整数幂
	while (x>=t){//如果t>x就不能做了不然能表达的数会超过a[i]
		b[++n]=t*i;//价值是价值为i的弹珠分到的个数乘上i
		x-=t;
		t*=2;
	}
	if(x)b[++n]=x*i;//如果下x最后没变用完，还要加一个x
}//这样可以求出每一个原来能求出的数


```

我们算一下时间复杂度，每组数据是$O(vlog_2v)$这里$v$指的是弹珠总价值,$log_2v$只是近似值，准确是上面写的弹珠的个数$log_2N_1+......+log_2N_6$

## 康康代码（ _很简单_ ）：

```
#include<bits/stdc++.h>
using namespace std;
int f[60005],a[10],b[1000],n,v,k,x,t;
int main()
{
	#ios::sync_with_stdio(false);
	cin>>a[1]>>a[2]>>a[3]>>a[4]>>a[5]>>a[6];
	while (a[1]||a[2]||a[3]||a[4]||a[5]||a[6]){//判断如果都是0就结束
		n=v=0;
		k++;
		for (int i=1;i<=6;i++){//上面解释过了
			x=a[i];
			v+=x*i;
			t=1;
			while (x>=t){
				b[++n]=t*i;
				x-=t;
				t*=2;
			}
			if(x)b[++n]=x*i;
		}
		if(v%2){//如果v是单数肯定不行
			printf("Collection #%d:\nCan't be divided.\n\n",k);
			cin>>a[1]>>a[2]>>a[3]>>a[4]>>a[5]>>a[6];//退出前一定要输入下一组数据不然会无限循环
			continue;
		}
		v=v>>1;//v除以2，只有能求出总价值的1/2就能分成2半
		f[0]=1;
		for (int i=1;i<=n;i++){//遍历每一个物品(弹珠）
			for (int j=v;j>=b[i];j--){
				if(f[j-b[i]])f[j]=1;//如果j-b[i]能被组成，加上b[i]后j也能被组成
			}
		}
		if(f[v]){//如果v能被组成就可以求出总价值的1/2
			printf("Collection #%d:\nCan be divided.\n\n",k);
		}
		else{//如果不能就无法达到目的
			printf("Collection #%d:\nCan't be divided.\n\n",k);
		}
		cin>>a[1]>>a[2]>>a[3]>>a[4]>>a[5]>>a[6];//输入下一组数据
	}
	return 0;
}

```


就这样了。
#### 备注：
 _~~希望管理大大通过（但是不通过也很好理解。。。。。。水平不行，RP不够，只是想提交题解，根本没想通过。当然，通过最好啦！！！）~~_ 