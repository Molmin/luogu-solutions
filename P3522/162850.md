这是一篇较详细的**单调队列**解法题解 !

首先,我们要求出**最长**的**连续的一段**并且**不下降**的温度

相信大多数人看到要求的和我一样一脸懵 *

~~好了,回归正题~~

假设我们现在有一段连续且不下降的序列

那么经过分析我们可以知道:**只有这段序列中每天的最高温度大于这段序列中最大的最低温度**才能满足**不下降**

在这里,我们把这些连续天数中最低温度最大的那个放在队头,这样的好处就是:我们新入队的那一天的最高温度要和队头的最低温度比较,若小于队头那一天的最低温度,说明不能满足**不下降**,若大于说明可以添加

好了,只说原理相信很多像我一样的蒟蒻还是不明白,下面我们以样例为例子手动模拟一下:

这里我们定义: `l: 头指针, r: 尾指针 len: 最长连续不下降天数`

首先第一个元素入队,队列中记录对应的天数

|1  |  |
| :----------- | :----------- |

入队后,队列只有一个数1,代表第一天

此时 l = r = 1, len = 1

然后第二个元素入队比较,很明显第二天的最高温度小于队头的最低温度,说明第一天和第二天不能满足**不下降**的要求,但我们依然要入队,这是为什么呢?我来解释一下,大家可以思考,若第二天不入队及时后面的再入队,第一天和后面的也不能满足**连续**的要求,所以我们这里选择入队,但不会再去考虑第一天的温度

| 1 |2  |  |
| :----------- | :----------- | :----------- |

若不考虑第一天,我们要进行 l++
入队后 r++, 此时 l = r = 2, len = 1

下一步把第三个元素进行比较,很明显满足要求可以入队,但这时根据我上面所说的,我们总是把这段连续天数中最大的最低温度放在队头,所以我们可以得到入队后的情况:

|  1| 3 |  |  |
| :----------- | :----------- | :----------- | :----------- |

这时我们可以发现把之前的2覆盖了,那么这时候我们应该怎么计算天数呢?

我们可以思考:既然这段连续天数中最大的最低温度放在队头,那么队头的前一位肯定不在这段序列中,并且它应该是这段序列中开始满足要求的那天的前一天(这里2就是这段序列开始满足的第一天,而1则是2的前一天)

所以: `len = i-q[l-1]`

接下来的几天没有什么要注意的地方,我们只需要把第三天这里我们要注意的理解,那么就可以理解下面的代码

~~害,终于结束了~~

下面就是代码实现环节 ~~(码风较丑还请担待)~~

```cpp

#include <iostream>
#include <cstring>
#include <cstdio>
#include <algorithm>
#include <cmath>
 
using namespace std;

typedef long long ll;
const int N = 1e6 + 5;

int n;
int a[N], b[N], q[N];

int main() {
    cin >> n;
    for(int i = 1; i <= n; i++) {
        cin >> a[i] >> b[i];
    }
    int l = 1, r = 0, ans = 0, len;
    for(int i = 1; i <= n; i++) {
        while(l <= r && a[q[l]] > b[i]) l++;  //若第i天最高温度小于队头最低温度
        if(l > r) len = 1;
        else len = i - q[l - 1];
        ans = max(ans, len);	//记录最大天数
        while(l <= r && a[q[r]] < a[i]) r--;  //把这段序列中最大的最低温度放在队头
        q[++r] = i;  //入队
    }
    cout << ans << endl;
    return 0;
}
```
