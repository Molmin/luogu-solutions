考虑设 $f_{i,j}$ 表示将前 $i$ 个数分成 $j$ 段的最小值，可以直接 $O(n^2k)$ 暴力转移。

但是转移当中含有 $\max$ 使得转移方程不美观。

考虑设 $f'_{i,j}$ 表示将前 $i$ 个数划分成 $j$ 段，最后一段的最大值必须是 $i$ 的最小贡献。（注意 $i$ 不一定是最后一段的结尾，后面也有可能接东西但是这里在 $\rm Dp$ 中不考虑）

那么设 $ls_i,nx_i$ 分别表示 $i$ 左边，$i$ 右边第一个比 $i$ 大的值，枚举上一个最大值 $k$，需要满足 $\max(a_i,a_k)\geq\max_{k<j<i}\{a_j\}$，讨论 $a_i$ 与 $a_k$ 的大小关系，有转移：

1.$a_i\leq a_k$：
$$f_{i,j}\leftarrow f_{k,j-1}+(a_i-ls_i)\times a_i+(ls_i-k)\times a_k$$

2.$a_i > a_k$：
$$f_{i,j}\leftarrow f_{k,j-1}+(i-nx_k+1)\times a_i+(nx_k-1-k)\times a_k$$

就是把 $(k,i]$ 这个区间考虑分给 $i,k$ 的最优分法。

然后这个东西是可以用李超线段树来维护的，具体的，维护两棵李超树，一棵是上面的转移，一棵是下面的转移。

维护上面的转移的部分相当于是维护一个单调栈的答案，可以用支持回退的李超树来做。

维护下面的转移的部分相当于是维护一段 $i$ 的后缀，但是我们可以维护一个李超树的合并，把单调栈这一次被弹掉的部分全部与 $i$ 的李超树合并起来，当以后 $i$ 被合并的时候就接着合并下去，这样复杂度是 $O(log n)$ 的，所以这个做法的总复杂度是 $O(nk\log n)$ 的。

代码有点难写就咕了，不过做法应该是没有什么太大问题的，欢迎各位指出问题。