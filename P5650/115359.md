这道题明显是道dp（~~大眼观察法~~），不过为什么叫**基础字符串练习题**?


------------
进入正题

题目：

给定长度非$0$的非空$01$串$S$。

找出$S$的非空连续子串$T$满足串中$0$的个数-$1$的个数最大。

接下来开始分析：

这题的状态和最大子序列的状态一样

我们设$dp[i]$表示以字符串$S$中第$i$个字符结尾的子串$T$的最大值

举个例子：

| S | 0 | 1 | 0 | 1 |
| :----------: | :----------: | :----------: | :----------: | :----------: |
| i | 1 | 2 | 3 | 4 |
| dp[i] | 1 | 0 | 1 | 2 |

那么转移方程是什么呢？

若$S[i]=1$
	
此时$dp[i]$可以接上一个$dp[i-1]$:$dp[i]=dp[i-1]-1$

但如果$dp[i-1]=-1$那还不如再新开一个串：$dp[i]=-1$

综上：$dp[i]=max(dp[i-1]-1,-1)$

若$S[i]=0$

此时$dp[i]$可以接上一个$dp[i-1]$:$dp[i]=dp[i-1]+1$

但如果$dp[i-1]=-1$那还不如再新开一个串：$dp[i]=1$

综上：$dp[i]=max(dp[i-1]+1,1)$

两种情况下的转移方程推出来了，代码自然就写出来了。

**不过，注意dp[n]不一定是最大的，需要用ans来找dp[i]中的最大的**

**还要注意！ans初始化不要为0，答案有可能为-1**

std:

```cpp
#include <iostream>

using namespace std;

char a;
int dp[100000000];
int ans=-10;
int main()
{
    int i=0;
    while(cin>>a)
    {
        i++;
        if(a=='0')
        {
            dp[i]=max(dp[i-1]+1,1);
        }
        if(a=='1')
        {
            dp[i]=max(dp[i-1]-1,-1);
        }
        ans=max(ans,dp[i]);
    }
    cout<<ans;
    return ^_^;
}

```
