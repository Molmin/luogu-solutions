# 0.题外话qwq

看大家都没有使用双向BFS的解法，本蒟蒻就发一发吧qwq。

# 1.主要思路

因为我们知道题目给出了 $s$ 和 $t$ ，给出了起始条件和终止条件，也就是说，我们可以在**给定起点和终点**的情况下，进行双向BFS。

而且，还有一系列的变换条件，这都可以写成**每次扩展新结点**的形式，从而BFS。

# 2.双向BFS是什么？

双向BFS，顾名思义，就是这是以**两个方向BFS的**。一般从起点和终点开始遍历，使用**两个**队列扩展，如果有一棵搜索树里出现了另一棵搜索树的结点，就代表**有一种方案**使得可以找到答案，且是**最优解**，即这个**交点**所在的**从起点到终点的这么一条路径**就是**最优解**。

放张图证明双向BFS是怎么个双向搜索的：

![image.png](https://i.loli.net/2020/04/19/Mb3GsaFo9v2ewQJ.png)

这样可以把时间压缩到原来的 $\frac{1}{2}$ ，甚至更优！

代码可以这么实现：

```cpp
建立并初始化两个BFS队列q1,q2;
建立两个标记数组b1,b2;
while(!q1.empty()&&!q2.empty())
 扩展q1
  如果q1的合法扩展有q2的节点
   输出起点到这个点的距离和终点到这个点的距离；
 扩展q2
  如果q2的合法扩展有q1的节点
   输出起点到这个点的距离和终点到这个点的距离；
```

这样会大大减少程序的时间。

# 3.有一些问题

Q1：我的BFS如何扩展？

A1：可以循环 $6$ 次，每次对应一个值——如 $i=1$ 时新扩展的节点就增加 $1$，$i=2$ 时新扩展的节点就增加 $2$ 等。

Q2：如何判重？

A2：可以给每一个起始值/终止值加上一个固定的数，比如 $50$ ，这样就不会出现负数判重等问题。

# 4.部分代码

```cpp
Fu(i,1,6)
{
	Fu(j,0,1)
	{
		int nxy=q[j].front();
		if(i==1)++nxy;
		else if(i==2)nxy+=5;
		else if(i==3)nxy+=10;
		else if(i==4)--nxy;
		else if(i==5)nxy-=5;
		else if(i==6)nxy-=10;
		if(nxy>100||nxy<0)continue;
		if(b[j][nxy])continue;
		q[j].push(nxy);
//		printf("%d %d %d\n",i,j,nxy);
		b[j][nxy]=1;
		st[j][nxy]=st[j][q[j].front()]+1;
		if(b[!j][nxy])return st[j][nxy]+st[!j][nxy];
	}
}
```

然后就是注意细节方面的问题，就A了。