一个蒟蒻的歪门邪道的BFS

代码里u和s的用法就写在这里：以样例一为例，压入7后压入6 8 2 12 -3 17再弹出7，此时队内有6个元素，s=6,以这六个元素向6个方向搜索后u=6，则第一批搜索的6个元素都被使用了，则均弹出后队内剩下的是第二批搜索后的元素，u清零，s=第二批搜索后元素个数，一直操作到找到答案

温馨提示：输出答案后一定要换行！！（当我没换行时听到WA声一片是震惊的）



------------
 
 
AC代码如下：

```cpp
#include<bits/stdc++.h>//万能头好！（其实是我懒得记那么多头文件）
using namespace std;
int main()
{
  queue<int> q;     //使用队列
  int a,b;     //a为初始温度，b为目标温度
  int t[7]={0,-1,1,-5,5,10,-10};     //六个调温方式
  int u=0,s;     //u和s搭配使用，上面有解释
  int bj[100];     //bj就是标记（接地气）
  int ans=1;     //最短步数
  memset(bj,0,sizeof(bj));     //数组初始化为0，个人习惯
  cin>>a>>b;
  if(a==b){     //特判，万一碰到a=b（真的有一个测试点）
    cout<<"0"<<endl;
    return 0;
   } 
  bj[a+50]=1;    //a+50是因为数组下标不能为负，那就以50为0度
  q.push(a);    //压入a
  for(int i=1;i<=6;i++){    //六个调温方式
    q.push(a+t[i]);    //压入新温度
    bj[a+t[i]+50]=1;    //做标记
   }
  q.pop();    //弹出a
  s=q.size();    //得到队列元素个数
  while(q.front()!=b){
    u++;
    for(int i=1;i<=6;i++){   //以队头元素向六个方向（就那意思）搜索
      if(bj[q.front()+t[i]+50]==0)    //如果标记为1则不用再搜索了
      q.push(q.front()+t[i]);
    }
    q.pop();     //弹出队头元素
    if(u==s){
      ans++;     //还没找到答案，步数＋1
      u=0;
      s=q.size();
     }
   }
  cout<<ans<<endl;     //输出答案并换行
  return 0;
}
```


------------

啊哈，这是本蒟蒻的第一篇题解，有些小激动（排版在下已经尽力了...）
