## 核心思想：最短路

### 1.建模

把温度作为点，把按一次遥控器能切换的温度中间连边，边权为1，表示按了一次。

以温度A为起点，温度B为终点跑最短路。A到B的最短距离即为最少次数。

### 2.算法

本题数据量小，A与B的范围都是40，可以使用Floyd和Johnson，也可以Dijkstra和SPFA等等。

我个人秉承一贯的理念：只要是单源最短路，没有负边权，那么就用Dijkstra+堆优化。

### 3.细节

#### 怎么建图？

由于数据量小，我们可以在输入前把图预处理出来。

枚举40个温度点，把与当前温度相邻的6个温度连边，即

`x+1 , x-1 , x+5 , x-5 , x+10 , x-10`

在建边的时候注意不要越界。

### 4.代码

~~其实就是模板，感觉也不用上代码了~~

```cpp
#include<iostream>
#include<cstdio>
#include<vector>
#include<algorithm>
#include<queue>
#define INF 0x7fffffff
#define pii pair<int,int>
using namespace std;
struct Node
{
    int head;
    int dis;
}node[100005];
struct Edge
{
    int next,to,len;
}edge[1000005];
int cnt;
void addEdge(int u,int v,int w)
{
    edge[++cnt]={node[u].head,v,w};
    node[u].head=cnt;
}
//链式前向星存图
int A,B;
void Dijkstra()
{
    for(int i=0;i<=40;i++)
    {
        node[i].dis=INF;
    }
    //切记初始化
    
    priority_queue<pii,vector<pii>,greater<pii> >q;
    //STL小根堆
    q.push({0,A});
    node[A].dis=0;
    while(q.size())
    {
        pii tmp=q.top();
        q.pop();
        int d=tmp.first,u=tmp.second;
        if(d!=node[u].dis)continue;
        for(int e=node[u].head;e;e=edge[e].next)
        {
            int v=edge[e].to;
            if(node[v].dis>d+edge[e].len)
            {
                node[v].dis=d+edge[e].len;
                q.push({node[v].dis,v});
            }
        }
    }
}
//以上为模板，不过多介绍

int main()
{
    for(int i=0;i<=40;i++)
    {
        if(i+1<=40)   addEdge(i,i+1,1);
        if(i-1>=0)    addEdge(i,i-1,1);
        if(i+5<=40)   addEdge(i,i+5,1);
        if(i-5>=0)    addEdge(i,i-5,1);
        if(i+10<=40)  addEdge(i,i+10,1);
        if(i-10>=0)   addEdge(i,i-10,1);
        //注意判断越界
    }
    //预处理图
    
    scanf("%d%d",&A,&B);
    Dijkstra();
    printf("%d\n",node[B].dis);
    return 0;
}
```

OK!

### 不过你以为到这就结束了？

考虑到本题数据范围颇小，为了有更优的解，我们可以打表。

（其实以上代码已经够用了）

枚举每个A与B的情况，输出到数组里。

注意细节的处理。

```cpp
#include<iostream>
#include<cstdio>
#include<vector>
#include<algorithm>
#include<queue>
#define INF 0x7fffffff
#define pii pair<int,int>
using namespace std;
struct Node
{
    int head;
    int dis;
}node[100005];
struct Edge
{
    int next,to,len;
}edge[1000005];
int cnt;
void addEdge(int u,int v,int w)
{
    edge[++cnt]={node[u].head,v,w};
    node[u].head=cnt;
}
void Dijkstra(int A)
{
    for(int i=0;i<=40;i++)
    {
        node[i].dis=INF;
    }
    priority_queue<pii,vector<pii>,greater<pii> >q;
    q.push({0,A});
    node[A].dis=0;
    while(q.size())
    {
        pii tmp=q.top();
        q.pop();
        int d=tmp.first,u=tmp.second;
        if(d!=node[u].dis)continue;
        for(int e=node[u].head;e;e=edge[e].next)
        {
            int v=edge[e].to;
            if(node[v].dis>d+edge[e].len)
            {
                node[v].dis=d+edge[e].len;
                q.push({node[v].dis,v});
            }
        }
    }
}
int main()
{
	freopen("AT46打表.txt","w",stdout);
	//输出到文件里，方便复制 
    for(int i=0;i<=40;i++)
    {
        if(i+1<=40)   addEdge(i,i+1,1);
        if(i-1>=0)    addEdge(i,i-1,1);
        if(i+5<=40)   addEdge(i,i+5,1);
        if(i-5>=0)    addEdge(i,i-5,1);
        if(i+10<=40)  addEdge(i,i+10,1);
        if(i-10>=0)   addEdge(i,i-10,1);
    }
    puts("int ans[45][45]={");
    for(int A=0;A<=40;A++)
    {
    	printf("{");
		Dijkstra(A);
    	for(int B=0;B<=39;B++)
    	{
    		printf("%d,",node[B].dis);
		}
    	printf("%d",node[40].dis);
		if(A!=40)puts("},");
		else puts("}");
	}
	puts("};");
    return 0;
}
```
这就是生成程序。

然后把打出的表放到代码里，输入A和B后直接输出即可。

```cpp
#include<cstdio>
using namespace std;
int ans[45][45]={
{0,1,2,3,2,1,2,3,3,2,1,2,3,4,3,2,3,4,4,3,2,3,4,5,4,3,4,5,5,4,3,4,5,6,5,4,5,6,6,5,4},
{1,0,1,2,3,2,1,2,3,3,2,1,2,3,4,3,2,3,4,4,3,2,3,4,5,4,3,4,5,5,4,3,4,5,6,5,4,5,6,6,5},
{2,1,0,1,2,3,2,1,2,3,3,2,1,2,3,4,3,2,3,4,4,3,2,3,4,5,4,3,4,5,5,4,3,4,5,6,5,4,5,6,6},
{3,2,1,0,1,2,3,2,1,2,3,3,2,1,2,3,4,3,2,3,4,4,3,2,3,4,5,4,3,4,5,5,4,3,4,5,6,5,4,5,6},
{2,3,2,1,0,1,2,3,2,1,2,3,3,2,1,2,3,4,3,2,3,4,4,3,2,3,4,5,4,3,4,5,5,4,3,4,5,6,5,4,5},
{1,2,3,2,1,0,1,2,3,2,1,2,3,3,2,1,2,3,4,3,2,3,4,4,3,2,3,4,5,4,3,4,5,5,4,3,4,5,6,5,4},
{2,1,2,3,2,1,0,1,2,3,2,1,2,3,3,2,1,2,3,4,3,2,3,4,4,3,2,3,4,5,4,3,4,5,5,4,3,4,5,6,5},
{3,2,1,2,3,2,1,0,1,2,3,2,1,2,3,3,2,1,2,3,4,3,2,3,4,4,3,2,3,4,5,4,3,4,5,5,4,3,4,5,6},
{3,3,2,1,2,3,2,1,0,1,2,3,2,1,2,3,3,2,1,2,3,4,3,2,3,4,4,3,2,3,4,5,4,3,4,5,5,4,3,4,5},
{2,3,3,2,1,2,3,2,1,0,1,2,3,2,1,2,3,3,2,1,2,3,4,3,2,3,4,4,3,2,3,4,5,4,3,4,5,5,4,3,4},
{1,2,3,3,2,1,2,3,2,1,0,1,2,3,2,1,2,3,3,2,1,2,3,4,3,2,3,4,4,3,2,3,4,5,4,3,4,5,5,4,3},
{2,1,2,3,3,2,1,2,3,2,1,0,1,2,3,2,1,2,3,3,2,1,2,3,4,3,2,3,4,4,3,2,3,4,5,4,3,4,5,5,4},
{3,2,1,2,3,3,2,1,2,3,2,1,0,1,2,3,2,1,2,3,3,2,1,2,3,4,3,2,3,4,4,3,2,3,4,5,4,3,4,5,5},
{4,3,2,1,2,3,3,2,1,2,3,2,1,0,1,2,3,2,1,2,3,3,2,1,2,3,4,3,2,3,4,4,3,2,3,4,5,4,3,4,5},
{3,4,3,2,1,2,3,3,2,1,2,3,2,1,0,1,2,3,2,1,2,3,3,2,1,2,3,4,3,2,3,4,4,3,2,3,4,5,4,3,4},
{2,3,4,3,2,1,2,3,3,2,1,2,3,2,1,0,1,2,3,2,1,2,3,3,2,1,2,3,4,3,2,3,4,4,3,2,3,4,5,4,3},
{3,2,3,4,3,2,1,2,3,3,2,1,2,3,2,1,0,1,2,3,2,1,2,3,3,2,1,2,3,4,3,2,3,4,4,3,2,3,4,5,4},
{4,3,2,3,4,3,2,1,2,3,3,2,1,2,3,2,1,0,1,2,3,2,1,2,3,3,2,1,2,3,4,3,2,3,4,4,3,2,3,4,5},
{4,4,3,2,3,4,3,2,1,2,3,3,2,1,2,3,2,1,0,1,2,3,2,1,2,3,3,2,1,2,3,4,3,2,3,4,4,3,2,3,4},
{3,4,4,3,2,3,4,3,2,1,2,3,3,2,1,2,3,2,1,0,1,2,3,2,1,2,3,3,2,1,2,3,4,3,2,3,4,4,3,2,3},
{2,3,4,4,3,2,3,4,3,2,1,2,3,3,2,1,2,3,2,1,0,1,2,3,2,1,2,3,3,2,1,2,3,4,3,2,3,4,4,3,2},
{3,2,3,4,4,3,2,3,4,3,2,1,2,3,3,2,1,2,3,2,1,0,1,2,3,2,1,2,3,3,2,1,2,3,4,3,2,3,4,4,3},
{4,3,2,3,4,4,3,2,3,4,3,2,1,2,3,3,2,1,2,3,2,1,0,1,2,3,2,1,2,3,3,2,1,2,3,4,3,2,3,4,4},
{5,4,3,2,3,4,4,3,2,3,4,3,2,1,2,3,3,2,1,2,3,2,1,0,1,2,3,2,1,2,3,3,2,1,2,3,4,3,2,3,4},
{4,5,4,3,2,3,4,4,3,2,3,4,3,2,1,2,3,3,2,1,2,3,2,1,0,1,2,3,2,1,2,3,3,2,1,2,3,4,3,2,3},
{3,4,5,4,3,2,3,4,4,3,2,3,4,3,2,1,2,3,3,2,1,2,3,2,1,0,1,2,3,2,1,2,3,3,2,1,2,3,4,3,2},
{4,3,4,5,4,3,2,3,4,4,3,2,3,4,3,2,1,2,3,3,2,1,2,3,2,1,0,1,2,3,2,1,2,3,3,2,1,2,3,4,3},
{5,4,3,4,5,4,3,2,3,4,4,3,2,3,4,3,2,1,2,3,3,2,1,2,3,2,1,0,1,2,3,2,1,2,3,3,2,1,2,3,4},
{5,5,4,3,4,5,4,3,2,3,4,4,3,2,3,4,3,2,1,2,3,3,2,1,2,3,2,1,0,1,2,3,2,1,2,3,3,2,1,2,3},
{4,5,5,4,3,4,5,4,3,2,3,4,4,3,2,3,4,3,2,1,2,3,3,2,1,2,3,2,1,0,1,2,3,2,1,2,3,3,2,1,2},
{3,4,5,5,4,3,4,5,4,3,2,3,4,4,3,2,3,4,3,2,1,2,3,3,2,1,2,3,2,1,0,1,2,3,2,1,2,3,3,2,1},
{4,3,4,5,5,4,3,4,5,4,3,2,3,4,4,3,2,3,4,3,2,1,2,3,3,2,1,2,3,2,1,0,1,2,3,2,1,2,3,3,2},
{5,4,3,4,5,5,4,3,4,5,4,3,2,3,4,4,3,2,3,4,3,2,1,2,3,3,2,1,2,3,2,1,0,1,2,3,2,1,2,3,3},
{6,5,4,3,4,5,5,4,3,4,5,4,3,2,3,4,4,3,2,3,4,3,2,1,2,3,3,2,1,2,3,2,1,0,1,2,3,2,1,2,3},
{5,6,5,4,3,4,5,5,4,3,4,5,4,3,2,3,4,4,3,2,3,4,3,2,1,2,3,3,2,1,2,3,2,1,0,1,2,3,2,1,2},
{4,5,6,5,4,3,4,5,5,4,3,4,5,4,3,2,3,4,4,3,2,3,4,3,2,1,2,3,3,2,1,2,3,2,1,0,1,2,3,2,1},
{5,4,5,6,5,4,3,4,5,5,4,3,4,5,4,3,2,3,4,4,3,2,3,4,3,2,1,2,3,3,2,1,2,3,2,1,0,1,2,3,2},
{6,5,4,5,6,5,4,3,4,5,5,4,3,4,5,4,3,2,3,4,4,3,2,3,4,3,2,1,2,3,3,2,1,2,3,2,1,0,1,2,3},
{6,6,5,4,5,6,5,4,3,4,5,5,4,3,4,5,4,3,2,3,4,4,3,2,3,4,3,2,1,2,3,3,2,1,2,3,2,1,0,1,2},
{5,6,6,5,4,5,6,5,4,3,4,5,5,4,3,4,5,4,3,2,3,4,4,3,2,3,4,3,2,1,2,3,3,2,1,2,3,2,1,0,1},
{4,5,6,6,5,4,5,6,5,4,3,4,5,5,4,3,4,5,4,3,2,3,4,4,3,2,3,4,3,2,1,2,3,3,2,1,2,3,2,1,0}
};
int A,B;
int main()
{
    scanf("%d%d",&A,&B);
    printf("%d\n",ans[A][B]);
    return 0;
}
```
结束！