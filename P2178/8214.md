这题出题人给的题解是用后缀数组O(nlogn)解决的，还用了单调栈或并查集。但这种复杂度还有可能被卡常数，实现上也有一定的难度，现在我们来YY一种O(n)的常数更小实现更简单的做法。

首先，题目中的r相似定义为从p、q两个点开始有长度不少于r的子串。如果我们能统计出所有p、q的LCP长度，并且只更新长度恰好为LCP的答案，那么我们可以通过后缀和和后缀最大值获得题目要求的答案。

考虑后缀树。假设我们神奇的获得了一棵后缀树，则只需要对于每一个非叶子节点，统计两个信息：1、有多少对叶子的LCA是它；2、它的子树中的所有叶子中，乘积最大值是多少。然后用这两个信息更新“该节点深度”dep相似的答案。树形DP解决。实现上要注意如果串都是相同字符，可能会爆栈，应采用BFS，由儿子更新父亲。

现在万事俱备，只欠一棵后缀树。考虑用后缀自动机构造后缀树。我们倒着插入原串（开头要先插一个特殊字符），并构建parent树。我们发现用于构造后缀自动机的len数组恰好就是对应后缀的长度，也就是该节点在后缀自动机中的深度。这里也有需要注意的：1、由于添加了特殊字符，叶子节点的深度需-1；2、存在一个-1后深度为0的叶子节点（表示空后缀），统计答案时需要扔掉。

至此，问题完美解决。时间复杂度O(n)，就算用string估计也不会被卡了。
