罕见的抄了一发题解……毕竟NOI原题哪有那么容易写出来的道理

并没有什么罕见的算法，不过思路还是很巧妙的

一开始我的想法是用单调栈，而且好像的确有这种算法的std，不过我乱搞了一下午样例都没过于是只好作罢

改为大众并查集做法。

首先很容易发现，对于任意一对r相似，它一定是k(0<k<r)相似的 

所以求出height数组后按其中的值排序，然后从大到小做

当前需要处理的串为i和i-1，设前缀长度为k 

易知若将两个并查集合并，则当前的前缀在并查集中一定是最小的，所以Ans[k][0]+=两棵树size的乘积（因为任意两两前缀都是k相似的，可以配对）

除了并查集的size，还维护一下并查集的max和min值，

则Ans[k][1]=max(Ans[k][1],Max1*Max2,Min1*Min2)

维护min值是为了防止有很小的负数这种情况（负负得正） 

最后因为Ans[i]也是满足Ans[i+1]的，所以做个前缀和合并一下答案就好

[代码](http://www.cnblogs.com/refun/p/8679198.html)