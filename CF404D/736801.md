[题目传送门](https://www.luogu.com.cn/problem/CF404D)

有启发性的题。

考虑 dp。第一眼我设计了这个非常显然的状态：

$dp_{i,j}$（$0\leq j\leq4$）表示对于字符串前 $i$ 位，且第 $i$ 位为 `0`，`1`，`2`，`*`，`?`（分别对应 $j=0,j=1\dots j=4$）的情况下，将该串变为合法串的方案数（$\bmod\ 10^9+7$）。

但是由于当该位为 `0` 或 `2` 时，需要未处理处的贡献，所以难以转移。

因此尝试记录相邻两位的状态。

当然我们无法预知后一位将是怎样的情况，只能确定仅有两种可能：下一位是雷，下一位不是雷。特别地，当自己就是雷时，和其它位无关（不代表其它位和它无关，以后可能会根据其更新），因此再记一个状态：自己就是雷。

因此 dp 状态改为： $dp_{i,j}$ 表示对于字符串前 $i$ 位，第 $i+1$ 位不是雷（$j=0$），是雷（$j=1$）；第 $i$ 位是雷（$j=2$）。

此时，我们可以根据该位的状态、后一位我们猜测的状态，来推出上一位的状态，确定了相邻两位。即使后一位猜错了也没事，因为当处理到那里时，它只会取走与自己有关的状态，不会出现错误贡献。

这下转移方程就很显然了，根据目前要转移的状态可得，上代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e6+10,mod=1000000007;
char s[N];
int n,dp[N][3];
signed main()
{
    scanf("%s",s+1);n=strlen(s+1);
    dp[0][0]=dp[0][1]=1;
    for(int i=1;i<=n;i++)
    {
        if(s[i]=='0')
        {
            dp[i][0]=dp[i-1][0];
        }
        else if(s[i]=='1')
        {
            dp[i][1]=dp[i-1][0];
            dp[i][0]=dp[i-1][2];
        }
        else if(s[i]=='2')
        {
            dp[i][1]=dp[i-1][2];
        }
        else if(s[i]=='*')
        {
            dp[i][2]=dp[i-1][1]+dp[i-1][2];
        }
        else if(s[i]=='?')
        {
            dp[i][0]=dp[i-1][0]+dp[i-1][2];
            dp[i][1]=dp[i-1][0]+dp[i-1][2];
            dp[i][2]=dp[i-1][1]+dp[i-1][2];
            //问号可以是任何一种字符，所以全部转移。
        }
        dp[i][0]%=mod;
        dp[i][1]%=mod;
        dp[i][2]%=mod;
    }
    printf("%d\n",(dp[n][0]+dp[n][2])%mod);
    return 0;
}
```

[record](https://www.luogu.com.cn/record/109425590)