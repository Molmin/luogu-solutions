### 题意简述
相信大家都玩过扫雷，这里的扫雷和我们玩的差不多，不过是一维扫雷，所以棋盘上除了星号（表示雷）和问号（表示这个格子还没被翻开）以外，只有零、一、二这三个数字。   
那么问题就来了：给你一个字符串，长度为 $n$（$ 1\ \leq\ N\ \leq\ 10^6 $），表示棋盘，求将问号改为其它四种字符，使棋盘合法的方案数。   
此处的“合法”就是说每个数字两旁的雷的数量就是这个数字，如数字零和数字二中间夹着一个星号就是非法的，而两个数字一中间夹着一个星号就是合法的。用扫雷的规则类比一下就会很快明白。    
答案对 $10^9+7$ 取模。    
### 思路分析
使用递推（或者说动规）求解。

##### **首先，定义 $f_{i,j}$ 表示第 $i$ 个位置第 $j$ 种情况的方案数。**          
各种情况具体如下：     
1. $f_{i,1}$：第 $i$ 个、第 $i-1$ 个、第 $i+1$ 个位置都没有雷（对应数字零的情况，以下简称“都没有”）。    
2. $f_{i,2}$：第 $i$ 个位置没有雷，第 $i-1$ 个和第 $i+1$ 个位置有雷（对应数字二的情况，以下简称“都有”）。    
3. $f_{i,3}$：第 $i$ 个位置有雷，第 $i-1$ 个和第 $i+1$ 个位置随便（对应星号的情况，以下简称“本身是”）。    
4. $f_{i,4}$：第 $i$ 个、第 $i+1$ 个位置没有雷，第 $i-1$ 个位置有雷（对应数字一的情况，以下简称“左边有”）。    
5. $f_{i,5}$：第 $i$ 个、第 $i-1$ 个位置没有雷，第 $i+1$ 个位置有雷（也对应数字一的情况，以下简称“右边有”）。    

看得出来数字一可能有两种情况，左边有雷或者右边有雷，讨论时需要分开。

##### **然后确定初始值，给 $f$ 数组初始化。**
为了方便，我们从第 $0$ 个位置开始初始化。   
由于第 $1$ 个位置可以是雷也可以不是雷，同时第 $0$ 个位置和第 $-1$ 个位置不能是雷（如果有雷那就离离原上谱了），而满足这个约束的有“都没有”和“右边有”，所以 $f_{0,1}=f_{0,5}=1$。   
需要注意的是，如果不加这个初始化为 $1$ 的操作，那么输出的答案永远是 $0$。  
数组里面的元素本来都是 $0$ 啊，你无论怎样加来加去不还是 $0$？   
~~所以好心提醒大家，在做递推题或者动规题的时候，一定要注意初始化！~~

##### **接下来就是每道递推题或动规题都会经历的过程：找递推式，或者说状态转移方程。**   
计算有多少种方案。字符不同，计算的方法也不同。统计当前位置属于哪种情况时的方案数，十分明显需要分类讨论。   
下面开始推式子吧！    
此处设当前位置为第 $i$ 个位置。
1. **当前位置是数字零**（对应 $f_{i,1}$ 的情况，即“都没有”）。   
要求上一个位置不能是雷，而且当前位置也不能是雷。
满足这个约束的情况有两个，分别是“**都没有**”和“**左边有**”（这里的“左边有”是对于第 $i-1$ 个位置而言，即第 $i-2$ 个位置是雷，第 $i-1$ 个位置和第 $i$ 个位置不是雷），这两种情况都可以为当前状态做贡献。     
所以此时 $f_{i,1}=f_{i-1,1}+f_{i-1,4}$。

------------

2. **当前位置是数字一**。   
这里就分两种情况了，分别是 $f_{i,4}$（“左边有”）和 $f_{i,5}$（“右边有”）。    
**考虑“左边有”**，此时当前位置的上一个位置就要是雷，即只有“**本身是**”的情况会对当前状态做贡献。   
所以 $f_{i,4}=f_{i-1,3}$。  
接着**考虑“右边有”**，此时当前位置的上一个位置就不能是雷，并且当前位置也不能是雷，即“**都没有**”和“**左边有**”的情况会对当前状态做贡献。  
所以此时 $f_{i,5}=f_{i-1,1}+f_{i-1,4}$。

------------

3. **当前位置是数字二**（对应 $f_{i,2}$ 的情况，即“都有”）。   
这种情况意味着第 $i-1$ 个位置是雷，满足这个约束的只有“**本身是**”这个情况。   
所以此时 $f_{i,2}=f_{i-1,3}$。

------------

4. **当前位置是星号**（对应 $f_{i,3}$ 的情况，即“本身是”）。  
这**意味着且仅意味着**当前位置一定是雷，而上一个位置是不是雷都**无所谓**。   
换句话说，就是对于第 $i-1$ 个位置来说，它的右边需要是雷，而这个地方是不是雷都无所谓。   
满足这个约束的有“**都有**”、“**本身是**”（当前位置有雷并不代表它右边的位置就没有雷，它右边的位置也可以是有雷的，就是两个雷并排在一起的情况）和“**右边有**”，这三个情况可以为答案做出贡献。   
所以此时 $f_{i,3}=f_{i-1,2}+f_{i-1,3}+f_{i-1,5}$。 
5. **当前位置是问号**。    
这个地方我们就需要分别计算了，毕竟四种字符都有可能成为当前位置的字符，不像前面所提到的情况，确定的字符已经让这个位置的情况确定了。     
（当然了有些情况是不存在的，但是不影响问题的答案。）   
直接把上面提到的所有状态转移方程（或者叫递推式？）全部照搬即可，即此时 
$$\begin{cases}
f_{i,1}=f_{i-1,1}+f_{i-1,4},\\
f_{i,2}=f_{i-1,3},\\
f_{i,3}=f_{i-1,2}+f_{i-1,3}+f_{i-1,5},\\
f_{i,4}=f_{i-1,3},\\
f_{i,5}=f_{i-1,1}+f_{i-1,4}.\end{cases}$$

------------

##### **最后是输出答案。**    
对于最后一个格子，可能的情况有“都有”、“本身是”和“左边有”。    
因为第 $n+1$ 个位置肯定不是雷，所以“都有”和“右边有”的情况要排除。   
那么最终的答案就很明显了，是 $f_{n,1}+f_{n,3}+f_{n,4}$ 的值。


### code展示
如果能看懂上面写的话，理解下面的代码应该也不难了。  
最后祝愿大家能够又收获一道绿题！
```cpp
#include<stdio.h>
#include<string.h>
int n;long long f[1000005][10];
char s[1000005];
int main()
{
    scanf("%s",s+1),n=strlen(s+1);//s+1为s数组的地址的起始位置往后一个位置，即输入的第一个字符会存进s[1]而不是s[0]中
    f[0][1]=f[0][5]=1;
    for(int i=1;i<=n;i++)
    {
        if(s[i]=='?') f[i][1]=(f[i-1][1]+f[i-1][4])%int(1e9+7),
        f[i][2]=f[i-1][3],
        f[i][3]=(f[i-1][2]+f[i-1][3]+f[i-1][5])%int(1e9+7),
        f[i][4]=f[i-1][3],
        f[i][5]=(f[i-1][1]+f[i-1][4])%int(1e9+7);
        //1e9+7在C++中默认为浮点数，要转化为int类型才能作为模数
        else if(s[i]=='0') f[i][1]=(f[i-1][1]+f[i-1][4])%int(1e9+7);
        else if(s[i]=='1') f[i][4]=f[i-1][3],f[i][5]=(f[i-1][1]+f[i-1][4])%int(1e9+7);
        else if(s[i]=='2') f[i][2]=f[i-1][3];
        else if(s[i]=='*') f[i][3]=(f[i-1][2]+f[i-1][3]+f[i-1][5])%int(1e9+7);
    }
    printf("%lld",(f[n][1]+f[n][3]+f[n][4])%int(1e9+7));
}
```

更新状态：    
三月二十五日初稿。    
六月二十三日发现此题由紫降绿了，更改了祝福语。~~然而被打回了。~~     
七月一日把所有字符串改成了汉字，~~避免被打回~~。