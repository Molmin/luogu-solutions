### 题意

- 给出 $R$ 行 $C$ 列的字符矩阵。
- 求在中心 $R - 2\times K$ 行 $C - 2\times K$ 列中
满足和最近的 `x` 字符的曼哈顿距离超过 $K$ 的位置个数。
- 对于 $30$ 分的数据，$3 \le R,C \le 50$。
- 对于全部的数据，$3 \le R,C \le 500$ 且 $2 \le K \le 500$。

### 做法分析

#### 部分分

首先考虑部分分做法。显然，可以对于每个在中心 $R - 2\times K$ 行 $C - 2\times K$ 列的字符都进行搜索，查找周围 $K - 1$ 格曼哈顿距离内是否有 `x` 字符，若无则对答案产生贡献。

该做法时间复杂度为 $O(RCK^2)$，可以拿到 $30$ 分的部分分。  
代码实现较为容易，故不再展开。

#### 正解

搜索算法效率不足以通过全部数据，考虑是否可以以空间换时间。

对于矩阵中的每一个点，我们可以统计其上方和下方有多少 `o` 字符。  
假设一个点可以对答案产生贡献，则需要在以该点为中心的、半径为 $K - 1$ 的菱形范围内都为 `o` 字符。  
显然，我们可以从左向右依次遍历我们统计的数组，如果有一个位置上方或下方 `o` 字符数量不足该位置应有的量，则该点无法对答案产生贡献，可以直接跳过。

该做法时间复杂度为 $O(RCK)$，即使常数较大也仍能通过全部数据。

另外，需要注意此题距离范围为 $1$ 至 $K - 1$，并非常见的 $1$ 至 $K$。

AC 代码如下：

```cpp
#include <algorithm>
#include <cstdio>
#include <iostream>
using namespace std;
int r, c;
int k;
char mp[505][505];
int s[505][505][2]; 
// s[i][j][0]表示第i行第j列位置上方（包括自己）有几个o
// s[i][j][1]表示第i行第j列位置下方（包括自己）有几个o
int ans;
int main()
{
    cin >> r >> c >> k;
    for (int i = 1; i <= r; ++i) {
        cin >> (mp[i] + 1);
    }
    for (int i = 1; i <= r; ++i) {
        for (int j = 1; j <= c; ++j) {
            s[i][j][0] = mp[i][j] == 'o' ? s[i - 1][j][0] + 1 : 0;
        }
    }
    for (int i = r; i >= 1; --i) {
        for (int j = 1; j <= c; ++j) {
            s[i][j][1] = mp[i][j] == 'o' ? s[i + 1][j][1] + 1 : 0;
        }
    }
    for (int i = k; i <= r - k + 1; ++i) {
        for (int j = k; j <= c - k + 1; ++j) {
            int flg = 1; 
            // flg表示当前位置是否对答案产生贡献
            for (int l = j - k + 1, cnt = 0; l < j + k; ++l) { 
                // cnt表示在l这一列上向上和向下至少应该有几个o
                if (l <= j) {
                    ++cnt;
                }
                else {
                    --cnt;
                }
                if (s[i][l][0] < cnt || s[i][l][1] < cnt) {
                    flg = 0;
                    break;
                }
            }
            ans += flg;
        }
    }
    cout << ans << endl;
    return 0;
}

```

PS：此题综合难度较易，建议降黄。