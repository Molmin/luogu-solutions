## Preface

[昨天刚翻到，今天就见到 reality version 了，非常感动。](https://www.cnblogs.com/alex-wei/p/dp_tricks.html)

~~魏老师别打我贺博客，实在是某人拒绝我说不够详细才出此下策的。~~

## Solution

这题数据范围强行二合一抽象的批爆，但是我不是很能理解有什么搞两个 Subtask 的必要。

**介绍一下科技：树上依赖型背包**。

这形如在树上选出若干个物品做背包问题，满足**这些物品形成一个包含根节点的连通块**。不妨假设这是一个 $\mathcal O(V)$ 加入物品、$\mathcal O(V^2)$ 合并背包的 01 背包。

显然存在一个 $\mathcal O(n\times V^2)$ 的，对每个子树暴力合并背包的树形 dp 做法，求出以每个节点为根时其子树的答案。

但其实对每个节点都求答案似乎有些累赘，因为我们只关心给定根时的答案。所以我们尝试把树拍平成 dfs 序，在 dfs 序上进行背包。同样让 $f_1\dots f_n$ 表示每个节点对应的背包。

对于每个节点 $i$：
+ 如果不选，那么跳过 $i$ 的整棵子树，所以可以把 $f_i$ 的每一位向 $f_{i+sz_i}$ 的每一位 checkmax；
+ 如果选，则将这个背包带到子树里，那么由于子树间的选与不选是一个子问题，我们可以直接把 $f_i$ 加入节点 $i$ 上物品的新背包向 $f_{i+1}$ 的每一位 checkmax。

容易发现，这样的复杂度是 $\mathcal O(nV)$。

---

于是我们反手一个树上依赖型背包，这时一个点对应物品的：

+ cost 是它到父亲的边边权 $\times 2$（遍历一个连通块，最优情况下一条边来回只走两次）；
+ val 是它上面所有纸片人的愉悦值数量。

对所有纸片人在的地方建个虚树就可以了（如果不建 Sub2 会炸），时间复杂度 $\mathcal O(M\log N + M\times tim)$。

## Bonus

不定根节点？考虑定根节点后是简单的，则可以点分治做到仅多一个 log。