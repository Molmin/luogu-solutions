### 题目大意

有一张 $N$ 个点 $2M$ 条边的有向图，第 $i$ 条边是一条从第 $A_i$ 个点到第 $B_i$ 个点，权值为 $C_i$ 的边，第 $i+m$ 条边是一条从第 $B_i$ 个点到第 $A_i$ 个点，权值为 $-C_i$ 的边。现给定 $Q$ 次询问，每次询问给定 $X_i,Y_i$，你需要输出从第 $X_i$ 个点到第 $Y_i$ 个点的路径上的权值最大值（可以重复经过某个点或某条边）。如果两点不连通，输出 `nan`；如果最大值为无限大，输出 `inf`。

输入格式：第一行三个整数 $N,M,Q$，接下来 $M$ 行每行三个整数 $A_i,B_i,C_i$，再接下来 $Q$ 行每行两个整数 $X_i,Y_i$，表示 $Q$ 组询问。

输出格式：共 $Q$ 行，每行一个整数或是一个字符串，表示对应询问的回答。

数据范围：$2 \le N \le 10^5$，$0 \le M \le 10^5$，$1 \le Q \le 10^5$，$1 \le A_i,B_i,X_i,Y_i \le N$，$0 \le C_i \le 10^9$。

------------

### 解法分析

赛时被 D 把心态搞崩了没去仔细想，赛后听学长讲评后发现是很有意思的一道题。

下面的分析全部建立在本题图的特殊性质条件的基础上。

显然的是只要 $X_i,Y_i$ 不在同一个连通块中，这组询问的答案就是 `nan`。

（~~然而赛时的我止步于此。~~）

同样显然的是只要 $X_i,Y_i$ 在同一个连通块中，而且这个连通块内存在正环的话，这组询问的答案就是 `inf`。

并且，只要有负环，就一定有正环，反之亦然。

那只出现什么样的环才能不存在正环或者负环呢？

边上权值之和为 $0$ 的环。

而且，显然环上任意两点之间都有两条简单路径，然后我们会发现，当环满足边权之和为 $0$ 的条件时，这两条路径的权值相同。

所以，**当一个连通块中不存在正环与负环时，块上任意两点之间不管有多少条不同路径，它们的权值都是相等的。**

信息量有点大，花点时间理解一下。

于是利用上面的结论我们可以发现一种解法：对于每个连通块，从块上任意一点搜索整个块，设这个点与第 $i$ 个点的距离为 $dis_i$。由刚刚的结论我们可以知道如果块内不存在正环的话 $dis_i$ 是唯一的，如果不唯一就说明有正环。如果询问中的 $X_i,Y_i$ 在同一连通块且块内不存在正环的话，这一组询问的答案就为 $dis_{Y_i}-dis_{X_i}$（可以理解为 $dis_{Y_i}+(-dis_{X_i})$。同样利用结论，两点之间所有路径权值相等，所以只要求出任意一条路径的权值就足够了）。

------------

### 代码

```cpp
#include <bits/stdc++.h>
#define ll long long
#define pb push_back
#define pll pair<ll,ll>
using namespace std;
const ll N=1e5+7;
ll n,m,q,coid,vis[N],dis[N],isnf[N],co[N];
vector <pll > v[N];
void dfs(ll pos) {
	co[pos]=coid; // 记连通块编号
	for (pll i:v[pos]) {
		ll x=i.first,y=i.second;
		if (!vis[x]) dis[x]=dis[pos]+y,vis[x]=1,dfs(x);
		else if (dis[x]!=dis[pos]+y) isnf[coid]=1; // 存在不相等路径，则有正环，注意这个时候还不能直接退出，你连通块编号还没记完呐
	}
}
int main() {
	scanf("%lld%lld%lld",&n,&m,&q);
	for (ll i=1,r1,r2,r3;i<=m;i++)
		scanf("%lld%lld%lld",&r1,&r2,&r3),v[r1].pb({r2,r3}),v[r2].pb({r1,-r3});
	for (ll i=1;i<=n;i++) if (!vis[i]) coid++,vis[i]=1,dfs(i); // 对每个连通块搜索
	for (ll r1,r2;q--;) {
		scanf("%lld%lld",&r1,&r2);
		if (co[r1]!=co[r2]) printf("nan\n"); // 不在同一连通块
		else if (isnf[co[r1]]) printf("inf\n"); // 有正环
		else printf("%lld\n",dis[r2]-dis[r1]);
	}
	return 0;
}
```