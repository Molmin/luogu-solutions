推一手蒟蒻的 $\color{LimeGreen}{\texttt {博客}}$ 

------------


总体做法已经被楼上的神仙们说得差不多啦，这篇文章旨在尽可能说得$\large{\texttt细}\normalsize{\texttt细}{\texttt 细}\small{\texttt 细}$细一点。避免像笔者一样~~Coding 五分钟，Debug 两小时~~的情况QwQ。

$\Large{\texttt 思}\Large{\texttt 路}$：莫队（不带修）+ $bitset$ 优化。可以称得上板子吧，可惜一眼还没看出来，还是题做的少/kk。

$\Large{\texttt 首}\Large{\texttt 先}$ ，讲一下为什么**离散化**是需要的。权值值域较大，将耗费大量 $bitset$ 的空间。离散化后 $bitset$ 只需开 $10^5$ 的空间，较为优秀。

$\Large{\texttt 其}\Large{\texttt 次} $，如果您是头一回接触 $bitset$ 对莫队的优化，这里有几个在代码里会用上的操作需要先跟您叙清：

- `bitset<MAX> now` 开一个大小为 $MAX$ 的 $bitset$ ，名为 $now$ 。本题中， $bitset$ 的第 $i$ 位则代表离散化后，值为 $i$ 的这个元素 **在/不在(1/0)** 这个区间内。

- `now.set(pos) ` 将 $now$ 的第 $pos$ 位设为 $1$ 。本题中用来表示离散化后，值为 $pos$ 的这个元素 **包含于** 要查询的区间。 

- `now.reset(pos)` 将 $now$ 的第 $pos$ 位设为 $0$ 。相对的，本题中用来表示离散化后，值为 $pos$ 的这个元素 **不包含于** 要查询的区间。 

- `sum[i] &= now` $sum[i]$ 也是一个 $bitset$ 。我们可以将两个 $bitset$ 直接 **与** 上，来实现求 **元素交集** 的作用。
	-  _如果您不理解为什么可以实现，我们可以考虑：如果一个离散后的元素，在三个区间都有出现，则它在三个区间所对应的 $bitset$ 中的位置**都为 $1$** ， **“与”** 运算后，三组都为 $1$ 的位置**结果依然为 $1$**，这些位置就对应着三个区间的交集。_ 
    
- `sum[i].count()` 用于求 $bitset$ 中 $1$ 的个数。这里用来统计求交集后**元素的个数**，原因与前面类似，不再赘述。

$\Large{\texttt 然}\Large{\texttt 后}$，需要指出这题使用莫队+ $bitset$ 的意义，有一言：

> 莫队可以维护常规数据结构难以维护的区间信息

这里的要维护的区间信息是什么，是**一个元素是否在区间中出现**。

这很难不让人联想到莫队板题《小B的询问》。

再者，也很难想到一种别的数据结构能够高效解决这类问题。

又有一言：

> bitset 常用于常规数据结构难以维护的的判定、统计问题

必然，这道题便是一款极为鬼畜的统计问题，**区间元素交集**，这令人不得不趋向 $bitset$ 求帮助。幸好， $bitset$ 求"与"可以解决这个问题。

（这里说句闲话，为什么逻辑运算符 **“与”**  $\land$ 和集合运算符 **“交”** $\cap$ 有些形似，实则不是巧合， $\cap$ 的定义便是：在集合A **且** 在集合B的元素。）

$\Large{\texttt 最}\Large{\texttt 后}$，略加整理一下可能会把您卡着的点，如下：

1. 本题稍带卡空间，建议将询问**分成三块**处理，以实现只开 $\dfrac{1}{3}$ 大小的 $bitset$ 而不牺牲时间复杂度。（这种卡空间思想类似于循环展开的卡时间思想？）。笔者采用了**常数大小的块**，而这一常数经检验为 $33350$ ，再往上就 $MLE$ 了QwQ 。当然，这是因人的写法而异的，不必死板。（~~用模拟退火调常数指日可待~~）

1. 做莫队时需要注意左右指针的移动顺序，否则可能会造成负值 $bitset$ 而 $RE$ 。具体地说，`l--,r++,l++,r--` 或 `l--,r++,r--,l++` 是最吼哒。因为他们都是**先扩张**了区间，**再收缩**。有效避免了一上来就收缩，结果一直找不到询问左右界的情况。

1. 因为本题是一个一个删去相同数的，所以不同位置上的元素，即使他们权值相同，**本质上是不同的**。故离散化时就**别想着去重**了，解决办法很多，比如少写一条 $\operatorname{unique}$ 哇，计算出现次数 $cnt$ 时有意更改权值保证其不重哇。笔者选择的是后者。

1. 和普通莫队记录最终答案的数组一样，参与 “与” 运算的 $bitset$ 的标号也不应是他排序后的序号，而应是这个询问**输入时记录的 $id$** 。即 `sum[q[i].id] &= now` 。

1. 既然我们是开常数大小的块，循环时须**格外注意上界**，谨防访问到空询问导致算法退化成暴力AwA。

1. 如果您被卡常了，可以试试莫队的**奇偶性排序**优化，百度即可，在此不多说了。

由于笔者码风诡异且实现与其他大佬基本无异，这里就放一个 $\mathtt{OI\ Wiki}$ 的[例题参考代码链接](https://oi-wiki.org/misc/mo-algo-with-bitset/)叭，顺着这条链是能翻到的。（~~逃~~