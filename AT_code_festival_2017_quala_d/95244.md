染色问题一般先想到奇偶染色，但是这题似乎没有很好的切入点。我们来一步一步转化问题。

曼哈顿距离可以转化成切比雪夫距离，通过变换坐标系，这是一个套路。为什么要转化呢？我们发现与点 $x$ 曼哈顿距离为 $d$ 的点构成了一个正方形，并且是斜着的，这不是很好处理。

变换过后，自然可以想到将变换后的坐标系分成 $d\times d$ 的块，块内的点显然不会有切比雪夫距离为 $d$ 的情况存在，所以只需考虑块间了。我们发现对于一个块 $x$，它的上面，下面，左边，右边的块中都有可能含有与块 $x$ 中某个点切比雪夫距离为 $d$ 的点，因此块 $x$ 必须与其上下左右的块颜色都不相同。

而我们自然又有一个贪心的策略，如果一些块可以染相同的颜色，就直接染。块 $x$ 上面的块和块 $x$ 下面的块就算颜色相同也不要紧，因为这两个块之间不可能存在切比雪夫距离为 $d$ 的点。块 $x$ 右边与块 $x$ 左边的点同理。进一步观察，发现这两对块的奇偶性各自相同，即块 $x$ 左右的块奇偶性相同，块 $x$ 上下的块奇偶性相同，但是这两对块之间的奇偶性却一定不相同。

想到了什么？是不是可以直接按行的奇偶性和列的奇偶性染色？正好 $4$ 种颜色，我们发现这样做的正确性根据上述结论是可以轻易证明出来的。

时间复杂度 $O(nm)$。

```cpp
#include<cstdio>
int main() {
	int n,m,d; scanf("%d%d%d",&n,&m,&d);
	for(register int i=1;i<=n;++i) {
		for(register int j=1;j<=m;++j) {
			int x=((i+j+m)/d)%2,y=((i-j+m)/d)%2;//平移整个变换后的坐标系，为了避免出现负数干扰判断奇偶性
			if(x==0&&y==0) putchar('R');
			if(x==0&&y==1) putchar('Y');
			if(x==1&&y==0) putchar('G');
			if(x==1&&y==1) putchar('B');
		}
		printf("\n");
	}
	return 0;
}
```