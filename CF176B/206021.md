#### 简述题意：
有两个字符串$a$,$b$，长度均$≤1000$个字符，把字符串$a$从任意一个地方截取，然后交换这两部分位置得到新的字符串，对它进行$k$次操作，问最后变到$b$串时的方法有多少种。
 $0<=k<=10^5$

------------
当我看到此题的标签时，阿勒？绿题，~~就这啊？~~ 但当我仔细想了一想此题，啪啪啪打脸，可能也是因为我太弱了，QAQ，看了 **@FP·荷兰猪大佬 @Mickey_snow等大佬** 的题解才写出来，本篇题解主要是对他们的题解进行蒟蒻式的说明，不喜勿喷。

------------
首先我们可以发现一个串进行变换的话，他是可以有$Len$(字符串的长度)种变换方式的。
#### 举个栗子：$ABC$字符串，它的变换方法有$ABC-CAB-CBA$三种方法，也就是他的长度。而且一个串变换到另一个串只需要一步，那么我们可以考虑预处理出一个x，表示一个字符串变换中有多少个目标串。看代码：
```cpp
	for(int i=1;i<=len;i++){ 
		if(check(i,i+len-1)){ //一个字符串的长度
			x++;
		}
	}
```
在这里大家会注意到一件事，我们在查找时，最大长度是$len+len-1$，这个是怎么回事呢？还是举原先的例子：
**$ABC$**当我们把他长度扩充两倍后，他就会变成**$ABCABC$**，我们在$(i,i+len-1)$的式子看一下，阿勒，$ABC-BCA-CAB$这不就是我们要找的拆分方法吗？真是妙啊！于是：
```cpp
    int len=strlen(a+1);
    for(int i=1;i<=len;i++){
    	a[i+len]=a[i];
	}
```
那么现在还有一个$check$函数的问题，这个$check$函数就很好解释，它就是把我们选出来的这一段字符串与字符串b去比较，看看如果一样，那么$x++$；
```cpp
bool check(int l,int r){
	int p=0;
	for(int i=l;i<=r;i++){
		if(a[i]!=b[++p]){
			return 0;
		}
	}
	return 1;
}
```


------------
### 接下来就是正题了：
#### 我们在经历了以上的分析后，我们再看一看题目，发现这是一道计数dp，那么接下来开始设置状态$f[i][1/0]$
1. $f[i][0]$表示的是在经过i次变换后，产生的原串个数，于此同时我们把字符串b给设置为原串。

2. $f[i][1]$表示的是经过i次变换后产生的其他串个数


分析：
1. $f[i][0]=f[i-1][1]*x+(x-1)*f[i-1][0]$

首先我们知道一个串在变换时，可以一次变换出x个原串，所以在$f[i-1][1]$个其他串中，每个串时可以转换出x个原串的，也就是$f[i-1][1]*x$个原串。其次，在$f[i-1][0]$个原串中，他们变换也是可以继续变换出原串的，那么，又因为**他们本身是一个原串**，所以变换出来的是**除他以外的**$x-1$个原串，所以$f[i][0]=f[i-1][1]*x+(x-1)*f[i-1][0]$

2.$f[i][1]=f[i-1][0]*(len-x)+f[i-1][1]*(len-x-1)$

在这里我们先前说了一个串的变换可以得到$len$个串，那么每个原串就可以变换出$len-x$个其他串也就是$f[i-1][0]*(len-x)$，而在$f[i-1][1]$个其他串中他们通过一次变换得到的是除自己以外的$len-x-1$个其他串。所以$f[i][1]=f[i-1][0]*(len-x)+f[i-1][1]*(len-x-1)$。

### 建议大家多看一下。有点难理解。
这一段的代码就是：
```cpp
for(int i=1;i<=k;i++){
    	f[i][0]=f[i-1][1]*x+(x-1)*f[i-1][0];
    	f[i][1]=f[i-1][0]*(len-x)+f[i-1][1]*(len-x-1);
	    f[i][0]=(f[i][0]+P)%P;
	    f[i][1]=(f[i][1]+P)%P;//取模惯用招数，不管是否为负数，先加一个模数，反正后面再%一次，是没有影响的
	}
```
然后就是初始化的问题，我们看下面：
```cpp
if(check(1,len)) f[0][0]=1;//如果a字符串本来就等于b字符串，那么它不用转移，就可以有一个原串
	else f[0][1]=1;//如果不是，那么它在不用转移时，就可以有一个其他串。
```
那么基本就差不多了，放AC代码，甚至你还可以在我的基础上加个O2，O3优化，那你就可以是rank2了
```cpp
#include<bits/stdc++.h>
using namespace std;
#define P 1000000007 //等同于P=1000000007
long long k,f[100005][3];//开个long long,防止见ZZ
char a[3005],b[1005];
bool check(int l,int r){
	int p=0;
	for(int i=l;i<=r;i++){
		if(a[i]!=b[++p]){//判断
			return 0;
		}
	}
	return 1;
}
int main(){
    scanf("%s%s%lld",a+1,b+1,&k);//加1方便计算
    int len=strlen(a+1);
    for(int i=1;i<=len;i++){
    	a[i+len]=a[i];
	}
    int x=0; 
	for(int i=1;i<=len;i++){
		if(check(i,i+len-1)){
			x++;
		}
	}
	if(check(1,len)) f[0][0]=1;
	else f[0][1]=1;
    for(int i=1;i<=k;i++){
    	f[i][0]=f[i-1][1]*x+(x-1)*f[i-1][0];
    	f[i][1]=f[i-1][0]*(len-x)+f[i-1][1]*(len-x-1);
	    f[i][0]=(f[i][0]+P)%P;
	    f[i][1]=(f[i][1]+P)%P;
	}
	cout<<f[k][0]%P;//最后答案就是第k次转换时的原串个数
	return 0;
} 
```
点个赞罗$QAQ$

$upd:$于$2020.1.24$加上$Latex$