首先我们不关心每个数的值，那么可以对它离散化。

计算最少的删掉元素数，显然可以转化为求最大的保留元素数。

按照题意，保留的数可以形成一些题目要求的序列。

由于我们并不需要考虑每个元素分到哪个组，而且要严格保证顺序，所以考虑记录在该元素前的还未匹配的该元素在序列中的前一个值（例如，当遇到 $8$ 时，查看在其前面的还未匹配的 $4$ 的数量），如果有，则将其向后转移。

所以我们需要一个数组来记录每个值尚未匹配且在它所属的序列中之前的数都匹配的个数即可。

设保留的数的个数为 $x$，那么答案为：$n-6\times x$。

```cpp
#include <bits/stdc++.h>
using namespace std;
int s[10]={4,8,15,16,23,42};
int n,a[500001],b[11];
int c[50];
int main(){
	scanf("%d",&n);
	for(int i=0;i<6;i++)
		c[s[i]]=i+1;
	b[0]=0x3f3f3f3f;
	for(int i=1;i<=n;i++){
		scanf("%d",&a[i]);
		if(b[c[a[i]]-1]>0)
			b[c[a[i]]]++,b[c[a[i]]-1]--;
	}
	printf("%d",n-b[6]*6);
	return 0;
}

```
