# 题解

- 这题的做法十分的精妙。

- 对于每一个数，我们不关心它在哪个子序列中，只关心它有没有出现和在几个子序列中。

- 我们可以记录下当前长度为 $1,2,3,4,5,6$ 的符合题目要求的子序列（或前面一部分）的个数。在遇到新的一个数时，我们看看还有没有刚好可以放下它的子序列。如果有，将那个子序列的长度 $+1$ 的子序列个数 $+1$，将那个子序列的个数 $-1$。

- 最后，$n$ 与 $6\times$ 完整的符合题目要求的子序列个数即为没用的数。

# 代码

- 由于用了许多三目运算符，可能有些阳间。

```cpp
#include <bits/stdc++.h>

using namespace std;

int n, a[500005], sum[500005];

int main()
{
	cin >> n;
	for (int i = 1 ; i <= n ; i ++)
	{
		int x;
		cin >> x;
		a[i] = (x == 4 ? 1 : (x == 8 ? 2 : (x == 15 ? 3 : (x == 16 ? 4 : (x == 23 ? 5 : 6)))));
	}
	for (int i = 1 ; i <= n ; i ++)
	{
		sum[1] += (a[i] == 1);
		int s = (a[i] != 1 && sum[a[i] - 1]);
		sum[a[i] - 1] -= s;
		sum[a[i]] += s;
	}
	cout << n - 6 * sum[6];
}
```

