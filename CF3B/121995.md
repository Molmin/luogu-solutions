因为这道题目 $n\le 10^5,m\le 10^9$，所以 $O(nm)$ 的 `背包DP` 会**严重超时，不予采用。**

发现每件货物的 $t_i$ **只可能有两种** （$1$ 和 $2$），因此采用**贪心算法。**

考虑重量为 $1$ 的物品取 $i$ 件，则重量为 $2$ 的物品必须取 $\min(\frac{(m-i)}{2},bl)$ 件。其中 $bl$ 是重量为 $2$ 的物品个数。

然后算出来的结果就是 $\sum^{i} _{j=1} a[j] + \sum^{n} _{j=i+1} b[j]$  。以这个结果更新最大值。

注意：因为要求的是最大价值，**所以 $a $ 和 $ b$ 数组一定要按照降序排序！** 因为明显对于两个同样重量的东西，**价值更大的更优**。

其中的两个 $\sum$ 可以通过前缀和优化成 $O(1)$ 。

然后输出方案在前缀和加的时候处理一下即可。具体看代码。

总时间复杂度（加上排序） $O(n \log n)$。

```cpp
struct node
{
	int x,p;
}a[2][100001];
int n,m,maxx,t1,t2,l[2],p1[100001],p2[100001];
LL s1[100001],s2[100001],ans,ans1,ans2;
int c1[10001],c2[10001];
bool cmp(node t1,node t2)
{
	return t1.x>t2.x;
}
int main()
{
	in(n,m);
	Fu(i,1,n)
	{
		in(t1,t2);
		a[t1-1][++l[t1-1]].x=t2;
		a[t1-1][l[t1-1]].p=i;//输入时给它分拨一下
	}
	sort(a[0]+1,a[0]+l[0]+1,cmp);
	sort(a[1]+1,a[1]+l[1]+1,cmp);//排序
	Fu(i,1,l[0])s1[i]=s1[i-1]+a[0][i].x,p1[i]=a[0][i].p;//前缀和，顺便处理位置
	Fu(i,1,l[1])s2[i]=s2[i-1]+a[1][i].x,p2[i]=a[1][i].p;//同上
	Fu(i,0,min(l[0],m))
	{
		int j=min(l[1],(m-i)/2);//枚举重量为2的个数
		if(i+j*2>m)continue;//注意判断，有坑
		if(s1[i]+s2[j]>ans)ans=s1[i]+s2[j],ans1=i,ans2=j;
        //更新答案
	}
	cout<<ans<<endl;
	Fu(i,1,ans1)cout<<p1[i]<<" ";Fu(i,1,ans2)cout<<p2[i]<<" ";//输出路径
	return 0;
}
//BY 线段树蒟蒻


```

---

下面是加强版↓，重头戏，$O(n)$ 解法

问：如果 $n\le 10^7,p_i \le 10^9$ 怎么办呢？

排序可以通过**基数排序** 解决，不需要 $O(n \log n)$。

时间复杂度从 $O(n \log n)$ 变成 $O(n)$。

基数排序代码：

```cpp
void radixsort()
{
	vector<node>t[256];int tp=0;
	Fu(i,1,4)
	{
		tp=0;
		Fu(j,1,m)t[(a[j].x>>(8*(i-1)))&255].push_back(a[j]);
		Fd(j,255,0)
		{
			Fu(k,1,t[j].size())
			a[++tp]=t[j][k-1];
			t[j].clear();
		}
	}
}
```


这个 $a$ 是待排序的结构体数组。

按照 `a[j].x` 关键字排序，没有违背基数排序**把一个数拆成多个关键字排序**的思想。

换句话说，只要用这个 `a[j].x` 的**关键字带着这整个`a[j]`排一下序即可。**

时间复杂度 $O(n)$ ，完全碾压楼下的解法。

~~不过还是 $O(n\log n)$ 的快排好写亿点。~~
