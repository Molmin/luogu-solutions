话说不难啊，为什么只有120人通过...（还有就是为什么用排序的题解没有一个用快排来排字符串内部？Pascal的除外）

思路很简单：

读入N及N个字符串。然后每一个字符串内部都要进行一次排序，每个字符串内部排好之后，再将全部字符串排一遍。这样下来，全部组成这个字符串的字母的数量相等的字符串就都应是相邻的了。所以我们只需统计，有多少个相邻的字符串是不一样的，就可以统计出有多少种不同的了。

```cpp
#include<bits/stdc++.h>
using namespace std;
long long i,n,sum,j,k;
string s[100000];
char t;
int main()
{
    cin>>n;                    //先输入N
    for (i=1;i<=n;i++)
    {
        cin>>s[i];                    //读入N个字符串
        sort(s[i].begin(),s[i].end());    //每一个字符串内部进行排序
    }
    sort(s+1,s+n+1);               //再将所有的字符串排序一次
    for (i=1;i<=n;i++) if (s[i-1]!=s[i]) sum++;                //最后，只需统计有多少个字符串互不相同就行了。有些人是一开始将sum定义为1，然后最后又减去一再输出，这样也没问题，只不过没必要啊。s[0]是空的，不可能跟s[1]一样，这样不就是第一种了吗...和将sum的初始值定为1效果一样。
    cout<<sum;         //输出
}
```