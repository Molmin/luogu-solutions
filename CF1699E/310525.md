[更好的阅读体验](https://www.cnblogs.com/LaoMang-no-blog/p/16457670.html)

---

[**CF link**](https://codeforces.com/problemset/problem/1699/E)

[**你谷 link**](https://www.luogu.com.cn/problem/CF1699E)

一道非常巧妙的 dp 题，但是顺着思路水到渠成并不是完全无迹可寻。

首先观察到题面中答案的形式是最值相减，提醒我们使用双指针的思想，即枚举最小值的过程中动态单调维护最大值，同时注意到本题中的操作类型是将一个数拆成两个数相乘的形式，所以可以想到是从大到小枚举，且思考加入控制了最大值，则要将比最大值大的数拆开，不是很好控制拆成那些数，拆的数的数量，所以考虑从大到小枚举最小值，同时控制最大值。

接下来考虑如何去控制最大值，如字面意思一般，我们希望让最大值尽量小，但是有不能在分解过程中产生比我们确定的最小值更小的值，单纯的用贪心似乎并不适合解决这个问题，所以我们考虑使用 dp。

本着求什么设什么的原则，我们设 $f_{i,x}$ 表示满足能将 $x$ 分解成多个数相乘且所有数都被包含在区间 $[i,v]$ 内的最小的 $v$，在具体实现过程中状态中的第一维 $i$ 可以压掉。接下来考虑转移，首先可以想到肯定是从大到小枚举 $i$，对于每个 $i$，任何一个 $x$ 的分解只有几种可能，要么根本不能分出 $i$，要么分出几个 $i$，要么能分不分，分别考虑转移，前后两种转移都是直接继承上一次的答案，$i$ 那维压掉后即不变，中间的转移考虑到一个数不一定只分出一个 $i$，所以可以考虑使用类似多重背包的优化，正向枚举直接转移，$f_x=\min\{f_x,f_\frac xi\}$。

然后我们发现上面的转移过程中 $f$ 数组随 $i$ 变小是单调变小的，即最大值不会变大，我们就可以进行上面的双指针，对于每个集合中存在的 $x$，标记 $f_x$，然后用一个指针指向最后一个标记，标记位置单调前移，每次计算答案，[代码](https://codeforces.com/contest/1699/submission/163163645)实现难度不大。