可以发现，小串 $s^\prime$ 一共匹配了 $n$ 次，而 $s^\prime$ 长度刚好为 $n$。

也就是说，我们可以让每次匹配相似的时候都匹配 $s^\prime$ 的不同位（因为只需匹配一位，也就是其他位根本不用管，单独考虑就行）。

比如当 $n=5,s=\mathbf{101011010}$ 时，如下面形式匹配：

第一次匹配，不去考虑其他位，在 $s^\prime$ 第一位填上 $s$ 的第一位，这时已经可以保证 $s^\prime$ 和 $s$ 的第一个子串相似了。

| $s^\prime$ | 1    |      |      |      |      |      |      |      |      |
| ---------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| $s$        | 1    | 0    | 1    | 0    | 1    | 1    | 0    | 1    | 0    |

第二次匹配：这时 $s^\prime$ 的第一位已经没有用了（因为只需匹配一位），我们将它向右移动一位匹配第二个 $s$ 的子串，并将 $s^\prime$ 的第二位填上对应的 $s$ 的这一位。

| $s^\prime$ |      | 1    | 1    |      |      |      |      |      |      |
| ---------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| $s$        | 1    | 0    | 1    | 0    | 1    | 1    | 0    | 1    | 0    |

第三、四、五次匹配同理，向右移动一位，再填上一位。

| $s^\prime$ |      |      | 1    | 1    | 1    |      |      |      |      |
| ---------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| $s$        | 1    | 0    | 1    | 0    | 1    | 1    | 0    | 1    | 0    |

| $s^\prime$ |      |      |      | 1    | 1    | 1    | 0    |      |      |
| ---------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| $s$        | 1    | 0    | 1    | 0    | 1    | 1    | 0    | 1    | 0    |

| $s^\prime$ |      |      |      |      | 1    | 1    | 1    | 0    | 0    |
| ---------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| $s$        | 1    | 0    | 1    | 0    | 1    | 1    | 0    | 1    | 0    |

这时就已经移动到了最后， 我们也得到了 $s^\prime=\mathbf{11100}$。

可以检验一下，这么填出来的答案能保证和 $s$ 的每个长度为 $n$ 的子串相似。

这样就已经可以做出答案了，但是我们还可以做得更快。

可以发现每次填上对应位的时候，对应的那个 $s$ 上的位数一定是奇数（从 $1$ 开始计算），所以直接在读入时输出奇数位或者读入完输出奇数位即可。

主要部分（`ch`是 $s$ 串）：

```cpp
scanf("%d", &t);
for (int i = 1; i <= t; ++i) {
    scanf("%d%s", &n, ch + 1);
    for (int j = 1; j <= 2 * n - 1; ++j) {
        if (j % 2 == 1) cout << ch[j]; // 奇数位就输出
    }
    puts(""); // 换行
}
```

