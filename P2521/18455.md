看到各位dalao都用的是x-y坐标排序...

这里就来安利一发自己的极角序..

极角序最大的好处就是不仅可以处理凸壳, 还可以处理整个凸包.

比如有一道例题是CF70D, 是动态凸包裸题, 边界条件要比这题扯淡..

当然写题解并不只是因为极角序, 还因为一些C++的奇怪操作让我特别想吐槽.


说下大体思路,

首先肯定是要将所有操作反过来 变删除为插入 然后就是用平衡树维护凸包了嘛

只不过这里用的比较是极角序而已

学过半平面交的人大概对极角序很熟悉了.

不少人都喜欢用atan2, 但是我一直喜欢用叉积.

总觉得atan2会出一些奇怪的精度问题.

这样就要分x轴上下来进行讨论, 不然会出问题.

这里只要求上凸壳所以极角序都可以简化, 不用判断x轴上下了

而且出题人做了各种各样的保证就比较舒服了...

很多条件就不用考虑了, 比如要把set首尾相接之类的就用不到了


那么大体来说就是这么一个比较函数:

```cpp
inline bool operator <(const vec &A,const vec &B){
    if(A.x==B.x&&A.y==B.y) return 0;
    vec a=A-sq,b=B-sq;
    int d=dcmp(a*b);
    if(!d){
        int dd=dcmp(len(a)-len(b));
        if(!dd) return dcmp(a*vec(0,1))>0;
        return dd>0;
    } return d>0;
}
```
因为\*弱排序原理\*导致这个函数写的特别扭曲..

其中这个sq是个全局变量, 我们只要保证这是一个一直在凸包中的点就ok

而刚开始会给一个三角形[(0,0),(n,0),(x,y)], 所以($\frac n2$,0)肯定是在凸包上的, 而且这样的a,b向量都在x轴的上方, 极角序也好写. 所以令sq=(n\*0.5,0)就非常合适了.


周长的话就加点的时候顺便维护了就行.

具体的细节和一些吐槽可以见我的[blog](http://blog.csdn.net/enzymii/article/details/79108684)

~~(其实你写题解的目的就是为了安利blog吧~~
