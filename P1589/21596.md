这个题吧，可能好多人都没看懂样例，我给大家解释一下

对于样例第二行1 6：所描述的泥泞路段是1到2,2到3,3到4,4到5,5到6

这样一个长度为5的路段，当然也可以见到的看作取起点不取终点

或者是取终点不取起点。

这样的话，我们就可以按起点排一边序，然后从头到尾算一遍啦

具体解释在代码中2333



------------

2022/7/31 加点内容（其他内容是 2017-04-30 的）

有人评论问了我：


5 3
0 10
2 9
3 8
4 7
5 6
-> 4

为啥是 1 1 1 1 1 1 1 1 1 1 0

我发现是我以前的内容写的太拉了，自己都看不懂了，所以补充一下。

首先这个题如果泥泞路两端是1和3，则说明是一个1到2，2到3的长度为2的泥泞路，故而一个长度为2的木板可以覆盖1到3。这个明白之后就要简单很多了。

在这里我这个1表示的是区间，可以见下图：

![示意图](https://cdn.luogu.com.cn/upload/image_hosting/clezwyk5.png)

对应这个数据

3 3
1 3
4 6
7 9
-> 3

0 1 1 0 1 1 0 1 1 0 0

这样应该就看明白了，1表示这个区间是泥泞路，比如1-2是泥泞路，而不是1这个点是泥泞路。

那么
5 3
0 10
2 9
3 8
4 7
5 6
-> 4

1 1 1 1 1 1 1 1 1 1 0

自然对应下图：

![示意图](https://cdn.luogu.com.cn/upload/image_hosting/b4rxyvni.png)

思路也再解释一下吧

1. 按起点从小到大排序

2. 逐个枚举泥泞路
	
	a. 如果这个泥泞路在铺上个泥泞路的时候就给铺了，就没必要管了
    
    	i.用个变量记录一下上个泥泞路铺完后多出来了多少就可以
        
   b. 算一下铺这个路要花多少

3. 结束

------------


------------



```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#include<algorithm>
#include<cmath>
using namespace std;
int n,m,tp,ans=0;
struct edge //结构体记录每一段的起点、终点
{
    int l;
    int r;
};
struct edge E[100011];
int cmp(edge a,edge b)//排序（按起点从小到大） 
{
    return a.l<b.l;
}
void work()
{
    E[0].r=-0x3f3f3f3f;//这个赋值要比最小的起点小就行 
    int la=0;//记录上一次所铺的是哪一段 
    for(int i=1;i<=n;i++)
    {
        if(E[i].r<=E[la].r+tp) //tp记录在铺上一段时额外铺的长度 
            continue;//如果现在要铺的那一段被上一段包含，就可以跳过了，因为已经铺好了 
        while(E[i].l<=E[la].r+tp)//如果这次铺的背上一次部分包含 
        {
            E[i].l++;//就只铺剩下的，这里可以O（1）解决的，只不过我智障就写了个while 
        }
        la=i;//记录一下这次铺的是第几段 
        //下面就是计算会超出多少和该段需多少木板了 
        if(((E[i].r-E[i].l+1)%m)==0) tp=0;
        else tp=m-((E[i].r-E[i].l+1)%m);
        if(tp==0) ans+=(E[i].r-E[i].l+1)/m;
        else ans+=(E[i].r-E[i].l+1)/m+1;
    }
}
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++)
    {
        scanf("%d%d",&E[i].l,&E[i].r);
        E[i].r--;
    }
    sort(E+1,E+1+n,cmp);
    work();
    printf("%d",ans);
    return 0;
}
``` 


------------

送给大家一些我自己造的例子，希望能帮到大家，不用谢我 

3 3
1 6
13 17
8 12
-> 5

0 1 1 1 1 1 0 0 1 1 1 1 0 1 1 1 1 1 0 0 0 0 0 0 0 0 0 0 0

3 3
1 4
2 6
9 18
-> 5

0 1 1 1 1 1 0 0 0 1 1 1 1 1 1 1 1 1 1 0 0 0 0 0 0 0 0 0 0

3 3
1 3
4 6
7 9
-> 3

0 1 1 0 1 1 0 1 1 0 0

3 3
1 10
2 9
3 8
-> 3

0 1 1 1 1 1 1 1 1 1 0

4 4
1 4
2 5
3 6
4 7
-> 2

0 1 1 1 1 1 1 1 1 0

5 3
0 10
2 9
3 8
4 7
5 6
-> 4

1 1 1 1 1 1 1 1 1 1 0

4 4
0 10
2 9
3 6
4 7
-> 3

1 1 1 1 1 1 1 1 1 1 0

6 165
56 1651

156 158

165  18478

145614 156156

158618 158888

165418 168156

-> 195


