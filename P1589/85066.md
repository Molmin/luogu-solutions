## 我一直相信渣渣写的题解，对谁都友好。

## 0.前言
典型的贪心算法解题，（~~当然我这些天是从络谷中专挑贪心练习~~），可能直接给我这题，我也不知道会用什么算法。

## 1.思路
 

- step 1：将泥泞小路针对起点排序。使用一个 **结构体+自带`sort`** 就可以实现。
- step 2：得到起点有序的小路之外，就需要考虑怎么铺路了。该怎么铺呢？主要就是两种情况：
  -  情况1:每次恰好只铺了自己的路。而且也刚刚好铺完，这样就不会导致与后面的铺路重复。比如“**1 3**”起点是1，终点是3，这样用一个长度为3的木板，一次就可以铺好。同理，“1 6”就只需要完整的2块木板。
  - 情况2：世界不可能如此完美，那么遇到不能整铺的情况怎么办？例如：“1 4”用长度为3的模板就需要两块。（1-3用一块，3-4再用一块。但是很显然，3-4这块木板是多余了2米。）我们就需要考虑如何最优化这种铺法多余的木板。很简单，贪就是了！**如果当前铺的终点的比下次要铺的起点要远，那么我们就用这次的终点接着铺，而不是从下次的起点开始铺**。无论如何，这样都能保证铺路木板最少化（因为更短的路需要更少的木板。）例如，有两段路都需要铺，分别是“3-7，8-12”（使用长度为3的木板），可以看到（3-6-9-12）只需要3块木板，如果是分开铺（3-6-7，8-11-12），则需要4块木板。

## 3.实现
```c
#include<iostream>
#include<algorithm>
using namespace std;
const int maxN = 10005;
typedef struct{
	int s,e;
}Road;
Road road[maxN];

bool cmp(Road r1,Road r2){
	return r1.s < r2.s;
}

int main(){
	int n,l;
	cin >> n>> l;
	for(int i = 0;i< n;i++){
		cin >> road[i].s >> road[i].e;		
	}
	int res = 0;
	sort(road,road+n,cmp);
	
	//从road[0]开始铺 
	int prioE = 0; //上一次的结束 
	for(int i = 0;i<n;i++){
		int m = 0;//铺当前路 需要的模板数 
		int len ;
		if(road[i].e <= prioE){//上一次就铺完了 
			continue;
		}
		if(road[i].s < prioE) {//如果本次开始小于上次结束，则一起铺，
			len = road[i].e - prioE;
			m +=(len/l);
			if(len%l!=0)//有余数加一 
				m++; 
			prioE += m*l;//实际铺到了哪里 
		}
		else{
			len = road[i].e - road[i].s;
			m +=(len/l);
			if(len%l!=0)//有余数加一 
				m++; 
			prioE = road[i].s + m*l;//实际铺到了哪里 
		}					
		res+=m; 		
	}
	cout << res<<"\n";
}
```

## 4.测试用例
```java
3 3
3 7
8 12
13 19
5

1 1
1 1000000
999999

3 1
1 6
13 17
8 12
13

3 3
1 6
13 17
8 12
5

3 10000
1 6
13 17
8 12
1
```
