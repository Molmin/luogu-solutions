## 扯在前面

我们老师刚讲过的题目，很考验思维，本蒟蒻WA了十发才过，然后看到题解里只是指出了特殊情况没多解释，可能有人看不懂，特来分享一下

首先题目就很有意思，思考的过程也很有趣，想把所有情况思考全思考对是件很不容易的事


------------
# 正文

##  题意：

两人取n堆数量不定的石子，当某一方取完后剩下了两堆一样的或本轮无石子可取（当前石子数为0），则失败。问给出石子各堆的数量，求先手胜还是后手胜。

##  分析：

首先，站在博弈论的角度，或者说把自己当做参与者，思考一下什么情况下是对自己最有利的，也就是说什么情况下自己必胜

然后抱着这样的心态，我们可以手玩几组样例。

**我们就可以知道**：
1. 若场上有两堆石子，一堆数量多一堆数量少，那我们宁可取少的，因为那样出现取完后两堆相同的概率最低；

1. 当两边都这样想时，就会不停取，一直取到一种极端情况，那就是每堆石子的数量是以一递增的，那时游戏就结束了，因为不管再怎么取，都会出现两堆相同数量的石子（两堆0也是）；
1. 当场上已经有两堆相同的石子时，下一次操作的人必取两堆其中之一，因为他如果不取，取完后这两堆相同，他就输了；
1. 若刚刚那人取完后，场上仍存在两堆相同的，他还是输了，即当时还存在一堆石子数量是刚刚那两堆数量减一或场上存在另外两堆以上数量相同但与这两堆数量不同的石子
1. 若场上存在三堆及以上石子时，先手无论怎么取，都会输，原因同上

**然后可得出情况如下可以判断某方必胜：**

1. 场上石子数已经是按1递增的
1. 场上存在三堆及以上石子相等
1. 场上存在两堆石子相同且还有一堆石子数比这两堆少一
1. 场上存在两堆0

这些先判断出来，剩下的统计原来的石子总数与极端情况的石子总数之差，**若为偶数则后手赢，反之则先手赢**

# 代码
```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<cstring>
#include<cstdlib>
#include<queue>
#include<algorithm>
#define maxn 1000100

using namespace std;

int n,a[maxn],tot,cnt,js;

int main(){
	scanf("%d",&n);
//	if(n==1 &&a[1]==0){
//		cout<<"cslnb";
//	    return 0;
//	} 
	for(int i=1;i<=n;i++){
		scanf("%d",&a[i]);
		tot+=a[i];
	}
	sort(a+1,a+n+1);
	for(int i=1;i<=n;i++){
		if(a[i]==a[i+1]) js++;
	}
	if(js>=2){
		cout<<"cslnb";//有两堆以上一样的时后手必赢 
		return 0;
	} 
	if(js==1){
		for(int i=1;i<=n;i++){
			if((a[i]==a[i+1] &&a[i-1]+1==a[i] && i!=1) ||(a[i]==a[i+1] &&a[i]==0)){
			cout<<"cslnb";//此时先手无所下手，后手赢 
		    return 0;
			}
		}
	} 
//	if(n==2 &&((a[1]==1&&a[2]==0) ||(a[2]==1 &&a[1]==0))){
//		cout<<"sjfnb";
//		return 0;
//	}
	for(int i=1;i<=n;i++){
		cnt+=i;
	}
	cnt-=n;
	if(tot-cnt==0){
		cout<<"cslnb";
		return 0;
	}
	if((tot-cnt)%2==0) cout<<"cslnb";
	else cout<<"sjfnb";
	return 0;
}
```
请批评指正