这题大家都很容易想到**枚举+判质数**，但你也看到了， $q$ 与 $l_i$ , $r_i$ 都小于等于 100000 ，很显然，这样肯定超时。

好了，现在我们对判质数进行优化：**筛质数**。什么是筛质数呢？原理很简单：很显然的，先开一个数组 $a$ ，从2开始遍历，每当遇到 $a_i==0$ ，这样这个数就是质数，从这个质数开始遍历，将这个质数的整数倍的数的对应的数组变为1（这样就明白上文判质数的道理了，因为遍历到那个数那个数对应的数组还为0，就表示他没有因数，也就是质数了）。但大家要注意，不能从1开始遍历（为什么自己想想），从2开始遍历并将 $a_1$ 设为1。演示一下大家看看：

| 遍历数字\编号 | 1 | 2 | 3 | 4 | 5 | 6 |
| -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: |
| 初始化 | 1 | 0 | 0 | 0 | 0 | 0 |
| 2 | 1 | 0 | 0 | 1 | 0 | 1 |
代码：

	m=(int) sqrt (n);
	for (i=2;i<=m;i++){
    	if (a[i]==0){
        	for (j=i*i;j<=n;j+=i) a[j]=1;
        }
    }


我们还可以对枚举做出优化：**前缀和**。前缀和是什么呢？即计算 $l$ 至$r$ 这一段区间的和。先计算从头到每一个数的之间的数的总和，最后输出时，把 $a[r]-=a[l-1]$ 即可（自己可以自己想一想）。代码：

	for(i=1;i<=n;i++){
 	   f[i]+=f[i-1];
	}
    for(i=1;i<=m;i++){
        int l,r;
        scanf("%d%d",&l,&r);
        printf("%d\n",f[r]-f[l-1]);
    }
    
好了整合一下，代码来袭：

	#include<stdio.h>
	using namespace std;
	int a[100005],b[100005];
	int main(){
		int n,i,j;
		scanf("%d",&n);
		a[1]=1;//筛质数
		for(i=2;i<=50000;i++){
			if(a[i]==0){
				for(j=i+i;j<=100000;j+=i)a[j]=1;
			}
		}
		for(i=1;i<=100000;i++){//前缀和
			b[i]=b[i-1];
			if(a[i]==0&&a[(i+1)/2]==0)b[i]++;//判断
		}
		for(i=1;i<=n;i++){//前缀和输出
			int l,r;
			scanf("%d%d",&l,&r);
			printf("%d\n",b[r]-b[l-1]);
		}
		return 0;
	}
    
OK，拜拜~~