# 题意以及数据
显然这道题是一个模拟题。

因为从数据上来看 $Q \le 100000$ 以及 $a[i] \le 100000$。


所以说，如果每做一次，对于每一个数进行素数判断的话，显然 $O(n ^ 2)$ 是会被卡掉的，所以就要先用[埃氏筛](https://baike.baidu.com/item/%E5%9F%83%E6%8B%89%E6%89%98%E6%96%AF%E7%89%B9%E5%B0%BC%E7%AD%9B%E6%B3%95/374984?fromtitle=%E5%9F%83%E6%B0%8F%E7%AD%9B&fromid=5677377&fr=aladdin)对于素数进行筛选，这样子会便于我们后续的判断。

放上埃氏筛部分代码：
```cpp
a[1] = 1;
for(int i = 2; i <= 100000; i++){
    for(int j = 2 * i; j <= 100000; j += i){
        a[j] = 1;
    }
}
```
# 前缀和部分
为什么此处的 $a[1]$ 要设置为 1 呢？这就和此题所要用到的前缀和有关了，这一题我们是枚举从 $start$ 到 $end$ 这一区间内的所有素数，并且用一个 $ans[]$ 数组进行储存。那么此时，我们通过观察埃氏筛的结果，显然 $a[2] =  0$，那么对于我们的前缀和来说比较麻烦，因为 2 是素数，我们需要计数，但是 2 不是奇数，所以 $i \ne 2$ 是必须要判断的一个条件，那么此时对于 $a[2]$ 的操作必须要和不符合条件的数进行同样的操作，也就是下面贴的这部分代码：
```cpp
for(int i = 2; i <= 100000; i++){
    if(a[i] == 0 && a[(i + 1) / 2] == 0 && i != 2){
       ans[i] = ans[i - 1] + 1;
    }
    else ans[i] = ans[i - 1]; 
}
```
这就是前缀和的代码了，所以说核心的代码已经推出来了，那么这道题可以很容易地AC了。

# 总结
这道题从题意到解答都是很简单的思路，主要需要掌握的知识点在于埃氏筛以及前缀和只要掌握了这些知识点，就很容易切掉这道题目了，下面贴上AC的代码以及部分注释：
```cpp
#include<bits/stdc++.h>

const int N = 100009;

using namespace std;

int T;
int a[N],b[N];

int main (){
    
    a[1] = 1;

    for(int i = 2; i <= 100000; i++){
        for(int j = 2 * i; j <= 100000; j += i){
            a[j] = 1;
        }
    }

    for(int i = 2; i <= 100000; i++){
        if(a[i] == 0 && a[(i + 1) / 2] == 0 && i != 2){
            b[i] = b[i - 1] + 1;
        }
        else b[i] = b[i - 1]; 
    }

    scanf("%d ", &T);
    while(T--){
        int l, r;
        scanf("%d %d ", &l, &r);
        printf("%d\n", b[r] - b[l - 1]);
        //此处的"l - 1"是因为 l 是闭区间，要包括进来
        //不然可能会减少一个符合条件的数
    }

    system("pause");

    return 0;

}
```