这是一道二分答案题，熟悉二分答案的大佬可以跳过下面一段：

------------

### 二分答案介绍：

二分答案就是说用 **二分** 的方法枚举答案，具体请看例子：

我现在在一堆木头中找最长的，我可以用一下方法：

1. 最找到可行范围内最中间的数,用 $check$函数判断他是否可行，分两种情况：
- 如果可行（$check$函数返回$1$）标记，返回 $chazhao(mid,r)$
- 如果不可行（$check$函数返回$0$）标记，返回 $chazhao(l,mid)$

表如下：

| 1 | 2 | 3 | 4 |5  | 6 | 7 | 8 | 9 | 10 |
| -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: |
| 1 | 1 | 1 | 1 | 1 | 0 | 0 | 0 | 0 | 0 |

----------

### 代码：

#### 1.$check$ 函数

```
bool check(int len)
{
	int cnt=0;
	
	for(int i=0;i<n;i++)
	{
		cnt+=a[i]/len;
	}
	
	if(cnt>=k)
		return true;
	
	return false;
}
return 0;
}
```
原理是：长度为 $len$ 的情况下如果可以分到的段数比 $k$ 多，返回$true$,否则返回 $false$



------------

#### 2.$chazhao$ 函数

```
int chazhao(int l,int r)
{
	if(r-l<=1){
		if(check(r))
			return r;
		if(check(l))
			return l;
		return 0;
	}
	
	int mid=(r+l)/2;
	
	if(check(mid))
		return chazhao(mid,r);
	else
		return chazhao(l,mid);
}
```

逻辑是：

- 当 $r-l<1$ 时：

如果 $check(r)$可以的话，返回 $r$,如果 $check(l)$可以的话，返回 $l$,否则返回 $0$。

注意：这里一定要先判断 $r$,再判断 $l$，因为 $r>l$,要先判断大的。



- 否则先算出 $mid$ ,然后按上面的逻辑算。

主函数没有技术含量，可以自己写，检验自己是否真正会了。