###### 题目翻译：Mikhail在一架2D飞机（我也不知道是啥）上行走。他可以往上走也可以往右走。你得到了Mikhail的一系列动作。他认为这个序列太长了，他想使它尽可能短。

###### 在给定的序列中，向上移动由字符U描述，右移动由字符R描述。Mikhail可以用对角线移动(描述为字符D)替换任意一对连续的移动，RU或UR。

###### 您的任务是打印替换后移动序列的最小可能长度。

这道题其实很简单，给新手练手还是不错，因为它只是需要求缩减之后序列的长度，就是说要求序列的总长度减去可以进行合并的个数。我们只需要从头到尾模拟一遍，找出有几个可合并的序列。（亲测暴力能过）

下面贴代码
```cpp
#include<bits/stdc++.h>
using namespace std;
char a[1000010];//再不爆空间的基础上尽量多开数组，血的教训
int main()
{
	int n,count=0;//count记录可合并的串数
	cin>>n;
	cin>>a+1;//字符串a从1的位置开始读入,这样就可以把i从1到n循环，不然要从0到n-1循环
	for(int i=1;i<=n;i++)
	{
		if((a[i]=='U'&&a[i+1]=='R')||(a[i]=='R'&&a[i+1]=='U'))//可以U在前也可以R在前
		{
	    	count++;
	    a[i]=' ';
	    a[i+1]=' ';//为了避免重复匹配，把匹配过的变成空格（实际上除了U或R都可以变）
		}
	}
	cout<<n-count;
}
```

