又一道很好的拆式子题目：  
连续数的拆分，如果暴力枚举的话，复杂度为$O(n^{2})$绝对TLE,我就不给代码了。  
于是我们考虑拆式子，我们发现连续的整数，可以直接等差数列公式（~~高斯真是个好人~~），于是原式就变成了这个亚子：  
$$\dfrac{(L+R)(R-L+1)}{2}=n$$  
可是如果暴力枚举$L$和$R$的话  还是会TLE，复杂度并没有减，于是我们继续化简：   
$$(L+R)(R-L-1)=2n$$    
$$\text{令}L+R=m\quad R-L+1=s$$   
$$\text{则}m*s=2n$$  
如果要满足这个式子成立的话，也就必须满足L和R是整数，也就是说：   
$$(s-m+1)\mod2=0$$  
$$(m+s-1)\mod 2=0$$   
然后我们就可以开心的枚举啦：  
我们可以随便枚举$m$和$s$中的任意一个数，然后直接按上面的判断直接判断加上就可以了，这样的复杂度是$O(n)$,卡一卡也是可以过得，但是有没有更好的方法呢？  

其实m可以不用枚举到n,我们来考虑m的上界，因为它和$s$要是$2n$的因数，所以这两个数最大不会超过$\sqrt {2n}$,如果超过了，就相当于是把$m$和$s$调换了一个位置（这里自己思考一下）,于是复杂度就可以简化成
$O(\sqrt{2n})$  
代码来啦
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;//三年OI一场空，不开longlong见祖宗
ll sum;
int main()
{
    ll n;
    scanf("%lld",&n);
    for(register ll i=1;i<=sqrt(2*n);i++)//这里的i就相当于m
    {
        if((2*n)%i!=0)continue;//首先要保证s为整数
        else
        {
            ll j=(2*n)/i;//这个j相当于s
            if((j+i-1)%2==0&&(i-j+1)%2==0)sum++;//判断+累加和
        }
    }
    printf("%lld\n",sum);
    return 0;//华丽结束
}
```
**update:**
2020.05.09 修改了一个小$bug$