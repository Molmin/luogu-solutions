[**原题传送门**](https://www.luogu.com.cn/problem/AT_abc127_d)
## 题面：
给定一个长度为 $n$ 的序列 $a$，和长度为 $M$ 的序列 $b$ 和 $c$，表示你最多可以选择 $a$ 中 $b_i$ 个数变为 $c_i$。让你求出在经过数次操作后，$A$ 序列的总和最大是多少。
## Solution:
我们首先考虑，如果有两个数 $a_i$ 和 $a_j$，并且 $a_i \le a_j$，$a_i \le a_j \le c_k$，那么最优策略是把 $a_i$ 替换成 $c_k$。因为把 $a_i$ 替换成 $c_k$，增加的值是 $c_k - a_i$，如果把 $a_j$ 替换成 $c_k$，增加的值是 $c_k - a_j$。比较 $c_k - a_i$ 和 $c_k - a_j$，因为 $a_i \le a_j$，所以 $c_k - a_i \ge c_k - a_i$。从中，我们可以发现这个贪心策略：**如果有几个数同时比可以替换的数小，那么把最小数替换成这个数增加的值最大**。有了这个结论，问题迎刃而解。我们要**让最小的数替换成最大的数，把第二小的数替换成第二大的数，把第三小的数替换成第三大的数，以此类推，直到原本的数比可以替换的数大**。这道黄题变成了纯模拟题，步骤如下。

- 用数组存放 $a$，用结构体 $f$ 数组存放 $b$ 与 $c$，之后把 $a$ 从小到大进行排序，把 $f$ 按照 $b$ 从大到小进行排序。
- 我们设 $tot$ 为**当前指向可以替换的数字在 $f$ 数组中的下标**，它最初默认指向第一个可以替换的数。
- 枚举每一个 $a_i$，如果 $a_i$ 比 $f_{tot}$ 中可以替换的值大，就直接终止循环。因为，$a$ 数组从小打大，$f$ 数组从大到小，而 $f_{tot}$ 之后的数只会越来越小，一定比 $a_i$ 大。
- 把当前的 $a_i$ 替换成 $f_{tot}$ 中替换成的值，并且把 $f_{tot}$ 中可以替换成的次数减 $1$。如果当前替换完成后，$f_{tot}$ 中可以替换的次数已经为 $0$，就把 $tot$ 指针后移一格。
- 重复执行第三步，直到枚举玩每一个 $a_i$ 或中途退出。
- 累加 $a$ 数组中总和。

思路还是有点麻烦，~~主要是太啰嗦了~~，代码更简单易懂。
## Code:
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 1e5 + 1;
int n, m;
ll a[N];
struct node{
	ll b;//可以替换成的值 
	ll c;//可以替换的次数 
}f[N];
bool cmp(node x, node y) 
{
	return x.c > y.c;//按照可以替换成的值从大到小 
}
int main()
{
	cin >> n >> m;
	for(int i = 1; i <= n; i ++)
		cin >> a[i];
	for(int i = 1; i <= m; i ++)
		cin >> f[i].b >> f[i].c;
	sort(a + 1, a + 1 + n);//a数组从小到大 
	sort(f + 1, f + 1 + m, cmp);//f数组从大到小 
	int tot = 1;//默认指向f数组中第一个位置 
	for(int i = 1; i <= n; i ++)
	{
		if(a[i] > f[tot].c) break ;
		//如果a[i]比f[tot]中可以替换的值大，直接退出 
		a[i] = f[tot].c;//替换a[i]的值 
		f[tot].b --;//当前可替换的次数-1 
		if(! f[tot].b) tot ++;
		//可以替换成当前值的次数已经用尽，指针指向下一个位置 
	}
	ll ans = 0;
	for(int i = 1; i <= n; i ++)
		ans += a[i];//累加 
	cout << ans;
	return 0;
}

```
