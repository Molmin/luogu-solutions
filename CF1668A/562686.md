## 题意

有一个 $n \times m$ 的矩阵，现在你在 $( 1,1 )$，你可以朝上、下、左、右四个方向移动，但不可以连续朝某个方向移动，问最少需要移动几次你才可以到达 $( n,m )$，如果无法到达 $( n,m )$，输出 $-1$。

## 思路

要往某个方向移动两格，比如要从二行一列到二行三列，可以这样走：$(2,1)\to(2,2)\to(1,2)\to(1,3)\to(2,3)$，花了四步。

大概就是到 $(2,2)$ 时不能直接往右，从上面绕一下就可以了。

发现只要有至少两行和两列就一定可以通过上述绕一下的方法到达终点。

因此无解的情况为：仅有 $1$ 行或仅有 $1$ 列，且到达终点需要至少移动两步（这只能是同方向的，而题目要求不可以连续朝某个方向移动）。

再考虑最优解：

当 $n=m$ 时不需要考虑连续朝某个方向移动，只需要靠下右交替或右下交替即可到达终点，花费 $n \times 2-2$。

多余的 $m-n$ 列或 $n-m$ 行再按照上述绕一下的方法走即可（走两格为一个周期，花费四步）。

然后再加上余数即可。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int T,n,m,x; 
signed main(){
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	cin>>T;
	while (T--){
		cin>>n>>m;x=abs(n-m);
		if ((n==1&&m>2)||(n>2&&m==1)) cout<<"-1\n";
		else cout<<(min(n,m)*2-2)+x/2*4+x%2<<'\n';
	}
	return 0;
}
```
