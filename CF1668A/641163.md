### [原题传送门](https://www.luogu.com.cn/problem/CF1668A)


## 题目描述：

有一个 $n \times m$ 的矩阵，现在你在 $( 1,1 )$，你可以朝上、下、左、右四个方向移动，但不可以连续朝某个方向移动，问最少需要移动几次你才可以到达 $( n,m )$，如果无法到达 $( n,m )$，输出 $-1$。

题面不是很难理解，然后我们来寻求解决方案。

## 解决方案

从特殊情况入手，再到一般情况（惯用思路）：

$1.$ 无解情况：当棋盘大小为 $1 \times x (x > 2)$ 的时候，由于不能出界，就必须朝着目的地方向移动至少两步，与题意矛盾，故此时无法到达目标。

$2.$ 当 $n=m$ 时：不需要考虑连续朝某个方向移动，只需要靠下右交替或右下交替即可到达终点，花费 $n \times 2-2$。

$3.$ 普遍情况：若 $n \not = m$，不妨假设 $n <= m$。首先还是沿 $45$ 度角方向，斜向下走到最远的位置，消耗 $2 \times (n - 1)$ 步；剩下 $m−n$ 个格子横着走。为了满足题目要求，最后这一段需要上下摆动行走，以避免连续两步方向相同。需要区分剩余步数是奇数还是偶数。剩余奇数步的话可以少摆动一次。

## 附代码 ~~（我是大蒟蒻）~~：
```cpp
#include<iostream>
#include<algorithm>
using namespace std;
int a,n,m,ans;
int main(){
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);//输入优化
    scanf("%d",&a);
	while(a--){
		cin>>n>>m;
		ans=0;
		if(n<m)swap(n,m);
		if(m==1&&n>2) printf("-1\n");
		else{
			ans+=(m-1)*2;
			ans+=(n-m)/2*4;
			if((n-m)%2) ans++;
  			printf("%d\n",ans);
		}
	}
	return 0;
}
```
