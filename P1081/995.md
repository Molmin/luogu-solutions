50分
对于50%的数据还是很好骗的。每次旅行都直接模拟行走，每次找一个最近或次近，时间O(N\*N)。

对于第一问直接枚举起点。时间复杂度为O(N\*N\*M + N\*N\*N)

70分
发现50分算法主要是 每次都要找下一个城市 耗费了太多时间，于是干脆直接预处理，O(N\*N)，总时间O(N\*M + N\*N)

满分
还是想想改进。。。70分算法的预处理太傻逼了。。其实我们是要每次找到一个海拔与当前城市相差最少的城市。所以算法就有很多种了……比如离散化+链表，双向链表，平衡树（其实用set的话程序比双向链表还好打，因为二分stl都给你弄好了。。）

这里主要介绍下双向链表的做法：就是按高度排序，然后链起来。按城市原始位置从左到右处理接下来的城市是哪个，然后将自己删掉（因为接下来就没用了）。如何找接下来的那个？就是往链表的左右两边找两层，记一个最近和次近。

然后预处理就可以优化到O(N)

then？？？

发现其实这是一棵树。。。

于是倍增

预处理已经处理出2^0的情况了。接下来直接动规就好了，就可以预处理出每个点的2^i的父亲是谁，以及A走了多少，B走了多少。

then？？？

现在问题就是给定总路程要怎么求出AB走的路程。

问题可以转化成给定总路程求走了几次。然后就可以用上先前的预处理。假设走了t次，则t肯定可以表示成二进制，而且只有logn位的二进制数。于是可以枚举这一位取0还是1。调用先前处理的数组，看加上所增加的路程后会不会超出x，不会就是1，会就是0。

于是问题就完美解决了！
