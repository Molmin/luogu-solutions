###这个题和楼下大佬们所说的一样，难点就在初始化。

首先要把距离每个点的最小点和次小点找出。

然后对于跑图我们用倍增处理一下即可。

同样的A[i][j]记得是A走2^j轮之后的距离。（B一样）

f[i][j]记得是从i走2^j个两步之后点（重点）


#预处理出最小点和次小点。

这个题其实我一开始想的是暴力求点，然后没看到数据范围（滑稽），后来有大佬告诉我这样的时间复杂度时O（n^2），我就放弃了。

我们用双向链表。

先不管方向，将所有城市排序之后，它的最小和次小点一定在i-1,i-2,i+1,i+2的位置，所以说如果排序我们的处理会方便很多。

##关于方向

首先我们记下每个城市排序之后的位置。

然后从第一个城市开始向i-1,i-2,i+1,i+2处找点。

很显然，由于是第一个点，这个时候找到的任何点一定在它东边。

###同样的，找完第一个点后将第一个点删除，那么第二个点自然成为了第一个点，同理。

这样我们便在O（n）的复杂度内完成了预处理。

#倍增的初始化要注意的的地方。

对于f，记得一定是2^j个两步之后所到达的点，与A,B谁开车无关。

对于B，由于开始一定是A先跑，所以我们要用次小点的最小点之间的距离初始化。

具体倍增思路与楼下差不多，这里我就只贴出初始化的代码。

#最小点与次小点

```cpp
inline void prepare(int u,int i){//u记得是排序后的位置，i为排序前的位置
    if(pre[u])min1[i]=H[pre[u]].p;
    if((nxt[u]&&H[u].h-H[pre[u]].h>H[nxt[u]].h-H[u].h)||!pre[u])min1[i]=H[nxt[u]].p;
    if(min1[i] == H[pre[u]].p){
        if(pre[pre[u]])min2[i]=H[pre[pre[u]]].p;
        if((nxt[u]&&H[u].h-H[pre[pre[u]]].h>H[nxt[u]].h-H[u].h)||!pre[pre[u]])min2[i]=H[nxt[u]].p;
    }
    else {
        if(pre[u])min2[i]=H[pre[u]].p;
        if((nxt[nxt[u]]&&H[u].h-H[pre[u]].h>H[nxt[nxt[u]]].h-H[u].h)||!pre[u])min2[i]=H[nxt[nxt[u]]].p;
    }
    nxt[pre[u]]=nxt[u];
    pre[nxt[u]]=pre[u];
}
```
#倍增初始化

```cpp
void Init(){
    for(int i=1;i<=N;i++){
        if(min2[i])A[i][0]=abs(data[min2[i]]-data[i]);
        if(min1[i])B[i][0]=abs(data[min2[i]]-data[min1[min2[i]]]);//走一轮B是从次近点向次近点的最近点走 
        f[i][0]=min1[min2[i]];
    }
}
```