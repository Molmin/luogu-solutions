这是个很有启发的题。

首先很容易想到直接爆搞的方法（50分），接着会发现对于从每个城市出发小A到达的下一个城市一直是固定的，便可以预处理，小B的同理（70分）。接下来就有问题了，直接一步一步模拟都会TLE，要优化的话只能往log方面想，而又需要知道小A小B经过的距离因此还是需要一步一步走，便只能想到运用[倍增](http://oj.luogu.org:8888/wiki?name=%E7%AE%97%E6%B3%95%EF%BC%9A%E5%80%8D%E5%A2%9E&flag=y)思想往前跳了。但又会有小A小B的交替，因此可以将小A小B一人走一步压缩成一步。接下来就是快速模拟每一个城市出发小A小B到达的下一个城市是哪了，有一个巧妙的办法不需要用到高级数据结构的——用[链表](http://oj.luogu.org:8888/wiki?name=%E9%93%BE%E8%A1%A8&flag=y)。首先所有的城市按照H排序，并且建成链表，从1到n依次处理，每次在链表中向前向后跳两次，看看这4个城市中哪个最近，哪个第二近，处理完某个城市之后将其从链表中删除（使用c++的可以使用set）。这样这道题便得以解决


给出倍增的方程：f[i][j]表示从i出发经过2^j次方步可到达哪个城市。




 

F[i][0]=next(i)

F[i][j]=f[f[i][j-1]][j-1]

