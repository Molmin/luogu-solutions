## P6874 [COCI2013-2014#6] KOCKICE

看到谷新加的一车题里面有一道已经通过了的，点进去以后发现是一套我审核时被毙掉的题目其中的一道，当时顺手写了（

### Analysis

首先不妨考虑我们先确定最终的砖头长什么样，然后计算出花费。

记  $\left\lfloor\frac n 2\right\rfloor = t$，当最中间一列有 $0$ 块砖时，那么显然对于第 $i$ 列，则有 $w_i = |t - i|$ 块砖。

设最终时中间的一列有 $x$ 块砖，则对于第 $i$ 列，有 $x + w_i$ 块砖，此时这一列的花费是 $|x + w_i - m_i| + |x + w_i - s_i|$。注意到 $a_i = m_i - w_i$ 和 $b_i = s_i - m_i$ 是定值，那么我们的最终花费即为 $\sum\limits_{i = 1}^n |x - a_i| + |x - b_i|$。这个式子的最小值的几何意义是数轴上有 $2n$ 个整点，选择一个整点使得这个点到其他所有点距离之和最小。

这是一个经典的结论，答案是将点按大小排序后在第 $n$ 和 $(n + 1)$ 个点之间（含端点）任选一个点即可。证明非常简单，首先将贡献分为两部分，即为选择的点左侧的点对答案的贡献和右侧的点对答案的贡献，考虑在 $n$ 和 $(n + 1)$ 之间（不含端点）的某个点，如果左移一位，那么左侧每个点的贡献 $-1$，总贡献减去 $n$，同时右侧每个点贡献 $+1$，总贡献加上 $n$，最终答案不变。而在该点在 $n$ 上或 $n$ 左侧时，如果左移一位移出 $[n, n + 1]$ 区间，那么左侧共有小于 $n$ 个点的贡献减 $1$，右侧多于 $n$ 个点的贡献 $+1$，最终答案会变大。同理可以证明在 $(n + 1)$ 或其右侧时点不能右移。

因此把 $a_i$ 和 $b_i$ 放在一起排序，取第 $n$ 大作为 $x$ 的值即可。需要注意的是，如果此时 $x \lt 0$，需要令 $x = 0$。

### Code

```cpp
namespace Fusu {

const int maxn = 300005;

int n;
ll a[maxn], b[maxn], w[maxn];
std::vector<ll> p;

void Main() {
  qr(n);
  qra(a + 1, n);
  qra(b + 1, n);
  for (int l = (n >> 1) + 1, r = l, i = 0; l; --l, ++r) {
    w[l] = w[r] = i++;
  }
  for (int i = 1; i <= n; ++i) {
    p.push_back(a[i] - w[i]);
    p.push_back(b[i] - w[i]);
  }
  std::sort(p.begin(), p.end());
  ll x = p[n];
  if (x < 0) x = 0;
  ll ans = 0;
  for (int i = 1; i <= n; ++i) {
    ans += llabs(a[i] - w[i] - x) + llabs(b[i] - w[i] - x);
  }
  qw(ans, '\n');
}

} // namespace Fusu
```

