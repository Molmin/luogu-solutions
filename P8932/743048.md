对于一个字符串 $S$，把它分成若干段，相邻的两个字母如果相同，就归为一段，设一共有 $x$ 段。如字符串 $\texttt{aabc}$ 就分为 $3$ 段：$\texttt{aa}$、$\texttt{b}$ 和 $\texttt{c}$。

如果段数为偶数，则第 $1$ 段和第 $2$ 段之间插入第 $1$ 段和第 $2$ 段，第 $3$ 段和第 $4$ 段之间插入第 $3$ 段和第 $4$ 段……最后还剩一段，则在末尾插入最后一段，一共需要 $\dfrac{x+1}{2}$ 次操作。

如果段数为奇数，则没有最后一段，需要 $\dfrac{x}{2}$ 次操作。

那对于每一次询问，怎么快速求出当前的段数呢？我们可以先 $O(n)$ 初始化出段数，对于一次询问：

- 如果原来的字符和它左边的相同，改了之后就不同了，则对答案产生 $1$ 的贡献。

- 如果原来的字符和它右边的相同，改了之后就不同了，则对答案产生 $1$ 的贡献。

- 如果原来的字符和它左边的不同，改了之后就相同了，则对答案产生 $-1$ 的贡献。

- 如果原来的字符和它右边的不同，改了之后就相同了，则对答案产生 $-1$ 的贡献。

一直维护着答案即可，总时间复杂度 $O(n)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+10,INF=1e9;
//省略快读快写
int q,len;
string s;
signed main()
{
	q=read(),cin>>s,len=s.size(),s=" "+s;
	int cnt=0;
	for(int i=1;i<=len;i++)
		if(s[i]!=s[i-1])
			cnt++;
	write((cnt+1)>>1,"\n");
	while(q--)
	{
		int x=read();char ch=getchar();
		if(x!=1&&s[x]==s[x-1]&&ch!=s[x-1])
			cnt++;
		if(x!=len&&s[x]==s[x+1]&&ch!=s[x+1])
			cnt++;
		if(x!=1&&s[x]!=s[x-1]&&ch==s[x-1])
			cnt--;
		if(x!=len&&s[x]!=s[x+1]&&ch==s[x+1])
			cnt--;
		s[x]=ch;
		write((cnt+1)>>1,"\n");
	}
}
```