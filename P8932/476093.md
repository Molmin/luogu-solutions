# 题解 P8932 [JRKSJ R7] Clock Paradox

作为我赛时唯一做出来的题（T2 被取模骗了），来篇题解庆祝下。

### Part1 题意

[题面传送门](https://www.luogu.com.cn/problem/P8932)

定义 $f(S)$ 为使字符串 $S=\overline{s_1s_2...s_n}$ 变成 $T=\overline{s_1s_1s_2s_2...s_ns_n}$ 所需的最小操作次数，其中 $T$ 初始时与 $S$ 相同，一次操作可以把 $S$ 中连续的一段插到 $T$ 中。 

给定字符串 $S$ 和 $q$ 次修改，求开始时和每次修改后 $f(S)$ 的值。

### Part2 做法

怎么把 $S$ 中连续的一段 $\overline{s_1s_2...s_k}$ 变成 $T$ 中的 $\overline{s_1s_1s_2s_2...s_ks_k}$ 呢？

- 可以看到，每一项都可以再插一个到这一项的前面或后面，这样就可以出现两个。
- 而连续的相同项则只需要把这一整段再插一个到前面或后面。
- 由于前后都可以插，所以每两段只需要插一次即可。
- 由此，我们发现：**设 $g(S)$ 为 $S$ 中连续相同的最少段数，则把 $S$ 转换成 $T$ 所需要的最少操作次数为 $\lceil \frac{g(S)}{2} \rceil$。**

那思路就很明确了：**只需要找出每一次修改后的 $g(S)$，就可以完成本题。**

但单次求 $g(S)$ 的复杂度是 $\text{O}(|S|)$ 的，总复杂度成了 $\text{O}(|S|q)$，直接 T 飞。所以我们只能在开始的时候求一次 $g(S)$，**后面每次修改直接在原来的基础上用 $\text{O}(1)$ 的复杂度算出新的 $g(S)$**。

这里，我简单地讨论了一下：

- 如果改的字符和原来的字符一样（等于没改），直接过；
- 否则：
    1. 如果这个位置原来的字符与其左边、右边的字符都一样，则 $g(S)$ 增加 $2$（一段变成了三段）；
    2. 如果这个位置原来的字符与其左边、右边的字符都不一样，改之后都一样，则 $g(S)$ 减少 $2$（三段变成了一段）；
    3. 如果这个位置原来的字符与其左边或右边的字符一样，改之后和两边都不一样，则 $g(S)$ 增加 $1$（两段变成了三段）；
    4. 如果这个位置原来的字符与其左边和右边的字符都不一样，改之后和一边是一样的，则 $g(S)$ 减少 $1$（三段变成了两段）；
    5. 其它情况没有变化。

这样，这道题就解决啦！总复杂度 $\text{O}(|S|+q)$。

### Part3 代码

为了让 `cin` 能过，这道题的时限已经放宽到三秒了。

注释已经加好啦！

```cpp
#include<bits/stdc++.h>
/*此处省略一坨快读快输，可以去我主页找，这道题中它跑出了342ms的好成绩*/
#define ll long long
using namespace std;
ll q,p,sum,len;
char ch,s[3000010];
//本来是string，为适配快读用了char数组，len存长度 
int main(){
	cin>>q>>s;
	sum=1;//全部一样也有一段，直接算上 
	len=strlen(s);
	//计算g(S) 
	for(int i=1;i<len;i++){//注意从1开始，否则会RE 
		if(s[i]!=s[i-1]){
			sum++;
		}
	}
	cout<<(sum+1)/2<<endl;//别漏了这个 
	while(q--){
		cin>>p>>ch;
		p--;//我是从0开始的所以p减去1 
		if(s[p]!=ch){//相同等于没改，直接过 
			if(p>0&&p<len-1){//改的位置不在两头（这个判断防RE） 
				//下面的情况根据sum的改变对号入座去上面找即可，这里不再赘述 
				if(s[p-1]==s[p]&&s[p]==s[p+1]){
					sum+=2;
				}
				else if(s[p-1]==s[p]&&ch!=s[p+1]||s[p+1]==s[p]&&ch!=s[p-1]){
					sum++;
				}
				else if(s[p-1]!=s[p]&&s[p]!=s[p+1]){
					if(ch==s[p-1]||ch==s[p+1])sum--;
					if(ch==s[p-1]&&ch==s[p+1])sum--;
				}
			}
			else{//改的位置在两边 
				if(p==0&&s[p]==s[p+1]||p==len-1&&s[p]==s[p-1]){
					sum++;
				}
				if(p==0&&ch==s[p+1]||p==len-1&&ch==s[p-1]){
					sum--;
				}
			}
		}
		s[p]=ch;//别忘了改上去 
		cout<<(sum+1)/2<<endl;//输出 
	}
	return 0;
}
```