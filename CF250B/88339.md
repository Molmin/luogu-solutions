
## 一、思路
由于 $ipv6$ 地址有 $8$ “段”，所以我们在复原的时候可以先定义个 $ss[9]$，其中 $ss[i]$ 表示第 $i$ “段”。**以下会分为几个小节进行讲解。**

### 如何分“段”
我们可以先考虑从左到右将字符串扫描一次，如果字符串结束或者遇到冒号，就可以记为一段。
### 如何补充每一段省略的$0$
在扫描的时候，定义一个 $p$，代表扫描到一段中非冒号字符个数，如果遇到冒号，就有两种情况：$p==4$ 和 $p!=4$。情况一：没有省略的$0$；情况二：有省略，那么可以根据 $p$ 的值先在 $ss[pe]$（$pe$ 代表段数，下面的小节会详细说明）中补充 $4-p$ 个$0$。处理完后，$p$ 归零。
### 如何记录段数
定义一个 $pe$，初始值为$1$，代表一开始处理的是第一段。在上述操作结束时，$pe++$。
### 如何判断双冒号省略了多少$0$
举个例子，如此地址：

	::1
    ::rq
补全之后为：

	0000:0000:0000:0000:0000:0000:0000:0001
    0000:0000:0000:0000:0000:0000:0000:00rq
由于在省略$0$后面又有要补充的数字和字母，我们便只补充全$0$。所谓全$0$，是指有若干段，每一段整段都是零。如上述的全$0$为：

	0000:0000:0000:0000:0000:0000:0000
    0000:0000:0000:0000:0000:0000:0000
之后的$0001$和$000rq$可以由第二小节中的操作将缺失$0$的段补充完整。

那么到底如何判断双冒号的全$0$有多少个？我们可以在处理之前先看除了双冒号外有多少完整或不完整的段，假设段数为 $m$，则最后全$0$个数为 $32-4*m$ （为了保持 $C++$ 的特性，乘号作星号），中间有 $8-m$ 段是全$0$段。
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
string s,s1,ss[9];
int n,tot,num,p,flag,pe,zero,num_,m;
void output(){
	for(int j=1;j<=7;j++)
		cout<<ss[j]<<":";
	cout<<ss[8]<<"\n";
}//输出函数，方便调试
int main(){
	scanf("%d",&n);
	while(n--){
		tot=0;
		zero=0;
		flag=0;
		num_=0;
		p=0;
		m=0; //一开始完整或不完整的段数
		pe=1;
		s="";
		for(int i=1;i<=8;i++) ss[i]="";//全部初始化
		cin>>s;
		for(int i=0;i<s.size();i++)
			if(s[i]!=':') tot++;
			else{
				if(s[i+1]==':') i++,num_++;
				if(tot) m++,tot=0;
			}
		if(num_>1){
			cout<<"INVALID\n";
			continue;
		}
		if(tot) m++; 
		zero=32-4*m;//判断有多少0待补
		int i;
		for(i=0;i<=s.size();i++){
			
			if(s[i]!=':'&&i!=s.size()) p++;//一段中数或字母的个数++
			if(s[i]==':'||i==s.size()){
				if(p){
					if(p>4){
						cout<<"INVALID\n";
						flag=1;
						break;
					}else{
						for(int j=1;j<=4-p;j++) ss[pe]+='0';//补0
						for(int j=i-p;j<i;j++) ss[pe]+=s[j];
					}//上述操作2，即补不完整段中的0
					pe++;//段数++
				}
				p=0;
				if(i!=s.size()){
					if(s[i+1]==':'){
						num=zero/4;
						for(int j=pe;j<pe+num;j++) ss[j]="0000";
						pe+=num;
						i++;//跳过这个冒号，直接开始下一个数字或字母
					}
				} //补全0，有num段，所以pe+=num
				
			}
		}
		if(flag) continue;//这里是判断输入不合法，输出“Invalid”也是在判断输入不合法，虽然题目中不存在这样的要求，但是还是添加了部分判断，读者可以忽略
		output();//输出
	}
	return 0;
}
```
**如果看代码看不懂，请务必多看思路，代码的编写紧扣思路。**
