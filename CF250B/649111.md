### 题意：
给出 $n$ 个压缩后的IPv6地址,给出一些压缩的方法,恢复IPv6地址的完整形式    
压缩方法有以下2条:        
1.删除前导 $0$ :       
（例如```a56f:00d3:0000:0124:0001:f19a:1000:0000``` $→$ ```a56f:d3:0:0124:01:f19a:1000:00```)        
2.用 $::$ 缩写连续 $0$ 序列          
（例如```a56f:00d3:0000:0124:0001:0000:0000:0000``` $→$ ```a56f:00d3:0000:0124:0001::```)        
注意IPv6地址只能用一次 $::$ 
### 分析：
不用什么算法，是较简单的字符串处理。但是码力很大，细节比较难处理。         
做法读完题目后已经很明确了，主要是以下三种情况：       
1.如果在两个 $:$ 之间有四个字符，直接输出，不用进行改变          
2.如果在两个 $:$ 之间少于四个字符，计算有几个字符，输出 $4-s$ 个 $0$ 后输出剩下的字符即可，其中 $s$ 代表两个 $:$ 之间的字符长度       
3.特殊的 $::$ 情况：我们要进行特殊处理，实现记录在 $::$ 之前有多少段，再寻找 $::$ 之后有多少段，这样就可以求出有多少段 $0000$ ,最后再输出就行了
### tips:
1.当记录到输出为最后一段时，要注意不要输出多余的空格或 $:$          
2.当不好观察输出时，可以使用文件输出。           
文件输出示例: ```freopen("test.txt","w",stdout);```      
打开程序所在位置的 ```test.txt``` 文件即可观察输出        
### code
```cpp
#include<bits/stdc++.h>
using namespace std;
long long a,b,c,d,e,lsss;
string s;
int ts(int lss){//::的情况 
	e=0;
	for(int i=lss+1;s[i]!='\0';i++){
		if(s[i]==':'){
			e++;
		}
	}
	b+=e;
	b--;
	for(int i=1;i<=(7-b);i++){
		if((b-e+i)==8){
			cout<<"0000";
			break;
		}
		else{
			cout<<"0000:";
		}
	}
}
int findd(int ls){
	if(s[ls-1]==':'&&s[ls]==':'){//::的情况 
		ts(ls);
	}
	else{//一般的情况 
		for(int i=1;i<=(4-c);i++){
			cout<<0;
		}
		for(int i=ls-c;i<=ls;i++){
			if(s[i]-'0'>=0&&s[i]-'0'<=9)
				cout<<s[i];
			if(s[i]=='a'||s[i]=='b'||s[i]=='c'||s[i]=='d'||s[i]=='e'||s[i]=='f'||s[i]==':'){
				cout<<s[i];
			}
		}
	}
}
int main(){
	cin>>a;
	for(int i=1;i<=a;i++){
		b=0;
		cin>>s;
		c=0;
		d=0;
		lsss=0;
		for(int j=0;s[j]!='\0';j++){
			d++;
			if(s[j]==':'){
				lsss=j;
				b++;
				findd(j);
				c=0;
			}
			else{
				c++;
			}
		}
		findd(d);
		cout<<endl;
	}
} 
```