[题目传送门](https://www.luogu.com.cn/problem/P8090)

## 题意

给定两个 $3\times 3$ 的由大写字母构成的字符方阵，第一个方阵为正确答案，第二个方阵为猜测结果。

您需要求出字母和位置都完全对应的字母个数和存在相同字母但是位置不对应的字母个数。

## 解析

我们可以在边输入边将字符数预处理。因为在正确答案的方阵中找到了满足第一问条件的字符是不会再次参与第二问的计算的，而剩余未参与第一问计算的在正确答案方阵的字符都会参与第二问的计算，所以我们在每一问的计算处理过程中都将对应的字符的非零预处理数 $-1$, 如果为 $0$ 则说明该字符在所有正确答案的位置已对应完或不存在，不应参与该问的计算。

所以按照这个思路我们可以首先遍历一遍猜测方阵得到第一问的结果。但是如果我们再遍历一遍猜测方阵去得到第二问的结果会将已参与第一问答案计算的字符再次计算一遍，所以我们可以另外创建一个 `bool` 类型二维数组用于记录同样位置的猜测字符是否已经参与第一问的处理。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
char a[10][10], tmp[10][10];
int c[30], ans; 
bool f[10][10];
int main(){
    for(int i = 1;i <= 3;i++){
        scanf("%s", a[i] + 1);
        for(int j = 1;j <= 3;j++){
            c[a[i][j] - 'A' + 1]++;
        }
    }
    for(int i = 1;i <= 3;i++){
        scanf("%s", tmp[i] + 1);
        for(int j = 1;j <= 3;j++){
            if(tmp[i][j] == a[i][j]){
                ans++;
                c[tmp[i][j] - 'A' + 1]--;
                f[i][j] = 1;
            }
        }
    }	
    printf("%d\n", ans);
    ans = 0;
    for(int i = 1;i <= 3;i++){
        for(int j = 1;j <= 3;j++){
            if(c[tmp[i][j] - 'A' + 1] > 0 && f[i][j] == 0){
                ans++;
                c[tmp[i][j] - 'A' + 1]--;
            }
        }
    }
    printf("%d\n", ans);
    return 0;
}
```
