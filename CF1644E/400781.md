感觉这题要比 D 简单一些，套路也是非常经典的对于每一个位置算贡献。好了，做完了（

### 题意

给你一个 $n\times m$ 的网格和一个操作序列，初始你在 $(1,1)$，你要按照操作序列操作：每次右移或下移一格。然后你可以把一次操作变为相同的两次，问你所有可能的操作序列一共可以到达多少格子。

### 分析

首先考虑一种特殊情况：假如操作序列只有一个方向，那么答案就是 $n$ 或 $m$。

首先我们按照给出的操作序列走一遍到那个格子，然后求出来这个位置最多可以在横或纵方向上走几格到达 $(n,m)$，记需要右移 $x$ 格，下移 $y$ 格。

在接下来的分析中，为方便起见，我们把格子与格子之间的操作改成格子内部的操作，比如说当前在 $(1,1)$ 然后要向右移，那么我们就把这个格子标记一个右移。当然这么做会漏一个格子，后面会加上的。

考虑计算答案。对于每一个格子，我们最多可以向**这个格子相对的方向**（比如格子是向右的，就考虑向下这个方向）移动 $x$ 或 $y$ 格。因为移动一定是向右向下的，你无论怎么扩展一定不会超出边界或者和别的重合，所以我们可以直接把这些贡献到答案里面。

注意一点，只有在第一次转向及以后才能进行这样的操作（想一想，为什么）。

然后考虑最后一个格子。不难发现，从右下角开始的 $x\times y$ 的所有格子都能走到，我们直接加上去。

### Code 

```cpp
#include<bits/stdc++.h>
#define int long long
namespace GGMZ
{
	const int N = 2e5 + 5;
	char s[N];
	int x, y, n, ans;
	void work()
	{
		bool flag = 1;
		std::cin >> n >> s + 1;
		x = 1, y = 1;
		for (int i = 1;s[i];i++)
		{
			if (s[i] == 'R')x++;
			else y++;
			if (s[i] != s[i - 1] && i != 1)flag = 0;
		}
		if (flag == 1)
		{
			std::cout << n << '\n';
			return;
		}
		x = n - x, y = n - y;
		int i = 2;
		ans = 1;
		while (s[i] == s[i - 1])ans++, i++;
		for (i;s[i];i++)
		{
			ans++;
			if (s[i] == 'R')ans += y;
			else ans += x;
			if (s[i + 1] == 0)ans += (x + 1)*(y + 1);
		}
		std::cout << ans << '\n';
	}
}
#undef int
int main()
{
	int t;
	std::cin >> t;
	while (t--)GGMZ::work();
	return 0;
}
```