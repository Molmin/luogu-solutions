具体实现和楼上大佬差的不是很多，但是可以从另一种方式思考：
（首先还是要特判全部相等）如果这是一个链（不用考虑首尾）则答案必然为2，固定第一个数c[1]后，每一个数c[i]为2-c[i-1]。

所以链的情况是很简单的，我们考虑将这个环化为链。

1. n个数中没有连续相等的两个。则我们可以先按链的方式去填，因为按这个方式，只要第一个确定，其他的数也就确定了，所以填完后，如果c[n]和c[1]相等，则我们无法通过转换前面的数使得它们不等，所以必须将c[n]变为3，最终答案即为3.如果c[1]和c[n]不等，则可以直接输出，答案为2。
2. n个数中有连续相等的两个，不妨设为t[i]=t[i+1]，所以，t[i]和t[i+1]之间是没有限制的，那么我们可以愉快地发现，它等价于一条 i----1----n----i+1的链，按链的方法处理即可。注意，要特判一下c[1]=c[n]的情况。

至于代码。。。就不全贴了吧，放一段第二种情况的。
```cpp
		int x=0;//x即为刚才所述的i
		for(int i=1;i<=n;i++){
			scanf("%d",&a[i]);
			if(a[i]==a[i-1])x=i-1;
		}
      if(a[1]==a[n])x=n;//特判
     if(x){
			printf("2\n");
			for(int i=1;i<=x;i++){//处理链x----1的部分
				if(i%2)printf("1 ");
				else printf("2 ");
			}
			for(int i=n;i>x;i--){//处理链n----x+1的部分
				if((n-i)%2)tmp[i]=1;
				else tmp[i]=2;
			}
			for(int i=x+1;i<=n;i++)printf("%d ",tmp[i]);
			printf("\n");
       }
```
有不懂的可以私信问我。

~~看在我思路如此清奇的份上，让我通过吧QAQ~~