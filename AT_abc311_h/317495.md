~~/bx /bx /bx jly！~~

### 题意

给定一棵 $n$ 个点的树，每个点有美丽度 $B$、重量 $W$、颜色 $C$（$0$ 或 $1$），对每个点求一下问题：

- 重复以下操作任意多次：选择一个除根以外的点 $u$，删除 $u$，将 $u$ 的所有儿子连到 $u$ 的父亲上；
- 最后得到的树满足相邻节点颜色不同，总重量不超过 $m$；
- 在满足上述条件的前提下总美丽度最大。

各个子问题独立。

$n \le 200,m \le 5 \times 10^4$。

### 分析

考虑到删除节点的具体顺序与答案无关，所以可以将删除改为选择，那么就有朴素 dp：$f_{u,i,0/1}$ 表示以 $u$ 为根，选的节点总重量为 $i$，最浅的一层节点颜色为 $c$ 的最大总美丽度。转移形如背包合并，具体的：

$$v \in son_u, f_{u,i,c} \gets f_{u,i-j,c}+f_{v,j,c}$$

$$f_{u,i,C_u} \gets f_{u,i - W_u,1 - C_u}+B_u$$

复杂度 $\mathcal O(nm^2)$，不能通过，考虑优化。

显然复杂度瓶颈在于背包合并，如果我们能将合并改为插入就可以省去一个 $m$，不难想到用 DSU on tree。

我们先考虑没有颜色的情况：先让当前位置继承重儿子的答案，再让 `dfs` 迭代的过程中传入一个 dp 数组，将轻子树的信息插入进去，这是 trivial 的。

考虑加入颜色后必须要考虑上颜色带来的转移影响，每次插入会影响到两个数组，因为颜色数很少，所以不妨考虑将两种颜色分别加入迭代。

具体的：考虑实现函数 `dfs(u, dp)`，返回值为两个数组；在查询子树 $u$ 的答案时，先递归继承重儿子的答案；然后对于每一个轻儿子令 `f[0] = dfs(v, f[0])[0], f[1] = dfs(v, f[1])[1]`，即分别将两种颜色迭代到轻子树中插入信息；最后在将 $u$ 节点的信息插入其中。

分析一下复杂度：在递归过程中，每个轻儿子被迭代了两次，所以假设一个点到根的路径上有 $d$ 条轻边，则它对时间复杂度的贡献为 $\mathcal O(2^d)$。设 $T(u)$ 为解决子树 $u$ 的总时间复杂度，则有 $T(u) = T(\operatorname{heavy}(u))+2\sum\limits_v T(v) + \mathcal O(m)$，所以 $T(n) = \mathcal O(n^{\log_2 3}m) \approx \mathcal O(n^{1.59}m)$，可以通过。

### Code

提交记录：<https://atcoder.jp/contests/abc311/submissions/43968659>。