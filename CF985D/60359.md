## 题解 CF985D 【Sand Fortress】

题目传送门：

https://www.luogu.org/problemnew/show/CF985D

笔者语：这题是一道**二分答案**脑洞题

（请爱惜这篇题解，这是本人熬到深夜打出来的）

再次笔者真的希望能帮到大家

============================================

#### 题面翻译：

你有**n袋沙子**，你需要用沙子堆一面墙，

**沙子必须摆放在整数的位置**，而且

**最左边已经有一面高为h袋沙子的墙了，**

所以，**最左边的沙子的袋数不能大于h，**

**相邻的两个点上堆放的沙子袋数相差不能超过1**

问，怎样堆放才能**使沙子的堆数最小**。

~~（接下来自己BB）~~

看了这题感到有点蒙~~（找不着北）~~

没关系，我们接下来分析本题

============================================

#### 思路&&算法分析：

~~（我要是说显然这题是二分答案你们会打我么= =）~~

对于此题，我们要满足题目中给的3个要求如下:

1.**第一个沙堆的高度不能超过h**

2.**任意两根**沙堆的高度差不能超过1

（即**最后一个沙堆高度一定为1**）

3.沙墙的**所有沙堆消耗的沙袋总数为n**


============================================

从题目意思可以发现这里**分为3种情况**:

（h代表最左端沙堆高度，k代表每一堆沙子的高度）

	 （若K<=h）

	 1.第一种这么堆:
      K,K-1，K-2,...,2,1  
     	其中 ∑ == n;

	 (若K>h)

 	2.第二种这么堆:
      K,K+1,..,K+x-1,K+x,K+x-1,...,K,K-1,...,2,1 
    	 其中 ∑ == n;

	 3.第三种这么堆：
      K,K+1,..,K+x-1,K+x,K+x,K+x-1,..,K,K-1,..,2,1 
     	其中 ∑ == n;

这时我们不妨假设一个沙堆数k，此时我们

不难发现，堆出的沙堆高度有以下两种情况，

①从h到1的单调递减的数列（如上面的1）

显然此时总沙堆数为  k*(k+1)/2

②从h先单调递增到一个max，然后单调递减的数列
（如上面的2,3）

（插入一句话）

**请注意**:在以下②③情况中**设能堆的沙堆的最大高度 **

**H=（k-h）/2+h**（因为这样才能保证沙堆数最少）

（下面继续正文）

但其实②情况**对于高出最左边h的高度**分为两种，

第一种是下面这样：

奇数情况：（上面的3）出现**两个并列最大值**

![](https://images2018.cnblogs.com/blog/1168200/201805/1168200-20180522121337955-1890891751.png)

这里**前半部分**有H-h+1个沙堆，**后半部分**直接等差数列求和即可：H*（H+1）

那么此时的**总沙堆数**为：(H+h) *(H-h+1)/2 + H*(H+1) /2

另一种是下面这样：

偶数情况：（上面的2）出现**单峰最大值**

![](https://images2018.cnblogs.com/blog/1168200/201805/1168200-20180522121344855-1204689348.png)

那么这里：**前半部分**H-h个沙堆，**后半部分**仍然是等差数列求和：H*（H+1）

那么此时的**总沙堆数**为(H-1+h)*(H-h)/2 + H*(H+1)/2

对于以上三种情况，只需判断是否这个k值合法即可

那么这个**答案显然是具有单调性**的（证明略）

由于考虑到要找**最少的堆**数目，我们可以使用**二分答案**，用**二分**来枚举沙堆堆数，检查这个堆数是否合法

**二分答案缩小范围的判定**：**堆k个沙堆所能堆出的沙墙使用沙袋的数目是否大于等于给出的n**，

若可行说明我们可以尝试缩小范围，得到更小堆得数目从而求得题目要的**最小值**

思路大体就是这样，~~其实不是很难~~~~（我推了一上午）~~

注意，**乘法会爆int**，笔者的代码里使用了long long

因此，我加了一个INF，如果计算出的沙堆数>=INF直接返回1（顶尖数据范围能达到那么一定是可行的）

之后就是注意等差数列求和的公式，别记错了

数学公式左边除以2可以转变为右边乘以2，实在不行就手推吧（本人也是爱莫能助啊）

接下来发代码，里面也有解释，应该会更详细一些

（本人太弱，可能讲的不是太好，dalao们不喜勿喷）

    #include<iostream>
    #include<cstdio>
    #include<cmath>
    #include<algorithm>
    using namespace std;
    typedef long long ll;
    inline ll read()
    {
        ll p=0,f=1;char c=getchar();
        while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}
    while(c>='0'&&c<='9'){p=p*10+c-'0';c=getchar();}
        return 1ll*f*p;}
    const ll inf=2000000000;
    ll n,h;
    inline bool check(ll k)
    //判断mid值是否可行,即判断所用的沙袋数最大值是否超过n
    {
        if(k<=h)
            {
                //1.如果分的堆数k<=h:直接等差数列求和
        	    if(k>=inf) return 1;
       	 	    return k*(k+1)/2>=n;
    	    }
        //以下对应k>h的情况
        ll H=(k-h)/2+h;//先求出要堆的沙堆的最大高度
        if(H>=inf)return 1;
        if((k-h)&1)//k-h为高出的高度
        //2.如果高出的高度为奇数则有两个最高点,前后两次求和
            return (H+h)*(H-h+1) + H*(H+1) >= (n<<1);
        //3.如果高出的高度为偶数则只有一个最高点,前后两次求和
        return (H-1+h)*(H-h) + H*(H+1) >= (n<<1);
    }
    int main()
    {
        n=read(),h=read();
        ll l=1,r=n,mid;
        //接下来二分答案
        while(l<=r)
            {
        	    mid=(l+r)>>1;
        	    if(check(mid))
                //二分出一个mid值进行判定
                	r=mid-1;
        	    else l=mid+1;
    	    }
        printf("%lld",r+1);
        return 0;
    }

好啦，以上就是本题的全解了，希望能帮到大家

最后推广一下我的博客：

https://www.luogu.org/blog/new2zy/

感谢阅读~~~拜拜>=<
