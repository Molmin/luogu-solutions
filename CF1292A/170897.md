
## 分析

这道题的大概思路还是挺好想的,大概就是每次输入的时候记录下挡路的"单元"

![](https://img2020.cnblogs.com/blog/1975074/202004/1975074-20200404182101617-467743414.png)


上图用圈出来的部分都是一个单元,可以阻挡玩家通过,如果整个地图只有一个熔浆单元格,显然是不足以构成一个单元,至少两个(上面三种情况)才可以构成.

那么思路就有了,如果在反转的时候对面三个格子已经有了熔浆单元,单元的数量加一.

![](https://img2020.cnblogs.com/blog/1975074/202004/1975074-20200404182116097-812467219.png)



在反转的时候,如果对面已经有了熔浆单元,说明这个格子在从地面到熔浆的过程中,单元的数量增加了,那么反转的时候自然要减回去.

## 代码

```cpp
#include <cstdio>
int vis[2][100005];
int n, q, x, y, ans;
int main() {
    scanf("%d%d", &n, &q);
    while (q--) {
        scanf("%d%d", &x, &y);
        x--;
        if (vis[x][y]) {
            if (vis[!x][y]) ans--;
            if (vis[!x][y + 1] && y + 1 <= n) ans--;  //注意边界
            if (vis[!x][y - 1] && y - 1 >= 1) ans--;
        } else {
            if (vis[!x][y]) ans++;
            if (vis[!x][y + 1] && y + 1 <= n) ans++;
            if (vis[!x][y - 1] && y - 1 >= 1) ans++;
        }
        vis[x][y] = !vis[x][y];
        printf("%s\n", ans ? "No" : "Yes");
    }
}
```