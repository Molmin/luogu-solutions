我觉得这样一道题能独立做出来应该是会很有成就感的。

怎么回事呢，为什么只有 2700 呢，不应该啊。

为了方便，令 $s_u$ 表示 $u$ 的子树的权值和，令 $S$ 表示整棵树的权值和。

考虑枚举每一段的权值和 $x$，一个很重要的结论是如果有方案，那么只有一个方案。

粗略地讲一下证明，大概就是你在选方案的时候，一定是选一个权值和为 $x$ 的子树，然后删掉这个子树，重复这个步骤。因为原图是棵有根树，所以按这个步骤分出的方案是唯一的。

进一步地，怎么判断有方案呢？只要满足 $s_u$ 是 $x$ 的倍数的 $u$ 刚好有 $\frac{S}{x}$ 个即可。

这个证明也是简单的，考虑对于一个 $u$，除去它所有的可以拆分的后辈的子树，那么剩下的这个集合一定仍然是 $x$ 的倍数。

为了方便，我们假设满足条件的 $u$ 有 $cnt$ 个。

那么说明可以拆分出 $cnt$ 个集合，每个集合都是 $x$ 的倍数。因为 $a_i>0$，所以每个集合的大小都是正整数。那么显然没有 $cnt>\frac{S}{x}$，进一步地，当 $cnt=\frac{S}{x}$ 时，唯一的分配方案就是每个集合刚好为 $x$。

那么现在把式子列出来，要求 $s_u=px$。

这里有一个问题在于 $x$ 是任一 $S$ 的因数，这玩意很多，也很大，不好处理。

但是发现 $\frac{S}{x}$ 很小，因为你最多只能分成 $n$ 段，所以我们考虑换个设 $x$ 的方法，令 $x$ 表示分成 $x$ 段，每段的大小为 $\frac{S}{x}$。

那么有 $s_u=p\times\frac{S}{x}$。

考虑移项，有 $x=p\times\frac{S}{s_u}$。

也就是说，一个点 $u$ 的子树对所有的满足是 $\frac{S}{\gcd(S,s_u)}$ 的倍数的 $x$ 满足条件。

倍数是好处理的，先存在 $\frac{S}{\gcd(S,s_u)}$，最后调和级数扫一遍就行了。

那么现在得到了 $g_i$ 表示分成 $i$ 段是否可行。

为了方便，把原题分裂的过程反过来，改为合并的过程，现在要求 $f_i$ 表示从若干段开始，最终合并到只有 $i$ 段的方案数，显然答案求 $f_1$。

转移是简单的。

$$f_i=(\sum_{i\mid j}f_j+1)\times g_i$$

总复杂度为 $O(n\ln n+n\log a)$。

https://codeforces.com/contest/1034/submission/172629101