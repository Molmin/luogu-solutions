看到这个题发现一脸不可做的样子，考虑转化一下题意。
首先可以发现第一次取的数是固定的，于是将它先取掉。后面的操作就变成了：先取任意一个位置，然后再取剩下的中间的数。
可以发现这个东西可以用两个栈拟合得很好，于是考虑将左右两边的数分别插入两个栈中，每次取其中一个栈内任意元素，然后将另一个栈的栈顶删除。

考虑枚举最终选择的区间，将这个区间内的点称作 “关键点” 并在栈中标记。可以发现，这些关键点一定要作为栈顶删除。
于是原问题被转化成一个判定问题：对于两个栈，每次操作为，将其中一个的栈顶与另一个中的任意元素一起删除。需要知道是否存在某种删除方式使所有关键点都作为栈顶被删除。

考虑栈顶的情况，发现一共有 $3$ 种 ：两个都是关键点，两个都不是关键点或一个是关键点而另一个不是。
考虑到出现不合法情况当且仅当其中一个栈内还有关键点而另一个栈内全都是关键点。而在三种情况中只有两个都不是关键点的情况才会浪费非关键点，所以我们要尽可能将关键点往上放，让它尽快消掉。这等价于尽可能先删除靠近栈顶的非关键点。
于是可以得到一个贪心的判定方法：对于两个都是非关键点的情况，将它们两个一起删除。对于一个是关键点而另一个不是的情况，将他们两个一起删除。对于两个都是关键点的情况，将其中一个与另一个栈中最靠近栈顶的非关键点匹配，这个可以用指针维护。
单次判定 $\Theta(n).$

再考虑到同时枚举最终选择两个端点非常浪费，由于极大合法区间的右端点一定随着左端点单调递增，所以可以用双指针维护。
再加上单次 $\Theta(n)$ 的判定，可以做到 $\Theta(n^2).$

考虑到枚举端点似乎已经没法优化，而判定时每次只修改了一个点的关键性，却要 $\Theta(n)$ 地重新判定，非常冗余，于是考虑从判定上下手继续优化。
可以发现，上文所述的删除方式相当于是给一个栈中的所有关键点找一个匹配，又因为关键点只能跟深度比自己大的点匹配，所以考虑建立一张二分图，每个栈中的关键点向另一个栈中比自己深的非关键点连边。
这两张二分图什么时候有完美匹配呢？根据 $\rm Hall$ 定律，设一边的某个点集 $S$ 向另一边的连边集合为 $E(S)$，一张二分图存在完美匹配，当且仅当对于任意集合 $S$，满足 $|E(S)|\geqslant |S|.$ 在这道题中就是在两个栈的任何两个长度相等的后缀内，其中一个里的关键点数量不大于另一个里的非关键点数量。并且由于一个栈内的点不是关键点就是非关键点，所以如果一个栈内的关键点相对于另一个栈内的非关键点合法，则两张二分图都存在完美匹配。

可以发现，如果将关键点看作 $-1$，非关键点看作 $+1$，那么这种标记关键点的方式合法当且仅当任何一个后缀和不小于 $0.$
这个可以用树状数组维护，每次区间端点移动则对后缀和区间修改，维护一下总体的最小值，判一下它是否为负数即可。

时间复杂度 $\Theta(n\log n).$