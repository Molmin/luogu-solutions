看一眼题，在某一时刻到达第n个点，一眼就是个DP题，定义状态$dp_{i,j}$是在第$j$时刻到达$i$点的方法数。

看一眼数据范围，$t\leq 10^9$，这样就是叉掉了几乎所有的DP做法。

但是额外地，我们发现n极小，并且路径长度也小的诡异。学过矩阵加速递推的大概现在已经起反应了，既然这样，影响下一个状态的就只剩下距今时间小于等于9的那部分了。也就是，如果我们确定要使用矩阵加速递推，那么剩下的就非常*显然*。

例如当n=3，路径最大长度是3的时候，定义$a_{i,j}$是经过$i$时间到达$j$的方法数（求求了，再大手就会打废掉的）：

$$\begin{bmatrix}1&2&3\\3&2&1\\1&3&1\end{bmatrix}$$
$$\Downarrow$$
$$\begin{bmatrix}0&0&0&1&0&0&0&0&0\\0&0&0&0&1&0&0&0&0\\0&0&0&0&0&1&0&0&0\\0&0&0&0&0&0&1&0&0\\0&0&0&0&0&0&0&1&0\\0&0&0&0&0&0&0&0&1\\0&1&0&0&0&0&1&0&1\\0&0&1&1&1&0&0&0&0\\1&0&0&0&0&1&0&0&1\\\end{bmatrix}\begin{bmatrix}a_{1,1}\\a_{1,2}\\a_{1,3}\\a_{2,1}\\a_{2,2}\\a_{2,3}\\a_{3,1}\\a_{3,2}\\a_{3,3}\\\end{bmatrix}=\begin{bmatrix}a_{2,1}\\a_{2,2}\\a_{2,3}\\a_{3,1}\\a_{3,2}\\a_{3,3}\\a_{4,1}\\a_{4,2}\\a_{4,3}\\\end{bmatrix}$$

很容易发现前几个都特别地有规律啊，毕竟只需要继承之前推出的结果就行了。只有最后三排，我们需要根据邻接矩阵来填上0或1。易于发现，扫描某一列，如果距离是三就在前面三个找出来，变成1。最后，利用矩阵快速幂，我们可以随随便便就发现答案。

注意，因为保存状态只能用一维的矩阵（貌似二维也是可以的，~~但是并不知道立方体乘法怎么做~~）所以必须把状态堆叠起来，这样打着有些别扭，但是莫得办法。在快速幂之后，就是乘上初始的状态矩阵，由于只有一个一，找一下输出就好了。参考代码qwq

```cpp
#include<bits/stdc++.h>
using namespace std;
const int Mod=2009;
int t,n,a[15][15],mx;
struct node{
    int a[105][105];
    void clear(){
        memset(a,0,sizeof(a));
    }
    friend node operator*(node x,node y){
        node z;
        z.clear();
        for(int i=1;i<=10*n;i++)
            for(int j=1;j<=10*n;j++)
                for(int k=1;k<=10*n;k++)
                    z.a[i][j]=(z.a[i][j]+x.a[i][k]*y.a[k][j])%Mod;
        return z;
    }
}x,E;
int main(){
    x.clear();
    E.clear();
    cin>>n>>t;
    mx=n;
    for(int i=1;i<=n;i++)
        for(int j=1;j<=n;j++){
            char inp;
            cin>>inp;
            a[i][j]=inp-'0';
        }
    for(int i=1;i<=9*n;i++)
        x.a[i][i+n]=1;
    for(int i=1;i<=10*n;i++)
        E.a[i][i]=1;
    for(int i=9*n+1;i<=10*n;i++){
        int p=i-9*n;
        for(int j=1;j<=n;j++)
            if(a[j][p])
                x.a[i][(10-a[j][p])*n+j]=1;
    }
    while(t){
        if(t%2)
            E=E*x;
        t/=2;
        x=x*x;
    }
    // for(int i=1;i<=10*mx;i++){
    //     for(int j=1;j<=10*mx;j++)
    //         cout<<E.a[i][j]<<" ";
    //     cout<<'\n';
    // }
    cout<<E.a[10*n][n*9+1];
}
```