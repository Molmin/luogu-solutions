### Description

给定一个由 `a b c` 构成的字符串 $S$，可以选择任意两个相邻字符，用第一个覆盖第二个或用第二个覆盖第一个。求能变出多少不同的字符串，`a b c` 的个数两两差 $\leq 1$，对 $51123987$ 取模。

$1 \leq |S| \leq 150$。

### Solution

序列自动机 + dp。

等价于从 $S$ 中选出一个子序列，把每个元素复制几次得到 $T$。设状态为 $f_{i,a,b,c}$ 表示当前选到了 $i$，此时 $T$ 中 `a b c` 出现的次数为 $a ,\ b ,\ c$ 时，有多少个不同的 $T$。

令 $nxt_{i,c}$ 为 $c$ 在 $i$ 及 $i$ 之后第一次出现的位置，$0 \ 1 \ 2$ 分别代表 `a b c`。转移如下


$$f_{1,0,0,0} = 1$$

$$f_{nxt_{i,0}, a + 1, b, c} = f_{nxt_{i,0}, a + 1, b, c} + f_{i,a,b,c}$$

$$f_{nxt_{i,1}, a, b + 1, c} = f_{nxt_{i,1}, a, b + 1, c} + f_{i,a,b,c}$$

$$f_{nxt_{i,2}, a, b, c + 1} = f_{nxt_{i,2}, a, b, c  + 1} + f_{i,a,b,c}$$

解释一下，如果 $S_i =$ `a` 那么 $f_{i,a,b,c}$ 会转移到 $f_{i,a+1,b,c}$，再转移到 $f_{i,a+2,b,c}$，相当于 $S_i$ 在进行复制。那么 $f_{i,a,b,c}$ 应该如何向 $i$ 后面的字母转移呢？假设下一个进行复制的字母是 `b`。首先你的 `b` 只能来源于 $i$ 后面的字母，如果来源于 $i$ 前面的字母，那么你就不可能选 `a`。其次，我们要保证不会算重，如果同时向 $i$ 后面的所有 `b` 进行转移，比如 $S=$ `abb` 那么可以选第二个 `b` 进行一次复制，也可以选第三个 `b` 进行一次复制。这样得到的是相同的 $T$，但是答案会算两次。所以转移到 $nxt_{i,1}$ 就可以了。

还有一个需要思考的地方，比如 $S=$ `aba`，我们选第一个 `a` 进行复制，和不选第一个 `a` 而是选第三个 `a` 进行复制，都可以得到 $T=$ `aaa`。所以我们要钦定只有第一个 `a` 才可以直接在空串的基础上进行复制，且第一个 `a` 不能直接转移到第三个 `a`。

枚举 $i ,\ a ,\ b ,\ c$。如果有 $a + b + c = n $ 且 $|a-b|, \ |a - c|, \ |b-c| \leq1$，那么将 $f_{i,a,b,c}$ 计入答案。

因为每个字符出现的次数不会超过 $\frac{n + 2}{3}$，所以时空复杂度为 $O(\frac{n^4}{27})$。

### Code

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 150 + 5, p = 51123987;
char s[N];
int f[N][(N + 2) / 3][(N + 2) / 3][(N + 2) / 3], nxt[N][3], n, ans;
int main() {
    scanf("%d%s", &n, s + 1);
    nxt[n + 1][0] = nxt[n + 1][1] = nxt[n + 1][2] = n + 1;
    for(int i = n; i >= 1; i--) {
        nxt[i][0] = nxt[i + 1][0];
        nxt[i][1] = nxt[i + 1][1];
        nxt[i][2] = nxt[i + 1][2];
        if(s[i] == 'a') nxt[i][0] = i;
        if(s[i] == 'b') nxt[i][1] = i;
        if(s[i] == 'c') nxt[i][2] = i;
    }
    f[1][0][0][0] = 1;
    for(int i = 1; i <= n; i++)
        for(int a = 0; a <= (n + 2) / 3; a++)
            for(int b = 0; b <= (n + 2) / 3; b++)
                for(int c = 0; c <= (n + 2) / 3; c++)
                {
                    if(a + b + c == n && abs(a - b) <= 1 && abs(a - c) <= 1 && abs(b - c) <= 1) 
                    	ans = (ans + f[i][a][b][c]) % p; 
                    f[nxt[i][0]][a + 1][b][c] = (f[nxt[i][0]][a + 1][b][c] + f[i][a][b][c]) % p;
                    f[nxt[i][1]][a][b + 1][c] = (f[nxt[i][1]][a][b + 1][c] + f[i][a][b][c]) % p;
                    f[nxt[i][2]][a][b][c + 1] = (f[nxt[i][2]][a][b][c + 1] + f[i][a][b][c]) % p;
                }
    printf("%d\n", ans);
    return 0;
}
```