这题题解好少，就发了一篇。

这是一道代码量比较少的蓝题，我的代码只有 34 行。

### 题目描述：

小 E 与 小 W 进行一项名为 `E&D` 游戏。

游戏的规则如下：桌子上有 $2n$ 堆石子，编号为 $1 \sim 2n$。其中，为了方便起见，我们将第 $2k-1$ 堆与第 $2k$ 堆（ $1 \le k \le n1 \le k \le n$ ） 视为同一组。第 $i$ 堆的石子个数用一个正整数 $S_i$ 表示。

一次分割操作指的是，从桌子上任取一堆石子，将其移走。然后分割它同一组的另一堆石子，从中取出若干个石子放在被移走的位置，组成新的一堆。操作完成后，所有堆的石子数必须保证大于 $0$。显然，被分割的一堆的石子数至少要为 $2$。两个人轮流进行分割操作。如果轮到某人进行操作时，所有堆的石子数均为 $1$，则此时没有石子可以操作，判此人输掉比赛。

小 E 进行第一次分割。他想知道，是否存在某种策略使得他一定能战胜 小 W。因此，他求助于小 F，也就是你，请你告诉他是否存在必胜策略。例如，假设初始时桌子上有 $4$ 堆石子，数量分别为 $1,2,3,1$。小 E 可以选择移走第 $1$ 堆，然后将第 $2$ 堆分割（只能分出 $1$ 个石子）。接下来，小 W 只能选择移走第 $4$ 堆，然后将第 $3$ 堆分割为 $1$ 和 $2$。最后轮到小 E，他只能移走后两堆中数量为 $1$ 的一堆，将另一堆分割为 $1$ 和 $1$。这样，轮到小 W 时，所有堆的数量均为 $1$，则他输掉了比赛。故 小 E 存在必胜策略。

### 思路：

对于相邻的两个数，我们将其视为一组，那么（ $1,1$ ）的 SG 函数值为 $0$，然后进行列举：

```
1: 0 1 0 2 0 1 0 3 0
2: 1 1 2 2 1 1 3 3
3: 0 2 0 2 0 3 0
4: 2 2 2 2 3 3
5: 0 1 0 3 0
6: 1 1 3 3
7: 0 3 0
8: 3 3
9: 0
```

如果我们斜着看，也就是将一个数分解成两个数之和后，可以得到的后续状态的 SG 函数：

```
2: 0
3: 1
4: 0 1
5: 2
6: 0 2
7: 1 2
8: 0 1 2
9: 3
```

这看起来很像二进制的表示方法，实际上就是二进制来表示，当我们遇到一个局面的时候，其 SG 函数就可以直接这样得到了。

### CODE：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 100010;
int head[N], num, sg[N];
int main()
{
	int T;
	scanf ("%d", &T);
	while(T --)
	{
		int n, ans = 0;
		scanf ("%d", &n);
		n >>= 1;
		for (int i = 1; i <= n; i ++)
		{
			int a, b;
			scanf ("%d %d", &a, &b);
			a --; b --;
			a |= b;
			int temp = 0;
			while (a & 1)
			{
				++ temp;
				a >>= 1;
			}
			ans ^= temp;
		}
		if (ans)
			printf ("YES\n");
		else
			printf ("NO\n");
	}
	return 0;
}
```
