
虽然下面有大佬已经证过本题结论了，但是还是自己写了一个证明，感觉有一点不一样，不知道证明是否正确。请大佬查错。

# 题意

有一些游戏，每个游戏都是这样的：

有两堆石子，每次操作可以丢掉其中一堆，并且把另一堆分至少一个到丢掉的这堆，保证每堆至少有一个石子，不能操作的人输。

每次可以挑一个游戏操作，最后不能操作的人输。

# 思路

首先打表找出规律，我们知道了$sg(i,j)=f((i-1)|(j-1))$，$f(x)$表示$x$二进制下最低的0位。然后就可以做题了，事实胜于雄辩。

无聊之余，我们来证明这个思路的正确性。

设$S(i)=\{sg(x,y)|x+y=i\}$，那么$sg(i,j)=mex(S(i) \cup S(j))$。

然后我们只要说明$S(i)$中的元素就是$i-1$在二进制下的所有1位即可。

首先$i=1$时，$S(i)=\varnothing$，成立。

现在假设$i-1(i\ge 2)$时结论正确性已经被证明，考虑$i$时的情况，$S(i)=\{f(x|y)|x+y=i-2\}$。对于某一组$x$和$y$，假设$f(x|y)=k$，那么$x$和$y$的后$k+1$位大概长这个样子：

| | k | k-1 | k-2 | ...| 1 | 0 |
|-----------: |-----------: |-----------: |-----------: |-----------: |-----------: |-----------: |
|x| 0 | 1 | 0 | ... | 1 | 0 |
|y| 0 | 1 | 1 | ... | 0 | 1 |

所以$0$ ~ $k$位相加的和的范围是$[2^k-1,2^{k+1}-2]$，因为$i-1=x+y+1$，所以$i-1$的后$k+1$位的范围应该是$i-1\in [2^k,2^{k+1}-1]$，第$k$位肯定是1。所以我们证明了$S(i)$只可能包含$i-1$的1位，那么接下来证明$i-1$所有的1位都在$S(i)$中。

先系统地描述一下这个命题，即$\forall k \in S(i)$，都存在一组$x,y(x+y+1=i-1)$使得$f(x|y)=k$。
因为$x|y$的第k位是0，$0$ ~ $k-1$位全是1，所以类似上面的证法，
要想满足$f(x|y)=k$必须满足$(x+y+1)mod\; 2^{k+1} \in [2^k,2^{k+1}-1]$。
又因为$i-1$的第k位是1，所以$(x+y+1)mod \; 2^{k+1}=(i-1)mod \; 2^{k+1} \in [2^k,2^{k+1}-1]$。
所以一定存在一组$x,y(x+y+1=i-1)$，使得$f(x|y)=k$。

证毕！



# 代码



```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 2e4+10;
int T, n, ans;

int lowzero(int x){
    for (int i = 0; ; ++i, x >>= 1)
        if (!(x & 1)) return i;
}

int main()
{
    for (scanf("%d", &T); T--; ){
        ans = 0;
        for (scanf("%d", &n), n >>= 1; n--; ){
            int x, y;
            scanf("%d%d", &x, &y);
            ans ^= lowzero((x - 1) | (y - 1));
        }
        printf("%s\n", ans ? "YES" : "NO");
    }
    return 0;
}
```
