## 思路

首先可以用 SG 定理把这个问题转换成求一组石子的 SG 值，然后再异或起来。

设 $\text{SG}(x,y)$ 为当前状态下的 SG 值。再设 $S_z=\{\text{SG}(x,y)|x+y=z,x,y\in N_{+}\}$，则根据题意，$\text{SG}(x,y)=\text{mex}(S_x \cup S_y)$。

接下来有一个重要结论：$S_z$ 是 $(z-1)$ 在二进制下 $1$ 的位置集合（位置从 $0$ 开始，下同）。

考虑使用数学归纳法证明。

首先，当 $z=1$ 的时候，$S_z=\varnothing$，等于 $0$ 在二进制下 $1$ 的位置集合。

接下来，假设 $1\sim z-1$ 的时候上面的结论已经证明了，现在来证明 $z$ 的时候是对的。

考虑 $x,y \le z-1$ 时 $\text{SG}(x,y)$ 有什么性质。因为 $S_x,S_y$ 都是 $x-1,y-1$ 在二进制下 $1$ 的位置，所以 $S_x \cup S_y$ 就是 $(x-1)|(y-1)$ 在二进制下 $1$ 的位置。设 $f(x)$ 为 $x$ 在二进制下第一个 $0$ 的位置，则 $\text{SG}(x,y)=f((x-1)|(y-1))$。

再来看 $S_z$ 的定义：$S_z=\{\text{SG}(x,y)|x+y=z,x,y\in N_{+}\}$。那么这里的 $x,y$ 一定都 $\le z-1$。所以 $S_z=\{f((x-1)|(y-1))|x+y=z,x,y\in N_{+}\}$。

转换一下，将 $z,x,y$ 都减一，变成了 $T_z=\{f(x|y)|x+y+1=z,x,y \in N\}$。所以现在就需要证明 $T_z$ 是 $z$ 在二进制下 $1$ 的位置集合。

现在就要对二进制位是 $1$ 或 $0$ 两种情况分别证明。

* 对于 $z$ 的二进制下 $1$ 的位置 $k$，存在一对 $x,y$ 满足 $x+y+1=z$ 使得 $f(x|y)=k$。当 $k=0$ 时，构造 $x=0,y=z-1$ 即可，因为 $z-1$ 的最后一位一定是 $0$。否则，构造 $x=2^k-1,y=i-2^k$ 即可。因为 $x$ 保证了第 $0 \sim k-1$ 位都是 $1$，此时 $x$ 第 $k$ 位已经没有了，而 $y$ 的第 $k$ 位一定是 $0$。

* 对于 $z$ 的二进制下 $0$ 的位置 $k$，不存在一对 $x,y$ 满足 $x+y+1=z$ 使得 $f(x|y)=k$。当 $z$ 的第 $0 \sim k-1$ 位都是 $0$ 的时候，减一后 $z$ 的第 $0 \sim k$ 位就都变成 $1$ 了。但要求 $x,y$ 的第 $k$ 位都是 $0$，这样就要求每一位都有进位。但是在第 $0$ 位的时候一定不会有进位，所以不存在。否则，减一之后不会影响第 $k$ 位，且前面必然至少存在一个 $0$。又因为 $x,y$ 的第 $0 \sim k-1$ 位 $x,y$ 至少有一个 $1$，所以 $0$ 必然会产生进位。接下来，每一位都会产生进位。一直到第 $k$ 位，此时 $x,y$ 的第 $k$ 位是 $0$，加上进位就变成 $1$ 了，与 $z$ 的第 $k$ 位是 $0$ 矛盾。所以不存在。

这样就证明了这个结论。

因为这个结论成立，所以根据上面，$\text{SG}(x,y)=f((x-1)|(y-1))$。这样求出每个 $\text{SG}(x,y)$ 然后异或起来即可。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n; int a[20010];
int f(int x)
{
	int now=0;
	while(x%2) x/=2,++now;
	return now;
}
int main()
{
	int t; cin>>t; while(t--)
	{
		cin>>n;
		for(int i=1; i<=n; ++i) cin>>a[i];
		int now=0;
		for(int i=1; i<=n; i+=2) now^=f((a[i]-1)|(a[i+1]-1));
		cout<<(now?"YES":"NO")<<'\n';
	}
	return 0;
}
```