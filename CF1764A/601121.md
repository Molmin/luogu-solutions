非常奇怪的一道题！你说他难吧，他的代码和思路比谁都简单。但你说他简单吧，对于萌新来说想一天都不一定明白。
## 题目概括
Doremy 有 $n$ 桶油漆，用一个长度为 $n$ 的序列 $a$ 表示。第 $i$ 个桶中的颜料编号为 $a_i$。定义 $c(l,r)$ 为从 $a_l$ 到 $a_r$ 的子串中颜料种类的数量（及相同的颜料只算一次）。请找出一对 $l$ 和 $r$ 使得 $l \leq r$ 并且 $r-l-c(l,r)$ 的值最大。

输入 $t$ 组数据。
## 题目思路
要是我和你说不管输入数据是什么只需要输出 1 和 $n$ 你信不信?其实就是这样，我们来证明一下！

为了让结果过更大，我们想要 $r$ 更大，$l$ 和 $c(l,r)$ 更小，先不考虑 $c(l,r)$ 的话，$r$ 选 $n$，$l$ 选 1 是最优情况。那 $c(l,r)$ 呢？他指的是这个子串中不同元素的个数，想要他越小，那么相同元素的个数应该越多。而 $c(1,n)$ 就包含了所有的相同元素，做到最优，但每增加一个不必要的元素，总元素个数会增加 1 ，而 $c(l,r)$ 也会增加 1 ，一抵消，也就相当于没有增加不必要的元素，所以永远会保持最优。

注：根据这个思路写完代码会发现样例不对，但是照样能通过。这是因为这道题对于每个输入数据其实有多种满足要求的输出，而样例只是给出其中的一种，题目在判断时，你的输出只要是其中一种，就都能通过！
## 通过代码
```cpp
#include<iostream>
using namespace std;
int a[100005];
int main()
{
	int t;
	cin>>t;
	while(t--)
	{
		int n;
		cin>>n;
		for(int i=1;i<=n;i++)
		{
			cin>>a[i];
		}
		cout<<1<<" "<<n<<endl;
	}
	return 0;
}
```
这个代码没什么好说的，就不加注释了。