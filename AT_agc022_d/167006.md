## 题意  

有一辆车在 $0$ 到 $L$ 号点之间不停地往返。  
有 $n$ 个点，第 $i$ 个点在 $x_i$ 位置。  
你必须在某个时刻，车经过它的时候下车，经过至少 $t_i$ 单位时间后才能上车。  
问你从 $0$ 号点出发，最终回到 $0$ 号点的最短时间。  

## 题解

首先显然答案是 $2L$ 的若干倍，我们只需计算来回的数量。  

考虑如果 $t_i$ 超过 $2L$ 的几倍这部分可以直接加到答案里去，并且将 $t_i \gets t_i \bmod 2L$。  

我们可以把所有的点分成 $4$ 类：  
考虑车往左开的时候和车往右开的时候你选择下车，经过 $t_i$ 时间后你上车时方向是怎样的。  
有 一定不变、一定变、一定变成左、一定变成右 $4$ 类。  

一定不变的点比较好处理，相当于是你什么时候下车都只是给答案加了一个来回，不会有任何影响。  

剩下的点中，在你下车的这一段时间，车一定至少改变了 $1$ 次方向。  
或者说：  
- 一定变的点（以下称为双向点），一定改变 $1$ 次方向。  
- 一定变成左的点（以下称为左点），只有在车从右边开来的时候下车，才会只改变 $1$ 次方向。  
- 一定变成右的点（以下称为右点），只有在车从左边开来的时候下车，才会只改变 $1$ 次方向。  

也就是说，一个来回最多只能下 $2$ 次车。  
并且还需要满足，这两个点中，左边是一个左点或双向点，右边是一个右点或双向点。  
每有这么一个匹配，答案就会少 $1$。  

实际上还有一个性质，就是任何右点一定在左点的右边。  
那么我们用一个栈之类的东西维护匹配即可。  

还有一些细节，比如第 $n$ 个点无法进行匹配之类的。实现的时候还是需要仔细思考的（即使代码很短）。  


## 代码  
```cpp
int n,L,p;
int x[N],t[N];
int top,sum,ans;
int l[N],r[N];
signed main()
{
    rd(n);rd(L);p=n;ans=n+1;
    for(int i=1;i<=n;i++) rd(x[i]);
    for(int i=1;i<=n;i++) rd(t[i]),ans+=t[i]/(2*L),t[i]%=2*L;
    for(int i=1;i<=n;i++){if (!t[i]) {ans--;continue;}l[i]=2*(L-x[i])>=t[i];r[i]=2*x[i]>=t[i];}
    ans-=l[n];
    for (int i=1;i<n;i++) if (l[i] || r[i]){if (!l[i]) {p=i;break;}if (r[i]) top++;else if (top) top--,ans--;}
    sum+=top,top=0;
    for (int i=n-1;i>=p;i--) if (l[i] || r[i]){if (!r[i]) break;if (l[i]) top++;else if (top) top--,ans--;}
    sum+=top;ans-=sum/2;ans*=2*L;
    write(ans);cout<<endl;
}
```