## 看了许多 _Dalao_ 的题解，好像没有人写有规律的原因，那我就发一篇题解来说说为什么 ans = (min(n, m) - 1) * 2（其实也就是证明一下ans = (min(n, m) - 1)）
其实我感觉这道题更想一道递推题

首先，只要转一次就走到头，并且不瞎转，出来的结果基本所需最少转弯次数，所以我走的策略是没有问题的（你也可以自己找策略），上一张图4 * 3的长方形遍历图

![](https://cdn.luogu.com.cn/upload/image_hosting/77mxe6nf.png)

（黄色代表起始点）

第一点：我们可以看出，其实3 * 4的长方形与边长为3的正方形转弯次数是一样的，只不过是横着走时要多走一格，但那与我们要数的转弯次数无关（样例2也说明了这一点）

所以我们要算的其实就是遍历边长为min(n, m)的正方形所需转弯次数，问题变成了这个图：

![](https://cdn.luogu.com.cn/upload/image_hosting/lzvqju2a.png)

这时，再上一张图

![](https://cdn.luogu.com.cn/upload/image_hosting/8gcht825.png)

第二点：我们可以发现，边长为3（或者说是n）的正方形遍历最小转弯数（整张图）其实就是边长为2（或者说n - 1）的正方形遍历最小转弯数（粉色部分） + 2（浅蓝色园圈出来的点）

那么我们设边长是n形的正方形遍历最小转弯数为f[n],则f[n] = f[n - 1] + 2,而f[1] 等于0（没什么好说的）这就是一道递推题了！

这时我们再化简，f[n] = （n - 1） * 2  (这也没什么好说的)，在结合第一点，就可以得出 ans = (min(n, m) - 1) 了

论证完毕

上代码！！！！

```cpp
#include <iostream>
using namespace std;

int main()
{
	int k;
	cin >> k;
	for(int i = 1; i <= k; i++)
	{
		int n, m;
		cin >> n >> m;
		cout << (min(n, m) - 1) * 2 << endl;
	}
	return 0;
}
```


完结散花！

~~最后再无耻地求波赞~~

萌新第一次发题解，管理员大大求过！

