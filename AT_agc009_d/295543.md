题意可以抽象为给出一个构造点分树的方式，求点分树的叶子节点的最大深度最小。

我们从叶子向根考虑这个问题，设 $f_{x}$ 表示点 $x$ 在点分树上到它的所有儿子的最远距离。我们有

结论：$\forall i,j ,f_i=f_j $ 必然存在在原树上 $i,j$ 两点之间的一个点 $z$ ，使得 $f_z>f_i$

证明：我们从原树上取出任意一个点对 $i,j$。我们取出这个点对在点分树上的 $lca$ 。首先从 $i$ 到 $j$ 有一条经过 $lca$ 在点分树的路径，我们得证明这条路径上没有重复的点，首先从 $i$ 到 $lca$ 或 从 $j$ 到 $lca$ 都不会有重复的点。因为点的权值是单增的。其次，这两条链之间不会有重复的点(除 $lca $)。因为如果有重复的点，这两个点必然会在第一个重复点的时候被合并。不满足我们找到 $lca$ 的定义。

有了这个结论之后，考虑这么一个构造，我们从叶子向根构造。我们对于每个点 $i$ 存一个集合。集合里的元素 $x$ 满足从 $x$ 到 $i$ 的路径上不存在点 $j$ 使得 $f_j>f_x$ 。假设我们考虑到了点 $x$ 作为根，首先对于 $x$ 的儿子的集合中出现过的数，我是一定不能选作为 $x$ 的权值的。因为如果选了这些权值，那么 $x$ 和这些点之间就满足上述结论了。同理，如果任意两个儿子同时出现了某一个权值，我也不能选这个权值。

具体实现可以用类似状压的方式。
```
int f[maxn];
int ans=0;
inline void dfs(int x,int fa){
	int s=0,p=0;
	for(auto y:e[x]){
		if(y==fa) continue;
		dfs(y,x);
		for(int i=0;i<=20;i++){
			if(((s>>i)&1)&&((f[y]>>i)&1) ) p=max(p,i+1);
		} s|=f[y];
	} while(((s>>p)&1)) p++;
	ans=max(ans,p);
	f[x]=s|((1<<(p+1))-1);
	f[x]=f[x]^((1<<p)-1);
	return ;
}
```
