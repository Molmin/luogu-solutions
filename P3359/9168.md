终于过了。

1对于z=0的情况，我们逆序加边，用并查集记录块的大小sz，每次贡献即sz[x]\*sz[y]。

(30分了)

2对于n=1000的情况:

首先，sx,y=0<=>s[x,k]=s[y,k]，其中x,y,k都是任意的。

简单的证明一下：

若k在x,y路径上，这显然成立；

否则s[x,k]与s[y,k]一定有一个重复的部分(应该有三种情况)，

因为x xor x=0,x xor 0=x,所以也成立。(自己画个图就能懂)

所以我们可以任意选一个标准点做根，先dfs出到所有点的s,那么对于任意两点就可以O(1)判断了。

那么我们逆序加边，计算贡献时每次暴力枚举两个块的所有点，判断s[x,root]是否=s[y,root]就行了。

(50分了)

3对于n=10^5:

我们在3的基础上，对每个块建一个平衡树。

计算贡献时，我们选择较小的树x，枚举所有点，logn查找它在y树中的个数，并logn加入y中。

这样最多只有nlogn次操作(显然像归并排序一样时最差,虽然我也不会证明),

时间nlog^2n。

可以自己写splay(我只会splay),也可以用map。(我的splay比map快了3倍)

记得用long long!（我改成long long结果忘了printf时用lld。。）

刚刚看了线段树合并的论文，发现这题先离散化，之后用动态加点线段树来存储，合并，就是nlogn的了(因为论文里说n个树合并这一定不会比插入n次差)。

论文里觉得太显然没有证明复杂度，然而我不能理解，于是自己想了个证明。

先叙述一下合并的过程。

对相同的节点(指都拥有的节点)是加和，之后递归处理左右儿子的，

而对于不同节点，也就是一个树有它另一个树没有它，或者两个树都没有的，我们直接取存在的那一个拿来用，之后exit。

根据这个过程，一次的时间=(两个线段树)相同节点个数+相同节点的不相同儿子的个数。

由于一个相同节点最多有两个儿子，所以时间<=3\*相同节点个数。

由于每一次合并相同节点后的线段树相比较于之前两个线段树，相当于失去了相同节点个数的节点；

而初始总结点数=nlogn，所以线段树失去的节点总数<=nlogn，也就是相同节点总个数<=nlogn。

所以总时间<=nlogn。

(然而比我启发式合并的splay慢，可能是数据问题)
