~~RMJ是废了吗，几乎每次交都是UKE~~

~~别问为什么标题这样写，问就是写成Takahashi's Solitaire会炸~~

题目意思翻译里已经讲得很清楚了。既然是要手中的牌总和最小，自然是要让桌上的牌总和最大。

首先，因为我们不一定要按照题目中给的顺序来放牌，所以我们可以考虑将所有的牌按从小到大的顺序排序。这样会方便我们进行取牌的操作。

接下来怎么做呢？很显然，因为我们需要让取出来放到桌面上的牌的总和最大，所以我们需要采取贪心的策略，能取就取。所以，我们需要从第一张牌开始，判断后面的牌可不可以取。能取就取出来，不能取就算答案，然后从下一张开始重新取。为什么不用从头开始取呢？因为从刚才取过的开头那一张的后面开始取答案只会更小，没有必要。毕竟每张牌上面的数都是非负整数。

最后一个问题：取到最后一张之后还能取怎么办？一般我们的思路都是回到开头继续取，但是显然没有这个必要。当我们的数组的最后一个元素需要连接第一个元素时，我们可以索性把整个数组接在最后一个元素后面（相当于是把牌复制了一份），并且把接上的数组的每个元素都加上 $m$。因为 $a \equiv (a + m)\pmod{m}$，所以我们在计算答案的时候让 $a_i$ 对 $m$ 取模，这样子既可以保证牌上数字的单调性（因为 $0 \leq a_i < m$），又可以方便计算答案。

但是这样会带来一个新问题：如果无论从哪个地方开始取牌都可以取完，那么我们的算法会取双倍的牌出来。

比如下面这组数据：

```
5 5
0 1 2 3 4
```

正确答案显而易见是 $0$，但是我们的算法因为会多取一倍的牌出来，导致答案变成了 $-10$。~~手上还剩负数张牌，这不扯淡吗~~

怎么办呢？其实很简单，给取的牌加一个张数限制，当取出的牌达到 $n$ 张之后，你能取也不能再取了，必须出来统计答案。

这么一套操作下来，题目也就解决啦~

贴个代码：

```cpp
#include<bits/stdc++.h>
#define N 400000
#define int1 long long
using namespace std;
int1 n,nn,m,a[N + 5],ans,i,j,sum,s,len;//sum表示取出的牌的和，ans表示桌上的牌总和的最大值，len表示取出的牌的张数（偷懒写成了长度length）。 
void C(){//关同步（加速读入输出用的）。 
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	return ;
}
int main(){
	C();
	cin >> n >> m;
	nn = (n << 1);//总牌数（因为复制了一遍牌）。 
	for(i = 1; i <= n; i++){
		cin >> a[i];
		s += a[i];//牌的总和。 
	}
	sort(a + 1,a + n + 1);//排序。 
	for(i = 1,j = n + 1; i <= n; i++,j++){
		a[j] = a[i] + m;//复制牌。 
	}
	for(i = 1,j = 0; i <= nn; i++,j++){
		if(a[i] - a[j] <= 1 && len < n){//如果还能取就取牌。 
			sum += a[i] % m,ans = max(ans,sum),len++;
		}else{//不能取就滚（bushi）。 
			sum = a[i] % m,ans = max(ans,sum),len = 1;//其实是重新取。
		}
	}
	cout<< s - ans << endl;//拿总和减去拿出去的最大值，得到的就是拿在手里的最小值。 
	return 0;
}
```
