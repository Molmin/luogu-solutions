好题。不看题解不会写题系列。 

~~虽然AC自动机的题解本来就没几篇我还一篇都没看懂~~


~~一开始口胡的写法是对的不过因为一个小瑕疵写挂了~~ 

建议先写过[文本生成器](http://www.cnblogs.com/refun/p/8706911.html)再来写这个题

不然这个题解可能看不懂

而且因为我比较菜不会的东西太多所以这个题解可能很长……

 
考虑暴力，我们会发现这个题和我做过的BZOJ1030好像几乎一模一样……

就连DP式子都一样

只不过N太大了没法转移是么……

贴一段文本生成器的AC代码。

```cpp
for (int i=1;i<=m;++i)
	for (int j=0;j<=sz;++j)
		for (int k=0;k<26;++k)
			if (!End[Son[j][k]])
				(f[i][Son[j][k]]+=f[i-1][j])%=MOD;
```
我们发现外层的m(也就是本题的N)循环的时候，里面两个循环每次进行的转移都是机械一样的。

都是根据父亲的状态来推儿子的状态。

这样的话，我们就可以用矩阵快速幂来优化了。


举个例子

4 3 100

111

这是样例。

我们将初始矩阵start定义为[1,0,0]，这对应的是文本生成器一题中的初始化f[0][0]=1; 

然后将x节点与x的所有儿子节点在转移矩阵a中a[x][son]+=1

这样在矩乘转移的时候我们就可以把父亲的状态推到儿子了 

最后答案即为start*a^n


因为很容易发现,start是f[0][]的所有状态

start*a是f[1][]的所有状态

那么start*a^n即为f[n][]的所有状态

将start*a^n矩阵里的所有数值加起来即为所求答案。

orz感觉自己已经是一条咸鱼了


对了送组数据: 

1000000000 19 9973

1010100110011000001 

5753

代码戳→[蒟蒻的博客](http://www.cnblogs.com/refun/p/8710926.html)