由于公主发出“哦”的声音和发出“哇”的声音是互不影响的，所以对于本题我们不难想到一种 $t$ 数列的构造方式：

当公主发出”哦“的声音和”哇“的声音的次数非零时，优先考虑让公主先”哇“。”哇“完后再让公主发出”哦“的叫声。那么即我们可以将第一个新郎的财富值设为 $1$ ，用 $sum$ 表示前面新郎财富的总和，若 $b$ 非零时，当前新郎的财富值为 $sum+1$ ，否则若 $a$ 非零，当前新郎的财富值等于前一个新郎的财富值 $+1$ ，否则新郎的财富等于前一个新郎。

然而，上述构造方法存在一定问题。

看下面一组数据：

```php
9 6 0
```

这时我们应该先让第二位新郎的财富等于 $1$ ，否则公主会发出“哇”的叫声，不符题意，会错误的输出 $-1$ ,所以将这种情况考虑后，我们的算法就正确了。

下面给出代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a,b;
int s[105];
int main()
{
	scanf("%d%d%d",&n,&a,&b);
	s[1]=1;
	int sum=1;
	int st=2;
	if(a&&b==0)
	{
		st=3;
		s[1]=s[2]=1;
		sum=2;
	}
	for(int i=st;i<=n;i++)
	{
	    if(b){
			s[i]=sum+1;
			if(s[i]>50000){
			   puts("-1");
			   return 0;
			}
			b--;
			sum+=s[i];
		}
		else if(a){
			s[i]=s[i-1]+1;
			if(s[i]>50000){
				puts("-1");
				return 0;
			}
			a--;
			if(s[i]>sum){
				puts("-1");
				return 0;
			}
			sum+=s[i];
		}
		else s[i]=s[i-1];
	}
	if(a==0&&b==0){
		for(int i=1;i<=n;i++)printf("%d ",s[i]);
	    puts("");
	}
	else puts("-1");
	return 0;
}
```



