**题意**

首先给定$m$个长为$n$的串，和踩中每个需付的代价。

定义每次操作从$\underbrace{000....00}_{n}$开始，每步可以任选至少一个$0$变成$1$，当所有串变成$\underbrace{111....11}_{n}$时，操作结束。

在操作过程中，如果在某时刻序列和之前给定的序列相同，那么要付给定序列的代价。

问在这数不清的不同操作都做完之后（两次操作相同当且仅当变换过程**完全**相同），一共要付的代价，对$998244353$取模。


~~哇这个题真实的难读懂啊qwq~~

**以下分析**

先来考虑对于一个给定串$s$，有多少个操作（设为$ans$）会撞上它。

可以注意到，**答案跟数字的位置无关**，所以我们可以先把串抽象出来，数出有$c$个$1$，$(n-c)$个$0$。

那么这$c$个$1$，可能是由$c-1$个$1$的串转移而来，可能是$c-2,c-3......0$个$1$的串转移而来。

### dp!

设$f[i]$为转移成$i$个$1$的方案数。

转移方程：$f[i]=\sum_{j=0}^{j-1}(f[j]*C_{i}^{j})$。

其中$C_i^j$是因为有$C_i^j$种方式从$j$个$1$转移成$i$个$1$。（在$i$个里面钦定$j$个为原有的$1$的方案数为$C_i^j$）

那么从$000.....0$转移到$s$的方案数就为$f[c]$。

而从$s$转移到$111.....1$的方案数可以倒着思考：从$111.....1$转移到$s$，有$(n-c)$个$1$变成了$0$对叭。

所以可以直接操起求过的$f$数组，从$s$转移到全$1$串的方案数就为$f[n-c]$。

然后用乘法原理乘起来，就得到了会经过串$s$的操作数，再乘上串$s$的单次代价就是这个串造成的总代价了。

最后把$m$个串的代价加起来就是答案。

```
/*
	qwerta 
	P4996 咕咕咕 Accepted 
	100
	代码 C++，0.6KB
	比赛 【LGR-055】洛谷11月月赛
	提交时间 2018-11-04 11:58:31//下考前几十秒发现自己忘开long long，太真实了qwq
	耗时/内存 108ms, 804KB
*/
#include<iostream>
#include<cstdio>
using namespace std;
#define LL long long//一年OI一场空，不开long long见祖宗
const int mod=998244353;
LL f[23];
char s[23];
LL je(int x)//返回x!（因为20!没爆long long就直接乱搞了
{
    LL ans=1;
    while(x)
    {
        ans*=x;
        x--;
    }
    return ans;
}
LL C(int q,int w)//返回C(q,w)
{
    return je(q)/je(w)/je(q-w);
}
int main()
{
    ios::sync_with_stdio(false);
    int n,m;
    cin>>n>>m;
    f[0]=1;//初始化
    //先把f预处理出来
    for(int i=1;i<=n;++i)
    {
        for(int j=0;j<i;++j)
        {
            f[i]+=C(i,j)*f[j]%mod;
            f[i]%=mod;
        }
    }
    LL ans=0;
    for(int i=1;i<=m;++i)
    {
        cin>>s;
        int c=0;//c为s中1的个数
        for(int j=0;j<n;++j)
        c+=s[j]-'0';
        int v;//这个串的单次代价
        cin>>v;
        ans+=(LL)f[c]*f[n-c]%mod*v%mod;
        ans%=mod;
    }
    cout<<ans;
    return 0;
}
```