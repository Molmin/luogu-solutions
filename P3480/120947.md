## Solution

博弈论 .

首先要满足单调不降 , 这启示我们使用差分 .

差分之后 , 我们发现 , 取走一些石子 , 本质是把它从差分序列中往右移动一些 . 这个序列最右边是垃圾桶 , 石子扔进去就拿不出来了 .

我们大胆猜测 : 必胜条件等价于所有石子数异或起来不等于 $0$ , 模仿 Nim 游戏 . 真的是这样吗 ?

我们判断给先手必胜找到一个充分必要条件 , 需要满足一下特征 :

- 最终状态是这个条件的反命题 .
- 必胜状态可以转移为必败状态 .
- 必败状态只能转化为必胜状态 .

考虑到我们是把一堆石子往右移 , 变了 $2$ 堆 , 所以不好控制 .

考虑研究所有从右往左的奇数位置 , 看他们异或起来不等于 $0$ 能否满足 .

- 最终状态 , 所有非垃圾桶的石子堆都没有石子 , 满足 .
- 如果现在异或起来等于 $0$ , 随便改一个就可以啦 .
- 如果现在异或起来不等于 $0$ . 考虑异或和最高位是 $a$ 位 . 那么必有一堆石子 $a$ 位有值 . 那么把这堆石子上异或和是 $1$ 的位全部去反 . 不难发现 , 最终这堆石子数量变小 , 这是可以做到的 .

为什么不能从左往右编号呢 ? 因为假设石子堆数是偶数 , 如果只有最后一堆有值 , 那么它扔到垃圾桶的时候 , 我们要求的异或是不改变的 , 但它就胜了 . 所以我们的编号需要每次取石子都能改变答案 , 就这么做了 .

code 

```cpp
#include<bits/stdc++.h>
#define ffor(i,a,b) for(int i=(a);i<=(b);i++)
#define roff(i,a,b) for(int i=(a);i>=(b);i--)
using namespace std;
const int MAXN=1000+10;
int T,n,a[MAXN];
int main() {
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	cin>>T;
	while(T--) {
		int n;cin>>n;
		ffor(i,1,n) cin>>a[i];
		int ans=0;
		ffor(i,1,n) if((n-i+1)&1) ans^=(a[i]-a[i-1]);
		if(ans) cout<<"TAK\n";
		else cout<<"NIE\n";
	}
	return 0;
}
```