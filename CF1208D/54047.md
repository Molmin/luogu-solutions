现在有一个从$1$到$n$的一个全排列,但是你不知道这个排列到底是什么,但是你有一个$sum[i]$,其中$sum[i]$表示$\sum_{j=1}^{i-1}(a_j<a_i)?a_j:0$,现在给你$sum$数组,让你求出这个排列$a$  

乍一看十分的不可做(没错就是十分不可做)  
我们可以考虑一下,对于某一个$a_i$,我们设他前面比他小的数有$k$个,而且在$a_i$被确定之后,$a_i$就不可能再对前面的数有贡献了.所以我们可以考虑倒序枚举,即从$n$到$1$来确定每一位.  

然后我们从后往前考虑,假设我们现在考虑的是第$n$位,那么我们就可以发现 

$$sum[n]=\sum_{i=1}^{n-1}(a_i<a_n)?a_i:0$$  

看起来并不能快速的求出这个式子....不过没关系,我们考虑一下传说中的**加法结合律**.  

我们考虑某些$i<=n$,如果有某些$a_i<=a_n$,那么这些个连续的$a_i<a_n$组成的区间的$sum$(我们暂时称之为$tmp_k$),那么显然

$$\sum_{idx}tmp_{idx}=a_n$$  

我们画一张图(没错我就是灵魂画师):  

![qwq.png](https://i.loli.net/2019/08/26/x7siJzvBa3tLulf.png)

看一下这张图,~~嗯,花里胡哨~~  


我们回到之前的那个式子,显然发现,我们把那些小于$a_n$的$a_i$结合形成$idx$个$tmp$时,我们可以把那些式子想分成几组就分成几组.所以我们可以考虑到树状数组的方式.

但是这样找一次不是$nlogn$的嘛,还不如暴力找呢qwq~~暴力出奇迹~~

注意到,我们放到这个树状数组里的东西,就是按顺序排列的序列$1,2,3....n$

(为什么要这么放呢?)  

我们注意到了之前的  
$$\sum_{idx}tmp_{idx}=a_n$$  

这个式子,其实每个$tmp$都可以拆分成若干$a_i$的和,而$a_i$的值域与序列$1,2,3....n$的值域相等,所以考虑合并成若干个$tmp$的话,序列$1,2,3....n$与原来的$a$数组是完全等价的.  

模型构建完了,现在开始考虑正事.  

我们考虑当前的$a_i$(之前已经假设过这个是$a_n$了)我们看上面的那张图,可以发现:我们可以把这个树状数组的节点可以分成$log_2n$层(每一条红线代表一层,圆内的数字指这个点控制的原序列中数的个数)所以我们可以枚举每一层的树状数组的节点,$if(tree[x]+sum<=a_n)$那么我们就$sum+=tree[x]$.  

经过了这样一遍乱搞之后,~~貌似时间复杂度还是和暴力一样啊qwq~~  

我们分析这样做的复杂度瓶颈在哪里,显然,我们在枚举树状数组上的每一层的时候,我们都要把这一层所有的节点枚举一遍.**但是**我们发现,对于第$i$层的某一个节点.如果我们选中了他,那么他之前的点完全可以不用考虑了(详见上图中的蓝线,因为在倒序枚举$i$的过程中,每个节点能控制的区间长度是单调递减的).所以我们在上一种方法中,多记录一个$num$表示现在已经考虑了前$num$位.所以我们枚举的时候,我们要多判断一个$(1<<i)+num<=n$就可以了.  

好,我们现在已经推导完了特殊情况,考虑除了$a_n$之外其他$a_i$的解决~~长征只开始了第一步~~(滑稽)  

其实并没有什么特殊的东西qwq...我们发现,我们在解决了第$a_{i+1}$个数到底是多少之后,因为我们之前是倒序枚举,所以$a_{i+1}$对$a_i$已经一点影响都莫得了.我们这时候就要在树状数组进行一次单点修改(将原来的$a_{i+1}$的点修改为$0$).  

注意一点,我们这么做的理由,是因为如果$j>i$,那么$j>(i-1)$~~废话~~,所以在题目保证有解的过程中,我们完全可以这么做.

然后....就莫得东西了吧qwq....树状数组不会写的话....线段树也不错啊qwq(滑稽).  

第一次写那么长的题解,好累啊QAQ.... 

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N = 2e5 + 5;
int n;
int s[N],tree[N],ans[N];
inline int lowbit(int x){
	return (x&-x);
}
void add(int x, int delta){
	while(x<=n){
		tree[x]+=delta;
		x+=lowbit(x);
	}
    return;
}
int query(int x){
    int sum = 0;
    while(x){
		sum+=tree[x];
		x-=lowbit(x);
	}
    return sum;
}
int find(int x){
    int num = 0 , sum=0;
    for(int i=log2(n)+1;i>=0;i--)
        if((num+(1<<i)<=n)&&(sum+tree[num+(1<<i)]<=x)){
            num+=(1<<i);
            sum+=tree[num];
        }
    return num + 1;
}
signed main(void){
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0);
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>s[i];
		add(i,i);
	}
	for(int i = n; i >= 1; --i){
        ans[i] = find(s[i]);
        add(ans[i],-ans[i]);
    } 
    for(int i=1;i<=n;i++)
		cout<<ans[i]<< " ";	
    return 0;
}
```
