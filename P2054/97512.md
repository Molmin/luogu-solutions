这一题是逆元的模板题。

------------


模运算中的加法、减法和乘法，都可以直接用普通运算中的加减乘一一对应。但是，除法不一样。模运算中的除法会异常地复杂。（形如$ (a/b) mod P $)
为了简便化模运算的除法，我们可以考虑求一个数mod P的逆元。设欲求数为a，则记它的逆元为$a^{-1}$。$a(mod P)$的逆元等价为求方程$a*a^{-1}≡1(mod P)$。倘若知道一个数的逆元，则a/b就可以等价为$a*b^{-1}$，于是就实现了简便化模运算中的除法。

为了求解方程$a*x≡1(mod P)$，可以考虑使用拓展欧几里得算法。

引理1：[裴蜀定理](https://baike.baidu.com/item/%E8%A3%B4%E8%9C%80%E5%AE%9A%E7%90%86/5186593)。这一定理说明了，对于任意的一组正整数$(a,b)$，一定存在至少一组x,y使得方程$gcd(a,b)=a*x+b*y$，其中函数$gcd$表示求最大公因数。
    


在证明了有解之后，我们需要找到一种求解的方法，这种方法被称为扩展欧几里得算法($Exgcd$)，可以基于辗转相除法来理解（并且，复杂度也等同于辗转相除法）的复杂度。
对于任意的(a,b)，考虑设

$$gcd(a,b)=a*x_{1}+b*y_{1}$$

$$gcd(b, amodb)=b*x_{2}+(amodb)y_{2}$$
则可以进行如下证明：

引理2：对于任意正整数对 $(a,b)$ ，可以证明$gcd(a,b)=gcd(b,amodb)$。

设d为$gcd(a,b)$，则可设$a=k_{1}*d$,$b=k_{2}*d$。设

$$k_{1}=n*k_{2}+t(t∈[0,k_{2}))$$

则有：

$$a=n*k_{2}*d+t*d$$

故有，

$$amodb≡t*d$$

又$∵$

$$b=k2*d$$

且

$$(t∈[0,k_{2}))$$

故可得

$$gcd(b,amodb)=d$$

得证。

故，

$$a*x_{1}+b*y_{1}=b*x{2}+(amodb)*y_{2}$$

整理有：

$$a*x_{1}+b*y_{1}=b*x_{2}+(a-[a/b]*b)*y_{2}$$

$$a*x_{1}+b*y_{1}=a*y_{2}+b*(x_{2}-[a/b])*y_{2}$$
由多项式定理可得递归式：

$$x_{1}=y_{2}$$

$$y_{1}=(x_{2}-[a/b])*y_{2}$$

故，只要知道方程：

$$gcd(b,amodb)=a*x_{1}+b*y_{1}$$

的解，就可以求得方程：

$$gcd(b, amodb)=b*x_{2}+(amodb)y_{2}$$

的解。

易知，这一递归方程组在$b=0$时取到边界条件，此时模$b$同余无意义。而易知，当$b=0$时，$gcd(a,b)=a$，方程$gcd(a,b)=a*x+b*y$的解为

$$x=1,y=0$$

所以我们便可以对方程

$$gcd(a,b)=a*x+b*y$$

递归求解了。

回到我们原来的问题。我们要求a的逆元，实质上是求解方程

$$a*x≡1(mod P)$$

我们又可以将它转化为方程：

$$a*x≡P*y+1$$

即

$$a*x-P*y≡1$$;

这一形式很显然与

$$gcd(a,b)=a*x+b*y$$

相同。故可以用$Exgcd$算法求解该丢番图方程，即可算出$x$。该$x$为$a$的逆元。
特别地，当且仅当$P$与$a$互质时，该方程有且仅有一组解。

------------

为什么说这一题和逆元有关呢？
总结规律易得，对于$∀x∈[1,n]$存在每一次变换后，原序号为$x$的卡牌，会被置换到$(x*2)mod(n+1)$的位置。

因此，设$m$次变换后，$L$来自于$x$，则有同余方程：

$$(x*2^{m})≡L(modP)$$

已知$m,L,P$，通过逆元可以很容易地求解这个方程：

容易变换得：

$$(x*2^{m})≡1*L(modP)$$

于是就转化为已知的求逆元问题。

------------

另外再说一个，就是关于巨佬们使用的：

```cpp
x^=y^=x^=y
```

这个东西是用于高效交换变量的。实际类似于

$$b=a+b,a=b-a,b=b-a$$

这样的东西，只不过位运算玄学操作一波效率更高得了。

另：一开始没搞懂这个玩意儿的优先级，没理解，不过打个括号手算一下就很好理解了。

```cpp
x^=(y^=(x^=y))
```

------------

代码

```cpp
#include<iostream>
#include<cstdio>
using namespace std;

int n,m,k;

int pw2(int t){
    int ans=1;
    int x=2;
    while(t){
        if(t&1){
            ans=(long long int)ans*x%(n+1);
        }
        x=(long long int)x*x%(n+1);
        t>>=1;
    }
    return ans;
}

void exgcd(int a,int b,int &x,int &y){
    if(!b){
        x=1,y=0;
        return;
    }
    exgcd(b,a%b,x,y);
    x^=y^=x^=y;
    y-=a/b*x;
}

void init(){
    scanf("%d%d%d",&n,&m,&k);
    int p=pw2(m);
    int a,b;
    exgcd(p,n+1,a,b);
    while(a<0){
        a+=n+1;
    }
    printf("%lld",(long long)a*k%(n+1));
}

int main(){
    init();
    return 0;
}
```
