这个题在考场上，我觉得水平和我一样比较一般的选手，大都不会去思考这个正解，因为感觉这个正解太复杂了，而84分的纯暴力又太香，而我看题解区也没有什么部分分，所以就来说一下我能想到的暴力吧。

算法一：对于x = 2的点，我们模拟这个删除过程，把删除的边都打上标记。然后我们删掉所有的边，加回所有没有标记的边，过程中用并查集维护连通块即可，由于本人写并查集不按秩合并，所以有个```logn```，时间复杂度O（$\sum$
```nlogn```）。 

算法二：对于1 - 7个点，可以枚举四个端点，然后相当于x = 2的情况，调用算法一，时间复杂度O（$n ^5$```lognT```），不过还需要判定两条路径不能有交，这个可以通过跳LCA过程中打标记实现，所以最后的时间复杂度O($n ^6$```lognT```)，有很多复杂度更优的办法，不过这是暴力嘛，怎么方便怎么来。

算法三：对于x = 1的点，我们相当于在一个森林上找一条路径，使得删去这个路径得到的联通块最多。这个可以用树dp求，```f[i]```代表从i子树内一点开始，连到i的路径里删去一条最多能产生多少个联通块，```g[i]```代表i子树内的一条路径里删去一条最多能产生多少个联通块。我们可以利用类似于求树的直径的办法求出来f与g数组，各个联通块取最大即可，时间复杂度O($\sum$n)。

算法四：对于```x = 0, n <= 100```的点，我们可以枚举两个端点，用算法三的办法进行树dp，时间复杂度O($\sum$$n^3$)。

然后就获得了84分的好成绩。