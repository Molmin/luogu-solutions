总归是想不出来……

Based on eJOI2018，参考一下原题的部分分。

首先考虑 $P=1$。在时间比较小的时候可以直接定义 $dp_{i,S}$ 表示在时刻 $i$ 是否可以得到集合为 $S$ 的签证。这样可以获得 25 分，非常烂。

在此基础上考虑 $P=2$ 且时间比较小的情况。两个签证可以处理两个集合的签证，这两个集合刚好可以拼出全集。这样做一遍上面的 DP，复杂度是一样的，判断会多一点时间。现在得到 45 分了。

但是现在时间很大。遇到这种 DP 定义里有时间，并且处理的是可达性的问题，可以直接把时间这一维抽出来放到值里。定义 $dp_S$ 为最快处理完集合 $S$ 中所有的签证的时间，这样是不是就赏心悦目了。

那么转移 $dp_S$，枚举最后一个签证 $i$。要求出最快能签证完成的时间，相当于求出最早能开始完整签证的时间。上上个签证完成的时间自然是 $dp_{S \backslash i}$，但是这个时间可能不合法，比如在这个时刻 $p$ 开始签证，但是 $[p,p+t_i]$ 这个时间我们要**带着这个护照**（如果是另外一个护照的旅行就不算）去旅行就不合法，需要等到这次旅行结束之后才能去。当然开始签证时我们也不能在旅行。注意到一个不合法的起始时间更新后可能仍然不合法，需要持续更新。这样是一个跑不满的 $O(2^nn^3)$，可以获得 90 分。

想优化这个时间。一个很简单的想法是枚举 $i$ 的时候根据 $t$ 从小到大枚举，因为这样的话时间只会往后更新，原因是限制的区间越来越大，限制也就越来越紧，之前不行的现在肯定也不行。这样就不用每次从 $dp_{S \backslash i}$ 开始枚举。时间复杂度 $O(2^nn^2)$，不是很行啊，怎么办？

从限制本身入手，假设当前的时间为 $p$。第一类限制可以描述为 $p \leq s_j \leq p+t_i$（此时 $j$ 是当前护照处理的旅行），第二类限制可以描述为 $s_j \leq p < s_j+len_j$。两个限制都和 $s_j$ 强相关，考虑双指针，设两个指针分别维护两个限制即可。时间复杂度 $O(2^nn)$，现在肯定能过了。

[评测链接](https://codeforces.com/problemset/submission/1012/178958128)。