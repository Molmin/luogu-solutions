我写一篇思路形成历程

dp，我认为，顺推的话

是记录当前状态对下一个状态的影响
--

或者逆推，分析前面状态对当前状态的影响


重点是    记录
-

![样例](https://cdn.luogu.com.cn/upload/pic/86.png)

从根节点开始

比如3节点

他的选择是 

保留1个客户，获利3

他可以影响2节点

2节点对3节点上传的数据

要做出选择

要么选，要么不选

鬼知道要不要选

那2节点有个主意

把选这个的情况记录下来

不选这个的情况也记录下来 

记录，记录，要把所有的情况都记录下来

亏本的记下来

最赚钱的记下来

不亏不赚的也赚下来

当然会多耗一些精力

但有一个远古神器

数组 

不用翻页，不用笔

智商不行，全靠记忆力

f[i][j]表示，以i为根的树中，保留j个用户，获得利润的最大值

开始记录了


所以3节点现在有个两个决策
-

保留0个用户，获利0元    f[3][0]=0

保留1个用户，获利1元     f[3][1]=1



![](https://cdn.luogu.com.cn/upload/pic/86.png)

3节点把数据上传给了父亲2节点
--
考虑3节点对2节点的影响

2节点有2个决策
 
保留0个用户，获利0元    f[2][0]=0

保留1个用户，获利1元    f[2][1]=1


到现在3节点可以扔掉了，因为2节点把他的数据都记下来了

dfs到4节点
-

4节点现有2个决策

保留0个用户，获利0元   f[4][0]=0
 
保留1个用户，获利4元   f[4][1]=4






4节点上传数据到父亲2节点
-
考虑4节点对父亲2节点的影响

这是2节点之前的决策  

保留0个用户，获利0元   f[2][0]=0

保留1个用户，获利1元   f[2][1]=1



现在父亲2节点要把儿子4节点上传的数据进行整理
-
2节点现在的决策有3个


保留0个用户，获利0元   f[2][0]=0

保留1个用户，获利1元    f[2][1]=1

保留2个用户，获利2元    f[2][2]=2

![](https://cdn.luogu.com.cn/upload/pic/86.png)


2节点再上传到父亲1节点
-
1节点现在的决策有3个

保留0个用户，获利0元    f[1][0]=0

保留1个用户，获利-1元    f[1][1]=-1

保留2个用户，获利0元    f[1][2]=0


dfs5节点
--

1节点现在的决策有2个

保留0个用户，获利0元    f[5][0]=0

保留1个用户，获利2元    f[5][1]=2


5节点再上传到父亲1节点
-
1节点现在的决策有3个

保留0个用户，获利0元    f[1][0]=0

保留1个用户，获利-1元    f[1][1]=-1

保留2个用户，获利0元    f[1][2]=0

保留3个用户，获利-1元   f[1][3]=-1


答案说不亏本的最大用户数
--

保留2个用户，获利0元    f[1][2]=0  就是答案了

就算问最大利润数，根据1节点的数据，也可以给出答案

所以我认为

dp的核心是记录
--





至于dp推导过程，我想这个得自己思考

为什么要这样做，为什么要逆着处理

实在是想不通了瞄一眼题解继续想

我不再推导，因为我推导出来的过程也不会比其它题解好多少

这篇重点讲思考的方向

```cpp
 #include<bits/stdc++.h>
using namespace std;
int n,m;
int a[3001];
vector<int>g[3001];
int f[3001][3001];
int fa[3001];
int dis[3001];    
int len[3001];
int ans=0;
void dfs(int u)
{
	len[u]=0;
	f[u][0]=0;
	for(int k=0,v;k<g[u].size();k++)
	{
		v=g[u][k];
		dfs(v);
	}
	
	if(u>=n-m+1)
	{
	    f[u][1]=a[u];
	    len[u]++;
	}	
			int ma=len[fa[u]];			

	    for(int k=len[fa[u]];k>=0;k--)
		{
			if(f[fa[u]][k]==~0x3f3f3f3f)continue;
			for(int j=1;j<=len[u];j++)
			{
			if(f[u][j]==~0x3f3f3f3f)continue;
				f[fa[u]][k+j]=max(f[fa[u]][k+j],f[fa[u]][k]+f[u][j]-dis[u]);				
				if(f[fa[u]][k+j]>=0)ans=max(ans,k+j);
				ma=max(ma,k+j);
			}
			
		}
	len[fa[u]]=ma;

	return;
}
int main()
{  	
	memset(f,0xc0,sizeof(f));
	cin>>n>>m;
	for(int u=1,tot,v1,v2;u<=n-m;u++)
	{
		scanf("%d",&tot);
		while(tot--)
		{
			scanf("%d %d",&v1,&v2);
			fa[v1]=u;
			dis[v1]=v2;
			g[u].push_back(v1);
		}
	}
	for(int i=n-m+1;i<=n;i++)
	{		
		scanf("%d",&a[i]);
	}
	
	dfs(1);
	printf("%d\n",ans);
}
```




