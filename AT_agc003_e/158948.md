比较神奇的一道题，看了一眼就有一点可做的感觉，典型的 AGC 风格。

~~当我状态好的时候才有概率独立想出做法。~~

给出一种清晰的思路，可能更好理解，起码我看现有题解都看不懂。

首先对于 $q_i\ge q_{i+1}$，去除 $q_i$，随便做一下。

于是有了条件 $\forall q_i<q_{i+1}$，将最后的数组分段，令第 $i$ 段包含 $S_i=[q_{i-1}+1,q_i]$，长度为 $d_i=q_i-q_{i-1}$，不妨令 $q_0=0$。

于是对于一个位置 $p$ 我们可以用它处于哪个段的哪个位置来表示，即存在唯一的 $x,y$，使得 $p\in S_x,y\in[1,d_x],p=q_{x-1}+y$，不妨用 $(x,y)$ 来表示这样的 $p$。

反之用 $P(x,y)=p$ 在最终数组的位置，每个位置 $(x,y)$ 对答案数组 $ans$ 都有一个贡献，不妨令为 $W(x,y)$，$W(p)$ 也表示同样的含义。

注意这里的 $W$ 是将贡献累进答案数组的一个过程而不是一个数组，毕竟我们不可能一直带着一个数组进行运算，而只是考虑贡献。

容易发现 $W(1,k),k\in[1,d_1]$ 是简单的，就是 $\forall i\in[1,k],ans_i\to ans_i+1$，而最后我们要求的是 $W(n,d_n)$ 后的答案数组。

于是考虑递归处理出 $W(x,y)$ 的贡献，将递归下一层设为 $W(x',y')$，令 $b=\lfloor \frac{y}{q_{x-1}}\rfloor,r=y\bmod q_{x-1}$：

由数组的构造过程可以发现出现了多段重复的 $(x-1,d_{x-1})$，直接贡献 $(b+1)\times W(x-1,d_{x-1})$。
  
除此之外贡献了一次 $W(r)$，简单实现就是直接二分找到对应的位置 $P(x',y')=r$，然后递归调用 $W(x',y')$ 即可。

考虑复杂度，令 $(x,d_x)$ 为“标记位置”，先考虑非“标记位置”：

由 $P(x,y)\to P(x',y')$，有 $(b+1)q_{x-1}+r\ge q_{x-1}+r> 2r\to r$，故位置每次必定减半。

而当 $P(x,y)\le d_1$ 时直接贡献到答案数组，结束，将递归调用的复杂度在第一次非“标记位置”就考虑进去，后面就不算其调用次数。

调用一次非标记的 $W(x,y)$ 会递归 $\log$ 次，带来 $O(\log^2)$ 的复杂度。（注意转移时有二分）

再考虑“标记位置”：

类似搜索的记忆化，每次将 $(b+1)W(x-1,d_{x-1})$ 累计到 $x-1$ 上再一起计算，即 $b+1\to tot_{x-1}$，只需一次调用 $tot_{x-1}W(x-1,d_{x-1})$。

而调用一次 $W(x-1,d_{x-1})$ 最多带来一次非“标记位置”，即调用“标记位置”与非“标记位置”（只考虑第一次而不考虑递归次数）总次数为 $n$。

总复杂度 $O(n\times\log^2)$，~~其实很好写但~~代码还是鸽了。

正文结束，下文是对进一步复杂度的思考，~~可能是错的~~。

------------

起因：这里怎么有篇 $\log$ 的题解，艹这难道不是 $\log^2$ 的？

发现递归过程的位置只会越来越小，我们希望只用一个单调的指针而不是二分来找出所有的转移位置，这能做到吗？

同时发现第一次调用的 $W(n,d_n)$ 也是“标记位置”，也就是说所有的非“标记位置”只会由“标记位置”引出。

于是我们只丢入 $n$ 个标记位置，用某个不知名的数据结构维护当前最靠后的位置到了哪里，再用一个指针在 $q$ 上单调移动。

指针部分是没有问题的，但是最靠后的位置我们需要支持这样的东西：查询最大值，减小键值。

除了将 $\log n$ 的复杂度改为 $\log_wV$ 以外我没有更多想法，其中 $V$ 是值域。