# [HAOI2018]苹果树
## 组合数学，树
### 前言
在机房神仙讲解之后花了好长时间才明白。
### 前置知识
(我一直都不会，果然太弱了)   
关于组合数，当数很**大**且**可以算逆元**时，可以预处理阶乘和逆元然后运算。但是当数**不大**且**不可求逆元**时，可以直接预处理组合数。   
于是就需要组合数的递推公式 $c(n,m)=c(n-1,m-1)+c(n-1,m)$   
代码
```cpp
for(int i=0;i<=n;++i)
	  c[0][i]=c[i][i]=1;
	for(int i=1;i<=n;++i)
	  for(int j=1;j<i;++j)
	    c[j][i]=(c[j-1][i-1]+c[j][i-1])%md;
```


------------

### 正题
题意其实就是给了一棵会生长的二叉树，求每对点的距离。   
这又是一道树上问题，让我想到前两天的一道题，对于树上问题我们都可以将每个点与它的父亲或儿子割裂开来，方便~~姬算~~计算。   
在这道题上，我们可以分别统计每条边对答案贡献，这就要求我们枚举点。又因为这个贡献只会与这个点上面的部分和它的子树有关。因为每个点有编号，所以上面部分是确定的，于是还要枚举子树大小。（显然$n²$是可做的）    
#### 求解
##### 方案
可以发现，当二叉树生长出一个点时，生长位置数要$-1+2$，根据乘法原理，一棵树的姿态有$n!$种，放到枚举的子树即为$size!$种，由于不知道选取了哪些点，所以还要乘上$C(n-i,size-1)$即要从$n-i$个点中选取$size-1$个点。
##### 贡献
这条边的贡献显而易见了，就是$size*(n-size)$。
##### 子树外
按这个思路这棵树实际上被分为了三部分：   
$1.$子树内   
$2.$ 已确定部分（子树上）  
$3.$剩余未确定部分（外）   
$2$和$3$即构成了子树外的部分。对于$3$，回到求解最初，生长出枚举的$i$枝的贡献为$-1+2$，但是它子树内的继续生长是不可能被统计到子树外的，于是子树外的方案就是从$i$的生长开始，减去$i$这个可行的生长点，开始和最开始一样生长，方案数就是$size2*(size2-1)*(size2-2)*...*(i-1)$即$size2!/(i-2)!$（此处设$3$的大小为$size2$）。当然此处仍然需要算$2$部分，就是$i!$。
#### $ANS$
于是最终得到一个式子
$\displaystyle \sum^{n}_{i=1}\displaystyle \sum^{n-i+1}_{j=1}j*(n-j)*C(n-i,j-1)*j!*i*(i-1)*(n-j-1)!$
(注意有一个化简，否则带着除法不太好做)
#### 代码
```cpp
#include<cstdio>
using namespace std;
long long c[2010][2010],jc[2020],ans;
int main()
{
	int n,md; 
	scanf("%d%d",&n,&md);
	jc[0]=1;
	for(int i=1;i<=n;++i)
	  jc[i]=(jc[i-1]*i)%md;
	for(int i=0;i<=n;++i)
	  c[0][i]=c[i][i]=1;
	for(int i=1;i<=n;++i)
	  for(int j=1;j<i;++j)
	    c[j][i]=(c[j-1][i-1]+c[j][i-1])%md;
	for(int i=2;i<=n;++i)
	  for(int j=1;j<=n-i+1;++j)
	    ans=(ans+jc[j]*c[j-1][n-i]%md*j%md*(n-j)%md*jc[n-j-1]%md*i%md*(i-1))%md;
	printf("%lld",ans);
 } 
```


