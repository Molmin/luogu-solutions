题目大意：给定 $n,m,k(1\le k\lt n \le 10^6,1\le m\le 10^{6})$ 以及一个长度为 $n$ 的序列 ${a_i}(1\le a_i\le m)$。每次操作可以选取两个数 $x,y$ 从序列中删去，并将 $\gcd(x,y)$ 加入序列中。求进行恰好 $k$ 次操作后 $\sum a_i$ 的最大值。

### 分析题目性质

显然如果序列中存在相同的两个元素，那么可以通过对这两个相同元素进行操作，把他们合并成一个元素并消耗一次操作次数，于是我们先假设所有元素都互不相同，思考如何解题。

考虑这么一件事情，如果一开始选了两个数 $x,y$ 并将其合并为 $\gcd(x,y)$ 加到了序列中，之后我们再把这个 $\gcd$ 拿出来去和另一个数字 $z$ 合并。那么这一系列操作就相当于把 $x,y,z$ 三个数字从序列中删去，并在序列中加入新数字 $\gcd(x,y,z)$。于是我们可以把操作分成若干组，每组操作就相当于选取 $t$ 个数字从序列中删去，然后把这 $t$ 个数字的 $\gcd$ 加入到序列中，一组操作所花费的操作次数就是 $t-1$ 次。

可以很自然地想到，若划分的组数越多，被波及的数字个数就越多，于是就会有一个猜想：是否一次性选取 $k+1$ 个数字把他们合并就是最优的。我们来证明这个猜想。

#### 猜想 1：一次性选取 $k+1$ 个元素进行合并是最优策略

考虑反证法，如果操作的组数有多组，那么考虑其中两组操作。不妨设第一组操作涉及到的数字集合为 $S$，各个数字的 $\gcd$ 为 $x$；第二组操作涉及的数字集合为 $T$，$\gcd$ 为 $y$，且有 $x\ge y$。那么这两组操作带来的贡献就是 $x+y-\sum_{i\in S}{i}-\sum_{j\in T}{j}$。

接下来观察把这两组操作进行合并对贡献造成的影响。选取 $S$ 中最大的数字 $mx$，由于不可重集 $S$ 中的 $\gcd$ 为 $x$ 且 $|S|\ge 2$，所以有 $mx\ge 2x$。考虑将 $mx$ 从 $S$ 中删除（即不对该数字进行操作），并对 $S,T$ 各自合并后的结果 $x,y$ 进行一次操作，那么在操作次数不变的情况下，其贡献为 $\gcd(x,y)-\sum_{i\in S}{i}-\sum_{j\in T}{j}+mx$。

对比两种操作的贡献，去除掉相同的部分有 $mx+\gcd(x,y)\gt 2x\ge x+y$，得出后者更优。于是最优方案下的操作组数只会有一组，即得证。

#### 题意转换

猜想得到证明后，我们就能将题意转化为：选 $k+1$ 个数字将他们合并成这些数字的 $\gcd$，求代价最少的方案。当然，这里有个前提是序列中的元素各不相同。

考虑有相同元素怎么办。实际上如果有相同的元素出现在同一组操作中，可以看做先把相同的元素合并成一个元素，剩下的是互不相同的元素一起操作。那么每次把两个相同元素合并的代价就是对应元素的值。

于是可以把重复的数字拎出来并排序，令 $b_i$ 表示删去 $i$ 个重复元素的最小花费。枚举 $i$ 的值，计算一次性选 $k-i+1$ 个数字合并的最小花费就能得到最终的答案。

在这一系列转换过后，我们要解决的问题就变成了：对每个 $i\le k+1$，求选择 $i$ 个数字合并成他们的 $\gcd$ 的最小花费。

由于简单版本的值域只有 $10^6$，那么就有一个经典的做法就是枚举 $\gcd$ 的值，之后判断 $\gcd$ 的每个倍数是否存在并计算即可。计算答案部分的时间复杂度为 $O(m\log m)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define N 1000010
int T,n,m,k,x,cnt,c[N];
long long sum,ans,b[N];
void init()
{
	cnt=sum=ans=0;
	scanf("%d%d%d",&n,&m,&k);
	k++;
	for(int i=1;i<=n;i++){
		scanf("%d",&x);
		c[x]++;
		sum+=x;
		if(c[x]>1)b[++cnt]=x;
	}
	sort(b+1,b+cnt+1);
	for(int i=1;i<=cnt;i++)b[i]+=b[i-1];
	if(cnt>=k-1)ans=max(ans,sum-b[k-1]);
	for(int i=1;i<=m;i++){
		long long res=i;
		for(int j=i,num=0;j<=m && num<k;j+=i)if(c[j]){
			res-=j,num++;
			if(cnt>=k-num)ans=max(ans,sum+res-b[k-num]);
		}
	}
	for(int i=1;i<=m;i++)c[i]=0;
	printf("%lld\n",ans);
}
int main()
{
	scanf("%d",&T);
	while(T--)init();
}
```
