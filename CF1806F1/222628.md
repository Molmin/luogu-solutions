考虑 F1：

首先，假设 $a$ 中元素互不相同。

改写一下问题：将序列分成 $n-k$ 组，最大化每组的 $\gcd$ 之和。我们设 $S_i$ 表示一个组的元素。

> 定理 $1$：当 $k>0$ 时，原序列的最小元素所属的组满足 $|S_a|>1$。

证明：

如果 $|S_a|=1$，我们可以找到一个组 $S_x$ 使得 $|S_x|>1$。可以证明，用原序列的最小元素替换 $S_x$ 的最大元素一定更优。

设 $a$ 为原序列的最小值，$b$ 为 $S_x$ 的最大值。

- 原始答案是 $a+\gcd(S_x)$。
- 用最小元素替换 $S_x$ 的最大元素，答案是 $b+\gcd(S_x \setminus \{b\}\cup\{a\}) >b$。



因为 $\gcd(S_x) \le \max{S_x} - \min S_x = b-\min S_x < b-a$，所以 $a+\gcd(S_x)< a+b-a=b<b+\gcd(S_x \setminus \{b\}\cup\{a\})$。Q.E.D.

注意，当 $\max S_x = \min S_x$ 时，$\gcd(S_x) \not\le \max{S_x} - \min S_x$，这就是为什么需要 $a$ 中元素互不相同。



> 定理 $2$：当 $k>0$ 时，只有一个 $S_x$ 满足 $|S_x| >1$。

证明：

设 $S_a$ 为包含最小元素的组。

根据定理 $1$，我们知道 $|S_a| >1$。我们可以从序列中删除 $S_a$ 包含的所有元素，将 $\gcd({S_a})$ 添加到序列中，并让 $k$ 减去 $|S_a|-1$。很明显 $\gcd(S_a)$ 是新的序列中的最小元素。我们可以继续这个过程直到 $k=0$，这告诉我们只有 $|S_a|=k+1>1$。Q.E.D.

我们可以枚举 $\gcd(S_a)$，做到 $O(n+m\ln m)$ 的复杂度。

如何处理重复的元素呢？

我们可以发现，对于重复的元素，最好的策略是将它们与相同的数合并，所以它和之前的部分是独立的。枚举对重复元素执行的操作次数即可。



---

考虑 F2：

仍然假设 $a$ 中元素互不相同。假设 $a$ 已经排好序了。

> 定理 $3$：当 $k>0$ 时，我们将选择前 $k$ 个元素，然后从剩下的元素当中再选择一个。

也就是说，$S=\{a_1,a_2,\ldots,a_k,a_x\}$，其中 $k < x \le n$，是唯一一个包含多个元素的组。

证明：

假设 $T=\{a_1,a_2,\ldots, a_{p}, a_{c_1}, a_{c_2}, \ldots, a_{c_t}\}$，其中 $p+1<c_1<c_2<\cdots<c_t$，$t\ge 2$，$p+t=k+1$。那么我们可以证明 $T'=\{a_1,a_2,\ldots, a_{p},a_{p+1}, a_{c_1}, a_{c_2}, \ldots, a_{c_{t-1 }}\}$ 一定更优。

设 $g=\gcd(T)$，$g'=\gcd(T')$。我们有 $a_{c_t}-a_{p+1}> a_{c_t}-a_{c_{t-1}}\ge g$。

$\Delta=ans(T')-ans(T)=a_{c_t}-a_{p+1}+g'-g> g'>0$。

重复这个过程，最后我们就能得到 $S=\{a_1,a_2,\ldots,a_k,a_x\}$，其中 $k < x \le n$。Q.E.D.



当有重复元素时，我们在去重后的序列中分别求出取 $1\sim k$ 个数的答案。前缀 $\gcd$ 只有 $O(\log m)$ 种不同的值，所以我们可以做到 $O(n \log^2 m)$（另一个 $O(\log m)$ 是计算 $\gcd$ 的复杂度）。设 $g_i$ 为前缀 $\gcd$。当我们在剩下的数中寻找最优的元素时，我们需要计算 $\gcd(g_i,a_j)$，导致时间复杂度成为 $O(n \log^2 m)$。我们可以发现，$g_i\mid g_{i-1}$，所以 $\gcd(g_i,a_j)=\gcd(g_i,\gcd(g_{i-1},a_j))$。$\gcd$ 是不降的，所以总复杂度可以做到 $O(n \log m)$（可以理解成对 $\gcd$ 势能分析）。