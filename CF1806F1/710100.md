容易得知操作顺序和最终结果是无关的，考虑对序列从小到大排序后逐个操作。

我们发现，如果我们不考虑序列中最小的元素，而是去合并序列后方更大的元素，我们一定希望后面元素有较大的 $\gcd$。但是稍作考虑后发现，其 $\gcd$ 值的上界仅为被合并的元素中最小的值，而这些元素的总和对答案造成的减量是非常之大的。

考虑 $k = 1$。对于序列中的最小值 $a_1$ 以及任意两非最小值 $a_i, a_j(i < j)$，如果选择合并 $a_i, a_j$，答案的减量（后文称之为“代价”）为 $a_i + a_j - \gcd(a_i, a_j)$，最优情况下这个值为 $a_j$，**这要求序列可重**；如果序列不可重，$\gcd(a_i, a_j) \leq \min(a_i, a_j - a_i)$，这意味着最优的代价为 $a_i + a_j - \min(a_i, a_j - a_i)$。

然而，如果我们转而合并 $a_1, a_i$，代价为 $a_1 + a_i - \gcd(a_1, a_i)$，最劣情况下这个值为 $a_1 + a_i - 1$。

**钦定序列是不可重的**，二者作差得到选择 $a_1$ 时至少可以减少的代价为 $a_j - a_1 - \min(a_i, a_j - a_i) + 1$。分别讨论 $a_j$ 在 $a_1, \frac{a_j}{2}$ 之间及 $\frac{a_j}{2}, a_j$ 之间，可证该值恒大于 $1$，此处略。至此我们发现，对于任意无重复元素的序列，**与最小值合并一定是最优的选择**。

考虑 $k > 1$。由于 $\gcd(a_1, a_i) \leq a_1$，因此与最小值合并后得到的新元素 $\gcd(a_1, a_i)$ 一定会成为序列中新的最小值。依此归纳下去，每次我们都会选择一个数与最小值合并，并将它们的 $\gcd$ 作为新的最小值，直到达到操作次数。因此所有的被操作数应被合并于一起，换言之，我们只需选定 $k + 1$ 个数一次性合并，最大化剩余元素与这 $k + 1$ 个数的 $\gcd$ 的总和。

至此已经足够解决 F1 了。需要注意的是关于重复元素的问题，在上文有提到：当序列可重时，如果选择合并 $a_i, a_j(a_i = a_j)$，代价为 $a_j$，是更优于与最小值合并的（e.g. 对于序列 $\{2, 5, 5\}$，合并成 $\{2, 5\}$ 显然优于合并成 $\{1, 5\}$）。但是这种最优的情况仅限相同元素之间，因此它独立于不可重的情形，我们可以将原序列去重，并单独考虑出现次数 $> 1$ 的元素。具体地，记 $b_i$ 表示共合并 $i$ 个相同元素的最小代价，$c_x$ 为 $x$ 在 $a$ 中的出现次数，记 $a'$ 为将 $a$ 中所有元素出现次数减一后的可重序列（即 $a$ 中的元素 $x$ 在 $a'$ 中的出现次数）。仍然对 $a'$ 从小到大排序，则 $b_i \gets a_i + b_{i - 1}$ 即得。

由于值域只有 $10^6$，枚举 $\gcd$ 的值为 $g$（即最小元素的因数），每次从小到大加入 $g$ 的倍数，记当前加入的元素集为 $T$，$sum = \sum \limits_{i = 1} ^ n a_i$，若 $k + 1 - |T| \in [0, |b|]$，令 $Ans \gets \max(Ans, sum - \sum \limits_{x \in T} x + g - b_{k + 1 - |T|})$。

```cpp
void solve(){
	i64 n, m, k; cin >> n >> m >> k;
	vector<i64> a(n), b, e(m + 1, 0);
	i64 sum = 0, ans = 0;
	for(int i = 0; i < n; i++)
		cin >> a[i];
	sort(a.begin(), a.end());
	for(int i = 0; i < n; i++){
		if(e[a[i]]) b.push_back(a[i]);
		e[a[i]] = 1; sum += a[i];
	}
	b.push_back(0); sort(b.begin(), b.end());
	for(int i = 1; i < b.size(); i++)
		b[i] += b[i - 1];
	int L = b.size() - 1;

	if(L >= k) ans = max(ans, sum - b[k]);
	for(int g = 1; g <= m; g++){
		if(a[0] % g) continue;
		int t = 0; i64 s = 0;
		for(int i = g; i <= m; i += g){
			if(!e[i]) continue;
			t++; s += i;
			if(0 <= k + 1 - t && k + 1 - t <= L)
				ans = max(ans, sum - s + g - b[k + 1 - t]);
		}
	}
	cout << ans << "\n";
}
```
