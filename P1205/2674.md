题解by redbag

如果说我的代码编译错误，那么说明你抄题解了。

本蒟蒻的代码比楼下两位大神的代码要长，把每个情况都单独分了类，写一个过程旋转，一个过程翻转，一个过程判断。

具体见注释。然后要注意一些细节问题。

-
/\*
ID: ylx14271

PROG: transform

LANG: C++

\*/
```cpp
#include<set>  
#include<map>  
#include<list>  
#include<queue>  
#include<stack>  
#include<string>  
#include<math.h>  
#include<time.h>  
#include<vector>  
#include<bitset>  
#include<memory>  
#include<utility>  
#include<stdio.h>  
#include<sstream>  
#include<iostream>  
#include<stdlib.h>  
#include<string.h>  
#include<algorithm> 
#define LL unsigned long long   
using namespace std;
char a[11][11],b[11][11],c[11][11],d[11][11];//a存原本的，b存要求的的，c存变换后的结果,d用来玩的 
int n,i,j;
void xz()//旋转90°过程
{
-     for (i=1;i<=n;i++)//将d数组复制成c数组 
-     {
-         for (j=0;j<n;j++)
-         {
-             d[i][j]=c[i][j];
-         }
-     }
-     for (i=1;i<=n;i++)//旋转D数组（也就是原本的c数组）将结果存入c数组 
-     {
-         for (j=0;j<=n-1;j++)
-         {
-             c[i][j]=d[n-j][i-1];//顺时针旋转90° 
-         }
-     }
-     return;
}
void fs()//反射
{
-     for (i=1;i<=n;i++)//将d数组复制成c数组 
-         for (j=0;j<=n-1;j++)
-         {
-             d[i][j]=c[i][j];//复制一遍 
-         }
-     for (i=1;i<=n;i++)
-         for (j=0;j<=n-1;j++)
-         {
-             c[i][j]=d[i][n-j-1];//翻转过程，第j列到了第n-j+1列
-         }
}
int pd()//判断经过处理后的图案是否与要求的图案一致 
{
-     for (i=1;i<=n;i++)
-         for (j=0;j<n;j++)
-         {
-             if (c[i][j]!=b[i][j])//如果这个字符对不上
-             return 1;//返回1 
-         } 
-     return 0; 
} 
int main() 
{
-     freopen("transform.in","r",stdin);
-     freopen("transform.out","w",stdout); 
-     cin>>n;
-     for (i=1;i<=n;i++)//读入原本的图案 
-     {
-         cin>>a[i];
-     }
-     for (i=1;i<=n;i++)//读入要转换成的图案 
-     {
-         cin>>b[i];
-     }
////////////////////////////////////////////华丽的分割线-90°/////////////////////////////////////////////////
-     for (i=1;i<=n;i++)//将c数组复制成a数组 
-     {
-         for (j=0;j<n;j++)
-         {
-             c[i][j]=a[i][j];
-         }
-     }
-     xz();//顺时针旋转90°
-     if (pd()==0)//如果与要求的图案相等 
-     {
-         cout<<1<<endl;
-         return 0;
-     } 
////////////////////////////////////////////华丽的分割线-180°////////////////////////////////////////////////
-   xz();//c在原本的90°的基础上直接转。
-     if (pd()==0)//如果与要求的图案相等 
-     {
-         cout<<2<<endl;//输出 
-         return 0;//结束 
-     } 
////////////////////////////////////////////华丽的分割线-270°//////////////////////////////////////////////// 
-     xz();//c在原本的90°的基础上直接转。
-     if (pd()==0)//如果与要求的图案相等 
-     {
-         cout<<3<<endl;//输出 
-         return 0;//结束 
-     } 
////////////////////////////////////////////华丽的分割线-反射/////////////////////////////////////////////////
-     for (i=1;i<=n;i++)//将c数组复制成a数组 
-     {
-         for (j=0;j<n;j++)
-         {
-             c[i][j]=a[i][j];
-         }
-     }
-     fs();//反射 
-     if (pd()==0)//判断。
-     {
-         cout<<4<<endl;
-         return 0;
-     } 
////////////////////////////////////////////华丽的分割线-组合/////////////////////////////////////////////////  
//介于反射过了，所以c数组直接旋转吧。  
-   xz();//c在原本的90°的基础上直接转。90°
-   if (pd()==0){cout<<5<<endl;    return 0;}//判断 
-     xz();//c在原本的90°的基础上直接转。180°
-   if (pd()==0){cout<<5<<endl;    return 0;}//判断 
-     xz();//c在原本的90°的基础上直接转。270° 
-     if (pd()==0){cout<<5<<endl;    return 0;}//判断 
////////////////////////////////////////////华丽的分割线-原图/////////////////////////////////////////////////
-     int biaoji=0;//标记 
-     for (i=1;i<=n;i++)
-         for (j=1;j<=n;j++)
-         {
-             if (a[i][j]!=b[i][j])//如果这个字符对不上
-             biaoji=1; //标记 
-         } 
-     if (biaoji==0)//如果每个数组都对得上
-     {
-         cout<<6<<endl;//输出 
-         return 0;//结束 
-     } 
/////////////////////////////////////////////华丽的分割线-无//////////////////////////////////////////////////  
-     cout<<7<<endl;//否则就无法变换成为要求的图形 
-     return 0;
}
![](https://cdn.luogu.com.cn/upload/pic/1422.png)
```