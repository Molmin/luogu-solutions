首先,我们为了快速判断一段区间是否符合要求,先跑一遍前缀和,分别设s1,s2,s3为从0~i的区间数字1,2,3出现的个数。现在我们要求l~r区间1,2,3的个数,只需要s[r]-s[l-1]就可以了。符合条件即个数全部>0。 

## 暴力算法。

暴力找出以每个点开头最短包含123的。然后在这每个点中取最小值。 

时间复杂度:O(n²);显然过不了。

## 优化

我们可以发现,如果l~r1不符合要求,那么l~r2 (r2>=r1)肯定也不符合要求。(因为123的数量只会多,不会少)。

假设现在找到的最小值为min,那么我们在枚举起始点为l的时候,先判断l~l+min是否符合要求,如果不符合要求,枚举下一个点,否则r--,表示min更新。


## 代码

```cpp
#include<iostream>
using namespace std;
int s1[1000005],s2[1000005],s3[1000005];
void Main(){
	string s;
	cin>>s;
	int i,size=s.size();
	s1[0]=(s[0]=='1');
	s2[0]=(s[0]=='2');
	s3[0]=(s[0]=='3');
	for(i=1;s[i];i++){
		s1[i]=s1[i-1]+(s[i]=='1');
		s2[i]=s2[i-1]+(s[i]=='2');
		s3[i]=s3[i-1]+(s[i]=='3');
	}
	for(i=size;i<=(size<<1);i++){ //在这个代码中,可能会枚举到超过s.size()的下标。 
		s1[i]=s1[i-1];
		s2[i]=s2[i-1];
		s3[i]=s3[i-1];
	}
	int l,r=-1;
	for(i=0;s[i];i++){ //枚举第一个的r。(第一个点没有前面的点的信息,无法优化)。 
		if(s1[i]&&s2[i]&&s3[i]){
			r=i;
			break;
		}
	}
	if(r==-1){
		cout<<0<<endl;
		return;
	}
	int Min=2147483647;
	for(i=1;s[i];i++){
		while((s1[r]-s1[i-1])&&(s2[r]-s2[i-1])&&(s3[r]-s3[i-1])){
			r--;
		}
		r++; //注意,r现在不符合要求,r+1才符合要求。 
		Min=min(Min,r-i);
		r++; //枚举下一个点,r也要加一。 
	}
	cout<<Min+1<<endl;
}
int main(){
	int t,i;
	cin>>t;
	for(i=0;i<t;i++){
		Main();
	}
	return 0;
}
```
## 时间复杂度

预处理前缀和:O(6n)。

核心代码:O(2n)。 

这里可以理解为O(n),因为前面的都是常数。

虽然有两重循环,但是r一直在缩小(除了i++的时候),所以这里的复杂度为O(n)。