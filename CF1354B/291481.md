**题目大意**：给你一个长度为 $s$ 的只由字符‘1’‘2’和‘3’构成的字符串，让你找出最短的包括‘1’‘2’‘3’的连续字串长度，不存在则输出0

#### 思路
设 $n$ 是读入字符串的长度，我的做法是先 $O(n)$ 遍历一遍整个字符串，如果字符串中的三种字符不全，那么不可能有解，直接输出0。

然后用两层循环计算从字符串中第 $i$ 个字符开始的最短包含‘1’‘2’‘3’三个字符的连续字串长度，因此，第二层的循环只需要三种字符都碰到了从这个字符开始的最短长度，然后更新答案。

但这样做的话时间复杂度可能会很高
~~(我也没试过)~~
，因此，考虑到像``122123``这样的数据，第1位的字符‘1’往后计算的结果一定比第3位的‘1’字符计算到的答案要大，而且无法为答案做出有效的贡献，同样，在遇到许多连续相同的字符时，也一定是从这些连续的相同字符的最后一个计算才能得到最短的子串。因此，在第二层循环中在三种字符都遇到之前遇到与第 $i$ 个字符相同的字符，就进行下一次循环，因为后面一定存在更优解，这样两层循环的复杂度最多比 $O(n)$ 大一点了

#### 代码如下
```cpp
#include <cstdio>
#include <cstring>
char a[200010];
int min(int x,int y)//返回两数较小值 
{
	return (x<y)?x:y;
}
int mj(int N)//判断这个输入的字符串是否无解 
{
	int i,b1,b2,b3;
	b1=0;b2=0;b3=0;
	for(i=1;i<=N;i++)
	{
		if(a[i]=='1')
			b1++;
		if(a[i]=='2')
			b2++;
		if(a[i]=='3')
			b3++;
		if(b1&&b2&&b3)
			return 0;
	}
	return 1;
}
int main()
{
	int T,N,i,j,ans,lt,cc,dd;
	char c1,c2,c3; 
	scanf("%d",&T);
	while(T--)
	{
		scanf("%s",a+1);
		N=strlen(a+1);
		if(mj(N))//无解则输出0 
		{
			printf("0\n");
			continue;
		}
		ans=1000000;
		for(i=1;i+2<=N;i++)//查找从第i个字符开始的包含1，2，3三个字符的子串长度 
		{
			c1=a[i];c2=0;
			cc=0;dd=0;lt=1;
			for(j=i+1;j<=N;j++)
			{
				if(a[j]==c1)//如果在后面遇到了与第i个字符相同的字符，那么一定存在更优解，所以跳过本次循环 
				{
					cc++;
					break;
				}
				lt++;
				if(a[j]!=c1&&a[j]!=c2)
				{
					if(c2==0)//c2为0时，第j个字符是第一个与第i个字符不同的字符 
					{
						c2=a[j];
					}
					else//否则第j个字符与c1和c2都不同，一定出现了第三种字符 
					{
						dd++;
						break;
					}
				}
			}
			if(cc)
				continue;
			if(!dd)
				continue;
			ans=min(ans,lt);
		}
		printf("%d\n",ans);
	}
}
```
~~虽然很长，但这是提交这个题解时洛谷上此题的最优解~~