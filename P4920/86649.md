做了两天后终于做出来了

~~然而尝试用传统题方式AC还是失败了~~

我尽量给出每道题的等价程序，但不能AC

# 样例

输入两个数a和b

第一行输出```Hello, National Olympiad in Informatics!```

第二行输出这两个数的和

第三行输出```%cinter %camp```，%c用a和b替换

第四行先输出0，然后输出一个最小的正整数$k$，满足$a+kb\equiv 0(mod\ 2^{32})$

第五行看起来很复杂，但看一下i的初始值就知道输出-1

六到十行输出一个点

除了第四行外都很简单

第四行：

先根据$a$和$b$的二进制表示中末尾的$0$（分别记为$x$和$y$）讨论一下：

如果$x<y$，那么无解，源程序就会死循环

其它情况，实际就等价于$\frac{a}{2^y}+k\frac{b}{2^y}\equiv 0 (mod\ 2^{32-y})$

也就是$\frac{a}{2^y}+k\frac{b}{2^y}\equiv 0 (mod\ 2^{32-y})$

$k\equiv -\frac{a}{2^y}(\frac{b}{2^y})^{-1}(mod\ 2^{32-y})$

再由欧拉定理，$k\equiv -\frac{a}{2^y}(\frac{b}{2^y})^{2^{32-y-1}-1}(mod\ 2^{32-y})$

快速幂即可

# 第一题

可以看出是b个a相加，对c取模

龟速乘就行（当然也可以用__int128或者python）

# 第二题

是一个递推数列，~~打表可知$a_n$是斐波那契数列某一项的平方~~还是要认真求一下通项公式的

三个递推式分别为

$b_n=a_{n-1}+b_{n-1}$

$a_n=2b_n-a_{n-1}+c_{n-1}$

$c_n=2b_n-a_n+c_{n-1}$

先把等号右边的$a_n$和$b_n$消掉，得到：

$a_n=a_{n-1}+2b_{n-1}+c_{n-1}$

$b_n=a_{n-1}+b_{n-1}$

$c_n=a_{n-1}$

很明显，这个数列的每一项都是正数（后面有用）

然后先证明$a_nc_n=b_n^2$

首先，$n=0$时显然成立

把$a_n$、$b_n$和$c_n$代入可以得到：

$a_{n-1}^2+2a_{n-1}b_{n-1}+a_{n-1}c_{n-1}=a_{n-1}^2+2a_{n-1}b_{n-1}+b_{n-1}^2$

即$a_{n-1}c_{n-1}=b_{n-1}^2$

所以可以用数学归纳法证明（过程略）

这样，可以设$a_n=x_n^2,b_n=x_ny_n,c_n=y_n^2$，并让$x_n$和$y_n$也是非负数

代进去，得：

$x_n^2=(x_{n-1}+y_{n-1})^2$

$y_n^2=x_{n-1}^2$

两边可以开方，然后再把$y_{n-1}$消掉，就得到：

$x_n=x_{n-1}+x_{n-2}$

这就是斐波那契数列，可以根据$a_0$和$c_0$求出初值，然后矩阵快速幂即可

# 第三题

求$1,n-1,(n-1)^2,(n-1)^3,(n-1)^4$的前$n+1$项和，对$2^64$取模（题意就是这样，不过为了方便，后面四个可以认为是$n^k$的前$n$项和）

第一问答案就是$n+1$，后面四问有相应的公式

模数不是质数，所以拉格朗日插值可能不太好写，所以开始大力~~百度~~推导公式

对于这类求和，通用的办法就是利用$\sum_{i=1}^{n+1} i^{k+1}-\sum _{i=1}^{n}i^{k+1}$

一种计算方法就是差分，结果是$(n+1)^{k+1}$

另一种计算方法是错位相减，计算$\sum_{i=0}^{n}((i+1)^{k+1}-i^{k+1})$，用二项式定理展开后发现只有次数小于等于$k$的项求和，然后把之前的结果代进来就可以

这样可以得出公式：

$\sum n=\frac{n(n-1)}{2}$

$\sum n^2=\frac{n(n+1)(2n+1)}{6}$

$\sum n^3=\frac{n^2(n+1)^2}{4}$

$\sum n^4=\frac{n(n+1)(2n+1)(3n^2+3n-1)}{30}$

对于包含3或5因子的分母可以用逆元解决，重点解决包含2的因子

可以看出，n和n+1恰好有一个是偶数，所以计算$\frac{n(n+1)}{2}$的值即可

# 第四题

~~传统题做法无法通过，大概需要2秒~~

分为两个子任务

第一个子任务：在一个01矩阵中，对于每个1，统计与它不重叠的1的个数，然后求和

答案明显是$n(n+1)$，其中$n$是1的个数

第二个子任务：对于每个1，计算与它最近的0的距离（曼哈顿距离），然后求和

可以用bfs或者dp求解

bfs的话，就是从每个0开始搜，更新距离

dp可以这样考虑：

最短路径中一定包含一条没用拐弯或者只拐弯一次的路径，而且拐弯一次的路径会有两种

也就是，任何一个点的最短路径必然属于下面四种情况之一（每一段的移动距离都可以为零）

先向上，再向右

先向上，再向左

先向下，再向右

先向下，再向左

所以，dp四遍，依次是向上、向下、向左、向右更新即可

当然也可以用其它方式DP

~~然而多次尝试后还是超时~~

# 第五题

给出一个01矩阵，统计全为1的矩阵个数

如果只是想AC的话，可以写$O(n^3)$的做法，可能也不慢

但是要用传统题的方式AC的话，这样肯定不行 ~~（虽然还是没有成功）~~

考虑枚举右下角，按行统计，这样就可以用单调栈优化。

对于每个点，如果矩形宽度增加，那么矩形的最大高度不增，利用这一性质，统计每个点之前可用的点个数即可。

```
.@...@.#
.@.#####
.######A
```
上图中@表示为1但不可以选的点，#表示可以选的点，从图中就能看出单调性

在计算前需要先求出每个点向上的最大高度

~~然而还是TLE了~~

# 第六题

给出一个奇怪的递推数列，求它的第$n$项

这个数列似乎是对$c$取模，但前面乘法会溢出，然后结果就会很奇怪，因此几乎不可能求出通项

但由于这个数列具有随机性，因此循环节不会太长，可以用判圈算法求解

具体做法：

1. 定义两个变量，第一个变量每次循环递推一次，第二个递推两次。如果递推过程中就达到了所需的项数，那么就直接结束。否则，当这两个变量相等时，进行第二步

2. 如果递推了$k$次，那么可以得到$a_{2k}=a_{k}$，从而$x\geq 2k$时$a_x=a_{x-k}$。设$n=ak+b$，那么$a_n=a_{ak+b}=a_{(a-1)k+b}=\cdots = a_b$。再递推$n\%k$次即可

由于循环节是$O(\sqrt{n})$级别的，仍然很大，所以还是要花一些时间才能算完，我的电脑用了大概90秒。

~~交上去肯定T飞~~

# 第七题

看一下check函数就能发现是$16\times 16$的数独，明显是搜索。

但是直接搜肯定会超时，所以要优化。

考虑人类是怎么填数独的：如果一个格子只可能是某个数，那么就填上

用类似的方式，可以这样搜：bfs，每搜到一个状态，找可填的数最少的空格子，枚举这个数然后入队

求每个点可填的数可以用二进制压位

这样就能秒出结果

# 第八题

求满足特定限制的七元组个数，对某个质数取模

可以猜到：答案是关于$n$的七次多项式，而且模数是质数，~~二话不说~~暴力插值

首先暴力求出前面几项的值，然后插值。由于需要的点很少，因此不用处理阶乘的逆元，暴力乘即可

答案确实是关于$n$的多项式，可以联想高维空间中的体积计算，但我不会证明

# 第九题

脑洞题，个人感觉意义不大，跳过

# 第十题

给出一个巨大的代码，你需要执行这段代码中的若干个函数

可以看出，下划线那个函数就是累加一次，其它函数都是类似这样的结构：

```cpp
void func(){f1();f2();}
```

也就是每个函数也是累加若干次，需要先求出每个函数累加的次数

用python处理一下，然后就解决了（当然也可以用其它方式）

我做的时候，先把每个函数前面的void去掉，然后把括号以及分号去掉，保留用来分隔的空格（用vscode的替换功能），然后用python处理

接下来要处理~~四篇文章~~

这一步类似，统计每个调用产生的累加次数，这样就能求出这一组调用累加的次数，同样可以用python处理

最后求出调用次数，乘一下就解决了

# 代码

把所有部分的等价代码写上大概有600行，为了节约版面，我把代码放在了[这里](https://www.luogu.com.cn/blog/ima/code-P4920)（非AC代码）

# 关于用传统题方式提交

输入数据就是给出的那些文件，所以要判断下是哪个任务的数据

另外有的题时限确实不够，只能直接输出答案