在 da32s1da 巨佬博客上面做一些扩展。。。

~~花了两个月做这道题目，偶尔玩一玩一个数据点，慢慢就过了~~

## test4 count2

count2 等价于寻找与一个 1 的格子曼哈顿距离最近的 0。在这里面虽然可以用 dp 来做，可以套用数据的**随机性**，从小到大枚举距离，然后找到了一个 0 就停止。跑得足够快。

## test6

注意到这是一个随机函数，随机函数的期望环大小足够小，于是用 Floyd 判圈找环。

步骤大概像这样：

- 做 floyd 找一个在环上面的点值
- 用这个点找到循环节
- 用大小找到在循环节之前有多长

然后暴力跑，后两步最坏情况 O(最后两个答案加起来)，第一步 O(玄学)，但是足够快。

## test7

暴搜+剪枝。

数独有无限多的剪枝方法，我用的是动态维护任意一个各自可能填什么东西 + 把一个格子设为一个值的时候看会导致什么别的地方必须设值。写起来用一个 dfs 套 dfs，5ms 完成，~~不过还是跑不过 SPOJ SUDOKU 那个毒题~~

## test8

枚举 7 数对，显然答案不可能超过 $n^7$ 级别，先假设是一个多项式。

先跑出来 $n=0,1,2,3,4,5,6,7,8$ 十个答案的所有值，然后分别对十个值做拉格朗日插值找到 $n=10^15$ 的值，如果真的是一个多项式就可以过。

~~果然过了~~

什么推式子都不需要。

我的不同方法就这些了 QAQ