作为有个蒟蒻，我想记录下我这题的自闭的那些坑！

做的时候想错了思路：

- 以为只要走到边界就是答案

- 想简单了，以为只要能够一直走，不会被拦下来就是成功 
结果看到了这个测试点：

		#.#.#
		..#..
		#####
		.S#..
		#.#.# 
        
 
    可以尝试把它填满9宫格矩阵，会发现从任何一个点
	开始走，最后都会回到这个点，那么这就相当于在
	绕圈圈，这样也可以一直走。但是这样根本不是答案 

- 以为每经过一个地图，就必须经过S点，直到我看见这个样例：


		3 4
		..#.
		#.#S
		#.##  
        
第二列可以一直走下去
		
 
~~敲黑板~~

注意：题意是地图无限大!有无限个一样的矩阵连接起来，所以只需要 
有一条道路能够一直走下去，而不是绕圈，不是返回到S点
而是找到一条可以一直走下去的路，要远离S点。不撞南墙不回头 那种 

```cpp
所以我想到了，虚拟坐标，它走让它走。
声明：
		flag[x][y][0]标记这个点是否走过
		flag[x][y][1]记录虚拟坐标的rx的坐标
	    flag[x][y][2]记录虚拟坐标的ry的坐标
	(rx,ry)坐标下面说明： 
```

	  
DFS中的 3 4 参数是（rx,ry）坐标，这个坐标不做任何处理，无论是正是负，都让它走。
     
	 1.如果走到走过的点，(x,y)也就是flag[x][y][0]==1
	 2.判断这个点的虚拟坐标(rx,ry)是否等于==(rx,ry)
	 	如果相等(==)：说明原来走得路都是在绕圈！ 
	 	如果不相等(!=)：说明可以无限走下去！ 

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,flag[2001][2001][4],yes=0;
char a[2001][2001];
int fz[][2]={0,1,1,0,0,-1,-1,0};
 //正常取模(x,y)坐标，不做任何处理的虚拟坐标(rx,ry) 
void DFS(int x,int y,int rx,int ry){
	if(yes || a[x][y]!='.') return ; //如果找到答案或者不是路 
	//printf("%d %d\n",x,y);
	if(flag[x][y][0]){ //如果这个点之前走过 
		if(flag[x][y][1]!=rx || flag[x][y][2]!=ry){
			yes=1; //如果正常取模坐标(x,y)!=虚拟坐标(rx,ry) 
		}         //成功！ 
		return ;
	}
	flag[x][y][0]=1; //标记这个走过 
	flag[x][y][1]=rx; //而且记录此时的虚拟坐标 (rx,ry)
	flag[x][y][2]=ry;// 
	for(int i=0;i<4;i++){
		int xx=(x+fz[i][0]+n)%n,yy=(y+fz[i][1]+m)%m;
		//看这里：(xx,yy)是正常取模坐标 
		DFS(xx,yy,rx+fz[i][0],ry+fz[i][1]);
	}  //而(rx+fz[i][0],ry+fz[i][1])是不做任何处理的虚拟坐标 
}
int main(){
	while(scanf("%d%d",&n,&m)!=EOF){
		int x,y;
		for(int i=0;i<n;i++){ //输入有个小坑 
		    scanf("%s",&a[i]);//需要不读空格和回车的输入 
			for(int j=0;j<m;j++){
				if(a[i][j]=='S') x=i,y=j,a[i][j]='.';
			}
		} 
		DFS(x,y,x,y); 
		if(yes==1) printf("Yes\n");
		else printf("No\n");
		yes=0;
		memset(fla//g,0,sizeof(flag)); //防！
	}
} 
```
求审核大大让过~蒟蒻的无能狂怒