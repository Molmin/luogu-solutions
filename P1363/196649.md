# P1363 幻想迷宫 题解

之前膜拜了一下Dalao们的题解，很多人说复制成到原来的3倍的矩阵会超空间，可是为什么要把1*1的迷宫拓展成3*3的呢？不如我们就拓展成2*2的，这样保证了内存是绝对不会超的，我做完内存36M。

那么复制矩阵的操作就不用解释了，接着很明显，深搜就完了。

思路如下：

1. 走到的点标记下，一开始输入的墙标记为1，走过的地方标记为2；每次走的时候都对长宽的两倍取余，保证不越界，这一点和别人写的思想应该是差不多的。

1. 以上，那么越界的时候我们就传送回去；但是，在这传送之前，我们就可以判断这个地方是否被走过了（上述的越界是超过n*m），如果走过，就意味着我们可以从原来的矩阵走到下一矩阵的该位置，因为地图是无限大的，那么我们是不是就可以认为可以走的出去呢？这么想就是正确的。

对于以上第二点，我们可以把边界写出来。

在此之前，有些读者可能不理解，我下面给出进行解释：

```cpp
                  if(x>=n || y>=m)
```


边界一：

```cpp
                  f[x%n][y%m]==2
```
**由于我们的填充方式，我们不会重复走我们走过的**，这意味着虽然我们越界会被“传送”回来，但是这个**位置被填充过了就不能走**，那么如果我们回来了，这是不是意味着我们可以无限走呢？那么我们就“离开”了迷宫。

边界二：

```cpp
                  f[x%n+n][y%m]==2
```

这个与边界一很像，如果我们到了其他矩阵的相应位置，那么貌似也是可以无限走的，所以其他边界也就很容易得出：

```cpp
                  f[x%n][y%m+m]==2
                  f[x%n+n][y%m+m]==2
```

遇到以上条件，那么我们就可以停止了。那么我们需要一个标志变量，表示我们找到了答案，然后以这个标志变量为边界退出其他搜索（第一次搜到能走出去就行了）。

特别的，我还准备了几张图供读者理解：

![](https://i.loli.net/2019/05/10/5cd585cf12f9c.png)

![](https://i.loli.net/2019/05/10/5cd585cf12f15.png)

![](https://i.loli.net/2019/05/10/5cd585cf12fcd.png)

这三张图表示的都是我们可以走到其他矩阵的相应位置，当然，**不一定是S走到下一个S**。虽然**对于二三图在该样例中是不能实现的，但是遇到其他地图就可能了**，这里只是给出图片供大家理解。

那么要是以上步骤都不执行，就判断是否越界，不越界就走到下一步，越界就传送回来。

给出两个部分的代码：



$code1$ 复制矩阵操作
------------

```cpp
  for(int i=0;i<n;i++) {
      for(int j=0;j<m;j++) {
          cin>>c;
          if(c=='#') //复制操作
              f[i][j]=f[i+n][j]=f[i][j+m]=f[i+n][j+m]=1;
          if(c=='S') x=i,y=j;//记录出发位置
      }
  }
```


$code2$ 搜索部分（~~核心~~）
------------

```cpp
inline void dfs(int x,int y) {
	if(flag) return;
	if(x>=n || y>=m) {
		if(f[x%n][y%m]==2||f[x%n+n][y%m]==2||f[x%n][y%m+m]==2||f[x%n+n][y%m+m]==2) { //边界
			flag=true;
			return;
		}
	}
        //这个位置走过了
	f[x][y]=2;
        //判断是不是能走
	if(!f[(x+1+2*n)%(2*n)][y]) dfs((x+1+2*n)%(2*n),y);
	if(!f[(x-1+2*n)%(2*n)][y]) dfs((x-1+2*n)%(2*n),y);
	if(!f[x][(y+1+2*m)%(2*m)]) dfs(x,(y+1+2*m)%(2*m));
	if(!f[x][(y-1+2*m)%(2*m)]) dfs(x,(y-1+2*m)%(2*m));
}
```
当然，剩下的就大家去补充吧（~~我都写了这么多不要说你不会~~）

~~然后我们就成功AC了~~

复杂度大约是$O(NM)+$递归时间复杂度?（反正不高）

**特别的：第二段代码中的flag的变量和是全局的，如果搜索完后是假那么就输出$NO$，并且，由于有多组测试数据，读入和清零是需要注意的。**

![](https://i.loli.net/2019/05/10/5cd58a5637575.png)

![](https://i.loli.net/2019/05/10/5cd58a5651555.png)


~~不点个赞再走吗orz~~
------------

