简单的bfs或者dfs即可。

在搜索时考虑当前所处的r\*c的区域相对于初始点所处的r\*c的区域的偏移量。

e.g
r=5 c=4       x点相对于S点所在的区域的偏移时（-1,0）

# #  。 #     这样我们每次搜索时如果向左超出边界，下一个点的偏移为（row,col-1），向右则是（row,col+1）

# #  S  #      横坐标同理。

# 。 。#     如果在搜到相同点的时候，发现原先点的偏移量和现在点的偏移量不同，则出现循环。输出Yes

# 。 #  #

# 。 。#

# #  。 #    p.s：按理说dfs对于本题效率应该更高，但是dfs会出现崩栈，所以bfs还是更保险一点。

# #  。 #             当然也可以想偶一样吧dfs改成非递归。之后发现竟然可以0ms AC

# 。 。#

# 。 #  #

# 。 X #

另外：Tune神犇用的是递归的dfs，却没有崩掉，据说时看这儿的题解：

http://endlesscount.blog.163.com/blog/static/821197872012515111314821/

无限YM

本题题目来源：Codeforces Infinite Maze
