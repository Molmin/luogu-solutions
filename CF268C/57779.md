比较简单的一道题。我们来分析一下：

题目定义：

给出一组好点的定义：

1. 所有的好点都属于整点

1. 每对好点的距离都不是整数

1. 所有好点的坐标$(x,y)(x,y)$满足有$x\in [0,n],y\in [0,m]x∈[0,n],y∈[0,m]$

1. $(0,0)(0,0)$不是好点

第一点是说坐标是整数，很好处理。第三点是说 $x$ 为 $1$ ~ $x$ 间，$y$ 为 $1$ ~ $m$ 间，就是循环的起始与结尾，也没啥难的。第四点现在也看不出啥来。

那主要的就是第2点，他说不是整数，那么选完某个点后，就不能再选和他同一列或者同一行的点了，如：选了$(1,1)(1,1)$，就不能选第一行的点和第一列的点了。好动了这个，那么稍加思考一下，就能发现好点最多为 $min(n,m)+1$。

那怎么放好点呢呢，最简单的，肯定是一条斜线了了。但是由于第四点（0，0）不是好点，所以我们必须选择这一条对角线（图1）。如图，这是一个$4*5$（ $n$ 为 $3$，$m$ 为 $4$ ）的格子，好点形成一条斜线，1为好点，0不是好点。




| 0|0  | 0 | 1 | 0 |
| -----------: | -----------: | -----------: | -----------: | -----------: |
| 0 | 0 | 1 | 0| 0 |
| 0 | 1 | 0 | 0 |  0|
| 1 | 0 | 0 | 0 | 0 |
图1

那么每两个好点的距离应为：$\sqrt{1^2+1^2}=\sqrt{2}$，所以不是整数，符合要求。

那我们来看看坐标，这些点的坐标为（注意，$x$ 和 $y$ 都是从0开始）：

$(0,3)(1,2)(2,1)(3,0)$

那也就是$(i,min(n,m)-i)$

上代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m;
int main() {
    cin>>n>>m;//输入
    n=min(n,m);
    cout<<n+1<<endl;//输出最多数量
    for(int i=0;i<=n;i++)cout<<i<<" "<<n-i<<endl;//输出坐标
}
```

大佬们点个赞再走吧！