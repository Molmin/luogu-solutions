一道好题，不涉及高深算法，主要练练思维。给出题人赞一个。

但是考场上想到 AC 做法真不容易。

而且细节还非常多。我 debug 了好久啊……

----------

### 解题思路

为了方便，姑且把小 Z 叫做我方，小 Y 叫做对方。且某些变量的范围如果显然则不写明。

乍一看没头绪？先抓住游戏的特点来分析。

注意只有**一个回合**，就是我方摸一次，对方摸一次就停止。

首先看看**不取**的情况：

我方不取，分数为 $0$。而 $0$ 已经是最低分，要么平局要么输，我方一定不会赢。**因此不必考虑不取的情况。**

----------

接着看到**连续**取牌——想到了区间和。
 
那么记 $S_{i,j}$ 表示区间 $[i,j]$ 数列 $a$ 的和。

由于**连续**取牌，若我方取 $x$ 张牌，对方随后取了$y$，则我方点数和为 $S_{1,x}$，对方点数和为 $S_{x+1,y}$。此时双方共取牌 $x+y$ 张，总共和为 $S_{1,y}$。

由于只有两人取牌，显然有下列式子：

$$S_{1,y}=S_{1,x}+S_{x+1,y}$$

即，

$$S_{1,y}-S_{1,x}=S_{x+1,y}$$

获胜条件可以表示为下列式子：

$$0\le S_{x+1,y}< S_{1,x}\le X\le K$$

**注意一句话：**

> 如果一样高，则无人获胜。

**明确本题要求的是我方必赢，因此平局算输**。注意原式的等号。

简单变形一下（省略某些条件）：

$$S_{1,y}-S_{1,x}< S_{1,x}\le X$$

即，

$$\begin{cases}S_{1,y}< 2S_{1,x} \\ S_{1,x}\le X\le K \end{cases}$$

别忘了，当 $S_{1,y}-S_{1,x}>X$ 时，也是我方获胜。

------------

那么现在尝试通过某种算法来满足上述条件。

$S$ 可以预先用**前缀和**求出，时间复杂度 $O(n)$。

对于 $x$，可以枚举不超过 $K$ 的 $S_{1,x}$，时间复杂度 $O(n)$。

对于 $y$，显然如果还用枚举，总时间复杂度达到 $O(n^2)$，果断舍弃。

但是别忘了，前缀和具有**单调性**。考虑二分查找 $y$。

如果存在 $y$ 满足 $S_{1,y}\ge 2S_{1,x}$ 且 $S_{1,y}-S_{1,x}\le X$ 的，那么我方必定不赢，这不是我们想要的取牌方案。

否则，不存在 $y$ 能使对方获胜。接下来就简单的讨论一下 $y$ 的情况，来决定 $X$ 所在的取值范围。

- 肯定的是，对于 $S_{1,y}=2S_{i,x}$，不考虑即可。因为这是平局，我方不能赢。

- 那么如果 $S_{1,y}<2S_{1,x}$，在 $[S_{i,x},1,K]$ 的范围内的整数，都是我们想要的 $X$。

- 如果是$S_{1,y}>2S_{1,x}$，那么在 $[S_{1,x},\min \{S_{1,y}-S_{1,x},K+1\})$ 的范围内的整数，也都是我们想要的 $X$。我们只需要让 $S_{1,y}-S_{1,x}>X$，变为 $0$ 分即可。

**注意上述区间的左右端点。**

那么，如果忽略统计答案时的时间复杂度，则为 $O(n\log n)$。~~实际上有点玄学~~

----------

### 另一种思路

![](https://cdn.luogu.com.cn/upload/image_hosting/pmbck196.png)

事实上，在前缀和单调性的基础上，我们可以采取比二分更快的方法——$\text{two-pointers}$。

因此正解时间复杂度为 $O(n)$。

详细内容请~~出门右转~~看其他地方的题解。

---------

### 实现细节

大部分是关于 STL 使用的，如果您不使用 STL 可略过。

- 在上述思路中，显然我们**不能保证统计的答案数组的是有序的且不重复**。那么必须使用桶记数或者用`vector`在`sort()`过后用`unique()`去重并用`erase()`删除多余元素。当然可以直接用`set`，但是复杂度会加多一个 $\log$，因为其内部是平衡树实现的。这里使用`vector`。

- 上述 STL 函数都是**左闭右开**。这是应有的常识。

- 建议前缀和开`long long`。

- 请注意二分时，如果采用 STL，请使用`lower_bound()`而非`upper_bound()`。因为如果使用后者，**平局的情况会被认为是** $S_{1,y}<2S_{1,x}$，返回值两者均为“未找到”。

- 使用`lower_bound()`，返回值“未找到”**并不总是**容器的`end()`，而是填入参数的第二项。具体见代码。

- `unique()`只能**移动连续**的重复元素到容器**末尾**，使其不重复，并不能做到完全去重或删除。因此需要先`sort()`排序后再`erase()`。

- 由于使用了大量的 STL，且读入较多，请务必**开启 O2 优化**。两者实际运行时间相差极大！

附：[开了 O2 的评测记录](https://www.luogu.com.cn/record/29836402) 和 [不开 O2的评测记录](https://www.luogu.com.cn/record/29836417)。

-----------

### 参考代码

~~丑陋码风以及压行请见谅~~

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <vector>
using namespace std;
typedef long long ll;
ll n,k;
vector<ll> ans;
int main()
{
	scanf("%lld",&n);
	vector<ll> a(n+2),s(n+2);//动态开数组
	for(ll i=1;i<=n;i++)
	{
	 	scanf("%lld",&a[i]);
		s[i]=s[i-1]+a[i];//求出前缀和
	}
	scanf("%lld",&k);
	for(ll x=1;x<=n && s[x]<=k;x++)
	{
		const auto iter=lower_bound(s.begin()+1,s.begin()+1+n,s[x]*2LL);//二分
		for(ll i=s[x];i<=k && (iter==s.begin()+1+n?true:i<*iter-s[x]);i++)//这里压行了，文末有解释
		 ans.push_back(i);
	}
    //下面是处理ans数组。
	sort(ans.begin(),ans.end());
	ans.erase(unique(ans.begin(),ans.end()),ans.end());
	printf("%lld\n",ans.size());
	for(auto i:ans)
	 printf("%lld ",i);
	return 0;
}
```
**部分代码解释**

```cpp
for(ll i=s[x];i<=k && (iter==s.begin()+1+n?true:i<*iter-s[x]);i++)
```
这句话通过`?:`来实现上文的分类讨论。

在上文中，可以发现两种情况的区间 $[S_{i,x},1,K]$ 以及 $[S_{1,x},\min \{S_{1,y}-S_{1,x},K+1\})$ 下界是一样的。

因此只需改变上界即可。而且无论是哪两种情况，都必须要保证 $X\le K$。

当然为了方便，你依然可以分开打代码。