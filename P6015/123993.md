~~生平第一次AC月赛T3~~

~~乡下人非常激动~~

~~发一篇题解以示心中的激动之情~~

------------

## 题解[【P6015 游戏】](https://www.luogu.com.cn/problem/P6015)

建议自己先读一遍题目再来看题解

**题意简化：**

一个由 $n$ 个数组成的有序数列，$A$ 取前 $i$ 个数，$B$ 取第 $i+1$ 至第 $i+j$ 个数

分别算出两人各自取到的数字之和 $x$ 与 $y$

再次读题：

“如果一个人手上的牌的数字和大于 $k$，那么他的分数就是 $0$，否则分数就是数字和。”

**可简单理解为$2$项要求：**

1、$x$ 小于等于一个常量 $k$  
2、$y$ 要么严格小于 $x$ ，要么严格大于 $k$

求给定范围内**保证**符合要求的 $k$ 值（即无论 $B$ 怎么取，均同时符合两项要求）

------------

**算法分析：**

输入举例：（输入输出格式请自己读题）
```
5
5 4 3 2 2
10
```

输出举例：
```
4
5 6 9 10
```

以上述数据为例进行分析：

- （1）当 $A$ 只取第一个数 $5$ 时：
  
  由第一项要求可得（以下简写为【1】，【2】同理），$k≥5$ 。此时，
  
  - （1-1）当 $B$ 只取 $4$ 时：
    
    因为 $4<5$ ，因此必然满足【2】，对于 $k$ 没有约束
    
  - （1-2）当 $B$ 取 $4+3$ 时：
    
    因为 $7>5$ ，要想满足【2】，必然要严格大于 $k$ ，因此 $k<7$
    
  **第一组答案出现了**：$5≤k<7$ ，$k=5$或$6$
  
- （2）当 $A$ 取 $5+4$ 时：

  由【1】得 $k≥9$。此时我们发现，$9$ 大于数列总和的一半，因此 $B$ 无论怎么取都会输（~~想一想，为什么？~~）

- 以此类推

------------

回头看这道题目，“取连续若干张牌”让你想到了什么算法？

**前缀和**

我们来算出这个例子的前缀和：
```
5 9 12 14 16
```
对应上文的情况（1），我们可以发现，有效 $k$ 范围与 $5$ 和 $12$ 两个数字有关

**而$12$恰好是数列中比$5$的两倍大的数字中最小的！（即 $2×5$ 的后继）**

------------

**初步猜想：**

对 $n$ 个数进行循环（第 $i$ 个数的前缀和的值记为 $a_i$ ），每次取出 $a_i$ 与 $2×a_i$ 的后继，计算区间进行输出

大家多试几组数据就会发现，这个猜想似乎是正确的

下面~~给出证明~~开始瞎掰：

设 $A$ 取出 $m$ 个数，$B$ 取出 $n$ 个数，则 $A$ 的总和为 $a_m$ ，$B$ 的总和为 $a_n-a_m$ ，称之为 $t$。

要使 $t<a_m$ ，必然有 $a_n-a_m<a_m$ ，即 $2a_m>a_n$ ，因此 $2a_m$ 的后继是上界（不包含）（~~想一想，为什么？~~）

------------

**算法实现**

首先我们要用到前缀和

然后结合刚才的分析，我们还需要求后继

“求后继”这一操作让你想到了什么算法？

**二分搜索**

~~二分属于入门知识，这里就不细讲了~~

**一个注意点**

题目要求有序输出，因此记录答案后要经历一次排序再输出

## $Code$：
```cpp
#include<bits/stdc++.h>
#define int long long//不开ll见祖宗，RE成70分
using namespace std;
int n,k,a[1000010],sum[1000010],ans[1000010],top,l,r;
bool vis[1000010];
signed main()
{
	scanf("%lld",&n);
	for(int i=1;i<=n;i++){
		scanf("%lld",&a[i]);
		sum[i]=sum[i-1]+a[i];
	}
	sum[n+1]=10e18;//手动添加一个尾数，防止后继在数组里找不到这种情况发生
	scanf("%lld",&k);
	for(int i=1;i<=n;i++){
		l=1;r=n+1;
		while(l<r){
			int mid=(l+r)>>1;
			if(sum[mid]>2*sum[i])
			r=mid;
			else if(sum[mid]<2*sum[i])
			l=mid+1;
			else{//恰好相等的要舍去，因为题目要求的是“严格大于”
				r=0;
				break;
			}
		}
		for(int j=sum[i];j<sum[r]-sum[i]&&j<=k;j++){
			if(!vis[j]){//因为13行加了尾数，因此答案可能重复，需要手动去重
				ans[++top]=j;
				vis[j]=true;
			}
		}
	}
	sort(ans+1,ans+top+1);//一定要排序！！！
	printf("%lld\n",top);
	for(int i=1;i<=top;i++){
		printf("%lld ",ans[i]);
	}
	return 0;
}
```
