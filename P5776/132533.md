**P5776**

如果你不知道耳分解，你可能会在做此题时吃大亏。

可能不完全严谨，建议看 ix35 论文原文。

对于任意一个是边双的原图，我们认为从一个初始子图为简单环的 $G_0$ 开始，对于 $G_i \rightarrow G_{i + 1}$，从边集的补集里选一个当且仅当路径端点在 $G_i$ 中的路径并入 $G_i$ 中得到 $G_{i + 1}$，最后可以得到原图。

对于这个路径就是耳，注意路径端点是可重复的，并且一条边在这个过程中只会被加入一次。

这个可以证明充要性。简单讲一下，必要性是因为任意每次拓展加入的都在原图上组成了一个简单环，所以肯定一直是边双；

充分性可以考虑构造一棵 $1$ 为根的 dfs 树，初始随便钦定一个和 $1$ 相连的非树边 $(1,x)$，将两点树上路径和该边构造初始简单环 $G_0$，在 $G_i$ 的点集 $V'$ 未满秩时每次找到一个 dfs 树上父亲在 $G_i$ 且自己不在 $G_i$ 中的点 $p$（在未满秩前显然存在这样的点），然后子树内随便找一个返祖边，设其连向 $p$ 的祖先 $u$ 以及 $p$ 的子孙 $v$，那么 $u$ 先走返祖边到 $v$ 然后走到 $p$ 的父亲去就是一个耳；如果 $V'$ 满秩了就每次把所有没加进的边扔进去就行了。

可以发现这样任意时刻，$G_i$ 中的点都是一个和 $1$ 联通的连通块。自然是对的。

这只是为了解决这道题而做的前置知识，如果你没看懂建议去看一下 ix35 原文，很好理解的。

------------------------------------------------------

回到这道题，那么我们可以状压 dp 模拟耳分解。维护 $f(S)$ 表示 $S$ 中的节点构成边双的最小花费，由于是最小花费我们可以不记录边集的选择情况，因为状压 dp 的过程肯定能算到所有可能出现的分解情况，重新算一条边一定不优。

一个比较显然的转移是维护一下 $E(T,x,y)$ 表示点集为 $T$，且 $x,y \in T$，从 $x$ 走到 $y$ 经过 $T$ 中所有点的最小边权和。

转移的时候枚举子集，令 $f(S) \leftarrow f(S/T) + \min_{x,y \in T} E(T,x,y) + \min_{a,b\in S/T} e_{a,x} + e_{b,y}$ 即可模拟一次加耳的过程。

当然你也可以直接枚举一个 $E(T \cup \{a,b\},a,b)$ 来算，毛姑姑下来可能是 $O(3 ^ n \times n ^ 2)$，剪点枝肯定跑的很快。

更快的理论复杂度做法是我们套路化的不一次加完一个耳，设 $dp(S,x,y)$ 表示 $S$ 中有一部分点正在进行加耳的步骤，并且当前已经加到了 $x$，而加耳的过程在末端点是 $y$ 时会结束时的最小边权和，再去转移原本的 $f(S)$。

发现你肯定能做到 $O(2 ^ n \times Poly(n))$ 了，不过你发现有很多 corner：

- 存在直接向外伸出一个点后回来的情况，直接暴力枚举解决；

- 由于 $dp(S,x,y)$ 只能记录两个节点，转移可能会出现从原本在 $G_i$ 的一个节点 $x$ 走到 $y$ 去经过同一条边走回来的情况，所以要多设一维，即 $dp(S,x,y,1/0)$ 新增一个维表示当前加耳的过程中，$x$ 是/不是当前耳按照枚举顺序下的第二个节点。

- 然后就直接让 $dp(S,x,y,1)$ 才能向 $f$ 数组更新，其它转移照常即可。发现这时候也会少算“从 $G_i$ 走出去找到一个点然后又走回一个在 $G_i$ 中但不同于出发点”的情况，照样枚举算就好了。

时间复杂度 $O(2 ^ n \times n ^ 3)$，自己的代码 corner 判的不好于是无耻地贺了 ix35 的代码。

```cpp
#include "bits/stdc++.h"
using namespace std;
const int Len = (1 << 12) + 5 , Inf = 0x3f3f3f3f;
int n,m,w[25][25][2],dp[Len][16][16][2],f[Len];
inline void solve()
{
	memset(w , 0x3f , sizeof w);
	memset(dp , 0x3f , sizeof dp);
	memset(f , 0x3f , sizeof f);
	scanf("%d %d",&n,&m);
	for(int i = 1 ; i <= m ; i ++)
	{
		int x,y,ww;scanf("%d %d %d",&x,&y,&ww);x -- , y --;
		if(w[x][y][0] > ww){w[x][y][1] = w[x][y][0];w[x][y][0] = ww;}
		else w[x][y][1] = min(w[x][y][1] , ww);
		swap(x , y);
		if(w[x][y][0] > ww){w[x][y][1] = w[x][y][0];w[x][y][0] = ww;}
		else w[x][y][1] = min(w[x][y][1] , ww);
	}
	for(int i = 0 ; i < n ; i ++) f[1 << i] = 0;
	for(int i = 1 ; i < (1 << n) ; i ++)
	{
		//printf("%d %d\n",i,f[i]);
		for(int j = 0 ; j < n ; j ++)
		{
			if(!((i >> j) & 1)) continue;
			for(int k = 0 ; k < n ; k ++) 
			{
				if(!((i >> k) & 1)) continue;
				f[i] = min(f[i] , dp[i][j][k][1] + w[j][k][0]);
			}
		}
		if(f[i] < Inf)
		{
			//case 1:直接伸出去一个点后回来，枚举 S 内端点和伸出去的点 
			for(int j = 0 ; j < n ; j ++)
			{
				if(!((i >> j) & 1)) continue;
				for(int k = 0 ; k < n ; k ++)
				{
					if((i >> k) & 1) continue;
					f[i | (1 << k)] = min(f[i | (1 << k)] , f[i] + w[j][k][0] + w[j][k][1]);	
				}	
			}
			//case2:伸出去一个带中转点的环，依次枚举这三个点，顺便 
			for(int j = 0 ; j < n ; j ++)//1,2,4,3 这个环没有枚到。 
			{
				if(!((i >> j) & 1)) continue;
				for(int k = 0 ; k < n ; k ++)
				{
					if((i >> k) & 1) continue;
					for(int l = 0 ; l < n ; l ++)
					{
						if(!((i >> l) & 1)) continue;
						dp[i | (1 << k)][k][l][0] = min(dp[i | (1 << k)][k][l][0] , f[i] + w[j][k][0]);
						//if((i | (1 << k)) == 11 && l == 0 && k == 3) printf("!!!%d\n",dp[i | (1 << k)][k][l][0]);
						if(j != l) f[i | (1 << k)] = min(f[i | (1 << k)] , f[i] + w[j][k][0] + w[k][l][0]);
					}
				}
			}
		}
			//case3:暴力转移
			for(int j = 0 ; j < n ; j ++)
			{
				if(!((i >> j) & 1)) continue;
				for(int k = 0 ; k < n ; k ++)//枚举的耳的另一个端点 
				{
					if(!((i >> k) & 1)) continue;
					if(min(dp[i][j][k][0] , dp[i][j][k][1]) == Inf) continue;
					for(int l = 0 ; l < n ; l ++)
					{
						if((i >> l) & 1) continue;
						dp[i | (1 << l)][l][k][1] = min(dp[i | (1 << l)][l][k][1] , 
						min(dp[i][j][k][0] , dp[i][j][k][1]) + w[j][l][0]);
					}
				}
			}			
		
	}
	if(f[(1 << n) - 1] == Inf) puts("impossible");
	else printf("%d\n",f[(1 << n) - 1]);
}
signed main()
{
	int T;scanf("%d",&T);while(T --) solve();
	return 0;
}
```