我们先思考，当只有一个序列时，如何求出其有多少个不重复的子序列？显然可以定义F[I]表示这个序列的前I位有多少个不同的子序列，转移方程很简单，因为第I个字母可以接在某序列的后面，也可以不接，自然就是F[I]=F[I-1]\*2。这样我们会发现答案就是2^长度。但是，这显然是错的。因为我们没有判重！


要知道如何去重，就必须知道出现重复序列的原因！


设当前位S[I]=’a’，并且存在一个最大的J，使得J<I且S[J]=‘a’，那么当阶段在J的时候，我们可以选择是够让F[J-1]个序列接上S[J]。同理，阶段在I的时候，可以选择是否让F[I-1]个序列接上S[I]。显然，F[I-1]包含了所有F[J-1]的序列，如果F[J-1]个序列在J选择了接的那一部分在I时选择不接，在J选择不接的那部分在I选择了接，这样就产生了重复的串！所以我们要做的就是让同一个序列不要同时面临两个一样的决策！所以，当阶段在I的时候，我们得到F[I]=F[I-1]\*2，其中是包括了个F[J-1]个序列的重复决策，所以需要减去这些重复的序列，最终得到正确的转移方程：F[I]=F[I-1]\*2-F[J-1]。


现在我们可以将问题扩展到复杂情况了，有类似的思想，可以轻易想到转移方程，当A[I]=B[J]=C[K]时，显然


F[I,J,K]=F[I-1，J-1，K-1]\*2-F[II-1，JJ-1，KK-1]，其中II、JJ、KK分别为三个序列在I、J、K位前的最靠近该位的位置，并且A[I]=A[II],B[J]=B[JJ],C[K]=C[KK]。貌似到此问题得到解决了，但是写程序的时候会发现，多序列和单序列还是有不同的！


多序列和单序列不同之处在于：多序列需要考虑字符不相等的时候的转移！必须将前面的状态全部转移过来，又不能重复，有什么思想可以解决？？


容斥原理！！


所以可以得到状态转移方程：



F[I,J,K]=

F[I-1,J,K]+F[I,J-1,K]+F[I,J,K-1]


-F[I-1,J-1,K]-F[I-1,J,K-1]-F[I,J-1,K-1]


+F[I-1,J-1,K-1]。
