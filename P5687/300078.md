作为一道不需要用到算法的题，这着实是一道好题！

题意简述：用最小的代价，在这个点阵中连边，使得所有点互相联通。

想想最小生成树的思想——贪心、不在已经联通的块中连边（即不构成环）。

那么这道题也是一样，在已经连上的边所构成的一些连通块当中，我们只在互相独立的两个块之间连边使其合并。

对于 $10^5$ 数量级的 $n,m$，显然不可能直接建图+暴力最小生成树。但是可以确定的一点是，我们首先对所有的权值（不论是行的还是列的）从小到大排序。每次取最小的那个权值看在它的这一行（或列）最少连多少边。显然最多要连 $n-1$（$m-1$）条。那么考虑什么情况下是必须要连全部的边的。或者说什么情况下是可以有部分边不需要连的？首先我们姑且把全部的边连上，然后再去看能不能舍去一些。
- 当我们在连的是行的权值时：如果我们看到连完之后出现了环，那么就可以省去 (【目前已经连过的列数】-1) 条边。
- 当我们在连的是列的权值时：如果我们看到连完之后出现了环，那么就可以省去 (【目前已经连过的行数】-1) 条边。

举个例子：

![](https://cdn.luogu.com.cn/upload/image_hosting/x9ru4brm.png)

构成了环。当前我们在连的是列的边，所以我们就看【目前已经连过的行数】（即红线条的数量），得到 $2$，那么就可以少连两条边，因此当前操作的这一列要加的权值就是 $w\times (n-1) - w\times (2-1)$。省掉之后大概是这样：

![](https://cdn.luogu.com.cn/upload/image_hosting/2ehbbtcy.png)

所以现在要考虑的就是什么条件下可以省，什么条件下不能省，如你所知，当然不是所有的情况都可以省去 (【目前已经连过的行（列）数】-1) 条边的。换言之，就是我们连全部的边之后看到的景象什么时候会出现环。

一个环，俗一点说，至少要有两根横杠两根竖杠，所以判断条件就是：【（连完这次之后）目前已经连过的列数】大于等于 $2$ 且【（连完这次之后）目前已经连过的行数】大于等于 $2$。

代码：
```
#include <bits/stdc++.h>
using namespace std;
const int N=6e5+5;
struct node { int ty,val; } a[N];
bool cmp(node a,node b) { return a.val<b.val; }
int main()
{
    int n,m,x=0,y=0;
    long long sum=0;
    cin>>n>>m;
    for(int i=1;i<=n;i++) scanf("%d",&a[i].val),a[i].ty=1;
    for(int i=n+1;i<=n+m;i++) scanf("%d",&a[i].val),a[i].ty=2;
    sort(a+1,a+n+m+1,cmp);
    for(int i=1;i<=n+m;i++){
        if(a[i].ty==1){
            sum+=1ll*(m-1)*a[i].val;
            x=x<n?x+1:x;
            if(x>1&&y>1) sum-=1ll*(y-1)*a[i].val;
        }
        else {
            sum+=1ll*(n-1)*a[i].val;
            y=y<m?y+1:y;
            if(x>1&&y>1) sum-=1ll*(x-1)*a[i].val;
        }
    }
    cout<<sum<<endl;
    return 0;
}
```