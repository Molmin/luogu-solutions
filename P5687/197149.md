屑$lzy$的屑题解——$P5687$

$1.64pts$做法

就是跑$Kruskal$（不晓得拼没拼错

但是我们细细一想，这个$Kruskal$需要排序$n*m$条边，非常浪费，这样跑不过$3<=n,m<=3*105$的数据范围，这样就不是最优的。

克鲁斯卡尔算法的基本思想是以边为主导地位，始终选择当前可用的最小边权的边（可以直接$sort$）。每次选择边权最小的边链接两个端点是$Kruskal$的规则，并实时判断两个点之间有没有间接联通。

这样的话64pts就拿到手了。

2.$68pts$做法

把数组开大点，$68pts$危险的拿到了！

（奇怪的分数增加了！！！

3.$100pts$做法

康康克鲁斯卡尔的思想，我们再康康题目，就会发现其实有很多边的边权是一样的，那么我们可以让这些多余的边不参与$Kruskal$的排序，这样只会排序$n+m$条边了。（因为这些边权一样，其中一条边为最小，则这些边都为最小）

我们还应该维护两个指针，指向横向的边和纵向的，来记录我们下一步应该取哪一条边（哪一条边最小）
我们如何确定取多少边呢？

很简单，在没有环的情况下最多的边数就是我们要去的边数。
这样大体思路就有了。

那么上代码！
```
#include<algorithm> 
#include<iostream> 
using namespace std; 
int n,m,a[300010],b[300010];
long long ans;//要用longlong!!!（坑死我了（awsl 
int main()
{ 
     cin>>n>>m; 
     for(int i=1;i<=n;i++) cin>>a[i]; 
     for(int i=1;i<=m;i++) cin>>b[i]; 
     sort(a+1,a+n+1);//排一下序，保证取出的都是最小的 
     sort(b+1,b+m+1); 
     ans=(long long)a[1]*(m-1)+(long long)b[1]*(n-1);//最小的边是肯定要取的 
     int a_=2,b_=2,l=1,r=1; 
     while(a_<=n&&b_<=m)//如果没有遍历完
     { 
        if(a[a_]<=b[b_])/*如果此时横列小于竖列*/ans+=(long long)a[a_++]*(m-r),l++;/*ans就加上整个横列，行数++*/ 
        else ans+=(long long)b[b_++]*(n-l),r++;//否则加上整个竖列，列数++
     } 
     cout<<ans; 
     return 0; 
}
```