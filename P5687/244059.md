近日，回顾了CSP2019—JX的赛题，做到T3时感到这道题很有意思，拿来分享一下。关于这道题，我将分正解和部分分两块进行讲解，**为暴力骗分选手与AK神犇提供思路**。

# 部分分
-

观察数据范围，我们可以得知，对于$64%$的数据:

$n,m≤300,a_i,b_j≤1000$

而克鲁斯卡尔（$Kruskal$）最小生成树的复杂度是$O(N log N)$,存图的时时间复杂度是$n×m$,所以，我有一个大胆的想法（~~手动滑稽~~）

## 建图
这个建图部分是属实的恶心，第一遍我都存错了。题解区好像也没有具体分析这个部分分存图方式的，我来做第一个吃螃蟹的人，**详细分析一下存图**。

我们手动画一下样例的网格图，发现同一行,同一列的权都相等，即

$W_{i,j}=W_{i,j+1} \ \ W_{i,j}=W_{i+1,j}$

显然，直接建图并不是一个正确的选择，我们需要**给点标号**，设坐标为$(1,1)$的点为$1$，**从左往右，从上到下递增**。根据样例，我们得到如下网格图（数字即标号）：
```cpp
1 2 3

4 5 6

7 8 9
```

我们就**根据这个编号存图即可**。

建图代码：
```cpp
for(fint i=1;i<=n;i++)
{
	x=read();
	for(fint j=1;j<m;j++)
	adds((i-1)*m+1+(j-1),(i-1)*m+2+(j-1),x);
}
for(fint i=1;i<=m;i++)
{
	x=read();
	for(fint j=1;j<n;j++)
	adds(i+(j-1)*m,i+j*m,x);
}
```

## 求解
然后我们跑一个**裸的Kruskal最小生成树**即可

此部分代码：
```cpp
sort(e+1,e+cnt+1,cmp);
for(fint i=1;i<=n*m;i++)
f[i]=i;
int ans=0,vis_tim=0;
for(fint i=1;i<=cnt;i++)
if(findx(e[i].from)!=findx(e[i].to))
{
	f[findx(e[i].from)]=findx(e[i].to);
	ans+=e[i].val;
	vis_tim++;
	if(vis_tim==n*m-1)
	break;
}
cout<<ans;
return 0;
```
就这样，我们拿下了**64分**

# 正解
-

当我们拿到$64pts$时，我们就该离成功不远了。$100pts$部分$3e5$的大数据显然不再适合暴力的$Kruskal$算法，但是$Kruskal$没有过时，稍加改动仍能奇迹再现！

## 思路

之前我们在跑最小生成树的时候，由于权值相等的边不断被加入判断之中，显得十分臃肿，那我们能不能考虑优化一下，使每个全相等的同行同列边不重复判断呢？其实，我们只需**使用整体思想，将同一行，同一列的边合为一体**，那么$AC$就指日可待了！

## 具体实现
我们只需**分别对a,b数组排序**，**对权进行处理，并加入生成树内**，此时优化后的最小生成树，就是我们最终的答案了！记得开$long long$
```
sort(a+1,a+n+1);
sort(b+1,b+m+1);
int ans=a[1]*(m-1LL)+b[1]*(n-1LL);
int sa=1,sb=1,aa=2,bb=2;
while(aa<=n&&bb<=m)
{
	if(a[aa]<=b[bb])
	ans+=a[aa]*(m-sb),sa++,aa++;
	else
	ans+=b[bb]*(n-sa),sb++,bb++;
}
cout<<ans;
return 0;
```

如此详细的一篇题解，如果对你做题有帮助话，那可是再好不过了呢！！

两种做法（$64pts/100pts$）的代码有需要的话[点此领取](https://www.luogu.com.cn/paste/3qbsm468)，最后，祝大家AC愉快哦！