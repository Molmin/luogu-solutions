## 此题算法为排序+贪心（尽管我没有排序）

------

首先读懂题意

>有$2n$个数，互不重复，一半是$B$的，一半是$E$的，每次$B$与$E$都出一个数，数大者胜，$B$后手出牌（可以这么理解），那么$B$最多赢几盘？

### 大家应该第一次想到的是暴力吧

先比较，将$B$的每个数二分查找在$E$中刚好比某一个数大的一个，用这两个抵消，剩下小的就是不能取胜的。

那么二分查找为$O(logn)$，一共$n$个数，总复杂度$O(nlogn)$，虽然对于本题数据过得去，但是代码实现有些复杂。

还有什么办法呢？

### 排序+比较

我们可以将$B$与$E$的牌都排序，然后从第一张开始，逐个比较，如果$B_i>E_j$，那么就可以将$ans$加一，否则一直将$B$数组向后查找元素直到出现$B_i>E_j$。

那么为什么正确呢？

假设有两个有序上升数列$B$，$E$，且这两个数列没有交集，数列中也不存在两个相同的数字。

假设有情况刚好$B_i>E_j$，设此时不是最优，那么设$B_{i-n}$或$B_{i+n}$与$E_j$配对可以更优，如果用$B_{i-n}$，那么根据条件，比$E_j$小，比原有可获得分数少$1$分，与原有假设不符；若选用$B_{i+n}$，那么$E_{j+n}$中可能存在比$B_i$大而比$B_{i+n}$小的数，此时也会使可获得分数减少，与假设不符。

所以刚刚的算法即可求最优解

上代码

```cpp
#include<bits/stdc++.h>
using namespace std;
bool b[100010],e[100010];//记录B，E所有的数字
int main()
{
	int n,a;
	cin>>n;
	memset(b,1,sizeof(b));//一开始B有全部数字
	for(int i=0;i<n;i++)
	{
		cin>>a;
		e[a]=true;//E有了这个数字
		b[a]=false;//E有的数字B就没有了
	}
	int b_[100010],e_[100010];//用来存数字的数组
	int now=1,now2=1;
	for(int i=1;i<=n*2;i++)//转化数字+排序一起
	{
		if(b[i])b_[now++]=i;
		if(e[i])e_[now2++]=i;//是true就代表有这个数
	}
	int ans=0,bnow=1,enow=1;
	for(int i=1;i<=n;i++)
	{
		if(b_[bnow]>e_[enow])//如刚刚算法所描述
		{
			ans++;
			bnow++;
			enow++;
		}
		else
		{
			bnow++;
		}
	}
	cout<<ans;//输出
	return 0;
}
```

#### 题解仅提供思路，代码请自己编写。