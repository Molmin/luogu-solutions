## 思路：
由于是在网格中移动，所以只有上、下、左、右四个方向。简单地说，只存在横向和纵向的两种移动。  
因此，从 $A$ 到其他一点，肯定是横向移动一定距离（使横坐标相等）且纵向移动一定距离（使纵坐标相等）。显而易见，在网格中这是最短的路线。  
综上，移动共分为两步：横向移动（横坐标 $+X$），和纵向移动（纵坐标 $+Y$）。
因此，我们只需要求出 $A$ 到 $B$ 和 $A$ 到 $C$ 中，横向移动与纵向移动相同的部分，注意，起点 $A$ 也算在相同部分之内，不要漏了。 
## 例子：
将以上思路用于样例第一个测试点：  
从 $A$ 到 $B$ 横坐标 $-2$，纵坐标 $+2$；  
从 $A$ 到 $C$ 横坐标 $+3$，纵坐标 $+3$。  
横坐标两条路线显然无交集，纵坐标可以一起向上走两格（$+2$）。
## 结论：
当横坐标改变值为一正一负时，横向两者不能一起走。  
当横坐标改变值为同正或同负时，两者可以一起走，走的长度为绝对值较小的改变值。  
纵坐标同理。  
最后，统计横纵总共可以一起走的，并加上起点 $A$。
## 精简代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int t;
int xa,ya,xb,yb,xc,yc;
int x,y;
int main(){
	cin>>t;
	while(t--){
		scanf("%d%d%d%d%d%d",&xa,&ya,&xb,&yb,&xc,&yc);
		printf("%d\n",min(abs(xa-xb),abs(xa-xc))*((xa-xb>0)==(xa-xc>0))+min(abs(ya-yb),abs(ya-yc))*((ya-yb>0)==(ya-yc>0))+1);
        	/*
        	min(abs(xa-xb),abs(xa-xc))*((xa-xb>0)==(xa-xc>0))
            	此部分为横向，前面min函数内的为求较小的绝对值
                后面部分为判断改变值是否同号，如果不同号，那么后半部分的值为0，乘起来整体为0
                当有一个横向移动距离为0时，整体为0，不用特判
                */
	}
	return 0;
}
```