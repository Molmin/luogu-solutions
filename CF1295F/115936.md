我数组开小了一半都能过 70 个点，有点好笑了。

昨天就会了，但是懒得写，今天抽空写了一下。

朴素的方法是 $f_{i,j}$ 表示 $a_i=j$ 时，$a_{[1,i]}$ 的方案数，暴力转移即可。复杂度 $O(na^2)$。

考虑优化，把所有的 $l_i,r_i$ 一起放到数轴上，会发现形成了若干个区间，每个区间内的点是可以一起考虑的，且只有至多 $2n$ 个区间。

那么做法显然了，把区间离散化，$f_{i,j}$ 表示 $a_i$ 在第 $j$ 个区间的时候，$a_{[1,i]}$ 的方案数。

考虑转移，对于每个区间需要一下子选出连续一段的东西，也就是说对于 $l>j,i<k$，从$f_{i,l}$ 向 $f_{k,j}$ 转移时，相当于 $[i+1,k]$ 全部都在第 $j$ 个区间。

相当于有 $cnt=k-i$ 个无差别的东西，要把它们分到 $len_j$ 个盒子里，可以有盒子为空，求方案数。根据插板法强制每个盒子本来就有一个东西即可，所以这部分的系数是 $\binom{len_j+cnt-1}{len_j-1}$。因为 $cnt$ 只有 $n$ 级别，所以直接暴力组合数即可。

这样就得到了一个 $O(n^5)$ 的做法，不过我 $O(n^4)$ 只跑了 15ms，所以估计也能过。然后考虑有两个地方可以优化，一个是组合数里的计算可以放到和 $k$ 的枚举一起，一个是 $\sum_{l>k}f_{i,l}$ 可以用一个后缀和，所以实际上复杂度可以降到 $O(n^3)$。但是我懒，所以组合数单独写了。

https://codeforces.com/contest/1295/submission/172110006