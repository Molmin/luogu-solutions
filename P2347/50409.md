### 这道题可以用大bitset来解决的，STL大法好

首先我们先从这道题来入手：

我们可以开心的发现这道题的转移方程很好写，我们枚举重量，然后再枚举每个物体，如果当前重量** f[i]** 可以被枚举出来，那么**f[i+w[i]]**也可以被枚举出来对吧。
好的那么一个n方dp 写完了，我们考虑一下优化

**bitset**

我们可以理解为这是一个类似于bool数组的东西，
却可以进行和二进制一样的操作，每一位只有0或1，但是，bitset却**自带1/32的超小常数**，简直就是卡常神器啊。

（关于bitset的各种基本操作请自行百度）

我们考虑一个bitset，假设6位，000101 那么表示第三个与第一个重量可以被枚举出，简而言之，我们用0代表当前重量无法被搞出，1代表可以被搞出，那么当我们有一个新的重量，（假设为2），那么(tqy是我开的bitset)   

**tqy|=(tqy<<w[i])**  

这个东西是不是就是江000101先左移2位，即表示我们当前重量加上2的重量是可以被搞到的，然后   |  ，就可以更新答案了，那么我们最后统计一下bitset变量中的1的个数就是我们可以枚举到的数的个数了
```cpp
#include<bits/stdc++.h>
#define rep(i,a,b) for(int (i)=(a);(i)<=(b);(i)++)
using namespace std;
bitset<10000> tqy;
int a[100000],w[8]={0,1,2,3,5,10,20,0};
int main(){
	rep(i,1,6) scanf("%d",&a[i]);
	tqy[0]=1; 	
	rep(i,1,6) rep(j,1,a[i]) tqy|=(tqy<<w[i]);
	cout<<"Total="<<tqy.count()-1<<endl;
	return 0;
}

```
bitset还是一种很强大的STL了，其超小常数一直被卡常专家所喜欢，而且bitset可以爆破掉不少题或是暴力分，而且代码比较短，建议入手

