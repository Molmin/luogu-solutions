很显然，这是一道01背包求方案数

有的人用多重背包，有的直接暴力过，个人认为01简单快捷而且更加好些，具体思路如下：

### 1.把题目转换成01背包，把每次进来的物品个数一个个的拆分为单个物品存放在c数组内

### 2.将c数组进行01背包求方案数的方法求解，求解方法如下：

## 设f[i][j]为体积为i的方案总和

### 那么，当第i件物品不选时，f[i][j]=f[i-1][j]
那么如果选择了呢，f[i][j]=f[i-c[i]];

### 那么两者累加，就是f[i][j]=f[i-1][j]+f[i-c[i]]
#### 为了减少空间浪费，去掉第一维，可以得到：

## f[i]=f[i]+f[i-c[i]],也就是f[i]+=f[i-c[i]]

##### 其余做法和01背包大致相同：

#### 代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
int f[10000000]={};
int c[10000000]={};
int main()
{
	int n=0;
	int num[10]={0,1,2,3,5,10,20};//先将砝码大小进行预处理
	for (int i=1;i<=6;i++)
	{
		int k;
		cin>>k;
		for (int j=1;j<=k;j++) 
		    c[++n]=num[i];
	}//转换01背包
	f[0]=1;
	int sum=0,ans=0;
	for (int i=1;i<=n;i++)
	    sum+=c[i];//求出01背包体积最大值
	for (int i=1;i<=n;i++)
	    for (int j=sum;j>=c[i];j--)
	        f[j]+=f[j-c[i]];//DP
	for (int i=1;i<=sum;i++)
	    if (f[i]) ans++;//累加所有可能出现的方案总和
	cout<<"Total="<<ans;
	return 0;
}
```