蒟蒻学习DP中……一连$A$了十几道$DP$~~水~~题

昨晚这题后，真的有一点感慨、、、（感慨其实太深了）

- 这道题目，让你求一共有多少种称出物品的克数，还告诉你【总克数不大于$10^3$】，一看就肯定是一个打标记然后计数输出的题。

- 然后一看标签，啊，$dp$。所以立即想到的就是建立一个$dp$数组，用来存放第$i$种克数的情况是否成立。

- 接着就开始想~~那个鬼畜的方程~~。

> $dp[0]$肯定要打上标记，因为什么都不取就可以了。

> 那么，如果$dp[i]$个成立，就意味着$dp[i$+一个合法的克数$]$必定也成立。

> 所以，遍历六种砝码的只数，然后从可以形成的**最大克数**往$0$遍历，碰到$dp[i]$合法的，就将$dp[i$+一个合法的克数$]$标记成合法。

> 最后遍历**1到最大值**（注意，是1，因为题目中已经明确写了$0$不算）输出。

上代码
```
#include <bits/stdc++.h>
using namespace std;
bool dp[1005];//第i克的情况是否成立
int a[7];//六种砝码的个数
int ans;
int b[7]={0,1,2,3,5,10,20};//为方便节省时间，减少判断次数，直接预存处理
int mx;
int main()
{
	dp[0]=true;//必须标记！！！
	for(int i=1;i<=6;i++)
	{
		cin>>a[i];
		mx+=a[i]*b[i];//mx表示最大称重克数
	}
	for(int i=1;i<=6;i++)
		for(int j=1;j<=a[i];j++)//第i种砝码有a[i]个
			for(int k=mx;k>=0;k--)
				if(dp[k]==true)
					dp[k+b[i]]=true;//标记
	for(int i=1;i<=mx;i++)
		if(dp[mx])
			ans++;//计数
	cout<<"Total="<<ans<<endl;//输出
    return 0;
}
```
这份代码$92$分。当然，我是不会告诉你，漏洞在哪里的。如果你找到了漏洞，我就借机吐槽一下：

## ~~LG的数据太水了~~

漏洞：`if(dp[mx])`->`if(dp[i])`