说白了就是多重背包（裸题）

我们记录一个n数组表示所带有的数目，记录一个w数组表示所带有的重量（预处理比较方便）

题目中总重不超过1000，这就是解题的关键了说明我们可以大胆开数组，而且2维也是可以过的

当然我用的是1维数组。。。。

详细解释见代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int f[1000006],n[10],w[10]={0,1,2,3,5,10,20,0,0,0},maxn,ans=0;//预处理 
int main(){
    memset(f,0,sizeof(0));
    scanf("%d%d%d%d%d%d",&n[1],&n[2],&n[3],&n[4],&n[5],&n[6]);
    maxn=n[1]*w[1]+n[2]*w[2]+n[3]*w[3]+n[4]*w[4]+n[5]*w[5]+n[6]*w[6];//找到你要多重背包的一个边界 
    f[0]=1;
    for(int i=1;i<=6;i++){//6个背包 
        for(int j=1;j<=n[i];j++){//每个背包n个东西 
            for(int k=maxn;k>=w[i];k--){//直接循环大法（从最远找回到最近）动态规划问题 
                if(f[k])continue;//这一步是为了ans的++才这样的 
                if(f[k-w[i]]){//当然，如果你的ans写在外面也是可以的，那么上面那句就可以删掉了 
                    f[k]=1;
                    ans++;
                }
            }
        }
    }
    /*for(int i=1;i<=maxn;i++)if(f[i])ans++;*/
    //就可以考虑用这一步来解决问题。 当然一边做一边处理我觉得比较好啦 
    printf("Total=%d\n",ans);
    return 0;
}
```