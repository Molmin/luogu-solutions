# CF1832C 题解

## 原题链接
[**Codeforces**](https://codeforces.com/contest/1832/problem/C)

[**洛谷**](https://www.luogu.com.cn/problem/CF1832C)

## 题目大意
有 $T$ 组测试样例，每组样例给你一个长度为 $n$ 的 $a$ 数列，让你求出与 $a$ 数组权值相同的 $b$ 数组的最小长度。

**权值定义：**

我们把 $ [a_1, a_2, \dots, a_n] $ 定义为 $a$ 数组的权值，他的权值就等于 $ |a_1-a_2|+|a_2-a_3|+\cdots+|a_{n-1}-a_n| $。

例：

$ [ 1 , 5 , 3 , 8 , 6 ] = |1 - 5| + |5 - 3| + |3 - 8| + |8 - 6| = 4 + 2 + 5 + 2 = 13$。

## 思路分析
一看数据范围就知道是一道 $ O (Tn) $ 的题。

只要保证某一个序列具有**单调性**（即单调递增、单调递减、单调不增、单调不减四种情况），其间的数就可以相互抵消。比如说我们假设 $ [a_1, a_2, \dots, a_n] $ 这个数列具有单调性，那么它的权值就等于 $a_1+a_n$，这个答案也就是 $ [a_1,a_n] $ 的权值的答案，长度自然就可以缩小。因为本条性质只针对于有单调性的数列，所以我们可以把原数列拆分为 $m$ 个具有单调性的数列，那么答案就是 $m + 1$（因为 $m$ 代表的是有几组，而我们要求的 $b$ 数组的最小长度则是点的个数，所以要 $+ 1$。这和小学的种树问题有点类似）。

最后：**多测不清空，爆零两行泪**（不过本题好像不需要清空，因为可以不用数组，但是为了保险起见还是加上）。

## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[300005];//本题可以不用定义数组，只需要定义一个now记录上一个数就行了
signed main(){
	int T;
	cin>>T;
	while(T--){
		//memset(a,0,sizeof(a));
		int n;
		cin>>n;
		int m=0;//有几个单调性的数列
		int f=-1;//判断目前的数列是增还是减，0为减，1为增，刚开始什么数列也不是 
		cin>>a[1];//第一个数无法形成数列，所以我们提前读入 
		for(int i=2;i<=n;i++){
			cin>>a[i];
			if(a[i]>a[i-1]){
				if(f!=1)m++;//已经无法保证单调性，因为f刚开始为-1，所以我们要用!=1 
				f=1;//把f改变为增 
			}
			if(a[i]<a[i-1]){
				if(f!=0)m++;//同上 
				f=0;//把f改变为减 
			}
			//因为=可以化作为1个数，所以我们不用考虑 
		}
		cout<<m+1<<endl;//点数=间隔的数量（组数）+1 
	}
	return 0;
} 
```

无注释版的在[**这里**](https://www.luogu.com.cn/paste/ks46u22a)。

## AC 记录
[**Codeforces**](https://codeforces.com/contest/1832/submission/207418165)

[**洛谷**](https://www.luogu.com.cn/record/111344150)

**THE END.**

**THANK YOU.**