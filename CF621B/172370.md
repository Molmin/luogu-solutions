# 第一步 读题

>有一个 $1000\times1000$ 的棋盘，上面有 $n(1\le n\le 200000)$ 个象，每个象的位置为$\left(x_i,y_i\right)$。 
**注意，这里的规定与国际象棋的不同。我们认为，只要两个象在同一对角线，就能够相互攻击到（中间有象也没有关系）。** 求互相攻击的象的对数。

首先看题，是让我们求出有多少组象能互相攻击到。**注意：这里的象和国际象棋的不一样，他可以跨过某一个或一些象来攻击其他象。** 这可是一个大坑啊！注意审题（多看几遍）。

# 第二步 思路

思路一：暴力模拟两个象是否相互攻击，如果相互攻击就累加，最后输出答案。时间复杂度 $O\left(n^2\right)$，但是我们发现 $1 \le n \le 2 \times 10 ^ 5$，这个开到 $n^2$ 明显爆炸了。。所以我们要优化。

------

思路二：我们可以来枚举对角线。我们可以计算每个位置的横坐标与纵坐标的和。以 $3$ 行 $3$ 列来找规律：

|  | $1$ | $2$ | $3$ |
| :----------: | :----------: | :----------: | :----------: |
| $1$ | $1+1=2$ | $1+2=3$ | $1+3=4$ |
| $2$ | $2+1=3$ | $2+2=4$ | $2+3=5$ |
| $3$ | $3+1=4$ | $3+2=5$ | $3+3=6$ |

我们发现，每个右上到左下的斜线上的数值都相等。那么我们就可以判断每一个右上到左下的斜线，从而找到每一个右上到左下的斜线上有多少对象能够互相攻击。

我们再看每一个位置的横坐标与纵坐标的差（由于有可能为负，所以我们都加上一个数值。这个数值一定要大于原本减完可能出现的数值，用来保存负数。由于我们以三行三列来找规律，所以我们统一加上4。）

|  | $1$ | $2$ | $3$ |
| :-----------: | :-----------: | :-----------: | :-----------: |
| $1$ | $1-1+4=4$ | $1-2+4=3$ | $1-3+4=2$ |
| $2$ | $2-1+4=5$ | $2-2+4=4$ | $2-3+4=3$ |
| $3$ | $3-1+4=6$ | $3-2+4=5$ | $3-3+4=4$ |

我们发现，每个左上到右下的斜线上的数值都相等，那么我们也可以判断每个左上到右下的斜线，最后找到这条斜线上有多少象可以互相攻击。

找到规律后，我们要知道如何来寻找有多少个象可以互相攻击。

| 斜线上象的数量 | 攻击组数 |
| :-----------: | :-----------: |
| $1$ | $0$ |
| $2$ | $1$ |
| $3$ | $3$ |
| $n$ | $1+2+...+\left(n-1\right)=\frac{n\left(n-1\right)}{2}$ |

这样，我们就有了这道题的核心思路。

# 第三步 代码
代码内有讲解，请慢慢食用。
```cpp
#include<bits/stdc++.h>//愉快的万能头
using namespace std;
inline int read(){//快读板子
	int ans=0,flag=1;
	char ch=getchar();
	while((ch>'9'||ch<'0')&&ch!='-') ch=getchar();
	if(ch=='-') flag=-1,ch=getchar();
	while(ch>='0'&&ch<='9'){
		ans=(ans<<1)+(ans<<3)+(ch^'0');
		ch=getchar();
	}
	return ans*flag;
}
int n,x,y;//读入需要的数据
int a[2005],b[2005];//分别表示两个对角线
long long ans;//表示答案，出题人很坑要开long long
int main(){
	n=read();//读入n
	for(int i=1;i<=n;i++){//循环模式
		x=read(),y=read();//先读入
		a[x+y]++;//右上到左下的斜线
		b[y-x+1001]++;//左上到右下的斜线，由于是1000*1000的棋盘，所以加上1001（你愿意多加就多加，但是数组别忘了开大）
	}
	for(int i=0;i<=2000;i++)//1000*1000的棋盘，两个1000加起来是2000。
		ans+=(long long)(a[i]*(a[i]-1)+b[i]*(b[i]-1))/2;//这里是同时判断，直接加上这个数的左上到右下、右上到左下的和。（运用乘法分配律），这里要强转一下
	printf("%lld\n",ans);//最后输出
	return 0;//return 233;
}
```
# 第四步 宣传

如果有帮助，请点个赞，谢谢！（撰文不易，`dalao`勿喷！）如果发现我的讲解有`bug`，请及时指出，感谢！


