这道题先看到数据范围，可以发现，枚举 $O(N^2)$ 是会超时的，应该考虑 $O(N)$ 算法。

可以考虑枚举斜线编号进行统计同一斜线上的所有象数量。

那怎么得到斜线编号呢？可以进行找规律。

---
1. 左上到右下的斜线

随便找一个点，例如 $(2,3)$ 在从左上到右下的第 $4$ 条斜线。

再找一个，例如 $(1,2)$ 在第 $3$ 条。

可以得出结论，$(x,y)$ 在第 $x+y-1$ 条斜线上。

2. 右上到左下的斜线

再随便找一个点，例如 $(1,1000)$ 在 $1$ 条斜线上。

再比如 $(2,999)$ 在第 $3$ 条斜线上。

可以得出结论，$(x,y)$ 在第 $y-x+1000$ 条直线上。

---
最后想一想答案最大的情况，应该是会超出 `int` 的范围的，故使用 `long long`。

---
代码部分
```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
int n, x[200005], y[200005], a[2005], b[2005], ans;
signed main() {
    cin >> n;
    while(n--) {
        cin >> x[n] >> y[n];
        ++a[x[n] + y[n] - 1];
        ++b[y[n] - x[n] + 1000];
    }
    for(int i = 1; i <= 2000; ++i) {
        ans += (a[i] * (a[i] - 1) + b[i] * (b[i] - 1)) / 2;
    }
    cout << ans << endl;
    return 0;
}
```