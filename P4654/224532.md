首先可以把陷阱所在的房间设为根节点，这样方便计算。

设老鼠现在在 $x$ 点，则老鼠的移动可以分两种情况考虑：

- 向 $x$ 的子树移动
- 向 $x$ 的父节点移动

先考虑第一种情况，向子树移动，考虑使用动态规划，设 $f_i$ 表示从 $i$ 点老鼠走向其子树后又被管理员逼回到了 $i$ 点的最少操作数。

这样设计状态是因为可以发现，老鼠从 $i$ 点一直往下走最终会到叶子节点，并且往上走的路都被它自己来的时候弄脏了，它就被堵在了叶子节点上。此时把它走到叶子节点的这条路径上的其它的分支都堵死，再把路径上的边都擦干净，这样老鼠就会沿着来时的路径回到 $i$ 点。

考虑状态转移，设老鼠现在在 $i$ 点。因为管理员和老鼠都使用最优策略，而老鼠希望管理员的操作数尽量多，那么老鼠肯定会向 $i$ 的儿子中，$f$ 值，即动态规划值最大的子节点移动，因为这样可以使管理员花费最多的操作数再回到 $i$。管理员则希望操作步数尽量少，所以他的最优策略是将连向动态规划值最大的子节点的边堵住，那么老鼠会向动态规划值第二大的子节点移动。这样，就得到了状态转移方程：
$$f_i=\mathrm{2ndmax}_{\text{j是i的子节点}}\{f_j\}+s_i$$

这里的 $s_i$ 表示 $i$ 点有多少个子节点，$\mathrm{2ndmax}$ 表示取第二大。$+s_i$ 其实是 $+s_i-1+1$ 化简之后的结果。$+s_i-1$ 是因为这是从 $i$ 的一个子节点走上来的，那条边已经被弄脏，相当于被堵上了，所以只用堵上 $i$ 向其它子节点的连边就可以了。再 $+1$ 是因为从 $i$ 走到这个子节点时已经使这条边弄脏，现在又被堵回到这个子节点要再回到 $i$ 点需要擦干净这条边，有一次操作。

那么解决了从 $i$ 点向下走的情况，来看向上走的情况，如图：
![](https://cdn.luogu.com.cn/upload/image_hosting/wr8sqd77.png)
$t$ 点就是陷阱所在的点。老鼠可以先向父节点走一段距离，再向下走。这种情况很难处理，因为无法确定老鼠在向父节点移动多少步后向下可以使老鼠最优。

考虑到答案具有单调性，可以二分答案操作步数。

在二分中，每次判断是否老鼠无论从起始点 $M$ 向上走多少步都能在现在二分到的操作步数内堵到陷阱点。因为管理员无论如何都不能堵住向父节点走的边，否则就相当于直接让老鼠根本走不到作为根节点的陷阱点。具体看代码。

------------
### 代码
###### 代码里有注释
```cpp


#include <cstdio>
#include <cstring>

using namespace std;

int N;
int T;
int M;
int h[1000009];
int nxt[2000009];
int to[2000009];
int idx;
int dp[1000009];
int sum[1000009]; //在二分中有用到，表示将老鼠从当前点逼到根节点即陷阱点需要到少步操作
int fa[1000009];
bool st[1000009]; //也是在二分中用到，起始点的所有祖先节点st值为true
int res;

inline void Add (int a, int b) {
    nxt[idx] = h[a], to[idx] = b, h[a] = idx++;
}

void In () {
    int a;
    int b;
    
    memset(h, -1, sizeof(h));
    scanf("%d%d%d", &N, &T, &M);
    for (int i = 1; i < N; i++) {
        scanf("%d%d", &a, &b);
        Add(a, b), Add(b, a);
    }
}

void Get_Dp (int x, int p) { //求出每个点的动态规划值，dp就是前面的f
    int v;
    int mx1 = 0; //最大值
    int mx2 = 0; //次大值
    int siz = 0; //子节点数量

    fa[x] = p;
    for (int e = h[x]; ~e; e = nxt[e]) {
        v = to[e];
        if (v == p) continue;
        siz++;
    }
    if (x != T) sum[x] = sum[p] + siz - 1 + (x == M);
/*求sum值时因为把老鼠从当前点逼到根节点可以从父结点的值递推而来，就相
当于从当前点逼到父节点再从父节点逼到根节点。如果当前点不是起始点，那
么肯定是从它的某个子节点上来的，则那条连边已经被弄脏，不用再堵。但如
果它是起始点，那么就不是从哪个子节点来的，需要把所有子节点都堵上。*/
    for (int e = h[x]; ~e; e = nxt[e]) {
        v = to[e];
        if (v == p) continue;
        Get_Dp(v, x);
        if (mx1 < dp[v]) mx2 = mx1, mx1 = dp[v];
        else if (mx2 < dp[v]) mx2 = dp[v];
    }
    dp[x] = mx2 + siz;
}

bool Chk (int x) {
    int v;
    int cc = 1;
    int vv; //不要在意奇怪的命名。。

/*
这里的 cc 是因为老鼠再往上走时不会停下来，要堵就必须老鼠边走管理员边
堵，但如果老鼠现在在的节点上，向两个不同的子节点走都不能使管理员在x步
内把老鼠逼回来，且管理员不能一次操作堵两条边，那么就不能使老鼠在x步内
被逼回。(管理员堵其中一条边，老鼠就走另一条边，总会使步数超过x步)。

但如果在现在的节点上老鼠无论走哪个子节点都无法使步数超过x步，那么管理
员就可以在这时候将父节点或祖先节点的某个无法在x步内将老鼠逼回的边提前
堵上。
*/

    for (int i = M; i != T; i = fa[i]) {
        vv = 0;
        for (int e = h[i]; ~e; e = nxt[e]) {
            v = to[e];
            if (st[v] || dp[v] + sum[i] <= x) continue; //如果在当前这个点上向子节点走需要的步数不大于二分到的步数x，或者它刚刚从这个子节点移动上来，都不用管
            if (!cc) return false;
            cc--, vv++;
        }
        x -= vv, cc++;
    }
    return x >= 0;
}

void Solve () {
    int l;
    int r;
    int mid;

    Get_Dp(T, 0);
    for (int i = M; i; i = fa[i]) st[i] = true;
    l = 0, r = 2 * N;
    while (l <= r) {
        mid = l + r >> 1;
        if (Chk(mid)) res = mid, r = mid - 1;
        else l = mid + 1;
    }
}

void Out () {
    printf("%d\n", res);
}

int main () {

    In();
    Solve();
    Out();

    return 0;
}
```