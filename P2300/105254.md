没人讲我就解释下这题用到的结论的证明

这题的结论和 [CSP-S 2019 划分](https://www.luogu.com.cn/problem/P5665) 的结论其实很类似，不如说这里的结论其实是 划分 结论推导过程中的一个引理

另外关于 划分 的证明也可看看我的 [博客](https://www.luogu.com.cn/blog/105254/solution-p5665) qwq

## 解析

### 引出

首先可以发现，最终划分的每一段都会提供 长度减一 的贡献，因此最优的方案一定要**尽可能多**地分段

### 结论及证明

将一个解 $S$ 的**倒数**第 $j$ 段的开始位置不严谨地表示为 $l_j\in S$

首先我们考虑这样的一个解 $S$。它与任意不同的解 $S'$ 之间，一定满足其中一条：

1. $S'$ 不存在倒数第 $j$ 段，但 $S$ 存在
2. $l_j\in S'\leq l_j\in S$

分别记为 $1.$，$2.$

&nbsp;

这样的 $S$ 应当是存在的，证明：

1. 如果 $S$ 的倒数第 $j$ 段存在

这里采用类似归纳法的方式证明

首先如果仅考虑 $j=1$，显然能找到这样一个 $S$

我们假设有一个 $S'$，它的 $l_2\in S'> l_2\in S$，那么图画出来就是这样的：

![S](https://cdn.luogu.com.cn/upload/image_hosting/7zzjuogm.png)

由于解还需满足从左到右**段和不增**，推一下就能发现 $l_2\in S$ 还能再往右一些，因此假设不成立

对于更大的 $j$，我们也都能用类似的方法反证证明

2. 如果 $S$ 的倒数第 $j$ 段不存在

我们要说明这实际上是不可能的

假设 $S$ 的倒数第 $j$ 段不存在，而有另一个 $S'$ 存在倒数第 $j$ 段

首先做出 $S'$ 的 $l_j\in S'$、$S'$ 的 $l_{j-1}\in S'$ 以及 $S$ 的 $l_{j-1}\in S$ 的在序列上的位置

![SS](https://cdn.luogu.com.cn/upload/image_hosting/kk1a50p2.png)

由于 $<a_i>$ 均非负，推一下就能发现，若 $[l_j\in S', l_{j-1}\in S'-1], [l_{j-1}\in S', l_{j-2}\in S'-1]$ 这两个相邻的分段成立，那么 $[l_j\in S', l_{j-1}\in S-1], [l_{j-1}\in S, l_{j-2}\in S-1]$ 这两个相邻的分段也是成立的

于是只要保持 $S$ 的 $l_k, 1\leq k\leq j-1$ 的分段不变，剩下的全盘 “复制” $S'$ 的分段，我们就能获得任一个满足 $2.$ 的 $S$，且 $S$ 存在第 $j$ 段。于是假设显然不成立

&nbsp;

于是 $S$ 是一定存在的

同时，$S$ 的 $1.$ 实际上就表明了它是所有解中分段最多的解

### 算法及证明

我们先形式化地说明下算法的流程：

设 $f(i)$ 表示对 $[0, i]$ 划分，使得划分最后一段左端点（区间左右均闭）最大的划分方案；再设 $l_i$ 表示 $f(i)$ 最后一段的左端点的下标

有 $l_i=\max\limits_{j: \sum\limits_{k=j+1}^ia_k\geq \sum\limits_{k=l_j}^ja_k} (j+1)$

我们指出，该算法计算出的 $f(i)$ 一定是符合其定义的

&nbsp;

为了说明算法的正确性，我们需要证明每次对 $l_i$ 的计算是始终后效性最优的

设算法第一次产生后效性是在计算 $f(i)$ 后。我们发现，算法产生后效性只可能是 $f(i)$ 在可能转移时无法转移；而要令 $f(i)$ 能被转移，就要使 $\sum\limits_{k=l_i}^ia_k$ 尽可能地小。对于 $f(j), j<i$，它们都不会对计算 $f(i)$ 产生后效性（因为第一次产生后效性是在计算 $f(i)$ 时）；而 $f(i)$ 的定义就是使对 $[0, i]$ 划分的最后一段的左端点的下标尽可能地大，也就是使最后一段的和尽可能的小。因此，不可能会有比 $f(i)$ 更优的方案，$f(i)$ 也一定不会产生后效性

&nbsp;

接着我们指出，$f(n-1)$ 的方案实际上就是上一节我们提到的划分最多的解 $S$

首先考虑 $f(n-1)$ 的方案的最后一段。按 $f$ 的定义，它一定是满足 结论 $1$ 的

再考虑 $f(n-1)$ 的方案的倒数第二段。注意到，它实际上就是 $f(n-2)$ 的最后一段，按 $f$ 的定义，这一定倒数第二段端点最右的方案，它也满足 结论 $1$（实际上这是：在倒数第一段端点最右的前提下，倒数第二段端点最右的方案。然而这涉及的问题实际上仅仅是 $S$ 的存在性，这在之前我们已经证过了）

于是如此类推，可以得出 $f(n-1)$ 的方案的每一段都是满足要求的，因此 $f(n-1)$ 的方案就是划分最多的解 $S$

### 单调队列部分

有了这个结论就好做了

记 $s(i)=\sum\limits_{k=0}^i a_i$。并不严谨地设 $f(i)$ 的值为其方案的最后一段的段和

首先上面的 dp 式子是满足四边形不等式的，这个随便推一下就行

（下面可能有些我自己口胡的词缀X。另外关于 dp 优化，小小地 [广告](https://www.luogu.com.cn/blog/105254/bu-fen-lei-xing-dp-you-hua-yang-xie) 一下）

于是 $w(i, j)$ 是最优性单调的（函数的极值（在一定范围内）随 $i, j$ 单调递增/递减）

接着发现它的 $w(i, j)$ 函数形式和滑动窗口 dp 是一样的。具体来说，$w(i, j)=j\cdot[f(j)\leq s(i)-s(j-1)]$，其中 $[P]$ 在表达式 $P$ 成立时取 $1$，否则取 $0$（$w(i, j)$ 也可以有其它略微不同的定义，不过就分析而言是一样的）

于是直接套用滑动窗口 dp 的单调队列模式维护即可。更具体的实现可以看代码

## CODE

```cpp
#include <cstdio>
#define ll long long
#define ull unsigned ll

const int MAXN =2e5+50;

/*------------------------------单调队列------------------------------*/

int id[MAXN];/*id[.] =j 表示该状态来自 f(j)*/
int head, tail;

/*------------------------------Main------------------------------*/

inline int read(){
	int x =0; char c =getchar();
	while(c < '0' || c > '9') c =getchar();
	while(c >= '0' && c <= '9') x = (x<<3) + (x<<1) + (48^c), c =getchar();
	return x;
}

int l[MAXN];/*最后一段左端点*/
ll sum[MAXN], slast[MAXN]/*最后一段的和*/;

int main(){
	int n =read();
	for(int i =1; i <= n; ++i)
		sum[i] =read()+sum[i-1];
	id[head] =0;
	tail =1;
	for(int i =1; i <= n; ++i){
		while(head+1 < tail && slast[id[head+1]] <= sum[i]-sum[id[head+1]])
			++head;
		l[i] =id[head]+1;
		slast[i] =sum[i]-sum[id[head]];
		while(head < tail && slast[id[tail-1]]+sum[id[tail-1]] >= slast[i]+sum[i])
			--tail;
		id[tail++] =i;
	}
	int ans =0;
	for(int r =n; r; r =l[r]-1)
		ans +=r-l[r];
	printf("%d", ans);
}
```