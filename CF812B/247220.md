## 本题使用深度优先搜索即可。

### 题外话：

AC 后看到很多人使用了 DP ，但对于这一题来说**完全没有必要**，不仅增加了时间复杂度还更难去想。

### 思路：

对于 DFS 大家第一时间肯定会想到按照每一个房间，枚举向左房间或者向右房间遍历，遇到梯子就上去，但是这样的复杂度完全过不了。所以我们考虑**枚举每一层**。对于每一层，我们有两种选择，一是选择关闭本层的所有的灯然后**回到原来的楼梯**，二是关闭本层的所有灯再**到对面的楼梯**。然后再花 $1$ 的单位上楼。但是对于这两种不同的情况，还需要再分类讨论起始位置：**人在左边楼梯还是在右边楼梯**。

### 细节

此题着重考察细节，因此，会有很多实现细节需要注意。

- 对于每次关掉一层的灯，其实求的就是关掉最左边（右边）花费的路程（至于左边还是右边取决于你所在的楼梯位置）。所以需要在输入的时候**统计每一层的最左边和最右边的灯的位置**。

- 枚举每种情况：

	- 如果处于左边楼梯并回来，**花费就等于** $2\times$ **最右边的楼梯位置** $+1$ 。
   - 如果处于左边楼梯直接到右边楼梯，**花费就等于** $m+1$ 。
   
   - 如果处于右边楼梯并回来，**花费就等于** $2\times m-$  **最左边的楼梯位置** $+1$ 。
   - 如果处于右边楼梯直接到左边楼梯，**花费就等于** $m+1$ 。
   
   - 别忘了 $+1 $ ，也就是**上楼花费的时间**。
   
- 最后考虑边界，在输入的时候**统计最上层的灯在第几层**，如果没有统计到灯，直接输出 $0$ 即可。对于统计出来的最高层灯，我们**只需要关到最高层**，无需再上楼了，这时候就可以直接统计最小值。

- 还有一种特殊的情况是某层（**但不是最高层**）没有灯需要关，**直接花费** $ 1 $ **单位上楼即可**。
   

## code：


```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
inline int read(){
   int s=0,w=1;
   char ch=getchar();
   while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
   while(ch>='0'&&ch<='9') s=s*10+ch-'0',ch=getchar();
   return s*w;
}
struct node{
	int l,r;
};
bool a[205][205];
node lt[25];//统计每层最左（右）的楼梯。
int n,m,h=-1,ans=1e9+10;
void dfs(int flr,int stp,bool k){
	if(flr==h){//到达需要关灯的最高层。
		if(k==0) stp+=lt[flr].r;
		ans=min(ans,stp);
		return;
	}
	else if(lt[flr].l==-1&&lt[flr].r==-1){//本层没有灯需要关。
		dfs(flr-1,stp+1,k);
		return;
	} 
	else if(k==0){//人在左边楼梯。
		dfs(flr-1,stp+(2*lt[flr].r)+1,0);
		dfs(flr-1,stp+m+1,1);
	} 
	else if(k==1){//人在右边楼梯。
		dfs(flr-1,stp+(2*(m-lt[flr].l))+1,1);
		dfs(flr-1,stp+m+1,0);
	} 
}
int main(){
	n=read(),m=read();
	m++;
	for(int i=1;i<=20;i++) lt[i].l=lt[i].r=-1;
	for(int i=1;i<=n;i++){
		for(int j=0;j<=m;j++){
			char c;
			cin>>c;
			a[i][j]=c-'0';
		}
		for(int j=0;j<=m;j++){//统计每层最左（右）的楼梯。
			int k=m-j;
			if(a[i][j]&&lt[i].l==-1) lt[i].l=j;
			if(a[i][k]&&lt[i].r==-1) lt[i].r=k;
			if(lt[i].l!=-1&&lt[i].r!=-1) break;
		}
		if(h==-1&&(lt[i].l!=-1||lt[i].r!=-1)) h=i;//统计最高层需要关的灯。
	}
	if(h==-1){
		cout<<0;
		return 0;
	} 
	dfs(n,0,0);//初始位置为 n ，步数为 0 ，在左边。
	cout<<ans;
    return 0;
}
```
