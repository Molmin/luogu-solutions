貌似是至今这道题题解中模拟做法最短的
```cpp
#include <bits/stdc++.h>
using namespace std;

int main()
{
	int a, b;
	cin >> a >> b;

	int cnt = a;//初始a根
	while (a / b != 0)//当还可以继续拼成整的蜡烛时
	{
		cnt += a / b;//拼来的蜡烛烧掉
		a = a / b + a % b;//上次拼掉的蜡烛烧完的 加上 上上次拼接时剩下的
	}
	cout << cnt << endl;
}
```

 #### 公式 ans=a+(a-1)/(b-1) 的解释：  
因为 b根残烛 <=> 一根蜡烛 <=> 一小时照明 + 一根残烛  
所以 b-1根残烛 <=> 一小时照明  

现在有a根蜡烛，把他们烧完，成了a根残烛。当然，最好的情况是，最后所有的残烛恰好换到了一根整蜡烛，这根整蜡烛换来一小时照明，得到一根残烛。  
对比初始情况和结束情况，损失了$(a-1)$根残烛，由上面的等价公式，可以换来$ (a-1) / (b-1)$个小时照明。 
其实，这里 / 号是整除，即$a-1=k(b-1)$ $\qquad$ $k$为正数 
  
  
接下来证明，当最后剩下t根残烛，并且这些残烛不够换成整蜡烛时，照明时间和上面最优情况是相等的  
  
因为最后t根残烛不够换，所以有   
$\qquad$ $1<t<b$  
事实上，因为最后剩$ t $根残烛，所以有：  
$\qquad$ $a-t=r(b-1)$ $\qquad$ ($r$为实际的答案)  $\qquad$ $(*)$式  
另外，如果令$k(b-1)<=a-t<(k+1)(b-1)$  $\qquad$ $(**)$式  
那么 $k$即为$(a-1) / (b-1)$的结果。  

下证$k=r$  
若将$(*)$式加到$(**)$式，消去$t$则有  
$\qquad$ $1+r(b-1)<a<b+r(b-1)$  
$\qquad$ $r(b-1)<a-1<(r+1)(b-1)$  
与$(**)$式对比，$r=k$  
得证

