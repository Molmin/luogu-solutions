## 题意
有 $n$ 座公寓，有 $k$ 座公寓已经被售出让你求相邻公寓中有已售出公寓的待售公寓的最大值和最小值。
## 思路
#### 最小值
由于求的是相邻公寓中有已售出公寓的待售公寓的最小值，所以我们就得让待售公寓相邻的公寓中尽量没有已售出公寓，换句话说，也就是让已售出公寓尽量与待售公寓不相邻。

那我们的策略就是让每一座已售出公寓相邻，把待售公寓的位置占掉，然后让第一个或最后一个在一端。

这样最小值永远为 $1$，只有挨着最后面或最前面的那一栋待售公寓适合居住。

举个栗子，当输入为：
```cpp
8 3
```
这时公寓的排列为
![](https://cdn.luogu.com.cn/upload/image_hosting/sv1kwdie.png)
我们只能选第四座公寓，所以答案为 $1$。
#### 最大值
我们要让可以选择的公寓最多，就得让已售公寓分开，这样每座已售公寓都能让它的价值最大，让每座已售公寓的两边都适合居住。

我们一共有 $k$ 座已售公寓，我们就有 $2\times k$ 座合适的待售公寓。
![](https://cdn.luogu.com.cn/upload/image_hosting/a07rnubt.png)

但是我们可以发现一座已售公寓加上两座待售公寓组成了一组，里面包含三座公寓。所以一共有 $3\times k$ 座公寓。

这时要注意 $3\times k<n$ 的情况，如果小于的话，说明除了已售公寓外其他的待售公寓都是适合的，答案就是剩下的代售公寓的数量，也就是 $n-k$。
### 注意
$n$ 和 $k$ 是有可能相等的，如果相等，就说明公寓都卖完了，最大值和最小值都是 $0$。

$k$ 可能等于 $0$，说明公寓一座也没有卖出去， 也就没有已售公寓，所以也没有合适的公寓。
## 代码
```cpp
#include<cstdio>
#include<iostream>
using namespace std;
int n, k;
int main() {
	scanf("%d%d", &n, &k);
	n == k || k == 0 ? printf("0 0") : printf("1 %d", min(2 * k, n - k));
	return 0;
}
```