D1,D2两题共一发题解写了。这俩代码巨像。

两题的本质都是**贪心**，D1问的是最大值，D2问的是最小值。约定：数值存储数组为$a$，黑白两子列当前最后一个元素的数值分别为$a[x],a[y]$。之所以这样存储是因为便于修改。显然我们不关心这个数值是从哪里取得的而关心这个数值本身是多少，因而可以考虑使用**这个数值对应于原数列的一个下标**来表示这个数值。当前待插入的元素为$a[i]$。$nxt[i]$即$next[i]$，代表数值$a[i]$下一次出现的地方，用链式前向星计算和维护。

先来考虑最大值的情况：

1.当$a[i]$与$a[x],a[y]$有相同数值。出于贪心原理，显然当前这个元素会尽可能地与数值不同的子列组合。因为如果放在另一边，当前步骤就会损失一个答案，对之后答案也不会起到什么积极的贡献——插入一个数至多只会增加1。

这样做的结果是**黑白子列最后一个元素的数值都相同了**——$a[i] \neq a[x]$时进入黑子列，黑子列最后一个元素变成$a[i]$，与$a[y]$相等；$a[i] \neq a[y]$同理。当两个都相同的时候更加是这样，不过这种情况下，对答案也没有贡献了。因而这个部分的代码可以被浓缩成这样：

```cpp
if (a[i] == a[x] || a[i] == a[y])//至少与一个相等
{
    ans += x!=y;//若x等于y则a[x]=a[y]。这种情况对应于黑白子列最后一个元素的数值都相同，ans不会增加。其余情况均会增加。
    x=y=i;//经过这个操作之后，数值变成相同的。
    continue;
}
```
2.$a[i]$与$a[x],a[y]$都不相等。这个情况是最头疼的情况。考虑一个贪心：如果$a[x]$的下一位元素$next[a[x]]$的位置比$a[y]$先，那么优先放入$a[x]$对应的黑子列中。因为，如果$a[x]$前面还有其他的数值，那么这样做与不这么做显然对答案贡献相同——它们均不会造成前面的$a[x]$与后面的$a[x]$合并；但是如果前面没有任何其他的元素，不这么做就会导致**前后的$a[x]$被合并**，答案损失1。因而，我们这么贪心是最优的。对应代码如下：

```cpp
ans++;//该数必然会造成一个贡献。
if (nxt[x] < nxt[y])//a[x]的下一个数更近，则往黑子列填
    x = i;
else
    y = i;
```
而最小值刚好就是反过来——尽可能地让前后合并。

因而，如果与黑子列的最后一个数值相等，则合并到黑子列去；与白子列最后元素相等则去白子列。

```cpp
if (a[i] == a[x])
{
    x = i;
    continue;
}
if (a[i] == a[y])
{
    y = i;
    continue;
}
```

都相等无所谓：随便找一个合并就行了。

如果都不相等，则又和前面相似——考虑后面对答案的影响了。最大值是尽可能地不合并，这里就是要尽可能地合并。因而，谁的$next$越近越可能合并，贪心证明同上。

```cpp
ans++;//必然要产生贡献了，但是尽可能让后面不产生贡献
if (nxt[x] < nxt[y])
    y = i;
else
    x = i;
```
剩下部分两个代码完全一样，就是链式前向星的基本操作了。