先读题。

这个题给出了一棵树，在这棵树里，乡村的点都没有儿子，而城市的点都有两个儿子。所以？

很据题意，可以设 $f_{i,j,k}$，表示从根节点走到序号为 $i$ 的点，通过了 $j$ 条向左走的未修的路（走向左儿子的路），以及 $k$ 条向右走的未修的路（走向右儿子的路）时，以 $i$ 为节点的子树的最小不便利值。


这个数组一开出来，就有浓厚的 $DP$ 气息了。
当 $i$ 是一个乡村时，显然能直接求出 $f_{i,j,k}=c_i(a_i+j)(b_i+k)$ 。而$i$是一个城市，则设 $l_i$ 为 $i$ 的左儿子，$r_i$ 为 $i$ 的右儿子。有两种情况：

1.修向左走的路。则有：

$f_{i,j,k}=f_{l_i,j,k}+f_{r_i,j,k+1}$

2.修向右走的路。则有：

$f_{i,j,k}=f_{l_i,j+1,k}+f_{r_i,j,k}$

两者取其 $min$ ，方能得解。

最后的答案？当然是 $f_{1,0,0}$ 了。

对于输入时乡村序号为负数的情况，采取$x=n-x-1$，使乡村的序号从 $-n$ 到 $-1$ 转化为从 $2n-1$ 到 $n$ ，这样就巧妙而简洁地化解了这一问题。

关于代码：我选用记忆化搜索，使自己不用大量思考循环的细节，空间能打擦边球通过，就懒得优化了~（但优化的方法是很值得学的，多学学其他题解）
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,l[20001],r[20001];
long long f[20001][41][41],a[20001],b[20001],c[20001];
long long dfs(int i,int j,int k)
{
	if(i>=n)return c[i-n+1]*(a[i-n+1]+j)*(b[i-n+1]+k);
	if(f[i][j][k]!=f[0][0][0])return f[i][j][k];//记忆化
	return f[i][j][k]=min(dfs(l[i],j,k)+dfs(r[i],j,k+1),dfs(l[i],j+1,k)+dfs(r[i],j,k));
}
int main()
{
	cin>>n;memset(f,63,sizeof(f));
	for(int i=1;i<n;i++)
	{
		cin>>l[i];
		if(l[i]<0)l[i]=n-l[i]-1;
		cin>>r[i];
		if(r[i]<0)r[i]=n-r[i]-1; 
	}
	for(int i=1;i<=n;i++)cin>>a[i]>>b[i]>>c[i];
	cout<<dfs(1,0,0);
	return 0;
}
```

UPD on 2022.2.8: 发现自己当年记忆化了个寂寞（已修改代码）
