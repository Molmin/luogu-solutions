## [传送门](https://www.luogu.com.cn/problem/AT_tkppc2016_c)

### 题意大概：
将一串有 $n$ 个 $0$ 或 $1$ 的数组中任意 $k$ 个 $0$ 改成 $1$ ，求出最长连续的 $1$ 串的长度。

### 思路：
由于求的是连续性子串长度，所以想到尺取。

先用前缀和累计 $0$ 的个数，每次让左指针前进一个数，再维护区间内 $0$ 个数始终为 $k$ 个，因为维护完的区间是符合题意的，所以比较取最大值。

### 代码：
```cpp
#include<iostream>
using namespace std;
int n,k,l,r=1,maxx;
int a[100003];
int main()
{
	cin>>n>>k;
	for(int i=1;i<=n;i++)
	{
		cin>>a[i];
		a[i]^=1;//将0改成1
		a[i]+=a[i-1];//前缀和
	}
	while(l<=n&&r<=n)
	{
		l++;//前进
		while(a[r]-a[l-1]<=k&&r<=n) r++;//要点1，2
		maxx=max(maxx,r-l);
	}
	cout<<maxx;
}
```

### 补充：
要点1：因为在 `a[r]-a[l-1]<=k` 中的 `=` 所以会导致循环结束时， `a[r]-a[l-1]` 是要大于 `k`的，且刚好比预想值大 $1$ ，那么区间长度就是 `(r-1)-l+1` ,即 `r-l` .

要点2：如果 `while` 中是 `r<n`  的话，在循环结束时，`r` 不会超过 `n` 的，上面说过， `r` 是要比预想直大 $1$ 的，所以当区间结尾在最后一个时答案就会少 $1$ ，加上 `=` 是刚刚好的。




