### 题意描述：

麦克结婚后胖了 70 磅，导致他的手指太胖，打字容易误按键。

他每天会详细记录自己吃的东西，但是有时候会误按键，打错字符。

为了帮助麦克的好友斯拉夫克读懂麦克的电子邮件，你需要编写一个程序，根据麦克的三封电子邮件，找出可能误打字符不超过 3 个的情况下，麦克可能写出的最长的信件。

### 思路：

这道题目的解法是求三个字符串的最长公共子序列（LCS），需要用到动态规划的思想。

我们可以使用一个三维数组 $dp_{i,j,l}$ 来记录前 $i$ 个字符的字符串 $a$，前 $j$ 个字符的字符串 $b$ 和前 $l$ 个字符的字符串 $c$ 的最长公共子序列的长度。

可以推出下述的状态转移方程：

- 如果字符 $a_i$、$b_j$、$c_l$ 相同，说明有一个新的公共元素，那么 $dp_{i,j,l}$ 就可以在 $dp_{i-1,j-1,l-1}$ 的基础上加 $1$，即 $dp_{i,j,l}=dp_{i-1,j-1,l-1}+1$。

- 如果字符 $a_i$、$b_j$、$c_l$ 不同，那么说明此时无法更新最长公共子序列，我们就需要继承前面的结果，即 $dp_{i,j,l} = \max (dp_{i-1,j,l} ,dp_{i,j-1,l}, dp_{i,j,l-1})$。

在求解 $dp$ 数组的同时，我们可以使用另一个三维数组 $ans_{i,j,l}$ 来记录三个字符串的最长公共子序列的内容。

每次更新 $dp$ 数组时，我们也可以同时更新 $ans$ 数组来记录最长公共子序列的内容。

最后，我们可以得到三个字符串的最长公共子序列的长度，以及最长公共子序列的内容。需要注意的是，题目中的每打一个想要的字符时误打的字符不超过 $3$ 个，这个条件不需要考虑，因为我们搜出来的 LCS 一定包含正解。

### 完整代码：
```cpp
#include<cstring>
#include<cstdio>
#include<iostream> 

#define N 105

using namespace std;

string a, b, c, ans[N][N][N];//字符串 
int la, lb, lc, f[N][N][N];// 长度和dp 

int main ()
{
	cin >> a >> b >> c;
	la = a.size (); lb = b.size (); lc = c.size ();//三个字符串的长度 
	for (int i = 1; i <= la; i ++)
	 for (int j = 1; j <= lb; j ++)
	  for (int k = 1; k <= lc; k ++)
	   if (a[i - 1] == b[j - 1] && a[i - 1] == c[k - 1])
	   {
	   	  if (f[i][j][k] < f[i - 1][j - 1][k - 1] + 1)
	   	  {
	   	  	f[i][j][k] = max (f[i][j][k], f[i - 1][j - 1][k - 1] + 1);
	   	  	ans[i][j][k] = ans[i - 1][j - 1][k - 1] + b[j - 1];//这里可以写b[j - 1]当然也可以a[i - 1]或者c[k - 1] 
		  }
	   }
	   else
	   {
		  if (f[i - 1][j][k] >= f[i][j - 1][k] && f[i - 1][j][k] >= f[i][j][k - 1]) ans[i][j][k] = ans[i - 1][j][k];
          else
		  if (f[i][j - 1][k] >= f[i - 1][j][k] && f[i][j - 1][k] >= f[i][j][k - 1]) ans[i][j][k] = ans[i][j - 1][k];//没法直接max只能一个一个比 
          else
          ans[i][j][k] = ans[i][j][k - 1];
          f[i][j][k] = max (max (f[i - 1][j][k],f[i][j - 1][k]), f[i][j][k - 1]); 
	   }
	   
	cout << ans[la][lb][lc];//输出 
	return 0;
}


```
大家回去之后要自己推一下，不要直接“复制提交”啊~