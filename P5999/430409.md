退役前最后一篇题解。

# 题目大意

有一个园子，里面有 $n$ 个草丛排成一排，标号 $1\sim n$，有一个袋鼠，从 $s$ 出发，每次跳一步跳到一个其他的草丛，经过每个草丛恰好一次，最终到达 $t$。显然他会跳跃 $n-1$次为了不被人类发现，袋鼠每次跳跃的方向必须与前一次不同。

具体地，如果他现在在 $now$，他是从 $prev $ 跳跃一次到达 $now$ 的，然后他跳跃一次到达 $next$：

- 那么如果 $prev<now$，就必须有 $next<now$；

- 如果 $now<prev$，就必须有 $now<next$。

问从 $s$ 到 $t$ 的方案数模 $10^9+7$的结果。

两个路线不同，当且仅当草丛被访问的顺序不同。

保证至少有一种方案初始时可以往任意方向跳。

# 题目分析

显然是一道计数 Dp。

题意可以看做：有一个 $1\sim n$ 的排列 $p$，这个排列不会出现长度超过 $2$ 的连续递增或递减的子串，求这个排列有多少个。

从小到大向这个排列 $p$ 插入数，令 $dp[i,j]$ 表示插到了第 $i$ 个数，序列被分成 $j$ 段的方案总数，**每一段内部都满足条件。**

然后推状态转移方程，有两种情况：

+ $i\neq s$ 且 $i\neq t$，此时 $i$ 插入在任何位置，因为从小到大插数，所以插的位置的两边都小于当前插入的这个 $i$，一定满足条件，当然也可以单独成段，这里必须满足这个数不能插到 $s$ 前面也不能插到 $t$ 后面，有 $dp[i,j]=dp[i-1,j-1]\times (j-[i>s]-[i>t])+dp[i-1,j+1]\times j$。

+ $i=s$ 或 $i=t$，此时只能插在最前面或最后面，有 $dp[i,j]=dp[i-1,j-1]+dp[i-1,j]$。

# 代码

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;

const int mod = 1e9 + 7;
const int N = 2005;
int dp[N][N];//插入到第 i 个数,序列被分成了 j 段时的方案数
int n,s,t;
int32_t main() {
    cin >> n >> s >> t;
    dp[1][1] = 1;
    for (int i = 2;i <= n; ++ i) {
        for (register int j = 1;j <= i; ++ j) {
            if (i == s || i == t) {
                dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];
                dp[i][j] %= mod;
            } else {
                dp[i][j] = (dp[i - 1][j + 1] * j) % mod + (dp[i - 1][j - 1] * (j - (i > s) - (i > t))) % mod;
                dp[i][j] %= mod;
            }
        }
    }
    cout << dp[n][1] << "\n";

    return 0;
}
```