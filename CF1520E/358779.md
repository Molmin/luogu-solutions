## 题意简述

给我们 $t$ 组数据，每组数据第一行为 $n$ ，为字符串长度，下一行为一个字符串（只有 ' . ' 和 ' * '字符），每次可以向右或者向左移动 ‘  * ’ 字符，求把所有的 ' * ' 字符连起来的最小移动次数

## 思路

可以运用贪心的思想

要求我们求最少移动次数，我们就需要一个明确的移动方向，那么向哪里移动最好呢？我们举一个例子

```
n=7
* . * . . * .
```


1. 全部向右移动

一共需要 $2+3=5$ 次（思考一下为什么最左边的只需要 $3$ 次）

2. 全部向左移动

一共需要 $1+3=4$ 次

3. 向最中间的‘*’符号靠拢

一共需要 $1+2=3$ 次 

不难发现，向中间靠拢是最优解方式，我们就用这个总思路来写程序

## Code

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
string s;
long long n,m[1000005],pop=0,flag=0,ans=0;
/*
n同题意，m存储*符号在哪个位置出现，pop是*出现的次数，flag用来判断是否整个字符串都是*（特判），ans存储答案
*/
long long t;//t组数据
int main()
{
	cin>>t;
	while(t--)
	{
		pop=0,flag=0,ans=0;//清空数据
		cin>>n;
		cin>>s;
		for(int i=0; i<n;i++)
		{
			if(s[i]=='*')//如果这个位置是*
			{
				m[++pop]=i+1;//存储一下位置，i+1是因为字符串下标从0开始，如果直接用i会出大问题
			}
			if(s[i]=='.') flag=1;//判断是否整个字符串都是*(样例中第二组数据)
		}
		if(pop==0||pop==1||flag==0) {cout<<0<<endl;continue;}//特判
		int mid=pop/2+1;//中间的*号所在位置的下标（m数组的下标）
		for(int i=1; i<=pop;i++)//求距离
		{
			ans+=abs(m[mid]-m[i])-abs(mid-i);
		}
		cout<<ans<<endl;
	}
	
}
```

