# P1721 [NOI2016] 国王饮水记 题解

## 题意简述

给定 $n$ 个城市，第 $i$ 个城市收集到了高度为 $h_i$ 的水，要求通过使用 $k$ 次地下连通系统，每次使用可以使若干个城市的水箱相连通，然后使它们的水位变为它们的平均值。要求求出 $k$ 次操作后， $1$ 号城市水箱中的水位的最大值。

## 策略选择及最优性证明

**引理0**：我们一定不会对初始水位不高于 $1$ 号的水箱操作，操作与操作之间选择的水箱一定不会有重叠。

**证明**：显然。

---

**引理1**：对于初始水位高于 $1$ 号的所有水箱，我们应当从小到大进行操作。

**证明**：对于两次操作，不妨设其中一个选择是 $k_1$ 个水箱，它们的值分别为 $a_1,a_2,…,a_{k_1}$；另一个选择是 $k_2$ 个水箱，它们的值分别为 $b_1,b_2,…,b_{k_2}$。设操作前 $1$ 号水箱的水位为 $x$，且根据**引理1**，数组 $a$ 中的任意数比 $b$ 中任意数小。那么，如果先选择操作 $a$，$1$ 号水箱的水位会变成：
$$
f_1=\frac{x+\sum_{i=1}^{k_1}a_i+(k_1+1)\sum_{i=1}^{k_2}b_i}{(k_1+1)(k_2+1)}
$$
否则，$1$ 号水箱的水位会变成：
$$
f_2=\frac{x+\sum_{i=1}^{k_2} b_i+(k_2+1)\sum_{i=1}^{k_1}a_i}{(k_1+1)(k_2+1)}
$$
作差可得：
$$
f_1-f_2=\frac{k_1\sum_{i=1}^{k_2}b_i-k_2\sum_{i=1}^{k_1}a_i}{(k_1+1)(k_2+1)}
$$

$$
=\frac{k_1k_2}{(k_1+1)(k_2+1)}\cdot(avg_b-avg_a)>0
$$

由此证毕。

---

**引理2**：如果我们需要在水箱集合 $S$ 中选择 $k$ 个水箱进行一次操作，那么选择水位最高的 $k$ 个一定是最优的。

**证明**：设操作前 $1$ 号水箱的水位为 $x$，选择的水箱水位分别为 $a_1,a_2,…,a_{k}$。那么，操作后的水位可以表示为 $\frac{x+\sum a}{k+1}$。显然，我们希望操作后水位尽可能大，只需要让 $\sum a$ 最大即可，也就是选择最大的 $k$ 个。

---

根据**引理1**以及**引理2**，我们可以从小到大进行dp，如下是一个显然的dp转移方程：
$$
dp_{i,j}=\max\{dp_{i-1,j},\frac{dp_{k,j-1}+sum_i-sum_k}{i-k+1}\}
$$
状态 $dp_{i,j}$ 代表前 $i$ 个水箱中已经操作过 $j$ 次后 $1$ 号水箱中的最高水位，$sum_p$ 代表前 $p$ 个水箱初始水位的前缀和。注意到转移可以压掉一维，忽略掉 $dp_{i-1,j}$ 一项（过程中直接继承即可），方程转化成：
$$
dp_{i}=\max\{\frac{dp_{k}+sum_i-sum_k}{i-k+1}\}
$$
至此，我们就找到了 $O(n^2k)$ 的初步算法。（关于为什么复杂度里面没有 $p$，我们可以在 $dp$ 时存一下是从哪个状态转移过来的，过程中不必使用高精类，最后时再进行一遍深搜统计最终答案就好了。）

## 算法优化

#### 基本尝试

然后应该做什么呢？

观察转移方程，经过初步尝试后，可以发现这个式子难以进行常规的斜率优化，甚至可以说是不可能，因为交叉相乘后出现了类似于 $k_2dp_{k_1}$ 的二次项。~~（@OvO_Zuo ：不然你猜它为什么是黑的）~~那么，我们就需要**另辟蹊径**。

#### 另类斜率优化

注意到转移方程中的式子其实本身就是一个斜率式子。设两个点 $(i,sum_i)$ 和 $(k-1,sum_k-dp_k)$。原式恰为第二个点关于第一个点的斜率。接下来，让我们分析这种特殊的斜率的性质。首先注意到原式一定是正的，即斜率一定是正的；另外，$i$ 一定比 $k-1$ 要大。同时，$i$ 和 $sum_i$ 都是单调递增的。

设三个决策点为 $k_1$，$k_2$，$k_3$，且它们大小递增，$k_1k_2$ 的斜率大于 $k_2k_3$ 的斜率。

![](https://s1.ax1x.com/2022/07/23/jXKuvt.png)

那么，考虑上图的情况，如果 $(i,sum_i)$ 位于如图所示绿色线以上的部分，有 $k_3$ 优于 $k_2$；而对于如图所示红色线以下的部分，有 $k_1$ 优于 $k_2$。因此，$k_2$ 在任意的情况下都不是最优点，可以直接舍去。对于其他非上图情况也都可以通过类似的分析发现，只要满足 $k_1k_2$ 的斜率大于 $k_2k_3$ 的斜率，那么 $k_2$ 在任意的情况下都不是最优点。

![image-20220722154911568](https://s1.ax1x.com/2022/07/23/jXKMKP.png)

而对于相反的情况，即 $k_1k_2$ 的斜率小于 $k_2k_3$ 的斜率，注意到红色部分和绿色部分的中间会有间隙，这意味着 $k_2$ 并不一定不是最优解，此时 $k_2$ 需要保留。

那么，哪个决策点是最优的呢？

![image-20220722164119240](https://s1.ax1x.com/2022/07/23/jXKQDf.png)

对于一个决策点而言，如果它右侧线段的延长线在 $i$ 之上，那么它会优于它右侧的下一个决策点；否则它右侧的下一个决策点优于它。考虑上图，我们找到第一个决策点使得它右侧的线段延长线在 $i$ 点之上，即其右侧线段斜率大于其与 $i$ 点连线的斜率，那么这个点就是最优决策点。如上图中的 $k_2$。这是因为 $k_2$ 比左侧所有点都要优，也比右侧所有点都要优。

至此，我们已经可以发现：这与**常规斜率优化**完全类似。维护一个下凸壳即可，二分进行决策选取，时间复杂度成功优化至 $O(n\log nk)$ 。

但是显然还是过不去。能否砍掉二分复杂度？

#### 终极优化

~~接下来是神的领域~~

**引理3**：对于决策点 $k_1,k_2$，如果满足 $k_1<k_2$ ，且 $k_1$ 在某一次的转移中较劣，在之后的转移中一定也都是较劣的。

**证明**：设在转移至 $i$ 的情况下，$k_2$ 比 $k_1$ 优。接下来，让我们来讨论转移至 $i+1$ 的情况。根据我们设出的条件，有以下结论：
$$
\frac{dp_{k_1}+sum_i-sum_{k_1} }{i-k_1+1}<\frac{dp_{k_2}+sum_i-sum_k}{i-k_2 +1}
$$
设左边为 $F$ ，右边为 $G$，条件相当于给出 $F<G$。考虑转移至 $i+1$ 的情况，即我们需要证明：
$$
\frac{FA+C }{A+1}<\frac{GB+C }{B+1}
$$
其中 $A=i-k_1+1,B=i-k_2+1,C=h_{i+1},A>B$。又因为操作顺序是从小到大，所以一定有 $C>G>F$ 。至此，只需证：
$$
(G-F)AB+C(A-B)+GB-FA>0
$$
注意到：
$$
C(A-B)+GB-FA>C(A-B)+F(B-A)=(C-F)(A-B)>0,(G-F)AB>0
$$
所以原式得证，证毕。

根据**引理3**，由于队首的元素都满足**引理3**，所以我们可以每次转移答案时将较劣的决策点从队首弹出，保证每一个决策点都最多入队出队各一次。至此，复杂度成功优化至 $O(nk)$，完结撒花。

## 代码

```c++
#include<bits/stdc++.h>
using namespace std;
#define LD long double
int n;
LD h1,sum[8005],h[8005],dp[2][8005];
short from[8005][8005];//存是从哪里转移过来
bitset<8005>jump[8005];//表示转移到当前状态是否进行了一次操作
int cnt=0;
int q[10000005],l=25001,r=25000;//手写队列比较方便
bool check(int k,int kn,int o,int i){
	if(l==r) return true;
	LD x1=k-1,y1=sum[k]-dp[o][k],x2=kn-1,y2=sum[kn]-dp[o][kn],x3=i,y3=sum[i];
	return ((y2-y1)/(x2-x1))>((y3-y1)/(x3-x1));
}
Decimal dfs(int x,int k){
	Decimal ret=0;
	if(k==0) return (Decimal)(double)h1;
	if(jump[x][k]) return (dfs(from[x][k],k-1)+(Decimal)(double)(sum[x]-sum[from[x][k]]))/(x-from[x][k]+1);
	else return dfs(from[x][k],k);
}
int main(){
	int k,p;
	LD tmp;
	cin>>n>>k>>p;
	scanf("%Lf",&h1);
	for(int i=1;i<n;i++){
		scanf("%Lf",&tmp);
		if(tmp>h1) h[++cnt]=tmp;
	}
	n=cnt;
	k=min(k,n);
	sort(h+1,h+1+n);
	for(int i=1;i<=n;i++) sum[i]=sum[i-1]+h[i];
	for(int i=0;i<=n;i++) dp[0][i]=h1;
	for(int j=1;j<=k;j++){
		l=r;
		q[l]=0;
		int dif=j&1,lst=1-dif;
		for(int i=1;i<=n;i++){
			while(l<r){
				if(check(q[l],q[l+1],lst,i)) break;
				else l++;
			}
			dp[dif][i]=max(dp[dif][i-1],(dp[lst][q[l]]+sum[i]-sum[q[l]])/(i-q[l]+1));
			if(dp[dif][i-1]>(dp[lst][q[l]]+sum[i]-sum[q[l]])/(i-q[l]+1)) from[i][j]=i-1,jump[i][j]=0;
			else from[i][j]=q[l],jump[i][j]=1;
			while(l<r){
				LD x1=q[r-1]-1,y1=sum[q[r-1]]-dp[lst][q[r-1]],x2=q[r]-1,y2=sum[q[r]]-dp[lst][q[r]],x3=i-1,y3=sum[i]-dp[lst][i];
				if(((y2-y1)/(x2-x1))>=((y3-y1)/(x3-x1))) r--;
				else break;
			}
			q[++r]=i;
		}
	}
	Decimal ans=dfs(n,k);
	cout << ans.to_string(p*6/5) << "\n";
	return 0;
} 
```