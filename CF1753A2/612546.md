考虑极端情况：假设数组中每一个数字都分成单独的一段，那么 $\sum^{k}_{i=1}s_i$ 即为原数组之和。

如果把其中一个数 $a_i$ 与上一个数 $a_{i-1}$ 合并在同一个区间（$i \neq 1$），那么 $a_i$ **将会取反，且上一个数不变**。

又可根据题意得到：**相邻的两个数不能同时取反**。因此上述中的区间合并没有任何限制（但不能把第一个数往前合并，原因显而易见）。

由此可将问题转化为：可以将序列中的任意（第一个数除外）不相邻的数取反，问如何使序列之和为 $0$。

可以很轻易的得出：每把一个 $1$ 取反成 $-1$，$s_i$ 之和就会减少 $2$、每把一个 $-1$ 取反成 $1$，$s_i$ 之和就会增加 $2$。

因此，只要序列之和为奇数，必然无解。反之必然有解。

若序列之和为偶数，则分情况看待：若序列之和为正数，则只将 $1$ 取反为 $-1$；若序列之和为负数，则只将 $-1$ 取反为 $1$。

于是贪心寻找，从第二个数开始依次往后找，只要找到了 上一个数未被取反 且 符合序列之和的正负 的（非 $0$）数，就将其取反。直到序列之和为 $0$ 时停止。 

输出也很简单，将取反的数与上一个数合并为一个区间就行了。

代码：

```cpp
#include<cstdio>
int T,n,tot,sum;
int a[200005],b[200005];
int main(){
	scanf("%d",&T);
	while(T--){
		sum=tot=0;
		scanf("%d",&n);
		for(int i=1;i<=n;i++) b[i]=0; 
		for(int i=1;i<=n;i++) scanf("%d",a+i),sum+=a[i];
		if(sum&1){
			puts("-1");
			continue;
		}
		for(int i=2;i<=n;i++){
			if(!sum) break;
			if(a[i]==(sum>0?1:-1)&&(!b[i-1]))
				sum-=2*(sum>0?1:-1),b[i]=1,tot++;
		}
		printf("%d\n",n-tot);
		for(int i=1;i<=n;i++)
			if(b[i+1]&&i+1<=n) printf("%d %d\n",i,i+1),i++;
			else printf("%d %d\n",i,i);
	}
	return 0;
} 
```