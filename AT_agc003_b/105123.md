这个题的大意就是：一张面值为a的卡牌，只能和面值为a-1、a、a+1的卡牌配对；给你一堆卡牌，求最大配对数。

刚拿到这个题，我的第一想法就是：先推推样例看一看。我的初始思路是：读入后，先把每种面值的卡牌与它后面的卡牌尽量配对以后，在将剩下的该面值卡牌模2，统计总数，但是，我造了一组数据，卡掉了这个想法：
```cpp
4
2 5 2 1
```
如果按我们原先的思路来，最终结果是4，但是我们尝试一下能发现，最大结果其实是5

#### 咋回事呢？

我们发现，按原先的想法处理完数据之后会剩下两个不相邻的1（0 1 0 1），我们要想办法把这两个1再配对。于是我们就想，应该可以通过调换一下处理顺序，先模2，再配对，这样就能使落单卡牌的面值尽量大（可能描述的有点不清楚，大家自己推一推便明白了，~~毕竟我是个语文渣~~）

然后我就惊讶地发现，我居然AC了……

以下是我的代码：
```cpp
#include<cstdio>
#include<iostream>
using namespace std;
int a[100010],n;
long long ans;
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	scanf("%d",&a[i]);
	for(int i=1;i<=n;i++)
	{
		if(!a[i])continue;
		ans+=a[i]/2;
		a[i]%=2;
		if(a[i])if(a[i+1])a[i]-=1,a[i+1]-=1,ans++;
	}
	printf("%lld",ans);
	return 0;
}
```