### 题目分析：

------------

不难看出此题用的是**贪心**。

由题目得，组合只有两种方式：
- 自己和自己一组。
- 自己和下一个一组。

可能有人会反驳：还可以是自己和上一个啊！  但是如果按三种情况算的话，自己和下一个、下一个和他的上一个（即自己）会重复算，从而使自己无从下手，不方便写代码。~~至少我是这样。~~

所以按两种方式算能不重不漏的覆盖所有情况。

先自己和自己凑一组，把每种能消耗的消耗完；再用剩下的和下一种匹配。这样能使消耗得牌数尽量多，即使能租的组数尽量多。



### AC 代码：
------------
```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,a[100010],ans;
int main(){
	scanf("%lld",&n);
	for(int i=1;i<=n;i++)
	scanf("%lld",&a[i]);
	for(int i=1;i<=n;i++){
		ans+=a[i]/2;//先自己和自己组
		a[i]=a[i]%2;//计算和自己组完后能和下一种组合的牌数
		if(a[i]!=0&&a[i+1]!=0){//若有一方为0，则不能和下一种组，直接跳过
			ans+=1;
			a[i]-=1;
			a[i+1]-=1;
		}//因为a[i]%2所以a[i]只能为1或0，但a[i]和a[i+1]都不为0（见判断条件），所以能组的最大数为1
	}
	printf("%lld\n",ans);
	return 0;
}
```


------------
#### 完