- Update on 2023.4.21 修正一处错误。

[CF1770G Koxia and Bracket](https://www.luogu.com.cn/problem/CF1770G)

相比于 F，这道题就略显套路了。

将左括号视为 $1$，右括号视为 $-1$，找到最前缀和最小的位置 $lst$，则 $s_1\sim s_{lst}$ 的每个左括号都有用，必然不会删去。同理，$s_{lst + 1}\sim s_n$ 的每个右括号也都有用。

对于 $s_1\sim s_{lst}$ 的每个右括号 $s_i$，如果它对应的前缀和为 $c_i$，则为保证前缀和非负，在 $s_1\sim s_i$ 中至少需要删掉 $-c_i$ 个右括号。我们只关心 $-c_i$ 的前缀最大值，因为若这些位置满足条件，则所有位置满足条件，而每个前缀最大值一定会比先前的前缀最大值大 $1$，所以我们将问题转化为：给定长为 $m$ 的序列，其中有 $c$ 个位置被打上了标记，求出选择 $c$ 个位置的方案数，使得对于每个前缀，选择的位置数不小于被打上标记的位置数。

设 $f_{i, j}$ 表示考虑到第 $i$ 个位置，当前选择位置数减去打标记位置数的数量为 $j$。对于没有被打标记的位置 $p$，$f_{p - 1, j}$ 转移到 $f_{p, j / j + 1}$，否则转移到 $f_{p, j - 1 / j}$。

非常明显的 [阶梯格路计数](https://www.cnblogs.com/alex-wei/p/Polynomial___Lagrange_Interpolation_and_Fast_Fourier_Transform.html) 问题，稍有变形，不过解法大差不差，核心思想是一致的：考虑 $f_l$ 转移到 $f_r$，用卷积描述一部分转移，剩下来 $\mathcal{O}(r - l)$ 个位置分别递归两侧处理。

对于本题，就是 $f_{l, j}(j\geq cnt)$ 对 $f_r$ 的贡献用卷积描述，其中 $cnt$ 表示 $l + 1\sim r$ 的被打上标记的位置。剩余部分递归，长度只有 $cnt$，而且因为截取的是低位，我们甚至不需要记录偏移量 $\Delta$。

$r - l = 1$ 的边界情况是平凡的。

$s_{lst + 1}\sim s_n$ 的左括号类似处理即可。

每个分治区间涉及到的多项式长度不超过其父区间长度，因此时间复杂度为 $\mathcal{O}(n\log ^ 2n)$。[代码](https://codeforces.com/contest/1770/submission/188373663)。