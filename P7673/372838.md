## 1.题目大意：

这题描述这么多~~废话~~，充其量输入就是按照二叉树的中序遍历输入，当时看完我都懵了。至于这个题目中说的“完全二叉树”，再结合这个 $K$ 看一看，这不就是满二叉树嘛。

## 2.思路+代码分析

于是——这道题的输入就变得格外的~~奇葩~~：在 **dfs** 中输入，让我们来看看代码：

```cpp
void dfs(int dep,int id){
	if(dep>n) return;//边界返回条件：深度超过二叉树的深度
	dfs(dep+1,id*2);
	cin>>a[id];
	dfs(dep+1,id*2+1);//两次dfs中间夹输入，妥妥的中序遍历输入大法！
}
int main(){
	……
	dfs(1,1);
	……
}
```

这里的 $dep$ 表示当前到达的深度，很明显这里根节点的深度设定的是 $1$，而 $id$ 是读入的下标，大家发现**输入的位置**了吗？没错，正是夹在两个向下搜索儿子节点的 dfs 中的。

当我们的 dfs 执行完毕之后，$a$ 数组中的答案就已经全部按照输出的顺序排号了。但是输出每一层结束都需要换行，这里我用了一个小小的 lowbit 思想：每一个 $2$ 的整数次幂的 lowbit 都是自己本身。

所以：

```cpp
for(int i=1;i<=n;i++){
		cout<<a[i]<<" ";
		if(((i+1)&(-(i+1)))==i+1) cout<<endl;
}
```
还有需要注意的是：& 的优先级比 == 还要小，所以需要打括号。

-----------

## 下课啦！