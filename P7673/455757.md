**这是本蒟蒻第八次写的题解，如有错误点请好心指出！**

## 问题简述

__这道题我们可以换另一种思路去看待它，就容易理解了：__

给你一个完全二叉树中序遍历后得出的结果，输出该完全二叉树。

## 解法综述

我们假设一个完全二叉树如下图：

![该图摘自本人CSDN博客](https://img-blog.csdnimg.cn/20210716190858528.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0pHX0RGXw==,size_16,color_FFFFFF,t_70#pic_center)

（该图摘自本人CSDN博客）

它的中序遍历为 $4251637$。

通过观察，我们会发现下面这一规律：

输出的第 $1$ 个数其实是它中序遍历的第 $4$ 个数；

输出的第 $2$ 个数其实是它中序遍历的第 $2$ 个数；

输出的第 $3$ 个数其实是它中序遍历的第 $6$ 个数；

输出的第 $4$ 个数其实是它中序遍历的第 $1$ 个数；

输出的第 $5$ 个数其实是它中序遍历的第 $3$ 个数；

输出的第 $6$ 个数其实是它中序遍历的第 $5$ 个数；

输出的第 $7$ 个数其实是它中序遍历的第 $7$ 个数；

其实就是输出该遍历中间的数并换行，然后从该遍历的中间开始分割成两份，输出左边那一份中间的数和右边那一份中间的数并换行，之后从这两份的中间开始分割成四份，输出第一份、第二份、第三份、第四份中间的数并换行，再将它们分割成八份......以此类推，直到将它们输出完为止。

## 代码描述
```cpp
#include<cstdio>
int n,b=1,a[1025],c,s=2;//s为该完全二叉树当前深度需要输出的节点
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++) b*=2;
	b--;//b为要输出的总节点数
	for(int i=1;i<=b;i++) scanf("%d",&a[i]);
	b=(b+1)/2;
	printf("%d\n",a[b]);//输出第一行，为该遍历中间的数
	c=b/2;
	while(--n)//继续输出n-1行
	{
		printf("%d ",a[c]);//先输出第一份中间的数
		for(int i=1;i<s;i++) printf("%d ",a[b*i+c]);//再输出第2到s份中间的数
		printf("\n");
		b=c;
		c/=2;//模拟分割
		s*=2;//深度加1，节点乘2
	}
	return 0;
}
```