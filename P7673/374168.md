## 题意
给定一个完全二叉树的中序遍历，输出这个 $K$ 行的二叉树。

## 思路

既然其他题解大多用了递归的方法，我再分享一种找规律的方法。

注意：此题要掌握通法，找规律只是考试救急的方法！

首先，一段完全二叉树的根节点一定在中序遍历的最中间，输出换行。

这样，一个序列就被根结点分成了两部分，分别是左子树和右子树，可以用相同的方法找到最中间的那个数，就是这棵子树的根节点。

以此类推，直到叶子结点，结束。

如何找根节点？我们发现，输入数据：

```
3
1 6 4 3 5 2 7
```

输出数据：
```
3
6 2
1 4 5 7
```

「在此，定义 位置 为 下标+1 」

其根节点为 `3` ，在序列的第四位；
第二行的字节点为 `6` 、 `2` ，分别在序列的第二位，第六位；
叶子结点为 `1` 、 `4` 、 `5` 、 `7` 分别在序列的第一、三、五、七位。

不难发现，根节点所在的位置能够被 $2^{k-1}$ 整除；

子节点所在的位置能够被 $2^{k-2}$ 整除；

叶子节点所在的位置能够被 $2^{k-3}$ 整除；

所以，在二叉树的第 $n$ 层的数，就能被 $2^{k-n}$ 整除。


## Code

```cpp
#include<bits/stdc++.h>
#define FOR(i,a,b) for(int i=a;i<=b;i++)

using namespace std;

string s1,s2;

int a[10005];
bool vis[100005];//标记数组，防止重复。（解释见下）
int main()
{
    int k;cin>>k;
    int n=pow(2,k)-1;//所有节点个数（题目已给定）
    FOR(i,1,n)
    {
        cin>>a[i];
    }
    int cnt=0;
    for(int i=k;i>=0;i--)//2的幂次递减，「这里 k 控制的就是上文的 n 」
    {
        FOR(j,1,n)
        {
            if(j%(int(pow(2,i)))==0/*若是2的幂的倍数*/&&vis[j]==0/*且未被访问过*/)
            //由于根节点满足2^k,所以也满足2^(k-1),一定要标记，防止重复。
            {
                vis[j]=true;
                printf("%d ",a[j]);
            }
        }
        cnt++;
        if(cnt>1)   puts("");//k变化时，说明这一行的节点都已输出，换行。
    }
    return 0;
}
```