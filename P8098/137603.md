> 有一个长为 $n$ 的递增的整数数组满足 $x_1\le x_2\le \cdots\le x_n$ 和一个整数 $k$。你不知道这个数组 $x$ 和这个整数 $k$，但你知道对于每个下标 $i$ 满足 $x_{j_i}\le x_i+k$ 的最大下标 $j_i$。保证 $i\le j_i$，且 $j_1\le j_2\le \cdots\le j_n\le n$。通过 $j$ 数组，构造一个任意数组 $x$ 和整数 $k$ 满足上述条件，需要满足 $1\le x_i,k\le 10^{18}$，可以证明答案一定存在。($1\le n\le 10^5$)

神仙构造题。考虑把题目中的关系描述为树形的关系，具体来讲是连 $j_i+1\rightarrow i$ 的边，这样能形成一棵外向树，其中父子关系 $u\rightarrow v$ 表示 $u$ 是第一个满足 $x_u>x_v+k$ 的下标。显然这样会多出一个虚节点 $n+1$，它就是根，且不管怎么样都可以防止形成森林。

接下来我们发现对于树上同一层的结点，我们关心的是它们之间比较“微小”的数量变化，而对于不同层的结点我们关心的是“较大”的数量变化。能发现，这里大小的定义就是与 $k$ 的关系，父亲结点和儿子结点之间的差“大约”是 $k$，而同层只需要考虑递增的条件微调一下即可。

有了这个发现，我们就可以定义每个结点的权值是 $h_ik+y_i(0\le x_i<k)$，其中 $h_i$ 是该点距离最深的叶子结点的距离，可以形象理解为高度。我们发现这个权值完全符合刚刚的分析，不同层之间差的大约是 $k$，还有 $y_i$ 之间的小小调整，而同层之间只有 $y_i$ 之间的小小调整。现在的目标就是恰当的给 $y_i$ 赋值了。

给 $y_i$ 赋值的限制在于满足原题递增的限制，因为一旦数组递增，其他的限制都能被满足。我们发现，如果从根节点开始 $\rm dfs$，每次访问子节点都按照编号从大到访问，满足 $y_i$ 按照访问次序递减，就能满足条件。首先因为 $h_ik$，高层一定大于低层，而又因为 $i\le j_i$，高层编号一定大于低层编号，所以大体上的递增是满足的。而每次我们又是按照编号从大到小访问子节点的，同层的又能保证递增（容易发现不同的父亲结点对应的儿子集合的编号是个区间且不会相交，且是按照父亲结点的大小排列的），所以整体满足递增。

至于 $k$ 的选择，因为 $y_i$ 要 $n$ 个结点人手一个，还要保证单调递减（这是因为父亲结点和儿子结点之间的关系是 $<$，所以 $y_i$ 也要单调递减），所以 $k$ 选 $n+1$ 就好，每次 $-1$。好了，分析完这么多，实现一遍 $\rm dfs$ 就能搞定，时间复杂度 $\mathcal{O}(n)$。
```cpp
#include <cstdio>
#include <vector>
#include <algorithm>
const int N = 1e5 + 10; std::vector<int> T[N]; int dep[N], x[N], now, mx;
void dfs(int u, int depth)
{
	dep[u] = depth; x[u] = now--;
	for (auto v : T[u]) dfs(v, depth + 1);
}
int main()
{
	int n; scanf("%d", &n);
	for (int i = 1, j; i <= n; ++i) scanf("%d", &j), T[j + 1].push_back(i);
	for (int i = 1; i <= n + 1; ++i) std::sort(T[i].begin(), T[i].end(), [](const int& a, const int& b) { return a > b; });
	now = n + 1; dfs(n + 1, 0); for (int i = 1; i <= n + 1; ++i) mx = std::max(mx, dep[i]);
	printf("%d\n", n + 1);
	for (int i = 1; i <= n; ++i) printf("%lld\n", 1ll * (mx - dep[i]) * (n + 1) + x[i]);
	return 0;
}
```