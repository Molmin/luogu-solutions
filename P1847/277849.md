## 结构体解
看到没人写结构体存坐标，于是我就来~~水一发~~补一篇啦

### 首先考虑纯模拟
每次输入左上角坐标和右下角坐标，然后通过 __循环在数组里累加这块区域的值__。这样做看起来是可行的，但是如果我们注意到这个题的 __数据范围__，就会发现这样是不可行的。

### 其次考虑把所有点存起来
根据样例画下，不难发现从 __左上角到右下角坐标围成了一个矩形。__ 那么我们就可以发现，这个题实际要我们求的是 __给出若干个矩形的左上角坐标和右下角坐标，以及若干个点，问有多少个点在矩形内，在哪几个矩形内，最上面的矩形的编号是多少。__

那么我们的思路就是 __把所有左上角，右下角的坐标存起来，在询问时判断当前在多少矩形内，最后一个包含该点的矩形的编号是多少。__

__另外一定要注意：在左上角右下角的点不算在矩形里！！！__

## 正题
```cpp
#include <iostream>
#include <cstdio>
using namespace std;
const int M = 2010;
// 定义一个结构体，用来存放矩形的左上角坐标和右下角坐标
struct Node {
	int x1, y1, x2, y2;
	Node (int x1, int y1, int x2, int y2) : x1(x1), y1(y1), x2(x2), y2(y2) {};
	Node () {};
};
Node pos[M];
int main() {
	int n, m;
	scanf("%d%d", &m, &n);
   // 将左上角，右下角的坐标存起来，矩形的编号就是数组的下标
	for (int i = 1; i <= m; i++) scanf("%d%d%d%d", &pos[i].x1, &pos[i].y1, &pos[i].x2, &pos[i].y2);
	int x, y, cnt, pre;
	while (n--) {
		scanf("%d%d", &x, &y), cnt = 0, pre = 0;
		for (int i = 1; i <= m; i++) {
			// 判断该点是否在矩形内
			if (pos[i].x1 < x && pos[i].y1 < y && pos[i].x2 > x && pos[i].y2 > y) cnt++, pre = i;
		}
      // 该点只要出现就一定在若干个矩形内，输出答案
		if (cnt) printf("YES %d %d\n", cnt, pre);
		else printf("NO\n");
	}
	return 0;
}
```
~~话说这题数据好水，我第一次m，n打反了都只WA了一个点~~