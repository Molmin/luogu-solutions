### -1 前言
看到本题的所有题解均用的是三层嵌套的循环解题，复杂度为 $O(n^3)$，对于本题的数据范围可以通过，但我将介绍一种 $O(n^2)$ 的做法。
### 0 题意
共有 $n$ 年可以进行投资，有 $d$ 种债券，分别对应本金 $a_i$ 及年利息 $b_i$，投资时使用前一年的本息和进行投资。

### 1 思路
典型的完全背包问题。

假设 $f_i$ 代表本金为 $i$ 时一年获得的利息。那么，它的状态转移方程为 $f_i=\max(f_i,f_{j-a_i}+b_i)$。

之后设 $ans$ 为目前的资金总数，再对每一年进行更新即可，此时的复杂度为 $O(n^3)$，代码可以参考其它题解。

### 2 优化
接下来对空间复杂度和时间复杂度进行优化。
- 空间复杂度：题中提到 $a$ 是 $1000$ 的倍数，我们可以进一步优化转移方程，将 $f_i$ 定义为当本金为 $i\times 10^3$ 时一年获得的利息。
- 时间复杂度：由题意可得，假如你手里有 $x$ 元，那么对于这 $x$ 元，在任何一年获得的最大利息相等，故我们可以先求出所以情况的最大利息，在循环里带入即可，时间复杂度下降为 $O(n^2)$。

### 3 代码
代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=1e5+10;
int s,n,d,ans;
int m[15],l[15],f[maxn];
int main(){
	cin>>s>>n>>d;
	for(int i=1;i<=d;i++){
		cin>>m[i]>>l[i];
		m[i]/=1000;//空间复杂度优化
	}
	ans=s;//先算入本金
	for(int i=1;i<=d;i++){
		for(int j=m[i];j<=maxn-10;j++){
			f[j]=max(f[j],f[j-m[i]]+l[i]);//每次更新当本金为j时的最大利息
		}
	}
	while(n--){
		int flag=ans/1000;
		ans+=f[flag];//每次增加最大利息
	}
	cout<<ans<<endl;//输出
}
```