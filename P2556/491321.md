### 题意：

一个图像有 $n$ 格像素，$0$ 为白色像素，$1$ 为黑色像素。将每 $8$ 个像素所表示的二进制数转换成一个十进制的数，现在输入 $n \div 8$ 个十进制数来表示这个图像，求每段连续的相同颜色的像素的长度与这段像素的颜色所组成的二进制数（这个二进制数有八位，最高位为它的颜色，后七位为它的长度）转换为十进制之后的值。

---
思路，先把所有输入的数转换成连续的二进制的数，用数组存起来，然后模拟：如果当前位置的值和上一个位置的值一样，那就长度加一，继续比较下一个位置。否则，按题目要求输出并把初始长度置为一。最后把最后一段的值也输出即可（大家自己想想为什么还要输出一个数）。

代码：

```cpp
#include<bits/stdc++.h>
#define N 80005
using namespace std;
int n,a[N],b[N];
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n/8;++i) scanf("%d",&a[i]);
	for(int i=1;i<=n/8;++i)
		for(int j=8;j>=1;--j){
			b[(i-1)*8+j]=a[i]%2;
			a[i]/=2;
		}
	int len=1;
	for(int i=2;i<=n;++i){
		if(b[i]!=b[i-1]){
			printf("%d ",b[i-1]?len+128:len);
			len=1;
		}
		else ++len;
	}
	printf("%d ",b[n]?len+128:len);
	return 0;
}
```

