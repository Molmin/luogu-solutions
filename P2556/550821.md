## 题目简述

这道题描述得很绕，无非就是：

- 给定一个数 $n$ 和 $\frac{n}{8}$ 个数 $x_{1...\frac{n}{8}}$。
- 把这 $\frac{n}{8}$ 个数转成2进制，并把他们按数字分段，如 $11011101$ 分成 $11,0,111,0,1$ 几段。
- 然后用一个 $8$ 位的二进制数表示段，其中头位是数字，后面七位是数的数量。还拿上面的举栗子，$11$ 可以表示成 $10000010$，表示数字是1，共有$(10)_2$ 也就是 $2$ 个 $1$，得到 $10000010,000000001,10000011,00000001,10000001$。
- 最后把它转回 $10$ 进制，得到 $130,1,131,1,129$。

## 题目分析

1. 先输入 $n$。
1. 输入 $x$（不开数组，可以省一些空间）。
1. 把 $x$ 分解成二进制数。
1. 遍历这个二进制数，每次都判断这个位置跟上一个是不是一模一样
>1. 如果一样，就是一段的，那么长度加 $1$。
>1. 如果不一样，就输出，然后初始化一下长度。

### 坑点：

1. 最开始的数不能是 $0$ 或 $1$，要进行特判。
1. 最后还要再输出一次，否则最后一段输出不了（想想看）。

## 代码

>### 注释版

```cpp
#include<bits/stdc++.h>
using namespace std;
int n, x, now = 114514, len, a[10];//now一定要赋不为0或1的初始值
int main(){
    scanf("%d", &n);
    for(int i = 0; i < n / 8; i++){
        scanf("%d", &x);
        for(int j = 8; j > 0; j--){//转换成2进制
            a[j] = x % 2;
            x /= 2;
        }
        for(int j = 1; j <= 8; j++){//遍历二进制数
            if(a[j] == now){//如果跟上一个数一样
                len++;//长度加一
            } else {//不一样
                if(now != 114514){//不是最开始的
                    printf("%d ", now * 128 + len);//输出
                }
                now = a[j];//更新now
                len = 1;//长度初始化为1
            }
        }
    }
    printf("%d ", now * 128 + len);//最终输出
    return 0;//好习惯
}
```

>### 无注释版

```cpp
#include<bits/stdc++.h>
using namespace std;
int n, x, now = 114514, len, a[10];
int main(){
    scanf("%d", &n);
    for(int i = 0; i < n / 8; i++){
        scanf("%d", &x);
        for(int j = 8; j > 0; j--){
            a[j] = x % 2;
            x /= 2;
        }
        for(int j = 1; j <= 8; j++){
            if(a[j] == now){
                len++;
            } else {
                if(now != 114514){
                    printf("%d ", now * 128 + len);
                }
                now = a[j];
                len = 1;
            }
        }
    }
    printf("%d ", now * 128 + len);
    return 0;
}
```