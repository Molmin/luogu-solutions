## Content
题目描述太过于繁琐而无法简化，请前往原题面查看。

**数据范围：$1\leqslant n\leqslant 8\times 10^4$。**
## Solution & Code
一个个人认为比较繁琐的模拟，但是思维难度奇低。

可能我的方法和题解区里面的大部分题解相比过程可能要复杂些，果然还是把简单问题想复杂化了……但是思路应该是清晰的。

话回正题，我们将所要做的程序分为四部分，本题解根据这四部分分开讲解，并且代码也只会分部分给。
### Part 1 读入&转化为二进制
我们将这 $\frac n8$ 个数读入进来之后，首先最主要的就是将这些数转化为八位的二进制数。我们可以考虑开个空字符串，每一轮将当前数 $x\bmod 2$ 的余数放到字符串的最后面，然后再 $x\leftarrow \left\lfloor\frac x2\right\rfloor$。最后再将整个字符串翻转过来就好了。注意，如果原数转换为二进制不足 $8$ 位，则要在前面补足前导零。最后将得到的 $\frac n8$ 个字符串按顺序拼接在一起，得到大字符串 $t$。

```cpp
n = Rint;
F(int, i, 1, n / 8) {
    int x = Rint; string tmp = "";
    while(x) tmp += (x % 2 + '0'), x /= 2;
    int len = tmp.size();
    if(len < 8) F(int, j, 1, 8 - len) tmp += "0";
    reverse(tmp.begin(), tmp.end()); //由于我们得到的字符串是反过来的，因此需要翻转一下，用到的是 STL 中的 reverse 函数。
    t += tmp;
}
```
### Part 2 分段
这一个部分比较简单，我们扫一遍字符串 $t$，一碰到和前面的字符不相等的情况就直接新建一段，存储当前这一段子串（其实只要存储第一个字符）及其长度。

```cpp
string tmp = "";
F(int, i, 0, n) {
    if((i == 0 || t[i] == t[i - 1]) && i != n) tmp += t[i];
    else a[++cnt] = (node){tmp, (int)tmp.size()}, tmp.clear(), tmp += t[i]; 
}
```
### Part 3 用二进制表示片段
有了前面的二进制转化的借鉴，这里就不用我再多说了吧，直接上代码。

```cpp
F(int, i, 1, cnt) {
    newt[i] += a[i].s[0];
    int p = a[i].t;
    string tmp2 = "";
    while(p) tmp2 += (p % 2 + '0'), p /= 2;
    reverse(tmp2.begin(), tmp2.end());
    int len = tmp2.size();
    if(len + 1 < 8) F(int, j, 1, 7 - len) newt[i] += "0";
    newt[i] += tmp2;
}
```
### Part 4 转化为十进制&输出
首先看二进制如何转化为十进制的问题。我们都知道，二进制的规则是“满二进一”，所以不难发现，**从低到高的第 $i$ 位上面的数字 $x$ 转换到十进制就是 $x\times 2^{i-1}$**。

因此，我们按照这种思路将十进制转换为二进制就很简单了，然后这道题目就这么愉快地做完了。

放上最后一部分的代码。

```cpp
F(int, i, 1, cnt) {
    int ans = 0;
    F(int, j, 0, 7) ans += (newt[i][j] - '0') * (1 << (7 - j));
    printf("%d%c", ans, " \n"[i == cnt]);
}
```

总体来说思维难度不是很大（起码我觉得比题解区的好想），实现起来有点麻烦，但也是一种行之有效的方法。

最终代码就把上面着四个部分拼接起来就好了，那么就不放完整代码了。