### 题目大意

给定一段路，其中有陷阱和平台，如果踩到陷阱就算输。在平台上可以跳跃到另一个向前的平台。如果从平台 $i$ 连续跳四次，且每次跳跃长度相等，则称为这是一次好的跳跃。

现在给定一个长度为 $n$ 的字符串 $s$，其中 `.` 表示陷阱，`*` 表示平台，输出 $s$ 有无可能出现一次好的跳跃。

### 思路

这一道题一看，如果要在 $n$ 大的时候做，必须用高级数据结构维护，可是一看 $n\le 100$。。。

那么我们可以先枚举每次跳跃的长度，在枚举起点，之后求出在起点上最多能跳几次，如果能跳四次及以上，直接输出 `yes`。时间复杂度 $O(n^3)$。

### 代码

```cpp
#include <bits/stdc++.h>
int n; char s[105];
signed main(void) {
	cin >> n >> s + 1;
	for (int i = 1; i <= n; ++i) {//枚举跳跃长度 
		for (int j = 1; j <= n; ++j) {// 枚举起点
			if (s[j] == '.') continue; //判断起点是否为平台
			int k, cnt = 0;
			for (k = j + i; k <= n; k += i) if (s[k] == '.') break; else ++cnt;
			if (cnt >= 4) return puts("yes"), 0;
		}
	}
	puts("no");
}
```