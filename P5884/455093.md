一道神仙思维题。原题是交互题，所以我们来讲强制在线的做法，讲一些思路上的细节。
# 题意简述
给出 $n$ 个点，每两个点之间都可能会有一条边。以随机的顺序询问所有两点之间的连边情况，你需要回答这两点之间是否连边，保证询问者只能在得到所有的答案之后才能判断“任意两点之间都直接或间接联通”这一命题的真伪。

图不一定需要在一开始确定，$n \leq 1500$。
# 思路分析

设一条边是从较小数指向较大数的，那么容易发现，对于结点 $k$ ，应当有 $k$ 条待定的入边，$n-k-1$ 条待定的出边。

我们可以尝试构造一棵以结点 $0$ 为根的树，涵盖所有结点。即所有结点都从 $k$ 条入边中选且仅选一条，则每一个结点的连通性仅由其入边决定。这样设计构造方案保证了每一个结点与其他所有结点的连通性只与它的入边有关，因为最终每一个结点都将在这棵树当中。所以，结点 $k$ 的连通性被确定只有以下两种可能：
- 1）这 $k$ 条边都确定为断开；
- 2）这 $k$ 条边中有一个确定为连接。

所以，我们只需要保证这两条都不满足，直到这个结点的所有入边都已经被询问过。对于每一个结点都满足题目要求，自然全图满足题目要求。也就是说，除最后一条入边之外，每条边都设定为断开即可。

在最开始时初始化每一个结点的入度，在过程当中更新入度，直到询问中较小的点入度变为 $1$ 时输出 $1$ ，否则输出 $0$ 即可。

# 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int d[1505]={0};
int main(){
	int n,u,v;
	cin>>n;
	for(int i=0;i<n;i++) d[i]=i;//入度初始化
	for(int i=1;i<=n*(n-1)/2;i++){
		scanf("%d%d",&u,&v);
		if(u>v) d[u]--;//更新入度
		else d[v]--;//更新入度
		if(u>v&&!d[u]||v>u&&!d[v]) cout<<"1\n";//判断入度是否恰为1
		else cout<<"0\n";
	}
	return 0;
}
```
