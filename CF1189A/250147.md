突然发现这道题可以交题解了。这篇题解里有关于策略详细的证明。

---

一道练习策略问题的好题。

首先统计 $s_i = 0, 1$ 的个数。统计完毕后，我们可以进行以下两种分支。

分支 $\alpha$：$0, 1$ 的个数相等，此时不是好的序列。题目需要求最短的序列。其实只要把第一个字符当做一个字符串即可。

证明：设字符串中有 $x$ 个 $0,1$。

若 $s_0 = \texttt{0}$，则剩下 $x - 1$ 个 $\texttt{0}$，$x$ 个 $ \texttt{1}$。

同理，若 $s_0 = \texttt{0}$，则剩下 $x$ 个 $\texttt{0}$，$x - 1$ 个 $ \texttt{1}$。

证毕。

证明十分简单，所以分为两个字符串即可。

分支 $\beta$：如果 $0,1$ 数量不一，这个字符串本身就是好的，所以直接输出即可。

关键代码：

```cpp
int n, _0, _1; string s;
_0 = _1 = 0;
read(n); std::cin >> s;
for(int i = 0; i < n; i ++) { s[i] == '0' ? _0 ++ : _1 ++; }
if(_0 != _1) {
  printf("1\n");
  for(int i = 0; i < n; i ++) { printf("%c", s[i]); }
} else {
  printf("2\n%c ", s[0]);
  for(int i = 1; i < n; i ++) { printf("%c", s[i]); }
}
return 0;
```