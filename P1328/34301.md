#迷之纯模拟

##首先要搞清楚大家的输赢状况:

# 每个数字代表:

##0  剪刀

##1  石头

##2  布

##3  蜥蜴人

##4  斯波克


#之间的输赢情况:


```cpp
##0=0<1>2>3<4(剪刀=剪刀<石头>布>蜥蜴人<斯波克)
##1=1>0<2>3<4(石头=石头>剪刀<布>蜥蜴人<斯波克)
##2=2<0>1<3>4(布=布<剪刀>石头<蜥蜴人>斯波克)
##3=3<0<1>2>4(蜥蜴人=蜥蜴人<剪刀<石头>布>斯波克)
##4=4>0>1<2<3(斯波克=斯波克>剪刀>石头<布<蜥蜴人)
```
#简单的理清之间的关系后，可以想到方法可以用简单的25个if搞定。

#那么代码如下:


```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
    long int k,j,i,s1=0,s2=0,n,n1,n2,a[202],b[202],x;
    cin>>n>>n1>>n2;
    for (i=1;i<=n1;i++) scanf("%d",&a[i]);
    for (i=1;i<=n2;i++) {scanf("%d",&x);b[i]=x;}//嗯。。发现直接输入会炸。。
    i=0;j=0;
    for (k=1;k<=n;k++)//循环轮数
        i=i+1;j=j+1;//i表示小A，j表示小B
        if (i>n1) i=1;//如果一旦超出，那么久重新开始循环
        if (j>n2) j=1;'//同上
        if (a[i]==0){//分类讨论:当小A出的是0(剪刀)时
            if (b[j]==1) s2=s2+1;//小B若是石头，则输
            if (b[j]==2) s1=s1+1;//小B若是布，则赢
            if (b[j]==3) s1=s1+1;//小B若是蜥蜴人，则赢
            if (b[j]==4) s2=s2+1;//小B若是斯波克，则输
        }
        if (a[i]==1){//当小A是1(石头)时
            if (b[j]==2) s2=s2+1;//小B若是布，则输
            if (b[j]==0) s1=s1+1;//小B若是剪刀，则赢
            if (b[j]==3) s1=s1+1;//小B若是蜥蜴人，则赢
            if (b[j]==4) s2=s2+1//小B若是斯波克，则输
        }
        if (a[i]==2){//当小A是2(布)时
            if (b[j]==0) s2=s2+1//小B若是剪刀，则输
            if (b[j]==1) s1=s1+1;//小B若是石头，则赢
            if (b[j]==3) s2=s2+1;//小B若是蜥蜴人，则输
            if (b[j]==4) s1=s1+1;//小B若是斯波克，则赢
        }
        if (a[i]==3){//当小A是3(蜥蜴人)时
            if (b[j]==0) s2=s2+1;//小B若是剪刀，则输
            if (b[j]==1) s2=s2+1;//小B若是石头，则输
            if (b[j]==2) s1=s1+1;//小B若是布，则赢
            if (b[j]==4) s1=s1+1;//小B若是斯波克，则赢
        }
        if (a[i]==4){//当小A是斯波克
            if (b[j]==0) s1=s1+1;//小B若是剪刀，则赢
            if (b[j]==1) s1=s1+1;//小B若是石头，则赢
            if (b[j]==2) s2=s2+1//小B若是布，则输
            if (b[j]==3) s2=s2+1//小B若是斯波克，则输;
        }
    }
    cout<<s1<<' '<<s2;//s1表示小A，s2表示小B
    return 0;
}
#小心直接复制掉坑哦~~
```