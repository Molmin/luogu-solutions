简单但有意思的题。

这篇题解可以算是记录了我的思维过程。

首先一个常见套路就是把答案序列看作一段 $0$，一段 $1$ 交替。

考虑需要满足什么条件。

对于一段 $0$，假设为 $l,r$，显然 $\forall i\in [l,r],a_i\in [L_{0,i},R_{0,i}]$ 且 $a_{l-1}\in [L_{1,i},R_{1,i}]$。

对于一段 $1$ 可以同理推出条件。

那么就可以考虑 $dp_{i,0/1}$，表示前 $i$ 位，答案第 $i$ 位是 $0/1$ 是否合法。

对 $dp_{i,0}$ 转移时可以尝试找一个 $j<i$ 使得 $dp_{j,1}=1$ 且 $(j,i]$ 这一段 $0$ 合法。如果能找到则 $dp_{i,0}=1$，否则 $dp_{i,0}=0$。

对 $dp_{i,1}$ 可以同理转移。

我们可以预处理 $pos_{i,0/1}$，表示从第 $i$ 位往后的连续 $0/1$ 最远可以延伸到什么位置。这个可以使用倍增或二分 $O(n\log n)$ 预处理。

然后就很容易 $O(n)$ 地进行 dp 了，总复杂度 $O(n\log n)$。

于是我点开官方题解，居然可以 $O(n)$？？？

关上题解又想了想，似乎可以从后往前考虑。把 $dp$ 的意义改为从第 $i$ 位往后的状态。

那么可以发现，$dp_{i,0}$ 可能的最优的转移点一定是最小的使得 $dp_{j,1}=1$ 的 $j$，因为如果从一个 $j'$ 可以转移到 $i$ 且 $j<j'$，那么从 $j$ 也一定能转移。对 $dp_{i,1}$ 同理。

也就是说，我们可以动态维护当前 $dp_{i,0}=1$ 的最小的 $i$ 以及 $dp_{i,1}=1$ 的最小的 $i$。只需考虑中间这一段是否合法，这可以在遍历的过程中也动态维护出来。这样就达到了 $O(n)$ 的复杂度。

参考代码（$O(n)$）：
```cpp
#include <bits/stdc++.h>
using namespace std;
#define N 100005
int n,m,mn[2],L1[2],R1[2],a[N],L[N][2],R[N][2],pr[N][2];bool fl,nw[2],tmp[2];
int main()
{
	scanf("%d %d",&n,&m);
	mn[0]=mn[1]=n+1;nw[0]=nw[1]=1;L1[0]=L1[1]=0;R1[0]=R1[1]=m; 
	for(int i=1;i<=n;++i)
		scanf("%d %d %d %d %d",&a[i],&L[i][0],&R[i][0],&L[i][1],&R[i][1]);
	for(int i=n;i;--i)
	{
		nw[0]&=a[i]>=L[i][0] && a[i]<=R[i][0];
		nw[1]&=a[i]>=L[i][1] && a[i]<=R[i][1];
		L1[0]=max(L1[0],L[i][1]);R1[0]=min(R1[0],R[i][1]);
		L1[1]=max(L1[1],L[i][0]);R1[1]=min(R1[1],R[i][0]);
		tmp[0]=nw[0] && a[i-1]>=L1[0] && a[i-1]<=R1[0];
		tmp[1]=nw[1] && a[i-1]>=L1[1] && a[i-1]<=R1[1]; 
		if(tmp[0]) pr[i][0]=mn[1];if(tmp[1]) pr[i][1]=mn[0];
		if(tmp[0]) mn[0]=i,nw[1]=1,L1[1]=0,R1[1]=m;
		if(tmp[1]) mn[1]=i,nw[0]=1,L1[0]=0,R1[0]=m;
	}if(mn[0]>1 && mn[1]>1) {puts("No");return 0;}puts("Yes");fl=mn[0]>1;
	for(int i=1;i<=n;i=pr[i][fl],fl^=1)
		for(int j=i;j<pr[i][fl];++j) printf("%d ",fl);return 0;
}
```