## 题目大意

给定整数 $n$，求 $n!$ 分解质因数后每个质因数的次数。

## 解法分析

解法一：

求出 $n!$ 后分解质因数。但是 $n\le 100$ 的数据范围注定了如果这么做要高精。

解法二：

对 $1\sim n$ 分解质因数，结果存一起，就是 $n!$ 的质因数集合。

综合码量与难度，我们决定采用第二种方法。

***

**若无特殊说明，下文中集合皆为可重集。**

简单证一下 $n$ 的质因数集与 $m$ 的质因数集的并集就是 $nm$ 的质因数集。

对于可重集 $s^x$，其表示 $x$ 的质因数。如 $s^{24} = \{2,2,2,3\}$。易得有

$$\prod_{i=1}^{card(s^x)}s^x_i = x$$

不难看出

$$(\prod_{i=1}^{card(s^x)}s^x_i \ \ ) \ \times (\prod_{i=1}^{card(s^y)}s^y_i \ \ ) = xy$$

记 $s^x$ 与 $s^y$ 的并集为 $s^{x, y}$，上式可转化为

$$\prod_{i=1}^{card(s^{x, y})}s^{x, y}_i = xy$$

得到 $s^{x, y} = s^{xy}$。

***

接下来质因数分解的过程其实就很简单了。结果我们用 `map` 解决。`map[i] = j` 质数 `i` 的次数为 `j` 。剩下的过程就是一一枚举，如整除就除。需要注意的是最后如果原数不为 $1$ 要将其添加进 `map`。

分解质因数代码：

```cpp
map<int, int> res;
res.clear(); // 清空
for (int i = 2; i <= x; i++) { // 要求 n!，所以枚举 2 ~ n
    int c = i; // 复制 i
    for (int j = 2; j * j <= c; j++) {
        if (c % j == 0) {
            if (res.count(j)) res[j]++;
            else res[j] = 1;
            c /= j;
            j--; // 有可能c除以j的结果还整除j，需要j--，再进行一次判断
        }
    }
    if (c != 1) // 特判如果c不为0
        if (res.count(c)) res[c]++;
        else res[c] = 1;
}
```


## 本题坑点

**输出格式。** UVA的输出格式一直非(chou)常(ming)严(zhao)谨(zhu)。

题目翻译没有讲清楚，这里说一下：

对于每个测试点，先输出 `n! = `，然后从小到大输出质因数次数，输出每个数占 $3$ 格对齐，输出 $15$ 个数以后换行，继续对齐第一行第一个数。

## 完整代码

```cpp
#include <bits/stdc++.h>

using namespace std;

int primes[168] = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997};

map<int, int> getres(int x) {
    map<int, int> res;
    res.clear();
    for (int i = 2; i <= x; i++) {
        int c = i;
        for (int j = 2; j * j <= c; j++) {
            if (c % j == 0) {
                if (res.count(j)) res[j]++;
                else res[j] = 1;
                c /= j;
                j--;
            }
        }
        if (c != 1) 
            if (res.count(c)) res[c]++;
            else res[c] = 1;
    }
	return res;
}

void output(int x, map<int, int> mp) {
	typedef map<int, int>::iterator it;
	int l;
	for (it i = mp.begin(); i != mp.end(); i++) {
		l = i->first;
	}
	cout << setw(3) << x << "! =";
	int cnt = 1;
	for (int i = 0; i < 27; i++, cnt++) {
		cout << setw(3) << (mp.count(primes[i]) > 0 ? mp[primes[i]] : 0);
		if (primes[i] == l) break;
		if (cnt == 15) {
			cout << endl << "      ";
			cnt = 0;
		}
	}
	cout << endl;
}

int main() {
	int n;
	while (cin >> n && n) {
		output(n, getres(n));
	}
	
	return 0;
}

```

可能比较乱，得理一下。