~~代码有点长，介意的小伙伴请跳过函数部分~~

咳咳，进入正题。这道题本蒟蒻的思路大致是：将对角线上的一个字母与非对角线上的一个字母储存起来，再一个一个查找对角线上的字母和非对角线上的字母，如果查找到的字母与已储存的字母不同，就输出“NO”，如果都相符，输出“YES”。

**注意点：**

 _**1.对角线有两条（从左上到右下的对角线和从右上到左下的对角线），所以要一一判断。**_ 

 _**2.有可能整个二位数组中的字母都是一样的，但这并不能构成一个“X”，需要剔除。**_ 

本蒟蒻只能为各位大佬提供如上简陋的思路了，另附AC代码详解：
```cpp
#include<bits/stdc++.h>//万能头
using namespace std;
char a[1001][1001];//定义二位数组
int n;
inline int read(){//快读，比cin和scanf都要快（NOIP利器）
    int X=0,w=0; char ch=0;
    while(!isdigit(ch)) {w|=ch=='-';ch=getchar();}
    while(isdigit(ch)) X=(X<<3)+(X<<1)+(ch^48),ch=getchar();
    return w?-X:X;
}
void p_x(){//自己写的输出函数，比较方便
    printf("NO");//输出NO的函数
    exit(0);//结束整个程序（如果用return 只能终止这个函数）
}
void p_y(){//输出NO的函数
    printf("YES");
    exit(0);
}
int main(){
    char c1,c2;
    n=read();//用快读读入n
    for(int i=1;i<=n;i++)
        for(int j=1;j<=n;j++){
        cin>>a[i][j];//读入二维数组
    }
    c1=a[1][1];//将对角线上的某一个字母储存（不一定是a[1][1]，只要是在对角线上的就行）
    c2=a[1][2];//将非对角线上的某一个字母储存（只要是非对角线上的就行）
    int f=0;
    for(int i=1;i<=n;i++){//注意这个点！有可能整个二位数组都是一个相同的字母！但它并不能组成一个“X”
    	for(int j=1;j<=n;j++){
    		if(a[i][j]!=c1){//如果有一个字母不同于已储存的字母
    			f=1;//代表整个二维数组不是同一个字母
    			break;
			}
		}
		if(f==1)break;
	}
	if(f==0){//如果都是同一个字母
		p_x();//输出NO
	}
    for(int i=1;i<=n;i++){
    	for(int j=1;j<=n;j++){
    		if(i==j){//如果找到这个字母在从左上到右下的对角线上
    			if(a[i][j]!=c1)//如果不同于已储存的在对角线上的字母
    			p_x();//输出NO
			}
			else if(j==n-i+1){//如果找到的这个字母在右上到左下的对角线上
				if(a[i][j]!=c1)//同上
				p_x(); 
			}
			else {//如果这个字母不在对角线上
				if(a[i][j]!=c2)//如果这个字母不同于已储存的在非对角线上的字母
				p_x();//输出NO
			}
		}
	}
	p_y();//经过一系列考验，输出YES
    return 0;//养成好习惯
}
```
