## 思路

考虑让越大的数当众数的次数越多，则显然最大的数都在前几个，如样例中：

```
3 3 * * * *
```

为了让这个最大的 $3$ 当众数次数最多，显然别的数出现次数不能大于它：

```
3 3 2 2 1 1
```

但是因为 $1$ 只有一个，所以应该为：

```
3 3 2 2 1 *
```

那么后面考虑第二大的 $2$，同理可推得数列样貌：

```
3 3 2 2 1 2
```

## 优化

显然直接硬模拟会得到万绿丛中一点红，考虑线性优化。

不难发现，所有能成为众数的数必然是呈单调队列状，考虑按照每一个众数取值进行分块，如在样例中：

```
| 3 3 2 2 1 | 2 |
```

分为多个块考虑。

每一个数能成为众数的次数就是每一个块的大小，其中由两部分组成：

1. 还剩下的数量大于等于众数还剩下的数量的
2. 还剩下的数量小于众数还剩下的数量的

设该数字目前剩下数量为 $a_i$，则这个数的贡献为：

$$i\times(\sum_{j=i}^{n}a_i(a_i\leq a_j)+\sum_{j=i}^{n}a_j(a_i>a_j))$$

大于 $a_i$ 的很好统计，因为本来大于它的就应该都在它的后面；而小于它且还剩下的，就是一个区间前缀和的成果。这两个都符合单调队列的性质。

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
ll n , a[100005] , ans , lev , buck[100005] , f[100005] , bef , bk[100005];
int main()
{
	cin >> n;
	for ( int i = 1; i <= n; i++ )	cin >> a[i] , buck[a[i]]++;
	for ( int i = 1; i < 100005; i++ )	f[i] = f[i - 1] + buck[i] * i;//前缀和
	for ( int i = 100003; i >= 0; i-- )	bk[i] = buck[i] + bk[i + 1];//大于i且在其后的数量
	for ( int i = 1; i < 100005; i++ )	buck[i] += buck[i - 1];//桶子
	for ( int i = n; i >= 1; i-- )
	{
		if ( a[i] <= bef )	continue;buck[a[i] - 1] - buck[bef] ) * bef <<endl;
		ans += ( bk[a[i]] * ( a[i] - bef ) + f[a[i] - 1] - f[bef] - ( buck[a[i] - 1] - buck[bef] ) * bef ) * i;
		bef = a[i];
	}
	cout << ans << endl;
	return 0;
}
```
