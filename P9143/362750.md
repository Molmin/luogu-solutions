## Part $0$ 题意理解

给定序列 $a$，求一个序列 $b$，满足 $1\sim n$ 各在 $b$ 中出现 $a_i$ 次，使得 $b$ 每个前缀的众数之和取得最大值，若有多个众数取最大的。

---

**若无特殊说明，以下 $T \subset S$ 为 $S$ 集合包含 $T$，即 $T$ 是 $S$ 的子集，不保证 $S\neq T$。**

## Part $1$ 思想转换

手玩一下可以发现一个显然的贪心策略：**从后往前扫，如果当前这个位置还能加就加上**。以样例为例：

$$
\begin{aligned}
&\{1,3,2\}:\{\}\\
&\{0,2,1\}:\{3,2,1\}\\
&\{0,1,0\}:\{3,2,1,3,2\}\\
&\{0,0,0\}:\{3,2,1,3,2,2\}\\
\end{aligned}
$$

每一次操作都会增加一段严格递减的连续段。我们考虑这一段的贡献，我们把这一段所有元素记为 $T$；前面所有数中，出现次数最多的，我们记为 $S$；则有 $T\subset S$。浅证一下：上一次没有的，这一次也没有；上一次有的，这一次有可能有也有可能没有。所以，**每次取到的数都是上一次的子集**。形象地画个图：

![](https://cdn.luogu.com.cn/upload/image_hosting/79mdzhh9.png)

从左到右每块表示当前取到数的集合，由于每两个都是包含关系，大小单调不增，所以**以这一段任意位置为结尾的前缀的众数 $\in$ 这一段的数**。又因为我们众数取最大值，所以这一整段的众数就是这一段第一个取到的数。仍以样例为例子：

$$3,2,1;\ 3,2;\ 2$$

可以看到，$b$ 被分成了三段。第一段有 $3$ 个，开头为 $3$；第二段有 $2$ 个，开头为 $3$；最后一段有 $1$ 个，开头为 $2$。所以总和为 $3\times 3+2\times 3+1\times2=17$。

## Part $2$ 算法优化

接下来我们有了一个明确的思路：对于每一个 $1\le i\le n$，计算以 $i$ 为开头的所有段的长度总和。

### 算法 $1$

从后往前枚举，对于当前点 $i$，其贡献为 $\sum\limits_{j=1}^i \min(a_j,a_i)$。可以这样理解：因为当前点要取完，所以前面的每个点最多被取到 $a_i$ 次，于是每个点贡献为 $\min(a_j,a_i)$，求和即可。当然，每次统计后要更新 $a$ 序列，对于 $1\le j\le i$ 将 $a_j\gets \max(a_j-a_i,0)$。这个东西可能可以线段树实现但是我不会线段树，所以赛时放弃了。

### 算法 $2$

队友 $\textrm{i\red{rris}}$ 给出了另外一种方案令我豁然开朗：排序。

将 $a_i$ 排序，并记录原来在 $i$ 位置的排序后在 $b_i$，排序后 $i$ 点表示的原数是 $c_i$，$b_i,c_i$ 是互逆的排列。排序后，对于每个点，计算其贡献。显然的，对于前面的点，总和为这一段的和；对于后面的点，每个点数值都大于等于自己，根据算法 $1$ 取 $\min$，所以贡献为 $(n-b_i)a_ic_i$。

那么怎么处理减的问题呢，对于当前点，前面的点显然都会变成 $0$，这个我们打个标记，记录当前最远的变成 $0$ 的数，因为所有 $0$ 构成了排序后 $a$ 的前缀，如果当前遍历到为 $0$ 的数直接跳过；对于后面的，我们记录当前偏移量 $f$（即没被减完的数比较原来的数减去的数量），然后在算结果的时候减一下就可以。$f$ 每次对 $a_i$ 取最大值。

后半部分的复杂度应该是 $\Theta(n)$ 的，算上排序是 $\Theta(n\log n)$。当然，题面保证了 $a_i$ 的范围，所以我们可以使用桶排序将其优化至严格线性。~~因为不想实现就没实现~~。

## Part $3$ 代码展示

非常简短的代码，甚至不到 $800$ B。

```cpp
#include <bits/stdc++.h>
#define int long long

using namespace std;

const int maxn = 1e5 + 10;

int n;
pair<int, int> a[maxn];
int b[maxn];
int s[maxn];
int ans, f, last = 1;

int sum(int l, int r) {
    return s[r] - s[l - 1] - (r - l + 1) * f;
}

signed main() {
    cin >> n;
    for (int i = 1; i <= n; i++) {
        cin >> a[i].first;
        a[i].second = i;
    }
    sort(a + 1, a + 1 + n);
    for (int i = 1; i <= n; i++) b[a[i].second] = i, s[i] = s[i - 1] + a[i].first;
    for (int i = n; i; i--) {
        int p = b[i];
        if (p < last) continue;
        ans += sum(last, p) * a[p].second + (n - p) * (a[p].first - f) * a[p].second;
        f = max(f, a[p].first);
        last = p + 1;
    }
    cout << ans;
    return 0;
}
```