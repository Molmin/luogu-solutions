## 题意理解

给一个正整数 $n$ ，再给出 $n$ 个数 $a_1,a_2,\cdots,a_n$
 表示有 $a_i$ 个整数 $i$ ，请你用这些数字构造一个数列，使每个子数列的众数最大。若有多个数出现次数最多，则其中最大的数为其众数。这里的子数列就是从左向右数的，第一个子数列是前一个数，第二个是前两个数，以此类推。
 
## 方法阐述
 
可以研究一下样例解释看出最优解法，模拟一下也比较好理解，简单讲就是从大到小把每个能拿的数都拿一遍，具体证明解释可以看 @TernaryTree 大佬的题解（我不会证）。

示例，左侧代表每个数字的个数，右侧代表生成的数列：
$$(1,3,2,3):()$$
$$(0,2,1,2):(4,3,2,1)$$
$$(0,1,0,1):(4,3,2,1,4,3,2)$$
$$(0,0,0,0):(4,3,2,1,4,3,2,4,2)$$

## 代码

首先是最直接的模拟，蒟蒻非常自信的。
```cpp
#include <bits/stdc++.h>
using namespace std;

long long n;
long long a[100005];
long long ans;//记录答案

signed main(){
    
    scanf("%lld",&n);
    for (int i=1;i<=n;i++)
        scanf("%lld",&a[i]);//输入
    while (1){
        bool f=1;//判断还有没有数字可以取用
        long long k=0,s=0;//众数以及众数个数
        for (int i=n;i>=1;i--){
            if (a[i]>0 && f){
                k=i;//这是最大的，本轮s个众数都是它
                s++;
                f=0;//还有数字
            }
            else if (a[i]>0)
                s++;//这个可以用
            a[i]--;//每个数字都用一遍
        }
        ans+=s*k;//答案加
        if (f) break;//没有数字了，结束
    }
    printf("%lld",ans);
    return 0;
    
}

```
两层循环复杂度高达 $10^{10}$ ，显然超时。思索后发现这里可以用前缀和优化。

示例：
$$(1,4,2,3):()$$
$$ans+0$$
$$(1,4,2,0):(4,4,4)$$
$$ans+(3 \times 4)$$
$$(1,4,0,0):(4,3,4,3,4)$$
$$ans+(2 \times 4)$$
$$(1,0,0,0):(4,3,2,4,3,2,4,2,2)$$
$$ans+(3 \times 4+1 \times2)$$
$$(0,0,0,0):(4,3,2,1,4,3,2,4,2,2)$$
$$ans+(1 \times 4)$$
从大到小加入数字，每加入一个则将 $u$ 加一，如果 $u \geqslant a_{i}$ ，有比 $i$ 大的众数，数字 $i$ 不加入众数计算，$u$ 不变，众数不加，否则更新 $u$ 并更新答案。

```cpp
#include <bits/stdc++.h>
using namespace std;

long long n,ans;
long long a[100005];
long long k[100005];

signed main(){

    scanf("%lld",&n);
    for(long long i=1;i<=n;i++)
        scanf("%lld",&a[i]);
    for(long long i=n,u=1;i>0;i--){
        for (u;u<=a[i];u++)//a[i]>u时，i为众数
            k[u]=k[u-1]+i;//新加入u个数时，k[u]为这部分的答案
        ans+=k[a[i]];//答案更新
    }
    printf("%lld",ans);
    return 0;
    
}

```
希望各位大佬多多指教。