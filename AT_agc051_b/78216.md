## 题意翻译

> 有数个大头钉在二维平面上，有四个人从不同的角度观察它们，重叠的点视为一个，是否可能有一个人观察到的大头钉数量远多余其他人？

让我们把大头钉的位置简化为二维坐标上的点。四个人观察的角度如下：

* ```A``` 从左往右观察。即所有 $y$ 坐标相同的点是重叠的。
* ```B``` 从左下往右上观察。即所有 $x$ 坐标与 $y$ 坐标相减的值相同的点是重叠的。
* ```C``` 从下往上观察。即所有 $x$ 坐标相同的点是重叠的。
* ```D``` 从右下往左上观察。即所有 $x$ 坐标与 $y$ 坐标相加的值相同的点是重叠的。

![](https://cdn.luogu.com.cn/upload/vjudge_pic/AT_agc051_b/cf17bb504667e73875a26607be26bad6c893bba0.png)

令 ```A, B, C, D``` 观察到的大头针数量为 $a, b, c, d$，你需要构造一组大头针的排布，满足以下一些条件：

* $d \geq 10 \times \max\{a, b, c\}$
* 大头钉的数量不多于 $10^5$ 个。
* 大头钉的坐标均为 $[0, 10^9]$ 内的整数。
* 不存在两个坐标相同的大头钉。

没有输入，直接输出一组解。

## 思路

考虑 ```A``` 的视角，因为 ```D``` 看到的点是 $\max\{a, b, c\}$ 的十倍，所以 ```A``` 每看到一个点就至少有九个点被挡住了。

同理 ```B, C``` 视角也有至少有九成的点被挡住了。

因此，可以令 $\vec{i}, \vec{j}, \vec{k}$ 分别表示与 $y = 0, y = x, x = 0$ 平行且长度不为零的向量（即与 ```A, B, C``` 视线平行的向量），构造一个如下的向量集合 / 点集。

$$\left\{ p\vec{i} + q\vec{j} + r\vec{k}|0\leq p, q, r < 10 \right\}$$

由上可知，只要这个集合没有重复元素，就有 ```A, B, C``` 视角中九成的点被挡。

例如考虑 ```A``` 视角时，无论 $p$ 的大小如何变化，其看到的点不会变化，而 $p$ 可取的数有 $10$ 个，故有九个点被遮挡。```B, C``` 视角同理。

因而此时只要 ```D``` 能看到所有的点就是一组解。

令 $A = \left| \vec{i} \right|, B = \left| \vec{j} \right|, C = \left| \vec{k} \right|$，以上命题等价于下列两个集合没有重复元素：

$$S=\left\{\left(pA + qB, qB + rC\right) | 0\leq p, q, r < 10\right\}$$
$$T=\left\{pA + 2qB + rC | 0\leq p, q, r < 10\right\}$$

因为有 $0\leq p, q, r < 10$ 的限制，可以考虑十进制，即令 $A = 1, B = 100, C = 10$，那么 $pA$ 控制个位数，$rC$ 控制十位数，$qB$ 控制百位数字，因此集合 $S$ 中不会有重复元素。在集合 $T$ 中，$qB$ 控制百位和千位数字，所以 $T$ 中也不会有重复元素。

注意，这里不能让 $qB$ 控制个位或者十位，因为在集合 $T$ 的元素中可能影响到后面一位。

还有一种思路，在 $\left[ 1, \dfrac{5\times 10^8}{9}\right]$ 内随机生成 $A, B, C$，这样有极大的概率可以使得集合 $S, T$ 没有重复元素。事实上，这也是 Official Editorial 中的做法。


```
// Solution 1
	A = 1, B = 100, C = 10;
	For (i, 0, 9) For (j, 0, 9) For (k, 0, 9)
		P.emplace_back (A * i + B * j, B * j + C * k);
	cout << P.size () << endl;
	for (auto& Now : P) cout << Now.first << ' ' << Now.second << endl;
```

```
// Solution 2
	A = Rnd () % 55555555, B = Rnd () % 55555555, C = Rnd () % 55555555;
	For (i, 0, 9) For (j, 0, 9) For (k, 0, 9)
		P.emplace_back (A * i + B * j, B * j + C * k);
	cout << P.size () << endl;
	for (auto& Now : P) cout << Now.first << ' ' << Now.second << endl;
```