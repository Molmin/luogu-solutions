## Section 0
为啥这个题没人写题解啊。
## Section 1
首先考虑能不能在线用线段树这类东西做。

考虑怎么快速合并两个区间的答案，好像并不能快速合并两个区间的答案。

于是我们先考虑一个（不是正解）的暴力插入删除做法，也就是莫队。
## Section 2
因为是可以离线的区间查询，我们战术来一发莫队。

先不管 $10^6$ 能不能过去，考虑怎么维护加数和删数。

我们发现加数的过程其实就是合并极长段的过程，我们是可以 $O(1)$ 做的。

具体上就是维护每个数所在的极长段的两个端点，然后合并新插入的数两段的数，和第十分块的那个维护比较像。

但是删除贼麻烦，因此只能回滚莫队。

然后我们就可以发现大常数 $O(n\sqrt m)$ 显然过不去。

这个时候我们突然发现给的最大区间长度 $10$ 压根没用，显然这不是正解。
## Section 3
然后我就不会了……去看了一眼官方题解，get 到了关键字**扫描线**。

我们考虑对于每个固定的 $l$ 分别挪 $r$ 的端点，这样就只有加入没有删除了，然而复杂度也爆炸了。

但是，我们可以将所有的 $l$ 一起处理，复杂度就没爆炸了！

然后考虑怎么一起处理。我们发现 $l$ 越小，新增一个数的合并长度就越大。由于合并长度最大只有 $10$，我们可以维护这个数加入之前所有数的**最后出现位置** $lst$，然后暴力移动端点来搞。

这里要注意区间最多只能延伸到这个数上一次出现的位置 $lst_{a_i}$，不然根本没插入。

最后我们就可以对一个 $r$ 得到几段 $l$ 的插入效果，对于每一段开个树状数组维护左边删除的部分，右边删除的部分，整体加入的部分即可。

现在的时间复杂度是 $O(nk\log n+m\log n)$，其中 $k=10$。

虽然常数并不是很小（这个 $10$ 或许接近 $30$），但是可以通过。
## Code
没卡常就最优解了甚至领先了第二名 $0.5$ 秒多……

感觉自己代码挺丑的，那就给个核心部分吧。

```cpp
	for(int i=1,l,r; i<=n; ++i) 
	{
		int L=lst[a[i]],R=i,SL=0,SR=0,X=R-1,sl=0,sr=0;
		lst[a[i]]=i,l=r=a[i];
		int C=0;
		while((sl<=10&&lst[l-1]>L)||(sr<=10&&lst[r+1]>L))
		if(sr>10||(sl<=10&&lst[l-1]>lst[r+1])) //左侧延伸
		{
			X=lst[l-1];
			while(lst[l-1]>=X&&sl<=10) --l,++sl;
			(SL<=10)&&(Add(tree[SL],X+1,R,-1),0),
			(SR<=10)&&(Add(tree[SR],X+1,R,-1),0),
			(SL+SR+1<=10)&&(Add(tree[SL+SR+1],X+1,R,1),0),
			R=X,SL=sl,SR=sr;
		}
		else if(sl>10||lst[l-1]<=lst[r+1])//右侧延伸
		{
			X=lst[r+1];
			while(lst[r+1]>=X&&sr<=10) ++r,++sr;
			(SL<=10)&&(Add(tree[SL],X+1,R,-1),0),
			(SR<=10)&&(Add(tree[SR],X+1,R,-1),0),
			(SL+SR+1<=10)&&(Add(tree[SL+SR+1],X+1,R,1),0),
			R=X,SL=sl,SR=sr;
		}
		(SL<=10)&&(Add(tree[SL],L+1,R,-1),0),
		(SR<=10)&&(Add(tree[SR],L+1,R,-1),0),
		(SL+SR+1<=10)&&(Add(tree[SL+SR+1],L+1,R,1),0);
		for(auto i:v[i]) for(int j=1; j<=10; ++j) ans[i.id][j]=find(tree[j],i.v);
	}
```