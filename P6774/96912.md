这个是标程做法，但是实现起来比直接分块要麻烦所以没有写代码（其实就是复述了一遍 ppt /kk，如果有误麻烦指出）。

如非特殊说明，复杂度分析认为 $n,m$ 同阶。

我们考虑对平面建立树套树（线段树套动态开点线段树）。那么内层的每个节点代表了平面中的一个矩形，为了之后的计算，我们需要维护树套树中每个矩形内部的答案。

![](https://s1.ax1x.com/2020/08/24/dsTlgU.md.png)

如图，假设我们现在有一个长和宽均不为 $1$ 的矩形（当至少一维为 $1$ 时答案一定为 $0$），我们想要求出这个矩形的答案（我们认为左下角为较小的下标），我们把这个矩形一分为四，并且我们已经递归得出了每个子矩形的答案，那么我们有：
$$
\begin{aligned}
ans(ABCD)=&ans(AB)+ans(CD)+ans(AC)+ans(BD)\\
-&ans(A)-ans(B)-ans(C)-ans(D)+siz(A)\cdot siz(D)
\end{aligned}
$$
其中 $siz(A)$ 是 $A$ 中包含点的数量。这个东西本质就是枚举任意两块，求出块之间的答案，再求出块内部的答案。由于 $ans(AB)$ 已经包含了 $ans(A)+ans(B)$，所以这里要容斥捡回去。**本题可以这样分治的关键在于 $A$ 和 $D$ 的贡献是平凡的。**

子矩形的 $ans$ 我们可以通过子树查询得到，$siz$ 我们只需要顺便维护就好了。



现在我们考虑回答询问。首先，我们需要用 $O(\log^2n)$ 个在树套树中的矩形定位出询问矩形，如下图所示：

![](https://s1.ax1x.com/2020/08/24/dsjK6x.md.png)

其中每一个 $A_{i,j}$ 都是树套树中的矩形。那么我们用类似上面的容斥来计算答案：即求出每行和每列的答案，加上行列均不同的两块的贡献，再减去每一块内部的答案。那么有
$$
\begin{aligned}
ans(1\dots w,1\dots h)=&\sum\limits_{i=1}^w\sum\limits_{j=1}^hsiz(i,j)\sum\limits_{c=i+1}^w\sum\limits_{d=j+1}^hsiz(c,d)\\
+&\sum\limits_{i=1}^wans(i,1\dots h)+\sum\limits_{i=1}^hans(1\dots w,i)\\
-&\sum\limits_{i=1}^w\sum\limits_{j=1}^hans(i,j)
\end{aligned}
$$
第一行和第三行我们直接在树套树上查询就可以了，注意第二行，我们发现这实际上仍旧是一个值域范围内的区间顺序对，但是这里值域范围一定出现在了树套树上，即只有 $O(n\log n)$ 种。并且如果这是一个 $w\times n$ 的矩形，由于我们给定的是一个排列，所以这个矩形内的数只有 $w$ 个。这样我们在这样的矩形查一次的复杂度是 $O(\sqrt w)$ 的，由于每一个长度的矩形只会出现 $O(1)$ 次，所以一次查询的总复杂度是 $O(\sqrt n+\sqrt{\frac{n}{2}}+\sqrt{\frac{n}{4}}+\dots)=O((1+\frac{1}{\sqrt 2}+\frac{1}{2}+\dots)\sqrt n)=O(\sqrt n)$ 的。预处理的复杂度类似，所以这个算法的总复杂度是 $O(n\log^2n+T)$（$T$ 指区间逆序对复杂度）的，空间上如果用一般的树套树也是 $O(n\log^2n+T)$ 的。据官方题解说也可以做到一个 $\log$ 或者线性。

据 lxl 说，这样分治套分块似乎当分块的复杂度比 $O(n^{1.5})$ 低时才会更优秀。