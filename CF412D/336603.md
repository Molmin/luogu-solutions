看这个题目第一眼，我还以为是拓扑排序。

构造一个 DAG ，如果 $a$ 欠了 $b$ 钱，说明 $b$ 得在 $a$ 前面，即让 $b$ 往 $a$ 连边。

然后在这个 DAG 上跑拓扑排序即可。

然后手模样例 $2$ 会发现他们的欠钱关系中有**环**。

分析样例 $2$ ，会发现虽然 $2$ 欠了 $3$ 钱，但是 $2$ 只要没有**正好**在 $3$ 前面进办公室就**不会**出事。

这启发我们可以仅针对每一个人，让欠他钱的人先进去就够了。

具体实现起来，如果 $a$ 欠了 $b$ 钱就让 $a$ 往 $b$ 连边，跑一次 DFS ，让所有**没入栈的节点**入栈，在跑完所有会欠他钱的节点后，将这个节点加入 `ans` 数组（可以理解成二叉树的后序遍历）。

我想到这里的时候，第一反应是：这不就是拓扑排序吗？

但是它和拓扑排序最大的差异是：

拓扑排序要求绝对纯洁（没欠任何人钱）的节点作为开头，但是在数据中可能不存在这种情况。

而这个 DFS 它只考虑到对于没访问过的节点，只加入**直接欠他钱的人**而不用考虑**欠了“直接欠他钱的人”的钱的人**。

因为只要一个人没有在**直接欠他钱的人**之前拿钱，那他就啥事没有。

[AC 代码](https://www.luogu.com.cn/paste/sujevqrx)