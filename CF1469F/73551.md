先考虑这样一个事情：我们如何实现加入一条链的操作。

从 ~~样例分析~~ 严谨的分析中我们可以知道：必然是把一条链的 **重心（中点）** 接过去，这样能保证产生的那些深度都最浅。

假设我们接上去的点（树中的）的深度是 $x$，链的长度为 $l$，那么我们要实现的操作是：

- 将深度为 $x$ 的点减少一个（染黑了）。

- $(x+1,x+\lfloor \frac{l-1}{2}\rfloor\ ]\cap \mathbb Z$ 深度的白点各增加一个。

- $(x+1,x+(l-1-\lfloor \frac{l-1}{2}\rfloor)\ ]\cap \mathbb Z$ 深度的白点各增加一个。

这题时限开了四秒，所以我们自然可以大力线段树，维护每个深度的点出现次数。

当然这里介绍一种十分巧妙的差分做法，是 Rank 1 那位 ~~凑DD~~ @jiangly 的写法。

因为是区间加操作，可以用查分来实现，**只会往后更新** 的性质使得我们可以一边做一边处理前缀和得到当前真正的白点个数。

这样就可以使得总复杂度为线性。


```cpp
for(i=0,j=1;i<N;i++)
    {
        sum+=s[i];
        s[i+1]+=s[i];
        if(sum+s[i+1]>=k){ans=i+1;break;}
        for(;j<=n&&s[i];j++)
        {
            s[i+2]+=2;
            s[i+2+(l[j]-1>>1)]--;
            s[i+2+(l[j]-1-(l[j]-1>>1))]--;
            s[i]--;
            sum--;
        }
    }
```

那么现在，我们需要知道操作的策略。

考场 yy 出来的结论是从大到小排序（但是没写，因为时间不够了），这里看能不能说清。

考虑当前要加进去的两条链，它们的长度分别为 $l_1,l_2$，且 $l_1<l_2$。

设当前深度最小的点深度为 $x$。

若是先加入 $l_1$，那么此时 $x$ 深度的点会减少一个，假设减少至 $0$，那么之后加入 $l_2$ 的时候，只能选取大于 $x$ 深度的点作为接入口，此时产生的点集明显 **劣于** 两条链顺序交换产生的点集。


比如 $l_1=3,l_2=5$ 的情况。

![](https://cdn.luogu.com.cn/upload/image_hosting/spqfcn98.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/md0tuopg.png)

题目中因为有说 **不用全部加入**，所以可以在找到深度最小的 **白点个数大于等于 k** 的地方直接跳出。

要注意一点：因为一条链会往后扩展 $\frac{l-1}{2}$ 左右的深度的点，而链的总数是 $n$ 条，粗略算一下的话最大深度会是 $k\cdot n$，这个 $k$ 大概是 $[1,3]$ 之间的某个实数，具体的我没算，本体也不卡空，我就直接开了四倍。