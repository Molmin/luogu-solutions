## 思路

简单博弈区间 dp。

设 $f(l,r)$ 表示区间 $[l,r]$ 的结果。1 表示先手必胜。0 表示平局。2 表示后手必胜。

**按顺序**进行以下掘厕：

- 先手选取 $l$，后手不管是选取 $l+1$ 还是 $r$ 都字典序大于先手，
	此处有两种局面两种情况：
	- 后手选取 $l+1$：
		- 要么在前几位决出胜负，即 $f(l+2,r)$ 这个状态先手必胜；
		- 要么前几位一样并且这一位先手字典序小，即 $f(l+2,r)$ 这个状态平，且 $s[l]<s[l+1]$。
	- 后手选取 $r$：
		- 要么在前几位决出胜负，即 $f(l+1,r-1)$ 这个状态先手必胜；
		- 要么前几位一样并且这一位先手字典序小，即 $f(l+1,r-1)$ 这个状态平，且 $s[l]<s[r]$。
		
	两种局面先手都必胜，先手就一定会选取 $l$，于是必胜。
- 先手选取 $r$，后手不管是选取 $l$ 还是 $r-1$ 都烂（依然有两种局面两种情况，不再赘述），那么先手就一定会选取 $r$。
- 先手选取 $l$，后手不管是选取 $l+1$ 还是 $r$ 都不能取胜，
	此处有两种局面两种情况：
	- 后手选取 $l+1$：
		- 要么在前几位决出胜负，即 $f(l+2,r)$ 这个状态先手必胜；
		- 要么前几位一样并且这一位先手字典序小或相等，即 $f(l+2,r)$ 这个状态平，且 $s[l]<=s[l+1]$。
	- 后手选取 $l+1$：
		- 要么在前几位决出胜负，即 $f(l+1,r-1)$ 这个状态先手必胜；
		- 要么前几位一样并且这一位先手字典序小，即 $f(l+1,r-1)$ 这个状态平，且 $s[l]<=s[r]$。
		
	两种局面先手都必胜或平，先手就一定会选取 $l$，于是平。
- 先手选取 $r$，后手不管是选取 $l$ 还是 $r-1$ 都不能取胜，那么先手就一定会选取 $r$。
- 否则先手必败。

CF 场上哪有时间找性质（，就这么硬刚（

虽然先手的确不可能必败。

## code

```cpp
#include<stdio.h>
int t,n,ans[2222][2222];char s[2222];
struct __readt__{inline __readt__(){scanf("%d",&t);}}_readt___;
inline int dfs(const int&l,const int&r)
{
	if(l>r)return 0;
	if(~ans[l][r])return ans[l][r];
	int x=dfs(l+2,r),y=dfs(l+1,r-1),z=dfs(l,r-2);
	if(((x==1)||(!x&&s[l]<s[l+1]))&&((y==1)||(!y&&s[l]<s[r])))
		return ans[l][r]=1;
	if(((z==1)||(!z&&s[r]<s[r-1]))&&((y==1)||(!y&&s[r]<s[l])))
		return ans[l][r]=1;
	if(((x==1)||(!x&&s[l]<=s[l+1]))&&((y==1)||(!y&&s[l]<=s[r])))
		return ans[l][r]=0;
	if(((z==1)||(!z&&s[r]<=s[r-1]))&&((y==1)||(!y&&s[r]<=s[l])))
		return ans[l][r]=0;
	return ans[l][r]=2;
}
main()
{
	scanf("%s",s);for(n=0;s[n];++n);
	for(int i=0;i<n;++i)for(int j=i;j<n;ans[i][j++]=-1);
	int x=dfs(0,n-1);
	if(!x)printf("Draw\n");
	if(x==1)printf("Alice\n");
	if(x==2)printf("Bob\n");
	if(--t)main();
}
```