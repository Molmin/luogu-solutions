# 题面

[题目传送门](https://www.luogu.com.cn/problem/CF1231C)

**题目大意：**

给定一个 $n\times m$ 的矩阵，问能否在每个 $0$ 的位置更改，使其变成一个每行每列均为递增的矩阵，若能输出最大和，不能则输出 $-1$。

# 思路

每行每列都要从左到右从上到下递增，那么每到一个 $0$ 的位置就能知道若要使这个数最大则肯定是越贴近下一个大数越好。比如：$1,2,0,6$ 这段序列，要使其成为递增序列可以将 $0$ 改成 $3$，$4$ 或 $5$。但要满足和最大的话明显要选最贴近 $6$ 的数 $5$。也就是说若 $a_{i,j}=0$ 那么 $a_{i,j}$ 就要改成 $\min(a_{i+1,j},a_{i,j+1})-1$，最后看看填完的矩阵满不满足递增条件就行啦。

你以为这就结束了？

你的第一反应是不是递增条件判断和完善矩阵时的 $i$ 和 $j$ 都从 $1$ 开始？那就错了。比如我们来看看样例 $1$ 的矩阵，如果我们下标从 $1$ 开始的话就会出现 $0$ 的右边或下面也会是 $0$ 的情况，那这个数就会变成 $-1$ 从而导致答案不正确。正确的做法是完善矩阵时从最右下角开始遍历，这样第一个遇到的 $0$ 的下面和右边一定不是 $0$，而到后面再来找这个 $0$ 的时候这个 $0$ 已经填好数了，因此不会出现上面说的问题。

# 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[555][555],n,m;
void wanshan(){//完善矩阵
//这里从右下角开始也是我卡了好久才发现的
    for(int i=n;i>=1;i--)
        for(int j=m;j>=1;j--)
            if(!a[i][j])
                a[i][j]=min(a[i+1][j],a[i][j+1])-1;//找到最大值的最接近的数填上去
}
int ans(){
    int reans=0;
    for(int j=1;j<=m;j++)
        for(int i=1;i<=n;i++){//判断是否合格顺便加一下
            if(i<n&&a[i+1][j]<=a[i][j]||j<m&&a[i][j+1]<=a[i][j])
                return -1;
            reans+=a[i][j];
        }
    return reans;
}
int main(){
    cin>>n>>m;
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)
            cin>>a[i][j];
    wanshan();
    cout<<ans();
    return 0;
}
```