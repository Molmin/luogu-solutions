* **【题目链接】**

[Link:CF375A](https://www.luogu.com.cn/problem/CF375A)

* **【解题思路】**

余数，是本题的突破口。

众所周知，一个数如果能被 $7$ 整除，那么这个数模 $7$ 的余数一定是 $0$。

而题目又说：_数 $a$ 一定包含 $1,6,8,9$。_

不难想到，可以把这 $4$ 个数每个分离 $1$ 个出来，把其他的数随便拼，最后用剩下的 $4$ 个数补上模 $7$ 的余数，让余数变成 $0$ 就行了。

此时，我大胆猜想：

**这四个数是不是可以拼出一些数，它们模** $\textbf{7}$ **后能得到所有可能的余数？**

可以直接枚举，口算足矣。

最后得到：

$1869\!\!\!\mod\! 7=0,8961\!\!\!\mod\! 7=1,1689\!\!\!\mod\! 7=2,6198\!\!\!\mod\! 7=3,$
$1698\!\!\!\mod\! 7=4,9861\!\!\!\mod\! 7=5,1896\!\!\!\mod\! 7=6$。

现在，我的猜想被证明了，同时也说明：本题没有无解情况。

因为，无论前面模 $7$ 的余数是什么，都可以用 $1,6,8,9$ 的一个排列补成可以被 $7$ 整除的数。

所以，可以直接把前面的数随便排，升序降序乱序都可以，再直接输出，边输出边做一遍高精模，最后用得到的余数决定该用 $1,6,8,9$ 的哪种排列。

时间复杂度$\Theta(|a|)$。

* **【实现细节】**

$0,7$ 是可以直接放在末尾而不影响答案的，所以我把它们全部放到末尾输出，不参与高精模。

* **【代码实现】**

```cpp
#include <iostream>

using namespace std;

int main(int argc,char *argv[],char *envp[])
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	char tmp;
	int counter[10]={},remain=0;//counter对各个数进行计数，remain记录余数
	const int mod_perm[8]={1869,8961,1689,6198,1698,9861,1896,1869};//用于补余数的排列
	while(cin.get(tmp))
		counter[tmp-'0']++;
	counter[1]--,counter[8]--,counter[6]--,counter[9]--;//把1、6、8、9各抽一个出来
	for(int i=1;i<10;i++)
	{
		if(i==0||i==7)
			continue;
		while(counter[i]--)
			remain=(remain*10+i)%7,cout<<i;//输出，顺便做一遍高精模
	}
	cout<<mod_perm[7-remain*10000%7];//用得到的余数决定该用哪种排列补余数
	//以下是为了优化而把0和7堆到一起输出
	while(counter[0]--)
		cout<<0;
	while(counter[7]--)
		cout<<7;
 	return 0;
}

```