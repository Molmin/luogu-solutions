一道不错的思维题。  
[题目传送门](https://www.luogu.com.cn/problem/CF375A)  
首先考虑把 $1689$ 的排列放在后面，设剩下的数字为 $k$，$1689$ 的排列为 $m$，则组合后的数为 $10000k+m$，模 $7$ 为 $4k+m~\bmod~7$，这引导我们探索 $1689$ 的排列能覆盖多少个剩余系。简单 `dfs` 可得：  
```plain
%7=0 1869 8169 9618 9681
%7=1 1968 6189 6819 8961
%7=2 1689 6918 6981 8619 9186 9816
%7=3 6198 6891
%7=4 1698 8691
%7=5 1986 8916 9168 9861
%7=6 1896 8196
```
这样就好办了，只要找到 $\equiv 7-4k \pmod{7}$ 的 $1689$ 排列即可。  
打表即可。  
【问题1】：  
Q:如果是 $18906$ 这样去掉一个 $1689$ 只剩 $0$ 的怎么办？  
A:遇到 $0$ 全部放在最后输出。  
【问题2】：  
Q:如何去掉一个 $1689$？  
A:设立桶数组，把 $1,6,8,9$ 四项初始值设置为 $-1$。  


这里是代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
int module_arrange[] = {1869, 8961, 1689, 6198, 1698, 9861, 1896, 1869};
string s;
int cnt[10] = {0, -1, 0, 0, 0, 0, -1, 0, -1, -1};
int main()
{
    int mod7 = 0;
    cin >> s;
    for (int i = 0; i < s.length(); ++i)
        cnt[s[i] - '0']++;
    for (int i = 1; i < 10; ++i)
        while (cnt[i]--)
            cout << i, mod7 = (10 * mod7 + i) % 7;
    cout << module_arrange[7 - (mod7 * 4) % 7];
    while (cnt[0]--)
        cout << 0;
    return 0;
}
```