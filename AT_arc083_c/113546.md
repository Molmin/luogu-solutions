#### **题目分析：（贪心+树形DP）**

首先要明确的是三件事：

1. 当某一个子树中染色方案和权值方案都确定以后，对于其祖先结点的子树造成的影响仅仅是两种颜色的权值和，而不关心其具体方案，因为对于它的父结点来说，这个子树是一个整体。
2. 显然将一个子树中所有结点黑白倒置，仍然满足要求；因此我们在处理上一条中提到的权值和时不必关心具体是哪种颜色的权值和。也就是说，不必知道到底是“黑色”还是“白色”的权值和，而只要知道是“两种不同颜色”的权值和。
3. 基于上面一条，我们在处理某一个子树时，可以假设它的根节点染黑色。因为如果根节点染白色，只需将这个子树上所有结点黑白倒置即可转换成黑色。同时，根节点的每一个子节点所对应子树中两种颜色当然也是可以交换的。

这就是我们分析的基础了。刚看到题目中给的条件可能还不太有头绪，即使有了上面的几条基本“规则”也难以继续做下去，所以我们还需要一个能够具体执行的染色和赋权法则。

**贪心策略：（假设将某个子树的根节点染成黑色）则这颗子树中黑色结点的权值和应当恰好等于$V_ x$，而白色结点的权值和应尽量小。**

证明：黑色结点权值和等于$V_x$应该没有什么问题，根据上面的黑白倒置理论，黑色或白色权和等于$V_x$是等价的。

- 白色结点的权值和尽量小也很容易理解：因为假如存在一种白色结点权值和更大的情况能够使整颗树满足要求，则我们一定可以给予这个子树根节点的父节点一个权值使得以父节点为根的更大的子树也满足要求，此时对于白色结点权值和小的情况，我们只要增大父节点的权值，就一定能够达到相同的效果。反之，如果权和较小是满足条件，则当权值增大时，有可能会超出父节点的$V$值，从而不能给它的父节点分配一个非负整数权值。

这就是我们染色和赋权的具体方案了。下面就要考虑具体如何实现的问题。

采用树形DP的递归实现。我们用$f[i]$表示以$i$为根的子树中白色结点的最小权值和。我们进行一次DFS，假设某结点$x$的所有子结点的$dp$值已经算出，并假设这个结点染黑色，那么对于每个子树$i$来说有两种决策：

1. 将这个子树的根节点染黑，则整棵树的黑权和增加$V_i$，整棵树的白权和增加$ f[i]$；
2. 将这个子树的根节点染白（黑白倒置），则整棵树的黑权和增加$f[i]$，白权和增加$V_i$。

同时考虑到这个节点自身染黑，而且权值可以是任意一个非负整数，所以只要每个子树统计完后黑权和不超过$V_x$即可（少的可以直接通过根节点加），所以我们要求的实际上就是：在黑权和不超过$V_x$的情况下，使白权和最小。这其实是类似于01背包的问题，题目中给出的最大$V_x$不大，因此可以使用背包问题的方法求解，这里只是每两个物品中必须选一个的背包，要求可行的最大值（因为黑权和最大代表白权和最小）。

下面代码中用$f[i]$指树形dp中的数组，$dp[i]$代表背包中的dp数组。

算法时间复杂度为$O(\sum \limits_{i=1}^nV_i)=O(NV)$。

------

#### **程序：**

```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAXN=1010;
int n,fa[MAXN],v[MAXN],dp[5*MAXN],f[MAXN];
vector <int> p[1010];
void dfs (int x) {
	for (int ii=0;ii<p[x].size();ii++) {
		dfs(p[x][ii]);
	}
	memset(dp,0x3f,sizeof(dp));
	dp[0]=0;
	for (int ii=0;ii<p[x].size();ii++) {
		int k=p[x][ii];
		for (int i=v[x];i>=0;i--) {
			int tmp=0x3f3f3f3f;
			if (i>=v[k]) {
				tmp=min(tmp,dp[i-v[k]]+f[k]);
			}
			if (i>=f[k]) {
				tmp=min(tmp,dp[i-f[k]]+v[k]);
			}
			dp[i]=tmp;
		}
	}
	for (int i=v[x];i>=0;i--) {
		f[x]=min(f[x],dp[i]);
	}
	return;
}
int main () {
	memset(f,0x3f,sizeof(f));
	scanf("%d",&n);
	for (int i=2;i<=n;i++) {
		scanf("%d",&fa[i]);
		p[fa[i]].push_back(i);
	}
	for (int i=1;i<=n;i++) {
		scanf("%d",&v[i]);
	}
	dfs(1);
	if (f[1]<0x3f3f3f3f) {
		printf("POSSIBLE\n");
	} else {
		printf("IMPOSSIBLE\n");
	}
	return 0;
}
```