~~出题人题解.jpg~~

发现题解区三篇题解都不是出题人的本意所以过来写写

***

首先看到二元组想到二离，可以转化为一个 $O(n)$ 次修改 $O(n\sqrt{m})$ 次查询的问题，这部分其实挺板的。

修改方式是向集合中插入一个点，查询方式是给出一个数 $x$ 和一个固定的常数 $y$ ，求集合内有多少个数 $z$ 满足 $z \oplus x \le y$。

考虑对 $z$ 建 Trie ，按 $x, y$ 的当前位进行讨论。

具体讨论不展开了，反正一定是 “对一棵子树累加贡献然后进入另一棵子树” 的形式。

不过这样做会多一个 $\log$，我们需要一个 $O(\sqrt{n})$ 修改 $O(1)$ 查询的数据结构。

考虑把 $k$ 层决策压成一层，那么如果能做到每一层 $O(1)$ 查询，一次查询就是 $O(\frac{\log n}{k})$ 的。

然后考虑修改部分，我们对于每 $k$ 层直接枚举 $x, y$ 在这几位的的 $2^k$ 种可能性，因此取 $k= \frac{\log n}{2}$ 即可得到 $O(\sqrt{n})-O(1)$ 的一个结构。

具体实现的时候只需要和普通 Trie 类似实现，只不过第一层的出边条数变成了 $2^k$ 而已，然后注意到第二层的节点可以通过第一层的出边直接确定编号，因此不需要动态开点。

仔细想想感觉这玩意儿本质上就是高低位分块（（

关键部分代码（剩下贺个二离板子就行）
```cpp
// o 就是题面中的 x
struct DS {
    int f1[1 << 9 | 5], f2[1 << 9 | 5][1 << 9 | 5];
    inline void ins(const int x) {
		REP(i, 0, 1 << 9) f1[i] += (((x >> 9) ^ i) < (o >> 9));
		REP(i, 0, 1 << 9) f2[x >> 9][i] += (((x & mod) ^ i) <= (o & mod));
	}
    inline int ask(const int x) { return f1[x >> 9] + f2[(x ^ o) >> 9][x & mod]; }
}ds;
```
