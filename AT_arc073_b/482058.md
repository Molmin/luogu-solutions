### 前言

为什么我现在才发现这道题洛谷里面有……

[题目链接](https://www.luogu.com.cn/problem/AT2556)

**正解：01 背包**

一道比较简单的创新 01 背包。

***

### 正解

如果按照背包的板子做，那么一定会 $\texttt{TLE}$ 和 $\texttt{MLE}$。那如何优化呢？

我们注意到数据范围里有一句十分特殊的话：

> 对于每个 $i=2,3,...,n$，满足 $W_1\le W_i\le W_1+3$

那么我们完全可以把每个物品的重量以 $W_1$ 为基准，转化为一个不超过 $3$ 的数。这么可以极大地优化空间复杂度。

用 $h$ 代表 $W_1$ 的真实数字。

但是这样的话，我们就无法得知我们现在装的东西到底有没有超过背包的容量，因为我们并不知道我们选了多少个东西。所以 $dp$ 数组还需要开一维代表选择物品的个数。

所以 $dp_{i,j,k}$ 代表在前 $i$ 个物品中选择 $k$ 个物品，背包容量为 $j$ 时的最大价值。

还需要注意一下循环的范围：

- $i:1\sim n$

（这个不需要解释了吧……）

- $j:0\sim 3\times i$

（因为物品的重量被处理过，当原来的 $W_i=W_1$ 时这个物品的重量为 $0$。所以最小的背包容量有可能是 $0$。物品最大的重量不超过 $3$，有 $i$ 个物品，所以最大可能容量为 $3\times i$。）

- $k:1\sim i$

（选择的物品数量不能超过总数。因为后面求答案 $ans$ 的初始值就为 $0$ 已经包括了一个都不选的情况，所以不需要考虑不选物品的情况。）

最后求答案的时候需要枚举 $dp_{n,i,j}$，注意只有 $i+j\times h\le m$ 时背包才不超限，可以更新答案。

具体见代码。

### Code

```cpp
#include<cstdio>
#define max(a,b) (a)>(b)?(a):(b) //卡常小技巧：用这个比库函数要快一些
#define ll long long
ll n,m,ans,h,w[105],v[105],dp[105][305][105];
int main(){
	scanf("%lld %lld",&n,&m);
	scanf("%lld %lld",&h,&v[1]); //h 代表 W1 的的重量
	for(int i=2;i<=n;i++){
		scanf("%lld %lld",&w[i],&v[i]);
		w[i]-=h; //以 W1 为基准转化每一件物品的重量
	}
	for(int i=1;i<=n;i++){
		for(int k=1;k<=i;k++){ //选择的物品数量不能大于总数量
			for(int j=0;j<=3*i;j++){ //3*i 为被允许的最大容量
				if(j<w[i])
					dp[i][j][k]=dp[i-1][j][k];
				else
					dp[i][j][k]=max(dp[i-1][j][k],dp[i-1][j-w[i]][k-1]+v[i]);
			}
		}
	}
    //在合法的范围内寻找最大值
	for(int i=0;i<=3*n;i++){
		for(int j=0;j<=n;j++){
			if(i+j*h<=m)
				ans=max(ans,dp[n][i][j]);
		}
	}
	printf("%lld",ans);
	return 0;
}
```