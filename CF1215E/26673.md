### 简要题意

称序列 $a_1\ \dots\ a_n$ 连续的，当且仅当如果 $a_l = a_r$ ，那么 $\forall\ i \in [l,\,r],\ a_i = a_l = a_r$ 。

给定序列，求最少交换相邻元素多少次使得序列连续。

---

### 解题思路

我们发现，“冒泡排序”能使得序列连续，尽管不是最优答案，但是在排序的意义下，交换次数已经最少了。

即有一个引理：

> 将一个序列排序最少交换相邻元素的次数等于该序列的逆序对数。

粗略证明：

> 每次交换两个相邻的逆序对都会使得逆序对减一，逆序对等于零时排序结束。

但是我们要让序列连续，而不是排序，怎么办？

其实本质相同，无非给 $20$ 种数，每种数赋一个互不相同的权值，按照权值排序而已。

联立数据范围，我们想到状压。

设 $f[i]$ 表示已选的数的状态集合（注意，每选择一个数，意味着给其赋一个比之前选的数都大，比之后选的数都小的权值），**集合中的数**权值逆序对的最小值。

有点难理解，假设有一个序列 $3,\,2,\,1,\,1$ ，$f[3] = f[(011)_2] \text{（集合中有数 1, 2）} = 0$ ，注意 $f[3] \neq 2$ ，因为只要给数 $1$ 赋权值 $2$ ，给数 $2$ 赋权值 $1$ ，数 $3$ 不在集合里不管，权值构成的序列应是 $*,\,1,\,1,\,2$ ，没有逆序对，故 $f[3] = 0$ 。

重点来了——转移，为求 $f[i]$ ，从 $i$ 表示的集合中枚举一个数 $u$ ，表示 $u$ 是新选的数，$j$ 为剔除 $u$ 后的集合。

枚举出 $u$ 之后，再从集合 $j$ 中枚举 $v$ ，根据上述，$v$ 比 $u$ 先选，所以在序列中，每一个 $l < r,\,a_l = u,\,a_r = v$ 都构成一个逆序对，当然我们不可能在枚举 $u,\,v$ 之后直接计算这个对吧！$1 \le u,\,v \le 20$ ，肯定会重复直接计算多次，不如预处理 $w[u][v]$ 表示有多少 $(l,\,r)$ 满足 $l < r,\,a_l = u,\,a_r = v$ 吧！这样求出 $sum = \sum\limits_{v \in j}w[u][v]$ ，$f[i] = \max(f[i],\,f[j] + sum)$ 就完成了 $i$ 中枚举 $u$ 的转移！

最简单粗暴的：预处理时，枚举 $u,\,v$ ，然后只留下 $a_i = u,\,a_i = v$ ，然后 $O(n)$ 扫过去计数器统计，时间复杂度是 $O(n \times 20 \times 20)$ ，稍微有点卡。

考虑去掉一个 $20$ ，只扫一遍，统计 $cnt[u]$ 表示扫到现在 $a_i = u$ 的个数，如果当前 $a_i = v$ ，枚举 $u$ ，令 $w[u][v]$ 加上 $cnt[u]$ 即可。

时间复杂度 $O(2^{20} \times 20 \times 20 + n \times 20)$ ，实际会跑得更快 。

---

### 代码实现

要开 $\text{long long}$ 哦！

```cpp
#include <bits/stdc++.h>

inline int read() {
    char c; int x; for (c = getchar(); !isdigit(c); c = getchar());
    for (x = 0; isdigit(c); c = getchar()) { x = x * 10 + c - '0'; } return x;
}

const int N = 20, M = 5e5 + 5, A = 1 << N;

int n, m, all, a[M], cnt[N];
long long w[N][N], f[A];

int main() {
    n = 20; m = read(); all = 1 << n;
    for (int i = 0; i < m; i++) {
        a[i] = read(); a[i]--; cnt[a[i]]++;
        for (int j = 0; j < n; j++) {
            w[j][a[i]] += cnt[j];
        }
    }
    for (int i = 1, j; i < all; i++) {
        f[i] = 1e18;
        for (int u = 0; u < n; u++) {
            if (1 << u & i) {
                j = 1 << u ^ i;
                long long sum = 0;
                for (int v = 0; v < n; v++) {
                    if (1 << v & j) { sum += w[u][v]; }
                } f[i] = std::min(f[i], f[j] + sum);
            }
        }
    }
    printf("%I64d\n", f[all - 1]);
    return 0;
}
```