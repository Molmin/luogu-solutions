## 思路分享

我们可以发现，这道题 $m$ 特别小，只有 $20$，所以我们可以考虑使用状压 $DP$。

又因为每次只能交换相邻的两个，所以我们可以考虑逆序对。但是不是只要求相同颜色的相邻就行了么？所以我们就可以请出状压 $DP$。

设 $DP_s$ 为当前状态为 $s$ 时的最优方案。举个例子，$dp_{10}=dp_{(01010)_2}$，就表示前 $2$ 个位置放的是 $2$ 与 $4$。

然后我们就可以根据题意列出状态转移方程：
$$
\boxed{dp_s=\max(dp_s,dp_{s1}+sum)}
$$
其中 $s1$ 就是 $s$ 在某一位 $1$ 上变成 $0$，$sum$ 则是对于更改的这一位 $i$，$s$ 的所有为 $1$ 的位置 $j$ 的 $\sum pd_{i,j}$ 其中 $pd_{i,j}$ 为序列中所有的有 $j$ 在 $i$ 前面的对数。

然后我们就可以 $DP$ 处理了。

最后放个部分代码：

```cpp
for(int s=1;s<(1<<m);s++){
	for(int i=0;i<m;i++){
		if(((s>>i)&1)==1){
			int s1=s-(1<<i),sum=0;
			for(int j=0;j<m;j++){
				if(((s1>>j)&1)==1){
					sum+=pd[i+1][j+1];
				}
			}
			dp[s]=min(dp[s],dp[s1]+sum);
		}
	} 
}
```
