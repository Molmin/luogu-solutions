### 前情提要
>我会做的题都是傻X题，所以这道题就是傻X题  
——某dalao

------------
# 正文
## 分析题面

>给出$n$个开头是'#'的字符串,你需要把这些字符串按字典序从小到大排列.  
你可以把某一个字符串的任意后缀去掉(当然你甚至可以去掉整个字符串),要求你去掉的字符数量最少.  
输出你操作完的这$n$个字符串.

![稍加思索](https://ss3.bdstatic.com/70cFv8Sh_Q1YnxGkpoWK1HF6hhy/it/u=2995028456,1422359237&fm=26&gp=0.jpg)

不难发现，虽然题目里有 _排列、字典序_ 等字眼，但是这好像……**并不是一道排序题**……

相反，这是对每个字符串的**单个处理**

![](https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=2781194016,2044444037&fm=26&gp=0.jpg)

简单来说，就是删掉每个字符串**最少**的**后缀**，让所有的字符串满足**字典序从小到大**，也就是第$i$个字符串的字典序**严格小于**第$i+1$个字符串

所以说，我们可以采用**从后往前**进行处理的思想

让第$i-1$个字符串删到**刚好**小于第$i$个字符串

第$n$个字符串不用做任何处理，因为**只要删除后缀就一定会减小字典序**

## 代码实现
### 法一
需要函数：$substr$（截取子串）

具体用法：
```cpp
字符串名称（string类型）.substr(起点位置,截取长度);
```
法一的思想与前文**分析题面**一致

对第$i-1$个字符串**从后往前**进行遍历

当$j$遍历到删去$j$以后的字符**恰好**可以让第$i-1$个字符串小于第$i$个

我们就**反其道而行之**，化删除为**截取**

也就是截取$j$之前（包括$j$)的字符串

核心代码如下：
```cpp
for(int i=n;i>1;i--){
	int len=s[i].size();
	for(int j=len-1;j>=0;j--){
		string tmp=s[i-1].substr(0,j+1);
		if(tmp<=s[i]){
			s[i-1]=tmp;
			break;
		}
	}
}
```
不难发现，对于$j$遍历到的每一个位置

**都需要调用一遍$substr$函数**

**并且对两个字符串进行比较**

效率很不优秀

![](https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=1623132418,3665102574&fm=26&gp=0.jpg)

### 法二
看到前文我嫌弃效率不优秀的盆友

是不是觉得我要放弃$string$了？

然而……并不是

而是用另外一个函数：$erase$

![](https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=3299279567,853265545&fm=26&gp=0.jpg)

~~因为STL实在是太好用了啊啊啊啊~~

具体用法：
```cpp
字符串名称（string类型）.erase(起点位置,删除长度);
```

不同于$substr$的是

只要一用$erase$，原来的字符串就会**自动删除**

所以如果想要保留原字符串的盆友还是建议**多用一个字符串来存储**

言归正传

法二的思想保留了题面的**删除**

但是并不是从**后缀**入手

我们先来看字典一般是怎么排序的：
>设想一本英语字典里的单词，何者在前何者在后？  
显然的做法是先按照第一个字母、以 a、b、c……z 的顺序排列；如果第一个字母一样，那么比较第二个、第三个乃至后面的字母。如果比到最后两个单词不一样长（比如，sigh 和 sight），那么把短者排在前。  
通过这种方法，我们可以给本来不相关的单词强行规定出一个顺序。“单词”可以看作是“字母”的字符串，而把这一点推而广之就可以认为是给对应位置元素所属集合分别相同的各个有序多元组规定顺序：下面用形式化的语言说明

引自[百度百科](https://baike.baidu.com/item/%E5%AD%97%E5%85%B8%E5%BA%8F/7786229?fr=aladdin)

聪明的小伙伴们已经发现了

我们可以**从前往后一位一位地比较**

如果第$i$个字符串在某一位上大于第$i-1$个字符串，就可以**不进行操作**

反之，**这一位就是我们要删除的起点**

核心代码如下：
```cpp
for(int i=n;i>1;i--){
	int len=s[i-1].size();
	int j;
	bool f=0;//s[i-1]是否小于等于s[i]
	for(j=0;j<len;j++){
		if(s[i][j]!=s[i-1][j]){
			if(s[i][j]>s[i-1][j])f=1;
			break;
		}
	}
	if(f)continue;
	if(j!=len)s[i-1].erase(j,len-j);
}
```
这样一来，**就只需要调用一次函数**

**并且不用再针对每个子串多次比较**

![](http://wx2.sinaimg.cn/large/ceeb653ely1g5298k6rifj205i03zq2v.jpg)
## 整体代码
AC代码如下
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=5e5+5;
int n;
string s[N];
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++)cin>>s[i];
	for(int i=n;i>1;i--){
		int len=s[i-1].size();
		int j;
		bool f=0;
		for(j=0;j<len;j++){
			if(s[i][j]!=s[i-1][j]){
				if(s[i][j]>s[i-1][j])f=1;
				break;
			}
		}
		if(f)continue;
		if(j!=len)s[i-1].erase(j,len-j);
	}
	for(int i=1;i<=n;i++)cout<<s[i]<<endl;
	return 0;
}
```
