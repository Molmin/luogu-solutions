以下是本蒟蒻对这个题目的理解，希望对各位有所帮助。

- 把字母对的关系抽象成无向边的关系，对每个字符建立一个对应数字的映射。

- 把刚才抽象出来的图形画出来，就会发现这个题目转化成了对于这样一个图，从一个点出发，能否完成对本图所有的边的遍历的问题。

- 所以我们考虑求欧拉路径，不了解请提前百度相关概念，本题目只需要了解欧拉路径和欧拉回路的概念就可以口胡出来，不一定非要背下来模板。

- 在求欧拉路径的时候注意以下部分：
	- 注意判断题目给出图形的连通性
    
    - 利用欧拉路径的原理判断even点的个数就可以判断本题目是否有解
    
    - 对欧拉路径和欧拉回路的情况应该分类讨论

- 如果对欧拉路径和dfs写的不熟练请注意以下内容：
	
    - 从小到大遍历连接字符，利用贪心的原理构造出字典序最小的情况。
    
    - 由于上面这一点，所以dfs中每一步都不折返，建议认真考虑一下如何实现。

- 记录答案非常关键，在写题目以前请仔细考虑。为了保证题目中对字典序的要求，强烈建议使用邻接矩阵存图，因为这样可以利用贪心的思想，对字典序从小到大的字符进行遍历搜边，从而保证最后（退栈）的时候记录的都是最终答案。

- 本题目没有重边和自环，原因请自行思考。

如果你现在找到了思路，强烈建议先不要看代码，自行实现。这个题目思路不是非常难，但对debug能力要求还是很高的！祝玩得开心！

那么本蒟蒻就只贴核心代码了qwq：
```cpp
void euler(int x){//x表示目前所处位置
    for(int i=0;i<255;i++){
    //这里是本人懒省事，如果好好建立映射只需要52个字符就OK
    	if(mp[x][i]>0){//如果这个边可选
    		mp[x][i]--;//删除这个边，避免折返
            mp[i][x]--;
            euler(i);//向下一层进发
        }
    }
    res[cnt--]=x;//退栈时记录，也可以给函数加一个deep把它写在if里面。
    //这里本人cnt初始为n
}
```
