## 来自蒟蒻的第一篇题解！！！！
首先一看题，没思路，点开题解，dalao们都说是欧拉回路板子【~~欧拉回路是什么？？？？~~】
于是花了半上午搞懂了欧拉回路是个什么东西，成功一遍过。
这篇题解会比较详细，主要是为了给像我这样的蒟蒻准备的。

很多思想都是从之前大佬们的题解中得来的，所以相当于是之前dalao们的题解的一点补充吧。


------------

首先是题意。
 
欧拉路径：在一个图中，由i点出发，将每个边遍历一次最终到达j点的一条路径。 

欧拉回路：i=j时的欧拉路径。

因为要求答案长度为n+1，所以这个题的题意可以转化成，给出一个无向图，求字典序最小的一条欧拉回路/路径。

所以建图，就是在每一组字母对之间连无向边。

------------
参照一楼大佬的题解，这题应该要判断是否联通的【~~虽然不判断也能AC~~】，用并查集判断是否是个连通图，也就是所有字母都只有一个祖宗。如果不是连通图，直接输出No Solution

------------
然后就是怎么求欧拉回路/路径了。

首先要判断是否存在欧拉回路/路径。

怎么判断呢。→参照此博客(https://blog.csdn.net/qq_34454069/article/details/77779300)

在无向图中

判断欧拉回路，只要每个点的度数均为偶数即可。

判断欧拉路径，如果有且仅有两个点的度数为奇数，就会存在一条从这两个中的一个到达另一个的欧拉路径。 

所以在输入是存储每个点的度数，判断是否满足条件。如果不满足，即没有欧拉回路/路径，就直接输出No Solution。

如果存在欧拉路径，直接把字典序较小的那个有奇数度数的点当做起点，进行dfs。

如果存在欧拉回路，就选择一个字典序最小的点当做起点，进行dfs。

------------
dfs过程其实就是不停地找字典序较小的边。其中有一个地方我想了一会才明白【~~dalao请自觉跳过~~】
就是路径要倒着存，是因为存储是在回溯的时候做的，所以要从后往前存【这么简单的问题可能也就我会想不明白。。。】


------------
最后一些小的点。

用邻接矩阵存图就可以，且看起来很方便。

我直接开的是125*125，因为ASCII码表里面z是122，所以可以直接用字符当下标。看dalao的代码是257，依然想不明白为什么。

然后n的范围是看讨论里面说的，因为每个字母都可以与51个字符相连，所以为 52*51/2，所以我答案数组开了1330；

上代码
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<string>
#include<algorithm>
using namespace std;
int n,head;
char a[2];
int b[130][130];//存图
int deg[130],fa[130];//deg存储度数，fa存储父亲，用来并查集判断是否联通
char ans[1330];//稍大于51*52/2
int find(int x)
{
	if(fa[x]==x)return x;
	return fa[x]=find(fa[x]);
}
void dfs(int x)//找欧拉回路/路径
{
	for(int i=64;i<=125;i++)
	  if(b[x][i])
	  {
	  	b[x][i]=b[i][x]=0;
	  	dfs(i);
	  }
	ans[n--]=x;//因为是回溯的时候存，所以倒着存
}
int main()
{
	cin>>n;
	for(int i=64;i<=125;i++)fa[i]=i;
    //A在ASCII码表里为65，z为122，所以64~125就足够了
	for(int i=1;i<=n;i++)
	{
		cin>>a;
		b[a[0]][a[1]]=b[a[1]][a[0]]=1;
		deg[a[0]]++;
		deg[a[1]]++;
		int xx=find(a[0]),yy=find(a[1]);
		fa[xx]=yy;
	}
	int cnt=0;
	for(int i=64;i<=125;i++)
	  if(fa[i]==i&&deg[i])cnt++;//祖宗结点
	if(cnt!=1){cout<<"No Solution"<<endl;return 0;}//如果不是连通图
	cnt=0;
	head=0;
	for(int i=64;i<=125;i++)
	{
		if(deg[i]&1)
		{
			cnt++;
			if(head==0)head=i;//顺道存储起点
		}
	}
	if(cnt&&cnt!=2){cout<<"No Solution"<<endl;return 0;}
    //如果有奇数度数的点，并且不是两个，说明不存在欧拉回路/路径
    if(head==0)//如果是欧拉回路
      for(int i=64;i<=125;i++)
        if(deg[i]){head=i;break;}//找欧拉回路的起点
    dfs(head);
    cout<<ans;
    return 0;
} 
```

最后吐槽，写题解好麻烦。。。

【但是很有收获】

如果有不清楚或者错误的地方欢迎私信~~