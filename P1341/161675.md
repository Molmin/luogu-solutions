### $0.$ 分析
字符串首等于尾，长度等于字母对数加一，并且每个字母对都要用上，很明显对每个字母对中的两个字母建边找欧拉回路，俗称一笔画（~~该死的老欧拉~~

### $1.$ [定义](https://baike.baidu.com/item/%E6%AC%A7%E6%8B%89%E5%9B%9E%E8%B7%AF/10036484?fr=aladdin)

### $2.$ 判定
对于无向图：如果所有点的度数均为偶数，那么这是一个欧拉图，因为把每个点的出度和入度分配相等之后一定会回到初始离开的起点；如果仅有两个点的度数为奇数，那么这是一个半欧拉图，因为这两个点多出来的一个度数刚好被分配成出度和入度，即为起点的终点，它们是不相同的；否则它什么都不是滑稽。

对于有向图是类似的，出度和入度已经给你分配好了鸭。

### $3.$ 寻找
- 起点和终点

如果是欧拉图随便，半欧拉图找出两个特殊点（有向图是两者，无向图两者可以互换）。

- 路径

进行$dfs$，可行就走，还需探讨一个问题，为什么需要最后去存，倒序输出？

这里给出了一个直接存的反例。

![](https://cdn.luogu.com.cn/upload/pic/67063.png)

假定我们从左上角的点出发，先向右走，在向左下走。当我们来到有自环的点时，就出现毛病了。有两种选择，一是直接回到起点，虽然也构成了一个欧拉子图，但是并不能达到我们的要求，所以必须先绕着自环走完再回到起点。加之我们肯定得按照字典序选择，很大概率会走错。

仔细观察我们发现，每个点肯定连接着若干个环，这些环中分成三种：遍历完的、没遍历过的、遍历了一部分的。除去遍历完的，要跑出正确的路径，我们应该先选择没有遍历过的，最后再进入遍历了一部分的死胡同（出不来）。

记录下来非常不可做的样子，考虑到终点一定在遍历了一部分的环中（我们是从那里来的），我们之前的路径又一定是合法的，那么我们是不是可以逆推呢？也就是说，当我们走进死胡同时，不要先记录答案，以死胡同为起点再向外走，遍历完剩下的环后，按照原路返回不就行了吗？

理一下思路，当一个点没有路可以走时，才加入栈（字典序从小到大枚举，从大到小想不用栈是会导致第一位出错，因为第一位字母存在于头和尾，头要最小，而你考虑到的是要后面的最大，会将头尾置为最大，从而丧失了最重要的部分）中。

有向图非常相似就不说了。

至于数据范围比较玄学，算了一下$52*52=2704$

算法很简单，思维不简单。

时间复杂度$Θ(n)$~

***code:***
```cpp
#include<bits/stdc++.h>
using namespace std;
#define N 123
#define For(i,x,y)for(i=x;i<=y;i++)
string str;
bool g[N][N];
int deg[N],cnt;
void dfs(int u)
{
    int i;
    For(i,65,122)
    if(g[u][i])
    {
        cnt++;
        g[u][i]=g[i][u]=0;
        //记得清空的是无向路径
        dfs(i);
    }
    str=char(u)+str;
    //倒序
}
//欧拉回路
void no()
{
    cout<<"No Solution";
    exit(0);
}
//无解
int main()
{
    char x,y;
    int n,i,j,num=0;
    cin>>n;
    For(i,1,n)
    {
        For(j,0,1)getchar();
        x=getchar();
        y=getchar();
        g[int(x)][int(y)]=g[int(y)][int(x)]=1;
        //邻接矩阵存图
        deg[int(x)]++;
        deg[int(y)]++;
        //记录每个点的度数
    }
    For(i,65,122)
    if(deg[i]&1)num++;
    if(num&&num!=2)no();
    //性质
    For(i,65,122)
    if((num&&deg[i]&1)||(!num&&deg[i]))break;
    //寻找出发点
    dfs(i);
    if(cnt<n)no();
    else cout<<str;
    return 0;
}
```
>感谢观看！