首先，看到这道题，我们必然想到：

设 $dp_i$ 为 $i$ 的分解方法的数量，则有 $dp_i = dp_{i-4} + dp_{i-5}$。

看上去没有问题，事实上它是错的。错的原因：

> 当然，$4$ 和 $5$ 的顺序并不重要，重要的是他们的个数。

那么，对于 $14 = 4 + 5 + 5 $ 和 $14 = 5 + 4 + 5$ 两种情况而言，可以从题面的描述看出它们是一种情况，而代码不会这么认为。显然的，代码没有判断每种情况的顺序。

知道错误原因了，我们就要改正：

由于判断顺序非常麻烦，我们可以命令每一种情况下，第 $i$ 个数不能小于第 $i-1$ 个数，即，一个数只能由 $4 + 4 + \cdots + 4 + 5 + 5 + \cdots + 5$ 来组成，不过 $4$ 和 $5$ 的个数是不限的。

为了满足这种情况，我们需要对上一次加 $4$ 和加 $5$ 的情况进行分类讨论。那么 $dp$ 数组的设置方法也很明显：

设 $dp_{i,0}$ 为上一步是加 $4$ 时 $i$ 的分解方法的数量，$dp_{i,1}$ 为上一步是加 $5$ 时 $i$ 的分解方法的数量。

自然的，由于上一步加的数必须小于等于这一步加的数，所以 $dp_{i,0} = dp_{i-4,0}$，$dp_{i,1} = dp_{i-5,0} + dp_{i-5,1}$。

由于最后一步所加的数可以为 $4$ 也可以为 $5$，所以答案即 $dp_{n,0} + dp_{n,1}$，其中 $n$ 为输入的数。

考虑到刚才的状态转移方程中出现了 $- 4$ 和 $- 5$，所以我们要预处理出 $1$ 到 $5$ 的 $dp$ 值。

$n \leq 10^6$，因此时间复杂度不会炸，且计算得 $n = 10^6$ 时答案为 $50001$，因此开 `int` 足以通过此题。

综上所述，本题便做完了。且此题代码坑点极少，因此代码也好写了。

```cpp
#include <iostream>
using namespace std;
int dp[1000001][2];
int n;
int main(){
	cin>>n;
	dp[1][0]=0;
	dp[1][1]=0;
	dp[2][0]=0;
	dp[2][1]=0;
	dp[3][0]=0;
	dp[3][1]=0;
	dp[4][0]=1;
	dp[4][1]=0;
	dp[5][0]=0;
	dp[5][1]=1;//预处理前几个数的dp值
	for(int i=6;i<=n;i++){
		dp[i][0]=dp[i-4][0];
		dp[i][1]=dp[i-5][0]+dp[i-5][1];
	}
	cout<<dp[n][0]+dp[n][1];
	return 0;
}
```
