
这是第一篇题解！！！鸡冻！！！
 
本题可以是一道应用暴搜加强力剪枝的极好的练习题，所以选择这道题的童鞋，在明白了思路及程序之后相信会有很大提升！
 
先来一下题目：

    乔治拿来一组等长的木棒，将它们随机的砍掉，得到若干根小木棍，然后他又想把这些木棍拼接起来，恢复到裁剪前的状态，但他忘记了初始时有多少木棒以及木棒的初始长度。请你设计一个程序，帮助乔治计算木棒的可能最小长度，每一节木棍的长度都用大于零的整数表示。
    
    输入包含多组数据，每组数据包括两行。第一行是一个不超过64的整数，表示砍断之后具有多少节木棍。第二行是截断以后，所得到的各节木棍的长度。在最后一组数据之后。是一个零。 
    
    对于每组数据，分别输出原始木棒的可能最小长度。
    
注意的问题是，各个原始木棒的长度都是一样的！

说一下本题的总思路即：DFS+超强力剪枝！（详见本人的 **AC** 程序）

首先，我们要从小到大枚举原始木棒的长度len，也就是枚举答案，最先找到的就是最小长度。那怎么确定枚举的是正确的呢？我们用的是搜索。

如果只搜索是极不理智的，而如果有了剪枝，一切就好说了，本题的剪枝主要有五个，我们会边看程序边了解一下。

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
int len,n;
bool v[101];
int a[101];
int cnt,sum,val;
//stick 即正在拼第stick根木棒(确保前面的都拼好了)
//第stick根木棒的当前长度为cab
//拼第stick根木棒的上一根小木棒为last(有些小朋友可能会有疑问，为什么第一次搜索是dfs(1,0,1)而不是dfs(1,0,0)首先，如果dfs(1,0,0)也能过并且更正确一些，而即使dfs(1,0,1)在bfs中的第三个if中，因为v[i]==1也不会进入)
bool dfs(int stick,int cab,int last)
{
	if(stick>cnt)
	  return true;//所有的木棒都已经拼好
	if(cab==len)
	  return dfs(stick+1,0,1); //当前的一根已经拼好，开始下一根
	int fail=0;//第二个剪枝开始了：对于每根木棒，fail记录的是最近一次尝试拼接的木棍长度。这样再回溯时就不会再尝试相同长度的木棍。
	for(int i=last;i<=n;i++)//第三个剪枝开始了：限制先后加入一根原始木棍的长度是递减的。因为先拼上一个长为x的木棍再拼上一个长为y的木棍，等效于先拼上一个长为y的木棍再拼上一个长为x的木棍。所以只需要搜索其中一种即可。
	{
		if(v[i]==0&&a[i]+cab<=len&&fail!=a[i])
		{
			v[i]=1;
			if(dfs(stick,cab+a[i],i))
			  return true;
		    v[i]=0;//还原搜索前的状态。
			fail=a[i];
			if(cab==0||cab+a[i]==len)
			  return false;//第四个剪枝开始了:如果在一根原始木棒中尝试拼接的第一根木棍的递归分支就以失败返回，直接判断当前分支无解。与此同时，第五个剪枝开始了，如果两个木棍的长度和与一个木棍的一样，只尝试一个的就行了(因为前两个可能会有更大的效用)
		}
	}
	return false;//所有分支都尝试过，搜索失败。
}
int main()
{
	while(cin>>n&&n)
	{
		sum=0;
		val=0;
		for(int i=1;i<=n;i++)
		{
			scanf("%d",&a[i]);
			sum+=a[i];//为啥要累加尼？为了求原始木棒的根数，即sum/len(len是枚举的答案)
            val=max(val,a[i]);
		}
	    sort(a+1,a+n+1);//第一个剪枝开始了：此为优化搜索顺序，优先尝试较长的木棍
	    reverse(a+1,a+n+1);//sort从小到大排序，而reverse会将整个数组翻转(懒人做法)，这样就可以达到从大到小排的结果
	    for(len=val;len<=sum;len++)
	    {
	    	 if(sum%len)
	    	   continue;
	    	 cnt=sum/len;
	    	 memset(v,0,sizeof(v));
	    	 if(dfs(1,0,1))//(1,0,1具体是啥，看上方的dfs)
	    	   {
	    	    cout<<len<<endl;
	    	   	break;//确定枚举正确的第一次即为答案，立即结束
	    	   }   
	    }
	}
        return 0;
} 
```