## 这道题就是一道**经典的搜索剪枝**题! 
### 剪枝优化三原则
1. **正确性**: 枝条不是爱剪就能剪的. 如果随便剪枝,把带有最优解的那一分支也剪掉了的话, 剪枝也就失去了意义。所以,剪枝的前提是一定要保证不丢失正确的结果。

2. **准确性**: 在保证了正确性的基础上, 我们应该根据具体问题具体分析, 采用合适的判断手段, 使不包含最优解的枝条尽可能多的被剪去,以达到程序“最优化”的目的。可以说, 剪枝的准确性, 是衡量一个优化算法好坏的标准。

3. **高效性**: 设计优化程序的根本目的, 是要减少搜索的次数, 使程序运行的时间减少. 但为了使搜索次数尽可能的减少, 我们又必须花工夫设计出一个准确性较高的优化算法, 而当算法的准确性升高, 其判断的次数必定增多, 从而又导致耗时的增多, 这便引出了矛盾。因此, 如何在优化与效率之间寻找一个平衡点, 使得程序的时间复杂度尽可能降低,同样是非常重要的. 倘若一个剪枝的判断效果非常好, 但是它却需要耗费大量的时间来判断、比较, 结果整个程序运行起来也跟没有优化过的没什么区别, 这样就太得不偿失了。


------------


### 深度优先搜索的优化技巧
1. **优化搜索顺序**：在一些搜索问题中，搜索树的各个层次，各个分支之间的顺序是不固定的。不同的搜索顺序会产生不同的搜索树形态，其规模大小也相差甚远。

2. **排除等效冗余**：在搜索过程中，如果我们能够判定从搜索树的当前节点上沿着某几条不同分支到达的子树是等效的，那么只需要对其中的一条分支执行搜索。

3. **可行性剪枝（上下界剪枝）**：该方法判断继续搜索能否得出答案，如果不能直接回溯。 在搜索过程中，即使对当前状态进行检查，如果发现分支已经无法到达递归边界，就执行回溯。

4. **最优性剪枝**：最优性剪枝，是一种重要的搜索剪枝策略。它记录当前得到的最优值，如果当前结点已经无法产生比当前最优解更优的解时，可以提前回溯。

5. **记忆化**：可以记录每个状态的搜索结果，再重复遍历一个状态时直接检索并返回。这好比我们对图进行深度优先遍历时，标记一个节点是否已经被访问过。


------------
这道题可以运用**最优性剪枝，可行性剪枝**来做，代码如下：
 
```cpp
#include <iostream>
#include <algorithm>
#include <cstring>
using namespace std;
int a[105],used[105],n,len,m,mmin=0,sum=0,bj;
bool cmp(const int &x,const int &y)
{
	return x>y;
}
void dfs(int k,int last,int rest)//第k跟木棍，last为上一节木棍编号，rest为第k根木棍还需要的长度 
{
	int i,j;
	if(k==m)// 剪枝9 
	{
		bj=1;
		return;
	}
	if(rest==0)
	{
		for(i=1;i<=n;i++)//剪枝4 
		{
			if(!used[i])
			{
				used[i]=1;break;
			}
		}
		dfs(k+1,i,len-a[i]);
	}
	for(i=last+1;i<=n;i++)//剪枝5和7 
	{
		if(!used[i]&& rest>=a[i])
		{
			used[i]=1; //当前木棍已使用 
			dfs(k,i,rest-a[i]);
			used[i]=0; 
			j=i;
			while(i<n && a[i]==a[j])i++;//剪枝6 
			if(i==n)
			{
				return;
			}
		}
	}
}
void solve()
{
	int i,j;
	for(i=mmin;i<=sum;i++)//剪枝2 
	{
		if(sum%i==0)//剪枝1 
		{
			memset(used,0,sizeof(used));
			len=i;
			used[1]=1;
			bj=0;
			m=sum/i;//木棍的根数 
			dfs(1,1,len-a[1]);
			if(bj)
			{
				cout<<len<<endl;
				break;
			}
		}
	}
}
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>a[i];
		mmin=max(mmin,a[i]);
		sum=sum+a[i];
	}
	sort(a+1,a+1+n,cmp);
	solve();
	return 0;
}
/*
9
5 2 1 5 2 1 5 2 1
*/
```
### 分析：
**最优性剪枝：**

1 、设所有木棍的长度和为sum ，原长度一定能被sum 整除；

2 、木棍原始长度一定不小于所有木棍中最长的那个；

**可行性剪枝：**

3 、长木棍肯定比几根短木棍拼成同样长度的用处小，短木棍
； 更灵活，可以对木棍从大到小排序；

4 、当用木棍i 拼凑原始木棍时，可以从第i+1 后的木棍开始搜，
化 因为根据优化1 ，i 前面的木棍已经用过了；

5 、用当前最长长度的木棍开始搜，如果拼不出当前设定的圆
度 木棍长度len ，则直接返回，换一个原始木棍长度len ；

6 、相同长度的木棍不要搜索多次。用当前长度的木棍得不出
； 结果是，用同一支长度相同的还是得不到结果，可以提前返回；

7 、判断收到的几根木棍组成的长度是否大于原始长度len ，如
； 果大于，可以提前返回；

8 、判断当前省的木棍根数是否够拼成木棍，如果不够，直接
； 返回；
9 、找到结果后，在能返回的地方法返回到上一层的递归处。
