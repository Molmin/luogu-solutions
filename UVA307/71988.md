
采用深度优先搜索（$DFS$）算法.

搜索的对象就是原始木棍的长度，可以从小到大搜索，在搜索前，可以先计算所有小木棍的长度之和$S$，因为我们知道，所有小木棍都是由原始木棍截出来的，所以$S$一定是我们要搜索的**原始木棍长度L的整数倍**。这可以跳过很多无效的L！

对于每一个要搜索的L，我们要检查所有的小木棍是否能够拼回原木棍，在搜索之前，应该要从最长的小木棍开始搜索，也就是说**从大到小**开始搜索，这样我们才能够保证不重复，并且已拼成功的小木棍要在递归时标志为已使用，保证不重复以避免重复。

为了保证搜索时是从大到小搜索，我们应该对小木棍的长度进行排序（或有序保存），另外我们在搜索时，搜索函数需要知道当前搜索的原始木棍长度，当前已拼接的长度，当前准备拼接的小木棍需要，所以定义搜索函数$dfs$时需要三个参数。

一个比较强的剪枝是，如果当前能够拼出一条原始木棍，当前拼接的最后一段小木棍长度是t，但是剩余的其他小木棍无法全部拼接出原始小木棍，则不需要将t长度的小木棍替换为其他小木棍进行进一步的搜索，因为已经没有搜索的必要了。为什么呢？假设有解（即可以所有小木棍都可以拼接的话），那用$t$拼和用 $t1+…+ti=t$ 去拼是一样的，所以不可能有解。

在搜索过程中，我们可以通过一个变量来累计拼成功的小木棍的和，这样就可以通过该值判断是否与$S$相等判断是否找到解了。

