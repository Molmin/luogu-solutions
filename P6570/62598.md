我们首先把数列中的数作为集合看待，具体来说，$x$ 的二进制表示中第 $i$ 位的 $0$ 代表不包含 $i$，第 $i$ 位的 $1$ 代表包含 $i$，也就是状压 $dp$ 的那种表示方式。

那么 $a\operatorname{and} b=0\Leftrightarrow a\cap b=\varnothing$，也就是说合法的子序列中任意两个数交集为空，这就意味着对于一个合法子序列 $S$，$\sum_{x\in S} x= \bigcup_{x\in S} x$，而根据数据范围  $S\subseteq 2^{18}-1$

所以我们只需要求出 $\bigcup_{x\in S} x=0,1,\cdots,2^{18}-1$ 的所有子序列 $S$ 的个数，就可以直接乘以那个 $\varphi(x)$ 的系数求和得到答案。

考虑朴素 $dp$，$dp_{i,j}$ 代表前 $i$ 个数中，$\bigcup_{x\in S} x=j$ 的 $S$ 的个数。

有 $dp_{0,0}=1$

$$dp_{i,j}=dp_{i-1,j}+\begin{cases}0& a_i\not\subseteq j\\ dp_{i-1,j\setminus a_i} & a_i \subseteq j\end{cases}$$

就是说，如果 $a_i$ 不是 $j$ 的子集，显然不能加，否则，转移之前的那个集合和 $j$ 的交集必须为空，否则就不合法，故只能包含 $j$ 与 $a_i$ 的差集。

我们发现，由于子序列没有顺序关系，我们可以假装原序列是从小到大排序的，这样我们可以直接消去一维。

$dp_i$ 表示 $\bigcup_{x\in S} x=i$ 的子序列个数，我们发现这样的子序列一定是只由 $\leq i$ 的数组成的。

设 $c_i$ 为 $a_x=i$ 的 $x$ 的个数，即 $i$ 在原序列出现次数

显然，$dp_0=2^{c_0}$，因为 $0$ 随便咋选都没问题。

$$dp_i=\sum_{j\subseteq i,k=i\setminus j,j>k} dp_k\times c_j$$

考虑枚举子序列中最大的那个数 $j$，显然 $j$ 有 $c_j$ 个，选任意一个都没问题，剩下的就是 $dp_k$，而 $j$ 是最大的，故必须要求 $j>k$

我们发现这样 $dp$ 就能过，这是因为一个结论：$n$ 个元素的集合的子集的子集的个数为 $3^n$，而这个 $dp$ 的复杂度显然就是子集的子集个数（因为对于每一个 $i$ 都枚举了它的所有子集 $j$）

所以总复杂度 $O(n+3^{18})$，常数较小，大概可以通过

当然你也可以写一些子集卷积之类的东西，但没必要。