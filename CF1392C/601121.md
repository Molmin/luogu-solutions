这道题其实代码并不难，只要想清楚就可以。

而我们采用的是贪心的思想，在成功的情况下使方法最优。

我们拿第样例的第一组来说：

我们根据不存在下降子序列的规则来看，目前有两个区间不符合要求（可以理解为两个连续的数据之间的差为下降），分别是 $ a_1$ 和 $a_2$ 以及 $a_2$ 和 $a_3$ 。

所以我们需要把不符合的数据 +1 ,并且可以发现，不符合的两个区间是相邻的，而相邻的就可以一起 +1 ,这样就是最优策略。

然后第二个和第三个一块加了 2 。接着第三个又加了 1 。所以答案就是 3 。

思路就是这样，接下来讲代码如何书写。

我们只需要一个循环来从前往后循环，每循环到一个点就只需要求他单独 +1 数量，也就是他前一个数比他多了几。他不需要考虑前面的情况，因为如果前面不符合，他前面的数就会带着她一起上升，这就是最优方案。

注意：算完了他需要加几后不能改变原数组，否则就不是最优策略了。

具体代码及简介注释如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,t;
long long a[200010];//数据数组 
int main()
{
	cin>>t;//输入数据组数量 
	while(t--)//多组数据循环 
	{
		cin>>n;//输入序列长度 
		for(int i=1;i<=n;i++)
		{
			cin>>a[i];//逐个输入每组数据 
		}
		long long ans=0;//定义ans来存储需要多少个“+1” 
		for(int i=2;i<=n;i++)//从第二个开始循环，因为第一个没有前面，及肯定满足要求 
		{
			if(a[i]<a[i-1]) ans+=a[i-1]-a[i];//如果不符合要求 ans 加上a[i-1]-a[i]即可。 
		}
		cout<<ans<<endl;//最后输出答案，别忘了换行（因为是多组数据） 
	}
	return 0;//完毕撒花 
}
```
最后 AC 记录：

[带注释提交记录](https://www.luogu.com.cn/record/73338931)

喊出我们的口号：~~点赞，关注，评论！~~ 珍爱生命，远离抄解！