#一道简单的模拟题，主要关注数字1下标，下面做一下当n=5时的模拟：


##未模拟时：1 2 3 4 5 6 7 8 9 10          这时1的下标为1

##一次模拟：6 1 7 2 8 3 9 4 10 5          这时1的下标为2

##二次模拟：3 6 9 1 4 7 10 2 5 8          这时1的下标为4

##三次模拟：7 3 10 6 2 9 5 1 8 4          这时1的下标为8

##四次模拟：9 7 5 3 1 10 8 6 4 2          这时1的下标为5

##五次模拟：10 9 8 7 6 5 4 3 2 1          这时1的下标为10

##六次模拟：5 10 4 9 3 8 2 7 1 6          这时1的下标为9

##七次模拟：8 5 2 10 7 4 1 9 6 3          这时1的下标为7

##八次模拟：4 8 1 5 9 2 6 10 3 7          这时1的下标为3

##九次模拟：2 4 6 8 10 1 3 5 7 9          这时1的下标为6

##十次模拟：1 2 3 4 5 6 7 8 9 10          这时1的下标为1


#这时你就会发现，只要1的下标k回到了原点，那么其他元素也回到了原点，并且：1的下标k如果大于n，那么1的下标k就要从k变为2\*(k-n)-1；如果1的下标k小于等于n，那么1的下标k就要从k变为2\*k。也就是说，1的下标k可得以下程序段：


if(k>n)k=2\*(k-n)-1;

else k\*=2;

#也就是说，如果你找到以上程序段，那么这题就好解了。


##现在，呈上代码。

##代码如下：




        

```cpp
#include <cmath>
#include <cstdio>
#include <string>
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;
int n,m;
int main(){
    freopen ("2755.in","r",stdin);
    freopen ("2755.out","w",stdout);
    scanf ("%d",&n);//读入数据
    int k=1;//1的下标k的初值为1
    while (1){//主程序代码
        if (k>n)k=2*(k-n)-1;//判断1的下标k是否大于n，如果大于，那么就将k赋为2*(k-n)-1；如果小于等于，就将k赋为k*2
        else k*=2;
        m++;//答案加1
        if (k==1)break;//判断如果1的下标k回到了起点，就退出程序
    }
    printf ("%d\n",m);//最后输出
        while (1)//反抄袭
    return 0;
}
```
#注意：m++这个语句必须在退出判断之后，否则最后答案就会少一