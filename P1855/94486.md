## 这是一道二维费用01背包题
其他背景没卵用，关键是输入输出格式所给信息关键

输入格式

第一行,n M T，表示一共有n(n<=100)个愿望，kkksc03 的手上还剩M(M<=200)元，他的暑假有T(T<=200)分钟时间。

第2~n+1行 mi,ti 表示第i个愿望所需要的金钱和时间。

输出格式

一行，一个数，表示kkksc03最多可以实现愿望的个数。


------------

从此中可看出，dp费用有**二维**，抽象可以这么说——

**有n个物品，每个物品第一种费用为mi，对应背包容量M；第二种费用为ti，对应背包容量T，求最多所取物品数量**

于是乎，这道题便转化为一道费用二维的01背包问题

“但它有二维费用，感觉好复杂啊！”蒟蒻发声

没关系，费用加一维，不过是循环加一维，数组加一维而已，实际上很简单的


------------

### 又到了喜闻乐见的上代码时间
#### case 1 三维数组

这是01背包取最大价值的代码

```cpp
for(int i=1; i<=n; i++) {
    for(int j=0; j<=m; j++) {
    if(j>=w[i])
      f[i][j]=max(f[i][j],f[i-1][j-w[i]]+v[i]);
    }
}

```

那我们无非是**多加一维**，再改为最多物品而已

```cpp
for(int i=1; i<=n; i++)//i枚举物品
    for(int j=m; j>=0; j--)//j枚举价格
    for(int k=t; k>=0; k--){//k枚举时间
        if(j+mo[i]<=m&&k+ti[i]<=t)//判断是否取
              f[i][j][k]=max(f[i-1][j][k],f[i-1][j+mo[i]][k+ti[i]]+1); 
        else f[i][j][k]=f[i-1][j][k];//继承
        ans=max(ans,f[i][j][k]);//取最终答案最大值
    }
cout<<ans;//输出
```
#### case 2 二维优化

只要你学过01背包，你肯定会写**一维优化**，这样可以节省很多空间

这是01背包一维优化的最大价值代码，特点是需要逆序枚举费用

```cpp
for(int i=1; i<=n; i++) {
    for(int j=m; j>=w[i]; j--) {
      f[j]=max(f[j],f[j-w[i]]+v[i]);
    }
}
```


同理，此题可以**二维优化**

```cpp
for(int i=1; i<=n; i++)
    for(int j=m; j>=mo[i]; j--)
    for(int k=t; k>=ti[i]; k--){
        f[j][k]=max(f[j][k],f[j-mo[i]][k-ti[i]]+1);//递推式，不难理解
    }
    cout<<f[m][t];//最终答案为f[m][t]

```

当然喽，二维优化代码更简短，空间更少，推荐大家使用

## Code

```cpp
#include<bits/stdc++.h>
#define F1(a,b,c) for(b=c;b<=a;b++)
#define F2(a,b,c) for(b=a;b>=c;b--)
using namespace std;
int n,m,t,i,j,k;
int ti[105],mo[105],f[205][205];
int main() {
    cin>>n>>m>>t;
    F1(n,i,1)cin>>mo[i]>>ti[i];
    F1(n,i,1)F2(m,j,mo[i])F2(t,k,ti[i])f[j][k]=max(f[j][k],f[j-mo[i]][k-ti[i]]+1);
    cout<<f[m][t];
    return 0;
}
```


本人做题时码的代码可能有些装B，主要推荐看上面的orz


------------
 PS：  _记忆化搜索应该也可以做，但个人不推荐，因为递归的时间总比循环多，而且——_
 
**一般来说，凡是能用记忆化写的，dp也能写。**
## 谢谢观看！