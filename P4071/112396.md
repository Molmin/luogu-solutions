## 2019.8.20(隔天）
### 我才看到题目里面要求对1e9+7取模，因此请无视下列的模法！！


这是一题错~~误~~(位)排序入门题，然而对于我这个数论渣滓来说简直是暴击。~~（看看机房别的dalao秒懂秒切）~~


------------

关于错位排序其实可以用一个很形象的描述来表达，即有n封信件，要投放到n个信箱中，但是这个邮递员有恶趣味，一定要将所有的信件都投放在不正确的信箱内，而我们要做的，就是帮他求出到底有多少种可能可以放错所有的信件。（我是成帮凶了？还有原来放错东西也是一门技术活啊喂！）

假设我们有一封给wly奆佬的信件，他的信箱是第k个，因此我们不能把这封信放在他的信箱里，我们需要另外找一个信箱g，那么此时有两个位置我们是不能放wly的信件的，即k和g两个位置（k不能放wly的信件，原本在g的信件不能放在g）。因此现在的错排就是d[n-2]。

而相反的，如果我们不将他放在g这个位置，那么也就是说wly奆佬的信件依然没有放下去，那么要在上面那种情况的基础上加上一封信，也就是n-1.因此现在的错排就是d[n-1]。

因为两者是相反的关系，因此我们都需要考虑，所以这里一共就有d[n-2]+d[n-1]种排序的方式。

然后我们发现，k的取值范围是1<=k<=n的，因此总排序数量就是(n-1)* (d[n-2]+d[n-1])种。

当我们在求d[i]的时候，我们需要明确的一点即此时的k取值范围是1<=k<=i，那么此时的公式就变为了(i-1)* (d[i-2]+d[i-1]).


------------


下面是求错排排序数量的code.

```cpp
void pre()
{
	f[0]=1;
	d[1]=0,d[2]=1,d[3]=2;
	for(int i=1; i<1000005; i++)
		{
			f[i]=f[i-1]*i%mod;
			inv[i]=C(f[i],mod-2);
		}
	for(int i=4; i<1000005; i++)
		{
			d[i]=(i-1)*(d[i-1]+d[i-2])%mod;
		}
}
```


------------

因为这道题有一个限定条件——有m个数字是已经被固定在正确的位置上的，所以我们可以预先处理这些数，将他们放在正确的位置上，然后剩下的n-m个数则是我们需要进行错排的数。

这道题有点坑的地方（其实这是题目的惯性），就是他的数据范围偏大，大到什么程度呢？他会把long long给炸掉，因此我们需要进行qpow操作以及magic操作（“模”法）。

（qpow操作）
```cpp
ll C(ll a,ll b)
{
	ll ans=1;
	while(b)
		{
			if(b&1)
				ans=a*ans%mod;
			a=a*a%mod;
			b>>=1;
		}
	return ans;
}
```

然后接下来就是特判那么一两个不乖的特例了。

当n=1、m=0的时候，是无论如何都不可能出现符合题意的情况的，因此此时的序列数为0.

当n=1、m=1的时候，总是且唯一满足题意，因此此时序列数为1.

如果m=0（n≠1）时，则无论我们怎么错排，都是符合题意的，那么只需要直接输出错排的个数d[n]即可。

对于其他的情况，也就是本题的真意，我们可以理解为有n个i满足第i位恰好为i的n~1的全排列的个数。

我们知道，1~n的全排列个数为n!，当我们固定下m个数字的时候，其他的n-m个数为错排数字，这些错排数字的排序个数则是C(m,n)了，那么代替上面的(n-1)（或者是(i-1)），可得答案为C(m,n)* （d[n-m]）。


------------

## 然后！就是我死去的“模”法了！
因为本蒟蒻没有模的习惯，因此以为只需要模一个1en+7就可以了，但是直到我把1e3~1e10都试过去之后……

总之以后养成好习惯，都模1e9+7吧！

至于1e9+7的作用是什么？

根据本蒟蒻的调查，1e9+7是十位整数里最小的质数，然后它能有效的防止int和long long爆炸（因为相加不爆int，相乘不爆long long）。


------------

下面是蒟蒻的code……（其实大家的code都大同小异……）

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
const long long mod=1e9+7;
ll f[1000005],inv[1000005],d[1000005];
int t;
ll C(ll a,ll b)
{
	ll ans=1;
	while(b)
		{
			if(b&1)
				ans=a*ans%mod;
			a=a*a%mod;
			b>>=1;
		}
	return ans;
}
void pre()
{
	f[0]=1;
	d[1]=0,d[2]=1,d[3]=2;
	for(int i=1; i<1000005; i++)
		{
			f[i]=f[i-1]*i%mod;
			inv[i]=C(f[i],mod-2);
		}
	for(int i=4; i<1000005; i++)
		{
			d[i]=(i-1)*(d[i-1]+d[i-2])%mod;
		}
}
int main()
{
	scanf("%d",&t);
	pre();
	for(int i=1; i<=t; i++)
		{
			ll n,m;
			scanf("%lld%lld",&n,&m);
			if(n-m==1) 
				printf("0\n");
			else if(m==n) 
				printf("1\n");
			else if(m==0) 
				printf("%lld\n",d[n]);
			else
				{
					printf("%lld\n",f[n]*inv[m]%mod*inv[n-m]%mod*d[n-m]%mod);//这里要用到逆元啦！具体怎么实现可以去看看别的大佬的，因为我也是向他们学习过的。
				}
		}
	return 0;
}
```
