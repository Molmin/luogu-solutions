想了大半天发现题意看反了（恼）。

------------
### Part 1：如何求 $l_i$ 和 $r_i$

既然题目给了个单调栈我们就往这方向想。

对 $a$ 建立一个单调递增的单调栈，然后我们可以利用下面的代码求出 $l$ 和 $r$（单调栈内存储下标）。

```cpp
	for(int i=1;i<=n;i++)
	{
		while(zd&&a[z[zd]]>a[i])r[z[zd--]]=i;
		l[i]=z[zd],z[++zd]=i;
	}
	while(zd)r[z[zd--]]=n+1;
```

手玩容易得证。

### Part 2：如何还原

考虑怎么把打乱的 $l$ 和 $r$ 变回去。

观察上面的代码容易发现，如果记 $t_i$ 表示 $i$ 在 $r$ 中出现的次数，那么 $t_i$ 其实就是循环运行到 $i$ 时单调栈弹出的元素个数。

显然如果 $t$ 确定，那么单调栈在每个时刻的状态也是能确定的。

求 $t$ 是简单的，所以我们可以直接求出 $t$ 后对上面代码稍作改造来求出 $l$ 和 $r$。

### Part 3：如何利用 $l$ 和 $r$

由 $l$ 和 $r$ 我们能得到 $O(n)$ 个排列 $a$ 中元素的大小关系。

再次回看一开始求 $l$ 和 $r$ 的代码，我们可以发现 $l$ 和 $r$ 正好覆盖了所有我们在单调栈求解时用到的所有的大小关系。也就是满足这里所有关系的排列 $a$ 个数就是答案。

容易想到从 $i$ 往 $l_i$ 和 $r_i$ 连单向边（$l_i=0$ 和 $r_i=n+1$ 的情况不连），显然这是个 DAG，其拓扑序的方案数就是答案。

### Part 4：如何求答案

一般 DAG 的拓扑序计数目前只有指数级做法，所以我们考虑进一步找性质。

注意到一个点的出边最多两条，考虑能不能把有两条出边的点变成只有一条，这样原图就变成了森林，有 $O(n)$ 的做法计算拓扑序数量。

实际上我们可以证明如果 $l_i\neq 0$ 且 $r_i\neq n+1$，那么必有 $r_{l_i}=r_i$ 或者 $l_{r_i}=l_i$。

>证明：
>
>根据 $l_i$ 和 $r_i$ 的定义，显然有 $a_{l_i}<a_i,a_{r_i}<a_i,\forall j\in(l_i,i)\bigcup(i,r_i),a_j>a_i$。
>
>那么有 $\forall j\in(l_i,r_i),a_{l_i}<a_j,a_{r_i}<a_j$。
>
>因为是排列，显然 $a_{l_i}\neq a_{r_i}$。
>
>于是必有 $r_{l_i}=r_i$ 或者 $l_{r_i}=l_i$。

如果 $r_{l_i}=r_i$，那么实际上我们不需要连 $i$ 到 $r_i$ 的边，也能表示出 $i$ 和 $r_i$ 的大小关系（因为已经有 $i$ 到 $l_i$ 的边和 $l_i$ 到 $r_i$ 的边了）。$l_{r_i}=l_i$ 同理。

于是每个点的出边就被缩到只剩一条了。

剩下来就是 $O(n)$ 的树形 dp 求答案了。