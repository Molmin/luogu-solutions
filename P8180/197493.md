通过大量的打表可以猜出一个结论：

> 重排后的 $l$ 和 $r$ 数组对应唯一一种未重排的 $l$ 和 $r$。

对于这个结论的证明，可能先解题后证更为直观。

--------

假设我们能直接得到未重排的 $l$ 和 $r$ 数组，思考 $l_i$ 和 $r_i$ 的意义。

这说明 $\forall\ l_i<k<r_i$，$a_k \ge a_i$。

**考虑每一个 $i$ 作为上式中 $k$ 的出现次数**，记为 $cnt_i$。

则易得如果 $a_i=1$，$cnt_i=1$。

分治到 $1$ 的左右两侧，则这两个区间的最小值的 $cnt_i=2$，其中 $1$ 次是因为它自己，$1$ 次因为序列中的 $1$。

不会存在一个和它在 $1$ 的同侧且更小的值，因为这样就违背了最小值的定义。

继续递归，容易证明这样递归的子区间中，$cnt_i$ 最小的位置 $a_i$ 也最小。

那么如果能得到 $cnt$ 数组，我们就能找到一个[笛卡尔树](https://baike.baidu.com/item/%E7%AC%9B%E5%8D%A1%E5%B0%94%E6%A0%91/7579802)的结构。

--------

有了笛卡尔树后计数就显得十分简单，因为排列的笛卡尔树一定是二叉的。

其两个子树完全是独立的，所以任何一种将数分入两个子树的方案都是合法的，每个节点上的方案数就是

$$\binom{siz_1}{siz_1+siz_2}$$

其中 $siz_{1,2}$ 表示两个子树的大小。

序列的方案数就是全部乘起来。

--------

对于求 $cnt$ 数组，每次加一个区间，直接用差分维护即可（毕竟是静态的）。

转念一想，重排对如何差分并没有任何影响。

这样，一组重排后的 $l$ 和 $r$ 数组对应一棵唯一的笛卡尔树，于是也就对应唯一的未重排的 $l$ 和 $r$ 了。

每个部分的复杂度都是线性的，所以总复杂度也是线性的。

--------

**Code：**

```cpp
long long n, Ans = 1;
int del[1000006];
int stk[1000006], siz[1000006], top;
int lch[1000006], rch[1000006];
void dfs(int x) {
    if (lch[x]) dfs(lch[x]);
    if (rch[x]) dfs(rch[x]);
    Ans = Ans * C(siz[lch[x]], siz[rch[x]]) % p;
    siz[x] += siz[lch[x]] + siz[rch[x]];
}
signed main() {
    n = read();
    init(n);
    for (int i = 1; i <= n; ++i) ++del[read() + 1];
    for (int i = 1; i <= n; ++i) --del[read()];
    for (int i = 1; i <= n; ++i) del[i] += del[i - 1];
    for (int i = 1; i <= n; ++i) {  // 建立笛卡尔树
        siz[i] = 1;
        while (top && del[stk[top]] > del[i]) lch[i] = stk[top--];
        if (top) rch[stk[top]] = i;
        stk[++top] = i;
    }
    dfs(stk[1]);
    write(Ans); puts("");
    return 0;
}
```

--------

是很小清新的一道题，对吧。

另外有一种只用 $l$ 的做法，可以去看其他人的题解，这里就不赘述了。