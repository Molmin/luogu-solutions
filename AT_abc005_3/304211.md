## 概括题意：

你现在正在做章鱼烧，章鱼烧会在 $ T $ 秒后过期，你不能让买家等你，如果**章鱼烧过期就不能卖**，求能不能全部卖完。



## 输入：

第一行输入一个 $ T $ 代表章鱼烧的保质期，也就是说章鱼烧放置的**超过 $ T $ 秒就算过期，不能卖了**。

第二行输入一个 $ n $ 代表章鱼烧的数量。

第三行输入从 $ a_1 $ 到 $ a_n $ 的 $ n $ 个正整数，代表每个章鱼烧做出来的时间。

第四行输入一个 $ m $ 代表客人的数量。

第五行输入从 $ b_1 $ 到 $ b_m $ 的 $ m $ 个正整数，表示每个客人来的时间。



## 思路：

这道题暴力枚举就可以了。

首先先判断如果客人的数量大于章鱼烧的数量，说明肯定卖不完（章鱼烧数量不够），直接输出```no```。

判断完毕后把客人来的时间和章鱼烧做出来的时间**从小到大排序**，因为输入的数据不一定是单调递增的。

接下来开始枚举，每次都卖时间最早做出来的章鱼烧（否则卖后面的会过期），有几个条件：

- **没有过期**，即做出来的时间不能超过 $ T $ 秒。


- **做出来的时间比客人来的时间要早**。

注意，这里并**没有判断章鱼烧有没有卖过**这个条件，因为从小到大排序枚举后不会出现这种情况，不理解的话可以看下面的代码部分。

如果章鱼烧都卖完了但是还有客人没吃到章鱼烧就输出```no```。

否则输出```yes```。



## 代码

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
int a[100010],b[100010];
int main()
{
	int n,t,m,y=1;
	cin>>t;
	cin>>n;
	for(int i=1;i<=n;++i)
	    cin>>a[i];
	cin>>m;
	for(int i=1;i<=m;++i)
	    cin>>b[i];
	if(m>n)//客人的数量大于章鱼烧的数量
	{cout<<"no"<<endl;return 0;}//直接输出no
	sort(a+1,a+n+1);
	sort(b+1,b+m+1);//从小到大排序
	for(int i=1;i<=m;++i)
	{
		bool x=0;
		for(int j=y;j<=n;++j)//枚举没买过的章鱼烧
		{
			if(a[j]<=b[i]&&a[j]+t>=b[i])//满足条件卖出 
			{
				x=1;
				y=j+1;//前面的章鱼烧都不能用了，从下一个开始卖，加上这句就不会有重复的章鱼烧卖出
				break; 
			}
		}
		if(!x){cout<<"no"<<endl;return 0;}//卖不出去，直接输出no 
	}
	cout<<"yes"<<endl;//每位客人都能卖出去 
	return 0;
}
```

如果你看懂了可以点击[传送门](https://www.luogu.com.cn/problem/AT821)去试一试做的对不对。