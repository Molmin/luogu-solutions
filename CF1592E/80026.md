（这好像是 CF 最近第二次出这种与起来大于异或的条件了）。

考虑什么情况下一个连续子段与起来才会严格大于异或——有一个二进制位，在该子段内二进制表示全部为 $1$，并且长度为偶数；此外，比它高的二进制位全部要打平（即与起来的结果和异或起来的相同，均为 $0$）。

考虑到 $n \leq 1\times 10^6$，因而只能 $O(n \log N)$ 的复杂度——枚举每一个二进制位，然后线性的扫一遍得到答案。

对于某一个特定的二进制位 $d$ （以下 $0,1$ 的讨论均发生在这一个二进制位上），由于需要这一段上这一个二进制位全为 $1$，因而合法段不会越过有 $0$ 的，所以考虑在两个二进制为 $0$ 的数之间统计答案。

接下来考虑其他的性质——高位全部打平，这一位上异或值为 $0$。区间求异或值一个常用方法就是前缀和。用一个 map 存储**比 $d$ 高的二进制位**上的异或前缀和——$map[x]=id$，$x$ 为异或前缀和而 $id$ 为**第一次出现这个前缀和的下标**。注意此处的前缀和是从上一个二进制为 $0$ 的数开始统计的。那么这样就可以保证尽可能的长了。

可能会有疑问说这样没法保证奇数。但是注意到一个性质——这一段全是 $1$，因而想要异或值是 $0$ 长度只能是偶数。因而不用区分奇偶性，直接用异或的性质解决。

```cpp
#include <cstdio>
#include <algorithm>
#include <map>
using namespace std;
const int N = 1000000;
int a[N + 5];
int main()
{
    int n;
    scanf("%d", &n);
    for (int i = 1; i <= n;i++)
        scanf("%d", &a[i]);
    map<int, int> pre;
    int ans = 0;
    for (int d = 0; d <= 20;d++)
    {
        pre.clear();
        int sum = 0;
        pre[0] = 1;//注意初始条件
        for (int i = 1; i <= n;i++)
        {
            if ((a[i] & (1 << d)) == 0)
            {
                sum = 0;
                pre.clear();
                pre[0] = i + 1;
                continue;
            }
            sum ^= (a[i] >> d);
            if(pre.count(sum)==0)
                pre[sum] = i + 1;//记录的是下一位
            else
                ans = max(ans, i - pre[sum] + 1);
        }
    }
    printf("%d", ans);
    return 0;
}
```