~~不得不说这道模拟真的是太废阳寿了~~

## 思路

一共 $5$ 行灯，所以输入 $5$ 个字符串。

然后开始打表。每个数字的字符如下：

```
.### ..#. .### .### .#.# .### .### .### .### .###
.#.# .##. ...# ...# .#.# .#.. .#.. ...# .#.# .#.#
.#.# ..#. .### .### .### .### .### ...# .### .###
.#.# ..#. .#.. ...# ...# ...# .#.# ...# .#.# ...#
.### .### .### .### ...# .### .### ...# .### .###
```
通过观察，可以发现每个数字都有它独特的地方。

以 $1$ 为例，可以发现 $a_{i+1}$ 的位置，即第一行第二个，只有它是 `.`。这样可以大大增加打表的效率。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
string a,b,c,d,e;
int main(){
	cin>>n>>a>>b>>c>>d>>e;
	for(int i=0;i<n*4;i+=4){
		if(b[i+2]=='.'&&c[i+2]=='.'&&d[i+2]=='.'&&e[i+2]=='#') cout<<"0";
		else if(a[i+1]=='.') cout<<"1";
		else if(d[i+3]=='.'&&d[i+2]=='.') cout<<"2";
		else if(b[i+1]=='.'&&c[i+1]=='#'&&d[i+1]=='.') cout<<"3";
		else if(a[i+2]=='.') cout<<"4";
		else if(b[i+1]=='#'&&b[i+2]=='.'&&b[i+3]=='.'&&d[i+1]=='.') cout<<"5";
		else if(b[i+1]=='#'&&b[i+2]=='.'&&b[i+3]=='.'&&d[i+1]=='#') cout<<"6";
		else if(c[i+1]=='.'&&c[i+2]=='.') cout<<"7";
		else if(d[i+1]=='#') cout<<"8";
		else cout<<"9";
	}
	return 0;
}
```
