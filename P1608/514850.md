### 题外话
建议先写这题 [P1144 最短路计数](https://www.luogu.com.cn/problem/P1144)

可以说此题为 P1144 加强版。

### 思路
分为两个操作：

1. 我们只需要在 dijkstra 中检查是否会更新点，如果更新，则将被更新的点的最少花费路径数设为 $0$。

1. 如果一个点到另一个点的花费刚好为到达的点的最小花费，即再次到达了那个点，到达的点的最小花费路径数就会加上它入度的最少花费路径。

### 核心代码
操作一：
```cpp
if (d[y] > d[minn] + z) { //d 数组为最小花费，更新操作。
	d[y] = d[minn] + z;
	q.push(make_pair(-d[y], y));
	ans[y] = 0;
}
```

操作二：

```cpp
if (d[y] == d[minn] + z) {
	ans[y] += ans[minn];
}
```
### 小坑点
重边只算边权最小的就好了。