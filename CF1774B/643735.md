### 序

如何做 CF 结论题：

1. 先猜一个结论。

2. 再口胡一下结论。

3. 再随便写出来，被叉了就回到第一步。

## 题意

给出两个数 $n,k$ 和一个序列 $a$。

问能否在每个下标 $i$ 都选 $a_i$ 次的情况下保证每 $k$ 个下标不重复。

## 思路

先假设 $n\bmod k=0$。

考虑将 $n$ 按照 $k$ 分组，每 $k$ 个为一组。

现在就是让你填入这些 $i$。

我们可以画一个表格，有 $n\div k$ 行，$k$ 列，每组占一行。

我们要做的就是保证每个填入的 $i$，从左往右遍历 $k$ 个之内没有 $i$。

最优思路就是**每列从上到下填数，从右到左处理每列**，且每次都将 $i$ 填 $a_i$ 个，一次性填完。

为什么要从右往左呢？因为从左往右的话，当 $a_i=n\div k$ 时，$i$ 按顺序填，最后一个 $i$ 会在第一个 $i$ 的右上方位置。

而从最后一个 $i$ 开始从左往右数 $k$ 个正好到第一个 $i$。

也就是说，在 $k$ 个数内出现了两个 $i$，叉掉。读者可以画一个表格自行模拟。

那么从右往左填，就有以下情况：

- 如果对于一个 $i$，$a_i>\dfrac{n}{k}$，那么你不管把这些 $i$ 填到哪个组里面去都会造成每组之中出现重复。

而出现重复，就意味着在同一行内出现了两个一样的下标，显然违反规则。

反之，则可以填入。

那么我们加入 $n\bmod k >0$ 的情况呢？

这种情况下，表格会新添一行，这一行有 $n\bmod k$ 个空出的位置（下文简称新位置），可以竖着放入一些 $a_i=\dfrac{n}{k}+1$ 的 $i$。

然而新位置只有 $n\bmod k$ 个，也就是说 $a_i=\dfrac{n}{k}+1$ 的 $i$ 个数太多时也会多出一些下标。

这些下标只能放入行数仍旧为 $n\div k$ 的列。由于 $a_i=\dfrac{n}{k}+1$，所以它们明显放不下。

于是我们可以特判一下。

## 正确代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[100001];
int t,n,m,i,k,s,p;
bool f;
int main()
{
	scanf("%d",&t);
	while(t--)
	{
		scanf("%d%d%d",&m,&n,&p);//这里把m,n反着输入了一下
		k=m/p;s=f=0;//k不一样了哦
		for(i=1;i<=n;i++) scanf("%d",&a[i]);
		for(i=1;i<=n;i++)
		{
			if(a[i]>k)
			{
				if(a[i]>k+1)//超过太多
				{f=1;break;
				}
				s++;//又有一个下标放入了新位置
				if(s>(m%p))//新位置不够ai=m/p+1的下标放
				{f=1;break;
				}
			}
		}
		puts(f ? "NO":"YES");
	}
	return 0;
}
```
