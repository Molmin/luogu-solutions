# [UVA1628 Pizza Delivery](https://onlinejudge.org/external/16/p1628.pdf)

> 你是一个披萨店的老板，有一天突然收到了 $n$ 个客户的订单。
>
> 你所在的小镇只有一条笔直的大街，其中位置 $0$ 是你的披萨店，第 $i$ 个客户所在的位置为 $p_i$，如果你选择给第 $i$ 个客户送餐，他将会支付你 $e_i-t_i$ 元。其中 $t_i$ 是你到达他家的时刻。
>
> 当然，如果你到的太晚，使得 $e_i-t_i<0$ 。你可以路过他家但是不能进去给他送餐，免得他反过来找你要钱。
>
> 最大化收益。
>
> $n \leq 100$ 。

考虑对于这种每秒代价递增的问题，一般都是代价提前计算。但是这题也不是最朴素的这类问题，因为存在可以放弃某些位置的情况。

然后就是比(我)较(又)神(不)仙(会)的状态设计环节。首先是，根据题面可知不用全部送餐，所以要把「准备送餐给ta」的人数 $k$ 放到状态里面。同时如果定义「选了某个区间内的全部数」作为状态，显然是不合适的。于是设 $f_{i,j,k,0/1}$ 表示**不考虑**区间 $[i,j]\cap\Z_+$  内的元素，还要给 $k$ 个人送餐，当前位于 $i(0)$ 还是 $j(1)$  的最小代价。那么最后答案就是 
$$
\max_{k=0}^n\{\max_{i=1}^n\{f_{i,i,k-1,0/1}+(e_i-|p_i|)\times k\}\}
$$
考虑转移。发现对于一个 $f_{i,j,k,0/1}$ 而言，必然是由一个包含 $[i,j]$ 的更大的区间 $[l,r]$ 通过切分得来的，同时为了每次只转移走一个子问题，需要 $r=j$ 或者 $l=i$ 的更大区间。于是考虑每次只转移一个点，故转移为：
$$
f_{i,j,k,0}=\max_{l\leq i<j\leq r}\{f_{l,r,k - 1,0}+(v_l-k\times |p_l-p_i|),f_{l,r,k - 1,1}+(v_r-k\times |p_r-p_i|)\}$$

$$f_{i,j,k,1}=\max_{l\leq i<j\leq r}\{f_{l,r,k - 1,0}+(v_l-k\times |p_l-p_j|),f_{l,r,k - 1,1}+(v_r-k\times |p_r-p_j|)\}$$
然后就刷表就好了？

```cpp
for (int len = n - 1 ; len ; -- len)
	for (int k = 0 ; k <= n - len ; ++ k)
    	for (int i = 1, j = i + len ; j <= n ; ++ i, ++ j){
            //cout << i << " " << j << '\n' ;
			for (int p = i + 1 ; p <= j ; ++ p){
				chkmax(f[p][j][k + 1][0], f[i][j][k][0] + val[i] - (k + 1) * abs(pos[p] - pos[i])) ;
				chkmax(f[p][j][k + 1][1], f[i][j][k][0] + val[i] - (k + 1) * abs(pos[j] - pos[i])) ;
            }
			for (int q = j - 1 ; q >= i ; -- q){
				chkmax(f[i][q][k + 1][1], f[i][j][k][1] + val[j] - (k + 1) * abs(pos[j] - pos[q])) ;
				chkmax(f[i][q][k + 1][0], f[i][j][k][1] + val[j] - (k + 1) * abs(pos[j] - pos[i])) ;
           }
        }
```

这东西看似是 $n^4$ 的，实际上跑得很快（