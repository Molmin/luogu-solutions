#### deque大法好

既可以队头队尾进出也可以队头队尾删除，多好啊！

拿样例来说，在做样例的过程中理解我的思路吧 ( ´･∀･｀)  
样例（给他们加个id，就是编号，方便加能量）：

维护一个单调递减的序列

（4，2，1）
（3，5，2）
（6，10，3）

-（4,2,1）入队
#### q:(4,2,1)

-(3,5,2)准备入队
#### q:(4,2,1)。。。(3,5,2)
因为此时队尾的4比3高，所以3发射5个能量到编号1去
#### q:(4,2,1)(3,5,2)
-（6,10,3）准备入队
#### q:(4,2,1)(3,5,2)。。。（6,10,3）
因为队尾的3比6矮，所以3发射5个能量到编号3去，3弹出队尾
#### q:(4,2,1)。。。（6,10,3）
因为队尾的4比6矮，所以4发射2个能量到编号3去，4弹出队尾
#### q:(4,2,1)（6,10,3）
此时没有站可以入队了，刚刚收到能量最多的是编号3的6，收到了7个能量，分别来自编号1,2，over

#### code:
```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
long long f[1000010],anss;
struct node{
	int h,v,id;
}e;
deque <node> q;
int main()
{
	scanf("%d",&n);
	for (int i=1;i<=n;i++)
	{
		scanf("%d%d",&e.h,&e.v);
		e.id=i;
		while (!q.empty()&&q.back().h<e.h) 
        //此时的站点可以收到所有队尾比它矮的站点的能量，相当于题目所说的向右发射 
		{
			f[e.id]+=q.back().v;
			anss=max(anss,f[e.id]);
			q.pop_back();
			
		}
		if (!q.empty()&&q.back().h>e.h) //此时站点向左发射能量给离它最近的一个站点 
		  f[q.back().id]+=e.v,anss=max(anss,f[q.back().id]);
		q.push_back(e); //入队 
	}
	printf("%lld\n",anss); 
	return 0;
}
```


