为了便于找到高度对应的能量，我们优化成：高度对应的下标i入队列，这样出队列的也是下标如是y;则对应的能量就是v[y]

**本人的代码风格：在代码中分析问题~~**
```cpp
/*
3
4 2
3 5 
6 10
高度的满足单调性：我吸收高度比我低的人，所以我来的时候，把高度比我低的都删除掉，只剩下我没有吸收的比我高的人。
！！因为从前向后的时候，你前面的人比你先入队列，你进来时就能把你前面比你低的都吸收了，但你不知道后面入队列的高低，所以只做了单向的前面。
故从后向前的时候，你后面的从比你先入队列，你进来进就你把你后面比你低的都吸收了，这样前面+后面=你的全部。
如：
 10  6  89  7
*/
#include<bits/stdc++.h>
using namespace  std;
int n,h[1000001],v[1000001],f[1000001];
int a[1000001],wei=1;//单调队列，只要尾指针，不要head=1。 
void  read()//队列中放的是高度的下标（方便找对应的能量） 
{ int i,j,k,x,y,max1;
cin>>n;
for(i=1;i<=n;i++)
cin>>h[i]>>v[i];
//构成单调队列,从前向后：入队列（从队尾开始找第1个比自己大的位置j）
//把j后面的所有元素（从j+1...<=wei-1;)删除,
//最后：第3步：把第i个的下标入队列。
wei=1;//空指针，永远等待你放元素的位置  
for(i=1;i<=n;i++)
{   // h[1]=4; ru(1)  a[1]=1;h[a[1]]=4
//h[2]=3; ru(2);  a[2]=2; h[a[2]=2]=3
//h[3]=6;ru(3);a[3]=3;h[a[j]=3]=6;
x=h[i];//第i个的高度
for(j=wei-1;j>=1;j--)//从尾到头找
if(h[a[j]]>x)// a[j]是队列中的元素，是下标是高度的下标
 break;// =x时继续找,j的最小值是0（没有1个比x大) 
else  continue;//!!高度相等是不能吸收的，所以不能删除 
for(k=j+1;k<=wei-1;k++)//从j+1开始到wei-1
{  y= a[k] ; //出队列 y=a[k]是队列中的元素：是下标 
f[i]=f[i]+v[y];//被第i个人 吸收能量 
}//j是比自己大的数，第i个人就应该插入 j+1位置。 
wei=j+1;//删除上面的那么元素，队尾指针直接变成：j+1(比自己大的后面) 
a[wei++]=i;//把高度i的下标入队列,wei永远是空 
} 
//从后向前，再填一次记忆数组
wei=1; //!!!队列一定要清空 
for(i=n;i>=1;i--)
{x=h[i];
for(j=wei-1;j>=1;j--)//j是队列中从尾到头找比x大的数
if(h[a[j]]>x)
 break;
 else continue;
for(k=j+1;k<=wei-1;k++)
f[i]=f[i]+v[a[k]];//吸收能量
wei=j+1;//wei是空位置，放在比你大的数下标j的后面:删除队列中元素
a[wei++]=i;//入队尾 
}
max1=0;
for(i=1;i<=n;i++)
{ cout<<h[i]<<"---吸收的最大能量为："<<f[i]<<endl;//此步可以省略，检查错误时用
if(f[i]>max1)
 max1=f[i];
}
cout<<max1<<endl;
}
int main  ()
{ read();
return 0;
}
```

**总的来说不算太难，注释已经很详细了，**~~算一份傻瓜攻略？~~