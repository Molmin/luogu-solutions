这是一道分类题

## 题意概要：

有一个长度为 n 的序列，里面有 n 个元素，把这 n 个元素分成三个集合：

第一个集合要求所有元素的乘积为负；

第二个集合要求所有元素的乘积为正；

第三个集合要求所有元素的乘积为 0；

## 题目分析：

### 可以对每个集合进行分析：

* 第一个集合：

既然要求所有元素的乘积为负，只要整个集合的元素中的负数的个数为奇数，那整个集合的元素乘积为负。

所以可以让这个集合只有一个元素：一个负数。

* 第二个集合：

既然要求所有元素的乘积为正，只要整个集合的元素中的负数的个数为偶数，那整个集合的元素乘积为正。

所以可以让这个集合有两种情况：

1. 所有元素为正

2. 所有元素中有偶数个负数

* 第三个集合：

只要整个集合中有一个零，那么无论其他元素为正数还是负数，最后集合元素乘积一定为零。

## 解法正确性分析：

* 第一个集合只有一个负数，所以乘积一定为负。

* 第二个集合的两种情况：

1. 所有元素均为正数，则乘积一定为正；

2. 所有元素中有偶数个负数， 其余为正数，则乘积一定为正。

* 第三个集合中有一个零，则乘积一定为零。

## 代码实现：

```
#include <iostream>
#include <cstdio>
#include <queue>
#define F1(i, a, b) for (int i = a; i <= b; ++i)
#define F2(i, a, b) for (int i = a; i >= b; --i)
using namespace std;

int a[101]; // a 数组存数列。
int n;
vector<int> S[4]; // 用 vector 存集合。

int main() {
	int fu = 0, sum = 0;
	scanf("%d", &n);
	F1(i, 1, n) {
		scanf("%d", &a[i]);
		if (a[i] < 0) ++sum; // 计数数列中负数的个数。
	}
	F1(i, 1, n) {
		if (a[i] < 0 && fu == 0) { // 如果数是第一个负数，
			fu = 1;
			S[1].push_back(a[i]); // 将此数放入第一个集合里。
			--sum;
		}
		else if (a[i] > 0 || (a[i] < 0 && sum % 2 == 0)) S[2].push_back(a[i]); // 如果数为正数或者剩余的负数个数为偶数，就把此数放入第二个集合里。
		else if (a[i] < 0 && sum % 2 == 1) {
			S[3].push_back(a[i]); // 如果剩余的负数个数为奇数，就把一个负数放入第三个集合里，这样就满足第二个条件。
			--sum;
		}
		else S[3].push_back(a[i]); // 0 放进第三个集合里。
	}
	F1(i, 1, 3) { // 输出
		printf("%d ", S[i].size());
		F1(j, 0, S[i].size() - 1)
			printf("%d ", S[i][j]);
		printf("\n");
	}
	return 0; // 好习惯
}
```