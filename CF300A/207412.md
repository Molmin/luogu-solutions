### Problem
把一个 $n$ 个元素的序列放进三个集合中，满足以下条件：

1. 第一个集合里所有元素的乘积小于 $0$

2. 第二个集合里所有元素的乘积大于 $0$
 
3. 第三个集合里所有元素的乘积等于 $0$

求一个满足条件的方案。

### Solution
很明显 $0$ 乘以任何数都得 $0$，所以第三个集合只要有 $0$ 即可，其他数无所谓。

根据小学学的负数乘法，负负得正，负正得负。

所以第一个集合里要有奇数个负数，第二个集合里要有偶数个负数。

因为只要一个满足条件的方案，所以只在第一个集合里放 $1$ 个负数，在第二个集合里放 $2$ 个负数（当然如果输入的数据中负数不够那只能放一个正数），其他数放在第三个集合中（反正乘积是 $0$ 没有影响）。
### Code
```cpp
	cin >> n;
	for (int i = 1; i <= n; i++)
		cin >> a[i], sum += a[i] < 0;//预处理出有多少个负数
	for (int i = 1; i <= n; i++) {
		if (a[i] < 0) {
			if (tot1 == 0)ans1[++tot1] = a[i];//第一个集合中至少要有1个负数
			else {
				if (tot2 < 2 && sum >= 3)//要有足够的负数
					ans2[++tot2] = a[i];//第二个集合中至少要有2个负数
				else ans3[++tot3] = a[i];//多余的数放在第三个集合中
			}
		}
	}
	for (int i = 1; i <= n; i++) {
		if (a[i] > 0) {
			if (tot2 < 2)ans2[++tot2] = a[i];//如果负数不够只能放正数
			else ans3[++tot3] = a[i];
		}
		if (a[i] == 0)
			ans3[++tot3] = a[i];//多余的数放在第三个集合中
	}
	cout << tot1 << " ";
	for (int i = 1; i <= tot1; i++)
		cout << ans1[i] << " ";
	cout << endl;
	cout << tot2 << " ";
	for (int i = 1; i <= tot2; i++)
		cout << ans2[i] << " ";
	cout << endl;
	cout << tot3 << " ";
	for (int i = 1; i <= tot3; i++)
		cout << ans3[i] << " ";
	cout << endl;//输出答案
```
