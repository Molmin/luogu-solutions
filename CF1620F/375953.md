~~CF的DP真的很畸形~~

题意：

[orz](https://www.luogu.com.cn/problem/CF1620F)

给出 $1...n$ 的一个排列 $a_1,a_2,...,a_n$，可以给若干个数取相反数，然后对于满足以下条件的 $i,j$ 连一条边

* $i<j$

* $a_i>a_j$

使得这张图是二分图，求一种取相反数的方案。

分析：

首先要知道什么是二分图。

二分图有一个重要的判定方法，就是染色 BFS。而染色为什么是对的？

很显然，一张二分图不存在奇环。

所以这张图应不存在奇环。

观察什么时候才能不存在奇环。发现对于一个三元组 $(i,j,k)$ 满足：

* $i<j<k$

* $a_i>a_j>a_k$

此时 $i,j,k$ 形成一个奇环：$i→j,j→k,k→i$

如果超出 $3$ 个元满足类似的关系，都会形成奇环。

因此序列的最长下降子序列应不超过 $2$。

从《导弹拦截》一题得知，序列的最长下降子序列```=```序列的最长上升子序列个数

因此整个序列如果要满足二分图，其最长上升子序列个数不超过 $2$。

尝试把这个序列拆成 $2$ 个子序列。

设 $f_{i,j,p,q}$ 表示考虑了 $a_1...a_i$，第一个子序列接到了 $a_i$，第二个子序列接到了 $a_j$，其中 $p=0/1$ 表示 $a_i$ 取/不取相反数，$q$ 同理，在此情况下是否能分成两个子序列。

转移：枚举 $a_{i+1}$ 取/不取相反数，接到 $a_i/a_j$ 。

为了方便表示，令 $a_{i,0}$ 为原来 $a_i$ 的值， $a_{i,1}$ 为相反数。 

1. $a_{i,p}<a_{i+1,k}$ ：$f_{i,j,p,q}→f_{i+1,j,k,q}$

2. $a_{j,q}<a_{i+1,k}$ ：$f_{i,j,p,q}→f_{i+1,i,k,p}$

显然状态数为 $O(n^2)$ 级别。

我们这里的 DP 中 $f$ 的值只是“是否能”，并没有充分利用。

利用贪心思想，显然第一个子序列接到了 $a_i$，第二个子序列最后一个数越小越好（能接更多的数）。

改进状态：

设 $f_{i,p}$ 为第一个子序列接到了 $a_i$，$p=0/1$ 表示 $a_i$ 是否取相反数，第二个子序列最后一个数（取完相反数之后）的最小值。

枚举 $k=0/1$ 表示 $a_{i+1}$ 是否取相反数。

1. $a_{i,p}<a_{i+1,k}$ ：$f_{i,p}→f_{i+1,p}$

2. $f_{i,p}<a_{i+1,k}$ ：$a_{i,p}→f_{i+1,p}$

由于要打印方案，因此在转移的同时记录路径。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=2e6+10;
int w,n,a[maxn],f[maxn][2],g[2]={1,-1},s[maxn][2];
void upd(int i,int x,int p,int b)
{
	if(f[i][x]>p)
		f[i][x]=p,s[i][x]=b;
}
void print(int i,int x)
{
	if(i-1) print(i-1,s[i][x]);
	printf("%d ",g[x]*a[i]);
}
int main()
{
	scanf("%d",&w);
	while(w--)
	{
		scanf("%d",&n);
		for(int i=1;i<=n;i++) scanf("%d",&a[i]),f[i][0]=f[i][1]=1e9;
		f[1][0]=-1e9; f[1][1]=-1e9;
		for(int i=1;i<n;i++)
		{
			for(int b=0;b<2;b++)
			{
				for(int c=0;c<2;c++)
				{
					int p=f[i][b];
					if(a[i]*g[b]<a[i+1]*g[c])
					{
						upd(i+1,c,p,b);
					}
					if(p<a[i+1]*g[c])
					{
						upd(i+1,c,a[i]*g[b],b);
					}
				}
			}
		}
		if(f[n][0]<1e9||f[n][1]<1e9) printf("YES\n");
		else printf("NO");
		if(f[n][0]<1e9) print(n,0);
		else if(f[n][1]<1e9) print(n,1);
		printf("\n");
	}
	return 0;
}
```
