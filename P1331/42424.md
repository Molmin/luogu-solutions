dfs和bfs什么的最讨厌了，这题数据不大，模拟他不香吗？

### 本题做法：模拟（含dfs思想）

就这么简单，按照常人的思路来就行啦qwq。

思路：从矩阵左上角开始往右下搜，如果出现船只一个部分，那么会出现以下四种情况，其他则为船只相互接触则输出Bad placement.

1.点形

. . .

. # .

. . .

判断很简单，只需判断右面和下面有没有其他船只（上面和左边循环的时候判断过了）。

2.横形

. . . . .

.###.

. . . . . 

先看右边有没有其他船只，若有，则一直向右寻找，同时判断下方与上方（上方是数据点10的坑）是否有其他船只部分（若有则说明船只相互接触），直到没有。

3.竖形

. . .

.#.

.#.

.#.

. . .

先看下边有没有其他船只，若有，则一直向下寻找，同时判断左边与右边（左边是数据点1的坑）是否有其他船只部分（若有则说明船只相互接触），直到没有。

4.方形

. . . .

.##.

.##.

. . . .

先看下边和右边有没有其他船只，若有，则一直向下和向右寻找其他船只部分，同时累计数值，作为判断的方形的长和宽，然后在范围内进行判断，若存在一点不为船只部分，则说明船只相互接触。

#### 每判断完一种可能，s++，同时把判断中的船只部分变回水，防止之后误判。

亮代码（代码中含更多注释请仔细思考）：
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
int n,m,k;
int a[1001][1001];//用二维数字数组储存矩阵，0为水，1为船只部分
long long s;（船只数）
int main()
{
	char c;
	int x;
	cin>>n>>m;
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			cin>>c;
			if(c=='#')
			a[i][j]=1;
		}
	}//输入
	/*for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			cout<<a[i][j]<<' ';
		}
		cout<<endl;
	}检查输入的矩阵*/
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			int t=0;//表示情况
			if(a[i][j]==1)//a[i][j]处为船只部分
			{
				if(a[i][j+1]==1)//右边有船只
				t=1;
				if(a[i+1][j]==1)//下边有船只
				t+=2;
			}
			else//不是船只部分则跳过
			continue;
			x=0; //记录是否两艘船相互接触
			if(t==0)//点形
			{
				s++;
				//cout<<i<<' '<<j<<endl;检查船只位置
				continue;
			}
			else if(t==1)//横形
			{
				for(int l=j+1;l<=m;l++)
				{
					if(!a[i][l])
					break;//船只部分结束跳出
					else if(a[i-1][l]==1||a[i+1][l]==1)//若上边或下边有其他船只部分
					{
						x=1;
					}
					a[i][l]=0;//判断过了，船只部分变为水
				}
			}
			else if(t==2)//竖形
			{
				for(int l=i+1;l<=n;l++)
				{
					if(!a[l][j])
					break;//船只部分结束跳出
					else if(a[l][j+1]==1||a[l][j-1]==1)//若左边或右边有其他船只部分
					{
						x=1;
					}
					a[l][j]=0;//判断过了，船只部分变为水
				}
			}
			else if(t==3)//方形
			{
				int e=1,f=1;//方形的长与宽
				for(int l=j+1;l<=m;l++)
				{
					if(!a[i][l])
					break;
					else//找长
					f++;
				}
				for(int l=i+1;l<=n;l++)
				{
					if(!a[l][j])
					break;
					else//找宽
					e++;
				}
				for(int l=i;l<=e+i-1;l++)//注意要-1,不然多判断一格，下面也是如此
				{
					for(int r=j;r<=f+j-1;r++)
					{
						if(!a[l][r])//如果有水
						{
							x=1;//两艘船相互接触
							break;
						}
						a[l][r]=0;//判断过了，船只部分变为水
					}
				}
			}
			if(x==1)
			break;
			s++;
			//cout<<i<<' '<<j<<endl;检查船只位置
		}
		if(x==1)
		break;
	} 
	if(x==1)//若出现船只相互接触的情况
	cout<<"Bad placement.";
	else
	cout<<"There are "<<s<<" ships.";
	return 0;
}
```

## 共同维护洛谷良好学习环境，杜绝抄袭！

2019 CSP RP++