我们设一艘船一行有h个“#”，一列有l个“#”，我们可以发现：

**如果一艘船不与别的船接触，也就是这艘船是矩形，那么这艘船由l\*h个“#”构成（和算长方形正方形的面积差不多）**，我们便可以有如下思路：

如果找到一个“#”，先把这一行的“#”的总数h找出，再把这一列“#”的总数l找出，最后用**dfs**把这个“#”所有连接的“#”的个数s统计出来,**如果s不等于l\*h,也就是这艘船不为矩形，就可以输出“Bad placement.”，终止程序**。否则就作为一艘船计入总数。

注意：

######  _如果找到一艘船，为了避免以后重复查找，要将所有构成这艘船的“#”都变成“.”。_ 

-----------
```cpp
#include<bits/stdc++.h>//万能头
using namespace std;
char a[1005][1005];//用二维数组储存整个游戏棋盘
int n,m,s,k,q;
void dfs(int x,int y) {//x、y代表棋盘中一个点的坐标
	++q;//将每个“#”都累计起来
	a[x][y]='.';//避免重复，将找到的“#”变成“.”
	if(x-1>=1&&a[x-1][y]=='#')//向下查找与当前“#”所连接的“#”，注意x的值不能小于1，否则会超出整个数组
		dfs(x-1,y);
	if(x+1<=n&&a[x+1][y]=='#')//向上查找与当前“#”所连接的“#”，注意x的值不能大于n（即这一行的“.”与“#”的个数），否则同上
		dfs(x+1,y);
	if(y+1<=m&&a[x][y+1]=='#')//向右查找与当前“#”所连接的“#”，注意y的值不能超过m（即这一列的“.”与“#”的个数），否则...
		dfs(x,y+1);
	if(y-1>=1&&a[x][y-1]=='#')//向左查找与当前“#”所连接的“#”，注意y的值不能小于1
		dfs(x,y-1);
}
int main() {
	cin>>n>>m;//读入整个棋盘的行和列
	for(int i=1; i<=n; i++) {
		for(int j=1; j<=m; j++)
		cin>>a[i][j];//输入整个棋盘
	}
	for(int i=1; i<=n; i++)
		for(int j=1; j<=m; j++) {
			if(a[i][j]=='#') {//如果找到一个“#”，就代表这个地方有船
				q=0;//注意清零
				int h,l;
				h=l=0;//行的总数河北列的总数也要清零
				for(int x1=i; x1<=n; x1++) {//将这一列与当前“#”所连通的“#”的个数找出
					if(a[x1][j]=='#') {
						++l;
					} else break;
				}
				for(int x1=j; x1<=m; x1++) {//将这一行与当前“#”所连通的“#”的个数找出
					if(a[i][x1]=='#')
						++h;
					else break;
				}
				k=h*l;//将构成这艘船的“#”的个数算出（如果这艘船不与别的接触）
				dfs(i,j);//深搜走起
				if(q!=k)//诶？如果先前把这艘船当做矩形的“#”的个数与找出的“#”的个数不同
				{
				cout<<"Bad placement.";	//表示这艘船不为矩形
				return 0;//结束整个程序
				}
                ++s;//将这艘船计入
			}
		}
		cout<<"There are "<<s<<" ships.";//输出要规范哈
	return 0;//养成好习惯
}
```
