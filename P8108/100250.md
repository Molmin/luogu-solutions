爱过不过。

果然我这样的彩笔写出来的题解充斥着一股“看上去好像没啥大问题但是为什么总觉得是低质量题解如果我把它放过了那么浑身难受不自在好像欠了洛谷一个亿”的感觉。

显然 $n^2$ 次操作可以干爆这些绀珠，因为每次操作怎么说都能消掉一个点。

对于一个操作，假设在我们最终钦定的操作结果中，它消掉了 $\{S_{x_1,y_1},S_{x_2,y_2},\cdots,S_{x_n,y_n}\}$ 这些点，那么我们可以理解成，先通过前面的操作把 $S_{x_n,y_n}$ 消到最底层，然后在前面的列执行 $\{S_{x_1,y_1},S_{x_2,y_2},\cdots,S_{x_{n-1},y_{n-1}}\}$ 的时候一波消顺便带走最后一个。

因此操作是可以从左往右扩展的。从左往右钦定操作，对于相邻的两列（我们姑且设为 $S_i=\{S_{i,1},S_{i,2},\cdots,S_{i,n}\}$ 和 $S_{i+1}=\{\texttt{\small{我懒得写了，同理}}\}$），显然要一起带走的点对之间不能相交，又要尽可能多，所以相当于求 LCS。

因此答案为 $n^2-\sum{\operatorname{lcs}(S_i,S_{i+1})}$。

问题是，本题好像没说是排列，任意序列做复杂度是不是平方的啊，是不是根本写不了啊，bzy 是不是又喝了假⑨来出题毒瘤我这样的小朋友啊。

注意到数据随机。很显然这题又是一道利用随机数据性质的没有正规解法的题目 ~~bzy 你坏事做尽~~。在随机数据下，每一列期望来看是没有多少同色的绀珠（每种颜色 $O(1)$）的。那么对于后一列的每一个绀珠 $S_{i+1,j}$，记下前一列中每一个和它颜色一致的位置。

考虑 LCS 的过程：

$$dp_{i,j}=\max\{dp_{i-1,j},dp_{i,j-1},[a_i=b_j]\times dp_{i-1,j-1}\}$$

第三项转移的次数即为相同点对数，期望为线性。

针对第三项转移的情况大力搞一搞，维护 $f_i$ 表示当前情况下(扫到第二列的前 $j$ 个），第一列以第 $i$ 个结尾的子串的最大匹配长度。

$$f_i=\max\{f_i,\max_{k<i}\{f_k+1\}\}({\forall S_{n',i}=S_{n'+1,j}})$$

随便树状数组维护一下，就完事了。

```cpp
int work(int ans=n*n)
{
    for(int i=1;i<=n;++i)
        for(int j=1;j<=n;++j)
            _index[j][col[i][j]].push_back(i);
    for(int i=1,ms=0;i<n;++i,memset(c,0,sizeof(c)),ms=0)
    {
        for(int j=1;j<=n;++j)
        {
            tot=0;
            for(auto k:_index[i][col[j][i+1]])
                indexes[++tot]=k,val[tot]=query(k-1);
            for(int k=1;k<=tot;++k)
                ms=max(ms,val[k]+1),update(indexes[k],val[k]+1);
        }
        ans-=ms;
    }
    return ans;
}
```
妈的，`index` 居然是保留字
