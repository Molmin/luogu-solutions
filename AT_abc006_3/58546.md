很明显，这题可以直接$O(1)$算法过，主要思想是分类讨论。

可以发现，从$n\times2$到$n\times4$（包括）之间的$m$都有解，其他则无解，例如下图是当$n=3$时：

![](https://s2.ax1x.com/2019/11/10/MnoHCF.png)

其中，你会发现一些规律：最少时一定是三个大人，如果脚增加一个，那么优先把一个大人变成一个老人，如果不能，就把一个老人变成婴儿（~~返老还童~~），直到三个都是婴儿。此时就是脚最多的时候。

因此我们分类讨论即可，里面的颜色的含义：
- 红色是只有大人的情况（$n\times2=m$）
- 橙色是有大人也有老人的情况（$n\times3\ge m,n\times2\not=m$）
- 蓝色是有老人也有婴儿的情况（$n\times3< m,n\times4\not=m$）
- 绿色是全都是婴儿的情况（$n\times4=m$）

因此我们有了这样一个策略，我们先判断无解的情况，再判断红色的情况，再判断绿色的情况，再判断橙色的情况，最后剩下的就是蓝色的情况。

除了橙色和蓝色，其它情况的个数很好求，其实橙色和蓝色也只是解二元一次方程组罢了。

当橙色情况时，我们假设有$a$个大人$b$个老人，依题意列出方程组：

$$\begin{cases}a+b=n\\2a+3b=m\end{cases}$$

解得

$$\begin{cases}a=3n-m\\b=m-2n\end{cases}$$

因此，直接套入即可。

当蓝色情况时，设$a$个老人$b$个婴儿，同理可解出

$$\begin{cases}a=4n-m\\b=m-3n\end{cases}$$


------------
代码：
```cpp
#include<cstdio>
#define O(x,y,z) {printf("%d %d %d\n",x,y,z);return 0;}//宏定义方便
int n,m;
int main(){
	scanf("%d%d",&n,&m);
	if(n*4<m||n*2>m)O(-1,-1,-1)//无解情况
	if(n*2==m)O(m/2,0,0)//红
	if(n*4==m)O(0,0,m/4)//绿
	if(n*3>=m)O(3*n-m,m-2*n,0)//橙
	else O(0,n*4-m,m-n*3)//蓝
}
```