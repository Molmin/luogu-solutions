## 思路

首先可以知道，这个序列的权值最大不超过 $2n-1$，因为对于最后一个数，如果之前的 $x$ 小于这个数，则可以加起来，此时最优情况是最后一个数为 $n$，而前面的 $x$ 为 $n-1$。否则 $x$ 大于等于最后这个数，则最终的权值只能为 $0$。

现在把问题转化成了构造权值为 $2n-1$ 的序列。

进一步转化，可以将 $n-1$ 和 $n$ 放在最后两个，那么只需要使得 $1,2,\cdots n-2$ 的权值为 $0$。

可以发现一些性质：

* 若之前的权值为 $0$ 且接下来两个数为 $x,x-1$，则权值仍然为 $0$。

* $1,2,3$ 放在最开始，权值为 $0$。

那么此时可以对 $n$ 的奇偶性分讨。

* $n$ 为偶数：构造 $n-2,n-3,\cdots,2,1,n-1,n$。这样前面 $n-2$ 个数每两个数权值就会清一次 $0$。

* $n$ 为奇数：在最开始放 $1,2,3$，之后放 $n-2,n-3,\cdots ,5,4,n-1,n$。这样前 $n-2$ 个数的权值还是 $0$。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
 
int main()
{
	int t,n,a;
	cin>>t;
	while(t--)
	{
		cin>>n;
		if(n%2==0)
		{
			for(int i=n-2; i>=1; --i) cout<<i<<' ';
		}
		else
		{
			cout<<1<<' '<<2<<' '<<3<<' ';
			for(int i=n-2; i>=4; --i) cout<<i<<' ';
		}
		cout<<n-1<<' '<<n<<'\n';
	}
}
```