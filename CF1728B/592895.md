Preface
---
日常构造被诈骗![](//啧.tk/kk)

乱搞吃了三发罚时![](//啧.tk/kk)

另外，观察样例法对部分题有用（因为其他诈骗题都把样例输出搞的很 ex 以至于你一眼看不出来规律）。对此题来说有用，但不是那么有用（比如第三个样例故意让你看不出来）。

Analysis
---
首先~~观察样例~~一阵分析可得最优答案一定为 $n\times2-1$。易证此结论：当 $x=n-1,p_n=n$ 时 $x<n$，$x$ 达到最大值。构造方法：当前 $n-2$ 个数得到的 $x=0$ 时，最后两个数为 $n-1$ 和 $n$，可以让 $x$ 达到最大值。

现在考虑如何让前 $n-2$ 个数得到 $x=0$。

首先，如果 $p$ 的前 $n-2$ 个数单调递减，那么第偶数次操作后 $x$ 必为 $0$ （因为当 $x\not=0$ 时必有 $x>p_?$，这时 $x$ 会被赋值为 $0$）。那么结论很显然了：
- 如果 $2\ |\ n$，那么 $2\ |\ (n-2)$，直接照上面构造即可。
- 否则，需要先构造一个单调递增的长度为 $2$ 的序列，然后再让后面单调递减。这样前 $2$ 个操作会让 $x\not=0$，后面的每个操作改变 $[x=0]$ 的值。

Code
---
```cpp
bool major(){
	n=read();
	if(n&1){
		printf("%d %d ",n-3,n-2);
		for(int i=n-4;i>=1;i--)printf("%d ",i);
	}
	else for(int i=n-2;i>=1;i--)printf("%d ",i);
	printf("%d %d\n",n-1,n);
}
```

撒花！