**0. 前言**  
这么棒一道构造+思维题没人交题解还是挺意外的。  

**1. 分析**  
实际上，前面的数是什么关系并没有最后几个数大。  
我们不妨调皮地想一个极端情况：最后一个数放 $1$。  
那么如果前面的所有数运算完之后是 $0$ 那么最终结果就是 $1$，否则就是 $0$。  
发现了吗？假设最后一个数放的是 $k$，并且前面的 $n-1$ 个数的运算结果 $<k$，那么最终的结果会等于 $k+x(x<k)$，最大为 $2k-1$。  
我们已经说明了最后一个数放 $n$ 在理论最大值上占有绝对优势。我们继续来说明任意的排列 $p_0$，如果 $n$ 不放在最后一位，总有 $p_1$ 满足 $f(p_1)>f(p_0)$;  
其中 $f(p)$ 表示 ~~fast_photon~~ 一个排列 $p$ 进行运算后的结果。  
>其实根据上面的结论我们不难想到，只要说明把 $n$ 换到最后一位能增大运算结果就可以了。  
我们假设此时 $p_k=n$，那么我们可以说：在第 $k$ 次及以后的操作中至少归零了一次。  
如果不是，那么显然第 $k$ 次没有归零，也就是说前 $k$ 次运算的结果是一个数加上 $n$，大于任意的 $1\le x\le n$，那么下一次一定归零。  

到这里，你可能就会发现我在上面的叙述中添加“如果 $n$ 不放在最后一位”的原因了。  
好的，那么 $n$ 已经放在了最后一位，接下来怎么办呢？  
还记得刚才证明过的 $f(p)\le 2n-1$ 吗？  
我们只需要把 $n-1$ 放在倒数第二位，然后让他在倒数第三位的时候清零一次就可以了。  
其实构造方案数不胜数，我这里只说我在赛场上想到的。  
>如果想让他在 $n-2$ 的位置清零，那么就可以放置一个 $1$，但是又不能在 $n-3$ 的位置清零，那么放置一个 $n-2$，在 $n-4$ 的位置放置一个 $2$，...  

上面这段文字可能有点晦涩难懂，我们把它翻译成人话。   
构造一个 $p$，使得 $p_1<p_2>p_3<p_4>p_5<\dots>p_{n-2}$ 或者 $p_1>p_2<p_3>p_4<p_5>\dots>p_{n-2}$。不难发现，奇数位和偶数位中的一个在相邻上一定比另一个大。  
这题只是要构造一个，我们先拿奇数大于偶数说事，此时可以不放让奇数最小的大于偶数最大的，也就是从 $1$ 到 $x$ 放在奇数位上，剩下的放在偶数位上。  

**2. 代码**  

```cpp
#include<iostream>
#include<cstdio>

using namespace std;

int t, n, a[105];

int main() {
	cin >> t;
	while(t--) {
		int q = 1;
		cin >> n;
		for(int i = 1; i <= n; i++) {
			a[i] = i;
		}
		for(int i = n - 2; i >= 1; i -= 2) {//放入较大的那部分数
			a[i] = q;
			q++;
		}
		if((n - 3) % 2 == 0) {
			for(int i = 2; i <= n - 3; i += 2) {//较小的，但是要判断n的奇偶性，考场上大概是脑子短路了没想到直接从n-3倒序枚举
				a[i] = q;
				q++;
			}
		}
		else {
			for(int i = 1; i <= n - 3; i += 2) {q;
				q++;
			}
		}
		for(int i = 1; i <= n; i++) {
			cout << a[i] << ' ';
		}
		cout << endl;
	}
} 
```

**3. 后言**  
我的导师说过一句话：大胆猜想，小心求证。  
我认为，对于任意一道题目，在想的时候要大胆猜想，写的时候要小心求证。时间不够的时候大胆猜想，有时间就要小心求证。这句话本是我的数学老师说的，我认为在信息学领域同样适用。