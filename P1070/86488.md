萌新的第二篇题解
代码没怎么简化但自觉思路清晰

这道题是一道神奇的动规

题曰：

》游戏从小新第一次购买机器人开始计时

》当马路上的机器人行走完规定的次数之后会自动消失，小新必须立刻在任意一个机器人工厂中购买一个新的机器人，并给新的机器人设定新的行走次数

这两个规定决定了任何时间，道路上有且仅有一个机器人

即使金币数是负的你也得硬着头皮走下去

（前20个点不用考虑这两条_(:3/L)\ 似乎是因为都是正的

但第21个测试点还不考虑这个问题的话
它会在开始计时第2秒才买机器人，不符合题意)

然后就是dp了

现在时间是j,你要到达第i个工厂，
那么你一定会经过第i-1(如果i==1那么就是n)条道路

吃到第j秒出现在这条路上的金币

但是你有两种选择

一，从i-1个工厂已经用过的机器人过来

二，之前的爆掉,在i-1号工厂新买一个，并扣除成本c[i-1]

如果采取第二种方法，那么不管你爆哪路来的机器人都没问题

既然如此就爆掉上一秒那个钱最多的吧！

不考虑步数的话最优解只要比较两个谁大就行了

```cpp
int x=i-1;
if(x==0)
	x=n;
int bw=w[x][j-1][0]>w[x][j-1][1]?w[x][j-1][0]:w[x][j-1][1];
w[i][j][0]=bw+g[x][j];
w[i][j][1]=h[j-1]-c[x]+g[x][j];
if(w[i][j][0]>h[j]||!gn[j]){
	h[j]=w[i][j][0];
	gn[j]=true;
}
if(w[i][j][1]>h[j])
	h[j]=w[i][j][1];
if(h[j]>ans)
	ans=h[j];
```

注：这里用w[i][j][0]和w[i][j][1]两个数记录是为了方便之后考虑步数的情况下，重新计算时方便计算差值，

w[i][j][0]表示这一步用旧机器人走到这一步的最大金钱，w[i][j][1]表示这一步新买...

计算答案的话要分别比较

然后(大概)就是本题最麻烦的东西了：步数p

（前20个点不用考虑这个问题，步数够了直接按买新的算）
（然而如果不考虑这个因素，从某个角度来讲就没有真正解决这道题）

你遇到了一个尴尬的境地：

从上个工厂用过的机器人直接走到这个工厂比新买一个省钱

但是步数不够了(从第i-p个工厂购买来的机器人用到j-1秒，并为j-1秒的最优方案)

那么你一定会思考一个问题：可不可以从之前的某个工厂提前购买一个呢

这样的话对于j-1秒的情况可能不是最佳方案，但对于第j秒可能更好一些

这样体现了之前的两种情况分开写的必要性

“回归到之前的某个工厂重新再来”：

```
void bk(int x,int y){
	int lx=x-p+1,ly=y-p+1;
	if(lx<=0)
	lx+=n;
	int mc=0;
	for(int i=1;i<=p;i++){
	int ct=w[lx][ly][1]-w[lx][ly][0];
		if(i==1||ct>mc){
			t[x][y]=y-ly+1;
			mc=ct;
		}
		lx++;ly++;
		if(lx>n)
			lx-=n;
	}
	w[x][y][0]+=mc;
}
```
调用这个函数之前给w[i][j][0]按“不算步数时用旧机器人的情况”
赋值

第lx步以后执行的操作没有区别，所以只是在这一步有所亏损
（之前按一直用旧机器人计算，现在按新买计算）

ct就是亏掉的数字，取最大值加在w[i][j][0]上即可

需要注意：

1，只有当某一步出现步数超过最大值 且 此时用旧的机器人比新买一个机器人的情况更省钱
（如果两者的钱相等则优先新买，可以节省步数）

2，最后要循环到点(i,j)本身，因为“在这一步机器人爆掉，但同时在本工厂再买一个”有可能是最佳选择

如果没有出现步数超额的情况就完全不考虑步数的问题
，因为此前每一步都是最优，而没有必要走一步就重新计算一次

这样就避免了很多不必要的循环

贴代码：
```cpp
#include<cstdio>
using namespace std;
const int N=1009;
int n,m,p,g[N][N],c[N],w[N][N][2],t[N][N],h[N],ans;
bool gn[N];
void bk(int x,int y){
    int lx=x-p+1,ly=y-p+1;
    if(lx<=0)
        lx+=n;
    int mc=0;
    for(int i=1;i<=p;i++){
        int ct=w[lx][ly][1]-w[lx][ly][0];
        if(i==1||ct>mc){
            t[x][y]=y-ly+1;
            mc=ct;
        }
        lx++;ly++;
        if(lx>n)
            lx-=n;
    //	printf("%7d(%d,%d)\n",ct,x,y);
    }
    w[x][y][0]+=mc;
}
int main(){
    scanf("%d%d%d",&n,&m,&p);
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)
            scanf("%d",&g[i][j]);
    for(int i=1;i<=n;i++){
        scanf("%d",&c[i]);
        w[i][0][1]=0-5-c[i];
        w[i][0][0]=0-5-c[i];	
    }
    for(int j=1;j<=m;j++)
        for(int i=1;i<=n;i++){
            int x=i-1;
            if(x==0)
                x=n;
            int bw=w[x][j-1][0]>w[x][j-1][1]?w[x][j-1][0]:w[x][j-1][1];
            w[i][j][0]=bw+g[x][j];
            if(t[x][j-1]>=p&&bw>h[j-1]-c[x])
                bk(i,j);
            w[i][j][1]=h[j-1]-c[x]+g[x][j];
            t[i][j]=w[i][j][0]>w[i][j][1]?(t[x][j-1]+1):1;
            if(w[i][j][0]>h[j]||!gn[j]){
                h[j]=w[i][j][0];
                gn[j]=true;
            }
            if(w[i][j][1]>h[j])
                h[j]=w[i][j][1];
        //	printf("%4d:%d-%d-(%d,%d)\n",w[i][j][0],w[i][j][1],t[i][j],i,j);
            if(h[j]>ans)
                ans=h[j];
        }
    printf("%d\n",ans);
return 0;}
```
（注释掉的代码用来debug）

这道题有21个测试点，前20个4分，最后一个20分

我几次提到“前20个点不用考虑这个问题”

也就是说即使不回头重新计算，不考虑负数你也有80分拿

甚至针对第21个点的数据写一个判断输出答案就可以轻松拿所有分
（最优解，24ms，就是这么做的）

但是一来真正比赛时没人告诉你哪个点是具体什么数字，只能尽力去写出正确的算法

二来这样做有一股浓浓的应试气息，个人认为既然写代码就应该把题目当作问题来解决，而不是以拿分为唯一目标；另一方面，如果能周全地考虑到问题的所有情况，彻底解决这一问题，相信分数不会辜负你的期望



