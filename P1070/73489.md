题解几乎都是填表法，只有一篇刷表法。我再来写一篇$O(n^3)$刷表题解。

填表法就是从后往前算，比如用$f[i]$计算出$f[i-1]$的值。

而刷表就是反过来，比如用$f[i]$计算出$f[i+1]$的值。

那么对于当前这一列，它有可能在计算后面任何一列时被用到.

![]( https://cdn.luogu.com.cn/upload/pic/71104.png )

比如对于选择时刻2的第二个数字得到的序列（红色方块），它就有可能作为第3,4,5,6,7列最优解的最后一步（即候选答案）。所以在算第二列时就可以把它们考虑一遍。
```
//f[i]表示只考虑前i列的最优解
for (int y = 1; y <= M; y++)//枚举每一列
	for (int x = 1; x <= N; x++)//枚举每一排
	{
		int v = f[y-1] - d0[x];//选(x,y)要d0[x]个金币，同时继承上一列的答案。
		for (int k = 0; k < min(P,M-y+1); k++)
		{//不能越界
			int p = x+k>N ? x+k-N : x+k;
            //避免取模是最重要的卡常
			v += d[p][y+k];
            //v 为对角线上一路累计的答案
			f[y+k] = max(f[y+k], v); 
            //用备选答案刷新以后的f值。
		}
	}
```
$O(n^3)$看似多达1e9，但是第三层循环跑不满，稍微卡常就可以通过。