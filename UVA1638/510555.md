# 解析
我们先考虑如何构造一个有 $n$ 根杆子，从左往右看能看到 $l$ 根，从右往左能看到 $r$ 根的排列。

也许直接构造可能会比较难，但如果我们将构造的过程看作将一个有 $n - 1$ 根杆子的排列中的每根杆子的高度都增大 $1$ 之后再在排列中插入一个高度为 $1$ 的杆子的话，就很简单了。

如果我们有一个有 $n - 1$ 根杆子，从左往右看能看到 $l - 1$ 根，从右往左能看到 $r$ 根的排列的话，我们只需要将新插入的杆子放在排列的最左边，就可以获得一个有 $n$ 根杆子，从左往右看能看到 $l$ 根，从右往左能看到 $r$ 根的排列。如果我们有一个有 $n - 1$ 根杆子，从左往右看能看到 $l$ 根，从右往左能看到 $r - 1$ 根的排列的话，我们只需要将新插入的杆子放在排列的最右边，就可以获得一个有 $n$ 根杆子，从左往右看能看到 $l$ 根，从右往左能看到 $r$ 根的排列。

但是，我们并不是什么时候都有上面这两种排列。如果我们只有一个有 $n - 1$ 根杆子，从左往右看能看到 $l$ 根，从右往左能看到 $r$ 根的排列的话，该怎么办呢？

假如现在我们有一个 $n = 4$ 的排列：

```
4 2 1 3
```

（此时 $l = 1,r = 2$。）

我们先将原排列中的每根杆子的高度都增大 $1$，

```
5 3 2 4
```

接下来，我们要考虑在哪里插入这根新杆子。

我们可以发现，当这根新杆子插在第 $1$ 根杆子后面时，会被第 $1$ 根杆子挡住，插在第 $i(1 \leq i \leq n)$ 根后面都是如此。当这根新杆子插在第 $1$ 根杆子前面时，会被第 $1$ 根杆子挡住，插在第 $i(1 \leq i \leq n)$ 根前面也都是如此。一波分析之后，我们可以得出：

当我们有一个有 $n - 1$ 根杆子，从左往右看能看到 $l$ 根，从右往左能看到 $r$ 根的排列时，有 $n - 2$ 种插入方法，使得我们可以得到一个有 $n$ 根杆子，从左往右看能看到 $l$ 根，从右往左能看到 $r$ 根的排列。

至此，我们便可以想到一个 dp 的做法：

设 $dp_{i,l,r}$ 表示有 $n$ 根杆子，从左往右看能看到 $l$ 根，从右往左能看到 $r$ 根的排列个数。根据上述结论，我们很快就可以推出状态转移方程。

$$dp_{i,l,r}=dp_{i - 1,l,r} \times (i - 2) + dp_{i - 1,l - 1,r} + dp_{i - 1,l,r - 1}$$

初始化为 $dp_{1,1,1} = 1$。

最后扯句废话：要想 $n \geq 2$ 时数据有解的话，$l$ 和 $r$ 一定要满足 $3 \leq l + r \leq n + 1$，但是因为这没啥用，所以在此不作证明。
# AC code
```c++
#include<bits/stdc++.h>
//#pragma GCC optimize("Ofast")
#define N 205
#define int1 long long
using namespace std;
int1 t,n,i,j,k,l,r,dp[N][N][N];
int1 read(){//sb 快读。
    int1 x = 0,f = 1;
    char ch = getchar();
    while(!isdigit(ch)){
        if(ch == '-'){
            f = -1;
        }
        ch = getchar();
    }
    while(isdigit(ch)){
        x = (x << 1) + (x << 3) + ch - '0';
        ch = getchar();
    }
    return x * f;
}
void print(int1 x){//sb 快写。
    if(x < 0){
        putchar('-');
        x = -x;
    }
    if(x > 9){
        print(x / 10);
    }
    putchar(x % 10 + 48);
    return ;
}
int main(){
	//freopen("arrange.in","r",stdin);
	//freopen("arrange.out","w",stdout);
	dp[1][1][1] = 1;
	for(i = 2; i <= 20; i++){
		for(j = 1; j <= i; j++){
			for(k = 1 + (j == 1); j + k - 1 <= i; k++){
				dp[i][j][k] = (dp[i - 1][j][k] * (i - 2) + dp[i - 1][j - 1][k] + dp[i - 1][j][k - 1]);//dp。
			}
		}
	}
	t = read();
	while(t--){
		print(dp[read()][read()][read()]);
		putchar('\n');
	}
	return 0;
}

```