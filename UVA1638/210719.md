**一道脑回路清奇的递推题**

$n \leq 20$,看这数据范围就是到是搜索或 $ O(n^3)$ 的算法。

设 $dp_{i,j,k}$ 表示放了 $i$ 跟棍子，从左边和从右边分别能看到 $j$ 个和 $k$ 个棍子的方案数。

考虑已经放了 $i-1$ 个棍子，现在要放高度为 $i$ 的棍子的情况，那么高度为 $i$ 的杆子可能会挡住很多其他杆子，看上去很难写出递推式。 

于是要换一个思路，设我们已经放了高度为 $2,3,\cdots i$ 的棍子，现在要放高度为 $1$ 的棍子，转移就很简单了。

1. 插到最左边，则从左边能看到它，从右边看不见。 
1. 如果插到最右边，则从右边能看到它，从左边看不见。 
1. 插到中间，则不管从左边还是右边都看不见它，并且有 $i-2$ 个位置可以插入。

又可以发现，看不看得到棍子其实与棍子本身的高度无关，而与棍子之间相对的高低有关，所以摆高度为 $1,2,\cdots i-1$ 的棍子和高度为 $2,3,\cdots i$ 的棍子的方案数一样，所以递推式就很简单了：

$$ dp_{i,j,k}=dp_{i-1,j-1,k}+ dp_{i-1,j,k-1}+ dp_{i-1,j,k} \times (i-2)$$

时间复杂度正好 $ O(n^3)$
```cpp
#include <iostream>
#define int long long
using namespace std;
const int kMaxN=21;
int dp[kMaxN][kMaxN][kMaxN];
int t;
signed main()
{
cin>>t;
dp[1][1][1]=1;
for(int i=2;i<=20;i++)
{
  for(int j=1;j<=i;j++)
  {
    for(int k=1;k<=i;k++)
    {
      dp[i][j][k]=dp[i-1][j-1][k]+dp[i-1][j][k-1]+dp[i-1][j][k]*(i-2);
    }
  }
}
while(t--)
{
  int a,b,c;
  cin>>a>>b>>c;
  cout<<dp[a][b][c]<<"\n";
}
return 0;
}
```
码字不易，在线求过。
