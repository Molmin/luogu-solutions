## 题意描述：

给出 $T$ 组 $n$ , $l$ , $r$ 。问 $n$ 根长度分别为 $1$ 到 $n$ 的柱子有多少种排列可以满足从左边看看到 $l$ 根柱子，从右边看看到 $r$ 根柱子。

## 做题思路：

首先应该能明显地看出这是一道典型的 $dp$ 题，我们考虑怎么进行 $dp$ 。

**状态显而易见的 $f[i][j][k]$ 表示 $i$ 根柱子，从左看能看到 $j$ 根，从右看能看到 $k$ 根的摆放数。**

**接下去思考转移。**

转移一般都是从 $i-1$ 转移到当前的第 $i$ 位的嘛，思考如果先放好的是长度为 $1$ 到 $i-1$ 的柱子，从中插入长度为 $i$ 的柱子。我们发现这样转移很困难（甚至可以说应该是无法实现的），因为每次这根柱子放的位置变一下，它对左右两边能看到的柱子数都会有影响，很难统计（感觉压根无法统计的啊）。

所以我们 ~~果断选择放弃做这题~~ 换种思路，**考虑先放好的是长度为 $2$ 到 $n$ 的柱子已经放好了，需要从中插入长度为 $1$ 的柱子。**

为什么这么考虑呢？

因为最短的柱子放在最左边，只会对左边能看到的柱子数量起一个 $1$ 的贡献，无法影响右边看到的柱子数量。同理，放在最右边只会对右边看到的柱子起一个 $1$ 的贡献，无法影响左边看到的柱子数量。而放在中间呢？放在中间任意一个位置都不会对两边有任何影响，所以转移就很好想了：

 $f[i][j][k]=f[i-1][j-1][k]*1+f[i-1][j][k-1]*1+f[i-1][j][k]*(i-2)$ 
 
 为什么要分别乘上 $1$ , $1$ 和 $i-2$ 呢？因为放在最左边只有最左边一个位置供它选择摆放，转移过来的方案数自然乘 $1$ ，放在最右边同理，放在中间有 $i-2$ 个位置供它选择摆放，自然要把转移过来的方案数乘上 $i-2$ 。
 
初始就是 $f[1][1][1]=1$ （只有一根柱子自然只有左边看去一根右边看去一根的情况 ~~难不成它还会隐身吗？！~~）。

答案就是对于每次的询问，对应输出 $f[n][l][r]$ 即可。

复杂度 $O(20*20*20+T)$ ，很优秀。

## 代码实现：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
#define dd c=getchar()
inline int read(){int s=0,w=1;char c;while (dd,c>'9' || c<'0') if (c=='-') w=-1;while (c>='0' && c<='9') s=s*10+c-'0',dd;return s*w;}
inline void write(int x){if (x<0) putchar('-'),x=-x;if (x>=10) write(x/10);putchar(x%10|'0');}
inline void wln(int x){write(x);puts("");}
inline void wlk(int x){write(x);printf(" ");}
#undef dd
int f[23][23][23];
signed main(){
	int T=read();f[1][1][1]=1;
	for (int i=2;i<=20;++i) for (int j=1;j<=i;++j)
	 for (int k=1;k<=i;++k) f[i][j][k]=f[i-1][j-1][k]+f[i-1][j][k-1]+f[i-1][j][k]*(i-2);
	while(T--) wln(f[read()][read()][read()]);
	return 0;
}
/*
状态:f[i][j][k]表示i个柱子,左看有j根,右看有k根的方案数.
转移:f[i][j][k]=f[i-1][j-1][k]+f[i-1][j][k-1]+f[i-1][j][k]*(i-2).
	解释:如果把最短的放在最左边,对左边看到的数量有1的贡献但是对右边无贡献;
		 如果把最短的放在最右边,与放在最左边的影响相反;
		 放在中间,不会对两边有任何影响,但是有n-2个位置可以放这根最短的柱子,所以转移过来要乘n-2个位置. 
初始:f[1][1][1]=1,其余初始为0.
答案:f[n][l][r]. 
} 
*/
```
