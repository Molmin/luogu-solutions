暴力能过

评测机真是卡，测了半天。。

本来以为是模拟踢球的什么东西，结果来了这一茬。。

~~（以上为废话~~

先重新康康题目：

>有一天看比赛时，Petya是如此无聊以至于在纸上写下各个球员的当前位置。为了看起来好看，他把各个球员用$1$与$0$来表示，$1$与$0$表示不同球队的人。如果一个队至少有七个人是站在一起的，那么就被认为很危险。例如，$00100110111111101$被认为是危险的（因为有$7$个$1$连在一起），而$11110111011101$则不是。现在Petya给了你现在的球队情况，让你判断是否危险。

其实说白了就是让你判断一个由$0$和$1$组成的数组中有没有$a_i$~$a_{i+6}$相等的情况。有，输出$YES$；没有输出$NO$。

那就写个循环暴力呗~


哦，不过，在惨不忍睹的暴力之前，先得做个小小的判断：

```cpp
if(n<7) {
	printf("NO\n");
	return 0;
}
```

大致就是判断这个$01$串的长度是否$≥7$。

这是很有必要的，原因有两点：

1.  从时间的角度出发

如果特判成立（即$n<7$），那只要输出就可以了。但是如果没有特判，循环必定会耗时更多（功劳归属于我们十分香的$if$判断）。所以，特判能省时。

2. 从答案的准确性角度出发

你没有特判，如果$a_{i+?}$不属于这个$01$串，那数组里是什么数我就不能保证了。所以，很可能影响答案的正确性。

>PS:$?$为未知数（$≤6$）

代码就不详细讲了，相信各位弄明白了之后都能写出来。

$code$
```cpp
#include<bits/stdc++.h>
using namespace std;
string s;
int n;
int main() {
	cin>>s;
	n=s.length();
	int x=1;
	if(n<7) {
		printf("NO\n");
		return 0;
	}
	for(int i=0; i<n; ++i) {
		if(s[i]==s[i+1]&&s[i+1]==s[i+2]&&s[i+2]==s[i+3]&&s[i+3]==s[i+4]&&s[i+4]==s[i+5]&&s[i+5]==s[i+6]) {//判断
			printf("YES\n");
			return 0;
		}
	}
	printf("NO\n");
	return 0;
}
```