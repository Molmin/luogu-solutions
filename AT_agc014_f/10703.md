在博客园食用更佳：[https://www.cnblogs.com/PinkRabbit/p/AGC014.html](https://www.cnblogs.com/PinkRabbit/p/AGC014.html)。

我们注意到一个关键性质：值为 $1$ 的元素所在的位置，并不影响其它元素是 high 或者 low，也不影响操作后它们的相对位置。

这提示我们先删去元素 $1$ 然后观察剩下的值在 $[2, N]$ 中的元素构成的序列。

更进一步地我们可以考虑递推：让 $i$ 从 $N$ 到 $1$，每次只考虑值在 $[i, N]$ 中的元素构成的序列。

此时我们以如何从 $i = 2$ 转移到 $i = 1$ 为例说明算法流程：

假设 $[2, N]$ 内的元素需要恰好 $T$ 步排好序。

如果 $T = 0$，也就是说初始时就排好序了，则如果元素 $1$ 在开头，答案就为 $0$，否则答案为 $1$。

如果 $T \ge 1$，则考虑包含元素 $1$ 的序列在 $T$ 步后，元素 $1$ 的位置，如果恰好在序列开头答案就为 $T$，否则答案为 $T + 1$。

如何判断元素 $1$ 在 $T$ 步后是否会在序列的开头？

考察 $T - 1$ 步后的情况（注意只有 $T \ge 1$ 时才有意义，这就是为什么要对 $T$ 分类）：

- **引理** $\boldsymbol{1}$**：**只包含 $[2, N]$ 的序列在 $T - 1$ 步后的开头的元素一定不是 $2$。
- **证明** $\boldsymbol{1}$**：**反证法，假设是 $2$，且此时序列还未排好序，这等价于存在 low 元素，则再进行一次操作 $2$ 必不在开头。

令开头元素为 $f$，上面证明了 $f > 2$。

注意到如果 $T - 1$ 步后，元素 $1$ 的位置落在 $f$ 与 $2$ 的位置之间，则再进行一次操作 $1$ 就会在开头，否则 $1$ 一定不在开头。

我们需要判断 $T - 1$ 步后元素 $1$ 的位置是否会在 $f$ 与 $2$ 之间。

我们先给出一个结论：如果在初始时元素 $1, 2, f$ 的「循环顺序」，恰等于 $(f, 1, 2)$，则最终元素 $1$ 的位置就会在 $f, 2$ 之间。

此处循环顺序相等，等价于在循环移位下同构。即 $(a, b, c)$ 与 $(b, c, a)$ 和 $(c, a, b)$ 相等。

对这个结论的证明，我们通过证明「在任意时刻下，一次操作均不会改变 $1, 2, f$ 的循环顺序」来显示。

要证明此结论，先证明一个引理（此引理的背景为，忽略元素 $1$，即只考虑值在 $[2, N]$ 中的元素）：

- **引理** $\boldsymbol{2}$**：**在前 $T - 1$ 步中的任意时刻，除非元素 $f$ 作为第一个元素出现，否则 $f$ 均不会成为 high 类元素。
- 也就是说如果 $f$ 成为了 high 类元素，当且仅当它处于序列的开头（第一个元素永远是 high 类元素）。
- **证明** $\boldsymbol{2}$**：**假设在某一个时刻 $f$ 成为了非开头的 high 类元素，操作后它将会处于在它前面的第一个 high 类元素后一位。
- 此时 $f$ 比它前一个元素大，这意味着它们始终会紧挨着，除非它前一个元素为 low 而 $f$ 为 high 的情况发生了。
- 如果它们始终紧挨着，则 $f$ 就永远没有机会成为第一个元素，而这正是 $T - 1$ 步后所要求的情况。
- 如果特殊情况发生了，则操作时 $f$ 实际上还是一个非开头的 high 类元素，回到初始情况，这种情况不可能无限次发生。

有了这个结论，我们考虑任意时刻下 $1, 2, f$ 的所有情况：

（注意到如果循环顺序改变，仅有可能是从左到右按照 high, low, high 或者 low, high, low 的顺序排列）

- 如果 $f$ 为开头元素，则 $f$ 为 high 类元素，$1, 2$ 均为 low 类元素，操作后循环顺序不变。
- 如果 $2$ 为开头元素，则 $2$ 为 high 类元素，$1, f$ 均为 low 类元素，操作后循环顺序不变。
- 如果 $1$ 为开头元素：
  - 如果 $f$ 为第二个元素，则 $1, f$ 均为 high 类元素，$2$ 为 low 类元素，操作后循环顺序不变。
  - 如果 $2$ 为第二个元素，则 $1, 2$ 均为 high 类元素，$f$ 为 low 类元素，操作后循环顺序不变。
  - 否则 $1$ 为 high 类元素，$2, f$ 均为 low 类元素，操作后循环顺序不变。
- 否则 $1, 2, f$ 均为 low 类元素，操作后循环顺序不变。

由此证明了在任意时刻下，一次操作均不会改变 $1, 2, f$ 的循环顺序。

于是证明了初始结论：如果在初始时元素 $1, 2, f$ 的循环顺序等于 $(f, 1, 2)$，则答案为 $T$ 否则为 $T + 1$。

这是从 $i = 2$ 推演到 $i = 1$ 的情况，对于一般的 $i$ 结论是类似的。

在实现时，对于一个 $i$，仅考虑值在 $[i, N]$ 中的元素，维护 $T_i$ 表示排好序的次数，以及 $f_i$ 表示 $T_i - 1$ 步后的第一个元素。

如果 $T_i = 0$ 则 $f_i$ 视作未定义。

要计算 $T_i$ 与 $f_i$ 时：

- 如果 $T_{i + 1} = 0$：
  - 如果元素 $i$ 所在的位置在元素 $i + 1$ 所在的位置的左边，则 $T_i = 0$，$f_i$ 未定义。
  - 否则 $T_i = 1$，$f_i = i + 1$。
- 否则 $T_{i + 1} \ge 1$：
  - 如果元素 $i$、元素 $i + 1$ 与元素 $f_{i + 1}$ 所在的位置的循环顺序是 $(f_{i + 1}, i, i + 1)$，则 $T_i = T_{i + 1}$，$f_i = f_{i + 1}$。
  - 否则 $T_i = T_{i + 1} + 1$，$f_i = i + 1$。

最后输出 $T_1$ 作为答案即可。

```cpp
#include <cstdio>

const int MN = 200005;

int N, p[MN], q[MN];
int t[MN], f[MN];

int main() {
	scanf("%d", &N);
	for (int i = 1; i <= N; ++i) scanf("%d", &p[i]), q[p[i]] = i;
	t[N] = 0;
	for (int i = N - 1; i >= 1; --i) {
		if (t[i + 1] == 0) {
			if (q[i] > q[i + 1]) t[i] = 1, f[i] = i + 1;
			else t[i] = 0;
		} else {
			if ( /* 1. */ (q[i] < q[i + 1] && q[i + 1] < q[f[i + 1]]) ||
			/*      2. */ (q[i + 1] < q[f[i + 1]] && q[f[i + 1]] < q[i]) ||
			/*      3. */ (q[f[i + 1]] < q[i] && q[i] < q[i + 1]))
				t[i] = t[i + 1], f[i] = f[i + 1];
			else t[i] = t[i + 1] + 1, f[i] = i + 1;
		}
	}
	printf("%d\n", t[1]);
	return 0;
}
```