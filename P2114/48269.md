【题目描述】

21世纪，许多人得了一种奇怪的病：起床困难综合症，其临床表现为：起床难，起床后精神不佳。作为一名青春阳光好少年，atm一直坚持与起床困难综合症作斗争。通过研究相关文献，他找到了该病的发病原因： 在深邃的太平洋海底中，出现了一条名为drd的巨龙，它掌握着睡眠之精髓，能随意延长大家的睡眠时间。 正是由于drd的活动，起床困难综合症愈演愈烈， 以惊人的速度在世界上传播。为了彻底消灭这种病，atm决定前往海底，消灭这条恶龙。历经千辛万苦，atm终于来到了drd所在的地方，准备与其展开艰苦卓绝的战斗。drd有着十分特殊的技能，他的防御战线能够使用一定的运算来改变他受到的伤害。具体说来，drd的防御战线由$n$扇防御门组成。每扇防御门包括一个运算$op$和一个参数$t$，其中运算一定是$OR,XOR,AND$中的一种，参数则一定为非负整数。如果还未通过防御门时攻击力为$x$，则其通过这扇防御门后攻击力将变为$x$ $op$ $t$。最终drd受到的伤害为对方初始攻击力$x$依次经过所有$n$扇防御门后转变得到的攻击力。

由于atm水平有限，他的初始攻击力只能为$0$到$m$之间的一个整数（即他的初始攻击力只能在$0,1,......,m$中任选，但在通过防御门之后的攻击力不受$m$的限制）。为了节省体力，他希望通过选择合适的初始攻击力使得他的攻击能让drd受到最大的伤害，请你帮他计算一下，他的一次攻击最多能使drd受到多少伤害。

【输入输出格式】

- 输入格式
输入文件的第$1$行包含$2$个整数，依次为$n,m$，表示drd有$n$扇防御门，atm的初始攻击力为$0$到$m$之间的整数。

接下来$n$行，依次表示每一扇防御门。每行包括一个字符串$op$和一个非负整数$t$，两者由一个空格隔开，且$op$在前，$t$在后，$op$表示该防御门所对应的操作，$t$表示对应的参数。
- 输出格式
输出一行一个整数，表示atm的一次攻击最多使drd受到多少伤害。

【样例输入输出】
- 样例输入
```
3 10
AND 5
OR 6
XOR 7
```
- 样例输出
```
1
```

$30$分思路：

我们可以考虑直接暴力枚举atm的攻击力，即枚举$0,1,......,m$，再通过位运算来判断该攻击力可以给drd造成多少点的攻击。在这里我们设$ans$为一次攻击能使drd受到的伤害的最大值。那么每次枚举完每个攻击力后就可以取$max()$了，最后输出$ans$即可。这种方法的时间复杂度为$O(nm)$，显然会超时。

$100$分（满分）思路：

我们可以考虑将攻击力转换为二进制。
> 用二进制计算，从最高位开始贪心该位是否可以为1（我们希望每一位上都是1，这样结果最大），因为最高位大数的一定大，所以这种方法是正确的。

上文的引用部分摘自[@licone的博客](https://www.luogu.org/blog/user16334/)，
这种方法的时间复杂度为$O(n\;log_2\;m)$~

$30$分代码：
```cpp
#include <cstdio>
struct node{ int op,t; } f[1000001];
int max(int x,int y)
{
    return x>y?x:y;
}
int main()
{
    int n=0,m=0;
    scanf("%d %d",&n,&m);
    for(int i=1;i<=n;i++)
    {
        char st[10001];
        scanf("%s %d",st+1,&f[i].t);
        if(st[1]=='A')
        {
            f[i].op=1;
        }
        else if(st[1]=='O')
        {
            f[i].op=2;
        }
        else if(st[1]=='X')
        {
            f[i].op=3;
        }
    }
    int ans=0;
    for(int i=0;i<=m;i++)
    {
        int da=i;
        for(int j=1;j<=n;j++)
        {
            if(f[j].op==1)
            {
                da=da&f[j].t;
            }
            else if(f[j].op==2)
            {
                da=da|f[j].t;
            }
            else if(f[j].op==3)
            {
                da=da^f[j].t;
            }
        }
        ans=max(ans,da);
    }
    printf("%d",ans);
    return 0;
}
```
$100$分代码：
```cpp
#include <cstdio>
struct node{ int op,t; } f[1000001];
int n=0,m=0;
int max(int x,int y)
{
    return x>y?x:y;
}
int sc(int da)
{
    for(int j=1;j<=n;j++)
    {
        if(f[j].op==1)
        {
            da=da&f[j].t;
        }
        else if(f[j].op==2)
        {
            da=da|f[j].t;
        }
        else if(f[j].op==3)
        {
            da=da^f[j].t;
        }
    }
    return da;
}
int main()
{
    scanf("%d %d",&n,&m);
    for(int i=1;i<=n;i++)
    {
        char st[10001];
        scanf("%s %d",st+1,&f[i].t);
        if(st[1]=='A')
        {
            f[i].op=1;
        }
        else if(st[1]=='O')
        {
            f[i].op=2;
        }
        else if(st[1]=='X')
        {
            f[i].op=3;
        }
    }
    int ans=0;
    for(int i=32;i>=0;i--)
    {
        if(ans+(1<<i)>m)
        {
            continue;
        }
        if(sc(ans)<sc(ans+(1<<i)))
        {
            ans+=(1<<i);
        }
    }
    printf("%d",sc(ans));
    return 0;
}
```