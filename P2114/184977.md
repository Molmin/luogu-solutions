在家里闲来无事做了一道题

作为NOI2014的签到题好像还是很好做的伐

切入题目

---

### 题目描述

21世纪，许多人得了一种奇怪的病：起床困难综合症，其临床表现为：起床难，起床后精神不佳。作为一名青春阳光好少年，atm一直坚持与起床困难综合症作斗争。通过研究相关文献，他找到了该病的发病原因： 在深邃的太平洋海底中，出现了一条名为drd的巨龙，它掌握着睡眠之精髓，能随意延长大家的睡眠时间。 正是由于drd的活动，起床困难综合症愈演愈烈， 以惊人的速度在世界上传播。为了彻底消灭这种病，atm决定前往海底，消灭这条恶龙。历经千辛万苦，atm终于来到了drd所在的地方，准备与其展开艰苦卓绝的战斗。drd有着十分特殊的技能，他的防御战线能够使用一定的运算来改变他受到的伤害。具体说来，drd的防御战线由n扇防御门组成。每扇防御门包括一个运算op和一个参数t，其中运算一定是OR,XOR,AND中的一种，参数则一定为非负整数。如果还未通过防御门时攻击力为x，则其通过这扇防御门后攻击力将变为x op t。最终drd受到的伤害为对方初始攻击力x依次经过所有n扇防御门后转变得到的攻击力。

由于atm水平有限，他的初始攻击力只能为0到m之间的一个整数（即他的初始攻击力只能在 0, 1, … , m中任选，但在通过防御门之后的攻击力不受m的限制）。为了节省体力，他希望通过选择合适的初始攻击力使得他的攻击能让drd受到最大的伤害，请你帮他计算一下，他的一次攻击最多能使drd受到多少伤害。

### 输入格式

输入文件的第 1 行包含 2 个整数，依次为n, m，表示 drd 有n扇防御门，atm 的初始攻击力为0到m之间的整数。

接下来n行，依次表示每一扇防御门。每行包括一个字符串op和一个非负整数t，两者由一个空格隔开，且op在前，t在后，op表示该防御门所对应的操作，t表示对应的参数。

### 输出格式

输出一行一个整数，表示atm的一次攻击最多使drd受到多少伤害。

### 输入输出样例

#### 输入 #1

```
3 10
AND 5
OR 6
XOR 7
```

#### 输出 #1

```
1
```

我们首先面向数据编程，发现有30分的暴力分，有一个门是$AND$ $0$，操作相同，我们就得到60分了

我们这个时候就要想一下正解了

位运算有一个特别的性质，也就是二进制上面的每一位都不互相干扰

而我们想让我们的攻击力最大化，所以我们尽量让二进制高位上面的值为1，这样可以使值最大

准确的说：

> 我们想让这个值最大，我们想让这个数的每一位都是1，越高位上面的1值越大。所以我们尽量让高位上的值为1

举个例子：

有两个二进制数：10000,01111

你觉得哪个比较大？当然是第一个啦

这个位数可以是1，我们就让他是1，因为后面的全是1都赶不上他

也就是说我们的贪心策略出来了：

> 从高位往低位枚举，如果可以让这一位成为1，就让他成为1

于是乎，我们定义两个变量：一个为`0`，一个为`~0`=`compl 0`=`-1`，将这两个数按顺序经过所有的门

初始的攻击力只能被0,1组成，我们第一个变量也就是每一位初始选0经过所有门的伤害，第二个变量同理

我们可以根据这个去组织我们的答案

如果0能变1 就变了

否则

1变0 不管

否则如果这个值是小于等于m的 就变了

然后就完了

```cpp
#include<cstdio>
int main(){
	int n,m,x=0,y=(compl 0),s,tot=0;//定义变量，在二进制下一个全是1，一个全是0
	char a[5];
	scanf("%d %d",&n,&m);
	while(n--)
	{
		scanf("%s %d",a,&s);
		if(a[0]=='A')	x and_eq s,y and_eq s;
		else if(a[0]=='X')	x xor_eq s,y xor_eq s;
		else	x or_eq s,y or_eq s;
	}//经过防御门
	for(int i=30;compl i;--i)
	{
		if((x>>i) bitand 1)	tot+=1<<i;
		else if(y>>i&1 and (1<<i)<=m)	tot+=(1<<i),m-=(1<<i);
	}//贪心
	printf("%d",tot);//输出最大攻击
	return 0;
}
```

注意：我们是不需要知道我们要的初始攻击的
