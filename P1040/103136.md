做这道题之前首先要了解二叉树的几个遍历：

前序遍历：先访问根再访问左子树再访问右子树，简称：根左右（性质：遍历出的序列的第一个节点是整个tree的根）

中序遍历：左根右（性质：遍历出的序列的中间某个节点是整个树的根）

后序遍历：左右根（性质：遍历出来的序列的末尾一定是整个tree的根）

那么对于中序遍历，如果给出你一个中序遍历的序列，123456A89 （其中A表示整个tree的根）， 那么 123456就是左子树 而89就是右子树了。

如果现在再给出一个中序遍历的序列123*56(*表示整个树的根) ，那么左子树就是123而右子树就是89.

如果现在给出一个中序遍历的序列，并且给出你所有子树根节点 ,123456789(8是整个树的根，4是子树[1,6]的根(用区间表示子树)，2是树[1,6]的子树[1,3]的根，而5是树[1,6]的子树[5,6]的根)，，，画出来的树应该是这样的。
![](http://thyrsi.com/t6/666/1548934557x2728278692.jpg)


那么这道题给出一串中序遍历，要你求subtree的左子树的加分× subtreesubtree的右子树的加分＋subtreesubtree的根的分数，的最大值；
用样例来说，其实就是让你在整个序列中选定一个根节点，求出此节点左子树的最大分数，与右子树的最大分数。说白了就是让你枚举子树的根。
既然知道了是枚举子树的根，那做法很显然了，法1：记忆化深搜，法二：区间DP
（说实话，两个方法大同小异，这里只讲法一）

法一：
用数组f[i][j]记录序列中区间[i,j] 中最大的分数（前面说了用区间表示子树）。
做法是枚举每一个区间[i,j]的根，根的在序号用k表示，
先求出[i,k-1] 与[k+1,j]的最大分数，再去求[i,j]的最大分数
最大分数的那个根k用一个数组root[i][j],记录下那一个根节点（因为题目说要输出前序遍历啊）

```cpp
#include <bits/stdc++.h>//万能头文件 
#define ll long long 
//中序遍历具有的性质：在序列中必有且只有一个节点是根，使得此节点左边的序列是左子树的中序遍历，右边序列是右子树的中序遍历
using namespace std;
int n;
int score[32];//没记错的话score这个单词意思应该是分数，用它来表示每个节点的分数 
ll f[32][32];//用于保存一个区间内最大分数 
int root[32][32];//保存根，题目要求输出 
ll ans=0;
ll dfs(int l,int r){
	if(f[l][r]!=-1)return f[l][r];
	if(l>r||r<l){
		return 1; 
	}//注意好递归边界！！！ dfs到l>r或r<l,意味着子树为空，题目要求返回1 
	ll sum=0;
	for(int i=l;i<=r;i++){
		if(dfs(l,i-1)*dfs(i+1,r)+score[i]>sum){
			sum=dfs(l,i-1)*dfs(i+1,r)+score[i];//要求[l,r]最大分数，先求[l,i-1],与[i+1,r]的最大分数 
			root[l][r]=i;//记录根节点 
		}
	}
	f[l][r]=sum;
	return f[l][r];
}
void print(int l,int r){
	if(l>r||r<l)return ;//注意，空子树不需要输出，空格都不用 
	if(l==r){
		cout<<l<<" ";
		return ;
	}
	cout<<root[l][r]<<" ";
	print(l,root[l][r]-1);
	print(root[l][r]+1,r);
}//递归输出前序遍历 
int main(){
	memset(f,-1,sizeof(f));//初始化为-1，因为n可能为0 
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>score[i];
		f[i][i]=score[i];//区间[i,i]表示i是叶子节点，题目要求保留原来的分数 
	}
	cout<<dfs(1,n)<<endl;
	print(1,n);
	
}
```



