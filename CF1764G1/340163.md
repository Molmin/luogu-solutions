因为自己思考的时候没有独立做出 G3，所以只写 G2 的题解。

事实上这场 E 浪费太多时间去考虑 corner case 了，能早点看到这题就可以上分了。

---

简单观察范围，G1 的范围是 $3\log n$ 次，G2 的范围是 $2\log n+1$ 次询问。

为什么非要我们找 $1$ 不可呢？事实上向下取整是一个很好的提示。一个直观的想法是每次查询，$k=2$。这个想法的来源在哪儿呢？首先 $k=1$ 的查询显然是浪费，同时发现 $k \geq 2$ 的时候 $\lfloor \frac{1}{k} \rfloor = 0$。如果 $\lfloor \frac{c}{k} \rfloor = 0$ 的 $c$ 可以唯一确定就很不错了，此时 $k=2$（不考虑采取 $k$ 更大的分治结构是因为如果为 $\lfloor \frac{c}{k} \rfloor = 0$ 太多，区分他们的成本太大，并且我们仍然需要 $k$ 更小的询问）。

此时可以按 $\lfloor \frac{c}{2} \rfloor$ 分类。容易发现一类的大小要么是 $2$ 要么是 $1$，并且类与类的区别只有大小的区别，我们只需要找到大小为 $1$ 的那类的位置。这里有一个对 G1 来说无关紧要的问题是，大小为 $1$ 的可能有两类（$0$ 和 $\frac{n}{2}$，此时 $n$ 为偶数）。对于 G1 来说可以先令 $k=n$，通过二分找到 $n$ 的位置并排除。

对于 G1 还剩下 $2 \log n$ 次询问。这是显然的一个二分的结构，每层二分查询两次。假设我们确定 $1$ 在区间 $[l,r]$ 内，对于中点 $p$，将序列分成大小为 $p$ 和 $n-p$ 的两段。在去除 $n$ 之后查询左右两边还没有配对的数的数量（当然这并不是查询的实际意义，当然算是比较简单的，令 $c$ 的值为 `query(l,r,2)` 的结果，则没配对的数的数量为 $2c-r+l-1$）。因为 $1$ 必然无法配对，所以没有配对的数更多的一半存在 $1$。这部分的查询次数为 $2 \log n$。

因为没有 $3 \log n$ 次询问的代码，可以先自己思考得到 G2 的方法，或者移步 [G2 的题解](https://www.luogu.com.cn/blog/340163/solution-cf1764g2)。