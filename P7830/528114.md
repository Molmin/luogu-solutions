## 写在前面

本着学习主席树的目的找到了这道题，本来以为黑题标着主席树的 tag 蕴含了主席树的什么高深套路，结果没想到这道题难在了思维和代码上。写一篇题解加深理解，同时补一个主席树的代码，这样题解区就有离线和在线两种做法了。

思路和代码一部分参考了他人题解。

## 分析

其实一看到这题，有一种思路是考虑倍增。我们尝试用倍增预处理出每个点走特定步数能到达的位置，然后处理询问。不过经过思考发现这些点来回来去的并不具备连边和转移的好性质，所以这个思路我们先放弃。

但是通过刚才的思路给了我们一个启发：**操作可能有周期性**。那我们就来尝试构造这个周期。

对于一个非根节点，它的激光可以指向它的父亲和儿子。根据经验，比较特殊的一定**跟父亲有关**，因为儿子没有普适性，有可能很多，也可能没有，但是父亲只有一个。

与父亲有关，那么我们可以让这个节点的激光指示器**一开始就指向自己的父亲**。然后我们发现了很好的性质：

-	这个节点从祖先到第一次访问该节点，激光指示器会顺时针转到第一个儿子，然后遍历这个儿子（**不管这个子树内每个节点的激光指示器状态如何，最终都会从子树中退出**，*因为无论激光指示器转多少都会有一次指向父亲，就会回退* ），之后回到该节点，再遍历第二个儿子，以此类推，顺时针转一圈，**将所有儿子遍历一遍后**激光指示器将再次指向父亲，回退。

这样的话，如果每个非根节点都指向它的父亲（这是我们**钦定的条件**，根节点不用管），那么我们从根出发可以完整遍历一整棵树。

分析发现，每条边只会下行上行各一次，所以最后我们的访问序列长度是 $2n-2$，又由于激光指示器顺时针旋转的性质，每次遍历的顺序是一定的，所以我们得到了一个**周期序列**。

------------

一个优秀的序列被构造完了，然而一开始每个节点激光指示器的状态可不保证指向父亲。接下来我们思考是不是任意状态的树最终都会指向我们这个最终循环序列。

在上一回合我们知道了一个非根节点的激光指示器最终一定有一次会指向它的父亲，从而回退。进而我们假设这个节点的祖先节点已经满足了 第一次访问都指向其父亲 的条件，那么这个节点再指向其父亲后回退，也就是说**下一次遍历它也成为了符合条件的一部分**。

进而我们可以找到一种扩展方式：**每次把新的符合条件的节点作为下一次扩展的起点**。这样我们就保证了每次一层层扩展，不会有遗漏，最后使整棵树符合我们刚才构造的样子，进入周期循环。

而且又因为题目中顺时针旋转这个性质，每次扩展后的访问序列**一定是最终周期序列的子序列**。因为每个儿子的相对遍历顺序不会改变。

来看看复杂度是否可以接受。每次扩展必然有至少一个节点通过旋转满足了条件，因而最终总的扩展次数不会超过 $n$ 次，也就是说我们的访问序列不会有多于 $n$ 个子版本就会到达最终版本，进入循环。

同样的，经由思考我们会发现，每个节点的一般遍历方式其实类似下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/25uro43i.png)

遍历一次变成符合要求，下次再把剩下的未遍历的儿子遍历完，我们可以通过一些方法使这个节点的每个儿子只遍历一次，进而保证了遍历的时间复杂度是 $O(n)$ 级别。同时我们对访问序列的修改次数也因此控制在了 $O(n)$ 级别。

## 实现

思路大抵明确了，接下来我们看看实现有哪些困难。

因为一开始每次的询问序列都是最终周期序列的子序列，所以我们可以一开始先把这个周期序列求出来。方法很简单，按照顺时针顺序存图（为了方便我们使用 ```vector```，毕竟时限 8s 完全不虚），先找到指向父亲节点的位置，然后假定现在一开始就指向父节点，那么从父节点其向右循环遍历直到再次遍历到父节点即可。注意对于一个节点每次遍历一个儿子都会再访问一次该节点，访问序列要加入一个该节点。


------------


接下来是难点。如何把奇形怪状的树扩展成最终形态？我们通过样例来浅析一下。

![](https://cdn.luogu.com.cn/upload/image_hosting/120gklhm.png)

上图是描绘了树，以及我们的序列，括号表示起点，不在序列中。

比如，第一次扩展，$2$ 号点在到达后就指向其父亲，回退，但是可以作为下一次扩展的点。**注意此时对序列的更改是在最后增加了一个** $2$。这里可以这么理解：$2$ 有儿子没遍历，但保证**已经遍历过的儿子是原遍历顺序的后缀**，所以为了还原序列，逆时针反着来所以**倒序还原 $2$ 的位置**。对于 $4$ 同理，大家可以自行模拟。

为了实现这个功能，我们可以在一开始处理最终序列时就记下每个点在最终访问序列中的位置，然后在扩展时倒序还原即可。



------------


然后对于每次扩展，只会在原先序列上再还原一部分，仍然有一部分不变，这就让我们想到了每次扩展只记录与原先版本不同之处，进而想到了对这个序列**进行可持久化**。那么我们可以通过维护一个该序列长度的主席树，每次更改就改一点就行，又因为我们通过方法保证了不会重复遍历任何节点，所以扩展的时空复杂度都是 $O(n\log n)$。

------------

对于最后的询问，首先明确每次扩展还是从根节点开始的，所以虽然每次扩展相对于前一次访问序列的变化不多，但是询问时整个访问序列都要走一遍。所以我们可以把所有可能的访问序列长度记下来并前缀和处理，用的时候二分找到这个序列在主席树上查询即可，这样就是经典第 $k$ 大问题。如果说 $k$ 很大，以至于已经扩展到了最终的周期序列，那么我们就可以通过取模运算做到 $O(1)$ 查询了。

然后就没啥要嘱咐的了，具体实现看代码，注意每个变量的含义，有一些实现我会写在注释里。

## 代码

人傻常数大，也可能是因为主席树空间占的大所以跑得慢，不过理论复杂度真的是 $O(n\log n)$……

```cpp
#include <iostream>
#include <algorithm>
#include <cstring>
#include <vector>
#include <queue>

#define mid ((l + r) >> 1)

using namespace std;
typedef long long ll;
const int maxn = 800005;

struct Node{
    int ls, rs;
    int cnt;//记录[l,r]区间里已经还原了多少元素
}tr[(maxn * 2) * (4 + 20)];//主席树，注意最终序列的长度是 2n-2，所以相应的也要扩倍
int root[maxn << 1], idx;
/* 存图数组；记录每个点在序列中的所有位置（倒序还原）；下一次需要扩展的点 */
vector<int> to[maxn], pos[maxn], ne;
int n, Q, m;//m记录的是扩展了多少版本
int seq[maxn << 1], len;//最终序列
int fa[maxn], ind[maxn];//记录父亲；记录终止位置（应该停在哪）
int now[maxn], tot;//记录现在遍历到哪个位置；
ll sum[maxn];//每个版本有多少步的前缀和
queue<int> q;

/* 可持久化线段树 */
int build(int l, int r){
    int p = ++ idx;
    if (l == r){
        return p;
    }
    tr[p].ls = build(l, mid), tr[p].rs = build(mid + 1, r);
    return p;
}

int insert(int p, int l, int r, int x){//还原x位置
    int q = ++ idx;
    tr[q] = tr[p];
    if (l == r){
        tr[q].cnt = 1;
        return q;
    }
    if (x <= mid) tr[q].ls = insert(tr[p].ls, l, mid, x);
    else tr[q].rs = insert(tr[p].rs, mid + 1, r, x);
    tr[q].cnt = tr[tr[q].ls].cnt + tr[tr[q].rs].cnt;
    return q;
}

int query(int p, int l, int r, int k){//Kth problem
    if (l == r){
        return l;
    }
    int cnt = tr[tr[p].ls].cnt;
    if (cnt >= k) return query(tr[p].ls, l, mid, k);
    else return query(tr[p].rs, mid + 1, r, k - cnt);
}

/* 扩展整棵树 */
void init(int u, int _fa){//先找到每个节点的父亲
    fa[u] = _fa;
    for (int i = 0; i < to[u].size(); i ++){
        int v = to[u][i];
        if (v == fa[u]){
            ind[u] = i;//记录最终的起始位置，也应该是旋转一圈的终点
            continue;
        }
        init(v, u);
    }
}

void get(int u){//得到最终序列
    /* u > 1 是因为第一次根作为起点不算在访问序列中 */
    if (u > 1) seq[++ len] = u, pos[u].push_back(len);
    int i = ind[u];
    while (true){
        i ++, i %= to[u].size();
        int v = to[u][i];
        if (i == ind[u] && u > 1) break;//非根节点，指向父亲一定要回退了
        get(v);
        seq[++ len] = u, pos[u].push_back(len);
        if (i == ind[u] && u == 1) break;//根节点，它没有父亲，所以说退出条件是再次指向起点
    }
}

void dfs(int u, int t){
    now[u] ++, now[u] %= to[u].size();//访问一次就要转一次
    if (u != t){//上一次在t停止，这一次从t扩展，所以这一次t不算在序列中
        root[m] = insert(root[m], 1, len, *pos[u].rbegin());
        pos[u].pop_back();
    }
    if (now[u] == ind[u] && u != t){//指向父节点，下一轮可完整扩展子树
        ne.push_back(u);
        return;
    }
    int i = now[u] - 1;
    int back_up = now[u];//备份
    while (true){
        i ++, i %= to[u].size(), now[u] = i;
        int v = to[u][i];
        if (i == ind[u] && u > 1) break;
        dfs(v, t);
        root[m] = insert(root[m], 1, len, *pos[u].rbegin());
        pos[u].pop_back();
        if (i == ind[u] && u == 1) break;
    }
    ind[u] = back_up;
    /* 注意ind[]的实际意义：
        即为一次遍历的终点（不包括该点）。ind[]本来记录的是父亲的位置，此处已经转一圈在父节点位置停止，
        那么下一次就是扩展这个点了，为了保证复杂度，即之后不会重复遍历以前的子树，由于是同一方向（顺时针），
        所以这一次的起点就是下一次的终点，ind[]改变为原来的起点，也就是我们刚才的备份 */
    if (!pos[u].empty()) ne.push_back(u);//还没完，下一轮还要从此扩展
    return;
}

int main(){
    ios::sync_with_stdio(false);
    cin.tie(0), cout.tie(0);

    cin >> n >> Q;
    for (int u = 1, k, v; u <= n; u ++){
        cin >> k;
        while (k --){
            cin >> v;
            to[u].push_back(v);
        }
    }

    init(1, 0), get(1);
    q.push(1), root[0] = build(1, len);
    while (!q.empty()){//类似于一个BFS里面套了DFS
        /* 继承上一个版本，然后这个扩展里的所有修改都对自身进行，因为查询时本次扩展是一个整体 */
        m ++, root[m] = root[m - 1];

        while (!q.empty()){
            int u = q.front();
            q.pop();
            dfs(u, u);
        }
        for (vector<int>::iterator it = ne.begin(); it != ne.end(); it ++){
            q.push(*it);//把下一轮可扩展的点入队
        }
        ne.clear();
        sum[m] = sum[m - 1] + tr[root[m]].cnt;
        if (tr[root[m]].cnt == len) break;
    }

    ll k;
    while (Q --){
        cin >> k;
        int t = lower_bound(sum + 1, sum + m + 1, k) - sum;//找到查询位置
        k -= sum[t - 1];//减去前面的贡献
        if (t < m){
            cout << seq[query(root[t], 1, len, k)] << endl;
        }
        else{//进入最终的循环
            k %= len;
            if (k == 0) k = len;
            cout << seq[k] << endl;
        }
    }

    return 0;
}
```

## 总结

构造循环，尝试导向循环，以及注意应用顺时针旋转的性质。是道很好的思维题。不过写完题解发现也不是那么难理解，我也是能弄懂黑题的人了hhhhh