楼上的题解似乎没有用位运算的，我来写一个^\_^

- 思路


和楼上的题解相似，设白子只能像前（右）走，黑子只能向后（左）走，则状态数一定是有限的，也就不会发生无限递归这种情况。


因为白子和黑子可以分别用1和0表示，所以我们可以用一个二进制数表示dfs的状态。此外，棋盘中的空位也用0表示，并在dfs中记录一个p表示空格的位置。然后就可以愉快地搜索了^\_^

- 初始化


我们第一个状态是前n位都是白子（1），第n+1位是空位，n+2位到2n+1位都是黑子（0）。


比如当n=3时，第一个状态是111**0**000（加粗部分是空位）


这个状态可以用位运算的式子`(1<<(n<<1|1))-1^(1<<n+1)-1`表示（这里的n<<1|1可以代替2\*n+1，位运算的优先级请自行百度）。

- 搜索


搜索的边界是当前状态等于目标状态。目标状态就是`(1<<n)-1`，别忘了还需要判断空位位置`p==n+1`。


因为我们知道空位的位置，所以我们可以只枚举空格前后各两个位置了。


minn记录最少步数，d数组记录当前方案，ans数组记录答案方案


- 代码


0ms AC，自认为代码还是比较短的，细节请参见注释



```cpp
#include <cstdio>
#include <cstring>
const int MAXN=200; // 当n<=12时，答案最多168步
int n, minn=MAXN;
int d[MAXN], ans[MAXN];
void dfs(int x, int p, int step) // x记录当前状态，p记录空位位置，step记录当前步数
{
    if (step>=minn) return ; // 剪枝
    if (x==(1<<n)-1&&p==n+1) // 边界条件
    {
        minn=step; // 更新答案
        memcpy(ans, d, sizeof ans);
        return ;
    }
    for (int i=p-2>1?p-2:1; i<=p+2&&i<=(n<<1|1); i++) // 枚举下一个状态，注意棋子的边界位置
        if (i<p&&x&1<<(n<<1|1)-i||i>p&&!(x&1<<(n<<1|1)-i)) // 白子只能往右，黑子只能往左
            // 通过位运算处理下一步状态，i是下一个状态的空位的位置
            d[step]=i, dfs((x|((x&1<<(n<<1|1)-i)>>p-i))&~(1<<(n<<1|1)-i), i, step+1);
}
int main()
{
    scanf("%d", &n);
    dfs((1<<(n<<1|1))-1^(1<<n+1)-1, n+1, 0); // 处理第一个状态并搜索
    for (int i=0; i<minn; i++) // 输出答案
    {
        printf("%d ", ans[i]);
        if (i%20==19) printf("\n"); // 记得20个数换一次行
    }
    return 0;
}
```