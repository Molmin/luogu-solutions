不少题解都用了找规律的方法，其实我觉得这才是正解，

毕竟搜索比较麻烦，有人的减枝还是根据不知怎么推出的答案来限制最大值，如果是考试可以，但平常做题还是不要这样（那还不如打表）

虽然有不少找规律的题解，但都仅限于找规律，并没有说明为什么，这里详细解释一下。

我相信大家的找规律能力

应该都能发现

我们把还未移动时的个空位也算上的话

$4$ $3$ $5$ $6$ $4$ $2$ $1$ $3$ $5$ $7$ $6$ $4$ $2$ $3$ $5$ $4$ $(n=3)$

$5$ $4$ $6$ $7$ $5$ $3$ $2$ $4$ $6$ $8$ $9$ $7$ $5$ $3$ $1$ $2$ $4$ $6$ $8$ $7$ $5$ $3$ $4$ $6$ $5$$(n=4)$

排一下

$4$ $ $ $ $ $35$ $ $ $ $ $642$ $ $ $ $ $1357$ $ $ $ $ $642$ $ $ $ $ $35$ $ $ $ $ $4$

$5$ $ $ $ $ $4 6$ $ $ $ $ $7 5 3$ $ $ $ $ $2 4 6 8$ $ $ $ $ $9 7 5 3 1$ $ $ $ $ $2 4 6 8$ $ $ $ $ $7 5 3$ $ $ $ $ $4 6$ $ $ $ $ $5$

规律挺明显

共$2n+1$个等差序列，长度从$1$到$n$再到$1$，而且后面与前面是对称的

我们讨论第$1$~$n+1$组序列，这些序列满足


- 第奇数个序列公差为$-2$，第偶数个序列公差为$2$

- 对于第$i$个序列$(1<=i<=n+1)$,若为第奇数个序列则首项为$n+i$，第偶数个序列则首项为$n-i+2$

那为什么会这样呢

我们研究一下下它的规则

注：下文皆用"移"表示移到相邻空格，"跳"表示跳过一个棋子,且开始左白右黑

每次都是白色棋子移过去，黑色棋子跳过来，然后黑色棋子移过来，白色棋子跳过去，白色棋子跳过去，白色棋子移过去，黑色棋子跳过来，黑色棋子跳过来，黑色棋子跳过来，

就是说每次先移动一步，然后对应颜色的棋子一直跳，直到不能跳为止，接下来换另一种颜色棋子移一步，再继续跳啊跳

（建议画图，会非常清楚）

黑棋只往左走，白棋只向右走，容易发现，这样一定是最优的，

这样前半部分就说完了

至于后半部分为什么是对称的呢

我们进行完前$n$组后，棋盘会变成：

空 白 黑 白 黑 ... 白 黑

第$n+1$组后，棋盘就变成了：

黑 白 黑 白 ...黑 白 空

这两者是对称的，我们之前从开始局面到$n$局面做的

反过来做一遍就可以从$n+1$局面到第$2n+1$局面

就是说，第$n+1$遍的作用是使序列翻转，然后我们就可以倒过来再做

这就是对称的原因

以上

希望对你有所帮助
```cpp
#include<iostream>
#include<cstdio>
#include<ctype.h>
using namespace std;
inline int read(){
    int x=0,f=0;char ch=getchar();
    while(!isdigit(ch))f|=ch=='-',ch=getchar();
    while(isdigit(ch))x=x*10+(ch^48),ch=getchar();
    return f?-x:x;
}
int f[17][17];
inline void check(int x){
	if(x%20==0)puts("");
}
int main(){
	int n=read(),cnt=0;
	for(int i=1;i<=n+1;++i){
		if(i&1)for(int j=0;j<i;++j)f[i][j]=n+i-j-j;
		else for(int j=0;j<i;++j)f[i][j]=n-i+j+j+2;
	}
	for(int i=2;i<=n+1;++i)for(int j=0;j<i;++j)printf("%d ",f[i][j]),check(++cnt);
	for(int i=n;i>=1;--i)for(int j=0;j<i;++j)printf("%d ",f[i][j]),check(++cnt);
	return 0;
}

```
