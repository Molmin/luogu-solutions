# 「CF878A Short Program」题解

以前做的 constructive 没写题解，看没有人就补一下吧。

## Part \#1 三行

首先考虑每一行代码都是位运算，对于每一位分开讨论。

不难发现，每一位的变化情况只有三种：

1. 无论这一位原来是 $0$ 还是 $1$，经过程序始终为 $0$；
2. 无论这一位原来是 $0$ 还是 $1$，经过程序始终为 $1$；
3. 无论这一位原来是 $0$ 还是 $1$，经过程序始终反转（$0$ 变 $1$，$1$ 变 $0$）；

所以，我们对于输出的的第 $i$ 个二进制位设置一个 $c_i$，$r_i$ 与 $s_i$，表示该位是否更改，是否翻转，设为 $0$（$s_i=0$） 还是设为 $1$（$s_i=1$）。当一个操作的参数第 $i$ 位为 $1$：

1. 若此操作为 &amp;，那么 $c_i\gets1$，$r_i\gets0$，$s_i\gets1$；
2. 若此操作为 |，那么 $c_i\gets1$，$r_i\gets0$，$s_i\gets0$；
3. 否则：
	- 若 $c_i=0$，则 $c_i\gets1$，$r_i\gets1$；
    - 若 $r_i=0$，则 $c_i\gets0$，$r_i\gets0$
    - 否则 $s_i\gets\lnot s_i$（即将 $s_i$ 的值 $0$ 变 $1$，$1$ 变 $0$）
    
这样子我们用 | 操作将二进制位设 $0$，&amp; 操作将二进制位设 $0$，^ 操作将二进制位反转，这样可以三行解决。

代码不难写，但是 tutorial 给了一个 bonus：两行解决问题。

## Part \#2 两行

**优化思路 1** 其实我们的设 $0$ 非常浪费，可以通过设 $1$ 后反转，那么我们直接将设 $1$ 合到 | 操作内，反转合到 ^ 操作，这样只需两行。注意顺序。

**优化思路 2** CF 评论区的大佬给出了一个强强的做法：

设 $S_0$ 为输入 $0$ 时的结果，$S_{1\ 023}$ 为输入 $1\ 023$ 时的结果，那么即可进行下面操作：&amp; $(S_0\oplus S_{1\ 023})$，^ $S_0$，其中 $\oplus$ 表示异或。

证明？同样是对于每一位考虑：

- 若这一位被设为 $1$，那么 $S_0$ 与 $S_{1\ 023}$（即当这一位为 $0$ 或 $1$ 时）在这一位都为 $1$，这样 `& 0` 使得它变为 $0$，再 `^ 1` 反转过来。同理对于设为 $0$ 的情况，只是通过 `^ 0` 不让其反转。
- 若这一位未被改动，那么通过 `& 1` 后不变，通过 `^ 0` 后依然不变。同样的，若这一位被反转，那么只需通过 `^ 1` 将其反转。
- 找规律发现就是上述结论。

所以本题代码非常短，相信所有人都写得出来，就不贴了。