# 前言

没有翻译感觉很恶心，这里提供一个翻译：输出斐波那契的第 $n$ 项。

# 思路

求斐波那契有两种方法：递推和递归。

注意到数据规模不大，只有 $80$，所以两种方法都可以通过，但是需要开 `long long`。

- 递推

斐波那契式子大家都知道吧，就是

$$f_0=f_1=1,f(i)=f(i-1)+f(i-2)$$

转换成编程语言，就是

$$f[0] = f[1] = 1,f[i] = f[i-1]+f[i-2]$$

按照式子模拟即可

```cpp
long long int i,n,f[101];
cin>>n;
f[0] = f[1] = 1;
for(i=2;i<=n;i++)//项数从 2 开始。 
	f[i] = f[i-1]+f[i-2];
cout<<f[n]<<endl;
    
```
- 递归

也分两种情况：不优化的递归和记忆化搜索。

普通的递归与递推的式子一样，即 `fib(n-1)+fib(n-2)` 但是每次调用消耗的是空间与时间，如果数据规模再大一些，就会 TLE，所以我们需要使用记忆化搜索。

记忆化搜索，顾名思义，就是选取记忆中的答案（这解释的多直白啊），我们需要一个 $f$ 数组，寄存斐波那契的第 $n$ 项，如果调用上面的递归式子在 $f$ 中有答案了，那么直接 `return f[n]`，否则 `return f[n] = fib(n-1)+fib(n-2)`。

解释的可能不大清晰，下面给大家放一下核心代码。

```cpp
long long int f[101];
long long int fib(int n)
{
	if(n<=1)
    		return 1;
	if(f[n])
		return f[n];
	return f[n] = fib(n-1)+fib(n-2);
}
```
注意到此题是多组数据，微改一下就可以完美通过。