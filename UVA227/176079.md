考虑到一个5*5的表格里面的坐标如下，我们填充的时候按照 行为x，竖为y

00 01 02 03 04

10 11 12 13 14

20 21 22 23 24

30 31 32 33 34

40 41 42 43 44

那么表格中的任何一个格子的上、下均可设置为在行上 加一或者减一， 而右左则可以设置为竖上加一或者减一
按这个思路，操作只有四个方向，上则x-1，y不动，左则y1-，x不动 
要在行上左右移动，那就 x 做加减
要在列上上下移动，那就 y 做加减 

具体实现就简单了

1、把5*5的方阵读取到数组中去，并且把空格的具体坐标找到

2、拆分操作字符，一个个去移动操作

3、打印出操作后的数组 或者 无法操作这个结果 

```c
#include<stdio.h>
#include<string.h>
#include <ctype.h>
#define maxn 5

//用户输入的谜题 
char a[maxn][maxn];

int main() {
    int t = 0;			//申明变量t 作为每一段的标题计数器 
    while(gets(a[0])) {//注意读的是第一行到数组第一行gets()函数的作用和scanf()差不多，但不同的是他能够把空格读出来，而不是跳过 

        if(a[0][0] ==0) {	//如果出现在循环开始时候读取第一格得不到东西，那么就继续读取值来填充第一行
			gets(a[0]);
		}
		
		if(a[0][0] == 'Z') 
			break;//判断读取到的这一行的第一个字母是Z，就完全终止本轮循环 
		
		
        int m = 0, n = 0;	//用两个时变量，在循环中找到空格就存坐标，存下来，等后面输入方向的时候才有个依据撒 
        
        //这里只读4行，再读就读到操作命令哪一行了，而且必须从第二行开始读，第一行被他的循环爸爸读过了 
		for(int i = 0; i <= 4; ++i) {
        	//如果i=0，就不读，因为外层循环已经读过了 
        	//因为，样例输入是输入多段 
            if(i)
				gets(a[i]);
				
            // 每读一行就循环当前行的列，去找下是否有空格，有的话就把空格的坐标存下来 
            for(int j = 0; j <= 4; ++j) {
                if(a[i][j] == ' '||a[i][j] == 0) {	//如果为空 或者 为0，就表示抓到了 
                    a[i][j] = ' ';					//将这一格设置为 空 
                    m = i; n = j;					//将空的位置记下来
                    break; 				//反正里面只会有一个空格，只要找到了就没有必要继续循环这一行了，就跳出去，能节约一步算一步啊 
                }
            }
        }
        

        //读取操作命令字符串，实施移动，两种情况表示操作无效    操作符无效 和 把表格插破了  
        //这里是利用getchar()一个个字符的读取，读一个操作一次 
        bool ok = true;			//设置一个标识符，如果移动的时候找不到路了，就标识为非，给后面的人说这是个错 
        for (;;) {				//花样死循环（要不是我是做教程，我自己都忘记了还有这么多作死的方法，哇哈哈哈哈哈） 
            char c = getchar();	//getchar()对屏幕上的字符依次读取，别问我他读是什么，反正就是依次，该函数以无符号 char 强制转换为 int 的形式返回读取的字符，如果到达文件末尾或发生读错误，则返回 EOF。 
            
            if(isspace(c)){		//isspace(c)：检查参数c是否为空白字符，是为真，否为假 
            	ok = false;
			}				
				
			if (c == '0') {		//如果遇到0，表示结束了，不用继续了 				
                break;			//跳出循环 
            }
            
            int x=m,y=n;			//m和n要记录原来的，不能拿来运算，所以搞两个新变量来计算，并作为新位置的记录
            //根据命令计算空格要移动的目标格子的坐标 
            if(c=='A'){			//向上-1 
            	x-=1;
			} 
			else if(c=='B'){	//向下+1 
            	x+=1;
			}
			else if(c=='L'){	//向左-1 
            	y-=1;
			} 
			else if(c=='R'){	//向右+1 
            	y+=1;
			} 
            
            //看看坐标还对不对，别都跑到火星上去了(超出数组界限了) 
            if (x < 0 || x > 4 || y < 0 || y > 4) {	//如果超过表格的限制       
                ok = false;	//设置标志为 非 
                
                //特别注意一下，这个破地方，本循环是一次只读一个字符，这里直接就跳出去的话，屏幕上的字还没读完，所以必须把剩下的读完
				while(c!='\n'){
					c=getchar();
				}
                
                break;		//结束循环，只要有一个不对，后面的都没必要继续了 
            }
            
            a[m][n] = a[x][y];	//将移动位置上的字母给空的位置
            a[x][y] = ' ';		//将新位置为空
            m = x, n = y;		//重新记新的位置
        }

        //输出
        if (t) {		//如果不是第一段，就给一个换行 
            puts("");		//作用与printf("\n")相同,这个主要用于输出字符串并换行，但不如printf还能格式化 
        }
        
        printf("Puzzle #%d:\n", ++t);
        if (ok) {
            for(int i = 0; i <= 4; ++i) {		//循环输出行 
                for(int j = 0; j <= 4; ++j) {	//循环输出列 
                    if (j) {					//一个字符前面不要空，后面都是每个字符一个空格 
                        printf(" ");			//输空格用的，最后字母后没空格
                    }
                    printf("%c", a[i][j]);
                }
                puts("");						//换行 ,当前这个等同于 printf("/n") 
            }
        }
        else {
            puts("This puzzle has no final configuration.");
        }
    }
    return 0;
}
```
