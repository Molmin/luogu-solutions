### 简要题意
这是一道交互题。  
有一张 $ n $ 个点的图，告诉你每个点的度数 $ d_i $，但是不告诉你有哪些边。  
你需要把这些点染色，要求对于每一种颜色，染成这种颜色的点是连通的，且需要满足 $ s_c \le n_c^2 $，其中 $ s_c $ 是这些点的度数之和，$ n_c $ 是这些点的个数。  
你可以进行不超过 $n$ 次询问，每次询问 "? u"，当第 $k$ 次询问 $ u $，交互库会告诉你第 $k$ 个与 $u$ 相邻的点。  
请你给出一种染色方案。

### 题解
发现对于每一种颜色的限制 $ s_c \le n_c^2 $ 很奇怪，但是不难想到，如果每一种颜色的点数都大于其所有点的度数最大值，则这个颜色是满足条件的。

从这个角度思考，假设先构造出一个满足条件的颜色，可以考虑找出度数最大的点 $x$，然后使用 $d_x$ 次询问，找出所有与 $x$ 相邻的点，然后将这些点和 $x$ 染成一样的颜色。这些点显然是连通的，并且点数超过了最大度数。

继续从这个角度思考，把所有点按度数排序，如果一个点已经被染色了，那么他就已经满足了条件，跳过它。  
对于一个没有被染色的点 $x$，暴力询问所有与它相邻的点。  
1. 如果询问到一个没有染过色的点 $y$，就把它染成和 $x$ 一样的颜色。  
2. 如果询问到一个已经被染过色的点 $y$，$y$ 当前所在颜色的点数一定不小于 $d_x$ 于是可以将 $x$ 染成和 $y$ 一样的颜色，然后 $x$ 直接满足了条件，于是结束对 $x$ 的询问。

不难发现这样所有颜色一定满足条件。  
分析一下询问次数：对于 1 类询问，每个点 $y$ 至多被询问一次；对于第 2 类询问，每个点 $x$ 至多询问出一次 2 类询问，并且 $x$ 一定是没有被 1 类询问问到的点。  
所以两种询问加起来次数一定不超过 $n$。

染色可以使用并查集来维护。

```c++
#include<bits/stdc++.h>
using namespace std;
const int N=1005;
int n,d[N];
int mark[N];
int fa[N];
int gf(int x){return x==fa[x]?x:fa[x]=gf(fa[x]);}
bool solve(){
	int id=0;
	for(int i=1;i<=n;i++)
		if(!mark[i]&&d[i]>d[id])id=i;	
	if(!id)return 0;
	mark[id]=1;
	for(int i=1;i<=d[id];i++){
		cout<<"? "<<id<<endl;
		int x;cin>>x;
		fa[gf(x)]=gf(id);
		if(mark[x])break;
		mark[x]=1;	
	}
	return 1;
}
void mymain(){
	cin>>n;
	for(int i=1;i<=n;i++)cin>>d[i],fa[i]=i,mark[i]=0;
	while(solve());
	cout<<"! ";
	for(int i=1;i<=n;i++)cout<<gf(i)<<' ';
	cout<<endl;	
}
int main(){
	int t;cin>>t;
	while(t--)mymain();
	return 0;
}
```