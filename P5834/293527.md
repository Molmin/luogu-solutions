## 以下是python AC代码，超简洁，3行搞定：
```python
a=int(input())
b=(1,2,4,7,8,11,13,14)#由于py中下标[-1]代表从后往前第一个数故可以这样写，c++不行	
print(((a-1)//8)*15+b[a%8-1])
```
## C++AC代码：
```c
#include <iostream> 
using namespace std;
int a,b[9]={14,1,2,4,7,8,11,13,14},c;
int main()
{
    cin>>a;
    c=((a-1)/8)*15+b[a%8];
    cout<<c<<endl;
    return 0;
}
```

   
  
总的来说，比较简单，数是每8个为一循环，即可写出代码

# 具体思路如下

列出序号与报的数之间的关系（第一行序号，第二行报的数）

    1 2 3 4 5 6 7 8 9 10 11 12 13 14 15
    1 2 * 3 * * 4 5 * *  6  *  7  8  *
    
    16 17 18 19 20 21 22 23 24 25 26 27 28 29 30
    9  10 *  11 *  *  12 13 *  *  14 *  15 16 *

由以上两组实验可以看出，每15个报的数为一循环，这也很好理解，3*/5=15，即15为其最小公倍数。每15个数中报8个数，报的数的对应关系也可容易得，1>>1，2>>2，3>>4，4>>7等等，因此可首先判断周期，再取模判断序号，相加即可。

**需要注意！**当a%8=0时的情况（需要在次中减一）这也是最后一个测试点的坑，84分的大概都死在这……（我+1）

因此题输入少，变量少，提供一种思路——**打表**

但因对本题无时间和空间优化，可留给大家自行探索。
思路：循环判断是否取模3，5=0，如是跳过，不是则输出序号即可。

1. 2019月12月27日完成初稿。
1. 2020月1月2日第一次修改，修改内容：修改代码格式，添加部分注释，增加C++部分。