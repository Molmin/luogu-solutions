本题可以采用极限法。为了做到分隔线的作用，我们可以让这条直线接近于平行于坐标轴，也就是说，让$k$的值尽可能大或者尽可能小。

> 一次函数图像斜率不小于$1$ ，不大于$10^{12}$

如果要让图像几乎是与$x$轴平行，那么$k$的值将非常接近$0$。可以说，当$k=0$的时候，函数为常数函数，此时关系式为$y=y_0$，函数与$x$轴平行。但是，$k<1$是要保证的，但是这不符合题目的要求。

如果要让图像几乎是与$y$轴平行，那么$k$的值将接近$∞$。可以说，当$k=∞$（当然这是不可能的）的时候，函数同样为常数函数，此时函数与$y$轴平行。

于是我们考虑作一个斜率为$10^{12}$的一次函数，可以发现，函数几乎是与$y$轴平行的。

此时，如果参数的值接近于$0$，那么函数几乎与$y$轴重合：

![](https://cdn.luogu.com.cn/upload/image_hosting/8fgwga94.png)

改变它的值，如果它大于$0$，那么直线在$y$轴左侧，否则在右侧。

![](https://cdn.luogu.com.cn/upload/image_hosting/2irt05j6.png)

通过这种方法，我们成功地找到了一种非常合理的划分方式。我们可以把这个斜率很大的函数看作是一个常数函数，我们用$x=a_0$表示。此时，该直线左侧满足$x<a_0$，右侧满足$x>a_0$。

题目中说要把这些直线分成$a:b$的比例，那么我们在排列之后（先按$x$值从小到大，再按$y$值从大到小），可以选取第$\dfrac{na}{a+b}$个点作为基准，让这个直线经过该点即可。

如下图，假如要把$6$个点分成$1:1$的比例，那么基准点就是$C$，即第三个点。我们让该直线过$C$点，然后接下来求关系式即可。

![](https://cdn.luogu.com.cn/upload/image_hosting/3kta2yr5.png)

设该基准点坐标为$(x_1,y_1)$，而关系式为$y=k(x-x_0)+y_0$。现在已经让$k=10^{12}$，所以只需要求$x_0,y_0$的值。

我们要让直线经过$(x_1,y_1)$，那么$C$的横纵坐标要满足该关系式。因为要让$y=y_1$，所以$k(x-x_1)=0$。所以$x=x_1$。

因此最终输出的答案为$10^{12},x_1,y_1$。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a,b,pos;
struct point
{
    int x,y;
}p[100001];//定义结构体，方便排序
bool cmp(point A,point B)
{
    if(A.x!=B.x)return A.x<B.x;//先按横坐标从小到大排序
    return A.y>B.y;//再按纵坐标排序
}
int main()
{
    scanf("%d%d%d",&n,&a,&b);
    for(int i=1;i<=n;i++)scanf("%d%d",&p[i].x,&p[i].y);
    sort(p+1,p+n+1,cmp);
    pos=n/(a+b)*a;//确定基准点的下标
    printf("1000000000000 %d %d",p[pos].x,p[pos].y);//按照思路输出
    return 0;
}
```