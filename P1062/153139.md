（看见大佬们都在发进制转化的短代码，我贴个长的）

首先，我们看看样例，分析一下规律。

我们试着忽略底数k，把次数展开：

```
0
1
0 1

2      //   +2
0 2    //0  +2
1 2    //1  +2
0 1 2  //0 1  +2

3       //   +3
0 3     //0  +3
1 3     //1  +3
0 1 3   //0 1  +3
2 3     //2    +3
0 2 3   //0 2  +3
1 2 3   //1 2  +3
0 1 2 3 //0 1 2   +3
……
```
可以看到：
若把这些次数分为许多部分，每一部分的第一个分别是1,2,3,4……

## 那么，去掉第一个之后，剩下的就是之前的所有数都加上现在这个部分的第一个数！！！

话不多说，接下来贴代码：
```cpp
#include<iostream>
#include<cmath>
#define maxn 1001
using namespace std;
int k,n;
long long f[maxn];
long long w[maxn];
int main()
{
	cin>>k>>n;
	for(int i=0;i<=n;i++){
		w[i]=pow(k,i);//记录k的0到n次方 
	}
	int h=0;
	for(int i=0;h<=n;i++){//外层循环枚举每一个部分 
		h++;
		f[h]=w[i];//记录第一个数 
		int k=h;
		for(int j=1;j<k;j++){//内层循环枚举之前的每一个数 
			h++;
			f[h]=f[j]+w[i];//之前的数+第一个数 
		}
	}
	cout<<f[n]<<endl;//输出 
	return 0;
}
```
