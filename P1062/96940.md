本蒟蒻第一次做题解，~~进入管理后台的一刹那蒙圈~~。

小百的第一篇题解：

在做题之前，我发现这是NOIP第四题，于是决定~~先看看题解~~借鉴一下前辈的思想，最后发现~~压根没有看懂~~自己动脑才是好孩子。

先补充一个知识：众所周知，C++的STL库中有单向队列(queue)和双向队列(deque)两个好东西，但是很少有人知道优先队列（priority_queue）。这个东西基本操作和queue差不多，但是它有一个令人垂涎欲滴的好处——

### 自动排序

也就是说，你放进去的所有元素，它都会自动帮你排好序。一般 _默认从大到小_ ，但是也可以手动调节。详情：https://blog.csdn.net/c20182030/article/details/70757660

~~早就知道的大佬们勿喷，我只是一个小小的蒟蒻~~

所以，我就打算找出数列里一定范围内的每一个数，扔到队列里去，然后找到第n个。

说到这里，这个数列有一个~~估计大家基本都发现了的~~规律，那就是任何一个数（除了1以外）都可以表示为数列中某一个数的k倍或者是k倍加1，找到了这个愉快的规律，愉快的我们就可以愉快地写出下面这个函数。

```
void f(long long int t)
{
	
	s.push(t);
    if(t>r)
	{
		return ;
	}
	f(t*k);
	f(t*k+1);
}
```

在这个函数中，t是寻找到的数列中的数，扔给了队列s，那么问题来了，r是干什么用的？

~~r是愉快的上天派下来的秀儿~~

r是一个上限，也就是说，本数列中的数都不可能超过这个数，因此如果t>r就可以打回去了，防止无限循环。但是r该怎么求呢？

~~报告，前方发现奇怪的变量~~

是的，我又用了一个变量l，意思是对于数列中任何一个数，它都由几个不同的k的方幂组成，而任何一个方幂不得超过k^l。知道了l就知道了r。

但是l又不会求了

我认为我可以靠玄学，于是占卜后，认为为了保险起见，我可以让l=sqrt(n/2)

#### 在几个分点中，r超出了long long 


彷徨的我坐在电脑前良久，以至于仿佛看到了我的肝已经在向我告别。就在这时，我发现：

#### 2^0+2^1+...+2^l>=n

就这样找出了不会爆炸的l

```
#include <bits/stdc++.h>
using namespace std;
int n,k,l;
long long int r=1,t=1;
priority_queue<long long int,vector<long long int>,greater<long long int> >s;
void f(long long int t)
{
	
	s.push(t);
    if(t>r)
	{
		return ;
	}
	f(t*k);
	f(t*k+1);
}
int main()
{
	cin>>k>>n;
	for(int i=1;;i++)
	{
		t=2*(t+1);//这里t只是用作了一个临时变量，和函数体的t没一点关系
		if(t>n)
		{
			l=i;
			break;
		}
	}
	for(int i=0;i<=l;i++)
	{               
		r*=k;
	}
	f(1);
	for(int i=1;i<n;i++)//把第n个之前的数都倒掉
	{
		s.pop();
	}
	cout<<s.top();
	return 0;
}//made in china-luogu
```
本代码在洛谷是AC的，但是由于~~我实在太弱了~~感觉码风神奇，希望各位dalao如果发现了可以改进的地方，能够在评论区提出，我会及时编辑
