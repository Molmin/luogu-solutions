我看大家全在用进制转换的思路在做（或者是我没看到别的思路。。），我来为大家提供一种新思路。

**题意**

不再赘述

**算法**

1、进制转换：几位大佬已经讲得十分详尽，我在这里讲一种生成法。

2、生成法：我们观察数列中的每个数，因为每个数是k的幂次方相加，所以必定为k的倍数，换句话说，每个数都是原数列中的数乘上k得到的，又由于还可以加k^0，所以还可能是原数乘上k再加1，这样一个个构造下去，最后就可以得到答案了

P.S. 大家可以去做一下P1748 H数，也是这种生成法（我可是最优解第二哦）

传送门：https://www.luogu.org/problemnew/show/1748

以下为代码：


```cpp
#include<cstdio>
typedef unsigned long long LL;//定义LL类型，偷个懒(雾)
int k,n,i=1,j=1,l=1;//i,j为当前要拓展的指针,l为队列的总长度。
LL q[1001]={0,1};//作为一个队列，储存各个数，初始化q[1]=1。
inline LL min(LL a,LL b){return a<b?a:b;}//min函数，不解释。
int main(){
    scanf("%d%d",&k,&n);//读入，不解释。
    while(l<n){//队列总长度不到要求，继续生成下一个数
        LL a=q[i]*k,b=q[j]*k+1;//a是按照上文所述的第一种方法生成，b是第二种方法。
        q[++l]=min(a,b);//取较小值，保证队列为单调递增，同时确保无重复。
        if(q[l]==a)i++;//指针加1，确保没有重复。
        if(q[l]==b)j++;//同理。
    }
    printf("%lld",q[n]);//输出q[n]，注意要用%lld，不然你定义LL也白搭。
}
```
------------


//P.S.管理员大大，之前有个小错误，已修正，请给过，谢谢啦
