因为看到“顺序相同”，我们联想到了LCS（最长公共子序列）,只不过LCS是对于每个选出来的字符相等且顺序相同，而这里是每个选出来的子串。所以我们按照lcs的套路做，设f[i][j][k][0/1]为：匹配到s的第i位，t的第j位，已经到了第k个字符串，第k个字符串是否继续拓展。

如果s[i]==t[j] 那么f[i][j][k][0]最优决策肯定是f[i-1][j-1][k-1][1]+1或者f[i-1][j-1][k][0]+1（自己新建一段或者拓展之前的一段）

否则，f[i][j][k][1]的最优决策，只能从f[i-1][j]或者f[i][j-1]转移而来，这样就完事了？？？？

Fake！！！如果我s[i]==t[j]的时候，也就是说我这一段是可以选择拓展和不拓展的，如果可以拓展，那不拓展的答案也该有max(f[i-1][j-1][k-1],f[i-1][j-1][k][0])+1，其实就是f[i][j][k][0],对吧

整理一下：

如果s[i]==t[j]:f[i][j][k][0]=max(f[i-1][j-1][k-1][1],f[i-1][j-1][k][0])+1;

f[i][j][k][1]=max(f[i-1][j][k-1][1],f[i][j-1][k-1][1],f[i][j][k][0]);

上代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,k,f[1001][1001][11][2];
char s[1001],t[1001];
int main(){
	int i,j,l;
	cin>>n>>m>>k;
	scanf("%s",s+1),scanf("%s",t+1); 
	for(i=1;i<=n;i++){
		for(j=1;j<=m;j++){
			if(s[i]==t[j]){
				for(l=1;l<=k;l++){
					f[i][j][l][0]=max(f[i-1][j-1][l][0],f[i-1][j-1][l-1][1])+1;
				}
			}
			for(l=1;l<=k;l++)f[i][j][l][1]=max(f[i-1][j][l][1],max(f[i][j-1][l][1],f[i][j][l][0]));			
		}
	}
	cout<<f[n][m][k][1]<<endl;
	return 0;
}
```
