### 更新：
1. 2023/7/5根据要求删除了数字与汉字间的空格。  
2. 2023/7/9根据要求在数字和汉字间添加半角空格，完善内容，标题改为三级标题并在标题行前添加回车。

感谢指出错误！

### 思路  
先观察 样例 #1：  
如果没有一辆车超车，那么我们可以这样看：  
进去一个 $3$ 出来一个 $3$，进去一个 $5$ 出来一个 $5$。  
但实际情况是：  
进去一个 $3$ 出来一个 $4$，显然 $4$ 超车了。  
进去一个 $5$ 出来一个 $3$，但显然 $3$ 没有超车，因为它已经进去过了。  
我们可以发现，如果一辆车没有进去过，却出来了，那么它就超车了。  
于是，按顺序一个一个进，一个一个出，记录没有进去却出来的车的数量，就是答案。  
具体实现见代码注释。  

### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
int en[100005],ex[100005];//enter进入;exit出去
int t[100005];//统计谁已经出去了但没进来，后面它进来就不用管他，直接跳过
int sum;
int main(){
	cin>>n;
	for(int i=1;i<=n;i++)scanf("%d",&en[i]);
	int j=1;//j代表已经进到哪一个了
	for(int i=1;i<=n;i++){
		scanf("%d",&ex[i]);
		while(t[en[j]])j++;//如果一个车已经出去过了，那么后来进来的时候就跳过它
		if(ex[i]!=en[j]){//如果出来的不是进来的，出来的就超车了
			sum++;
			t[ex[i]]=1;//因为没进来直接出去了，所以之后这辆车会进来，统计一下，之后他进来跳过就好。
		}//如果进来的不是出来的，一直找到进来的出去为止，比它提前出去的都是超车，所以j不变
		else j++;//如果进来的是出来的，那就找下一个进来的
        //因为进来的的是出来的，所以不用统计，它之后不会再进来
	}
	cout<<sum;
	return 0;
}
```