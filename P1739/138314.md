心血来潮水红题，居然WA了？

当我AC后点开题解，发现大家做的都好麻烦。

居然没有用STL直接写模拟的。

于是有了这篇题解——

## 首先，我们确定一下输出NO的情况：

> 如果结束时左括号数量多于右括号（也就是最后左括号数量-右括号数量>0）

> 如果在任意时候右括号数量多于左括号（也就是左括号-右括号<0）

## 那么，其他时候则输出YES

综上所述，可以开始快乐写代码了。

# 解法一，直接获取全部字符，逐个处理

由于题目中给出数据只有一行，并且没有空格，那么我们可以使用STL中的string来读取整行字符，遍历一遍即可。代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
    string s;
    cin>>s;
    int l=s.size(),L=0;//获取字符串长度
    for(int i=0;i<l;i++){
        if(s[i]=='(')L++;//统计左括号数目
        if(s[i]==')')L--;//如果遇到右括号则和一个左括号相抵消
        if(L<0){cout<<"NO";return 0;}//判断每一步是否存在右括号数目多于左括号的情况
        }
    if(L>0)cout<<"NO";//特判左括号没有被完全抵消的情况
    else cout<<"YES";//正常情况（括号被完全匹配）
    return 0;
}
```
# 解法二，边输入边处理。
这种方法讲究的是效率，可以加快速度和压缩代码，原理与解法一基本一致，上代码解释：

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
    char c;
    int L=0;//定义存储左括号的变量
    while(1){
        c=getchar();//读取字符
        if(c=='(')L++;//统计左括号数目
        if(c==')')L--;//如果遇到右括号则和一个左括号相抵消
        if(c=='@')break;
        if(L<0){cout<<"NO";return 0;}//判断每一步是否存在右括号数目多于左括号的情况
    
    }
    if(L>0)cout<<"NO";//特判左括号没有被完全抵消的情况
    else cout<<"YES";//正常情况（括号被完全匹配）
    return 0;
}
```
请勿滥用STL！！！！
