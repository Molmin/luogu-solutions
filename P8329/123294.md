- Update on 2022.10.2：修改表述。

> [P8329 [ZJOI2022] 树](https://www.luogu.com.cn/problem/P8329)

高妙的容斥 DP，做完之后对容斥的理解程度又上升了！

VP 的时候设当前考虑了前 $i$ 个节点，第一棵树上有 $j$ 个非叶子，第二棵树上有 $k$ 个节点还未确定父亲的方案数为 $f_{i, j, k}$。

我们发现钦定第一棵树上某个点是非叶子时，并不能保证它在最终的方案里是叶子，因为这和是否存在后面的节点以它作为父亲有关。

所以我们不得不记录 $f_{i, j, k, l}$ 表示 $j$ 个钦定为非叶子的节点仍然是叶子，$k$ 个钦定为非叶子的节点已经是非叶子，第二棵树上有 $l$ 个节点还没有父亲。

转移枚举当前节点在第一棵树上是叶子还是非叶子。

- 若是叶子，那么它在第二棵树上是非叶子。枚举儿子个数 $a$ 以及在第一棵树上以哪一类非叶子作为父亲，有转移 $f_{i, j, k, l} \times j \times \dbinom l a \to f_{i + 1, j - 1, k + 1, l - a + 1}$ 和 $f_{i, j, k, l} \times k \times \dbinom l a \to f_{i + 1, j, k, l - a + 1}$。
- 若是非叶子，同理有转移 $f_{i, j, k, l} \times j \to f_{i + 1, j - 1, k + 1, l + 1}$ 以及 $f_{i, j, k, l} \times k \to f_{i + 1, j, k, l + 1}$。

答案即 $\sum\limits_{i = 1} ^ {n - 1} f_{n, 0, i, 1}$，时间复杂度 $\mathcal{O}(n ^ 5)$，卡常后可以获得 60 分。

状态没有办法继续优化了，考虑对 DP 方法进行优化。

注意到我们容易钦定一个节点是叶子节点，但不容易钦定一个节点是非叶子节点。这个时候就要想到容斥了。具体地，令命题 $P_i$ 为节点 $i$ 在第一棵树上是叶子，$Q_i$ 为节点 $i$ 在第二棵树上是叶子。否命题是节点 $i$ 在某棵树上是非叶子。

我们希望求出 $P_i \land \lnot Q_i$ 以及 $\lnot P_i \land Q_i$ 的方案数，但是钦定 $\lnot P_i$ 或者 $\lnot Q_i$ 是很麻烦的一件事，需要 $n ^ 2$ 的时间复杂度。对于第一棵树，$j, k$ 两维是平方。对于第二棵树，$l, a$ 两维也是平方。

相比之下，钦定 $P_i$ 或 $Q_i$ 就容易得多（例如，当钦定 $i$ 在第二棵树上是叶子的时候，我们不需要枚举 $a$ 这一维）。钦定 $P_i$ 意味着我们强制 $i$ 在第一棵树上是叶子，钦定 $Q_i$ 同理。

同时，我们也容易做到 **不考虑 $P_i$** 的限制。也就是不管 $i$ 在第一棵树上是不是叶子，$P_i$ 或者 $\lnot P_i$ 两种情况都算上。实际意义就是 $i$ 作为一个 **自由节点**，我们不关心它究竟是非叶子还是叶子，这意味着接下来的节点可以随意向它连边。不考虑 $Q_i$ 的限制同理。

我们可以轻松实现上面两个要求，即对每个节点 $i$，选择究竟是钦定 $P_i$ 还是不考虑 $P_i$ 的限制，并求出方案数。对于第一棵树，我们记录 $i$ 及其前面的 **自由节点的个数** $j$（而不是 **钦定的非叶子节点个数**）作为转移系数。对于第二棵树也是一样，记录 $i$ 及其后面的 **自由节点的个数** $k$。记方案数为 $f_{i, j, k}$。

现在考虑求答案。观察 $P_i \land \lnot Q_i$ 和 $\lnot P_i \land Q_i$，它们显然是互斥的，即不可能出现一个节点在第一棵树上是叶子，在第二棵树上是非叶子，**并且** 在第一棵树上是非叶子，在第二棵树上是叶子。所以我们对两种情况单独求解。

对于 $P_i \land \lnot Q_i$ 的方案数，**进行容斥**，它等于 $P_i$ 的方案数（$P_i$ 相当于 $P_i \land (Q_i \lor \lnot Q_i)$）减去 $P_i\land Q_i$ 的方案数。同理，$\lnot P_i\land Q_i$ 的方案数等于 $Q_i$ 的方案数减去 $P_i\land Q_i$ 的方案数。

之前我们分析过 $P_i$ 和 $P_i\lor \lnot P_i$ 都是方便实现的，所以直接容斥 DP 即可。对于 $f_{i, j, k}$，

- 如果我们选择 $P_i$，那么对于 $Q_i$ 相当于要求 $Q_i \lor \lnot Q_i$，说明 $i$ 在第二棵树上是自由节点。考察 $i$ 的连边方案，由于第一棵树上 $< i$ 的自由节点个数为 $j$，第二棵树上 $\geq i$ 的自由节点个数为 $k$，即 $> i$ 的自由节点个数为 $k - 1$，所以 $f_{i - 1, j, k}$ 以 $j \times (k - 1)$ 的系数转移到 $f_{i, j, k - 1}$。
- 如果我们选择 $Q_i$，同理，$f_{i - 1, j, k}$ 以 $j \times k$ 的系数转移到 $f_{i, j + 1, k}$。
- 如果我们选择 $P_i\land Q_i$，因为这种情况要 **被减掉两次**，所以 $f_{i - 1, j, k}$ 以 $-2j\times k$ 的系数转移到 $f_{i, j, k}$。

因为 $1, n$ 两个节点比较特殊，所以对它们单独考虑。节点 $1$ 相当于初始化 $\forall i\in [1, n - 1]$，$f_{1, 1, i} = i$，节点 $n$ 相当于对 $\sum\limits_{i = 1} ^ {n - 1} f_{n - 1, i, 1} \times i$ 求和。

做一遍 DP 的复杂度是 $\mathcal{O}(n ^ 3)$，对每个 $n$ 求答案的复杂度是 $\mathcal{O}(n)$，所以总时间复杂度为 $\mathcal{O}(n ^ 3)$。

```cpp
#include <bits/stdc++.h>
using namespace std;
constexpr int N = 500 + 5;
int n, mod, f[N][N], g[N][N];
void add(int &x, int y) {x += y, x >= mod && (x -= mod);}
int main() {
  cin >> n >> mod;
  for(int i = 1; i <= n; i++) f[1][i] = i;
  for(int i = 2; i <= n; i++) {
    int ans = 0;
    for(int j = 1; j < i; j++) add(ans, 1ll * f[j][1] * j % mod);
    cout << ans << "\n";
    for(int j = 1; j < i; j++)
      for(int k = 1; k <= n - i + 1; k++)
        if(f[j][k]) {
          int coef = 1ll * f[j][k] * j % mod;
          add(g[j][k - 1], 1ll * coef * (k - 1) % mod);
          add(g[j + 1][k], 1ll * coef * k % mod);
          add(g[j][k], (mod - 2ll) * coef % mod * k % mod);
        }
    swap(f, g), memset(g, 0, sizeof(g));
  }
  return 0;
}
```