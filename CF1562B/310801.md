### 题目大意

给定若干个 $k$ 位数，你需要删除掉**尽可能多**的数（至少留一个数），使得留下来的数**不是质数**。

- $1\leqslant k \leqslant 50$。
- 读入的数中不含 $0$
- $1$ 在本题中被认作不是质数。
- 保证有解，有多组数据。

### 题目解析

首先考虑只留下来一位的情况：

一个数字删去若干位后可能不是质数，当且仅当这个数字中某些位数是 $1$ 或 $4$ 或 $6$ 或 $8$ 或 $9$。

即，如果读入的数字中含有 $1,4,6,8,9$ ,显然可以只留下其中一个数字。

---

否则，就需要保留至少两位数：

1.如果该数字中某些数位是$2$（或 $5$ ）且这个数位不在首位，那么这个数一定可以通过保留这个数位和它的前一位数，来使剩下的数能被$2$（或 $5$）整除。

2.如果该数字中有超过两个数位是 $7$ 或者超过两个数位是 $3$ ，那么这个数一定可以通过保留两个 $7$（或 $3$ ）来使剩下的数能被 $11$ 整除（即 $77$ 或 $33$ ）。

3.剩下的情况，则是首位数是唯一的 $2$（或 $5$ ）。由于数据一定有解，而 $23$ 和 $53$ 都是质数，便可通过首位数来判断该保留的是 $27$ 还是 $57$。

### 正确性证明：

如果存在一个数，使得它必须保留至少三位才能保证它不是质数，那么根据上文提到的，该数不能有数位是 $1$ 或 $4$ 或 $6$ 或 $8$ 或 $9$，不能有超过两个 $3$ 或 $7$ ，如果存在 $2$ （或 $5$ ），那么 $2$（或 $5$ ）就必须在首位，不能有数位是 $0$ （题目要求），这样的数数量是有限的，总共就这些：

$2,5,23,27,53,57,37,73,237,273,537,573$

又因为题目保证有解，所以前 $8$ 个数除 $27,57$ 外都不成立，后4个数便可保留首位数和一个 $7$ ，长度都为 $2$。

综上，**不存在一个数使得其满足题目要求且必须保留至少三位才能保证剩余的数不是质数**。

### 代码：

```cpp
#include<bits/stdc++.h>
typedef long long ll; 
using namespace std;
ll t,k,ton[10];
char c[55];
signed main(){
	scanf("%lld",&t);
	while(t--){
		memset(ton,0,sizeof(ton));
		int flag=0;
		scanf("%lld",&k);
		cin>>c;
		for(int i=0;i<k;i++){
			ton[c[i]-'0']++;
			if(c[i]=='1'||c[i]=='4'||c[i]=='6'||c[i]=='8'||c[i]=='9'){
				printf("1\n%d\n",int(c[i]-'0'));
				flag=1;
				break;
			}
		}
		if(flag==1)	continue;
		for(int i=0;i<k;i++){
			if((c[i]=='2'||c[i]=='5')&&i!=0){
				printf("2\n%c%c\n",c[i-1],c[i]);
				flag=1;
				break;
			}
			if((c[i]=='3'||c[i]=='7')&&ton[c[i]-'0']>=2){
				printf("2\n%c%c\n",c[i],c[i]);
				flag=1;
				break;
			}
			
		}
		if(flag==0){
			if(c[0]=='2')
				printf("2\n27\n");
			else
				printf("2\n57\n");
		}
		
	}
	return 0;
}
```

蒟蒻文笔不好，大佬轻喷！！(