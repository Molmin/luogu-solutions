前言：

- 这道题是别人推荐的一道单调栈好题，看到这道题时，看到很多题解都看不懂，于是回去复习lyd大佬的书，弄明白之后就A了这道题，想借题解加深一下记忆，同时也想帮助一下和我一样的萌新.

基础：

- 什么是单调栈？单调栈其实是栈的一个“骚操作”，可以通过维护单调递减或单调递增的元素来及时排除不可能的选项，保证策略集合的有效性，同时也便于维护.

问题转化：

- n行m列土地，求最大矩形面积，我们把问题拆分成n个子问题来解决.
- 对于每一行,依次记录每行向上一直是F土地的可延伸的最大距离，记为f(i,j).

  1. 当前元素(i,j)为F,则f(i,j)=f(i-1,j)+1.
  2. 当前元素(i,j)为R,则f(i,j)=0.

- 我们记录这个数组有什么用呢？这就可以转化为单调栈维护的问题了.

具体思路：

- 对于每一个子问题，我们维护一个单调递增的单调栈.我们定义一个结构体(其中记录的两个元素分别是当前行第j个矩形的f值，以及它在当前已加入栈中矩形高度的排名).

- 我们考虑当前加入第k个矩形的情况.

  1. 当前矩形高度大于栈顶，直接加入即可，因为没有比它大的元素，那么他的排名为1.
  
  2. 当前矩形高度小于栈顶，则不断取出栈顶，直到栈为空或者栈顶矩形的高度比当前矩形小.在出栈过程中，我们累计被弹出的矩形的宽度之和，并且每弹出一个矩形，就用它的高度乘上累计的排名（是累计，因为在它入栈后还有比它大的元素入栈）来更新答案.
  
  3. 这样为什么是对的呢？这是因为：如果当前要加入矩形的f值（即当前矩形的高度比上一个小），那么该矩形想利用前面的矩形一起构成一个大矩形是，这块矩形的高度不可能超过该矩形自己的高度，则记录前面元素的高度就没有用处了.而宽度还有用处（因为当前矩形高度较小，与比它高的矩形的宽度总和相乘，在此矩形出栈时，要用它来更新答案）.所以我们要记一个当前已加矩形的高度排名（无论是在栈里还是已经出栈）.而又因为每个元素只被弹栈一次，所以不会有重复情况.
  
  4. 在所有矩形（m个）都考虑过后，我们再用还没有弹栈的元素再来个新一波答案，直到栈空.
  
下面上代码（我相信各位大佬也不需要代码）：

```
#include<iostream>
#include<stack>
#include<cstring>

#define N 1010

using namespace std;

int n,m,f[N][N],maxx;
char c;
struct node
{
	int len,h;
}a[N];
stack<node> S;

void ask(int x)
{
	memset(a,0,sizeof(a));
	a[1].h=f[x][1],a[1].len=1;
	while(S.size())  S.pop();
	S.push(a[1]);//初始化
	for(int i=2;i<=m;i++)
	{
		int w=0;
		while(S.size()&&f[x][i]<=S.top().h)//需要弹栈
		{
			w+=S.top().len;
			maxx=max(maxx,w*S.top().h);
			S.pop();//更新答案并弹栈
		}
		a[i].h=f[x][i],a[i].len=w+1;//已入栈的比他高的矩形个数加1
		S.push(a[i]);
	}
	int w=0;
	while(S.size())//用剩余矩形更新答案
	{
		w+=S.top().len;
		maxx=max(maxx,S.top().h*w);
		S.pop();
	}
}

int main()
{
	cin>>n>>m;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
		{
			cin>>c;
			if(c=='F')  f[i][j]=f[i-1][j]+1;
		}
		
	for(int i=1;i<=n;i++)  ask(i);//解决子问题
	
	cout<<maxx*3<<endl;//别忘了要乘3哦
	
	return 0;
}
```
