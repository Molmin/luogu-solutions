# 来一篇不一样的题解QAQ

------------
看到这一道题的第一反应是悬线法，但是突然想另辟蹊径来试试水，于是就去暴力了。。。

~~刚好和一个人赌气，他不相信一维数组能过，所以我用一维数组n^3大暴力，，，结果还真过了@鬼墨无忧~~


------------
我的思路是这样的：

1. 三重循环不用说，i表示行数，j表示列数，k用来找该行前面的矩阵

1. 开一个一维数组  _map_  来存当前到第一行的高度，如果读入为 _F_ ，则  _++ map[j]_  ，如果为 _R_ ，则清零；

1. 开一个变量  _num_  来维护当前的最小高度；
1. 开一个变量  _ans_  来存现在找到的最大矩形面积，即矩形高乘上矩形长度，就是代码中的 _num * (j - k + 1)_ 

好了，现在我们的暴力完成了，但是直接交肯定会TLE，所以我们可以加一个优化：

$$map[j]!=0$$
原因：整个输入只有 _R_ 和 _F_ 构成 , 而 _R_  又不用考虑，所以我们找的时候直接跳过 _R_ 就行了；

代码时间：

```
#include<cstdio>
#include<algorithm>
#define _ 0
using namespace std;
int map[1050] ,n ,m ,num ,ans = 1;
char op;
int main()
{
    scanf("%d%d" ,&n ,&m);
    for(int i = 1 ; i <= n ; ++ i)
    {
        for(int j  = 1 ; j <= m ; ++ j)
        {
            scanf("%s" ,&op);
            if(op == 'R') map[j] = 0;//如果为R则直接清零
            else ++ map[j];//存现在到第一行的高度
            num = map[j];
            for(int k = j - 1 ; k && map[k] ; -- k)
            {
                num = min(num , map[k]);
                ans = max(ans , num * (j - k + 1));//算出答案
            }
        }
    }
    ans *= 3;
    printf("%d" ,ans);
    return ~~(0^_^0);
}
```

防伪标记已加，抄代码的盆友注意啦~~~