相信大家都能发现这只是一道普通的模拟题，算法思路省略，主要将几个剪枝和注意事项。
### 【注意事项】
##### 1、每次移动后，最多进行一次奖励或惩罚，不会发生连锁反应。
##### 2、所有的数据点的起点都应该是-1，而不是样例中的0。
##### 3、在输入数据中包含空格，所以应该用gets或getline。
##### 4、在准备执行奖励或惩罚时，一定要奖励或惩罚的距离大于等于3（而不是2）。
##### 5、当棋子越过左起点或右终点时，要将其移动至左起点或右终点。
##### 6、如果用gets读入，要把字符串的长度减1.
### 【剪枝】
##### 由于数据非常的大，我们需要在程序之前对每个点奖励或惩罚的距离进行预处理（小贴士：从后往前枚举可以节约时间，因为不然就要先统计'>'或'*'的个数，再将沿途的点标记一遍），用一个数组来记录每一个奖励或惩罚点后面接的'>'或'*'的个数。具体实现见代码。
### 【代码】
```cpp
#include <bits/stdc++.h>
using namespace std;

char s[1000010];

int add[1000010],a[1000010];

int main(){
	int len,i,j,k,m,n;
	gets(s);
	len=strlen(s)-1;			//要减去换行符所占的长度 
	scanf("%d",&n);
	for(i=1;i<=n;i++)
		scanf("%d",&a[i]);
	for(i=len-1;i>=0;i--){		//从后往前预处理奖励或惩罚的点 
		if(s[i]=='>'){
			if(s[i+1]!='>')
				add[i]=1;
			else
				add[i]=add[i+1]+1;
		}
		if(s[i]=='*'){
			if(s[i+1]!='*')
				add[i]=1;
			else
				add[i]=add[i+1]+1;
		}
	}
	a[1]--;						//由于所有测试数据的起点都为-1，所以第一步只能走啊a[1]-1步 
	k=0;
	for(i=1;i<=n;i++){
		k+=a[i];
		if(add[k]>=3){			//注意：题目说的是，一定要三个及以上距离 
			if(s[k]=='>')
				k+=add[k];
			else
			if(s[k]=='*')
				k-=add[k];
		}
		if(k<0)					//如果当前位置越出边界，则让它回到边界 
			k=0;
		if(k>len-1)
			k=len-1;
	}
	k++;						//题目中的第一个字符的位置是一，输入的字符串的第一个字符的位置是零，故需再次加上一 
	printf("%d %d\n",k,len-k);
	return 0;
}
```