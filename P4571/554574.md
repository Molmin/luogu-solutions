首先，我们来模拟一下火星人倒油过程。

假设给火星人两个瓶子，容量分别为 $a$，$b$。

不妨设 $a>b$。

那火星人第一次会选多少燃料呢？

火星人一定会先将 $a$ 倒满，将 $a$ 的燃料倒满 $b$，再将 $b$ 的燃料倒回到燃料库。重复几次，燃料就只剩下 $a\ mod\ b$。

然后再重复一下，又因为火星人一定会给你燃料，最后就会得到一个结果：$\gcd(a,b)$。

那如果要三个，四个，甚至更多个瓶子呢？其实简单推理一下结论也是一样的，等于所有选择的瓶子的容量的最大公约数。

也就是说我们要找到 $k$ 个瓶子，使得最大公约数最大。

很多人就卡在了这一步不知道怎么办。

其实我们都十分思维定式。

最大公约数就是从所有公约数中选出最大的。

那我们为什么不可以先找到公约数呢？

而公约数又是从所有约数集合中找出公共的部分。

我们可以将所有数的约数都分解出来，然后找出是否有某个约数出现的次数大于等于 $k$，然后在这些约数中找到最大的就是答案。

应该解释的挺清楚了 ~~(bushi~~ 直接看代码：

```cpp
#include<bits/stdc++.h>
#define N 10000005
using namespace std;
map <int,int> f;
vector <int> p;
int n,k,a,ans;
int main(){
    scanf("%d%d",&n,&k);
    for(int i(1);i<=n;++i){
        scanf("%lld",&a);
        for(int j(1);j*j<=a;++j){
            if(a%j) continue;
            if(!f[j]) p.push_back(j);
            ++f[j];
            if(!f[a/j]) p.push_back(a/j);
            ++f[a/j];
            if(j*j==a) --f[j];
        }
    }
    for(int i(0);i<p.size();++i)
        if(f[p[i]]>=k) ans=max(ans,p[i]);
    printf("%d\n",ans);
    return 0;
}
```

✿✿ヽ(°▽°)ノ✿