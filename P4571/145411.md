这是~~我第一个自己没看题解写出来的~~一道数学题。

众位大神，这个菜鸡写的比较啰嗦，不喜请划过

------------
如果只看两个瓶子相互倒的话，就是一道小学数奥题——结论就是两者的GCD,那么我们就可以猜测这个结论在拓展到n个数的时候也成立。关于这个成立的原因，第一份题解写的很好，我就当一个补充，写一写几个式子来再证一下两个瓶子互相倒吧。


------------
首先，我们不妨假设有两个瓶子a,b,且Va<Vb,且Va=x,Vb=y。每一次倒的定义就是：油池->b,b->a,a->油池,b->a。
 
|  |第一次  |第二次  |第三次  |第四次  |  第N次   |
| :----------- | :----------- | :----------- | :----------- | :----------- | :----------- |:-----------|
|a剩余 |y-x  |2y-2x  |3y-3x  |4y-4x  |ny-nx  |
|a差多少满  |2x-y  |3x-2y  |4x-3y  |5x-4y  |(n+1)y-nx  |

我们可以~~清晰的~~看到，每次a的剩余都符合模式a*x-b*y，所以我们可以知道，当两个瓶子相互倒的话，就是符合裴蜀定理的a*x+b*y=d，所以，就可以解决了。而当拓展到多个时，就可以想，先找两，把两个这么相互倒可以找到的最大值再当成一个瓶子，放入，以此类推。所以题目就成了，给你N个数，任选k个数，求这k个数的GCD最大可以是多少


------------
由于题目的范围，我们可以用试除法求出这n个数的因子,然后用一种玄学的统计众数方法找到K个数的GCD/这个找众数的方法叫什么名字我忘了，但大致思路就是——把每个因数组成的数组先排序，然后从后向前扫，用一个变量cnt记录某个数出现的次数。如果这个数所在的位置的上一个位置的数和它一样，cnt++,否则就变为1.如果这个数出现过K次以上，那么在它清零前，cnt就会大于k。


------------
下面就是代码了
```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<algorithm>
using namespace std;
int n,k,a[1000005],top,cnt=1,x;
int main() {
	scanf("%d%d",&n,&k);
	for(register int i=1;i<=n;i++){
		scanf("%d",&x);
		for(register int i=1;i<=sqrt(x);i++){//试除法处理
            if(x%i==0){
                a[++top]=i;
                if(i*i!=x) a[++top]=x/i;
            }
        }
	}sort(a+1,a+top+1);
	for(register int i=top-1;i>0;i--) {
		//众数的统计
		if(a[i]==a[i+1]) cnt++; else cnt=1;
		if(cnt>=k){
			printf("%d",a[i]);
            system("pause");
			return 0;
		}
	}
	system("pause");
	return 0;
}   
```


------------
国际惯例，谢谢观赏
