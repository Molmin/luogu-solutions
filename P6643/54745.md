首先易证比较大的边最多就选一条。

你考虑答案不会超过 $2(n-1)$ 减直径，如果一条边能加进来至少说明直径比 $n$ 除 $3$ 上取整要严格大。如果你都加进来两条大边那你的答案就至少就是 $n-3+2\lceil \frac{n}{3} \rceil$ 然后他还要比 $2n-2-\lceil \frac{n}{3} \rceil-1$ 严格小，你会发现刚好似了。所以肯定是最多加一条大边。

那问题就是选哪个大边了，这里有一些聪明的做法但是我根本不会。考虑枚举加谁，相当于有若干次询问每次让你强制走某个 $(u,v,w)$，和树边你能做到的最好结果。如果你现在要从起点 $s$ 走到终点 $t$，如果 $s$ 到 $t$ 的路径和 $u$ 到 $v$ 的路径没交，你会发现相当于 $s$ 到 $t$ 的路径不用走第二遍，但是 $s$ 到 $t$ 和 $u$ 到 $v$ 的路径的交你还是得走第二遍的，所以这个时候的答案就是 $2(n-1)-dis(s,t)+w-dis(u,v)+$路径交的长度。

所以其实就是给若干对 $u,v$ 查询 $dis(s,t)-$ 路径交的最大值。我们考虑树剖嗯做。

先考虑不交的贡献咋算，考虑那个交点，每个点处理出除去重儿子后在子树里选出的最长路径就行了，LCA 单独算一下，相当于扣了两个儿子之后找出最长和次长的路径，往上的最长路可以换根 dp 出来，然后可以在 bfs 序上建一个 st 表维护区间子树内最长路最大值。然后找两次最大值就行了。一次查询就是两个点在那跳跳跳！每个点会经过若干段重链的前缀，然后在 LCA 下边是一段 dfn 区间，你对每个重链的前缀都预处理出来最大值（就是扣了一个重儿子的答案），然后对两个 dfn 区间你就可以再开个 st 表或者写个线段树维护一下 rmq 。对于跳轻儿子的情况就你拿那个维护区间子树最长路的 st 表怎么算算就行了，反正能 O(1) 做的。然后就是进行这样的一些处理后你第一部分的复杂度就变成单 log 了。

有交的贡献你就考虑肯定长成那段交的左右端点伸出去一条链的样子。然后你考虑处理出来每个点作为左端点的代价和作为右端点的代价，然后就是找一个在前边的左端点代价加上一个在后边的右端点代价就行了。具体来说，你把那 log 条重链拿出来，中间所有跳轻儿子的位置也拿出来，LCA 也拿出来，反正就是 log 个东西排成一列，每一个东西你都算出来他作为左边和右边的贡献就能用前缀 max 之类的玩意随便算一算就行了。然后重链的部分这块还是长成若干个重链前缀和两个 dfn 区间，你还是一样就预处理出来重链前缀的权值以及弄个 rmq 数据结构查询一下那两个 dfn 区间就能单 log 搞出来，对于那些跳轻儿子的单点就拿在 bfs 序上维护的 st 表怎么算算就行了，都是单 log 的。LCA 也是一样扣了两个儿子的。不过你还会发现一件事情叫做两个点处于同一段重链里，这该怎么办呢？无所谓，反正是若干段重链前缀和两个区间，拿线段树维护一下区间内前面选一个左端点后面选一个右端点的答案，对于重链内部前缀预处理一下。

最后我们就可以在 $O((q+n) \log n)$ 的时间复杂度里做完这个题啦！

代码可能稍微有点长：https://www.luogu.com.cn/paste/d1gqxs7n
