# P3143
~~(为什么我6个小时后交的一篇题解都过了，这篇题解没有通过也没有被打回……我再交一遍吧）~~
## 题意简述

- 给出 n 个数，从其中选出两组数，使每一组的 最大值与最小值之差不超过 k

## 题目分析

题目中选数是可以任意的，但是要尽量接近，所以我们选的数一定是一段长度连续的数。所以我们可以先对它排序。

我们很容易可以想到一个贪心思路（错的），一次考虑每一个点，算出以这个点为左端点可以选几个数，然后选出最大的两个点，相加得到答案。

但是这个贪心思路可能选出的两段区间会有重叠部分，导致答案错误。

**但是我们只要解决这个重叠问题就可以了**，我们可以考虑每个点，算出以它左边最大可以选的区间有多长，它右边最大可以选的区间有多长，再相加，这样就不会出现重叠了！

**但怎么计算它左边最大可以选的区间有多长呢？**~~（暴力出奇迹！）~~ 设 $le[i]$ 为$i$点左边最大可以选择的区间长度，我们只要从左往右依次考虑每个点，枚举这个点为左端点可以选 k 个数，然后 $max(k,le[i-1])$ 就是 $le[i]$ 的值了 。（同样，计算右区间同理）

最后，枚举一遍 $ i $，$le[i]+r[i+1]$最大的就是答案。

## 易错点

- 不要忘了排序
- 后面的点比前面的点大，枚举右区间时不要弄反了
- $le[1]$ 和 $r[n]$ 应先设为1再去枚举

## AC代码

内带详细注释

```cpp
#include<bits/stdc++.h>
using namespace std;
void read(int &x){//快读 
	int f=1;x=0;
	char ch=getchar();
	while(ch<'0'||ch>'9') {if(ch=='-') f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9') { x=x*10+ch-'0';ch=getchar();}
	x*=f;
}
#define N 50010
int n,k,ans;
int a[N],le[N],r[N];
int main(){
	read(n),read(k);
	for(int i=1;i<=n;i++) read(a[i]);
	sort(a+1,a+1+n);//易错点1 
	le[1]=r[n]=1;//易错点3  
	for(int i=2,now=1;i<=n;i++){ 
		while(a[i]-a[now]>k) now++;//找 "k" 
		le[i]=max(le[i-1],i-now+1);//类似递推 
	}
	for(int i=n-1,now=n;i>=1;i--){
		while(a[now]-a[i]>k) now--;
		r[i]=max(r[i+1],now-i+1);//易错点2
	}
	for(int i=1;i<n;i++){
		ans=max(ans,le[i]+r[i+1]);//最后的枚举 
	}
	cout<<ans;
}

```

蒟蒻写题解不易，点个赞呗~
