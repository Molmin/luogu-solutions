## $\tt Description$

有一种图形叫做五角形圈。一个五角形圈的中心有 $1$ 个由 $n$ 个顶点和 $n$ 条边组成的圈。在中心的这个 $n$ 边圈的每一条边同时也是某一个五角形的一条边，一共有 $n$ 个不同的五角形。这些五角形只在五角形圈的中心的圈上有公共的顶点。

现在给定一个 $n$ 五角形圈，你的任务就是求出 $n$ 五角形圈的不同生成树的数目。

注意：在给定的 $n$ 五角形圈中所有顶点均视为不同的顶点。

## $\tt Solution$

比赛的时候一眼下去有点懵，然后就画了一下图，写了一个 $n=2$ 的暴力，然后调试了一会儿后答案对了，然后就跑去搞 $n=3$ 、 $n=4$ 的答案。然后花了点时间找到了规律，写个了递推。然后这道题目就做完了。

> 我们再仔细观察，发现它变成一颗树，需要将所有五边形删去一条边，得方案 5 的 n 次方。
然后其中一个五边形要再删去一条边，且这条边必须要在中心圈上。所以剩下一条边只有 4 种方案，得方案 $5^{(n-1)} \times 4n$。——zdw

## $\tt Code$

```cpp
#include <cstdio>
int d[1000001];
int pow(int x,int y)
{
	if(y==0)
	{
		return 1;
	}
	else
	{
		int dq=pow(x,y/2);
		if(y%2==0)
		{
			return (dq*dq)%2007;
		}
		else
		{
			return (((dq*dq)%2007)*x)%2007;
		}
	}
}
int main()
{
	freopen("count.in","r",stdin);
	freopen("count.out","w",stdout);
	d[2]=8;
	for(int i=3;i<=100;i++)
	{
		d[i]=d[i-1]+4;
	}
	int T=0;
	scanf("%d",&T);
	while(T--)
	{
		int n=0;
		scanf("%d",&n);
		printf("%d\n",(d[n]*pow(5,n-1))%2007);
	}
	return 0;
}
```