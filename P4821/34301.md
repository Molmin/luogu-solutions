##### [题目传送门](https://www.luogu.org/problemnew/show/P4821)
#### [博客传送门](https://blog.csdn.net/huang_ke_hai/article/details/87918858)

题目描述：
有一种图形叫做五角形圈。

![在这里插入图片描述](https://img-blog.csdnimg.cn/20190225155738159.png)

一个五角形圈的中心有1个由n个顶点和n条边组成的圈。在中心的这个n边圈的每一条边同时也是某一个五角形的一条边，一共有n个不同的五角形。这些五角形只在五角形圈的中心的圈上有公共的顶点。如图0所示是一个4-五角形圈。
现在给定一个n五角形圈，你的任务就是求出n五角形圈的不同生成树的数目。还记得什么是图的生成树吗？一个图的生成树是保留原图的所有顶点以及顶点的数目减去一这么多条边,从而生成的一棵树。
注意：在给定的n五角形圈中所有顶点均视为不同的顶点。
***
输入格式
输入包含多组测试数据。
第一行包含一个正整数T，表示测试数据数目。
每组测试数据包含一个整数n( 2<=N<=100)，代表你需要求解的五角形圈中心的边数。
***
输出格式
对每一组测试数据，输出一行包含一个整数x，表示n五角形圈的生成树数目模2007之后的结果。

分析：
一道数学推导题（$wc$居然放在图论专讲里。。）。

* 我们首先考虑生成树的概念：$n$个点的图被$n-1$条边所连。

不难得出，图中一共有$4n$个点,$5n$条边。
* 根据生成树的性质，我们需要删除$n-1$条边。

均摊下来，每个五边形需要删去一条边，剩下一条边。（也就是说有一个五边形需要删去两条边）

因为图中的正$n$变形也是一个环，所以我们必须有一条边是需要删正$n$边形的边的。

* 一个五边形需要删两条边，有一条边必须删正$n$边形的边，有4种方法，每个五边形都可能是这个删两条边的五边形，一共有$n$个，是$4n$种方法
* 剩下n-1个五边形各有五条边可以删，一共是$5^{n-1}$种方案

所以总方案个数是：
$$4*n\ +\ 5^{n-1}$$

那么具体代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define LL long long
#define P 2007
int t;
int main(){
	freopen("data.in","r",stdin);
	freopen("data.out","w",stdout);
	scanf("%d",&t);
	while (t--){
	    int n;
	    scanf("%d",&n);
	    LL Pow=1;
	    for (int i=1;i<n;i++) Pow=(Pow*5)%P;
	    printf("%lld\n",(Pow*4*n)%P);
	}
	fclose(stdin);
	fclose(stdout);
	return 0;
}

```
