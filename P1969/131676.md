
。。。

上次第一次发题解被吞了

难受


# 下面说这道题
    首先想到的是依次读入每个高度，并从1 to h 枚举同一高度，
    并与上一个同一高度的标记值比较，
    只要标记值为0 或者差值大于1 就会增加一次移动次数，
    并更新标记一次，
    但一看数据规模。。。100000的区间，10000的高度。。。
    

------------

    其实这种想法没错，但我们需要换一种标记方法；
    题上说的很明白，搭建是按**区间**进行的，一个区间只需搭建一次，
    我们记上一个高度（说成当前高度吧，不然怪别扭的）为h，读入高度为H，
    h，H也是代表在相应位置重叠区间的个数，
    如果读入H=h相同，h个区间可以顺势延长，不会增加搭建次数，
    
    如果H>h，那么我们必须新建**H-h**个的区间，前面的h个区间继续延伸
    这也会增加相应的搭建次数
    
    如果H<h，那么会有**H-h**个区间无法继续延伸，
    但前面的H个区间仍然可以延伸，不会增加次数
    
    更新上一个的高度，读入下一个
    **注意**，首次读入前，h=0，视为在之前有0个区间叠加，否则会省掉一些搭建次数。
    以此类推，可以很容易得出搭建次数
    如果没听懂，自己画一幅图试试呗，很容易理解的
    ~~我才不承认我解释的不好呢~~
    
#     下面附代码
    
    
```pascal
var
  n,h,i,x,ans:longint;//ans用长整型就好，至多500000000大小，不会超

begin
  readln(n);
  h:=0;//其实没有也可以啦，反正初始值为0，~~等于上面白提醒注意了，泪目~~
  for i:=1 to n do
    begin
    read(x);
    if x>h then inc(ans,x-h);//增加搭建次数
    h:=x;//更新当前高度（在此处的区间个数）
    end;
  write(ans);//输出
end.
```
没错，就这么简单的代码......