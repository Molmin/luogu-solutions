这题虽然说是普及-难度，但依然有些思维含量。

我们现在可以这样想：为什么区间的个数不等于最高的块呢？是因为搭完一个区间可能会造成区间的分割。

我们现在可以从左向右摆积木，如果当前列需要的高度大于前一列需要的高度，那么当前不会造成区间分割，记录这个递增序列的最大高度。

如果小于前一列需要的高度，造成了区间分割，这时我们需要把“凸”起的木块所需区间计入答案，因为它们已经被分割开来，无法再与后面的块连在一起。不难想象，这里的“凸”指的是之前最大高度与当前块所需高度之差。因为是递增序列，那么这几列所需的区间就是“凸”起的高度。

这样利用贪心思想，时间复杂度为O（n），但是别忘了要把最后一个递增序列加上哦（即循环到n+1）。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[100010],ans;
int main(){
	cin>>n;
	for(int i=1;i<=n;i++) 
		cin>>a[i];
	int base=0;
	for(int i=1;i<=n+1;i++){
		if(a[i]>=base)base=a[i];
		else ans+=(base-a[i]),base=a[i];
	}
	cout<<ans<<endl;
	return 0;
}
```
