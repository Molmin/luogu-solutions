看到这道题，我们应该有种冲动吧——如果你没有，那么我们一起来看

排序二叉树最大的特点是什么——没错，就是排序，更严谨来说，是它的中序遍历成升序（无重复元素前提下） ，而对一棵二叉树，它的中序遍历的顺序是不会变化的，因此现在的a[i]只会是a[i]不变化/变化后得到的结果

我们又想让修改次数最少，又想令其保持升序，因此我们直接找出其中最长上升子序列不动，其余修改（爱咋咋地）不是

流程如下：

1.	读入，求树的中序遍历，计入s[]数组
2.	LIS一遍求出len，ans=n-len

同时，这道题n<=100000,$n^2$的老年LIS算法是不行的，大家可以去看大神的博客，建议写法：

```cpp
memset(dp,INF,sizeof dp);
go(i,1,n)dp[lower_bound(dp+1,dp+n+1,s[i])-dp]=s[i];
	reintlen=(lower_bound(dp+1,dp+n+1,INF)-dp)-1;

```
    
但千万别开心过头了
来看看我考场上写的样例

![](https://cdn.luogu.com.cn/upload/pic/41030.png)

How to 完善我们的方案？
借用一句话：不严谨的真理往往是通往真理的钥匙。


从错误入手，分析错误原因：
考虑二叉排序树的定义：

 _设key[p]表示结点p 上的数值，对于其中的每个结点p，若其存在左孩子lch，则key[p]>key[lch]；若其存在右孩子rch，则key[p]<key[rch]。注意，应该是所有左子树中的key 小于当前key，所有右子树中的key 大于当前key。_ 

其中唯一且最大的限制就在于根和儿子的大小约束关系：而这种关系体现在什么，是中序遍历的编号！

![](https://cdn.luogu.com.cn/upload/pic/41031.png)

再看此图，5在中序是4,3在中序是7

故3和5的关系牵扯到3层（第一次我们将其列出：1比3小，2比1小，5比2大），简单来说，由于这里不可取等，3和5就至少相差三——不信的话你还是尝试去造第二个图
在程序实现中即对每对i，j,|va[i]-va[j]|>=|其中序遍历之差|

这个东西很麻烦，而中序遍历时我们其实可以直接保存va[i]-(i的中序遍历编号)之后就求一个不下降序列即可

具体的实现如下：

中序：
```cpp
void zx(re int rt)
{
	if(t[rt].lc) zx(t[rt].lc);
	s[++s[0]]=t[rt].va-s[0];
	if(t[rt].rc) zx(t[rt].rc);
}
```
不降lis（这里没办法stl直接写）：
```cpp
dp[len=1]=s[1];
go(i,2,n)
	if(s[i]>=dp[len]) 
		dp[++len]=s[i]; 
	else{      		
        	re int j=upper_bound(dp+1,dp+len+1,s[i])-dp;
            dp[j]=s[i];
		}
//ans=n-len
```



