## 题意&&坑点
此题的大意是，输入的负数表示下半身，而正数则是上半身，现在输入一段数列，要求上半身从小到大与下半身锲合。

#### 坑点

- 输入负数的绝对值必须从小到大

- 最后一个输入的负数，必须要第一个匹配

那么，这一题就是**从大到小** **先进后出！**

这不就是栈吗？

于是，此题用栈就好了。

## 思路&&注意

思路：用栈模拟负数的压入（毕竟它是是下半身啊），输入正数就对栈顶进行匹配，匹配到就直接弹出。

注意：

- 插入负数时，它绝对值必须从大到小。

- 最好插入负数的绝对值，这样插入可以直接比较大小，输入正数可以直接匹配。

- 正数匹配时，有可能栈为空，应此要提前判断。

- 每次判断完成后，一定要把栈清空，进行下一次操作。

## 代码

```cpp
for(int i=1; i<=n; i++) {
	int flag=0;//flag是判断这个东西有没有失败
	for(int j=1; j<=a1[i].n1; j++) {
		if(!flag) {
			if(a1[i].aa[j]<=0) {//负数（下半身）
				if(s.empty())//如果为空
					s.push(abs(a1[i].aa[j]));//直接插入
				else {
					int cc=abs(a1[i].aa[j]);//绝对值
					if(s.top()<cc) {//如果此负数的绝对值比上一个大
						flag=1;//失败
						cout<<":-( Try again."<<endl;
					} else
						s.push(cc);//加入
				}
			} else {
				if(s.empty()||s.top()!=a1[i].aa[j]) {//如果栈是空的或者栈顶与此数不相同的
					flag=1;
					cout<<":-( Try again."<<endl;//失败
				} else
					s.pop();//匹配成功，弹出
			}
		}

	}
	if(flag==1) {//如果失败，清空
		while(!s.empty())
			s.pop();
		break;
	}
	if(flag==0) {//如果成功，输出
		cout<<":-) Matrioshka!"<<endl;
	}
}
```
