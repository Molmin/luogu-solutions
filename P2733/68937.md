这道题大佬都说很简单，但是看完大佬们的题解我还木明白dp方程怎么搞，数据预处理我还没看过。。。

经过我一番思索，终于得出了正解。

这道题求正方形数目，于是我们用排除法： 

对于一个矩阵中的（1x1）零点它所影响范围内的（2x2）正方形肯定不选，即，也即为零

比如：

		1 0 1 1 1 1

		0 0 1 1 1 1

		1 1 1 1 1 1

		0 0 1 1 1 1 

		1 0 1 1 0 1 

		1 1 1 0 0 1

对于测试样例的（6x6）矩阵，经过第一次关于（2x2）正方形的变化后会变成（5x5）的矩阵，也可以推出，（i，j）点控制的点为（i-1，j）（i，j-1）（i-1,j-1）

经过变化：

		0 0 1 1 1 

		0 0 1 1 1 

		0 0 1 1 1 

		0 0 1 0 0

		0 0 0 0 0 
        
矩阵中1的点的个数即为所构成（2x2）正方形的个数

然后，（3x3）变换也可以直接由该“经过（2x2）变换的这个矩阵”得到。

附上代码

```cpp
#include<iostream>
#define Max 300
using namespace std;
int main() {
	int n, a[Max][Max]{ 0 },sum = 0;
	cin >> n;
	char c[Max][Max];
	for (int i = 0; i < n; ++i)
		cin >> c[i];
	for (int i = 0; i < n; ++i)
		for (int j = 0; j < n; ++j)
			a[i + 1][j + 1] = c[i][j] - '0';
	for (int k = 2; k <= n; ++k) {
		sum = 0;
		for (int i = 1; i <= n - k; ++i) {
			for (int j = 1; j <= n - k; ++j){
				if (!a[i][j]) { a[i - 1][j] = 0; a[i][j - 1] = 0; a[i - 1][j - 1] = 0; }//如果a[i][j]为零，则它控制的三个矩形也为零
		        sum += a[i - 1][j - 1];
			}
		}
		if (！sum) break;
		cout << k << ' ' << sum << endl;
	}
	return 0;
}
```

有修改，不要抄