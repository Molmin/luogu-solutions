## 题意
给定一个 $01$ 串集合 $S$，其中每个串的长度都不超过 $N$，求出至少是 $S$ 中 $K$ 个串的子序列的最长串，如果有多解，输出字典序最小的那组解。
## 数据范围
$ 0\leq N\leq 20$，$0\leq K\leq \vert S\vert$

## 分析
由于初始给定的集合 $S$ 比较大，我们考虑自动机DP。

首先考虑子序列匹配的过程，假设我们有两个串 $A=10$，$B=00110$，要判断 $A$ 是否是 $B$ 的子序列：

在 $B$ 中找到 $A$ 的第一个字符 $1$ 的位置 ，在从这个位置的下一个位置开始找 $A$ 中的第二个字符 $0$（即在剩下的 $10$ 中匹配 $0$），如果都找得到就匹配成功。本质上是一个贪心的过程，能匹配就匹配肯定是最优的。

知道了如何匹配后，我们就可以据此来设计状态，令 $f_{A,B}$ 表示已经匹配的子序列为 $A$，剩下还可以用来匹配的串为 $B$ 的状态下 $A$ 是多少个串的子序列。转移时，枚举下一个匹配的字符是 $0$ 还是 $1$，在 $B$ 中找第一个 $0$ 或 $1$ 位置即可。

代码实现上，显然不能直接记录 $A,B$ ，考虑到我们只需要知道 $A,B$ 分别的长度和他们合在一起的状态 $T$，而在转移时我们会从小到大枚举 $A$ 的长度，所以只用记录 $A+B$ 的长度即可。这样时空复杂度就都是 $O(n2^n)$。

## 注意事项
开数组尽量保证转移时访问地址连续，这样会快很多（对我而言，三倍），下面的代码把 ans 数组去掉（只用 f 来判定是否大于等于 k）在洛谷上就是目前 rk1 了。

## 代码

```cpp
#include<bits/stdc++.h>
#define gc getchar()
#define FOR(i,a,b) for(int i=a;i<=b;i++)
#define ROF(i,b,a) for(int i=b;i>=a;i--)
using namespace std;
inline int read(){
	int x=0;char s=gc;
	while('0'>s||s>'9')s=gc;
	while('0'<=s&&s<='9'){x=x*10+s-48;s=gc;}
	return x;
} 
int n,Ans,ansb,kk,ans[1<<20],A1[21][1<<20],f[21][1<<20],nxt[21][1<<20];
char s[1<<20];
int main(){
	n=read(),kk=read();
	FOR(i,0,n){
		cin>>s;
		FOR(j,0,(1<<i)-1)if(s[j]=='1')f[i][j]=1;
	}	
	FOR(i,1,n)
		FOR(j,0,(1<<i)-1){
			int p=(j>>(i-1))&1;
			nxt[i][j]=-1;
			ROF(k,i-2,0)if((j>>k&1)!=p){nxt[i][j]=k+1;break;}
		}
	FOR(i,0,n){
		FOR(j,0,(1<<i)-1)ans[j]=0;
		FOR(k,0,n-i)FOR(j,0,(1<<(i+k))-1)ans[j>>k]+=f[i+k][j];
		ROF(j,(1<<i)-1,0)if(ans[j]>=kk)Ans=j,ansb=i;
        
		FOR(k,1,n-i)
			FOR(j,0,(1<<(i+k))-1){
				int p=nxt[k][j&((1<<k)-1)];
				if(p!=-1){
					int t=j&((1<<p)-1);
					f[i+p][((j>>k)<<p)+t]+=f[i+k][j];
				}
			}
	}
	ROF(i,ansb-1,0)cout<<((Ans>>i)&1);
	return 0;
} 
/*
3 4
1
01
1011
01001110
*/ 
```


