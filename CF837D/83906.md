### [点￥這#里体验题目巛♂性的版♀本](https://www.luogu.org/problemnew/show/CF837D)



------------

## Part1:做题感想：

+ 马上就要NOIP了，本蒟蒻DP也是非常的蒻。正好集训班ZHHX神犇讲了这道题，发现是道思维挺不错的题目，就过来水了。

+ 如果细心的话会发现这道题某个人的记录占了一页（⑨次）~~（就是我）~~
+ 快读出锅害死人

+ 这是本人第一次写题解，如果有纰漏的地方函请斧正。



------------

## Part2.动态规划心得：

名言1：
```
DP进阶:堆维度和删维度就是了。——鲁迅
```

当然，我们不能盲目堆。
**我在这里要讲的更多一些DP的小技巧**，以便以后dalao们能更好的了解DP而不是日日夜夜头疼想状态转移方程。


------------

## Part3.有用的小技巧：

### 1.增加维数。
我们拿到一道题且无从下手时，其正解一般是DP。
为什么我们做不出来？因为其中有很多很多**因变量**不受我们控制。也就是说，我们在考虑该状态转移的过程中应该尽量多的选择具有后效性的状态，而后再想着怎么优化降维。

### 2.巧用其他数据结构。

我在这里举个栗子大家就懂了：去年PJ组最后一道题**[跳房子](https://www.luogu.org/problemnew/show/P3957)**。我们都能想到用dp[i]来表示最大值，但是时间复杂度太大了。

P.S.
```
动态规划时间复杂度：状态数*状态转移复杂度
```

我们就很自然地想到用单调队列来维护最大值。

同理，当我们苦思冥想dp方程怎么优化时不妨回顾一下自己刷过的题，或许会有灵感哦。

### 3.整体与部分的转化（即可行性转最优）。

我们在某题~~（BZOJ1079）~~可能会暴力出来一个~~1e9~~维的dp方程。不妨再想想：

#### 可不可以把其中一个维度扔出来作为dp的含义呢？

很高兴的是，这道题就是那么优化的，待会我们再讲。

### 4.合并本质相同的维度。

在某些问题里，我们会发现有几个维度的意思（本质目的）是一样的。那我们不如合并降维，结为异姓兄弟。

### 5.再说。

下面我们就开始正式讲这道题。



------------

## Part4.不做成背包的本题做法：


Cthugha告诉我说这是背包，我反正没看出来QAQ。不过我们不能只会背包，我们必须搞明白动态规划的普遍做法而不是每道题都想着怎么套模板。~~（其实就是没看出来怎么用背包）~~

刚才我们提到了第三点：整体与部分的转化，我们现在就开始具体讲讲。


+ 这题怎么做？看不懂啊QAQ



------------

### DP方程初步分析：

```
我们把一个数的 roundness 值定义为它末尾 0 的个数。

给你一个长度为 n 的数列，要求你从中选出 k 个数，使得这些选出的数的积的 roundness 值最大。
```
我们至少能得到几条信息：

#### 1.有什么对roundness末位的0具有较大贡献
#### 2.0不能对roundness产生贡献

有时候我们的直觉是对的： 
### Key1:只有2和5才能凑成末位0。（10嘛）
### 且乘下来0的个数由min(sum_2,sum_5)决定哦
换句话说，2与5的贡献最大。

其他的就好想多了：
我们需要最优的子结构，就可以安排一个i作为前i个已经选取的数，但是一些数我们可以不选啊，就在安排一个j作为已经选取的数


自此我们摸出了一个简单的四维dp方程：dp[i][j][x][y]

### Key2：四维dp方程表示前i个数已经选取了j个数，其中2为质因数的数个数为x,5为质因数的数的个数为y。dp表示一个bool值，可以选取则为true,反之则为false



------------

### 初步DP方程的转移方程：

Dp[i+1][t+1][ x+sum_2[i+1] ][ y+sum_5[i+1] ]=true;

Dp[i+1][t][x][y]=true;

最后总得计算一次roundness最大值即可。时间复杂度：O（$N^{2}$*$(Nlog N)^{2}$） 太大了。



------------

### 运用知识点三解决本道题:

我们不妨将**[y+sum_5[i+1]]**移出来，作为dp的含义。
即：

### Key3：dp[i][j][x]=y;
### dp[i][j][x]表示将前i个数选出t个，已经有x个2，dp值代表最多有多少个5。

那么状态转移方程即为：
#### Dp[i+1][j][x]=max(dp[i+1][j][x],dp[i][j][x]);
#### Dp[i+1][j+1][x+sum_2]=max(Dp[i+1][j+1][x+sum_2],dp[i][j][x]+sum_5);（有前提）

时间复杂度是：O（$N^{2}$*Nlog N）

当然，还有优化方法：



------------
### 运用状态压缩优化本问题：

具体请看AC代码，这里不多讲，因为状压dp很常用就是了。

------------
### AC代码：

```
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cctype>
#include<algorithm>
#include<stack>
#include<queue>
#include<cmath>
//#include<mrwang>
#define ll long long
#define mp make_pair
using namespace std;
/*
inline ll read() {
    int x=0,w=0;
    char ch=0;
    while(!isdigit(ch)) {
        w|=ch=='-';
        ch=getchar();
    }
    while(isdigit(ch)) x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
    return w?-x:x;
}*/
int get_lower(ll x,int p) { //求某个因数的次数
	int ass=0;//贫穷限制了我的想象力
	while(x%p==0) {
		x/=p;
		ass++;
	}
	return ass;
}
ll n,k;//题目给出
ll a[200+5];//不要忘了开大一点哦
//bool dp[3][200+50][5000][5000];//原四维未优化dp方程
ll dp[2][200+5][6000];//前i位已经选出了j个数，其中因数2的个数为k所代表的因数5的个数
ll sum_two,sum_five,sum,ans;//计算2,5出现次数
ll cur;//状压
inline void ready() {//本人习惯 
//    n=read(),k=read();
	scanf("%d%d",&n,&k);
	for(ll i=1; i<=n; i++)
//	a[i]=read();
		scanf("%lld",&a[i]);
	memset(dp,-1,sizeof(dp));//这个是老习惯 
}
int main() {
	ready();
	dp[0][0][0]=0;//不要忘了初始情况 
	for(ll i=1; i<=n; i++) {
		sum_two=get_lower(a[i],2);//计算质因数2的出现次数 
		sum_five=get_lower(a[i],5);//同上 
		cur^=1; 
		sum+=sum_two;//计算总次数 
		for(ll j=0; j<=k&&j<=i; j++) { //因为是取出i个数
			for(ll x=0; x<=sum; x++) {
				dp[cur][j][x]=max(dp[cur^1][j][x],dp[cur][j][x]);
				//决策一：考虑当前数是否有贡献
				if(j>=1&&dp[cur^1][j-1][x-sum_two]>=0&&x-sum_two>=0)
					dp[cur][j][x]=max(dp[cur^1][j-1][x-sum_two]+sum_five,dp[cur][j][x]);
				//决策二：考虑取出当前数是否对当前产生最大贡献
			}
		}
	}
	for(ll i=0; i<=sum; i++) {
		ans=max(ans,min(i,dp[cur][k][i]));//乘下来0的个数由2质因子和5质因子的数量来决定
	} //即min(i,dp)
	printf("%lld",ans);
	return 0;
}
```




------------

### 后记：

~~明明我快读没写错啊为什么会卡在第8个点上啊QAQ~~

## 祝各位NOIP2018都400score++，拿到自己想要的好成绩！

学累了可以找我来玩哦。

感谢帮我debug的各位神仙

END.

