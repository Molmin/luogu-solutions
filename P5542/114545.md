## 正解：二维差分

~~（写题解是因为写题时忘了二维差分怎么写，现在复习下）~~



 _对于一维差分，实现[a,b]区间加上val_ 
 
c[a]+=val;

//从c[a]开始，往后的每一个数都+val

c[b+1]-=val;

//相当于在c[b+1]处终止了+val的操作



------------


拓展到二维差分

 _实现矩形（左上角（x1,y1) ,右下角(x2,y2))内加上val;_ 

c[x1][y1]+=val;  //  开始+val的操作

c[x1+1][y2]-=val; // 在该行终止

c[x1][y2+1]-=val; // 在该列终止


(要注意的是：对于c[x2+1][y2+1]这个，被终止了两次，即多减了一个val，所以要补回来)

c[x2+1][y2+1]+=val;



------------

差分和前缀和是互逆操作，还原成原数组，维护个前缀和就好了

------------
### 注意点：

 1、题目给的是二维坐标系的左下角和右上角，实际上就是我们平常使用差分或前缀和时，用行列表示的左上角和右下角（相当于把坐标系转一下）,所以直接拿来用就好了，不需要进行转化
 

2、题目告知的是点的坐标，而差分和前缀和都是在格子上实现的，所以要把点转化成格子,即左上角的点横坐标和纵坐标都+1（不会的话可以画个图模拟下）

------------
下面贴代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1010;
int n,k,a,b,x,y,ans;
int f[N][N];
int main(){
	cin>>n>>k;
	for(int i=1;i<=n;i++){
		cin>>a>>b>>x>>y;
		a++;b++;
		f[a][b]++;
		f[a][y+1]--;
		f[x+1][b]--;
		f[x+1][y+1]++;
	}
	for(int i=1;i<=1000;i++)
		for(int j=1;j<=1000;j++){
			f[i][j]+=f[i-1][j]+f[i][j-1]-f[i-1][j-1];
			if(f[i][j]==k)ans++;
		}
	cout<<ans;	
	return 0;
}
```
~~逃了~~~
