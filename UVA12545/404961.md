## 思路：
令操作 $1$ 为改问号，操作 $2$ 为改 ```'0'``` 为 ```'1'```；操作 $3$ 为交换。

首先，这三个操作都不能减少 $s$ 中 ```'1'``` 的数量，所以，当 $s$ 中 ```'1'``` 的个数比 $t$ 中多时输出 $-1$，其余情况是一定有解的。

其次，第三个操作（交换）不能改变 $1$ 的数量。而 $s$ 和 $t$ 相同的必要条件是 $1$ 的个数相同，所以我们只能用操作 $1$、$2$ 来改变一的数量。$s$ 中的 ```'?'``` 用 $1$ 操作**尽可能**变为 $t$ 中的一样的字符。之后，$s$ 中的字符必要改的 ```'0'``` 用 $2$ 操作**尽可能**找 $t_i$ 为 ```'1'``` 的 $i$ 位置改。

注意，执行 $1$、$2$ 操作的首要目的是改变 $s$ 中  ```'1'``` 的个数（当然，如果 ```'1'``` 已经够了，操作 $1$ 就只能把 ```'?'``` 改为 ```'0'``` 了）！

然后我们怎么知道 $3$ 操作要执行多少次呢？$s$ 中和 $t$ 中同一位置不同字符的个数除以 $2$ 就是答案。要注意实现细节。
## 代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
int main()
{
   int T;
   char s[101], t[101];
   scanf("%d", &T);
   for(int i = 1; i <= T; ++i)
   {
      scanf("%s%s", s, t);
      printf("Case %d: ", i);
      int cs = 0, ct = 0, ws = 0, ls, ans = 0;
   // num of '1' in s; '1' in t; '?' in s; '0' in s; 答案*2.
      for(int i = 0; s[i]; ++i)
      {// 统计
         if(s[i] == '1')
            ++cs;
         else if(s[i] == '?')
            ++ws;
         else
            ++ls;
         if(t[i] == '1')
            ++ct;
      }
      if(cs > ct)
      {
         puts("-1");
         continue;
      }
      for(int i = 0; s[i]; ++i) // 操作 1
         if(s[i] == '?')
         {
            ans += 2;
            if(ct == cs)
               s[i] = '0';
            else if(ws <= ct-cs)
            {// 如果 '?' 的个数 <= 还要改 '1' 的次数
               s[i] = '1'; // 尽量把 '?' 改为 '!'，因为 '?' 都要被改，这里改了不浪费操作 2
               ++cs;
            }
            else
            {
               s[i] = t[i];
               if(t[i] == '1')
                  ++cs;
            }
            --ws;
         }
      for(int i = 0; s[i]; ++i) // 操作 2
         if(s[i] == '0')
         {
            if(cs == ct) break;
            if(t[i] == '1' || ls == ct-cs){++cs;ans+=2;s[i]='1';}
            --ls;
         }
      for(int i = 0; s[i]; ++i) // 操作 3
         if(s[i] != t[i])
            ++ans;
      printf("%d\n", ans>>1);
   }
   return 0;
}
```