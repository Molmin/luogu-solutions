## 前言
这题其实就是思路题，想好以后就是一道比较简单的题了

## 思路

先看输入，给了你两个字符串，与三种修改方案，但可以发现，三种方案都不可以减少 $ 1 $ 的数量，所以可以先扫一遍，如果 $ a $ 串的 $ 1 $ 的个数要比 $ b $ 串中的 $  1 $  个数多的话，就可以直接输出 $ -1 $ 了。

如果不是，就说明一定可以变成字符串 $ b $ 。我们再依次看三种操作。

操作一： 将 $ 0 $ 变成 $ 1 $ ，操作二： 将 $ ? $ 变成 $ 1 $ 或 $ 0 $ ，操作三： 交换两个数的位置。

通过观察可以发现，如果两个位置在 $ a,b $ 串中的数字相反，可以直接交换，使用一次机会。就像下面这个样例：

```
01
10
```

直接交换两个数的位置，变成

```
10
10
```
只需消耗一次机会。所以我们可以统计  $ a,b $ 串中这样情况的数量，取其中的最小值即可。

而省下的如果是 $ 10 $ ,就直接加一， $ ?1 $ 或  $ 1? $ 的情况，也直接加一即可。 

如果剩下的是 $ 01 $ ,因为已经事先确认了一定可以转换完成，就说明一定有更多的 $ ? $ 存在。 而将问号换为 $ 0 $ 再交换的代价的正好是 $ 2 $ ,所以将这样情况数量相加即可。

因为 $ ? $ 也需要一次机会，所以还要加上 $ ? $ 的数量。

## 代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,i,j;
string a,b;
int main(){
	cin>>n;
	for(i=1;i<=n;i++){
		getchar();
		cin>>a;
		getchar();
		cin>>b;
		int a1=0,a2=0,a3=0,a4=0;
		for(j=0;j<=a.size()-1;j++){
			if(a[j]=='1')a1++;
			if(b[j]=='1')a2++;
		}
		if(a1>a2){
			cout<<"Case "<<i<<": -1"<<endl;
			continue;
		}
		else{
			a1=a2=a3=a4=0;
			for(j=0;j<=a.size()-1;j++){
				if(a[j]=='1'&&b[j]=='0')a1++;
				if(b[j]=='1'&&a[j]=='0')a2++;
				if(a[j]=='?')a3++;
			}
			int ans=max(a1,a2)+a3;
			cout<<"Case "<<i<<": "<<ans<<endl;
			continue;
		}
	}
}
```
