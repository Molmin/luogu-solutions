- 我们之前在思考点分治的时候忽然想到了一个问题。
- 如果把每次的分治重心全部建立父子关系，显然可以得到一棵新树，而这棵树的高度为严格 $O(\log n)$。
![](https://cdn.luogu.com.cn/upload/image_hosting/9iiwnfyx.png)
- 由于点分树的高度很少（提高行政效率），所以我们甚至可以保存关于每个点分树上节点线性的信息（更好地“管辖”子树，中央集权）！所以很多暴力的操作都是可以搞的（~~暴政~~）。

**引入**
- 让我们来一道[例题](https://www.luogu.com.cn/problem/P6329)，它要求在线地修改点权，查询距离不超过 $k$ 的点的点权和。
- 我们先建出点分树，一个很暴力的想法就是用 $\text{vector}$ 求出 $c(u,k)$ 表示 $u$ 在点分治下的子树内在原树距离不超过 $k$ 的点的个数，预处理 $d(u,k)$ 表示 $u$ 在点分治上的 $k$ 级祖先与它在原树上的距离，然后查询的时候暴力查询（$f(u,k)$ 表示在点分树上的 $k$ 级祖先）$f(fa(u,i),k-d(u,i))$。
- 然后你很快发现这样会重复，因为它的父亲会查到它儿子，所以还要设 $g(u,k)$ 表示 $u$ 在点分树上的父亲在原树上距离小于等于 $k$ 的点有多少个在 $u$ 的子树上，从而减去重复的部分。
- 接下来你还要带修，但是你很快发现这并不是难事，暴力在点分树上跳，用树状数组维护这一过程。
- 时间复杂度 $O(n\log n+q\log^2 n)$，空间复杂度 $O(n\log n)$。

**实现细节**
- 我认为点分树的实现很有细节，类似于[分治](https://www.luogu.com.cn/blog/luo1gu1zui1bang1/post-ji-chu-you-hua-fen-zhi)的内容，它可以形象化地分为这几步：
- 第一步即寻找重心，在这个时候可以同时处理上层对子树的影响（我是通过一个队列来实现的）。
- 第二步即正式地计算子树内部的贡献，然后找到重心，同时下传对子树的影响（我同样通过一个队列实现）。
- 第三步即分裂下传，把这些纲要在头脑内想一想，思路就逐渐清晰了。
- $f$ 函数和 $g$ 函数对于特定的节点 $u$ 所需要开的空间大小同样十分重要，$f$ 函数应该至少开以 $u$ 为根，这棵子树的最大深度那么多的空间，而 $g$ 函数应该开以 $u$ 点分树上的父亲为根，这棵子树的深度那么多的空间，当然，你全部设成子树大小也可以。
- 这里吐槽一下，我一开始点分治打错还过了好几题，这数据有点水，[代码实现](https://www.luogu.com.cn/paste/15plvu6a)。
- [调试代码](https://www.luogu.com.cn/paste/e7d831z8)。