算法很简单，对于每个节点，暴力比较其左右子树。只需要在空节点处停止比较，此外**不需要任何剪枝**。

代码就不贴了，很多人都贴过了，这里只说两点：
1. 在比较两棵树 $x$ 和 $y$ 时，不妨假设 $\textsf{size}[l[x]] \le \textsf{size}[r[x]]$，此时可以**递归**比较 $l[x]\sim r[y]$ 并**循环**比较 $r[x] \sim l[y]$. 这样的尾递归优化可以保证栈深度为 $O(\log(n))$.
2. 暴力的复杂度是 $O(n\log(n))$，而不仅仅是 $O(n^2)$。问题的关键在于，总比较次数不只是小于所有子树大小之和，而且小于所有**节点数较少的儿子**的大小之和。比如对于只有左儿子的树（即链），实际上总比较次数为  0。下面是严格证明。

令
$$f(n):= \max_{T=\textsf{大小为}n\textsf{的树}}\Bigg\{\sum_{t=T\textsf{内的节点}}\min\big\{\textsf{size}[l[t]], \textsf{size}[r[t]]\big\}\Bigg\}$$
即大小为 $n$ 的树中所有**节点数较少的儿子**的大小之和的最大值，也是总比较次数的一个上限。易知：
$$f(n) = \max\Big\{f(t) + f(n-1-t) + t \mathrel{\Big|} t=0,1,\dots, \left \lfloor{\frac{n-1}{2}}\right \rfloor \Big\}$$
其中 $t$ 代表较小的那棵子树的大小。特别定义 $f(0) = \max\{\} := 0$.

欲归纳证 $f(n) \le n\log_2(n)$.

对于 $n=0$ 和 $n=1$，$f(n) = 0 \le n\log_2(n)$.
- 注：虽然 $\log_2(n)$ 在 $n=0$ 无定义，但 $n\log_2(n)$ 在 $n=0$ 有极限 $0$，因而不影响下文依赖函数连续性的极值分析。

对于 $n>1$，由归纳假设知
$$f(n) \le \max\Big\{t\log_2(t) + (n-1-t)\log_2(n-1-t) + t \mathrel{\Big|} t \in \Big[0, \frac{n-1}{2}\Big]\Big\}$$

右边连续且关于 $t$ 的二阶导 $\frac{1}{t}+\frac{1}{n-1-t}$ 在定义区间内部恒为正，因此为闭区间内的下凸函数，存在最大值且只可能位于两端，即 $t=0$ 或 $t=\frac{n-1}{2}$. 带入可得
$$f(n)\le \max\Big\{(n-1)\log_2(n-1),\;\frac{n-1}{2}\log_2\frac{n-1}{2} \times 2 + \frac{n-1}{2}\Big\} \le n\log_2(n)$$

证毕。

考虑满二叉树可知，$O(n\log(n))$ 为暴力复杂度的精确上界。