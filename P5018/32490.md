## 在这道题之前呢，我先给大家讲一个悲惨的故事

当年有一个oier，考场上不到十五分钟就干掉了前两个题，然而t3是一个恶心的dp，dp作为他的弱项，这一题几乎耗掉了他的所有时间，他想，t3都这么难，t4不用问了吧，他粗略的看了一下t4，结果发现是一道搜索题，暴力当然是每个oier最喜欢的做法，然而不知为什么，他竟没有去做，跟t3死磕到底，而t4呢，他在考试结束的前五分钟，写出了一鸣惊人的代码
```cpp
#include<iostream>
using namespace std;
int main(){
    cout<<"1";
 	return 0;
}
```

考试成绩出来了，t1是一道再水不过的字符串，然而他的gets忘了cstdio。。。

t2是枚举，他得到了100分

t3他推了好几个小时的状态转移方程，本想可以得部分分，然而爆零是结局

t4不用说了

他励志要挽回一点颜面，于是就有了今天这篇题解

## ————————————————————————————————

搜索题不用解释了吧，我们要找出对称的二叉树，不妨设两个指针，这两个指针对着干，你往左我就往右，这样我们才可以保证是对称的，这两个指针一开始还是血浓于水的兄弟，然而为了各自的理想分道扬镳，也就是说，在一棵对称二叉树的根节点他们是相等的。

如果我的论述极为晦涩，那么请看我们的代码
```cpp
#include<iostream>
//#include<windows.h>
using namespace std;
struct tree{
    int left,right,bs;
}a[1000001];
int mmax,sum,ans,f=0;
int dfs(int l,int r){
if(l==-1&&r==-1){
    return 0;
}
if(l==-1||r==-1||a[l].bs!=a[r].bs){
    f=1;
    return 0;
}
    if(a[l].bs==a[r].bs&&l>0&&r>0){
        sum++;
        dfs(a[l].left,a[r].right);
        dfs(a[l].right,a[r].left);
    }else{
        f=1;
        return 0;
    }
}
int main(){
    int n;
    cin>>n;
    for(int i=1;i<=n;i++){
        cin>>a[i].bs;
    }
    for(int i=1;i<=n;i++){
        cin>>a[i].left>>a[i].right;
    }
    for(int i=1;i<=n;i++){
        f=0;
        dfs(i,i);
        if(f==0)
        mmax=max(mmax,sum);
        sum=0;
    }
    cout<<mmax;
    return 0;
}
```
我们细细来讲解

输入完成后，我们的f变量是用来判断是否为一棵对称二叉树，dfs（i，i）的两个参数即为上文提到的两个指针，他们一开始是相等的

深搜函数内，我们先判断两个指针所代表的是否为空节点，如果是的话就return，接下来我们再判断是否是一棵对称二叉树，如果两个指针其中有一个是空节点而另一个不是的话或者两指针代表的权值不同我们就认为这不是一棵对称二叉树。

如果这两个条件都没满足，我们便将节点数加一，注意这里的两个dfs，一个往左一个往右，这样就可以保证对称。

跳出dfs后，我们用mmax数组来存储最大的节点数，如果是一棵对称二叉树，我们就更换mmax的值。

我并不会太多的高级算法，所以我并没有用更高级的算法来做，所以我只能用我拙劣的代码及晦涩的语言来为大家讲解。

我的代码可以优化，但是我太懒了

就这样啦