### **题目大意**

输入一个正整数 $N$ , 找出一个最小的自然数，使得这个自然数的各个数位的乘积为 $N$。
    
### **思路**
 
 
有一个贪心的思想在里面，你想让输出的数字最小，你要从大的数开始遍历。因为一个数字的每一位都为小于 $10$ 的数，所以要从 $9$ 到 $2$ 遍历。（ $1$ 只会增大这个数的大小）。

从大到小遍历是因为让这个答案尽可能小，用大数除出的数会使会使数位更小。（如果一个数能被 $9$ 整除，就没必要用二个 $3$ 整除，会使答案增大）

遍历完之后，如果剩下的数比 $9$ 大则无解。

当一个数小于 $10$ 时，答案就是这个数。

### **代码**

```
#include<bits/stdc++.h>
using namespace std;
int T;
int n;
int main(){
	cin>>T;
	while(T--){
		int a[100001];
		cin>>n;	
		if(n<10){//特判 1：n 小于 10 时输出这个数。
			cout<<n<<endl;
			continue;
		}
		int num=0;
		for(int i=9;i>=2;i--){//从 9 到 2 遍历。
			while(1){
				if(n%i!=0)
					break;//如果这个数被除到不能再被整除时，跳出循环。
				else{
					a[++num]=i;//存储数据。
					n/=i;
				}
			}
		}
		if(n>=10){//如果最后 n 比 10 大,则无解
			cout<<-1<<endl;
			continue;
		}
		for(int i=num;i>=1;i--){
			cout<<a[i]; //将 a[i] 倒序输出，因为 a[i] 的大小是递减的，而最小的情况应是从小到大输出。
		}
		cout<<endl;
	} 
	return 0;
}
```
