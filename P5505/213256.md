# 题意简述：

有 $n$ 个有标号的抽屉和 $m$ 种有标号的水果，每种水果有 $a[i]$ 个，求每个抽屉至少放一种水果的总方案数。

# Solution

先看一个简单的问题，有 $m$ 个相同的小球，放到 $n$ 个相同的盒子里，盒子不为空，问有多少种放置方案？

采用隔板法，$m$ 个小球排成一排，在 $m - 1$ 个空隙中插入 $n - 1$ 块隔板，总共形成 $n$ 个部分，每个部分就是一个盒子，总共有 $C_{\ m-1}^{\ n-1}$ 种方案。

若盒子可以为空，问有多少种放置方案？

可以看做有 $m + n$ 个元素，在 $m + n - 1$ 个空隙里插入 $n - 1$ 块隔板，总共形成 $n$ 个部分，每个部分包含若干个元素，如果某部分只包含一个元素，则这个元素就看作盒子，且没有得到小球；若某部分包含 $k$ 个元素，则这部分就看作 $k - 1$ 个小球放入 $1$ 个盒子中。总共有 $C_{\ m+n-1}^{\ n-1}$ 种方案。

对于本题，考虑一种特产一种特产的分，设第 $j$ 种特产，有 $a [ j ]$ 个，若有 $i$ 个人没有得到特产，则剩下的 $n − i$ 个人分，且也可能某些人存在分不到的情况，方案为 $C_{\ a[j]+n-i-1}^{\ n-i-1}$ ，同时，每个人编号不同，还需要选择 $i$ 个人出来，这 $i$ 个人肯定不能分到特产，所以至少 $i$ 个人没有分到特产的方案数为： $C_{a[j]+n-i-1}^{n-i-1}$  ，其中 $1\le j\le m$  ，表示的是一种特产一种特产的分，而分步用乘法。

设 $f [ i ]$ 表示至少 $i$ 个人没有分到特产的方案数。

我们有： $f[i]=C_n^i\prod_{j=1}^m C_{\ a[j]+n-i-1}^{\ n-i-1}$  。

设有 $3$ 个人分别是  $A , B , C $  ， $f [ 1 ]$ 包含的情况有，     $A(B,C),B(A,C),C(A,B)$ ，括号外的表示选出来肯定分不到的人，括号里的表示可能分不到的人。可以发现，对于两人分不到的情况减了两次，因此需要加上 $f [ 2 ] $ 包含的情况，这样就得到刚好 $1$ 个人分不到、刚好 $2$ 个人分不到的方案数，为 $f[1]-f[2]$ 。

根据容斥原理，那么刚好 $1$ 个人、$2$ 个人、…  $n-1$ 个人的分不到的总的方案数为：

$f[1]-f[2]+f[3]-f[4]....f[n-1]$。

用 $f [ 0 ]$ 表示至少 $0$ 个人分不到的方案数，减去上面的方案数，就是刚好 $0$  个人分不到的方案数，即最后的答案：

$ans=\sum_{i=0}^{n-1}(-1)^i\times f[i]$。

时间复杂度为 $O(N^2)$ 。

下面是我的代码

```cpp
#include<bits/stdc++.h>
#define M 1000000007
#define ll long long
using namespace std;
ll ans,C[3005][3005],n,m,a[100005],f[100005];
ll T(ll x)
{
	if(x%2==1) return -1;
	else return 1;
}
int main()
{
	scanf("%d%d",&n,&m);
	for(ll i=1;i<=m;i++) scanf("%d",&a[i]);
	C[1][1]=1;
	for(ll i=0;i<=2000;i++)
	C[i][i]=C[i][0]=1;
	for(ll i=2;i<=2000;i++)
	{
		for(ll j=1;j<=i;j++)
		{
			C[i][j]=(C[i-1][j-1]+C[i-1][j])%M;	
		//	cout<<C[i][j]<<" ";	
		}
	//	cout<<endl;
	}
	for(ll i=0;i<=n-1;i++)
	{
		ll s=1;
		for(ll j=1;j<=m;j++)
		{
			s=((s%M)*(C[n-i+a[j]-1][n-i-1]%M))%M;
		}
		if(i%2)ans=(ans-s*C[n][i]%M+M)%M;
		else ans=(ans+s*C[n][i]%M)%M;
	}
	cout<<ans%M;
	return 0;
} 
```
