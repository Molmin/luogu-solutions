~~我好菜啊，这道并不难的题做了我一天，从上午8点多到下午4点多才做完，总算自己刚出来了。赶快发一篇题解纪念一下。~~

首先我们分析一下题目的性质：

我们考虑从前往后填这个序列（我们把排成一行的红球和蓝球简称为“一行球”，注意把它和答案序列区分开来）。

（下文把红球写为A，蓝球写为B）

因为我们任何时候都可以选择第一个位置，所以任何时候都可以填A（A没填完的话）

然后我们还需要得知更多信息。我之前的想法是枚举B第一次出现和最后一次出现的位置，这样对正解有所启发，~~但是也会误入歧途，导致我想了一上午都没想出来；睡完午觉，猛然想到了正确的枚举方法，让我们一点点来说~~

不妨设$S<T$

我们先枚举B第一次出现的位置。为了拼出更多的序列，我们肯定希望选择更小的T。事实上，我们应该选择此时一行球中第一个B的位置。

我们发现，在接下来长度为B-1的序列中，我们可以任意填A和B！再之后，T这个位置就失效了。

好，假设我们枚举了接下来放几个B，设为i。

然后我们只能放A了——直到下一个B出现！

我们再枚举B在第二部分里第一次出现的位置，同样，我们要在一行球里选择最靠前的B作为S。

接下来长为B-i-1的序列我们又可以随意填了，枚举填了j个。

再接下来我们只能顺着拿球了，也就没有方案数可言了。

这样我们就得到了$O(n^4)$的算法：

（代码中p为枚举T，q为枚举S）

```cpp
for(ri p=1; p<=A+1; ++p)
{
	for(ri i=1; i<B; ++i)
	{
		for(ri q=p+B; q+B-i-1<=len; ++q)
			for(ri j=1; j<=B-i; ++j)
			{
				if(!(B-i-j<=len-(q+B-i-1))) continue;
				inc(ans,mul(c[B-1][i-1],c[B-i-1][j-1]));
			}
	}
}
```

显然有很大的优化空间。

我们发现j这一维可以直接前缀和掉，然后p这一维更没用了：它只是限制i和q的取值范围，对数字没有贡献！

于是就这样优化为了$O(n^2)$

具体细节+-1之类的要推一推，代码很简单：

```cpp
#define N 4005
int c[N][N],sc[N][N];
void init(int n)
{
	c[0][0]=sc[0][0]=1;
	for(ri i=1; i<=n; ++i)
	{
		c[i][0]=1;
		for(ri j=1; j<=i; ++j)
			c[i][j]=add(c[i-1][j-1],c[i-1][j]);
		for(ri j=i; j>=0; --j)
			sc[i][j]=add(sc[i][j+1],c[i][j]);
	}
}
int A,B;
signed main()
{
#ifdef M207
	freopen("in.in","r",stdin);
	// freopen("ot.out","w",stdout);
#endif
	in(A,B);
	if(B==1)
	{
		out(A+1);
		return 0;
	}
	int len=A+B,ans=0; init(len);
	for(ri i=1; i<B; ++i)
	{
		for(ri q=B+1; q<=i-B+len+1; ++q)
		{
			int t=2*B-2*i-len+q-2;
			inc(ans,mul(c[B-1][i-1],sc[B-i-1][max(t,0)],min(A+1,q-B)));
		}
	}
	inc(ans,A+1);
	out(ans);
	return 0;
}
```

我总感觉这道题能做到$O(n\log n{\tt ~or~} n\sqrt{n})$