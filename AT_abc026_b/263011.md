先得从小到大排序，排序后很显然，红环在奇数层，白环在偶数层。(且最外层是红环)

再利用圆环面积公式$(S=π*(R^2-r^2))$算出每个红环面积(排序后的每个奇数层半径的平方$-$偶数层半径的平方)$*π$,再由乘法分配律推导得总面积$=$(所有的奇数层半径的平方的和$-$所有的偶数层半径的平方的和)$*π$

上代码($c++$)

```cpp

#include<bits/stdc++.h>
using namespace std;
int a[1005];
int main()
{
	int n,m=0;//最后用m*π
	cin>>n;
	for(int i=1;i<=n;i++)
		cin>>a[i];
	sort(a+1,a+n+1);
	for(int i=1;i<=n;i++)
	{
		if(i%2!=0)
			m=m+a[i]*a[i];//奇环加
		else
			m=m-a[i]*a[i];//偶环减
	}
	printf("%.11f\n",abs(m*1.0*3.14159265358979323846264338327));//算面积要用abs函数(最后那一堆是π)
	return 0;
}
```

$AT$要换行哟