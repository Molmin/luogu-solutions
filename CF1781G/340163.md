向蜜蜂学习了一种好做法。

首先显然存在 $O(2^n)$ 的枚举做法，合法性检测容易不谈。

观察样例，我们宣称答案只存在 $0,1,2$。进一步猜测只有样例里面的唯一一种特殊情况答案是 $2$，否则答案是点个数模 $2$ 的值。

对这个结论进行默认，考虑构造。我们按这样的方式构造：

1. 如果深度最深的叶子的父亲没有另一个儿子：这两个结点涂上不同的颜色，然后这两个结点从树上删去，并不影响；   
2. 如果深度最深的叶子的父亲有两个儿子（另一个儿子必定也是叶子）：父亲和两个儿子涂上不同的颜色，然后从树上删去，此时有一种颜色会多用一个。

直接这样构造删除若干连通块，容易出现删不干净或者不优的困境。我们保留剩下最多十个结点的树进行暴力搜索，找到剩下的树中最优的方案。然后对于用第二种方式构造的三个结点，如果蓝点多就让父亲填白色，否则让父亲填蓝色。

这种构造的合法性显然，（可以尝试）通过暴力枚举得到一开始猜测的结论的正确性，且这种构造根本卡不掉，于是通过了此题。

[评测记录](https://codeforces.com/problemset/submission/1782/189424059)。