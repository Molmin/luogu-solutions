题意：有一个起点X，求该起点的位置，满足从X顺时针走到每一个A时，走过的序列中A的数量比B的数量多的总数分别为0，S，k-S（三个问）。

为什么是k-S？因为第三问是B的特征值为S，则剩下的就是A，即A的特征值为k-S。

理解了这一题时，第一反应是求出一个序列S，该序列的S[i]表示从第1到第i位，A比B多的数量，以便判断A是不是“强的”。在求这个序列的时候，先假设所有空位都是B。

然后呢？枚举X的位置？

但在前面我们把X也假设成了B，如果枚举X的位置的话S序列的值是需要维护更新的。

画一个图也许能更好解释规律。

假设一个序列{0，0，1，1，1，0，0，1，0}，0表示未知的位置，1表示该位置是A。此时可以求出S={-1，-2，-1，0，1，0，-1，0，-1}，最后一位一定是-1。我们将S中的每一个元素按顺序点在坐标系中（数值表示纵坐标，为区分类型，将0（B）用红点，1（A）用蓝点）

![](https://cdn.luogu.com.cn/upload/pic/27377.png)

简单的观察发现，貌似能求出“强的”点A的数量，就是高于某条水平直线的蓝点个数。

但是要考虑X的位置。因为原数列S可以看作是第0个点为X（假设存在第0个点）的计算结果，如果是正常的情况，就要对S进行适当的修改。若其中第x个点是红点且为X，则在他之后的S'[x+i]（i>0）应该为S[x+i] - S[x]，如果S'[x+i]>0且x+i为蓝点，则说明第x+i位是满足“强的”一个A。将上式移项，即为S[x+i]>S[x]，此时右半边的特征值即为高于射线y=S[x]的蓝点个数。而x左边的S'[x-i]（i>0）应该为(S[n] - S[x]) + S[x-i]，改写该式得S'[x-i] = S[x-i] - S[x] - 1，同上，移项后，即为S[x-i] > S[x] + 1，此时左半边的总数即为高于射线y=S[x] + 1的蓝点个数。

取第7个点，这个点是红点，如果X在这里，则它的总数就是如图所示的一条折线上蓝点的个数。

![](https://cdn.luogu.com.cn/upload/pic/27378.png)

为了方便，在对待第X个点时，我们将X左边的每一个点降一个单位的高度（即满足i<x的Si减一）。此时折线就变成了如下的一条直线。

![](https://cdn.luogu.com.cn/upload/pic/27381.png)

然后统计>S[x]的蓝色点数即可。

直接求一个位置X为O(n)，总复杂度为O(n^2)，效率低下。可以利用前缀和优化至O(1)的复杂度。

先预处理每个y=i的蓝点数目，记作G[i]，再处理G[i]的前缀和，即H[i] = H[i+1] + G[i]，此时H[i]为>=S[i]的蓝点数量。在不修改点高度时，解即为H[S[x]+1]（去掉正好等于S[x]的解）。如果修改高度，从左往右处理每一个点，如果这个点是B，直接求答案。如果是A，S[i]将会减一，所以H[i]会减一。而其他的H将不会受到影响（想想看）。

并且题目说对于不同位置的X，一定有不同的总数（具体原因不再赘述）。

所以，这题就可以解决了。

主要代码（伪代码）：
```
for i = 1 -> n
	if (p[i] = 1) H[s[i]]--; //修改H即可，不必要修改s
	else if (H[s[i] + 1] = S) ans = i, break; //找到唯一解，退出程序
//大家都是dalao，就不放原代码了
```
预处理前面说的很详细，不放代码了。

此时总时间复杂度可以降到O(n)。