## 题目描述
有 $4$ 个栈，一开始有 $n$ 个数从小到大在 $4$ 号栈内，从顶至下分别是 $1,2,3,\cdots,n$，要求你将 $4$ 号栈里的 $n$ 个数通过一些规则移到 $1$ 号栈内，每一步可以将一个里面有数字的栈里的栈顶元素移到其他三个栈里面，**但是这个元素不能大于被移栈的栈顶，除非被移栈为空**，求最少步数。
## 分析
题目描述里加粗字体提示我们这是这一题解题的关键，栈的性质就是先进后出，也就是自顶向下取元素，那么，从上往下拿，小的叠在大的上面，我们想到了什么呢？对，汉诺塔！

一般的汉诺塔都是 $3$ 座塔的，但题目中有 $4$ 个栈，也就是 $4$ 座塔。我们可以手玩 $n \le 10$，不难发现当 $n$ 分别为 $1$ 至 $10$ 时，答案分别为 

```1 3 5 9 13 17 25 33 41 49```

设第 $i$ 步需要的步数为 $f_i$，我们求出它的差分数组 $b$，也就是 

```1 2 2 4 4 4 8 8 8 8```

其中 $f_0=0$，$b_i=f_i-f_{i-1}$，不难发现，$2^j$ 出现了 $j+1$ 次，为了验证答案，我们也可以将这个数列丢进 [OEIS](http://oeis.org/)，以下是作者的查找记录：[记录](http://oeis.org/search?q=1+3+5+9+13+17+25+33+41+49&language=english&go=Search)。
## 代码
知道了思路后，代码就很好写了，唯一需要注意的是要每步取模，以及要开 ```long long``` 。
```cpp
#include<bits/stdc++.h>

using namespace std;

long long n,cnt=1,res=1,ans;//cnt为有几项连续的res，res表示前一项与后一项的差，ans为最终答案。 
int main() {
	cin>>n;
	for(;cnt<=n;cnt++,res=res*2%1000007) n-=cnt,ans=(ans+cnt*res)%1000007;
	cout<<(ans+n*res)%1000007;//由于可能有剩余的数，所以最后要加上。 
    return 0;
}
```
