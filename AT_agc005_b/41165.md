~~看到这道题的第一反应是线段树~~

然而小蒟蒻只会粘板 洋洋洒洒的代码实在是望而生畏

在Atcoder上浪了一波 看到tourist巨佬的程序 昨天晚上脑子有点挂机 没怎么看懂 今天早上爬起来看 实在是妙啊 不愧是巨佬



------------

首先有一个巧妙的转化思想

就是枚举区间找最小值的复杂度很高 但我们可以去找每一个元素的“贡献区间”  而且这种关系是一一对应的 即是没有两个元素 对应同一个区间

后面的找区间和统计答案等细节就在程序里面的注释里了

统计区间个数这个可以琢磨一下，有点组合的意味，求到了“最大影响区间”之后，相当于确定了左右端点的最值，还要包含当前这个元素，左右端点就可以分别在当前元素的左边和右边滑呀滑。

```cpp
#include<cstdio>
#define MAXN 200005
#define LL long long
int n,a[MAXN],pos[MAXN],pr[MAXN],ne[MAXN];
LL ans;
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&a[i]);
		pos[a[i]]=i;
	}
	for(int i=0;i<=n+1;i++)
		pr[i]=i-1,ne[i]=i+1;//pr是i的影响区间的左端点(不含) ne是右端点(不含) 注意是不含！！！
	for(int i=n;i>=1;i--)//n的排列 倒着来
	{
		int j=pos[i];
		ans+=1LL*i*(j-pr[j])*(ne[j]-j);//统计区间个数时要注意端点时不含的
		pr[ne[j]]=pr[j];
		ne[pr[j]]=ne[j];
		//核心 用当前这个值依次更新其它数的影响区间 很巧妙
		//由于是倒着来的，那么如果被更新的值要大于当前数，则没有影响，因为被更新的贡献已经算完了
		//所以就假设这些数都小于当前数 而当前数的影响区间内的所有数都要大于它自己，也大于被更新数，所以可以更新区间
	}
	printf("%lld\n",ans);
}
```