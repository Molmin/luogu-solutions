# **UPD on 2021-12-03：修改了部分变量名和一些细节并进行重新提交**

**前排：由于考场电脑太拉，误判了复杂度，导致本来能AC的题让我加了个剪枝，100->70，估计这波是要省二AFO了**

这题......个人感觉想要AC挺不容易的，可以评个绿（也可能是我太蒻了？）

直接考虑正解（打表的话，我们队有个50分的，据说还有个老哥打表打了18G？）：

设 $N=1e7$ 

首先考虑数位里带7的数：直接扫一遍判断即可：复杂度 ${O(N(sizeofnumber))}$ ，位数最大是 $7$ ，可以看作常数。

接下来，去标记掉以这些数为因数的数。
直接一个一个膜之类的暴力判断肯定是不行的，对于这种依靠因数的筛数（实际上算是筛数），可以想到埃氏筛。笔者接下来的做法可以看作是埃氏筛的一种变形：

话都说到这里了，不少人脑子里估计码已经出来了：双重循环，外层的$i$查数，如果$i$没被标记就进二重循环，设一个 $j$ 从 $2$ 开始每次加1，把 ${i \times j}$ 标记出来，边界是 ${i \times j  \le N}$ 。

这里，笔者再加一些小优化：

建立一个数组（最好不要用vector），在第一轮标记带 $7$ 的数的时候把标记的数顺便存进去；之后，外层循环的 $i$ 改为从 $1$ 开始的该数组的下标，相应的，标记的数是 $j$ 与那个数组中下标为 $i$ 的数的乘积；再建一个bool数组，标记数的时候同时在这个新数组中进行标记；外层循环如果下标为 $i$ 的数在新数组中被标记，直接跳过。

以上优化经笔者测试，在代码其他部分（详见最后）相同的情况下，洛谷的民间数据在C++14 O2下可以 4.63s->2.99s（官方数据6.27s->3.68s）。

这一部分的时间复杂度小于 $O(N {\log} N+N)$ （证明许多神犇已给出，故此处略去）， $1e7$ 跑进1s没问题。

接下来考虑处理查询：

很容易想出这样的算法：对于询问的合法性，直接看标记；若合法，二分查找第一个合法的最大值。

这种写法时间复杂度最坏是接近 ${O(T {\log} N)}$ 的，加上前面的预处理，想不炸都难。（实际上因为被标记为不合法的数占大多数加上常数较低，这种写法可以通过。）

实际上，$O(N {\log} N)$ 复杂度对于 $1e7$ 来说已经比较吃力，再加上常数等因素，应该会想到：单个查询需要 $O(1)$ 处理才能过。

笔者这里的写法有一点贪心的思想，下面直接放：


首先建立一个查询表，然后从表的尾部开始遍历

维护“前一个合法的数”，初始为 $1e7+1$ ；

若当前的数不合法，直接在查询表当前数的下标中存入-1；否则，存入“前一个合法的数”，并将它改为当前数。

正确性显然，故证明略去。

算上前面的预处理，总时间复杂度大概略小于 ${O(N+N {\log} N+T)}$ （预处理进行了剪枝），理论上可以通过（反正洛谷民间数据过了（UPD：官方数据也过了），考场上我查询写了二分导致错判复杂度然后......）

[洛谷上的官方数据AC](https://www.luogu.com.cn/record/64170498)

贴上代码（非考场代码，freopen是为了测试）：
```cpp
#include<bits/stdc++.h>
#define LL long long
#define N 10000000+1000
using namespace std;
LL ccfNB,cnta,cntb,idx=N-999;
bool ccfTQL[N],ccfORZ[N];
LL ans[N],ccfSTO[N];
inline LL qread()
{
    LL a=0,f=1;char ch=getchar();
    while(ch<'0' || ch>'9') {if(ch=='-') f*=-1;ch=getchar();}
    while(ch>='0' && ch<='9') {a=a*10+ch-'0';ch=getchar();}
    return a*f;
}
inline void CCFNB(LL x)
{
    char w[128];LL cnt=0;
    if(x<0) putchar('-'),x*=-1;
    while(x) {w[cnt++]=(x%10)+'0';x/=10;}
    while(cnt--) putchar(w[cnt]);putchar('\n');
}
int main()
{
    freopen("number4.in","r",stdin);freopen("number.ans","w",stdout);
    for(LL i=1;i<=N-1;i++)
    {
        LL tmp=i;
        while(tmp){if(tmp%10==7) {ccfTQL[i]=1,ccfSTO[++cnta]=i;break;}tmp/=10;}
    }
    for(LL i=1;i<=cnta;i++) if(!ccfORZ[ccfSTO[i]])
    {
        for(LL j=2;j*ccfSTO[i]<=N-1;j++) ccfTQL[ccfSTO[i]*j]=1,ccfORZ[ccfSTO[i]*j]=1;
    }
    for(auto i=N-1000;i>=1;i--)
    {
        if(ccfTQL[i]) ans[i]=-1;
        else ans[i]=idx,idx=i;
    }
    ccfNB=qread();
    while(ccfNB--) CCFNB(ans[qread()]);
    return 0;
}
```

这道题最大的“坑点”笔者感觉不在于筛数，而是查询。

笔者认为，这道题极好地考察了选手“以空间换时间”的能力，评个绿......应该不过分吧？（然后评黄了......可能只是笔者太菜了而已）