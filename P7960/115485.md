# 0 前言

我是真的没想到我这么水一个成绩还能鬼混进 NOIP，怕不是某组织见我们学校那么弱，多给了几个名额（雾

这篇题解是建立在考场上四个样例全过和你谷民间数据 $\text{100pts}$ 的基础上写的，~~100%高质量。~~

如有发现错误请在讨论区指出，万分感谢！

# 1 简化题意

虽然题面算是比较清晰的，不过我还是写一下简化后的题意：

$T$ 组数据 $(1<T\le2\times10^5)$，每组数据占一行，包括一个正整数 $x(1\le x\le10^7)$，你需要输出一行一个整数。

- 假设正整数 $n$ 不能被任何一个数位中带 $7$ 的数整除，我们就称数 $n$ 为合法的数。注意，由此定义可得，如果 $n$ 的数位中本身含有 $7$，$n$ 也是不合法的。所有合法的数可以组成一个单调递增序列 $\{S_i\}(i\ge1)$。例如，$S_1=1$，$S_2=2$。

- 如果 $x$ 是合法的数，就输出 $x$ 的下一个合法的数（即如果 $S_i=x$，就输出 $S_{i+1}$）。如果 $x$ 不合法，则输出 $-1$。

# 2 题目分析

由题可知，所有合法的数都在 $10^7$ 之内，考虑筛法。

可以用和**埃氏筛**相似的思路：从 $1$ 开始枚举正整数，如果该正整数的数位中含有 $7$，就将它的所有在数据范围内的倍数都打上不合法标记，一直到 $10^7$ 枚举结束。

正确性的证明（如果知道埃氏筛的原理可以跳过不看）：

反证法。假设用这种方法筛完所有数后仍有不合法的数没被筛出，记这个数为 $a$。那么根据定义，它一定至少有一个因子是不合法的数，记这个因子为 $b$。这样的话，$b$ 肯定也没被筛出，因为算法没有通过 $b$ 去筛掉 $a$（而算法本应该这样做）。所以 $b$ 肯定也至少有一个因子是不合法的数，而这个因子没有被筛掉。就这样一层层往前推，就推到了一开始枚举到的一个不合法的数 $c$，它没被筛掉导致了后面一连串的数没被筛掉。而算法每枚举到一个数都会判断它数位中是否含有 $7$，不存在漏判的现象，于是这个与前面没筛出的 $c$ 矛盾，从而证明了算法的正确性。

判断一个数的数位中是否含有 $7$，可以利用除十法逐位判断。另外提一个优化的细节：筛出所有合法的数后，没必要在输入 $x$ 之后一个个枚举 $x$ 后面的数判断是否合法，可以将所有合法的数放进一个有序数组 $S$，再利用**映射**的思想去将数和在数组中的下标对应，有数就能求出下标，有下标就能求出数。具体地讲，对于每个 $S_i$，可以利用另一个数组 $A$，使 $A_{S_i}=i$。这样，对于一个给定的合法数 $x$，可以直接找到 $x$ 在 $S$ 中的下标为 $A_x$。就这样，可以在 $O(1)$ 的时间内得出 $S_{A_x+1}$ 就是答案。

时间复杂度基本与埃氏筛相似，具体实现细节参见代码。

# 3 代码实现

```cpp
#include<iostream>
#include<cstdio>
using namespace std;

const int maxN=1e7+5;
int t,n,tot,Safenum[maxN],Numsafe[maxN];//映射
bool Ill[maxN];//筛表

bool judge(int x){//判断数位中是否含有7
	while(x){
		if(x%10==7) return true;
		x/=10;
	}
	return false;
}

void GetSafeNum(){//筛出所有合法的数
	for(int i=1;i<maxN;i++){
		if(judge(i)) for(int j=1;j*i<maxN;j++) Ill[j*i]=1;
		if(!Ill[i]){
			tot++;//tot就是当前筛出的合法的数的个数
			Safenum[tot]=i,Numsafe[i]=tot;
		}
	}
}

int main(){
	ios::sync_with_stdio(false);
	GetSafeNum();
	cin>>t;
	while(t--){
		cin>>n;
		if(!Numsafe[n]) cout<<-1;
		else cout<<Safenum[Numsafe[n]+1];
		if(t) cout<<endl;
	}
	return 0;
}
```