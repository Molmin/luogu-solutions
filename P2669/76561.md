下面介绍一种数学方法。

我们把第1天分成一组，第2和第3天分成二组，第4，5，6天分成三组，...，以此类推。

画一个图帮助理解：
```
组数：						金币数：
1						     1             //第1组
2，3						  3，5          //第2组
4，5，6                       8，11，14     //第3组
7，8，9，10                   18，22，26，30//第4组
...                           ...
```
不难看出，第n组最后一天金币数为：1^2+2^2+3^2+...+n^2。可以写一段代码，如果输入的K恰好是第n组的最后一天，就可以直接算出值并输出。

如果输入的K不是第n组的最后一天，那就只能算出n的值。不过，我们不存储n的值，而存储n-1的值，原因待会儿说。

上面的思路，我用了这样一段代码实现：
```cpp
for(i=1;;i++)
{
        sum+=i;                 //累加天数
        ans+=i*i;               //计算金币数
        if(sum==k)              //如果恰好是第i组的最后一天
        {
           printf("%d\n",ans);  //就输出
           return 0;            //然后直接结束
        }
        if(sum>k) {t=i-1;break;}//如果K不是第i组的最后一天，就算出i-1的值存在t中
}
```
接下来主要解决K不是第n组最后一天的情况，我们已经求出了n-1的值，可以这样思考，先算出K是第n组的哪一天，假设是第d天吧，可以求到第n组第1天到第d天的金币数，再求出第1组到第n-1组的金币数，两者相加，就是正确答案。

我们可以这么实现：
```cpp
	ans=0;            //一定记住将ans清零
    for(i=1;i<=t;i++) 
        ans+=i*i;     //求出第1组到第n-1组的金币数
    d=k-sum+t+1;      //求得d的值
    ans+=d*(t+1);	  //d*(t+1)表示第n组第1天到第d天的金币数,将两值相加
```

最后输出就行了。

完整的代码如下：
```cpp
#include<cstdio>
int main()
{
    int k,sum=0,ans=0,t,d,i;
    scanf("%d",&k);
    for(i=1;;i++)
    {
        sum+=i;
        ans+=i*i;
        if(sum==k)
        {
           printf("%d\n",ans);
           return 0;
        }
        if(sum>k) {t=i-1;break;}
    }
    ans=0;
    for(i=1;i<=t;i++)
        ans+=i*i;
    d=k-sum+t+1;
    ans+=d*(t+1);
    printf("%d\n",ans);
    return 0;
}

```