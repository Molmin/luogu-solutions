如果有一个点能看到各个顶点，那么这个点的上下左右一定要对应四个$RR$。

如果有$OO$，那么这两个$270$°的角**延伸出去**的角的可视范围没有交集，即它们不能被同时被看到（点$A$能看到点$B$，那么点$B$也能看到点$A$。反之$B$一定不能看到点$A$），如下图所示：（延伸出去的角可能是$R$也可能是$O$，这里以$R$为例）
![](https://img.hzao.top/data/UVA1073_OO.png)


所以一定不能有$OO$。

如果没有$OO$，但是有$OR$。那么$OR$前面一个字符一定是$R$。（否则就有$OO$了）。这$O,R$两个角的可视范围是有交集的。如下图所示：
![](https://img.hzao.top/data/UVA1073_OR.png)

同样地，相邻的$RR$两角的可视范围也是有交集的。至少它们两个角是可以被同时看到的。

如果一个点能看到所有内角，那么它的正对的上下左右一定都是$RR$。因为如果某个方向是$RR$，显然成立。如果某个方向上的角度序列有$OR$，那么这个方向的角度序列只能是$OROROR...ORR$。即只能以$RR$结尾。（如果一直不结尾，那就不构成多边形。如果以$OO$结尾，那么不合法）。

既然以$RR$结尾，那么能同时看到这个$RR$的点一定在如图所示的灰色区域。


![](https://img.hzao.top/data/UVA1073_ORR.png)



反过来说，一个点的正对的上下左右四个方向一定是$RR$。

**稍加思考可以发现，只要满足上下左右四个方法有$RR$，且整个序列没有$OO$，那么一定满足条件。(没有$OO$意味着不会往外拐)**




$L$个内角代表$L$条边，根据多边形内角和公式：
$90R+270O=(L-2)* 180.$

又因为$R+O=L.$

所以有$R=(L+4)/2,O=(L-4)/2.$

所以我们要求的就是$(L+4)/2$个$R$和$(L-4)/2$个$R$的字符串中，有至少四个$RR$且没有$OO$的个数。注意$L<4$或者$L$为奇数时无解。（为奇数时的内角和不为$180$°的整数倍）

前两个实现方法参考《算法竞赛入门经典：训练指南》:

**方法一：**

用$f(i,j,b,e)$表示有$i$个$R$，$j$个$O$，开头为$b$（$0$表示$R$，$1$表示$O$），结尾为$e$。

则$f(x,0,0,0)=f(0,1,1,1)=1,x > 0.$

且$f(i,j,b,0)=f(i-1,j,b,1)+f(i-1,j,b,0).$

$f(i,j,b,1)=f(i,j-1,b,0).$（不能出现$OO$）

答案就很显然了（把几个$f(i,j,b,e)$加起来），你可以自行推一推或者见代码。

递归加上记忆化即可$O(n)$解决。（直接递推则需$O(n^2)$）

代码：
```cpp
#include<cstdio>
#include<cstring>
int L,kase;
long long d[520][520][2][2];
long long f(int i,int j,int b,int e){
    if(~d[i][j][b][e]){
        return d[i][j][b][e];
    }
    if(!j){
        return i&&!b&&!e;
    }
    if(!i){
        return j==1&&b==1&&e==1;
    }
    if(e){
        return d[i][j][b][e]=f(i,j-1,b,0);
    }
    else{
        return d[i][j][b][e]=f(i-1,j,b,0)+f(i-1,j,b,1);
    }
}
int main(){
    memset(d,-1,sizeof(d));
    long long ans;
    while(~scanf("%d",&L)&&L){
        ans=0;
        if(!(L&1||L<4)){
            ans+=f((L+4)/2,(L-4)/2,0,0);
            ans+=f((L+4)/2,(L-4)/2,1,0);
            ans+=f((L+4)/2,(L-4)/2,0,1);
        }
        printf("Case %d: %lld\n",++kase,ans);
    }
    return 0;
}
```


**方法二：**

$d(i,j,k)$表示以$k$开头，有$i$个$R$，有$j$对相邻的$R$（$RRR$算两对，$ROR$算$0$对），且以$R$结尾的方案数。

则$d(1,0,0)=d(1,0,1)=1.$

其余$d(i,j,k)=d(i-1,j,k)+d(i-1,j-1,k)$.表示当前字符串可由某个$R$结尾的字符加上$OR$或$R$来得到。

设$A=(L+4)/2$。


答案是$d(A,4,1)+d(A,3,0)+d(A,4,0).$

第一项表示$O$开头$R$结尾。

第二项表示$R$开头$R$结尾。求的是字符串中只有$3$对$RR$。但是把开头和结尾这一对算上就有$4$对了。

第三项很难理解，它表示$R$开头$O$结尾。每一个$R$开头$O$结尾的合法字符串都对应一个把最后一个$O$去掉之后的，$R$开头$R$结尾的字符串。因为最后一个字符是$O$，不能和前面的$R$接在一起，所以需要保证前面就有$4$个$R$。

也就是说把$4$个$RR$对的$R$开头$R$结尾的字符串后面加上一个$O$就可以得到$4$个$RR$对的$R$开头$O$结尾的字符串。

代码：


```cpp
#include<cstdio>
#include<cstring>
int L,kase;
long long d[520][520][2];
long long f(int i,int j,int k){
    if(i==1){
        return !j;
    }
    if(~d[i][j][k])return d[i][j][k];
    return d[i][j][k]=f(i-1,j,k)+f(i-1,j-1,k);
}
int main(){
    memset(d,-1,sizeof(d));
    while(~scanf("%d",&L)&&L){
        if(L&1||L<4){
            printf("Case %d: 0\n",++kase);
            continue;
        }
        printf("Case %d: %lld\n",++kase,
            f((L+4)/2,3,0)+//R...R
            f((L+4)/2,4,1)+//O...R
            f((L+4)/2,4,0)  //R...O
        );
    }
    return 0;
}
```


**方法三：**（参考了[KobeDuu的博客](https://blog.csdn.net/qq_41157137/article/details/89309235)）

组合计数。

其实可以发现，只要有$A=(L+4)/2$个$R$，$B=(L-4)/2$个$O$(其实$B=A-4$)，并且$OO$不相连，那么一定可以保证有4个$RR$对。

可以这样想：把$A \ge 4$个$R$连成一个环，那么有$A$个$RR$对。

再把$B=A-4$个$O$插入，每插入一个$O$，就会少一个$RR$对。

所以最后剩下$A-B=4$个$RR$对。刚好满足条件。

所以可以这样利用组合数算,把所有$RR$排成一行之后：

$1.$在开头放$O$

那么，最后一个位置不能放$O$。剩下$A-1$个位置可以放，要放下$B-1$个$O$。

计数$C_{A-1}^{B-1}$
![](https://img.hzao.top/data/O_on_first.png)

$2.$不在开头放$O$

那么剩下$A$个位置可以放$B$个$O$。
计数$C_{A}^{B}.$

所以答案为$C_{A-1}^{B-1}+C_{A}^{B}.$

代码太简单就略了吧。

[祝AC。](https://blog.hzao.top/)