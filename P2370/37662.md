**思想：贪心+背包**

~~这是我们编程班里有个人用排序过背包题给予我的灵感~~

看到大佬都用什么二分，我太菜了

首先，可以从题意看出，文件肯定是一份一份的，于是先确定是01背包

**01（所有）背包公式：dp[j]=max(dp[j],dp[j-v[i]]+w[i])（v[i]为当前第i件物品的重量，w[i]为当前第i件物品的价值）**

再由题意可知，要求总价值不小于p且最优，所以我们考虑贪心思想
，从小到大排，这样就可以直接在装背包这个循环里直接完成输出了

最后，如果都没有满足>=p的情况，输出无解

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int main() {
	int n,p,t,v[100001],w[100001],dp[100001];// n, p, t 分别表示 文件总数， 希望最小价值p，硬盘大小
	cin>>n>>p>>t; //输入文件总数，希望最小价值及硬盘大小 
	for(int i=1;i<=n;i++) cin>>v[i]>>w[i]; //输入第i个文件的大小及价值 
	for(int i=1;i<n;i++) { 
	for(int j=i+1;j<=n;j++) {
		if(v[i]>v[j]) //排序，判断大小，然后两个一起换，小的放前面，大的放后 
		{
			swap(v[i],v[j]);
			swap(w[i],w[j]);
		}
	}
	}
	//全题核心 
	for(int i=1;i<=n;i++) {//背包 
		for(int j=t;j>=v[i];j--) {
			dp[j]=max(dp[j],dp[j-v[i]]+w[i]);//方程 
			if(dp[t]>=p) { //如果当前的期望值已经大于p了，那么直接输出（前面排过序了，所以不需要考虑后面可能还会有更优的情况） 
				cout<<v[i];//输出当前价值，结束 
				return 0;
			}
		}
	}
	cout<<"No Solution!";//如果所有的期望值都没有超过最小期望值，那么输出无解 
	return 0;
}
```
