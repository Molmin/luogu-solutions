- [类题](https://www.luogu.com.cn/blog/luo1gu1zui1bang1/post-tu-lun-zui-xiao-ge)。

**题意**
- [链接](https://www.luogu.com.cn/problem/CF160D)。
- 给定一个无向连通图，判断它的每条边属于这三种情况的哪一种：在所有最小生成树上，在部分最小生成树上，不在任何最小生成树上。
- 点数 $n$ 和边数 $m$ 不大于 $10^5$。

**分析**
- 回想 $\text{Kruskal}$ 最小生成树算法：贪心加入最小的边，使之不成环。
- 我们可以获得一个极其平凡的判定不在任何生成树上的充分条件：若某条边在加入时已经连通，而且它的简单路径上不含任何等于该边权的边，那么它一定不在该生成树上。
- 容易证明它的必要性，如果存在一条边，把那条删掉然后换上这条，它也是最小生成树了。
- 那么接下来的问题在于如何确定某条边在所有最小生成树上，很容易想到类似的做法，如果我们在那个过程中找到了边，那么这条边本身和它所有的边一定只在部分最小生成树上。
- 那么可不可以用这个判定呢？我们回看 $\text{Kruskal}$ 算法，容易发现当小于某个值的所有边都被算入，图的连通性完全相同（因为相当于对一些不连通的子图跑最小生成树），如果我们尝试构造出一种反例就违反了它。
- 好啊，我们找到了一个很好的判断标准，但是它跑暴力会超时耶。
- 我们可以使用 [Link Cut Tree](https://www.luogu.com.cn/blog/luo1gu1zui1bang1/post-shuo-ju-jie-gou-dong-tai-shu-jie-gou)，可以暴力访问当前的最大值并打标记，时间复杂度 $O(m\log n)$。
- 当然这太奇葩了，为了这么个简单的东西你要写一个动态树结构，所以下一步我们探索实现细节。

**实现**
- 首先我们可以使用并查集完成不在任何最小生成树的点的判定，具体就是先把相同的边加一次（做到这一步，我们可以使用树链剖分+线段树完成接下来的操作）。
- 接下来问题在于如何判断是否一定在最小生成树上，容易发现，所有可行的边把连通块连成了这个样子。
![](https://cdn.luogu.com.cn/upload/image_hosting/1lc07zn6.png)
- 所以我们（并查集）缩点，然后使用 $\text{Tarjan}$ 找桥（注意没连过边的点不应该被加入否则复杂度会错），复杂度 $O(m\log n)$，瓶颈为排序。
- [代码实现](https://www.luogu.com.cn/paste/rlmup072)。