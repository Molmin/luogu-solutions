## 题意简述

有若干工件需要**依次**经历两道工序加工。每道工序各有若干台机器供使用，加工时间各不相同。求加工完这些工件所需的最短时间（挂钟时间）。

## 解题思路

假如只有一道工序，那是很容易的。就是贪心地加工每个零件，哪个机器加工完后的挂钟时间短就用哪个。

但是，有两道工序，那么完成工序 A 后，不好判断先加工谁，后加工谁。即我们不能通过直接依次模拟两道工序来得到答案。

那么，我们考虑分开进行两步的加工：即假设在 B 机器后面也有同样数量的工件（称为“新工件”）在等着，一个工件的工序 A 完成后，对应的新工件立即进入 B 机器。它们在中间“会合”，构成成品。考虑到这样做，工序 A、B 之间并无依赖关系，故我们可以**分别计算**每个工件经历两个工序的时间，且一个工件所用的时间，就是其两道工序的时间**之和**。

有人要问了：这样做与题意不一致，是否会改变答案呢？并不会。因为“新工件”进入 B 机器是在对应的工件已经完成 A 工序之后。并不会有一对“对应的”工件同时在两个机器里的情况。

## 代码

```cpp
#include <cstdio>
#include <algorithm>

int n, m1, m2, t, ans, a[35], b[35], t1[35], t2[35], f[1005];
// t1, t2 分别为两种机器加工完成后的挂钟时间

int main() {
    scanf("%d%d%d", &n, &m1, &m2);
    for(int i = 1; i <= m1; i++) scanf("%d", a+i);
    for(int i = 1; i <= m2; i++) scanf("%d", b+i);

    for(int i = 1; i <= n; i++) {
        for(int j = t = 1; j <= m1; j++)
            if(t1[j] + a[j] <= t1[t] + a[t]) t = j;
        f[i] = t1[t] += a[t];
    }
    printf("%d ", f[n]);

    for(int i = n; i; i--) {
        for(int j = t = 1; j <= m2; j++)
            if(t2[j] + b[j] <= t2[t] + b[t]) t = j;
        f[i] += t2[t] += b[t];
    }
    printf("%d\n", *std::max_element(f+1, f+n+1));

    return 0;
}
```