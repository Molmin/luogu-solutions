### Link.
[Codeforces](https://codeforces.com/problemset/problem/468/D)  
[Luogu](https://www.luogu.com.cn/problem/CF468D)  

### P.S.
看上去好清真啊，看上去好原题啊，看上去好清新啊，洛谷评分也就一个紫，点开难度。  
**woc \*3100**，就这还紫题？？？恐惧了恐惧了，爪巴了爪巴了。  
和 @[Krimson](https://www.luogu.com.cn/user/206998) 一起胡的一个做法。  

### Description.
有一棵树，无根边带权。  
一个排列的 $\{p_i\}$ 权值定义为 $\sum\text{dist}(i,p_i)$。  
求权值最大值，以及取到这个最大值的最小排列。  

### Solution.
首先，最大值显然是 `ATcoder` 原题，肯定是每条边达到 $\max\{sz_u,sz_v\}$。  
然后第一问就做完了，证明就考虑取重心，然后反复横跳（AT 肯定是有原题的。  

第二问考虑同样取重心，把树划分成了若干棵子树（重心本身可以当作一棵方便处理  
考虑转化一下，定义一个树的入度表示这个树还没被匹配的点，出度表示这个树需要匹配的点。  
那能匹配的方案肯定满足每个点都可以匹配，也就是其他点的入度大于当前点的出度。  
我们维护 $d_i$ 表示 其他点的入度减当前点的出度。  
每次匹配相当于对匹配子树和被匹配子树的 $d_i$ 不变，其他全局减一。  
要求减完后不出现 $-1$。  

考虑如果出现了一个 $d_i=0$，那肯定需要直接匹配这两个。  
但是全局同一时间肯定仅可能有两个 $d_i=0$，且如果有两个肯定其他已经匹配完了。  

然后每次如果有除了当前子树外的 $d_i=0$，那只能匹配目标。  
否则就贪心匹配全局最小值，这样肯定不会让 $d_i$ 变成负数。  

至于全局 $-1$ 直接维护一个 tag 就行了。  

注意特判重心，因为重心可以和自己匹配，不需要满足 $d_i\ge 0$ 的限制。  

### Coding.
过于压行已被消除
