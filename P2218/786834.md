#### 这道题考察算法的综合运用。
**首先，我们思考如何快速地找到答案。** 由于一定存在整数 $n$ 使任何长度不小于 $n$ 的正方形满足要求（就是题目中的 $L$），所以可以采用二分（$2×10^9$ 的范围，大约 $30$ 次循环），并进行覆盖方案搜索的方式得到 $L$，这是和其它题解类似的。

不过，在思考如何搜索时，我想到了循环嵌套。不用 dfs，是因为这道题搜索的维度是固定不变的 $3$ 层，且每层的任务可以略有不同：
- 第一层：在**所有点**中找寻覆盖方案；
- 第二层：在**剩余点**中找寻覆盖方案（与第一层的不同在于本层需要判断点是否被覆盖）；
- 第三层：通过 X,Y 坐标极值作差判断是否可以覆盖（**无需搜索**）。

**其实将题目划分成这几层后，你就会很快发现，第三层的实现很简单，重点在于前两层算法的实现。** 由于点有固定的坐标，因此从二维数组的角度而言，这些点中**一定存在**一个固定最上点（Y 坐标最小）、最下点（Y 坐标最大）、最左点（X 坐标最小）与最右点（X 坐标最大），共计 $4$ 个极限位置。然而，正方形只有 $3$ 个，所以必有一个正方形要盖住 $4$ 个点中的 $2$ 个（当剩余正方形数减少时也如此），因此可以考虑让正方形的顶点 X 坐标为最左点或最右点的 X 坐标，而 Y 坐标等同于最上点或最下点，这样理论上就可以把 $2$ 个极限点盖住（**在未找到答案的情况下，此处每种 X,Y 坐标都要尝试，且前两层都要这样判断。** 共循环 $(2×2)^2=16$ 次，连同二分时时间复杂度循环常数约为 $500$）。

看到这里，细心的你可能要问了：假设目前正在最上、下点的 Y 坐标差或是最左、右点的 X 坐标差正好为现在正在搜索的 $L$，那不就可以考虑盖住这两个点，而对其它极限点姑且撒手不管了吗？其实，这样做并不是最优方案。如果一个正方形只盖住上、下或左、右的点，在这个正方形旁就可能有两处“留白”，且它们距离较大，需要浪费至少 $2$ 个正方形来覆盖。而如果同时兼顾上下和左右，就可以尽量少“留白”（即使有 $2$ 处，它们的距离也很小，比较容易覆盖），少“浪费”正方形。

**有了这些思考，这题差不多在 $O(500n)$ 的复杂度里就能迎刃而解了。** 不过如果用这个思路写代码，有些变量得**开 `long long`**，因为在计算时（**不一定是真的正方形**），正方形某个角的坐标的绝对值是有达到 $10^9+2×10^9=3×10^9$ 的。
```cpp
#include<bits/stdc++.h>
#define lld long long
using namespace std;
lld n,x[20000],y[20000],t[20000];//t[i] 表示 i 点被覆盖次数
void Plus(lld a,lld b,lld c,lld d,lld e){for(lld i=0;i<n;i++)if(x[i]>=a&&x[i]<=b&&y[i]>=c&&y[i]<=d)t[i]+=e;}
//为在范围内的所有点更改覆盖次数
//函数名不能用 plus，否则可能报错
void find_min_max(lld&a,lld&b,lld&c,lld&d){
	a=c=2e9,b=d=-2e9;
	for(lld i=0;i<n;i++)if(!t[i])
		a=min(a,x[i]),b=max(b,x[i]),c=min(c,y[i]),d=max(d,y[i]);
}//查找未覆盖点中的极限 X,Y 坐标
int main(){
	scanf("%lld",&n);
	for(lld i=0;i<n;i++)scanf("%lld%lld",x+i,y+i);
	lld m,s=0,t=2e9;
	while(s<t){
		lld a=x[0],b=a,c=y[0],d=c,aa,bb,cc,dd,aaa,bbb,ccc,ddd;bool f=1;//a,b,c,d 为第一层正方形覆盖前的极值，后面的变量以此类推；f=0 表示覆盖成功
		for(lld i=1;i<n;i++)
			a=min(a,x[i]),b=max(b,x[i]),c=min(c,y[i]),d=max(d,y[i]);//找极值，由于暂未标记覆盖，为省时，暂不用上面的函数
		lld p1[4][4]={{a,a+(m=s+t>>1),c,c+m},{a,a+m,d-m,d},{b-m,b,c,c+m},{b-m,b,d-m,d}};//查找正方形覆盖左上、左下、右上、右下角时的边角 X,Y 坐标
		for(lld i=0;f&&i<4;i++){
			Plus(p1[i][0],p1[i][1],p1[i][2],p1[i][3],1);
			find_min_max(aa,bb,cc,dd);//第二层
			lld p2[4][4]={{aa,aa+m,cc,cc+m},{aa,aa+m,dd-m,dd},{bb-m,bb,cc,cc+m},{bb-m,bb,dd-m,dd}};
			for(lld j=0;f&&j<4;j++){
				Plus(p2[j][0],p2[j][1],p2[j][2],p2[j][3],1);
				find_min_max(aaa,bbb,ccc,ddd);//第三层
				if(bbb-aaa<=m&&ddd-ccc<=m)f=0;//此时只要进行极差分析
				Plus(p2[j][0],p2[j][1],p2[j][2],p2[j][3],-1);
			}
			Plus(p1[i][0],p1[i][1],p1[i][2],p1[i][3],-1);
		}
		if(f)s=m+1;
		else t=m;
	}
	printf("%lld",t);
}
```
这是我在洛谷第一次提交题解，可能还有一些不足。如果你在阅读时遇到了问题，欢迎指出！