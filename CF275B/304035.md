看着这题没有题解着实有那么点难受，为了给来做这道题目的萌（cai）新（ji）一点提醒，正义的我来写题解了！

首先，我们要看的是黑色的方块，所以为了判定的时候不至于再找一遍黑方块，输入的时候就单独把黑方块的xy坐标全部单独记录在一个坐标数组里

再往下看，对于任意的两个黑方块，它们的位置关系可以分成三种：

1.在同一行
2.在同一列
3.既不在同一行，也不在同一列

如果在同一行，这两个方块之间一定不能有白方块，否则就像题目里给出的第二幅图片一样要绕路，必须拐2次，同一列也一样。

如果是第三种情况，那么要走到那个位置至少要拐弯一次，那么只要判段走到那个位置的拐角是不是被白块给挡住了（不要问我为什么不判定路上有没有空位，程序能进行到那里就已经排除了路上没空位的事情）

讲了这么多，代码怎么实现呢？大概讲一下思路：输入每一行后，内部循环读出黑块的位置，注意单独用一个数来存储下标，然后从第一个黑块开始，测试这个黑块和它往后的所有黑块是否只需要拐弯一次，然后循环往复已知测试到倒数第二个黑块，如果不行直接在循环内部输出no后return，这样跳出循环后的一定是合法的，输出yes后return

该给出代码了：
```cpp
#include<bits/stdc++.h>
#define N 3000
#define LL long long
#define UNLL unsigned long long
using namespace std;
int n,m,x[N],y[N],cnt;
char s[N][N];
int main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		cin>>(s[i]+1);//让每行的纵坐标从1开始 
		for(int j=1;j<=m;j++){
			if(s[i][j]=='B'){
				x[++cnt]=i,y[cnt]=j;
			}//记录所有黑方块的坐标 
		}
	}
	for(int i=1;i<cnt;i++){
		int a=x[i],b=y[i];//记录第i个黑方块的坐标 
		for(int j=i+1;j<=cnt;j++){
			int c=x[j],d=y[j];//记录第j个黑方块的坐标 
			if(a==c){
				for(int k=min(b,d);k<=max(b,d);k++){
					if(s[a][k]=='W'){
						cout<<"NO";
						return 0;
					}
				}//如果在同一行，必须之间没有白方块挡路，否则绕路需要至少2次拐弯 
			}
			else if(b==d){
				for(int k=min(a,c);k<=max(a,c);k++){
					if(s[k][b]=='W'){
						cout<<"NO";
						return 0;
					}
				}//如果在同一列，必须之间没有白方块挡路，否则绕路需要至少2次拐弯 
			}
			else{
				if(s[a][d]=='W'&&s[c][b]=='W'){
					cout<<"NO";
					return 0;
				}//在满足前两个情况(能循环到这里说明其他在同一行和同一列的方块都活过去了)的情况下，只需要判断拐点的位置是白还是黑 
			}
		}
	}
	cout<<"YES";//走出循环，说明所有方块走到其他方块都至多需要1次拐弯，符合要求 
	return 0;
}
```
看了题解却发现没有的人，现在有福可以享了/偷笑