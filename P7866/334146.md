[题目](https://www.luogu.com.cn/problem/P7866)不难，直接模拟即可。

因为题目只有 2 副扑克牌，所以每种牌最多只有 2 张。

所以当比如点数 J 这种类型的牌有 6 张或以上时，肯定能组成 2 对小昕昕；

而当只有 3 张或者以上时就需要分类讨论了：如果有某种花色的 J 有2张，则肯定能组成 1 对小昕昕，否则无法组成 1 组小昕昕。

代码见下：
```cpp
// Problem: P7866 「EVOI-RD1」小昕昕
// From: Luogu
// Url: https://www.luogu.com.cn/problem/P7866?contestId=49613
// Interactive:false
// MemoryLimit: 128 MB
// TimeLimit: 1000 ms
//
//
// Powered by CP Editor (https://cpeditor.org)
#include <bits/stdc++.h>
using namespace std;
int s[6][16] = {0};//用来统计每张牌的个数
int num, ans = 0;
void input() {//将每张牌统计计入数组
  for (int i = 1; i <= num; i++) {
    string sum;
    cin >> sum;
    if ((sum[0] == 'S' && sum[1] == 'A') || (sum[0] == 'S' && sum[1] == '1'))
      s[1][1]++;                                     //黑桃1
    if (sum[0] == 'S' && sum[1] == '2') s[1][2]++;   //黑桃2
    if (sum[0] == 'S' && sum[1] == '3') s[1][3]++;   //黑桃3
    if (sum[0] == 'S' && sum[1] == '4') s[1][4]++;   //黑桃4
    if (sum[0] == 'S' && sum[1] == '5') s[1][5]++;   //黑桃5
    if (sum[0] == 'S' && sum[1] == '6') s[1][6]++;   //黑桃6
    if (sum[0] == 'S' && sum[1] == '7') s[1][7]++;   //黑桃7
    if (sum[0] == 'S' && sum[1] == '8') s[1][8]++;   //黑桃8
    if (sum[0] == 'S' && sum[1] == '9') s[1][9]++;   //黑桃9
    if (sum[0] == 'S' && sum[1] == 'T') s[1][10]++;  //黑桃10
    if (sum[0] == 'S' && sum[1] == 'J') s[1][11]++;  //黑桃J
    if (sum[0] == 'S' && sum[1] == 'Q') s[1][12]++;  //黑桃Q
    if (sum[0] == 'S' && sum[1] == 'K') s[1][13]++;  //黑桃K
    if ((sum[0] == 'H' && sum[1] == 'A') || (sum[0] == 'H' && sum[1] == '1'))
      s[2][1]++;                                     //红桃1
    if (sum[0] == 'H' && sum[1] == '2') s[2][2]++;   //红桃2
    if (sum[0] == 'H' && sum[1] == '3') s[2][3]++;   //红桃3
    if (sum[0] == 'H' && sum[1] == '4') s[2][4]++;   //红桃4
    if (sum[0] == 'H' && sum[1] == '5') s[2][5]++;   //红桃5
    if (sum[0] == 'H' && sum[1] == '6') s[2][6]++;   //红桃6
    if (sum[0] == 'H' && sum[1] == '7') s[2][7]++;   //红桃7
    if (sum[0] == 'H' && sum[1] == '8') s[2][8]++;   //红桃8
    if (sum[0] == 'H' && sum[1] == '9') s[2][9]++;   //红桃9
    if (sum[0] == 'H' && sum[1] == 'T') s[2][10]++;  //红桃10
    if (sum[0] == 'H' && sum[1] == 'J') s[2][11]++;  //红桃J
    if (sum[0] == 'H' && sum[1] == 'Q') s[2][12]++;  //红桃Q
    if (sum[0] == 'H' && sum[1] == 'K') s[2][13]++;  //红桃K
    if ((sum[0] == 'C' && sum[1] == 'A') || (sum[0] == 'C' && sum[1] == '1'))
      s[3][1]++;                                     //梅花1
    if (sum[0] == 'C' && sum[1] == '2') s[3][2]++;   //梅花2
    if (sum[0] == 'C' && sum[1] == '3') s[3][3]++;   //梅花3
    if (sum[0] == 'C' && sum[1] == '4') s[3][4]++;   //梅花4
    if (sum[0] == 'C' && sum[1] == '5') s[3][5]++;   //梅花5
    if (sum[0] == 'C' && sum[1] == '6') s[3][6]++;   //梅花6
    if (sum[0] == 'C' && sum[1] == '7') s[3][7]++;   //梅花7
    if (sum[0] == 'C' && sum[1] == '8') s[3][8]++;   //梅花8
    if (sum[0] == 'C' && sum[1] == '9') s[3][9]++;   //梅花9
    if (sum[0] == 'C' && sum[1] == 'T') s[3][10]++;  //梅花10
    if (sum[0] == 'C' && sum[1] == 'J') s[3][11]++;  //梅花J
    if (sum[0] == 'C' && sum[1] == 'Q') s[3][12]++;  //梅花Q
    if (sum[0] == 'C' && sum[1] == 'K') s[3][13]++;  //梅花K
    if ((sum[0] == 'D' && sum[1] == 'A') || (sum[0] == 'D' && sum[1] == '1'))
      s[4][1]++;                                     //方块1
    if (sum[0] == 'D' && sum[1] == '2') s[4][2]++;   //方块2
    if (sum[0] == 'D' && sum[1] == '3') s[4][3]++;   //方块3
    if (sum[0] == 'D' && sum[1] == '4') s[4][4]++;   //方块4
    if (sum[0] == 'D' && sum[1] == '5') s[4][5]++;   //方块5
    if (sum[0] == 'D' && sum[1] == '6') s[4][6]++;   //方块6
    if (sum[0] == 'D' && sum[1] == '7') s[4][7]++;   //方块7
    if (sum[0] == 'D' && sum[1] == '8') s[4][8]++;   //方块8
    if (sum[0] == 'D' && sum[1] == '9') s[4][9]++;   //方块9
    if (sum[0] == 'D' && sum[1] == 'T') s[4][10]++;  //方块10
    if (sum[0] == 'D' && sum[1] == 'J') s[4][11]++;  //方块J
    if (sum[0] == 'D' && sum[1] == 'Q') s[4][12]++;  //方块Q
    if (sum[0] == 'D' && sum[1] == 'K') s[4][13]++;  //方块K
  }
}
/*
void test() {
  for (int i = 1; i <= 4; i++) {
    for (int j = 1; j <= 13; j++) {
      cout << s[i][j] << " ";
    }
    cout << "\n";
  }
}
*/
void solve() {
  for (int i = 1; i <= 13; i++) {
    if (s[1][i] + s[2][i] + s[3][i] + s[4][i] >= 6)//该点数的牌不少于6张时肯定能组成 2 对小昕昕
      ans += 2;
    else {
      if (s[1][i] >= 2 && s[2][i] >= 1) {
        s[1][i] -= 2;
        s[2][i] -= 1;
        ans++;
      }
      if (s[1][i] >= 2 && s[3][i] >= 1) {
        s[1][i] -= 2;
        s[3][i] -= 1;
        ans++;
      }
      if (s[1][i] >= 2 && s[4][i] >= 1) {
        s[1][i] -= 2;
        s[4][i] -= 1;
        ans++;
      }
      if (s[2][i] >= 2 && s[3][i] >= 1) {
        s[2][i] -= 2;
        s[3][i] -= 1;
        ans++;
      }
      if (s[2][i] >= 2 && s[4][i] >= 1) {
        s[2][i] -= 2;
        s[4][i] -= 1;
        ans++;
      }
      if (s[3][i] >= 2 && s[4][i] >= 1) {
        s[3][i] -= 2;
        s[4][i] -= 1;
        ans++;
      }
      if (s[1][i] >= 1 && s[2][i] >= 2) {
        s[1][i] -= 1;
        s[2][i] -= 2;
        ans++;
      }
      if (s[1][i] >= 1 && s[3][i] >= 2) {
        s[1][i] -= 1;
        s[3][i] -= 2;
        ans++;
      }
      if (s[1][i] >= 1 && s[4][i] >= 2) {
        s[1][i] -= 1;
        s[4][i] -= 2;
        ans++;
      }
      if (s[2][i] >= 1 && s[3][i] >= 2) {
        s[2][i] -= 1;
        s[3][i] -= 2;
        ans++;
      }
      if (s[2][i] >= 1 && s[4][i] >= 2) {
        s[2][i] -= 1;
        s[4][i] -= 2;
        ans++;
      }
      if (s[3][i] == 1 && s[4][i] == 2) {
        s[3][i] -= 1;
        s[4][i] -= 2;
        ans++;
      }
    }
  }
}
int main() {
  ios::sync_with_stdio(false);//关闭同步流
  cin >> num;
  input();
  solve();
  cout << ans << "\n";
  return 0;
}
```
