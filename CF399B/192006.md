这个题一开始我把左右搞反了

结果考试0分

反过来就对了。。。。

-------
分割线

如果一个栈中最低端已经是红球就相当于不用处理栈底

假设一个栈中只有蓝球，会是多少步呢？

由打表可知：前5项为

1 3 7 15 31

有什么规律呢？
1 + 2 = 3
3 + 4 = 7
7 + 8 = 15
....

好了如果栈底是红球剩下的就是蓝球，而栈底无影响，现在这种情况我们知道了

可是。。。大多数不是这样

比如红红蓝红蓝红。。。。

这怎么办？？

我们尝试转换已知问题，发现红红...蓝只需要一步即可变为

蓝蓝...红

然后这样每次栈顶是蓝色用第一种方法解决，不是就花一步转换


```cpp
#include<bits/stdc++.h>

using namespace std;

long long n,a[1001];
char ch;
long long b[60] = {0,1,3,7,15,31,63,127,255,511,1023,2047,4095,8191,16383,32767,65535,131071,262143,524287,1048575,2097151,4194303,8388607,16777215,33554431,67108863,134217727,268435455,536870911,1073741823,2147483647,4294967295,8589934591,17179869183,34359738367,68719476735,137438953471,274877906943,549755813887,1099511627775,2199023255551,4398046511103,8796093022207,17592186044415,35184372088831,70368744177663,140737488355327,281474976710655,562949953421311,1125899906842623};
//long long c[60] = {0,1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,262144,524288,1048576,2097152,4194304,8388608,16777216,33554432,67108864,134217728,268435456,536870912,1073741824,2147483648,4294967296,8589934592,17179869184,34359738368,68719476736,137438953472,274877906944,549755813888,1099511627776,2199023255552,4398046511104,8796093022208,17592186044416,35184372088832,70368744177664,140737488355328,281474976710656,562949953421312};//打表(因为只有50的数据范围

int main() {
	cin>>n;
	/*
	string s;
	cin>>s;
	int len = s.length();
	for(int i = 0;i < len;++i){
		a[i + 1] = s[i] - 'B';
	}
	*/
	ch = getchar();
	while(ch < 'A' || ch > 'Z')//去掉多余字符
		ch = getchar();
	for(long long i = 1; i <= n; ++i) {
		a[i] = ch - 'B';
		ch = getchar();
	}//16为红0为蓝
	long long y = n,tot = 0,x = 0;
	x = 0;
	for(int i = n; i >= 1; --i) {//把栈顶连续蓝的转换成红的
		if(a[i] == 0) {
			x ++;
			a[i] = 16;
		} else {
			y = i;
			break;
		}
	}
	tot += b[x];
	for(int i = y; i > 0; --i) {//如果是蓝的，花一步转换为一直问题
		x++;
		if(a[i] == 0) {
			tot += b[x - 1] + 1;
		}
	}
	
	cout<<tot<<endl;

	return 0;
}

```
