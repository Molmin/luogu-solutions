[$MYCui's$ $blog$](https://www.cnblogs.com/MYCui/p/13947754.html#CF1443B)
### 前言：

本人这篇题解按照规范的DP思路走。

所以会讲得比较模式化，希望能够理解。

### 做法：

采用线性的$dp$的方法，时间复杂度O($n$)，额外空间复杂度O($2*n$)

首先是一个小小的贪心。

去掉给出的串的前缀的0以及后缀的0，因为我们不需要处理这些0.

然后$dp$进行处理

+ #### 设立状态

$dp[i][0]$(这个状态是对于第$i$位字符为$0$的时候特有的状态)表示到第$i$位，不把第$i$位上的$0$变成$1$进行处理，将前面的串全部变为$0$所需要的最少费用。

$dp[i][1]$表示的是将当前位变为$1$进行处理(假如是$1$就不需要变)，将前面的串变为$0$所需要的最小费用

+ #### 状态转移方程

分两种情况：

$Case1$:**当前字符为$1$**

分情况讨论：

假如前一个字符为$1$

$dp[i][1] = dp[i - 1][1];$

假如前一个字符为$0$

$dp[i][1] = min(dp[i - 1][0] + A,dp[i - 1][1])$

(因为如果前一个是$0$，不把它变为$1$，那么我们不能承接前面的情况，只能把当前的$1$作为接下来连续的$1$组成的串的开头，费用加上A。不然就可以接上前面的)

$Case2$：**当前字符为$0$**

$dp[i][1] = dp[i - 1][1] + B$

对于此种情况下对于$dp[i][0]$我们再结合当前字符的前一个字符进行分类讨论。

前一个字符为$1$，$dp[i][0] = dp[i - 1][1]$

否则$dp[i][0] = dp[i - 1][0]$(前一个字符变为$1$但是这个字符不变为$1$显然没有意义。)

状态转移方程到此结束。

+ #### 边界的设立
 $dp[start][1] = A$(这里是$start$是指第一个$1$出现的位置)
 
 最后的答案会是$dp[len][1]$(这里的$len$是最后一个$1$出现的位置)
 
 思路讲解到此结束。
 
#### Code
```cpp
#include <bits/stdc++.h>
using namespace std;
int T;
int A,B;
int dp[100005][2];
char s[100005];
int main()
{
	cin >> T;
	for(int v = 1 ; v <= T ; v ++)
	{
		cin >> A >> B;
		cin >> s + 1;
		int len = strlen(s + 1);
		int start = 1;
		while(s[start] == '0')start ++;
		while(s[len] == '0')len --;
		dp[start][1] = A;
		for(int i = start + 1 ; i <= len ; i ++)
		{
			dp[i][1] = dp[i][0] = 0;
            //状态转移，前文已经介绍的很清楚了，不再赘述
			if(s[i] == '1')
			{
				if(s[i - 1] == '1')
				dp[i][1] = dp[i - 1][1];
				else dp[i][1] = min(dp[i - 1][1] , dp[i - 1][0] + A);
			}
			else 
			{
				dp[i][1] = dp[i - 1][1] + B;
				if(s[i - 1] == '1')
				dp[i][0] = dp[i - 1][1];
				else dp[i][0] = dp[i - 1][0];
			}
		}
		cout << dp[len][1] << endl;
	}
	return 0;
}
```

#### 后话

这个做法一开始我没敢保证是对的，仔细想想感觉没有什么问题，然后Hack了自己几组数据，没有Hack成功，要是哪位仁兄Hack 掉了我，及时私信我，我会做出修改。