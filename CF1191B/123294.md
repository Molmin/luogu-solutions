因为本题的数据很小，所以模拟即可

观察题目，可以发现 要想凑成一个 $mentsu$，**那么它们末尾的字母一定是相同的**

所以，我们可以把题目给的 $3$ 个字符串排序，规则如下：

**优先字母从小到大排，字母相同数字从小到大排**

然后就可以愉快地模拟啦~

具体实现细节见代码

```cpp
#include<bits/stdc++.h>
using namespace std;
string a[3];
bool cmp(string a,string b){return a[1]<b[1]||a[1]==b[1]&&a[0]<b[0];}
//排序规则
int main()
{
	cin>>a[0]>>a[1]>>a[2];
	if(a[0]==a[1]&&a[1]==a[2])cout<<0,exit(0);
	//如果三个字符串相同，那么它们一定可以构成一个"mentsu"
	sort(a,a+3,cmp);//排序
	if(a[0][1]==a[1][1]&&a[1][1]==a[2][1]&&a[0][0]+1==a[1][0]&&a[1][0]+1==a[2][0])cout<<0,exit(0);
	//如果三个字符串字母相同，数字连续（已经排过序了）那么它们一定可以构成一个"mentsu"
	if(a[0][1]==a[1][1]&&a[0][0]+1==a[1][0])cout<<1,exit(0);
	if(a[1][1]==a[2][1]&&a[1][0]+1==a[2][0])cout<<1,exit(0);
	//如果有两个字符串字母相同，数字连续，那么就还要1个麻将才能凑出"mentsu"
	if(a[0][1]==a[1][1]&&a[0][0]+2==a[1][0])cout<<1,exit(0);
	if(a[1][1]==a[2][1]&&a[1][0]+2==a[2][0])cout<<1,exit(0);
	//如果有两个字符串字母相同，数字相隔1，那么也还要1个麻将才能凑出"mentsu"
	if(a[0]==a[1]||a[1]==a[2])cout<<1,exit(0);
	//如果有两个字符串相同，那么也还要1个麻将才能凑出"mentsu"
	cout<<2;//否则需要两个 
	return 0;
}
```
