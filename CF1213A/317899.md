性质一，当所有的数模 $2$ 的余数一样时，所需要的代价是 $0$。

原因：
- 当所有的 $x_i$ 模二余数为 $0$ 时，我们可以把所有的 $x_i$ 不停地向 $0$ 跳。此时因为 $x_i$ 模二余 $0$，所以它的绝对值模二也余 $0$，因此可以在跳动若干次正好到 $0$。
- 当所有的 $x_i$ 模二余数为奇数时，只需要把它们用 $0$ 代价向 $1$ 跳即可。原理和上面相同。

那么，题目就被转化成如何把一个数组所有的元素转换成模二余数相同的数。

我们注意到，模二的结果只可能余 $0$ 或者是 $1$。此时如果原来模二余数为零的数的数量有 $tot$ 个，可以得到以下结果：

- 当我们把所有的数模二的余数设为零时，我们可以让所有模二余一的数加一。所以总共花的钱数为模二余一的数的数量。也就是 $n-tot$。
- 当我们把所有模二余零的数全部转成一时，需要调的就是所有模二余零的数字，也就是 $tot$ 个。

为了减少花费，我们只需要知道 $\min{(tot,n-tot)}$ 即可。

代码：

```cpp
#include<iostream>
using namespace std;
int main(){
    int n;
    cin>>n;
    int a[n+1];
    for(int i=1;i<=n;++i)
        cin>>a[i];
    int tot=0;
    for(int i=1;i<=n;++i)
        if(a[i]%2==0)
            ++tot;
    cout<<min(tot,n-tot)<<endl;
}
```