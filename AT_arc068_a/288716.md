# 一道贪心，给大家一个不一样的做法

 - **题目大意**
 - **贪心思路**
 - **实现方法**
 
 ----
 
## 题目大意
 
 一个骰子，初始的时候任意的一个面朝上，接下来每一轮可以翻转骰子到相邻的一面，并获得此面的得分（那一面
的数值即是得分）。问至少要几轮才可以获得够 $x$ 分。

-----

## 贪心思路
 
既然要求最少的轮次，那么要每一轮拿更多的分数。

**怎么让每一轮的分数最大化呢？**

第一轮，按照贪心的“选择目前最优”的思路，选择六分；

第二轮，继续选择目前最优，由于要翻转，不能再得到六分，这次就选择到了五分；

第三轮，又可以翻转回六分了，选择六分。

$......$

相信大家都发现规律了，我们每一轮的得分为`6  ——> 5  ——> 6  ——> 5…` 。

**这便是我们的贪心策略**。

-----
## 实现方法

如果$x$是$11$的倍数，答案当然呼之欲出——$\frac{x}{11}$。所以，现在我们要处理的是$x$离$11$的倍数还差（或是多出）的一部分的处理方式。

从简单的入手，我们把丢一次$6$分加丢一次$5$分称为一大轮。现在如果我们按照一大轮一大轮地扔，需要扔几大轮？答案是向上取整的 $\frac{x}{11}$ ，求出这个值以后，我们只需要再判断能不能少掷五分的那一次就好了。

注：我们不用判断用不用掷六分的，因为如果掷五分的、掷六分的都可以省去的话，向上取整的$\frac{x}{11}$的值应该可以少 $1$ 。

讲了那么多，还是看看代码实现吧：
```
#include<bits/stdc++.h>
using namespace std;
int main()
{
  long long n,ans=0,x;
  cin>>x;//读入
  n=ceil(x/11.0);
  //此处的'ceil'为向上取整符，而为了防止括号内自动向下取整，
  //需要加上.0来强制转换为浮点型
  ans=ceil(x/11.0)*2;
  //因为每一大轮其实是两轮，所以要乘2
  if(n*11-x>=5)//如果可以省略最后掷的五分
    ans--;//答案减一
  cout<<ans<<endl;//输出
  return 0;
}
```
### 注意：

1. 这里我们运用到了[向上取整函数ceil](https://www.cnblogs.com/zjutlitao/p/3558218.html)，大家可以去深入了解一下；
2. 不开$long$ $long$的话……你懂的；
3. 记得要换行。

---

### 祝大家AC愉快！