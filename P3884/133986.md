# 并查集+近似于LCA的算法
这道题有三小问，我们逐一解决。


------------
### 一、深度
我们定义一个数组b，用于记录每一点的深度。

然后列出方程：
```cpp
b[a[i].rt]=b[a[i].lf]+1;//rt表示子节点，lf表示根节点
//根据题目定义的深度进行
```
最后进行**最大判断**：
```cpp
maxd=max(maxd,b[a[i].rt]);
```

------------
### 二、宽度
我们定义一个数组c，用来记录每一个深度所拥有的节点的个数。
```cpp
c[b[a[i].rt]]++;
```
最后同理选出最大即可。


------------
### 三、节点到节点的距离
题目的定义是这样的：

**结点间距离的定义：由结点向根方向（上行方向）时的边数×2，
与由根向叶结点方向（下行方向）时的边数之和。**

那么重要的是找出最近公共祖先（LCA）。
```cpp
inline ll LCA(ll l,ll r){
	register int i;
	ll p1=l,p2=r;//此时所处的位置
	ll d1=0,d2=0;//祖先到节点的距离
	while(p1!=p2){//比较祖先深度，哪一方深度深，哪一方就往上爬
		if(b[p1]>b[p2])p1=f[p1],d1++;
		else if(b[p1]<b[p2])p2=f[p2],d2++;
		else p1=f[p1],p2=f[p2],d1++,d2++;//可同时进行
	}
	return d1*2+d2;//可以在往上爬的同时记录，也可最后根据先前制定的b数组进行加减
}
```
