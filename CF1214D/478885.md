### $Problem$

题意简述：给你一个地图，其中有一些点不能走，问你最少要堵上几个点才能使点 $(1,1)$ 无法走到 $(n,m)$，只能向右或向下行走。

数据范围： $3$ $\leq$ $n×m$ $\leq$ $1 \times 10^6$。

### $Solution$

~~其实这个题作为蓝题挺水的。~~

首先可以考虑到，答案的值为 $0$ 或 $1$ 或 $2$。

证明：

- 因为最劣的情况就是将 $(1,2)$ 和 $(2,1)$ 堵住，价值也就是 $2$。

- 最优的情况就是根本不用你来堵住点，本身 $(1,1)$ 和 $(n,m)$ 就不联通。

那么我们就考虑什么时候会分别取到这三个值就好了。

$0$ 是最容易判的，直接从 $(1,1)$ 开始搜就行了，看能不能搜到 $(n,m)$，如果不能就输出 $0$。

如果搜得到 $(n,m)$，就说明至少要堵住 $1$ 个点了，然后在第一遍搜索的前提下，将第一遍走过的路径上的点变成障碍，在从 $(1,1)$ 出发，再搜一遍，如果还能搜到 $(n,m)$ 那么答案就为 $2$，否则为 $1$。

保证正确性的方法 ~~（虽然好像去掉了也能过）~~ ：第一遍搜索的时候优先往下搜，第二遍搜索优先往右搜，这样的话如果能搜到，因为我们的两条路径一条是优先向右走，一条是优先向下走，若这样都有交点，证明了所有路径必然相交。

### $Code$
~~丑陋的~~ 代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;   
const int N=1e6+7232;
int n,m,ans;
string s[N];
int dx[2]={0,1};
int dy[2]={1,0};
void dfs(int x,int y)
{
    if(ans) return ;
    if(x==n&&y==m)
    {
        ans=1;
        return ;
    }
    for(int i=0;i<2;i++)
    {
        int xx=x+dx[i],yy=y+dy[i];
        if(xx<1||yy<1||xx>n||yy>m) continue;
        if(s[xx][yy]=='#') continue;
        s[xx][yy]='#';//将路径上的点设为障碍
        dfs(xx,yy);
        if(ans) return ;//搜到了一条路径，就不能标记其他点了，只标记一条路径上的点
    }
}
int main()  
{   
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++) 
    {
        cin>>s[i];
        s[i]='?'+s[i];
    }
    s[1][1]='#';
    dfs(1,1);
    if(!ans) printf("0\n");//如果搜不到终点
    else 
    {
        ans=0;
        s[n][m]='.';//终点是可以经过多次的
        swap(dx[1],dx[0]);swap(dx[0],dx[1]);//保证了第一遍和第二遍搜索的优先方向不同
        dfs(1,1);//再重新搜一遍
        ans++;
        printf("%d\n",ans);
    }
}
```
