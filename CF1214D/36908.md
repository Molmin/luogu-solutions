# $ \Huge\texttt 奆 $坑题一道

在赛场上想到第一种办法结果被卡了……QAQ

显而易见的，答案只有$0,1,2$三种可能（真不行就直接堵`(1,2)`与`(2,1)`），如果一开始就不可能从左上角到右下角，则返回0。

处理答案为`1`或者`2`的情况？可以想到，如果有一个格子是所有可行道路的**必经之点**，则把这个格子堵住就OK了，否则输出2。

那么问题就是，如何求这个**必经之点**呢?

八仙过海，各显神通：

## 1.DP

通过递推得到每一个点到达`(1,1)`以及`(n,m)`的方案数，分别为`f[i][j]`与`g[i][j]`，则`f[i][j]*g[i][j]=经过此点的从左上到右下的路径数`，如果该值等于总路数(`g[1][1]`或者`f[n][m]`)，则这个点就是**必经之点**。

### BUT!

这种方法会导致其dp值很大（可以达到$\text C_{n+m}^{n}$左右），所以需要取模等hash方法，而这种方法会有一定概率被卡掉，所以不建议使用这种办法（据编者所知，1e9+7，1e9+9，998244353都被卡了~~某八位质数竟没有被卡~~）

所以还有什么办法呢？

## 2.对角线？

试试[这个题解](https://www.luogu.org/blog/chenyewei1234/cf1214d-treasure-island)？

一种玄学方法（反正我这种蒟蒻是想不出来~~我眼泪在肚子里打转~~），大概是一种**可靠**的正解。

## 3.支配树！

考完后听同机房奆佬说可以用支配树解决，然后就上网搜了一下，发现

$\Huge\texttt{米青女少口啊}$

支配树可以得到一幅图上从某个点到其他点的**必经之点**。

所以这，，不就裸题了吗？？？

那么支配树满足以下性质：

1. 根节点是我们选定的起点s。
2. 对于每个点i，它到根的链上的点集就是对于它的必经点集{xi}。
3. 对于每个点i，它是它的支配树上的子树内的点的必经点。

（↑网上找来的）

而这题又是一个DAG（有向无环图），又有一些蜜汁优越性，在支配树中插入一个新的节点$X_i$，只需要：

1. 求出所有连向该点的节点在树上的lca（最近公共祖先）
2. 将第一步求出的节点作为新节点的父亲
3. 更新插入节点的fa值

好了…

尤其是每一个节点顶多只有两个点连向它，~~所以求lca就珂以直接CXK+C&&CXK+V辣！~~

那么基本上就可以求出`(1,1)`到`(n,m)`的必经之点了，如果`(n,m)`节点在树上的父亲：

1. 是`(1,1)`：两点之间无**必经之点**，输出2
2. 是其他节点：该点到根节点`(1,1)`之间有别的必经之点，输出1
3. 不在树上：无法到达，输出0

$\Large\textit Code\ below$

```cpp
#include<algorithm>
#include<cstdio>
using namespace std;

char s[1 << 20];
int f[1 << 20], g[1 << 20], fa[1 << 20][20], d[1 << 20];
int n, m;

inline int pos(int x, int y)//将二维位置转为一维上的数组位置
{
    return x > 0 && y > 0 ? (x - 1) * m + y : 0;
}

inline int lca(int x, int y)//倍增求LCA
{
    bool bx = x <= 0 || !fa[x][0], by = y <= 0 || !fa[y][0];
    if (bx && by) return 0;
    if (bx && !by) return y;
    if (!bx && by) return x;//几个特判（x,y是否在树上）
    if (d[x] < d[y]) swap(x, y);
    for (int i = 19; i >= 0; i--) if (d[fa[x][i]] >= d[y]) x = fa[x][i];
    if(x == y) return x;
    for (int i = 19; i >= 0; i--) if (fa[x][i] != fa[y][i]) x = fa[x][i], y = fa[y][i];
    return fa[x][0];
}

signed main()
{
    // freopen("1.txt", "r", stdin);
    // freopen("2.txt", "w", stdout);
	scanf("%d%d", &n, &m);
	for (int i = 1; i <= n; i++) scanf("%s", &s[pos(i, 1)]);
   fa[pos(1, 1)][0] = -1;
	for (int i = 1; i <= n; i++)
        for (int j = 1; j <= m; j++)
        {
            int p = pos(i, j);
            if ((i != 1 || j != 1) && s[p] != '#')
            {
                fa[p][0] = lca(pos(i - 1, j), pos(i, j - 1)), d[p] = d[fa[p][0]] + 1;//上面提到的支配树操作
                for (int i = 1; i < 20 && fa[p][i - 1]; i++) fa[p][i] = fa[fa[p][i - 1]][i - 1];//更新fa数组
            }
        }
    switch (fa[pos(n, m)][0])
    {
        case 0: puts("0"); break;
        case 1: puts("2"); break;
        default: puts("1");
    }//情况判断
	return 0;
}

```

（这好像还是伪的支配树，不过能过这一题，在普通图的上支配树还是自行百度吧，窝也不会QAQ…）
