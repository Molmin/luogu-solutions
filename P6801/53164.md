# 写在前面
xdm写题目的时候如果要开 $long\;long$，记得把全部都改成 $long \;long$ 阿！！！  ——来自一个修了好半天代码只有12分的蒟蒻  

1. 本文不会出现$\sum$，因为我自己会被绕晕$qwq$  
2. 本文的举例会按输入格式表示，同时用（尽量偏暗的）色彩辅助理解  
3. 当然可能废话有点多，可以根据标题跳着看
4. 思路部分无代码，因为连贯性比较大，分开来我不太会讲，实在看不懂可以看看图

# 具体思路

题面用一句话来说，就是给一个图形，数其中的矩形个数  

### 标准的 x * y 矩形中包含的矩形个数

取出一个矩形，其实就是选择出连续的几行和连续的几列。  
行数为 $x$ 时，矩形的长度可以为 $1, 2 \ldots, x.$   
对于每种长度，根据起始行，不同的情况数为 $x, x - 1,\ldots,1.$   
相加后就是行数所占的所有不同的情况数：$\frac{(1 + x) * x}{2}$  
列数同理。那么包含的矩形个数就是  
$$f(x,y) = \frac{(1 + x) * x}{2} * \frac{(1 + y) * y}{2}$$

### 高度不同时数矩形的策略：容斥原理

看一个例子
```
input:
2
4 3
2 1
```
![](https://cdn.luogu.com.cn/upload/image_hosting/ow5fnkd8.png)

对于这个矩形，可以通过 $f(4,2)$（红+紫）$\;+\;$$f(3,3)$（紫+蓝）$\;-\;$$f(3,2)$（紫） 计算出总矩形个数  

不过写代码的时候直接使用容斥原理需要很多的加减法，很容易弄错，可以换一种思路理解这个式子：  
变换顺序为 $f(4,2) - f(3,2) + f(3,3)$  
$f(4,2)-f(3,2)$ 保证计算的矩形一定有红色（也就是红色部分对答案的贡献），接着我们就可以将红色部分从图形上剪去，余下$3*3$的蓝色和紫色部分直接用 $f(3,3)$ 计算  
 
这样，我们可以转化问题：**将一个图形，不断地剪去最高的连续最长矩形，剪去时计算他们的贡献并求和**  

(为了更好地理解这个东西，再来一个例子）
```
6
1 3 4 4 2 2
1 1 1 1 1 1
```
![](https://cdn.luogu.com.cn/upload/image_hosting/qrl7w8gj.png)

如图，每次计算包含红色的矩形个数并剪去它（紫色的部分是重复计算，需要减去）  
注意紫色部分的高度应该取峰两边的更大值，如图 $1$ 中左边高度为 $3 > 2$，图 $2$ 中右边高度更大为 $2>1$，这是为了只将突出的峰剪去，否则会导致重复计算

1. $ans += f(4,2) - f(3,2)$
2. $ans += f(3,3) - f(2,3)$
3. $ans += f(2,5) - f(1,5)$
4. $ans += f(1,6)$

最终 $ans = 81$

### 时间复杂度优化：单调栈 + 前缀和

因为 $1 \leq h_i \leq 10^9$，显然不能直接按高度循环（不过可以离散化后操作），我使用的是单调栈来优化  

#### 单调栈粗略介绍

单调栈的特征就是单调，以单调递增为例，栈中元素为$\{1,3,4\}$，下一个即将入栈的元素为 $2$，则先让 $4$ 和 $3$ 出栈，再使 $2$ 入栈，保证栈内元素的单调性

#### 单调栈在本题中的使用

由于每次都是剪去最高的部分，可以推想：  
1. 如果更高，那么可以直接入栈；
2. 如果一样高，那么可以和上一个矩形组成一个成宽的矩形，之后一起计算；
3. 如果更低，那么就会形成一个峰，这时需要不断地减去最高的部分，直到栈顶的矩形高度小于等于当前读入的矩形高度

#### 前缀和

对于相同高度的矩形，我们可以自然的将他们组合成更大的矩形，如上图 $2$ 中，高度为 $4$ 的矩形由第三块和第四块共同组成。在代码中，我们只需要用前缀和维护第三块和第四块矩形的宽度，就可以直接计算出
高度为 $4$ 的矩形长度

高度为 $3$ 同理，由二三四这三块组成。只要记录最前面（第二块）矩形入栈的位置，就可以直接计算出总宽度

# 代码

```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;

ll mod = 1e9 + 7;
ll n, ans;
ll h[100001], w[100001], pre[100001];
//h是高度，w是宽度，pre是宽度的前缀和
stack<pair<ll, ll> > s;
//first是高度，second是第i个读入的矩形，配合宽度的前缀和可以将高度相等的矩形直接组合

ll cal(ll x, ll y)
{
	x %= mod; y %= mod;
	x = ((1 + x) * x % mod) * 500000004 % mod;//500000004是2关于膜1e9+7的乘法逆元
	y = ((1 + y) * y % mod) * 500000004 % mod;
	return x * y % mod;
}

int main()
{
	ios::sync_with_stdio(false);
	cin >> n;
	for(int i = 1; i <= n; ++i) cin >> h[i];
	for(int i = 1; i <= n; ++i)
	{
		cin >> w[i];
		pre[i] = pre[i - 1] + w[i];
	}
	ll tmp_h1, tmp_w1, tmp_h2;//这里，记得函数内开变量也要longlong
	for(int i = 1; i <= n; ++i)//此处代码压缩很严重
	{
		ll flag = i;//这个后面再说
		while(!s.empty() && h[i] < s.top().first)
		{
			//忘记判断栈空的话，会遇到段错误，而cpp是按从左至右顺序判断的
			//比较当前读入的矩形和栈顶矩形的高度
			flag = s.top().second;//后面再说
			tmp_h1 = s.top().first;//栈顶的矩形高度
			tmp_w1 = pre[i - 1] - pre[s.top().second - 1];
			s.pop();
			//当前读入的矩形还没有进栈，所以栈顶的矩形是第 i - 1 个读入的矩形
			//second是同高度的最前面的矩形入栈的位置
			
			tmp_h2 = h[i];//tmp_h2相当于需要减去的紫色部分的高度
			if(!s.empty()) tmp_h2 = max(s.top().first, h[i]);
			ans = (ans + cal(tmp_h1, tmp_w1) - cal(tmp_h2, tmp_w1) + mod) % mod;
			//这里记得与前后都进行比较，也要记得判断栈是否为空
		}
		if(s.empty()) s.push(make_pair(h[i], 1));
		else if(h[i] > s.top().first) s.push((make_pair(h[i], flag)));
		//如果栈空了，说明读入的矩形高度很低（或刚开始读入），但前面的矩形并不会悬空，所以从第一个格子开始数
		//如果栈没空，读入的矩形与栈顶高度相等，那么会自动组合，不用管
		//          读入的矩形比山顶矩形高，需要入栈，如果之前没有删去峰的话，同高度最前一块就是第i块
		//                                      如果之前删去了峰，说明前面还有同高度的矩形，用flag记录最前
	}
	while(!s.empty())//这个和循环里差不多，复制粘贴后改改就行
	{
		tmp_h1 = s.top().first;
		tmp_w1 = pre[n] - pre[s.top().second - 1];
		s.pop();
		if(!s.empty())
		{
			tmp_h2 = s.top().first;
			ans = (ans + cal(tmp_h1, tmp_w1) - cal(tmp_h2, tmp_w1) + mod) % mod;
		}
		else ans = (ans + cal(tmp_h1, tmp_w1)) % mod;
	}
	ans %= mod;
	cout << ans << endl;
	return 0;
}
```