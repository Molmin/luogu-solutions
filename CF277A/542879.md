# CF277A题解

[CF277A Learning Languages](https://www.luogu.com.cn/problem/CF277A)

**题意简述**

有 $n$ 个人，每个人会说几种语言（也可以一种也不会），为了使这 $n$ 个人之间都可以互相交流（可以通过过中间翻译交流），试求还需要让这些人一共要学多少种语言。

**思路**

我们先把样例2拿来研究一下。

我们可以把每个人和每种语言都看成节点，如果一个人会一种语言，就可以把它看成在这个人的节点和这种语言之间有一条无向边。

于是，我们就可以把样例2的数据绘制成一张图：

![样例2的图](https://cdn.luogu.com.cn/upload/image_hosting/nqtoyv6h.png)

其中 $P$ 是人的节点，$L$ 是语言的节点。

我们发现，图中**同一个连通块内的人节点都是可以互相交流的**（很好理解，也不需要发现）。

那么，如果要使所有人都可以互相交流，就让**所有的人节点都在一个连通块**里就好了。

注意，只需要所有的**人节点**在连通块里就行，假如有没人会的语言，也是不用考虑的！（即允许有独立的语言节点不在联通块内）。

题目让我们所求的是这些人一共要学的语言数，也就是将这些联通块都连起来的最小连边数。如果把每一个连通块都当成一个节点的话，把这些节点都连起来的最小连边数就是**连通块数** $-1$ 了。（还是要提醒：独立的语言节点不算连通块！）

另外，有个地方需要特判：假如没有一个人会一种语言，那么最后的结果就是人数（每个人都学同一种语言）。

**实现**

大概这么几个步骤：

1. 读入
1. 建图
1. 连通块计数
1. 输出

其中建图这一步，我们把人的节点编号是 $1$ 到 $n$，语言的编号是从 $n+1$ 到 $n+m$。

这里我是用邻接表来实现的，当然也可以用前向星或者邻接矩阵实现。（注意建的是无向图）

连通块计数的板子放这了：
```cpp
//dfs部分
void dfs(int x) {
	//v数组标记节点是否被遍历过
	v[x]=1;//访问了x节点，标记打上
	for(int i=0; i<e[x].size(); ++i) {//遍历与x节点相连的所有节点
		if(v[e[x][i]])continue;//如果这个节点已经被遍历过了，就不访问了
		dfs(e[x][i]);//访问这个节点
	}
}
```
```cpp
//主程序部分
for(int i=1; i<=n; ++i)//遍历每个节点
		if(!v[i])//这个节点未被访问
		{
			dfs(i);//访问
			//如果当前节点所在的连通块里的所有节点都被访问完了
			//由于访问过的节点都不在访问
			//dfs就会退出
			cnt++;//连通块的数量+1
		}
```
最后输出的时候记得输出时要记得 $-1$ 和特判。


**代码**

```cpp
#include<bits/stdc++.h>
using namespace std;
int v[1000001];
vector<int> e[100001];
int n,m,cnt,flag,a,lan;
void dfs(int x) {//连通块板子
	v[x]=1;
	for(int i=0; i<e[x].size(); ++i) {
		if(v[e[x][i]])continue;
		dfs(e[x][i]);
	}
}
int main() {
	cin>>n>>m;
	for(int i=1; i<=n; ++i) {
		cin>>a;
		for(int j=1; j<=a; ++j) {
			//flag是特判标记
			flag=1;//排除特判的情况
			cin>>lan;
			e[i].push_back(n+lan);//人的编号是i，语言的编号是n+lan
			e[n+lan].push_back(i);//建的是无向图
		}
	}
	for(int i=1; i<=n; ++i)//独立语言节点不算连通块，所以只遍历到n
		if(!v[i]) dfs(i),cnt++;//连通块板子
	if(flag)cout<<cnt-1;//记得-1
	else cout<<n;//特判
}
```
