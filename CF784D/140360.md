## 题目大意：

给出一个数字串以及数字转化成盲文的规则，判断这个数字串转化成盲文后是否回文。


------------
## 解决方法

采用非常暴力的手段即可。要判断回文，我们想象把这个字符串首尾对折一下，重合的两个字符我们称它们处于“对应位置”。我们来对照表格看一下对应位置的字符要满足什么条件？

![](https://cdn.luogu.com.cn/upload/image_hosting/tsdnknrv.png)

很显然，若该串回文，对于任意一个字符，其对应位置的字符分以下几种情况：

$1.$ 当前字符为 $4$，则它对应位置的字符为 $6$。

$2.$ 当前字符为 $6$，则它对应位置的字符为 $4$。

$3.$ 当前字符为 $5$，则它对应位置的字符为 $9$。

$4.$ 当前字符为 $9$，则它对应位置的字符为 $5$。

$5.$ 当前字符为 $8$，则它对应位置的字符为 $0$。

$6.$ 当前字符为 $0$，则它对应位置的字符为 $8$。

$7.$ 当前字符为 $3$，则它对应位置的字符为 $3$。

$8.$ 当前字符为 $7$，则它对应位置的字符为 $7$。

其余情况皆不满足。我们只用跑一下该字符串的 $0$ 到 $len/2$ 位置，判断每个字符和它对应位置的字符是不是满足上述条件的一种即可。

特别地，若该字符串长度为奇数，则它的中间位置字符只能是$3$ 或 $7$。


------------


## 上代码

```
#include<bits/stdc++.h>
using namespace std;
int main(){
	char a[500];
	gets(a);
	int len=strlen(a);
	if(len%2&&a[len/2]!='3'&&a[len/2]!='7'){//当长度为奇数，判断中间位置的字符 
		cout<<"No";
		return 0;
	}
	for(int i=0;i<=len/2;i++){
		int p=len-1-i;//这样a[p]是a[i]对应位置的字符  
		if((a[i]=='3'&&a[p]=='3')||(a[i]=='7'&&a[p]=='7')||
			(a[i]=='4'&&a[p]=='6')||(a[i]=='6'&&a[p]=='4')||
			(a[i]=='5'&&a[p]=='9')||(a[i]=='9'&&a[p]=='5')||
			(a[i]=='8'&&a[p]=='0')||(a[i]=='0'&&a[p]=='8'))//满足任意一种条件，该位置判定成立 
			continue;
		cout<<"No";//否则立刻判定为错误 
		return 0;
	}
	cout<<"Yes";
	return 0;
}
```
