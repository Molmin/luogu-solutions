 _特喜欢写入门难度的题解。。。。。感谢 _**@高宇恒bool**_ 指导_ 

   这个题目基本上使用拆分方法就可以做，即从最低位开始分别存入一个数组。这题要注意的是负数的反转和反转后头为0的情况中的一些细节问题，很容易出错

直接上代码

```cpp
#include<iostream>
using namespace std;
int main(){
    int k,n,i=0,MAXN=100001,u,m=0,l;
	int a[MAXN];
	cin>>k;   //输入数字
	u=k;   //因为后面还需要用到k，所以用一个新的u替代k执行后面的反转循环
	while(u!=0){    _//反转数字开始_ 
    a[i]=u%10;   //取余后，数组存储的即为u的最低位的值
    i++;  //因为数组项从0开始存储，所以i自增应放在后面
    l=u-a[i];   //l将原数最低位变为0；
    u=l/10;   //因为原数最低位是0，便可以放心大胆的除以10去掉末位，完成u的更新
	}    _//反转数字结束_ 
	if(k<0){   //以下步骤是负数的反转后处理
		cout<<"-";   //先加个负号，再将每个数变为其相反数（因为负数时反转后每个数字都是负的）
		for(n=0;n<i;n++)
		a[n]=-a[n];
	}
	for(n=0;n<i;n++){   //以下步骤是反转后前有0的处理
		if(a[n]!=0)   //若开头没有0，则退出循环
		break;
		else
	if(a[n]==0)   //若开头有0，计算0的个数
	m++;
}
	for(n=m;n<i;n++)   //因为数组内已经是从末位到首位，所以直接输出，m保证输出的头位没有0
	cout<<a[n];
	return 0;
}
```

这题目主要注重细节，其余就没有什么难点了。。。