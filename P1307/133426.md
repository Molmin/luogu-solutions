## 挑战目前最短题解！！！

看了一下题解，2楼的DALAO方法和我基本相同，但是我感觉很多OIer都没看懂，所以特别来补充一下。

**因此这片题解会写的比较长，但是会写得比较易懂**

而且这种解法的代码量极短...

~~其实我是冲着最短题解来的~~


------------
**做这道题需要灵活的运用两个运算符： / 和 %**

如果有OIer不熟悉这两个运算符运用可以点我的[这篇题解](https://www.luogu.org/blog/stonejuice/solution-p1554)。里面还是比较详细的解释了这两个运算符的用法的。


------------

其实思路还是非常好懂的。

我们举个栗子

如果我们要反转numa=2145这个数

那我们取个位5丢进numb **（运用运算符 % ）** ，然后再把5扔掉 **（运用运算符 / ）** ,numa变为214。

然后将numb的数进位，变为50，再把numa的个位4扔进numb,然后丢掉4。此时numb变为54，numa变为21。

**重复上述过程，当numa=0时，无数可取，停止循环。**

画个表就是酱紫

numa----numb

2145----0

214-----5

21------54

2-------541

0-------5412

**这样看就很好懂了吧QWQ（自认为）**

当然可能还有人有一些问题：

- Q:反转的数不是有负数吗，怎么会AC呢？
- A:因为处理的时候使用的是乘除和模这三个运算符啊，这些运算符不会改变数的正负，所以反转后还是负的！

- Q:怎么处理前导0？
- A:反转后就自动处理前导0了！因为程序会自动处理！（就像你反转130，你写的肯定不会是013，程序也是一个道理）

**先贴一个不压行方便各位学习的代码：**

```
#include <iostream>
using namespace std;
int numa,numb;//全局变量自动赋值为0 
int main()
{
	cin>>numa;  
	while(numa!=0)
	{
		numb=numb*10+numa%10;
		numa/=10; 
	}
    //将numb原来的数进位，将numa最后一位+进numb,再丢掉此数。当numa为0时停止  
    cout<<numb;//输出，反转后0会被自动处理 
    return 0; 
} 
```


**再贴一个最短代码！！！**（重点？）


```
#include <iostream>
int numa=0,int numb=0;
int main(){
    for(std::cin>>numa;numa!=0;numa/=10)numb=numb*10+numa%10;
    std::cout<<numb;
} 
```


------------
## 修改日志：
- 19-3-10 接受了某位DALAO的意见，**省去了using namespace std，改为用std::cin与std::cout**，并且将变量开进了main()中。

