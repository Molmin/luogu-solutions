如果每个人想要送给的人都不一样，那皆大欢喜，直接就是答案。

想一下，如果有两个人都想送给同一个人呢？三个人都想送给同一个人呢？如果有这样中情况发生，只能满足一个人。那另外的人怎么办呢？

不难想到，如果有 $x$ 个人都想将礼物送给一个人，那么必然会有 $x-1$ 个人没有礼物收，然后就让那 $x-1$ 个人送给这没有礼物收的 $x-1$ 个人。

还有一种情况，就是自己送给自己，虽然题目中保证了输入中不会有这种情况，但是经过我们的一顿安排，这种情况可能就出现了。

例如：$1$ 想送给 $3$，$2$ 也想送给 $3$，$3$ 想送给 $2$。 按照上面的处理方法，会让 $2$ 送给 $3$，$3$ 送给 $2$，这样 $1$ 就只能送给自己，是不满足题目要求的。

那这种情况怎么处理呢？

如果送给自己了，就让这个人的愿望满足，这样的话就有两个人的礼物送给了同一个人了。这时，让那个人把礼物送给这个原本要把礼物送给自己的人，这样就可以了，也不会减少总数。

如果上面的方法你没理解，体现到刚才的例子上，就是让 $1$ 把礼物送给 $3$，然后让 $2$ 把礼物送给 $1$，这样就是 $1$ 送给 $3$，$2$ 送给 $1$，$3$ 送给 $2$，这样就能理解了。

对于多个人想要送给同一个人，我的代码是满足最后一个人，代码如下：

```cpp
#include<bits/stdc++.h>

using namespace std;
typedef long long ll;

int main() {
//    freopen("in", "r", stdin);
    int t;
    scanf("%d", &t);
    while (t--) {
        int n, cnt = 0;
        scanf("%d", &n);
        vector<int>p(n + 1), st(n + 1), ans(n + 1), v;
        map<int, int>mp;
        for (int i = 1;i <= n; i++) {
            scanf("%d", &p[i]);
            st[p[i]]++; //想要给 p[i] 送礼物的人数
            mp[p[i]] = i; //最后一个想要给p[i] 送礼的人的编号
        }
        for (int i = 1;i <= n; i++) if (!st[i]) v.push_back(i);//没有人想要给i送礼物
        for (int i = 1;i <= n; i++) {
            if (st[p[i]] == 1) ans[i] = p[i], cnt++; //没有人和i争了，那就让i如愿以偿
            else { //有多个人想要给p[i]送，那就让i送给那些没有礼物收的人
                ans[i] = v.back();
                st[p[i]]--;
                v.pop_back();
            }
        }
        printf("%d\n", cnt);
        for (int i = 1;i <= n; i++) {
            if (i != 1) printf(" ");
            if (i == ans[i]) { //出现了自己送给自己
                ans[i] = p[i]; //满足这个人的想法
                ans[mp[p[i]]] = i; //让原本送给p[i]的那个人将礼物送给i
                mp[p[i]] = i;
            }
            printf("%d", ans[i]);
        }
        puts("");
    }
    return 0;
}
```