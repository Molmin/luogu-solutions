# CF985C Liebig's Barrels 题解

## 题意简述

* 给定总计 $n \times k$ 块木板。
* 需要选中 $k$ 条木板来组成 $n$ 个木桶。
* 每个木板只能使用一次。
* 每个木桶的容积定义为这个木桶最短的木板的长度。
* 要求这 $n$ 个容积尽可能相近的木桶的最大容积。

## 思路分析

### 贪心策略

要求最短的木板，只需要 `sort` 一遍找到 $a_1$ 即可。这根最短的木板就是当前木桶的容积。即剩下的 $n - 1$ 根木板必须要满足当作全部 $n$ 个木桶的条件。

可以发现，当 $a_n - a_1 \gt l$ 时，是不可能做出木桶的（否则 $a_n \dots a_m$ 必定大于 $a_1 + l$，这明显违背题意）。

想要让总容量最大，自然是尽可能找大的木板，有一个木桶的容量已经确定为 $a_1$，就要让剩下的几个木桶在 $a_2 \dots a_n$ 这 $n - 1$ 根木板中选择大的当作容量。

我们将最大容量定义为变量 $v$，只需要遍历数组，找到同时满足 $a_v - a_1 \leq l$ 和 $a_{v + 1} - a_1 \gt l$ 的 $v$ 即为最大容积。（由题意得，最短木板就是木桶容积，所以可以直接使用容量 $v$ 在木板长度数组 $a$ 中遍历）。

最后就是组装木桶了。由于我们要找容积尽可能大的木桶，所以往大的木板找，即找 $a_v$ 到 $a_{v + k}$ 这些木板来组成木桶。（即 $a_{m - k + 2} \dots a_m$）。以此类推，到大木板取完时，我们再回过头拿小木板。

### 样例说明

使用样例 \#1：

```
4 2 1
2 2 1 2 3 2 2 3
```

排序后遍历数组找到 $v = 6$：

```
1 2 2 2 2 2 3 3
```

所以 $a[v] = 2$，此时按照我们的贪心策略，木桶应该这么分：

![表格](https://s2.loli.net/2023/01/12/ef8qLx2BjFkrcRz.png)

~~由于洛谷博客的 Markdown 版本过老，所以大家将就着看一下图。~~

容量为 $v = 2 + 2 + 1 + 2 = 7$。

### 贪心证明

我们这里使用上文的 \#样例 1 交换一下组 2 和组 3 中的 $1$ 和 $2$，更新 $v = 2 + 2 + 1 + 2 = 7$。(若交换其他变量如 $1$ 和 $3$ 则无法满足题意)

交换处理的元素位置后却无法取得更优解，由此可以推定目前的解已经是最优解了。

---

总的来说，这是一道有水平的贪心题。在想出贪心策略后，代码的实现也是一个问题。

## 代码

```cpp
#include <bits/stdc++.h>

using namespace std;
typedef long long ll;
const ll N = 2e6 + 50;

ll n, k, l, ans;
ll a[N];

void work() {
    sort(a + 1, a + (n * k) + 1);   // 找出最短木板
    if (a[n] - a[1] > l) {
        printf("0\n");
        exit(0);
    }

    ll v = n * k;
    while (a[v] - a[1] > l) v--;    // 找到最大容量
    ll cnt = 0, it = v;
    for (ll i = n * k; i - (k - 1) > v; i -= (k - 1)) {
        ans += a[it--];
        cnt++;
    }
    for (ll i = 1; i <= v - cnt; i += k)
        ans += a[i];
}

int main() {
    scanf("%lld %lld %lld", &n, &k, &l);
    for (ll i = 1; i <= n * k; i++)
        scanf("%lld", &a[i]);
    work();
    printf("%lld\n", ans);
    return 0;
}

```

注意 **数据范围**，需要开 `long long`，否则在第七个数据点就会开始炸。
