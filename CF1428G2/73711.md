# 题意
看翻译只能懂个大概（连数字都能写错）。然后自己用机翻看了一下，终于懂了。

没看懂题的可以看这里：

给定 $q$ 个位数不超过 $6$ 的数 $n_1\sim n_q$ ，将这每个数分为 $k$ 个数（$k$ 个数和为 $n$）。
对于每个数来讲，其权值为所有数位的权值之和。每个数在每个数位的权值如下：

![](https://cdn.luogu.com.cn/upload/image_hosting/z7m9x4h8.png)

对于每个 $n$ ，使其分成的 $k$ 个数的权值最大，求最大权值。
# 分析
仔细观察我们可以发现：

一个 $9$ 所贡献的权值等同于三个 $3$ 贡献的权值。同理，一个 $6$ 所贡献的权值等同于两个 $3$ 贡献的权值。所以我们完全可以抛开 $3$ 和 $6$ 不看，将其全部转化为 $3$ 考虑。

又注意到其余数值的贡献均为 $0$ ，因此，我们要尽可能将 $n$ 分为很多个三。

我们对于每个分开来的数（将其定为 $a_1 \sim a_k$ ），都将其分成各个数位，因为每个数位的贡献均为单独计算的。

但是我们必须要将 $n$ 完全拆完，所以并不能使每个 $a_i$ 都成为由 $3$ 组成的数，所以一定要有数做不了贡献。但我们要尽可能将没有贡献的数的个数减小，这时我们可以发现，其实所有无法贡献的数可以完全集中在一个 $a_i$ 上，让另外的 $k-1$ 个数都可以做出贡献。

假设有两个数第 $i$ 位无法做出贡献，记这两个数该位上的数字分别为 $x$ 和 $y$：

1. 若 $x+y\le9$ ，则可使 $z=x+y$ 作为单独的一个数位，就可将两个无法贡献的数位变为一个。

2. 若 $x+y>9$ ，则可使 $w=9,z=x+y-9$ 代替原 $x,y$ 其中 $w$ 可以正常贡献，同样只有一个数位无法贡献。

因此，我们可以得到一个结论，每一位最多只有一个 $a_i$ 无法进行贡献。

我们可以将这每个无法进行贡献的数位全部转移在 $a_k$ 上，以保证其他的数均能表示为由 $3、6、9$ 构成的数。

这时，我们可以将这个问题转化为背包问题。

我们要分的空间为 $n$ ，每个物品的重量为 $3\times10^i$ ，其对应价值为 $f[i]$ ，每个物品有 $3\times(k-1)$ 个。

为什么是 $3*(k-1)$ 个呢？

因为最后的 $a_k$ 要用于装多出来的无法贡献的数。而对于每个数，其每位上都可以装 $0\sim3$ 个三（$0、3、6、9$），所以每一种三（指在各个数位上），只要装的个数小于等于 $3\times(k-1)$，就一定可以装下。

这就成为了一个多重背包，因为数据较大，所以要使用二进制优化才能通过。

那剩下的无法贡献的怎么办呢?

我们可以再弄一个必须装满分组背包，因为每个数位仅可以选（$0\sim9$），不可以重复。注意，其中的 $3、6、9$ 能够贡献，并不是一定无法贡献。

对于 $hard$ 版本，我们要先预处理每个 $n$ 的答案（$0 \sim 999999$），然后再输出。

所以其实两个版本难度差不多？怪不得都是黑的。。。
# Code
（代码有注释，如果还不是很懂的话可以看看代码）

~~个人认为码风还不错~~
```cpp
#include<bits/stdc++.h>
using namespace std;
int k;
long long p[6];//即原文f，因为个人习惯不想重名
int q;
long long f[1000001];//答案
long long w[1000001];
long long c[1000001];//每个物品的质量、体积
//这几个long long 一定要开，不开过不了（我就连交了3次）
int power=3;
int tot;
int main()
{
	cin>>k;
	for(int i=1;i<=999999;i++)
	{
		f[i]=-0x7ffffffffffff;//赋初值，因为必须装满，装不满的赋为极小值，0x7fffffff不够大，可以再多加几个f，不然要被Hake
	}
	for(int i=0;i<=5;i++)
	{
		cin>>p[i];
	}
	for(int i=0;i<=5;i++)
	{
		long long t=3*(k-1);
		long long now=1;
		while(t>now)
		{
			t-=now;
			w[++tot]=p[i]*now;
			c[tot]=power*now;
			now*=2;
		}
		w[++tot]=p[i]*t;
		c[tot]=power*t;
		power*=10;//二进制优化拆物品
	}
	for(int i=1;i<=tot;i++)
	{
		for(int j=999999;j>=c[i];j--)
		{
			f[j]=max(f[j],f[j-c[i]]+w[i]);//先多重背包
		}
	}
	power=1;
	for(int i=0;i<=5;i++)
	{
		for(int j=999999;j>=0;j--)
		{
			for(int x=1;x<=9;x++)
			{
				if(j<x*power)
				{
					break;
				}
				f[j]=max(f[j],f[j-x*power]+(!(x%3))*(x/3)*p[i]);
			}
		}	
		power*=10;
	}//分组背包，记得是要装满的
	cin>>q;
	for(int i=1;i<=q;i++)
	{
		int n;
		cin>>n;
		cout<<f[n]<<endl;//直接输出答案
	}
	return 0;
}
```

蒟蒻有生以来第一道黑题题解（~~说不定以后就不是了~~）