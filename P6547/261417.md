注：5月15改了一个for循环.

------------
感谢第一篇题解，给了我一些细节的提醒

这题就是求所有的数字，将它们排序后输出即可。

但仅仅是那么简单吗？当然不是！

因为数据范围：**每个字符串长度不超过 100**

**100**！如果全部都是数字，绝对爆long long。

所以我们要用**字符串**存数。（推荐STL自带的string，原因后面解释）。

读入后先判断这个字符是不是数字，是的话还要判断它是不是开头的数字，如果是那数字的个数就+1，否则就和还没处理的那个数接在一起（string的第一个好处：+号可以将两个字符串接在一起）。但这里有个坑点：
## 0！0！0！

是0的话就按之前的方法处理，最后在将数组扫一遍，如果是空串的话，就把它改为0。

至于排序。。。大家可以先做做这题：[P1781 宇宙总统](https://www.luogu.com.cn/problem/P1781)

你可以手写排序函数，也可以进行冒泡排序。

主要是先按长度比，如果长度相同再按字典序排。

代码:

```cpp
#include <bits/stdc++.h>
using namespace std;
bool cmp(string a,string b){//判断函数 
	return (a.size()>b.size()||a.size()==b.size()&&a>b);//先判长度，再判字典序大小 
}
string a[10005];//数字数组 
int main(){
	int n,len=0;//len是一共有的数字个数 
	cin >> n;
	string b;//读入用 
	for (int i=1;i<=n;i++){
		cin >> b;
		for (int j=0;j<b.size();j++){//string自带的求长函数
			if (b[j]<='9'&&b[j]>='0'){
				if (i==0||b[j-1]>'9'||b[j-1]<'0'){//b[j]是这个数字的开头 
					++len;
				}
				if (a[len]!=""||b[j]!='0')//b[i]不是这个数字的开头 
					a[len]=a[len]+b[j];//string的+在系统内部重新定义了，功能是把两个字符串连接在一起。 
			}
		}
	}
		for(int i=1;i<=len;i++)
		if(a[i]=="")//判断是否是空串
		a[i]='0';//是的话这个数就是0
	sort(a+1,a+1+len,cmp);
	for (int i=len;i>=1;i--) cout << a[i] << endl;//由于我按降序排序，所以输出时要倒着输出
} 
```
