### 一道带有 string suffix structures 标签的题目居然没有后缀数组的题解，令人震惊。

题意：给定一个长为 $n$ 的 $01$ 串 $s$ ，求一个字典序最小的长为 $k$ 的 $01$ 串 $t$ ，使得它与 $s$ 中所有长为 $k$ 的子串至少有一位对应相同。

 考虑将 $s$ 按位取反得到串 $r$ 。那么 $t$ 合法的充要条件是它与 $r$ 中所有长为 $k$ 的子串不同。暴力怎么做呢？首先先将无解的情况判掉，即若 $r$ 中长为 $k$ 的本质不同的子串数量恰好等于 $2^k$ ，就是无解的情况。

否则，从高位往低位贪心填 $0/1$ ，假设我们当前在填第 $i$ 位（$1\leq i \leq k$），前 $i - 1$ 位已经确定了。如果 $r$ 中所有长为 $k$ 的且长为 $i-1$ 的前缀与 $t$ 相同的且第 $i$ 位为 $0$ 的子串数量是 $2^{(k-i)}$ ，说明这一位填 $0$ 的话后面填什么都没救了，只能填 $1$ ；否则填 $0$ 。同时为了完成这一操作，我们每次确定第 $i$ 位的取值的时候，要把第 $i$ 位不符合的 $r$ 的长为 $k$ 的子串去掉（举个例子，前三位填了 $001$ ，如果 $k=4$ 就得把串 $0001$ 去掉）。

这个复杂度是 $O(n^2)$ 的，可以用后缀数组优化。建出 SA 后按照后缀排名从小到大遍历每一个本质不同的长为 $k$ 的串并把它们扔到一个数组里，这样的话字典序自然保证了递增；维护一个左指针和右指针表示当前需要考虑的串的范围，每次填数用二分找出第 $i$ 位为 $0$ 的串的数量就可以 check 合法性了，然后你会发现用后缀数组的好处就是每次更新需要考虑的串的范围的具体操作就是去掉一个前缀或后缀，所以用之前二分得到的信息更新左右指针就很 trivial。几乎没有细节，时间复杂度 $O(n\log n)$ 。

有一个坑点是多组询问的情况下**要对 rk （后缀排名）数组的两倍进行清空**，否则 WA on test 86。

提交记录：[link](https://codeforces.com/contest/1469/submission/165796570)