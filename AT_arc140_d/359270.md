这一篇题解的状态设计与转移应该是很清楚的。

## 分析

首先观察题干输入，发现这是一个 $n$ 个点、 $n$ 条边的图，且一个点只连出去一条边，那么它一定是由多个基环树或环组成的。现在考虑删去未定的边，发现删去一条边会使得一棵基环树变成两棵树、或使得一棵树变成两棵树，且每一棵树中仅有一个权值为 $-1$ 的节点（否则边数不够）。

我们发现原题中求的是每种情况下连通块数的总和，根据加法结合律，可以转化为求每种连通块（基环树）在多少种情况下出现，再加和。因而我们考虑数出有多少种连通块出现过。设权值为 $-1$ 的节点有 $cnt$ 个，则删去未定边的后的树有 $cnt$ 棵。分两种情况讨论。

1. 对于删去未定边后，仍然是基环树或环的连通块，无论其它边如何连接，这个连通块都一定存在。故它对每一种情况都会产生 $1$ 的贡献。情况总数是 $n^{cnt}$ 种，这一类的连通块数可以通过 dfs 求出。相乘即为第一种情况的贡献

2. 对于 $cnt$ 棵树，其内部连边可以形成新的连通块（基环树），具体的连边方式是每一个权值为 $-1$ 的节点向下一棵树的任意一个节点连边，最终形成一个基环树。考虑设 $dp_{i,j}$，表示从前 $i$ 棵树中选出 $j$ 棵树组成一个连通块的方案总数。设第 $i$ 棵树中的节点数量为 $num_i$，便有如下的转移。
$$
dp_{i,j}=dp_{i-1,j}+dp_{i-1,j-1}\times \max(1,j-1)\times num_i 
$$

其中第一部分是 $i$ 不选的方案数，第二部分是 $i$ 被选进基环树中的方案数。基环树中插入一棵树时，有 $j-1$ 个空位可供插入（注意插入第一棵树时，这里应该是 $1$，而不能乘 $0$），连接到该树上的边可以连到树上的任意一个节点，有 $num_i$ 种方案，相乘即为第二部分的方案数。

最终，考虑由 $i$ 棵树组成的一个连通块，共有 $dp_{cnt,i}$ 种；对于每种连通块，其以外的 $-1$ 节点可以任意连接，该连通块都存在，能产生 $1$ 的贡献，故每个连通块都会在 $n^{cnt-i}$ 种情况中出现。将两者相乘即为选出 $i$ 棵树的贡献，将所有 $i$ 的贡献相加即为第二种情况的贡献。

两种情况的贡献相加即为最终答案。

## 代码
```cpp
#include<bits/stdc++.h> 
#define int long long
#define rep(i,j,k) for(int i=j;i<=k;i++)
#define repp(i,j,k) for(int i=j;i>=k;i--)
#define ls(x) x*2
#define rs(x) x*2+1
#define mp make_pair
#define fir first
#define sec second
using namespace std;
const int mo=998244353,N=2005;
void read(int &p){
	int x=0,w=1;
	char ch=0;
	while(!isdigit(ch)){
		if(ch=='-')w=-1;
		ch=getchar();
	}
	while(isdigit(ch)){
		x=(x<<1)+(x<<3)+ch-'0';
		ch=getchar();
	}
	p=x*w;
}
//1.发现：最终结果一定是若干棵基环树，现目前的情况一定是若干棵基环树+若干棵树，每棵树中有一个-1节点
//2.考虑：由于求的是每种情况下连通块的总和，根据加法结合律，可以转化为求每种连通块（基环树）在多少种情况下出现，再加和
//3.分类：原本存在的基环树一定在每种情况下出现，可以先记录答案，再考虑树之间连接形成的基环树在多少种情况下出现
//4.分析：先考虑由i棵树连接形成的基环树，设dp(i,j)表示前i棵树中选择j个形成一棵基环树的方案总数 
//若当前树被选择，则考虑：当前树会被插入已经形成的环的任意位置，共有j-1种插入点；该树的-1位置连接点已经确定，
//但上一个树连接到该树上的点任意，共有num[i]种，应该相乘。 
//则：已选择j棵树形成一棵基环树，对答案的贡献为1，其余的树无论如何连接，这一个贡献一定存在，且只会在这里计入
//（因为基环树的环已经唯一了），所以其他的任意连接均可。
int n,pw[N],dp[N][N];
struct tree{
	int to,nxt;
}e[2*N];
int a[N],fir[N],np,sz[N],num[N];
void add(int x,int y){
	e[++np]=(tree){y,fir[x]};
	fir[x]=np;
}
bool vis[N];
void dfs(int x){
	vis[x]=1;
	sz[x]=1;
	for(int i=fir[x];i;i=e[i].nxt){
		int j=e[i].to;
		if(vis[j])continue;
		dfs(j);
		sz[x]+=sz[j];
	}
}
signed main(){
	read(n);
	pw[0]=1;
	rep(i,1,n){
		pw[i]=pw[i-1]*n%mo;
		read(a[i]);
		if(a[i]!=-1)add(i,a[i]),add(a[i],i);
	}
	int cntt=0,ans=0;//cntt:-1的数量 
	rep(i,1,n){
		if(a[i]==-1){//先求树的数量 
			dfs(i);
			num[++cntt]=sz[i];
		}
	}
	rep(i,1,n){
		if(!vis[i]){//每做一次dfs就走了一个基环树，加上该点的贡献 
			dfs(i);
			ans=(ans+pw[cntt])%mo;
		}
	}	
	rep(i,0,cntt)
	    dp[i][0]=1;
	rep(i,1,cntt){
		rep(j,1,cntt){
			dp[i][j]=(dp[i-1][j]+dp[i-1][j-1]*max(j-1,1ll)%mo*num[i]%mo)%mo;//插入一棵新树时，乘插入点数和上一棵树连到这棵树上任意一个点的总数 
		//注意：当j=1时，插入点的方案数应该是1，不能乘0,；大于1时，插入点的方案数为j-1. 
		//	printf("%d %d:%lld\n",i,j,dp[i][j]);
		}
			
	}
	rep(i,1,cntt){
		ans=(ans+dp[cntt][i]*pw[cntt-i]%mo)%mo;
	}
	printf("%lld\n",ans);
	return 0;
} 
```