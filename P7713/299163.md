### 题意
奥运会一共有 $ n $ 个裁判，裁判的原始打分分别为 $ a_{1} $ ， $ a_{2} $ ， …  ， $ a_{n} $ 。 现在有 $ m $ 次操作机会，每次操作可以使得任意一个裁判的打分加 $ 1 $ 。请问在进行 $ m $ 次操作之后，去掉一个最高分，去掉一个最低分，剩下 $ n - 2 $ 个裁判的总分数最高是多少。

### 思路：贪心
先把 $ n $ 个裁判的原始打分从小到大排序。考虑到目标是让中间 $ n - 2 $ 个裁判的总分数尽可能高，因此我们的策略应该是**在加分的时候，应该是尽可能把分数加给中间 $ n - 2 $ 个裁判，但 _同时要保证不改变最高分和最低分的相对位置_ 。**

为了方便理解，举一个具体例子的不同操作思路（假设已经对 $ n $ 个裁判的原始打分进行排序）：

$ n =  4 $ ， 分数为 $ 1 $ $ 2 $ $ 2 $ $ 4 $ ， $ m = 4 $

①、 假设 $ 4 $ 次操作全部给打 $ 1 $ 分的裁判，分数变为 $ 5 $ $ 2 $ $ 2 $ $ 4 $ ，去掉最高最低，剩下 $ n - 2 $ 个裁判的总分数为 $ 6 $。

②、 假设 $ 4 $ 次操作全部给打 $ 4 $ 分的裁判，分数变为 $ 1 $ $ 2 $ $ 2 $ $ 8 $ ，去掉最高最低，剩下 $ n - 2 $ 个裁判的总分数为 $ 4 $。

③、 假设 $ 4 $ 次操作全部给中间两位裁判，分数变为 $ 1 $ $ 4 $ $ 4 $ $ 4 $ ，去掉最高最低，剩下 $ n - 2 $ 个裁判的总分数为 $ 8 $。**（最优）**

以上只是定性感受一下贪心的思路。可以发现给最低分裁判加分是没有意义的，所以我们的分数要尽量给到中间的裁判，同时保证最高分裁判依旧是最高分即可。接下来捋一下完整算法：

$ Step1 $ 读入全部原始打分，排序；

$ Step2 $ 查看 $ a_{2} $ ， …  ， $ a_{n - 1} $ 裁判分数与 $ a_{n} $ 裁判的分数是否相等，如果不等，可以通过操作调整为相等（此时的调整是不会影响最高分和最低分的相对位置的）；

$ Step3 $ 如果上一步结束之后，依旧有操作次数剩余，可以按照 $ a_{n} $ ， $ a_{n - 1} $ ， …  ， $ a_{2} $ 逆序逐个裁判分数加 $ 1 $ ，直到操作次数为 $ 0 $ （因为是逆序逐个加，所以此时的调整同样不影响最高分和最低分的相对位置，同时保证了尽可能多的加分落在了中间 $ n - 2 $ 个裁判身上）；

$Step4 $ 最后就是累加 $ a_{2} $ ， …  ， $ a_{n - 1} $ 个裁判的最终分数，就是答案了。

最终时间复杂度是排序产生的 $ O(nlogn) $ 。

### 代码
```cpp
#include <iostream>
#include <cstring>
#include <cstdio>
#include <algorithm>
using namespace std;

long long a[100005]; 

int main()
{
    long long n, m;
    scanf("%lld%lld", &n, &m);
    for (int i = 1; i <= n; i++) scanf("%lld", &a[i]);
    sort(a + 1, a + n + 1);
    long long diff = 0; // 记录a[2]~a[n-1]分别与a[n]的差值之和
    for (int i = 2; i <= n - 1; i++)
        diff += a[n] - a[i];
    if (m <= diff) // 如果m<=diff，可以全部加到a[2]~a[n-1]
    {
        long long ans = 0;
        for (int i = 2; i <= n - 1; i++) ans += a[i];
        cout << ans + m << endl;
    }
    else // 如果m>diff，先把a[2]~a[n-1]调整到与a[n]相同，再来处理剩余的操作次数
    {
        m -= diff;
        long long ans = a[n] * (n - 2);
        if (m / (n - 1)) // 计算剩余次数m够让a[2]~a[n]全部加1多少次
        {
            ans += m / (n - 1) * (n - 2);
            m -= m / (n - 1) * (n - 1);
        }
        if (m >= 2) ans += m - 1;
        cout << ans << endl;
    }
    return 0;
}
```
