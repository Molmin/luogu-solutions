## Content
某个人去参加比赛，$n$ 个评委分别给他打分 $a_1,a_2,\dots,a_n$。这个人可以最多执行 $m$ 次操作，每次操作将一个评委的分数加 $1$。定义他的最终分数为去掉一个最高分和一个最低分后的剩余得分的总和。求可能最高的最终分数。

**数据范围：$3\leqslant n\leqslant 10^5$，$0\leqslant m,a_i\leqslant 10^9$。**
## Solution
本题解我们来分 Subtask 来讲解。
### Subtask 1 (5 pts)：$m=0$
这一个部分分其实是很好拿的。我们只需要将所有评委的分数排个序，然后统计一下第 $2\sim n-1$ 个人的分数和即可。
### Subtask 2 (10 pts)：$n=3$
这个 Subtask 对于启发正解很有作用。

我们不妨先花费若干次操作，把第 $2$ 高的分数和最高的分数齐平。当然在这里如果就把操作数给用完了，那么就直接可以统计结果了。

如果第 $2$ 高的分数和最高的分数齐平了的时候，操作数还没有用完，我们就把剩余的操作数平均分成两份（如果多出了一份先丢在一边）。然后我们把这两份分别分给第 $2$ 高的分数和最高的分数。多出的一份无论分给谁都不会影响最终的结果，因此就可以直接输出第 $2$ 高的分数了。
### Subtask 3 (15 pts)：$n,m\leqslant 10^3$
这个 Subtask 你随便怎么暴力模拟应该都可以过，因此不做赘述。
### Subtask 4 (70 pts)：正解
我们回到 Subtask 2，受到其中均分的启发，我们不妨先让第 $2\sim n-1$ 高的分数和最高的分数齐平。当然在这里如果就把操作数给用完了，那么就直接可以统计结果了。

如果全部齐平了还没用完操作，我们就把剩余的操作数平均分成 $n-1$ 份（多出的分不出来的操作数先丢在一边，留做备用）。然后先把这 $n-1$ 份平均分给第 $1\sim n-1$ 高的分数，然后再去看是否多出的操作数。如果有多出的操作数，我们将一个操作数分给最高的分数，再将剩余的操作数随便分给第 $2\sim n-1$ 的分数中的任意几个（每个人分 $1$ 个操作数）就可以了。
## Code
```cpp
ll a[100007];

int main() {
	int n = Rint; ll m = Rll;
	ll ans = 0;
	F(int, i, 1, n) a[i] = Rint;
	sort(a + 1, a + n + 1);
	if(m) {
		F(int, i, 2, n - 1) {
			int add = min(a[n] - a[i], m);
			a[i] += add, m -= add;
		}
		int sum = m / (n - 1) * (n - 1), eve = sum / (n - 1);
		F(int, i, 2, n) a[i] += eve;
		m -= sum;
		if(m) {
			a[n]++, m--;
			F(int, i, 2, n - 1)
				a[i] = a[i] + min(1ll, m), m = max(m - 1, 0ll);
		}
	}
	F(int, i, 2, n - 1) ans += a[i];
	return write(ans), 0;
}
```