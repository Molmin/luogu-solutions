这里是一个亲民**且正确**的 AAAT 题解，着重于理解和实现，复杂度分析的话有点能力就可以去其他地方找到。（正确指不像隔壁 90 分手动适应数据）

首先有换根，还有换父亲，据 jerry3128 说这是强制 Link、Cut，必须上动态树，那我们先上一棵动态树来维护形态。

考虑信息的维护，我们的 LCT 可以做的是什么？Access，可以以一棵 Splay 的形态提取一条链。

那么链加链改链查我们都能处理了，只需要给 Splay 下放基本的标记即可，此题包含覆盖标记和加标记，这种一般的套路是先下放覆盖，再放加标记，覆盖标记会清空加标记。

再考虑子树信息，同样的我们用这两种标记下放修改操作，我们想将子树的标记下放下去，那么就得给所有的虚儿子都打上标记。

如果暴力遍历打上肯定不太行，虚儿子个数可能 $O(n)$，于是我们想到了用数据结构来维护往虚儿子丢的标记。

一种 naive 的想法就是上常用的线段树，于是我们可以做到 $O(1)$ 打标记，$O(\log)$ 将一个儿子从虚儿子中取出来（即变成了实儿子），$O(\log)$ 将一个点插入虚儿子中，并且能保证标记和信息的正确性。

但是众所周知 LCT 本质是虚实边剖分，虚实儿子的切换本身就是 $O(\log)$ 的复杂度，而套上 Splay 后还是 $O(\log)$ 是由于 Splay 的势能是均摊的，一次 Access 中 Splay 的势能增加总和为 $O(\log)$ 才并不影响复杂度。

而线段树并不能这样摊复杂度，它切换一次儿子的复杂度就是 $O(\log)$，于是复杂度为 $O(\log^2)$，不太行。（并不是指不能做，jerry3128 已实现了这种做法，只是复杂度不优秀） 

所以我们需要一种在维护虚儿子的同时能均摊复杂度的数据结构，参考 LCT，一种自然而然的想法就是上 Splay，复杂度能摊进一次 Access $O(\log)$。

同样的可以上其他可以摊的数据结构如 Leafy Tree，好像隔壁的魔改 LCT 就是这种实现，但与本题解无关。

做法也就自然而然的出来了，相当于在一般的 LCT 上加了 Splay 来维护虚儿子的标记下放，接下来讲两种实现：

------------

实现 1：添加虚点，相当于转每条虚边为虚点，本来虚边连接的是一棵 Splay 的顶和另一个 Splay 的某个点。

现在中间多了一个虚点，我们将虚点用 Splay 的形态堆起来，也就是堆成一个二叉树，但操作都像 Splay 那样操作。

这样的话一个实点会有两个实点儿子，一个虚点儿子，虚点儿子即为虚点堆起来的 Splay 的根。

一个虚点有两个虚点儿子，一个实点儿子，实点儿子即为虚边连接的那个儿子。

如果你想更直观的感受的话可以看成三叉的 LCT，其中两叉是正常的 Splay，另一叉是特殊的连接另一种点的边。

结构大概就是这样，代码实现是特别方便的，可以避开很多特殊处理，主要原因是虚点和实点直接相连，信息的上传和标记的下放像正常的 Splay 做即可。

通常的实现可能写成四叉树，即虚实儿子都两个，既让虚实儿子结构差不多方便写代码，~~又参考了 Top Tree 的写法让常数更小~~。（其实并不清楚常数会怎么样，可能多维护了一叉可能会变大吧？）

具体的，Access 要做的就是在实儿子里面 Splay 到父亲是虚儿子，再 Splay 虚儿子到实儿子下面更新下放标记。

代码的话用 AAAT 做这道题的很多人都是这样实现的，反正我见到的大多是这样，随便去贺一份代码参考即可。

------------

实现 2：对于每个点的虚边独立的维护一棵 Splay，与上面的区别在于虚边的 Splay 和 LCT 中的完全独立开来，互相不影响。

优势就是刚说的，完全独立，可以分开维护信息~~和调错~~。

劣势就是有亿些特殊处理，原因是虚点和实点不直接相连，所以虚实切换的时候就得手动特殊处理，~~两个互相独立的 Splay 互相切换就是两倍的码量~~。

简单来说就是：代码思路是清晰的，代码实现是毒瘤的。

现身说法：![](https://cdn.luogu.com.cn/upload/image_hosting/b1lav7et.png)

------------

选择第二种实现还有一个好处，就是我帮你扫了一圈雷，你可以参考我走的路线来做，**但我的实现也只是一种平凡的实现**，你可以有更神仙的。

注意：以下是我平凡的实现，实现方法并不唯一。

首先考虑实 Splay，要上传的信息分为两种，当前这棵实 Splay 的信息和，和这棵实 Splay **下**（不包含当前的实 Splay）所有的信息和。

一棵 Splay 其实代表一条链，那么也就相当于刨开一条链的子树信息和，由所有实儿子的虚 Splay 上传而来。

要维护这两个信息我们还得维护一个节点的所有虚儿子的信息和，由它对应的虚边 Splay 的根传信息上来。

然后上传的信息就完了，只不过有 $\operatorname{sum},\max,\min$ 这三种信息，~~三倍也就复制两次~~。

下放标记好像说过了，先下放覆盖标记，再放加标记，覆盖标记会清空加标记，加标记不对覆盖标记造成影响。

然后就是虚实切换的细节，我们 Access 一直都在实 Splay 上走，其实要考虑的就是一次实 Splay 两边虚 Splay 上的变化。

首先是对上面一棵 Splay 的影响，当前的 Splay 根变了，我们先把当前根在虚 Splay 上旋到顶，然后把当前根替换为新根。

对下面一棵 Splay 的影响就是喜闻乐见的虚 Splay 插入删除基本操作。

还有就是虚实节点有所不同的细节，实点下传标记要修改当前值，但虚点承载的其实只是标记，而并非值，所以只是修改信息，要注意下传的区别。

最后就是操作的细节，也就换父亲有点操作，因为涉及到判断同一个子树，也就涉及到 Splay，记得跟着修改虚 Splay 里面的信息即可。

最后的最后，建议实 Splay 先写 LCT 或贺 LCT 板子，虚 Splay 用 assert 把结构上的要求摆出来，基本结构上就~~不会错~~很好改了。

然后标记和信息只能输出中间变量或参考题解改改。

这里补一个下放标记的细节，据说本机房有一个90分 `WA on 8` 的是因为这里挂了：

如果本实 Splay 里面没有虚儿子了就不能动整个当前 Splay 下的信息，如果本节点没有虚儿子就不能动虚儿子信息。

如果动了的话可能出现 $\pm\infty\to v$，其中 $v$ 是赋值操作的值。

我好像在0分 WA 的时候就扫到了这个雷并排掉了，我改出来后在机房里预言了一波这个坑很大能陷一车人结果真中了。。。

[代码](https://www.luogu.com.cn/paste/iarde391)，如果有不清楚我为什么这么写的，或是我没说清楚的，都可以来问我。