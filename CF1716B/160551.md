# 题目翻译
当序列 $a$ 中的第 $i$ 个元素满足 $a[i]=i$ 时，我们说这个元素具有固定性。  
长度为 $n$ 的排列是从 $1$ 到 $n$ 的整数序列，且每个元素都具有固定性。  
对于第 $i$ 个数的操作，我们可以交换任意两个数的位置，并且要满足，每一次操作过后得到的新序列中具有固定性的点的数量变少，请构造一组数据，由序列 $n$ 经过 $x$ 次操作得到，使 $x$ 最大。  
原序列和每一次操作后得到的序列（共 $x+1$ 个序列），一起构成了置换链。
### 输入
第一行：一个整数 $t(1\leq t \leq 99)$ 表示数据的组数。  
第 $2$ 到第 $t+1$ 行，每行一个整数 $n$ 表示序列长度。
### 输出
对于每一组数据：  
第一行输出置换链中序列的个数 。  
之后每行输出置换链中的一个序列。
# 分析
首先，第一次交换，一定会使两个元素不具有固定性。  
之后的每一次交换，可以选择交换两个没有被交换过的数，也可以选择交换一个没被交换过的数和一个被交换过的数。  
前者会使两个数不具有固定性，后者会使一个数不具有固定性，然而我们要找到最多的交换次数，所以每次我们选择后者。  
通过上面的分析，我们发现，最多的交换次数就是 $n-1$ 次（ $n$ 为序列长度），那么一种可行的方案就是先交换第一个和第二个元素，之后从第 $2$ 个元素开始，每次交换第 $i$ 个数和第 $i+1$ 个数。
# 代码实现
```
#include <bits/stdc++.h>
using namespace std;
const int MAX=110;
int n,a[MAX];
int main(){
	int t;
	scanf("%d",&t);
	for(int k=1;k<=t;k++){
		scanf("%d",&n);
		printf("%d\n",n);
		for(int i=1;i<=n;i++){
			a[i]=i;
			printf("%d ",i);
		}
		printf("\n");
		for(int i=1;i<=n-1;i++){
			swap(a[i],a[i+1]);
			for(int j=1;j<=n;j++){
				printf("%d ",a[j]);
			}
			printf("\n");
		}
	}
	return 0;
}
```
