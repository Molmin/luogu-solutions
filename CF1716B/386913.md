场上被聪明的谷歌翻译搞到了，看懂题意之后应该是各位都能一眼秒掉的题目吧。

### 题意简述：

对于一个长度为 $n$ 的排列 $p$，若 $a_i=i$，则称其为“置换的不动点”。

现在给你一个整数 $n$，且 $a_1=[1,2,3,\dots,n]$，你需要构造出一个最长的序列 $a_1,a_2,a_3,\dots$ 。使得对于每一个 $2 \leq i$ 都有 $a_i$ 中“置换的不动点”的数量严格大于 $a_{i-1}$ 中“置换的不动点”的数量。如果有多种构造方案，输出任意一种。

### 思路分析：

很简单。

由于第一次交换时一定会使“置换的不动点”的数量减少两个，之后每一次操作都会使“置换的不动点”的数量减少一个，并且刚开始“置换的不动点”的数量为 $n$ ，那么想要使得最后的时候 “置换的不动点”的数量最少也就是为 $0$，最多只能进行 $n$ 次操作，每次操作交换相邻两个数字就行。

为什么如何理解每次操作交换相邻两个数字就行？

很简单，举个例子就明白了：

假设 $n=5$：

则 $a_1=[1,2,3,4,5] \ \text{fixedness}=5$

$a_2=[2,1,3,4,5] \ \text{fixedness}=3$

$a_3=[2,3,1,4,5] \ \text{fixedness}=2$

$a_4=[2,3,4,1,5] \ \text{fixedness}=1$

$a_5=[2,3,4,5,1] \ \text{fixedness}=0$

显然的，这样子就可以使第一次交换时使“置换的不动点”的数量减少两个，之后每一次操作使“置换的不动点”的数量减少一个，使序列最长。

当然，只要满足第一次交换时一定会使“置换的不动点”的数量减少两个，之后每一次操作都会使“置换的不动点”的数量减少一个，就可以使序列最长。

### 完整代码供参考：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int maxn = 105;
int n, a[maxn];
signed main() {
	int T = 1;
	cin >> T;
	while (T--) {
		cin >> n;
		cout << n << endl;
		for (int i = 1; i <= n; i++) {
			a[i] = i;
			cout << a[i] << " ";
		}
		cout << endl;
		for (int i = 1; i <= n - 1; i++) {
			swap(a[i], a[i + 1]);
			for (int j = 1; j <= n; j++) {
				cout << a[j] << " ";
			}
			cout << endl;
		}
	}
	return 0;
}
```