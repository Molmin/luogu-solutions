### 样例中 $n$ 为 $3$ 时 ——

$a[1]$ = $[1,2,3]$ , $a[2]$ = $[1,3,2]$ —— 这是一个有效的长度链 2 。 从 $a[1]$ 自 $a[2]$ ，位置上的元素 $2$ 和 $3$ 交换下，固定性从 $3$ 自 $1$.

$a[1]$ = $[2,1,3]$ , $a[2]$ = $[3,1,2]$—— 这不是一个有效的链 。第一个排列应始终为 $[1,2,3]$ ，$n$ = $3$.

$a[1]$ = $[1,2,3]$ , $a[2]$ = $[1,3,2]$ , $a[3]$ = $[1,2,3]$ —— 这不是一个有效的链。从 $a[2]$ 自 $a[3]$ ，位置上的元素 $2$ 和 $3$ 被交换，但固定性从 $1$ 自 $3$ .

$a[1]$ = $[1,2,3]$, $a[2]$ = $[3,2,1]$, $a[3]$ = $[3,1,2]$ —— 这是一个有效的长度链 3. 从 $a[1]$ 自 $a[2]$ ，位置上的元素 $1$ 和 $3$ 换下，固定性从 $3$ 自 $1$ . 从 $a[2]$ 自 $a[3]$，位置上的元素 $2$ 和 $3$ 换下，固定性从 $1$ 自 $0$ .
# 解题思路
给定一个长度为 $n$ 数列链 $a[ ]$， 最开始输出 $n$。

最开始的数列是从 $1$ ~ $n$ 最优，接下来每一次交换原数组的相邻两个元素（建议用 $\verb!swap!$ 函数），产生新的数列。

从 $a[n]$ 和 $a[n - 1]$ 开始交换，重复递减操作，直到交换到 a$[1]$ ，共交换 $n$ 次，每次都要输出新数组。
# 上代码——
```
#include<bits/stdc++.h>//万能头文件
using namespace std;
const int N = 1e2 + 5;//定义常量，N相当于105
int t, n, a[N], count;//count表示交换元素的下标
#define f(i, j, k) for (int i = j; i <= k; i ++)//宏定义
int main()
{
	scanf("%d", &t);
	while(t --)//多组数据
	{
		scanf("%d", &n);
		count = n;
		printf("%d\n", n);//先输出n
		f(i, 1, n) 
			a[i] = i;//数组a[]初始化
		f(j, 1, n)
		{
			f(i, 1, n) 
				printf("%d ", a[i]);//输出新数组
			swap(a[count], a[count --]);//交换a[count]和a[count --]的值
        	printf("\n");//记得换行
		}
	}
	return 0;
}
```