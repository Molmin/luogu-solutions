### 1. 简述题意

给定一个长度为 $n$ 的序列 $a_1$，每次操作可以交换序列中任意两个元素，每操作一次就生成一个新的序列 $a_i$，要求使得序列 $a_i$ 的固定性严格小于序列 $a_{i-1}$ 的固定性，且使得固定性减小最慢。

定义一个序列的固定性为序列中 $a_i=i$ 的元素的个数。

### 2. 思路

一眼题，**贪心**。

首先我们很容易知道，第一次无论交换哪两个元素，都会使得 $a_1$ 的固定性减 $2$。

既然我们想让固定性减小最慢，那么我们就要考虑：每次交换的两个元素都要有什么特点？

显然，想让固定性减小最慢，每次固定性一定只减小 $1$。

那么我们每次就可以交换一个 $a_i≠i$ 的元素和另一个 $a_i=i$ 的元素。

进一步可知，我们每次只需交换相邻的两个元素即可。

如果仍不能理解，可以看看下面举的例子。

e.g. $n = 7$

$a_1=[1,2,3,4,5,6,7]$，固定性为 $7$。

$a_2=[2,1,3,4,5,6,7]$，固定性为 $5$。

$a_3=[2,3,1,4,5,6,7]$，固定性为 $4$。

$a_4=[2,3,4,1,5,6,7]$，固定性为 $3$。

$a_5=[2,3,4,5,1,6,7]$，固定性为 $2$。

$a_6=[2,3,4,5,6,1,7]$，固定性为 $1$。

$a_7=[2,3,4,5,6,7,1]$，固定性为 $0$。

### 3. 代码

```cpp
#include <cstdio>
#define N 105
int t, n; int a[N];
inline void swap(int &a, int &b){ //使用位运算交换两个元素的值
    a ^= b ^= a ^= b;
}
int main(){
    scanf("%d", &t);
    while (t--) {
        scanf("%d", &n);
        printf("%d\n", n);
        for (int i = 1; i <= n; ++i) { //赋值并输出原始序列
            a[i] = i;
            printf("%d ", a[i]);
        } puts("");
        for (int i = 1; i < n; ++i) { //每次交换相邻两个元素的值
            swap(a[i], a[i + 1]);
            for (int j = 1; j <= n; ++j) //输出处理过的序列
                printf("%d ", a[j]);
            puts("");
        }
    }
    return 0;
}
```