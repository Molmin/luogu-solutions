这道题是我们要将 $n$ 个数选若干个数分成两组，第一组需要满足每个数都不同，第二组需要满足每个数都相同，而且我们要求第一组和第二组的数的个数都相等，问你它们每组的数的个数最大是多少？？？

如果我们满足第一组的条件的话，会发现第一组的数的个数最多为这 $n$ 个数不同的数的个数，如果我们满足第二组的条件的话，会发现第二组的数的个数最多为这 $n$ 个数中一个数出现的最多次数，那么如果两组须同时满足，我们就可以在第一组中先将这 $n$ 个数中不同的数都只取一个，第二组可以把这 $n$ 个数中一个数出现的最多次数的那个数全放到第二组，但是有一个矛盾的条件，第一组需要的数中，第二组也需要，在这里我们把只考虑第一组的数的个数的最大值设为 $x$ ，把只考虑第二组的数的个数的最大值设为 $y$。这种情况其实出现在 $x=y$ 时，因为要想相等，第一组的数肯定将所有不同的数全取一遍，这样的话原先的 $y$ 就减去了一个 $1$，这样的话我们的答案就要相应的减 $1$。其他情况都可以直接取 $x$ 和 $y$ 的最小值就可以了，因为当 $x>y$ 时，那么第一组只能取 $y$ 个，它完全可以不取出现次数最多的那个数。第二组直接把出现次数最多的那个数全取完就可以了，这样互不干扰。当 $x<y$ 时，第一组把所有不同的数都取了一个，就算出现次数最多的数减少了 $1$ 个，也不影响它在出现次数最多的那个数中能取出 $x$ 个来，所以两个也互不干扰。

至于判断不同的数有多少个和一个数出现的最多次数，你可以直接使用 sort 排序，然后扫一遍序列进行操作就搞定啦！！！放心，不超时，可放心食用！！！

**注意多组数据！！！**

时间复杂度：$O(\sum{n \log n})$

# code:
```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
int a[200005];
int main(){
    int t;
    scanf("%d",&t);
    while(t--){
        int n,i,sum=0,maxn=0,t=0;
        scanf("%d",&n);
        for(i=1;i<=n;i++){
            scanf("%d",&a[i]);
        }
        sort(a+1,a+n+1);
        for(i=1;i<=n;i++){
            if(a[i]!=a[i-1]){
                sum++;
                maxn=max(maxn,t);
                t=1;
            }
            else{
                t++;
            }
        }
        maxn=max(maxn,t);
        if(maxn>sum){
            printf("%d\n",sum);
        }
        else{
            if(maxn==sum){
                printf("%d\n",sum-1);
            }
            else{
                printf("%d\n",maxn);
            }
        }
    }
    return 0;
}
```
