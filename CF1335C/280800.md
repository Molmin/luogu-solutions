## 题目翻译
有$n$个小朋友，第$i$个小朋友的技能值为$a_i$，现在请你把这$n$个小朋友分$2$组，这个分组必须满足以下条件：
- 两组小朋友必须人数相同
- 第一组小朋友的技能值必须不同
- 第二组小朋友的技能值必须相同

举个栗子：

- 当分组为$[1, 2, 3]$和$[4, 4]$时，这就是一个**不正确**的分组，因为第一组和第二组人数不同；
- 当分组为$[1, 2, 3]$和$[3, 3, 4]$时，这就是一个**不正确**的分组，因为第二组小朋友技能值不同；
- 当分组为$[1, 1, 2]$和$[3, 3, 3]$时，这就是一个**不正确**的分组，因为第一组小朋友的技能值相同。
- 当分组为$[1, 2, 3]$和$[3, 3, 3]$时，这就是一个**正确**的分组，因为第一组小朋友技能值不同，第二组小朋友技能值相同。
- 当分组为$[5]$和$[6]$时，这就是一个**正确**的分组。

你需要计算出，第一组小朋友最多能有多少个人。**有些小朋友可以不在分组里。**

**数据范围**：
$a_i\le n \le 2\times 10^5$
## 题目分析
划重点：**有些小朋友可以不在分组里。**

首先需要找到两个值：有多少种不同的技能值$x$，**相同的技能值的数量最大值**$y$。

粗体字可能比较难理解，举个栗子：

例如这$n$个小朋友技能值分别是```1 1 1 1 1 2 2 2 3 4 5```，那与$1$相同技能值的数量就是$5$，与$2$相同的技能值就是$3$。我们就只需要知道这个最大值，在这个栗子中，$y=5$。

那么，接下来一共有$3$种情况：
- $x<y$，这时候不同的比相同的少，就可以把相同的分为一组，然后把$y$个不同的之中选$x$个分到另一组（因为有些小朋友可以不给他分组），第一组有$x$个人。
- $x=y$，这时候比较特殊，也许你会想说$x$个分为一组，$y$个分为一组。但是我们的$x$是不同的技能值数量，是包括那个$y$的。就像在上面那个例子，$x=y=5$。但是并不是把$[1,1,1,1,1]$一组，$[1,2,3,4,5]$一组，因为这样就是无中生$1$了。所以只应该选择少$1$个，所以第一组应该有$x-1$个人。
- $x>y$，这时候相同的人数比不同的多，就可以把所有不同$y$个人的分为一组，再从选择$x$中选择$y$个人即可。

也许你又迷惑了，$x,y$怎么求呢？

注意数据范围：$a_i\le 2\times 10^5$，桶排有请~
## 示例代码
```cpp
#include <iostream>
using namespace std;
int t,n,x,kind,maxtong;				//x是一会要输入的tmp，kind就是上文说的y，maxtong就是上文说的x
const int maxn = 200005;
int tong[maxn];						//桶~
int main(){
	cin>>t;
	while(t--){
		kind=maxtong=0;						//有多组数据，要清零
		cin>>n;
		for(register int i=1;i<=n;++i){
			cin>>x;
			if(!tong[x]++)++kind;
			//可以改写为
			/*
        if(!tong[x])++kind;				//如果这个技能值没见过，就把y++
        tong[x]++;						//桶值++
        */
		}
		for(register int i=1;i<=n;++i)
		maxtong=max(maxtong,tong[i]);		//桶中找最值
		if(maxtong == kind)					//分析都有了
			cout<<(kind-1);
		else if(maxtong > kind)
			cout<<kind;
		else
			cout<<maxtong;
		for(int i=1;i<=n;++i)				//多组数据，要清零
		tong[i]=0;
		cout<<endl;							//十年cf一场空，不打换行见祖宗
	}
	return 0;
}
```