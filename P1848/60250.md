emmm 这个题目肛了一个晚自修写出来（不包括思考过程）
主要思路楼上讲的很清楚吧，所以我就随便讲讲

简单的dp方程还是比较好想的但是n方的时间显然过不了
### f[i]=min(f[j]+max(h[i]....h[j])) sum[i..j]<=L
于是考虑优化以下分好几个点

------------
### 考虑到max(h[i])是一段段变化的可以合并且 f 单调不减因此只需考虑h[i]变化的点，即决策点 故有两种维护方法
#### 1.单调栈+二分位置
#### 2.对当前i位置的单调队列（保留最开始元素即head<tail不取等）
反正各有所爱吧，~~个人喜欢单调队列一点~~

### 然后在max(h[i]) 维护好的前提下f 的 dp只要考虑决策点且满足单调性
#### 1.数据结构 线段树（支持单点修改）~~暴力~~塞入决策点数据
#### 2.STL multiset 也是维护最小值取*begin（同样暴力塞进去）
#### 3.heap 小根堆（反正就是维护最小值嘛）差不多其实不过快一些，好像楼上都没讲到
#### 4.然后翻了一下看到还有一个方法就是写priority_queue看到一个神仙跑得飞快不吸氧200毫秒很可怕啊蒟蒻自叹不如


------------

最后么就是在最前面决策点不符合条件时往后移动一位(两个元素不相邻否则直接队头后移)，我的顺序是先更新队列然后删点再更新f

然后吐槽以下调试过程stl真的难调试 **哭**还有我自己的代码单调队列出问题了看一下机房神仙代码**玄学**一步看不懂啊很难受 线段树不怎么我的菜，**代码就不写了**，好像都差不多，顺便膜一下
### [神仙](https://www.luogu.org/space/show?uid=35069)rank 1 巨秀 瞬间秒掉20分钟敲完一遍A怀疑人生。。。还好写线段树比我stl慢~~嘻嘻嘻~~