**题目大意**：一栋公寓有$n$层，每层$m$户，每户有两扇窗，“$0$”代表窗没亮着，“$1$”代表窗亮着，问一共有多少**户**的窗亮着。 

------------
一开始，我没看清楚题目，以为是要求有多少扇窗户开着，打出了以下代码：  
```
#include<bits/stdc++.h>
using namespace std;
int main()
{
    int a,b,c,ans=0;
    scanf("%d %d",&a,&b);
    for(int i=1;i<=a*b;i++)
    {
        scanf("%d",&c);
        if(c)ans++;
    }
    printf("%d",ans);
    return 0;
}
```
结果显而易见，第一个测试点就$\texttt{\red{WA}}$了。我有重新看了一遍题目，要求多少**户**的窗户是开着的。其实，输入的$n$和$m$没有什么用，只用两个两个读入数字，然后判断这两个数字中有没有“$1$”就可以了，如果有“$1$”，计数器就加$1$，最后输出计数器的值即可。

------------
代码如下：
```
#include<bits/stdc++.h>
using namespace std;
int main()
{
    int a,b,c,d,ans=0;
    scanf("%d %d",&a,&b);
    for(int i=1;i<=a*b;i++)
    {
        scanf("%d %d",&c,&d);
        if(c|d==true)ans++;
    }
    printf("%d",ans);
    return 0;
}
```
------------
**知识点**：

$|$是或运算符，和它类似的还有$\And$与运算符和$\oplus$异运算符。    
首先，我要澄清一点，那就是，在C++中，任何不是$0$得数都被认为是真的，任何等于$0$的数都是假的。对于这一点，部分人有误区，他们认为负数也是假的，但实际上，任何不等于$0$**都是真的，包括负数**。  
1.  $|$的运算规则是：$0|0=0,1|0=1,1|1=1$，其中$0$是指对应假的值，$1$是指对应真的值，但是，如果有负数参加$|$运算，需要先求出它的补码，再进行计算。  

2.  $\And$的运算规则是：$0\And0=0,1\And0=0,1\And1=1$，其中$0$是指对应假的值，$1$是指对应真的值。  

另：特殊用法：  

- 清零。  
方法：如果想将一个单元清零,只要与一个各位都为零的数值相与，结果为零。  
- 取一个数中指定位。  
方法：找一个数，对应$\text{X}$要取的位，该数的对应位为“$1$”，其余位为“$0$”，此数与$\text{X}$进行“与运算”可以得到$\text{X}$中的指定位。例如，设$\text{X}=10101110$，取$\text{X}$的低$4$位，用$\text{X}\And 00001111=00001110$即可得到。  

3.  $\oplus$的运算规则是：$0\oplus 0=0,1\oplus 0=1,1\oplus 1=0$，其中$0$是指对应假的值，$1$是指对应真的值。   
交换律：$A\oplus B=B\oplus A$  
结合律：$A\oplus B\oplus C=A\oplus (B\oplus C)=(A\oplus B)\oplus C$  
自反律：$A\oplus B\oplus B=A\oplus 0=A$  
另：$A\oplus A=0 ,A\oplus 0=A$  

另：特殊用法：  

- 相异或，保留原值。例如$X\oplus 00000000=10101110$。  
- 使特定位翻转。找一个数，对应$\text{X}$要翻转的各位，该数的对应位为“$1$”，其余位为“$0$”，此数与$\text{X}$对应位异或即可。例如，$\text{X}=10101110$，使$\text{X}$低$4$位翻转，用$\text{X}\oplus 00001111=10100001$即可得到。
