依据贪心的思路，我们理应选择$5$个最大的数并对其作乘积。

但是我们发现，负负得正，最小的数也有可能在这$5$个数之列。

但是负负得正也是有条件的，只有这五个数中有偶数个负数时才是正数。

所以这五个数中显然只可能有$0,2,4$个负数，另外需要注意的一点是，取负数也需要尽量取绝对值最大的负数，所以我们直接从最小值开始取即可，所有的可能情况为：

* $1,$取五个最大的数

* $2,$取三个最大的数和两个最小的数

* $3,$取最大的数和四个最小的数

这些情况分别对应取$0,2,4$个负数。

至此，本题就做完了，需要注意的一点是：数组无序，需要先将其```
sort```成升序。

代码短到离谱：

```cpp
#include <bits/stdc++.h>
using namespace std;
long long T, a;
long long b[500005];
int main()
{
    cin >> T;
    while (T--)
    {
        cin >> a;
        for (int i = 1; i <= a; i++)
            cin>>b[i];
        sort(b + 1, b + a + 1);
        cout << max(max(b[1] * b[2] * b[3] * b[4] * b[a], b[1] * b[2] * b[a] * b[a - 1] * b[a - 2]), b[a] * b[a - 1] * b[a - 2] * b[a - 3] * b[a - 4]) << endl;
    }
}
```
