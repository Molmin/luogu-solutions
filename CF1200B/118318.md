**显然，我们要想让自己能跳到最后一根柱子，就要让当前背包里的砖块个数越多越好。**

因为捡砖块是可以进行无限次的，而且没有耗费，但是搭砖块是要耗费你背包里的砖块的，所以你背包里的砖块要越多越好。

现在考虑一下从第 $i$ 根柱子跳到第 $i+1$ 根柱子上。

分两种情况讨论：

1. 如果你当前的高度 $h_i$ 比下一根柱子的最低跳跃范围大，即 $h_i>h_{i+1}-k$，那么你就可以捡砖块。

	这个时候考虑如何才能捡到最多的砖块，那当然是一直捡到当前高度为 $h_{i+1}-k$ 最赚啊。
    
    这时一共捡了 $h_i-(h_{i+1}-k)$ 个砖块，又可以完美跳到下一根柱子。

1. 如果你当前的高度 $h_i$ 比下一根柱子的最低跳跃范围小，即 $h_i<h_{i+1}-k$。

	那么显然你要搭砖块，而且背包里的砖块只减不加，所以考虑怎么样才能使耗费最小。
    
    显然当你达到 $h_{i+1}-k$ 的高度时，不仅能跳到下一根柱子，而且耗费最小。
    
那么把二者结合到一起，我们就可以算出从第 $i$ 根柱子跳到第 $i+1$ 根柱子上后，背包的增减量是多少：

$$bag_{new}=bag_{old}+h_i-(h_{i+1}-k)$$

然后再看一下背包内的砖块个数是否为负的就好了。如果是负的，就说明背包内的砖块不够用，输出 NO 就好了。

**这道题有一些比较坑细节，代码中的注释会说明。**

完整代码加注释如下：

```cpp
#include<bits/stdc++.h>
 
#define N 110
 
using namespace std;
 
int t,n,bag,k,h[N];
bool flag;
 
int main()
{
	scanf("%d",&t);
	while(t--)
	{
		flag=false;//记得初始化
		scanf("%d%d%d",&n,&bag,&k);
		for(int i=1;i<=n;i++)
			scanf("%d",&h[i]);
		for(int i=1;i<n;i++)
		{
			int x=min(h[i],h[i]-(h[i+1]-k));//这里加个min是因为如果h[i+1]-k小于0那么最多只能跳到0
			bag+=x;
			if(bag<0)
			{
				flag=true;
				break;
			}
		}
		if(flag)//最后这里也要判断一下
			puts("NO");
		else
			puts("YES");
	}
	return 0;
}
```
