#### 一、题目大意

对于一个长为 $n\ge 2$ 的只由 `A` 和 `B` 组成的字符串 $S[1…n]$，定义 $f(S)$ 是 $S$ 中从左到右所有 `A` 右边的第一个字符组成的字符串加上 $S$ 中从左到右所有 `B` 右边的第一个字符组成的字符串。由于 $S$ 中除了最右边的字符之外右边都有字符，所以 $f(S)$ 的长度为 $n-1$。

$T$ 组数据，给出 $S$，将 $S$ 反复执行 $S\to f(S)$ 直到 $S$ 长度为 $1$，问你最后的这个字符是 `A` 还是 `B`。

- $\sum n\le 3\times 10^5$

#### 二、做法

神仙思维题。

首先暴力模拟显然是 $O(n^2)$ 的。

然后下面是正解。
我们针对字符串 $S[1…n]$ 的最后一个字母进行讨论：

$(1)$ 如果 $S_n$ 是 `A`。

1. $S$ 中没有 `B`。答案一定是 `A`。

2. $S$ 中有 `B`。我们假设 `B` 最后一次出现是 $S_i(i<n)$。那么我们就有 $S[i+1…n]$ 全部都是 `A`。又因为 $f(S)$ 的最后一个字符就是这个 `B` 的右边第一个字符，所以 $f(S)$ 的最后一个字符也是 `A`。

于是反复操作到最后，剩下的字符一定是 `A`。

$(2)$ 如果 $S_n$ 是 `B`。

1. $S$ 中没有 `A`。答案一定是 `B`。

2. $S$ 中有 `A`。然后考虑 $S_n$ 是 `B` 时 $f(S)$ 的最后一位是 `A` 的情况。

	不难发现必要条件是存在 $i$ 使 $S_i=$`B` 并且 $S_{i+1}=$`A`。这是因为，如果不存在 $i$ 使 $S_i=$`B` 并且 $S_{i+1}=$`A`，那么由于有 `A`，所以一定是一段 `A` 加上一段 `B`。容易知道每次操作后都是一段 `A` 加上一段 `B`，最后一次操作后一定只剩下 `B`。

   然后如果存在 $i$ 使 $S_i=$`B` 并且 $S_{i+1}=$`A`，那么 $S$ 一定是形如 `…BA…AB…B` 的结构，即从后往前看，是一段 `B`，加上一段 `A`，前面再跟着一个 `B`。然后我们知道，这样的话，$f(S)$ 是 `…AB…B`。并且每操作一次末尾连续的 `B` 的个数都会减少 $1$。所以在它在长度变为 $1$ 之前一定会转换成一个结尾是 `A` 的字符串。最后一次操作后一定只剩下 `A`。
   
然后我们依照这些讨论写出代码即可。

#### 三、代码

注意代码里的 $S$ 下标从 0 开始。

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
string s;
ll t,n,fl;
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	cin>>t;
	while(t--){
		cin>>n>>s;fl=0;
		for(ll i=1;i<n;i++)
			if(s[i-1]=='B'&&s[i]=='A')fl=1;
		cout<<(fl?'A':s[n-1])<<'\n';
	}
	return 0;
}
```