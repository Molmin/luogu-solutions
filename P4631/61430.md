> Update on 2020.10.8：添加了一些参考链接。

希望看到这一篇帮忙顶一下，不然真就全网人类智慧 kdt 泛滥了。。。

有两个 **复杂度正确** 的解法哦！

代码详见 https://www.luogu.com.cn/paste/tlbnzyno

### Description

给定平面上的 $n$ 个圆，用三个参数 $(x, y, R)$ 表示圆心坐标和半径。

每次选取最大的一个尚未被删除的圆删除，并同时删除所有与其相切或相交的圆。

最后输出每个圆分别是被那个圆所删除的。

### Hint

- $1\le n\le 3\times 10^5$
- $0\le |x|, |y|, R \le 10^9$

### Solution 1

后来在 Codeforces 上找到的官方题解 [Link here](http://codeforces.com/blog/entry/59650)。如果对题解中某些说明无法理解可以参考上述内容。做法参考：[Link here](https://www.cnblogs.com/clrs97/p/10340285.html#4662153)。

有一个非常简单的 $O(n^2)$ 暴力，由于每次都要扫一遍所有圆所以复杂度爆炸。

我们尝试剪枝，缩小枚举的范围。

若当前最大圆的半径为 $R$，那么我们做一个分块操作：将整个平面 **划分为一个个方格**，方格的边长为 $2R$，刚好“框住”这个最大圆。

对于当前这个圆，我们只要搜索 **其所在格子及其相邻的** 即可（两个格子相邻定义为所在行的距离不超过 1，且列距离也不超过 1，换言之，一个格子所有相邻的就是周围一圈 8 个）。显然这样是不会漏记的，因为所有圆的半径都不超过方格大小，那么一定不会出现两个圆相交或相切，但却不在相邻两个方格内。

但我们总不能每次都搜怎么大的格子，最大圆的大小如果非常大而其他圆又很小的话这个剪枝没有丝毫用处。因此我们引入一个 **重构机制**：设现在考虑到的圆的半径为 $R^\prime$，原来方格大小为 $L$。若 $R^\prime < L$，那么 **重构整个方格**，并以 $2R^\prime$ 作为新的方格大小 $L$。

重构的复杂度会不会有问题？观察到，当半径不足方格大小的一半时才会重构，重构之后如果又来一次那又得一半。于是整个算法不会有超过 $O(\log R)$ 次重构，而一次重构的复杂度可以达到 $O(n\log n)$（排序时重构，搜索时二分），所以总共最多也就两只 $\log$，不会有问题。

可以证明每个圆被检查的次数为常数。因为对于一个圆，一个方格中不会有太多的大小相似的大圆对它进行检查，这些大圆会在之前就会被互相消除掉。

总复杂度为 $O(n\log n\log R)$。

但其实重构是可以做到一次 $O(n)$ 的，这样复杂度就是优秀的 $O(n(\log n+\log R))$。具体可以参考上述链接。

### Solution 2

*虽然也是有理有据的 $\log^2$ 但跑的真的很慢。* 做法参考：[Link here](https://www.cnblogs.com/ywwyww/p/9083228.html)。

对于一个圆 $(x, y, R)$，考虑如何得到比它大的与之相交或相切，并且 **不是因为其他圆而被带走的圆**。

这些圆之间 **不可能又有公共部分**，否则它们之间会互相消除。

有一个比较显然的东西：这些圆一定在矩形 $(x-R, y-R) \sim (x + R, y + R)$ 的 **边框** 上。不会出现在内部是因为这些圆是比当前圆大的。

对于 $x$ 方向，我们维护一下前面的扫描线，那么前面每个圆会有 $x+R, x-R$ 两条。然后向后做，每次加入是将 $y$ 方向的两条扫描线加进去，查询是查询 $y$ 方向的 **前驱后继** 即可。这个用平衡树（```set```）显然可以搞。

然而发现这样只是求出一个圆的答案。现实相当于要多组询问，那么我们 **CDQ 分治**！

首先肯定是按 $R$ 排序。然后先递归左侧，处理完左侧大的对右侧小的影响，然后递归右侧。如果是递归到重点 $l=r$ 的话，发现这里还没有删除那就自己删掉，**标记一下这个不是被带走的**。

主要怎么做左侧对右侧的影响。首先对于左边的，我们取出所有 **不是被带走的** 圆的扫描线，作为“修改”；右侧则取出全部，作为“查询”。修改部分，形如 $x-R$ 的是“插入”，$x+R$ 是“删除”，分别表示加入可能的答案和移除这个已经没有的答案。查询部分显然两边都是要查询的。

最后得到了一堆扫描线，然后按坐标大小的顺序去做。插入时将这个圆的 $y$ 坐标插入，删除时也将这个圆的 $y$ 坐标删除。查询就是 $y$ 坐标的前驱后继即可。注意答案对编号取 min。

这样的复杂度是 $O(n\log^2 n)$ 的，~~然而被随机选择 KDT 吊起来打 QAQ~~

### Solution 3

既然是“二维平面”，那么可以 **KDT** 暴力搞。

首先一个圆心为 $(x, y)$，半径为 $R$ 的圆，我们可以粗略地认为是一个矩形区域 $(x-R, y-R)\sim (x+R, y+R)$。

那么考虑用 KDT 维护这些矩形。对于一个圆，搜索可能与之有交集的区域即可。

但这样复杂度是 $O(\text{玄学})$ 而且可能被卡。

于是发扬人类智慧，将所有的点 **随机旋转** 一个角度。于是就可以过 LOJ 数据了。

不过 Luogu 不需要旋转 qwq。

思维难度、代码难度和速度全方位碾压 Sol 1 & 2。

### Code

https://www.luogu.com.cn/paste/tlbnzyno