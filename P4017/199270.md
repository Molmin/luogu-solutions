不会(不想用)拓扑排序?

~~DFS才是真爱~~

但是这里的DFS不是爆搜,是通过**类似**拓扑排序的思想,,只需在代码中**加几行**来优化搜索,速度和拓扑不相上下~~(主要是简单,虽然拓扑也不难QAQ)~~

~~(我觉得海星)~~
![](https://cdn.luogu.com.cn/upload/image_hosting/2tfpzizy.png)

我们先设$f[i]$为**从不会捕食其他生物的生产者(即入度为0的点)到$i$点的路径数**

正常爆搜就是直接搜下去,然后以$f[i]= \sum f[j]$(j为i的前驱),来更新f的值,这样复杂度很高,**原因如图**

![](https://cdn.luogu.com.cn/upload/image_hosting/g181n9o3.png)

按上图红色路径走,**f值的变化为**,$f[3]=f[1]+f[2],f[4]=f[3],f[5]=f[4]$

按绿路径走,**f的变化为**,$f[2]=f[1],f[3]=f[1]+f[2],f[4]=f[3],f[5]=f[4]$

可以发现$f[4]=f[3],f[5]=f[4]$是**出现了两次的**,但是5和4都只有一个前驱,我们可以猜测其实可以直接从他们的前驱一次更新过来,所以我们在走红色路径走到点3时,可以等一等(即**停止搜索**),再去走绿色路径走到点3时,**再继续搜索**,搜索路径如图

![](https://cdn.luogu.com.cn/upload/image_hosting/izx04iz2.png)

我们来看现在f值的变化,$f[3]=f[1]+f[2],f[2]=f[1],f[3]=f[1]+f[2],f[4]=f[3],f[5]=f[4]$

计算可以发现这个时候$f[5]$的值和上面的相等,且$f[4]=f[3],f[5]=f[4]$也只出现了一次

**结论:我们再来找一下这种搜索方法一般性的规律,可以发现就是当一个点的所有前驱都走到过它时,才继续往下搜**

就这一个结论,没了吗?


$~~$

$~~$

$~~$

$~~$

**没了**

当然如果你想**再快一点**,可以再来个优化,我们看上面的式子$f[3]=f[1]+f[2],f[2]=f[1],f[3]=f[1]+f[2],f[4]=f[3],f[5]=f[4]$,我们发现可以变成$f[3]+=f[1],f[2]+=f[1],f[3]+=f[2],f[4]+=f[3],f[5]+=f[4]$值也是不变的,这样在代码中就可以$O(1)$更新f值了

为什么?因为用这种方法从一个点走到它的下一个点的行为是唯一的(**不重复**),所以直接更新也可以满足公式$f[i]= \sum f[j]$(j为i的前驱)

所以**从没有前驱的节点开始搜**就可以了,细节看代码吧

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=6005,M=500005,mod=80112002;
#define ll long long
ll n,m,ft[N],nx[M],to[M],f[N],rd[N],ans;//rd[i]为i点的前驱数量,顺便记录一下一个点的所有前驱是否都走向它过
bool st[N];//因为前面rd有两个作用,所以需要这个来判断一个点是不是一开始就无前驱(具体的看下面)
inline long long read()
{
    char c=getchar();long long sum=0,f=1;
    while(!(c>='0'&&c<='9')) {if(c=='-') f=-1;c=getchar();}
    while(c>='0'&&c<='9') {sum=((sum<<1)+(sum<<3))+(c-'0');c=getchar();}
    return sum*f;
}
void dfs(ll x)
{
	if(!rd[x])//如果所有的前驱都走到过它了,继续搜
	{
	   if(!ft[x])//如果发现他不能继续走,即为终点
	   {
		   ans=(ans%mod+f[x]%mod)%mod;//记录
		   return;//返回
	   }
	   else for(ll i=ft[x];i;i=nx[i])
	   {
		   rd[to[i]]--;//所到点的rd--
		   f[to[i]]=(f[to[i]]%mod+f[x]%mod)%mod;//因为这种方法,每次到一个点是唯一的,所有直接用f[to[i]]+=f[x]并不会出现重复(刷表法)
		   dfs(to[i]);///继续搜
	   }
    }
	return;
}
int main()
{
	n=read();m=read();
	for(int i=1;i<=m;i++)
	{
		ll a=read(),b=read();
		rd[b]++;//前驱加一
		nx[i]=ft[a];//存路
		ft[a]=i;
		to[i]=b;
	}
	for(int i=1;i<=n;i++) if(!rd[i]) st[i]=1;//如果无前驱,为1
	for(int i=1;i<=n;i++) if(st[i]) f[i]=1,dfs(i);//因为搜索时会使rd[i]减为0来说明它已经被所有的前驱走到过了,所以如果这里再通过rd[i]==0来判断就会出现错误,所以要通过st来判断是原生态的无前驱节点
	cout<<ans%mod;//输出
	return 0;
}
```
