### 题解也是对自己的一种提升，所以我又来写题解了。


------------


首先这个题目和  **P3183 [HAOI2016]食物链** 类似。我写那个题目也参考了一下某个大佬的代码。
话不多说，我们来看这个题目的思路，DFS+记忆化+优化 。

首先来看一下样例数据
#### 5 7
#### 1 2
#### 1 3
#### 2 3
#### 3 5
#### 2 5
#### 4 5
#### 3 4
我们可以画个图![图片1](http://m.qpic.cn/psc?/V10vKiCC171fKX/Sln7pk6dp5wwcfV4X5H3.J2T9r*p34niGJerNB8JaomKmu6dBPj9l19kzEonrJG*X.9xkAacVYfnZyFYOB4Zbw!!/b&bo=RAINAgAAAAADB2s!&rf=viewer_4)
我们可以找的的食物链为

1->2->5

1->2->3->5

1->2->3->4->5

1->3->5

1->3->4->5

一共五条食物链
，通过对图的观察我们能够发现一条完整的食物链的最高级消费者是没有被吃过的，而生产者和低级别的消费者是会被吃过，所以我们可以设置两个标记数组,**w**和**u**来表示被吃过与吃过的。

创建了这两个数组之后我们就要着手将他们的关系存下来了，因此我们可以创建一个结构体数组用来表示吃与被吃的关系，此时我们看到数据有n<=5000,m<=500000这么多的关系，我们能不能
### 直接找到生物之间吃与被吃的关系呢
如果我们能直接找到相对应的关系而不是进行循环遍历，这样我们就能够省下大量的时间。

因此我们就要朝着这个想法去创建结构体
```cpp
struct node{
	int x,y,next;//next是存与之相关的直接后继
}mp[500005];
```
想法说完了我们直接来看代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,cun[5005]={0};
int w[5005]={0},u[5005]={0},ans,cun2[5005]={0};
int j=1,mod=80112002;
struct node{
	int x,y,next;
}mp[500005];

int dfs(int t){	
	int num=0;
	if(!u[t]){//如果此时这个生物没有吃过别的生物就证明找到了生产者，			
		return 1;//一条食物链找完了可以返回了 
	}
	if(cun[t])//直接返回我们搜过的 
	return cun[t];
	for(int i=cun2[t];i;i=mp[i].next){//关键，我们从与此消费者相关的直接后继开始找
										//依次找到所以与消费者t相关的直接后继，找完了i为零直接停止循环 
			(num+=dfs(mp[i].x))%=mod;
	}
	return cun[t]=num;//记忆化直接返回 
}

int main(){
	cin>>n>>m;
	while(m--){
		int a,b;
		cin>>a>>b;
		w[a]=1;//标记当前生物被吃过 
		u[b]=1;//标记当前生物吃过别的生物 
		mp[j].x=a;//存下被b吃的 
		mp[j].y=b;//存下吃a的 	
		mp[j].next=cun2[b];//存下那些是能被b直接吃的 
		cun2[b]=j;//及时更新与b相关的直接后继
		j++;
	}
	for(int i=1;i<=n;i++){
		if(!w[i]){//如果没有被吃过证明是顶级消费者 ，在测试数据中可能不止一个这样的消费者 
			(ans+=dfs(i))%=mod;//消费者代入
		}
	}
	cout<<ans;
}
```

可能注释看不太懂我来解释一下next怎么存的，
就拿样例数据来说明一下。

我们输入样例数据后发现有3组数据是直接与消费者**5**相关，分别是 3 5, 2 5, 4 5.
首先是3 5，**next**第一次存消费者**5**的有关数据，所以他上次出现的位置是0,（这也是我们终止DFS中那个循环的重要条件），**cun2[b]=j**;存下本次出现的位置，为
第4组数据。第二次是2 5，**next**就存下上次出现的位置是4，**cun2**及时更新，本次位置为5.依此类推，4 5，**netx**就存下5，**cun2**更新为6。

现在我们看到DFS之中的循环i起点就是最后一次存到的**cun2**的值，**i=mp[i].next**更新找到的就是当前这个消费者与之相关的直接的上一个结点。例如i=cun2[5]
cun2[5]最后一次存是6,我们mp.next[6]存下的是上次出现**5**与之相关的5.所以**i=mp[i].next**更新之后的i为5,以此类推之后是4，最后到0终止循环。


### 我们就通过记忆化+连接直接后继创建有向图（萌新不知道算不算有向图）.
### 就能大大缩减我们的时间复杂度了。