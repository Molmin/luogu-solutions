清新的一道题。

首先，容易看出，如果一个联系人发了至少一条消息，那么他的最前位置就是 $1$，否则就是他的编号（即最初排名）。

思考最后位置。个人觉得拿到这道题有两种很自然的思路，分别走就可以得到三种做法。

第一种思路是直接模拟。我们需要支持删除一个点，在最前面加入一个点以及查一个点排名三种操作。通过这三种操作求出答案是容易的，这里只说说如何支持这三种操作。

直接平衡树这样做就是第一种做法。

考虑删除一个点即其原位置后面所有点排名减 $1$，插入一个点即其插入位置后面所有点排名加 $1$。我们在最前面为 $m$ 次操作留出 $m$ 个空位，然后再依次放下 $n$ 个点并做后缀加操作，之后每次要将一个点换到最前面时，只需要将这个点从原位置删掉并做后缀减，再放到这次操作对应的空位并做后缀加。后缀加减、单点求值，树状数组上单点修改、前缀求和即可做到。这是第二种做法。

另一种思路是，一个联系人这次发消息和上次发消息之间（或第一次发消息之前）发过消息的不同联系人数，就是这个人相对于排名 $1$（或初始排名）的偏移量。这是很典型的二维数点问题。这样做就是第三种做法。

本人很快想到的是二维数点做法，和同学交流后实现的是树状数组模拟的做法。[参考实现](/paste/7x0q6dwj)