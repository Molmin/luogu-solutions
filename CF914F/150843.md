~~讲一下这题的不正经做法。~~

以下假设 $n,q,\sum\left|y\right|$ 同阶。

首先是暴力，每次 $O(1)$ 修改，$O(n^2)$ 查询，总时间最坏 $O(n^3)$。

然后优化这个暴力，发现用 kmp 可以优化到每次 $O(n)$ 查询，总时间最坏 $O(n^2)$。

我们想一想为什么这个最坏是 $O(n^2)$：假设 $\left|y\right|=len$，那么最多有 $\dfrac{n}{len}$ 次查询，每次查询 $[1,n]$，时间复杂度为 $O(\dfrac{n^2}{len})$，当 $len=1$ 的时候最坏 $O(n^2)$。

可以发现，当 $len$ 较大的时候，kmp 是可以直接跑过去的，所以可以设一个阈值 $L$，当 $L\leq len$ 的时候直接跑 kmp。

那么当 $len<L$ 时怎么做呢？

统计一个字符串在另一个串里的出现次数，不难想到用哈希~~也可能是我才疏学浅只想得到哈希~~。

记 $hs_{i,j}$ 表示 $[i,i+j-1]$ 的哈希值。

查询操作：

相当于统计 $i\in[l,r-len+1]$ 与询问串哈希值相同的 $hs_{i,len}$ 数量，可以分块，设块大小为 $B$，那么可以做到每次 $O(\dfrac{n}{B})$ 查询。（树状数组不知道行不行，但是我的树状数组过不去）

修改操作：

修改位置 $i$ 时，只需要修改包含位置 $i$ 的长度小于 $L$ 的子串的哈希值，因为最多会有 $L^2$ 个子串被修改，所以每次修改 $O(L^2)$。

对每个块开 $L$ 个桶，第 $j$ 个桶记录块内每个位置 $i$ 的 $hs_{i,j}$ 的出现次数，可以用哈希表实现。

然后是我的悲惨经历：兴致勃勃地写完代码，交上去发现 MLE on test 4 了，调了一下午 $L,B$ 都没用。

最后发现是哈希表中修改后会出现一些数量为 $0$ 的哈希值，需要将它们及时扔出去减少占用的内存。

时间复杂度 $O(\dfrac{n^2}{B}+nL^2+\dfrac{n^2}{L})$，空间复杂度不太会算（

这题感觉空间比较卡，如果 MLE 了试着调一下 $L$ 和 $B$ 的大小。

随便测了下我的代码是 $L=25,B=700/1000$ 和 $L=20,B=320/500$ 可过。

[Code](https://www.luogu.com.cn/paste/w9dq4x2e)