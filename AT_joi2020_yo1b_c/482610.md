本题注意几个优化方案：

1. `STL` 的 `map` 虽然很方便，但常数大，能计数就计数。

2. 本题可以 $O(n)$ 过，无需 $O(n+m)$，数据大的时候有很明显的优势。

好了，现在我们讲这道题的灵魂，它可以视作很多算法（如哈希、搜索、桶排）的基础——计数排序。本题虽然不用排序，但我们可以用计数的思路。空间复杂度 $O(n)$。

标准计数排序时间的确是 $O(n+k)$，但我们不用排序，就可以优化为 $O(n)$，只要随时更新答案即可。上代码：

```cpp
#include<bits/stdc++.h>
int j[101]={},n,k,t,ans=-2147483647;//或写作INT_MIN 
int main(){
	scanf("%d",&n);
	getchar();getchar();//把没用的m抛弃 
	while(n--){
		scanf("%d",&t);
		j[t]++;//计数 
		if(j[t]>ans)ans=j[t];
	}
	printf("%d",ans);
}
```