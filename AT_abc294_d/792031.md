## AT_abc294_d 题解
----------

##### "为啥好多大佬都用的 set，就我是两个 queue，一个 map 水过去的吗……" ----@Saint_ying_xtf
----
#### "为啥好多大佬都用的 set,两个 queue，一个 map 就我是啥也不用水过去的吗……" ----@SKB_Konnyaku



感觉比较简单的~就是一个模拟而已~ ~~（还错那么多遍）~~ 

我们看下题，总共有 $3$ 种操作：

第 $1$ 种操作:呼叫目前还没有呼叫的 ID 最小的人。

第 $2$ 种操作:曾经被呼叫的 ID 为 $x$ 的人前来报道。

第 $3$ 种操作:呼叫目前还被呼叫过而没有来的 ID 最小的人，并输出其 ID。



所以思路就很简单了：

先用一个变量 $v$ , 记录当前我们 ID 最小的人的 ID。


对于第 $1$ 种操作:根本就不用操作。

对于第 $2$ 种操作:曾经被呼叫的 ID 为 $x$ 的人前来报道, 然后一个个看过去后面的 ID，找到了就是一个新的最小 ID 者。

对于第 $3$ 种操作:并输出 $v$。

贴代码:

```

#include<bits/stdc++.h>
using namespace std;
int n, q;
bool hj[1000010];  // 记录当前 ID 的是否报到了 
int cnt = 0, v = 1;  // 注意：v = 1！ 因为当前的最小 ID 者是 1 
int main() {
	scanf("%d %d", &n, &q);

	for (int i = 1; i <= q; i++) {  // q次事件 
		int opt, x;
		scanf("%d", &opt);
		// 第一种不用操作 
		if (opt == 2) {
			scanf("%d", &x);
			hj[x] = 1;  // 1 是已来报道，所以接下来的最小 ID 就要接着找了 
			if (x == v)
				while (hj[v])
					v++;
		} else if (opt == 3) {
			printf("%d\n", v);
		}
	}
}


```

