$\text{update\ on 2023.01.06}$：优化了格式，添加了证明。

看了题解区的7篇题解，大致可以分成四类：

- 二分 $O(n\log n)$。
- 贪心（优先队列）的 
- 还有建图用图论的 
- 第一篇的 $O(n)$ 算法。

我个人感觉第一篇题解的 $O(n)$ 算法没有讲得特别好。所以我就来讲讲 $O(n)$ 算法。( 我先声明一下，我忽略了预处理。$\text{sort}$ 已经消耗了 $O(n\log n)$ 的时间了，这里讲的 $O(n)$ 是核心部分。第一篇题解也一样，其实也是 $O(n\log n)$ 的算法）。

步入正题：

初读题目，因为是将数列从**小到大排序，又是交换**。这让人自然而然的想到了[P1908 逆序对](https://www.luogu.com.cn/problem/P1908)。我就直接抄了那题的代码，然后发现只有 $10$ 分。

思考后发现，本题的交换是**可以交换两个不相邻的位置上的两个数**的，但是逆序对那道题，在交换时，是**只能交换相邻两个位置上的值**，这就是差别。 例如:

`6 4 3` 这个数列。如果是逆序对，是有 $2$ 对。但是本题，我们只需要交换 $1$ 次，即：$\text{swap}(6,3)$。

正解：

先对数列进行预处理：通过快排得出数列最后的正确排序，然后就得到了每个数的位置（座位号）

因为**每一个数都有一个属于自己的最终位置**，所以我们让每一个数换到它最终的位置之后，他就不用再动了。也就是**每个数换一次**。（就像是给每一个数分配座位，你走到每一个数面前对它说：“朋友，你去那个座位”，然后它去了就不用再动了）每个数分配一次，那么理论的时间复杂度就是$O(n)$。具体代码只需要模拟这个思路即可。

纸上模拟：
```cpp
8 23 4 16 77 -5 53 100
经过快排之后：
-5 4 8 16 23 53 77 100
每个数对应的座位：
8 23 4 16 77 -5 53 100
3 5  2 4  7  1  6  8
实际的座位：
1 2  3 4  5  6  7  8
（我们要直到当前座位上的人对了，才去下一个座位）
第一步：让8坐到3去，4就坐到了1
第二步：让4坐到2去，23就坐到了1
第三步：让23坐到5去，77就坐到了1
第四步：让77坐到7去，53就坐到了1
第五步：让53坐到6去，-5就坐到了1（此时，1的座位上的人已经正确，就去下一个座位）
发现2,3,4,5,6,7,8的座位上的人此时都已经正确。结束。

```

上面是整个过程的模拟（时间复杂度的证明），下面是正确性（最优性）的证明：

对于“把 $a_i$ 放回它应该在的位置”这个操作而言，每次对“$a_i≠i$” 的个数的贡献不是 $-1$ 就是 $-2$（着重：不为 $0$ ）。同时，若贡献可以是 $-2$，则必，$a_{a_i}=i$。此时，这个操作贡献一定是 $-2$。所以操作次数一定最优（最少）。过程正确性（最优性）证毕。

引理：对于每个位置 `while(a[i]!=i) 执行操作;` 这个过程是互相独立的。即：$a_i\rightarrow a_{a_i}$ 成环。

成环原因显然，因为会回到 $a_i(a_i=i)$。

所以，最终的答案即为：$ans=\sum\limits_{x=1}^m(len(x)-1)$（ $len(x)$ 表示 $x$ 号环的长度，$m$ 表示环的个数）


$\text{Code}:$
```cpp
#include<bits/stdc++.h>
using namespace std;
struct node{
	int value,seat;
}q[1000001];
int s[100001];
inline int read()
{
    int x=0,f=1;
    char ch=getchar();
    while(ch<'0'||ch>'9'){
        if(ch=='-')
            f=-1;
        ch=getchar();
    }
    while(ch>='0'&&ch<='9'){
        x=(x<<1)+(x<<3)+(ch^48);
        ch=getchar();
    }
    return x*f;
}
bool cmp(node x,node y)
{
	return x.value<y.value;
}
int main()
{
	int i,j,k,n,ans=0;
	n=read();
	for(i=1;i<=n;i++)
	{
		q[i].value=read();//快读完全可以用cin替代
		q[i].seat=i;
	}
	sort(q+1,q+1+n,cmp);
	for(i=1;i<=n;i++)
	s[q[i].seat]=i;
	for(i=1;i<=n;i++)
	{
		while(s[i]!=i)
		{
			swap(s[i],s[s[i]]);
			ans++;
		}
	}
	cout<<ans;
 	return 0;
}

```
可能有些人有疑惑：为什么 $\text{for}$ 里有 $\text{while}$，时间复杂度还会是$O(n)$。
因为每个数都只去了一次自己的位置，所以总的时间复杂度还是 $O(n)$。

$\text{Tips}:$ 我的代码也算是我发现的记录里没有 $0\text{ms}$ 这种东西的记录里最快的了。 [记录](https://www.luogu.com.cn/record/35777886)（不加氧气）， [记录](https://www.luogu.com.cn/record/35777987)(加氧气）。72ms最优解里排第八
