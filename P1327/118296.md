整体思路是用结构体存储值和位置后，做快速排序。

这样得到每个元素原有位置和最终位置的映射，原有位置和最终位置相同的不需要移动，不相同的必须移动，用贪心算法处理。

8

8 23 4 16 77 -5 53 100

6 3 1 4 2 7 5 8 原有位置

1 2 3 4 5 6 7 8 最终位置

比如-5原下标6，最终下标应该是1，所以下标1和下标6交换后-5的最终位置就确定了。

1 3 6 4 2 7 5 8 原有位置

1 2 3 4 5 6 7 8 最终位置


算法核心在于如何快速找到下标为1的元素在排序后数组中位置，以便快速交换。这里使用索引数组对原有位置和最终位置关联，注意每次交换后要更新索引数组。


```cpp
#include <iostream>
#include <algorithm>
using namespace std;
struct p
{
    int v,x;
} a[100005];
int n,tong[100005];
int cmp(p x,p y)
{
    return x.x<y.x;
}
int main()
{
    int i,j,l=0;
    cin>>n;
    for(i=1; i<=n; i++)
    {
        cin>>a[i].x;
        a[i].v=i;
    }
    sort(a+1,a+n+1,cmp);
    for(i=1; i<=n; i++) /**< 用t索引每一个元素排序前后位置 */
    {
        tong[a[i].v]=i; /**< 例如 tong[6]=1，表示原来第六个元素是排序后第一个元素*/
    }
    for(i=1; i<=n; i++)
    {
        if(i!=a[i].v)  /**< 比如排序后第一个元素原有位置是6，通过tong[1]找到原有第一个元素位置，比如是4，交换一次 */
        {
            l++;
            tong[a[i].v]=tong[i]; /**< 既然交换了，刷新下索引，现在第6个元素是原来第4个元素 */
            swap(a[i].v,a[tong[i]].v);
        }
    }
    cout<<l;
    return 0;
}

```


