## 题意
给定$n$个商店和总时间$T$，每个商店$i$有两个系数$a_i$，$b_i$，当你在时间$t$时处于商店$i$，就可以花$a_i * t+b_i$的时间在这个商店等待，然后进行购物，购物不用花费时间，你原本在家中，从家到商店或在任意两个商店中往来的时间是$1$，求在给定的时间内最多能在几个商店中购物。

## 分析
1. 我们首先要对原给定商店进行排序，设我们当前时间为$t$，我们现在有两个商店$i$和$j$可以去，如果先去商店$i$再去商店$j$的时间更短，则需满足这个式子: $(t+1)*(a_i+1)+b_i+((t+1)*(a_i+1)+b_i+1)*a_j+b_j+1<(t+1)*(a_j+1)+b_j+((t+1)*(a_j+1)+b_j+1)*a_i+b_i+1$，对上式进行化简可得$a_i*(b_j+1)>a_j*(b_i+1)$，所以我们就可根据这个来对原序列进行排序，保证先选的性价比更优。

2. 我们先来考虑一个$O(n^2)$的$dp$，$f[i][j]$表示在前$i$个商店中在$j$个商店中购物的最小时间，对于这个$dp$可用$01$背包的思想来做，$f[i][j]=min\{(f[i-1][j-1]+1)*(a[i]+1)+b[i]\}(j<=i)$这是选的情况，如果不选则$f[i][j]=f[i-1][j]$，然后$f[n][i]<=T$的最大$i$即是答案，对于第一维可用直接压掉，让空间达到$O(n)$。

3. 对于上面的$dp$，我们其实可以进行优化，我们可以发现，对于$a_i≠0$的情况，因为$a_i$为正整数，所以我们如果在商店$i$等待的话，等待结束后的时间为$a_i*t+b_i$，而$a_i*t+b_i>=2*t$，所以也就是说我们如果要在一个商店购物，时间至少要翻两倍，所以我们最多能在$log(T)$的商店中购物。所以我们的$dp$转移的时间就从$O(n)$降为$O(log(T))$，时间大大降低。而对于$a_i=0$的情况，我们发现不管当前的时间为多少，在这个商店购物的时间都是固定的，所以对于这个商店，它在后面的时间购物肯定比在前面的时间购物更优。

4. 所以根据上面的分析，我们就可以知道这题的解法了，我们将$a_i≠0$和$a_i=0$的商店存放在两个数组中，先对于$a_i≠0$的商店进行我们最开始的$dp$，然后我们将$a_i=0$的商店按照$b_i$从小到大排序，并求出前缀和$s_i$，然后我们在枚举从$a_i≠0$中的商店选择$k$个，然后我们在二分查找出$s_x≤T-f[k]$的最多商店数$x$，答案即为$max\{x+k\}$。

## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
const ll N=2e5+5;
ll n,T,b[N],ans,f[N],tot1,tot2;
struct node
{
	ll x,y;
}a[N];
bool mycmp(node x,node y)
{
	return x.x*(y.y+1)>y.x*(x.y+1);
}
int main()
{
	scanf("%lld%lld",&n,&T);
	for(ll i=1;i<=n;i++)
	{
		ll x,y;
		scanf("%lld%lld",&x,&y);
		if(x==0) b[++tot2]=y+1;
		else a[++tot1]={x,y};
	}
	sort(a+1,a+tot1+1,mycmp);
	sort(b+1,b+tot2+1);
	for(ll i=1;i<=35;i++) f[i]=T+1;
	for(ll i=1;i<=tot1;i++)
		for(ll j=35;j>=1;j--)
			f[j]=min(f[j],(f[j-1]+1)*(a[i].x+1)+a[i].y);
	for(ll i=1;i<=tot2;i++) b[i]+=b[i-1];
	for(ll i=0;i<=35;i++)
	{
		if(f[i]>T) continue;
		ll x=0;
		if(tot2) x=upper_bound(b+1,b+tot2+1,T-f[i])-(b+1);
		ans=max(ans,i+x);
	}
	printf("%lld\n",ans);
	return 0;
}
```
