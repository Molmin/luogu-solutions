[**原题传送门**](https://www.luogu.com.cn/problem/CF717C)
# 题面：
给定 $N$ 个数，要求你将这 $N$ 个数重新排列，并算出相应的乘积，要求乘积的和最小。
# Solution:
首先，用暴力枚举一定会超时。我们不妨想一想一种新的贪心思路，**如果将大数和大数相乘，所得的结果会非常大；但如果将大数与小数相乘，结果就会相对更小**。所以，我们要**避免两个大数**相乘。假设有两个数 $x$ 和 $y$，令 $y$ 比 $x$ 小 $4$，那么根据题意一共有两种答案，第一种是 $x^2+y^2=x^2+(x-4)^2=2x^2-16$，第二种是 $2xy=2x(x-4)=2x^2-8x$，又因 $x$ 至少为 $4$，得出 $2x^2-8x≤2x^2-16$。第二种贪心策略得出的答案明显比第一种小。再举个例子，假设输入以下样例。
```
2
1 3
```
这有两种可能，分别为 $1$ 乘 $3$ 加 $3$ 乘 $1$，或 $1$ 乘 $1$ 加 $3$ 乘 $3$。第一种答案为 $6$，而第二种答案为 $10$。显然，第一种利用**大数与小数相乘**得到的结果为最优。
# Code:
```
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int mod=10007;
const int N=1e5+1;
ll n,i,ans,a[N];
int main()
{
	cin>>n;
	for(i=1;i<=n;++i) 
		cin>>a[i];
	sort(a+1,a+1+n);//贪心，先排序 
	for(i=1;i<=n;++i)
		ans=(ans+a[i]*a[n-i+1])%mod;//累加乘积并取模 
	cout<<ans;
	return 0;
}

```
