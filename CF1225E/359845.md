[题目传送门~](https://www.luogu.com.cn/problem/CF1225E)

和朋友 duel 到的一个简单有趣数数题。

思路可能会讲的细一点，所以有点长。

首先，考虑没有石头或石头固定的情况。相信大家都能轻松设计出一个 $O(nm)$ 两维 DP 的算法。如果你不会，请不要在这道题上浪费时间。

加入推动石头的限制。面对更复杂的 DP 情况，一般都可以通过加几维做出来。这里我们先加两维，一维用来表示横行后面有多少石头，一维表示纵列后面有多少石头。用这两维判断能不能更新。

显然这个 $O(n^2m^2)$ 的东西很烂，做不了。

思考一下有什么好的性质，可以压一下状态。

可以想到，如果石头固定，就不存在后面两维，非常简单。后面两维都是我们在推石头的过程中产生的很多问题。

我们不要让前面推过的石头再对后面的贡献产生影响。

### 思路 1：

可能不是很好理解，但是是比较好想。我们考虑，不要推石头。一个点的方案数对后面产生的贡献，是一个区间。直接用前缀和维护一下。横行和纵列推石头贡献是分开的，拿两个数组交叉贡献一下。

### 思路 2：

思路一是我做题时想的思路过程，感觉可能不是很好理解。这里还有一种更具体的解释。

一条从起点到终点的路径，必定是一个形似这样的东西。

![](https://cdn.luogu.com.cn/upload/image_hosting/qlwzdz0j.png)

在没有石头或者石头固定的情况，我们是一格一格往前推的。差不多就是下图橙色箭头这样。

![](https://cdn.luogu.com.cn/upload/image_hosting/mmc6ieli.png)

诶像这样的东西肯定会对后面的推石头产生影响啊，所以我们抛弃这个传统做法，换用绿色箭头的这个从拐点来 DP。

首先，由于是拐点，所以他后面的石头一定是没动过的。所以我们搞个后缀和预处理可以轻松确定他最远能走到哪。

所以这个拐点的方案数就可以贡献到后面一段区间，拿个差分做一下区间加就可以。

状态设计：`f[2010][2010][2]`，第一维是 $n$，第二维是 $m$，最后一维表示是向右拐点还是向下拐点。

两个思路是同一个做法的不同解释。第一个好想，第二个好理解。

代码

```cpp
#include <cstdio>
#define MOD 1000000007
#define ll long long
using namespace std;
ll n,m,suf[2010][2010],suf1[2010][2010],f1[2010][2010],f2[2010][2010];
char mp[2010][2010];
int main(){
	scanf("%lld%lld",&n,&m);
	if(n==1&&m==1){
		puts("1");return 0;
	}
	for(int i=1;i<=n;i++){
		scanf("%s",&mp[i][1]);
	}
	for(int i=1;i<=n;i++){//做一个后缀和预处理 
		for(int j=m;j>0;j--){
			if(mp[i][j]=='R'){
				suf[i][j]=1;
			} 
			suf[i][j]+=suf[i][j+1]; 
		}
	}
	for(int j=1;j<=m;j++){
		for(int i=n;i>0;i--){
			if(mp[i][j]=='R'){
				suf1[i][j]=1;
			}
			suf1[i][j]+=suf1[i+1][j];
		}
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			f1[i][j]+=f1[i][j-1];f2[i][j]+=f2[i-1][j];
			f1[i][j]%=MOD;f2[i][j]%=MOD;
			f1[i][j]+=MOD;f2[i][j]+=MOD;
			f1[i][j]%=MOD;f2[i][j]%=MOD;
			if(i==1&&j==1){//特判(1,1)两边都可以走 
				if(m!=1&&suf[i][j+1]<m-j){
					f1[i][j+1]+=1;
					f1[i][m-suf[i][j+1]+1]-=1;
				}
				if(n!=1&&suf1[i+1][j]<n-i){
					f2[i+1][j]+=1;
					f2[n-suf1[i+1][j]+1][j]-=1;
				}
			}
			else{
				if(m!=j&&suf[i][j+1]<m-j){//交叉转移 
					f1[i][j+1]+=f2[i][j];
					f1[i][j+1]%=MOD;
					f1[i][m-suf[i][j+1]+1]-=f2[i][j];
					f1[i][m-suf[i][j+1]+1]+=MOD;
					f1[i][m-suf[i][j+1]+1]%=MOD;
				}
				if(n!=i&&suf1[i+1][j]<n-i){
					f2[i+1][j]+=f1[i][j];
					f2[i+1][j]%=MOD;
					f2[n-suf1[i+1][j]+1][j]-=f1[i][j];
					f2[n-suf1[i+1][j]+1][j]+=MOD;
					f2[n-suf1[i+1][j]+1][j]%=MOD;
				}
			}
		}
	}
	printf("%lld",(f1[n][m]+f2[n][m])%MOD);
	return 0;
}
```