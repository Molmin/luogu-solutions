**谨以此题解纪念长时间停打 CF 后的第一场比赛**

### 思路

因为整个串为整个串的一个前缀，所以对于整个串的任意一个排列，都一定会有一个前缀的恐惧值为 $|a-b|$。所以我们可以尽量让这个恐惧值最大。因为对于 $a>b$ 和 $a<b$ 的情况处理方法相似，所以这里以第一种为例子。

那么现在开始构造。首先，为了让任意一个前缀的恐惧值都不大于 $a-b$，那么我们可以用 $b$ 个 01 串填在前面。填完后，最大恐惧值为 $1$，整个串的恐惧值为 $0$。现在，剩下的地方全部填 $0$ 就可以保证最大恐惧值为 $a-b$ 了。

但是，对于 $a=b$ 的时候，整个串的恐惧值为 $0$。可是对于长度为 $1$ 的前缀，恐惧值为 $1$，故这种情况最大恐惧值至少为 $1$。而上述方法构造的最大恐惧值刚好为 $1$，所以这种情况仍然可以用上述方法构造。

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
	int t;
	scanf("%d",&t);
	while(t--)
	{
		int a,b;
		scanf("%d%d",&a,&b);
		if(a<b)
		{
			for(int i=1;i<=a;i++)
				printf("01");
			for(int i=a+1;i<=b;i++)
				printf("1");
		}
		else
		{
			for(int i=1;i<=b;i++)
				printf("01");
			for(int i=b+1;i<=a;i++)
				printf("0");
		}
		puts("");
	}
	return 0;
}
```