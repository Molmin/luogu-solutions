# 思路
通过读题，可以发现我们必须使用 $k$ 长度的胶带，剩下没有覆盖的就需要通过覆盖两个点的区间来覆盖。换句话说，就是要覆盖 $k$ 个点和 $n-k$ 个区间。

拿样例来说，首先花费 $2$ 长度的胶带覆盖两个点（注意，不是前两个），再将两点之间的区间长度排序，覆盖前 $2$ 个，也就是 $20$ 到 $30$ 和 $75$ 到 $80$。最后将总和加起来就行了。
# 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
int n,m,k,a[100005],s[100005],ans;
int main(){
	cin>>n>>m>>k;
	for(int i=1;i<=n;i++){
		cin>>a[i];
	}
	for(int i=1;i<=n;i++){
		s[i]=a[i]-a[i-1];
	}
	s[1]=INT_MAX;//排除第一个
	if(n==k){
		cout<<n;
		return 0;
	}//注意，如果胶带和点一样多，就直接每个点覆盖一个长度为1的就行了。
	ans=k;//先覆盖k个点。
	sort(s+1,s+n+1);
	n-=k;
	for(int i=1;i<=n;i++){
		ans+=s[i];//加上区间长，注意因为我们已经覆盖了一个点了，所以加长度的时候不用加1。
	}
	cout<<ans;
	return 0;
}
```