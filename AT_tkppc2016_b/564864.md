### 题意概述
------------
给出 $n$ 和 $m$。分别表示物品数量和背包容量。

接下来 $n$ 行，分别输入 $v_i$ 和 $w_i$ （题目中称 $t_i$），表示物品价值和物品重量。

### 解题思路
------------
一道简单的 **01 背包** ，需要判断两种状态，分别是 **取** 或 **不取**。如果取到这个物品，可以增加价值，但会减少背包容量。

我们可以定义一个数组 $dp$， 用来表示各种容量时的**价值**。最后输出 $dp_m$ 即可。

众所周知，**01 背包** 用 $i$ 来枚举**物品**，用 $j$ 来枚举**重量**（注意是倒序）。

所以可以有这样的代码：

``` cpp
for(int i=1;i<=n;i++) {
		for(int j=m;j>=w[i];j--)
			//你的状态转移方程
}
```

然后思考**状态转移方程**：

首先，我们知道每种物品可以选择**取**或**不取**。

在取的情况下，可以写出：

$$dp_j = dp_{j-w_i}+v_i$$

即 `dp[j]=dp[j-w[i]]+v[i]`。

在不取的情况下，亦可以有：

$$dp_j=dp_j$$

即`dp[j]=dp[j]`。

我们需要总价值最大，所以有状态转移方程

$$dp_j = max_{dp_{j-w_i}+v_i}^{dp[j]}$$

即 `dp[j]=max(dp[j],dp[j-w[i]]+v[i])`。

### 代码实现
------------
``` cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,v[1000005],w[1000005],dp[1000005];
int main() {
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++) scanf("%d%d",&v[i],&w[i]);
	for(int i=1;i<=n;i++) {
		for(int j=m;j>=w[i];j--)
			dp[j]=max(dp[j],dp[j-w[i]]+v[i]);
	}
	printf("%d",dp[m]);
	return 0;
}
```
