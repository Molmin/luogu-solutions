跑一遍tarjan 

啥是tarjan

说到以Tarjan命名的算法，我们经常提到的有3个，其中就包括本文所介绍的求强连通分量的Tarjan算法。而提出此算法的普林斯顿大学的Robert E Tarjan教授也是1986年的图灵奖获得者（具体原因请看本博“历届图灵奖得主”一文）。

      首先明确几个概念。

强连通图。在一个强连通图中，任意两个点都通过一定路径互相连通。比如图一是一个强连通图，而图二不是。因为没有一条路使得点4到达点1、2或3。
强连通分量。在一个非强连通图中极大的强连通子图就是该图的强连通分量。比如图三中子图{1,2,3,5}是一个强连通分量，子图{4}是一个强连通分量。


   关于Tarjan算法的伪代码和流程演示请到我的115网盘下载网上某大牛写的Doc（地址：http://u.115.com/file/f96af404d2<Tarjan算法.doc>）本文着重从另外一个角度，也就是针对tarjan的操作规则来讲解这个算法。

   其实，tarjan算法的基础是DFS。我们准备两个数组Low和Dfn。Low数组是一个标记数组，记录该点所在的强连通子图所在搜索子树的根节点的Dfn值（很绕嘴，往下看你就会明白），Dfn数组记录搜索到该点的时间，也就是第几个搜索这个点的。根据以下几条规则，经过搜索遍历该图（无需回溯）和对栈的操作，我们就可以得到该有向图的强连通分量。

 

数组的初始化：当首次搜索到点p时，Dfn与Low数组的值都为到该点的时间。

堆栈：每搜索到一个点，将它压入栈顶。

当点p有与点p’相连时，如果此时（时间为dfn[p]时）p’不在栈中，p的low值为两点的low值中较小的一个。

当点p有与点p’相连时，如果此时（时间为dfn[p]时）p’在栈中，p的low值为p的low值和p’的dfn值中较小的一个。

每当搜索到一个点经过以上操作后（也就是子树已经全部遍历）的low值等于dfn值，则将它以及在它之上的元素弹出栈。这些出栈的元素组成一个强连通分量。

继续搜索（或许会更换搜索的起点，因为整个有向图可能分为两个不连通的部分），直到所有点被遍历。

   由于每个顶点只访问过一次，每条边也只访问过一次，我们就可以在O（n+m）的时间内求出有向图的强连通分量。但是，这么做的原因是什么呢？

 

   Tarjan算法的操作原理如下：

1.Tarjan算法基于定理：在任何深度优先搜索中，同一强连通分量内的所有顶点均在同一棵深度优先搜索树中。也就是说，强连通分量一定是有向图的某个深搜树子树。

2.可以证明，当一个点既是强连通子图Ⅰ中的点，又是强连通子图Ⅱ中的点，则它是强连通子图Ⅰ∪Ⅱ中的点。

这样，我们用low值记录该点所在强连通子图对应的搜索子树的根节点的Dfn值。注意，该子树中的元素在栈中一定是相邻的，且根节点在栈中一定位于所有子树元素的最下方。

3.强连通分量是由若干个环组成的。所以，当有环形成时（也就是搜索的下一个点已在栈中），我们将这一条路径的low值统一，即这条路径上的点属于同一个强连通分量。

4.如果遍历完整个搜索树后某个点的dfn值等于low值，则它是该搜索子树的根。这时，它以上（包括它自己）一直到栈顶的所有元素组成一个强连通分量。

5.by the way题里给的范围虽然大 但是内存限度也大啊 按那个大小开准是没错的==

```cpp
#include <bits/stdc++.h>
#define N 2000 + 10
using namespace std ;
int a[N][N];
int mark[2][N] ;
int n,num ; 
void dfs(int k,int pre)
{
	mark[k][pre]=true,num++ ;
	for (int i=1;i<=n;i++)
	if (!mark[k][i])
	if ((k && a[pre][i]) || (!k && a[i][pre])) dfs(k,i) ;
}
int main() 
{
	scanf("%d",&n) ;
	for (int i=1;i<=n;i++)
	for (int j=1;j<=n;j++)
	scanf("%d",&a[i][j]) ;
	dfs(0,1);dfs(1,1) ;
	printf("%s\n",num==2*n?"YES":"NO") ;
	return  0;
}
```