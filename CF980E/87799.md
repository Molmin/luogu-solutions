请先学会倍增算法再来看本题解。

建议看题解时要自己照着题解意思画图。

题意:给定一棵树，第 $i$ 个节点权值为 $2^i$。求其权和最大且需要删掉 $m$ 个结点的联通子图。

$1+2+4+...+2^{n}=2^{(n+1)}-1$。这个是小学奥数，故不写计算过程。

所以可见如果一个数不选，比它小的数无论如何选都无法补救。所以尽可能从大的选。

注意:不能从小的结点开始删，因为无法保证图的连通性。还有一种错误的算法是每次删最小的叶节点保证图联通。但是也是不正确的。比如对于这棵树 ```2-4-5-1-3```，按此算法会将 $2,3$ 删去,但显然删 $1,3$ 更好。

首先，如果 $m=n$，说明要删掉所有结点，特判即可。否则必须选$n$结点。

将题目中的删去结点改为选结点。接下来从 $(n-1)$ 到 $1$ 依次选。设当前选的是 $i$结点。如果可选则一定选 $i$ 结点。但是不能仅选取 $i$ 结点，还需选取其它结点确保已选结点联通。现在问题就是判断是否可选。

因为目前可选结点联通。而整棵树**不存在回路**，所以 $i$ 结点在仅经过未选结点时，**恰好连到其中的 1 个结点**。(下面称这个结点为 a)

而它们中间的结点全部都需要选,所以只需要判断需要选的结点数是否小于目前还可选的结点数。若小于则说明可以选。并将中间这些点都选上。

现在的问题是如何找到 a。若 $i$ 结点已选,则说明 a 就是 $i$ 结点。$n$ 结点一定选。并且已选的点是联通的。所以 $i$ 结点到 $n$ 结点的路径上一定是有一部分是已选,一部分未选。并且**这两部分的结点都在一起(构成链)**。

所以相当于满足单调,就用倍增算法做即可。求出两点距离也用倍增算法优化即可。求距离也用倍增算法即可。求距离也用倍增即可。

实现时以 $n$ 结点为根即可。

时间复杂度:由于每个节点最多被选一次，所以是 $O(n)$，加上倍增就是 $O(n\times \log_{2}(n))$。

```cpp
#include<iostream>
using namespace std;
struct xyq{
	int v,next;
}_[2000005];
int head[1000005],tot=1;
void add(int u,int v){
	_[tot].v=v;
	_[tot].next=head[u];
	head[u]=tot;
	tot++;
}
int f[21][1000005],dis[1000005];
void dfs(int iakioi,int step){
	dis[iakioi]=step;
	int i;
	for(i=head[iakioi];i;i=_[i].next){
		if(!dis[_[i].v]){
			f[0][_[i].v]=iakioi;
			dfs(_[i].v,step+1);
		}
	}
}
bool chose[1000005]; //chose:已选。zyl:已选结点的父亲。 
int main(){
	int n,m,i,j,A,B,ykb=-1,logn,now,sum=0;
	cin>>n>>m;
	m=n-m;
	if(!m){ //一个结点都不能选,什么都不需要输出。
		return 0;
	}
	for(logn=0;(1<<logn)<=n;logn++){
	}
	for(i=1;i<n;i++){
		scanf("%d %d",&A,&B);
		add(A,B);
		add(B,A);
	}
	f[0][n]=n;
	dfs(n,1);
	for(i=1;i<=logn;i++){
		for(j=1;j<=n;j++){
			f[i][j]=f[i-1][f[i-1][j]];
		}
	}
	chose[n]=1;
	m--;
	for(i=n-1;i>=1;i--){
		if(chose[i]){ //特判如果被选过则不需要再选。否则有可能出错。(sum 最终会算成 1)。
			continue;
		}
		now=i;
		sum=0;
		for(j=logn;j>=0;j--){
			if(!chose[f[j][now]]){
				now=f[j][now];
				sum+=(1<<j); //(1<<j)=pow(2,j)。跳了 2 的 j 次方步。
			}
		}
		now=f[0][now]; //这里倍增找出的是仍未选过的深度最小结点。所以还需要跳一步。
		sum++;
		if(sum<=m){ //如果可以选。将中间所有结点都选了。
			m-=sum;
			for(j=i;j!=now;j=f[0][j]){
				chose[j]=1;
			}
			chose[now]=1;
		}
	}
	for(i=1;i<=n;i++){
		if(!chose[i]){
			cout<<i<<" ";
		}
	}
	return 0;
}
```