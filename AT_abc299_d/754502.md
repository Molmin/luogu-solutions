# 题意：
有一个长度为 $n$ 的序列 $s$，开始只知道 $s_1=0$ 和 $s_n=1$。可以查询 $20$ 次 $s_i$ 的值，找一个位置 $p$，使 $s_p \neq s_{p+1}$。
# 分析：
最多可以查询 $20$ 次，而 $n$ 的大小很大，所以就可以往二分的方向想。
# 思路：
应为这个序列只有两种数字，$0$ 或 $1$。不难发现，假如有一段区间 $s_l ,  s_{l+1} , s_{l+2}……s_r$ 只要 $s_l \neq s_r$，那么无论中间是什么数，总会找到答案。而题目给出 $s_1=0$ 和 $s_n=1$，所以我们可以用二分，询问中点后，看中点与左、右哪个端点相反，只要一直找左右端点不同的区间，答案就一定会在里面。最后输出最后找到的中点就行了。

**注意：最终的答案范围在 $1$ 到 $n-1$。**
# Code:
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,ans; 
int main()
{
   	cin>>n;
   	int l=1,r=n-1;
   	while(l<=r)
    {
   		int x;
   		int mid=(l+r)/2;
   		ans=mid;
   		cout<<"?"<<" "<<mid<<endl;
    	cin>>x;
   		if(x==1)
   			r=mid-1;
   		else
		    l=mid+1;	
   	}
   	cout<<"!"<<" "<<(l+r)/2<<endl;
}
```
