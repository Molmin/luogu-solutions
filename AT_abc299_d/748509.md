## 题目描述

这是一道交互题。

有一个长度为 $n$ 的 $01$ 序列 $s$，保证 $s_1 = 0,s_2 = 1$。开始只告诉你 $n$，你需要对交互库询问某个位置上的数，最多 $20$ 次。

请你找到一个整数 $p \in [1, n)$，满足 $s_p \ne s_{p +1}$。

## 输入输出

首先输入一个整数 $n$，表示序列长度。

如果你要询问 $s_i$ 的值，那么你需要输出 `? i`，交互库会给你输入。

如果你要输出答案，那么你需要输出 `! p`。

## 数据范围

$2 \le n \le 2 \times 10^5$

## 分析

这个交互题很有意思，但考察思维。

题目中已经给了我们提示，因为 $20$ 是约等于 $\log_n$ 的，因此考虑二分。

首先把 $l$ 指针指向第一个位置，$r$ 指针指向最后一个位置。接下来我们要做的是维护这两个指针并时刻满足 $s_l = 0$ 且 $s_r = 1$。

这样做的目的是，如果最后 $l$ 和 $r$ 交叉，那么 $s_l$ 一定不等于 $s_r$，答案直接输出即可。

二分过程中，首先记录下它们的中间值 $mid = \left \lfloor \dfrac{l+r}2 \right \rfloor$。

接下来我们对交互库询问 $s_{mid}$ 的值。

由于要维护两个指针满足条件，所以这里分成两类解决。

如果交互库给的答案为 $0$，那么我们需要把 $l$ 指针移到 $mid$ 这里。

否则，把 $r$ 指针移到 $mid$ 这里。

这样我们就能保证 $s_l = 0$ 且 $s_r = 1$ 这个条件了。

当 $l$ 和 $r$ 相差小于等于 $2$ 时，也就是 $l$ 和 $r$ 之间存在 $\le 1$ 个元素时，就可以推出二分的循环了。输出 $l$ 即可。

## 代码

```cpp
#include <iostream>

using namespace std;

int n, l, r, mid, res, x;

int main()
{
	// 读入 
	cin >> n;
	
	l = 1, r = n;
	
	while (l + 2 <= r)		 // 二分循环条件为 l 和 r 之间存在 > 1 个元素
	{
		mid = l + r >> 1;		// 求中间值 mid 
		cout << "? " << mid << '\n';		// 询问 mid 的值 
		cin >> x;
		
		// 维护两个指针 
		if (!x) l = mid;
		else r = mid;
	}
	
	cout << "! " << l;		// 输出答案 
	
	return 0;
}
```
