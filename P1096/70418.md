~~其实这道题顶多就入门难度的~~。

可是本蒟蒻并没有看范围(勿喷)。

言归正传，这道题一看就是递推或递归(别问我为什么)。我们需要找出后一项与前一项的关系，来解决这道大大的难(shui)题。

第1步：将n-2个圆盘移到B柱上。

第2步：将2个最大的圆盘移到C柱上。

第3步：将n-2个圆盘移到C柱上。

因为第3步的步数=第一步的步数且第2步需用2步。

所以，总步数=第1步的步数*2+2。

我们再来分析一下第1步的步数：

第一步的步数=将n-4个圆盘移动到B柱上的步数*2+2。

那么将n-4个圆盘移到B柱上的步数呢？

由此下去，

用递归解决(不考虑数据范围，~~和本蒟蒻一样~~):

```cpp
#include<stdio.h>
int hanoi(int x)
{
	return x==1?2:hanoi(x-1)*2+2;
}
int main()
{
	int n;
	scanf("%d",&n);
	printf("%d",hanoi(n));
	return 0;
}
```
结果只对了5个点。

这时，本蒟蒻才看到数据范围(~~打脸了~~)

于是改为了long long。
```cpp
#include<stdio.h>
long long hanoi(int x)
{
	return x==1?2:hanoi(x-1)*2+2;
}
int main()
{
	int n;
	scanf("%d",&n);
	printf("%lld",hanoi(n));
	return 0;
}
```

结果还是只对了7个点。

这时本蒟蒻才知道这道难(shui)题为什么是普及+/提高-了。

转而想到了高精度(就算是unsigned long long也不行，因为步数大概有2^200步)

因为步数>2^200

所以步数大概在2^250左右

而2^250=10^75*1.8092513943330655534932966407607

故因把数组开到100位。

下面就是如何乘2和加2了

(这里要特别说明一下，本题解的高精度都是从右向左存的,比如65，存进来就是 5 6)

先说说加2吧

本蒟蒻的思路是先将第一位+2，再判断是否进位。

代码如下
```cpp
a[1]+=2;j=1;
while(a[j]>=10&&j<len)	//判断是否进位
{
	a[j]-=10;
	a[j+1]++;
	j++;
}
if(a[len]>=10)	//如果最高位进位长度加1
{
	a[len]-=10;
	a[++len]++;
}
```

现在就该说说乘2了

本蒟蒻的思路是将每一位都乘2后再判断进位。

代码如下
```
for(j=1;j<=len;j++)	//把每一位都乘2
{
	a[j]*=2;
}
for(j=1;j<len;j++)	//判断进位
{
	if(a[j]>=10)
	{
		a[j]-=10;
		a[j+1]++;
	}
}
if(a[j]>=10)	//如果最高位进位长度+1
{
	a[j]-=10;
	a[j+1]++;
	len++;
}
```
本蒟蒻的巨丑的代码就不贴出来丢人现眼了，请大家自己集合一下吧。

下面附递推代码(~~无数据范围~~,最大30,比递归快得多)
```cpp
#include<stdio.h>
int main()
{
	int i,n,ans=0;
	scanf("%d",&n);
	for(i=1;i<=n;i++)
	{
		ans=ans*2+2;
	}
	printf("%d",ans);
	return 0;
}
```