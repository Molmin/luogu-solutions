## 本蒟蒻第一次发题解，经验较少，不喜勿喷……  


------------

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首先来分析下这个题，我们暂时先不考虑有2n个有孔圆盘，当作只有n个圆盘，我们用A'(n)来表示将n个圆盘全部从A柱移到C柱上的最少移动次数。于是，  

1.当n=1时，我们可以直接把这一个圆盘从A柱移到C柱上，就有A'(1)=1。**这样就完成了把1个圆盘从A柱移到C柱上的最简过程，共1次操作。**

2.当n=2时，我们可以先将最上方第一个圆盘移到B柱上**（可以理解成将n=1时的终点从C换成B，进行一次n=1时的操作）**，然后再将第二个圆盘移到C，最后把第一个圆盘从B柱移到C柱上**（可以理解成将n=1时的起点换成B，终点换成C，进行一次n=1时的操作），这样就完成了把2个圆盘从A柱移到C柱上的最简过程，共3次操作。其中第一次操作和最后一次操作可以理解为重复当n=1时的操作（只不过换了起点或者终点而已）**，就有A'(2)=A'(1)*2+1=3。

3.当n=3时，我们可以先将第一个圆盘移到C柱上，第二个圆盘移到B柱上，再把第一个圆盘移到B柱上**（至此，前三步可以理解为将n=2时的终点从C换成B，进行一次n=2时的操作）**，然后我们将第三个圆盘移到C柱上，紧接着又把第一个圆盘移到A柱，把第二个圆盘移到C柱，最后再把第一个圆盘移到C柱，**（这最后三步又能理解成将n=2时的起点换成B，终点换成C，进行一次n=2时的操作），这样就完成了把3个圆盘从A柱移到C柱上的最简过程，共7次操作。其中第前三次操作和后三次操作可以理解为重复n=2时的操作（只不过换了起点或者终点）**，就有A'(3)=A'(2)*2+1=(A'(1)×2+1)×2+1=7。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;于是，综上可以得出：**把n个圆盘从A柱移到C柱上的最简过程就是先做一轮移动n-1个圆盘的过程，借助C柱使前n-1个圆盘移动到B柱上，再将第n个圆盘移到C柱，最后再做一轮移动n-1个圆盘的过程，借助A柱使前n-1个圆盘从B柱移到C柱上，就可以推出递归公式A'(n)=A'(n-1)*2+1(n≥2）**，由于A'(1）=1，又可以推得![](https://cdn.luogu.com.cn/upload/pic/47207.png ),最后利用等比数列求和公式化简得**A'(n)=2^n-1**。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于题目所要求我们求的是2n个圆盘从A柱移到C柱，因此**A(n)=2A'(n)=2*(2^n-1)=2^(n+1)-2**。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;至此公式推导完毕。如果就开始这么写的话，只有50分-70分（用int存50分，用long long的话也只有70分），先贴出50分的代码：
```cpp
#include<cstdio>
#include<cmath>
int main(){
    int n;
    scanf("%d",&n);
    int ans=pow(2,n*1.0+1)-2;//注意这里n要*1.0转成浮点类型再加上1，因为pow函数传入的两个数必须是浮点类型
    printf("%d",ans);
    return 0;
}
```

------------
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为什么只有50分呢？把光标移到后面那五个红的点一看，发现全是read 0，肯定是数据范围没考虑周全的问题。赶紧看看讨论/题解发现原来要使用高精度，于是我按照高精度的方法重新写了一遍。不过我和楼上的高精的思路不太一样，我定义了一个函数专门算乘法，然后循环n次计算乘法（因为是要算2^(n+1)嘛，乘当然只要乘n次），可能这样有点复杂吧：
```cpp
#include<cstdio>
#include<iostream>
using namespace std;
string mul(string a,string b){//这里读进来的是两个string类型，在函数内再转int数组
	int lena=a.size(),lenb=b.size(),x;//获取两个串长度
	int m[100000]={0},n[100000]={0},c[100000]={0};//m数组存a的每一位，n数组存b的每一位，c数组存结果的每一位，注意都必须初始化为0，即使声明在了函数外边，因为每调用一次这个函数就要刷新一次
	for(int i=1;i<=lena;i++)
		m[i]=a[lena-i]-48;//逆序存a的每一位
	for(int i=1;i<=lenb;i++)
		n[i]=b[lenb-i]-48;//逆序存b的每一位
	for(int i=1;i<=lenb;i++){
		x=0;//x是需要进到下一位的数，记得每进来一次循环就要清零一次
		for(int j=1;j<=lena;j++){
			c[i+j-1]+=m[j]*n[i]+x;//模拟竖式乘法过程，用m的第j位乘以n的第i位是因为默认m是第一个因数，n是第二个因数，因此j放在内循环，i放外循环。
			x=c[i+j-1]/10;//x的值刷新为要进到下一位的数
			c[i+j-1]%=10;//保证结果的每一位不超过10
		}
		c[i+lena]=x;//最后一次计算出来的x要记得保存到已算出的最高位的后面那一位
	}
	string k;//存结果
	bool p=0;//标记k是否为空串
	for(int i=lena+lenb;i>0;i--)//乘法的结果的位数最多不会超过两个因数的位数之和
		if(c[i]!=0){//不输出前导0
			for(int j=i;j>0;j--){
				k+=c[j]+48;//不要忘记加上0的ASCII值48
			}
			p=1;//标记k串已经存了值
			break;//不要丢了break
		}
	if(p==0)//如果k现在还是空串，说明结果为0（当然这一题乘法的结果不可能为0），就返回0
		return "0";
	return k;//否则就返回这个结果，此处不用else，因为如果满足p=0的话那就已经return掉这个函数了
}
int main(){
    int n;
    scanf("%d",&n);
    string ans="2";
    for(int i=1;i<=n;i++)//注意是乘n次，因为是要求2^(n+1)
    	ans=mul(ans,"2");
	ans[ans.size()-1]-=2;//这里不用考虑个位是否≥2，因为2的幂的个位不可能小于2
	cout<<ans;//注意这里如果使用的string的话最好别用printf输出，因为printf只能输出c语言的内置数据，而string的话是C++STL库里的，要使用printf的话只能使用传指针的方式输出，即printf("%s",ans.c_str());
	return 0;//不要忘记
}
```
当然，也用一般性的做法写了一遍（这个在时间上好像快很多）：
```cpp
#include<cstdio>
#include<iostream>
using namespace std;
string pow(int n){//如果使用了万能头或者cmath、math.h的库的话函数名不建议叫pow
	int len=1,x=0;//len表示得到的结果的位数，x表示要进到下一位的数
	int a[1000]={0};
	a[1]=1;//注意a[1]要赋成1，因为后面乘了n次
	for(int i=0;i<n;i++){
		for(int j=1;j<=len;j++){
			a[j]=a[j]*2+x;//乘以2再加上要进到这一位的数
			x=a[j]/10;
			a[j]%=10;//保证每一位大小不超过10
		if(x!=0&&j==len)//如果到了最后一位还有余数，就要再多开一位
			len++;
		}
	}
	string k;//储存结果
	for(int i=len;i>0;i--){
		k+=a[i]+48;//不要忘记加上0的ASCII值48
	}
	return k;
}
int main(){
    int n;
    scanf("%d",&n);
    string ans=pow(n+1);
    ans[ans.size()-1]-=2;
    //这里不用考虑个位是否≥2，因为2的幂的个位不可能小于2
    cout<<ans;
	return 0;
}
```