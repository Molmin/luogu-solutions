# 数学递推+高精度
对于这种数论题目，我们可以推一下规律。
| 1 | 2 | 2^(1+1)-2 |
| -----------: | -----------: | -----------: |
| 2 | 6 | 2^(2+1)-2 |
|  3| 14 | 2^(3+1)-2 |
| n | 2^(n+1)-2 |2^(n+1)-2  |
所以总结出来规律：

### 对于每一个输入的n，输出2^（n+1)-2。

但我们一看数据范围：n<=200

所以用**高精度算法**。

我的思路是把高精度算法分解成两大块:

1. 2的n次方（用循环，每次乘2）
1. -2（高精度减法）



------------
### 一、2的n次方
```cpp
inline void f1(ll x){
	register int i;
	ll k=0;
	for(i=1;i<=l+1;i++){
		a[i]=(a[i]*2)+k;//先把每一位上全部乘2
		if(a[i]>=10){//判断位数超出10的情况
			k=(a[i]/10);
			a[i]%=10;
		}
		else k=0;//如果没有超出，就不用在下一位++
	}
	if(a[l+1]>0)l++;//判断最高位是否有进位
}
```


------------
### 二、高精度减法
```cpp
inline void f2(){
	ll p=1;
	if(a[p]>=2){//如果可以直接减2
		a[p]=a[p]-(1<<1);//听说二进制会快一点
		return;
	}
	else{//不可以直接减
		a[p]=a[p]+(1<<3);//往前面一位推
		p++;
		while(a[p]==0)a[p]=9,p++;//判断是否可以向前一位借1
		a[p]--;
		if(a[l]==0)l--;//如果前一位被减了，那么就往后挪一位
	}
}
```
贴一下main函数：
```cpp
int main(){
	register int i;
	n=read();
	a[1]=1;
	for(i=1;i<=n+1;i++)//2的n次方
	f1(2);
	f2();//高精度减法
	for(i=l;i>=1;i--)printf("%lld",a[i]);
	printf("\n");//最好换行
	return 0;
}
```


