题意：  
我们定义边加权树为一棵 $n$ 个点的树，边权只能为 $-1$ 或 $1$。那么 $n$ 个点 一共可以构成 $n^{n-2}\times 2^{n-1}$ 棵边加权树。  
定义对于每个顶点 $i$，所有端点为 $i$ 的边的权值的乘积为 $-1$，那么我们称这棵为好的边加权树。  
求每棵好的边加权树，$1$ 到 $n$ 的最短路径的和，答案模 $998244353$。  


------------
题解：  
首先要推一堆结论：  
1. 当 $n$ 为奇数时，一定无解。很好证明，我们定义每个点的贡献：所有端点为为该端点的边的权值的乘积。因为为奇数，那么所有端点的贡献之积一定为 $-1$，因为是 $n\times -1$ 嘛。换个角度看，如果用边的贡献算所有端点的的贡献之积呢，那么对于每条边一定算了两遍，因为该边有两个顶点，在单独算的时候每个顶点会乘一遍，两个点就是两遍，那么我们可以得出结论，每条边的贡献都为 $1$，那么贡献之积一定也为 $1$ 与前面矛盾，所以一定无解。  
2. 对于每颗边加权树，一定是唯一解，从叶子节点开始思考，叶子节点只有一条边，那么一定为 $-1$，继续往上面思考，每个父节点，只剩下一条边未确定，因为所有边的乘积确定为 $-1$ 所以连向上的那个点也一定唯一。那么可以一直递推到根，所以具有唯一解。  
3. 根据性质 $2$ 我们甚至可以求出每条边的权值。考虑一个节点，若包括它本身的子树大小为 $x$，那么该边的权值为 $(-1)^x$ 很好证明，该点已经确定的边同样是 $(-1)^{x_{son}}$ 递归到最后就到叶子节点，而叶子节点的边我们确定是 $-1$ 所以可以归纳到该边为 $(-1)^x$。  

得出这些结论的你发现和这题并没有什么鸟用，你还是一头雾水，不知道怎么推柿子。  
然后回到本题，要求 $1$ 到 $n$ 的最短路径，那我们就考虑在路径上的边，其实就是这条边把整棵树分成两半，$1$ 在一边，$n$ 在另一边。继续结合我们的结论 $3$，那么 $1$ 和 $n$ 确定了，你得去构造你的子树了吧，那么我们设 $i$ 号边的子树大小就是 $i$，那么该子树选点可以有 $\binom{n-2}{i-1}$ 种选法，那么这条边怎么连呢，一边有 $i$ 个点，另一边为 $n-i$ 个点，这条边都可以连，那么就是一共有 $i\times (n-i)$ 种连法，再考虑两边的树结构那不就是 $i^{i-1}\times (n-i)^{n-i-2}$ 了嘛，就根据题意，或者根据 [凯莱公式](https://baike.baidu.com/item/%E5%87%AF%E8%8E%B1%E5%85%AC%E5%BC%8F/55604647?fr=aladdin)。那么最后根据乘法原理，搞在一起就好啦。  
结论就是：  
$\sum\limits_{i=1}^{n-1}(-1)^i\times\binom{n-2}{i-1}\times i\times(n-i)\times i^{i-2} \times (n-i)^{n-i-2}$  
基本没啥细节吧，随便搬个板子过来，一个循环就完了。  
代码：  
```
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int mod=998244353;
const int INF=0x3f3f3f3f;

inline ll read()
{
	ll x=0,f=1;char c=getchar();
	while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}
	while(c>='0'&&c<='9'){x=(x<<3)+(x<<1)+c-'0',c=getchar();}
	return x*f;
}

const int N=1e6+10;
ll f[N],invf[N];
ll ksm(ll a,ll b)
{
	int res=1;
	while(b)
	{
		if(b&1)res=res*a%mod;
		b>>=1;
		a=a*a%mod;
	}
	return res;
}
void init()
{
    f[0]=1;
    invf[0]=ksm(f[0],mod-2);
    for(int i=1;i<N;i++)
    {
        f[i]=f[i-1]*i%mod;
        invf[i]=ksm(f[i],mod-2);
    }
}
int C(int a,int b)
{
	if(a<b)return 0;
	return f[a]*invf[a-b]%mod*invf[b]%mod;
}

int main()
{
	init();
	ll n=read();ll ans=0;
	if(n&1){printf("0\n");return 0;}
	for(ll i=1;i<=n-1;i++)
		ans=(ans+((i&1)?-1:1)*C(n-2,i-1)*i%mod*(n-i)%mod*ksm(i,max(0ll,i-2))%mod*ksm(n-i,max(0ll,n-i-2))%mod+mod)%mod;
	printf("%lld\n",ans);
	return 0;
}

```
