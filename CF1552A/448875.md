### 题目大意：
有 t 组数据，每组数据会给你一个长度为 n 的字符串 s。
你可以选择 k 个数，并把这 k 个数排序。使字符串 s 最后按照字典序排序。问 k 的最小值

### 分析：
因为只需要输出需要排序的数的最小个数，所以我们无需考虑着 k 个数都是什么。

我们的目标仅是把字符串 s 按照字典序排序。也就是说，无论我们选的这 k 个数都是什么，只要能使 s 最终成为按照字典序排序的字符串就可以了。

再想一想，如果我们所选的数排好序后有的数相较与原先的位置没有变化，那么这一个数一定是不需要选的。

因为在这道题里，我们最后一定是把字符串 s 按照字典序排好了，在结合上面说的“位置没有发生变化的数一定不需要选择”，就可以得出结论：

#### 我们要输出的 k 就是字符串 s 在排序中位置发生改变的个数。

### 实现：
经过上述的分析，实现其实已经很明了了。

在读入字符串 s 之后，先为 s 排序，然后用排好序的 s 与没有排序的做对比，如果有的位置上的字符发生了改变，答案增加一。

### 代码：
```c
#include<iostream>
#include<algorithm>
using namespace std;
char s[10000];
char e[10000];
int main(){
	int t;
	cin>>t;
	while(t--){
		int n;
		cin>>n;
		int ans=0;
		for(int i=1;i<=n;i++){
			cin>>s[i];
			e[i]=s[i];
		}
		sort(s+1,s+n+1);
		for(int i=1;i<=n;i++){
			if(s[i]!=e[i]){
				ans++;
			}
		}
		cout<<ans<<endl;
	}
	return 0;
}
```
