写个人能看的题解。

### 怎么做

我们考虑对每个点分别计算这个概率，为了方便不妨在计算一点答案时将其设为树根。

我们先把“删边”这个操作变成一个比较容易处理的形式。在有根树意义下，删除边 $u-v$ 时，不妨设 $u$ 是 $v$ 的父节点，我们认为，这个操作把 $v$ 的所有子树接到了 $u$ 上，然后删除掉 $v$ 这个节点，之后节点 $u$ 的编号是新选择的编号。

记 $f_{u,j}$ 表示，在 $u$ 的子树中，对于所有删边顺序，仅对最后 $j$ 条边选择保留的编号，而其他边随意选择时，根节点的编号仍然是 $u$ 的概率之和。节点 $x$ 最后的答案是 $\frac{f_{x,n-1}}{(n-1)!}$。

考虑类似树上背包地合并子树的 dp 值。我们分两步完成将 $f_v$ 合并至 $f_u$ 的这一过程。

第一步是，我们要加入边 $u-v$。我们考虑 $v$ 的子树和节点 $u$ 连接在一起形成的这棵树 $T$，令 $g_i$ 表示，在 $T$ 中，对于所有删边顺序，仅对最后 $i$ 条边选择保留的编号时，根节点的编号仍然是 $u$ 的概率之和（和 $f_{u,j}$ 定义是一样的）。

考虑如何计算 $g_i$，我们枚举边 $u-v$ 在倒数第几步被删掉。

第一种情况是，$j\leq i$，也就是说边 $u-v$ 被收缩时，新的编号已经被确定。我们在确定这条边的编号时，必须要选 $u$，因此要乘上一个 $\frac{1}{2}$ 的概率，然后，这条边之前的编号选择是随意的，而收缩之后，剩下 $j-1$ 条边选择编号时都必须保留 $u$，而因为，$v$ 的子树都被连接到了 $u$ 上，这等同于在 $v$ 的子树中保留 $v$，概率之和是 $f_{v,j-1}$，转移式为 $g_i \leftarrow f_{v,j-1}$。

第二种情况是 $j > i$，也就是这条边不需要确定编号，而且在最后 $i$ 条边之前已经被收缩掉了。收缩后 $i$ 条边时，必须保留 $u$ 等同于之前必须保留 $v$，也就是 $g_i \leftarrow f_{v,i}$。

现在，我们已经成功地将 $u-v$ 这条边包含了进来，可以考虑如何与考虑完之前子树的答案合并了。

考虑在之前的子树中选了 $i$ 条边的编号，而在需要合并上来的 $T$ 中选了 $j$ 条边，我们需要把有编号的边放一起，没有编号的边放一起，需要保持两个子树内部删边的相对顺序不变。记 $M$ 和 $N$ 分别为之前已经被合并进来的边数和 $T$ 中的边数，根据组合意义，方案数为 $\binom{i+j}{j} \binom{M+N}{N}$，转移式为 $f_{u,i+j} \leftarrow f_{u,i} g_j \binom{i+j}{j} \binom{M+N}{N}$。

通过树上背包的上下界优化，容易做到 $O(n^4)$。

### 怎么想到这么做

对每个点单独计算贡献可以说是一种常见做法。在转化成有根树之后，我们发现，收缩 $u-v$ 时，这条边之前的编号选择是随意的，之后的话，由于此时的 $v$ 已经变成了 $u$，这些边选择编号时不能把 $v$ 吃掉，至此容易看出子问题的形式，我们需要保证后若干条边不吃掉根节点，记录一下即可。

```cpp
#include <bits/stdc++.h>
int n,u,v,size[55];
double f[55][55],C[55][55],g[55],h[55],fac[55];
std::vector<int>ch[55];

void dfs(int u,int pr){
	f[u][0]=1;size[u]=1;
	for(int v:ch[u]){
		if(v==pr)continue;
		dfs(v,u);
		std::memset(g,0,sizeof(g));
		for(int i=0;i<=size[v];++i)
		for(int j=1;j<=size[v];++j){
			if(j<=i)g[i]+=0.5*f[v][j-1];
			else g[i]+=f[v][i];
		}
		std::memset(h,0,sizeof(h));
		for(int i=size[u]-1;i>=0;--i)
		for(int j=size[v];j>=0;--j)
			h[i+j]+=f[u][i]*g[j]*C[i+j][j]*C[size[u]-i-1+size[v]-j][size[u]-i-1];
		for(int i=0;i<size[u]+size[v];++i)f[u][i]=h[i];
		size[u]+=size[v];
	}
}

int main(){
	scanf("%d",&n);
	for(int i=0;i<=n;++i){
		C[i][0]=1;
		for(int j=1;j<=i;++j)C[i][j]=C[i-1][j]+C[i-1][j-1];
	}fac[0]=1;for(int i=1;i<=n;++i)fac[i]=fac[i-1]*i;
	for(int i=1;i<n;++i){
		scanf("%d%d",&u,&v);
		ch[u].push_back(v);
		ch[v].push_back(u);
	}for(int i=1;i<=n;++i){
		std::memset(f,0,sizeof(f));
		dfs(i,0);
		printf("%.7f\n",f[i][n-1]/fac[n-1]);
	}
	return 0;
}
```
