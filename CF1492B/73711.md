# 翻译
你有一叠牌，共有 $n$ 张，编为 $p_1\sim p_n$（其中 $p_1$ 为最下面， $p_n$ 为最上面）,你要将这一叠牌移动至另一叠 $p_1'\sim p_n'$。

你的移动方式是：从上往下选择一部分牌（连续），将其按原顺序平移至第二叠牌的上方。

此时，我们令一叠牌的权值为 $\sum\limits_{i = 1}^{n}{n^{n - i} \cdot p_i} $。

最后你要使平移后的牌权值最高，求最后牌的摆放顺序，即按序输出 $p_1'\sim p_n'$。
# 题意分析
对于这类题，最关键的地方在于牌移动的顺序究竟该如何选择。所以我们要考虑两点，一个是它搬运的方式，另一个是它价值的计算。

1. 搬运方式：

我们可以看出，每次取牌时，断点处的牌会在这部分牌的最下方。

2. 统计方式：

我们可以发现，其答案可近似看作一个 $n$ 进制数，不过每一位的数为 $1\sim n$（正常的 $n$ 进制数应为 $0\sim n-1$）。所以，我们只要将答案减去 $11...1$，就可以将其转化为一个真正的 $n$ 进制数。我们又可以想到，两个 $n$ 进制数的大小比较方式为从高到低，只要有 $a_i$ 比 $b_i$ 大，则 $a>b$。所以，我们只需要让最大的数尽可能靠下就可以了。

因此我们从大往小（即从最上方往最下方）扫，遇到当前剩余牌的最大的，就将这一叠往后移，这样就可以保证大的牌尽可能在最下，以让最后的答案最大。
# Code
```cpp
#include<bits/stdc++.h>
using namespace std;
int T;
int n;
int p[100001];
int s[100001];
bool b[100001];
int head;
inline void out()
{
	while(head)
	{
		cout<<s[head]<<" ";
		b[s[head--]]=1;
	}
	return ;
}
int main()
{
	cin>>T;
	for(int t=1;t<=T;t++)
	{
		memset(b,0,sizeof(b));
		cin>>n;
		int now=n;
		for(int i=1;i<=n;i++)
		{
			cin>>p[i];
		}
		for(int i=n;i>=1;i--)
		{
			s[++head]=p[i];
			if(s[head]==now)
			{
				out();
			}
			while(b[now])
			{
				now--;
			}
		}
		out();
		cout<<endl;
	}
	return 0;
}
```
