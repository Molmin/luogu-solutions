与@Curry28同学的出发点相似，其实从[0,n](注意是开区间）有多少个x是有数学规律的；

我的方法是首先分析个位：

每10位会有一个x；

n%10 后若大于x 则有1个；

以此类推

对于第n位

每10^n位会有10^(n-1)个x；

n%10^n后再与x\*10^(n-1)比较，进行计算；(算零头)

由于除了位数的讨论以外没有循环，所以在O(log10n）


但由于本题的范围是[1,n]所以要讨论0的情况

在比赛时这种方法显然不好

但是可以作为思路拓展

[/color][codec ]



    




```cpp
#include <iostream>
#include <math.h>
using namespace std;
int loop(int a,const int n,const int x)        //a位数     n，x为输入
{
    if (a == 0)                                         //递归尾部
    {
        return 0;
    }
    int k=int(n/int(pow(10,a)));                              /*--------------这两步在讨论整的部分---------------------*/
    k *= int(pow(10, a - 1));                                   /*--------------------------------------------------------*/
    int p1 =int (n %int(pow(10, a))),                           /*--------------------------------------------------------*/
        p2 = (x + 1)*int(pow(10, a - 1)),
        p3 = x*int(pow(10, a - 1));
    if (p1 >= p2)                                                                //这一大部分讨论 零头
        k += pow(10, a - 1);
    else if (p1 >= p3)
        k += p1%int(pow(10, a - 1));                     /*--------------------------------------------------------*/
    int z = loop(a - 1, n, x)+k;                                   //递归
    return z;
}
int main()
{
    int x = 0, a = 0, b = 0, c = 0; int n = 0;
    cin >>n>> x;
    while (int(n / pow(10,a)) != 0)  //判断最高位数
    {
        a++;
    }
    if (x == 0)                           //在讨论 x==0的情况
    {
        if (n < 10)
        {
            cout << 0;
            return 0;
        }
        cout << loop(a-1, n + 1, x)-111111111111%int(pow(10,a-1)); // 这个用来解决被误算的数（以零开头的数）
        return 0;
    }
    cout<<loop(a, n+1, x);       //因为loop函数讨论的是[0,n-1],因此用n+1；
}
```
[/codec ]

感觉自己写得太烂了【扶额·····】
