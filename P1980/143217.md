这个题的关键是对于0这种特殊情况的处理，log10n复杂度的算法就是对每个位依次处理。
- 对于1-9这部分数字，对于某个考虑的十进制位，该位的左半部分可以从0变到当前这个数字减一，例如34535,若我们统计5的出现次数，在考虑百位时，可以将百位固定为5，左半部分从0到33，有34种情况。在左半部分如此变化的情况下，目标位右半部分可从全0变到全9，在上面的例子中，右半部分可从00变到99，共100中情况。两者相乘则得到目标位大部分的情况(34x100)。但我们遗漏了左半部分为34的情况，这种情况我们需要根据目标位上的数字进行判断。
 - 目标位小于目标数字，那么就可以pass了，该目标位出现的次数就是上面的方法所计算的。
 - 目标位等于目标数字，那么还需要加上右半部分的数字+1的情况。（例中即从34500到34535，共36种）
 - 目标位大于目标数字，那么就可以直接目标位固定，右半部分从全0到全9了。
- 对于0这种特殊情况，左半部分不能从0开始，只能从1开始，因为高位都为0的话目标位的0并不会出现。如34535，统计百位的0的次数，即只能首先考虑(1-33)0(00-99)的33x100种情况。而对于左半部分最大时目标位的情况，我们需要考虑两种情况。
 - 目标位上刚好是0，比如34035，我们只有34000-34035，共36种情况，即右半部分数字+1。
 - 目标位上大于0，比如34535，那么我们可以由34000-34099的100种情况。

------------


 ```cpp
#include <iostream>
using namespace std;

int main() {
    int n, x;
    cin >> n >> x;
    int tmp;
    int occur = 0;
    int multi = 1;
    int last = 0;
    int res;
    while (n > 0) {
        tmp = n / 10;
        res = n % 10;
        occur += tmp * multi;
        if (x > 0) {
            if (res > x)occur += multi;
            else if (res == x) occur += last + 1;
        }
        else if (res==x) occur += last + 1 - multi;
        last += res * multi;
        n = tmp;
        multi *= 10;
    }
    cout << occur << endl;
    return 0;
}
```