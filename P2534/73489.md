`IDA*`往往是估价函数与迭代加深结合在一起。不过这道题我看了大佬的讲解才发现根本用不到迭代加深，而估价函数则起剪枝的作用。

- 首先注意读题，只能从顶部开始反转，也就是说只能从1开始翻转。另数据里$N\le 16$，讨论里也提到了，`N = 50`是没法做的。

- 本题最重要的估价函数就是相邻两项的差不为1的数对个数`f`，这是因为最终状态的`f`为`0`，每一次反转`[1, i]`时相邻的`(i, i+1)`被替换为`(1, i+1)`，答案最多减少1，所以至少还要`f`步才能转化成功，`f`小于等于实际步数，满足估价函数的要求。当然输入的相邻两个数不一定相差1，这是就要离散化。

- 因为要最少的反转，所以每次反转都是要希望减少`f`的，显然最多只需要`N`次，所以`ans`初值可以设为`N`。另外我们发现`1,2...N`和`N,N-1...1`两种排列`f`都是0，但是只有前一种才对，所以可以增加特判`a[1]==1`时才更新答案。

- `f`不一定要每次计算，我们反转`[1, i]`时，相邻数对只有`(i, i+1)`被替换为`(1, i+1)`，有$f += (|a[1] - a[i+1]|\neq 1) - (|a[i] - a[i+1]|\neq 1)$，记得回溯就可以了。

```cpp
#include <bits/stdc++.h>
using namespace std;

int N, f, ans, a[17], t[107];

void DFS(int sum)
{
	if (sum + f >= ans) return;
	if (!f && a[1] == 1)
	{
		ans = sum;
		return;
	}
	for (int i = 2; i <= N; i++)
	{
		if (i != N)//直接把[1, N]整个翻转是不会改变f的 
			f += (abs(a[1] - a[i+1])!=1) - (abs(a[i] - a[i+1])!=1);
		reverse(a + 1, a + i + 1);
		DFS(sum + 1);
		reverse(a + 1, a + i + 1);
		if (i != N)//直接把[1, N]整个翻转是不会改变f的
			f -= (abs(a[1] - a[i+1])!=1) - (abs(a[i] - a[i+1])!=1);
	}
}

int main()
{
	scanf("%d", &N);
	for (int i = 1; i <= N; i++)
		scanf("%d", a + i), t[a[i]]++;
	for (int i = 1; i <= 100; i++)
		t[i] += t[i-1];
	for (int i = 1; i <= N; i++)
		a[i] = t[a[i]];
	for (int i = 1; i < N; i++)
		f += (abs(a[i] - a[i+1]) != 1);
	ans = N, DFS(0);
	printf("%d\n", ans);
}
```