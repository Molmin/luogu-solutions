看到没有人写题解，过来搬运一下官方题解。

来自：[alpha1022](https://www.luogu.com.cn/paste/4qn38il5)。

将询问离线，按右端点作扫描线，同时考虑维护 $f(s)$ 表示子串 $s$ 目前为止最后出现的位置的右端点。  
考虑一个目前位置新出现的子串 $t$ 的贡献，在更新 $f(t)$ 之前，会发现新增加一个 $t$ 使得左端点在 $f(t)-|t|+1$ 之前的询问都会将 $t$ 计入答案。于是我们需要一个支持前缀和 $|t|$ 取 max，单点查询的数据结构；可以显然地转化为单点修改，查询前缀 max，容易使用树状数组完成。

不过到此为止该做法仍然非常朴素，考虑使用 LCT 维护反串后缀树，在每个状态上维护 $f$ 值。新加入右端点类似于 LCT 的 access 操作，容易维护。  
新出现的另一个问题在于后缀树的状态包含了不止一个字符串。想必精通后缀树 / 后缀自动机的您一定看出来了，这时我们的数据结构就需要另外支持区间和公差为 $1$ 的等差数列取 max。  
对于 general 的公差不固定的问题，~~根据 EI 鸽鸽的教诲~~使用二进制分组 + cascading 可以做到 $O(n \log n \alpha(n))$，不过这是题外话了。  
事实上可以把操作化为这样的形式：对于 $l \le i \le r$，令 $a_i = \max(a_i,x-i)$。考虑维护一个 $b_i = a_i - i$，那么操作就变成了 $b_i = \max(b_i,x)$ 并单点查询，使用线段树可以轻松解决。