### 非常不错的一道题，进制转换与高精度的完美结合
这道题的总体难度不高，但是也有一些点需要注意，不然就会各种~~WA RE CE~~

下面进入正题，首先是读入数据，这一部分的难点在于进制大于10时如何处理——这也时整道题的难点之一。

这里我们选择分类讨论的思想，对读入的每一位数字，0-10常规处理（关于这种常规方法这里就不再赘述啦），A-Z（大于10）则采取另一种处理方法，没错！同样是利用ASCII这个神奇的东西。ASCII这个东西嘛，自己去看一下相信你会恍然大悟的。~~只可意会不可言传~~。

对于每一位A-Z的数字，由char型转变为int型只需减掉55，~~你非要写成'7'也不是不行~~，下面代码
```
scanf("%s",s1);
scanf("%s",s2);
int l1=strlen(s1);
int l2=strlen(s2);
for(int i=0;i<l1;++i)
{
	if(s1[i]>=48 && s1[i]<=57)
	{
		a[l1-i] = s1[i]-48;
	}
	else if(s1[i]>=65  && s1[i]<=90)
	{
		a[l1-i] = s1[i]-55;
	}
}
for(int i=0;i<l2;++i)
{
	if(s2[i]>=48 && s2[i]<=57)
	{
		b[l2-i] = s2[i]-48;
	}
	else if(s2[i]>=65  && s2[i]<=90)
	{
		b[l2-i] = s2[i]-55;
	}
}
```
下面就是计算的部分啦，在此之前，我们可以先回忆十进制的高精度加法，是如何进位的呢？？应该是这个样子
```cpp
res[i]+=(a[i]+b[i]);
if(res[i]/10)
{
	res[i+1]+= res[i]/10;
	res[i]%=10;
}
```
第一步，将加数与被加数相加得到对应的和；第二步，判断是否能进位：如果不能，结束；如果能，模拟**进位的过程**
那么仅为的过程是如何实现的呢？？代码已经很清晰了，10就是进制！

同样，这本题中，我们可以把进制约定为k，那么进位的部分就应该这样写：
```
for(int i=1;i<=l1||i<=l2;++i) //模拟竖式，依次相加每一位
{
	res[i]+=(a[i]+b[i]);
	if(res[i]/k)
	{
		res[i+1]+= res[i]/k;
		res[i]%=k;
	}
}
```

到这里，计算的过程已经Ok，下面需要处理的是仍然是一些细节。

前导零的处理，这一直是令很多萌新头疼的事，到底从第几位开始判定很难确定，不过我们可以多留出几位，比方说，由常识可知某一位一定为前导零，那么我们就从这一位开始判定，代码
```
int p=l1+l2;
while(res[p]==0 && p!= 1)
{
	--p;
}
```
PS：~~虽然这个方法比较容易去想，但是毕竟不利于自身的提高，继续学习建议使用更精准的方法~~

下面是输出的过程，由前面我们可以知道，应该从第p位，也就是res[p]开始输出，当然，我们在输出的过程中也要注意处理进制的问题。 这里我们仍然采用分类讨论的思想（具体看前面），代码如下：
```
for(int i=p;i>=1;--i)
{
	if(res[i]>=0 &&res[i]<=9)
	{
		printf("%d",res[i]);
	}
	else if(res[i]>=10&&res[i]<=35)
	{
		printf("%c",res[i]+55);
	}
}
```
到这里就OK啦，下面是完整代码：
```
#include <bits/stdc++.h>
using namespace std;

int k;
const int N=2000+10;
char s1[N],s2[N];
int a[N],b[N],res[N+N];

int main()
{
	scanf("%d",&k);
	scanf("%s",s1);
	scanf("%s",s2);
	int l1=strlen(s1);
	int l2=strlen(s2);
	
	for(int i=0;i<l1;++i)
	{
		if(s1[i]>=48 && s1[i]<=57)
		{
			a[l1-i] = s1[i]-48;
		}
		else if(s1[i]>=65  && s1[i]<=90)
		{
			a[l1-i] = s1[i]-55;
		}
	}
	
	for(int i=0;i<l2;++i)
	{
		if(s2[i]>=48 && s2[i]<=57)
		{
			b[l2-i] = s2[i]-48;
		}
		else if(s2[i]>=65  && s2[i]<=90)
		{
			b[l2-i] = s2[i]-55;
		}
	}
	
	for(int i=1;i<=l1||i<=l2;++i)
	{
		res[i]+=(a[i]+b[i]);
		if(res[i]/k)
		{
			res[i+1]+= res[i]/k;
			res[i]%=k;
		}
	}
	
	int p=l1+l2;
	while(res[p]==0 && p!= 1)
	{
		--p;
	}
	
	for(int i=p;i>=1;--i)
	{
		if(res[i]>=0 &&res[i]<=9)
		{
			printf("%d",res[i]);
		}
		else if(res[i]>=10&&res[i]<=35)
		{
			printf("%c",res[i]+55);
		}
	}
	
	return 0;
}
```

完结，撒花！！！