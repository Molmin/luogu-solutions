这边来了一个励志于把主函数写得短小精悍而写了 $operator$ 的蒟蒻......

---

**【分析】**
--

很明显，题目就是把[P1601](https://www.luogu.org/problemnew/show/P1601)的进制改了改,数据范围改了改，其他都是不变的。

介于有一些人可能还不了解高精度，这边做一个简单的讲解(注意，前方玄学讲解)

已经了解的大犇请跳到下一条分割线下

对于一个整数，我们一般用 $int$ 储存，而对于更大的，我们需要用到 $long$ $int$ 、 $long$ $long$ $int$ 甚至 $unsigned$ $long$ $long$ $int$

而对于再大一点的，我们就没办法用已有的变量来存了($int128$ 除外，那个好像很多地方不能用)

因此，我们必须靠手写一个新的变量

这个跨越可能对于第一次接触的人来说挺匪夷所思的，但其实很好理解。就如对于已有的函数不能满足我们需求的时候，我们需要自己写函数

好的，我们继续

对于这个新的变量，它要储存一个很大的数，我们暂且称呼它为大数($bignum$)

那么，对于大数，我可以把它的每一位都看作一个单独的数，那么，这个大数就可以用一个数组来描述。

比如，我对于 $314159265358972718281829$ 这个数，我们用一个数组$n_i$去描述它

那么，我们该把 $3$ 视为 $n_0$ 还是把 $9$ 视为 $n_0$ 呢？

我们来考虑一下进位

如果两个数进行运算后需要进位，那么进位是进在最左边那个数字的左边

如果我们把 $3$ 作为 $n_0$ ，那么进位时多出来的数字得往前存到 $n_{-1}$ ，这岂不是匪夷所思吗？

相反，如果我们把 $9$ 作为 $n_0$ 那么，进位时 $3$ 的进位只要再往后一个就可以了

因此，我们习惯把数字的最后一个数作为 $n_0$ ，倒数第二个为 $n_1$ ，以此类推(这里暂时不考虑压位)

对此，我们还要一个东西来描述这个数字，就是这个数字是几位数

它的意义就是数组 $n_i$ 的大小，我们可以一个变量 $l$ 来维护

那么，对于这题，我们还需要一个变量 $b$ 来维护其进制数

---

好的，那我们接下来考虑如何实现 $bignum$ 的加法

我们通过列竖式可以发现，我们进行十进制数的加法时，习惯先求和同一个位上的数，再把它大于 $10$ 的部分进位，其余的留下

十进制数的意义实质上就是满 $10$ 进 $1$ ，因此，对于题目中的 $b$ 进制，就是满 $b$ 进 $1$ 。

所以，我们对于加法可以这么实现：

先重新定义一个 $bignum$ 变量为

这个 $bignum$ 变量中的每一位 $n_i$ 都由相加的两个 $bignum$ 变量求和而得

之后， $n_0$ 开始往前进位

最后，我们重新检查一下这个 $bignum$ 的 $l$ 与它实际长度是否相同，不同的话我们要进行修改(比如 $999+1$)

---

接下来讲个本蒟蒻的个人习惯

个人喜欢把主函数写的比较短小精悍，那么，这些~~有的没的~~全部可以用一个结构体封装起来

那么，如果我们再对 $bignum$ 写读入输出操作、初始化操作就可以很优雅的将主函数缩短了

这部分不难，就不做讲解了，各位可以看本蒟蒻代码自行理解

对于字母转成数字的怎么办呢？

当然也是强行封装啦 ~~2333333~~

---

**【代码】**
--

那本蒟蒻就放代码了

```cpp
#include<cstdio>
using namespace std;
#define f(a,b,c) for(int a=b;a<=c;a++)
#define g(a,b,c) for(int a=b;a>=c;a--)
struct bignum{
	int b,l,n[2048];
	inline void clr() { l=1; f(i,0,2047) n[i]=0; }
	bignum(int b):b(b) { clr(); }
	inline int tra(char c){
		if((c>='0')&(c<='9')) return c-'0';
		if((c>='A')&(c<='Z')) return c-'A'+10;
		return -1;
	}
	inline char tra(int c){
		if(c<=9) return c+'0';
		else return c-10+'A';
	}//这两个函数虽然函数名一样，但其传入的变量是不一样的，计算机会自己识别该用哪一个
	inline void init(){
		int stack[2048]={0},size=0;
		char c=getchar();
		while(tra(c)<0) c=getchar();
		while(tra(c)>=0) stack[size++]=tra(c),c=getchar();
		clr(); l=0;
		while(size--) n[l++]=stack[size];
	}//读入
	inline void outit() { g(i,l-1,0) putchar(tra(n[i])); }
    //输出
	bignum operator + (const bignum &x){
		bignum y(b);
		y.l=(l>x.l)?l:x.l;
		f(i,0,y.l-1) y.n[i]=n[i]+x.n[i];
		f(i,0,y.l-1) y.n[i+1]+=y.n[i]/y.b,y.n[i]%=y.b;
		while(y.n[y.l]) y.l++;
		return y;
	}//加法实现
};
int main(){
	int b; scanf("%d",&b);
	bignum x(b),y(b),z(b);
	x.init();
	y.init();
	z=x+y;
	z.outit();
	return 0;
}
```