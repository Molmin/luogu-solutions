#### 简化题意

给定你 $10$ 个 `01` 字符串去进行递归。如果字符串的这一位是 `1` 就将这个字符串分成两部分，如果这一位是 `0` 则停止递归。

#### 大概思路

将一个字符串分成两部分时，每一次分裂都面临着一个选择，即到底从左边分还是从右边分。遇到 `0` 不做任何处理，即直接退出这一边的递归。所以，我们可以使用一个递归函数，读入指令时如果为 `1` 就继续递归，反之退出。

#### 代码部分

```cpp
#include<iostream>
using namespace std;
int a,b,x=0;//三个变量分别表示长度，最终答案以及切割总数。数据范围起见，我们使用int。
void digui(int now)//注意，now和len虽然都是切割次数，但一个是目前的，一个是求最大值的，所以含义并不一样。
{
    char c;
    cin>>c; //一次读入一个字符
    if(now>a)
    { //目前切割次数大于最大之前存的切割次数
        a=now; //更新答案的长度
        b=x;
    }
    //c=='0' 表示不割，否则表示割
    if(c=='0')//如果是0
    {
        return ;//终止递归
    }
    else//如果是1
    {
        x++; //又多割了一次
        digui(now+1); //切割左边
        digui(now+1); //切割右边
    }
}
int main()
{
    for(int i=1;i<=10;i++)
    {
        int l; //这里的l表示每一组数据的长度
        cin>>l;
        x=0; //初始化。
        a=-1; //记录为-1，如果你想写0也不是不行
        digui(0); //肯定没开始切，所以从now=0开始递归。
        cout<<b<<endl;//每日一个换行小习惯
    }
    return 0;
}

```