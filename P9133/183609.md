题目名称：大富翁  
时间限制：$\text{1s}$   
内存限制：$\text{512MB}$   
题目类型：传统题

#### 题意简述

给定一棵由 $n$ 个结点构成的树，每个点有点权 $w_i$，双方轮流选点，每次当前方必须花费 $w_x$ 个游戏币选择一个没有选择过的节点 $x$，如果此次操作后 $x$ 的子树内有 $p$ 个对方选取过的点，祖先中有 $q$ 个对方选取过的点，那么就可以从对方那里获得 $(p-q)$ 个游戏币，求在游戏过程结束后先手所能赚取游戏币的最大数量（游戏过程中游戏币数量可以为负数且双方均使用最优策略）。

对于所有数据，$1\le n\le2\times10^5$，$0\le w_x\le2\times10^5$。

#### 题目解法

还是考虑拆贡献，考虑最终局面中一对存在祖孙关系的结点 $x$ 和 $y$（$x$ 是 $y$ 的祖先），假设先手为 $A$，后手为 $B$，则存在以下四种情况：

- $x,y$ 均为 $A$ 选择，此时对先手的贡献为 $0$；
- $x,y$ 均为 $B$ 选择，此时对先手的贡献为 $0$；
- $x$ 为 $A$ 选择，$y$ 为 $B$ 选择，此时对先手的贡献为 $1$；
- $x$ 为 $B$ 选择，$y$ 为 $A$ 选择，此时对先手的贡献为 $-1$。

发现，若将 $x$ 的点权设置为 $1$，$y$ 的点权设置为 $-1$，则最终先手获得的贡献即为他获得的点的价值和。

所以，先假设第 $x$ 个点的点权为 $-w_x$，再对于所有这样的点对 $(x,y)$，将其中 $x$ 的点权加上 $1$，将 $y$ 的点权减去 $1$，则最终 $A$ 或 $B$ 选取的点的点权之和即为 $A$ 赚取游戏币的数量。

容易发现，此时第 $i$ 个点的点权即为 $\text{siz}_i-\text{dep}_i-w_i$，且在最优策略下 $A$ 所能选取的点权为所有点的点权从大到小排序后奇数下标的点权，可以直接 $\text{dfs}$ 后排序求出，时间复杂度 $\mathcal{O}(n)$。

#### 参考代码

```cpp
#include <bits/stdc++.h>

using namespace std;

const int N = 2e5 + 5;

int siz[N], dep[N], w[N];
vector<int> G[N];

void dfs(int x)
{
    siz[x] = 1;
    for (int i = 0; i < G[x].size(); ++i) {
        int v = G[x][i];
        dep[v] = dep[x] + 1;
        dfs(v);
        siz[x] += siz[v];
    }
    return;
}

signed main()
{
    int n;
    scanf("%d", &n);
    for (int i = 1; i <= n; ++i) {
        scanf("%d", &w[i]);
    }
    for (int i = 2, fa; i <= n; ++i) {
        scanf("%d", &fa);
        G[fa].push_back(i);
    }
    dfs(dep[1] = 1);
    for (int i = 1; i <= n; ++i) {
        w[i] = (siz[i] - 1) - (dep[i] - 1) - w[i];
    }
    sort(w + 1, w + n + 1, greater<int>{});
    long long res = 0;
    for (int i = 1; i <= n; i += 2) {
        res += w[i];
    }
    printf("%lld\n", res);
    return 0;
}
```

#### 总结

对于这类有关点权的博弈问题，可以拆开点权，然后利用线性性进行合并每个点的贡献，最终可以转化为简单的博弈问题进行解决。