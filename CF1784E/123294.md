在 $s$ 无穷拼接的过程中，对于每个 $s$，在执行它对应的比赛之前，只有初始比分会改变。初始比分共四种状态，分别记为 $0, 1, 2, 3$。

现在，我们只要知道初始比分 $i$ 经过 $s$ 之后的最终比分 $j$ 以及 A 获胜的轮数减去 B 获胜的轮数 $k$，就可以确定 $s$ 对应的 $r$ 值：从 $0$ 开始，经过一段 $\rho$ 型路径到达一个环，设 $\Delta$ 为环上所有 $k$ 值之和，若 $\Delta > 0$，则 $r > \frac 1 2$；若 $\Delta = 0$，则 $r = \frac 1 2$（尽管前面会有不在环上的路径，但当轮数趋于正无穷时，它对比值的贡献几乎不存在）；若 $\Delta < 0$，则 $r < \frac 1 2$。

$i\to (j, k)$ 形成了映射 $f$，我们求出使得经过 $s$ 后对应关系为 $f$ 的 $s$ 的数量。对于某个映射 $f$，在其后添加 $a$ 或 $b$，会得到不同的新的映射 $f_1, f_2$。我们将涉及到的 $f$ 用一个数表示（相当于离散化），再进行 DP。内层映射的转移是直接模拟，所以应该算不上 DP 套 DP，就是一个简单的 DP 自动机。

看似状态数为 $\mathcal{O}(n ^ 4)$ 并带有常数 $4 ^ 4 = 256$，但看上去就很跑不满。最终状态数 $\mathcal S$ 只有不到 $10 ^ 6$ 种，而时间复杂度为 $\mathcal{O}(n\mathcal S)$（可能还要算上离散化的 $\mathcal{S} \log \mathcal{S}$），可以接受。[代码](https://codeforces.com/contest/1785/submission/192577785)。

另一种时间复杂度更可观的做法：直接枚举环上的所有点（$2 ^ 4$ 种情况），这样就不需要对每个 $i$ 维护对应的 $k$，而是直接维护环上的点的 $\sum k$，统计答案时检查一下是否合法即可。

时间复杂度 $\mathcal{O}(n ^ 2)$ 并带有常数 $2 ^ 4\times 4 ^ 4 = 4096$。懒得写了。