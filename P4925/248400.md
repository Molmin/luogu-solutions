## 题目简述
- 给一个由 $k$ 中不同字符组成的长度为 $n$ 的字符串。
- 其中没有一个长度超过 $1$ 的连续子串是回文串。
- 规定第 $s$ 为是字符 $w$。（如果 $s=0$ 表示没有限制）
- 求可能方案数对 $p$ 取模的结果。

## 解题思路
首先直觉告诉我们 $w$ 没什么用。可以不用管他。

其中没有一个长度超过 $1$ 的连续子串是回文串，意味着没有出现 $\mathtt{aa}$ 或者 $\mathtt{aba}$ 的形式。只要满足这两个条件就好了（因为其他回文串都包含这两种连续子串）。

假设 $s=0$，那么：
- 第一位就有 $k$ 种选择。
- 第二位因为不能和第一位相同，所以只有 $k-1$ 中选择。
- 第三位不能和第一第二位相同，而且第一第二位必然不同。所以一共 $k-2$ 中选择。
- 剩下的同第三位一样都有 $k-2$ 种选择。

也就是说，一共有 $k\times (k-1)\times (k-2)^{n-2}$。当然要特判 $n=1$ 时。

如果 $s\not=0$，那么因为所有答案中 $s$ 位在所有字符集中出现的概率是均匀的。也就是说会是所有的情况的 $\dfrac{1}{k}$ 。所以答案是 $ (k-1)\times (k-2)^{n-2}$。淡然也要特判 $n=1$ 时。

一个比较阴的点是 $k\leq10^{18}$。不能直接快速幂，需要先把 $k$ 对 $p$ 取模。

## 参考代码
```cpp
#include<iostream>
using namespace std;
#define ll long long
ll n,k,p,s,w;
ll ksm(ll a,ll b){
	ll r=1;
	while(b){
		if(b&1) r=r*a%p;
		a=a*a%p;
		b=b>>1;
	}
	return r;
}
int main(){
	cin>>k>>n>>p>>s>>w;
	k%=p;
	if(s==0){
		if(n==1) cout<<k;
		else cout<<k*(k-1)%p*ksm(k-2,n-2)%p;
	}
	else{
		if(n==1) cout<<"1";
		else cout<<(k-1)*ksm(k-2,n-2)%p;
	}
	return 0;
} 
```
