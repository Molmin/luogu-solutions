这一题题意为,求由$K$个字符组成,长度为$L$且第$s$位为$w$的字符串的个数,再膜$^{[1]}p$



虽然不知道为什么这一题会有状压标签,但是看$L$的大小就可以知道它与状压应该没什么关系,而是一道**数学题**



先来看$s==0$的情况



首先我们知道,所求字符串的第一位有$K$中可能,我们设第一位为$A$,我们**一步步来构造这个字符串**,我们先加入第一位




此时字符串为"$A$"



然后再来看第二位,因为**不能存在长度大于1的回文串**,所以第二位不能为$A$,所以只剩$K-1$种选择,设第二个字符为$B$,加入到字符串



此时字符串为"$AB$"



然后再来看第三位,因为不能存在长度大于1的回文串,所以第三位不能为$B$,也不能为$A$,所以只剩$K-2$种选择,设第三个字符为$C$,加入到字符串



此时字符串为"$ABC$"



然后再来看第四位,因为不能存在长度大于1的回文串,所以第四位不能为$C$,也不能为$B$,但是可以为$A$,因为"$ABCA$"中不可能存在长度大于1的回文子串,所以有$K-2$种选择,设第四个字符为$D$,加入到字符串



此时字符串为"$ABCD$"




从第四位开始剩下的$L-3$位,都和第四位一样,有$K-2$种选择



以此类推,我们不难发现$^{[2]}$,答案为$K\times (K-1)\times (K-2)^{L-2} \bmod p$



再来看$s≠0$的情况,如果你将这种情况想成像上面一样从第一位开始填,然后要满足第$s$位为$w$,然后第$s-1$,$s-2$为不能为$s$,那情况将会变得**复杂很多**,我们可以换一种思路,假我们想一下最终得到的字符串,字符$w$一般是在其中间的位置,**我们设构造$w$左边的字符串有$a$种方法,构造完左边的后再构造右边的字符串有$b$种方法,可以知道答案为$a\times b \bmod p$**



所以我们先来考虑构造$w$左边的字符串,**我们可以从$w$的左边开始构造(即先构造第$s-1$个字符)**,因为它不能为$w$,所以有$K-1$种选择,我们设这个字符为$A$,加入字符串中



此时的字符串为"$\cdots \_~\_ ~\_~ \_~~ A~w~ \_~\_~\_~\_\cdots$"("$\_$"为还未构造的区域)



再构造第$s-2$个字符,不难发现,它有$K-2$种选择,设它为$B$,加入



此时的字符串为"$\cdots \_~\_ ~\_~ B~ A~w~ \_~\_~\_~\_\cdots$"



不难发现,第$s-3$到第一个字符都有$K-2$种选择,所以我们设构造$w$左边的字符串有$(K-1)\times (K-2)^{s-2}\bmod p$中方法



再来构造右边的字符串,同样我们从第$s+1$个字符开始构造,因为此时的字符不能为$w$,也不能为$A$,所以只有$K-2$种选择,设它为$C$,加入



此时的字符串为"$\cdots J~H ~G~ B~A~w~ C~\_~\_~\_\cdots$"



不难发现,从第$s+2$到第$n$个字符串都只有$K-2$种选择.



所以我们设构造$w$右边的字符串有$(K-2)^{L-s}\bmod p$种方法



**所以最后答案为$(K-1)\times (K-2)^{L-2} \bmod p$**



可以验证,当我们的假设"字符$w$在其中间的位置"不成立,答案也是正确的



注意这一题由于$N≤10^{18},p≤10^9$,$p^3$即爆$\operatorname{long~ long}$,所以务必做到**每一次乘法膜一次**,每一个种答案输出时也膜一次,$K$一开始最好直接膜一次



###### $[1]$:"膜"同"模".



###### $[2]$:自己模拟一下就知道了.



代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll unsigned long long
ll n,k,p,s,w;//n表示题目中的L
ll qpow(ll x,ll y,ll z)//(x^{y})%z,快速幂
{
	ll s=1;
	x%=z;
    while(y>0)
    {
      if(y%2) s=s*x%z;
      x=x*x%z;
      y>>=1;
    }
    return s%z; 
}
int main()
{
	cin>>k>>n>>p>>s>>w;
	k%=p;
	if(n==1) return s? printf("%lld",1%p),0:printf("%lld",k%p),0;
	ll ans=(k-1)%p;
	if(!s) ans=(ans*k)%p;
	ans=(ans*qpow(k-2,n-2,p))%p;
	return printf("%lld",ans),0;
}
```
