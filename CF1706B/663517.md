### 题意

给定 $n$ 个方块，每个方块有一个颜色 $c_i$，第一个方块在原点，第 $i$ 个方块可放置在第 $i-1$ 个方块的左面、右面或者上面。对于每个颜色输出能建成的最高的塔（塔指一列上连续的同一颜色方块，高度即为数量）。

# 分析

首先，对于一串连续的同一颜色，自然是一直往上垒，越垒越高，通过分析样例，我们还发现一个规律：两个同一颜色方块之间间隔的方块数量是 $2$ 的倍数时，这两个方块可垒到一起。

这怎么解释呢？如果间隔 $0$ 个方块，显然成立；间隔两个方块时，我们可以在当前的基础上，在右面放一个，再在右面的上面放一个，再在右面的上面的左面放一个——这就相当于在原方块上面放了一个。依次类推，对于更大的 $2$ 的倍数，我们也可以采用这种向右垒的方法，所以这个规律是正确的。

在具体的程序实现中，因为最后输出顺序是按颜色编号，所以需要用 $ans$ 数组记录大小。我们只需要统计出一个 $last$ 数组来存该颜色上一次出现的位置，为 $0$ 说明没出现过，直接让 $ans_i$ 加 $1$ 即可，否则判断是否符合上述规律，符合就让 $ans_i$ 加 $1$。

另外，由于 $ans_i$ 能否加 $1$ 只与 $c_i$ 上一次出现的位置有关系，所以我们对于 $c$ 数组也不必开了，直接读入 $c$ 即可，节省空间（~~然鹅对于 250 MB 的空间限制来说节省 0.76 MB 并没有任何卵用~~）。

#### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
int t, n, c, ans[200010], last[200010];
signed main(){
	ios::sync_with_stdio(false);//关闭与 stdio 的同步来提速
	cin >> t;
	while (t--) {
		memset(ans, 0, sizeof(ans));
		memset(last, 0, sizeof(last));//每次注意初始化 ans 和 last
		cin >> n;
		for (int i = 1; i <= n; i++) {
			cin >> c;
			if (!last[c] || (i - last[c] - 1) % 2 == 0)//可以往上垒
				ans[c]++;
			last[c] = i;//记录位置
		}
		for (int i = 1; i <= n; i++)
			cout << ans[i] << ' ';
		cout << "\n";
	}
	return 0;
}

```

