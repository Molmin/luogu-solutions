## 题意
给你 $n$ 个节点，每个节点有一个颜色 $c_i$，现在把一号节点放在原点位置，后一个点必须放在前一个点的左边、右边或上面，选择一个有节点的位置 $(x,y)$，在该点一直向上走，一直走到顶上的点 $(x,y+s-1)$，则定义该点“塔”的高度为 $s$。当一个塔仅由一种颜色的节点组成时，则称其为一个“单色塔”。

现在你可以按照规则任意排放这些点，求对于一种颜色，其“单色塔”的最高高度是多少？

## 思路
### 性质
考虑一个点可以放在前一个同色点上的充要条件。

可以是“上”的操作叠在其上方；

也可以是“右上左”的操作；

也可以是“右右上左左”的操作；

$\dots$

总之，可以先经过 $k$ 步向右，再向上，再经过 $k$ 步向左将其放置在前一个节点上方。

此时，由于经过了 $2\times k+1$ 步，二者的下标之差一定为奇数。

### 做法
先离线下来操作，开一个 $ans$ 数组代表每一个颜色的答案，用 $las$ 数组记录上一个该颜色的位置，那么每次读入 $c_i$ 时，只需和上一个该颜色的位置作差即可。若差为奇数，更新答案。

## 代码
```cpp
#include<bits/stdc++.h>
#define rep(i, a, b) for (int i = (a); i <= (b); ++i)
#define nrep(i, a, b) for (int i = (a); i >= (b); --i)
using namespace std;
int t,n,c,ans[100005],las[100005]; 
int main(){
  std::ios::sync_with_stdio(0);
  cin>>t;
  rep(kk,1,t){
    memset(ans,0,sizeof(ans));
    memset(las,0,sizeof(las));
    cin>>n;
    rep(i,1,n){
      cin>>c;
      if(las[c]==0 || (i-las[c])%2==1){
        ans[c]++;
        las[c]=i;
      }
    }
    rep(i,1,n)cout<<ans[i]<<" ";
    cout<<"\n";
  }
  return 0;
}
```