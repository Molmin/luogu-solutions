# C++搜索与回溯 --深搜 DFS
### 思想：搜索 >> 标记>> AC
## 重点和难点！
## -->
#### 1.；一共上下左右4种走法，可以用数组来完成
#### 2.判断条件要弄清楚；
#### 3.障碍物处理；
#### 4.开始点要标走过；
#### 5.2维数组行列变量弄清楚.
## 针对问题
### 一. 一共上下左右4种走法，可以用数组来完成.
上下左右4种走法，确实不太好弄，

要**仔细观察**才能发现.

若所在点为**a[n][m]**



|  | **n,m-1** |  |
| -----------: | -----------: | -----------: |
| **n-1,m** | **n , m** | **n+1,m** |
|  | **n,m+1** |  |

（1）上：a[n][m-1]
（2）下：a[n][m+1]
（3）左：a[n-1][m]
（4）右：a[n+1][m]
### 所以 代码如下
### -->
```
int dx[4]={0,0,1,-1};//打表
int dy[4]={-1,1,0,0};//打表
```
### 二. 判断条件要弄清楚

一共**6**个**条件**

（1）是否**超界**；
（2）是否为**障碍物**或**走过**

### 所以 代码如下
### -->
```
if(nx>=1&&nx<=n&&ny>=1&&ny<=m&&zhang[nx][ny]==0&&use[nx][ny]==0)
{
	use[nx][ny]=1;//标记
	dfs(nx,ny);
	use[nx][ny]=0;//清标记或回溯
}
```
### 三. 障碍物处理
直接定义bool双重变量   
**0**为不是障碍物  
**1** 为是障碍物
### 所以 代码如下
### -->
```
for(int i=1;i<=t;i++)
{
	int x,y;//障碍物坐标
	cin>>x>>y;
	zhang[x][y]=1;//标记
}
```
### 四. 开始点要标走过
在DFS中我没算起点的重复，所以我在主函数之中给他算了重复；
### 所以 代码如下
### -->
```
use[sx][sy]=1;//起点算重复
```

## 【上AC代码】
```
#include<bits/stdc++.h>//万能头
using namespace std;
int n,m,t,sx,sy,fx,fy,sum;
bool zhang[10][10],use[10][10];//zhang为障碍物标记，ues为走过标记，俩数组可合二为一
int dx[4]={0,0,1,-1};//打表
int dy[4]={-1,1,0,0};//打表
void dfs (int x,int y)
{
	if(x==fx&&y==fy)
	{
		sum++;//可行方案+1
		return ;
	}
	for(int i=0;i<=3;i++)//数组下标为0，一共4个方向，所以0到3
	{
		int nx,ny;
		nx=x+dx[i];//nx=new x，新x
		ny=y+dy[i];//ny=new y，新y
		if(nx>=1&&nx<=n&&ny>=1&&ny<=m&&zhang[nx][ny]==0&&use[nx][ny]==0)//6个条件，不能过范围，不为障碍物和不能走过
		{
			use[nx][ny]=1;//标记
			dfs(nx,ny);
			use[nx][ny]=0;//清标记
		}
	}
}
//深搜
int main()
{
	cin>>n>>m>>t;
	cin>>sx>>sy>>fx>>fy;//输入起点和终点
	for(int i=1;i<=t;i++)
	{
		int x,y;//障碍物坐标
		cin>>x>>y;
		zhang[x][y]=1;//标记
	}
	use[sx][sy]=1;//起点算重复
	dfs(sx,sy);
	cout<<sum;
	return 0;
}
```
## 吾为蒟蒻
# 如有优化建议可在讨论区发表




