分析题目，很明显在奶牛入住时分为两种情况：  
1. 它最喜爱的房间还未被入住。
2. 它最喜爱的房间已经被入住了。

对于第一种情况，只需要将房间入住即可；  
对于第二种情况，则需往后寻找，直到发现了一个空的房间为止 。 
很明显，将他后面的每一个房间都寻找过去十分浪费时间，因此可以设置两个数组 $p$  和 $q$，$p[i]$ 表示从 $i$ 号房间往**后**能够找到第一个空的房间,$q[i]$ 表示从 $i$ 号房间往**前**能够找到第一个空的房间（均不包括它本身）。在每一只奶牛入住房间时，将此房间的上一个空房间的下一空房间设置为此房间的下一个空房间,同时将此房间的下一个空房间的上一空房间设置为此房间的上一个空房间  
话说起来太乱，看张图就明白了：

![牛的选房间情况](https://cdn.luogu.com.cn/upload/image_hosting/s3s0mzf5.png?x-oss-process=image/resize,m_lfit,h_170,w_225)  
绿线表示数组 $p$ 与 $q$ 原先的指向情况，蓝线表示牛入住一个房间后的指向情况  
这样一来，我们就能节省很多的时间  
具体实现，请看参考代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,k;
long long x,y,a,b;//注意数据范围，a*y是有可能爆int的
int room[3333333];
int p[3333333];
int q[3333333];
int main()
{
	scanf("%d%d",&n,&k);
	for(int i=0;i<n-1;i++)p[i]=i+1;
	p[n-1]=0;//因为是环形的，所以最后一个房间最开始要指向第一个房间
	for(int i=n-1;i>0;i--)q[i]=i-1;
	q[0]=n-1;//同上
	for(int i=1;i<=k;i++)
	{
		scanf("%lld%lld%lld%lld",&x,&y,&a,&b);
		for(int j=1;j<=y;j++)
		{
			for(int l=1;l<=x;l++)
			{
				int t=(j*a+b)%n;//不要忘记取模
				while(room[t])//寻找下一个空房间
				{
					t=p[t];
				}
				room[t]=1;//住进这个房间
				p[q[t]]=p[t];
				q[p[t]]=q[t];//前后重新标记
			}
		}
	}
	for(int i=0;i<n;i++)
	{
		if(!room[i])//寻找第一个空的房间
		{
			cout<<i;
			return 0;
		}
	}
	return 0;
}
```


### 本篇题解到这里就结束了，欢迎大家在评论区提出意见！