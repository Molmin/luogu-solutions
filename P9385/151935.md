大概出题人是对着 idea 出的题，所以正着想很难。

类似强连通分量耳分解的思想。我们每次钦定从编号最小、并且没定出边的点开始（有白点则为最小的白点，否则为最小的黑点，这里钦定了标号所以不用乘系数），一路确定出边，并最终到达一个定过出边的点（新加了一条链）或形成新的连通块（新加了一个 $ρ$ 型，一条杆一个环）。

设 $f_{i,j}$ 表示已经扩展了若干轮，用了 $i$ 个白点和 $j$ 个黑点。

类似 dp 分步转移的思想，每次从当前状态新加一个点作为转移，或者结束这一轮加点（转移到 $f$）。

设 $g_{i,j,0/1,0/1}$ 表示正在加一条链，记录钦定链末尾的颜色以及当前点的颜色。

设 $h_{i,j,0/1}$ 表示正在加一个 $ρ$ 型的杆，记录当前点颜色。

设 $l_{i,j,0/1,0/1,0/1,0/1}$ 表示正在加一个 $ρ$ 型的环，记录环末尾的颜色，当前点颜色，环上的白点个数奇偶性，环上的黑点个数奇偶性。

然后讨论一下转移就好了，就是枚举下一个加的点的颜色，从 $g$ 转移到 $g/f$，从 $h$ 转移到 $h/l$，从 $l$ 转移到 $l/f$，从 $f$ 转移到 $g/h$。具体转移可以见代码。

时间复杂度 $O(nm)$。

```cpp
#define N 2005
#define inf 0x3f3f3f3f

int n,m;
modint f[N][N],g[N][N][2][2],h[N][N][2],l[N][N][2][2][2][2];

signed main()
{
	n=read(),m=read(),mod=read();
	f[0][0]=1;
	// g(i,j,结束col,当前col)
	// h(i,j,当前col)
	// l(i,j,结束col,当前col,white sum,black sum)
	For(i,0,n)
		For(j,0,m){
			
			For(x,0,1)For(y,0,1){
				if(!(x&&y)) f[i][j]+=g[i][j][x][y];
				For(z,0,1)
					if(!(y&&z)) g[i+(!z)][j+z][x][z]+=g[i][j][x][y]*(z?(m-j):(n-i));
			}
			For(y,0,1){
				if(!h[i][j][y].x)continue;
				For(z,0,1)
					if(!(y&&z)) h[i+(!z)][j+z][z]+=h[i][j][y]*(z?(m-j):(n-i));
				l[i][j][y][y][!y][y]+=h[i][j][y];
			}
			For(a,0,1)For(b,0,1)For(c,0,1)For(d,0,1){
				if(!l[i][j][a][b][c][d].x)continue;
				if((!(a&&b)) && (!(c&&d))) f[i][j]+=l[i][j][a][b][c][d];
				For(z,0,1)
					if(!(b&&z)) l[i+(!z)][j+z][a][z][c^(!z)][d^z]+=l[i][j][a][b][c][d]*(z?(m-j):(n-i));
			}
			if(i!=n){
				g[i+1][j][0][0]+=f[i][j]*i;
				g[i+1][j][1][0]+=f[i][j]*j;
				h[i+1][j][0]+=f[i][j]; 
			}else{
				g[i][j+1][0][1]+=f[i][j]*i;
				g[i][j+1][1][1]+=f[i][j]*j;
				h[i][j+1][1]+=f[i][j];
			}
		}
	modint res=f[n][m];
	cout<<res.x;
	return 0;
}
```