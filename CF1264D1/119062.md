深度即合法括号匹配子序列中左括号的数目的最大值。

考虑如何计算一个序列的深度。

容易发现，是每次找最左的 $($ 和最右 $)$ 贪心地匹配。

证明我再想想？感觉挺好猜的。

感性理解一下，就是说最左边不和最右边匹配的话，可能导致最右边匹配不上其他的左括号，而且区间大小更小，更难搞到更多匹配。。。比如 $(())$。感觉挺玄乎的。官方题解也没有理性的证明。

---

这样引导一种区间dp的做法。 设 $f_{l,r}$ 表示答案。

- $s_l = ) \ or\  ? $ 或者 $s_r=( \ or \ ?$，那么就是有机会 $l$ 或者 $r$ 对答案没有贡献。

然后注意都满足的时候需要去掉 $f_{l+1,r-1}$。因为多算了一次。

- $s_l = (\ or \ ?$ 且 $s_r = ) \ or \ ?$

如果左端点匹配 $[l+1,r-1]$ 的 $)$，那么违反了贪心策略。

因为时刻取的是最左或者最右的匹配掉。

考虑这样一个匹配，对 $[l+1,r-1]$ 中所有的情况都 $+1$。这个数目是 $2^{t}$，$t$ 是区间 $[l+1,r-1]$ 的 $?$ 数目，这表示每个 $?$ 两种取值。

时间复杂度 $\mathcal{O(n^2)}$。

```cpp
signed main() { 
	cin >> s; n = s.length(); s = ' ' + s;
	for(int i=1;i<=n;++i) p[i] = p[i-1] + (s[i] == '?');
	for(int l=2;l<=n;++l) {
		for(int i=1,j=l;j<=n;++i,++j) {
			if(s[i] != '(') inc(f[i][j], f[i+1][j]);
			if(s[j] != ')') inc(f[i][j], f[i][j-1]);
			if(s[i] != '(' && s[j] != ')') inc(f[i][j], P - f[i+1][j-1]);
			if(s[i] != ')' && s[j] != '(') {
				int v = p[j-1]-p[i];
				inc(f[i][j], f[i+1][j-1]);
				inc(f[i][j], qpow(2, v));
			}
		}
	}
	printf("%d\n", f[1][n]);
	return 0;
}
```