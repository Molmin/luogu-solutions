### 分析：

#### 不难发现，对于一个结点k，其左结点、右结点的编号分别是2k和2k+1。

这个结点论非常重要

这样，不难模拟出c++程序：

```c
#include<cstdio>
#include<cstring>

const int maxd = 20;

int s[1<<maxd];                          //最大结点个数为2^maxd-1 
int main()
{
	int D, I;
	while(scanf("%d%d",&D, &I) == 2)
	{
		memset(s, 0, sizeof(s));        //开关 
		int k, n = (1<<D)-1;            //n是最大结点编号（注意，要加括号，优先级！！！）
		for(int i = 0; i < I; ++i)      //连续让I个小球掉落 
		{
			k = 1;
			for(;;)
			{
				s[k] = !s[k];
				k = s[k] ? k*2 : k*2+1; //根据开关状态选择下落方向 
				if(k > n) break;        //已经落“出界”了
			}
		} 
		printf("%d\n", k/2);            //“出界”之前的叶子编号 
	}
	return 0;
}
 
```


尽管在本题中，每个小球都是严格下落D-1层，但用“if(k>n) break;"的方法判断“出界”更具一般性，所以上面代码采用了这种办法。


### 缺点：运算量太大


每个小球都会落在根结点上，因此，两个小球必然一个是左子树，一个是右子树。
一般的，只要看小球的奇偶性，就能知道它是最终在哪棵子树中。


#### 对于那些落入根结点左子树的小球来说，只需知道他是第几个落入根的左子树里的，就可已知道他接下来往左还是往右了。依此类推，直到小球落道叶子上。


以上为个人分析，若有不是，大佬轻喷。
