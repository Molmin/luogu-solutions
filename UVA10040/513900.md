~~说真的这道题弄了好久才AC真是太不容易了%%%~~

#### 一.题意

这题大概意思就是说让你构造一个长度为 $2^n$ 的环，使每次以长度 $n$ 在环上截取都能恰好得到 $0$ 到 $2^n-1$ 之间的数各一次，要你输出在环上截取的第 $k$ 个数的值。

#### 二.前置知识

有向图的欧拉回路，不会请自行移步 [欧拉回路](https://www.luogu.com.cn/problem/P7771)。

#### 三.题解部分

首先考虑构图，以 $n=3$ 为例，构造 $00,01,10,11$ 四个节点。

$00$ 左移后舍去最高位末尾加上 $0$ 可得 $00$ ，于是连一条 $00→00$ 的边。

$00$ 左移后舍去最高位末尾加上 $1$ 可得 $01$ ，于是连一条 $00→01$ 的边。

$01$ 左移后舍去最高位末尾加上 $0$ 可得 $10$ ，于是连一条 $01→10$ 的边。

$01$ 左移后舍去最高位末尾加上 $1$ 可得 $11$ ，于是连一条 $01→11$ 的边。

$10$ 左移后舍去最高位末尾加上 $0$ 可得 $00$ ，于是连一条 $10→00$ 的边。

$10$ 左移后舍去最高位末尾加上 $1$ 可得 $01$ ，于是连一条 $10→01$ 的边。

$11$ 左移后舍去最高位末尾加上 $0$ 可得 $10$ ，于是连一条 $11→10$ 的边。

$11$ 左移后舍去最高位末尾加上 $1$ 可得 $11$ ，于是连一条 $11→11$ 的边。

构图就完成了，不难发现对于每个点都有两条出边，两条入边，显然是一个欧拉图。

于是就可以愉快地跑欧拉回路了，同时用栈记录路径上经过的点就可以构造出题目要求的环，注意是环！！！所以统计答案时要破环为链（我就是在这里挂了）。

#### 四.代码
```cpp
#include<bits/stdc++.h>
using namespace std;
 
const int MAXN=3e6+5;
bool num[MAXN*2],path[MAXN][2];
int s[MAXN],anss[MAXN];
int n,m,k,cnt;
void init()
{
    m=1<<(n-1);
    memset(path,0,sizeof(path));
    int top=0,t=0;
    s[++top]=m-1;
    cnt=0;
    while(top)
    {
        int x=s[top];
        int y,i;
        for(i=0;i<=1;i++)
        {
            y=(x<<1)&(m-1)|i;
            if(!path[x][i]) break;
        }
        if(i<=1)
        {
            s[++top]=y;
            path[x][i]=1;
        }
        else
        {
            anss[++t]=s[top];
            --top;
        }
    }
    --t;
    while(t)
    {
        int x=anss[t--];
        num[++cnt]=x&1;
    }
    for(int i=1;i<=cnt;++i) num[i+cnt]=num[i];
}
int main()
{
    int T;
    cin>>T;
    while(T--)
    {
        scanf("%d %d",&n,&k);
        init();
        int ans=0;
        for(int i=k+1;i<=k+n;++i)
        {
            int now=(i>cnt)?i-cnt:i;
            ans=(ans<<1)+num[i];
        }
        printf("%d\n",ans);
    }
    return 0;
}
```
