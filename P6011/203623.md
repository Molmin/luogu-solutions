这道题恶心的是删除后的移位操作。

不过可以把求区间最值的 $l,r$ 转移为线段树上的虚拟节点。就是说，先弄一个线段树维护区间最值，然后删除的时候只是用一个数据结构维护，在查询的时候利用数据结构把 $[l,r]$ 映射到线段树的 $[l',r']$ 上。

转移也很简单。

写一个平衡树维护数组下标。在删除的时候删除 $rank(k)$（平衡树中排名第 $k$ 的下标）。注意删除的时候要在线段树中剔除 $a_{rank(k)}$ 的影响。然后区间 $[l,r]$ 就是线段树中的 $[rank(l),rank(r)]$。

~~这还不如写一个文艺平衡树呢~~

这个平衡树比较特殊，你把它建出来后就会发现，如果用权值线段树实现这棵平衡树，和维护区间最值的线段树的样子完全一样。

然后就可以顺便用维护区间最值的线段树来维护一下权值线段树。

不过用权值树状数组可能会常数小一些。

下面是部分代码：

```cpp
	if(opt==1) 
		{
			madd(*f.find_by_order(l-1));//更新线段树
			f.erase(f.find_by_order(l-1));//删除下标
		}
		else
		{
			scanf("%d",&r);
			l=*f.find_by_order(l-1),r=*f.find_by_order(r-1);//映射
			printf("%d %d\n",min(1,l,r),max(1,l,r));//线段树求最值
		}
```

我没有用权值线段树写，而是用了 pb_ds。因为既然用另外的平衡树可以维护，权值线段树应该也可以。