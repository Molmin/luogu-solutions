## Solution

首先很容易发现 $n=1$ 或者 $n=m$ 那么一定没有合法答案，然后考虑如何构造答案。根据第二个限制我们很容易想到从原字符串中插入一些字符来满足第一个和第三个限制，而第一个限制很容易满足，关键是如何满足第三个限制。

我的方法是这样的：找原序列中是否有两个相同的字符相邻。比如如果一个字符串是 $0101101$ ，中间有 $2$ 个 $1$ 相邻，那么这个时候我们就往这两个相同的字符中插入 $m-n$ 个与它们不同的字符，比如这个例子就可以往 $2$ 个 $1$ 当中插入 $m-n$ 个 $0$ ，这样的答案一定是合法的，下面可以简单证明一下：

首先前两个限制显然满足，考虑是否满足第三个限制。注意到我们将原序列中的一对相同且相邻的字符拆开了，而在我们构造出来的字符串中已经不可能再找出一段子串使得相邻的字符对数与原字符串相同了，也就是不可能存在与原字符串相同的子串，这样就可以满足第三个限制。

那么如果给出的序列是 $01010101$ 这样的字符串呢？这样就更简单了，我们直接在第一个字符后面插入 $n-m$ 个第二个字符就好了，这也可以证明：如果要想保证子串长度与原字符串相同，那么就必然要选出一对相邻且相同的字符，但原串并没有一对相邻且相等的字符，所以不可能与原串相等。

但是好像落了点什么，如果说给出的字符串是 $01$ 或 $10$ ，那么好像也没有合法答案。原因很简单，不管在这两个字符中间插入什么，都会得到一个子串与原字符串相等，这样一直推下去就可以证明没有合法答案。所以还要特判掉这种情况不合法。

然后就没了。时间复杂度 $O(n+m)$

## Code
```c++
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int N=2e6+5;
int T,n,m;
char s1[N];
int main()
{
	scanf("%d",&T);
	while(T--){
		bool flg=0;
		scanf("%d%d",&n,&m);
		scanf("%s",s1+1);
		if(n==1||n==m){
			printf("-1\n");
			continue;
		}
		for(int i=1;i<n;i++){
			if(s1[i]==s1[i+1]){
				for(int j=1;j<=i;j++){
					cout<<s1[j];
				}
				for(int j=1;j<=m-n;j++){
					if(s1[i]-'0'==1) cout<<"0";
					else cout<<"1";
				}
				for(int j=i+1;j<=n;j++){
					cout<<s1[j];
				}
				cout<<"\n";
				flg=1;
				break;
			}
		}
		if(!flg){
			if(n==2){
				printf("-1\n");
				continue;
			}
			cout<<s1[1];
			for(int i=1;i<=m-n;i++){
				cout<<s1[2];
			}
			for(int i=2;i<=n;i++){
				cout<<s1[i];
			}
			cout<<"\n";
		}
	}
	return 0;
}
```