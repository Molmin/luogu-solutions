分三类讨论。

一个小技巧：$\tt '0'\oplus 1='1','1'\oplus 1='0'$。

#### 无解
- 当 $n=m$ 时，无法插入字符，$B$ 串一定与 $A$ 串相同，无解；
- 当 $n=1$ 时，由于 $B$ 串是 $\tt 01$ 串，不可避免地出现 $\tt 0$ 和 $\tt 1$，无解；
- 当 $A=\tt "01"$ 时，在保证第三条要求的基础上，不可能找不到两个相邻且不相同的字符，无解；
- 当 $A=\tt "10"$ 时，与 $A=\tt "01"$ 类似，无解。

#### $A$ 中有两个相邻且相同的字符
那我们可以把 $A$ 串从这两个相邻的字符的中间断开，并用 $m-n$ 个与这两个字符不同的字符把它们再连起来。

举个例子，$A=\tt "0101110"$，这时我们把 $A$ 断开成 $\tt "0101$ 和 $\tt "110"$，并用 $m-n$ 个 $\tt '0'$ 把它们连起来，最终效果是 $\tt"0101000...000110"$。

#### $A$ 中没有两个相邻且相同的字符
那么 $A$ 应该是类似于 $\tt "01010101..."$ 这一种字符串，我们可以在首位后面插入 $m-n$ 个与首位不相同的字符。

举个例子，$A=\tt "0101010"$，这时我们在首位后面插入 $m-n$ 个 $\tt '1'$，最终效果是 $\tt "0111...1111010101"$。

代码：
```cpp
int n,m;
char a[100010];
int mian(){
    cin>>n>>m>>a;
    bool flag=0;//有没有两个相邻且相同的字符
    int pos=0;//如果有，那它们在哪里，如果没有，那就从 a[0] 后面插入
    for(int i=0;i<n-1;i++){//暴力扫一遍，可以确定复杂度是对的
        if(a[i]==a[i+1]){
            flag=1;
            pos=i;
            break;
        }
    }
    if(n==m||n==1||(n==2&&a[0]^a[1])){
        cout<<"-1"<<endl;
        return 0;
    }
    a[pos+1]='\0';
    cout<<a;//C 字符串特性，以 '\0' 结尾，那就把末尾改成 '\0' 输出
    a[pos+1]=a[pos]^flag^1;//记得还原
    for(int i=1;i<=m-n;i++) cout<<(char)(a[pos]^1);
    cout<<a+pos+1<<endl;
    return 0;
}
```