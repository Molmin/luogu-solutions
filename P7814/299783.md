#### 题意

给定一个长度为 $n$ 的序列 $A$，求构造长度为 $m$ 的序列 $B$，满足 $B$ 的**子串**不包含 $A$ 且 $B$ 的**子序列**包含 $A$。

#### 思路

由于 $B$ 的子序列包含 $A$ ，所以肯定要先构造一个 $A$ 串。

接下来我们要破坏 $A$ 的连续性。

我们才不管那么多东西，只要考虑最简单暴力的办法。

死命往一个地方插入一个相同的字符，直接把你断开。

那么问题来了，我要插什么？插哪里？

容易想到找到最早出现的两个相邻且相同的字符，往中间插入不同与它们的字符。

证明一下：

如果我们插入后，就分成了两段。

前面的部分是断开的，不可能匹配成功。

后面的部分由于取不到缺少的那个相同字符，也不可能匹配成功。

举个栗子：

$11011$

插入后（红色的 $0$ 是插入的）：

$1$ $\color{red}0$ $1011$

前面的 $1$ 和后面的串匹配不到，不可能匹配成功。

后面的 $1011$ 没有前面的 $1$ 做为前缀，也没法匹配成功。

那么如果没有两个相邻且相同的字符呢？

因为只有 $01$ 两个字符，所以 $A$ 只有 $101010...$ 或 $010101...$ 两种情况。

因此我们在第一个字符与第二个字符中间疯狂插入第二个字符就好了。

比如原串为：$10101$

插入后为：$1$ $\color{red}0$ $0101$

还是把原串分成两个部分，让它们都缺少所必须的字符。

最后考虑不可能的情况。

显然，如果 $n=m$ 或 $n=1$ 是没办法的，因为 $B$ 必定有子串等于 $A$。

还有一种情况是 $A$ 为 $10$ 或 $01$，因为如果想把 $A$ 分割开，中间无论插入什么都会匹配成功。

上代码：
```
#include<bits/stdc++.h>
const int N=2e6+7;
using namespace std;
int T,n,m;
int a[N];
int main() {
	scanf("%d",&T);
	while(T--) {
		int sum=0,chec=0;
		scanf("%d%d",&n,&m);
		string s;
		cin>>s;
		for(int i=0;i<n;i++) {
			a[i+1]=s[i]-'0';
			if(a[i+1]==a[i]&&i>0)
				sum++;
		}
		if(s=="01"||s=="10"||n==1||n==m) {
			puts("-1");
			continue;
		}
		if(!sum) {
			printf("%d",a[1]);
			for(int i=1;i<=m-n;i++)
				printf("%d",a[2]);
			for(int i=2;i<=n;i++)
				printf("%d",a[i]);
			printf("\n");
		}
		else {
			printf("%d",a[1]);
			for(int i=2;i<=n;i++) {
				if(a[i]==a[i-1]&&!chec) {
					chec=1;
					for(int j=1;j<=m-n;j++)
						printf("%d",a[i]^1);
				}
				printf("%d",a[i]);
			}
			printf("\n");
		}
	}
	return 0;
}
```
完结撒花~