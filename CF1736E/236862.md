容易发现最终贡献给答案的 $a_i$ 是不降的，且 $n$ 很小，我们直接设计一个非常暴力的状态： $f_{i,j,k}$ 表示做完第 $i$ 轮，第 $i$ 轮的贡献为 $a_j$，且我们在这轮结束后保留了 $k$ 次交换操作没有使用的最大答案。

（第三维的解释：这里我们并不是每一轮都关心其交换的位置，只需要在这个交换操作产生贡献的时候再计算）

转移：

- $f_{i,j,k} = f_{i-1,j,k}+a_j$

这个转移相当于此时 $a_{i-1}=j$，我们在这次操作交换了当前的 $a_{i-1}$ 与 $a_i$。

- $f_{i,j,k} = f_{i-1,t,k-1+j-i}+a_j (j\ge i,t<j)$

这个转移相当于此时将 $a_j$ 从第 $j$ 个位置一路换到第 $i$ 个位置，需要使用掉 $j-i$ 次操作。

直接暴力转移是 $O(n^4)$ 的，但注意到我们可以在做的时候就维护一下 $g_{i,j,k}$ 表示 $\max\{g_{i,t,k}\}(t\le j)$，这样转移的过程就不需要枚举 $t$ 了，时间复杂度即为 $O(n^3)$，可以通过此题。

初始化直接把 $i=1$ 的情况赋值一下就好。

[code](https://codeforces.com/contest/1736/submission/178636468)