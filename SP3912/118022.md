这题一看就知道是个贪心题，但怎么想都想不出怎么贪心，后来钻研挺长时间才懂。希望这篇题解可以帮到大家。  

## 神仙证明   
首先，证明一个结论。**如果这棵树中有最大权值点 x（非根），那么一旦 x 的父节点已经染色，就应该立刻染 x**。   
如果染色没有限制，那么显而易见，我们应该先染权值最大的节点，再染权值第二大的节点，以此类推。但因为有限制，所以我们应该   
假设权值最大的节点是b，它的父节点是a，那么当染色有限制时，如果a被染色了，我们应该立即给b染色。   
所以我们就找到了在染色顺序上相邻的两个点。 

 
然后我们再考虑这对点和其它点的关系，比如点 c，那么：  
方案一：如果先染 a,b，再染c，分值是 a+2b+3c；  
方案二：如果先染 c，再染a,b，分值是 c+2a+3b；  
我们计算一下两个分值的差： a+2b+3c - (c+2a+3b) = 2c-(a+b)  
如果方案一更优，那么 2c-(a+b) < 0，则 c < (a+b)/2  
**所以当且仅当 a,b 的平均值大于 c 时，我们应该先染 a,b，再染 c**。  
故我们在考虑剩余点的染色顺序时，**可以将 a,b 两个点当成一个点，其权值是 a,b 的均值**  
以此类推，我们就确定了本题的贪心原则  
 
最终做法是：每次找出当前权值最大的非根节点，将其染色顺序排在紧随父节点之后的位置，然后将该点合并进父节点中，更新父节点的权值。直到所有点都合并进根节点为止。       
关于ans的计算，我们可以保存顺序，最后按照顺序计算它的总代价。或者还有一种更简便的，我们可以在合并的过程中顺便将答案一起更新。      
因为我们是通过一次次合并确立正确染色顺序的，**每次合并就有父节点所包含的点在它之前染色**。就乘以父节点包含的节点个数，合并到最后整个树成了一个点，答案也就完成了 
 
~~好恶心的贪心 ~~

## 上代码(附有详细注释)
~~(个人觉得码风老少皆宜)~~
```cpp
#include <cstdio>
#include <cstring>
using namespace std;
#define db double
int r,n;
struct node
{
    int f;//他爸 
    int c;//记录合并为当前节点的节点权值和 
    int t;//记录当前这个节点是由几个节点合并成的
    db w;//当前点合并后的新权值，姑且称为"性价比"(算术平均值c/t)
}tr[1020];
int find()
{
    int ans;
    db maxn=0;
    for(int i=1;i<=n;++i)
        if(i^r && tr[i].w>maxn)//找出平均值最大的节点集合(不能选根节点) 
        {
            maxn=tr[i].w;
            ans=i;
        }
    return  ans;    
}
int nn,ans,a,b,fa;
int main()
{
    while(~scanf("%d %d",&n,&r))
    {
    	if(!n && !r)return 0;
    	ans=0;
	    for(int i=1;i<=n;++i)
	    {
	        scanf("%d",&tr[i].c);
	        tr[i].w=tr[i].c;//初始化"性价比" 
	        tr[i].f=0;
	        tr[i].t=1;//只有他一个人 
	        ans+=tr[i].c;//先把所有点的权值加起来，到后面再乘
	    }
	    for(int i=1;i<n;++i)
	    {
	        scanf("%d %d",&a,&b);
	        tr[b].f=a;//确认关系 
	    }
	    for(int i=1;i<n;++i)
	    {
	        nn=find();//找到当前不为根且性价比最高的节点 
	        tr[nn].w=0;//把当前节点的"性价比"调成最低，使其在将来的运算中不被考虑到，等价于将其删除 
	        fa=tr[nn].f;
	        ans+=tr[nn].c*tr[fa].t;//累加答案
	        for(int j=1;j<=n;++j)if(tr[j].f==nn)tr[j].f=fa;//将其儿子全部归到其父亲名下 
	        tr[fa].c+=tr[nn].c;//合并进父节点 
	        tr[fa].t+=tr[nn].t;//合并进父节点 
	        tr[fa].w=db(tr[fa].c)/tr[fa].t;//更新父亲性价比 
	    }
    	printf("%d\n",ans);
	}
    return 0;
}

```
