## 前言

学校的一套训练题出了 ABC260 的题目，觉着这道题比较有意思，自己也有一个时间复杂度比较低的解题思路，所以决心写篇题解。

## 题解

我们称一个序列若为“好序列”，则该序列为“合法的”，否则，该序列是“不合法的”。

考虑每一个 $(1,2,3,…,M)$ 的连续子序列都可以用一个数对 $(h,s)$ 表示，其中， $h$ 表示数对的起始位置， $s$ 表示数对的长度，即：数对 $(h,s)$ 表示的序列是 $(h,h+1,…,h+s-1)$ 。

容易得到：若数对 $(h,s)$ 表示的序列不合法，那么数对 $(h,s-1)$ 和数对 $(h+1,s-1)$ 表示的序列均不合法。

原因显而易见：若 $(h,h+1,…,h+s-1)$ 对于给出的数对 $(A_i,B_i)$ 不包含 $A_i$ , $B_i$ 中的任意一个，那么显然其子序列也不包含 $A_i$,$B_i$ 中的任意一个。

考虑维护数组 $a[1,2,…,M]$ ，含义为：对于所有以 $i$ 开头的子串，长度小于等于 $a[i]$ 的序列都不合法。

那么对于每一组 $(A_i,B_i)$ ，我们可以得到三个限制条件：

1. 对于所有以 $1$ 开头的子串，长度小于等于 $A_i-1$ 的序列都不合法。
1. 对于所有以 $A_i+1$ 开头的子串，长度小于等于 $B_i-A_i-1$ 的序列都不合法。
1. 对于所有以 $B_i+1$ 开头的子串，长度小于等于 $M-B_i-1$ 的序列都不合法。

即：数对 $(1,A_i-1)$ ， $(A_i+1,B_i-A_i-1)$ ， $(B_i+1,M-B_i-1)$ 所表示的序列以及其子序列都不合法。这个结论是显而易见的，因为以上提到的序列均不包含 $A_i$ 和 $B_i$ 中的任意一个。

对所有给出的数对 $(A_i,B_i)$ 执行以上操作，得到以下代码：

```cpp
for(i=1;i<=n;i++)
{
	scanf("%d%d",&ta,&tb);
	a[1]=max(a[1],ta-1);
	a[ta+1]=max(a[ta+1],tb-ta-1);
	a[tb+1]=max(a[tb+1],m-tb);
}
```

对于每一个限制条件 $a[i]$ ，又可以进行以下转移：

```cpp
for(i=1;i<=m;i++)
{
	a[i+1]=max(a[i+1],a[i]-1);
}
```

它的含义为：若数对 $(i,a[i])$ 表示的序列不合法，那么数对 $(i+1,a[i]-1)$ 表示的序列一定不合法。

接下来考虑答案的计算：对于长度为 $i$ 的序列，有：长度为 $i$ 的合法序列的个数等于长度为 $i$ 的序列的总个数减去长度为 $i$ 的不合法序列的个数。

长度为$i$的序列的总个数是容易统计的：其个数为 $M-i+1$ 。考虑对长度为$i$的不合法序列的个数进行计算。结合数组 $a$ 的定义容易得到：长度为$i$的不合法序列的个数等于数组 $a$ 中大于等于 $i$ 的数的个数。

因此考虑反向累加统计数组 $a$中有多少个数大于等于 $i$ ，得到以下代码：

```cpp
for(i=1;i<=m;i++)
{
	cnt[a[i]]++;
}
for(i=m;i>=1;i--)
{
	tot+=cnt[i];
	ans[i]=m-i+1-tot;
}
```

最终顺次输出数组 $ans$ 即可。

总时间复杂度是 $O(N)$ 。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int cnt[200010],a[200010],ans[200010];
int main()
{
	int i,j,n,m;
	int ta,tb,tot=0;
	scanf("%d%d",&n,&m);
	for(i=1;i<=n;i++)
	{
		scanf("%d%d",&ta,&tb);
		a[1]=max(a[1],ta-1);
		a[ta+1]=max(a[ta+1],tb-ta-1);
		a[tb+1]=max(a[tb+1],m-tb);
	}
	for(i=1;i<=m;i++)
	{
		a[i+1]=max(a[i+1],a[i]-1);
	}
	for(i=1;i<=m;i++)
	{
		cnt[a[i]]++;
	}
	for(i=m;i>=1;i--)
	{
		tot+=cnt[i];
		ans[i]=m-i+1-tot;
	}
	for(i=1;i<=m;i++)
	{
		printf("%d ",ans[i]);
	}
	return 0;
}
```
