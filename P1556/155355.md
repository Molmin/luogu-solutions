
题目描述

每天，John都要为了农场里N(1≤N≤10)头牛的健康和幸福四处奔波。

每头牛的位置可以描述为一个二维坐标，John从坐标原点(0,0)出发。为了使路径更有趣，John决定只沿着平行于坐标轴的方向行走，这样只能沿着东西南北方向运动。而且只有到达某头牛的坐标后John才会改变行走的方向（当然，如果有必要，John也会穿过某头牛的坐标而不改变行走的方向。）

如果John改变行走的方向，他会原地转90°或者180°。John的路径必须保证检查完所有牛后返回原点。

John可以穿过某头牛的坐标而不改变方向任意次，请计算出有多少条路径满足John能检查完N头牛，在每头牛的坐标处恰好改变一次方向。同一条路径从不同方向经过要计算两次。
输入输出格式
输入格式：

第一行，整数N。

第2行到第N+1行，第i+1行是两个用空格隔开的整数x和y，表示第i头牛的坐标（-1000 ≤x, y ≤1000）

输出格式：

一行个整数，表示路径的量如果没有满足要求则输出 0。

输入输出样例
输入样例#1： 

4
0 1
2 1
2 0
2 -5

输出样例#1： 

2

这其实是一道比较简单的dfs。
唯一的难点在于一个方向的问题，就是到达了一个点必须转弯。

具体做法就是只要dfs每一个奶牛的位置，因为只有四个方向，所以和当前位置在同一行或同一列的奶牛的位置还没有到过，且需要改变行走的方向就可以到达那一个奶牛的位置。

PS:每次做完还需判断到达（0,0）的位置是否需要改变方向，如果需要改变才算一条是路径。
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,sum,a[11],b[11];
bool f[11];
int pd(int t,int w,int x,int y)  //判断行进方向
{
	if(t==x)
	{
		if(w<y)return 1;else return 2; 
	}
	if(w==y)
	{
		if(t<x)return 3;else return 4;
	}
}
void sc(int t,int w,int fx,int h)
//当前位置t,w，方向fx，和将要到达了第h个奶牛
{
	if(h>n)  
	{
		if(((t==0)||(w==0))&&(pd(t,w,0,0))!=fx)sum++;
        //在0行或0列，且要改变方向
		return;
	}
	for(int i=1;i<=n;i++)
	if((f[i]==false)&&          //没有做过
      ((t==a[i])||(w==b[i]))&&  //在同行或同列
      (pd(t,w,a[i],b[i])!=fx))  //需要改变方向
	{
		f[i]=true;
		sc(a[i],b[i],pd(t,w,a[i],b[i]),h+1);
		f[i]=false;
	}
}
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
	cin>>a[i]>>b[i];
	sc(0,0,0,1);
	printf("%d",sum);
	return 0;
}
```
