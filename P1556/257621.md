**一道（不）普通的dfs……**


------------
### STEP 1 审题

1.起点为（ 0 ，0 ），终点为 （ 0 ，0）；

2.两次行走不能来自同一个方向；

3.求~~抓完~~所有奶牛的总方案数；

ps：n<=10；



------------
### STEP 2 思路

看到数据范围，~~嘻嘻~~深搜+剪枝妥妥没问题~

深搜，不撞南墙不回头，直到搜到合理的答案才将总方案数+1后返回。


------------
### STEP 3 剪枝
~~其实这道题也不用怎么剪~~

1.走过的点不能走（这好像不算剪枝~

2.如方向一样就进行下一个点

3.没有任何一个坐标一样就返回


------------
### STEP 4 90分代码及注释（没错，拒绝ctrl+c）
```
#include<bits/stdc++.h>//万能头文件
using namespace std;
int n,cx[11],cy[11],v[11],ans;
//分别记录总数，每个点的坐标，判断是否走过以及答案数
void dfs(int x,int y,int g,int f){//分别表示该点的x,y坐标，层数以及过来的方向
	if (g==n){//如果每个点都处理完了
		int w;//记录如果向终点走的方向
		if (cx[x]==0){
			if (0>cy[y]) w=4;
			else w=3;
		}else{
			if (0>cx[x]) w=2;
			else w=1;
		}
		if (w==f) return;//相同就返回
		ans++;
		return;
	}
	for (int i=1;i<=n;i++){
		if (!v[i]){//没有走过
			if (g==n-1&&cx[i]!=0&&cy[i]!=0) return;//如果是最后一个点并且x,y坐标都不是0就返回
			int w;
			if (cx[i]==x){
				if (cy[i]>y) w=4;
				else w=3; 
			}else if (cy[i]==y){
				if (cx[i]>x) w=2;
				else w=1;
			}else continue;//如上记录方向
			if (w==f) continue;
			v[i]=1;//标记
			dfs(cx[i],cy[i],g+1,w);//搜
			v[i]=0;//回阙
		}
	}
}
int main(){
    scanf("%d",&n);
    for (int i=1;i<=n;i++) scanf("%d %d",&cx[i],&cy[i]);//输入
    dfs(0,0,0,0);//搜索
    printf("%d\n",ans);//输出
    return 0;//好习惯++
}
```


------------
### STEP 5 完结撒花！
90分代码只要稍微改一下就可以AC了哦！

思路上，如果还有不懂的地方可以在评论区问我，我会第一时间解答哒！

如果都明白了，就点个赞纪念一下你的成长吧！