前面的 dalao 都用的是字符串，~~可惜蒟蒻的我怎么调都调不对~~，于是只好用位运算了。

**题目分析**

关于 IP 地址、网络掩码等的描述，前面的 dalao 已经说的很好了。简单说一下：IP 地址原本是一串二进制数，每八位分割一下，分别转换为十进制，用点号隔开，就得到了常见的类似于 `194.85.160.177` 之类的地址。将所有 IP 地址的 32 位二进制表示从前往后比较，找出一模一样的位数（设为 $x$），网络掩码就是前面 $x$ 个 $1$，后面用 $0$ 补全 32 位所得到的二进制数，用刚才的方法转换成十进制表示的结果。最小网段就是在所有 IP 地址中随便找一个，和网络掩码进行按位与运算得到的结果。输入十进制 IP 地址，求最小网段和网络掩码。

代码方面，位运算可能篇幅有点长，但还是很好理解的。只是有一点，存储地址的时候，要用**无符号整数**。如果用有符号整数，位移运算时补的数会根据符号位来，输出将会十分奇特（害得我调了两个小时）：

```cpp
#include<cstdio>
using namespace std;
int n,a,b,c,d;
unsigned p[10005],q,s;
//p数组存储 IP 地址，q 存储掩码，s 存储最小网段。
unsigned calc() {
    unsigned ans = 0;
    for(int i = 1;i <= 32;i++) {
        bool bit = (p[1] >> (32 - i)) & 1;
        //这里的 bit 表示当前位的值，便于比较。右移后取最后一位，可以取中间某位。
        for(int j = 2;j <= n;j++) {
            if(((p[j] >> (32 - i)) & 1) != bit) return ans; 
            //比较，如果发现不等，就直接结束。
        }
        ans >>= 1;
        ans += 1 << 31;
        //在前面加一个 1
    }
    return ans; //如果全部相同，也要记得返回（坑）。
}
int main() {
    while(~scanf("%d",&n)) {
        for(int i = 1;i <= n;i++) {
            scanf("%d.%d.%d.%d",&a,&b,&c,&d);
            //scanf 直接这样，不用分割。
            p[i] = (((((a << 8) + b) << 8) + c) << 8) + d;
            //看起来有点奇特，事实上就是拼起来
        }
        q = calc(); //得到网络掩码
        s = q & p[1]; //得到最小网段
        printf("%u.%u.%u.%u\n",(s >> 24) % (1 << 8),
        (s >> 16) % (1 << 8),(s >> 8) % (1 << 8),s % (1 << 8));
        printf("%u.%u.%u.%u\n",(q >> 24) % (1 << 8),
        (q >> 16) % (1 << 8),(q >> 8) % (1 << 8),q % (1 << 8));
        //挺好理解，只是注意按无符号格式输出。
    }
    return 0;
}
```