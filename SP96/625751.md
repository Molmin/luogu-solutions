# **1.前言**
如果说这道题很难，其实也没有。用宽搜就可以了。但让也有人用最短路什么的。我没什么不用？~~我懒得用~~。我觉得没必要。
# **2.题目大意**
给你一个矩阵。对于每个格子，如果这个格子为字符 x，就不能走，S 为起点，D 为终点。如果这个格子为数字，则为走这个格子所需代价。问你从起点到终点做少要多少代价。
# **3.思路**
用两个一维数组记录每次走过的点的位置 $t$ 和 $w$ ，然后用队列思想进行宽搜，从起点开始，向上，下，左，右四个方向判断，如果可以到达，就是原来所需代价加上这个格子所需代价最小，就是可以到达。**注意，刚开始宽搜时，除起点外所有点初始值为0。** 最后，到达终点时要再次判断，因为终点的标志是字符 D。
# **4.程序（仅供参考）**
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,i,j,f[1100][1010],xx,dx[11000000]= {1,0,-1,0},dy[11000000]= {0,1,0,-1},yy,t1,w1,t2,w2,t,w,b[1100],c[1100];
char a[1100][1100];
int main() {
	scanf("%d%d",&m,&n);
	while (n!=0&&m!=0) {
		for (i=1; i<=n; i++){
			cin>>a[i];
			for (j=1; j<=m; j++) {
				if (a[i][j-1]=='S') t1=i,w1=j-1,a[i][j-1]='0';
				if (a[i][j-1]=='D') t2=i,w2=j-1,a[i][j-1]='0';
			}
		}
		t=w=1;
		b[w]=t1;
		c[w]=w1;
		memset(f,63,sizeof(f)); //除起点外所有格子定位最大。
		f[t1][w1]=0;
		while (t<=w) {
			for (i=0; i<4; i++) {
				xx=b[t]+dx[i];
				yy=c[t]+dy[i]; //判断上，下，左，右。
				if (a[xx][yy]!='X'&&a[xx][yy]!='S'&&xx>0&&yy>-1&&xx<=n&&yy<m)
					if (f[b[t]][c[t]]+a[b[t]][c[t]]-48<f[xx][yy]) {
						f[xx][yy]=f[b[t]][c[t]]+a[b[t]][c[t]]-48;
						w++;
						b[w]=xx;
						c[w]=yy;//记录可以到达的点。
					}
			}

			t++;
		}
		cout<<f[t2][w2]<<endl;
		scanf("%d%d",&m,&n);
	}

}
```
