套路题，但我确实没做起，因为套路掌握的不够熟练。

如果所有数字都为 $p$，设有 $t$ 个，则有 $p\times t=\sum a_i$，也就是说最后变出的数字是 $S=\sum a_i$ 的因数。

考虑计算最少的次数变成这个数字，首先有个最简单的策略是花费 $n-1$ 次变成 $S$，然后花费 $t-1$ 次分裂成 $p$。

考虑什么时候能少？如果把 $S$ 画成一个长段，初始在 $sum_i=\sum_{j=i}^ia_i$ 的位置分段，最后分段的位置为 $\forall k\in[1,t],kp$。

你按上述策略在分段的位置进行合并与分裂操作，如果你在同一个位置合并且分裂那么你可以直接去掉这两次操作。

显然发现能去掉的位置满足 $\exists k,p|sum_k$，考虑直接计算 $2\sum[sum_i\bmod p=0]$ 即可。

一般人都想到这一步了，然而接下来却是套路。

直接对 $S$ 质因数分解，对于每个数 $sum_i$ 只保留和 $S$ 的公因数，发现询问的就是一个质因子集合上的超集，直接对质因子上高维后缀和即可。

唯一的细节是 $S=1$ 时 Pollard-Rho 可能会挂掉，我乱写的 Pr 都跑的很快，代码就不放了。