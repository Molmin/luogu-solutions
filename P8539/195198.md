## 思路

观察有无性质。发现，如果一个数在某个位置没有成为最大值，那么它**再也不可能**成为最大值了，因为如果后面的 $b$ 比当前的 $a$ 大，由于 $v \geq 1$ 所以 $b+kv>a$。

显然如果让他成为 $k$ 次，一定是它首先成为从 $1$ 开始的最大值，并且比后面至少 $k-1$ 个数大。

首先考虑怎么让 $a_i$ 成为 $1\sim i$ 的最大值。我们可以维护一个 $pre$ 数组，$pre_i$ 表示到 $i$ 的最大值是多少。显然每次转移很显然，就是枚举之前的加 $v$，和当前的哪个大：$pre_i=\max(pre_{i-1}+v,a_i)$。那么我们在判断 $i$ 是否比之前的全部大的时候，直接看一下 $a_i$ 和 $pre_{i-1}+v$ 的关系即可。

然后考虑一下怎么让 $a_i$ 比后面 $k$ 数都大。对于 $i$ 位置的数，他在和 $i+j$ 这个数比较的时候，应该是 $a_i + j \times v$ 和 $a_{i+j}$ 在比较。也就是说我们要维护 $[a_{i+1}-v,a_{i+2}-2 \times v,\dots,a_{i+k-1}-(k-1)\times v]$ 这些的最大值，使得 $a_i$ 比这个最大值大。

考虑维护这个最大值。显然可以用差分的思想，线段树维护每个 $i$ 位置上，$a_i-i \times v$ 的值，每次找到 $[i+1,i+k-1]$ 的最大值，将它加上 $i \times v$，即可得到答案。由于最大值加的东西都是只和 $i$ 有关，所以可以放心维护。

但是注意到这并不是最终结果，因为 $b$ 数组依然有影响。所以我们考虑线段树同时维护最大值的位置。我们每次找最大值的时候，如果有多个相同的，那么就取 $a$ 最小的那个的位置。然后判断一下取出来的最大值和那个 $a$ 值的大小关系，如果比它小那么答案就加一。

复杂度 $O(n \log n)$。

## 代码

[Code](https://www.luogu.com.cn/paste/h609x83m)

其实感觉这道题离线下来我那个做法可以单调队列做，但是我比较懒所以没写。qwq