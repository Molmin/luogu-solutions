神奇的题目当然要用神奇的解法

一看k的取值范围，就知道肯定是找规律的题

先做了一个暴力，把1-10全部试一遍，发现只有1,2,4,8是合格的，似乎便是2的多次方，再将16,32,64试一遍，也都是合格的。于是我们可以得到这题的终极结论，答案就是2的k-1次方。

于是，快速幂算法隆重登场。

首先，快速幂的目的就是做到快速求幂，假设我们要求a^b,按照朴素算法就是把a连乘b次，这样一来时间复杂度是O(b)也即是O(n)级别，快速幂能做到O(logn)，快了好多好多。它的原理如下：

　　假设我们要求a^b，那么其实b是可以拆成二进制的，该二进制数第i位的权为2^(i-1)，例如当b==11时，a11=a(2^0+2^1+2^3)

　　11的二进制是1011，11 = 2³×1 + 2²×0 + 2¹×1 + 2º×1，因此，我们将a¹¹转化为算 a^(2^0)×a^(2^1)×a^(2^3)，也就是a^1×a^2×a^3，看出来快的多了吧

原来算11次，现在算三次，但是这三项貌似不好求的样子....不急，下面会有详细解释。 　　由于是二进制，很自然地想到用位运算这个强大的工具：&和>> &运算通常用于二进制取位操作，例如一个数 & 1 的结果就是取二进制的最末位。还可以判断奇偶x&1==0为偶，x&1==1为奇。 >>运算比较单纯,二进制去掉最后一位，不多说了，先放代码
```cpp
ll power(ll a,ll k){
    ll res=1;
    while(k){
        if(k&1)(res*=a)%=mod;
        k>>=1,(a*=a)%=mod;
    }
    return res;
}
```
代码很短，死记也可行，但最好还是理解一下吧，其实也很好理解，以k==11为例，k=>1011,二进制从右向左算，但乘出来的顺序是 a^(2^0)×a^(2^1)×a^(2^3)，是从左向右的。我们不断的让a*=a目的即是累乘，以便随时对ans做出贡献。

然后,附上AC代码（快速幂部分就写在主函数里了）
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
ll read(){
    ll a=0,b=getchar(),c=1;
    while(!isdigit(b))c=b=='-'?-1:1,b=getchar();
    while(isdigit(b))a=a*10+b-'0',b=getchar();
    return a*c;
}
ll k,sum=2,ans=1,mod=123456789;
int main(){
    k=read()-1;
    while(k){
        if(k&1)(ans*=sum)%=mod;
        k>>=1,(sum*=sum)%=mod;
    }
    printf("%lld",ans);
    return 0;
}
```
~~再做一个广告哈~~

~~(中国金坷垃运输专用车，缓缓驶来.....)~~

~~日、非:(两人互相挤着正面拦住货车)金坷垃!金坷垃!我们的!我们的!金坷垃!我们的!~~

~~(满载金坷垃的小货车被截住了...)~~

~~美:(走下车)你们想干什么?~~

~~日、非:金坷垃!金坷垃!我们的!我们的!~~

~~非:我要金坷垃!非洲农业不发达，必须要有金坷垃!~~

~~日:我要金坷垃!日本资源太缺乏，必须要有金坷垃!~~

~~日、非:金坷垃!……(日和非扭打 抢金坷垃)~~

~~非:妈妈的!金坷垃,是我的!(非打了日一拳，眼镜掉了)~~

~~美:(拉开两人)不能打架!不能打架!金坷垃好处都有啥? 谁说对了就给他!~~

~~非:(多次挥动手刀)肥料掺了金坷垃，不流失~不蒸发~零浪费!~~

~~日:(夺过金坷垃)肥料掺了金坷垃，能吸收两米下的氮磷钾!~~

~~非:世界肥料都涨价，肥料掺了金坷垃! 一袋能顶两袋撒!~~

~~日:用了金坷垃，小麦亩产一千八，日本的粮食再也不向美国进口啦! 哈哈哈哈哈!~~

~~美(心理台词):小鬼子，真不傻! 金坷垃给了他， 对美国农业威胁大， 绝不能给他!~~

~~美:非洲农业不发达 ，我们都要支援他。金坷垃，你们日本别~想~啦!~~

~~日:狡猾! 狡猾! 没有金坷垃，怎么种庄稼?金坷垃!金坷垃!(撕心裂肺地说)~~