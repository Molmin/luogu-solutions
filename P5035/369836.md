先算一下前几个

|    k     |   ans    |
| :------: | :------: |
|    1     |    1     |
|    2     |    2     |
|    3     |    4     |
|    3     |    8     |
|    4     |    16    |
| $\vdots$ | $\vdots$ |

答案应该就可以猜到了，是 $2^{k-1}$。

但是怎么证明呢？

---

设原来的数是 $x$，跳的深度为 $y$。

则 $y|x$，可设 $x=ay$。

此时 $x-y=ay-y=(a-1)y$ 是 $y$ 的倍数。

所以假设跳后的数是 $t$，这次跳的深度一定是 $t$ 的约数。

我们可以倒推。

最后结果是 $1$，所以最后一次跳的数只能是 $1$ 的约数，只能是 $1$。

所以在跳最后一次之前一定是 $2$，而且在跳到 $2$ 后还需要跳 $1$。

假设从前往后推 $t$ 次后结果是 $2^{t}$，且还需要跳 $2^{0}、2^{1}、\cdots、2^{t-1}$。

则推第 $t+1$ 次时。

$2^{t}$ 的所有约数仅剩下 $2^{t}$ 可选，所以只能由 $2^{t+1}$ 跳到，且还需要跳的数有  $2^{0}、2^{1}、\cdots、2^{t}$。



在 $t=1$ 时假设成立。

所以由数学归纳法可知所有数均为 $2$ 的自然数次幂，从小到大依次为 $2^{0}、2^{1}、2^{2}、\cdots$。

因此答案为 $2^{k-1}$。

这时我们只需要用上快速幂就可以 AC 这道题了。

---

简单的代码：

```c++
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int mod=123456789;
ll k;
ll ksm(int a,ll b) {
	if(b==0) return 1%mod;
	if(b&1) return 1ll*ksm(1ll*a*a%mod,b>>1)*a%mod;
	return ksm(1ll*a*a%mod,b>>1)%mod;
}
int main() {
	scanf("%lld",&k);
	printf("%d",ksm(2,k-1));
	return 0;
}
```