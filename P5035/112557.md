~~这题有提高+难度吗？~~

好了，我们来进入正题。

首先，我们看到这一道题，（哇！提高+难度！ 啪！这不重要QAQ）题面貌似挺正常的，看起来就是一个模拟，直到···

>对于100%的数据，k<=10^18

这怎么弄？这种数据连$O(n)$都过不了啊？

自然而然地，我们会想到这可能会是$O(log n)$或$O(1)$复杂度的(O(1)肯定不可能）

于是乎我们就只能求助于打表找规律，然后···

| k| ans
| :----------: | :----------: |
| 1| 1|
| 2| 2
| 3|4
| 4| 8|
| 5| 16
| 6| 32
| 7|64
| 8|128

我们可以发现以下规律：

$$ans=2^{k-1}$$

规律发现是发现了，但是我们如果用朴素的$O(n)$求乘方的方法，将会TLE，那么，我们就需要一种更快的计算乘方的算法——快速幂

## 快速幂

我们来观察一下一个乘方的式子：

$$a=b^k$$

我们可以把这个式子拆为

$$a=b*b*b*b*b*···*b$$

其中，这里有k个b。然后，我们把它再合起来

$$a=b^{ \frac{k}{2}}*b^{ \frac{k}{2}}$$

所以，我们在计算a的时候，并不用把所有的b全部乘起来，只用计算$b^{ \frac{k}{2}}$就可以了，这样的复杂度是$O(logn)$的！

下面给出一个简单的快速幂模板（用了一点位运算，提升速度）

```
inline long long quickpow(long long a,long long b)
{
	long long ans=1;
	while(b)
	{
		if(b&1)ans*=a,ans%=mod;
		a*=a,a%=mod,b>>=1;
	}
	return ans;
}
```
然后，我们就愉快地A掉了这题啦！