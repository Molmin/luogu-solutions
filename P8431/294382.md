## 题目大意
定义 $f(x)$ 值为将整数 $x$ 所有数码翻转得到的数，如 $f(123456)=654321,f(1200)=21$。给定 $n$，求出最大的 $k$ 使得 $\forall x\in[1,k]$，都有 $f(x)\le n$。

## 思路

手玩了一下样例，我们发现，对于位数小于 $n$ 的数 $x$，$f(x)$ 一定不会大于 $n$（毕竟位数小于 $n$），那么，我们直接从 $x=100\dots01$（位数恰好等于 $n$）开始看起。

此时，我直接在脑子里想象将 $x$ 翻转过后得到的数逐渐 $+1$（后面说的 $x$ 全部是翻转过的），什么时候会超过 $n$  呢？我们可以发现，首位（原数的个位）增加的速度一定是大于第二位（原数的十位），而第二位增加的速度又大于第三位（原数的百位）（这是显然的），那么，假设 $n$ 的第一位不是 $9$ 时，一旦 $x$ 的第一位超过 $9$ 就会大于 $n$，而 $n$ 的第一位是 $9$ 时，$x$ 不可能在第一位超过 $n$，我们找到 $n$ 从前往后第一个不是 $9$ 的位，当 $x$ 的这一位超过 $n$ 这一位的数时就会大于它。故答案就是：**找到 $n$ 第一位不是 $9$ 的位，将其加一并翻转**（此时是第一个比 $n$ 大的数）**，首位赋值为 $1$（首个不是 $9$ 的位不是首位的情况下）**（确保位数）**，末位减一**（询问的是 $f$ 值小于等于 $n$ 的上界）**即可**。此时还有一些问题：

首先，对于全部是 $9$ 的数，例如 $9999$ 这一类，可以直接特判掉，答案应该是 $n+1$（以 $9999$ 为例，因为 $10000$ 翻转后有前导 $0$，故从 $10001$ 开始才不符合条件）；

其次，对于 $998000$ 这类 第一个不是 $9$ 的位之后 全部是 $0$ 的数，按照我们之前的结论会得到 $100998$ 的答案，这是因为对于其他情况，只要后面有一位不是 $0$，那么翻转过后我们得到的答案都不会大于 $n$，而若后面全是 $0$ 的话，我们确保位数的那个 $1$ 就会让这个数大于 $n$ 了，故此时第一位不是 $9$ 的位在答案里就不需要加一了。例如在 $n = 998000$ 时，我们原来的结论会得到 $k = 100998$ 的答案，但是此时当 $x=100899\in[1,k]$ 时，$f(x) = f(100899) = 998001 > n$，我们占位的 $1$ 使得答案不对了，故我们要将答案改成 $100898$（毕竟占位的 $1$ 不能去掉）；

最后，一定要初始化。

## 代码
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#define maxn 25
using namespace std;
int T,n; char a[maxn]; int ans[maxn];
int main(){
	scanf("%d",&T);
	while(T--){
		bool flag=0;
		cin>>a+1; n=strlen(a+1);
		for(int i=1;i<=n&&!flag;i++){
			if(a[i]!='9'){
				ans[i]=a[i]-'0'+1; for(int j=i+1;j<=n;j++){if(a[j]!='0') break; if(j==n) ans[i]--;}
				if(i!=n) ans[n]=1; break;
			} else ans[i]=9;
			if(i==n){ printf("1"); for(int i=1;i<=n;i++){printf("0");ans[i]=0;} flag=1; printf("\n");}
		}
		if(!flag){ans[1]--; for(int i=n;i>=1;i--){printf("%d",ans[i]);ans[i]=0;} printf("\n");}
	}
	return 0;
} 
```
