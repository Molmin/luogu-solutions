# 前言

这是一个不太懂数学的小屑生写的文章，如果您想看更具有说服力的文章，请移步到别的题解，这个题解是用“充满智慧的暴力枚举大法”来通过解题的。

# 题目描述

给定一个正整数 $n$，请找出一组**互不相同**的正整数 $a,b,c$，使得：

- $a+b+c = n$。
- $\gcd(a,b) = c$。

其中 $\gcd(x,y)$ 表示 $x$ 和 $y$ 的最大公因数。

# 思路

一道很简单的构造题，很容易想到当 $c = 1$ 的时候解法最多。为什么呢？$c = 1$ 说明 $a$ 和 $b$ 一定是正整数；当 $c = 2$ 的时候，$a$ 和 $b$ 一定是偶数；当 $c = 3$ 的时候，$a$ 和 $b$ 一定是 $3$ 的倍数。此时我们发现，如果 $c$ 越大，那么满足条件的 $a$ 和 $b$ 就越难找，我们只需要让 $c$ 最小即可，所以 $c = 1$ 的时候解法最多。

那么我们只需枚举 $a$ 和 $b$ 就可以了。怎么个枚举法呢？可以先让 $a = 2$，再从 $n-3$ 挨个枚举 $b$，满足条件就输出。 当写出代码时，发现有一个弊端，万一 $n$ 是奇数而且也是 $3$ 的倍数，例如 ```63``` 呢？程序竟然会输出 ```2 0 1```！出现了 $0$ 就肯定出错，所以需要优化。我们可以让 $a$ 也加入到枚举的行列里，每次枚举，让 $b-1$，同时也让 $a+1$，双管齐下，肯定能找到正确的答案。

# 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
	//定义变量
	 
	int n,t,a,b,c;
	
	//输入
	 
	cin>>t;
	
	//处理
	 
	while(t--)
	{
		cin>>n;
		//假设让c = 1,a = 2,b = n-3,原因前文已经解释。 
		c = 1;
		a = 2;
		b = n-3;
		
		//暴力枚举大法，如果不满足条件就一直枚举，反正题目说了有解 
		while(!(__gcd(a,b)==1&&a+b+c==n))//不满足条件 
			a++,b--;//继续枚举 

		//找到答案了，输出 
		printf("%d %d %d\n",a,b,c);
	}
	return 0;
}
```
