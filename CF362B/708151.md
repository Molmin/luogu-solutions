[题面传送门](https://www.luogu.com.cn/problem/CF362B)

# 题意简述

有很多级台阶，皮特想走过他们，有的台阶很脏，所以他不想踏上去。

他一次可以跨过 $1$ 或 $2$ 级台阶，也可以只走到上一级，而不跨过台阶。

现在他在第一级台阶，他要到第 $n$ 级台阶上，问是否能在不踏上脏台阶的情况下做到。

注意：皮特一定会踏上第一个和最后一个台阶，所以如果第一个或最后一个台阶是脏的，那么皮特一定会踏上脏台阶。

# Solution

一道简单练手题。

这题方法很简单，只需要判断有没有三个及三个以上的连续的脏台阶，因为这样皮特就无法不踏上脏台阶。

但是这题直接枚举是不行的，因为数据太大，$1 \leq n \leq 10^9$。

所以我们就要提前排序，然后用排好序的数组来枚举判断。代码：

```cpp
if((a[i]+1)==(a[i+1])&&(a[i+1]+1)==(a[i+2])) {//判断
            printf("NO");
			return 0;
}
```

注意，这里需要特判一下，如果第一个或者最后一个台阶是脏台阶，那么直接输出 `NO`，但这里我们已经对数组排好序了，所以直接判断脏台阶数组的第一项和最后一项就行，不用挨个枚举。~~因为这样会 TLE~~

特判代码：

```cpp
if(a[0]==1||a[m]==n-1) {//特判 
		printf("NO");
		return 0;
}
```

# AC Code

```cpp
#include <bits/stdc++.h>
using namespace std;
int main() {
	int n, m, a[3005];
	scanf("%d%d", &n, &m);
	for(int i=0; i<m; i++) scanf("%d", &a[i]);
	sort(a, a+m);//排序，为后面的判断做准备 
	if(a[0]==1||a[m]==n-1) {//特判 
		printf("NO");
		return 0;
	}
	for(int i=0; i<m; i++) {
        if((a[i]+1)==(a[i+1])&&(a[i+1]+1)==(a[i+2])) {//判断
            printf("NO");
			return 0;
        }
    }
    printf("YES");//如果没有输出 NO，输出 YES 
	return 0;
}//虽然和上一篇题解的代码有点像，但是是自己写的 QwQ 
```

By 2022.7.2 蒟蒻的第二十篇题解