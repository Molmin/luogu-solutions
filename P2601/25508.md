看到这题首先想到一个一个数一定会T

然后有什么可以一次数好多种的方法呢

我们想到可以枚举正方形中心点再二分

若正方形最大边长可以到l,则这个中心对答案有$\frac{l+1}{2}$的贡献

我们只要能O(1)判断两个正方是否相等就可以A掉这个题

通过刘汝佳的字符串hash我想到了扩展到二维的哈希

Hash[i][j]=Map[i][j]+X\*Hash[i][j+1]+Y\*Hash[i+1][j]-XY\*Hash[i+1][j+1]

那样我们预处理出一个矩阵的hash数组并预处理出$Pow[i][j]=Y^iX^j$就可以求出一个正方形的hash了

以(i,j)为左上角且长为l的正方形的hash=Hash[i][j]-Hash[i+l-1][j]\*Pow[l-1][0]-Hash[i][j+l-1]\*Pow[0][l-1]+Hash[i+l-1][j+l-1]\*Pow[l-1][l-1]

于是我们可以把原来的矩阵和原矩阵的左右镜像和原矩阵的上下镜像的hash预处理出来就可以用上面枚举中心+二分+Hash的做法来A掉这个题了

---
本质和楼下RMQ+Manacher算法差不多，但是以为用了hash所以更容易理解一些

\*Hash是个好东西，虽然有点玄学但是真的能代替很多有难度算法\*

[代码](http://paste.ubuntu.com/25416469/)

Hash本应该用unsigned long long来存储来着

但是因为极端数据太慢了，一狠心改成int了
