因为我们要求 $a,b$ 的异或值为 $x$ 且 $\max(a,b)$ 尽可能的小，不妨我们设 $a \leq b$。则我们要让 $b$ 尽可能的小，那怎么能让它尽可能的小呢？

首先，这个运算其实就是不进位加法，而如果我们转换成一般的进位加法的话，$a,b$ 两个位的数要很大才能使其出现进位，但是我们要求 $\max(a,b)$ 尽可能的小，所以还是不出现进位为好吧。。。

因此，如果不出现进位的情况，有这几种求和的方法（在这里，我们严格要求左边的数不小于右边的数）：

```
0 0+0

1 1+0

2 2+0,1+1
```
但是我们要让这两个数尽可能的小，所以我们首先得保证最高位尽可能的小，不然的话低位再怎么变化也没用，但是我们又要求 $a \leq b$,所以，当这个位的数为 $0$ 时，我们直接给它们两个赋 $0$ 就可以，当它为 $1$ 时，分两种情况，要不给 $a$ 一个 $1$，要不给 $b$ 一个 $1$，那取决于什么呢，因为我们要求 $b$ 最小，但是又得让 $a \leq b$ ，所以在前面的高位都相同时我们只能给 $b$ 一个 $1$ 但是之后就不一样了，既然 $a \leq b$ 已经满足了，我们就直接让 $a$ 的后面最大，$b$ 的后面最小就可以了，当它为 $2$ 时，如果前面高位都一样，我们就都赋 $1$，这样一次性就能满足两个条件，当 $a \leq b$ 已经确定时，就给 $a$ 赋 $2$，给 $b$ 赋 $0$ 即可。

**温馨提示:前导零要去掉！！！**

# code:

```cpp
#include<cstdio>
#include<iostream>
using namespace std;
char b[50005],c[50005];
int main(){
    int t,i,j;
    scanf("%d",&t);
    for(j=1;j<=t;j++){
        int n;
        bool yes=0;
        scanf("%d",&n);
        for(i=0;i<n;i++){
            char a;
            cin>>a;
            if(a==49){
                if(yes){
                    c[i]=49;
                    b[i]=48;
                }
                else{
                    c[i]=48;
                    b[i]=49;
                    yes=1;
                }
            }
            if(a==48){
                c[i]=b[i]=48;
            }
            if(a==50){
                if(yes){
                    c[i]=50;
                    b[i]=48;
                }
                else{
                    c[i]=b[i]=49;
                }
            }
        }
        yes=0;
        for(i=0;i<n;i++){
            if(b[i]!=48){
                printf("%c",b[i]);
                yes=1;
            }
            if(b[i]==48&&yes){
                printf("0");
            }
        }
        printf("\n");
        yes=0;
        for(i=0;i<n;i++){
            if(c[i]!=48){
                printf("%c",c[i]);
                yes=1;
            }
            if(c[i]==48&&yes){
                printf("0");
            }
        }
        printf("\n");
    }
    return 0;
}
```
