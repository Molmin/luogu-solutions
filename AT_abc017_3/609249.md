### 大致题意

有 $n$ 个遗迹，可以按照任意顺序探索这些遗迹，允许不探索全部。

探索时会获得宝石，一共有 $m$ 种宝石。

探索过第i个遗迹后，得分将增加 $s_i$，同时，将得到所有种类编号在 $l_i$ 到 $r_i$ 之间的宝石各一个，但是重复探索同一遗迹，将什么都得不到。

获得的宝石无法丢弃，当获得所有种类的宝石后，会清空得分且不能再得分。

求出在不清空得分的情况下，可得到的最高分数。

### 解析/思路

注意到 $1\le s_i \le 5\times 10^3$，即得分均为正，因此贪心，令探索到的遗迹数量尽可能多，且得到的宝石种类尽可能少。

继续思考，得到的宝石种类要尽可能少，那在最优情况下我们肯定要得到 $m-1$ 种宝石。设这个不希望得到的宝石为第 $i$ 种，则我们不应该探索可以得到宝石 $i$ 的遗迹，即在去探索所有遗迹的得分中减去所有会得到第 $i$ 种宝石的遗迹的得分，得出的数即为答案。

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+10;
int n,m,i,mi=INT_MAX,s,tmp,a[N],x[N],y[N],f[N];
int main(){
	cin>>n>>m;
	for(i=1;i<=n;i++)cin>>x[i]>>y[i]>>f[i];
	for(i=1;i<=n;i++)a[x[i]]+=f[i],a[y[i]+1]-=f[i],s+=f[i];
	for(i=1;i<=m;i++)tmp+=a[i],mi=min(mi,tmp);
	cout<<s-mi<<'\n';
}
```