[link](https://www.luogu.com.cn/problem/UVA624)。

## 题目大意
给定 ${n}$ 首歌，每首歌有各自的时间， 你有一个磁带机，它可以存 ${m}$ 分钟的歌。

我们要求在不超过存储时间的情况下最大可以存多少分钟的歌（求出答案序列）。
## 思路
其实这就是一个 01 背包，每一种物品都有取或不取两种状态，用动态规划进行求解即可。

但这道题的难点其实是怎样得到答案序列。

因为 ${f}$ 的下标和记录的值都是时间，所以我想到可以使用一个数组专门来存当前状态是由哪个状态转移来的。

这个状态的值减去它上一个状态的值就是听的歌的时长。

可能讲的有点抽象，代码中附了注释。
## code
```cpp
#include <cstdio>

const int N = 1e4 + 5;

int n, m, w[N], f[N], p[N];

inline void print(int x) {
	if (!p[x]) {
		printf("%d ", x);	 //p 数组初始化为 0，所以到 0 表示到达听的第一首歌。
		return ;
	}
	print(p[x]);
	printf("%d ", x - p[x]);	//x 为当前状态的最佳答案，p[x] 为上一状态的最佳答案，它们的差就是听的那首歌的时间。
}

int main() {
	while (~scanf("%d %d", &m, &n)) {
		for (int i = 1; i <= n; i++) {
			scanf("%d", &w[i]);
			f[i] = p[i] = 0;
		}
		for (int i = n + 1; i <= m; i++)
			f[i] = 0;
		for (int i = 1; i <= n; i++)
			for (int j = m; j >= w[i]; j--)		//这里很重要，因为是01背包，所以一定是从背包最大容量倒着往前枚举，否则一个物品可能会被使用多次。
				if (f[j] < f[j - w[i]] + w[i]) {
					f[j] = f[j - w[i]] + w[i];
					p[j] = j - w[i];	//如果听了这首歌可以使当前状态答案更优，就把上一状态记录下来。
				}
		if (f[m])	//如果答案为 0，不用输出序列（因为根本没有）。
			print(f[m]);
		printf("sum:%d\n", f[m]);
	}
	return 0;
}
```