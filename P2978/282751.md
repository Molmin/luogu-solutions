一道很好的并查集入门题。

题解区 dalao 们并查集都讲得不是特别详细（对于我这种蒟蒻来说），所以这篇题解
是写给没学过并查集或刚学并查集的萌新看的，dalao 们自动忽略。

为了让大家更好的理解并查集，不被抽象的概念吓倒，我们先看题目。

### 题目分析

给出 $M$ 对朋友关系，并且朋友的朋友就是朋友，要我们回答任意两头牛是不是朋友。

### 算法介绍

首先，我们把朋友论资排辈，这样每对朋友之间都有了个大哥。我们用数组 $pre[i]$ 记录第 $i$ 头牛的大哥是谁，当然一开始每头牛的大哥是自己，所以我们得到了初始化代码：
~~~cpp
for(i=1;i<=n;i++)
pre[i]=i;
~~~
现在，有两头牛相遇了，他们互相看不顺眼，想打一架。但是打架之前要先确认是不是一个集体的，怎么确认呢？他们找到了自己的大哥，问：“你认识他吗？”，他的大哥表示不认识，于是他的大哥又去找他自己的大哥：“你认识他吗？”，最后他们分别找到了终极大哥，发现这是同一头牛，两牛便握手言和，一起喝茶，成为了朋友。

细心的人已经发现一个问题：“这样每次找来找去不很麻烦吗？”，所以在寻找终极大哥的过程中，把所有问过的牛的大哥都变为终极大哥，这样每次找就很容易了。

（~~这真是我编过最 SB 的故事~~）

上面这个故事，蕴含了并查集的两个操作：找根和查询以及路径压缩

首先我们来看找根，这个过程是递归的，所以我们使用递归，代码如下：
~~~cpp
int sreach(int k){
    if(pre[k]==k)//如果这头牛的大哥就是自己，那他就是终极大哥
	return k;
    return pre[k]=sreach(pre[k]);//不然就找他的大哥，顺手把他的大哥设为终极大哥（即路径压缩）
}
~~~
然后是查询 $x$ 号牛与 $y$ 号牛是否是朋友，即他们的终极大哥是否相同。
~~~cpp
cin>>x>>y;
if(sreach(y)==sreach(x))//如果两个人的终极大哥一样
cout<<'Y'<<endl;
else
cout<<'N'<<endl;
~~~
下面只剩下如何让两头牛交朋友，即合并操作了，我们还是用一个~~无比尴尬的~~故事来看。

刚才那两头牛成为了朋友，但是他俩成了朋友，他们的朋友（大哥）也得成为朋友，怎么办呢？最简单粗暴的办法是把一边的终极大哥变为另一个终极大哥的小弟，这样就成为了一个集体，但变成小弟的那头牛不高兴啊：“凭什么我是小弟？”，那行，你俩打一架吧！秉着“自古对波左边输”的信念，左边的果然输了，成了小弟。

以下就是 $x$ 和 $y$ 号牛交朋友的代码：
~~~cpp
cin>>x>>y;
pre[sreach(x)]=sreach(y);
~~~
怎么样？并查集是不是非常简单？学会了这些，这道题便可以秒切了!
### 完整代码(无注释)
~~~cpp
#include<bits/stdc++.h>
using namespace std;
int i,n,m,q,pre[10010];
int sreach(int k){
    if(pre[k]==k)
	return k;
    return pre[k]=sreach(pre[k]);
}
int main()
{
	int x,y;
    cin>>n>>m>>q;
    for(i=1;i<=n;i++)
    pre[i]=i;
    for(i=1;i<=m;i++){
        cin>>x>>y;
        pre[sreach(x)]=sreach(y);
    }
     for(i=1;i<=q;i++){
        cin>>x>>y;
        if(sreach(y)==sreach(x))
        cout<<'Y'<<endl;
        else
        cout<<'N'<<endl;
    }
    return 0;
}
~~~