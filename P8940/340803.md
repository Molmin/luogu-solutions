~~这是真人真事。~~

## 命题思路：

- 本题整体解法应该比较自然。
- 命题人先想题再想做法的。
- 然后本来也想让大家乐呵乐呵，但是好像大家还是没乐呵起来。
- 简单数论 / 动态规划 / 最优化 / easy。

## 题解报告：

### 算法 1

- 注意到当所有数都相等的时候，我们不需要操作。
- 期望得分 $10$ 分。

### 算法 2

- 我会搜索！
- $n\leq 4$ 应该随便搜索都能过去（心虚。
- 结合算法 1 期望得分 $15$ 分。

### 算法 3

- 我会观察性质！注意到最后的答案一定是全局 $\gcd$。证明平凡，略。

- 观察性质：每个数最多被一次操作覆盖。
- 证明同样平凡，分几种 corner case 证明重复操作可以合并就好了。
- 然后设计 $\rm dp$，记 $f_i$ 表示把 $1\sim i$ 都变成相同的数的最小代价。记全局 $\gcd$ 为 $G$。
- 有转移 $f_i=\min\{f_{j-1}+i-j+1+k+[\gcd(a_j,a_{j+1},\dots,a_i)\neq G]\}$。
- 直接转移是 $\mathcal{O}(n^3)$ 的，期望得分 $45$ 分。

### 算法 4

- 我会优化上面的 $\rm dp$！
- 我们考虑动态维护 $\gcd(a_j,a_{j+1},\dots,a_i)$。
- ~~当然了，强上数据结构也可以。~~
- 综合时间复杂度 $\mathcal{O}(n^2\log n)$ 的，期望得分 $65$ 分。

### 算法 5

- 我们把原序列满足 $a_i=G$ 的位置染红，其他染黑，则原序列形成若干黑色段。
- 记 $L_i,R_i$ 表示从左到右第 $i$ 黑色段的左右端点位置。
- 我会继续观察性质！注意到只有每段的右端点为有效转移点。因此我们改记 $f_i$ 表示把 $1\sim R_i$ 都变成相同的数的最小代价。
- 考虑分情况转移！如果从本段转移过来，则有 $f_i=f_{i-1}+R_i-L_i+1+k+[\gcd(a_{L_i},a_{L_i+1},\dots,a_{R_i})\neq G]$。
- 否则转移时选择的区间一定包含红色位置，那么可以直接把选择的区间变成 $G$。
- 则有 $f_i=\min\limits_{j<i-1}\{f_{j} + R_i-L_{j+1}+1+k\}$。
- 考虑第二种转移如何快速实现，不难发现，动态维护 $f_j-L_{j+1}$ 的最小值即可。
- 每次转移时上述两种情况取 $\min$ 即可。

- 综合时间复杂度 $\mathcal{O}(n\log a_i)$，瓶颈在于求 $\gcd$，事实上，常数只有 $\frac{1}{3}$。