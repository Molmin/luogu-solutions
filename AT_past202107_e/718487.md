## 题目

[题目传送门](https://www.luogu.com.cn/problem/AT_past202107_e)

## 思路

我们来观察一下这个数字的变化（假设 $k = 4$，只列举前 $5$ 项）：

| 第 $i$ 次操作 | 可能被改变的数字 | 最终数字 |
| -----------: | -----------: | -----------: |
| $1$ | $1$ | $1$ |
| $2$ | $3$ | $3$ |
| $3$ | $9$ | $9$ |
| $4$ | $27$ | $28$ |
| $5$ | $84$ | $84$ |

从中可以发现，$28$ 和 $84$ 模 $3$ 余 $1$，$1$、$3$ 和 $9$ 模 $3$ 余 $0$。也就是说，在第 $k+1$ 次操作时，如果最终数字为 $w$，那么第 $k$ 次操作时的最终数字为 $w \div 3$，第 $k - 1$ 次操作时的最终数字为 $(w \div 3 - 1) \div 3$。

通过我们的发现，可以得出这样的一个思路：

重复执行 $30$ 次，循环变量 $i$ 从 $30$ 到 $1$ 依次递减。每次循环将 $x$ 除以 $3$，如果当前的 $x$ 模 $3$ 余 $1$，那么将答案设为当前的 $i$。循环结束后，如果它是 $1$，那么输出答案即可，否则，就输出无解。

## 细节

在实现的过程中，还有三点细节需要注意：

1. 循环中，因为青木君只会在一次操作后，将 $x$ **加一**，所以如果当前的 $x$ 模 $3$ 余 $2$，那么可以直接判定无解。

2. 循环中，因为青木君只会在**一次**操作后，将 $x$ 加一，所以如果有两次 $x$ 模 $3$ 余 $1$，也可以直接判定无解。这里可以使用一个标记变量来记录之前是否出现过 $x$ 模 $3$ 余 $1$ 的情况，如果第二次出现，就是无解的情况。

3. 因为 $1 \leq n \leq 10^{15}$，所以要开 `long long`！

## 代码

代码如下：

```cpp
#include <bits/stdc++.h>
using namespace std;

typedef long long ll;

int main() {
    ll x;
    cin >> x;
    bool flag = false;
    int ans = -1;
    // x每次除以3，还原乘的过程。
    for(int i = 30; i >= 1; --i, x /= 3) {
        if(x % 3 == 2) {    // 除以3余2不满足条件
            puts("-1");
            return 0;
        }
        if(x % 3 == 1) {    // 除以3余1
            if(flag) {  // 如果之前有过除以3余1那么不满足条件
                puts("-1");
                return 0;
            }
            ans = i;    // 更新答案
            --x;    // x减去那个多乘的1
            flag = true;    // 记录一下，出现过除以3余1的情况
        }
    }
    // 只有除完以后x只剩下1时输出答案，否则不满足条件
    printf("%d", x == 1ll ? ans : -1);
    return 0;
}
```

谢谢大家！完结撒花！
