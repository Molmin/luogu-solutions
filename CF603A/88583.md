机房巨佬都说这是一道规律题，可蒟蒻我推不出规律，只好打个dp

3个状态：

①$f[i][0]$表示当前第$i$个数字没有翻转，且前面无子串翻转的最大值

②$f[i][1]$表示当前第$i$个数字没有翻转，前面某一段翻转所得的最大值

③$f[i][2]$表示当前第$i$个数字翻转所得的最大值

很容易看出$f[i][0]$只能由$f[i-1][0]$转移过来

$f[i][1]$由$f[i-1][1]$(很之前一段翻转)与$f[i-1][2]$(前面一段翻转)转移来

$f[i][2]$由$f[i-1][2]$(连续一段翻转)与$f[i-1][0]$(前面没翻转)转移而来

详细状态转移方程见代码

```cpp
#include<cstdio>
#define max(x,y) ((x) > (y) ? (x) : (y))
int a[1000005],n,ans,f[1000005][3];

int main()
{
	register int i;
	scanf("%d",&n);
	for(i = 1;i <= n;++ i)
		scanf("%1d",&a[i]);
	f[1][0] = f[1][1] = f[1][2] = ans = 1;
	for(i = 2;i <= n;++ i)
	{
		bool flag = (a[i] == a[i - 1]);
		f[i][0] = (flag ? f[i - 1][0] : f[i - 1][0] + 1);
		f[i][1] = (flag ? max(f[i - 1][2] + 1,f[i - 1][1]) : max(f[i - 1][1] + 1,f[i - 1][2]));
		f[i][2] = (flag ? max(f[i - 1][2],f[i - 1][0] + 1) : max(f[i - 1][2] + 1,f[i - 1][0]));
		ans = max(f[i][0],max(f[i][1],f[i][2]));
	}
	printf("%d",ans);
	return 0;
}

```
