    先给大家讲一下思路：在本题中，由于只有加号和乘号，只要从左往右扫一遍，如果遇到乘号直接计算（做乘法）；如果遇到加号，若后面没有符号或者后面一个符号也是加号，则直接计算（做加法）；否则（后面是乘号），先把后面紧接着的连续乘号算完，最后再加。
    算法实现中，只要设置一个栈保存没有立即进行的加法，扫描结束后再一起处理栈中的加法运算；同时，因为把一个数字串转换成数也需要单独编写一个子程序；最后，还要注意实现过程中及时对10000取模。
    来，上代码。
```
#include<bits/stdc++.h>
using namespace std;
const int N=100010,k=10000;
int a[N];
int main()
{
    int x,top=1;
    char ch;
    cin>>a[1];
    while(cin>>ch){
        cin>>x;
        if(ch=="*")a[top]=(a[top]*x)%k;//直接乘法运算
        if(ch=="+")a[++top]=x;//加法入栈
    }
    int ans=0;
    for(int i=1;i<=top;i++)//处理栈中的所有加法运算
        ans=(ans+[i])%k;
    cout<<ans<<endl;
    return 0;
}
  
  
```
这是此蒟蒻第一次写题解，求管理员大佬通过。