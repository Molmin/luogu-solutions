## 挑战短代码系列

~~暴搜两次便AC~~~~

### 蒟蒻de辣鸡思路：把每个数用一个整型数组存起来，运算符用一个字符数组存起来，即：a[i]和a[i+1]之间的运算符为c[i]。

作为一个辣鸡，我尝试了一遍一次判断就输出，然后发现过不了

最后惊奇的发现：乘法的优先性居然高于加法。这可让我这个小学数学常年不及格的孩子愁坏了。

怎么办呢？

### 先从后往前扫描一遍，将乘号两边的数乘起来，把a[i]赋值为积，a[i+1]赋值为0，方便第二次扫描求和。第二次扫描，将数组内每一个数一个一个加起来，~~打暴力，方便又实用~~

具体理解可以看代码：
```cpp
#include<stdio.h>
long long a[101010],cnt=1,sum=0;
char c[101010];
int main(){
    scanf("&%lld",a[cnt]);
    a[cnt]%=10000;//读入第一个数
    while(cin>>c[cnt]){//一个一个读，读到不再有新的运算符，也就不会再有新的运算
        cin>>a[++cnt];
        a[cnt]%=10000;//模一遍玩
    }
    for(int i=cnt;i>=1;i--){
        if(c[i]=='*'){//判断乘法
            a[i]*=a[i+1];//赋值
            a[i]%=10000;//再模一遍玩
            a[i+1]=0;//懒得删除元素（其实我不会QwQ）
        }
    }
    for(int i=1;i<=cnt;i++){//一个一个加
        sum+=a[i];
        sum%=10000;//叕模
    }     
    printf("%lld",sum);//完美的输出
}
```
~~卖个萌求管理通过~~