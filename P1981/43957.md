这道题不是很难，我用了一个库函数atof来实现转化（不知道的可以问问度娘），然后，就是纯模拟了·······具体详见代码

```cpp
#include<cstring>
#include<cstdio>
#include<iostream>
#include<cmath>
using namespace std;
char a[1000000];//用于储存表达式 
int p[100001];//用于储存数 
bool w[100001];//用于判断符号为加号（1）或乘号（0） 
int main()
{
    scanf("%s",a);//读入字符串，这里我用的是scanf，因为好像很多评测系统不支持gets 
    int len=strlen(a)-1;//计算表达式长度，因为从零开始，所以要-1 
    int k;//用于储存一个数的最高位在表达式中出现的位置 
    int r=1;//用于记录已记录到几个数 
    int flag=1;//用于判断此数字是否为最高为上的数字 
    int flag1=1;//用于记录已记录到几个符号 
    for(int i=0;i<=len;i++)
    {
        if(a[i]>=48&&a[i]<=57&&flag==1)//如果这个字符是数字而且是最高位 
        {
            k=i; 
            flag=0;//记录，同时将flag赋值为0 
        }
        if(a[i]=='+'||a[i]=='*')//如果这个字符是符号，说明数字已经转换完毕 
        {
            flag=1;//说明上一个数已经记录完毕 
            int h=0;//用于将表达式中的数转移进辅助数组q 
            char q[4]={'0'};//这里一定要赋值为零！！！！ 
            for(int j=max(k,i-4);j<i;j++)//因为题目说只保留后四位，所以这里会做一个比较，到底这个数有没有超过10000 
            {
                q[h]=a[j];
                h++;
            }
            p[r]=atof(q);//库函数，将q数组中储存的数以浮点数形式赋值至p数组 
            r++;
            if(a[i]=='+')
                w[flag1]=1;//若为加号，则赋值为1 
            if(a[i]=='*')
             w[flag1]=0;//若为乘号，则赋值为0 
            flag1++;
        }
        if(i==len)//特殊处理在最后一位的情况 
        {
            int h=0;
            char q[11];
            for(int j=max(k,i-3);j<=i;j++)
            {
                q[h]=a[j];
                h++;
            }
            p[r]=atof(q);//转化 
            r++;
        }
    }
    for(int i=1;i<=r-2;i++)
    {
        if(w[i]==0)
        {
            p[i+1]=p[i+1]*p[i]%10000;//先算乘法，这里一定要记得取余！！！！不然会全WA！！！！ 
            p[i]=0;
        }
    }
    for(int i=1;i<=r-2;i++)
        p[i+1]=p[i+1]+p[i]%10000;//这里也一样！！！！！ 
    cout<<p[r-1]%10000<<endl;//这里也是！！！！！！ 
    return 0;
}
```