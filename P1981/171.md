洛谷1981：表达式求值

[题目描述]

给定一个只包含加法和乘法的算术表达式，请你编程计算表达式的值。

[输入样例]

1+1234567890\*1

[输出样例]

7891
[数据范围]

对于 30%的数据，0≤表达式中加法运算符和乘法运算符的总数≤100；

对于 80%的数据，0≤表达式中加法运算符和乘法运算符的总数≤1000；

对于 100%的数据，0≤表达式中加法运算符和乘法运算符的总数≤100000。

[算法分析]

把表达式用字符串读入，从后往前处理，将数字的后四位存起来，其他的都不要，并把符号也存起来。然后将这些数字扫一遍，若和这个数下标一样的符号为乘号，就将这个数和前一个数相乘，否则不变。最后，将剩下的每一个数都加起来，输出答案。因为此题数据较大，在运算时要不断对10000取模。

得分：100

[C++源代码]

```cpp

#include<iostream> 
#include<cstdio>
#include<cstdlib>
#include<cstring>
using namespace std;
string s;
char fh[1000001];
int f,z,sz[1000001],sz1[1000001],z1=1,ans,k,y=1;
int main ()
{
    cin >>s;
    for (int b=s.size()-1;b>=0;--b)
    {
        if ((s[b]>='0') && (s[b]<='9') && (y<=4))
        {
            if (z==0)z=1;
            k=s[b]-'0';
            for (int b=1;b<=y;++b)k*=10;
            sz[z]+=k;y++;
        }
        if ((s[b]=='+')||(s[b]=='*'))
        {
            sz[z]/=10;
            z++;f++;y=1;
            fh[f]=s[b];
        }
    }sz[z]/=10;
    for (int b=z;b>=1;--b)
    {
        if ((fh[b]=='*'))sz1[z1-1]=sz[b]*sz1[z1-1]%10000;
        else {sz1[z1]=sz[b];z1++;}
    }
    for (int b=z1;b>=1;b-=2){ans+=sz1[b]+sz1[b-1];ans%=10000;}
    printf ("%d\n",ans);
    return 0;
}

```