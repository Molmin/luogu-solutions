很简单的纯模拟：

比如1+2\*3，先读入1，此时ans==1;

然后再读入2，此时ans==3;

但是显然不应该直接加2，应该加上2\*3，但是现在还不知道下一个是\*3。

等到读入3的时候，发现是乘，于是减去2，加上2\*3。

此时ans==7

还有一个例子：比如

1+1\*2\*3+4

这里出现了连乘，所以在需要储存，

第一次读入1，ans==1

第二次读入+1，ans==2

第三次读入\*2，ans先减去前面那个1，然后加上1\*2

第四次读入\*3，ans先减去前面那个1\*2，然后加上1\*2\*3

最后读入+4，ans加上4.

所以需要储存一下。

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int main()
{
    long long ans=0,w1,w2;
    char c;
    scanf("%lld",&w1);  //先处理第一个数
    ans+=w1;
    for(int i=0;scanf("%c%lld",&c,&w2)!=EOF;i++)  //边读入边计算
    {
        w1%=10000;  //模一下，否则会爆
        w2%=10000;  //模一下
        if(c=='*')   //如果读入的符号为乘
        {
            ans=ans-w1+w1*w2;  //计算，w1为存的需要减去的内容
            w1*=w2;  //这里不能用=，因为需要存，把乘法看做一个整体
        }
        else if(c=='+')  //加法计算
        {
            ans+=w2;  //直接加就好了
            w1=w2;  //储存一下
        }
        ans%=10000; //ans模一下
        w2=0;  //没有任何用处的置零
    }
    printf("%lld",ans%10000);  //输出就好了XD
    return 0;
}
```
题解尾部安利一下一部神作：
##[这番超好看的XD](https://bangumi.bilibili.com/anime/5796)
