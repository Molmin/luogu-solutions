### 解题思路  
首先虽然题目是运算，但是数字和运算符是混在一起的，所以输入的变量只能是字符串类型，我们需要对整个字符串进行遍历。
遍历的时候会遇到两种情况：
‘0’到’9’，需要把当前的字符拼到数字中。
如果遇到的是’+’ 和 ‘*’，说明情况 1 中的数字拼接结束了，但是此时无法直接进行运算，因为参与运算的数字还在当前运算符的后面。虽然此时不能对当前运算符进行计算，但是可以对上一个运算符进行计算。
一些重点，关系到你能不能拿满分：  
1. 数字保存到栈中。  
2. 题目中包含两种运算，加法和乘法，不存在括号，乘法的优先级高于加法。遇到加号时可以不必立即运算，但是遇到乘法必须立即计算。  
3. 上一个运算符是乘法时，取出栈顶元素与当前拼出的数字相乘，计算结束再放回栈中。  
4. 字符串最后必然是数字，所以遍历结束后要检查是否有乘法运算未计算。
5. 不管是加法还是乘法，如果结果要保留4位数字，那么计算过程中的每个数字都可以提前 %10000 保留4位，对结果都不会有影响。  
6. 加法可以最后再计算，栈中剩下的数字统一相加，补上加法运算即可。  
---  
### 参考代码（关爱生命，拒绝抄袭）：  
```cpp  
#include <bits/stdc++.h>
using namespace std;
bool need = false;//need为true表示上一个运算符是乘号
stack<int> s;
string str;
int num = 0, top = 0;
void handle() {
	if (need) {//如果上一个运算符是*，那么和栈顶数字相乘再放入栈中
		top = s.top();
		s.pop();
		s.push(num * top % 10000);
	} else s.push(num % 10000);//否则直接放入栈中
	num = 0;
}//handle 表示数字拼接完毕了，把数字放入栈中
int main() {
	cin>>str;
	int len = str.size();
	for (register int i = 0; i < len; ++i) {//这里设置的need，下一次才会用到
		if (str[i] == '*') {
			handle();
			need = true;
		} else if (str[i] == '+') {
			handle();
			need = false;
		} else num = str[i] - '0' + num * 10;//新的数字拼接前面保存的数字末尾
	}//遍历结束后要把最后一个数字放入栈中
	handle();
	//乘法在前面都处理完了，剩下的都是需要执行加法的数字
	while (!s.empty()) {
		top = s.top();
		s.pop();
		num = (top + num) % 10000;   
	}
	printf("%d", num);
	return 0;
}  
```  
其实我们要记住，几乎所有表达式问题都可以用栈解决。