
[题目传送门](https://www.luogu.com.cn/problem/P3941)

## 解题思路

利用二维前缀和求解。首先可以预处理出二维前缀和，直接枚举每一种大小的矩阵可以打出 $O(n^2m^2)$ 的暴力做法。加上特殊性质的判断可以得到75pts。

正解需要利用压行的技巧，将几行压成一行求解。首先我们对前缀和取模，数组中只保留取模后的值。

先假设所有的矩形左上角的 $y$ 值都为 $1$，枚举首行与末行，以及最右端的列数。

利用cnt数组存储每个取模后的值出现的矩阵个数。有一个结论：如果在枚举中出现两个同余的矩形，那么这两个矩形中间的矩形的模 $k$ 的余数为 $0$，也就符合条件。

看图

![](https://s3.ax1x.com/2020/12/01/DhLSAO.png)

如果设 $s_3$ 为图中最大的矩形，即两个矩形之和，且范围内和的余数为 $x$，而又同时存在 $s_1$ 这个矩形模 $k$ 的余数为 $1$，那么显然 $s_2$ 就是一个符合条件的矩形。

一开始除了 $cnt[0]$要初始化为 $1$，因为这个矩形本身要算进去，其他的都是 $0$。

之后枚举时若出现了一个余数为 $x$ 的矩形，那么它必然与之前所有同样余数的矩形都可以构成一个如 $s_2$ 一样的合法矩形，这时候只要将答案加上之前出现的同余矩形数即可。

不用考虑其他情况，因为除了这 $cnt[x]$ 个矩形，其他情况出现的矩形已经在之前的循环中枚举出来了，这样就可以不重不漏地枚举出每一个合法矩形。

时间复杂度 $O(n^2m)$。
## 代码
```cpp
#include<iostream>
#include<cstdio>
#define ll  long long
using namespace std;
int n,m,a[500][500],k;
ll sum[500][500];
ll cnt[1000010],b[500];
ll ans,s;
int main()
{
	scanf("%d%d%d",&n,&m,&k);
	int last=0;
	for(int i=1;i<=n;i++)
	for(int j=1;j<=m;j++)
	{
		scanf("%d",&a[i][j]);
		sum[i][j]=(sum[i-1][j]+sum[i][j-1]-sum[i-1][j-1]+a[i][j]+k)%k;
	}
	for(int i=0;i<n;i++)
	for(int j=i+1;j<=n;j++)
	{
		cnt[0]=1;
		for(int q=1;q<=m;q++)
		{
			b[q]=(sum[j][q]-sum[i][q]+k)%k;
			ans+=cnt[b[q]];
			cnt[b[q]]++;
		}
		for(int q=1;q<=m;q++)cnt[b[q]]=0;
	}
	printf("%lld",ans);
	return 0;
}
```