此题做法我觉得不是很好想。首先(nm)^3的暴力可过30，(nm)^2的二维前缀和优化可得60，这些都是一看到题就能想出来的做法，加上特殊性质可以拿到75.而如果写了AC算法，却粗心了，可能会是时间和分数上的双重失败。

（不过对于大佬来说这些不过是闭着眼睛敲一会儿键盘的事情。

---------------------------------------

AC思路：

首先子矩形不是子矩阵。

大概可以减少一维。因为不是二维求和，只是输出k的倍数的子矩形。首先对所有二维求和显然是n^4的算法。那么只是输出k的倍数的子矩形个数，就算二维求和做完后再朴素求解答案，就已经是n^4，因而我们如果要优化，肯定从“k的倍数”入手。

首先处理从左上角开始的每一个二维前缀和，于是可以O（1）得到矩阵中每一个子矩形的和。考虑数据范围400，可以猜到大概是n^2logn或n^3的算法。二维二分比较困难，因此可能是n^3。（这是我的思考过程）因为是k的倍数，所以把每一个二维前缀和都只存对k的余数即可。（注意负数特判，因为有减法。）

一个性质：每一个矩形都可以表示为一个大矩形减去一个小矩形。我们不妨设这个大矩形和小矩形的上边都是x=1的边。

![](https://t1.picb.cc/uploads/2017/11/09/veg0g.png)

也就是这样。

现在我们需要枚举4个值才可以表示所有的矩形：大矩形的起点的横坐标，大矩形和小矩形的宽度，小矩形的长度，大矩形的长度。

然而，大矩形和小矩形的长度实际上我们枚举一次就好，当我们枚举到一个长度，假设矩形差为m，它就是要求的矩形的值。把它存到一个vector里面，并且存它一共出现了几次。

这样就是O（n^2m)的算法了。如果想保险可以写成（m^2n)，因为有时候m会等于2 。

最后我们对这些出现过重复的矩形的值进行处理。可以举几个例子试一下，每一个差都可能是答案，而两个连续的差合起来也可能是答案。为了清楚可以看我的渣图。

![](https://t1.picb.cc/uploads/2017/11/09/velke.png)

假设如图四条线，其矩形值都是a，那么显然两条线夹着的矩形值为0（当然都是k的剩余系里面）。也就是1，2，3三个矩形都是符合条件的。那12，23，123也都是符合条件的。那答案就是1+2+3=6.当有5个a就是1+2+3+4=10.不难发现这是等差数列，用等差数列求和就好了。

```cpp
#include<bits/stdc++.h>
using namespace std;
long long a[1000][1000],n,m,k,ans;
long long c[1000][1000];
int apnum[5000005];
bool numaped[5000005];
vector<int>cnum;
int absolute(int x){
    if(x%k>=0)return x%k;
    else return x%k+k;
}
int main(){
    std::ios::sync_with_stdio(false); 
    cin>>n>>m>>k;
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){
            cin>>a[i][j];
            c[i][j]=absolute(c[i][j-1]+c[i-1][j]-c[i-1][j-1]+a[i][j]);
        }
    }
    for(int i=1;i<=n;i++){//横坐标枚举 
        for(int j=0;j<=n-i;j++){//宽度枚举 
                apnum[0]=1;
            for(int y=1;y<=m;y++){//长度枚举 
                apnum[absolute(c[i+j][y]-c[i-1][y])]++;
                if(!numaped[absolute(c[i+j][y]-c[i-1][y])])cnum.push_back(absolute(c[i+j][y]-c[i-1][y]));
                numaped[absolute(c[i+j][y]-c[i-1][y])]=1;
            }
            for(int p=0;p<cnum.size();p++){
                ans+=((apnum[cnum[p]])*(apnum[cnum[p]]-1))/2;
                apnum[cnum[p]]=0;
                numaped[cnum[p]]=0;
            }
            cnum.clear();
        }
    }
    cout<<ans;
}
```