本题不需要数组，只需要一个递归，边输出边统计1的个数

其实本题是位运算模板题，通过每次右移并且进行逻辑与运算就可得出1的个数。因为短除法是要从后往前输出，我们就利用递归输出，并且在递归时顺便进行统计。

做完本题的可以去做 $\large CSP-J2020\ T1$，跟本题很像

代码：

```cpp
#include <iostream>
using namespace std;

int cnt = 0;

void func(int& n)
{
	bool a = n & 1;
    if(a)
    {
        cnt++;
    }
	n >>= 1;
	if(n)
	{
		func(n);
	}
	cout << a;
}

int main()
{
    ios::sync_with_stdio(false);
    int x;
    while(cin >> x && x)
    {
        cnt = 0;
        cout << "The parity of ";
        func(x);
        cout << " is " << cnt << " (mod 2).\n";
    }
    return 0;
}
```

知识点：

# 位运算


## 1、<<
"<<"左移符号用于将n的二进制每一位往左移，末尾用0补足

$\Large n\, << \,1 \,=\, n \,* \,2$

$\Large n \,<<\, 2\, = \,n\, * \,2\, * \,2$

$\Large n\, <<\, x \,= \,n \,*\, {2 ^ x}$

## 2、>>

">>"右移符号用于将n的二进制每一位往右移，最右边的一位消失

$\Large n \,>>\, 1\, =\,n \,/ \,2$

$\Large n\, >>\, 2 \,=\, n \,/\, 2$

$\Large n \,>>\, x\, =\, n \,/ \,{2 ^ x}$

注意n右移的结果必定是正整数，也就是说这里的除法相当于自动下取整

## 3、&

a & b的返回值是将a与b的二进制进行按位与运算，按位与就是都为1为1，不然为0

例如a和b的二进制分别为10101与10011

那么：
```cpp
10101
10011

10001
每一位按位与

a & b = 10001
```

### 如果a的位数或b的位数不够，用0补足


## 4、|

a | b的返回值是将a与b的二进制进行按位或运算，按位或就是其中一个为1就为1，两个都为0为0

### 如果a的位数或b的位数不够，用0补足

例如a和b的二进制分别为10101与10011

那么：
```cpp
10101
10011

10111
每一位按位或

a | b = 10111
```
$\Huge End.$