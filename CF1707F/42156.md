好牛逼啊。

不妨假设 $n=2^k$。如果 $t\ge n$，$c$ 一定全是 0，以下假设 $t<n$。

这个操作见过很多次，显然就是设 $t$ 的子集为 $S$，$c_i=\oplus_{j\in S}a_{(i+j)\bmod n}$。

接下来的 idea 也比较正常：尝试对 $t$ 分治。（第一个试错点：从低位往高位考虑，顺序不要反）如果 $t$ 为偶数，说明 $a_{0,2,\dots},a_{1,3,\dots}$ 两边互不影响，因此可以递归计算 $ans([c_{0,2,\dots}],t/2)$ 和 $ans([c_{1,3,\dots}],t/2)$ 乘起来。否则，考虑先（试错：先还是最后）对 $a$ 做一次操作变为 $[a_{0}\oplus a_1,a_1\oplus a_2,\dots]$，这之后 $a$ 的奇数位、偶数位互不干扰了。此时 $a$ 奇数位和偶数位异或和相等。

接下来，要跳出思维定势，因为有了上述观察就已经可做了！注意到我们已经有了”从 $c$ 恢复 $a$ 的和“的工具：（和皆指异或和）

- 如果 $t$ 是偶数，异或和就是奇偶分开、$t/2$ 的和之和。
- 如果 $t$ 是奇数，奇偶分开、$t/2$，要求这两边的返回值相等。返回这个相等的返回值。

由此我们设计出来 dp：设 $f[\{c\},k,t]$ 表示 $c=\{c\}$ 且 $a$ 的异或和为 $k$ 的合法 $c$ 的数量。转 移：$t$ 是偶数就是递归两边，然后结果对 $k$ 做 $\mathrm{xor}$ 卷积；$t$ 是奇数就是递归两边，然后结果对 $k$ 做点积。

观察到整个 dp 数组在 $k$ 这维只有三种形态：

- 全相等，且为 $2^{x}$。
- 只有一个位置非 0，且为 $2^{x}$。

归纳易证。因此点积和 $\mathrm{xor}$ 卷积都是容易 $O(1)$ 维护的。所以可以设计类似翻转的线段树的结构来维护 dp，模数在变就只维护 $x$ 最后快速幂。

如果 $n\ne 2^k$，这步也不显然。设 $n=2^m(2x+1)$，数组 $b[0,2^m-1]_i=a_i\oplus a_{i+2^m}\oplus \dots$，注意到每次操作对 $b$ 的影响和对 $a$ 的影响形式完全相同，在 $2^m$ 步后 $b$ 变为全 0。结论：只要 $b$ 合法 $a$ 就合法。

结论的证明其实并不难。分析上面的递归过程在 $n\ne 2^k$ 时出了什么问题：第一次出问题一定是 $n$ 是奇数时，也即 $n=2x+1$，现在递归的 $c$ 就是 $b$ 的组成。如果 $t$ 在之前已经变成了 0，那在 $t$ 变成 0 时每个位置已经独立了。递归到现在这时当然还是独立的。因此，只需证明 $n$ 是奇数且 $t>0$ 的情况，合法只需要全部 $\mathrm{xor}$ 和为 0。只需证能唯一恢复上一层的序列，也即在已知全体 $\mathrm{xor}$ 和、相邻 $\mathrm{xor}$ 和时有唯一解，这是显然的！

直接用（bitrev 之后的）线段树维护，时间复杂度 $O(n+(m+q)\log n)$。