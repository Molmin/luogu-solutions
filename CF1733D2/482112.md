### $\mathcal O(n^2)$ Solution

直接区间 $\tt dp$，但是我不会啊。

不过足以通过本题。

### $\mathcal O(n)$ Solution

如果 $x \ge y$ 直接按照 D1 的做法做。

如果 $x<y$ 我们设有 $\Delta$ 个不同的元素，直接处理出所有的不同的位置，存在一个序列 $d_1,d_2,\dots,d_{\Delta}$ 里面。

首先 $\Delta\bmod 2=1$ 直接输出 $-1$，这个在 D1 已经讨论过了。

然后，考虑直接设线性状态 $dp_i$，那么：

$$dp_{i}=\begin{cases}\min(dp_{i-2}+x(d_i-d_{i-1}),dp_{i-1}+y) & i \text{ is even}\\ \min(dp_{i-2}+x(d_i-d_{i-1}),dp_{i-1}) & 
i\text{ is odd} \end{cases}$$

答案是 $dp_{\Delta}$。

证明：

首先我们考虑到有一个基本的贪心，就是第 $2i-1$ 个锅一定会和第 $2i$ 个一起修。如果不一起修就会有跨过别的锅的情况，当然在 $y$ 操作的时候不影响，但是在 $x$ 操作的时候就不如拿相邻的两个锅修，这样的贪心显然是对的。

所以我们会分成奇数和偶数讨论，具体的：

$n$ 是偶数的时候，如果要把第 $i$ 个锅修掉，那么有两种方案：和前面一个锅一起修，那么代价是 $y$，从 $dp_{i-1}$ 转移过来。还有一种：使用代价为 $x$ 的操作，一个一个操作过来（对 $l=i,r=i+1$ 操作一次，对 $l=i+1,r=i+2$ 操作一次实际上就抵消了，这一点在 D1 中你就应该观察到），那么你应该把状态从第 $i-2$ 个状态转移过来，具体的，是 $dp_{i-2}+x(d_i-d_{i-1})$。

$n$ 是奇数的时候，如果要把第 $i$ 个锅修掉，那么因为奇数是被偶数继承状态，所以第一种情况它直接从 $dp_{i-2}$ 转移，第二种情况同理于上面的第二种情况，所以也是 $dp_{i-2}+x(d_i-d_{i-1})$。

那么取最小值就好了，于是得证，复杂度 $\mathcal O(n)$。

[实现](https://codeforces.com/contest/1733/submission/187616357)，但是不用分类讨论。