### 解题思路：

有趣的 DP 题。

对于每一个奇数，都可以从两个方向转移过来（加一和减一），每一个偶数都可以从三个方向转移过来（一半，加一和减一）。

这其中比较麻烦的是从比自己大一的那一个转移过来，因为在一般的 DP 中是不能从后向前转移的，那么就考虑改变一下。

首先发现，任意一个数都不可能连续减两次一的，减一一定是发生在乘以二之后的，如果是加一之后那还不如不做，而在乘以二之后连续减两次一一定劣于在乘以二之前减一，这两种效果一样，但前一种一定更优。

根据这个，显然偶数是不可能从比自己大一的数转移过来的。

再往后推一步，任意一个奇数从比自己大一的数转移过来一定是从后一个数的一半乘以二然后在减一的，否则会与刚才的结论冲突。

-----

综上所述，实际的转移只有如下几种可能：

1. 当前数是偶数，从这个数的一半或比这个数小一的数转移过来。

2. 当前数是奇数，从比这个数大一的数的一半或比这个数小一的数转移过来。

形式化地，有：

$\begin{cases}f_i=\min(f_{i-1}+x.f_{\frac{x}{2}}+y)|i \mod2=0\\f_i=\min(f_{i-1}+x,f_{\frac{x+1}{2}}+y)|i \mod2=1\end{cases}$

-----
### 代码：

```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
long long f[10000005],n,x,y;
int main(){
	scanf("%lld%lld%lld",&n,&x,&y);
	for(int i=1;i<=n;i++){
		if(i&1)f[i]=min(f[i-1]+x,f[(i+1)/2]+x+y);
		else f[i]=min(f[i-1]+x,f[i/2]+y);
	}
	printf("%lld",f[n]);
	return 0;
}
```
