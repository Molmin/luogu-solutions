## 题意：
将给出的数组分为p个递减的序列，且每两个序列的和之差小于等于3。
## 分析：
首先我们可以很轻易的想到，要想任意两堆重量差值最小，我们要尽量把相同重量的物品均分到p堆里，因为如果p堆里都有一个重量为x的物品，相互之间的差值依然为0，这样两堆的差值只取决于$sum[3]$%$p$,$sum[2]$%$p$,$sum[1]$%$p$,因为其与的已经均分到p堆里了，不会造成差值。

那么这些怎么办呢？我们只需要把它们从大到小依次放到p堆里，可以保证合法。我们只需要分类讨论即可证明：首先每个堆里最多有一个1，一个2，一个3，且第一堆一定是最重的，第p堆一定是最轻的，按照这个，那么只要证明$w[1]$-$w[p]$<=3即可。假设堆1为3,2,1那么第p堆至少是2,1，否则堆1不可能在上面放着2,1;同理，假如第一堆为3,1，那么第p堆至少为1……如此讨论几次，即可发现重量只差按照这个方式排列一定小于三。

## 蒟蒻代码
```
#include<algorithm>
#include<iostream>
#include<cstring>
#include<cstdio>
#include<cmath>
using namespace std;
int n,p,a[1010],w[510][510];
int main()
{
	scanf("%d%d",&n,&p);
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&a[i]);
	}
	sort(a+1,a+1+n);
	int fl=1,g=1;
	n++;
	while(n--)
	{
		w[fl][g]=a[n];
		g++;
		if(g>p)
		{
			g=1;
			fl++;
		}
	}
	for(int i=1;i<=p;i++)
	{
		for(int j=1;w[j][i];j++)
		{
			printf("%d ",w[j][i]);
		}
		printf("\n");
	}
	return 0;
}