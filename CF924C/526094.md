一堆单调栈的，不是很理解（大佬轻喷），写篇通俗易懂的题解。

------------

此题翻译很不友好，读了一遍又一遍还是不懂。

一句话解释一下（搬的）：每天在当前水位刻一条线，如果这个水位上以前已经刻过了就不用重复再刻，输入的 $m_i$ 是每天水位以上有多少条刻线（第一天开始的时候保证是没刻线的），问 $n$ 天里水位以下刻线的总数的最小值。

显然，水位以上的个数都给出，以下的个数和取决于总个数和。

又由于刻线个数是单调不减的，只需要尽可能多重复，就可以让总个数和取最小值。

很快就能想到，个数每天最多增加 $1$，于是倒序维护第 $i$ 天可能的最少个数 $f_i=\max(m_i,f_{i+1}-1)$。

前文提到，刻线个数是单调不减的，所以再求前缀最大值。

具体地说就是，正序枚举 $i$，更新 $f_i$ 为 $\max(f_i,f_{i-1})$。

最后，水位以下的刻线个数等于总个数减去水位以上的个数，即 $d_i=f_i-m_i$。

输出答案 $\sum_{i=1}^{n}d_i$。

------------

这么简单的代码应该没有人看吧。

不过记得看数据范围。
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;//不开long long见祖宗
const ll maxn=2e5;
ll n,ans,a[maxn],f[maxn];
int main(){
    scanf("%lld",&n);
    for(ll i=1;i<=n;i++){
        scanf("%lld",&a[i]);
        ans-=a[i];
    }
    for(ll i=n;i>=1;i--)
        f[i]=max(a[i],f[i+1]-1);
    for(ll i=1;i<=n;i++){
        f[i]=max(f[i],f[i-1]);
        ans+=f[i];
    }
    printf("%lld\n",ans);
    return 0;
}//tjnlyy
```
