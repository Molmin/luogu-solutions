## 题目分析

题目还是很容易理解，而且题目数据中没有出现无解的情况。

这一题里面有很多 string 基础而有趣的技巧，很适合初学者来学习 string，熟练运用这些技巧，可以让代码更简洁。

这一题其实很水，于是我们先看思路和技巧：

## 思路 & 做法

1. **如何将两个字符串合并？**

	STL 的 string 可以 **直接用加号连接两个字符串**，例如
	```cpp
	string a="this test ",b="is so easy";
	string c=a+b;
	```
	这个情况下，字符串 c 的值为 "this test is so easy"，即字符串 a 与字符串 b 的连接。并且，单个 char 类型的字符也可以通过这种方式连上字符串。

2. **字符串能进行大小比较吗？**

	可以的。字符串的大小比较是 **针对于字典序来** 比较的，即两个字符串首位比较，首位相同比二位……一直到有字符不同或者字符串截止。

	同理，字符串也可以进行 max 和 min 以及 sort 的比较。这在很多地方有很大的用处，比如本题判断哪个字符串应该在前和字符串排序时可以用到。

3. **本题的做法？**

- 先输入，然后进行第一轮排序，将无序的字符串数组排序成从大到小的有序数组。接下来求长度，即 **每个答案字符串除去分隔符** 应该有的长度。

- 进行双重循环寻找答案。第一层循环从首到尾，第二从循环从当前的首扫到尾，如果这两个字符串 **没有被用过** 并且相加长度相同即视为可行解。

- 对于可行解，我一开始的程序是直接输出，但很可惜没有通过，于是我把所有的可行解用答案数组记录下来，最后再进行一次排序输出——竟然离谱的 [通过](https://www.luogu.com.cn/record/103721123) 了！！！~~虽然并不知道为什么我的写法求的不是最可行解而是要进行二次排序，但是能过就好。~~

4. **为什么第二次循环从头扫到尾？这样的话有没有可能影响之后的字符串寻找最小值从而影响答案最优性？**

	这个是不会的。我之前也因为这个问题想了很久。为什么不会呢？因为我们一开始的数组是从小到大排序的，最小的字符串找了它后面最小的字符串，即为最优。并且这不会影响到后面的字符串寻找，因为只有和自己长度一样的字符串才能选择一样的字符串作搭档，而那一个字符串又没有这一个字符串大，不会成为最优解。
    
   感觉这里讲的不是很清楚，可以看看样例或者自己写几个数据辅助理解，这道题对于字符串真的很友好了。
    
5. **有一点需要注意：**
	对于一个字符串，有两种构造方法，可能会导致不同结果。详见样例 2 和样例 3。这里面因为分隔符的大小不一样，导致了两种结果的产生。

## 喜闻乐见的代码环节：

没有写多少注释，自己感觉讲得很清楚了。

```cpp
#include <bits/stdc++.h>
using namespace std;
int n,len,cnt=0;
bool mark[10050];//mark 数组判重
string s[10050],ans[10050];//一个记录最开始的字符串，一个是答案数组
char d;
string make(string a,string b,char c){
	string aa=a+c+b,bb=b+c+a;
	return min(aa,bb);
}//将两个字符串连接并返回最小值
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>s[i];
		len+=s[i].size();
	}
	cin>>d;
	len=len*2/n;//求得长度
	sort(s+1,s+n+1);
	for(int i=1;i<=n;i++){
		if(mark[i])continue;//i被用过
		for(int j=i+1;j<=n;j++){
			if(mark[i])break;//在当前已经求出对于i的最优解了，退出循环
			if(mark[j])continue;//j被用过
			if(s[i].size()+s[j].size()==len){
				mark[i]=true;
				mark[j]=true;//标记
				ans[++cnt]=make(s[i],s[j],d);
			}
		}
	}
	sort(ans+1,ans+cnt+1);//答案数组排序
	for(int i=1;i<=cnt;i++)cout<<ans[i]<<endl;
	return 0;
} 
```
