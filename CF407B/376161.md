定义一个房间“稳定”表示打上标记后此房间标记数为偶数。

手玩一下可以发现我们到了第 $i$ 个点时第 $1$ 个房间到第 $i-1$ 个房间肯定都是稳定的。

口胡证明：到达第 $i$ 个点肯定要使得第 $i-1$ 个点稳定，然后就可以归纳。

因此设 $f_{i,j}$ 表示从第 $i$ 个房间走到第 $j$ 个房间，且使得房间 $k$（$1\le k\le j$）都稳定的最小步数，初始所有房间都稳定。

若 $i=j$，那么分类讨论：

1. $p_i=i$：此时只需要走 $2$ 步，因此 $f_{i,j}=2$。
2. $p_i<i$：此时第一步会走到 $p_i$，那么我们需要从 $p_i$ 走到 $i-1$，下一步才能走到 $i$。因此 $f_{i,j}=1+f_{p_i,i-1}+1=f_{p_i,i-1}+2$。

若 $i<j$，此时我们需要先从 $i$ 走到 $j-1$，下一步 $j-1$ 走到 $j$，但是 $j$ 会走到 $p_j$，所以分类讨论：

1. $p_j=j$：此时再走 $1$ 步即可稳定。
2. $p_j<j$：此时需要先从 $p_j$ 走到 $j-1$，再从 $j-1$ 走到 $j$，需要走 $f_{p_j,j-1}+1$ 步。

为了实现方便，不妨设 $f_{i,i-1}=0$，那么有转移方程：

$$
f_{i,j}=f_{i,j-1}+f_{p_j,j-1}+2
$$

可以使用记忆化搜索实现，时间复杂度 $O(n^2)$。

```cpp
#include <iostream>

using namespace std;

const int kN = 1001;
const int kM = 1e9 + 7;

int n, p[kN], f[kN][kN];

int S(int i, int j) {
  if (f[i][j]) {
    return f[i][j];
  }
  if (i > j) {
    return 0;
  }
  return f[i][j] = (S(i, j - 1) + S(p[j], j - 1) + 2) % kM;
}

int main() {
  cin >> n;
  for (int i = 1; i <= n; ++i) {
    cin >> p[i];
  }
  cout << S(1, n);
  return 0;
}
```