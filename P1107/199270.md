就我一个人被标签上的贪心骗了吗

~~自己走的路含着泪也要走完~~

### 思路

#### 贪心+递归

每次都挑柿子最多的树(在上方的柿子不算)

一开始先到柿子最多的树上(同时记录第二多的数量)如所在高度没有柿子就向下爬一米,在这棵树还剩的柿子比第二多的多时,就一直在这棵树向下爬,直到比第二多的少时,为这个时候这棵树下面的柿子可能不是最多的了,这里的第二多其实包括了第二多的树上高度大于现在高度的柿子,就是不算的,所以要在其他树高度为现在的高度-delta(因为跳过去高度会下降delta,意,高度-delta要大于0不然只能不跳)以下的柿子数量,如果找到的的最大值大于现在这棵树的跳到那一棵树上去(之后第一多的值为那棵树的数量,第二多为之前找到的第二多),如果小于就还在这一棵树上,直到高度为0,输出吃到的种数结束

取第二大的值的方法:if(a>最大值) 第二大的值=最大值,最大值=a

这里的思路没有用优化 ~~(朴素的思路)~~

复杂度 _O_ (n$^2$*h) 50分

贪心代码

```cpp
void tx(int now,int high,int maxn,int maxn2,int tot)//now为现在所在的树,high为现在所在高度,maxn为现在所在树剩余的柿子(即最多),maxn2为第二多,tot为总共吃了多少柿子
{
	if(high<0||now==0) return;//防超界
	if(high==0)//高度为0
	{
		cout<<tot;//输出
		exit(0);//直接退出整个程序
	}
    /*tr[i][high]为树i在高度为high有几个柿子*/
	if(tr[now][high]==0) return tx(now,high-1,maxn,maxn2,tot);//没有,向下爬
	maxn-=tr[now][high];//这棵树这个高度的柿子被吃掉了
	tot+=tr[now][high];//吃的柿子数量加上去
	if(maxn<maxn2&&high-del>0)//如果出现思路中提到的那种情况,即这棵树不一定是柿子最多的了,且要能向下跳(够高)
	{
	    int s1=0,mm=0,mm2=0,mmc=0;//s1记录某一棵树的柿子,mm为最多的树的柿子树,mm2为第二多,mmc为最多的树的编号
		for(int i=1;i<=n;i++)
		{
			s1=0;
			for(int j=1;j<=high-del;j++)
			{
			    s1+=tr[i][j];//这棵树高度high-del以下所有的柿子(只有这些可以吃到)
			}
			if(s1>mm) mm2=mm,mm=s1,mmc=i;//mm取最大值,mm2第二大值,mmc保存最大值所在树的编号
		}
		if(mm>maxn&&mmc!=0)/*mmc!=0表示还有其他树*/ return tx(mmc,high-del,mm,mm2,tot);//另一棵树更多
		else return tx(now,high-1,maxn,maxn2,tot);//还是这棵树多
	}
	else//这棵树依然一定是最多的,或跳不了了
	{
		return tx(now,high-1,maxn,maxn2,tot);//向下爬一米
	}
}
```

### 优化
 
我们发现前面的代码其实有许多可以优化的地方

- 之前找柿子非常费时间,于是可以定义一个n1[i]保存第i棵树在现在高度下方的柿子数量,每次经过的高度如果这棵树有柿子那么n1[i]-=这个高度的柿子树,注意跳途中的高度也算,所以找跳到那一棵树时要先减掉跳的过程中错过的柿子,在判断最大值,如果不跳要回溯到减跳的过程中错过的柿子之前的值(可以先保存一个副本)//最重要的优化

- 前面思路中如果找了其他的树都比这棵少,本来maxn2的值是不变的因为把每棵树的柿子数量找一遍非常费时间,所以如果将maxn2赋值为mm(即找到的最大值),如果最大值就是这棵树,那么更新为找到的第二大的值//也非常重要

- scanf输入,虽然cin可能会过但明显慢了很多

下面这个优化建议不要(或再完善一下,防止一个高度有太多的柿子使数组爆炸,但是这一题不需要),去掉对时间复杂度影响较小:
 
- 前面减n1[i]时要从1~n找一遍~~非常~~花时间,所以定义一个h[i][j]表示高度i中第j个在这个高度有柿子的树的编号(如果一棵树有两个同一高度的柿子算作在h中保存在不同位置,就是这里可以优化) 

### 完整代码 

复杂度 略大于 _O_ (n$^2$) 

100分(514ms) //没有用第三个优化

```
#include<bits/stdc++.h>
using namespace std;
int tr[2010][3001]/*,h1[2010][5001]如果不用第三个优化不需要定义*/,n,h,del,m,m2,mc,n1[50001],n2[50001];//tr[i][j]存树i在高度j上有多少柿子,n,h,del题目定义,m,m2,mc,n1[],n2[]下面会用得到
void tx(int now,int high,int maxn,int maxn2,int tot)
{
	if(high<0||now==0) return;//防止超界
        /*
        这个是第三个优化的代码
	for(int p=1;p<=h1[high][0];p++)
	{
		n1[h1[high][p]]--;//这个高度的柿子所属的树的柿子总量减一,注意tr不要变,后面要用到(减掉这个高度所有柿子)
	}
	*/
        for(int p=1;p<=n;p++) n1[p]-=tr[p][high];//所有树减掉这个高度的柿子
	if(high==0)//高度为0,表示爬完了
	{
		cout<<tot;//输出
		exit(0);//直接结束整个程序
	}
	if(tr[now][high]==0) return tx(now,high-1,maxn,maxn2,tot);//这里没柿子,直接向下
	maxn-=tr[now][high];//这棵树这个高度的柿子吃掉了
	tot+=tr[now][high];//吃了的柿子数加上去
	if(maxn<maxn2&&high-del>0)//如果出现思路中提到的那种情况,即这棵树不一定是柿子最多的了,且要能向下跳(够高)
	{
	    int s1=0,mm=0,mm2=0,mmc=0;//s1记录某一棵树的柿子,mm为最多的树的柿子树,mm2为第二多,mmc为最多的树的编号
		for(int i=1;i<=n;i++)//在所有的树中找
		{
		    for(int j=high-1;j>=high-del+1;j--) n2[1]=n1[i],n1[i]-=tr[i][j];//减掉跳过程中的,并保存副本(如果不跳要回溯)
			s1=n1[i];//用于取最大值
			if(s1>mm) mm2=mm,mm=s1,mmc=i;//mm取最大值,mm2第二大值,mmc保存最大值所在树的编号
		}
		if(mm>maxn&&mmc!=0)//有更多的树,mmc!=0表示还有其他树
		{
		 return tx(mmc,high-del,mm,mm2,tot);//另一棵树更多
	    }
		else //没有或跳不了了
		{
		if(mmc==now) mm=mm2;//如果最大是自己,用第二大(不然会出错)
		for(int i=1;i<=n;i++) n1[i]=n2[i];//回溯到选择跳之前的值 
		return tx(now,high-1,maxn,mm,tot);//还是这棵树多
	    }
	}
	else//这棵树依然一定是最多的,或跳不了了
	{
		return tx(now,high-1,maxn,maxn2,tot);//向下爬
	}
}
int main()
{
	scanf("%d%d%d",&n,&h,&del);//输入
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&n1[i]);//输入有几个
		if(n1[i]>m) m2=m,m=n1[i],mc=i;//m取最大值,m2第二大值,mc保存最大值所在树的编号
		for(int p=1;p<=n1[i];p++)
		{
			int hi;//用于输入
			scanf("%d",&hi);
			tr[i][hi]++;//这棵树这个高度的柿子加1
			/*
			h1[hi][++h1[hi][0]]=i;//这个高度柿子加一(同一棵树有多个算作不同,但保存的编号一样)
			如果不用第三个优化不需要这一句*/
		}
	}
	tx(mc,h,m,m2,0);//从最多的树开始
	return 0;//输出在函数里面
}
```
