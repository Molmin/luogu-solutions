## UVA12099 题解

**申明**

令本书架三层高度分别为 $x_1,x_2,x_3$，且 $x_1,x_2,x_3\in A$。

对于 $\forall q\in A,q\neq0$。

------------

**暴力算法**

$O(3^n)$ 枚举每本书放入那个书架，并刷新答案。

可以通过部分数据。

`DFS` 时记录信息：

1. 当前第几本书。

2. 第一层书架厚度和。

3. 第一层书架当前“最高书”。

4. 第二层书架厚度和。

5. 第二层书架当前“最高书”。

6. 第三层书架当前“最高书”。



------------

**优化算法**


该问题为多阶段决策问题。

在搜索基础上加上记忆化，即重叠子问题设计状态。

$dp_{p,i,j,one,two,three}$ 表示放了前 $p$ 本书，第一个书架宽度为 $i$，最高书为 $one$；第二个书架宽度为 $j$，最高书为 $two$，第三个书架最高书为 $three$。

此时，我们会发现有大量的无用状态，子问题几乎不重叠。同时，空间无法承受。

考虑精简状态。每一本书的宽度信息最终都是需要“累加”的，是一定需要记录的。

而高度却不一定，只有最高的那一本才是“有效信息”。尝试把书的高度这三个维度优化。

进一步分析，发现需要记录当前最高书的根本原因在于：在某一个书架放一本书时，不知道当前这本书的加入是否会增加该层书架高度。

可以调整决策的顺序，把所有书从高到矮决策。

将书本按高度从大到小排序后一本本放入书架：

只有当放该书架第一本书时会更新高度值，其它都不会更新，因为后摆的书一定比先摆的书来得矮。

这样只需要知道当层书架宽度信息，就可以推知某本书的加入是否会增加该层书架的高度了。

宽度为 $0$，就是第一本书，宽度就会增加，否则宽度就不会增加。

结构体与 `sort` 排序即可。

现在我们重新考虑状态设计。

我们不妨令最高的一本书放的书架为第一层。

则 $dp_{p,i,j}$ 表示按从大到小顺序放了前 $p$ 本书），此时第二层书架宽度为 $i$，第三层书架宽度为 $j$ 时，二、三层书架高度和的最小值。

状态数很精简了，$70\times (70\times 30)\times (70\times 30)=70^3\times 30^2$，约等于$3\times 10^8$，本题时限三秒，这样的时间可以承受。但空间显然不行。

考虑对其进行滚动数组优化即可、

放完前 $p$ 本书的情况只和放完前 $p-1$ 本书的情况有关，因此考虑使用滚动数组滚掉$p$ 这一维。

此时状态设计完毕，可以开始转移、

考虑在放第 $i$ 本书（高度为 $a_i.h$，宽度为 $a_i.w$）时的情况，分三类讨论。

1. 放在第一层。

不改变任何状态值，不需要做任何事情。

2. 放在第二层。

如果这是第二层的非第一本书：

$$dp_{j,k}=\min(dp_{j,k},dp_{j-a_i.w,k})$$

如果这是第二层的第一本书：

$$dp_{j,k}=\min(dp_{j,k},dp_{0,k}+a_{i}.h)$$

3. 放在第三层。

如果这是第三层的非第一本书：

$$dp_{j,k}=\min(dp_{j,k},dp_{j,k-a_i.w})$$

如果这是第三层的第一本书：

$$dp_{j,k}=\min(dp_{j,k},dp_{j,0}+a_{i}.h)$$

此时我们需要注意，因为有滚动数组优化，故若先更新该行前面的值，后面再更新该行的其他值会利用该行前面更新的值，而不是该行前一行的值。

故 $j$ 与 $k$ 逆序枚举。

接下来我们考虑细节处理。

$dp_{0,0}=0$，其余为 $∞$。

考虑最终答案。

所有书本宽度之和为 $tmp$ 可以预处理得到。

再计算 $h_i\times w_i$。

$$ans=\min(ans,(dp_{i,j}+a_{i}.h)\times max(max(i,j),tmp-i-j))$$

时间复杂度 $O(n^3\times w^2)$。

空间复杂度 $O(n^2\times w^2)$。

可以通过本题所有测试数据。

注意多组测试数据。



------------


**问题的总结与反思**

动态规划，尤其在背包动规的时候，对物品决策顺序进行调整，可以达到优化状态数的目的。同时分类讨论也是动态规划中重要的策略之一。



------------

**代码**

```
#include<bits/stdc++.h>
using namespace std;
int r,dp[2200][2200];
struct node
{
    int h,w;
};
node a[2200];
bool cmp(node a,node b)
{
	return a.h>b.h;
}
int main()
{
	scanf("%d",&r);
	while(r--)
	{
		int n=0,m=0,k=0,s=0,t=0;
	    scanf("%d",&n);
	    memset(a,0,sizeof(a));
 	   	for(int i=1;i<=n;i++)
    	{
        	scanf("%d%d",&a[i].h,&a[i].w);
        	t+=a[i].w;
	    }
	    sort(a+1,a+1+n,cmp);
	    memset(dp,0x3f,sizeof(dp));
	    dp[0][0]=0;
	    for(int i=2;i<=n;i++)
	        for(int j=t;j>=0;j--)
	        	for(int k=t;k>=0;k--)
	        	{
	            	if(j>a[i].w) dp[j][k]=min(dp[j][k],dp[j-a[i].w][k]);
	            	if(j==a[i].w) dp[j][k]=min(dp[j][k],dp[0][k]+a[i].h);
	            	if(k>a[i].w) dp[j][k]=min(dp[j][k],dp[j][k-a[i].w]);
	            	if(k==a[i].w) dp[j][k]=min(dp[j][k],dp[j][0]+a[i].h);
	        	}
	    s=0x3f3f3f3f;
	    for(int i=t;i>0;i--)
	    	for(int j=t;j>0;j--)
	    		if(dp[i][j]<=600) 
					s=min(s,(dp[i][j]+a[1].h)*max(max(i,j),t-i-j));
	   	printf("%d\n",s);
	}
	return 0;
}
```



------------

**Up to date**

$2022/7/7$ 更新了 $\LaTeX$。

$2022/11/28$ 更新了问题的总结与反思并修改了文章分类。