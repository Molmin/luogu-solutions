## Part I. 题意简述

就是任意在一堆数里面选，每次可以跳到距离与你选的那个数相同的那些点，问你最快到达某个点要多久。

## Part II. 思考过程

其实自己卡了很久。这里就提供一个思考方向。

第一步，观察数据范围，能更容易入手，那么可以发现时间复杂度大概是 $O(T \times N) = O(10^9)$ （可能有点不严谨，建议请留个言吧）。并且考虑到输入需要输入 $n+2$ 个数，我们需要使用 $O(n)$ 算法通过此题。


我们第二步，思考一个问题，为什么题目会那么笃定地说一定能到达终点？

那就应该只有一个数喜欢的时候也可以到终点对吧。

考虑以下两张图。

第一个是样例的第 $4$ 组数据，一开始并没有样例解释。

尝试自己推一下吧。其实疑惑的地方就是这里，因为你不知道怎么走。

解决这种题目，实在想不出时，可以考虑使用几何画板等工具画一画。

尝试一个数喜欢是不是能到终点。

首先在起点作一个半径是 $15$ 的圆。然后也在终点作一个半径是 $15$ 的圆，因为我们要试着找到一个最短的路，最短的路径应该在圆交点处产生。找到交点了！一看，跟样例解释一样。中途点都是 $(5,10 \sqrt{2})$。

![](https://cdn.luogu.com.cn/upload/image_hosting/kbwx3mjf.png)

因此，只要两个圆（分别以起点终点为圆心）相交或相切，那么两步即可到达。

第二个例子，两圆相离了。转个角度一想，那跳几下（跳几下，使起点位置发生改变，起点的圆也顺着改变位置）就能让两圆相切或相离了呀！

有颜色的线段是跳跃的路径。

![](https://cdn.luogu.com.cn/upload/image_hosting/jmhi4jd7.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/bhu4r6vn.png)

如果想样例第二组测试数据那样呢？那就直接橫跳呀，因为直线距离最短！

## Part III. 代码

讲了好多，觉得有点啰嗦。看图一边理解吧。

```cpp
#include <iostream>
#include <cstdio>
using namespace std;
int t,n,a[100001],k,ak,tmp,ans;
int main()
{
	scanf("%d",&t);
	while (t--)
	{
		scanf("%d%d",&n,&k);
		ans=2147483647; //把ans置为最大值
		for (int i=1;i<=n;i++)  //当时不知道拿最大的跳就行，只知道要O(n)做法所以没去管
		{
			scanf("%d",&a[i]);
			tmp=0;
			ak=k;
			if (ak%a[i]==0) //一直横着跳就好
			{
				tmp=(ak/a[i]);
				ak=0;
			}
			else
			{
				if (ak>2*a[i])
				{
					tmp+=(ak-2*a[i])/a[i]; //起点位置变化，步数也要加
					ak-=tmp*a[i];          //起点与终点的横坐标之差
					if (ak>2*a[i]) ak-=a[i],tmp++; //没到呢，还要再走，要让圆相交
				}
				if (ak) tmp+=2; //加了个if以防万一，具体是还没跳完呢，斜着跳要两步
			}
			ans=min(tmp,ans);  //取最小值
		}
		printf("%d\n",ans);
	}
}
```

### At last, thanks for watching~