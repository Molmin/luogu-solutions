# 题意

给定$n$个物品，装进一个容量为$k$的背包，每个物品的价值为$1$，重量为$c[i]$。

求一种选物品的方案，要求所获得的价值最大（可以不装满背包），要求输出选的物品的编号（任意顺序，本题```SPJ```）

### 输入格式 

第一行两个整数$n$，$k$。

第二行$n$个整数，表示每个物品的重量

### 输出格式

输出共两行。

第一行为所选的物品数量。

第二行为所选的物品的编号（任意排列，本题```Special Judge```） 

---

# 题解

直接按照题意$dp$即可（$01$背包）

记录路径的话用一个```bool```型数组```id[i][j]```来记录状态，最后逆序转移状态输出即可

详情见代码

--- 

# 代码 

```cpp
#include<stdio.h>
int n,k,c[110],f[10010]; //价值就是1，不用另开数组了 
bool id[110][10010]; //保存选的物品 
int main()
{
	scanf("%d%d",&n,&k);
	for(register int i=1;i<=n;++i) scanf("%d",&c[i]);
	for(register int i=1;i<=n;++i)
	{
		for(register int j=k;j>=c[i];--j) 
		{
			if(f[j-c[i]]>=f[j]) //等同于 f[j-c[i]]+w[i]>f[j] -> f[j-c[i]]+1>f[j] -> f[j-c[i]]>=f[j]
			{
				f[j]=f[j-c[i]]+1; //等同于 f[j]=f[j-c[i]]+w[i] 
				id[i][j]=true; //记录路径 
			}
		}
	}
	printf("%d\n",f[k]); //输出物品数 
	int x=n,y=k; //赋初始值 
	while(x>0&&y>0)
	{
		if(id[x][y]) //如果选了 
		{
			printf("%d ",x); //输出编号 
			y-=c[x]; //转移到上一个状态 
		}
		--x; //转移到选x-1个物品的情况 
	}
	return 0;
}
```