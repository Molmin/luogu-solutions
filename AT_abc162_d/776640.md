前传：某天早上这道题被放进了我们的比赛里，我赛时只想到了暴力枚举三个数的算法，然而由于老师配置的数据太弱，我的代码居然过了……然而下午老师重测了一遍，100分秒变50分……

### 题意简述
给你一个长度为 $N$ 的、由 `R`，`G`，`B` 三个字母组成的字符串 $S$，求满足如下要求的三元组 $(i,j,k)$（$1 \le i < j < k \le N$）的个数：
- $S_i \neq S_j$ , $S_j \neq S_k $ , $S_i \neq S_k$
- $j-i \neq k-j$

数据范围是 $ 1\ \leq\ N\ \leq\ 4000 $。

### 思路分析
一开始大家一定会和我一样想到暴力枚举三个数的做法（时间复杂度为 $O(n^3)$），但显然这个算法会超时得让你等到花都谢了。所以我们需要优化我们的暴力。    
问题就出在这里：该如何优化呢？     
我们可以尝试忽略第二个条件，只求满足第一个条件的三元组的数量，再减去满足第一个条件而不满足第二个条件的三元组的数量，就是我们的答案。      
设三个字母出现的次数为 $r$，$g$，$b$，不难看出满足第一个条件的三元组的数量是 $r \times g \times b$。     
那么如何求满足第一个条件而不满足第二个条件的三元组（即在满足第一个条件的情况下，还满足 $j-i = k-j$）的数量呢？    
我们可以枚举 $k$ 和 $k - j$，继而可以求出 $j$ 和 $i$。接着我们判断这三个位置的字母是否互不相同，如果是，那么这个三元组就是满足第一个条件而不满足第二个条件的。    
这个算法只需要用到枚举 $k$ 和 $k - j$ 这两个变量的双重循环（比最开始的少了一层），时间复杂度为 $O(n^2)$，可以通过。   

### code展示
码风和大家可能有点不同，做了点解释，希望大家能看懂。
```cpp
#include<stdio.h>
int n;long long ans,sum1,sum2,sum3;char s[4005];
int main()
{
    scanf("%d%s",&n,s+1);//s+1为s数组的地址的起始位置往后一个位置，即输入的第一个字符会存进s[1]而不是s[0]中
    for(int i=1;i<=n;i++)//上文中的k
    {
        if(s[i]=='R') sum1++;
        if(s[i]=='G') sum2++;
        if(s[i]=='B') sum3++;
        for(int j=1;i-j*2>=1/*j为上文中的k-j*/;j++) if(s[i]^s[i-j]&&s[i-j]^s[i-2*j]&&s[i]^s[i-2*j]) ans--;
        //如果两个数不相等，那么这两个数异或的结果将大于0，即为真
    }
    printf("%lld",ans+sum1*sum2*sum3);
}
```

