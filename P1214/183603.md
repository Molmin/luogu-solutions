## 枚举即可

------------

**1.枚举所有双平方数**

**2.记录下所有双平方数**

**3.从小到大进行搜索（便可不用排序）**

**--如果下一项比之前的小，便不符合条件，直接跳过**

**从第二项开始，判断如果不满足等差数列，直接跳过**

**否则判断如果项数刚好等于等差数列的长度且为等差数列（条件满足）：直接输出即可（起点，公差）**

------------

**question：题目中要求“这些行应该先按b排序再按a排序”，这应该怎么办呢？**

**仔细观察，发现一开始便从小开始循环，故不用再排序了，安心输出就好**

------------

**细节：题目中“如果没有找到数列,输出NONE”可千万不要忘了！！！**

**具体方法：有输出，则输出后标记一下（标记为1即可），最后循环完后判断，如果为0才需要输出NONE，否则就直接结束咯！**

------------

## 代码：
```

#include<iostream>
using namespace std;
const int MAX = 250 * 250 * 2 + 1;//数组开的最大 
bool f[MAX] = {0},ok = 0;int num[MAX]; 
int main()
{
    int n,m,cnt=0,k;
	cin>>n>>m;
	for (int i = 0;i <= m;i++)
		for (int j = 0;j <= m;j++) f[i * i + j * j] = 1;//枚举所有双平方数 
	for (int i = 0;i <= MAX;i++)
		if (f[i]) num[++cnt] = i;//记录下双平方数
	for (int i = 1;i < num[cnt];i++)//从小到大进行搜索 
	{
		for(int j = 1;j < cnt - 1;j++)
		{
			if (num[j] + (n - 1) * i > num[cnt]) break;//如果下一项比之前的小，便不符合条件，直接跳过 
			for (k = 2;k <= n;k++)//k直接从2开始，第二项 
		    	if (!f[num[j] + (k - 1) * i]) break;//如果不满足等差数列，直接跳过 
		    if (k == n + 1 && f[num[j] + (n - 1) * i])//如果k刚好等于等差数列的长度且为等差数列 
			{
				cout<<num[j]<<" "<<i<<endl;//输出答案(前面已经从小的开始循环，故不用考虑顺序了) 
				ok = 1;//标记有解 
			}
		}	
	} 
	if (!ok) cout<<"NONE"<<endl;//无解的输出 
	return 0;
}
```
