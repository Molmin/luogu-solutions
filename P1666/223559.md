### 解题思路：

先把这玩意搬到字典树上去，然后考虑选择的限制。

容易发现，一旦选择了某一个字符串，所有一这个字符串为前缀的字符串和所有的这个字符串的前缀都不能选，也就是这个字符串的子树和到根节点的路径上的所有点都不能选。

那么就考虑一个在字典树上的树形 $\text{DP}$，设 $f_{i}$ 表示选择了 $i$ 子树中的某一个节点的方案数，对于一个非关键节点，直接往下继承，否则有 $f_{i}=\prod f_{son}+1$，表示从自己的子节点中任意选取或者是全都不选，只选择自己。实现的时候可以将多余的边省去，就直接让每一个节点都是关键节点，方便一点。

注意最后要减去只选择虚根节点的贡献 $1$。

复杂度 $O(n)$。

---
另一种做法复杂度劣一些，但是代码不用那么复杂。

设 $f_i$ 表示考虑前 $i$ 个字符串并且强制选第 $i$ 个的方案数，但是直接这样做的话会导致在选取了一个之后其它的内容之间是否有冲突无法被考虑。

于是就想到将所有的字符串按照字典序排序，这样就做到了无冲突的一定是一个前缀，也就是若 $j<k$ 无冲突，任意 $i<j$ 与 $k$ 无冲突。

这种方法要注意最后加上空集的贡献 $1$。

---
还有开 $\text{long long}$，最大可能方案为 $2^{50}$，即任意两者都没有冲突。

---
### 代码：