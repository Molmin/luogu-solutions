这种场上一人没过的题也是紫……难以理解。

首先考虑怎么去重。有一个比较直观的想法是，如果连续进行了两次操作 B，后续肯定不会再进行操作 A。因为连续两次操作 B 跟一个操作 A，相当于先操作 A 再操作 B 并且后者更优。并且有意义的操作 A 最多 $O(\log a)$ 个，因此实际上这个操作序列在进行两个操作 B 之前并不长。

可是发现这个去不了重（$n=1$ 很容易就 hack 掉了），考场上就没有往这边想。实际上这个比较重要。

假设我们进行了 $p$ 次操作 A，在第 $i-1$ 到第 $i$ 次操作 A 之间进行了 $a_i$ 次操作 B（$a_i \in \{0,1\}$），容易将序列 $a$ 表示成一个二进制数的形式，记作 $s$。在第 $i-1$ 次到第 $i$ 次操作 A 之间的操作 B 相当于使原数减去 $2^{p-i+1}$。那么总共进行的操作次数便为 $p+\sum a$。

现在还剩下若干次操作 B，这个并不好描述。但是注意到影响是全局的，差分数组不会变化，那么可以用最小的数以及差分数组来表示不同的序列。将序列按差分数组分类，算不重复的最小的数这一元素的个数。

但是 $\sum a$ 的选取依然很多。实际上因为 $p$ 次操作 A 的原因，记原序列中 $a_i \bmod 2^p = b_i$，若 $b_i < s$ 则 $a_i' = \lfloor \frac{a_i}{2^p} \rfloor -1$，否则 $a_i' = \lfloor \frac{a_i}{2^p} \rfloor$，那么将 $b_i$ 全部弄出来排序，会发生减一的是一个前缀，于是总共只有 $O(n \log a)$ 种方案。

当然 $s \in [b_i,b_{i+1})$ 有很多种选区方案，我们需要 $\sum a$ 最小的那个，这个求起来很容易。实现可以随便写，因为 $n$ 太小（比如写个 `map<vector<LL>,vector<pair<LL,LL>>>` 什么的完全没问题）。

[评测链接](https://atcoder.jp/contests/arc086/submissions/36469791)。