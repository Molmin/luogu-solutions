### 前言

赛时打了个迷惑复杂度的做法，把我自己迷惑了。

胡一个做法。

---
### 思路

看到时限 $10s$，数据范围 $10^5$ 级别，直接考虑根号做法。

设阈值为 $T$。

首先，$d>T$ 的次数为 $O({n\over T})$ 次，直接暴力往后跳就好了。

再者，$d\le T$ 的，如果每次都保证精力有减少，则次数为 $O(T)$ 次。

可以考虑 binary search 找到下一次精力减少的位置。

似乎是对的？

> 如果没有任何一摞砖被搬完，小 E 就会停止工作。

这个东西并查集维护一下就好了。

为了平衡复杂度你可以考虑值域分块，块长 $\sqrt n$。

$O(T^2+\sqrt n)$ 修改，$O({n\over T}+T\log n)$ 查询。

取 $T=n^{\frac13}$，单次复杂度即为 $O(n^{\frac23})$。

这样就可以过题了。

---

似乎可以做到 $O(n\sqrt{n\alpha(n)})$。

就是利用并查集特性，一共 $O(nT)$ 个元素，再开一组并查集就好了，可以把单次修改操作复杂度均摊成 $O(T\alpha(n)+\sqrt n)$。

然后查询也可以优化，即 binary search 的部分也可以平衡掉，查询复杂度 $O({n\over T}+T\alpha(n))$。

于是取 $T=\sqrt{n\over\alpha(n)}$ 即可。

实际跑起来未见得更快很多。

感觉应该有更好想复杂度也更优的做法。
