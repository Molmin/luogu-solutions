
既然每个点都要配对，把问题看成如下的多阶段决策过程：先确定 $P_0$ 和谁配对， 然后是 $P_1$ ，接下来是 $P_2$ ,……，最后是 $P_n-1$ .

按照前面的思路，设 $d(i)$ 表示把前 i 个点两两配对的最小距离和，然后考虑第 i 个点的决策——它和谁配对呢？假设它和点 j 配对( $j<i$ )，那么接下来的问题应是“把前 i-1 个点中除了 j 之外的其他点两两配对”，它显然无法用任何一 个 d 值来刻画——此处的状态定义无法体现出“除了一些点之外”这样的限制。 

当发现状态无法转移后，常见的方法是增加维度，即增加新的因素，更细致地描述状态。既然刚才提到了“除了某些元素之外”，把它作为状态的一部分，设 $d(i,S)$ 表示把 前 i 个点中，位于集合 S 中的元素两两配对的最小距离和，则状态转移方程为：
	$d(i,S) = min(dist(P_i,P_j)+d(i-1, S-{i}-{j})|j∈S)$


```cpp
//此处 Latex 无法正确显示，所以用代码框框一下
d(i,S) = min{dist(P_i,P_j)+d(i-1, S-{i}-{j})|j∈S}

```
    
其中， $dist(P_i,P_j)$ 表示点 $P_i$ 和 $P_j$ 之间的距离。那么如何表示集合 S 呢？由于它要作为数组d中的第二维下标，所以需要用整数来表示集合，确切地说，是{0, 1, 2,…,n-1}的任意子集，使用二进来表示集合。

那么怎样用二进制表示集合呢？

可以用二进制数来表示，从右往左第 i 位表示 $a_i$ 是否在集合中，只用左移 i 位即可。当用二进制表示子集时，位运算中的按位与、或、异或对应着集合的交、并、对称差。

S & (1<<i) 不等于 0 就意味着 S 和 {j} 的交集不为空

上面的方程可以进一步简化。事实上，阶段 i 根本不用保存，它已经隐含在 S 中了—— S 中的最大元素就是 i .这样，可直接用 $d(S)$ 表示“把 S 中的元素两两配对的最小距离和”，则状态转移方程为：

$d(S)=min(dist(P_i,P_j)+d(S-{i}-{j})|j∈S, i=max(S))$

```cpp
//此处 Latex 无法正确显示，所以用代码框框一下
d(S)=min{dist(P_i,P_j)+d(S-{i}-{j})|j∈S, i=max{S}}

```


示例代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
int n;
double x[50],y[50];
double d[(1<<25)];	//dp数组，注意 double
double dist(double x1,double y1,double x2,double y2)
{
    return sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2));	//距离公式
}
int main()
{
    int Case=0;
    while(cin>>n&&n)
    {
        n*=2;
        for(int i=0;i<n;i++)
        {
            string t;	
            cin>>t;
            cin>>x[i]>>y[i];	//输入，此处 t 无用
        }
        for(int S=1;S<(1<<n);S++)	//最好位运算时打上括号
        {
            d[S]=2147483647;	//设为最大值
            int i,j;
            for(i=n-1;i>=0;i--)
            {
                if(S&(1<<i))	//找到最大的
                {
                    break;
                }
            }
            for(j=0;j<n;j++)
            {
                if(S&(1<<j))
                {
                    d[S]=min(d[S],dist(x[i],y[i],x[j],y[j])+d[S^(1<<i)^(1<<j)]);	//转移方程, ^的意义前面已经讲过
                }
            }
        }
       printf("Case %d: %.2lf\n",++Case,d[(1<<n)-1]);	//格式化输出，注意减一
    }
    return 0;
}
```


