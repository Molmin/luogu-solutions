这道题作为状压DP入门题，也是我第一个状压题，很具有纪念意义。。。

首先我们要理解并熟练运用位运算。

将数用十进制表示，实际运用的是二进制，通过0 1串来表示状态。因为长度为n 01串能表示的状态多达2^n-1,所以状压DP解决的是小范围的问题，时间复杂度一般为指数级别。

当然，也可以搜索，但是状压DP比较简洁，思路比较清晰（前提是理解的情况下）

如果各位同学是从紫书上看见的这个题，并想自己打出来，那么提醒一下，紫书上那5行代码有个错误，非常致命。

那就是：S要从1开始枚举。

想想也是很显然的。根据d数组的意义想一想就会明白。

这个题的思路随处可见，在这里也不赘述了。

不过需要提醒一下，如果从 1--n给各个点进行标号的话，需要进行一些修改，这些修改或许会加深对位运算的意义的理解。

下面是从1-n给个点进行标号的DP代码：

```
	for(int S = 1; S < (1<<n); S++){
			dp[S] = inf;
			int i = 0;
			for(i = 1; i <= n; i++)if(S & (1<<(i-1)))break;
			for(int j = i+1;j <= n; j++)if(S & (1<<(j-1)))
			//这里进行判断都要-1，因为将1左移n-1位移动到的才是第n位 
                //如果j是S中的元素，那么S的第j位应该是1，这样进行&运算得到的是1。
			dp[S] = min(dp[S], dis(i, j) + dp[S^(1<<(i-1))^(1<<(j-1))]);//如果要将01串中的某一位去除，就与在那一位的1进行^;	
		}
		printf("Case %d: ", ++kase);
		printf("%.2lf\n", dp[(1<<n)-1]);//1左移n位得到1后面n个0，-1后得到n个1，即全部配对完毕的状态。
```