首先在线性结构上搞是没有前途的，因为这些位运算不满足某些例如与 $\min/\max$ 的分配律等的好性质。于是我们换个角度，考虑枚举答案，看它们都可行不可行。

容易想到，可以枚举 $a_i$ 的部分看是否有 $i<j<k$ 使得 $a_j\operatorname{and}a_k$ 和 $a_i$ 或起来能包含当前答案。那么我们显然可以求出对于每个值，$a_i$ 部分包含它的最小 $i$ 和 $a_j\operatorname{and}a_k$ 包含它的最大 $j$，如果 $i<j$ 就可行。后面这个显然更强，但也是不难的，只需要看包含当前值的次大下标即可，这个高维前缀和即可轻松求出。

但是如果向上面这样枚举的话，最快也只能做到枚举子集的 $\mathrm O\!\left(3^d\right)$。但是我们注意到要求的是最大的符合要求的值，于是可以按照套路字典序贪心，从高到低位决定（这是本题的关键，也是我看了题解之后发现的东西）。因为容易发现若 $i$ 包含 $j$，则 $ok(i)\to ok(j)$。于是这样只需要判断 $\mathrm O(d)$ 个值是否可行，复杂度 $\mathrm O\!\left(2^dd\right)$。

然后发现这个字典序贪心的写法跟普通的倍增代替二分是一样的，尽管它并不满足普遍意义上的单调性。

**_[code](https://www.luogu.com.cn/paste/4ewnwzp0)_**