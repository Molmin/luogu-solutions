[题目传送门](https://www.luogu.com.cn/problem/UVA668)

### 题意：

将输入的 $N$ 个正整数拆分为若干个整数的 **加和** ，使得所有整数之 **积** 最大。

---

### 分析：

本题其实偏数学。

- 首先我们要知道，每个大于 $4$ 的数拆分为多个正整数之和，再将这些拆分出的数相乘后，他们的积 **一定** 大于原数。

- 其次，将一个正整数拆分为多个正整数后，拆分出的每个数都比原数小。

因而，我们拆分时，要 **优先选择更小** 的数。

但注意：$0$、$1$ 在被拆分出来后不仅对结果增大没有帮助，还会产生副作用。因而，我们选数时从 $2$ 开始。

**结论：选择的数是从** $2$ **开始，公差为** $1$ **的等差数列中的数。**

---

但注意，**并不是所有数** 都可以刚好拆分为前文所说的等差数列，因此，我们还要将剩余部分拆为若干个 $1$，把拆分出来的数字按 **从大到小** 的顺序加 $1$ 。

什么意思？举个例子：

- $16$ 拆分出来的等差数列为： $2$、$3$、$4$、$5$

- 剩余的数量为：$2$

- 因此，我们在等差数列中从大到小看 $2$  个，分别给 $5$ 和 $4$ 加 $1$。最终的数列为： $2$、$3$、$5$、$6$

---

但这时，我们发现一个问题：如果剩的值大于数列长度（也就是等于序列最后一个数），我们就要特判了。

比如，当这个整数为 $19$ 时：

- 拆分出来的数为： $2$、$3$、$4$、$5$

- 剩余的部分为： $5$

- 而按刚才的方法分配后，序列为： $3$、$4$、$5$、$6$

- **这时仍然剩下：**$1$

所以我们要把它 **再放到最后** ，最终为： $3$、$4$、$5$、$7$

当然，我们 **无需** 再判断最后 **最后剩余部分** $>1$ 的情况，因为这时剩余部分就至少能再在数列中添加一个数了。

---

### 注意：

**_本题的输出格式要格外注意，行末不能有空格，除最后一行外每行换行两次，最后一行换行一次。_**

---

### 代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int ans[5000];//暂存答案的数组
int main()
{
	int t,xb;
	cin>>t;
	for(int i=1;i<=t;i++)
	{
		xb=0;//下标归零
		int n;
		cin>>n;
		for(int j=2;j<=n;j++)//构造等差数列
		{
			ans[xb]=j;
			n-=j;
			xb++;
		}
		int pl=xb-1;
		while(n>0)//处理多余部分
		{
			if(pl==-1)//特判
			{
				ans[xb-1]++;
				break;
			}
			ans[pl]++;
			pl--;
			n--;
		}
		for(int k=0;k<=xb-2;k++)
		{
			cout<<ans[k]<<" ";
		}
		cout<<ans[xb-1];//最后一个单独输出，避免多余空格。
		cout<<"\n";
		if(i!=t)//判断是否为最后一行
			cout<<"\n";
	}
	return 0;
}
```
