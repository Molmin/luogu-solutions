#### 题目大意：
  给定一个整数 $N$ , 将其表示为 $a_1 + a_2 + a_3 + ... +a_k$ 的形式。并要求 $a_1\times  a_2\times  a_3\times ... \times a_k$ 的积最大。输出 $a_1$ 到 $a_k$ 的值。
  

------------
#### 解题思路：
这道题显然不是暴力出奇迹。当 $N = 1000$ 
时，暴力算法一定会超时。我们应该想出一种更加普遍的规律来求解。那么，**数学证明** 就派上用场了。

首先，将 $N$ 分解为 $N = a_1 + a_2 + a_3 + ... + a_k$ , 可以推导出这么一些规律：

-  $a_1 > 1$ : 如果 $a_1 = 1 $ , 那么将 $a_1$ 加到 $a_k$ 上，必然使得到的这个乘积大于原来的乘积。

-  $2 \geqslant  a_i+_1 - a_i \geqslant 1$ : 因为如果出现 $>2$ 的情况，可以将 $(a_i+_1), (a_i)$ 改为 $(a_i+_1 - 1), (a_i +_ 1)$ , 使得到的乘积更大。

- 最多只有一个 $i$ ，使得 $(a_i+_1)-a[i]=2$ 。
我们用反证法来证明，假设 $i<j$ ，并且 $(a_i +_1)-a_i=2,(a_j+_1) - a_j=2$ ，那么将  $(a_i), (a_j+_1)$  替换成 $(a_i+_1),(a_j+_1-1)$ 将使得乘积更大。

- $a_1 \leqslant 3$ : 如果 $a_1\geqslant 4$ ，那么将$a_1,a_2$ 替换成 $2,a_1-1,a_2-1$ 将使乘积更大。

综上，本题目的做法就是求出以 $2$  起始的最大连续自然数序列之和 $sum$，使得 $sum$ 的值不超过输入数 $N$，然后分类讨论情况：

**情况1** ：若剩余值 $(n - sum)$ 等于 $w$，则最后输出序列为： $3, 4, ... ,w, w+2$ ， 即将原最大序列每项加 $1$ ，再将最后剩余的一个 $1$ 加到最后一项上。

**情况2** ：若剩余值 $(n - sum)$ 小于 $w$， 则从序列的最大项 $i$ 开始，从大到小依次将每项加 $1$ ，直到剩余值用完。

根据上面的分析，我们就可以通过模拟，写出一份代码啦~


### Code
```cpp
#include <iostream>
#include <cstdio>
using namespace std;
int a[1000], N;

int main() {
	cin >> N;
	for (int i = 1;i <= N; ++i) {
		int number;
		cin >> number;
		int sum = 0, l = 0, left;
        for (int i = 2;i <= number; ++i) {
            a[l++] = i;
            sum += i;
            if (sum > number) {
                sum -= i, l--, left = number - sum;
                break;
            }
        }
        for(int i = l - 1; left ; left--) {
			a[i]++;
            i--;
            if (i < 0) i = l - 1;
        }
        for (int i = 0;i < l - 1; ++i) {
			printf("%d ", a[i]);
			printf("%d", a[l - 1]);  
		}
	}
    return 0;
}
```
感谢观看~