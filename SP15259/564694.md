# 分析：


这是一道裸的 01 背包题目。

我们定义 $f(i,j)$ 为在背包空间为 $j$ 且只取前 $i$ 样物品时所能获得的最大价值。

因为一个物品要么选，要么不选，所以我们只考虑这两种情况。

当选第 $i$ 样物品时，先判断是否能装下。如果能，就需要腾出 $w_i$ 的空间给这样物品，最大价值即为 $f(i,j) = f(i - 1,j - w_i) + v_i$。

如果不选，那么最大价值就还是在空间不变的条件下取前 $i - 1$ 件物品的最大价值，即 $f(i,j) = f(i - 1,j)$。

所以 $f(i,j)$ 就为这两种情况的最大价值，状态转移方程即为 $f(i,j) = \max(f(i - 1,j - w_i) + v_i,f(i - 1,j))$（注意前者要先判断能不能装下）。

任何 dp 题都有边界，这题的边界即为 $f(0,i) = f(j,0) = 0(i \leq N)$（前者没有物品可装，后者没有足够的空间，所以最大价值都为 $0$）。

当然，我们可以发现，$f(i)$ 这一行的值只依赖于 $f(i - 1)$ 这一行，所以我们可以把二维压成一维。

当一轮循环结束进入下一轮循环时，此时 $f$ 存储的就是 $f(i - 1)$ 的值，所以状态转移方程为 $f(j) = \max(f(j - w_i) + v_i,f(j))$。

至于为什么要从后往前推，是因为如果从前往后推，前面的数会被 $f(i,j)$ 覆盖，而非我们需要的 $f(i - 1,j)$。

# 代码:
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 1e5 + 9;
struct data{
	int w,v;
} a[N];
int t,m,f[N],ans;
int main(){
	scanf("%d%d", &n, &m);
	for(int i = 1;i <= n;i++)
		scanf("%d%d", &a[i].w , &a[i].v);
	for(int i = 1;i <= n;i++)
		for(int j = m;j >= 0;j--)
			if(j >= a[i].w)
				f[j] = max(f[j],f[j - a[i].w] + a[i].v);
	printf("%d", f[m]);
}
```
