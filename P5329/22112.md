为啥要 $O(n\log n)$ 呢。作为菜哭自己的魔芋，当然要先看部分分啦：

> 对于另外 $20\%$ 的数据，任意两个相邻字符 $a_i,a_{i+1}$ 不相等；

由于相邻的相同字符在去掉后得到的字符串是一样的，那么明显可以将相邻的相同字符合并，先处理完相邻字符都不一样的情况，最后在输出时一起输出

比如 `aaabb`，可以先将 `aaa` 和 `bb` 分别合并，得到 `ab`，排序可得答案为 `4 1`，再将刚被合并的相邻相同字符放进去，得到 `(4) 5 (1) 2 3`（其中打括号的为合并后的答案，无括号的即刚加入字符）

那么只需考虑相邻字符不同的情况惹。对于比较 $s_i,s_j(i<j)$，不需要考虑 $i$ 之前的字符（都相同），只需考虑 $a_i,a_{i+1}$ 的大小关系即可（$s_i$ 以 $a_{i+1}$ 开头，$s_j$ 以 $a_i$ 开头）

如此可以知道对于每一个 $s_i$，它与每一个 $s_j(i<j)$ 的大小关系都是一样的，那么可以将 $s_i$ 放在所有 $s_j(i<j)$ 的前/后边，只要从后往前维护，就可以链表维护惹（需要维护在链表前后插值）

空间时间复杂度都为 $O(n)$

Code：

```cpp
#include <cstdio>

const int N = 1001000;
int r[N], ps[N], len[N];
char s[N];
int n, t, L, R;

int main() {
	scanf("%d%s",&n,s+1);
	for(int i=1,j=1;i<=n;i=j) {
		while(j <= n and s[i] == s[j]) ++j;
		++t, len[t] = j-i, s[t] = s[i], ps[t] = i - 1;
	}
	L = R = t;
	for(int i=t-1;i;--i)
		if(s[i] > s[i+1]) r[i] = L, L = i;
		else r[R] = i, R = i;
	for(int nw=L;nw;nw=r[nw])
		for(int i=1;i<=len[nw];++i)
			printf("%d ",ps[nw]+i);
	return 0;
}
```