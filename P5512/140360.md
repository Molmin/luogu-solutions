## 题目

相信你来做这道题，肯定已经通过了[简化版](https://www.luogu.com.cn/problem/P1549)。


------------
## 解决问题

大题思路和简化版是一样的，但是要通过此题的数据，直接写搜索我也没办法通过，真的是太菜了。这里介绍一下打表的思路，加上各种奇奇怪怪的优化，能在可以接受的时间内得到答案（完全不加优化爆搜大概得等上几天？没试过，不敢尝试）。

### 优化一

预处理出对于任意两个数同时与它们两个相邻的数可能有哪些。条件就是：相邻的数相加不超过 $n^2$ 且和为素数、两两互不相同。用vector来存，$s_{i,j,k}$ 表示与 $i$ 和 $j$两个数相邻，第 $k+1$ 个可能的数。大大减少了枚举花费的时间。

### 优化二

改变一下搜索的顺序。先搜第一行和第一列，这样可以尽早排除一些第一行与第一列数字之和不是最优的情况（因为一旦不是最优就返回掉了）。

### 优化三

跟题解区的大佬学的设定下限。先预估一下可能搜到的情况中第一行与第一列之和最小可能是多少（只是可能，不一定会成立，这就是为什么这个优化并不具有普遍性）。

对于 $n$ 为奇数的时候，对于第一行和第一列的 $2n-1$ 个数，第一行选取 $2$ 到 $n$，第一列选取 $n+1$ 到 $2n-1$。求一下和（当然这里 $1$ 也算进来）：

$$\sum_{i=1}^{2n-1}i=n\times(2n-1)$$

所以对于 $n$ 为奇数的时候，如果某种方案的第一行与第一列数字之和可以达到这个下限，即 $n\times(2n-1)$，直接输出，结束程序。

对于 $n$ 为偶数的时候，对于第一行和第一列的 $2n-1$ 个数，第一行选取 $2$ 到 $n$，第一列选取 $n+1$ 到 $2n-1$。这样是否可行？答案是否定的。我们知道：偶 $+$ 偶 $=$ 偶；偶 $+$ 奇 $=$ 奇；奇 $+$ 奇 $=$ 偶。由于只存在 $2$ 一个偶素数，要使相邻两个数之和为素数，相邻两个数必须是一奇一偶（由于相同数不可以重复使用，故不存在 $1+1=2$ 这种情况）。由于第一行和第一列都由 $1$ 开头，第一行和第一列的数必须满足：奇（这个奇数当然固定为 $1$）、偶、奇、偶、奇……偶 。$n$ 为偶数，则最后第一行和第一列都要满足奇数数量和偶数数量相等。第一行的数字是 $1$ 到 $n$，满足条件。而第一列的数字是 $1$、$n+1$ 到 $2n-1$，奇数比偶数多两个，不满足条件。要使和最小，应当把 $2n-1$ 替换为 $2n$（可以看做是 $2n-1+1$），这样才能满足奇数和偶数数量相等。求出和便是：


$$\left(\sum_{i=1}^{2n-1}i\right)+1=n\times(2n-1)+1$$

所以对于 $n$ 为奇数的时候，如果某种方案的第一行与第一列数字之和可以达到这个下限，即 $n\times(2n-1)+1$，直接输出，结束程序。

### 优化四

建立在优化三的基础上，同样不具有普遍性。即按照最优情况选数。当 $n$ 为奇数，第一行的数只从 $2$ 到 $n$ 选取，第一列的数只从 $n+1$ 到 $2n-1$ 选取。当 $n$ 为偶数，第一行的数只从 $2$ 到 $n$ 选取，第一列选取的数都属于 $[n+1,2n]$，且不等于 $2n-1$。然而对于一些情况，这样并不能得到的解，比如 $n=9$。可以写两个程序，一个正常搜，一个按照这里说的搜，任何一个搜出来都是对的，搜出来就可以直接做到表里（要注意，在这种选数规则下，搜出解了可以使用，但如果输出 NO 也不证明无解，只是说在这种选数规则下无解）。正常搜的话 $1$ 到 $9$ 还可以，$10$ 的话有点受不了。但用了这种选数规则， $10$ 竟然秒出了。虽然这种优化不普遍，能较快地算出 $10$ 多少有点“碰运气”的成分，但也不失为一种得分策略。


------------

## 代码

给的代码不是最后提交的那一份，而是生成答案的代码（没有加优化四，但是很好加）。

```
#include<bits/stdc++.h>
using namespace std;
bool p[200]={0,0,1,1,0,1,0,1,0,0,0,1,0,1,0,0,0,1,0,1,0,0,0,1,0,0,0,0,0,1,0,1,0,0,0,0,0,1,0,0,
			0,1,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,1,0,1,0,0,0,0,0,1,0,0,0,1,0,1,0,0,0,0,0,1,
			0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,1,0,1,0,0,0,1,0,1,0,0,0,1,0,0,0,0,0,0,
			0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,1,0,0,
			0,0,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,1,0,1};//素数桶 
int tot=0;//累计第一行和第一列之和 
int minn;//当前所有情况中第一行和第一列之和最小值 
int n;
bool vis[110];
int a[15][15];
int Q[15][15];//盛放最终答案 
vector<int> s[101][101]; 
bool tag;//标记是否有解 
void dfs(int x,int y){
	if(tot>=minn)
		return;
	if(x==n+1){
		if(tot>=minn)
			return;
		minn=tot;
		for(int i=1;i<=n;i++)
			for(int j=1;j<=n;j++)
				Q[i][j]=a[i][j];
		tag=1;
		if(n%2==1){
			if(tot==n*(2*n-1)){
				for(int i=1;i<=n;i++){
					for(int j=1;j<=n;j++)
						cout<<Q[i][j]<<' ';
					cout<<endl;
				}
				exit(0);
			}
		}
		if(n%2==0){
			if(tot==n*(2*n-1)+1){
				for(int i=1;i<=n;i++){
					for(int j=1;j<=n;j++)
						cout<<Q[i][j]<<' ';
					cout<<endl;
				}
				exit(0);
			}
		}
	}
	if(x==1){
		for(int i=0;i<s[0][a[x][y-1]].size();i++){
			if(!vis[s[0][a[x][y-1]][i]]){
				vis[s[0][a[x][y-1]][i]]=1;
				a[x][y]=s[0][a[x][y-1]][i];
				tot+=s[0][a[x][y-1]][i];
				if(y==n)
					dfs(x+1,1);
				else
					dfs(x,y+1);
				vis[s[0][a[x][y-1]][i]]=0;
				tot-=s[0][a[x][y-1]][i];
			}
		}
	}
	if(y==1){
		for(int i=0;i<s[0][a[x-1][y]].size();i++){
			if(!vis[s[0][a[x-1][y]][i]]){
				vis[s[0][a[x-1][y]][i]]=1;
				a[x][y]=s[0][a[x-1][y]][i];
				tot+=s[0][a[x-1][y]][i];
				if(x==n)
					dfs(2,2);
				else 
					dfs(x+1,1);
				vis[s[0][a[x-1][y]][i]]=0;
				tot-=s[0][a[x-1][y]][i];
			}
		}
	}
	if(x!=1&&y!=1){
		for(int i=0;i<s[a[x-1][y]][a[x][y-1]].size();i++){
			if(!vis[s[a[x-1][y]][a[x][y-1]][i]]){
				vis[s[a[x-1][y]][a[x][y-1]][i]]=1;
				a[x][y]=s[a[x-1][y]][a[x][y-1]][i];
				if(y==n)
					dfs(x+1,2);
				else
					dfs(x,y+1);
				vis[s[a[x-1][y]][a[x][y-1]][i]]=0;
			}
		}
	}
}
int main(){
	cin>>n;
	for(int i1=0;i1<=n*n;i1++){
		for(int j1=0;j1<=n*n;j1++){
			for(int k1=1;k1<=n*n;k1++){
				if(k1==i1||k1==j1||i1==j1)
					continue;
				if((p[k1+i1]||i1==0)&&(p[k1+j1]||j1==0))
					s[i1][j1].push_back(k1);
			}
		}
	}
	tot=0;
	minn=999999;
	a[1][1]=1;
	memset(vis,0,sizeof(vis));
	vis[1]=1;
	tag=0;
	dfs(1,2);
	if(!tag){
		cout<<"NO"<<endl;
		return 0;
	}
	for(int i=1;i<=n;i++){
		cout<<"	";
		for(int j=1;j<=n;j++)
			cout<<Q[i][j]<<' ';
		cout<<endl;
	}
	return 0;
}
```










