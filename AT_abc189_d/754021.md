**难的一匹の动态规划！**

我们开一个 $dp$ 数组，用 $dp_{i,j}$ 表示前 $i+1$ 个位置上填了数后，值为 $j$ 的方案数。我们发现，在填第 $1$ 个数（位置 $0$）时，值为 $1$ 和值为 $0$ 的方案均为 $1$。

---

此后，如果是遇上 ```AND```，那么值为真的数量就是上一个值为真的数量。因为当前就必须填真，而原来的也必须填真，所以数量就还是原来为真的数量。用式子表示：

$$f_{i,1}=f_{i-1,1}$$

而值为假的数量呢？其实就是原来为真的数量加原来为假的数量乘二。因为原来是真，那么这里选假就可以变成假，有一种选择；原来是假，那这里选真选假都一样，有两种选择，乘二。用式子表示：

$$f_{i,0}=f_{i-1,1}+f_{i-1,0} \times 2$$

---

如果碰上 ```OR```，要想值为假，就必须两边都是假才行。那么值为假的方案数就等同于上一个假的方案数。用式子：

$$f_{i,0}=f_{i-1,0}$$

要使值为真，方案数就会是原来真的数量乘二加上原来假的数量。因为原来如果是真，那么这里不管选什么，答案不影响，所以乘二；原来如果是假，那为了让答案为真，所以只有填真一种选择。这里用式子来讲就是：

$$f_{i,1}=f_{i-1,0}+f_{i-1,1} \times 2$$

---

四种情况，四个式子都推完了，代码就不用多说了吧……

```cpp
#include<bits/stdc++.h>
using namespace std;
long long dp[65][5];
bool a[65];
int main(){
    int n;
    cin>>n;
    for(int i=1;i<=n;i++){
        string s;
        cin>>s;
        if(s=="AND") a[i]=true;
    }
    dp[0][0]=1;
    dp[0][1]=1;
    for(int i=1;i<=n;i++){
        if(a[i]){
            dp[i][1]=dp[i-1][1];
            dp[i][0]=dp[i-1][0]*2+dp[i-1][1];
        }else{
            dp[i][1]=dp[i-1][1]*2+dp[i-1][0];
            dp[i][0]=dp[i-1][0];
        }
    }
    cout<<dp[n][1]<<endl;
    return 0;//完结撒花！
}
```