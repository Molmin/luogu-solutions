[P6550 [COCI2010-2011#2] LUNAPARK](https://www.luogu.com.cn/problem/P6550)

这道题目是一道思维题，用到的知识点是国际象棋的棋盘，本片题解会着重讲解证明。

题面要求通过向上下左右移动的方式来，不重复地经过棋盘上一些格子的格子，使得它们的娱乐程度最大。

他的行动方式可以类比贪吃蛇，就是只能向上下左右移动，从左上角走到右下角。如果重复的走了某一个格子，也就是贪吃蛇撞到是自己的身体，是不可行的。

不难从猜测和题目中给出的样例发现：我们需要尽可能多的取覆盖因为只有这样我们才能够得到最大的娱乐程度。

证明很显然，在其他格子经过情况不变的情况下，由于所有的娱乐程度都是正整数，多覆盖这一个格子（严格上来说应该是偶数个格子），答案一定会更优。

那么，如果可以经过所有的格子，那就十全十美；如果有的格子一定无法经过，那我们就舍弃掉这些格子中总代价最小的那些格子。

我们现在就需要去看，有那些情况是可以经过所有的格子，那些不能。如果能，我们要怎么走；如果不能，我们又应该怎么走。

这种走棋盘的问题，我们一般会用**黑白染色**来解决（下面默认左上角起点为白色）。

假设我们对一个 $5 \times 5$ 棋盘进行黑白染色。

![](https://cdn.luogu.com.cn/upload/image_hosting/pmwp652u.png)

在这个棋盘之中，我们取其中的任何格子，我们会发现，无论往那个方向走，我们都会走到一个与当前格子颜色不同的格子上。也就是，黑色一定会走到白色；白色一定会走到黑色。

![](https://cdn.luogu.com.cn/upload/image_hosting/soogstjs.png)

数学证明：以左上角起点格子为 $(1,1)$ 右下角终点格子为 $(r,c)$ ，对整个棋盘进行标号。那么对与标号在 $(x,y)$ 的格子，我们根据 $(x+y) \bmod 2$ 的值进行染色，为 $0$ 的是一种颜色，为 $1$ 的是另一种颜色。

那么，对于 $(x,y)$ ，它可以移动到的格子至多有四个，分别是 $(x \pm 1,y)$ 和 $(x,y \pm 1)$ ，它们的染色情况，为 $(x+y \pm 1) \bmod 2 \ne (x+y) \bmod 2$ ，即移动后的格子和原格子颜色不同

那么如果我们把一种从起点到终点的路径上每一个点的染色情况标注出来，那么必然是：白黑白黑白黑……这种黑白交替的形式，那么我们的路径可能也就只和棋子的黑白数挂钩了。

当起点为白色，终点为白色时，我们的白色格子比黑色格子多一个的时候，才有可能经过所有的格子。当起点为白色，终点为黑色时，我们的白色格子和黑色格子数量相等的时候，才有可能走完所有的格子

我们探究情况的方式就可以用一一对应实现。

对于行或者列为偶数的情况，黑白格子能够一一对应，也就是黑色格子和白色格子的数量相同。

如果行和列均为奇数，以 $5 \times 5$ 为例，先讲除最后一行之外的格子一一对应（因为行数减一是偶数），然后对之后一行除了最后一个格子进行一一对应。那么，这种情况下，白色格子比黑色格子多出来了一个

![](https://cdn.luogu.com.cn/upload/image_hosting/mjbl6m9g.png)

那我们来考虑这些情况下终点的颜色。根据黑白染色的数学定义，当 $r+c\equiv1\pmod{2}$ ，也就是行和列一奇一偶的时候，终点为黑色——和黑白格子的数量刚好吻合！！！这种一情况下，我们时可以有办法覆盖所有格子的！！！

当 $r+c\equiv0\pmod{2}$ ，行和列奇偶性相同的时候，终点为白色，但我们又有两种情况：同为奇数时，白色格子多一个，和我们的需要吻合；但同为偶数的时候，黑色格子和白色格子一样，呃，好像不符合我们的期待。

综上所述，当行和列有一个为奇数的时候，我们可能有办法完全覆盖。但如果行和列均为偶数的时候，我们需要舍弃掉一些格子。

现在，我们需要考虑舍弃和构造。

当行和列有一个为奇数的时候，我们又要清楚我们的贪吃蛇——当贪吃蛇比较长的时候，我们会让他反复地左右走，那么这种情况的构造也就显然了：

![](https://cdn.luogu.com.cn/upload/image_hosting/8ta15ax6.png)
![](https://cdn.luogu.com.cn/upload/image_hosting/l60n99cg.png)

那么对于行和列均为偶数的情况呢？

根据之前的推理，我们起点和终点颜色相同，我们的白色格子会比黑色格子多一个，但实际情况确实数量相等，那我们就至少需要舍弃一个黑色格子。同时，我们一定不会舍弃白色的格子，因为这样我们就需要舍弃更多的黑色格子，会导致答案更劣。

根据贪心的思想，我们应该舍弃的时娱乐程度最小的那个黑色格子。

在不经过这个黑色格子的情况下，我们就要来思考构造了。

显然，我们的大致思路还是和其他的情况一样，去一行（列）一行（列）地扫。我们不妨来看行，那如果目前在扫的一行和我们不经过的那个点比较远，我们就是可以正常扫的。我们至少可以这样处理 $r-2$ 行，我们需要留一个空行来处理那个不能经过的格子。

![](https://cdn.luogu.com.cn/upload/image_hosting/r7wx9k4c.png)
![](https://cdn.luogu.com.cn/upload/image_hosting/hnexe2sa.png)

大致会达到这样的两种情况，我们也应该能够找到对应的解法。

![](https://cdn.luogu.com.cn/upload/image_hosting/jkeg4np9.png)
![](https://cdn.luogu.com.cn/upload/image_hosting/x4tcrh5f.png)

其实就是在 $2 \times c$ 的棋盘里面从左往右扫的时候，扫到了需要跳过的那个格子同列的格子时，我们多往右走一步即可

大致的思路就是这样，具体的细节在代码中慢慢实现。（请原谅我代码有点丑）

```cpp
#include <bits/stdc++.h>
using namespace std;
int Qread()
{
	int x=0;char ch=getchar();
	while(ch<'0'||ch>'9') ch=getchar();
	while(ch>='0'&&ch<='9')
	{
		x=(x<<3)+(x<<1)+(ch^48);
		ch=getchar();
	}
	return x;
}
int r,c,i,j,delr,delc,gl;
int a[1010][1010];
char ch;
int main()
{
	a[0][0]=2e9;
	r=Qread();c=Qread();
	for(i=1;i<=r;i++)
	for(j=1;j<=c;j++)
	{
		a[i][j]=Qread();
		if((i+j)%2==1&&a[delr][delc]>a[i][j]) delr=i,delc=j;//记录那个我们需要跳过的黑格子，因为起点为白同时行列和模2余0，所以我们要找行列和模2余1的
	}
	if(r%2==1)//行为奇数，按行扫
	{
		for(i=1;i<=r;i++)
		{
			if(i%2==1) ch='R';//判断应该向左还是向右
			else ch='L';
			for(j=1;j<c;j++)
				putchar(ch);
			if(i!=r) putchar('D');//除最后一行之外在扫描后需要向下一步
		}
	}
	else if(c%2==1)//列为奇数，按列扫，和按行扫同理
	{
		for(j=1;j<=c;j++)
		{
			if(j%2==1) ch='D';
			else ch='U';
			for(i=1;i<r;i++)
				putchar(ch);
			if(j!=c) putchar('R');
		}
	}
	else//行和列均为偶数的情况
	{
		gl=delr;
		if(gl%2==0) gl--;//找到需要特殊处理的那两行中考上的那一行，因为我们在上面处理的时候左上角的格子时白色的
		for(i=1;i<r;i++)//因为有两行被特殊处理了，所以少一行
		{
			if(i%2==1) ch='R';
			else ch='L';
			if(i==gl)
			{
				for(j=1;j<c;j++)//特殊的两行上下扫，需要去掉的格子额外往右移一下
				{
					if(j==delc) putchar(ch);
					if(j%2==1) putchar('D');
					else putchar('U');
					if(j!=c-1) putchar(ch);
				}
				if(c==delc) putchar(ch);
			}
			else
			{
				for(j=1;j<c;j++)
					putchar(ch);
			}
			if(i!=r-1) putchar('D');
		}
	}
   cout<<"防止你抄题解";
	return 0;
}
```
