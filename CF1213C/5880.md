稍微有点难度。

题意：求$\sum_{k=1}^{\left \lfloor \frac{n}{m} \right \rfloor}(km\ mod\ 10)$

蒟蒻啥都不会，只好“打表”$QAQ$

加的是个位数，可以发现，无论是$0-9$中的哪一个数，在至少10次之后结果都会循环。

由此可得一张表
```
   0 1 2 3 4 5 6 7 8 9
1  0 1 2 3 4 5 6 7 8 9
2  0 3 6 912 5 8111417
3  0 61218141016121824
4  0102020201020202030
5  0152025201520252035
6  0212233241526272829
7  0282634322028363442
8  0363238342036423844
9  0454045402540454045
```
最后答案$ans=\left \lfloor N/(M*10) \right \rfloor*a[0][M\%10]+a[(N\%(M*10))/M][M\%10]$
```cpp
#include<cctype>
#include<cstdio>
int Q,mod[10][10]={
	{0,45,40,45,40,25,40,45,40,45},
	{0,1,2,3,4,5,6,7,8,9},
	{0,3,6,9,12,5,8,11,14,17},
	{0,6,12,18,14,10,16,12,18,24},
	{0,10,20,20,20,10,20,20,20,30},
	{0,15,20,25,20,15,20,25,20,35},
	{0,21,22,33,24,15,26,27,28,39},
	{0,28,26,34,32,20,28,36,34,42},
	{0,36,32,38,34,20,36,42,38,44},
	{0,45,40,45,40,25,40,45,40,45},
};
long long N,M,ans;
template<class T>inline void read(T &m)
{
	m=0;
	char c=getchar();
	while(!isdigit(c))c=getchar();
	while(isdigit(c))m=(m<<3)+(m<<1)+(c&15),c=getchar();
}
int main()
{
	read(Q);
	while(Q--)
	{
		read(N),read(M);
		ans=((long long)(N/(M*10)))*mod[0][M%10];
		N%=(M*10);
		if(N>=M)ans+=mod[N/M][M%10];
		printf("%lld\n",ans);
	}
}
```