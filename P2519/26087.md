随便点的一道DP题，本来这题以前无数次想不出来，题解好像也看不懂，想的时候都打算放弃了

但是想着一定要死磕思维能力，最后居然还真的自己做出来了

果真是以前放弃得太轻易hhh

首先要确定一下题意，“有ai个人”我感觉也可以理解为>=ai个人

但是其实后来想一下，如果这样说得话就没必要强调可能有相同分数了

因为如果是>=ai的话，两个同分的和两个相邻分数的对于合法性其实都一样

所以认为题意为恰好有ai个人（当然考场上还是大力问监考）

那么研究一下这个约束条件的限制，可以发现实际上是ai和bi中间摞了n-ai-bi个人

那么用xi=ai表示这一摞人前面有多少人，yi=n-ai-bi表示摞了多少人

可以发现对于xi相等而yi不等的两个人一定无法满足

而xi和yi都相等的人一定一起满足（除非xi和yi相等的人数超过了yi，那么多出者不满足）

所以可以把xi和yi相等的人合并，令zi表示满足这些人的要去需要再拿多少个假人充数

（假人就是条件不被满足的人）

然后灵稽一动，不妨就按xi递增排序，然后考虑枚举到的每个人是否满足要求

如果这样做的话状态可以设为f[i]表示把前i个人安排上需要的最少说谎人数

递推求解

这样好像不太对，有后效性

即假设现在要那一个假人充数，那这个假人是前面考虑过的，还是后面没考虑的，还是把已经满足的撤了

你不知道，会影响决策

我的思路转了一圈之后，找不到什么有可能的做法，再回来研究这样做，发现各种细节美好得不正常

于是决定随便写写试试

然后就ac了

我尻![](https://img2018.cnblogs.com/i-beta/1746505/201912/1746505-20191211180621056-567986158.png)这都行

现在再来考虑算法得正确性，可以发现刚才得顾虑是多余的

因为所有没满足要求的假人都是一样的，而易证假人是充足的，因为如果假人不够则与总人数冲突

所以我们完全不用考虑假人从哪来，只需要直到前边已经有i个人被安排了就行

最后整理一下思路

首先令xi=ai，yi=n-ai-bi，zi=需要补的假人

然后按xi递增排序，走递推

f[i]初值为i，包括f[0]=0

递推公式为f[a[i].x+a[i].y]=min(f[a[i].x+a[i].y],f[a[i].x]+a[i].z)

需要注意a[i].x和a[i-1].x中间可能隔了几个数，而这些状态实际受f[a[i-1].x]的影响

因为中间可以直接丢一个假人过去把之前的更优决策继承过来

也就是说f[a[i-1].x+j]应该等于f[a[i-1].x]+j，f[a[i].x]应该等于min(f[a[i].x],f[a[i-1].x]+a[i].x-a[i-1].x)

我的写法是用一个temp跟着a[i].x走，每次让temp++就令f[temp]=min(f[temp],f[temp-1]+1)

-----------------------------
代码：
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
struct nds{int x,y,z;}a[110000],b[110000];  int m=0;
int n;
int f[110000];
bool cmp(nds x,nds y){  return x.x==y.x ? x.y<y.y : x.x<y.x;}
int main(){
	freopen("ddd.in","r",stdin);
	cin>>n;
	int l,r;
	for(int i=1;i<=n;++i){
		scanf("%d%d",&l,&r);
		a[i].x=l,a[i].y=n-l-r;
	}
	sort(a+1,a+n+1,cmp);
	for(int i=1;i<=n;++i)if(a[i].y>0){
		if(a[i].x!=b[m].x || a[i].y!=b[m].y){
			b[++m]=a[i];
			b[m].z=a[i].y-1;
		}
		else  b[m].z=(b[m].z ? b[m].z-1 : 0);
	}
	for(int i=1;i<=n;++i)  f[i]=i;
	f[0]=0;
	int tmp=0;
	for(int i=1;i<=m;++i){
		while(tmp<b[i].x){
			++tmp;
			f[tmp]=min(f[tmp],f[tmp-1]+1);
		}
		f[b[i].x+b[i].y]=min(f[b[i].x+b[i].y],f[b[i].x]+b[i].z);
	}
	while(tmp<n){
		++tmp;
		f[tmp]=min(f[tmp],f[tmp-1]+1);
	}
	printf("%d\n",f[n]);
	return 0;
}


```