【题面】
 
 一次考试共有n个人参加，第i个人说：“有ai个人分数比我高，bi个人分数比我低。”问最少有几个人没有说真话(可能有相同的分数)

~~题面短得以为这题是个水题~~

【分析】

通过他们所说的前面后面的人数，我们首先可以确定他的**排名区间**（区间内的人分数相等）

这样我们就很容易发现两个排除假话的关键：

1. 前后的人数之和如果大于等于总人数显然是不可能的。

1. 我们刚才分析得出，**区间内的分数相等**，假如一段区间是$[a,b]$，一段是$[b,c]$，如果两段区间同时存在，那么传达出的意思是：$a=b>$c且$a>b=c$，这显然是不成立的。所以我们发现，如果两段区间**不完全重合**显然是不符合题意的。

特别地，如果两段区间**完全重合**是可能的，因为他们可能分数相同。

但是**重合区间数**如果超过**区间长度**就一定有假话。

这个很好理解，假如区间长度为$k$，那么就是说有$k$个人分数相等，但却有多于$k$个人说自己在这段区间内，这显然有人说假话。

所以我们可以给区间附一个权值$w[i]=min($相同区间数$,$区间长度$)$

【问题等价】

 有若干个区间，每个区间都有一个权值，要求选出若干不相交区间使得权值和最大。
 
 这个问题用贪心显然是不能做了，因为可能选的很多区间的权值和还不如一个区间大。 
 
 我们考虑用DP，先模仿最长上升子序列的做法，我们令 $F[i]$ 表示选第 $i$ 个区间能得到的最大权值，那么我们有 $$F[i]=max(F[j])+Value[i]$$其中要求区间 $j$ 与区间 $i$ 不相交，可是这个复杂度是 $O(n^2)$的，我们可以用线段树优化求 $max(F[j])$的过程，复杂度变成 $O(nlogn)$。

但是我们还有更好的做法，我们这次以每个点为单位， $F[i]$ 表示到 $i$ 这个点为止能选择的最大权值，那么我们如果 $i$ 这个点是某个区间的右端点，$$F[i]=max(F[i],F[left]+value)$$，$left$ 是这个区间的左端点，$value$ 是这个区间的权值，这样除排序复杂度外可以 $O(n)$ 的解决。

【代码实现】
```
#include<bits/stdc++.h>
using namespace std;
const int N=100010;
struct node{int l,r;} p[N];
int n,tot,num,a[N],w[N],L[N],R[N],f[N];
bool cmp(node x,node y)
{
    if(x.r!=y.r) return x.r<y.r;//关键字：右端点 
    return x.l<y.l;//次关键字：左端点 
}
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
    {
    	int x,y;
        scanf("%d%d",&x,&y);
        if(x+y>=n) continue;//显然是假话（自己体会） 
        p[++tot].l=x+1,p[tot].r=n-y;//记录线段左右端点 
    }
    sort(p+1,p+tot+1,cmp);
    for(int i=1;i<=tot;i++)//计算区间权值
    {
        if(p[i].l!=p[i-1].l||p[i].r!=p[i-1].r) num++;
        //如果线段完全重合则num值不发生变化，权值增加
        w[num]=min(w[num]+1,p[i].r-p[i].l+1);//区间权值
        L[num]=p[i].l,R[num]=p[i].r;//记录重新选出来的线段
    }
    int j=1;
    for(int i=1;i<=n;i++)
    {
        f[i]=f[i-1];
        while(j<=num&&R[j]==i) 
		{
			f[i]=max(f[i],f[L[j]-1]+w[j]);//上文已解释
			j++;
		}
    }
    printf("%d",n-f[n]);
    return 0;
}
 ```
