我不会拆柿子，我也不会分析性质。

咋办？我们先写暴力。

相信各位应该都会这个的 DP 柿子。

设 $f_i$ 表示有 $i$ 个人的时候需要比较最少次数。

转移就枚举其约数即可，然后用那个式子稍微算一算就可以了。

```cpp
for (int i=2;i<=n;i++) {
		f[i]=1e9;
		for (int j=1;j*j<=i;j++) {
			if (i%j) continue;
			int X=j;
			if (X>1)
				f[i]=min(f[i/X]+X*(X-1)/2,f[i]);
			
			X=i/j;
			f[i]=min(f[i/X]+X*(X-1)/2,f[i]);
		}
}
```

核心代码如上。

那么我们进一步考虑优化这个过程。

我们会发现，这个东西似乎挺难搞的，并且我们的复杂度最好是线性的。

如果说要求 $O(n \log n)$ 的话可以考虑刷表，然后调和级数即可。

那么我们先打表打出来它的所有转移决策点。

```cpp
cin>>n;
	for (int i=2;i<=n;i++) {
		f[i]=1e9;
		for (int j=1;j*j<=i;j++) {
			if (i%j) continue;
			int X=j;
			if (X>1)
				f[i]=min(f[i/X]+X*(X-1)/2,f[i]);
			
			X=i/j;
			f[i]=min(f[i/X]+X*(X-1)/2,f[i]);
		}
//		cout<<i<<" fad?\n";
		for (int j=1;j*j<=i;j++) {
			if (i%j) continue;
			int X=j;
			if (X>1)
				if (f[i]==f[i/X]+X*(X-1)/2) cout<<X<<" ?\n";
			
			X=i/j;
			if (f[i]==f[i/X]+X*(X-1)/2) cout<<X<<" ?\n";
		}
		cout<<f[i]<<" "<<i<<" ?\n";
	}
```

打表之后发现一件非常有趣的事情，就是决策点有一个一定是最小质因数。

猜一下上面这个结论，然后利用欧拉筛把最小质因子筛出来，大力转移。

恭喜你通过了这道题。

大致证明就是除法一定是下降的比较快的，因此我们应该把旁边那个加法给缩小，最好的情况是最小。

同时这题要线性处理逆元，这里给出一个比较好的做法，就是先求 $n!$ 的逆元然后再乘上 $(n-1)!$，这两个东西可以 $O(n)$ 递推求得。

[code](https://codeforces.com/contest/822/submission/176869683)