### 这题难点不在搜索，而是读题……
-----

我先解读一下题目意思：

给你一个 $n\times m$ 的矩阵。

对于每次询问。输出所询问点所在联通块的**所有** `.` 周围的 `*` 个数。

看到没有？是所有！举个例子：

~~~
* * * *
* . . *
* . * *
* * * *

~~~

我们如果只看**整个**联通块周围的 `*` 的话……

那就只有 $7$ 个 `*` 了。

但是，我们很明显的看到：样例 $2$ 里面，最后的答案是 $8$ ！

仔细的读了一下英文题面之后，我发现：

这一道题实际上要求的是联通块里所有 `.` 的周围有的 `*` 的个数！

是不是还是有点昏？

简单的来说：

每访问到一个 `.` ，我们都需要在它四个方向上查找 `*` ，也就是可以有**重复**的计算！。

很好，现在大家应该可以读懂这道题了。

重新回到刚刚的样例：

~~~
* * * *
* . . *
* . * *
* * * *

~~~

这时候，我们已经可以明显的发现：

联通块右上方的 `.` 和左下方的 `.` 是有重复的 `*` 出现的。

我现在把这个重复的 `*` 改成 `@` 。

~~~
* * * *
* . . *
* . @ *
* * * *

~~~

清楚了么？

-------

那现在，我们只需要在每次询问时搜出询问位置所在的联通块，然后把这个联通块里所有元素的周围走一遍。

访问到 `*` 的时候计数器++就可以了。

(具体代码实现就不细说了，这有很多种实现方法，我的代码放上来简单讲讲实现（见代码的注释）) 。

[AC record](https://www.luogu.com.cn/record/35492193)

$Code:$

```cpp
#include<bits/stdc++.h>
using namespace std;

const int si=1006;//数组大小不解释

int n,m,k;
int tmp=0;
int ans[si*si];//这里ans数组用来存储答案，我的做法是用一维数组来储存，直接用pre数组的下标来访问，所以要开n^2的空间
int pre[si][si];//
char d[si][si];//地图，不解释
int dx[]={0,0,0,1,-1};
int dy[]={0,-1,1,0,0};//方向数组，不解释

void dfs(int x,int y){//深搜
	pre[x][y]=tmp;//tmp表示第tmp次询问（区分答案用的）
	for(register int i=1,nx,ny;i<=4;++i){
		nx=x+dx[i];
		ny=y+dy[i];
		if(nx<1||ny<1||nx>n||ny>m){
			continue;
		}//边界，搜出去就continue掉
		if(pre[nx][ny]){
			continue;
		}//如果pre数组被修改过了（已经有答案储存在ans数组了），那也continue掉
		if(d[nx][ny]=='*'){
			ans[tmp]++;
		}//搜到*，计数器+（答案）+
		else{
			dfs(nx,ny);//继续递归搜索
		}
	}
}

int sx;
int sy;//开始的坐标。

int main(){
	cin>>n>>m>>k;
	for(register int i=1;i<=n;++i){
		for(register int j=1;j<=m;++j){
			cin>>d[i][j];
		}
	}
	for(register int i=1;i<=k;++i){
		cin>>sx>>sy;
		tmp++;//tmp只是一个区分答案的指针罢了
		if(!pre[sx][sy]){
			dfs(sx,sy);
		}//pre没有被修改过，也就是说它之前还没搜过，搜一遍。（如果之前搜过，那ans里一定会有答案，直接输出就好了）
		cout<<ans[pre[sx][sy]]<<endl;//输出
	}
	return 0;
}
```


本蒟蒻写题解是为了让自己和别人能更好理解题目，管理员大大求过QAQ