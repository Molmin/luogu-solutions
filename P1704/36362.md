## 暴力赛高！暴力是全世界最最最（以下省略2147483647个人最）**NB**的算法！

### [AC记录](https://www.luogu.org/record/show?rid=6705503)

这里似乎没有朴素的算法啊（啊当然Pascal不算哈）

我开始做题的时候还专门为了求稳去学习了一下$nlogn$的最长上升子序列呢

其实我们会发现，暴力的时间复杂度其实根本不是$O(n^2)$，就让我们来分析一下暴力的时间复杂度。

首先，读入，时间复杂度$O(n+k$)，即$O(n)$；

接下来，对必须做题的时间排序，复杂度$O(nlogn)$；

再下去，对每段进行最长上升子序列，在一般情况下$c_i$平均分布，复杂度为$O((n/k)^2 * k)$，即$O(n^2/k)$，但是，在某些奇葩的数据下，会出现这个复杂度退化为$O(n^2)$的情况，显然，这道题并没有这样的数据（啊当然NOIP的话你是可以看看CCF会不会出这种毒瘤数据，但是这种一般的题目出题人都是直接敲个随机生成就走人的）（不要问我为什么因为我自己出题就是这么干的）。

综上所述，暴力的时间复杂度为$O(n^2/k)$，似乎AC并没有多少问题。。。

上代码，具体的问题就看代码辣~~

```cpp
#include<bits/stdc++.h> // 万能头文件 

using namespace std;

bool cmp(int a, int b){ // sort需要的比较函数 
	return a < b;
}

int Num[1100000]; // 题面中的c 
int f[1100000];   // 最长上升子序列的数组 

int Get(int l, int r){ // Get(l,r)表示从Num[l+1~r-1]这段的最长上升子序列 
	int Lbound = Num[l]; // 表示左边的边界，如果数要被放进最长上升子序列中必须要大于这个边界 
	int Rbound = Num[r]; // 表示右边的边界，如果数要被放进最长上升子序列中必须要小于这个边界
	for(int i = l+1; i < r; i++){ // O(n^2)最长上升子序列应该不用我多说了吧 
		if(Num[i] > Lbound && Num[i] < Rbound){ // 判定这个数是否符合在两个边界之间的条件 
			f[i] = 1;
			for(int j = l+1; j < i; j++){ // 这里注意不要把l和r扫进去，会死得很惨 
				if(f[j] + 1 > f[i] && Num[j] < Num[i]) f[i] = f[j]+1;
			}
		}
	}
	int Ans = 0;
	for(int i = l+1; i < r; i++){ // 这个时候也是同理，别把l和r扫进去 
		if(f[i] > Ans)
			Ans = f[i];
	}
	return Ans;
}

int main(){
	memset(f, 0, sizeof(f)); 
	int n, k;
	//----------开始读入------------- 
	scanf("%d %d", &n, &k);
	int OI[500000];
	for(int i = 1; i <= k; i++){
		scanf("%d", &OI[i]);
	}
	sort(OI+1, OI+k+1, cmp);
	for(int i = 1; i <= n; i++){
		scanf("%d", &Num[i]);
	}
	//---------读入结束-------------- 
	Num[0] = -1; // 注意一下这句话，因为我们要保证在0~第一个必须做题的天之内左边界为无限小 
	int Ans = k + Get(0, OI[1]); // 特判一下从0~c[1]之间的这段 
	for(int i = 1; i < k; i++){ // 扫一遍所有区间 
		Ans += Get(OI[i], OI[i+1]); // 加上这个区间的最长上升子序列长度 
		if(Num[OI[i]] >= Num[OI[i+1]]){ // 特判：如果后面一个节点和前面一个节点并不严格单调，则无解 
			printf("impossible");
			return 0;
		}
	}
	Num[n+1] = 2147483647;  // 和上面的同理（n+1是为了把最后一天扫进去） 
	Ans += Get(OI[k], n+1);
	if(OI[1] == 0) Ans--; // 对于第七组数据的特判，看讨论里面所以加的，但是似乎是数据出错了。。。 
	printf("%d", Ans); // 直接输出答案 
	return 0;
}
```