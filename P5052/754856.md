## 思路
观察题目，发现我们的决策只有两种，要么往左边收集宝可梦，要么往右边。而我们需要维护的信息也只有五种，区间长度，时间，方向和价值。我们考虑动态规划，对于第 $i$ 个点，他只会从 $i+1$ 或 $i-1$ 转换而来。可以得到如下方程，其中 $p_i$ 表示他的距离，$t$ 代表时间，$l,r$ 代表左右端点，$01$ 表示方向，$1$ 为左，$0$ 为右。

```cpp
dp[i][l][r][1]=max(dp[max(i-(p[l+1].num-p[l].num),0)][l+1][r][1],dp[max(i-(p[r].num-p[l].num),0)][l+1][r][0])+p[l].give;
dp[i][l][r][0]=max(dp[max(i-(p[r].num-p[r-1].num),0)][l][r-1][1],dp[max(i-(p[r].num-p[l].num),0)][l][r-1][0])+p[l].give;
```

注意到范围 $N \leq 10^3$ ，所以我们需要一些方法减低数组开的空间。现在，请我们返回题面。对于任意宝可梦，是不需要时间捕捉的。由于我们不需要在意他的过程，我们只需要在意他在区间左右端点即可，所以，我们可以考虑离散化只存储有宝可梦的房间即可。由于 $m\leq 100$ 所以最后我们的空间可以控制在 $10^7$ ，这样，我们就可以过这道题了。
## 细节处理
我们可能开始的时候并不在有宝可梦的地方，我们就从离最近的地方开始状态转移就好了。