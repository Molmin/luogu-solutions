题意翻译

farmer john有N（1≤N≤100,000）头牛，他想赚跟多的钱，所以他准备买牛奶和出租牛。有M(1≤M≤100,000 )家商店想买牛奶，每家商店的进货价不同。有R(1≤R≤100,000 )户邻居想租牛，每户人家的租价不同。 问他最多能赚多少钱。

输入：输入的第1行包含n,m,r三个整数。紧接着的n行每一行有1个整数Ci (1≤Ci≤1,000,000)，表示第i头牛产出Ci加仑奶。再下面的m行每行有两个整数Qi与Pi (1≤Qi,Pi≤1,000,000)，表示第i个商店最多以Pi美分每加仑的价格购买Qi加仑牛奶。FJ可销售0~Qi加仑牛奶到一个商店。然后的r行每行有一个整数Ri，表示FJ的第i个邻居想以Ri(1≤Ri≤1,000,000 ), 的价格租一头牛。

输出：仅一行。表示一天最多获得多少钱。


说明： FJ 需要挤一号和四号奶牛的奶，共可得牛奶13加仑。他可以先买给出价最高的10加仑，赚250美分，然后把剩下的按每加仑15美分去卖，共有295美分的利润。 然后，他要把其他三头以250,80，和100美分的价格分别卖出，赚430美分。所以他一共可得725美分/日的利润。

输入输出样例
输入样例#1：

5 3 4
6
2
4
7
1
10 25
2 10
15 15
250
80
100
40

输出样例#1：

725
注意：int类型不够大！！！

这道题有三种地方用到了贪心:
1.留下产奶量多的奶牛;
2.卖牛奶先卖给出价高的商铺;
3.把奶牛租给出价高的邻居。

而为了节省时间，就可以用前缀和。
注意程序中的这一句：mm=max(mm,zqs+c[min(n-i,k)]);
c中保存将不产奶的n-i头奶牛租给邻居的可得的最大金额，因为前缀和后直接取c[min(n-i,k)]，求个min是因为n-i可能不k大，说明租给邻居后还有奶牛剩余。
```cpp
#include<bits/stdc++.h>
using namespace std;
struct ll{            
//全部用long long（只要个别用就可以，这里为了节约做题时间）
	long long zl,qian;
}b[1000001];
long long n,m,k,z,zqs,mm,t,a[1000001],c[1000001];
bool cmp(long long x,long long y)
{
	return x>y;
}
bool cmp2(ll x,ll y)
{
	return x.qian>y.qian;
}
int main()
{
	cin>>n>>m>>k;
	for(int i=1;i<=n;i++)
    //读入奶牛的产奶量，从大到小排序（贪心）
	cin>>a[i];
	sort(a+1,a+1+n,cmp);
	for(int i=1;i<=m;i++)
    //读入商铺买奶牛的信息，按钱从大到小排序（再次贪心）
	cin>>b[i].zl>>b[i].qian;
	sort(b+1,b+1+m,cmp2)；
	for(int i=1;i<=k;i++)
    //读入邻居租奶牛的金钱，从大到小排序（又一次贪心）
	cin>>c[i];
	sort(c+1,c+1+k,cmp);
	for(int i=1;i<=k;i++)//节省时间而用的前缀和
	c[i]=c[i-1]+c[i];
	t=1; //t代表当前卖个第几个商铺
	for(int i=0;i<=n;i++)//枚举留下i头奶牛产奶
	{
		z=z+a[i];//第i头牛产奶
		while((t<=m)&&(z>=b[t].zl))
        //商铺还能卖且可以将商铺的需求量全部完成，则全部买。
		{
			zqs=zqs+b[t].zl*b[t].qian;
			z=z-b[t].zl;
			t++;
		}
		if(t<=m)//没做完的话，将剩余的牛奶买出去。
		{
			zqs=zqs+z*b[t].qian;b[t].zl-=z;z=0;
		}
		mm=max(mm,zqs+c[min(n-i,k)]);
	}
	cout<<mm;
	return 0;
}
```
