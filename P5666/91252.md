[更佳阅读体验](http://endsah.tk/blog/CSP2019-S-Solution/)

下面用 $son(x)$ 表示 $x$ 的重儿子，$s _x$ 表示 $x$ 子树大小。特别的，对叶子定义其 $son(x) = 0$，且 $s _0 = 0$，减少特判。

考虑到三个重要结论：

1. 一棵树任意定根，重心一定在根节点所在的重链上。
2. 两个重心一定相邻。
3. 点 $u$ 满足 $s _u \ge \lceil \frac n 2 \rceil, s _{son(u)} \le \lfloor \frac n 2 \rfloor$，是其为重心的充要条件。

第一个结论要想到也不难，随手画一下重剖的图会发现这看上去就很对。第二个是常识。第三个实际上就是「其分裂出来的树均不超过 $\lfloor \frac n 2 \rfloor$」的另一说法。

由于第二个的存在，只需要求出深度较深的重心，$O(1)$ 地检查一下他的父亲即可统计好答案。

把问题的求解分为两个部分。同时为了简化讨论，默认以原树的某个重心为根。

### 子树内

把树重剖一下。

首先，叶子的重心肯定是他自己；从重链往上爬，容易知道其重心也会随着节点的上移而上移。暴力的把重儿子的重心向上调整即可，总复杂度 $O(n)$（因为每个重心都是在对应的重链上爬，路径不交）。

### 子树外

真正需要注意的是这一部分。

仍然考虑到「重心在根节点的重链上」这个结论，显然删除轻儿子子树内的部分点不会使根节点的重链变化。那么预处理出 $g(x)$ 表示若整个树删掉了 $x$ 大小的子树之后，重心会在这个重链的哪个位置；容易知道随着 $x$ 的减小，重心的位置会逐渐上移，直接 $O(n)$ 地处理出 $g$ 后遍历所有轻儿子统计答案即可。

再考虑删去重儿子子树内某一部分。由于**以原树重心为根**，所以如果删掉 $x$ 大小的子树之后重儿子仍然是重儿子，那么重心肯定是根（不可能删掉一部分之后重心还向该树内部移动）。若删掉之后原本的次重儿子取而代之，那么会变成和上面一样的问题，同样对次重儿子预处理出 $g$ 求答案。

总复杂度 $O(n)$，注意要时刻判断另一个重心的存在。

### 另一种思路

以上思路都是基于「考虑删掉一个子树，重心会如何变化」的；实际上也可以考虑「有多少个子树满足删掉之后，剩下的树以我为根」。

同样以重心为根。设删去的子树大小为 $S$，考虑一个非根节点 $u$ 作为重心时是什么情况：

$$
\begin{aligned}
s _u \ge \lceil \frac {n - S} 2 \rceil, s _{son(u)} \le \lfloor \frac {n - S} 2 \rfloor \\
\Rightarrow n - 2 s _u \le S \le n - 2 s _{son(u)}
\end{aligned}
$$

实际上漏了一个额外条件：删除的点不能位于其子树内。所以先做一遍全局的，统计出有多少个满足条件的 $S$；再 DFS 一遍，访问到一个节点时记录一个值，遍历完子树之后再用现在值减去之前的值，即可得到子树内的影响，用全局值减去即可。

再考虑根。这里的不同是删去重儿子的部分子树时重儿子可能变化，所以分重儿子和轻儿子求解即可。

用树状数组维护上述过程，复杂度 $O(n \log n)$。