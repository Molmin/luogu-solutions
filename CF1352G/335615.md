#### 题目大意


------------
给定义一个 $n$，输出 $1-n$ 的一个排列满足任意两个数的差 $∈ [2,4]$。
若无满足条件的排列输出 $-1$。

#### 题目分析


------------
本题唯一的难点在于如何排列这 $n$ 个数字使得相邻的数字的差满足题设条件。

观察样例并不能很好的发现规律，而暴力枚举的复杂度让人望而却步。

想要解决一道构造题就要从题干中找出关键信息并将关键信息整合成对于解题有帮助的线索。首先从这一列数的性质入手可以发现满足两个数字的差 $\ge 2$ 的数字组合中最容易想到的就是奇数与偶数天生的性质。很容易便可以进一步想到要分别枚举 $\le n$ 的所有的奇数和偶数，但是如何处理奇数和偶数的边界成了解决此题的最大障碍。

分别考虑 $n = 7$ 和 $n = 8$ 的情况：

- 当 $n = 7$ 时，$\le n$ 的奇数有 $1,3,5,7$，偶数有 $2,4,6$。如果直接将这两个序列拼接起来显然是不行的，我们可以考虑将这两个序列其中的一个翻转过来例如翻转前一个序列变成 $7,5,3,1$ 但是这时候直接和第二个序列拼接也是不行的，所以我们考虑两个不相邻的奇数和偶数的差为 $3$ 这一性质可以想到将未翻转的序列交换前两个数字所以 $n = 7$ 的时候，序列就可以为 $7,5,3,1,4,2,6$

- 当 $n = 8$ 时，沿用上述方式，奇数有 $1,3,5,7$，偶数有 $2,4,6,8$。序列可以变为 $7,5,3,1,4,2,6,8$。

到这里我们已经完成了此题的绝大部分，但是还有一种 $-1$ 的情况没有考虑，根据我们构造的方式，当 $n \le 3$ 时无论如何都不可能满足题设条件，故可以直接输出 $-1$。

#### 代码实现


------------
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<cstdlib>

using namespace std;
const int N = 10010;

inline int read(){
    int x=0,f=1;
    char ch=getchar();
    for(;!isdigit(ch);ch=getchar()) if(ch=='-') f=-1;
    for(; isdigit(ch);ch=getchar()) x=(x<<3)+(x<<1)+ch-'0';
    return x*f;
}

int main(){
	int T = read();
	while(T--){
		int n = read();
		if(n < 4){
			printf("-1\n");
			continue;
		}
		if(n % 2 == 0){
			for(int i = 2;i <= n;i += 2){
				printf("%d ",i);
			}
			printf("%d %d ",n-3,n-1);
			for(int i = n-5;i >= 1;i -= 2){
				printf("%d ",i);
			}
			printf("\n");
		}
		if(n % 2 == 1){
			for(int i = 1;i <= n;i += 2){
				printf("%d ",i);
			}
			printf("%d %d ",n-3,n-1);
			for(int i = n - 5; i>= 2;i -= 2){
				printf("%d ",i);
			} 
			printf("\n");
		}
	}
	return 0;
}
```
