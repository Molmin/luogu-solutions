这里是一种从DP出发的思路。

我们设酋长的名字长为 $n$，每位依次编号为 $1\sim n$。再设字符集大小是 $m$。

然后，我们先来看一道题作为本题的模型：[[Cnoi2020]线形生物](https://www.luogu.com.cn/problem/P6835)。

我们将会发现这两题是很相似的——具体来说，本题可以被抽象成一个与上题一模一样的模型：

有 $n+1$ 个点，编号为 $0\sim n$。其中，对于每个 $0\leq i<n$，都有边 $(i,i+1)$。这条边表示刚好抽到了序列中的下一个字符。

但是，我们发现它还有可能没有抽到下一个字符。此时，它不一定必须从头开始，而是有概率成为前 $i$ 个字符构成的串的一个 $\text{border}$（$\text{border}$ 定义为某个串相同的前缀与后缀）的下一位。

比如，设一个串为 ```ABAABAB```，且当前我们位于第 $6$ 位。

显然，如果这时摇出一个 `B`，就直接结束了；于是有一条边 $(6,7)$。

但是，如果摇出一个 `A`，我们就得找到前 $6$ 位的串 ```ABAABA``` 的一个 $\text{border}$，使得该 $\text{border}$ 结尾的下一个字符是 `A`。我们发现 ```ABA``` 这个 $\text{border}$ 刚好符合要求。于是我们连一条边 $(6,4)$。

那么假如字符集中还有一个 `C` 呢？我们将会发现不得不再连一条边 $(6,0)$。

于是我们对于一个串，可以找到它关于 `A` 的 $\text{border}$（```ABA```），关于 `B` 的 $\text{border}$（```ABAABA```），关于 `C` 的 $\text{border}$（```一个长度为-1的串```），然后各自往这些 $\text{border}$ 结尾字符的下一个位置连边。

（需要注意的是，一个串并不是所有的 $\text{border}$ 都需要连边。举例来说，上例中的 ```A``` 与 ```ABAABA``` 同是关于 `B` 的 $\text{border}$，但显然我们选择**长度最长的那个**——这也是我特意标注“关于 `B` 的 $\text{border}$”的原因，因为**关于同一个字符能且只能连出一条边**）

于是我们便成功将一道黑题转成了一道蓝题（并不，因为接下来还有很长的路要走）

我们先来看一下那道蓝题怎么做——

我们设 $h_i$ 表示当前在位置 $i$，期望要多少步才能走到位置 $i+1$。再设 $g_i$ 表示 $h_i$ 的前缀和（从起点期望多少步走到位置 $i+1$）。

于是如果有一条边 $(i,j)$ 且 $j<i$，则我们如果走上了这条边，就需要期望 $g_{i-1}-g_{j-1}$ 的时间来回到 $i$。

因为每条边都是等概率（$\dfrac{1}{deg_i}$）选到的，所以我们期望需要 $deg_i$ 次才能选到唯一有用的边（$(i,i+1)$），则相当于每一条边都会被走一次。

于是就有

$$h_i=deg_i+\sum\limits_{(i,j),j<i}g_{i-1}-g_{j-1}$$

其中，外面那个 $deg_i$ 是因为每一条边本身就需要 $1$ 的时间走过。

下面回到本题。显然，对于每个位置 $i$，都有 $deg_i=m$。（回忆一下，$m$ 是字符集大小）

于是就有

$$h_i=m+(m-1)g_{i-1}-\sum g_{j-1}$$

因为 $j$ 是 $\text{border}$ 的下一个字符；所以 $j-1$ 就是 $\text{border}$ 的结尾；故我们就可以直接在下面令 $j$ 表示所有 $i$ 的 $\text{border}$ 的结尾（前提是这些 $\text{border}$ 的下一个字符必须互不相同，这点我们之前已经讨论过了。这样处理后，我们便不需要考虑什么“长度为 $-1$ 的串”诸如此类的奇怪东西）

这样处理之后，我们下面定义一个 $\text{border}$ 的**结尾字符**表示它末尾字符的下一个字符。

故我们有

$$h_i=m+(m-1)g_{i-1}-\sum g_j$$

显然在 $n=10^5$ 的条件下，暴力连边是不可取的，故我们要想办法优化。

有什么求 $\text{border}$ 的算法吗？

对，没错，就是你们想的那个，**KMP**。

众所周知（并不），KMP的 $next$ 数组构成了一棵树，我们称作 $next$ 树。一个节点在 $next$ 树中的所有祖先即为它的所有 $\text{border}$。

但是根据我们之前所说，这些 $\text{border}$ 中结尾的下一个数相同的只能保留一个，故我们应该开一个桶表示对于当前节点，它（所有祖先 $\text{border}$ 中）（以每个字符作为结尾字符）的串的下标。

但是这样复杂度仍然是 $O(nm)$ 的。

我们考虑一些优化。我们设 $f_i$ 表示 $i$ 节点时的 $\sum g_j$。则有

$$h_i=m+(m-1)g_{i-1}-f_i$$

但是 $f_i$ 怎么求呢？我们考虑从它 $next$ 树上的父亲（设为 $fa$ ）转移过来。

我们考虑 $f_i$ 相较于 $f_{fa}$ 改变了什么——

1. 原本的 $f_{fa}$ 中并没有考虑 $g_{fa}$ 其本身，而对于 $i$ 来说，$g_{fa}$ 也是其 $\text{border}$，故应加上 $g_{fa}$；

2. $f_{i}$ 中不应包含 $i$ 本身的结尾字符。故我们可以预处理出来 $rep_i$ 表示 $i$ 的所有祖先中，最深的那个和 $i$ 拥有相同结尾字符的 $\text{border}$ 的位置（通过上文提到的桶，在 $next$ 树上dfs即可得到）（假如不存在这样的 $\text{border}$，设为 $-1$ 即可）。则 $f_i$ 应该减去 $g_{rep_i}$。

这样我们便成功求出了 $f_i$。套用前面的式子，便可在 $O(n)$ 时间内DP完成。

我们最后梳理一下过程——

1. 对原串进行KMP，建出 $next$ 树；

2. dfs $next$ 树，用桶求出 $rep_i$；

3. 初始化（$f_0=0,g_0=h_0=m$）

4. 枚举 $i$，从它的父亲求出 $f_i$，然后求出 $h_i$，然后前缀和得到 $g_i$。（实际操作中直接把 $g$ 和 $h$ 开在同一个数组里即可）

5. 答案即为 $g_{n-1}$。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int mod=10000;
int T,n,m,a[100100],kmp[100100],f[100100],g[100100],rep[100100],buc[100100];
vector<int>v[100100];
void dfs(int x){
	int tmp=buc[a[x+1]];
	buc[a[x+1]]=x;
	for(auto y:v[x]){
		rep[y]=buc[a[y+1]];
		dfs(y);
	}
	buc[a[x+1]]=tmp;
}
int main(){
	scanf("%d%d",&m,&T);
	while(T--){
		scanf("%d",&n);
		for(int i=0;i<=n;i++)v[i].clear();
		for(int i=1;i<=n;i++)scanf("%d",&a[i]),rep[i]=0;
		for(int i=1;i<=m;i++)buc[i]=-1;
		for(int i=2,j=0;i<=n;i++){
			while(j&&a[j+1]!=a[i])j=kmp[j];
			if(a[j+1]==a[i])j++;
			kmp[i]=j;
		}
		for(int i=1;i<n;i++)v[kmp[i]].push_back(i);
		dfs(0);
//		for(int i=0;i<n;i++)printf("%d ",rep[i]);puts("");
		f[0]=0,g[0]=m;
		for(int i=1;i<n;i++){
			f[i]=(f[kmp[i]]+g[kmp[i]])%mod;
			if(rep[i]>=0)f[i]=(f[i]-g[rep[i]]+mod)%mod;
			g[i]=(1ll*(m-1)*g[i-1]+m-f[i]+mod)%mod;
			(g[i]+=g[i-1])%=mod;
		}
//		for(int i=0;i<n;i++)printf("%d ",f[i]);puts("");
//		for(int i=0;i<n;i++)printf("%d ",g[i]);puts("");
		printf("%04d\n",g[n-1]);
	}
	return 0;
} 
```
