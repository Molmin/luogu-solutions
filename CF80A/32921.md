> 这道题看似是数论，但是可以……打表

---

> 思路

由于本题数据范围极小，因此我们考虑$O(1)$的 ~~数据预处理~~ 打表法。

由于输入数据保证$m>n$，因此在运行时只需要判断$n$是否为质数、$m$是否为$n$之后的第一个质数即可。因此，考虑用一个数组$nex$作为表的本体，其中$nex_i$表示质数$i$之后的第一个质数；如果$i$不是一个质数，那么将$nex_i$置为$-1$即可。运行时，只需要判断$m$是否等于$nex_i$即可。

当然，这种方法受数据范围影响较大（$aka.$「面向数据编程」），因此，在数据范围较大时，我们可以考虑线性筛出$n$之后的第一个质数并同$m$比较，具体思路在此从略。

---

> 代码实现

应该看得懂吧（。

```cpp
#include<iostream>
#include<cmath>
using namespace std;
int nex[51]={-1,-1,3,5,-1,7,-1,11,-1,-1,-1,13,-1,17,-1,-1,-1,19,-1,23,-1,-1,-1,29,-1,-1,-1,-1,-1,31,-1,37,-1,-1,-1,-1,-1,41,-1,-1,-1,43,-1,47,-1,-1,-1,53,-1,-1,-1};
int main()
{
    ios::sync_with_stdio(0); // 关闭同步，使流输入输出更加高效
    int a,b;
    cin>>a>>b;
    cout<<(b==nex[a]?"YES":"NO");
    return 0;
}
```

---

> 附言＆必要说明

- ~~你谷$\rm{CF}$题恶评日常~~
	- ~~我又切了一道紫题！`.jpeg`~~ 
- $generator$：手打（