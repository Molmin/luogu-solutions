初始只有根节点的树，每次加叶子之后询问至少再添加多少个叶子能使得树有两个重心。不强制在线。

$\sum n\leq 5\times 10^5$。

有两个重心 $\to$ 一条边把树分成大小均为 $\frac{|V|}{2}$ 的两部分 $\to$ 找到原树中的一条边使得两部分点数差距最小。

到这里就卡住了，因为不能动态维护子树 size 最接近 $\frac{i}{2}$ 的值（$i$ 是当前点数），继续分析性质：暂时忽略不用加点的情况，则这条边的两端一定有点数 $< \frac{i}{2}$ 的，那么点数 $> \frac{i}{2}$ 的另一边如果仍然存在一棵子树满足点数 $>\frac{i}{2}$，则整体向那棵子树移动一步更优。也就是端点一定有一个是原树重心。对于不用加点的情况，两个端点都是重心。

如果能动态维护重心，其另一端的 size 不超过它，所以只需要求它的邻边中对应 size 最大的，父边可以特判，儿子只需要在子树里找 size 最大的，都可以用树剖维护 size 以及子树 size 最大值。最后处理重心，发现添加一个叶子之后重心至多朝着这个叶子移动一步，所以时刻也只需要维护一个重心（即使实际有两个，添加叶子之后也只是切换到另一个，可以从维护的那个重心走一步得到），全都可以借助树剖结构来实现。

$O(n\log^2n)$，[Submission](https://codeforc.es/contest/1827/submission/206039557)。