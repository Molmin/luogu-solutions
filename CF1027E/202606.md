# 算法

~~简单的~~DP

虽然是 $O(n^3)$ ，但是**比较直观**，好想。

写的也详细一些，将几个大佬的“易证”稍微解释一下。

[题目传送门](https://www.luogu.com.cn/problem/CF1027E)

[博客传送门](https://www.luogu.com.cn/blog/yanhangyn/)

# 思路

首先将令人烦躁的题意进行一个转换

~~根本看不懂~~

### 题意：

在一个 $n*n$ 的矩阵中，用黑白两种颜色进行染色，求满足下列条件的方案数：

1. 任意相邻的两列颜色排列要么完全相同，要么完全相反。

2. 任意相邻的两行颜色排列要么完全相同，要么完全相反。

	**注意：完全相反指的是黑变白，白变黑。**
    
3. 相同颜色组成的矩形面积小于 $k$ 。 （题目中给出 $k$ 大小）

### 可以得到的几个结论：

 1. 在确定第一行和第一列的颜色排列后，就可以得到有且仅有一种的“漂亮着色”。（及满足题意中 1,2 条的矩阵方案）
 
 2. 一种“漂亮着色”方案中，最大的相同颜色矩阵面积，是第一行中相同颜色组成的最长连续子串长度乘上第一列中相同颜色组成的最长连续子串长度。
 
 3. 第一行与第二行情况完全相同。（排列种类）
 
 **（注意：两个子串颜色不同也没有影响）**

#### 	证明：

1. 若第一行中第 $i$ 和第 $i+1$ 颜色相同，那么第 $i$ 列和 $i+1$ 列必定完全相同，反之则是完全不同。因此在确定第一行颜色排列后，可以得到任意相邻两列之间的关系。

	此时再得知第一列的全部颜色排列后，即可推出仅有一种满足“漂亮着色”的方案。（当然将列和行反过来想也一样）
    
2.	对于第一行 $i$ 与 $i+1$ 颜色相同，那么第 $i$ 列与 $i+1$ 列就是完全相同。所以第一列中相同颜色组成的最长连续子串长度就是该同色矩形的宽，第一行中相同颜色组成的最长连续子串长度就是该同色矩形的长。

3. 因为是正方形嘛，嗯嗯嗯。

### 因此

将第一行的所有状态求出，枚举所有情况，将其中符合“完美着色”的累加即可。（行列完全相同）

### 状态定义

$f(i,j,k)$ 表示

处理第 $i$ 个，最长相同颜色连续子串长为 $j$ ，结尾相同颜色连续长度为 $k$ 。

### 状态转移    

当 $i+1$ 与 $i$ 颜色不同时：$f(i+1,j,1)+=f(i,j,k)$ 

当 $i+1$ 与 $i$ 颜色相同时：$f(i+1,\max(j,k+1),k+1)+=f(i,j,k)$

### 一些细节

1. 由于直接开 $O(600^3)$ 的空间会炸，而且我们观察到状态转移只与前一个状态有关，所以用一个滚动数组。

2. 由于在处理时白色与黑色没有区别，所以任何一种方案都有两个情况，所以最后答案乘二。

3. 最后枚举可行答案时，有四个变量，即行和列的 $f(i,j,k)$ 的后两维。于是我们用一个新数组 $o(j,k)$ 表示第 $j$ 个位置最长相同颜色连续子串长为 $k$ 的数量。最后只需枚举行和列的 $k$ 即可。（都是 $n$ 的情况）

4. **不要忘记取余！**

# 代码

```
#include<bits/stdc++.h>
#define int long long
const int p=998244353;
using namespace std;
int n,k,x=1,y;
long long ans;
int f[2][600][600];
int o[600][600];
signed main(){
	cin>>n>>k;
	f[1][1][1]=1;
	for(int i=1;i<n;++i){
		for(int j=1;j<=i;++j){
			for(int v=1;v<=j;++v){
				f[!x][j][1]=f[!x][j][1]%p+f[x][j][v]%p;
				if(v+1>j)	f[!x][v+1][v+1]=f[!x][v+1][v+1]%p+f[x][j][v]%p;
				else f[!x][j][v+1]=f[!x][j][v+1]%p+f[x][j][v]%p;
			}
		}
		memset(f[x],0,sizeof(f[x]));
		x=!x;//滚动数组
		y=x;//记录n在滚动数组中哪个
	}
	for(int j=1;j<=n;++j)
		for(int v=1;v<=n;++v)
			o[y][j]=o[y][j]%p+f[y][j][v]%p;
	for(int i=1;i<=n;++i){//行的最长相同颜色子串长度
		for(int j=1;j<=n;++j){//列的最长相同颜色子串长度
			if(i*j<k)
				ans+=o[y][i]%p*o[y][j]%p; 
				ans=ans%p;	
		}
	}
	printf("%lld",ans*2%p);
	return 0;
}
```

    
	
