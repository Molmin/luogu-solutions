非常简单的一个题。但容易想歪。这种题相对C和D来说就可以算有点意思了。

做数据结构题，乃至做所有题，都有一个技巧。先把暴力敲出来，看看能不能优化暴力。

我们考虑怎么暴力做这题。

首先，枚举一开始的分割位置 $t$。（$a[t]$属于左边）

其次我们发现不大好确定怎么移动。这时候就要发掘发掘性质。

我们发现，移动完的数组一定是形如在某个数 $s$ 左边（包括$s$）的$p$为$1, 2, ..., s$， 剩下的为$s+1, s+2, ..., n$。这个非常好理解。

那么我们只要枚举 $s$ ，统计出 $t$ 左边（包括$t$）原来大于$s$的$p_i$的$a_i$的和，右边（不包括$t$）原来小于$s$的$p_i$的$a_i$的和，两边一加就是答案。

回头一看复杂度，妥妥的$n^3$。

接下来考虑优化。我们发现统计和那一步可以用权值线段树，优化到$n^2lgn$

但是这样子没什么用。枚举的复杂度是省不了的。

怎么办？

采用OI的常用套路，逆向思维。(譬如枚举每条边的贡献，枚举字符集就是这个的常见应用）

我统计不了每个状态下你分开的贡献，我还不能把你所有的贡献一起处理了？这样统一处理，就可以方便地使用一些东西维护。

我们考虑还是枚举$t$。维护一个数组$S$，$S[i]$表示$s$为$i$时候的答案。

对于一个$p_i$，如果它在$t$左边（包括$t$），那么它会对$s_0, s_1, ..., s_{p_i-1}$产生$a_i$的贡献。

对于一个$p_i$，如果它在$t$右边（包括$t$），那么它会对$s_{p_i}, s_{p_i+1}, ..., s_{n}$产生$a_i$的贡献。

这个时候我们直接上一棵线段树维护就可以了。

一开始全部在左边。后来一个一个往右加。最后全部在右边。每次加入后查询全局最小值。这就是一个非常完美的解法。