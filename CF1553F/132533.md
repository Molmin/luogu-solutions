说实话，自己做的时候没往整除分块上面想就导致后半不会……很神必。

说白了还是没把整除分块学懂。

我们先考虑把 $mod$ 写成另一种形式，即 $x \mod y = x - \lfloor \frac{x}{y}\rfloor y$ ，我们在这个式子的基础上考虑如何计算。                 

我们不难发现递推计算是比较发现的，根据 $p_{i - 1}$ 推出来 $p_i$ 只需要把剩下所有涉及 $i$ 与前缀的贡献加上去即可 ，我们将询问分成两类：   

- 形如 $a_i \mod a_j$ ，其中 $j \leq i$ ；        

- 形如 $a_j \mod a_i$ ，其中 $j \leq i$ ；            

我们考虑对于后面的情况是固定模数算和，换成上面那个式子的话我们不妨考虑直接暴力枚举 $\lfloor \frac{x}{y} \rfloor$ 这个值，然后你就会发现由于被除数固定，这个玩意儿套用整除分块就只有 $\sqrt a_i$ 个值，然后你维护一下值域区间和以及值域区间个数就可以把所有 $\lfloor \frac{x}{y} \rfloor$ 相同的数的贡献处理出来，那么这就需要一个 $O(1)$ 查询区间的数据结构，直接冲分块即可。             

接着你又考虑对于前面那种情况，你一想你后面那个东西都是 $O(n \sqrt a_i)$ 了这里就也涉及个根号的时间复杂度就行了，所以直接根号分治。

令 $B = \sqrt n$，对于所有 $a_j \leq B$ 直接暴力维护前缀所有数膜上小于等于 $B$ 的数之和，这里是 $O(n \sqrt a_i)$ 的。            

对于 $B \leq a_i$ 的情况，那么 $\lfloor \frac{x}{y} \rfloor$ 这个值又是的个数又是 $O(\sqrt a_i)$ 级别的，所以和整除分块差不多的方法维护就行了，时间复杂度 $O(n \sqrt a_i)$ 。              

最后总的时间复杂度是 $O(n \sqrt a_i)$ ，关于卡常的话是采取 dX 的方法把整除分块的前 $\sqrt n$ 个值拿出来直接跑结果就跑的飞快……虽然我个人不是很理解为什么会快了很多（至少我个人觉得这里没有巨大常数优化），但是实测就是要快很多。                 