第三次写题解，前面的题解都因为算法重复被打回了……这次提出了一点我独特的思路，望通过

第二题嘛，是道比较水的题目，~~但是我被淹死了~~

看到这道题，相信大家都可以自然而然地想到将已经读入的选手成绩做一个排序。但是在看到十万级别的数据之后，我们就会发现：这道题根本就没有这么简单！

考虑到一些时间复杂度比较优秀的排序算法的时间复杂度都是$O(nlogn)$，这样的复杂度仍然是不能满足要求的。所以我们只能使用时间复杂度为$O(n)$的排序算法——桶排序了。

AC代码如下（非本人考场代码）：
```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int x, w, n, ton[601];
int main()
{
	cin >> n >> w;
	for(int i = 1; i <= n; i++)
	{
		cin >> x;
		ton[x]++;
		int line = max(1, i * w / 100), sum = 0;
		for(int j = 600; j >= 0; j--)
		{
			if(ton[j])
			{
				sum += ton[j];
				if(sum >= line)	
				{
					cout << j << ' ';
					break;
				}
			}			
		}
	}
	return 0;
}
```
[洛谷评测记录（100分AC）](https://www.luogu.com.cn/record/41507752)

然而我在考场上看着这个代码，仍然不太满意：按照最大数据量来看，$10^5×600$应该还是会超时（~~其实并没有~~）。于是我在考场上动起了小心思：既然每一次都要将桶里面的数据从600到0扫一遍，那么就必定会有很多空的桶被扫到了，浪费了很多时间。那么为什么不把所有装了数据的桶编号从大到小，用一个数组装起来呢？用普通的数组存储当然是不行的，因为每次插入数据时，都要将其后面的数据依次向后移一位。这样反而比原来还慢。因此我们就要用到……

# 模拟链表！

考虑到利用指针来实现的链表难度比较大，而且申请动态空间有比较大的风险，所以我决定使用模拟链表来存储装有数据的桶的编号。并且在插入时，判断一下是否已有该数据，如果已经有了的话就不再重复插入，这样可以节省不少时间。

~~然后在考场上打出来，直接被第三个大样例终结……~~（前面答案与样例完全相同，但是后面缺少了一大半）就是很后悔……

下面还是把考场上的代码贴出来，并没有AC，主要是给大家提供一个可行（应该）的思路：
```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int x, w, n, ton[601], data[601], next[601], k, n1, head;
int main()
{
	cin >> n >> w;
	for(int i = 1; i <= n; i++)
	{
		cin >> x;
		ton[x]++;
		if(ton[x] == 1)
		{
			data[++n1] = x;
			if(n1 == 1)
			{
				head = n1;
				next[n1] = 0;	
			} 
			else
			{
				if(x >= data[head])
				{
					next[n1] = head;
					head = n1;
				}
				else
				{
					k = head;
					while(k)
					{
						if(data[k] > x && x >= data[next[k]])
						{
							next[n1] = next[k];
							next[k] = n1;
							break;
						}
						k = next[k];
					}
				}
			}
		}
		int line = max(1, i * w / 100), sum = 0;
		k = head;
		while(k)
		{
			if(ton[data[k]])
			{
				sum += ton[data[k]];
				if(sum >= line)	
				{
					cout << data[k] << ' ';
					break;
				}
			}			
			k = next[k];
		}
	}
	return 0;
}
```
[洛谷评测记录（80分）](https://www.luogu.com.cn/record/41508710)

------------
# 2020.11.15更新
机房里有许多小伙伴不懂链表是什么个东西，应他们要求，我就在这篇题解下面简单讲一下

![这是一个普通的数组](https://cdn.luogu.com.cn/upload/image_hosting/m4ordypp.png)

这个数组里的元素是有序排列的，唯独少了个6.所以6现在想要插队进去……

![](https://cdn.luogu.com.cn/upload/image_hosting/kzr1xbnx.png)

7和8看到6比他们小，只能顺次向后移一位……

![](https://cdn.luogu.com.cn/upload/image_hosting/fpoh59he.png)

于是6就插队成功啦

![](https://cdn.luogu.com.cn/upload/image_hosting/du1d46lx.png)

大家看到，普通的数组如果在中间插入一个元素，就需要后面的元素全部顺次后移一位。这样显然是十分麻烦的，每次插入都要遍历一次数组。那么有什么办法呢？

# 链 表 ！

想象一个场景：一个班的同学们正在排练舞蹈队形，老师突然命令他们变换队形。同学们跑得那叫一个乱七八糟……

![](https://cdn.luogu.com.cn/upload/image_hosting/xujwroez.png)

老师看到这个场景，又下达了一条命令：所有同学都记住自己前面的是哪个同学，跟着那个同学走！于是，同学们迅速地找到了他们的前面的同学（前驱）

![](https://cdn.luogu.com.cn/upload/image_hosting/fwb117sh.png)

于是1号成为了队首，2号跟着1号，3号跟着2号……8号跟着7号，这样子队列自然而然的就变成有序的啦~注意到，现在的同学们并没有按照上面那样有序排成一条队，而是四处分散的。他们仅仅是通过对应关系来确定队列顺序。

这时，6号同学又姗姗来迟了。他想要加个塞儿，怎么办呢？

![](https://cdn.luogu.com.cn/upload/image_hosting/cnmkclke.png)

舞蹈老师看到6号同学来了，~~就因为迟到把他赶了出去~~ 又下达了一条指令：在新的一次排练中，7号同学紧跟6号同学，同时6号同学紧跟5号同学。调整后的队伍如下：

![](https://cdn.luogu.com.cn/upload/image_hosting/skdvbwq9.png)

这时，队列又重新变得有序了~

可以看到，链表的数据插入操作比数组的数据插入操作要简单得多，不需要将数据移动位置，只需要调整一下前驱的指针即可。

不过链表当然也是有缺点的啦。首先，链表的元素访问比数组要麻烦。如果是数组，想要找排第三位的同学，只要喊一声“排第三的同学快出来”就行了。但是如果使用链表，大家都只知道自己前面的同学是谁，不知道自己排第几，只能先找到排最后的同学，再找他前面的同学，再找他前面的同学的前面的同学……直到找到要找的同学或者是找遍了整个队伍为止。其次，链表的实现比数组要复杂一些（数组这东西有实现可言吗），在使用时要多加小心 ~~我这次经历就是一次惨痛的教训~~

顺便一提，使用链表时一般不像上面说明的那样从尾巴找到头，而是先知道了排头的同学是哪个，再一个个往后面找。实现也很简单，如果不用指针的话，使用一个head变量来存储排头，然后用一个next数组来存储每个变量的后继分别是谁，再使用一个data数组来保存每个变量的值。插入时更改next数组的值即可，如果需要遍历，就使用一个迭代器，从head开始，再通过next数组来迭代即可实现链表的遍历。大家可以看我上面的第二个代码来理解。