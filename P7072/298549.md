我在考场上乱写了个 $O(600n)$ 的桶排做法呢。  
~~我才不会告诉你我考场上想到了对顶堆和线段树，然而鹅忘了怎么写了~~  
闲话少说，切入正题。  

---
第一眼看到这一题，就感觉这道题是桶排，毕竟有重复分数啊，$n\le 10^5$ 啊，分数小于 $600$ 啊。  
你看分数这么小根据经验肯定是桶排对吧。

---
有了大体思路，开始考虑实现。  
1. Q1：算排名肿么算啊  
	A1：$k\times w \div 100$，题目下面已经温馨提示了不能用 ```double/float``` 怎么可能会用呢。
    
2. Q2：怎么插入一个人的分数啊。  
	A2：$t_{score_i}+1$ 来桶排啊。
    
3. Q3：如何查询排名为 $ranking$ 的值啊。  
	A3：从 $600$ 到 $0$ （注意啊是 $0$，你看样例都有 $0$ 了）依次查询。首先我们要一个叫 $sum$ 的累加器来累加当前人数。如果$ranking \le sum$ 且这个桶有数（没数还分数线啊）的话，那么分数就是当前扫到的分数。因为假设是前面小的分数，肯定达不到这个 $ranking$，是不可能的。如果是更大的，排名更靠后，也不是这个 $ranking$。  
    
---
代码：  
```cpp
#include<cstdio>
using namespace std;
int t[610];//桶
int main()
{
	//freopen(".in","r",stdin);
	//freopen(".out","w",stdout);
	int n,w;
	scanf("%d%d",&n,&w);
	for(int p=1,x;p<=n;p++)
	{
		scanf("%d",&x);
		int ranking=p*w/100,s=0;//ranking为排名，s为人数
		t[x]++;//添加
		if(p==1)//特判一下这样的情况，这样的情况无需扫描
		{
			printf("%d ",x);
			continue;
		}
		for(int i=600;i>=0;i--)//扫描
		{
			s+=t[i];
			if(s>=ranking&&t[i])//找到了！
			{
				printf("%d ",i);
				break;
			}
		}
	}
}
```
时间复杂度为跑不满的 $O(600n)$，基本上分布应该不会十分均匀，而且越往后集聚越多，时间更少。  
超时是不太可能滴~