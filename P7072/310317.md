# 第一种解法

看到这样一道题，我们的思路就是每加一人，就sort一遍。

但是，这样显然会超时（n=100000可不是盖的)~~~~

比sort稍微快一点，我们可以使用插入排序，不过也会超。

所以我们需要另辟蹊径。

代码就不出示了，毕竟不是正解（其实是不想写）


------------

# 第二种解法（正解）

其实我们只要观察一下数据范围就会发现，分数的范围非常小！（只有600）

于是就顺理成章的想到了桶排。

思路非常简单，而且不存在超时。

没什么好说的，就出示代码了！

```cpp
#include<bits/stdc++.h>
using namespace std;
int t[605];
int n,w;
int main()
{
	int x;
	cin>>n>>w;
	for(int i=1;i<=n;i++)
	{
		cin>>x;
		t[x]++;
		int sum=0;
		for(int j=600;j>=0;j--)
		{
			sum+=t[j];
			if(sum>=max(1,i*w/100))
			{
				cout<<j<<' ';
				break;
			}
		}
	}
	return 0;
 } 
```
# 小小总结一下
这道题是桶排的经典题目，很适合排序的学习者尝试，思路非常清晰。

另外这是本菜鸡的第一篇题解，希望大家支持一下

早安，信奥人！

Good morning,OIer!