题意：给你一个数列，对于每前i个数字，按照w%的比例取走，最小的被取走的数是多少

直接设k为我们要取走的人数个数（按题意可算出k），答案就是数列中第k大的数字

若是每次都sort，效率是$O(n^2logn)$,最多只能拿50分

我在考场上时，也想到过插入排序，因为对于基本有序的序列，插入排序是$O(n)$的，若每次都插入数据，总体效率就为$O(n^2)$,运气好的话，可以拿到85分

同时在考场上也想过用二分来优化插入排序，可每次数据需要移动，所以时间复杂度依旧使$O(n^2)$,然后就感觉用什么数据结构可能能瞎搞出来，但没有去尝试

然后我就注意到分数的范围$0-600$,可以直接利用桶排解决问题，总体效率$O(600n)$

于是就轻松的把这题A了

# 代码:

```cpp
#include <bits/stdc++.h>
using namespace std;
int n,w;
int t[601];
int a[100001];

int main(){
	cin>>n>>w;
	for(int i=1; i<=n; i++) scanf("%d",&a[i]);
	for(int i=1; i<=n; i++) {
		int k=max(1,(int)(i*w/100));//算出k，避免精度问题，先乘w再除100
		int sum=0;
		t[a[i]]++;//桶排
		for(int i=600; i>=0; i--) {
			sum+=t[i];
			if(sum>=k) {//如果大于i的人数已经超过或者等于k，直接输出答案
				printf("%d ",i);
				break;
			}
		}
	} 
	return 0;
} 
```

## 题外话:

考场后出来感觉$O(600n)$可能会有一点卡时，有点怕会TLE

然后同学告诉我他~~手写~~了两个堆可以做到$O(nlogn)$

感觉堆排才是正解吧，虽然有一定的常数，可总体是比$O(600n)$要快。

有兴趣的OIer可以去了解一下堆排的做法，~~我太菜了不会~~