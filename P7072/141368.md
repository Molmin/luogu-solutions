~~AFO选手报道~~

**update** 11.14 增加了一些说明

考场上不会T2先去杠T3T4 11;20想出T2正解 11:45惊险写完

题目大意：求一个动态序列的第p大值,其中 $p=max(1,n \times w/100)$


$30$ $pts$

~~出考场后大部分人写了暴力~~

每次读入一个数就sort一遍，时间复杂度 $ O(n^2logn) $

$??$ $pts$

考虑一个问题：为什么要排序？

因为我们要找区间里第p大的数

用快排思想，每次查找区间第p大数，时间复杂度 $O(n^2)$

$100$ $pts$

看数据范围猜时间复杂度 : $ O(nlogn) $ ?

回想一下30分的暴力到底暴力在哪里：**我们只关心第p大的数，并不需要一个有序序列**，而每次的排序用了大量时间去维护我们不需要的信息。

转化问题：**第p大的数就是前p大数中最小的数**

我们可以构造一个东西，往里面扔p个数，每次用 $O(logn)$ 取出这里面的最小值即可。

这不就是堆吗！

我们可以构建两个堆：小根堆q1存储前p个数，那么每次的答案就是前p个数中最小的一个，即q1堆顶，大根堆q2存储还没有进q1的数。

那么就有了以下思路：

1.每读入一个数就压到q2里
10 60
200 300 400 500 600 600 0 300 200 100
2.如果q1中不到p个数就从p2里拿数（每次拿的都是没进q1中最大的数，可以保证q1存储前p个数）

3.**如果q1的堆顶比q2堆顶小（即后面的数中有比前p个数大的）两个堆互相扔一个数**

时间复杂度 $ O(nlogn) $

代码后面有样例过程，不理解的同学可以看看以更好地了解这个思路。

~~STL大法好~~

```cpp
#include<iostream>
#include<cstdio>
#include<queue>

using namespace std;

int n,w,p,s;
priority_queue< int,vector<int>,greater<int> > q1;//小根堆
priority_queue< int > q2; //大根堆
int main(){
	scanf("%d%d",&n,&w);
	for(int i = 1 ; i <= n ; i ++){
		scanf("%d",&s);
		q2.push(s);
		p = max(1,i*w/100);//按照题目描述求p
		while(q1.size() < p && q2.size()){
			q1.push(q2.top());q2.pop(); 
		}//只要q1里面没有p个数就往里压数
        while(q1.top()<q2.top() && q2.size()){
			int temp = q1.top();
			q1.pop();
			q1.push(q2.top());q2.pop();
			q2.push(temp);
		}//q1与q2互相扔数
		printf("%d ",q1.top());//答案就是q1堆顶啦
	}
	return 0;
}
```

```text
用样例模拟一下这个过程：
10 60
200 300 400 500 600 600 0 300 200 100

i=1 p=1
把200压进q2，发现q1里不到1个数，200进q1，q2变空
q1:200
q2:NULL
输出200

i=2 p=1
把300压进q2，发现q1里有1个数
q1顶200小于300，两个堆互相扔数
q1:300
q2:200
输出300

i=3 p=1
把400压进q2，发现q1里有1个数
q1顶300顶小于400，两个堆互相扔数
q1:400
q2:300 200
输出400

i=4 p=2
把500压进q2，发现q1里不到2个数
从q2中取最大值500压到q1里
q1:400 500
q2:300 200
输出400

i=5 p=3
把600压进q2，发现q1里不到3个数
从q2中取最大值600压到q1里
q1:400 500 600
q2:300 200
输出400

i=6 p=3
把600压进q2，发现q1有3个数
q1顶400小于q2最大值600，两个堆互相扔数
q1:500 600 600
q2:400 300 200
输出500

i=7 p=4
把0压进q2，发现q1里不到4个数
从q2中取最大值400压到q1里
q1:400 500 600 600
q2:300 200 0
输出400

i=8 p=4
把300压进q2，发现有4个数
q1顶400大于q2顶300 无交换
q1:400 500 600 600
q2:300 300 200 0
输出400

i=9 p=5
把200压进q2，发现q1里不到5个数
从q2中取最大值300压到q1里
q1:300 400 500 600 600
q2:300 200 200 0
输出300

i=10 p=6
把100压进q2，发现q1里不到6个数
从q2中取最大值300压到q1里
q1:300 400 500 600 600
q2:300 200 200 100 0
输出300
```

~~此题还有一个解法是桶排，题目把成绩设成小于600可能暗示桶排，不过如果把成绩范围改大桶排就爆了，而且桶排的时间复杂度600n,可以被nlogn吊打~~