### 题意

有 $N$ 个人，每人有一个分数，要你实时求出进入前 $w\%$ 所需要的分数线。

### 思路

考虑题目中所说的“前 $w\%$ 的分数线”，当进入前 $w\%$ 的分数有并列分数的人时，会增加获奖人数而不是更改分数线，所以并列的分数不需要考虑，所以只需要考虑第 $\lfloor p \times w \% \rfloor$ 名的分数就可以了。

此时题目就变成了：求一个动态增加的数列中的第 $k$ 大。其中 $k$ 为当前的 $\lfloor p \times w \% \rfloor$。

### 解法

#### 暴力

容易想到每读入一个数就对整个数列进行排序，然后输出第 $\lfloor p \times w \% \rfloor$ 大的数。时间复杂度是 $O(n^2\log n)$，只有50pts。

#### 桶排序

仔细读题会发现：题目中给定的分数一定小于等于600！所以我们可以开一个大小为600的桶数组 $T_i$ ，表示当前分数为 $i$ 的人数。每一次都从600分开始从大往小遍历整个数组，在循环中维护一个变量 $cnt$，表示大于等于当前分数的人数，在每个分数值都加上当前分数值的人数，当这个人数大于等于 $\lfloor p \times w \% \rfloor$ 时，当前的分数值就是要求的答案了。时间复杂度是 $O(600n)$，应该可以过 $10^5$ 的数据，100pts。

#### 对顶堆

我们也可以维护两个堆，一个大根堆，一个小根堆，其中小根堆中维护最大的 $\lfloor p \times w \% \rfloor$ 个数，大根堆维护剩下的 $p - \lfloor p \times w \% \rfloor$ 个数。此时要求的数就是小根堆的堆顶。若小根堆元素数量大于需要的，就将小根堆的堆顶弹出，插入大根堆；反之亦然。当有新的数插入时，只需要维护对顶堆的状态，就能求出要求的分数了。时间复杂度是 $O(n\log n)$，100pts。