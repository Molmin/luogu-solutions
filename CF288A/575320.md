## 思路讲解：

本题思路主要是贪心算法。

有 $n$ 位长的字符串，需要含有 $k$ 个字符。如果 $k > n$，或是 $n>1$ 且 $k==1$，那么就是找不到这样的字符串的，输出 $-1$ 即可。

如果能找到，因为找的是字典序最小的，所以前 $n-k+2$ 位只需交替输出 $a,b$ 即可。（$a$ 在前 $b$ 在后，这样字典序小）从第 $n-k+3$ 到第 $n$ 位，就由字母 $c$ 开始，一直输出到第 $n$ 个字母即可。

鉴于以上策略很好想（其他题解也说了），我就重点说一下易错部分：

首先，$n-k+2$ 是有可能大于 $n$的，所以需要特殊判断，方法有两种：

1. 循环时不用 `i<=n-k+2`，而用 `i<=min(n,n-k+2)`，先将 $n$ 与 $n-k+2$ 取最大值，再循环。

1. 直接 `i<=n`，在循环内判断此时的 $i$ 与 $n-k+2$ 的大小关系。

其次，本题要对字符进行运算，所以推荐使用 `printf("%c")` 进行输出。

说了这么多，上代码~

## AC CODE:

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	int n,k;
	cin>>n>>k;
	if(n<k||n>1&&k==1)//无法构成
	{
		cout<<"-1";
		return 0; 
	}
	for(int i=1;i<=min(n,n-k+2);i++)//本人采用了上面两种方法的第一种。
	{
		if(i%2==1)cout<<'a';//特别注意是模2余1输出a，不是余0
		else cout<<'b';
	}
	for(int i=n-k+3;i<=n;i++)//这里就不用特判了，因为本身终止条件就是小于等于n
	{
		printf("%c",'c'+i-n+k-3);
	}
	return 0;
}

谢谢观看~

```
