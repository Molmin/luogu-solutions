在本篇题解中，我们称题目中的 "拉票" 为 "操作"。

令 $mex\{S\}$ ( $S$ 是一个自然数集合 ) 为 $S$ 中没有出现的最小自然数。特别地，我们规定 $mex\{\emptyset\}=0$。

令 $xor\{S\}$ ( $S$ 是一个自然数集合 ) 为 $S$ 中所有元素的异或和。

我们考虑对给一个城市一个权值 $val[u]$，令

$val[u] = mex\{val[v]\ |\ \text{存在有向边}\ u\to v\}$

定好权值之后，我们证明几个东西：

**引理1 ：** 对于任意一条边 $u \to v$，$val[u] \neq val[v]$。

**证明 ：** 由于 $val[v]$ 一定在 $u$ 对应的集合 $S_u$ 中出现过，因此 $val[u] = mex\{S_u\}\neq val[v]$

**引理 2：** 令 $X(p)$ 表示所有 $val[u] = p$ 的 $u$ 的 $h[u]$ 的异或和，即 $X(p) = xor\{h[u]\ |\ val[u] = p\}$。先手能够获胜，当且仅当存在 $p$，使得 $X(p)\neq0$。

为了证明这个引理，我们先来证明其他两个东西：

**引理 2.1：** 若对于所有 $p$，有 $X(p)=0$，那么在执行一次操作后，必然存在一个 $t$ 使得 $X(t) \neq 0$。

**证明：** 设这次操作的点为 $u$，由 引理 1 我们可以得到不存在第二个点 $v$ 使得存在边 $u \to v$ 并且 $val[u] = val[v]$，因此能影响到 $X(val[u])$ 的只有 $h[u]$。

而我们在这次操作中必须令 $h[u]$ 减小（也就是令 $h[u]$ 发生变化），由于 $X(val[u])$ 一开始是 $0$，$h[u]$ 发生变化后 $X(val[u])$ 就一定非 $0$。引理 2.1 得证。

**引理 2.2：** 若存在一个 $p$ 使得 $X(p)\neq 0$，那么一定存在一种执行操作的方式使得操作后对于所有 $t$，$X(t) = 0$。

**证明：** 设 $q$ 最大的满足 $X(q) \neq 0$ 的数。首先我们需要证明一定存在一个点 $u$，使得在对这个点进行操作后可以让 $X(q) = 0$。

转化一下命题：对于一个 $val[u] = q$ 的点 $u$，我们想要让 $X(q)$ 归零，就要将 $h[u]$ 修改为 $X(q) \bigoplus h[u]$。现在命题变成了证明存在一个点 $u$，使得 $(h[u] \bigoplus X(q)) < h[u]$（$\bigoplus$ 表示异或）。

我们考虑 $X(q)$ 最高的为 $1$ 的那个二进制位（设这一位为 $i$，且由于 $X(q) \neq 0$，这样的 $i$ 一定存在）。因为 $X(q)$ 是若干个数的异或和，因此一定存在一个 $u$ 使得 $h[u]$ 的这一位也为 $1$，我们从满足 $h[u]$ 的第 $i$ 位为 $1$ 的 $u$ 中任选一个，记作 $w$。

我们设 $t = h[w] \bigoplus X(q)$，显然 $t$ 只有后 $i$ 位会发生变化，并且 $t$ 在第 $i$ 位为 $0$，而 $h[w]$ 在第 $i$ 位为 $1$，因此 $t < h[w]$。故 $w$ 合法，证明完毕。

证明了存在 $u$，接下来的任务就很轻松了：由于 $val[u] = mex\{S_u\}$，因此对于每一个小于 $q$ 的数 $p$，都存在一条边 $u \to v$ 使得 $val[v] = p$。

因为我们可以任意操作 $h[v]$，所以我们对于每个 $p,\ X(p) \neq 0$ 都找到一个 $v,\ val[v] = p$ 然后让 $h[v]$ 变为 $h[v] \bigoplus X(p)$ 即可。引理 2.2 得证。

证明了上述的两个小引理，我们现在可以来证明这个大引理了。

**证明：** 不可操作的状态（终止状态）就是所有点的 $h$ 都已经等于 $0$，此时显然有所有的 $X(p) = 0$。

若一开始存在 $p$ 使得 $X(p) \neq 0$，那么先手就能通过一次操作让所有 $X(p)$ 归零（由引理 2.2），而后手不管怎么操作，又都会至少让一个 $X(p)$ 变成非 $0$（由引理 2.1）。我们只需要证明这样操作下去总会让所有点的 $h$ 都归零（游戏会结束）就行了。（注：题目已经说明了一定能结束，这里只是再证明一次，如果不感兴趣可以跳过）

因为原图是一张 `DAG`，我们用数学归纳法来证明游戏一定会结束。

我们将这张图的拓扑序倒着写下来，令这个倒着的拓扑序为 $s$。

对于 $s[1]$，可以说明它没有任何出边，所以若进行只包含 $s[1]$ 的子游戏，不管 $h[s[1]]$ 是什么，游戏一定能结束。

对于 $s[k](k>1)$，假设我们说明了进行包含 $s[1],s[2],...,s[k-1]$ 的子游戏，不管 $h[s[1...k-1]]$ 是什么，游戏一定能结束。

我们知道，由于拓扑序的性质，对 $s[1],...,s[k-1]$ 进行的操作一定不能影响 $h[s[k]]$。而对 $s[k]$ 进行的操作一定是缩小 $h[s[k]]$，然后再改变 $s[1],...,s[k-1]$ 中某些点的 $h$。

我们知道不管 $h[s[1...k-1]]$ 是什么，这个子游戏一定能结束，也就是最终我们会回到只能操作 $s[k]$ 的状态。

而操作 $s[k]$ 只能缩小 $h[s[k]]$，$h[s[k]]$ 也不会被包含 $s[1...k-1]$ 的子游戏影响，所以 $h[s[k]]$ 一定会归零。因此包含 $s[1...k]$ 的子游戏不管 $h[s[1...k]]$ 是什么一定能结束。

通过归纳，证明完毕。于是 引理 2 得证。

有了上面的两个引理，接下来的构造方案是简单的：若所有 $X(p) = 0$，输出 `LOSE`，否则输出 `WIN`，然后找到最大的使得 $X(p)\neq 0$ 的 $p$，再找到一个使得 $h[u] \bigoplus X(p) < h[u]$ 的 $u$，更新 $u$ 以及它出边 $v$ 的 $h$ 使得所有 $X(p)$ 归零即可。

可以参考下面的代码：

```cpp
#include <bits/stdc++.h>

using namespace std;

int n,m;
vector<int> edge[200050];
int val[200050];
long long h[200050],X[705];
int maxn;

void dfs(int pos)
{
	if(val[pos] != -1) return ;
	bool vis[705] = {0};
	for(auto v : edge[pos])
	{
		dfs(v);
		vis[val[v]] = 1;
	}
	for(int i = 0;; ++ i)
		if(!vis[i])
		{
			val[pos] = i;
			break;
		}
	maxn = max(maxn,val[pos]);
	X[val[pos]] ^= h[pos];
}

int main()
{
	scanf("%d%d",&n,&m);
	for(int i = 1;i <= n; ++ i) scanf("%lld",&h[i]);
	memset(val,-1,sizeof(val));
	for(int i = 1;i <= m; ++ i)
	{
		int u,v; scanf("%d%d",&u,&v);
		edge[u].push_back(v);
	}
	for(int i = 1;i <= n; ++ i)
		dfs(i);
	for(int i = maxn;i >= 0; -- i)
		if(X[i])
		{
			printf("WIN\n");
			for(int j = 1;j <= n; ++ j)
				if(val[j] == i && (h[j] ^ X[i]) < h[j])
				{
					h[j] = h[j] ^ X[i];
					X[i] = 0;
					for(auto v : edge[j])
						if(X[val[v]])
						{
							h[v] = X[val[v]] ^ h[v];
							X[val[v]] = 0;
						}
					break;
				}
			for(int j = 1;j <= n; ++ j)
				printf("%lld ",h[j]);
			puts("");
			return 0;
		}
	printf("LOSE\n");
}
```