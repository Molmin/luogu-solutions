# ~~**我又来颓题解了**~~

第一暴力，一个一个枚举左右端点再扫就是N^3，T不T。。。自己拿捏

第二暴力就是可以预处理出区间正负。。。好想法但是N^2也会T昂

看到前面大佬的前缀积一头雾水，我果然还是太蒻了。

于是我就开始自己找规律

拿到第一组数据，先把它们全化成正负

就是：
```cpp
+-+-+
```
把它们所有的配对都写出来，会形成一个金字塔（第i行第j个表示第i个数作左端点，第j个数作右端点所形成的子串的正负性，最后的答案其实就是金字塔中正负号数量的总和）

得到：
```cpp
+--++
 --++
  +--
   --
    +
```
这样看其实也不是很明显，我们来看第二组

化成符号:
```cpp
++-+++-+++
```
继续写配对

```cpp
++----++++
 +----++++
  ----++++
   +++----
    ++----
     +----
      ----
       +++
        ++
         +
```
~~还有点好看~~

但好不好看是次要的，我们仔细观察这个结构，这个金字塔是由很多个正方形和三角形构成的，三角形由+号构成，正方形由+ - 交替构成。

一列一列地看会比较好想，代码实现也要容易一些，观察一下，没有遇到负号的时候每一列比起前一列就只是在最下面添加了一个+号而已，其它部分都保持不变，遇到负号就将当前所有的正负号反转再添上一个负号（也可以理解为添加一个正号再反转，代码实现中就为这种写法）。按照这样的规律下来就可以O(n)计算整个“金字塔”中的正负号数量总和了

具体实现看代码：

```cpp
#include<bits/stdc++.h>
#define int long long	//记得开long long 
#define mx 200005
using namespace std;
int a[mx];
inline int r()	//朴素的快读 
{
	int x=0,f=1;
	char ch=getchar();
	while(!isdigit(ch))
	{
		if(ch=='-') f=-1;
		ch=getchar();
	}
	while(isdigit(ch))
	{
		x=(x<<3)+(x<<1)+(ch^48);
		ch=getchar();
	}
	return x*f;
}
signed main()
{
	int n;
	cin>>n;
	for(int i=1;i<=n;i++) a[i]=r();
	int ansz=0/*正积子串累加器*/,ansf=0/*负积子串累加器*/,cntz=0/*之前提到的每一列的正号数量*/,cntf=0/*同理,每一列负号数量*/;
	for(int i=1;i<=n;i++)
	{
		cntz++;//增加的正号 
		if(a[i]<0)//遇到负号时 
		{
			swap(cntz,cntf);//由于全部反转,所以正号的数量变成负号的数量，负号的数量变成正号的数量 
		}
		ansz+=cntz;//正号累加 
		ansf+=cntf;//负号累加 
	}
	cout<<ansf<<" "<<ansz<<endl;//输出答案 
	return 0;
}
```
