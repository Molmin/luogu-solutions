这道题是挺巧妙的（毕竟之前没见过用第一类Stirling数的题

题目大意：对于一个$1,2,\ldots,n$的排列，设有$A$个数的左边都比它小，$B$个数的右边都比它小。已知$n,A,B$，求满足的排列个数。

首先$A$和$B$的地位是对称的，我们可以先考虑只有$A$的限制条件怎么做。

设$dp[i][j]$表示对于$i$个元素的排列，且$A=j$的方案数。

显然如果最小的数在第一位，那么就有1的贡献，否则没有，所以

$$dp[i][j]=dp[i-1][j-1]+(i-1)*dp[i-1][j]$$

然后我们考虑如何考虑$B$

我们知道，所有数都不大于$n$，所以$n$左边的数才可能贡献到$A$，$n$右边的数才可能贡献到$B$，所以

$$Ans=\sum_{i=1}^ns(i-1,A-1)*s(n-i,B-1)*C_{n-1}^{i-1}$$

但是这个式子还是要进行优化的，不过有一点比较麻烦，第一类Stirling数连通项公式都不好求，怎么推式子呢？

我们可以用**组合意义**来证明等式。

$Ans$是在$n-1$个元素中先选出$i-1$个，然后再分别将$i-1$个和剩下的$n-i$个组成$a-1$和$b-1$个圆排列（这是根据元素个数来枚举）

也是$n-1$个元素组成$a+b-2$个圆排列，然后再这$a+b-2$个圆排列中选$a-1$个（这是根据圆排列直接枚举），因此得知

$$Ans=s(n-1,a+b-2)*C_{a+b-2}^{a-1}$$

然后这道题就做完了

其实我们在考虑证明一些组合恒等式的时候，可以通过组合意义来证明，有时非常简洁。

不过有一道题跟这道题挺像的，是CF上面的，大家可以DoubleExp一下

```cpp
#include<cstdio>
#define Rint register int
using namespace std;
typedef long long LL;
const int mod = 1000000007;
int t, n, a, b, S[50003][203], C[203][203];
int main(){
    scanf("%d", &t);
    S[0][0] = 1;
    for(Rint i = 1;i <= 50000;i ++)
        for(Rint j = 1;j <= 200;j ++)
            S[i][j] = (S[i - 1][j] * (i - 1ll) + S[i - 1][j - 1]) % mod;
    C[0][0] = 1;
    for(Rint i = 1;i <= 200;i ++){
        C[i][0] = 1;
        for(Rint j = 1;j <= i;j ++)
            C[i][j] = (C[i - 1][j] + C[i - 1][j - 1]) % mod;
    }
    while(t --){
        scanf("%d%d%d", &n, &a, &b);
        printf("%d\n", (LL) S[n - 1][a + b - 2] * C[a + b - 2][a - 1] % mod);
    }
}
```