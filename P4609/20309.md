这是一道$Owen$两个月前就切的题目，然后他给我推荐~~我到现在才做~~，先$orz$一发$Owen\% \% \%$

~~如果不知道这道题是第一类斯特林数根本想不到~~

我们先分析一波，相当于我们要求排列数量，满足前缀最大值有$A$种，后缀最大值有$B$种。

### 以最大数为界

可以考虑最大的数，显然这个数一定被算入答案。

我们以这个最大数为界，维护$A+B-2$个连通块。

连通块是什么意思呢？？？

就是一个数列，满足第一个数大于其他数。

比如

```
4 1 2 3
4 3 2 1
4 2 1 3
4 1 3 2
4 2 3 1
4 3 1 2
```

然后我们把连通块分到两边，左边$A-1$个块，右边$B-1$个块，就好了。

由于左边的块一定是按照最大数从小到大排序（右边从大到小）的，所以划分的方案数是$C_{A+B-2}^{A-1}$

那么怎么求出把一个排列划分成$A+B-2$个连通块的方案数呢？

### 连通块$\Leftrightarrow$[圆排列](https://baike.baidu.com/item/%E5%9C%86%E6%8E%92%E5%88%97)

这是为什么呢？

考虑一个圆排列，从最大数处剪开，就是一个连通块。

比如
```
2 1 4
2 4 1
```

是两个圆排列

剪开后就是

```
4 2 1
4 1 2
```

可以感性理解一下。

所以划分的方案数，就是第一类斯特林数！！！

如果你不知到第一类斯特林数，可以看看我的[组合数学的一些小知识总结](https://www.luogu.org/blog/wohaocaia/zu-ge-shuo-xue-di-yi-suo-xiao-zhi-shi-zong-jie-wei-wan-post)才刚开始写，未完待续，大佬轻喷。

答案就是($s$是第一类斯特林数)

$$s_{n-1}^{A+B-2}C_{A+B-2}^{A-1}$$

左边是把$n-1$个数（除了最大数）分成$A+B-2$个连通块的方案数，右边是把连通块分配给左右两边的方案数。

所以预处理组合数和第一类斯特林数就好啦！

代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define ljc 1000000007
ll S[51001][303],C[303][303],T,n,a,b;
int main(){
    C[0][0]=1;
    for (int i=1;i<=202;i++){
        C[i][0]=1;
        for (int j=1;j<=i;j++){
            C[i][j]=(C[i-1][j-1]+C[i-1][j])%ljc;
        }
    }
    S[0][0]=1;
    for (int i=1;i<=50000;i++){
        for (int j=1;j<=201;j++){
            S[i][j]=(S[i-1][j-1]+(i-1)*S[i-1][j]%ljc)%ljc;
        }
    }
    cin>>T;
    while (T--){
        scanf("%lld%lld%lld",&n,&a,&b);
        printf("%lld\n",S[n-1][a+b-2]*C[a+b-2][a-1]%ljc);
    }
    return 0;
}
```