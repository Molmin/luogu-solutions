这道估计大多数人看到题后，第一思路都是直接01背包，dp[j]=max(dp[j],dp[j-a[i]]+1)，那么你会发现，dp[i]，只能存一个数，而答案有很多种可能，比如样例，dp[2]=2，但是你可以取走两个 1 或一个 2，有两种情况，所以这个方法就再见了。

然后又会有人想到第二种思路：dp[i][j]=max(dp[i-1][j],dp[i-1][j-a[l]]+1)，这个方法正确性固然不会错，但一看数据范围，n 是 1000，k 是 1000，还有枚举 l 的复杂度 1000，好吧，又再见了。。。

所以思路是什么呢(其实我刚开始也不知道)，后来我上百度查了一下，百度的方法(就是楼下说的思路)是这样的：把所有数字排序后，给所有数字减去 a[1] (当然 a[1] 不用减)，然后拿这些数字直接去做01背包就行了。dp[i] 表示当前总价值是 i 时最少需要拿几个物品。

不过这个算法的正确性如何证明呢？

对于每一种取法，每一项减去 a[1] 后会空出 k 个 a[1] 的位置，那么每一种合法的 dp[i] 一定相当于没有减去时的 dp[i+a[1]·k]，因为对于每一个 i ，i+a[1]·k 都不相同，所以对于每一种合法的 dp[i]，dp[i+a[1]·k] 一定只有一种情况————总代价为 i+a[1]·k。直接输出这个数就行了。。。

下来就是具体代码实现了：

```cpp
#include<iostream>
#include<algorithm>
#include<string.h>
using namespace std;
int n,k,a[1005],dp[1000005];
bool cmp(int i,int j) {return i<j;}	//从小到大排序
int main()
{
    memset(dp,12,sizeof(dp));	//乱搞的初始化最大值
    cin>>n>>k;
    for(int i=1;i<=n;i++)
        cin>>a[i];
    sort(a+1,a+n+1,cmp);
    for(int i=2;i<=n;i++)	a[i]-=a[1];	//骚操作
    dp[0]=0;
    for(int i=2;i<=n;i++)	//一定别忘了i从2开始枚举
        for(int j=0;j<=a[n]*k;j++)
            if(j>=a[i])	dp[j]=min(dp[j],dp[j-a[i]]+1);	//转移
    for(int i=0;i<=a[n]*k;i++)
        if(dp[i]<=k)	//判断当前 dp[i] 是否可以满足要求
            cout<<a[1]*k+i<<" ";
    return 0;
}
```