#### 题目不难，只要细心思考，有耐心地去模拟，就可以做出来

## 核心算法：模拟（？）

我看有些大佬用了搜索，其实不必

我感觉自己的思想可能是最好理解的

我们用两个$flag$记录奶牛和FJ的方向

$1$向上，$2$向右，$3$向下，$4$向左

没错，就是顺时针排列

再分别用两个变量记录当前$FJ$和奶牛的坐标

只要坐标不同（即还没有相遇），那么就一直循环，直到相遇，输出步数

在循环时进行判断，只要撞墙或者超出地图范围，就转弯

怎么转弯？

对了，让$flag$++

撞不了墙，就朝着当前的方向继续走一步

### 需要注意的一点
#### 转弯之后，是不用走下一步的，因为题目中描述转弯也消耗一分钟

具体请看代码注释

哦对了，是用$Python$实现的，但是用别的语言的各位同学也可以看下，因为语法差别对理解的阻碍并不是很大，而且最重要的是思想


```python
a=list()

#建立列表，大体上相当于某些语言的数组

for i in range(10):
	a.append(input())
	for j in range(10):
		if a[i][j]=='F':
      		  	#记录FJ的位置
			fx=i
			fy=j
		if a[i][j]=='C':
      			#记录奶牛的位置
			cx=i
			cy=j
            
#上面那段是输入，就相当于建立了一个二维数组

flagf=flagc=1

#分别是FJ和奶牛的初始方向（向上）

cnt=0

#记录步数（分钟数）

while not(cx==fx and cy==fy):
	#只要坐标不重合，就继续循环
	if flagf==1:
    
    		#向上走，就是横坐标减一
            
		if fx-1<0 or a[fx-1][fy]=='*':
        
        		#如果越界，就转向，不走
                
			flagf=2
		else:
			fx-=1
            
           		 #否则就走
                 
	elif flagf==2:
    
    			#向右走，就是纵坐标加一
                
		if fy+1>=10 or a[fx][fy+1]=='*':
			flagf=3
		else:
			fy+=1
	elif flagf==3:
    
    			#向下走，就是横坐标加一
                
		if fx+1>=10 or a[fx+1][fy]=='*':
			flagf=4
		else:
			fx+=1
	else:
    
    			#向左走，就是纵坐标减一
                
		if fy-1<0 or a[fx][fy-1]=='*':
			flagf=1
		else:
			fy-=1  
	
 	#以上是FJ的判断，下面是奶牛，同理，改变量名就行了

	if flagc==1:
		if cx-1<0 or a[cx-1][cy]=='*':
			flagc=2
		else:
			cx-=1
	elif flagc==2:
		if cy+1>=10 or a[cx][cy+1]=='*':
			flagc=3
		else:
			cy+=1
	elif flagc==3:
		if cx+1>=10 or a[cx+1][cy]=='*':
			flagc=4
		else:
			cx+=1
	else:
		if cy-1<0 or a[cx][cy-1]=='*':
			flagc=1
		else:
			cy-=1  
	cnt+=1
    
    	#步数加一
        
	if cnt>=100000:
    
    	#这是个技巧性的判断，
        #如果走了100000步还抓不到，基本无望了,
        #为了确保正确，可以提高这个数字，
        #但是由于python运行太慢，
        #就不加了，代码是可以通过的
        
		print(0)
        #输出0，到不了
		exit(0)
        #结束程序
print(cnt)
#输出步数
```
代码到这就结束了，希望大家多多支持

我感觉自己的思想是很好理解的，如果朋友们有问题还可以再询问

写题解不易，求过审