### 解题思路：

由于只能移动 $n-1$，所以一旦前面有障碍物一定不能在规定时间内到达对面，这是显然的。

对于不能交换，结合上面一条，可以得出一条对边只能放一个。

最后是不能重合，发现如果某不在对边上两个点到四个边框的第二短距离（由于这个点在一个边框上，最短的一定是 $0$）不相等，那个一定不可能在中间相遇。

而相等时，在绝大多数情况下都可以通过移动到对边来使得其不在中间相遇（可以结合 $4\times4$ 的格子理解，这种情况下是可以放满的，四个点分别放在 $(3,1)$，$(1,2)$，$(4,3)$，$(2,4)$）。

但是当恰好在中间时就无法作出相应的调整，只能将答案减一（结合 $3\times3$ 理解，这种情况下只能放一个）。

---
### 代码：

```cpp
#include<cstdio>
using namespace std;
int x[10005],n,m,ans,y[10005],a,b;
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=m;i++){
		scanf("%d%d",&a,&b);
		x[a]=1;y[b]=1;
	}
	for(int i=2;i<n;i++){
		if(x[i]==0)ans++;
		if(y[i]==0)ans++;
	}
	if(((n&1)==1)&&(x[(n+1)/2]==0&&y[(n+1)/2]==0))ans--;
	printf("%d\n",ans);
	return 0;
}
```
