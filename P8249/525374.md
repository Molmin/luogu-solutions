### 题目大意
给定两个数 $a$，$b$，再给定 $q$ 个询问。每个询问输入两个整数 $l$ 和 $r$，满足 $l\leq r$，求所有的 $i\in[l,r]$，$(i\bmod a)+(i\bmod b)$ 的最大值。
### 解题思路
$30$ 分做法：顺着题目大意暴力模拟，遍历 $l$ 到 $r$ 之间的所有数，最终求出最大值。

$70$ 分做法：对于取模的问题，通常都有一种循环节做法。我们观察后容易发现，$(i\bmod a)+(i\bmod b)$ 的值与 $((i+a\times b)\bmod a)+((i+a\times b)\bmod b)$ 的值是相等的。所以 $a\times b$ 就是一个循环节。

然后每次询问就不用暴力遍历 $[l,r]$ 了，如果 $r-l\geq a\times b$，那么直接遍历 $[1,a\times b]$，求出最大值即可。时间复杂度 $O(q\times a\times b)$。
不过数据强度好大，这种做法不加优化大概只能拿 $50$ 分~~我太蒻了~~。

**满分做法**：

根据刚才我们 $70$ 分做法的分析，容易想到:

其一，如果 $r-l+1\geq a\times b$，证明覆盖超过了一个循环节，直接输出一个循环节内的最大值即可，这个是可以预处理出来的。所以就不加赘述了。

其二，如果 $r-l+1<a\times b$，那么这题本质上是多次求一个长度为 $a\times b$ 的序列（把这个序列为 $A$ 数组），某一区间的最大值。把 $l,r$ 分别向 $a\times b$ 取模，得到 $l1=l\bmod (a\times b)$，$r1=r\bmod (a\times b)$。考虑如何求出最大值？

$a\times b$ 最大能达到 $10^6$ 级别，如果每一次求最大值都用遍历的方式，那么肯定会超时。

思考：怎样预处理，能使每次求最大值所花费时间复杂度均为 $O(1)$?

这里我们将会使用一种方法：**倍增法（或 ST 表）**。

定义：数组 $f[i][j]$，表示从 $i$ 往后 $2^j$ 个数中，$A[k]$ 的最大值。即 $f[i][j]= max\{A_k\}$，其中 $k\in[i,i+2^j-1]$。因为本题是求余数，可能会有余 $0$ 的，所以数组下标就从 $0$ 开始好了。

- **先考虑如何预处理**：

**其一，对 $f$ 数组的预处理。**

首先，非常容易得到所有的 $f[i][0]=A[i]$。从 $1$ 开始遍历 $j$，再从 $0$ 开始遍历 $i$，保证 $i\in [0,a\times b-2^j+1)$，考虑如何转移 $f[i][j]$。

例如，要想知道 $f[3][3]$ 的值是多少，实际上就是求 $A_3\sim A_{10}$ 之间的最大值。我们可以把 $8$ 个数拆成两份（**分治思想**），分别是 $A_3\sim A_6$ 和 $A_7\sim A_{10}$。只要知道这两份的最大值，再 $\max$ 一下就可以了。

而 $A_3\sim A_6$ 的最大值，就是 $f[3][2]$。$A_7\sim A_{10}$ 的最大值，就是 $f[7][2]$。所以就有 $f[3][3]=\max(f[3][2],f[7][2])$。具体一点，$f[3][3]=\max(f[3][3-1],f[3+2^{3-1}][3-1])$。

一般地，就有 $f[i][j]=\max(f[i][j-1],f[i+2^{j-1}][j-1])(j\geq 1)$。使用这个公式即可。

**其二，对 $log$ 数组的预处理。**

大家都非常熟悉的式子：

如果 $a^x=n$，那么 $x=\log_an$。当 $a=2$ 时， $x=log_2n$。

显然，在大多数情况下，$x$ 都不会是一个整数。

而现在，我们要定义一个 $log$ 数组，里面存储的都要是整数。我们对 $log$ 数组定义如下：$log[i]=\lfloor\log_2i\rfloor$。为什么这样做，即这样做有什么好处，咱们下面再说。

那么 $log[i]$ 如何转移就非常明显了：如果你嫌麻烦，不想考虑精度误差（~~这当然是不好的啦~~），可以直接写。或者，你也可以写这个，跑一遍求出来。

$log[1]=0$，之后所有的 $i\geq 2$，都有 $log[i]=log[\lfloor{\dfrac{i}{2}}\rfloor]+1$。

关于这个数组的一个重要性质：$\log_2\dfrac{i}{2}<log[i]\leq \log_2i$。经过简单的变形可以得到： $\dfrac{i}{2}<2^{log[i]}\leq i$。具体过程留给读者。

- **再考虑预处理后，如何在 $O(1)$ 时间内求出最大值？** 批注：接下来讲的都是 $r1-l1<a\times b$  的情况如何处理，其余情况都直接输出一个区间的最大值即可。

要考虑两种情况。这个和直接的 ST 表有那么一点点小区别，直接 ST 表，一定保证要查询的 $l\leq r$，但是这一题，因为是取模运算，有可能会 $l1>r1$。所以就分两种情况 $l1\leq r1$ 与 $l1>r1$ 进行讨论。（讲完之后，你会发现其实本质上是一样的。）

**当 $l1\leq r1$ 时：**

例子 $1$：$l1=2,r1=9$。需要查询 $[A_2,A_9]$ 中的最大值。

我们掐指一算， $9-2+1=8=2^3$，查询的可以表示为 $[A_2,A_{2+2^3-1}]$ 中的最大值。这不就是 $f[2][3]$ 吗？所以直接输出 $f[2][3]$即可。

例子 $2$：$l1=4,l2=11$。

还是掐指一算，要求的是 $[A_4,A_{4+2^3-1}]$ 的最大值。直接输出 $f[4][3]$即可。

例子 $3$： $l1=2,r1=11$。需要查询 $[A_2,A_{11}]$ 中的最大值。

这回 $11-2+1=10$，不是 $2$ 的整数幂了。所以，刚刚的方法肯定不行。回顾刚刚我们推导 $f$ 数组的方法，我们再查询中，仍然可以使用**分治思想**。

既然求一个不好求，那就把你分成两个。对于这种情况，我们发现将例子 $1$ 与例子 $2$ 合起来，实际上就是 $[A_2,A_{11}]$。那么，只需要将两个答案 $\max$ 一下即可。所以，这一次输出的是 $\max(f[2][3],f[4][3])$。

例子 $4$：$l1=6,r1=25$。

这次我们将 $l1$ 与 $r1$ 一般化了。$25-6+1=20$ 仍然不是 $2$ 的整数次幂。回想刚才的分治方法，我们把一个区间变成了两个长度为 $2$ 的整数次幂的区间，而且要覆盖整个大区间，再进行 $\max$。

是不是想到刚才预处理的 $log$ 数组了？刚才我们得出了一个重要结论，那就是  $\dfrac{i}{2}<2^{log[i]}\leq i$。带入 $i=20$，$10<2^{log[20]}\leq 20$。因此，只要用两个长度为 $2^{log[20]}$ 的数组，就能够覆盖整个区间。

$log[20]=4$，$2^{log[20]}=16$。所以，可以把区间 $[A_6,A_{25}]$ 拆分成 $[A_6,A_{21}]$ 和 $[A_{10},A_{25}]$。因此，应该输出 $\max(f[6][4],f[10][4])$。

通过上面四个例子，我们进行总结，从特殊到一般，不难得出：

应当输出 $\max(f[l1][log[r1-l1+1]],f[r1-2^{log[r1-l1+1]}+1][log[r1-l1+1]])$。这个公式看起来很吓人，其实拆分开来看，也是很浅显的。这里就不多加解释了，~~毕竟刚刚举了 $4$ 个例子呢。~~

**当 $l1>r1$ 时：**

要求的实际上是“区间 $[A_{l1},A_{a\times b-1}]$ 的最大值”和“区间 $[A_0,A_{r1}]$ 的最大值”的最大值。
即输出 $\max\{\max\{A_i\},max\{A_j\}\}(i\in[l1,a\times b-1],j\in[0,r1])$。

例如 $l1=10,r1=5,a\times b=20$ 时，实际上只用输出 $\max\{\max\{A_i\},max\{A_j\}\}(i\in[10,19],j\in[0,5])$。

所以实际上就是两个情况 $1$ 再进行 $\max$。简单的计算之后，可以发现应当输出：$\max\{\max\{f[l1][log[a\times b-l1]],f[a\times b-2^{log[a\times b-l1]}][log[a\times b-l1]]\},max\{{f[0][log[r1+1]],f[r1-2^{log[r1+1]}+1][log[r1+1]]}\}\}$。建议把两个 $\max$ 分开看。实际上就是套公式。

至此，我们把所有的求值方法都讲解完毕了。

### 代码建议

~~自认为已经讲的非常详细了，~~ 所以我就不提供代码了。可以按照下面的每一句话，翻译成机器语言编写：

1. 输入 $a,b,q$。
2. 求出 $A$ 数组 $A_0\sim A_{a\times b-1}$ 的值。并求出该区间内的最大的 $A_i$，记作 $k$。
3. 预处理 $f$ 数组和 $log$ 数组。公式见上文。
4. 输入 $q$ 组 $l,r$。
5. 判断 $r-l$ 与 $a\times b$ 的大小关系。如果 $r-l\geq a\times b$，则直接输出 $k$。
6. 求出 $l1$ 和 $r1$。
7. 分两类情况 $l1\leq r1$ 和 $l1>r1$，套用公式并输出答案（记得换行）。

两个小提示：

1. $log$ 是一个函数，为了避免重复，建议使用 $lg$ 这个名字。
2. 出现 $2^n$ 运算，可以使用位运算 ``` 1<<n ``` 来代替。

全文完。谢谢审核大大审阅。