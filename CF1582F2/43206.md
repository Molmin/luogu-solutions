本题比 `CF1582F1` 的数据有所加强， $n$ 的范围达到了 $10^6$ ，每个整数 $a_i$ 的范围也加到了 $5000$ ，考虑动态规划，一个一个数字的加进来，看看能组成的异或值会不会变多。


做题的时候的思路是这样走的，不想看的同学可以直接跳到下面正解的部分。先考虑一个复杂度高的算法，发现题目给的空间 `500M` 比较多，如果所有数字都是 $5000$ 以内的，则最终得到的异或值不会超过 $m = 1<<13$ ，空间足够开 $m \times m$ 的二维数组。

题目中有一个关键的话，我们选中数列中的一个子序列，这个子序列是严格上升的，那么对于每个子序列，我们可以记录当前的结尾。后面加入新的 $a_k$ 进来的时候，找前面的结尾比 $a_k$ 小的，可以接在它后面，得到更长的序列，而前面得到的异或值 $x$ ，我们可以得到新的异或值 $x \oplus a_k $，这里的 $\oplus$ 代表异或运算。

定义 $dp[i][j]$ 表示对于前 $k$ 个数字，当结尾是 $i$ 的时候，异或值能不能组成 $j$ ，如果能就记录 $1$ ，不能就记录 $0$ .那么当加入 $a_k$ 的时候，扫一遍这个数组的比 $a_k$ 小的行，再扫一遍每一列，如果 $dp[i][j]$ 是 $1$ ，就把 $dp[a_k][j \oplus a_k]$ 标记为 $1$ 。那么我们得到了一个复杂度是$O(n \times m^2)$的算法。

考虑优化，我们发现dp数组里面每个位置都只存 $0$ 和 $1$ ，信息密度比较低，每次扫一行去找 $1$ 的位置比较费时间。而且每次对于新加进来的数字 $a_k$ ，都要枚举前面的每一行，也是非常费时间。于是改一下定义的方式，不用二维数组，而是用`vector`数组。

**正解部分：**

定义：

`vector<int> l[MAXN];`

用 `l[i]` 这个 `vector` ，去装所有的结尾小于 $i$ 的子序列中，能得到哪些异或值。

然后枚举每一个 $a_k$ ，对于当前的 $a_k$ ，遍历一下 $l[a_k]$ ，把里面每个数字 $x$ 拿出来，再把 $x \oplus a_k$ 放到 $l[a_k+1],l[a_k+2]...l[m-1]$ 这些 `vector` 里面。我们发现，如果 $x$ 被从 $l[a_k]$ 中拿出来并且转移到别的位置以后，这个 $x$ 就可以从 $l[a_k]$ 这个 `vector` 中删掉了，因为如果下次有相同的 $a_k$ 进来，拿出来相同的 $x$ 去做转移，只会得到重复的结果。所以我们需要保证每个 `vector` 里面不进重复的元素，这个用一个二维数组标记一下就可以了。这样我们可以得到一个均摊复杂度 $O(m^3)$ 的做法，因为一共最多只有 $m^2$ 个数，每个数最多转移到 $m$ 个数。

但是这个复杂度还是不够的，还需要继续优化。考虑一下当我们把某个异或值 $y$ 插入到 $l[a_k+1],l[a_k+2]...l[m-1]$ 这些 `vector` 里面以后，比如下次又要把同一个数字 $y$ 插入到 $l[a_k'+1],l[a_k'+2]...l[m-1]$ 这些 `vector` 里面，其实如果 $a_k'$ 比 $a_k$ 小，那么只需从 $a_k'$ 到 $a_k-1$ 这个范围内插入就行了。那么我们可以再开一个数组 `th` ， $th[i]$ 表示对于 $i$ 这个异或值，对于 $x>=th[i]$ ，所有的 $x$ 的 $l$ 列表里面都已经插入过 $i$ 了。这样均摊复杂度会降到$O(m^2)$


代码时间：
```
#include <iostream>
#include <algorithm>
#include <cstring>
#include <vector>

using namespace std;
const int MAXN = 1 << 13;
int n;
vector<int> l[MAXN];//l[i]表示我们找到的子序列结尾小于i的时候，异或值可能是哪些
int th[MAXN];//th[i]表示对于i这个异或值，对于x>=th[i]，所有的x的l列表里面都已经插入过i了
int ans[MAXN];//每个异或值是否出现过

int main() {
    cin >> n;
    for (int i = 0; i < MAXN; ++i) {
        l[i].push_back(0);
        th[i] = MAXN;
    }
    for (int i = 1; i <= n; ++i) {
        int a;
        cin >> a;
        for (int j = 0; j < l[a].size(); ++j) {
            int u = l[a][j];//当前可以得到u这个值
            int v = u ^ a;//可以转移去v
            ans[v] = 1;
            //此时l[a[i]+1]...l[MAXN-1]里面都可以添加一个v
            //之前th[v]以后的已经添加过了
            while (th[v] > a) {
                th[v]--;
                l[th[v]].push_back(v);
            }
        }
        l[a].clear();
        l[a].shrink_to_fit();
    }
    int cnt = 0;
    for (int i = 0; i < MAXN; ++i) {
        if (ans[i]) {
            cnt++;
        }
    }
    cout << cnt << endl;
    for (int i = 0; i < MAXN; ++i) {
        if (ans[i]) {
            cout << i << " ";
        }
    }
    cout << endl;
    return 0;
}
```


