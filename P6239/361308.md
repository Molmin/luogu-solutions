[博客使用更好吃（bushi)](https://zqs2020.gitee.io/2021/01/06/luogu-P6239/)

[传送门](https://www.luogu.com.cn/problem/P6239)

状压DP好题。自己太弱没想出来好不容易才把咕咕的题解看懂QAQ。所以特地来对咕咕的题解一些省略了的地方做补充

咕咕说的一个naive想法：$f_{i,j,s}$ 表示前 $i$ 个点，连了 $j$ 条边，后 $k$ 个点的度数奇偶二进制表示为 $s$ 的方案数。显然转移起来有重复计算，因为我们根本不知道哪些点、边连了那些没有连。

I am too naive。还真就只想到了这个naive想法，而正解的状态应该是：$f_{i,j,s,t}$ 表示前 $i$ 个点，$j$ 条边，后 $k$ 个点的度数奇偶二进制表示为 $s$，当前点 $i$ 只考虑到了和 $i-k\sim i-t-1$ 个点连边（**注意，不一定和这些点连了边，但是 $i$ 和 $i-t-1$ 后的点一定没有连边**）的方案数。

具体的，第 $x$ 个点对应的二进制位为 $i-x$。如果点 $i$ 度数为奇数，第 $i$ 位为 $1$，反之为 $0$。

转移的情况，首先最容易想到的是直接跳过 $i-t-1$ 这个点，在今后不再 $i$ 考虑和 $i-t-1$ 连边，考虑 $i$ 与 下一个点 $i-t-2$ 的连边情况，说白了也就是什么也不干，不加点也不加边,对应的式子为（这个东西不叫转移方程，因为是刷表法，它只是一个更新公式）：

$$f_{i,j,s,t-1}+=f_{i,j,s,t}$$

其次，还可以再与 $i-t-1$ 这个点连一条边。边数加一，并且此时点 $i$ 与点 $i-t-1$ 度数的奇偶性发生改变，所以 $s^{\prime}$ 是 $s$ 与这两个点对应的二进制位取异或的结果：

$$f_{i,j+1,s^{\prime},t}+=f_{i,j,s,t}$$

$s^{\prime}$ 为 $s$ 对 $2^0$ （第 $i$ 个点对应的二进制位）与 $2^{t-1}$ （第 $i-t-1$ 个点对应的二进制位）取异或的结果。

如果当前已经把 $i$ 与 $i-k\sim i-1$ 的所有连边都考虑完了，就可以加入新的点 $i+1$ 了。但是注意，这个时候 $i+1$ 由于题目规定不能往 $i-k$ 连，而题目要求每一个点的度数都是偶数，所以 $i-k$ 的度数必须为偶数才能转移。

$$f_{i+1,j,s^{\prime},min(i,t)}+=f_{i,j,s,0}$$

$s^{\prime}$ 为 $s$ 左移一位的结果。

输出 $f_{n,m,0,0}$。

虽然思路来自咕咕，但是看在我这么认真写题解的份上~~点个赞再走吧QAQ~~

# $Code:$
```cpp
#include <cstdio>

const int MOD = 1e9 + 7, N = 32;
inline int min(const int x, const int y) {return x < y ? x : y;}
inline void upd(int &x, const int y) {if ((x += y) >= MOD) x -= MOD;}
int f[N][N][1025][N];

int main() {
	int n, m, k;
	scanf("%d%d%d", &n, &m, &k);
	f[1][0][0][0] = 1;
	for (int i(1); i <= n; ++ i) {
		for (int j(0); j <= m; ++ j)
		for (int S(0); S < 1 << k + 1; ++ S) {
			for (int t(min(i - 1, k)); t; -- t) {
				upd(f[i][j][S][t - 1], f[i][j][S][t]);
				if (i > t) upd(f[i][j + 1][S ^ 1 ^ 1 << t][t], f[i][j][S][t]);
			}
			if (!(S & (1 << k))) upd(f[i + 1][j][S << 1][min(i, k)], f[i][j][S][0]);
		}
	}
	printf("%d", f[n][m][0][0]);
	return 0;
}
```