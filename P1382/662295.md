### 并查集

##### 最优解 #1(2023.6.15)

------------

#### 前言

优点：好想 & 好写 & 效率较高。

类似[白雪皑皑](https://www.luogu.com.cn/problem/P2391)中的区间染色，后被染色的区间颜色会覆盖任何先前被染色的区间颜色，区间的染色存在顺序，从后到前的染色顺序可以直接固定区间的颜色，不接受之后（实际操作序列中之前）的染色；在本题中更高的楼房会覆盖更低的楼房的天际线，和白雪皑皑类似。

笔者将这种题目的性质大致总结如下：**对于序列的操作存在优先级，优先级高的操作覆盖优先级低的操作**。所以，如果按照优先级进行操作，配合并查集就可以实现对于序列每个元素的 $O(1)$ 操作。

------------

#### 并查集优化暴力染色

暴力思路：使用数组 $c$ 记录区间 $[-10^9,+10^9]$ 上每个整数点的高度，对位置 $c_i$ 取原高度和当前楼房高度 $\max$，所有操作结束后遍历 $c$，统计拐点数并记录其位置输出。

无需分析，本题的时间和空间限制显然无法接受此等做法的花费。

一个显而易见的优化：由于答案只要求统计天际线拐点个数和坐标，只考虑可能存在拐点的位置，即每栋楼房的最左端和最右端。离散后对每个位置更新最大高度，最终扫描一遍离散序列，统计拐点数量并记录位置、输出。

由于每栋楼房离散后被序列中的两个点代替，时间复杂度瓶颈为染色操作的 $O(n^2)$。

现在使用并查集，楼房的高度已经提前得知，从高到低对楼房排序后，依次更新每个位置的高度，已经更新过的位置用并查集跳过。由于使用并查集，每个位置至多被染色 $1$ 次，染色操作的时间复杂度优化至均摊 $O(n\log n)$，总体时间复杂度 $O(n\log n)$。

至此，可以通过此题。

```cpp
#include<algorithm>
#include<iostream>
#include<utility>
#include<vector>
using namespace std;
struct House{int h,l,r;}s[100001];
int n,cnt,c[200001],f[200001],p[200001];//数组c记录离散后每个点的高度
vector<pair<int,int> > v;//记录天际线拐点的坐标
bool cmp(const House &x,const House &y){
	return x.h>y.h;
}
int ask(const int &x){
	if(x==f[x]) return x;
	return f[x]=ask(f[x]);
}
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>s[i].h>>s[i].l>>s[i].r;
		p[i]=s[i].l,p[i+n]=s[i].r;
	}
	sort(s+1,s+n+1,cmp);//排序和离散化
	sort(p+1,p+n*2+1);
	cnt=unique(p+1,p+n*2+1)-p-1;
	for(int i=1;i<=cnt;i++) f[i]=i;//并查集初始化
	for(int i=1;i<=n;i++){
		s[i].l=lower_bound(p+1,p+cnt+1,s[i].l)-p;
		s[i].r=lower_bound(p+1,p+cnt+1,s[i].r)-p;
		for(int j=ask(s[i].r-1);j>=s[i].l;j=ask(j-1))
			c[j]=s[i].h,f[j]=f[j-1];//并查集更新
	}
	for(int i=1;i<=cnt;i++) if(c[i]!=c[i-1]){
		v.push_back({p[i],c[i-1]});
		v.push_back({p[i],c[i]});
	}
	cout<<v.size()<<'\n';
	for(auto &i:v) cout<<i.first<<' '<<i.second<<'\n';
	return 0;
}
```

拐点的出现是因为该位置存在高度变化，其必定成对出现，所以可以依次比较每个位置的高度来记录答案。为了防止两栋楼房之间的缝隙被错误填充，将楼房离散后的右端点 $-1$，连带解决了最后一个天际线拐点 $y$ 坐标应为 $0$ 的处理，不需要额外操作。

------------

#### 闲话

笔者练习扫描线时看到了此题，联想到并查集，翻阅题解区却没找到一篇提及并查集的题解，最终抱着偷懒的心态实现并通过了，几个月后心血来潮想要写一篇题解。

2023.6.15:据说这类优化被称作“并查集惰性删除”。