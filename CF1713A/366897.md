## 题意简述

从平面直角坐标系的原点出发，需要经过所有在坐标轴上的给定的点（“宝箱”）然后回到原点，不限顺序。每次移动可以向上、下、左、右四个方向移动一个单位长度。求出最少需要移动几个单位长度。

## 分析

![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1713A/2b602eaf16bce39f930bfcfcfb2b3ed7bd31fbab.png)

上图是样例的第 $1$ 测试组给出来的解释图片。我们可以把这个方案描述为`(0,0)->(1,0)->(1,1)->(1,2)->(0,2)->(-1,2)->(-1,1)->(-1,0)->(-1,-1)->(-1,-2)->(0,-2)->(0,-1)->(0,0)`，共 $12$ 次移动。

由于矩形的对边相等，我们能很容易地发现上面这种方案与下面这种只在坐标轴上移动的方案同为最优方案：`(0,0)->(1,0)->(0,0)->(0,1)->(0,2)->(0,1)->(0,0)->(-1,0)->(0,0)->(0,-1)->(0,-2)->(0,-1)->(0,0)`。

这种方案的特点是：沿着每一条半轴移动到距离原点最远的一个“宝箱”后返回原点。当然，如果一条半轴上没有“宝箱”，就不需要在这条半轴上移动。

我们可以使用四个变量 $maxx$、$minx$、$maxy$、$miny$ 分别记录 $x$ 轴正半轴、$x$ 轴负半轴、$y$ 轴正半轴、$y$ 轴负半轴上距离原点最远的“宝箱”与原点的距离。**因为这些变量每个都负责一条半轴，所以它们的初始值都应该为 $0$。**

因为到达一条半轴上所有的“宝箱”后需要返回原点，所以答案为 $2\times (maxx+maxy+\lvert minx\rvert+\lvert miny\rvert)$。由于 $minx$、$miny$ 为非正数，答案可以化简为：$2\times (maxx+maxy-minx-miny)$。

## 代码

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
void work()//每个测试组（test case）
{
	int n,x,y,maxx=0,minx=0,maxy=0,miny=0;//分别记录 x 轴正半轴、x 轴负半轴、y 轴正半轴、y 轴负半轴上距离原点最远的“宝箱”与原点的距离
					       //若初始值不为 0，则有可能有“宝箱”被重复到达
	scanf("%d",&n);
	for(int i=1;i<=n;i++)//读入每一个“宝箱”的坐标
	{
		scanf("%d%d",&x,&y);
		if(x<minx) minx=x;
		if(x>maxx) maxx=x;
		if(y<miny) miny=y;
		if(y>maxy) maxy=y;
	}
	printf("%d\n",2*(maxx+maxy-minx-miny));//求出答案，输出
}
int main()
{
	int t;
	scanf("%d",&t);
	while(t--)
	work();
	return 0;
}
```