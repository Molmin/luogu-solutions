以下均为赛时想法。

---

首先这个变换是显然的：每次操作就是交换差分，那么相当于差分可以随便重排。

化一下这个方差的式子，就是 $n \times \sum a_i^2- (\sum a_i)^2$。

然后 $a$ 同时减小某个数对答案是没有影响的，那么可以钦定 $a_1=0$。

---

然后卡了很久，尝试去猜结论，发现样例它的差分是 `2 1 2`，可以猜测到这个差分是先减小后递增的，打了个暴力确实如此，具体的证明不会，但是感性理解应该是不难的（这样数就会尽可能的“均匀”）。

---

然后就容易想到做法了：首先把差分重排，从小到大考虑，那么每个差分要么插在首要么插在尾，但是两个想减的东西很难维护，那么可以想当把一维放到状态里去，经过一些尝试后发现就是 $\sum a_i$，即 $dp_{i,j}$ 表示处理到前 $i$ 个差分，这 $i$ 个差分还原出来的 $a_i$ 的序列的和是 $j$，在这个情况下的 $\sum a_i^2$ 的最小值，然后你发现无论是插头上还是尾巴上都是可以快速算出新的 $\sum a_i$ 和 $\sum a_i^2$ 的。

---

这样子的复杂度貌似是 $\mathcal{O}(n^2 \times \max a_i )$ 的，怎么办呢？发现很多差分都是 $0$，不为 $0$ 的差分只有 $\max a_i$ 个，为 $0$ 的转移是无意义的根本不用管，那么就可以做到 $\mathcal{O}(n \times (\max a_i)^2)$ 的复杂度，需要滚动数组。[赛时代码](https://www.luogu.com.cn/paste/dfg1yjdm)。

---

这种题大家肯定都会做，我又垫底了。

---
---
---

过了你谷民间数据，应该没假吧。

---

upd：过了。