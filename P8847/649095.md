# 1、题意
给你一个由 $1$ 和 $-1$ 构成的数列，将其重构，使最大子段和最小。

# 2、分析
首先，只要数列里含有 $1$ 那么最大子段和最小为 $1$，所以我们考虑下面两种情况：  
- $-1$ 的个数多于等于 $1$，那么我们只要用 $-1$ 将 $1$ 全部隔开，然后将所有多余的 $-1$ 排在数列尾即可，此时最大子段和为 $1$。  
$$\{1,-1,1,-1,1,\dots,1,-1,-1,-1,-1\}$$
- $1$ 的个数多于 $-1$，那么我们为了防止多个 $1$ 在一起使最大子段和大，那么我们尽量用 $-1$ 去将 $1$ 隔开使全前缀和为 $0$，多余的 $1$ 全部排在数列尾即可，此时最大子段和为 $1$ 的个数减去 $-1$ 的个数的差。
$$\{1,-1,1,-1,1,\dots,1,-1,1,1,1,1\}$$

# 3、代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
	int n,a,z=0,f=0;
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>a;
		if(a>0)
			z++;//统计1的个数 
		else
			f++;//统计-1的个数 
	}
	if(z<=f)//-1比1多 
	{
		for(int i=1;i<=z;i++)
			cout<<"1 -1 ";
		for(int i=1;i<=f-z;i++)
			cout<<"-1 ";
	}
	else//1比-1多 
	{
		for(int i=1;i<=f;i++)
			cout<<"1 -1 ";
		for(int i=1;i<=z-f;i++)
			cout<<"1 ";
	}
	return 0;
}

```
