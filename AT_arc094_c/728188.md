# 思路

想了好久呜呜，想出来之后感觉这道题确实挺妙的，首先无论所 $a_{i}$ 有多少情况，第一个人肯定是要把他给归到零，因为这样第二个人会运用大把的步数把       $b_{i}$ 归到零，这样是最优的，也就是整个程序的基值就是所有 $a_{i}$ 的值，~~那如果这个第一个人当老阴 13，~~趁我们不注意给大的 $a_{i}$ 疯狂减，最后到零，相当于我们亏了一个 $b_{i}$ 的操作，且得不偿失，所以我们还要判断   $a_{i}$ 比 $b_{i}$ 大时该怎么办，首先，我们用判断每个 $b_{i}$ 的情况，用基值减去 $b_{i}$，判断最大值，这样既能满足第一个人的最好情况，这样即让步数最大，情况最优，~~也不用担心被阴拉！~~

# 代码

```
#include<bits/stdc++.h>
using namespace std;
#define int long long
int a[10000005];
int b[10000005];
main()
{
	int n;
	cin>>n;
	int sum=0;
	for(int i=1;i<=n;i++){
		cin>>a[i]>>b[i];
		sum+=a[i];
	}
	int max1=0;
	for(int i=1;i<=n;i++){
		if(a[i]>b[i]){
			max1=max(max1,sum-b[i]);
		}
	}
	cout<<max1<<endl;
    return 0;
}
```
