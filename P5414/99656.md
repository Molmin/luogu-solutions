这道题说的是求最小成本，但是我想了想，得出了一个伟大的结论——~~我不会~~很难。然后我就接着想，有没有办法可以不用求最小成本的方法求最小成本呢，其实是有的。我常常看别人解题是用逆向思维的，我终于也能用上一场了——因为他排序是最小成本，那么除了排过序的数字以外，就是最大的了。那么我们求出这个数每次需要进行排序的两个数（我用的是冒泡原理，冒泡是每两个数都进行一次比较）中最大的值加上当前的值（每一次排序用的成本），然后每次循环都打擂台，求出最大的代价，也就是除去排过序的数以外的最大的和（这样才能求出最小代价），紧接着输出所有数字的和减去除去排过序的数以外最大的数字总和，剩下的就是最小的成本了！话不多说，上代码：
```
#include<bits/stdc++.h>
using namespace std;
int t,tt[1005];
int n;
long long a[105],s,sum;
int main()
{
	scanf("%d",&t);
	for(int i=1;i<=t;i++)
	{
	     scanf("%d",&n);
             for(int j=1;j<=n;j++)
	     {scanf("%d",&a[j]);sum+=a[j];}
	     for(int j=1;j<=n;j++)
	     {
	       for(int k=1;k<j;k++)
	       {
		   if(a[k]<=a[j])
		   tt[j]=max(tt[j],tt[k]);
	       }
		 tt[j]+=a[j];
		 if(tt[j]>s)s=tt[j];
             }
	  cout<<sum-s<<endl;
	  sum=0;
	  s=0;
	  memset(tt,0,sizeof(tt));
	}
   return 0;
}
```
//本人的宗旨就是：不写让人看不懂的题解，~~然而我还是写了~~好久没有发过题解了，管理员就让过了吧