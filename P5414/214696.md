> ~~又来写题解了。/hh~~

## 题意概述

通过调换数字 $K_{c_1},K_{c_2},\cdots,K_{c_m}$，对长度为 $n$ 的序列 $K$ 进行升序排序，所用成本为 $K_{c_1},K_{c_2},\cdots,K_{c_m}$。求排序的最小成本。

## 大致思路
调换 $K_{c_1},K_{c_2},\cdots,K_{c_m}$ 其实就是将 $K$ 中其他数字留在原来的位子上。显然，留下来的数字必须是升序排列的。因为调动的数字个数 $m$ 越大，耗费就越多，所以要让尽量少的数字调动。那么，留下来的数字就是最多的，也是升序排列的。

看到这里，你是不是想到了 $dp$ 的经典问题：最长不降子序列。

与其说调换数字，不如说是**保留数字**。保留**最多的数字**，直接求**最长不降子序列**就行，但 $F_i$ 的意义是得改变的。

综上，代码就能写出来了！

另外，记得**多组数据**！

## CODE

```cpp
#include <stdio.h>
int n, a[105], f[105];
int main(void) {
    int t;
    for (scanf("%d", &t); t--; ) {
        scanf("%d", &n);
        int ans1 = 0, ans2 = 0;
        for (int i = 1; i <= n; ++i)
            scanf("%d", &a[i]), ans1 += a[i];
        for (int i = 1; i <= n; ++i) {
            f[i] = 0;
            for (int j = 0; j < i; ++j)
                if (a[j] <= a[i])
                    f[i] = f[j] > f[i] ? f[j] : f[i];
            f[i] += a[i];
            ans2 = f[i] > ans2 ? f[i] : ans2;
        }
        printf("%d\n", ans1 - ans2);
    }
    return 0;
}
```

## The end. Thanks.

~~（走过路过是不是要赞过呢？~~