### 题目大意
- 给定一个长为 $n$，首项为 $a$，公差为 $d$ 的等差数列 $x$。

- 在数列中任选两个数 $x_i$ 与 $x_j$，若 $x_i+x_j$ 为偶数且 $\dfrac{x_i+x_j}{2}$ 不在数列中，那么将该数插入等差数列中。

- 输出最多能插入的数的个数。

整理信息，我们可以将题目大意转换为：
- 给定一个长为 $n$，首项为 $a$，公差为 $d$ 的等差数列 $x$。

- 若 $x_{i+1}-x_i$ 为偶数，那么在数列中插入 $\dfrac{x_i+x_{i+1}}{2}$，一直操作下去，直至所有的 $x_{i+1}-x_i$ 都为奇数。

- 输出最多能插入的数的个数。

### 解题思路
看数据规模，就知道是数学题。解决数学题，有一种非常高效的方法，那就是~~找规律~~**从特殊到一般，推导公式**。

显然，答案与首项 $a$ 无关。

咱们就以下面这个数据为例：$n=4$，$a=10$，$d=24$。即这个数列为 $[10,34,58,82]$。

- 第一次操作后：$[10,22,34,46,58,70,82]$，共插入了 $3$ 个数。

- 第二次操作后：$[10,16,22,28,34,40,46,52,58,64,70,76,82]$。共插入了 $6$ 个数。

- 第三次操作后：$[10,13,16,19,22,25,28,31,34,37,40,43,46,49,52,58,61,64,67,70,73,76,79,82]$，共插入了 $12$ 个数。

总共插入了 $21$ 个数，所以应当输出 $21$。

我们发现，**每一次插入的数都是上一次插入的数的二倍**。如果我们将每次插入的数的个数定为一个序列 $s$，则有 $s_i=s_{i-1}\times 2$。

那么 $s_1$ 为多少呢？显然，$s_1=n-1$。

所以我们只需要求出序列 $s$ 有几项，再进行求和，就可以得到答案了。

再一次对操作进行分析：

- 原数列的公差为 $24$。
- 第一次操作后，数列的公差为 $12$。
- 第二次操作后，数列的公差为 $6$。
- 第三次操作后，数列的公差为 $3$。至此，无法继续添加数了。

每一次操作后，公差都变为上一次的一半，直到公差成为一个奇数。
所以，序列 $s$ 的项数，就是公差 $d$ 的 $2$ 的**因数的个数**，可以将它记为 $k$。因为时间充裕，我是用暴力求出 $k$ 的。当然，实际上也可以用 $O(1)$ 求出来。

因此答案就是 $(n-1)(2^k-1)$。经检验发现公式是正确的。

### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
long long t,n,a,d;
long long k,f[100];
int main(){
	cin>>t;
	while(t--){
		k=0;
		cin>>n>>a>>d;
		while(1){
			if(d%2==1)break;
			d/=2;
			k++;
		}
		cout<<(n-1)*((1<<k)-1)<<endl;
	}
	return 0;
}
```


