题意比较简单这里不再赘述。

## 思路
我们发现合法的操作次数其实就是操作后序列中增加的数的个数。因此可以观察操作后的序列。

没有进行过操作的等差数列 $x$ 应该如下所示：

$x_1 = a$

$x_2 = a + d$

$x_3 = a + 2d$

$x_4 = a + 3d$

$x_5 = a + 4d$

$\vdots$

$x_n = a + (n - 1)d$

如果就以上面的数进行操作，可以得到如下的数列：

$x_1 = a$

$x_2 = a + \dfrac{d}{2}$

$x_3 = a + 2d$

$x_4 = a + \dfrac{3d}{2}$

$x_5 = a + 3d$

$\vdots$

$x_{2n - 2} = a + \dfrac{(n - 1)d}{2}$

$x_{2n - 1} = a + (n - 1)d$

对比原来的序列，会发现多出了诸如 $\dfrac{d}{2}$ 这样的分数（假设 $d$ 可以被 2 整除），如果再就以这些数进行操作，就会多出诸如 $\dfrac{d}{4}$ 这样的分数（假设 $d$ 可以被 4 整除）。

也就是说，我们可以通过判断 $d$ 是否可以被 2，4，8，16 $\ldots$ 整除，来确定可以增加进序列的数的数量，即合法的操作次数。

这样的时间复杂度是 $O(\log d)$ 的，可以通过这道题。

而计算增加进序列中的数也比较简单。假设 $d$ 可以整除的最大的 2 的 $n$ 次幂 为 $x$，则序列中数的总数为 $x(n - 1) + 1$。再减去原来的 $n$ 也就是 $x(n - 1) + 1 - n$ 。

Code：
```cpp
#include <bits/stdc++.h>
using namespace std;

typedef long long ll;

int main()
{
    int T;
    scanf("%d",&T);
    while(T--)
    {
        ll n,a,d;
        scanf("%lld%lld%lld",&n,&a,&d);
        for(ll i = 1;;i <<= 1)
        {
            if(d & 1) 
            {
                printf("%lld\n",i * (n - 1) + 1 - n);
                break;
            }
            d >>= 1;
        }
    }
    return 0;
}
```