蒟蒻第一次打月赛，激动地点开第一题：
> ~~哇，好简单！~~

30min 后，终于 AC 了。（我好菜啊）

-----
## 正文：

首先，这个数列是等差数列，也就是说，**每两个相邻元素所构成的子区间 $[x_i,x_{i+1}]$ 中，能产生的新数是一样的**。那么，我们就只用算出每两个元素之间能产生多少个新数，再乘以子区间数 $n-1$ 即可。

可能大家会有疑问，万一两个不同子区间中产生的新数又产生了新数呢？

其实原因很简单，因为这两个数所产生的新数，**必定会由其中一个子区间中的数产生**，那么这时候就重复计算了。所以直接把问题简化成计算两个相邻元素产生的新数即可。

我们来推导一下吧：

设有一集合 $A$，当前有两个元素 $\left \{ A_1,A_2 \right \}$。

首先判断 $A_1+A_2$ 是否是偶数，若不是，则不能再产生数。

根据题目，$A_1$ 为首项，公差为 $d$。

$\therefore A_2 = A_1 + d$

$\therefore A_1 + A_2 = 2A_1 + d$

$\therefore \frac{A_1 + A_2}{2} = A_1 + \frac{d}{2}$

所以，**判断 $A_1 + A_2$ 是否为偶数，就是 $d$ 是否为偶数**。这也就等于，如果 $d$ 为奇数，就连一个数也产生不了，答案为 $0$。

若设 $d$ 为偶数，则第一次后的集合变成了 $\left \{ A_1,\frac{A_1+A_2}{2}, A_2 \right \}$。这个数列也是一个等差数列，因为前后两个子区间产生的新数是一样的，所以直接判断左子区间 $\left \{ A_1,\frac{A_1+A_2}{2} \right \}$。此时 $d$ 又更新为 $\frac{A_1+A_2}{2}-A_1$。继续判断 $d$ 的奇偶，直到 $d$ 为奇数才停止。

又容易发现：

$\because d_1 = \frac{A_1+A_2}{2}-A_1$

$\therefore d_1 = \frac{A_1}{2}+\frac{A_2}{2}-A_1=\frac{A_2}{2}-\frac{A_1}{2}=\frac{A_2-A_1}{2}$

又 $\because d_0 = A_2 - A_1$

$\therefore d_1 = \frac{d_0}{2}$

即，**每次产生新数后，公差 $d$ 就除以 $2$**。

到此，思路就已经出来了。

本题像是一个二分，每次二分子区间，只取左或右区间，每次将 $d$ 除以 $2$，判断其奇偶。

开始，子区间数量为 $1$，没有新数。

第一次，子区间数量为 $2$，原来的新数为 $0$，产生的新数为 $1$，共产生 $1$ 个数。

第二次，子区间数量为 $4$，原来的新数为 $1$，产生的新数为 $2$，共产生 $3$ 个数。

第三次，子区间数量为 $8$，原来的新数为 $3$，产生的新数为 $4$，共产生 $7$ 个数。

每次产生的新数比原来多 $1$。设答案为 $ans$，则 $ans_i = 2ans_{i-1}+1$。

## Code:（其中的位运算有解释）

```cpp
#include <cstdio>
int t;
long long n, a, d; // 注意开 long long
int main() {
	scanf("%d", &t);
	while(t--) {
		scanf("%lld %lld %lld", &n, &a, &d);
		long long ans = 0;
		while(!(d & 1)) { // d 为偶数
			ans = (ans << 1) + 1; // ans = ans * 2 + 1
			d >>= 1; // d /= 2;
		}
		printf("%lld\n", ans * (n - 1)); // n - 1 个相邻的数对，每个数对答案为 ans
	}
	return 0;
}   
```

#### 第一次写题解，若有错误请大佬指出。