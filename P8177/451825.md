[题目传送门](https://www.luogu.com.cn/problem/P8177)

作为月赛的第一题，这道题目实在是毒瘤（虽然有可能是我太菜了），尤其是题意可能有点难理解，理解了就能推公式了。

首先，有一点很显然，那就是无论你怎么选 $x$ 和 $y$，结果都是一样的。

接着就是题目中啰啰嗦嗦说了一大堆，其实就是求两个数的整数平均数，那很明显我们只需要找两个平均数是整数的数就行了，因为在哪里开始找都是可行的。

还有便是判断是否能进行操作时，只需要判断相邻每两个数的平均数是否是整数，因为相隔偶数个数的两个数的平均数已经存在；而相隔奇数个数的两个数的平均数不是整数（可以举例说明，我就不说了）。

![](https://cdn.luogu.com.cn/upload/image_hosting/onhi9nw6.png)

如图，黑色的是原来的数列，红色的是第一次遍历数组进行操作后的数列，蓝色是第二次，接着因为相邻两个数的平均数是小数了，所以就不能进行操作了。

咳咳，接下来进入正题：

题目问进行多少次操作，其实就是最后的数列和最开始的数列相差多少个数，以上图的数列为例，答案是 $12$，也就是 $3 \times 4$，不难发现，$4$ 是项数 $n$ 减去 $1$，而 $3$ 是什么回事呢？

显然 $3$ 与公差 $d$ 能平均分多少次有关的，能平均分多少次，就是这个数包含多少个因数 $2$，因此我们可以推出式子，设公差包含因子 $2$ 的格数为 $v$，$j$ 是 $2$ 的 $v$ 次方，答案为 $w$，式子就是：

$w=(n-1)\times(j-1)$

但是，你以为这就完了吗？

注意看题目数据范围，显然不可以使用 int，因此我们需要开 long long。

而且，因为要开 long long，所以求次方不能用 pow 函数了，得自己打。

最后是你们都喜欢的代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
    int t;
    cin>>t;
    for(int i=0;i<t;i++)
    {
    	long long n,a,d;
    	scanf("%lld %lld %lld",&n,&a,&d);
    	long long dd=d;//公差
    	long long bb=0;//指数
    	long long jj=2;
    	long long ll=1;//幂
    	while(dd!=1)
    	{
    		if(dd%jj==0)
    		{
    			dd/=jj;
    			if(jj==2)bb++,ll*=2;
			}
    		else break;
		}
    	printf("%lld\n",(n-1)*(ll-1));//输出
	}
    return 0;
}
```
