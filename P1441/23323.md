

------------
**思路比较简单清晰，看数据范围可以猜到是暴搜 + 01背包**

具体做法敬请参见其他题解，这里讲一下几个小优化。

###### 第一：DFS中的可行性剪枝，是最基础的剪枝之一。

**①如果当前删掉的数已经超过了给定的M，一定是不合法的，剪掉。**

**②如果剩下的数都删掉也达不到给定的M，一定是不合法的，剪掉。**

这是基础中的基础，不过也有一点点小讲究，比如说剪枝的位置，最简单的是放在开头判断一下，这样**理论上来讲**，还是调用了一下这个函数，总会慢一点点点点点点。所以我一般习惯在递归前剪枝，大概这样：

```cpp
	if( N - M - Now + Left ) Dfs( Now + 1 , Left ) ;
	if( M - Left )
	{
		Throw[Now] = true ;
		Dfs( Now + 1 , Left + 1 ) ;
		Throw[Now] = false ;
	}
```

（缩进相对还算规范吧，不喜憋着）

其中Now是我当前选到的个数，Left是我已经舍弃的个数，N和M如题意。

这样我在递归前就剪好，**常数**就小了啊。

###### 第二：一点点01背包中剪枝的小技巧。

```cpp
register int All = 0 ; // 维护当前总和 
	for(register int i = 1 ; i <= N ; i++ )
	{
		if( Throw[i] ) continue ;
		for(register int j = All ; j >= 0 ; j-- )
			Dp[ j + A[i] ] = Dp[ j + A[i] ] or Dp[j] ;
		All += A[i] ;
	}
```

记一个All表示当前选择的所有砝码的质量总和，更新的时候，只用从All的位置往前枚举，可以省掉一多半的时间。

顺便问一下，为什么要排序才能过#8和#9啊……

等我问到or想到了，回来更新题解。