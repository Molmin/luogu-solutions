贪心题，思维巧妙。

不能马上看懂第一篇题解的可以看看。

具体做法就是上面题解所说的：

          对于点i，在点1与点2~（i-1）的路径中找一个最小的插入边权，加入答案。
          
          插入边权的定义为：W=min(W,(dis[1][i]+dis[i][k]-dis[1][k])/2)(2<=k<=i-1)(i>=3)
          
为什么这样做是正确的？

证明如下：

1. 先撇去对路径一端一定是点1的限制，证明后面半句话。假设我们已经求得了i-1个点的“进化树”，如图

![1](https://cdn.luogu.com.cn/upload/image_hosting/22xgltz1.png)

为了使新点连接到树上的那条边权最小，我们可以枚举两个叶子节点，放在这两个点的路径上，连上新边，边权就是上述的插入边权，枚举出每个新点的最小插入边权，加入答案，保证答案最小。

形成新图

![2](https://cdn.luogu.com.cn/upload/image_hosting/0tfu4wsq.png)

假设新点k，接在了u和v的路径上。

因为给出的数据一定是合法的，所以一定可以找出一个连接点（黄点），改变 u（或v）到黄点 以及 黄点到橙点 的边权，使得dis[k][u]和dis[k][v]合法。

那么其他的dis是否也合法？

反证法:不妨再取一个点p，显然**dis[p][k]=dis[p][u]-dis[u][k]+插入边权**,等式右边都是已经合法的，要是dis[p][k]不合法，那么数据也不合法，构造不出这样一棵树，但数据一定是合法的，所以任意的dis[p][k]一定合法，证毕。

这样得出的“进化树”无需考虑树上边权的大小（即黄点在哪里），只要插入的边合法，自然能找出对应的黄点，更新对应的边权，但这些并不需要我们求，毕竟答案只与插入边权有关。

2. 对于每一个新点，我们都需要枚举两维的点作为插入的两端，这样一共是3维循环，如果固定一个端点，就能减少一维循环。正确性证明如下：

从1的证明可知，任取两点做端点一定能保证新点到所有点的dis合法。假设还是点k，接在了u和v的路径上。因为dis[1][k]合法，所以满足：**dis[1][k]+dis[u][k]-dis[1][u]=插入边权**，这个式子正好就是我们贪心的式子，只不过v变成了1，正确性显然。

每一组数据都可以优化到**O(n^2)**

最后附上代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int dis[40][40];
int n,m,i,j,x,tmp,ans;
int main(){
    while(true){
        cin>>n;
        if(n==0) break;
        ans=0;
        for(i=1;i<=n-1;i++){
            for(j=1;j<=n-i;j++){
                cin>>x;
                dis[i][j+i]=dis[j+i][i]=x;
            }
    	}
    	if(n>=2) ans=dis[1][2];
    	for(i=3;i<=n;i++){
            int now=100000000;
            for(j=2;j<=i-1;j++){
                now=min(now,dis[1][i]+dis[i][j]-dis[1][j]);
            }
            ans+=(now/2);
    	}   
    	cout<<ans<<endl;
    }
    return 0;
}
```
