### 前排概述
-----------

一道构造题，有思维难度

本篇题解采用数学归纳法证明递推式

相较于其他题解，应该会更加通俗易懂（雾

### 题目解析
-----------

构造出来的树中，明显分为有编号的节点，与没有编号的节点。有编号的节点有以下特性：

1. 由于每个有编号的节点都是叶子节点，所以没有一条边的两端都是有编号的节点（若有，则其中必有一个是另一个的父亲，不符合叶子节点的定义）

2. 由结论 $1$ 可以得到，新加入一个节点（$1、2$ 除外），它与树（指由已经加入的节点构成的树）的连接边的另一个顶点，一定是在树中一个边上的。而如果是节点 $1、2$，那么他们之间的连边必定有一个无编号的点作中转

看图理解：

![1](https://cdn.luogu.com.cn/upload/pic/56867.png)

节点 $3$ 加入时，另一端一定是在 $1、2$ 之间的这条边上的一点的

其他节点亦是如此

而且不难证明，在同一条边上的点，无论在哪里，本质都是相同的

### 思路
-----------

由于我们求得是边权总和，所以每加入一个点，对答案的贡献就是蓝点(如上图)到新的点的边权

那么这个边权是多少呢

仍以上图为例

![2](https://cdn.luogu.com.cn/upload/pic/56876.png)

设贡献为 $x$

所以可以列出方程 （$M$ 的意义如题目

$M[1, 3] - x + M[2, 3] - x = M[1, 2]$

解得

$x = (M[1, 3] + M[2, 3] - M[1, 2]) / 2$

发现这些都是已知数，就求出了贡献

-----------
那么如果 $n = 4$ 的情况呢

这里我们列举将节点 $4$ 加入到 $2、3$ 之间的路径上

![3](https://cdn.luogu.com.cn/upload/pic/56878.png)

列出方程

$M[3, 4] - x + M[2, 4] - x = M[2, 3]$

解得

$x = (M[3, 4] + M[2, 4] - M[2, 3]) / 2$

到这里，我们可以发现一个规律：

将节点 $i$ 插入到 $j$ 与 $k$ 之间的路径，贡献为：

$(M[j, i] + M[k,i] - M[i, j]) / 2$

证明也十分简单，就如 $n = 3$ 时的情况即可证明

由于每个节点 $i$ 可以插入到 $j \in [1...i - 1]$ 与 $k \in [1...i - 1]$ 且 $k \not = j$ 这两个 集合中的任意一个元素，所以代码也就出来了

### 代码
-----------
```cpp
#include <bits/stdc++.h>
using namespace std;
const int maxn = 30 + 10;
int f[maxn][maxn], n, ans;
int main() {
    while (scanf("%d", &n) && n != 0) {
        ans = 0;
        for (int i = 1; i <= n; ++i) {
            for (int j = i + 1; j <= n; ++j) {
                scanf("%d", &f[i][j]), f[j][i] = f[i][j];
            }
        }
        ans = f[1][2];
        for (int i = 3; i <= n; ++i) { int t = 0x7fffffff;
            for (int j = 1; j < i; ++j) {
                for (int k = j + 1; k < i; ++k) {
                    t = min((f[i][j] + f[i][k] - f[j][k]) >> 1, t);
                }
            }
            ans += t;
        }
        printf("%d\n", ans);
    }
    return 0;
}

```