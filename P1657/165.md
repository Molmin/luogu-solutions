【题解】：

[color=blue]（以样例分析）[/color]

可用穷举法，先不考虑“每人都满意”这一条件，这样只剩[color=red]**“每人选一本且只能选一本”**[/color]这一条件。在这个条件下，可行解就是五本书的所有全排列，一共有5！=120种。然后[color=green]**在120种可行解中一一删去不符合“每人都满意”的解**[/color]，留下的就是本题的解答。

[color=brown]**这五个数的一种全排列就是五本书的一种分发。例如54321就表示第五本书分给5，第4本书分给4，…，第1本书分给1。“喜爱书表”可以用二维数组来表示，1表示喜爱，0表示不喜爱。**[/color]

算法设计：S1：产生5个数字的一种全排列；

S2：检查是否符合“喜爱书表”的条件，如果符合就解++；

S3：检查是否所有的排列都产生了，如果没有产生完，则返回S1；

S4：结束。

上述算法有可以改进的地方。比如产生了一个全排列12345，从表中可以看出，选第五本书即给1的书,5是不可能的，因为1只喜欢第1,3本书。这就是说5XXXX都是不符合题目的条件。由此想到，[color=purple]**如果选定第一本书后，就得立即检查一下是否符合条件，发现5是不符合的，后面四个数字就不必选了，这样就减少了运算量**[/color]。换句话说，第一个数只在1,3中选择，这样就可以减少3/5的运算量。同理，选定了第一个数字后，也不应该把其他4个数字一次选定，而是选择了第二个数字后，就立即检查是否符合条件，例如，[color=sorrel]**第一个数选1，第二个数选2后，立即检查，发现不符合条件，就应另选第二个数，这样就把12XXX一类的分法在产生前就删去了，又减少了一部分运算量**[/color]。

综上所述，改进后的算法应该是：[color=gold]**在排列产生时，每增加一个数，就检查该数是否符合条件，不符合，就立即换一个，符合条件后，再产生下一个数。因为从第i本书到第i+1本书的寻找过程是相同的，所以可以用回溯算法。**[/color]算法设计如下（伪代码）：

    ```delphi

    int search(i)
    {
        for (j=1;j<=5;j++)
            if (第i个同学分给第j本书符合条件)
               {
                记录第i个数
                if (i==n）解++；
                else search(i+1)；
                删去第i个数
               }
    }
    
```