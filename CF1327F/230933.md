[Link](https://www.luogu.com.cn/problem/CF1327F)

[New Blog阅读效果更佳](https://tony102.com/index.php/archives/109/)

## Sol

首先看到这种位运算的题目，就先看看它给的二进制操作是否独立（一般都会独立），独立的话就可以拆位做了。显然，这道题的操作只有 $\mathrm{AND}$ 操作，可以拆位。

考虑区间 $[l,r]$ 内的数的第 $k$ 位，假如限制给的 $a_i$ 在这一位上要求是 $1$ ，那么这个区间内所有的数这一位上都必须是 $1$，不用考虑贡献。

加入要求是 $0$ ，则这一段至少有一个 $0$。这一部分就是我们要计算的。考虑我们对每一位算出一个 $pos_i$ ，表示第 $i$ 位不放 $0$ 的情况下最早放 $0$ 的位置。设 $f_{i,j}$ 表示前 $i$ 位最后一个 $0$ 放在 $j$ 的位置上的方案数。

若 $j \in [pos_i, i)$ ，那么方案数不变直接从上一位继承过来。$f_{i,j} = f_{i-1,j}$

若 $j = i$ ，则前面 $[pos_{i-1}, i - 1]$ 的 $f$ 都可以贡献到 $f_{i,j}$ 上，即 $f_{i,j} = \sum\limits_{j = pos_{i-1}}^{i-1} f_{i-1,j}$

可以发现 $pos_i$ 单调不降，每次把 $f_{i,j}$ 加进来的时候把前面要出去的 $f$ 刷成 $0$ 即可。

## Code

见 Blog