## CF 1327 F AND Segments

首先发现：每一位都是完全独立的，可以分别算，最后乘起来。

所以我们现在将问题转化为了 $k$ 个只含 $0,1$ 的子任务，注意由于 $n$ 比较大，所以你在多了个 $k$ 的情况下，接下来的做法必须是线性的，只要带一个 $\log$ 就难以通过。

如果告诉你某个区间的 $\operatorname{and}$ 是 $1$，那么当然这个区间就没有选择，必须全部是 $1$。

如果告诉你某个区间的 $\operatorname{ans}$ 是 $0$，那么这个区间就至少需要包含一个 $0$。

考虑如何进行计数，我们先考虑一个特殊情况：没有区间与等于 $1$ 的限制，只有区间与等于 $0$ 的限制时，如何处理？

---

我们先写一个暴力 DP，设 $dp(i,j)$ 表示填到第 $i$ 个位置，最后一个 $0$ 的位置为 $j$（即从右往左数的第一个 $0$）时，满足 $i$ 以前所有限制的方案数。

首先对于每个 $i$，可以求出一个 $l_i$ 表示上一个 $0$ 的最靠前位置，其实就是右端点在 $i$ 之前的所有区间的左端点最大值（因为这个区间里至少有一个 $0$，所以最后一个 $0$ 不能在这之前）。

对于 $j\in [1,l_i)$，有 $dp(i,j)=0$，因为这种情况不可能。

对于 $j\in [l_i,i-1]$，有 $dp(i,j)=dp(i-1,j)$，因为 $i$ 这里没有决策，只能填 $1$（填 $0$ 的话最后一个 $0$ 就是 $i$ 本身）。

对于 $dp(i,i)$，实际上之前任何一种满足要求的填发都可以，所以：

$$dp(i,i)=\sum\limits_{x=l_{i-1}}^{i-1} dp(i-1,x)$$

我们发现很多的 $dp(i,j)$ 是没有变化或者只是赋值为 $0$ 的，这启发我们把 $dp(i,j)$ 看成一个以 $j$ 为下标的序列 $dp_i$，我们只需要考虑如何从 $dp_{i-1}$ 得到 $dp_i$ 即可。

赋值为 $0$ 的操作根本不用理会：我们只需在进行统计时直接屏蔽 $j<l_i$ 的情况即可。

于是我们只是增加了一个 $dp_{i,i}$ 的值，观察上面那个转移方程，其实是求了一个 $dp_{i-1}$ 的某后缀和。

我们可以拆一下这个后缀和，设 $s_{i,j}$ 表示 $\sum\limits_{k=1}^j dp_{i,k}$，那么实际上：

$$dp_{i,i}=s_{i-1,i-1}-s_{i-1,l_{i-1}-1}$$

而且，$l_i$ 具有单调性，所以我们只需用一个指针维护 $l_i$（根据 $i$ 的变化而变化），然后可以 $O(1)$ 求出 $dp_{i,i}$。

---

再考虑有限制区间与等于 $1$ 的条件。发现此时有些位置必须是 $1$，是不能动的，但这并不影响，我们只需把所有已经限定为 $1$ 的位置扔掉，剩下的位置做上面的过程即可。

---

考虑一下每一位做的复杂度，我们要求做到线性：

1. 统计出哪些位置必须填 $1$：就是若干次区间覆盖，可以用差分数组记录，最后统计差分数组前缀和，可以做到线性。

2. 处理 $l_i$：一开始就将每个询问挂在右端点的一个 vector 中，然后就不用排序，直接扫描一次统计即可，可以做到线性。

3. 处理 $dp_{i,j}$：用一个指针维护当前 $l_i$ 以及当前 $l_i$ 的前缀和，再用一个变量维护当且所有 $dp_{i,j}$ 的和，由于 $l_i$ 的单调性，这个过程是均摊线性的。

所以整个题的复杂度是 $O((n+m)k)$。

核心代码（$x$ 为当前在哪一位，$d$ 为差分数组，$nt$ 就是当前的 $dp$ 数组，$cur$ 是 $l_i$ 指针，$al,res$ 分别是全部和以及 $l_i$ 的前缀和）：

```cpp
int calc (int x) {
	memset(d,0,sizeof(d));
	memset(nt,0,sizeof(nt));
	for (int i=1;i<=n;i++) {
		int tmp=v[i].size();
		for (int j=0;j<tmp;j++) {
			int l=v[i][j].first,p=v[i][j].second;
			if (p&(1<<x)) {d[l]++,d[i+1]--;}
		}
	}
	int tot=0,cur=0,res=0,al=1;
	nt[0]=1;
	for (int i=1;i<=n;i++) {d[i]+=d[i-1];}
	for (int i=1;i<=n;i++) {
		if (!d[i]) {mp[i]=++tot;}
		else {mp[i]=tot;}
		int tmp=v[i].size();
		if (!d[i]) {
			nt[tot]=(al-res+P)%P;
			al=(al+nt[tot])%P;
		}
		for (int j=0;j<tmp;j++) {
			int l=v[i][j].first,p=v[i][j].second;
			if (!(p&(1<<x))) {
				if (d[i]&&d[l]&&mp[i]==mp[l]) {return 0;}
				int vl=(d[l]?mp[l]+1:mp[l]);
				while (cur<vl) {res=(res+nt[cur])%P;cur++;}
			}
		}
	}
	int ans=0;
	for (int i=cur;i<=tot;i++) {ans=(ans+nt[i])%P;}
	return ans;
}
```






