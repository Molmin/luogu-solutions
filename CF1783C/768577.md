# 题目
[CF1783C题目传送门](https://www.luogu.com.cn/problem/CF1783C)
# 分析
首先，在所有你不参与的比赛中，结果都已经定好了，按照题目每组数据输入的顺序，每个人分别赢 $[0, n)$ 场（这里所有的下标都从 1 开始）。

设 $x$ 为你最终战胜了多少人。那对于编号为 $[1,x)$ 的人来说，即使他们都战胜了你，那他们赢的场数也不超过 $x$，对你没有威胁；而对于编号为 $(x,n]$ 的人来说，就算他们都输给了你，那他们赢的场数也多余 $x$，你不可能超越他们。那么，唯一对你的名次有影响的，就是编号为 $x$ 的人。如果你打败了他，那么你的名次便是 $n - x$，否则你的名次是 $n - x + 1$。

显然，让 $x$ 越大便能使排名更靠前，那么这道题目贪心的算法应该已经很显然了。我们先对 $a$ 数组排序（排完序的数组记为 $b$ 数组），然后从前往后取，直到其总和超过 $m$ 为止。那么，我们之前的 $x$ 就已经确定了。接下来，将现在的总和减去最后加上的那个数，即 $b_x$，再加上 $a_x$，如果大于 $m$，则说明不不能取，排名为 $n - x + 1$；否则能取，排名为 $n - x$。

那么怎么证明最后一步是对的呢？分类讨论即可：~~（前排提示：有点乱，不想看的可以跳过）~~

（1）若总和中已包含 $a_x$，则因为 $b$ 的不下降的特性，所以可得 $b_x \ge a_x$，既然现在的总和不大于 $m$，那减去 $b_x$ 加上 $a_x$ 也一定不大于 $m$。

（2）若总和中不包含 $a_x$，还有两种情况：

1. 总和减去 $b_x$ 加上 $a_x$ 不大于 $m$。那么这就是最好的情况了，我们不能有更高的排名了。

2. 总和减去 $b_x$ 加上 $a_x$ 大于 $m$。这说明想要保持在打赢包含第 $x$ 个人在内的共 $x$ 个人是不可能的了，如果我们硬是要打赢第 $x$ 个人，最好情况是减去 $b_x$ 和 $b_{x-1}$ 再加 $a_x$ 就不大于 $m$，打赢 $x - 1$ 个人，那排名也只能是 $n - (x - 1) + 1 = n - x$，和干脆不打第 $x$ 个人的结果是一样的。

~~终于结束了~~
# 代码
思路分析完了，最后的代码也自然要放一下。因为有排序的存在，时间复杂度 $O(n log n)$，能通过本题。
```cpp
#include<bits/stdc++.h>
using namespace std;
inline int rd(){
	int res = 0;
	bool flag = false;
	char c = getchar();
	while(c < '0' || c > '9'){
		if(c == '-')
		flag = true;
		c = getchar();
	}
	while(c >= '0' && c <= '9'){
		res = (res << 3) + (res << 1) + (48 ^ c);
		c = getchar();
	}
	return flag ? -res : res;
}
int t, n, m;
void solve(){
	int x = 0;
	n = rd(), m = rd();
	vector<int> a(n), b;
	for(int i = 0; i < n; i++)
	a[i] = rd(); // 输入 
	// 注：这份代码中， m 为剩余时间 
	b = a;
	sort(b.begin(), b.end()); // 排序 
	for(int i = 0; i < n && m >= b[i]; i++)
	// 只要数组没越界，并且总和不大于 m ，就接着从前往后取 
	m -= b[i], x++; // 花费掉 b[i] 的时间，多打败一个人 
	if(x > 0 && x < n && m + b[x - 1] - a[x] >= 0) x++;
	// 如果取了不止一个且没有全部取完并且时间还够，就能和第 x 个人并列，则排名加一 
	printf("%d\n", n - x + 1); // 输出排名 
}
int main(){
	t = rd(); // 快读输入 
	while(t--)
	solve(); // 多组测试数据 
	return 0; // 华丽地结束！ 
}
```
