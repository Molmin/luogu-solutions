怎么没人写 $O(n)$ 呀，赶紧水一发 ~~（其实主要是洛谷咕值贡献掉到 0 了）~~

同步发表于[我的Blog](https://sxyugao.top/p/3396b077.html)，欢迎各位大佬来玩。

---

言归正传。

第一眼看到这题时，大部分人都会想到，既然是树，那么它一定是一层一层地向下 BFS。

也就是说，BFS 序中越后出现的节点，它树上的深度肯定是大于它前面的节点的。

于是照这个思想打完后，发现 Wrong Answer 了。

显然这个思路是有反例的，比如下图的情况：

![](https://i.loli.net/2019/01/29/5c5061bbb4545.png)

输入给的 BFS 序为：1 5 2 3 4 6

如果根据原来的思路输出就是 Yes，然而正确的 BFS 序显然是 1 5 2 6 3 4

再仔细思考一下，发现合法的 BFS 序不仅要满足刚才的深度条件，而且满足每个节点的父亲在 BFS 序中的位置都要不晚于在它后面出现的节点父亲的位置。

这么看貌似时间复杂度是$O(N^2)$的，如何减小复杂度呢？

我们发现一个节点的子树是一个连续的区间，我们直接把每个节点重新编号为它父节点的编号，再把连续相同编号的节点的合并成一个节点即可 ~~(其实可以不用unique的，但是当时没细想）~~ 。合并好以后有一个很好的性质，若输入的序列为合法的 BFS 序，重新编号后的序列元素在原序列中的位置单调递增。这样，时间复杂度就降到了$O(n)$了。

代码详见[博客](https://sxyugao.top/p/3396b077.html)。