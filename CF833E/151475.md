先把读入的线段转成端点的形式。对每个涉及到的端点 $x$，我们计算出 $ans_x$ 表示只考虑 $[0,x]$ 这段区间，最多能有多少多长的线段不被覆盖。那么每次询问给定 $s$，我们只需要在 $ans$ 数组里 lower_bound 一下，可以得到答案在一段区间中。注意到这段区间一定不被覆盖，否则答案应该在上一段区间中，所以可以直接计算出答案。那么问题变成了求 $ans$ 数组。

考虑端点分割形成的每一段线段的覆盖情况，如果 $0$ 条那么白给，如果 $>2$ 条那么必然被覆盖，那么只剩下 $1$ 条和 $2$ 条。考虑如果删除的是一条线段 $x$，那么贡献是覆盖一次的且是被 $x$ 覆盖的线段，如果是两条线段 $x,y$，那么是覆盖一次的且是被 $x$ 或 $y$ 覆盖的线段，加上覆盖两次的且是被 $x$ 和 $y$ 覆盖的线段。扫描端点 $x$ 尝试维护信息。

如果存在一段区间被覆盖了两次，且是被线段 $x$ 和线段 $y$ 覆盖的，那么我们在 $x$ 点和 $y$ 点直接连边，容易证明形成了一个森林。每次添加一个线段的时候，要么是给一个点增加一个权值，要么是给一条边增加一个权值，每次需要找到 $x,y$ 满足 $x$ 的点权 + $y$ 的点权 + $(x,y)$ 的边权（如果存在边）最大化，且满足 $c_x+c_y\le C$。

这个问题是可以维护的，分成两个部分：$(x,y)$ 之间有边与无边。无边的时候每次修改 $c_x$ 的时候考虑其中一个选择 $c_x$，另一个需要满足 $c\le C-c_x$，在线段树上查询最值就行。有边的时候可以在树上用一些数据结构技巧维护，但是这棵树还很特殊，容易发现剥掉叶子之后就是一条链。所以对于每个度数不为 $1$ 的点，维护其周围的叶子点权和之间的边权的 $\max$ 即可。

写起来有一些细节。线段树如果动态开点可能会被卡空间。注意如果线段树最值查到自己要判一下。我写的比较丑所以代码就不放了。复杂度是一个 $\log$。