### Problem Statement

$n$ 个区间，第 $i$ 个为 $[l_i, r_i]$，代价为 $c_i$。有代价限制为 $C$。

$m$ 次询问，可移除总代价不超过 $C$ 的至多两个区间，求最小的 $x$ 使得 $[0, x]$ 内至少有 $k_j - \epsilon$ 的长度未被任何区间覆盖。询问独立。

### Constraints

$0 \le n \le 3 \times 10^5$，$1 \le m \le 3 \times 10^5$，$0 \le l_i \lt r_i \le 10^9$，$1 \le k_j \le 10^9$，$0 \le C, c_i \le 10^9$。所有数据均为整数。

---

### Solution

记 $S \coloneqq \lbrace l_i \rbrace \cup \lbrace r_i \rbrace$。问题易于转化为：对于 $S$ 中的每一点 $x$，求出在只考虑 $[0, x]$ 的情况下，未被覆盖的最大长度 $l_x$​。

考虑递增枚举 $x$。假设当前转移为 $x' \to x$​。
记 $v_i$​ 表示：选择的区间包含 $i$​，且 $i$ 区间在这些区间中右端点最大（相同可按编号钦定顺序），在只考虑当前 $[0, x]$ 的情况下，新增空白长度最大值。
记 $v_{0, i}$ 表示：仅选择区间 $i$，在只考虑当前 $[0, x]$ 的情况下，新增空白长度最大值。
记 $o_i$ 表示：区间 $i$ 中，在只考虑当前 $[0, x]$ 的情况下，至多被两个区间覆盖的长度。
容易通过记录以上三者转移 $l_x$。

>具体地，若当前段被多于两端区间覆盖，则 $l_x \gets l_{x'}$。
>若未被覆盖，则 $l_x \gets l_{x'} + (x - x')$。
>若某个区间首次出现，则对应的 $v$ 更新为其左侧 $v_0$ 的最大值（对代价有要求，可通过平衡树（C++ 中 `std::map`）维护单调性）。
>若恰被一个区间覆盖，更新对应的 $v_i, v_{0, i}, o_i$，用对应的 $v_i$ 更新 $l_x$。
>若恰被两个区间覆盖，更新两区间的 $o_i$，及右端点较大者对应的 $v_i$，用这一 $v$ 更新 $l_x$。

询问时二分 $S$ 中的 $x$。显然对于 $x' \to x$，若 $l_{x'} \ne l_x$，则 $l_{x''} = \max(l_{x'}, l_x - (x - x'')) \pod{x' \le x'' \le x}$。注意 $\max S$ 外的处理。

时间复杂度 $O((n + m) \log n)$，空间复杂度 $O(n + m)$。