本题其实不需要用到线性DP，在这里，介绍一种简单的贪心思想，思路如下：

+  首先，这是求区间最大值的题目，我们可以定义一个变量来保存一段区间的和，每一次将这个和与目前最大的值相比较，若是目前区间的值大于已知最大值，那么就更换。

+ 但是，如果此时区间的值小于零，那么我们可以想到，就算此时你再加上其他数，结果也是不会比之后的区间大，反而之后的区间会因此儿变小。所以，此时我们将这个区间的值归零，重新计数；

### 但是要注意!!!以下是重点！以下是重点！以下是重点！
#### ~~重要的事情说三遍~~

- 如果所有的利润都为负数，那么就要取最大的一个利润！！！即我们可以定义一个bool类型的变量，并保存下目前变量的最大值。若是没有出现>=0的数字，就输出此时的最大值。


--------------------完美的分割线----------------------

---

接下来是代码：
```cpp
#include<iostream>
using namespace std;
int n;
int a[100010];
int Max=-0xfffffff;
int t;
bool bol;
int num=-0x7fffffff;
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>a[i];
		t+=a[i];
		if(t<0)t=0;
		Max=max(Max,t);
		if(a[i]>0)bol=1;
		num=max(num,a[i]);
	}
	if(bol)cout<<Max<<endl;
	else cout<<num<<endl;
	return 0;
}
```

##### 求管理员大大放行QAQ。

**~~来都来了，不点个赞再走嘛~~**