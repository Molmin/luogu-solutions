- [博客体验](https://www.luogu.com.cn/blog/writeSTL/solution-p3009)

## 前置知识

- $1$：动态规划（dp）

> 用递推或记忆化搜索的形式把多阶段过程转化为一系列单阶段问题，利用各阶段之间的关系，逐个求解。

- $2$：一些数学符号

> 第一个：$\sum$
>
> > 第一种形式：$\sum\limits_{\textsf{变量=底值}}^{\textsf{顶值}}\textsf{式子}$
> >
> > 表示把变量从底值到顶值循环，求每个式子的值之和，相当于 `for (int 变量=底值;变量<=定值;变量++) ans+=式子;`
> >
> > ---
> > 
> > 第二种形式：$\sum\limits_{\textsf{变量的取值范围}}\textsf{式子}$
> >
> > 表示将 $i$ 取边取值范围，求每个式子的值的值之和，相当于 `while (变量在取值范围内){ans+=式子;变量遍历下一个值;}`
> 
> ----
> ----
> 第二个：$\max$
> 
> > 和 $\sum$ 用法一样，就是求和改成了求 $\max$。
> >
> > ---
> >
> > 顺便介绍几个类似的：
> >
> > | 编号 | 读法 | 写法 | 作用 |
> > | :---: | :---: | :---: | :---: | :---: |
> > | 1 | `sigma`($\sigma$) | $\sum$ `\sum` | 求和 |
> > | 2 | `min` | $\min$ `\min` | 取最小值 |
> > | 3 | `max` | $\max$ `\max` | 取最大值 |
> > | 4 | `pi`($\pi$)| $\prod$ `\prod` | 求积 |
> > 在 $\LaTeX$ 书写中行内模式 (一个美元符号) 中，在符号后加上 `\limits` 可以使上下居中，即 $\sum_{i=0}^n$ 变成 $\sum\limits_{i=0}^n$（居中的模式两个美元符号默认上下居中）


## 算法分析

> 在这个问题中，我们均设序列 $P$ 的下标是从 $0$ 开始的。

这个题目要求最大连续子串和，即找到一组 $l,r$ 使 $\sum\limits_{i=l}^rP_i$ 最大，所以答案让我们求的是 $\max\limits_{0\le l,r<n\;\;l,r\in\mathbb{N^*}}\left\{\sum\limits_{i=l}^rP_i\right\}$（~~然而列出这个式子并没有什么用~~）

### 1.暴力做法

我们可以暴力枚举 $l,r$，时间复杂度为 $\mathcal{O}(n^2)$。

---

### 2.暴力的优化

每次 $l,r$ 可以考虑二分求解，它本来就是 $l,r$ 正好还方便二分，排序一下保证单调性即可。

时间复杂度 $\mathcal O(\log^2 n)$

### 3.普通 dp 做法

我们设 $f(l,r)$ 为 $P_l\sim P_r$ 序列内的最优解。

如果原序列有一个子串 $P_l\sim P_r$ 是最优解，那么在一个包含于它的更大的子串 $P_x\sim P_y$（$x\le l$ 且 $r\le y$） 中，$f(l,r)$ 必然 $\le f(x,y)$，因为如果 $f(l,r)<f(x,y)$ ，又因为 $x\le l$ 且 $r\le y$，所以 $f(x,y)$ 里必须有一部分 $f(l,r)$，所以$f(l,r)$ 必然 $\le f(x,y)$。 

所以这个问题具有 **最优子问题性质**。

这个问题最优子问题性质，考虑 dp 求解。

转移方程分析如下：

我们用 $dp_i$ 代表序列中 $0\sim n-1$ 部分的最优解，也就是 $f(0,n-1)$。

- 如果不选这个元素，那么它的值就是 $dp_{i-1}$，因为第 $i$ 个元素不选所以不做贡献，则做贡献的只有前 $i-1$ 个。

- 如果选这个元素，那么它的贡献是它本身的贡献加上他前面的贡献，即 $dp_i+dp_{i-1}$。

并且注意这句话：
> 材料一：
>
> > $(-10^3 \le P_i \le 10^3)$
> 
> 材料二：
> 
> > 约翰想要找到奶牛们在连续的时间期间所获得的最大的总利润。（注：连续时间的周期长度范围从第一天到第 $n$ 天）。

这句话说明最大总利润 *必须取一些值*，如果没有注意这一点，就会被天天赔钱的数据卡掉。

取最优解，转移方程就得到了：

$$dp_i=\max\{dp_{i-1},dp_i+dp_{i-1}\}$$

答案为 $\max\limits_{0\le i<n}\{dp_i\}$，也就是所有 $dp_i$ 的最大值（$0\le i < n$）。

现在来考虑边界条件：

显然，$dp_0=P_0$，因为只有它一个元素。

其次，$dp_i\ge P_i$，因为如果 $0\sim i-1$ 区间内的最优解只含有 $P_i$ 一个元素，等号成立，因为 $P_i \in \{P_x\mid 0\le x <i-1,x\in\mathbb{N^*}\}$，即使有一个 $k$ 使 $P_i>P_k$，我们求的还是最优解，即 $dp_i\ge P_i>P_k$。

所以说 $dp_i$ 的初始值应为 $P_i$，因为这样可以保证 $dp_i\ge P_i$（注意状态转移方程中的 $dp_i+dp_{i-1}$ 可以体会）

此算法时间复杂度为 $\mathcal O(n)$，空间复杂度为 $\mathcal{O}(n)$（因为 dp 数组初始值和 $P$ 序列一样，可以合并，优化一半空间）

代码如下：
```cpp
#include<iostream>
#include<cstdio>
using namespace std;
const int N=100001;
//the "dp" array=the input array.
int dp[N],n;
template<typename T>
inline T Max(T a,T b){return a<b?b:a;}
int main()
{
	scanf("%d",&n);
	for (int i=0;i<n;i++) scanf("%d",dp+i);
	for (int i=1;i<n;i++) //dp
		dp[i]=Max(dp[i],dp[i]+dp[i-1]);
	int ans=-1001;        //mini ans=-1000.
	for (int i=0;i<n;i++)
		ans=Max(ans,dp[i]);
	printf("%d",ans);
	return 0;
}
```

---

### 4.dp 的优化

这个 dp 还是可以优化的。

可以轻易发现：dp 时 $dp_i$ 的取值只与 $dp_{i-1}$ 有关。

所以只需要存储 $dp_i$ 和 $dp_{i-1}$ 滚动使用空间即可。

取 $\max$ 也可以滚动进行，又优化了常数。

用这两点就可以将空间复杂度优化到 $\mathcal O(1)$，时间复杂度只优化了些常数（QAQ）。 

---

所以目前的最快时间复杂度是 $\mathcal{O}(n)$，可以轻松跑过 $10^5$ 的数据，但是空间用 $\mathcal O(n)$ 是可以过的，这也降低了这个题的难度。

只给第三种解答，因为前两种是~~基本~~能力，第四种只要明白了第三种就能轻松写出。