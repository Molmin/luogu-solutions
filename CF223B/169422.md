看题直观感觉好像很简单，一做发现细节不少，有点复杂，做完又会觉得简单。。。

----------------


首先读题，~~注意问的是子序列不是字串~~。

最直接的想法是弄一个类似于双指针的东西扫一遍，看看 $s$ 串能不能整一个子序列跟 $t$ 串一样，然后再拿一个数组看看 $s$ 串中每一种元素是否都在 $t$ 串种出现。

然后就错了。。。

hack 数据是这样的：

```

babbbbbaba
ab

```
这样子最后一个 ``a`` 是没有 ``b`` 与它凑一个子序列的。

~~那是不是说倒着再跑一边就对了?~~

别急，这样子还是只有最前面和最后面一小部分是保证一定能凑出子序列的，其他位置还是不能确定。

定义某个位置的**前匹配长度**为以这个位置为结尾的子序列可以与 $t$ 的前缀匹配的长度，记为 $pr_i$。

同时定义**最大前匹配长度**为以这个位置为结尾的子序列可以与 $t$ 的前缀匹配的最大长度，记为 $mpr_i$。

那么同时可以记一个后匹配长度去维护后缀匹配，分别记为 $su_i$，$msu_i$。

回到双指针的地方，观察 $s$ 串：

1. 如果可以直接跟 $t$ 串匹配，则当前位置的最大匹配长度为 $t$ 串的当前匹配长度；

2. 如果不能直接匹配，则当前位置的最大匹配长度为上一个出现的这个字符的最大匹配长度。

关于匹配长度有个性质：

如果一个位置 $i$ 存在 $pr_i+su_i=len_t$，则这个位置一定可以被包含某个合法子序列中。

那么对于一个位置 $i$，满足 $mpr_i + msu_i \ge len _ t$， 则这个为是可以被包含某个合法子序列中。

显然 $mpr$ 和 $msu$ 可以在两次双指针扫的时候维护。

-------------

然后就有了一种做法：

用双指针正反各扫一遍，维护 $mpr$ 和 $msu$。对于 $s$ 串中每一个位置 $i$， 都要满足 $mpr_i + msu_i \ge len_t + 1$（加 $1$ 是因为位置 $i$ 会被算两边）

code:

```
#include<bits/stdc++.h>
using namespace std;
int n, m, len;
char s1[200010], s2[200010];
int pr[200010], su[200010];
int vis[233];
signed main(){
	scanf("%s", s1 + 1);
	n = strlen(s1 + 1);
	scanf("%s", s2 + 1);
	m = strlen(s2 + 1);
	int l1 = n, l2 = m;
	while(l1 >= 1 && l2 >= 1){
		while(s1[l1] != s2[l2] && l1 >= 1){
			pr[l1] = vis[s1[l1]];
			l1--;
		}
		if(s1[l1] == s2[l2]){
			vis[s1[l1]] = m - l2 + 1;
			pr[l1] = vis[s1[l1]];
			l1--, l2--;
		}
	}
	while(l1 >= 1){
		pr[l1] = vis[s1[l1]];
		l1--;
	}
	memset(vis, 0, sizeof(vis));
	l1 = 1, l2 = 1;
	while(l1 <= n && l2 <= m){
		while(s1[l1] != s2[l2] && l1 <= n){
			su[l1] = vis[s1[l1]];
			l1++;
		}
		if(s1[l1] == s2[l2]){
			vis[s1[l1]] = l2;
			su[l1] = vis[s1[l1]];
			l1++, l2++;
		}
	}
	while(l1 <= n){
		su[l1] = vis[s1[l1]];
		l1++;
	}	
	for(int i = 1; i <= n; i++)
		if(pr[i] + su[i] <= m){
			puts("No");
			return 0;
		}
	puts("Yes");
	return 0;
}
```