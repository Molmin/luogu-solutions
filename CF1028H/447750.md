定义一个序列 $b$ 是优秀的，当且仅当存在 $i<j,b_i\times b_j$ 是完全平方数。定义序列 $b$ 上的一次操作为任意选择一个 $b$ 中的元素，将其乘/除以一个质数 $p$（除法要求整除）。

给定序列 $a_{1\cdots n}$，$q$ 次询问区间 $[l,r]$ 组成的序列至少进行多少次操作才能变成优秀的。

$n\leq 2\times 10^5$，$q\leq 10^6$，$1\leq a_i\leq 5\times 10^6$，$l<r$，7s，1G。

预处理去掉每个数的平方因子，则此时每个数的 $\omega \leq7$。记 $t_i$ 表示 $i$ 的质因子个数，则两个数 $x,y$ 要操作 $t_x+t_y-2t_{\gcd(x,y)}$ 次才能满足 $x\times y$ 是完全平方数。

考虑若 $a|b$，则 $t_a\leq t_b$，要最小化 $t_x+t_y-2t_{\gcd}$，则如果只处理一次询问，可以枚举 $d|x,d|y$ 统计 $t_x+t_y-2t_d$ 的最小值。

枚举 $d$ 拉出序列中 $d$ 的倍数，注意到处理后的 $a_i$ 不含平方因子，则其因子个数为 $2^\omega\leq 128$ 个，则总共只有 $128n$ 次被拉出来统计。对于确定的 $d$，希望最小化 $t_x+t_y$，也就是需要找到最小和次小的 $t$。

对于一次询问，暴力地统计其中的最小值和次小值。对于多次询问，考虑真正有贡献的（最小值，次小值）点对实际只有 $O(len)$ 对。具体地，枚举次小值所在的位置，找到其左，右第一个比自己小的作为最小值，则每个区间的情况都被包含了。正确性考虑截取其中的一个区间 $[l,r]$，找到区间最小值，则区间里的次小值会找到它作为某一边第一个比自己小的数计入答案。则问题转为区间包含的线段的最小权值，容易离线扫描线。

线段有 $2^8n\leq 5\times 10^7$ 个，而询问只有 $10^6$ 个，扫描线时需要支持的操作是单点修改，后缀求 $\min$。注意到答案首先不超过 $14$，那么可以改为前缀取 $\min$ 和单点查值，前缀取 $\min$ 则值单调不降，暴力地往前更新 $f$ 值直到不能更新，则更新次数容易均摊到 $2\omega n\leq 14n$，这样统计答案的部分就快了不少。

单调栈部分复杂度是 $O(2^\omega n)$，统计答案部分复杂度是 $O(2^\omega n+q+\omega n)$，则总复杂度是 $O(\omega2^\omega n+q+V\times \omega)$。

不卡常，实现比较简陋。[Submission](https://codeforces.com/contest/1028/submission/178756057)。