### 前置知识：[满二叉树](https://baike.baidu.com/item/%E6%BB%A1%E4%BA%8C%E5%8F%89%E6%A0%91)

~~看起来这题是一道二叉树题目，好慌有木有？其实他跟二叉树一点关系都没有......~~

先来看一看题目图：

![](https://cdn.luogu.com.cn/upload/image_hosting/zdb2rnzg.png)


通过我们寻找规律，我们不难发现：在每一个节点上，（不论什么节点）当小球第**奇数次**经过节点时，一定会向左子树下落；当小球第**偶数次**经过节点时，一定会向右子树下落。

这样，我们就不用模拟每一次小球的下落了（耶！） ，如果模拟每一次下落的话，就会**TLE**。

那么怎么求出它到底落入了第几个袋子呢？

先定义一个我们的答案：

$ans=1$

如果向左子树滚动，则：

$ans=ans\times2$


如果向右子树滚，则：

$ans=ans\times2+1$

最后一个问题：记得在向左子树滚动时将**当前小球序号**$÷2$；向右子树滚动时将$($**当前小球序号**$+1)÷2$，进行这两步操作是为了确保在下一深度时可以分辨向哪一子树滚动。

还有，对于深度为$n$的二叉树，需要滚动$n-1$层。

### 经典片段：上代码

相信大家对于前面的讲解已经了解透彻，但是实现代码版还需思考，现在我将代码版发出来，道理都在代码里，使用语言：**C++**

```cpp
#include<iostream>
using namespace std;
int main()
{
	int p;
	cin>>p;
	for(int i=1;i<=p;i++)
	{
		int s,x;
		cin>>s>>x;
		int ans=1;
		for(int j=1;j<s;j++)//对于深度为s的二叉树，需要滚动s-1层
		{
			if(x%2==0){ans=ans*2+1;x/=2;}//偶数乘二加一，序号减半
				else {ans*=2;x=(x+1)/2;}//奇数乘二，序号加一减半
			}
		cout<<ans<<endl;
		}
	int k;
	cin>>k;//别忘了还要输入-1
	return 0;
	}
```

## ~~珍爱账号，远离抄袭~~

###### 求管理员过~