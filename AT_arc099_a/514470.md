### 思路：

每次向下推平到最小值，意味着该数组最后所有元素都会被推平到 $1$。为了避免做无用功，我们可以通过一定的操作使得每次操作都满足以下条件：

- 包含 $1$。这是为了使得它推平后结果为 $1$，避免再次推平。

- 仅包含一个 $1$。这是为了避免不必要的资源浪费。

需要注意的是，每次仅能将 $k-1$ 个非 $1$ 数字推平至 $1$。

我们可以按照如下思路构造：

- 找到 $1$ 的位置。

- 求出 $1$ 的右面的元素个数，并对 $k-1$ 取余，称之为 $p$。

- 在第一次操作时将 $1$，以及其右面的 $p$ 个，左面的 $k-p-1$ 个推平。

- 继续向右推平。由于刚才的操作，向右推平一定没有剩余。

- 向左推平。

此时，我们可以总结，本题无序看数组的排布，推平最小次数仅和 $n,k$ 有关，最小的操作次数为：

$$\left\lceil \dfrac{n-1}{k-1} \right\rceil$$

### AC Code:

```cpp
#include <bits/stdc++.h>
using namespace std;

int a;

int main()
{
    int n,k;
    cin >> n >> k;
    for(int i=1; i<=n; i++) cin >> a;
    cout << (n+k-3) / (k-1) << endl; // 这样做不明白的请继续阅读
}
```

### 拓展：

原式可以变成：

$$\left\lfloor \dfrac{n+k-3}{k-1} \right\rfloor$$

原因是：

$$\left\lceil \dfrac{a}{b} \right\rceil = \left\lfloor \dfrac{a+b-1}{b} \right\rfloor$$

两个式子之间并无本质区别，都可以 AC 此题，但在实际应用中如果拿不准尽量写最原始的式子。