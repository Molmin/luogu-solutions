[在这里看效果更好哦](https://114677.blog.luogu.org/at3595-ti-xie)

和他们一样，这分明就是扫雷游戏的兄弟题啊

这道题的主要思路就是每一个点都扫一遍，看看他附近八个点里有没有雷就行了

简单浏览了下他们的题解，我发现好几篇有个共同的特点，就是把八个方向分别列出来一遍，这样比较麻烦，所以我也进行了一些优化
 
```
#include<bits/stdc++.h>
using namespace std;
char a[1001][1001];//开字符数组就不用多说了吧 
int wi[8]={1,1,0,-1,-1,-1,0,1};
int wj[8]={0,-1,-1,-1,0,1,1,1},n=0,m=0;//wi和wj分别是不同的方向，同来方便统计雷数，否则很麻烦
int main()
{
    cin>>n>>m;
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=m;j++)
        {
            cin>>a[i][j];
        }
    }//就是输入
    
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=m;j++)
        {
            if(a[i][j]=='#')
            {
                cout<<'#';//如果是雷就直接输出，过
            }
            else//如果不是雷
            {
                int num=0;//统计雷数
                for(int m=0;m<8;m++)
                {
                    if(a[i][j]!='.')
                    {
                    	continue;//还是一样
                    }
                    if(a[i+wi[m]][j+wj[m]]=='#')//如果是周围的雷
                    {
                        num++;//那么计数器就加1
                    }
                }
                cout<<num;//输出就好了
            }
        }
        cout<<endl;//每行输出后的换行
    }
    //因为在循环中多出一个换行，所以就不用多换行来满足AT了
    return 0;
}
```

	点个赞好吗~\(≧▽≦)/~