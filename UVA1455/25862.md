
**[博客中食用更佳](https://www.luogu.org/blog/xzlhxc/solution-uva1455)**    
**upd:博客地址变更，其余内容保持不变。**

------------
[题目链接（luogu）](https://www.luogu.org/problemnew/show/UVA1455)   

预备知识：本题综合了并查集和树状数组（或线段树~~和分块~~）的算法，需要学习的可以参考[【模板】并查集（P3367）](https://www.luogu.org/problemnew/show/P3367)以及[【模板】树状数组2（P3368）](https://www.luogu.org/problemnew/show/P3368)（内含线段树解法）的题解。    
# ①题意
本题抽象成几何问题后，我们可以发现，line的每一次查询都确保**直线与x轴平行**，不管每一个州（点集）的x坐标为何值，只要查询的y坐标在这个州的**最高点与最低点之间**，那么这个州就会被算上，所以，我们**只需要考虑每个点的y坐标**，从而可以把每一个操作看做（投影为）一条数轴（y轴）上的操作，本题就变成区间问题了，即可以用线段树等数据结构高效求解。
# ②数据处理加工
由于我们要维护点与各个不相交集合的关系，自然能想到要用并查集来维护点之间的关系，代码如下：
```cpp
struct DSU //Disjoint Set Union 并查集
{
	int n;
	int root[100001];
	void init(int x)//初始化
	{
		n=x;
		for(int i=0;i<n;i++)
               //本题中点的序号是从0开始的
		 root[i]=i;
		return;
	}
	int Find(int x)
	{
		return root[x]==x?x:root[x]=Find(root[x]);
                //路径压缩
	}
	void Merge(int x,int y)
	{
		int k1=found(x),k2=found(y);
		if(x==y)return;
		root[k2]=k1;
                //并没有按秩合并，主要是因为懒
		return;
	}
}city;
```
我们可以将整个坐标系看做一个网格图，每一个整数y坐标表示区间$[y-1,y)$这一段。  
如图，y表示的就是红色部分的区间信息。
![](https://cdn.luogu.com.cn/upload/pic/56687.png)
然后我们定义：区间$(L,R]$表示y坐标集$L+1,L+2 ...R$，那么我们便可以把每个点的**祖先节点所在州（点集）** 的最高点和最低点的y值用数组
```int pos[MAXN][2]```存起来，就是这个州（点集）所表示的区间($pos[i][1],pos[i][0]$]。  

~~（在我的代码中我用了数组下标为0的数组表示最大值，读者可自行变通 ）~~ 

特别地，当一个点初始化的时候，没有必要开一个数组存，只要
```cpp
pos[i][0]=pos[i][1]=y;
```
就可以了。  

由于我们还要求每个州（点集）的大小，所以我们开一个```int siz[MAXN]```来储存以$i$为祖先的州（点集）大小。  

关于查询，根据定义，设输入的小数为$x$，我们只要查询$(x+0.5)$的y值便可。
# ③区间修改，单点求值
由于题意的操作可以看做是区间修改，单点求值，线段树当然可以，但这里我们用树状数组或许会更快。    

先考虑求（点集）的个数。我们用一个树状差分数组```int cf[MAXN]```来储存每个点所代表的段经过的点集的个数，每一次连接可以等价为一段区间上的操作。   

当2个点（代表的祖先节点设为$i_1,i_2$）连接时，我们可以看做是2个点集求并，所以我们可以分以下3种情况：  
#### (1)$i_1=i_2$
2个点在同一个点集内，不管怎么连，都不会连到这个点集外面去，所以点集外就不必考虑了，而点集内肯定已经算过一遍了，整个点集的点的个数也没有改变，所以不用管，直接```continue```。
### (2)($pos[i_1][1],pos[i_1][0]$]$\bigcap$($pos[i_2][1],pos[i_2][0]$]$= \emptyset $
2个点集的y坐标集有交集，如图：
![](https://cdn.luogu.com.cn/upload/pic/56697.png)
容易发现连接之后（加上黄色虚线之后）对上下2部分不会产生影响，所以这个情况直接把2个点集合并，并将中间部分代表的区间维护的个数$+1$即可。   

**以及维护siz值：
```siz[k1]=siz[k2]=siz[k1]+siz[k2];```**
### (3)($pos[i_1][1],pos[i_1][0]$]$\bigcap$($pos[i_2][1],pos[i_2][0]$]$\ne \emptyset $
2个点集的y坐标集有交集，如图：
![](https://cdn.luogu.com.cn/upload/pic/56691.png)
（图中蓝点和绿点分别为2个点集的最高点和最低点，黄色段为它们的交集）   
与（1）类似，无论怎么连，它们总是影响不到总区间外，所以我们只需要将黄色

段的区间维护的个数$-1$即可。

```//别忘了 siz[k1]=siz[k2]=siz[k1]+siz[k2];```
------------
# ④优化代码长度
### “等等，如果按照上面说的做，分类讨论会把我累死的...”
仔细观察一下（2）与（3）的情况，可以发现2种情况合并后的点集的最高点和最低点就是原来2个点集的最高点和最低点。所以我们直接将2个点集代表的区间维护的个数都$-1$，再把新点集代表的区间维护的个数都$+1$即可。可以理解成重新构造一个点集。

至于州的个数，再开一个树状差分数组，像个数一样维护就可以了。
```cpp
int x=readin(),y=readin(),k1=city.found(x),k2=city.found(y);
if(k1==k2)continue;
if(pos[k1][0]!=pos[k1][1])
//如果只是一个单点就不用取消了，这里判断的是非单点的情况
{
	add(pos[k1][0]+1,1,0);//维护（点集的）个数
	add(pos[k1][1]+1,-1,0);
	add(pos[k1][0]+1,siz[k1],1);//维护大小（点的个数）
	add(pos[k1][1]+1,-siz[k1],1);
}
if(pos[k2][0]!=pos[k2][1])//同上
{
	add(pos[k2][0]+1,1,0);
	add(pos[k2][1]+1,-1,0);
	add(pos[k2][0]+1,siz[k2],1);
	add(pos[k2][1]+1,-siz[k2],1);
}
siz[k1]=siz[k2]=siz[k1]+siz[k2];//点集（大小）合并
add(max(pos[k1][0],pos[k2][0])+1,-1,0);//维护新点集个数、大小
add(min(pos[k1][1],pos[k2][1])+1,1,0);
add(max(pos[k1][0],pos[k2][0])+1,-siz[k1],1);
add(min(pos[k1][1],pos[k2][1])+1,siz[k1],1);
city.merge(k1,k2);//点集合并
pos[k1][0]=pos[k2][0]=max(pos[k1][0],pos[k2][0]);//更新最高（低）点
pos[k1][1]=pos[k2][1]=min(pos[k1][1],pos[k2][1]);
```
# ⑤查询
查询单点就可以了，②中已有提过。
# ⑥AC!
 _觉得好就点个赞吧！_ 