# 洛谷P2678，NOIP2015

## 因为要求最短距离的最大值，很自然的考虑二分（虽说刚开始不会分），然后来看看怎么分

#### 第一种极端情况，不移石头，不论如何都得从这头跳到对岸，距离最小为l

#### 第二种可以考虑两块石头，移一块，第一块到岸边距离为l/3，第二块为l/2，那么跳跃距离分别为l/3，l/6，l/2：第二种可以考虑两块石头，移一块，第一块到岸边距离为l/3，第二块为l/2，那么跳跃距离分别为l/3，l/6，l/2：

如果移第一块，距离变成l/2，l/2；

如果移第二块，距离为l/3，l*2/3；

两种情况对应的最短距离的最大值分别为l/3，l/2，所以选择第一种
到了这里很自然的想到枚举，但此时只移一块石头，当m更大（甚至为10000时）肯定TLE到了这里很自然的想到枚举，但此时只移一块石头，当m更大（甚至为10000时）肯定TLE
#### 所以开始考虑其他算法
从上面两个栗子可以看出，最开始的距离应该是全长，那么既然要尝试所有答案，时间复杂度又不能太大，咱可以试试二分枚举
左端点为岸，右端点为对岸（仿佛废话）
就会有如下的伪码描述
初始区间为总长度
{
	尝试当前区间长度（跳跃距离）是否合法；
	if（1）去右区间查找更优解；
	else 左区间寻找可行解；
}
最大复杂度为log 1e9
#### 先在来看看判断函数
按照上面的想法，我们得把整个石头数组遍历一遍，每到一块新的石头，就要判断一次是否合法，就是当前这两块石头之间的距离是否大于Mid(理解一下)
如果距离比mid小，说明此时两者之间的距离不满足使当前的mid为最小的跳跃距离，那就移动，计数器++
如果比mid大，那就跳过去
#### 到这有同学还是晕的话，可以停下来理解一下这个最短距离的最大值是什么意思
最短距离，每一种移动方案对应一个距离，每一个距离也返回去对应一种移动方案，首先要在【0，l】内找到最大的移动距离，然后判断是否合法，即让这个距离为此次跳石头的最小值，然后尝试很多种距离，用二分找到一个解，可行就去找更大的，不行就找更小的
#### 最小距离指每次跳跃的距离，那么最大值就是所有这个距离里面最大的值
好了该放代码了
```#include<iostream>
#include<cstdio>
using namespace std;
int l,n,m,dis;
int shitou[50010];
bool panduan(int mid);
int main()
{
	scanf("%d%d%d",&l,&n,&m);
	for(int i=1;i<=n;i++)
	scanf("%d",&shitou[i]);
	shitou[n+1]=l;
	int left=0,right=l;
	while(left<=right)
	{
		int mid=(left+right)/2;
		if(panduan(mid))
		left=mid+1,dis=mid;
		else
		right=mid-1;
	}
	cout<<dis<<endl;
}
bool panduan(int mid)
{
	int cnt=0,cur=0;
	for(int i=1;i<=n+1;i++)
	{
		if(shitou[i]-shitou[cur]<mid)
		cnt++;
		else
		cur=i;
	}
	if(cnt>m)
	return 0;
	else
	return 1;
}```

 

 

 

 

 
