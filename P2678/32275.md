此题无论是题目，还是代码，思路都非常简洁明了。一道很好的又很经典的二分查找题。

首先假如枚举，那不用说，直接TLE。

然而很多人就卡在如何二分上面。这就非常奇怪了，因为一旦理解了暴力的判断是如何达到的，那二分也就一目了然了。

首先将石头位置排个序，以便处理方便。这一步也是必须要做的，因为若不排序，那判断将非常的困难。而下面这一步，也是此题之精髓——

我们对于一个长度x，想看看它是否可以符合删除石头数小于等于m，可以这样做：

从位置的小到大扫遍所有石头，用一个变量存储上一个跳到的点。第一个与这上一个点的距离大于等于x的石头即是下一个跳到的点。这里用了一点贪心的思想：因为如果不跳到第一个符合条件的点上，那么整个队列的稀疏度就会提高，最终需要删除的石头也会更多。因为我们要取最优状态，所以要保证跳过的石头数最少。当然，如果某个石头到终点的距离小于x，那它不能被统计到——所以得删去后面这些无法跳到的石头。我自认为这应该也是一个坑点（虽然我第一遍就判断了）。

这样，便求出了这个x是否可行，如果可行，那就往右边二分，但要记得范围要包括x；若不行，则往左边二分，右限制不包括x。然后，二分到左右边界相等，输出即可。

然后此题就做完了。大家应该很容易理解。

如果还有不太懂的，那具体请见代码：

```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
int sto[100000];//开大一点，保险
int main()
{
    int s,n,m;
    scanf("%d%d%d",&s,&n,&m);
    int zuo=1,you=s,mid;//所有边界为1、s
    for(int i=0;i<n;i++)scanf("%d",&sto[i]);
    sort(sto,sto+n);//从小到大排序
    int sg,cnt,ii;
    while(zuo!=you)
    {
        mid=(zuo+you+1)>>1;//位运算加速
        sg=cnt=0;//初始化
        for(ii=0;ii<n;ii++)
        {
            if(s-sto[ii]<mid)break;//如解析中所述，若再跳x已超过终点，则不可取此点，它后面的也显然不可取
            if(sto[ii]-sg<mid)cnt++;//跳过
            else sg=sto[ii];//贪心，直接跳到
        }
        cnt+=n-ii;//统计最后被删除的点数
        if(cnt<=m)zuo=mid;
        else you=mid-1;//二分边界更新，具体请见解析
    }
    printf("%d",zuo);//输出
    return 0;
}
```