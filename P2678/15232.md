感觉楼下讲的有点绕，楼下的楼下讲的又有点太难了，二分答案应该算是普及组算法，但是在提高组里也会考，而且作为优化来说也是很大的提升，从O(n)到logn绝对是非常好的优化。



有的时候，我们会遇到一些特殊的问题：它们很难直接求解，或者根本无法直接求解，

这种时候就应该换个角度，从答案方面入手。例如，一元三次方程求解那道题，大家还记得

吧？
 
更多的，我们把这种思路拓展到这一类问题，我们很难直接从正面求解，但它的答案范

围有边界，即具有有界性，且（至少在一定范围内）具有单调性（顶多局部不变）

，我们就可

以拓展一下分治思想，从答案这边二分，不断逼近正解，直到找到正解（整数）或逼近到精

度内（实数） 


上段取自djdj1506的分治与倍增，把二分答案的作用讲的很清楚了，这里详细解释一下什么是边界性，什么是单调性

边界性，说的通俗一点就是这个答案是有范围的，不像是bfs这种很多解的，

单调性，就是小的如果能成功，大的就一定能成功，judge函数写起来就是FFFFFFTTTTTT这样的序列

（作者也是蒟蒻，能力有限，还请各位在题目中自行理解） 这种题目显著的特点就是比较容易告诉你答案判断能否成功，而不是正面强推

二分答案就讲到这儿，题目的讲解直接看代码注释

```cpp
#include<cstdio>
#include<algorithm>
#define N (50000+10) 
using namespace std;
int a[N];
int d,n,m,ans;
bool judge(int x){//二分推荐写judge，比较规范比较标准，容易检查
    int tot=0,i=0,now=0;//tot表示需要搬走的石块数量，i表示找的石头，now表示我站在哪一块石头上
    while (i<n+1){
        i++;
        if (a[i]-a[now]<x){//如果距离小于我二分的答案x，那么这块石头需要搬走
            tot++;
        } 
        else{
            now=i;//不然我就跳过来
        }
    }
    if (tot>m) return false;//如果要搬走的石头多于m块，那么这个解太大了
    else return true;
}
int main(){
    scanf("%d%d%d",&d,&n,&m);
    for (int i=1;i<=n;i++) scanf("%d",&a[i]);
    a[n+1]=d; 
    int l=1,r=d,mid;
    while (l<=r){//可以说算是二分的格式吧
        mid=(l+r)/2;
        if (judge(mid)){
            ans=mid;
            l=mid+1;
        } 
        else r=mid-1;
    }
    printf("%d",ans);
}
希望大家看完前面的说明和ac代码后能够对二分答案有个更好的认识，也能更加灵活的使用二分答案，希望这篇题解能够对大家带来帮助
```