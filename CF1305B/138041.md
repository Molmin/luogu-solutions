# 题意

原题：[CF 1305B 【Kuroni and Simple Strings】](https://www.luogu.com.cn/problem/CF1305B)

给定一小括号序列。

每次可以删除其形如 `()` 或 `(())` 等形式的子串，子串可以不连续，求最少操作多少次，以及操作方案，使括号序列不再包含这样形式的子串。

# 分析

睿智的我们发现，如果某子串呈现类似于 `)(` 的形式，就不需要管它，一定不可以构成可以删除的子串。

接着，分析一个括号串

$$(\,)\,(\,(\,)\,)\,$$

如果我们把他分成这样

$$\color{Blue}(\,)\;\color{Orange}(\,(\,)\,)$$

就需要操作两次，因为不允许删除形如 `()()` 的子串

可是，如果我们这样

$$\color{Red}(\;\color{Black})\color{Red}(\;\color{Black}(\;\color{Red})\,)$$

删去红色括号，留下不能构成可删除子串的黑色括号，就可以只用操作一次。

进而发现，什么情况可以在同一次操作处理？

就是**左括号和右括号的出现分别连续**，一旦出现左右括号匹配上的情况，就只能继续往后找右括号而不能找左括号了。

此外，上述例子还告诉我们，需要找到一种方法，把 **不得不匹配上** 的括号删去，留下形如 `)(` 的子串。

注意到所谓 `)(` 形式，其实是左右括号位置相反，那我们考虑尽可能删去原串左侧的 `(` ， 原串右侧的 `)`，而不处理左侧的 `)` 和右侧的 `(` 。

因为只有左侧删 `(` ，右侧删 `)` 才能保证上述的左右括号分别连续。

可是何谓左侧右侧呢，并不是相对于原串中心，而是一种**相对关系**

因此，考虑建立两个指针 $i,\,j$，从原串头尾向彼此扫，即

$$i->\;\;\;\;\;\;<-j$$
$$(())())(($$

一旦两个指针所指位置匹配成一对括号，删去，否则跳过。

然后发现操作数要么是 $1$ 要么是 $0$

虽然很玄幻，但考场上试一试发现对的就交了，理论上按上述过程想应该是对的。虽然不会严格证明。

可能有点贪心的思路吧

# 源码
其实可以更精简，但考场上没有顾虑那么多。

一开始有另一个思路，所以建立数组 $a$ ，但那是错的，并且 $a$ 也没啥用。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 1005;
char s[N];
int a[N];
int flag = 0, tot = 0;
int main()
{
	scanf("%s", s+1);
	int n = strlen(s+1);
	for (int i = 1; i <= n; i++) {
		if (s[i] == '(') {
			a[i] = 1;
		}
		if (s[i] == ')') {
			a[i] = 2;
		}
	}
	int i = 1, j = n;
	while (1) {
		while (i <= j && (a[i]==2))
			i++;
		while (i <= j && (a[j]==1))
			j--;
		if (i >= j) {
			break;
		}
		a[i] = a[j] = -1;
		flag = 1;
		tot += 2;
		i++, j--;
	}
	if (flag) {
		printf("1\n%d\n", tot);
		for (int i = 1; i <= n; i++)
			if (a[i] == -1)
				printf("%d ", i);
	}
	else {
		printf("0\n");
	}
	return 0;
}

```
