这一道题一眼看到像是**DFS**，因为数据范围比较小，只要求出保证相邻的不同的一组解就好了，坏掉的方格不用管，可以很简单的打好DFS，一旦找到一组解就返回，代码的实现也不难，一开始我这个蒟蒻就是这么想的，但是其实有更好的方法，代码的实现完全可以更加的简单。

因为坏掉的方格不用考虑，所以说坏掉的方格越多，限制的条件就越少。然后我们就可以倒过来思考，假设有一种情况可以在没有任何坏掉的方格的时候放满棋子，那么加上坏掉的方格也可以满足条件。然后就是求出这种情况了。

这种情况其实很简单，就是每一个斜行上的颜色一样，然后黑白交替出现。然后就是模拟，(i+j%2)相同的同一种颜色，坏掉方格直接输出'-'，代码很短。
给个图会意一下：

![(其实是国际象棋的棋盘）](https://cdn.luogu.com.cn/upload/pic/14904.png )

AC代码：（写的有点丑）
```cpp
#include<iostream>
#include<cstdio>
using namespace std;

int n,m;
char a;

int main(){
	scanf("%d%d",&n,&m);//读入n，m
	for(int i=1;i<=n;i++){
		a=getchar();//读入换行符，防止被换行符影响
		for(int j=1;j<=m;j++){
			a=getchar();//读入a[i][j]的状态
			if(a=='-'){//为坏就直接输出'-'
				putchar('-');
			}else{
				if((i+j)&1){//(i+j)%2==1就把当前块变成白
					putchar('W');
				}else{
					putchar('B');//否则变成黑，边读边输，所以调试会有点奇怪
				}
			}
		}
		puts("");
	}
	return 0;
}
```