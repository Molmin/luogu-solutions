终于做出来了，我觉得我把构造不出来的想法都试了个遍（

首先这棵树可能是多叉，这就意味着你不可能通过把一个点和它的儿子通过不同的相交方式连在一起，即你不能对于一个儿子把它的右端点放在自己的区间里，而对另一个儿子则是左端点。所以必须是覆盖，比如对于简单的 $1 \to 2, 1 \to 3$ 的树得是 

![](https://s4.ax1x.com/2022/01/26/7qZSaQ.png)

那么如何再连上其它的子树呢？直接再把前面都盖掉是不行的，因为这样要把几个子树合并在一起的时候会使它和它的子子孙孙都连上边。而前面我们知道不能通过不同的方式相交，所以必须在前面那个子树的另一个方向继续加点并保证完全不交，即这样

![](https://s4.ax1x.com/2022/01/26/7quum6.png)

这样可以确保要么覆盖要么完全没有交。最后把最右边的（红色）连起来就是把子树合并了。

这样我们就有了一个大概的构造想法，可是如何去实现这样的一个想法呢？这也是这题很有趣的一个地方。我们并不能一下子通过一种顺序得出每条线段的左右端点，因为一个点的右端点要往右拓展是收到它子树的限制的，而它子树的左端点向左拓展上是受到它限制的，且有的情况下还要空出一个点来一边它的父亲连向它。

为了解决顺序不同的问题，可以先反向确定下来右端点，因为一个点直接相连的子节点的右端点是不需要递归就可以直接确定的。然后再设置一个全局变量作为左边的边界，在往下递归的时候根据是否需要预留一个节点（第一个子树需要）决定是否多拓宽一个左边界，再递归下去即可。最后把当前点的左端点放到下面预留出来的那个点上（儿子就多拓展一个）。

实现我使用了左闭右闭区间并通过返回值传递空出的节点。

```cpp
int dfs(int u, int fa, int rb, int op) {
    int an = 0;
    if (op) an = --rb;
    for (int i = (int)g[u].size()-1; i >= 0; i--) {
        int v = g[u][i];
        if (v == fa) continue;
        R[v] = --rb;
    }
    lb = rb;
    int flag = 0, sp = 0;
    for (int v : g[u]) if (v != fa) {
        if (!flag) sp = dfs(v, u, lb, 1), flag = 1;
        else dfs(v, u, lb, 0);
    }
    if (flag) L[u] = sp;
    else L[u] = --lb;
    return an;
}
void main() {
	std::cin >> n;
	for (int i = 1, x, y; i < n; i++) {
	    std::cin >> x >> y;
	    g[x].push_back(y), g[y].push_back(x);
	} 
	lb = 1;
	dfs(1, 0, 0, 0);
	int min = std::min(*std::min_element(L + 1, L + 1 + n),
	                   *std::min_element(R + 1, R + 1 + n));
	for (int i = 1; i <= n; i++)
	    L[i] -= min - 1, R[i] -= min - 1;
	for (int i = 1; i <= n; i++) std::cout << L[i] << ' ' << R[i] << '\n';
}
```