## 注意

此题被人加了 hack 数据，好多题解代码是错的，这份题解保证正确（因为我是在加了数据之后过的）。

## 题目意思
题目翻译说的很清楚，大家先去看题，不要着急看题解。

这里只补充一个点：

``只要牛铃的大小不超过盒子大小 s ，他可以把 1 个或者 2 个牛铃塞进大小刚好为 s 的盒子里。``

注意，不是每个牛铃大小不超过 $s$ 就行，而是**总大小**！

## 算法及思路
本题为一道~~毒瘤的~~经典的**二分 + 贪心**题。

贪心算法应该不用我讲，基本上约等于暴力（可以理解为**有策略和经过脑子思考的暴力**）。

至于二分，可以[点这](https://www.luogu.com.cn/blog/hugocaicai/solution-p7766)看看算法介绍及实现。

废话不多说，开始这道题的思路讲解。

思路
------------
在讲思路前，大家需**对贪心和二分有基础的了解**（这里我默认大家都会这两种算法了，不会看上面）。

首先，**主要算法是二分**。直接通过**二分枚举 $s$ 的大小**（后面代码为 $ans$）。
- 左边界 $l$ 应该为**输入的最后一个元素**（即代码里的 $a_n$）。因为如果小于 $a_n$，**那 $a_n$ 就装不下任何一个箱子**。再小，也要有个界限。
- 右边界 $r$ 应该为**无限大**，这里我设成了 $10^9$，如果 $r$ 不够大，可能导致**有部分答案枚举不到，造满江红的情况**。
- 每次用 check 函数检查后，如果该答案符合条件，则更新 $ans$。
- 最后输出 $ans$ 即可。

以上不是重点，重要的地方在**贪心**，它用在了 check 函数里，**这也是 hack 数据的毒瘤之处。**

对于贪心，为了让**盒子总数尽量小**，应该让**两个牛铃的箱子数量尽量多**，这个是一定正确的。

我一开始的思路是**直接用最大的跟最小的匹配，次大的跟次小的匹配**……以此类推，最后看看**箱子数量是否大于当前枚举到的盒子数量**，小于等于返回 $1$，否则返回 $0$。

这个代码打出来，你只能对 $2$ 个点。

我们来看样例 $3$：
```
输入：
3 2
3 5 7
输出：8
```
如果按照刚刚的思路，输出结果应该是 $10$。

到底错在了哪里？

题目解释已经给出来了，**最佳搭配应该是 $(3,5)$，$(7)$，并不是$(3,7)$，$(5)$。**

所以，正确的思路应该是：如果**当前最大和最小的匹配不上**，应该让**最大的那个单独放一个箱子**（因为如果**最小的跟最大的都超了，其他跟最大肯定也超了**）。

你以为这道题到这就结束了？

看看题目数据：$1\leq n \leq 2⋅k\leq 100000$。所以，需要 $O(n)$ 的复杂度。

先定义一个**左指针和一个右指针**。如果两个牛铃匹配成功，则**左指针   $+1$，右指针 $-1$。**如果超过箱子容量，则右指针 $-1$。当**左指针等于右指针**时，证明所有牛铃全部匹配成功，判断箱子数量即可。

其他细节，代码里大家自己看吧。

## 一些小坑
1. 最后输出既不是 $l$，也不是 $r$，而是 $ans$。
2. check 函数如果 $O(n^2)$，你就会 Time Limit Enough（时间“充裕”），简称 TLE。
3. 注意上面思路部分提到的毒瘤。

## 代码
代码仅供参考。珍爱生命，远离抄袭。

Code：
```cpp
#include<bits/stdc++.h>
using namespace std;

const int N = 100000 + 10;
int n, k, l, r, ans, mid, a[N];

bool check(int x){
	int l = 1, r = n, cnt = 0;
	//l, r左右指针，cnt箱子个数 
	while(l <= r){
		if(x >= a[l] + a[r] && l != r){
			l++, r--, cnt++;//匹配成功 
		}else if(x < a[l] + a[r] && l != r){
			r--, cnt++;//匹配不上，把较大的放进箱子里（不用判断，r一定不小于l） 
		}else if(l == r){
			l++, cnt++;//特判一下，细心的童鞋发现了，这其实是最后一个了（l <= r） 
		}
	}
	if(cnt > k)	return false;//如果大于了，返回错误 
	return true;//否则返回正确 
}

int main(){
	cin >> n >> k;
	for(int i=1;i<=n;i++)	cin >> a[i];
	l = a[n], r = 1e9;//因为输入保证序列不下降，所以a[n]一定是最大的 
	while(l <= r){
		mid = (l + r) / 2;//枚举箱子大小 
		if(check(mid)){
			ans = mid;//更新答案 
			r = mid - 1;//考虑能不能再小点 
		}
		else	 l = mid + 1;//太小了，大点 
	}//二分过程不解释，不懂的点上面链接 
	cout << ans << endl;
	return 0;//成功hack掉hack数据 
}
```
本篇题解到此结束，如果对你有帮助，别忘了点个赞哦！