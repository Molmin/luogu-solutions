## 1 题意
有一个 $2N$ 个数的序列 $A$，从 $1$ 到 $2N$ 标号。你要把 $1 \sim 2N$ 这些数填进去，使它形成一个排列。

但是已经有一些位置强制填了特定的数了，输入时会给出。

最后令长度为 $N$ 的序列 $B$ 为：令 $B_i = \min\{A_{2 i - 1}, A_{2 i}\}$。

询问所有方案中能得到的不同的 $B$ 的数量。
## 2 转换
首先我们可以发现，对于一个 $i(1\leq i\leq n)$，如果 $A_{2i-1}\neq-1$ 且 $A_{2i}\neq -1$，那么此时的 $B_i=\min(A_{2i-1},A_{2i})$ 是确定的，我们就可以不管这种情况。

删去后数列剩下 $m$ 项。

那么剩下的就只有两种情况：有一个没确定的和两个都不确定的。

### 2.1 两个都没确定的
如果这个二元组中两个数都没有确定，那么这个二元组可以和另外任意的一个两个都没有确定的二元组交换位置。

设这种二元组的个数为 $x$，最后的答案就要乘以 $x!$。

### 2.2 有一个没有确定
如果这个二元组中有一个数确定了，那么这个二元组就是唯一的，即不能与任意一个二元组调换位置。

对于这么多奇奇怪怪的条件，最好的方法是考虑 dp。

由于从小到大 dp 存在后效性，所以我们从大往小 dp。

## 3 dp
设 $dp_{i,j,k}$ 表示考虑了 $i\sim 2n$ 的所有数值，其中有 $j$ 个已经赋值的 $-1$ 等着匹配，有 $k$ 个本身有值的数等着匹配。

初始状态 $dp_{m+1,0,0}=1$。

在转移中，分类讨论 $i$ 的两种情况。
### 3.1 $i$ 在数列中已出现
#### 3.1.1 $i$ 匹配了一个已经赋值的更大的 $-1$
此时 $dp_{i,j,k}$ 由 $dp_{i+1,j+1,k}$ 转移。

由于点 $i$ 是唯一的，那么 $dp_{i+1,j+1,k}$ 的贡献为 $1$。

#### 3.1.2 $i$ 不匹配
点 $i$ 准备与一个更小的值匹配，此时 $dp_{i,j,k}$ 由 $dp_{i+1,j,k-1}$ 转移。

由于没有匹配，贡献为 $1$。

### 3.2 $i$ 在数列中未出现
即 $i$ 放进了某一个 $-1$ 中

#### 3.2.1 $i$ 匹配一个已经赋值的更大的 $-1$
此时 $dp_{i,j,k}$ 由 $dp_{i+1,j+1,k}$ 转移。

因为在最后再统一乘以 $x!$，所以此时的贡献为 $1$。

#### 3.2.2 $i$ 匹配一个更大的已出现的数
此时 $dp_{i,j,k}$ 由 $dp_{i+1,j,k+1}$ 转移。

因为此时匹配任意一个数都会使最终的结果不一样，所以贡献为 $k+1$。

#### 3.2.3 $i$ 不匹配
此时 $dp_{i,j,k}$ 由 $dp_{i+1,j-1,k}$ 转移。

由于没有匹配，贡献为 $1$。

最终答案 $ans=dp_{1,0,0}\times x!$。

时间复杂度为 $\mathcal O (m^3)$。

## 4 code
```
#include<bits/stdc++.h>
using namespace std;
#define ll long long
const ll mod=1e9+7;
ll n,m;
ll a[601],fl[601],b[601],f[601];
ll dp[601][601][601];
int main(){
	cin>>n; 
	n*=2;
	for(ll i=1;i<=n;i++) cin>>a[i];//输入
	for(ll i=1;i<=n;i++){
		if(a[i]!=-1&&a[i+1]!=-1) fl[a[i]]=fl[a[i+1]]=1;//将两个都有值的删掉
		i++;
	}
	for(ll i=1;i<=n;i++){
		if(!fl[i]) b[i]=++m;//剩下的数列
	}
	ll x=0;
	for(ll i=1;i<=n;i++){
		if(a[i]!=-1&&a[i+1]==-1) f[b[a[i]]]=1;//判断是不是-1
		if(a[i]==-1&&a[i+1]!=-1) f[b[a[i+1]]]=1;
		if(a[i]!=-1&&a[i+1]!=-1) x++;//最后系数x!
		i++;
	} 
	dp[m+1][0][0]=1;//初始化
	for(ll i=m;i>=1;i--){
		for(ll j=0;j<=m-i;j++){
			for(ll k=0;k+j<=m-i;k++){
				if(f[i]){
					dp[i][j][k+1]=(dp[i+1][j][k]+dp[i][j][k+1])%mod;//3.1.2
					if(j) dp[i][j-1][k]=(dp[i][j-1][k]+dp[i+1][j][k])%mod;//3.1.1
				}else{
					dp[i][j+1][k]=(dp[i][j+1][k]+dp[i+1][j][k])%mod;//3.2.3
					if(k) dp[i][j][k-1]=(dp[i][j][k-1]+dp[i+1][j][k]*k)%mod;//3.2.2
					if(j) dp[i][j-1][k]=(dp[i][j-1][k]+dp[i+1][j][k])%mod;//3.2.1
				} 
			} 
		}
	}
	ll ans=dp[1][0][0];
	for(ll i=1;i<=x;i++) ans=ans*i%mod;//乘以阶乘
	cout<<ans;
	return 0;
}
```
