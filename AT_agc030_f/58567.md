首先忽略所有已经填好的对。

一个排列可以如下描述：

- 所有形如 $(v,-1)$ 的对中，$-1$ 的具体值。
- - 注意它们显然在先前就已经有顺序，我们不必考虑。
- 剩下元素的两两配对方案，作为 $(-1,-1)$。
- - 和这些 $(-1,-1)$ 的排列顺序（总是 $(-1,-1)$ 对数的阶乘，下文将其忽略）

还注意到以下观察：

- 对于形如 $(v,-1)$ 的情形：
- - 若 $v$ 是较小值则 $-1$ 是谁没关系，都是同一个 $B$。
  - 若 $-1$ 是较小值则它的具体取值会影响 $B$。
- 对于 $(-1,-1)$ 的情形：
- - 较大值的具体取值不影响 $B$，较小值的取值会影响 $B$。

于是我们从大到小考虑每个元素和谁配对。每个元素：

- 如果它是形如 $(v,-1)$ 的对中的 $v$，则称它为**固定插头**。否则称为**不定插头**。
- 如果一个元素是固定插头：
- - 它可以暂时不配对。
  - 或者它可以和之前的一个不定插头配对。注意它每和一个不定插头配对都是同一个 $B$。
- 如果一个元素是不定插头：
- - 它可以暂时不配对。
  - 或者它可以和之前的一个固定或不定插头配对。注意它和每个固定插头配对都是不同的 $B$，但是和不定插头配对却只会产生相同的 $B$。

```cpp
#include<bits/stdc++.h>
using namespace std;

const int p = 1000000007;

int n;
int v[605];
int clr[605];
int f_[2][605][605];

int main() {
	scanf("%d", &n);
	for (int i = 1; i <= 2 * n; i++) scanf("%d", &v[i]);
	for (int i = 1; i <= n; i++) {
		int k = (v[2 * i - 1] != -1) + (v[2 * i] != -1);
		if (k == 2) clr[v[2 * i - 1]] = clr[v[2 * i]] = 2;
		else if(k == 1) {
			if(v[2 * i - 1] != -1) clr[v[2 * i - 1]] = 1;
			if(v[2 * i] != -1) clr[v[2 * i]] = 1;
		}
	}
	f_[1][0][0] = 1;
	n <<= 1;
	for (int i = n; i; i--) {
		auto of = f_[(i + 1) & 1], nf = f_[i & 1];
		if (clr[i] == 2) {
			memcpy(nf, of, 4 * 605 * 605);
		}
		if (clr[i] == 1) {
			memset(nf, 0, 4 * 605 * 605);
			for (int j = 0; j <= n; j++)
			for (int k = 0; k <= n; k++) {
				if (j < n) nf[j + 1][k] = (nf[j + 1][k] + of[j][k]) % p;
				if (k) nf[j][k - 1] = (nf[j][k - 1] + of[j][k]) % p;
			}
		}
		if (clr[i] == 0) {
			memset(nf, 0, 4 * 605 * 605);
			for (int j = 0; j <= n; j++)
			for (int k = 0; k <= n; k++) {
				if (k < n) nf[j][k + 1] = (nf[j][k + 1] + of[j][k]) % p;
				if (k) nf[j][k - 1] = (nf[j][k - 1] + of[j][k]) % p;
				if (j) nf[j - 1][k] = (nf[j - 1][k] + 1LL * j * of[j][k] % p) % p;
			}
		}
	}
	
	int ans = f_[1][0][0];
	for (int i = 1, cnt = 0; i <= n / 2; i++)
		if (v[2 * i - 1] == -1 && v[2 * i] == -1) ans = 1LL * ans * ++cnt % p;
	printf("%d\n", ans);
}
```