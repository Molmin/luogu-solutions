首先不难发现，我们与其对每个 $a_i$ 确定其 $d_{\max}$ 和 $d_{\min}$，不如考虑这个 $a_i$ 能配对的最大和最小的 $b$。

考虑一对点对 $(a_i,b_j)$ 可以配对的充要条件：$a_i
\le b_j$ 且其余位置均能够配对。

对第一件事，不妨记一个数 $p_i$，表示最小的 $a_i\le b_{p_i}$ 的位置。那么 $p_i\dots n$ 中每个位置，都可能成为 $a_i$ 配对位。

考虑如何满足第二件事：贪心的考虑，对于每个 $a_i$，我们让其和剩余且第一个不小于其的 $b$ 配对。反过来，我们让每个 $a_i$ 和 $b_{p_i}$ 配对即可。因此 $d_{\min}=b_{p_i}-a_i$。第一问解决。

再来看第二件事。不妨对 $b$ 开一个辅助数组 $w_i$ 表示 $b_i$ 匹配完后剩余多少个闲余的 $a$。那么显然匹配失败的充要条件为存在 $b_i<0$。根据定义，对每个 $a_i$，我们让 $w_{p_i}...w_n+1$。对每个 $b_i$，我们让 $w_i\dots w_{n}-1$。当我们试图匹配 $(a_i,b_j)$ 时，将其贡献赋成 0 即可。

根据这个模型我们也可以看出为什么第一问直接取 $p_i$ 是正确的。

发现对于一个 $i$，$a_i$ 贡献赋 $0$ 是恒定的，$b$ 的贡献赋 $0$ 是一段后缀，并且 check 只需要检查全局 $\min$ 非负。所以可以直接二分位置+线段树维护。

[AC 记录](https://codeforces.com/contest/1721/submission/169845575)