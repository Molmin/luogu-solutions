# P2339Turning in Homework 题解

[P2339](https://www.luogu.com.cn/problem/P2339)链接在此

本题使用的大致思想有**贪心**和**动态规划**。

使用的模型是**区间DP**。更加细致地，是在区间两端的DP。

$~$

## 贪心：
首先应当明确的是，我们的路线应该是酱紫的：

![](https://accrobin.github.io/assets/image/Arti3.jpg)

原因：
1.我们不可能一直朝着一个方向走，走走停停，那样显然是不优的。
2.那为什么我们的圈子越兜越小了呢？（想一想，为什么？）$^1$

继续，我们考虑，$\exist ~i,j ~s.t.~x_i \le x_j \land T_i \le T_j$这样的两间教室。通俗点讲，就是$i$教室在$j$教室前面，而且$i$教室先下课。那么我们就可以在前往$j$教室的路上顺便前往$i$教室。如果$T_i \ge T_j$，那么我们可以在从$j$返回的路上顺便前往$i$教室。

所以我们应当将每件教室按照位置进行排序（贪心的体现）。

$~$

## 动态规划之区间DP

$~$

### 变量的选取
既然我们兜的圈子是精心规划过的，那么就应当以圈子的范围为突破口。也就是说，将**圈子的范围**作为转移方程的变量，以此来进行转移。我们先将圈子的左右端点记下来，记作$l$和$r$。之后，我们将圈子更严谨地成为“**区间**”。

不过，只有范围还是很粗糙的，我们要进一步精致化。

考虑：我们现在处在一个区间的端点上，接下来要如何走？等等，突然发现似乎我们并不清楚现在**究竟处在这个区间的哪一个端点上**。

因为**处在不同的端点就有不同的转向策略**，所以，必要地，我们应当把现在所处区间的端点也作为一个变量。区间只有两个端点，那么我们记$0$作为左端点，记$1$作为右端点。

$~$

### 动态转移方程
为了简洁和易于理解，将两点$i,j$之间的距离记作$dis(i,j)$，而在具体实现中我们应使用$|x_i-x_j|$，即`abs(a[i].x-a[j].x)`。

请读者**再次阅读题目**，**明确各个变量的含义**。

接下来就是写出动态转移方程的时候了：

我们设$f[l][r][0]$表示当前处在区间$[l,r]$的左端点时$^2$，已经花费的最小时间。

$~$

一、考虑当我们处在区间$[l,r]$的左端点上时，上一步可能是从哪里转移过来的：

　　1）如果是第$l-1$个教室，我们花费的时间至少是$f[l-1][r][0]+dis(l-1,l)$，（已经花费的时间+将花费的时间）。又因为受到了时间$T$的限制，故我们这个步骤的结果就是$\max(f[l-1][r][0]+dis(l-1,l),T_{l})$。

　　2）如果是第$r+1$个教室，我们花费是时间至少是$f[l][r+1][1]+dis(l,r+1)$，同样受到时间限制，这个步骤的结果是$\max(f[l][r+1][1]+dis(l,r+1),T_{l})$。

　　我们要从这两种情况中选择时间更小的那个，所以：

$$
f[l][r][0]=\min \begin{Bmatrix}
\max(f[l-1][r][0]+dis(l-1,l),T_{l})
 \\
\max(f[l][r+1][1]+dis(l,r+1),T_{l})
\end{Bmatrix} 
$$

$~$

二、考虑当我们处在区间$[l,r]$的右端点上时，上一步可能是从哪个教室转移来：

　　1）如果是第$l-1$个教室，结果就是$\max(f[l-1][r][0]+dis(l-1,r),T_{r})$。

　　2）如果是第$r+1$个教室，结果就是$\max(f[l][r+1][1]+dis(r,r+1),T_{r})$。

　　结合这两种情况，可得：

$$f[l][r][1]=\min \begin{Bmatrix}
\max(f[l-1][r][0]+dis(l-1,r),T_{r})
 \\
\max(f[l][r+1][1]+dis(r,r+1),T_{r})
\end{Bmatrix} $$

**综上所述**，我们可以得到：

$$
f[l][r][0]=\min \begin{Bmatrix}
\max(f[l-1][r][0]+dis(l-1,l),T_{l})
 \\
\max(f[l][r+1][1]+dis(l,r+1),T_{l})
\end{Bmatrix}\\
f[l][r][1]=\min \begin{Bmatrix}
\max(f[l-1][r][0]+dis(l-1,r),T_{r})
 \\
\max(f[l][r+1][1]+dis(r,r+1),T_{r})
\end{Bmatrix}
$$

然后照着抄，实现在代码上就OK了~

你以为这就OK了？不！还有很多细节：

$~$

## 实现的细节
### 初始化$f$数组
$f$数组的初始化应该赋值为$\infty$，但是还应当把$f[1][n][0]$和$f[1][n][1]$用转移方程来预处理出来。

$~$

### 答案的选择
我们在做完这些步骤之后，得到的是最小的区间$[i,i]$，而区间$f[i][i][0/1]$还要加上$dis(i,d)$才是最终答案。我们还要再$O(n)$跑一遍得出最小值。

代码：

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>

#define max std::max
#define min std::min

typedef struct Res
{
	int x, t;
	bool operator < (const Res &b) const
	{
		if(x<b.x)
			return 1;
		return 0;
	}
}Res;
Res a[1005];
int dp[1005][1005][2];
int main(void)
{
	int n, len, E, i, j, ans;
	scanf("%d%d%d", &n, &len, &E);
	for(i=1;i<=n;i++)
		scanf("%d%d", &a[i].x, &a[i].t);
	sort(a+1, a+n+1);
	memset(dp, 62, sizeof(dp));
	dp[1][n][0] = max(a[1].x, a[1].t);
	dp[1][n][1] = max(a[n].x, a[n].t);
	for(i=1;i<=n;i++)
	{
		for(j=n;j>=1;j--)
		{
			if(i==1 && j==n) continue;
			dp[i][j][0]=min(max(dp[i-1][j][0]+a[i].x-a[i-1].x,a[i].t),max(dp[i][j+1][1]+a[j+1].x-a[i].x, a[i].t));
			dp[i][j][1]=min(max(dp[i-1][j][0]+a[j].x-a[i-1].x,a[j].t),max(dp[i][j+1][1]+a[j+1].x-a[j].x,a[j].t));
		}
	}
	ans = 2147483647;
	for(i=1;i<=n;i++)
		ans = min(ans, min(dp[i][i][1], dp[i][i][0])+abs(E-s[i].x));
	printf("%d\n", ans);
	return 0;
}
```

1:反证

分两种情况：

1）假设我们的圈子大小一直不变，在圈子边界上就会出现时间的浪费，不优。

2）假设我们的圈子越兜越大，在圈子中心就会出现越来越多的空闲教室，也就是说，我们花费的大量不必要的时间在路上。

更加**感性**地，我们这样考虑：圈子越来越小，意味着我们尽可能地将**路上**花费的时间减小了，是更优秀的。

$~$

2:贪心

此时除了这个区间以外的所有教室的作业都已经收好了，不用去理会。注意，$l$和$r$是已经收好作业的。