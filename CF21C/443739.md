题目只是让我们将这个序列分为 3 段，并且保证每一段都相等，那么我们肯定会首先去判断可不可以这样分。
```cpp
	for(i=1;i<=n;i++){
		scanf("%d",&a[i]);
		sum+=a[i];
	}
	if(sum%3!=0){
		printf("0");
		return 0;
	} 
```
就像上面的这样，但是大家可能会觉得这有个缺点，比如说如果输入样例是 2,3,3。

确实可以直接进行下一步操作，不过这个是不能分成三段的。我也是想到了这一点。于是加了个这个东东：
```cpp
sum/=3;
```
如果要想理解这个等一下我会讲，我必须得先把思路讲完。
然后我们就直接循环判断，再次把每个数加起来，如果说是 $sum$ 那么就让方法加一，但是因为后面可能会出现零的情况，所以前往不可以将前面的值给清空否则完蛋，如果是 $sum$ 的两倍，那么就把原来计算是否等于 $sum$ 的值再加给另外一个变量的值，而这个值就是我们要的东西。

但我们为什么不考虑第三段呢？因为你想一想，我们一二段都求出来了，而且我们也证明它是可以成为三段的，也就没这个必要了。
所以其代码如下：
```cpp
	long long ans=0,k=0,t=0;
	for(i=1;i<n;i++){
		ans+=a[i];
		if(ans==sum*2) k+=t;
		if(ans==sum) t++;
	}
	printf("%lld\n",k);
```
好了这下就讲完了，关于上面的那个代码的解释我也给大家说一下，我们再次以上面的示例为例：输入 2,3,3。

因为这个是可以绕过取余 3 的判断的，但是下面的要使得前面的第一段的值之和必须得为 2，可是却不行，所以我们这个方法是可以的。

不过这还是不对，那么我们是哪里错了呢？主要是我们的判断第一个要放在第二个的后面，为什么呢？因为也存在着这种情况，那么就是说前面是可以满足第二段也可以满足第一段，如果碰到这种情况，如果不是这样放的话，第二段和第一段的分割点是重合的！那么也就表示这个分割点是不可取的。

最后是全部代码：
```cpp
#include<bits/stdc++.h>
const int CF=100010;
using namespace std;
int a[CF];
int main(){
	int n,i;long long sum=0;//不开long long 见祖宗。
	scanf("%d",&n);
	for(i=1;i<=n;i++){
		scanf("%d",&a[i]);
		sum+=a[i];
	}
	if(sum%3!=0){
		printf("0");
		return 0;
	} 
	sum/=3;
	long long ans=0,k=0,t=0;
	for(i=1;i<n;i++){
		ans+=a[i];
		if(ans==sum*2) k+=t;
		if(ans==sum) t++;
	}
	printf("%lld\n",k);
	return 0;
}
```

//不用说谢谢，不因客套，只因能见您的笑容，以及您电脑上的 AC，您已经回报。

//祝大家信息学越来越棒哦！