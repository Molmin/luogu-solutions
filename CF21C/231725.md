啊这，这道题卡了我好久……就因为两句代码写反了（而且反过来应该也是没影响的）

**咳咳**，回归正题。

题目中说了 $ n=10^5 $ ，所以前缀和肯定是要用的（一本正经）

~~于是我就作死打了个 $ n^2 $ 的暴力……~~

主要思路是枚举两个分割点，再通过前缀和判断三段是否相等。

然后贴一下核心的代码：

```cpp
for(int i=1;i<n-1;i++){
	if(a[i]==a[n]/3)f[++tot]=i;//玄学初始化 
}
for(int i=1;i<=tot;i++){
	if(a[f[i]]!=a[n]/3)continue;//玄学优化 
	for(int j=f[i]+1;j<n;j++){
		if(a[f[i]]==a[j]-a[f[i]]&&a[f[i]]==a[n]-a[j]){//判断 
			ans++;
			if(a[j+1]>0)break;//玄学优化 
		}
	}
}
```
~~嗯，事实证明这题的数据并不水~~，那么就想办法优化呗~

核心思想其实差不多，但是我们稍微思考一下就会发现：

如果一个点是第一个分割点，那么这个点就会满足 $ a_i=\mathtt{tot} \div 3 $ ，而如果后面还有第二个分割点，那么我们就可以直接将答案加上前面可以做第一个分割点的个数。

所以，我们就只需要在遇到满足第一个分割点时，将此时记录第一分割点的变量加一，然后在后面遇到第二分割点时将答案加上此时的第一分割点个数就可以啦~

**Code：**
```cpp
#include<bits/stdc++.h>         //万能头 
using namespace std;
long long n,ans,a[100005];      //不开 long long 见祖宗！ 
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		int x;
		cin>>x;
		a[i]=a[i-1]+x;          //前缀和 
	}
	if(a[n]%3!=0){              //此处有一个特判，前面没有讲到，但是不要忘了加哦~ 
		cout<<0;
		return 0;
	}
	long long tot=0,sum=a[n]/3;
	for(int i=1;i<n;i++){
		if(a[i]==sum*2)ans+=tot;//先判断这个点是否为第二分割点 
		if(a[i]==sum)tot++;     //在判断这个点是否为第一分割点，之前就是这两句写反了，我也很懵啊…… 
	}
	cout<<ans;
	return 0;
}
```
~~不要脸地求个赞~~