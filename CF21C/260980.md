### 前言

一道橙题我还做了一天，我果然变弱了。

### 分析

#### 题意

就是让你将这个序列分成 $3$ 段，然后要达到每段的总和相等。

#### 解题思路

分成 $3$ 段？

那就先统计一下总和，然后特判一下是否可以分成三段。

如果可以，那就开始处理。

`int x,y x表示到i的总和，y表示前面有多少个是总和/3的`

然后用一个 `ans` 作为答案。

那么 $i$ 从 $1$ 到 $n-1$ 开始处理，至于为什么到 $n-1$，因为 **each piece contains positive integer amount of squares.**，也就是说每一段必须是有整数的，如果是到 $n$ 那么就有可能存在着在 $n$ 的那个地方分割的可能性。

然后判断一下，是否存在着 $x=tot$ 如果存在那么就表示从 $1$ 到这里是存在着可以分割的 $1$ 段的。

还要一个判断，那么就是 $x=tot \times 2$ 是否成立，如果成立那么就证明前面有可以分成 $2$ 段，也可以表示后面有 $1$ 段，至于为什么，那么可以想一想前面已经处理过了可以分成 $3$ 段，那么如果前面是 $2$ 段的，后面必然是存在着 $1$ 段的。如果成立的话 $ans=ans+y$ 因为 $y$ 是表示前面有多少个 $1$ 段可以分的，那么也就说明了如果这个地方是可以对于后面的 $1$ 段是可以分的，那么前面的都会和这个点分会满足条件，满足了条件那么答案加上 $y$。

第二个判断要放在第一个前面，至于为什么，因为也存在着这种情况，那么就是说前面是可以满足 $2$ 段 也可以满足 $1$ 段，如果碰到这种情况，如果不是这样放的话，$2$ 段 和 $1$ 段的分割点是重合的！那么也就表示这个分割点是不可取的。

那么最后就输出答案。

### 代码

```cpp
#include <iostream>
#include <cstdio>
using namespace std;
const int INF=1e5+5;
int n,a[INF];
long long ans,tot;//不开 long long 见祖宗。
signed main()
{
        scanf("%d",&n);
        for (int i=1; i<=n; i++) {
                scanf("%d",&a[i]);
                tot+=a[i];
        }
        //读入处理。
        if (tot%3!=0) return 0&puts("0");//如果不能分三段，那么结束。
        long long x=0,y=0;
        tot/=3;
        //变量意义前面已经说过了。
        for (int i=1; i<n; i++) {
                x=a[i]+x;
                if (x==tot*2) ans=ans+y;//如果这个点是可以分前面 2 段的，那么答案加上 y。
                if (x==tot) y++;//如果这个点是可以分前面 1 段的，那么 y+1。
        }
        printf("%lld\n",ans);//输出答案。
        return 0;
}

```

### 写在后面的话

我这篇题解如果有错误，那么请在评论区里留言，我将会很感谢反映的人。

**谢谢观赏！**