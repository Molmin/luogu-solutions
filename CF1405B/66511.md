## 【题意】
给你一个数组 $a$，保证 $\sum a_i=0$ ，每一次可以对一个数对 $(i,j)$ 进行一次操作，使得 $a_i=a_i-1,a_j=a_j+1$ ，若 $i<j$ 则操作免费，否则操作代价为 $1$ 。

求最小的代价使得 $\forall a_i=0$

## 【思路】
最优化问题，考虑贪心。

首先不难发现，我们只减 $>0$ 的，只加 $<0$ 的。

由于 $i<j$ 时操作免费，我们对于每一个 $>0$ 的，都最应该优先用它来抹平 **它之后第一个** $<0$ 的。然后实在不能用前面的抹平的 $<0$ 的数，我们不得不选取最后面的 $>0$ 的数来花费代价抹平它。

于是我们维护一个前缀和就行了，当前缀和 $<0$ 时，直接借用最后面的让前缀和 $=0$ 并记录花费，由于 $\sum a_i=0$ ，我们可以不用管 **借用** 二字，直接在前缀和 $<0$ 时让前缀和归零也能得到正确答案。

实现细节见代码。

## 【代码】
```cpp
#include <bits/stdc++.h>
using namespace std;
int n;
int a[100005];
int main(){
	int t;scanf("%d", &t);
	while(t --){
		scanf("%d", &n);
		for (register int i = 1;i <= n;i ++)scanf("%d", &a[i]);
		long long ans = 0, num = 0;
		for (register int i = 1;i <= n;i ++){
			num += a[i];
			if(num < 0){
				ans -= num;
				num = 0;
			}
		}
		printf("%lld\n", ans);
	}
}
```