## 题意

有 $n(1\le n\le 5000)$ 个空盒子，第 $i$ 个是边长为 $a_i$ 的立方体。你可以把盒子 $i$ 放进盒子 $j$ 当且仅当

+ 盒子 $i$ 没有被放进别的盒子里
+ 盒子 $j$ 里没有别的盒子
+ 盒子 $i$ 的边长小于盒子 $j$ 的边长($a_i<a_j$)

要求操作若干次之后，最终剩下的盒子个数的最小值。

## 思路1

$O(n^2)$ 暴力模拟，将数组从大到小排序，然后用数组 $em_i$ 来记录盒子 $i$ 是否为空(即里面没有盒子)，0 为空，1 为非空。

最后只需要输出空盒子总数，即满足
```
em[i]==0
```
的 $i$ 的个数即可。

#### 那如果 $1\le n\le 10^5$ 怎么做呢？

## 思路2

用 $map$ 存储 $cnt$ 数组，其中 $cnt_i$ 记录边长 $i$ 出现的次数。答案就是 $cnt_i$ 中的最大值。

接下来证明一下这个思路：设 $cnt_x$ 为最大值，则比边长 $x$ 小的都能够装入盒子，再将边长为 $x$ 的都装到比它大的盒子中去，大的盒子是不够的，则最少每一叠盒子中都有一个边长为 $x$ 的(没有多出来的大盒子)，因此答案就是 $cnt_x$。

## 代码

接下来放上思路 2 的完整代码。思路 1 大家可以自己尝试着去写。
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,ans,a[5005];
map<int,int>m;
int main(){
    ios::sync_with_stdio(0);
    cin.tie(0);
    cin>>n;
    for(int i=0;i<n;i++){
	cin>>a[i];
	m[a[i]]++;
	ans=max(ans,m[a[i]]);
    }
    cout<<ans<<endl;
    return 0;
}
```
