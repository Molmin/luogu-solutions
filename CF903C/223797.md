这道题要用贪心？？？

这道题实际上就是一个变形的抽屉原理。

我们想象一下，可见盒子数为$1$是什么情况，情况就是，所有数不重复，然后递增着放就行了，小的放大的里面，这样一直套，一直套到最大的盒子里。

但是当有重复的数怎么办？

我们可以把它划分成多个可见盒子数为$1$的情况，保证每个划分出来的东西都满足其中没有任何重复的数即可。

最后我们应用抽屉原理即可：只有重复次数最多的数才需要考虑，记重复次数最多的数为$max$，我们设其它数的重复次数都等于$max$，那么将正好组出$max$组可见盒子数为$1$的情况，那么既然增加了几个数都是$max$，而又因为重复次数最多的数不能重复在一个可见盒子数为$1$的情况中，所以答案最小是$max$。

既然一个数最大是$max$最小是$max$，所以

## $ans=max$

再利用map数组$mp[i]$记录$i$出现的次数，最终取最大值即可，最后上没压行的代码（为了你们看的方便）：

```cpp
#include<bits/stdc++.h>
using namespace std;
map<long long,long long> mp;
long long a,b[5005],maxn=1;
int main(){
	cin>>a;
	for(int i=1;i<=a;i++){
		 cin>>b[i];
		 maxn=max(maxn,++mp[b[i]]);
	}
    cout<<maxn;
}
```
