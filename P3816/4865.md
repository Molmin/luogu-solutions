啊，好久没有写题解了~

看到这道题，大家首先想到的一定是一个会TLE的DP：

设f[i][j][0]表示大小为i的黑高度为j的以红色节点为根节点的红黑树中平均路长的最大值，f[i][j][1]表示大小为i的黑高度为j的以黑色节点为根节点的红黑树中平均路长的最大值，可以列出DP方程：

f[i][j][0]=max{f[k][j][1]+f[i-k-1][j][1]+i},

f[i][j][1]=max{f[k][j-1][0]+f[i-k-1][j-1][0]+i,f[k][j-1][0]+f[i-k-1][j-1][1]+i,f[k][j-1][1]+f[i-k-1][j-1][0]+i,f[k][j-1][1]+f[i-k-1][j-1][1]+i}.

这个DP的时间复杂度是O(n^2 log n)，因为一棵有n个节点红黑树的高度至多是2 log (n+1)，当n=30000时使用这个算法程序往往要运行数分钟。
如何过这道题呢？

我们有了可以在数分钟解决n=30000的算法，设当n=1,2,…,30000的答案是a[1],a[2],…,a[30000],使用此算法打表记录a数组即可。

……

代码交上去，"Unknown Error"…

原因很简单，提交的代码会有长度限制，一般OJ都是要求代码长度不超过50KB,还不清楚洛谷这边怎样，反正直接用C++初始化记录的数组的方法打表代码将近200KB，是交不上去的。

考虑减少代码量。

我们发现a数组相邻两项的差并不是很大，大多都在(-100,100)之间，于是我们设b[i]=a[i+1]-a[i],打表记录a[1]和b数组，代码长度变为90KB左右。
90KB还是太长，我们可以按类似上述的方法继续减少代码，设c[i]=b[i+1]-b[i],发现大多时候c每一项∈(-10,10),打表记录a[1],b[1]和c数组，代码长度60KB左右。

到这里大家一定想到设d[i]=c[i+1]-c[i],打表记录a[1],b[1],c[1]和d数组，然而c的值域已经很小了，小到了其绝对值几乎只有个位数和十位数，所以代码长度并不会减少太多。

观察打表代码，发现代码中出现了大量的逗号，这是由于要初始化过长的整型数组，于是想到用一个字符来表示一个数，借此初始化字符串，比如我们设ascll码为0的字符表示0,ascll码为1的字符表示1…但是我们在C++代码中用一个字符来表示ascll码为0,1,…的字符，所以我们设ascll码为111的字符表示0,ascll码为112的字符表示1…代码长度一下子被优化到约30KB，实测可以交上去，轻轻松松拿到Rank 1.

以往写完题解，我都会附上自己的代码，然而代码太长，我就破例不附了。

哦，对了，当年福建省选这道题不让打表。

……

……

……