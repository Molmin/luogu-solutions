思路：
## 一个公司想要通过他控制的公司来控制其他公司的前提是他有控制了的公司
这虽然是句废话，但是我们可以发现：
## 可以先判断某公司直接控制的公司，再考虑其他公司。
所以先以每个公司为基准点出发，遇到能控制的公司就连起来，对它掌控股权的公司进行搜索，结果累加到他的父亲（也就是控制它的公司中），直至在加了一次后发现该公司对刚刚获取股权的公司的股权达到了50%以上，就可以对他继续搜索

~~这不就是dfs吗~~

哦，对了，可能有环的存在，所以对于已经控制的公司就不要再搜了，因为你控制它的那一刻就对他搜索过了。

代码如下：


```cpp
#include <iostream>

using namespace std;

int a[120][120],b[120][120],ak[120][120],a0[120],i,j,k,o,p,q,m;//ak是专门用来标记的，监测每个公司分别掌握了哪些公司的股权来提高查找效率
//b用来标记已经控制的公司来避免死循环
//a用来标记公司之间掌握的股权数,通过累加实现查找 
//a0专门标记每个公司掌握了多少公司的股权 
int fh;//没有返回值也给他安个返回值 

int search(int x,int y){
	for(int w=1;w<=a0[y];w++)
	{
		a[x][ak[y][w]]+=a[y][ak[y][w]];
		if(a[x][ak[y][w]]>=50 && b[x][ak[y][w]]!=1)
		{
			b[x][ak[y][w]]=1;
			fh=search(x,ak[y][w]);
		}
	}
	return 0;
}

int main(int argc, char** argv) {
	cin>>m;
	for(i=1;i<=m;i++)
	{
		cin>>o>>p>>j;
		a[o][p]=j;
		ak[o][++a0[o]]=p;
	}

	for(i=1;i<=100;i++)
	{
		b[i][i]=1;
		if(ak[i][1]!=0)
		for(j=1;j<=a0[i];j++)
		{
			if(a[i][ak[i][j]]>=50 && b[i][ak[i][j]]!=1 && i!=ak[i][j])//去重
			{
				b[i][ak[i][j]]=1;
				fh=search(i,ak[i][j]);
			}
		}
	}
	for(i=1;i<=100;i++)
		for(j=1;j<=100;j++)
		if(b[i][j]==1 && i!=j)
		{
			cout<<i<<" "<<j<<"\n";
		}
	return 0;
}
```
