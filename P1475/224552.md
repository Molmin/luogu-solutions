 _本蒟蒻的第一篇题解。谨以此题纪念我的AC200吧，望管理员爸爸审核通过！_ 

[原题传送门](https://www.luogu.org/problem/P1475)

****看到这道题我第一秒就想到：水题！并查集秒切！ 
忽然转念一想，本蒟蒻还不会并查集鸭。。。。点开标签，简单的搜索二字饱含大大地深意（其实就是个普通的暴搜），那我们就利用离散化搞一下这道题吧!

## 所谓离散化：

#### 官方定义：
把无限空间中有限的个体映射到有限的空间中去，以此提高算法的时空效率。

Emmmm。。。这么有技术含量的定义想来我这种蒟蒻也看不懂

#### 通俗一点：
就是把没有用的数据全部删掉，换成一些比较小的数来代替这些大数据，用小数据来处理大数据。

数据比较水，所以再简单的写一个暴搜，快乐的提交
AC其实很简单。

### 附：点开提交记录第一页便有两名小可怜抄题解棕名了。。题解虽好，小心中毒噢！

本题解离散化过程思维难度略大，不过还是很好理解的
## 请君放心食用！


详情见注释吧，附上代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,p,q,m,num,hh[2333333],h[6333][6333],w[6333][6333];
int a[6333][6333],b[2333333],c[6333][6333],f[2333333],g[6333][6333],o[2333333];
bool d[6333][6333],e[23333];
int yes(int x,int y){
	for(int i=1;i<=num;i++){
		a[x][i]+=a[y][i];       //最初的公司对其他的公司控制力又强了几分 
		if(a[x][i]>50&&!d[x][i]){      //又有公司要凉了 
			d[x][i]=1;
			c[x][++b[x]]=i;
			yes(x,i);             //继续寻找可供最初的公司控制的子公司 
		}
	}
}
int kuo(int x){
	for(int i=1;i<=num;i++)
		if(a[x][i]>50&&!d[x][i]){        //如果可以控制且1公司还没控制2公司 
			d[x][i]=1;
			c[x][++b[x]]=i;          //2公司沦陷了。。。。 
			yes(x,i);         //进入递归，扩展1公司通过2公司可以控制的其他公司 
		}
}
int main(){
	int i,j;
	cin>>n;
	for(i=1;i<=n;i++){
		cin>>p>>q>>m;                //朴素的不能再朴素的输入  （逃 
		if(!e[p]){o[++num]=p;e[p]=1;}          //记录下来每个值 
		if(!e[q]){o[++num]=q;e[q]=1;}          //为离散化做准备 
		g[p][++hh[p]]=q;              //记录和某一个公司有连接的所有其他公司 
		h[p][q]=m;
	}
	sort(o+1,o+num+1);                   //做一个排序保证数据输出升序排列 
	for(i=1;i<=num;i++)f[o[i]]=i;          //
	for(i=1;i<=num;i++)                //离散化 
		for(j=1;j<=hh[o[i]];j++)
			a[i][f[g[o[i]][j]]]=h[o[i]][g[o[i]][j]];
	for(i=1;i<=num;i++)kuo(i);               //查找被i公司控制的公司，dfs开始！  
	for(i=1;i<=num;i++)                 //输出i公司控制的公司 
		for(j=1;j<=num;j++)
			if(d[i][j]&&o[i]!=o[j])             //自己不能控制自己所以o[i]!=o[j] 
				cout<<o[i]<<" "<<o[j]<<endl;       //输出结果 
	return 0;            //每天return 0，快乐赛神仙！！ 
}
```
 _小生不才，题解不如各位dalao有技术含量，若有疑问评论区讨论！
祝各位OIer永葆黑发！_ 