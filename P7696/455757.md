**这是本蒟蒻第十七次写的题解，如有错误点请好心指出！**

## 问题简述

__这道题我们可以换另一种思路去看待它，就容易理解了：__

给你一个正整数 $n$ 和含有 $n$ 个数的数组 $a$ 并进行操作：取一个质数 $x$ 使得 $\frac{a[i]}{x}$ 为整数，将 $a[i]$ 除以 $x$ 并将 $a[i]$ 乘上 $x$。

经过多次操作使得数组 $a$ 里的数的最大公因数最大，求出该最大公因数并算出得到该数的最少操作次数。

## 解法综述

由取质数 $x$ 进行操作和求最大公因数可知解决该题一定要求质数和分解因数，然后分开考虑题目问的问题。

- 预处理求质数：由数组 $a$ 中的数不超过 $10^{6}$ 可知我们只需要求出 $10^{6}$ 以内的质数并将这些质数存入数组 $zs$ 中。

- 求最大的最大公因数：我们将数组 $a$ 里的数因数分解，用数组 $ys$ 存储得到数组 $a$ 所有数的各个因数的个数（保证分解的因数都是质数），其中 $ys[i]$ 表示第 $i$ 个质数的个数。

  得出数组 $ys$ 的所有信息后，即可求出最大的最大公因数了。用 $s$（$s$ 初始为 $1$）累乘 $zs[i]^{ys[i]/n}$，而 $s$ 就是我们要的最大的最大公因数，其中 $zs[i]^{ys[i]/n}$ 表示用 $n$ 均分 $ys[i]$ 个质数 $zs[i]$ 相乘的积。
  
- 求最少操作次数：我们将数组 $a$ 里的数因数分解，得出 $a[i]$ 的各个因数的个数，与 $s$ 的各个因数的个数相比较，若 $a[i]$ 的一个因数的个数小于 $s$ 对应的因数的个数，则 $a[i]$ 的该因数需要操作。

## 代码描述
```cpp
#include<cmath>
#include<cstdio>
int n,cnt;
double a[105];
long long s=1,s1;
int bz[1000005],zs[1000005];
void pdzs(int x)//判断质数
{
	for(int i=2;i<=x;i++)
	if(!bz[i])
	{
		zs[++cnt]=i;
		for(int j=1;i*j<=x;j++) bz[i*j]=1;
	}
	return;
}
int ys[1000005];
void fjys(int x,int t)//分解因数
{
	for(int i=1;zs[i]<=x;i++)
	while(x%zs[i]==0)
	{
		x/=zs[i];
		ys[i]+=t;
	}
	return;
}
int main()
{
	pdzs(1000000);//预处理求1000000以内的质数
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
		scanf("%lf",&a[i]);
		fjys((int)a[i],1);//将a[i]因数分解
	}
	for(int i=1;i<=cnt;i++)
	{
		if(ys[i]/n!=0) s=s*pow(zs[i],ys[i]/n);//求最大的最大公因数
		if(ys[i]!=0) ys[i]=0;
	}
	printf("%lld ",s);
	for(int i=1;i<=n;i++)
	if(a[i]!=s)//若a[i]与s相等，则a[i]不需要进行任何操作
	{
		fjys((int)a[i],1);//将a[i]因数分解
		fjys(s,-1);//将s因数分解
		for(int j=1;j<=cnt;j++)
		if(ys[j]!=0)
		{
			if(ys[j]<0) s1-=ys[j];
			//ys[j]既是a[i]的因数zs[j]的个数与$s$对应的因数的个数的差，也是需要操作的次数的相反数
			ys[j]=0;
		}
	}
	printf("%lld",s1);
	return 0;
}
```