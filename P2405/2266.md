non的天平:高精除+DP

DP。。

non最近正在为自己的体重而苦恼，他想称量自己的体重。于是，他找来一个天平与许多砝码。

题目描述 Description

砝码的重量均是n的幂次，n^0、n^1、n^2、n^3、n^4、n^5的……non想知道至少要多少个砝码才可以称出他的重量m。注意砝码可以放左边，也可以放右边。

输入输出格式 Input/output

输入格式：

第一行一个正整数m，表示non的重量；

第二行一个正整数n，表示砝码重量幂次的底；

输出格式：

一个整数表示最少所需的砝码数。

输入输出样例 Sample input/output

样例测试点#1

输入样例： 在线IDE

99
10
输出样例：

2
说明 description

【数据范围】

对于30%的数据点，m <= 2^63 - 1

对于100%的数据点，0 <= m <= 10^10000, 0 < n <= 10000




分析：对于本题的数据范围，势必要高精了。

首先说明白一点：天平使用原则：左物右码。

那么题目可以等效成这样：右边的质量-左边的质量=给出的质量，所以砝码就有了加减两个策略可以选择

我们先来看题目的样例：99

99的得出有两种大的方向：加策略 和 减策略

首先加策略的话，需要9\*10+9\*1  ->18个

其次减策略的话，需要1\*100-1\*1  ->2个

样例减策略要优于加策略。


原题目也就等价于这样一个等式

k0\*10^0+k1\*10^1+k2\*10^2+k3\*10^3=99 这里我们假设左边就三项把  方便研究

k的系数可正可负，正就是放在右边，负就是放在左边。

那么我们要求∑|k|最小，可以这样想：
我们先考虑最小的质量是1的砝码，我们要确定使用了几个1砝码，那么我们就要把个位的9补平，要么是10-1，需要一个； 要么是0+9，需要9个；

显然减一下好，而且减掉一个刚好。于是我们确定了上述方程的第一项系数k0= -1

那么方程就是这样：-1\*10^0+k1\*10^1+k2\*10^2+k3\*10^3=99

把第一项移到右边：k1\*10^1+k2\*10^2+k3\*10^3=100

我们看到我们成功的把个位填平了，使得方程可以同除以10

那么就变成了k1\*10^0+k2\*10^1+k3\*10^2=10

于是到这里我们看到了问题具有很强的  最优子结构性质。


而无后效性是显然的，我们确定了小法吗的个数后，右边的个位被填平，所以我们不在需要小法吗

于是问题就是一道DP问题。

而这个m是一个高精数，在说我们的n=10是很特殊的，对于其他的n我们 要进行很多的 m div n 和m mod n操作

于是我们整体的预处理一下，

把m进行n进制的分解

不断的把 计算m mod n这个余数，记录，再把m div n，把m除干净为止；

于是我们得到了n进制下的 每一位上的数字，对应于我们每一个数量级的砝码

对于每一位我们有两个策略，直接使用yu【i】这么多的砝码，或者用n-yu【i】这么多的砝码进上去，两种操作都可以使n进制下的个位变成0

于是我们发现他其实是0/1 DP 也就是说我们开一个数组f【0..m,0..1】，前一维意思是处理到n进制下的第i位，后一维意思是我们当前这一位的处理策略 0代表直接拿出yu【i】这么多的砝码，1代表我们把当前位补平，进到下一位去

数组元素存储处理完当前第i位需要的砝码数

于是状态转移方程：

f[i,0]:=min(f[i-1,0]+yu[i],f[i-1,1]+yu[i]+1);

f[i,1]:=min(f[i-1,0]+b-yu[i],f[i-1,1]+b-yu[i]-1);

写状态转移方程的时候仔细一点就不会错：使用f【i-1，1】的时候，我们当前位就+1


AC代码：

```delphi

program exam1;
var ans,k,j,b,d,num:int64;
var i,ii:longint;
var a:array[0..10000]of integer;//高精度原数组
var yu:array[1..100000]of longint;//余数数组，也就是n进制下的位数组
var f:array[0..10000,0..1]of longint;//DP数组
ss:ansistring;

function min(aa,bb:longint):longint;//DP最小值函数
begin
if aa>bb then exit(bb)
else exit(aa);
end;

procedure devide;//高精除法，记录下余数的同时，把商数组在重新赋给a数组，继续做高精除
  {c:=a div b; d:= a mod b}
  var ix,len:integer;
  var c:array[0..10000]of integer;//商数组
  begin
    fillchar(c,sizeof(c),0);
    len:=a[0]; d:=0;
    for ix:=len downto 1 do begin
      d:=d*10+a[ix];
      c[ix]:=d div b;
      d:=d mod b;
    end;//高精除法结束

    while (len>=1) and (c[len]=0) do dec(len);
    c[0]:=len;//位数处理
    fillchar(a,sizeof(a),0);
    for ix:=0 to c[0] do
    a[ix]:=c[ix];//a数组重赋值为c  等价于a:=a div b;

    inc(num);
    yu[num]:=d;//得到余数
  end;

procedure print;//特质判断输出，因为有个巨坑无比的点b=1，只有1这一种砝码。把质量数原样输出就对
var i:longint;
begin
for i:=a[0] downto 1 do
write(a[i]);
end;

begin
readln(ss);
readln(b);
a[0]:=length(ss);
for i:=1 to a[0] do
a[a[0]-i+1]:=ord(ss[i])-48;//高精读入
 
if b=1 then//特判
begin
print;
halt;
end;

repeat//处理成n进制
devide;
until a[0]=0;//直到原数除空了


f[0,0]:=0;f[0,1]:=1;//赋初值，为什么f[0,1]:=1呢 看下面红色的 为了让f[1,0]和f[0,0]的值正常等于yu[1]和n-yu[1]；
for i:=1 to num do//num位n进制位
begin
f[i,0]:=min(f[i-1,0]+yu[i],f[i-1,1]+yu[i]+1);//如果前一位不进到这一位，那么0的DP直接加上yu[i]，如果前一位进上来了，就多+1
f[i,1]:=min(f[i-1,0]+b-yu[i],f[i-1,1]+b-yu[i]-1);//若前一位不进，1的DP加上补足数n-yu[i]，若前一位进上来了，补足数就是n-(yu[i]+1)
end;
writeln(min(f[num,0],f[num,1]+1));//注意输出的时候f[num，0]的意义是最高位是直接给出这么多的砝码；
end.                          而f[num,1]的意义是最高位是补平的，而如果最高位是补平进到下一位这样处理，就额外需要更高位砝码x1

```


至此，我们发现有效代码就这么几行。

我都惊呆了！只有60+行！！

而这面的想法是很多的。

精彩的 高精+数论+DP

最精髓的在于进制转换和 0/1 DP 的部分

好吧，也就这两部分了

