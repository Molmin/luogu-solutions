# 不就是离散化排序板子题目嘛！  
（强烈谴责::AtCoder的界面太乱了）  
然后我就又来mergesort了！  

mergesort，学名归并排序，本次实现方式：二路归并  
具体来说就是分解序列，二路归并实现就二分序列实现。  

然后当两个序列都是有序（满足题目要求）的时候，进行归并操作。  
什么时候最有序？分解到一个元素为止。  
```cpp
    if (l==r)return;
```
然后开一个辅助空间，开三个下标~~指针~~指向左端点，右端点，辅助空间的第一个元素   
```cpp
    student stack[r-l+1+1];
    int p1=l,p2=mid+1,p3=1;
```
重复下面操作直到有一个指针出序列范围：  
将两个序列中最符合要求的元素放进辅助空间，对应指针++
```cpp
    while (p1<=mid&&p2<=r)
    {
        if (student[p1]>student[p2])
            stack[p3++]=student[p1++];
        else
            stack[p3++]=student[p2++];
    }
```
很明显会有某一个序列剩下一大批元素  
因为每个序列都是有序的，所以只需要将剩下的都放进辅助空间即可。
```cpp
    while (p1<=mid)stack[p3++]=student[p1++];
    while (p2>=r)stack[p3++]=student[p2++];
```
然后把辅助空间里的元素复制回原来序列。
```cpp
    p3=1;//返回到第一个元素
    for (int i=l;i<=r;i++,p3++)
        student[i]=stack[p3];
```

------

这个题是想着让我们离散化原先的数据。  
开一个结构体，一个元素放id，一个放身高，  
先按照身高大->小排一次序，然后逐个输出id即可。  
看着没有用归并排序 and 友元函数重载运算符的，so特来写一篇题解。

------

最后放上高清无码的[$\color{pink}\texttt{C++ code}$](https://www.luogu.org/paste/tq182b6j)。  
(防止污染：想观看的同学直接点击粉字传送）