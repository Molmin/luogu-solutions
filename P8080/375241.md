$N$ 只有 $50$，所以直接模拟，贪心。

我们可以寻找那些不能使用杯座的人，再反求出能使用杯座的人，而 $S$ 的两侧各有一个杯座，所以我们只需要考虑 $L$ 是否能使用杯座。

因为样例有点水，所以先自己列举了几个样例进行研究:

- $\texttt{*S\ \ *L\ \ L*\ \ L\ \ L*\ \ S*}$ ：第 $3$ 个 $L$ 不能使用杯座。

- $\texttt{*S\ \ *L\ \ L*\ \ L\ \ L*\ \ L\ \ L*}$：第 $3$，$5$ 个 $L$ 不能使用杯座。

- $\texttt{*L\ \ L*\ \ L\ \ L*\ \ L\ \ L*\ \ L\ \ L*\ \ S*}$：第 $3$，$5$，$7$ 个 $L$ 不能使用杯座。

由此发现，再连续的一些 $L$ 中，第 $n$ 个 $L$ 不能使用杯座满足 $n \not = 1$ 且 $n$ 为奇数。 

还有一种情况，即 $\texttt{*S\ \ *S\ \ *L\ \ L*\ \ S*\ \ L\ \ L*}$ 中第 $3$ 个 $L$ （即第 $2$ 段连续的 $L$ 中第 $1$ 个）不能使用杯座，所以又可以发现当出现 $\texttt{SLL}$ 的情况且在此之前出现过 $L$（如样例 $2$）时，其中第 $1$ 个 $L$ 不能使用杯座。

综上两种情况所述，我们维护两个变量 $x$，$y$，$x$ 用来维护连续的 $L$ 中第奇数个 $L$，$y$ 用来维护情况二中在此之前是否出现过 $L$。

最后，上代码！

```cpp
#include <bits/stdc++.h>
using namespace std;
int n, ans, a, x, y;
string s;
int main() {
    scanf("%d", &n);
    cin >> s;
    for(int i = 0; i < n; i++) {
        ans++;
        if(s[i] != 'L') x = 0;
        else x++, y++;
        if(i > 0 && s[i] == 'L' && s[i - 1] == 'S' && s[i + 1] == 'L' && y != 1) ans--;
        if(x != 1 && x % 2 == 1) ans--;
    }
    printf("%d\n", ans);
    return 0;
}
```

[AC 记录](https://www.luogu.com.cn/record/68271401)，吸氧实测 $32ms$。