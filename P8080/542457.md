$upd\ at\ 2022/1/29\ :$ 改正语言错误。

### 这是一篇 $C++$题解

[题目传送门](https://www.luogu.com.cn/problem/P8080)

首先看到这个题目描述：
>每排座位的相邻两个座位之间都设有一个杯架（除了两个爱心座位之间外）。

对比样例 $3$ 的说明，可以发现题目这里是表述不清。实际上，我们可以认为爱心座位的个数是偶数，将它们两两分组，每组之间设有一个杯座。

那么我们知道，每一个杯座一定要尽量地被利用。

我们就分 $2$ 种情况。

1. 这一排有爱心座位。这时，杯架的数量（设为 $m$ ）一定满足 $m\le n$ 。大家可以画图理解一下。我们以一对爱心座位为分界线，左边的杯架都匹配给右边的人，右边的杯架反之，如下图。让每一个杯架都匹配给旁边的人，这种情况输出 $m$ 。
![](https://cdn.luogu.com.cn/upload/image_hosting/ooi10761.png)
2. 这一排只有普通座位。这时，每一个人都有杯座。输出 $N$ 。

接着上代码（**对照理解，不要抄袭**）：

```cpp
#include<bits\stdc++.h>
using namespace std;
int main(){
	ios::sync_with_stdio(false);//给cin和cout加速 
	string s;
	bool flag=0;//有没有爱心座位L 
	int n,sum=1;//刚开始最左边有一个杯座
	//sum记录的是杯座的数量，后面是从左到右记录，每一个座位对应了右边相应的杯座（或右边没有杯座） 
	cin>>n>>s;
	for(int i=0;i<n;i++){//判断是否有爱心座位的同时统计杯座数量 
		if(s[i]=='S'/*注意是单引号*/){
			sum++;//一个普通座位右边配一个杯座 
		}else{
			flag=1;//有爱心座位 
			sum++,i++;//爱心座位是两个两个出现，出现第一个，将i+1跳过第二个，右边有一个杯座，sum+1 
		} 
	}
	if(flag){//有爱心座位
		cout<<sum;//情况1 
	}else{//没有爱心座位 
		cout<<η;//情况2 
	} 
	return 0;
}//不要抄袭不要抄袭不要抄袭听我的不要抄题解这个只是用于对照理解的
```

这一道题实际还是很简单的，时间 $O(n)$ ，空间 $O(n)$ ，而且数据范围极小。也希望管理可以通过这篇题解。