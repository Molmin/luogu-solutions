**博弈论题首先找规律**

首先$0$个石子的状态一定是必败态，因为对面在上一轮已经拿完了。

观察$1$~$5$个石子，发现$1=p^0,2=2^1,3=3^1,4=2^2,5=5^1$，都是必胜态，可以一次拿完赢得游戏。

然后$6$个石子没办法一下拿完（因为$6\neq p^k$）。可以知道只能拿$1$~$5$个石子，这样都会转移到前面的必胜态，只不过这个必胜态已经是对面的了，**所以说$6$个石子是你的必败态，在你面前出现$6$个石子又轮到你拿的时候，你必定失败。**

这样一直往后找到$12$的时候，发现$7$~$11$都是必胜态（一次把石子总数拿到$6$个石子然后对面就输了），而$12$是必败态（可以枚举$1$~$12$中的所有$p^k$，都转移到对面的必胜态）。

于是猜想**所有$6n$的状态是必败态，其余所有状态$(6n+1,6n+2 \ldots 6n+5)$都是必胜态。**

我们采用数学归纳法证明：

当$n=0$时，结论成立，因为$0$~$5$上面已经说明过了。

现在假设$0$~$6n-1$都满足结论。

先证明$6n$为必败态：因为任何$p^k$，都不是$6$的倍数，所以$6n$个石子拿完一次**不会还是$6$的倍数**，故必定转移到对面的必胜态，所以$6n$是必败态。

显然$6n+r(r=1,2 \ldots 5)$只需要拿掉$r$便可以转移到$6n$，是对面的必败态，所以$6n+r(r=1,2 \ldots 5)$是必胜态。

证毕。

代码，只需要判一下输入是否是$6n$即可：

``` cpp
#include<bits/stdc++.h>
using namespace std;

int main(){
    int T,x;
    for(scanf("%d",&T);T;T--){
        scanf("%d",&x);
        puts(x%6==0?"Roy wins!":"October wins!");
    }
    return 0;
}
```