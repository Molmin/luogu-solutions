
```cpp
    #include<bits/stdc++.h>
    using namespace std;
    inline int read(){
        int lin=0;
        char x=getchar();
        while(x<'0' || x>'9') x=getchar();
        while(x>='0' && x<='9'){
            lin=(lin<<1)+(lin<<3)+x-'0';
            x=getchar();
        }
        return lin;
    }
    int t,x;
    int main(){
        t=read();
        while(t--){
            x=read();
            if (x%6==0) printf("Roy wins!\n");
            else printf("October wins!\n");
        }
        return 0;
    }
```
\*题目：
游戏规则是这样的：共有n个石子，两人每次都只能取p^k个（p为质数，k为自然数，且p^k小于等于当前剩余石子数），谁取走最后一个石子，谁就赢了。

现在October先取，问她有没有必胜策略。

若她有必胜策略，输出一行"October wins!"；否则输出一行"Roy wins!"。\*


证明：

数学归纳法。

首先看题目，易知——1、2、3、4、5这五个数，当我方轮到时，都是处于我方的必胜态——直接取数让对方无法取即可。

然，我方遇到6时，6分解质因数形式，为2\*3，不可直接取数得到。

那么，无论取1-5这五个能取的任意一个，对方所获得的数，必然呈必胜态。

那么遇到6，为我方必败态。

继而推广。

设n<=6k时，其中只有6的倍数，是必败态。

那么，当n<=6\*k+6时。

只需要证明6\*k+1-5这五个数，都是我方的必胜态，显然，我方只需要取对应的1-5这五个数，留给对方的数则6\*k

由假设，知6\*k为必败态，对方必败，我方必胜。

得证。

继而。

当我方获6\*k+6时，证之必败，那么即证明，我们能够取一个数，让对方处于必败态，而由假设，让对方处于必败态的数，必然是6的倍数，即，我方要取6的倍数。

易知。

6的倍数不可被直接取得。

故，得证。

而后，直接推广，数学归纳法成立。

总结论——6\*k为必败态，我方取得6\*k，即6的倍数时，必败，否之，必胜。
