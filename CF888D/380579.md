观察题目数据：$n\leqslant 1000,1\leqslant k\leqslant 4$。发现 $k$ 的范围奇小无比。

对于每一组 $n,k$，我们先不要思考总共答案是多少，即我们先把题目中“至少”两字去掉后再考虑。

我们首先考虑 $k=1$ 的时候，也就是说除了一个数不一样，其他都必须一样，那很显然是不存在的，只存在所有都一样的情况，换句话说 $k=1$ 时 $ans=1$。

考虑 $k=2$，在保证有两个绝对不同的时候，其他必须相同。那很显然这两个必须是一个交换的状态，也只有一种可能，那我就可以选出这两个数，有多少种选出的方案就有多少去掉“至少”的答案。即 

$$
ans=C_{n}^{n-k}
$$

在加上“至少”两字后，我们只需要把所有 $k<2$ 的情况加入即可：

$$
ans=C_n^{n-k}+1=C_n^k+1
$$

考虑 $k=3$，对于剩下的三个不同，我们应该怎么选？这是可以枚举得到的，两种分别是 $(2,3,1)$ 和 $(3,1,2)$，那就是说我只需要选出这三个数，再把他们有多少种排列的方式乘上即可，最后加入 $k<3$ 的情况：

$$
ans=C_{n}^{n-k}\times 2+C_n^{k-1}+1=C_n^k\times 2+C_n^{k-1}+1
$$

考虑 $k=4$，对于剩下的四个不同，我们也可以枚举，先固定第一位（有 $3$ 种情况），固定第二位也有 $3$ 种情况，而剩下两位就自然固定了，也就是说选出 $4$ 个数相同的情况下，这 $4$ 个数有 $9$ 种排列方式，所以答案就是：

$$
ans=C_n^k\times 9+C_n^{k-1}\times 2+C_n^{k-2}+1
$$

至此所有的情况都枚举完了，考虑组合数咋求（为了方便我们把所有 $C_n^{n-k}$ 都替换成了 $C_n^k$），这题没有取模，又由于 $n\leqslant 1000$，所以我们可以暴力求，但是要开 `long long`，时间复杂度 $\mathcal{O}(k)$（差不多等于没有）。

代码如下：

```cpp
//CF888D
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,k;
int C(int n,int k){
    int ans=1;
    for(register int i=n;i>=n-k+1;i--) ans=ans*i;
    for(register int j=1;j<=k;j++) ans=ans/j;
    return ans;
}
signed main(){
    scanf("%lld %lld",&n,&k);
    if(k==1) printf("1");
    if(k==2) printf("%lld",C(n,2)+1);
    if(k==3) printf("%lld",C(n,3)*2+C(n,2)+1);
    if(k==4) printf("%lld",C(n,4)*9+C(n,3)*2+C(n,2)+1);
}
```