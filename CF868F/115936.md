洛谷的 RemoteJudge 炸了？

~~前阵子好像问过 wxw 类似的题。~~

朴素的做法是设 $f_{i,j}$ 表示分好了前 $i$ 个子段，第 $i$ 个子段以位置 $j$ 结尾的最优方案。

那么有 $f_{i,j}\leftarrow f_{i-1,k}+cost_{k+1,j}$。复杂度 $O(n^2k)$。

考虑优化。这个 $cost_{k+1,j}$ 很烦所以看看它有啥性质。我们考虑从左往右枚举 $j$，并考虑 $j$ 右移的过程中 $cost_{k+1,j}$ 的增量。容易发现这个增量是不增的。通俗来讲就是对于 $k<l$，$cost_{k+1,j}$ 增加的量一定不比 $cost_{l+1,j}$ 增加得少。那么就会发现每个位置的决策点是单调的。

对于决策单调性的问题，我们可以用分治的方式去解决。

感觉有点像整体二分，我们假设当前在 $solve(l,r,ql,qr)$ 表示 $f_{i,[l,r]}$ 的决策点在区间 $[ql,qr]$。

我们取中点 $mid=\frac{l+r}{2}$，枚举 $[ql,qr]$ 的每个决策点，暴力地算出 $mid$ 的最终决策点在 $qmid$。然后递归到 $solve(l,mid-1,ql,qmid)$ 和 $solve(mid+1,r,qmid,qr)$。

这样分治会有 $\log n$ 层，每次分治的时候决策点区间会分成两个相交 1 个位置的区间。所以这部分复杂度是 $O(n\log n)$。

瓶颈在于查询 $cost_{l,r}$。事实上我们可以类似莫队一样暴力地维护两个端点，然后暴力地去移动。

考虑这个做法的复杂度。我们发现从 $solve(l,r,ql,qr)$ 递归到 $solve(l,mid-1,ql,qmid)$ 的时候，两个端点刚好是 $mid$ 和 $qmid$。那么意味着每一层暴力移动的次数实际上是 $qr-ql$ 级别的。所以整体的移动次数依然是 $O(n\log n)$。

外面跑 $k$ 次，复杂度为 $O(nk\log n)$。

https://codeforces.com/contest/868/submission/192508661