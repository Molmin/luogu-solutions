首先，我们分析一下题目，总结一下就是：告诉你变换规律，给你一个只包含‘E’、’S’、’W’、’N’的字符串，模拟输出在t步之后的坐标位置。

至于其他，根本没用！

我一看，这不就是道模拟水题吗？怎么还有普及-的难度，根本就可以是入门的好吧？然后兴致勃勃，兴高采烈，开开心心地敲了个纯模拟……相信结果呢，大家都知道了……这道题，它竟然还暗藏玄机！！！

滑到题目底部，你会发现一个美丽新世界：

对于60%的数据：T <= 500,000且命令串长度 <= 5,000

对于100%的数据：T <= **2,000,000,000**且命令串长度<= 5,000

这……20亿？！可以的，就冲这范围，我给你个普及-的难度。

于是我们只能换一种思维。由题意可得，这个移动是有规律的，而且是个循环，这样就可以轻而易举地做出来了。

#### 下面是代码，看看注释应该更清楚。

```
#include<bits/stdc++.h>
using namespace std;
int main()
{
	int nx=0,ny=0,t,le=0,ls=0,lw=0,ln=0;
	//nx,ny是记录当前坐标。 
	//t是题目所给，表示走的步数。 
	//le表示一次循环中，“E”的个数，之后有用。
	//ls表示一次循环中，“S”的个数，之后有用。
	//lw表示一次循环中，“W”的个数，之后有用。
	//ln表示一次循环中，“N”的个数，之后有用。这四个都是计数器，注意清零。 
	string s;  //题目所给字符串。 
	cin>>s>>t;
	int l=s.size(),len=floor(t*1.0/l);  
	//len记录了这段字符串循环了多少次，floor是向下取整，注意里面要乘个1.0，因为floor只能对实型操作。 
	for (int i=0;i<l;++i)
		switch(s[i])
		{
			case 'E':le++;break;
			case 'S':ls++;break;
			case 'W':lw++;break;
			case 'N':ln++;break;
		}
	//记录一次循环中，四种字符的个数。 
	int tx=le-lw,ty=ln-ls;
	nx+=len*tx,ny+=len*ty;
	//这两步很重要！！！它算出了经过len轮之后的坐标，这样省去了模拟的时间，这题大概就要完成了。 
	for (int i=0;i<t-len*l;++i)
		switch(s[i])
		{
			case 'E':nx+=1;break;
			case 'S':ny-=1;break;
			case 'W':nx-=1;break;
			case 'N':ny+=1;break;
		}
	//这个循环处理了len轮之后剩下步数的问题，按题意移动。 
	cout<<nx<<" "<<ny<<endl; 
	return 0;
}
```

可能我的代码看起来比较繁琐，但是咱要记住一件事儿：

#### 只要能AC的代码，都是好代码！

你们也可以理解为是我在为自己辩护（好吧，实际上还真是，逃）