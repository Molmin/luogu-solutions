看了一下大家的做法，我感觉都比较复杂，本蒟蒻来发一篇通俗易懂的题解。

大致做法：动态规划

# 思路

设 $dp_i$ 表示前 $i$ 个数的最大可能和。

设 $sum_i$ 表示前 $i$ 个数所有奇数位置的和。

### 当 $i$ 为偶数时：

将这个序列划分成 $\frac{i}{2}$ 段，每段 $2$ 个数。由于要选 $\frac{i}{2}$ 个数，且这些数不相邻，则需要每一段都选出 $1$ 个数。（建议手动画图）

考虑第 $i$ 个数选与不选：
* 若选了第 $i$ 个数，则第 $i-1$ 个数就必须不选，答案为 $dp_{i-2}+a_i$。
* 若不选第 $i$ 个数，则在 $a_i$ 这一段中，则必须选第 $i-1$ 个数，选了第 $i-1$ 个数，就只能选第 $i-3$ 个数....所以答案为 $sum_{i-1}$。




### 当 $i$ 为奇数时：

需要在前 $i$ 个数中选出 $\frac{i-1}{2}$ 个数。

* 若选了第 $i$ 个数，同上。
* 若不选第 $i$ 个数，需要在前 $i-1$ 个数中选取 $\frac{i-1}{2}$ 个数，即 $dp_{i-1}$ 

综上所述，$dp_i=\max(dp_{i-2}+a_i,dp_{i-1})$.
# 代码
```c++
#include<bits/stdc++.h>
using namespace std;
#define int long long //不开long long会死
int n;
int a[200005],sum[200005];
int dp[200005];
signed main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
		sum[i]=sum[i-1];
		if(i%2==1) sum[i]+=a[i];
	} 
	dp[1]=0;//初始化 
	for(int i=2;i<=n;i++){
		if(i%2==0){
			dp[i]=max(a[i]+dp[i-2],sum[i-1]);
		}
		if(i%2==1){
			dp[i]=max(a[i]+dp[i-2],dp[i-1]);
		}
	}
	cout<<dp[n]<<endl;
}
```
