## 前言

**这是一道很板的** $\operatorname{DP}$ **。**

&nbsp;
## 状态转移方程
我的思路虽然不是最简单的，三维 $\operatorname{DP}$ （可优化为二维），但比较好理解。

1. **我先想到的思路**  
   记录 $f[i][j]$ 为前 $i$ 个数中取 $j$ 个的最大值。但题目要求不能选相同的两个数，所以还需要增加一维，记录该位置有没有被选。  
   空间复杂度 $\mathcal O(n \times n \times 2) = \mathcal O(2n^2)$，显然不行。

2. **考虑压缩**   
	对于第二维，例如当 $i=7$ 时，$j$ 显然不能取到 $0,1,2,5......$等值。  
   归纳总结：对于 $i$ , 第二维 $j$ 只能取 $(i-1)/2$ 或 $(i+1)/2$。则第二维可以压缩为 $[0/1]$，对应着 $(i-1)/2, (i+1)/2$ 。  
   空间复杂度 $\mathcal O(5n)$，（加上 $a$ 数组的）。
   
3. **状态转移方程**  
	直观地看，我们可以分奇偶考虑。  
   为了使 $\operatorname{DP}$ 具象化，我们  
   对于 $i \nmid 2$：   
   $$dp[i][0][0] = max(dp[i-1][1][0],dp[i-1][1][1])$$
   $$dp[i][0][1]=dp[i-1][0][0] + a[i]$$
   $$dp[i][1][1]=dp[i-1][1][0]+a[i]$$
   简单思考可得: $dp[i][1][0]$ 不存在。
  	
   对于 $i \mid 2$：  
   $$dp[i][0][0]=max(dp[i-1][0][0],dp[i-1][0][1])$$
   $$dp[i][1][0]=dp[i][1][1]$$
   $$dp[i][1][1]=dp[i][0][0]+a[i]$$
   同理，$dp[i][0][1]$ 不存在。
   
&nbsp;

## 代码

```cpp
#include <stdio.h>
#include <algorithm>
using namespace std;
int N, a[200005];
long long dp[200005][2][2];
int main()
{
    scanf("%d", &N);
    for (int i = 1; i <= N; ++i)
        scanf("%d", &a[i]);
    dp[1][1][1] = a[1];
    for (int i = 2; i <= N; ++i)
        if (i % 2)
        {
            dp[i][0][0] = max(dp[i - 1][1][0], dp[i - 1][1][1]);
            dp[i][0][1] = dp[i - 1][0][0] + a[i];
            dp[i][1][1] = dp[i - 1][1][0] + a[i];
        }
        else
        {
            dp[i][0][0] = max(dp[i - 1][0][0], dp[i - 1][0][1]);
            dp[i][1][0] = dp[i - 1][1][1];
            dp[i][1][1] = dp[i - 1][0][0] + a[i];
        }
    if (N % 2) printf("%lld\n", max(dp[N][0][0], dp[N][0][1]));
    else printf("%lld\n", max(dp[N][1][0], dp[N][1][1]));
    return 0;
}
```

要开 ```long long``` 存放 ```dp``` 数组，但~~数据好像过水~~了。

   
&nbsp;

## 优化

主要比较简单的优化有两种：

1. 奇偶合并  

	即在循环时不判断奇偶，直接通过位运算做。

2. $dp$ 数组合并

	上文中有提到，对于 $i$ 时奇数 / 偶数，$dp$ 数组其实都只用三种情况，所以可以做如下合并：  
   $$dp[i][0][0] \Rightarrow dp[i][0]$$
   $$dp[i][0][1] / dp[i][1][0] \Rightarrow dp[i][1]$$
   $$dp[i][1][1] \Rightarrow dp[i][2]$$
   ($dp[i][0][1]$ 和 $dp[i][1][0]$ 可以用 $i$ $\&$ $1$ 来区分）
   
[代码](https://www.luogu.com.cn/paste/y4pzti8x) 比较难懂，但短了近一半，时间和空间也更优秀。

至此，一道~~偏水的~~蓝题就只用了绿题的思维难度和代码难度解决了！
  
    