#### 题解Rank1好像连续两个P就会被hack……

~~我不会说我因为离线处理完后没有重新排序询问WA了1h~~

~~我也不会说我在对拍调试的时候hack了3篇题解~~

恩看大家这个题都清一色的树状数组……可是我用的线段树

~~但是因为我不会写树状数组~~

~~而且可能我常数小我的线段树跑的并不是很慢~~

进入正题

一步一步分析

# step1

对于给定的字符串，如何建立trie树呢？

这个很简单，和普通AC自动机的插入单词操作差不多

如果当前要处理的是一个小写字母，就往当前节点的儿子走

如果当前是P，意味着从根到当前节点组成了一个单词，记录下这个单词的位置

如果当前是B，那么就往当前节点的父亲走。(毕竟末尾的一个字母删掉了)

# step2

建立好trie树顺带把trie树补成trie图且连好fail后，我们考虑暴力

如何判断单词x是否是y的子串呢？

根据AC自动机和fail的定义，我们很容易知道两个结论：

1.trie树上一个节点的祖先节点所代表的单词，肯定是当前所代表的单词的前缀

2.一个节点的fail指针指向的肯定是当前节点所代表的单词的最长后缀

而且子串可以理解为前缀的后缀。

暴力的话就从根到y遍历所有点，对于每个点，我们往上暴跳fail，如果遇到x单词的结尾就ans+1



------------

当然这样分肯定不多就是了……

考虑逆向思维，我们建立一颗fail树。(不知道是啥的先去百度)

那么我们原本是要考虑所有属于y单词的节点有哪些能够暴跳fail指针到x单词结尾 

现在就变成了考虑fail树中y单词的节点有哪些在x的子树中了。

还是不是很好搞对么……？那就离线

询问按照y进行排序，然后按照建立trie树的过程重新遍历一遍trie树

这样我们经历单词的顺序肯定是第一个，第二个……第sum个单词

每往下走一步，我们就给到的节点的权值加一

每往上跳一步，我们就给离开的节点的权值减一

当我们跳到第i个单词的时候，就处理询问里y=i的所有情况

就是查询一下fail树中x的子树权值和

这个DFS序+线段树就很好搞了 

代码不贴了有点长(其实是想安利一下博客)

[Blog](http://www.cnblogs.com/refun/p/8697626.html)
