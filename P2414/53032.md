首先根据ac自动机的性质，y在x中的每次出现，就是有一个y的字符的fail指针指向x的结束节点。
    
所以我们的问题变成了统计多少个y中的fail指针指向x。

由此得到启发，我们可以建一颗fail树，树上的每条边就是原trie树上的一个节点指向它的fail节点。

所以我们只要统计在fail树中，关于每个x的节点，y节点在它的子树中出现了几次。

我们之所以能这样统计，是因为在fail树中，关于每个子树的根节点x，它必然是它子树中的每个节点所代表的字符串的后缀。

关于这种树上子树统计问题，我们显然可以用树状数组来维护它的dfs序来进行计数。

但我们发现，因为很多个串可能出现重复，所以对每个询问重复插入并进行统计会造成大量的时间浪费。

这时候我们可以用一个巧妙的优化：我们在统计中，按照最初的trie图进行遍历，假如当前节点是一个子串的结尾，那么当前已经插入的字符肯定是且只能是该子串中的字符，这样我们就可以实现对fail树的o（n）遍历了。