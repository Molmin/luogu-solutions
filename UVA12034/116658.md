## **这是一道可以用DP做的题**

**我们可以把问题分解，由于存在名次并列，我们并不知道占用了多少个名次，这为我们解题带来了麻烦，因此可以把问题按照占用名次的数目分解。如4名同学的排名问题，我们分别讨论占用1个名次、2个名次、3个名次和4个名次的情况，进而联想到用动态规划来求解，~~并且复杂度十分优秀~~**

设DP[i][j]代表前i个人（包含第i个人）中最后一个名次为j的方案数

那么这个状态一定由前i-1个人的状态转移过来，于是我们考虑
前i-1个人的情况

1.前i-1个人就已经有了j个名次

2.前i-1个人还只有j-1个名次，需加入第i个人才会有第j个名次

对于第一种情况，第i个人的可以随意放在前j个名次的任意一个，所以
**DP[i][j]+=(DP[i-1][j]\*j)**


对于第二种情况，第i个人的可以随意放在前j-1个名次中任意两个之间(也就是j-2种放法)，还可以放在一首一尾,所以**DP[i][j]+=(DP[i-1][j-1]\*(j-2+1+1))**



所以**DP[i][j]=DP[i-1][j-1]\*j+DP[i-1][j]\*j**

离线更快，只用跑一次

献上代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,dp[1010][1010],a[1010],MAX;
int mod=10056;
int main(){
    cin>>n;
    for(int i=1;i<=n;i++){
		cin>>a[i];
		MAX=max(MAX,a[i]);
	}
	
	dp[0][0]=1;
	
	for(int i=1;i<=MAX;i++){
		for(int j=1;j<=MAX;j++){
		//	if(i==1&&j==1) dp[i][j]=dp[i-1][j-1]+dp[i-1][j]*j;
			dp[i][j]=dp[i-1][j-1]*j+dp[i-1][j]*j;
			dp[i][j]%=mod;
		}
	}
	
	for(int i=1;i<=n;i++){
		int sum=0;
		for(int j=1;j<=a[i];j++){
			sum+=dp[a[i]][j];
			sum%=mod;
		}
	cout<<"Case "<<i<<":"<<" "<<sum<<endl;
	}
} 

```
