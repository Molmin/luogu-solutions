楼上哪位dalao一眼看穿递推方程，貌似对于 ~~像我这样的~~ 蒟蒻不太友好啊，那我就结合我 ~~超级碰巧~~ 的解题经历发一篇题解吧。

这个题一眼一看，规律还真不好找。那么现在我们分析一波。设 f[i] 表示当有 i 个人的时候有多少种排名，f[1] 与 f[2] 的值是显而易见的(f[1]=1；f[2]=3)。然后我们枚举有3个人参加排名时所有可能的情况如下（**不同名次之间有“||”分割**）：

①123
②12||3
③13||2
④23||1
⑤1||23
⑥2||13
⑦3||12
⑧1||2||3
⑨1||3||2
⑩2||1||3
⑪2||3||1
⑫3||1||2
⑬3||2||1

乍一看好像看不出什么，那么接下来我们把它们分个组（为了压缩空间就只写标号了，建议大家自备草稿纸）：

(1)⑤⑧⑨

(2)⑥⑩⑪

(3)⑦⑫⑬

(4)②③④

(5)①

还看不出来？再分一下！

1.(1)(2)(3)

2.(4)

3.(5)

哦，发现了。当有 i 个人参加排序时，我们把每种情况分为两部分，第一部分为考到第一名的那群人，其余的都是第二部分的。这时我们~~惊讶地~~看出，**当第一部分的人数为 j 时，第二部分的排名情况总数一定是 f[i-j] 。**不妨设**此时第一部分所有可能出现的组合为 g[i][j]**；
那么很容易得到 
**f[i]=∑g[i][j]·f[i-j] (j是变量，范围1~i)**。 
有了这样一个神奇的关系，我们就可以~~开心地~~递推啦！

接下来我们考虑 g 数组怎么求。刚开始我用了递归，结果瞬间T到飞起。后来我把 g 数组打印出来找找规律，发现······这~~TM~~不是杨辉三角吗？ 为什么是杨辉三角呢？我到现在还不会证明
~~（所以说碰巧嘛）~~。

走过以上的心路历程，答案基本就出来了。带个4进去算，结果正确。开心！
\\(^▽^)/

再然后，欣喜若狂地AC啦！  

code：
```cpp
#include<bits/stdc++.h>
using namespace std;
long long yh[2000][2000];//杨辉三角 
long long m,n;//m为数据组数，n为每组的数据 
long long f[2000];
long long top=4;//记录已经找到的位置 
const int mod=10056;
int main()
{
    for(int i=0;i<2000;i++)//预处理杨辉三角 
	{
		yh[i][0]=1;
		yh[i][i]=1;
	}
	for(int i=2;i<2000;i++)
    {
		for(int j=1;j<i;j++) 
        	yh[i][j]=(yh[i-1][j]%mod+yh[i-1][j-1]%mod)%mod;
            //杨辉三角也要取模，或者你想写高精度也可以 
    }
	f[0]=1;
	f[1]=1;
	f[2]=3;
	f[3]=13;
	f[4]=75;//多打几组表 
	cin>>m;
	for(int c=1;c<=m;c++)
	{
		cin>>n;
		cout<<"Case "<<c<<": ";
		if(f[n])//在线处理，可以确保每个点只跑一次。如果这个点被跑过，直接输出就好 
		{
			cout<<f[n]<<endl;
			continue;
		}
		for(int i=top+1;i<=n;i++)//注意从top+1开始递推，已经求出的结果是神圣不可侵犯的 
		{
			for(int j=1;j<=i;j++) 
			    f[i]=(f[i]%mod+(yh[i][j]%mod)*(f[i-j]%mod))%mod;//疯狂取模 
		    f[i]%=mod;
		}
		cout<<f[n]<<endl;
		top=n;//更新top 
	}
	return 0;
}
```
其实代码还存在可以优化的地方，但那都是小菜，无关紧要。

另外，
## 代码千万条，诚实第一条。
## 题解抄习惯，封号两行泪！