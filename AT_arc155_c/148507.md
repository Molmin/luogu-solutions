### 前言

比赛时死活调不出来，赛后 2 分钟就 AC 了，成功错失一次蓝名的好机会。

## Problem

给你两个数列，可以进行如下操作：

选取连续 3 个数，如果它们的和是偶数，那么可以随便排列。

问第一个能否变成第二个。

## Solution

最简单的，如果组成两个数列的数不全一样，直接寄。这个开个桶或者排序一遍都可以。考虑剩下来的情况。

一个直观的想法是，按奇偶分类。可以发现，能够操作当且仅当：

- 三个偶数

- 一个偶数两个奇数


可以发现，在一堆连续偶数中，只要超过 2 个，就可以随便排列。

首先，如果所有的奇数都动不了，那么除非这些奇数本来 $A$ 和 $B$ 就对应相同，否则肯定寄。

举个例子：

```
9 8 2 4 3 4 6 3
9 2 4 8 3 6 4 3
```

当 $A$ 和 $B$ 的奇数对应相同时，所有偶数被分成了若干块，只能在块内移动。所以，开个桶比较每个块内是否对应相同即可。

在上面的例子中，`4 6` 不能变成 `6 4`，所以寄了，由此：

**特判**：如果一个块内只有两个偶数，那它们不能移动。

现在，只要有一个奇数能动，那就可以把两个奇数并在相邻的两项。

举例：

```
1 1 [4 5 1] 4
1 1 [1 5 4] 4
```

记 `0` 为偶数，`1` 为奇数，那么 `1 0 1 -> 1 1 0`，所以可以并在一起。

并在一起后，还可以平移：`1 1 0 <-> 0 1 1`；

它们还能交换顺序：`1 3 2 <-> 3 1 2`；

对于一长串的 `1`，可以整体平移：

```
111110
111011
101111
011111
```

感性理解可知，每次可以选一长串的奇数，不断把别的奇数并进来，直到形成一大串，然后移到最左端。

此时，所有偶数都在最右端。

根据前面提到的，奇数之间可以借助偶数交换相邻两个，所以不断地操作可以把奇数进行排序。

**注意特判只有两个偶数的情况**：如果偶数的个数超过 3 个，那么可以用操作随便乱动。否则，偶数的**相对位置**就被定死了。

最后，所有操作都是可逆的，那么如果 $B$ 也能类似操作成一堆奇数在最左边，就可行。

如果 $B$ 不能呢？那肯定寄了。因为 $A$ 能操作到的都是能够进行操作的数组。

我的处理方法是：把 $A$ 和 $B$ 交换，再看看行不行。

具体看代码。

## Code

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
const int N=200005;
int n;
int a[N],b[N],c[N],d[N];
bool check()// 如果奇数可以移动，检查偶数
{
	int t1=0,t2=0;
	for(int i=1;i<=n;i++)
	{
		if(!(a[i]&1)) c[++t1]=a[i];
		if(!(b[i]&1)) d[++t2]=b[i];
	}
	if(t1==2&&c[1]!=d[1])// 只有两个偶数
	{
		return 0;
	}
	return 1;
}
bool solve()
{
	for(int i=1;i<=n-2;i++)
	{
		int t=(a[i]&1)+(a[i+1]&1)+(a[i+2]&1);
		if(t==2)
			return check();
	}
	int lst=0;
	for(int i=1;i<=n;i++)
	{
		c[i]=a[i];
		d[i]=b[i];
	}
	for(int i=1;i<=n;i++)
	{
		if((c[i]&1)&&(c[i]!=d[i]))//奇数不对应相同，且不能移动，一定不行
			return 0;
		if(c[i]&1)
		{
			sort(c+lst,c+i);
			sort(d+lst,d+i);
			for(int j=lst;j<=i-1;j++)//这一块内偶数的构成不同
				if(c[j]!=d[j])
					return 0;
			if((i-1)-lst==2&&a[i-1]!=b[i-1])//检查2个偶数的问题
				return 0;
			lst=i;
		}
	}
	sort(c+lst,c+n+1);
	sort(d+lst,d+n+1);
	if(n-lst==2&&c[n]!=d[n])//检查2个偶数的问题
	{
		return 0;
	}
	return 1;
}
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&a[i]);
		c[i]=a[i];
	}
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&b[i]);
		d[i]=b[i];
	}
	sort(c+1,c+n+1);
	sort(d+1,d+n+1);
	for(int i=1;i<=n;i++)
	{
		if(c[i]!=d[i])
		{
			printf("No");
			return 0;
		}
	}
	bool ok=0;
	for(int i=1;i<=n;i++)
	{
		if(a[i]&1)
		{
			ok=1;
			break;
		}
	}
	if(!ok)
	{
		printf("Yes");
		return 0;
	}
	bool t1=solve();
	if(!t1)
	{
		printf("No");
		return 0;
	}
	for(int i=1;i<=n;i++) swap(a[i],b[i]);
	bool t2=solve();
	if(!t2)
	{
		printf("No");
		return 0;
	}
	printf("Yes");
	return 0;
}

```