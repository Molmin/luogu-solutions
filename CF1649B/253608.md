## 题目分析
很显然，**你为了让球的个数尽可能的少，一定会想让一个球在人们的手中传递的次数尽可能的多**。

然后我们就会发现一个巨大的问题：**当其他人的传球次数都用完的时候，很可能传球次数最多的人还有许多次球要传。**

比如对于这一组样例：

$3$

$1 \ 5 \ 2$

我们发现不管怎么样第二个人都会多出一次传球次数。所以我们迫不得已只能再增加一个球。此时最少就要用两个球。

所以我们可以总结出一个贪心思路：**其他人要尽可能地每次都把球传给传球次数最多的人。如果无法使用一个球，那么迫不得已必须要增加球的个数。**

更具体的，我们结合上面这组样例进行分析：

为了让二号球员剩余的传球次数尽可能少，所以我们选择**从他开始传球，并且传到球的每个人都立即把球回传给二号，让二号尽可能多传**，那么最优的传球序列就是：

第一个球：$2→1→2→3→2→3→2→3$ 或 $2→1→2→3→2→3→2→1$

第二个球：$2→1$ 或 $2→3$
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
int t,n;
ll a[100005];
int main(){
    cin>>t;
    while (t--){
        cin>>n;
        ll s=0;
        for (int i=1;i<=n;i++) {
            cin>>a[i];
            s+=a[i];//记录所有人传球次数的总和
        }
        sort(a+1,a+n+1);//其实并不用排序，直接记录最大值就可以了
        if (s==0){
            cout<<0<<'\n';//特判没有人传球的情况
        }else{
            s-=a[n];// a[n] 就是最多的传球次数，把它减掉就是其他人加起来的传球次数
            cout<<max(1ll, a[n]-s)<<'\n';// a[n]-s 表示传球最多的人还要传这么多次，如果它小于等于1，就表示一个球足够了，不然就要用 a[n]-s 个球
        }
    }
    return 0;
}
```
