水二分答案，随便分类讨论一下就行了。

共有三种情况：
- 一路往左（负轴）
- 一路往右（正轴）
- 从左到右（负->正）

那么，为什么不会从正轴到负轴呢？

既然你能到正轴，终点也一定在正轴，如果你这次跑去负轴，下次去终点又要回来，显然浪费时间。

详见注释：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,x[50005],t;//坐标 
bool check(int m)//m为二分出来的左起点
{
	for(int i=m;i<=n;i++)//循环右终点坐标 
	{
		int l=i-m+1;//起点坐标 
		if(x[l]>0)//一路向右，如果连起点都在右边，那么终点也一定在
		{
			if(x[i]<=t){//终点用时在t以内 
				return true;
			}
		} 
		if(x[i]<0)//一路向右，如果连终点都在左边，那么起点也一定在
		{
			if(x[i]>=-t){//终点用时在t以内（将t化为负数，可按照绝对值理解）			
				return true;
			}
		} 
		if(x[l]<0&&x[i]>0){//兜了个圈子拐个弯，即这段区间横跨了原点 
			if(min(x[i],-x[l])+x[i]-x[l]<=t)//先去距离短的相邻点,但是无论如何起点和终点间距离必须要走 
				return true;
		}
	} 
	return false;////如果整个循环执行完无解就继续二分 
} 
int main(){
	cin>>t>>n;
	for(int i=1;i<=n;i++)
	    cin>>x[i];
	sort(x+1,x+1+n);//排序,防止毒瘤乱码 
	int l=-1,r=n+1;//由于能访问的路标数量可能为0~n，所以以理论范围扩大1为实际范围，即把左边界设为-1，右边界设为n+1，这样就可以保证二分到所有解
	while(l+1<r){//之所以不写l<r是为了留空格 
		int mid=(l+r)/2;
		if(check(mid))
			l=mid;
		else 
			r=mid;
        //更新l,r的值时写mid而不是mid+1或mid-1，也是为了防止最后l>r
	}
	cout<<l<<"\n";//最后输出l
	return 0;
}
```
