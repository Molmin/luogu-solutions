赛时：只走 $x$，走 $n$ 步，这个东西都需要用多项式快速幂，这题肯定不可做。

赛后：走 $n+1$ 步就对了？？？

比较高妙的双射题。

考虑先把路径放到一个序列上，每次走我们都先走 $x$，再走 $y$，因此考虑设 $B_i$ 表示第 $i$ 步 $y$ 前我 $x$ 走了 $B_i$ 步，这样可以得到一个长度为 $n$ 的序列 $B$，然后发现此时需要钦定 $A_0=1$，需要满足以下条件：

- $A_{B_i}=1$。

- $\sum_{i=1}^n B_i=n$。

- $\sum_{j=1}^i B_j\ge i$。

回忆卡特兰数，相当于没有第一条限制，一般的方法是找到第一个位置然后翻转，但是这题显然不能这样，因为对 $x$ 有限制，而对 $y$ 无限制，翻转会破坏这个。

考虑卡特兰数另一个通项：$\frac{\binom{2n}{n}}{n+1}$，尝试从这里去找性质。

对于任意一个不满足第三个条件的序列 $c$，容易发现我们可以找到一个前缀和最小的地方，把它转到最前面，这样一定合法，但是这样的位置可能会有多个。

原来是 $n$ 个 $+1$，$n$ 个 $-1$，那么考虑变成 $n+1$ 个 $+1$，然后要求除了第一个位置以外的位置都 $\ge 1$，那么开头唯一。

也就是说对于任意一个 $(n+1,n)$ 的序列，对应唯一一个合法序列，并且一个合法序列可以通过循环移位得到所有任意序列。

这样可以得到通项 $\frac{\binom{2n+1}{n}}{2n+1}$，但是这并不是我们想要的。

因为我们限制了一个 $-1$ 前面 $+1$ 的个数，因此考虑把一个 $-1$ 和它前面的 $+1$ 变成整体，然后第一个加入的 $+1$ 单独看成一个整体，对这个整体进行循环移位，可以发现依然满足上面的双射。

此时任意序列的个数相当于就是长度为 $n+1$，和为 $n$ 的序列个数，插板法之后就可以得到最终的通项：$\frac{\binom{2n}{n}}{n+1}$。

回到原题，相当于任意序列的每一个长度受到限制，但是可以直接算，就是相当于$f^{n+1}$，直接多项式快速幂即可，复杂度 $O(n\log n)$。

代码很好写。

```cpp
int main() {
  ios::sync_with_stdio(0);
  int n;
  cin >> n;
  poly f(n + 1);
  f[0] = 1;
  for (int i = 1; i <= n; i++) cin >> f[i];
  f = Ln(f, n + 1);
  for (int i = 0; i <= n; i++) f[i] *= n + 1;
  f = Exp(f, n + 1);
  cout << f[n] / (n + 1) << '\n';
}

```