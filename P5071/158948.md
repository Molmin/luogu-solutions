Pollard-Rho 简单练习题，写了板子用这道题检验一下就比较舒服。

首先是众所周知的约数个数的计算方式，令 $c(x)$ 为 $x$ 的约数个数：

若 $x=\prod_ip_i^{c_i}$，则 $c(x)=\prod_i(c_i+1)$。

那么直接从质因数下手，这玩意就一脸的根号分治，手算一下界，把 $1000$ 以内的 $168$ 个质数取出来做前缀和，剩下的每个数最多提供两个质因子。

考虑这至多 $2n$ 个质因数的贡献，看起来又是一脸的根号分治？

发现约数个数的公式很适合 $O(1)$ 增减，用莫队可以减少很多的难度。（笔者感觉直接对这玩意上根号分治也是很可行的，但抵不上我太懒了

于是先上 Pollard-Rho 分解质因数，然后根号分治小的暴力，大的直接拉莫队跑一跑就完了。

------------

以下是复杂度和卡常：

根号分治小的部分是用数组暴力做前缀和，复杂度为 $O(168(n+Q))$，跑的不慢。

根号分治大的部分先有个 Pollard-Rho，期望复杂度 $O(n10^{\frac 94})$，众所周知 Pr 复杂度和常数都挺玄学的。

然后是莫队，我们手写一个 Hash 表，复杂度 $O(n\sqrt Q)$。

好像有个逆元的处理细节应该没人不会吧（，反正我直接跑了 $10^6$ 以内的逆元完全不是瓶颈。

然后是卡常，首先一部分一部分的挂上去发现果然是 Pr 的常数最大，于是只用指着 Pr 卡就能卡过去：

- 把 `LL` 换成 `int`，把龟速乘/`__int128` 直接换成 `LL` 以内的乘法。
- Miller-Rabin 那里直接用 3 次的确定性判素数，因为 $2^{32}$ 以内，或者你随 3 次（不保证能过）
- 最好有手写随机数的习惯，`rand` 之类的不靠谱。

然后再给其他部分提提速，发现根号分治的大小完全不影响后面 Pr 和莫队的速度（

于是把根号分治的界跳到 $500\sim 700$ 甚至可以变快，莫队部分都手写 Hash_table 了也没啥卡头。

然后就可以过了，这些细节注意一下，其他（指 Pr，不得不说我就慢在这里还不会卡）实现差点也能过，~~就算你的 Pr 写的和我的一样差都能在 2~2.4s 内把最卡的点跑过去~~。

[几乎没卡常的代码](https://www.luogu.com.cn/paste/yfkbhgw8)