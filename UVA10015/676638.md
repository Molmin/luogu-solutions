## 题目大意

约瑟夫问题，但是在第 $i$ 次出队将走第 $i$ 个质数步。求最后的赢家。

------------
## 思路

先考虑一下最朴素的约瑟夫问题的公式怎么推的。

我们假设目前有 $n$ 个人，走 $k$ 步，那么我们把他们先从 $0$ 到 $n-1$ 编号，对于出队的人，后面的人重新从 $0$ 开始编号。这就相当于把整个序列向后推了 $k$ 位，所以旧编号里面标号为 $x$ 的人就应该是现在的 $(x-k)\bmod n$ 位。所以，新编号的 $x$ 就是旧编号里的 $(x+k)\bmod n$ 位。

我们考虑从后向前推。最后一次出队后只剩一个人，那么这个人的新编号必然是 $0$；然后我们就知道了他的旧编号，旧编号的旧编号……一直到他原来的编号，于是我们就知道哪个人最后仍然在列了。

我们回到这个问题，设第 $i$ 个质数是 $p_i$，那么到第 $i$ 步就有 $n-i+1$ 个人。所以我们先把答案设为 $0$，然后从 $i=n-1$ 倒推即可。另外，为了防止模运算中出现 $0$，所以我们从 $0$ 开始标号，那么最后的答案应该加 $1$。代码如下：

```cpp
void getp(int n){
	isp[1]=true;
	for(int i=2;i<=n;i++){
		if(!isp[i]) p[++hop]=i;
		for(int j=1;j<=hop&&i*p[j]<=n;j++){
			isp[i*p[j]]=true;
			if(i%p[j]==0) break;
		}
	}
}//原题里面数据小，什么筛法都行
signed main(){
	getp(40003);
	int n=read();
	while(n){
		int ansid=0;
		for(int i=n-1;i>=1;i--) ansid=(ansid+p[i])%(n-i+1);//倒推
		printf("%lld\n",ansid+1);
		n=read();
	}
	return 0;
}
```