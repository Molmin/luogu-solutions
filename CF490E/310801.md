### 题意概述
给你n个带有“？”的数，让你将“？”填上，问如何构造能使这个序列**严格递增**。

### 分析：
很明显这是一道贪心题，每一次尽量取可以取的最小值就好。

思路是：每次循环确定一个数的值，然后再用下一个字符串和这个数进行比较，如果能构造出来，就返回这个数，否则返回$-1$，即输出“$NO$”。

暂且将待确定数字的值记为$b$，已确定数字的值记为$a$。我们可以分为$3$种情况来讨论。

#### $Type$ $1$：$a$的长度大于$b$的长度
很明显$b$无论如何构造，都无法大于$a$，直接返回$-1$

`if(lenb<lena)	return -1;`

#### $Type$ $2$：$a$的长度小于$b$的长度
此时无论怎样构造，$b$都会大于$a$。所以我们将除了第一位以外的“$？$”都改成$0$，以保证$b$最小。（特别注意：**第一位不能是$0$！**）

```
if(lenb>lena)//这里的a和b已经都转为字符串格式。
{
	int intb=0;
	for(int i=0;i<lenb;i++)
	{
		if(b[i]=='?')
		{
			if(i==0)	b[i]='1';
			else b[i]='0';
		}
		intb=intb*10+b[i]-48;
	}
	return intb;
}
```

现在我们的a和b的长度都**相等**了，但是真正的难点才刚刚开始

#### $Type$ $3$：$a$的长度等于$b$的长度
再看做法之前，请你先自己想一想。我这个做法可能不是唯一的。但是我觉得很妙。

---

首先定义一个变量$flag$，初始值为1。然后从前往后扫一遍$b$数组，遇到“？”跳过

- 当遇到$b_i>a_i$时，$flag$设为$2$，$break$;

- 当遇到$b_i<a_i$时，$flag$设为$0$，$break$;

这样，我们又分成了三种情况。

#### $Type$ $3.1$：

**即$a$的长度等于$b$的长度，且b不是问号的部分大于a对应的部分。（$flag$==$2$）**

首先看一组数据：

$a=566423$

$b=5??5?3$

根据小学知识，我们知道比较长度相等的两个数时，高位上的数字越大，这个数就越大。

而要让$b$尽量小，且大于$a$，可以将$b_i$第一次大于$a_i$的数标记上，往左的“？”都设为$a_i$，往右的“？”都设为0。以保证$b>a$且$b$最小

这样我们将第一次大于$a_i$的数标记上：

$b=5??5?3$

$...........↑..$
(就是第四位的“$5$”）

往高位，“$？$”都设为$a_i$

$a=566423$

$b=5665?3$

然后往低位，“$？$”都设为$0$。

$a=566493$

$b=566503$

大家可以自行推理一下这个算法的正确性。

#### $Type$ $3.2$：

**即$a$的长度等于$b$的长度，且b不是问号的部分等于a对应的部分。（$flag$==$1$）**

再看这组数据：

$a=566493$

$b=5??4?3$

由于要让$b$尽量小，我们从后往前扫$b$，扫到$b_i$为“$？$”，**且**$a_i$**不为**$9$的时候，将$b_i$设置为$a_i+1$（如果$b_i$为“$？$”，$a_i$为$9$时，直接将$b_i$设为$0$），然后继续往前扫，扫到$b_i$为“$？$”时，将$b_i$设置为$a_i$。**特别地，如果从后往前扫，每个“$？$”对应的$a_i$都是$9$或者压根没有“$？$”的时候，返回$-1$**

$a=566493$

$b=5??4?3$

$...........↑..$（第四位的$4$标记上）

从后往前扫：

$a=566493$

$b=5??403$（跳过$9$）

$............↑.$

第一位标记上：

$a=566493$

$b=5?7403$（将第三位设为$a_i+1$）

$.........↑....$

往前的设为$a_i$：

$a=566493$

$b=567403$

$.......↑.......$

则$567403$即为所求。

证明思路不再赘述。

#### $Type$ $3.3$：

**$a$的长度等于$b$的长度，且b不是问号的部分等于a对应的部分。（$flag$==$0$）**

此部分和代码交由你们自己完成吧！

---

~~友情提供主程序代码~~：

```cpp
int main()
{
	int n,answer[100009];//存储答案
	scanf("%d",&n);
	int last=0;
	for(int i=1;i<=n;i++)
	{
		string s;
		cin>>s;
		last=possible(last,s);
		if(last==-1)	{cout<<"NO";return 0;}
		answer[i]=last;
	}
	cout<<"YES";
	for(int i=1;i<=n;i++)
	{
		printf("\n%d",answer[i]);
	}
	return 0;
}
```