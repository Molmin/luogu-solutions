/*本文根据陈启峰论文结合个人理解所作*/

【解析】

使用”约束 放宽”条件的算法。

首先不难看到一个很显眼的条件$ k \leq 5$,提示我们去拆分这个绝对值。

为了方便，以下均令$ k = 5$. 

将所有常数乘进去后，本来对于动物i,j，友好程度是这样的：

$|a_{i,1} - a_{j,1}| + |a_{i,2} - a_{j,2}| + |a_{i,3} - a_{j,3}| + |a_{i,4} - a_{j,4}| - |a_{i,5} - a_{j,5}|$

去掉绝对值以后，可以看成是图中的10个数（两组数）各带五个符号。

于是可以看成是对于每个$i$,给他的五个数取一组正负号SIGN（总共32种），在计算的时候和另一个符号全部取反的$i'$来进行求和。这一步显然可以用二进制位相关的操作瞎搞。

但由于绝对值的限制，我们需要满足$\forall  1 <= l <= k, a_{i,l} - a_{j,l} >=0.$

这个苛刻的限制似乎可以用$2^k$棵线段树来维护，但我太弱，并没有进行过尝试...

**到这里，就是“约束 放宽”条件法起作用的时候了。不过个人认为，这只是一种帮助你想到此题题眼的思想，请不要对这个名称过于纠结**

注意到答案就是我们要维护的这个$ a_{i,l} - a_{j,l}$所构成的。 而在题目中，在$l \neq k$的时候，这个值都是越大越好，只有$l = k$的时候是越小越好。

所以就是基于这一点，引发我们思考：能不能把条件放宽成只要$a_{i,k} - a_{j,k}\geq 0$ 就可以了呢？

**这一步理解可能很困难。 我先打个不恰当比方： 考一次试，想方设法取得好成绩，却又有一些规矩来限制着我们， 而其中有的规矩不是硬性规定（比如做题速度要怎么样，要花多少时间检查等等一些来自自己、前辈的经验），遵守他们本身就是为了让你做得更高效；有的规矩则可能是硬性的（比如不能作弊），不遵守比遵守就做这件事来说可能会导致你低效但你必须这么做。 在这个时候，我们要选出最会考试的学生，只需要在不能作弊的基础上关注成绩即可，因为那些成绩不理想的人往往更可能没有这些经验、在做题速度、检查时间这些方面把握的更不好。对于这个题，也是这个道理。**

瞎扯了这么多，我们来看看来自原文的科学证明（有改动）：

下面我们用$F_{i,BN}$来表示符号取BN的时候第i种动物的值。

【定理】对于任意的$a,b \in R,BN$，都有$|a - b| >= a - b$  &&$ |a - b| >= b - a$

【推论】对于任意的$a,b \in [1,n], BN \in [0, 2^k - 1]$ ,满足原性质的可以表示成
$(\sum_{i=1}^{K-1} |A_{a,i} - A_{b,i}|) - |A_{a,k} - A_{b,k}| $ 
满足新性质的可以表示成

$(\sum_{i=1}^{K-1} ±(A_{a,i} - A_{b,i}) - |A_{a,k} - A_{b,k}| $ 。那么显然满足原性质的那些数>= 满足新性质的那些数。

所以设满足两个性质的结果集分别为$S1，S2$，其中最大值为$MAX1，MAX2$，那么一定有$MAX1 >= MAX2$.

但是注意！ 因为显然原性质严格比新性质苛刻（即原性质包含新性质）

所以有$S1 \subset S2$.

所以显然$MAX1 <= MAX2$

综上， $MAX1 = MAX2$.

所以，我们就成功的实现了“放宽”。

**个人认为，原论文中所讲到的“约制”与“放宽”中，“放宽”这一操作相对来说更加新颖，而“约制”则可以认为是从一些无章的事物中规约出性质，没听说过这个算法也会这么做。**

接下来的做法就建议自己想一想在看下去了：

首先枚举符号；
因为只要让$a_{i,k} - a_{j,k}\geq 0$满足，我们不妨让a数组先按照k从小到大排一个序使得每一个后面元素的k都大于前面元素的k，然后维护一个最小值；每遍历一个，先用他的值减去当前的最小值和答案比大小，再用它更新一下最小值即可。

所以总复杂度是$O(n2^k)$的。

代码：

```
#include <bits/stdc++.h>
#define ll long long
using namespace std;
const int INF = 0x3f3f3f3f;
const int maxn = 100010;
inline int read()
{
    int x = 0, f = 1;
    char ch = 0;
    while (!isdigit(ch)) {ch = getchar(); if (ch == '-') f = -1;}
    while (isdigit(ch)) x = x * 10 + ch - 48, ch = getchar();
    return x * f;
}
int c[maxn], n, k, ans;
struct node
{
    int a[6],id;
}a[maxn];
bool cmp(node a,node b) {return a.a[k] < b.a[k];};
inline int calculate(int sign, int x)
{
    int ans = 0;
    for(int i = 0; i < k - 1; i++) ans += (sign & (1 << i)) ?a[x].a[i + 1] :  - a[x].a[i + 1];
    ans -= a[x].a[k]; return ans;
}
int main()
{
    n = read(); k = read();
    for(int i = 1; i <= k; i++) c[i] = read();
    for(int i = 1; i <= n; i++)
        for(int j = 1; j <= k; j++)
        a[i].a[j] = read(), a[i].a[j] *= c[j];
    for (int i = 1; i <= n; ++i) a[i].id = i;
    sort(a + 1, a + n + 1, cmp);
    int ans1,ans2;
    for(int i = 0; i < (1 << k - 1); i++)
    {
        int minn = INF;int minid;
        for(int j = 1; j <= n; j++)
        {
            int now = calculate(i, j);
            ans = max(now - minn, ans); if (ans == now - minn) ans1 = a[j].id,ans2 = minid;
            minn = min(now, minn);if (minn == now) minid = a[j].id;
        }
    }
    printf("%d %d\n",min(ans1,ans2),max(ans1,ans2));
    printf("%d\n",ans);
    return 0;
}
```
