# Best Matched Pair 题解

## 前言

[题目传送门](https://www.luogu.com.cn/problem/AT_icpc2016autumn_a)

[可能更好的阅读体验](https://www.luogu.com.cn/blog/xiaoyang111/solution-at-icpc2016autumn-a)

## 正篇开始

### 思路

题意已经非常简洁了，不再简化并阐述题意。

我们把这个问题分成几部分来做。

1. 输入各种数据。

2. 枚举每一种乘积。

3. 判断这个乘积是否合法，也就是判断这个乘积从高到低的对应每位数字是否依次递增且连续。

4. 如果这个数合法，取最大值。

5. 输出最大值，记得换行。

上面过程用代码实现非常简单，最后把所有实现的代码拼凑起来就对了。

### 代码

我是边输入边操作的，时间复杂度会降低一点。

代码见下，可能风格有些难看，请见谅：

```cpp
#include <iostream>//头文件
#include <vector>//头文件
using namespace std;
bool func(int a){//判断这个数是否合法
	//我这个函数里面是倒着推的
	int up=a%10;//赋值为最后一个数
	a/=10;//把最后一位数去掉
	while (a){//如果没有数可以取了就退出
		if (up!=(a%10)+1){//如果不符合条件
			return false;//返回错误
		}
		up=a%10;//把up赋值为最后一位数
		a/=10;//把最后一位数去掉
	}
	return true;//都符合条件返回正确
}
int main(){
	int n;//定义整数n
	cin >> n;//输入n
	vector<int> a(n);//定义容器a
	int mx=-1;//初始把最大值赋值为-1
	for (int i=0;i<n;++i){//输入
		cin >> a[i];//输入
		for (int j=0;j<i;++j){//枚举乘积
			int t=a[i]*a[j];//算出乘积
			if (func(t)){//如果是个合法的数
				mx=max(mx,t);//取最大值
			}
		}
	}
	cout<<mx<<endl;//输出
	return 0;
}
```

### 解释

问：为什么不用长整型放数字和乘积？

答：数据中 $a_i$ 较小，即使两个 $10^4$ 的数乘起来不会爆普通整型变量。

问：为什么可以用枚举？

答：数据中 $n$ 较小，我的代码时间复杂度较为低，不会超时。

问：为什么最大值开始要赋值为负数？

答：两个正整数相乘不可能变成负数，取最大值的时候就不可能取到负数，到最后输出的时候也不用判断是否有没有合法的乘积。

