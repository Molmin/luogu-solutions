此题解适用于还不晓得什么是二次离线莫队的朋友，dalao 可选择性阅读（就是很废话那种）。

这题还是很良（du）心（liu），也就不到 100 行，但细节丰富（根本扛不住）。
# 二次离线莫队
首先看题，题目要求的是异或值在二进制下有 $k$ 个 1 的数对个数，先不管什么是二次离线莫队，我们用普通莫队的思路思考。

考虑插入一个数，在插入时要看当前区间里的所有数（关键是这题还不好搞 Bit，Segment_Tree 等数据结构），只好硬着头皮上，直接一个 $O(n^2\sqrt n)$ 带走，这就要用到二次离线莫队了。

首先这题考虑插入一个数对区间的贡献，即 $i\in[l,r-1]$ 中有多少数异或 $a_r$ 后的值符合要求，首先直接暴力找肯定是不行的，这里似乎也不好用什么数据结构，于是我就注意到了 $a_i\in [0,16383]$。这能说明什么？可以直接（暴力）统计呀！！（注：这里不是把 $[0,16383]$ 的数全部统计完。）为了方便统计，这里先引进一个东西：异或运算的交换律（和加法交换律不一样）：$a⊕b=c$，即 $a⊕c=b$。

有了这个，我们能方便些什么呢？我们可以先预处理出在区间 $[0,16383]$ 里有哪些数在二进制下有 $k$ 个 1（下面统一称为 $b$）。然后把 $i,j\in[l,r],a_i⊕a_j=b$，转化成：$i,j\in[l,r],a_i⊕b=a_j$ 这样就直接统计有多少个 $a_i$ 就行了，虽然 $n\sqrt n$ 个查询 ok 了，但还有 $n\sqrt n$ 个插入，在搞个常系数（最坏为 $C^7_{14}$）上去，T 飞...

这里再引进一个新技术：差分，将 $a_r$ 对 $a_i,i\in[l,r-1]$ 的贡献差分为 $a_r$ 对 $a_i,i\in[1,r-1]$ 的贡献减去 $a_r$ 对 $a_i,i\in[1,l-1]$ 的贡献，这里注意不能乱差分，因为这题的贡献是“1 对 1”（就是把贡献的区间割一下不影响答案之和），所以可以差分。这样就可以预处理前缀了，但是我们还是逃不掉 $a_r$ 对 $a_i,i\in[1,l-1]$ 的贡献······意思是在更新答案时还是不能做到 $O(1)$ 的复杂度。

补充一下，这里其实还要预处理后缀，因为在移动左端点时要用到。这里好像还体现不出差分的优势（耐心一点嘛 qwq）。

这就要一个黑科技：二次离线莫队。

首先我们将查询的移动过程离线下来，存在一个容器里，注意在存储过程中要配合好我们预处理的前（后）缀，要辨识出要用的是前缀还是后缀，要减去的区间是哪段，这里用前缀还是后缀可以开两个容器，减去的区间就用数组下标就行了。

按这样发展，那岂不是要开 $O(n^2)$ 的二维数组？但是思考一下，我们这样做会浪费很多空间，所以只好开 ```vector```，但这还是不行，会卡 cache（$O(n\sqrt n)$ 的空间复杂度），那为何不存移动的区间呢？这样既可以不被卡 cache 也可以完美的存下二次离线莫队需要的东西。

接下来就是二次离线莫队最精髓的部分了——处理离线下来的查询。这里我们就是要直面差分后无法逃脱的那个东西：$a_r$ 对 $a_i,i\in[1,l-1]$ 的贡献，这里就是要正确处理 $a_i,i\in[1,l-1]$，前面会 T 飞的原因其实就是这一段数据会被重复计算好多好多遍，所以我们离线下来就是为了避免重复计算，具体方法就是从 1 到 $n$ 走一遍，遇到要用的 $a_i,i\in[1,l-1]$ 就拿出来用，然后配合前缀一波带走（后缀也是一样的）。

这样的时间复杂度就是 $O(n\sqrt n)$ 加上那个常系数（就是 $C^7_{14}$ 那个）乘上 $O(n)$。所以说这是个“黑科技”。

在开头提出的细节丰富，这里提几点：
- 对询问排序。
- 初始化统计数组。
- 最后要还原答案所在的数组（因为在处理时时处理的局部）。
- 记得给合适的元素开 ```long long```，不然你猜是 TLE 还是 MLE。

最后给出处理那一步的参考代码。
```cpp
for(int i=1;i<=n;i++){//i:要割去的区间为[1,i) 
    for(int j=0;j<QZ[i].size();j++){//对于这个i要处理的所有询问 
        for(int k=QZ[i][j].l;k<=QZ[i][j].r;k++){//[QZ[i][j].l,QZ[i][j].r]:需要前缀且的移动区间 
            ans[QZ[i][j].id]+=QZ[i][j].op*(qz[k]-t[a[k]]);//QZ[i][j].id:对应的询问的下标 
        }                                                 //QZ[i][j].op:这个贡献是正的还是负的 
    }                                                     //qz[k]:[k,k]对[1,k)的贡献(即前缀),t[a[k]]:对于a[k],在[1,i)中有多少数与它异或后符合要求 
    for(int j=1;j<=top;++j) t[(a[i]^cnt[j])]++; //cnt[1~top]在[0,16384)中符合要求的数 
}
```