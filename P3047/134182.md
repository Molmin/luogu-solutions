# 路过的靓仔看过来！
走过路过，千万不要蒟蒻！

这道题狠友男赌，尻（考）的不仅仅是码力，毒题能力，更是叔上问题功底的检测，无论各位现在是在普及组还是提高组，都十分值得来刷一下这道经典题目。

（~~抄袭了一下我上一篇题解的开头~~）

------------
不扯其他的了，直切主题

题目就是求每个结点在k步内能到达当前结点的奶牛数目。


因为不仅可以向上搜，还能向下搜，只说步数为k，没说只能往树下面搜，不能往上搜，所以要做两次大法师（滑稽


------------
## 第一次dfs

Dp[u][j]表示从下往上，走j步能到达u点的奶牛数。

很明显这不是正确答案，我们来手动构一张图。

![](https://cdn.luogu.com.cn/upload/pic/73544.png)

在这张其丑无比的图中，我们
看3号结点，它dp[3][j]记录了从
上往下k步到达3的点，但是它忽略了1到达它
情况，于是第二遍大法师就是要处理上方的结点。


------------
## 熔池，融吃，容斥！！！
解决这个问题的办法就是↑ ↑ ↑ ↑

第二遍dfs我们要用父亲状态更新儿子。

方程显而易见：
f[i的儿子][j]+=∑​f[i][j−1]

## 这个方程对吗

------------
## 我信你个鬼！！！！（滑稽
这方程鬼都看得出有许多重复！

在k>2的时候肯定会有重复！

那么重复了什么呢？还是用这张奇丑无比的图

![](https://cdn.luogu.com.cn/upload/pic/73545.png)

K=3

我在图上标的数字表示

Dp[1][3~0]（这是第一次dfs时的dp数组

好，我们来看2号结点。

假如我们要求最终的dp[2][3]
如果用上面的公式的话，

![](https://cdn.luogu.com.cn/upload/pic/73547.png)

我们就要加上这些结点，

然而，4号结点离2号结点的距离明明是1啊，但他
离1的距离的确是2。所以，我们要减去像4号结点一样的结点，那么这些结点有什么特点呢？很明显，它离2距离为1，也就是3-2


------------
所以公式就是

所以公式就是：

f[i的儿子][j]+=∑​f[i][j−1]

f[i的儿子][j]-=∑​f[i][j-2]


------------
那么很明显，第一次dfs是从叶子节点更新根结点，而第二次是父亲更新儿子，所以第一次操作要在搜索后做，第二次要在搜索前。
```cpp
void dfs1(int u,int fa)
{
	for(int i=head[u];i;i=e[i].next){
		int v=e[i].to;
		if(v==fa)continue;
		dfs1(v,u);
		for(int j=1;j<=k;++j)
		dp[u][j]+=dp[v][j-1];
	}
}
void dfs2(int u,int fa)
{
	for(int i=head[u];i;i=e[i].next){
		int v=e[i].to;
		if(v==fa)continue;
		for(int j=k;j>=2;--j)
			dp[v][j]-=dp[v][j-2];
		for(int j=1;j<=k;++j)
			dp[v][j]+=dp[u][j-1];
		dfs2(v,u);
	}

```

##### 最后把dp[i][1~k]累加起来即可其实这题还是有些难度的，主要是容斥原理的应用！

# QWQ
