## 思路

看到是由火柴棍拼接便可以想到不同数字对应不同权值，由此可以试图使用完全背包。

显然我们的策略是先找出数位最多的（因为这样肯定最大），再反向找出这些数字并由大到小输出。

具体实现方式就是一次完全背包加上一次贪心。

## Part 1

完全背包，价值为数字所带来的数位个数（当然是 1），权值是使用的火柴棒数量，直接上模板。

```cpp
for(int i=1;i<=m;i++)
    for(int j=w[a[i]];j<=n;j++)
        dp[j]=max(dp[j],dp[j-w[a[i]]]+1);
```

## Part 2

贪心，先由大到小将可用数字排序，不断在这些数字中按序寻找可用数字（即不断寻找可用最大数字），不断输出，直到火柴棍用完。

```cpp
sort(a+1,a+1+m,cmp);
while (1)
    for (int i=1;i<=m;i++)
        if (w[a[i]]<=n && dp[n-w[a[i]]]==dp[n]-1){
            putchar(a[i]+'0');
            n-=w[a[i]];
            if (!n) return 0;
            break;
        }
```

以上便是核心代码内容，是对 Dark_Sky 大佬的解释补充（因为我自己有些没看懂想了比较久），希望可以帮到各位大佬。