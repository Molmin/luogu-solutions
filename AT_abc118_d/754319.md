### 题目大意：
给你有 $ n $ 根火柴棒和 $ m $ 种数字,并且告诉你数字 $ 1 $，$ 2 $，$ 3 $，$ 4 $，$ 5 $，$ 6 $，$ 7 $，$ 8 $，$ 9 $ 分别需要 $ 2 $，$ 5 $，$ 5 $，$ 4 $，$ 5 $，$ 6 $，$ 3 $，$ 7 $，$ 6 $ 根火柴。

求 $ n $ 根火柴全部都用完且后能拼成的最大数字。
### 解题思路：
- 运用动态规划。
- 将每个数字所需要的火柴棒存入一个数组中。
- 将较小的数值进行更新。
- 从小到大进行排序。
- 查找 $ n $ 次，及查找每一位上尽可能大的数值。
- 判断如果当前的数字是其中的最大值，输出当前的数字。
- 否则，直接查寻下一个值。

### 代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,m;
int a[10],dp[10005];
int c[10]={0,2,5,5,4,5,6,3,7,6};//直接将每个数字所需要的火柴棒存入c数组中 
int main(){
	scanf("%lld%lld",&n,&m);
	for(int i=0;i<m;i++) 
		scanf("%d",&a[i]);//导入a[i]的值 
	dp[0]=1;//dp初始化 
	for(int i=0;i<m;i++)
		for(int j=c[a[i]];j<=n;j++)
			dp[j]=max(dp[j],dp[j-c[a[i]]]+1);//将较小的数值进行更新，用i根火柴棍能够得到的最大数 
	sort(a,a+m);//从小到大进行排序 
	m--;
	while(n){//查找n次，及查找每一位上尽可能大的数值 
		if(n-c[a[m]]>=0 && dp[n]==dp[n-c[a[m]]]+1)
			n-=c[a[m]],printf("%d",a[m]);//如果当前的数字是其中的最大值，输出当前的数字 
		else
			m--;// 如果当前的数字不是其中的最大值，查找下一个值 
	}
	return 0;//好习惯 
}

```
诚信做题，严禁抄袭。