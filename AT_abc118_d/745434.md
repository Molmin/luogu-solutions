[题面](https://www.luogu.com.cn/problem/AT_abc118_d)

# 题目描述

有 $n$ 根火柴 $m$ 种数字，数字 $1,2,3,4,5,6,7,8,9$ 分别需要 $2,5,5,4,5,6,3,7,6$ 根火柴，要求 $n$ 根火柴全部都用完且拼成的数字最大，输出这个数字。

# 输入格式

第一行两个整数 $n, m$；

第二行 $m$ 个整数，分别为 $a_1, a_2, \cdots, a_m$（即 $m$ 种数字是哪几个）。

# 输出格式

一行一个整数，表示能拼成的最大数字。

---

# 题解

做这个题的思路其他题解都讲得很完整了，从完全背包角度进行解决的解法（代码）也基本一样。但是在本人阅读题解时，遇到的问题就是不知道为什么有这样一句 `f[0] = 1`，所以这里主要讲解一下代码中 `f[0] = 1` 的意义。

这里以样例一进行讲解：

样例一

```
20 4
3 7 8 4
```

第一步

进行完全背包时，$f$ 数组的更新状况如下：

![](https://s1.ax1x.com/2023/06/25/pCNRmp6.png)

第二步

反推方案：

$i = 1,a[i] = 8,w[i] = 7,f[20 - 7] = f[12] \ne f[20] - 1$；

$i = 2,a[i] = 7,w[i] = 3,f[20 - 3] = f[17] = f[20] - 1$；

输出 $7$；

$f[17 - 3] = f[14] = f[17] - 1$；

输出 $7$；

$f[14 - 3] = f[11] = f[14] - 1$；

输出 $7$；

$f[11 - 3] = f[8] = f[11] - 1$；

输出 $7$；

$f[8 - 3] = f[5] = f[8] - 1$；

输出 $7$；

$f[5 - 3] = f[2] \ne f[5] - 1$；

$i = 3,a[i] = 4,w[i] = 4,f[5 - 4] = f[1] \ne f[5] - 1$；

$i = 4,a[i] = 3,w[i] = 5,f[5 - 5] = f[0] = f[5] - 1$；

输出 $3$；

综合上面两个步骤，我们可以看出：

将 $f[0]$ 设为 $1$，之后，$f$ 数组中所有由 $f[0]$ 转移得到的数据都加上了 $1$，这样做的目的是，在第二步反推时，倒数几步（即若 $f[0] = 0$，则 $f[0]$ 与 $f[1]$，$f[2]$ 都为 $0$），不会出现“一个状态由多个情况转移而来”的情况（因为根据本题题意可知，本题要求 dp 转移时具有唯一性），故将 $f[0]$ 特殊处理。

同理，我们可知，对于 $f$ 数组的处理也可采用 “先全部赋值为 $-1$，再将 $f[0]$ 赋值为 $0$” 等方法。

最后附上代码：

```cpp
#include <bits/stdc++.h>

using namespace std;

const int N = 1e4 + 10;

int n, m;
int number[10] = {6, 2, 5, 5, 4, 5, 6, 3, 7, 6};
int f[N], a[15], w[15];

int main() {
	cin >> n >> m;
	for (int i = 1; i <= m; i ++ ) {
		cin >> a[i];
		w[i] = number[a[i]];
	}

	f[0] = 1;
	for (int i = 1; i <= m; i ++ )
		for (int j = w[i]; j <= n; j ++ )
			f[j] = max(f[j], f[j - w[i]] + 1);
	sort(a + 1, a + m + 1, greater<int>());//降序
	for (int i = 1; i <= m; i ++ )
		w[i] = number[a[i]];

	while (n) {
		for (int i = 1; i <= m; i ++ )
			if (w[i] <= n && f[n - w[i]] == f[n] - 1) {
				n -= w[i];
				cout << a[i];
				break;
			}
	}
	cout << endl;
	return 0;
}
```