原式就是要求$\sum_{i=1}^n\frac{x^i}{i}$，一看思路简单明确，其实这道题还是有点价值的。

主要思路和楼下一样，但是还是可以优化的。

首先，当n不是很大的时候，直接算，不会超时的。然后当n递增时，因为$x\in\left(0,1\right)$，答案增长会变缓，但是可能积少成多，当加了100个，1000个甚至更多时，答案可能悄然增加了1e-4，怎么办呢？注意，这个数列是收敛的！收敛的值（后称极限）时可以求得！所以发现答案增长减缓时，与极限在保留4位小数的值相等时，立马跳出循环！

**问题是，这个极限怎么求呢？**

学过高等数学的人都知道，有如下泰勒展开公式：


$\ln(1-x)=x+\frac{x^2}{2}+\frac{x^3}{3}+\frac{x^4}{4}+\cdots\left(-1\le x<1\right)$


所以，可以利用math库的log函数把这个极限求出来，然后与当前计算的答案比较，就可以了。

利用这个方法，可以卡到9ms！

代码很简单，就18行！

```cpp
#include <bits/stdc++.h>
using namespace std;

int n, i;
double x, lim, s, ans;

int main(){
    scanf("%lf%d", &x, &n);
    lim = -log(1.0 - x);
    s = 1.0;
    ans = 0.0;
    for(i = 1; i <= n; i++){
        s *= x;
        ans += s / i;
        if(round(ans * 10000.0) >= round(lim * 10000.0)) break;
    }
    printf("%.4lf\n", ans);
}
```