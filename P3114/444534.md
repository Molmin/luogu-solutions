## 题意
给定一些水平单位线段的初始位置和向右移动的速度，求有一条线段可能成为朝 y 轴正方向的射线遇到的第一条线段。
## 思路
线段的数量比较多，模拟线段的移动比较低效，应当对线段与射线之间的关系进行分析。

通过线段的初始点和右移速度，可以求出射线穿过线段的时间段，任意时刻，射线穿过的线段中 y 坐标最小的就是射线第一个遇到的线段。

考虑到时间段的连续性，我们可以用扫描线的方式来维护当前与射线相交的线段。将每个时间段分成入点和出点，然后对所有的时间点排序，按顺序处理。如果遇到了入点，就将对应的线段加入，否则将对应的线段删除，此外，还要能够求出 y 坐标最小的线段，可以用 STL 中的 `map` 进行维护。

值得注意的是，不能对时刻进行处理，因为一条线段可能在两个相邻时刻都被其他线段挡住了，但是在这两个时刻之间是射线遇到的第一个线段。所以我们应当将时刻对应到时段，然后对时段进行处理。
## CODE
```cpp
#include <bits/stdc++.h>
using namespace std;
const int kMaxN = 5e4 + 1;
struct E {                                                // 事件
  int i, t, y, o;                                         // 编号、时段编号、y坐标、类型
  bool operator<(const E &_e) const { return t < _e.t; }  // 按照时段排序
} e[kMaxN * 2];
map<int, int> m;
bool b[kMaxN];
int n, r, ans;
int main() {
  cin >> n;
  for (int i = 1; i <= n; i++) {
    cin >> e[i].t >> e[i].y >> r;
    e[i + n] = {i, -(e[i].t + 1) * r, e[i].y, 1};  // 时段左边界
    e[i] = {i, e[i].t * -r, e[i].y, 0};            // 时段右边界外
  }
  sort(e + 1, e + 1 + 2 * n);
  for (int i = 1, j; i <= 2 * n; i = j) {  // 枚举每个时段
    for (j = i; e[j].t == e[i].t; j++) {   // 相同时段合并处理
      if (e[j].o) {                        // 开始时段
        m[e[j].y] = e[j].i;                // 记录y坐标
      } else {                             // 结束时段
        m.erase(e[j].y);                   // 删除y坐标
      }
    }
    if (!m.empty()) {            // 当前时段有线段
      b[m.begin()->second] = 1;  // 标记最低线段
    }
  }
  for (int i = 1; i <= n; i++) {  // 枚举线段
    ans += b[i];                  // 累加答案
  }
  cout << ans;
  return 0;
}

```