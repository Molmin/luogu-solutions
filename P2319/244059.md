这题难度不大，但是坑点极多，导致我足足做了半个多小时才A掉，看到题解区好像没有和我的思路一样用结构体排序处理二分图的，所以发篇题解分享一下。

 分析题目
-
首先读题，我们知道总共有**m道题，选手有n种不同的“锦囊妙计”**，每道题都可以从**两种“锦囊妙计”中选择一种**，而每种“锦囊妙计”只能用**一次**，求**最多答出几道题**。很自然的，我们想到了**二分图最大匹配**。由于匈牙利算法要远比Dinic算法好打，所以我就选用了**匈牙利算法**来解决这道题。

PS:现在不让有仿抄袭，我就不弄了，大家一定要自觉哦

代码实现
-
我们浏览样例
```cpp
5 6
3 2
2 0
0 3
0 4
3 2
3 2
```
竟然发现了0，我们都知道正常情况下都是1-m匹配1-n，可这~~毒瘤出题人~~却让1-m匹配0--n-1。所以，很自然的我就想到将**0--n-1，转化为1--n**。**建图代码如下**：

```cpp
inline void adds(int u,int v)
{
	e[++cnt].to=v;
	e[cnt].nxt=head[u];
	head[u]=cnt;
	return ;
}//链式前向星存图又快又好！

for(fint i=1;i<=m;i++)
	x=read(),y=read(),adds(i,y+1),adds(i,x+1);道理很简单，就是将妙计都+1
```
接下来我们就按照**标准的匈牙利算法**跑一遍，这时候再**仔细浏览**题目：
```cpp
只有当选手正确回答一道题后，才能进入下一题，否则就被淘汰。
```
什么意思呢，也就是主人公没有~~复活币~~，不能出现1匹配了，2未匹配，3又匹配的现象。一旦出现匹配不成功的现象，立刻结束。
```cpp
inline int Hungary()
{
	int ans=0;
	for(fint i=1;i<=n;i++)
	{
		memset(vis,0,sizeof(vis));//记得清零
		if(dfs(i))
		ans++;
		else
		break;//在这里一定要BREAK哦！
	}
	return ans;
}

inline int dfs(int x)
{
	for(fint i=head[x];i;i=e[i].nxt)
		if(!vis[e[i].to])
		{
			vis[e[i].to]=1;
			if(!s[e[i].to].x||dfs(s[e[i].to].x))
			{
				s[e[i].to].x=x;
				return 1;
			}		
	    }
	return 0;//爆搜找对象
}
```
现在，我们跑完了匈牙利算法，看一下**储存对应匹配关系的s数组**，发现s数组储存的是锦囊妙计对应的题目，我们要让他翻转过来，所以我们用s.num储存锦囊妙计的编号，当然呢，千万不要误解 _SPJ_ 的意思，我们可不能任意的输出，要符合1--ans的**对应关系**，这里就考虑到**结构体排序**。最后**千万不要忘记结果-1**哦
```cpp
   struct camp
   {
	int num;
	int x;
   }
   s[p];//结构体一步到位
	cout<<ans<<endl;
	for(fint i=1;i<=n;i++)
	s[i].num=i;//储存序号方便之后的排序
	sort(s+1,s+n+1,cmp);排序
	for(fint i=1;i<=n;i++)
	if(s[i].x)
	cout<<s[i].num-1<<endl;//输出
    
   inline bool cmp(camp aa,camp bb)
   {
  	return aa.x<bb.x;
   }
```
这样呢，这道题我们就完成了，赶快交上去~~听取AC一片~~吧。