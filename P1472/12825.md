
首先明确一下题目的意思：用N个点组成一棵深度为i的二叉树，求一共有几种方法？ 设dp[i,j]表示用i个点组成深度最多为j的二叉树的方法数，则：

dp[i,j]=∑(dp[k,j-1]×dp[i-1-k,j-1])(k in {1..i-2})

边界条件：dp[1,i]=1



我们要求的是深度恰好为K的方法数S，易知S=dp[n,k]-dp[n,k-1]。 但需要注意的是，如果每次都取模，最后可能会有dp[n,k]<dp[n,k-1],所以可以用S=(dp[n,k]-dp[n,k-1]+v) mod v


给出n,k,求满足以下条件的二叉树个数 1.每个结点的度为偶数 2.该树有n个结点 3.该树的深度为k 问题分析: 用动态规划和乘法原理求解,可以观察到一个树G(有x个结点,深度为k),如果去除它的根结点可以得到两个子数G1,G2,这两个子图的深度为k-1,他们的结点数的和为x-1.设其中G1有i个结点则G2有x-1-i个结点.


定义P(G)为与满足条件的二叉树G有同样多结点有深度相同且同样满足条件的树的个数.


将二叉树按上述方法依次分解为(有1个结点,深度为k-1的树和有x-1-1个结点深度为k-1的树),(有2个结点,深度为k-1的树和有x-1-2个结点深度为k-1的树),(有3个结点,深度为k-1的树和有x-1-3个结点深度为k-1的树)...(有x-1-1个结点,深度为k-1的树和有1个结点深度为k-1的树)...


由乘法原理得到:由G按上述方法分解成的每对二叉树(Gx,Gy)加一个根结点构成的二叉树的个数有P(Gx)\*P(Gy)个.


G可以分解为x-2对子树,由加法原理得到P(G)=∑P(Gi)\*P(Gj){(i,j)∈G可以分解到的子树对(Gi,Gj)}


定义f(x,k)满足为深度为k,结点个数为x,每个结点的度为偶数的二叉树的个数,由上述分析得到f(x,k)=∑(f(x-1-i,k-1)\*f(i,k-1){1<=i<=x-2}.

```cpp
var
  n,m,i,j,k:integer;
  dp:array[1..200,0..100]of integer;
begin
  readln(n,m);
  for i:=1 to m do
    dp[1,i]:=1;
  for j:=1 to m do
    for i:=1 to n do
    begin
      if not odd(i) then
        continue;
      for k:=1 to i-2 do
        dp[i,j]:=(dp[i,j]+dp[k,j-1]*dp[i-1-k,j-1]) mod 9901;
    end;
    writeln((dp[n,m]+9901-dp[n,m-1]) mod 9901);
end.
```