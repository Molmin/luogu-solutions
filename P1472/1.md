这是一个DP问题。我们所关心的树的性质是深度和节点数，所以我们可以做这样一张表：

table[i][j]表示深度为i、节点数为j的树的个数。根据给定的约束条件，j必须为奇数。你如何构造一棵树呢？当然是由更小的树来构造了。一棵深度为i、节点数为j的树可以由两个子树以及一个根结点构造而成。当i、j已经选定时，我们选择左子树的节点数k。

这样我们也就知道了右子树的节点数，即j-k-1。至于深度，至少要有一棵子树的深度为i-1才能使构造出的新树深度为i。有三种可能的情况：左子树深度为i-1 ，右子树深度小于i-1；右子树深度为i-1，左子树深度小于i-1；左右子树深度都为i-1。事实上，当我们在构造一棵深度为i的树时，我们只关心使用的子树深度是否为i-1或更小。

因此，我们使用另一个数组smalltrees[i-2][j]记录所有深度小于i-1的树，而不仅仅是深度为i-2的树。知道了上面的这些，我们就可以用以下三种可能的方法来建树了：

```delphi

table[i][j] := smalltrees[i-2][k]*table[i-1][j-1-k];
                  // 左子树深度小于i-1，右子树深度为i-1
table[i][j] := table[i-1][k]*smalltrees[i-2][j-1-k];
                  // 左子树深度为i-1，右子树深度小于i-1
table[i][j] := table[i-1][k]*table[i-1][j-1-k];
                  // 左右子树深度都为i-1 

```
另外，如果左子树更小，我们可以对它进行两次计数，因为可以通过交换左右子树来得到不同的树。总运行时间为O(K\*N^2)，且有不错的常数因子。
