其实这一道题是一道递推题，唯一的难点就是难找规律

定义一个f数组，f[n][k]表示n个点不大于k长度的方案数

结果就是f[n][k]-f[n][k-1]了

三重for循环首先枚举长度i，点的个数j，左子树的个数t

公式 f[j][i]+=f[t][i-1]* f[j-i-1][i-1]

记得是乘，而不是加，乘法原理就不解释了

代码如下：

```cpp
#include<cstdio>
#include<cstring>
using namespace std;
int n,k,f[210][210];
int main()
{
	int i,j,t;
	scanf("%d%d",&n,&k);
	for(i=1;i<=k;i++) f[1][i]=1;//一个点无论多高都是1种方案 
	for(i=1;i<=k;i++)//枚举高度 
	{
		for(j=3;j<=n;j+=2)//枚举点数，两边同时+1，所以j+2 
		{
			for(t=1;t<j;t+=2)//枚举左子树的点数 
			{
				f[j][i]+=f[t][i-1]*f[j-t-1][i-1];//刚才的公式 
				f[j][i]%=9901;//题目说的%9901 
			}
		}
	}
	printf("%d\n",(f[n][k]-f[n][k-1]+9901)%9901);//输出，但是这两个数可能不是同级，所以要+9901，这个不影响结果 
	return 0;
}
```