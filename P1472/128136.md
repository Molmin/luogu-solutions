[题目](https://www.luogu.com.cn/problem/P1472)在这里。  
这道题应当是用**动态规划**解的。至于为什么要用动态规划，应当是因为这是个**计数**的问题。    
整篇题解主要分四块：  
- **动态规划的数组**
- **状态转移方程**
- **常数优化，以及一点小坑**
- **完整代码**  

会一一叙述。  
### 动态规划的数组
这个应当是最难整的地方了。  
首先，我们应当考虑这样：$dp_{i,j}$表示$j$个节点、$i$层的完满二叉树的种数。  
然后你会发现推导状态转移方程时推导不下去了。究其原因，是因为这个数组中的数字之间没有什么明显而好用的关系。  
那么继续想。肯定和那个有关；我们就围绕那个试一试。譬如说，利用**前缀和**思想，设$sum_{i,j}=\sum_{k=1}^{i}dp_{k,j}$。  
还有，显然地，$sum_{1,j}=1$。这是**初始值**。
事实上，这个是走得通的。
### 状态转移方程
首先，树的根一定**既有左子树，又有右子树**。除了节点数，它们不互相影响。  
大家应该学过小学奥数中的加法原理与乘法原理吧！在这种情况下，应当**枚举左子树的节点数**，把左右子树的状况数**乘**起来。  
好极了。已经有思路了。给个代码吧！
```cpp
for(int i=1;i<=k;i++)
    for(int j=1;j<=n;j++)
        for(int cut=1;cut<j;cut++)
            sum[i][j]=(sum[i][j]+sum[i-1][j-cut-1]*sum[i-1][cut])%9901;
```
### 常数优化，以及一点小坑
**理论上**，速度能加倍。
完满二叉树有这样一条性质：节点数一定是**奇数**。
为什么呢？可以这样想：完满二叉树都是由根节点“长”出来的；只有根节点时节点数是**奇数**，每“生长”一次增加两个节点，节点数**奇偶性不变**，节点数还是**奇数**。
好极了。上面的代码中的那个$j$只需枚举**奇数**即可。我改进之后是这样：
```cpp
for(int i=1;i<=k;i++)
    for(int j=1;j<=n/2;j++)
        for(int cut=1;cut<2*j+1;cut++)
            sum[i][2*j+1]=(sum[i][2*j+1]+sum[i-1][2*j-cut]*sum[i-1][cut])%9901;
```
哦不，光是这样，你是过不了的。如果你得了91分，错在最后一个点上，输出的是负数，往下看完。  
算法没毛病的。问题出在取模上。举个例子：
$$a=13716,b=8706$$
$$a\bmod 9901=3815,b\bmod 9901=8706$$
$$(a-b)\bmod 9901=5010,a\bmod 9901-b\bmod 9901=-4891$$
所以怎么办呢？简单极了，输出时做个特判，小于零了，就加上9901。
### 完整代码
代码很简洁；但思维难度不小。这便是一个很典型的动态规划。
```cpp
#include <bits/stdc++.h>
using namespace std;
inline int read(){
    int s=0,w=1;
    char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
    while(ch>='0'&&ch<='9') s=s*10+ch-'0',ch=getchar();
    return s*w;
}
//快读的函数。可以读入一个整数。
int main(){
    int n,k,sum[209][209]={0};//n、k如题意。sum是动态规划用的数组。
    n=read();k=read();//输入。
    for(int i=1;i<=k;i++) sum[i][1]=1;//赋初值
    for(int i=1;i<=k;i++)
        for(int j=1;j<=n/2;j++)
            for(int cut=1;cut<2*j+1;cut++)
                sum[i][2*j+1]=(sum[i][2*j+1]+sum[i-1][2*j-cut]*sum[i-1][cut])%9901;
    //动态规划。
    if(sum[k][n]-sum[k-1][n]<0)
        cout<<sum[k][n]-sum[k-1][n]+9901<<endl;
    else
        cout<<sum[k][n]-sum[k-1][n]<<endl;
    //输出。
    return 0;
}
```