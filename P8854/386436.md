# P8854 [POI2002]超级马 题解
蒟蒻的第一篇题解。

好像这道题用bfs更快一点，有的大佬还用了最大公约数来加速求解。但本人是蒟蒻，所以还是用dfs了。但是代码亲测不吸氧也能过，而且简单易懂。

题面给出了棋盘无穷大，直接求解肯定不行。

所以我们来思考一下满足什么条件才可以遍历整个棋盘。

想想我们的洪水填充算法。每一次都是向四周探索，直到遍历整个图为止。

那反过来，遍历整个图，只需要每个点都可以到达相邻的四个点上就可以了。

#### 将这个结论带入到题目中，就可以将题目转化为：给定一些移动方式，不限次数，问能不能在若干次移动中移动到起点上下左右相邻的四个点上。

这一点很显然。因为既然能从起点经过若干次移动移动到上下左右相邻的四个点上，那么，起点的左边一格也可以通过若干次移动移动到上下左右相邻的四个点上
，起点的右边一格也可以通过若干次移动移动到上下左右相邻的四个点上，以此类推，这样就可以遍历整个棋盘（也就是整个图）了。

问题来了，怎么才能判断能否走到起点上下左右相邻的四个点上呢？

观察数据范围，

 $1 \le K,N \le 100,-100 \le P,Q \le 100 $

再结合题意，本蒟蒻第一时间想到的就是搜索。

但是怎么搜索呢？

这好办。既然题目已经告诉我们了 $ -100 \le P,Q \le 100$，所以我们只需要开一个 $200 * 200$ 的二维数组,然后以 $[100,100]$ 作为起点，每个点只要不超过数组范围就循环将各个移动方式都走一遍，最后看起点上下左右相邻的四个点上是否都遍历过即可。这里可以剪个枝：如果已经发现起点上下左右相邻的四个点都经过了，那么直接跳出搜索，输出。


以下是代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=202;
int ax[N],ay[N];
int k,n,p,q;
int a[N][N],e=0;//e是是否经过起点上下左右四个点的标志
void dfs(int x,int y)
{
	a[x][y]=1;
	for(int i=1;i<=n;++i) 
	{
		if(x+ax[i]<=200&&x+ax[i]>=0&&y+ay[i]<=200&&y+ay[i]>=0&&!a[x+ax[i]][y+ay[i]]) dfs(x+ax[i],y+ay[i]);
		if(a[100][101]==1&&a[100][99]==1&&a[101][100]==1&&a[99][100]==1)//剪枝 都经过了就不用搜了 输出TAK 但是如果这句话写在循环外面会T一个点 
		{
			e=1;
			return;
		}
	}
	return;
}
int main()
{
	scanf("%d",&k);
	for(int i=1;i<=k;++i)
	{
		memset(a,0,sizeof(a));
		memset(ax,0,sizeof(ax));
		memset(ay,0,sizeof(ay));//记得每一组数据做完清空数组
		e=0;
		scanf("%d",&n);
		for(int i=1;i<=n;++i) 
		{
			scanf("%d%d",&p,&q);
			ax[i]=p,ay[i]=q;
		}
		dfs(100,100);//暴搜
		if(e==1) printf("TAK\n");
		else printf("NIE\n");
	}
	return 0;	
} 
```




