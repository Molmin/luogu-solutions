在开始讲之前，先发两张图片，那位前辈当初在讲这个课题的时候真的讲的十分的好，并查集基本上是一下就懂了。

##接下来一段话就是这位大神写的，想看的话可以去这个链接：http://blog.csdn.net/dellaserss/article/details/7724401/

这个链接也不是我的链接，只是觉得这篇转发的博文确实值得一看。

【转】

为了解释并查集的原理，我将举一个更有爱的例子。 话说江湖上散落着各式各样的大侠，有上千个之多。他们没有什么正当职业，整天背着剑在外面走来走去，碰到和自己不是一路人的，就免不了要打一架。但大侠们有一个优点就是讲义气，绝对不打自己的朋友。而且他们信奉“朋友的朋友就是我的朋友”，只要是能通过朋友关系串联起来的，不管拐了多少个弯，都认为是自己人。这样一来，江湖上就形成了一个一个的群落，通过两两之间的朋友关系串联起来。而不在同一个群落的人，无论如何都无法通过朋友关系连起来，于是就可以放心往死了打。但是两个原本互不相识的人，如何判断是否属于一个朋友圈呢？

我们可以在每个朋友圈内推举出一个比较有名望的人，作为该圈子的代表人物，这样，每个圈子就可以这样命名“齐达内朋友之队”“罗纳尔多朋友之队”……两人只要互相对一下自己的队长是不是同一个人，就可以确定敌友关系了。

但是还有问题啊，大侠们只知道自己直接的朋友是谁，很多人压根就不认识队长，要判断自己的队长是谁，只能漫无目的的通过朋友的朋友关系问下去：“你是不是队长？你是不是队长？”这样一来，队长面子上挂不住了，而且效率太低，还有可能陷入无限循环中。于是队长下令，重新组队。队内所有人实行分等级制度，形成树状结构，我队长就是根节点，下面分别是二级队员、三级队员。每个人只要记住自己的上级是谁就行了。遇到判断敌友的时候，只要一层层向上问，直到最高层，就可以在短时间内确定队长是谁了。由于我们关心的只是两个人之间是否连通，至于他们是如何连通的，以及每个圈子内部的结构是怎样的，甚至队长是谁，并不重要。所以我们可以放任队长随意重新组队，只要不搞错敌友关系就好了。于是，门派产生了。

![Luogu](http://ognp9z0fj.bkt.clouddn.com/BCJ.jpg)

转这个，只是为了让所有入门的OIer对并查集有一个全面的了解。


话说到底，这道题还有一个问题，就是最后三个点，如果是全裸的并查集，会TLE，所以我们要重新思考如何才能优化并查集。

那么，就看这幅图：

![Luogu](http://ognp9z0fj.bkt.clouddn.com/BCJ2.jpg)

这幅图看懂后，就可以清晰的了解到什么叫做所谓的路径压缩。。在（find函数中）一次一次地询问自己的上级是谁，效率非常低，但是当我们在询问到了自己的上级过后就把自己的上级改到最高的地方去，就是路径压缩了。这也是tarjan的基础。


#分割线++++++++以下是代码。


```cpp
#include <cstdio>
//并查集。 
using namespace std;
int n,m;
int father[10000]; //上级、父亲。。。一切表示父辈的词语都可以描述
int sum[10000];//当前节点所属下级有多少个，在路径压缩的时候可以省步数。
int find(int x){
        return x == father[x]? x:find(father[x]);
}//find（找自己的父亲，其实还有一种while的方法，可以去各大博文上去看一看。
void unite(int x,int y) {
    x=find(x);
    y=find(y);
    if(x==y) return;  //如果本来就来一个并查集内就不管了
    if(sum[x]<sum[y]) father[x] = y; //如果x的sum值更少，那么合并x到y中的代价就更小。
    else {
        father[y] = x;
        if(sum[x] == sum[y]) sum[x]++;
    }
```
}//合并两个并查集
```cpp
int main() {
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++) {
        father[i] = i;
        sum[i] = 1;
```
}//初始化

```cpp
    for(int _=1;_<=m;_++) {
        int z,a,b;
        scanf("%d%d%d",&z,&a,&b);
        if(z==2)  if (find(a) == find(b)) printf("Y\n");  else printf("N\n");
        if(z==1)  unite(a,b);
    }
    return 0;
} 
```
#OIers RP++
