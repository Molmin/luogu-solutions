可以参考博客这一篇：
http://www.cnblogs.com/ACworker/p/7228920.html

图论中的一个较经常考察的点：并查集。就是需要一个unionn(x,y)的合并问题和一个find(x)找父亲问题。

并查集首先就是先把自己指向自己做自己的父亲，等到后面找别人来做自己的父亲，一层一层上去，但是此题要注意的是路径压缩问题，路径没压缩的话就会3个点超时。

我们来平民化一下并查集的概念（很早以前从一个博客上看到的，我用自己的语言组织了一下）：

【平民化概念】：

在金庸小说的世界里，门派很多，经常会发生一些争斗，而且一般来说一个大的势力首先都需要自己出头来做老大，所以这个时候你自己的这个门派的老大就是你自己，即father[you]=you

后来，在你冒险的过程中你开始结识了一群很牛逼的好友，你觉得应该把他们拉到自己的门下，那么这个时候你就劝说他们把他们的门派老大指向你，意思就是说你是他们的老大，即father[别人]=you

但是你只是认识了这些比你低一级别的属下，你属下的属下和他属下的属下都互相不认识啊，这个时候就很容易起争端还不知道是自己人，互相打来打去（怎么这么傻），万一有一天在小树林里碰面，A、B二人都不知道对方是敌是友，如果要一级一级上报上去，显然是可以做到的，但是其中所耗费的时间必然是我们所比较不愿意接受的，所以我们希望我们属下的属下，他的老板就是我，意思就是说他可以直接认识我，并且接触到我，这样的话两人看到，就可能说：“在下是饕餮的属下”，“诶，我是饕餮他属下XX的属下，我们两个是朋友”然后两个人就手拉手一起走上人生巅峰了。。。。。这里的代码转换一下即：判断一下是敌是友（int x=find(A),y=find(B)解释：x是A的顶头上司，y是B的顶头上司)如果不认识，那么认识一个朋友就是一个保障嘛，那么这个时候：father[x]=y，但是你会发现如果这样，一层一层地上报岂不是很麻烦，那么你就可以直接father[A]=y就可以啦，这就是一个非常简单的路径压缩啦

在这么一个有趣的背景下，我们其实已经把并查集的意思给讲完啦，希望大家能够理解！！

CODE：（可以结合上面的平民化小概念来一起理解哦）


```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,z,x,y;
int father[10002];
int find(int i){
    if(i==father[i])return i;
    while(i!=father[i])i=father[i];
    return father[i];
}
void unionn(int i,int j){
    int r1=find(i),r2=find(j);
    if(r1==r2)return;
    father[r2]=r1;//这句可以考虑不要
    father[j]=r1;//这句一定要加上去不然没路径压缩会超时（就是这一句忘了加导致TLE3个点），顺便再说一句，并查集的路径压缩可以达到几乎为O（1）的效率，非常好用！！！用路径压缩提高效率是很多OIer会做的事情，当然如果是那个什么秩的就是考虑树高的会相对比较麻烦
    return;//所以一般用路径压缩可以解决大多的并查集问题
}
int main(){
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++)    father[i]=i;
    for(int i=1;i<=m;i++){
        scanf("%d%d%d",&z,&x,&y);
        switch(z){
            case 1:{
                unionn(x,y);
                break;
            }
            case 2:{
                if(find(x)==find(y))printf("Y\n");
                    else printf("N\n");
                break;
            }
        }
    }
    return 0;
}
```