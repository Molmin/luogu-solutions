\_新题目，我来写写题解\_

这不是并查集裸题么...那么我就在这里讲讲并查集好了

什么是并查集？

~~并查集，从字面意思上说，有三个层面，第一个就是并，第二个就是查，第三个就是集。~~**此话当屁处理**

说白了就是可以**快速地**合并与查找的集合。

并查集的功能：

1.把两个元素所在的集合合并

2.检查两个元素是否在同一个集合

好了，说正事儿：

我们开一个f数组，f[i]就表示i的爹，一开始元素i的爹是自己。在同一个集合的每一个元素，它的祖宗是一样的。注意是祖宗，不是爹。如果一个元素的爹自己，那么这个元素就是祖宗。这个“祖宗”是很重要的，我们用一个祖宗代表一个集合。

- 如何找到一个元素的祖宗呢？我们就要写一个递归找爹，直到找到一个元素的爹是自己的元素为止。

这个函数在下面。我看别人的代码太长，于是发(chao)明(xi)了一个?:表达式的递归找爹，详情见下

- 如何判断两个元素是否在一个集合呢？我们只需要判断这两个元素是否是一个祖宗。也就是**getf(x)==getf(y)**。

- 如何合并两个元素所在的结合呢？首先，这两个元素肯定是在不同的集合，我们要想要合并，只需要把其中一个集合的祖宗的爹改为另一个集合的祖宗。可以这样：**f[getf(x)]=getf(y);**就把x所在集合的祖宗改为y所在集合的祖宗了

- 另外还有状态压缩：

 ![](https://cdn.luogu.com.cn/upload/pic/2744.png) 

如何状态压缩？在递归回溯的过程中，只需要把找到的祖宗作为路上所有节点的爹就行了。

如果没有状态压缩，在递归找爹中，就是**return f[x]==x?x:getf(f[x]);**了，请自己找区别

C++代码：(十分233)

```cpp
#include <iostream>
using namespace std;
int f[10001],n,m,a,b,c;
int getf(int x)
{
    return f[x]==x?x:f[x]=getf(f[x]);
}
int main()
{
    cin >> n >> m;
    while(n--)
        f[n]=n;
    while(m--)
    {
        cin >> a >> b >> c;
        if(a==1)f[getf(b)]=getf(c);
        if(a==2)cout << (getf(b)==getf(c)?'Y':'N') << endl;
    }
    return 0;
}
```