## 本蒟蒻的第一篇题解
### 求赞 ^_^
#### 先说说什么是并查集
并查集，在一些有N个元素的集合应用问题中，我们通常是在开始时让每个元素构成一个单元素的集合，然后按一定顺序将属于同一组的元素所在的集合合并，其间要反复查找一个元素在哪个集合中。这一类问题近几年来反复出现在信息学的国际国内赛题中，其特点是看似并不复杂，但数据量极大，若用正常的数据结构来描述的话，往往在空间上过大，计算机无法承受；即使在空间上勉强通过，运行的时间复杂度也极高，根本就不可能在比赛规定的运行时间（1～3秒）内计算出试题需要的结果，只能用并查集来描述。
#### 						——伟大的度娘
话不多说，此题即为学习并查集必刷的~~水~~题
先来看一个find函数
```cpp
int find(int x){
	if(fa[x]==x) return x;
	return fa[x]=find(fa[x]);
}
```
它的功能是找到集合中一个成员的“父亲”
### 注意路径压缩！！！（我一开始没注意而有3个点TLE）
最后附上AC代码
```cpp
#include<bits/stdc++.h>//万能头 
using namespace std;
int fa[10010];
int find(int x){//找找自己亲爱的父亲 （并查集之精华） 
	if(fa[x]==x) return x;
	else return fa[x]=find(fa[x]);//路径压缩 
}
int main(){
	int n,m,z,a,b;
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++) fa[i]=i;//初始定义父亲 
	for(int i=1;i<=m;i++){
		scanf("%d%d%d",&z,&a,&b);
		int r1=find(a),r2=find(b);//一次读入——一次操作 
		if(z==1) if(r1!=r2) fa[r2]=r1;//可自定义函数unionn 
		if(z==2){
			if(r1==r2) printf("Y\n");
			else printf("N\n");
		}
	}
	return 0;//好习惯 
}
```

*祝大家在成为神犇的路上一帆风顺*
