# 此解绝对是正解
蒟蒻的第一篇题解
------------
好的，在进入代码之前我们先来了解一下并差集。~~根据我多年的经验~~，并差集是一种树的集合，每一个子节点都可以查找到该集的根，并差集可以有两种操作——一种是把两个集合合并，另一种是查找两数在不在同一集合中，就像这个板子想让我们做的一样。

#### 官方解释是这样的：
------------

并查集，在一些有N个元素的集合应用问题中，我们通常是在开始时让每个元素构成一个单元素的集合，然后按一定顺序将属于同一组的元素所在的集合合并，其间要反复查找一个元素在哪个集合中。这一类问题近几年来反复出现在信息学的国际国内赛题中，其特点是看似并不复杂，但数据量极大，若用正常的数据结构来描述的话，往往在空间上过大，计算机无法承受；即使在空间上勉强通过，运行的时间复杂度也极高，根本就不可能在比赛规定的运行时间（1～3秒）内计算出试题需要的结果，只能用并查集来描述。并查集是一种树型的数据结构，用于处理一些不相交集合（Disjoint Sets）的合并及查询问题。常常在使用中以森林来表示。        
###  			—— _来自百度百科_ 

好的，知道了这些我们就可以开始做题了!


------------
首先我们需要把所有的节点初始化，使他的父亲节点等于他本身，及所有的节点都是毫不相干的节点，代码如下：


------------


```cpp
cin>>n>>m;
    for(int i=1;i<=n;i++)
    {
        dad[i]=i;//初始化，使所有数的父亲节点都等于TA本身，即是说有数都为毫不相干的根节点 
    }
```


------------

然后我们就需要判断进行什么操作。通过题中的条件我们可以判断出来，并分别进行操做、


------------

```cpp

 for(int i=0;i<m;i++)
    {
        cin>>zi>>xi>>yi;
        if(zi==1)
        {
            add(xi,yi);//如果zi==1，就要合并 
        }
        if(zi==2)//如果zi==2就判断 
        {
            if(finddad(xi)==finddad(yi))//找到xi与yi的根节点，判断是不是一个，是就说明在一棵树上（一个集合内） 
            {
                cout<<"Y"<<endl;
            }
            else//不然的话输出“N” 
            {
                cout<<"N"<<endl;//不要忘了加endl，不然会错的 
            }
        }
    }
```
------------
现在我们发现，寻找父亲是需要一个函数的


------------

```cpp
int finddad(int a)//寻找TA的父亲节点 
{
    if(dad[a]!=a)//如果他不等于他的父亲节点，也就说明他不是根节点 
    {
        dad[a]=finddad(dad[a]);//将他的父亲节点变成父亲节点的父亲节点……最后他就变成整棵树的第二层了
    }
    return dad[a];//最后返回他的父亲节点 
}
```
------------
~~即你的爸爸就是我的爸爸~~


------------
我们同时还需要一个函数来合并集合


------------
```cpp
int add(int x,int y)//用来合并集合的函数 
{
    int aa=finddad(x);//先找出这两个值的父亲节点然后记录 
    int bb=finddad(y);
    if(aa!=bb)//如果他们两个的父亲节点不相同，说明他们是两棵不相干的树（集合），所以要把它们合并 
    {
        dad[aa]=bb;//要合并只需要把y父亲节点的值（称作bb）赋值给x的父亲节点（称作aa）的父亲节点就好了，相当于在两树之间连了一根线 
    }
}
```


------------
好了~~现在完事了~~附完整代码：


------------
```cpp
#include<iostream> 
using namespace std;
int n,m,zi,xi,yi;
int dad[200001];//数组，表示每一个数存的都是他的父亲节点 
int finddad(int a)//寻找TA的父亲节点 
{
    if(dad[a]!=a)//如果他不等于他的父亲节点，也就说明他不是根节点 
    {
        dad[a]=finddad(dad[a]);//将他的父亲节点变成父亲节点的父亲节点……最后他就变成整棵树的第二层了 
    }
    return dad[a];//最后返回他的父亲节点 
}
int add(int x,int y)//用来合并集合的函数 
{
    int aa=finddad(x);//先找出这两个值的父亲节点然后记录 
    int bb=finddad(y);
    if(aa!=bb)//如果他们两个的父亲节点不相同，说明他们是两棵不相干的树（集合），所以要把它们合并 
    {
        dad[aa]=bb;//要合并只需要把y父亲节点的值（称作bb）赋值给x的父亲节点（称作aa）的父亲节点就好了，相当于在两树之间连了一根线 
    }
}

int main()
{
    cin>>n>>m;
    for(int i=1;i<=n;i++)
    {
        dad[i]=i;//初始化，使所有数的父亲节点都等于TA本身，即是说有数都为豪不相干的根节点 
    }
    for(int i=0;i<m;i++)
    {
        cin>>zi>>xi>>yi;
        if(zi==1)
        {
            add(xi,yi);//如果zi==1，就要合并 
        }
        if(zi==2)//如果zi==2就判断 
        {
            if(finddad(xi)==finddad(yi))//找到xi与yi的根节点，判断是不是一个，是就说明在一棵树上（一个集合内） 
            {
                cout<<"Y"<<endl;
            }
            else//不然的话输出“N” 
            {
                cout<<"N"<<endl;//不要忘了加endl，不然会错的 
            }
        }
    }
    return 0;
} 

```


------------
# 感谢大家QWQ——蒟蒻奉上的真挚感谢
