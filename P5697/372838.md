~~一道大无语的搜索~~

------------------
## 1.题目大意

这题一上来怎么也看不懂，样例太大，所以我先~~贴心~~的给大家一个小样例。

输入样例：

```
6
```

输出样例：

```
2
3 5
```

其实到这还是很不清晰，所以我来解释一下：

这里的输出的 $3$ 表示有三个玩具，两种玩具，第一种有 $1$ 个，第二种有 $2$ 个。组合方案为：$\{0,0\},\{0,1\},\{0,2\},\{1,0\},\{1,1\},\{1,2\}$。

输出的 $5$ 表示有五个玩具，一种玩具。组合方案为：$\{0\},\{1\},\{2\},\{3\},\{4\},\{5\}$。

--------------
## 2.分析

看到这，我们会发现，每一种玩具如果有 $k$ 个，那么就会有 $0,1,2,…,k$ 这些个选择，即一共有 $(k+1)$ 种选择。再根据乘法原理，如果有 $m$ 种玩具，每一种玩具有 $k$ 个，只要满足 $\prod\limits_{i=1}^{m}{k_i}$ 等于 $n$ 即可。

讲大白话就是：从 $2$ 开始搜索（如果从 $1$ 开始，说明玩具的个数为 $0$，无效），如果是 $n$ 的因数，就把 $cnt$ 加上当前的数减 $1$。

---------------
## 3.正确代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,ans[10000000],ansx;//不知道为啥要开如此大 
void dfs(int n,int x,int cnt){
	if(x<=n){
		ans[++ansx]=cnt+n-1;
	}
	for(int i=x;i*i<=n;i++){
		if(n%i==0){
			dfs(n/i,i,cnt+i-1);
		}
	}//dfs找因数的O(sqrt(n))做法 
}
int main(){
	cin>>n;
	dfs(n,2,0);//从2开始，上文有解释 
	sort(ans+1,ans+ansx+1);
	ansx=unique(ans+1,ans+ansx+1)-ans-1;//排序+去重 
	cout<<ansx<<endl;
	for(int i=1;i<=ansx;i++){
		printf("%d ",ans[i]);
	}
	return 0;
}
```