   通过题目给的测试数据，我们可以知道这道题需要用快速幂。
   如果我们用朴素算法的话，那是肯定会**超时**的（~~反正我只过了三个点）。~~
    
   不会快速幂的话转[快速幂](https://baike.so.com/doc/7017753-7240645.html)
   
   当然这只是百科里面的快速幂，如果~~看不懂~~的话也可以看下面~~我的讲解~~（逃）。
   
   快速幂，就像字面说的一样：通过算法快速实现幂运算
   

------------


------------

快速幂的本质，****应该是二进制的转换，运用位运算****；

例如，如果n能被2整除，那我们可以先计算一半，得到a^(n/2)的值，再平方得结果。虽然有优化，但优化的不佳，依然是线性的复杂度。 ~~（那举例个鬼呀）~~（逃）重在思想。

也就是说，我们想要计算的是a的二次方的二次方的二次方的...

所以代码的实现也有了依据。
```c
#define ll long long
ll ksm(ll a,ll n,ll p)//计算a^n % mod
{
    ll s=1;
    while(n)
    {
        if(n&1)////判断n的最后一位是否为1
            s=(s*a)%p;
        a=(a*a)%p;
        n/=2;(也可以是n>>=1)//去掉2进制最后一位。
    }
    return s%p;//返回值；
}
```
**P**是**取模**的值，也可以没有p这个值

上述代码即可简化为

```c
#define ll long long
ll ksm(ll a,ll n)
{
    ll s=1;
    while(n)
    {
        if(n&1)
            s=s*a;
        a=a*a;
        n>>1;
    }
    return s;
}
```



------------
------------
## 上正文了，上正文了。 **注意**

这道题我们可以很简单的推出 _（x+m*10^k）%n _ 

~~**不废话啦**~~直接上代码。

```c
#include<iostream> //头文件
#define ll long long//宏定义
using namespace std;
ll n,m,k,x;//注意定义的是long long类型
ll ksm(ll a,ll n,ll p)//计算a^n % mod,函数里面涉及到的任何参数，包括函数自己也是long long的。
{
    ll s=1;
    while(n)
    {
        if(n&1)////判断n的最后一位是否为1
            s=(s*a)%p;
        a=(a*a)%p;
        n/=2;(也可以是n>>=1)//去掉2进制最后一位。
    }
    return s%p;//返回值；
}
int main()//主函数
{
    cin>>n>>m>>k>>x;//输入
    cout<<(x+(m*ksm(10,k,n)%n)%n)%n;//输出
    return 0;
}
```
最后安利一下我的[博客](https://www.luogu.org/blog/lwhd/)~~（逃）~~

如果本蒟蒻题解写的不够好或者有哪些地方不够精确，请在评论里面留言。

望满意~~~~~~

题解写的不容易。希望审核大佬手下留情    ~~逃~~