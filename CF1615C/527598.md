## 思路

我们发现，对于连续两次操作，第二次操作的位置在第一次操作是一定是 $0$，若操作同一个位置等于不操作，因此只操作不同的位置。

两次操作后只有操作的位置由 $0$ 变 $1$，相当于交换了序列中的一个 $0$ 和一个 $1$。下面分两种情况讨论：

如果 $a$ 中是 $0$，$b$ 中是 $1$ 的位置的数量与 $a$ 中是 $1$，$b$ 中是 $0$ 的位置的数量相同，即可将所有这些位置两两交换，答案即为它们的数量之和；

如果 $a$ 中是 $0$，$b$ 中是 $0$ 的位置的数量比 $a$ 中是 $1$，$b$ 中是 $1$ 的位置的数量少 $1$，则可找到那个多出来的 $1$ ，对它进行操作，之后就变回了第一种情况。

对于其他情况，无解。若两种情况都满足，取最小值即可。


## 代码

```cpp
int t;
cin>>t;
while(t--){
	int n;
	cin>>n;
	string a,b;
	cin>>a>>b;
	a='#'+a,b='#'+b;
	int sum00=0,sum10=0,sum01=0,sum11=0;
    //a0b0,a1b0,a0b1,a1b1
	for(int i=1;i<=n;i++){
		if(a[i]=='0'&&b[i]=='0') sum00++;
		if(a[i]=='1'&&b[i]=='0') sum10++;
		if(a[i]=='0'&&b[i]=='1') sum01++;
		if(a[i]=='1'&&b[i]=='1') sum11++;
	}
	int ans=0x3f3f3f3f;
	if(sum01==sum10) ans=min(ans,sum01+sum10);
	if(sum11==sum00+1) ans=min(ans,sum11+sum00);
	cout<<(ans==0x3f3f3f3f?-1:ans)<<'\n';
}
```