## Description
给定两个 01 串 $a_1$ 和 $b_i$。长度 $n\le 10^5$。问能否通过下面的操作使得 $a$ 变为 $b$：

- 选择一个 $a_i = 1$ 的 $i$，保持其不变，然后翻转剩余所有 $a_i$。

如果能，则输出最小步数。

## Solution
比较妙的题。

首先我们注意到，一次操作可以视为**改变 $a_i$，然后打上全局翻转标记**。

然后我们简化一下状态：不难发现每个 $i$ **初始**满足如下状态之一：

- $a_i = 1$ 且 $a_i = b_i$，简称 $1$ 同，满足这样的 $i$ 的个数记为 $f(1, 1)$。
- $a_i = 1$ 且 $a_i \ne b_i$，简称 $1$ 异，满足这样的 $i$ 的个数记为 $f(1, 0)$。
- $a_i = 0$ 且 $a_i = b_i$，简称 $0$ 同，满足这样的 $i$ 的个数记为 $f(0, 1)$。
- $a_i = 0$ 且 $a_i \ne b_i$，简称 $0$ 异，满足这样的 $i$ 的个数记为 $f(0, 0)$。

然后现在一个局面的状态就可以用 $f(0/1, 0/1)$ 来表示。我们考虑预处理出一开始的 $f(0/1, 0/1)$。

随后，我们注意到如果我们视为改变 $a_i$ 然后打标记的话，第一次操作肯定只能操作 $1$ 同/异，但是由于打上了全局标记，第二次操作就只能操作 $0$ 同/异了，剩下同理，所以我们的操作一定是 $10101010\cdots$ 交替进行。

操作奇数次后，会存在全局翻转标记，这意味着所有的 $0/1$ 异实际上都是同，所以我们要的最终状态是 $f(1/0, 1) = 0$。

操作偶数次后，没有全局翻转标记，这意味着所有的 $0/1$ 同实际上就是同，所以要的最终状态就是 $f(1/0, 0) = 0$。

一次对 $1$ 同的操作会使得 $1$ 同减一并且使得 $0$ 异加一，剩余情况同理。

所以，当且仅当 $f(1, 1) - f(0, 1) = 1$ 时，我们可以操作奇数次使得 $f(1/0, 1) = 0$，操作次数显然为 $f(1, 1) + f(0, 1)$。

当 $f(1, 0) = f(0, 0)$ 时，我们可以操作偶数次使得 $f(1/0, 0) = 0$，操作次数显然为 $f(1, 0) +f(0, 0)$。

于是此题就做完了，没有看懂的可以看下代码：

## Implementation
```cpp
const int maxn = 1e5 + 5;
char s1[maxn], s2[maxn];
int n;

int main() {
    int T; read(T);
    while (T--) {
        read(n), read(s1 + 1), read(s2 + 1);
        int same[2][2] = {0};
        FOR(i, 1, n)
            ++same[s1[i] - '0'][s1[i] == s2[i]];
        int ans = 1e9;
        if (same[1][1] - same[0][1] == 1) ans = same[1][1] + same[0][1];
        if (same[1][0] == same[0][0]) chkmin(ans, same[1][0] + same[0][0]);
        print(ans > n ? -1 : ans);
    }
    return output(), 0;
}
```