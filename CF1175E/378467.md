题目大意：给你一些线段，然后 $Q$ 次询问，每一次询问询问一段区间 $[l, r]$，问最少需要多少条线段可以覆盖这一段区间。

我们定义 `Seg[i]` 代表一条线段，其中 `seg[i].l` 代表线段的左端点，`seg[i].r` 代表一条线段的右端点。

我们可以暴力地贪心，每一次贪心区间 $[l, r]$，在 $O(N)$ 的时间复杂度内求出区间需要几条线段覆盖，但是这道题有多组询问，时间复杂度为 $O(NQ)$，所以会超时。

我们现在要将时间复杂度控制在 $O(N\log N)$ 及以下。

可以发现，对于某一个位置 $x$，有多条线段都可以覆盖这一个位置，我们实际上只用记录所有线段中，右端点最靠右的那一条就可以了。

现在我们要预处理出来一个 $R_i$，代表哪一条线段，它的左端点小于 $i$ 点，而且右端点最大。

但是 $R_i$ 如何预处理呢？对于任意的一条线段，$R_i = \max(R_i, seg_i.r)$

$R_i$ 也可以由 $R_{i - 1}$ 来更新过来，这样我们就可以预处理出来每一个位置往右，左端点小于 $i$ 点，且右端点最大了。

**核心要领：ST表**

我们定义 $dp_{i, j}$ 表示 $i$ 位置往右，$2^j$ 条线段所能到达的最靠右的位置。

$dp_{i, 0}$ 表示从 $i$ 位置开始，往右一条线段所能到达的最右位置，它就等于 $R_i$。

$dp_{i, j}$ 递推公式：$dp_{i, j} = dp_{dp_{i, j - 1}, j - 1}$。

**下面上代码**

```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 200010;
const int MAX_L = (N << 1) + N;

int dp[MAX_L][20], R[MAX_L];

int main()
{
    int n, m, l, r;
    cin >> n >> m;
    for (int i = 0; i < n; i ++)
    {
        scanf ("%d%d", &l, &r);
        R[l] = max(R[l], r); // 通过线段更新 R[l] 的值
    }
    dp[0][0] = R[0];
    for (int i = 1; i < MAX_L; i ++)
        R[i] = max(R[i], R[i - 1]); // 通过 R[i - 1] 来更新 R[i] 的值
    for (int i = 1; i < MAX_L; i ++) // 从这里开始预处理ST表(RMQ)
        dp[i][0] = R[i]; // 初始条件
    for (int j = 1; j < 20; j ++)
        for (int i = 0; i < MAX_L; i ++)
            dp[i][j] = dp[dp[i][j - 1]][j - 1]; // 状态转移方程
    // 询问，重点
    while (m --)
    {
        int x, y;
        scanf ("%d%d", &x, &y);
        int ret = 0;
        for (int i = 19; i >= 0; i --)
            if (dp[x][i] < y) // LCA思想，能跳就跳
                x = dp[x][i], ret += (1 << i);
        if (dp[x][0] < y)
            puts("-1");
        else
            printf ("%d\n", ret + 1); // LCA思想，到最后了，还不是最近的公共祖先，我们还需要往前跳一步才算是公共祖先
    }
    return 0;
}

```

