### 2018/12/7 22:14 初版

### 2019/12/6 编辑 ~~一周年~~

	优化了一些表达式，看起来更舒服了
    更正了一个错误：
    	原稿中写有“解释的条件其实就是n=1，因为n是整数，不可能直接一步跳到0的（这题因为没有设立下限，其实就表明了n≥0）”
        当时作者能力有限，没有发现有一个严重的错误
        并不是因为没有设立下限而表明n≥0，而是因为n为正整数，正整数乘或除以正整数不可能变成负的
        目前已经修正，详细直接看文章吧
        


这其实是一道大水题

## 不要把它想得太复杂！

# 这是一道一遍AC的题！

来来来分析一下题意：

	给了你一个鬼畜的程序和一个整数n
    让你判断，将n代入这个程序段中，该程序会不会停止
    （其实n是正整数，后面会讲为什么）

再看一看给你的程序段：

```
while n > 1
  if n mod 2 = 0 then
    n:=n/2
  else
    n:=3*n+3
```

这不是**Pascal**吗【捂脸】

前P党党员+P党党员表示~~快乐~~【我就是一个P转C的人】

应该都看得懂吧，就解释一下几个和C++不同的写法
	
    while ~表达式~  对应：while (~表达式~）
    if ~表达式~  对应：if (~表达式~）
    Pascal里，if中的"="相当于C++中的"=="
    ":="就是C++中的"="
    mod 求模，即取余数，相当于"%"
    
所以，程序段大意便为：
	
    在n>1时，如果是偶数，就除以2；
    是奇数？乘上3再加3。

这题的解法其实很简单，大致如下：

	如果n为2的k次方（或者说n的k次方根为2，k为正整数）
    就写“TAK”
    反之，写“NIE”
    
# **为啥？**

### 来分析一下

这题解题的精髓便在处理奇数的程序上

处理偶数那个不用管。不就除以个2吗，偶数，除以2又不会变成小数

但看一看处理奇数的程序，大有内涵：

```
n:=3*n+3
```

太烦了，提取公因式，就变成了：

```
n:=3*(n+1)
```

大家应该看出来了：只要进入了处理奇数的分支里，就必定会**含有一个因子3！！**

n为偶数时，也只能除以个2，这个因子3是消不掉的，只会越积越多【n的最小值已经成3了】

所以，进入奇数分支，还想小于等于1？来搞笑的吧

所以要想顺利结束该程序段，只能一路偶数到底

【顺带皮一句，结束的条件就是n=1。为了题目有意义，n是正整数。一个正整数乘或除以一个正整数是不会变负的。其次，不用考虑n=0，因为n乘或除以的那个数不等于0】

怎么办？

# 2^k=n了解一下

我解释的够清楚了吧

这个用一个递归即可搞定，咋搞看注释：

```
bool Pss( long long n ){
	if ( n == 1 )
        //n已经变成1了，符合条件
		return true;
	if ( n % 2 == 0 )
        //还是偶数，算Pss(n/2)【这就是递归的精髓】
		return Pss( n / 2 );
	return false;
    /*由于C++自动忽略return后的所有语句(没运行的不算）
      所以在这里，能执行到这的只有奇数了
      不是1，不是偶数，非正数不行，不是奇数是啥？*/
}
```

后面没有任何技术含量，上代码就是了：

```
#include<bits/stdc++.h>
using namespace std;
bool Pss( long long n ){
	if ( n == 1 )
		return true;
	if ( n % 2 == 0 )
		return Pss( n / 2 );
	return false;
}
int main(){
	long long n;  //10^14,int似乎装不下
    //不开long long见祖宗
	cin >> n;
	if ( Pss( n ) )  //如果正确
	{
		cout << "TAK";
		return 0;  //这个是个人习惯，完全可以用else
	}
	cout << "NIE";
	return 0;
}
```

所以

综上所述

## Think More！

## And You Will Success!