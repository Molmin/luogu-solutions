应该是唯一一个O(1)解法。

------------
首先，这是一道类似于读程序写结果的题，把那个伪代码放一下
```
while n > 1
 if n mod 2 = 0 then
   n:=n/2
 else
   n:=3*n+3
```
然后，分析一下这个语句```n:=3*n+3```化简一下得```n:=3*(n+1)```,看出来了吗，如果这个语句被执行，那 $n$ 的因数里就会有 $3$ 永远不会停止，所以 $n$ 一定是一除到底，也就是 $n=2^k(k\text{为常数})$

------------

因为 $2^k$ 一定化成二进制能写成只有第 $k+1$ 位是 $1$，其他都为 $0$。$2^k-1$一定化成二进制能写成后 $k$ 位都是 $1$，其他都为 $0$。两数做 $and$ 运算，结果一定为 $0$。

所以直接写就行了：
```cpp
#include<bits/stdc++.h>
using namespace std;
long long n;//一定要long long
int main()
{
	cin>>n;
	cout<<((n&(n-1))?"NIE":"TAK");//三目真香
	return 0;
 } 
```
好了，完了，给个赞吧。