## 思路：

~~简单~~区间DP题。

### 最大值减最小值
分析题目，发现每一组中除了最大值、最小值，其他值没有作用。中间的值可以在某一组中，也可以单独分离出来成为一组。

分析数据范围：$n<=200$ 

emmm  O($n^3$)

对于每一个数据，都有以下几种情况：

1.作为一组值的最小值

2.作为一组值的最大值

3.作为一组值的中间值

4.单独成为一组

而所有数据的最小值不可能作为一组值的最大值，所有数据的最大值反之。

考虑将数据升序排序，方便处理每一组值的最大/最小值。

设 $f[i][j][k]$ 表示前 $i$ 个值（排序后），有 $j$ 个组 **可以** 再选人（还没最大值），不和谐度为 $k$ 的方案数。

根据上述四种情况，转移式为：

$f[i][j][k]+=f[i-1][j-1][k+a[i]]$

（$k+a[i]$表示这一组减去最小值）

$f[i][j][k]+=f[i-1][j+1][k-a[i]]*(j+1)$

（ $k+a[i]$ 表示这一组加上最大值，最大值可以是前面j组任意一组的最大值，所以结果乘 $j+1$ ）

$f[i][j][k]+=f[i-1][j][k]*j$

（中间值可以在前面j组任意一组中，所以结果乘 $j$ ）

$f[i][j][k]+=f[i-1][j][k]$

（自开自闭~~简称自闭~~区间）

然而这样打完后你会发现： $k$ 值如何枚举？？

$k$ 的范围极其不定，可以在最小值时变成-100000，也可以在n处回到k。

所以这是这道题第二个难点：

### 动态算贡献

由于k的不确定性，我们继续分析题目

当数据为:

$2,3,5,7,8$

时，如果某组以2为最小值，7为最大值，它的k值变化应该是

$-2 ..... +8  =6$

由于数据是排序的，所以也可以写成

$+(3-2) .. +(5-3) .. +(7-5)..  +(8-7)  =1+2+2+1=6$

它们是相同的。

~~自己推推就好了~~

所以k值在每次转移时，不必在最小值和最大值处变化，而是在每次转移时变化，变化值为 $a[i]-a[i-1]$

状态转移式变为：

$f[i][j][k]+=f[i-1][j-1][k-(j-1)*(a[i]-a[i-1])]$


$f[i][j][k]+=f[i-1][j+1][k-(j+1)*(a[i]-a[i-1])]*(j+1)$


$f[i][j][k]+=f[i-1][j][k-j*(a[i]-a[i-1])]*j$


$f[i][j][k]+=f[i-1][j][k-j*(a[i]-a[i-1])]$

需要注意的是：由于转移时最小值与最小值-1的差值并不需要加上，所以1、2转移要稍加变换。

最后只需要累加 $f[n][0][i]$ ( $i$ from $0$ to $k$ )即可。

而 $f[0][0][0]=1$

然后就愉快的AC了。

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int f[201][201][1001];
int a[100001];
#define mod %1000000007
int main()
{
	int n,m,ans(0);
	cin>>n>>m;
	for(register int i=1;i<=n;i++)
		scanf("%d",&a[i]);
	sort(a+1,a+n+1);
	f[0][0][0]=1;
	for(register int i=1;i<=n;i++)
	for(register int j=0;j<=i;j++)
	{
		int cha=(a[i]-a[i-1]);
		for(register int k=0;k<=m;k++)
		{//f[i][j][k]:前i点，开区间j个，到现在的值 k
			//kai
			if(j!=0&&k-(j-1)*cha>=0)
			f[i][j][k]=(f[i][j][k]+f[i-1][j-1][k-(j-1)*cha])mod;
			//bi
			if(j!=n&&k-(j+1)*cha>=0)
			f[i][j][k]=(f[i][j][k]+(long long)f[i-1][j+1][k-(j+1)*cha]*(j+1))mod;
			//mid
			if(k-j*cha>=0)
			f[i][j][k]=(f[i][j][k]+(long long)f[i-1][j][k-j*cha]*j)mod;
			//one
			if(k-j*cha>=0)
			f[i][j][k]=(f[i][j][k]+f[i-1][j][k-j*cha])mod;
		}
	}
	for(register int i=0;i<=m;i++)
	ans=(ans+f[n][0][i])mod;
	cout<<ans;
}
```

### 注意事项

1.DP时 $j$ 可能是负值或超过 $n$ ，需要特判。

2.DP转移相乘时要开longlong！

3.别忘了mod

祝大家AC愉快。