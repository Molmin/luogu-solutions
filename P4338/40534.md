如果$x$号城市崛起，那么这一次崛起发生的战争数量就是这个城市到根的路径上的城市所属于的不同的国家的数量。

由于一个城市崛起过后，会使从这个城市到根的路径上的城市都属于它管辖，所以属于同一个国家的城市，它们一定组成一条链，并且这条链上的点的深度是依次递增的。

为了方便统计答案，在一个城市崛起的过程中，我们只在它与某个国家发生战争的城市中深度最大的那一个城市统计答案。也即是计算有多少个“发生了战争的深度最大的城市”。

![图示1](http://wx4.sinaimg.cn/mw690/0060lm7Tly1fxwsgb1zqgj30w00i0dg2.jpg)

如图，7号点崛起，然后3号点崛起。如果现在6号点崛起，需要统计贡献的点是4号点和1号点。

发现一个点被统计一次贡献，要求它的子树内有两个城市先后崛起，并且这两个城市来自不同的儿子的子树（如果是来自同一个儿子，那么就会在深度更大的位置统计贡献，这个城市虽然管辖的国家变了，但是对答案没有贡献）。

进一步挖掘性质：整个历史进程描述为一些国家依次崛起。考虑一个点的时候，来自这个点的子树以外的点的崛起不需要被关心；这个点的一个儿子的子树内的点的崛起的**相对顺序**也不需要我们关心。我们只关心这个崛起顺序中来自这个点的不同的儿子的子树的点的相对顺序。这就是说，我们对于每个点都按照最优的方式安排它的儿子的崛起，这对于它的祖先、它的儿子都是没有影响的。

问题简化为，对于一个点$u$，有$n$个儿子，每个儿子的子树的所有点总共会崛起$x_i$次，安排一种顺序使得来自不同子树的先后两次崛起的数量最大。

如果这些点的分布比较均匀，我们可以找出一种安排，使得相邻两次崛起一定来自不同的子树。即$ans=(\sum x_i)-1$。那么什么情况下找不出这样的一种安排呢？一定是有来自于某一个子树的点的数量过多，把这些点拿出来，相邻两个之间插一个来自其他子树的点，其他子树的点插完了，这个子树的点还有剩，那么剩下的那一段就必须是连续的、来自同一个子树的点了。设$tot=\sum x_i$，$mx$为所有$x_i$的最大值，这时候$ans=2\times (tot-mx)$。显然此时$2\times (tot-mx)<tot-1$。

综上，$ans=min(tot-1,2\times(tot-mx))$

有一点需要注意，一个点子树内的崛起事件，不仅可以来自这个点的儿子，还可以来自这个点自己，计算答案的时候可以把这个点自己当做它的一个子树，即要求不来自于同一个子树（可以一个来自子树，一个是$u$自己），或者不都来自于$u$。

到这里，我们可以得到不带修改的做法：直接$O(n)$扫一遍，$tot$为$u$子树内所有的崛起次数，$mx$为$u$的崛起次数与$u$的不同儿子的的子树内的崛起次数的最大值，这个节点对答案的贡献就是$min(tot-1,2\times (tot-mx))$。所有节点的贡献加起来就是答案。

考虑如何修改。设$tot_u$表示以$u$为根的子树內所有节点的崛起次数总和。那么修改一个点$u$，就会影响到$u$到根的路径上所有节点的$tot_u$，也会相应地影响这些节点对答案的贡献。

考虑当$tot_u-1>2\times(tot_u-mx)$的时候，如果修改的是$mx$来自的子树的点，那么修改前的贡献是$2\times (tot_u-mx)$，修改后的贡献是$2\times ((tot_u+w)-(mx+w))=2\times(tot_u-mx)$。$u$的贡献是不变的。

这样就启发我们如何优化修改的过程：如果一个点存在一个儿子$son[u]$使得$tot_u-1>2\times(tot_u-tot_{son[u]]})$，那么就在$u$到$son[u]$之间连实边，$u$到其他的儿子连虚边，一次修改中我们只考虑这个点到根的路径上，实链之间（也就是由虚边相连的点）的贡献变化。

我们记录下每个点当前对答案的贡献类型：是$tot-1$，还是$2\times (tot-mx)$且$mx$来自一个子树，还是$2\times(tot-mx)$且$mx$是这个点自己。修改一个点过后，这个点到根的路径上的所有点的$tot$都会$+=w$。由虚边相连的点，它的贡献类型可能会发生变化。直接从当前的答案中减去它原来的贡献，修改，然后重新计算它的贡献类型，加上它现在的贡献。这里对于一条实链上的点，我们需要区间修改、单点查询这些点的$tot$，那么可以利用差分的思想，设$val[u]=tot_u-tot_{son[u]}$，在LCT中维护$val$的和即可。

具体来说，LCT中的某条实链，维护它的splay里面的每个节点的$val$值的和就是这条实链上深度最小的点的$tot$。因而，如果想要得到某一个点的$tot$，就应该计算$splay$里面**深度大于等于它**的点的$val$之和，也就是将这个点splay到根后，这个点的$val$加上它右子树的$val$之和。修改某一条实链（或者某条实链的上半部分），只需要将这条链上待修改的、深度最大的点的$val$加上$delta$，就等价于将这个实链上深度小于这个点的点进行了区间加。

修改过后，要重新考虑实链上被修改的点中深度最低的点：

1.它的虚儿子中有一个的$tot$改变了，这个虚儿子的$tot$是否大于它当前实儿子的$tot$？如果是，则应该将这个点的$val$加上当前实儿子的$tot$，减去那个虚儿子的$tot$（保证$val_u=tot_u-tot_{son[u]}$），然后将那个儿子置为虚儿子。

2.这个点的$tot$改变了，它的贡献类型是否会变化？如果$tot-1<2\times (tot - tot_{son[u]})$，还要记得把$son[u]$置为 0 。

修改的复杂度等于这个点到根的路径上虚边的数量乘以splay的复杂度。如果一个点没有实儿子，那么从它的儿子这一层到它，$tot$至少会增加一倍。如果一个点的父亲有实儿子，但是不是这个点，父亲的$tot$就至少是这个点的两倍。因此，修改的虚边数量是$\log$级别的。