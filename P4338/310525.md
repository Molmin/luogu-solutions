[更好的阅读体验](https://www.cnblogs.com/LaoMang-no-blog/p/16393477.html)

---

[**你谷 link**](https://www.luogu.com.cn/problem/P4338)

这个题说模板挺模板的，但是其实也很有思维，这里来讲讲看。

简化题意，给定一棵 LCT，初始都是虚边，给定每个点的 `access` 操作次数，求一个操作顺序使得虚实边转换次数最多。

首先考虑如果不存在修改怎么做，我们考虑按每个点分别考虑，我们发现当相邻两次操作在不同的子树中（或者一个在子树中另一个是自己）都可以产生贡献，我们可以着手构造，然后发现如果没有一个子树（或自己）的操作次数和大于一半，都可以构造满，否则就是剩下的两倍，即 $\min\{S-1,2(S-\max\{a_x,\max_{y\in\operatorname{son}(x)}S_y\})\}$，这样我们就能得到没有修改操作的分。

接下来是修改操作，首先显然这种修改只会影响被修改的点到根的路径，我们考虑对这条路径进行操作。

观察上式，我们发现有一个临界点，就是 $S$ 和 $\max_{y\in\operatorname{son}(x)}S_y\}$，的关系，即有没有一个子树的大小超过一半，另一个特性是这个子树只可能存在一个，我们称这个子树对应的儿子为该点的“重儿子”，与重剖不同的是，重剖中的重儿子是子树最大的儿子，而这里不是，这里是**子树大小超过该树一半的儿子**，且这个重儿子也可以是自己（自己的值超过子树的一半），当然也可以没有。

类比重剖，重儿子组成了一条重链，我们发现一次修改最多只会在每条重链中影响一个点，因为重儿子变大不会影响上式的值，这是保证我们时间复杂度的关键，重剖中每个点到根只会经过至多 $\log n$ 条重链，因为每经过一个轻儿子子树大小就会减半，这其实就是点权等于 $1$ 的特殊情况，在点权不为 $1$ 时同样成立，最多经过 $\log\sum_{i=1}^n a_i$ 条重链，证明同上。

接下来问题就转化成一下几点：

1. 动态维护重链的修改；
2. 查询子树和与重儿子信息。

这其实就很显然了，可以直接套 LCT 解决，时间复杂度大约是 $\mathcal O\left(n\log\sum_{i=1}^n a_i\right)$，不是很会 LCT 的时间复杂度证明，如有错误欢迎指正。

[**c++ 代码**](https://www.cnblogs.com/LaoMang-no-blog/p/16393477.html)