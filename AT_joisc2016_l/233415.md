**结论**：苯题疑似存在 $O(n)$ 做法。

考虑 $2$ 小时的人 $X$ 匹配了哪个 $5$ 小时的人 $Y$。不妨认为 $X_i$ 的分数 **不比** $X_{i+1}$ 的分数 **低**，$Y$ 同理。

$X_i$ 能匹配的 $Y_j$ 的 $j$ 构成一个区间 $j\in \left[1,f_i\right]$。容易发现 $i\le f_i\le f_{i+1}$。

这些分界线自然地把 $Y$ 序列划分成了若干个块。

定义 $Y_i$ 属于块 $k$，当且仅当 $k$ 满足 $f_{k-1}+1\le i\le f_{k}$，并记 $B_i=k$，$siz_k=f_{k}-f_{k-1}$，初始时 $cnt_{k}=0$。

由于求的是最多的匹配数量，容易发现存在最优解，方案是：根据 $i$ 从小到大考虑，如果可以在 $[1,f_i]$ 中找到未匹配的人并且国籍相同的人，就直接匹配。

考虑当前考虑 $X_i$ 匹配的是谁。记目前划分出来的标号最大的块的标号为 $num$。为了行文方便，**暂时** 先用 `std::multiset` $S$ 来储存 $\left[1,f_i\right]$ 未匹配的人 $Y$。

现在考虑在 $S$ 中找一个人 $Y_j$ 使得国籍和 $X_i$ 相同，并且所属于的块标号最大。

- 操作 $1$：当找到这样的人 $Y_j$，在块 $B_{j}$ 上插一个匹配旗，并且执行赋值语句 $cnt_{B_j}\leftarrow cnt_{B_j}+1$，把 $B_j$ 从 $S$ 中删除。

- 操作 $2$：当找不到这样的人 $Y_j$，就在块 $num$ 上插一个占座旗，并且执行赋值语句 $cnt_{num}\leftarrow cnt_{num}+1$。它的意义是要在 $[1,f_{i}]$ 中留一个人给它匹配，因此它实际上可以放在块 $1,2,\cdots,num$ 中的任意一个可以放的块里边。

当上面的赋值语句中使得 $cnt_{x}=siz_x+1$，肯定是块 $x$ 里占座旗过多，考虑将其中一个占座旗移动到前面的块，给新加进来的这个旗子让出位置，从而使得 $cnt_x$ 依然和 $siz_x$ 相等；如果无法把占座旗放进前面的块，也就是无法把占座旗继续往前移，那么可以判定找到的这个人 $Y_j$ 必定是被前面的人给占了。因此将这个人从 `multiset` 中删除，继续在 $S$ 中找人。

这个算法已经可以找出正确答案了。最后，来优化一下上面算法里复杂度比较高的地方。

- 第一个是找块 $x$ 前边没满的块。维护一个 $pre$ 数组，用 $pre_x$ 代表 $x$ 的上一个块。如果某个块已经满了，那么后边也用不到了，因此可以 **路径压缩**。总共时间 **据有位高手说** 是 $O(n)$。

- 第二个是使用 `std::multiset` 多出来的 $\log$ 因子。由于国籍最多 $O(n)$ 个，用 $O(n)$ 个栈去记某个国籍、还没被删掉的人 $Y$，对应的块的标号。总共时间也是 $O(n)$。

输入时 $X,Y$ 已经分别有序了，因此也不必排序。总复杂度就是 $O(n)$ 了。

[在 LOJ 上的提交](https://loj.ac/s/1424399)。目前在 AT 和 LOJ 上均为最优解，但俺不太会证这个路径压缩的复杂度，以后会了再补上，或者等一个高手来指点指点俺吧。

