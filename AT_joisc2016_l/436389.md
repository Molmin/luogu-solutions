赛时乱搞做法，然后没开可重集被卡成 $90$。

当然这题并不需要开可重集。

考虑费用流建模，如果把 $(c_i,d_i)$ 二元组合当成左部点，把 $(a_i,b_i)$ 当成右部点。

然后由于要求一一对应且 $d_{p_i} \geq b_i$，所以可以将 $(o,d_i)$ 连向 $\forall p \in [0,d_i], (o,p)$，费用为 $0$，流量为 $1$。对于 所以可以把同类的 $(o,d_i)$ 连向 $\forall g \not = o,p \in [0,d_i], (g,p)$，费用为 $1$，流量为 $1$。

然后跑最小费用最大流可以做到 $O(n^3)$。

一眼这东西不好搞，直接考虑一些可行策略。

考虑贪心策略，把尽可能多的点不改变类型，也就是贪心的选比当前值大的最小数，如果没有，则必然改变类型，否则贪心选取。

然而显然要求的是对于你选择的决策 $S$，你必然需要满足决策 $S$ 满足存在完美匹配。

然而显然上述贪心不一定能满足存在完美匹配。

那每次贪心的时候判断存在完美匹配，考虑其正确性。

首先感性得理解，不难发现由于已经从大到小排序，选择比当前数大的最小决策一定不会影响后面同类的决策。

然后考虑用拟阵证明：

考虑 $M=(S,L)$ 的拟阵，考虑 $L$ 是 完美匹配的子集，$S$ 是边集。

考虑 $w(x)$ 为同类连边是 $0$，否则为 $1$。

考虑 $L$ 是否满足遗传性和交换性，不难发现子集显然满足遗传性，而交换性也不难得出。

所以按照 $w(x)$ 递减排序，显然是对的。但是照着贪心复杂度不太能接受，毕竟边集是 $O(n^2)$，考虑右部点固定时只能选一条边，固考虑用一条最优边来判断。考虑取大的最小值的左部点显然在固定右部点时，存在完美匹配的可能性更高，即如果判定出不存在完美匹配，则所有 $w(x)=0$ 且为当前右部点的边集都不能选，否则选择这条边仍然能去除当前右部点的边集。

然后还有点问题，$w(x)=1$ 的边怎么办，很简单，其实只用计数 $w(x)=0$ 的边取的最多边数，然后总数减去选择的右部点点数即可。

考虑完美匹配怎么判，不难想到hall定理，考虑连边的特殊性，连边为一段前缀，那可以判断值域的前缀大小关系。

这个可以做差，维护全局最小值，删边可以在线段树上做。

复杂度 $O(n \log n)$。

```cpp
signed main(){
    //fprintf(stderr,"%.3lfMB\n",(&test2-&test1)/1048576.0);
    n=read();
    for(int i=1;i<=n;i++) a[i]=read(),h[++tot]=b[i]=read();
    for(int i=1;i<=n;i++) c[i]=read(),h[++tot]=d[i]=read();
    sort(h+1,h+tot+1);tot=unique(h+1,h+tot+1)-h-1;
	for(int i=1;i<=n;i++) b[i]=lower_bound(h+1,h+tot+1,b[i])-h;
	for(int i=1;i<=n;i++) d[i]=lower_bound(h+1,h+tot+1,d[i])-h;
	// for(int i=1;i<=n;i++) printf("%lld ",b[i]);puts("");
	// for(int i=1;i<=n;i++) printf("%lld ",d[i]);puts("");
    for(int i=1;i<=n;i++) st[c[i]].insert(d[i]);
    for(int i=1;i<=n;i++) t.update(1,1,tot,d[i],tot,-1),t.update(1,1,tot,b[i],tot,1);
    int res=0;
    for(int i=1;i<=n;i++){
        
        auto u=st[a[i]].lower_bound(b[i]);
        if(u==st[a[i]].end()) res++;
        else{
            int p=*u;t.update(1,1,tot,p,tot,1),t.update(1,1,tot,b[i],tot,-1);
            if(t.mn[1]>=0){st[a[i]].erase(u);}
            else{
                t.update(1,1,tot,p,tot,-1),t.update(1,1,tot,b[i],tot,1);
                res++;
            }
        }
    }
    printf("%d\n",res);
    return 0;
}
```
