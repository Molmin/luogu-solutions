## 来发一波Cayley公式的证明

解法:对于每一个n,输出n^(n-1)即可

但是重点不在此,重点是证明的方法~~OI不需要证明~~

## 前置知识:
首先介绍一种树的编码方式，就是我首先知道这个树上的节点时标好了号的，其实号应该是随意标的，因为完全图是对称的。然后我对这棵树可以有一个编码的方式，就是取树上标号最小的叶子节点，写下与它相邻的节点的标号，然后把这个删掉，以此类推，直到这棵树最后只剩下了两个节点为止，此时此刻我们得到了一个长度为n-2的数列。第一部分也就证明完毕了即一棵完全图的生成树唯一对应一个长度为n-2的数列。 
## 开始证明了
第二部分我们证明一个长度为n-2的数列是唯一对应一棵完全图的生成树，首先对于这个数列，其中的元素都是1-n之间的，但是这其中的元素又不是完全包含1-n之间的所有元素，所以我们去寻找不包含在这个数列之中的最小的数字是多少，找到这个数字就说明这个数字肯定是原树的叶子，并且是最小的叶子，（因为假如这个节点不是叶子的话，那么他就得有两条边，最后只剩了一条边，所以这个节点的某一个连接点被去掉过，所以数列中就必须有这个节点，但是数列中没有，并且它是这棵树最小的叶子节点）所以第一个数就是和这个最小的叶子相连的节点，然后我们按照相同的方式去应用于后面n-3个节点，寻找第二个叶子和哪一个节点相连以此类推，我们最后得到了唯一一颗完整的树。所以证毕了,~~AC了~~

## SO CODE:(基于[P1226](https://www.luogu.org/problemnew/show/P1226#sub))
```cpp
// luogu-judger-enable-o2
#include<bits/stdc++.h>
#define ll long long
using namespace std;
ll m=1e9+9,n,p,mm,nn,pp,ans=1,t;
int main()
{
    scanf("%lld",&t);
    while(t--)//多组数据读入
    {
		scanf("%lld",&n);
		p=n-1;//质数
		ans=1;//初始值
	    mm=m;nn=n;pp=p;
	    //if(pp==0)return puts("0"),0;
	    for(;p;p/=2,n=n*n%m)if(p&1)ans=ans*n%m;//快速幂
	    printf("%lld\n",ans);//输出
	}
    return 0;
}
```

部分内容转自[CSDN](https://blog.csdn.net/wanwandebaba/article/details/78946057)