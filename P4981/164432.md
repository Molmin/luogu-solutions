# prufer 编码 

对于一个无根树，他的 prufer 编码是这样确定的：  

- 每次找到**编号最小的**一个叶子节点，也就是度数为$1$的节点，把**和它相连的点**，加入 prufer 编码序列的末尾，然后把这个点从树中删掉  
- 如果当前树只有两个节点了，就停止  

那么，通过给定的无根树求 prufer 编码就很简单了  
比如下面这个无根树，它的 prufer 编码就是$\texttt{125214}$  

![](https://pic.downk.cc/item/5e8a9d06504f4bcb04b1824d.png)  

这个 prufer 编码有一些很显然的性质  
首先长度肯定是$n-2$，但每个元素**可能相同**，然后对于每个无根树，它的 prufer 编码肯定也唯一    
如果编码的每个元素都相同，那么它可以是一个编号最大的点连向其它所有点（特殊的菊花图），如果都不同，可以是一个链  
当然，这里说“可以”是因为有可能还存在其它的构造方式  

那么，prufer 编码对应的树是否唯一？  
也就是说，每一个编码是不是只能求出唯一的树？  
是可以的，先给出求的方式：  
设这棵树点的集合为$V$，初始状态下$V=\{1,2,\cdots,n\}$  

- 每次找到编码最前面的一个点，在$V$中找到**不在编码序列中出现**的编号**最小**的点，连边，然后分别把他们在$V$中和编码中删掉  
- 显然，当编码被全部删掉后，$V$中还有两个元素，再把他们两个连边，结束  

然后验证一下刚才那个图，发现是正确的  

可以感性理解一下，编码序列的第一个数，就是我们第一次删除叶子节点以后添加的它的相邻节点，而这个被删掉的节点肯定不在编码中，它也是序号最小的，所以还原树的时候就要把它和它相邻的那个被添加到编码中的点连边  
然后每次都这样做就得出了原树  
又因为在找编码的时候最后剩了两个节点，那两个节点肯定是连在一起的，所以这就是为什么要把$V$中剩下的两个点连边  

所以，上面通过 prufer 编码求树的操作，也是唯一的  
那么可以得出一下更深入的性质：  

- prufer 编码和无根树**一一对应**  
- 对于有$n$个节点的**无根树**，有$n^{n-2}$种构造方式  
因为编码和树一一对应，所以长度为$n-2$，每一位有$n$种取值的编码的种类数是$n^{n-2}$，这个东西也叫做 Cayley 公式  
- 对于有$n$个节点的**有根树**，有$n^{n-1}$种构造方式，很显然，就是让每个节点轮流当根，然后运用上面那个式子  
- 度数为$k$的点，在 prufer 编码中出现的次数是$k-1$  
因为在$k-1$个点被删掉的时候，它被加入编码，此时度数为$1$，直接被删掉不会加入编码中  
- 对于给定$n$个点的度数分别是$k_1,k_2,\cdots,k_n$的有根树，有$\dfrac{(n-2)!}{\prod (k_i-1)!}$种构造方式  
问题即为求每个元素出现$k_i$次的排列个数，分子的$(n-2)!$是说，没有这个限制条件的全排列个数，分母上是去重，就是说如果相同的元素交换位置应该算一种方案，所以要除以它的阶乘  
- 上面那个性质再扩展一下，假设有$cnt$个点对度数有要求，其它的没要求，设$sum=\sum_{i=1}^{cnt}k_i$，则方式有：  
$\tbinom{n-2}{sum}\frac{sum!}{\prod_{i=1}^{cnt}(k_i-1)!}\times (n-cnt)^{n-2-sum}$  
解释一下什么意思，那个组合数就是从$n-2$个数里面算出$sum$个，然后对这$sum$个用上一条性质的公式，然后还有$n-2-sum$个位置可以任意排列剩下的$n-cnt$个点，所以得出上面式子  


应该没有了，如果有大佬知道其它性质欢迎在评论区给出  

-------------  

[P4981 父子](https://www.luogu.com.cn/problem/P4981)  
然后看这个题，显然就是要求$n$个点的有根树个数，直接输出$n^{n-1}$就行  

```cpp  
#include<cstdio>
#include<algorithm>
#include<iostream>
#include<cmath>
#include<iomanip>
#include<cstring>
#define reg register
#define EN std::puts("")
#define LL long long
inline int read(){
	register int x=0;register int y=1;
	register char c=std::getchar();
	while(c<'0'||c>'9'){if(c=='-') y=0;c=std::getchar();}
	while(c>='0'&&c<='9'){x=x*10+(c^48);c=std::getchar();}
	return y?x:-x;
}
inline LL power(LL a,LL b,LL mod){
	LL ret=1;
	while(b){
		if(b&1) ret=ret*a%mod;
		a=a*a%mod;b>>=1;
	}
	return ret;
}
int main(){int T=read();while(T--){
	int n=read();
	std::printf("%lld\n",power(n,n-1,1e9+9));
}
	return 0;
}
```