## 这道题还是很简单的，只要你了解一个公式就很好推导

首先我们需要理解题意，大致意思就是：给你一个$ n$个节点，求出有多少种不同的有根树。

---
既然我们已经知道了题意，那么就来分析一下。

有人的第一反应是求卡特兰数。
** 注：这个是错的，你应该去重新看一看卡特兰数的性质和应用**

---

好了我们来讲一下正解

我们需要用到$ Cayley$公式：
$Cayley$公式的定义是这样的，对于$n $个不同的节点，能够组成的**无根树**（原来是无向连通图或者是有标志节点的树）的种数是$n^{n-2}$种。（这里让大家好理解一点，就写成了无根树，其实应该是一样的概念）

### 证明的话我就不证明了，我做这道题的时候也就只是知道这个公式

----
那么我们的初步问题就解决了，接下来就是解决无根树和有根树之间的转换。

但是转换很难吗？把有根树转换成根节点有$n$种情况的无根树，也就是$ n^{n-2}\times n$，化简就是$n^{n-1}$。答案也就是这个玩意了。

因为这道题，$n$比较大，所以就用一下快速幂。

---
## 以下是AC代码
```cpp
#include <bits/stdc++.h>
using namespace std;

typedef long long LL;
const LL Mod=1e9+9;
LL power(LL n,LL m,LL p) {
    LL ret=1;
    while (m) {
        if (m&1) ret=(ret*n)%Mod;
        n=(n*n)%Mod;
        m>>=1;
    }
    return ret;
}
int main() {
    int cas; scanf("%d",&cas);
    while(cas--) {
        LL n;
        scanf("%lld",&n);
        printf("%lld\n",power(n,n-1,Mod));
    }
    return 0;
}

```