# 纯记忆化搜索

~~菜鸡写给新手看的~~

本蒟蒻表示不会什么Tarjan缩点；只会打打暴搜；~~(本蒟蒻自己写出的第一道蓝题）.~~

 **暴搜思路：**

- 首先这道题的图是一条带环的链（可能是不连通的，但这点在代码实现的时候可以不考虑），那就先构造出这条链，然后再在链里dfs；
- 一个环里的隔间能够到达的隔间总数是相同的，是等于这个环里的结点个数的；找环可以在dfs的过程中找，具体如何操作看代码；
- 如果这个结点不属于任何一个环，那它能去到的总隔间数会等于它去到的下一个隔间能去到的隔间数加1；
------------
**思路有了，你可以先去试试自己完善代码，如果还不行，那再看下面的代码也不迟；**

**代码+实现过程：**~~本蒟蒻代码能力不强，可能还可以优化，如果可以还请评论告诉我~~
```cpp
#include<iostream>
#include<cstring>
using namespace std;
bool c[100004],h[100004];//dfs遍历中c数组判断是否遍历过；h判断这个结点是否在环里 
int father[100004];//下一个隔间 ； 
int n;
int d[100005];//最终答案； 
void dfs(int x)
{
	if(c[x]){//当dfs遇到经过的结点时，从这个结点开始往后一定会构成一个环；为什么呢，可以想象当一个像一个6一样的图，从头部开始dfs，那当你遇到第一个走过的点时，那就代表你能从这个点走回这个点，那不就是一个环吗； 
		int t=x,k=1;
		x=father[x];
		while(x!=t){//记录结点数，存环； 
			k++;
			h[x]=1;
			x=father[x];
		}
		h[x]=1;//代码冗杂部分，哪位大佬可以解决一下；（其实就是懒，不想改了）； 
		d[x]=k;
		x=father[x];
		while(x!=t){//存答案； 
			d[x]=k;
			x=father[x];
		}
		return;
	}
	if(d[x]){//下一个点遍历过，那就返回；为什么不直接用c数组呢？因为下面数组归零了；那为什么要归零呢？ 因为我们判环是用的c，如果c不归零，那就会出现错判环；所以这里我们用d的值是否改变过来判断； 
		return;
	}
	c[x]=true;
	dfs(father[x]);
	if(!h[x]){//如果不是在环里的，那他能到的总隔间数就会等于它能去到的下一个隔间能去到的隔间数加1； 
		d[x]=d[father[x]]+1;
	}
	return;
}
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>father[i];
	}
	for(int i=1;i<=n;i++){
		memset(c,0,sizeof(c));//c归零，dfs里解释了为什么； 
		if(!d[i])//要不要都无所谓； 
		dfs(i);
	}
	for(int i=1;i<=n;i++){
		cout<<d[i]<<endl;
	}
	return 0;
}
```


------------
题解只是提供个思路，在代码实现这方面还是要靠自己，所以当你下次看题解的时候不妨就只看思路，再自己实现代码，这样可能对你提升你的代码能力会更加有所帮助；