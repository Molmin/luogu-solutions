# P2921 在农场万圣节 题解
## 并查集 题解
### 然发现题解都是$Tarjan$ ~~而本人并不会写（这就是这篇题解的来历）~~
附赠并查集模板题：[[模板]并查集](https://www.luogu.org/problemnew/show/P3367)

Part 1：题目分析
------------

- 看到这个题目，每个房间都会对应一个所要去的房间，说明**这是一张有向图，我们也可以理解成一片带环的森林**。既然这里说到了环，那么很自然地想到$Tarjan$，**但是，并查集不也是可以求环的吗？**

并查集可以硬套，但是我们需要另开一个数组记录这个节点的父节点，这样，在我们找到环之后我们就可以原样退回，依次赋值。

**因为在一个环上的房间走一圈经过的房间数是一样的！**

那么为什么要另外记录父节点？因为我们**路径压缩**了，这样**每个点全部指向根节点，我们就回不去了**。


Part 2：问题解决
------------

### 解决环

搜索环就很简单了，那么环上还有一些支链怎么解决呢？我们画图会发现，对于一个节点只有两种情况：
1. **在环上**
1. **在通向环的路上**

那么如果我们把环的大小定义为环上的节点数，**那么：**

**定理一**：**链上各点走到有走过的点所经过的节点数就都等于环的大小**

**定理二**：**链上各点走到有走过的点所经过的节点数就等于该节点到环上的距离+环的大小**

所以我们对每个节点全部加入并查集走一遍，并且这种方法是在线的，我们不需要储存数据：

```cpp
  //f存储在哪个集合，fa存储父节点，并查集操作是对f的操作
  //i是循环变量，当前到第i个房间，走到第m个房间
  //并查集别忘了数组初始化
    int m;
    scanf("%d",&m);
    Find(m,i);
    
  int Get(int x) {
    if(x==f[x]) return x;
    return f[x]=Get(f[x]);
  }
  void Find(int p,int q) {
    if(Get(p)==Get(q)) {//找到环了
      int cnt=1;//最后会少一个，这里初值设为1
      //回退
      for(int i=p;i!=q;i=fa[i]) cnt++;//累加环的长度
      for(int i=p;i!=q;i=fa[i]) E[i]=cnt;
      //定理一
      E[q]=cnt;
      return;
      //E数组是答案数组
    }
    //没找到环
    //并查集集合合并，可以写成merge函数形式
    //值得注意的是，这里是以当前房间为父节点合并的
    f[Get(q)]=Get(p);
    fa[q]=p; //记录父节点
    /*
    merge函数：
    void merge(int x,int y) {
      f[get(x)]=get(y);
    }
    */
  }
```
这里作个解释，为什么Get(p)==Get(q)就是找到环了？首先，这个算法是在线的，一开始$f[i]$的初始值都为$i$，那么如果$i$(第$i$个房间)，$x$(要去的房间)指向同一个祖先，那就说明$i$与$x$在同一个集合内，这里的集合指什么？就是我们所说的环，因此并查集可以解决环的问题。

**这就是并查集：查询元素是否在同一个集合内，并且支持将两个元素同时放到一个集合内。**

### 环解决完了，下面需要解决链

**我们在解决环的时候，已经把环上的点都赋予了答案，那么剩下没答案的就是链了**。因此我们只需要用$O(n)$的时间找一下还有那些没答案的，再用一个循环找到它到所在环的距离就行了。总复杂度大概$O(2n)?$

```cpp
  for(int i=1;i<=n;i++) {
    if(!E[i]) {//找到链，处理链上的节点
      int cnt=1,j;
      for(j=fa[i];!E[j];j=fa[j]) cnt++;
      //同理，链的长度
      E[i]=cnt+E[j];
    }
    //输出答案
    printf("%d\n",E[i]);
  }
```
不理解的话我还特意给了张图(~~感谢几何画板的支持~~)：
![](https://i.loli.net/2019/06/05/5cf79a0d7a28114585.jpg)

Part 3：AC
------------

好了，上面已经解决完本题了，别忘了**并查集初始化**：

```cpp
  for(int i=1;i<=n;i++) f[i]=i;
```
下面整理一下关键代码片段：

**数组、定义交代：**
```cpp
  int E[SIZE],f[SIZE],fa[SIZE];
  //E答案数组，f并查集数组，fa父节点数组
```


**1. 并查集部分：**

```cpp
  int get(int x) {
    if(x==f[x]) return x;
    return f[x]=get(f[x]);
  }
  int merge(int x,int y) {
    f[get(x)]=get(y);
  }
```
**2. 找环：**

```
  for(int i=1;i<=n;i++) {
    int m;
    scanf("%d",&m);
    Find(m,i);
  }
  //函数位置自己看着办
  void Find(int p,int q) {
  if(get(p)==get(q)) {//找到环
    int cnt=1;
    for(int i=p;i!=q;i=fa[i]) cnt++; //找环的长度
    for(int i=p;i!=q;i=fa[i]) E[i]=cnt;
    E[q]=cnt;
    return;
  }
  //没找到，合并
  merge(q,p);
  fa[q]=p;
}
```
**3. 找链&输出答案：**

```cpp
  for(int i=1;i<=n;i++) {
    if(!E[i]) {
      int cnt=1,j;
      for(j=fa[i];!E[j];j=fa[j]) cnt++;
      //找链的长度
      E[i]=cnt+E[j];
    }
    printf("%d\n",E[i]);
  }
```
**4. $End$**

```cpp
  return 0;//比赛忘了写后果自负
```
~~剩下部分自己补充了，有问题私聊~~


$END$
------------

## 最后祝大家$NOIP2019 RP++$

（~~这样可以点赞了吧？~~）
