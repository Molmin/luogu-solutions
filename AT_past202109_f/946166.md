# [题目传送门](https://www.luogu.com.cn/problem/AT_past202109_f)

# 题目分析
构造一个数列，使字符串中字符```'1'```的位置在数列中下标等于里面的数，字符串中的字符```'0'```的位置在数列中下标不等于里面的数。所以可以预处理时把字符串中所有的```'1'```的位置先填上数，然后处理```'0'```的位置。考虑分几类讨论：

- 若```'0'```的个数为 $1$，那么```'0'```所在的位置一定下标和数一样，因为只能填一个数了，也就是下标的数。因此直接输出 $-1$。
- 若没有```'0'```，那么直接按从 $1$ 到 $n$ 的顺序输出下标即可。
- 若```'0'```的个数为偶数，那么可以把相邻的两个```'0'```进行处理：第一个```'0'```的下标为第二个```'0'```的数，第二个```'0'```的下标为第一个```'0'```的数，也就是交换，可以保证没有一个```'0'```的下标与数相等。
- 若```'0'```的个数为奇数，那么可以先对前三个```'0'```进行处理：把第一个```'0'```的下标作为第二个```'0'```的数，第二个```'0'```的下标是第三个```'0'```的数，第三个```'0'```的下标是第一个```'0'```的数，后面的```'0'```的个数一定是偶数，按照偶数的处理方式处理即可。

# 代码
```cpp
#include<iostream>
#include<algorithm>
using namespace std;
int main(){
	int n,a[100001]={0},b[100001]={0},ans=0,h=0;
	cin>>n;
	char c[100001];
	cin>>c;
	for(int i=0;i<n;i++){
		if(c[i]=='1'){
			a[i+1]=i+1;
		}
		else{
			ans++;
			b[h++]=i+1;
		}
	}
	if(ans==1){
		cout<<-1<<endl;
		return 0;
	}
	if(ans==0){
		for(int i=0;i<n;i++){
			cout<<i+1<<" ";
		}
		return 0;
	}
	sort(b,b+h);
	if(ans%2==0){
		for(int i=0;i<h;i+=2){
			a[b[i]]=b[i+1];
			a[b[i+1]]=b[i];
		}
		for(int i=1;i<=n;i++){
			cout<<a[i]<<" ";
		}
		return 0;
	}
	a[b[0]]=b[1];
	a[b[1]]=b[2];
	a[b[2]]=b[0];
	for(int i=3;i<h;i+=2){
		a[b[i]]=b[i+1];
		a[b[i+1]]=b[i];
	}
	for(int i=1;i<=n;i++){
		cout<<a[i]<<" ";
	}
	return 0;
}
```
