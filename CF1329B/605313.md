# CF1329B Solution
这篇题解计算方法和别的题解有点不同。
### 题目描述
Dreamoon 非常喜欢数列。因此他出了一道数列问题，保证你在 OEIS 上找不到它。

有两个整数 $d, m$，找到这样的数列 $a$ 的数列，满足以下限制条件：

- 数列 $a$ 的长度为 $n$，$n \ge 1$；
- $1 \le a_i \lt a_2 \lt \cdots \lt a_n \le d$；
- 定义一个长度为 $n$ 的数组 $b$：$b_1 = a_1$，$\forall i \ge 1, b_i  = b_{i - 1} \oplus a_i$，其中 $\oplus$ 表示二进制异或 (xor)。在构建出 $b$ 后，应当满足 $b_1 \lt b_2 \lt \cdots \lt b_{n - 1} \lt b_n$ 的限制条件。

由于满足条件的数列数量可能很多，请输出答案模 $m$ 的结果。
### Solution
容易发现，二进制的位数一定是单调递增的。而且异或前缀和单调递增，数列单调递增是二进制位数单调递增的**充要条件**。反证法可以轻松的证明出来。

那么 $n$ 的最大值就是 $\lfloor\log_2d\rfloor+1$。令 $k=\lfloor\log_2d\rfloor+1$。现在我去构造 $k$ 个数，第 $i$ 个数的二进制从左到右的首位是 $1$。令 $f_i$ 表示第 $i$ 个数有几种情况。

容易发现当 $i\ne k$ 时，$f_i=2^{i-1}$，因为后面的 $i-1$ 位可以任意取 $0$ 或 $1$。当 $i=k$ 时，$f_k=d-2^{k-1}+1$，因为这个数的后面 $k-1$ 位不可以随便取，可能会超过 $d$。对于 $f_k$，符合条件的数是 $[2^{k-1},d]$ 的所有数。

现在我可以从这 $k$ 个数中选取任意个数，这样选出来的数进行从小到大的排序就会自动生成一个符合条件的序列。它满足二进制位数严格单调递增，自然会满足这些性质。因为是充要条件，所以不会漏。设选出来的内部种类数是乘法原理，这些东西再利用加法原理相加。

设 $k=3$，那么答案就是 $f_1+f_2+f_3+f_1f_2+f_3f_1+f_2f_3+f_1f_2f_3$。现在要把 $3$ 拓展到 $\lfloor\log_2d\rfloor+1$，这个式子可以被快速求出。

考虑化简这个式子。每个数对答案的贡献要么是 $f_i$ 要么是 $1$（选或者不选），所以贡献是 $(f_i+1)$。直接相乘，减去全都没选的情况就行，即 $(f_1+1)(f_2+1)(f_3+1)\cdots(f_k+1)-1$。直接计算即可。
```cpp
void solve(){
    int n=read(),ans=1;
    mod=read();
    int mx=log2(n)+1;
    F(i,1,mx-1) f[i]=qpow(2,i-1);
    f[mx]=n-pow(2,mx-1)+1;
    F(i,1,mx) mulmod(ans,f[i]+1);
    addmod(ans,-1);
    printf("%lld\n",ans);
}
```