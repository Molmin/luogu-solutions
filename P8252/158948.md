数据没出，于是口胡线性做法没问题吧。（其实是从游记里面搬的）

先假装全都不能讨论发现是个包含树的关系，于是有了一个自然的想法：

判断给定关系是否形成包含树，并在判断失败的时候输出这两个点。

对每道题考虑，包含它的按长度排序，相同长度必须相同，否则形不成包含树。

然后长度相邻的两个点必定是父子关系，祖先关系都不行，只能有一个父亲的连边，先把边连上再去重即可。

然后暴力判父子是否包含，暴力遍历儿子长度相关的复杂度，于是 $\sum$ 起来还是 $O(m)$ 的。

但这样实现出来有排序，去重和 `map/unordered_map` 或二分来判断两个点是否包含，是 $O(m\log)$ 的，考虑更优秀的实现：

首先排序换成提前桶排，然后直接对相邻长度连边，看是否有父亲完全包含儿子。

去重也不用，只用保证每个点只走一次即可，同上只能有一个父亲，可以通过记录父亲是谁来判定。

直接从根往下做，对于每个点暴力遍历它有的元素判断全都是父亲的标记，表示被包含。

同时打标记上自己的标记，用于处理它自己的儿子，显然线性。

对于长度相同的在桶排时会自动按编号排序（意思是桶排是 stable 的）于是一定形成一条链，当成长度不同的正常判断即可。