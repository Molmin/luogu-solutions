提供两种~~不同于[官方题解](https://www.noi.cn/xw/2022-03-28/759692.shtml)的~~思路！

[题面](https://www.luogu.com.cn/problem/P8252)。

### 题意

有一场 $N$ 道题，$N$ 个人参加的模拟赛，给出每人会做的题目集合 $S_i$，问是否存在 $A,B$ 两人，他们会做的题的集合满足如下关系：

![](https://cdn.luogu.com.cn/upload/image_hosting/2cme3y3b.png)

### 思路

根据题意，若 $S_A,S_b$ 有交集且都不是对方的子集，那么 $A,B$ 一定构成一组合法解。大小为 $0$ 或 $1$ 的集合一定不会成为答案，所以可以在开始时将其剔除。

#### 一

首先我们将 $S$ 按照集合内元素个数从大到小排序并重新编号，然后记 $last_i$ 为当前上一个会做第 $i$ 题的人的编号。

对于第 $i$ 个人，遍历 $S_i$，如果 $S_i$ 中存在两道题 $x,y$ 的 $last$ 不同，则 $last_x$ 或 $last_y$ 中元素数较少的能与 $i$ 构成合法解；否则 $S_i$ 一定完全包含于此前某集合中，则再次遍历 $S_i$，将其中所有元素的 $last$ 的值都更新为 $i$。

因为已经将集合按照元素数排序，所以含元素多的集合必然先处理。且每次更新的 $last$ 都必然是覆盖已有某个集合的子集，则实质上维护了若干互不相交的小集合，若有集合跨越了此前两个不同集合，则有解。时间复杂度为 $O(T\times (n\log n + (n+m)))$

#### 二

我们可以先使用``vector``或链表记录第 $i$ 题会做人的集合 $B_i$，然后同样对 $S$ 按照大小排序。

每次取出当前剩下未判断的集合中元素最多的集合 $i$，然后将其中元素使用哈希或``set``维护出来。这时再次遍历 $S_i$，对于 $S_i$ 中的元素 $j$，遍历 $B_j$。若元素 $k \in B_j$ 且集合 $S_k$ 还未被判断过，则遍历 $S_{k}$，判断其中是否存在元素不属于 $S_i$。若不存在，则 $S_{k} \subseteq S_i$，不合法，对集合 $S_{k}$ 打上删除标记；否则 $i$ 与 $k$ 构成一组合法解。维护集合是否已判断可使用链表实现序列元素快速删除。

通过从遍历会做 $i$ 会做的某道题的人的集合，即遍历了所以尚未判断的与 $i$ 有交集的集合，保证了“有交集”这一条件；且每个集合最多被判断一次。用哈希实现，时间复杂度为 $O(T\times (n\log n + (n+m)))$。