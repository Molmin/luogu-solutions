# 思路
首先看下题意，地图的形状是两个矩形拼在一起且有一条边共线。题目保证sum(x)与地图面积相等。于是问题简化为：将地图分为面积为x[i]的n个联通块。
## 引理
非常容易想到的是，这样的问题是一定有解的；一种可行的填法是：先尽量将地图转化为简单图形（即将地图的一个“凸出”的块填满），于是易知剩下的解法。
## 建立模型
有了如上思路，我们可以简单地得到满足如下条件的构造方法：  
（1）各个分块相联通：按照“首尾相连”的顺序进行填充，一种字母填完后立即换成下一种字母继续填充；  
（2）对（1）的补充：为保证“首尾相连”的填法顺利进行，需要根据图形讨论起始点在图形左侧还是右侧（对x讨论，y的情况无需讨论，总可以从第一行开始）。
![](https://i.loli.net/2020/03/10/czRNdKuhlVAQi5P.png)   
观察该图并进行手算后得知，分类讨论情况如下:  
####  b > d  
<i> d % 2 == 0  
从最左侧开始(即x = 1)  
<ii> d % 2 != 0  
从最右侧开始(即x = a + c)  
####  b < d(可看作上一种情况的镜像)
<i> d % 2 != 0  
从最左侧开始(即x = 1)  
<ii> d % 2 == 0  
从最右侧开始(即x = a + c)  
  
显然，从最左侧开始时，初始方向向右；从最右侧开始时，初始方向向左。
# 实现
首先依以上结论得出初始位置x, y及方向值dir(用1或-1表示）。我们还可以预处理出二维数组g来表示可以到达的点，方便后续操作。  
随后以dir为方向扫描整张图，出现越界时（利用g数组判断）将x回退，同时y ++，dir *= -1，即完成了“掉头”操作。  
输出时，依然依据g数组来确定是否有一个有意义的值，并输出。  
## 注意事项
本题总体较为简单，唯一的易错点在于二维数组的大小。注意a, b, c, d <= 50，故a + c <= 100，N需要取到100方可避免越界。  
代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;

const int N = 110;

int a, b, c, d, n, t;
bool g[N][N] = {0};
int dir, x, y;
char ans[N][N];

int main(){
	ios::sync_with_stdio(0);
	cin.tie(0); //读入优化，考场慎用 
	cin >> a >> b >> c >> d >> n;
	
	//预处理出g数组 
	for(int i = 1; i <= a; ++ i) for(int j = 1; j <= b; ++ j) g[i][j] = 1;
	for(int i = a + 1; i <= a + c; ++ i) for(int j = 1; j <= d; ++ j) g[i][j] = 1;
	
	//对x, y, dir进行讨论 
	if(b > d)
		if(d & 1) //注：d & 1 相当于 d % 2 
			x = a + c, y = 1, dir = - 1;
		else
			x = 1, y = 1, dir = 1;
	else
		if(b & 1)
			x = 1, y = 1, dir = 1;
		else
			x = a + c, y = 1, dir = -1; 
	
	//扫描填充 
	for(int i = 0; i < n; ++ i){
		cin >> t;
		while(t --){
			ans[x][y] = 'a' + i;
			x += dir;
			if(!g[x][y]){ //越界 
				x -= dir; //x回退一格 
				++ y; //进入下一行 
				dir = - dir; //掉头 
			}
		}
	}
	cout << "YES\n"; //一定存在解法 
	for(int i = 1; i <= max(b, d); ++ i){
		for(int j = 1; j <= a + c; ++ j)
			cout << (g[j][i] ? ans[j][i] : '.'); //根据g值判断是否存在有效值 
			//由于构建坐标系时(i, j)表示为先列后行，但输出时应先行后列，故写为ans[j][i]
		cout << endl;
	}
	
	return 0;
}
```
