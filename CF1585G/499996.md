~~话说怎么全网都没有这题的中文题解啊。~~  
想不到官方题解里一只 $\log$ 的神奇做法，所以我用树上启发式合并（dsu on tree）和线段树以 $\mathcal O(n \log^2 n)$ 的时间复杂度通过了此题 ~~同时喜提最优解最后一名~~。  

首先复习一下博弈论相关知识：
1. 一个公平游戏的一个状态的 $\operatorname {SG}$ 函数值为它能到达的所有状态的 $\operatorname {SG}$ 函数值中没出现过的最小非负整数（即 $\operatorname {mex}$ 值）。
2. 多个公平游戏组合在一起的 $\operatorname {SG}$ 函数值是其中所有游戏状态的 $\operatorname {SG}$ 函数值异或和。
3. 一个公平组合游戏先手必败当且仅当其初始状态 $\operatorname{SG}$ 函数值为 $0$。

那么这题就有了一个基本思路，即对每棵子树求出它删去一个深度以下的点剩下的子树的 $\operatorname {SG}$ 函数值的异或和的 $\operatorname {mex}$，最后再将森林中的所有树根的 $\operatorname {SG}$ 函数值异或在一起。

这个计算的过程要对子树询问，看上去很可以 dsu on tree，但是和 dsu on tree 的板子又有这些不同：

1. 需要维护的 $\operatorname {mex}$ 值不像和之类的那么好维护。
3. 询问一个点为根的子树不把根计入答案。
1. 空状态并不是树上的节点，但它的 $\operatorname {SG}$ 函数值（也就是 $0$）会对计算过程有影响。
2. 每次并不是要询问整棵子树，而只是对一个深度以上求解。


对于第一个问题，可以开一棵线段树来维护每个非负整数出现的次数，修改的时候先把原来的值删去，插入时加上，询问时线段树上二分。  
对于第二个问题和第三个问题，每次维护当前点以下的答案即可（不重新计算重儿子子树改为只计算重儿子上的值，而不进入子树中的其它点），同时每次加入一个 $0$ 表示新出现的一层的答案。  
对于最后一个问题，因为最小深度肯定是不断递减的，每次删除重儿子的深度限制和当前点的限制之间深度的答案就行了，注意 dsu on tree 加和清空的时候不要再 加/清空 这些点了。

这样这题就做完了。

cf 提交记录：[#153349274](https://codeforces.com/contest/1585/submission/153349274)
