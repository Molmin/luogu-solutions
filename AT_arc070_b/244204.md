之前的题解全都是 $O(NKlogN)$，我来氵一篇 $O(NK)$ 的，毕竟5000的数据范围多一个log多少还是有点危的。

------------

#### 题意：
给定一个大小为 $N$ 非负整数集合 $A$，一个元素和不小于 $K$ 的 $A$ 的非空子集被称为优秀的，问 $A$ 中有多少个元素满足把它改成0而不会影响优秀子集的个数。$N,K \leqslant 5000,1 \leqslant A_i \leqslant 10^9$。

------------

#### 思路：
我们先考虑什么样的元素能成为一个**不满足条件**的数（其实正着考虑也可以，难度差不多），即改变它后会影响优秀子集的个数。显然，我们肯定能找到一个包含该元素的优秀子集，满足它的和减去该元素小于 $K$。这样我们就得到了 $O(2^NN)$ 的做法，显然过不了，我们还需要进一步优化。

由于 $A_i$ 范围太大，没了它又不好做题，先考虑减小它的范围。对于大于 $K$ 的元素， 肯定不满足条件 ，先把它们踢出去，对于一个元素和大于 $2K$ 的子集，也可以不考虑，因为就算减去 $K$ 也比 $K$ 大，还是优秀的。

经过这样一通操作，现在我们要考虑的子集的元素和都和 $K$ 同级了，可以用**背包**求出来所有子集和它们对应的元素和。但是光有子集的元素和不够啊，想要求解答案仍需要继续分析。

我们发现，这个答案好像是有**单调性**的，假如元素 $x$ 不是答案，大于 $x$ 的所有数也不是答案。因为可以找到包含 $x$ 的原优秀子集 $S$，$x$ 变为0后它的元素和小于 $K$，把 $x$ 替换成任意大于它的元素，它前后“优秀性”的改变仍然是永恒的事实。

现在，我们只需要尝试对每个优秀子集找到最小的能使它变为不优秀的子集就好了。最正常的思路肯定是把子集元素排序后从小往大扫一遍。假如现在遍历到的第一个元素 $x$ （即子集的最小元素）并不能使 $S$ 变得不优秀，那么就算去掉它，$S$ 肯定也是一个优秀的子集，而且求出来的答案只会比原来的小，由单调性，这样是完全正确的。因此，我们只需要再保存一下每个子集的最小值就好了。

------------

#### 实现：

上面说了，要用背包求出所有子集，那么如何求出它们的最小值呢，我们考虑把 $A$ 从大到小排序，这样一个子集的最小值肯定是最后加入这个子集的元素。

考虑转移方程 $f(i,j) = f(i-1,j)\ or\ f(i,j-A_i)$。其中$f(i,j)$表示前 $i$ 个元素能否凑出元素和为 $j$ 的元素，是布尔值，$or$ 是逻辑或。

同时开一个$2K \times N$ 的二维辅助数组 $g$，$g_i$ 存的是所有元素和为 $i$ 的子集的最小值对应下标。如果转移时 $f(i,j-A_i) = true$，我们就往 $g_j$ 里压入一个 $i$。这里我们相当于把很多最小值，元素和都相同的子集当成一个子集，于是子集数量就变成 $NK$ 级别的了。

然后我们遍历一下从 $K$ 到 $2K$ 的 $g$ 里的下标，打上标记，最后看一下哪些元素自身和前面的所有元素都没有标记，统计答案就做完了。实际上你可以在dp的时候就给元素打标记，并不需要 $g$。

下面是代码，由于比较短就没加多少注释。
```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <functional>
const int N = 5005;
int n, k, a[N]; 
bool f[N*2], can[N]; 
int main(void)
{
	scanf("%d%d", &n, &k);
	for(int i = 1;i <= n;++i)
		scanf("%d", a+i);
	std::sort(a+1, a+1+n, std::greater<int>());
	//这里是把a从大到小排序，懒得写cmp了 
	f[0] = 1;
	for(int i = 1;i <= n;++i)
		if(a[i] < k)
			for(int j = k*2;j >= a[i];--j)
				if(f[j-a[i]])
				{
					f[j] = 1;
					if(j >= k && j-a[i] < k)//如果当前优秀子集去掉ai不优秀了就打上标记 
						can[i] = 1;
				} 
	int ans = 0;
	for(int i = n;i >= 1 && a[i] < k && !can[i];--i)//注意大于k的ai也不能计入答案 
		++ans;
	printf("%d\n", ans);
	return 0;
}
```