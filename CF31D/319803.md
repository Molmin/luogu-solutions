翻了一下题解，似乎暂时没有不用搜索过掉这题的，那我就来一篇吧。

------------

注意题目的这句话：

> 保证切完以后不存在只被切了一部分的巧克力。即对于任意一部分巧克力内部不存在刀口。

换句话说就是，保证切完之后分成的每个部分的巧克力都是一个完整的矩形，且内部不存在刀口。

所以，这题用不着搜索。

我们可以把这块巧克力抽象成一个 $H \times W$ 的格阵，然后开两个二维数组 $a,b$，$a_{i,j}$ 表示第 $(i,j)$ 个格子的下方是否有刀口，$b_{i,j}$ 表示第 $(i,j)$ 个格子的右方是否有刀口。存的方法很简单，输入每一刀的时候分两种情况遍历一下就可以了，不细说。

然后我们开一个二维数组 $c$ 表示一个格子有没有被遍历过，再从左上到右下同时遍历这两个二维数组，每次到一个新的格子，我们就向一个格子一个格子地在 $b$ 中向右找最近的刀口，找到之后再一个格子一个格子地在 $a$ 中向下找最近的刀口，都找到了，就可以确定我们正在遍历的这个部分的长、宽和位置了，再然后记录一下答案，再把这个矩阵里的所有格子都标记为遍历过即可。

最后给答案排一下序输出就完事了。

由于 $n,W,H \le 100$，且“保证切完之后分成的每个部分的巧克力都是一个完整的矩形，且内部不存在刀口”，这个解法一定是正确的。

但是，如果题目里没有做这个保证的话，我们就只能用搜索算答案了，因为你遍历到的刀口不一定能把你正在遍历的部分分成两块。

------------

```cpp
#include <bits/stdc++.h>
#define ll long long
#define ull unsigned long long
#define rnt register long long
using namespace std;
const ll N=107;
ll n,m,t,tot;
ll hang[N][N],lie[N][N],ans[N*N],bkt[N][N];
int main() {
	cin>>n>>m>>t;
	while (t--) {
		ll r1,r2,r3,r4;
		cin>>r1>>r2>>r3>>r4;
		if (r1==r3) { //分两种情况，第一种是沿着行切
			for (rnt i=r2+1;i<=r4;i++) hang[r1][i]=1; //标记上文中的 a 数组
		}
		else if (r2==r4) { //第二种是沿着列切
			for (rnt i=r1+1;i<=r3;i++) lie[i][r2]=1; //标记上文中的 b 数组
		}
	}
	for (rnt i=1;i<=n;i++) {
		for (rnt j=1;j<=m;j++) {
			if (!bkt[i][j]) { //如果这个格子没被遍历过
				ll r1=i,r2=j,r3=1,r4=1; //r1,r2 为遍历时使用变量，r3,r4 记录这个部分的长和宽
				while (lie[r1][r2]==0&&r2<m) r2++,r4++; //向右找
				while (hang[r1][r2]==0&&r1<n) r1++,r3++; //向下找
				for (rnt u=i;u<=r1;u++) {
					for (rnt v=j;v<=r2;v++) bkt[u][v]=1; //这个部分的格子全部做标记
				}
				ans[++tot]=r3*r4;
			}
		}
	}
	sort(ans+1,ans+tot+1);
	for (rnt i=1;i<=tot;i++) cout<<ans[i]<<" ";
	return 0;
} 
```