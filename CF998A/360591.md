### 看题
你需要输入一串数列，把这些数字分给两个人，使得这两个人获得的数字总和不一样。如果无法做到不一样，输出$-1$。

~~这是不是很容易做到！！！~~

### 分析
看到这道题，马上就可以 ~~偷懒~~ 想到思路：

**把最小的数分配给一个人，把其他的全部分给另外一个，不就满足条件了！**

**并且题面说至少分到一袋，如果像上面那么处理，第一行只要输出1就可以了，第二行只要输出这个数列中最小数字的地址就好了！**

那么第一步我们需要找到最小的数字：
```cpp
for(int i=1;i<=n;i++){
		cin>>a[i];
		minn=min(a[i],minn);
}
```
然后再查找一遍数列，如果查找到了最小的数字，存储地址。
```cpp
for(int i=1;i<=n;i++){
	if(minn==a[i]){
		存储地址的变量=i;
		break;
	}
}
```
但是数列**无法满足题意**就会输出```-1```，所以仅有这两个板块的程序是不够的，会导致程序错误。那么怎么判断无法满足题意的情况呢？

**当数列只有一个数字或者数列仅有的两个数字相等的时候无法满足题意！**

当只有一个数字的时候，无法把一个数字分给两个人；仅有的两个数字相等的话，每个人分到的数字必然是相同的！

那么漂亮的程序出来了！
```cpp
#include <iostream>
#include <algorithm>
using namespace std;
int a[10001];
int main(){
	int n,sum=0,minn=39204092;
	int minxia=0;
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
		minn=min(a[i],minn);
	}//查找最小的数字
	for(int i=1;i<=n;i++){
		if(minn==a[i]){
			minxia=i;
			break;
		}
	}//查找最小数字的地址
	if(n==1||n==2&&(a[1]==a[2])){
		cout<<"-1"<<endl;
	}else{//特判
		cout<<1<<endl;
		cout<<minxia<<endl;
	}
	return 0;
}
```