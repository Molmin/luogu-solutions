考虑容斥。称满足 $ b_i = b_{i + 1} (1 \leqslant i < n) $ 的 $ i $ 为关键点。则题意要求的是有 $ 0 $ 个关键点的 $ \{b_n\} $ 的数量。

容易发现

$$ \text{答案} = \text{至少有 } 0 \text{ 个关键点的答案} - \text{至少有 } 1 \text{ 个关键点的答案} + ... + (-1)^{n - 1} \text{至少有 } n - 1 \text{ 个关键点的答案} $$

观察发现长度为 $ n $，**至少**有 $ k $ 个关键点的一组 $ \{b_n\} $ 其实是将整个数组分成了连续 $ n - k $ 段，**每段的 $ b_i $ 一定相同**，但**相邻的两段的数可相同可不同**，这是容斥思想的核心。

定义 $ f_{i, 0/1} $ 为 $ b_1, ..., b_i $ 这一段排列，分成连续的偶数段 / 奇数段的方案数，其中每段 $ b_j $ 一定相同，相邻两段无要求。

则有

$$ \text{答案} = (-1)^{n}(f_{n, 0} - f_{n, 1}) $$

考虑如何转移。枚举 $ i $ 所在的一段的左端点 $ j $，可以得到

$$ f_{i, 0/1} = \sum_{j = 1}^i f_{j - 1, 1/0} (\min_{k = j}^i a_k) $$

$ \min_{k= j}^i a_k $ 的含义是 $ b_j, ..., b_i $ 这些数只能是同一个数，取值范围自然是这个区间中最小的 $ a_i $。

发现这样转移是 $ O(n^2) $ 的。考虑在 $ \min $ 的单调性上做优化。

维护一个 $ a_i $ 严格递增的单调栈。在做 $ f_{i, 0/1} $ 时，单调栈的栈顶应该是 $ i (a_i) $，设栈顶的下一位元素是 $ x (a_x) $。则有

$$ f_{i, 0/1} = f_{x, 0/1} + a_i \sum_{j = x + 1}^i f_{j - 1, 1/0} $$

解释：因为 $ a_x $ 是 $ i $ 往左走第一个比 $ a_i $ 大的数，所以转移方程中，$ j $ 取 $ 1 $ 到 $ x $ 的任何数，$ \min_{k = j}^i a_k $ 都与 $ \min_{k = j}^x a_k $ 相等。因此这些 $ j $ 对 $ f_{i, 0/1} $ 的贡献之和就等于 $ f_{x, 0/1} $。

而 $ a_{x + 1} $ 到 $ a_{i - 1} $ 的数都小于等于 $ a_i $。因此 $ j $ 取 $ x + 1 $ 到 $ i $ 的任何数，都有 $ \min_{k = j}^i a_k = a_i $。因此这些 $ j $ 对 $ f_{i, 0/1} $ 的贡献之和就是 $ a_i \sum\limits_{j = x + 1}^i f_{j - 1, 1/0} $。显然可以通过维护 $ f_{i, 0/1} $ 的前缀和快速计算。

注意栈中只有一个元素时，$ f_{i, 0/1} = a_i \sum\limits_{j = 1}^i f_{j - 1, 1/0} $。此时 $ a_i $ 大于 $ a_1 $ 到 $ a_{i - 1} $ 的所有数，也就不存在这样的 $ x $。

边界条件为 $ f_{0, 0} = 1, f_{0, 1} = 0 $。时间复杂度 $ \Theta(n) $。

~~看题解也就图一乐 真理解还得看代码~~

```cpp
#include <bits/stdc++.h>
using namespace std;
const int mod = 998244353;
typedef long long ll;
#define int ll
int a[200010], f[200010][2], s[200010][2];
int stk[200010], cnt = 0;
inline int p1(int x)
{
	return (x & 1) ? mod - 1 : 1;
}
signed main()
{
	int n;
	scanf("%lld", &n);
	for(int i = 1; i <= n; i++)
		scanf("%lld", &a[i]);
	f[0][0] = s[0][0] = 1, f[0][1] = s[0][1] = 0;
	stk[0] = 0;
	for(int i = 1; i <= n; i++)
	{
		while(cnt && a[stk[cnt]] >= a[i])
			cnt--;
		stk[++cnt] = i;
		f[i][0] = ((cnt == 1 ? 0 : f[stk[cnt - 1]][0]) + (s[i - 1][1] - (cnt == 1 ? 0 : s[stk[cnt - 1] - 1][1]) + mod) * a[i]) % mod;
		f[i][1] = ((cnt == 1 ? 0 : f[stk[cnt - 1]][1]) + (s[i - 1][0] - (cnt == 1 ? 0 : s[stk[cnt - 1] - 1][0]) + mod) * a[i]) % mod;
		s[i][0] = (s[i - 1][0] + f[i][0]) % mod;
		s[i][1] = (s[i - 1][1] + f[i][1]) % mod;
	}
	printf("%lld\n", (f[n][0] - f[n][1] + mod) * p1(n) % mod);
	return 0;
}

```