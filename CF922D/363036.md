## 前言
不得不说，作为某某机构 CSP-J 某一场模拟赛的第四题，这道题还是有点难度的（蒟蒻第一次写蓝题题解，如有不足请见谅）。

## 题目意思
题目翻译就是题目意思，没什么好讲的。

## 主要思路
本题主要算法是贪心。

这道题最难想的地方在于如何将**字符串排序**。如果想要**组成的字符串 $sh$ 子序列数量尽量大**，第一反应是让每个 $h$ 的前面有尽可能多的 $s$。但是，如果单纯地按照每个字符串前缀 $s$ 或者是后缀 $h$ 排序，并没有什么用处。

其实我们一开始的思路是对的。对字符串进一步观察，很容易就会发现以下几个点：
1. **无论怎么变换，每个字符串自己所作出的贡献是一样的**。
2. **如果考虑相邻两个字符串变换，对前后并没有影响。**
3. **如果要求两个字符串是否需要交换，只需比较他们交换前后所组成的 $sh$ 串数量即可。**

因此，排序规则（也就是贪心策略）就是按照**相邻两个字符串交换前后所组成的 $sh$ 串数量从大到小**排序。

现在，问题转化成如何**求出相邻两个字符串所组成的 $sh$ 串个数**。

对于每个字符串，我们先**预先求它 $s$ 的数量（$sum_s$）和 $h$ 的数量（$sum_h$）**。

接下来的步骤用文字不好说明，我举个例子让大家理解。

就用样例中其中两个字符串吧：``ssh``（设这个字符串为 $S_1$） 和 ``hs``（设这个字符串为 $S_2$）。

首先知道以下四个信息：

$S_1sum_s = 2$，$S_1sum_h = 1$；

$S_2sum_s = 1$，$S_2sum_h = 1$。

- 如果组成的字符串为 ``sshhs``，那么两个字符串之间组成的 $sh$ 串数量应该是 $S_1sum_s\times S_2sum_h=2$（**前面 $s$ 数量 $\times$ 后面 $h$ 数量**）。
- 如果组成的字符串为 ``hsssh``，那么两个字符串之间组成的 $sh$ 串数量应该是 $S_2sum_s\times S_1sum_h=1$（同理）。

看完这个这例子，相信大家都懂了吧？

 ~~懂了，但是没有完全懂！~~

相信有部分 OIer 会问：如果这样算，那字符串自己的子序列数量不就被忽略了吗？

我在前面说过，**无论怎么变换，每个字符串自己所作出的贡献是一样的**。我们**只需要比较交换前后横跨两个字符串的子序列数量**。至于自己本身的子序列数量，就无关紧要了。

现在，我们已经确定好了字符串的顺序，拼好了那个字符串。接下来，就是统计这个新的字符串到底有多少个子序列了。

这里有个小技巧：先**求出整个字符串 $h$ 的数量（$cnth$），每遇见一个 $s$ 就将答案加上 $cnth$，如果当前是个 $h$，则 $cnth-1$。这样就能 $O(n)$ 求出子序列数量了。**

## 一些小坑
- 交换顺序时，记得把字符串也交换位置（推荐用结构体，结构体里面存一个字符串，$sum_s$ 和 $sum_h$）。
- 五年 OI 一场空，不开 ``long long`` 见祖宗。

## 代码
以下是参考代码。珍爱生命，远离抄袭。

Code：
```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;

const int N = 100000 + 10;
ll n, lens, cnts, cnth, ans;
struct sstring{
	string s;
	ll sums, sumh;
} str[N];//结构体
string anss;

bool cmp(sstring x, sstring y){return x.sums * y.sumh > x.sumh * y.sums;}//排序规则

int main(){
	cin >> n;
	for(int i=1;i<=n;i++){
		cin >> str[i].s;
		for(int j=0;j<str[i].s.length();j++)	if(str[i].s[j] == 's')	str[i].sums++;
		for(int j=0;j<str[i].s.length();j++)	if(str[i].s[j] == 'h')	str[i].sumh++;
		//预处理求出每个字符串 s, h 的数量 
	}
	sort(str + 1, str + 1 + n, cmp);
	for(int i=1;i<=n;i++){
		anss += str[i].s;//最终字符串
		cnth += str[i].sumh;//事先求出 h 的数量
	}
	lens = anss.length();
	for(int i=0;i<lens;i++){//巧妙的思想 
		if(anss[i] == 's')	ans += cnth;//如果遇到一个s，加上后面h的数量（一定正确） 
		if(anss[i] == 'h')	cnth--;//因为如果遇到在s前面的h，就被减掉了，不重不漏 
		if(cnth == 0)	break; //一个小优化
	}
	cout << ans << endl;
	return 0;
}
```
本篇题解到此结束，如果对你有帮助，别忘了点个赞哦！