> [题目传送门](https://www.luogu.com.cn/problem/CF1553D)。
>
> 题意简述：给定 $s,t$，现在要依次输入 $s$ 中的字符。对于每个字符 $s_i$，你可以选择输入 $s_i$ 或者使用退格键，判断是否能得到 $t$。

不妨将字符串反过来贪心考虑：设 $i=|s|$，$p=|t|$。

- 如果 $s_i=t_p$，那么显然选择输入这个字符，$p\gets p-1$，$i\gets i-1$。
- 否则只能退格，不输入 $s_i$ 并删除 $s_{i-1}$，所以 $i\gets i-2$。

若 $p=0$ 则能得到 $t$，反之则不行。

也许有人会问，如果 $s_{i-1}$ 也是退格怎么办？实际上**若干个连续的退格等价于若干个不连续的退格：**不妨设 $s_{i-1}$ 的退格删了 $s_j$，而 $s_i$ 的退格删了 $s_k$，显然有 $k<j$。也就是说 $s_{k+1}\sim s_{j-1}$ 以及 $s_{j+1}\sim s_{i-2}$ 全部被删掉了。因此它等价于在 $s_j$ 处**不输入而选择使用退格删除输入的 $s_k$**，在 $s_i$ 出不输入而选择使用退格删除输入的 $s_{i-1}$。若 $k+1=j$，那么刚好是我们想要的；而如果 $k,j$ 不连续，那么可以递归证明下去。所以我们可以认为**每次退格删除的必定是该位置的前一个字符**，贪心算法的正确性就得到了证明。

```cpp
#include <bits/stdc++.h>
using namespace std;

int main(){
	int T=1; cin>>T;
	while(T--){
		string s,t; cin>>s>>t;
		int p=t.size()-1;
		for(int i=s.size()-1;i>=0;i--)~p&&s[i]==t[p]?p--:i--;
		puts(~p?"NO":"YES");
	}
	return 0;
}
```