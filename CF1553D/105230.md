> [CF1553D](https://www.luogu.com.cn/problem/CF1553D)
>
> 给定两个字符串 $s,t$，你可以逐字符键入字符串 $s$。
> 
> 在键入过程中，你可以选择不键入当前字符，而是删去前面的一个字符，例如当 $s =$ `abcbd` 时，当你键入到字符 `c` 时选择删除，后面正常键入，则最后得到的字符串就为 `abd`
> 
> 特别地，当你选择删去的这个字符前没有字符时，只会令当前的字符不出现而已。
> 
> 现在请问对于 $s$ ，是否可以经过若干次删除（或者不删除）得到 $t$
> 
> $|s|,|t| \leq 2\times 10 ^5$

<!-- more -->

## 解题思路：

比较巧妙的贪心。 

删除的操作我们可以直接考虑为删掉两个相邻的字母。

首先我们考虑两个在 $t$ 中相邻的字符在 $s$ 中满足什么条件，观察到我们不论按照什么顺序删除，实际上都是与相邻的两个一起删除是等价的。

举个例子。如字符串 `abcdef`，我们先删除 `cd`，然后在 `e` 处按下删除键，删除了 `be`。这两个操作等价于删除 `bc` 再删除 `de`。所以我们可以得出一个重要条件：**两个在 $t$ 中相邻的字符在 $s$ 中间隔的字母数必定为偶数**。正确性显然。

接下来，我们考虑怎么去在 $s$ 中匹配这样的一个 $t$ 出来。暴力的思路是枚举每个 $s_i = t_1$ 的 $i$，但这样的程序会被形如 `aaaaa...` 的数据 hack 掉。所以我们考虑能不能只对 $t$ 中的每个字符匹配一次？

结论是可以的，例如这个串：`abacabe`，我们的文本串为 `abe`，那么我们实际上选哪个 `a` 作为开头都是等价的，因为我们对于每个 `a` 开头我们都需要找到对应的 `b`，基于贪心的思想，我们直接找我们能够找到的第一个 `a` 把它与文本串中的 `a` 匹配上。如果失配了，很简单，我们只需要移除 $s_i$ 与 $s_{i+1}$ 就行了（为了满足重要条件）

最后，考虑到匹配的最后一个位置到末尾实际上也是需要偶数个位置的，我们不妨调整一下开始匹配的位置，若 $(n-m)\bmod 2 = 0$，两串长度奇偶性相同，我们直接从第一个位置开始匹配即可，否则奇偶性不相同，我们从第二个位置开始匹配。

时间复杂度 $O(n)$

## 代码：

```cpp
void solve() {
    scanf("%s",s+1);
	scanf("%s",t+1);
	int n = strlen(s+1),m = strlen(t+1);
	if (m > n) {
		puts("NO");
		return ;
	}
	
	if (m == 1)  {
		bool flag = 0;
		for (int i = 1;i <= n;++i) {
			if (s[i] != t[m]) continue;
			if ((n - i) % 2 == 0) {
				flag = 1;
				break;
			}
		}
		if (flag) puts("YES");
		else puts("NO");
		return ;
	}
	bool fail = 0;
	int pos = 1;
	for (int i = (n-m) % 2 + 1;i <= n;++i) {
		if (fail) {fail = 0;continue;}
		if (s[i] == t[pos] && pos <= m) ++pos;
		else fail = 1;
	} 
	if (pos > m) puts("YES");
	else puts("NO");
}
```