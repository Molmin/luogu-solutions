~~这道题主要还是使用了小学数学-被九整除的数的性质-各位数字之和为9的倍数，同时还要保证末尾有一个零（能被90整除）但是本题貌似数据水，不用考虑末尾0就可以过。~~
```cpp
/*
P2192
本题思路如下：
先考虑是否有9个5能构成一个被9整除的数，若没有，则不可能，输出-1
把0最后考虑，这样能保证得出的数最大。（先放5后放0准没错)
最后先把9的倍数个"5"输出后再尽量多输出"0"，便完成了
*/
#include<bits/stdc++.h>
using namespace std;
const int MAXN = 1010;
int n,a[MAXN],num_f;//num_f表示这一串数中5的个数
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		scanf("%d",&a[i]);
		if(a[i]==5) num_f++;//统计5的个数
	}
	if(num_f<=9&&n-num_f==0){//这里注意，虽然这道题改成num_f<9也可以过，但是严谨地，还是要用num_f<=9,因为这样可以保证它不会只被9整除，而不被10整除(即保证至少有一个0在最后）
		puts("-1");
		return 0;//特判：如果5的个数没有超过9个，并且没有0，则输出-1
	}
	for(int i=1;i<=num_f-num_f%9;i++) printf("5");//先输出5
	if(num_f>=9) for(int i=1;i<=n-num_f;i++) printf("0");
	else printf("0");//如果前面没有5，就输出一个0，否则输出多个0，多多益善
	printf("\n");//行末换行
	return 0;
}
```
