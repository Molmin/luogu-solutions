## 题意：

给你一个序列，现可对它执行若干次操作，每一次操作可以把一个区间里的数乘 $-1$。

现在问数列和的最大值与达到这个最大值所需要的最少的操作次数。

## 题解：
贪心。

第一问是简单的，因为最优就是全非负数。输出序列绝对值之和即可。

接下来解决第二问。

不难发现，如果有几个负数是连续排列的，就可以用一次操作把他们全变成非负数，所以不断的找全是负数的区间，最后输出区间数即可。

证明：

假设有 $n$ 个负数区间，则有 $n-1$ 个非负数区间把它们隔开。而如果先对这整个区间进行一次操作的话，总操作次数为 $n-1+1=n$ 次，并没有比直接对负数区间进行操作更优。

所以贪心策略正确。

注意，要开 `long long`。

## 代码：
```
#include <bits/stdc++.h>
using namespace std;
#define int long long
int n , a[1000005];
signed main() {
	int t;
	cin >> t;
	while(t--){
		cin >> n;
		int ans = 0 , cnt = 0;
		for(int i = 1;i <= n;i++){
			cin >> a[i];
			ans += abs(a[i]);
		}
		a[0] = 114514;
		for(int i = 1;i <= n;i++){
			if(a[i] < 0){
				cnt++;
				while(a[i] <= 0 && i <= n) i++;
			}
		}
		cout << ans << ' ' << cnt << endl;
	}
	return 0;
}
```
