题意简述：

今天 Alex 得到了长度为 $n$ 的数组 $a_1,a_2,…,a_n$。他可以应用任意多的操作（包括零操作）来改变数组的元素。

在 $1$ 的操作中，Alex 可以选择任何 $l$ 和 $r$，使得 $1≤l≤r≤n$，并将数组中从 $l$ 到 $r$ 的所有元素乘以 $−1$。

Alex 上学要迟到了，所以你应该帮助他找到数组中数字的最大可能之和，这个数字可以通过进行任何数量的运算得到，以及为此必须进行的最小运算数量。

分析：

第一问是在求经过一系列的操作后，最大可能的和。那么我们想，只要把所有的负数都通过操作 $1$ 变成正数，以此来相加。

第二问是在求最大的和下，最少的操作次数。那我们只要在每一次操作时选择尽量多的负数和零（零不影响结果），即求元素为负数的最长连续子序列的数量。

附代码：

```cpp
#include <bits/stdc++.h>
#define int long long //记得开longlong
using namespace std;
int T,n,x;
signed main()
{
	cin>>T;
	while(T--)//T组数据
	{
		int daan1=0,daan2=0;
		bool p=0;
		cin>>n;
		for(int i=1;i<=n;i++)
		{
			cin>>x;
			daan1+=abs(x);//第一问
			if(x<0&&!p) p=1,daan2++;//如果这是新的连续负数子序列的第一个，那么第二问答案+1，p标记为1
			else if(x>0) p=0;//如果为正数，那么说明一个负数序列结束了，p标记为0
		}
		
		cout<<daan1<<" "<<daan2<<"\n";
	}
	return 0;
}
```
