### 题目大意:

给你一个~~绳子~~(谷歌生草机翻译的)字符串，你需要对它进行一定操作使它变成回文串（字符串下标从1到n）。

一共有两种操作：

- ``L i``选择把子串$s_2,s_3,...s_i$翻转（变成一个形如$s_i,s_{i-1},...s_2$，$2≤i≤n-1$）并反向追加（放到）到字符串最前面（原字符串保持不变）。

- ``R i``选择把子串$s_i,s_{i+1},...s_{n-1}$翻转（翻转方法同上，$2≤i≤n-1$）并追加到字符串最后面（原字符串保持不变）。

输出**任意一种**方案的操作次数和具体方法，采用SPJ。

### 解法：

看样例我们可以~~很轻易地~~得到一个通用方法：

把第二个字符进行第一种操作，得到字符串$s_2,s_1,s_2,...s_n$，长度为$n+1$；

然后把$s_1$到$s_n$进行第二种操作，得到字符串$s_2,s_1,s_2,...s_n,s_{n-1},..s_2,s_1$，长度为$n+(n-2)+1=n*2-1$；

最后把倒数第二个字符进行第二种操作，得到字符串$s_2,s_1,s_2,...s_n,s_{n-1},..s_2,s_1,s_2$，长度为$n*2-1+1=n*2$；

总结一下就是一下3步：

```L 2```

```R 2```

```R n*2-1```

因为是SPJ，~~可以为所欲为~~，只要输出一种可行方法就行，不必最优

所以代码可以很短：

```
#include<bits/stdc++.h>
#define int long long
using namespace std;
char a[20001000];
signed main()
{ 
	cin>>a;
	int n=strlen(a);
	cout<<3<<endl<<"L "<<2<<endl<<"R "<<2<<endl<<"R "<<2*n-1;
}
```