## 题目大意：

有一只海龟，初始在数轴上 $0$ 的位置，再给定一个序列。

海龟会一步一步的执行，如果当前是 `F`，则他会往前走一步。如果当前是 `T`，则它会转 $180 \degree$。

你必须精确的修改 $k$ 步，但每一个位置可以多次修改，问海龟最远能走多远（正方向）。

## 解题思路：

很明显是 dp 了。设 $dp_{i,j,0/1}$ 为前 $i$ 个命令，修改 $j$ 个，最后方向是 $0/1$ 时的最远距离。

~~然后随便搞搞就好了~~。

由于单个命令可以改多次，所以要再枚举一重 $w$，既为当前命令花几次操作来改变。

倘若在更改完之后为 `F`，那么就按照当前方向走一步，否则改变当前方向。

注意这里要求严格改 $k$ 次，所以在 $i=1$ 的时候 $w$ 一定要从 $j$ 开始。

否则如果第一个命令改 $w$ 次，但命令个数有 $j$ 个，就会变成第 $0$ 个命令改变 $j-w$ 次。

显然，这样的情况会使得最后不是精确 $k$ 次。

## AC代码：

```cpp
#include<iostream>
using namespace std;
int k, dp[105][105][2];
string s;
int main()
{
	cin >> s >> k;
	for (int i = 1; i <= s.size(); i++)//当前枚举到第几位了，从1开始方便处理。
	{
		for (int j = 0; j <= k; j++)//当前改变了几步。
		{
			for (int f = 0; f <= 1; f++)//当前方向。
			{
				dp[i][j][f] = -0x3f3f3f3f;
				for (int w = (i == 1 ? j : 0); w <= j; w++)//在当前位置花多少个次数来更改。
				{
                			//这里有个小优化，如果 w 是偶数，且当前是 T；
                       			//或者说 w 是奇数但当前是 F，这两种情况都会变成 T。
					if (w % 2 + (s[i - 1] == 'T') == 1)
						dp[i][j][f] = max(dp[i - 1][j - w][!f], dp[i][j][f]);//当前命令为 T。
					else
						dp[i][j][f] = max(dp[i][j][f], dp[i - 1][j - w][f] + (f == 0 ? 1 : -1));//否则当前命令是 F
				}
			}
		}
	}
	cout << max(dp[s.size()][k][1], dp[s.size()][k][0]);
	return 0;
}//ck
```
