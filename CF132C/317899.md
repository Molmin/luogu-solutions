[仍然是老习惯，早上起床打一场 Codeforces。今天起晚了，打不起来，所以就做了一道 C 题。我是拿随机数跳题跳的，爬取题面到本地以后一直在做，调了好久，感到奇怪，最后交的时候才发现这是 Div.1 （唔，问题是我居然 AC 了？](https://oi-master.github.io/post/codeforces-contest-132-c-ti-jie/)

## 思路
典型的 DP 题目。我们可以用一个三维 DP 来做这道题目，是 $dp_{i,j,k}$ ，表示的是前 $i$ 个字符，换了 $j$ 次，然后方向为 $k$ 的时候里原点最大的距离。$k$ 的取值为 $0$ 或者是 $1$ ，$0$标识的就是正方向，$1$ 表示的就是负方向。

然后，我们来分析一下状态转移方程，不过，直接写不太方便，我觉得我们应该从每个情况看起。

1. 如果 $s_i$ 是 `F`：

    我们枚举在这个 $i$ 的位置上换了几次，枚举的范围就是 $0$ 至 $j$，然后我们把这个换的次数的值叫做 $k$ ，接下来我们再进一步分析一下 $k$。
    
    如果 $k$ 是奇数的话，那么因为抵消的关系就相当于 $k$ 是 $1$ 。那么，现在的方向一定和上一次的方向是相反的，所以，可以得知，状态转移方程如下：
    
    $$dp_{i,j,0}=max(dp_{i,j,0},dp_{i-1,j-k,1})$$
    然后，我们也可以得知
    
    $$dp_{i,j,1}=max(dp_{i,j,1},dp_{i-1,j-k,0})$$
    
    否则，那么 $k$ 就是偶数，那么就等于字符没变呢。所以，我们就按照现在的方向向前走一步，如果是正方向，那么位置就加上 $1$ 。如果是负方向，那么位置就减掉 $1$ 。这个应该很好理解，上式子。
    
    $$dp_{i,j,0}=max(dp_{i,j,0},dp_{i-1,j-k,0}+1)$$
    
    几乎一样的式子：
    
    $$dp_{i,j,1}=max(dp_{i,j,1},dp_{i-1,j-k,1}-1)$$
    是吧？很好理解对不对？
    
2. 如果 $s_i$ 是字符 `T`：

    额，一样的一样的，如果 $k$ 是
    奇数的话，那么 $s_i$ 就会变成 `F` ，状态转移方程搬下来：
    $$dp_{i,j,0}=max(dp_{i,j,0},dp_{i-1,j-k,0}+1)$$
    $$dp_{i,j,1}=max(dp_{i,j,1},dp_{i-1,j-k,1}-1)$$
    
    如果 $k$ 是偶数的话：
    
    $$dp_{i,j,0}=max(dp_{i,j,0},dp_{i-1,j-k,1})$$
    $$dp_{i,j,1}=max(dp_{i,j,1},dp_{i-1,j-k,0})$$

好了，现在是不是感觉很简单？我们只需要加一个简单的初始化即可。

$$dp_{0,0,0}=dp_{0,0,1}=0$$

其他的格子都赋值为无限小（$-inf$）。

上代码。
### 代码
```cpp
/* Generated by powerful Codeforces Tool
 * You can download the binary file in here https://github.com/xalanq/cf-tool
 * Author: OI_Master
 * Time: 2020-04-06 08:37:08
**/
#include<bits/stdc++.h>
using namespace std;
#define int long long
int dp[101][51][2];
signed main() {
	ios::sync_with_stdio(false);
	cin.tie(0);
	string s;
	cin>>s;
	int n;
	cin>>n;
	int size=s.size();
	s=' '+s;
	for(int i=0;i<=size;++i)
		for(int j=0;j<=n;++j)
			dp[i][j][0]=dp[i][j][1]=-1000000000000;
	dp[0][0][0]=0;
	dp[0][0][1]=0;
	for(int i=1;i<=size;++i)
		for(int j=0;j<=n;++j)
			for(int k=0;k<=j;++k)
				if(s[i]=='F')
					if(k%2==1){
						dp[i][j][0]=max(dp[i][j][0],dp[i-1][j-k][0]);
						dp[i][j][1]=max(dp[i][j][1],dp[i-1][j-k][0]);
					}
					else{
						dp[i][j][0]=max(dp[i][j][0],dp[i-1][j-k][0]+1);
						dp[i][j][1]=max(dp[i][j][1],dp[i-1][j-k][1]-1);
					}
				else
					if(k%2==1){
						dp[i][j][0]=max(dp[i][j][0],dp[i-1][j-k][0]+1);
						dp[i][j][1]=max(dp[i][j][1],dp[i-1][j-k][1]-1);
					}
					else{
						dp[i][j][0]=max(dp[i][j][0],dp[i-1][j-k][1]);
                        dp[i][j][1]=max(dp[i][j][1],dp[i-1][j-k][0]);
					}
	cout<<max(dp[size][n][0],dp[size][n][1]);
	return 0;
}
```
没了，没了，下面就是评论区了。