## 前言
~~对于这道题线段树的写法请参见其他dalao题解~~

可能因为这道题的测试点都挺水，本人参照（膜拜）[3206583219sjw](https://www.luogu.com.cn/user/129601) 的想法来水了我的第一篇题解。

因为这个类似于扫描的思维和标程有~~异曲同工之妙~~可能会对像我这样的新手起一点指导作用以理解和应用其他更为高大上的方法吧~

###### 不知道数据会不会加强……

## 思路
观察这些个矩形，通过题意我们可以想到这个题只与矩形的周长有关（废话），所以我们自然而然地想到可以将矩形分为四条线分别进行计算。由于矩形的特性，我们可以分别将所有矩形的左边竖线和下边横线进行计算，并将答案乘2即可。这个做法的好处在于：

![](https://cdn.luogu.com.cn/upload/image_hosting/02homnyn.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

比如上两个矩形（内含边用黄色标注），我们可以用平移的方法确保整体位于左边的竖边和右边的边一定一一对应。那么我们**先将每个矩形的左边从左往右排列一下**，讨论左边矩形时，对于内含的边，我们可以添加一个临时数组tag标记，即
```cpp
for(int i=1;i<=n;++i)					 //从左往右遍历矩形
	{
		for(int j=e[i].ly;j<e[i].ry ;++j)//从下倒上遍历标记每个构成边的点
		{
			if(tag[j]<e[i].lx )ans+=2;   //tag在遍历第二个矩形时在黄色的右竖边时遍历的点在第一个矩形内部，so不加，原来的黄边移到了最右边的粉边
            							 //ans+=2是连接的整个图形的左边+右边，保证两两配对
			if(tag[j]<e[i].rx )tag[j]=e[i].rx ;//更新整体图像的最右边界
		}
	}
```
用tag数组标记上一个（或之前右边最右的）矩形的位置，可以明确接下来的矩形是否相接。这里tag表示的是竖着的y轴。
对于横边也一样：
```cpp
for(int i=1;i<=n;++i)
	{
		for(int j=e[i].lx ;j<e[i].rx ;++j)
		{
			if(tag[j]<e[i].ly )ans+=2;
			if(tag[j]<e[i].ry )tag[j]=e[i].ry;
		}
	}
```
总的来说这个思路的流程和线段树做法是一样的（吧），~~但由于我太菜了而且线段树想不出来~~只能用这个稍微投机取巧的方法，线段树应该是比这个更优秀（我没比较过），时间复杂度~~不知道~~。这里再次膜拜提供方法思路（和标程）的[dalao](https://www.luogu.com.cn/user/129601)。
## 过程
我们可以建一个结构体存储矩形。
```cpp

int tag[21000],ans=0,n;
struct square
{
	int lx,ly,rx,ry;//lx，ly是左下坐标，rx，ry右上
}e[5005];

bool cmpx(edge a , edge b){return a.lx <b.lx ;}
bool cmpy(edge a , edge b){return a.ly <b.ly ;}
//讨论不同方向上用于sort的排序函数
```
主函数
```cpp
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;++i)
	{
		scanf("%d%d%d%d",&e[i].lx ,&e[i].ly ,&e[i].rx ,&e[i].ry );
		e[i].lx +=10001;
		e[i].ly +=10001;
		e[i].rx +=10001;
		e[i].ry +=10001;
	}                          //因为tag初始是0，而题目坐标有负数所以投下机
//////////////////////////////////////////////////////////////////////////
	memset(tag,-1,sizeof(tag));//可以一数组二用
	sort(e+1,e+n+1,cmpx);
	for(int i=1;i<=n;++i)
	{
		for(int j=e[i].ly ;j<e[i].ry ;++j)
		{
			if(tag[j]<e[i].lx )ans+=2;
			if(tag[j]<e[i].rx )tag[j]=e[i].rx ;
		}
	}
//////////////////////////////////////////////////////////////////////////
//	……横边代码请自行想象
	printf("%d",ans);
	return 0;
}
```
因为防刷题和~~版权原因~~不能发完整程序非常抱歉……但是基本思路应该都清楚了~~不清楚的请出门右转线段树【滑稽】~~

### 希望我的题解能帮到你
###### 第一篇题解留念