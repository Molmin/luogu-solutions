### 一、做法

以下令上边为平行于 $x$ 轴的纵坐标较大的那一条边，下边为平行于 $x$ 轴的纵坐标较小的那一条边，左边为平行于 $y$ 轴的横坐标较小的那一条边，右边为平行于 $y$ 轴的横坐标较大的那一条边。

首先有一个很显然的性质：矩形的 $4$ 条边上都必须有点，因为如果一条边上没有点，这一条边可以适当向内收缩使得矩形边上及内部点数不变并且面积缩小。所以矩形的面积要最小，它的每一条边都至多只有 $n$ 种选法。

然后就是这一题的做法。有一个很显然的暴力（官方题解给的就是这个）：枚举矩形的 $4$ 条边分别由哪个点决定，然后判断被它包含的点的数量是否大于等于 $K$。时间复杂度 $O(n^5)$，可以通过此题。[官方题解](https://img.atcoder.jp/abc075/editorial.pdf)写了，代码就不给了。

再优化，可以在离散化所有点后使用二维前缀和，在 $O(1)$ 的时间内统计一个指定矩形内部有多少点，然后 $O(n^4)$ 通过这道题。其他题解写了，代码就不给了。

再优化，我们可以只枚举 $3$ 条边，比如说上、左、右 $3$ 条边。此时我们发现，下边的纵坐标变大，矩形内部包含的点的个数就不会增大；下边的纵坐标变小，矩形内部包含的点的个数就不会减少。所以我们可以 $O(\log n)$ 二分下边的纵坐标，再 $O(1)$ 判断矩形里面的点的个数是否大于等于 $K$ 即可。时间复杂度 $O(n^3\log n)$，代码就不给了。

再优化，我们还可以发现一个性质。对于固定的下边和左边，我们要保证面积最小，即恰好大于等于 $K$ 个点使得 $4$ 条边再缩就会导致矩形包含的点的个数小于 $K$，那么我们逐渐增大右边时，就需要减小上边的纵坐标，来使得矩形恰好包含至少 $K$ 个点。所以一开始我们假设，在离散化后，有 $cx$ 个不同的横坐标，有 $cy$ 个不同纵坐标，我们设定的矩形左边的横坐标编号为 $i$，下边的纵坐标编号为 $j$，右边的横坐标编号为 $k$，上边的纵坐标编号为 $h$，那么我们就让 $k$ 从 $i$ 开始枚举到 $cx$，让 $h$ 从 $cy$ 开始对应缩小使得 $h$ 再缩一点矩形包含的点的个数就会小于 $K$。那么这种情况时才可以保证矩形的面积可能最小。注意，由于 $k=i$ 时很可能即使 $h=cy$，矩形包含的点数也不足 $K$，所以要先让 $k$ 自增到存在 $h\le cy$ 的矩形包含至少 $K$ 个点。时间复杂度：枚举 $i,j$ 要 $O(n^2)$，处理 $h,k$ 需要 $O(n)$，所以总的时间复杂度是 $O(n^3)$。所以其实这一题可以出到 $n\le 500$。

### 二、代码

```cpp
#include<bits/stdc++.h>
#define S(lx,rx,ly,ry) s[rx][ry]+s[lx-1][ly-1]-s[rx][ly-1]-s[lx-1][ry]
using namespace std;
typedef long long ll;
ll n,K,x[60],y[60],ans=4e18,cx,cy,X[60],Y[60],p[60][60],s[60][60],c=0;
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	cin>>n>>K;
	for(ll i=1;i<=n;i++)cin>>X[i]>>Y[i],x[++c]=X[i],y[c]=Y[i];
	sort(x+1,x+c+1);cx=unique(x+1,x+c+1)-x-1;
	sort(y+1,y+c+1);cy=unique(y+1,y+c+1)-y-1;
	for(ll i=1;i<=n;i++){
		X[i]=lower_bound(x+1,x+cx+1,X[i])-x;
		Y[i]=lower_bound(y+1,y+cy+1,Y[i])-y;
		p[X[i]][Y[i]]=1;
	}
	for(ll i=1;i<=cx;i++)
		for(ll j=1;j<=cy;j++)s[i][j]=p[i][j]+s[i-1][j]+s[i][j-1]-s[i-1][j-1];
	for(ll i=1;i<=cx;i++)
		for(ll j=1;j<=cy;j++)
			if(S(i,cx,j,cy)>=K)
				for(ll k=i,h=cy;k<=cx;k++)
					if(S(i,k,j,cy)>=K){
					while(S(i,k,j,h-1)>=K)h--;
					ans=min(ans,(x[k]-x[i])*(y[h]-y[j]));
				}
	cout<<ans<<'\n';
	return 0;
}
```