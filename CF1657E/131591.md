
更好的阅读体验：

https://www.cnblogs.com/hokarikanae/articles/16045118.html

第一次打 codeforces 自己做出 E 题，还是个 dp ，所以来写人生第一发题解。

## 一、题意：

有一个 $n$ 个点的无向完全图，边权 $e\in[1,k]$ ，已知该图的最小生成树的权值与所有与1号点相连的边的边权和相同，求有多少种构图方式，答案对   $998244353$ 取模，$n,k \leq 250$ 。

## 二、分析：

考虑一棵以 $1$ 号点为根的菊花图（ $1$ 号点度数为 $n-1$ ），根据题意，显然这是其中一棵最小生成树，设它的权值为 $t$ 。那么如果要满足**不存在更小的生成树**，有什么条件呢？

考虑两个点 $u$ ，$v$（ $u,v\neq1$ ），设 $u$ 到 $v$ 的无向边权值为 $x$ ，而 $1$ 到 $u$ 的边权值为 $y$ 。那么在以 $1$ 号点为根的菊花图中，如果去掉 $1$ 到 $u$ 的边，并加上 $u$ 到 $v$ 的边，也可以得到一棵生成树，而这颗生成树的权值为 $t-y+x$ 。根据题意 $t-y+x\geq t$ ，得出：$y\leq x$ 。**也就是说，除 $1$ 号点外任意点 $u$ 连出去的边的权值都必须 $\geq$ 边 $(u,1)$ 的权值，换句话说，离 $u$ 最近（可以是之一）的点必须是 $1$ 号点，容易发现这是充要条件。**

## 三、解题方法：

根据上面的分析，可以发现：

决定无向完全图的形态的是什么？ $\frac{n(n-1)}{2}$ 条边的边权；

限制边权的条件是什么？两端点 $u$ ，$v$ 到 $1$ 号点的距离；

除此之外，一条边的边权是否受到其他边的限制？不受到。

再结合本题较小的数据范围，一个简单的 dp 思路就呼之欲出了：

设 $dp_{i,j}$ 表示已经在图中加入了 $i$ 个点，这些点到 $1$ 号点的距离最大值为 $j$ **（且必须存在这个最大值）** 时，有多少种不同的构图方案。在这里，我们需要考虑选取点的不同方案，因此这 $i$ 个点的编号可以是任意的（当然 $1$ 号点必须包括在内），未必是 $1,2,3\cdots i$ 。

初始状态：$dp_{1,0}=1$ ，$dp_{1,i}=0$ $(i\in [1,k])$ 。这是因为只有 $1$ 号点时，我们什么都做不了，一条边也没有，边权最大值当然是 $0$ 了。

答案： $\sum _{i=1}^{k}dp_{n,i}$ 。

重点在于如何转移。笔者赛时在这里也卡了一会儿，因此会讲得细致一些。

对于 $i\geq2$ ，考虑一个状态 $dp_{i,j}$ ，我们枚举到 $1$ 距离为 $j$ 的点有多少个，在代码中笔者枚举的是到 $1$ 距离小于 $j$ 的点有多少个，即转移点在哪里。我们设到 $1$ 距离小于 $j$ 的点有 $t$ 个，那么应当转移到当前状态的是 $dp_{t,x},x\in[0,j-1]$ ，即可以转移过来的状态数为 $\sum_{x=0}^{j-1}dp_{t,x}$ 。转移的时候，我们先在剩余的 $n-t$ 个点中选择 $i-t$ 个点进行新加入，这个选择的方案数是 $C_{n-t}^{i-t}$ ；选好之后，我们还要连边，注意到所有点到 $1$ 号点的边在转移过程中都已经确定下来了，我们需要枚举的是新加入的这些点到除了 $1$ 号点之外的点的边。

这里有一个很关键的地方：对于还未加入的 $n-i$ 个点，已加入的点与它们相连的边会受到更加严格的限制，因为它们到 $1$ 号点的距离 $>j$ ，于是已加入的点与它们相连的边的边权也必须 $>j$ ，那么这些边我们就应该在加入剩下的 $n-i$ 个点的时候再分别考虑，到时候只需要考虑那个大于 $j$ 的某个限制就可以了，因为这一定是更严格的限制（其实这里就反映了一个动态规划的重要思想：消去后效性）。

回到 $dp_{i,j}$ 的转移过程来，当我们加入这 $i-t$ 个点时，应该只考虑这些点之间的连边以及这些点到前 $t$ 个点（除了 $1$ 号点）之间的连边。所有的这些边的限制均为边权 $\geq j$ ，因此，连边的总方案数为： $(k-j+1)^{(i+t-3)(i-t)/2}$  ，指数 $(i+t-3)(i-t)/2$ 就是这一次连边的总数，建议可以画一下图手玩一下，很容易明白的。

综上所述，转移方程为：

$dp_{i,j}=\sum_{t=1}^{i-1}(\sum_{x=0}^{j-1}dp_{t,x})$  $\cdot C_{n-t}^{i-t}$  $ \cdot (k-j+1)^{(i+t-3)(i-t)/2}$ ，其中 $i\in[2,n]$ , $j\in[1,k]$ 。

注意到 $\sum_{x=0}^{j-1}dp_{t,x}$ 可以用前缀和优化，组合数的系数不太大，可以直接递推预处理，幂次 $(k-j+1)^{(i+t-3)(i-t)/2}$ 可以用预处理分块快速幂（光速幂）优化，得到 $O(kn)$ 的空间复杂度和 $O(kn^2)$ 的时间复杂度；笔者比较懒，而且 codeforces 的机子比较快，可以接受 $O(kn^2 \log n)$ 的复杂度，因此直接在转移的过程中用了快速幂。

时间复杂度： $O(kn^2 \log n)$ ，空间复杂度： $O(kn)$ 。

## 四、代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
const long long p=998244353,inv=499122177;
long long n,k,dp[255][255],C[255][255],sum[255][255];
long long qpow(long long x,long long y){
	long long r=1;
	while(y){
		if(y&1) r=r*x%p;
		x=x*x%p,y>>=1;
	}
	return r;
}//快速幂
int main(){
	scanf("%lld%lld",&n,&k);
	dp[1][0]=1;
	for(long long i=0;i<=k;++i) sum[1][i]=1;//初始化dp值
	for(long long i=0;i<=n;++i) C[i][0]=1;
	for(long long i=1;i<=n;++i){
		for(long long j=1;j<=i;++j){
			C[i][j]=(C[i-1][j-1]+C[i-1][j])%p;
		}
	}//预处理组合数
	for(long long i=2;i<=n;++i){
		for(long long j=1;j<=k;++j){
			for(long long t=1;t<=i-1;++t){
				dp[i][j]=(dp[i][j]+
           C[n-t][i-t]*sum[t][j-1]%p*qpow(k-j+1,(i-2+t-1)*(i-t)/2)%p)%p;//状态转移方程
			}
			sum[i][j]=(sum[i][j-1]+dp[i][j])%p;//前缀和优化
		}
	}
	long long ans=0;
	for(long long i=1;i<=k;++i) ans=(ans+dp[n][i])%p;
	printf("%lld\n",ans);
	return 0;
}//切掉E了，拜拜！
```

