这道题其实想出了枚举方法就不是很难了。

枚举，需要条理清晰，不重不漏。

那怎么样才能不重不漏呢？

我们试着这样想：能不能先把其中一种操作做完，再去做另一种操作呢？

那么，就可以开始尝试了：

以 $579$ 为例：

我们先移动数位，可以得到三种结果：$579,957,795$

然后再分别在这三个数上面进行讨论。

讨论 $579$：

我们如果要字典序最小，那么应该怎么加呢？

**让第一位变成 0！**

没错，字典序永远先管高位。

我们只要确定了第一位是 $0$，那么整个新字符串就确定了。

如果 $579$ 第一位变成了 $0$，那么肯定是进行了 $10-5=5$ 次加法操作。

因此让后面的位数都加上 $5$ 再取模 $10$ 即可。

最后再从这几个字符串中找出字典序最小的就可以了。

代码如下：

```cpp
#include <cstring>
#include <cstdio>

int n;
char s1[1010], s2[1010], ans[1010];

void solve(){
	int las = 10 - (s2[0] - '0');	//注意这是字符，所以要先将字符变成数字
	s2[0] = '0';
	for(int i=1; i<n; i++)
		s2[i] = (s2[i] - '0' + las) % 10 + '0';	//然后再将数字变成字符
        
	if(strcmp(s2, ans) < 0)			//比字典序小，即答案更优
		strcpy(ans, s2);			//更换答案
}

int main(){
	
	scanf("%d %s", &n, s1);
	for(int i=0; i<n; i++)			//初始化答案数组
		ans[i] = 'a';
        
	for(int i=0; i<n; i++){
		for(int j=i; j<i+n; j++)		//枚举字符串，注意位数要取模
			s2[j - i] = s1[j % n];
		solve();
	}
	puts(ans);

	return 0;
}
```