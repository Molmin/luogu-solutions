怎么说呢，这题的背景实在是浪漫，看得我都想恋爱的QWQ。

~~于是我果断```Ctrl + C，Ctrl + V```发到了朋友圈里，瞬间收获无数少女的青睐，大家都在惊叹，好浪漫，好暖男啊~~~

咳咳，现在步入正题。

### 题目概括：
有已知棵树，每棵树上有已知量的樱花，求恰好摘取一定量樱花的总方案数量。

~~别看了别看了，一点都不浪漫。~~

乍一看，我还以为是个完全背包，只是价值和重量都相同。不过当我信誓旦旦地打完后，发现样例都过不去。

于是点开标签，发现是个前缀和。

所以说，这题思路：
#### 用01背包优化的完全背包（不是二进制拆分和单调队列）再加上前缀和。

虽然说这题中说了恰好，但是不能初始化成```-INT_MAX```，因为要求的是方案总数，所以我们并没有用到max，而是直接相加。

做dp题的话，如果一开始没有思路，就用多维，把所有的量都表示一下，亿维的方程还是比一维好推一点的，然后再一点点优化掉，这样是基本的过程。~~（注意亿字）~~

#### 第一种思路：二维。
设f(i,j) 表示在前 i 棵樱花树一共收集到了 j 朵樱花。

然后定义一个变量k（0 <= k <= min(j, s[i]）)，用来枚举。

然后递推式子就是：```f(i,j) += f(i-1,j-k)。```

最后把结果累加即可。

#### 第二种思路：一维。
我们令f[i]表示恰好收集i朵樱花的方案数量。

首先我们想到了完全背包的暴力写法：
```cpp
for(i = 1;i <= k; ++i)//前i棵树
 for(p = n;p >= 0; --p)//多重背包转换为01背包
  for(j = 1;j <= min(s[i], p); ++j)
   f[p]=(f[p]+f[p-j])%10086001;
```
但是会发现，这样会T掉。

于是我们用上前缀和，成功解决这个问题。

个人觉得这个代码还算是比较简洁了吧。

## Code：
```cpp
#include<cstdio>
#include<iostream>
using namespace std;
typedef long long ll;//前缀和注意
const int maxn = 5e3 + 5;
const int K = 10086001;
int n, k, s;
ll sum[maxn], sm;
int f[maxn], ans;
int main()
{
	int i, j, v;
	scanf("%d%d", &n, &k);
	sum[0] = f[0] = 1;
	for(i = 1;i <= k; ++i)
	{
		scanf("%d", &s);
		
		for(j = 1;j <= n; ++j)
		  sum[j] = sum[j-1] + f[j];//更新前缀和
		 
		for(v = n;v >= 0; --v)//01背包跑一遍
		  f[v] = (f[v] + sum[v - 1] - sum[v - min(s, v) - 1])%K;
		  
		sm += s;//判断有没有n朵樱花
		
		ans = (ans + f[n]) % K;
	}
	
	if(sm < n)
	  puts("impossible");
	else
	  printf("%d", ans);
	return 0;
}
```
浪漫的题，代码也要很浪漫啊。