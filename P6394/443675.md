主要分析动态规划的优化过程。

## Step 1

首先想一个朴素做法，由于此类题较为典型，这里直接给出状态，``dp[i][j]`` 表示前 $i$ 棵樱花树摘到 $j$ 朵樱花的方案数，方程为：  

$dp_{i,j}=\sum_{q=0}^{\min \{j,s_i\}}dp_{i-1,j-q}  $  

那么可以写出一个 $O(n^3)$ 的朴素动规。  
代码：略。  

## Step 2

重新审视方程，发现后面的一堆完全可以前缀和带走，这样时间复杂度就降到了 $O(n^2)$。  

代码：  
```cpp
for(int i=1;i<=k;i++)
{
	for(int j=1;j<=n;j++)
		dp[i-1][j]=(dp[i-1][j]+dp[i-1][j-1])%mod;
	for(int j=0;j<=n;j++) 
	{
		int l=j-min(j,s[i]),r=j;
		dp[i][j]=(dp[i-1][r]-dp[i-1][l-1])%mod;
	}
	ans=(ans+dp[i][n]+mod)%mod;
}
```  

## Step 3

如果你交上刚刚的代码，也许会获得 $\text{80 pts}$ 至 $\text{100 pts}$ 的好成绩，原因是内存超限，观察题目发现：  
>内存限制 64.00MB

这很简单，因为 $dp_{i}$ 只会由 $dp_{i-1}$ 转移而来，那么可以加上滚动数组，就能通过本题。  

代码：略。  

## Step 4

进一步想到 $dp$ 只和题中的 $s$ 数组有关，那么完全可以直接省掉第一维，参考多重背包的方法即可。  

代码：略，详见其他题解。

## 后记

至此，本题已经被优雅的解决，其中写动态规划的优化过程也是在提示我们：不需要每道题一上来就写正解，通过稍劣的解法逐步推出正解也是值得提倡的写法。  

UPD 10月15日：修改格式和笔误。