这真的是一道**签到题**，~~因为我赛时只 AC 了这题~~。

## 题意简述

给一个长度为 $n$ 的**正整数**数列，将其中一个数修改为**任意整数**，使得**最长严格上升子串**长度最大，并输出这个长度。

注意点：

- **任意整数**：说明我们可以把它改得很大很大，也可以很小很小。

- **严格上升**：说明子串中一个数字一定比前一个大，不可能小于或等于。

- **子串**：说明这个序列在原数列中是**连续的**。

***

## 分析和解法

看完题目，很容易想到，我们首先需要预处理出原数列中所有严格上升子串的长度。

用 $f_{i,j}$ 表示 $[i,j]$ 中最长严格上升子串的长度？显然不行，$10^6$ 的范围，先不说时空了，这么大的数组编译都成功不了。

用 $f_i$ 表示 $[1,i]$ 中最长严格上升子串的长度？显然也不行，不方便处理（~~反正我不会~~）。

等一下，题目说是子串，就一定是连续的，所以……

$e_i$ 表示以 $i$ 结尾的严格上升子串的长度，$b_i$ 表示以 $i$ 开头的严格上升子串的长度，可以用两个线性递推方便地预处理出来，问题似乎突然变得简单起来！

$$e_i=\begin{cases}
e_{i-1}+1&a_{i-1}<a_i\\
1&(a_{i-1}\ge a_i)\vee(i=1)
\end{cases}
$$

$$b_i=\begin{cases}
b_{i+1}+1&a_{i}<a_{i+1}\\
1&(a_i\ge a_{i+1})\vee(i=n)
\end{cases}$$

其中，$\vee$ 是**逻辑或**运算，即代码中的 `||`。考虑到全局变量初始化为 $0$ 的特性，实际实现时不需要特判 $1$ 和 $n$，这点可以自己理解。另外需要注意的是递推顺序。

这部分的代码：

```cpp
	for(int i=1;i<=n;i++)
		e[i]=a[i]>a[i-1]?e[i-1]+1:1;
	for(int i=n;i>=1;i--)
		b[i]=a[i]<a[i+1]?b[i+1]+1:1;
```

预处理过后，接下来要枚举改变的数是哪个，怎么改变，具体的见这部分代码罢。

```cpp
	for(int i=1;i<=n;i++){
		if(a[i-1]<a[i+1]-1)//一定要减 1！
			ans=max(ans,e[i-1]+b[i+1]+1);//改变数字，将其前后的两个严格上升子串连接起来
		if(a[i-1]>=a[i])
			ans=max(ans,e[i-1]+1);//改变数字，延长前面的严格上升字串
		if(a[i]>=a[i+1])//这两个 if 中一定都是 >=
			ans=max(ans,b[i+1]+1);//同上，但是延长后面的
	}
```

仍然不需要特判 $1$ 和 $n$，自行理解。

***

## 代码

完整代码贴在这里，不过动了亿些手脚，~~我看哪个大冤种直接复制。~~

```cpp
#include<bits/stdc++.h>
#define N 1000005
#define max(a,b) (a>b?a:b)
using namespace std;
int read(){
	int r;
	char ch=getchar();
	while(ch<'0'||ch>'9')
		ch=getchar();
	while(ch>='0'&&ch<='9')
		r=r*10+ch-'0',ch=getchar();
	return r;
}
void write(int w){
	if(w>10)
		write(w/10);
	putchar(w%10+'0');
}
int n,a[N],b[N],e[N],ans;
signed main(){
	n=read();
	for(int i=1;i<=n;i++)
		a[i]=read();
	for(int i=1;i<=n;i++)
		e[i]=a[i]>a[i-1]?e[i-1]+1:1;
	for(int i=n;i>=1;i--)
		b[i]=a[i]<a[i+1]?b[i+1]+1:1;
	for(int i=1;i<=n;i++){
		if(a[i-1]<a[i+1]-1)
			ans=max(ans,e[i-1]+b[i+1]+1);
		if(a[i-1]>=a[i])
			ans=max(ans,e[i-1]+1);
		if(a[i]>=a[i+1])
			ans=max(ans,b[i+1]+1); 
	}
	write(ans);
	return 0;
} 
```