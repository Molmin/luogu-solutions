看到还没有人发题解，不如我来一篇？

其实做这道题纯粹是因为这是一道双倍经验题，这道题与JZOJ 5916. 【NOIP2018 模拟 10.20】flow 体面意思是一样的，大家可以把它看成一个中文翻译，下面奉上这道题的中文翻译（~~代码形式插入~~）

```
5916. 【NOIP2018 模拟 10.20】flow  (File IO): input:flow.in output:flow.out 
Time Limits: 1000 ms  Memory Limits: 262144 KB  Detailed Limits    Special Judge 
Description 
       你是申国的一个地方长官，你手下有 n 个城市。        为了加强基础设施建设，在 2020 全面建成小康社会，统筹推进经济建设、政治建设、文化建设、 社会建设、生态文明建设，坚定实施科教兴国战略、人才强国战略、创新驱动发展战略、乡村振兴战 略、区域协调发展战略、可持续发展战略、军民融合发展战略，突出抓重点、补短板、强弱项，特别是 要坚决打好防范化解重大风险、精准脱贫、污染防治的攻坚战，使全面建成小康社会得到人民认可、经 得起历史检验。你认为本省的水利调配非常有问题，这导致部分地区出现严重的缺水，而部分地区却全 年洪灾泛滥。        于是你打算将原有的但是已经废弃了的 m 条水管重新使用。第 i 条水管连接城市 xi 和 yi。这些水管 联通了所有城市。每座城市对水的需求不同设为 ai，部分城市处于缺水状态，ai 为正，缺水量刚好为 ai mol。部分城市因为有水库，ai 为负，它需要向外输送-ai mol 的水才能不形成洪灾。对于每条水管，你需 要决定它的输送量 fi，若 fi 为正则表示从 xi 向 yi 输送 fi mol 的水，fi 为负则表示从 yi 向 xi 输送-fi mol 的 水。        你需要做到每个城市都刚好满足它的需求，即缺 ai mol 水的城市需要刚好输入 ai 的水，而多出-ai mol 水的城市需要刚好输出-ai mol 水。        你需要判断能否满足要求，若满足，你还需要输出所有的 f。 
Input 
第一行一个整数 n。 第二行 n 个整数 ai。 第三行一个整数 m。 接下来 m 行每行两个整数，xi,yi。 意义如题中所述。 
Output 
如果不能满足要求，输出”Impossible”。 否则第一行输出”Possible”，接下来 m 行，第 i+1 行输出 fi。 若有多组解，随意输出一组即可。 
Sample Input 
4 
3 -10 6 1 
5 
1 2 
3 2 
2 4 
3 4 
3 1 
Sample Output 
Possible 
4 
-6 
8 
-7 
7 
Data Constraint 
对于 10%：n<=5，|ai|<=20 对于 20%：n<=10，|ai|<=20 对于另 30%：n<=1000，m=n，|ai|<=20 对于 100%：n<=200000，m<=300000，你使用 longint(pascal)/int(c++)就能够存储 ai。 数据纯随机。 
Hint 
Tips 
mol 是一种单位。 
```
下面是思路：

首先，我们需要判断是否合法，这很简单，只需要记录一下a数组里面的数的总和为0及合法，不为0则不合法，直接输出"Impossible"之后return 0即可。

之后讨论合法情况：

现在考虑如何构造出一种合法解。
一种很简单的方法就是先构造一棵生成树，
强制只用树上面的边，这样就可以轻松求出一组合法解。

还是看不懂的小朋友们还是直接看下面的代码吧

```cpp
#include<bits/stdc++.h>//万能头文件
using namespace std;
int a[200001],fa[200001],p[200001],ans[200001];
int cnt;
struct rec
{
    int nxt;
    int lst;
    int to;
    int id;
}e[400001];//个人习惯用数组存邻接表
int getfa(int x)
{
    return fa[x]=fa[x]==x?x:getfa(fa[x]);//并查集
}
void add(int x,int y,int flag)//建立邻接表
{
    e[++cnt].nxt=e[x].lst;
    e[cnt].to=y;
    e[cnt].id=flag;
    e[x].lst=cnt;
}
void dfs(int x,int f)//DFS搜索
{
    p[x]=a[x];
    for(int i=e[x].lst;i;i=e[i].nxt)
        if(e[i].to!=f)
        {
            dfs(e[i].to,x);
            p[x]+=p[e[i].to];
            if(i%2)ans[e[i].id]=p[e[i].to];
            else ans[e[i].id]=-p[e[i].to];
        }
}
int main()
{
    int n,m;
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
    {
        scanf("%d",&a[i]);
        fa[i]=i;
        cnt+=a[i];//cnt此时用来记录a数组是否合法
    }
    if(cnt)//判断是否合法
    {
        cout<<"Impossible"<<endl;
        return 0;
    }
    cout<<"Possible"<<endl;
    cnt=0;
    scanf("%d",&m);
    for(int i=1;i<=m;i++)//如上面解释所说
    {
        int x,y;
        scanf("%d%d",&x,&y);
        if(getfa(x)!=getfa(y))
        {
            add(x,y,i);
            add(y,x,i);
            fa[getfa(x)]=getfa(y);
        }
    }
    dfs(1,0);
    for(int i=1;i<=m;i++)//输出
        cout<<ans[i]<<endl;
    return 0;
}
```
~~恶搞环节：~~

好学生自动忽略即可

~~教大家一种新的定义方式，可以让抄你题解的人一脸懵逼。~~

~~以下划线长度不同定义不同的变量~~
```cpp
#include<bits/stdc++.h>
using namespace std;
int _[200001],__[200001],___[200001],____[200001];
int _____;
struct ________________
{
    int _______;
    int ________;
    int _________;
    int __________;
}______[400001];
int _________________(int ___________)
{
    return __[___________]=__[___________]==___________?___________:_________________(__[___________]);
}
void __________________(int ___________,int ____________,int _______________)
{
    ______[++_____]._______=______[___________].________;
    ______[_____]._________=____________;
    ______[_____].__________=_______________;
    ______[___________].________=_____;
}
void ___________________(int ___________,int _______________)
{
    ___[___________]=_[___________];
    for(int _____________=______[___________].________;_____________;_____________=______[_____________]._______)
        if(______[_____________]._________!=_______________)
        {
            ___________________(______[_____________]._________,___________);
            ___[___________]+=___[______[_____________]._________];
            if(_____________%2)____[______[_____________].__________]=___[______[_____________]._________];
            else ____[______[_____________].__________]=-___[______[_____________]._________];
        }
}
int main()
{
    int ______________,_______________;
    scanf("%d",&______________);
    for(int _____________=1;_____________<=______________;_____________++)
    {
        scanf("%d",&_[_____________]);
        __[_____________]=_____________;
        _____+=_[_____________];
    }
    if(_____)
    {
        cout<<"Impossible"<<endl;
        return 0;
    }
    cout<<"Possible"<<endl;
    _____=0;
    scanf("%d",&_______________);
    for(int _____________=1;_____________<=_______________;_____________++)
    {
        int ___________,____________;
        scanf("%d%d",&___________,&____________);
        if(_________________(___________)!=_________________(____________))
        {
            __________________(___________,____________,_____________);
            __________________(____________,___________,_____________);
            __[_________________(___________)]=_________________(____________);
        }
    }
    ___________________(1,0);
    for(int _____________=1;_____________<=_______________;_____________++)
        cout<<____[_____________]<<endl;
    return 0;
}
```
~~不要以为上面的是代码补全，上面的科室AC代码哦~~~