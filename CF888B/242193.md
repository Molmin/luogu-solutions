这道题其实翻译给得很直接了，这篇题解就简单把这个公式推一下。

可以看出机器人只执行了其中一些指令后才回到起点，要回到起点向左与向右的步数必定要相同，向上与向下的步数也应该相同。

要能尽量执行更多的指令， L 与 R 中个数最少的就必须全部被执行，多出来的部分就被机器人忽略了，对于 U 和 D 也是一样。

那么能够执行的最多步数就等于 L 和 R 中最少的个数与 U 和 D 中最少的个数之和再乘以2。

推出了公式后这题就不难了。

CODE：

```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
    int x;
    cin>>x;//长度
    int l=0,r=0,u=0,d=0;//计数器
    for(int i=1;i<=x;i++)
    {
        char c;
        cin>>c;
        if(c=='L')l++;//统计个数
        if(c=='R')r++;
        if(c=='U')u++;
        if(c=='D')d++;
    }
    cout<<2*(min(l,r)+min(u,d))<<endl;//根据公式输出答案
    return 0;
}
```
