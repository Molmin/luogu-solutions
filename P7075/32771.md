提供一个**代码复杂度较小**，**在线**$O(1)$ 回答单个询问的解法。

先前面说明一下，把公元前 4713 年 1 月 1 日 作为第0天并不是什么坏主意，毕竟“0”还是有不错的除法性质的。

下面用 $n$ 表示询问的天数。解题的关键在于将 $n$ 对应的年份分成多个阶段，划分依据是有无每100年平年的规定。

此外，这题还有一个重要的性质：**周期性**。这是我的解法的关键之处。

## 解法1$\quad$根据周期性缩小范围求解

### 1.公元 1582 年 10 月 4 日（含）以前

这个时期的特点在于每 4 年必有闰年。一共有 1721424+577737 天，注意计算器手算别算错。公元前后能合起来是因为闰年总是每4年1次。

我们发现 公元前 4713 年是个闰年，不满足它是一个 4 年平闰周期的最后一年。处理方法很粗暴，让 $n$ 加上$1095$，年份原点改成前 4716 年，这样保持性质不变。将 $n$ 对 $1461$（3平1闰的天数）整除、取模，可以得到经过多少个 4 年、询问是这个4年里的第几天。

`y=-4716+n/1461*4, n%=1461;`

如果算出结果的年份大于等于零，说明是公元后，因公元零年不存在，真实年份要+1。


### 2.公元 1582 年 10 月 15 日（含）以后

以公元 1 年为起点。貌似那 10 天消失的原因就是闰年的需求。所以我们可以假设前1582年有“每 400 年的前 3 个第 100 年是平年”，这样一共会多算 12 天，将 $n$ 减去 $12$ 就好了。但是因为消失的 10 天，$n$ 还要再加上 $10$。所以到这里，将 $n$ 总共减去 $1721426$ ，可以得到计算所需的公元后天数。

然后化归到 400 年的周期里，方法和上面类似。

`y=1+n/146097*400, n%=146097;`

继续讨论当前的 $n$ 是否在前 300 年当中（前 300 年共 109572 天）。

1. 如果 $n$ 在第 4 个 100 年中，每 4 年必有闰年，化归一下直接到4年周期里求解。   
`y+=300, n-=109572;`   
`y+=n/1461*4, n%=1461;`

2. 如果 $n$ 在前 3 个 100 年中，   
`y+=n/36524*100, n%=36524;`   
在这种情况下讨论$n$是否在这 100 年的前 96 年（每 4 年的最后 1 年有闰年）（共 35064 天）   
如果 $n$ 在最后 4 年，`y+=96, n-=35064;`    
转到 4 年周期里求解。   
否则直接可以 `y+=n/1461*4, n%=1461;`   
同样到 4 年周期里去。

### 3.每 4 年周期的处理

这是求解最后的步骤。根据之前的做法，这4年中只可能是第4年为闰年。接下来要将 $n$ 化到该年的第几天。

1. 如果 $n$ 大于等于 $1095$ 且存在闰年，那么 $n$ 直接减去 $1095$，答案年份+3。
2. 否则年份加上 $n/365$，$n$ 对 $365$ 取模。特别地，如果$n \ge 59$，还要再加上1（回避2月29日）。

如何快速判断一年中的第 $n$ ($n$ 从0开始) 天是几月几日？直接打表，一个366*2的数组，用的时候快速查询。平年和闰年共用，区别在于如果第 4 年是平年，在 $n \ge 59$ 时，让 $n$ 加上 1 ，就跳过了 2 月 29 日。

由于前面多次用到这个，可以单独写一个函数。

------------

**最终代码如下，除去我写代码时注释还是很简洁的。**

因为整除、取模常数较大，所以 $O(1)$ 自带大常数，但应该比带循环的做法要好。

注意读入$n$要开`long long`。

```cpp
#include <cstdio>
using namespace std;
typedef long long ll;
//这里快读函数省略
//已经化归到4年的情况下求解
void solve2(int n, int &y, int &m, int &d, bool flag) { //flag为标记是否考虑4年末的闰年
	//打表，快速计算第i天的日月
	static int todate[366][2]={{0,0},{0,1},{0,2},{0,3},{0,4},{0,5},{0,6},{0,7},{0,8},{0,9},{0,10},{0,11},{0,12},{0,13},{0,14},{0,15},{0,16},{0,17},{0,18},{0,19},{0,20},{0,21},{0,22},{0,23},{0,24},{0,25},{0,26},{0,27},{0,28},{0,29},{0,30},{1,0},{1,1},{1,2},{1,3},{1,4},{1,5},{1,6},{1,7},{1,8},{1,9},{1,10},{1,11},{1,12},{1,13},{1,14},{1,15},{1,16},{1,17},{1,18},{1,19},{1,20},{1,21},{1,22},{1,23},{1,24},{1,25},{1,26},{1,27},{1,28},{2,0},{2,1},{2,2},{2,3},{2,4},{2,5},{2,6},{2,7},{2,8},{2,9},{2,10},{2,11},{2,12},{2,13},{2,14},{2,15},{2,16},{2,17},{2,18},{2,19},{2,20},{2,21},{2,22},{2,23},{2,24},{2,25},{2,26},{2,27},{2,28},{2,29},{2,30},{3,0},{3,1},{3,2},{3,3},{3,4},{3,5},{3,6},{3,7},{3,8},{3,9},{3,10},{3,11},{3,12},{3,13},{3,14},{3,15},{3,16},{3,17},{3,18},{3,19},{3,20},{3,21},{3,22},{3,23},{3,24},{3,25},{3,26},{3,27},{3,28},{3,29},{4,0},{4,1},{4,2},{4,3},{4,4},{4,5},{4,6},{4,7},{4,8},{4,9},{4,10},{4,11},{4,12},{4,13},{4,14},{4,15},{4,16},{4,17},{4,18},{4,19},{4,20},{4,21},{4,22},{4,23},{4,24},{4,25},{4,26},{4,27},{4,28},{4,29},{4,30},{5,0},{5,1},{5,2},{5,3},{5,4},{5,5},{5,6},{5,7},{5,8},{5,9},{5,10},{5,11},{5,12},{5,13},{5,14},{5,15},{5,16},{5,17},{5,18},{5,19},{5,20},{5,21},{5,22},{5,23},{5,24},{5,25},{5,26},{5,27},{5,28},{5,29},{6,0},{6,1},{6,2},{6,3},{6,4},{6,5},{6,6},{6,7},{6,8},{6,9},{6,10},{6,11},{6,12},{6,13},{6,14},{6,15},{6,16},{6,17},{6,18},{6,19},{6,20},{6,21},{6,22},{6,23},{6,24},{6,25},{6,26},{6,27},{6,28},{6,29},{6,30},{7,0},{7,1},{7,2},{7,3},{7,4},{7,5},{7,6},{7,7},{7,8},{7,9},{7,10},{7,11},{7,12},{7,13},{7,14},{7,15},{7,16},{7,17},{7,18},{7,19},{7,20},{7,21},{7,22},{7,23},{7,24},{7,25},{7,26},{7,27},{7,28},{7,29},{7,30},{8,0},{8,1},{8,2},{8,3},{8,4},{8,5},{8,6},{8,7},{8,8},{8,9},{8,10},{8,11},{8,12},{8,13},{8,14},{8,15},{8,16},{8,17},{8,18},{8,19},{8,20},{8,21},{8,22},{8,23},{8,24},{8,25},{8,26},{8,27},{8,28},{8,29},{9,0},{9,1},{9,2},{9,3},{9,4},{9,5},{9,6},{9,7},{9,8},{9,9},{9,10},{9,11},{9,12},{9,13},{9,14},{9,15},{9,16},{9,17},{9,18},{9,19},{9,20},{9,21},{9,22},{9,23},{9,24},{9,25},{9,26},{9,27},{9,28},{9,29},{9,30},{10,0},{10,1},{10,2},{10,3},{10,4},{10,5},{10,6},{10,7},{10,8},{10,9},{10,10},{10,11},{10,12},{10,13},{10,14},{10,15},{10,16},{10,17},{10,18},{10,19},{10,20},{10,21},{10,22},{10,23},{10,24},{10,25},{10,26},{10,27},{10,28},{10,29},{11,0},{11,1},{11,2},{11,3},{11,4},{11,5},{11,6},{11,7},{11,8},{11,9},{11,10},{11,11},{11,12},{11,13},{11,14},{11,15},{11,16},{11,17},{11,18},{11,19},{11,20},{11,21},{11,22},{11,23},{11,24},{11,25},{11,26},{11,27},{11,28},{11,29},{11,30}};
	if (n>=1095 && flag) { //第4年是闰年
		y+=3, n-=1095; //现在n是该年第几天
	} else {
		y+=n/365, n%=365;
		if (n>=59) n++;
	}
	m=todate[n][0]+1, d=todate[n][1]+1;
}
void solve(ll n, int &y, int &m, int &d) {
	if (n<1721424+577737) { //1582年10月4日及之前
		//平移一下，把闰年放在第4个周期
		//因为前4713是闰年
		n+=1095;
		y=-4716+n/1461*4, n%=1461;
		solve2(n,y,m,d,true);
		if (y>=0) y++; //公元0年不存在
	} else { //公元后，改历法后
		n-=1721424;
		//有每400年的闰年、100年的平年
		//前1582年当成无100年平年来做，多了12天，还要再加上
		n+=10-12;
		//约束到400年里
		y=1+n/146097*400, n%=146097;
		//然后讨论一下有多少闰年
		//下面约束到100年里 每100年有 36524天
		if (n>=109572) { //最后一个100年，最后一年是闰年，满足每4年有闰年
			y+=300, n-=109572;
			y+=n/1461*4, n%=1461;
			solve2(n,y,m,d,true);
		} else { //不是最后一个100年，末尾没有闰年
			y+=n/36524*100, n%=36524;
			if (n>=35064) { //在最后一个4年
				y+=96, n-=35064;
				solve2(n,y,m,d,false);
			} else {
				y+=n/1461*4, n%=1461;
				solve2(n,y,m,d,true);
			}	
		}
	}
}
int main() {
	int q=read<int>();
	while (q--) {
		ll n=read<ll>();
		int y,m,d;
		solve(n,y,m,d);
		if (y<0) printf("%d %d %d BC\n", d,m,-y);
		else printf("%d %d %d\n", d,m,y);
	}
	return 0;
}
```
## 解法2$\quad$利用映射拟合，暴力计算年份

这应该算是优化到极致的做法。

首先我们问一个问题：为什么会有闰年的设定？答案很简单，但可能不一定能在做这题时想到：为了补上少数的年份。   
还有为什么有100年不闰、400年又闰的设定？其实也是拟合减小误差的需要。

在上面的解法中，我们发现讨论闰年特别特别麻烦，不难想到：如果能直接算出 $n$ 在第几年，不就没那么多破事了吗？考虑到闰年的设定，这样做应该具有可行性。

### 先考虑简单的情况：儒略历的每4年1闰。

虽然可以先化到 4 年里，但是没有必要。注意到 4 年共 1461 天，除以 4 为 $365.25$ 。如果让 $n$ 直接除以$365.25$，是否能得到正确的增加年数？直接这样做不行，因为 $n=0,1,...,365$ 时得到的结果都是0，包括了366天。这里我们不妨把第0年设为闰年。这样一来，就可以实现周期为4年的循环（第0年为闰，后3年为平）。这个可以在 Excel 中打表验证。   
其次是将 $n$ 减去一定天数得到一年中的第几天，这个只需知道有多少闰年。根据计算，不难得出之前经过闰年数为 $[(y+3)/4]$。   
由于儒略历的第0年恰好为闰年，所以最终结果只需减去 $4713$（不要忘了公元后要+1）。

### 剩下一个麻烦的情况

和解法1一样，$n$先减去 $1721426$，得到公元后假想天数。但是为了保证第一年是闰年，还要加上366（公元零年派上用场了2333）。

这里在 Excel 里稍微玩玩整除拟合会发现，虽然 $365.2425$ 是比较精确的平均每年天数，但在根据一年的最后一天求年数时，用 $365.25$ 反而能得到准确值。

但是并没有这么巧的事。对拍几组会发现，有时年初日期会出错。在 Excel 里检查，发现一年的第1天会在3/4的情况下被当作上一年额外多出的一天（第2, 3天则分别有2/4, 1/4的情况出错）。这样看来，这个解法似乎就不行了。

很遗憾，我没有找到能实现完美拟合的的被除数，只能使用我一开始想出的溢出累加法，即多出来的天放到下一年。

最终我的解决方案就是依旧使用 $365.25$ 作为除数，但是需要特判被算成上一年的错误情况。这种错误很容易查出，一年中天号 $n$ 大于等于 $365$ 或 $366$，直接将年数加1，$n$ 溢出部分减去。这里无需再特判平闰，因为多出来的那几天不超过4天，不关闰年什么事。也不用担心一年倒数几天的事，最后一天都不会出错，就更不用说倒数第2,3天了。

还有需要注意，因为这里 $365.25$ 仅对前400年拟合较好，仍然需要用整除将 $n$ 化归到400年中去。

![](https://cdn.luogu.com.cn/upload/image_hosting/fj9o441y.png)

------------

核心代码实现如下。格里高利历下求经过闰年数用到了简单的容斥。总体代码复杂度和其他题解相比很低，但稍微需要用点数学。大模拟？根本不存在！

```cpp
void solve(ll n, int &y, int &m, int &d) {
	bool flag;
	if (n<1721424+577737) { //1582年10月4日及之前
		y=n/365.25; //基础年序数，第0年为闰年，这样恰好可以得到年数
		n-=y*365+(y+3)/4; // y=0时n不多减，y=1,2,3,4时n要多减1，……
		flag=y%4==0;
		y+=-4713;
		if (y>=0) y++; //公元0年不存在
	} else { //公元后，改历法后
		//记新历的公元1年1月1日为第0天
		//我们希望这里的第0年是闰年，干脆定义公元0年，n加上366
		//直接算出年份，从0开始计  因为这样做在400年里是没有问题的，所以先化归到400年里
		n-=1721426-366;
		int y0=n/146097*400;
		n%=146097;
		y=n/365.25;
		//这里注意，因为不能保证年数正确，会超过该年天数，检查出来直接年数+1就行，因为误差在4以内
		//下面将n减去前面的天数
		//y=0时n不多减，y=1,2,...,400时n要多减1
		n-=y*365ll+(y+3)/4-(y+99)/100+(y+399)/400;
		flag=y%400==0 || y%4==0 && y%100!=0; //当前年是否是闰年
		y+=y0;
        if (n>=365+flag) n-=365+flag, y++; 
	}
	if (!flag && n>=59) n++;
	m=todate[n][0]+1, d=todate[n][1]+1;
}
```

## 一个小小的优化：将查表发扬光大！

直接把判断闰年、闰年计数打表，减少除法运算。

`flag=!(y&3);`

`n-=y*365ll+sumLeapYear[y], flag=isLeapYear[y];`

打表代码如下：

```cpp
//是否为闰年
printf("bool isLeapYear[400]={1");
for (int i=1;i<400;i++) {
	printf(",%d",i%400==0 || i%4==0 && i%100!=0);
}
printf("};\n");
//前缀闰年数
printf("int sumLeapYear[400]={0");
for (int i=1;i<400;i++) {
	printf(",%d",(i+3)/4-(i+99)/100+(i+399)/400);
}
printf("};\n");
```

然而实测几乎没有时间上的优化（笑）。

估计不少时间都用在输入输出上了。
