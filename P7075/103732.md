## CSP-S 2020 T1 儒略日

这篇题解的 idea 来源于我的一位学长，并试图实力证明此题的细节难度应该是一道绿题所应具备的正常难度，且充分说明考场上的我有多么 sb。

题意在题面里说的很详细，也没什么方法简化。

题目里 $10^9$ 的最大年数和 $10^5$ 的数据组数迫使我们去想尽可能快的处理单组数据的方法。

注意到直接模拟的话，难点在以下几个位置：

1. 对于公元前的情况，年数应该倒减，且应该输出 BC
2. 闰年的判断与计数
3. 对于 1582 年以前和 1582 年以后，闰年的判断不同，且格里高利历的闰年判断要更加恶心
4. 1582 年丢失了 10.5~10.14 共十天

我们依次解决。

### 一些常量

非闰年的每月天数依次为：31、28、31、30、31、30、31、31、30、31、30、31。

一年有 365 天，闰年有 366 天。

儒略历下，每四年有 1461 天。

格里高利历下，每四百年有 146097 天。

### 时间段

我们把时间轴分成 [公元前4713年初 至 公元前1年末]，[公元1年初 至 公元 1581 年末]，[公元1582年初 至 公元1582年末]，[公元1583年初以后] 四段，这样每一段中间处理的方式就是完全相同的，不会有历法变化。每段初对应的儒略日能用以上常量轻松算出来。

这四个时间段对应的是 $[0,1721424)$，$[1721424,2298884)$，$[2298884,2299239)$，$[2299239,+\infty)$。

确定时间段后，我们就可以将天数减去时间段起始位置，得到一个从起始位置开始的天数，然后拿这个数去算。

### 公元前-儒略历

儒略历下，每四年有 1461 天，所以我们可以通过 

$$year =4713 - \lfloor \frac{day}{1461} \rfloor \times 4$$

迅速得出当前我们的一个很接近的起始年份，然后将 $day$ 对 1461 取模，将需要处理的天数压到 1461 以下。

为了防止判断失误，我们直接对从 1 月 1 日开始 0~1460 天内的月日状况和年的增长数进行预处理。公元前4713年是一个闰年，因此我们让第一年是闰年，如此处理出来就是第一年是闰年的情况下 0~1460 天内每天的年月日。代码如下：

```cpp
//第一维是天数，后一维是日/月/年
ju1[0][0]=ju1[0][1]=1;
for(i=1;i<Y4;i++)//Y4=1461
{
	ju1[i][0]=ju1[i-1][0]+1,ju1[i][1]=ju1[i-1][1],ju1[i][2]=ju1[i-1][2];
	int lim=days[ju1[i][1]];//days存储月份的天数
	if(ju1[i][1]==2&&ju1[i][2]==0) lim++;//闰年
	if(ju1[i][0]>lim) ju1[i][0]=1,ju1[i][1]++;//跨月
	if(ju1[i][1]>12) ju1[i][1]=1,ju1[i][2]++;//跨年
}
```

对于这一时间段的询问，拿 $day$ 去查表就好了。

### 公元-儒略历

还是儒略历，不同的是公元 1~4 年中第四年才是闰年，所以我们处理一个和上面类似的 $\text{ju2}$，只不过我们让第四年是闰年。

$$year =1 + \lfloor \frac{day}{1461} \rfloor \times 4$$

之后就是直接查表。

### 1582年

这一年比较麻烦，但是只有 355 天，我们可以暴力把每天都打表。只要是按天枚举，一切就好办。

```cpp
d[0][0]=d[0][1]=1;
for(i=1;i<355;i++)
{
	d[i][0]=d[i-1][0]+1,d[i][1]=d[i-1][1];
	int lim=days[d[i][1]];
	if(d[i][0]>lim) d[i][0]=1,d[i][1]++;
	if(d[i][0]==5&&d[i][1]==10) d[i][0]=15;
}
```

### 格里高利历

这个的闰年判断是最恶心的，但是还是有 400 年一度的周期。通过

$$year =1583 + \lfloor \frac{day}{146097} \rfloor \times 400$$

计算出一个较近的年份，然后将 146097 天内的年月日情况打表。

我们从 1583 年开始，因此我们令第 18 年是 400 年一度的闰年。

```cpp
gr[0][0]=gr[0][1]=1;
for(i=1;i<Y400;i++)
{
	gr[i][0]=gr[i-1][0]+1,gr[i][1]=gr[i-1][1],gr[i][2]=gr[i-1][2];
	int lim=days[gr[i][1]];
	if(gr[i][1]==2&&gr[i][2]%4==1&&(gr[i][2]%100!=17||gr[i][2]==17)) lim++;
	if(gr[i][0]>lim) gr[i][0]=1,gr[i][1]++;
	if(gr[i][1]>12) gr[i][1]=1,gr[i][2]++; 
}
```

终于，我们对这种恶心东西也可以查表解决了。

### 总结

在打完四个时间段的表以后，每次询问都只剩了确定时间段+查表这一简单操作。

好写（copy-paste），好调，少细节。这种思想或许也能在其他类似的模拟题上发挥作用。

**计算机给了你内存，可你不珍惜；直到你逞强打挂了，却追悔莫及。**

```cpp
#include <iostream>
#include <cstdio>
using namespace std;
const int Y4=1461,Y400=146097,BC=1721424,To_1582=2298884,To_1583=2299239,days[13]={0,31,28,31,30,31,30,31,31,30,31,30,31};
int ju1[Y4][3],ju2[Y4][3],d[400][2],gr[Y400][3];
int main()
{
	int T,i;
	scanf("%d",&T);
	ju1[0][0]=ju1[0][1]=1;
	for(i=1;i<Y4;i++)
	{
		ju1[i][0]=ju1[i-1][0]+1,ju1[i][1]=ju1[i-1][1],ju1[i][2]=ju1[i-1][2];
		int lim=days[ju1[i][1]];
		if(ju1[i][1]==2&&ju1[i][2]==0) lim++;
		if(ju1[i][0]>lim) ju1[i][0]=1,ju1[i][1]++;
		if(ju1[i][1]>12) ju1[i][1]=1,ju1[i][2]++; 
	}
	ju2[0][0]=ju2[0][1]=1;
	for(i=1;i<Y4;i++)
	{
		ju2[i][0]=ju2[i-1][0]+1,ju2[i][1]=ju2[i-1][1],ju2[i][2]=ju2[i-1][2];
		int lim=days[ju2[i][1]];
		if(ju2[i][1]==2&&ju2[i][2]==3) lim++;
		if(ju2[i][0]>lim) ju2[i][0]=1,ju2[i][1]++;
		if(ju2[i][1]>12) ju2[i][1]=1,ju2[i][2]++;
	}
	d[0][0]=d[0][1]=1;
	for(i=1;i<355;i++)
	{
		d[i][0]=d[i-1][0]+1,d[i][1]=d[i-1][1];
		int lim=days[d[i][1]];
		if(d[i][0]>lim) d[i][0]=1,d[i][1]++;
		if(d[i][0]==5&&d[i][1]==10) d[i][0]=15;
	}
	gr[0][0]=gr[0][1]=1;
	for(i=1;i<Y400;i++)
	{
		gr[i][0]=gr[i-1][0]+1,gr[i][1]=gr[i-1][1],gr[i][2]=gr[i-1][2];
		int lim=days[gr[i][1]];
		if(gr[i][1]==2&&gr[i][2]%4==1&&(gr[i][2]%100!=17||gr[i][2]==17)) lim++;
		if(gr[i][0]>lim) gr[i][0]=1,gr[i][1]++;
		if(gr[i][1]>12) gr[i][1]=1,gr[i][2]++; 
	}
	while(T--)
	{
		long long x;
		scanf("%lld",&x);
		if(x<BC)
		{
			int y=4713-x/Y4*4;x%=Y4;
			printf("%d %d %d BC\n",ju1[x][0],ju1[x][1],y-ju1[x][2]);
		}
		else if(x<To_1582)
		{
			x-=BC;
			int y=1+x/Y4*4;x%=Y4;
			printf("%d %d %d\n",ju2[x][0],ju2[x][1],y+ju2[x][2]);
		}
		else if(x<To_1583)
		{
			x-=To_1582;
			printf("%d %d 1582\n",d[x][0],d[x][1]);
		}
		else
		{
			x-=To_1583;
			long long y=1583+x/Y400*400;x%=Y400;
			printf("%d %d %lld\n",gr[x][0],gr[x][1],y+gr[x][2]);
		}
	}
	return 0;
}
```