## 定位

CSP2020 S 组 T1，实属一道耗时耗脑的大模拟题。~~本蒟蒻在赛时模拟了三个小时才拍过大样例。~~

## 准备

首先，对于大模拟题，我们应当准备一些可能会用到的常量、函数等。例如，$1 \sim 12$ 月的天数和闰年的判断就是极其重要的。

为了更快地推算后面的日期，像每年有 $365 / 366$ 天，每 $4$ 年有 $1461$ 天，每 $400$ 年有 $146097 / 146100$ 天诸如此类的数据都可以当做常量。

放眼观瞧数据范围，发现第 $10$ 个测试点的年份是小于 $10^9$ 的。这样一来，输入的天数将达到 $(4713+10^9) \times 365.24 \gt 2^{31}$，将超出 `int` 存储范围。

为了方便，不妨将大部分变量类型定义为 `long long`。

```cpp
const long long _400y[2]={146100,146097};
//保存不同历法的400年所对应的天数
const long long _4y=1461;
//4年对应的天数
const long long D[13][2]=
{{0,0},{31,31},{28,29},{31,31},{30,30},
{31,31},{30,30},{31,31},{31,31},{30,30},
{31,31},{30,30},{31,31}};
//保存非闰年/闰年每个月的天数
long long day1[370][2][2],day2[13][35][2];
//day1[i][0/1][0/1]保存一年第i天对应的月、日
//day2[m][d][0/1]保存月、日对应一年中的第几天
void init()
{
    for(int i=0;i<=1;i++)//对非闰年（0）和闰年（1）进行枚举
    {
        for(int m=1,x=1;m<=12;m++)//在1~12月之间枚举，x为当前的天数
        {
            for(int d=1;d<=D[m][i];d++,x++)
            {
                day1[x][0][i]=m;
                day1[x][1][i]=d;
                day2[m][d][i]=x;
            }
        }
    }
}
bool leap1(long long y)//现行的闰年判断法则
{
    if(y%400==0)return true;
    if(y%100==0)return false;
    if(y%4==0)return true;
    return false;
}
bool leap2(long long y)//儒略历法闰年判断
{
    if(y<0)y=-y-1;
    return (bool)(y&3)^true;//y&3 等同于 y%4
}
```

## 思路

这道题细节不少，需要对不同的时间段进行讨论，大致可分为以下几种：

1. 公元前 $4713$ 年 $1$ 月 $1$ 日 $\sim$ 公元前 $1$ 年 $12$ 月 $31$ 日

2. 公元 $1$ 年 $1$ 月 $1$ 日 $\sim$ 公元 $1582$ 年 $10$ 月 $4$ 日

3. 公元 $1582$ 年 $10$ 月 $15$ 日及以后

## 具体情况

我们来分情况进行讨论，暂且不考虑日期，先处理年份。

### 公元前 $4713$ 年 $1$ 月 $1$ 日 $\sim$ 公元前 $1$ 年 $12$ 月 $31$ 日

- 以 $400$ 年为一单位

从公元前 $4713$ 年 $1$ 月 $1$ 日 起，可以先以 $400$ 年为一个单位。由于这段时间的闰年相对不复杂，因此以 $400$ 年 $=146100$ 天进行计算即可。

当然，在这个区间内最迟能到达公元前 $313$ 年，最多可往后推 $\dfrac{4400}{400}=11$ 个 $400$ 年。

若用 $y_{x}$ 表示 $x$ 年所对应的天数，则推移的单位数 $t=\min(11, \lfloor \dfrac{r}{y_{400}} \rfloor)$，即往后推移 $t$ 个 $400$ 年。

- 以 $4$ 年为一单位
  
处理完 $400$ 年之后，我们再以 $4$ 年为一个单位，每次往后推 $4$ 年——不需要考虑整除 $100$ 方便了许多。

这里需要注意的是，若上一次推到了公元前 $313$ 年，而当前可以达到公元后，那么就必须区别对待，即保证当前的推移在公元前范围内。

若上一次的 $t$ 值为 $t_0$，则这时推移的单位数量为：

$$t=
\begin{cases}
\lfloor \dfrac{r}{y_4} \rfloor & t_0 \lt 11\cr
\min(\lfloor \dfrac{r}{y_4} \rfloor, 78) & t_0=11
\end{cases}$$

- 以 $1$ 年为一单位

一边判断剩余天数是否小于当前年的天数，一边推移年份即可，需注意闰年。

- 以 $1$ 天为一单位

前面的推移结束后，剩下的天数若小于 $365$，则可以在公元前 $1$ 年结束推移（公元前 $1$ 年为闰年）。

经过尝试~~计算~~可知，当 $r=1721423$ 时，对应日期公元前 $1$ 年 $12$ 月 $31$ 日。

### 公元 $1$ 年 $1$ 月 $1$ 日 $\sim$ 公元 $1582$ 年 $10$ 月 $4$ 日

可将 $r$ 的值减去 $1721424$，再用剩下的值进行推移，方法与前面类似。

- 以 $400$ 年为一单位

$t=\min(3, \lfloor \dfrac{r}{y_{400}} \rfloor)$，最多可推移到 $1201$ 年。

- 以 $4$ 年为一单位

$$t=
\begin{cases}
\lfloor \dfrac{r}{y_4} \rfloor & t_0 \lt 3\cr
\min(\lfloor \dfrac{r}{y_4} \rfloor, 95) & t_0=3
\end{cases}$$

最多可推移到 $1581$ 年。

- 以 $1$ 年为一单位

视 $r$ 的情况而定。

经过这样的推移，我们可知当 $r=2299160$ 时，对应日期公元 $1582$ 年 $10$ 月 $4$ 日。

### 公元 $1582$ 年 $10$ 月 $15$ 日及以后

由于 $1582$ 年 $10$ 月 $4$ 日 $\sim 14$ 日被删去，因而 $r=2299161$ 对应 $1582$ 年 $10$ 月 $15$ 日。

因此，我们可以将 $r$ 减去 $2299161$，然后继续推移。

由于闰年的规则变化，因而我们不妨只以 $400$ 年为单位进行推移，然后一年一年地推移。这样最多推 $399$ 次，在推移的过程中判断天数即可。

## 代码

可以通过取 $\min$ 来判断推移时间的多少，并用特殊的数据处理来降低难度。

在调试的过程中，我们可以借助题目中的小样例检验自己的结果是否正确，同时可以记录一些特殊时间点方便判断。

特殊的时间节点：

|$r$|对应日期|备注|
| :----------: | :----------: | :----------: |
|$0$|公元前 $4713$ 年 $1$ 月 $1$ 日|儒略日原点|
|$1721423$|公元前 $1$ 年 $12$ 月 $31$ 日|用来特判|
|$1721424$|公元 $1$ 年 $1$ 月 $1$ 日|用来特判|
|$2299160$|公元 $1582$ 年 $10$ 月 $4$ 日|使用儒略历的最后一天（~~它SPFA的日子~~）|
|$2299161$|公元 $1582$ 年 $10$ 月 $15$ 日|使用格里高利历的第一天，并开始使用新的闰年制|
|$2459161$|公元 $2020$ 年 $11$ 月 $7$ 日|CSP2020 第二轮举行|
|$365244221425$|公元 $10^9$ 年 $12$ 月 $31$ 日|本题 $r$ 可能出现的最大值，解释了为什么需要开 `long long`|

经过略微修改的赛时 `AC` 代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
long long Q,day1[370][2][2],day2[13][35][2],r;
const long long _400y[2]={146100,146097},_4y=1461;
const long long D[13][2]={{0,0},{31,31},{28,29},{31,31},{30,30},{31,31},{30,30},{31,31},{31,31},{30,30},{31,31},{30,30},{31,31}};
bool leap1(long long y)
{
    if(y%400==0)return true;
    if(y%100==0)return false;
    if(y%4==0)return true;
    return false;
}
bool leap2(long long y)
{
    if(y<0)y=-y-1;
    return bool(y&3)^true;
}
void init()
{
    for(int i=0;i<=1;i++)
    {
        for(int m=1,x=1;m<=12;m++)
        {
            for(int d=1;d<=D[m][i];d++,x++)
            {
                day1[x][0][i]=m;
                day1[x][1][i]=d;
                day2[m][d][i]=x;
            }
        }
    }
}
void pr(long long y,long long m,long long d)//输出日期的函数
{
    printf("%lld %lld ",d,m);
    if(y<0)printf("%lld BC\n",-y);
    else printf("%lld\n",y);
}
int main()
{
    init();
    scanf("%lld",&Q);
    while(Q--)
    {
        long long Y=-4713,M=1,D=1,t;
        scanf("%lld",&r);
        if(r==1721423)//本程序若不特判，则会输出 0 0 1
        {
            puts("31 12 1 BC");
            continue;
        }
        if(r<1721423)//[1 1 4713 BC, 30 12 1 BC]
        {
            t=min(11LL,r/_400y[0]);
            r-=t*_400y[0];
            Y+=t*400;
            if(t==11LL)t=min(78LL,r/_4y);
            else t=min(99LL,r/_4y);
            r-=t*_4y;
            Y+=t<<2;
            long long f=leap2(Y),date1=day2[M][D][f];//处理剩余的 365/366 天
            t=min(r,364+f);
            r-=t;
            M=day1[date1+t][0][f];
            D=day1[date1+t][1][f];
            while(r)
            {
                Y++;
                M=D=1;
                r--;
                f=leap2(Y);
                date1=day2[M][D][f];
                t=min(r,364+f);
                r-=t;
                M=day1[date1+t][0][f];
                D=day1[date1+t][1][f];
            }
        }
        else if(r<=2299160)//[1 1 1, 4 10 1582]
        {
            r-=1721424;
            Y=M=D=1;
            t=min(3LL,r/_400y[0]);
            r-=t*_400y[0];
            Y+=t*400;
            if(t==3LL)t=min(95LL,r/_4y);
            else t=min(99LL,r/_4y);
            r-=t*_4y;
            Y+=t<<2;
            long long f=leap2(Y),date1=day2[M][D][f];
            t=min(r,364+f);
            r-=t;
            M=day1[date1+t][0][f];
            D=day1[date1+t][1][f];
            while(r)
            {
                Y++;
                M=D=1;
                r--;
                f=leap2(Y);
                date1=day2[M][D][f];
                t=min(r,364+f);
                r-=t;
                M=day1[date1+t][0][f];
                D=day1[date1+t][1][f];
            }
        }
        else if(r<=2299238)//[15 10 1582, 31 12 1582]
        {
            r-=2299150;
            Y=1582,M=10,D=4;
            long long f=leap1(Y),date1=day2[M][D][f];
            t=min(r,364+f);
            r-=t;
            M=day1[date1+t][0][f];
            D=day1[date1+t][1][f];
            while(r)
            {
                Y++;
                M=D=1;
                r--;
                f=leap1(Y);
                t=min(r,364+f);
                r-=t;
                M=day1[t+1][0][f];
                D=day1[t+1][1][f];
            }
        }
        else//[31 12 1582, ∞)
        {
            r-=2299238;
            Y=1583;
            t=r/_400y[1];
            r-=t*_400y[1];
            Y+=t*400;
            if(!r)//专门针对 0 月 0 日的特殊情况
            {
                pr(Y-1,12,31);
                continue;
            }
            while(true)
            {
                long long f=leap1(Y);
                if(r<=365+f)
                {
                    pr(Y,day1[r][0][f],day1[r][1][f]);
                    break;
                }
                else Y++,r-=365+f;
            }
            continue;
        }
        pr(Y,M,D);
    }
    return 0;
}
```