### 题意

定义一个序列是**几乎上升的**，当且仅当它不包含三个连续的元素 $x,y,z$ 满足 $x\geq y\geq z$。

有一个长度为 $n$ 的序列，给出 $q$ 个询问，每次询问 $l,r$，表示询问 $a_l,a_{l+1},a_{l+2},\cdots a_r$ 组成的序列中**最长的几乎上升子序列长度**。

### 思路

下文令 $a_l,a_{l+1},a_{l+2},\cdots a_r$ 组成的序列为 $b$。

下文说长度大于等于 $3$ 的极长的单调不递增子段为**坏子段**。

我们不妨先考虑如何在 $O(n)$ 时间内得到一个序列 $b$ 的答案。要算出最长上升子序列长度，就意味着需要删除最少的元素数量。我们可以把 $b$ 序列中所有坏子段拿出来，这些子段都妨碍了我们将 $b$ 变为一个几乎上升的序列。

能够发现因为我们拿出来的这些子段都是极长的，所以这些子段互不相交。

那么我们考虑每一个子段，对于一个子段，很显然其中只能留下两个元素，否则仍然无法满足约束。虽然删去一些元素后很多原本不相邻的元素会变得相邻，但是可以发现，只要对于某一个子段留且仅留下首尾两个元素就不会在删完之后再次出现反例。因为首元素的前一个元素必然小于它，而尾元素的后一个元素必然大于它，无论如何都不可能存在一个包含这两个元素其中之一的反例。

那么如何加快速度呢？

首先我们可以先求出原本 $a$ 序列中的坏子段。然后可以发现，在 $[l,r]$ 区间中，包含若干完整的坏子段。很显然，我们可以前缀和每个坏子段的长度减掉 $2$，然后在查询中快速得到所有完整坏子段中需要删去的元素数量。

而 $l,r$ 可能也归属于一个坏子段，因此要对两边进行统计，如果两边也存在于坏字段中，并且这个坏子段在 $[l,r]$ 内的部分的长度大于等于 $3$，就也需要删去其在 $[l,r]$ 内的部分的长度减去 $2$ 个元素。

加在一起就可以得到最少要删去的元素个数，用区间长度减掉就可以得到最长几乎上升子序列长度。

### 代码

在代码实现中为了方便，我们可以将所有元素先分成一堆极长的单调不递增子段，但注意在统计答案时，只有长度大于等于 $3$ 的这样的子段才能贡献。

```
int n,q;
int a[N];
int sum[N];
vector <pii> seq;
int lst=1;
int now=1;
int bel[N];
int main(){
    ios::sync_with_stdio(false);
    cin>>n>>q;
    fr1(i,1,n){
        cin>>a[i];
    }
    seq.pb(0,0);
    fr1(i,1,n-1){
        if(a[i]>=a[i+1]){
            now++;
        }
        else{
            fr1(j,lst,now){
                bel[j]=seq.size();//记录下每个元素归属于哪个极长的单调不递增子段
            }
            seq.pb(mp(lst,now));
            lst=now=i+1;
        }
    }
    fr1(j,lst,now){
        bel[j]=seq.size();
    }
    seq.pb(mp(lst,now));
    fr1(i,1,seq.size()-1){
        sum[i]=sum[i-1]+(seq[i].se-seq[i].fi+1>=3?seq[i].se-seq[i].fi-1:0);
    }//对坏子段中需要删去的元素数量垒前缀和，如果不坏则记为0
    while(q--){
        int l,r;
        cin>>l>>r;
        if(bel[l]==bel[r]){//归属于同个极长单调不递增子段
            cout<<min(2,r-l+1)<<endl;
            continue;
        }
        int lef=seq[bel[l]].se-l+1;//拿出包含l的极长的单调不递增子段在[l,r]内的部分的长度
        if(lef<3){
            lef=0;
        }
        else{
            lef-=2;
        }//算出要删掉多少元素
        int rig=r-seq[bel[r]].fi+1;//拿出包含r的极长的单调不递增子段在[l,r]内的部分的长度
        if(rig<3){
            rig=0;
        }
        else{
            rig-=2;
        }//同理
        cout<<r-l+1-(sum[bel[r]-1]-sum[bel[l]]+lef+rig)<<endl;//前缀和相减得到完整坏子段的贡献，加上两边的贡献得到删去元素的最小数量，再用区间长度减掉
    }
    ET;
}
```

[AC 记录](https://codeforc.es/contest/1818/submission/203929990)