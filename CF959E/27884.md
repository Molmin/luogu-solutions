我的解法和楼上的大佬是一样的，虽然我觉得这个结论是比较显然的，不过还是~~口胡~~证明一下比较好

因为所有节点之间的边等于节点编号的异或，所以权为$2^k$次的边连接的两个数二进制上只有第$k-1$位不同。

我们然后想普通的最小生成树题是怎么做的。

最小生成树算法比较常用的有$prim$和$kruskal$。

其中$kruskal$是将所有边中最小的一条一条加入。

我们先来考虑加入权为$2^k$的边:

对于每一个$x$，一定都可以分解成$a_0*2^0+a_1*2^1+…+a_k*2^k+…+a_n*2^n$。

对于它的权为$2^k$的边连接的一定是$a_0*2^0+a_1*2^1+…+(a_k\quad xor\quad1)*2^k+…+a_n*2^n$。

因为权值小于$2^k$的边都已近加入过了，所以$a_k*2^k+…+a_n*2^n$与$a_0*2^0+a_1*2^1+…+a_k*2^k+…+a_n*2^n$一定是有边连接的。

所以这条边是可以被$a_k*2^k+…+a_n*2^n$与$(a_k\quad xor\quad 1)*2^k+…+a_n*2^n$所代替的。

所以每$2^{k+1}$个点需要加入一条$2^k$的边。

然后我们再来考虑权值不是$2^k$的边：

假设一条边权值为$x$，我们可以把它表示成$b_0*2^0+b_1*2^1+…+b_k*2^k+…+b_n*2^n$。

它连接的是$a_0*2^0+a_1*2^1+…+a_n*2^n$和$(a_0\quad xor\quad b_0)*2^0+(a_1\quad xor\quad b_1)*2^1+…+(a_n\quad xor \quad b_n)*2^n$

设$k$最大的不为0的$a_i$为$a_k$，那么所有小于$2^k$的边都被加入过了。然后理由同上，这条边一定是没有用的。

然后我们只要将所有$2^k$的边加起来就好了。

代码：
```
#include <iostream>
#include <cstdio>

#define ll long long

using namespace std;

ll n,ans;

int main(){
    ios::sync_with_stdio(false);
    cin>>n;
    ll now=1;
    while(n!=1){
        ans+=(n/2)*now;
        n=n/2+n%2;
        now*=2;
    }
    cout<<ans<<endl;
    return 0;
}

```