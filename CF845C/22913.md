~~为什么看到楼下的聚聚们用了我不会的算法[可怜]~~

让本蒟蒻来一发简介易懂的代码

## 接下来是正题
看到这道题,想必大家的第一反应是贪心.

因为只有两台电视可以同时工作,所以我们用now1,now2来表示当前电视的**最早可以没事干的时间**.

但是这样的话,我们要保证节目的时间是**有序**的,这样才能处理**最早可以没事干的时间**

~~由于我的语言能力过差~~

想必大家还没有听懂我这一句话的意思...

那我们根据样例来解释一下我这句话的意思

### (假装是样例1)
3

1 2

2 3

4 5

~~我们发现了这个样例是有序的,所以我们可以先不用排序~~

然后我们发现第一个节目是1~2,然后这个时候两台电视都是空着的,所以我们~~假装~~现在第一台电视在放第一个节目,然后这样的话就可以不用管,所以**当前的now1=2**.

接下来我们发现第二个节目是2~3,然后由于题意,我们不能在某一个瞬间切换节目,所以说我们需要使用第二台电视,所以**当前的now2=3**.

最后我们发现第三个节目是4~5,我们可以发现,第一台电视已经结束第一个节目播放了(即a[i].l>now1)!那么我们可以发现,~~用第一台电视就可以了对吧~~.所以所以**当前的now1=5**

最后发现这整个过程中都没有出现不合法的时候

## 然后我们这道题就做完啦!

接下来是代码(码风极丑):
```
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;
int n,now1,now2;
struct node
{
	int l,r;
}
a[200010];
bool cmp(node x,node y)
{
	return x.l<y.l||(x.l==y.l&&x.r<y.r); //这里的话就是我们的排序,由于我太蒻不喜欢三目运算符...
}
int main()
{
	scanf("%d",&n);
	for (int i=1;i<=n;i++)
		scanf("%d%d",&a[i].l,&a[i].r);
	sort(a+1,a+n+1,cmp);
	now1=-1;now2=-1; //如果初始赋为0的话,会咕,本人就在这里咕了一次(逃)
	for (int i=1;i<=n;i++)
	{
		if (a[i].l>now1) //这里的话是第一个判断,毕竟我们多用用第一台电视是没有问题的对吧
			now1=a[i].r;
		else
		if (a[i].l<=now1) 
			if (a[i].l>now2)
				now2=a[i].r;
			else
			{
				printf("NO\n"); //这里的话是出现不合法的瞬间,我们直接判掉就可以了
				return 0;
			}
	}
	printf("YES\n");
	return 0;
} 
```