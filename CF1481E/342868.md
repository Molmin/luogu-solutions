# 题解

- 此题 $n$ 较大，考虑 $O(n)$ 的解法。

- 我们肯定会想到动归，由于移动的书不好用于转移，所以我们定义 $dp_i$ 为以 $i$ 开头的后缀中不移动的书数量的最大值。

- 我们还要记录颜色 $a_i$ 出现的第一个位置与最后一个位置 $st_{a_i},ed_{a_i}$，以及后缀中颜色 $a_i$ 的数量 $cnt_{a_i}$。

- 考虑如何转移。首先，如果要将这本书一道末尾，那么 $dp_i=dp_{i+1}$。然后我们再分两种情况考虑：

1.  这本书的颜色 $a_i$ 是颜色 $a_i$ 第一次出现的地方，那么我们可以将其与最后一次出现的位置之间异色的书移走，状态转移方程为：$dp_i=\max(dp_i,cnt_{a_i}+dp_{ed_{a_i}+1})$；

1. 如果不是，那么我们将后缀中的全部已到末尾，这样才是更优的，状态转移方程为：$dp_i=cnt_{a_i}$。

- 由于是从后往前推，而且状态设计是不动的书的最大值，所以最后的答案为：$n-dp_1$。

# 代码

```cpp
#include <bits/stdc++.h>

using namespace std;

int n, a[500005], st[500005], ed[500005], cnt[500005], dp[500005];

int main()
{
	cin >> n;
	for (int i = 1 ; i <= n ; i ++)
	{
		cin >> a[i];
		if (!st[a[i]])
		{
			st[a[i]] = i;
		}
		ed[a[i]] = i;
	}
	for (int i = n ; i >= 1 ; i --)
	{
		dp[i] = dp[i + 1];
		cnt[a[i]] ++;
		if (i != st[a[i]])
		{
			dp[i] = max(dp[i], cnt[a[i]]);
		}
		else
		{
			dp[i] = max(dp[i], dp[ed[a[i]] + 1] + cnt[a[i]]);
		}
	}
	cout << n - dp[1];
}
```
