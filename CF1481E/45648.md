# CF1481E Sorting Books

题解有一个地方没说清楚，我下面补充。

预处理出每种颜色的最左最右位置 $l_i,r_i$，考虑动态规划处理题目的对偶问题，最多能保留几个不移动。令 $dp_i$ 为后缀 $suf_i$ 即 $a(i,n)$ 中能不动书数目的最大值。

**转移：**

考虑到第 $i$ 个位置

1. $i$ 是这个颜色的左端点，可以把和右端点之间的异色书移走，有转移 $dp_i\leftarrow cnt_{a_i}+dp_{r_{a_i}+1}$。
2. 如果不是，$cnt_{a_i}$ 为后缀中颜色为 $a_i$ 的数目。下面就是我要**补充**的地方。现在有一个方案是保留后缀中颜色为 $a_i$ 的不动，移动其他的，那么要移动多少？由于 $i$ 不是右端点，所以后续过程中在 $i$ 前面且跟 $i$ 同色的要跟 $i$ 相邻的话，必须一起移到后面，然后再把 $suf_i$ 中所有异色的再移出来。所以才有了转移 $dp_i\leftarrow cnt_{a_i}$，也就是其它全部移走的意思，这里有一个费用提前计算的思想。
3. 如果要移动当前的书，转移 $dp_i\leftarrow dp_{i+1}$。

由于要移动的最少，那么要保留的最多，所有转移取一个最大值。

这里再给出一组样例供理解第二点，**2 3 4 5 6 2 2 8**答案**2**。

### code
```cpp
const int N=1e6;
int n,m;
int a[N],dp[N],l[N],r[N],cnt[N];
signed main(){
	read(n);fs(i,1,n){
		read(a[i]);if(!l[a[i]])l[a[i]]=i;
		r[a[i]]=i;
	}
	fn(i,n,1){
		dp[i]=dp[i+1];
		++cnt[a[i]];
		if(i!=l[a[i]])dp[i]=max(dp[i],cnt[a[i]]);
		else dp[i]=max(dp[i],cnt[a[i]]+dp[r[a[i]]+1]);
	}
	printf("%d",n-dp[1]);
	return 0;
}
```