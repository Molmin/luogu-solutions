这是我的第一篇RemoteJudge的题解，也是第一篇作为一道题第一篇题解的题解，更是我AC数上200后的第一篇题解，仅此纪念。

本来打算用这道题来作为我的第200道AC的题的，但结果却因为系统问题拖到今天变成了第201道AC的题……

下面开始正文……

题意的话，@[玉签初报明](https://www.luogu.org/space/show?uid=5464) 已经给得很清楚了：  
A君从上车起，醒a分钟再睡b分钟，如此往复。他上车后c分钟会经过目的地，这时候如果他醒着就会下车，否则就会坐过站。另外，A君坐过站后会继续坐这辆车，这辆车每60分钟转一圈。这样一来，A君在上车后60t+c(t为非负整数)分钟会经过目的地。 如果A君不能下车，请输出-1。 然而A君醒来与睡着交替的瞬间也可以下车。

我想来想去来搞不灵清怎么样才算不能下车，怕搞错就直接把while循环的继续条件设为了$ans <= 10000000$（相信有dalao能想出来的，希望可以发题解或在这篇文章后面评论，谢谢）

其它地方大概也就没什么坑点了，这是一道大水题……

具体解释见代码：
```cpp
#include<bits/stdc++.h>//万能头文件
using namespace std;
int main()
{
    int a, b, c;
    scanf("%d%d%d",&a,&b,&c);
    long long ans = 0;
    while(ans <= 10000000)
    {
        if(a >= c)//如果在这次醒着的时候到站了
        {
            printf("%d\n",ans + c);//输出一共的时间（不要忘记输出在这一趟里到站的时间）
            return 0;//结束程序
        }
        ans += a + b;//如果暂时无法到达，那么ans加上这次醒着和睡着的时间。
        c -= (a + b);//并且到达目的地的时间要减去（a+b）
        if(c < 0)//如果已经错过了
            c += 60;//再等下一趟，即+60
    }
    printf("-1\n");//无法到站
    return 0;//退出程序
}
```
希望大家不要直接粘代码。