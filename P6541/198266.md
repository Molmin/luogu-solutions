交了 100 多次，总算卡过去了。纪念一下。（我不是要卡评测！！！）

看了下题解，没有做法完全一样的。（不过跑得都比我的快

先看简单的Subtask 2 和 3。

## Subtask 2
由于是完全二叉树， $1$ 号结点到每个结点的距离都是 $O(\log n)$ 级别的。直接暴力跳即可。

参考代码：
```cpp
vst[1]=1;
if(dataType==2){
	for(int i=2;i<=n;i++){
		if(vst[i])continue;
		for(int j=1;j!=i;j=explore(j,i),vst[j]=1);
	}
}
```
## Subtask 3
树的形态是一条链，要求 `explore` 次数为 $n+\log n$ 。

由于是一条链，因此已探索的部分一定也是一条连通的链。

因此，每遇到一个新的点，从链的两端试着跳即可。

这里需要随机选点，这样期望下能让没探索的部分减少一半，因此只需要选 $\log n$ 个点就能覆盖整条链。

每个点被选中在确定方向的时候最多会浪费一次次数，总共就是 $\log n$ 次；而其他时候每次操作都有一个新的点加入，因此总次数为 $n+\log n$ ，可以接受。

参考代码：(用 `set` 和 `vector` 写的取随机数，很笨重，dalao 们可以酌情修改)
```cpp
set<int> S;
S.clear();
for(int i=2;i<=n;i++)S.insert(i);
vector<int> k;
int L=1,R=1;
while(!S.empty()){
	k.clear();
	for(set<int>::iterator it=S.begin();it!=S.end();it++)k.push_back(*it);
	int p=k[rand()%k.size()];
	int tmp=explore(L,p);
	if(vst[tmp]){
		for(int i=R;i!=p;i=explore(i,p),vst[i]=1,S.erase(i));
		R=p;
	}
	else{
		vst[tmp]=1;
		S.erase(tmp);
		for(int i=tmp;i!=p;i=explore(i,p),vst[i]=1,S.erase(i));
		L=p;
	}
}
```

## Subtask 1
树无特殊形态，要求 `explore` 次数为 $O(n\log n)$ 级别。

暴力跳肯定是不行了，要考虑如何快速在已知的树上确定一个未知结点接入的位置。

这个问题于是可以转化为：

>给定一棵树，要求确定一个点的位置。
>
>你每次可以对一个点提出询问：要求的点在询问的点的哪一棵子树里。
>
>要求询问次数 $O(\log n)$ 。

显然，每次对树的重心进行询问，就可以把问题的规模降低一半，从而在 $\log n$ 次询问中找出结果。

于是就出现了一个 [75 分做法](https://www.luogu.com.cn/record/77087446) ：对于每个未访问过的点，像前面那样找到在已知的树上的位置，然后添加一条链。

这个做法虽然满足了询问次数的条件，然而它的时间复杂度是 $O(nk)$ 的(其中 $k$ 为找点的位置并加点的次数)，因为找重心的复杂度是 $O(n)$ 的；显然一张菊花图就能把它卡到 $O(n^2)$ 。

我们发现，每次都找重心太浪费了，尤其是很多时候重心根本没有移动。

而关于重心，很容易就能想到点分树。

这里有人也许会说：

“每加入一个新点，点分树的形态就会变化，怎么维护？”

答案是，这里**并不需要维护精确的点分树**。只要大概能保证复杂度就行了。

我给出的解决方法是：每加入一定量的点，就重构一次点分树。（我确实没想到替罪羊树式的重构方法）

这个“一定量”，我在最初实现时取了 $\dfrac{n}{30}$ ，也就是说，一共会重构 $30$ 次。

这样，在不卡常的情况下，我们可以拿到 $85\sim90$ 分。

这时候，我错误的认为是前面的常数过大，去卡常；

卡了 100 次左右，终于过了；

然后我把重构的阈值从 $\dfrac{n}{30}$ 改成 $\dfrac{n}{10}$ ；

然后它一发就过了。 /oh

这就是一个悲伤的不必要的卡常故事。

[完整代码](https://www.luogu.com.cn/paste/t0r6jacw)（ [跑了 6.71 s](https://www.luogu.com.cn/record/78663554) ）（ 写了 3KB 多，太长了不放文章里了 ）