利用dfs序设状态DP。

这题最重要的地方是把题目条件翻译成人话，不难发现题目要求中选苹果的覆盖情形是若干从根出发的链组成的，**并且若取走一个苹果的费用是 $1$ ，则我们可以免费在我们最深的一条链的每一个点上各取一个苹果**。

那么我们的方案就必须取决于最深的那一条链，考虑枚举最深链，那么我们能考虑的答案来源于四部分：链上免费部分，链上付费部分，树的链左部分，树的链右部分。

后三个部分都可以考虑DP，链上显然可以背包，树的链左、链右部分我们也考虑DP。

**DFS出栈序有个有意思的性质，链左、链右部分节点的出栈序是一段连续区间（画个图）**，设出 $dp[i][j]$ 表示考虑出栈序在 $[1,i]$ 中的节点，选择 $j$ 个苹果的最大价值。


画个图分析一下一段出栈序前缀的节点的排布方式，必然是一些分散的子树，且都蹭在一条链上（画个图），且假设当前出栈序前缀是 $[1,i]$，那么 $i$ 对应的节点一定是最后一棵子树的根节点。

那么设这个根节点（当前考虑到的点）是 $x$，它有两种情况，要么选，要么不选。如果不选，那么 $x$ 子树内的点都不能选，只能够从在它之前最后一个遍历完的子树转移过来，这个子树的根节点出栈序是 $i-siz[x]$。如果选了，那么它的子树内所有节点都可以纳入考虑范围，就可以从 $dp[i-1][...]$转移来，那么可以得到如下方程：

$$ dp[i][j]=dp[i-1][j] $$
$$dp[i][j]=\max_{k=1}^{num[i]}\{dp[i-1][j-k]+k*val[x]\} $$

这个多重背包的过程可以用单调队列优化。


这样DP完，我们只要枚举完最深链，再把三个背包合并一下就好，$\mathcal{O(nk^2)}$。

明显过不了，发现瓶颈是最后合并背包的过程，考虑优化。直观上来说链左和链右都很难优化掉，考虑优化链付费部分。

我们利用题目的选苹果条件来改造一下树的结构，拆个点，把一个点 $(x,num[x])$ 拆成 $(x,1)$，和儿子 $(x',num[x]-1)$，要选大于 $1$ 个苹果的先决条件是先选了一个苹果，这也满足题目中的选苹果的父子限制关系，照样DP。

这样我们枚举最深链时不经过新点，链上苹果数都是 $1$ ，自然去掉了链付费部分，我们合并背包的过程就可以被优化，复杂度 $\mathcal{O(nk)}$。