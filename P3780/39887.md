$shadowice$已经把他的思路说的很清楚了，可以[先看一下](https://www.luogu.org/blog/ShadowassIIXVIIIIV/solution-p3780)会更好理解？

这篇主要是对[$Claris$题解](https://www.cnblogs.com/clrs97/p/7842530.html)的简单说明。与$shadowice$的做法还是有差异的（比如并没有明显用到后序遍历的性质），而且用这种写法可能跑的比较轻松？

（另外你只要想明白$f,h$是代表啥，就很好理解了...）

-----
> 问题等价于树形依赖背包，允许一条链每个点各免费取一次。

免费取一条链即$t\leq h+k$的限制。这样最优解一定会免费取了一条从叶子到根节点的链。

现在考虑一下怎么做。不妨枚举这条链（也就是枚举叶子）。

假如我们枚举的叶子是7，也就是这样：

![](https://cdn.luogu.com.cn/upload/pic/45236.png)

同样我们可以考虑这么4部分：

$(1)$ $1-4-6-7$这条链可以免费取一次

$(2)$ $1-4-6-7$这条链还可以付费取$a_i-1$次

$(3)$ 链左边的点可以各付费取$a_i$次

$(4)$ 链右边的点可以各付费取$a_i$次

-----
$(1)$只需要在叶子处算一下到根节点路径上的权值和就可以了（就是$val_1+val_4+val_6+val_7$）。

$(2)$就是对当前链做多重背包（不过每个物品的个数为$a_i-1$）。

$(3)$是对前边枚举过的非链上的点做背包。如果把邻接表反过来，$(4)$和$(3)$的求法是一样的（也是对前面的点背包）。

单是枚举叶子就是$O(n)$的了。所以我们八成需要DP预处理每个叶子处$(2)(3)(4)$三个值。

不妨DP的时候将$(2)(3)$合并到一起算，$(4)$在反转边表后再计算。

-----
> 设$f[i][j]$表示按DFS序考虑到$i$，体积为$j$的最大收益。

$f[i][j]$就是到$i$节点，已用体积为$j$，同时考虑了$(2)(3)$两种情况的最大值（只考虑了当前点到根节点的链和链左边的点）。

比如$f[7][j]$就是对$2,3,5,1,4,6,7$做完多重背包，已用体积为$j$的最大价值（背包时$1,4,6,7$的个数分别都是$a_i-1$）。

![](https://cdn.luogu.com.cn/upload/pic/45237.png)

怎么求呢？可以先看一下$Claris$的代码。

> 先放入不能免费的物品，等遍历完儿子后再放入必选的物品，那么$i$到根路径上所有点都只算了不能免费的部分。

举个例子：从$4$访问完$5$子树后，然后访问$6$，显然$f[6]$就是$f[5]$再加入$1$个$5$和$a_6-1$个$6$做一次多次背包（$5$此时就不能免费取了，因为之前是免费且必选的所以并没有计算；而$6$此时会免费取一次，最后加到链上就可以了，所以此时计算$a_6-1$个，即不能免费的）。

当然我们不能直接去修改$f[5]$这个数组，但我们可以更新数组$f[4]$，因为它不是叶子，最后就用不到它的$f$值。而且$4$的其它儿子比如$11$，也可以直接用$f[4]$更新它。

也就是我们要用$f[5]$和$1$个$5$更新$f[4]$，即$f[4][j]=\max\{f[4][j],\ f[5][j-1]+val_5\}$。

注意此时$f[5][j]$是考虑过$5$子树内的，不能直接用$f[5][j]$转移（可能一个$5$也没有选），要强制选一个$5$再转移。

然后用$f[4]$更新$f[6]$。其实就是先把$f[4]$复制给$f[6]$，然后用$f[6]$和$a_6-1$个$6$做多重背包。

那么算法流程大概是：记$v$的父节点为$x$，先把$f[x]$复制给$f[v]$，然后用$a_v-1$个$v$更新$f[v]$，递归到$v$。处理完$v$子树后，再用$f[v]$加入一个$v$做背包来更新$f[x]$，以便更新后面的子节点。

这里对$f[i]$做多重背包是$f[i][j]=\max_{k=1}^{a_i-1}\{f[i][j-k]+k*val_i\}$，可以用单调队列维护，$O(k)$更新。

-----
> 然后将DFS序翻转，设$h[i][j]$表示按DFS序考虑到$i$，体积为$j$的最大收益。

$h[i][j]$表示到节点$i$，已用体积$j$，情况$(4)$的最大价值，也就是只考虑它到根节点的链的右边的点的最大价值。

比如$h[7]$，就是对$9,10,11,8$做多重背包后的dp数组：

![](https://cdn.luogu.com.cn/upload/pic/45238.png)

> 等遍历完儿子后再放入必选的物品和不能免费的物品，那么$i$到根路径上所有点都没有算。

转移方式与$f$很类似，只是需要在遍历完$i$的子树后，才用$a_i,val_i$更新$h[i]$（这样在用$h[i]$更新子树时并没有计算当前链上的，只考虑了链右边的点）。不细说了。（和后序遍历也挺类似的？）

> 如此一来，对于每个叶子$i$，用 $f[i][j]+h[i][k-j]+$免费取一次到根节点的路径的权值 更新答案即可。

> 对于不能免费的物品，需要用单调队列优化转移。

> 时间复杂度$O(nk)$。

细节：二维数组最好用一维数组代替（注意每个点的空间是$k+1$）。其它注意一下就好了。

代码看$Claris$博客好了，感觉没多少可改的了orz。