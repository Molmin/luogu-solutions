## ~~热爱刷水题~~
### 这明明是一道暴力模拟，为啥子算法标签为~~数论~~
### 这本身就是一道为萌新而准备的题为啥大佬代码那么高深
### 我来发一篇详细的题解帮助各位萌新解答！


------------
# 思路：
#### 看到某些变量相互关联，且数据类型不同时
#### （当然数据类型一样时也可以用）
#### 我第一个想到的就是结构体
#### 有些小伙伴解决不掉输入，我会在下面代码中详解
#### 让我们愉快的读下下题——
#### 我们可以看到让输出的数仅仅是某些数运算的最小结果
#### 又看到数据范围
#### 直接确定——结构体加排序加暴力
#### ~~sort万岁，暴力万岁！~~
# 直接上代码，附带详细注释——


------------
```
#include<bits/stdc++.h>//我爱万能头
using namespace std;
struct node{
	int lu;//与莫斯科的距离
	int tong;//同学的个数（很形象吧）
	string s;//名字
	int zong;//以此地为聚会地点，各路同学门所花费的money
}a[100001];
//定义node 类型的数组
int n=0;//用与储存地点的个数
bool camp(node g,node h) // 自定义排序函数，后面sort会用到
{
 //属于结构体基本操作
	if(h.zong==g.zong)//如果两地运费相同，
   //则返回距离首都最近的那个地点
	{
		return g.lu<h.lu;
	}
	return g.zong<h.zong; //返回费用少的在前
   //以zong为条件的升序
}
int main()
{
	while(true)//开始解决读入问题
   //通过看题我们不难发现题中讲到：
   // ~~最后一个输入的是莫斯科的信息~~
   //也就是说，当输入的字符串为莫斯科时
   //或者输入的第二个变量为0时，就可以结束循环
	{
		++n;//下标从一开始
		cin>>a[n].tong>>a[n].lu>>a[n].s;//输入
		if(a[n].s=="Moscow") break;//判断是否为莫斯科
        //如果是就结束循环
	}
	for(int i=1;i<=n;i++)//开启暴力之路——150*150完全不超
  //外层循环为以第i个点为最终地点
	{
		for(int j=1;j<=n;j++)
    //内层枚举所有的地点到i地点
		{
			a[i].zong+=abs(a[j].lu-a[i].lu)*a[j].tong;
    //统计所有点到a[i]的钱
    //钱=j地点到i地点的距离 * 此地的人数 
    //因为为每人每千米花费1卢布，所以省略不乘
    //两地的距离=i点与j点到莫斯科的距离差的绝对值（大家可以画个图理解）
		}
	}
	sort(a+1,a+n+1,camp);//按照camp规则排序
	cout<<a[1].s<<" "<<a[1].zong;//输出最终答案
	return 0;//结束！
}
```


------------
管理员大大求过呀~~