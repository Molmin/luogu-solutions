# 题目大意

题目中说了一大堆，但我概括出来就这么多：一个 $a$ 行 $b$ 列的矩阵，给定 $n$ 个点的坐标，对应坐标不能走，问有几种方法？

## 题目思路

其实这就是一道深搜题，只要在深搜模板上改一改就行了。

先输入 $a$ 行 $b$ 列和 $n$ 个点不能走。$n$ 次循环，输入 $c$，$d$ 后用数组标记。然后进入深搜。深搜结束后再输出 $s$。

## 深搜思路

先判断是否达到终点，如果达到终点，$s$ 加一后，在结束这次深搜。

如果没有达到，就进行两次循环，定义 $nx$ 和 $ny$，计算出 $nx$ 和 $ny$ 后，判断有没有超出边界和这个点是否走过，如果都符合，就把这个点标记成已走过，进行下一次深搜，再把这个点标记成没走过。（回溯）

### 代码部分

```cpp
#include<bits/stdc++.h>
using namespace std;
int a,b,s=0;//a行b列的矩阵，s来记录方案数量
int dx[2]={0,1},dy[2]={1,0};//搜索的方向
int c,d;//第c行d列不能走
bool f[50][50]={false};//标记这个点是否走过的数组
void dfs(int x,int y)
{
	if(x==a&&y==b)//如果到达终点
	{
		s++;//次数加1
		return ;//结束这一次dfs
	}
	for(int i=0;i<2;i++)
	{
		int nx=dx[i]+x,ny=dy[i]+y;
		if(nx>0&&nx<=a&&ny>0&&ny<=b&&f[nx][ny]==false)
		//判断是否出界和这个点是否走过
		{
			f[nx][ny]=true;//已经走过了，标记一下
			dfs(nx,ny);//下一次dfs
			f[nx][ny]=false;//回溯
		}
	}
	return ;
}
int main()
{
	cin>>a>>b>>n;//输入a行b列和n个点不能走
	for(int i=1;i<=n;i++)
	{
		cin>>c>>d;//第c行d列不能走
		f[c][d]=true;//把这个点标记
	}
	dfs(1,1);//从第1行1列开始搜索
	cout<<s<<endl;//输出方案数
	//（AT不换行，亲人两行泪）
	return 0;
}
```
