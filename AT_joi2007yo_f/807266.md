[题目传送门](https://www.luogu.com.cn/problem/AT_joi2007yo_f)
# 观前提示
本蒟蒻没怎么写过题解，如有错误或建议，欢迎私信交流！

---
设从 $(1,1)$ 到 $(i,j)$ 的路径数为 $w(i,j)$，可以得出以下结论：

1. 若 $(i,j)$ 不能走，则 $w(i,j)=0$，因为没有任何一条路径可以到达该点；
2. 若 $(i,j)$ 能走，则 $w(i,j)=w(i,j-1)+w(i-1,j)$，具体原因见下：

因为只能向东或向北走，所以能到 $(i,j)$ 的路径必然都是从 $(i,j-1)$ 和 $(i-1,j)$ 来的，而 $(i,j-1)$ 的每条路径都只需再往东走一步就能到达 $(i,j)$，所以能从 $(i,j-1)$ 到达 $(i,j)$ 的路径数就是 $w(i,j-1)$；同理，能到 $(i-1,j)$ 的每条路径都只需再往北走一步就能到达 $(i,j)$，所以能从 $(i-1,j)$ 到达 $(i,j)$ 的路径数就是 $w(i-1,j)$。根据[加法原理](https://baike.baidu.com/item/%E5%8A%A0%E6%B3%95%E5%8E%9F%E7%90%86#1)，能到达 $(i,j)$ 的路径数就等于能从 $(i,j-1)$ 到达 $(i,j)$ 的路径数加上能从 $(i-1,j)$ 到达 $(i,j)$ 的路径数，即：$w(i,j)=w(i,j-1)+w(i-1,j)$。

此外，除非 $(1,1)$ 不能走，否则 $w(1,1)=1$。

还有一点，这是 AT 的题，输出答案时别忘了加个换行。

结合上述所有的要点，我们就可以高高兴兴地 AC 了！

---
# AC代码
~~因为递推的做法已经有大佬发过了，所以就只能写递归了QAQ~~
```cpp
#include <bits/stdc++.h>
using namespace std;
int n,a,b;
bool f[17][17];
int w(int x,int y){
	if(x<0 || x>a || y<0 || y>b){
		return 0;
	}
	if(f[x][y]){
		return 0;
	}
	if(x==1 && y==1){
		return 1;
	}
	return w(x,y-1)+w(x-1,y);
}
int main(){
	cin>>a>>b;
	cin>>n;
	for(int i=1;i<=n;i++){
		int t1,t2;
		cin>>t1>>t2;
		f[t1][t2]=1;
	}
	cout<<w(a,b)<<endl;
	return 0;
}

```
感谢观看！