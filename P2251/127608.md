# 单调队列

#### 概念：

一种具有单调性的队列，即单调递减或单调递增。

#### 操作：

不断向队列内读入新元素，并实时更新队列，去掉最老值或加入最新值，不定期查询当前区间内的最小/大值。

#### 作用：

查询当前区间内的最小值或最大值。


### 那么我们该怎么实现它呢？

就用样例模拟一遍：

1. 队列为空，直接让16进队，此时q={16}

2. 下面读入5，队尾元素大于5，说明只要有5，那么16就不可能是最小值，16从队尾出列，5则进队，此时q={5}

3. 下面读入6，队尾元素小于6，但是如果接下来3个数都比6大，那么6还是有可能成为最小值的，所以6进队，此时q={5，6}

4. 下面读入9，同上，9入队，此时q={5,6,9}

5. 下面读入5，同上，6、9出队，5进队，此时q={5,5}

6. 下面读入13，因为现在的队首已经不在区间内了，直接将队首弹出，然后同上，13加入队列，此时q={5，13}

7. 同上同上……

8. 然后输出就是每移动一次区间就输出队首就可以了。

## 代码如下：

```cpp
#include <bits/stdc++.h>

using namespace std;

int n, m;

int q1[1000001];//q为a数组内元素的下标

int a[1000001];

int min_deque() {
    int h = 1, t = 0;
    for (int i = 1; i <= n; i++) {
        while (h <= t && q1[h] + m <= i) h++; //如果队首元素已经不在区间内，弹出
        while (h <= t && a[i] < a[q1[t]]) t--; //如果队尾元素大于新元素，弹出
        q1[++t] = i;//新元素入队
        if(i >= m) printf("%d\n", a[q1[h]]);//输出当前区间的最小值
    }
}

int main() {
    cin >> n >> m;
    for (int i = 1; i <= n; i++) scanf("%d", &a[i]);
    min_deque();
    return 0;
}
```



------------
## 感谢！
