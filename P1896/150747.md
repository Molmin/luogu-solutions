看到这道题的第一眼，我就想到了著名的八皇后问题，当时是用搜索做的。但是
********************but********************
八皇后只有八个位置可以用来放置，本问题却最多达9*9，所以用搜索复杂度可能高了些。
于是我们想到了状压动归。
    因为每行可以放置多个国王，我们用状压的思想，把每行的状态压缩成一个数来表示，这是很多与棋盘有关题目的处理方法，二进制1表示放置了一个国王，二进制0表示空位。先不考虑上下行的攻击情况，对于每一行来说，我们可以预处理出所有可行的状态记录所有的可行状态。
```
void yu()//预处理
{
	int all=(1<<m)-1;//一行中所有可能的情况
	for(int i=0;i<=all;i++)
	{
		if(!(i&(i<<1)))//如果不和左右冲突
		{
			s[++cnt]=i;//记录状态
			int x=i;
			while(x) x-=lowbit(x),sum[cnt]++;//记录每种情况所需国王数
		}
	}
}//lowbit(x)是x的二进制表达式中最低位的1所对应的值
```
动态规划解题：
    按行划分阶段；
    建立状态dp[i][j][k],表示的意义是前i行中，第i行状态为s[j]（j属于[1,cnt]时，前i行一共放置了k个国王的方案数，状态转移方程为：
    dp[i][j][k]=sigma(d[i-1][p][k-sum[j]]）
枚举第i-1行的可行状态s[p],当s[p]与s[j]不互相攻击时，满足上面的状态转移方程，很显然要求k>=sum[j]。
     最后的所求为sigma(dp[m][i][k]),i属于[1,cnt],dp[0][1][0]初始化为1。
```
bool Is_safe(int shang,int xia) 
{
	if( (shang&xia) || ((shang>>1)&xia) || ((shang<<1)&xia) ) return false;
	//  相邻的上方       相邻的左上方        相邻的右上方 
	return true;
}
 
void DP()
{
	dp[0][1][0]=1;//初始化 
	for(int i=1; i<=N; i++)//枚举行，按行划分阶段 
		for(int j=1; j<=cnt; j++)//枚举可行的行状态 
			for(int k=0; k<=K; k++)//枚举国王
			{
				if(sum[j]>k) continue;//前面的i-1行无国王可放 
				for(int p=1; p<=cnt; p++)
					if(Is_safe(s[p],s[j]))
						dp[i][j][k]+=dp[i-1][p][k-sum[j]];
			}
	return;
}
 
```
