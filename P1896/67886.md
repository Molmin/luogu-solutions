### 这一题是刚学状压的时候写的，借鉴了第一篇题解的处理方式。
- 写过一些题目，还是对状压有些理解，因为这一题n的值特别小，计算了一下$2^9$，发现不超过2000，而且如果用$dfs$好像也不怎么好，所以试着写了一下状压。这种压缩的方法十分明显，枚举每一行的状态，用二进制表示，如果该位有0（最低位为1），那么这一行的这一列上就有放国王，如果是0就没有放。考虑到怎么从上一行转移过来，设$f[i][j][k]$为第i行为止，第j种情况，目前为止一共使用了k个国王的方案数（注意：这里的j并不是二进制的状态，而是第j种我们求出的状态！！！我是将状态存储在$zt[\ ]$数组中的！！请认真看代码）。因为我们如果需要做这一行，只和上一行有关（有点像八皇后呢）。如果上一行的状态为第l种，且这两种状态是可以相容的，那$f[i][j][k]+=f[i-1][l][k-use[j]]$。注明一下：$use[i]$存储的是第i种情况需要消耗的国王数量，我们目前消耗的国王减去这一行消耗的国王数量就是上一行为止国王的总数。
- 还有一点，就是怎么判断两种状态相容，我们设两种状态为$zt[i]$和$zt[j]$，如果我们上下两行同个位置中没有国王，而且相邻位置也不能有两个国王，这样的状态才是相容的，所以处理相邻的办法就是判断($zt[j]<<1$)&$zt[k]==0$还有($zt[j]>>1$)&$zt[k]==0$和$zt[j]$&$zt[k]==0$这样就判断了上面的三种情况。
```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#include<algorithm>
using namespace std;
int n,m,use[200010],zt[200010],tot;
long long f[11][2048][100],ans=0;
void dfs(int x,int y,int num)//预处理每一行可行的情况
{
        if(num==n)
        {
            use[++tot]=y;
            zt[tot]=x;
            return ;
        }
        if((x&1)==0)
            dfs((x<<1)+1,y+1,num+1);
        dfs((x<<1),y,num+1);
}
int main()
{
        cin>>n>>m;
        dfs(0,0,0);
        f[0][0][0]=1;
        for(int i=1;i<=n;i++)
            for(int j=0;j<tot;j++)
                for(int k=0;k<tot;k++)//注意，一定不能取tot，最后一种情况是0，已经和第0种重复了!!!
                    if((zt[j]&zt[k])==0&&(zt[j]&(zt[k]<<1))==0&&(zt[j]&(zt[k]>>1))==0)
                        for(int l=use[j];l<=m;l++)
                            f[i][j][l]+=f[i-1][k][l-use[j]];//转移
        for(int i=0;i<tot;i++)
            ans+=f[n][i][m];//最后一行可以是任意的情况
        cout<<ans;
        return 0;
}
```
