# 一个状压DP

首先 先解释一下状压是什么吧 对于这种类型的题 每个点 都只存在两种情况 即为放了东西 没放东西 （这里先解释一下为什么不可以把状态设为每一个点 因为 如果设为每一个点的话 状态很不好转移 下一个点的位置无法确定）那么 我们就可以把放了东西定为1 没放东西定为0 于是 我们便可以得到类似“0 1 0 1”这样的一个状态（这里我们只模拟了一行的状态） 而这样的一个状态“0 1 0 1” 可以把他看作一个二进制数 我们也就可以很轻松的把他转换为一个10进制数 即5 那么 这个十进制数5 就可以表示这样的一个“0 1 0 1”的状态 也就是说 我们把这样的一个状态压缩到了一个十进制数里面 也就是状态压缩了

而我们的DP 就是通过状态的转移来进行计算 那么我们这个时候 所需要存储的状态 就会变成一个数 避免了原先一整行的摆放情况难以存储的问题

于是我们看回这道题 首先 它就是刚刚讲过的 是一个判断摆放情况的题 而且 他的数据范围很小（数据范围大了 状压就不一定能做了 因为它有一个进制的转换） 所以 可以判断出来 这是一道状压DP

那么 我们就可以设状态为每一行的摆放情况 f(i,j,k) 用来表示 第i行 摆放情况为j 截止当前行 使当前状态下一共摆放的个数为k的情况总数

那么 他的状态怎么转移呢 因为它本质上是一个放或不放的题 所以他的动态转移方程类似于01背包 

即 f[i][j][k]=f[i][j][k]+f[i-1][t][k-第i行放了的个数] 其中 t为第i-1行的状态

那么我们只需要枚举行 枚举该行状态 枚举上一行状态 再判断一下两状态是否冲突 然后再统计答案就好啦

先放上代码 看不懂的话后面有解释的（~~但我jio得我已经讲清楚了~~）

```cpp
#include<iostream>
#include<cmath>
#include<cstring>
using namespace std;
int n,k;
long long f[10][2000][100];
int a[2000];
int b[2000];

int sum1(int x){
	int ans=0;
	while(x){
		ans++;
		x-=x&-x;
	}
	return ans;
}

int checkh(int x){
	int t=x&1;
	while(x){
		
		x=x/2;
		
		if(x&1==t && t==1){
			return 0;
		}
		t=x&1;
	}
	return 1;
}

int main(){
	cin>>n>>k;
	for(int x=0;x <= (1<<n)-1;x++){	
		int bol=checkh(x);
		if(bol){
			int yi=sum1(x);	
			a[x]=yi;
			f[1][x][a[x]]=1;
		}
		else{
			b[x]=1;
		}
	}
	for(int i=2;i<=n;i++){
		for(int x=0;x <= (1<<n)-1;x++){
			if(!b[x]){
				int gs1=a[x];
				for(int y=0;y<=(1<<n)-1;y++){
					if(!b[y]){
						if((x&y)==0&&(x&(y<<1))==0&&(x&(y>>1))==0){
							for(int s=k;s>=gs1;s--){
								f[i][x][s]+=f[i-1][y][s-gs1];									
							}
						}				
					}
				}				
			} 
		}
	}
	long long cut=0;
	for(int x=0;x<=(1<<n)-1;x++){
		if(!b[x]){
			cut+=f[n][x][k];
		}		
	}
	cout<<cut;
	return 0;
} 
```


DP部分较为简单 我就再啰嗦一下预处理把 

首先 如何枚举状态 比如一个3 * 3的棋盘 那么某一行的状态中 值最大的状态为“1 1 1” 这个状态怎么来的呢 它可以是由“1 0 0 0 ”-1得到 那么 我们只需要根据棋盘的规模n 推出形如“1 0 0 0 ”这样的数 然后再-1 就可以得到状态的最大值啦 这里我们就需要用到位运算 左移<< 比如当n=3 时 “1 0 0 0”就可以由1向左移动3位得到 所以就有了(1<<n)-1这个式子去求状态的最大值 然后再枚举就好啦 
```cpp
for(int x=0;x <= (1<<n)-1;x++)
```

然后 枚举完状态 我们需要判断一下状态的合理性 因为这里我们只考虑一行 所以 只需要不存在两个连续的“1”即为合理 那么我们就可以进行逐位比较 我们每一次可以用“x&1”取出x的最后一位 然后再将x右移 取其当前末尾值 然后比较就OK啦 代码如下

```cpp
int checkh(int x){
	int t=x&1;
	while(x){
		
		x=x/2;//右移和÷基本是等效的
		
		if(x&1==t && t==1){
			return 0;
		}
		t=x&1;
	}
	return 1;
}
```
还有就是如何得到状态中有几个“1”
这里我们用到了一个树状数组中必用的东西 lowbit 即为x&-x
 这个东西有什么用呢 就是取出x的最后一个1所在位置 具体的证明啊什么的我写不动了 可以自己再去看看树状数组 [树状数组模板题](https://www.luogu.org/problem/P3374)
 下面是代码
 ```cpp
int sum1(int x){
	int ans=0;
	while(x){
		ans++;
		x-=x&-x;
	}
	return ans;
}
```
然后 这里我用了两个数组a和b 分别用来存这个状态里的“1”的个数和其合理性 就不用每次调用函数啦

**最后 给大家提个醒 数组一定要开够 以及 十年OI一场空 不开longlong见祖宗**