这是一道状压DP题。那么怎么判断一道题是不是状压呢？

我们老师说如果一道题他的数据很小，特别小，不要高兴，你会发现这道题一般算法解决不了，那么恭喜这90%是状压DP


------------


# 言归正传

状压的精髓就是把状态用数字表示出来，这个十进制数转化的二进制数就是这个状态

**所以这需要一定位运算基础**

~~像我这种蒟蒻还需要边码程序边看位运算是啥~~

我们用1来表示这个位置放了个国王，0表示不放

像这样

**10101001**

**00101010**

在n<=9范围内，不考虑题干，最大的情况是

(111111111)2=2^9-1;

这也就是为什么状压题数据都很小。

现在我们来看题目要求

国王能攻击到它上下左右，以及左上左下右上右下八个方向上附近的各一个格子，共8个格子。

这个国王能攻击他周围一圈人，就是要满足

**000**

**010**

**000**

我们要先考虑本行的状态要成立

成立的条件就是(i>>1)&i==0（确定左边一个不是国王）&&(i<<1)&i==0（确定右边一个不是国王）

然后注意这道题只需要放k个国王，不能多不能少，所以我们在判断的同时要看看这种状态有几个1即几个国王，大于k的删掉，小于k存储有几个

```cpp
for(int i=0;i<MAXN;i++){//MAXN为最大值
        if((!((i<<1)&i))&&(!((i>>1)&i))){
            int j=i,tl=0,pd=0;
            while(j>0){
                if(j&1) tl++;
                if(tl>k){
                    pd=1;
                    break;
                }
                j=j>>1;
            }
            if(!pd) b[i]=tl;
            else b[i]=-1;
        }
        else b[i]=-1;
    }
```

注意不成立一定不要赋值成0，这样没有办法区分是有0个（**000000000**）还是不成立

然后还要满足和上一行不冲突

上一行的状态我们认为是j

那么要满足j&i==0(他的上一个不是国王)&&(j>>1)&i==0(左上不是)&&(j<<1)&i==0(右上不是）

状态我们可以表示了现在就想转移方程

其实转移方程还是很好写的

f[i][j][k]存储前i行一共有j个国王第i行状态为k的方案数

那么f[i][j][k]+=f[i-1][j-m][l]

其中m为现在第i行状态一共有多少个国王，l为i-1行的状态

C++AC代码如下

```
#include<bits/stdc++.h>
using namespace std;
long long f[10][82][1025],ans;
int b[1025];
int main(){
    int n,k;
    cin>>n>>k;
    int MAXN=1<<n;//最大的情况是这个值-1
    for(int i=0;i<MAXN;i++){//判断程序在刚才已经出现了
        if((!((i<<1)&i))&&(!((i>>1)&i))){
            int j=i,tl=0,pd=0;
            while(j>0){
                if(j&1) tl++;
                if(tl>k){
                    pd=1;
                    break;
                }
                j=j>>1;
            }
            if(!pd) b[i]=tl;
            else b[i]=-1;
        }
        else b[i]=-1;
    }
    f[0][0][0]=1;//初值
    for(int i=1;i<=n;i++){//DP
        for(int j=0;j<=k;j++){
        for(int h=0;h<MAXN;h++){
            if((b[h]<=j)&&(b[h]!=-1)){
                for(int l=0;l<MAXN;l++){
                    if((!(h&l))&&(!(h&(l<<1)))&&(!(h&(l>>1)))&&(b[l]!=-1)){
                        f[i][j][h]+=f[i-1][j-b[h]][l];
                    }
                }
            }
        }   
        }
    }
    for(int i=0;i<MAXN;i++){
     ans+=f[n][k][i];//每种情况都要加一遍
    }
    cout<<ans;
    return 0;
}
```