## 状压DP的入门好题
**backgrand**:今天，蒟蒻Tryer在机房的DP专场考试中，抱着~~爆零~~坚定的决心，在考场上悟出了状压DP的精髓，并且没有爆零！！！


### 先安利一波常用的位运算技巧：
1.取出x的第i位:
```cpp
int main()
{
    y = (x>>(i-1))&1;
    return 0;
}
```
2.将x第i位取反:
```cpp
int main()
{
    x ^= (1<<(i-1));
    return 0;
}
```
3.将x第i位变为1：
```cpp
int main()
{
    x |= (1<<(i-1));
    return 0;
}
```
4.将x第i位变为0：
```cpp
int main()
{
    x &= (~(1<<(i-1)));
    return 0;
}
```
5.将x最靠右的1去掉：
```cpp
int main()
{
    x = x&(x-1);
    return 0;
}
```
6.取出x最靠右的1:
```cpp
int main()
{
    y = x&(-x);
    return 0;
}
```
7.判断是否有两个连续的一：
```cpp
int main()
{
    if(x&(x<<1)) cout<<"YES";
    return 0;
}
```
8.枚举子集：
```cpp
int main()
{
    for( int x = sta ; x ;  x = ( ( x - 1 )&sta) )
      cout<<x;
    return 0;
}
```
这些操作真的很常用，很好用，一定要在理解的基础上记忆，可以试着手动推导一下。


------------
### 下面进入正题

这道题很简单，想了一会一遍就过了。

#### Beginning

我们还是需要定义一个dp数组

```cpp
long long dp[11][1<<9][166];
//在第i层，状态为j时，放k个的方案数
``` 
值得一提的是，每一行的每个状态都有不同的方案数，且**与同一行的其他状态无关**

#### Next

因为第一行的比较特殊，所以我个人习惯将第一行单独提出来处理一下。

算法是，每枚举每个状态，然后判断这个状态是否满足题目条件，不符合就continue,然后我们统计这个状态存在的棋子数cnt,自然而然的，dp[1][sta][cnt] = 1;

代码如下
```cpp
for( ri sta = 0 ; sta <= ( 1<<n ) - 1 ; sta++ ){
    	bool b = false;
    	int cnt = 0;
    	//判断该状态是否合法,并统计已经放的棋子数 
    	for( ri j = 1 ; j <= n ; j++ ){
    		if( sta>>( j - 1 )&1 ) cnt++;
    		if( ( sta>>j&1 ) && ( sta>>( j - 1 )&1 ) ){
			    b = true;
				break;
			}
    	}
	    if( b ) continue;
    	dp[ 1 ][ sta ][ cnt ] = 1;
    }
```
由于我们需要判断是否有连续的棋子，所以我们可以用到上面提到的操作7,但是我们又需要统计这个状态存在的棋子数cnt,所以干脆直接一位一位地拆。

如果各位dalao有其他更好的方法，欢迎提出。

#### Next

下面会用到很多技巧

我们自然地会想到枚举每一行的每个状态，然后判断这个状态是否合法，但是最关键的状态转移又该如何进行呢？？？

我们考虑先定义一个状态fsta = (1<<n)-1;

它代表上面的每个地方都放了棋子，然后我们利用当前状态，来修改fsat，得到一个可行方案的**最大集合**，然后枚举它的**每个子集**，这样状态转移就变得异常简单了。

代码实现：
```cpp
          int fsta = ( 1<<n ) - 1;
	      if( sta&1 ){
	          fsta &= ( ~1 );
	          fsta &= ( ~2 );
	      }//特殊处理第一格 
		  for( ri j = 2 ; j <= n ; j++ )
		  	if( sta>>( j - 1 )&1 ){
		  		fsta &= ( ~( 1<<( j - 2 ) ) );
		  		fsta &= ( ~( 1<<( j - 1 ) ) );
		  		fsta &= ( ~( 1<<j ) );
		  	} 
		  //这一格如果有棋子，其上一排的正上方，左上方，右上方都要取0
	      //枚举所有子集，包括0
		  for( ri x = fsta ; 1 ; x = ( ( x - 1 ) & fsta ) ){
		  	  for( ri k = 0 ; k <= n * n ; k++ )
		  	  	dp[ i ][ sta ][ cnt + k ] += dp[ i - 1 ][ x ][ k ];
		  	  if( x == 0 ) break;
		  }//注意，因为我们需要0作为一个子集，所以与上面提到的操作8略有不同
```

#### End

**谢谢你看完蒟蒻我写的题解，虽然解法不一定很优，但是应该比较好理解吧.qwq**