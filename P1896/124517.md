# About P1896【[SCOI2005]互不侵犯】
这题真好啊！互相尊重主权和领土完整，互不侵犯，互不干涉内政，平等互利，和平共处——和平共处五项原则！！！


这题是状态压缩动态规划吧！！！

据(bol)传言，数据不过18，不是暴搜就是状压！！

------------
### 为什么暴搜不行呢？？？
首先看上去时间复杂度很玄学，很看脸，如果碰上 **某些大常数** 算法，极易死亡！！

再从空间复杂度上来看，每个点的情况有两种，如果我们记录每个点的状态，空间复杂度是大概2^n，很容易 ~~死亡~~ ！

------------
### 关于这个题的状态压缩！！
假设n=3

我们先模拟一下当前的棋盘的第一行

一开始是没有任何棋子： 000 ；

那么我们用1来表示这个位置有国王

我们先不考虑国王之间会不会互相侵犯，那么把格子放国王都有那些情况呢？

①000 、②001、 ③010、 ④011、 ⑤100、 ⑥101、 ⑦110、 ⑧111

#### 那么我们光看这一行的话，有那些情况会符合呢？

emm，如果单看这一行的话那么对于每个1来说，ta的左边和右边的都必须是0；

那么满足情况的有:

①000，②001，③010，⑤100，⑥101 这些情况

看n仅仅是3，每行可能满足就有5种了（通过打表大法n=9，每行可能的情况有89种（可能会错））那么暴力乱搞貌似………………

所以不如换个状压的想法！！

你看着着000,001,010的，他怎么这么像二进制呢！！！

对啊，二进制好啊！！！

对于每种发棋子的情况比如 010 就可以变成一个十进制数字2来储存这个状态！！

#### 这样不就极大的节省空间吗？？

#### 那么我们怎么去找符合的情况呢？

众所周知，有一种二进制运算叫做 “（&）与” 运算，即1&1=1, 0&1=0, 0&0=1

同时呢“000”&“101”=“000”， “101”&“001”=“001”（即按位与（&））

在仅看每一行种，如果这个情况n合法那么一定存在 （n&（n<<1）==0）&&n&（n&（n>>1）==0）存在，那么判断一下就可以找出每一行的所有可能情况！

#### 同时我们可以记录一下每种情况用多少国王

即每种情况对应下的二进制代码有多少位是1！

有两种方法：

第一种：暴力10进制转换二进制，除2取余法！
```cpp
	int p=0; 
   	while(w)
	{
    		if(w%2) p++;
        	w/=2;
         }
```

第二种：用bitset库的函数做


------------

**简单介绍一下bitset；**

bitset存储二进制数位。

bitset就像一个bool类型的数组一样，但是有空间优化。

bitset中的每个元素都能单独被访问，例如对于一个叫做a的bitset，表达式a[3]访问了它的第4个元素，就像数组一样。

(但是输出单独访问结果不能用printf，和bitset有关的输出都用cout)

另外bitset的大小在编译时就需要确定，也就是说bitset<>的尖括号中写的是大小。

比如 bitset <10> a(5)  ==> 输出a得 101

bitset的运算就像一个普通的整数一样，可以进行与(&)、或(|)、异或(^)、左移(<<)、右移(>>)操作。

bitset有一些函数比如：

![](https://cdn.luogu.com.cn/upload/pic/61910.png)

那么我们就可以用a.count()算出一的个数！


------------
### 那么把所有东西都预处理完了就准备dp吧！！
我们用dp[i][j][k]表示第i行，状态为j，已用国王数为k的方案数！！

乍看一眼，好像并不能怎么状态转移

那我们可以考虑一下dp[i][j][k]可以转移到哪？

我们假设状态是从第一行向下转移，那么第i+1行的状态只会影响下一行的状态（因为第i行是从i-1行转移过来的，那么在假设情况下，i不会影响i-1行）；

我们设i行的情况为j,用了k个国王，i+1行的情况为 p，这种情况要用国王w个；

在i行为j的情况下p是否合法，只取决与 对于每一个国王位置（i+1，pos）而言，（i，pos-1），（i，pos），（i，pos+1）均不能有国王；

那么可以用之前那个左右移的方法去判断p情况是否合法

即 j&p=0，j&（p<<1）=0,j&(p>>1)=0;

这样看来 dp[i+1][p][w+k]+=dp[i][j][k]

那么我们把i+1换一下：就可以得到

dp[i][p][w+k]+=dp[i][j][k]

#### 在我们预处理每行可能的情况时，把dp[1][n][k]更新为1
n为该种状态，k为所用国王！

## **于是这个题就顺利的结束了！！**
cpp代码如下：

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <bitset>
using namespace std;
int n,m,ans,tot=0;
bool vis[1<<9];
int g[1<<9],dp[10][1<<9][82];
int main()
{
	scanf("%d%d",&n,&m);
	for(register int x=0;x<(1<<n);x++)
	{
		if(!(x&(x<<1))&&!(x&(x>>1))) vis[x]=true;
		bitset <9> a(x);
		g[x]=a.count();
		if(vis[x]) dp[1][x][g[x]]=1;
	}
	for(register int i=2;i<=n;i++)
	{
		for(int j=0;j<(1<<n);j++)
		{
			if(vis[j])
			{
				for(register int k=0;k<(1<<9);k++)
				{
					if(vis[k] && !(j&(k<<1)) && !(j&(k>>1)) && !(j&k))
					{
						for(register int w=0;w+g[k]<=m;w++) dp[i][k][w+g[k]]+=dp[i-1][j][w];
					}
				}
			}
		}
	}
	for(register int i=0;i<(1<<n);i++) ans+=dp[n][i][m];
	printf("%d",ans);
	return 0;
}
```
