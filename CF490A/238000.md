看了看题解，有用 $\text{queue}$ 做的，有用 $\text{multimap}$ 做的，还有用 $\text{vector}$ 实现的，现在，作者给大家展示一种**二叉堆**的做法。（为了偷懒，当然采用 $\text{STL}$ 中的 $\text{preority}$_$\text{queue}$ ）

目前 $\text{preority}$_$\text{queue}$ 支持的操作中最为常见的有：

| 方法 | 描述 | 实例 | 时间复杂度 |
| :----------: | :----------: | :----------: | :----------: |
| $\text{push}$ | 把元素插入堆 | `q.push(x);` | $O(\log n)$ |
| $\text{pop}$ | 删除堆顶元素 | `q.pop();` | $O(\log n)$ |
| $\text{top}$ | 查询堆顶元素（最大值） | `int x=q.top();` | $O(1)$ |
| $\text{empty}$|查询堆是否为空，为空则返回1否则返回0|`if(q.empty())`|$O(1)$|
|$\text{size}$|查询堆内元素数量|`int x=q.size()`|$O(1)$|

对于本题，解题步骤如下：
1. 开三个小根堆$/$大根堆
2. 扫描一遍数组，将第 $i$ 个元素放入第 $t_i$ 个二叉堆。（$t_i$ 为输入数组的第 $i$ 项）
3. 若三个堆均非空，跳至第 $4$ 步，否则跳至第 $7$ 步
4. 三个堆都取出堆顶元素，放入表示答案的数组中。
5. 计数器$+1$
6. 跳回第 $3$ 步
7. 输出计数器最终结果以及答案数组。

正确性证明如下：

- 对于我们的答案数组，每一行三个数都是从三个堆的堆顶取来的，所以三个人的价值互不相同，满足条件。
- 对于计数器，最终凑不齐三个不同价值的人了，故计数器停止操作，正确。

程序留给大家思考，这里就不展示了。