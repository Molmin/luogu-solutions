[更好的阅读体验](https://www.cnblogs.com/LaoMang-no-blog/p/16445964.html)

---

[**你谷 link**](https://www.luogu.com.cn/problem/P6396)

可以先给一份形式化题意：

给定一个初始串 $S_0$ 和参数 $m$，你可以进行一下 $5$ 种操作：

1. 对于一个串 $S$，构造串 $T$ 满足 $T$ 为 $S$ 的**最长回文后缀**，并将 $S$ 赋值为 $T$，代价为 $A$。
2. 对于一个**回文串** $S$，构造串 $T$ 满足 $S$ 为 $T$ 的**最长回文后缀**且 $T$ 为 $S_0$ 的子串，并将 $S$ 赋值为 $T$，代价为 $B$。
3. 对于一个**回文串** $S$，构造串 $T$ 满足可以找到一个**长度至多为 $m$** 的串 $a$，使得 $S=a+T+a^R$，并将 $S$ 赋值为 $T$，代价为 $C$，其中 $a^R$ 表示 $a$ 的反串。
4. 对于一个**回文串** $S$，构造串 $T$ 满足可以找到一个串 $a$，使得 $T=a+S+a^R$ 且 $T$ 为 $S_0$ 的子串，并将 $S$ 赋值为 $T$，代价为 $D$。
5. 对于一个串 $S$，构造串 $T$ 满足可以找到一个**字符** $a$，使得 $T=a+S$ 且 $T$ 为 $S_0$ 的子串，并将 $S$ 赋值为 $T$，代价为 $E$，特别的，进行过 $5$ 操作后不能再进行其他操作。

每次给定一组 $l,r$，令 $T$ 为 $S_0$ 的 $[l,r]$ 范围内的字符取出形成的新串，询问最少需要多少代价能使 $S_0$ 变为 $T$。

首先发现 $5$ 操作独立于其他操作之外，其它四个操作都基于初始串的回文子串，这提示我们使用一种数据结构维护 $S_0$ 的所有回文子串，很明显可以想到回文自动机。

先将 $S_0$ 建成回文自动机，现在我们思考五个操作在回文自动机上对应的意义。

首先就像上文所说的，$5$ 操作独立于别的操作之外，大概也可以想象是怎么用的，就是在生成目标串的回文后缀以后在前面直接接上，那么我们就考虑别的操作在回文自动机上的意义了。

首先看到最长回文后缀应该能很自然地想到回文自动机的失配指针，$1$ 操作对应边 $\langle p,\mathrm{fail}_p\rangle$，$2$ 操作对应 $\langle\mathrm{fail}_p,p\rangle$，然后另外两个操作其实也很明显，在串左右两边同时操作正好对应回文自动机的转移边，因为 $m$ 很小，所以直接对应向父亲暴力连边最多也没几条，但是其中最棘手的就是 $4$ 操作，这等价于向回文自动机中的子树里的每个点连边，在极限情况下显然是会被卡的，所以得想点办法。

其实难度并不是很高，这种往整个集合连边经典套路是建虚点，有些特殊情况不如分块优化建图、线段树优化建图之类的，这题不用这么麻烦，可以直接给每个点建一个虚点，如果两点在回文自动机上有连边，那么对应的虚点从父亲往儿子连边，边权为 $0$，从原点向虚点连有边权的边，虚点向原点连边权为 $0$，这样原来到子树中的边就可以转化为进入虚点后走到目标点对应的虚点再走回来，这两个操作是等价的。

接下来就是先从整串的状态进入回文自动机（如果整个串不是回文串还要用一次 $1$ 操作），再跑到目标串对应的一个回文后缀，再用 $5$ 操作变成目标串。

同时有一个注意点，注意到最后是**跑到目标串对应的一个回文后缀**而不是最长回文后缀，因为如果 $2$ 代价较高而 $5$ 代价较低的话也许最后用 $5$ 代替 $2$ 也不是不行，所以为了减少询问的复杂度，预处理 $d_i$ 表示回文自动机上从最后状态到编号为 $i$ 的节点**只用前 $4$ 种操作**所需要的最小花费，$f_i$ 表示回文自动机上从最后状态到编号为 $i$ 的节点所需要的最小花费，$d_i$ 可以用 Dijkstra 直接处理，$f_i$ 可以 dp 解决，转移方程为 $f_i=\min\{d_i,f_{\mathrm{fail}_p}+\operatorname{len}(p)-\operatorname{len}(\textrm{fail}_p)\}$。

最后就是找到区间 $[l,r]$ 对应字符串的最长回文后缀，可以利用倍增的思想倍增跳 $\textrm{fail}$ 指针，找到以 $r$ 结尾的长度不超过 $r-l+1$ 的最长的回文串。

整体是一道非常综合的题目，具体实现细节较多，可以看代码。

[代码](https://www.cnblogs.com/LaoMang-no-blog/p/16445964.html)