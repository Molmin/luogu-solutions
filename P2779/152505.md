设 $n$ 为序列长度。

首先，$O(n^2)$ 的暴力 dp 应该是好想的，~~就连我这种大蒟蒻也想得出来。~~

我们先定义**基本可行序列**是不能被拆成多个可行序列的可行序列。

如 $\verb!BW!$,$\verb!BBBWWW!$ 都是基本可行序列，$\verb!BWBBWW!$ 就不是基本可行序列，它可以被拆成 $\verb!BW!$,$\verb!BBWW!$ 两个可行序列。我们可以实现在 $O(n^2)$ 的时间复杂度内处理好 $\mathit{S}_{i,j}$（以 $i$ 开头，以 $j$ 结尾的子序列）是否是基本可行序列。

设 $f_{i}$ 为以第 $i$ 位**结尾**的序列中有多少种可行方案，很明显，我们可以枚举所有的 $w<i$，若 $\mathit{S}_{w+1,i}$ 是一个基本可行序列，就让 $f_{i}$ 加上 $f_{w}$。

发现一个序列的结尾必定是偶数位，所以对 $i$ 与对 $w$ 的枚举可以减半。

接下来想怎么得满分。

我们枚举每一个**偶数位** $i$ 观察能否在小于 $O(n)$ 的时间复杂度内快速处理出 $f_{i}$ 的值。

首先，若 $c_{i}$（$i$ 的颜色）为 $\verb!B!$，显然它做不了结尾，$f_{i}=0$。

其次，若是 $c_{i-1}$ 为 $\verb!B!$ 那么我们只可能取到 $f_{i-2}$ 的贡献。

举个栗子：

$\verb!??B???!$

显然，如果以第 4 位为结尾，由于 $c_{3}$ 是 $\verb!B!$，那么以 4 为结尾的**基本可行序列**只能是 $\verb!BW!$，再往前走，就是 $\verb!??BW!$，显然构成不了一个基本合法序列，所以 $f_{4}=f_{2}$，因为它只能取到 $\mathit{S}_{3,4}$。

如果不是上面这两种情况，那么怎么办？

比如上述栗子中的 $f_{6}$，它能取到那些呢？

我们知道 $f_{4}$ 能取到 $f_{2}$，而 $f_{6}$ 之前没有别的 $\verb!B!$ 影响它，所以 $f_{6}$，可以往前取到 $f_{0}$！

为什么会这么神奇？

因为它的本质，就是让在 $i$ 之前，离它最近的 $\verb!B!$ 的距离**等于** 这个 $\verb!B!$ 离该基本可行序列的开头的距离，只不过我们用了简便的方法来处理它而已。 

于是我们可以定义一个指针 $back$,表示当前 $f_{i}$ 能取到的最小的位置，和一个存储变量 $now$,表示当前 $f_{i}$ 可获得的值。

当 $c_{i}$ 为 $\verb!B!$ 时，直接令 $now=0$，$back=i$，因为 $i$ 以前的 $f_{w}$ 都不能赋值给 $f_{i}$，所以最终给 $f_{i}$ 赋值的 $now$ 也是 $0$。

当 $c_{i-1}$ 为 $\verb!B!$ 时，直接令 $now=f_{i-2}$，$back=i-2$，因为只有 $f_{i-2}$ 能赋值给 $f_{i}$，所以最终给 $f_{i}$ 赋值的 $now$ 也是 $f_{i-2}$。

若这两种情况都不是，那么根据之前的观察，$back$ 可以减 $2$,$now$ 可以在 $back$ 改变后加上 $f_{back}$,显然要排除 $back<0$ 的情况。

这样完了吗？不！$\verb!W!$ 被吃了吗？

有一个位置 $j$，我们设在它后面最小的给定的 $\verb!W!$ 的位置在 $suf_{j}$，事先定义 $suf_{n}=n+1$。

举个栗子：

$\verb!?WB???WW?W!$

可以得到从 $\mathit{suf}_{0,n}$ 的序列是：

$2,2,7,7,7,7,7,8,10,10,11$

这个好理解，但它有什么用呢？

我们会发现，$f_{i}$ 最远可以贡献到的位置正是 $2 \times suf_{i}-i-2$。

比如，上述栗子中，$f_{4}$ 最远可以贡献到 $f_{8}$, $\mathit{S}_{5,8}$ 为 $\verb!BBWW!$，显然可行，再远的话就是 $\verb!??WW?W!$,就不可行了。

这又是为什么呢？

其实根处理 $\verb!B!$ 的思路是一样的，我们要 $i$ 与在它之后最近的 $\verb!W!$，即 $suf_{i}$ 的距离**等于** $suf_{i}$ 到该基本合法序列末尾的长度，只不过我们在转移过程中就能方便处理好 $\verb!B!$ 的影响，处理第二个 $\verb!W!$ 要用麻烦一点的方法一些而已。

所以，我们将 $2 \times suf_{i}-i$ 与 $i$ 连边，因为它是第一个无法获得 $f_{i}$ 贡献的位置。

由小到大处理 $f_{i}$，用 $now$ 存储给 $f_{i}$ 赋予的值，事先将所有与它连边的 $w$，让 $now$ 减去 $f_{w}$，这样处理好 $\verb!W!$ 的影响后，再用前文所述的方法处理 $\verb!B!$ 的影响，得到最后的 $now$ 数组，此时 $f_{i}$ 便可赋值为 $now$ 了，自然，处理出来的 $f_{i}$ 会对后面产生贡献，如此我们再让 $now$ 加上 $f_{i}$,便可放心去处理 $i+1$ 去啦。

总算讲完了，由于对于每个 $i$,只会有一条入边，所以跑边的时间复杂度是 $O(n)$，而 处理 $f_{i}$ 的时间复杂度也是 $O(n)$，所以总的时间复杂度可以达到优秀的 $O(n)$。

**总结一下思路，我们想分别计算出 B 与 W 的影响，一个在递推中直接处理，一个在递推中用连边的方式处理。**

附上代码（前文的 $suf$ 可以方便理解，在实际代码中已省略）：


```cpp
#include<bits/stdc++.h>
#define g getchar()
#define pc(a) putchar(a) 
using namespace std;

const int N=5e5+7,mod=1e9+9;
int nex[N],to[N],hd[N],tot;
int n,f[N],now,back;
char c[N];

void qp(int x){
	if(x<0) pc('-'),x=-x;
	if(x<=9){
		pc(x+'0');
		return;
	}qp(x/10);
	pc(x%10+'0');
}

void add(int x,int y){
	if(x<=n){
		nex[++tot]=hd[x];
		hd[x]=tot;
		to[tot]=y;
	}
}

int main(){
	while((c[++n]=g)>='?'){
	}n--;
	if(n&1){
		qp(0);
		return 0;
	}int x=n+1;
	for(int i=n-1;i>=0;i--){
		if(c[i+1]=='W') x=i+1;
		add((x<<1)-i,i);
	}f[0]=now=1;
	for(int i=2;i<=n;i+=2){
		for(int j=hd[i];j;j=nex[j]){
			int v=to[j];
			if(v>=back){
				now=now-f[v]+mod;
				if(now>mod) now-=mod;
			}f[v]=0;
		}if(c[i]=='B') now=0,back=i;
		else if(c[i-1]=='B') now=f[i-2],back=i-2;
		else{
			back-=2;
			if(back>=0) 
				 now=now+f[back];
		}if(now>mod) now-=mod;
		f[i]=now;
		now=now<<1;
		if(now>mod) now-=mod;
    }qp(f[n]);
	return 0;
}

```








