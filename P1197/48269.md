【题目描述】

很久以前，在一个遥远的星系，一个黑暗的帝国靠着它的超级武器统治者整个星系。某一天，凭着一个偶然的机遇，一支反抗军摧毁了帝国的超级武器，并攻下了星系中几乎所有的星球。这些星球通过特殊的以太隧道互相直接或间接地连接。

但好景不长，很快帝国又重新造出了他的超级武器。凭借这超级武器的力量，帝国开始有计划地摧毁反抗军占领的星球。由于星球的不断被摧毁，两个星球之间的通讯通道也开始不可靠起来。现在，反抗军首领交给你一个任务：给出原来两个星球之间的以太隧道连通情况以及帝国打击的星球顺序，以尽量快的速度求出每一次打击之后反抗军占据的星球的连通块的个数。（如果两个星球可以通过现存的以太通道直接或间接地连通，则这两个星球在同一个连通块中）。

【输入输出格式】

- 输入格式

输入文件第一行包含两个整数，$n (1 \leq n \leq 2m)$ 和$m (1 \leq m \leq 200,000)$，分别表示星球的数目和以太隧道的数目。星球用$0$~$n-1$的整数编号。

接下来的$m$行，每行包括两个整数$x$, $y$，其中（$0 \leq x \not= y<n$），表示星球$x$和星球$y$之间有以太隧道。注意所有的以太隧道都是双向的。

接下来一行是一个整数$k$，表示帝国计划打击的星球个数。

接下来的K行每行一个整数$x$，满足$0 \leq x<n$，表示帝国计划打击的星球编号。帝国总是按输入的顺序依次摧毁星球的。

- 输出格式

输出文件的第一行是开始时星球的连通块个数。

接下来的$k$行，每行一个整数，表示经过该次打击后现存星球的连通块个数。

【输入输出样例】

- 输入样例
```
8 13
0 1
1 6
6 5
5 0
0 6
1 2
2 3
3 4
4 5
7 1
7 2
7 6
3 6
5
1
6
3
5
7
```
- 输出样例
```
1
1
1
2
3
3
```

这道题目其实基本上就是并查集的入门题啦~想要入门的同学可以去做一下这道题目：[【模板】并查集](https://www.luogu.org/problemnew/show/P3367)，或者看一下我的这篇题解~

在这里举一个有$7$个点的栗子，如图（数组中的第$i$个格子表示的是$i$号点的老大）~

![](https://cdn.luogu.com.cn/upload/pic/18407.png)

你会发现，一开始每个点的老大都是自己。

看早这里，你可能会问：每个点的老大是用来干什么的？其实，我们不难发现，当某些点的老大相同的时候，他们必定处在一个联通块中。现在，我们要给出一些关系：$x$号点和$y$号点的老大是一样的。那么，我们就要将$x$号点和$y$号点合并。例如在这个栗子中我们将$6$号点和$1$号点合并（$x=6,y=1$）。在这里我们规定我们将$x$号点的老大改为$y$号点的老大，修改完后如图。

![](https://cdn.luogu.com.cn/upload/pic/18408.png)

那么我们在代码中怎么实现合并操作呢？不用急，下面上代码（$hb()$函数即为合并函数，其中$f[x]$表示的是$x$号点的老大）~

```
void hb(int x,int y)
{
	int tx=find(x),ty=find(y);
	if(tx!=ty)
	{
		f[tx]=ty;//将x号点的老大改为y号点的老大。
	}
}
```

什么？居然混入了一个$find()$函数T_T？其实$find()$函数是用来寻找$x$号点的老大的，并把和$x$号点处在一个连通块上的点的老大都改为$x$号点的老大，下面上$find()$函数的代码~

```
int find(int x)
{
	if(x==f[x])
	{
		return x;//找到老大了，返回这个老大的编号。
	}
	else
	{
		return f[x]=find(f[x]);//把一些和x号点处在同一个连通块中的点的老大改为x号点的老大。
	}
}
```

然后并查集就讲完啦^_^，然后将这个并查集反过来做就OK啦。不过如果并查集写的不好的话会TLE的哦，具体的代码实现还请看AC代码~

本题解内的图片的绘图工具为@EternalAlexander 编写的OI Painter软件，Beta 1.3~

下面上AC代码~
```
#include <cstdio>
struct nodea{ int x,y,g; } b[1000001];
struct nodeb{ int h; } r[1000001];
int ans[1000001],f[1000001],c[1000001],x[1000001];
int len=0,da=0,p=0;
int n=0,m=0;
void ins(int x,int y)
{
	len++;
	b[len].x=x;
	b[len].y=y;
	b[len].g=r[x].h;
	r[x].h=len;
}
int find(int x)
{
	if(x==f[x])
	{
		return x;
	}
	else
	{
		return f[x]=find(f[x]);
	}
}
void hb(int x,int y)
{
	int tx=find(x),ty=find(y);
	if(tx!=ty)
	{
		f[tx]=ty;
	}
}
int main()
{
	scanf("%d %d",&n,&m);
	for(int i=1;i<=n;i++)
	{
		f[i]=i;
	}
	for(int i=1;i<=m;i++)
	{
		int x=0,y=0;
		scanf("%d %d",&x,&y);
		x++,y++;
		ins(x,y),ins(y,x);
	}
	int q=0;
	scanf("%d",&q);
	for(int i=1;i<=q;i++)
	{
		scanf("%d",&x[i]);
		x[i]++;
		c[x[i]]=1;
	}
	for(int k=1;k<=n;k++)
	{
		if(c[k]==0)
		{
			for(int i=r[k].h;i>0;i=b[i].g)
			{
				if(c[b[i].x]==0 && c[b[i].y]==0)
				{
					hb(b[i].x,b[i].y);
				}
			}
		}
	}
	for(int i=1;i<=n;i++)
	{
		if(c[i]==0 && f[i]==i)
		{
			da++;
		}
	}
	ans[++p]=da;
	for(int j=q;j>=1;j--)
	{
		da++;
		c[x[j]]=0;
		for(int i=r[x[j]].h;i>0;i=b[i].g)
		{
			if(c[b[i].x]==0 && c[b[i].y]==0 && find(b[i].x)!=find(b[i].y))
			{
				da--;
				hb(b[i].x,b[i].y);
			}
		}
		ans[++p]=da;
	}
	for(int i=p;i>=1;i--)
	{
		printf("%d\n",ans[i]);
	}
	return 0;
}
```