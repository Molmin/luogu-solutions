1、这个题解稍作修改就可以完成任意进制。如果是任意进制，也就不需要在输入的时候判断了，统一输入字符串，转十进制的时候检测一下大小写字母就好了。

2、这个题其实就是常见的回文数题的小型扩展。如果真的深入理解了什么是进制，那么就很简单。

3、30次累加的数字不会超过10^16，2^63是9.223E18，所以64位整数就够用，不需要高精度。如果用了高精度会更复杂。

```c
#include <stdio.h>
#include <string.h>

int main()
{
    int sn;
    char nums[8] = { 0 };//题目中数字不超过100，2进制的100是7位数，留一个给尾零。
    long long num = 0;
    long long sum = 0, tmp;
    int i, j, len;

    scanf("%d", &sn);
    if (sn == 16)
    {
        scanf("%x", &num); //由于16比较特殊，单独拿出来处理
    }
    else
    { 
        scanf("%s", nums); //10以下的用字符串处理

        len = strlen(nums); //以下是手动任意进制转10进制，由于只有10以下所以忽略字母，实际只要加个判断可以36进制以下转10进制。
        for (i = 0; i < len; i++)
        {
            tmp = nums[i] - '0';
            for (j = 0; j < len - i - 1; j++) //其实就是pow函数
            {
                tmp *= sn;
            }
            num += tmp; //最终结果在num里，是字符串数转为十进制的结果。
        }
    }

    for (i = 0; i < 30; i++, sum = 0)
    {
        for (tmp = num; tmp; tmp /= sn)
        {
            sum = sum * sn + tmp % sn;
        }//这个循环其实可以完成任意进制的逆序。之前逆序的是十进制所以都是用的10。这里其实就是用十进制的运算完成了任意进制的数字逆序，其实就是短除法的特殊应用，短除法数字逆着写就是转换后的数字，那么顺着写就是倒过来的。

        if (sum == num)
        {
            break;
        }
        num += sum;
    }//题目是多进制，实际还是回文数的老循环。

    if (i == 30) //如果没有break出来，循环结束的i将会是30。
    {
        printf("Impossible!");
    }
    else
    {
        printf("STEP=%d", i);
    }

    return 0;
}
```