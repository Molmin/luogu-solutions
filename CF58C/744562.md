这题问的是最少修改几次，我们不妨想想最多有几个不需要修改。


假定有一个序列 $3$，$4$，$5$，$4$，$3$，很明显，聪明的你一定发现这是一个美丽的序列，我们可以得出两个规律，前半部分单调递增，之后就是单调递减，而且关于中心对称，由此我们可以看出第二个规律，不妨让下标变成 $1$，$2$，$3$，$2$，$1$，就会发现序列的每个数和他的坐标的差相等，表示下标的方法也非常的简单，前半部分就是 $i$,后半部分就是 $n-i+1$,取他们的最小值判断一下就好了。

然后用 $cnt$ 数组统计一下数，用 $ans$ 保存一下最大值，别忘了，输出 $n-ans$，因为我们统计的是最多有几个不需要修改。

代码如下：

```c
#include<bits/stdc++.h>
using namespace std;
int n,cnt[100005],ans;
int main(){
    cin>>n;
    for(int i = 1;i <= n;i++){
        int k;
        cin>>k;
        int m = min(i , n - i + 1);//我们新建的下表
        k -= m;
        if(k < 0) continue; 
        cnt[k]++;//统计
        ans = max(ans,cnt[k]);//找最大的
    }
    cout<<n-ans;
}
```
