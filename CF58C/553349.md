## CF58C题解
#### 题意
给一个正整数列，求改动多少数才能使整个数列回文且前半部分严格递增。
#### 思路
首先，暴力肯定不行 ~~伤心~~，要用其他方法使不改动的数的个数最大。

这样，就肯定能找到一个第一个数为 $1$ 的符合要求的模板数列（如 $121$，$1221$ 等）。然后就能用原数列中每一个数减去模板数列对应位置的数，再把差桶排后用 $n$ 减去最大值输出即可。

备注：因为要求正整数列，所以 $1$ 打头的一定是符合要求的最小数列，所以如果有数比对应的模板数都小就一定要改。
#### code
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,x,a[100001],b[100001];
int main() 
{
	cin>>n;
	x=n/2;//前半和后半的分隔线
	for(int i=1;i<=x;i++)//上半部分
	{
		cin>>b[i];
		if(b[i]>=i)a[b[i]-i]++;//简单亲民的桶排
	}
	if(n%2!=0)//奇数个数的特殊处理
	{
		cin>>b[++x];
		if(b[x]>=x)a[b[x]-x]++;
	}
	int y;
	for(int i=x+1;i<=n;i++)//下半部分
	{
		cin>>b[i];
		y=n-i+1;
		if(b[i]>=y)a[b[i]-y]++;//又一个桶排
	}
	sort(a,a+100000+1,greater<int>());
	cout<<n-a[0];
	return 0;//完结撒花
}
```
