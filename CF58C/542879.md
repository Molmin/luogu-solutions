# CF58C Trees题解

这道题似乎与Tree没什么关系.....

[CF58C Trees](https://www.luogu.com.cn/problem/CF58C)

**题意简述**

给定一个序列，问修改其中几个值能使序列回文且左半部分为连续递增的的正整数

**思路**

这里有几个关键点：

- 回文
- 递增
- 连续
- 正整数

构造符合要求的最简单的序列，比如 $[1,2,1]$，$[1,2,3,2,1]$ 等。这些以1开头的序列我们把它称之为“简单序列”。

我们可以把简单序列中的每一个数都加上一个 $d$，原序列又会变成一个新的序列。而新的序列也是符合要求的。

这时，我们就可以得出一个重要的结论：

**任意一个符合要求的序列和与其长度相等的简单序列的每一位数差值相等。**

举个栗子：
![](https://cdn.luogu.com.cn/upload/image_hosting/9q07okod.png)


现在我们再回到题目。题目让我们回答最小的修改个数，而这个问题就等价于最多的不变的个数。

再看看刚刚得出的结论，那些数是不需要变的呢？假设我们已经知道了差值 $d$，那么不变的数就是这个数和简单序列中对应的数差值已经是 $d$ 的数。

但是最终这个 $d$ 还是自己定的，因为我们要让不变的数最多，所以 $d$ 就是所有差值的众数（所有差值中最多的一个）。而不用修改的数量就是众数的出现次数。

下面，就可以开始思考如何实现了。

**实现**

大概又这么几个步骤：

1. 读入
1. 构造长度为 $n$ 的简单序列
1. 计算差值
1. 找出差值众数和众数的出现次数
1. 输出

其中，构造简单序列的这一步可以简化。简单序列的第 $i$ 位就是  $\min(i,n-i+1)$。

3和4可以合并，用桶去储存该差值的数量， 桶中的数大于 $maxn$ 时就更新 $maxn$。

最后，因为 $manx$ 储存的是不用修改的数量，所以输出 $n-maxn$。

另外，当差值为负数时直接跳过，因为题目要求是正整数。

**代码**

```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
int a[1000001],b[100001],c[100001];
int cnt,maxn;
int main()
{
	cin>>n;//读入
	for(int i=1;i<=n;++i)
	{
		cin>>a[i];//读入
	}
	for(int i=1;i<=n;++i)
	{
		//min(i,n-i+1)是简单序列第i位值
		if(a[i]-min(i,n-i+1)<0)continue;//如果差值是负数，直接跳过
		c[a[i]-min(i,n-i+1)]++;//将桶中的数量增加
		if(c[a[i]-min(i,n-i+1)]>maxn)//如果桶中的数量大于maxn
		{
			maxn=c[a[i]-min(i,n-i+1)];//更新
		}
	}
	cout<<n-maxn;//输出
}
```
