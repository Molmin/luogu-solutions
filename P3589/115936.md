感觉蛮暴力的。

考虑从子串所在位置考虑，对于某一个位置能与子串第 1 个字符匹配当且仅当它在区间 $[0,p-1]$ 或 $[p,n-1]$ 。

考虑某一个位置如果能与子串第 $i$ 个字符匹配，那么这个区间还是一样的，但是这个信息没什么用，考虑它与第 $i$ 个字符匹配的情况下，第 $1$ 个字符的区间。

这个是简单的，将第 $i$ 个字符的 $[l,r]$ 在模意义下减去 $(i-1)\times a$ 即可。

这里有个细节，区间平移后可能会出现 $l>r$ 的情况，这个时候对应的是 $[l,n-1]$ 和 $[0,r]$ 两个区间，因为模意义本身是个类似环的形式。如果 $l\le r$ 就还是区间 $[l,r]$ 。

然后对于 $i=[1,m]$ 我们都把区间对应出来，因为 $n$ 和 $a$ 互质，所以相当于让我们求有多少个值是满足的。对于每个区间考虑区间加，一个值满足条件当且仅当它的值刚好为 $m$ 。

最后注意特判一下最后的 $m-1$ 个值，因为他们可能会被统计但是实际上他们后面凑不够 $m$ 的长度，这个暴力跑一遍就好了。

对于区间加，考虑差分，然后类似离散化搞一下，最后扫一遍即可。

可能有点小卡常，加 O2 应该都能过，一开始写的 map 发现比较吃力，实际上离散化的过程可以直接全部存进数组里排序然后直接用来扫就好了，不用再去二分找，因为有排序总复杂度为 $O(m\log m)$ 。