被这道题教育了/kk

首先有个很暴力的想法是设 $f_{i,j}$ 为 $a$ 数列选前 $i$ 个，$b$ 数列选前 $j$ 个所需步数。

显然可得


$f_{i,j}=\min(f_{i-1,j},f_{i,j-1})+1$

特别的如果 $a_i \neq b_j$，则:

$f_{i,j}=\min(f_{i,j},f_{i-1,j-1}+1)$

显然不会在 $a_i \neq b_j$ 的时候按第一项转移，所以此时 $f_{i,j}=f_{i-1,j-1}$。

注意到 $a_i=b_j$ 只存在 $n$ 个，即最多会出现 $n$ 次第一种转移。

那么考虑能不能把第二种转移写成从某个 $a_i=b_j$ 转移过来的状态，这样就可以直接记搜。

事实上是可以的，我们设 $t$ 表示在转移 $f_{i,j}$ 的时候，$i,j$ 之前最后一个 $a_{i-t-1}=b_{j-t-1}$。那么在此之后就会一直选两个，所以可以写成：

$f_{i,j}=f_{i-t-1,j-t-1}+t$。

那么我们只需要计算 $a_i=b_j$ 的 $n$ 个状态和为了计算这 $n$ 个状态所需要计算的 $2n$ 个 $a_i \neq b_j$。这可以使用记搜实现。

然后是如何计算 $t$ ，可以二分，注意到 $i,j$ 确定的时候 $a_k$ 会和 $b_{k-(i-j)}$ 匹配，所以开 $2n$ 个 vector 记录每个差存在的 $a_i=b_j$ 即可二分，复杂度 $O(n \log n)$，当然也可以进一步优化到 $O(n)$ ，具体参考其他题解。