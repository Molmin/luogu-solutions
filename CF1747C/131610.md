诈骗题
## 题意简述
有一个序列长度为 $n$ 的序列 $a$，`Alice` 和 `Bob` 两人轮流操作，`Alice` 先手，将当前序列中的第一个数减 $1$，并可以选择当前序列中一个数交换（不能是当前序列中的第一个数），当一个人操作前，当前序列中的第一个数为 $0$，这个人就输了。问最后谁会赢。
## 题目分析
结论：两人每次操作交换的必是当前的 $a_1$，与除去 $a_1$ 后序列的最小值。
>证明：若 `Alice` 操作交换到的是序列中的次小值 $y$，，不是最小值 $x$，且 `Bob` 不取 $x$，那么她需要操作的使其变为 $0$ 的次数会由 $x$ 上升为 $\min(x+1,y)$；若 `Bob` 取 $x$ ，操作次数又 $x$ 上升为 $y$，操作步数增多，因此这样操作更劣，她会选择交换序列中最小值 $x$。同理可知，`Bob` 也会选择他操作时的序列中的最小值。

将除去 $a_1$ 后的序列 $a$，从小到大排好序。很明显，只有 `Alice` 的第一步操作会被限制减少的是 $a_1$，两个人剩下的操作都会选择能选择的最小的数。这样数字相对与初始值减小的数最多只有三个。`Alice` 交换时可取序列中的最小值 $a_2$ 与 `Bob` 交换时序列中可能的最小值 $a_1-1$ 和 `Alice` 操作前可取序列中次小值 $a_3$。将 $\min(a_1-1,a_3)$ 与 $a_2$ 比较，若前者小，则 `Bob` 胜，反之 `Alice` 胜。需特殊处理 $n=2$ 情况。

## Code
```
int n,a[100100];
void solve(){
    read(n);
    for(int i=1;i<=n;i++){
        read(a[i]);
    }
    sort(a+2,a+n+1);//将除去a[1]以外的所有数排序
    if(n==2){//特判只有两个数情况，此时Bob没有其它数可选
        if(a[2]<=a[1]-1){
            puts("Alice");
        }
        else{
            puts("Bob");
        }
        return;
    }
    if(a[2]<=min(a[1]-1,a[3])){
        puts("Alice");
    }
    else{
        puts("Bob");
    }
}
```
## 题外话
为什么说这题诈骗题呢？因为我看到的第一眼，发现他是博弈论，以为要求 `SG函数`，想了五分钟就跑去看 `d` 了，然后就发生了一些很难受的事（详情请见[我的d题题解](https://www.luogu.com.cn/blog/luoshen0/solution-cf1747d)的题外话部分），做完后看了两分钟 `c` 思路就出来了，就很绷不住。