### 题目分析

一、关于输入输出的解释

输入的第一行是人的数量 $n$ ，衣服的数量 $m$ ，以及衣服的弹性 $x$ ， $y$ 。

第二行为 $a_i$ 。

第三行为 $b_i$ 。

输出的第一行为最多有多少人能买到合适的衣服。

接下来每行为匹配的人的编号，以及对应的衣服的编号。

二、思路：

思考之后不难发现，如果一个人选了最不合适他的衣服，但在弹性内他能穿上，那么其他人就更有可能选到能穿的衣服，翻译过来就是，对于一个 $a_i$ 找到能匹配的最小的 $b_i$ ，最后记录结果就得到了解。

三、实现：

实现起来就很容易了，只需要用两个指针，$ia$ ， $ib$ ，分别表示目前到了哪个人，哪件衣服，由于满足 $B$ 单增，通过 $ib$ 向后找到的第一个能穿上的一定是最小的，也就是上述的思路。

四、细节：

给定的大小都是严格单增的。

其他的细节注释在了代码里，~~本人认为写的还是挺好看的（逃~~。

------------

上代码啦：

```cpp
#include <bits/stdc++.h>
#define maxn 100005
using namespace std;
int n, m, x, y, cnt; //n:人的数量，m:衣服的数量，x,y:弹性，cnt:匹配的数量
int A[maxn], B[maxn]; //A:每个人希望的大小，B:衣服的大小
int ansx[maxn], ansy[maxn]; //记录答案的匹配
int main() {
	cin >> n >> m >> x >> y;
	for (int i = 1; i <= n; i++)
		cin >> A[i];
	for (int i = 1; i <= m; i++)
		cin >> B[i];
	int ia = 1, ib = 1; //两个指针，ia为当前的人，ib为当前的衣服
	while (ia <= n && ib <= m) { //如果人没有走完，衣服也没被买完
		while (B[ib] + x < A[ia]) //如果当前的人穿不了，就向后找更大的
			ib++;
		//这里需要注意一下，如果不能穿，一定是太小了，而不会是太大了
		if (ia <= n && ib <= m && A[ia] - x <= B[ib] && A[ia] + y >= B[ib]) {
			//注意看是否还在范围内，因为可能当前的人已经没有合适的衣服了
			ansx[++cnt] = ia; //记录答案
			ansy[cnt] = ib;
			ib++;
		}
		ia++;
	}
	cout << cnt << endl;
	for (int i = 1; i <= cnt; i++)
		cout << ansx[i] << " " << ansy[i] << endl; //输出答案
	return 0;
}
```
至此就做完啦，看都看完了，应该也学会了吧，代码要自己写哦，~~点个赞再走吧~~。

完结撒花！