注意到好像还没有人写状压$dp$的题解，那么我就来发一波状压$dp$的题解。

但是，在开始讲述之前，我需要先吐槽本题的数据。

1. 一个开关的直接关联开关可以是自己
	
    然而题目中并没有说明需要忽略这样的数据

1. 一个开关的直接关联开关有重
	
    然而题目中并没有说明需要去重
    
1. 一个开关的直接关联开关可以大于开关总数$n$或者是$0$
	
    于是我的状压$dp$疯狂$RE$


综上，这道题的数据的确出的不尽人意。但是，我们也要理解出题人。数据这个东西是否有锅其实和做法是有很大关系的。以前我就尝试过出一道题目，最后就是因为数据不得不放弃了。

~~只是数据有锅却以为是自己代码写挂了就比较……嗯~~

## 现在进入正题。

状压$dp$，即把$dp$的状态进行压缩后转移的$dp$技巧。

之前好像看到讨论里有人说本题$dp$有后效性？我个人认为是没有的。但是空口无凭，所以我就来谈一谈这个问题。

我们使用一个二进制数来表示一个开关的开关状态：从最低位到最高位分别表示一个开关的状态。其中$0$表示开关打开，$1$表示开关关闭。那么，当一个开关的改变对状态造成影响后，我们就可以使用位运算**异或**来表示这种变化，从而实现转移。

在证明这个$dp$的状态设计没有后效性之前，我们先来看一看关于异或的一些性质。

- 异或运算满足交换律，即 $a$ $xor$ $b$ $=$ $b$ $xor$ $a$

- $a$ $xor$ $b$ $xor$ $b$ $=$ $a$

有了这两条性质就可以了。

首先，对于任意一个开关，当它的状态发生变化后，其对整体状态的变化过程一定可以利用题目中已知的信息表示成一个二进制数。换句话说，是一个**不受当前整体开关状态影响**的固定值。那么，由第二条性质可得，如果某一个开关被拨动两次，结果就会导致整个状态并没有发生任何改变。

于是，我们得到：**任何一个开关要么变动一次，要么不动**。

其次，对于任何两个会变动的开关$i$、$j$，无论我们先拨动$i$或者先拨动$j$，由于异或运算满足交换律，所以对整体结果的改变是一样的。

于是，我们又得到，**开关拨动的先后顺序并不影响结果**。

也就是说，这个问题现在已经有点类似于一个$01$背包了。每个开关要么动一次，要么不动，并且顺序任意。

扯了这么多，相信各位也已经明白这个$dp$是没有后效性的。因此，它可以作为我们解决本题的一个方法之一。

现在开始说具体的$dp$过程。

$state[i]$：表示当按下开关$i$时与其直接关联的开关的集合 **（不包括$i$）**

$change[i]$：表示当按下开关$i$后它对整个开关状态的影响 **（包括$i$）**（就是上文提到的“不受当前整体开关状态影响的固定值”）。假设原来的整体开关状态是$x$（是一个二进制数），按下开关$i$后，整体开关状态变为$x$ $xor$ $change[i]$。

$f[i][j]$：表示考虑到第$i$个开关，使得当前整体开关状态为$j$的最小按开关次数。若不可能达到则设为$INF$。转移方程：

$f[i][j]$ $=$ $Min$ $(f[i-1][j_0]+1$ $,$ $f[i-1][j])$

其中$j_0$ $xor$ $change[i]$ $=$ $j$

也就是说，讨论当前按不按第$i$个开关，可以从两个不同的状态转移过来，用于更新答案即可。至于$j_0$的取值，由刚才的等式就可以解出来。我们让等式两边同时异或上$change[i]$，再结合之前提到的第二条性质，就可以得到：

$j_0$ $=$ $j_0$ $xor$ $change[i]$ $xor$ $change[i]$ $=$ $j$ $xor$ $change[i]$

于是状态转移方程变为：

$f[i][j]$ $=$ $Min$ $(f[i-1][j$ $xor$ $change[i]]+1$ $,$ $f[i-1][j])$

然后我们枚举每一个开关（$20$），再枚举每一种状态（$2^{20}$），发现时间复杂度大约在$2e8$左右，结合本题的$5s$时限，是可以通过的。但是空间复杂度和时间复杂度同级，这是我们无法承受的。注意到$f[i][j]$只会由$f[i-1][j $ $or$ $j_0]$转移过来，所以使用滚动数组优化空间。至此，本题得到了状压$dp$的完美解法。

当然，关于出锅数据，当然可以用二维的数组避免掉。不过由于我是先写$dp$然后~~通过讨论区~~发现数据有问题后在原来的代码上直接改动的，就用的排序去重。这个怎么实现都可以啦。

以下是~~我历经千辛万苦写出来的~~$AC$代码。

```cpp
#include<cstdio>
#include<iostream> 
#include<cstring>
//用到了memset 
#include<algorithm>
//用到了sort和unique 
using namespace std;
//写读入优化是一个比较…嗯…的习惯 
inline void read(int &x) 
{
	int w=x=0;
	char ch=getchar();
	while(ch<'0'||'9'<ch)
		ch=='-'?w=1,ch=getchar():ch=getchar();
	while('0'<=ch&&ch<='9')
		x=(x<<3)+(x<<1)+(ch^'0'),ch=getchar();
	x=w?-x:x; 
}
const int Maxn=1<<20,N=25,INF=0x3f3f3f3f;
//定义INF最好习惯性地用这个，不会越界 
int n,m,t,Max,cnt[N],child[N][N];
//n，m如题所述；t是临时变量；Max是总状态的最大可能（1<<n）
//cnt是每个开关 合法 直接关联开关的个数，child是编号 
int tot,tmp[N],f[5][Maxn];
//tot和tmp是用于排序去重的， f数组是dp数组 
int state[N],change[N];
//如前文所述 
int main()
{
	read(n),Max=1<<n;//设定Max 
	for(int i=1;i<=n;++i)
	{
		read(m),tot=0;//tot一定要赋初值为0 
		for(int j=1;j<=m;++j)
		{
			read(t);
			if(t>0&&t<=n&&t!=i)//说起来都是泪 
				tmp[++tot]=t;
		}
		sort(tmp+1,tmp+tot+1),cnt[i]=unique(tmp+1,tmp+tot+1)-tmp-1;
		//先sort再unique去重并把去重后的数目存到cnt[i]里
		//当然这里可以用二维数组简化 
		for(int j=1;j<=cnt[i];++j)	
			child[i][j]=tmp[j],state[i]^=1<<(tmp[j]-1);
		//存入child并且更新state 
	}
	for(int i=1;i<=n;++i)
	{
		change[i]=state[i]^(1<<(i-1));
		//由于state是没有存自己的，所以要先把自己存进去 
		for(int j=1;j<=cnt[i];++j)
			change[i]^=state[child[i][j]];//更新change[i] 
		//由于state[i]已经记录了所有的child的状态变化
		//因此不需要把它们自己的改变存到change[i]里
		//这也就是为什么不能把自己的变化存到state里 
	}
	memset(f,0x3f,sizeof f),f[0][0]=0;
	//初始化dp数组，其中初始状态f[0][0]为0 
	for(int i=1;i<=n;++i)
	{
		int now=i&1;//x&1=x%2，这是用于压维优化空间的 
		for(int j=0;j<Max;++j)//遍历所有可能的状态 
			f[now][j]=min(f[now^1][j],f[now^1][j^change[i]]+1); 
		//状态转移 ： now就是i，now^1就是i-1 
	}
	//注意末状态是Max-1 
	if(f[n&1][Max-1]==INF)//无法关闭闹钟（自闭） 
		printf("Change an alarm clock，please!");
	else//输出答案 
		printf("%d",f[n&1][Max-1]);
	return 0;
} 
```

测试用时$174ms$，慢于广搜做法。