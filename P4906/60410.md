-- P4906 【小奔关闹钟】--
题目背景

由于今天是星期一，闹钟准时响了，由于小奔太困了，所以她想关停闹钟。

题目描述

可是，他的闹钟电路太复杂了，有很多个开关，每个开关都连着其他开关，其他开关又连着更多的开关，当且仅当所有开关都关闭时，闹钟才会停止响铃，（初始时默认每个开关都开着的），她该如何是好呢？

请你帮小奔求出最少开关次数，如果无论如何都不能关闭闹钟，请输出‘Change an alarm clock，please!

输入输出格式

输入格式：

共有N+1行

第一行一个数N（1≤N≤20），表示有N个开关，从第2行起的第i行表示第i个闹钟开关。

以后N行，每行第一个数为M（0≤M≤N-1），表示第i个闹钟开关的直接关联开关个数。（由直接关联开关所关联的直接关联开关，自然就是第i个闹钟间接关联开关啦，当打开第i个开关时，只有直接关联，间接关联以及第i个开关才会起作用。），之后M个数，表示第i个闹钟直接关联开关的标号。（如果M为0则表示没有任何关联）

输出格式：

一个数ans，表示最少按开关次数，如果无法关闭，输出‘Change an alarm clock，please!’

--------分割线---------------------------------------

状压广搜

看n<=20,显然可以把每个开关的状态用2进制表示

如15(n=5,01111)表示1开 2,3,4,5关

0表示全部开,2^n-1表示所有都关

把每一个开关的作用效果用2进制表示出来,之后我们直接异或这个2进制数即可代表按这个开关.
----

用一个vis数组表示这个状态是否在队列中,如果不在就入队,直到二进制结果得到结果或队列空.
~~似乎没有无解情况......~~

代码(有小坑):
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,k,a[201][201],vis[9999999],ans,b[201],l;
int dfs(int p){
    int w=l^1<<(p-1); 
    for(int i=1;i<=n;i++)
    {
    	if(a[p][i]&&i!=p)
    	{
    		w^=1<<(i-1);
    		for(int j=1;j<=n;j++)
    		if(a[i][j]&&i!=j)w^=1<<(j-1);
    	}
    }//只搜两层,把搜到的开关取反
    return w;
}
struct node
{
    int x,step;
};//广搜结构体,x为状态,step为步数
queue<node>q;
int main(){
    cin>>m;
    for(int i=1;i<=n;i++){
        cin>>m;
        for(int j=1,x;j<=m;j++)
        {
            cin>>x;a[i][x]=1;
        }
    }
    l=pow(2,n)-1;
    for(int i=1;i<=n;i++)
    {
    	b[i]=l^dfs(i);//第i个开关的效果
    //	cout<<b[i]<<" ";
    }
    q.push((node){0,0});vis[0]=1;//把初始状态入队
    while(q.size())
    {
        node oo=q.front();q.pop();
        int u=oo.x,v=oo.step;vis[u]=0;
        for(int i=1;i<=n;i++)
        {
            int r=u^b[i];if(r==l)return printf("%d",v+1)&0;
            if(!vis[r])q.push((node){r,v+1}),vis[r]=1;
            //取队首拓展,如果能全关直接退出,否则把当前状态入队
        }
    }
   cout<<"Change an alarm clock，please!";
   //原题的逗号是中文标点....
    return 0;
}
```
跑的飞快,只用了25ms.....(~~为什么要开5s~~)