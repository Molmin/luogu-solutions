这一题很多人一开始都想到了暴力（因为数据范围很小，在`100`之内），虽然暴力是能过的，但是因为暴力好写，思路简单，在此不做赘述。

下面我要介绍一种更加好写，代码更少的算法------前缀和。


------------
前缀和，顾名思义，是一个数组的某项下标之前(包括此项元素)的所有数组元素的和，这种算法在求区间的题目中十分好用。比如说求$l$到$r$中所有元素的和，只需用前缀和数组中的下标为$r$减去$l-1$（之所以是$l-1$是因为$l$本身不能被减去）。

有了这种算法，代码就十分好写了。

思路：

先读入数组，边读边算前缀和，再读入`l`与`r`，计算出`l`与`r`的之间的和（用前缀和），如果大于0就加到`sum`和变量中，最后输出。（更详细解释再代码中）

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[102],he[102],sum;//用he数组表示记录前缀和,sum记录答案
int main()
{
    int n,m;
    cin>>n>>m;
    int l,r;
    for(int i=1;i<=n;i++)
    {
        cin>>a[i];
        he[i]=he[i-1]+a[i];//计算前缀和，he数组种第i个数表示a数组中前i个数的和，用he数组下标为i-1的和加上a[i]，算出he数组中下标为i的值
    }
    for(int i=1;i<=m;i++)
    {
        cin>>l>>r;
        if(he[r]-he[l-1]>0/*如果l到r中和大于0,注意l-1，he[l]本身不能被减去*/) sum+=he[r]-he[l-1];
    }
    cout<<sum;
    return 0;
}
```
再见！看(dian)懂(ge)即(zan)可(zan)。

求过！