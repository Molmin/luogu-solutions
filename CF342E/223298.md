想到点分树就做完了（

假如能维护 $c_x$ 为 $x$ 子树内离 $x$ 最近的红色点距离。

一开始想的是树剖这个东西，询问拆成查询它到根的链中最低的红点，和以它到根的链中的点为 LCA 的红点。前者很容易树剖两个 $\log$ 解决。如果维护的 $c_x$ 都是加上它到重链底部的距离的值，这样查询就是查询一个最小值，而修改变成了公差为 $2$ 的等差数列加。对于每一个重链开一个李超树支持区间插入线段查询区间最低点（修改 $\log^2$，查询 $\log$ ）可以做到 $\log^3$。总复杂度就是 $\mathcal{O}(n\log^3 n)$，没有实现是口胡的所以可能有误的一个想法（

如果把询问看成对端点为 $x$ 的所有路径看哪个最短路径满足端点为红色，从而想到树分治。建出点分树之后，端点 $x$ 的路径一定经过 $x$ 在点分树内的祖先，那么维护每个点在点分树的子树内的红点，在原树里离它最近的距离是多少，查询的时候 $x$ 加上到它点分树内祖先的距离加上这个最小值，取个 $\min$ 就好。

修改的话直接暴力跳点分树里的父亲然后更新就可以。统计到的路径可能会产生折返，但其实比它优的一定能统计到所以无关紧要。

[code](https://codeforces.com/contest/342/submission/127421460)