首先谈论一下
#### 题目常见问题
1.题目问的是留下的树苗,注意是树苗不是树木(其实我一开始就以为是树木)

### 呵,不要在意这些细节

2.题目第2问是求砍掉的树苗,不是树木!(要注意,我会强调一下的)

解决了常见问题以后,就说一下我的解题思路

------------

### 1.就三种情况:树木(一开始就有),坑(就是树木被砍了),树苗(砍了树又种的)

承认吧,很简单不是吗?
```
#include<iostream>
#include<cstdio>
#include<cmath>
#include<string>
using namespace std;   //l<=10000,n<=100 数据范围......额...... 
int a,b,c,l,n,sm[20000]={0},s=0,z=0;//l:树木棵数,n:砍伐(或种植)次数,sm[20000]:树木情况{0代表树木,1代表坑,2代表树苗},s:树苗棵数,z:树苗被砍伐棵数 
int main()
{
	cin>>l>>n;//输入树木棵数和种植(或砍伐)次数 
	for(int i=1;i<=n;i++)//从第1次到第n次 
```
------------
举个例子(样例1):

首先都是树(如下)

0 0 0 0 0 0 0 0 0 0 0

砍2—6棵树
0 0 1 1 1 1 1 0 0 0 0

种1—8棵树
0 0 2 2 2 2 2 0 0 0 0

砍5—7棵树
0 0 2 2 2 1 1 1 0 0 0

答案就显而易见了,哈

### 2.节省时间(边输入边运算)

------------
```
	{
		cin>>a>>b>>c;//a:种植或砍伐{0代表砍伐,1代表种植},b:起始位置,c:终点位置 
		if(a==1)//如果是种植,那么...... 
		{
			for(int j=b;j<=c;j++)//从第b棵树到第c棵数 
			    if(sm[j]==1)//如果这里是个坑 
				   sm[j]=2;//那么种棵树苗 
		}
		else if(a==0)//如果是砍伐,那么...... 
		{
			for(int j=b;j<=c;j++)//从第b棵树到第c棵树 
			{
				if(sm[j]==2)z++;//如果这里是棵树苗,那么树苗被砍伐数+1 
				sm[j]=1;//这里变成坑 
			}
		}
	}//这里继上一个for循环
	for(int i=0;i<=l;i++)//从第1棵数到第l+1棵树 
	    if(sm[i]==2)//如果第i个地方是树苗,那么...... 
	       s++;//树苗棵树+1 
	cout<<s<<endl<<z;//输出树苗棵数和树苗被砍伐棵数 
	return 0;
}
```
------------
## *再次提醒留下的是树苗不是树木！
## *再次提醒留下的是树苗不是树木！
## *再次提醒留下的是树苗不是树木！(重要的事情说三便)