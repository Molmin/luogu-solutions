一道贪心入门题。题解区两名 dalao 讲得也很好，小蒟蒻太蒻了只好补充一些 dalao 没有讲到或是没有细讲的东西，所以这篇题解是给初学者看的。
### 题目分析
#### 大意
给你 $N$ 个数，把这 $N$ 连在一起使其最大。

~~清晰明了！讲得好！~~
#### 思路
假如你不知道什么是贪心，你看到这题也会想：“哈！好简单！肯定是让最高位最高
啊！”。

也就是我们要让高位尽可能的高，得到的数才会更大，即从最高位开始，我们选择**目前最高位最大的数**，比如下面这组数据：
```cpp
3
998 233 666
```
显然 $998$ 应该放在最高位，然后放 $666$，最后放 $233$。

因此我们可以把数排序，从高到低输出即可，排序方法如下：
```cpp
bool cmp(string a,string b)
{
	return a<b;
}
```
但这是**错误的**,如这组数据：
```cpp
9 998
```
显然答案是 $9998$，但这个程序输出 $9989$。

如何解决？下面介绍**邻项交换法**：

本人口才不好，引用我校神仙nodgd的话解释：

“证明贪心正确性最常用的算法，假设交换顺序，方案不会更优。”

那这道题不就迎刃而解了！我们不是比较两个数，而是比较两个数放在前后哪个更优！即：
```cpp
bool cmp(string a,string b)
{
	return a+b<b+a;
}
```
证明亦是如此。

### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
bool cmp(string a,string b)
{
	return a+b<b+a;
}
int main()
{
	int n=233;
	string a[55];
    //这题的输入是多组数据，一直到N=0结束
	while(1)
	{
		cin>>n;
		if(n==0)
		return 0;
		for(int i=1;i<=n;i++)
		cin>>a[i];
		sort(a+1,a+n+1,cmp);
		for(int i=n;i>0;i--)
		cout<<a[i];
		cout<<endl;
	}
	return 0;
}
```