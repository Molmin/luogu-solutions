O（Nk）时间复杂度0ms过

只有一列的不用说吧，我说下两列的

考虑每一行的状态

0 空出这一行

1 选择左边空出右边

2 选择右边空出左边

3 选择这一行两个（不作为一个矩阵，而是左边一列单独一个矩阵，右边单独一个矩阵）

4 选择这一行两个（两个一块作为一个矩阵的一部分）

定义f[i,j,k]为当前处理到第i行，已经选了j个矩阵，当前行状态为k的最大值（k为上面的0-4种状态）

如果空出这一行，则j不需要变化，直接继承上一行的各种状态的最大值

f[i][j][0]=max(f[i-1][j][0],f[i-1][j][1],f[i-1][j][2],f[i-1][j][3],f[i-1][j][4]);

如果选择左边空出右边，如果上一行的左边没有单独地选择成为矩阵的话（即选择1或3），则j需要包含新选择成为的矩阵（即这一行的左边的这个矩阵）,

如果上一行为同时选择两列的为一个矩阵的状态，则只选择单独的左边是不能包含进去上一行的矩阵的，所以也应j-1(t1为这一行左边的值)

f[i][j][1]=max(f[i-1][j-1][0],f[i-1][j][1],f[i-1][j-1][2],f[i-1][j][3], f[i-1][j-1][4])+t1;

右边同理(t2为这一行右边的值)

f[i][j][2]=max(f[i-1][j-1][0],f[i-1][j-1][1],f[i-1][j][2],f[i-1][j][3], f[i-1][j-1][4])+t2;

选择两个分别单独作为矩阵，类似只选择左边或右边，不过是单独选左边和右边合并了下

f[i][j][3]=max(f[i-1][j-1][1],f[i-1][j-1][2],f[i-1][j][3])+t1+t2;

if(j>=2) f[i][j][3]=max(f[i][j][3],f[i-1][j-2][4]+t1+t2);

选择两个作为一个矩阵，则上一行除了可以接上的，都得j-1

f[i][j][4]=max(f[i-1][j-1][0],f[i-1][j-1][1],f[i-1][j-1][2],f[i-1][j-1][3],f[i-1][j][4])+t1+t2;


代码：




```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
const int INF=0x3f3f3f3f;
const int maxn=105;
const int maxk=11;
int f[maxn][maxk][5];
int main(){
    int n,m,k,t;
    scanf("%d%d%d",&n,&m,&k);
    if(m==1){
        for(int i=1;i<=n;i++){
            scanf("%d",&t);
            for(int j=1;j<=k;j++){
                f[i][j][1]=max(f[i-1][j][1],f[i-1][j-1][0])+t;
                f[i][j][0]=max(f[i-1][j][1],f[i-1][j][0]);
            }
        }
        printf("%d",max(f[n][k][0],f[n][k][1]));
    }
    else{
        memset(f,-INF,sizeof(f));
        for(int i=0;i<=n;i++){
            for(int j=0;j<=k;j++){
                f[i][j][0]=0;
            }
        }
        int t1,t2;
        for(int i=1;i<=n;i++){
            scanf("%d%d",&t1,&t2);
            for(int j=1;j<=k;j++){
                f[i][j][0]=max( max(f[i-1][j][0],f[i-1][j][1]), max(f[i-1][j][2],f[i-1][j][3]));
                f[i][j][0]=max(f[i][j][0],f[i-1][j][4]);
                f[i][j][1]=max( max(f[i-1][j-1][0],f[i-1][j][1]), max(f[i-1][j-1][2],f[i-1][j][3]))+t1;
                f[i][j][1]=max(f[i][j][1], f[i-1][j-1][4]+t1);
                f[i][j][2]=max( max(f[i-1][j-1][0],f[i-1][j-1][1]), max(f[i-1][j][2],f[i-1][j][3]))+t2;
                f[i][j][2]=max(f[i][j][2], f[i-1][j-1][4]+t2);
                f[i][j][3]=max(f[i-1][j-1][1],max(f[i-1][j-1][2],f[i-1][j][3]))+t1+t2;
                if(j>=2) f[i][j][3]=max(f[i][j][3],f[i-1][j-2][4]+t1+t2);
                f[i][j][4]=max( max(f[i-1][j-1][0],f[i-1][j-1][1]),max(f[i-1][j-1][2],f[i-1][j-1][3]))+t1+t2;
                f[i][j][4]=max(f[i][j][4],f[i-1][j][4]+t1+t2);
                //printf("f[%d][%d]:0=%d 1=%d 2=%d 3=%d 4=%d\n",i,j,f[i][j][0],f[i][j][1],f[i][j][2],f[i][j][3],f[i][j][4]);
            }
        }
        printf("%d",max( max( max(f[n][k][0],f[n][k][1]), max(f[n][k][2],f[n][k][3])),f[n][k][4]));
    }
    return 0;
}
```