这题有点神，反正我对这种布尔值的动态规划一般都想不到。

首先当然保证输入合法，即每个位置只能有一个人上或下。

考虑构造一个方案，但是限制很多，做起来十分繁琐。

注意到题目只要求判断是否合法。

然后根据套路，考虑 $ dp_{i} $ 表示 $ [1,i] $ 的楼层是否可以合法。

转移比较好想，可参见 @james1BadCreeper 的博客

即枚举最后一个区间与前面区间的断点，判断前面的区间是否合法与最后一个区间是否合法。

重点落在了判断最后一个区间是否合法上。

先把代码给出，给一个写起来清晰点的做法。

（输入部分比较冗杂，为了大致的美观单独分了一个函数）


```cpp
#include<bits/stdc++.h>
using namespace std;
bool dp[1050];
const int maxn=205;
int n;int a[maxn],b[maxn];
int wh[maxn],p[maxn];
inline void init(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		scanf("%d%d",&a[i],&b[i]);
		if(a[i]!=-1&&b[i]!=-1&&a[i]>=b[i]){
			puts("No");
			exit(0);
		}
		if(a[i]!=-1){
			if(p[a[i]]){
				puts("No");
				exit(0);
			}
			else p[a[i]]=i;
		}
		if(b[i]!=-1){
			if(p[b[i]]){
				puts("No");
				exit(0);
			}
			else p[b[i]]=i;
		}
	}
}

inline bool cal(int l,int r){
	int mid=(r-l+1)>>1;
	for(int i=l,j=l+mid;j<=r;i++,j++){
		if(p[i]&&p[j]&&p[i]!=p[j])return 0;	
		if(p[i]&&b[p[i]]==i)return 0;
		if(p[j]&&a[p[j]]==j)return 0;
	}
	return 1;
}
int main(){
	init();
	dp[0]=1;dp[1]=0;
	for(int i=2;i<=n*2;i++){
		for(int j=i-2;j>=0;j-=2){
			if(dp[j]&&cal(j+1,i)){
				dp[i]=1;
				break;
			}
		}
	}
	if(dp[2*n])puts("Yes");
	else puts("No");
	return 0;
}
```

在输入的同时，先标记好每一个位置已经被谁占了。

若 $ p_{i}=j $，则说明第 $ i $ 层楼被 $ j $ 这个人上电梯或下电梯用了。
 
并在此时顺便处理了显然不合法的情况。

到了 $ cal(l,r) $ 的时候，用了其他大佬在题解里提到的结论：这一个区间里的人乘坐距离都相同。则对于区间里的每个人 $ x $， 应当满足他一定能乘坐到 $x+k$，即 $ x $  转移到  $ x+k $ 这个操作是合法的。我们枚举了区间左右边界，可以确定  $ k=(r-l+1)/2 $
 
实现，类似归并排序，用两个指针 $i,j$ 扫过去，以 $i$ 指代 $x$，以 $j$ 指代 $i+k$。不合法情况有三:
 
 + 对于某个 $ x $，$ x+k $ 已经被使用过了，且在 $ x+k $ 处的不是他 
 
 + 某个人在前半段下电梯
 
 + 某个人在后半段上电梯
 
第一种是因为上面的推理，后两种显然无法保证人在区间里面。
 
（如果人在后半段才上电梯却仍可以在区间里，那么这个区间一定可以按照这个人为界，划分为前后两个更小的区间。）
 
 对应着代码里的三个判断并返回 $0$



最后判断一下 $dp_{2n}$ 就做完了。

思考题：可以发现把 init 里的第一个特判删了也不影响结果（所以上面没提），为什么？   （答案在 cal 后面两个不合法情况里）
