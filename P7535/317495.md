这道题简单来说就是求两人得到的钱等有多接近，看一下数据范围，不难发现，爆搜是肯定过不了的。

- ### 题目分析：
对于这类求最好情况的题， 估计这就是贪心或 dp，再简单造几组数据发现贪心他死了，所以确定这道题肯定是 dp。

- ### 思路：
来研究一下状态转移方程一张钞票要么谁都不给，要么给其中一个。
所以，可以考虑用 $dp[i][j]$ 表示选钱 $i$ 张钞票，差距为 $j$ 
的时候单人分到的最大钱数（不算不选的）。

则可以得到状态转移方程：
```cpp
dp[i][j] = max(dp[i - 1][j], max(dp[i - 1][j + a[i]] + a[i], dp[i - 1][abs(j - a[i])] + a[i]));
```
好心的朋友们测一下，不难发现这样搞会空间起飞。
幸好，我们只用到 $i - 1$ 和 $i$。所以可以直接压成两个一维数组，这样就好了。

- ### 于是有code如下：
```cpp
#include <bits/stdc++.h>
using namespace std;
//这里的变量非常的常规就不说了。
int n, a[505], dp[2][100005], sum;
int main () {
	scanf ("%d", &n);
	for (int i = 1; i <= n; i++) {
		scanf ("%d", &a[i]);
		sum += a[i];//计算和
	}
	memset(dp, -0x3f, sizeof dp);//初始状态赋值极小
	dp[0][0] = 0;
	for (int i = 1; i <= n; i++) {
		for (int j = 0; j <= sum; j++) {
			dp[i & 1][j] = max(dp[i & 1 ^ 1][j], max(dp[i & 1 ^ 1][j + a[i]] + a[i], dp[i & 1 ^ 1][abs(j - a[i])] + a[i]));//美丽的状态转移方程
		}
	}
	printf ("%d", sum - dp[n & 1][0] / 2);//答案
}
```
**如有错误请大佬指出！**