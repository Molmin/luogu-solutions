本人的第五篇题解（如果算上没通过的话），其实本题也是我的第三道蓝题，所以一个萌新，所写的题解可能会有些许问题，但应该可以做到最易理解。

阅读题目，我们为了~~面子~~集体荣誉而需要令自己的队伍排名**尽量靠前**，注意不是**第一**，故要设定每个牌对应的分数来~~自欺欺人~~完成目的。

观察题目数据，按正常人的想法三层循环暴力的话，_$O(1000^3)$_ 将会是永远越不去的坎儿。

故再次阅读题目，发现，我们可以将控制两个变量，然后去寻找第三个变量的范围从而做到优化的目的。

理论上，控制银、铜数去查金牌或是金、铜数去查银牌也是可以的，但根据题中所给的：$1000>=Pg>=Ps>=Pb>=1$ 不难发现上述两种做法编写难度显然大于控制金、银而去查铜牌，故铜牌的那一层循环将是优化的对象。

优化的方式很好理解，先将金、银已得的分数算出，后将自己与别的队伍进行比较，情况有四种，并将四种状态记录到数组 con 中：

1. 不论铜牌分数是多少，我方稳输，记状态为0。
2. 不论铜牌分数是多少，我方稳赢，记状态为1。
3. 铜牌分数小于 _某值_ 时，我方可赢，记状态为2。
4. 铜牌分数大于 _某值_ 时，我方可赢，记状态为3。

于是情况便明朗起来，除输入输出外，程序将主要分为两个模块：记录该种情况为何种状态，判断该种状态下铜牌分数可否让我获胜。听上去很简单，不是吗？

现在我们的问题是，如何找出我们需要的 _某值_ ，记为 dv，这将是接下来解题的关键。

于是我们开始推推式子，将总分记为 totle，金、银总分记为 tot，我们要求：

$totle_{1}\geq totle_{else}$

即：

$tot_{1}+Cu_{1}\times dv\geq tot_{else}+Cu_{else}\times dv$

简单化简后，有：

$dv\geq \frac{tot_{else}-tot_{1}}{Cu_{1}-Cu_{else}}$

共有k支队伍，每一支队伍与一队都有不同的 dv，故可以将 dv 储存在一个数组 po 中，即：

$po_{k}\geq \frac{tot_{k}-tot_{1}}{Cu_{1}-Cu_{k}}$

值得注意的是，如果双方的铜牌数相等将出现除以0的问题而 RE，记得在此处加以特判。

现在，我们需要的 _某值_ 已经具象为一个可以讨论计算的数据，故我们所需要的四种状态便可以用 $po_{k}$ 来具体定义：

1. 若 $po_{k}>$ _银牌分数_ (记为 ps )，我方稳输，记状态为0。
2. 若 $po_{k}<0$ ，我方稳赢，记状态为1。
3. 铜牌分数小于 $po_{k}$ 时，我方可赢，记状态为2。
4. 铜牌分数大于 $po_{k}$ 时，我方可赢，记状态为3。

故，计算出 $po_{k}$，将状态记入 con 后，我们循环每一支队伍，并将胜利次数计入 ma，而关于 con 的判断语句将进行如下操作：

1. 若 $con_{k}$ 为0，即我方必输， $continue$。
2. 若 $con_{k}$ 为1，即我方必赢， ma++。
3. 若 $con_{k}$ 为2，即分数小于 $po_{k}$ 时,我们令铜牌分数为1然后 ma++。
4. 若 $con_{k}$ 为3，即分数不小于 $po_{k}$ 时,我们令铜牌分数为 $po_{k}$ 然后ma++。

注意到情况3与情况4不能同时进行统计，故在真正实现时，我们将两种情况分开统计。


每计算出一组答案同已经记录过得答案进行比对、判断并更新已有答案，最后得出最终答案并输出。

最后附上 AC 代码（对了，在写对拍时与另一篇题解的答案有冲突，上交却依然  AC ，还请各路大佬一同修正并轻喷）：

```cpp
#include<bits/stdc++.h>
using namespace std;

int n,g[20],s[20],b[20],pg=1,ps=1,pb=1,pp,tot1,tot,dv,ma,po[20];
int con[20];//0 no way,1 no problem,2 k小于某值,3 k大于某值 

int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>g[i]>>s[i]>>b[i];
	}
	int cu=b[1];
	for(int i=1;i<=1000;i++)//循环金牌分数
	{
		for(int j=1;j<=i;j++)//银牌分数不能大于金牌，铜牌同理
		{
			tot1=i*g[1]+j*s[1];
			for(int k=2;k<=n;k++)
			{
				tot=i*g[k]+j*s[k];
				if(cu-b[k])
				{
					dv=abs((tot-tot1)/(cu-b[k]));
				}
				
				if(tot>tot1)
				{
					if(cu<=b[k])
					{
						con[k]=0;
					}
					else
					{
						if(dv*(cu-b[k])<tot-tot1)
						{
							dv++;
						}
						con[k]=3;
						po[k]=dv;
					}
				}
				else if(tot==tot1)
				{
					if(cu>=b[k])
					{
						con[k]=1;
					}
					else
					{
						con[k]=0;
					}
				}
				else
				{
					if(cu>=b[k])
					{
						con[k]=1;
					}
					else
					{
						con[k]=2;
						po[k]=dv;
					}
				}
			}
			ma=0;
			for(int k=2;k<=n;k++)
			{
				if(con[k]==1||(con[k]==2&&po[k]>=1))
                //此时判定稳赢与小于某值时胜利的情况，并在后续操作中将铜牌赋为1分
				{
					ma++;
				}
			}
			if(ma>pp)
			{
				pp=ma;
				pg=i;
				ps=j;
				pb=1;
			}
			for(int k=2;k<=n;k++)
			{
				if(con[k]==0||con[k]==1||con[k]==2||po[k]>j)
				{
					continue;
				}
				ma=1;
				for(int l=2;l<=n;l++)
				{
					if(con[l]==0||l==k)
					{
						continue;
					}
					else if(con[l]==1||(con[l]==3&&po[k]>=po[l])||(con[l]==2&&po[k]<=po[l]))
					{
						ma++;
					}
				}
				if(ma>pp)
				{
					pp=ma;
					pg=i;
					ps=j;
					pb=po[k];
				}
				else if(ma==pp&&pg>=i&&ps>=j)
				{
					pb=min(pb,po[k]);
				}
			}
		}
	}
	cout<<pg<<" "<<ps<<" "<<pb<<endl; 
    return 0;
}
```
---
因为格式的原因给审核带来了很多麻烦……非常抱歉！