首先当然是简单翻译一下题目啦！
### 题意
给定一个由 $0$ 和 $1$ 构成的序列，求出能构造出该序列的操作序列，规定操作如下：  
对于一个目前长度为 $n$ 的序列（最开始长度为 0），操作 $i$（$i$ 的取值范围为 $0-n$）会将该序列中前 $i$ 个元素进行反转（即 $0$ 变成 $1$,$1$ 变成 $0$），然后在第 $i+1$ 位插入一个 $0$。  
举例，对于操作序列$(0, 0, 2, 1)$，序列变化如下：
1. 操作 $0$，序列变为$[0]$。
1. 操作 $0$，序列变为$[0, 0]$。
1. 操作 $2$，序列变为$[1, 1, 0]$。
1. 操作 $1$，序列变为$[0, 0, 1, 0]$。

### 解法
首先我们就要判断是否具有合法解，不管做什么操作，显而易见的，操作完了之后最后一位都只能是 $0$，因此当序列最后一位是 $1$ 时，不具有合法解。  
那么对于最后一位是 $0$ 的时候，我们需要如何进行构造，如何思考其是否合法呢？  
首先给出结论，最后一位是 $0$ ，则必然有合法解。下面请听我慢慢分析。  
对于一个序列$[1, 1, \cdots, 1, 0]$，聪明的你一定能想到，我们可以使用操作序列$(0, 0, \cdots, 0, k)$来构造（$k$ 为该序列中 $1$ 的个数，$0$ 的个数为 $k$）。特殊地，对于 $k = 0$ 的情况，操作序列为$(0)$。   
而对于两个这样的序列拼起来的序列$[1, 1, \cdots, 1, 0, 1, 1, \cdots, 1, 0]$（前半部分和后半部分连续 $1$ 的个数分别为 $k_1$, $k_2$）的序列，可以使用操作序列$(0, 0, \cdots, 0, k_2, 0, 0, \cdots, 0, k_1)$（前半部分和后半部分连续 $0$ 的个数分别为 $k_2$，$k_1$），并且这种拼装对 $k = 0$ 的情况仍然适用。  
于是聪明的你一定发现了，对于最后一位为 $0$ 的序列，不管它是什么样的，都可以用这种拼装来表示，于是它们都合法，并且你也找到了它们所对应的操作序列，至此你就可以开心地 AC 了！

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;

int t, n, a[100010], b[100010], cnt = 0;

int main() {
	cin >> t;
	while(t--) {
		cnt = 0;
		cin >> n;
		for(int i = 1; i <= n; i++)
			cin >> a[i];
		if(a[n] == 1) {
			cout << "NO" << endl;
			continue;
		}
		cout << "YES" << endl;
		
		int j = 0;
		for(int i = 1; i <= n; i++) {
			if(a[i] == 1) {
				j++;
			}
			else{
				b[++cnt] = j;
				for(int k = 1; k <= j; k++) {
					b[++cnt] = 0;
				}
				j = 0;
			}
		}
		for(int i = cnt; i >= 1; i--)
			cout << b[i] << " ";
		cout << endl;
	}
    return 0;
}
```
