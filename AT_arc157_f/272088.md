提供一种简单、套路、易懂且时间复杂度比题解优秀的做法。 ~~`AtCoder rating` 太低只能在洛谷写题解了。~~

考虑求 `最长公共子序列` 的那个 `dp` ，设 $f_{i,j}$ 表示两个序列分别前 $i,j$ 个字符，它们的 `最长公共子序列` 。

考虑拓展到这一问题，状态新增一个 $S$ 表示下标为 $(\min(i,j),\max(i,j)]$ 的 `XY` 位置是否交换。

`dp` 的值为字典序最小的 `最长公共子序列` ，这个可以压成一个 `long long` 直接存储取 $\min$ ， $O(1)$ 转移是显然的。

考虑时间复杂度，设 `最长公共子序列` 的长度为 $l$ ，若 $n-|i-j|<l$ 则可以不 `dp` 它，因为它不可能成为答案。

由于任意三个位置都必定能匹上两个，故 $l\ge \lfloor\frac{2}{3}n\rfloor$ ，事实上这个界是可以达到的，构造如下。

```
XXYXXYXXY...
YXYYXYYXY...
```

由于 $l\ge \lfloor\frac{2}{3}n\rfloor$ ，故 $|i-j|\le n-l\le \lceil\frac{1}{3}n\rceil$ ，也就是总的状态数或者说总时间复杂度不超过 $O(n2^{\frac{n}{3}})$ 。

这个界很松，例如上述这一构造， $i,j$ 之间的 `XY` 数量大概不超过 $(\frac{1}{3})^2 n$ ，即上述构造总时间复杂度 $O(n2^{\frac{n}{9}})$ 。

继续挖掘它的性质，设刚开始的字符串的每个位置均为 `XY` ，考虑将一个 `XY` 的位置变成 `XX/YY` 会发生什么。

初始时 $l=n-1$ ，每改变两个位置会使 $l$ 减小 $1$ ，而这需要满足连续三个位置不全为 `XX/YY` ，否则无法减小 $1$ 。

设有 $k$ 个 `XX/YY` 的位置，则 $l$ 大概至多是 $n-\frac{k}{2}$ ，接下来考虑 $i,j$ 之间最多有多少个 `XY` 这种位置。

一个显然的思路就是假设 $i,j$ 之间全部为 `XY` ，那么 $|i-j|$ 最大约为 $\min(\frac{k}{2},n-\frac{3}{2}k)$ ， $k$ 取到 $\frac{n}{2}$ 时该式取到 $\frac{n}{4}$ 。

容易发现 $k$ 比 $\frac{n}{2}$ 小时 $n-l$ 太小达不到 $\frac{n}{4}$ ，比 $\frac{n}{2}$ 大时 $|i-j|$ 虽然可以很大但中间的 `XY` 位置很少。

具体的构造就是前面大概 $\frac{n}{4}$ 个位置为 `XY` ，剩余的位置为上面那个构造，此时总时间复杂度 $O(2^{\frac{n}{4}})$ ，达到上界。

至于 $l$ 如何得到就直接 `贪心` 即可，具体就是记录前面能保留什么字符，直接一位一位暴力 `贪心` 匹配即可。

事实上常数很大，但可以轻松跑过 $n=50$ ，只需要 $8\ \text{ms}$ ，目前在 `AtCoder` 上是最优解，可以 $200\ \text{ms}$ 内跑出 $n=80$ 。

随机数据下跑得非常快，大概可以在 $10\ \text{ms}$ 以内跑出 $n=120$ ， $n$ 更大的话 `__int128` 会存不下。[代码](https://atcoder.jp/contests/arc157/submissions/39330696)。