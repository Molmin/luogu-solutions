装箱问题裸题

看到这种解法只有pascal,那我就发一个c++题解

思路类似于桶排：如果某个质量可以取，那么这个质量加上当前物体的质量也可以取

具体看注释

```cpp
#include<bits/stdc++.h>
using namespace std;
long long v,n,a[501],F[100000];
//F[i]表示重量为i的情况是否存在(数组开大防止越界)
int main()
{
	cin>>v>>n;//输入最大质量和个数
	for(int i=1;i<=n;i++)
	cin>>a[i];//a[i]为每个物体的质量
	F[a[n]]=1;
    F[0]=1;//初始化，空的和装最后一个的状态初始化为1
    for(int i=n-1;i>=1;i--)//从后向前搜索防止重复累加
	{
        for(int j=v;j>=0;j--)//从后往前防止重复
        if(F[j]!=0)
        F[j+a[i]]=1;
        //如果F[j]这个状态本来可以取，那么F[j+a[i]]这个状态也可以取。F[j]=1标记F[j]可以取
	}    
	for(int j=v;j>=1;j--)//从最大质量往前搜索
	if(F[j]==1)//找到第一个能取到的即为最大质量
	{        
	cout<<j;//输出能取的最大质量
	return 0;//强制终止程序
	}
}
```