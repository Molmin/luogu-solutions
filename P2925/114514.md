
### 本题是01背包的经典题型，

#### 不过这里需要用到优化（其实也不叫优化），不然可能超时

#### 在第二个循环的时候可以直接从a[j]开始，这样可以保证用容量去减a[j]的时候一定大于等于0。从而能够节省一个判断的时间

#### （不然可能只有91分哦）

```cpp
include<iostream>
using namespace std;
int a[50500];
int ans[50500];//ans数组就用来统计答案
int main()
{
    int n,m;
    cin>>n>>m;
    for(int j=1;j<=m;j++)
    {
        cin>>a[j];
        for(int i=n;i>=a[j];i--)
        {
            ans[i]=max(ans[i],ans[i-a[j]]+a[j]);
        }
    }
    cout<<ans[n];
    return 0;
}//程序结束
```
### 背包问题其实算是动态规划问题中的一个分支，这道题是一道标准的01背包问题，比较适合初学者。
#### 学背包的时候如果有不懂是正常现象，毕竟初学，可以通过做题练习以及交流的方式使自己的代码能力得到提高




