规定（都是正常的规定，可以跳过）：

用二进制数 $k$ 来表示一个集合，某一位为一表示有，零表示没有，$|k|$ 表示集合 $k$ 的大小，即二进制表示下 $1$ 的个数，$x|y$ 表示集合 $x$ 和 $y$ 的并集，即按位或，$x\&y$ 表示集合 $x$ 和 $y$ 的交集，即按位与，$x\otimes y$ 为集合 $x$ 和 $y$ 的对称差，即按位异或。

---
不妨设序列的最大前缀和在相等时取其一次出现的，当序列 $a_i$ 的最大前缀和是 $\sum\limits_{i=1}^ka_i$ 当且仅当 $\forall p\in[1,k),\sum\limits_{i=1}^pa_i<\sum\limits_{i=1}^ka_i$,$\forall p\in(k,n],\sum\limits_{i=k+1}^pa_i\le0$，这样将序列分成了前后两个子集。

设 $f_x$ 表示集合 $x$ 最大前缀和用到了所有数字的排列数，$g_x$ 表示集合 $x$ 满足任意前缀和非正的排列数，则答案为 $\sum\limits_{x=1}^{2^n-1}f_xg_{x\otimes(2^n-1)}$。

考虑如何求 $f$ 和 $g$，$g$ 可以通过简单的状压递推求：
```cpp
for(p=0;p<k;++p)
for(int x:G[p])
for(i=0;i<k;++i)
if((q=x|(1<<i))^x)
if((sm[q]=sm[x]+a[i])<=0)
if((dp[q]+=dp[x])>=M)dp[q]-=M;
```
以上 `sm` 表示集合元素和，`dp` 即需要求的 $g$ 数组，`p` 枚举的是集合元素个数（大小），`G[p]` 表示大小为 `p` 的集合。

于是 $g$ 求出来了，求 $f$ 可以使用基础容斥，考虑 $x$ 的前缀和不会用到所有数的情况有 $\sum\limits_{y\&x=x}f_yg_{y\otimes x}$ 种，用总排列数 $|x|!$ 减去即可。发现这是一个子集卷积形式，而且只有位数小的会推到位数大的，满足无后效性，参考[小清新子集卷积](/blog/502410/subset-sconvolution-fresh)，运用快速沃尔什变换可以做到 $O(n^22^n)$ 时间，$O(n2^n)$ 空间。

[LOJ 上的 AC 记录](https://loj.ac/s/1539004)