ARC 特有的代码简单但 Ad-hoc 的题 /oh

------------

首先考虑 $n = 2$ 的情况。不妨进行一个表的打，观察一下 $[0 \sim 19] \times [0 \sim 19]$（$1$ 表示 Alice 胜，$0$ 表示 Bob 胜）：
```
01111111111111111111
11001111111111111111
10101111111111111111
10011111111111111111
11111111011101111111
11111111110011001111
11111111101010101111
11111111100110011111
11110111111101111111
11111100111111001111
11111010111110101111
11111001111110011111
11110111011111111111
11111100110011111111
11111010101011111111
11111001100111111111
11111111111111111111
11111111111111111111
11111111111111111111
11111111111111111111
```
不难发现对于每个 $4 \times 4$ 的块，要么跟 $[0 \sim 3] \times [0 \sim 3]$ 相同，要么全 $1$；而且，如果把 $[0 \sim 3] \times [0 \sim 3]$ 视为 $0'$，全 $1$ 视为 $1'$，则还会构成原分形。

基于上述观察，我们猜想：若存在 $a_1, a_2$ 某一位（四进制下）使得其满足把这位的两个数抓出来满足 Alice 胜，则 Alice 胜；否则，Bob 胜。

证明：

- 设 $a_i$ 在四进制下的第 $j$ 位为 $b_{i, j}$，$\max a_i$ 的最高位为 $k$。
- 抓出最高的满足该条件的位 $j$，考虑当前先手选择的 $X$。
- 只要我们证明先手在我们猜测的必胜状态下可以给出一种方案使得其转化为必败状态，则原命题得证。

1. $b_{1, j} = b_{2, j} > 0$

若第 $k$ 位满足前文猜想的先手必胜的条件，令 $X_k = \max(b_{1, k}, b_{2, k})$；否则，令 $X_k = 0$。

2. $b_{1, j} = 0, b_{2, j} > 0$

若 $b_{1, k} = b_{2, k} > 0$，令 $X_k = 0$；若 $b_{1, k} = 0, b_{2, k} > 0$，令 $X_k = b_{2, k}$；若 $b_{1, k} > 0, b_{2, k} = 0$，令 $X_k$ 为 $0, b_{1, k}$ 外的任何数；否则，令 $X_k = 0$。

对偶情况同理，不再赘述。

可以发现，先手用上述 $X$ 进行一次上述操作后必然会转化为必败情况，且可以穷举证明，对于剩下四种本质相同的情况，要么已经全 $0$，要么无论选择什么作为最高位，都会转化为先手必胜的情况。于是猜想得证。

将上述结论推广到 $n > 2$ 的情况，~~很难~~发现此时只要满足存在某一位，使得 $n$ 个数中这位存在非 $0$ 项且非 $0$ 项全部相等，则 Alice 胜；否则，Bob 胜。

模拟上述过程即可。时间复杂度为 $O(Tn \log_4 w)$，其中 $w$ 为值域 $10^9$。

代码：
```cpp
#include <stdio.h>
#include <stdbool.h>

int a[107], cnt[7];

int main(){
	int t;
	scanf("%d", &t);
	for (int i = 1; i <= t; i++){
		int n;
		bool ans = false;
		scanf("%d", &n);
		for (int j = 1; j <= n; j++){
			scanf("%d", &a[j]);
		}
		while (!ans){
			bool flag = true;
			for (int j = 1; j <= n; j++){
				if (a[j] != 0){
					flag = false;
					break;
				}
			}
			if (flag) break;
			for (int j = 0; j <= 3; j++){
				cnt[j] = 0;
			}
			for (int j = 1; j <= n; j++){
				cnt[a[j] % 4]++;
				a[j] /= 4;
			}
			for (int j = 1; j <= 3; j++){
				if (cnt[j] >= 1 && cnt[0] + cnt[j] == n){
					ans = true;
					break;
				}
			}
		}
		if (ans){
			printf("Alice\n");
		} else {
			printf("Bob\n");
		}
	}
	return 0;
}
```