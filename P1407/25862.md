**[博客中食用更佳](https://www.luogu.org/blog/xzlhxc/solution-p1407)**
[题目链接（luogu）](https://www.luogu.com.cn/problemnew/show/1407)   
前置芝士：[二分图匹配（匈牙利算法）](https://www.luogu.com.cn/problem/P3386)。

------------

## 题外话
 _突然感觉以前的题解风格奇丑无比，故改用二号标题。_    
 _如对排版有建议或者对题解内容不理解的欢迎私信笔者！_ 
 
~~在学tarjan的时候看到了这道题，于是去学了二分图匹配来做（大雾~~     
第一次看题误将40%的数据看成100%，结果暴力匈牙利，TLE+RE……     
这题相对于模板的二分图匹配多了亿些思考量，不失为一道好题。

## ①题意翻译
给定一个$2*N$个节点的二分图，初始时给出一个完全匹配，每次尝试删掉一个匹配（及边）并询问是否仍存在完全匹配（每次输出结果后要将删除的边复原）。

$0<N \leq 4000$ ,$0< M \leq 20000$
好像已经把做法说得明明白白了呢……那么考虑一下细节吧……

## ②细节
**1.** 本题建图时可用$map$映射，如果怕$TLE$可以写个哈希函数 ~~（反正我不会，谁教教我）~~。**可以用1~n的编号存左节点，n+1~2n的编号存右节点。** 其它题也可这么做。
```cpp
for(int i=1;i<=n;i++)//储存夫妻关系
{
	string A,B;
	cin>>A>>B;
	Num[A]=++num,Num[B]=num+n;
  //Num为字符串->编号的map，num为编号。
	addedge(num,num+n);//加边
	match[num+n]=num,match[num]=num+n;//匹配
}
//储存“情人”边的时候就简单了，只要根据map的值加边就可以。
```

------------

**2.** 没有必要跑完整一遍匈牙利，题目中给的“夫妻关系”一定是一对一的，所以题目**已经给了你一个完全匹配了** ，只需要在这个完全匹配上，**每次删去一组匹配关系和匹配边**，再跑匈牙利，**如果有增广路，就说明去除了这条边之后还能形成n对夫妻，反之则不能。**
```cpp
for(int i=1;i<=n;i++)
{
	CX=i,CY=match[i];//全局变量标记删除边
	match[CY]=0;//删除匹配关系
	if(dfs(i))cout<<"Unsafe\n";
	else cout<<"Safe\n";
	match[CY]=i;//复原匹配关系
	memset(visit,0,sizeof(visit));
}
```
**每次$dfs$最多访问$n$个节点，故时间复杂度为$O(N^2)=O(AC)$ 。**

------------

**3.** 由于本题的匈牙利只是为了判定有没有完全匹配，并不是求一个新的匹配，况且每一次还要将删去的边复原，所以在$dfs$的过程中不必记录新的匹配，只要返回$true/false$即可。
```cpp
bool dfs(int u)
{
	for(int i=hd[u];i;i=nx[i])
	{
		if(visit[to[i]]||(u==CX&&to[i]==CY))continue;
                //如果w(u,v)为删除边，则不能走。
		visit[to[i]]=true;
		if(!match[to[i]]||dfs(match[to[i]]))
		 return true;//不用记录新的match
	}
	return false;
}
```

------------

**4.** 注意数据范围：点数为$N*2$，边数为$(N+M)*2$ ，一不小心就很容易$RE$……~~惨痛的教训~~

## ③AC！
“居然几乎把全部代码都给了，真不像我的风格……”   
~~可能以后会更新tarjan做法（等我理解了之后）。~~    
喜欢就点个赞吧！
