## 将合法括号序列转化为树形结构

学过莫队处理树上关于链的询问的同学应该知道对于任意一棵 $n$ 个点的有根树都可以构造出一个长度 $2n$ 的括号序列：

```cpp
void dfs(int x) {
    rbs[++cnt]='(';
    for (auto v : G[x]) {
        dfs(v);
    }
    rbs[++cnt]=')';
}
```


比如下面这棵树构造出来的括号序列即为 $\texttt{((()(()))(()))}$。

![](https://cdn.luogu.com.cn/upload/image_hosting/02jen7pt.png)

并且其中任意一对匹配的括号都可以对应到原树的一棵子树，任意一个左括号可以对应到原树的一个点。

而对于任意一个长度为 $2n$ 的（形如 $(S)$，其中 $S$ 是一个合法括号序列）合法括号序列我们都可通过下面的方式建立一棵 $n$ 个点的有根树，使得该树构造出来的括号序列恰好为给定的括号序列：

* 初始化 $tot=1,now=1$。

* 扫描括号序列的第 $2$ 到 $2n-1$ 位。

* 如果括号序列的第 $i$ 位为左括号令 $tot \gets tot+1,fa[tot]=now,now=tot$。

* 如果括号序列的第 $i$ 位为右括号令 $now\gets fa[now]$。

而第 $i$ 个左括号即对应到树上编号为 $i$ 的点。

而对于形如 $\texttt{(S1)(S2)...(Sm)}$ 的括号序列（$\texttt{Si}$ 均表示一个合法括号序列），可以加一对匹配的括号将其变为形如 $\texttt{(S)}$ 的括号序列：

$$
\texttt{(S1)(S2)...(Sm)}\to \texttt{((S1)(S2)...(Sm))}
$$

对变形后的括号序列建树可以得到一棵 $n+1$ 个点编号从 $0\sim n$ 的树。

（下面的代码中， `str` 为变形之前的括号序列）

```cpp
int tot = 0,now = 0;
for (int i = 1; i <= 2 * n; i++) {
    if (str[i] == '(') {
        G[now].push_back(++tot); fa[tot] = now; now = tot;
    } else {
        now = fa[now];
    }
}
```
接下来考虑对于一种不存在 $\texttt{(A)(B)}$ 结构的括号序列其树形结构是怎么样的。

不难发现，对于有根树中的某个点 $u$，如果其有 $\ge 2$ 个儿子，那么该树构造出来的括号序列中一定有形如 $\texttt{(A)(B)}$ 的结构。因此对于一种树形结构来说，其构造出来的括号序列不包含 $\texttt{(A)(B)}$ 的必要条件是对于任意一个点 $u$，点 $u$ 有且仅有一个儿子。并且这个条件是充分的，因为对于一条链而言其对应的括号序列一定是形如 $\texttt{(((((())))))}$ 的。

再考虑题目中给的两种操作如何对应到树上。

因为对于任意一种合法的括号序列一定可以写成形如 $\texttt{(A)(B)(C)...}$ 的形式，而相邻的匹配的括号对应到树上一定是在 DFS 过程中相邻的子树，因为出一棵子树会向括号序列中添加一个右括号因此在括号序中相邻的匹配的括号一定是兄弟关系。

那么操作二可以看成：对于儿子个数 $\ge 2$ 的点 $u$ 选取两段相邻的儿子交换其子树的位置位置。进一步可以直接看成交换任意两个儿子的子树。

因为操作而可以用 $0$ 费用进行儿子位置的交换，所以在操作 $1$ 中我们可以不在意儿子在 DFS 过程中的顺序。

而对于操作 $1$ 可以看成：对于一个儿子个数 $\ge 2$ 的点 $u$，选取两个儿子 $p,q$，将所有 $q$ 儿子的子树“挂到” $p$ 上，再将 $q$ 作为叶节点“挂到” $p$ 上，花费为 $x\times w[p]+y\times w[q]$，并且在下面的讨论中，我们将使用 $\mathrm{op(p,q)}$ 表示对 $p,q$ 进行操作 $1$：

![](https://cdn.luogu.com.cn/upload/image_hosting/vzg70cu1.png)

那么问题即可转化为通过若干次操作 $1$ 与操作 $2$，将给定有根树操作成一条链的最小花费。

在下面的讨论中我们将按自顶向下的顺序考虑：即从 $1$ 到 $n$ 依次考虑在最终链中深度为 $i$ 的点是哪个点，按自上到下的顺序合并（这里可以感性理解一下，因为子树内部的合并在当前层的合并之后做也不影响，所以一定可以先将当前层合并之后再考虑内部的合并），并且在下面的讨论中如果当前考虑到了第 $i$ 层，同时考虑维护一个集合 $S_i$ 表示当前情况下，链的深度为 $i$ 的点可能取哪些点。

## $x=0,y=1$

考虑钦定一个点 $u\in S_i$，在第 $i$ 层“保留”点 $u$，该种情况下的最小花费。

因为除了 $u$ 以外的点都需要至少合并到另一个点上，所以 $\forall v\in S_i,v\ne u$，都需要付出 $w[v]$ 的花费。

因为未保留的点在下面层的合并中还要付出花费，所以在当前层中一定是保留一个权值最大的点。

使用堆维护 $S_i$ 以及当前堆中元素的 $w$ 的和即可。因为每个元素至多进堆一次出堆一次，所以复杂度为 $O(n\log n)$。

## $x=1,y=1$

同样考虑钦定一个点 $u\in S_i$，在第 $i$ 层“保留”点 $u$，该种情况下的最小花费。

因为 $\mathrm{op(p,q)}$ 的花费为 $w[p]+w[q]$，所以 $v\in S_i$ 内的所有点贡献都可以写成 $(pt[v]+qt[v])\times w[v]$，其中 $qt[v]$ 表示操作 $\mathrm{op(p,v)}$ 发生的次数，$pt[v]$ 表示操作 $\mathrm{op(v,q)}$ 发生的次数。并且不难发现 $\forall v\in S_i,v\ne u$，$qt[v]=1$，$qt[u]=0$。

而 $\sum_{v\in S_i} pt[v]=|S_i|-1$，因此应该让 $\min_{v\in S_i}(w[v])$ 参与尽量多的合并。

那么不难得到在确定 $u$ 情况下的贪心策略：先将除了 $u$ 外的所有点 $v$ 向 $w$ 最小的点 $p$ 合并，最后再将 $p$ 与 $u$ 合并。

因为对于未保留的点还会在后面参与合并，因此当前层一定是保留 $w$ 最大的点最优。

使用数据结构维护这个过程复杂度同样是 $O(n\log n)$。

## $x=1,y=0$

考虑钦定一个点 $u\in S_i$，在第 $i$ 层“保留”点 $u$，该种情况下的最小花费。

不难发现，和 $x=1,y=1$ 类似一定是先都合并到权值最小的点再合并到 $u$。 

即如果 $|S_i|\ge 2$，花费为 $\min_{v\in S_i}(w[v])\times (|S_i|-2)+w[u]$。

> key Observation：无论每一层留下的点是谁，$|S_i|$ 是不变的。即 $|S_i|$ 是可以唯一确定的。

并且实际上本题可以看成点与层的匹配，即每层保留哪个点，在第 $i$ 层的点可以与 $\ge i$ 的层匹配。

而对于一种已经确定的匹配方案，$\min_{v\in S_i}(w[v])$ 即 $\le i$ 层的点中所有匹配的层 $\ge i$ 的点的最小点权。而 $|S_i|$ 可以在 $O(n)$ 的时间内预处理出来。

考虑一种理想情况：$\forall i,|S_i|\ge 2$（实际上这种情况一定不存在，因为一定有 $|S_n|=1$）。

令 $val[i]=|S_i|$。

令 $match[i]$ 表示匹配到第 $i$ 层的点，$d[i]$ 表示点 $i$ 的深度，这样任意一种匹配的方案的花费可以写成：

$$
\sum_{i=1}^nw[match[i]]+\min_{j\ge i,d[match[j]]\le i}(w[match[j]])\times \max(0,val[i]-2)
$$

等价于：

$$
\sum_{i=1}^nw[i]+\sum_{i=1}^nmin_{j\ge i,d[match[j]]\le i}(w[match[j]])\times \max(0,val[i]-2)
$$

那么我们只需要最小化：

$$
\sum_{i=1}^nmin_{j\ge i,d[match[j]]\le i}(w[match[j]])\times \max(0,val[i]-2)
$$

而这样，我们并不在意每一层谁留下，我们更在意每一层谁“下去了”，更具体而言我们只在意当前层的最小值是否“下去了”，不难发现对于一个取到最小值的点在遇到比该点权值更小的点之前留在某一层一定不优，并且根据单调栈相关理论不难发现其为前缀最小值的结构。

因为 $\forall i,val[i]\ge 2$，所以 $min_{j\ge i,d[match[j]]\le i}(w[match[j]])$ 一定能够取到 $\min\limits_{d[j]\le i}(w[j])$（即每次将除了取到当前的前缀最小值以外的点留下）。

接下来考虑一种比较棘手的情况：存在 $val[i]=1$，如何处理？

但是实际上可以发现除了 $val[n]=1$ 以外，$val[i]=1$ 的位置一定是一段（可能非空的）前缀。 

这是怎么回事呢？令 $G_i$ 表示 $S_i$ 中所有点儿子构成的集合，不难发现 $|S_{i+1}|=|S_i|-1+|G_i|$。因此如果 $|G_i|\not=0$，一定有 $|S_{i+1}|\ge |S_i|$，并且如果存在 $|G_i|=0$，那么 $\forall j\ge i,|G_j|=0$。

因此 $val$ 整体上一定是如下的结构：先非严格单调递增，后严格单调递减。

考虑严格单调递增的部分，满足 $val[i]=1$ 的位置一定是一段前缀，而严格单调递减的部分有且仅有 $val[n]=1$。

并且对于一段 $val[i]=1$ 的前缀，我们是并不用考虑的，因为匹配这段深度的点一定是唯一确定的。

（下面的讨论中将该段前缀扔掉）

因此实际上，至多有一个点匹配会匹配 $val[i]=1$ 的点。

考虑枚举匹配深度为 $n$ 的点 $u$，不难发现如果 $\forall i\ge d[u],val[i]>2$，那么 $\forall i,min_{j\ge i,d[match[j]]\le i}(w[match[j]])$ 一定还能够取到前缀最小值。

而实际上因为本题 $val$ 的结构，$val[i]=2$ 的深度 $i$ 也一定是连续的一段前缀（因为已经将为 $val[i]=1$ 的一段前缀扔掉了），并上深度 $n-1$。

而 $val[n-1]$ 实际上并不用考虑，因为其并不会产生任何贡献。

考虑找到一个 $lim$，使得 $\forall lim<i<n-1$，满足 $val[i]\not=2$。

如果 $d[u]>lim$，那么 $\forall i,min_{j\ge i,d[match[j]]\le i}(w[match[j]])$ 一定还能够取到前缀最小值。

如果 $d[u]\le lim$，因为 $\forall i\le lim$，的深度 $i$ 不会产生贡献，所以这里只需要考虑对 $i>lim$ 的深度 $i$ 产生的贡献。

并且实际上只有 $u$ 一个点满足 $d[u]\le 2$，且 $u$ 匹配的深度 $>lim$。

$\forall i>lim$，$min_{j\ge i,d[match[j]]\le i}(w[match[j]])$ 能够取到从 $lim+1$ 的最小值 / $w[u]$。

因为前缀最小值具有单调性，所以这里考虑二分出最大的取 $w[u]$ 的前缀即可。

复杂度 $O(n\log n)$。

[代码链接](https://www.luogu.com.cn/paste/lq4cwln3)

 