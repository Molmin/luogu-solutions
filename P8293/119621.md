首先把括号序列转化成一棵有根树，每个点 $u$ 有一个权值 $a_u$。

考虑两类操作对树的形态的影响。

假设有两个节点 $u,v$，它们的儿子集合分别为 $S_u,S_v$。

显然只有 $u,v$ 父亲相同时才能操作。

分析对于 $u,v$ 进行操作得到的结果：

- 如果是第一类操作，那么 $S'_u=S_u\cup S_v\cup \{v\},S'_v=\varnothing$，代价是 $x\times a_u+y\times a_v$。

- 如果是第二类操作，那么只会交换 $u,v$ 的先后顺序。

我们最终需要达到的形态是一条链。

容易发现，一定存在一种最优策略是按照深度从小到大依次操作。

因为在操作深度为 $dep$ 的点时深度为 $1\sim dep-1$ 的点已经形成了一条链，所以我们只关心每个点的权值和深度。

接下来按照 $x,y$ 分类讨论。

令当前这一层（包括从上面传下来的）的点的权值形成的集合为 $S$。

令 $mn,sum$ 分别为 $S$ 中所有数的最小值，最大值，总和。

因为最终形成一条链，所以每一层只会删除一个节点，剩下的都会被传到下一层。

$x=0,y=1$：

删除权值为 $w$ 的节点需要付出的代价是 $sum-w$。那么显然删除**最大值**一定是最优策略。

$x=1,y=1$：

删除权值为 $w$ 的节点需要付出的代价是 $sum+mn\times (|S|-2)$。那么显然删除**最大值**一定是最优策略。

$x=1,y=0$：

删除权值为 $w$ 的节点需要付出的代价是 $w+mn\times (|S|-2)$。

这时候就不能贪心地删除最大值了。

根据这个式子可以发现，前 $n-1$ 层每一层删除的节点都会产生对应权值的贡献。我们前 $n-1$ 层中每一层的 $mn$ 都尽量小，又要使得前 $n-1$ 层中每一层的 $w$ 之和尽量小。

只有一个点不会在前 $n-1$ 层中被删除，因此相当于是要使得第 $n$ 层的 $w$ 最大。

不妨假设前 $n-1$ 层中不存在 $|S|=1$ 的情况，这种层一定没有贡献。

如果对于前 $n-2$ 层都有 $|S|\ge 3$，那么每一层都删除**次大值**一定是最优策略。

但有时可能不满足这个条件。

可以发现前 $n-2$ 层中 $|S|=2$ 的层一定形成一段前缀。我们可以事先计算出每一层的 $|S|$ 并找到这一段前缀。假设这一段前缀为 $1\sim p$。

显然，操作完前 $p$ 层之后只会传下来一个节点。

可以直接暴力枚举传下来的是哪个节点，然后用之前 $|S|\ge 3$ 的做法往后贪心就可以得到一个 $O(n^2\log n)$ 的做法。

但实际上可以发现我们留下的一定是前 $p$ 层中涉及到的所有数中的最小值或者最大值，这一点可以用调整法证明。

这样我们就得到了一个 $O(n\log n)$ 的做法，可以通过本题。

题外话：实际上我认为 $x=1,y=1$ 和 $x=1,y=0$ 难度差不多，但大部分人好像认为后者难很多？~~虽然按照题解的篇幅来看好像后者确实难很多~~