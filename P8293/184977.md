首先做掉 $x=y=0$ 的情况，不管你怎么变我都摆烂输出 $0$。

考虑两个小结论，一个是内层括号提不出来（比如 `(())()` 不能变成 `()()()`），即内层括号不影响外层；二个是你执行的操作 1 次数固定。这两个比较显然。并且被提入内层的永远是右边的左括号。

然后是观察一点特殊性质，比如有一个 $x=0,y=1$ 的部分分。那我们先研究一下这个 $x=0,y=1$ 的部分分。

因为有第一个结论，所以每层互不影响。注意到这个部分分下，我们想让每一层较大的值尽量不贡献，同时发现造成贡献的括号会提入内层继续贡献，那么显然提入内层的括号越小越好。那么这个部分分的贪心策略是在当前层留下最大的左括号，然后解决下一个子问题。记每层的括号权值总和为 $S$，最大的权值为 $p$，那么会造成贡献 $S-p$。

然后考虑看起来非常复杂的 $x=y=1$ 啊。在这个语境下，因为我们还是想要把小的括号放进内层持续贡献。那么将小的放入内层的策略需要我们进行考虑。我们仍然想尽量让大的少贡献，但是这里大的要留在外面必须要贡献一次。那我们有一个简单的策略是，先把非最大值或最小值的左括号塞进最小值（记为 $p$）对应的括号，然后再将最小值对应的左括号塞进最大值对应的括号里。设当前层括号个数为 $|S|$，权值总和为 $S$，易得该层贡献为 $p(|S|-2)+S$。

最后是 $x=1,y=0$，现在是左括号贡献了，但是我们并不好沿用上面的方法，最根本的原因是结构上的问题，因为左括号不会放进去持续贡献。先考虑结构，每一层在一开始的时候的括号个数排成一个序列，会形似 $1,1,\cdots,1,2,2,\cdots ,2,\geq 3,\geq 3,\geq 3, \cdots ,1$。首先前面的极长的 $1$ 可以忽略。从 $\geq 3$ 部分开始之后，我们的策略就唯一了：我们既想让小的持续贡献，还不想让大的贡献，那我们干脆两个都放进去好了。证明方法可以采用 exchange argument（可以假设如果我们将最小值或者最大值留在外面反证）。

但是前面有一堆 $2$，这堆 $2$ 的意义在于，我们最终加入第一个 $\geq 3$ 层的值无法确定。显然这个值要么是前面一堆 $2$ 中的最小值或者最大值，证明仍然采用 exchange argument（如果我放入的不是最小值或最大值那么一定不优于最小值或最大值其中一者或两者，证明很简单）。然后这样的话只需要做 $O(1)$ 遍决策。

上面的三个决策都可以在 $O(n \log n)$ 时间内实现。

鉴于代码比较长，我放在[这儿](https://www.luogu.com.cn/paste/enhpj4ng)吧。