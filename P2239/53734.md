这应该是一道数学题，暴力是肯定过不了的（估计这是废话）。

既然是数学题，我看到许多的人都是用 O(n) 过的，但是可不可以 O(1) 就可以过呢，我们来探讨一下。

![](https://cdn.luogu.com.cn/upload/pic/12876.png)

这是一个6行6列的矩阵，很明显我们可以将它分成3个空心的正方形进行讨论(1~20,21~32,33~36)，因为既然是螺旋，也就是向右，下，左，上，之后便又到了向右走的时候，也就成了循环，所以我们分成空心正方形的依据就是开头的数字是起始点（向右走），结尾数字是终点（上面是起始点，向右走），很明显所有正方形均可成立。

既然我们要求出i行j列的数字，那么首先我们只需要知道它是在哪一个空心正方形里面就可以缩小搜索范围（由元素个数决定顺序，多前少后），故这一个空心正方形的编号为
```cpp 
long long int l=min(min(i,n+1-i),min(j,n+1-j)); 
```
这一个可以手推，最后就是分情况讨论了。

```cpp
/*
//如果在第一列，求的数=下一个空心正方形的开头数字+（这一个空心正方形的结尾数字所在的列-求的数所在的列+1）。
//如果在最后一列，求的数=……（可以自己想了）。
X X …… X //如果在这一行，求的数=上一个空心正方形的结尾数字+求的数到上一个空心正方形的结尾数字的列的差（有一个规律就是一空心正方形的结尾数字所在的列就是这一个空心正方形的编号）。
X      X
X      X
……    ……
X X …… X//如果在这一行，求的数=上一个空心正方形的结尾数字+（这一个空心正方形的边长-1）*2+（空心正方形的边长-求的数所在的列+1）。
*/
```
```cpp
#include<bits/stdc++.h>
using namespace std;
long long int n,i,j;
int main(){
	scanf("%lld %lld %lld",&n,&i,&j);
	long long int l=min(min(i,n+1-i),min(j,n+1-j));
	long long int r=4*(l-1)*(n-l+1);//上一个正方形的结尾数字
	if(i==l) r+=j-l+1;
	else if(j==l) r=4*l*(n-l)+(l-i+1);
	else if(i==n-l+1) r+=(n-2*l+1)*2+(n+1-j)-l+1;
	else if(j==n-l+1) r+=n-2*(l-1)+i-l;
	printf("%lld\n",r);//答案
	return 0;
}
```