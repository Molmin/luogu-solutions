```
模拟
解法 1：
这是个蛇形填数问题。 如果采用先枚举二维数组再找对应的元素方法，由于 1
≤ n ≤ 30,000，需要建立一个 30,000× 30,000 的二维数组，结果会发生数据
溢出且超出运行内存上限（ 128M)。
我们可以采用类似贪吃蛇的方法，让它在 N×N 个方格内自外向内逐格移动，控
制其向右转的方向，并计算其长度。
如果遇到极端情况时，可能需要枚举达 900000000 次，
这显然太慢了些，我们可以根据贪吃移动的特点对程序进行优化。
可以这样考虑，当贪吃蛇到每个行列的转折点时，可以先判断目的地是否
在自己的正前方，如果是则只需计算当前位置到目的地的距离加上自身的长度即
可；否则就计算到下一个转折点人距离，加上当前自身长度，并到达下一个转折
点，同时控制所在行（或列）的边界向内侧移动；
超时          超时        超时


解法 2：
考虑到贪吃蛇总是从外围一圈圈地向目的地前进，而每一圈刚好是一个正方形，
我们可以先计算外围各圈正方形的周长之和，再让贪吃蛇从目的地所在圈的左上
角出发，计算其从出发地到目的地的长度就可以了。
例如： n=4, (2,2)在第 2 圈， (3,1)在第 1 圈。
n=6， (4,5)在第 2 圈
圈数 q=min(x, y, n-x+1, n-y+1 )
圈数 q 求出后，前 q 圈的数字总和很容易求出来。
对于任何一个方阵：
第 1 圈有 4n-4 个数;
第 2 圈有 4(n-2)-4 个数；
第 3 圈有 4(n-4)-4 个数；
„„
第 q 圈有 4(n-q(n-1))-4 个数
前 1 圈有 4n-4 个数;
前 2 圈有 4n-4 + 4(n-2)-4 = 2(4n-2*4)个数；
前 3 圈有 4(n-4)-4 + 2(4n-8) = 3(4n-3*4)个数；
„„
前 q 圈有 q(4n-4q)个数；
解决了某个位置在螺旋矩阵上的圈数之后
目标位置(i,j)到底在当前这一圈的第几个位置？
如目标数 26 所在的位置(4,5)，在第 2 圈的什么位置？
根据该位置所在螺旋矩阵中的圈数设为 q+1，需要分四种情况讨论
若在上边界上，则该数字在该位置所在圈的第 j-q 个位置
若在右边界上，则该数字在该位置所在圈的第 3*n-5*q-j-1 个位置
若在下边界上，则该数字在该位置所在圈的第 4*n-7*q-i-2 个位置
若在左边界上，则该数字在该位置所在圈的第 n-3*q+i-1 个位置
最后附上代码：
```
```cpp
#include<bits/stdc++.h>
using namespace std;

int main(){
	int n,i,j,k,x,ans;
	cin>>n>>i>>j;
	x=min(i-1,n-i);
	x=min(x,j-1);
	x=min(x,n-j);
	ans=4*n*x-4*x*x;
	if(i-x==1)ans+=j-x;
	else
	  if(i+x==n)ans+=3*n-5*x-1-j;
		else
	  	  if(j-x==1)ans+=4*n-7*x-2-i;
	  	    else  ans+=n-3*x+i-1;
	cout<<ans<<endl;
	return 0;
}
```
