
```cpp
#include<fstream>
using namespace std;
ifstream  in("luo.in");
ofstream  out("luo.out");
int main()
{
int n,x,y,t,x1,y1,k;
in>>n>>x>>y;
t=(n+1)/2;//一共有多少圈
x1=x;
y1=y;//保存x,y，当(x,y)比最大的圈还要大时，要还原到
//小圈的坐标，如n=5,t=3一共有3圈
//(2,3)所在的圈是：k=min(2,3)=2
//(4,5)所在的圈是：x=4>(t=3):x等价于:x=n+1-x=6-4=2
//y=5>(t=3):y等价于：y=n+1-y=6-5=1
//故 (4,5)->转换后(2,1):k=1在第一圈 
if(x>t) 
  x=n+1-x;
if(y>t)
  y=n+1-y;
/*判断x,y在那一圈上,对称线,第一圈(1,1),(1,2)..(1,4)..(2,4)(3,4)..(4,4)
..(4,1)..(3,1),(2,1)的特点是(x,y)横枞坐标中至少有一个(1或4),
```
第二圈(2,2),(2,3)..((3,3),(3,2)的特点是(x,y)横枞坐标中至少有一个(2或3)
且一定不含有4或1,[因为4或1在第一圈已经用完],4+1=5,3+2=5,和是定值n+1

较大数的坐标还原到第几圈如:让4还原到第1圈中, n+1-4=1 ;3还原在第二圈;


********

第i圈中不可能有横枞坐标比i小的数,

如第2圈不会少于1(4等价于1,所以也不可能有4)

,第3圈不会少于2(3等价2,所以也可能有3),

故k圈是(x,y)的最小值


\*/


```cpp
if(x>y)//k是x,y的最小值表示是第K圈 
  k=y;
else k=x;
t=1+n*n-(n-2*(k-1))*(n-2*(k-1));//第k圈的起始值; 
//(外面大的n*n-里面
//(n-2)*(n-2)行少了2个,列少了2个,是正方形)
//,k=1,k=2算一下即可 
//===外面的是1.2.3..12;故第2圈的起始值13
if ((x1==y1)&& (x1==k)) //在对角线上的起始位置上 
out<<t<<endl;
/*把一个矩形分成: 对角线,上三角(y>x),下三角(x<y)
```
从而判断他在这三个区域
那一个部分(对角线,上三角,下三角)

第一种情况.在对角线上x==y坐标相等,

x1=k表示在(左上角,[1,1],[2,2]) 

对角线,就等于起始值t\*/



if ((x1==y1)&&(x1==n+1-k) &&(x1!=k) )//在圈的右下角 

  out<<(t+n+1-k-k+n+1-k-k);

 /\*第二种情况.在对角线上x==y坐标相等,x1=k表示

在(右上角)对角线[4,4] [3,3],就等于起始值t,

 x1<>k防止n+1-k=k ,从而输出2次,出错.如:(n=5,x=3

 ,y=3),k=3第三圈，t=25,故输出２次,

t+n+1-k-k+n+1-k-k是：t是开头的数

值，
第k圈的起始坐标：(k,k)，右下角(n+1-k,n+1-k)，

故行移动的次数是行坐标之差，列移动是列坐标

之差．而移动一次对应的数值正好加１

如第1圈:(1,1)--(4,4)：数从1.2.3...7，移动６次；行差是4-1+4-1;

值５－－(2,4)，是(2-1,4-1)＝移动4次

\*/

  
```cpp
if (x1<y1)
out<<(t+x1+y1-k-k);//在上三角，
//起始值t，(x1,y1)-起始点坐标(k,k)行移动的次数x1-k.
if (x1>y1)
out<<(t+n+1-2*k+n+1-2*k+n+1-k-x1+n+1-k-y1);
//在下三角；先把(k,k)起始点移动
```
/\*右下角（n+1-k,n+1-k）的拐点，此时满足
上面的次数是(行差+列差)；

第二步**再从拐点(n+1-k,n+1-k)移动到(x,y)

也是行差＋列差（但不能直接合并）

如：(4,3)应该从起始(1,1)移动(4,4)：移动次数为：6次；

再从(4,4)移动(4,3)移动1次，总的是6+1=７；不能合并如果合并是：(4,3)-(1,1)=3+2移动5次而

正确结果是7次  \*/

  
  
}
