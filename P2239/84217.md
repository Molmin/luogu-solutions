**图片尺寸过大>_<为获取最佳阅读效果，欢迎访问：**[Actinoi's blog:NOIP2014 普及组](https://www.actinoi.com/2019/08/19/noip2014%20普及组/)


很明显，这个提示一个找规律的题呗！

我们可以将大矩阵分成一层一层的小矩阵：

![6_6矩阵.png](https://i.loli.net/2019/08/19/718Q3yr6sjVPgYo.png)

然后，我们先研究如何在一个小矩阵里面找到一个坐标：

![小矩阵.png](https://i.loli.net/2019/08/19/NvDEmKg29MOVyfS.png)

假设我们知道这个小矩阵左上角的数字是多少，如果我们要找在这个小矩阵寻找一个数字，应该怎样找呢？

1. 当 $i\ =\ 1$ 时，也就是在第 $1$ 行寻找一个数字。我们直接返回左上角的数字 $+\ j$ 就可以。
2. 当 $i\ =\ n$ 时，也就是在第 $n$ 行寻找一个数字。这个小矩阵的大小 $n$ 是 $4$ ，因此，我们先将 $(n\ -\ 1)\ ×\ 3$ 得到左下角的坐标，然后再 $-\ j\ +\ 2$ 得到我们要找的坐标，最后，将这个坐标 $+$ 左上角的数字就是我们要找的数字了！
3. 当 $j\ =\ 1$ 时，也就是在第 $1$ 列寻找一个数字。同情况 $2$ 一样，我们先将将 $(n\ -\ 1)\ ×\ 4$ 得到左上角正下方数字 $32$ 的坐标，然后再 $-\ i\ +\ 2$ 得到我们要找的坐标，最后，将这个坐标 $+$ 左上角的数字就是我们要找的数字了！
4. 当 $j\ =\ n$ 时，也就是在第 $n$ 列寻找一个数字。我们直接返回左上角的数字 $+\ n\ +\ i\ -\ 1$ 就可以。



​​​​​&emsp;然后，我们可以通过递归来得到小矩阵。并且在递归过程中，我们可以不断将当前 $(n\ -\ 1)\ ×\ 4$ 得到当前矩阵左上角的数字。最后输出答案就好辣！

```cpp
#include <iostream>
using namespace std;
int find(int n, int i, int j) {
    if (i == 1)
        return j;
    if (i == n)
        return (n - 1) * 3 - j + 2;
    if (j == 1)
        return (n - 1) * 4 - i + 2;
    if (j == n)
        return n + i - 1;
    return find(n - 2, i - 1, j - 1) + (n - 1) * 4;
}
int main() {
    int n, i, j;
    cin >> n >> i >> j;
    cout << find(n, i ,j) << endl;
    return 0;
}

```