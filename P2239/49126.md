#####   前提 :
我们把矩阵的一圈当作一层，从最外圈开始数,把所求的值分成两部分算,一部分是之前满层的值,一部分是所求点在当前层的位置,两者相加即可.
##### 算层数：
简单观察下我们就能发现
i，j在矩阵的第几层就是i，j，n+1-i，n+1-j中最小的那一值
##### 算所求层的起点：
第K层的起点是上一层的起点加上上一圈边长减1的4倍；
- **F(K)=F(K-1)+4*(N-1-2*(K-1))**
- **F(1)=1;**

推导可得通项式**F(K)=1+4(K-1)(N-K+1)**

##### 算(i,j)离(k,k)的距离：
###### 如果所求i,j在矩阵上半的三角
	直接加i-k+j-k即可;
###### 在下半个三角的时候
	我们可以把k的对角点当新的起点,也就是算（i，j）到(k+(n-1-2*(k-1)),k+(n-1-2*(k-1)))的距离
    
```cpp
#include <bits/stdc++.h>
using namespace std;
int main()
{
	int n,i,j,srt;
	cin>>n>>i>>j;
	int cen=min(min(min(i,j),(n-i+1)),(n-j+1));//算第几层
	srt=4*(cen-1)*(n-cen+1)+1;//第cen层的起点
	if(i==n-cen+1||j==cen)//如果在下半部分
		srt+=2*(n-1-2*(cen-1)),cen+=(n-1-2*(cen-1));
	cout<<srt+abs(i-cen)+abs(j-cen);
	return 0;
}
```