## 题目分析

![](https://i.loli.net/2018/10/12/5bc037fd43168.png)

如下表所示，$4*4$螺旋矩阵的填充方式是这样的：

数值&得到方式

$1$ 起点

$2$ 向右

$3$ 向右

$4$ 向右（到达外圈矩阵列数尽头，行数为$1$，开始转向下填充）

$5$ 向下

$6$ 向下

$7$ 向下（到达外圈矩阵列数尽头和行数尽头，开始转向左填充）

$8$ 向左

$9$ 向左

$10$ 向左（列数为1、到达外圈行数尽头，开始转向上填充）

$11$ 向上

$12$ 向上（进入下一圈的起点（第一个数），以此类推）

这是图：

![](https://i.loli.net/2018/10/12/5bc0662d9e124.png)

（以下以数对$(x,y)$表示第$x$行第$y$列）可见，螺旋矩阵是从点$(1,1)$开始，初始值是$1$，逐圈递进，以顺时针方向填数，每一次填的数是前一次填的数$+1$。现在，题目让我们求矩阵中$(i,j)$的值。

## 算法

枚举$or$递归（找规律）

## 算法解析

（找规律有人写过了，现在我说枚举）

首先，直接暴力枚举是会超时$TLE$的,因为算出所有 $(x,y)$ 的值的话时间复杂度是 $O(n^{2})$ ，所以程序时间最坏情况是 $O(9 \times 10^{8})$ ，明显超时。于是我们要优化。

如何优化呢？仔细观察，可以发现进入每个圈的第一个数字是可以直接算出来的，$1,13$之间相隔$12$，也就是第一圈的数的个数 $+12$ 。$12$  即第一圈的数的个数，也就是说，从第 $i$ 圈进入第 $i+1$ 圈的起点（起点的 $x=y$ ），是第 $i$ 圈的起点的数加上第 $i$ 圈的数的个数，凭这个可以去找答案在第几圈再模拟填数，免去了之前一圈一圈填数的时间。

知道了优化思想，我们要知道怎么算每圈数的个数。这要用上数形结合的方法了。以样例为例，构造一个 $4 \times 4$ 的螺旋矩阵（如图）：

![](https://i.loli.net/2018/10/12/5bc037fd43168.png)

- 第一圈的左上角坐标为 $(1,1)$ ，右下角坐标为 $(4,4)$ 
- 第二圈的左上角坐标为 $(2,2)$ ，右下角坐标为 $(3,3)$ 

**推出以下公式：**

（第 $i$ 圈左上角坐标为 $(x_{1},y_{1})$ （就是 $(i,i)$ ），第 $i$ 圈右下角坐标为 $(x_{2},y_{2})$ 就是 $(n-i+1,n-i+1)$）
1. 第 $i+1$ 圈的左上角坐标和右下角坐标分别是 $(x_{1}+1,y_{1}+1)$ 和 $(x_{2}-1,y_{2}-1)$ 。
2. 将第 $i$ 圈包含其以内的圈看做一个正方形，边长是它的 （ 右下角坐标 $-$ 左上角坐标 $+1$ ） ，第 $i+1$ 圈包含其以内的圈也看做一个正方形，边长是它的 （ 右下角坐标 $-$ 左上角坐标 $+1$ ） ，那么第 $i$ 圈就是一个环，之后用求正方形的环的面积的方法：**第 $i$ 圈包含其以内的圈组成的正方形面积 $-$ 第 $i+1$ 圈包含其以内的圈组成的正方形面积**。

**综上可得：**

- 第 $i$ 圈数的个数 $=(x_{2}-x_{1}+1)^{2}-((x_{2}-1)-(x_{1}+1)+1)^{2}$ （注意，这是个正方形）

我为了方便起见，在程序中变成第 $i$ 圈推第 $i-1$ 圈

- 注：当 $n$ 为偶数时，矩阵有 $n/2$ 圈；当 $n$ 为奇数时，矩阵有 $n/2+1$ 圈

## 程序：
```cpp
#include <iostream>
#include <fstream>
#include <algorithm>
#include <cstdio>
#include <string>
#include <cstring>
#include <cmath>
using namespace std;
inline int read()
{
    int s=0,w=1;
    char a=getchar();
    while(a<'0'||a>'9')
    {
        if(a=='-')w=-1;
        a=getchar();
    }
    while(a>='0'&&a<='9') s=s*10+a-'0',a=getchar();
    return s*w;
}//快读，你可以理解为cin
inline void write(int k)
{
    if(k<0) putchar('-'),k=-k;
    if(k>9) write(k/10);
    putchar(k%10+'0');
    return;
}//快写，你可以理解为cout
int main()
{
    int n,x,y,sum=1,q=-1;//n,x,y的意思跟题目一样。sum表示该圈起点的数（初始为1），q记录圈数
    n=read();
    x=read();
    y=read();
    for(int i=2,j=2,ii=n-1,jj=n-1,k=1;i<=n/2+n%2;i++,j++,ii--,jj--,k++)//i,j,ii,jj分别表示该圈的左上角坐标和右下角坐标，k表示上一个圈是第几圈（所以我是从第2圈开始枚举的）
    {
        if(x<i||x>ii||y<j||y>jj)
        {
            q=k;
            break;
        }//若询问的坐标不在该圈内就在上一圈第k圈
        sum+=((ii+1)-(i-1)+1)*((jj+1)-(j-1)+1)-(ii-i+1)*(jj-j+1);//如果在该圈以内，就要加上上圈的数的个数，为该圈起点值（因为有可能询问坐标就在这圈）
    }
    if(q==-1) q=n/2+n%2;//如果q并没有变过，说明它在最后一圈
    if(x==q&&y==q)
    {
        write(sum);
        return 0;
    }如果询问坐标恰好在起点，那么直接输出
    int i=q,j=q+1;//i,j是当前点的坐标
    while(i!=q||j!=q)//模拟算出第q圈的每个点的值（回到起点就停止，答案在起点的值已经特判过了）
    {
        sum++;//这个点的值
        if(x==i&&y==j)
        {
            write(sum);
            return 0;
        }//如果该处是询问坐标，输出
        if(j+1<=n-q+1&&i==q)
        {
            j++;
        }//未到达该圈列数最右，行数最上，向左填数
        else if(i+1<=n-q+1&&j==n-q+1)
        {
            i++;
        }//到达该圈列数最右，未到达该圈行数最下，向下填数
        else if(j-1>=q&&i==n-q+1)
        {
            j--;
        }//到达该圈列数最右，到达该圈行数最下，向左填数，填到列数最左
        else if(i-1>=q&&j==q)
        {
            i--;
        }//到达该圈列数最左，到达该圈行数最下，向上填数，填回起点
    }//详情见路径分析过程
    return 0;
}
```