考虑到数字总是从外围一圈圈地向目的地前进，而每一圈刚好是一个正方形，
我们可以先计算外围各圈正方形的周长之和，再让贪吃蛇从目的地所在圈的左上
角出发，计算其从出发地到目的地的长度就可以了。

例如：n=4, (2,2)在第 2 圈，(3,1)在第 1 圈。
 	  
          n=6，(4,5)在第 2 圈
    
圈数 q=min(x, y, n-x+1, n-y+1 )

圈数 q 求出后，前 q 圈的数字总和很容易求出来。

对于任何一个方阵：
	 
           第 1 圈有 4n-4 个数;
	       第 2 圈有 4(n-2)-4 个数；
	       第 3 圈有 4(n-4)-4 个数；
 	       ……
	       第 q 圈有 4(n-q(n-1))-4 个数
           
	       前 1 圈有 4n-4 个数;
	       前 2 圈有 4n-4 + 4(n-2)-4 = 2(4n-2*4)个数；
 	       前 3 圈有 4(n-4)-4 + 2(4n-8) = 3(4n-3*4)个数；
		 ……
	       前 q 圈有 q(4n-4q)个数；
解决了某个位置在螺旋矩阵上的圈数之后
目标位置(i,j)到底在当前这一圈的第几个位置？

如目标数 26 所在的位置(4,5)，在第 2 圈的什么位置？

根据该位置所在螺旋矩阵中的圈数设为 q+1，需要分四种情况讨论

若在上边界上，则该数字在该位置所在圈的第 j-q 个位置

若在右边界上，则该数字在该位置所在圈的第 3*n-5*q-j-1 个位置


若在下边界上，则该数字在该位置所在圈的第 4*n-7*q-i-2 个位置

若在左边界上，则该数字在该位置所在圈的第 n-3*q+i-1 个位置

上代码：
```
#include <bits/stdc++.h>
using namespace std;
int n,i,j,q,ans;
int main(){
	cin>>n>>i>>j;
	q=min(i-1,n-i);
	q=min(q,j-1);
	q=min(q,n-j);//先算圈数
	ans+=q*(4*n-4*q);//再算之前有几个圈数
        //分四种情况讨论
	if(i-q==1)ans+=j-q;//若在上边界上
	else if(i+q==n)ans+=3*n-5*q-1-j;//若在右边界上
	else if(j-q==1)ans+=4*n-7*q-2-i;//若在下边界上
	else  ans+=n-3*q+i-1;//若在左边界上
	cout<<ans;
	return 0;
}
```
