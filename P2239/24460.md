发现自己的思路没有跟人雷同赶紧来这儿水一发（划掉）

这题一看到差点想用30000\*30000的数组但是一看会爆掉，那还是算了（滑稽）

所以肯定是手动模拟啦（笑）

咳咳好了回归正题（严肃）：

首先，再一次又一次的举例中，我们能发现，假定每一次操作都是走直线（方向不同），

那么我们可以找到规律，即每次走直线会经过的格子数（把矩阵想成一个二维数组，每一个空间代表一个小格子）应该是：

n,n-1,n-1,n-2,n-2,……2,2,1,1然后结束；然后方向上的规律是右，下，左，上，那么对于四个方向，我们可以用变量d来表示，

然后记录每次移动完成后的起始点坐标。

然后我们还能发现，要么i会与当前行相同，要么j会与当前列相同，然后就可以求出解了。

（说实话我这种写法应该很好理解了）

最后，附上蒟蒻代码（滑稽）

```cpp
cpp
#include<iostream>
#include<cmath>
using namespace std;
int n,i,j,ans;
int dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};//方向数组
int main()
{
    cin>>n>>i>>j;
    if(i==1)//一开始的n个数肯定都在第一行，所以当i=1时直接输出j即可
    {
        cout<<j;
        return 0;
    }
    int head=n-1,x1=1,y1=n,x2,y2,d=1,v=n;//x1，y1用来表示起点坐标，x2，y2表示终点，v表示每次移动完后末尾那个点的数字的值。
    while(head>=1)//每次循环移动操作两次
    {
        x2=x1+dx[d]*head;
        y2=y1+dy[d]*head;
        v+=head;
        if(i==x1&&i==x2)//i在该行时
        {
            ans=v-abs(y2-j);//一定要用绝对值！！我在这里被坑了好久qwq
            cout<<ans;
            return 0;
        }
        if(j==y1&&j==y2)//j在该列时
        {
            ans=v-abs(x2-i);
            cout<<ans;
            return 0;
        }
        d=(d+1)%4;//调整方向，下同。
        x1=x2;//更新起点。
        y1=y2;
        x2=x1+dx[d]*head;
        y2=y1+dy[d]*head;
        v+=head;
        if(i==x1&&i==x2)
        {
            ans=v-abs(y2-j);
            cout<<ans;
            return 0;
        }
        if(j==y1&&j==y2)
        {
            ans=v-abs(x2-i);
            cout<<ans;
            return 0;
        }
        d=(d+1)%4;
        x1=x2;
        y1=y2;
        head--;//head功能见上述规律
    }
}
```