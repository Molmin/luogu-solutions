# 数据点:
对于 50%的数据，1 ≤ n ≤ 100;

对于 100%的数据，1 ≤ n ≤ 30,000，1 ≤ i ≤ n，1 ≤ j ≤ n

本题首先让我们想到传统的模拟，从[1,1]开始往数组中填充数字，但对于[30000,30000]的数组，直接爆零。对于读入的n, x, y，先判断(x,y)在第几圈，再模拟圈内的数字。

如：n=4, (2,2)在第2圈，(3,1)在第1圈。
n=6，(4,5)在第2圈

![](https://i.loli.net/2018/11/07/5be2f0569157e.png)

![](https://i.loli.net/2018/11/07/5be2f08ae3a76.png)

# 圈数q=min(x, y, n-x+1, n-y+1 )
即目标位置到四个边界距离的最小值.圈数q求出后，前q圈的数字总和很容易求出来。

对于任何一个方阵：

第1圈有4n-4个数;

第2圈有4(n-2)-4个数；

第3圈有4(n-4)-4个数；

……

第q圈有4(n-q(n-1))-4个数

目标位置(i,j)到底在当前这一圈的第几个位置？

如目标数26所在的位置(4,5)，在第2圈的什么位置?

分两种情况：

1）目标数(i,j)在上行或右行；i+j-2q+1
       
2）目标数(i,j)在下行或左行；
      
      距离第一个数的距离i+j-2q+1
      
# 上代码:
```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
    ios::sync_with_stdio(false);//优化,使cin与scanf相差无几
    long long n,i,j,mi,ans=0;
    cin>>n>>i>>j;
    mi=min(i,min(j,min(n-i+1,n-j+1)));
    if(i<=j)ans=mi*(4*(n-1)-4*mi)+10*mi-4*n-3+i+j;
    else ans=mi*(4*n-4*mi)+2*mi+1-i-j;//模拟过程
    cout<<ans;//输出ans
    return 0;
}
```
谢谢观赏,好评一个！