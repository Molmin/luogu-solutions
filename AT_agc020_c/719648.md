题目链接：[AGC020C] Median Sum。

题目大意
给定一个长度为 $n$ 的整数序列 $a_{1..n}$，求所有非空子序列和的中位数。

思路分析

这道题目的难点在于求出所有的非空子序列和。对于一个长度为 $n$ 的序列，它的非空子序列和就有 $2^n - 1$ 个，这个数量级是 $O(2^n)$ 的，因此暴力枚举所有非空子序列肯定是不行的。我们可以考虑一下怎么求出所有的非空子序列和。我们可以用动态规划的思想，设 $f(i, j)$ 表示以 $a_i$ 结尾、长度为 $j$ 的子序列的和，也就是说 $f(i, j)$ 与 $f(i-1, j-1)$ 和 $a_i$ 有关系，状态转移方程为：
$$
f(i, j) = \max(f(i-1, j-1) + a_i, f(i-1, j))
$$
这样我们就能够 $O(n^2)$ 地求出一个序列的所有非空子序列和。但是，这个时
间复杂度仍然过高，我们需要优化。根据题目的性质，我们可以知道中位数一定是所有非空子序列和的中位数，而不
是所有子序列和的中位数。因为所有子序列和的数量是 $O(2^{n+1})$ 的，而所
有非空子序列和的数量是 $O(2^n)$ 的，因此我们只需要考虑所有非空子序列和
即可。我们可以将所有非空子序列和从小到大排序，然后取出排序后的数组的中位数即可。这个排序的时间复杂度是 $O(2^n \log(2^n))$，可以通过此题。最后，还有一个需要注意的点：由于题目中的下标是从 1 开始的，所以在代码中我们需要将数组下标减去 1。


下面的代码中，$f(i,j)$ 表示以 $a_i$ 结尾的长度为 $j$ 的子序列的和

参考代码

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 2005;
int n, a[N];
long long f[N][N], s[N * N];
int main() {
    cin >> n;
    for (int i = 1; i <= n; i++) {
        cin >> a[i];
    }
    for (int i = 1; i <= n; i++) {
        f[i][1] = a[i];
        for (int j = 2; j <= i; j++) {
            f[i][j] = max(f[i - 1][j - 1] + a[i], f[i - 1][j]);
        }
    }
    int cnt = 0;
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= i; j++) {
            s[++cnt] = f[i][j];
        }
    }
    sort(s + 1, s + cnt + 1);
    cout << s[(cnt + 1) / 2] << endl;
    return 0;
}
```