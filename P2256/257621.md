[题目传送门](https://www.luogu.com.cn/problem/P2256)

[并查集模板传送门](https://www.luogu.com.cn/problem/P3367)

**这道题的第一眼就是：字符串+板子并查集！！！**

遵循政治老师的教导，本题解将从是什么，为什么，怎么做三个方面来为大家阐述并查集的相关知识以及本题做法。

**好了，闲话不多说，不会这道题的童鞋们跟我来！**



------------


### STEP 1 什么是并查集
```
并查集，是用来求两者是否同属一个单位的一种思路。
仅由一个内容仅仅两行左右的函数以及一个数组就可以实现。
优点：方便快捷，使用有效。
缺点：emmm……没有什么大的缺点，非要有的话可能就是时间复杂度有些高，
     但是这个是可以通过一个小优化解决哒！
```


------------
### STEP 2 为什么要用并查集
并查集是用来判断两者是否为一个单位的方法。

如果同属于一个单位的人为一个战队，那么通过标记和函数查找，我们可以清楚地知道这一个战队的队长是谁，并且以这个队长为这个战队的标志，以后战队的每一个人与其他人碰面，只要标志不同，那就把另一个拉近自己的战队。在访问的时候，只要两个人的标志不同，就是不在一个战队，否则他们就是一个战队的好哥们啦。


------------
### STEP 3 并查集怎么做

#### 1.并查集标准判断标志是否相同函数
```
//只是个例子
int f[100];//定义一个数组，当然这个数组初始化的时候每个人的队长都是他自己
int find(int x){
	if (f[x]==x) return x;//如果队长是他自己，那么他就是队长
	return find(x); //否则一直搜，直到搜到队长为止
}
```
但是，你会发现，如果每一次碰到一个人就一直搜队长，是不是太慢了，于是我们可以优化一下，只要沿路碰到的全将他的队长设为最高队长。
```
//依然是个例子
int f[100];
int find(int x){
	if (f[x]==x) return f[x];
	return f[x]=find(f[x]);//沿路的都顺便将他标记
}
```
#### 2.针对这道题的转化函数
怎么在不用map的情况下定位跟踪到某一个名字的位置呢？这时候就需要新建一个函数来定位。
```
string mz[100];//大小随便开的，用来直接储存输入的名字
int fname(string name){//输入一个字符串也就是名字
	for (int i=1;i<=n;i++){
		if (name==mz[i]) return i;//不断搜索，返回他的位置
	}
}
```


------------

### STEP 4 总AC代码带注释
```
#include<bits/stdc++.h>
using namespace std;
int n,m,k;//储存的相应东西如题所示
string f[20001],mz[20001];//分别储存每个人的队长标志以及序号对应的人名
int fname(string name){//转换函数
	for (int i=1;i<=n;i++){
		if (name==mz[i]) return i;
	}
}
string find(string name){//并查集函数
	if (f[fname(name)]==name) return name;
	return f[fname(name)]=find(f[fname(name)]);//将名字转换成数字储存
} 
int main(){
    scanf("%d %d",&n,&m);
    for (int i=1;i<=n;i++){
    	cin>>f[i];
    	mz[i]=f[i];
	} //正常输入
	for (int i=1;i<=m;i++){
		string a,b;
		cin>>a>>b;
		f[fname(find(a))]=find(b);//并查集找队长操作
	}
	scanf("%d",&k);
	for (int i=1;i<=k;i++){
		string a,b;
		cin>>a>>b;
		if (find(a)==find(b)) printf("Yes.\n");
		else printf("No.\n");//寻找队长是否相同并输出
	}
    return 0;//好习惯要养成哦！
}
```

------------

### STEP 5 完结撒花
终于完美的结束了！还不懂的童鞋们可以在评论区留言，我会第一时间回复哒！如果没有问题了，就点个赞记录留念一下你的成长吧！
