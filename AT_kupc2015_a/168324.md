题目大意就是求出一个字符串中tokyo和kyoto的个数。

看起来题目非常的简单，直接枚举就好了

但是还是有需要注意的地方：单纯的直接枚举的话可能会有**重复**的字符串计入到了答案里面。

这时候我们就要采取一些技巧。

思路：

枚举每个字符，将它及其后面的4个字符拿来一起判断
（因为tokyo和kyoto长度都是5），判断可以用两个bool型的变量来实现

如果有符合题意的，累加答案并且让指针向后移5位，这样能去掉重复的部分

枚举时还有几个小优化：

1.当剩下还没有枚举的字符串长度小于5时，可以直接结束 ，因为后面不可能再有符合题意的字符串


2.判断一个长度为5的子串是否符合题意时，若有一个字符不匹配就打上标记，如果tokyo和kyoto都有了标记，直接退出判断

代码有解释：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
string s;//表示输入的字符串 
char s1[10]={'t','o','k','y','o'},s2[10]={'k','y','o','t','o'};//预处理出符合要求的两种字符串 
bool c1,c2;//c1表示有无第一种字符串，c2表示有无第二种 
int ans=0,k;//k是s1和s2的指针 
int main()
{
	cin>>n;
	while(n--)
	{
		cin>>s;
		ans=0;//记着清零答案 
		for(int i=0;i<s.length();i++)//枚举字符串的每一位字符 
		{
			if(i>s.length()-5)break;//如果剩下的字符串长度小于五,直接结束 
			c1=0,c2=0;k=0;//清零 标记和指针 
			for(int j=i;j<i+5;j++)
			{
				if(s[j]!=s1[k])c1=1;
				if(s[j]!=s2[k])c2=1;
				if(c1&&c2)break;//如果两种字符串都不符合直接退出枚举 
				k++;//改变指针 
			}
			if(!c1)//如果符合s1 
			{
				ans++;//答案加一 
				i+=4;//i指针直接加4,防止重复累加 
			}
			else if(!c2)//如果符合s2 
			{
				ans++;//同上 
				i+=4;
			}
		}
		cout<<ans<<'\n';//输出 
	}
	return 0;
}
```

