这道题刚开始看的时候找不到下手去做的地方

其实这种最优方案的问题无非就是三种做法

要么暴力dfs
要么找性质贪心
要么就是dp

dfs暴力肯定不行，贪心可以吗？在找了很久性质后我没有发现什么有用的性质

那就只能dp了，考虑如何去表示一个状态使得这个状态下的答案之和这个状态有关，这实际上是大部分动态规划算法最基本也是最核心的部分

很容易就会想到一个状态，记录下每个位置的人有没有出去

很遗憾这样去做的话不同的状态有2^n，是我们不能承受的，那有没有什么办法可以压缩这个状态呢？观察到每个人是否出队是和他所在的队伍最终被我们摆放的位置有关，然后我们就很轻松的把每个人的状态压缩到了每个队伍最终的位置上

继续观察，对于最终两个相邻的队伍来说，那么他们的相对位置关系谁在前谁在后对之后的状态都是没有影响的，毕竟之后的队伍只能接在他们后面或者前面，这样就把两个相邻的队伍对之后状态的影响压缩到了一个队伍中

那能不能把所有已经拍好的队伍压缩到一起呢？答案是可以的，只要让他们都相邻就可以了，怎么让他们都相邻呢？把他们全部放到最前面就行了，这样一来一个状态对之后状态的影响就只有和哪些队伍已经排好了有关

记录二进制状态f【i】，i从后向前数第j位的01字符表示第j个队伍有没有排号（这里的排号指的是这个队伍所有人都在一起且所有排号的队伍都在最前面）状态下最少的出队人数

我们就可以很轻松的从一个状态的答案推出最其他状态的答案，从而推出把所有队伍的人都整合在一起并放到前n个位置的最少出对人数

对于一个状态i，枚举没有拍好的队伍j，将j接在所有排号的队伍后面，设为位置l-r，需要出队的就是所有在原序列中不在这个区间且属于j队伍的人

维护前缀和统计一下就好

```
//代码借鉴了其他题解
#include<iostream>
#include<cstdio>
#include<cmath>
#include<cstring>
#include<algorithm>
using namespace std;
int f[(1<<20)+100],n,m,sum[100100][25];
int main()
{
	std::ios::sync_with_stdio(false);
	cin>>n>>m;
	for(int i=1;i<=n;i++)
	{	int x;
		cin>>x;
		for(int j=1;j<=m;j++)
			sum[i][j]=sum[i-1][j];
		sum[i][x]++;
	}
	int end=(1<<m)-1;
	f[0]=0;
	for(int i=1;i<=end;i++)
		f[i]=1000000000;
	for(int i=0;i<=end;i++)
	{	int finish=0;
		for(int j=0;j<m;j++)
			if((i>>j)&1)
				finish+=sum[n][j+1];
		for(int j=0;j<m;j++)
		{	if((i>>j)&1)
				continue;
			int l=finish,r=l+sum[n][j+1];
			f[i|(1<<j)]=min(f[i|(1<<j)],f[i]+r-l-(sum[r][j+1]-sum[l][j+1]));
		}
	}
	cout<<f[end]<<endl;
	return 0;
}
```
