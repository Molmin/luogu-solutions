对于n<=6: 
可以暴力枚举判断分组情况，
时间复杂度O(n^n),期望得分20pts；

对于另外40%满足Ai两两不同的测试点，
排序后直接按照条件贪心选择直到无法选择即可，
时间复杂度O(nlogn),暴力实现是O(n^2)，
期望得分50pts，
结合n<=6的暴力分可以获得70pts.

满分算法：
考虑贪心，将所有人的实力值放进一个桶里，
每次考虑将剩下的人中实力值最小的那个人所在的组提取出来，
假设这个人的实力值是p，把这个人放入当前组，
按照p+1,p+2，p+3.....依次遍历实力值，
假设当前遍历到的实力值是x，
当剩余的实力值为x的人数小于实力值为x-1的人数，则让这一组最大元素为x-1，停止这一轮操作；
否则，每次将当前实力值的人取一个出来放进当前组，
这样不断取出元素直到所有元素都被分组，此时人数最少的组就是最优解.
做法正确性证明：
剩余的实力值为x的人数小于实力值为x-1的人数，
等价于一定有一个组中实力值最大的人的实力值为x-1，也就是以x-1结尾；
否则剩余的实力值为x的人数一定大于等于实力值为x-1的人数；
然后每次取出来的新的小组的最小值单调不下降，组的大小为|Max-Min+1|,
于是显然贪心地让当前组在x-1位置结尾是最优的.

对于|Ai|<=10^9无法直接存到一个桶里的情况，
将实力值排序后离散化，对于不连续的实力值中间加上一个空点，
可以发现这样对答案不会产生影响，这样值域就被压缩到了O(n)的范围，
时间复杂度O(nlogn),空间复杂度O(n),期望得分100pts.


同时这题还有一种时空复杂度与上一个算法相当的另一种贪心算法，
思维难度相对小但是用到了STL里的priority_queue和map.
从小到大加入每一个元素，
每次贪心地找到上一个元素是X-1的组并加入这个元素，
如果有多个，加入元素数量最小的那个组；
如果没有，则创建一个新组，组内元素只有X.
具体实现，可以用map套priority_queue实现，
map维护的组内的上一个元素，pq维护的是满足条件的所有组的大小.
离散化后开O(n)个priority_queue也是可行做法.

然后附上原题地址：https://www.hackerrank.com/challenges/team-formation/problem