刚学KMP，理解之后感觉对整个人都 **升华** 了。


------------

首先看字符串是整周期的例子，例如一个字符串$ababababab$，$ab$就是一个周期，最长公共前后缀如图所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/cknym26m.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

对于答案$N-next[N]$可以这样理解：从字符串的某一处开始到串末，和串首到某一处是完全相等的，其中最长的就是最长公共前后缀（若有不适稍微坚持一下）。

具体到那个例子就是1~8和3~10完全相等。

**头脑风暴：  
第一个周期和第二个周期完全相等（1~2和3~4），  
第二个周期又和第三个周期完全相等（3~4和5~6）。  
......  
既然相等当然就可以匹配了  
也就是最长公共前后缀就是第1个周期开始到第2个周期   
然后是第2个周期到第3个周期  
......**

因为不可能第一个周期自己和自己匹配，就算一个周期中间有公共前后缀（例如abacaabaca，周期为abaca），也不可能后面完全匹配（例子中的第6个字符和第2个字符失配了）。

就算真的有，那么就表明有更短的周期（KMP会自己克服的）

**那么最长公共前后缀就是第 $1.2.3.4$ 个周期和第 $2.3.4.5$ 个周期,也就是前缀不包含最后一个周期，后缀不包含第一个周期。**

**那么就很好理解了：字符串的长度减去这个周期的长度就是一个周期的长度（相当于第一个周期），便有了$N-next[N]$这个公式。**

具体到那个例子就是1~2（或者9~10）是一个完整的周期。

（你成功一半了加油！ヾ(◍°∇°◍)ﾉﾞ）

------------

万一不是整周期呢？答案依然是成立的。

例如这个字符串cabcabca（周期可以看做abc），如图所示：
![](https://cdn.luogu.com.cn/upload/image_hosting/v1y85ooc.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

从字符串的某一处开始到串末，和串首到某一处是完全相等的，其中最长的就是最长公共前后缀。我们首先将第一个c看做第0个周期的最后一个字符。

**头脑风暴二号：  
第0个周期的最后一个字符c和第1个周期的最后一个字符c相等，  
第一个周期和第二个周期相等，  
第二个周期的前两个字符和第三个周期的前两个字符相等。**

既然相等，那么我们又可以进行匹配了......


（是不是有点感觉）

**这里的最长公共前后缀就是：  
第0个周期的最后一个字符c、第一个周期以及第二个周期的前两个字符  
和第一个周期的第最后一个字符c、第二个周期以及第三个周期的前两个字符**

和前面说的一样，最长公共前后缀的不可能在一个周期里面自己匹配，否则就有更短的周期。

于是KMP算法就会从（第0个周期的最后）一个字符c和第一个周期的最后一个字符c开始匹配，正好就会空出一个完整的周期cab，仅仅是顺序不同。

（KMP算法如此强大，如果还不理解可以再多想想）


------------

代码贴不贴都无所谓了
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
int size1,nex[1000001],j;
char s1[1000001];
int main()
{
  
	cin>>size1;
	cin>>s1+1;
	j=0;
	for(int i=1;i<=size1;i++)
	{
		if(s1[j+1]!=s1[i+1]&&j>0)j=nex[j];
		if(s1[i+1]==s1[j+1])
		nex[i+1]=++j;
	}
	cout<<size1-nex[size1]<<endl;
}
```


------------
做完这道题别慌着走，这里还有几道题供您使用

**[UVA10298](https://www.luogu.com.cn/problem/UVA10298)**

**[P2445](https://www.luogu.com.cn/problem/P2445)**