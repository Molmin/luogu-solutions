其实这题不难，~~像我这种蒟蒻都会~~,主要是理解题意。

**大致题意**：题目给出一个由“ # ”和“ . ”组成的矩阵，让你给出两个大小相同且“ # ”是相连的矩阵，且这两个矩阵的“ * ”重叠部分刚好是给出的这个矩阵。(答案不唯一，只要满足题目要求就行)~~（其实这题应该打个spj标签的）~~

**主要思路**：题目中给到："题目保证边界上不会被涂色"，即：边界中不会有“ * ”，那我们就可以以此来连接两个图中的“ # ”，你可以像这样先把外围搞定（上，下两侧的暂时不画，后面会提到）：
```
(以5*5为例)
①   ②
#....  ....#
#....  ....#
#....  ....#
#....  ....#
#....  ....#

```
然后在把内围用几根线线连起来，像这样：（~~叠词词，恶心心~~）
```
(你可以看成是左边奇数行，右边偶数行填满，但要注意最左边和最右边两列不能同时为“ * ”，不然就违背题目了)
①      ②
####.  ....#
#....  .####
####.  ....#
#....  .####
####.  ....#

```
然后在依据题目给的“ # ”的位置把两个矩阵相对应的位置换成“ # ”即可。
```
（样例1）
①      ②
####.  ....#
##.#.  .####
####.  ....#
##.#.  .####
####.  ....#
```
~~然后是最期待的代码环节~~

# CODE
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m;
char r[1001][1001],b[1001][1001];
char a;
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			cin>>a;
			r[i][j]=a;
			b[i][j]=a;
		}
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			if(i%2&&j!=m)r[i][j]='#';
			else if(j==1)r[i][j]='#';
		}
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			if(i%2==0&&j!=1)b[i][j]='#';
			else if(j==m)b[i][j]='#';
		}
	}
	putchar('\n');
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			cout<<r[i][j];
		}
		putchar('\n');
	}
	putchar('\n');
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			cout<<b[i][j];
		}
		putchar('\n');
	}
	return 0;
}
```

就这样，拜拜(～￣▽￣)～