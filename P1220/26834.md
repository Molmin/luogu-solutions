我们假设 dpij0 为目前最优值是在 i 位置,dpij1 为目前最优值是在 j 位置

则 i 到 j 表示已经关掉的灯的区间，因为我们要求最小的损耗，所以必然是从当前区间走向区间两端

再利用前缀和来算从前一个位置走向当前位置所需要的时间，再乘上没关掉电灯的功率即可

```cpp
for(i = c to 1)for(j = i+1 to n)
dp[i][j][0]=min(dp[i][j][0],dp[i+1][j][0]+(a[i+1]-a[i])*(b[n]-(b[j]-b[i])));//分4情况，耗能计算，时间乘以功率 
            dp[i][j][0]=min(dp[i][j][0],dp[i+1][j][1]+(a[j]-a[i])*(b[n]-(b[j]-b[i])));
            dp[i][j][1]=min(dp[i][j][1],dp[i][j-1][1]+(a[j]-a[j-1])*(b[n]-(b[j-1]-b[i-1])));
            dp[i][j][1]=min(dp[i][j][1],dp[i][j-1][0]+(a[j]-a[i])*(b[n]-(b[j-1]-b[i-1])));
```
代码不给出了，可以看博客有详细解释
http://www.cnblogs.com/oi-forever/p/7344325.html
