## 翻译

Snuke 有无限个边长为 $1$ 的正方形和正三角形瓷砖。有多少种不同的方法可以用这些瓷砖组成一个边长为 $d$ 的正十二边形？请计算方案数并对 $998\ 244\ 353$ 取模。

具体地说：
* Snuke 可以使用任意数量的瓷砖。
* 方案中没有两块瓷砖是重叠的。
* 瓷砖所填充的区域必须是一个无孔的正十二边形。
* 如果我们可以将一种方案通过旋转和平移得到另一种方案，则这两个方案是相同的。

输入共一行，一个正整数 $d$，表示正十二边形的边长。

输出共一行，一个正整数，表示方案数对 $998\ 244\ 353$ 取模后的结果。

对于 $100\ \%$ 的数据，$1 \le d \le 10^{6}$。

## 思路

是一道思维好题。

尝试从外往内填充这个正十二边形。我们可以发现，正十二边形的顶角大小为 $150\degree$，正好是 $60\degree + 90\degree$，因此一个角就只能由一个正三角形和一个正方形填充，如下图。

![](https://cdn.luogu.com.cn/upload/image_hosting/4vxbi3ak.png)

这时，如果我们想要在正方形右侧填充正三角形，必定会留出一个 $30\degree$ 的缝隙，所以正方形右侧只能填充正方形。同样的，如果在正三角形左侧填充正方形，也会留出一个 $30\degree$ 的缝隙，所以正三角形左侧仍然是正三角形。

因为每个角都是由正三角形和正方形拼接而成，所以填充正三角形的边相邻的两边都是填充正方形的边，填充正方形的边相邻的两边都是填充正三角形的边。

这样，只要确定一个角，就能确定最外围一圈的填充方案。

考虑最外围一圈填充后，内部的图形要如何填充。

![](https://cdn.luogu.com.cn/upload/image_hosting/i9hmpsbw.png)

如上图所示，在内部的十二边形里，所有在外层填充了正三角形的边，长度都减短了 $1$，而填充了正方形的边长度不变。

此时同样考虑一个角，由正方形和正三角形填充，所以填充这个内部的十二边形外围一圈的方案也可以由一个角确定。

同样的，对于第二次填充后内部的图形，用正三角形填充的边边长长度仍然会减短 $1$，用正方形填充的边长长度仍然不变。

![](https://cdn.luogu.com.cn/upload/image_hosting/avmh2yg5.png)

哎呀！里面只剩下一个正六边形了怎么办！

这时候，还是考虑一个角。正六边形的一个角是 $120\degree$，想用正方形填充？那就必定会剩下一个 $30\degree$ 的角，所以这个正六边形就只能用正三角形填充，而且有且只有一种方案。（想一想，为什么？）

---

综上，我们可以把十二条边分为两组，$A = \left\{e_1, e_3, e_5, e_7, e_9, e_{11} \right\}$，$B = \left\{e_2, e_4, e_6, e_8, e_{10}, e_{12}\right\}$，其中 $e_i$ 表示逆时针方向第 $i$ 条边。

每填充一层，可以选择 $A$ 或者 $B$ 中所有边上填正三角形，其余边填正方形。或者说，可以选择 $A$ 或者 $B$ 中所有边长度减短 $1$，其他边不变，直到 $A$ 和 $B$ 中的边边长都为 $0$。

于是我们可以建立二维坐标系，$x$ 轴为 $A$ 中边的长度，$y$ 轴为 $B$ 中边的长度，把问题抽象为仅允许向左、向下走时从 $(d, d)$ 走到 $(0, 0)$ 的方案数。

（即将向左走视为 $A$ 中的边长度减 $1$，向下走视为 $B$ 中的边长度减 $1$，而走到边界时，就是上面提到的六边形的情况）

![](https://cdn.luogu.com.cn/upload/image_hosting/9mz4rz8y.png)

如上图，对应了 $d=10$ 的一种方案。

由于一共有 $2d$ 步，其中 $d$ 步是向左的，所以总方案数为 $C_{2d}^d$。

但是因为旋转相同的限制，所以 $A$ 和 $B$ 是可以互换的，也就是说，在二维坐标系里，关于 $y = x$ 对称的路线是等价的！

所以最后的答案是 $\dfrac{1}{2}C^{d}_{2d}$！

## 代码

```cpp
inline ll fstpow (ll a, ll b, ll p = mod)
{
	a %= p; ll Ans = 1;
	while (b)
	{
		if (b & 1) Ans = Ans * a % p;
		a = a * a % p, b >>= 1;
	}
	return Ans;
}
inline ll GetInv (ll x) { return fstpow (x, mod - 2); }
int main ()
{
	cin >> d, Fac = Ans = 1;
	For (i, 1, d) Fac = Fac * i % mod;
	Inv = GetInv (Fac), Fac = 1;
	For (i, d + 1, d + d) Fac = Fac * i % mod;
	Ans = Ans * Fac % mod * Inv % mod;
	cout << Ans * GetInv (2) % mod << endl;
	return 0;
}
```