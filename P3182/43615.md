一直认为这是个二分图问题，然而用二分图做不会做    ORZ。

然后没办法，只好换一种方法喽。。。。

唉，我们仔细观察这个题我们发现这是一道很典型的错排问题。

至于什么是错排，我们下面来看看。

当n个编号元素放在n个编号位置，元素编号与位置编号各不对应的方法数用D(n)表示，那么D(n-1)就表示n-1个编号元素放在n-1个编号位置，各不对应的方法数，其它类推.

第一步，把第n个元素放在一个位置，比如位置k，一共有n-1种方法；

第二步，放编号为k的元素，这时有两种情况：⑴把它放到位置n，那么，对于剩下的n-1个元素，由于第k个元素放到了位置n，剩下n-2个元素就有D(n-2)种方法；⑵第k个元素不把它放到位置n，这时，对于这n-1个元素，有D(n-1)种方法；

综上得到

D(n) = (n-1) [D(n-2) + D(n-1)]

特殊地，D(1) = 0, D(2) = 1.

下面通过这个递推关系推导通项公式：

为方便起见，设D(k) = k! N(k), k = 1, 2, …, n,

则N(1) = 0, N(2) = 1/2.

n ≥ 3时，n! N(n) = (n-1) (n-1)! N(n-1) + (n-1)! N(n-2)

即 nN(n) = (n-1) N(n-1) + N(n-2)

于是有N(n) - N(n-1) = - [N(n-1) - N(n-2)] / n = (-1/n) [-1/(n-1)] [-1/(n-2)]…(-1/3) [N(2) - N(1)] = (-1)^n / n!.

因此
N(n-1) - N(n-2) = (-1)^(n-1) / (n-1)!,

N(2) - N(1) = (-1)^2 / 2!.

相加，可得

N(n) = (-1)^2/2! + … + (-1)^(n-1) / (n-1)! + (-1)^n/n!

因此
D(n) = n! [(-1)^2/2! + … + (-1)^(n-1)/(n-1)! + (-1)^n/n!].

此即错排公式。

（本段来自百度百科）

我们还会发现一个问题，这个公式那么恶心，对于那种n很大的数我们要怎样办啊。

那这样我们就用一个递推式：

f[n]=(f[n-1]+f[n-2])\*(n-1)表示错排方案数的递推公式，因为可以视为新添加两个点，

如果前n-1个满足，那么这两个与其中任意一个互相交叉互换也一定满足；

如果前n-2个满足，最后两个不满足，那么直接交叉也使得可以满足。


这个题我们也可以将其转化成一个错排问题。

但由于这个题数据比较大，我们必须采用高精



下面奉上代码

```cpp
 #include<cmath>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;
const int maxn = 201; 
const int mod = 100000000;
int n;
long long f[maxn][50];
int a[maxn];
int main()
{
    scanf("%d",&n); f[1][0]=0; f[2][0]=1; 
    for(int i=3;i<=n;i++) 
    {
    for(int j=0;j<=a[i-1];j++) 
      f[i][j]=f[i-1][j]+f[i-2][j];
    a[i]=a[i-1]; for(int j=0;j<=a[i-1];j++) 
    {
        f[i][j+1]+=f[i][j]/mod;
        f[i][j]%=mod;
    }
    while(f[i][a[i]+1]) a[i]++;
    for(int j=0;j<=a[i];j++) 
       f[i][j]*=(i-1);
    for(int j=0;j<=a[i];j++) 
    {
         f[i][j+1]+=f[i][j]/mod;
         f[i][j]%=mod;
    }  
    while(f[i][a[i]+1]) a[i]++;
    }
    printf("%lld",f[n][a[n]]);
    for(int i=a[n]-1;i>=0;i--) printf("%08lld",f[n][i]);
    return 0;
}
```