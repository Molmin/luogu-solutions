这是一道不错的 **错排** 题。

首先，题目中保证任意两个障碍不在同一行也不在同一列，那障碍的实际位置对答案便不会有影响，我们总可以交换行列位置使得第 $i$ 行的障碍在第 $i$ 列。

于是题目就变得简单起来了。我们只用求从 $1$ 到 $n$ 的一个使得 $a_{i}$ 不等于 $i$ 的排列
。

我们用一个 $f$ 数组来统计总方案数, $x$ 表示棋子总个数，我们可以分类讨论一下来求出递推式。当 $a_{x}=i$ 且 $a_{i}=x$ 时，问题就变成了剩下 $x-2$ 个棋子的错排问题。否则对另外的这 $x-1$ 个棋子，明显会有 $f(x-1)$ 种排法。

对于 $i$ 有 $x-1$ 种情况，所以得出式子为 $f(x)=(x-1)(f(x-1)+f(x-2))$

于是码出代码如下


```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n;
int f[1000010];
int t;
signed main(){
	cin>>n;
	f[1]=0;
	f[2]=1;
	for(int i=3;i<=n;i++){
		t=i-1;
		f[i]=(f[i-1]+f[i-2])*t;
	}
	cout<<f[n];
}

```

但是并没有过，只有 $60$ 分。

于是我有回去看了一下题面，发现 $x$ 小于等于 $200$ 。这道题要用高精度！

于是我用了 python 。

c++ 多写一个高精度就好了。

## 代码
```cpp
n=int(input());
f=[0 for i in range(210)];
f[2]=1;
f[3]=2;
for i in range(3,n+1):
    f[i]=(f[i-1]+f[i-2])*(i-1);
print(f[n]);

```