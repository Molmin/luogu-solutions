[题目传送门](https://www.luogu.com.cn/problem/CF331C1)

这道题就是一个很简单的贪心

首先，我们发现， $n$ 每次只要减去 $n$ 所有位上最大的数子，就可以得到最小的次数了。

那问题来了：那如何快速得到 $n$ 每个数位上的数字呢？

这里我选择了用一个堆，因为他可以 $O(\log n)$ 插入， $O(1)$ 查询最大值。

以样例为例：

step 0: $n=24$

step 1: $n=24-4=20$

这时，我们发现，$n$ 减去了他各个数位上数字的最大值（ $4$ ）,变成了 $20$ 。

step 2: $n=20-2=18$

这时， $n$ 数位上数字的最大值为 $2$ ，于是 $n$ 减去了   $2$ ，变为了 $18$ ；

step 3: $n=18-8=10$

现在， $n$ 数位上数字最大值变为了 $8$ ，于是 $n$ 变为了   $18-8$ ，也就是 $10$ 。

step 4: $n=10-1=9$

又经过了一次变换， $n$ 数位上数字的最大值变为了 $1$ ， $n$ 变为了 $10 - 1$ ，就是 $9$ 。

step 5: $n=9-9=0$

最后， $n$ 只剩一位了，数位上数字的最大值自然就是 $n$ ，也就是 $9$ 。

 $n$ 花费了 $5$ 次变为 $0$ ,所以结果为 $5$ 。

最后的最后，贴一下我的代码：
```cpp
#include <bits/stdc++.h>//头文件
using namespace std;
int cnt;
int main(){
	int n;
	cin >> n;
	while(n){
		priority_queue <int> p;//定义堆
		int j = n;//防止n变为0,找一个“替身”
		while(j){
			p.push(j % 10);//把n各个数位的数字放入堆中
			j /= 10;
		}
		n -= p.top();//减去最大值
		cnt++;//次数加一
	}
	cout << cnt;
   	return 0;//好习惯
}
```
