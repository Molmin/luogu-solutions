### 前言

挺有意思的结论题，虽然我是打表找规律的（比赛的时候确实打表找规律更好用）。

------------

### 题意

给定一个正整数 $n$，Alice 和 Bob 轮流操作，每次操作减去当前的数一个不是 $1$ 和它本身的约数。谁不能操作谁输。Alice 先操作，请问谁有必胜策略。

------------
### 分析

我们分下面 $3$ 种情况讨论：

1. 当前的数 $n$ 是个奇数；
2. 当前的数 $n$ 是偶数但不是 $2$ 的幂。
3. 当前的数 $n$ 是 $2$ 的幂。

- 第 $1$ 种情况：由于 $n$ 是奇数，那么选择的 $n$ 的约数 $k$ 肯定也是奇数，而且由于 $k|n$ 和 $k|k$，所以 $k|(n-k)$，所以 $n-k$ 一定不是 $2$ 的次幂（因为有约数 $k$），转化为第 $2$ 种情况。

- 第 $2$ 种情况：接下来我们要证明面对这种情况是必胜的。由于 $n$ 是偶数但不是 $2$ 的幂，那么一定存在一个奇数非 $1$ 约数 $k$，考虑让 $n$ 减掉这个 $k$，就转化为第 $1$ 种情况。而这样循环会在哪一步结束呢？很显然是在第 $1$ 种情况结束，因为第 $2$ 种情况的操作是无论 $n$ 为任意满足条件的值都可以进行的，而第 $1$ 种情况的会在面对质数的时候停止。

至此我们证明了第 $1$ 种情况必败，第 $2$ 种情况必胜。

- 第 $3$ 种情况：$n$ 是 $2$ 的幂时，我们可以减去 $\frac{n}{2}$ 使得 $n$ 仍然是第 $3$ 种情况，也可以减去一个其他数使得转化为第 $2$ 种情况。但是第 $2$ 种情况是必胜的，所以不应该转化为第 $2$ 种情况。于是唯一的选择就是对半减。所以 $n$ 是 $2$ 的奇数次幂时必败，$n$ 是 $2$ 的偶数次幂时必胜。



------------

### 核心代码

```cpp
int T=read();
while (T--)
{
	ll x=read();
	ll p=2;
	while (p<x) p*=4;
	if (p==x||x%2==1) cout << "Bob\n";
	else cout << "Alice\n";
}
```
