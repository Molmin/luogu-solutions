发现简单版本的 $n,m$ 都很小，因此我们可以考虑暴力做法。

不难想出一个贪心策略：将序列 $a$ **从大到小**排序，取前 $k$ 个数，那么选出的这 $k$ 个数组成的子序列一定**和最大**。证明过于简单这里就不写了。

不过这题的 $a$ 序列中可能存在值相同的元素，如何解决它们在原序列的分布问题十分关键。

一般地，设**从大到小**排序后的第 $k$ 个元素为 $x$。

那么原序列中所有**大于** $x$ 的元素**都一定**会被取到，所有**小于** $x$ 的元素**都不会**被取到。

而原序列中**等于** $x$ 的元素，是子序列中值最小的元素，可能**只取到一部分**。

这么一说，序列中不确定的元素只剩下**等于** $x$ 的元素了。

而题目说了第二关键字是**字典序**，所以 $x$ 作为子序列中最小的数，在子序列中的位置应该越前越好。

因此可以设计策略如下：

- 对于值大于原序列第 $k$ 大的元素，直接收入子序列；
- 对于值等于原序列第 $k$ 大的元素，优先挑靠前位置的，直到选满 $k$ 个数为止。

代码如下（$n,m \le 100$，随便怎么写都可以，这里为了简单就搞了个 `std::map`）：

```cpp
#include <bits/stdc++.h>
#define INF 1e9
#define eps 1e-6
typedef long long ll;
using namespace std;

map <int, int> M;
int n, m, a[110], b[110], seq[110], ss;
bool bb[110];

int main(){

	scanf("%d", &n);
	for(int i = 1; i <= n; i++)
		scanf("%d", &a[i]), b[i] = a[i];
	sort(b + 1, b + n + 1);
	scanf("%d", &m);
	for(int i = 1, k, pos; i <= m; i++){
		scanf("%d%d", &k, &pos);
		for(int j = n; j >= n - k + 1; j--)		// 挑前 k 大
			M[b[j]]++;
		ss = 0;
		for(int j = 1; j <= n; j++)		// 放到原序列找
			if(M[a[j]] > 0)
				M[a[j]]--, seq[++ss] = a[j];
		printf("%d\n", seq[pos]);
	}

	return 0;
}
```