### 本篇题解主要是对一楼 LYC_music 大佬题解的解释说明。

显然，如果第一次看到他的题解，多数人都看不懂，（那太专业了？）

`LYC` 题解原文就不引述了。

`LYC` 大概的意思是，由于小球**遇到障碍物才会停止运动**，所以小球**只会停到地图内部的边缘**或者是**障碍物的四周**（计算 `LYC` 已有，略）。也就是说，其余的点都是无用的,我们只要将**所有有用的、能直接到达的点用边连起来**，因为小球每次要走到底，所有的边权都为 $1$ 。因为我们不知道小球会在那里相遇，所以干脆**从每个可以相遇的点倒着搜**即可，所以**建反向边跑记搜**（有可能 `vector` 会被卡。记搜能有效避免重复状态造成的时间浪费）。还有就是要**搜索状态要带方向**，不同的方向会有不同的结果。最后答案只要在四个方向里的结果中选最小的就可以了。

这里放部分思维难度比较高的（伪）代码

```cpp
	for (int i = 1; i <= n; ++ i)
		for (int j = 1; j <= n; ++ j)
			if (四旁至少投一边是障碍或是边缘)
				id[i][j] = ++ tot; //tot既表示符合的点的个数，这里也可表示找到的这个点给它的编号。
	for (int i = n; i >= 1; -- i)
		for (int j = n; j >= 1; -- j){
			if (! a[i][j + 1]) //这里做范例
				to[i][j][3] = to[i][j + 1][3]; // 走到下一步
				// to[i][j][k] 表示在坐标为[i][j]的点时按k方向走，下一步到的点
			else
				to[i][j][3] = id[i][j]; //这里就是这一行/列在这个方向上的终点。
			同上
		}
	一样再做其它两个方向
	for (int i = 1; i <= tot; ++ i)
		for (int j = 1; j <= tot; ++ j)
			dis[i][j] = 114514114514, dis[i][i] = 1;
	//赋初始值，注意dis[i][i]:
	  ① i表示是几号点而不是坐标； 
	  ②因为到时候要消耗一步来找第一步，干脆直接把初值赋值为 1，然后特判相等的情况更为方便

	for (int i = 1; i <= n; ++ i)
		for (int j = 1; j <= n; ++ j)
			if (id[i][j])
				for (int k = 1; k <= 4; ++ k){
					int too = to[i][j][k];
					G[too][k].push_back(id[i][j]);
				} //建边
	for (int i = 1; i <= tot; ++ i)
		q.push(make_pair(i, i));
		//再次强调， i表示是几号点而不是坐标；
	接着就是记搜。
```
如果实有需要看代码，请[移步此处](https://www.luogu.com.cn/paste/kj921xjj)