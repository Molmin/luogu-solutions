这次比赛我增了11分，保住了我青名(```specialist```)的称号。

~~然而并没有什么卵用~~

这题作为```Div.2```的$B$题来说还是比较水的。

~~然而还是花了一个小时多一点的时间~~

## 进入正题

### 题意
> 定义```锐化数组```(```Sharpened Array```)$A$为存在一个数$k$,使得$1\leq k \leq n$且$a_1<a_2<...<a_k$且$a_k>a_{k+1}>a_{k+2}>...>a_n$。

现在给定一个数组$A$(保证所有数非负)和一种操作：

- 将一个**严格为正**的数-1.

问：

是否可以进行有限次该操作使数组$A$为```锐化数组```。

### 思路

既然~~良心~~出题人没有规定操作的次数，那我们就开始模拟锐化操作。

一个总和最小的```锐化数组```应该是这样的：

$$0,1,2,...,k-2,k-1,k,k-1,k-2,...,2,1,0$$

我们就进行模拟，看是否能构造出类似这样的数组。

### 做法

定义变量```l```为可以构建$a_1,a_2,...,a_l$使几次操作后可以变成$1,2,...l$。

定义变量```r```为可以构建$a_{n-r+1},a_{n-r+2},...,a_n$使几次操作后可以变成$n-r+1,n-r+2,...n$。

我们找出最大的```l```和```r```，然后判断“峰顶”是否比它们都要高。

### 代码
```
#include<bits/stdc++.h>
using namespace std;
int t,n,a[300010];
int main(){
   scanf("%d",&t);
	while(t--){
		scanf("%d",&n);
		for(int i=1;i<=n;i++)scanf("%d",&a[i]);
		a[0]=a[n+1]=-1;//因为要使a[1]和a[n]为0
		int l=1,r=n;
		while(a[l-1]<a[l+1]-1&&a[l]>a[l-1])a[l]=a[l-1]+1,l++;//找出最大的l
		while(a[r-1]-1>a[r+1]&&a[r]>a[r+1])a[r]=a[r+1]+1,r--;//找出最大的r
		puts(l>=r||l==r-1&&a[l+1]>a[r]&&a[l+1]>a[l]?"Yes":"No");//判断峰顶
	}
}
```