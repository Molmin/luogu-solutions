# 矩阵快速幂典型题 #

不会矩阵快速幂转到这里[斐波那契数列](https://www.luogu.org/problemnew/show/P1962)

### 首先，我们可以先用dp的思想来解这道题；

我们先按照题意定义f[k][1]表示第k个数是放金属性的珠子的话到第k个一共有几种放法，f[k][0]表示第k个数是放木属性的珠子的话到第k个一共有几种放法。
#### 这也就可以推出下面这两个式子

## f[i][0]=f[i-1][1]

## f[i][1]=f[i-1][0]+f[i-1][1]

#### 第一个意思就是第i个放木属性的话，那么i-1个就必须是金属性，这样的话，到第i个放木属性的放法数量和第i-1个放金属性的放法数量就是一样的了，就可以这样来进行转移
#### 而第二个的意思是如果第i个放金属性，那前面那个放木属性还是金属性都没关系，所以这两种情况都有可能，所以要加起来

#### 而到第i个的总情况数就是 f[i][0]+f[i][1];


这个题目有一个区别于其他矩阵快速幂的题目的特点就是它的形状是环状的，这也就是说最后一个的情况受第一个影响，这就需要我们在最后一层的时候区分下，所以有四种情况
#### （1）、金……金
#### （2）、金……木
#### （3）、木……金
#### （4）、木……木（舍去）
因为这个形状是环形的，所以第（2）、（3）种情况最后得出的个数是一样的，我们只要算第一个是金属性的话，结果是什么就行，最后金属（2）*2+（1）就行

最后就是矩阵快速幂的部分，我们定义初始值f[2]={0,1}，表示第一个无法放木属性，只能放金属性，而后面f[0]表示上面递推式中的f[i][0]，f[1]表示上面递推式的f[i][1]；

我们就可以得出矩阵快速幂的递推式（自己演算下很快就出来了）

### a[2][2]={{0,1},{1,1}}

最后上代码（和斐波那契数列差不多）

```cpp
#include<iostream>
#include<cstring>
using namespace std;
const int Mod=1000000007;
void mulself(long long a[2][2])
{
    long long c[2][2];
    memset(c,0,sizeof(c));
    for(int i=0;i<2;i++)
    {
        for(int j=0;j<2;j++)
        {
            for(int k=0;k<2;k++)
            {
                c[i][j]=(c[i][j]+a[i][k]*a[k][j]%Mod)%Mod;
            }
        }
    }
    memcpy(a,c,sizeof(c));
}
void mul(long long f[2],long long a[2][2])
{
    long long c[2];
    memset(c,0,sizeof(c));
    for(int i=0;i<2;i++)
    {
        for(int j=0;j<2;j++)
        {
            c[i]=(c[i]+f[j]*a[j][i]%Mod)%Mod;
        }
    }
    memcpy(f,c,sizeof(c));
}
int main()
{
    
    int T;
    cin>>T;
    while(T--)
    {
        long long a[2][2]={{0,1},{1,1}},f[2]={0,1};
        long long n;
        cin>>n;
        n--;
        while(n)
        {
            if(n&1) mul(f,a);
            mulself(a);
            n>>=1;
        }
        cout<<(f[0]+f[1]+f[0])%Mod<<endl;
    }

    
    return 0;
}
```




