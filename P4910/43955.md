看到没多少人发题解，那么本蒟蒻就来发一篇吧。~~这居然还是本蒟蒻的第一篇题解~~

~~话说这题难度被评为省选/NOI-真是令人智熄~~

## 简化题意

你有黑白两种珠子（~~什么时候变成黑白了~~）个INF颗，现在要将黑色与白色珠子共n颗串成一个环，使任意两个相邻的珠子中至少有一个黑色珠子，求满足条件的串法的方案数（有多组数据）。（震惊的是两种经过旋转后重合的方案视为不同的方案）

### 60分做法：

当我第一眼看到这题后，就感觉这题是道环形dp。设f[i][0]表示已经放完前i个珠子，且第i个珠子为黑色的方案数，设f[i][1]表示已经放完前i个珠子，且第i个珠子为白色的方案数，于是列出转移方程：

（1）第一个珠子为黑色，f[1][0]=1,f[1][1]=0;

（2）第一个珠子为白色，f[1][0]=0,f[1][1]=1;

f[i][0]=f[i-1][0]+f[i-1][1]；f[i][1]=f[i-1][0]（2<=i<=n）

最后答案为（1）中的f[n][0]+f[n][1]+（2）中的f[n][0]。

时间复杂度O(Tn)

当我看到数据范围“1<=n<=10^18”时，~~我和我的小伙伴们都惊呆了~~，于是就有了

### 100分做法：

经过认真的~~打表~~观察后，我发现转移方程其实可以合并：

由于f[i-1][1]=f[i-2][0]，第一条方程其实可以变为f[i][0]=f[i-1][0]+f[i-2][0]。发现了什么？斐波那契数列！

所以答案可以简化为（1）中的f[n][0]+f[n-1][0]（也就是f[n+1][0]）+（2）中的 f[n][0]。

设F[i]为斐波那契数列的第i项，则（1）中的结果为F[n+1]，而由于（2）中f[1][0]=0，即该斐波那契数列是由0开始的，所以（2）中的结果为F[n-1]。

#### 结论：

答案为F[n+1]+F[n-1]。

然而这样还并没有结束，我们应该如何求F[n+1]和F[n-1]呢？应该很容易想到用矩阵加速递推吧（也就是矩阵快速幂）。

还有一点，不要忘了特判n=1时的情况，~~不然你就会获得94分的好成绩~~

最后，~~也是最重要的~~，献上本蒟蒻的代码：

```
#include<bits/stdc++.h>
#define ll long long
#define md 1000000007
using namespace std;
int T;
ll n,m,ans;
void mul(ll f[3],ll a[3][3]){
    int j,k;
    ll c[3];
    memset(c,0,sizeof(c));
    for(j=1;j<=2;j++) for(k=1;k<=2;k++) c[j]=(c[j]+f[k]*a[k][j])%md;
    memcpy(f,c,sizeof(c));
}
void mulself(ll a[3][3]){
    int i,j,k;
    ll c[3][3];
    memset(c,0,sizeof(c));
    for(i=1;i<=2;i++) for(j=1;j<=2;j++) for(k=1;k<=2;k++) c[i][j]=(c[i][j]+a[i][k]*a[k][j])%md;
    memcpy(a,c,sizeof(c));
}
void jzksm(ll x){
    ll f[3]={0,1,1};
    ll a[3][3]={{0,0,0},{0,0,1},{0,1,1}};
    while(x>0){
        if(x%2==1) mul(f,a);
        mulself(a);
        x/=2;
    }
    ans=(ans+f[2])%md;
}//矩阵快速幂
int main(){
    scanf("%d",&T);
    while(T--){
        scanf("%lld",&n);
        if(n==1){
            printf("1\n");
            continue;
        }
        ans=0;
        jzksm(n-1);
        jzksm(n-3);//由于第一、二项已知，我们只需做n-1、n-3次变换
        printf("%lld\n",ans);
    }
    return 0;
}
```