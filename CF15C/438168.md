## 题意简述
有 $n$ 个采石场，每个采石场里有 $m_i$ 辆车,每个采石场第 $1$ 辆车里有 $x_i$ 块石头，第 $j$ （$0<j \leq m_i$）辆车中有 $x_i+j-1$ 块石头。有两个人每次从任意一辆车中取任意数量的石头（不能不取），最后一个取完所有石头的胜利，两人都以最优策略去取，问结果是先手胜利还是后手胜利。
## Solution
     
读完题之后，我们很快地可以发现这就是一个**Nim游戏**，而Nim游戏的后手必胜条件是每一堆的石子数异或起来**结果为 $0$** ，否则先手必胜。   
然后....~~直接暴力异或？~~  

看一下数据范围，$n<=10^5 $, $x_i,m_i<=10^{16} $ ,采石场数量不多，但是车的数量和每堆石子的数量是一个很大的数，这告诉我们~~暴力会TLE~~要用一个 $O(n)$ 的算法。   

观察一下这道题给出的条件，每个采石场的第一辆车的石头数是给定了的，而后面每辆车的石头数都是前一辆车的石头数+1，所以每个采石场可以看成一个连续的自然数序列，这个序列里每一个数都异或起来的结果肯定是有规律的，不妨推导一下这个规律。 

先观察一下**从 $0$ 开始**的自然数序列的异或和有什么规律：   

| 序列长度 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 |
| -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: |
| 异或和 | 1 | 3 | 0 | 4 | 1 | 7 | 0 | 8 | 1 | 11 | 0 | 12 |
可以发现，异或和似乎有某种规律，这个规律看起来和序列长度有关,令序列长为 $l$ 。        
先从 $l=0$ 看起，此时序列异或和为 $0$ 。      
然后 $l=1$ ，序列里新添加了一个 $1$ ，原来的异或和为 $0$ ，那么这个序列现在的异或和就为 $1$ 。    
接着 $l=2$ , 序列里又多了一个 $2$ ，原来的异或和为 $1$ ，再和 $2$ 异或一下得到 $3$ 。  
再看 $l=3$ , 新来的这个 $3$ 和原来的异或和相等，所以异或和又回到了 $0$ 。     
$l=4$ 时，$4$ 异或上 $0$ 还是 $4$； $l=5$ 时，$5$ 和 $4$ 只有最后一位不一样，所以异或和变成了 $1$ ；$l=6$ 时，$6$ 是个偶数，所以 $6$ 异或上   $1$ 就相当于给 $6$ 加上 $1$ 也就是 $7$ ； $l=7$ 时，跟 $l=3$ 的情况一样，$l=8$ 时和 $l=4$ 时的结果一样......以此类推，推完之后发现了下面的这些规律：  
1. 如果 $l\bmod 4=1$ ,那么异或和为 $1$ 。  
2. 如果 $l\bmod 4=2$ ,那么异或和一定为 $l+1$ (在 $1$ 的基础上多异或了一个 $l$ ,$l$ 为偶数所以二进制下最低位为 $0$ ，和 $1$ 异或刚好得到 $l+1$ )。   
3. 如果 $l\bmod 4=3$ ,那么异或和一定为 $0$ (以刚刚的 $l$ 为准,在异或和已经为 $l+1$ 的基础上多异或了一个 $l+1$ ，两个相同的数的异或值为 $0$ )。 
4. 如果 $l\bmod 4=0$ ,那么异或和一定为 $l$ (任何数异或上一个 $0$ 都不变)。   
在规律4的基础上再来解释规律1，以规律4的 $l$ 为准，$l$ 和 $l+1$ 的异或结果一定为 $1$，因为 $l\bmod 4=0$ ,所以 $l$ 和 $l+1$ 只有最低位不同，所以异或结果为 $1$ 。   

~~恭喜你完成了一大半的推导。~~   

但是，$1\leq x_i\leq 10^{16}$ ,也就是说序列一定不从0开始，so....如何解决？

异或运算的逆运算是它本身，就是 $a \oplus  b \oplus b=a$ ，这个序列是从 $x_i$ 开始的，我们可以算出来 $0\sim x_i+m_i-1$ 的异或和，再求出 $0\sim x_i-1$ 的异或和，两者异或一下就得到了 $x_i\sim x_i+m_i-1$ 的异或和，根据上面推导得出的结论，可以 $O(1)$ 求出一个采石场中石头数量的异或和，$O(n)$ 求出总的异或和，然后判断一下即可。
## Code
~~结论题的代码一般都很简单，推出结论的话几行就出来了。~~
```c
#include <bits/stdc++.h>
using namespace std;
#define ll long long//记得开longlong
#define rint register int
#define pc(x) putchar(x)
#define gc getchar
ll n,a,m,sum,ps;
inline ll read(){
	ll x=0;
	char ch=gc();
	while(!isdigit(ch)) ch=gc();
	while(isdigit(ch)) x=x*10+ch-'0',ch=gc();
	return x;
}
ll work(ll x){//根据推导出的规律来快速求出异或和
	if(x%4==0) return x;
	if(x%4==1) return 1;
	if(x%4==2) return x+1;
	else return 0;
}
int main(){
	n=read();
	for(rint i=1;i<=n;i++) a=read(),m=read(),sum^=(work(a+m-1)^work(a-1));
	(sum)?printf("tolik"):printf("bolik");//总异或和不为0则先手胜，否则后手胜
	return 0;
}	
```
