有删减，原文见[**我的博客**](https://www.cnblogs.com/SharpnessV/p/14861735.html)


先考虑 $60$ 分做法，每种颜色恰好选择一个。

那么最优值一定是全部选最小的，最大值一定是全部选最大的。

考虑只记录当前指针 $p$ ，每次可以选择将当前指针对应位置向后移动一格，也可以选择将指针向后移动若干格。

由于指针 $p $ 只能向后移动，考虑每次只能将指针向后移动一格，而不是若干个。

这里我们利用撤销操作，如果当前指针只选了一个数，则可以选择撤销，并将指针向后移动一格。

这样时间复杂度  $\mathcal{O}(K\log K+N+M)$ ，可以得到 $60$ 分。

我们可以延续 $x=y=1$ 的做法，现在每种颜色可以选多个数。

对于当前颜色，我们可以把一种方案看成 $x=y=1$ 时的一个物品，现在我们只需要对于每种颜色，快速求出第 $k$ 小的方案。

这是与前面不相干的子问题，我们可以分开解决。

如果我们钦定选择 $s$ 个数，那么最小的方案一定是选择最小的 $s$ 个数，最大的方案一定是选择最大 $s$ 个数，其余的任何方案都可以表示为从最小的 $s$ 个数开始，选择若干个数向后移动若干位。

其中移动时两个数不能相交，一个数不能越过另一个数。

那么我们维护四元组 $(i,j,k,val)$ ，分别表示当前需要移动的是第 $j$ 个数，它前面是第 $i$ 个数，它后面是第 $k$ 个数，当前代价是 $val$ 。

对于任意一个满足 $l\le s\le r$ 的 $s$ 初始化插入 $(s-1,s,size+1,0)$ 。

转移，$(i,j,k,val)\to (i,j+1,k,a_{j+1}-a_j+val)$ , $(i,j,k,val)\to (i-1,i+1,j,a_{i+1}-a_i+val)$ 。

所以总状态数 $<3k$ ，堆维护，时间复杂度 $\mathcal{O}((k+n)\log k) $ 。
