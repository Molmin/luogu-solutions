一种更加朴素的方法。

首先我们此题实际上要做的，就是对每个数维护其到达目标 $s_i$ 的实际时间，设为 $s_i+tim$。

于是用小根堆维护 **已经到达的 $s_i$ 的奶牛 $i$** 的所有 $s_i+tim+t_i$，考虑堆顶这个点在 $t_i$ 时间内，实际上是堵住了序列上一个连续区间的所有其它点，使得它们对应的 $tim$ 加上了 $t_i$。

可以把每个数维护一个 $v_j=s_j - j$，然后考虑现在一个 $s_i=k$ 位置正在坐下，那么直到上一个 $j$ 满足 $v_j \le n - k$，其之后的部分就是这个区间。

然后再考虑那个 $j$，其已经到达目标，再求出其对应区间，并将其插入小根堆。

接下来，考虑从堆顶 `pop` 出 $i$，则这个区间可以继续往后走。我们可以把这区间里面的 $v_j$ 减去 $t_i$，然后把这个区间包含进入下一个在堆内的节点。

同时在这个区间内，继续计算是否有已经到达目标的点，并插入堆。

为了方便，多加上一个 $s_{n + 1} = n + 1, t_{n + 1} = \infty$。这样下一个点一定存在。

用线段树处理区间操作。

关于复杂度，可以用势能分析。故复杂度 $O(n\log n)$。