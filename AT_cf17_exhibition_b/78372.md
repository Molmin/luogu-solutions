显然可知，结果的序列中只有原序列的集合中的元素。

若没有，则把不在原集合中的元素替换为其在原集合中的前驱，一定不劣。



考虑一个贪心的解法：

将 ai 按顺序插入，使得每次插入后都能满足题意。如果 ai 前的元素已经形成了一个满足题意的序列，插入的操作一定是将其变为一个不小于它的值，然后往前类似于冒泡排序那样交换。

若将 $a_i$ 更改为 $v ( v≥a_i )$，更改的代价为 $v - a_i$，交换的代价为当前序列中在 $a_i$ 之前且比 $v$ 大的数的个数 $cnt(v)$ ，总代价为 $val(v) = v + cnt(v) - a_i$。对于每一个 $a_i$ ，贪心的策略是每次都选择将其改为 $val$ 最小的 $v$ 。

先离散化，决策中的 $v + cnt(v)$ 可以用一个权值线段树去维护：每加入一个数会对比它小的数的询问有 $1$ 的贡献，所以修改是区间加，查询是全局最小值。

---

如何去证明呢?

若当前点为 $a_i$，当前最优决策为 $v$ ，任取一个决策 $v' ( v' ≠ v )$。

显然有 $val(v) ≤ val(v')$ 。我们要去证明 $v$ 不会比 $v'$ 更劣。

首先，对于一个决策 $x$，对当前答案的影响是 $val(x)$ ，对全局的影响是对 $[1,x-1]$ 的所有决策值全部 $+1$。

显然，若 $v ≤ v'$，在当前局面上 $val(v) ≤ val(v')$，一定不优；
在全局上 $v'$ 区间加的更多，影响更大，也是不优的。所以当 $v ≤ v'$ 时，$v$ 不会比 $v'$ 更劣。

对于 $v > v'$ 的情况，有两个引理。

> $\textsf{1.对于一个定区间内，最优的决策的位置随着时间推移只会不变或向右跑。}$


这个很显然，如果决策从 $v_1$ 跑到了 $v_2 ( v_2 < v_1 )$ ，则有：

$$
\begin{cases}
val(v_1)≤val(v_2) \\
val(v_1)+\Delta v_1>val(v_2)+\Delta v_2
\end{cases}
$$

由于加的是前缀，所以 $\Delta v_1≤\Delta v_2$，两式不可能同时成立。

> $\textsf{2.如果第 }i(i\neq n)\textsf{ 次没有选择当前最优，那么之后一定有一次选择了当前最优。}$

这个也很显然，如果之后没有任何一次选择当前最优的话，将最后一次选择当前最优一定更优。~~其实指的就是最后一次（（（~~

为方便表述，这里用数轴去代替权值线段树。

![01.png](https://i.loli.net/2020/11/19/qJPmb4MtxsTR8Xf.png)

蓝色是 $v'$ 的区间加，紫色是 $v$ 的区间加。

令下一次取最优决策点时的决策为 $v''$，由引理②可以得知 $v''$ 存在。

由于引理①，对于任意的一个定区间 $[ k , n ] ( v'≤k≤v )$ ，它的最优决策只会随时间推移向右跑。
观察可以发现，不同的只有 $[ v' , v ]$，所以只需证明该区间不对其产生贡献。

1. 当 $v''≥v$ 时，$[ v' , v ]$ 显然不会计入答案。

![02.png](https://i.loli.net/2020/11/19/CP3Hsz4BayMbmlo.png)

2. 当 $v'≤v''≤v$ 时，对于查询区间，最优决策 $v$ 只会向右推移，$[ v' , v ]$ 无贡献。

![03.png](https://i.loli.net/2020/11/19/WwVM9AkBU5JtXPC.png)

3. 当 $v''＜v'$ 时，可以看做是区间 $AB$ 取 $min$ 而成，其中对区间 $B$ 应用引理①，可知 $[ v' , v ]$ 依然不会产生贡献。


![04.png](https://i.loli.net/2020/11/19/YH6NLhG2S5Xs1mn.png)

这样就证完了。

---

还有一点小东西。

观察上面的证明过程可以发现，当前决策的区间加只要比 $v$ 小，且不比 $a_i$ 小（一个数不能减小），对后面的决策不造成影响。所以每次区间加不用去查询最小值出现的位置，而是只需要去加 $[1,a_i-1]$ 即可。

---

核心代码（其中 `t` 为线段树）：

```cpp
  for(int i=1;i<=n;i++){
      read(a[i]),b[i]=a[i];
  }
  sort(b+1,b+n+1),t.build(b);
  for(int i=1;i<=n;i++){
      int pla=lower_bound(b+1,b+n+1,a[i])-b;
      ans+=t.query_min(pla,n)-a[i];
      t.update(1,pla-1,1);
  }
  write(ans);
```
