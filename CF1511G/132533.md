做过最好的一道运用到“逐位考虑”性质的题目了，不看题解思路完全往莫队上面去了……                   

首先很显然的转化一下题意，我们只需要知道石子堆的异或和就好了，也就是回答所有询问的：           

$\bigoplus_{i = 1} ^ n [l \leq a_i \leq r](a_i - l)$    

即可。              

考虑如何维护这个东西，最经典的操作就是莫队滚区间然后用 trie 树做全局整体 $\pm 1$ 以及全局整体异或和得到 $O(n \sqrt n \log n)$ 的时间复杂度，虽然可以卡常过掉此题但是这种做法显然还不够优秀。                

我们考虑一些很有兴趣的性质。既然是异或和，那么还是逐位考虑咯？而且我们的式子里面只和左端点有关系，还要维护类似“和”的东西。不难想到倍增固定左端点维护以这个端点开始的一个区间异或和。                

记 $sum_{i , j}$ 表示从值域的第 $i$ 个数开始到 $i + 2 ^ {j} - 1$ 这一段的区间异或和，注意这里的区间异或和对于每一个数已经减去了 $l$ 。            

那么我们很自然的开始凑式子，最理想的情况当然是像 st 表那样从 $sum_{i , j - 1}$ 和 $sum_{i + 2 ^ {j - 1} , j - 1}$ 转移。我们不难发现，对于 $i + 2 ^ {j - 1}$ 到 $i + 2 ^ j - 1$ 这一段减去 $i$ 后，值域在 $[2 ^ {j - 1} , 2 ^ j - 1]$ 之间，其最高位是 $2 ^ {j - 1}$ 。而且我们刚才罗列的两个状态里面都是不涉及这一位的。考虑异或的性质，我们现在是不是只要知道这一段值域区间里面棋盘上的棋子数的奇偶性就可以得到这一位对最后的答案是否有贡献了啊？          

令 $Sum_x$ 表示棋盘上有多少个棋子在 $1 \sim x$ 这些列上，于是可以得到转移式：             

$sum_{i,j} = sum_{i , j - 1} \bigoplus sum_{i + 2 ^ {j - 1} , j - 1} \bigoplus [Sum_{i + 2 ^ j - 1} - Sum_{i + 2 ^ {j - 1} - 1} \mod 2 = 1] \times 2 ^ {j - 1}$       

预处理这个东西出来之后，我们对于查询还是运用相同的道路：                   

从高位到低位考虑每一位的贡献。如果当前答案可能涉及到一位 $k$ ，那么我们就先把预处理出来的 $dp_{l , k}$ 往答案里面塞，接着只用考虑 $[l + 2 ^ k , r]$ 这一段内棋子数的奇偶性就可以求得 $2 ^ k$ 这一位是否会对答案贡献，由于从高到低枚举，$k$ 是当前的最高位，所以这一位的造成贡献情况以及 $[l , l + 2 ^ k - 1]$ 这一段区间的异或和已经被全部搞定。     

接下来把 $l$ 置为 $l + 2 ^ k$ 后继续考虑就好了，由于从高到位倍增枚举，所以最后单次查询只会用 $O(\log m)$ 的时间。         

最终的时间复杂度就是 $O((m + q) \log m)$ 。    

对于这种方法，个人认为是不止 2700 的。

```cpp
#include "bits/stdc++.h"
using namespace std;
const int Len = 2e5 + 5;
int sum[Len][35],n,m,q,a[Len],Sum[Len];
int main()
{
	scanf("%d %d",&n,&m);
	for(int i = 1 ; i <= n ; i ++) 
	{
		scanf("%d",&a[i]);
		Sum[a[i]] ++;
		//sum[a[i]][0] ^= a[i];
	}
	for(int i = 1 ; i <= m ; i ++) Sum[i] += Sum[i - 1];
	for(int j = 1 ; j <= 28 ; j ++)
		for(int i = 1 ; i + (1 << j) - 1 <= m ; i ++) 
			sum[i][j] = sum[i][j - 1] ^ sum[i + (1 << (j - 1))][j - 1] ^ (((Sum[i + (1 << j) - 1] - Sum[i + (1 << (j - 1)) - 1]) % 2) * (1 << (j - 1)));		
	scanf("%d",&q);
	for(int i = 1 ; i <= q ; i ++)
	{
		int l,r;scanf("%d %d",&l,&r);int ans = 0;
		for(int j = 28 ; j >= 0 ; j --)
		{
			if(l + (1 << j) <= r) 
			{
				ans ^= sum[l][j] , l += (1 << j);
				if((Sum[r] - Sum[l - 1]) & 1) ans ^= (1 << j);
			}
		}
		(ans == 0) ? putchar('B') : putchar('A');
	} 
	return 0;
}
```