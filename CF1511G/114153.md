一开始其实也只会莫队套 Trie 的 $O(n\sqrt n\log n)$，看了官方题解不知所云，后来在 CF 讨论区里找到了这个神奇的做法，来补一发。

___

首先非常明显，这两位就是在玩一个 Nim 游戏，所以问题转化为：考虑在范围内的棋子，这些棋子到左边界的距离的**异或**和。

看到位运算，考虑逐位确定答案。发现逐位这种东西用**倍增**维护起来非常方便，（毕竟倍增就是一个逐位的过程），所以来考虑倍增怎么做。

我们定义 $jp_{i,k}$ 表示，只考虑纵坐标位于 $i$ 至 $i+2^k-1$ 的棋子、钦定左边界为 $i$ 的距离异或和。

考虑转移。发现倍增在转移到更高位时，最高位的贡献是**独立**的（即 k 更低的位都不会对这一位产生影响）。所以如果要从 $jp_{i,k-1} $ 转移到 $ jp_{i,k}$，第 k 位的贡献就只是纵坐标位于 $i+2^{k-1}$ 到 $i+2^k-1$ 的棋子数量的奇偶性。

写成更简洁的形式：其中 $\oplus$ 表示异或，$Sum_i$ 表示前 i 列中有多少个棋子。

$$jp_{i,k} = jp_{i,k-1} \oplus jp_{i+2^{k-1},k-1} \oplus [Sum_{i+2^{k}-1}-Sum_{i+2^{k-1}-1} \text{mod} \ 2 = 1] \times 2^{k-1}$$

这整个倍增表可以在 $O(m\log m)$ 的时间内预处理出来。

然后来考虑回答询问。用倍增的套路，从高位到低位依次逼近答案。我们发现，每拼接上一段，整个区间中还未被拼接上的部分的所有棋子的距离都会增加一个**二的幂次**。换句话说，这只对要求的答案的**某一位**产生贡献。

然后跟预处理部分一样，前缀和讨论棋子数量的奇偶性即可。

每回答一次询问需要 $O(\log m)$ 的时间，总复杂度 $O((m+q)\log m)$。

给个代码：

```cpp
#include <cstdio>
const int maxn = 2e5+5;
int n,m,q,a[maxn],sum[maxn];
int Log[maxn],jp[maxn][19];
int main(){
	scanf("%d %d",&n,&m);
	for(int i=1;i<=n;++i)scanf("%d",&a[i]),++sum[a[i]];
	for(int i=1;i<=m;++i)sum[i] += sum[i-1];
	for(int i=2;i<=m;++i)Log[i] = Log[i>>1] + 1;
	for(int j=1;j<=Log[m];++j)
		for(int i=1;i+(1<<j)-1<=m;++i)
			jp[i][j] = jp[i][j-1]^jp[i+(1<<j-1)][j-1]^((1<<j-1)*((sum[i+(1<<j)-1]-sum[i+(1<<j-1)-1])&1));
	scanf("%d",&q);
	for(int i=1,l,r,ans;i<=q;++i){
		scanf("%d %d",&l,&r),ans = 0;
		for(int k=Log[m];~k;--k)
			if(l+(1<<k) <= r){
				ans ^= jp[l][k],l += (1<<k);
				if((sum[r]-sum[l-1])&1)ans ^= (1<<k);
			}
		putchar(ans?'A':'B');
	}
	return 0;
}
```

挺好一题。