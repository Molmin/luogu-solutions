### 题意简述

- 现有 $n$ 个数 $1 \le c_1, c_2, ... , c_n \le m$。

- $Q$ 次询问，每次询问给出 $l, r$，询问 ${\rm xor}_{\ l \le c_i \le r}(c_i - l)$ **是否等于 0**。

- $n, m, Q \le 2 \times 10^5$。

提供了三种不同做法。

### 算法 1
自己 yy 的做法。

先将 $c_i$ 排序。然后值域区间对应一个下标区间，对值域区间莫队。

于是我们只需要支持以下操作：

全局权值 $+1$ 或 $-1$，全局异或和。

这个是某年联合省选原题。 具体地，把 Trie 倒过来就容易维护了。

$O(n \sqrt{n} \log n)$。

不过右侧移动似乎是 $O(1)$ 的，应该有奇怪的排序方法能把 $\log$ 放进去。日后有空想一想写一写会放份代码。

### 算法 2
官方题解的奇妙根号分治。感觉十分奇怪。

先离线下来，然后问题就变成了查询 $F(x, y) = {\rm xor}_{\ y \le c_i}(c_i - l)$。

把每个数拆成 $\le 2^K$ 和 $ > 2^K$ 两部分分别统计答案。

前一部分比较好处理。我们直接存下来所有数对 $2^K$ 取余的结果，查询时是容易的。

后一部分看起来比较困难，但发现每个位置的前 $2^K$ 位在 $l$ 变化时只改变 $ \dfrac{m}{2^K}$ 次，于是拿个 BIT 暴力去维护他就好了。

两个拼起来就好。

$O(n \sqrt{n \log n})$。

挺智慧的，反正我肯定不会去想。想了也不一定能想到基于改变用 BIT 维护。

~~忘记基础思想.jpg~~

### 算法 3

自己 yy 的做法 2。

当时想完算法 1 就想不根号。想着想着还真给想出了点什么。

我们考虑位运算和倍增，就像笔芯和钻石一样，性质不同，却相互衍生，本质相同。

于是我们记一手 $f(x, y) = {\rm xor}_{\ x \le c_i \le2^y}(c_i - x)$。 

然后大力倍增去求 $f$。只在当前位有奇数个的时候才略需讨论。

求答案的时候也是不难操作的。于是就单 log 了。

代码下次一定。