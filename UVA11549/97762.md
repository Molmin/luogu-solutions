### 例题（[戳](https://www.luogu.org/problemnew/show/UVA11549)）

* 这就是刘汝佳紫书中的一道题目

* 题目想法简单，关键是其中涉及到一种挺有意思的想法

* 即Floyd判环

* 那么什么是Floyd判环呢？

* 对于这道题目，首先很简单能想到一种算法，即枚举所有可能的解，并用一个set存起来

* 每得到一个新的解，就与判断先前这个解是否出现过

* 若出现过则退出循环并输出最优解，若未出现过则将这个数加入set，并进行下一轮操作

* 但是这种解法空间消费比较大（因为你每得到一种解，就把它放进set中）

* 另外还有一种解法，即Floyd判环

* 大致的思路其实是差不多的，唯一不同点就在于Floyd判环用一种很巧妙的方式跑完了整个圈环，而不用开set

* 什么意思呢？

* 我们可以把第一种方案想象成一个小孩绕着圈在跑步，每跑一步，他就能得到一个新的值，再对此进行操作

* 而Floyd判环，其实是让一个跑得快的小孩2号和一个跑得慢的小孩1号跑同一个环

* 当快小孩儿追上慢小孩时，说明什么，**说明他已经跑完了一整圈**，换种说法，**就是他已经跑过了所有情况，并得到了所有可能的值**

* 因而，我们只需要在快小孩跑步时处理他跑出来的数据就可以了

* 至于快小孩比慢小孩每次多跑几步，这无所谓，只要适当就好，当然，如果你这一点处理不好的话，是会影响到复杂度的（具体内容很玄学，我们就不赘述了）

* 具体代码就不放了，大家可以看楼下或紫书或我提交的代码~~（虽说三个完全一样）~~