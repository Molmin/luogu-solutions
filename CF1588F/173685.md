[CF1588F Jumping Through the Array](https://www.luogu.com.cn/problem/CF1588F)

给定序列 $a_{1\cdots n}$ 与**排列** $p_{1\cdots n}$，进行 $q$ 次操作如下：

- `1 l r`，询问 $\sum_{i=l}^r a_i$ 的值；
- `2 v x`，连边 $i\to p_i$，将 $v$ 能到达的所有点 $u$ 的 $a_u\gets a_u+x$；
- `3 x y`，交换 $p_x,p_y$。

$1\leq n,q\leq 2\times 10^5$，$-10^8\leq a_i\leq 10^8$。

图由若干个环构成，交换 $p_x,p_y$ 性质很不优美，并且显然修改的方式不便于上线段树，所以考虑上根号复杂度的处理。

先考虑序列分块，但没啥用，所以考虑操作分块，每 $S$ 个询问统一处理一次，总共处理 $O(\frac qS)$ 次。那么把所有 $2$ 操作中的 $v$ 设置为关键点，一条链定义为从一个关键点的后继出发，直到遇到第一个关键点为止，那么这条链始终处于同一个环中，且只有 $O(S)$ 个，我们将其缩起来以链为基础单位来处理，每次处理标记每个点所处的链，复杂度 $O(n)$。

维护一个到这次处理之前的前缀和，顺序遍历操作，$2$ 操作遍历目前环上的每条链，在链上打 add 的标记，复杂度 $O(S)$，$3$ 操作只需要直接交换 $p$ 即可，复杂度 $O(1)$。

接下来考虑 $1$ 操作的答案就是前缀和算出来的答案再加上块内之前修改的贡献，那么需要枚举每一条链对这次询问的贡献，其等于这条链当前的 add 标记乘上其中有多少个点在 $[l,r]$ 内，add 标记可以直接查，求链中有多少点编号在区间内这一步如果直接二分来搞的话可以做到 $O(S\log n)$，那么总复杂度就是 $O(\frac qS \cdot n+qS\log n)$，将 $n,q$ 视为同阶，则在 $S=\sqrt \frac {n}{\log n}$ 时取得理论最优复杂度 $O(n\sqrt{n\log n})$，貌似可以通过。

但是可以先将其预处理出来，考虑得到每个点所在的链之后按编号从小到大遍历每一个点，并给其所在的链的权值 +1，则遍历到 $i$ 时链的权值的意义就是链中编号属于 $[1,i]$ 的点的个数，于是把询问拆成前缀相减来做就可以做到总复杂度 $O(n\sqrt n)$。

[我写的代码](https://codeforces.com/contest/1588/submission/143728939)跑的不是很快，但是应该比较简洁。