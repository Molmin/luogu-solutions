相当好的题，下文假设 $n,m$ 同阶。

首先考虑一个事实：如果没有 $3$ 操作，有一个非常显然的 $O(n\sqrt n)$ 算法。

* 对于修改，直接在这个环上打标记。
* 对于询问，处理每一个被操作过的环，计算这个环中有几个点在询问区间内，乘上这个环的值。
* 在 $\sqrt n$ 次操作之后，计算每个点的值加入一个数组，并清空。之后的询问直接加上这个数组的区间和。

注意到 $\sqrt n$ 次操作之后清空是一个很高明的想法。我们考虑将某些一直处在某个环上一个连续段的点集缩成一个点，因为在 $\sqrt n$ 次操作中最多只有 $\sqrt n$ 个位置被改变，所以一个环的环长最大值也只有 $\sqrt n$，同样也可以证明被修改过的点最多只有 $\sqrt n$ 个。

于是我们稍微修改就能得到另一个 $O(n\sqrt n)$ 算法：

* 对于修改，直接在这个环的所有点集上打标记。
* 对于询问，处理每一个被操作过的点集，计算这个点集中有几个点在询问区间内，乘上这个点集的值。
* 在 $\sqrt n$ 次操作之后，计算每个点的值加入一个数组，并清空。之后的询问直接加上这个数组的区间和。

注意到这里计算询问区间内点的数量是因为询问只有 $\sqrt n$ 个区间，即询问 $\sqrt n$ 个位置的前缀和，因此我们直接将一个数转成这 $\sqrt n$ 个位置的 lower_bound 然后暴力做前缀和就可以了，时间复杂度是对的。

代码有点细节，顶碗人代写！