这道题总体来说不是很难，要注意的地方是每走一步要判断一下走了之后是否可以在指定时间内出去，如果出不去，就不走这一步。第一次走要特别判断，因为是从路边走最短的路线到达第一个点。详情见代码QuQ

    #include<bits/stdc++.h> //万能头 
    using namespace std;
    int m,n,k,a[25][25],maxn=0,p=0,ii,jj,pp,huasheng=0;
    int main()
    {
        //freopen("data.in","r",stdin);
        cin>>m>>n>>k;
        for(int i=1;i<=m;i++)
        {
            for(int j=1;j<=n;j++)
            {
                cin>>a[i][j]; //输入花生田 
            }
        } 
        //第一次
        for(int i=1;i<=m;i++)
        {
            for(int j=1;j<=n;j++)
            {
                if(a[i][j]!=0) //有花生植株 
                {
                    if(a[i][j]>maxn)
                    {
                        maxn=a[i][j]; //maxn拿到花生最多的花生植株
                        //题目说的是先找花生最多的植株 
                    }
                }
            }
        }
        for(int i=1;i<=m;i++)
        {
            for(int j=1;j<=n;j++)
            {
                if(a[i][j]==maxn) //找到这棵花生植株的位置 
                {
                    p+=i; //p记录下从路边到这棵花生植株所耗用的时间 
                    a[i][j]=0; //这个地方已经采摘完毕，变为0 
                    ii=i;
                    jj=j; //ii、jj记录下当前这棵花生植株的位置，以后有用
                }
            }
        }
        if(2*p+1>k) //如果来回所用的时间加上采摘需要的时间大于指定的时间 
        {
            cout<<"0"; //小猴一个花生都摘不到（可怜QwQ） 
            return 0; 
        }
        else
        if(2*p+1==k) //如果来回所用的时间加上采摘需要的时间刚好等于指定的时间 
        {
            cout<<maxn; //小猴摘到了maxn个花生（太好了有吃的QwQ） 
            return 0;
        }
        else //走到这里说明有可能还可以继续采摘 
        {
            p++; //p加上小猴采摘所需的时间1 
            pp=p; //pp储存第一次摘花生所需的时间 
            huasheng+=maxn; //变量花生累加 
        }
        //第一次结束 
        while(pp!=k) //从第二次开始就可以循环了！ 
                     //直到pp（一共所用时间）等于 k（指定时间）下 
        {
            maxn=0; //一定要清零 
            for(int i=1;i<=m;i++)
            {
                for(int j=1;j<=n;j++)
                {
                    if(a[i][j]!=0) 
                    {
                        if(a[i][j]>maxn)
                        {
                            maxn=a[i][j]; //拿到刷新后的数组中的最大的数（刚才有一个最大的数被刷新成0了） 
                        }
                    }
                }
            }
            for(int i=1;i<=m;i++)
            {
                for(int j=1;j<=n;j++)
                {
                    if(a[i][j]==maxn)
                    {
                        p+=abs(i-ii)+abs(j-jj); //小猴不能斜着走，只能横着、竖着走，所以这个关系式
                                                //就可以算出小猴从一个花生植株到另一个花生植株所用的时间了！
                                                //好像叫平面直角坐标系？ 
                        a[i][j]=0; //刷新，这个地方变成0 
                        ii=i;
                        jj=j; //ii、jj记录下当前这棵花生植株的位置，以后有用 
                    }
                }
            }
            if(ii+p+1>k) //走回去的时间加上上一次耗费的时间和这一次采摘的时间大于指定时间 
            {
                cout<<huasheng; //这次不摘，只输出上一次摘的个数 
                return 0;
            }
            else
            if(ii+p+1==k) //走回去的时间加上上一次耗费的时间和这一次采摘的时间刚好等于指定时间 
            {
                cout<<huasheng+maxn; //上次的和这次的一起拿走吃！ 
                return 0;
            }
            else //还有可能可以继续摘 
            {
                p++; //加上采摘耗费的时间1 
                pp=p; //记录一共所用的时间 
                huasheng+=maxn; //变量花生累加 
            }
            //这样不断循环的话总会出现大于或等于指定时间的情况！ 
        }
        return 0;
    } 
    //代码有点长，但是较易懂，各位dalao勿喷！！！ 