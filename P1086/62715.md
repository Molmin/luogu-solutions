这题用降维大法！
————用结构体来实现二维数组的降维排序。只需要33行。

------------

建二维数组再反复找最大值是很自然的想法，但这样既没必要，也费时间。注意，题目要求是按花生数从大到小依次寻找，所以不要用贪心、深搜，只要能排序就能解决了。这样又有三个问题需要解决。

------------

一是二维数组如何排序？先一维化，再排序，但需要记录行号列号，因为要计算与植株、与路边的距离。这样就要用到结构体。

------------

二是能不能采摘如何判断？要做三件事，能去、能采、能回路边。能去就要用与下一个植株的距离，也就是相应行号、列号之差的绝对值之和判断，注意不是平面坐标系上两点的距离；能采是1单位时间，能回路边是行号减0。

------------

三是注意几个坑。第一，会不会一株也采不了？第1次是从路边直接进去，与列号无关，没有距离的计算，有特殊性，所以要对第1次采摘特判。第二，采最后一株时不需要进行能去下一株的判断，这时怎么处理？直接能回路边就可以，要防止数组过界。第三，会不会去了但不够采，或者不能回？每次更新剩余时间时，能去下一株采摘的前提是问题2的三件事，回路边已经作了判断，所以既然到了下一个植株，就能够从那里采了直接回路边。


```cpp
#include<bits/stdc++.h>
using namespace std;
struct pea{
	int a,b,s;//行、列号及花生数,行号a同时是回路边步数 
}p[600];
bool cmp(pea x,pea y){//按花生数排序规则 
	return x.s>y.s;
}
int main()
{
    int m,n,k,i,j,r=0,t,ans=0;
    scanf("%d%d%d",&m,&n,&k);
    for(i=1;i<=m;++i)
    for(j=1;j<=n;++j)
    {
    	++r;//结构体数组个数计数,最终r=m*n 
    	scanf("%d",&p[r].s);
		p[r].a=i,p[r].b=j;//记录花生数及行列号 
	}
	sort(p+1,p+1+r,cmp);//全部按花生数从大到小排好 
	if(k>=1+2*p[1].a)//采摘需要1单位时间，第1次直接去并且能回，
		k-=p[1].a+1,ans+=p[1].s;//去并且采摘，更新剩余时间，熊停在a1
	else {printf("0");return 0;}//否则不够时间采摘和回来就输出0个 
	for(i=1;i<r;++i)//站在第一株花生旁向下一步看
	{
		t=abs(p[i].a-p[i+1].a)+abs(p[i].b-p[i+1].b);//与下一点距离 
		if(k>=t+1+p[i+1].a)//能去、采、回路边,最后一步也是如此 
			k-=t+1,ans+=p[i+1].s;//就去采，更新剩余时间和采摘数 
		else break;//不能采就退出 
	}
	printf("%d",ans);
    return 0;
}

```
- 