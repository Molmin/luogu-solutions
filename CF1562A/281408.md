**~~昨晚历经艰辛坎坷过了这道题，写篇题解纪念一下。~~**

# 题目大意

输入两个数分别为 $l$ 和 $r$ 让你从 $l$ 到 $r$ 的区间中选出两个数，分别为 $a$ 和 $b$ ，并且 $r\ge a\ge b\ge l$ 输出 $a\bmod b$ 的最大值。

# 解题思路

由于这一题的数据范围是： $1\le l\le r \le 10^9$ 所以我们直接暴力枚举 $a$ 和 $b$ 肯定会 $T$ 飞，所以我们想 $O(1)$ 的实现方法。

我们可以把这道题分成四种情况：

-  $l=r$ 时，这个区间只有一个数，无法选出两个数，所以直接输出 $0$ 。

我们知道在 $l$ 足够小的情况下，假设 $l=1$ ， $a$ 与 $b$ 最大的余数肯定是让除数 $b$ 尽可能大，同时 $a$ 也要尽可能大，所以 $a$ 就肯定是 $r$ ，为了使 $b$ 尽可能大， $a$ 要除以一个数，使 $b$ 与它的余数尽可能大，所以那个数必然是 $2$ 。

那我们就可以令 $tmp$ 为 $a\div 2$ 也就是 $r\div 2$ 的结果，然后我们分开判断。

-  $l<tmp$ 时，举个例子， $l=10,r=30,tmp=15$ 那么 $l$ 到 $r$ 之间最大的连个余数便是 $r$ 与 $r\div 2-1$，因为 $30$ 为偶数，如果 $b$ 直接等于 $30\div 2$ 是不行的，因为 $30$ 可以整除 $2$ 所以我们这里要用一个三目运算符输出，判断如果 $r$ 是奇数，可以直接输出 $tmp$ ，否则 $b$ 必须要 $+1$ 因为 $r$ 是偶数，换句话说，输出的是 $tmp-1$ 。

```cpp
 if (l < tmp) {
  cout << (r % 2 ? tmp : tmp - 1) << endl;
 } 
```

- $l=tmp$ 时，举个例子， $l=10,r=20,tmp=10$ 这时， $r$ 是偶数， $r$ 肯定可以整除 $l$ 所以为了让余数变大， $b$ 要等于 $l+1$ ，这样输出就是 $r-(l+1)$ 换个例子， $l=10,r=21,tmp=10$ ， $r$ 为奇数，那么为了要使 $l=tmp$ ，肯定 $l\times 2+1=r$ ，如果我们给 $l$ 加个 $1$ 那余数同时会减个 $1$ ，不会出现 $r$ 能整除 $l+1$ 的情况，所以 $r$ 为奇数时也输出 $r-(l+1)$ 。

```cpp
　else if (l == tmp) {
　　cout << r - (l + 1) << endl;
　}
```

- 否则的话为了让余数最大，肯定是 $a=r,b=l$ 是余数最大，因为 $l>tmp$ 所以 $r$ 无法整除 $l$ ，这时直接输出 $r-l$ 即可。

```cpp
　else {
　　cout << r - l << endl;
　}
```

# 代码

```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
ll t, l, r, tmp;
int main() {
  cin >> t;
  while (t--) {
    cin >> l >> r;
    if (l == r) {
      cout << 0 << endl;
      continue;
    }
    tmp = r / 2;
    if (l < tmp) {
      cout << (r % 2 ? tmp : tmp - 1) << endl;
    } else if (l == tmp) {
      cout << r - (l + 1) << endl;
    } else {
      cout << r - l << endl;
    }
  }
  return 0;
}
```

**祝愿洛谷越办越好 QWQ 。**