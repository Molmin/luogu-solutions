## 题意：

用最少的操作次数，使第 $i$ 个数的值等于 $i$。
## 思路：
肯定有一些石子堆的石子个数过多、有些石子堆的个数过少。  

所以我们按照贪心的思路，移动的每一颗石子都应该是从过多的石子堆移动到过少的石子堆。  

将 $b_i$ 赋值为 $i$，令 $ans$ 加上 $a_i$ 与 $b_i$ 的差的绝对值，即用几次操作可以让 $a_i$ 等于 $i$，由于每次都会多算一次，所以正确答案是 $ans$ 的一半。  

### 注意事项：  
- 减的时候不要忘了取绝对值。
- 循环最好从 $1$ 开始，因为 $i$ 在循环里需要用到。

#### 代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[105],b[105],n,ans;
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
	  	scanf("%d",&a[i]);
	  	b[i]=i;//将 b_i 赋值为 i
	}
	for(int i=1;i<=n;i+=1)
	  	ans+=abs(a[i]-b[i]);//令 ans 加上 a_i 与 b_i 的差的绝对值
	printf("%d\n",ans/2);
	return 0;
}
```
##### ps：AT题文末换行不能少（尽人皆知）