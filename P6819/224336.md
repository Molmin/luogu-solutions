非常妙的一道题目。

### 题目大意

有 $n$ 个盒子，开始时每个盒子中有一个棋子。两个人进行博弈，每次选择两个正整数 $i$，$p$，将 $i$ 号盒子中的一个棋子移到 $2^p\times i$ 号盒子中。若 $2^p\times i$ 号盒子已有棋子，则抛弃这两个棋子。不能移动者输。

求第 $k$ 小的 $n$，使得先手必**败**。

$1 \leq k \leq 10^9$

### 题目分析

为了找到第 $k$ 小的合法的 $n$，我们需要先会判断一个 $n$ 合不合法。

将 $1 \sim n$ 写成二进制的形式，那么乘一个 $2^p$ 相当于在末尾增加 $p$ 个 $0$，当所有数都大于 $n$ 时就输了。

不难发现，只有当两个数 $\text{lowbit}$ 位前面部分相同时，它们才有可能被同时抛弃。举个例子：

- $1001101|000$

- $1001101|00000$

这两个数字在 $\text{lowbit}$ 位的左边都相同，那么在第一个数字后面添加两个 $0$ 时，它们会被同时抹去。

- $11001|0000$

- $10010|000$

这两个数字在 $\text{lowbit}$ 位的左边不同，所以就算在第二个数字后面添加一个 $0$，它们也不会被同时抹去。

于是将 $1 \sim n$ 按照 $\text{lowbit}$ 位的前面部分进行区分，相同的则划分成一个组。

对于同一个组，令其前面相同部分为 $w$，则这些数一定形如 $w \times 2^p$，当 $p_1 < p_2$ 时，$w \times 2^{p_1}$ 号盒子的棋子可以放到 $w \times 2^{p_2}$ 号盒子。将题目反过来，操作改为把 $i\times 2^p$ 号盒子的棋子放到 $i$ 号盒子，此时结果也是一样的。

所以现在从增加 $0$ 变成了删去 $0$，没得删的人输。

发挥你们大脑的想象力，把一个一个 $0$ 看成石子，这就变成了一个没那么经典的取石子游戏：

**每次可以从一堆石子拿走一些石子，不能不拿，如果拿完后同一组有两堆石子个数一样，则把这两堆拿走。**

考虑把后面的强制操作去掉。假如有两堆石子个数一样，但我不拿走，会影响答案吗？

如果先手必胜，那么只有可能后手碰这两堆石子，但后手只要从一堆取了一些石子，先手就可以模仿他在另一堆取同样石子，直到两堆变为 $0$ 或后手不取了，那还是先手必胜。后手同理。

所以现在变为了最简单的取石子游戏，**先手必输当且仅当石子个数异或和为** $0$。

---

继续优化判断方法。对于每一个 $i$，计算 $1 \sim n$ 中有多少个数 $\text{lowbit}$ 后有 $i$ 个 $0$，很容易算出有 $\lfloor \dfrac{n}{2^i}\rfloor-\lfloor \dfrac{n}{2^{i+1}}\rfloor$ 个。

因为要求异或和，所以只跟其奇偶性有关系。将 $n$ 用二进制表示，这个式子的奇偶性其实就是第 $i$ 位等不等于第 $i+1$ 位。等于就是偶数，不等于就是奇数。

设 $n$ 的二进制形式为 $p$，则异或和为 $\oplus_i{[p_i \neq p_{i+1}]i}$。

发现 $k$ 比较大，无法直接枚举判断，所以考虑二分。假设现在二分到 $x$，就要求 $[1,x]$ 有多少个符合条件的 $n$。

现在的 $n$ 的答案只跟其二进制的相邻位有关系，直接对其进行数位 dp。设 $f_{i,j,k,0/1}$ 表示考虑到 $n$ 的第 $i$ 位，其中第 $i$ 位为 $j$，目前异或和为 $k$，是否贴着 $x$ 上界。转移很好转移，就不再赘述。

二分一个 $\log$，数位 dp 两个 $\log$，总复杂度 $O(\log^3n)$，实测 $k$ 取 $10^9$ 时 $n$ 大约为 $7 \times 10^{10}$。

### 代码

```cpp
#include<bits/stdc++.h>
#define ll long long
#define fr(i,x,y) for(register ll i=(x);i<=(y);i++)
#define pfr(i,x,y) for(register ll i=(x);i>=(y);i--)
using namespace std;
ll K,f[66][2][66][2];
ll ck(ll x){
	fr(i,0,60) fr(j,0,1) fr(k,0,63) fr(l,0,1) f[i][j][k][l]=0;
	f[60][0][0][1]=1;
	pfr(i,60,1){
		fr(j,0,1){
			fr(k,0,63){
				fr(l,0,1){
					if(!f[i][j][k][l]) continue;
					if(l==1){
						if((x>>(i-1))&1){
							f[i-1][1][k^((j^1)*(i-1))][1]+=f[i][j][k][l];
							f[i-1][0][k^(j*(i-1))][0]+=f[i][j][k][l];
						}
						else f[i-1][0][k^(j*(i-1))][1]+=f[i][j][k][l];
					}
					else{
						f[i-1][1][k^((j^1)*(i-1))][0]+=f[i][j][k][l];
						f[i-1][0][k^(j*(i-1))][0]+=f[i][j][k][l];
					}
				}
			}
		}
	}
	ll res=0;
	fr(i,0,1) fr(j,0,1) res+=f[0][i][0][j];
	return res-1;
}
int main(){
	scanf("%lld",&K);
	ll l=1,r=(1ll<<60)-1;
	while(l<r){
		ll mid=(l+r)>>1;
		if(ck(mid)<K) l=mid+1;
		else r=mid;
	}
	printf("%lld",l);
} 
```