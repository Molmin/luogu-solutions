一开始是练习广搜时搜到的题，但其实并不是广搜，但出于习惯还是做了QAQ

——————————————————————————

问从起点到终点的路径是否为最短路径。

判断是不是最优的方法：

**1、如果走的位置是刚才走过的，就一定不是最优**

**2、对于一个走到的位置，除过过来的方向，如果其他方向曾经走过，就一定不是最优**

其余情况均为最优

——————————————————————

用一个数组模拟即可

代码有点丑，明白就可以了：

```cpp
#include<bits/stdc++.h>
using namespace std;

bool a[205][205];//定义一个bool类型数组
string f;
int i,x=101,y=101;//初始时必须把起点放在中心
int main()
{
	a[x][y]=1;//起点
	cin>>f;
	for(i=0;i<f.size();i++)
	{
		if(f[i]=='U'){x--;if(a[x][y]==1||a[x-1][y]==1||a[x][y-1]==1||a[x][y+1]==1){cout<<"BUG"<<endl;return 0;}}//向上走
		else if(f[i]=='D'){x++;if(a[x][y]==1||a[x+1][y]==1||a[x][y-1]==1||a[x][y+1]==1){cout<<"BUG"<<endl;return 0;}}//向下走
		else if(f[i]=='L'){y--;if(a[x][y]==1||a[x-1][y]==1||a[x][y-1]==1||a[x+1][y]==1){cout<<"BUG"<<endl;return 0;}}//向左走
		else if(f[i]=='R'){y++;if(a[x][y]==1||a[x-1][y]==1||a[x+1][y]==1||a[x][y+1]==1){cout<<"BUG"<<endl;return 0;}}//向右走
		a[x][y]=1;//把这个点标记一下
	}
	cout<<"OK"<<endl;//如果还顺利的进行到现在，就肯定是最优了
	return 0;
}
```
