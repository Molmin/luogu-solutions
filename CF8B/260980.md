### 前言

吐槽一下这个翻译，什么也没说清楚。。。

题目就是说呢，有一张地图然后呢有一个机器人，他在某个地方，然后他要到达某个地方，给出了他的行进方向，问你他从某个点到某个点的是不是最短路径，L 表示 往左走，R 表示 往右走，U 表示往上走，D 表示往下走，如果是最短路径输出 `OK` 不是输出 `BUG`。

### 分析

这个问题和从哪个点开始没有太大的关系，我们唯一要考虑的就是负数的情况，那么防止负数我们可以把 $x$ 和 $y$ 设成 $101$ 这样就可以防止有负数的情况。

然后再会过来看这个问题，首先我们肯定一点，就是说**如果他走过了这个点然后再回头走这个点肯定不是最优的**。

那么我们继续思考，另外的情况。

也就是，如果**他走到的这个点除他走过来的那个点以外，其它的三个点如果有一个被走过了就证明不是最短路径**，~~就好比是你吃饱了撑的，走过一个附近的点然后旁边是最终的目的地，你还绕一圈走到这个点~~。

所以我们可以总结出来两点判断是否是最短路径。

1. 如果他走过了这个点然后再回头走这个点肯定不是最优的。

2. 他走到的这个点除他走过来的那个点以外，其它的三个点如果有一个被走过了就证明不是最短路径。

然后我们就可以利用这 $2$ 点来做这道题目。

### 代码

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
//头文件不多讲。
using namespace std;
const int INF=205;
int data[INF][INF],x,y,fx[]={0,0,-1,1},fy[]={1,-1,0,0};
string s1;
// data 为标记数组，标记是否走过了这个点，是就是 1 ，不是就是 0，作者比较喜欢用 int 数组。
//x y 为最开始的点。
//fx 和 fy 为方向数组。
//s1 表示 命令的读入。
inline bool check(int x_,int y_)//check 函数返回 true 表示不是最优的，false 就代表是最优的，这里千万千万不要用 x1 和 y1 否则会 CE 的，虽然作者也不知道为什么，总之就是尽量不要用 x1 和 y1。
{
        if (data[x_][y_]) return true;//如果走过了，那么就代表不是最优的。
        int tot=0;//否则我们利用一个 tot 来标记它周围有多少个格子被走过了。
        for (int i=0; i<4; i++)
        {
                int dx=fx[i]+x;
                int dy=fy[i]+y;//dx dy 表示 四个方向。
                if (data[dx][dy]) tot++;//如果走过了，那么就 +1。
        }
        return tot>1;//除走过来的那个格子以外，其它如果有，那么就返回 true。
}
signed main()
{
        x=y=101;//最开始设成 101 这样就不怕负数了，毕竟从哪个点开始都可以。
        cin>>s1;//读入命令串。
        int len=s1.size();//测量长度。
        for (int i=0; i<len; i++) {
                data[x][y]=1;//标记是否走过。
                if (s1[i]=='L') {
                        y--;//往左走那么 y-1。
                        if (check(x,y)) {//判断一下是否是最优的。
                                printf("BUG\n");
                                return 0;//不是那么就输出 BUG 并且 结束。
                        }
                }
                if (s1[i]=='R') {
                        y++;//往右走那么 y+1。
                        if (check(x,y)) {//判断一下是否是最优的。
                                printf("BUG\n");
                                return 0;//不是那么就输出 BUG 并且 结束。
                        }
                }
                if (s1[i]=='D') {
                        x++;//往下走那么 x+1
                        if (check(x,y)) {//判断一下是否是最优的。
                                printf("BUG\n");
                                return 0;//不是那么就输出 BUG 并且 结束。
                        }
                }
                if (s1[i]=='U') {
                        x--;//往上走那么 x-1
                        if (check(x,y)) {//判断一下是否是最优的。
                                printf("BUG\n");
                                return 0;//不是那么就输出 BUG 并且 结束。
                        }
                }
        }
        printf("OK\n");//如果全都是最优的那么就输出 OK ，代表是最短路径。
        return 0;
}

```

### 写在后面的话

我这篇题解如果有错误，那么请在评论区里留言，我将会很感谢反映的人。

谢谢观赏！