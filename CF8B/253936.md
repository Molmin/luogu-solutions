### 前言
本题大意为：  
地图是一个无限的方格区域，每个方格要么是空的，要么包含一个障碍物。众所周知，机器人从不试图碰到障碍物。通过记录机器人的运动，找出是否至少存在一个这样的地图，可以为机器人选择一个起始方格（起始方格应该是空的），这样当机器人从这个方格移动时，它的运动与记录的运动一致（机器人不会碰到任何东西，只沿着空的方格移动），从起点到终点的路径最短。

### 详解
>* 1，即为最短路，先来科普一个知识。假设在一个空图（$n \times m$）内，最短路一定为$n+m$。但是，题目并非空图，就无法使用递推思想。
>* 2，这题无法用递推思想，所以我们可以用类搜索的方法做。定义横纵坐标，走过即标记。
>* 3，行走的过程中，如果遇到标记过的地方，**或是其他地方可以走过来**，就结束程序，输出。

### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[200][200]={0};
int x=100,y=100;
string work(string str){
    a[x][y]=1;
    for(int i=0;i<str.size();i++){
        if(str[i]=='U'){
            x--;
            if(a[x][y]||a[x-1][y]||a[x][y-1]||a[x][y+1])return "BUG";
            a[x][y]=1;
        }
        if(str[i]=='D'){
            x++;
            if(a[x][y]||a[x+1][y]||a[x][y-1]||a[x][y+1])return "BUG";
            a[x][y]=1;
        }
        if(str[i]=='L'){
            y--;
            if(a[x][y]||a[x][y-1]||a[x-1][y]||a[x+1][y])return "BUG";
            a[x][y]=1;
        }
        if(str[i]=='R'){
            y++;
            if(a[x][y]||a[x][y+1]||a[x-1][y]||a[x+1][y])return "BUG";
            a[x][y]=1;
        }
    }
    return "OK";
}
int main(){
    string str;
    cin>>str;
    cout<<work(str);
    return 0;
}
```
### 后记
其实这道题还可以用最短路做，即分析他的行走路线，判断出障碍物的位置，再求解。只提供思路。