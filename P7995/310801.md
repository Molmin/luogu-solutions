身边做这道题的，有许多人都是靠搜索卡过去的。这让我这个用 DP 做的人很不爽......

来说一下我的做法吧：

设 $dp[i][j][l][dis]$ 表示从左上角走到第 $i$ 行第 $j$ 列 ，此时已经拐了 $l$ 个弯，目前方向是 $dis$ ($dis=0:$ 当前朝向向右；$dis=1:$ 当前朝向向下)的不同的路线有几种。 

借鉴经典 DP 题目过河卒的思想，设计转移方程如下：

- 从左上到右下遍历 $(i,j)$，表示第 $i$ 行第 $j$ 列的格子:

 如果 $(i,j)$ 是稻草，不能走，则 $dp[i][j][*][*]$都是零；
	
- 否则将 $l$ 从 $0$ 遍历到 $k$：
    
1.从左面的格子走来：$dp[i][j][l][0]+=dp[i][j-1][l][0]$； 

2.从左面的格子走来，且拐了弯：所以在左面的格子那里需要你面朝下方：$dp[i][j][l][0]+=dp[i][j-1][l-1][1]$；

3.从上面的格子走来：$f[i][j][l][1]+=f[i-1][j][l][1]$；

4.从上面的格子走来，且拐了弯：所以在上面的格子那里需要你面朝右方：$dp[i][j][l][1]+=dp[i-1][j][l-1][0]$；

#### 一些特判：

1. 当 $l$ 等于 $0$ 时，$l-1$ 会导致奇怪的溢出，所以需要特判。

2. 由于初始的方向是不确定的，所以初始化时 $dp[1][1][0][0]$ 和 $dp[1][1][0][1]$ 都等于 $1$。

3. $dp[1][2][0][0]=dp[2][1][0][1]=1$。

为什么要加上第3条？因为如果将这两个格子连同其他的格子一起转移时，会分别将 $dp[1][1][0][1]$ 和 $dp[1][1][0][0]$ 转移到 $dp[1][2][1][0]$ 和 $dp[2][1][1][1]$,也就是说，你开始面向右方，但是你决定向下拐走下面那个格子，使用了一次拐弯的机会，导致出现奇怪的错误。当然，在特判时需要判断这两个格子上有没有稻草。

~~p.s 我也不知道上面那段话有没有讲清楚......而且貌似加上第3条后，第2条就没有存在的必要了？~~

最后需要输出的答案便是：

$$\sum^k_{l=0} {dp[n][n][l][0]+dp[n][n][l][1]}$$

#### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll N=55;
ll a[N][N],f[N][N][4][2],n,k,ans,t;
char c[N];
ll st(ll x){//start的意思，判断第x行应该从第几列开始
	if(x==1)	return 3;
	if(x==2)	return 2;
	return 1;
}
void init(){
	memset(f,0,sizeof(f));
	memset(a,0,sizeof(a));
	n=k=ans=0;
}
signed main(){
	scanf("%lld",&t);
	while(t--){
		init();
		scanf("%lld %lld",&n,&k);
		for(int i=1;i<=n;i++){
			scanf("%s",c);
			for(int j=0;j<n;j++){
				if(c[j]=='.')	a[i][j+1]=0;
				else a[i][j+1]=1;
			}
		}
		f[1][1][0][0]=f[1][1][0][1]=1;//没错，这一行应该可以删掉（吧
		if(a[1][2]==0){
			f[1][2][0][0]=1;
		} 
		if(a[2][1]==0){
			f[2][1][0][1]=1;
		}
		for(int i=1;i<=n;i++){
			for(int j=st(i);j<=n;j++){
				if(a[i][j]==1)	continue;
				f[i][j][0][0]+=f[i][j-1][0][0];
				f[i][j][0][1]+=f[i-1][j][0][1];
				for(int l=1;l<=3;l++){
					f[i][j][l][0]+=f[i][j-1][l][0];
					f[i][j][l][1]+=f[i-1][j][l][1];
					f[i][j][l][0]+=f[i][j-1][l-1][1];
					f[i][j][l][1]+=f[i-1][j][l-1][0];
				}
			}
		}
		for(int i=0;i<=k;i++){//貌似从1开始遍历也可以？不过没关系啦
			ans+=f[n][n][i][0]+f[n][n][i][1];
		}
		printf("%lld\n",ans);
	}
	return 0;
}

```

本算法时间复杂度为 $O(Tn^2k)$，暴打爆搜！