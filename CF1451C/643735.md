## 题意

给两个字符串 $a,b$，与一个数 $k$，每次可以进行两个操作：

- 交换 $a$ 中的任意两个字符。

- 选中 $i$，如果 $a_i=a_{i+1}=...=a_{i+k-1}$ 则将这段区间内的字符全部 $+1$。

求**能否**将 $a$ 变成 $b$。

## 思路

由于 1 操作的存在，$a$ 序列的排列与答案无关。

那么问题就来到了如何使用 2 操作。

我们可以对 $a,b$ 根据字符排序，再用两个数组 $c1,c2$ 记录 $a,b$ 序列中每个字符出现的次数，再将相同的字符尽量配对。

排序后枚举每个字符 $i$：

1. $c1_i\geq c2_i$。

此时我们将 $a$ 序列与 $b$ 序列配对完后，又出现了两种情况：

- $c1_i-c2_i \bmod k>0$。

说明这几个剩下的字符无法被一次 2 操作处理完。

很显然，它们永远也不会被处理完，所以无解。

反之，则可以继续进行操作。

2. $c1_i<c2_i$。

那么 $b$ 序列反而会多几个字符。

由于我们的字符是从前往后枚举，所以之后便不会处理到字符 $i$ 了，$b$ 序列多的几个字符也不会被处理了。

所以也判断无解。

其实在实现的过程中，我们不需要真的对字符串排序，因为我们从小到大枚举字符，就已经实现了类似于桶排序的有序化处理。

## 正确代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int c1[501],c2[501];
int t,n,m,i,k;
char a[1000001],b[1000001];
int main()
{
	scanf("%d",&t);
	while(t--)
	{
		scanf("%d%d",&n,&m);
		scanf("%s%s",a,b);
		memset(c1,0,sizeof(c1));
		memset(c2,0,sizeof(c2));
		for(i=0;i<n;i++) c1[a[i]-'a']++,c2[b[i]-'a']++;//桶
		for(i=0;i<26;i++)
		{
			if(c1[i]<c2[i])break;
			k=c1[i]-c2[i];
			if(k%m)break;
			c1[i+1]+=k;//这一步相当于是把a配对后剩下的字符用几次2操作变成下一个字符，放到下一个字符去讨论
		}
		if(i>25)puts("Yes");
		else puts("No");
	}
	return 0;
}
```
