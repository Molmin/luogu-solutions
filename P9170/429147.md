## 题意

Alice 和 Bob 各有 $n$ 个集合，值域 $m$，两人各从每个集合里选一个数组成两个长为 $n$ 的序列 $a_{1\dots n}$，$b_{1\dots n}$。

Alice 先选，Bob**看到 Alice 选的数**后再选。记 $X=\sum[a_i=b_i]$，Alice 希望最大化 $X$，Bob 希望在保证 $b$ 中元素**互不相同**的前提下最小化 $X$，两人都聪明绝顶，求最终的 $X$。

**集合大小不超过** $2$，多测，$\sum n,\sum m\leq 1.5\times 10^6$。Bob 无法保证 $b$ 互不相同时输出`-1`。

## 思路

几乎是考场想法。

由于集合大小不超过 $2$，所以可以转化为从两个数中选一个。在第 $i$ 个位置上，设 Alice 能选的两个数分别为 $s_{i,0/1}$，Bob 能选的两个数分别为 $t_{i,0/1}$。

首先手玩一下，发现 Bob 的选数方案一般远小于 Alice 的，~~并且 Bob 的主观能动性大一些~~，所以从 Bob 的选数方案入手。

由于第 $i$ 个数要选 $t_{i,0}$ 或 $t_{i,1}$ 中的一个，我们可以把 $t_{i,0}$，$t_{i,1}$ 之间连一条边（不忽略自环），然后 Bob 要做的就是将每条边定向，使得每个点入度最多为 $1$； Alice 的决策相当于在每一条边上写 $s_{i,0/1}$；如果一条边指向的数和边上面的数相等，那么对 $X$ 有 $1$ 的贡献。

如果一个连通块内的边数大于点数，那么 Bob 无论如何都无法满足要求，输出`-1`，否则这个连通块要么是颗树，要么是个基环树。容易发现每个连通块独立，所以我们把每个连通块分开考虑。

在分类讨论之前，先考虑一下 Alice 的决策。如果 Bob 定向后一条边指向的点等于 Alice 在上面写的数，那么对 $X$ 有 $1$ 的贡献。显然，Alice 只想写 $t_{i,0/1}$，不然不可能有用。那么，边可以分为三类：$t_{i,0/1}$ Alice 都可以选（称为 1 类边）；$t_{i,0/1}$ 中 Alice 只能选一个（称为 2 类边）；都不能选（称为 3 类边）。

### 基环树

这种情况相对容易，因为定向后环部分一定是个有向环，剩下的部分是外向树。外向树的部分 Bob 的决策唯一，可以提前贪心处理。

现在只剩环上的点了。Bob 有两种方式来将环定向，对应两种决策。Alice 的目标是最大化两种选法中的 $X$ 最小值。

随便将某个方向定为正向，那么 2 类边会对正向或逆向中的一个方向造成贡献。为了用 1 类边最大化最小值，Alice 应该让两个方向的贡献尽可能平均。这个可以简单计算。

### 树

这种情况中 Bob 不再只有很少种决策。Bob 可以选择一个点，并以它为根，将边定向为外向树。记 Bob 选 $i$ 为根时 $X=c_i$，则 Alice 可以改变 $c$，目标是最大化 $\min c_i$ 。

先随便定一个根，并在边端点中深度较深的点处计算贡献，钦定 $dep_{t_{i,0}}<dep_{t_{i,1}}$，考虑 Alice 的决策对 $c$ 的影响：

- 3 类边是废物；
- 2 类边对子树内（$s_{i,0/1}=t_{i,0}$）或外（$s_{i,0/1}=t_{i,1}$）的点有 $1$ 的贡献；
- 1 类边可以自由选择对子树内还是子树外产生 $1$ 的贡献。

提前把 2 类边对树上每个点对 $c$ 的贡献算出来，先预设所有的 1 类边都选择对子树外贡献。称 $\;$ _把 1 类边从选择贡献子树外变为选择贡献子树内_ $\;$ 为在儿子处的操作。重复以下过程：

- 找到最小值的位置，设之为 $x$（线段树）；
- 用 $c_x$ 更新答案；
- 找到 $x$ 的祖先（包括 $x$）中可操作的中深度最浅的点并操作（下面说）。
- 如果 $x$ 祖先（包括 $x$）中没有可以操作的，结束。

倒数第二步可以重复以下操作：

- 向上找到最浅的没有试图操作过的点（倍增）；
- 如果 $x$ 及 $x$ 上面没有未被操作的点，结束；
- 试图操作它；
- 如果它成功被操作，结束。

这样贪心为什么是对的呢？首先，Bob 会选贡献最小的点，所以用最小值更新答案是对的~~（废话）~~；然后，要让答案可能增加，必须让 $c_x$ 变大，必须选择一个 $x$ 的祖先来操作；同时，被尝试操作的点的所有祖先都一定被尝试操作过，所以倍增是对的；最后，操作深度较浅的点比操作深度较深的点更优。

每个点最多被尝试操作一次，每次尝试都要一次线段树查询，若干次线段树修改（可能要），一次倍增，所以复杂度也是对的。

### 总结

将基环树和树的答案都分别算出来后，就可以把它们的答案简单地加起来得到答案。

时间复杂度：$\mathrm O(\sum n\log n)$（默认 $n,m$ 同阶）。

### 注意事项

都是[我错过的](https://www.luogu.com.cn/paste/r3xrxb0t)。

- 由于要拆开计算，编号可能会很乱（树上要拍成dfn序，基环树上要找环）；
- 小心自环和二元环；
- 小心一个点的树；
- 各种各样的初始化，注意 $T\leq 1.5\times 10^6$（各种各样）；
- 倍增不要只跳 $18$ 步；
- 点数最多是 $\min(2n,m)$ 的；

## 代码

有点长，放在[这里](https://www.luogu.com.cn/paste/e3fobh85)了。