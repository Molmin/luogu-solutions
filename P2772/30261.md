楼下几位巨佬几乎都是用单调队列，在此给出一个不使用任何数据结构的写法。

首先给出如下定理：

**对于任意一个点，如果它的y值不小于任何一个点使这个“任何一个点”x值大于给定点的x值，那么该点为极大点。**

第一反应：看不懂

第二反应：这不就是极大点的定义么

好，我们改一下说法：

**对于任意一个点，如果y值比它大的点全部都在它的左边，那么该点为极大点。**

第一反应：这回能看懂了

第二反应：这不还是极大点的定义么

不急，一步步慢慢推导。我们迎来了wx定理的最终版本：

**对于任意一个点，如果它的y值比它右边（包括这一列）的点都要大，那么该点为极大点。**

呃呃，这不还是定义！

但是我们可以用它来解题了。

首先，我们按照x值从小到大排序。接下来，我们从右往左扫一遍，并维护最大y值，当当前y大于已知最大y值时加入答案并更新最大y，否则无视。最后，我们将加入的点倒序输出即可。

这份算法，可以得90分。（我就被坑了）

为什么？重新来看定理：

对于任意一个点，如果它的y值比它右边**（包括这一列）**的点都要大，那么该点为极大点。

是的，判定条件包括这一列！

所以我们要在排序时，当x相等时比较y。这样，才能AC。

最后献上简短但丑陋的代码：

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
using namespace std;
struct point{
    int x,y;
    bool operator <(point b)const{
        return (this->x<b.x)||((this->x==b.x) && (this->y<b.y));
    }
}p[500001];
int n,imax=-1,a[500001],top;
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++)scanf("%d%d",&p[i].x,&p[i].y);
    sort(p+1,p+n+1);
    for(int i=n;i>=1;i--)
    {
        if(p[i].y>imax){
            a[++top]=i;
            imax=p[i].y;
        }
    }
    for(int i=top;i>=1;i--){
        printf("(%d,%d)",p[a[i]].x,p[a[i]].y);
        if(i>1)printf(",");
    }
    return 0;
}
```