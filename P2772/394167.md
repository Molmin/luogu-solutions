### 题目  
寻找极大点。  
### 想法
贪心先按  $x$  轴从大到小排序，同时  $y$  轴从大到小排序（为了之后方便比较），这样可以方便判断  $y$  轴的压制性（即保证当  $x_1>x_2$  时，  $y_1<y_2$  ）。  
对于同一  $x$  轴上的点，他们的极大点就是  $y$  值最大的那个点，而这个点是不是真·极大点，则要判断是否高于压制点（  $y$  轴目前最高点），是则是极大点之一，同时更新压制点为那个点的  $y$  值。  
那么压制点的初值是多少呢？自然是  $x$  值最大时  $y$  至最大的点，因为此时他在  $x$  轴上已经是巅峰，所以不受其他任何的约束，而其他点由于收到  $x$  轴的约束，所以只能在  $y$  轴上崭露头角。
那么这一部分的写法如下：
```cpp
	//f[],k,t[],cnt均为int类合法数组，其中f[]存储极大点编号，k存储压制点，t[]存储每个点，cnt记录极大点个数
	f[++cnt]=1;k=t[1].p;//极大点++，存储压制点（初始化）
	for(int i=2;i<=n;++i)
		if(t[i-1].q>t[i].q)//x值产生变化时
			if(t[i].p>k)//判断是否压制
				f[++cnt]=i,k=t[i].p;//不压制则更换
```
既然刚刚是倒着存储的，那么也就要倒着输出：
```cpp
	for(int i=cnt;i-1;--i)//"i-1"等同于"i!=1"，为了不多输出","，所以提前结束
		printf("(%d,%d),",t[f[i]].q,t[f[i]].p);
	printf("(%d,%d)\n",t[f[1]].q,t[f[1]].p);
```
就讲这么多，再见！