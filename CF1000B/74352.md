#### 1 题目描述（[传送门](https://www.luogu.com.cn/problem/CF1000B)）

#### 2 解题思路

题目通俗一点理解就是有一条 $0\sim M$ 的线段，用 $n$ 个点分成 $n+1$ 条线段。从左到右编号，取其中所有编号为奇数的线段长度。操作就是插入一个点使后面线段的奇偶性改变。

考虑插入一个点，会将一个线段分成两部分，取其中一部分。那么，一定是将线段分为 $1$ 和 $a_i-1$ ，然后取 $a_i-1$ 的收益最大。

因此，我们的思路就是，枚举每一段线段，取该线段前的所有编号为奇数的线段，该线段后的所有编号为偶数的线段，和该线段的长度减一，三者加和。最后取所有枚举出的和的最大值（注意还可以不插点）。

可以用前缀和维护奇数线段和和偶数线段和， $O(1)$ 调用即可。

#### 3 解题代码

```cpp
#include <iostream>
using namespace std;
int n,m;
int a[100100],len[100100];
int ans=0;
int sum1[100100],sum2[100100];
//sum1[i]表示线段i前所有编号为奇数的线段的长度和，sum2[i]表示线段i前所有编号为偶数的线段的长度和
int main()
{
    scanf("%d%d",&n,&m);
    a[0]=0;a[n+1]=m;
    for(int i=1;i<=n;i++)scanf("%d",&a[i]);
    for(int i=1;i<=n+1;i++)
    {
        len[i]=a[i]-a[i-1];
        if(i%2)
        {
            ans+=len[i];
            sum1[i]=sum1[i-1]+len[i];
            sum2[i]=sum2[i-1];
        }
        else
        {
            sum1[i]=sum1[i-1];
            sum2[i]=sum2[i-1]+len[i];
        }
    }
    for(int i=1;i<=n+1;i++)
        ans=max(ans,sum1[i-1]+len[i]-1+sum2[n+1]-sum2[i]);
    printf("%d\n",ans);
    return 0;
}
```

#### 4 解题心得

本题最开始理解错题意，导致毫无头绪。先去做了后面的中文题再回来阅读，豁然开朗。

前缀和维护/差分维护可以 $O(1)$ 查询/修改，还是很有用的优化方法。