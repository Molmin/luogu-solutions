楼下的两位大佬都十分的强，但是我认为蒟蒻们~~比如我~~，看不懂这么深奥的代码。接下来，我来详细讲讲方法：

学过小奥的大佬们应该都知道概率这个板块吧：

**我们先以两个骰子为例：计算构成每个和的方案数**


2=1+1 2种

3=1+2=2+1 3种

4=1+3=2+2=3+1 4种

5=1+4=2+3=3+2=4+1 5种

6=1+5=2+4=3+3=4+2=5+1 6种

7=1+6=2+5=3+4=4+3=5+2=6+1 7种

8=2+6=3+5=4+4=5+3=6+2 6种

9=3+6=4+5=5+4=6+3 5种

...

不难看出从7开始，方案数开始下降。

∴7是可能性最大的。

而能构成最小的和为1×2=2，最大的和为2×6=12，2和12的平均数为7。

**再看看3，不难发现可能性最大的是10和11**

而10和11正好是平均数两边的整数。

∵要输出小的那个。

∴总结出来答案表达式为：

```cpp
int((n*1+n*6)/2)
```

**你如果高高兴兴的去直接输出，你一定会~~惊喜的~~发现有WA的**

原因：如果n是1，则所有1到6的点数可能性相同，所以特判输出1。（而程序确输出了3）

大家听累了吧，看看代码然后自己AC吧：
```cpp
#include<cstdio>
#include<cmath>
using namespace std;
int n;
int main(){
	scanf("%d",&n);
	if(n==1) printf("1\n");
	else
	{
		int ans=(n*1+n*6)/2;
		printf("%d\n",ans);
	}
	return 0;
}
```

第一次写这么精细的题解，非常不易。

望管理员通个过，大佬们点个赞~。