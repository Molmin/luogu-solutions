题意要求树上两条路径所表示的字符串的 LCP，有一个很 basic 的做法就是维护链上的字符串哈希值，优点在于支持 link/cut，链字符加或赋值等操作，时间复杂度为 $q\log_2^2n$，其实很优秀，然而缺点在于容易被卡，常数大，当然可以选择多哈希，但有一种更好的 $O(q\log_2n)$ 的做法。

考虑将树重链剖分，将两条路径表示成路径区间并配对（使所有区间一一对应），这样能将它们分成 $O(\log_2n)$ 段在重剖序中的区间（注意有可能是反重剖序，所以预处理需要同时记重剖序的正串反串）。

于是问题变成了：给定一个字符串，求其两个后缀的 LCP。

我们发现 SAM 是维护后缀的，更适合求最长公共后缀，所以需要将字符串反过来求两个前缀的最长公共后缀。

考虑 parent 树中，一个节点的父亲是它的最长真后缀，所以两个节点的 lca 就是它们的最长真后缀，可以打 ST 表 $O(1)$ 求。

接下来就是平凡的了，如果上一段的 LCP 等于长度，就继续算下一段，否则就停止，时间 $O(n(|\sum|+\log_2n)+q\log_2n)$，空间 $O(n(|\sum|+\log_2n))$，实测 ST 表会被卡空间，所以要用线段树求最值，当然也可以离线下来 tarjan（似乎会变麻烦？），反正就是用时间还空间，然而因为 zkw 线段树常数太小了，所以并不会被卡常。

[CF 上的 AC 记录](https://codeforces.com/contest/504/submission/191650086)