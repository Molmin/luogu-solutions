> [P3583 [POI2015]KWA](https://www.luogu.com.cn/problem/P3583)
>
> [POI 合集](https://www.cnblogs.com/alex-wei/p/POI.html)。

打表猜结论题。首先这道题目长得就一脸可以打表的样子，所以我们先通过 DP 求得一点小数据的 $w$ 值。

输出到 $10^4$，发现一个比较明显的分割点在 $9455$ 这个地方：因为 $9455=S(30)=\sum_{i=1}^{30}i^2$ 所以它是最后一个 $w$ 值为 $30$ 的数，显然若 $i>9455$ 则 $w(i)>30$。这给予我们第一个思想：当 $i$ 很大的时候，$j^2\ (j\leq i)$ 的组合能够生成的数覆盖了**几乎所有** $S(i-1)\sim S(i)$ 之间的数，以及当 $n>S(i)$ 时，必然有 $w(n)>i$。

但再观察表，发现在 $9455$ 的前面有一些 “超重” 数，它们的 $w$ 值为 $31$。乍一看似乎没啥规律，不过仔细思考后可以发现，这些超重数 $p$ 与 $9455$ 之间的差 $q\ (q=9455-p)$，应该就是所有 $w(q)=\infty$ 的 $q$。毕竟 $p$ 应该由 $1\sim i$ 的平方之和减掉一些数的平方得到，但如果它们的差（$n-p$）即要减去的数不能由若干个不同的完全平方数之和得到，那么 $p$ 也不能由 $S(i)$ 减去一些不同的完全平方数得到，这说明 $w(p)$ 不得不大于 $i$。

接下来我们证明在 $p$ 足够大的时候，一定有 $w(p)=i+1$，其中 $i$ 为使得 $S(i)\geq p$ 的最小的 $i$ 且 **$S(i)-p$ 不能由若干完全平方之和表示**：设 $q=S(i+1)-p$，由于不能被若干完全平方之和表示的数有限（共有 $31$ 个且最大值为 $128$），所以 $p\to \infty$ 时 $q\gg 128$，因此 $w(q)\neq \infty$，这说明 $p$ 可以由 $S(i+1)$ 减去若干完全平方数得到，故 $w(p)=i+1$。

综上，我们有如下算法：首先暴力求出 $n$ 比较小时的 $w(n)$（大概到 $10^3$ 级别就够了，设范围为 $[1,x]$），若给定的 $n$ 属于 “比较小”，即 $n\leq x$，直接输出答案。否则**二分**求出最小的 $i$ 使得 $S(i)\geq n$，那么第一问的答案即 $i+[\mathrm{exist}\ j,\ w(j)=\infty\land n+j=S(i)]$，第二问的答案可以由 $n$ 较小时的超重数之和，加上从 $x+1$ 到 $n$ 之间所有超重数得到。

因为对于固定的 $j$，所有 $w(p)=j$ 的 $p$ 中有 $31$ 个超重数（可表示为 $S(j-1)-q$，其中 $w(q)=\infty$），所以令 $l$ 为 $S(l)\leq x$ 的最大的 $l$（注意这个分割点 $x$ 不应该取到比较靠近形如 $S(i)-d$ 其中 $d$ 是一个很小的数的位置，因为这样会把 $w(p)=l$ 的超重数 $p$ 分割成 $\leq x$ 和 $>x$ 两部分，无法直接用 $31$ 乘以 $j$ 的个数计算），答案加上 $31\times (i-1-l)$，再枚举 $w(q)=\infty$ 的 $q$，若 $S(i)-q\leq n$ 说明 $S(i)-q$ 这一超重数的贡献也要算上，答案加 $1$。

除去预处理的常数复杂度，时间复杂度为二分求 $i$ 的 $\log n$。代码预处理到了 $10^4$，此时 $l=30$ 所以上式可改写为 $31\times (i-31)$。

```cpp
const int N = 1e4 + 5;
int f[N], mnf[N], w[N];
ll n;
int main() {
	mem(f, 0x3f, N), f[0] = 0, mnf[N - 4] = N;
	for(int i = 1, sum = 0; i <= 31; i++, sum += i * i)
		for(int j = min(N - 1, sum); ~j; j--)
			if(f[j] < N) cmin(f[j + i * i], i);
	for(int i = N - 5; i; i--) mnf[i] = min(mnf[i + 1], f[i]), w[i] = f[i] > mnf[i];
	for(int i = 1; i < N - 4; i++) w[i] += w[i - 1];
	cin >> n;
	if(n < N - 4) {
		if(f[n] > N) cout << "- " << w[n] << endl;
		else cout << f[n] << " " << w[n] << endl; exit(0);
	}
	ll l = 30, r = 1.5e6;
	while(l < r) {
		ll m = (l + r >> 1) + 1;
		ll sum = m * (m + 1) * (2 * m + 1) / 6;
		if(sum < n) l = m;
		else r = m - 1;
	}
	int ans = w[N - 5] + (l - 30) * 31;
	ll val = (l + 1) * (l + 2) * (2 * l + 3) / 6;
	for(int i = 1; i <= 1 << 7; i++)
		if(f[i] > N) {
			ans += val - i <= n;
			if(val - i == n) r++;
		}
	cout << r + 1 << " " << ans << endl;
	return cerr << "Time : " << clock() << " ms" << endl, flush(), 0;
}
```