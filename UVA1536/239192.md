# 题意

给定 $N$ 枚硬币，其中 1 枚为假币，真币重量都一样，假币与真币重量不同，**已知一枚真币的重量**。称 $k$ 次能否找到那枚假币？

$ \large{ \text{注：已知一枚真币的重量} } $

# 思路
对于两枚硬币，我们可以直接知道哪一枚是硬币（因为另一枚硬币一直知道是真的了）

## 定理
**那么假设有 $a$ 枚硬币，已经知道称 $b$ 次。则称 $b+1$ 次，最多有 $a \times 3 - 3$ 枚。**

## 证明
我们已经知道**减治法**的称量方法，所以我们会分为 4 堆，$x$，$x$，$x$，$m (m \in \{ 0, 1, 2\})$。
设为 $A$，$B$，$C$，$D$。

### 若下一次有 $a \times 3 - 3$ 枚
一共分为三堆，$a-1$，$\color{red}a-1$，$a-1$。我们将**已知真币的所在堆标为红色**。

先称量 $A$、$B$，若平衡，则位于 $C$ 堆，将真币放入 $C$ 堆，此时问题变为 **$a$ 枚硬币（一枚已知），称 $b$ 次**

### 若下一次有 $a \times 3 - 2$ 枚
一共分为三堆，$a-1$，$\color{red}a-1$，$a$。

先称量 $A$、$B$，若平衡，则位于 $C$ 堆，将真币放入 $C$ 堆，此时问题变为 **$a+1$ 枚硬币（一枚已知），称 $b$ 次**，可知无法称量。

**所以最大数量为 $a \times 3 - 3$ 枚**

最后我们去推算一下称 $k$ 次最多可以验证多少硬币

# Code
```cpp
#include<bits/stdc++.h>
using namespace std;
void work()
{
    int n,k;
    int a=2;

    cin>>n>>k;
    
    for(int i=1; i<=k&&a<=100; i++)
    a=a*3-3;

    if(n<=a)
    printf("POSSIBLE\n");
    else
    printf("IMPOSSIBLE\n");
}
int main()
{
    int t;
    cin>>t;
    while(t-->0)
    work();
    return 0;
}
```