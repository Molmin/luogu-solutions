[$\color{blue}{\text {pwp }~{\to\textbf{My blog}\gets}}~\text{qwq}$](https://www.luogu.com.cn/blog/390770/blogcenter)

## 题解 SP15637

一道 DP。

### 1.状态

什么可以影响接下来的决策呢？可以列举出几点：**每行元素数、行数、每行末尾元素、每列末尾元素**。但是，肯定不可能有这么多状态。

解决方法是：使用**每行元素数**作为 DP 数组的下标，**行数**最多只有 $5$ 行，所以 DP 数组设 $5$ 维（$k<5$ 时增加人数为 $0$ 的行，变成 $k=5$ 的情况）。从身高**高到低考虑每个人的站位**，就不用记录每行末尾元素和每列末尾元素。

所以最后的状态为：$f(a_1,a_2,a_3,a_4,a_5)$ 表示每行分别站 $a_1,a_2,a_3,a_4,a_5$ 个人的时候的方案数。

### 2.转移

考虑一个人进入合影队形时有哪些情况可以影响他的站位，因为已经从高到低考虑了，所依不用考虑身高的问题，只用考虑是否有位置。

所以转移为：依次从后往前考虑每一行，当第 $i$ 行人数少于 $N_i$ 时且第 $i$ 行人数少于第 $i-1$ 行人数时（可以将第 $0$ 行人数设正无穷），可以进行转移。

### 3.方程

- 边界：$f(0,0,0,0,0)=1$
- 转移：若 $a_i<N_i$ 且 $a_i<a_{i-1}$ 时，令 $f(a_1+1,a_2,a_3,a_4,a_5)=f(a_1+1,a_2,a_3,a_4,a_5)+f(a_1,a_2,a_3,a_4,a_5)$

- 答案：$f(N_1,N_2,N_3,N_4,N_5)$

## 代码

```cpp
//SP15637
#include <bits/stdc++.h>
using namespace std;
long long dp[31][31][31][31][31];
int n[6],k,a[6];

int main(){
	while(scanf("%d",&k) && k){
		memset(n,0,sizeof(n)),a[0]=0x3f3f3f3f,memset(dp,0,sizeof(dp)),dp[0][0][0][0][0]=1;
		for(int i=1; i<=k; ++i) scanf("%d",&n[i]);
		#define F(i) for(a[i]=0; a[i]<=n[i]; ++a[i])
		F(1) F(2) F(3) F(4) F(5){
			if(a[1]<n[1] && a[1]<a[0]) dp[a[1]+1][a[2]][a[3]][a[4]][a[5]]+=dp[a[1]][a[2]][a[3]][a[4]][a[5]];
			if(a[2]<n[2] && a[2]<a[1]) dp[a[1]][a[2]+1][a[3]][a[4]][a[5]]+=dp[a[1]][a[2]][a[3]][a[4]][a[5]];
			if(a[3]<n[3] && a[3]<a[2]) dp[a[1]][a[2]][a[3]+1][a[4]][a[5]]+=dp[a[1]][a[2]][a[3]][a[4]][a[5]];
			if(a[4]<n[4] && a[4]<a[3]) dp[a[1]][a[2]][a[3]][a[4]+1][a[5]]+=dp[a[1]][a[2]][a[3]][a[4]][a[5]];
			if(a[5]<n[5] && a[5]<a[4]) dp[a[1]][a[2]][a[3]][a[4]][a[5]+1]+=dp[a[1]][a[2]][a[3]][a[4]][a[5]];
		}
		printf("%lld\n",dp[n[1]][n[2]][n[3]][n[4]][n[5]]); 
	}
	return 0;
} 
```
