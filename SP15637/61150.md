看到网上很多人说《算法竞赛进阶指南》上的方法不行，会MLE  
那动态开空间不就是了……  
在合法的方案中，每一行，每一列都是单调的，也就是说我们要确保每一次放的时候，放的人要小于左边的，上面的。  
其实这也很好办，假设我们放的人的高度是递减的，第一行我们只要放得去，就能满足单调，而下面几行，只要各自人数小于等于上面一行的人数就OK了。  
让我们来看看这一题的“动态规划信息表”

|信息|表示方式|解释|
|:-:|:-:|:-:|
|状态|$F_{a_1,a_2,a_3,a_4,a_5}$|表示各排从左端起，分别占了$a_1,a_2,a_3,a_4,a_5$个人时，合影方案数量|
|边界|$F_{0,0,0,0,0}=1$|其余为0|
|目标|$F_{N_1,N_2,N_3,N_4,N_5}$|无|
|转移|无|若$a_1<N_1$,则令$F_{a_1+1,a_2,a_3,a_4,a_5}+=F_{a_1,a_2,a_3,a_4,a_5}$。若$a_2<N_2\&\&a_1>a_2$则令$F_{a_1,a_2+1,a_3,a_4,a_5}+=F_{a_1,a_2,a_3,a_4,a_5}$  第3~5同理|

至于杨氏矩阵和钩长公式，还请大家自行了解。  
欢迎来我[博客](https://bubbleioa.github.io/2018/08/26/[SP15637][POJ2279]GNYR04H%20-%20Mr%20Youngs%20Picture%20Permutations/)玩！
## 代码
```c++
#include<cstdio>
#include<cstring>
using namespace std;
int k,a[6],n[6];

int main(){
    while(scanf("%d",&k)){
    	if(k==0)break;
        memset(n,0,sizeof(n));
        for(int i=1;i<=k;i++) scanf("%d",&n[i]);
        int f[n[1]+1][n[2]+1][n[3]+1][n[4]+1][n[5]+1];
        memset(f,0,sizeof(f));
        f[0][0][0][0][0]=1;
        for(a[1]=0;a[1]<=n[1];a[1]++)
        	for(a[2]=0;a[2]<=n[2];a[2]++)
          		for(a[3]=0;a[3]<=n[3];a[3]++)
           			for(a[4]=0;a[4]<=n[4];a[4]++)
            			for(a[5]=0;a[5]<=n[5];a[5]++){
            				int t=f[a[1]][a[2]][a[3]][a[4]][a[5]];
                            if(a[1]<n[1]) f[a[1]+1][a[2]][a[3]][a[4]][a[5]]+=t;
                            if(a[2]<n[2]&&a[1]>a[2]) f[a[1]][a[2]+1][a[3]][a[4]][a[5]]+=t;
                            if(a[3]<n[3]&&a[2]>a[3]) f[a[1]][a[2]][a[3]+1][a[4]][a[5]]+=t;
                            if(a[4]<n[4]&&a[3]>a[4]) f[a[1]][a[2]][a[3]][a[4]+1][a[5]]+=t;
                            if(a[5]<n[5]&&a[4]>a[5]) f[a[1]][a[2]][a[3]][a[4]][a[5]+1]+=t;
        				}
        printf("%d\n",f[n[1]][n[2]][n[3]][n[4]][n[5]]);
    }
    return 0;
}

```