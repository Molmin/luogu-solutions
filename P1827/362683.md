这是一道经典的二叉树题目，与P1030非常相似，不同点在于，一个是通过先序中序求后序，一个是通过中序后序求先序，还有一个不同点，就是P1030的题解满了，所以我只能写这一题的......

但是这一题也确实是比P1030简单，毕竟已经知道先序，就能把二叉数存储惹。

（送给蒟蒻们）

二叉树：一个节点最多有两个子树。

先序：根在前，左在中（左中跟在前，左在中，右在后），右在后（同左）。

中序：左在前（左中左在前，根在中。。。），根在中，右在后。

后序：左在前（...），右在中（。。。），根在后。

是不是看到了递归的影子，和回溯法一样，我们只需要打出一个模板，让后无线套，最后直接给主函数用，至于树，用结构体或三个变量就能储存。

程序呈上：
```
#include<bits/stdc++.h>
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstdlib>//原谅我这画蛇添足地猫病
using namespace std;
char tr[100001]={};//存储树要用字符型。
int a[201]={};
int n=0;//计数器。
string s1,s2;//输入的两个字符串。
void dfs(int l,int r,int l1,int r1){//****我没用****结构体，所以参数多了些。
     if (l==r) {tr[++n]=s1[l];return;}//熟悉的递归套路。
     for (int i=l;i<=r;i++)
       if (s1[i]==s2[l1]){
	       dfs(l,i-1,l1+1,l1+i-l);
		   dfs(i+1,r,l1+i-l+1,r1);
		   tr[++n]=s1[i];
		   break;
	   }
}
int main(){
    cin>>s1>>s2;
    for (int i=s1.size();i>=1;i--) s1[i]=s1[i-1],s2[i]=s2[i-1];
    dfs(1,s1.size(),1,s2.size());//直接套用后，无
    for (int i=1;i<=n;i++) cout<<tr[i];
    return 0;
}

```
有基础的选手除了想要发题解的还是别看这类题目的题解，毕竟对你们来说，如果能自己做出来，普及组肯定没问题，提高组也有望rp++。