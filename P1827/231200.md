#### 此题与P1030求先序遍历类似，可以依照此题方法来写。

[传送门](https://www.luogu.com.cn/problem/P1030)在这里，写完这题可以去练练这个，学习效率<<=1。

# 正题：


### 1 · 分析：

以样例为例：

中：ABEDFCHG  
前：CBADEFGH

求得  
后： AEFDBHGC

总所周知，后序遍历为 **左 右 根** ，

对照例子也不难发现，

前序遍历 （**根 左 右**） 的第一个节点为根节点（标记为C)，

也就是后序中最后遍历的节点。

而中序遍历为 **左 根 右** ，因此中序遍历C前为左子树，C后为右子树

再按此方法类推遍历所有节点，直到没有节点可以遍历时结束。

很明显的**递归性质**，对吧？

### 2 · 实现：

递归实锤，现在要考虑的是如何维护这两种遍历。其实数组和字符串

都是的OK的.个人更偏向于字符串储存 ~~毕竟c++的stl是真的香~~

用substr解决子串问题比邻接表方便多啦！！！

别忘记后序遍历输出一定在递归后哦，
对比前序和后序，自己想想为什么叭~~~

要注意的一点是我们求后序遍历只用保存中序遍历中的字符，

因此在前序遍历中判断根节点后，可以放心大胆的删掉它。

### 3 · 对string小小的科普（dalao快撤！！！）：

贴心的针对string小萌新的讲解：

1.substr(x,y):取从下标为x的字符开始往后数y为的串，如果只有参数x则从x直到串末

2.erase(x):删除x字符（串）

3.find(x,y):从下标y的字符开始往后寻找x,如果只有一个参数x则从头到尾找。成功找到则返回该下标，否则-1

---
#### 下面为代码环节，具体思路已标明清楚，请放心食用。

不要问我为什么为什么用f 和 m表示前序和中序，

因为这样简便 ~~其实就是水不会英文表达~~

```cpp
#include<bits/stdc++.h>//万头妙
using namespace std;//命名空间妙

void def(string f,string m){//前序和中序
	if(f.empty()) return;//没有字符可分则退出
	
	char ch=f[0];//前序中开头为当前根节点
	int k=m.find(ch);//在中序中找到此节点并记录下标
    
	f.erase(f.begin());//删除前序的开头（因为之后不会再用到它
	
	def(f.substr(0,k),m.substr(0,k));//找到和中序左子树对应的前序
	def(f.substr(k),m.substr(k+1));//两者皆递归，先左后又（左右根）
    
	cout<<ch;//递归结束倒着输出
}

int main(){
	cin.tie(NULL);//cin小优化了解一下(●ˇ∀ˇ●)
	string m,f;
	
	cin>>m>>f;
	def(f,m);//个人习惯，先前后中
	
	return 0;
}
```
### That's all for this.

在各种写题解的训练中本蒟蒻变强啦！~~也变秃了~~

会尽其所能继续给大家带来优质的题解。若有不足欢迎提出鸭!!!

最后，管理大大？（眼神明示）

嗯，就酱紫，拜拜！