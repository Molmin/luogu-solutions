如果 $a_1$ 是最大的，就没必要进行操作了。

如果 $a_1$ 不是最大的，就让 $a_1$ 与某个比 $a_1$ 大的元素进行操作，直到 $a_1$ 比这个元素大。假设这个元素是 $a_i$，那么进行若干次操作后 $a_1$ 将会变为 $\lceil\frac{a_1+a_i}{2}\rceil$。

但是比 $a_1$ 大的元素可能有多个，所以用贪心的思路来选择先后顺序。

看样例 $1$：$a_1=1,a_2=2,a_3=3$，如果先把 $a_1$ 和 $a_3$ 进行操作再把 $a_1$ 和 $a_2$ 进行操作，得到最终的 $a_1$ 是 $2$。但如果先把 $a_1$ 和 $a_2$ 进行操作再把 $a_1$ 和 $a_3$ 进行操作，得到最终的 $a_1$ 是 $3$。这说明每次操作都应选择比 $a_1$ 大的元素中最小的那个。

于是考虑将 $a_2$ 到 $a_n$ 从小到大排序，依次遍历每个 $2$ 到 $n$ 中的 $i$，如果 $a_i>a_1$，那么将 $a_1$ 修改为 $\lceil\frac{a_1+a_i}{2}\rceil$。

代码如下：

```cpp
cin >> t;
while (t--)
{
    cin >> n;
    for (int i = 1; i <= n; i++)
        cin >> a[i];
    sort(a + 2, a + n + 1);
    for (int i = 2; i <= n; i++)
        if (a[i] > a[1])
            a[1] = int(ceil((a[1] + a[i]) / 2.0));
    cout << a[1] << '\n';
}
```