出处：[https://www.luogu.org/blog/Sky-crystal/solution-p3951](https://www.luogu.org/blog/Sky-crystal/solution-p3951)

当NOIP的第一题不再是模拟时，事情就变得不是那么简单，

相信大家很容易发现这是道数论题(毕竟NOIP第一题不会出DP)，

那第一步肯定就是将题目套到自己所学过的数论中，

可以发现这是道exgcd或中国剩余定理的模板题。

**不过，这并不是最好的解题方法**，

因为大部分的人都是用一个神奇的公式 A 了这题的：

### $ans=(a-1)*b-a$ ；

其中 ans 为小凯用手中的金币不能准确支付的最贵的物品的价值，即需输出的值，

a 和 b 就是小凯手中的两种金币，即题目输入。

### 要推出此公式有两种方法：

#### 1：暴力：
枚举0到某个比较大的数，判断是否能凑成，最后找出最大的 ans，通过 a，b，ans 的值找规律

此方法比较简单，类似小学的找规律，就不仔细说明

#### 2：纯数学方法推出公式：

（以下用 $k$ 来表示物品的价值）

由题目可以得之最简单的办法就是枚举 $k$，

判断每一个 $k$ 是否满足 $k=a*x+b*y$，

其中 $x,y$ 分别表示需要 $a,b$ 面值的金币的数量，且 $x,y$ 大于等于0，

应此，我们可以将所有的k想象成一条数轴，从 0 开始到 $\operatorname{lcm}(a,b)$。

至于为什么到 $\operatorname{lcm}(a,b)$，下面会讲。

我们可以模拟这样一个过程，每次枚举 $y$ 的值，

此时 $b*y$ 相当于一个定值，

再枚举 $x$ 的值，计算 $k=a*x+b*y$，将 $k$ 标记（大家可以在底下画一下），

我们可以发现，

1：每次都会标记一个新的 $k$ ，不会重复。

2：当 $y=a-1$ 后就可以得出最终结果。

为什么呢？

因为每一个方程 $k=ax+by$ 都只有唯一的 $x,y$ 满足既是正整数又能使方程成立，

不过与 $exgcd$ 不同，$exgcd$ 中 $k$ 不是定值，只有 $a,b$ 是定值，

第二个是因为当 $y=a$ 时，$y*b$ 就变成了 $\operatorname{lcm}(a,b)$ (因为 $ab$ 互质)，

而此时 $yb+ax$ 的值都是 $a$ 的倍数，即 $(b*y+a*x)\bmod a=0$。

我们可以发现当 $y==0$ 时 $b*y+a*x$ 的值同样都是 $a$ 的倍数，

所以当 $y==a$ 时就没必要找了，以前都找过了，

同样当 $a>y$ 时也没必要找了，因为 $(a+i)*b+a*x=a*b+i*b+a*x=a*(b+x)+b*i$，

转换一下将 $x=x+b$ , $y=i$，

则$(a+i)*b+a*x$就变成了 $a*x+b*y$，

所以当 $y=a-1$ 时就可以停止了。

而 $y=a-1$ 时 $k=a*x+(a-1)*b$，

所以易得出当 $a=x$ 时所有后面的数都在上一次被完全填满了。

为什么呢？

因为我们发现凑不出的数都是从某个数开始，每一次加上 $a$ 或 $b$ ，因为上个数凑不出，那加上一个a或b还是不会被凑出，直到遇到某个数是 $a$ 或 $b$ 的倍数才停止，

而 $x,y$ 无论如何增加最终都会等于 $a$ 或 $b$ 而成为 $a$ 或 $b$ 的倍数而停止增加，

这就是输入数据保证存在的原因。

所以当 $y=a-1$ , $x=0$ 时的数 $k=b*y=b*(a-1)$，

注意到这是 $b$ 的倍数，

所以最大的 $ans$ 就是 $b*(a-1)$ 再减去一个 $a$，
 
因为每一个小于 $\operatorname{lcm}(a,b)$ 的 $b*y-a$ 都是无法被凑成的

设 $a*x_{1}+b*y_{1}=b*y_{2}-a$，

移项得 $a*(x_{1}+1)=b*(y_{2}-y_{1})$，

显然，只有 $\operatorname{lcm}(a,b)$ 满足，

#### 所以解就是 $(a-1)*b-a$。

代码是 $O(1)$ 的

```cpp
#include<iostream>
using namespace std;

int main(){
	long long a,b;
	cin>>a>>b;
	cout<<(a-1)*b-a;
	return 0;
}

```





















