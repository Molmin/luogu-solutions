前置：

1.**两个相邻的相等的数**：如 $1100$，有两组**两个相邻的相同的数**，分别为 "11" 和 "00"，这两组是相反的。

对于一个串，有两种情况：

①有偶数$(cnt)$个两个相邻的相同的数：对于其中一组两个相邻的相同的数，一定对应一组与它相反的两个相邻的相同的数(一组"11"一定对应一组"00")，每次翻转这相反的两组之间的数（不包括两端点），都可以让这两组相反的两个相邻的相同的数配对，即变为两组"10"或两组"01"。

>如："$\textcolor{blue}{1}\textcolor{red}{10010}\textcolor{blue}{0}110$"，可以翻转红色部分的数，蓝色的为两端点，两组相反的两个相邻的相等的数是开头的"$\textcolor{blue}{1}\textcolor{red}{1}$"和末尾的"$\textcolor{red}{0}\textcolor{blue}{0}$"。翻转之后变成了"101**00**10**11**0"，再翻转一次就成了"1010101010"

所以一共需要 $cnt/2$ 步。

②有奇数$(cnt)$个两个相邻的相同的数，则一定只有一组两个相邻的相同的数找不到与它相反的，则需要多用一步来翻转它，使其合法。翻转它之后，就有偶数个了。所以一共需要 $(cnt+1)/2$ 步。

综上，一共需要 $(cnt+1)/2$ 步就可以翻转成目标串。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+5;
int T,n,ans;
char s[N];
int main(){
  scanf("%d",&T);
  while(T--){
    ans=0;
    scanf("%d%s",&n,s);
    for(int i=1;i<n;i++)
      if(s[i]==s[i-1]) ++ans;
    printf("%d\n",(ans+1)>>1);
  }
  return 0;
}
```
