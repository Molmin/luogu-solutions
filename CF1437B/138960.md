~~这不是昨天的比赛吗qwq~~

【分析】：首先我们需要明白一件事：在01串中对换任意位置的一对0和1（而且不引起其他的变化）是完全可行的：如果说该对01是相邻的，直接翻过来；如果不相邻，将他们所在的区间（记为[l,r]）翻过来，然后再将区间[l+1,r-1]翻一次就可以了。

那么，如何实现操作数最小化呢？

第一步就是，确定你最终想要的01串的形态（有且仅有下面两种）：

①： 1010……10

②： 0101……01

好，怎么确定呢？

给个例子：1111010000

这个串中第一个元素是1，如果你想要01串形态变为②

那么就要使第一个1变为0，最后的0变为1，如果将它们直接对换，可知操作数是增加的（这里值得动手证一下）。类似地，可以讨论得到其他方式让第一个1变为0，最后的0变为1也会使操作数增加。（其他情况也可以类似讨论）

确定形态后，我们可以将当前串和最终串写出来进行比对：
```cpp

1 1 1 1 0 1 0 0 0 0
  ↓   ↓ ↓ ↓ ↓   ↓
1 0 1 0 1 0 1 0 1 0
```
在这里，将没有箭头的区间称为“相同的区间”，有箭头的则称为“不相同的区间”

下直接给出结论：相同的区间若参与变换，则操作数是不减的。

所以我们尽量对“不相同的区间”进行操作，可知连续的该类区间贡献是1（直接翻过来），而如果一定要在操作中包含“相同的区间”（如上面的两个单独的箭头），则贡献为2（还要翻回去），所以分别对他们统计一次就可以了。

由此，可以结合一下代码理解：

```cpp
if(s[0]=='1'){
			for(int i=0;i<len;i++){
				if(i&1) b[i]=0;
				else b[i]=1;
			} 
			
			int ans=0;
			for(int i=0;i<len;i++){
				bool flag=0;
				while(a[i]!=b[i]){
					flag=1;
					i++;
				}
				if(flag) ans++;
			} 
```

这里很多结论都是直接给的，可能不严格，希望大家提出哪里有问题qwq谢谢

完整代码：

```cpp
#include<cstdio>
#include<iostream>
using namespace std;
int a[100001];//a储存原串
int b[100001];//b储存目标串
int main(){
	int t;
	cin>>t;
	while(t--){
		int len;cin>>len;
		string s;
		cin>>s;
		for(int i=0;i<len;i++) a[i]=s[i]-'0';
		if(s[0]=='0'){
			for(int i=0;i<len;i++){
				if(i&1) b[i]=1;
				else b[i]=0;
			} 
			
			int ans=0;
			for(int i=0;i<len;i++){
				bool flag=0;
				while(a[i]!=b[i]){
					flag=1;
					i++;
				}
				if(flag) ans++;
			} 
			cout<<ans<<endl;
		}
		if(s[0]=='1'){
			for(int i=0;i<len;i++){
				if(i&1) b[i]=0;
				else b[i]=1;
			} 
			
			int ans=0;
			for(int i=0;i<len;i++){
				bool flag=0;
				while(a[i]!=b[i]){
					flag=1;
					i++;
				}
				if(flag) ans++;
			} 
			cout<<ans<<endl;
		}
	}
	return 0;
}
```


