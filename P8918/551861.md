**题目大意：** 给定 $t$ 组询问，每次询问给出一个正整数 $n$，同时给定初始位置 $x=0$，初始时间为 $i=1$。**每次你可以将 $x$ 加上或者减去 $2^{i-1}$，并将 $i$ 加上 $1$。** 求是否存在方法，使得 $x$ 可以到达 $n$，如果存在，求最小的 $i - 1$。

### Solution

签到题，这里给出一个最优的构造方法。

首先，考虑 $i = \lceil \log_2 (n + 1) \rceil$ 时的情况，如 $x = 101$ 时的所有合法情况：

```
±1±2±4±8±16±32±64
```

此时可得到的最大值为 $127$（全为加号的情况下），与 $n$ 的距离为 $26$。$26$ 可以从 $16 + 8 + 2$ 得到，从而将 $8,\,4,\,1$ 前面的加号替换为减号即可。（将 $a$ 的加号替换为减号后，贡献从加上 $a$ 变为减去 $a$，与原贡献的差距为 $2a$。故如果与原贡献的差距为 $2^i$，则应当将位置 $2^{i-1}$ 前的加号变为减号）

考虑将这个算法扩展，**对于 $n$ 的询问，得 $k = 2^{\lceil \log_2(n + 1) \rceil + 1} - n - 1$。如果 $k$ 为奇数则无解，否则最优步数即为 $\lceil \log_2(n + 1) \rceil$。**

这个算法的最优性是显然的（至少经过 $\lceil \log_2(n + 1) \rceil$ 步的加法才能超过 $n$ 的值），但是判断无解的正确性还需要一些证明。

考虑 $k$ 为奇数的情况，如果 $k$ 为奇数，则减去 $a$ 使得 $k$ 为偶数，必须使得 $a$ 也为奇数。但是由于将任意正整数数列中的**数 $a$ 的正负性改变，则对总和的影响为 $2a$** ，而 $2a$ 必然为偶数，所以当总和为奇数时，改变某数的正负性不能使得总和变为偶数，从而不存在方案使得总和为 $0$，也就不存在方案使得距离 $k$ 变为 $0$。

如果增加步数，显然加入的数是 $2$ 的正整数次幂，是一个偶数，仍然不存在方案使得 $k$ 可以变为 $0$。正确性证毕。

参考代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long int ll;
const int maxn = 2e5 + 10;
int main() {
    ios::sync_with_stdio(false);
    cin.tie(); cout.tie(); 
    int t; ll n; cin >> t;
    while (t--) {
        cin >> n;
        ll k = 1, d = 0, ans = 0;
        while (d < n)d += k, k <<= 1, ++ans; k >>= 1; ll c = d - n;
        if (c & 1)cout << "-1\n";
        else cout << ans << "\n";
    }
    return 0;
}
```
