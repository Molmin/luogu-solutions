发现本题还没有题解，蒟蒻来提供一篇。
# 题目
[UVA12535](https://www.luogu.com.cn/problem/UVA12535)
# 题意
给定 $n$ 个圆上的点与圆的半径 $r$，求从中任取 $3$ 点能凑出多少个锐角三角形。
# 思路
由于点的个数 $n$ 最大可能达到 $2\times10^{4}$，且本题有多组测试样例（$40$ 组左右），这说明我们单次计算的时间复杂度必须低于 $O(n^2)$，才有可能通过此题。十分显然，最终答案可能非常大，一个一个的判断三角形是否为锐角三角形是不可行的。

当思路陷入僵局时，我们可以来观察一下题目给的这幅图片。

![12535](https://cdn.luogu.com.cn/upload/image_hosting/9r4pcxdh.png)

图片很糊，但是我们依然很直观的可以看出 $P_i$，$P_{i+1}$，$P_{i+2}$ 这三个点构成的是一个钝角三角形，因为夹角 $θ$ 明显是**小于 $180$ 度**的（$θ$ **等于 $180$ 度**时说明三角形两点在外接圆直径上，此时三角形应为直角三角形）。那如果有连续的 $m$ 个点的两侧点角度差**小于等于 $180$ 度**时呢？可以推出此时从这些点中任意取 $3$ 个点组成的三角形一定为非锐角三角形。

于是，大体思路就出来了：先按照角度将所有点排序，计算出所有点可能组成的三角形总个数，然后按照角度顺序一边加点，一边用三角形总数减去新增的非锐角三角形个数，剩下的就是答案了。

现在剩下的问题是：如何计算在加入一个新的点时新增了多少个非锐角三角形。考虑一下之前的结论，由于所有点都是排过序的，我们可以用队列维护两侧点角度差**小于等于 $180$ 度**，此时队列中的点任选两个都能与新点组成一个非锐角三角形，那么我们就能容易的算出当前新增的非锐角三角形数量了。

时间复杂度：快速排序 $O(n\log_2{n})$，维护队列 $O(n)$。

总时间复杂度：$O(n\log_2n)$。

注意事项：

- 记得开 long long。
- 在计算第一个点的新增非锐角三角形数量前，要预先把除第一个点以外的点加入队列中。

# 代码
```cpp
#include<bits/stdc++.h>
using  namespace  std;
const int maxn=2e4+5;
double angle[maxn];
queue<double>q;
int main()
{
    long long n,r,cnt=0;
    while(scanf("%lld %lld",&n,&r),n!=0)
    {
        printf("Case %lld: ",++cnt);
        for(int i=1; i<=n; i++)
            scanf("%lf",&angle[i]);
        sort(angle+1,angle+n+1);
        while(!q.empty())
            q.pop();
        for(int i=2; i<=n; i++)
            q.push(angle[i]-360.0);//由于第一个点可能与末尾的点构成非锐角三角形，所以需要预先将后n-1个点加入队列（角度要减去360度，保证队列中的角度一直维持单调不降）
        long long ans=n*(n-1)*(n-2)/6;//计算所有三角形总个数
        for(int i=1; i<=n; i++)
        {
            double lef=q.front();
            while(angle[i]-lef>180.0+1e-6&&!q.empty())//角度最小点与当前点(角度最大点)差距超过180度，此时丢掉角度最小的点
            {
                q.pop();
                lef=q.front();
            }
            if(q.size()>=2)
                ans-=(q.size()*(q.size()-1)/2);//减去新增非锐角三角形
            q.push(angle[i]);//将当前点加入队列
        }
        printf("%lld\n",ans);
    }
    return 0;
}

```

