异或有一个性质：
$$a\oplus b=x\Leftrightarrow b=x\oplus a$$
也就是说，只要我们确定了 $a$ ，那么 $b$ 的数值也就自然确定了。
我们对区间进行查询，枚举区间内的每一个数 $a$,只需要确定 $a\oplus x$ 存在，那么就直接输出 ```yes``` 即可。
### 解法（DP):
注意到我们是对一个区间 $[L,R]$ 进行询问，那么我们的 $f$ 数组就可以用类似前缀和的思想，将 $f_i$ 定义的范围设定为 $[1,R]$。

如果 $a\oplus b=x$,那么我们称 $a$ 和 $b$  是一对满足条件的数对，并且较小的那个称为该数对的下界。

那么，$f_i$ 所表示的集合为：所有 $[1,i]$ 范围内满足条件的数对的下界的下标，属性为所有下标当中的最大值。

因此当我们查询区间 $[L,R]$ 时，只需要判断**区间左端点 $L$ 是否在最大下界的左边**即可，因为这可以保证在区间内**至少**存在一个数对是满足条件的。

在实现上，我们定义一个哈希表来存储每个数所对应的下标，考虑当前遍历到的元素为 $a_i$ ，与其对应的数为 $a_i\oplus x$。

如果 $a_i\oplus x$ 在前面出现过，那么我们需要取它的下标与前 $i-1$ 个数中满足集合条件的下标之间的较大值，即
$$f_i=\max(f_{i-1},Hash_{a_i\oplus x})$$

这样时间复杂度大约为 $\Theta(m+n)$。~~很快啊~~
#### 贴上代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[100005],f[100005];
map<int,int> Hash;//记录每一个a[i]^x的最近的位置
int main(){
    int n,m,x;
    cin>>n>>m>>x;
    for(int i=1;i<=n;i++){
    	cin>>a[i];
    	f[i]=max(f[i-1],Hash[a[i]^x]);
    	Hash[a[i]]=i;//哈希一下~
    }
    while(m--){
        int l,r;
        cin>>l>>r;
        if(f[r]>=l)cout<<"yes\n";//左端点在最大下界的左边
        else cout<<"no\n";
    }
    return 0;
}
```