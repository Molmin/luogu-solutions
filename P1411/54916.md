#### 一个比较难想的树形分组dp，我们考虑设dp[u][k]表示在以u为根的子树中，共分成k个联通块能够的到的最大分数，可是这个问题似乎有点后效性，同时也不好转移，那我们干脆设的更明确一点，设dp[u][k]表示在u的子树中，和u连在一起的点的个数（即u所在的联通块大小）为k时能得到的最大分数。特殊的，我们用dp[u][0]表示在以u为根的子树中能得到的最大分数，

#### 我们考虑一个转移：dp[u][j]=max(dp[u][k]/k\*dp[v][j-k]/(j-k)\*j)

#### 由于题目数据有点sang，xin，bing，kuang，在常规做法中，我们必须要一个高精度，而写一个高精除低精，还是比较麻烦的，所以我们就考虑如何把这个除法弄掉。

#### 我们重新设dp[u][k]表示在u的子树中，u所在的联通块的大小为k时，得到的最大分数不乘以k时的大小。那么转移就很好写了。

#### dp[u][j]=max(dp[u][k]\*dp[v][j-k])，那么我们之前说的dp[u][0]就可以起到作用了，这时特殊的，dp[u][0]=max(dp[u][j]\*j)，这个方程的正确性还是比较好证明的，最后的结果就是dp[1][0]。

#### 剩下的就是一个高精度了。


#### 参考代码：

```cpp
int dfs(int u,int fa){
    sz[u]=1;dp[u][0]=1;dp[u][1]=1;
    for (int p=a[u];p;p=e[p].next){
        int v=e[p].to;
        if (v!=fa){
            dfs(v,u);
            sz[u]+=sz[v];
            for (int j=sz[u];j>=0;j--)
                for (int k=min(j,sz[u]-sz[v]);k>=max(1,j-sz[v]);k--)//这个分组背包有很多种写法
                    ChkMax(dp[u][j],dp[u][k]*dp[v][j-k]);
        }
    }
    for (int i=1;i<=sz[u];i++)
        ChkMax(dp[u][0],dp[u][i]*i);
}
```



最后Orz楼下dalao
