一开始想了个贪心。


就是每次枚举叶子，


如果大小为1或者合并后大小<=3,就把相连的点的大小+=它的大小，


否则就把答案\*=它的大小；


删掉这个点；


重复操作。


但这是错的(还能拿65)。


于是我就打了个dp，


f[x][j]表示以x为根的子树，x所属的联通块大小为j，的最大乘积。


枚举儿子y，之后再枚举每个j，k f[x][j]=max{f[x][k]\*f[y][j-k]}


注意这时不要让j,k=0,但j-k可以是0。


因为如果联通块不为0，那么x必须选择。


之后再枚举k,f[x][0]=max{f[x][k]\*k}


这个dp要高精\*高精，所以复杂度挺高的，约O(n^3\*l^2) l是答案长度


(但高精度压位后空间正好能过，时间的话最慢的点0.1s+...应该是数据水吧)


(根据时空来看其他过的人是这个方法)


其实比较乘积可以转化为比较log(乘积)


这样就可以O(n^3)dp了


记录一下从哪里转移过来的


最后再统计一下答案


只用做n次低精乘高精


总时间O(n^3)


upd:
做了http://codeforces.com/contest/815/problem/C

发现这个dp复杂度其实是O(n^2)

每次转移是复杂度是 x之前的子树的sz\*当前子树的sz

相当于之前子树所有点和当前子树的点组成的点对数

而每个点对只会在lca处被计算一次

所以复杂度O(n^2)
