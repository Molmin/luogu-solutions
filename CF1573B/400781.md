### 题意
给你两行数，每行 $n$ 个，一行全是奇数，一行全是偶数，你可以交换任意一行的相邻两个数，问经过多少次操作之后可以使得第一行的字典序小于第二行。

 -----
### 分析
先来重提一个概念：什么叫字典序？

就是我们从第一位开始比较，第一位较大的字典序更大，第一位相同就比较第二位，以此类推比下去。

回到题目。一行全是奇数，一行全是偶数，这第一位无论如何不可能相等的。
所以我们只需要使第一行第一个数小于第二行第一个数就可以了。

我的做法是，枚举其中一行的每一位作为首位的情况，考虑另一行把哪一位移过来才能满足题目要求且移动次数最小，最后取一个最小值就行了。

咱们来看一下样例最后一组数据：
```
5
7 5 9 1 3
2 4 6 10 8
```
以枚举第二行为例：

考虑 $2$ 作为首位，第二行不用移动；第一行可选的首位有 $1$，移过来需要 $3$ 次操作，总代价为 $3$；

$4$ 作为首位，第二行移动 $1$ 次；第一行可选的首位有 $1$、$3$，移动 $1$ 需要的操作次数最少，需要 $3$ 次操作，总代价为 $4$；

$6$ 作为首位，第二行移动 $2$ 次；第一行可选的首位有 $1$、$3$、$5$，移动 $5$ 需要的操作次数最少，需要 $1$ 次操作，总代价为 $3$；

$10$ 作为首位，第二行移动 $3$ 次；第一行可选的首位有 $1$、$3$、$5$、$7$、$9$，移动 $7$ 需要的操作次数最少，需要 $0$ 次操作，总代价为 $3$；

$8$ 作为首位，第二行移动 $4$ 次；第一行可选的首位有 $1$、$3$、$5$、$7$，移动 $7$ 需要的操作次数最少，需要 $0$ 次操作，总代价为 $4$；

综上，答案为 $3$。

至于如何实现，我们处理出第一个序列上每一个数移动到第一位所需要的次数，记录下它们的**前缀最小值**，对于序列二的每一个数，直接查询即可。注意，做前缀最小值之前，所有数字对应的操作次数初始化为 inf。

#### 最后，注意多组数据。
----------

### Code：
```cpp
#include<bits/stdc++.h>
struct istream
{
	istream operator>>(int &x)
	{
		x = 0;
		char ch = getchar();
		while (!isdigit(ch))ch = getchar();
		while (isdigit(ch))x = x * 10 + ch - '0', ch = getchar();
		return *this;
	}
}cin;
namespace XMSU
{
	const int N = 2e5 + 5;
	int a, b, n, ans;
	int mi[N];
	void work()
	{
		cin >> n;
		ans = INT_MAX;
		memset(mi, 0x3f, sizeof(int)*(n * 2 + 5));
		for (int i = 1;i <= n;i++)
		{
			cin >> a;
			mi[a] = i - 1;
		}
		for (int i = 1;i <= 2 * n;i++)
		{
			mi[i] = std::min(mi[i - 1], mi[i]);
		}
		for (int i = 1;i <= n;i++)
		{
			cin >> b;
			ans = std::min(ans, i - 1 + mi[b]);
		}
		std::cout << ans << '\n';
	}
}
int main()
{
	int T;
	cin >> T;
	while (T--)XMSU::work();
	return 0;
}
```
PS：赛场上没有想到前缀最小值的做法，直接写了一棵线段树上去，达到了相同的效果……