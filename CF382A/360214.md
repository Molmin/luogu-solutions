## 目标

给你一个字符串形式的天平和一堆物品，让你把所有物品堆中的物品往天平上放。

试问天平能否平衡。如果能，输出操作后的天平。

## 分析

主要有如下几个重点：

- 字符串的解析
- 放上物品后判断天平是否平衡

首先，这道题给你的这堆物品的重量都为 $1$，所以东西无关紧要，我们只需统计天平两端物品的数目。

而表示天平的这个字符串用 `|` 分割，所以 `|` 所在的位置就是天平左半部分的物品数量（因为字符串下标从 $0$ 开始）。

而我们放上去**不平衡**无非有两种情况：

1. 天平上某一端的物品个数已经超过了目标物品个数；
2. 天平上和物品堆里的东西总和是奇数，就算全放上去了也无法平衡。

所以我们分别对它进行判定就好啦！

## 代码

~~码风巨丑 勿喷~~

```C++
#include<iostream>
#include<cstdio>
#include<cmath>
using namespace std;

int main() {
    string s, t; cin >> s >> t; int l, r, a, b, c;
    l = s.find('|'), r = s.size() - l - 1;
    a = abs(l - r), b = t.size(), c = l + r + b >> 1;
    if (c < l || c < r || (a ^ b) & 1) cout << "Impossible";
    else cout << t.substr(0, c-l) << s << t.substr(c-l);
    return 0;
}
```

## 补充

代码中运用到了 C++ 字符串中的两个方法。

### find 方法

返回某个字符在字符串中**第一次出现**的位置。

1. `s.find(c)` 返回字符串中第一次出现 $c$ 的位置（下标从 $0$ 开始）；
2. `s.find(c, pos)` 返回字符串中 $pos$ 位置之后第一次出现 $c$ 的位置。

### substr 方法

返回某个字符串的子串。

1. `s.substr(s, l)` 返回从 $s$ 开始的 $l$ 个字符组成的字符串；
2. `s.substr(s)` 返回从 $s$ 开始到结尾的字符串。
