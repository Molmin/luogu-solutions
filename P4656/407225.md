## P4656题解

**前置知识: 字符串哈希（或 KMP）**

首先观察题面，其意思是让我们将一个字符串分割成尽可能多的子串，使得这些字串构成的集合是回文的。所以我们知道，需要使用一个合理的、快速的方法判断字符串中的两个子串是否相等。所以我们需要使用 **KMP** 或 **字符串哈希**。

由于 **KMP** 过于深奥，我这小小的蒟蒻讲不明白，所以给出 **字符串哈希** 的做法。

因为我们要让字串尽可能的多，意思是我们要让每个子串的长度尽可能小，并且题目限制了我们的时间复杂度在 $O(n)$，所以考虑贪心的做法（线性 DP 复杂度过高）。

不妨从字符串的第一个位置开始枚举，如果从第一个没有被判断过的位置，到当前位置的字串（即：$S[last..i]$）与其关于字符串中间位置对称的字符（即：$S[n-i+1..last+1]$）这两个字符串相等，那么我一定要将这两个字符串分割出去，因为这样可以使所选集合中的字符串的长度最短，从而达到字串数量最多的目的。

下面给出代码和详细解释：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int P = 13331;
int T, n, ans, last;
char s[1000005];
unsigned long long f[1000005], p[1000005];
void H(){//采用自然溢出法，保存一个字符串及其字串的哈希值
	for (int i = 1; i <= n; i++)
		f[i] = f[i - 1] * P + s[i] - 'a' + 1;
}
bool judge(int l1, int r1, int l2, int r2){
	//根据哈希值判断两个字串是否相等
	//判断方法的正确性证明略 
	return f[r1] - f[l1 - 1] * p[r1 - l1 + 1] == f[r2] - f[l2 - 1] * p[r2 - l2 + 1];
}
int main(){
	scanf("%d", &T);
	p[0] = 1;
	for (int i = 1; i <= 1000000; i++)
		p[i] = p[i - 1] * P;
	//p[i]存储 p^i%(2^64-1) 的值，用于判断字符串是否相等 
	while(T--){
		scanf("\n%s", s + 1);
		n = strlen(s + 1);
		//输入 
		H();//初始化Hash数组（代码中的f数组） 
		ans = 0, last = 1;//last 
		for (int i = 1; i <= n; i++)
			if (judge(last, i, n - i + 1, n - last + 1))
				last = i + 1, ans++;//如果两个字符串已经相等，则一定要选出 
			//原因见上方 
		printf("%d\n", ans); 
		//输出答案 
	}
	return 0;
}
```