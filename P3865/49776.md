43篇题解，过不了就当做一篇笔记好了。

ST表是一种预处理nlog（n），查询O（1）的算法，用于处理**无修改**的区间最值问题。

* 简介ST表

其实我是先学倍增LCA再学ST表的，~~别问为什么顺序这么奇怪~~，所以看到ST表的做法就觉得非常熟悉.**它是用ans[i][j]表示从j开始的$2 ^ i$个数的最值**，也就是j ~ j + $2 ^ i$ - 1 的最值。

* 如何求这个数组的值

明显可以将这个区间二分，分为j ~ j + $2 ^ {i - 1} $ - 1和j +$2 ^ {i - 1}$ ~ j + $2 ^ i$ - 1，可以看图理解一下。（上面是数组下表，下面是a数组的值）

![](https://cdn.luogu.com.cn/upload/pic/75118.png)

这样就将大问题转化为了小问题，每次计算ans[i][j]的时候可以直接从**ans[i-1][j]和ans[i-1][j + pow(2,i)]取最大值。**

由于i的问题只与i-1的子问题相关。直接i从1~n循环一遍，每一遍循环计算每个j的ans[i][j]的值，就可以O（nlog（n））预处理出每一个ans[i][j]。**记得要给ans[0][j]赋上a[j]**（因为长度为$2 ^ 0$的区间只有一个数，就是自己）

* 查询：

每一次需要查询区间（x，y）的最大值，那么怎么查询呢？

~~当然是将i从log（n）开始到0循环，一开始站在x点，每次能跳则跳，然后取一个最大值啦~~

咳咳，所以倍增LCA还是和ST表有不同之处的，ST表的查询和这个差不多，但是简单一点，来看这个区间。

![](https://cdn.luogu.com.cn/upload/pic/75119.png)

其实在这种情况下，我们直接输出max（ans[2][3]，ans[2][5]）的值就可以了，这样就覆盖了整个区间，而重复部分由于是最大值，所以没有影响。

梳理一下一般情况，如何用ST表查询区间（x，y）的最大值：

设k = log（y - x + 1）（其实就是求x ~ y所包含的点的数量的log），答案是**max（ans[k][x]，ans[k][y-pow（2，k）+ 1]）**

（也就是从x向右伸展$2 ^ k$个数中的最大值，和从y向左伸展$2 ^ k$个数中的最大值，取一个最大值作为答案）

* 为什么这样一定覆盖整个区间

我保证中学生都可以看懂。~~你歧视小学学历的人？~~

这里可以用反证法证明：

假设在区间（x，y）中有一段（a，b），是不被（x，x + $2 ^ k$）和（y - $2 ^ k$ + 1 ， y）所覆盖的。那么（x，x + $2 ^ k$）和（y - $2 ^ k$ + 1 ， y）一定不相交（如果相交就完全覆盖了），即y - x + 1>= 2 * $2 ^ k$。

回顾一下k的定义，log(y - x + 1），也就是说y - x + 1 >= 2 * （y - x + 1），显然不可能，所以这两段一定覆盖整个区间。

放上本题AC代码（仅供参考，优化看不懂就别看了）：

```
#include <cstdio>
#define max(a,b) a>b?a:b
int n,m;
int ans[20][100005],p[20],lo[200005];

int read(){
	int x = 0;
	char ch = getchar();
	while(ch < '0' || ch > '9'){
		ch = getchar();
	}
	while(ch >= '0' && ch <= '9'){
		x = x * 10 + ch - '0';
		ch = getchar();
	}
	return x;
}

int main(){
    n = read(),m = read();
	p[0] = 1; 
    for(int i = 1;i <= 17;i++){
    	p[i] = p[i - 1] * 2;
    	lo[p[i]] = i;
    }
    for(int i = 1;i <= n;i++){
    	ans[0][i] = read();
    	if(!lo[i]){
    		lo[i] = lo[i - 1];
    	}
    }
    for(int i = 1;i <= 17;i++){
    	for(int j = 1;j + p[i] - 1 <= n;j++){
    		ans[i][j] = max(ans[i - 1][j],ans[i - 1][j + p[i - 1]]);
    	}
    }
    int x,y;
    for(int i = 1;i <= m;i++){
    	x = read(),y = read();
    	int k = lo[y - x + 1];
    	printf("%d\n",max(ans[k][x],ans[k][y - p[k] + 1]));
    }
	return 0;
}
```

最后说一句，本题难度应该不止黄吧，思维难度还是挺大的。
