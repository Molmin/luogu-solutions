没放图警告  

## 0.前言  
个人认为 ST表像是一种基于dp(倍增?)算法的数据结构  
## 1.概念与应用  
ST表示用来解决区间最值(RMQ)问题的  
ST表的实现方式和线段树不同 线段树是把待查询区间**拆成$logn$级别个不相交区间** 而ST表则是通过把一个区间最大值用**两个区间 最大值 的最大值**代替 并且选取的两个区间的并集则是带查询区间  

这样使得ST表能够在$O(1)$时间内查询区间最大/最小值 但是由于两个区间的交集未必为空 所以ST表不能实现区间求和(以及其他类似的事情)  
## 2.实现方式  
实现的关键在于**拆成的区间的选取**  
我们需要预处理出来一定数量个区间的最值 然后每次询问根据询问区间选取两个
我们需要在能保证**任意一个区间查询都能够正确实现**的情况下使得**总区间数量尽量小**  

这里我们选择的是对于每一个点$l$预处理区间$[l,l+2^k-1]$  
就是从$l$开始往后$2^k$个数的最值  
这样一定可以满足任意一个区间查询  

证明: $2^k <= (2^k+2^k-x) <= 2^{k+1}$ $(0<=x<=2^k)$  
~~是不是太抽象了~~  
对于一个询问区间长度在$[2^k,2^{k+1}]$的询问 一定存在两个长度为$2^k$的区间 它们的并集等于询问区间  

对于区间查询$[l,r]$ 选择**左端点为l**的区间和**右端点为r**并且 **区间长度为$2^k$**的两个区间  

$2^k$可以通过区间长度计算出来  

~~可以直接上代码了~~  
## 3.代码实现  
### 1.预处理  
倍增思想  
$[1,2]=max([1,1],[2,2])$ $[1,4]=max([1,2],[3,4])$ ...  
记得从小到大枚举区间长度 然后区间最大值等于左半边右半边的最大值  
记$dp[x][i]$表示区间$[i,i+2^x-1]$  
x只要枚举到$logn$即可  

预处理log:  
```cpp
LOG[0] = -1;
for(int i = 1;i <= 100000;i ++) LOG[i] = LOG[i >> 1] + 1;
```
预处理:  
```cpp
for(int j = 1;j <= LOG[n];j ++){
	for(int i = 1;i <= n;i ++){
		dp[j][i] = max(dp[j - 1][i],dp[j - 1][i + (1 << (j - 1))]);
	}
}
```  
### 2.查询  
先根据区间长度算出上文所说$k$  
由于预处理时每个区间对应的是左端点 所以要计算右端点为r的区间的左端点  
由于是闭区间 计算长度是$r - l + 1$  
左端点计算方式:$r - l + 1 = 2^k$  
$l = (r - 2^k + 1)$  
这很简单 但是我觉得必须给出来
```cpp
scanf("%d %d",&l,&r);
k = LOG[r - l + 1];
printf("%d\n",max(dp[k][l],dp[k][r - (1 << k) + 1]));
```  

完整代码:  
~~这是我远古时期写的了~~  
```cpp
#include <cstdio>
#include <iostream>
#include <algorithm>
#include <cstring>
#include <cmath>
using namespace std;
int n,m,b,c,k;
int a[100005] = {0};
int dp[55][100005] = {0};
int LOG[100005] = {0};
int main(){
	cin >> n >> m;
	for(int i = 1;i <= n;i ++){
		scanf("%d",&dp[0][i]);
	}
	LOG[0] = -1;
	for(int i = 1;i <= 100000;i ++){
		LOG[i] = LOG[i >> 1] + 1;
	}
	for(int j = 1;j <= LOG[n];j ++){
		for(int i = 1;i <= n;i ++){
			dp[j][i] = max(dp[j - 1][i],dp[j - 1][i + (1 << (j - 1))]);
		}
	}
	for(int i = 1;i <= m;i ++){
		scanf("%d %d",&b,&c);
		k = LOG[c - b + 1];
		printf("%d\n",max(dp[k][b],dp[k][c - (1 << k) + 1]));
	}
	return 0;
}
```

## 4.更多应用
ST表同时也是可以输出区间最值所在位置  
改变判断条件 dp数组保存下标  
## 5.总结  
$nlogn$预处理 $O(1)$查询最值  
代码实现复杂度也不高  
应用范围虽然没有线段树大 但是ST表还是值的一学的