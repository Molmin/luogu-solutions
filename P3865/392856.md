前置知识：前缀计算。
## 概念：
在前缀计算中，任意子区间都可以表示成两个前缀区间相减。

所以可以预处理所有前缀区间的值。

子区间的值就是两个前缀区间值进行逆运算的结果。

但是，运算不可逆时无法用前缀计算处理。

只能考虑将目标区间连续分成几个区间，用正向计算来求解。

令连续的区间 A 和 B 合并后得到区间 C 。

那么，对区间 A 和 B 的值进行运算，就可以得到区间 C 的值。

需要运算满足结合律。

## ST表：预处理所有长度为 $2$ 的幂的区间的值
通常用区间左界 $i$ 和表示长度的幂 $j$ 表示区间 $[i, i + 2^j - 1]$ 。

求解方式按照幂由小到大递推求解。

每个幂为 $j$ 的区间可以由两个幂为 $j - 1$ 的区间合并而成。

递推边界是单位区间，即 $j$ 为 $0$ 的区间。
### 实现思路
1. 初始化单位区间的值。
2. 由小到大枚举区间长度
3. 枚举区间左边界，并计算当前区间的值。

## 时空复杂度
令区间的全长为 $n$ 。

每个长度的区间数量 $n$ ，长度数量 $\log n$ ，区间总数 $n \log n$ 。

### 时间复杂度
计算区间值 $O(1)$ ，总共 $O(n \log n)$ 。
### 空间复杂度
记录每个区间的值 $O(n \log n)$ 。
## 应用
相比于前缀计算提高了复杂度，但是扩大了应用场景。

用 ST表 的区间可以合并出任意子区间。

对于长度为 $l$ 的区间 $[i, i + l - 1]$ ，令 $l = 2^{p_1} + 2^{p_2} + …… 2^{p_k}$ 。

可以将区间划分成长度为相应 $2$ 的幂的区间：

$[i, i + 2^{p_1} - 1]$、 $[i + 2^{p_1} , i + 2^{p_1} + 2^{p_2} - 1]$、…… 。

最多划分成 $\log l$ 个区间。
## 题目分析
给定一个长为 $n$ 的整数序列 $a$ 。

进行 $m$ 次查询，每次查询指定区间中的最大值。

## 思路
先预处理出 ST表 中每个区间的最大值。

对于每个查询，对区间进行划分，找到所有区间中的最大值。
## $code$
~~~cpp
#include <algorithm>
#include <iostream>

using namespace std;

const int kMaxN = 1e5 + 1;
const int kMaxL = 20;

int f[kMaxN][kMaxL];
int n, m, l, r, ans;

int main() {
  ios::sync_with_stdio(0);
  cin.tie(0), cout.tie(0);
  cin >> n >> m;
  for (int i = 1; i <= n; i++) {
    cin >> f[i][0];  // 读入单位区间的最大值
  }
  for (int j = 1; j < kMaxL; j++) {                            // 枚举幂
    for (int i = 1; i + (1 << j) <= n + 1; i++) {              // 枚举左界
      f[i][j] = max(f[i][j - 1], f[i + (1 << j - 1)][j - 1]);  // 计算相应区间的最值
    }
  }
  while (m--) {
    cin >> l >> r;
    ans = 0;
    r = r - l + 1;                     // 计算区间长度
    for (int j = 0; j < kMaxL; j++) {  // 枚举幂
      if (r >> j & 1) {                // 需要当前幂
        ans = max(ans, f[l][j]);       // 更新最值
        l += 1 << j;                   // 移动左界
      }
    }
    cout << ans << '\n';
  }
  return 0;
}
~~~