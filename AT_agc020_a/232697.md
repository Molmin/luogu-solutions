这道题很简单。

由于某些原因，我的题解分两部分，下文会叙述原因。

题目解析：这道题是一道模拟题。
我们可以通过模拟两个人的最优策略来完成这道题目。

最优策略是：向对方走，压缩对方的空间，直到对方无法前进并后退。

下面便是题解。

第一部分：模拟题解（我最初的题解）

通过循环模拟每个人每一步走的步数，直到相遇，计算谁后退，后退者输。

当相遇时，由于先走的人需要后退，所以先走的那个人会输。

所以只要模拟到相遇即可。

源代码：
```
#include<iostream>
using namespace std;
int main(){
int a,b,c,x,y,z;
cin>>c>>a>>b;
z=a-b;
if(z<=0)z*=-1;
for(int i=1;i<=1;){
z-=1;
y+=1;
//拒绝抄袭从我做起
if(z==0&&y%2==1){cout<<"Borys";break;}
if(z==0&&y%2==0){cout<<"Alice";break;}}
}
```

结果我用数据试过以后：

~~此题原来十分简单~~

发现这题能用奇偶性解决……

奇偶性解决：因为相遇时先走的人会输，所以用中间距离的奇偶性来判断谁必须后退。
因为不管前进还是后退，距离奇偶性都会变化。


所以：第二部分（更加简单的方法）

使用$b-a$奇偶性解决。
如果$b-a$是奇数$Borys$赢；
反之，$Alice$赢。
源代码：

```
#include<iostream>
using namespace std;
int main(){
int a,b,c,x,y,z;
cin>>c>>a>>b;
z=a-b;
if(z%2==0)cout<<"Alice";
else cout<<"Borys";
return 0;}
```
本人的题解就到这里了，谢谢阅读，希望大佬多多提出意见！