这道题其实根本没有看起来的那么毒瘤......

看到操作$2$，发现其实就是将$2$个相隔$1$个位置的数交换一下。容易发现，$2$个数字对应下标的**奇偶性不变**。于是就有了思路：

先将数列中下标为**奇数**的与下标为**偶数**的分为两个数列，分别排序，再将两个数列按原来下标顺序合并。~~好吧我承认我语文不好，只好上个例子~~
```
原数列:4 3 5 2 1
分拆:4 5 1,3 2
分别排序:1 4 5,2 3
合并:1 2 4 3 5
```
~~是不是很生动形象呢~~

问题就转变为了冒泡排序的最小交换次数问题，不就是**逆序对**嘛。因为$N\le 10^5$，所以要开$long$ $long$。

参考代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
#define N 100005
#define gc getchar
#define ll long long
#define lb(x) ((x)&(-(x)))
int n,a[N],b[2][N],c[N],ds[N],v[N];ll ans;
int rd()
{
	bool fl=0;int res=0;char c=0;
	while(!isdigit(c)) fl|=c=='-',c=gc();
	while(isdigit(c)) res=(res<<1)+(res<<3)+(c&15),c=gc();
	return fl?-res:res;
}
void dsc() {sort(ds+1,ds+ds[0]+1);ds[0]=unique(ds+1,ds+ds[0]+1)-ds-1;}
int id(int _v) {return lower_bound(ds+1,ds+ds[0]+1,_v)-ds;}
void upd(int x) {for(;x<=n;x+=lb(x)) ++v[x];}
int qSm(int x) {int res=0;for(;x;x-=lb(x)) res+=v[x];return res;} 
int main()
{
	n=rd();
	for(int i=1;i<=n;++i) a[i]=rd(),b[i&1][++b[i&1][0]]=a[i];
	sort(b[0]+1,b[0]+b[0][0]+1);sort(b[1]+1,b[1]+b[1][0]+1);
	for(int i=1;i<=b[0][0];++i) c[++c[0]]=b[1][i],c[++c[0]]=b[0][i];
	if(b[1][0]>b[0][0]) c[++c[0]]=b[1][b[1][0]];for(int i=1;i<=n;++i) ds[++ds[0]]=c[i];dsc();
	for(int i=1;i<=n;++i) c[i]=id(c[i]),ans+=i-1-qSm(c[i]-1),upd(c[i]);
	printf("%lld\n",ans);
}
```
~~于是作弊者们用这份代码交了上去，发现WA了，但得到了71分的好成绩~~

举个hack的栗子：
```
输入：
5
2 100 1 200 3
```
上面代码的输出：
```
3
```
正确输出：
```
1
```
方法：
```
(1) 1 100 2 200 3 (不计)
(2) 1 100 200 2 3 (不计)
(3) 1 2 200 100 3
(4) 1 2 3 100 200 (不计)
```
之前的程序错在明明可以使用操作$2$直接交换时，却使用了操作$1$（就错在后面的求逆序对上）

那正解是怎么做的呢？

看到操作$1$，发现每一次都会将相邻$2$个数的下标的奇偶性互换。于是一个新的思路就出现了：

先将数列排序，并记录排序好后的每一个数的位置对应排序之前的那个数的位置。如果$2$个位置奇偶性不同，则将计数器的值加$1$。

**输出的是计数器的值除以2！！！**（具体为什么请自己想，很简单的）

参考代码：
```cpp
那么好写还要我放代码？
```