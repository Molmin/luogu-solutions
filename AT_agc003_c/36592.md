由于操作 2 没有要求，容易想到可以无限制地用它，直到不得不用操作 $1$ 。于是，考虑什么时候操作 2 不能解决。

首先，操作 2 等价于交换 a[i] 和 a[i+2] ，对于某个位置上的数，使用操作 2 只能将它移到与原位置距离为偶数的位置。（即原来在奇数位置，移动后也在奇数位置；原来在偶数位置，移动后也在偶数位置）。然而操作 1 与此刚好相反。

然后，做法就很明显了：找出每个数最终要到达的位置，判断与当前的位置的奇偶性是否相等，若不等，说明需要消耗一次操作 1 。

注意最终统计的答案需要除以 2 （每一次操作改变的是两个数的位置）。

核心代码：

```cpp
int main()
{
	n=read();
	for(int i=1;i<=n;i++){
		a[i]=read();
		b[i]=a[i];
	}
	int ans=0;
	sort(b+1,b+1+n);
	for(int i=1;i<=n;i++)a[i]=lower_bound(b+1,b+1+n,a[i])-b;
	for(int i=1;i<=n;i++)if((a[i]&1)!=(i&1))ans++;
	cout<<ans/2;
	return 0;
}
```
