先声明一下本篇题解中使用的一些简称：

$Cir(A,B)$ : 以 $A$ 为圆心， $B$ 为圆上一点作圆。

$Line(A,B)$ : 过 $A$, $B$ 两点作一条直线。

---

# 1.简单数学知识

## Data 1

作中垂线：

记 $A(0, 0)$，$B(0, 1)$

那么作一个 $Cir(A, B)$, 作一个 $Cir(B, A)$，连接两圆的交点就行了。

为啥？因为一条线段上的中垂线上的点到两个端点的距离相等。

那么我们画的这两个圆上的点到各自圆心的距离都相等。

那么两圆的交点到两个圆心的距离都相等，这样就有了两个点，到两个圆心的距离相同。

然后我们就可以确定这两个点都在中垂线上。并且由于两点确定一条直线，我们就可以确定好这条中垂线了。

```cpp
inline void solve1() {
	puts("3");
	Cir(0, 0, 1, 0);
	Cir(1, 0, 0, 0);
	db x = 0.5, y = sqrt(0.75);
	Line(x, y, x, -y);
}
```

## Data 2

过一点作给定线段的垂线

这应该也不难。假设给定的线段是 $AB$，过 $C$ 作 $AB$ 的垂线。

那么就可以作 $Cir(A, C)$ 和 $Cir(B, C)$，这时候就有两个交点。

不难发现这两个交点关于 $AB$ 所在直线对称，所以这两个交点的连线就垂直于 $AB$ 了。

```cpp
inline void solve2() {
	puts("3");
	db x = 5.23124577, y = 4.31624417;
	Cir(0, 0, x, y);
	Cir(1, 0, x, y);
	Line(x, y, x, -y);
}
```

# 2. 倍增

## Data 4

给出两个点 $A(0, 0)$ 和 $B(1, 0)$, 请你找到 $Target(1024, 0)$

发现给出的步数要求是 $10$，然后 $1024=2^{10}$，不难想到倍增。

可以每一次作 $Cir((2^k, 0), A)$ 来得到 $(2^{k+1}, 0)$

所以就很简单了。

```cpp
inline void solve4() {
	puts("10");
	for(int i = 0; i < 10; i++)
		Cir(1 << i, 0, 0, 0);
}
```

## Data 5

还是 $10$ 步，要求得到 $(1000,0)$

我们发现最多可以从 $(125, 0)$ 开始倍增。

但是 $(125, 0)$ 怎么来呢？？

事实上我们可以利用负半轴！

$(125, 0)$ 可以由 $Cir((63, 0), (1, 0))$ 得到

$(63, 0)$ 可以由 $Cir((31, 0), (-1, 0))$ 得到

那么依此类推，就有：$(2^k-1,0)$ 可以由 $Cir((2^{k-1}-1, 0),(-1, 0))$ 得到。

而 $(-1,0)$ 可以由 $Cir((0, 0), (1, 0))$ 得到。

那么就可以照样倍增做了。

```cpp
inilne void solve5() {
	puts("10");
	Cir(0, 0, 1, 0);
	Cir(1, 0, -1, 0);
	for(int i = 2; i <= 5; i++) Cir((1 << i) - 1, 0, -1, 0);
	Cir(63, 0, 1, 0);
	Cir(125, 0, 0, 0);
	Cir(250, 0, 0, 0);
	Cir(500, 0, 0, 0);
}
```

---

# 3. 更难的数学知识

## Data 3

给出一个正方形 $ABCD$，请你求出 $CD$ 中点 $E$ 与 $A$，$B$ 组成的三角形 $\triangle ABE$ 的外心 $F$。

![](https://cdn.luogu.com.cn/upload/image_hosting/u08ucplj.png)

有一种 $naive$ 的想法：先找 $AB$ 的中垂线($3$ 步)，然后可以顺便找到 $E$，然后再找 $AE$ 的中垂线($3$ 步)，然后就可以找到 $F$ 了。

然后你就发现限制是 $5$ 步...

所以怎么办啊。。

之后我就瞎jb乱试，结果给我试出来了：

![](https://cdn.luogu.com.cn/upload/image_hosting/3utydotc.png)

为啥是作 $Cir(D, I)$ 呢？

因为我们发现 $DK = \frac{\sqrt{5}}{2}$，$BK=1$，然后设 $BL=x$

我们就有方程：$\frac{5}{4}-(1-x)^2=1-x^2$

解得 $x=0.375$...正好是我们要的坐标。。

左边的同理。那么我们就只需要 $5$ 步就可以解决辣！

```cpp
inline void solve3() {
	puts("5");
	Cir(0, 0, 1, 0);
	Cir(1, 0, 0, 0);
	db Y1 = 0.86602540378;
	Line(0.5, Y1, 0.5, -Y1);
	Cir(1, 1, 0.5, 0);
	Line(0.072975, 0.375, 1.927024, 0.375);
}
```

## Data 7

给出三个点，三个点能形成的夹角小于 $120^{\circ}$，请你求出这三个点形成的三角形的费马点 $P$。

首先不难想到构造一个等边三角形 $ABD$($D$与$C$在直线$AB$异侧)，费马点一定在直线 $CD$ 上。

构造的方法：$Cir(A,B)$，$Cir(B,A)$，$Line(C,D)$

这样我们就花了 $3$ 步确定了费马点所在的一条直线。

那怎么找另一条直线呢？

考虑这时候我们可以在 $CD$ 所在直线上找到与圆 $A$ 的另一个交点 $E$，不难发现 $\angle CPB = \angle EPB$...反正我们可以拿 $E$ 来找费马点，效果是一样的。

那么我们这时候已经有了 $Cir(A,E)$，所以就可以节约一步，这样就只需要 $5$ 步了。

![](https://cdn.luogu.com.cn/upload/image_hosting/tsb61dgd.png)

```cpp
inline void solve7()
	puts("5");
	Node A(0, 0);
	Node B(12.34441574, 0);
	Node C(5.16457145, 9.12243565);
	Cir(A, B), Cir(B, A);
	Node D(6.17220787, -10.690577625);
	Line(C, D);
	Node E(5.05577917978, 11.2616027654);
	Cir(E, A);
	Node F(17.40019491978, 11.261602765);
	Line(A, F);
}
```

## Data 8

给出一个三角形 $\triangle ABC$，求内接圆与 $AB$ 交点。

这个挺简单的吧。

用切线长定理，可以按照内切圆与三边的切点把三边分别分成三组对应相等的线段。

然后作圆把 $AC$ 和 $BC$ 放在 $AB$ 上之后，发现要求的点就在两个交点的中点处。

这样就只需要 作两个圆 + 求中垂线 就行了。$5$ 步解决。

![](https://cdn.luogu.com.cn/upload/image_hosting/etds379c.png)

```cpp
inline void solve8() {
	puts("5");
	Node A(0, 0);
	Node B(12.34441574, 0);
	Node C(5.16457145, 9.12243565);
	Cir(A, C), Cir(B, C);
	Node D(0.7354107776, 0);
	Node E(10.4829208931, 0);
	Cir(D, E), Cir(E, D);
	Node F(5.6091658353, 8.4415913837);
	Node G(5.6091658353, -8.4415913837);
	Line(F, G);
}
```

# 4. 二分

## Data 6

谁说二分被卡次数啊！！！

明明就只需要 $35$ 次好不好啊。。

一开始做这个的时候手动二分，用了 $31$ 次就做出来了。（感觉自己很有毅力的说。。）

~~密集恐惧症患者请务必看下图~~

![](https://cdn.luogu.com.cn/upload/image_hosting/o06kycpb.png)

$31$ 步后的精度误差：

![](https://cdn.luogu.com.cn/upload/image_hosting/fn6tl25s.png)

但是。

这题给的点是 $(0, 0)$ 和 $(0, 1)$...但我算的是 $(0, 0)$ 和 $(1, 0)$...

~~我人没了~~ 然后当场自闭。

然后觉得再手动二分不太现实，结果用程序实现了一下 $39$ 步的二分。然后发现checker给出了这个信息：

> wrong output format Extra information in the output file

？？？发生了什么？

我看看输出，挺对的啊，甚至到第 $35$ 步就已经达到 $10^{-5}$ 的精度要求了啊。。

然后仔细一看，发现说了 ${\rm Extra\ information}$。。

这什么 checker 还要要求不能冗余操作啊。。

于是就换成 $35$ 步就能过了。。

```cpp
inline void solve6() {
	Node A(0, 0), B(0, 1);
    Circle C(A, B), D(B, A);
	int On = 2;
	db Target = 0.42197248;
	puts("35");
	Line(0, 0, 0, 1);
	for(int i = 0; i < 17; i++) {
		if(On & 1) Cir(A, B), C = Circle(A, B), On |= 2;
		else Cir(B, A), D = Circle(B, A), On |= 1;
		Node X = C + D;
		Node Y(-X.x, X.y);
		Line(X, Y);
		Node T(0, X.y);
		if(T.y < Target) A = T, On &= 2;
		else B = T, On &= 1;
	}
}
```

## 5. 乱搞

## Data 9

这题以及接下来一题都是给你两个点，然后让你找到给定点。。

其实就是让你瞎猜，看你要多久能猜到。

怎么猜就不细说了，大概就看看有没有 共圆/共线 的情况，然后找到想要的圆心就行了。

大概是一个这样的惨状：(还是没有那个二分惨。。)

![](https://cdn.luogu.com.cn/upload/image_hosting/ipzzbn8l.png)

```cpp
inline void solve9() {
	puts("6");
	Node A(0.0);
	Node B(10.64978745, 0);
	Node C(-10.64978745, 0);
	Node G(-3.9647169635, 0);
	Node D(-5.324893725, 9.2229864766);
	Node E(5.324893725, 9.2229864766);
	Node F(-2.8891429893, -7.2931728544);
	Cir(A, B);
	Cir(B, A);
	Cir(C, A);
	Cir(E, C);
    Line(D, F);
	Cir(G, C);
}
```

## Data 10

这个点的图已经在上面了。大概就从第九个点扩展三步就到了。

```cpp
inline void solve10() {
	puts("9");
	Node A(0.0);
	Node B(10.64978745, 0);
	Node C(-10.64978745, 0);
	Node D(-5.324893725, 9.2229864766);
	Node E(5.324893725, 9.2229864766);
	Node F(-2.8891429893, -7.2931728544);
	Node G(-3.9647169635, 0);
	Node K(-2.1668572419, 6.4387784412);
	Node L(22.6154412357, 15.6487848684);
	Node I(21.2995749, 0);
	Node M(-13.0855381857, 10.3675016799);
	Node N(-6.5503572407, 8.3970704861);
	Cir(A, B);
	Cir(B, A);
	Cir(C, A);
	Cir(E, C);
	Line(D, F);
	Cir(G, C);
	Line(K, E);
	Line(I, M);
	Cir(N, L);
}
```