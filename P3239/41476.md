简化题意：

给定 $n$ 个技能，进行 $r$ 轮，令 $j=1$ 从 $j$ 开始，每张卡牌有 $p_j$ 的概率选择，如果选择，则进入下一轮，否则令 $j+1$，直到 $j>n$ 为止，同一张技能只能选择一次，最后得到的收益即为每一张选择的技能的 $d_i$ 之和。求最后期望的收益。

题解：

一道巧妙的概率期望 DP。

肯定要进行转化，可以发现，每一个技能的收益是独立的，所以可以求出每一个技能的收益再累加，换句话说，令 $h_i$ 表示第 $i$ 个技能被选择的概率，则答案为：

 $\sum\limits_{i=1}^n d_ih_i$，其中 $d_i$ 为已知量。
 
 现在考虑怎么求 $h_i$。
 
 直接没法求，~~又因为数据范围不大~~，可以增加一维。
 
 令 $f_{i,j}$ 表示前 $i$ 个中选 $j$ 个的概率，则最终的 $h_i$ 可以通过枚举转移得出。

要得出转移，必须要知道第 $i$ 个数被选的概率。而这个东西等于 $1-$ 它不被选的概率，而不被选的概率是 $(1-p_i)^{r-j}$，表示可能选到它的 $r-j$ 次都没选到（根据定义，有 $j$ 次选的前面的数）。

于是选的概率和不选的概率都可以求出。

所以：

$f_{i,j}=(1-(1-p_i)^{r-j+1})f_{i-1,j-1}+(1-p_i)^{r-j}f_{i-1,j}$

可以快速递推，但 $O(Tnr\log r)$ 乘上不小的常数很卡，所以可以预处理快速幂或者用 cmath 库中的 pow。

最后 $h_i$ 的答案即为 $\sum\limits_j(1-(1-p_i)^{r-j})f_{i-1,j}$（转移的概率）。

总体来说，非常巧妙，代码也很短。

```cpp
#include<cstdio>
#include<cmath>
#define re register
using namespace std;
int T,n,r;
double ans,p[252],d[252],f[252][252],xx;   
int main(){
	scanf("%d",&T);
	while(T--){
		scanf("%d%d",&n,&r);
		for(re int i=1;i<=n;++i)scanf("%lf%lf",&p[i],&d[i]);
		for(re int i=0;i<=n;++i)for(int j=0;j<=r;++j)f[i][j]=0;
		ans=0,f[0][0]=1;
		for(re int i=0;i<=n-1;++i){
			for(re int j=0;j<=i<r?i:r;++j){
				f[i+1][j]+=f[i][j]*(xx=pow(1-p[i+1],r-j)); 
				if(j<r)f[i+1][j+1]+=f[i][j]*(1-xx),ans+=f[i][j]*(1-xx)*d[i+1];
			}
		}
		printf("%.6lf\n",ans);
	}
}
```






