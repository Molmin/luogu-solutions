2020.11.14

提高阅读体验

------------


~~刚出题解就发现错误……~~

2020.3.22

修改一处括号问题

------------


一道很好的期望$dp$练手题

要求期望伤害，不难想到用每张牌的发动概率$g[i]$乘那张牌的伤害$d[i]$，最后根据期望的线性性质相加即可，故答案为

#### $\sum_{i=1}^ng[i]d[i]$

可怎么求$g[i]$呢？

首先不难求出$g[1]$，即第一张牌的发动概率，为

#### $g[1]=1-(1-p[1])^r$

再讨论第二张牌：

若之前第$1$张牌发动了技能，那第一轮肯定轮不到第二张牌发动，所以第二张牌发动的概率为

$1-(1-p[2])^{r-1}$

若之前第一张牌没有发动技能，那么第二张牌发动的概率为

$1-(1-p[2])^r$

欸，如果我们考虑第$i$张牌时知道$1$~$i-1$这i-1张牌中已经有j张牌发动过技能了，那么第$i$张牌此时发动的概率就应该等于$1-(1-p[i])^{r-j}$

我们构建一个$dp$模型：设$f[i][j]$为前$i$张牌恰好有j张发动技能的概率

若第$i$张牌发动了，那么
$f[i][j]=f[i-1][j-1]*(1-(1-p[i])^{r-j+1})[j>0]$

若第$i$张牌没发动，那么
$f[i][j]=f[i-1][j]*(1-p[i])^{r-j}[i\ne j]$

$dp$转移方程出来啦，附上这一部分的代码：
```cpp
for(int i=2;i<=n;i++){
	for(int j=0;j<=Min(i,r);j++){
		if(j)//第i张牌发动 
		f[i][j]+=f[i-1][j-1]*(1.0-Pw[i][r-j+1]);
		if(i!=j)//第i张牌不发动 
		f[i][j]+=f[i-1][j]*Pw[i][r-j];
	}
}
```

我们得出了所有的$f[i][j]$，那怎么求每张牌发动的概率$g[i]$呢？

$g[i]$应该为$\sum_{j=0}^{i-1}f[i-1][j]*(1-(1-p[i])^{r-j})$，即前1~i-1张牌中有j张牌发动的概率乘第i张牌发动的概率

这样，我们就愉快地A了这道题(有些细节见代码里的注释）

 _Code_ :
 ```cpp
#include<bits/stdc++.h>
using namespace std;
#define N 225
#define R 137

int n,r,t;
int D[N];//伤害
double P[N],f[N][R],g[N],Pw[N][R];
//P[i]表示第i张牌发动技能的概率
//f[i][j]表示前i张牌恰好有j张发动的概率
//g[i]表示第i张牌在r轮中发动的概率
//Pw[i][j]预处理,即(1-P[i])^j,第i张牌在最后j轮都不发动的概率 

int Min(int x,int y){return x<y?x:y;}

void read(){
	scanf("%d%d",&n,&r);
	for(int i=1;i<=n;i++){
		scanf("%lf%d",&P[i],&D[i]);
		Pw[i][0]=1; 
	}
}

void work(){
	if(!r){
		printf("%.10lf",g[0]);//即0
		return;
	}//当r等于0时代表没有进行游戏,输出0 
	for(int i=1;i<=n;i++){
		for(int j=1;j<=r;j++){
			Pw[i][j]=Pw[i][j-1]*(1.0-P[i]);
		}
	}//预处理 
	f[1][0]=Pw[1][r];
	f[1][1]=1.0-f[1][0];
	g[1]=f[1][1];//初始化 
	for(int i=2;i<=n;i++){
		for(int j=0;j<=Min(i,r);j++){
			if(j)//第i张牌发动 
				f[i][j]+=f[i-1][j-1]*(1.0-Pw[i][r-j+1]);
			if(i!=j)//第i张牌不发动 
				f[i][j]+=f[i-1][j]*Pw[i][r-j];
		}
	}
	for(int i=2;i<=n;i++){
		for(int j=0;j<=Min(i-1,r);j++){
			g[i]+=f[i-1][j]*(1.0-Pw[i][r-j]);
		}
	}//统计第i张牌在所有r轮中发动的概率 
	double ans=0;
	for(int i=1;i<=n;i++)ans+=g[i]*D[i];//期望得分,第i张牌发动的概率乘伤害 
	printf("%.10lf\n",ans);
}

int main(void){
	scanf("%d",&t);
	while(t--){
		memset(g,0,sizeof(g));
		memset(f,0,sizeof(f));//记得重置f,g数组 
		read();
		work();
	}
	return 0;
}
```

($p.s.$：本人第一道非红题题解，望兹磁)