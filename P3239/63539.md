首先，如果直接一轮一轮地进行期望推导，会发现前面有冲突的情况。枚举第 $i$ 轮第 $j$ 张卡时既要保证**前 $i-1$ 轮都没有发动过第 $j$ 张卡**，又要保证**第 $i$ 轮没有发动过前 $j-1$ 张卡**，再乘 $p_i$ 算概率。但是这样怎么算都算不对，其实感觉也是一个“意识”调题的过程吧，反正最终把样例调到 $3.21$ 左右发现概率对不上（样例解释），于是还是放弃了。

因此考虑建立**无后效性的dp**方程。因为需要满足 “如果发动了当前的卡”，那么就停止本轮，所以方程需要和前缀有关。令 $f[i][j]$ 表示在所有的 $r$ 轮里，前 $i$ 张卡有 $j$ 个发动了的概率。此时对于任意的第 $k$ 张卡就可以用 $f[k-1]$ 有关的数据推出来了。

考虑状态转移方程，对于 $f[i][j]$，可以从 $f[i-1][j-1]$ 或 $f[i-1][j]$ 推过来。当从 $f[i-1][j]$ 推过来时，表示第 $i$ 张**整场都没有发动**，因此 $f[i-1][j]$ 的贡献为 $f[i-1][j]\times (1-p_i)^{r-j}$。

其中 $(1-p_i)^{r-j}$ 表示在全部 $r$ 轮中，由于在前 $i-1$ 个中钦定了 $j$ 个，**占用了 $j$ 轮**，剩下的 $r-j$ 轮中每次都没有发动第 $i$ 张卡。

同时，为了便于理解，当我们dp做到 $f[i]$ 时，如果认为第 $i$ 张卡为此时的第一张卡，剩下的 $r-j$ 轮里就只能选择下标为 $[i,n]$ 的卡了。此时第 $i$ 张卡的发动不受前 $i-1$ 张的限制。

当从 $f[i-1][j-1]$ 推过来时（首先要满足 $j>0$），表示第 $i$ 张被发动了，**正难则反**，被发动的概率就是用 $1$ 减去没有被发动的概率。而没有被发动的概率在上文中被提到了，是 $(1-p_i)$ 的幂。此时由于只钦定了 $j-1$ 张卡发动，所以指数为 $r-j+1$。因此 $f[i-1][j-1]$ 的贡献为 $f[i-1][j-1]\times\left(1-(1-p_i)^{r-j+1}\right)$。

然后可以依次求出所有的 $f$，此时我们再根据 $f$ 推出每张卡被发动的概率 $P_i$。

仿照上面 $f[i-1][j-1]\to f[i][j]$ 的过程，我们可以直接算出 

$$P_i=\sum_{j=0}^{i-1}f[i-1][j]\times \left(1-(1-p_i)^{r-j}\right)$$

答案是对每个 $P_i$ 乘上伤害值 $d_i$。

对每个 $(1-p_i)$ 预处理幂后，时间复杂度为 $O(nTr)$。

## Code：

```cpp
#include<cstdio>
#include<cstring>
#define db double
db f[233][233],p[233];
db q[233][233];//q[i][j]表示(1-p[i])^j
int d[233];
int main()
{
    int T;
    scanf("%d",&T);
    while(T--)
    {
        int n,r;
        scanf("%d%d",&n,&r);
        for(int i=1;i<=n;++i)
        {
            scanf("%lf%d",&p[i],&d[i]);
            q[i][0]=1;
            for(int j=1;j<=233;++j)
                q[i][j]=q[i][j-1]*(1-p[i]);
        }
        f[0][0]=1;
        for(int i=1;i<=n;++i)
            for(int j=0;j<=i&&j<=r;++j)
            {
                f[i][j]=j?f[i-1][j-1]*(1-q[i][r-j+1]):0;
                f[i][j]+=f[i-1][j]*q[i][r-j];
            }
        db ans=0;
        for(int i=1;i<=n;++i)
            for(int j=0;j<i&&j<r;++j)
                ans+=d[i]*(f[i-1][j]*(1-q[i][r-j]));
        printf("%.10lf\n",ans);
    }
    return 0;
}
```