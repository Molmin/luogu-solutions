这题确实可以用小学数学解决（后三位除8，证明方法就是$a×1000+bcd$中，1000%8=0）。

但是，但是！  
可以打表的！  
好吧不能完全叫打表。  
我们先来看一下可实现性：  
从0————999...99(100个9)  
但是，你不要忘了小学数学！  
他无外乎位数小于三位的数和位数大于三位的数。  
位数大于三位的数，可以用$a×1000+bcd$表示    
也就是说，问题又转换成了找三位数的问题（因为往高了去的都是靠后三位被8整除的）。  
~~我是不会告诉你我怕再写一篇一样的不会被通过才来打表的~~  
换句话说，我们只需要把能被8整除的三位数写出来就可以了。  
然后你又可以说：那也很多啊，怎么，你要...  
### 方法一  
我们可以看到很多可以被八整除的数形如：416,808。  
而他们根！本！就！不！用！枚！举！出！来！  
很简单啊：16、8/0在一开始就会被输出，管你什么别的。  
那同理800多你就不用管了，形如×0×、××0、×00、×16、×24、××8...你都不用管了。  
然后打表。  
### 方法二
我们是谁啊？OIer啊！~~我们的目标是？AK IOI!~~  
我们可以用程序啊！  
这样问题就简单了，造出8倍数的i，然后
~~~
a=s.find("i");
    if(a<s.size())
    {
        printf("YES\ni");
        return 0;
    }
~~~
就完了呗。  
且慢！这有个极大的漏洞！方法一的众人也请注意！  
一个问题：526到底该输出Yes/n56呢，还是NO呢？  
当然，蒟蒻都知道，该输出前者，但是！你这样的程序会输出后者！  
原因很简单，你判断的是连着的！  

#### 改进  
不要怕吗，遇到困难应该继续前进！  
这个题有个温馨提示，顺序不会被打乱的，那就...  
循环套循环！  
比如526：  
~~~
a=s.find("5");
    if(a<s.size()-1)
    {
        for(int i=1...)
        {
         b=s.find("6");
         ...
        }
    }
~~~
这样就可以特判了——虽然时间很尴尬。   
或者继续用方法一勤奋的思想，特判这些数  
~~~
a=s.find("526");
    if(a<s.size())
    {
        printf("YES\n56");
        return 0;
    }
~~~
这样也行，就是码量增加，且一忘皆无...

#### code
不是吧阿sir，这破题打表代码都要？
