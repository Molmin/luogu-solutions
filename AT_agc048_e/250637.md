首先点进题目，还没给 $f$ 完整定义呢，啪的一下就看见一个巨大的

> It can be proved that there always are sequences that satisfy the conditions and that the number of those sequences is finite.

而这样的序列个数有限是显然的，值域摆在那撑死也就 $n!$ 种，我们不妨先行考虑一下题目告诉我们的一定有序列满足条件这个事情怎么证明。我们发现这个约束相当逆天，站在整体的角度难以调控。那我们只能换个视角，试试看能不能证明这样一个性质：对于任意合法的 $x_1,x_2,\cdots,x_{i-1}$，一定存在一个合法的 $x_i$。

我们考虑维护一个变量 $p$ 在自然数集上从零开始扫，并同时维护一个变量 $q$ 表示 $-p+\sum_{j=1}^{i-1}[A_j+T\times x_j\lt A_i+T\times p]$。容易发现，当且仅当 $q=0$ 的时候，赋 $x_i$ 为 $p$ 是合法的。而我们考虑，在 $p=0$ 时，$q$ 非负；而在 $p=i-1$ 时，$q$ 非正。观察到当 $p$ 增大一的时候，$q$ 可能一并增大很多，但减少只有至多一。如此，$q$ 不可能一步从正数跳到负数，一定存在一个 $p$ 使 $q=0$，此时赋 $x_i=p$ 即可。

以上的性质启示我们，其实字典序这个东西是可以贪心做的。我们先来观察一下对于给定的 $A$ 和 $T$，$f(A,T)$ 有没有什么奇奇怪怪的性质。首先最容易发现的就是 $x_1=0$。随后我们观察上面证明的过程，$x_i=p$ 是最大的，代表着把 $p$ 增大一的时候维护的 $q$ 值减少恰好一（否则 $[p+1,n-1]$ 的区间上依然可以跑上面那个证明），而这也说明了 $\sum_{j=1}^{i-1}[A_j+T\times x_j\lt A_i+T\times p]$ 此时没有任何变化。方便起见我们记 $z_i=A_i+T\times x_i$，那么也就是说不存在 $1\le j\le i-1$ 使得 $z_j-T\lt z_i\le z_j$。作为一个统一的约数，注意到 $x_1=0$，换而言之 $z_1=A_1$，那么我们可以得到 $A_1-T\lt z_i\le A_1$ 对一切 $1\lt i\le n$ 都一定不成立。

接下来我们可以干一件比较震撼的事情：删掉 $x_1$，然后把所有 $z$ 值大于 $A_1$ 的 $x$ 减掉一，研究一下会发生什么。考虑 $z$ 值之间的偏序关系。对于两个都没减或者两个都减了的 $z$，显然没有任何变化；对于恰有一个减了的 $z$，显然是减了的那个 $z$ 原来比较大，同时注意到这个 $z$ 恰好减了 $T$，而且它本来在 $A_1$ 之上，那现在依然在 $A_1-T$ 之上，而没减的那个 $z$ 本来在 $A_1$ 之下，**那由我们在上一段推出的结论可以得知它一定在 $A_1-T$ 之下**，换而言之，还是减了的 $z$ 大。同时，变化前后的序列的字典序最大性是彼此可以互推的。

如此一来，我们可以敏锐地观察到，变化后的 $x$ 即为 $f(A_{[2,n]},T)$。这为我们启示了一个比较震撼的事实，在已知 $A_1$ 的情况下，由 $f(A_{[2,n]},T)$ 推到 $f(A,T)$ 的变化实际上是相当简单的，而且每一项之间相当独立。举个例子，如果我们现在已知了 $A_1,A_n$ 和 $f(A_{[2,n]},T)$ 的最后一项，$f(A,T)$ 的最后一项是相当好求的。那么据此，我们就可以设计 DP 来统计 $f(A_{[i,n]},T)$ 的给定项是 x 的方案数了。DP 的步骤相当简单，按递推关系直接刷表即可，在此不再赘述。

```cpp
#include <atcoder/all>
using namespace std;
typedef atcoder::modint1000000007 mint;
constexpr int N = 59;
int n, k, t;
vector<int> b[N];
signed main() {
  cin.tie(nullptr)->sync_with_stdio(false);
  cin >> n >> k >> t;
  for (int i = 1; i <= n; ++i) {
    b[i].resize(k);
    for (int& x : b[i]) cin >> x;
  }
  for (int i = 1; i <= n; ++i) {
    mint ans = 0;
    for (int a : b[i]) {
      mint f[N][N];
      f[i][0] = mint(k).pow(n - i);
      for (int p = i - 1; p; --p)
        for (int q = 0; q <= n; ++q)
          for (int a1 : b[p]) {
            int nq = q + (a1 < a + (q + 1) * t);
            f[p][nq] += f[p + 1][q];
          }
      for (int q = 0; q <= n; ++q) ans += f[1][q] * q;
    }
    cout << ans.val() << '\n';
  }
  return cout << flush, 0;
}
```

---

写在最后：

这题的官方题解写得什么玩意，几个重要结论基本一个没证……