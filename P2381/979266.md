### 题意;
给定 $N$ 只奶牛所在的圆圈，在圆圈上每两只相邻的奶牛之间有一个距离，奶牛可以按顺时针或逆时针方向走到相邻的奶牛，距离为较短的路程。

现在要求在圆圈上找到距离最远的两只奶牛，输出它们之间的距离。
### 解题思路：

建议先手画几个奶牛的圆圈，模拟一下题目中给的样例。画图的时候，可以把这些奶牛的顺序放在顺时针方向或者逆时针方向。

以顺时针方向为例，那么包含奶牛 $1$ 在内的第 $i$ 个奶牛的位置距离圆圈起点的顺时针距离为：

$$p_i = p_{i-1} + dis_i$$

其中 $dis_i$ 表示第 $i$ 个奶牛和第 $i+1$ 个奶牛之间的距离，$p_0=1$ 表示圆圈起点（可以看出来 $p$ 就是前缀和数组）。

从上述公式中可以看出，$p_i$ 是一个单调递增的序列。

因为题目要求的是相距最远的两个奶牛之间的距离，那么我们可以枚举其中一个奶牛，然后找到离它最远的奶牛。

如何找到离它最远的奶牛呢？因为 $p_i$ 是单调递增的，所以如果要找到离奶牛 $i$ 最远的奶牛，需要找到一个最小的 $j$，满足 $p_j-p_i > \frac{p_n}{2}$。

因为可以顺时针走到奶牛，也可以逆时针走到奶牛，所以需要判断顺时针路径和逆时针路径谁更短。

### 算法实现：

先读入所有奶牛的圆周距离，然后计算 $p_i$。

然后枚举奶牛。对于每个奶牛 $i$，在 $p$ 中二分查找到最小的满足条件的 $j$，然后计算出两个奶牛间的最短距离和最长距离。

因为圆有着对称性，所以在两边都需要取最小值。

时间复杂度为 $O(N\log N)$。

### 完整代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll N=200200;
inline ll read(){
    ll x=0,f=1;
    char c=getchar();
    while(c<'0'||c>'9'){
        if(c=='-')
            f=-1;
        c=getchar();
    }
    while(c>='0'&&c<='9'){
        x=(x<<1)+(x<<3)+(c^48);
        c=getchar();
    }
    return x*f;
}
inline void write(ll x){
	if(x<0){
		putchar('-');
		x=-x;
	}
	if(x>9)
	  write(x/10);
	putchar(x%10+'0');
}
ll n,p[N],ans=0,l=1,r=0;
int main(){
	n=read();
	for(int i=1;i<=n;++i){
		p[i]=read();
		p[i+n]+=p[i];
		p[i]+=p[i-1];
	}
	for(int i=n+1;i<=n*2;++i)
	  p[i]+=p[i-1];
	double t=(double)p[n]/2.0;
	for(int i=1;i<=n*2;++i)
	  p[r+1]-p[l]<=t?ans=max(ans,p[++r]-p[l]):++l;
   write(min(ans,p[n]-ans));
   return 0;
}
```
大家回去自己推一下，看看能不能找到更优秀的算法~