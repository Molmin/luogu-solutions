## 简要题意

有 $n$ 个字符串，将这 $n$ 个字符串按照一定的顺序首尾相接连在一起。求连成的字符串中最多有几个 `AB` 子串。

## 做法

经过对题意的一通分析，我们知道连成字符串中一个 `AB` 子串有两种来源：

1. 这个 `AB` 是原来 $n$ 个字符串中的一个的子串。这就意味着，无论这 $n$ 个字符串以什么顺序连接，这些 `AB` 子串的数量是不变的。
2. 这个 `AB` 子串是两个字符串连接时形成的。这就必须满足前一个串的最后一个字符是 `A`，后一个串的第一个字符是 `B`。

***

对于 1，我们只需要在一开始把符合条件的 `AB` 子串数出来。

对于 2，我们就必须进行分类讨论。

设三个整型变量：$sa$、$sb$、$sab$，其中 $sab$ 表示由 `B` 结尾，由 `A` 开头的字符串的个数，$sa$ 表示不由 `B` 结尾，但以 `A` 开头的字符串的个数，$sb$ 表示由 `B` 结尾，但不由 `A` 开头的字符串的个数。

现在，我们有了 $sa$ 个 `xxA` 形式的串，$sb$ 个 `Bxx` 形式的串，$sab$ 个 `BxA` 形式的串。接下来进行如下操作：

（第一步）将所有 `BxA` 形式的串先首尾相接，连到一起，变成：

```
BxA BxAB ....A BxA
```

总共形成了 $sab - 1$ 个 `AB`。

(第二步）将一个 `xxA` 接到上面的字符串前面，再将一个 `Bxx` 接到字符串的末尾，变成：

```
xxA BxA BxAB ....A BxA Bxx
```

又多形成了 $2$ 个 `AB`。

（第三步）最后将剩余的 `xxA` 和 `Bxx` 两两配对，一个 `xxA` 和一个 `Bxx` 会形成：

```
xxA Bxx
```

最后多形成的 `AB` 串个数是 $sa-1$ 和 $sb-1$ 的最小值。

（为什么要减一？因为在第二步的时候已经有用掉了一个 `xxA` 和一个 `Bxx`）

当然，上述的操作都是对于每种串都大于等于 $1$ 个的情况。真实情况会稍微复杂一点。具体细节参见以下 AC 代码注释：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,len,sa,sb,sab,ans;
main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
		char str[49];
		scanf("%s",str);
		len=strlen(str);
		if(str[0]=='B'&&str[len-1]=='A')sab++;
		else if(str[0]=='B')sb++;
		else if(str[len-1]=='A')sa++;
		for(int i=0;i<len-1;i++)if(str[i]=='A'&&str[i+1]=='B')ans++;
	}
	if(sa&&sb&&sab)ans+=sab-1+2+min(sa-1,sb-1);//可以完成第一步、第二步、第三步。
	else if(sa&&sb)ans+=min(sa,sb);//当sab==0，就无法做第一步，由于没有第一步，所以也无法完成第二步。因此这次只能完成第三步，因为第二步没有做，所以不用减一。
	else if(sa&&!sb&&sab||!sa&&sb&&sab)ans+=sab;//只能完成第一步，第二步只能做一半。
	else if(!sa&&!sb&&sab)ans+=sab-1;//只能完成第一步
	return printf("%d\n",ans),0;
}
```