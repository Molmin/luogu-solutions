## 引子

这是蒟蒻柒米的第二篇题解，请多关照。

随机跳转到的一道 AT 黄题，发现能做，也还没有题解，就顺便写了篇。

[更好的阅读体验](https://www.luogu.com.cn/blog/528540/solution-at-diverta2019-c)。

## 题面

[原题面：https://www.luogu.com.cn/problem/AT_diverta2019_c](https://www.luogu.com.cn/problem/AT_diverta2019_c)

题意简述：

有 $ N $ 个字符串，将它们以某种顺序连接成一个新字符串， 求这个新字符串中子串 $\texttt{AB}$ 的最大可能出现次数。

## 思路

简单分析了一下：

+ 每个字符串中间的 $\texttt{AB}$ 不因拼接而改变。可以直接统计。

+ 每个字符串结尾的 $\texttt{A}$ 字符和开头的 $\texttt{B}$ 字符可能会额外影响到最后的结果。

+ 那么可以将所有用于拼接的字符串分为四类：

  1. 以 $\texttt{A}$ 结尾；

  2. 以 $\texttt{B}$ 开头；

  3. $\texttt{A}$ 结尾，$\texttt{B}$ 开头，二者兼备；

  4. 啥也没有。

想一想，发现可以分类讨论。

- 首先，肯定是 “$\texttt{A}$ 结尾，$\texttt{B}$ 开头，二者兼备” 的字符串比较好用。只要将所有这类字符串首尾相接就行了。

- 其次，那类首尾相接的字符串，前面还可以接一个 “以 $\texttt{A}$ 结尾” 的字符串，后面也能接一个 “以 $\texttt{B}$ 开头” 的字符串。且如果有这两类字符串拼接到头尾的话，效益最大化。

- 考虑首尾相接的字符串可能出现的不同效益。设有 $\text{x}$ 个第三类字符串，如果没有第一、二类字符串与它相接，收益为 $\text{x - 1}$；如果有一种与它相接，收益为 $\text{x}$；如果头尾都接上了，收益为 $\text{x + 1}$。

- 最后，将可能剩余的 “以 $\texttt{A}$ 结尾” 和 “以 $\texttt{B}$ 开头” 的两类字符串两两配对，每对都能贡献 1 个子串。

- 那么最后可能的落单的 “以 $\texttt{A}$ 结尾” 或 “以 $\texttt{B}$ 开头” 的字符串，还有啥也没有的字符串，就不能产生额外贡献了。

假设这里已经统计出了所有字符串中间的 $\texttt{AB}$ 的数量和前三类字符串的数量，分别存储在变量 $ans$，$a$，$b$，$c$ 中。

那么按以上策略分类讨论进行拼接，我们便有了以下代码：

```cpp
if(a && b && c) cout << ans + c + 1 + min(a - 1, b - 1); //中间子串 + 贡献拉满的第三类字符串 + 一、二类组合所得
else if(a && b && !c) cout << ans + min(a, b); //由于没有第三类字符串，所以中间子串 + 一、二类组合
else if(a && !b || !a && b) cout << ans + c; //中间子串 + 由于只有一、二类字符串中的一种，所以第三类字符串只能加上接头或尾的贡献
else if(!a && !b && c) cout << ans + c - 1; //中间子串 + 由于没有一、二类字符串，所以只有第三类字符串单独的贡献
else cout << ans; //啥也没有，只有中间字符串
```

那就先把所有字符串中间的 $\texttt{AB}$ 子串和不同类别的字符串统计出来吧。

## 输入 & 统计

这里不多赘述，在输入用于拼接的字符串数量 $N$ 后，以字符串数组存储后续的输入

如上，分别用变量 $ans$，$a$，$b$，$c$ 来统计字符串中间的 $\texttt{AB}$ 子串数量和上文所述的前三种字符串的数量。

至于第四类，啥也没有的，无法作出额外贡献，就无需统计了。可以理解为将所有这类字符串随便拼到了最后面。

## 完整代码

只要补齐框架、定义和输入就可以了。

```cpp
#include <bits/stdc++.h>
using namespace std;
string str[10001];
int main(){
	int n;
	cin >> n;
	int ans = 0, a = 0, b = 0, c = 0;
	for(int i = 1; i <= n; i ++){
		cin >> str[i];
		int len = str[i].size();
		for(int j = 1; j < len; j ++) //遍历一遍以统计字符串中 "AB" 的数量
			if(str[i][j - 1] == 'A' && str[i][j] == 'B') ans ++;
		if(str[i][len - 1] == 'A' && str[i][0] == 'B') c ++;
		else if(str[i][len - 1] == 'A') a ++;
		else if(str[i][0] == 'B') b ++; //这里需要注意一下判断不同类别的顺序
	}
	if(a && b && c) cout << ans + c + 1 + min(a - 1, b - 1);
	else if(a && b && !c) cout << ans + min(a, b);
	else if(a && !b || !a && b) cout << ans + c;
	else if(!a && !b && c) cout << ans + c - 1;
	else cout << ans;
	return 0;
}
```

## Ending

- Upd on 23.1.2：调整了一些变量和字符串常量的 $\LaTeX$，修改了讲解顺序，删去了一些冗余部分。

完结撒花！！

有问题或 hack 之类的要艾特柒米哦，也欢迎在评论区指出或私信我。

*22.12.28*