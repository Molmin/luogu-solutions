## P1318 积水面积
#### 首先，我想到，对于一个高为$x$的柱子$i$，在以$i$为左端点的积水区域，它积水的高度最大是$x$，往右不断往右寻找一个柱子，如果一根柱子$j$的高度大于目前寻找的总高度，那么一定会产生积水现象。
#### 如果小于等于目前寻找的总高度，可能会出现积水现象，但是我们把它归为另外区间的积水现象。
```
for(int i=1;i<=a;i++){
	for(int j=i+1;j<=a;j++){
		if(s[j]>mx){//如果一根柱子的高度大于目前寻找的总高度
			som+=(s[j]-mx)*(j-i-1);//将它的与左端点距离乘与之前最高的柱子的高度差得到积水面积
			mx=s[j];//更新目前最高
		}
	}
	mx=0;
}
```
#### 但是如果有一个柱子比当前最高的柱子高，也比那根左端点的柱子高，则需要特判，因为左端点构造不成一个太高的积水现象。
```
if(s[j]>s[i]){//判断是否大于左端点
	som+=(s[i]-mx)*(j-i-1);//直接用左端点与之前最高作差再乘距离之差
}
```
#### 得到代码：
```
#include<bits/stdc++.h>
using namespace std;
int a,mx,som;
int s[10001];
int main(){
	scanf("%d",&a);
	for(int i=1;i<=a;i++)
	scanf("%d",&s[i]);
	for(int i=1;i<=a;i++){
		for(int j=i+1;j<=a;j++){
			if(s[j]>mx){
				if(s[j]>=s[i]){
					som+=(s[i]-mx)*(j-i-1);
				}
				som+=(s[j]-mx)*(j-i-1);
				mx=s[j];
				if(mx>=s[i])//进行特判加快速度
				break;
			}
		}
		mx=0;
	}
	printf("%d",som);
	return 0;
}
```
#### 其实本题已有大佬说出了$O(n)$的做法，但本人懒得写，因为数据太水