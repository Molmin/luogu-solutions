逛了一圈看见没有大佬和我思路一样，于是赶紧来写下题解

~~可能是字符串做多了吧……~~

简单阐述一下吧：

我们先来看几张样例变形后的图（图就不要太挑剔了，毕竟是画图出品，我尽力了）：

思路：

**~~逆向思维大法好啊！~~**

我们可以把整个图形中不能积水的地方全部都标记出来，这样剩下的地方就是能积水的啦！

**具体操作**

生成初步的图形就不说了，玩玩全全的生成垂直柱状图，有方块的是不可能积水的啊

1.顺旋转90度以后，我们垂直向下将没有本来不存在的方块补上，直到遇见了第一个这一列存在的方块就停止这一列的补空，于是图就成了这个样子：

![](https://cdn.luogu.com.cn/upload/image_hosting/v426uoit.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

2.同理，逆时针旋转90度后补空就是这样：

![](https://cdn.luogu.com.cn/upload/image_hosting/ludoyqqs.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

3.最后再把两张图综合一下，就得到了一个完整的矩形：

![](https://cdn.luogu.com.cn/upload/image_hosting/pvurdo53.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

4.这个时候题目就变得非常简单了，我们只需要遍历整个矩形，找到没有方块的地方的个数，这个个数就是积水的面积了。

上面是做法，思考了一下为什么可以这样做：

1.其实补上空缺的方块就相当于是把不积水的地方给排除掉，剩下的就是能积水的地方

2.垂直向下补空，直到遇见第一个原本就存在的方块（可以把旋转后的图形当成一个建筑，下雨的时候，被楼上遮盖的地方是不会淋雨的），这样自然就不会把中间的凹槽给补上。两侧都如此操作一下，就可以排除所以不积水的地方啦！

我们就用一个字符数组来储存。

下面代码实现就很简单了，注释都在代码中了，不能积水的地方用‘*’表示（其实用什么表示都差不多），可以积水的地方就是空的

```
#include<bits/stdc++.h>
using namespace std;
int n,s[10005],tot=0,h=0;//s是每个位置上方块的高度，tot计数，h为整个矩阵的高度
char mp[10005][5005];//储存整个矩阵中每个位置的状态
int main(){
	cin>>n;
	for(int i=0;i<n;i++){
		cin>>s[i];
		h=max(h,s[i]);//记录下摞的最高的方块，方便生成最初的图形
	}
	for(int i=h;i>0;i--){//从最高高度开始往下依次储存
		for(int j=0;j<n;j++){
			if(s[j]>=i) mp[i][j]='*';//高度够高，就储存‘*’和生成垂直柱状图类似
		}
	}
	for(int i=h;i>0;i--){//从最高高度开始往下依次补空（从下到上也可以）
		for(int j=0;j<n;j++){//从左到右补空
			if(mp[i][j]=='*') break;//遇到原来就有方块的地方就停止补空
			else mp[i][j]='*';
		}
	}
	for(int i=h;i>0;i--){//和上面同理
		for(int j=n-1;j>=0;j--){//从右到左补空
			if(mp[i][j]=='*') break;
			else mp[i][j]='*';
		}
	}
	for(int i=h;i>0;i--){//开始进行统计
		for(int j=0;j<n;j++){
			if(mp[i][j]!='*') tot++;//如果不是积不了水的地方就计数
		}
	}
	cout<<tot;//输出
	return 0;
} 
```