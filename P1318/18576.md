### 这一题其实有一种较优解法

如果数据左右两边比较高，中间就不用判断，里面就是所有填水，比如这个数据：0 8 0 1 2 0 2 7 0
![](https://cdn.luogu.com.cn/upload/pic/16898.png)
看看这个五毛图理解一下？不要太挑剔，毕竟是画图出品（逃

这样我们就可以找出两边最大值里的最小值来判断，去除当前的砖块高度就可以得到一列的水高
```cpp
#include<bits/stdc++.h>
//万能头大法好
using namespace std;
int main()
{
	int a[10001]={0},l[10001]={0},r[10001]={0},n,sum=0; //数组清零&定义n和答案
    //a用来储存原数据，l用来储存从左到右的最大值，r用来储存从右到左的最大值
	cin>>n;
	for(int i=1; i<=n; i++)
	{
		cin>>a[i]; //读入原数据
		l[i]=max(l[i-1],a[i]);
        //这里很重要！这是至i为止左边最高的高度
	}
	for(int i=n; i>=1; i--)
		r[i]=max(r[i+1],a[i]);
        //至i为止右边最高的高度
	for(int i=1; i<=n; i++)
	{
		if(min(l[i],r[i])-a[i]<0) sum+=0;
        //如果为负数，则说明当前的比较高，不可能积水，所以把0加上/或者不加0
		else sum+=min(l[i],r[i])-a[i];
        //因为只能积水到最低的高度处，所以用min。然后再减掉原来的高度，就可以等于i处砖块以上水的面积，如果是0的话也不用特判~
	}
	cout<<sum; //输出一下答案
	return 0;
}
```