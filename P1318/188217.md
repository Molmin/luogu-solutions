看着他们的题解怎么那么多啊，不就是个模拟嘛，又不会超时，所以蒟蒻我又来发模拟代码喽

先说一下思路吧，身为蒟蒻，并没有去考虑区间，只考虑当前这一个位置下的存水高度，那么怎么算呢，很简单的。

只需要找出左边最高的和右边最高的，只要都比这个高度高，然后在两个高度里面找出较低的那个，加答案的时候再减去这个高度就好了嘛。

但是我要说明一点，因为数据得问题，我水过去了，如果数据很大的话，我这个做法应该会超时，因为每个点都会进行好多好多次循环，时间浪费太大了，但是可以优化，只不过我就要放学了，所以就没去写，下次补上昂

怎么优化呢，对于左边最高，一直取最大的就行，但是右边，可能当前最高并不是所有点的相对最高，加上一个if判断一下，虽然还需要循环，但是还是节省了很多时间的，我简单写了下

```
if(a[i]==you)
{
	you=0;
	for(int j=i+1)
	 you=max(you,a[j]);
} 
```
这样就可以更新我们的右边了，至于加到什么地方，自己琢磨琢磨吧，不难想的

还有一个小小的事情，无论第一个点和最后一个点多么大，都存不住水，这没错吧，那么我们就可以忽略这两个点的存水情况，循环直接 2->n-1 就可以了

这就是我的解题思路了，下面奉上AC但是丑陋的代码：

```
#include<bits/stdc++.h>//偷懒专用库 
#define ll long long
#define INF 520
#define MAXN 99999//宏定义 
using namespace std;

inline int read(){
  char c=getchar();int x=0,f=1;
  while(c<'0'||c>'9'){if(c=='-') f=-1;c=getchar();}
  while(c>='0'&&c<='9'){x=x*10+c-'0';c=getchar();}
  return x*f;
}//这里是快读哈，想学的可以借鉴借鉴，比我会的dalao就当没看见昂 

int  n,ans,zuo,you;//n表示数，ans记录答案，zuo是当前点左边最大的高度，you是当前点右边最大的高度 
int a[MAXN];//记录高度 

int main()//主函数部分 
{
	n=read();//读入n 
	for(int i=1;i<=n;++i)
	 a[i]=read();//读入高度 
	for(int i=2;i<n;++i)//为什么从2？为什么到n-1？这是因为1和n多么高，都存不住啊 
	 {
	 	zuo=you=0;//清零 
	 	for(int j=i+1;j<=n;++j)//找右边最高的 
	 	  {
	 	     if(a[j]>a[i]&&a[j]>you)//要比这个点高并且要找最高的 
			    {
			       you=a[j];
			    }	
		  }
		 for(int j=i-1;j>=1;j--)//和右边一样 
		  {
		  	if(a[j]>a[i]&&a[j]>zuo)
		  	 {
		  	 	zuo=a[j];
			 }
		  }
		if(zuo>a[i]&&you>a[i])//这个是判断是否能存，因为有可能这个点就是最高点，那样会减出一个负数，影响答案 
		 ans+=(min(zuo,you)-a[i]);//取左右两边较小的高度，还要减去这个点的高度，自己体会一下，画个图就知道了 
	 }
	cout<<ans;//输出 
	return 0; //养成好习惯，从你我做起哦 
}
```
