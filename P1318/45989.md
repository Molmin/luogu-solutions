#### 刚看这道题，以为就求个差分，将负的取个反加起来（太垃圾了），发现好像不行
原思路是比较光和前一个进行比较，明显错误

后来又改为和前后两个进行比较，发现还是错的（太弱了），因为存在像1234321234的情况

但不屈于现状的我还是不想用题解的方法解决

终于发现了一个惊天大秘密（都怪我垃圾）

### 思路如下
先找到最大值出现的第一个位置和第最后个位置，然后会发现从第一个不为0的数到最后一个最大值的位置如果加满水应该是单调不下降的，最后一个不为0的位置到第一个最大值的位置从后往前也是单调不下降的，从第一个数往最后一个最大值扫的时候，只用和他前面的进行比较，保证大于等于她前面的，若不是，记录差值，让他等于前一个，从后往前扫的思路相同。
### 代码如下
```
#include<iostream>
using namespace std;
int main()
{
	int n,a[10002],maxa=0,maxi,maxa2=0,maxi2,sum=0,f01,f02,d=0;//maxa，maxa2为最大值，maxi，maxi2为第一个最大值和最后一个最大值的位置，sum记录答案，f01，f02为第一个和最后一个不为0的数的位置
	cin >> n;
	for (int i = 1; i <= n; i++)
		cin>>a[i];
	for (int i = 1; i <= n; i++) {
		if(a[i] != 0 && d==0) f01 = i, d=1;//记录第一个不为0的位置，如果已经出现，将d赋值，以后将不对其造成影响
		if(a[i] != 0) f02 = i;//记录最后一个不为0的数
		if (a[i] > maxa) {
			maxa = a[i]; //记录第一个最大的数
			maxi = i;//记录第一个最大的数的位置
		}
		if (a[i] >= maxa2) {
			maxa2 = a[i];//记录最后一个最大的数的
			maxi2 = i;//记录最后一个最大的数的位置
		}
	}
	for (int i = f01+1; i <= maxi2; i++) {
		if (a[i] < a[i-1]) {//若从第一个不为0的数到最后一个最大的数中存在不是单调不下降
			sum = sum + a[i-1] - a[i];//记录答案（记得面积及高度）
			a[i] = a[i-1];//将此处水填满
		}
	}
	for (int i = f02-1; i >= maxi; i--) {//从最后一个不为0的数到第一个最大数时与上方思路一致
		if (a[i] < a[i+1]) {
			sum = sum + a[i+1] - a[i];
			a[i] = a[i+1];
		}
	}
	cout<<sum;
}
```