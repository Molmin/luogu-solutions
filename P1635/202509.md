观察到 $(4x + 3 = 2(2x + 1) + 1)$  以及  $(8x + 7 = 2(2(2x + 1) + 1) + 1)$

所以可以把 $(xx -> 2x + 12x + 1)$ 当成一个基本变化

则 $(xx -> 4x + 3)$ 是两个基本变化，$(x -> 8x + 7)$ 是三个基本变化

所以可以模拟一个基本变化

当基本变化次数大于 $300000$ 是结束迭代

因为要使两个变化之和最小，所以尽量多用 $xx -> 8x + 78x + 7$

当基本变化次数$ % 3 == 0$，都用 $(xx -> 8x + 7)$，总次数 $=$ 基本变化次数 $ / 3$

当基本变化次数$ % 3 == 1$，用两个 $(xx -> 4x + 3)$，剩下用 $(xx -> 8x + 7)$，总次数=基本变化次数 $/3 + 1$

当基本变化次数 $%3 == 2$，用一个 $(xx -> 4x + 3)$，剩下用 $(xx -> 8x + 7)$，总次数=基本变化次数 $/3 + 1$

### 代码如下:

```cpp
#include <bits/stdc++.h>
using namespace std;

typedef long long ll;
const ll mod=1000000007;
ll x, ans;

int main()
{
	cin >> x;
	ll i;
	for(i = 0; i <= 300000; i++)
	{
		if(x == 0) break;
		x = (x * 2 + 1) % mod;
	}
//其实这里有个小bug,i==300000时已经迭代了300001次
//如果在这个时候刚好等于0，其实还是不符合条件的
//不过我，懒得改了(●‘?‘●)
	if(x != 0)	cout << -1;
	else if(i % 3 == 0)	cout << i / 3;
	else if(i % 3 == 1)	cout << i / 3 - 1 + 2;
	else if(i % 3 == 2)	cout << i / 3 + 1;
	return 0;
}
```

