```delphi
const sh=1000000007;{取模之数}
var
n,c,k:int64;{用longint也可}
function f(k:int64):int64;
begin
  exit(2*k+1);
end;
begin
  read(n);k:=n;
  repeat
  inc(c);
  if c>300000 then begin write(-1);halt;end;{如果基本步数一定超过100000，那么退出}
  k:=f(k);{基本步数}
  k:=k mod sh;{化简数值}
  until k mod sh=0;{再次求值以求保险}
  if c mod 3=0 then write((c div 3))else write(c div 3+1);{填补空缺}
end.
```
[color=fuck]此题纵观看来应属简单，关键在于对巨大数据的化简以及整理。具体的思路，在于循环中判断，计算后取模，旨在化简数据大小，从而适宜调备。当我们看到（4x+3）与（8x+7)时，脑际应即刻反映为(4\*(x+1)-1)以及（8(x+1)-1)。对二者提取公因式，可获之（2x+1)。可以发现，设f(x)=2x+1,则f(f(x))=4x+3;f(4x+3)=f(f(f(x)))=8x+7。以（2x+1)作为计算基本单位，进行反复运算，得到其应有的基本次数。最终，须谨记，对计算结果若mod 3=0，那么输出其div 3的值，否则须输出（c div 3+1)。因为，设若其得到的值为5，则是（8x+7)的一步，再外加（4x+3)的一步。设若其mod 3<>0 则必定其还有另外剩余的未被算入的步数，我们只要在原数据+1，就可以解决，毋用其他冗繁的方式。

[/color]
