~~机房考试时做到一道很像的题。。。~~
# 题意分析
给你一个数x。每一次处理可以将其变为(4x+3)%1000000007或(8x+7)。问最少进行多少次操作后，能得到0。
# 思路
分析后我们可以发现：

令f[x]=2x+1

4x+3=f[f[x]]

8x+7=f[f[f[x]]]

因此，我们可以把这道题转化成：将x进行几次2x+1的处理，求什么时候能变为0

我们可以暴力枚举次数，直到求出0为止。

然后将处理次数分为几个2和3（注：根据贪心策略，为了使次数最小，尽可能多分3。）

我们知道，2，3是可以完全分配除0，1以外的所有自然数的。

可以证明，当x在一次2x+1操作之下可以变为0时，在题目所限100000步内，无法将其变为0。

具体操作看下面代码

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n; 
int sum=0;
int main()
{
	cin>>n;
	while(n!=0&&sum<=300000)//因为要3次2x+1操作才抵得上一次题目所说的8x+7操作，所以限制要大3倍
	{
		n=(2*n+1)%1000000007;
		sum++;
	} //枚举2x+1操作的次数
	int ans=sum/3+(sum%3>=1);
    //如果刚好能被3除尽，就全部用3
    //如果除3余2，就再用一个2
    //如果除3余1，就退一个3，换两个2
    //所以只要除3有余数，说明要多进行一次操作
    //sum%3>=1,如果成立，值为1，反之为0
	if(sum==1||ans>100000)//次数为1，或者超过限制，输出-1
	{
		cout<<-1;
	}
	else
	{
		cout<<ans; 
	}
	return 0;
}
```
