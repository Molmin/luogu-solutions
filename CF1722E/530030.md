### 题意简述

给出 $n$ 个矩阵的长 $h_i$ 和宽 $w_i$。然后给出 $q$ 组询问，每组包含四个正整数 $h_s,w_s,h_b,w_b$，求 $\sum h_i\cdot w_i$，其中 $h_s<h_i<h_b,w_s<w_i<w_b$。

### 题目分析

（下文中涉及数学符号可能使用不规范，但意对即可。）

将 $h_s,w_s$ 和 $h_b,w_b$ 分别构造成两个矩形 $S$ 和 $B$，根据数据范围可以得出 $S\subseteq B$，我们要求的是所有满足 $s\subseteq I \subseteq B$ 的矩形 $I$ 的面积总和。

显然暴力枚举是通过不了的，我们考虑将矩形 $S,I,B$ 的左上角对齐进行分析。

我们设 $m_{i,j}$ 表示点 $(0,0),(0,i),(0,j),(i,j)$ 四个点构成的矩形区域中真包含的所有矩形面积和。

（在下文中我们为书写方便，将上一行中四个点组成的矩形记作 $R_{i,j}$，不规范但能看懂就好。）

那么首先就能在输入时将 $m_{i,j}$ 加上目前输入的矩形面积。（注意是加上而不是赋值，要考虑两个完全相同的矩形。）

那么便可以用 **二维前缀和** 的方式进行计算，可得如下式子：
$$
m'_{i,j}=m_{i,j}+m_{i-1,j}+m_{i,j-1}-m_{i-1,j-1}
$$
其中 $m'$ 表示 $m_{i,j}$ 新的值，即编程中的赋值后的数。

那么为什么这个式子成立呢？

首先我们知道，若 $i>p,j>q$，那么 $R_{p,q}$ 能被 $R_{i,j}$ 完全包含（即真包含），那么 $R_{p,q}$ 能完全包含的矩形 $R_{i,j}$ 也一定能包含，所以 $m'_{i,j}=m_{i,j}+m_{i-1,j}+m_{i,j-1}$ 便明确了。

那么为什么要减去 $m_{i-1,j-1}$ 呢？

我们可以这么想，将 $m_{p,q}$ 分成 $R_{p-1,q}$ **就能** 包含的矩形面积 与 有了第 $p$ 行 **才能** 包含的矩形面积之和。我们容易发现这两部分是不相交的且覆盖了所有情况。同样地，也可分成 $R_{p,q-1}$ **就能** 包含的矩形面积 与 有了第 $q$ 列 **才能** 包含的矩形面积之和。

于是，我们将 $m_{i-1,j}$ 和 $m_{i,j-1}$ 都如此分解，会发现重合部分 $m_{i-1,j-1}$ 所以便可以减去。这是 **容斥原理**，也是二维前缀和实现的重要基础，这样，我们便只剩下最后一部分了。

在上面的推导中，我们的 $m_{i,j}$ 始终是包含而不是真包含（两者的差距我们暂且看作真包含不能边界重合）。而根据数据都是整数，并且我们有整数集中的这样一个式子：若 $x,y\in\mathbb{Z},x<y$，则 $x+1\leq y$。

所以既然 $m_{i,j}$ 是包含，那么 $m_{i-1,j-1}$ 一定是 $R_{i,j}$ 的真包含。然而还没结束，因为我们还得解决一个被包含的关系。

也使用容斥，我们将现在的答案减去能被 $R_{h_s,w_s}$ **包含** 的矩形面积（这里因为边界重合不能算进答案，于是可以一起减去）。

但仔细想想还会发现，有一部分不能被 $R_{h_w,w_s}$ 包含但还在答案里。这是什么？

其实是因为这些矩形有一条边和 $R_{h_s,w_s}$ 其中一条边所在直线重合，但另一条边却很长，就不能被 $R_{h_s,w_s}$ 包含，这部分我们直接从下面的式子中看：
$$
ans_{R_{h_s,w_s},R_{h_b,w_b}} = m_{h_b-1,w_b-1}-m_{h_s,w_b-1}-m_{h_b-1}{w_s}+m_{h_s,w_s}
$$


### 代码实现

注意多测，记得清空 $m$ 数组。

不开 ll 见祖宗。

```cpp
#include<bits/stdc++.h>
#define ll long long
const int N = 1e5;
const int M = 1000;
using namespace std;
int t, n, q, h, w;
ll m[M + 5][M + 5], ans;
int h1, w1, h2, w2;
int main()
{
	scanf("%d", &t);
	for(int z = 1; z <= t; z++)
	{
		memset(m, 0, sizeof m);
		scanf("%d%d", &n, &q);
		for(int i = 1; i <= n; i++)
		{
			scanf("%d%d", &h, &w);
			m[h][w] = m[h][w] + h * w;
		}
		for(int i = 1; i <= M + 2; i++)
		{
			for(int j = 1; j <= M + 2; j++)
			{
				m[i][j] = m[i][j] + m[i - 1][j] + m[i][j - 1] - m[i - 1][j - 1];
			}
		}
		for(int i = 1; i <= q; i++)
		{
			scanf("%d%d%d%d", &h1, &w1, &h2, &w2);
			ans = m[h2 - 1][w2 - 1] - m[h1][w2 - 1] - m[h2 - 1][w1] + m[h1][w1];
			printf("%lld\n", ans);
		}
	}
    return 0;
}
```

