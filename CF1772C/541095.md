# 鸣谢
- 感谢管理员 @[Maxmilite](https://www.luogu.com.cn/user/274993)，多次指出本题解的不妥当之处。
- 感谢 @[tangrunxi](https://www.luogu.com.cn/user/231147)，本题解参考了一下他的代码并做出了细小改动。

# 题意
- 给定一个数组，把这个数组相邻两个数的差列出来，汇聚成另一个数组，这个数组有 $n$ 个不同的值，就代表这个数组的特征数。
- 现在给定 $n$ 和 $k$，让你构造出一个长度为 $k$ 且数组中每个数都不超过 $n$ 的一个**严格递增数组**，使这个数组的特征数尽量大，并输出这个数组。
- 共有 $t$ 组独立的询问，$1\le t\le 819$ 且 $1\le k\le n\le 40$。

# 分析
显然这题的算法是贪心。让特征数尽量大，那我们就可以让每两数之差都变得不一样，设定为 $ [1, 2, 3, 4, 5\cdots ] $。

------------
$\texttt{Q:}$  什么要设定为 $ [1, 2, 3, 4, 5\cdots] $ 而非 $ [1, 3, 5, 7, 9\cdots] $、$ [1, 100, 1000, 10000, 100000\cdots] $ 等其他数组呢？

$\texttt{A:}$ 因为题目中明确表明构造的数组有一个上限 $n$，数组中的每个数都不能超过 $n$，假如不把两数之差设置为 $ [1, 2, 3, 4, 5\cdots] $ 的话，那肯定就不是最优解，到后面可能会超过 $n$。

------------
既然我们把每两数之差给定下来了，那么就这样结束了吗？并没有，因为加到后面可能会超出上限 $n$。例如样例中的 $k=5$ 且 $n=9$ 的情况下，第一个数是 $1$，第二个数是 $1+1=2$，第三个数是 $2+2=4$，第四个数是 $4+3=7$，都很正常。

那么第五个数呢？$7+4=11$，超过了上限 $n=9$，怎么办呢？我们只能再次利用贪心，既然离最优解有差距，那么就让这个差距变小些，我们需要让后面的数足够凑出数组的长度。

我们找到满足条件的最后一个数，之后不满足条件的数就以它为基准，依次递增 $1$，这样的话，只和前面的 $1$ 重复，把损失降到了最小，且不会超过上限 $n$。那么，代码就有了。

# 代码
```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
int t,n,i,j,k,cnt1,cnt2,a[10010];
signed main(){
	cin>>t;
	while (t--){
		cin>>k>>n;
		memset(a,0,sizeof(a));
		a[1]=1;
		cnt1=2;
		for (i=0;i<k;i++){
			if (n-a[cnt1-1]>k-2){
				a[cnt1]=a[cnt1-1]+cnt1-1;
				cnt1++;
			} 
			else{
				cnt2=a[cnt1-1]+1;
				for (j=cnt1;j<=k;j++){
					a[j]=cnt2;
					cnt2++;
				}
			}
		}
		for (i=1;i<=k;i++)
		  cout<<a[i]<<" ";
		cout<<endl;
	}
	return 0;
}
```
代码参考了 @[tangrunxi](https://www.luogu.com.cn/user/231147) 的并做出了一些修改，因为我的思路和他的很像，侵删。