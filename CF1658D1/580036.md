赛场上看到这题，把我给卡住了。


~~（翻了一遍提交记录，我的方法似乎是独家的）~~

# 思路：

因为异或是一种二进制运算，

所以不妨考虑先将所有的数字都转成二进制。

然后再仔细想一下，

你就会发现 既然这个全排列是和同一个数进行异或运算，

所以我们可以直接按位考虑。

举个例子：

比如说这个要求的数转成二进制时第一位是一，

那么，对于和这个数进行异或的数（也就是那个全排列），

不管前面几位怎么样变换，

第一位为零时 都会在最终结果处产生一个一；

第一位为一时 都会在最终结果处产生一个零。

也就是说，只需要针对所有的这些数中每一位一的个数和零的个数进行考虑。

由此我们可以想到桶排序。

记录这个全排列中所有的数转成二进制以后 ，

对于每一位数 都加进这一位数所对应的桶计数数组里。

比如说某数转为二进制后第三位为一 那桶数组的第三项就要加上一，

对于异或的结果 我们也这样处理。

分别存在两个不同的桶数组中，

随后我们遍历两个桶数组，

对于两个桶数组的某项，

如果它们相等 那就说明要求的数化成2进制时的关于这一项的位为零。

因为桶计数实际上统计的是一的个数，

如果它们不相等 那就说明要求的数化成二进制是关于这一项的位为一。

（因为题目中写到保证有解 那么就可以省去判断这一步骤）

实测能过。

# 代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int __pow(int h){//计算2的次幂
	int p =1;
	for(int i =0;i<h;i++)p*=2;
	return p;
}
int main(){
	int t;
	cin >> t;
	while(t--){
		int l,r;
		cin >> l >> r;
		int ans =0;
		int tong1[30] = {0};
		int tong2[30] = {0};
		for(int i =l;i<=r;i++){
			int qaq;
			cin >> qaq;
			int j =0;
			int num =i;
			int k =0 ;
			while(num !=0){
				tong2[k]+=num%2;
				num/=2;
				k++;
			}//全排列转二进制
			while(qaq!=0){
				tong1[j]+=qaq%2;
				qaq/=2;
				j++;
			}//异或后的全排列转二进制
		}for(int i =0;i<=24;i++){
			//cout << tong1[i];
			if(tong1[i] != tong2[i]){
				ans+=__pow(i); 
			}//遍历桶数组并算出答案
		}
	cout << ans << endl;}
	}
```

