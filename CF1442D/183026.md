考虑大力猜结论，思考选完 $k$ 次后最终的状态是什么？

很重要的性质是，数组是**不降的**。

可以证明的是，最终必然是若干个完全取完的数组，**至多一个取了一部分的数组**，剩下的应该完全没有动过。

感性理解一下这个结论，假设最后剩下两个数组 $a,b$，那么我们把取 $b$ 的次数拿去取 $a$（或者把取 $a$ 的次数拿去取 $b$），必然优于两者各取一部分。

从春令营讲义 ~~贺~~ 修改来的

一个显然的思路是枚举不满的数组是哪个，把剩余的每个数组缩成一个数（因为必然全选或全不选）。从前往后跑一遍背包，从后往前跑一遍背包。然后，每次枚举的时候把前后的背包合并，再枚举不满的数组选到哪个位置，剩下的在合并后的背包中查询，时间复杂度 $\mathcal{O}\left(nk^2\right)$，无法通过此题。

考虑优化，容易发现上述做法的时间复杂度瓶颈在于背包的合并，回想传统艺能，发现向背包插入物品的时间复杂度是 $\mathcal{O}\left(k\right)$ 的，所以可以想到利用这个性质。

```
//传统艺能
for(int j = maxw; j >= w; j --) 
	f[j] = max(f[j], f[j - w] + v);
```
分治能很好解决本题，对于一个区间 $\left[l,r\right]$，可以找到一个    `mid = (l + r) >> 1`，把 $\left[mid + 1,r\right]$ 的数插入到背包中，递归求解 $\left[l,mid\right]$；然后**把插入的数回退**，改为插入 $\left[l,mid\right]$ 的数，递归求解 $\left[mid + 1,r\right]$。这样当递归到 `l==r` 时，等价于 $l$ 是我们枚举到的没选满的数组，然后朴素枚举 $l$ 选到哪个位置求解即可，这样的事件复杂度是 $\mathcal{O}\left(nk\log n\right)$ 的，记得注意常数优化。

[Submission](https://codeforces.com/contest/1442/submission/143503744)









$$$$$$$$$$$$$$$$$$$$