## 想法

### Hint 1

有一个重要的转化：交换所需的次数等于**重排后原下标的逆序对数**。（可以把重排后的序列看成需要按照下标排序的序列）这样，抽象的交换操作就转化为具体的逆序对数。

### Hint 2
记颜色为 $i$ 的黑球下标 $b_i$，白球为 $w_i$。**以黑球为主体统计**，则颜色为 $i$ 的黑球构成的**下标逆序对**可能是：

- 和黑球构成的；
- 和重排后值较小而下标较大的白球构成的；
- 和重排后值较大而下标较小的白球构成的。

### Hint 3

考虑**按颜色从小到大依次放入**，这样可以通过“放入和未放入”判断大小关系。

## 题解

把同色球的逆序对单独处理，不影响答案。此后，一个黑球的逆序对默认为和其他白球的。

可以 dp. 设 $f(i,j)$ 为第 $i$ 个黑球放在第 $i+j$ 个位置（即有 $j$ 个白球）。有 $f(i,j) \gets \min\{f(i,j-1),f(i-1,j)+g(i,j)\}$，其中 $g(i,j)$ 为把第 $i$ 个黑球放在第 $i+j$ 个位置产生的逆序对数。

$g(i,j)$ 可以 $O(n^2)$ 预处理。

## 代码

```cpp
const int N = 4005;
int n;
char c[N]; int a[N];

int f[N][N], g[N][N];
int pB[N], pW[N];

int main() {
    rd(n);
    U (i, 1, n * 2) {
        scanf("%c%d\n", c + i, a + i);
        if (c[i] == 'B') pB[a[i]] = i;
        else pW[a[i]] = i;
    }
    
    // 排序后，原下标的逆序对数
    // 计算每个黑球的贡献
    // 考虑把第 i 个黑球放在 i + j
    // 会和：
    // - 黑数字大于 i, 下标小于 
    // - 黑数字小于 i, 下标大于
    // - 白数字大于 j, 下标小于
    // - 白数字小于等于 j, 下标大于
    // 大力预处理？

    U (i, 1, n) {
        int cnt = 0;
        U (j, 1, n) cnt += pW[j] < pB[i];
        U (j, 0, n) {
            g[i][j] = cnt;
            cnt -= pW[j + 1] < pB[i];
            cnt += pW[j + 1] > pB[i];
        }
    }

    ms(f, 0x3f);
    U (i, 0, n) f[0][i] = 0;
    int ans = 0;
    U (i, 1, n)
        U (j, 1, i - 1)
            ans += (pB[i] < pB[j]) + (pW[i] < pW[j]);
    U (i, 1, n) U (j, 0, n) {
        int x = j ? f[i][j - 1] : 0x3f3f3f3f, y = f[i - 1][j] + g[i][j];
        f[i][j] = min(x, y);
    }

    printf("%d", ans + f[n][n]);
}
```