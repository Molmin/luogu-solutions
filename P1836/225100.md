最常规的数位 $dp$。但是这一题一大部分人用了 打表 $or$ 暴力。用数位 $dp$ 的人也不讲讲数位 $dp$ 。我个人觉得，数位 $dp$ 没有他们讲的这么简单吧。

我们先要明确一点：数位 $dp$ 一般用于求 ( 是一般 ) 一个区间内的数满足一个条件的个数或者其他。( 这个其他影响状态转移方程 ) 然后用前缀和的思想。求 $[0.a-1]$ 和 $[0,b]$ 的解，答案就是 $[0,b]-[0,a-1]$

首先，我不建议把这一题作为数位 $dp$ 入门题，如果想学数位 $dp$ ，可以先做 [P2657 [SCOI2009] windy 数](https://www.luogu.com.cn/problem/P2657) 。两题的最大区别在于：统计个数 和 统计数字和。

如果想的话，去做 [这题](https://loj.ac/problem/10168)，你就知道我说的不这么简单是什么意思了。（ 不是指难度上的简单，是指理解上的，虽然它的确不是很简单 ）

数位 $dp$ 的基本思想是从高位往低位枚举每一位数位，计算对答案的贡献 ( 贡献这个词，这里意会即可 ) 

考虑状态 $f[x][y][z][w]$。表示从高到低枚举到第 $x$ 位时第 $x$ 位取 $y$ ， $(z)$ 当前高侧的每一位是否等于原数。当前枚举出来的数字和为 $w$ 。（数位dp一般需要一个 $bool$ 判断是否当前高侧的每一位是否等于原数，因为等于的时候，后面枚举的数不能超过原数的下一位，而不等于的时候可以枚举 $0-9$ ）

可以手模几个例子。

考虑状态转移方程：$f[x][y]+=f[x+1[k]$ ( $k$ 为 $0-9$ 中的可以取的数，存在上面的限制 ) $z$ 和 $w$ 相应改变，是因变量

然后这里我给点小技巧。
- 使用记忆化搜索貌似会方便点，因为不用像刷表法那样考虑下标的先后顺序
- 对于这种 $bool$ 状态（本题只有一个不代表别的只有一个）学会用逻辑运算是个好主意
- 计算 $[0,a]$ 的过程写成函数。

$Code:$

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
int s[109];
ll mem[51][10][2][181];
bool vis[51][10][2][181];
ll head;
ll dfs(int x,int y,int z,int w)
{
        int i;
        ll res=0;
        if(vis[x][y][z][w]) return mem[x][y][z][w];
        if(x==1) return w;
        for(i=0;i<=9;i++)
        	if(z==1&&i>s[x-1]) break;
            	else res+=dfs(x-1,i,z&(i==s[x-1]),w+i);
        vis[x][y][z][w]=1;
        return mem[x][y][z][w]=res;
}
ll calc(ll x)
{
        head=0;
        memset(vis,0,sizeof(vis));
        while(x)
        {
            s[++head]=x%10;
            x/=10;
        }
        return dfs(head+1,0,1,0);
}
int main()
{
        ll a,b,t;
        cin>>a;
        cout<<calc(a)<<endl;
        return 0;
}

```


莫名跑出最优解了.....（ 时间复杂度$:O(lognlogn*9*logn*9*10*2)$，也就是状态数，大约为$O(1620log^3n)$，还有常数 ）