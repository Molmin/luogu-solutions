**0. 前言**  
一个比较常见的套路了。  

**0.5. 题意**  
给定一个长度为 $n$ 的序列，你需要自选一个 $k$（$1< k\le n$），自选方式把序列划分成 $k$ 个子段，让所有子段的 $\gcd$ 最大。  

**1. 分析**  
首先考虑一个方案 $\{b_k\}$（我们假设 $b_i$ 是第 $i$ 段的子段和），假设其 $\gcd$ 为 $d$。因为子段都是连续的，所以我们可以合并 $b_1$ 和 $b_2$。此时，任意一段仍然是 $d$ 的倍数。  
就有一个现象：对于任意一个长度大于 $2$ 的方案，总有一个长度等于 $2$ 的方案，使得它们的结果一样大。  
换句话说，如果最大值为 $d_0$，且长度为 $2$ 的方案不存在答案为 $d_0$ 的，那么这个 $d_0$ 最多只能在 $k=1$ 取到。  
所以，我们只需要每次把整个序列分成 $2$ 段，就一定能找出最优解。  
方法就是，枚举断点，前缀和统计。  
```cpp
cin >> n;
for(int i = 1; i <= n; i++) {
	cin >> x[i];
	s[i] = s[i - 1] + x[i];//前缀和
}
int ans = -1ll;
for(int i = 1; i < n; i++) { //枚举的是左边那个子段的结束坐标
	int l = s[i], r = s[n] - s[i];
	ans = max(ans, __gcd(l, r));//__gcd是C++某个库（好像是math）自带的 gcd 函数。
}
cout << ans << endl;
```  

**2. 后言**  
C题出锅了，D题是恶心交互，E题不会，下班力（喜