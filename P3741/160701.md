本蒟蒻的第一篇题解，因为~~社区贡献的咕值太低想提分~~想对洛谷做出一点贡献。
好了，话不多说上思路：
（因为我看见了1<=n<=100，所以···）

（1）在不改变任何字母的情况下有多少VK

（2）依次改变每一个字符，验证有多少VK

（3）每次验证完后都与之前的最大值比较更新max

（4）输出max
对，你没看错这就是~~暴力求解~~ 模拟。
好了，上代码：
```cpp
#include <cstdio>
#include <cstring>
char x[105];
int max=-1,tot;//max存储最多，tot存储每次的VK数 
int main() {
	int n;
	scanf("%d",&n);//说实话，本蒟蒻第一次做的时候完美地忽略了它，于是乎后面直接用的strlen 
	scanf("%s",x);//字符串，表示她的输入 
	tot=0;
	for(int i=0;i<=strlen(x)-1;i++)//这里是枚举一个都没改的时候有多少VK  ps：∵数组从零开始存储∴要枚举到n-1 
	{
		if(x[i]=='V'&&x[i+1]=='K') tot++;//当一个字符为 V且下一个字符为 K 时，就会多一个"VK"字符串 
	}
	max=tot;// 因为第一个一定是目前最多，所以直接赋值给 max 
	for(int i=0;i<=strlen(x)-1;i++)//开始搜索改掉每一个会有多少 
	{
		if(x[i]=='V') x[i]='K';//如果这个数本身是V，改成 K 
		else if(x[i]=='K') x[i]='V';//如果这个数本身是K，改成 V
		//ps:因为它上面已经将 V变成了K如果不加else，那么一个V就会是
		//V-->K-->V 对，变回去了··· 
		tot=0;//每次将tot置为0 
		for(int j=0;j<=strlen(x)-1;j++)
		{
			if(x[j]=='V'&&x[j+1]=='K') tot++;//再次统计"VK" 的次数 
		}
		if(max<tot) max=tot;//判断这次的次数是否超过了之前的最大值，如果超过了，最大值变成这次的值 
		if(x[i]=='V') x[i]='K';
		else if(x[i]=='K') x[i]='V';//把变了的字符变回去，道理同上 
	}
	printf("%d",max);//输出最大值即可 
	return 0;//完结撒花
} 
```
好了，第一篇题解先酱紫吧，毕竟，蒻蒻之路还挺长，好了，我先溜了，Bye~