### 简要题意

有一个 $n\times m$ 的矩阵，矩阵内的数字从 $1$ 开始，按从左到右、从上到下的顺序进行排列，给出一个定义：

一对相邻的格子，如果满足各自内的数字之差为 $1$，则我们称这一对格子为一个 domino。

### 讲解

其实这道题，如果你想直接用朴素算法求解，思路很显然：枚举这 $n\times m$ 个格子，对于每个格子的上下左右进行判断（如果存在），最后再容斥一下（除以 $2$，因为这种算法会保证形如 $(x_1,y_1),(x_2,y_2)$ 的答案会以另一种形式出现：$(x_2,y_2),(x_1,y_1)$）。

但是时间复杂度是 $O(n\times m)$ 的，对于 $n=10^9,m=10^9$ 这样的极限情况显然会 TLE，那么我们考虑推出一个结论，直接求解。

举一个例子，设 $n=5,m=5$，那么矩阵为：

```
 1  2  3  4  5
 6  7  8  9 10
11 12 13 14 15
16 17 18 19 20
21 22 23 24 25
```

显然，一般情况下，第 $i(1\le i<n)$ 行的数字不能和第 $i+1$ 行 的数字构成 domino，并且每一行的 domino 数量就是 $m-1$ 的值。

那么答案就是 $n\times (m-1)$。

但还要考虑特殊情况。设 $n=5,m=1$，那么矩阵为：

```
1
2
3
4
5
```

手动计算一下，可以发现其中有 $4$ 个 domino。

但按照我们先前的计算方法，得出的结果却是 $0$。

很简单，既然每一行只有一个数字，那么我们上述的规律就不成立了（即每一行内不存在 domino，但每一列内反而会出现 $n-1$ 个 domino），所以需要特判一下。

时间复杂度 $O(1)$。

### 核心代码

```cpp
if(m==1)
	cout<<n-1<<endl;
else
	cout<<n*(m-1)<<endl;
```