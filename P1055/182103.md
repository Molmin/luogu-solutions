## 萌新第一次发题解，觉得挺好理解的故发了上来
####  若有不完善的地方还请各位大佬指出 

```
/*
	该题细节稍不注意就会WA 50 
	第一次就是50 第二次80
	因为少了对'X'的判断 此题我用字符转化为数字利用了ASCLL
	要相当注意对X的判断 多跑几个样例 比如2-400-00000-X 2-100-00000-X
*/ 
#include <iostream>//c++代码 
using namespace std;
int main()
{
	char a[13];//开一个字符序列 
	int sum=0;//sum为求和结果 
	int k=1;//k为倍数 随着数字增加 
	for(int i=0;i<13;i++)//输入13个字符 
	{
		cin>>a[i];
	}
	for(int i=0;i<11;i++)//只需判断前11个字符即可 因为要求的是求和结果 
	{					//最后两位为 - 和验证码 
		if(a[i]!='-')//如果不是- 那么先把这个数字字符转为整型 
		{
			int b=a[i];//注意这个时候 因为ASCLL的原因 如果a[i]为'0'的话 b为48 
			b-=48;//所以要减去48  
			sum+=k*b;//转化完后
			k++;//倍数加1 
		}
	}
	sum%=11;//这时取模算出余数和验证码对比 
	int c=a[12]-48;//把输入的字符的最后一位转化为数字 
	if(sum==c && a[12]>='0' &&a[12]<='9' ||sum==10 &&a[12]=='X')
	{			// 这里判断的是
				//如果余数等于最后一位并且最后一位是0-9范围内的就输出Right
				//或者余数如果为10并且最后一位的字符为'X'就输出Right 
		cout<<"Right";
	}
	else//否则 
	{
		for(int i=0;i<12;i++)//先输出前12位 
		{
			cout<<a[i];
		}
		if(sum==10)//对最后一位进行判断 如果取模后余数为10 最后一位输出'X' 
		{
			cout<<'X';
		}
		else//否则输出余数 
		{
			cout<<sum;
		}
	}
	return 0;
}
```