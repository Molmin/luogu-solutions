题意：一把锁，有0~9几个数字，现在在第a个数，要到第b个数，可以让数字加一或减一，数字转到10会变成0，到-1会变成9，求最少转多少次

输入a，b

输出最少次数

非数学方法

模拟两种转法，要么一直加一直到解锁，要么一直减一。

因为要算最少的，所以只有两种可能，即上面两种，如果加一再减一就不可能满足最少次数。

所以我们可以搞两个循环来算

```cpp
#include <bits/stdc++.h>
using namespace std;
int a,b;//输入的起始数和目标数
int main()
{
  	cin>>a>>b;
  	int ans1=0,ans2=0,tmp=a;
    //ans1为一直加的结果，ans2为一直减的结果，tmp暂时存a的值
  	while(a!=b){//一直循环到现在的数变成目标数
  		++ans1;
  		++a;
  		if(a==10){//这里可以改为a%=10，效果一样
  			a=0;
		}
	}
	a=tmp;//现在的数归回起始时状态
	while(a!=b){//一直减的方法
		++ans2;
		--a;
		if(a==-1){
			a=9;
		}
	}
	cout<<min(ans1,ans2)<<endl;//输出最少的次数
  	return 0;
}

```