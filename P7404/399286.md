## 题目大意

给定序列 $a$，每次可选择区间 $[L,R]$ 加一，求最少操作次数使得 $\exists k \in[1,n]$，

- $a_1< a_2 <...< a_k$ ；

- $a_k > a_{k+1} > ... > a_n$。

### 前置知识 - 差分

差分，相当于前缀和的逆运算。我们定义一个差分数组 $f$，满足如下性质：

 - $f_i=a_i-a_{i-1}$
 
 - $a_i=\sum_{j=1}^if_j$
 
 - 将区间 $[l,r]$ 加上 $k$，相当于 $f_l  \gets f_l+k,f_{r+1} \gets f_{r+1}-k$

## 分析

区间加，且只能加 $1$，且分析递增递减性质，考虑差分。

定义一个差分数组 $d_i=a_i-a_{i-1}$
。

则题目要求满足的条件就转化为：$\exists k \in[1,n]$，

- $d_1,d_2...d_k > 0$；

- $d_{k+1},d_{k+2}...d_n < 0$。

传统差分到此为止仿佛就没法做下去了，而本题就妙在于采用一种类似于**动态规划**的差分做法。

由于本题的 $k$ 并不是固定的，而是选择最优的，所以考虑定义 $f_{i\in[1,n],j\in[0,1]}$。其中：

- $f_{i,0}$ 表示让 $a_1...a_i$ 严格递增的方案数；

- $f_{i,1}$ 表示让 $a_i...a_n$ 严格递减的方案数。

再推转移方程，以 $f_{i,0}$ 为例：

前文说过，如果两数差为正，则一定满足递增。那么，就可以推出第一个式子：

$$f_{i,0}=f_{i-1,0},d_i>0$$

如果不为正，就需**加上**两数差的**绝对值**，此时已经保证了单调递增。若须严格递增，则还要加上 $1$，保证两数差为正。这一步操作类似于 [P4552](https://www.luogu.com.cn/problem/P4552)，也相当于一道双倍经验题。

这样，就推出了第二个式子：

$$f_{i,0}=f_{i-1,0}-d_i+1,d_i \le 0$$

两式结合，就推出了本题的第一个方程。

对于递减，其实可以转化为从 $n$ 开始，保证 $a_n>a_{n-1}>...>a_k$，这样也转化为了和递增差不多的方程。

最后一步，从 $1$ 到 $n$ 枚举中间点 $k$，取 $\max (f_{i,0},f_{i+1,1})$ 的最小值。

最后提醒一句：**一定要记得开 long long**。

### Code：
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
int n, s=1e18, a[200010], d[200010];
int f[200010][3];
signed main(){
	scanf ("%lld", &n);
	for (int i=1; i<=n; i++){
		scanf ("%lld", &a[i]);
		d[i] = a[i] - a[i-1];
	}
	for (int i=2; i<=n; i++){
		if (d[i] > 0) f[i][0] = f[i-1][0];
		else f[i][0] = f[i-1][0] - d[i] + 1;
	}
	for (int i=n; i>=2; i--){
		if (d[i] < 0) f[i][1] = f[i+1][1];
		else f[i][1] = f[i+1][1] + d[i] + 1;
	}
	for (int i=1; i<=n; i++){
		s = min(s, max(f[i][0], f[i+1][1]));
	}
	printf ("%lld\n", s);
	return 0;
}

```