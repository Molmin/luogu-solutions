原题链接：**[传送门](https://www.luogu.com.cn/problem/P7404)**

------------
### 题目大意：

这道题大致是说，给你一个 $n$ 个数的序列 $A_i$，你可以让一个区间里的每一个数加上 $1$。现在让你找到一个中间节点 $k$，对于子序列 $A_1=\{A_1,A_2,\cdots,A_k\}$ 为严格递增序列，对于子序列 $A_2=\{A_k,A_{k+1},\cdots,A_n\}$ 为严格递减序列。问你实现这个状态找哪个中间节点所需的加法操作最少。

------------
### 分析：

这道题我们可以用 **DP** 的思想来想。

我们要用一个 $sx$ 数组，**来存放每一个元素与它前面的每一个元素构成升序序列所需的操作次数。**

降序同理。我们用 $jx$ 数组**来存放每一个元素与它后面的每一个元素构成降序序列所需的操作次数。**

那么应该怎么处理这两个数组呢？

我们不妨先让：$sx_0=0$，$js_n=0$。

然后对于序列里的每一个元素，我们发现：

对于升序序列而言，一个元素的状态应是由前一个的状态转移而来的，而且还要加上比前一个大最少需要的操作数。如果 $a_i<=a_i-1$，那么状态转移方程为：

$sx_i=sx_{i-1}+(a_{i-1}-a_{i}+1)$

否则，直接继承前一个元素的状态。

自然的，降序序列中，一个元素的状态应是由后一个的状态转移而来的，而且还要加上比后一个大最少需要的操作数。如果 $a_i<=a_i+1$，那么状态转移方程为：

$jx_i=jx_{i+1}+(a_{i+1}-a_{i}+1)$

否则，直接继承前一个元素的状态。

处理完之后，我们就跑一遍数组，枚举 $k$ 点 ，用一个变量 $ans$ 寻找 $\max(jx_k,sx_k)$ 的最小值。然后输出即可。

------------
### 注意事项：
1. 要开 **long long**；
2. $ans$ 初始化一定要够大，否则有几个点会被卡。

------------
### **AC 代码：**

```cpp
#include<cstdio>
#include<iostream>
#define int long long

using namespace std;

int n,a[200005],sx[200005],jx[200005];
int ans=0x3f3f3f3f3f3f3f3f; 
//ans一定要够大。

inline int read()//快读。 
{
	int x=0,f=1;char ch=getchar();
	while (ch<'0'||ch>'9')
    {if (ch=='-') f=-1;ch=getchar();}
	while (ch>='0'&&ch<='9')
    {x=x*10+ch-48;ch=getchar();}
	return x*f;
}

signed main(){
	
	n=read();
	
	for(int i=1;i<=n;i++) a[i]=read();
	
	for(int i=2;i<=n;i++){
		sx[i]=sx[i-1];
		if(a[i-1]>=a[i]) sx[i]+=a[i-1]-a[i]+1;
	}//处理每个点成为上升序列所需操作数。
	
	for(int i=n-1;i>=0;i--){
		jx[i]=jx[i+1];
		if(a[i+1]>=a[i]) jx[i]+=a[i+1]-a[i]+1;
	}//处理每个点成为下降序列所需操作数。 
	
	for(int i=1;i<=n;i++) 	
        ans=min(ans,max(sx[i],jx[i]));
        //找最小值，枚举中间节点。 
	
	printf("%lld",ans);//输出。 
	
	return 0;
}
```


 ### _Thanks for reading!_ 