这道题是刘汝佳紫书上**高效算法设计**一章中的例题，题意非常清楚，就是找最小能够满足跑完全程的加油站编号，算法就是贪心+模拟。

然而，数据范围达到了1e5，难点在于如何优化时间复杂度。

根据题意和实际情况，我们很容易得到“**如果总油量不足以支持跑完全程，就一定无解**”的结论。

那么，是否存在**总油量>=所需油量但仍然无解**的情况呢？我们可以这样想：由于走的是环形跑道，我们总可以找到一个起点使得油量足够支撑跑完全程，因为如果不存在这样的点，则把每一个点当作起点都会有ai+...+aj<bi+...+bj出现，这样的话就有a1+a2+...+an<b1+b2+..+bn，与我们的假设矛盾，所以**这种情况不存在**。

再考虑有解的情况，基于最直接的模拟，我们尝试从1号加油站枚举，遇到不能到达的情况就直接退出枚举下一个，时间复杂度为**O（n^2）**,TLE。

如何优化呢？我们在计算中发现：从枚举的起点到不能到达站点之间的数据信息蕴含在了我们的判断条件（能否走完这段路程）中，能不能“**把这些信息分离出来从而省略判断一些点**”呢？我们考虑：去掉起点以第二个点为起点，由于原先的起点一定满足ai>=bi，所以从现在的起点出发仍不能通过上一个中断点，更别说一些中间点还到不了此时的中断点呢，下面用式子来说明：

假如我们从1号点出发，到3号点油量不能支撑，有以下关系式：

A: **a1>=b1**

B: **a1+a2>=b1+b2**

C: **a1+a2+a3<b1+b2+b3**

显然，由A式和C式可以推出**a2+a3<b3+b3**，由B式和C式可以推出**a3<b3**(~~不推也知道~~）

也就是说，**一旦出现不能到达的情况时，经过的这些点都不可能作为起点了**，时间复杂度可以优化到**O（n）**。

另外，当确定答案时我们需要遍历所有n个点吗？回答是不需要。我们只用判断从1-n出发能否到第n点就行了。（可别忘了我们的前提——**总油量>=所需油量！**）

献上我自以为比其他题解更简洁的代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=1e5+5;
int a[maxn],b[maxn],now; 
int main(){
	int t,n;
	scanf("%d",&t);
	for(int k=1;k<=t;++k){
		scanf("%d",&n);
		now=0;
		for(int i=1;i<=n;++i)
			scanf("%d",a+i),now+=a[i];
		for(int i=1;i<=n;++i)
			scanf("%d",b+i),now-=b[i];
		printf("Case %d: ",k);
		if(now<0)printf("Not possible\n");
		else{
			int ans;
			for(int i=1;i<=n;){//这里的i代表起点
				now=0,ans=i;
				for(;now>=0&&i<=n;++i)//这里的i代表以后的点
					now+=a[i]-b[i];
			}
			printf("Possible from station %d\n",ans);
		}
	}
	return 0;
}
```










