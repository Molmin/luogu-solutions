首先要抓住题目的性质，把题目所问的提炼以下，就变成了这样的描述
### 题目描述
给定一个数 x = 1，初始sum = 1，每次可对x进行操作，将其值变为[x, x * 2]之间的任意一个数，然后将sum加上现在的x，问最少需要几次操作可以变成给定的数字n，同时对于每次操作输出 x 的改变量。
### 思路
要达到最少次数，贪心的想每次肯定加上最多的量 x * 2，然而每次最少加上变化过的x，所以最后一次加的数可能小于当前的x，但是没关系，可以让这次加上的那个小于x的数尽可能的往前移直到前一个数小于等于它，然后按照顺序求一遍答案即可。
具体看代码就通俗易懂了。
### 代码
```cpp
void solve() {
	int n;
	scanf("%d", &n);
	vector<int> v;
	int x = 1;
	while(n > 0) {
		if(n > x) v.push_back(x);
		else v.push_back(n);
		n -= x;
		x <<= 1;
	}
	sort(v.begin(), v.end());
	printf("%d\n", v.size() - 1);
	for(int i = 1; i < v.size(); i++) {
		printf("%d ", v[i] - v[i - 1]);
	}
	puts("");
}