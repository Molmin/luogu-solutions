注:为防止我自己的翻译没有通过,下面是一些题解中出现文字的定义.

- “松树”，指原题中 `spruce`，具体定义见题目描述。
- “根部点”，指原题中 `origin` ，一个**合法的**“松树”中最底行中间位置就是“根部点”。
- 本题解中 $(i,j)$ 表示的是矩形的第 $i$ 行,第 $j$ 列这个位置.

容易发现下面的性质：

1. 所有字符为 `*` 的位置均是一个大小为 $1$ 的“松树”；
2. 对于一个位置，如果它可以是一个大小为 $k$ 的“松树”的“根部点”，那么它便一定可以是大小为 $i(1\leq i\leq k)$ 的“松树”的“根部点”；
3. 对于位置$(x,y)$，能够构成一个大小为 $k(k>1)$ 的“松树”的“根部点”仅当位置 $(x-1,y),(x,y+1),(x,y),(x,y-1)$ 这 $4$ 个位置均可以是一个大小为 $k-1$ 的“松树”的“根部点”；

那么便可以得出做法：建立一个二维数组 $p$，其中 $p_{i,j}$ 表示第 $i$ 行第 $j$ 列能够构成“松树”的最大大小。

首先输入时如果位置 $(i,j)$ 是字符 `*` ,则 $p_{i,j}$ 初始赋值为 $1$ ,否则初始赋值为 $0$.

然后进行若干次枚举，每次枚举“松树”大小 $k$（从 $2$ 开始从小到大），之后枚举所有位置 $(i,j)$，如果这个位置满足上述判断条件，那么就使 $p_{i,j}=p_{i,j}+1$。

那么我们就可以得出答案（根据性质 $2$ ）：

$$\texttt{answer}=\sum_{i=1}^n\sum_{j=1}^{m}p_{i,j}$$

我们可以手推一个例子（这里的例子是样例的第三组数据）：

输入后我们便可以得到初始数组 $p$ 的值：
```
0 1 1 1 0
1 1 1 1 1
1 1 1 1 1
1 0 1 0 1
```
然后枚举“松树”大小，首先枚举大小 $2$ ,更新后的数组 $p$ 为：
```
0 1 1 1 0
1 2 2 2 1
1 2 2 2 1
1 0 1 0 1
```
然后枚举到大小 $3$ ,更新后的数组 $p$ 为：
```
0 1 1 1 0
1 2 2 2 1
1 2 3 2 1
1 0 1 0 1
```
容易看出不会存在大小超过 $3$ 的“松树”了，接下来统计所有 $p$ 所有位置的数字和，得出答案 $23$。

明显的，理论上的这种做法的时间复杂度是 $O(n^2m)$ 的，但因为我们枚举的是“松树”的“根部点”，所以我们可以通过“松树”大小来限制枚举的范围（因为有一些地方一定不可能成为某些大小的“松树”的“根部点”），达到减少枚举次数的目的。同时，矩形中最大的“松树”大小也不可能超过 $\min(n,\lceil \frac{m}{2} \rceil)$ ，这样也可以减去不必要的枚举。

详见代码。
```cpp
#include<bits/stdc++.h>
using namespace std;
int T,n,m;
char c;
int p[520][520];
int main(){
    cin>>T;
    while(T){
        T--;
        
		cin>>n>>m;
        for(int i=1;i<=n;i++)
            for(int j=1;j<=m;j++){
                cin>>c;
                if(c=='.') p[i][j]=0;
                else p[i][j]=1;
            }
        
        for(int k=2;k<=min(n,m/2+m%2);k++)
        for(int i=k;i<=n;i++)
        for(int j=k;j<=m-k+1;j++)
        if(p[i][j]>=k-1 and p[i-1][j]>=k-1 and p[i][j+1]>=k-1 and p[i][j-1]>=k-1)
        p[i][j]++;
       
        int ans=0;
        for(int i=1;i<=n;i++)
            for(int j=1;j<=m;j++)
                ans+=p[i][j];
        cout<<ans<<endl;
    }
    return 0;
}
```
