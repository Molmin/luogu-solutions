真心的毒瘤题  
光做这道题代码重构了3遍，提交了20+  
我还是太蒻了QAQ  
以上是废话  


------------
这道题一眼所见必为字典树，直接插入n个原始串，再直接匹配询问串即可，然而实现过程中遇到了很多问题


------------
### 第一代  
直接在find的里面修改，遇到问号直接累加  
然而出了问题——只过了一个测试点  
蒟蒻的我百思不得其解，实验多次无望的情况下开始了第一次重构代码


------------
### 第二代  
只有五千次询问，且最多只有3个问号，显然可以暴力枚举出所有可能的串，再注意匹配，复杂度显然是可以AC的，更何况还放了2000ms的时限  
然而还是WA了，经过多次对拍发现神奇的现象：一共有n个字典串，然而有时查询的结果大于n!!!  
**显然统计了重复的串**  
打个比方：  
a??b  
'?'可以表示空，所以枚举后会出现**a' '?b**与**a?' 'b**，而我们在匹配的时候是忽略空字符的，那么以上的两种情况实际上是完全相同的，我们把相同的情况统计了多次  

------
### 第三代  
在第二代枚举的基础上，多开一个字典树，保留相同的串，保证在同一次询问中不会匹配两个完全相同的串，**空间复杂度即维护两个字典树，时间复杂度(nlen+mlen^2)**，复杂度是可行的,并获得了AC

------
### 第四代  
在第一代的基础上，把find函数修改一下，如：
```
void find(char *x,int now,int len,int p){
	int l,r;
	if(x[now]=='?'){
		l=0,r=4;
		if(now+1<=len&&x[now+1]=='?'){
			if(x[now+2]=='?'){
			  if(now+3<=len)
			    find(x,now+3,len,p);
			  else{
			   sum+=f[p].end;
		       return;
			   }
			}
			else if(now+2<=len)
			  find(x,now+2,len,p);
			else{
			sum+=f[p].end;
	        return;
			}
		}
		else if(now+1<=len)
		  find(x,now+1,len,p);
		else {
		sum+=f[p].end;return;
	    }
	}
	else l=r=x[now]-'a';
	for(int i=l;i<=r;i++){
		if(now==len){
			if(f[p].next[i])
			  sum+=f[f[p].next[i]].end;
		}
		else{
			if(f[p].next[i])
			  find(x,now+1,len,f[p].next[i]);
		}
	}
}
```
即我们不提前枚举，而是直接匹配原始串，遇到'?'的时候直接讲指针往后跳，也就是指连续问号这一段只匹配一次，匹配完直接跳过，这样可以保证匹配的唯一性  
如果巨佬觉得难理解的话结合代码画个图试试   

-----
### 后记  
做题不能太莽撞，一定要先做好准备工作，梳理好思路，千万不能像本蒟蒻一样，浪费了多次重构代码的时间以至于被[机房巨佬](https://www.luogu.org/space/show?uid=118273)狂虐  
至于代码还是自己写比较好QwQ  
愿这篇题解对你有些帮助