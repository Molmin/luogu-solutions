### 难度

这道题黄，但是用 Python 做，就会很简单（前提是去掉加速板子）。

### 思路

**关键思维**：这个问题的主要思想是向后思考。我们不考虑游戏将如何进行，而是考虑游戏的倒数第二个状态会是什么样子，等等。此外，我们还会处理游戏将立即结束的情况（即，当特殊节点是叶节点时）。

**详细解释**：首先，我们来处理游戏结束的情况。只有当特殊节点 $x$ 是叶节点时才会发生这种情况，所以我们所要做的就是检查 $\deg[x]=1$。请注意，$n=1$ 必须在这里单独处理（仅输出```Ayash```）。

在 $x$ 不是叶节点的情况下，答案如下：如果 $n$ 是奇数，```Ashish```获胜，如果 $n$ 是偶数，```Ayush```获胜。

根据关键思想的提示，让我们反向分析这个游戏（为了清楚地解释，假设 $n>10$）。当 $x$ 从游戏中移除时，它不能是剩下的唯一节点（因为之前的玩家可能也移除了 $x$，因此他没有以最佳方式玩）。假设游戏的结构与最后一步的 WLOG 类似（连接到 $x$ 的树可以是任意树）。

想想```Ayush```赢了，最后一步是移除 $x$。现在，在这一举动之前的状态可能是什么？如果```Ashish```从树上移除了一个节点，那么他就没有发挥出最佳效果：因为他本可以移除 $x$！因此，他一定从 $x$ 上移除了一些东西。

考虑到这种情况，```Ashish```实际上不应该移除它，而是应该从树上移除另外一些东西。因此，我们假设游戏结束时的状态是不可能的：实际上，连接到 $x$ 的树应该只包含一个节点（我们已经证明 $x$ 不能是剩下的唯一节点）。

这样子，那就解出来了。

### 代码

我把板子给去掉了以后~~变得非常非常简单~~：

```python
for _ in range(int(input()) if True else 1):
    n, x = map(int, input().split())
    graph = [0]*(n+69)
    graph2 = [0]*(n+69)
    for _ in range(n-1):
        p, q = map(int, input().split())
        graph[p] += 1
        graph[q] += 1
        if p != x and q != x:
            graph2[p] += 1
            graph2[q] += 1
    if graph[x] <= 1:
        print("Ayush")
        continue
    print("Ayush"if (sum(graph2) - n) % 2==0else "Ashish")
```
结束了。