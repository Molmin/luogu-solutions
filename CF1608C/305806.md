# CF1608C Game Master

提供一种没在题解区看到的解法。

如果简单的考虑一个人是否可以通过自己不断地改变 $a,b$ 场地来获得最终的胜利是连样例都过不了的。为什么呢？举个例子：某个人的战斗力分别是 $4$ 和 $1$  ，而另一个人是 $5$ 和 $2$ ，那么现在看来前者永远赢不了。但如果这时候来了一个人是 $3$ 和 $3$ ，那么他就可以先让这个人把那个啥都比他强的人干掉，然后自己把他干掉。

所以这道题的限制条件看上去比较复杂，但仔细思考一下这个例子可以发现，设两个人的战斗力分别是 $(a_1,b_1),(a_2,b_2)$ ，如果有
$$
(a_1>a_2\wedge b_1<b_2)\vee(a_1<a_2\wedge b_1>b_2)
$$
那么这两个人的胜负关系是等价的，即他们要么都能赢，要么都会输。

证明比较简单，他们可以利用双方较大的值来将两个人“合并”成一个人，战斗力为 $(\max(a_1,a_2),\max(b_1,b_2))$ ，如果能把其他人干掉，那他们可以最后可以随便选一个人赢；如果干不掉，那他们自己肯定干不掉。

有这个条件好像就可以像大多数题解一样建图搞了，但我是建立了坐标系。

把每个人看成一个二维坐标上的点，坐标为 $(a,b)$ 。

那么，如果两个点的胜负关系等价，他们的位置关系如图所示：

![img](https://cdn.luogu.com.cn/upload/image_hosting/3ajwzg4q.png?x-oss-process=image/resize,m_lfit,h_1000,w_1000)

那我们可以在这样的所有点对之间连一条线（其实就是图论的连边），然后由于 $a$ 最大的点肯定可以获胜，所以所有和 $a$ 最大的点联通的点都可以获胜。然后考虑如果暴力连边的话复杂度是 $O(n^2)$ 的。于是可以考虑这样一件事情：我们只考虑和 $a$ 最大的点联通的点，把当前已经确定联通的点全部拿出来，画出这样一个图：

![img](https://cdn.luogu.com.cn/upload/image_hosting/jg9ueeiv.png?x-oss-process=image/resize,m_lfit,h_1000,w_1000)

为啥要这样干呢？因为考虑到一个点它可以连线到的点所在范围长这样子：

![img](https://cdn.luogu.com.cn/upload/image_hosting/bzdg6glm.png?x-oss-process=image/resize,m_lfit,h_1000,w_1000)

那么，这些点共同形成的有效区域即为这个样子：

![img](https://cdn.luogu.com.cn/upload/image_hosting/06qo7za7.png?x-oss-process=image/resize,m_lfit,h_1000,w_1000)

其实容易发现有效区域只由四条线决定：$x=\max\{a\},x=\min\{a\},y=\max\{b\},y=\min\{b\}$ 。

然后就可以考虑维护有效区域来连边了：

先对所有点按 $a$ 从小到大排序。用一个 set 存之前处于非有效区域的点（有效区域只会随点数的增加变大，之前不处于有效区域的之后可能处于）。倒着考虑，第一个点肯定满足要求。然后依次考虑加进来的每个点。

由于是按 $a$ 从大到小加的，所以当前点的位置关系其实只有两种情况：

![img](https://cdn.luogu.com.cn/upload/image_hosting/3adreuk7.png?x-oss-process=image/resize,m_lfit,h_1000,w_1000)

![img](https://cdn.luogu.com.cn/upload/image_hosting/4b0sx0eq.png?x-oss-process=image/resize,m_lfit,h_1000,w_1000)

（深蓝色线表示有效区域）

对于第一种情况，它不属于有效区域，那么就把它加入 set 。

对于第二种情况，它属于有效区域，那么就标记它合法，并更新有效区域且要维护 set 。

对于有效区域的更新其实很简单，因为排过序，所以决定一个点是否在有效区域内的唯一标准只有 $\min\{b\}$ ，大于它就在里面，反之不在（虽然对于这个点来说这个更新没有意义）。

然后考虑维护 set 。满足什么样条件的点会被新的有效区域覆盖并被标记合法呢？对于 $a$ 这一维，因为排过序，所以一定合法。而对于 $b$ 这一维，可以发现只要比当前点的 $b$ 小就行了。（注意这时就要更新 $\min\{b\}$ 了）

这样算法就结束了，实际实现的时候set用堆替换就行了。