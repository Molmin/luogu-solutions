线性做法！

观察这题的数据范围是 $5\cdot 10^5$，暴力枚举会 TLE，我们先来考虑可以被分成两个相同子串的字符串所具有的性质：所有字母的出现次数均为偶数。

再来考虑如何优化：显然一个字符串所有子串的数量为 $n^2$，需要减少这个数量。

此时我们发现任意两个前缀相减就能得到所有的子串那么如果想让两个前缀相减得到的字符串满足那个性质，前缀有什么要求呢？

不难发现，两个前缀中任意字母的出现次数相减得到的一定是偶数，简而言之，两个前缀中任意字母的出现次数的奇偶性相同，而字母只有 $10$ 种，$0$,$1\cdots 9$。

考虑状压 DP，出现次数为奇数表示为 $1$，偶数表示为 $0$，存每个前缀中给定 $0\cdots 9$ 出现的奇偶的方案数。

比如 $f[10000][1001011010]$ 意思就是前 $10000$ 个前缀中，满足 $1$，$2$，$4$，$7$，$9$ 出现的次数为偶数，$0$，$3$，$5$，$6$，$8$ 出现的次数为奇数的前缀数量。

第 $i$ 轮先把状态算出来，然后答案加上前面和它状态一样的，最后再把它的状态加上去。

另外需要注意，刚开始啥都不选的方案也有一种，以及开 LL。

```cpp
talk is cheap,show me the code:
```
简短的代码：

```cpp
#include <cstring>
#include <iostream>
using namespace std;
char s[500005];
int len, f[1024] = {1}, cnt[15];
long long ans;
signed main () {
	scanf ("%s", s + 1);
	len = strlen (s + 1);
	for (int i = 1; i <= len; ++ i) {
		++ cnt[s[i] - 48];
		int mask = 0;
		for (int j = 0; j <= 9; j ++) mask |= (1LL << j) * (cnt[j] & 1);
		ans += f[mask] ++;
	}
	printf ("%lld", ans);
	return 0;
}
```