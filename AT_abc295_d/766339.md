**翻译**

给你一个只包含数字的串 $S$，记它以下标 $l$ 的字符开头，以下标 $r$ 的字符结尾的子串为 $[l,r]$，求有多少个 $[l,r]$ 能通过改变字符位置变成一个完全由两个相同字符串组成的串。

**分析**

易发现，只要一个字符串所有字符都有偶数个，它就是符合题意的。那么我们就可以建立 $tot$ 数组，用 `tot[i][j]` 记录在第 $i$ 位之前及第 $i$ 位 字符 $j$（这里因为原串只含数字，所以可以这样记录）出现的次数，易得 $tot$ 数组递推公式，即除了 $tot_{i_{S_i}}$ 要加一之外，其它都与 $tot_{i-1}$ 相同即可。

注意到 $S$ 的最长长度为 $5\times 10^5$，朴素算法 $O(n^2)$ 过不了，所以继续找规律。

我们会发现，只有当两个 $tot$ 数组中的数 `tot[i][n]` 与 `tot[j][n]` 模 $2$ 相等时，其差才会是偶数，并且当一个 `tot[i]` 与一个 `tot[j]` 的所有字符模 $2$ 相等时，$[i,j]$ 才是符合题意的子串。那么我们可以进行一个基本的状态压缩：化为二进制。

记 $|S|$ 为 $S$ 的长度，我们对于所有 $1\le i\le |S|$ 的整数 $i$，与所有 $0\le j\le 9$ 的整数 $j$，将 `tot[i][j]` 乘上 $2^j$ 再加起来，可以得到一个状态，可以证明一个状态只对应一种 $tot$ 的值。数字只有 $10$ 个，所以对应的状态只有 $2^{10}=1024$ 种。开一个 $a$ 数组记录状态，$a_i$ 表示第 $i$ 个状态的出现次数。对于一个状态的出现次数 $x$，只需要选取其中 $2$ 个便可以成为符合题意的字符串，易得结果就是 $x\times (x-1) \div 2$ 种选择方法，所以答案就是 $\sum a_i\times({a_i-1})\div 2$。

**AC Code**
```
#include <iostream>
#include <string>
#include <cmath>
using namespace std;
long long tot[int(5e5+10)][10],a[1025];
int main()
{
	long long t,ans=0;//比赛时没开long long吃了一次罚时，各位千万要记住开long long啊
	string s;
	cin>>s;
	long long n=s.size();
	for(int i=1;i<=n;i++)
	{
		for(int j=0;j<=9;j++) tot[i][j]=tot[i-1][j];
		tot[i][s[i-1]-'0']++;//递推tot数组
		for(int j=0;j<=9;j++) tot[i][j]%=2;//只计算其模2的结果，所以可以直接对2取模
	}
	for(int i=1;i<=n;i++)
	{
		t=0;
		for(int j=0;j<10;j++)
		{
			t+=pow(2,j)*tot[i][j];//计算其对应状态
		}
		a[t]++;
	}
	a[0]++;//第0种状态对应的是S中第一个字符
	for(int i=0;i<=1024;i++)
	{
		if(a[i])
		{
			ans+=a[i]*(a[i]-1)/2;//计算答案
		}
	}
	cout<<ans;
	return 0;
}
```
