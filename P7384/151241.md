戳[这里](https://www.luogu.com.cn/blog/zym20070228/solution-p7384#)食用体验更佳。

看到各位大佬的题解都是并查集的，这里来一个更加简单但理论上可能被卡的方法。

## 一、题意分析

原题面：给你 $n$ 个数，将它们分成任意组（可以不连续），将每个组内的数按位或，并将各组的结果累加，在保证其结果最小的情况下求最多分成的组数。

标几个重点：1. 可以不连续 ，2. 保证其结果最小。

首先有一个明显的结论：把所有的数都或起来（即分成一组）的值一定最小，因为两个数或起来的值一定小于等于和。假设我们已经将所有数合成了两个数，我们需要考虑：要让这两个数加起来的值和或起来的值相等，也就是在二进制下每一位都最多有一个数为 1 。那么我们可以发现：如果两个数（二进制下）有某一位都为 1 ，那么这两个数必须在同一组。这就是我们分组的关键。

## 二、实现方法

在考场时我压根就没想到“拆位+并查集”，于是我用了一个更简单暴力的方法：模拟分组的过程。

假设现在已经分了若干组，对于每一个数，考虑它是否需要分入这一组，如果所有组都不需要，那么这个数可以成为新的一组。如果有一个数可以被分入多组，则要把这些组全部合并。还有一个特殊情况，如果这个数为 0 ，则可以直接把答案加 1 。最后答案就是 0 的个数加上剩下的组数。

考虑优化……暴力我优化个寂寞？

最后复杂度分析，这就体现了暴力的问题，由于要搜索每一组，所以我们算法的时间复杂度应该是 $O(np)$ ，其中 $p$ 是组数。然而这个复杂度分析也有一定问题，因为组数一直在变化 ~~，所以复杂度是 O(玄学)~~ 。但是我们可以大概的算出最坏复杂度：因为各个组的值在二进制下的每一位最多有一个组为 1 ，所以最多有 $\log(a_i)$ 组。如果出题人出一组所有 $a_i$ 均为 $2^k$ 形式的数据，那么这份代码肯定是过不了的。不过，我的代码实测最慢的点也只有 382 ms ，证明暴力还是很香的（可能出题人压根没想到会有我这么碰运气的）。

## 三、代码

由于我们需要删除（合并时用）和计算总组数的操作，很容易想到用 vector 来维护。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define getchar()(p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
char buf[1<<21],*p1=buf,*p2=buf;
template <typename T>
inline void read(T& r) {
	r=0;bool w=0; char ch=getchar();
	while(ch<'0'||ch>'9') w=ch=='-'?1:0,ch=getchar();
	while(ch>='0'&&ch<='9') r=r*10+(ch^48), ch=getchar();
	r=w?-r:r;
}
#define ll long long
const int N=1e7+5;
int n,ans;
vector <ll> p;//维护当前的组 
int main()
{
	read(n);
	ll now;
	for(int i=1;i<=n;i++)
	{
		read(now);
		if(now==0)
		{
			ans++;
			continue;
		}//当前数为 0 ，直接把答案加 1 
		int st=-1;//当前匹配到的组，初值为 -1 
		for(int j=0;j<p.size();j++)
		{
			if((p[j]|now)<p[j]+now)//需要加入这个组 
			{
				if(st==-1)//如果还没被分到，加入这个组 
				{
					p[j]|=now;
					st=j;
				}
				else//否则将两个组合并 
				{
					p[st]|=p[j];
					p.erase(p.begin()+j);
					--j;
				}
			}
		}
		if(st==-1) p.push_back(now);//没被分到，直接开一个新组 
	}
	printf("%d",ans+p.size());
	return 0;
 }
```

最后送大家一句话：实在不会做就暴力骗分 ~~，没准就正解了呢~~。