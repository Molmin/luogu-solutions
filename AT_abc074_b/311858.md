[原题传送门](https://www.luogu.com.cn/problem/AT3533)。
[在窝的博客中食用更佳](https://www.luogu.com.cn/blog/MZY666/solution-at3533)。

### 【 题意概括 】

先输入两个数 $n$，$k$，表示有一个 $n$ 行 $k$ 列的平台。每一行有且仅有一个球。

随后输入 $n$ 个数。第 $i$ 个数表示在第 $i$ 行的那个球的坐标。

在每一行的坐标为 $0$ 和 $k$ 的地方各有一个机器人。

求捡起所有球所费机器人的路程最小和。

### 【 思路 】

很明显，对于在第 $i$ 行的球，让在第 $i+1$ 或 $i-1$ 行的机器人去捡是非常不划算的。

那么只需要在每一行把球和两端的距离进行比较，取其最小值即可。所以可以边读入边计算。

是时候上代码了！

### 【 代码实现 + 注释 】

```cpp
#include<bits/stdc++.h>//万能头文件好 
using namespace std;
int main(){
	int n,k,ai,ans=0;//先定义好，注意ans初始化为0
	scanf("%d%d",&n,&k);//输入n,k
	while(n--){
		scanf("%d",&ai);//输入
		ans+=min(ai-0,k-ai)*2;//路程和加上，因为是往返距离所以要乘2
	}
	printf("%d\n",ans);//输出ans，换行是个好习惯
	return 0;//over~
}
```

这时，我锐利的小眼神发现某人的题解中出现了这句话（非恶意吐槽）：

>相比楼上两篇题解用min代替if将核心缩短至一行。

恩，比压行怎么能不叫上我呢！（人家题解中不是压行的意思啊喂）

来，看看我的压行水平咋样！有钱的捧个钱场，没钱的捧个人场啊！

```cpp
#include<iostream>
using namespace std;int main(){int n,k,i,s=0;cin>>n>>k;while(n--)cin>>i,s+=min(i-0,k-i)*2;cout<<s;return 0;}
```

~~当然如果在某OJ上交用main，去掉return 0;也可以。~~

咳咳，以上内容纯属放松一下，不推荐比赛中使用。

对了，由于作者自愿禁言了，如果有建议请私信。否则将**无法**回复您哦！

完结撒花~（疯狂暗示$-v-$