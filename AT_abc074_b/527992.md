# 题目大意:
有一个 $NK$ 的平台，每一行 0 和 $K$ 的坐标上都有一个机器人，第 $i$ 行有一个位于坐标 $x_i$ 的球。机器人收到启动指令之后，如果该行还有球，就移动到球的位置，捡起球，再回到原来的位置；如果该行的球被另一个机器人抢了，就原地不动。请你安排机器人的启动顺序，使得机器人总移动距离最短。

# 分析:
首先,我们考虑使用贪心的思想，一行两端各有一个机器人，并且之间有一个球，因为我们要求机器人的最短距离，所以让其他行的机器人去另一行是不划算的，接着我们只需要判断一行中两个机器人走的路程的较小值即可，最后输出最短移动距离。

# Code:
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int a[100005];    //定义一个数组为球的坐标
signed main()
{
	int n,k,ans=0;
	cin>>n>>k;
	for(int i=1;i<=n;i++)
	{
		cin>>a[i];	
		ans=ans+min(a[i],k-a[i])*2;   //注意，题目要求机器人回到原来的位置,所以要*2
	}
	cout<<ans<<'\n';  //最后输出最短移动距离
	return 0;
}

```

