**本蒟蒻第一篇题解**  
写得不好见谅  
其他题解都是$O(n^3)$的,  
我来发一个$O(n^2)$的.  
50ms  
因为我在比赛时做到数据是(1<=R,S<=2000).  
(~~然而比赛时没有做出来~~）  

$\Large \text{本题的}\Large O(n^2)\Large \text{算法要使用栈，不会的请先学会栈}$  


大家可能做过下面这题  
![](http://poj.org/images/2559_1.jpg)  
给一个柱形图,求柱形图中面积最大的矩形的面积  

原题[POJ2559](http://poj.org/problem?id=2559)  
此题对应数据的算法是$O(n)$的，要用到单调栈.  
对于每一个高度，(用单调栈)求出它用这个高度可以覆盖到的左右两个位置$st[\;i\;],ed[\;i\;]$  
那么$ans=max(ans,h[\;i\;]\times(ed[\;i\;]-st[\;i\;]+1)$  
至于如何$O(n)$求出$st[\;i\;],ed[\;i\;]$?在下面会有详解

本题类似上面的题目，不过变成了二维的，面积也变成了周长.  
不过做法类似，同样要使用单调栈.  
先预处理：
```cpp
scanf("%d%d",&n,&m);
for(int i=1;i<=n;i++)
for(int j=1;j<=m;j++)
{
	ch=getchar();
	while(ch!='.'&&ch!='X')ch=getchar();
	if(ch=='.')a[i][j]+=a[i-1][j]+1;
}
```
$a[\;i\;][\;j\;]$代表第i行第j列自己及上面有多少个连续空位  
也就是转换成上面的题目(柱形图).  

如何求$st[\;j\;],ed[\;j\;]\;:$  
维护一个单调递增的栈,  
如果当前值小于栈顶就弹出栈顶以维护单调性.  
当一个元素入栈，根据情况维护$st[\;j\;]$  
当一个元素出栈，根据情况维护$ed[\;j\;]$   

以下为详解 :  
入栈时 :  
如果是空栈，就说明当前值是最小值，即可以无限向左延伸，直到延伸到位置$1$,  
如果当前元素的值与栈顶相同，直接使用栈顶元素的$st$值就行了,  
如果当前元素与栈顶不同，就说明当前元素向左不能延伸到栈顶元素的位置，此时$st$值应该为栈顶元素位置$+1$.  
出栈时 :  
若被迫出栈，则栈顶元素大于当前值，栈顶不能延伸到当前位置，故栈顶的$ed$值为当前位置$-1$,  
若到最后都为出栈，即可以延伸到最右边，故$ed$值为$m$.  

最后是$ans$的处理方法(与上面的面积不同)  
$ans=max(ans,a[\;i\;][\;j\;]\times2+(ed[\;j\;]-st[\;j\;]+1)\times2)$  
(我是先求周长,在最后的时候$ans-1$)

贴AC代码(有详细注释)
```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int n,m;
char ch;
int a[2005][2005];
int st[2005];
int ed[2005];
//st和ed数组是循环利用的
int s[2005];
int p,ans,t;
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)
	for(int j=1;j<=m;j++)
	{
		ch=getchar();
		while(ch!='.'&&ch!='X')ch=getchar();
		if(ch=='.')a[i][j]+=a[i-1][j]+1;
	}//预处理转换成柱形图
	for(int i=1;i<=n;i++)
	{
		p=0;
		for(int j=1;j<=m;j++)
		{
			while(p&&a[i][j]<a[i][s[p]])
			{
				ed[s[p]]=j-1;//若被迫出栈，则栈顶元素大于当前值，栈顶不能延伸到当前位置，故栈顶的eded值为当前位置-1
				p--;
			}
			if(p==0)st[j]=1;//如果是空栈，就说明当前值是最小值，即可以无限向左延伸，直到延伸到位置1
			else 
			if(a[i][j]==a[i][s[p]])st[j]=st[s[p]];//如果当前元素的值与栈顶相同，直接使用栈顶元素的st值就行了
			else st[j]=s[p]+1;//如果当前元素与栈顶不同，就说明当前元素向左不能延伸到栈顶元素的位置，此时st值应该为栈顶元素位置+1
			p++;
			s[p]=j;
		}
		while(p)
		{
			ed[s[p]]=m;//若到最后都为出栈，即可以延伸到最右边，故ed值为m
			p--;
		}
		for(int j=1;j<=m;j++)
		if(a[i][j])
		ans=max(ans,(a[i][j]<<1)+((ed[j]-st[j]+1)<<1));//处理答案，a<<1等价于a*2
	}
	printf("%d",ans-1);//主人不算客人，客人数为周长减一
	return 0;
}
```
如有错误请指出，谢谢