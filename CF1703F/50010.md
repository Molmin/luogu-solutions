**一步一步来**

我们先观察到题目的要求 $a_i<i<a_j<j$

首先很容易就会想到暴力的 $O(n^2)$ 做法，枚举 $i,j$ 判断可行的个数。

对这个暴力稍微优化一下那就是每次的 $j$ 都从 $i+1$ 开始枚举，当然这只能优化一些常数

考虑到数据范围 $n$ 在 $10^5$ 左右，所以可以考虑 $O(n)$ 或 $O(n \log n)$的做法

那么我们就要想办法把 $O(n^2)$ 的方法里优化掉一个循环

面对处理序列的问题，我们会尝试观察题目条件中的单调性来优化

那我们来观察一下：$a_i<i<a_j<j$

哎嘿，好像真的有单调性：如果我们枚举 $i$，那么 $i$ 就是单调递增的，随着 $i$ 的增大，满足条件的 $a_j$ 个数便越来越少了。

那我们拆分一下条件，先枚举 $j$ ，把所有满足 $a_j<j$ 的 $a_j$ 扔到一个数组 $b$ 里。然后对 $b$ 从小到大排序

记录 $b$ 的长度为 $m$ 

注意 $a,b$ 的下标都从 1 开始

然后我们留一个变量 $p$，$p$ 一开始等于 1

然后从1开始枚举 $i$

如果 $i$ 满足 $a_i<i$，我们就看看 $i$ 是否小于 $b_p$ ：

- 如果 $i<b_p$ ，那么 $b_p$ 到 $b_m$ 都满足大于 $i$ （因为数组 $b$ 已经排序过了），那么对于这个 $i$，他对答案的贡献就是 $m-p+1$。

- 否则，我们就让 `p++`，直到 $i<b_p$，注意判断边界条件。

读到这里，可能你就对这题大概有思路了。

而我们在实现的时候需要注意一些小细节：我们在编程的时候一般习惯让数组下标从 0 开始，而题目中的 $i,j$ 都是从1开始的。所以我们在写比较条件的时候可能就要写 `i+1`，`j+1` 而不是 `i`，`j`。

OK，思路就讲到这里。

（碎碎念）：笔者是退役 OIer，准大一新生，目前处于复建状态。看到其他题解里的树状数组，甚至二分，我都有些不太熟悉了，令人感慨。此外，受到学长推荐，最近我在自学 python，所以最近我都尝试用 python 写题目，但我 python 的代码风格不可避免的受到了 C++ 的影响，望海涵。

啊，时光荏苒……

#### Code:
```python
T = int(input())
while T:

    T -= 1
    n = int(input())
    a = list(map(int, input().split()))
    b = []
    cnt = 0
    ans = 0
    for i in range(n):
        if a[i] < i+1:
            b.append(a[i])
            cnt += 1
    b.sort()
    j = 0
    for i in range(n):
        if a[i] < i+1:
            while j < cnt and b[j] <= i+1:
                j += 1
            ans += cnt - j
    print(ans)

```



