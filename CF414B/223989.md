## 一、前言

本题是一道较简单的 DP，主要考察思维能力，是一道较好的**线性 DP** 的练手题。

## 二、题意

给出一个数列中的最大元素 $n$（**注意！：题目有误，这里应该是每一种数列中的最大值不能大于** $n$）,和数列的长度 $k$，求满足**后一个数都能被前面的一个数整除**的数列的个数（对 $10^9+7$ 取模）。

## 三、思路

首先看到求方案数的题目，大概率就是 DP 了（~~还有暴搜~~），再看数据范围（$1 \leq n,k \leq 2000$），在 DP 的时间复杂度可接受的范围内。

## 四、动态规划

### （1）状态

首先对于动态规划设计状态，一定要看**题目求什么**以及**什么会影响答案**，将状态设成所求的东西（就好像数学方程中设未知数的原则**求什么设什么**），再将**会影响答案的**写进状态下标。

比如这题，求的是**满足条件的数列种类**，因此我们设 $f(i,j)$ 为**最大元素为 $i$，长度为 $j$ 的满足条件的数列个数**。最大元素、数列长度即为**影响答案的因素**。

### （2）转移

本题转移的关键就在题目的条件：**后一个数都能被前面一个数整除**，显然当我们转移到 $f(i,j)$ 的时候，其方案数一定是由**前一个元素是 $i$ 的因数，长度为 $j-1$ 的方案数累加而成**。即

$$f(i,j)+=f(t,j-1) \ (t \ | \ i)$$

### （3）初始化

我们会发现，最大元素为 $1$ 和数列长度为 $1$ 的数列个数都为 $1$。

## 五、注意点

对于每一个数，我们可以想到预处理出它们所有的因数，转移时直接枚举每一个因数即可。

## 六、代码

```cpp
#include<bits/stdc++.h>
#define re register
using namespace std;
typedef long long ll;

const int N=2007;
const int mod=1e9+7;
ll n,k,f[N][N],ans;
vector<int>p[N];

//预处理出所有的因数 
inline void pre()
{
	for(re int i=1;i<=n;i++)
		for(re int j=1;j<=sqrt(i);j++)
			if(i%j==0)
			{
				p[i].push_back(j);
				if(j!=i/j)
					p[i].push_back(i/j);
}
}

int main()
{
	scanf("%lld%lld",&n,&k);
		
	//初始化 
	for(re int i=1;i<=n;i++)
		f[i][1]=1;
	for(re int i=1;i<=k;i++)
		f[1][i]=1;
	
	pre();

	//转移 
	for(re int i=2;i<=n;i++)
		for(re int j=2;j<=k;j++)
			for(re int t=0;t<p[i].size();t++)
				f[i][j]=(f[i][j]+f[p[i][t]][j-1])%mod;
	
	for(re int i=1;i<=n;i++)
		ans=(ans+f[i][k])%mod;
	
	printf("%lld",ans);
	
	return 0;
}
```
