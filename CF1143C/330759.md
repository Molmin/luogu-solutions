## 题目大意

> $n$ 个节点构成了一棵树，每个节点都会尊重或者不尊重它的所有祖先。现在按照编号从小到大删除每一个**不尊重祖先且它的 _直接_ 儿子不尊重它**的节点。输出所有被删除的节点，或者输出 $-1$ 。  
特别地，根节点必定尊重它的祖先。

**注**：题面上的翻译省略了删点这个过程。虽然可以证明删点不会对答案造成任何影响，但是这么做思维难度直接没了……

## 题解

并不是一道很难的题，评蓝有些高了……

考虑一个节点被删除后对答案可能造成的影响。事实上，它不会造成任何影响。这个结论可以算是本题的关键。考虑如何证明。

一个节点被删除的充要条件是：

- $1.$ 它的直接儿子都不尊重祖先（或者没有儿子）。
  
- $2.$ 它不尊重祖先（尽管它可能没有祖先）。

显然由于根节点必定尊重祖先，所以根节点不会被删除。考虑删除一个不是根节点的节点。为了叙述方便，设它为 $u$ ，它的父节点为 $fa$ 。

- 假设 $fa$ 本来就要被删除，那么删除 $u$ 后，新接上去的节点肯定也不尊重 $fa$ （由条件 $1$ ），于是不会改变 $fa$ 的定性。

- 假设 $fa$ 本来不要被删除，那么删除 $u$ 后也不会使 $fa$ 变得要删除（由条件 $2$ ，$u$ 肯定不尊重 $fa$ ，于是 $fa$ 有其他的直接儿子尊重它）。

于是我们证明了删除一个节点不会产生任何影响。那么做起来就很简单了：枚举每个节点，看它直接儿子是不是都不尊重它，再看这个节点是否尊重祖先，就能决定是否删除它了。由于一共只有 $n-1$ 条边，于是枚举的总时间花费应该是 $\mathcal O(n)$ 的。

关于最后的从小到大输出。事实上，我们直接枚举序号 $1,2,\cdots n$ 就行了，甚至不需要排序。

什么？你觉得遍历一遍边常数太大了？事实上，我们完全不需要建图。由于本题输入了每个节点的父节点，于是只要另开一个 $\text{bool}$ 数组用于存储每个节点直接儿子是否都不尊重它就行了。常数再次缩小……

**时间复杂度**： $\mathcal O(n)$ 。

## 参考代码

```cpp
#include<bits/stdc++.h>
#define up(l,r,i) for(int i=l,END##i=r;i<=END##i;++i)
#define dn(r,l,i) for(int i=r,END##i=l;i>=END##i;--i)
using namespace std;
typedef long long i64;
const int INF =2147483647;
const int MAXN=1e5+3;
bool I[MAXN],J[MAXN],f; int n;
int qread(){
    int w=1,c,ret;
    while((c=getchar())> '9'||c< '0') w=(c=='-'?-1:1); ret=c-'0';
    while((c=getchar())>='0'&&c<='9') ret=ret*10+c-'0';
    return ret*w;
}
int main(){
    n=qread(),memset(J,1,sizeof(bool)*(n+1));
    up(1,n,i){
        int t=qread(); I[i]=qread(); if(t!=-1) J[t]&=I[i];
    }
    up(1,n,i) if(I[i]&&J[i]) printf("%d ",i),f=true;
    if(!f) puts("-1");
    return 0;
}
```