## 题意
给定一个 $n$ 个点的有根树，节点 $i$ 的父节点为 $p_i$（根节点的 $p_i$ 为 $-1$），每个节点有一个值 $b_i$，如果 $b_i$ 为 $0$ 表示这个节点尊重其所有祖先节点，为 $1$ 则表示这个节点不尊重其任何一个祖先节点。	   

对于一个节点 $x$，如果 $b_x=1$ 且对于 $x$ 的任意一个儿子 $son_x$ 都有 $b_{son_x}=1$，那么称节点 $x$ 为一个 ``Queen`` 节点。   

现在，我们要进行若干次操作，每次操作会删除当前树上的一个 ``Queen`` 节点 $v$（如果有多个则选择那个编号最小的），删除之后将 $v$ 的所有儿子 $son_v$ 与 $v$ 原本的父亲 $fa_v$ 相连（如果没理解这句话的话建议看题目描述里给的那个图），直到树上不存在任何一个 ``Queen`` 节点。请按顺序输出每次操作所删除的节点的编号，如果无法进行任何一次操作，输出 ``-1``。
## Solution
翻译其实给的不太好，相当于是把这个题化简了，只剩一个简单的模拟。
	
这道题的关键就在于，每次删点之后，没有任何节点会成为新的  ``Queen`` 节点，也没有任何 ``Queen`` 节点会变为非 ``Queen`` 节点。所以只需要按编号升序输出最开始树上的所有 ``Queen`` 节点即可。
 
假设现在我们删去了点 $v$，然后要将 $v$ 的所有儿子与 $fa_v$ 相连。因为 $v$ 是 ``Queen`` 节点，这代表着 $b_v=1$ 且 $\forall x\in son_v,b_x=1$。于是，这个操作相当于让 $fa_v$ 少了一个 $b_i=1$ 的儿子，多了若干个 $b_i=1$ 的儿子。如果原来 $fa_v$ 就是 ``Queen`` 节点，那操作之后仍然是；如果原来不是的话那么操作之后也不会变成 ``Queen`` 节点。

那么现在只需要找出最初树上的所有 ``Queen`` 节点了。实现这个连树都不需要建，时空复杂度均为 $O(n)$。
 
我们需要维护的是每个节点的 $b_i$，以及其子节点内是否有任何一个节点的 $b_i=0$。
开两个 ``bool`` 数组，每次读入时同步修改即可，如果读入的 $b_i=1$，则在另一个数组里将 $p_i$ 标记为 $1$。读入完之后遍历一遍 $1\sim n$，如果遇到了 ``Queen`` 节点就输出。 
 
## Code
```
#include <bits/stdc++.h>
using namespace std;
bool f[100001],p[100001];
int read(){
	int x=0,y=1;
	char ch=gc();
	while(ch<48||ch>57){
		if(ch=='-') y=0;
	 	ch=gc();
	}while(ch>47&&ch<58) x=x*10+ch-48,ch=gc();
	return y?x:-x;
}
void write(int x){
    if(x>9) write(x/10);
    pc(x%10+48);
}
signed main(){
	int n=read(),cnt=0;
	for(int i=1,x;i<=n;i++){
		x=read(),p[i]=read();
		if(!p[i]) f[x]=1;
	}for(int i=1;i<=n;i++) if(p[i]&&!f[i]) write(i),pc(' '),cnt++;
	if(!cnt) cout<<-1;
	return 0;
}
```
