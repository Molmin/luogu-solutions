此题数据范围 Kruskal 可以通过，因此只在此处讲解 Kruskal 算法，如需 Prim 算法的内容，移步 [【普及】最小生成树笔记](https://www.luogu.com.cn/blog/LinearExpectation/easy-MST-note)。

------

## 概念

最小生成树是无向图中的一个常见问题，描述如下：

给定一个连通无向图，可以删去一些边，问应该保留哪些边能使得图依然连通，并且边权和最小。

我们把这个生成出来的树（为什么是树？因为保留 $n-1$ 条边时最省，但凡多一条边，就会有一条边是多余的，他就不满足最小边权和了）称之为最小生成树（$\small\bm{Minimal\ Spanning\ Tree,MST}$。

## 思路引导

《算法竞赛从入门到进阶》中的一段话特别具有启发性：

> 图的两个基本元素是点和边，于此对应，有两种方法可以构造最小生成树 $T$。这两种算法都基于贪心法，因为 MST 问题满足贪心法的“最优性定理”，即全局最优包含局部最优。

两种算法是 $\rm\small Prim$ 和 $\small\rm Kruskal$ 算法。其中 $\rm\small Prim$ 算法基于这样一个思想：“最近的邻居（节点）一定在 MST 上。”，于此相对地，$\rm\small Kruskal$ 的基本思想是“最短的边一定在 MST 上”。

从这里我们会发现一个问题：两种截然不同的 MST 算法，得到的最小生成树一样嘛？说不准，因为 MST 在有些图（很多图）上是不唯一的，于是你会得出两个（甚至更多）不同的（但是总边权 $\sum w$ 相同的）答案。但是洛谷的例题就特别良心，只让你输出总边权，于是你可以选择你用得顺手的算法。

我们首先从比较简单的 Kruskal 讲吧。

## Kruskal 克鲁斯卡尔

我们要顺次选取边权最短的边，于是我们需要用一种较为朴素的存边方式，即“直接存边”。这个存边方式在普通 Bellman-Ford 中也有应用，可以去复习一下哦。

假设我们现在已经用 $\rm\small STL$ 中的 $\rm\small sort$ 把一共的 $m$ 条边全部都排序好了。现在我们需要加入第一条边，然后加入第二条边，然后加入第三条边，然后加入……等等，这么加下去不是所有边又加回来了吗？！

当然不行，我们只要加入有用的边。什么样的边是没有的呢？这里给出一个结论：会形成圈的边。因为如果形成了一个圈，那么你连上的这个节点就必然已经是连通的，这条边没有起到作用，我们应该要跳过他，然后再判断下一条边。

那我们应该怎么判断是否形成环呢？答案是并查集。“并查集是$\rm\small Kruskal$ 算法的绝配”这句话不是白说的，我们只要每次加入边的时候（假设是一条 $u$ 和 $v$ 之间的边），我们只需要把并查集中的 $v$ 指向 $u$ 的根节点，并且进行路径压缩即可，这样可以使得整个集合的编号是统一的，也避免了一棵树退化成一条链。

只要我们发现，$v$ 的祖先已经是 $u$ 的祖先了，也就是说 $u$ 和 $v$ 是**连通的**，我们就可以不要这条边——他是无用的。“这其实是发现了一个**圈**，并查集的作用就体现在这里。”

直到经过了所有的 $m$ 条边，就可以结束了，下面是代码：

```cpp
#include<bits/stdc++.h>
#define int long long
#define MAXN 2000005
using namespace std;
int fa[5005],n,m;
struct edge{
	int u,v,w;
}e[MAXN];
bool cmp(edge x,edge y){
	return x.w<y.w;
}int find(int k){//查询祖先 
    if(fa[k]==k)return k;
    return fa[k]=find(fa[k]);
}int kruskal(){
	int s=0;
	for(int i=1;i<=n;i++)fa[i]=i;//初始化并查集 
	sort(e,e+m,cmp);
	for(int i=0;i<m;i++){
		int u=find(e[i].u);
		int v=find(e[i].v);
		if(u==v)continue;//如果已经连通，就跳过
		fa[v]=u;s+=e[i].w;//加入集合，答案累计 
	}return s;
}signed main(){
	scanf("%lld%lld",&n,&m);
	for(int i=0;i<m;i++){
		int x,y,z;
		scanf("%lld%lld%lld",&x,&y,&z);
		e[i].u=x;e[i].v=y;e[i].w=z;
		e[i].u=y;e[i].v=x;e[i].w=z;
	}printf("%lld",kruskal());
	return 0;
} 
```

他的复杂度包含这几个部分：对边进行排序 $O(m\log m)$，并查集与遍历所有边 $O(m)$，在渐进意义上是 $O(m\log m)$，会发现在稠密图上他发挥地不会那么好，确实，编码简单的算法往往有着复杂度不尽理想的问题，面对数据范围比较大的题目，我们需要更优（却更难）的算法来解决。