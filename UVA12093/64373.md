### 题意

给出一棵无根树，现在要求你在树上选择一些节点放置$A$,$B$两种装置，$A$装置可以覆盖该节点周围的边（覆盖半径为$1$），$B$装置覆盖半径为$2$。$A$装置花费 $C_1$，$B$装置花费 $C_2$。求覆盖所有边的最少花费。

### 思路分析

首先，我们能看出这是一道树形DP的魔改题。由于是无根树，我们可以选定$1$号节点为根。与一般的树形DP不同的是，这道题目多了一个覆盖范围为$2$的条件。那么我们考虑从普通的树形DP来改变转移和状态来思考。

首先对于只有方案$A$的情况，我们令$dp[u][0/1]$表示是否在节点$u$上放置装置的最小花费。显然，我们可以将原来的“放置”更改为“放置装置$A$”和“放置装置$B$”。也就是$dp[u][0/1/2]$分别表示$u$点不放置装置或放置装置$A$或放置装置$B$。与魔改前的状态相同，此时的子树必须是全部被覆盖的状态。

我们可以思考一下魔改之后的转移方程。首先转移到$dp[u][0]$的方程。我们要覆盖这个子树的所有边，并且这个点不覆盖任何的边，那么这个点的所有儿子一定会覆盖至少一条边。所以得到：$dp[u][0]=min(dp[v][1],dp[v][2])$。

同理，如果这个点放上了装置$A$，那么他的儿子可以放置任何一种装置或者不放。得到转移方程$dp[u][1]=min(min(dp[v][0],dp[v][1]),dp[v][2])$。

那么这时候我们就会遇到一个问题：如果这个点放置装置$B$会怎样？同放置装置$A$理，我们要思考它的儿子。但是这时候我们应该思考的是它儿子的儿子，因为在上面的情况中它的儿子必须被放置。所以我们定义另一个情况表示它和它的儿子都不放置装置并且除了这个点链接儿子的边之外，这个子树上的所有边都被覆盖。定义这种情况为$dp[u][3]$。得到$dp[u][2]=min(dp[v][0/1/2/3])$。

所以关于$dp[u][3]$的转移，显而易见是从$dp[v][0/1/2]$转移过来了。

但是这样会发现我们少考虑了一种情况：一个节点放置装置$A$和在他的一个子节点上放置装置$B$效果是一样的。所以我们记录一个值表示这个情况的差值，最后再答案上更新就行了

### 参考代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,aa,bb;
int head[100010],cnt=0;
struct ss{
	int to,next;
}e[1000010];
inline void add(int a,int b){
	cnt++;
	e[cnt].to=b;
	e[cnt].next=head[a];
	head[a]=cnt;
}
int dp[10010][10010];
void dfs(int u,int f){
	dp[u][2]=bb;dp[u][1]=dp[u][3]=dp[u][0]=0;
	int cc=1e9;
	for(int i=head[u];i!=0;i=e[i].next){
		if(e[i].to==f){
			continue;
		}
		dfs(e[i].to,u);
		int yy=min(min(dp[e[i].to][1],dp[e[i].to][0]),dp[e[i].to][2]);
		dp[u][0]+=min(dp[e[i].to][1],dp[e[i].to][2]);
		dp[u][1]+=yy;//转移
		cc=min(cc,dp[e[i].to][2]-yy);//记录一个节点放置装置$A$和在他的一个子节点上放置装置$B$的差值
		dp[u][2]+=min(yy,dp[e[i].to][3]);
		dp[u][3]+=yy;
	}
	dp[u][1]+=min(aa,cc);//把一个节点放置装置$A$和在他的一个子节点上放置装置$B$的差值更新到答案
}
int main(){
	while(~scanf("%d%d%d",&n,&aa,&bb)){
		if(n+aa+bb==0){
			return 0;
		}
		memset(dp,0,sizeof(dp));
		memset(head,0,sizeof(head));cnt=0;
		for(int i=1;i<n;i++){
			int a,b;
			scanf("%d%d",&a,&b);
			add(a,b);add(b,a);
		}//初始化输入的树
		dfs(1,-1);//DP
		printf("%d\n",min(dp[1][0],min(dp[1][1],dp[1][2])));//找答案，因为三个情况都有可能是答案
	}
	return 0;
}
```

