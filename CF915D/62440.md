看到题以为这个数据会卡掉 $O(n^2)$，后来才发现这个居然可以放 $O(nm)$ 做法（所以哪里来的紫题难度）但显然还是应该考虑一下有没有线性做法。

由于找到一个环的时候总是必须选择删除这个环上的任意一条边，也就是一个找哪条边被所有环都覆盖的问题。

我们考察 Tarjan 算法的过程。（根据《算法竞赛进阶指南》）定义：

1. 树边：DFS 过程中搜索树中的边（即每个点第一次被访问时经过的边）
2. 前向边：从搜索树上祖先走向后代的边
3. 后向边：从搜索树上后代走向祖先的边。
4. 横叉边：除此之外的边，由于 DFS 的性质终点 `dfn` 小于起点。

`low[x] == dfn[x]` 意味着 `x` 不能通过走子树到达任何可以到达 `x` 的已访问节点。栈中从 `x` 到栈顶的所有节点都显然在 `x` 的子树内并且都不在任何环内（否则应该已经出栈）。所以如果我们发现存在一条后向边，我们就可以覆盖这两个节点间的路径。

如果是横叉边呢？如果终点处于栈中显然会减小 `low`，并且我们会发现不会存在任何环包含两条横叉边，那么就是会在这两个点的 LCA 处这整个环才会被处理。我们对搜索树上的这两个点走到 LCA 的一段路径进行覆盖。

至于 LCA 我们额外跑一遍 Tarjan 再进行树上差分即可。$O(m+n)$。输出是否存在一条边被所有路径都覆盖。观察到每一次覆盖都是在一个强连通分量内部，所以有多个大小大于 $1$ 的强连通分量就肯定无解。另外这个图不能在一个强连通分量内存在前向边。儿子全部回溯后需要重新扫描一遍所有边检查是否有前向边的终点尚未出栈。

考虑有没有可能最优解必须选择横叉边或后向边。显然若删除后向边，如果这条边沟通的两个点树上路径还与其它环重叠的话就不优了。若删除横叉边也有类似的问题。所以正确性可以保证。