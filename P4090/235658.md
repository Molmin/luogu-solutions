# P4090

**前言：大致的思路 1 楼的大佬已经说了，但是在细节和代码上还不是非常清晰，本篇题解进行进一步解释。**

## 题意简述

- 有 n 头牛排成一排，每次的队首—第 i 头牛拿了礼物后会被放到第 $n-c_i$ 的位置上
- 问有几头牛当不了队首（拿不到礼物）

## 题目分析

如其它题解所说，一头牛不能拿到礼物一定因为前面的牛构成循环。

可以二分这个形成循环的长度，然后判断这个循环是过短还是过长。

接下来是本篇题解的重点了，**如何判断这个循环过短还是过长？**

先放代码，边看代码边理解：

```cpp
bool check(int now){//循环长度
	if(now==1) return 1;//排在第一个的牛肯定能拿到礼物 
	for(int i=0;i<now;i++) b[i]=a[i];
	sort(b+1,b+now);//从小到大排序，此时我们不关注哪一头牛被放到了后面，我们关注是否有牛被放到二分的循环长度之外 
	int limit=n-now;//拿不到牛的数量 
	for(int i=1;i<now;i++){
		if(b[i]>limit) return 0;//这个循环中有拿不到礼物的牛，因为即使轮到它后它可以排到很前面，但因为前面已经成循环了，所以轮不到它 
		limit++;//有牛被放到循环后面了，后面的牛都可以往前移动一格 
	}
	return 1;
}
```

我们现在二分了一个循环长度 $now$ ，如果这个循环过长，实际上的循环更短，那么一种情况就是这一个循环中被放到最后面的元素仍在一些元素前面，那么这些元素即使拿礼物后可以放到比较前面，但他们没有拿礼物的机会（前面自成一个循环）。

为什么是一种情况呢？因为就算会被放在最后面的元素在循环外，还可能有放到倒数第二后面的元素在一些元素前面。（暂时没理解没关系，先往下看，下面有图片辅助理解）

所以我们可以将他们按 $c_i$（的副本） 排序。（这虽然暂时破坏了牛的编号与位置的对应关系，但是我们此时关注哪一头牛被放到了后面，我们关注是否有牛被放到二分的循环长度之外）然后逐个考虑。

```cpp
if(b[i]>limit) return 0;
```

看这行代码，你可能现在不理解为什么要 $limit++$ , 没关系，我们先看 i=1的时候。（$b[i]$ 的位置是不一定的，我们现在假设这堆牛中 $c$ 最小的是在这个位置）

![](https://cdn.luogu.com.cn/upload/image_hosting/j7n2t8ux.png)

黄线是第 $now$ 头牛，也就是当前循环的最后一头牛。如果 $b[1]>limit$ ，就代表 $b[1]$ 被放到了黄线前面，则循环内至少有一头牛 $now$ 在循环外，返回 0，缩短循环长度。

现在来看假如 $b[1]$ 在黄线后面的情况，

![](https://cdn.luogu.com.cn/upload/image_hosting/9zxqk6oe.png)

因为 $b[1]$ 放到了黄线后面，所以 $b[1]$ 后的那些牛都要往前一格，相当于黄线左移了一格，也就是 $"limit++"$ 。

然后把 $b[2]$ 当成新的 $b[1]$ 处理，如果这一段处理完都没有出现过短的情况，那么我们的循环长度就可能小了，应该记录答案然后判断更长的 $now$ 。

## 完整代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
void read(int &x){
	int f=1;x=0;
	char ch=getchar();
	while(ch<'0'||ch>'9') {if(ch=='-') f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9')  {x=x*10+ch-'0'; ch=getchar();}
	x*=f;
}
#define N 100010
int n,a[N],b[N],ans;
bool check(int now){
	if(now==1) return 1;//排在第一个的牛肯定能拿到礼物 
	for(int i=0;i<now;i++) b[i]=a[i];
	sort(b+1,b+now);//从小到大排序，此时我们不关注哪一头牛被放到了后面，我们关注是否有牛被放到二分的循环长度之外 
	int limit=n-now;//拿不到牛的数量 
	for(int i=1;i<now;i++){
		if(b[i]>limit) return 0;//这个循环中有拿不到礼物的牛，因为即使轮到它后它可以排到很前面，但因为前面已经成循环了，所以轮不到它 
		limit++;//有牛被放到循环后面了，后面的牛都可以往前移动一格 
	}
	return 1;
}
int main(){
	read(n);
	for(int i=1;i<=n;i++) read(a[i]);
	int le=0,r=n;
	while(le<=r){
		int mid=(le+r)>>1;
		if(check(mid)){
			ans=mid; 
			le=mid+1;
		}
		else r=mid-1;//这个循环内部有拿不到礼物的牛，实际上能拿到礼物的牛更少 
	}
	printf("%d\n",n-ans);
	return 0;
}
```

蒟蒻写题解不易，给个赞呗。