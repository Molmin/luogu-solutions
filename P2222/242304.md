## 矩阵乘法！！！
### Hello!我是萌新！在教练考矩阵前做的这一题，既然题解这么少，那我就来凑个热闹！
------------
### 这题考矩阵的乘法，还不了解矩阵之间如何相乘的同学可以先看看百度如何做矩阵的乘法！
### 假如你已经会了矩阵的乘法，不妨先想一想通过暴力手段强乘一通，显然仅计算的话时间复杂度是O(6*(nm))，我们的洛谷神机也许可以跑得过去，但是你的空间复杂度是O(3*(nm)),妥妥的炸空间啊怎么办？
------------
### 别急，车到山前必有路。不妨先想想矩阵乘法的性质，当两个矩阵做乘法时，新生成的矩阵的行数与第一个的行数相同，列数与第二个矩阵的列数相同（矩阵不具有交换律）。所以，本题目中三个矩阵相乘所生成的新矩阵的行数与A的行数相同，与C的列数相同。那么在新矩阵中，所查询的(x,y),x代表的行数从始至终都没有改变，这不就消去了一个维度吗？时间空间大大优化！同学们可能还会对输出有问题，下面，我附上代码讲述：
```cpp
#include<cstdio>
int x,y,m,n,o,p;
int i,j,c,i1,j1,c1;
int a[6005],b[6005];//这里我采取滚动数组的方式又删去了一个数组
int main(){
	scanf("%d%d%d%d%d%d%d%d%d",&x,&y,&m,&n,&o,&p,&i,&j,&c);
	while(true){
		if(i==x)a[j]+=c;
		i1=i;
		j1=j;
		c1=c;
		scanf("%d%d%d",&i,&j,&c);
		if(i<i1||(i==i1&&j<=j1))break;
        //由于本题目的输入非常规律，如果更换了矩阵一定会有行列的变化，这个变化的趋势只会小于或等于x,y（否则结果为0没意义啊），因此大可抓住这个小漏洞，进行更换矩阵输入的判断！
	}
	while(true){
		b[j]+=a[i]*c;
		i1=i;
		j1=j;
		c1=c;
		scanf("%d%d%d",&i,&j,&c);
		if(i<i1||(i==i1&&j<=j1))break;
	}
	for(int k=1;k<=6000;k++){
		a[k]=b[k];
		b[k]=0;
	}//滚动数组循环使用，你也可以用cstring底下的memcpy函数和memset函数进行操作，我比较懒哈！
	while(true){
		if(j==y)b[y]+=a[i]*c;
		i1=i;
		j1=j;
		c1=c;
		scanf("%d%d%d",&i,&j,&c);
		if(i<i1||(i==i1&&j<=j1))break;
	}
	printf("%d",b[y]);
	return 0;
}
```
### 有的细心的同学可能发现了，前面的输入没问题，但最后的一行输入完后不就卡死了吗？按理说是的，但是所有的评测都是以文件的形式输入的，所以在你的所有输入完后，是会默认添加一个文件尾表示结束，因此不会有任何问题（你交给洛谷神机测一下不就知道了咩？）。如果同学们想独自运行一下的话可手动加入文件尾：在所有你想输入的输入完后按下回车，再打出(Ctrl+z),再打出一个回车，就大功告成啦！
## 保佑我模拟赛顺利！！！！！