### [Tree and LCS](https://www.luogu.com.cn/problem/AT_arc156_c)

题目大意：

我们定义一个排列 $A$ 和$B$ 的相似性为 $S_i=B_{A_i}$， $S$ 和 $A$ 的最长公共子序列。

我们需要找到一个排列 $P$ 使得和给定树 $T$ 的所有简单路径的相似性的最大值最小。

先证明下这个相似性的最小值。

假如对于排列 $P$，我们肯定可以通过选择路径 $A:x\to P_x$，这样的话 $P$ 和 $A$ 的 LIS 即为 $1$ 了，此为答案的下界。 

现在我们不妨想一想如何构造或者证明存在一种方式使得我们可以保证答案就是下界。

考虑如下的一种神奇的构造方式：

我们将原树的所有叶子拎出来，放入一个队列。

1. 从队列中取出两个点，$u,v$，将 $P_u=v,P_v=u$。

2. 将两个点从树中删掉，然后将新生成的叶子放入队列中。

3. 重复操作直到只剩下一个叶子或者什么都不剩（剩下的一个叶子 $i$，$P_i=i$）

下面来证明为什么这样可以保证答案为 $1$。

首先，对于原图中的所有边，我们只选取极大路径，容易证明这时最大值肯定在这里面。

那么对于一个极大路径 $u\to v$，我们从中找出 $x,y$。

![](https://cdn.luogu.com.cn/upload/image_hosting/wafp3lk4.png)

我们假设 $A,P$ 的 LIS 中包含 $x\to p_y$，换句话说，在上述步骤中， $x,y$ 被匹配并且同时删掉了。

![](https://cdn.luogu.com.cn/upload/image_hosting/c4c1tumq.png)

图中边表示匹配。

那么对于 $A$ 中，位置在 $x$ 前的某一个点 $k$，他的匹配对象有两种可能：

1. 在 $u\to v$ 的路径中。

2. 不在 $u\to v$ 的路径中。

第二种情况不影响我们的 LIS 我们直接忽略。

考虑第一种情况中，和 $k$ 匹配的 $s$ 的位置。

我们判断 $k\to s$ 是否有可能对 LIS 产生贡献，只需要看 $s$ 在 $A$ 中和 $y$ 的相对位置即可。

我们可以证明 $s$ 如果存在在 $A$ 中，那么一定在 $y$ 的后方。

首先，原树是一棵无根树，我们不妨找一个根来帮助我们判断，我们让根是最后删除点/点对。（容易证明，如果最后存在两个点，那么他们一定是相连的）

在这棵树上有一个性质，对于某个节点 $p$，先要删除他就一定要把他的孩子都删除完。

借助这个性质，我们可以知道 $x,y$ 一定不是祖先关系，因为你要想删掉其中深度较小的点，肯定要先删掉深度更大的点。

我们设 $x,y$ 的 $\text{lca}$ 为 $c$。

那么树肯定是长这样的。

![](https://cdn.luogu.com.cn/upload/image_hosting/hfyuy62s.png)

而 $k$ 一定在 $x$ 的子树中，肯定先于 $x$ 被删除，既然如此，那么和他抵消的 $s$ 一定会在 $y$ 的子树中。如果不是，有两种可能：

1. $s$ 在 $c\to u$ 的路径中，那么 $s,k$ 存在祖先关系，假设不成立。

2. $s$ 在 $y\to x$ 中，那么想要删除 $s$，至少得先删除 $x,y$ 中的某一个，但是根据上方所说， $k$ 比 $x$ 先删除，互相矛盾，假设不成立。

那么，我们就完美的证明了它的正确性。
