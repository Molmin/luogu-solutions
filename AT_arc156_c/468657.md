## Solution

首先第一点，一个排列的价值肯定是大于 $0$ 的。因为我们可以选择一个路径为 $(u,P_u)$，这个样子的话 $x_k=P_u$，$y_1=P_u$，两者相等，价值至少为 $1$。

那么也就是说，如果我们能设计一个构造方案使得构造出来的排列价值为 $1$，那么也就解决了这题。下面我们先给出大致流程，然后给出证明：

1. 计算每个节点的度数并建一个新队列 $q$，设 $\{ans_n\}$ 为最终答案。
2. 把所有的度数为 $1$ 的节点塞进 $q$ 中。
3. 取出 $q$ 中的两个节点 $u,v$ 并删除，令 $ans_u\gets v,ans_v\gets u$。
4. 在树中删除节点 $u,v$，而后执行 $2$。
5. 当队列中的节点个数不小于 $2$ 时重复执行 $3,4$。
6. 如果 $n$ 为奇数，则应当还有一个 $ans_i$ 没有被赋值，则令 $ans_i\gets i$。
7. 最终得到的 $\{ans\}$ 即为所求。

证明：

- 考虑使用数学归纳法。
- 当 $n=1,2$ 时刻手动验证，显然符合要求。
- 当 $n\ge 3$ 时，设我们当前取出节点 $u,v$，删除 $u,v$ 后得到了一个 $n-2$ 规模的问题，可得满足条件；然后我们将 $ans_u\gets v,ans_v\gets u$，增加价值的唯一方法是通过新加进来的节点 $u,v$，即取路径 $(u,v)$ 的情况显然是最优的，至少不会比取其它路径差；而 $x_1=u$，而 $y_k=ans_{v}=u$，所以想要产生贡献必须要将第一个点和最后一个点配对，而这样我们无法继续配对，因为最后一个节点已经顶住了，所以最大价值仍为 $1$；将 $x_k=v,y_1=ans_{u}=v$ 同理。
- 则通过数学归纳法可得，该算法对于所有的正整数 $n$ 均成立；又因为每个节点最多删一次，且度数之和为 $2n-2$，所以算法复杂度 $\Theta(n)$。

然后就做完了。

## Code

正解：<https://atcoder.jp/contests/arc156/submissions/39088712>。