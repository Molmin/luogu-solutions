这是一道多么好的~~暴力~~树状数组题目啊。

首先考虑这样一个结论：

对于若干个右端点相同的询问，区间里出现的相同数字一定只需要考虑最后出现的那一次，例如：

`1   3   5   4   1`


这组数中，最左端的 $1$ 完全可以被最右端的 $1$ 代替，因为右端的 $1$ 一定会出现在查询的区间中，就算第一个 $1$ 计算过，在最后也会被重复计算，因此这个结论成立。

那么，我们可以建立一个数组 $ans$ 用于存储答案，$ans[i]$ 用于存储以 $i$ 为左端点的区间询问的答案，同时使用一个 $pre$ 数组储存当前数字上一次出现的位置 $pre[a[i]]$ 存储的是 $a[i]$ 对应的数上一次出现的位置下标。遍历数组，扫描到一个数字时，我们需要考虑这个数的贡献以及区间。

1. 如果这个数没有出现过，即 $pre[i]$ 为空，那么其影响区间为 $[1,i]$
2. 如果这个数出现过，即 $pre[i]$ 已经存储着这个数上次出现的位置，那么其影响区间为 $[pre[i]+1,i]$

相当于是每个数字只影响从当前位置到上一次出现的位置的区间，那么我们就将这个问题转化为了**区间修改**，**单点查询**的问题，但是直接暴力复杂度过高，因此可以使用数据结构进行优化，树状数组和线段树都可以实现，这里使用树状数组会更简单一些。

关于树状数组这里就不再赘述，[OI-WIKI](http://next.oi-wiki.org/ds/fenwick) 这里有详细的讲解，不会使用的可以去学习。

AC 代码如下。
```cpp
#include <bits/stdc++.h>
#define low(i) ((i) & (-(i)))
using namespace std;

int n, a[100010], b[100010];	// a 为原数组, b 为树状数组（差分）
int ans[100010];	// ans[i] 存储以 i 为左端点的区间答案
int m;
int q[100010];	// q 存储询问
int pre[100010];	// pre[a[i]] 存储 a[i] 这个数上次出现的位置

// 树状数组
void add(int p, int val){
	for(; p<=n; p+=low(p)){
		b[p] += val;
	}
}

int query(int p){
	int ans = 0;
	for(; p; p-=low(p)){
		ans += b[p];
	}
	return ans;
}

int main(){
	scanf("%d %d", &n, &m);
	for(int i=1; i<=n; i++){
		scanf("%d", &a[i]);
	}
	for(int i=1; i<=m; i++){
		scanf("%d", &q[i]);
	}
	for(int i=1; i<=n; i++){
		// 如果当前数字没有出现过
		if(!pre[a[i]]){
			pre[a[i]] = i;
			add(1, 1);
			add(i+1, -1);
		}
		// 如果当前数字出现过
		else{
			add(pre[a[i]]+1, 1);
			add(i+1, -1);
			pre[a[i]] = i;
		}
		if(i == n){
			// 遍历到右端点，准备查询答案
			for(int j=1; j<=m; j++){
				printf("%d\n", query(q[i]));
				// 查询以 q[i] 为左端点的区间答案
			}
		}
	}
	return 0;
}
```
完结撒花！

PS: [P1972 [SDOI2009]HH的项链](https://www.luogu.com.cn/problem/P1972) 思路与这一题基本相同，多了排序处理离线询问的技巧，大家可以进行练习。