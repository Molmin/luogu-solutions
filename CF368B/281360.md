## 直接摆思路：

$~~~~~~~~~$ 我们看到 $n$ 的范围到了 $10^5$ 级别，很明显，最暴力的方法明显是过不了的，这里给大家介绍一种最简单的DP思想:

$~~~~~~~~~$ 我们从后往前枚举，如果我们当前枚举到的数是第 $i$，即 $a[i]$ 个，就是说：如果 $a[i+1] 到  a[n]$中间出现过与 $a[i]$ 相等的数，那么我们就不用加一，直接枚举下一个数 $a[i-1]$ .

$~~~~~~~~~~$ 如果我们枚举到 $a[i]$ 并且之前没有出现过与 $a[i]$ 相同的数，就标记 $a[i]$ 已经出现过了．

```cpp
#include<bits/stdc++.h>
using namespace std;
const int M=1e5+5;
int n,m,s[M],v[M],a[M],k[M];
// s[i] 记录的就是 i~n 之间有多少不同的数
// v[i] 记录的就是 i 这个数有没有出现，v[i]=1 就是出现了　，v[i]=0 就是没出现．
// a[i] 就是题目里的 a[i].
// k[i] 就是题目里的 l[i].
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++) scanf("%d",&a[i]);
	for(int i=1;i<=m;i++) scanf("%d",&k[i]);
	for(int i=n;i>=1;i--)
	{
		if(!v[a[i]]) {s[i]=s[i+1]+1;v[a[i]]=1;}
        //如果 a[i] 这个数没有出现过,那么就是我们又找到了一个新的没有出现过的数．标记为出现过，更新答案．
		else s[i]=s[i+1];//否则，答案等于 i+1 项
	}
	for(int i=1;i<=m;i++) printf("%d\n",s[k[i]]);//注意输出的不是s[i]，是s[k[i]];
	return 0;
}
```
## 完结
