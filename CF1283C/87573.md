题目可以想象在一张图上，把每个同学看成点，送礼关系看成边。

我们只关注每个点的入度与出度，因为它可以表示同学送礼与收礼情况。

对于 $f_i=j\;(1 \le i,j \le n,\;i≠j)$ 的情况，将第 $i$ 个点出度加 $1$，第 $j$ 个点入度加 $1$（可以看成从 $i$ 到 $j$ 连一条单向边）。

那么就会出现一些特征不同的节点，分成四类：

1. 入度出度均为 $1$；
2. 入度出度均为 $0$；
3. 入度为 $1$，出度为 $0$；
4. 入度为 $0$，出度为 $1$。

其中，第 $1$ 类点不需要处理，而且第 $3$ 和第 $4$ 类点可以进行匹配。

那问题就转化成如何处理第 $2$ 类点。

讨论两种情况：

- 第 $2$ 类点个数只有 $1$ 个，那么它可以让一个第 $3$ 类点连向它，让第 $3$ 类点变成第 $1$ 类，自己变成第 $3$ 类点，之后再让第 $3$、$4$ 类点匹配；

- 第 $2$ 类点不止 $1$ 个时，我们可以让所有第 $2$ 类点组成封闭的环，使其全部变成第 $1$ 类点，再让第 $3$、$4$ 类点匹配。

**注意到，一张有向图的节点入度和等于出度和，而第 $1$、$2$ 类点入出度均相等，所以第 $3$ 类点一定可以和第 $4$ 类点两两匹配。**

当所有点变成第 $1$ 类点时，匹配即完成。

**参考代码：**

```cpp
#include <cstdio>

int n, a, in[200010], out[200010], ans[200010];
int aa[200010], bb[200010], cc[200010], cnt, k, s1, s2, s3;

int main(){

	scanf("%d", &n);
	for(int i = 1; i <= n; i++)
		scanf("%d", &a), a > 0 ? out[i]++, in[a]++, ans[i] = a : 0;
	
	for(int i = 1; i <= n; i++)
		if(!in[i] && !out[i])
			k = i, cnt++;

	// 处理第 2 类点只有 1 个的情况
	if(cnt == 1){
		for(int i = 1; i <= n; i++)
			if(in[i] && !out[i]){
				out[i] = 1, ans[i] = k, in[k] = 1;
				break;
			}
	}
   
	// 将第 3 类点与第 4 类点进行匹配
	for(int i = 1; i <= n; i++){
		if(in[i] && !out[i])
			aa[++s1] = i;
		if(!in[i] && out[i])
			bb[++s2] = i;
	}
	for(int i = 1; i <= s1; i++)
		out[aa[i]] = 1, in[bb[i]] = 1, ans[aa[i]] = bb[i];
	
	// 处理第二类点至少有 2 个的情况
	for(int i = 1; i <= n; i++)
		if(!in[i] && !out[i])
			cc[++s3] = i;
	
	for(int i = 1; i < s3; i++)
		out[cc[i]] = 1, ans[cc[i]] = cc[i + 1], in[cc[i + 1]] = 1;
	ans[cc[s3]] = cc[1];		// 首尾相接形成环
	
	for(int i = 1; i <= n; i++)
		printf("%d ", ans[i]);
	puts("");

	return 0;
}
```