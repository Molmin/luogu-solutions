### Description:
此题中，我们要让每个人都能送出礼物并收到礼物，也就是要排除自己送自己的情况。
### Solution:
首先，在 $A$ 中存所有没有送礼物的人， $B$ 中存储所有没有收到礼物的人。

例如
```
5
5 0 0 2 4
```
中
```
A = {2,3}
B = {2,3}
```
此时让每一个 $A[i]$ 和 $B[i]$ 进行配对，但是不能送给自己，所以当$A[i]$ = $B[i]$ 的时候，先把$b[i]$ 和 $B[i+1]$ 互换，再进行配对。

例如，当`A = {2,3},B = {2,3}`时$A[1]$ = $B[1]$ ，所以 $B$ 变为`B = {3,2}`后再进行配对。

当$A$的最后一个数=$B$的最后一个数时，把$B[i]$ 和 $B[1]$ 互换，再重新对 $A[1]$ 进行配对，并对$A[i]$ 和 $B[i]$ 进行配对。

### Code:
```cpp
#include <bit/stdc++.h>
using namespace std;
int n;
int a[200001];//a[i] = j 表示第i个人的礼物送给了第j个人
int A[200001];
bool b[200001];
int B[200001];
int main()
{
	cin >> n;
	for(int i = 1；i <= n；i++)
	{
		scanf("%d",&a[i]);
		b[a[i]] = true;//记录第a[i]个人被送过礼物
		if(a[i] == 0) A[++A[0]] = i;//记录还未送出礼物的人
	}
	for(int i = 1；i <= n；i++) if(b[i] == 0) B[++B[0]] = i;//记录 还未收到礼物的人
	for(int i = 1；i <= A[0]；i++)//对每一个没送出礼物的人进行配对
	{
		if(A[i] == B[i])//如果此时是自己送给自己，前文有讲
		{
			if(i != A[0])//此时不是最后一个的时候，交换i和i+1
			{
				swap(B[i],B[i+1]);
			}
			else//此时是最后一个，那就与第一个交换
			{
				swap(B[1],B[i]);
				a[A[1]] = B[1];
			}
		}
		a[A[i]] = B[i];
	}
	for(int i = 1;i <= n;i++) printf("%d ",a[i]);//输出每个人的送礼对象
		return 0;
}
```
不要复制代码哦！