这道算法题可以用环图做！

通过读题我们发现，每个人都应当送出一份礼物，也会收到礼物，但不能自己给自己一份礼物。

从而可将此题转化为一个序列，不能自己给自己礼物就等价于序列中元素的值不能与它的位置相等。

即

$$i \neq v[i]$$

因为位置与数值是一一对应的，所以我们可以从位置向数值连一条有向边，构成环。

构建完图之后，由于有空缺的数据，所以这个环是不完整的。

要构成一一对应的关系，就转换成了要将这个环补全。

由于 $i \neq v[i]$ ，即 $i$ 不能向 $v[i]$ 连一条边，所以也就不能出现负环。

因此我们可以总结成三种情况：

$1$ 有多个环，且有缺口。

$2$ 环中缺口可插入需要补全的元素。

$3$ 环无缺口。

对于以上三种情况，我们可以分类讨论出解决方法：

$Key1$ 将有缺口的环首尾相连。

$Key2$ 将需要补全的元素按照补全的原则补到缺口中。

$Key3$ 将剩下的元素互相相连，即“抱团取暖”。

因此，我们将问题转化成了用所有的元素构建一个（或多个）完整的环图，使得满足没有负环。

看到这里的同学，可以自己试着去写写代码了（~~tf口吻~~）

```
#include<iostream>
#include<cstring>
#include<algorithm>
using namespace std;
const int N=200005;
int p[N],q[N],st[N];//p为正向边，q为反向边，st为标记数组
int n;
int main()
{
    cin>>n;
    for(int i=1;i<=n;i++)
    {
        scanf("%d",&p[i]);//添加正向边
        q[p[i]]=i;//添加反向边
    }
    bool flag=false;//判断是否填补所有的空缺元素
    for(int i=1;i<=n;i++)
    {
        if(st[i] || !q[i]) continue;//打过标记或没有下一个点的点跳过
        st[i]=true;//打上标记
        int x=i,y=i;//x和y分别表示环的尾和头
        while(p[x] && !st[p[x]])//当x有下一个点并且没有走过时
        {
            x=p[x];//更新环的尾
            st[x]=true;//打标记
        }
        while(q[y] && !st[q[y]])//同理通过反向边向前走
        {
            y=q[y];
            st[y]=true;
        }
        if(p[x]==y) continue;//如果连通，则跳过
        if(!flag)//判断是否处理过没有出现的点
        {
            flag=true;//打标记，表示处理过了
            for(int j=1;j<=n;j++)
            {
                if(!q[j] && !p[j])//如果这个点是孤立的 即key2操作
                {
                    st[j]=true;//打标记
                    p[x]=j;//把这个点放到环的尾部
                    x=j;//更新环的尾
                }
            }
        }
        p[x]=y;//把环连起来 即key1操作
    }
    if(!flag)//如果还有没处理完的点就抱团取暖 即key3操作
    {
        int x=0,y=0;
        for(int i=1;i<=n;i++)
        {
            if(!p[i])//如果没有连通的点，即没有处理过
            {
                if(!x && !y) x=y=i;//如果是这个抱团取暖环的第一个元素，那么他的首尾都附上它本身
                else
                {
                    p[x]=i;//把这个点放到环的尾部
                    x=i;//更新环的尾
                }
            }
        }
        p[x]=y;//把抱团取暖环连起来
    }
    for(int i=1;i<=n;i++)
    {
        printf("%d ",p[i]);//输出每个位置所连得下一个点即为答案
    }
    return 0;
}            
```

谢谢各位巨佬们的阅读，可以给一个小小的赞嘛，Thanks♪(･ω･)ﾉ