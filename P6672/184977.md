题意转化：给定 $m$ 个数 $a_1,a_2,\dots,a_m$，求有多少种排列，使得 $\forall i,\sum_{j=1}^i a_j\geq 0$。其中 $\sum_{j=1}^m a_j=0$。

对于这道题来说，我们将其转化为新题意，只需要将每一个 $w_i$ 减去 $1$ 即可。

考虑套路，我们将序列循环位移，得到的新方案就是这个新环的贡献。但是环有可能会贡献多个值导致重复，所以我们应该想办法让每个环的贡献变成 $1$。

于是我们在最后面再添加一个 $-1$。问题就又变成了前 $m$ 个前缀和大于等 $0$ 的排列数。

这里有个结论：在所有循环同构的排列中，有且仅有一个合法。

回望我们加上的 $-1$，显然除了最后一个数的前缀和是 $-1$，其它的全部为 $0$。这同时意味着所有后缀和都不大于 $-1$。若我们将其位移若干位，某一后缀就变为了当前的前缀，即某个前缀必定小于 $0$，显然不合法。

现在我们每个环的贡献只有 $1$ 了。我们一共有 $m+1$ 个数，圆排列的方案 $m!$。又因为最后一个 $-1$ 可能有 $m-n+1$ 个标号，但是我们只能钦定一个 $-1$ 为提供贡献的 $-1^*$，所以答案还要除去 $m-n+1$。

答案为 $\dfrac{m!}{m-n+1}$。

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	int n,m=0;
	scanf("%d",&n);
	for(int i=1;i<=n;++i)
	{
		int a;
		scanf("%d",&a);
		m+=a;
	}
	long long ans=1;
	for(long long i=1;i<=m;++i)
	{
		if(m-n+1==i)	continue;
		ans*=i;
		ans%=998244353;
	}
	printf("%lld",ans);
	return 0;
}
```