这是一道十分经典的深搜问题

由题意可知，被‘*’包围的0有几个，就是我们所需要的答案

那什么样的0才算被包围呢，也就是说，这个0无论上下左右这么搜索，遇到的都是‘*’，不会碰到边界

那反过来想，我们只要从边界出发，把所有可以到达边界的0全部用1或非0的其他任何字符代替，最后统计剩下几个0，就是我们需要的答案

-------------------------------
附AC代码
```
#include<iostream>
#include<bits/stdc++.h>
using namespace std;
int qp[505][505] = { 0 };
int tx[5] = { 0,1,-1,0,0 };
int ty[5] = { 0,0,0,1,-1 };
int n, m;
int dfs(int x,int y)
{
	int i;
		for(i=1;i<=4;i++)//上下左右共搜索四次
		if (qp[x + tx[i]][y + ty[i]]==0&&qp[x + tx[i]][y + ty[i]]!=1&& x + tx[i] >= 0 && x + tx[i] <= n + 1 && y + ty[i] >= 0 && y + ty[i] <= m + 1)//判断下一步不越界且值为0
		{
			qp[x+tx[i]][y+ty[i]]=2;//把下一步值为2
			dfs(x + tx[i], y + ty[i]);//走出下一步
		}
}
int main()
{
	char a[505][505];
	int i, j, cn=0;
	cin >> n >> m;//输入行数和列数
	for (i = 1; i <= n; i++)
		for (j = 1; j <= m; j++)
		{
			cin >> a[i][j];//输入字符
			if (a[i][j] == '0')
				qp[i][j] = 0;
			if (a[i][j] == '*')
				qp[i][j] = 1;//为了方便处理，把字符转化成数字（不做也可以）
		}
	qp[0][0] = 2;
	dfs(0, 0);//从坐标0，0开始搜索，搜索到n+1,m+1;把边界都搜索到
	for (i = 1; i <= n; i++)
		for (j = 1; j <= m; j++)
				if (qp[i][j] == 0)
				cn++;//统计剩下的0
	cout << cn;//输出
}
```
