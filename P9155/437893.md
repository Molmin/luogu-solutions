## 解法分析
这一题乍一看很简单，但是瞅一眼数据范围就知道作为 2B 还是不可能太水的，极限情况下数据达 $2^{10^5}$，很明显不是普通类型的变量能胜任的了。看到大范围很自然地会想到高精度，但是再一想会发现直接无脑高精加高精乘还要转进制，显然复杂度过大了。怎么办呢？我们来分别从这三个方面入手进行优化：
1. 先看进制转换，显然十进制转二进制需要高精除，很麻烦。于是可以直接使用二进制高精度解决这个问题。进位时与十进制思路是一样的，只是把模十除以十换成了模二除以二。
1. 再看操作一：移位。常规方式移位的话需要操作整个已用的数组，显然大动干戈了。于是可以采用偏移数组的方法达到类似双端队列的效果。即定义一个指针指向当前的最低位的上一个位置~~（之所以上一个只是图方便）~~，初始状态下指针指向数组中央，每左移一位指针自减即可。
1. 最后看操作二：加法。常规的高精加每加一次都要处理进位，很浪费时间。于是我们把所有加上去的数直接放在最低位别管，所有操作完成了再一次性进位。这样子极端情况下一位存储的数据达 $2^{16} \times 10^5$，需要使用 `long long`。

于是，如果定义最终结果的长度为 $l$，那么操作一和操作二都是 $O(1)$ 的，进位是 $O(l)$ 的，总复杂度为 $O(T(n+l))$，完美解决此题。
## 代码
此代码为赛时最优解：![](https://cdn.luogu.com.cn/upload/image_hosting/5d3yy5h7.png)  
快读快写函数已省略。
```cpp
#include <bits/stdc++.h>

using namespace std;

#define ll long long

ll sf[100010], p;
void init() { p = 50005, sf[0] = 1, sf[p + 1] = 0; }
void add(ll b) { sf[p + 1] += b; }
void ls() {
  if (sf[p + sf[0]]) ++sf[0], --p, sf[p + 1] = 0;
}

int main() {
  ll t = read(), n, x;
  while (t--) {
    n = read(), init();
    while (n--) {
      x = read();
      if (x & 1)
        ls();
      else
        add(read());
    }
    for (ll i = p + 1, tmp1, tmp2; i <= p + sf[0]; ++i) {
      tmp1 = sf[i] & 1, tmp2 = sf[i] >> 1;
      if (tmp2) {
        sf[i] = tmp1;
        if (i == p + sf[0])
          ++sf[0], sf[i + 1] = tmp2;
        else
          sf[i + 1] += tmp2;
      }
    }
    for (int i = p + sf[0]; i > p; --i) pc(sf[i] ? '1' : '0');
    pc('\n');
  }
  fls();
  return 0;
}
```