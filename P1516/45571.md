## 从零开始理解一次不定方程

之前的题解虽然已经很详细了，但是总感觉不是对新人（比如我）不是很友好。所以这里再讲一遍，争取逻辑顺畅。

P1516，青蛙的约会，本质就是求解**一次不定方程**。 何谓一次不定方程，通俗的来说，就是一个存在两个未知数的方程，所以这种方程的答案是以解集的形式呈现的。

那么如何求解一次不定方程呢？需要提前了解两个数学定理——****扩展欧几里得算法和裴蜀定理**

------------

------------


### 扩展欧几里得算法（exgcd）

扩展欧几里得算法即为求解形如 ax + by = gcd(a, b) （并且有a,b∈N*, x,y∈Z）的方程的解集，gcd()即为求解最大公因数。

是不是有人要问了，我TM为什么要求长得这么丑，看起来毫无意义的方程 ? 只能说，先不要急，后面要用。

关于exgcd求法的推导，其实本质上是一个**迭代递推**的过程，即利用gcd(a, b) = gcd(b, a % b)，从而缩小a, b的数值，最终达到终末状态——再回溯求得原方程的解。这里简单推导一下

**设** x, y, 有方程 ax + by = gcd(a, b)

**再设** x', y', 有方程 bx' + (a%b)y' = gcd(b, a%b)

**因为** gcd(a, b) == gcd(b, a%b)

**所以** 联立得 ax + by = bx' + (a%b)y'
（接下来，需要我们推导x与x', y和y'的关系，原因见上文）

**因为** a%b = a - (a / b) * b 
[ 注：这里除号为下取整 ]

 _（关于为什么可以这么表示，具体可以自己在数轴上划一划，就可以明白了）_ 

**所以** 有 ax + by = bx' + (a - a/b * b) y'

**合并同类项** 得 ax + by = ay' + b * (x' - a/b * y')

**所以** 观察等式两边，得:

 _1_ . x = y'

 _2_ . y = x' - (a/b) * y'
 
 _(那么是不是只要知道x'与y'，就可以得出x,y的值了？)
(那么x’，y’怎么求？只需要把x',y'看做是要求解的x，y，再进一步迭代即可。)_ 

**观察** 在a,b逐渐减小时有:

**当b=0时**， a * 1 + b * 0 = gcd(a, b)

**即得** 边界条件x0 = 1, y0 = 0;
(关于b是如何变为0的，请代上数值详细模拟一边gcd的算法)

**至此，推导完毕.**

总结以上推导，我们便拥有了求解ax + by = gcd(a, b)的工具。


------------

### 裴蜀（贝祖）定理

具体证明比较复杂，此处略（自行百度即可）

**定理**->  方程 ax+by=c （a,b,c∈N*）有解的充要条件是 gcd(a, b) | c

 _( gcd(a, b) | c的意思是，gcd(a, b)是c的一个因数，或者说， c % gcd(a, b) == 0。充要条件的定义请左转见数学必修2)_ 

通过这个定理，我们不仅能够判断方程的**可解性**，还可以得出方程的解集，推导见下：

设 a·x0 + b·y0 = gcd(a, b)

则令 k = c ÷ gcd(a, b)

得 a·x0·k + b·y0·k = c

设变量t，则
又变形得

a·(x0·k + b / gcd(a, b) * t) + b·(y0·k - a / gcd(a, b) * t) = c

所以 ax + by = c  的解集就是

{(x, y)|x = x0·k + b / gcd(a, b) * t, 

y = y0·k - a / gcd(a, b) * t, 且t∈Z}

所以，我们就解完了一元不定方程？是不是非常简单2333




------------


------------

------------

## 那么这个题？

关键词：**「转化能力」**

根据题目所述，我们有x, y, m, n, L, 那么根据题目条件便有(设t是经过的时间，L*k即为两个青蛙（？）的距离)：

(方便起见，不妨设n > m)

**由** x + mt - (y + nt) = L * k,  k∈Z

**得**  (x - y) - (n - m)t = L * k

**移项得** Lk + (n - m) * t = (x - y)

未知数只有k和t了，那么这个方程是不是感觉在哪里见过啊？？

那么是不是可以很愉快地解方程啦？

最后我们得到了关于t、k的解集。

**因为** t>=0恒成立（为什么?你见过时间倒流吗=.=）

**所以** 只取t的最小正整数即可。
这里稍微说明一个小技巧——
如果有y = x + a*t， 那么y的最小正整数y'可以这么求：
（这里的字母是瞎编的，不是原题。）

y' = (x % t + t) % t; 

最后就做完了。代码奉上



```
.....
#include <bits/stdc++.h>
using namespace std;

typedef long long ll;

void exgcd(ll a, ll b, ll &x, ll &y)
{
	if(!b){x = 1; y = 0; return;}
	exgcd(b, a % b, y, x);
	y -= a / b * x;
}

ll gcd(ll a, ll b){
	return (b == 0) ? a : gcd(b, a % b);
}

ll X, Y, M, N, L, g, x, y;

int main()
{
	ios::sync_with_stdio(0);
	cin >> X >> Y >> M >> N >> L;
	if(N < M) swap(X, Y), swap(M, N);
	g = gcd(L, N - M);
	exgcd(L, N - M, x, y);
	if((X - Y) % g != 0) cout << "Impossible" << endl;
	else {
		cout << (y * ((X - Y) / g) % (L / g) + (L / g)) % (L / g) << endl;
	}
	return 0;
}
```
