### 一、算法

$n,m\leq5000$，暗示着要用 dp，贪心只能过样例，好吧其实连样例都过不去。

### 二、状态定义

定义 $dp[i][j][0/1]$ 表示 $a$ 数组替换前 $i$ 个，$b$ 数组替换前 $j$ 个，最后替换的是 $a$ 或 $b$ 数组的元素，最大数字的最小值。

### 三、状态转移方程

首先想 $dp[i][j][0]$，也就是从 $dp[i-1][j][0/1]$ 转移过来的。

- 如果从 $dp[i-1][j][0]$ 转移过来，就要看 $a[i-1]$ 和 $a[i]$ 一不一样，如果一样加 $2$，不一样加 $1$。

- 如果从 $dp[i-1][j][1]$ 转移过来，就要看 $a[i]$ 和 $b[j]$ 一不一样，一样加 $2$，不一样加 $1$。

同理，$dp[i][j][1]$ 的状态转移方程也很好想了，也是类似的，但是由 $dp[i][j-1][0]$ 转移过来的是看 $b[i-1]$ 和 $b[i]$ 一不一样而不是 $a[i-1]$ 和 $a[i]$。

### 四、答案

求全部替换最大数字的最小值，即 $dp[n][m][0]$ 和 $dp[n][m][1]$ 的最小值。

### 五、边界

边界就是 $dp[i][0][0]$ 和 $dp[0][j][0]$，即只替换一个数组，可以贪心。注意要求最小值，所以初值要赋无穷大，但 $dp[0][0][0]$ 和 $dp[0][0][1]$ 要设为 $0$。