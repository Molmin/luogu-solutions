## 1. 编程思路。

本题要求将有 $n$ 个元素的数组 $A$ 和有 $m$ 个元素的数组 $B$ 中的 $0$ 用偶数替换，$1$ 用奇数替换。参与替换的数每个只用 $1$ 次，要求参与替换的数的最大数尽可能小，问这个最大数字是多少？

采用动态规划来完成。

设 $dp_{0,i,j}$ 表示数组 $A$ 中已替换了 $i-1$ 个数，数组 $B$ 中已经替换了 $j$ 个数，现在替换数组 $A$ 的第   $i$ 个数用到的尽可能小的最大数字；$dp_{1,i,j}$ 表示数组 $A$ 中已替换了 $i$ 个数，数组 $B$ 中已经替换了 $j-1$ 个数，现在替换数组 $B$ 的第 $j$ 个数用到的尽可能小的最大数字。

显然有 $dp_{0,0,j}=\infty (1\le j \le m)$，替换 $A$ 数组的第 $0$ 个不存在的数无意义。  $dp_{1,i,0}=\infty(1\le i \le n)$，替换 $B$ 数组的第 $0$ 个不存在的数也无意义。

下面推导状态转移方程。

设变量 $add$ 表示在状态转移时，需要在前一个数的基础上加上的数值。

$dp_{0,i,j}$ 表示要替换数组 $A$ 的第 $i$ 个数，可以将数组 $A$ 中的第 $i-1$ 个替换的数作为它的前一个数，若 $A_{i-1}\ne A_i$，则前后两个数奇偶性不同，只需在前一个数的基础上加 $1$，置 $add=1$；若 $A_{i-1}= A_i$，则前后两个数奇偶性相同，必须在前一个数的基础上加 $2$，置 $add=2$；即 $dp_{0,i-1,j}+add$。

也可以将数组 $B$ 中的第 $j$ 个替换的数作为它的前一个数，若 $B_j\ne A_i$，则前后两个数奇偶性不同，只需在前一个数的基础上加 $1$，置 $add=1$；若 $B_j= A_i$，则前后两个数奇偶性相同，必须在前一个数的基础上加 $2$，置 $add=2$；即 $dp_{1,i-1,j}+add$。

$dp_{0,i,j}$ 取 $dp_{0,i-1,j}+add$ 和  $dp_{1,i-1,j}+add$ 的最小值。

同理，$dp_{1,i,j}$ 取 $dp_{1,i,j-1}+add$ 和  $dp_{0,i,j-1}+add$ 的最小值。$add$ 的赋值方式与上面类同。

最后的答案取 $dp_{0,n,m}$ 和  $dp_{1,n,m}$ 的最小值。 

## 2. 源程序。

```c
#include <stdio.h>
#include <string.h>
int dp[2][5005][5005];
int min(int a,int b)
{
    return a<b?a:b;
}
int main()
{
    int n,m;
    scanf("%d",&n);
    int a[5005]={0},b[5005]={0};
    int i,j;
    for (i=1;i<=n;i++)
        scanf("%d",&a[i]);
    scanf("%d",&m);
    for (i=1;i<=m;i++)
        scanf("%d",&b[i]);
    int inf = (n + m) * 5000;
    int add;
    for (i = 0; i <= n; i++)
    {
        for (j = 0; j <= m; j++)
        {
            if (i==0 && j==0) continue;
            dp[0][i][j]=inf;
            if (i!=0)
            {
                add=1;
                if (a[i]==a[i-1]) add++;
                dp[0][i][j]=min(dp[0][i][j],dp[0][i-1][j]+add);
                add=1;
                if (a[i]==b[j]) add++;
                dp[0][i][j]=min(dp[0][i][j],dp[1][i-1][j]+add);
            }
            dp[1][i][j]=inf;
            if (j!=0)
            {
                add=1;
                if (b[j]==b[j-1]) add++;
                dp[1][i][j]=min(dp[1][i][j],dp[1][i][j-1]+add);
                add=1;
                if (b[j]==a[i]) add++;
                dp[1][i][j]=min(dp[1][i][j],dp[0][i][j-1]+add);
            }
        }
    }
    printf("%d\n",min(dp[0][n][m], dp[1][n][m]));
}
```

