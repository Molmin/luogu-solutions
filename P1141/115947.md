非STL党福利
这是我写的第二篇题解
典型的BFS

不多说，上代码，代码中有详细解释
```cpp
#include <bits/stdc++.h> 
using namespace std;
int dx[4]={0,0,-1,1};
int dy[4]={1,-1,0,0}; //4个方向 
int n,m,q[935000][2];//n和m，队列q，其中第二维0代表横坐标，1代表纵坐标 
int h[900000];//记录连通图,(并查集,h[1]表示第一个集合(也就是连通图)中的点数) 
char g[1035][1035];//输入0,1,由于中间没有空格,就用char了 
int v[1035][1035];//记录这个点是否被访问过,.v[a][b]的值就是ab这个点在第v[a][b]个图中,属于第v[a][b]个集合 
int T=0;	//现在正在处理第T个集合(连通图) 
int main()
{
	int i,j,k;
	scanf("%d%d",&n,&m);//输入 不多说 
	for(i=1;i<=n;i++)
		for(j=1;j<=n;j++) cin>>g[i][j];
	for(i=1;i<=n;i++)
		for(j=1;j<=n;j++)
		{
			if(!v[i][j])//如果i.j这个点还没有被访问过 ,那我们就开始吧! 
			{
				++T;//存入新的集合 
				int f=1,r=1;//队头和队尾 
				q[1][0]=i,q[1][1]=j;//初始点入队 
				v[i][j]=T;//标记这个点在第T个集合中 
				while(f<=r) 
				{
					int X=q[f][0],Y=q[f][1];//先存入这个点的坐标 
					for(k=0;k<4;k++)//4个方向枚举 
					{
						if(X+dx[k]<=n&&X+dx[k]>0&&Y+dy[k]<=n&&Y+dy[k]>0&&!v[X+dx[k]][Y+dy[k]]&&g[X][Y]!=g[X+dx[k]][Y+dy[k]])
						{
							//这个点没出界并且这个点还没被访问过
							//在这里注意一下,一旦访问过一个点,必定就是结果,因为这是连通图,(集合)
							//可以证明每个点只能属于一个集合
							/*
							for example:
							证明 
							假如某个点 既属于1集合，又属于 2集合
							那么1,2集合中的点可以相互到达
							1,2集合是同一个集合 
							*/ 
							q[++r][0]=X+dx[k];//这个点入队 
							q[r][1]=Y+dy[k];
							v[q[r][0]][q[r][1]]=T;//记录这个点是第T个集合 
						}
					} 
					++f;//搜索下一个,.队头+1(push我不会用,我是非STL党) 
				}
				h[T]=r;//所以综上,这个集合内有r个点!不是f!这是队列为空,我设置的f=r+1 
			}
		}
	for(i=1;i<=m;i++)
	{
		int x,y;
		scanf("%d%d",&x,&y);//分别输入xy，开始询问 
		printf("%d\n",h[v[x][y]]);//查找xy这个点属于第v[x][y]个集合，第v[x][y]个集合里有h[v[x][y]] 个点，直接输出即可 
	}
	return 0;
}

```
最后祝愿自己能在2019年AKNOIP~~(苦逼的自己是江苏高考最后一届，无法复读)~~