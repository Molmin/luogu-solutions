### UPD：

蒟蒻的第一篇题解，审了几天终于过了，感动。**题解修改后还要重审？？？**

**前置技能：并查集**

此题的思路和`P3958 奶酪`思路较为相似。

## 并查集解法
并查集求联通块。这题其实连搜索都用不上，并查集稳稳的，不会TLE了。

当时我用dfs做的这题，在TLE的问题上纠结了好几天，最后好不容易才记忆化AC了。过了一个月，我惊奇地发现，这题可以用**并查集**做！

用并查集做，更容易理解，更好写。

翻了下题解，发现题解里有一篇是一样的解法，但是几乎没有解释。这里把做法解释一下。

### 一 绕开二维并查集
我们将联通的所有块放入一个集合中。

由于二维并查集比较难写，我们可以绕开二维并查集。

首先讲一下将二维坐标转换为数字的方法。由于最大坐标是有限($x,y<n$)(当$x,y$从$0$开始)的，所以我们可以将其中一个坐标乘上$n$，再加上另一个坐标。这样，每个坐标都不会重复。在我的程序中，坐标从$0$开始。我转换的方法是：
$$a=ny+x$$
其中，$a$为得出的数字。代码实现如下：
```cpp
inline int vti(int y, int x) { return y * n + x; }
```

### 二 将联通块放于一个集合中
如何将联通块放入一个集合中？

我们可以遍历整张图。

对于每个点，当它的坐标$x>0$时，检测它和左侧的块是否联通。如果联通，则并入一个集合中。

当它的坐标$y>0$时，检测它和上方的块是否联通。如果联通，则并入一个集合中。

可以画张图模拟一下这个过程。当遍历完整张图后，所有联通块中的所有块就都在一个集合中了。

代码实现：
```cpp
for(int i = 0; i < n; i++)	//遍历y坐标
	for(int j = 0; j < n; j++)	//遍历x坐标 
	{
		if(i > 0) if(map[i][j] != map[i - 1][j]) Union(vti(i, j), vti(i - 1, j)); //如果和上面联通，合并 
		if(j > 0) if(map[i][j] != map[i][j - 1]) Union(vti(i, j), vti(i, j - 1)); //如果和左边联通，合并 
	}
```

### 三 求出每个联通块中块的个数
我们这里使用一个num数组计数。

```cpp
int num[maxn * maxn];	//根节点中储存块数 
```

遍历整张图，对于每个块，将它所在集合的代表“拥有”的块数+1。代码实现：
```cpp
for(int i = 0; i < n; i++)
	for(int j = 0; j < n; j++)
		num[Find(vti(i,j))]++;	//对于每个块，将其集合的块数量+1。
```
### 四 回答每个询问
有了前面的并查集操作，这一把就简单多了。直接输出num数组中询问坐标的**根节点**所“拥有”的块数即可。

**注意一定要查询根节点！其他的节点是没有存储块数的。**

代码实现：
```cpp
while(m--)	//神奇的方法，重复m次，可以省去i。m以后没必要用，所以可以这样做。 
{
	int x,y;
	scanf("%d %d",&y,&x);			//询问时也是先行后列，即先y后x。 
	printf("%d\n",num[Find(vti(y - 1,x - 1))]);	//O(1)获取联通块数量。由于读入时下标从0开始，所以输出的时候下标也应该从0开始。 
}
```

### 五 完整代码
辛辛苦苦写的题解，就不要抄代码了吧。~~**小心粽名**~~
```cpp
#include <cstdio>

const int maxn = 1010;

int n,m;

char map[maxn][maxn];	//地图 

int uset[maxn * maxn],	//并查集 
	num[maxn * maxn];	//根节点中储存块数 

/*并查集模板*/
int Find(int e) { return e == uset[e] ? e : uset[e] = Find(uset[e]); }
void Union(int e,int f) { uset[Find(f)] = Find(e); }
 
/*用一些神奇的方法将坐标转换为int*/
inline int vti(int y, int x) { return y * n + x; }

int main()
{
    scanf("%d %d",&n,&m);		//读入n和m 
    for(int i = 0; i < n; i++)	//遍历y坐标
    {
    	scanf("%s",map[i]);			//顺便读入地图。个人不是很喜欢用getchar。 
		for(int j = 0; j < n; j++)	//遍历x坐标 
		{
			num[vti(i,j)] = 0;			//顺便初始化
			uset[vti(i,j)] = vti(i,j);	//初始化并查集。自行思考为什么可以在这里初始化。 
			if(i > 0) if(map[i][j] != map[i - 1][j]) Union(vti(i, j), vti(i - 1, j)); //如果和上面联通，合并 
			if(j > 0) if(map[i][j] != map[i][j - 1]) Union(vti(i, j), vti(i, j - 1)); //如果和左边联通，合并 
		}
	}
	for(int i = 0; i < n; i++)		//遍历y坐标
		for(int j = 0; j < n; j++)	//遍历x坐标
			num[Find(vti(i,j))]++;	//对于每个块，将其集合的块数量+1。 
	while(m--)	//神奇的方法，重复m次，可以省去i。m以后没必要用，所以可以这样做。 
	{
		int x,y;
		scanf("%d %d",&y,&x);			//询问时也是先行后列，即先y后x。 
		printf("%d\n",num[Find(vti(y - 1,x - 1))]);	//O(1)获取联通块数量。由于读入时下标从0开始，所以输出的时候下标也应该从0开始。 
	}
    return 0;
}
```