> 这是一篇发布于2017.11.19的早期题解，已经修改

楼下都说这题是什么并查集什么的，其实DFS联通块就可以了，没有那么复杂，速度也快。

[使用Markdown链接获取更好的阅读效果](https://www.zybuluo.com/RiverHamster/note/956433) **完整代码见链接中**

`时间：216ms` `单个点时间：68ms` `空间：36MB`

`时间复杂度` $O(n^2+m)$

## 主要思路

很容易就可以发现，所有**连接在一起的格子的答案是一样的**。

所以，只需要用DFS找到所有的联通块，联通块内所有的格子的答案都是这个联通块的格子数目。

## 程序实现

记录每个格子是否被搜过（在某个连通块中）。

两重循环，如果这格没搜过就从这个格子开始搜。

每搜到一个格子当前答案加1，**数组记录当前格子位置**，每次都向4个方向的满足条件的格子扩展。

搜完一块后把数组记录的格子的答案赋成连通块总的格子数。

读入时有个小技巧，对于二维字符数组a，`scanf("%s",a[i]+1)`可以以1下标读入一行。

(gets,strlen等同理，如`strlen(s+1)`1下标字符串长度）

## Code

```cpp
for(int i=1;i<=n;i++)
    for(int j=1;j<=n;j++) if(!v[i][j]){ //枚举格子，没有访问过就DFS
        v[i][j]=true;                   //这格被访问
        now=0;                          //总数记为0
        dfs(i,j);                       //从这格开始搜索
        for(int i=1;i<=now;i++) f[ans[i][0]][ans[i][1]]=now; //依次赋值，重复使用并没有问题
    }
```
```cpp
#define nx x+dx[i] //增量数组表示下一个的x
#define ny y+dy[i] //增量数组表示下一个的y
#define check(x,y) (x>0&&x<=n&&y>0&&y<=n) //越界检查

void dfs(int x,int y){
    now++; //记录答案
    ans[now][0]=x,ans[now][1]=y; //记录连通块的格子
    for(int i=0;i<4;i++){ //搜索下一格
        if(check(nx,ny)&&!v[nx][ny]&&a[x][y]!=a[nx][ny]){
            //越界、访问、颜色判断
            v[nx][ny]=true; //记录访问状态
            dfs(nx,ny);     //下一格
        }
    }
}
```

## 一些问题（修改部分）
- 为什么复杂度是对的

每个格子都只被搜过一次，复杂度当然是对的，你TLE可能是你的复杂度问题。

- 为什么不会爆栈

OJ上栈空间和内存相等。本机评测可以在 Windows 上使用
`g++ a.cpp -o a -Wl,stack=268435456`编译成$256$MiB栈空间调试，自行网上搜索“g++ Windows 扩栈”。