## 前言
作为一个小蒟蒻，这道01迷宫真的是打得我快死。不过总算是做出来了，于是我决定发题解纪念一下（撒花~）
## 思路
这道题实际上思路并不会很难，但是代码实现起来极其麻烦（至少对于我这种蒟蒻来说）。
我一开始直接针对每一次查询进行一次广搜，毫无意外，直接崩掉QAQ，于是我就稍微想了一下，发现对于任意一个格子s1，如果从s1出发，能够到达另外一个格子s2，那么从s2出发，也一定能到达s1，同理可得，从s1出发能够到达的所有点，从s2也能够到达。

于是这道题的思路就非常清晰了。

定义查询quiry:=dfs(x, y)，dfs(x, y)用于查询从坐标为(x, y)的格子出发，能到达多少个格子。

首先，我们创建一个队列q用于存放所有的查询，然后在每次从队列中取出一个查询(x0, y0)，判断该查询是否已经有答案，如果没有，就进行一次广搜，广搜过程中如果到达一个同样在查询队列中的格子，那么将其存入一个临时数组。广搜完毕后，将临时数组中的所有查询的答案都设置为dfs(x0, y0)，并把这些查询全部做一次标记，表明它们已经有了答案。

## 一点小小的优化
一开始我虽然有了思路，但是还是不知道代码应该怎么写（毕竟是个蒟蒻QAQ），想了很久才想出来。为了各位不要掉坑里，于是我把几个可以优化的点也说出来吧

1、每次广搜完之后，不需要复原地图，因为下一次广搜一定不会到达这次广搜能搜到的格子。

2、把答案存在地图上（相信我，这会省掉你一大堆时间）

## 代码
```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
using namespace std;

int q[100001][2], map[1001][1001][3], qi[1000001][2];
int qr=1, n, m, temp1 = 1, value1;
int jg[100001][2];
char temp[1001];

int gs(int i, int j){
    int front = 1, rear = 2, k[2], value;
    qi[1][0] = i;
    qi[1][1] = j;
    jg[temp1][0] = i;
    jg[temp1++][1] = j;
    
    while(front < rear){
        k[0] = qi[front][0];
        k[1] = qi[front++][1];
        map[k[0]][k[1]][1] = 2; 
        value = map[k[0]][k[1]][0];
        if(map[k[0]][k[1]+1][0] != value && map[k[0]][k[1]+1][1] != 2 && k[1]+1 <= n && k[1]+1 > 0){
            qi[rear][0] = k[0];
            qi[rear++][1] = k[1]+1;
            if(map[k[0]][k[1]+1][1] == 1){
                jg[temp1][0] = k[0];
                jg[temp1++][1] = k[1]+1;
            }
            map[k[0]][k[1]+1][1] = 2;
        }
        if(map[k[0]][k[1]-1][0] != value && map[k[0]][k[1]-1][1] != 2 && k[1]-1 <= n && k[1]-1 > 0){
            qi[rear][0] = k[0];
            qi[rear++][1] = k[1]-1;
            if(map[k[0]][k[1]-1][1] == 1){
                jg[temp1][0] = k[0];
                jg[temp1++][1] = k[1]-1;
            }
            map[k[0]][k[1]-1][1] = 2;
        }
        if(map[k[0]-1][k[1]][0] != value && map[k[0]-1][k[1]][1] != 2 && k[0]-1 <= n && k[0]-1 > 0){
            qi[rear][0] = k[0]-1;
            qi[rear++][1] = k[1];
            if(map[k[0]-1][k[1]][1] == 1){
                jg[temp1][0] = k[0]-1;
                jg[temp1++][1] = k[1];
            }
            map[k[0]-1][k[1]][1] = 2;
        }
        if(map[k[0]+1][k[1]][0] != value && map[k[0]+1][k[1]][1] != 2 && k[0]+1 <= n && k[0]+1 > 0){
            qi[rear][0] = k[0]+1;
            qi[rear++][1] = k[1];
            if(map[k[0]+1][k[1]][1] == 1){
                jg[temp1][0] = k[0]+1;
                jg[temp1++][1] = k[1];
            }
            map[k[0]+1][k[1]][1] = 2;
        }
        
    }
    return front-1;
}

int main(){
    cin >> n >> m;
    for(int i = 1; i <= n; i++){
        cin >> temp;
        for(int j = 1; j <= n; j++) map[i][j][0] = (int)(temp[j-1] - '0');
        for(int j = 0; j < n; j++) temp[j] = ' ';
    }
    for(int i = 1; i <= m; i++) cin >> q[i][0] >> q[i][1];
    for(int i = 1; i <= m; i++) map[q[i][0]][q[i][1]][1] = 1;

    while(qr <= m){
        if(map[q[qr][0]][q[qr][1]][2] != 0){qr++;continue;}
        value1 = gs(q[qr][0], q[qr][1]);
        for(int i = 1; i < temp1; i++){
            map[jg[i][0]][jg[i][1]][2] = value1;
        }
        qr++;
        temp1 = 1;
    }
    for(int i = 1; i <= m; i++){
        cout << map[q[i][0]][q[i][1]][2] << endl;
    }
    return 0;
}
```
懒得写注释，将就着看一下吧QAQ