### Upd：2023.1.30 修改了代码。原代码错在忽略了说 `L` 的和说 `R` 的人可以全错。

引理 $1$：在小于等于 $x$ 的位置**包含**了在小于等于 $y(y>x)$ 的位置的情况。

引理 $2$：在大于等于 $x$ 的位置**包含**了在大于等于 $y(y<x)$ 的位置的情况。

---

利用上述两个引理，我们把所有 `L`，`G` 的坐标**分别**排序。然后两重循环枚举 `L`，`G` 对应的坐标（假设存储两者的坐标数组分别为 $l,g$，元素个数分别为 $p,q$）。假设我们枚举到了 $l_i=x,g_j=y$，其中 $x$ 表示位置需满足 $\le x$，$y$ 表示位置需满足 $\ge y$。这个范围需要是合法的，所以需满足 $y \le x$。由于 $l,g$ 都是有序的，故 $\le x$ 也就相当于要舍去**小于 $x$** 的情况，也就是 $i-1$；$\ge y$ 也就相当于要舍去**大于 $y$** 的情况，也就是 $q-j$。然后把两者加起来，就是要删去的元素个数了。取最小值即可。

举个例子理解一下：

假设 $l= \{1,4,5,7,8\},g=\{1,2,3,4,5\}$。目前枚举到 $l_3=5,g_2=2$。也就是说，位置 $p$ 需满足 $2 \le p \le 5$。根据引理，$\le 5$ 的情况包含了 $\le 7, \le 8$ 的情况，所以无需删去；但不包含 $\le 1,\le 4$ 的情况。也就是说 $\le 5$ 不一定代表 $\le 1,\le 4$，所以需要删去。大于等于也同理。

### Code：

```c++
#include <bits/stdc++.h>
using namespace std;
int n, s, t, p, q, a[1007], b[1007];
int main(){
	scanf ("%d", &n);
	for (int i=1; i<=n; i++){
		char x;
		cin >> x; scanf ("%d", &t);
		if (x == 'L') a[++p] = t;
		else b[++q] = t;
	}
	s = n - 1;
	a[++p] = 1e9+7, b[++q] = -1e9;
	sort (a+1, a+p+1);
	sort (b+1, b+q+1);
	for (int i=1; i<=p; i++){
		for (int j=1; j<=q; j++){
			if (b[j] <= a[i]) s = min(s, q - j + i - 1);
		}
	}
	printf ("%d\n", s);
	return 0;
}
```