## [Codeforces Round #675 (Div. 2) B](https://codeforces.com/contest/1422/problem/B)

有一个矩阵，每次可以让一个元素加1或减1，求最少次数使得矩阵行列回文

### Solution：

显然对每个位置，要求的回文中与它有关的只有至多4个点，所以找出这4个点，找出其平均数，将所有数都变成其平均数即可

然鹅，__这个解法是错的！__

为什么错呢？这也使考场上的我百思不得其解！不可能呀？

看这个样例：

```
1
2 2
9 6
10 9
```

它的答案是多少？

按照我们刚刚的方法算出来是把所有数都变为8（平均数下取整为8），也就是答案为6

但是，如果把所有数都变为9，答案为4！

问题出在了“我们在将平均数上下取整的时候并不精确，实际上这个应该上取整还是下取整并不只与它%4的余数有关，还与小于这个平均数的数的个数与大于这个平均数的个数有关！”

换句话说，其实应该是**中位数！**

于是，对于每一个这4个数，我们得到他们对答案的贡献：

将这四个数放入b数组从小到大排序

```cpp
ans+=abs(b[4]-b[2])+abs(b[3]-b[2])+abs(b[2]-b[2])+abs(b[1]-b[2])
```

取绝对值得：

```cpp
ans+=b[4]+b[3]-b[2]-b[1]
```

实际情况中还会有一些靠近中间的数出现“4个数有重叠”的现象，我们还像这样记录答案，最后ans/=4的时候对这些数也是适用的，读者可以自己手模验证

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int a[110][110],b[7];
signed main(){
	int t;cin>>t;
	while(t--){
		int n,m,ans=0;cin>>n>>m;
		for(int i=1;i<=n;++i)
			for(int j=1;j<=m;++j)cin>>a[i][j];
		for(int i=1;i<=n;++i)
			for(int j=1;j<=m;++j){
				b[1]=a[i][j],b[2]=a[n-i+1][j],b[3]=a[n-i+1][m-j+1],b[4]=a[i][m-j+1];
				sort(b+1,b+5);
				ans+=b[4]+b[3]-b[1]-b[2];
			}
		cout<<ans/4<<endl;
	}
	return 0;
}
```

# 记得CF的题都要#define int long long!!!