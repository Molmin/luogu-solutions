这道题我们可以用一个新的思路来解决它。
首先，读入应该没什么大不了的，我们读入一个字符串$s$。
```cpp
cin>>s;
```
接下来，我们不管那些~~乱七八糟的~~标点符号的用法，直接往上搞，当然，搞完后不打印输出，例如第二个样例我们在后台会把它弄成
```
...@..@
```
这个字符串我们把它叫做$x$。这一段你会写吗？应该很简单，我就给你看一下循环里的if语句。
```cpp
if(i+2<s.size()&&s[i]=='d'&&s[i+1]=='o'&&s[i+2]=='t'){
	x+='.';
	i+=2;
}
else if(i+1<s.size()&&s[i]=='a'&&s[i+1]=='t'){
	x+='@';
	++i;
}
else
	x+=s[i];
```
接下来，我们判断一下头和尾是否符合条件。

判断完后应该是这个样纸滴：
```
dot..@..at
```
你懂得这个意思了吗？如果两边的不符合要求，那么把它换成字母，可以存在$ans$里。
```cpp
if(x[0]=='@')
	ans+="at";
if(x[x.size()-1]=='@'){
	x.erase(x.size()-1);
	x+="at";
}
if(x[0]=='.')
	ans+="dot";
if(x[x.size()-1]=='.'){
	x.erase(x.size()-1);
	x+="dot";
}
if(x[0]!='@'&&x[0]!='.')
	ans+=x[0];
```
你有没有发现如果是最后一个字母有问题，并不把它存进去？后面我们会做的。

有些人说：“很好，这就是我想要的结果，打印吧。”

错的，如果中间有多个@，例如
```
abc@abc@abc
```
那怎么办？~~尽管这个电子邮箱有点不太靠谱哈~~

我们还要判断，并且我们刚刚只处理了第一个字符啊！

先弄个$j$。
```cpp
int j=1;
```
$j$是用来记处理到哪一位了，由于第$0$位已经处理过，我们把$j$设成$1$。

我们现在出发，找第一个@，这个@及前面的字符都是可以的，不是吗？
```
while(x[j]!='@'){
	ans+=x[j];
	++j;
}
```
这个循环结束后，$x[j]$一定是@，所以我们把@加入$ans$，同时++$j$。
```cpp
while(x[j]!='@'){
	ans+=x[j];
	++j;
}
ans+='@';
++j;
```
后面的@一律不算数~
```cpp
while(j<x.size()){
	if(x[j]!='@')
		ans+=x[j];
	else
		ans+="at";
	++j;
}
```
打印吧，已经OK了
```cpp
cout<<ans<<endl;
```
最后结束程序。
```cpp
return 0;
```
---
~~完整代码大家自己拼吧~~