题意：定义 $f(x)$ 为其十进制意义下各位数字之和，比如 $f(1)=1,f(123)=6$。给定长度为 $n$ 的序列 $A$，请找到一个非负整数 $x$ 使得 $\sum\limits_{i=1}^nf(A_i+x)$ 最小，并输出这个最小值。

由于 $n$ 很大，不大可能是以 $n$ 为阶段进行 DP，所以只可能是以数位为阶段。然后用 $f_{i,y}$ 代表从低到高第 $i$ 位，并且这一位产生了 $y$ 个进位时最多能减少的值（也就是假设 $x$ 这一位是 $t$，那么数字和增加了 $nt$，而由于产生了 $y$ 次进位，变化的量就是 $nt-9y$，维护的就是这个东西的最小值）。

思考这样的状态是否足够。我们发现一个性质，由于每个数加的 $x$ 是相同的，所以后 $i$ 位越大的数越容易在这一位产生进位。于是我们可以按照后 $i$ 位的大小把 $A$ 排序，这样一来就可以精准地知道到底是哪些数进位了。

梳理一下流程。枚举上一阶段的状态以及 $x$ 当前位放什么数。假设当前枚举到了 $f_{i-1,z}$，当且这一位放的数是 $t$，于是发现一个数能进位当且仅当这一位上的数 $t'+t\ge 10$，也就是 $t'\ge 10-t$。动态维护 $t'$ 的后缀和即可。由于有进位的影响，而根据前面的分析，上一阶段每个进位都确定地对应了某个数，这样一来只需要给这个数对应的位置减一，然后给后一个位置加一，并更新后缀和即可。

复杂度 $O(T^2n)$，$T$ 是 $10$，即表示阶段数（也就是最大数的位数）以及字符集大小。