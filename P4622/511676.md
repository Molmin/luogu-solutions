## 题目大意
题意其实算得上是比较清楚的了，就是在一段区间中选择一段连续的，然后让它们的高度$+1$（端点不能选）。不懂的模拟一下样例就行了。

![](https://cdn.luogu.com.cn/upload/pic/19412.png)

注意，下面的情况不能出现：

![](https://cdn.luogu.com.cn/upload/image_hosting/m1muhu9s.png)

# Solution
~~最开始本蒟蒻看到这个题也不会，看了很多大神的题解。（膜拜大神）(〃'▽'〃)~~

很显然，这道题是一道 DP ，但是 DP 的的状态比较难确定（不得不说COCI的题是真的不错）。从刚刚的例子我们其实可以通过观察得到，第一个和最后一个必然是0，否则直接输出无解。对于当前的每一个位置，最开始都是0，即相等。对于每一次操作，对于高度相等的  $i$ 和 $i+1$ ，我们可以讨论一下：

------------
①.如果 $i$ 和 $i+1$ 的高度一起 $+1$ ，则它们的高度仍然相等。

②.如果i的高度 $+1$，$i+1$ 不变，则最终的 $i$ 仍然比 $i+1$ 高1个单位。这是因为此时，$i$ 为右端点（对于左半边的区间而言），即 $i$ 的高度再也无法改变；而 $i+1$ 为左端点，所以 $i+1$ 的高度也无法改变。也就是说，之后的操作一定是不会影响到这两个位置的。

③.如果 $i+1$ 的高度$+1$，$i$ 不变，则最终的 $i+1$ 仍然比 $i$ 高1个单位。（道理同上）

------------
综上，我们得出结论：
$$ \text{相邻的两个位置，它们的高度差 } \le 1 \text{。}$$

剩下的就很简单了：定义状态 $f[i][j]$ 表示第i个位置的高度为j的情况数。初始化就是 $f[1][0]=1$，要输出的是 $f[n][0]$。

对于每一个位置 $i$，能达到的最大高度显然是：
$size = i - 1 (i \le n \div 2) \text{ 或者 } size = n - i (i > n \div 2)$。
如果当前位置是 $-1$，就去循环 $0 \sim size$；如果题目给定了就去分类讨论：$ \le size$ 就计算情况数，反之直接输出0。

其实本蒟蒻也写过一种直接暴算的做法，即循环枚举 $0 \sim size$，懒得算 $size$。但这样有个很严重的问题：对于那些题目给定的高度，我们只能通过判断情况数是否为 0 来看能否达到这个高度，这样的话就不能随便取模（因为有可能模完为 0），就只能算完之后整体取模。但 $n$ 太大了，导致 long long 都装不下答案。所以这个题必须要一边处理 $size$ 一边做。

最后还有一个所有题解都提到的滚动数组啦（没学过的看代码）。

# AC代码
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long LL;

const int N = 10010, mod = 1000000007;
int n, a[N];
LL f[2][N];

int main()
{
	cin >> n;
	for(int i = 1; i <= n; i++)
		cin >> a[i];
	if(a[1] > 0 || a[n] > 0)
	{
		cout << 0 << endl;
		return 0;
	}
	
	f[1][0] = 1;
	for(int i = 2, now = 0; i <= n; i++, now = !now)
	{
		memset(f[now], 0, sizeof(f[now]));
		
		int size = (i <= n / 2 ? i - 1 : n - i);
		if(a[i] != -1)
		{
			if(a[i] > size)
			{
				cout << 0 << endl;
				return 0;
			}
			f[now][a[i]] = ((a[i] >= 1 ? f[!now][a[i] - 1] : 0) + f[!now][a[i]] + f[!now][a[i] + 1]) % mod;
			continue;
		}
		for(int j = 0; j <= size; j++)
			f[now][j] = ((j >= 1 ? f[!now][j - 1] : 0) + f[!now][j] + f[!now][j + 1]) % mod;
	}
	cout << f[n & 1][0] << endl;
	return 0;
}

```
