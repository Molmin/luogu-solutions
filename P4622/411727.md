# 初始 dp 定义和各种问题
先来 dp 定义：$dp_{i,j}$ 表示前 $i$ 个数且第 $i$ 个数是 $j$ 的方案数。

接下来会面临 $2$ 个问题：


* 转移怎么办？考虑前 $i-1$ 个数，但是第 $i - 1$ 个数又是多少？？ 
* 第 $i$ 个数为 $j$，$j$ 的范围是多少？ （开数组和枚举时需要用到）

**问题一解决方案：**

分析一下第 $i - 1$ 个数和第 $i$ 个数的关系。


假设序列中一个区间是由 $k$ 组成的，那么跟这个区间相邻的数只能为 $k - 1, k, k + 1$。简化后可得**序列中相邻两数绝对值相差小于等于 $1$**。

那么 问题一 $ \ $中的第 $i - 1$ 个数的值只能是 $j,j-1,j+1$。

**问题二解决方案**

序列中的最大值绝对不会超过 $n$。 那么 **$j$ 的范围只需要枚举到 $n$**。

# 状态转移
由于第 $i - 1$ 个数和第 $i$ 个数绝对值相差小于等于 $1$。

那么 $dp_{i,j}=\max\{dp_{i-1,j-1},dp_{i-1,j},dp_{i-1,j+1}\}$。

这里注意一下，如果 $a_i$ 是已知的，直接套用方程即可，否则，需要枚举 $j$ 进行转移！

# 小细节
* 转移的时候需要判断数组是否越界。
* 开 $10005\times 10005$ 的 dp 数组很显然开不下的，可以滚动优化。
* **需要判断第一个数和最后一个数是否大于等于 $1$，如果是就输出 $0$ !!!  ** 

# 代码
```c++
//这个代码是有坑的，但是这个坑已经提到过了
#include <bits/stdc++.h>
using namespace std;

#define int long long
const int N = 1e4 + 5, mod = 1000000007;
int a[N], dp[2][N];
int n;

signed main() {
	cin >> n;
	for (int i = 1; i <= n; i++) {
		cin >> a[i];
	}
	dp[1][0] = 1;
	for (int i = 2; i <= n; i++) {
		memset(dp[i & 1], 0, sizeof dp[i & 1]);
		if (a[i] != -1) {
			if (a[i] >= 1) {   //数组可能越界
				dp[i & 1][a[i]] = (dp[(i - 1) & 1][a[i] - 1] + dp[(i - 1) & 1][a[i]] + dp[(i - 1) & 1][a[i] + 1]) % mod;
			}
			else {
				dp[i & 1][a[i]] = (dp[(i - 1) & 1][a[i]] + dp[(i - 1) & 1][a[i] + 1]) % mod;
			}
		} 
		else {
			for (int j = 0; j <= N - 5; j++) {
				if (j >= 1) {
					dp[i & 1][j] = (dp[(i - 1) & 1][j - 1] + dp[(i - 1) & 1][j] + dp[(i - 1) & 1][j + 1]) % mod;
				}
				else {
					dp[i & 1][j] = (dp[(i - 1) & 1][j] + dp[(i - 1) & 1][j + 1]) % mod;
				}
			}
		}
	}
	cout << dp[n & 1][0] << endl;
}
```