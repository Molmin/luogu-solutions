## 动态规划+STL：map做法

### 题目的意思就是求出最长连续上升子序列

什么是最长上升连续子序列呢？

**最长**：不用解释，就是子序列越长越好

**连续**：子序列中每个数都是连续的（既差为1）

**上升**：子序列的数是单调递增的

**子序列**：子序列就是原来序列中的一部分构成的序列，这里不一定需要在原来序列中是相邻的

~~翻译不太好~~


方法是什么呢？由于每个数和它-1的数的答案是有关系的，也就是+1，那么我们就可以采用动态规划的做法

$ans[i]:$以i结尾的最长连续上升子序列的元素个数的最大值。

那么我们可以利用STL中的map来访问a[i]-1的编号

于是方程就是：

$1.map[a[i]-1]!=0:ans[i]=ans[map[a[i]-1]]+1$

$2.map[a[i]-1]==0:ans[i]=1$(因为它是新的子序列的开始)

**注意！不能用数组来当桶用**

为什么呢？你看一下a[i]的范围就知道了

输出ans数组中最大的元素就是第一问的答案

第二问怎么输出这个子序列呢？

我们找到ans[i]最大值以及它在数组中的值，因为是连续的，所以我们可以知道子序列开始的数

那么，再循环一边找到子序列在原来序列中的下标就可以了

好的，代码开始：
```cpp
#include <iostream>//基本输入输出流 
#include <map>//一会要用map来查询编号 
using namespace std;
map<int,int>m;//数->编号的映射 
int n;
int ans[200005],a[200005];//ans就是动归变量 
int maxa;//第一问答案 
int l,r;//子序列元素的最小值和最大值 
int main()
{
	cin>>n;//输入个数 
	for(int i=1;i<=n;i++)
	{
		cin>>a[i];//输入原来序列的每个数 
		int tmp=m[a[i]-1];//找到前一个的编号 
		if(tmp)//如果非零（在原序列中存在） 
		{
			ans[i]=ans[tmp]+1;//等于以上一个元素的答案+1 
		}
		else ans[i]=1;//如果为零（在原序列中不存在） ，它就是新的子序列的开始 
		m[a[i]]=i;//关联起来数和编号 
	}
	for(int i=1;i<=n;i++)
	{
		if(ans[i]>maxa)maxa=ans[i],r=a[i];
		//找到最大的子序列长度以及其中最大的数 
		//a[i]一定是以它结尾的子序列的最后一个数 
	}
	cout<<maxa<<endl;//输出第一问答案 
	l=r-maxa+1;//求出子序列的最小数 
	int idx=l;//记录一下 
	for(int i=1;i<=n;i++)
	{
		if(a[i]==idx)//如果子序列开始 
		{
			cout<<i<<" ";//输出它的编号 
			idx++;//要找的数+1（因为子序列是连续上升的） 
		}
	}
	return 0;//养成好习惯，竞赛中没有直接爆零 
}
```
测第一个样例，发现不对！

难道在多个数的情况下，输出字典序最大的答案吗？

完了，需要将所有可能的答案记录下来，在用trie数搜字典序？？？

其实不用，我们看一下题目，没说

样例说明也说了可以输出其他答案，我的代码是输出字典序最小的

那就没事了~~~

谢谢大家