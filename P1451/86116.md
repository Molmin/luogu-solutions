这道题很明显，是一道搜索题，求非零区块数。

搜索非零的区块，并将搜索到的区块全部赋值为零，看看要进行几次操作就好了。

```
如例题:
 4 10
 0234500067
 1034560500
 2045600671
 0000000089
```

```
第1次操作
 0000000067
 1000000500
 2000000671
 0000000089
```

```
第2次操作
 0000000000
 1000000500
 2000000671
 0000000089
```

```
第3次操作
 0000000000
 0000000500
 0000000671
 0000000089
```

```
第4次操作
 0000000000
 0000000000
 0000000000
 0000000000
```
所以共操作四次，答案输出4
我们知道，搜索有深搜和广搜，深搜一般适合解决求次数的问题，可以看作大暴力，广搜则能高效遍历全图，求最短路径和邻接块的问题。

这道题明显广搜适合，虽然深搜能水过，但效率极低，不推荐。

这里其实程序的主函数是一样的，不同的是那个操作，也就是用深搜或广搜去遍历这个区块，将其赋值为零。

主函数如下
```
int main(){
	cin>>n>>m;
	for (int i=1;i<=n;i++)
	{
		cin>>s;
		for (int j=0;j<s.size();j++) 
			a[i][j+1]=s[j]-'0';
	} //常规读入
	for (int i=1;i<=n;i++)
		for (int j=1;j<=m;j++)
			if (a[i][j]!=0)//找到区块的第一个点，才进行操作
			{
				ks(i,j);//进行操作
				k++;//统计操作次数
			}
	cout<<k;
	return 0;
} 
```
重要的是操作了

先看深搜
```
void cz(int x,int y)
{
	if (a[x][y]==0) return;判断所在位置是否在要求区块内
	a[x][y]=0;//遍历过了，将这个位置赋值为零
	cz(x+1,y);//向上搜索
	cz(x-1,y);//向下搜索
	cz(x,y+1);//向右搜索
	cz(x,y-1);//向左搜索
}
```
让后广搜
```
int bi[5]={0,1,0,-1,0},bj[5]={0,0,-1,0,1};
queue<int> q1,q2;
void cz(int x,int y)
{	
	q1.push(x);
	q2.push(y);
    //将原位置放入要搜索的队列
	while(!q1.empty())//无可搜索位置时，循环结束
	{
		int x1=q1.front();q1.pop();
		int y1=q2.front();q2.pop();
        //取出要搜素的位置，这个位置没用了，可以踢出队列
		a[x1][y1]=0;//因要搜索的位置处于要求区块，所以直接赋值为零
		for (int i=1;i<=4;i++)
		{
			int xx=x1+bi[i];
			int yy=y1+bj[i];
            //xx,yy表示临近搜索位置的四个点，这几个点有可能能继续搜索
			if (a[xx][yy]!=0)//判断上述的点是否可行
			{
				q1.push(xx);
				q2.push(yy);
                //若可行，将其存入要搜索队列
			}
		}
	}
}
```