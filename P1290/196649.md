#  P1290 欧几里德的游戏 题解

### ~~说实话我是不小心就 AC 了……~~


------------

看到这样的取数游戏，问先手是否有必胜的策略，我们可以考虑什么情况下先手必胜。

在本题中，我们为了方便规定 $X$，$Y$ 为两个操作数，并且满足 $X>Y$。

那么先手必胜当且仅当经过几轮之后：

$$X\text{ mod } Y=0(\text{轮到先手操作})$$

我们先不管谁会赢，我们考虑把题目给出的两个数变为0的最小操作次数。这里的操作次数定义为：进行一次减法运算为一次操作。比如 $(7,2)$ 变为 $(3,2)$ 需要操作 $2$ 次，变为 $(1,2)$ 需要操作 $3$ 次。

那么若要使 $X,Y$ 中的一者变为 $0$， 考虑每次 $X,Y$ 大小发生变化，会发生如下的操作：$X=X\text{ mod }Y$，为了符合上面所做的规定，我们交换 $X,Y$，每次大小发生变换对操作次数的贡献为 $\left \lceil\frac{X-Y}{X}\right\rceil $。

- **提示**：**下面所说的先后手与先后操作并不矛盾**。**先后手指的是**一开始操作的人是先手还是后手，**即我们用先手和后手代表人**；而**先后操作是**到当前的这个状态轮到哪一个人**先或后操作**，即为**操作顺序**。（可能有点绕……但是为了防止误解还是说一下）

我们考虑每一次 $X,Y$ 大小发生变化的时候，操作次数对胜负会造成什么样的影响。假设现在 $X\text{ mod }Y=0$，已经是必胜局面，不妨假定此时轮到先手操作，我们对所有局面进行**逆推**，如果最终结果与一开始先手一致，则可说明先手必胜，否则假设不成立，先手没有必胜策略。

考虑当前状态为转变到 $X\text{ mod }Y=0$ 的上一步，令此时操作次数为 $k=\left \lceil\frac{X'-Y'}{X'}\right\rceil $，接下来分类讨论：

1. $k=1$，此时只能操作一次，那么当前一定是后手操作。

2. $k>1$，考虑如何使得 $X\text{ mod }Y=0$ 时是先手操作。如果当前后手操作，则存在一种方案，可以让后手操作完后 $k'=1$，此时先手操作必定会使必胜局面 $X\text{ mod }Y$ 让给了后手，这样后手就必胜了。所以如果下次次是必胜的局面，当前要必胜，那么只能让先手操作。因为先手操作后同理可以使 $k'=1$，即后手对 $X$ 减去一个 $Y$ 之后就轮到先手，且满足 $X\text{ mod }Y=0$，先手就赢了。

- 注意上面全部推论保证 $X>Y$，若出现 $X<Y$ 的情况应该交换两者再继续。

显然上面的推论不止适用于当前状态下一步 $X\text{ mod }Y=0$ 的情况。我们注意到$X\text{ mod }Y=0$ 此时即为先手，即当前操作的人必胜，所以上面推论可以扩展到当前局面的下一个局面为先手必胜状态的情况。


因为我们要知道下一个状态，所以这也是一开始**逆推**的原因，具体可以使用递归实现。我们假设下一步是先手必胜，也就是先手操作一定赢的情况（否则一定输），翻译成代码实现是这样的:

```cpp
bool solve(int X, int Y) { 
	//返回值：0当前操作的是先手  1 当前的是后手
	if(X < Y) Swap(X, Y);
	if(X % Y == 0) return 0;
	//……
	if(solve(X % Y, Y) == 0) { 
		// 上一次操作要求先手来 
		if((X - 1) / Y > 1) return 0;
		return 1;	
	}	
}
```
这里还运用到一个数论小知识：$\left\lceil\frac{a}{b}\right\rceil=\left\lfloor\frac{a+b-1}{b}\right\rfloor$，所以$\left \lceil\frac{X-Y}{X}\right\rceil = \left\lfloor\frac{(X-Y)+Y-1}{X}\right\rfloor$。

接下来我们考虑上一步情况先手必败的情况，也就是后手操作先手才能赢，对应上面代码的程序返回值应为 $0$，令此时操作次数为 $k=\left \lceil\frac{X'-Y'}{X'}\right\rceil $：

1. $k=1$，那么仍然只能选择当前先手操作（因为只能操作一次）。

2. $k>1$，考虑当前后手操作，后手一定可以操作到这一步的下一种状态，也就是 $X,Y$ 的大小发生了改变。这样的状态即当前状态的下一步，本来应该后手操作先手才能必胜的，但是如果这一步是后手先操作，那么这个状态就变成了先手操作，那么先手就必败了。所以当 $k>1$ 时，只能让先手操作，否则后手必胜。

所以我们得到了当前步下一步为先手操作必胜还是后手操作必胜的所有情况。我们仍按照上面代码的 $0,1$ 规则进行编号（$0$代表这一步先手操作，$1$代表后手操作），令每一步的胜负状态为 $S_i$，当前步的下一步为 $Next_i$，则当前状态 $i$ 的后继状态就是 $S_{Next_i}$，当前的 $X,Y$ 分别记为 $X_i,Y_i$，那么令 $k_i=\left \lceil\frac{X_i-Y_i}{X_i}\right\rceil$。

那么：

- 若 $S_{Next_i}=0$，即下一步先手操作则先手必胜，那么：

> 结论1. $S_{Next_i}=0,k_i=1$，则 $S_i=1$；

> 结论2. $S_{Next_i}=0,k_i>1$，则 $S_i=0$；

- 若 $S_{Next_i}=1$，即下一步后手操作则先手必胜，那么：

> 结论3. $S_{Next_i}=1,k_i=1$，则 $S_i=0$；

> 结论4. $S_{Next_i}=1,k_i>1$，则 $S_i=0$。

观察上面的部分，发现对于所有状态 $S$，唯有$S_{Next_i}=0,k_i=1$，则 $S_i=1$ 的情况当前需要后手操作，所以我们可以得到下面这样一个很简洁的代码：

```cpp
bool solve(int X, int Y) { 
	//1 当前后手
	//0 当前先手 
	if(X < Y) Swap(X, Y);
	if(X % Y == 0) return 0;
	if(!solve(X % Y, Y) && (X - 1) / Y == 1) 
		return 1;
	return 0;	
	// 这个 (X-Y)/Y 上取整等于 (X-Y+Y-1)/Y下取整
	// 在题解里已经强调过了 
}
```
（你们可能注意到 $Swap$ 函数的 $S$ 是大写的了，因为是我手写的……）

（~~核心代码都出来了不会你们还想要完整代码吧……~~）


------------

 - 别急，没看懂？那我带你来模拟一遍。

首先我们列出了所有状态：

![](https://i.loli.net/2019/11/21/DnroLUelzCaT5N6.jpg)

这张图中我们左边放的是 $X$，而右边放的是 $Y$。

显然最终状态是 $X=3,Y=1$，规定这个状态的值为 $S_4=0$，也就是先手在 $X=3,Y=1$ 的时候操作。

1. 那么我们开始推 $4,3$ 的 $S$ 值。此时有 $k_3=\frac{4-1}{3}=1$（为什么减 $1$ 的已经说过很多次了）。那么因为 $S_{Next_3}=S_4=0$，满足上面的第一条规律，所以 $S_3=0$。

2. 继续，$S_{Next_2}=S_3=1$，$k_2=\frac{7-1}{4}=1$，满足第 $3$ 条规律，所以 $S_2=0$。

3. 快结束了！$S_{Next_1}=S_2=0$，$k_1=\frac{25-1}{7}=3$，满足第 $2$ 条规律，所以 $S_1=0$，即开始使先手会必胜，所以样例第一个输出了 "Stan wins"。

- ~~下面为了减少语言表述~~，我直接放上第二组样例的一张图，大家自己模拟一下：（~~绝对不是因为我懒得写~~）

![](https://i.loli.net/2019/11/21/pSPQu3svnrxZ5ka.jpg)

- 注意到最后推出来初始状态先手需要后操作，但是我们规定初始状态先手必须先操作，所以先手没有必胜的策略，那么输出 "Ollie wins" 即为答案。

（都画了这么多图了总该理解了吧……）

其实上面那一段代码还有可以优化时间的地方，具体的会在下面完整程序中体现。

（~~说好不给完整程序的呢？~~）

（~~啊！真香……~~）


------------

- ## $Code$


```cpp
#include<bits/stdc++.h>
using namespace std;

void Swap(int &X, int &Y) {
	X ^= Y, Y ^= X, X ^= Y;
}

bool solve(int X, int Y) { 
	//1 当前后手
	//0 当前先手 
	if(X < Y) Swap(X, Y);
	if(X % Y == 0) return 0;
	
	if((X - 1) / Y > 1) return 0; 
	if(solve(X % Y, Y)) return 0;
	return 1;	
}

int main() {
	int T, X, Y;
	scanf("%d", &T);
	while(T--) {
		scanf("%d %d", &X, &Y);
		if(solve(X, Y)) puts("Ollie wins");
		else puts("Stan wins");
	}
	return 0;
}
```

$End$
------------
### 点个赞好嘛 $QwQ$ （~~我好无耻啊……~~）