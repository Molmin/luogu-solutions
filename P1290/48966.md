第一次发题解，希望能对大家有所帮助。

对于这个问题，m每次可以减去n的整数倍，

我们分下面几种情况讨论：

1.m-n<n,也就是m只能减去n\*1,这是状态是唯一的，模拟辗转相减法就可以得出胜负。

2.m-n>n,对于这种情况看似很复杂，因为不确定m可以减去n的几倍后才会得到情况1，

但其实细细分析，我们假设情况1是必胜态

a.如果n\*(k+1)>m>n\*k,如果直接m-n\*k，就得到情况1，当前的人必胜

b.如果减去n\*(k-1),那么下一个人只能减去n，那么下一个人就处在情况1，当前的人必输

c.如果减去n\*(k-2)，那么下一个人会采取优策略，因为情况1是必胜，所以他减去n\*2后就得到情况一，当前的人必输。

d.如果减去n\*(k-3)......，道理可同c

那么当情况一是必输态时呢？

a.这是唯一的状态，

b.此时下一个人处在情况1，当前的人必胜

c.减去n\*(k-2)实际上是在给下一个人喘息的机会，他完全可以再减去n，那么当前的人就处在情况一必输，这明显不是最优策略

也就是说

情况2当前的人必胜

而情况1模拟即可。


参考代码：

```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
int main(){
    int T;
    scanf("%d",&T);
    while (T--){
        int n,m;
        bool f=true;
        scanf("%d%d",&n,&m);
        for (;;){
            if (n<m)swap(n,m);
            if (n%m==0 || n-m>m)break;
            n-=m;f=!f;    
        }
        if (f)printf("Stan wins\n");
        else printf("Ollie wins\n");
    }
    return 0;
}

```