#### 题目链接[P1290 欧几里德的游戏](https://www.luogu.org/problem/P1290)

```
题目描述
欧几里德的两个后代Stan和Ollie正在玩一种数字游戏，这个游戏是他们的祖先欧几里德发明的。给定两个正整数M和N，从Stan开始，从其中较大的一个数，减去较小的数的正整数倍，当然，得到的数不能小于0。然后是Ollie，对刚才得到的数，和M，N中较小的那个数，再进行同样的操作……直到一个人得到了0，他就取得了胜利。下面是他们用(25，7)两个数游戏的过程：

Start：25 7

Stan：11 7

Ollie：4 7

Stan：4 3

Ollie：1 3

Stan：1 0

Stan赢得了游戏的胜利。

现在，假设他们完美地操作，谁会取得胜利呢？

输入格式
第一行为测试数据的组数C。下面有C行，每行为一组数据，包含两个正整数M, N。（M, N不超过长整型。）

输出格式
对每组输入数据输出一行，如果Stan胜利，则输出“Stan wins”；否则输出“Ollie wins”

输入输出样例
输入 #1复制
2
25 7
24 15
输出 #1复制
Stan wins
Ollie wins
```
对于这一题

我们设当前两个数字的组合为${(a,b)}$(a>=b)

显而易见当a=b时先手必胜

因此我们只讨论**a>b**的情况

我们设${a=k*b+c}$(k=${\lfloor{a/b}\rfloor}$,c为余数)

易知对于当前状态${(k{*}b{+}c,b)}$可以转移到{ ${((k{-}1){*}b{+}c,b)}$, ${((k{-}2){*}b{+}c,b)}$,...,${(b{+}c,b)}$,${(b,c)}$ }

此时如果**k>1**则对于该状态来说先手必胜

证明:

若k>1,则一定可以将状态${(k{*}b{+}c,b)}$转移至 ${(b{+}c,b)}$或${(b,c)}$ 

而对于状态${(b,c)}$有两种可能——必胜状态或必败状态

1. 当${(b,c)}$为必败状态时,则可以转移到该状态的${(k{*}b{+}c,b)}$一定为必胜状态

2. 当${(b,c)}$为必胜状态时,由于c<b(因为c是余数),则${(b+c,b)}$只能转移到${(b,c)}$,

	即${(b+c,b)}$为必败状态,因为${(k{*}b{+}c,b)}$可以转移到该状态,所以${(k{*}b{+}c,b)}$一定为必胜状态
    
证毕.

因此,我们得出一个结论

```
当a!=b,且a>2*b(保证k>1)时,(a,b)为必胜状态,即先手必胜

```

接下来讨论当**k==1**的情况

此时状态为${(b{+}c,b)}$

而对于这种状态,我们只能转移到${(b,c)}$状态

而对于${(b,c)}$我们令${b{=}k{*}c{+}d}$

则状态可化为${(k{*}c{+}d,c)}$,而这与我们之前讨论的情况类似

因此对于该状态,若k>1则谁取谁就必胜,否则转移到${(c,d)}$再进行上述讨论

放代码


```cpp
#include<bits/stdc++.h>
using namespace std;

int read(){
  int p=0;char c=getchar();
  while(c<'0'||c>'9')c=getchar();
  while(c>='0'&&c<='9')
  p=(p<<3)+(p<<1)+c-'0',c=getchar();
  return p;
}

int T,n,m,x,ans;

int main(){
  T=read();
  while(T--){
    n=read();m=read();
    ans=1;//1为S取,0为O取
    if(n<m)swap(n,m);//n始终为大数
    if(n==m){//若相等,则S胜
      printf("Stan wins\n");
      continue;
    }
    while(n<2*m){//若n<2*m,即n=m+c
      n-=m;
      if(n<m)swap(n,m);//n为大数
      ans^=1;//换人取
    }
    if(ans)printf("Stan wins\n");//在必胜状态若S取,则S胜
    else printf("Ollie wins\n");//同理
  }
  return 0;
}

```


