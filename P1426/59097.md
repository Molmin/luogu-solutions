其实跟某一题解的思路一样，但是看了那一片题解的评论区，还有不少人有疑问，于是，我就再详细的讲解一下这道题。~~（希望能通过）~~

在小鱼到达探测范围之前，都在一直游，l记录的是离出发点的距离。总所周知：x（位移）=v（当前的速度）*t（时间），但是需要注意的是，速度是一直在变的，也就是每一秒的v都是上一秒的98%，所以一定要每次让v自乘0.98。

当小鱼到达探测范围时，循环就退出了，因为循环的条件是l<s-x（x-s~x+s整个区间都是探测范围，~~这应该很好理解~~）。题目要求是：“也就是说小鱼一旦进入探测器范围，如果能在下1秒的时间内马上游出探测器的范围，还是安全的。”注意是在下一秒，所以v还要自乘0.98（因为这个时候的v是上一秒的）。然后下一秒经过的位移是x=v'*t=v*0.98*1=v*0.98，只要这个位移x>s+x-l，就是安全的，否则，有危险。

肯定有些读者还对x>s+x-l这句话有疑问，那在解释一下。因为退出循环时，小鱼已经到了探测范围之中，所以这时l>s-x&&l<s+x。所以小鱼现在的位置（l）到游出探测范围（s+x）之间的距离就是s+x-l啦，对吧。

下面看代码吧（很短的）：

```cpp
#include<bits/stdc++.h>//万能头文件 
using namespace std;
double s;//邪恶的猎人把探测器安装在距离A处右边s米的地方
double x;//探测器左右x米之内是探测范围
double v=7;//鱼第一秒可以游7米
double l;//记录游泳到的位置距A点的距离 
int main()//主函数 
{
	cin>>s>>x;//输入s、x 
	while(l<s-x)//在游到探测范围之前 
	{
		l+=v;//每秒的位移x=v'*t，l为总的距离，l+=x。 
		v*=0.98;//从第二秒开始每秒游的距离只有前一秒的98%
	}
	if(v*0.98>=s+x-l)//如果在一秒内小鱼游出了探测范围 
		cout<<"n";//没有危险 
	else//否则 
		cout<<"y";//有危险 
	return 0;//结束 
}

```

ps

再提几点需要注意的：

1、因为每次*0.98所以计算出来的结果一定是小数，所以要用double型变量来存储

2、因为那一篇题解最后没有打return 0，所以再次提出，return 0最好写上，作为一个oier良好的代码习惯

3、一定要有良好的代码风格，特别是缩进，这样可以大大增加代码的可读性。

最后，感谢大家看完本蒟蒻这篇冗长的题解。