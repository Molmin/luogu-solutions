这里我们把题目中的s，x换成n，m

因为小鱼的第n秒的运动总距离的这样的7\*1+7\*0.98+...+7\*0.98^n

那么我们化简一下7\*(0.98^(n+1)-1)/(0.98-1)

公式解读

【
令s=1+a+a^2+...+a^n

则as=a+a^2+...+a^n+a^(n+1)

∴(a-1)s=a^(n+1)-1

∴s=(a^(n+1)-1)/(a-1)

】
继续化简350\*(1-0.98^(n+1))

首先令s=1每次循环\*0.98

那么第s-1秒的距离就是350\*(1-s)

循环到下一秒能进入探测圈的那一秒跳出

就是 350\*(1-s)>=n-m时跳出

当然s已经多乘了一次0.98了，所以出来再除一遍0.98

然后下一秒运动的距离就是 7\*s\*0.98

求出（恰好到n-m的时间）-（下一秒运动后会到n-m的时间） 的时间 t

然后 看看 (1-t)\*下一秒的运动距离+t\*下下秒的运动距离 是否>2\*m

大于输出n

否则输出y






```cpp
#include<cstdio>
double n,m,t,s=1,l=350;
int main()
{
    scanf("%lf%lf",&n,&m);
    while(l-l*s<n-m)s*=0.98;
    s/=0.98;
    t=(n-m-l+l*s)/(7*s*0.98);
    if((1-t)*(7*s*0.98)+t*(7*s*0.98*0.98)>2*m)puts("n");
    else puts("y");
return 0;
}
```
接下来上一下改进的代码（其实就是合并了下多项式）

```cpp
#include<cstdio>
double n,m,t,s=1,l=350;
int main()
{
    scanf("%lf%lf",&n,&m);
    while(l-l*s<n-m)s*=0.98;
    s/=0.98;
    t=(n-m-l+l*s)/(6.86*s);
    if(6.86*s-0.1372*t*s>2*m)puts("n");
    else puts("y");
return 0;
}
当然因为数据水，没有卡数据的所以用楼下的方法也是可行的
```