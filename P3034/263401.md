## 题意：
- 有一堆奶牛，每次拍照前按一定顺序排好。
- 每次拍照时，有若干奶牛重新插入到新位置，不动的奶牛之间相对位置（即顺序）不变。
- 每个奶牛至多移动一次，若一个奶牛在一次拍照时移动，则在其他拍照时不动。
- 给你五次拍照后的结果，让你求原序列。

## 解析

**这道题的核心在于：考虑相对位置。**

设奶牛 x 和 y ，原序列中 x 在 y 前，我们尽可能让最多的时间 x 在 y 后：

1. 第一次， x 移到 y 后。
2. 第二次， y 移到 x 前。
3. 由于 x 和 y 都移动过了，而不管其他奶牛怎么移动，都不可能令 x 在 y 后，所以，至少有 3 次 x 和 y 保持 原序列的相对顺序。

所以，只需统计每次照相时两两的相对位置，若出现三次及以上**一者在另一者前的情况**，则原序列中也有如此前后关系。

~~为什么Farmer John要拍五次照？为了使保持任何两头奶牛维持原序列的先后状态（3+）， 永远大于不同于原序列的先后状态 （2-），因为这样才有唯一解。~~

**但是，有一句“保证所有编号都是不超过 1\,000\,000\,0001000000000 的非负整数。”**

说明 FJ 并不是按照“1，2，3 ···”的顺序编号的，此时我们要用离散化。

但是，如果直接用 STL map 的话，会时间超限。

看了高人的题解后，我知道了一种叫
```cpp
tr1::unordered_map
```
的东西，于是斗胆用了一下，经过多次尝试后，发现这东西可以帮助我们通过此题。

下面附上源码：
```cpp
#include <bits/stdc++.h>
#include <tr1/unordered_map>
using namespace std;
const int MAXN = 20000;
int n, List [MAXN+1];
tr1::unordered_map <int, int> Dis [6]; //离散化映射，具体在其他题解里有 
bool cmp (int a, int b){ //排序函数 
	int end = 0;
	for (int i=1; i<=5; i++) end += Dis[i][a]<Dis[i][b];
	return end >= 3;
}
int main (){
	scanf ("%d", &n);
	for (int i=1; i<=5; i++){
		for (int j=1; j<=n; j++){
			scanf ("%d", &List [j]);
			Dis [i][List[j]] = j;
		}
	}
	sort (List+1, List+n+1, cmp); // 通过cmp排序
	for (int i=1; i<=n; i++) printf ("%d\n", List [i]);
	return 0;
}
```
