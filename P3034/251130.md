## 题意
- #### 有 $n$ 头牛，用小于等于 `1,000,000,000` 的正整数编好了号。牛们初始有一个排列顺序，FJ 希望以个顺序给牛拍照。
- #### FJ 一共拍了 5 张照，但是牛很不安分，总是从它自己的位置移动到其它位置，所以 FJ 不得不在每次拍照前都让它们排好序。
- #### 每头牛都有一次机会在拍某张照前移动到另一个位置。但一旦用了这个机会这头牛在拍剩下的四张照片时都不会再乱动了。
- #### 给出 5 张照片的顺序，求初始的排列顺序。

## 做法
哈希+排序。

首先，因为每头牛只能动一次，所以如果两头牛在超过 2 张照片中的先后顺序相同，那么这两头牛在初始的排列顺序中先后顺序便固定了。

那么只要对牛的任意一张照片用这种特殊的比较方法排一个序，就可以了。

可是有一个问题就是怎么 $O(1)$ 求出牛在某张照片里的位置。解决方法也很简单，只要用一个哈希表来把牛的编号映射到牛的位置就行了。

但是手写哈希比较麻烦，所以我们可以使用 `STL` 的 `unordered_map`。它的使用方法和 `map` 相同，不同的是 `map` 内部用的是红黑树，查询和修改时间复杂度均为 $O(log_2n)$；而 `unordered_map` 内部用的才是哈希表，查询时间为复杂度为 $O(1)$，但修改则比较慢。而对于这道题，由于只有输入的时候需要修改，所以使用 `unordered_map` 会更好些。

## AC 代码
```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <tr1/unordered_map> // 头文件 

using namespace std;
using namespace std::tr1; // 注意这里，unordered_map 的命名空间是 std::tr1 

int n,ans[20005]; // ans 存初始排列（答案） 
unordered_map<int,int> a[10]; // a 存每张照片中牛的编号对应的位置 

bool cmp(int x,int y)
{
	int cnt=0; // 计数器，存有多少张照片中中 x 的位置比 y 靠前
	for(int i=1;i<=5;i++)
	{
		if(a[i][x]<a[i][y]) // 在这张照片中 x 的位置比 y 靠前 
		{
			cnt++; // 计数器 ++ 
		}
	}
	return cnt>2; // 计数器大于 2，则初始排列中 x 比 y 靠前 
}

int main()
{
	scanf("%d",&n);
	for(int i=1;i<=5;i++)
	{
		for(int j=1;j<=n;j++)
		{
			int x;
			scanf("%d",&x);
			a[i][x]=j; // 建立映射关系 
			ans[j]=x;  // 对最后一张照片排序（其实对哪一张都没问题） 
		}
	}
	sort(ans+1,ans+n+1,cmp); // 排序 
	for(int i=1;i<=n;i++)
	{
		printf("%d\n",ans[i]); // 输出，记得换行 
	}
}
```