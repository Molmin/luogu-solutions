神仙题（

首先考虑没有 $pos$ 和 $val$ 限制下该如何计算答案

结论：$LIS+LDS=n+1$ 的排列一共有 $\binom{2n-2}{n-1}$ 个

证明：考虑对一个排列构造一个标准杨表，那么这个排列的 $LIS+LDS$ 即为第一行长度加上第一列长度，即这个杨表一定只有第一行和第一列

根据 Robinson-Schensted correspondence，两个形态相同的杨表和排列一一对应

于是满足 $LIS+LDS=n+1$ 的排列一共有 $\sum (\frac {n!}{n(i-1)!(n-i)!})^2=\binom{2n-2}{n-1}$ 个

这提示我们去找一个同样有 $\binom{2n-2}{n-1}$ 种方案的选择方式和 $LIS+LDS=n+1$ 的序列一一对应

考虑把排列画到一个 $n\times n$ 的网格图上，规定左上-右下方向为递减，左下-右上方向为递增

考虑构成这个网格图的 $n-1$ 条横分割线和 $n-1$ 条竖分割线，在其中选择 $k$ 条横分割线和 $k$ 条竖分割线染黑，这样一共有 $\binom{2n-2}{n-1}$ 种选择方式，接下来考虑如何把它和 $LIS+LDS=n+1$ 的排列一一对应

记 $(i,j)$ 为第 $i$ 行第 $j$ 列的**格点**，$[i,j]$ 为第 $i$ 条横分割线和第 $j$ 条竖分割线的**交点**

把从上往下每条黑线和**从左往右**每条黑线匹配，并把它们的交点染黑；把从上往下每条白线和**从右往左**每条白线匹配，并把它们的交点染白，那么这张图上一共有 $k$ 个黑点和 $n-k$ 个白点

接下来如下为格点染色：

1. 对于黑点 $[i,j]$，若其左上部分没有白点，则将 $(i,j)$ 染黑；若其右下部分没有白点，则将 $(i+1,j+1)$ 染黑

2. 对于白点 $[i,j]$，若其右上部分没有黑点，则将 $(i,j+1)$ 染白；若其左下部分没有黑点，则将 $(i+1,j)$ 染白

对于这样的格点染色方式，有如下性质：

性质 $1$：所有黑格/黑点单调递减，所有白格/白点单调递增

性质 $2$：若黑点 $[i,j]$ 左上方格被染黑，则 $[i,j]$ 左上方所有的黑点左上方格都被染黑；右下方向同理；对白点同理

性质 $3$：对于黑点 $[i,j]$，$(i,j)$ 与 $(i+1,j+1)$ 中至少有一个被染黑；对白点同理

证明：考虑反证，若黑点 $[i,j]$ 左上方格和右下方格都没被染黑，则说明 $[i,j]$ 左上方和右下方都有白点，与性质 $1$ 矛盾

性质 $4$：不存在一个点既被染黑又被染白（否则一条线上有两个被染色的点）

性质 $5$：不存在一行/一列上有两个格点被染成了不同颜色

证明：考虑反证，假设 $(i,j_1)$ 被染成了黑色，$(i,j_2)$ 被染成了白色，不妨设 $j_1<j_2$

那么一定有 $[i-1,j_1-1]$ 为黑点，$[i,j_2-1]$ 为白点或 $[i,j_1]$ 为黑点，$[i-1,j_2]$ 为白点

无论哪种情况都与格点的染色方式矛盾

性质 $6$：不存在一行/一列上有两个格点被染成了相同颜色

证明：考虑反证，假设 $(i,j_1),(i,j_2),j_1<j_2$ 同时被染黑，则显然 $[i-1,j_1-1],[i,j_2]$ 均为黑点

由于 $j_1-1$ 和 $j_2$ 为两条相邻的黑竖线，所以它们当中必然有一条白竖线，也就必然有白点

而无论白点在哪里都与格点的染色方式矛盾

于是在把格点染色过后，不存在一行/一列上有两个被染色的格点，并且至少有 $n-1$ 个格点被染色了

如果有 $n$ 个格点被染色，则这 $n$ 个格点组成一个排列，并且至少有一个黑点的左上格和右下格均被染黑或一个白点的左下格和右上格均被染白

不妨设有一个黑点 $[i,j]$ 的左上格和右下格均被染黑，那么由性质 $1$ 可得这个排列的 $LDS=k+1$，而由于白点均在 $[i,j]$ 右上方或左下方，所以 $(i,j)$ 一定可以加入 $LIS$ 中，即 $LIS=n-k$，满足条件

如果有 $n-1$ 个格点被染色，记还没有格点被染色的行为 $i$，列为 $j$，并将 $(i,j)$ 染成灰色，此时 $n$ 个染色的格点构成排列

性质 $7$：被 $(i,j)$ 左上方的黑点染黑的格点只有左上格；左下方白点，右下方黑点，右上方白点同理

证明：考虑反证，假设在 $(i,j)$ 左上方的黑点 $[p,q]$ 右下格被它染黑，则第 $i-1$ 条横线不能是黑线（否则根据性质 $2$ 可得第 $i$ 行有格点被染黑）

所以第 $i-1$ 条横线必然是白线，且这条白线上的白点一定在 $[p,q]$ 左下方，而根据性质 $3$，由于这个白点右上方有黑点，所以它的左下格一定被染白，而左下格在第 $i$ 行上，矛盾

性质 $8$：$(i,j)$ 左上方只有黑点，右上方只有白点，左下方只有白点，右下方只有黑点

证明：考虑反证，假设在 $(i,j)$ 左上方有白点 $[p,q]$，不妨它的左下格被它染白了

对于第 $i-1$ 条横线，若其为白线，则根据性质 $1$，白点一定在 $[p,q]$ 左下方，根据性质 $2$，这个白点的左下格一定被染白，而这个染白的格点在第 $i$ 行，矛盾；否则由于 $[p,q]$ 左下方被它染白，说明这条线上的黑点一定在 $[p,q]$ 右下方，由于这个黑点左上方有白点，所以由性质 $3$，它的右下格被染黑，而这个格点在第 $i$ 行，矛盾

此时这个排列的 $LDS=k+1$，$LIS=n-k$，同样满足条件

这样我们就证明了线染色到合法排列的映射，接下来通过构造证明合法排列到线染色的映射

对于一个合法排列 $p$，若它的 $LIS$ 和 $LDS$ 都确定，则令它们的交为灰色格点

灰色格点左上方显然单调递减，所以令这些格点右下角的交点为黑色交点，其他方向同理，显然这样的线染色方式合法

若 $LIS$ 和 $LDS$ 不确定，则它们可能的交一定为一段值连续的递增/递减序列，不妨设是递减序列，记长度为 $l$，那么我们将这个递减序列的前 $l-1$ 个格子的右下角定位黑色交点

由于值连续，所以存在一个 $l\times l$ 且以这段序列为对角线的正方形，把整个正方形看成前面的灰色格点，和前面一样构造即可

这样我们证明了每个合法排列都可以映射到一组线染色，又线染色方案数和合法排列数相同，可以推出线染色和合法排列一一对应

回到原问题，原题即要求一个格点 $(x,y)$ 一定要被染色

若 $(x,y)$ 被染黑，不妨设它被黑点 $[x-1,y-1]$ 染黑，考虑枚举第 $x-1$ 条横线上方的黑线数量 $i$（包含第 $x-1$ 条横线）

由于 $[x-1,y-1]$ 右下方不能有白点，所以要求白横线数量 $n-k-1 \le (x-i-1)+(y-i-1)$ 即 $k\ge n+2i-x-y+1$，也即除了 $i$ 条黑线以外还有至少 $n+i-x-y+1$ 条黑线

同样计算 $(x,y)$ 被 $[x,y]$ 染黑的方案数，再减去同时被 $[x-1,y-1]$ 和 $[x,y]$ 染黑的方案数

对于 $(x,y)$ 被染白和 $(x,y)$ 被染灰的方案数可以同样计算，但这样需要很多容斥，非常麻烦

不难发现 $(x,y)$ 同时被 $[x,y]$ 和 $[x-1,y-1]$ 染黑的要求是除了上方的 $i$ 条黑线以外还有恰好 $n+i-x-y+1$ 条黑线，$(x,y)$ 染灰的要求也是这样

所以我们不妨在之前单独算被 $[x-1,y-1]$ 染黑的情况时把恰好 $n+i-x-y+1$ 条黑线的情况去掉，放到后面一起统计，这样就不需要容斥了

时间复杂度 $\mathcal O(n)$

code:
```cpp
#include<bits/stdc++.h>
#define int long long
#define MAXN 5000010
#define p 1000000007
using namespace std;
const int N=5000000;
int qpow(int x,int y){
	int ret=1;
	for(;y;y>>=1,x=x*x%p)if(y&1)ret=ret*x%p;
	return ret;
}
int n,x,y;
int fac[MAXN],ifac[MAXN];
int C(int x,int y){return x<y?0:fac[x]*ifac[y]%p*ifac[x-y]%p;}
int sum[MAXN];
int calc(int x,int y){
	sum[n]=0;int ret=0;
	if(x>1&&y>1){
		for(int i=n-1;i>=0;i--)sum[i]=(sum[i+1]+C(n-x,i)*C(n-y,i))%p;
		for(int i=1;i<n;i++){
			int t=max(0ll,n+2+i-x-y);
			if(t>=n)continue;
			ret=(ret+C(x-2,i-1)*C(y-2,i-1)%p*sum[t])%p;
		}
	}
	return ret;
}
signed main(){
	fac[0]=1;for(int i=1;i<=N;i++)fac[i]=fac[i-1]*i%p;
	ifac[N]=qpow(fac[N],p-2);
	for(int i=N;i;i--)ifac[i-1]=ifac[i]*i%p;
	scanf("%lld%lld%lld",&n,&x,&y);
	int ans=(calc(x,y)+calc(n-x+1,y)+calc(x,n-y+1)+calc(n-x+1,n-y+1))%p;
	for(int i=0;i<n;i++){
		int t=n+1+i-x-y;if(t<0)continue;
		ans=(ans+C(x-1,i)*C(y-1,i)%p*C(n-x,t)%p*C(n-y,t))%p;
	}
	printf("%lld",ans);
	return 0;
}
```