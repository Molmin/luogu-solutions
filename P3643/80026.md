首先考虑最朴素的DP如何实现：

确定状态$f_{i,j}$为前$i$个学校，第$i$个学校派出$j$艘划艇的方案总数（规定$j$不为0，则第$i$个学校必须参赛）。转移方程也非常好写：

$$f_{i,j}=\sum_{h=0}^{i-1} \sum_{k=1}^{j-1} f_{h,k},j \in [a_i,b_i]$$

即，$f_{i,j}$可以由以下情况转移得到：在$i$前面派的最后一个学校编号为$h(h \leq i-1)$，且第$h$个学校派出了$k(k \leq j-1)$艘划艇的方案和。

但是这显然会炸裂：划艇数会达到$10^9$的量级，这非得把汉城短短的汉江全部塞满划艇不可，而且我们的空间时间也都炸裂了。但是我们注意到学校数目$n$很小，只有$500$，因而可以考虑离散化。

将每一个学校区间$[a_i,b_i]$处理为前闭后开区间$[a_i,b_i+1)$，然后将$2n$个端点进行离散化处理，得到至多$2n$个**互不相交**的区间。那么一个学校派出的划艇数目，就可以被唯一的划分到一个子区间中。

如：区间分别为$[1,3],[2,4],[1,5],[3,7]$，那么端点为$1,2,3,4,5,7$，子区间为$[1,2],[2,3],[3,4],[4,5],[5,7]$。对第三个学校$[1,5]$来说，它可以取得的区间编号为$1,2,3,4$。第四个学校区间编号为$3,4,5$。对于一个学校来说，它派出的划艇数目如果在某一个区间中，其实问题是本质等价的——如果落入$[5,7]$中，那么派出6和派出7对这个学校来说没有本质区别。

但是这么做就会出现一个问题：如果若干个学校出现在了同一个子区间怎么办？这个地方就是整个DP的核心。

我们重新刻画状态：$f_{i,j}$表示第$i$个学校派出的划艇数在第$j$个区间。由于我们的区间不包含$0$，因而第$i$个学校必定参赛。

为了解决上面新出现的问题，我们就要考虑有多少个学校和第$i$个学校同在第$j$个区间。但是这么好像也非常复杂：有些学校的$[a_i,b_i]$不一定覆盖第$j$个区间，也就是说不是我们想枚举多少就有多少的。于是我们刻画一个镜像状态：前$p$个学校不在第$j$个区间（即小于$j$区间）。后面这种数目$m$可以通过计算出来。

因而我们成功的将前面的$i-1$个学校划分成了两部分：前面$p$个学校不在$j$区间，后面的$m$个学校同第$i$个一样，都在$j$区间。显然，如果$p$不同，那么派出的种类一定不同，不会造成重复。

那么，如何转移呢？

对于前面的$p$个学校的数目，这个问题与当前大问题本质相同，因而可以直接使用$f_{p,k}$——前面$p$个学校，最后一个学校所在区间在第$k(k\leq j-1)$个区间的数目。因而第一部分的数目就是$\displaystyle \sum_{k=1}^{j-1}f_{p,k} $——$k$需要枚举，因为任意的$k$都存在满足条件的数目。第二部分，对于和第$i$个学校派出数目区间一样的$m$个学校，这部分种类数如何计算？

将问题用另一种方式呈现：在$[0,len]$区间中取$m$个数，使得非零数单增的方案总数。

接用sky_of_war大佬的证明想法：首先在$[1,len]$个数中任取$m$个数，方案总数为$C_{len}^{m}$——只关心选了那些，排列是唯一的。之后考虑下面这个序列，由前面$m$个$0$和$1,2,3……,len$所组成。在这个序列中任取$m$个数，同理可得方案总数为$C_{len+m}^{m}$。而且这个方案与原问题方案是一一对应的——前面取$0$的位置对应不参赛的学校，后面取的地方也与原来学校位置对应。因而答案为$C_{len+m}^{m}$。

由于第$i$个学校必须参赛，那么0的数量要少一个，即$C_{len+m-1}^{m}$种。

而且，前后两个子问题互不影响，因而满足乘法原理。对于一个$p$，对应的方案总数就应该为：$\displaystyle C_{len+m-1}^{m}\sum_{k=1}^{j-1}f_{p,k}$。考虑$p$也是要枚举的，所以：

$$f_{i,j}= \sum_{p=0}^{i-1} C_{len+m-1}^{m}\sum_{k=1}^{j-1}f_{p,k}$$

很显然可以发现，第一部分的答案可以作为一个整体$sum$：记$\displaystyle sum_{p,j}=\sum_{k=1}^{j-1}f_{p,k}$，因而原式化简为：

$$f_{i,j}= \sum_{p=0}^{i-1} C_{len+m-1}^{m}sum_{p,j}$$

总复杂度$O(n^3)$。

放上核心代码：

```cpp
    c[0] = 1;
    g[0] = 1;//即sum数组
    for (int j = 1; j < tot;j++)//tot为总的端点（区间）个数
    {
        long long len = num[j + 1] - num[j];
        for (int i = 1; i <= n;i++)
            c[i] = c[i - 1] * (long long)(i + len - 1) % mod * inv[i] % mod;//提前算好组合数。由于几个亿的组合数显然没办法递推，只能用带乘除的递推。由于在同一层循环中下标恒一样，c[i]表示上标为i的组合数。
        for (int i = n; i >= 0;i--)//此处使用了省空间的写法。考虑递推式中，第i行的信息只从i-1行获得，因而可以类比背包的省空间写法，倒推来压缩空间。
            if(a[i] <= j && j + 1 <= b[i])
            {
                long long C = c[1], f = 0;
                int m = 1;//m为满足条件的个数。由于是从后往前的枚举，所以m单调递增。每碰到一个合法的p，m就要自增
                for (int p = i - 1; p >= 0;p--)
                {
                    f = (f + C * g[p] % mod) % mod;
                    if(a[p] <= j && j + 1 <= b[p])
                        C = c[++m];//C为组合数，与m相绑定
                }
                g[i] = (g[i] + f) % mod;
            }
    }
    long long ans = 0;//ans统计答案。显然答案可以从所有的g中出现。
    for(int i = 1; i <= n; i++)
        ans = (ans + g[i]) % mod;
```
