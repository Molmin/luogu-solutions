这道题比较水，思路十分简单，用一个前缀和进行模拟即可AC。

首先定义一个数组为s，例如:s[i]表示从第1个输入的数到第i个输入的数之和。

接着就从1到n-1开始枚举，如果s[i]它等于第i项后面数字之和（第i项后面数字之和就是s[n]-s[i],这其实是前缀和中一个重要的思想，大家可以想想为什么），那么答案就加一。

最后即可输出计算的结果。

如果不用前缀和每次直接暴力求和，复杂度为O(n^2)，而用前缀和复杂度为O(n)。

下面是一段非常简短的代码（一共只有24行）。

```cpp
#include <iostream>//头文件 
using namespace std;//名字空间 
int s[110000];//定义前缀和数组 
int main()
{
	int n;
	cin>>n;//读入n 
	for(int i=1; i<=n; i++)
	{
		int a;
		cin>>a;
		s[i]=s[i-1]+a;//从第1项到第i项之和=第1项到第i-1项之和+第i项元素 
	}
	int ans=0;//初始ans为0 
	for(int i=1; i<=n-1; i++)//注意，i要从1遍历到n-1 
	{
		if(s[i]==s[n]-s[i])//如果第1项到第i项之和=第i项后面数字之和
		{
			ans++;//ans加一 
		}
	}
	cout<<ans;//输出ans 
	return 0;//结束程序 
}
```


