**2020年2月14日更新：修正题解排版**

----------

看到要求出所有的方案，就想到能切割的点不止一个。这时，就可以通过**枚举**切割点，进而得到全部分割的可能方案，然后判断十分合法。最后统计出合法方案的数量即可。

再看题目，可得：当分割成的两个部分的数字之和相等时，此分割方案合法。

如果枚举出分割点后再去逐个求和，最终会使时间复杂度为 $O(n^2)$。对于此题的数据范围 $(1 \le n \le 10^5)$，这样的做法是过不了的。怎么办？

**可以预处理啊！**

我们可以用预处理前缀和来解决问题。我们开一个数组 $s$，$s_{i,0}$ 表示 $[1,i]$ 之间所有数字的和，$s_{i,1}$ 表示 $[i,n]$ 之间所有数字的和。这样，当枚举出切割点 $f$ 时，只需要判断 $s_{f,0}=s_{f+1,1}$ 是否成立即可。

时间复杂度&实现流程梳理：

1. 用 $O(n)$ 把 $s$ 数组全部预处理出来；
2. 枚举切割点。复杂度 $O(n)$；
3. 每次检验枚举出来的切割点方案是否合法，如果合法，统计入变量 $\texttt{ans}$ 中。复杂度 $O(1)$；
4. 输出 $\texttt{ans}$ 的值，总时间复杂度为 $O(n)$。

以下是代码：

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
int main()
{
    int n,ans=0;
	scanf("%d",&n);
    int a[n+2],s[n+2][2];
    memset(s,0,sizeof(s));
  //s数组全部设为0
    for(int i=1;i<=n;i++)
        scanf("%d",&a[i]);
    //读入数列
    for(int i=1,j=n;i<=n&&j>=1;i++,j--){
        s[i][0]=s[i-1][0]+a[i];
        s[j][1]=s[j+1][1]+a[j];
    }//对于s数组的预处理（标准的前缀和操作）
  //以上为数据读入与预处理部分
  
  //以下为数据处理和输出部分
    for(int f=1;f<n;f++)  //枚举切割点
        if(s[f][0]==s[f+1][1])
            ans++;   //找到一个合法方案
    printf("%d",ans);   //输出合法方案数
	return 0;
}
```
