**upd：修正部分公式错误。**

**upd：添加结论的证明。**

验题人题解。

## A 潇湘の雨

#### Sol

考虑一次遍历是 $(2n)^2$ 的，所以若遍历 $k$ 次，那么是

$$\left\lfloor\dfrac{k}{(2n)^2}\right\rfloor$$

轮再加上一些点。

不难发现还剩

$$\begin{aligned}&~k\mod (2n)^2\\=&~k-k\times\left\lfloor\dfrac{k}{(2n)^2}\right\rfloor\end{aligned}$$

个点。

那么既然我们可以找每个 $(x,y)$ 的下一个点，$<(2n)^2$ 个点是不需要考虑的。

据此答案即为

$$\left\lfloor\dfrac{k}{(2n)^2}\right\rfloor$$

#### std

```cpp
signed main(){
	int n = init(), k = init();
	print(k / (n * n * 4));
}
```

#### 尾声

发现大家的题解都没有提到一个结论：

> 任意一个 $(2n)\times(2n)$ 的方阵，一定存在一种遍历方式可以 **循环遍历**。

这个结论我可以简单地证明一下：

考虑从 $(1,n)$ 位置开始，先向左到 $(1,1)$，再向下到 $(1,2)$，再向右到 $(2,n)$，然后遍历完整个左半边之后，再去蛇形遍历右半边。

举一个 $n=2$ 的例子：

![](https://cdn.luogu.com.cn/upload/image_hosting/f0jpvgn6.png)

按照这种遍历方式，我每次取 $\color{red}\text{დ}$ 字符的后一个位置，一定能保证最后一轮除非恰好满足 $(2n)^2=k$ 否则一定不经过 $\color{red}\text{დ}$。

举个例子，如果 $\color{red}\text{დ}$ 在 $(1,2)$，那我就选 $(1,1)$，我先按照这个顺序遍历掉剩下的 $15$ 个格子，再去走 $(1,1)$，一定最优。

如果 $\color{red}\text{დ}$ 在 $(4,4)$，那我就选 $(3,4)$，每次都选 $\color{red}\text{დ}$ 位置的下一个格子，这样就证明出这个结论了。

这个结论才是我们命制这道题目的原意，好像大多数题解从结论出发，忽略了这个模型的证明，令人感到遗憾。