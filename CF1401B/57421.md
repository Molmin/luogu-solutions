先单独考虑序列的 $c$ 的第 $i$ 个位置。我们根据 $c_i$ 的产生方法，可以推断出以下三点：

- $c_i$ 能增加最终答案，**当且仅当 $a_i=2,b_i=1$ 时**。此时 $c_i$ 值为 $2$，会使最终答案增加 $2$。
- $c_i$ 会减少最终答案，**当且仅当 $a_i=1,b_i=2$ 时**。此时 $c_i$ 值为 $-2$，会使最终答案减少 $2$。
- 对于其它情况，$c_i$ **最终的值都是 $0$**。

题目要求 $\sum_{i=1}^{n}c_i$ 的**最大值**，我们就要使序列 $c$ 上能增加最终答案的位置尽可能多，能减少最终答案的位置尽可能少。于是我们又得出三条处理答案的规则：

- 考虑序列 $a$ 中 $2$ 数量和序列 $b$ 中 $1$ 的数量，尽可能地增加答案。
- 考虑序列 $a$ 中剩下的 $2$ 和 $0$ 的数量，以及序列 $b$ 中 $2$ 的数量，尽可能消掉序列 $b$ 中的 $2$。
- 考虑完上述两点后，由于序列 $c$ 的其它位置都会变成 $0$ ，因此不考虑剩下的其它数字。

由以上两条规则，我们得到了最终的代码：

```cpp
#include<iostream>
#include<cstdio>
#define ll long long
#define rgt register int
using namespace std;
int main(){
	ll test,a[3],b[3],ans;
	scanf("%lld",&test);
	while(test--){
    
		for(rgt i=0;i<3;i++) //读入数据
			scanf("%lld",&a[i]);
		for(rgt i=0;i<3;i++)
			scanf("%lld",&b[i]);
            
		ans=0;
     //计算序列 c 中增加答案的增加量
		if(a[2]>b[1]){
			ans+=b[1]*2;
			a[2]-=b[1];
			b[1]=0;
		}else{
			ans+=a[2]*2;
			b[1]-=a[2];
			a[2]=0;
		}
        
     //用序列 a 中的 0 和 2 把序列 b 中的 2 消掉
		if(b[2]>a[0]){
			b[2]-=a[0];
			a[0]=0;
		}else{
			a[0]-=b[2];
			b[2]=0;
		}
		if(b[2]>a[2]){
			b[2]-=a[2];
			a[2]=0;
		}else{
			a[2]-=b[2];
			b[2]=0;
		}
        
		ans-=b[2]*2;  //消不掉的要从最终答案中扣掉这部分
        
		printf("%lld\n",ans);
	}
	return 0;
}
```
