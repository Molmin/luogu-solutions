这题是一道巧妙的bfs题。

首先，我们可以暴力枚举$n$的倍数。但是那太慢了。就算不会超时，也会爆long long。比如说下面这组数据

```
1437 9
0 2 3 4 5 6 7 8 9

```
答案是这样的：

Case 1: 111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111

你还敢再用暴力吗？

我们可以变换一下思路。

想象一下：在这种情况下，可以bfs构造符合条件的数，再判断他是否被$n$整除。可是这样的代码还是会爆炸。

实际上，这道题的正解是同余。

可以通过数组存储搜到的每一位数，再用数组模拟指针进行输出。

我们还可以假设有两个数$x,y(x<y)$，并且$x \space mod \space n=y \space mod \space n$。假设一个数$k$能接到$x$和$y$的尾部，使得$x\space mod \space n=0$，那么显然$y\space mod \space n=0$。所以我们可以把$y$剪枝掉。同样地，我们可以把所有出现过的余数全部唯一地保留，剩下全部剪枝掉，这样状态数最多有$n$个，可以通过本题。

AC代码：
```cpp
#include <iostream>
#include <cmath>
#include <algorithm>
#include <string>
#include <cstring>
#include <queue>
using namespace std;
int q[100005];//人工队列
int pt[100005],sz[100005];//指向父节点的指针和添加上去的数
bool y[10005];
int f[15];//不允许使用哪些数
long long n,m,ans;
int i,j,k;
void print(int x){//输出解
    if(pt[x]!=x)print(pt[x]);
    putchar(sz[x]+'0');
}
void bfs(){
    int i,a;
    int h1=0,t1=1;
    for(i=1;i<10;i++){//压入1-9中合法的节点
        if(!f[i]){
            h1++;
            q[h1]=i%n;
            pt[h1]=h1;
            sz[h1]=i;
        }
    }
    while(h1-t1>=0){//bfs
        a=q[t1];
        if(a==0){//如果得到解
            print(t1);//输出并返回
            cout<<endl;
            return;
        }
        if(!y[a])y[a]=true;//判断这个数是否同余，如果跟以前的相同则剪枝
        else{
            t1++;
            continue;
        }
        for(i=0;i<10;i++){
            if(!f[i]){//压入合法的节点
                h1++;
                q[h1]=(a*10+i)%n;
                pt[h1]=t1;
                sz[h1]=i;
            }
        }
        t1++;//pop
    }
    cout<<"-1"<<endl;
    return;
}
int main(){
    while(cin>>n){
        memset(y,0,sizeof(y));
        cin>>m;
        for(i=0;i<10;i++){
            f[i]=0;
        }
        for(i=0;i<m;i++){
            cin>>j;
            f[j]=1;
        }
        cout<<"Case "<<++k<<": ";
        bfs();
    }
    return 0;
}
```