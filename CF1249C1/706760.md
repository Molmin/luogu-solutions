（最优解第一页）

通过样例可知，首先所有 $3^{n}$ 都是好数，同时所有 $3n+2$ 都不是好数（因为它一定有两个相同的次幂）。

那么剩下的情况为 $3n $ 和 $3n+1$ 类。

我们如何判定 $3n $ 类的数呢？因为不能有相同的次幂，所以如果它一直减去小于它的好数，看最后的差，就可以判定它为 $3n+1$ 类，$3n+2$ 类或是好数。

接下来是 $3n+1$ 类。因为 $1$ 为 $3^{0}$，所以它相当于 $3n+3^{0}$，也就是$3n $ 类。

看起来似乎陷入了死循环，但是，如果接下来除以三后的结果为 $1$ ，那么它就和前面的重复了，变成了 $3n+2$ 类。

即：$3n+1$ 类的数，只能取一次 $1$，其后必须为 $3^{n}+3^{n-k1}+3^{n-k2}+\cdots\cdots$，不能再有一个 $3n+1$ 或 $3n+2$ 的数。

如 $13$，他是 $3n+1$ 类的数，取一次 $1$ 后变成 $12$，为 $3n $ 类，减去小于它的 $3^{n}$（此处为 $9$），变为 $3$。$3$ 是好数，$3+9=12$ 是好数，$1+3+9=13$ 也是好数。

从中可以发现规律：所有好数一定能由$3^{n}+3^{n-k1}+3^{n-k2}+\cdots\cdots$ 组成

也就是说，最后的好数为 $3^{n}$ 及其子集的总和。

代码实现：

先造出所有的好数，然后一个个读入，查找就可以了。

因为它只能为 $3n $ 和 $3n+1$ 类，同时数据范围给我们要小于等于 $19683$（即 $3^{10}$）,所以我们只需要把每一个 $9$ 位的$\verb!01!$串用三进制计算为十进制的值，最后加上 $19683$ 特判就可以了。

代码如下：

```
#include<bits/stdc++.h>
using namespace std;
int s[11]={0,1,3,9,27,81,243,729,2187,2187*3};
int r[1000]={};
int t[11];
int sjz(){
	int b=0;
	for(int i=1;i<10;i++){
		if(t[i]==1)b+=s[i];//本来r是存3的n次方的数组
	}
	return b;
}
int main(){
	//造数部分
    for(int i=1;i<512;i++){
    	int u=i;
		for(int j=1;j<10;j++){
			if(u%2==0){
				u=u/2;
				t[j]=0;
			}else{
				u=u/2;
			t[j]=1;
		}
	}
		r[i]=sjz();//计算长度为9的01串
	}
	r[512]=19683;//特判
   //查找部分
	int a;
	cin>>a;
	while(a--){
		int b;
		cin>>b;
		for(int i=0;;i++){
			if(r[i]>=b){
				cout<<r[i]<<endl;
				break;
			}
		}
	}
	return 0;
}

```
