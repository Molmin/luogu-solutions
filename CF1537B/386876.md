[题目链接：CF1537B Bad Boy](https://www.luogu.com.cn/problem/CF1537B)

## 题意解释

Riley 有一个 $n$ 行 $m$ 列的房间，他初始在房间内 $(i,j)$ 的位置，他要把两个悠悠球扔到房间的任意两个位置（两个位置可以相同），并且从初始位置出发捡回两个悠悠球后回到初始位置。

Riley 每次只会移动到相邻（有公共边）的格子，且整个过程中只会沿着当前状态的最短路径移动。求把悠悠球扔在哪两个位置可以使 Riley 需要移动的总距离最长。

## 结论

容易验证，将两个悠悠球扔在房间**对角线的两个角落**，Riley 需要移动的总距离一定最长。

以样例中的第 $3$ 组数据（$n=3$，$m=5$，$i=2$，$j=2$）为例：

其中蓝色点表示 Riley 的初始位置，两个红色点表示悠悠球的位置，绿色箭头表示 Riley 的一种移动的路线。

当把两个悠悠球分别扔在房间的左上角和右下角时，Riley 移动的路线长度**相当于在房间的外围走一圈**，此时路线最长：

![](https://cdn.luogu.com.cn/upload/image_hosting/f1piz3nx.png)

当把两个悠悠球分别扔在房间的左上角和右上角时，Riley 移动的路线长度显然小于上一种情况：

![](https://cdn.luogu.com.cn/upload/image_hosting/4ka3qhj3.png)

上述结论成立。

可以发现对于初始位置在房间外围的情况，会有其他的最优解，但此时将悠悠球扔在房间对角线的两个角落亦是一种最优解。

所以，你可以输出以下两种答案中的任意一种：

- 左上角和右下角，即 $(1,1)$ 和 $(n,m)$；
- 右上角和左下角，即 $(1,m)$ 和 $(n,1)$。

## 代码

```cpp
#include <cstdio>
int t,n,m,i,j,x1,y1,x2,y2,ans;
int main()
{
	scanf("%d",&t);
	while(t--)
	{
		scanf("%d%d%d%d",&n,&m,&i,&j);
		printf("%d %d %d %d\n",1,1,n,m);
	}
	return 0;
}
```

