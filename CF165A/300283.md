# 题意及注意点

- 在一个平面直角坐标系中，给定 $n$ 个点。求有多少个点满足在它的**正**上方，**正**下方，**正**左方，**正**右方都有点。

- 这里的正上方，正下方，正左方，正右方**不一定**是指相邻的 $4$ 个点，**只要为正方向都可以**。

- ~~从数据范围来看，~~ 简单的**模拟**就可以解决。

# 思路

- 在读入过后，~~窝掐指一算~~，我们可以发现数据范围支持暴力枚举，所以可以暴力**枚举**一遍，判断每个点是否在其他 $n-1$ 个数的正上方，正下方，正左方或正右方并记录下来。

- 接下来，就只有一步了：**将记录下来的信息进行处理**，判断它的正上方，正下方，正左方，正右方是否有点，如果都有就更新计数器。

- 再想一想，其实上面所说一步在**循环枚举的结尾**就可以完成，加一个判断语句，处理一下就好了。（具体操作可以见代码qwq）

# 代码


```cpp
#include<bits/stdc++.h>
using namespace std;
int i,j,n,x[100005],y[100005],flag,flag2,flag3,flag4,ans;
void qwq(int i,int j)//枚举判断
{
	if(x[i]<x[j]&&y[i]==y[j]) flag=1;
	if(x[i]>x[j]&&y[i]==y[j]) flag2=1;
	if(x[i]==x[j]&&y[i]>y[j]) flag3=1;
	if(x[i]==x[j]&&y[i]<y[j]) flag4=1;
}
int main()
{
	ios::sync_with_stdio(false);
	cin>>n;
	for(i=1;i<=n;i++) cin>>x[i]>>y[i];
	for(i=1;i<=n;i++)
	 {
	 	flag=flag2=flag3=flag4=0;
	 	for(j=1;j<=n;j++) qwq(i,j);
if(flag==1&&flag2==1&&flag3==1&&flag4==1) ans++;
	 }
	cout<<ans;
	return 0;
}
```

撒花完结awa