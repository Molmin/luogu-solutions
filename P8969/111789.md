大家好，我是根号数据结构爱好者。所以我用分块 A 了此题。

观察本题操作，发现区间加和单点查询都是可以简单地用分块来维护的。但是区间 popcnt 是个很新颖的东西。（也许是我题做得太少了吧。）赛时我以为是个什么神秘的 Trie 树然后一直想不出来。赛后听说 LHQing 用分块过了本题然后就滚去问他了。感谢 LHQing 大帝的耐心指导。

容易发现 $\text{popcnt}(x)<64$。由此我们可以得到一种做法——当某个块被整块 popcnt 后，将其去重只会剩下 $64$ 种以下的元素。把这些去重后的元素存起来，之后再对该块进行整块操作的时候，只需要对这几个元素进行修改即可。更详细地说，将第一次被整块 popcnt 后该块中每一个元素的值（下文称为代表值）与继续执行其它整块操作后的值（下文称为实际值）组成一组映射。修改时直接暴力枚举，查询时直接查询映射即可。

来分析一下复杂度。不考虑散块修改。当一个块被第一次整块 popcnt 前，整块加是单块 $O(1)$ 的。第一次被 popcnt 时单块复杂度是 $O\left(\sqrt n\right)$ 的，但这种情况只会发生 $O\left(\sqrt n\right)$ 次。之后执行的所有整块操作都是单块 $O\left(\log V\right)$ 的。因此总复杂度是 $O\left(m\sqrt n\log V\right)$ 。

然而散块修改会破坏映射的一一对应关系。换句话说，散块修改会使两个相同的代表值所对应的实际值不同。所以我们不得不用此块的映射更新自身所有元素，然后将映射清空再执行修改。之后如果要将这个块再整块 popcnt 的话就不得不 $O\left(\sqrt n\right)$ 地重构映射。这样时间复杂度不就不对了吗？

实际上我们可以用类似势能分析的方法来证明散块修改不会过大影响总复杂度。设每块初始时势能为 $1$，散块修改会使该块的势能 $+1$，整块 popcnt（重构映射）会使该块的势能 $-1$。容易发现，每次修改会使中间的所有整块势能 $-1$，只有两旁 $O(1)$ 个散块的势能会 $+1$。因此最大总势能就控制在 $O(m)$ 的级别。所以重构映射的总复杂度是 $O\left(m\sqrt n\right)$。

综上所述，总时间复杂度是 $O\left(m\sqrt n\log V\right)$（忽略低次项），空间复杂度是 $O\left(n+\sqrt n\log V\right)$。

PS：可以通过逐块处理来卡 cache。这样能使存映射的两个数组大小均为 64，可以卡进 cache。应该会使速度显著提升。（但是我没写不逐块处理的代码不知道具体提升了多少。）
