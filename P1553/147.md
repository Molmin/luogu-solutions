题解：

我真是非常佩服此题的作者，把原本的一题水题变得更水了。而且这个作者也可谓是勤勤恳恳，这题竟然有二十个测试点，发过题目的朋友都知道，出一道题最麻烦的就是写测试点了，所以在此表达对作者的真心敬佩。


**然后再说一下算法分析：其实我们只要拿出原本数字反转的题解，然后对于小数点，分号，百分号分别进行处理。而比较需要注意的就是数据为小数时的小数部分，需要单独提出来处理，因为对于一个整数，例如100，它是成立的，可是对于一个小数0.100就需要变成0.1，所以这一部分需单独处理。**

        
说了那么多，那么程序该如何实现呢？其实我们只要用字符串来读入，然后用pos找出符号，对于符号前与符号后的数进行处理。这里有几点需要注意：

**1.整数和百分数只需要做前部分的处理，不要把后一部分的处理也写出来了。**

2.在所给出的数据中，很有可能会有0的情况出现，对于这种情况，要十分注意，我栽在上面好多次了。

**3.这里讲一下0的情况的细节。首先除了小数的小数部分之外的数，绝对不可能以0开头，所以如果数据的第一个字符就是0，那么直接打0,。而小数的小数部分呢，它的开头可以是0，但结尾就绝对不可能是0，那么如果该数据的最后一个字符是0，也直接打0。**

  
**以下是个人的AC源程序，仅供参考。**

```delphi
var i,j,k,m,n,q,p:longint;
    s:string;
procedure fz1(s:string);{这里是对于普通的整数进行处理的过程}
begin
  if s[1]='0' then begin write('0');exit;end;{对于答案是0的情况的处理}
  j:=length(s);
  while s[j]='0' do dec(j);{去0}
  for i:=j downto 1 do{倒向输出即为答案}
    begin
      write(s[i]);
    end;
end;
procedure fz2(s:string);{对于小数的小数部分的特殊处理}
var i:longint;
begin
  j:=length(s);
  if s[j]='0' then begin write('0');exit;end;
  while s[j]='0' do dec(j);{去掉开头的0}
  k:=1;
  while s[k]='0' do inc(k);{去掉末尾的0}
  for i:=j downto k do
    begin
      write(s[i]);
    end;
end;
begin
  read(s);
  n:=length(s);
  m:=pos('.',s);
  if m>0 then begin{如果该数据是小数，那么处理}
    fz1(copy(s,1,m-1));{对该小数的整数部分处理}
    write('.');{在数据中间打出小数点}
    fz2(copy(s,m+1,n));{对于该小数的小数部分的处理}
    exit;{处理完后就退出}
  end;
  p:=pos('/',s);{以下处理大致与上同}
  if p>0 then begin
    fz1(copy(s,1,p-1));
    write('/');
    fz1(copy(s,p+1,n));
    exit;
  end;
  q:=pos('%',s);
  if q>0 then begin
    fz1(copy(s,1,q-1));{对于百分号的数据只需要处理一个数据}
    write('%');
    exit;
  end;
  fz1(s);{如果数据既不是小数、分数也不是百分数那么就直接进行整数的处理}
end.
```