读完题之后，发现最后终点站的车辆的顺序是任意的，于是在地推的过程中，不同车辆不需要有序的表示，只需记录是否相同即可。

用二进制数 $p$ 存储当前在最后 $P$ 辆进站的车，是否是最后一辆（即之后是否有同一辆车进站），如果 $p$ 的第 $P$ 位为 $1$，则新进站的车必须是 $P km$ 前进站的车，否则可以枚举新进站的车之前在哪一位，转移如下：
```cpp
for(p=1;p<p2;++p)
		if((pct[p]=pct[p-(p&-p)]+1)==K)
			mp[mt++]=p;
	for(i=0;i<mt;++i){
		p=mp[i];
		if((p>>P-1)&1)add(i,((p<<1)^(1<<P))|1);
			else for(w=0;w<P;++w)
				if((p>>w)&1)add(i,(p^(1<<w))<<1|1);
	}
```
发现可供转移的状态只有 ${P\choose K}\le{10\choose 5}=252$，所以离散化后可以接受 $O(k^3)$ 的转移，发现转移次数 $n$ 很大，于是使用矩阵快速幂，可以在 $O(k^3\log_2n)$ 的时间复杂度内完成本题。
```cpp
for(rs=at,n-=K+1;n;n>>=1,at=at*at)
		if(n&1)rs=rs*at;
	p=lower_bound(mp,mp+mt,(1<<K)-1)-mp;
	printf("%d\n",rs.a[p][p]);
```