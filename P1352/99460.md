## 树形$dp$:

众所周知，$dp$是一门玄学…

本篇主要浅显地讲解一下树形$dp$的特点及其相关应用

更多的内容需要大家自己去研究.

~~因为本人的水平实在有限~~

### 前置技能：
 
[树结构](https://baike.baidu.com/item/%E6%A0%91%E7%BB%93%E6%9E%84/3399688?fr=aladdin)

[动态规划](https://baike.baidu.com/item/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/529408?fr=aladdin)

### 树形$dp$定义：

树形动态规划问题可以分解成若干相互联系的阶段，在每一个阶段都要做出决策，全部过程的决

策是一个决策序列。要使整个活动的总体效果达到最优的问题，称为多阶段决策问题。

#### 无后效性：

无后效性是指如果在某个阶段上过程的状态已知，则从此阶段以后过程的发展变化仅与此阶段的状态有关，

而与过程在此阶段以前的阶段所经历过的状态无关。利用动态规划方法求解多阶段决策过程问题，过程的状

态必须具备无后效性。

#### 树形$dp$的特殊性质：

没有环，$dfs$是不会重复的，而且具有明显而又严格的层数关系。利用这一特性，我们可以很清晰地根据题目要求写出一个在树形结构上的记忆化搜索程序。

### 经典例题：

##### ~~（反正我老师说是经典例题，是不是我不清楚… 这个锅我不背 $qaq$)~~

#### 1. [HDU 1520 (Anniversary party)](http://acm.hdu.edu.cn/showproblem.php?pid=1520)
####    [P1352 没有上司的舞会](https://www.luogu.org/problemnew/show/P1352)

如果关系构成一条链,则$i$能不能参加舞会只和$i-1$有没有参加舞会有关。所以,可以用：

$f[i][0]$ 表示$i$不参加舞会的情况下，前i个人能达到的最大快乐指数和。

$f[i][1]$  表示$i$参加舞会的情况下，前i个人能达到的最大快乐指数和。

状态转移方程如下：

$f[i][0]=max{f[i-1][0],f[i-1][1]}$

对于本题，考虑每一棵子树，其根节点为$i$。

$i$能不能参加舞会只和$i$的孩子有没有参加舞会有关，和以$i$的孩子为根的子树如何决策无关。

所以用:

$f[i][0]$   表示i不参加舞会的情况下，以i为根的子树能达到的最大快乐指数和。

$f[i][1]$   表示i参加舞会的情况下，以i为根的子树能达到的最大快乐指数和。

则有：

$f[i][0]=∑max{f[j][0],f[j][1]} $

$f[i][1]=∑f[j][0]+R[i]$  

状态转移方程：

$f[i][0]=∑max{f[j][0],f[j][1]} $

$f[i][1]=∑f[j][0]+R[i]$ 

其中，$j$为$i$的儿子
	
#### 2. [HDU 2196 Computer](http://acm.hdu.edu.cn/showproblem.php?pid=2196)

由于题目告诉我们“每台新电脑和之前的某一台电脑连接”，这与每个非根节点只有一个父亲对应，所以得出：
       
所有电脑与之间的连接构成了一棵树。
       
问题就转化成了，给定一棵有边权的树，求第i台电脑与距离它最远的电脑之间的距离$Si$。

我们在做$dfs$的时候可以做一些改进：

当我们确定一个点为起点的时候，这棵树就成了一颗有根树，我们不妨记录以每个点$i$为根的子树中，距离该点的最长路$f[i]$，则有：

$f[i]=max(f[j]+len[i][j])$，其中j为i的孩子。
 
那么，我们同样能在$O(n)$的复杂度内得到根的答案$f[root]$。
     
这样做，我们还是需要枚举每个点作为根。

复杂度还是不变！

但是我们发现，改进后，我们在第一遍$dfs$后就得到了以每个点为根的子树中到该点的最长路，我们只差该点经过它父亲得到的最长路，离要求的答案仅有一步之遥！

显然，$f[root]$即为$root$的答案，我们接下来考虑$root$的孩子$i$，有人认为$i$的答案就是$max(f[i],f[root]+len[root][i])$。这是不对的，因为有可能$f[root]$是$root$经过$i$得到的，这样我们以i为起点的时候$f[root]+len[root][i]$相当于走了$i->root->i$这样的非法路径。

 但我们可以第一遍$dfs$的时候记录下每个点i为根的子树中，距离i的最长路、次长路分别为$f[i][0]$、$f[i][1]$（保证最长路和次长路经过i的两个不同的孩子）并记录对应的经过的孩子$g[i][0]$、$g[i][1]$。这样我们在考虑$root$的孩子$i$时有：
 
 如果$g[root][0]!=i$，$i$的答案就是
                 $max(f[i],f[root][0]+len[root][i])$；
 
 否则，$i$的答案就是
                 $max(f[i],f[root][1]+len[root][i])$，
 
 我们可以同时更新$f[i]$和$g[i]$，以便计算$i$的孩子的答案。
 
 可以发现我们在计算一个点$i$的答案时，必须要先知道它的父亲的答案。只要用$dfs$的顺序计算就可以了。
 
 这样，两遍$dfs$，每次转移都是$O(1)$，总复杂度$O(n)$。

### 最后的最后

还有两条大家感兴趣的可以自己去做一做。

[POJ 3107 Godfather](http://poj.org/problem?id=3107)

[POJ 1155 TELE](http://poj.org/problem?id=1155)