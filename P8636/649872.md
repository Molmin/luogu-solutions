## 思路
等比数列必然有一个首项，显然要先将等比数列排序之后两两相除，以此获得一个没有首项的序列。这里有一点需要注意，就是题目中有可能会出现两个一样的数字，这个时候相除答案会是 $1$，但是 $1$ 是所有正整数的最小公因数，显然不是我们要找的数字，所以读入数据的时候需要去重。

之后，获得了相邻两项的商。本来做到这里，我天真的以为只要对这些商求最大公因数就行了，事实上如果存在 $1$、$8$、$80$ 这样的序列，求商后得 $8$、$10$，如果简单得求最大公因数会得到错误答案 $8$。

一开始我也没考虑到，因为如果公比为 $8$，就无法从序列中得到由 $8$ 变为 $80$ 的情况。

这是为什么？本质上是因为没有没有考虑到公比之间的变化，那如何考虑公比之间的变化。以上面的数据举例，如果存在 $q$，则必然存在 $q^{n_1}=8$，$q^{n_2}=10$，如果考虑 $n_1$，$n_2$ 的存在性情况，也就是说需要满足 $q^{n_2-n_1}=\frac{4}{5}$，其中 $n_2-n_1$ 属于整数。相当于对商数列求最大公因数的时候，多了这一个条件就足够。

所以只需要在获得商数列的基础上，增加这些条件即可。这些条件的获得，直接通过对商数列的排序，然后对相邻的商进行相除即可。获得条件后，其实条件和商数列形式上是完全一样的，也就是这些数值需要出现在整个数列中。

所以我们通过在商数列后面追加这些数值即可。
## 代码
```python
def gcd(a, b):
    if b == 0:
        return a
    return gcd(b, a % b)

def lgcd(a, b):
	return [gcd(a[0],b[0]),gcd(a[1],b[1])]


while True:
	try:

		n = int(input())
		l = list(set(map(int, input().split())))
		l.sort()
		n = len(l)
		tl = []
		for i in range(n - 1):
			g = gcd(l[i], l[i + 1])
			tl.append((l[i + 1] // g, l[i] // g))

		tl=list(set(tl))
		tl.sort(key=lambda x:x[0]/x[1])
		n=len(tl)
		for i in range(n-1):
			tl.append((tl[i+1][0]/tl[i][0],tl[i+1][1]/tl[i][1]))


		g = tl[0]
		for i in tl:
			g = lgcd(g, i)

		print('%d/%d' % (g[0], g[1]))
	except:
		break


```