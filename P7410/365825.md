# 前言

提供一种较为容易理解的 $O(n^3)$ 做法。

# 题意

给你一张表格，求表格内有多少个子矩阵的最小值为 $100$。

# 思路

## Step 1

首先考虑 $O(n^4)$ 暴力方法。

令 $lie_i$ 为当前第 $i$ 列的最小值。

枚举上、下、左、右边界。先确定上、下边界，更新 $lie$ 数组，然后枚举左右边界，如果有最小值等于 $100$ 的，答案 $+1$；如果有最小值小于 $100$ 的，直接 `break` 跳出此次右边界循环。

## Step 2

其次考虑优化。

由于每次枚举左右边界都要找最小值（及等于 $100$ 的和小于 $100$ 的），可以先预处理出每一列向右边延伸到第一个等于 $100$ 的位置，及每一列向右边延伸到第一个小于 $100$ 的位置。（相当于处理右边界）

然后再从左边开始扫，如果能延伸到的第一个小于 $100$ 的位置要比第一个等于 $100$ 的位置远，就可以把答案加起来。

加起来？加什么呢？

由于我们枚举的是左边界，那么右边界最近必须到第一个等于 $100$ 的位置，最远到第一个小于 $100$ 的位置**之前**。对于答案来说，长度每增加 $1$，答案就加 $1$，故答案应该加的是第一个小于 $100$ 的位置减掉第一个等于 $100$ 的位置。

# $\texttt{AC Code}$

需要注意的是，题面已经提醒了要开 `long long`。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
int n, a[510][510], lie[510], eq[510], ls[510];
// lie -> 第 i 列最小值
// eq -> 每一列向右边延伸的第一个等于 100 的位置 
// ls -> 每一列向右边延伸的第一个小于 100 的位置 
ll ans;
int main() {
	scanf("%d", &n);
	for (int i = 1; i <= n; ++i)
		for (int j = 1; j <= n; ++j)
			scanf("%d", &a[i][j]);
	for (int i = 1; i <= n; ++i) {     // 上边界 
		for (int j = 1; j <= n; ++j) lie[j] = a[i][j];
		for (int j = i; j <= n; ++j) { // 下边界 
			for (int k = 1; k <= n; ++k) lie[k] = min(lie[k], a[j][k]);
			// 求每列最小值 
			eq[n + 1] = ls[n + 1] = n + 1; // 先做标记 
			for (int k = n; k; --k) {      // 因为是求向右延伸，故从右往前推 
				eq[k] = eq[k + 1];
				ls[k] = ls[k + 1];
				if (lie[k] == 100) eq[k] = k;
				if (lie[k] < 100) ls[k] = k;
			}
			for (int k = 1; k <= n; ++k)
				if (ls[k] > eq[k]) ans += ls[k] - eq[k]; // 累加答案 
		}
	}
	printf("%lld", ans);
	return 0;
} 
```

最后，祝 **CSP2022 R2 RP += INF**！！