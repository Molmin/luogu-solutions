#### 题目大意


------------
求最小值为 $100$ 的矩形个数。

#### 思路分析

------------
只要知道一个矩阵的左上角和右下角的坐标就可以确定该矩阵，故考虑枚举所有的矩阵并一一进行检查。

这样做的复杂度是 $\Theta(n^6)$ 显然不可行。

首先考虑对于检查的复杂度进行优化，由于一个矩形是否可行只与它的最小值有关，故考虑在输入的时候将所有等于 $100$ 的数按照原数储存，所有大于 $100$ 的数当做 $0$，所有小于 $100$ 的数当做无穷小。使用二维前缀和优化，如果一个矩阵的和小于 $0$ 说明一定有小于 $100$ 的值存在，故不满足条件，由于一个满足条件的矩阵中不一定只有一个 $100$，所以答案就是和大于等于 $100$ 的矩阵个数。

此时的时间复杂度为 $\Theta(n^4)$，加速后勉强可以通过第五个测试点。

接下来考虑如何优化枚举矩阵的边界。

首先考虑在序列上的操作。

记录序列中小于 $100$ 的数的位置，这些数将这个序列分成了若干个不相关的区间，对于每个这样的区间分别进行求解并将答案累加即可。

如果这段区间中没有 $100$，则这段区间对于答案的贡献是 $0$，如果有一个 $100$，则贡献为 $100$ 的位置到这段区间的首尾距离的乘积。

如果这段区间中有不止一个 $100$，如果仍按照上述对于一个 $100$ 的情况进行计算会出现重复的情况。

以两个 $100$ 的情况为例：

![1](https://cdn.luogu.com.cn/upload/image_hosting/xqert8s5.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

以左边的 $100$ 为最小值的矩阵左边界可以到这段区间的左边界，右边界可以到第二个 $100$，所以答案就是第一段区间长度和第二段区间长度的乘积，以右边的 $100$ 为最小值的矩阵的左边界可以到区间的左边界，右边界可以到区间的右边界，故答案为第一段区间长度和第三段区间长度的乘积和第二段区间长度和第三段区间长度的乘积的和，也就是第二个 $100$ 的左边的区间长度和右边的区间长度的乘积。

故可得一般情况下答案是所有 $100$ 到左边界的长度和到下一个 $100$ 的长度的乘积。

由此，只需枚举矩形的上下边界，此时只需要存下上边界到下边界这段中的最小值，此时的情况就是序列上的情况。

```cpp
int main(){
	int n = read();
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			a[i][j] = read();
		}
	}
	for(int i=1;i<=n;i++){
		for(int k=1;k<=n;k++){
			mn[k]=INF;
		}
		for(int j=i;j<=n;j++){
			int pos1 = 0 , pos2 = 0;
			for(int k=1;k<=n;k++){
				mn[k] = min(mn[k],a[j][k]);
			}
			for(int k=1;k<=n;k++){
				if(mn[k] < 100){
					if(pos2 > pos1){
						calc(pos1,pos2,k);
					}
					pos1 = k;
				}
				if(mn[k] == 100){
					if(pos2 > pos1){
						calc(pos1,pos2,k);
					}
					pos2 = k;
				}
			}
			if(pos2 > pos1){
				calc(pos1,pos2,n+1);
			}
		}
	}
	printf("%lld\n",ans);
	return 0;
}
```
