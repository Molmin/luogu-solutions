### 题目大意：
Valera写了一个排序的算法（伪代码）：
```
loop integer variable i from 1 to n - 1
    loop integer variable j from i to n - 1
        if (a[j] > a[j + 1]), then swap the values of elements a[j] and a[j + 1]
```
显然这是错误的……

给你一个 $n$ 表示数组的长度，
请你构造一组数据，
Hack掉他的算法。

如果无法Hack，就输出"-1"。

### 分析：
显然，一个标准的冒泡排序的第二重循环应该从 $1$ 开始。

那么这个算法就漏掉了第 $i$ 次排序后，
前 $i$ 项中可能出现的逆序对。

而如果长度小于等于 $2$ ，
则这个算法就不会漏掉任何逆序对，
所以 $n \leq 2$ 时，
这个算法时正确的。

为了在其它情况下卡掉它，
就需要构造数据，
使它漏掉一个或一些逆序对，

当 $n=3$ 时，

当且仅当第 $2$ 次循环后前 $2$ 项是逆序的，
这个算法才会出错。
为了让前 $2$ 项在第 $2$ 次循环后逆序，
只有这个数组： $3~2~1$ 
（算法结果： $2~1~3$ ），
即数组原本就有序的情况。

当 $n=4$ 时，

- 输入 $4~3~2~1$ ，
得到的结果是 $3~1~2~4$ 。

- 输入 $3~2~1~4$ ，
输出 $2~1~3~4$ 。

可以看出还有其它的方法可以使它出错,
但是逆序输出是最简单可靠的方法。

### 代码：
```cpp
//从99开始逆序，当然也可以用从其它的数开始
//但是题目限制 1<=a[i]<=100 所以起始的数不能太大，也不能太小 
#include<bits/stdc++.h>
using namespace std;
int main()
{
	int n;
	scanf("%d",&n);
	if(n<=2)
	{
		printf("-1\n");
		return 0;
	}
	for(int i=1;i<=n;i++)
	{
		printf("%d ",100-i);
	}
	return 0;
}
```

