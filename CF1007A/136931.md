### 知识点：贪心。

### 题意：

`有n个数，把它们重新排列，每一个位置相对，求排列之后的数比排列之前的数大的位置个数的最大值。`

### 基本思路：

先进行一轮排序。

然后对于每个位置，向后查找一个比这个大的数，那么就将这两个数搭配。

```cpp
	for(int i=0;i<n;i++)
	{
		for(int j=i+1;j<n;j++)//从后面算起
		{
			if(yuan[j]>yuan[i]&&used[j]==0)//used[j]用过了没，是不是大
			{
				used[j]=1;
				sum++;//累加
				break;
			}
		} 
	}
```

（这是第一版代码，完美展现了贪心思想，唯一的问题是超时）

那么怎么改进呢？实际上，你会发现$a[i+1]$必然大于等于$a[i]$；而如果$a[j]$不能和$a[i]$匹配，那么显然更不能和$a[i+1]$匹配。

比如说：现在有数组$a[6]=\{1,1,1,1,1,2\}$，你已经发现第四位的$1$已经不能和第二位搭配，那么第三位的$1$就更不可能和第四位搭配了。

所以，不需要从头开始匹配$a[j]$，直接继续即可。

秉持刚才的思路，下面是改进：

```cpp
	int j=0;
	for(int i=0;i<n-1&&j<n;i++)
	{
		j++;//将j向后累加，原因在上面
		if(yuan[j]>yuan[i])//代表可以匹配
		{
			sum++;
		}
		else i--;//相当于还是这个i，但是是下一个j。
	}
```

其他部分大概没有问题，以下是全部代码。

```cpp
#include<bits/stdc++.h>
using namespace std;
int yuan[100005],sum;
int main()
{
	int n;
	cin>>n;
	for(int i=0;i<n;i++)
	{
		cin>>yuan[i];
	}
	sort(yuan,yuan+n);//从小到大排序，贪心的基本操作 
	int j=0;
	for(int i=0;i<n-1&&j<n;i++)
	{
		j++;
		if(yuan[j]>yuan[i])
		{
			sum++;
		}
		else i--;
	}//循环内内容已经解释。 
	cout<<sum;
	return 0;
}
```
