这题是一道贪心题目，贪心就是要将问题的解推向最优，虽然贪心有时有弊端，不一定能求出~~最优解~~，但是面对这道题还是绰绰有余的。

题目大意：将 $n$ 个数重新排列，求排序之后比原来位置数大位置个数的最大值。

我的思路是可以先排序一下，然后从一个位置查他后面的几个比他大的数字位置，把原来的数和现在正在查询的数匹配一下，这就是排序的意义了，因为排序之后，序列可以保证他是从小到大的。

具体不好说，先上核心代码：
```c
for (int i = 1;i < n;++ i){
    cnt++;
    if(cnt > n) break;
    if (a[i] < a[cnt]) ans++;
    else i--;
}
```
$cnt$ 就是每次都在向后找，$i$ 是在便利整个循环，如果现在的数比之前的那个数大，那么这就是正确的位置，统计的 $ans$ 便加一。如果没有 $i$ 就要 $-1$，重新查询。 

总代码：
```c
#include<bits/stdc++.h>
using namespace std;
int n,a[100005],ans,cnt = 1;
int main (){
    cin >> n;
    for (int i = 1;i <= n;i++){
		cin >> a[i];
	}
    sort(a + 1,a + n + 1);
    for (int i = 1;i < n;++ i){
        cnt++;
        if(cnt > n) break;
        if (a[i] < a[cnt]) ans++;
        else i--;
    }
    cout<<ans;
    return 0;
} 
```
长度不长，实现比较容易。