### 我们需要分析在什么时候会叫，事实上并没有想象中的那么简单。

首先，如果我们在它第一次叫之前就把它吃了，我们一定是输出"NO"

其次，我们再对题意进行**分析**

我们发现题目只给了三个值，所以我们需要充分利用这三个值。

那么，这三个值有什么意义呢？

首先我们考虑**枚举**菠萝叫的时间，为
	$$t+1,\ t+s,\ t+s+1,\ t+2s,\ ...\ ...$$

在提交了一次代码后，我们发现这样枚举是会超时的

所以我们要**优化**我们的算法，考虑题目要让我们求的其实就是$x=k*s+t$或$x=k*s+1$ $\ \ \ 0\le k < +\infty$

那么新的算法就出来了，枚举k！

但是上面的算法会被下面的数据卡掉

>5 1 1000000000

所以算法需要**继续优化**

然后我们要**化开第一个式子**
	$$x=k*s+t$$
    $$x-t=k*s+t-t$$
    $$x-t=k*s$$

同理第二个式子
	$$x=k*s+t+1$$
    $$x-1=k*s+t+1-1$$
    $$x-t-1=k*s+t-t$$
    $$x-t-1=k*s$$
    
当式子化成上面的样子之后，我们的问题基本上就解决了

学过取模的同学一定都知道，$a=b*c\ \ \leftrightarrow\ \ a\%c=0$

所以我们就可以把枚举k的步骤去掉，考虑直接求取模后是否等于零

然而把代码敲完后，我们发现自己连样例都过不了，为什么呢？

这就是这道题最难的地方，我们需要有足够的英文水平**略过翻译**，看到原题中的菠萝并不会在第t+1秒叫，才能通过此题。

>综上，此题将枚举，优化，数论，翻译四种算法巧妙结合在一起，无疑是善良的出题人无私的馈赠，大量精心结合的算法，涵盖了OI中绝大多数的题目组合。你可以利用这道题，对自己的知识点进行全面的盘查，让你脑海中的漏洞无处遁形。我相信，这道美妙的题目，可以给拼搏于进入国家集训队的逐梦之路上的你，提供一个有力的援助。

其实这道题还可以用**查看讨论法**通过此题，在这里就不一一介绍了

```cpp
#include<cstdio>
using namespace std;
int t,s,x;
int main(){
	scanf("%d%d%d",&t,&s,&x);
	if(x<t){puts("NO");return 0;}
	if((!((x-t)%s)||!((x-t-1)%s))&&x!=t+1)puts("YES");
	else puts("NO");
 return 0;
}
```