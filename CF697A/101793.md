不会用latex，还望各位见谅

做法似乎看起来和别的大佬的不大一样，但好像本质是一样的？

开讲。

题目给出了t,t+1,t+s,t+s+1,t+2s,t+2s+1···t+ks,t+ks+1(k∈N*)这样一个数列，我们把它据+1或者没有+1（奇数或偶数）分为两个数列：

**{an}**：an=t+ns
**{bn}**：bn=t+ns+1

显然，如果x时刻菠萝会叫，x**必然属于{an}、{bn}之一**

之后就是枚举了。

但是题目的数据范围那么大，一路枚举到1e9肯定超时，所以我们需要一些优化。

很容易看出，~~因为ted没有储存粮食的习惯~~，x时刻以后的任何时刻都对答案无意义，所以枚举到x/s+1即可。为什么+1呢？大概防止翻车咯~~~我倒确实不知道为什么+1反正过了就好了~~

弄完这些，还要注意一个特判，就是在t时刻如果菠萝叫了ted也是吃不了菠萝的，所以如果t=x就直接输出YES。

下面上代码

```cpp
#include<iostream>
using namespace std;
int t,s,x;
int main()
{
	cin>>t>>s>>x;
	if(x==t)   //特判
	{
		cout<<"YES";
		return 0;
	}
	for(int i=1;i<=x/s+1;i++)   //枚举部分
	{
		if(x==t+s*i||x==t+s*i+1)  //属于{an}或{bn}中的任何一个
		{
			cout<<"YES";
			return 0;
		}
	}
	cout<<"NO";
	return 0;
}
```

~~我这好像是全场跑得最慢的代码~~