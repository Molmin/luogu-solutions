~~没参加省选，做一道最简单的题吧~~

我们先考虑，如果整个序列全是正数，策略是什么。答案是：从左到右（题目这么要求）两两合并，而不是一股脑全部加起来。为啥？你看，我们如果每次只取两个数，那么第一个数被加了 $n$ 次，第二个数被加了 $n-1$ 次，…，第 $n$ 个数被加了 $n-(n-1)=1$ 次，又因为这个加的次数是随每次取的数的个数的递增而递增的，所以相比之一股脑全取（每个数被加了一次），显然是更优的，且是最优的策略。

对于这道题而言，我们沿用这种“单次少取”的策略，然而我们又不想让我们本次得到的这个加和成为负数从而使结果变小，所以我们的策略就是，每次从当前的数列中从左到右取尽量少（但是要大于等于 2）的数，使得加和为正。

代码实现如下（含注释）。
```
#include <iostream>
using namespace std;
typedef long long ll;
ll a[100010];  //须用长整型
int main()
{
    int n;
    //读入
    cin>>n;
    for(int i=1;i<=n;i++) cin>>a[i];
    
    //ans为答案，sum为这一次的加和
    ll ans=0,sum=a[1];
    for(int i=1,j=1;i<n;i=j-1){
        sum+=a[i+1];  //我们只需要在上一次的结果上操作即可
        //你可能会问，为什么上面的sum+=a[i+1]不直接放到循环里面呢
        //其实，我们的循环不一定会执行，而上面这个必须要执行（因为至少要取两个数）
        for(j=i+2;j<=n && sum<=0;j++) sum+=a[j]; //一旦sum>0就跳出
        if(sum<=0) break; //后面怎么加也不能为正了，断定他没救了
        ans+=sum;
    }
    cout<<ans<<endl;
    return 0;
}
```