[题目传送门](https://www.luogu.com.cn/problem/P6625)

首先，面对形如要求计算$\sum_{j=1}^{i}a_j$的问题，我们要想到前缀和。

什么是前缀和呢？其实就是预先处理出$\sum_{j=1}^{i}a_j$存入数组S,使得$S_i$等于$\sum_{j=1}^{i}a_j$。不难发现，$\sum_{a}^{b}a_j=S_b-S_a$。

但是，这样计算前缀和，每计算一个$S_i$的时间复杂度为$O(n)$，总体预处理时间复杂度为$O(n^2)$，~~甚至比暴力还慢~~，如何更快的计算呢？

首先，看一个公式：$\sum_{i=1}^{b}a_i=\sum_{i=1}^{b-1}a_i+a_b$。根据前缀和的定义，我们可以得出：$S_i=S_{i-1}+a_i$，由此，我们可以得出前缀和的简便计算方式

```cpp
for(int i=1;i<=n;i++){
	scanf("%d",&a[i]);
	s[i]=s[i-1]+a[i];
}
```


利用这一特性，我们可以解出[这道题](https://www.luogu.com.cn/problem/P1115)。

然后，我们掌握了这一知识后，就可以开始做这道~~良心出题人的馈赠~~了

每次替换对答案的贡献等于最前面一张卡牌上的数值加替换的一段中其他卡牌的数值，而第一张卡牌上的数值等于之前被替换掉的卡牌数值之和，我们可以发现，这个值就等于原数组中本轮要替换的末尾元素下标的前缀和

而我们想让这个值尽量大，不难看出，每一次的选择无后效性，故这个值只要为正数就可以选择

上代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[100005],s[100005],n;
long long ans;
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		scanf("%d",&a[i]);
		s[i]=s[i-1]+a[i];
	}
	for(int i=2;i<=n;i++){
		ans+=max(0,s[i]);

	}
	cout<<ans<<endl;
} 
```
