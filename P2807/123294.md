#### 个人认为，本题找规律有更好的办法

思路：把大三角形看成等边三角形，先考虑正着放的，再考虑倒着放的

我们把底边在第 $i$ 条线段上的三角形成为在第 $i$ 层

#### 正着放（边长为 $i$）：

三角形个数最少的层数：第 $i$ 层，共有 $1$ 个

三角形个数最多的层数：第 $n$ 层，共有 $n-k+1$ 个

正着放**边长为 $i$** 的小三角形有 $1+2+……+(n-i+1)$ 个

边长 $i$ 的范围：$1,2,3……n$

#### 倒着放（边长为 $j$ ）：

三角形个数最少的层数：第 $j$ 层，共有一个

三角形个数最多的层数：第 $n-j$ 层：共有 $(n-j)-j+1$ 个

倒着放**边长为$j$** 的小三角形有 $1+2+……+(n-2*j+1)$个

边长 $j$ 的范围：$1,2,3……n/2,\ n/2$向下取整 （因为是倒着放的，所以最底下要留出一半的高度）

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int t,n,f[550],ans;//f[x]为从1加到x的和
int main()
{
	cin>>t;
	for(int x=1;x<=500;x++)f[x]=f[x-1]+x;//预处理 
	while(t-->0){
		cin>>n,ans=0;//ans要清零
		for(int i=1;i<=n;i++)ans+=f[n-i+1];//计算正着的三角形个数
		for(int j=1;j<=n/2;j++)ans+=f[n-j*2+1];//计算倒着的三角形个数
		cout<<ans<<endl;
	}
	return 0;
}
```

如果有错误请私信我，我会及时改正！

$\small{\text{Upd 2019.8.17 美化文章，修改部分文字，添加Latex}}$