西格玛 Σ 这种东西对于一些人（比如我）来说显然太高深了……但谁说一定要用了呢？


我们先来看正着的三角形（表示懒得做图，实在不行可以看一下其他发布者的图或自己画一幅）

```cpp
n=1   1;
n=2   4(=1+  1+2);
n=3   10(=1+  1+2+  1+2+3);
n=4   20(=1+  1+2+  1+2+3+  1+2+3+4);
n=5   35;
n=6   56;
```
…………
so
规律是这样的：

ans=1+(1+2)+(1+2+3)+(1+2+3+4)+(1+2+3+4+5)…………+(1+2+3+...+n)=(n+1)\*n/2+n\*(n-1)/2+(n-1)\*(n-2)/2;

-------------------------------------------------------------------------------------------------------

然后是倒着的：

```cpp
n=1     0;
n=2     1;
n=3     3(=1+2);
n=4     7(=1+2+3+ 1);
n=5     13(=1+2+3+4+ 1+2);
n=6     22(=1+2+3+4+5+ 1+2+3+ 1);
n=7     34(=1+2+3+4+5+6+ 1+2+3+4+ 1+2);
```
然后规律也就出来,这个用通项公式还真不太好写，所以直接上代码（当然你用西格玛就很好表示了）。
```cpp
for(k=0;n-k>=2;k+=2)
        ans+=(n-k)*(n-k-1);
    ans/=2;
```
-------------------------------------------------------------------------------------------------------

最后，把正着的和倒着的加起来就是最终的Answer；



```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int main()
{
    long long ans = 0 , k , n , t;
    cin>>t;
    while(t>0)
    {
    ans=0; 
    scanf("%lld",&n);
    for(k=0;n-k!=0;k++)
        ans+=(n-k)*(n-k+1);
    for(k=0;n-k>=2;k+=2)
        ans+=(n-k)*(n-k-1);
    ans/=2;
    printf("%lld\n",ans);
    t--;
    }
    return 0;
}
```