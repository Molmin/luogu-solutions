#### CF273E Dima and Game

考虑对于单独一个$(l,r)$，实际上是一个两端往中间并拢的过程。

因此$(l,r)$的先手胜负状态只与$r-l$的大小有关。

设$r-l$的值为$x$，则$x$可以转移到的状态为$\lfloor \frac{x}{3}\rfloor$和$x-\lfloor \frac{x}{3}\rfloor$。

然而这题的$P$开到了$10^9$，因此直接对每个状态求$SG$会歇逼。

手玩即可发现，状态的$SG$呈一段一段的分布，而这个段数并不多，经过打表可以发现，段数的总数，只有$100$段左右。

于是考虑把这些状态和其范围打表记录。

设$f_{i,j}$表示考虑取了$i$个，目前的$SG$状态是$j$的方案数。

转移就枚举第$i$位是$0/1/2$即可，注意因为$2 \otimes 1 =3$,因此第二维需要记录四个状态。

根据$SG$函数的定义，$f_{n,1}+f_{n,2}+f_{n,3}$即为答案。



```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#define N 1200005
#define int long long
#define mod 1000000007 
using namespace std;
int read()
{
	int x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){x=(x<<3)+(x<<1)+(ch^48);ch=getchar();}
	return x*f;
}
int pos[110]={1,3,4,5,7,9,13,15,19,27,39,40,57,58,81,85,120,121,174,179,255,260,363,382,537,544,780,805,1146,1169,1632,1718,2415,2447,3507,3622,5154,5260,7341,7730,10866,11011,15780,16298,23190,23669,33033,34784,48894,49549,71007,73340,104352,106510,148647,156527,220020,222970,319530,330029,469581,479294,668910,704371,990087,1003364,1437882,1485130,2113113,2156822,3010092,3169669,4455390,4515137,6470466,6683084,9509007,9705698,13545411,14263510,20049252,20318116,29117094,30073877,42790530,43675640,60954348,64185794,90221631,91431521,131026920,135332446,192557382,196540379,274294563,288836072,405997338,411441844,589621137,608996006,866508216,884431705,1000000001};
int sg[110]={0,1,2,1,2,0,1,2,0,1,2,0,2,1,2,0,2,1,2,0,2,1,2,0,2,1,2,0,2,1,2,0,2,1,2,0,2,1,2,0,2,1,2,0,2,1,2,0,2,1,2,0,2,1,2,0,2,1,2,0,2,1,2,0,2,1,2,0,2,1,2,0,2,1,2,0,2,1,2,0,2,1,2,0,2,1,2,0,2,1,2,0,2,1,2,0,2,1,2,0,2,1};
int n,p,g[N],f[N][4];
int query(int l,int r)
{
	l=p-l;r=p-r;
	return (l+r)*(l-r+1)/2%mod; 
}
signed main()
{
	n=read();p=read();
	for(int i=0;i<102;i++)
	{
		if(pos[i]>p)break;
		int l=pos[i],r=min(p,pos[i+1]-1);
		g[sg[i]]+=query(l,r);
		g[sg[i]]%=mod;
	}
	f[0][0]=1; 
	for(int i=1;i<=n;i++)
	{
		for(int j=0;j<4;j++)
		{
			for(int k=0;k<=2;k++)
			{
				f[i][j^k]+=f[i-1][j]*g[k]%mod;
				f[i][j^k]%=mod;
			}
		}
	}
	printf("%lld\n",(f[n][1]+f[n][2]+f[n][3])%mod);
	return 0;
}
```

