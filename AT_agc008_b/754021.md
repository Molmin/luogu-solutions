**思路：**

结论：除了一组连续的 $k$ 个位置，其他地方上的颜色是可以让我们随便填的。

举个栗子：我们设 $n=5,k=3$。

初始时：

```白白白白白```

如果要只把第 $4$ 个涂黑，首先需要把 $2,3,4$ 都涂了：

```白黑黑黑白```

然后把 $1,2,3$ 都涂成白色，覆盖掉：

```白白白黑白```

这样就成功了！多做几次，我们可以发现，通过覆盖的原理，除了那连续的会颜色一致外，其他地方想是啥颜色就可以是啥颜色。

---

如此，解法也就呼之欲出了。

我们遍历每一个长度为 $k$ 的区间，如果这一段的和比 $0$ 小，就不选涂白，否则就涂黑记录答案。不在这个区间内的可以乱涂，通过贪心的想法，不是负数就涂黑加进来，是负数就涂白不要了，这么做显然是最优的。

但如果每一种区间位置都要遍历一遍数组求答案，结局必然是会 T 的飞起，需要进行优化。

求区间和的值……这简直就是为了前缀和量身定做的情况！我们开两个前缀和数组，一个记录全部乱涂的前缀和，计算乱涂部分；一个记录全涂一个色的前缀和，计算长度为 $k$ 的那个区间的前缀和。

然后计算一下答案，把所有情况下的最大答案输出就可以了。

**代码：**

```cpp
#include<bits/stdc++.h>
using namespace std;
long long ans,qzh1[100005],qzh2[100005];
int main(){
    int n,k;
    cin>>n>>k;
    for(int i=1;i<=n;i++){
        int x;
        cin>>x;
        qzh1[i]=qzh1[i-1]+x;
        qzh2[i]=qzh2[i-1]+max(0,x);
        //记录前缀和，如果比0小（即负数）就置0，不对答案造成影响，相当于不选。
    }
    for(int i=1;i<=n-k+1;i++){
        ans=max(ans,max((long long)0,qzh1[i+k-1]-qzh1[i-1]/*k区间值如是负数，就置0，同样相当于不选。*/)+qzh2[n]-(qzh2[i+k-1]-qzh2[i-1])/*总的减去k区间，因为k区间在前面算过了，不可以乱涂*/);//核心！
    }
    cout<<ans<<endl;
    return 0;
}
```