> *I. [AT3951 [AGC022F] Checkers](https://www.luogu.com.cn/problem/AT3951)*

为什么会有人模拟赛搬 AGC F 啊？

首先将每个点的坐标看成 $10 ^ {100}$ 进制，那么每一位独立，因为最终结果的每一位不超过 $2 ^ {n - 1} \ll  10 ^ {100}$。

考虑一个点删去另一个点的过程，从 $A\to B$ 连边画成一棵树。那么最终 $B$ 这一位的绝对值即 $2 ^ d$，其中 $d$ 是它的深度，因为每次 $0$ 向 $2 ^ k$ 跳一步会达到 $2 ^ {k + 1}$。

现在的问题是每一位的符号应当如何确定。注意到 $B$ 被删去后，包含 $B$ 这一位的点每删去一个点，$B$ 的符号就会改变一次。因此，一个节点受到它的所有祖先 $a$ 在与 $a$ 同一层的且在 $fa_a$ 的子树内的 “兄弟” 节点当中被删去的时间的影响，或者说一个点 $u$ 的符号受到 “某个节点删去包含 $u$ 的节点（因为 $v$ 删去 $u$ 之后就包含了它，而 $v$ 删掉它的所有儿子之后又被 $w$ 删除，那么 $w$ 就包含了 $u$）并在此之后又删掉了其它节点” 这个事件发生次数的奇偶性。这个在从上往下 DP 的过程中可以直接考虑到：考虑一次扩展一层。如果一个本层节点 $u$ 在下一层有偶数个儿子，那么这些节点正负个数相等，否则 **与 $u$​ 相同的符号** 会多一个，因为最后被 $u$ 删去的节点与 $u$ 的符号相同，往前推正负性不断改变，因为有奇数个所以除去最后被 $u$ 删去的节点往前推偶数个，正负抵消了。

但是 $B$ 的符号还受到它的儿子个数的 **奇偶性** 的影响，因为 $B$ 每删去一个点，符号也会改变一次。所以我们需要记录一维体现这个因素。层数是不重要的，我们只需知道已经选择了几个节点，因此设 $f_{i, j}$ 表示已经确定了 $i$ 个节点，其中当前层钦定 **恰好** 有 $j$​​ 个节点有奇数个儿子（这意味着这些节点的 **原符号**（即不考虑儿子个数的奇偶性的影响，仅考虑）与 **最终符号**（即考虑儿子个数的奇偶性的影响）不同）的总方案数。

- 被钦定有奇数个儿子的节点原符号必然相同，因为若有两个符号不同的节点钦定有奇数个儿子，这与它们同时有偶数个儿子所产生的正负贡献是等价的。注意，符号和节点编号的选择是两个相对独立的事件。而我们自然是希望钦定有奇数个儿子的节点越少越好，因为钦定有奇数个儿子意味着下一层必须得有符号固定的一些节点。

首先考虑初始值，应该是 $f_{1, 0} = f_{1, 1} = n$。因为根可以有奇数或偶数个儿子。此时这个 $j = 1$ 是正号，因为根节点的初始的符号是正的（删去包含根的节点并在此之后又删掉了其它节点的次数为 $0$，因为没有节点能删掉根）。

接下来考虑转移。枚举 **在最终** 与 $j$ 对应的符号 $\rm sign$（也就是钦定了 $j$ 个原来为 $\rm sign$ 的节点在最终要变为 $-\rm sign$）相同的节点个数 $x$ 和不同的节点个数 $y$。如果 $j = 0$ 则任意，因为究竟 $x$ 是正还是 $y$ 为正都无所谓，这是对称的。

根据上一层的限制，我们首先得放 $j$ 个符号为 $\rm sign$ 的节点挂到那些被钦定恰好有奇数个儿子的节点上，剩下来的**原符号正负平分**，原因在上面已经分析过了。因此 **原符号** 为 $\rm sign$ 的节点个数为 $\dfrac {x + y + j} 2$（如果 $x + y + j$ 的奇偶性不对，则这种方案不合法，跳过）。这说明我们被迫用钦定一些且仅有这些节点拥有奇数个儿子的方法更改它们的符号，也就是让最终符号的分布和我们枚举的 $x, y$ 一致，这样计数才正确。显然，我们需要钦定 $\left|x- \dfrac {x +y + j} 2\right|$ 个节点改变符号。当 $x$ 更大时，说明需要将一些原符号为 $-\rm sign$ 的节点改成 $\rm sign$，否则需要将一些原符号为 $\rm sign$ 的节点改成 $\rm -sign$。但无论是哪种情况，只要 $j$ 的 $-\rm sign$ 确定了，那么对应的改符号也确定了，即转移到的 $\dfrac {|x - y - j|} 2$ 对应的符号也确定了，因此 $x, y$ 的符号也确定了，即唯一确定一种方案。由于一开始 $j = 1$ 确定对应正号，$j = 0$ 则 $x, y$​ 的符号根据对称性可以任意钦定，所以方案唯一确定。

综上，有转移方程
$$
f_{i, j} \times \dbinom{n - i}{x + y}\dbinom{x + y}{x} \to f_{i + x + y, \frac {|x - y - j|} 2}
$$
限制为 $x +y + j$ 是偶数且 $x + y \geq \max(1, j)$。显然，$f_{n, 0}$ 即为所求。时间复杂度 $\mathcal{O}(n ^ 4)$​​。

可能讲得比较混乱，总结一下。我们定义 **原符号** 为仅考虑 $u$ 的祖先的影响时的符号。$u$ 的原符号由 $u$ 的父亲的 **原符号** 以及 $u$ 在它的所有兄弟节点中被删去的顺序决定。如果一个原符号为 $\rm sign$ 的节点 $u$ 有偶数个儿子，那么它们的原符号正负个数相同。如果有奇数个儿子，那么会多出来一个原符号为 $\rm sign$ 的儿子，并且 $u$ 的最终符号会变为 $-\rm sign$，这也是我们能够使得一个节点的原符号和最终符号不同的唯一方法。

对于 $f_{i, j}$ 这个状态来说，我们强制令 $j$ 个节点的符号需要从 $\rm sign$ 变为 $-\rm sign$，通过令它们有奇数个儿子实现。这个符号已经确定了，原因在上面有说明。因此，这意味着下一层节点原符号等于 $\rm sign$ 的比原符号等于 $-\rm sign$ 的要多出来 $j$ 个。但这并不意味着它们的最终符号分布就等于原符号分布，因为下一层节点也可以通过它们的儿子改变符号。为此，我们枚举最终符号分布 $x, y$，这样可以方便地算贡献，并直接推出至少需要改变多少个节点的原符号，从而实现转移。

接下来说一下如何优化到三次方。转移方程先化简为
$$
f_{i, j} \times \dfrac{(n - i)!}{(n - i - x - y)! x! y!} \to f_{i + x + y, \frac {|x - y - j|} 2}
$$
考虑为 $f_{i, j}$ 乘以 $(n - i)!$，那么转移方程变为 $\dfrac {f_{i, j}}{x! y!} \to \cdots$。最后答案因 $(n - n)! = 1$ 仍为 $f_{n, 0}$。

我们注意到 $x, y$ 的转移相对来说是很独立的，除了要满足 $2\mid x + y + j$，$x + y > 0$ 且 $x + y\geq j$ 的限制。第一项等价于 $2\mid x + y - j$，第三项等价于 $y\geq j - x$。由于最终贡献的下标形为 $\dfrac {|x - y - j|}2$，我们不妨先从 $f(i, j)$ 转移到 $g(i + x, x - j)$，再从 $g(i', j')$ 转移到 $f\left(i' + y, \dfrac {|j' - y|} 2\right)$。

考虑这些限制：$y \geq j - x\iff y \geq -j'$，容易考虑到。$2\mid x + y - j\iff 2\mid j' + y$，容易考虑到。对于 $x + y > 0$ 而言，我们在枚举 $x$ 的时候仅枚举 $x \geq 1$ 的部分。为了包含 $x = 0$，$y\geq 1$​​ 的部分，我们用一开始的转移方程就好了。时间复杂度 $\mathcal{O}(n ^ 3)$。

注意对于每个 $i$ 要先用 $g_i \to f_{i + y}$，再 $f_i\to g_{i + x}$，前者求出了 $f_i$ 的真实值（因为有 $y = 0$ 的情况），否则会漏考虑很多情况。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 500 + 5, p = 1e9 + 7;
int n, fc[N], ifc[N], f[N][N], g[N][N << 1];
void add(int &x, int y) {x += y, x >= p && (x -= p);}
int ksm(int a, int b) {
	int s = 1;
	while(b) {
		if(b & 1) s = 1ll * s * a % p;
		a = 1ll * a * a % p, b >>= 1;
	}
	return s;
}
int main() {
	cin >> n;
	for(int i = fc[0] = 1; i <= n; i++) fc[i] = 1ll * fc[i - 1] * i % p;
	ifc[n] = ksm(fc[n], p - 2), f[1][0] = f[1][1] = fc[n];
	for(int i = n - 1; ~i; i--) ifc[i] = 1ll * ifc[i + 1] * (i + 1) % p;
	for(int i = 1; i <= n; i++) {
		for(int j = -n; j <= n; j++) if(g[i][j + n]) for(int y = max(0, -j); y <= n - i; y++) if(j - y & 1 ^ 1) add(f[i + y][abs(j - y) >> 1], 1ll * g[i][j + n] * ifc[y] % p);
		for(int j = 0; j <= i; j++) if(f[i][j]) {
			for(int x = 1; x <= n - i; x++) add(g[i + x][x - j + n], 1ll * f[i][j] * ifc[x] % p);
			for(int y = 1; y <= n - i; y++) if(y >= j && (y + j & 1 ^ 1)) add(f[i + y][y + j >> 1], 1ll * f[i][j] * ifc[y] % p);
		}
	}
	cout << f[n][0] << endl;
    return 0;
}
```

