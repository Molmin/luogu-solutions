
楼下题解写的什么啊2333……~~(可能这就是dalao的思路吧)~~

菜的不行的我来写一发题解好了
______________________________________

### 前置芝士:可持久化线段树/主席树

不会这个东西的话可以出门左转luogu模板区，包教包会

## 本题题解

题目意思简单明了，就是每次询问一个区间的人在k这个位置集合的最小体力消耗

那么根据排序不等式还是别的什么东西总之我们可以得到一个结论就是$[l,r]$中位置第一小的人跑到第K个位置，第二小的人跑到k+1,第3小的人跑到k+2……如此这般一直到位置最大的人跑到第K+r-l个位置，这样进行列队体力值消耗之和一定是最小的

证明的话大概就是假设有两个人是逆序列队的(也就是原来位置靠前的人站到了后面)，那么我们可以将这两个人进行交换从而使得总代价更加少

而我们发现另外一个非常有趣的性质就是在这个列队过程中，存在一个分界点mid使得mid左边的人都向右跑，mid右边的人都向左跑

证明的话我们可以自己画一画图，然后就会发现因为集合的区域是连续的一段区间，因此是不会存在那种一些人向右跑之后又一些向左跑又一些人向右跑的情况的

那么我们现在假如说我们有一个神奇的数据结构，可以让我们知道有多少个人向右跑了，假设这些人集合在了$[K,K+s]$这个区间的话，根据刚才的结论我们知道一定是位置最靠前的前$s+1$的人向右跑了，我们可以不怎么负责任的列出这样的一个式子，它表示所有向右跑的人的体力消耗之和(对于这个式子意会一下就好它并不严谨)

$$\sum_{i}|a_{i}-K+i|$$

然后我们拆一下∑的话会变成这个式子:(由于都是向右跑，因此绝对值号被拆掉之后要取负号)

$$\sum_{i=K}^{K+s}i-\sum_{i}a_{i}$$

前面的式子是个等差数列求和可以$O(1)$的算出来，然后我们现在唯一要做的就是快速的算出来$[l,r]$前$s+1$小数字的和了

__________________

 _如果看懂了前面的部分不需要看这里_ 
 
 同理我们会发现恰好有$r-l-s$个人向左跑了，这部分代价我们也可以不怎么负责任的列一个式子出来
 
 $$\sum_{i}|a_{i}-K+i|$$
 
 只不过这会是向左跑，所以我们可以直接把绝对值符号拆掉，就得到了这个式子
 
 $$\sum_{i}a_{i}-\sum_{i=K+s+1}^{K+r-l}i$$
 
 当然后边的式子依然是一个等差数列求和的形式，我们依然可以$O(1)$的算出来
 前面的部分则是$[l,r]$中第$s+2$小到第$r-l+1$小数字的和了

_________________

好了经过刚才的一顿分析我们会发现我们需要的东西就是第一快速的求出那个分界点mid，或者说不求出分界点mid也可以，但是我们必须知道有多少人向左跑了

第二就是我们需要快速的求出区间$[l,r]$内前k大的数字之和

那么我们发现一件事是那个神奇的分界点会满足这样的性质，那就是

$cnt_{mid}=mid-K+1$

其中$cnt_{mid}$表示在区间$[l,r]$当中小于等于mid的数字个数

那么我们发现这个东西当然可以二分啦~

现在可能我们唯一要做的事情就是查找区间中比mid小的数字个数和前k小的数字之和啦~

这个问题，我们似乎只要得知了$[l,r]$这个区间的权值线段树长什么样我们就可以相当快速的求出来了……，甚至我们可以直接在权值线段树上二分，每次计算一下刚才的那个值，如果$cnt_{mid}$比$mid-K+1$小了我们就向右递归，否则我们就向左递归，每次向右递归的时候我们直接加上左儿子区间对应数字之和，这样当我们二分出mid的时候我们也顺手求出了所有值小于mid的数字之和

问题来了我们怎么知道一个区间的权值线段树长什么样呢？

当然是可持久化线段树(主席树)啦~我们把两个前缀的权值线段树一减我们就得到了目标区间的权值线段树了…

所以这道题我们最后要做的就是在主席树上二分出列队时的分界点(注意一件事是可能我们在所有人都向左跑或者向右跑的时候可能无法正确的二分出mid的位置，不过我们依然可以正确的二分出有多少个人向左跑了)，然后对于向左跑的人和向右跑的人分别计算一下代价即可了，写起来的话会相当的好写~

 _tips:值域才$10^6$我们无需也不能写离散化_ 

上代码~

```C
#include<cstdio>
#include<algorithm>
#include<map>
using namespace std;const int N=5*1e5+10;const int P=22*N;typedef long long ll;
int n;int m;
struct per_linetree//简易主席树板子
{
    int s[P][2];int siz[P];ll val[P];int ct;int root[N];int tim;ll vl;ll sl;
    per_linetree(){root[0]=ct=1;}
    inline void ins(int p1,int p2,int l,int r,int pos)//插入
    {
        siz[p2]=siz[p1]+1;val[p2]=val[p1]+pos;if(r-l==1){return;}int mid=(l+r)/2;
        if(pos<=mid)s[p2][1]=s[p1][1],ins(s[p1][0],s[p2][0]=++ct,l,mid,pos);
        else s[p2][0]=s[p1][0],ins(s[p1][1],s[p2][1]=++ct,mid,r,pos);
    }
    inline void query(int p1,int p2,int l,int r,int k)//二分，这里使用两个全局变量来记录向右跑的人数和向左跑的人的位置之和
    {
        if(r-l==1)return;int mid=(l+r)/2;
        int ns=siz[s[p2][0]]-siz[s[p1][0]];ll nv=val[s[p2][0]]-val[s[p1][0]];
        if(mid-k+1<ns+sl)vl+=nv,sl+=ns,query(s[p1][1],s[p2][1],mid,r,k);
        else if(mid-k+1==ns+sl){vl+=nv,sl+=ns;return;}
        else query(s[p1][0],s[p2][0],l,mid,k);	
    }
    inline void cins(int val){ins(root[tim],root[tim+1]=++ct,0,1e6,val);++tim;}
    inline void cquery(int l,int r,int k)//二分出来分割点之后简单的计算一下就行了
    {
        vl=0;sl=0;query(root[l-1],root[r],0,1e6,k);
        ll vr=val[root[r]]-val[root[l-1]]-vl;
        ll sr=(k+sl+k+r-l)*(r-l+1-sl)/2;sl=(k+k+sl-1)*sl/2;
        printf("%lld\n",sl-vl+vr-sr);
    }
}plt;
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1,t;i<=n;i++)scanf("%d",&t),plt.cins(t);
    for(int i=1,l,r,k;i<=m;i++)scanf("%d%d%d",&l,&r,&k),plt.cquery(l,r,k);
    return 0;//拜拜程序~
}
```










