蒟蒻第一次发题解，抱住可爱的我自己233

本题难度虽说洛谷写着提高+，但实质上是比较水的。

~~虽然我还是看了题解才会做~~

 # 细节在代码里解释，会详细写一些我自己感觉不太好懂的地方#
```
#include<iostream>
#include<cstdio>
#include<cmath>
#include<cstring>
using namespace std;
//1000个骨牌最小差为-1000*（6-1）=-5000，为防止下标负数越界加上5010 
int f[1005][10015];
//f[i][j]表示前i个骨牌的差为j-5010时需要翻牌的次数 
int a[1005],b[1005],c[1005];
//a为骨牌上方的数，b为骨牌下方的数，c为上方的数-下方的数（即差） 
const int N=5010;//懒得写5010(笑) 
int main()
{
//	freopen("in.txt","r",stdin);
	int n;
	cin>>n;
	for(int i=1;i<=n;i++)
	cin>>a[i]>>b[i],c[i]=a[i]-b[i];
	
	memset(f,0x7f,sizeof(f));//f[i][j]=0x7f表示无法在前i个骨牌使差为j 
	f[0][0+N]=0;//0个骨牌一次都没翻，差为0 
	
	//dp过程，其实主要就一行233 ~~所以说很水啊 ~~
	for(int i=1;i<=n;i++)
	for(int j=10;j<=10010;j++)//由10开始是因为由1开始j-c[i]可能为负 
	{
		//重点，敲黑板
		//①f[i-1][j-c[i]]表示前i-1个骨牌的差为j-c[i]，而第i个骨牌的差为c[i]，所以不用翻
		//②同理，f[i-1][j+c[i]]表示前i-1个骨牌的差为j+c[i]，而第i个骨牌的差为c[i]
		//  所以需要翻一次后差为-c[i]，后同①。所以需要+1  
		f[i][j]=min(f[i-1][j-c[i]],f[i-1][j+c[i]]+1);
	}
	//选择答案 
	int ans1=10000,ans2=1000;//ans1表示n个骨牌的差，ans2表示最少需要翻几次（分别对应j和f[n][j]) 
	for(int j=10;j<=10010;j++)
	{
		if(f[n][j]<f[0][0])//检查差是否可以等于j -N(还记得差加了5010吗)，如果有做过肯定小于初始值 
		{
			if(fabs(j-N)<=ans1)//题目要求差最小 
			{
				if(fabs(j-N)==ans1)//如果差相等，表示从负的做到正的，再做肯定比现在的差大，直接退出 
				{
					ans2=min(ans2,f[n][j]);break;
				}
				//更新两个ans 
				ans1=fabs(j-N);
				ans2=f[n][j];				
			}
		}
	}
	//这个也很重要，输出每一个值可以帮助自己检查，很实用的技巧 
/*
	for(int i=1;i<=n;i++)
	for(int j=5000;j<=5020;j++)
	printf("f[%d][%d]=%d\n",i,j-5010,f[i][j]);
*/	
	cout<<ans2;
	return 0;
}
```
我感觉我写的好详细啊，下次要偷懒一点233