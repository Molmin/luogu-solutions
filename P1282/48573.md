# 一维数组解法
**数组作用**：f[i]表示经过最少反转数得到数字i的最小值，由于题目中a,b的值为1~6，所以范围为-5000~5000，开10000的数组即可。  
s数组为该对多米诺骨牌对整个序列的贡献，这个作用不大。

------------
**做法思路**：对于每对骨牌，若反转就会对使原值变成j-s[i]*2（设j为原值），所以对于每对骨牌，都反转一下，用这个来更新f数组，然后就直接DP做。


------------
**代码如下**：

```cpp
#include<cstdio>
#include<iostream>
using namespace std;
int s[1005],f[10005];
int main()
{
    int n,a,b,i,j,x=0;
    scanf("%d",&n);
    for(i=1;i<=n;i++)
      scanf("%d%d",&a,&b),s[i]=a-b,x+=s[i];
    for(i=0;i<=10000;i++)f[i]=99999999;//一开始默认要反转无穷多次得到值i
    f[x+5000]=0;//初始化，原值不需要反转，所以f[x]=0;
    for(i=1;i<=n;i++)   //枚举每对骨牌
    {
      if(s[i]==0)continue;
      //j为枚举哪些值是已经存在的，再计算反转之后对新数字的贡献
      for(j=5000;j>=0;j--)
      {
      	if(f[j]==99999999)continue;
	    if((j-s[i]*2)<=10000&&(j-s[i]*2)>=0)
	    {
		  f[j-s[i]*2]=min(f[j]+1,f[j-s[i]*2]);
		}
	  }
	  for(j=5000;j<=10000;j++)
      {
      	if(f[j]==99999999)continue;
	    if((j-s[i]*2)<=10000&&(j-s[i]*2)>=0)
	    {
		  f[j-s[i]*2]=min(f[j]+1,f[j-s[i]*2]);
		}
	  }
    }
    
    //按照题目要求，找出上下排骨牌之差绝对值最小，且反转次数最少，应该容易理解
    int a1,a2;
    for(i=5000;i>=0;i--)
      if(f[i]!=99999999){
	    a1=i;
	    break;
	  }
	for(i=5000;i<=10000;i++)
      if(f[i]!=99999999){
	    a2=i;
	    break;
	  }
	if(a1==a2)printf("%d",min(f[a1],f[a2]));
	else if(5000-a1<a2-5000)printf("%d",f[a1]);
	else printf("%d",f[a2]);
    return 0;
}
```


------------
为何DP时我要用两层for，原因是：对于0~5000（就是负数的情况）与5000~10000（正数的情况），它们对状态的转移是不一样的，DP要用已知值更新未知值，所以对于正负数循环的状态转移是要分开写的。（应该也容易理解吧）
**^_^**