为什么大家做这题都是用的DP？这让我不会DP的蒟蒻无地自容啊。

那么，就让我来发第一篇BFS(是的，你没看错)题解吧...~~(管理员大大求给过，原创)~~

其实这题很像BFS的模板，我们可以一层层的搜下去，翻转一次，两次，三次等能不能得到最小值。当得到最小值的时候就直接 ${exit(0)}$ ，妥妥的套模板。

不过问题来了:
1. 用BFS万一TLE了怎么办？

- 我怎么知道最小值是多少？

Solution :
1. 剪枝

- 求出最小值

~~看上去是不是什么都没说？开个玩笑~ ~，具体方法见代码和注释~~ 

## Code

```cpp

/*     蒟蒻的第一篇题解,若有不当,敬请指正     */

#include "bits/stdc++.h"
using namespace std;

int n,m,k,sum,p,a[1001],b[1001],dp[6001],s[1001];
int f[100001],q[100001],h,t,boo[100001],del[10001][1001];
//a[i],b[i]:输入的点数    s[i]:一张牌上的点数差的绝对值
//boo[i]:标记上下之差为i时是否搜索过
//(因为求最小翻转,所以最先到达某个状态的一定是最优解)
//del[i][j]:第i个状态时哪些牌被翻转过(每张牌最多翻转一遍)
int push(int x,int o)
{
	if(boo[x+50000]==1)
		return 0;
    //若此状态被搜索过就返回
    //因为Σs1-Σs2可能为负数,所以要整体向右偏移,避免数组下标越界(P党福音)
    //即使极端情况1000个6-1,偏移5000也够了,我手贱多打了个0
	if(del[h][o]==1)
		return 0;
    //如果该状态时这张牌被翻转过就返回
	boo[x+50000]=1;
	if(x==k||x==-k)//±k:当上方比下方多k或少k时都是符合条件的
	{
		printf("%d",f[h]);
		exit(0);
	}
	t++;
	for(int i=1;i<=n;i++)
		del[t][i]=del[h][i];
	del[t][o]=1;
    //标记此状态时翻转过的牌(这题数据略水,不标记也只有两个点WA)
	q[t]=x;
	f[t]=f[h]+1;
}

int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
		scanf("%d%d",&a[i],&b[i]);
		s[i]=abs(a[i]-b[i]);
		p+=a[i]-b[i];
		if(a[i]>b[i])
			a[i]-=b[i],b[i]=0;
		else
			b[i]-=a[i],a[i]=0;
        //将a[i],b[i]其中一个缩减到0，方便标记
        //事实上,6-3 5-2 4-1 3-0等差值相同时,都是等价的
		sum+=s[i];//求总差值
	}
	m=sum/2;
	for(int i=1;i<=n;i++)
		for(int j=m;j>=s[i];j--)
			dp[j]=max(dp[j],dp[j-s[i]]+s[i]);
	k=sum-2*dp[m];
    //这里用到了01背包的思路:选一部分在上方,剩下的在下方,上方的当做要选取的物品
    //那么就有n个物品,背包的总体积为m=sum/2,物品的价值和体积都为s[i]
    //在sum/2的体积中选取最大价值(类似装箱问题),则选取体积最接近于总体积的一半时,两份体积的差最小
    //所以最小差值即为k=(sum-dp[m])-dp[m]=sum-2*dp[m]
	push(p,0);//BFS模板
	do
	{
		h++;
		for(int i=1;i<=n;i++)
			if(a[i]==0)//上方小于下方,翻转后Σs1-Σs2变大
				push(q[h]+2*s[i],i);
			else//上方大于下方,翻转后Σs1-Σs2变小
				push(q[h]-2*s[i],i);
	}
	while(h<t);
	return 0;
}
```

#### 写在最后:
对于参加NOIP的选手,即使不会DP,遇到DP题也不要放弃,去尝试着拿暴力分,广搜深搜记搜都能拿到部分分甚至满分(像这题),无论如何都不要放弃,或许还能有新的收获。