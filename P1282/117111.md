### 这是一道很不错的DP题，它考察了一种关于减少两个集合的差值的DP思想。
***
**首先很明显的是这道题的状态不是那么好写，所以我们考虑一下怎么把它变一下型**

**可以隐隐约约感受到一种转移的感觉，就是我假如翻动了一组多米诺骨牌的话，我的f会加一，同时另外一个表示上下集合之差量会变化，所以这个地方的DP转移方程中间只有两个量，一个是和差值相关的量，一个是和反转次数相关的量，我们要使得前一个量达到一个最值的时候对应的后面的一个量的最小值。**

**这样子说是很感性的说法，在换种说法就是：**

**我们要用 f [ i ] 里面的 i 来表示上下集合的差值，用 f [ i ] 这个整体来表示翻动的次数，使得可以取到的最大的 i 对应的 f [ i ] 最小，这其实就有点像01背包了！**

**现在考虑状态转移方程，因为上下两个翻转会带来变化，它们单独存在的时候是没有考虑价值的，所以我们把上下两块多米诺骨牌看作是一个物体，它所占有的体积，就应该是翻转它们两个可以带来的集合之差减少值，而它们两个所代表的整体的重量【就是和 f [ i ] 同类型的量，说它是什么都行】就是1.**

**这时机（~~chi~~）智（~~dun~~）的我发现了不太好的一个地方，就是我翻转之后的带来的贡献【集合之差减少量】不好表示，因为这和我现在上下集合孰大孰小是有关系的，也就是说每对多米诺骨牌所表示的价值是会随着状态的变化而变化的，这大大的违背了DP的原则，是不可行的！！**

**但是我们可以通过一个巧妙的方法解决这个问题！：**

**假如我们事先就让所有的多米诺骨牌对都翻到上大下小的状态，那么我们现在每一对多米诺骨牌对应的价值就是固定的了，只会朝着减少差值的方向进行，也就是上下骨牌点数之差的两倍，而这个背包的最大值就是上下集合的点数之差，每对骨牌的重量是固定的，假如之前本身就是上大下小那么重量就是1，反之就是-1（相当于先加上了这些重量，后来再转回去就抵消了！）**

**所以我们记录一个base代表一开始就把上小下大的情况转成上大下小的情况的数量，代表我之前就已经消耗的步数，然后跑一个严格排列的# 的01背包，找到距离背包大小最小的有效的 f [ i ] 再加上base就是答案了！**

**解释一下严格排列的01背包：**

**一般的01背包中 f [ i ] [ j ] 表示的是前 i 个物品中用体积为 j 的背包可以装下的最大价值（最小重量），也就是说这里的 j 的体积是可以不装满的**

**而这个地方我们的体积必须装的严严实实的，因为这里的 f [ i ] [ j ] 表示的是前 i 对多米诺骨牌中 通过翻转使得上下集合的差值减小了 j 的情况下的最小翻转次数！**

**一个是背包可空，一个是使得差值恰好为**

**所以下面的DP转移的时候必须保证转移过来的 j 要么是 0 要么是一个已经确定了是一步步转移过来的状态，而这个地方的【确定】我们用一个 full 数组来维护，表示是不是一个装满了的背包！**
***
**代码如下：**
```cpp
#include<bits/stdc++.h>
#define maxn 10000
using namespace std;
int n,V,base_weight,v[maxn],w[maxn],f[maxn];
bool full[maxn];
inline int qr()
{
	int sum=0;
	char j=0;
	bool flag=0;
	while(!isdigit(j))
	{
		flag|=j=='-';
		j=getchar();
	}
	while(isdigit(j))
	{
		sum=(sum<<1)+(sum<<3)+(j^48);
		j=getchar();
	}
	return flag? -sum:sum;
}
inline void readin()
{
	n=qr();
	int a,b;
	for(int i=1;i<=n;i++)
	{
		a=qr();
		b=qr();
		if(a>b)
		{
			v[i]=2*(a-b);
			V+=a-b;
			w[i]=1; 
		}
		else if(a<b)
		{
			v[i]=2*(b-a);
			V+=b-a;
			w[i]=-1;
			base_weight++;
		}
	} 
	for(int i=1;i<=V;i++)
	f[i]=0x7777777;
	return;
}
inline void Solve()
{
	for(int i=1;i<=n;i++)
	if(v[i])
	for(int j=V;j>=v[i];j--)
	{
		if(v[i]==j||full[j-v[i]])
		{
			full[j]=1;
			f[j]=min(f[j],f[j-v[i]]+w[i]);
		}
	} 
	return;
}
inline void print()
{
	for(int i=V;i>=1;i--)
	if(full[i])
	{
		printf("%d",base_weight+f[i]);
		return;
	}
	printf("%d",base_weight);
	return;
}
int main()
{
	readin();
	Solve();
	print();
	return 0;
}
```
