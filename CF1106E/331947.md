### [Lunar New Year and Red Envelopes](https://www.luogu.com.cn/problem/CF1106E)

md，被诈骗了。

注意条件 $s_i\le t_i\le d_i$，这说明每个时间点只有一种抉择，而不会因为重叠的红包导致抉择出现其他情况。

准确的来说，如果在 $i$ 时刻，`Bob`可以选择红包了。

那么 $i$ 号时间点的最优红包一定还没有被抢，因为如果被抢了，`Bob`会被送到大于 $t_i$ 的时间点，而此时这个红包已经消失了，所以每个时间点只会有一种抉择，并且不会受到`Alice`的影响。

考虑用优先队列维护出每个时间点的抉择 $nxt_i$ 表示抉择之后的下一个时间点，$c_i$ 表示抉择的价值。

$dp_{i,j}$ 表示在 $i$ 号时间点时，阻拦 $j$ 次的最小权值。

转移也很简单

```cpp
dp[nxt[i]][j]=min(dp[nxt[i]][j],dp[i][j]+c[i]);
dp[i+1][j+1]=min(dp[i][j],dp[i+1][j+1]);
```

