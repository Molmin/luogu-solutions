# [题目传送门](https://www.luogu.com.cn/problem/AT_agc058_a)
# 题目描述

给定一个 $1$ 到 $2N$ 的排列 $P=(P_1,P_2,\cdots,P_{2N})$，可以进行若干次操作，每次操作可以将相邻两个位置的元素交换。现在要求进行若干次操作，使得 $P$ 满足以下条件：

对于所有奇数 $i\in[1,2N-1]$，都有 $P_i<P_{i+1}$；

对于所有偶数 $i\in[2,2N-2]$，都有 $P_i>P_{i+1}$。


# 思路分析
题目中说了，必然存在操作方案使得最终序列符合条件，那么我们只需考虑如何跳过中间某一步到达最终符合条件的状态，考虑什么情况下可以快速结束构造。

显然要想得到满足要求的序列必须满足 $P_{2i} > \max\{P_{2i-1}, P_{2i+1}\}$ 或 $P_{2n} < P_{2n-1}$。

依次遍历每个 $2i$，如果它不符合上述条件，就交换 $P_{2i}$ 和 $\max\{P_{2i-1}, P_{2i+1}\}$ 的位置，那么这个位置上的值肯定就满足限制条件了，把操作记录到答案里即可。

对于最后一个位置 $2n$，如果它不符合要求，就交换 $P_{2n}$ 和 $P_{2n-1}$ 的位置即可。

时间复杂度是 $O(n)$，可以通过本题。

# 参考代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 1e5 + 2;
int n, a[N * 2], cnt; // 定义序列长度n、序列数组a、交换操作次数cnt
vector<int> ans; // 用于存放交换操作的位置
int main() {
	cin >> n;
	for (int i = 1; i <= n * 2; ++i)
		cin >> a[i];
	for (int i = 2; i <= n * 2; i += 2) { // 从第二个位置开始遍历，每次跳两个位置
		if (a[i] < max(a[i - 1], a[i + 1])) { // 如果当前元素不符合题目要求
			if (a[i - 1] > a[i + 1]) // 如果左边的元素比右边的元素大
				swap(a[i], a[i - 1]), ans.push_back(i - 1); // 则将左边的元素交换到当前位置，并记录交换位置
			else
				swap(a[i], a[i + 1]), ans.push_back(i); // 否则将右边的元素交换到当前位置，并记录交换位置
		}
		if (i == n * 2 && a[i] < a[i - 1]) // 如果当前遍历到倒数第二个位置且倒数第二个元素大于最后一个元素
			ans.push_back(i - 1); // 则将倒数第二个位置与最后一个位置交换，并记录交换位置
	}
	cout << ans.size() << '\n'; // 输出交换操作的次数
	for (auto x : ans)
		cout << x << " "; // 逐个输出交换操作的位置
	cout << endl;
	return 0;
}
```
