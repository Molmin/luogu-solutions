### 题目大意：
给一个序列，求它的连续的数$a[b[1]]-a[b[2]]+a[b[3]]-a[b[4]]$的最大值.

### 思路：
正如题目说的一样，$b$序列必须是连续的。一开始我就是没有看到连续的，所以贪心写了半个小时，发现样例没过。如果必须是连续的那么就只能$dp$了。


#### dp状态：
因为题目中有连接加和连接减两种情况，所以$dp$应该要有第二维表示是接着加还是减。所以说$dp[i][0]$表示第$i$个减，反之$dp[i][1]$表示从第$i$个是加。

#### dp转移：
根据我们之前推出的状态，可以轻松地想到转移方程。
```cpp
dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] + a[i]);
dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] - a[i]);
```
因为如果要减接着的肯定是上一个加，要加肯定要接上面的减。

### 代码：
```cpp
# include <bits/stdc++.h>
using namespace std;
long long a[500000], dp[500000][2];
int main()
{
	int n, q;
	int T;
	cin >> T;
	while (T--)
	{
		memset(dp, 0, sizeof(dp));     //多组数据别忘了dp初始值哦 
		cin >> n >> q;
		for (int i = 1; i <= n; i++)
		{
			cin >> a[i];
		}
		for (int i = 1; i <= n; i++)
		{
			dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] + a[i]);
			dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] - a[i]);        //dp转移 
		}
		cout << max(dp[n][0], dp[n][1]) << endl;           //两种情况中取最大 
	}
 } 
```
