提供两种 AC 做法。

---

看到这样的一个求值方式，不难想到用 DP 解决。

设 $f_{i,0/1}$ 为 $i$ 可选可不选，前 $i$ 个能达到的最大值。

其中 $i$ 若选，则 $0$ 代表答案中 $a_i$ 系数为负，$1$ 代表答案中 $a_i$ 系数为正。

若 $i$ 不选，则 $0$ 代表距离 $i$ 最近的一个已选的元素 $a_j$ 在答案中系数为负，$1$ 代表距离 $i$ 最近的一个已选的元素 $a_j$ 在答案中系数为正。

那么就有转移 $f_{i,0}=\max\{f_{i-1,1}-a_i,f_{i-1,0}\}$ 和 $f_{i,1}=\max\{f_{i-1,0}+a_i,f_{i-1,1}\}$。

由于 $a_i$ 一定为正，所以系数为正的数字个数一定比系数为负的数字个数多 $1$，那么答案就是 $f_{n,1}$。

转移只用到了 $i-1$ 的状态，所以可以把第一维去掉。

记得开`long long`。

代码：

```cpp
int n, q, t;
long long f[2];
inline void main() {
  for (read(t); t--; f[0] = f[1] = 0) { // 记得清空数组
    read(n), read(q); // 记得题里还有一个q要读，虽然没用
    for (int i = 1, x; i <= n; ++i) {
      read(x);
      f[0] = max(f[1] - x, f[0]);
      f[1] = max(f[0] + x, f[1]);
    }
    write(f[1]), putchar('\n');
  }
}
```

---

第二种就和 C2 的 hard 版本联系密切了，不过也不用担心，思路是通用的。

小 trick：如果实在不会做可以多看看样例找规律，尤其是这种 easy version，可以去看看 hard version 的样例，好好利用会有大用。（其实这次 C2 给的样例最适合发现这题的规律了）

先给结论：定义 $a_0=a_{n+1}=0$，对于波峰 $i$ 有 $a_i\gt a_{i-1}$ 且 $a_i\gt a_{i+1}$，对于波谷 $i$ 有 $a_i\lt a_{i-1}$ 且 $a_i\gt a_{i+1}$。所有波峰、波谷都要选，波峰系数为正，波谷系数为负。

感性证明：可以考虑一加一减的一个二元组 $(a_i,a_j)$，其中 $i\lt j$。若是选一个波峰和一个波谷一定是局部最优的。若 $a_i$ 不是波峰，对答案贡献会减小，若 $a_j$ 不是波谷，对答案贡献也会减小。所以把所有二元组都统计上一定是最优的。

所以沿途判断是波峰就加、是波谷就减就好。

```cpp
int n, q, t, a[N];
ll ans;
inline void add(int x) {
  if (a[x] > a[x - 1] && a[x] > a[x + 1]) { // 为波峰
    ans += a[x];
  } else if (a[x] < a[x - 1] && a[x] < a[x + 1]) { // 为波谷
    ans -= a[x];
  }
}
inline void main() {
  for (read(t); t--;) {
    read(n), read(q);
    for (int i = 1; i <= n; ++i) { read(a[i]); }
    a[n + 1] = ans = 0; // a[n+1]=0是为了保证答案正确性，因为a[n]也可能被选上
    for (int i = 1; i <= n; ++i) { add(i); }
    write(ans), putchar('\n');
  }
}
```

# 