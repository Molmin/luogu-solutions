# 题意
一个公司有 $n$ 个部门，第 $i$ 个部门有 $a_i$ 名员工。一个项目必须由来自不同部门的恰好 $k$ 名员工组成。 问最多可以同时建立多少个项目？
# 暴力
如果随便选人的话，最后可能会出现人很多但却没有 $k$ 个部门不为空的情况，但如果每回都选人最多的那 $k$ 个部门的话，就能保证人数不为空的部门尽可能的多。

所以暴力思路就很容易想到了：每次将人最多的那 $k$ 个部门的人数减 $1$ ，直到没有 $k$ 个部门不为空。能减多少次就能建立多少项目。

可是这个思路的时间复杂度非常高，因为人数非常多并且人还是一个一个挑的。
# 满分做法

设每个部门的那 $a_i$ 个人的编号为 $j = 1 ,2 ,\dots,a_i $。

上面的思路是根据任务选人，可以换一个角度，根据部门来选人。先假设 $c$ 是需要建立的项目的个数，那校验的方法就是：看每个部门里编号 $\le c$ 的总人数人是否能凑足每个项目的 $k$ 个人。

构造方案的方法是：依次分人。

举个例子：有三个部门， $c=5 , k=2$ 
```cpp
5	\\凑出这5个项目的第一个人
2	\\凑出前2个项目的第二个人
3	\\凑出后3个项目的第二个人
```

### 怎么求出 $c$
最暴力的方法当然是枚举。

但可以发现， $c$ 是有单调性的，因为 $c$ 越小，能凑足这 $c$ 个项目的 $k$ 个人的可能性就越大。所以二分出 $c$ 就可以了。
```cpp
#include <algorithm>
#include <iostream>

using namespace std;
using LL = long long;

const int kMaxN = 2e5 + 5;

int n, k;
LL a[kMaxN], l = 1e12 + 1, r, mid;

bool C(LL c) {
  LL s = 0;
  for (int i = 1; i <= n; i++) {
    s += min(c, a[i]);
  }
  return s / c >= k;
}

int main() {
  cin >> n >> k;
  for (int i = 1; i <= n; i++) {
    cin >> a[i];
    l = min(l, a[i]);
    r += a[i];
  }
  while (l <= r) {
    mid = (l + r) / 2;
    if (C(mid)) {
      l = mid + 1;
    } else {
      r = mid - 1;
    }
  }
  cout << r;
  return 0;
}
```