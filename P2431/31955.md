表示不会写位运算版的~~~，其实都是0ms啦

就是求n~m二进制中，所含最多的1的个数，因为2的幂次方都是(10000...0)2，若有最多的1，说明选的二的幂次方就越多

证明1的位置不移动可以得到最优解(只看一个1的情况)：

1:假设(n)2中的1可以往前移，那么

(1)这个数的十进制超过了m   结论是:1的位置不可以移动

(2)这个数的十进制小于等于m，但却得到了一个更大的数，假设我们只改变0，即使不一定得到最优结果，但得到的数也会小于这个数，因此，1的个数大于等于这个数的1的个数(important)   结论是:1的位置不可以移动(不动一定得到最多的1，动不一定得到最多的1)

2.假设(n)2中的1可以往后移，那么

所得的数一定小于n，结论是:1的位置不可以移动

在可以移动多个1时，综合以上几点，发现结论是:1的位置不可以移动(就不证明了)

```cpp
#include<cstdio>
typedef unsigned long long ull;
    ull n,m,t=0,ans=-1;
    int a[100];
int main()
{
    scanf("%llu %llu",&n,&m);
    while(n>0)
    {
        a[t++]=n%2;
        n/=2;
    }
    t=70;
    while(1)
    {
        for(int i=0;i<t;i++)
            if(a[i]==0)
            {
                a[i]=1;
                break;
            }
        ull s=0,p=1;
        for(int i=0;i<t;i++)
            s+=a[i]*p,p<<=1;
        //printf("%llu\n",s);
        if(s>m) break;
    }
    for(int i=0;i<t;i++)
        ans+=a[i];
    printf("%llu",ans);
}
```