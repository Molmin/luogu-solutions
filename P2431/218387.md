## 用2进制他不香么

看了其他题解，太复杂了~~（其实是我看不懂）~~，还是写一篇简洁易懂的题解吧。

首先要明白一个事实：任何一个数都能用2的任意次方相加所得。这里我就不予证明啦，有兴趣的朋友上网搜一下。


------------
正题开始
而月饼的重量都是2的次方嘛...

刚好填满明显是最优解，既然题目范围是小于2的64次方，开2个64的数组就行啦，从小到大来记录，明显比从大到小记录简单，因为月饼重量后一个是前一个的2倍，所以前面的月饼全吃完也没有后面的月饼重，而数量要多得多，这样它不是很香么？就像“日取其半”一样，这里给大家解析一下样例

输入16 25

从下往上

首先16的话

10000刚好满足

25的话

10001从下往上找，+1，阔以

10011再吃一个2g的，还是可以

10111再吃一个4g的，恩，还行

11111？不行了，超过25了

OK，4个

这样也和答案一样
粘代码

```cpp
#include<bits/stdc++.h>
using namespace std;
long long Max[64],Min[64];//开局2数组，装备全靠写，当然bool类型也行
int main()
{
    long long a,b,num=0,c,d,e;
  //a，b是最多和最少，c,d,e都作为临时储存变量
    cin>>b>>a;//标准输入流它不香么
    d=b;
    e=a;
    int n=-1;//计数器
    while(a>0)//记录每一位是否进入，不停地mod2呗，这样就能得到最优解
    {
        Max[++n]=a%2;
        a/=2;
    }
    n=-1;
    while(b>0)//看看最小值要多少
    {
        Min[++n]=b%2;
        b/=2;
    }
    for(int i=0;i<64;i++){
        if(Min[i]==1)//记录最小月饼数
        {
            num++;
        }
    }
    c=0;//计数器万岁
    int i=1;
    while(e>=d)//判断月饼数量是否超过最大
    {
        if(Min[c]==1)//吃了这一块么？
        {
            c++;//吃了？加一
        }
        else
        {//没有？那你快吃啊
            d+=i;
            num++;
            c++;
        }
        i*=2;
    }
    cout<<num-1;
}
```
拒绝抄袭，从你我做起