### 题目分析
首先，看到这道题先想，如果每一个边长为 $5$ 的立方体尽可能放满，所需要的立方体就会更少。所以我们可以先讨论一下放立方体的策略。

1. 考虑边长为 $5$ 的立方体怎么放，很明显，它与大立方体一样大，每个大立方体内只能放一个，并且没有剩余的空间。
2. 考虑边长为 $4$ 的立方体怎么放，每一个大立方体中只能放一个，剩余的空间只能放 $61$ 个边长为 $1$ 的立方体。
3. 考虑边长为 $3$ 的立方体怎么放，每个大立方体中也只能放一个，剩余的空间中只能放 $7$ 个边长为 $2$ 的立方体和 $42$ 个边长为 $1$ 的立方体。
4. 如果边长为 $2$ 的立方体实际个数比上述留给它的空要少，就可以把它多余的空给边长为 $1$ 的立方体，每个空能放 $8$ 个边长为 $1$ 的立方体。如果个数比空多，每个大立方体中能放 $8$ 个边长为 $2$ 的立方体。剩余空间能放 $61$ 个边长为 $1$ 的立方体。
5. 如果还有边长为 $1$ 的立方体没被放进去，每个大立方体可以放 $125$ 个边长为 $1$ 的立方体。

总结一下，我们的思路是先把大的放进去，然后再用小的填空，使大立方体中尽可能都放满。很同意楼上的看法，确实有点奥数的感觉。
### code
```cpp
#include <iostream>
#include <cstdio> 
using namespace std;
long long n = 5, a[10], ans;
int main()
{
	for(int i = 1;i <= n;i++)
		cin >> a[i];
	ans = a[5];
	ans += a[4];
	a[1] -= 61 * a[4];
	ans += a[3];
	a[2] -= a[3] * 7;
	a[1] -= a[3] * 42;
	if(a[2] < 0)
		a[1] += a[2] * 8, a[2] = 0;
	if(a[2] > 0)
	{
		ans += a[2] / 8;
		ans += (a[2] % 8) ? 1 : 0;
        a[1] -= 61 * (a[2] / 8);
		a[2] %= 8;
		a[1] -= a[2] ? (125 - a[2] * 8) : 0;
	}
	if(a[1] > 0)
	{
		ans += a[1] / 125;
		ans += (a[1] % 125) ? 1 : 0;
	}
	cout << ans << endl;
	return 0;
}
```