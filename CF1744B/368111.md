挺简单的一道题，但是要注意一下细节。

### 前置“芝士”：

- 奇数+奇数=偶数
- 奇数+偶数=奇数
- 偶数+偶数=偶数

### 思路：
在输入 $n$ 个数的时候，我们可以把奇、偶数的个数求出来并把这 $n$ 个数的和求出来，因为对于 $q$ 次操作，每次均只需输出数列的和。

在执行 $q$ 次操作时，设每次操作输入的是 $x$ 和 $y$，那么就按照 $x$ 是 $0$ 的情况和 $x$ 是 $1$ 的情况分别执行：若为 $0$，则数列和加上偶数 $\times y$；若为 $1$，则数列和加上奇数 $\times y$。

按照上面这个思路，看似可以过了，开始时我也是这么打的，但是测试样例只对了几组。

为什么呢？因为奇数加偶数仍然等于奇数，而奇数加奇数则等于偶数，因此在 $x=0$ 或 $x=1$ 的情况下都要特判 $y$ 是否为奇数：若 $x=0$ 且 $y$ 为奇数，根据奇数加偶数等于奇数，要将奇数个数加上偶数个数，并将偶数个数清 $0$；若 $x=1$ 且 $y$ 为奇数，根据奇数加奇数等于偶数，要将偶数个数加上奇数个数，并将奇数个数清 $0$。

另外，这题必须使用 $\texttt{long long}$，因为数列和可能会超出 $\texttt{int}$ 范围。

### 代码：
```cpp
#include<iostream>
#include<cstring>
#define ll long long
using namespace std;
ll t,n,q,a[100005];
ll js;//奇数个数 
ll os;//偶数个数 
ll ans;//数组和 
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);
	cin>>t;
	for(;t--;){
		js=os=ans=0;//初始化 
		cin>>n>>q;
		for(int i=1;i<=n;++i){
			cin>>a[i];
			if(a[i]%2==0)++os;
			else ++js;
			ans+=a[i];//求出整个数组的和 
		}
		for(int i=1;i<=q;++i){
			int x,y;
			cin>>x>>y;
			if(x==0){
				ans+=os*y;
				if(y%2==1){//奇数+偶数=奇数，所以偶数全部变为奇数
					js+=os;
					os=0;
				}
			}
			else if(x==1){
				ans+=js*y;
				if(y%2==1){//奇数+奇数=偶数，所以奇数全部变为偶数 
					os+=js;
					js=0;
				} 
			}
			cout<<ans<<"\n";
		}
	}
	return 0;
}
```