### 思路：这题虽然用递归会超时，但我们可以用递归来打表。
### 解法：
根据给出的递归式，可以得到递归函数。
```cpp
long long f(int n){
	if(n==1||n==2)return 1;
	return f(n-1)+f(n-2);
}

```
有了递归函数，程序也不难写出，会很慢，可以加上O3优化等。
```cpp
#include<bits/stdc++.h>
#pragma G++ optimize(3)//O3优化吼啊
using namespace std;
const long long p=pow(2,31);
long long f(int n){//递归大法吼啊
	if(n==1||n==2)return 1;
	return f(n-1)+f(n-2);
}
int main(){
	for(int i=1;i<=48;i++){
		printf("%lld,",f(i)%p);//printf吼啊
	}
	return 0;
}

```
于是得到一张表（已经%2^31了）。
```cpp
1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17711,28657,46368,75025,121393,196418,317811,514229,832040,1346269,2178309,3524578,5702887,9227465,14930352,24157817,39088169,63245986,102334155,165580141,267914296,433494437,701408733,1134903170,1836311903,823731425,512559680
```
还要把每个数分解质因数，分解质因数的第一个数是不需要乘号的，所以需要进行特判。
```cpp
for(int i=2;i<=a[n];i++){
		while(a[n]%i==0){//有就使劲除
            if(!pd)cout<<i;
            else cout<<'*'<<i;
            a[n]/=i,pd=true;
        }
	}
```
有了这些就可以写出代码了。
### 代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
bool pd;
int n;
long long a[49]={0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17711,28657,46368,75025,121393,196418,317811,514229,832040,1346269,2178309,3524578,5702887,9227465,14930352,24157817,39088169,63245986,102334155,165580141,267914296,433494437,701408733,1134903170,1836311903,823731425,512559680};//打表
int main(){
	cin>>n;
	cout<<a[n]<<'=';
	for(int i=2;i<=a[n];i++){
		while(a[n]%i==0){
            if(!pd)cout<<i;
            else cout<<'*'<<i;
            a[n]/=i,pd=true;
        }
	}//分解质因数
    cout<<'\n';
	return 0;
}

```



