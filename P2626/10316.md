题目很简单，就是求出斐波那契数列的第n个，因为有mod，所以不用高精度，只要开int64就可以了。之后再分解质因数，i循环一


点一点加（可能会在超大的质数中超时，不过也没有超时间）。

讨论中说了当n=1或n=2时是1，尽管数据貌似没有1，但只要向质数一样处理，输出1=1就可以了（本题解中用了打表，很赖皮，但也


是在比赛时针对特殊情况的好助手）。

PS：在斐波那契数列中动用了a数组，开int64，其实用三个数xyz就可以了，稍微占一点内存。为了简单易懂，就不用xyz了。（比


赛抠一点，平时多一点）

附上AC的代码：

```cpp
var
 a:array[1..48] of int64;     
 n,i:longint;           //定义很简单粗暴
begin
  readln(n);
  if n<3 then
  begin
    writeln('1=1');      //专门判断当a[n]=1时的特殊情况
    exit;
  end;
  a[1]:=1;      //定义a[1]
  a[2]:=1;      //定义a[2]
  for i:=3 to n do a[i]:=(a[i-1]+a[i-2]) mod 2147483648;      //求斐波那契数列的第n项，公式见题首     
  write(a[n],'=');     //先输出a[n]
  i:=1;                    //i从2开始判断，后面会在判断之前再加一个1
  while true do      //死循环，事后会直接退出的
  begin
    inc(i);                 //不断累加从而从小到大分解质因数
    while a[n] mod i=0 do         //如果a[n]含i这个质因数就一直循环
    begin
      a[n]:=a[n] div i;               //除法
      write(i);                          //输出质因数
      if a[n]=1 then              //如果a[n]已经分解完了
      begin
        writeln;                  //换行
        exit;                     //直接结束程序
      end;
      write('*');                 //别忘了中间有乘号间隔
    end;
  end;
end.
```