   斐波那契相信大家都会了，这题主要是考的分解质因数。

   斐波那契的递推式:$f[i]=f[i-1]+f[i-2]$,还有一种简单的,写在代码里:
        
   因为你把$f[i]$算出来了,要算$f[i+1]$,那么原来的$f[i-2]$就没用了,$f[i-1]$变成了$f[i-2]$,刚算出来的$f[i]$变成了$f[i-1]$,一直递推到n。这样就可以用三个变量代替f数组。
    
   分解质因数的话,就是从2开始枚举,直到发现一个能被整除的质数(这个质数一定是最小的),再输出,把数列的最后一个数除上这个质数,然后接着从2开始找。。。一直到那个数被除到1为止。
        
   具体分析看代码:
    
```cpp
#include<iostream>
#include<cmath>
using namespace std;
bool pri(int x)//判断质数。
{
	int m=sqrt(x);//用一个变量来存储，避免了重复计算平方根
	if(x<=1)//小于等于1的都不是质数
		return false;
	for(int i=2;i<=m;i++)//从2循环到sqrt(x)(m)
		if(x%i==0)//如果有能被整除的,就说明不是质数
			return false;
	return true;
}
void fjzys(int x)//分解质因数(不会英文用拼音...)
{
	cout<<x<<"=";//先输一个头,这是一定要的
	if(pri(x))//如果本身就是质数那就不用分解了,直接输出
	{
		cout<<x;
		return;
	}
	bool fir=false;//判断输出的是否为第一个数
	while(x!=1)//x没有被除尽时
	{
		for(int i=2;i<=x;i++)//从2到x,找一个可以被x整除的质数
			if(pri(i) && x%i==0)
			{
				if(fir==false)//如果是第一个数就不用加乘号
				{
					cout<<i;
					fir=true;//现在不是第一个了
				}
				else//如果不是第一个就加乘号
				{
					cout<<"*"<<i;
				}
				x/=i;//把x除以i
				break;//退出循环
			}
	}
}
int main()
{
	long long f1,f2,f3;//如果要%2^31的话可能会爆int
	int n;
	cin>>n;
	if(n==1 || n==2)//第1和2项都是1,不用分解了
	{
		cout<<"1=1";
		return 0;
	}
	f1=1;//第1项为1
	f2=1;//第2项为1
	for(int i=3;i<=n;i++)
	{
		f3=f1+f2%21474836348;//第3项=第1项+第2项
		f1=f2;//第1项变成"第2项"
		f2=f3;//第2项变成"第3项"
		f1%=21474836348;
		f2%=21474836348;//就地取模保险
	}
	fjzys(f3);//输出
}
```