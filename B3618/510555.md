~~状压大水题，可惜太冷门了。~~

# 解析

这道题，一看数据范围，我就想到了状态压缩。

## 1. 状态压缩是什么？

状态压缩，顾名思义，就是将状态像压缩包一样缩到一起。

比如，这道题如果要拿每个人是选还是不选（选则为 $1$，不选则为 $0$）作为状态表示的话，最多会需要 $21$ 个参数来表示状态！虽然不是很多，但是写起来还是会比较麻烦的。
```c++
long long dp[2][2][2][2][2][2][2][2][2][2][2][2][2][2][2][2][2][2][2][2][2][2];
```
（不压缩的数组长这样，是不是很长很烦？）

但是，我们可以发现：这个数组的每个下标取值都只会是 $0$ 或 $1$，而`int`的范围远远大于 $0$ 和 $1$。如果按上面这样来表示，会造成很多的空间浪费！

那怎么办呢？

当我们将每一维看作一个 $2$ 进制数中的一位时，我们就可以用一个 $2$ 进制数表示整个数组 $21$ 维的状态。

举个例子：

当我们把 $dp_{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,1,0}$ 的下标压缩后，得到了 $10110_{(2)}$。$10110_{(2)} = 14_{(10)}$，所以 $dp_{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,1,0}$ 就可以直接用 $dp_{14}$ 来表示。

所以，我们可以把空间挤一下，将数组压成一维！
```c++
long long dp[1<<22];//为什么是左移22位呢？因为左移21位会RE……
```
## 2. 这题怎么算成功率？
题目说了，当有偶数个人拥有同一类能力时，团队会失去这项能力。就像当多个数异或有偶数个 $1$ 时，异或的结果为 $0$。

所以，我们可以首先预处理出如果只选这个人的成功率，然后枚举所有可能的状态，判断这种状态里选了哪些人，最后将这些人的成功率全部异或，再找出最大的答案输出即可。

不理解也没关系，看代码就好了。

# AC code
```c++
#include<bits/stdc++.h>
#define owo (1<<22)+5
#define int1 unsigned long long
using namespace std;
int1 n,k,n2,i,j,l,a[26],dp[owo],s,t,ans;//不开long long见祖宗。
int1 read(){//日常快读。
	int1 x = 0,f = 1;
	char ch = getchar();
	while(!isdigit(ch)){
		if(ch == '-'){
			f = -1;
		}
		ch = getchar();
	}
	while(isdigit(ch)){
		x = (x << 1) + (x << 3) + ch - '0';
		ch = getchar();
	}
	return x * f;
}
void print(int1 x){//日常快写。
  	if(x < 0){
    	putchar('-');
    	x = -x;
  	}
  	if(x > 9){
    	print(x / 10);
  	}
  	putchar(x % 10 + 48);
  	return ;
}
int main(){
	n = read(),k = read(),n2 = 1ull << (n + 1ull);
	for(i = 1ull; i <= n; i++){
		s = read();
		for(j = 1ull; j <= s; j++){
			t = read();
			a[i] += (1ull << (k - t));//预处理成功率。
		}
	}
	for(i = 2ull; i < n2; i++){//枚举所有可能的情况。
		l = i;
		for(j = n; j >= 1ull; j--){//计算这种组合的成功率。
			if(l >= (1ull << j)){
				l -= 1ull << j;
				dp[i] ^= a[j];
			}
		}
		ans = max(ans,dp[i]);//找最大的答案。
	}
	print(ans);
    return 0;
}
```