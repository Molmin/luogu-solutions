好难写的说，先写做法再码吧，过了再贴提交记录到文章最后面。

这种弔题能自己想出来还是很有成就感的，虽然好像想了三天。

发现每次修改所影响的和查询的都是子树，所以先把 $dfs$ 序搞出来，每次相当于对一个区间处理。

问题转换为每个点有一个 $a_i,b_i$ ，每次有两种操作。

$1.$ 对于一个区间，将这个区间每个 $a_i+=x$。

$2.$ 查询一个区间内 $|a_i|\times|b_i|$ 的最大值。

首先 $b_i$ 是固定的，瓶颈在于这个 $a_i$ 的绝对值。

我们考虑把每个点表示为 $b_ix+c_i$ 的形式，其中 $c_i=|a_i|\times |b_i|$ ，而 $x$ 为 $|a_i|$ 的变化量。

一种朴素的想法是维护凸包，但是线段树涉及合并的话合并凸包复杂度很危险，所以用万能的分块去维护，每一块维护一个凸包。

考虑这个凸包咋弄，绝对值有一个很好的性质 $|x|=\max(x,-x)$ ，而题目查询的刚好又是最大值。

所以我们可以对每个点弄出两条直线，一个是 $b_ix+a_ib_i$ ，另一个是 $-b_ix-a_ib_i$ ，这样无论正负，取 $\max$ 都是对的。可以自己抽象想一下。

然后分块的过程，对于整块就去给这一块打个 $tag$ ，其实就是这一块整体的 $x$ ，对于散块，把 $tag$ 下传后暴力修改，然后重构那一块的凸包。

考虑复杂度，对于修改直接暴力弄，重构的部分，对于每条直线 $ax+b$ ，我们在预处理时按照 $a$ 排序然后依次插入凸包，这样散块重构的时候，因为下传的 $tag$ 只会影响 $b$ 并不影响排序的结果，所以重构是复杂度是 $O(\sqrt n)$ 的。

考虑查询，对于散块直接枚举就行，对于整块要查询这块的凸包在 $tag$ 的位置，二分做的话会多个 $\log$ ，考虑怎么优化。

我们同时对每个块维护一个指针，在修改的时候发现 $tag$ 一定是在变大的，因为 $x>0$ ，然后将指针向右移一直移到 $tag$ 的位置，然后散块重构时指针归零，查询时直接查询整块的指针位置即可，这是一个类似双指针的过程。

这样一来，复杂度就做到了严格 $O(n\sqrt n)$ 。

这玩意能一次过也是有够离谱。

https://codeforces.ml/contest/1178/submission/156588400