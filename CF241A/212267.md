这道恶评题居然没有题解？赶紧自己发一发……

**评分建议：红**

~~一开始看题面还以为是最短路，琢磨了半天发现是模拟+贪心……~~

我们可以结合样例来分析：（此段可跳过，可直接从下一分割线处开始观赏）

样例一：

![](https://cdn.luogu.com.cn/upload/image_hosting/unkxc3pw.png)

共花费$10$小时。

此时，我们可以手造一组极端数据：

```cpp
m = 2, k = 3

d = {1, 4}

s = {2, 1}
```

此时，常规思路应为：开始$1$号城自动加的$2$升油够到$2$号城了，还剩$2-1=1$升油；自动加$1$升油后$2$升油不够到下一城，即在此地停留$3*2=6$小时后油量够了，到达下一城，共花费$1+6+4=11$小时。

这是最优解吗？不是！正确答案其实是$8$小时！

我们可以在$1$号城时就停留$3$小时，这时到达$2$号城后就有了$2+2-1+1=4$升油，够到终点站了，共花费$3+1+4=8$小时，小于常规思路的$11$小时！

------------

显然，要想时间短，就应该在油量较多的地方加油 ~~（废话）~~，所以，此时我们可以这样想：

假设一路顺风，直接利用到达一地自动加的油就到终点了（样例一），这样当然最好；否则，在路途中必然会出现断油的情况，在这种情况下，我们应当选择所有已经经过的城市中油量最多的地方应当多停一段时间加油（手造数据）。所以，我们应当先进行初始化：

```cpp
for (int i = 1; i <= m; i++) ma[i] = max(ma[i - 1], s[i]);
```

$ma_i$代表第$i$城及之前经过的所有城市中油量最多的城市所储存的油量，显然，它必然为第$i-1$座城市及之前最多的油量与第$i$座城市油量中较大数，也就有了以上代码。

此时，我们完成了初始化，随后便是统计答案的时候了。

显然，之前手造数据时我们发现在断油情况下应当选择已过的城市中油量最多的城市加油，此时可以换一种角度思考：

当走到断油的地方时，我们可以假设这辆老爷车有时光倒流的超能力，能够~~穿越时空，重临过去~~，回到之前油量最多的城市，到那里去加油，直到够到达下一座城市为止。

此时因先前已经初始化过$ma_i$，故直接将当前油量加上$ma_i$，同时答案加上$k$即可。

这时候要注意，由于可能要加多次油才能满足需求，故应重复执行直到$d_i$不大于当前油量时为止。

```cpp
//ans表示至少需要的时间（即答案）
//now表示当前油量
while (d[i] > now) {
    ans += k;
    now += ma[i];
}
```

循环结束后，当前油量还需减去途中消耗的油量（即$d_i$），答案应加上路程（亦为$d_i$）即可。
最后贴上全代码（最优解第二位，欢迎打破~）

```cpp
#include <bits/stdc++.h>
using namespace std;
int m, k, d[1050], s[1050], ans, now, ma[1050];
int main() {
    cin >> m >> k;
    for (int i = 1; i <= m; i++) scanf("%d", &d[i]);
    for (int i = 1; i <= m; i++) scanf("%d", &s[i]);
    for (int i = 1; i <= m; i++) ma[i] = max(ma[i - 1], s[i]);
    for (int i = 1; i <= m; i++) {
        now += s[i];
        while (d[i] > now) ans += k, now += ma[i];
        now -= d[i]; ans += d[i];
    } cout << ans;
}
```
