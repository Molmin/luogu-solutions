# 贪心题

### 前言

逗比题，不过这道题对于新手来讲还是很友好的。

题目链接：[$\text{Link}$](https://www.luogu.com.cn/problem/CF489B)

看到楼下的复杂度都是 $O(nlogn)$ 的，这里给个 $O(n)$ 的做法。

目前来看是最优解啊/xyx。

### 题目简述

有两个长度分别为 $n,m$ 的数列 $a,b$，当 $a$ 数列中的第 $x$ 个数和 $b$ 数列中的第 $y$ 个数的差 $\le1$，那么就说明它俩可配对且每个数至多只能被匹配一次，求最多匹配数。

~~还不如回去看题目描述~~

### 题目解析

不难想到是贪心，**与楼下唯一不同的是这里给出贪心证明**。

先说一下怎么贪心：

- 分别将 $a$ 数列和 $b$ 数列从小到大排序

- 设两个指针 $tot1,tot2$，若当前 $\mid a_{tot1}-b_{tot2}\mid\le1$，就说明又有了一组匹配，那么将 $tot1$ 和 $tot2$ 同时往后挪，否则若 $a_{tot1}<b_{tot2}$，那么将 $tot1$ 往后挪，否则 $tot2$ 往后挪。

可为啥这样，以下是证明：

如果对于一个 $a$ 数列中的一个最小的数 $a_x$，它可能和多个在 $b$ 数列的数相匹配，显然，我需要先试试 $b$ 数列中最小的一个 $b_y$，如果可行，那么赶紧配对，再试试 $a$ 数列中第 $2$ 小和 $b$ 数量中第 $2$ 小的；否则，如果 $a_x>b_y$ 说明既然 $b$ 数列最小的已经不行了，那么我们就要再次将最小的和 $a$ 匹配，反之亦然，最后以此类推，发现只是一个不断找最小值的过程，所以就要先排序。

但为什么我的算法是 $O(n)$ 呢？因为这道题中 $a_i,b_i$ 的值都非常小，故可用 $O(n)$ 的桶排/xyx。

_[$code$](https://paste.ubuntu.com/p/zmWHjZHdyD/)_

时空复杂度：$O(n)$。

$$\texttt{The End.by UF}$$