闲话：我觉得这道题应该说明一下数据是随机的。就因为这个本来想到正解了，以为会卡 $O(n^2)$,结果在这题耗了半天才知道这道题不会卡 $O(n^2)$。

先给大家说一下**子序列**的定义：
>对于序列 $a$，可任意取几个数，按照它们在原序列 $a$ 的位置顺序排列，排列后的序列就是 $a$ 的**子序列**。例如 $a=\{2,1,3\}$，它的**子序列**有 $\{2, 1, 3\},\{2 ,1\},\{2,3\},\{1,3\},\{2\},\{1\},\{3\}$。

使用贪心思想，为了字典序变小，所以先考虑高位。为了让高位变小，那可以让它与最小数（那个位置后面的最小数）交换。假如（后面的）最小数有很多一样的怎么办？先举个例（~~栗~~）子。
## 栗子
假如序列 $A$ 是这样 $t\dots s\dots s$，$t$ 为最高位，$s$ 为最小的数。

最高位与第一个 $s$ 交换后是这样 $s\dots t\dots s$。

与第二个交换后是这样 $s\dots s\dots t$。

它们按照字典序比较，是 $s\dots s\dots t$ 更小，所以如果有多个相同的最小数就与位置最靠后的数交换。
## Next
为了让**子序列** P 满足**子序列**的定义（所有的数的排列方式是按在原序列的位置顺序排列的）。那么下一个考虑的位置应该是 $t+1$，$t$ 代表上一次**被**交换的数。
## 特判
如果要考虑的位置就是最小的数呢，那就不考虑这个位了，考虑它的下一位。

## 核心代码如下
```
    	int now = 1;\\现在要考虑的位置
    	while(now < n)
    	{
    		ull minn = 1e10, w = now;
    		for(int i = now + 1; i <= n; i++)\\查找最小值
    		if(a[i] <= minn)
    		minn = a[i], w = i;
    		if(a[now] <= minn){now++;continue;}\\特判
    		swap(a[now], a[w]);
    		now = w + 1;
	}
    	ull ans = 0;
	for(ull i = 1; i <= n; i++)
	ans = ans + i * a[i];
```