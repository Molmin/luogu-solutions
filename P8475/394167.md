### update:
* 修改了排版的空格问题。

### 题目
* [P8475 「GLR-R3」雨水](https://www.luogu.com.cn/problem/P8475)

### 解析
* 我们可以将序列分割成多段：$a_1,a_2,...a_{b_1}||a_{b_1+1},...,a_{b_2}||a_{b_2+1},...,a_{b_k}||a_{b_k+1},...,a_n$，交换序列为 $\left(1,b_1,b_1+1,b_2,b_2+1,...,b_k,b_k+1,b_n\right)$。
* 此时显然满足 $a_1>a_{b_1},a_{b_1+1}>a_{b_2},...,a_{b_k+1}>a_n$ 时交换是有意义的。
* 为了使字典序最大，最小的数字一定要放在尽量的前，所以交换的数字组 $(i,j)$ 应满足 $a_i>a_j$ 且 $a_j=\min\limits^n_{k=i+1}a_k$，这样就可以将最小的数字转移到了前面，其余序列区间也这样操作即可。
* 若无法当前找出有意义的序列区间，则可以将左端点向右移。
* 由于数据较为随机，可以直接暴力跳最小值，不会有时间危险。

### 代码
* 这里就只放核心部分了，其余部分请抄题目或自己实现。

```cpp
inline void work(){
	for(int i=1;i<=n;++i){
		int cnt=i;
		for(int j=i+1;j<=n;++j){
			if(a[j]<=a[cnt])
				cnt=j;
		}
		if(a[i]!=a[cnt]) std::swap(a[i],a[cnt]),i=cnt;
	}
}
```