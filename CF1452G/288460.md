@duyi 巨佬的做法好麻烦啊，这里给出一个更容易的做法，代码难度，算法难度，和算法时间复杂度更加优秀。

---

题意：

$a$ 被 $b$ 的好多点在树上追（每回合 $a$ 先动，然后 $b$ 的所有点都单独动），$b$ 的点固定，问每一个 $a$ 的位置，$a$ 最多能保持多久不被追。

$n\leq 10^{5}$。

---

先考虑 $a$ 的逃跑路径，其中设 $dist[u]$ 表示 $u $ 到最近的 $b$ 的距离，$dis(a,b)$ 表示 $a,b$ 的距离。


考虑 $u$ 要到 $v$ 只有当 $dist[v]>dist[u] $ 时，最后的答案是$dist[v]$（跑到 $v$ 然后等死），前提是 $u \to v$ 时不被 $b$ 抓 。

反着思考，即 $u $ 可以让所有 $(dis(u,v)<dist[u])$ 的 $v$ 使 $ans[v]=\max(ans[v],dist[u])$，若只是朴素的用 $\rm bfs$ 来更新，时间肯定不够，所以我们考虑剪枝。

我们按 $dist[u]$ 降序排列，易知我们更新的时候不用取 $max$ 而是直接覆盖没被覆盖过的即可，为了避免额外的遍历，我们只需开一个数组 $now[u]$ 纪录当前遍历到 $u$ 的时候 $u$ 又去更新了与 $u$ 相距多少的节点。

注：这里这个 $now$ 比较难懂，下面放一个例子。

```
10
10 9
7 6
5 3
3 8
2 7
8 1
9 3
8 4
7 8
1
2

```

![](https://cdn.luogu.com.cn/upload/image_hosting/9x3os348.png)

当我们以 $10 $ 为 $u$ 来更新其他 $v$ 的 $ans[v]$ 时，这里的 $now[1]=1,now[8]=2,now[3]=3,now[10]=5……$

---

当我们$\rm bfs $ 到一个点时，若此时的 $u$ 给予下一个点的更新距离小于 原有的更新过的距离，那么就可以剪掉这个枝。

这部分的代码：

```cpp
for (int i = maxDist; i > 0; i--)
{
    for (auto u:P[i])//取出dist[u]=i的u 
    if (now[u]<dist[u])
    {
        if (!ans[u]) ans[u] = i;
        now[u]=i;
        Q.push({i, u});
    }
    while (!Q.empty())
    {
        int d = Q.front().first;
        int u = Q.front().second;
        Q.pop();
        if (--d==0)continue;
        for (auto v:E[u])
        {
            if (now[v] < d)
            {
                if (!ans[v]) ans[v] = i;
                now[v] = d;
                Q.push({d, v});
            }
        }
    }
}
```

复杂度总体来说是 $O(n\log n)$ 的，至少排序带一个 $\log $，后面部分也是 带$\log $的。

但后面部分复杂度证明我不太会，但是可以感性理解，比如说第一次 $u$ 离最近的 $b$ 那部分的 $now[v]$ 是不会被更新的，而 $u$ 并非随便取的，而是取相对所有 $b$ 最远。大概最终效果和启发式合并或者点分治差不多，真要严谨证明可以去看官方题解。






