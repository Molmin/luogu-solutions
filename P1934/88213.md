一道一维动态规划的好题。

对于所有$DP$的题目，我们都可以从定义、状态转移方程、边界（即初始化）和目标来分析。

首先我们来定义$f$数组。

由于本题求的是最小消耗元气值，所以我们可以这样定义：

令$f_i$为从第$1$层打到第$i$层的最小元气消耗值。

那么，由题意可得方程：

$f_i=min\{f_{j-1}+(a_i+a_j)·\sum\limits_{k=j}^ia_k\}$
$(1\leq{j}<i,a_i+a_j\leq t)$

接下来考虑边界。

易得$f_0=0$。

又因为单独打破一层也会消耗元气，那么我们可以把$f_i$的初始值设定为：$f_i=f_{j-1}+a_i·n^2$

最后考虑目标。

由定义易得，目标（即所求答案）为$f_n$

那让我们来分析一下时间复杂度：

遍历$i$和$j$就需要花费$O(n^2)$的时间，如果求和还需要依次累加的话，那么总共的时间复杂度为$O(n^3)$，不可过。

那我们就得引进前缀和来解决问题了。

设$s_i=\sum\limits_{k=1}^ia_k$，运用减法易得$\sum\limits_{k=j}^ia_k=s_i-s_{j-1}$

而前缀和可以在读入时预处理，那么求和的时间复杂度降为$O(1)$，总时间复杂度为$O(n^2)$，可过。

$AC$ $Code$ 

```cpp
#include <iostream>
using namespace std;

long long s[1010], a[1010], n, t;
long long f[1010];//注意，要开long long

int main() {
	cin >> n >> t;
	for (int i=1; i<=n; i++) {
		cin >> a[i];
		s[i] = s[i-1]+a[i];
	}//读入+预处理前缀和
	f[1] = a[1]*n*n;//初始化f[1](与我前文中的初始化本质一样)
	for (int i=2; i<=n; i++) {
		f[i] = f[i-1]+a[i]*n*n;//初始化f[i]
		for (int j=1; j<i; j++)
			if (a[i]+a[j]<=t) f[i] = min(f[i], f[j-1]+(a[i]+a[j])*(s[i]-s[j-1]));//方程求解
	}
	cout << f[n] << endl;//输出答案
	return 0;//完结撒花！
}
```