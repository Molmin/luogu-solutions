本蒟蒻第一次写题解，如有错误请指正
## 题目大意


有 n 个封印，每个封印有坚固值 $a_i$，有两种方法打破封印：
- 花费 $n^2\times a_i$ 的元气，打破第 i 层封印。
- 在 $a_i+a_j\leqslant t$ 时，花费 $(a_i+a_j)(\sum\limits_{k=i}^j a_k)$ 打破第 i-j 层封印。
- $n\leqslant 10^3$，$a_i\leqslant2\times10^4$，所以 $n^2\times a_i$ 以及 $(a_i+a_j)(\sum\limits_{k=i}^j a_k)$ 可能会超出 ```int``` 范围，使用 ```long long int```。

求最小消耗元气。

## 方法


由于该题存在多种相似的状态，故可使用 dp 求最小值，求区间之和可使用前缀和优化，前缀和的时间复杂度 $O(n)$，在前缀和优化后本题时间复杂度为 $O(n^2)$。
### 关于前缀和
注：在此仅概述一维前缀和。

前缀和本蒟蒻一般用数组存储（以下用 $r_i$ 表示），其主要思想为：

1. 记录前 1-i 个数之和
```cpp
//令共有 n 个数，每个数为 a
	for(int i=1;i<=n;++i){ //i 从 1 开始防止 r 数组越界
   		scanf("%lld",&a[i]);
   		r[i]=r[i-1]+a[i];
	}
```

2. 用前缀和求出 i-j 区间中 a 的和，用 $r_j-r_{i-1}$ 表示，注意，i 要减去 1，因为减去 $r_i$ 时，同时减去了 $a_i$ 的值($r_i$ 中加入了 $a_i$)

举个例子
|  $a_i$|$a_1=1$|$a_2=3$|$a_3=2$|$a_4=4$|$a_5=5$|
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| $r_i$ |$r_1=1$|$r_2=r_1+3=4$|$r_3=r_2+2=6$|$r_4=r_3+4=10$|$r_5=r_4+5=15$
当求 $a_2$ 至 $a_4$ 的和时，就可用 $r_4-r_1=10-1=9$ 得出结论。

下面给出公式的推导，从中能看出为何 i 要减去 1。

$a_i+a_{i+1}+a_{i+2}+...+a_j$

$=(a_j+a_{j-1}+...+a_2+a_1)-(a_{i-1}+...+a_2+a_1)$

$=r_j-r_{i-1}$

如仍不理解可自行画图。~~其实是我画不好~~。

### 关于 dp
这个我就不详细说了。~~我自己也不太行~~。主要就是找出动态转移方程，就我而言，一般就是：

现在的最好情况 $=$ 几种方案中，哪个好，选哪个。

由上述得该题的动态转移方程为：

$f_i=\min(f_{i-1}+n^2\times a_i,(a_i+a_j)\times(r_i-r_{j-1})+f_{j-1})$

解释：

$f_{i-1}+n^2\times a_i$ 为第一种方案，即打破当前层封印后消耗元气总数。

$(a_i+a_j)\times(r_i-r_{j-1})+f_{j-1}$ 为第二种方案，即打破第 j-i 层封印，因而后面加上的为 $f_{j-1}$ 而非 $f_{i-1}$。其中的 $r_i-r_{j-1}$ 为前缀和求和。

## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
long long int n,t,a[1010],r[1010],f[1010];
int main(){
    memset(f,0x7f7f,sizeof(f));
    f[0]=0;
    scanf("%lld%lld",&n,&t);
    for(int i=1;i<=n;++i){
        scanf("%lld",&a[i]);
        r[i]=r[i-1]+a[i];//求出前缀和
    }
    for(int i=1;i<=n;++i){//枚举当前层数或 j-i 层的终点 i
        f[i]=f[i-1]+pow(n,2)*a[i];//先赋值，避免当 a[i]+a[j] 一直 >t 时，f[i] 未赋正确的值导致还为 0x7f7f
        for(int j=1;j<i;++j){//枚举第二种方案的起点 j
            if(a[i]+a[j]<=t){
                f[i]=min(f[i],(a[i]+a[j])*(r[i]-r[j-1])+f[j-1]);
            }
        }
    }
    printf("%lld",f[n]);
    return 0;
}
```
结束
