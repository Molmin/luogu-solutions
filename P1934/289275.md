~~明显~~考虑动规。

假设 $f_i$ 表示打破前 $i$ 层封印所需要的最少元气。

首先题目中：

> 打破一层封印时需要消耗的元气为该层封印的坚固值和封印总层数 $n$ 的平方的乘积。

可以得到其中一个转移方程：

$f_i=\min(f_i,f_{i-1}+a_i \times n^2)$。

其次，我们需要枚举在区间 $[1,i)$ 中的 $j$，来枚举连续打破 $[i,j]$ 区间的最小元气值。

根据题目中的信息可以总结出：

> 如果满足 $a_i+a_j\leq t$，即可花费 $[i,j]$ 的所有封印的坚固值之和乘以 $(a_i+a_j)$。

然而，如果区间 $[i,j]$ 的封印的坚固值之和用循环来算的话时间复杂度为 $O(n^3)$，明显超时。因此这个区间和可以用前缀和来预先处理好。~~这就是为什么标签里有个前缀和。~~

所以可以得到代码：

```cpp
#include<bits/stdc++.h>
#define int long long//数据较大，需要long long
using namespace std;
int n,t;
int a[1009];
int f[1009];
int sum[1009];
signed main(){
	cin>>n>>t;
	for(int i=1;i<=n;i++){
		cin>>a[i];
		sum[i]=sum[i-1]+a[i];
		f[i]=10000000009;//赋个大值！一开始我没有赋那么大就只有30分
	}
	for(int i=1;i<=n;i++){
		f[i]=min(f[i],f[i-1]+a[i]*n*n);//第一个转移方程
		for(int j=1;j<i;j++){
			if(a[i]+a[j]<=t)/*注意是有条件的！*/ f[i]=min(f[i],f[j-1]+(a[j]+a[i])*(sum[i]-sum[j-1]));//第二个转移方程
		}
	}
	cout<<f[n];//f[n]即为打破这n层封印所需要的最小值
}
```
