# 题解CF335A Banana

### 题目描述

Piegirl 正在为一个项目买贴纸。贴纸粘贴在纸张上，每一张纸都包含正好 $n$ 张贴纸。每一张贴纸上恰好只印了一个字符，所以纸张可以用一个长度为 $n$ 的字符串来描述。

Piegirl 想用贴纸创造一个字符串 $s$。她可以购买任意数量的纸张，并且可以把这些纸张指定为长度为 $n$ 的任意字符串，但是所有的纸张必须相同，因此所有纸张的字符串都是相同的。一旦她拿到了纸张，她会从纸张上取下一些贴纸，然后（按任意顺序）排列成 $s$。

确定她必须购买的最小纸张数，并提供一个字符串，描述她应该购买的可能的纸张。

如果没有符合要求的纸张，输出 `-1`。

### $Solution$

首先我们统计字符串中每个字符的出现个数，如果个数 $k > n$，显然无解。

如果有解，我们就要计算最少需要的纸张数。

怎么计算呢？

我们可以把所有字符存入一个优先队列，显然需要最多的字符总数除以当前添加到纸张字符串中的字符数（向上取整）就是答案。

用这个对字符进行比较，每一次对于最需要的字符数加一。

因为每个字符都肯定会出现，所以初始值都为一。

### $C++ \quad Code$

```c++
#include <bits/stdc++.h>
#define R register
using namespace std;

char s[1010],ans[1010];int n,t,l,f[30],p;
struct ch{
	int k,a;										// k 指该字符总数，a 指当前字符数
	char c;
	ch(){}
	ch(int _k,char _c):k(_k),a(1),c(_c){}			// a 的值即为初始化 1
	int st(){return (k-1)/a+1;}						// 按照目前选择计算，总共需要的纸张数目
}h[30];

bool operator <(ch a,ch b){
	return a.st()<b.st();							// 根据需要纸条数进行比较
}
priority_queue<ch> q;
int main(){
	scanf("%s%d",s,&n);
	l=strlen(s);
	for(R int i=0;i<l;i++)++f[s[i]-'a'];
	for(R int i=0;i<26;i++)
        if(f[i])
            q.push(ch(f[i],'a'+i)),					// 如果有该字符，则加入优先队列
    		ans[p++]='a'+i;							// 每一个字符都是必须的，所以开始就应该加入答案序列
	if(n<q.size()){printf("-1\n");return 0;}		// 如果纸张长度连字符数都不够，显然不行
	ch c;
	for(n-=q.size();n;--n){							// 之前已经添加过每个字符了，所以循环次数要减掉字符数
		c=q.top();q.pop();
		ans[p++]=c.c;
		c.a++;										// 如果还可以选择，那么最缺的优先
		q.push(c);
	}
	c=q.top();
	printf("%d\n",c.st());							// 最后队首元素需要的值即为答案
	puts(ans);
	return 0;
}
```





***by jsntsys***

$2020.11.30$

红名祭

upd 2020.12.2:更正了题目描述和一处笔误。