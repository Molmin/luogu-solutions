## 题意
有 $n$ 个数,每一次取一个 $x$，并将所有值为 $x+1$ 和 $x-1$ 的数都删除，每取一个数，就要加上被取的数，问最后被取的数的和最大时是多少。

## 思路
用 $a$ 数组统计每个数出现的次数， $a[i]$ 表示第 $i$ 个数出现的次数。

然后就该开始 $dp$ 了， $dp[i][0]$ 表示不取当前这个数， $dp[i][1]$ 表示取这个数。 $dp[i][0]=max(dp[i-1][0],dp[i-1][1])$ ，因为如果不取当前这个数，那么前一个数可以取也可以不取。
 $dp[i][1]=dp[i-1][0]+a[i]*i$ ，因为，如果取当前这个数，上一个数就不能取，但要加上这个数的个数乘这个数。

## 代码
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int m,a[100005],dp[100005][5];
signed main()
{
	int n,d=0;
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>m;
		if(m>d) d=m;//记录最大的数 
		a[m]++;//每个数出现的个数
	}
	dp[1][1]=a[1];//初始化 
	for(int i=1;i<=d;i++)
	{
		dp[i][0]=max(dp[i-1][0],dp[i-1][1]);//不取 
		dp[i][1]=dp[i-1][0]+a[i]*i;//取 
	}
	cout<<max(dp[d][0],dp[d][1]);//最大值 
    return 0;
}
```
