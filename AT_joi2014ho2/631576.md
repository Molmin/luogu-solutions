# [IOI 饅頭](https://www.luogu.com.cn/problem/AT_joi2014ho2)
~~模拟赛的时候没看到这题所以写个题解纪念一下。~~
# 题意简明
你有 $m$ 个大小相等且有价格的馒头和 $n$ 个有容积与价格的盒子，每种馒头和盒子只有一个，可以把馒头装进盒子里。

一个盒子带来的利润 $=$ 盒内馒头的总价值 $-$ 盒子的价格。求最大可能的利润。
# 思路分析
## 设状态
看完题面，刻在 DNA 里的经验告诉我们这题应该是个 [0/1 背包](https://www.luogu.com.cn/paste/1qtp07x1)。于是，我们往背包的方向去想。我们把每个盒子看成一个物品，把盒子的**价格**看成物品的**价值**，把盒子的**容积**看成物品的**重量**，把**馒头**看成要获得的**总价值**。那么 $dp_i$ 就表示装 $i$ 个馒头所需要的最小代价。状态就搞定了。
## 推方程
这时候可能有人会问：我们希望盒子的价格尽量小，但希望物品的价值尽量大。怎么能把这两个看起来相反的状态联系在一起呢？

没错，这就是本题和 0/1 背包的区别。本题中，我们希望 $dp_i$ 的值尽量小，也就是使成本更小。然后我们就得出了方程。
$$dp_i=\min(dp_i,dp_{i-c_j}+e_i)$$
其中，$j$ 为当前枚举到的盒子。大家应该也发现了，本题方程中取 $\min$，0/1 背包中取 $\max$。
## 看细节
在高兴的打完代码后，发现 WA 了。仔细检查后发现，本题中的 $c_i$ 并不一定小于 $m$。也就是说，**有些盒子不能百分之百利用**。当 $c_i>m$ 时，取 $c_i=m$ 即可。同样的，要取 $dp_i=\max(dp_i,dp_j)$，$1\le i<j\le n$。

馒头的大小是一样的，但价值不一样，那肯定选价值大的呀，可以先 $sort$ 一遍。计算答案时，我们已经求出了装 $i$ 个馒头的最小花费。那么答案为 $ans=\max(sum_i-dp_i)$。其中 $sum_i$ 是用前缀和处理出来的前 $i$ 大的馒头价值之和。

总复杂度 $O(nm)$，输出记得换行哟。
# 代码实现
```cpp
#include <bits/stdc++.h>
using namespace std;
int n,m,a[10005],c[505],v[505],dp[10005],sum,ans;
bool cmp(int x,int y)
{
	return x>y;
}
int main()
{
	scanf("%d%d",&m,&n);
	for(int i=1;i<=m;i++)
	{
		scanf("%d",&a[i]);
		dp[i]=1e9;
	}
	sort(a+1,a+m+1,cmp);
	for(int i=1;i<=n;i++)
	{
		scanf("%d%d",&c[i],&v[i]);
		c[i]=min(c[i],m);//细节
	}
	for(int i=1;i<=n;i++)
	{
		for(int j=m;j>=c[i];j--)
		{
			dp[j]=min(dp[j],dp[j-c[i]]+v[i]);
		}
		for(int j=m;j>1;j--)
		{
			dp[j-1]=min(dp[j-1],dp[j]);
		}
	}
	for(int i=1;i<=m;i++)
	{
		sum+=a[i];//前缀和
		ans=max(ans,sum-dp[i]);
	}
	printf("%d\n",ans);//记得换行
	return 0;
}
```
希望本篇题解可以帮到大家！！！