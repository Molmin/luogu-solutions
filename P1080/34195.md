我们首先看题面里有这样一句话：

“排在该大臣前面的所有人的左手上的数的乘积除以他自己右手上的数，然后向下取整得到的结果。”

很明显，这是一道贪心。

证明这是贪心（伪）：

```cpp
设国王左右手为a0、b0
设大臣左右手为a1、b1,a2、b2,......
将大臣编号为1,2,3,......,n
大臣k的奖金为a0*a1*......*ak-1/bk(不会latex,多多包涵，意会即可)
对于该大臣，很明显前面怎么排对他的奖金获得是没有影响的
```
既然有了刚才的证明（？）

就可以开始推贪心的解法了
```cpp
我们取相邻的两名大臣x,x+1为研究对象，其奖金数为sx,sx+1,则有：
sx=a0*a1*a2*......*ax-1/bx
sx+1=a0*a1*a2*......*ax/bx+1
ans=a0*a1*...*ax-2*max(ax-1/bx,ax*ax-1/bx+1)
如果交换x,x+1，则
sx=a0*a1*a2*......*ax-1*ax+1/bx
sx+1=a0*a1*a2*......*ax-1/bx+1
ans=a0*a1*...*ax-2*max(ax+1*ax-1/bx,ax-1/bx+1)
我们只考虑当前位置的最优解,则看交换和保持当前位置哪个更优
若max(ax-1/bx,ax*ax-1/bx+1)>max(ax-1/bx+1,ax*ax-1/bx)，说明此时应该交换
很显然ax-1/bx<ax*ax-1/bx,ax-1/bx+1<ax*ax-1/bx+1
所以我们可以化简一下，只比较ax+1*ax-1/bx和ax*ax-1/bx+1的大小
继续化简:只比较ax+1*bx+1和ax*bx的大小
```
推这个费了我老长时间（雾）

接下来就可以直接写代码了，记得是冒泡排序，最后统计结果时用高精度

代码太丑就不放了