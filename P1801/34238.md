楼下好多dalao QAQ

我的方法是用堆解

当然普通的堆排序暴力模拟是无法通过的（30分）

便有一种思路

有两个堆h1、h2

h2储存整个序列的前i个最小值，保证h2的大小永远等于i，大根堆，根即为每次需要Get的值

h1储存序列剩下部分的值，小根堆

每一次操作就是先按照u(i)（在我的代码里用的是b[i]）Put(a[j])进到h1

然后因为有u的存在，所以往h2 Put一个数，即为h1的最小值

但是这时候有可能h1中会有比h2任何一个节点小的节点，这样的h2是不符合规定的，于是反复判断h1和h2的根节点（一个是h1最小，一个是h2最大），如果h1的根节点小于h2的根节点，则取出h1和h2的根节点，然后将h1的根节点Put进h2，h2的根节点Put进h1，直到h2的根节点小于h1为止

输出h2

下面的代码我用的是自己手写的堆模板（无聊写的），不是STL的。

Heap<typename,size>代表定义一个typename为类型，大小为size的堆

h1.Put(x);代表往h1这个堆里面Put进x这个数

h1.(1);代表取出h1的根节点，返回这个节点的值。

h1[i];就代表h1的第i个数，根节点是1。

h1.size代表h1的大小，没有节点为0,1个节点为1……

该代码耗时360ms，空间3566KB

（感觉这题难度没有那么大）


Heap<int,5000005> h1,h2(1);  //定义h1为小根堆，h2为大根堆

```cpp
int a[200005],b[200005];  //定义输入用的数组
int main()
{
    ios::sync_with_stdio(false);  //关闭同步，优化
    int m,n;
    cin>>m>>n;//输入就不说了
    for(int i=0;i<m;i++)
        cin>>a[i];//读入a[i]
    for(int i=0;i<n;i++)
        cin>>b[i];//读入u[i]
    int c,t;
    for(int i=0,j=0;i<n;i++)
    {
        for(;j<b[i];j++)  //Put进a的前几个数
            h1.Put(a[j]);
        c=h1.Get(1);  //在h2里面放入h1的根节点，为了保证h2的大小永远等于i
        h2.Put(c);
        while(h1.size>0&&h1[1]<h2[1])  //如果h1有节点并且h1的根节点小于h2的根节点，那么就要“交换”
        {
            t=h2.Get(1);  //取出h2的根节点
            c=h1.Get(1);  //取出h1的根节点
            h1.Put(t);  //放入节点
            h2.Put(c);
        }
        cout<<h2[1]<<endl;  //输出第i小的节点
    }
    return 0;
}
```