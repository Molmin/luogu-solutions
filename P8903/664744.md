历经千辛万苦终于过了......

# solution



- 对于本题而言，每个人都可以有选或不选两种情况，因此很明显这是个背包题。


### solution搜索
- 老规矩，深搜找找规律。定义四个维度分别为 $k$，$s1$，$s2$，$s$，分别表示当前搜到第 $k$ 个人，花费了 $s1$ 个哞尼和 $s2$ 个冰淇淋，得到了 $s$ 的价值。

- 这里有一个小陷阱，就是每个人可以**多次用冰淇淋来换 $1$ 的哞尼**，这样的话就变得棘手了许多。

- 每一层的搜索分支就会很多：首先是不选，那么递归下一层，剩下三个变量都不变。如果选呢？换不换哞尼呢？换几个哞尼？这样需要枚举一遍可能的情况，枚举 $i$ 为换哞尼的数量，则 $i$ 从 $0$ 开始枚举，我们定义第 $k$ 位朋友要 $c_{k}$ 个哞尼，$x_{k}$ 个冰淇淋换一个哞尼，共有 $b$ 个冰淇淋，由于不能让朋友倒贴哞尼，因此最多换的哞尼数量是：
$$\min(c_{k},(b-s2) \div x_{k})$$

- 这样的暴搜可以拿到 $30pts$，贴上核心代码：

```cpp
void dfs(int k,int s1,int s2,int s){
	if(s1>a) return;//可行性剪枝
	if(k>n){
		ans=max(ans,s);
		return;
	}
	dfs(k+1,s1,s2,s);
	for(int i=0;i<=min(c[k],(b-s2)/x[k]);i++){
		dfs(k+1,s1+c[k]-i,s2+i*x[k],s+p[k]);
	}
}
```

- 在此基础上我们加上最优性剪枝就变成了 $40pts$：

```cpp
if(f[k][s1][s2]>=s) return;
	f[k][s1][s2]=s;
```

- 最后我们把能优化的全部优化，变成 $60pts$：

```cpp
int dfs(int k,int s1,int s2){
	if(s1>a) return -1e9;
	if(f[k][s1][s2]!=-1) return f[k][s1][s2];
	if(k>n) return 0;
	int p1,q=-1e9;
	q=dfs(k+1,s1,s2);
	for(int i=0;i<=min(c[k],(b-s2)/x[k]);i++){
		p1=dfs(k+1,s1+c[k]-i,s2+i*x[k])+p[k];
		q=max(q,p1);
	}
	return f[k][s1][s2]=q;
}
```

### solution背包

- 此时我们观察数据范围，注意到有 $B=0$ 的数据，所以特判一下这种情况，然后跑一边裸的背包，就变成了 $75pts$，这应该正解之外能拿到的最高分数，大家可以检测一下在很难想到正解的情况下能否把该拿的分都拿到。

- ~~正解我也没怎么想到，还参考了网上的一些想法。~~

- 定义两个数组 $f1$ 和 $f2$，**$f1_{i,j}$ 表示前 $i$ 个人只花 $j$ 个冰淇淋作代价所有的最大价值，$f2_{i,j}$ 表示后 $i$ 个人只花 $j$ 个哞尼所有的最大价值**。

- 这样在跑 $f1$ 数组时有个贪心策略，就是对 $c$ 进行排序，花费小的排在前面，这样我们能最大化价值，因此需要结构体。

- 以下是全部用冰淇淋的核心代码，有注释：

```cpp
for(i=1;i<=n;i++){
		for(j=0;j<=b;j++){
			f1[i][j]=f1[i-1][j];//全用冰淇淋即d[i].c*d[i].x
			if(j>=d[i].c*d[i].x) f1[i][j]=max(f1[i][j],f1[i-1][j-d[i].c*d[i].x]+d[i].p);//标准背包
		}
	}
```

- 其次全部不用冰淇淋跟 $B=0$ 的代码一致，是裸的背包。

- 定义结构体 $d$，$d_{i}.c$ 表示第 $i$ 个人需要的哞尼，$d_{i}.p$ 表示价值，$d_{i}.x$ 表示换 $1$ 个哞尼需要的冰淇淋数量。

- 那么两个混合用怎么处理呢？定义 $i$ 为当前枚举到第 $i$ 位朋友，$j$ 为对于当前朋友而言我花 $j$ 个哞尼，那么剩下的需要花费 $(d_{i}.c-j) \times d_{i}.x$ 个冰淇淋，那么需要满足 $(d_{i}.c-j) \times d_{i}.x \le b$ 才可以进行 $\max$ 的比较。

- 在满足情况的条件下，设 $ans$ 为最终答案，则有以下式子：

$$ans=\max(ans,f1_{i-1,b-(d_{i}.c-j) \times d_{i}.x}+f2_{i+1,a-j}+d_{i}.p$$

- 这里要提一下，$f2$ 数组要从后往前推，这是为了得到以上式子时价值不重复，即如果两个都从前往后推很可能同一状态下两个数组中记录的价值会有重复。而两个数组不同方向推就不会重复。

- 依旧是提供核心代码：

```cpp
for(i=1;i<=n;i++){
		for(j=0;j<=d[i].c;j++){
			if((d[i].c-j)*d[i].x<=b && j<=a){
				ans=max(ans,f1[i-1][b-((d[i].c-j)*d[i].x)]+f2[i+1][a-j]+d[i].p);
			}
		}
	}
```

- 结束了这道毒瘤题目，写的好像有点长。