# 【P7071题解】有趣的拆分
> 	一个刚从考场上下来的蒟蒻


## 前言

CSP2020的第一道题,总体来说很~~水~~

### 题目分析
简单模拟,注意做题技巧~~相信过了初赛的都能AC~~

题目说把$n$拆分成多个2的正幂次幂之和,显然，肯定是叫我们枚举2的幂,如果大于$n$,就输出答案,同时更新$n$。
    
    那么问题来了？是从小到大枚举幂还是从大到小呢？
    答案是从大到小.原因请看下面的例子


```c
6=4+2
```

此处是从大到小（可证此为唯一解）

```c
6=1+2+?
```

此处是从小到大(显然错误)

    但是如果从大到小，2的幂初始值就不知道怎么赋，这就要用到下文的技巧1

#### 技巧1：打表
>是的你没有看错,这道题真的可以**打表**

	前面我们为了2的幂而纠结,再一看数据范围 1e7。灵机一动写了下面的一个程序
```c
#include<bits/stdc++.h>
using namespace std;
int main(){
    int n=1,cnt=0;
    while(1){
        if(n>=1e7)break;
        n=n*2;
        cnt++;
    }
    cout<<cnt;
    return 0;
}
```
	输出24.
    
   	这意味着在数据范围内有24个2的正整数幂.并不是很多，所以为什么不设数组p,p[i]表示2的i次幂.判断时直接访问p数组中的值.于是有了如下代码：
 
```c
for(int i=1;i<=25;i++){//给p数组赋初值
    p[i]=t;
    t=t*2;
}
```
### 怎么拆
逆序枚举p数组,若n<p[i],将p[i]存入答案数组中,更新i
```c
int ns=1;
    for(int i=25;i>=1;i--){
        if(n<=p[i]){
            ans[ns]=p[i];//存储答案
            ns++;//答案个数加一
            n-=p[i];//更新n
        }    
    }
```

### 关于无法拆分
    很简单,拆分完不为0就是无法拆分
## Code
```c
#include<bits/stdc++.h>
using namespace std;
int p[30],ans[30];
int main(){
    int n,t=2;
    cin>>n;
    for(int i=1;i<=25;i++){//给p数组赋初值
        p[i]=t;
        t=t*2;
    }
    int ns=1;
    for(int i=25;i>=1;i--){
        if(n<=p[i]){
            ans[ns]=p[i];//存储答案
            ns++;//答案个数加一
            n-=p[i];//更新n
        }    
    }
    if(n!=0){//没有拆完
        cout<<-1;//不能完美拆分
        return 0;
    }
    for(int i=1;i<=ns;i++)cout<<ans[i]<<" ";//输出答案
    return 0;
}

```
