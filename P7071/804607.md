# 空间复杂度 $O(1)$ 的做法

本题还可以使用 highbit 来做……

所谓 hightbit，其实就是一个这样的东西：

```cpp
int highbit(int x){
	for (int i=1; i<=16; i <<= 1) x |= (x >> i);
	return x ^ (x >> 1);
}
```

设 $x$ 在二进制下的最高有效位为 $k$，那么它返回 $2^k$。

也可以理解成设 $2^k \le x \le 2^{k+1}$，那么它会返回 $2^k$。

首先，大家都知道 `|=` 和 `>>` 的意思吧（不懂的自行百度）。

那么为什么它可以做到呢？

1. $i=1$ 时把最高位 $1$ 右移 $1$ 位，并与原数据按位取或。那么这就使得最高位和它的下一位是连续 $2$ 个 $1$。
2. $i=2$ 时把最高位 $1$ 右移 $2$ 位，并与原数据按位取或。那么这就使得最高位和它的后三位是连续 $4$ 个 $1$。

以此类推，直到循环结束，此时 $x$ 从最高有效位 $k$ 位一直到第 $1$ 位都是 $1$。

将其右移一位后就是从 $k-1$ 位一直到第 $1$ 位都是 $1$。

然后再用 $x$ 异或一下，则后面的 $k-1$ 位都是 $1\oplus1=0$，而第 $k$ 为则是 $1\oplus0=1$。所以返回的就是 $2^k$。

虽然有一个循环，但是它的时间复杂度是 $O(\log w)$，其中 $w$ 是整型位数。（基本上可以看作常数了，毕竟它最高也就是 $7$）

AC 代码如下：

```cpp
#include <bits/stdc++.h>
using namespace std;

int highbit(int x){
	for (int i=1; i<=16; i <<= 1) x |= (x >> i);
	return x ^ (x >> 1);
}

int n, k;

int main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	
	cin >> n;
	
	if (n & 1){
		cout << -1;
		return 0;
	}
	
	while (n){
		k = highbit(n);
		cout << k << ' ';
		n ^= k;
	}
	
	return 0;
}

```

时间复杂度为 $O(\log n \log w)$，空间复杂度为 $O(1)$。

话说我是不是题解区里唯一一个 $O(1)$ 空间复杂度的呀，其它的好像都是 $O(\log n)$。

UPD：好像有一个也是 $O(1)$ 空间复杂度的，但是它的时间复杂度貌似是 $O(\log^2n)$，不算很优。