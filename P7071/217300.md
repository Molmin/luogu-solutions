### 前言
AFO
### 正文

每一个可以表示为 $2^k$ 的数在二进制下只有一个位置上的数是 $1$ 。具体地,$2^k=1\ \text{lsh}\ k$，其中 $\text{lsh}$ 表示位运算中的按位左移。

那么我们可以对于这个数在二进制下的每一位进行分析。

比如：对于十进制数 $(233)_{10}$,它对应的二进制数为 $(1110 1001)_2$。

它等于

$\ \ \ (\ 10000000\ )_2$

$+(\ 01000000\ )_2$

$+(\ 00100000\ )_2$

$+(\ 00001000\ )_2$

$+(\ 00000001\ )_2$

也就等于

$1\text{lsh}8+1\text{lsh}7+1\text{lsh}6+1\text{lsh}3+\text{lsh}0$

也就等于

$2^8+2^7+2^6+2^3+2^0$。

那么我们可以得出解法：**对于一个二进制数$x$,如果它的第$k$位是$1$,那么输出$2^k$**。

~~那么如何判断第 $k$ 位是不是 $1$ 呢~~？

我们只需要构造一个只有第 $k$ 位是 $1$ 的二进制数，然后将这两个数按位与一下就可以了。~~自己证明一下吧，很简单的。~~

代码：
```cpp
#include<iostream>
#include<algorithm>
#include<stdio.h>
#include<cmath>
using namespace std;
int n;
void solve(){
	scanf("%d",&n);//输入n
	if(n&1)//特判一下，如果n是奇数，那么需要输出2^0不符合题意。
		return(void)puts("-1");
	int si=(int)(log(n)/log(2))+1;//二进制下数字有几位
	for(int k=si;k>=1;k--)//从高位往低位枚举
		if(n&(1<<k))printf("%d\n",(1<<k));//如果这位是1，那么输出2^k
	return ;
}
int main(){
	solve();
}
```


时间复杂度$\Theta(\log n)$

