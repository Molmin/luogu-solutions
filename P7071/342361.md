### 题目难度：入门至普及-之间
打开卷子的一瞬间，看到这题，~~不由感慨：第一题还是一如既往的水~~。于是接下来就是直接写了个无脑的大搜索，样例都过了。可是提交完之后往第二题翻的时候，看到了：
对于100%的数据, $1≤n≤1*10^7$.

幸好看到了这个。。。不然就凉了！

------------
### 下面是正解：
我们都知道一个叫做二进制的东西，这道题用二进制做可以用$O(nlogn)$的时间复杂度解决。
### 思路：
我们知道一个数转成二进制是将这个数不断对二取模再除以二，余数逆序排列。

就比如把173转成二进制数：

![](https://img-blog.csdnimg.cn/20190322133542835.png)



根据短除法，二进制数的最右边一位是$2^0$位

其次第二位是$2^1$位$......$

也就是说如果第$n$位上的数字是$1$，那么这个数字1就相当于十进制中的$2^{n-1}$

根据这些，我们同样可以吧173分解成$2^0+2^2+2^3+2^5+2^7$

因为有$2^0$的存在，所以它不是“优秀的拆分”。

所以我们只需要把n进行二进制转换，判断是否有$2^0$位，没有就输出按照它的二进制拆分出来的结果，二进制拆分出来的结果只要没有$2^0$存在，就一定是“优秀的拆分”。

那么为什么，这样拆分出来的结果一定是“优秀的拆分”呢：

首先，我们按照二进制拆分出来的数的和，一定等于被拆分数，且拆分出来的每一个数一定都为$2$的非负数次幂，只要排除$0$，就能将n分解为不同的 2 的正整数次幂。

但是题目还有一个要求：不同的，因为二进制只有$0$和$1$，只能表示有或者没有，所以拆分出来的数更不存在重复的情况。

### 下面见代码：
```cpp
//满分做法：O（nlogn） 
# include <iostream>
# include <algorithm>
# include <cstring>
# include <cstdio>
using namespace std;
int a[100000];
long long ans[100000];
int f(int z)
{
	int sum = 1;
	for (int i = 1; i <= z; i++)             //计算2的z次方 
	{
		sum *= 2;
	}
	return sum;
}
bool cmp(int x, int y)       //从大到小排序 
{
	return x > y;
}
int main()
{
	int n;
	cin >> n;
	int p = 0; 
	while (n > 0)      //将n转换成二进制 
	{
		a[p] = n % 2;
		n /= 2;
		p++;
	}
	if (a[0] == 1)     //如果说2的0次方位有数，则不满足拆分成正整数次幂。 
	{
		cout << -1 << endl;
		return 0;
	}
	int l = 0;
	for (int i = 1; i < p; i++)  //如果2的0次方位为0，则存在优秀的拆分 
	{
		if (a[i] == 1)          //如果在第i位上有数，说明能拆分 
		{
			ans[l] = f(i);        //将拆分出来的数记录在ans数组里 
			l++;
		}
	}
	sort(ans, ans + l, cmp); //从大到小排序结果 
	for (int i = 0; i < l; i++)  //输出 
	{
		cout << ans[i] << " ";
	}
	cout << endl;
	return 0;
}
```
### 总结：
这道题虽然作为今年csp普及组的第一题，但是有一些思维难度，主要是优化比较难想到。这道题的难度基本上相当于往年noip普及组$1.5$题左右的难度。

最后祝大家rp++，稳拿一等奖！！！