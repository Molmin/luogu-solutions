我们可以发现，如果前一个相邻的 $0$ 在 $1$ 前面，那么下一个相邻不同的两位一定是 $1$ 在 $0$ 前面。因此我们只要看第一个不同的就行了。记相邻两数不同的数量为 $k$ 。

先拿一个例子来分析一下：
```
6
100010
```
想要它单调不下降，遇到 $1$ 在 $0$ 前面的，肯定要调换位置。第一次调整过后如下：
```
011101
```
这样我们发现，原来 $0$ 在 $1$ 前面的变成了 $1$ 在 $0$ 前面。由此我们可以推出，当第一个不相同的是 $1$ 在 $0$ 前面，答案就是 $k$ 。

再看一个：
```
7
0101010
```
它的第一对相邻的不同数字不需要调整，那么答案就是 $k-1$ 。

代码也很简单，如下：

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=1e5+10;
int t,n;
char a[N];
int main()
{
	cin>>t;
	while(t--){
		cin>>n;
		int k=0;
		for(int i=1;i<=n;i++){
			cin>>a[i];
			if(i>1&&a[i]!=a[i-1]) k++;	//求出k
		}
		for(int i=1;i<n;i++){
			if(a[i]<a[i+1]){	//0在1前
				k--;
				break;
			}
			if(a[i]>a[i+1]) break;	//1在0前
		}
		cout<<k<<endl;
	}
	return 0;
} 
```
