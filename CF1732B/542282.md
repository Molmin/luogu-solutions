感觉现有题解看上去都好奇怪？

## 解题思路
首先给出一个引理：

- 连续的若干个相同的 $0$ 或 $1$ 与一个 $0$ 或 $1$ 是等价的，换言之，在给一个后缀取反时，取若干段连续的 $0$ 或 $1$ **一定不会比其他方式更劣**。

证明是比较显然的，这里就省略了。

所以我们只需要考虑将原序列中连续相同的数**缩**成一个数，而此时（可以证明）新序列一定是零一交替的形式，形如：
$$01010101\dots$$
或者：
$$10101010\dots$$

要想取反使得原序列单调不减，和让新序列单调不减也是等价的，也就是让序列变成：
$$00000\dots011111\dots1$$

为了达成这样的形式，不难看出，设我们的新序列总共有 $k$ 个 $0/1$，那么：

- 若原/新序列以 $0$ 开头，则从第二段开始到倒数第二段每一段都需要取一次反，一共 $k - 2$ 次（最后一段是什么不重要，不需要取反）

- 若原/新序列以 $1$ 开头，则第一段也需要取一次反，一共 $k - 1$ 次

同样根据这样的操作方式我们可以发现，操作完后只有最后一段连续 $0/1$ 可能是 $1$，而前面一定全为 $0$。

统计新序列的 $k$ 只需要统计有多少个相邻的 $s_i, s_{i+1}$ 满足两者不相等就可以了。这样统计出来是 $k - 1$，计算也差不多。

## AC Code
```cpp
#include <bits/stdc++.h>
using namespace std;
int n, a[100005];


int main(){
	int t;
	scanf("%d", &t);
	while (t--){
		scanf("%d", &n);
		for (int i=1; i<=n; i++) scanf("%1d", &a[i]);
		int num = 0;
		for (int i=1; i<n; i++) if (a[i] != a[i + 1]) num++;
		if (a[1] == 1) printf("%d\n", num);//因为统计出来num就是k-1，所以这里就不需要再减一了
		else{
			if (!num) printf("0\n");//要特判本来就满足整个序列全0或全1的情况，不然输出-1
			else printf("%d\n", num - 1);
		}
	}
	return 0;
}

```
