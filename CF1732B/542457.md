考虑下面这个字符串：`010000100011011111001`（$542457$ 的二进制表示）。首先开头的 $0$ 不用考虑。接下来：

- 第二个字符出现不同，最优策略当然是修改这个字符（和后面的字符），字符串变为 `001111011100100000110`。
- 第三个字符又变了，采取一样的策略，把字符串改为 `000000100011011111001`。
- 第七个字符再次变了，采取同样的策略，后面的也以此类推。
- 现字符串为 `000000000000000000110`，需要修改倒数第三个字符，字符串变为 `000000000000000000001`。
- 发现最后一个字符又变成 `1` 了，接着再次改变这个 `1`，让它变成 `0`。

现在这个字符串都是 $0$ 了。现在修改了 $x-1$ 次，其中 $x$ 就是字符串的块数。但是修改最后一块是没有必要的，所以再减去 $1$。答案就是 $x-2$。

要是原来的串以 $1$ 开头呢？

看一下这个串：`1100111111110000000100000010`（`0xcff0102`），首先把字符串操作一次变为 `0011000000001111111011111101` 后，就和前面一样了。所以，答案是 $x-1$。

那么，只需要判断字符串开头是什么，再判断字符串的块数就能得到答案。怎么得到块数？就看看有几个字符串和前面的不一样，最后遍历下来就得到了 $x-1$ 的值。

```cpp
#include <bits/stdc++.h>
using namespace std;
int main(){
	int t;
	cin>>t;
	while(t--){
		int n;cin>>n;
		string a;cin>>a;
		int x=0;
		for(int i=1;i<n;i++)if(a[i]!=a[i-1])x++;
        //现在得到了 (x-1) 的值
        if(x==0)cout<<0<<endl;//都是0的话说明不需要变，但是如果直接执行下面一句会变成-1，所以要特判
		else cout<<x-(1-(a[0]-48))<<endl;/*是0就再减一，否则就是1，不需要再减了*/
	}
	return 0;
}
```
