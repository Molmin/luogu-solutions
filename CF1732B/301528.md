### [洛谷原题传送门](https://www.luogu.com.cn/problem/CF1732B)

### [CF原题传送门](https://codeforces.com/problemset/problem/1732/B)

## 思路
题目要让序列 $s$ 单调不减，因序列只包含 $0$ 和 $1$，所以不难发现操作主要取决于 $1$。

由于操作更改的是序列的后缀，那么更改第一个肯定不是最优的，如此，就要以第一个数字作为后面的序列的操作的基准。

再进一步，把连续的相同数字定为一段，可以发现，每一次操作的左端点 $l$ 在最优情况下一定满足 $s_{l-1} \neq s_l$，举个简单的例子：

$1100$ 若操作为 $\underline{1}$ $\underline{100}\Rightarrow\underline{1}$ $\underline{011}$ 还需多次才能达到最终状态。

$1100$ 若操作为 $\underline{11}$ $\underline{00}\Rightarrow\underline{11}$ $\underline{11}$ 则只需要 $1$ 次。

将序列按相同数字分成 $k$ 段，此时有两种情况：

-  第一段数字为 $1$。

-  第一段数字为 $0$。

为 $1$ 需要 $k-1$ 次操作，因为每一次操作可以更改一段，只需更改除第一段外的后 $k-1$ 段。

为 $0$ 需要 $k-2$ 次操作，因为第二段为 $1$，不需要更改，跟为 $1$ 时差不多。

特殊的情况，只有一段数字且为 $0$ 时没有第二段，直接输出 $0$ 即可。

注：代码有简化的地方，看起来会跟思路不一样（实际效果跟思路一样）。

## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int t,n,s;
char a[100005];
int main()
{
	scanf("%d",&t);
	while(t--)
	{
		scanf("%d%s",&n,&a);
		s=a[0]-'0';//第一段为1时比为0时多操作一次
		for(int i=1;i<n;i++)//要去掉第一段，所以从1开始
		{
			if(a[i]!=a[i-1])//求段数
			{
				s++;
			}
		}
		printf("%d\n",max(s-1,0));
		//段数-1，只有一段数字且为0时，s-1会成-1，比0小就输出0
	}
	return 0;
}
```
