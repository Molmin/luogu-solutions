# 前言
怎么说呢，这道题其实还挺有趣的，一道代码十分简短的题，却会让一些人越想越复杂，什么排序啊，前缀和啊，等等。最后反而做不出来这道题，下面就给大家分享一下本蒟蒻的一些想法。

# 题目描述

有两个字符串 $S$，$T$，你可以在任意一个字符串内做以下操作：将第 $i$ 位字符变为第 $j$ 位上的字符。

问最终能不能使 $S=T$。

# 思路

首先看到这道题，我第一反应是，这么水的一道题真的是橙题吗？我直接排序一波，再来判断 $S$ 和 $T$ 的元素是否一一相符，输出一下不就完了？打了十多分钟的代码后，发现样例都过不了，因为我们没有考虑元素的重复性，所以去重一下不就好了？去重的办法是用桶，统计一下每个字符是否出现过，然后判断一下桶内的元素是否在两个字符串中都出现过，输出一下答案。自信提交上去，结果错在了下面的数据上：

输入
```
1
aa
ab
```
输出
```
YES
```
错误的原因是在于，装 $S$ 数组元素个数的桶 $a$ 内存入了 $a$ 这个字符，而装 $T$ 数组元素个数的桶 $b$ 内存入了 $a$，$b$ 字符，显然程序会输出 $\verb!NO!$。但我们只需要把 $T$ 数组内的 $b$ 换成 $a$ 不就完了吗？再想想，此时两个字符数组只剩下了一种元素 $a$！这说明了什么？只需要一个字符就可以判断一下是否能满足条件，那我们不就找一个字符，两个字符数组内都出现了这个字符不就可以输出 $\verb!YES!$ 吗？事实证明我们的思路是正确的，那么下面就给大家奉上代码。

# 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
	//定义
	 
	char s[101],t[101];
	int q,i,l,j,a[256]={0},b[256]={0};//用桶来判断是否存在两个字符串中都出现的字符。 
	int f;//f 表示是否满足条件。 
	
	//输入
	 
	cin>>q;
	
	//处理 
	while(q--)
	{
		//切记两个桶初始要清空！！ 
		memset(a,0,sizeof(a));
		memset(b,0,sizeof(b));
		
		f = 0;//假设初始两个字符串不相同（事实也如此）。 
		scanf("%s %s",s,t);
		l = strlen(s);
		
		//统计元素是否出现过，下面的代码都是桶的基础部分，这里不再讲解。 
		for(i=0;i<l;i++)
			a[s[i]]++;
		for(i=0;i<l;i++)
			b[t[i]]++;
			
		//开始查找有没有满足条件的字符。 
		for(i='a';i<='z';i++)//从字符 a 查找到字符 z。 
			if(a[i]&&b[i])//找到这个字符了，条件是这个元素在两个桶中都出现过 。 
			{
				f = 1;//找到了，直接 break掉。 
				break;
			}
		//根据 f 的值来输出。 
		if(f)
			printf("YES\n");
		else
			printf("NO\n");
	}
	return 0;
}
```
