>这里是墨攸，平生没有什么爱好，就喜欢刷水题

给你们介绍一种很神奇的做法（虽然有点多此一举qwq）：

先上代码：

```cpp
#include<bits/stdc++.h>
#define orz 0
#define inf 0x3f3f3f3f
using namespace std;

int n, ans;
char c;

int main()
{
    for(int i = 1; i <= 8; i ++)
    {
        scanf("%c", &c);
        n = (n << 1) + (c - '0');
    }
    while(n)
    {
        n &= n - 1;
        ans ++;
    }
    printf("%d", ans);
    return orz;
}
```

这个代码是什么原理呢


------------


**首先，我们把这个$01$串转化为一个二进制数，也就是下面这行代码：**

```cpp
for(int i = 1; i <= 8; i ++)
{
    scanf("%c", &c);
    n = (n << 1) + (c - '0');
}
```

每次把 $n$ 给 乘$2$（即左移一位），然后在加上当前读到的数。


------------


**那么计算又是什么原理？**

我们看这句代码：

```cpp
n &= n - 1;
```

首先，$n$是我们处理好的$2$进制数。我们每次把$n$给$-1$

这会导致什么结果呢，我们来举个例子说明：

比如 ： 

`10100(2) - 1 = 10011(2)`  
`1010010000(2) - 1 = 1010001111(2)`  
`101000000(2) - 1 = 100111111(2)`

如上所见，我们找到了最低位的那个 $1$，把它变成了 $0$ 且把这之前的所有位都变为了 $1$。

我们只需要把原来的数 和 减一后的数 与运算一下，就可以把后面的 $1$ 给变为 $0$

再如上面的例子：

`10100(2) & 10011(2) = 10000(2)`  
`1010010000(2) & 1010001111 = 1010000000(2)`  
`101000000(2) & 100111111(2) = 100000000(2)`

很明显，我们每次操作都使得原$2$进制数里少了一个$1$。

所以我们只需要不断操作，直到原数为$0$即可。输出我们操作的次数即为答案。

于是有了如上代码。

```cpp
#include<bits/stdc++.h>
#define orz 0
#define inf 0x3f3f3f3f
using namespace std;

int n, ans;
char c;

int main()
{
    for(int i = 1; i <= 8; i ++)
    {
        scanf("%c", &c);
        n = (n << 1) + (c - '0'); //转化为2进制数
    }
    while(n)
    {
        n &= n - 1; //每次操作
        ans ++; //记录操作次数
    }
    printf("%d", ans);
    return orz;
}
```