### 先来理一遍题意：

1. 有两个党派，为 D、R。

2. 一个人**正常发言**时，能禁言一个人，被禁言的人**永远不能正常发言**。

3. 循环发言，直到只剩一个党派能发言为止。

------------


### 接着，我们来画一下发言流程图（如果不禁言）：

发言前：1 2 3 4 5

1 发言后：2 3 4 5 1

2 发言后：3 4 5 1 2

……

即每个人发言后，都排在队尾，队首发言。**这种题，不用队列都难**！

------------

### 再来看加了禁言的：

每个人当然会禁言下一个发言的“反派人物”，这样就不给他机会禁言“自己的同胞”，能最大限度地防止自己人被禁言。但这样不好直接处理禁言谁，队列只能对队首操纵……

**那就把两个党派还剩多少次禁言机会记下来呗，一有机会禁言，就用一次机会**

------------

### 注意：

一个党派的人都被禁言时，另一个党派可能不止一个人，所以不能用 ```!q.empty()``` 或 ```q.size()>1``` 来判断，必须**记录两派能发言的人数**，直到一方为零再停止。

------------


### 代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,cnt,r,d,cntr,cntd;
//r:R党禁言次数，d:D党禁言次数.
//cntr:R党现存多少人，cntd:D党现存多少人
char a;
queue <char> q;//生成队列
int main()
{
	cin>>n;
	for(int i = 1;i <= n;i++)
	{
		cin>>a;
		q.push(a);
		if(a == 'R')cntr++;//统计R党人数
		else cntd++;//统计D党人数
	}
	while(cntr > 0&&cntd > 0)//判断结束
		if(q.front() == 'D')//D党发言
			if(r >= 1)r--,q.pop(),cntd--;//被禁言
			else d++,q.push(q.front()),q.pop();//未被禁言
		else//R党发言
			if(d >= 1)d--,q.pop(),cntr--;//被禁言
			else r++,q.push(q.front()),q.pop();//未被禁言
	cout<<q.front();
	return 0;//好习惯
}

```