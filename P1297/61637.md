### 分析: 说说 思路: i , i + 1 , i + 2 ...... 
                     --> --> --->
    是这样错位的 那我们考虑对于每个(i + 1!= n+1)位置的答案
他是由上一个位置(i) 填过来的 那现在这个位置(i+1)填对的概率是多少呢
举个例子：eg: a[i] = 2 a[i+1] = 3  
           ai      pi      ai+1     pi+1
            1     1/2       1       1/3
		    2     1/2       2       1/3  
			/      0        3       1/3
所以两个位置选项相同的概率P = (1/2)*(1/3)+(1/2)*(1/3)+0*(1/3) = 2/(2*3)
由数学归纳法可知: P = min(a[i],a[i+1])/(a[i]*a[i+1])   
取min值的原因就是 因为可能第i/(i+1)个题可能有多余的选项 导致另者没有这个选项 就比如eg中的
i没有3 但i+1中有 3 所以P的分子应是两者中较小的一者
我们再把上式化个简:  P = min(a[i],a[i+1])/(a[i]*a[i+1]) = 1/max(a[i],a[i+1])  
两者是等价的 但后者避免了乘法运算 更方便运算 最后我们枚举每一个i 和 i+1(i = n时 i+1 = 1)
算出对应的P 最后累加起来就可以了
代码应该就很简单了:
```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
int n , A , B , C;
ll a[10000005];//记得开 long long  
double ans ;
int main(){
	scanf("%d%d%d%d%d",&n,&A,&B,&C,a + 1);
    for(int i = 2 ; i <= n ; i ++)
    a[i] = ((ll)a[i - 1] * A + B) % 100000001;
    for(int i = 1 ; i <= n ; i ++)
    a[i] = a[i] % C + 1;//以上是读入 复制题目^_^ 
    for(int i = 1 ; i < n ; ++i){//开始算每个i+1的概率 (最后一个单独算) 
    	ans += (double)1/max(a[i] , a[i + 1]);//如分析中所说 
	}
	ans += (double)1/max(a[1] , a[n]);//特别处理下 
	printf("%.3lf\n",ans);//输出就可以了 
	return 0;
} 
```