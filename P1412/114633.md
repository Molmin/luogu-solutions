## 引导：

看题的第一步看看测试数据范围，发现很大，这是我们就要想到动态规划。


------------

## 思路：

### 1: 这是我们有一个很简单想到的三维 DP ：f[i][j][k] : i 表示第 i 个数 ，j 表示维修次数， k 开采次数， 表示讨论完所能达到的最大收入。那么显然有状态方程： 

f[i][j][k]=max(f[i−1][j][k],f[i−1][j][k−1]+a[i]∗p),type[i]=1

f[i][j][k]=max(f[i−1][j][k],f[i−1][j−1][k]−b[i]∗p),type[i]=2

### 很明显，是不可取的，因为范围太大了，于是我们要想讲三维压成一维。

### 2: 可以发现，当前的决策只对后面的开采有影响，且剩余耐久度与之后的开采收益成正比，如果倒着考虑这个问题，得出 i - n 的星球 1 点耐久度所能获得的最大收益，从后往前 dp ，得出最大值最后乘 w 就是答案.

### 3：如果正着讨论不够优秀或者难以讨论（正难则反），考虑倒着讨论。注意到如果把答案列式计算下来，可以发现一个乘法分配率的形式，因为每次操作对p的改变都是乘上一个数。所以，如果定义 f[i] 为处理完区间 [i,n] 的星球得到的最大收入，

f[i]=max(f[i+1],(1−0.01k)∗f[i+1]+a[i]),type[i]=1
f[i]=max(f[i+1],(1+0.01c)∗f[i+1]−b[i]),type[i]=2


------------

## 个人建议：

~~DP是玄学，不重要~~，状态转移方程才重要！

```c
#include <iostream>
#include <cstdio>
#include <cmath>
using namespace std;
int n, a[1000005], f[1000005];
double w, c, k, dp[1000005];
int main()
{
    scanf("%d %lf %lf %lf", &n, &k, &c, &w);
	for (int i = 1; i <= n; i++)
        scanf("%d %d", &f[i], &a[i]);
	
	for (int i = n; i >= 1; i--)
    {
        if (f[i] == 1) dp[i] = max(dp[i + 1], dp[i + 1] * (1 - 0.01 * k) + a[i]);
        else dp[i] = max(dp[i + 1], dp[i + 1] * (1 + 0.01 * c) - a[i]);
    }
    printf("%.2lf", dp[1] * w);
    return 0;
} 
```