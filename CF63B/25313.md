正版题面(翻译部分有误，在此更正)：

一个共有n个数的非递减数列，还有一个整数target，每次操作可以让满足以下两个要求的数+1：

1. 该数比target小；

2. 该数不等于它后面的那个数。

特别地，最后一个数默认满足要求2.

你的任务是求出最小的操作数m，使得第m操作后，该数列中的所有数都等于target.

n,target<=100.

题解：

首先，我们可以注意到题目中的数列是**非递减**的。

我们可以先想象一个暴力模拟：

```cpp
记录步数=0；
while(1){
	判断数列中每一个数是否==target{
		是：输出步数，程序结束；
		否：找到每一个符合要求的数，步数+1.
	}

}
```
这个应该已经能过了(我没有试过，理论上平方阶的应该能过)

但是还能再快吗？

我们观察这个数列，它是一直保持非递减的吗？

是的！

我们想一下，如果一个数列中的数全都一样而且不到target，那么一波操作之后会有什么发生？

只有最后面的一个数会改变！

那么，一个普通数列是不是可以看做是由若干个上面的数列拼接而成的数列呢？

所以：

正解闪亮登场！

```cpp
#include<cstdio>
using namespace std;
int a[105];
int main()
{
	int num, target;
	scanf("%d%d", &num, &target);//见题面。
	for(int i=1; i<=num; ++i){
		scanf("%d", &a[i]);//a[i]存储初始数列。
	}
	int ans = 0;
	for(;;){
		for(int i=1; i<=num; ++i){
			if(a[i] == target && i == 1){printf("%d\n", ans);return 0;}//注意到这个了吗？就是上面所说的优化！如果第一个数都达到了target，那么由于数列的非递减性质，所有的数都一定等于target。少了一个n啊！
			else if(a[i] != a[i+1] && a[i] < target)++a[i];//模拟操作。
		}
		++ans;//记录步数+1
	}
	return 0;
 } 
```
