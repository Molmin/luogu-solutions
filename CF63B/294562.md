#### 表面上，这道题就是个简单模拟，实际上，还是有~~亿~~一点点坑点，本题解将会总结一下。

***
题意：给出一个拥有$n$个元素的数组$a$，保证递增，问最少进行多少次以下操作，可以使所有的元素都为$k$：

1. 如果该元素小于$k$，并且它不等于它后面一个的元素的话，它加1。

1. 最后一个元素默认不等于后面一个元素。

***

这道题的数据范围是$1 <= n,k <= 100$，十分水，所以暴力模拟即可。

过程如下：

1. 从1循环到$n$，判断是否可以加1，如果可以直接加

1. 判断是否符合退出条件，如果可以，直接退出并输出答案

1. 如果不行，计数器++

这时，好奇的小朋友就会问了：**怎么判断退出条件呢？难道直接循环？**

虽然这样可以，但是比较慢，我们可以考虑这样一种方法：**由于我们是从1开始循环，而原本就是递增的，所以我们只需要看元素1是不是等于k即可**。

***

下面是坑点：

判断是否符合条件的语句一定要放在循环开头，如果你放在计数器++前面，就无法判断直接满足的数据，这也是这道题唯一的坑点，也是其他题解并没有阐述的地方。

***
上代码，请配合注释食用：
```cpp
#include<bits/stdc++.h>

using namespace std;

int n,k;
int a[100000];
int ans;

int main(){
	cin>>n>>k;
	for(int i = 1;i <= n;i ++)cin>>a[i];
	a[n + 1] = 2147483600;//最后一个设为一个不可能达到的值
	while(1){
		if(a[1] == k)break;//把判断放在循环开头
		for(int i = 1;i <= n;i ++){
			if(a[i] < k && a[i + 1] != a[i])a[i] ++;//判断是否可以++
		}
		ans ++;//计数器++
	}
	cout<<ans;
	return 0;
}
```