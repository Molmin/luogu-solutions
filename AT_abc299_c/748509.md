## Descripition

给你一个长度为 $N$ 的字符串 $S$，请你求出最大的字串 $s$ 满足字串的第一项或最后一项为 `-`，其余为 `o`。请你求出所有满足条件的子串中 `o` 字符的最大数量。若没有，输出 `-1`。

## Solution

观察题目，实际上就是要我们求最多有连续的几个 `o`，只是需要满足左边或右边要存在一个 `-`。

对于输出 `-1` 的情况，要么是整个字符串中没有出现过 `-`，要么是整个字符串中没有出现过 `o`。特判即可。

剩下的就都是满足条件的字符串了，这样就可以求连续 `o` 的个数了。

定义 `k` 表示当前已经出现连续 `o` 的个数，`res` 为最大答案。对于每一个字符，我们分别来处理。

如果当前这个字符是 `o`，那么代表当前连续出现的 `o` 的个数多了一个，所以 `k ++ ;`。

否则如果当前这个字符是 `-`，那么代表上一次的连续 `o` 已经中断了，此时尝试更新 `res` 的值，并将 `k` 复位。即 `res = max(res, k), k = 0;`。

需要注意的是，最长的连续 `o` 可能出现在最后，而最后时我们并没有更新答案，所以要在循环外面再次尝试更新 `res`。

## Code

```cpp
#include <iostream>

using namespace std;

const int N = 2e5 + 10;

int n, k, res;		// k 表示当前已经出现连续 o 的个数，res 为最大答案
char s[N];
bool f1 = 1, f2 = 1;		// 记录是否没有出现过 o 和没有出现过 - 

int main()
{
	// 读入 
	cin >> n >> s + 1;
	
	for (int i = 1; i <= n; i ++ )
	{
		// 分类讨论，原理上面有说 
		if (s[i] == 'o') k ++ , f1 = 0;
		else f2 = 0, res = max(res, k), k = 0;
	}
	
	// 最后一次更新最大值 
	res = max(res, k);
	
	if (f1 || f2) res = -1;		// 判断是否无解 
	
	cout << res;		// 输出 
	
	return 0;
}
```
