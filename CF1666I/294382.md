## 思路
首先，我们将问题简化成一维：在数轴上有两个点 $x_1$ 与 $x_2$（不妨设 $1\le x_1<x_2\le n$），通过询问任意的 $x$ 点到两点的曼哈顿距离纸之和，找出这两个点。

假设我们询问点 $x$，其到两点的曼哈顿距离之和应为 $y = |x-x_1|+|x-x_2|$，~~通过画图~~，我们可以知道，$y$ 关于 $x$ 的函数表达式应为 $y = |x-x_1|+|x-x_2| = \begin{cases}-2x+(x_1+x_2)&x<x_1\\x_2-x_1&x_1\le x\le x_2\\2x-(x_1+x_2)&x>x_2\end{cases}$。证明如下：

------------
1. 若 $x<x_1<x_2$，则 $x-x_1<0,x-x_2<0$，故 $y=(x_1-x)+(x_2-x)=-2x+(x_1+x_2)$
2. 若 $x_1\le x\le x_2$，则 $x-x_1\ge 0,x-x_2\le 0$，故 $y=(x-x_1)+(x_2-x)=x_2-x_1$
3. 若 $x_1<x_2<x$，则 $x-x_1>0,x-x_2>0$，故 $y=(x-x_1)+(x-x_2)=2x-(x_1+x_2)$

整理可得上述函数。（下图绿色虚线为求出的函数，红色为模拟描点得到的函数，可看出两者重合）

![](https://cdn.luogu.com.cn/upload/image_hosting/upjt0b27.png)

可以这样理解：在数轴上，两点之间的点到这两点的曼哈顿距离之和就是两点间的距离 $(x_2-x_1)$。在 $x_1$ 左侧时每左移一个单位，距离多 $2$，右侧时每右移一个单位距离也多 $2$。

------------
也就是说，在 $\left[x_1,x_2\right]$ 范围内，点到 $x_1,x_2$ 两点的曼哈顿距离之和为定值，之外每远离一个单位曼哈顿距离之和距离之和增加 $2$（性质 $1$）。同时，我们还可以知道，图像关于直线 $x=\dfrac{x_1+x_2}{2}$ 对称，所以我们知道若两不同点 $a,b$ 到两端点的曼哈顿距离之和相等，则 $\dfrac{a+b}{2}$ 一定在“平底”上（性质 $2$）。

结合图像的性质，我们可以着手解决问题。我们可以求出函数“平底”的一段来看出两点的位置（“平底”段的两端点就是所求两点横坐标）。我们发现可以选两个点，求出一个一定在范围内的点，询问后就可以解出答案。详细步骤及证明如下：

- 首先我们可以对 $1,n$ 两端点进行询问，记返回值分别为 $f(1),f(n)$。假设 $f(1)>f(n)$，那么根据性质 $1$ 一定有 $f(1+\dfrac{f(1)-f(n)}{2})=f(n)$（由性质 $1$，点 $1$ 向右一个单位距离减 $2$，想要达到和 $f(n)$ 相同时距离应减小 $f(1)-f(n)$，也就是从 $1$ 开始向右 $\dfrac{f(1)-f(n)}{2}$ 单位），再根据性质 $2$ 有 $(\dfrac{(1+\frac{f(1)-f(n)}{2})+n}{2})$ 一定在“平底”上。  
- 再对这个点进行询问，我们可以得到一个值，记为 $f(mid)$，所以有 $f(x_1)=f(mid)$，故再使用性质 $1$，我们得到 $x_1=1+\dfrac{f(1)-f(mid)}{2}$。同理我们可以得到 $f(x_2)=f(mid)$，$x_2=n-\dfrac{f(n)-f(mid)}{2}$。
- 而当 $f(1)<f(n)$ 时，同理可以得到 $mid = \dfrac{1+(n-\frac{f(n)-f(1)}{2})}{2}$，也有 $x_1=1+\dfrac{f(1)-f(mid)}{2},x_2=n-\dfrac{f(n)-f(mid)}{2}$。
- 在 $f(1)=f(n)$ 时，上述两种情况都适用，有 $mid=\dfrac{1+n}{2}$，$x_1=1+\dfrac{f(1)-f(mid)}{2},x_2=n-\dfrac{f(n)-f(mid)}{2}$。

这样，我们就完成了一维版本，最少需要 $3$ 次 SCAN 操作。

------------
我们再将结论推广到二维。
同样地，我们可以推出，在以目标点 $(x_1,y_1),(x_2,y_2)$ 之间的直线为对角线的矩形中，点到两点的曼哈顿距离之和为定值，如图中浅红色的点（红色的为目标点）。其它点每离这个矩形水平方向或竖直方向上远一格距离之和都会加 $2$。证明即在横纵方向上各用一次一维的结论即可。

![](https://cdn.luogu.com.cn/upload/image_hosting/w4allkl8.png)

所以，我们不妨关注一下第一列（图中浅蓝色部分）（其实哪一列应该都可以，为了下面计算方便可以选第一列）。这一列中，每个点到两个曼哈顿距离之和可以看成是 竖直方向上点到目标点在第一列上投影的点（即 $(x_1,1),(x_2,1)$）的曼哈顿距离和（图中橙色部分） 加上 水平方向上的 $|y_1-1|+|y_2-1|$（图中亮橙色部分，为定值）。那么，既然如此，我们抛开水平方向上的定值不看，真正决定距离和大小的其实就是竖直方向上的这两段。我们仔细看就能发现，竖直方向上的这两段就可以看作是刚才的一维的问题，于是，我们可以用刚才一样的方法求得 $x_1$ 及 $x_2$（可以这么求的前提是 $|y_1-1|+|y_2-1|$ 这一定值不会对结果有影响，上述式子中我们的 $f(1),f(mid),f(n)$ 都是通过相减推出其它量的，所以没有影响）。也就是说，我们将目标点限制在了两条直线上，需要 $3$ 次操作。

![](https://cdn.luogu.com.cn/upload/image_hosting/3yowstih.png)

同理，我们在第一行也按上述方法能够求出 $y_1,y_2$，也就是说，我们得到了两组点 $(x_1,y_1),(x_2,y_2)$ 和 $(x_1,y_2),(x_2,y_1)$，需要 $3$ 次操作。答案只能是其中一组（显然答案不可能是 $(x_1,y_1),(x_2,y_1)$ 这类的），于是我们要 DIG 一组中的一点，若是则另一个答案即为这一组的另一点；若不是则答案即为另一组的两个点，也就是说，要 $3$ 次才能挖出所有点。

计算一下，目前我们一共用了 $3+3+3 = 9$ 次操作，除去重复的 SCAN $1\ 1$（第一列和第一行求解时都要用到）也要 $8$ 次，比题中要求的 $7$ 次多一次，所以，我们想如何减少一次操作。

如下图，观察 $(n,1),(1,m)$ 到两目标点的曼哈顿距离，我们发现，水平方向上两段加起来正好是 $2(m-1)$ 而竖直方向上恰好是 $2(n-1)$，所以有 $f_{(n,1)}+f_{(1,m)}=2(n+m-2)$，所以我们 SCAN 其中的一个就能算出另一个。这时，我们刚好将操作次数减到了 $7$ 次。

![](https://cdn.luogu.com.cn/upload/image_hosting/6qn7r5tv.png)

### 代码
```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int T,n,m;
int lt,ld,lm,rt,mt;
int anst,ansd,ansl,ansr;
int opt;
int main(){
	scanf("%d",&T);
	while(T--){
		scanf("%d%d",&n,&m);
		//对第一列计算
		printf("SCAN 1 1\n");fflush(stdout);scanf("%d",&lt);
		printf("SCAN %d 1\n",n);fflush(stdout);scanf("%d",&ld);
		if(lt>ld) {printf("SCAN %d 1\n",(n+(1+(lt-ld)/2))/2);fflush(stdout);scanf("%d",&lm);}
		else {printf("SCAN %d 1\n",(1+(n-(ld-lt)/2))/2);fflush(stdout);scanf("%d",&lm);}
		anst=1+(lt-lm)/2;ansd=n-(ld-lm)/2;//两目标点的横坐标
		rt=(2*(n+m-2)-ld);//算左上角点
		//对第一行计算
		if(lt>rt) {printf("SCAN 1 %d\n",(m+(1+(lt-rt)/2))/2);fflush(stdout);scanf("%d",&mt);}
		else {printf("SCAN 1 %d\n",(1+(m-(rt-lt)/2))/2);fflush(stdout);scanf("%d",&mt);}
		ansl=1+(lt-mt)/2;ansr=m-(rt-mt)/2;//两目标点的纵坐标
		printf("DIG %d %d\n",anst,ansl);fflush(stdout);scanf("%d",&opt);//挖答案
		if(opt) {printf("DIG %d %d\n",ansd,ansr);fflush(stdout);scanf("%d",&opt);}
		else {printf("DIG %d %d\n",anst,ansr);fflush(stdout);scanf("%d",&opt);
		printf("DIG %d %d\n",ansd,ansl);fflush(stdout);scanf("%d",&opt);}
	}
	return 0;
}
```