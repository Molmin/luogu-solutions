# 详解将1~n个元素扩大为1~3n个元素的原因以及意义
### 首先本题的解法是将1~n个元素扩大为1~3n个元素，使用[1，3n]个并查集（每一个并查集中的所有元素都具有同一种特性，不同并查集中不存在相同元素）来维护3n元素彼此的关系。
### 在这里我们留下两个问题：1.为什么是[1,3n]个并查集？2.为什么要有3n个元素？
### 它们在后续会得到解答
### 在这里x元素，x+n元素，x+2n元素三者的关系被定义为：
## x元素所在集合中所有∈[1，n]的元素都是x元素的同类
## x+n元素所在集合中所有∈[1，n]的元素都是x元素的天敌
## x+2n元素所在集合中所有∈[1，n]的元素都是x元素的猎物
## x+n元素所在的集合中所有∈[1，n]的元素都是x+2n元素的猎物
### 这里又多出了一个问题：为什么要这样定义？
### 相信很多人看到这里的时候依旧是懵逼的，但没关系，先回过头去再看一遍上面的文字，理清自己脑中有哪些疑问，再接着往下看
### 当我们得到一句关于两个元素x，y彼此关系的描述时，我们如果已知目前x,y它们各自的猎物和天敌，以及它们是否是同类，就可以判断这句描述的真假
## 这时我们来分析一下上面定义的作用
### 我们可以通过x+n元素来确定x元素目前已知的天敌，也可以通过x+2n元素来确定x元素目前的猎物，还可以通过x元素本身来确定x的同类
### 于是借此我们就能够进行语言真假的判断了
## 那么要怎样操作才能使所有的元素满足定义呢？
### 我们只需要认清以下几点：
### 1.两个同类元素的天敌集合是同一个集合，猎物集合也是同一个集合
### 2.天敌的天敌是猎物
### 3.猎物的猎物是天敌
### 对于一句真话，当x元素,y元素是同类时，将他们两者的天敌集合（x+n元素与y+n元素所在集合）和猎物集合（x+2n元素与y+2n元素所在集合）以及自身所在的集合分别合并。当x元素是y元素的天敌时，将x元素所在集合与y元素的天敌集合合并，将y元素所在集合和x元素的猎物集合合并，将x元素的天敌集合和y元素的猎物集合合并
## 现在来回答先前的问题：
### 1.为什么是[1,3n]个并查集？
### 因为不断合并后的并查集数量只有这么多。
### 2.为什么有3n个元素？
### 因为要满足上述的定义。
## 3.为什么要这样定义？
### 因为这样定义可以完美的解决问题，它被称为规则。
------------

### 最后再发表在下的一点看法：
### “为什么要这样做？”是我们在学习中最常遇到的问题，但有时候这个问题真的很恐怖。就如同我们知道1+1=2，但是当你产生“”为什么1+1=2”这样一个问题时就会感到恐惧，因为你发现你是在质疑规则，但规则是不能被撼动的，否则一切都会消失，所以你的问题将永远无法得到解答，于是乎你就会掉入思维的无底洞。
## 学习的过程是打破砂锅问到底，但你最好祈祷你自己不会打破砂锅，因为根本没有底。
### 附上代码：
```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cstring>
#include<cstdlib>
#define maxn 150010
using namespace std;
int n,k,x,y,z,ans;
int f[maxn];
int read()
{
	int f=1,w=0;char ch=getchar();
	while(ch<'0'||ch>'9')ch=getchar();
	while('0'<=ch&&ch<='9'){w=w*10+ch-48;ch=getchar();}
//	cout<<f*w<<endl;
	return f*w;
}
int find(int pos)
{
	while(f[pos]!=pos)pos=f[pos];
	return f[pos];
}
int unity(int p,int q)
{
	p=find(p);q=find(q);
	f[q]=f[p];
}
int main(void)
{
//	freopen(".in","r",stdin);
//	freopen(".out","w",stdout);
	n=read();k=read();
	for(int i=1;i<=n*3;i++)f[i]=i;
	for(int i=1;i<=k;i++)
	{
		z=read();x=read();y=read();
		if(x>n||y>n){ans++;continue;}
		if(z==1)
		{
			if(find(x+n)==find(y)||find(x+2*n)==find(y))ans++;
			else
			{unity(x,y);unity(x+n,y+n);unity(x+2*n,y+2*n);}
		}
		else
		{
			if(x==y||find(x)==find(y)||find(x+n)==find(y))ans++;
			else
			{unity(x+2*n,y);unity(x+n,y+2*n);unity(x,y+n);}
		}
	}
	printf("%d\n",ans);
	fclose(stdin);
	fclose(stdout);
	return 0;
}
```