逻辑各位都能理清楚，关键是怎么维护这个逻辑。

#### 对于并查集这样一个数据结构来说，维护相同类型的数据比维护对立类型的数据要更加容易，所以我们需要考虑把对立关系转换成同类关系，也就是给并查集分组。

举个例子，看一下这句话：
	
    A的天敌是B。
 
这句话用并查集维护的话，我们需要把它转化成：
	
    A的天敌与B是同类。
    
同理的，对猎物关系也是这么处理。

为了更方便地表示A的天敌与B的同类关系，我们选择把数组开到三倍，来表示不同的关系映射。

这里我的定义是x+n为食物，x+2n为天敌。

注意在处理这三倍的关系的时候方式要一样（也就是说三个空间里的对应数据关系是一致的）。注意每次关系处理的时候三种关系都要对应上。

仔细思考，思路很好懂的。

```cpp
//对一个并查集来说，同类关系比对立关系更易于维护。
		scanf("%d%d%d",&t,&x,&y);
		if(x>n||y>n){ans++;continue;}
		if(t==1){
			if(find(x+n)!=find(y)&&find(y+n)!=find(x)){
				//x+n表示x的食物
				//y+n表示y的食物
				//这里用三倍空间记录 
				fa[find(x)]=fa[find(y)];
				fa[find(x+n)]=fa[find(y+n)];
				fa[find(x+n+n)]=fa[find(y+n+n)];
			}else ans++;
		}else{
			if(find(x)!=find(y)&&find(x)!=find(y+n)){
				//x不是y的食物而且x也不是y的同类。 
				fa[find(x+n)]=find(y);//y与x的食物同类
				fa[find(y+n+n)]=find(x);//x与y的敌人同类
				fa[find(x+n+n)]=find(y+n);//x的敌人与y的食物同类 
			}else ans++; 
		} 
```