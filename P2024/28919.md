考虑单一一种情况（A吃B），我们可以搜索能吃A的X1，能吃X1的X2...Xn，如果这些数中有B的话，便是假话。那么我们发现这样的搜索会重复很多搜索过的内容，浪费大量的时间，我们便需要优化，去除重复搜索的内容，这样，很容易想到并查集。


并查集：并查集主要分为一个找祖先和合并的过程。主要思想就是每个点的祖先先定义为自己。一旦需要合并，就把右边的点祖先改为左边的点（左边改右边也行），找祖先就看什么时候祖先为自身就是找到了最初的祖先，否则继续找上一代的祖先。


可以用深度优先搜索：


```cpp
Int ss(int k)
{
If(f[k]==k)
Return k;
Else
Return f[k]=ss(f[k]);
}
```
那样判断A和B的关系可以从判断f[A]和f[B]用O（1）的时间解决。 这道题有一些特殊，包含了三种类别（A\B\C）,认真思考一下可以通过建立几个并查集a,b,c来记录不同的关系，也可以通过 建立补集法（个人认为更加好理解并且代码更加精炼）。

建立补集法 就是建立三倍大小的集合，并可以分为三个部分。而每个部分代表着一种动物种类，里面的每个元素代表每个动物可能为这个动物种类。其中我们可以认为 1 ~ n 的部分是物种X，n+1 ~ 2n 的部分是生产者（被物种X吃），2n+1 ~ 3n 的部分是消费者（吃物种X）。当然，由于环状关系，我们可以认为 n+1 ~ 2n 的部分是物种X，2n+1 ~ 3n 的部分是被物种X吃，1 ~ n 的部分是吃物种X……这样一来，每有一句真话，我们需要分别给三组集合合并。


A[k]物种K A[k+n]吃K的物种 A[k+2n]K吃的物种


```cpp
X=1
a[f(y)]=f(z); // Y Z同类
a[f(y+n)]=f(z+n);//吃Y的 吃Z的同类
a[f(y+2*n)]=f(z+2*n);//Y吃的 Z吃的同类
X=2
a[f(y+n)]=f(z); //吃Y的 Z同类
a[f(y+2*n)]=f(z+n); //Y吃的 吃Z的同类
a[f(y)]=f(z+2*n);//Y Z吃的同类
```
我们可以通过建立如此的关系来简单判断X1，X2的关系，从而简单的判断是否说谎。 最终这道题就简单的解决了。

至于其他的小细节自己判断。
