来一篇非模拟做法:

首先我们要知道，只要石头和布出的个数确定，
出的顺序就对答案没有影响。

可以自己尝试一下.

那么我们只要知道对方出的石头和布的个数就好了。

其次我们可以很容易看出，这道题简单的贪心思想：出布一定比出石头优。

那么我们要使布的个数最多，出石头和布的个数也就确定了：

设总长度为$l$，布的个数为$l/2($向下取整$)$，石头的个数为$l-l/2($注意不可以写成$l/2$，想想为什么？$)$

答案为：$min($我出布的个数，对手出石头的个数$)-min($我出石头的个数，对手出布的个数$)$。

这两个$min$分别代表自己赢的局数和对手赢的局数，因为平局都不得分，所以可以不考虑

#### 代码奉上：
```cpp
#include<cstdio>
#include<cstring>
using namespace std;
char c[100007];
int main(){
	scanf("%s",c);int l=strlen(c),g=0;
	for(int i=0;i<l;++i)if(c[i]=='g')g++;
	printf("%d\n",min(l/2,g)-min(l-l/2,l-g));
    return 0;
}
```