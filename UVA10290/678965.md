## 题意简述
给定 $0\le N\le 9\times 10^{14}$，求所有把 $N$ 拆为若干个连续的自然数的和。

如 $9$ 可以表示为：

$$
\begin{aligned}
9 &=2+3+4\\
&=4+5\\
&=9
\end{aligned}
$$
故共有 $3$ 种。

## 题目分析
设拆出的这些若干个连续自然数的首项为 $a$，末项为 $b$。

那么就有 $b-a+1$ 项。这些自然数的和为 $\dfrac{(a+b)\times (b-a+1)}{2}$。

所以 $2N=(a+b)\times (b-a+1)$。

由于 $a$ 和 $b$ 必须取整数，所以 $(a+b)$ 和 $(b-a+1)$ 的奇偶性一定是不同的。

故 $(a+b)$ 为偶数，$(b-a+1)$ 为奇数或者 $(a+b)$ 为奇数，$(b-a+1)$ 为偶数。

那么将 $2N$ 分解出所有的质因子 $2$ 之后，剩下的数的因子个数。注意需要舍去不合理的解，也就是 $b-a>a+b$ 这种情况。

每次分解 $N$ 的时间复杂度最劣情况下为 $O(\sqrt{n})$，$N$ 的极限数据是 $9\times 10^{14}$，那么最坏要运行 $3\times 10^7$ 次，最多会输入 $1100$ 次，所以最坏运行 $3\times 10^{10}$ 次，在 $3$ 秒的时间限制内无法胜任。

思路改进：

由于只需要运行到 $3\times 10^7$ 以内，所以可以用线性筛把所有的素数预处理，然后只需要枚举素数是否为 $N$ 的因数。

这时筛法是 $O(3\times 10^7)$ 的，我测试了一下，$3\times 10^{7}$ 之内有 $1857859\approx 2\times 10^6$ 个素数，相比原来的复杂度少了一个量级，在 $3$ 秒的时间范围内可以运行出来。

```cpp
int findprime(){
    memset(a,0,sizeof(a));
    a[0]=1;
    a[1]=1;
    int s=0;
    for(int i=2;i<=3e7;i++){
        if(a[i]==0){
            pr[++s]=i;
        }
        for(int j=1;i*pr[j]<=3e7&&j<=s;j++){
            a[i*pr[j]]=1;
            if(i%pr[j]==0)break;
        }
    }
    return s;
}
int tot=findprime();
```

这个线性筛代码将在 `pr[]` 数组中存储所有的 $3\times 10^7$ 以内的所有素数，并返回素数个数，同时在分解质因数时的循环条件应为 `i<=tot&&pr[i]*pr[i]<=n` 而非 `i<=tot`，因为超过之后的运行没有必要，而且会造成时间浪费。剩下就可以照着公式敲一遍即可。