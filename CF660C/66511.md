提供一种奇奇怪怪的队列优化 $DP$ （~~递推？~~）的解法。复杂度还是比较优秀的，主要是好懂。

## 【思路】

### 【求解】
首先设计状态：

$$
dp[i][j] 
$$

表示到第 $i$ 个数变了 $j$ 个 $0$ 的 **以第i个数结尾** 的最长连续 $1$ 串长度。

方程很显然：

$$
dp[i][j]=dp[i-1][j-1]+1,dp[i][0]=0(a[i]=0)
$$
$$
dp[i][j]=dp[i-1][j]+1(a[i]=1)
$$

最后取 $max\{dp[i][k]\}$ 即可。

这是 $O(n^2)$ 的，考虑优化。

首先 $dp[i]$ 这一维显然可以滚掉不要。

然后发现 $dp$ 数组的变化要么是 **不变然后加1** ，要么是 **整体移动一位，然后加1，然后只对一个数清零** 。

因此想到用队列优化。

维护一个队列，队首是 $dp[k]$ ，队尾是 $dp[0]$ 。

对于整体加 $1$ 的操作，外置一个变量 $base$ ，保存总共加过几次 $1$ 即可。

对于移动一位的操作，直接删掉队首即可，这是因为没有 $dp[k+1]$ 这一项，所以移动后元素个数是 $-1$ 的，而且这样一来 $dp[k-1]$ 就会刚好变成 $dp[k]$ ，其他元素同理。

然后由于新加进来的 $dp[0] = 0$ ，而队列里的每一个数其实都不是其真实值，而是 **真实值 - base（定义见上文）**，因此我们把 $-base$ 入队就完成了 $dp[0]=0$ 操作。

至此完成了 $O(n)$ 求出解的算法，下面考虑输出。

### 【输出】
最后输出这个变化后的序列其实也不难。

现在我们已经知道了末尾最长可以有几个连续的 $1$ ，设这个答案为 $ans$ 。

我们自然也知道这个答案是在 $i=$ 多少的时候取出来的，假设是在 $i=pos$ 时取出来的。

那么只要使得满足 $i\in[pos-ans+1,pos]$ 的所有 $a[i]$ 为 $1$ 即可，因为 $ans$ 已经可以确定是一组解，那么把这 $ans$ 个数全部变为 $1$ 一定满足题意，即一定为一组解。

剩下的数照常输出即可。

## 【代码】
```cpp
#include <bits/stdc++.h>
using namespace std;
int n, k, ans, pos, base;
int a[300005];
queue <int> q;
int main(){
    scanf("%d%d", &n, &k);
    while(k --) q.push(0);
    q.push(0);
    for (register int i = 1;i <= n;i ++){
        int x;
        scanf("%d", &x);
        a[i] = x;
        base ++;
        if(!x){
            q.pop();q.push(-base);
        }
        if(ans < q.front() + base){
            ans = q.front() + base;
            pos = i;
        }
    }
    printf("%d\n", ans);
    for (register int i = 1;i <= n;i ++){
        if(i >= pos - ans + 1 && i <= pos) printf("1 ");
        else printf("%d ", a[i]);
    }
    putchar(10);
}
```