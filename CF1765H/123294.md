**赛时做法**：答案具有可二分性。设当前检查是否有 $p_i\leq k$，相当于 $p_i := k$ 并检查是否有解。检查是否有解：设 $a_i$ 表示 $i$ 能到达的所有点 $j$ 的 $p_j$ 的最小值，拓扑排序时贪心选取当前队列中 $a_i$ 最小的点并扩展。若当前取出的点已经打破限制，则无解。时间复杂度 $\mathcal{O}(nm\log ^ 2 n)$，[TLE](https://codeforces.com/contest/1765/submission/185240086)。因为取出的点的 $a_i$ 单调不降，所以将优先队列换成若干个桶可以做到 $\mathcal{O}(nm\log n)$，[勉强通过](https://codeforces.com/contest/1765/submission/185240247)。

**官方做法**：很巧妙！将整个过程倒过来，将 $i$ 尽量往后放，也就是从 $n$ 到 $i$ 找到第一个时刻 $j$ 使得除了 $i$ 以外，当前没有可以取出的位置，则 $j$ 即为 $i$ 的答案。当时刻不大于一个位置的限制时，它可以被取出，优先队列或若干个桶维护。时间复杂度 $\mathcal{O}(nm)$。[代码](https://codeforces.com/contest/1765/submission/185280634)。