考虑计算每条边在多少个不同的点集的斯坦纳树中。

对于仙人掌上的边可以分成两类：

* 割边。

* 环上的边。

分别考虑这两类边。

如果边 $(u,v)$ 是割边，令断掉该边之后分裂成的两个连通块分别是 $A,B$，那么对于点集 $S$，如果 $S\subseteq A$ 或 $S\subseteq B$，那么 $(u,v)$ 一定在点集 $S$ 的斯坦纳树种，否则 $(u,v)$ 一定在点集 $S$ 的斯坦纳树中。

因此边 $(u,v)$ 会出现在 $(2^{|A|}-1)\times (2^{|B|-1})$ 个子集的斯坦纳树中。

那么接下来终点考虑 $(u,v)$ 是环上的边要如何计算。

对于仙人掌，和基环树类似可以“以环为中心”考虑去考虑整个图。

![](https://cdn.luogu.com.cn/upload/image_hosting/5kzx1uvs.png)

对于环上的边单独考虑一个边会被算的次数会很难办（因为如果一个斯坦纳树包含一条环上的边，那么可能可以用其他的边替代该边）。

因此这里整体考虑一个环上的情况。

假设环上共有 $k$ 个点，那么如果断掉所有环上的边，该环所在的连通块会分裂成 $k$ 个连通块，设 $k$ 个连通块分别为 $T_1,T_2,...,T_k$。

对于集合 $S$,如果存在一个 $i$，满足 $1\le i\le k$ 那么集合 $S$ 的斯坦纳树中一定不包含该环上的点。

否则，$S$ 的斯坦纳树中一定包含环上的一条链。

![](https://cdn.luogu.com.cn/upload/image_hosting/rp09vf6g.png)

红叉表示对应连通块内存在 $S$ 的点的“根节点”。

我们希望在环上找到一条最短的链使得能够将所有被打红叉的点“串起来”。

那么实际上相当于总的环长减去打红叉的点相邻两点之间路径长度的最大值。

考虑按顺时针顺序将所有环上的点编号。

并将所有相邻两点之间的路径按顺时针方向定向，这样任意一个点有恰好一个出度和恰好一个入度，这样对于一条边 $u\to v$，就可以使用 $u$ 为这条边 “编号”。

![](https://cdn.luogu.com.cn/upload/image_hosting/i6638n8h.png)

定义一个点集 $S$ 的斯坦纳树在该环上删除的路径为删掉相邻两点间最大的路径中编号最小的路径。

那么这样，一个点集 $S$ 的斯坦纳树就是 “唯一”的了。

考虑 $O(k^2)$ 枚举环上的每段路径，计算有多少个点集 $S$ 满足其斯坦纳树在该环上删除的路径为所枚举的路径。

![](https://cdn.luogu.com.cn/upload/image_hosting/1w54pe3t.png)


注意到，其实计算过程中只关心每个连通块的大小，因此现在可以将除了该环以外的部分全部 “扔掉”，只维护每个连通块的大小即可。而此时我们要解决的就只是一个环上问题了。

![](https://cdn.luogu.com.cn/upload/image_hosting/cpk2h5l7.png)

我们每次枚举路径后的问题相当于去计算“该路径的补”的部分有多少种方案使得任意两个“关键点”的距离 $\le $ 该路径的长度，且不存在起始点 $<\min(u,v)$ 的路径使得该路径的长度恰好 $=k$。

考虑破环成链。

![](https://cdn.luogu.com.cn/upload/image_hosting/m3zp0n5r.png)

考虑定义一个 $calc(l,r,k,low)$ 表示区间 $[l,r]$ 这一段钦定 $l$ 和 $r$ 一定是 “关键点”，满足任意两个相邻关键点距离 $\le k$，且不存在两个相邻的关键点 $u,v$ 满足 $u<v,v-u=k,pos[v]<low$。

大力 DP 即可， $calc(l,r,k,low)$ 的复杂度是 $O(k^2)$ 的，使用前缀和可以优化成 $O(k)$。

因此对于一个大小为 $k$ 的环，计算贡献的复杂度为 $O(k^3)$，因为一个点在至多一个环，所以总的复杂度为 $O(n^3)$。   



