这个题 主要是 用来教大家2个思想。


暴力的30分就不说了。

有40分是 7000-7100 考虑打表。 在自己电脑上 暴力跑出7000-7100的答案(大概要5分钟),然后输出来 存到程序里,直接输出即可。

这种技巧适用于 数据比较少的情况,要综合考虑代码长度(表太大了 cpp文件会太大)和打表的时间。





```cpp
    for (int n=7000;n<=7100;n++)
    {
        ll ans=0;
        for (int i=1;i<=n;i++)
        {
            for (int j=i+1;j<=n;j++)
                ans+=gcd(i,j)*2;
            ans+=i;
        }
        printf("f[%d]=%I64d;\n",n,ans);
    }
f[7000]=275797760;
f[7001]=275818761;
f[7002]=275909661;
f[7003]=275957900;
f[7004]=276059136;
f[7005]=276136101;
f[7006]=276211445;
f[7007]=276344088;
f[7008]=276499480;
f[7009]=276547721;
f[7010]=276616365;
f[7011]=276735228;
f[7012]=276784296;
f[7013]=276805333;
f[7014]=276928189;
f[7015]=277019184;
f[7016]=277082288;
f[7017]=277122041;
f[7018]=277231645;
f[7019]=277252700;
f[7020]=277537280;
f[7021]=277630645;
f[7022]=277665749;
f[7023]=277705536;
f[7024]=277782704;
f[7025]=277848609;
f[7026]=277911813;
f[7027]=277932892;
f[7028]=278030072;
f[7029]=278147405;
f[7030]=278286229;
f[7031]=278334776;
f[7032]=278444744;
f[7033]=278491761;
f[7034]=278526925;
f[7035]=278675500;
f[7036]=278724736;
f[7037]=278772965;
f[7038]=278953037;
f[7039]=278974152;
f[7040]=279184840;
f[7041]=279224729;
f[7042]=279296077;
f[7043]=279317204;
f[7044]=279404000;
f[7045]=279447661;
f[7046]=279521765;
f[7047]=279634760;
f[7048]=279698152;
f[7049]=279792113;
f[7050]=279966413;
f[7051]=280013164;
f[7052]=280116272;
f[7053]=280156229;
f[7054]=280191493;
f[7055]=280282448;
f[7056]=280543520;
f[7057]=280564689;
f[7058]=280599973;
f[7059]=280683164;
f[7060]=280777624;
f[7061]=280825733;
f[7062]=280952861;
f[7063]=280998240;
f[7064]=281061776;
f[7065]=281173025;
f[7066]=281208349;
f[7067]=281256908;
f[7068]=281430400;
f[7069]=281451605;
f[7070]=281585637;
f[7071]=281625696;
f[7072]=281803424;
f[7073]=281850321;
f[7074]=281970093;
f[7075]=282036468;
f[7076]=282139744;
f[7077]=282220157;
f[7078]=282255541;
f[7079]=282276776;
f[7080]=282480296;
f[7081]=282529185;
f[7082]=282564589;
f[7083]=282623572;
f[7084]=282813048;
f[7085]=282903613;
f[7086]=282967357;
f[7087]=283015400;
f[7088]=283093272;
f[7089]=283177593;
f[7090]=283247021;
f[7091]=283292580;
f[7092]=283417536;
f[7093]=283466333;
f[7094]=283501797;
f[7095]=283655352;
f[7096]=283719176;
f[7097]=283768065;
f[7098]=283948557;
f[7099]=283997212;
f[7100]=284136752;
```
下面是正解：
f[d]表示gcd=d的(i,j)有多少对.   那么sum(f[d]\*d)就是答案。 所以如何求f[d]是关键。

直接求f[d]有困难,我们可以用g[d]表示gcd是d的倍数的(i,j)有多少对,如何减去f[2\*d],f[3\*d],f[4\*d],f[5\*d]...

g[d]=(n/d)\*(n/d). 可以按n,n-1,n-2...1的顺序来求f[d].

所以总时间应该是n/1+n/2+n/3+n/4+...n/n.  这个东西 欧拉当年研究过的,有兴趣的可以百度一下,只要记住它是nlogn级别的就好(想一想筛法)。这个结论很常用,请大家记住。


```cpp
    for (int d=n;d>=1;d--)
    {
        f[d]=1ll*(1ll*n/d) * 1ll*(n/d);
        for (int i=d+d;i<=n;i+=d) f[d]-=f[i];
        ans+=f[d]*d;
    }
    printf("%I64d\n",ans);

```