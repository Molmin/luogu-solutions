这题只要了解其精髓就变得很简单了。

我刚刚做了一个单调不增或单调不减的题，通过推荐题目过来了。

这里我们将单调递增转化为单调不减，只需要将 $a_i$（下标为 $1$~$n$）减去 $i-1$ 就可以了。

为什么呢？反着想，如果要将单调不减转化为单调递增，考虑数组值全相等的特殊情况，我们就得把 $a_2$ 加上 $1$；把 $a_3$ 加上 $2$；把 $a_4$ 加上 $3$；……；把 $a_n$ 加上 $n-1$。即把 $a_i$ 加上 $i-1$。所以要将单调递增转化为单调不减，就把 $a_i$ 减去 $i-1$。现在想想数组不限制的，因为我们不能知道最终序列两个值是否相等，我们按数组值全相等的特殊情况才能保证是单调递增的。

现在来想单调不减的思路，给个样例。

单调处理前：
```
7
1 4 4 7 9 7 15
```
单调处理后：
```
7
1 3 2 4 5 3 9
```
我们按递推顺序想想，

下标为 $1$ 时，符合条件，不做处理。序列为：$\{1\}$。

下标为 $2$ 时，符合条件，不做处理。序列为：$\{1,3\}$。

下标为 $3$ 时，不符合，将前面的 $3$ 改为 $2$。序列为：$\{1,2,2\}$。

下标为 $4$ 时，符合条件，不做处理。序列为：$\{1,2,2,4\}$。

下标为 $5$ 时，符合条件，不做处理。序列为：$\{1,2,2,4,5\}$。

下标为 $6$ 时，不符合，将前面的 $5$ 改为 $3$。序列为：$\{1,2,2,4,3,3\}$。?

下标为 $7$ 时，符合条件，不做处理。序列为：$\{1,2,2,4,3,3,9\}$。

为什么第六步可行呢？我们在做处理时肯定是将前面最大数变为这个数（即最适配情况）（$5,3$ 变 $3,3$），而这个的操作数，与将前面最大数与这个数折中变化的操作数相同（$5,3$ 变 $4,4$）。

而我们每次只找前面最大值，把我们更改的数值当作动态平衡（可小可大），这种动态平衡与单调不减是等效的（这里要好好理解），因为这并不影响我们找到的前面最大值与操作数。

当当前的数小于前面最大值，且这个最大值原本处于动态平衡，则这个数的值就定下来了，每次将前面最大数变为这个数。

当当前的数大于或等于前面最大值，符合条件，不更改值。

所以我们只需维护前面的更改数值后的值的最大值就行了。

附上代码：

```cpp
#include<bits/stdc++.h>
#define ll long long
#define mxm 200002
#define mxn 100002
using namespace std;
ll n,mx;
priority_queue<ll>qmx;
inline void rd(ll &x){x=0;short f=1;char c=getchar();while((c<'0'||c>'9')&&c!='-') c=getchar();if(c=='-') f=-1,c=getchar();while(c>='0'&&c<='9') x=x*10+c-'0',c=getchar();x*=f;}
inline void pt(ll x){if(x<0) putchar('-'),x=-x;if(x>9) pt(x/10);putchar(x%10+'0');}
int main(){
	rd(n);
	for(ll i=1,x;i<=n;i++){
		rd(x);
		x-=i-1;//将其要求从单调递增，转化为单调不减
		qmx.push(x);//将x放入优先队列
		mx+=qmx.top()-x;//记录操作次数
		qmx.pop();//将最大值弹出
		qmx.push(x);//改为x
	}//想想当x大于或等于时，是否没改值
	pt(mx);//输出操作次数
}
```