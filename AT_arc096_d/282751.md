大佬们都写的不太详细，我补充一些细节。~~但是不放代码。~~


第一步我们先差分，每一个点选择一次就必须要把子树内所有节点选择一次，一个点显然不能选 $d$ 次以上，否则和父亲节点差值一定超过 $d$，如此一来我们可以将原问题转化为一个经典的多重背包问题——每棵子树是一个物品，价值为子树内 $c_i$ 之和，体积为 $m_i$ 之和，最多选择 $d$ 次，特别的，$1$ 子树可以选择任意多次。由于 $d$ 是 $10^9$ 级别，显然无法通过。

考虑怎么去优化它，尝试寻找一个跟阈值无关的背包问题算法。

首先是一个常见（？）trick，由于质量比较小，交换体积和质量，也就是说 $dp_i$ 表示质量为 $i$ 时的最小体积。这样 dp 依然是有问题的——有可能质量也比较大，在这里就是有可能超过 $n^3$ 的范围。怎么优化？（下文中 $w$ 是质量，$v$ 是重量）

如果一个物品 $j$ 选了 $w_i$ 件，并且存在一个 $i$ 使得 $ \frac{w_i}{v_i}> \frac{w_j}{v_j}$ 的话，选择 $w_j$ 个 $i$ 会更优，换句话说当一个劣于 $i$ 的 $j$ 选到了 $w_i$ 个的时候就会被 $i$ 替换，所以我们只用每个物品拿出 $\min(n,d)$ 个做一下多重背包，剩余的可以通过贪心解决。当然多重背包要用单调队列/二进制优化一下多重背包。