
大体思路
首先，每个人都一定会得到 $1$ 块钱（，只有最后的那些幸存者会得到 $2$ 块钱，所以，我们只要求出最后幸存几个人就好了。假设经过 $x$ 次出圈操作后还剩 $final(x)final(x)$ 个人，这个时候人数绝对不会减少了，所以这个问题的正解是 $final(x)+nfinal(x)+n$ ，加上一个 $n$ 是什么意思呢？就是其余的，淘汰的那些人得到的钱数。
设 $a$ 数组为 $i$ 个人的圈报数后的幸存者编号，设报到 kk 的人出去，则 $a[i-1]a[i?1]$ 可以理解为第 11 轮第 11 次报数， kk 出去后的状态。 kk 出去后会从 k+1k+1 继续报数，此时圈中 有 i-1i?1 个人，从 k+1k+1 开始报数，编号$a[i]$为： k+1,k+2,...i,1,2,...k-1k+1,k+2,...i,1,2,...k?1 。
```
代码
AC 代码：
#include<bits/stdc++.h>//万能头文件
using namespace std;
int n,a[100001],ans;//n用来存储游戏的人数，a数组用来存经过x次出圈操作后剩余的人的编号，ans用来存给了存活者编号小给了多少2元 
int final(int x){//final函数用来记录还剩多少个人 
    if(x==a[x])// 如果第x次x=a[x]时，人数就不会再减少了 
        return a[x];//将a[x]返回 
    final(a[x]);//递推，调用final的a[x] 
}
int main(){
    cin>>n;//将人数输入 
    a[2]=1;//a[2]必有1个人 
    for(int i=3;i<=n;i++)//进行上一段代码x+1次循环 
        a[i]=(a[i-1]+1)%i+1;//计算经过i次出圈操作后剩余的人的编号
    ans=final(n);//将ans赋值为剩余人数 
    cout<<n+ans<<endl;//将n+ans输出（注意！ans只是2元*获胜人数，还有一些暂时离开的人得了1元的钱没有加上，所以要加上） 
    return 0;//结束程序 
}
```


