
我们先从n个人的幸存者说起


设$j_n=n$个人的最后幸存者

```cpp
n   :|1|2,3|4,5,6,7|8,9,10,11,12,13,14,15|16……|

j_n :|1|1,3|1,3,5,7|1,3,5 ,7 ,9 ,11,13,17|1 ……|
```

注意我把$n$以及对应的$j_n$分为几段

对于任意一个$n$

可以发现$n$所在的那一段的起点是小于等于$n$的最大的$2^m$

引入一个新的量$l$，表示$2^m$与$n$的差

$n=2^m+l$

$j_n=j_{2^m+l}=2*l+1$(找规律，~~其实也可以反证法但我不会~~)

把$n$转为二进制

$b_i$为二进制的第$i$位的值($0$或$1$)

因为$l<2^m$

所以l的二进制的位数不超过$2^m$

所以$n$的位数为$m+1$，最高位为$1$

```cpp
n  =         (1      b[m-1] b[m-2]…… b[2] b[1] b[0])2 这个2只是
表示二进制

2^m=         (1      0      0     …… 0    0    0   )2 这里有m个
0

n-2^m=l=     (0      b[m-1] b[m-2]…… b[2] b[1] b[0])2

l*2=         (b[m-1] b[m-2] b[m-3]…… b[1] b[0] 0   )2

l*2+1=j(n)=  (b[m-1] b[m-2] b[m-3]…… b[1] b[0] 1   )2
```

$j_n$ $=$n的二进制将最高位去除$(-2^m)$再左移一位（乘以二）再加一

$j_n=(n-2^m)*2+1$

---

对于新约瑟夫问题

$ans=j(j(j(……j(j(n))……)))$,$ans$为最后剩下的人数

一直嵌套到$2^k-1$(因为$2^k-1$的二进制为$1111……1111$,他的$j_n$还是等于$n$

所以$ans=j(2^k-1)=j((111……11)2)=(111……11)2$    <--这个2只是表示二进制

因为在运算过程中，把最高位去掉，最高位后面的$0$都会被去掉，例如 $n=(10011)2$ , $j_n=(111)2$

而$1$不会被去掉，所以$2^k-1$二进制的$1$的个数为$n$的二进制等于$1$个数

于是公式就是$n$+((把$n$的二进制的所有$0$去掉)再变成十进制)*$2$  (先给$n$个人每人一块钱，再给最后剩下的$ans$个人每人一块钱)

有一个名叫
```cpp
__builtin_popcount()
```

的函数是用来数一个数的二进制有多少个1

把1左移_builtin_popcount(n)为得到的是一个数，二进制是1后面有
_builtin_popcount(n)个0

这个数减一后的二进制就是__builtin_popcount(n)个1

就等于$j(2^k-1)=ans$

所以程序为

```cpp
#include<iostream>
using namespace std;
int main()
{
   int n;
   cin>>n;
   cout<<n+(1<<__buitin_popcount(n)-1);
   return 0;
}
```
---

$update$ $on$ $2019/1/26$