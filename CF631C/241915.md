### 题意简述

给定 $n$ 和 $n$ 个数，$m$ 次操作，每次操作给定 $li$ 和 $ri$。

若 $li$ 为1，则将前 $ri$ 个数从小到大排列；

若 $li$ 为2，则将前 $ri$ 个数从大到小排列；

输出最终数列。

### 方法

首先暴力不可能，正解方法我也是在看了题解后想到的，所以方法大致和其他题解相同，但代码的实现换了比其他题解更好理解的方法。

再输入后的第一步，我们要先筛选出有用的操作，比如：

```
1 3
2 4
```
中的 `1 3` 就是没用的，会被 `2 4` 覆盖掉。

可以发现能从后往前，对于每个 $ri$，往前遍历，删除所有 $rj$ 小于 $ri$ 的操作。

代码实现：

```cpp
for (int i = m; i >= 1; i)
		{
			int j = i - 1;
			while(tt[i] >= tt[j]) j--;//tt就是上文提到的r，但由于不是最终答案，所以用tt暂存。
			x[++cnt].l = t[i],x[cnt].r = tt[i],i = j;//x.l和x.r就是最终答案。
		}
```

第二步，我们需要先将 $l$ 和 $r$ 按 $r$ 的大小从大到小排序。

我们发现，我们可以将答案序列切成 $cnt + 1$ 个部分，最右边的部分，也就是从头到尾没有排过序的部分保持不动。

剩下 $cnt$ 个部分，每部分长度是 $x[i + 1].r + 1$ ~ $x[i].r$ 如果 $x[i].l$ 值为1，那这部分选取剩下的原数组的数中最大的那些，反之选最小的，存入答案数组当中。

代码实现：

```cpp
	sort(x + 1,x + 1 + m,cmp);
	for (int i = x[1].r + 1; i <= n; i++) ans[i] = a[i];
	sort(a + 1,a + 1 + x[1].r);
   //注意是a + 1 + x[1].r，x[1].r 之后的部分不改动所以不需要。
	p = 1,q = x[1].r;//指针。
	for (int i = 1; i <= cnt; i++)//如上所述。
		{
			for (int j = x[i].r; j > x[i + 1].r; j--)
				{
					if (x[i].l == 1)
						{
							ans[j] = a[q],q--;
						}
						else
							{
								ans[j] = a[p],p++;
							}
				}
		}
```

第三步，输出（不讲了不讲了）。

至此，可以AC本题，速度全洛谷第二（当时是的）。

[完整代码](https://www.luogu.com.cn/paste/6na940k6)