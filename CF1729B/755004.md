简单模拟，但有点小坑。

思路很简单，遍历整个字符串，判断该位是两位数还是一位数，然后再将其转化为字母存进答案字符串中。

但是如果正序枚举字符串会出现问题！为什么？考虑 $1100$，当枚举到第一个 $1$ 时，将会将其认为与后面一个 $1$ 组成一个两位数！实际上的答案应该是一位数 $1$ 和二位数 $10$。所以需要我们采用**倒序枚举**字符串。

那么整理思路：倒序枚举字符串，当前第 $i$ 位如果为 $0$ 且 $i-2\ge 0$，那么就是两位数，转化为字母添加到答案中；如果不是 $0$，直接将其转化字母添加到答案中。

当然，倒序枚举字符串得到的答案是**颠倒的**，所以最后要将答案字符串颠倒。

得到代码：
```
#include <bits/stdc++.h>

using namespace std;

int T;

int main () {
	cin >> T;
	while (T --) {
		int n;
		string s;
		cin >> n;
		cin >> s;
		string ans = "";
		int i = s.size () - 1;
		while (i >= 0) {
			if (s[i] == '0' && i - 2 >= 0) {//与前面是两位数 
				ans += 'a' + (s[i - 1] - '0') + (s[i - 2] - '0') * 10 - 1;//转化为字母 
				i = i - 3;//结束这个两位数 
			}
			else {
				ans += 'a' + (s[i] - '0') - 1;//直接添加 
				i --;
			}
		}
		reverse (ans.begin (), ans.end ());//颠倒答案字符串 
		cout << ans << endl;
	}

	return 0;
}
```

