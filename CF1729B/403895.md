# CF1729B Decode String题解

## 题目描述

给出一个由小写字母构成的字符串的加密规则：如果这个字符是字母表中第 $1\sim9$ 个字母，直接加入该字母在字母表中的序号，否则除了加入序号外还要再加入一个 $0$。现给你一段加密后的字符串，问它的原文是什么。

## 思路

一道模拟题，从第一个字符开始模拟，每次与后面的数组成新的数，并做出以下情况判断：

一、如果与后面一个数组成了后大于 $26$，那么肯定不能与后面结合，直接加入当前数。
   
二、如果与后面的一个数组成后不大于 $26$ 且大于 $10$，判断往后第二个数是否为 $0$，如果不是那么肯定不能与后面结合，因为两位数后面必须跟一个 $0$，所以直接加入当前数。

三、如果与后面的一个数组成后不大于 $26$ 并大于 $10$，且往后第二个数为 $0$，判断往后第三个数是否为  $0$，如果是那么肯定不能与后面结合，因为如果结合了后面第三个数就会单独出现一个 $0$，不符合变化规律，所以直接加入当前数。

如果上面三条都不符合，那么直接与后面一个数结合。每次开头判断是否大于 $10$，如果是就直接跳过 $2$个字符，并加入当前数。最后特判一下最后一个数就行了。

## code

```cpp
#include<bits/stdc++.h>
using namespace std;
int q,n;
char t[55];
int main(){
	scanf("%d",&q);
	while(q--){
		scanf("%d",&n);
		for(int i=1;i<=n;i++){
			cin>>t[i];
		}
		int wz=1,s=t[1]-'0';
		string ans="";
		while(wz<=n){
			if(s>=10){//如果已经大于10了 
				ans+=s+'0'+48;
				s=t[wz+2]-'0';
				wz+=2;//跳过后面加的0 
				continue;
			}
			if(t[wz+1]=='!'){//特判最后一个数 
				ans+=s+'0'+48;
				break;
			}
			int ss=s*10+(t[wz+1]-'0');//与后面结合后的数 
			if(ss>26){//第一种情况 
				ans+=s+'0'+48;
				s=t[wz+1]-'0';
			}
			else if(ss>=10){
				if(t[wz+2]!='0'){//第二种情况 
					ans+=s+'0'+48;
					s=t[wz+1]-'0';
				}
				else{
					if(t[wz+3]=='0'){//第三种情况 
						ans+=s+'0'+48;
						s=t[wz+1]-'0';
					}
					else{
						s=ss;//都不符合就与后面结合
					}
				}
			}
			else{
				s=ss;//都不符合就与后面结合 
			}
			wz++;
		}
		for(int i=1;i<=n;i++){
			t[i]='!';//数组清零 
		}
		cout<<ans<<"\n";
	}
	return 0;
} 
```
