从让 $d$ 从 $0$ 开始逐步递增，每次判定 **恰好** $d$ 步操作是否能得到目标状态。

将二序列的状态看作二进制数，设 $c_i(s)$ 为状态 $s$ 循环移动 $i$ 位的结果。

首先忽略每次的反转 $b$ 序列操作，若初始 $a$ 序列状态为 $s$、$b$ 序列状态为 $t$，则 $d$ 步后 $a$ 序列的状态为 $r_d'=s\oplus(\oplus_{i=0}^{d-1}c_i(t))$。（$\oplus$ 表示二进制按位异或）

接下来考虑反转 $b$ 序列的操作。

![](https://cdn.luogu.com.cn/upload/image_hosting/xs03a2i1.png)

由上图可发现规律：第 $i$ 次反转相当于让最终结果连续的 $d-i+1$ 位反转（注意序列是首尾相接的），则问题转化为：

使最终结果 $r$ 初值为 $r_d'$，共 $d$ 次操作，第 $i$ 次操作反转 $r$ 循环序列上的连续 $i$ 位，问是否有一种操作方案使得 $r$ 在所有反转完成后值为 $0$。

设 $f_{i,j}$ 表示 $j$ 状态是否可用 **恰好** $i$ 次操作得到 $0$。要询问恰好 $d$ 步操作能否得到目标状态，只用判断 $f_{d,r_d'}$ 的值即可。

经程序验证，对于所有状态 $j$，都有 $f_{n,j}=\operatorname{true}$，则 **最小步数一定不超过** $n$。因为所有询问中 $n$ 相等，只用在询问前预处理出所有的 $f_{i,j}$ 即可。因为 $i$ 次反转操作实质上是 $i-1$ 次的操作基础上反转长为 $i$ 的段得到的，因此预处理时时间复杂度为 $\Theta(2^nn^2)$，每次询问时间复杂度 $\Theta(n)$。

```cpp
main() {
	int m, q; scanf("%d%d",&q,&m);
	int n=(1<<m); f[0][0]=true;
	sum[0]=1; for (int i=1; i<=m; ++i) sum[i]=sum[i-1]|(1<<i);
	for (int i=1; i<=m; ++i) { // 预处理 f 数组
		for (int j=0; j<m; ++j) {
			int r=j+i-1, sta=sum[min(m-1,r)];
			// i-1 次操作结果异或长 i 的连续段即为 i 次操作结果
			if (j) sta^=sum[j-1];
			if (r>=m) sta|=sum[r-m]; // 考虑从末尾循环到开头的部分
			for (int k=0; k<n; ++k) f[i][k^sta]|=f[i-1][k];
		}
	}
	int mm = m-1;
	while (q--) {
		int x=read(), t=read();
		for (int i=0; i<=m; ++i) { // 枚举判定答案是否为 i
			if (f[i][x]) { // 此时 x = r_i'
				printf("%d\n",i); break;
			}
			x ^= t; // r_{i+1}' 在 r_i' 的基础上多异或了一次 b 的循环移位
			t = (t>>1)|((t&1)<<mm); // 将 b 的状态循环移位
		}
	}
	return 0;
}
```