看了下前几页的题解没找到太像的 所以还是勇敢的传一下试试  
~~不想莫名不被通过~~
# 思路：
### 因为只有零和一 且 零分为两种 所以我们不妨先把它手动分成三个数（~~问题就是要做这件事~~） 圈里的并不算好找 看dalao们的题解可能初学dfs的~~蒟蒻~~我也不是很理解 于是就~~百度到~~想到我们只需要把圈外零的用dfs先变成其他的数 最后全盘扫一遍 把没被改变的零（即圈内零）变成需要的数（2） 同时要是检测到圈外数（刚刚dfs更改的）把它变回0就OK啦！！！
# 代码：


------------

```cpp
#include <cstdio>
using namespace std;
int n;
int a[32][32];
void dfs(int x, int y){
	if(x >= 0 && x <= n + 1 && y >= 0 && y <= n + 1){
		if(a[x][y] == 1 || a[x][y] == 3) return ;
		else{a[x][y] = 3;
			dfs(x + 1, y); dfs(x - 1, y);
			dfs(x, y + 1); dfs(x, y - 1);}
	}
}
int main(){
	scanf("%d", &n);
	for(int i = 1; i <= n; ++ i)
	for(int j = 1; j <= n; ++ j)
	scanf("%d", &a[i][j]);
	dfs(0, 0);
	for(int i = 1; i <= n; ++ i)
	for(int j = 1; j <= n; ++ j)
	if(a[i][j] == 3) a[i][j] = 0;
	else if(a[i][j] == 0) a[i][j] = 2;
	for(int i = 1; i <= n; ++ i, printf("\n"))
	for(int j = 1; j <= n; printf("%d ", a[i][j]), ++ j) ;
	return 0;
}

```
### 注意：dfs在先搜索的时候应该搜索到矩阵的外面一圈（0， n + 1） 否则的话就会出现错误（边缘处被涂色）
#### 输入：  
6    
0 0 1 1 1 0  
1 1 1 0 1 0  
1 0 0 0 0 1    
1 1 0 1 1 1   
0 1 0 1 0 0  
0 1 1 1 0 0  
### 正确输出：  
0 0 1 1 1 0  
1 1 1 2 1 0  
1 2 2 2 2 1  
1 1 2 1 1 1  
0 1 2 1 0 0  
0 1 1 1 0 0  
### 错误输出： ~~自己改边界跑一下试试~~  
求审核给过一次 嘤嘤嘤~





