    哈哈哈本人第一次发布题解,希望管理员大大审核的时候手下留情!
   
   这一题为什么是**BFS**呢,**因为DFS的效率其实没有BFS那么高**
   
   
   为什么:
   
   看完代码之后你就知道了
   
   ### 思路:
   1.我们假设所有的'0'其实都被包围,但事实上并不是
   
   2.犯了错误就要纠正,具体有哪一些本来并不是被包围的'0'被我们误认成了被包围的?
   
   3.我们发现,那些在矩阵边缘的其实都不应该被包围!(这个就自己证明吧)
   
   
   ##### 程序实现:
   
   1.先认为所有的'0'都应该被修改,并且真的把它修改成了'2';
   
   2.边角上的'2'其实本来不应该被修改的,那我们把他们改回去  ,改成'0'
   
   3.然后来寻找与这些零相邻的'2',它们其实也是被改错了的
   ```
#include<iostream>
#include<ctime>
#include<cstdio>
using namespace std;
int num[40][40],c;
int k;
int main()
{
	int i,j,k,l;
	cin>>c;
	for(i=1;i<=c;i++)for(j=1;j<=c;j++)
	{
		scanf("%d",&num[i][j]);
		if(num[i][j]==0)num[i][j]=2;
	}
	for(i=1;i<=39;i++)
	{num[0][i]=9;num[i][0]=9;}//这一行先不要管,先看懂整个程序
	//输入+预处理结束 
	for(i=1;i<=c;i++)
	{
		if(num[1][i]==2){num[1][i]=0;}
		if(num[i][1]==2)num[i][1]=0;
		if(num[c][i]==2)num[c][i]=0;
		if(num[i][c]==2)num[i][c]=0;//针对所有边角料来一遍 
	}
	for(k=1;k<=100;k++)//广度优先搜索 阈值=100 (事实上不需要那么多)
	for(i=1;i<=c;i++)
	for(j=1;j<=c;j++)
	{
		if(num[i][j]!=1)
		if(num[i][j-1]==0||num[i-1][j]==0||num[i+1][j]==0||num[i][j+1]==0)
		num[i][j]=0; 
	}
	for(i=1;i<=c;i++)
	{
		
		for(j=1;j<=c;j++)
		printf("%d ",num[i][j]);
		cout<<endl;
	}
	return 0;
}
```