[传送门](https://www.luogu.org/problem/P1162)

此题是要找一个包围的圈，里面填色。

反过来想只要把外面的没被包围的找到就行

- #### 但是外面的被切割成了好几块（如测试点#2），怎么办

```
6
0 0 1 1 1 0
1 1 1 0 1 0
1 0 0 0 0 1
1 1 0 1 1 1
0 1 0 1 0 0
0 1 1 1 0 0

```


**最笨的办法：**

```cpp
for (int i = 1; i <= n; i++) {
	if (a[n][i] != 1) dfs(n, i);
	if (a[1][i] != 1) dfs(1, i);
}
for (int i = 1; i <= n; i++) {
	if (a[i][1] != 1) dfs(i, 1);
	if (a[i][n] != 1) dfs(i, n);
}
```

**比较聪明的办法：**

因为矩阵是从$(1, 1)$开始的，所以不妨把矩阵周围的格子也打开

就像水流一样，从$(1, 1)$开始放的话可能遇到格子为$1$的就停了

但如果从$(0, 0)$开始放，原矩阵外的格子不会有$1$，那么水就会流过去，从而所有没被包围的格子会有水流到

- #### $dfs$（俗称大法师）一定要用$4$个$if$来搜索吗

定义方向数组：

```cpp
int dx[] = {0, 0, -1, 1};
int dy[] = {1, -1, 0, 0};
```

那么三行就搞定了：

```cpp
for (int i = 0; i < 4; i++) {
		dfs(x + dx[i], y + dy[i]);
}
```

- #### 死循环怎么办

要知道，搜到下个格子后，可能会从下个格子搜回来，造成了死循环

定义$visit$数组，没搜到时为$0$，搜到一个后便把它标记为$1$（已搜）

> 希望可以帮助到萌新
> 
> $OI$之路十分漫长，此题只是一个微小的开始，但也是一个伟大的开始





