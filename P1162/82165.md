看了这么多题解，居然发现没有人用我这种方法

------------

蒟蒻：一拿到这到题我就对样例观察了一番，发现了这个圈的特点便是1 0 1。

二狗（一脸疑惑）：啥是1 0 1？

蒟蒻：就拿n为5的来说吧。

蒟蒻：形如1 0 0 0 1 ，1 0 0 1 1 ，1 0 1 1 1 ，0 1 0 0 1 ，0 1 0 1 1 ，0 1 1 0 1 ，0 0 1 0 1 ......
   
二狗（打断蒟蒻的话）：停停停，别举例子了，我已经懂了。

二狗（想了想）：为什么说是1 0 1呢？

蒟蒻：因为对于每一行输入来说，只要是第一个出现有1 0 1种格式的，中间的 0 一定属于圈内的 0 ，注意，是第一个，然后我们只要对这个0进行搜索就好啦。

蒟蒻：我给你举几个栗子，

	n=6

	0 0 0 0 0 0

	0 0 1 1 1 1

	0 1 1 0 0 1
	
	1 1 0 0 0 1

	1 0 0 0 0 1
	
	1 1 1 1 1 1

蒟蒻：你看上面这个样例，第三行的0 1 1 0 0 1，就是出现的第一个1 0 1，夹在中间的两个0，就是圈内的0。再给你举个例子。

	n=6

	0 1 1 1 1 0
	
	1 1 0 0 1 1
	
	1 0 0 0 0 1
	
	1 0 0 0 0 1
	
	1 1 0 0 1 1
	
	0 1 1 1 1 0 

蒟蒻：你看第二行的1 1 0 0 1 1 ，也是出现的第一个1 0  1，夹在中间的两个0也是圈内的0，这下你应该懂了吧。

二狗（皱了皱眉头）：你这不对啊！

蒟蒻（ÒωÓױ）：哪不对啦？？

二狗（拿出草稿纸画了画）：你看你看。

	n=9
	
	0 1 1 1 0 1 1 1 0
	
	0 1 0 1 0 1 0 1 0
	
	1 1 0 1 1 1 0 1 1
	
	1 0 0 0 0 0 0 0 1
	
	1 1 1 1 0 0 0 1 1
	
	0 0 0 1 1 0 1 1 0
	
	0 0 0 0 1 0 1 0 0
	
	0 0 0 0 1 0 1 0 0
	
	0 0 0 0 1 1 1 0 0
	
二狗（把草稿纸递给蒟蒻）：你看这栗子，既然这样话，第一行的0 1 1 1 0 1 1 1 0就是出现的第一个1 0 1。那你不是错了吗？

蒟蒻（拍了一下脑袋）：对哦，看样子不能找第一个1 0 1了。

二狗：找第二个不就好了吗？

蒟蒻（恍然大悟）：Aha！不愧是二狗！

（正当他们准备提交代码时）

蒟蒻（忽然感觉不太对）：咦？那如果只有一个1 0 1的话，上哪去找第二个呢？

二狗（慌了）：那咋办？？

蒟蒻（沉思....）:既然这样的话，我们把第一个1 0 1也记录下来，第二个也记录下来。如果有多个1 0 1的话，就用第二个1 0 1，如果只有一个1 0 1的话，就用第一个。

二狗：搜嘎斯内。

```cpp
#include<bits/stdc++.h>
using namespace std;
struct node{
	int x;
	int y;
}st,by;
const int dx[5]={0,1,-1,0,0},dy[5]={0,0,0,1,-1};
int n,a[40][40],sum;
bool flag;
queue<node> q;
void dfs(node now){
	for(int i=1;i<=4;i++){
		node nxt;
		nxt.x=now.x+dx[i];
		nxt.y=now.y+dy[i];
		if(nxt.x>=1&&nxt.y<=n&&nxt.y>=1&&nxt.y<=n&&a[nxt.x][nxt.y]==0){
			a[nxt.x][nxt.y]=2;
			dfs(nxt);
		}
	}
}
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		bool flag1=0,flag2=0,flag3=0;
		int x=0,y=0;
		for(int j=1;j<=n;j++){
			scanf("%d",&a[i][j]);
			if(a[i][j]==1&&flag1==0){
				flag1=1;
			}
			if(a[i][j]==0&&flag1==1&&flag2==0){
				flag2=1;
				x=i,y=j;
			}
			if(a[i][j]==1&&flag1==1&&flag2==1&&flag3==0){
				flag3=1;
			}
		}
		if(flag1==1&&flag2==1&&flag3==1){
			sum++;
			if(sum==1){
				by.x=x;
				by.y=y;
			}
		}
		if(sum==2){
			st.x=x;
			st.y=y;
		}
	}
	if(sum==1){
		st.x=by.x;
		st.y=by.y;
	}
	a[st.x][st.y]=2;
	if(n%2==0){
		q.push(st);
		while(!q.empty()){
			node now=q.front();
			q.pop();
			for(int i=1;i<=4;i++){
				node nxt;
				nxt.x=now.x+dx[i];
				nxt.y=now.y+dy[i];
				if(nxt.x>=1&&nxt.y<=n&&nxt.y>=1&&nxt.y<=n&&a[nxt.x][nxt.y]==0){
					a[nxt.x][nxt.y]=2;
					q.push(nxt);
				}
			}
		}
	}
	else{
		dfs(st);
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			printf("%d ",a[i][j]);
		}
		printf("\n");
	}
	return 0;
}

```