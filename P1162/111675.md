第一次发题解，求给过（眼泪汪汪）。

首先讲一下思路：根据题意，当找到第一个1时，其右下必然是圈内的0，那么只要从这个0开始广搜寻找联通块就可以了。（因为圈只有一个，那么当找到第一个1之后便要打断循环，很重要！）

话不多说，上代码！

```cpp
#include<iostream>
using namespace std;
int n；
int dx[4]={1,0,-1,0},dy[4]={0,-1,0,1};//定义方向数组（暂且这么叫吧。）
int map[31][31];//用于存放矩阵
void cz(int p,int q){//bfs函数
	int h[1000][2];//定义队列
	int t,w,x,y,i;//t、w分别表示头、尾指针，x、y即横纵坐标
	map[p+1][q+1]=2;t=0;w=1;//将找到的1的右下角的0改为2
	h[1][1]=p+1;h[1][2]=q+1;//将0入队
	do{//四向广搜
		t++;
		for(i=0;i<=3;i++){
			x=h[t][1]+dx[i];y=h[t][2]+dy[i];//这里举个例子:当i=0时，横坐标加上dx【0】即1，纵坐标加上dy【0】即0，就表示向下搜索
			if(map[x][y]==0){//判断是否可以入队
				w++;
				h[w][1]=x;h[w][2]=y;
				map[x][y]=2;//“上色”
			}
		}
	}while(t<w);//队空则停止搜索
}
int main(){
	int i,j;
	bool f=0;
	cin>>n;
	for(i=0;i<n;i++){//输入矩阵
		for(j=0;j<n;j++){
			cin>>map[i][j];
		}
	}
	for(i=0;i<n;i++){//搜索第一个1
		for(j=0;j<n;j++){
			if(map[i][j]==1){
				cz(i,j);
				f=1;
				break;//找到后立即打断循环，因为只有一个圈
			}
		}
		if(f)break;
	}
	for(i=0;i<n;i++){//输出“上色”后的矩阵
		for(j=0;j<n;j++){
			cout<<map[i][j]<<" ";
		}
		cout<<endl;
	}
}
```
完成！

这里主要跟大家分享一下方向数组，刚学的，很方便不是吗？

如有不足还请dalao指正（抱拳）

（求过求过求过求过求过）