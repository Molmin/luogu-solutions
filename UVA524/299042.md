~~题目太水~~

------------
这题的中心思想就是 深度优先搜索DFS

我们要搜索每一个位置的可能会有哪些数。如果最后搜索出来的组合合法，我们就把它直接输出。

**注意：UVa的题目格式不能有任何多余空格和换行。我提交的时候好几次是`Presentation Error`**

------------
我们一步一步来。

0. 所需变量

$n$ ：如题所述

$i$ ：用于 `Case` 输出

$a[]$ ：答案数组，用来存储答案

$vis[]$ ：用来标记是否用过

1. 主函数

- 输入

`while(scanf("%d", &n) != EOF)`

题目说了：
>直到读到EOF结束

所以我们只用判断读进来的是否是`EOF`就行了

- 初始化
```cpp
memset(a, 0, sizeof(a));
memset(vis, 0, sizeof(vis));
a[1] = 1, vis[1] = 1;
```
把答案数组和标记数组初始化就行了

为了防止重复，我们把每一个答案的第一个数都定为1，而标记数组也同样要更改。

- `\n` 符 **坑点**
```cpp
if(i > 0)
{
	printf("\n");
}
```
只有第二次以后的前面才需要换行符，如果每一次后面都跟着一个换行符到最后一行会多出一行，这时就会`Presentation Error`。

- 初始输出

如题所述，每组数据前面都要输出 `Case ……`

`printf("Case %d:\n", ++i);`

- $dfs()$

最重要的部分~~没什么好讲~~

`dfs(2);`

因为第一个数已经锁定了，直接从第二次开始就行了。

2. $dfs()$ 函数

需要一个参数 $step$ ，表示已经走到哪一步了。

- 判断

我们要先判断是否到达了 $n$ ，如果到达了并且符合要求就输出。
```cpp
if(step > n)
{
	if(prime(a[n], a[1])) // 如果头尾相加是质数
	{
		for(int i = 1; i < n; i++) // 一个坑
		{
			printf("%d ", a[i]);
		}
		printf("%d\n", a[n]); // 不想Presentation Error就得多写几个字
	}
}
```
- 否则

如果没到步数呢？我们就要继续搜索。
```cpp
else
{
	for(int i = 2; i <= n; i++) // 因为1已经被用过了，从2开始搜索
	{
		if(!vis[i] && prime(a[step - 1], i)) // 如果没用过并且符合条件
		{
			a[step] = i;
			vis[i] = 1; // 标记一下
			dfs(step + 1); // 搜索
			vis[i] = 0; // 与回溯
		}
	}
}
```
至此，我们的程序就结束了。

------------
小朋友，你是否有很多问号？

$prime()$ 是个什么东东？

~~哦，对，差点忘了~~

```cpp
bool prime(int x, int y)
{
	int s = x + y; // 求和
	if(s == 0 || s == 1) // 加一个特判（好像也没用）
	{
		return 0;
	}
	for(int i = 2; i * i <= s; i++) // 因为精度问题，老师不建议用sqrt()
	{
		if(s % i == 0) // 再说也没意思了……
		{
			return 0;
		}
	}
	return 1;
}
```
$prime()$ 函数也就结束了

整个~~程序~~题解也就结束了

~~写题解不易，大家点个赞呗~~