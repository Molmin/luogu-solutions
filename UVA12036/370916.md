## 题目意思
给定一个 $n*n$ 的矩阵，让你改变每一行的数字顺序（也可以不改），让每一列上的数字都不一样。
## 算法实现
首先，我们先来寻找一下规律。

例如给出数据：

$t$ =1, $n$ =3

17 16 19

19 17 16

16 17 19

显然这组数据是可以过的，也就是把第三行的17和19换个位置。

再给出数据：

$t$ =1, $n$ =4

5 6 9 8

8 6 5 9

8 9 5 6

9 8 5 8

显然这组数据是不可以过的，因为第三行有两个8，并且每一行都有一个8。

这样，我们就有规律可寻了。

已知第一个样例中没有一个数的出现次数是超过 $n$ 的，第二个样例中，8出现的次数超过 $n$ 了。

那么，我们就得出了算法的主要部分：
```cpp
for(int i=1;i<=n*n;i++)
{
        int a;
        cin>>a;
        f[a]++;
        if(f[a]>n)
           ok=1;
}
```
统计每一个数出现的次数，如果有一个数出现的次数大于 $n$ 了，则不能成功。  

但是，这是为什么呢？我们就要证明了。

如果一个数出现的次数比 $n$ 还多，每一列只能有一个，总共只有 $n$ 列，也就是说，不管怎么分，总是有一列会多出一个。所以是不可行的。

如果没有一个数是超过 $n$ 的，则一定可以。就拿第一个给出的数据说好了，如果有数字个数是等于 $n$ 的，那么他肯定是要首先考虑的，这就很像“八皇后”问题，只是斜线上可以摆而已，我们根据“八皇后”问题的搜索思路，就可以将每一个数都摆放在矩阵中。

然后，就是输出部分了：
```cpp
printf("Case %d: ",w);
if(!ok)
    cout<<"yes"<<endl;
else 
    cout<<"no"<<endl;
```
至于 $w$ ，在输入 $t$ 组数据是用 $for$ 循环就可以了。

## 一些人最喜欢的代码环节
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int t;
int n;
int f[105];
int ok=0;
signed main()
{
    cin>>t;
    for(int w=1;w<=t;w++)
    {
        cin>>n;
        ok=0;
        memset(f,0,sizeof(f));
        for(int i=1;i<=n*n;i++)
        {
	    int a;
            cin>>a;
            f[a]++;
            if(f[a]>n)
                ok=1;
        }
        printf("Case %d: ",w);
        if(!ok)
            cout<<"yes"<<endl;
        else 
            cout<<"no"<<endl;
    }
    return 0;
}
```
好了就这样，一道水题收入囊中。。。

（感谢管理员大大的负责qwq）