## Description
- 给一些字符，你需要构造一个字符串，使得它的每一个前缀子串的公共前后缀最小
- 若有多种情况，输出字典序最小的。
## Solution
这题分类很烦，很多大佬都是清晰地直接分类，但是我更想还原一种思考的过程，这是我们在考场上更需要的。

这种毫无思路的题，拿到只好暴力打表玩数据。。

我们惊讶得发现，大部分串的答案（最长公共前后缀）都为1 。

顺着这个思路往下走，如何构造1 。我们设字典序最小的那个字母为 $a$ ，第二小为 $b$ ，第三小为 $c$

首先肯定 $aa$ 开头，如果再接 $a$ ， $aaa$ 的答案就为2了，那么我们接 $b$ ，$aab$ 再接 $a$ 依然答案为1，所以问题不大，继续上 $a$ ，然后类推，最后串的开头应该是这样 $aabababab...$ 对于 $c$ 及其以后的字母，接在 $ab$ 后面，所以我们构造出了一种串，形如 $aababab..ccddeeffggxxyyzz$ 
如果 $b$ 不够用， $c$ 接上，效果一样的

然而这种情况不能满足所有数据，以上的情况要使 $a$ 少于一半，否则可能出现 $aabababcdaaaaaa$ 的情况，答案就为2了，而我们依然要使答案为1，怎么办呢。只有第二位填 $b$ 了，那么后面填再多的 $a$ 也只会使答案为1，要使字典序最小，就在 $b$ 后面疯狂填 $a$ ，但是后面不能出现 $ab$ 了，所以在 $a$ 之后填一个 $c$ ，在案字典序填。最后形如 $abaaaaaaaaaaaaacbcddeeff$

当然，答案会不会是0呢，当然可能。细心的小伙伴应该已经发现了，我在上面的每一个串后面的乱七八糟的字母都打了两个，其实想一想，如果有一个字母仅出现了一次，那么答案一定为0，我们只要找到一个字典序最小的扔到前面然后剩下的字母按顺序输出就行了。

还有一个显然的情况，样例已经友好地给我们了，就是仅有一种字母，直接输出吧。

## code
细节超多，慢慢调吧

[出门右转](https://codeforces.com/contest/1530/submission/134021829)