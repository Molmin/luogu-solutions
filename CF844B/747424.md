## 题意
给一个 $01$ 矩阵，求有多少子点集满足：

- 点全是 $0$ 或点全是 $1$。 

- 点都在同一行或同一列上。

## 思路
首先我们要注意一点：题目中让求的子点集可以不相连，例如样例二：
```
2 3
1 0 1
0 1 0
```
其中除了六个单独一个点成一个子点集，还有第一行两个 $1$ 和第二行两个 $0$ 也算两个子点集。

所以计算中间不相连，也可以成为子点集。

那我们的思路就简单多了，循环枚举每一行和每一列，分别求出来每一行每一列 $0$ 和 $1$ 的个数。

当求出 $0$ 或 $1$ 的数量后，不难发现，这一行或者一列子点集的个数就是 $2^n-1$，其中 $n$ 是 $0$ 或 $1$ 的数量。   

我们把每一行每一列的子点集数都相加，就求出答案了。

### 注意

我们上面算每一行的子点集数包含单独一个点成一个子点集的数量，当算每一列时，也包含单独一个点成一个子点集的数量，也就是我们算了两遍。

所以我们需要让子点集总数减去一遍，也就是减去 $n\times m$。

还有记得开 ```long long```，算 $2^n-1$ 时 ```int``` 会炸。
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int n, m, a[55][55], s;
int sum(int n){ //计算子点集数量
    return pow(2, n) - 1;
}
signed main(){
    scanf("%lld%lld", &n, &m);
    for(int i = 1; i <= n; i ++)
      for(int j = 1; j <= m; j ++)
        scanf("%lld", &a[i][j]);
    for(int i = 1; i <= n; i ++){
        int t1 = 0, t2 = 0;
        for(int j = 1; j <= m; j ++){
            if(a[i][j] == 0)t1 ++;
            else t2 ++;    
        } //计算每一行0和1的数量
        if(t1 != 0)s += sum(t1);
        if(t2 != 0)s += sum(t2);
    }
    for(int j = 1; j <= m; j ++){
        int t1 = 0, t2 = 0;
        for(int i = 1; i <= n; i ++){
            if(a[i][j] == 0)t1 ++;
            else t2 ++;
        } //计算每一列0和1的数量
        if(t1 != 0)s += sum(t1);
        if(t2 != 0)s += sum(t2);
    }
    printf("%lld", s - n * m); //去掉重复部分
    return 0;
}
```
