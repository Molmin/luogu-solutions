[题目传送门](https://www.luogu.com.cn/problem/CF844B)

## 题目大意

给出一个仅包含字符零一的矩阵，求**同时**满足如下要求的子点集个数：

- 点集中所有的字符均为零或一。
- 点集中所有的字符均在同一行或同一列。

## 题目分析

我们可以将满足要求的子点集分成三种：

- 单独的一个点，肯定满足要求。
- 字符个数大于一且均在同一列的。
- 字符个数大于一且均在同一行的。

第一种子点集的个数非常好计算，就是 $n \times m$。

对于第二种子点集，考虑枚举列号，对每一列分别计算，再分为全是零的和全是一的。

全是零的和全是一的一样，这里用全是零的举例。

容易发现其实就是这一列中字符全是零且长度大于一的子序列，数量其实就是 $2^c - c - 1$，其中 $c$ 为零的数量。（因为 $2^c$ 就是全是零的子序列个数，因为要去掉空的子序列所以需要减一，因为要去掉长度为一的子序列所以要减去 $c$。）

对于第三种子点集，和第二种计算方法一样，对每一行分别计算即可。

最后将三种子点集的个数累加即可。

时间复杂度 $\mathcal{O}(nm)$，原题数据范围 $1 \le n, m \le 50$ 所以可过。

## 坑点描述

1. 这道题答案十分大，超出了 `int` 的最大值 $2^{31}-1$，所以需要开 `long long`，如果不开 `long long` 你会在第十八个点得到一个负数。
1. 由于精度问题，计算 $2^c$ 时千万不要用 `<cmath>`（或 `<math.h>`）库中的 `pow` 函数，直接用 `1LL << c` 表示 $2^c$ 即可，否则你会在第十八个点 WA 掉。（也不能写成 `1 << c`，因为这样的话就会计算出来一个 `int` 的值。）

~~别问我怎么知道的那么清楚。~~

## 最终代码

```cpp
#include <iostream>
#include <cmath>
#define int int64_t
#define maxn 64
using namespace std;
int n, m;
char c[maxn][maxn];
int ans;
signed main() {
    cin >> n >> m;
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= m; j++)
            cin >> c[i][j];
    for (int i = 1; i <= n; i++) {
        int cnt0 = 0, cnt1 = 0;
        for (int j = 1; j <= m; j++)
            if (c[i][j] == '0')
                cnt0 += 1;
            else
                cnt1 += 1;
        ans += (1LL << cnt0) - cnt0 - 1, ans += (1LL << cnt1) - cnt1 - 1;
    }
    for (int i = 1; i <= m; i++) {
        int cnt0 = 0, cnt1 = 0;
        for (int j = 1; j <= n; j++)
            if (c[j][i] == '0')
                cnt0 += 1;
            else
                cnt1 += 1;
        ans += (1LL << cnt0) - cnt0 - 1, ans += (1LL << cnt1) - cnt1 - 1;
    }
    cout << ans + n * m;
    return 0;
}
```
运行时间：$165$ 毫秒。

如有错误欢迎在评论区指出，如果对您有用就太好了。