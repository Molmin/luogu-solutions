首先有两个非常显然的结论：

1. 括号只会加在减号后（因此括号内的运算一定取反）
2. 两个右括号，两个左括号不会重合在一起。

> $$x_0-(x_1-(x_2))$$
>
> 这个应该等于（$x_{0,1,2,3}$ 都是表达式，即若干个 $a_i$ 的计算结果再移项）
>
> $$x_0-(x_1)+x_2$$

3. 括号不会套到 $\ge3$ 层。说一下原因。

> $$x_0-(x_1-(x_2-(x_3)))$$
>
> 这是带三次括号式子的一般形态。考虑将其化简。
>
> $$x_0-x_1+x_2-(x_3)$$
> 
> 但是显然的有另一种得到这个化简结果的方案。
> 
> $$x_0-(x_1-x_2)-(x_3)$$
>
> 所以套到 $\ge3$ 层的括号都可以化简为更简单的情况。


---

我们考虑 $f_{i,j}$ 代表计算到第 $i$ 位，目前有 $j$ 个未匹配的左括号，此时的最大答案。（$j=0,1,2$）

> 为什么可以想到设计这个状态？$f_i$ 表示计算到第 $i$ 位的答案其实是蛮好想到的，不过这个状态太简陋（表示不了括号的嵌套关系），结合二结论不难可以想到一维与括号相关。

然后考虑转移。

+ 转移 $\tt0$：对 $i$ 这一位不加括号。

$$f_{i,j}=f_{i-1,j}\pm a_i$$

> 解释：正常从 $i-1$ 那一位继承答案。至于那个 $\pm$ 是取加还是减，要看 $a_i$ 前原先的符号，以及目前套着括号个数 $j$（套一个括号符号取一次反）

+ 转移 $\tt1$：在 $i$ 这一位后加一个右括号。

$$f_{i,j}=f_{i-1,j+1}\pm a_i$$

> 解释：加一个右括号，相当于消掉了一位左括号，所以要从 $j+1$ 那里继承答案。$\pm$ 取加还是减类似。

+ 转移 $\tt2$：在 $i$ 这一位前加一个左括号。

$$f_{i,j}=f_{i-1,j-1}\pm a_i$$

> 解释：加一个左括号，相当于新增了一位没有匹配的左括号，所以要从 $j-1$ 那里继承答案。$\pm$ 取加还是减类似。

但是并不是 $\forall j=0,1,2$ 都可以用上述式子，有些边界情况特判。

---

$\tt DP$ 数组只会用到上一位的答案，所以可以滚动数组，空间变成 $O(1)$。

```cpp
#include<stdio.h>

using ll = long long;

#define rep(i,a,b) for(int i = (a);i <= (b);++i)

void chkmax(ll &x,ll y){ x < y && (x = y); }

int n,op; ll x,dp[2][3]; char c;

int main(){
	scanf("%d",&n);
	dp[0][0] = 0; dp[0][1] = dp[0][2] = -9e18;
	rep(i,1,n){
		op = (c == '-' ? -1 : 1);
		scanf("%lld",&x),x *= op;
		int cur = i & 1,lst = cur ^ 1;
		rep(j,0,2) dp[cur][j] = dp[lst][j] + x * (j & 1 ? -1 : 1);
		chkmax(dp[cur][0],dp[lst][1] - x);
		if(n > 1) chkmax(dp[cur][1],dp[lst][2] + x);
		if(op < 0) chkmax(dp[cur][1],dp[lst][0] + x);
		if(op < 0) chkmax(dp[cur][2],dp[lst][1] - x);
		if(c != n) do c = getchar(); while(c == ' ');
	}
	printf("%lld\n",dp[n & 1][0]);
	return 0;
}
```