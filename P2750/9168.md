一开始我直接搜索，从小到大放数(字母当成数)，每个数枚举行，

之后放在这一行已放的末尾，前提是上一行放的比这一行多。

（因为否则该数的左边或上面就无数可放了）。

之后发现可以记忆化，用f[a,b,c,d,e](第i个参数表示第i行已放的数目)表示

该情况下的方案数。


后来我发现从小到大枚举字母并不能保证字典序从小到大，

如将7放在第二行的所有情况未必比将7放在第三行的所有情况字典序都小，

因为第1行会优先影响字典序。


于是只能从小到大枚举行，列，数；但是我们知道之前的搜索虽然不保证字典序升序，

但求出的方案数是正确的。所以可以求出当前状态下的方案数。比如当前状态已经放了

AB,我们就可以求出接下来的方案数。如果总方案数+当前方案数<所求方案数，

我们就让总方案数加上当前方案数，之后再尝试AC。

时间（5\*5\*25\*（6^7）≈3\*10^7），而实际时间远远小于这个数，只用了10ms。
