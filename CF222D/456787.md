### 思路
首先,很明显，最高肯定是第一名，所以问题就在如何把最坏成绩往下降。因为不知道名字，所以我们可以随意组合第一轮和第二轮的成绩。两个数组分别 $sort$ 一下之后我们从第一轮的成绩从小开始看。

如果这个成绩大于 $x$ ，那么就把它和第二轮目前最小的成绩组合。

如果这个成绩小于 $x$ ，并且加上第二轮目前最大的成绩之后能比 $x$ 大，那就把它和第二轮最大的成绩组合。

如果这个成绩不仅小于 $x$ ，而且加上第二轮目前最大的也比 $x$ 小 $($没救了$)$ ，那我们就不在它身上浪费分数了，把它与目前最小的第二轮成绩组合。

在这样组合之后， $sort$ 一下，在从小的看，就能找到这个人的最差排名。

### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,x,a[100005],b[100005],c[100005];//c是用来记录组合之后的总分数
int main()
{
	scanf("%d%d",&n,&x);
	int h=n,t=1;//记录当前第二轮最大的分数和最小的分数
	for(int i=1;i<=n;i++) scanf("%d",&a[i]);
	for(int i=1;i<=n;i++) scanf("%d",&b[i]);
	sort(a+1,a+n+1);
	sort(b+1,b+n+1);
	for(int i=1;i<=n;i++)
	{
		if(a[i]>=x||a[i]+b[h]<x) c[i]=a[i]+b[t++];//没救了或者本身就大于x，就与最小的相加
		else c[i]=a[i]+b[h--];//还值得抢救的就与最大的相加
	}
	sort(c+1,c+n+1);//记得排序
	printf("1 ");//最好成绩肯定是第一名（其实什么时候输出都行）
	for(int i=1;i<=n;i++)
	{
		if(c[i]>=x)//找到了
		{
			printf("%d",n-i+1);
			break;
		}
	}
	return 0;
}
```

###### 完结撒花