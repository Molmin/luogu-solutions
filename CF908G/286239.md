%%%kelin大佬

补充一下kelin大佬题解的几个细节

1. 为什么有“个大于等于k的数字”的情况对答案的贡献要乘上11111...：

```
1 1 1 2 3 3 ..... k   k   k   k+2  k+2 ...
先考虑1，将1以及以后的位对答案的贡献都减去1，再将这些数都减去1，即：
ans +=
1 1 1 1 1 1 ..... 1   1   1   1    1 ...
原数列对答案的贡献变为：
0 0 0 1 2 2 ..... k-1 k-1 k-1 k+1  k+1 ...
因为我们不在原数列中修改，所以接下来对2计算贡献的时候，
现数列对答案的贡献中大于0的位会再减去1，依次类推...

如果对原数列中k+1计算贡献，但k+1不在原数列中呢？
也不难：我们找到的大于等于k+1的数的个数就是k+2 k+2 ...的所有数，
这些数减去1同时记录答案，就变为了：
0 0 0 0 0 0 ..... 0   0   0   1    1 ...
正常了

其实可以按照另一个思路理解：一个数k，会对1~k每一个数“大于等于其的数的个数”作1的贡献，
所以它做出的总贡献为k，即它会被算k次贡献，即k*他的位的权值
```

2. 对于转移时p的取值，根据数位dp的传统做法不难理解：

	如果之前位不严格小于，就让最高位为该位置上的最大值，这样，最后的“不严格小于”实际上表示的是“严格等于”，所以统计答案的时候直接统计上这种情况