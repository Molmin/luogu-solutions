这个憨批 DPair 为了抢一血写了一个下午的根号做法然后卡了一个晚上的常，最终在 **神·zhoukangyang** 秒掉这道题后~~发现他代码里没分块~~才觉悟过来有超级 naive 的 polylog 做法

***

考虑这道题严格难于区间数颜色，因此不是扫描线就是莫队

莫队做法的大常数难以通过本题，因此考虑扫描线

扫描线数颜色的经典套路就是对于每一个颜色维护出其最后一次产生贡献的位置，然后求一个区间和

考虑这道题，不难发现每一个 LCA **可能** 会在 **后往前第一次** 出现的位置上产生贡献

然后我们先考虑求出所有这种位置

发现若一个点要作为 LCA 产生贡献，首先它一定可以在它本身的位置产生一次贡献，那么这类贡献总共有 $O(n)$ 个，按一般的做法处理即可

然后考虑剩下的贡献必然是这个点的两棵子树中分别取一个点

但是这样的点对个数过多了，显然不可取，我们考虑减掉无用点对

不难发现，对于三对 **合法** 点 $(u, v), (u, w), (v, w)$，若 $u<v<w$ ，那么显然 $(u, w)$ 是不可能计入贡献的。

因此能和一个点形成一个 **计入贡献的合法点对** 必然是它和它在其他子树内的前驱后继

考虑我们在更前面的点处产生贡献，那么就是它在其他子树内的前驱

那么就转化为了一个经典的问题，可以用 dsu on tree 解决

然后发现复杂度也一并解决了，仔细思考一下会发现这东西的复杂度分析和 DSU on tree 是类似的，访问到的点数是 $O(n\log n)$ 级别的，而每一个点产生的贡献是 $O(1)$，因此这样的点数就是 $O(n\log n)$ 的

因此总共是 $O(n\log n)$ 次单点修改和前驱后继操作，然后是 $O(q)$ 次区间修改

由于本题 $n, q$ 不同阶，直接上树状数组就行了

最终复杂度 $O(n\log^2 n+q\log n)$ 

