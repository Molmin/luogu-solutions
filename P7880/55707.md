我们发现，题目要求的是区间虚树的颜色个数，我们把询问离线，按右端点排序，维护每一个左端点的虚树的答案。

我们新加入一个点 $i$，虚树上最多加两个点，其中一个是这个点本身，影响到了左端点为 $[1,i]$ 的虚树。

另一个点我们在 LCT 上 access 一下，将这个点到根的链的权值赋值为 $i$。

access 时经过的每一条虚边的父亲就是可能的一个新增的节点，其影响到的虚树是一个前缀（其实是一个区间，但前面的每颗虚树都已经有这个点了，我们再加一遍也没事），前缀大小就是这个节点的权值。

那么现在问题变为，我们有 $n$ 个集合，$O(n\log n)$ 次修改，一次修改形如向一个前缀中加入一个颜色，一次查询形如单点查询集合大小。

我们对每种颜色记录当前长度为多少的前缀已经包含这种颜色，称为 $pos_i$，那么一次修改就是区间 $(pos_i,k]$ 加 1，$pos_i\larr \max(pos_i,k)$，一次查询就是单点查询，树状数组解决。

时间复杂度 $O(n\log^2n+m\log n)$，空间复杂度 $O(n+m)$。

看懂了的应该都会实现，就不放代码了。