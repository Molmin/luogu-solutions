[题目传送门](https://www.luogu.com.cn/problem/P5769)


神仙建模题。我们如果把飞机看成路径，航班看成节点，就是一个 `DAG` 最小不相交路径覆盖的问题（下面会解释）。

关键在于如何建边。 

考虑每一条边的意义。若 $u$ 和 $v$ 之间有连边，说明一条路径覆盖了 $u$ 就一定可以覆盖 $v$。在这个问题中，就是一架飞机飞了 $u$ 航班，就一定可以飞 $v$ 航班。

显然，飞机每次飞行可以为了调度而不执行航班任务。

那么就很明确了。只需要知道一架飞机在飞完 $u$ 航班后能不能在 $v$ 航班的起飞时间之前到达 $v$ 航班的起点机场。

我们用 $f_{i,j}$ 表示从机场 $i$ 出发到从机场 $j$ 出发所用的最短时间。注意，是**出发**而不是到达。

首先，$f_{i,i}=0$，因为这个状态描述的是发生相同的事情之间的时间，显然，相同事情时间相同，时间差为 $0$。

其次，$f_{i,j}=t_{i,j}+p_j\,(i\ne j)$。这是初始状态。因为 $t_{i,j}$ 是从 $i$ 起飞到 $j$ 降落所需的时间，想要再次起飞，必须经过维修。因此最短时间肯定是落地之后马上维修，维修完马上起飞，这样几个动作之间的衔接不花费时间，只需要加上维修的时间就好。

然后就可以 `Floyd` 处理任意从两机场出发之间的最短时间。但是这样加了一个维修的时间，难免让人感到怪异。其实是可以的。

比如 $f_{i,j}=f_{i,k}+f_{k,j}\,(i\ne j\ne k)$。其中 $f_{i,k}$ 表示飞机从 $i$ 起飞到 $k$ 降落，然后在 $k$ 维修；$f_{k,j}$ 表示飞机从 $k$ 起飞到 $j$ 降落，然后在 $j$ 维修。这样一来，$f_{i,j}$ 描述的就是飞机从 $i$ 起飞到 $k$ 降落，在 $k$ 维修好后从 $k$ 起飞到 $j$ 降落，再在 $j$ 维修好后立马起飞。显然是符合题目要求的飞行流程的。

对于两个航班 $a$ 和 $b$，用 $u$ 表示起飞机场，$v$ 表示降落机场，$w$ 表示起飞时间。则必须满足 $a_w+t_{a_u,a_v}+p_{a_v}+f_{a_v,b_u}\le b_w$ 时，两个航班之间可以连 $a\rightarrow b$ 的边（从 $a$ 航班出发开始飞，到达 $b$ 航班结束）。 上面的式子的意思是：从 $a_u$ 起飞到 $a_v$ 降落然后维修，再从 $a_v$ 起飞到 $b_u$ 降落然后维修（维修的时间在 $f$ 里都算了），最终得到最早的可以起飞的时间。即，飞机能否在航班 $b$ 起飞之前到达 $b_u$ 并做好维修工作。

由于只可能是起飞早的航班向起飞晚的航班建边，所以我们构成了一个 `DAG`，至此转化成 `DAG` 最小不相交路径覆盖的模型（不相交是因为一个航班不能由多架飞机去飞，航班飞完了就没有这个航班了，不能让飞机在机场为了一个完成的航班空等）。

对于 `DAG` 最小不相交路径覆盖问题，我们将 `DAG` 中的每个节点 $u$ 拆成 $u_1$ 和 $u_2$，表示出发和到达 $u$。对于 `DAG` 中所有的边 $u\rightarrow v$ 在模型中连 $u_1\rightarrow v_2$，表示一条路径从 $u$ 出发就一定可以到达 $v$，从而覆盖 $u,v$ 两个节点；即一架飞机飞完 $u$ 航班一定可以飞 $v$ 航班，从而执行完两个航班任务。

此时，我们已经将问题完全转化成了模型，直接用公式计算：

`DAG` 最小不相交路径覆盖 = 原图节点数 - 拆点图最大匹配。

为什么呢？因为是不相交的路径，所以一个入点只能与一个出点匹配，转化成二分图匹配问题。又因为增加一条匹配 $(u_1,v_2)$，就可以将以 $u$ 为结尾的路径和以 $v$ 为开头的两条路径连成一条路径，从而使答案减一。因此任意一个路径覆盖数都可以用“原图点数 - 任意拆点图匹配数”来表示。由于要使路径覆盖数最小，所以减去的要尽量大（因为原图点数是定值），因此减去的匹配数要最大，即减去最大匹配。

我们将源点 $S$ 向所有 $u_1$ 连容量为 $1$ 的边，将所有 $u_2$ 向汇点连容量为 $1$ 的边，将拆点图中的所有 $u_1\rightarrow v_2$ 的边的容量设为 $1$。这样跑出的最大流即为最大匹配。因为在网络图中每一条流都相当于一条匹配：匹配问题中，同一个点只能根一个点匹配对答案产生贡献；然而最大流中，若同一个点（表示到达的节点）有其它多个节点流入的流量，由于自己到汇点 $T$ 的边容量为 $1$，所以也只会将一个点流入的流量流到汇点，产生贡献。因此最大流也是“同一个点只能根一个点对答案产生贡献”，等价于最大匹配。

于是我们用最大流求出最大匹配后，用原图点数（航班数）减去最大匹配，就是最小不相交路径覆盖——覆盖所有节点的最小不相交路径数，即为飞完所有航班的最少飞机数，为题所求，输出即可。

代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int N = 1005, M = 6e5;
int n, m, p[N], t[N][N], f[N][N], cnt = 1, q[M], l, r, d[N], hd[N], T, ans, now[N];
struct flight {
	int u, v, w;
}a[N];
struct edge {
	int v, w, nxt;
}e[M];
inline void add(int u, int v, int w) {
	e[++cnt] = edge{v, w, hd[u]};
	hd[u] = cnt;
}
inline bool bfs() {
	for (int i = 0; i <= T; ++i) {
		now[i] = hd[i];
		d[i] = 0;
	}
	d[q[l = r = 1] = 0] = 1;
	while (l <= r) {
		int x = q[l++];
		for (int i = hd[x]; i; i = e[i].nxt) {
			if (e[i].w && !d[e[i].v]) {
				d[q[++r] = e[i].v] = d[x] + 1;
				if (e[i].v == T) {
					return 1;
				}
			}
		}
	}
	return 0;
}
int dfs(int x, int flow) {
	if (x == T) {
		return flow;
	}
	int s = 0;
	for (int i = now[x]; i; i = e[i].nxt) {
		if (e[i].w && d[e[i].v] == d[x] + 1) {
			int k = dfs(e[i].v, min(flow - s, e[i].w));
			e[i].w -= k;
			e[i ^ 1].w += k;
			s += k;
			if (s == flow) {
				now[x] = i;
				return s;
			}
		}
	}
	d[x] = now[x] = 0;
	return s;
}
signed main(/*芦语晨我喜欢你*/) {
	scanf("%lld%lld", &n, &m);
	T = (m << 1) + 1;
	for (int i = 1; i <= n; ++i) {
		scanf("%lld", p + i);
	}
	for (int i = 1; i <= n; ++i) {
		for (int j = 1; j <= n; ++j) {
			scanf("%lld", t[i] + j);
			if (i ^ j) {
				f[i][j] = p[j] + t[i][j];
			} else {
				f[i][j] = 0;
			}
		}
	}
	for (int i = 1; i <= m; ++i) {
		scanf("%lld%lld%lld", &a[i].u, &a[i].v, &a[i].w);
		add(0, i, 1);
		add(i, 0, 0);
		add(i + m, T, 1);
		add(T, i + m, 0);
	}
	for (int i = 1; i <= n; ++i) {
		for (int j = 1; j <= n; ++j) {
			for (int k = 1; k <= n; ++k) {
				f[j][k] = min(f[j][k], f[j][i] + f[i][k]);
			}
		}
	}
	for (int i = 1; i <= m; ++i) {
		for (int j = 1; j <= m; ++j) {
			if (i ^ j && a[i].w + t[a[i].u][a[i].v] + p[a[i].v] + f[a[i].v][a[j].u] <= a[j].w) {//满足这个条件的就是原图中的一条边，对其拆点建模即可
				add(i, j + m, 1);
				add(j + m, i, 0);
			}
		}
	}
	while (bfs()) {
		ans += dfs(0, 1e18);
	}
	printf("%lld\n", m - ans);
} 
```
