# AT4547 题解
## Upd 9.19.2021:修改了一个表述问题
可能是楼上的巨佬认为斜率优化太简单了，就讲的非常简略，那作为一个刚学斜率优化的新手，我就来略微详细一点的讲讲斜率优化是如何优化动态规划的转移的。

看到题面，我们首先可以显然的推出一个DP式：

记 $dp_i$ 为跳到第 $i$ 个位置的最小花费，则我们有：

$dp_i=min(dp_j+(h_j-h_i)^2+c) ,0<j<i$.

我们注意到，将式子中的 $(h_j-h_i)^2$ 可以拆开为：

$(h_j-h_i)^2 = h_j^2 - 2 \times h_j \times h_i + h_i^2$.

而原转移式中的 $h_i^2+c$ 与 $j$ 的取值并无关联, 故我们可以将它们从 $min$ 式中提出来：

$dp_i=min(dp_j+h_j^2-2 \times h_j \times h_i)+h_i^2+c$.

我们发现， $h_i^2+c$ 与 $h_j^2$ 两项都很好处理，但就是中间的 $2 \times h_j \times h_i$ 这个与 $i$ 和 $j$ 都有关联的项很不好处理。

我们假设转移式中，使得 $dp_i$ 最小的一个 $j$ 值为 $k$ ,那么我们此时就可以把 $min$ 给去掉，即：

$dp_i=dp_k+h_k^2-2 \times h_k \times h_i+h_i^2+c$

对式子变一个形，就有：

$dp_k+h_k^2=(2 \times h_i) \times h_k+dp_i-h_i^2-c$.

发现这个很像什么？是不是很像一个 $dp_k+h_k^2$ 关于 $h_k$ 的一次函数？

那么这时候我们就用一个二维坐标系来显式地表示这个状态转移方程：

将 $(x=h_k,y=dp_k+h_k^2)$ 这个二元组抽象成在二维坐标系上的一个点，而

$dp_k+h_k^2=(2 \times h_i) \times h_k+dp_i-h_i^2-c$

就是一个形如 $y=kx+b$ 的一次函数，其中：

$k=2 \times h_i$ ,

$b=2 \times dp_i-h_i^2-c$ .

我们再观察一下函数的特征，就可发现，函数的截距，即 $b$ 竟然只与我们需要最小化的 $dp_i$ 和一些常数有关！

那么，此时问题就转化为了一个线性规划问题：

有一条斜率固定，最初位置对应截距为 $-inf$ 的直线，将直线慢慢上挪，直到直线第一次碰到某一个点，求出此时直线的截距。

更形式化的说，就是给定了直线的斜率，要求从已有的 $n$ 个点中找出一个点使直线经过该点，并要求这样确定的直线是所有 $n$ 种不同的可能直线中，截距最小的一条，并求出该直线的截距。

这个又怎么做呢？我们可以想到，如果 $n$ 个点形成了一个下凸壳，

即对于任意 $i$ ，都有

$((y_i-y_{i-1})/(x_i-x_{i-1})>(y_i-y_{i+1})/(x_i-x_{i+1}))$ ，

那么此时我们就只需要找到当前凸壳中的某个点，是该点与其左边点斜率比 $k$ 小，右边的比 $k$ 大，那么这个点就是答案直线所对应的点了。

当然，若是有一个点与其相邻的点间没有形成凸壳，即若有 $i$ 不满足上述对于斜率的要求，那么这个点不可能作为最优点被选择，因为无论在什么情况下，其两个相邻点中必有一个比它更优。

所以，我们要实现一个快速维护支持插入，弹出的下凸壳的数据结构，这里我们使用单次均摊复杂度 $O(1)$ 的单调队列来维护凸壳，故时间复杂度是 $O(N)$ 的。

**code：**

```
const int N(2e5+10);

int n,c;

int h[N];
int q[N];
int dp[N];

inline double X(int i){return h[i];}
inline double Y(int i){return (dp[i]+(h[i]*h[i]));}
inline double K(int i,int j){return ((Y(j)-Y(i))/(X(j)-X(i)));}

signed main(){
	n=read(),c=read();
	rep(i,1,n)h[i]=read();
	int head=1,tail=1;
	q[1]=1+(dp[1]=0);
	rep(i,2,n){
		while(head<tail&&(h[i]<<1)>=K(q[head],q[head+1]))++head;
		dp[i]=dp[q[head]]+(h[q[head]]-h[i])*(h[q[head]]-h[i])+c;
		while(head<tail&&K(i,q[tail])<=K(q[tail],q[tail-1]))--tail;
		q[++tail]=i;
	} cout<<dp[n];
	return 0;
}

```