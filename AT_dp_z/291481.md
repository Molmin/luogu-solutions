[题面](https://www.luogu.com.cn/problem/AT4547)

### 题意

从 $i$ 号石头跳到 $j$ 号石头的费用为 $(h_i - h_j)^2 + C$，求从 $1$ 号跳到 $N$ 号的最小费用。

### 思路

设 $F_i$ 表示跳到 $i$ 号石头所需最小花费，则根据题意，可列 $O(N^2)$ 的转移方程：

$F_i= \min(F_j + ( h_i - h_j )^2 + C ) ,1 \leq j < i$.

化简方程，得：

$F_i= \min( F_j +  {h_i}^2 - 2h_ih_j + {h_j}^2 + C ) ,1 \leq j < i$.

于是 $F_i$ 即为在所有合法范围内的 $F_j +  {h_i}^2 - 2h_ih_j + {h_j}^2 + C$ 中最小的值，当此式取得最小值时，$\min$ 可以去掉，于是原式化为：

$F_i= F_j +  {h_i}^2 - 2h_ih_j + {h_j}^2 + C $.

对于每一个 $i$，我们都需要找到相应的令右侧取得最小值的 $j$，而当 $i$ 固定时，原转移方程中所有与 $i$ 相关的量是不变的，可以看作常量；而与 $j$ 相关的量在变化，可以看作变量。因此，可以将方程中与 $i$ 相关的量移到一侧：

$F_j + {h_j}^2 =  2 h_i h_j + F_i - {h_i}^2 - C$.

等号左侧只有变量，$2 h_i h_j$ 项是常量与变量相乘，而等号右侧其余部分都是常量。

此时，可以令 $y = F_j + {h_j}^2$，$k = 2h_i$，$x = h_j$，$b = F_i - {h_i}^2 - C$。于是原方程可以被表示为 $y = kx + b$ 的一次函数直线形式。

我们成功把朴素的转移方程化成了“斜率式”。

因为我们要求的 $F_i$ 在斜率式的 $b$ 一项中，而又希望 $F_i$ 尽可能大，所以我们所取的斜率式的截距也要尽可能大。

此时的每一个 $j$，都可以在平面上表示为坐标 $(h_j,F_j + {h_j}^2)$ 的一个点。而对于每一个 $i$，其在斜率式中对应的斜率 $2h_i$ 是固定不变的。当某个 $i$ 对应斜率的直线正好经过了某个 $j$ 对应的点时，可以根据斜率方程求出此时对应的截距 $b$，进而根据 $i$ 求出此时所得的 $F_i$ 值，即使用斜率式完成了一次动规的状态转移。

但仅仅这样还不够。我们观察到斜率式中的 $k,x$ 两项都具有单调性。即 $i$ 所对应的直线斜率随 $i$ 递增；$j$ 所对应点的横坐标也随 $j$ 递增。由此我们可知为使截距最小，符合条件的点一定在所有 $j$ 对应点的下凸包上。

因此我们可以根据斜率维护一个下凸包。下凸包的性质是点的斜率单调递增，由此想到可用单调队列维护。当队首斜率小于当前斜率时弹出队首，当新点插入时弹出队尾维护单调性。然后转移 $F_i$，取队首元素，用斜率式计算新的 $F_i$ 完成转移。

这样我们就用**斜率优化**将转移的总复杂度降为了 $O(N)$。

### 代码

```cpp
#include <cstdio>
const int Nx=200010;
int N;
long long C,H[Nx],F[Nx],K[Nx],Y[Nx];
int que[Nx],L,R;
double slope(int a,int b)
{
	double xx,yy;
	yy=Y[b]-Y[a];
	xx=H[b]-H[a];
	return yy/xx;
}
int main()
{
	scanf("%d%lld",&N,&C);
	int i,j,k;
	for(i=1;i<=N;i++)
	{
		scanf("%lld",&H[i]);
		K[i]=2*H[i];
	}
	F[1]=0;Y[1]=H[1]*H[1];
	que[1]=1;
	L=1;R=1;
	for(i=2;i<=N;i++)
	{
		while(L<R&&slope(que[L],que[L+1])<K[i]*1.0)
			L++;
		j=que[L];
		F[i]=Y[j]-K[i]*H[j]+H[i]*H[i]+C;
		Y[i]=F[i]+H[i]*H[i];
		while(L<R&&slope(que[R-1],que[R])>slope(que[R],i))
			R--;
		que[++R]=i;
	}
	printf("%lld\n",F[N]);
}
```
