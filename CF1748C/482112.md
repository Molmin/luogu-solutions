[更好的阅读体验？](https://kouhu-automaton.blog.luogu.org/solution-cf1748c-feh)

[题目链接](https://codeforces.com/problemset/problem/1748/C)

有趣的题。

首先去考虑一个很套路的东西：用 $0$ 对数列分段，然后每一段再单独思考。这里的原因很简单：因为每一次 $0$ 的出现都重新刷新了前缀数组。

也许你还是不懂，那你可以往下看：

每一段应该怎么搞？显然的是，如果这个 $0$ 后面一段的前缀数组里面出现了 $10$ 次 $-2$，$8$ 次 $2$，$3$ 次 $114514$，那么你会把 $0$ 改成 $2$，这一定是最优的吧？显然的，我们要使得后面一段里，前缀数组最多出现的数全部变成 $0$，这就一定是最优的！

这也验证了，为什么我们以 $0$ 分段：因为 $0$ 可以改变后面一段的值，在更后面的（即下一个 $0$ 后面的）值就不归这个 $0$ 管了。

那么我们用 $\tt map$ 不难写出下面一段代码。

```cpp
int res = 0, maxn = -1e9;
map<int, int> mp;
for(int i = n; i; --i) {
	mp[s[i]]++;
	maxn = max(maxn, mp[s[i]]);
	if(!a[i]) {//判断 0
		res += maxn;
		maxn = 0;
		mp.clear();
	}
}
```

这里 $s$ 是前缀数组。

别忘了答案加上本来就有的 $mp[0]$。

于是综上，我们可以得到单组测试数据复杂度是 $\mathcal O(n\log n)$。

还有，如果你在打 $\tt CF$ 能用 $\tt map$ 就用 $\tt map$，用一些复杂度不稳定或者你不熟练的东西，很容易 $\tt FST$ 或者吃罚时。