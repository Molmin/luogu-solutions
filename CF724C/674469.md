## 解题思路

首先，我们单独看 $x$ 坐标，当光线没有碰到右边的墙时，不管 $y$ 如何变化，$x$ 总是每次加 $1$；当光线碰到右边的墙反射回来后，$x$ 坐标会依次减 $1$，直到再次碰到左边的墙，反射后就又开始了一次先加后减的坐标变化。

$y$ 坐标同理，只不过是先碰到上边的墙，然后再反射到下边的墙，它也有先依次加 $1$，然后依次减 $1$ 的规律。

我们发现，对于 $x$ 坐标，变化周期是 $2n$ 次一个，每个周期的每个坐标依次都是 $0,1,2,...,n,n-1,n-2,...,1$，我们把它们存到 $a$ 数组里（下标从 $0$ 开始）。

对于 $y$ 坐标，变化周期是 $2m$ 次一个，每个周期的每个坐标依次都是 $0,1,2,...,m,m-1,m-2,...,1$，同样地，把它们存到 $b$ 数组里（下标从 $0$ 开始）。

这样，题目的初始化就完成了，思路也基本上捋清楚了，接下来就是进行公式推导，进一步求解这道题。

## 公式推导

因为题目告诉了我们一个坐标 $x,y$（即各个传感器），询问这个坐标会不会被光线经过，需要求出一个经过的最小时间，所以我们设这个最小时间为 $t$，则
$$
a_{t \bmod 2n}=x,b_{t \bmod 2m}=y
$$
因为我们知道在 $a$ 和 $b$ 数组中哪些数是等于 $x,y$ 的，设这些数的下标为 $x_1,y_1$，所以此方程就可以变为：
$$
x_1 \equiv t\pmod {2n},y_1 \equiv t\pmod {2m}
$$

我们就可以用解一个 **同余方程组** 的方法来解这两个方程。

但是，单单这样解，我们需要用到 **扩展中国剩余定理**，为了确保用到的知识点足够简单，那么我们可以从另一个角度来思考，把这个方程组拆成两个方程，先看第一个方程：
$$
x_1 \equiv t\pmod {2n}
$$
容易得知这个方程的一个解就是 $t=x_1$，那么我们表示第一个方程的通解就为：$x_1+2pn(p \in \mathbb{Z})$，接下来看第二个方程：
$$
y_1 \equiv t\pmod {2m}
$$
把第一个方程的通解代入第二个方程，就为：
$$
x_1+2pn\equiv y_1 \pmod {2m}
$$
其中 $p$ 未知，可以根据同余的相关定义再次转化方程：
$$
2pn+2qm=y_1-x_1
$$
其中，$p,q$ 是未知数，那么方程变成了一个 $ax+by=c$ 的模式，我们这时就可以只用 **扩展欧几里得** 来求解，但是在 $a,b$ 数组中，同一个 $x,y$ 可能对应不同的下标 $x_1,y_1$，我们就要对这些下标进行枚举，然后取所有枚举出来的答案的最小值。

## 时间复杂度：

为了表述方便，此处默认为 $n,m$ 同阶。单次扩展欧几里得算法的时间复杂度是 $O(\log n)$ 的，因为 $k$ 个传感器需要 $k$ 次枚举求值，所以时间复杂度一共是 $O(k\log n)$。

## 代码

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
ll n,m,k,x,y,l[100005][2],i,j,cnt,ans,r[100005][2];
//扩展欧几里得模板
ll exgcd(ll a,ll b,ll &x,ll &y){
	if(b==0){
		x=1,y=0;
		return a;
	}
	ll temp = exgcd(b,a%b,x,y);
	ll z = x;
	x = y,y = z-y*(a/b);
	return temp;
}
//按照上面的公式进行传参，推导，求值
ll solve(ll a,ll b,ll c,ll d){
	ll a1 = c,b1 = d,c1 = b-a,x,y;
	ll d1 = exgcd(a1,b1,x,y);
	if(c1%d1!=0) return -1;
	ll x0 = a+c*(x*(c1/d1)),y0 = c/__gcd(c,d)*d;
	return (x0%y0+y0)%y0;      //通过取模取最小值
}
int main(){
	ios::sync_with_stdio(false);
	cin>>n>>m>>k;     
	//此处是分别记录每个x,y值有多少对应的下标
	for(i=0;i<=n;i++){
		if(i==0) l[i][0]=l[i][1]=0;
		else if(i==n) l[i][0]=l[i][1]=n;
		else l[i][0] = i,l[i][1] = 2*n-i;
	}
	for(i=0;i<=m;i++){
		if(i==0) r[i][0]=r[i][1]=0;
		else if(i==m) r[i][0]=r[i][1]=m;
		else r[i][0] = i,r[i][1] = 2*m-i;
	}
	//此处是枚举答案，取最小，然后输出
	while(k--){
		ans=LLONG_MAX;     //先赋一个很大的值
		cin>>x>>y;
		for(i=0;i<2;i++){
			for(j=0;j<2;j++){
				cnt=solve(l[x][i],r[y][j],2*n,2*m);     //枚举，配对，取最小
				if(cnt!=-1) ans=min(ans,cnt);
			}
		}
		if(ans==LLONG_MAX) cout<<"-1\n";    //无解
		else cout<<ans<<endl;               //有解
	}
}
```