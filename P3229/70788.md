# 一道欺负我智商的题。。。
~~本来想打单调队列优化dp的，结果看到算法标签就点了此题~~

首先你要理解题意，蒟蒻理解了好久。它就是说，给你一个由1和-1组成的数列，让你分成m段，并让这m段区间和最大值最小，还要求多种方案时字典序最小。

我也不知道大佬怎么做的，反正我不会高斯消元。。。

哦，对了，如果输入的是0，表示他不喜欢则那一位为-1。

设总和为S。区间和最小值为ans。后缀和为sum[]，后缀中0的个数为cnt[]。

为什么是后缀，往后看。。。

首先考虑特殊情况：

- 全是1 显然答案为ans=ceil(S/m);ceil()是向上取整。

- 全是-1 ans=ceil(abs(S)/m)

- 一半全1，一半全-1 比如11111-1-1-1可以变成11(111-1-1-1),括号里为0，可以与任意区间搭配，于是变成了上面的情况。

所以ans=ceil(abs(S)/m)，简易证明：你可以用第三中方法狂消1和-1直到只有一种数，剩下来的数的个数是abs(S)。

如果abs(S)=0且能分的区间不足m那就另当别论。。。

~~由于我太菜了，还有情况没考虑就多多包含~~

先预处理sum[]，ans，cnt[];

- S=0
  
   - cnt[1]>=m,此时找sum[i]=0的点i，用单调队列维护找出字典序最小的一条即可。
   - cnt[1]<m,ans>0,和下面一起处理。
   
- S!=0 sum的每一种取值分开考虑。

  设上一个选的为last，则这一个i能选要满足abs(sum[last+1]-sum[i+1])<=ans,那么我们枚举sum[i+1]的取值时就可以直接从sum[last+1]-ans到sum[last+1]+ans。
  并且abs(sum[i+1]/m'(即剩下要选的数量))要满足小于等于ans，i还有后面的数不能超过m'个。
  然后跑单调队列就完啦，不要告诉我你切黑题还不会这个。。。

实现起来还有不少细节，比如负数下标之类的，仔细看下应该都能懂

代码在我丑陋的[blog](http://www.cnblogs.com/cx233666/p/8708482.html)里。

