## 题解 P1385【密令】

### DP 分析

发现数列的总和不变，于是问题变为了有多少种长度为 $n$ 的序列，使得总和为 $sum$，并且每个数都是 $0$ 到 $25$ 之间的数（可以证明，只要总和均为 $sum$，一定可以构造出方法从原序列变为新序列）。

这很明显是一个动态规划问题。

设 $f(k,x)$ 为前 $k$ 个数总和为 $x$ 的方案数。
$$
f(k,x) = \sum_{0 \le i \le 25,x\ge i}f(k-1,x- i )
$$
什么意思呢？考虑要放第 $k$ 个数使得总和为 $x$ 时，每一个在 $[0,25]$ 的 $i$（当然也需要满足 $x \ge i$），都尝试把它放进序列，这时就需要从 $f(k-1,x-i)$ 转移过来。答案即为所有满足条件的 $f(k-1,x-i)$ 之和。

----

### 细节问题

这个 dp 的边界值是多少？

如果数列总和为 $0$，那么只有一种，就是全 $0$。所以对于所有的 $i$，$f(i,0) = 1$。 

如果数列中只有一个数，并且数列的总和在 $[0,25]$ 之间，那么也只有一种方式。

----

### 实现方式

由于是多组测试数据，可以先预处理好答案，询问的时候直接输出即可。因为 $\left|s\right|\le100$，所以字典序总和最多为 $2600$。

输入的时候完全不用考虑这个字符串是什么，只需要知道长度和总和即可。注意，输出的时候需要减一，删去原来的那个字符串，因为原题问的是变成不同的字符串的个数。

输入可以使用 `getchar`，类似快读的方式处理，如下。

```cpp
inline void readString() {
	char ch = getchar();
	count = 0, sum = 0;
	while (ch < 'a' || ch > 'z') ch = getchar();
	while (ch >= 'a' && ch <= 'z') ++count, sum += (int)ch - 'a', ch = getchar();
}
```

其余部分实现：

```cpp
signed main() {
	scanf("%lld", &T);
	for (int i = 0; i < 26; ++i) dp[1][i] = 1;
	for (int k = 2; k <= 100; ++k) {
		dp[k][0] = 1;
		for (int x = 1; x <= 2600; ++x)
			for (int i = 0; i < 26; ++i)
				if (x >= i)
					dp[k][x] = (dp[k][x] + dp[k - 1][x - i]) % MOD;
	}
	while (T--) {
		readString();
		printf("%lld\n", dp[count][sum] - 1);
	}
	return 0;
}
```

