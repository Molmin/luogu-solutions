### 前言

[弱化版](https://www.luogu.com.cn/problem/P6560)

教练讲的题，据说是很好的码力题和博弈论题，于是就来写一下题解加深印象。

前置知识：

- `bfs`
- 拓扑排序
- 博弈论

------------

## Solution

博弈论正常思路：定义动态规划数组表示这个点能否完成某个目标。

于是来套一下定义：定义 $f_{a,b,c,d,e,f}$ 表示黑子在 $(a,b)$ 处，第一个红子在 $(c,d)$ 处，第二个红子在 $(e,f)$ 时的状态。看空间限制：$n,m \leq 10$，不会超空间。但是这里有一个小细节，可以优化我们枚举的状态数，我们发现 $f_{1,2,3,4,5,6}$ 和 $f_{1,2,5,6,3,4}$ 其实是同一种状态，于是我们减少枚举数量，强行让第一个红子的坐标在第二个红子的上方，这样就会减少状态冗余。

我们再定义一个 `pair` 类型的 $wp$ 数组，$wp.x=1$ 代表在 $i$ 状态下黑子为必胜态，$wp.x=0$ 代表在 $i$ 状态下红子为必胜态，最后定义 $wp.x=+\infty$ 代表 $i$ 这个状态还没被遍历过。$wp.y$ 则代表到达 $i$ 这个状态需要的步数。于是我们的答案就可以知道，定义 $ans$ 为目标状态，当 $wp_{ans}$ 的第一关键字为 $+\infty$ 时，说明是平局。当 $wp_{ans}$ 的第一关键字为 $1$ 时，说明黑子胜。否则红子胜。

定义完成后，我们便开始 bfs，找到递推起点（黑子必胜的点），有三种情况：要么到达了底线，要么吃掉了红子，要么红子无路可走。然后求出每一个状态被哪一个状态更新，这里建立反向边，保存下来备用。

接下来进行拓扑排序和博弈论的部分，假如我们取出来的点为 $u$，并且 $u$ 是必胜态，设 $u$ 能到达 $v$，说明 $v$ 一定为必败态。

证明：因为我们建立的是反向边，所以其实是 $v$ 去更新 $u$，只有 $v$ 为必败态时，$u$ 才是必胜，所以当 $u$ 必胜时，$v$ 必败。

注意，当 $v$ 为 $+\infty$ 时，我们需要把 $v$ 定义为必胜态。

具体细节参考代码。

 [Code](https://www.luogu.com.cn/paste/pln30uv1)


