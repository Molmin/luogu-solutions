## 分析

这一题完全就是一道水模拟，按照题目要求一个数一个数地找一直到找不到为止。

（其实我一开始是把这道题当成二分来写的，结果发现这道题没办法二分……）

这里有一些地方需要注意：

1. 需要注意一位数和两位数的判断时的区别；

2. 通过数组来记录，只要是个答案就更新数组，保证所有答案都被数组记录过；

3. 最后输出的时候是在找第一个没有被存储的数，而题目要求我们输出能拼的数，所以我们的输出应该是输出它前一个数。

于是，这个非常非常水的模拟题目就被我们完美解决了！

AC 代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
int n,block[4][7];
bool record[101];//记录所有能拼的数 
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=6;j++){
			cin>>block[i][j];
		}
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=6;j++){//第一个方块的面 
			record[block[i][j]]=true;//1位数也要记录 
			for(int k=1;k<=n;k++){
				if(k==i)continue;//同一个方块不能拼数 
				for(int m=1;m<=6;m++){//第二个方块的面 
					record[block[i][j]*10+block[k][m]]=true;//前面的是十位后面的是个位
					//不用管会不会重复，因为反正能的话就记录，能拼几次和答案没关系 
				}
			}
		}
	}
	for(int i=1;i<=100;i++){
		if(!record[i]){//不能拼就输出 
			cout<<i-1;//记得是输出能拼的数，现在找的是第一个不能拼的 
			return 0;
		}
	}
	return 0;
}

```
