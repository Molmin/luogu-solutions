> [CF1684G Euclid Guess](https://www.luogu.com.cn/problem/CF1684G) *2800

还算有点意思的网络流题。

首先，为使得余数为 $t$，则除数 $b$ 必然 $> t$，不妨令 $b = t + 1$。因为 $a > b$，所以 $a$ 最小为 $2t + 1$。因此首先判掉若存在 $2t + 1 > m$ 则无解。

考虑接下来的过程。若 $1\leq k < t$，则 $(2t + k, t + k) \to (t + k, t) \to (t, k)$，这意味着如果要搞出一个 $t$，我们还需要一些比较小的数作为垫背。

但是当 $k = t$ 时，整个过程 $(3t, 2t)$ 只会形成一个数 $t$，很棒，唯一的问题是需要满足 $3t \leq m$。

这样一来我们就有了大致思路。找到所有 $3t > m$ 的 **大** $t$，我们需要一个 $(2t + k, t + k)$ 来消灭掉这个 $t$，并且还需要 $k$ 以及 $(t, k)$ 后续形成的数作为垫背。如果存在方案使得每个数够用，那么剩下来所有 $3t\leq m$ 的 **小** $t$ 可以每次用一个 $(3t, 2t)$ 消灭掉。

问题转化为怎么消灭掉较大的 $t$。如果直接尝试枚举其对应的 $k$ 等于某个小 $t$，由于一次操作会涉及多个小 $t$，我们没有办法解决这种情况。

考察欧几里得算法本身，我们发现对于一开始的 $(a, b)$ 而言，$\gcd(a, b)$ 一定会出现在序列当中。这就好办了啊！如果 $k$ 不是 $t$ 的约数，那么令 $k\gets \gcd(k, t)$ 显然一定更优，因为后者涉及到的数完全包含于前者。更劲爆的是，后者只会涉及到 $k$ 本身一个数。

综上，枚举大 $t_i$ 和小 $t_j$，若 $t_j \mid t_i$ 且 $2t_i + t_j \leq m$，则 $i\to j$ 连边。跑一个二分图最大匹配（大 $t$ 之间由于 $3t > m$ 所以内部不会连边，是二分图）。如果所有左部点均被匹配掉则有解，将匹配对应的方案输出，并将剩下来的小 $t$ 通过 $(3t, 2t)$ 消灭掉。否则无解。

[代码](https://codeforces.com/contest/1684/submission/157754086)。