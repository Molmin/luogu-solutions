### 题意简述
有 $n$ 张牌，每张牌有红色和蓝色两面，每一面有一个数字。      
最初，所有卡片的红色面朝上放置。爱丽丝和鲍勃玩一个游戏，他们重复下面的步骤：    
首先，爱丽丝从剩下的一张牌中选择一张，并将其翻转过来。接下来，鲍勃在剩下的所有牌中拿走一张牌。然后，鲍勃得到的分数等于拿走的卡片正面朝上写的数字。      
游戏在没有牌的时候结束。           
爱丽丝试图在游戏结束时最小化鲍勃的得分，而鲍勃试图将其最大化。当两名玩家都采取最佳步骤时，鲍勃在游戏结束后的得分是多少？    

-----

### 思路分析    
一眼博弈论。           
~~不知是谁口口声称这是个数学题，我不说他是不是在我样例还没分析完就有了思路。~~      
首先通过分析不难看出：每一轮，爱丽丝一定会把一张当前正面数字大于反面数字的牌反过来，而鲍勃一定会选择一张当前正面数字大于反面数字的牌。    
设 $x$ 为正面数字大于反面数字的牌的数量。
1. 如果 $x$ 是偶数，$x/2$ 轮之后，所有留下的牌都是正面数字小于反面数字的了。此时到爱丽丝选择，她只好把其中一张反过来，这一张就变成了正面大于反面，而鲍勃一定会选这张牌拿走。这样下去，可得出鲍勃一定会把所有牌中数字大的那一面上的数字取走。    
1. 如果 $x$ 是奇数，那么到第 $x/2+1$ 轮时，还剩一张正面大于反面的牌，此时爱丽丝会把它反过来，那么鲍勃面对的就会都是正面小于反面的牌。此时，选择正面比反面差距最小的牌（即以背面为参照物，使正面尽量大），是鲍勃的最佳策略。（大家感性理解哈）   

于是有如下策略：
1. 统计初始的时候正面数字大于反面数字的牌的数量。
1. 如果是偶数，那么把所有牌的最大值累加即可；如果是奇数，对于正反两面两个数差距最小的那张牌，计算最小值，否则计算最大值。

下面是喜闻乐见的代码时间：  
（在这里使用了亿点小技巧，即事先统计所有牌的最大值的和，当 $x$，即代码中的 $sum$，是奇数时，把这个和减去正反两面两个数差距最小的那张牌的正反两面两个数的差，就是答案。）
```cpp
#include<stdio.h>
long long n,a[200005],b[200005],sum,all,minn=2000000005;
long long abs(long long num) {return num>0?num:-num;}
long long max(long long a,long long b) {return a>b?a:b;}
long long min(long long a,long long b) {return a<b?a:b;}
int main()
{
    scanf("%lld",&n);
    for(int i=1;i<=n;i++) scanf("%lld%lld",&a[i],&b[i]),sum+=(a[i]>b[i]),
    all+=max(a[i],b[i]),minn=min(minn,abs(a[i]-b[i]));
    if(sum&1) printf("%lld",all-minn);
    else printf("%lld",all);
}
```    

---

### 时间复杂度分析
由只有短短十三行的代码可以看出，这个思路的时间复杂度为 $O(n)$，十分轻松就通过了。    

在这里感谢这位[蓝名大佬](https://www.luogu.com.cn/user/808529)提供的思路，是他给我的思路帮助我一次就过了这道题，没吃罚时。    
完结撒花。