## 题意

有 $n(1\le n\le 2\times 10^5)$ 张卡片，第 $i$ 张的正面写有数字 $a_i$，反面写有数字 $b_i$。Alice 和 Bob 用这些卡片做游戏。一开始所有卡片都是正面朝上，每一轮 Alice 任意翻转一张卡片，Bob 任意取走一张卡片并得到这张卡片朝上一面的分值。卡片全部取走则游戏结束。Alice 想要最小化 Bob 的总分，而 Bob 想要最大化。问若两人都足够聪明，则 Bob 的总分是多少。

## 代码

先放代码吧，应该是最短解且时间复杂度 $O(n)$。结论题，我看赛时很多人没有发现结论稍稍浪费了些码力，都是 $O(n\log n)$ 做法。但这个结论推一下也不算难，如果不会证明，再前往下一部分。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
ll n,a[200005],b[200005],cnt,sum,mini=1e18;
int main(){
    cin>>n;
    for(int i=1;i<=n;i++)cin>>a[i]>>b[i];
    for(int i=1;i<=n;i++)sum+=max(a[i],b[i]);
    for(int i=1;i<=n;i++)cnt+=(a[i]>b[i]);
    for(int i=1;i<=n;i++)mini=min(mini,abs(a[i]-b[i]));
    if(cnt%2)cout<<sum-mini<<endl;
    else cout<<sum<<endl;
    return 0;
}
```

## 思路

大家应该已经看懂了结论。

拿到这道题，首先会有这样对 Bob 的分析，若有朝上面为较大数的卡片，则取走；若没有，则取卡片上两数的绝对值差小的以减小损失。再进一步去考虑，若 Bob 留给 Alice 的是一个朝上面全是较小数的状态，则最后这些卡片 Bob 都能以较大值取走（Bob 留给 Alice 的状态将不再发生变化）。而如果 Bob 留给 Alice 的状态是朝上面为较大数的卡片有大于等于 $2$ 张，那么下一轮 Bob 所得的分值仍能是较大值；而如果 Bob 只剩给 Alice 一张朝上面较大的卡片，那么 Alice 可使得 Bob 当前一轮取不到较大值。

一番分析稍作总结：如果 Bob 尽可能去取较大值，那么他最多只会有一张卡片取到的是较小值（因为一旦出现 Bob 只剩给 Alice 一张朝上面较大的卡片这种状态，那么此后都将是 Bob 留给 Alice 一个朝上面全是较小数的状态）。

你算下样例就可以猜测出 Bob 取到最小数的那张卡片一定是绝对值最小的那一张，下面考虑证明。

首先看什么情况下能够形成 Bob 只剩给 Alice 一张朝上面较大的卡片这种状态。我们发现，如果 Bob 按原始思路走，必定是减少一张朝上面较大的卡片，而 Alice 可任选增加或减少一张，由此可知，朝上面较大的卡片的奇偶性不变。由此可知，当初始朝上面较大数的个数为偶时，Bob 可以以较大值取走所有卡片。

接下来讨论初始朝上面较大数的个数为奇的情况，这样 Bob 一定会有一张取到的是较小数，那根据猜想，我们可以改变 Bob 取卡片的策略。如果绝对值最小的那张卡片朝上面为较小值，则立即取走，将朝上面较大的卡片的个数变为偶数，剩下卡片都能以较大值取走。如果这张卡片朝上的是较大值，那么 Bob 不能动，Alice 也不能动，可以看作这张卡片废了。因为一旦 Alice 翻了这张卡片，Bob 立即拿掉就好了。剩下的卡片朝上面较大的共有偶数张，可以全部较大值拿下。

综上所述：当卡片朝上面较大数的个数为奇时，仅有正反两数差绝对值最小的卡片取得较小值，其余均可取得较大值；当卡片朝上面较大数的个数为偶时，均可取得较大值。

结论有了，代码分分钟搞定！