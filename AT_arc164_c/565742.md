### 本题解为 $O(N)$ 的做法
## 题目大意
有 $N$ 张卡牌，每张卡牌的正反两面分别印着 $A_i,B_i$ 两个数字，初始时派都正面朝上，现在 Alice 和 Bob 按以下规则轮流操作，直到游戏结束：

进行 $N$ 个回合，每个回合中，Alice 先将一张牌翻面，然后 Bob 拿走桌面上的一张牌，并获得其朝上的那一面的数字的分数。

Alice 尽全力最小化 Bob 的分数，Bob 尽全力最大化 Bob 的分数，且他们都绝顶聪明。问最后 Bob 得了多少分。

## 题目分析

由于所有的牌最后都会被取走，我们可以先对每张卡牌的较小的值求和，设其为 $ans$，做为一个基本的分数，然后定义每张卡牌的权值 $W_i$ 为较大值与较小值的差，状态 $F_i$ 为较大值是否朝上，是就是 $1$，否则为 $0$。则 Alice 的操作为选择一个 $i$，使得 $F_i$ 异或 $1$，Bob 的操作的就是选择一个 $i$，如果此时 $F_i$ 等于 $1$，则获得 $W_i$ 的贡献，同时，把卡牌 $i$ 移除。特别地，如果 $W_i=0$，则初步将 $F_i$ 的值视为 $0$。


首先，给出结论：

最终的答案为 $ans+\sum\limits_{1\le i\le n}W_i-\min\limits_{1\le i\le n}W_i$，当且仅当初始时 $\sum\limits_{1\le i\le n}F_i$ 为奇数且不存在 $1\le i\le n,A_i=B_i$，否则，最终的答案为 $ans+\sum\limits_{1\le i\le n}W_i$。

接着，给出证明：

- 结论一：当前的牌的状态全部为 $0$ 时，如果此时 Alice 先手，则答案得到这些牌的权值之和的贡献。

这个结论显然，Alice 翻哪张，Bob 就选哪张，这样每次 Bob 选择时，被选的牌的状态都为 $1$。

- 结论二：当前的牌的状态全部为 $0$ 时，如果此时 Bob 先手，则答案得到这些牌的权值之和减去其中最小的权值的贡献。

这个结论也显然，因为 Bob 选完一个后，就会变成结论一的情况。所以要最大化选完后的牌的权值和，即最小化选择的牌的权值。

- 结论三：Bob 最多只需要选择一次状态为 $0$ 的牌。

如果当前的牌还有状态为 $1$，Bob 就会选择状态为 $1$ 的牌，这绝对比选择状态 $0$ 的更优。否则就进入到结论一和二的情况。

- 结论四：当前的牌中状态为 $1$ 的牌的数量为偶数，且 Alice 先手时，Bob 可以得到所有的卡牌的权值的贡献。

如果 Alice 选择将一个状态为 $0$ 的卡牌翻面，则 Bob 把被翻的卡牌取走，不仅得到对应的贡献，而且局面不变，直到没有状态为 $0$ 卡牌。

如果 Alice 选择将一个状态为 $1$ 的卡牌翻面，则 Bob 从剩下的卡牌中取走一张，得到对应的贡献，状态为 $1$ 的卡牌数减少 $2$，直到没有状态为 $1$ 的卡牌，此时，符合结论一。

- 定义一：定义 Bob 能得到所有卡牌的权值的局面为 Bob 的必胜态。

- 结论五：当前的牌中状态为 $1$ 的卡牌的数量为奇数，且 Alice 先手，且当前的牌中不存在 $W_i=0$ 时，Bob 无法达到必胜态。

无论 Alice 怎么翻，Bob 为了维持必胜态，都得选一张状态为 $1$ 的牌取走，这会使得状态为 $1$ 的卡牌数量一直为奇数，直到剩一张状态为 $1$ 的卡牌时，Alice 将其翻面，符合结论二的局面，无法达到必胜态。

因此，Bob 为了最小化损失，就会让最终的卡牌的中的权值的最小值最小，而还剩 $2$ 张以上牌供他选择时，他总可以不选到所有的权值中最小的那一张。

- 最终结论得证。

若初始的牌中不含有 $W_i=0$ 的牌，则对应结论四和结论五。

如果有 $W_i=0$ 的牌，当处于结论四的状态时，处于必胜态，否则，将当中的一张牌的状态视为 $1$（可以这么做是因为无论状态是什么都不会造成贡献），则成为结论四的局面。

题外话：这题就到这里解决了。但是赛时由于这样研究了特别久，还干不过暴力模拟，等别人 D 题写完，我才想出这个结论，等到想出 D 题就没时间写代码了，这场 ARC 就 G 了（卑微）。

```cpp
#include<bits/stdc++.h>
#define ll long long
#define rep(x,y,z) for(int x=(y);x<=(z);x++)
inline int read(){int s=0,w=1;char c=getchar();while(c<48||c>57) {if(c=='-') w=-1;c=getchar();}while(c>=48&&c<=57) s=(s<<1)+(s<<3)+c-48,c=getchar();return s*w;}
inline void pf(ll x){if(x<0) putchar('-'),x=-x;if(x>9)pf(x/10);putchar(x%10+48);}
const int inf=2147000000;
using namespace std;
int n,x,y,cnt,m=inf;
ll ans;
int main(){
	n=read();
	rep(i,1,n){
		x=read(),y=read(),m=min(m,abs(x-y));
		if(x>y)cnt++;
		ans+=max(x,y);
	}
	if(cnt&1)ans-=m;
	cout <<ans;
	return 0;
}
```

 