# 前言

非常有趣的结论题，当时我连 B 题都没打就来打 C 题导致差点没 A 掉 B（

# 关于这篇题解

作者对于 $ \LaTeX $ 公式的运用还不够熟练，如果本篇题解公式有误或者思路上有问题，欢迎在评论区进行讨论。

# 解题报告

此处的解题报告会对结论以及赛时思考得出结论的思路进行全面分析，希望能够帮助大家在赛时可以使用类似的思路写出类似的思维类题目。

## 思路

我们假设对于每一张卡片，其双面中较大的数字为 $ U_i $，较小的数字为 $ D_i $，设两面数字的差 $ U_i - D_i = Delta_i $，那么容易得到以下结论：

1. 游戏开始时，每一张卡片正面的数字不是 $ U_i $ 就是 $ D_i $，即：每一张卡片的写有数字较大值的一面不是朝上就是朝下 ~~（废话）~~。

2. **无论何时，Bob 取走第 $ i $ 张卡片至少能得到 $ D_i $ 的分数，至多能得到 $ D_i + Delta_i $ 的分数。**

3. 对于任意 $ i $，均有 $ Delta_i \geq 0 $。

注意到以上的结论 2，我们可以把原先的问题转变为等价的问题：我们认为 Bob 原本就有 $ \sum D_i $ 的分数，现在第 $ i $ 张卡片中较大的数字为 $ Delta_i $，较小的数字为 $ 0 $，其余问题不变，我们称新问题为问题 2，以与原问题区分。

为了方便，我们定义一张卡片的分数为 $ Delta_i $，然后，我们定义一张卡片 **非零**，当且仅当其正面的数字为 $ Delta_i $。注意，一张卡片非零是由其正面是否为 $ Delta_i $ 决定而非是否数字为为 $ 0 $ 决定的。

由此，对于问题 2 我们可以得知 Alice 进行的最优思路：轮到 Alice 操作时，Alice 必定会翻转场上正面数字较大且状态为 **非零** 的卡片。

显而易见，如果 Alice 不翻转场上正面数字较大且 **非零** 的卡片， Bob 必定会取走该卡片，因为取走该卡片是对于 Bob 而言最优的思路，取走正面数字为 $ 0 $ 的卡片一定是劣的，当场上有至少两张 **非零** 卡片时，取走正面数字最大的一张卡片一定是更优的。

那么 Bob 的思路也显而易见了，上文有提及，此处不多做赘述。

我们又注意到：Alice 的操作是建立在场上有 **非零** 的卡片的前提上的，那么如果场上所有的卡片正面都为 $ 0 $ 且轮到 Alice 操作，会发生什么呢？

此时，Alice 无论反转哪张卡片都会使得一张卡片从写有 $ 0 $ 的一面翻转至写有 $ Delta_i $ 的一面。此时轮到 Bob 进行操作，显然 Bob 会取走这一张唯一的被翻到 $ Delta_i $ 的一面的卡片。

于是我们又得到一个结论：

- 当场上所有卡片正面都为 $ 0 $ 且轮到 Alice 操作时， Bob 会得到相当于场上所有卡牌的 $ \sum Delta_i $ 的分数。

我们称以上情况为 **状态 A**。

那么，当场上所有的卡片正面都为 $ 0 $ 且轮到 Bob 操作会发生什么情况呢？

我们设此时 Bob 取走了卡片 $ p $ 的情况为 **状态 B**，显然，Bob 无论取哪张卡片 $ p $，都会先损失该张卡牌的分数 $ Delta_p $，然后进入 **状态 A** 并获得其余所有卡牌的分数 $ \sum Delta_i ( i \neq p ) $。

因此，Bob 在该种状态下会取得 $ \sum Delta_i - Delta_p $ 的分数，因为在进入 **状态 B** 时 $ \sum Delta_i $ 已经确定，所以 Bob 会最小化 $ Delta_p $ 来最大化 $ \sum Delta_i ( i \neq p ) $ 的值。

因此，又出现一个结论：

- 当场上所有卡片正面都为 $ 0 $ 且轮到 Bob 操作时， Bob 取走场上分数最小的卡牌 $ p $ 并得到相当于场上所有卡牌的分数总和减去卡牌 $ p $ 的分数，即 $ \sum Delta_i ( i \neq p ) $ 的分数。

在两个结论都确定时，我们尝试考虑在什么情况下经过若干次操作后会进入 **状态 A**，又在什么情况下经过若干次操作后会进入 **状态 B**。

对于问题 2，我们设在初始状态下有 $ cnt $ 张 **非零** 卡片，然后 Alice 和 Bob 都使用最优思路进行行动，容易得知：在两人各行动一次后， **非零** 卡片的数量一定会减少 $ 2 $，直到剩余 **非零** 卡片的数量为 $ 0 $ 或 $ 1 $。

当剩余卡片 **非零** 数量为 $ 0 $ 时，此时轮到 Alice 行动，可以知道此时状态就是 **状态 A** ，又根据先前 Bob 操作的思路，易知 Bob 在 **状态 A** 之前取走的卡牌必定全为 **非零** 卡片，又知道 Bob 在 **状态 A** 同样取卡片时会取剩余的所有 **非零** 卡片，因此有：

- 当 $ cnt $ 为 $ 2 $ 的倍数时，Bob 分数为 $ \sum Delta_i $。

在原问题中，Bob 的分数就是 $ \sum ( Delta_i + D_i ) $ ，即 $ \sum U_i $。

当剩余卡片 **非零** 数量为 $ 1 $ 时，Alice 会将其翻转，然后进入 **状态 B**。此时我们容易证明：分数最小的一张卡片必定没被取走（如果这张卡片初始 **非零**，那么取走前 $ cnt - 1 $ 张 **非零** 卡片必定会剩余该张卡片，然后其又会被Alice翻转，否则，这一张卡片初始为 $ 0 $，更不可能被取走），所以 Bob 分数为 $ \sum Delta_i - \min ( Delta_i ) $。即：

- 当 $ cnt $ 不为 $ 2 $ 的倍数时，Bob 分数为 $ \sum Delta_i - \min ( Delta_i ) $。

在原问题中，Bob 的分数就是 $ \sum ( Delta_i + D_i ) - \min ( Delta_i )  $ ，即 $ \sum U_i - \min ( Delta_i ) $。

求出 $ \min ( Delta_i ) $，问题就解决了。

# 代码

得出结论，代码实现就很简单了。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int Exp10reMAXN=200020; 
long long dist[Exp10reMAXN],MINN=(1ll<<60),tot;
int main()
{
	int n,i;
	long long ta,tb,ccnt=0;
	scanf("%d",&n);
	for(i=1;i<=n;i++)
	{
		scanf("%lld%lld",&ta,&tb);
		if(ta<tb)
		{
			swap(ta,tb);
		}
		else
		{
			ccnt++;
		}
		dist[i]=ta-tb;
		tot+=ta;
		MINN=min(MINN,dist[i]);
	}
	if(ccnt%2==1)
	{
		tot-=MINN;
	}
	printf("%lld",tot);
	return 0;
}
```
