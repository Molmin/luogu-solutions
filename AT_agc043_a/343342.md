## 解题思路
我们申请一个数组 $f[i][j][1/0]$ 记录从第 $(1,1)$ 位置，到 $(i,j)$ 位置，从两个方向来（$"1"$ 是从上边来，$"0"$ 是从左边来）需要的操作次数。$a[i][j]$ 记录位置上有没有井号。由于是三维的，自认为比较好理解。
 下面就到了推理状态转移方程的时候了！
- 一般情况下，第 $(i,j)$ 个位置从上边来的最小操作数就是上边格子 $(i-1,j)$ 的从两个方向来的操作数的最小值加上这个位置是不是井号，第 $(i,j)$ 个位置从左边来的最小操作数就是左边格子 $(i,j-1)$ 的从两个方向来的操作数的最小值加上这个位置是不是井号。
- 如果左边和本身都是井号，如果这么走，就只需一次操作即可，即删除这两个位置上的井号。所以，如果满足这一条件，它的状态就是左边的两方向最小值。
- 如果上边和本身都是井号，与左边同理。

所以，状态转移方程为：

先判断：

$\begin{cases}if:a[i][j] = a[i-1][j] = 1:f[i][j][1] = min(f[i-1][j][1],f[i-1][j][0]);\\if:a[i][j] = a[i][j-1] = 1:f[i][j][0] = min(f[i][j-1][1],f[i][j-1][0]);\end{cases} $

然后判断（其中 "left";"up" 为左边与本身为井号和上边与本身为井号简写）：

$\begin{cases}if :left:f[i][j][1] = min(f[i-1][j][1],f[i-1][j][0])+a[i][j];\\if:up:f[i][j][0] = min(f[i][j-1][1],f[i][j-1][0])+a[i][j];\\otherwise:\begin{cases}f[i][j][1] = min(f[i-1][j][1],f[i-1][j][0])+a[i][j];\\f[i][j][0] = min(f[i][j-1][1],f[i][j-1][0])+a[i][j];\end{cases}\end{cases}$

~~好复杂QAQ~~

虽然后面的括号里除了 $\texttt {otherwise}$ 的那两个判断不写也能AC（我也不知道是数据太水还是可以证明，反正我没证），但是这样更严谨。

注意！前两个判断要同时，绝对不能 $\texttt {else}$!
## code：
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[102][102];
int f[102][102][2];
int n,m;
int main(){
	cin >> n >> m;
	memset(f,0x3f,sizeof f);
	for(int i = 1;i <= n;i ++){
		for(int j = 1;j <= m;j ++){
			char s;
			cin >> s;
			a[i][j] = (s=='#');
		}
	}
	f[1][0][1] = f[1][0][0] = 0;
	f[0][1][1] = f[0][1][0] = 0;
	for(int i = 1;i <= n;i ++){
		for(int j = 1;j <= m;j ++){
			int f1 = 0,f2 = 0;
			if(a[i][j-1] == 1 && a[i][j] == 1){
				f[i][j][0] = min(f[i][j-1][1],f[i][j-1][0]);
				f1 = 1;
			}
			if(a[i-1][j] == 1 && a[i][j] == 1){
				f[i][j][1] = min(f[i-1][j][1],f[i-1][j][0]);
				f2 = 1;
			}
			if(f1 == 0 && f2 == 0){
				f[i][j][0] = min(f[i][j-1][1],f[i][j-1][0])+a[i][j];
				f[i][j][1] = min(f[i-1][j][1],f[i-1][j][0])+a[i][j];
			} 
			if(f1 == 1 && f2 == 0)f[i][j][1] = min(f[i-1][j][1],f[i-1][j][0])+a[i][j];
			if(f1 == 0 && f2 == 1)f[i][j][0] = min(f[i][j-1][1],f[i][j-1][0])+a[i][j];
		}
	}
	cout<<min(f[n][m][0],f[n][m][1])<<endl;
	return 0;
}
```
