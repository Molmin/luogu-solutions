在我的[博客](https://oi-master.github.io/post/atcoder-agc-043-a-ti-jie/)阅读体验更好哦！

这道题把我坑的无话可说，实在是服了这个做法。动态规划！当时没想出来，现在想想，感觉自己理解得差不多了……好了，回归正题，我们先按照老配方——题面先。

## 题面
### 英文题面
请你走 [这里](https://atcoder.jp/contests/agc043/tasks/agc043_a) ，会带你去 Atcoder 官网。

### 中文题面
这道题大意是这样的：

给你一个 $H\times W$ 的迷宫，其中，“.”代表空地，“#”代表墙。现在，让你从左上角的 $(1, 1)$ 走到右下角的 $(H, W)$ ，只能走右边或下面。不过，这与往常的题目不一样，不是问你最少要走多少步，也不是有几种走法。其实，这个迷宫可能不同，现在给你一个条件，就是选择一个矩阵，把这个区域内的所有的空地转成墙，墙转成空地。问你最少要多少个操作才能保证能同行。
## 思路
这道题，我们先看枚举。枚举什么呢？枚举操作次数，然后在嵌套一个枚举在哪里操作？答案是完美的，不会错，但是你不用写了，一定会超时。

然后，我们考虑贪心。如何贪心？这仍然是个问题。好像贪心很难想全，情况较多。那么引用一位学长的话，叫做：

> 贪心不行就 DP 。

好的，~~为了验证这句话的正确性~~，我们就做一下 DP 吧。不过，这道题的 DP 状态转移方程有点难想，显然，状态较多，一不小心套个四重循环就会爆（其实不一定，不过估计评测机不是用现在的高级 CPU，而是像 CCF 统一评测老爷机来评测的，最好不要冒这个险），所以，这个 DP 又是一个难写的 DP 啊，不好想。

卡在这里显然不太合适，我们先看一下要你写的代码吧，从微观开始讲。先提前说一下，这个代码不是本人自己写的，而是一位大佬 hhhyyyfff 写的，在此先膜拜一下。
```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>

using namespace std;

char s[110][110];
int H, W, f[110][110];

int main() {
    scanf("%d%d", &H, &W);
    for (int i = 1; i <= H; ++i) scanf("%s", s[i] + 1);

    f[1][1] = s[1][1] == '#';
    for (int i = 2; i <= W; ++i)
        f[1][i] = f[1][i - 1] + (s[1][i - 1] == '.' && s[1][i] == '#');
    for (int i = 2; i <= H; ++i)
        f[i][1] = f[i - 1][1] + (s[i - 1][1] == '.' && s[i][1] == '#');
    for (int i = 2; i <= H; ++i)
        for (int j = 2; j <= W; ++j)
            f[i][j] = min(f[i - 1][j] + (s[i - 1][j] == '.' && s[i][j] == '#'),
                          f[i][j - 1] + (s[i][j - 1] == '.' && s[i][j] == '#'));
    printf("%d\n", f[H][W]);
    return 0;
}
```
首先，读入没什么难的事情了，主要就是后面的 DP 。

第一行与第一列的初始化大家应该也能看得懂，知道这是什么意思。唯独后面的条件是什么意思还不知道。待会我会解释的，您们放心。

然后，就是主要的 DP 了，发现仍然很简单。当你不看后面那个 `(s[i - 1][j] == '.' && s[i][j] == '#')` 时，你一定会尖叫：

> 这个 DP 太土了！比 [传纸条](https://www.luogu.com.cn/problem/P1006) 还简单呐！

看来，主要的核心就在那一个表达式上面了。表达式的意思是，这个点要不要再翻一次，对不对？这是显而易见的。

首先，如果这个点不是墙，那么小表达式的值一定为 $0$ 。

我们来看看，如果上一步是从上方走下来的，且上方是个墙，那么要不要翻？显然，上边翻的时候，把这一格的墙也同时翻掉了，所以，不用再翻。但是如果上面一格是空地呢？说明没有翻到这个墙，这个墙还要再翻一次。

左边的也是对称的。

嘿，让我们往宏观走走。这个 DP 十分巧妙，在记录最少的翻的次数时，顺便就把翻的标记也延续下来了。十分有意思，也很巧妙。

## 代码
还是刚刚的代码。

还是 stO hhhyyyfff Orz 。
```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>

using namespace std;

char s[110][110];
int H, W, f[110][110];

int main() {
    scanf("%d%d", &H, &W);
    for (int i = 1; i <= H; ++i) scanf("%s", s[i] + 1);

    f[1][1] = s[1][1] == '#';
    for (int i = 2; i <= W; ++i)
        f[1][i] = f[1][i - 1] + (s[1][i - 1] == '.' && s[1][i] == '#');
    for (int i = 2; i <= H; ++i)
        f[i][1] = f[i - 1][1] + (s[i - 1][1] == '.' && s[i][1] == '#');
    for (int i = 2; i <= H; ++i)
        for (int j = 2; j <= W; ++j)
            f[i][j] = min(f[i - 1][j] + (s[i - 1][j] == '.' && s[i][j] == '#'),
                          f[i][j - 1] + (s[i][j - 1] == '.' && s[i][j] == '#'));
    printf("%d\n", f[H][W]);
    return 0;
}
```
本文到此结束。