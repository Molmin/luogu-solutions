## 这题看似是一个贪心，可是仔细一想是一个DP
---
### 过程
因为本题只能向右或向下走，所以设当先的位置坐标为$(i,j)$

**从上到下**

则如果$i-1$为'.'就表示$i-1$可以直接通过,如果$i$为'#'且要从$i-1$走到$i$，就必须变换一次。

**从左到右的同理**

所以我们可以很快地写出**状态转移方程**

设$f_{i,j}$为从$(1,1)$走到$(i,j)$的最小变换次数
1. 如果$(i-1,j)$为'.'且$(i,j)$为'#'：
    $f_{i,j}=f_{i-1,j}+1$
2. 如果$(i,j-1)$为'.'且$(i,j)$为'#'：
    $f_{i,j}=f_{i,j-1}+1$

---
### 当然我们不能忘记初始化

1. 对于起点
    显然，起点肯定是要经过的，所以如果$(1,1)$为'#'，那么$f_{1,1}=1$

2. 对于第一行
    所有向下走的步骤都是建立在第一行的基础上的，都是从第一行走过来的，所以需要初始化。第一行的初始化与本题的状转方程相同
        如果$(i-1,j)$为'.'且$(i,j)$为'#'：$f_{1,j}=f_{1,j-1}+1$
        否则：$f_{1,j}=f_{1,j-1}$

3. 对于第一列
    所有向右走的步骤都是建立在第一行的基础上的，所以第一列也需要初始化。初始化与状转方程相同
    如果$(i-1,j)$为'.'且$(i,j)$为'#'：$f_{i,j}=f_{i-1,j}+1$
    否则：$f_{i,j}=f_{i-1,j}$

---

### 到此所有的步骤都完成了
最后答案为$f_{H,W}$

---
#### 详细步骤参考代码
```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 1005;

int n,m;
char ch[N][N];
int f[N][N];

int main(void){
    cin>>n>>m;
    for (int i=1;i<=n;i++)
        for (int j=1;j<=m;j++)
            cin>>ch[i][j];
    if (ch[1][1]=='#')
        f[1][1]=1;
    for (int i=2;i<=m;i++){
        int now=0;
        if (ch[1][i-1]=='.' && ch[1][i]=='#')
            now=1;
        f[1][i]=f[1][i-1]+now;
    }
    for (int i=2;i<=n;i++){
        int now=0;
        if (ch[i-1][1]=='.' && ch[i][1]=='#')
            now=1;
        f[i][1]=f[i-1][1]+now;
    }
    for (int i=2;i<=n;i++)
        for (int j=2;j<=m;j++){
            int now1=0,now2=0;
            if (ch[i][j-1]=='.' && ch[i][j]=='#')
                now1=1;
            if (ch[i-1][j]=='.' && ch[i][j]=='#')
                now2=1;
            f[i][j]=min(f[i][j-1]+now1,f[i-1][j]+now2);
        }
    printf("%d\n",f[n][m]);

    return 0;
}
```
