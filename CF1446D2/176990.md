一篇复杂度为 $O(n)$ 的题解（含代码）。

首先特判掉有两个全局众数的情况，此时答案为 $n$。

容易发现的是全局的众数一定是答案区间的众数之一，感性理解考虑最优解一定是将全局范围一点一点缩小到有一个数和全局众数的出现次数相同。

那么可以枚举另一个出现次数和全局众数相同的数。设全局众数为 $x$，枚举的这个数为 $y$，那么如果将 $a_i=x$ 的位置设为 $1$， $a_i=y$ 的位置设为 $-1$，其他位置设为 $0$，此时问题就等价于找到一个最长的区间，他的区间和为 $0$。（当然这样可能有不合法的区间，但是由于 $x$ 一定是最优解中的众数所以不合法的区间一定不优，不用考虑）

这个问题有一个很经典的操作就是对于每个 $a_i=y$，将他加入一个数组中，再找到他前面和后面当前的第一个 $a_i=x$，将他也加入这个数组中再从原序列中删掉，然后对这个数组求一下最长的合法子段，求前驱和后继可以用 `set`，但是这样复杂度会多一个 $\log n$，不优秀。

我们观察上面的操作其实就是在找前缀和 $\ge0$ 的位置，那么我们可以维护一个 $cur$ 表示当前的前缀和，然后用链表往后跳最近的 $x$ 或 $y$，如果 $cur=0$ 那么我们就强制跳到下一个 $y$ （不管中间的 $x$）。这样正着做一次再反着做一次，然后归并一下就可以做到 $O(n)$。

具体细节见[代码](https://codeforces.com/contest/1446/submission/162509664)（~~由于我比较懒使用了 `unordered_map` 所以常数不优秀，可以用 `bool` 数组来代替~~）
