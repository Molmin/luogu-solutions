提出一个 $O(n)$ 的解法。

有个简单结论是，最终选出的子段中的众数包含全局众数。证明很简单，也就是如果当前的子段的众数不包含全局众数，我们可以扩大这个子段使得全局众数的出现次数和子段内出现次数最多的其他数出现一样多，显然更优。

一般的做法是考虑根号分治，分出现次数大于 $\sqrt n$ 的和不满 $\sqrt n$ 的考虑。前者可以直接 $O(n)$ 暴力复杂度 $O(n \sqrt n)$，后者采取双指针也能做到 $O(n \sqrt n)$。总时间复杂度 $O(n \sqrt n)$。

考虑优化。注意到我们确定了一个众数 $c$，再枚举区间内的一个其他的众数 $d$，那么将 $c$ 看做 $1$，$d$ 看做 $-1$，其他看做 $0$，我们需要找到一个和为 $0$ 的子段。我们抽出这样一段并让单点带权，问题的形式已经被完全转化成[此题](https://www.luogu.com.cn/problem/P8349)，并有了比较优秀的性质：每次查询的 $x$ 有一个相等。

我们直接采用上面提及的题目中大数对小数的做法，维护可能在子段中的 $1$ 的集合。枚举其他的所有众数后，集合的大小也不过 $O(n)$。这样直接算就好了。

时间复杂度最终取决于造出集合的时间复杂度。暴力删点是 $O(n \log n)$ 的。注意到我们并不需要实时回答问题，可以分开维护向左和向右取的全局众数，用栈维护全局众数若干个连续的连续段集合即可。