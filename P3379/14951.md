lca目前比较流行的算法主要有tarjian，倍增和树链剖分

关于倍增算法楼下已有详细阐述，在这里我就先介绍剩下两种

tarjian是一种离线算法，需要提前知道所有询问对

算法如下

1.读入所有询问对（u,v），并建好树（建议邻接表）

2.初始化每个节点各属一个并查集，都指向自己

3.对整棵树进行dfs（深度优先搜索）遍历

每处理到一个新节点(u)时看他的另一半（询问对象v）是否visit过，如果visit过了，则这组询问对的lca即v的并查集的根节点，若没有visit过，则继续向下深搜，该节点记为已visit

每当回溯的时候都将子节点的并查集并到父节点的并查集中


这样一遍走下来就完成了tarjian算法。


接着说说树剖，

树剖（树链剖分）是一种在线算法，跑起来非常快，应该是目前lca算法中最优的

建树后，我们需要把整棵树划为轻重链，

每一个非叶子节点都一定在一条重链上

定义：

重边：父节点与其子树最大（子节点最多）的节点的连边称为重边

轻边：非重边即为轻边

重链：相连的重边称为重链

划分重链后，我们要记一个jump数组表示存每个节点的“跳”的信息

如果这个节点在重链上，则jump[i]为它所属重链的根节点（最顶端）

如果这个节点不在重链上或者它是一条重链的顶端（根节点），那么jump[i]为它的父节点


接下来我们就可以处理询问对了

比如求两个节点a，b的lca

我们先看他们是否在同一条重链上，如果是，则lca即为深度较小的节点

如果不是，则我们需要比较jump[a]和jump[b]的深度，jump[a]比较浅则令a=jump[a]反之令b=jump[b]

重复以上过程直到a==b（lca为这个节点）或a,b在同一条重链上时（lca为深度浅的节点）


这样就完成了，复杂度虽说评是O(n\*logn)但实际上跑起来快得多

以上就是我对lca的理解，希望对大家有帮助。


————by cc\_ling 2017.3.5
