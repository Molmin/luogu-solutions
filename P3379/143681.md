- 算法：

首先我们能想出一种暴力算法：先把深度高的点跳到和深度低的点的同一层，然后他们俩一起往上跳，如果两个点相遇了，当前点就是他们的最近公共祖先。但可惜会超时，于是我们考虑一下优化。

- 优化：

我们可以把跳的过程优化一下，原来是一个一个往上跳，速度太慢，我们就可以用二进制优化一下，2的n次方这样往上跳。已知fa[u][i]表示u的第2的i次方个祖先（fa[u][0]就是u的父亲）。时间复杂度O(n log n)

- 流程：

1. 我们先预处理出每个点的2的i（0 <= i <= 上限（上限直接用20也行））次方的父亲和每个点的深度
2. 然后将两个点中深度最深的点往上跳，直到与另一点在同样的深度
3. 进行特判是否两个点重合了（重合了就不用向上跳了）
4. 然后两个点一起向上跳2的i（i从大到小，因为这样保证有正确性）次方（前提是不能重合），最后他们会跳到他们的LCA的儿子上（自行理解）
5. 最后返回其中一个点的父亲就是他们两个的LCA

- 全文 + 代码：

https://www.cnblogs.com/qqq1112/p/11448165.html