# 题意
给定一个 $n$ 长的排列，询问是否可以通过以下操作使排列变为不下降的。

取序号 $1\le i < j < k\le n$，进行操作：
- 若 $a_i>a_k$，则将 $a_i$ 改为 $a_i+a_j$；
- 若 $a_i\le a_k$，则将 $a_j$ 与 $a_k$ 交换。


# 分析

观察上述操作，发现排列中**第一个数永远无法变小**。

因为若 $i=1$，当 $a_1>a_k$ 时，$a_1$ 会变为 $a_1+a_j$，又因为排列中每个数都是大于零的，所以此时 $a_1$ 会变大；当 $a_1\le a_k$ 时，交换的是 $a_j$ 和 $a_k$，与 $a_1$ 无关，所以 $a_1$ 永远无法变小。

而不下降的排列中，第一个数肯定是 $1$，所以如果输入的排列第一个数字 不是 $1$，由于上述 $a_1$ 永远无法变小的结论，输出答案就为否。

当输入的排列里，第一个数字为 $1$ 的时候，必然可以通过上述操作实现不下降排列。

因为如果令 $i=1$，由于排列每个元素不重复的性质，后面的数字都比 $1$ 要大，所以**只能做第二个操作**。这样一来，我们取要调整的数字所在位置为 $k$，要将其调整到达的位置为 $j$，这样就可以实现 $a_j$ 与 $a_k$ 的交换，即除了第一个元素，后面的元素想怎么交换位置就怎么交换，所以此时一定可以交换出我们想要的序列。


# 代码

```cpp
#include<bits/stdc++.h>
#define LL long long
using namespace std;
const int N = 1e6+6;
LL _,n,a[N];
void work(){
	cin>>n;
	for(LL i=1;i<=n;i++){
		cin>>a[i];
	}
	if(a[1]!=1){
		cout<<"NO\n";
	}
	else cout<<"YES\n";
}
int main(){
	ios::sync_with_stdio(false);
	cin>>_;
	while(_--){
		work();
	}
} 
```
