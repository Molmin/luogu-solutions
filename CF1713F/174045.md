~~看错两次题，两个假做法拼起来就是正解，眼花人大胜利。~~

不需要技术和推导，但是稍微有点费观察的做法。

考虑先由 $b_{i,n}$ 求出 $b_{n,i}$，再求出 $b_{0,i}$。

对于前半部分，我们知道 $b_{i,j}=b_{i,j+1}\oplus b_{i-1,j+1}$。考虑下面这张图，第 $i$ 行 $j$ 列是 `1` 则表示 $b_{i,n}$ 对 $b_{n,j}$ 有贡献：
```plain
1000000000
1100000000
0010000000
0011000000
0010100000
0011110000
0010001000
0011001100
1010101010
1111111111
```
这是一个很漂亮的分形（看不出来的话只看右下角八行八列），可以递归求解，改成迭代的话就是类似 FWT 的形式。我特意画了一个 $n$ 不是二的次幂的情况，这也没差。

严谨证明写起来可能比较繁琐，主要需要证明 $b_{i,n}$ 对右下角的三角中同一列的每个位置的贡献都是同一形式，但是肯定是很直观的。

这部分本质就是其他题解里的子集和，代码写起来也一样。

对于后半部分，我们知道 $b_{i,j}=b_{i+1,j}\oplus b_{i+1,j-1}$。贡献的形式跟上面比较类似，我直接写了，对于下面的图，第 $i$ 行 $j$ 列是 `1` 表示 $b_{n,j}$ 对 $b_{0,i}$ 有贡献：
```plain
1000000000
0100000000
1010000000
0101000000
0010100000
0001010000
0000101000
1000010100
0100001010
1010000101
```
就是第一个图，往左再写一列，然后把那一列横过来再不断左移得到 $n$ 行。

然后考虑这样一个过程：先令 $b_{0,i}=b_{n,i}$，然后从低到高遍历 $n$ 的每一个为 $1$ 的二进制位 $j$，把每个 $b_{0,i}$ 异或上 $b_{0,i-2^j}$。

手玩一下你发现这样的过程就构成了上面的贡献形式。证明也是那种“我不知道怎么证但是它肯定能证”。不过我不是很清楚这个过程的本质。

可以看代码理解。
```cpp
#include<bits/stdc++.h>
using namespace std;
using ll=long long;
inline ll read(){
	ll x=0;
	bool f=0;
	char c=getchar();
	while(!isdigit(c)){
		if(c=='-') f=1;
		c=getchar();
	}
	while(isdigit(c)){
		x=x*10+c-'0';
		c=getchar();
	}
	return f?-x:x;
}
const int maxn=5e5+5;
int n,a[maxn];
int main(){
#ifdef LOCAL
	freopen("in.txt","r",stdin);
	freopen("out.txt","w",stdout);
#endif
	n=read();
	// 通过最后一列计算最后一行
	for(int i=n-1;i>=0;i--) a[i]=read();
	for(int i=0;i<20;i++)
		for(int j=0;j<n;j++)
			if(j>>i&1) a[j]^=a[j^(1<<i)];
	reverse(a,a+n+1);
	// 通过最后一行计算第一行
	for(int i=0;i<20;i++) if(n>>i&1)
		for(int j=n;j>(1<<i);j--) a[j]^=a[j-(1<<i)];
	for(int i=1;i<=n;i++) printf("%d ",a[i]);
#ifdef LOCAL
	fprintf(stderr,"%f\n",1.0*clock()/CLOCKS_PER_SEC);
#endif
	return 0;
}
```
有没有老哥教教我啊。