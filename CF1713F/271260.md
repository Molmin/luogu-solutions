看每个 $a_{i}$ 对 $b_{j,n}$ 的贡献，显然，这两点间路径数量就为贡献的次数，因为是异或所以看奇偶性即可。我们发现，$a_{i}$ 对 $b_{j,n}$ 的贡献就是 $C^{j-1}_{n-i+j}$。也就是说 $a_{n-i+1}$ 对 $b_{j,n}$ 的贡献就是 $C^{j-1}_{i-1+j-1}$。

可以证明，对于组合数 $C^{i}_{j}$，其为奇数当且仅当 $i$ 是 $j$ 的子集。然后我们可以根据这些条件建立起一个异或方程组，可惜时间复杂度是 $O(n^3)$，不足以解决问题。

当然可以优化，发现这个异或方程组中最多 $n \sqrt{n}$ 个贡献，可以暴力存下来进行求解，但是会被卡。以下是一个异或方程组矩阵的示例。（我将 $a$ 数组反了过来，以便简化组合数）

```
1 1 1 1 1
1 0 1 0 1
1 1 0 0 1
1 0 0 0 1
1 1 1 1 0
```

因为这个异或方程组的矩阵建立方式很特殊，感觉有规律可循，希望能利用这个图快速求解。我们沿着朴素的异或方程组思路走，我们想将这个矩阵消出一个斜三角，于是矩阵变成了这样：

```
1 1 1 1 1
0 1 0 1 0
0 0 1 1 0
0 0 0 1 0
0 0 0 0 1
```

然后再按常规思路把除对角线外的东西消掉：

```
1 0 0 0 0
0 1 0 0 0
0 0 1 0 0
0 0 0 1 0
0 0 0 0 1
```

然后就是答案了，我们发现，我们发现，第一步消元中，对第 $i$ 行消元刚好使用了 $i$ 的所有真子集，这个是可以递推优化的。

第二步中，第 $i$ 行消元刚好使用了所有以 $i$ 为真子集的行，这个同样是可以递推优化的。

然后最后的 $a$ 数组就是答案。

```
// LUOGU_RID: 104820427
#include<bits/stdc++.h>
template<typename G>inline void read(G&x) {G f=1;x=0;char ch=getchar();while((ch<'0'||ch>'9')&&ch!='-') ch=getchar();if(ch=='-') f=-1,ch=getchar();while(ch>='0'&&ch<='9') x=x*10+(ch^48),ch=getchar();x*=f;}
using namespace std;
const int MAXN=1e6+5;
int n,a[MAXN];
signed main() {
	read(n);--n;
	for(int i=0;i<=n;++i) read(a[i]);
	for(int j=0;j<19;++j) {
		for(int i=n;i>=0;--i) {
			if(i>>j&1) a[i]^=a[i^(1<<j)];
		}
	}
	for(int j=0;j<19;++j) {
		for(int i=0;i<=n;++i) {
			if(!(i>>j&1)) a[i]^=a[i^(1<<j)];
		}
	}
	for(int i=n;i>=0;--i) printf("%d ",a[i]);
	return 0;
}
```