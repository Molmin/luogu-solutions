大概题意：

有 $n$ 个教练，和 $t$ 个现有的教练团队，每个团队都属于两个协会中的一个。有e对训练师互相憎恨。他们的仇恨没有重边和自环。每个教练都有一个愿望清单，列出他想加入的团队。你的任务是将球员分成小组，并将小组分成两个会议，以便：

1. 每个教练都属于一个团队；

1. 没有团队参加两个协会；

1. 协会之间的总仇恨至少为 $ \frac{e}2 $；

1. 每一位教练都是从他的愿望清单中选出的一个团队。

1. 会议之间的总仇恨计算为来自不同会议的团队中互相憎恨的培训师对的数量。


---

是一道非常神奇的题目。cf里这个题有`probabilities`的标签。

拿到题目，简单思考：总仇恨值至少为$ \frac{e}2 $，这个值是不是有一点点低？

稍加思索：简化模型，若我们随机选团队，团队随机选协会，那么可以看做每个教练都随机分布在两个协会中且概率相等（这里是简化了的模型，大致可以这么认为）。

那么考虑每一条憎恨的边，易得其有一半的概率对总仇恨产生贡献，那么所有边的总贡献的和的期望值就是 $ \frac{e}2 $ 。

并且可以认为每一条边的产生贡献和不产生贡献其实是等价的，也就是纯随机总贡献有一半以上的可能是符合条件的。这样我们随便随机几次就可以随机出答案： 设随机了 $k$ 次，那么所有的随机都没有成功的概率就是 $\frac1{2^k}$ ，期望两次就可以随机出答案，随机 $20$ 次几乎不可能失败。

---

核心代码：

```cpp
bool work(){
	for (int i=1;i<=n;i++) belong[i]=t[i][rand()%t[i][0]+1];//随机运动员选择 
	for (int i=1;i<=T;i++) c[i]=(rand()&1);//随机团队 
	int res=0;
	for (int i=1;i<=e;i++) res+=(c[belong[a[i].X]]!=c[belong[a[i].Y]]);//计算贡献 
	return res*2>=e;
}
int main(){
	srand('S'+'J'+'Y'+' '+'A'+'K'+' '+'I'+'O'+'I');
	scanf("%d%d",&n,&e);
	for (int i=1;i<=e;i++) scanf("%d%d",&a[i].X,&a[i].Y);
	for (int i=1;i<=n;i++){
		scanf("%d",&t[i][0]);
		for (int j=1;j<=t[i][0];j++) scanf("%d",&t[i][j]),T=max(T,t[i][j]);
	}
	while (!work());
	for (int i=1;i<=n;i++) printf("%d ",belong[i]);puts("");
	for (int i=1;i<=T;i++) printf("%d ",c[i]+1);
	return 0;
}
}

```


