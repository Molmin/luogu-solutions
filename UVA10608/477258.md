把每位公民看作点，朋友关系为边，题目意思便被我们转化成了：

有一个 $N$ 个点 $M$ 条边的无向图，求其中最大连通块中点的数量。

可以直接考虑并查集。

并查集，顾名思义，它需要实现并和查的功能。

并，指的是将两个点所在的连通块合并，而查，指的是判断两点是否在一个连通块里。对于这题，我们只需要实现并的功能。

为了方便查找，并查集均用父亲节点存储法，每个节点指向它所连边的上一个节点。

如何将两个点所在的连通块合并呢？按照我们的理解，是不是给出两个点，在这两个点中间连一条线，就能合并了呢？当然不。当你直接连边时，你连的两个边的父亲级别的节点均不会认为存在加边，而且加边后也不好处理两个边的父亲节点数组。

根据第一个出现的问题，可以发现我们要用没有父节点的点来进行连边。因此，可以发现另一种选择：对两个点的最老祖宗节点进行连边。

那么，我们就需要实现寻找最老祖宗节点和连边的程序。

求最老祖宗节点：

```cpp
int find(int x){//寻找点x的祖先
	if(x==f[x]) return x;//如果点x的祖先是自己，说明x就是最老祖宗节点，返回x。
	return f[x]=find(f[x]);//否则，递归其父亲节点
}
```
连边：

```cpp
void add(int x,int y){//连边
	f[find(x)]=find(y);//对两个点的最老祖宗进行连边。此处默认把y的祖先连到x上。
}
```
并的问题解决了，对于其他部分，设一个数组，把一个连通块的所有点的数量存在其最老祖宗节点在数组中的对应位置，再求最大值，本题便做完了。

注意事项：

- 本题是**多组数据**！不要用单个数据的做法来做本题。

- 初始时要将每个点的父亲节点设为自己，这代表一个点的父亲节点仍是自己，即途中没有边。之后再根据输入逐个加边。

- 对于每一个数据，存连通块点数量的数组都要归零，以免出现奇怪的 WA。

考虑了这些，代码就好写了。

```cpp
#include <iostream>
using namespace std;
int f[30003],fr[30003];
int n,m,t,a,b;
int find(int x){//查找祖先
	if(x==f[x]) return x;
	return f[x]=find(f[x]);
}
void add(int x,int y){//连边
	f[find(x)]=find(y);
}
int main(){
	cin>>t;
	while(t--){
		cin>>n>>m;
		for(int i=1;i<=n;i++){
			f[i]=i;
			fr[i]=0;//这里是初始化。
		}
		for(int i=1;i<=m;i++){
			cin>>a>>b;
			add(a,b);
		}
		for(int i=1;i<=n;i++){
			fr[find(i)]++;//存节点数量
		}
		int maxnum=-1;
		for(int i=1;i<=n;i++){
			if(maxnum<fr[i]){
				maxnum=fr[i];//找节点最多的连通块的节点数量
			}
		}
		cout<<maxnum<<endl;
	}
	return 0;
}
```
附录：

这是一道并查集题目，对并查集感兴趣的同学可以再去做一下下面几题：

[P1551 亲戚](https://www.luogu.com.cn/problem/P1551)；

[P3367 【模板】并查集](https://www.luogu.com.cn/problem/P3367)；

[UVA10583 Ubiquitous Religions](https://www.luogu.com.cn/problem/UVA10583)。

都是比较基础的并查集题目，但都要涉及到查的功能，可以翻看一下题解，里面有较详细的对并查集的讲解。