题解连更计划第5篇

## 【题意】
好题，但是翻译错了，然后讨论里的翻译不够全面，下面简述一下题意。

就是有三个长度为$n$的字符串$A$，$B$，$C$，其中$C$是一个仅由$'?'$构成的字符串。

现在$Oleg$和$Igor$每个人分别有一个字符串（可能会有重复元素），然后从$Oleg$开始轮流进行下列操作：

1. 选一个自己字符串中的字符
2. 把$C$中**任何一个位置**上的$'?'$字符替换为所选字符
3. 删去自己字符串中的所选字符

然后$Oleg$要尽可能使$C$字典序小，$Igor$反之，且两人都使用最优策略，求$C$。

## 【注意】
我上面已经标黑了——**任意一个位置**。不然这道题就太水了

## 【思路】
首先，我们很容易想到：

若$n \equiv 1(mod~2)$，则$Oleg$需要选出$\lfloor \frac n2 \rfloor + 1$个字母，而$Igor$需要选出$\lfloor \frac n2 \rfloor$个。

若$n \equiv 0(mod~2)$，则$Oleg$需要选出$\lfloor \frac n2 \rfloor$个字母，而$Igor$需要选出$\lfloor \frac n2 \rfloor$个。

而由于$Oleg$要尽可能让字典序小，他一定只会选出$A$**字符串中所有字母里字典序最小的那几个字母**，同理，$Igor$会选出$B$中最大的几个。

于是想到排序，然后分别储存两个人**一定会用到**的字母。

接下来思考对于这一些字母，两个人会怎么处理，即最优策略，得出后模拟即可。

## 【策略】
分两种情况讨论。

当$Oleg$所选字母中最小的已经比$Igor$所选的字母中最大的还要大了，例如
$${A}={b, c}~~{B}={a, a}$$
为了使字典序尽可能小，$Oleg$应该怎么做？

答案显而易见，**如果这一步不能使自己最优，那就防止自己最劣**。

因此，他应该把$'c'$放到$C$的最后一位，显然这是当前最优的（因为如果他对前面进行操作，后手一定可以使你更劣，比如你把$'b'$放到第二位，后手就可以把$'a'$放到最后一位，此时你一定更劣）。

所以，当$Oleg$所选字母中最小的已经比$Igor$所选的字母中最大的还要大了，就把$A$**必选的字母中**最大的放到$C$的最后。

而如果上述情况不发生，就按照一般思维，把自己最小的放在$C$最前面，防止对手抢占这个位置。

而$Igor$显然同理，这里不再赘述，留给读者思考。

等等，同理？

那么这两个人的程序显然可以合并起来写啊。

## 【写法】
这里提供一种很简便的代码写法。

先排序，这个不用说，也没什么技术含量。

由于要同时求最大值与最小值，想到单调队列，进一步想到$deque$来维护。

然后用类似于**滚动数组**的写法分别模拟两个玩家的所有操作策略，由于两人策略显然相同，应此程序相同，不用多次判断。

最后输出$C$即可。

下面给出程序。

```cpp
#include <bits/stdc++.h>
using namespace std;

char s[2][300010], ans[300010];//滚数写法
inline bool cmp(char x, char y)
{
	return x > y;
}

int ed, bg, len;

deque <char> a[2];

int main()
{
	scanf("%s%s", s[0], s[1]);
	len = strlen(s[0]);//要卡卡常，我在这里锅过
	sort(s[0], s[0] + len);
	sort(s[1], s[1] + len, cmp); 
	for (register int i = 0;i < len;i ++)
	{
		a[i & 1].push_back(s[i & 1][cur[i & 1] ++]);//存deque
	}
	bg = 0;
	ed = len - 1;
	for (register int i = 0;i < len;i ++)
	{
		if(a[0].front() >= a[1].front())//重头戏，这里面的转移可以思考一下
		{
			ans[ed --] = a[i & 1].back();
			a[i & 1].pop_back();
		}
		else
		{
			ans[bg ++] = a[i & 1].front();
			a[i & 1].pop_front();
		}
	}
	printf("%s", ans);
}
```