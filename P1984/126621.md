[P1984 [SDOI2008]烧水问题](https://www.luogu.org/problem/P1984)

贪心：

1.```一杯杯地烧开比几杯一起烧开要优```.

解释：如果每次只烧开一杯，那么烧开之后可以用热传递**给其他所有杯都加热一些**；而如果同时烧开几杯，那么相当于本来可以用热传递先加热再烧开的那些水直接烧开了，增加了总的加热温度，所以不优.

2.``每次烧水时都贪心地选择此时温度最高的那一杯烧开``.

解释：如果我们当前选择的不是温度最高的一杯，那么它实际上本来是可以先被热传递加热一些的，现在选择它会导致总的加热温度增加.


------------

通过以上的分析，我们不难得出具体做法：**每次依次选择温度最高的一杯加热，直到所有杯的水都烧开过为止.**

也就是枚举每一杯水，然后对其他还没有烧开的水进行热传递.

暴力的做法是$O(n^2)$的，无法通过该题. 所以我们不妨列出几项找找规律.

~~果然数论题还是应该推式子找各项之间加减乘除乘方的递推关系吗~~

>第一杯，加热到沸点$p$，温度增量为$p$
>
>第二杯，热传递后温度为$p/2$，温度增量为$p/2$
>
>第三杯，热传递后温度为$(p/4+p)/2=5p/8$，温度增量为$3p/8$
>
>第四杯，热传递后温度为$((p/8+5p/8)/2+p)/2=11p/16$，温度增量为$5p/16$

观察发现，每两杯之间的温度增量之比：

>第二杯：第一杯=$1/2$
>
>第三杯：第二杯=$3/4$
>
>第四杯：第三杯=$5/6$
>
>第$n$杯：第$n-1$杯=$(2(n-1)-1)/2(n-1)$

通过归纳法（已有大佬论证，不加以赘述）可以得证.

又因为**能量增量的比等于温度增量之比**，最小总能量等于能量增量之和，所以我们就可以在$O(n)$之内算出最小的总能量了.

注意初始化第一杯水所需的能量为$(4200*100)/n$.

```cpp
#include<bits/stdc++.h>
#define ldb long double
#define maxn 3000010
using namespace std;
ldb sum(ldb x){
	return ((x-1)*2-1)/((x-1)*2);
}
int n;
ldb eng[maxn],ans;
int main(){
	scanf("%d",&n);
	eng[1]=((ldb)420000/(ldb)n);ans=eng[1];
	for(int i=2;i<=n;i++){
		eng[i]=sum(i)*eng[i-1];//能量增量之间的比例关系
		ans+=eng[i];//总能量增量等于答案
	}
	printf("%.2Lf\n",ans);
	return 0;
} 
```
