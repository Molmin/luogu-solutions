嘛，我觉得，这道题蓝题实在是言过其实了。完全就是状压dp模板题啊！

我们对于**每个单词选或者不选**这个状态用一个二进制数存储。

举个栗子：

- 00001就是只有第一个单词被选上了；

- 00100就是只有第三个单词被选上了；

- 01001就是第一、四个单词被选上了；

- 11111就是这五个单词全部被选上了。

我们一看数据范围，$N\le16$，那就是说我们的状态不会超过$2^{16}-1=65535$，吼啊。

下面是愉快的转移方程时间：

$f[s][c]$表示状态为$s$且最后一个字母为$c$的最大复杂度，那么我们现在想选上单词$j$：

如果$s\;|\;2^{j-1}$，即$j$的那一位为1，那么$j$已经被选过了，我们就不能再选了，continue;

否则

$f[s+2^{j-1}][j$的末位$]=max(f[s+2^{j-1}][j$的末位$],f[s][j$的首位$]+j$的长度$)$

想必大家都看的出来$s+2^{j-1}$就是我们选上$j$之后的状态啦。

最后奉上代码：

```
#include<bits/stdc++.h>
using namespace std;

int n,N;
int f[66666][30];  //f[s][c]是状态为s,末尾字符为c的最大复杂度
string wrd[20];
int ANS;

int main(){
	cin>>n;N=(1<<n)-1;
	for(int i=1;i<=n;i++) cin>>wrd[i];
	
	for(int i=1;i<=n;i++)
		f[1<<(i-1)][wrd[i][wrd[i].size()-1]-'A']=wrd[i].size(),ANS=max(ANS,f[1<<(i-1)][wrd[i][wrd[i].size()-1]-'A']);  //初始化 
	
	for(int i=1;i<=n;i++)  //最多n个单词嘛
	for(int j=1;j<=n;j++)  //选择使用单词j
	for(int s=0;s<=N;s++)  //状态
	if(s & (1<<(j-1)))  continue;  //选过惹~
	else{
		f[s + (1<<(j-1))][wrd[j][wrd[j].size()-1]-'A']=max( f[s + (1<<(j-1))] [wrd[j][wrd[j].size()-1]-'A'] ,(int)(f[s][wrd[j][0]-'A'] +wrd[j].size()));
		ANS=max(ANS,f[s + (1<<(j-1))][wrd[j][wrd[j].size()-1]-'A']);
		//cout<<i<<' '<<j<<' '<<s<<endl;
	} 
	cout<<ANS;
} 
```

~~900+ms，我也很想知道那些爆搜是怎么做到0ms的~~