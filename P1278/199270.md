这应该是本题最~~短小~~的代码了(就是有亿点点慢QAQ)

首先看标签,记忆化搜索....,嗯,所以我们可以考虑用$\operatorname{DP}$来完成(~~一般情况下,能用记忆化搜索的都能用$\operatorname{DP}$~~)

这一题由于一个单词是否说过会影响状态的转移,所以我们可以考虑用状压$\operatorname{DP}$

什么是状压$\operatorname{DP}$呢,下面是状压$\operatorname{DP}$的入门知识

我们知道,[一个十进制数可以转化为二进制](https://www.cnblogs.com/web-record/p/11132861.html),二进制数是由0和1组成,如$(11)_{10}=(1011)_{2}$我们可以用,这些1和0来表示一些信息,而因为它是数所以可以存在用于DP的数组里,并且可以通过位运算来进行快速的计算.

这里介绍几种位运算

按位与"$\&$",$1\& 1 =1$,$1\& 0 =0$,$0\& 1 =0$,$0\& 0 =0$,如果是一个多位的二进制数则按位计算,如$(1011)_{2} \& (0110)_2 = (0010)_{2} =(10)_2=(2)_{10}$

按位或"$|$" $1| 1 =1$,$1| 0 =1$,$0| 1 =1$,$0| 0 =0$ 计算方法同上

按位异或"$⊕$" $1⊕ 1 =0$,$1⊕ 0 =1$,$0⊕ 1 =1$,$0⊕ 0 =0$,计算方法同上(注这个位运算在C++代码中用"^"符号表示)

右移"$<<$",就是将一个数的二进制串整体像右移,如$(13)_{10}<<3=(1101)_2<<3=(1101000)_2=(104)_{10}$,并且$a<<k=a\times 2^k$

左移"$>>$",类似.

那位运算如何进行,比如我们用二进制的第$i$位表示单词$i$是否说过,那么我们如果要看第单词$3$是否说过,设现在的状态为$(110010)_2$我们可以直接$(110010)_2 \& (1<<(3-1))=(110010)_2 \& (100)_2=0$,等于0,说明单词$3$还没说过,那如果我们要判断单词$k$是否说过,设状态为$j$,那么就可以判断$j\&(1<<(k-1))$,如果为1即说过

由于这一题涉及的位运算不多这里就不深究

这一题我们可以考虑用二进制数来表示状态,如果第$i$位为0,则第$i$个单词没被说过,反之则说过,我们可以把这个二进制数存在数组里作为状态来转移,所以我们的数组为$f[k]$表示状态为$k$,的最大长度,所以我们首先枚举这个状态,然后我们再枚举一个$i$和一个$j$表示从$i$接到$j$,所以我们可以得出状态转移方程

$f[k+(1<<(j-1))]=max(f[k+(1<<(j-1))],f[k]+(int)s[j].size())$

初始化$f[(1<<j)]=s[j+1].size()$(只说一个单词的状态要先处理)

我们发现总是用小的下标更新大的下标,所以从小到大($0$到$(1<<n)-1$)枚举状态即可

代码

```cpp
for(int k=0;k<(1<<n);k++)
	for(int i=1;i<=n;i++)
	for(int j=1;j<=n;j++)
	{
		if(i==j) continue;
		if(s[i][s[i].size()-1]==s[j][0]&&(k&(1<<(i-1)))&&!(k&(1<<(j-1)))) f[k+(1<<(j-1))]=max(f[k+(1<<(j-1))],f[k]+(int)s[j].size()),ans=max(ans,f[k+(1<<(j-1))]);//因为从i到j所以状态k里i必须说过,j必须没说过
	}
```

如果这样写,你会获得70分的好成绩,为什么呢?因为我们发现i能接到j,需要状态k最后一个接的为i,所以我们加一维,使数组变为$f[k][i]$表示状态为k,最后一次接的为$i$的最大长度

则状态转移方程为

$f[k+(1<<(j-1))][j]=max(f[k+(1<<(j-1))][j],f[k][i]+(int)s[j].size())$

所以代码也很容易写出来了

```cpp
#include<bits/stdc++.h>
using namespace std;
int f[(1<<16)][17],n,ans;
string s[100];
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++) cin>>s[i],f[(1<<(i-1))][i]=s[i].size();//初始化只说了一个单词的状态的值
	for(int k=0;k<(1<<n);k++)//枚举状态
	 for(int i=1;i<=n;i++)//枚举i
	  for(int j=1;j<=n;j++)//枚举j
	   if(i!=j&&s[i][s[i].size()-1]==s[j][0]&&(k&(1<<(i-1)))&&!(k&(1<<(j-1)))) f[k+(1<<(j-1))][j]=max(f[k+(1<<(j-1))][j],f[k][i]+(int)s[j].size());//更新f的值
	for(int i=0;i<(1<<n);i++) for(int j=1;j<=n;j++) ans=max(ans,f[i][j]);//找最大值
	return printf("%d",ans),0;//输出和return 0二合一
}
```
