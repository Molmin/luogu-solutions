### 神奇的 substr 

我们都知道，奶牛找对应城市时都只看城市名字的前两位，所以城市名字后面那几位都是没用的。而且很烦。

就在这时，**substr（字符串子串）** 出现了！


```
举个例子，我们先定义个 string c="ABCDE";
那么 c.substr(0,2) 就是 "AB"。

是不是有点感觉了？其实它的意思就是：
- 从字符串 c 的第 0 位开始，按顺序取 2 位得到的子串。

如果你只写前面那个数字，而不写后面那个数字的话，
如 c.substr(1) 意思是：
- 从字符串 c 的第 1 位开始，一直到末尾的这段子串（这个例子中是"BCDE"）。

```

很奇妙吧，可以自己写程序试一下。

------------

### 思路

如果把 map 看成一个盒子，把对应城市对答案的贡献看成金币，那么想象一下：

```
有一天，叫做 MIAMI FL 的城市找到了很多盒子，
它高兴地打开 MIFL（由城市名前两位和州名拼接而成）盒子，
发现里面什么也没有，他很沮丧。

善良的 MIAMI FL 为了不让别的城市和它一样，
向 FLMI（由州名和城市名前两位拼接而成）盒子
放入了它仅有的一个金币，
和它有缘（对应）的城市将会得到这份好运。

不久之后，城市 FLINT MI 也来到了这个有很多盒子的地方，
它高兴地打开 FLMI 盒子，发现里面居然有一个金币！
它取走了这个金币，并且把它交给了 ans 国王。
怀着感激之情的它向 MIFL 盒子里也放了一枚金币。

这个故事在各个城市间流传开来，
每个城市都像他们一样以这种方式行动。
城市们的善举打动了盒子，
于是放进盒子的金币即使被拿走，也从来不会减少。
在 ans 的领导下，城市们都过上了富裕的生活。
```

有了 substr 的帮助，我们可以直接把城市名转化为它的前两个字符。之后把新城市名和州用两种顺序拼接起来，就得到了：取金币的盒子，放金币的盒子。

ans（交给国王的金币总数）就是最终对应城市的数量。（想一想为什么）

------------

### 代码


```C++
#include<bits/stdc++.h>
using namespace std;
int n,ans;           //城市数 金币总数/答案
string a,b;          //城市名 州名 
map<string,int> box; //神奇的 map 
int main()
{
	ios::sync_with_stdio(false); //增加 cin, cout 的速度 
	cin>>n;    //城市数量 
	while(n--) //重复 n 次 
	{
		cin>>a>>b;       //城市名 和 州名 
		a=a.substr(0,2); //取城市名称的前两位 
		if(a!=b)         //特判 不能自己跟自己对应 
		ans+=box[a+b];   //取得金币/答案贡献
		box[b+a]++;      //存入金币，造福 城州名恰好相反的城市 
	}
	cout<<ans<<endl;
	return 0;
}

```

------------

~~其实那个故事是我随便编的，而且有逻辑谬误，大家随便看看理解一下就好。~~

~~为什么我想起了那个一大片宏定义的神仙题解。~~
