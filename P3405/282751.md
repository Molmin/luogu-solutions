这是本蒟蒻的第一篇题解，不喜勿喷。

看了一下各位 dalao 的解法，绝大部分是用的 map 做，并把字符串转换成数字，这里提供一个直接用字符串的 map 解法。

### 题目分析
题目的大致意思是：求有多少对城市和州满足城市的前两个字母与另一个州的前两个字母相同(~~好像还是很绕~~)，也就是令每个城市和他所在的州的前两个字母为 $c_i$ 和 $s_i$,找出一对 m 和 n 使得 $s_m=c_n$ 且 $s_n=c_m$。

看到这道题，第一反应是用 map 做，所以有以下代码：
~~~cpp
map<string,int>t;
~~~
其中 string 的那一项表示城市和州，int 项表示出现次数。

然后我就发现一个问题，如何表示城市和州呢？

经过我~~一通瞎搞~~深思熟虑后，我用的是这样的表示方法：在 $c_i$ 和 $s_i$ 中间插入空格，代码：
~~~cpp
	c2=c[0];c2+=c[1];//c2表示输入的c的前两位
	s2=s[0];s2+=s[1];//s2表示输入的s的前两位
	c1=c2;c1+=" ";c1+=s2;//c1表示合并c和s的结果
	s1=s2;s1+=" ";s1+=c2;//s1表示合并s和c的结果
~~~
下面开始说主体思路：对于输入的$c_i$与$s_i$，求出 $c1,c2,s1,s2$ 后，将答案加上 $t[s1]$，为啥加 $s1$ 不加 $c1$ 呢，因为一座城和州对应的应该是（州，城），然后 $t[c1]++$，最后输出答案即可。

然而，交上去 WA 了。。。

**这个题坑的地方就是要特判 $c2 = s2$，如果 $c2 = s2$ 就要把它减回去。**
### 完整代码
~~~cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	map<string,int>t;
	string c,s,c1,s1,c2,s2;
	int n,ans=0;
	cin>>n;
	while(n--)
	{ 
		cin>>c>>s;
		c2=c[0];c2+=c[1];//c2表示输入的c的前两位
		s2=s[0];s2+=s[1];//s2表示输入的s的前两位
		c1=c2;c1+=" ";c1+=s2;//c1表示合并c和s的结果
		s1=s2;s1+=" ";s1+=c2;//s1表示合并s和c的结果
		ans+=t[s1];
		if(c2==s2)//特判
		ans-=t[c1];
		t[c1]++;
	}
	cout<<ans<<endl;
    	return 0;
} 
~~~