- 发一个dp做法吧，首先这道题不是常规的dp，需要对问题进行转化。我们的目的是要通过翻转某一区间获得尽可能多的1，但是翻转也会带来一定的损失，之前的一些1会被翻转成0，如果翻转了一些不太好的区间，就会“得不偿失了”。
- 那么我们如何判断一次翻转是亏了还是赚了？可以引入一个数组b[i]记录每次反转对你当前有的“money”进行更新，如果a[i]为1，那么反转这次你的钱就会-1，如果a[i]为0，那么你的钱就会+1。那么如何让你在反转一个区间的值之后能赚到多的钱？就是求序列b的"最大连续子序列和"，这就转换为我们熟悉的不能再熟悉的问题了，时间复杂度O(n)。
- 当然也可以直接用i,j暴力枚举b的左端点和右端点，需要O（n^2）的复杂度，求b[i]+b[i+1]+...+b[j]需要O(n)的复杂度，总共的时间复杂度O（n^3）。

最大连续连续子序列求和的dp模板：
- 递归边界:dp[0] = b[0]
- 状态转移方程：
	
    以b[i]为结尾的最大连续子序列可以状态转移到两个子问题上：
    - 一是最大就是b[i]本身
    - 二是把当前元素并入前面一个元素的连续子序列中
	
代码如下(DP做法）：
```cpp
#include <bits/stdc++.h>
using namespace std;
const int maxn = 110;
int a[maxn];		//输入数组 
int b[maxn];		
int dp[maxn];		//dp[i]表示以b[i]为结尾的最大连续子序列和 

int main() {
	int n;cin>>n;
	int cnt = 0;	//cnt原来的1的个数 
	for(int i = 0;i < n;i++) {
		cin>>a[i];
		if(a[i] == 1) {
			b[i] = -1;
			cnt++;			//计算输入的总共的1数 
		}
		else b[i] = 1;
	}
	
	dp[0] = b[0];		//dp边界 
	for(int i = 1;i < n;i++) {
		dp[i] = max(b[i],dp[i-1]+b[i]);
	}
	int k = 0;		//需要遍历所有的右端点来得到最大连续子序列和 
	for(int i = 1;i < n;i++) {
		if(dp[i] > dp[k]) {
			k = i;
		}
	}
	cout<<cnt+dp[k];			//原来有的1加最佳翻转后的多出来的1为答案 
	return 0;
}
```
