#### 此题的另外两篇题解给出的做法都是 $O(n^3)$ 的时间复杂度，可以通过 $n\leq 100$ 的数据。但其实不难发现有一种 $O(n)$ 的做法：  

我们的目标是，让序列在一次翻转之后能获得尽可能多的 $1$ ，也就是在翻转之前，这段子序列中的 $1$ 尽可能少， $0$ 尽可能多。因此，我们记 $[1,i]$ 中 $0$ 的个数为 $a[i]$ , $1$ 的个数为 $b[i]$ ，从左向右扫描，维护 $a[i]-b[i]$ 的最大值即可。  

另一种理解方式，我们假定 $1$ 对答案的贡献为 $-1$， $0$ 对答案的贡献为 $1$ ，那么：

原序列  1 0 0 1 0  
贡献    -1 1 1 -1 1

对“贡献”序列求最大子段和即可。**答案为“贡献”序列的最大子段和与原序列中 $1$ 的个数之和。**~~证明显然~~。时间复杂度 $O(n)$ ，空间复杂度 $O(1)$。 

## Code ： 

```cpp
#include <cstdio>
int n,a,now,ans,cnt;
inline int max(int a,int b){
	return a>b?a:b;
} //手打max函数，据说可以加速
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		scanf("%d",&a);
		if(a){
			cnt++; //统计1的个数
			if(now) now--;
		} else now++;
		ans=max(ans,now); //ans维护最大子段和
	}
	printf("%d",cnt+ans);
	return 0;
}
```

我还给此题制作了加强版，只允许 $O(n)$ 的算法通过：[U87061 翻转序列](https://www.luogu.org/problem/U87061)
