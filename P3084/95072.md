本蒟蒻第二道题解


------------

做题历程:

夏令营模拟赛出了这道题，比赛时并不会做，老师一波玄学讲题，思路懂了，用了一天打出来，夏令营OJ全A，洛谷上WA了一个"-1"无解的点。~~夏令营OJ数据真水~~， 后面改了就AC了

------------
前置芝士：单调队列
单调队列就是一种具有严格单调性，先进先出，后进后出的数据结构，有队头和队尾两个指针。

说人话就是一个数组，数字从大到小或从小到大排列，元素可以从最后进入和最前面弹出。

实现下面会应用到。

------------


本蒟蒻并不懂什么差分约束,就直接讲讲DP的思路吧

首先，理解题意，题目大意就是一条数轴上，有多段区间，可能会相互覆盖，但不一定数轴上所有点都覆盖到，现在要求每个区间内都有且只有一个特殊点，求特殊点的最大数量。

接着，我们设F[i]表示i点放置，题意告诉我们，每个区间有且只有一个点，所以这个点的转移范围必然是前面的第一个不覆盖它的区间, 就像这样（不要吐槽我的图，我也不知道有什么好的软件，只能用画图了QwQ）![](https://cdn.luogu.com.cn/upload/pic/63325.png)

此时，我们的问题就变成了如何寻找每一个点的转移过来的区间，分析一下，这个转移过来的区间的右端点肯定是第一个覆盖到当前点的区间的左端点-1，大概就是这样![](https://cdn.luogu.com.cn/upload/pic/63330.png)

右端点好求，那怎么求左端点呢？

输入的时候，我们可以先预处理每一个照片区间，按左端点的先后sort排序,然后从数轴最右端往最左端枚举每个照片区间，当一个区间最先没有覆盖到F[i]时，这个照片区间的左端点也就是我们转移区间的左端点了（排了序，转移范围就最大了，感受一下awa）

要特别注意的是：在枚举过程中，如果一个F[i]没有被区间覆盖，那么它就是不受限制的，为求最大值，它就可以直接赋1，为了方便，我们就DP过程中就直接不统计这个点，统计这类点的个数，最后直接加上就好了。

下面就轮到了重点部分，DP了
按理来说，我们只要从左往右枚举每个点，对应地枚举区间，转移过来+1就好了，但是，如果每个点的区间都非常大，就会超时了，而在这个过程中，我们的转移区间是不断右移的，且每次只要取最大值，有没有什么方法优化呢？

那就是单调队列！

每一次我们从一个点到另一个点移动转移区间时，只要将区间右边的新元素进队，左边已不在转移范围内的旧元素出队就可以了。同时我们还要维护单调这一性质，因为我们要取最大值的队头。所以，这将是一个单调递减的队列。如果新进队的元素大于前面的元素，我们就将前面的元素弹出，让它顶替，再让它和前面的比较，如果也大于就弹出，直到符合整个队列符合单调性为止（可以将队列中的前面全部元素弹出，只剩最大的一个它）。DP转移的时候，每次获取队头的值就可以（不弹出）。图示：![](https://cdn.luogu.com.cn/upload/pic/63340.png)

另外，对于无解的情况，我们也要考虑，当一个区间完全覆盖了两个不相交的区间时，此时就无解了，如下图：![](https://cdn.luogu.com.cn/upload/pic/63357.png)
而在预处理的过程中，这种情况，右边的小区间的转移区间的左端点，会更新到左边小区间的左端点，而右端点则还保留在大区间的左端点，此时，这一部分就无法枚举，从而不会更新，，因为我们的左端点已经比右端点还右了，单调队列的头指针也先于了尾指针，整个队列里已经没有值了，也无法更新了！！！（头指针要在小于等于尾指针的情况下才能++）也就将这个状态一直持续到了结束，后面DP无法进行，也就保留了初始化化的状态（如果感觉这一段不清楚，可以看代码自己模拟）。

此时，程序的主体就已经完毕了，输出部分，我们需要从最后一个照片的左区间到N中选取，因为后面可能会没有覆盖到，而不做DP，至此，我们的程序就完毕了。

下面上代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
struct sec{
	int l,r;
}ph[1000001];//照片区间
int f[1000001],L[1000001],R[1000001],q[1000001];
//f是DP数组，L是每个点的转移区间左端点，R是右端点，q是单调队列
bool cmp(sec x,sec y){
	return x.l<y.l;
}
inline int read(){//快读
	int s=0,f=1;
	char c;
	c=getchar();
	while(c<'0' or c>'9'){
	if(c=='-')
	f=-1;
	c=getchar();
	}
	while(c>='0' and c<='9'){
	s=s*10+c-'0';
	c=getchar();
	}
	return s*f;
}
int main(){
	int n,m,i,j,now,st,ed,ans=-1,ex=0;
	n=read();m=read();
	for(i=1;i<=m;i++){
		ph[i].l=read();ph[i].r=read();//读入照片区间
	}
	sort(ph+1,ph+m+1,cmp);//按左端点从小到大快排
	now=1;
	for(i=1;i<=n;i++){//预处理每个点转移区间的右端点
		while(ph[now].r<i and now<=m)now++;
     //  ph[now].r<i  当右端点大于该点时，就找到了
     //  now<=m  如果该点在最后没有被覆盖，要判断一下，别跑出去了
		if(now>m or ph[now].l>i)R[i]=-1,ex++;
     //如果没有被覆盖，ex统计个数+1;
	    else R[i]=ph[now].l-1;//否则记录右端点
	}
	now=m;
	for(i=n;i>=1;i--){
	    while(ph[now].r>=i and now>0)now--;
     //处理左端点，从后往前枚举，一个照片区间的右端点一旦没有大于它。
     //照片区间的左端点就是转移区间的左端点了
		if(now==0)L[i]=0;
     //如果最先一个区间覆盖了它，它就从最前面0开始转移
	    else L[i]=ph[now].l;
     //直接赋值，如果是没有被覆盖的点，区间右端点-1，不计算
    }
    for(i=1;i<=n;i++)f[i]=-1;//初始化
    st=ed=1;
    //单调队列,st队头指针(也可以理解成位置，后同)，ed队尾指针
    now=0;//当前点
    for(i=1;i<=n;i++){
    	if(L[i]<=R[i]){
    	    while(R[i]>now){
          now++;//如果右端点大于当前端点，依次前移，进队
    	    if(f[now]>=0){
    	    	while(f[now]>=f[q[ed]] and ed>=st)ed--;
       //如果队尾新元素大于前面的元素，依次弹掉前面的元素，直到队头 
    	    	ed++;q[ed]=now;//完成进队
            }
            }
            while(L[i]>q[st] and st<=ed)st++;
            //前面已不再转移区间内的元素依次出队
            //后面无法转移，不进队，头指针又向前。
            //一旦越过头指针≤尾指针的边界，就无解了
            if(st<=ed)f[i]=f[q[st]]+1;
            //取队头最大值转移
        }
    }
    for(i=ph[m].l;i<=n;i++)
    ans=max(ans,f[i]);//在最后取最大值 
    if(ans==-1)//如果过程中已无法转移过来，全为-1，则无解
    printf("-1\n");
    else
    printf("%d\n",ans+ex);//有解就最大值加上没被覆盖的点的数量，输出
	return 0;
}
```
本篇题解到此结束，本蒟蒻没写过几篇题解，如有不周之处，请各位神犇大佬多多包涵,同时也欢迎指正