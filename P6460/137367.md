本题值得使用$Python$练手，但需要注意细节。

- 考虑隔天的情况

- 相同时刻需要特判，直接输出$24:00:00$，原因是：

> 保证时间间隔至少是 $1$ 秒钟，最多是 $24$ 小时。

对于$Python$来说，我们可以输入两个字符串，然后分别提取其中的数字。这里会用到一个类型转换，即：

`int(x,base=y)`

上述函数可以将$x$（可以是数字或字符）转换为$y$进制的数。对于十进制数，$y$可以用$0$替代，作为默认值。

例如`int('8',base=0)=8`，`int('8',base=6)=12`等。

通过这种方式，我们可以将字符串的数据存入变量中。而通过这些变量，我们可以计算时间差，从而分别得到时、分、秒的差。

```python
s = ['', ''] # 定义空字符串数组，长度为2（等同于输入的行数）
hh = [0, 0] # 定义保存输入的小时的数组
mm = [0, 0] # 定义保存输入的分钟的数组
ss = [0, 0] # 定义保存输入的分钟的数组
t = [0, 0] # 定义保存一个时间点所对应的秒数（例如12小时36分钟27秒就是45387秒，以45387的数的形式存放在该数组中）
ans = [0, 0, 0] # 定义保存最终答案，即时间差的数组，长度为3（即时、分、秒）
first = False # 定义first的bool变量，用来判断是否要在开头打印冒号
for i in range(len(s)): # 在[0,len(s))的范围内进行操作（即[0,2)）
    s[i] = str(input()) # 以字符串形式输入
    hh[i] = int(s[i][0], base = 0) * 10 + int(s[i][1], base = 0) # 获得对应位置的数，对于每一段的第一个数，我们将其乘10并加上着一段的第二个数作为转化完的数据
    mm[i] = int(s[i][3], base = 0) * 10 + int(s[i][4], base = 0)
    ss[i] = int(s[i][6], base = 0) * 10 + int(s[i][7], base = 0)
    t[i] = 3600 * hh[i] + 60 * mm[i] + ss[i] # 计算时、分、秒对应的秒数
if s[0] == s[1]: # 特判！！！！！
    print('24:00:00')
else:
    if t[1] < t[0]: # 如果第二个的时刻在第一个时刻之前，就说明在第二天，要加1天，即（3600×24=）86400秒
        t[1] += 86400
    dif = t[1] - t[0] # 差为t[1]-t[0]
    ans[0] = dif // 3600 # 小时数
    ans[1] = dif // 60 % 60 # 分钟数
    ans[2] = dif % 60 # 秒数
    for i in ans: # 这里i取的是ans数组中对应的数据，而不是下标
        if first == True: # first为真就输出冒号
            print(':', end='') # end=''表示输出前面内容后不换行
        if i < 10: # 是一位数就要补0
            print('0', end='')
        print(i, end='') # 输出该位
        first = True # 赋值first为真
```

附上$C++$代码：（需要$C$语言的话，可以直接把下方的头文件`#include<cstdio>`改为`#include<stdio.h>`并把`bool first`改为`int first`，因为$C$语言没有`bool`）

```cpp
#include<cstdio>
int hh[2],mm[2],ss[2],t[2],dif,i,ans[3];
bool first;//这些变量意义都同Python代码（除了i以外，它是用于循环的）
int main()
{
    for(i=0;i<2;i++)
    {
        scanf("%d:%d:%d",&hh[i],&mm[i],&ss[i]);
        t[i]=3600*hh[i]+60*mm[i]+ss[i];//格式化输入不提
    }
    if(t[0]==t[1])//特判
    {
        printf("24:00:00");
        return 0;//直接结束程序
    }
    dif=t[1]-t[0];
    if(dif<0)dif+=86400;
    ans[0]=dif/3600;
    ans[1]=dif/60%60;
    ans[2]=dif%60;//计算
    for(i=0;i<3;i++)//循环输出
    {
        if(first)putchar(':');//putchar速度>printf速度
        if(ans[i]<10)putchar('0');//判断
        printf("%d",ans[i]);//输出
        first=1;//赋值
    }
}
```

$Updates:$

$\text{2020-4-24 19:31 发布}$

$\text{2020-4-25 9:10 增加了C++代码}$