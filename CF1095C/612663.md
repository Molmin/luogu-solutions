注：非常抱歉打错了几个字，只能重新提交审核了！

本蒟蒻第一次提交题解，有错的地方欢迎指出！一下是正片：

### 1、思路实现

[先给个 link](https://www.luogu.com.cn/problem/CF1095C)

先一看，是道蓝题，不过别急，这道蓝题很简单。题目要求我们把 $n$ 拆成 $k$ 个 $2$ 的幂，显然我们可以先转换成二进制。比如样例中的 $n$ 转换为二进制就是： $(1001)_2$ ，通过位值原理，又可以转换成： $(1000)_2+(1)_2$ ，转成十进制，就是 $(8)_{10}+(1)_{10}$ ，这样， $n$ 就被拆分成了两个 $2$ 的幂。

不过样例要求要拆 $4$ 个 $2$ 的幂，所以这样显然不行。但是，我们知道： $2^k = 2^{k-1}*2$ 所以，通过这种方法，我们可以每次挑出最大的 $2$ 的幂，然后把它拆成两个小一半的 $2$ 的幂，这样，我们就离答案进了一步！

**总结：** 现将 $n$ 转成二进制，在每次挑出最大的 $2$ 的幂，把它拆成两个，直到出现了 $k$ 个幂。

### 2、特殊情况

1. 不难发现， $2$ 的幂的数量只会越来越多，所以如果 $k$ 一开始就小于的 $2$ 的幂数量，直接输出 $“No”$。注意一下， $n$ 的二进制中， $1$ 的数量就是幂的数量哦！

1. 如果 $n$ 小于 $k$ ，那么也输出 $“No”$ ，具体为什么不解释（因为太简单了）。

加上了两种特殊情况，就到了代码时间了！

### 3、具体实现

我们可以先用数组 $a$ 存储 $n$ 的二进制，但具体表达却与二进制不太相同。例如 $1001$ 就按照之前所说，把当前最大的 $2$ 的幂拆成两个小一点的，再按照原来的方法就表示为 $0201$ （也就是 $(100)_2+(100)_2+(1)_2$ ，现在数组 $a$ 已经不是只有 $0$ 和 $1$ 了），此时，从右往左的 $n$ 位就表示有几个 $2^{n-1}$ 。当 $a$ 中的数字总和等于 $k$ 时，就是答案。比如样例，现先是 $1001$ ，然后是 $0201$ ，再将首位 “推” 一次，就得到 $0121$ ，等于 $(100)_2+(10)_2+(10)_2+(1)_2$ 最后一转换，就得到了 $(4)_{10}+(2)_{10}+(2)_{10}+(1)_{10}$ ，注意要从小到大输出。

其他的具体细节就看注释吧！

```cpp
#include<bits/stdc++.h>
#define int long long // 这道题可以不开 long long 哦！
#define QWQ while(1) cout<<"yee" 
using namespace std;
const int N=2e5+5;
int n,k,idx,a[N],t;
// idx 是 n 的二进制时的位数, a 数组用于储存 n 的二进制。 
// t 是用于临时记录 n 中， 2 的幂的数量（也就是 1 的数量）。
signed main()
{
	QWQ;
	cin>>n>>k; // 平平无奇的输入。 
	if(n<k){
		cout<<"NO";
		return 0;
		// 特殊情况 2 ，之前介绍过了 qwp 。 
	}
	while(n){ // 进制转换部分，把 n 转成二进制。 
		s[++idx]=n&1; // 这一步是位运算，不懂得可以去我博客里看看。
		t+=s[idx]; // 统计 n 二进制下 1 的数量。 
		n>>=1; // 也是位运算，等价于 n/=2 。 
	}
	if(t>k){
		cout<<"NO";
		return 0;
		// 特殊情况 1 ，之前介绍过了 qwp 。 
	}
	// 接下来是本代码的重点：将 n 中的 2 的幂数量增多。
	k-=t;
	while(k--){ // 前已经有了 t 个 2 的幂，先在还需要 k-t 个幂，每次只增加一个。 
		while(a[idx]==0) idx--; // 找到当前最大的 2 的幂。
		s[idx]--;
		s[idx]+=2; // 模拟 “推”的过程。 
	}
	cout<<"YES"<<endl;
	for(int i=0;i<=l;i++){
		for(int j=1;j<=a[i];j++){ // 第 n 为是多少就要输出 a[n] 个 2 的 n-1 次方。 
			cout<<(1<<i-1); // 位运算，等价于 1*(i-1)*2 ,但不同的是 i-1 为 0 时，也会输出 1 。 
		}
	}
	return 0; // 完美结束！ 
}
```