## 题意

给定 $n$ 个字符串 $s_i$，每个字符串有一个权值 $w_i$。

定义一个函数 $f(s,t)$ 表示 $t$ 在 $s$ 中的出现次数。

$q$ 次操作，支持将 $w_i$ 区间加/区间覆盖，询问一个字符串 $T$ 和 $l,r$，求 $\sum_{i=l}^{r}f(T,s_i)w_i$。

## 题解

作者并没有真正实现过这个算法，可能算法存在一定问题，如有问题请指出（轻喷）。

首先观察到区间推平并不是很好维护，考虑用一个珂朵莉树来处理。具体来说，每次将一段区间 $(l,r,v)$ 推平成为 $v'$ 可以转化成将 $[l,r]$ 加上 $v'-v$。可以证明这样转化后操作总数仍然是 $O(n)$ 的，因为任意一次操作最多使总转化操作增加三。

由于这里有区间加操作且没有保证数据随机，不能直接用 set，可能要手写一棵平衡树来支持区间加的操作。~~不过据说数据是随的~~。

这部分复杂度为 $O(n\log n)$。

接下来考虑建出 AC 自动机，记录每次询问每次匹配到的所有点（匹配点个数是 $|L_i|$ 的）。显然查询 $[l,r]$ 可以差分为查询 $[1,r]$ 的值减去 $[1,l-1]$。

如果我们给每个串的终止节点编一个号，那么一次询问等于询问一个点到根路径上编号 $\leq k_i$ 的点的权值和。当然串有可能相等，这个特殊处理一下即可。

这样题意转化为：给你一棵树，点有编号，支持将 $[l_i,r_i]$ 中的点 $+v_i$，查询一个点到根路径上所有编号 $\leq k_i$ 的权值和。

感觉不是很能 $n\text{ polylog } n$ 的样子，考虑 [APIO 桥梁](https://www.luogu.com.cn/problem/P5443) 的套路：将询问修改离线，每 $B$ 个分为一块。

考虑对于块内，暴力处理每个修改对询问的影响。可以用可持久化线段树统计出一个点到根路径上小于某个编号的点的个数，那么一次修改对一个询问的影响可以在 $O(\log n)$ 时间处理，复杂度 $O(nB\log n)$。

其实可以大力将所有操作离线，按 dfs 序处理所有查询，那么实际上有 $O(nB)$ 次查询操作但是只有 $O(n)$ 次修改操作，直接值域分块即可做到 $O(nB+n\sqrt n)$。

对于块间，我们记录一个差分数组，每过一个块就暴力从上往下更新一遍所有点的值，这部分复杂度 $O(\frac{n^2}{B})$。

取 $B=n$，可得复杂度为 $O(n\sqrt n)$。

后面瓶颈部分理论常数极小，且代码量不大。代码量主要在于第一部分。