[$\texttt{\color{gold}更好\color{black}{的阅读体验}}$](https://www.cnblogs.com/coros-trusds/)

容易看出考察基环树（或者说“环套树”）的熟练运用。

### 变量解释：

| 变量名称 | 解释 |
| -----------: | -----------: |
| $c_i$ | 第 $i$ 个卫星调整接收源的所需花费 |
| $in_i$ | 指向点 $i$ 的边的编号 |
| $out_i$ | 从点 $i$ 延出的边的编号 |
| $vis_i$ |  $vis_i = 0$ 时未访问；$vis_i = 1$ 时已访问但没在环上；$vis_i = 2$ 时为在环上的点  |
| $fa_i$ | 原本指向点 $i$ 的点的编号 |
| $loop_i$ | 环上的点 |



### 题目大意

> 给出一个有向图，求把这个有向图变成一个环的最小代价。

### 思路分析

对于一个基环树森林，我们将其分为几个独立的基环树，每一棵基环树把权值最大的取除，所有操作全部完成之后，再把已经不完整的基环树们连成一个环即可。

特别地，找到一棵基环树之后，如果一棵基环树的环的点数正好有 $N$ 个，那么它已经满足条件是一棵基环树了，直接输出 $0$ 即可，否则 #$4$ 和 #$7$ 会出错。

------------

整个程序分为主函数、深度优先遍历和找环。

### 找环

选定一个需要深入的点 $u$。

1. 如果点 $u$ 未被访问，则显示访问此节点，并且依次访问指向此节点的点。

2. 如果点 $u$ 已被访问，那么将其放入环中，并且标记为环中的节点，并且依次访问指向此节点的点。

这是一个找环的过程，目的是找出环为接下来的 dfs 做准备。

### dfs

对于一个节点 $u$，访问其出边所连接的点，对其进行遍历。

这个步骤是为了找出价值最大的那条边，然后割掉它。

```cpp
inline void dfs(int u,int fath)
{
	if(vis[u]==0)
	{
		vis[u]=1;
	}
	
	for(register int i=head[u];i;i=node[i].nxt)
	{
		int v=node[i].v;
		
		if(v!=fath && vis[v]!=2)
		{
			dfs(v,u);
			
			if(c[out[u]]>c[i])
			{
				sum+=c[i];
			} 
			
			else
			{
				sum+=c[out[u]];
				
				out[u]=i;
			}
		}
	}
}
```

[完整代码戳这里](https://www.cnblogs.com/Coros-Trusds/p/15098995.html)