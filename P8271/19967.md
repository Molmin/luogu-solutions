题目大意  
给定一个由字符 'C'，'O' 和 'W' 构成的字符串 s，允许两种操作：删除两个相邻且相等的字符或者选择一个字母将其替换为另外两个字母的任一排列。回答 $Q$ 个询问，第 $l$ 到第 $r$ 个字符组成的子串能否通过若干次操作变为单个字符 'C'。  

思路  
注意到字符串 s 的长度不超过 $200000$，询问个数 $Q$ 同样不超过 $200000$。所以 $O(|s|\times Q)$ 做法肯定会超时。尝试对字符 'O' 进行操作：  
```
O-->CW-->CCO-->O
O-->CW-->COC
O-->CW-->OWW-->O
O-->CW-->WOW
O-->WC-->OCC-->O
O-->WC-->COC
O-->WC-->WWO-->O
O-->WC-->WOW
```
观察发现如果相邻两个字符不同则可以将其转换成三者中的另一个字符，如果相邻两个字符相同则可以将其一同删除。字符的相对顺序并不影响转换且转换可逆，即一个字符 'C' 可以视为一个字符 'O' 和一个字符 'W'，一个字符 'O' 和一个字符 'W' 也可以视为一个字符 'C'。  
对三种字符出现的个数预处理出一个前缀和，用于快速统计区间 $[l,r]$ 中每种字符出现的个数。如果字符 'O' 和字符 'W' 奇偶性相同则可以将其全部转换为字符 'C'，看能否最终转换成奇数个字符 'C'，如果字符 'O' 和字符 'W' 奇偶性不同则注定无解。时间复杂度为 $O(|s|+Q)$。

代码如下
```cpp
#include<bits/stdc++.h>
using namespace std;
string st;
long long n,Q,l,r,A,B,C,nc[200010],no[200010],nw[200010];
bool p;
int main(){
	cin>>st>>Q;
	n=st.size();
	for(int i=0;i<n;i++){
		nc[i+1]=nc[i];
		no[i+1]=no[i];
		nw[i+1]=nw[i];
		if(st[i]=='C')nc[i+1]++;
		if(st[i]=='O')no[i+1]++;
		if(st[i]=='W')nw[i+1]++;
	}
	for(int i=1;i<=Q;i++){
		cin>>l>>r;
		A=(nc[r]-nc[l-1])%2;
		B=(no[r]-no[l-1])%2;
		C=(nw[r]-nw[l-1])%2;
		if(A==1 && B==0 && C==0){
			cout<<"Y";
            continue;
		}
		if(A==0 && B==1 && C==1){
			cout<<"Y";
            continue;
		}
		cout<<"N";
	}
	return 0;
}

```