为方便,$c[i][j]$表示$C_{i}^{j}$,$a/b$表示$floor(a÷b)$(即$\frac {a}{b}$的整数部分)。
## 翻译有误
跑了一下样例,发现题面不对,仔细查看原题目后才知道翻译确实错了,应该是杨辉三角第$(n+1)$行不能整除p的个数。
## 进制转换
根据位值原理,可以知道,$p$进制下从右往左数第$i$个的权值为$a×p^{(i-1)}$($a$为这个数位上的数,所以$0<=a<p$)。

由$0<=a<p$可得,左边的权值一定大于右边的权值,所以每个数都是不可替代的。每一位的值就是舍掉右边的数(即除以$p^{i}$模$p$的余数。(若不理解,可以以$10$进制为例自行操作一下)

然后就可以表示为$sum\{a/p^{i}\%p\}$
## 组合数
$c[i][j]$表示从$i$个物品选$j$个的方案总数。

$c[i][j]=c[i-1][j]+c[i-1][j-1]$。

证明:当选取元素1时,共有$c[i-1][j-1]$种(总个数和选择个数都少了1)

当不选取元素1时.共有$c[i-1][j]$种。(只有总个数-1)

而杨辉三角的状态转移方程也是这个,所以杨辉三角就转化为了组合数。
## lucas定理

$c[i][j]\%p=c[i/p][j/p]×c[i\%p][j\%p]$\(p为质数)\(证明自行百度)

## 题解核心部分

观察lucas定理,$c[i/p][j/p]$可以接着递归得到$c[i/p/p][j/p/p]×c[i/p\%p][j/p\%p]$。所以最终得到的是将i,j分解为p进制后的每一位相乘。

∵$p$为质数。(已知) ∴因子只有$1,p$。

而×1却起不到任何作用,只用讨论$p$。

所以必须其中有一个数是$p$的倍数才能整除,要避免这种情况。

然后刚才分解出来的进制数$n$的每一位一定小于$p$(因为都模了$p$),所以不可能为$p$的$1$以上倍。所以就只能是$0$。

然后就只用避免什么时候$0$的问题了。

一个组合数是否为$0$,关键在于取的物品是否超过总数。所以$c[i][j]$中i一定小于$j$。

要避免此情况,所以$0<=j<=i$,然后很容易知道共有$(i+1)$种情况。

由小学奥数可得,分步用乘法原理。

然后题目变为:把$n$转化为$p$进制,统计(每一位+1)的积。
```cpp
#include<iostream>
using namespace std;
int Main(int n,int p){
	int sum=1,i;
	for(i=n;i;i/=p){
		sum=sum*(i%p+1)%10000;
	}
	return sum;
}
int main(){
	int i,n,p;
	for(i=1;;i++){
		scanf("%d %d",&p,&n);
		if((!n)&&(!p)){
			return 0;
		}
		printf("Case %d: %04d\n",i,Main(n,p));
	}
	return 0;
}
```