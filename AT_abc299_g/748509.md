## 题目描述

有一个长 $N$ 的序列，保证其中包含 $1 \sim M$，请你找到一个长 $M$ 的子序列，使得其中每个数字都出现了一次，并使得排列的字典序最小。

## 分析

由于题目保证一定出现过 $1 \sim M$，所以我们放心的考虑贪心策略即可。

我们以一个栈来存储最终答案。由于输出时需要用到栈中间的元素，所以我们手写一个栈。定义 $s_i$ 表示栈中的第 $i$ 个元素，$tt$ 表示当前栈顶元素在栈中的位置。

假设我们已经处理好了前 $i-1$ 个元素的顺序，但是它不一定是最终的最优答案，但一定是当前的最优答案。那么，如果来了一个新元素 $a_i$，我们该如何处理这个元素呢？

如果 $a_i$ 在当前的栈中已经出现过，不做考虑，退出当前轮的抉择。

下面的讨论都建立在 $a_i$ 不在当前栈中的基础上。

如果 $a_i > s_{tt}$，也就是 $a_i$ 比当前的栈顶元素要大，那么显然要将 $a_i$ 插入栈顶。因为题目要求排列的字典序最小，所以越大的元素就要越往后放，所以把当前的更大的元素放到后面。

否则，如果 $a_i < s_{tt}$，那么此时放入不一定是当前最优解，所以还要分情况讨论。

如果当前的栈顶元素在后面有过出现，那么此时可以放心的把栈顶元素删掉，并把 $a_i$ 插入栈中。同理，如果删掉之后仍然满足这个条件，可以循环删除。

反之，如果当前的栈顶元素在后面没有出现，那么也就不存在更优的解法，直接放入栈中即可。

## 代码

```cpp
#include <iostream>

using namespace std;

const int N = 2e5 + 10;

int n, m, a[N], s[N], tt, d[N];		// s 表示栈，tt 表示当前栈顶的位置，d[i] 表示 i 数字出现的次数 
bool st[N];		// st[i] 表示 i 数字是否在当前的栈中 

int main()
{
	// 读入 
	cin >> n >> m;
	
	for (int i = 1; i <= n; i ++ )
	{
		cin >> a[i];
		d[a[i]] ++ ;		// a[i] 出现的次数多 1 
	}
	
	for (int i = 1; i <= n; i ++ )
	{
		d[a[i]] -- ;		// 这个数字出现过了一次 
		if (st[a[i]]) continue;		// 如果这个数字在当前的栈中，不做处理 
		while (s[tt] > a[i] && d[s[tt]]) st[s[tt]] = 0, tt -- ;	
		// 如果当前的栈顶元素在后面有过出现，那么此时可以放心的把栈顶元素删掉，并把 a[i] 插入栈中
		
		s[ ++ tt] = a[i];
		st[a[i]] = 1;
	}
	
	for (int i = 1; i <= m; i ++ ) cout << s[i] << ' ';			// 输出栈中元素 
	
	return 0;
}
```
