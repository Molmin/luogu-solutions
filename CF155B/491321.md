可以发现,如果两张牌可以获得的分数分别为 $a_1,a_2$，能获得的出牌次数为 $b_2,b_1(b_1=0)$，如果 $b_1>b_2$，那么我们肯定先出第 $2$ 张牌。因为如果 $b_2>b_1$ 的话 $b_2$ 肯定大于 $0$，也就是我们可以把两张牌都出了，获得的分数就为 $a_1+a_2$；但如果我们出第 $1$ 张牌，那就只能获得 $a_1$ 的分数，显然比 $a_1+a_2$ 要小。

也就是说，我们需要尽量先打出能获得最多出牌机会的牌，即 $b$ 最大的牌，因为只要我们保证出牌次数不为零，就有机会出那些 $a$ 比较大的牌，这样一定是最优的。

那么做法就是我们对牌堆进行排序，能带来出牌次数越多的牌排在越前面，如果能带来的出牌次数一样的话，就按获得的分数进行从大到小排序。最后在排完序的牌堆中模拟一下出牌过程即可。

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
struct card{//p 记录分数，o 记录能获得的出牌次数
	int p,o;
}a[1005];
int n,ans,c1=1,c2;//c1 位当前能出牌的次数，c2 表示手上剩的牌的数量
bool cmp(card x,card y){
	if(x.o==y.o) return x.p>y.p;
	return x.o>y.o;
}
signed main(){
	scanf("%d",&n);
	c2=n;
	for(int i=1;i<=n;++i) scanf("%d%d",&a[i].p,&a[i].o);
	sort(a+1,a+n+1,cmp);
	for(int i=1;i<=n;++i){
		ans+=a[i].p;
		c2--;//每出一张牌，出牌机会减一；剩余牌数减一。
		c1--;
		c1+=a[i].o;//出牌机会加上排上对应的 o。
		if(!c1 || !c2) break;//如果剩余牌数或出牌机会等于零，就退出循环
	}
	printf("%d",ans);
	return 0;
}
```
