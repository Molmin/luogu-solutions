### 解题思路：

又是一道卡特兰数变体，提供一种和其他题解都不一样的推导方法（应该也算是常见的一种）。

考虑将所有的收 $10$ 元操作视为向右上移动一个单位，将所有的收 $20$ 元找 $10$ 元视作向右下移动一个单位。

那么整个方案数就是从一开始的 $(0,k)$ 走到 $(n+m,k-m+n)$，其中走过的路径一定不能碰到 $y=-1$ 这一条线，这样的总方案数是从 $n+m$ 个操作里选择 $n$ 个操作（或者 $m$ 个操作）：$C_{n+m}^{n}$（或者 $C_{n+m}^{m}$）。这些方案里包含了可行的和不可行的。

然后像一般的卡特兰数推导一样，将所有碰到的线向下翻折，得到不可行方案数，也就是在 $n+m$ 个操作里选择 $n+k+1$ 个操作（或者 $m-k-1$） 个操作，得到：$C_{n+m}^{n+k+1}$（或者 $C_{n+m}^{m-k-1}$）。

这样一来，可行的方案就是 $C_{n+m}^{n}-C_{n+m}^{n+k+1}$，除以所有可能的方案数得到：$1-\dfrac{C_{n+m}^{n+k+1}}{C_{n+m}^{n}}$。

化简一下，立刻有：$1-\dfrac{n!m!}{(n+k+1)!(m-k-1)!}$，直接一个循环搞定。

---
### 代码：

```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
long long n,m,k;
double ans;
int main(){
	scanf("%lld%lld%lld",&n,&m,&k);
	if(m>n+k){
		printf("0");
		return 0;
	}
	ans=1;
	for(int i=0;i<=k;i++){
		ans*=(double)(m-k+i)/(double)(n+i+1);
	}
	printf("%.6lf",max(1-ans,0.0));
	return 0;
}
```
