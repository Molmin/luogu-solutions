这里就说说我思考这道题的方法吧，就当是个总结了

---
首先这题很明显是一道DP，但是似乎二维不太好做，我们可以先考考虑一维的情况，即为

**给定一个n个正整数的序列，从这个序列中选出一个r个数的子序列，使得这个子序列的分值最小(分值指其相邻元素的差的绝对值的和的最小值)，并输出这个分值。**

这个问题容易了许多，设$f[i][j]$表示在其前i个数中选择j个（且选的数中包括第i个），组成的子序列中分值最小值是多少。那么动态转移方程很显然是：

#### $f[i][j]=min(f[k][j-1]+abs(a[i]-a[k]))(i>k>=j-1)$

注意这里$k>=j-1$

最终结果就是$min(f[i][r])(n>=i>=r)$

这样的时间复杂度就是$O(n^2k)$

---
一维的情况考虑完了那我们再回来看看原题，是否可以设计出一个相似的状态呢，要不先设$f[a][b][c][d]$表示前a行b列,已经选了c行d列组成的子序列分值最小是多少，但是似乎不太好转移？那换一种思路看看...

再回头看看上面写的那个一维的方程
#### $f[i][j]=min(f[k][j-1]+abs(a[i]-a[k]))(i>k>=j-1)$
它和二维的情况有什么联系呢，等等，如果把选出来的子矩阵第$i$行(第$i$列也可以)的所有同行元素的差的绝对值的和看作上面子序列的中第$i$个数，那状态和状态转移方程不就和上面的方程一样了么。

但是怎么知道每一行选了那些数，也就是选了哪几列，那枚举试试看吧，似乎也找不到更优秀的办法了

最后把 所有同行元素的差的绝对值的和 和 任意两行之间的分值还可以预处理一下就好了

状态转移方程和其他大佬的差不多这里就不列出了

这样最差时间复杂度就是$O(C(16,8)* 16^3)$，大概是五千多万，这样就通过了这道题

---
个人觉得这道题还是值得蓝题的难度的。

最后希望这篇题解对大家有所帮助，谢谢。