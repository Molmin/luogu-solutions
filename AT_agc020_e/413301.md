[link](https://www.luogu.com.cn/problem/AT3859)

## 前言

此篇博客主要补充说明和细节

题意简化：

求 $S$ 包含的字符串被压缩后得到的不同字符串总数量，

当一个字符串 $T$ 被字符串 $S$ 包含，

当且仅当 $|T|=|S|$ 且 $S$ 为 $0$ 的位置 $T$ 也为 0 。

## 思路

一眼望去要么是区间 dp 要么是数位 dp ，

数位是没可能的，那只能是区间 dp 。

~~但是我模拟赛考场写了一个贪心结果假了。~~

设一个数组 $dp$ ，其中 $dp_s$ 表示对于 $01$ 串 $s$ （没错，参数是一个字符串），其包含的字符串被压缩后得到不同字符串的总数量。


那么对于 $s$ 的最后一个字符 $c$ ，拆成两部分看：参与压缩与不参与压缩，

如果 $c$ 不参与压缩，那么得到的数量 $sum1$ 满足下式：

$$

sum_1=
\begin{cases}
dp_{s-c} & S[c]=0\\
dp_{s-c}\times 2 & S[c]=1
\end{cases}
$$

其中 $s-c$ 即为 $s$ 去除最后一位所得的字符串。

注意到当 $S[c] =1$ 时 $sum_1=dp_{s-c\times}2$ 是因为此时被 $S$ 包含的字符串 $T$ 在此位有 $0$ 和 $1$ 两种选择。

如果 $c$ 不参与压缩，那么枚举 $s$ 最后一个循环节的长度 $l$ 。

每当枚举到一个长度为 $l$ 的压缩串 $t$ 与其在 $s$ 尾部往前数的次数 $k$ ，

参加压缩得到的数量 $sum_2 +=dp_t \times dp_{s-t\times k}$ ，

最后 $dp_s=sum_1+sum_2$ ，

考虑用记忆化搜索实现。

## 实现

现在，我们需要把遇到的困难解决。

1. 怎么存字符串

因为 $n\le 100$ ，可以使用 `__int128` 状态压缩。

2. $dp$ 数组空间开不下

发现很大一部分情况都被排除掉了，导致了空间的极大浪费，

所以考虑用 $map$ 储存，设 $map_{i,j}$ 表示当前处理到了第 $i$ 位，字符串状态为 $j$ 的压缩数量，代替 $dp_j$ 发挥作用。

现在，你可以愉快的去写代码了！

我的代码就不放了，状态压缩写得比较鬼畜。。。
