~~我真的不想调格式啊啊~~

> 给定一个二元组序列$(a_i,b_i)$,多次询问形如$(c_i,d_i)$,求$i$的个数使得$a_i\bigoplus c_i\leqslant \min\{b_i,d_i\}$

考场上完全不会$b$小的部分分~~

- 区间为$[1,n]$

	- 所有的$\min$均由$d_i$取到

	用$c_i$在Trie树上游走，假设走到$x$,这个高位是$1$，必定存在一边使这一位为$0$,累加这一边遍历次数，走另一边，否则高位为$0$，直接走异或起来为$0$的那边即可

	- 所有的$\min$均由$b_i$取到

	让$a_i$能取到$\leqslant b_i$的$c_i$在$\mathrm{Trie}$树上是一些不交的子树内的标记点，具体来说跟上一个Sub一样假装用$a_i$作为$c_i$来游走，其中会涉及到一些`必定存在一边使这一位为 0 `的选择，把这些子树打上标记(真的打在根处)，以后用$c_i$遍历时累加经过标记即可
   - 一般情况
   
   考虑把$(a,c),(b,d)$丢在一起按$b/d$从大到小排序，按序处理即可
- 区间为$[l,r]$
	
    首先差分掉转为前缀$[1,i]$，然后问题变成了计算顺序的维护，一个Naive的想法是使用树套树，考察问题本质是要让每个询问被出现时间更早的修改更新到，这是一个偏序问题，考虑CDQ分治，具体的，先按照$b/d$排序，对每个分治区间两侧按照位置排序，之后双指针
    - 左边修改右边询问 :$\min$由$b_i$取到
    - 右边修改左边询问 :$\min$由$d_i$取到
    
	  按照最初的手段处理即可