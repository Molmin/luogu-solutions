先为大家献上翻译···

暑假结束了，毕业了。奶牛们正在找工作。农场主约翰知道后，鼓励奶牛们四处碰碰运气。而且他还加了一条要求：一头牛在一个城市最多只能赚D（1≤D≤1000）美元，然后它必须到另一座城市工作。当然，它可以在别处工作一阵子后又回到原来的城市再最多赚D美元。而且这样的往返次数没有限制。

城市间有P（1≤P≤150）条单向路径连接，共有C（2≤C≤220）座城市，编号从1到C。奶牛贝茜当前处在城市S（1≤S≤C）。路径i从城市A\_i到城市B\_i（1≤A\_i≤C，1≤B\_i≤C），在路径上行走不用任何花费。

为了帮助贝茜，约翰让它使用他的私人飞机服务。这项服务有F条（1≤F≤350）单向航线，每条航线是从城市J\_i飞到另一座城市K\_i（1≤J\_i≤C，1≤K\_i≤C），费用是T\_i（1≤T\_i≤50000）美元。如果贝茜手中没有现钱，可以用以后赚的钱来付机票钱。

贝茜可以选择在任何时候，在任何城市退休。如果在工作时间上不做限制，贝茜总共可以赚多少钱呢？如果赚的钱也不会出现限制，就输出-1。

【输入】

第一行：5个用空格分开的整数D，P，C，F，S。

第2到第P+1行：第i+1行包含2个用空格分开的整数，表示一条从城市A\_i到城市B\_i的单向路径。

接下来F行，每行3个用空格分开的整数，表示一条从城市J\_i到城市K\_i的单向航线，费用是T\_i。

【输出】

一个整数，在上述规则下最多可以赚到的钱数。



好，然后就是思路了

我的想法是Bellman\_ford（松弛ing）

关键代码1

```cpp
dist[S]=-D;
    for(i=1;i<C;i++)
    {
        flag=true;
        for(j=1;j<=C;j++)
            for(k=1;k<=G[j].sum;k++)
                if(dist[G[j].E[k].v]>dist[j]+G[j].E[k].w)
                {
                    dist[G[j].E[k].v]=dist[j]+G[j].E[k].w;
                    flag=false;
                }
        if(flag)
            break;
    }
    flag=true;
    for(j=1;j<=C;j++)
        for(k=1;k<=G[j].sum;k++)
            if(dist[G[j].E[k].v]>dist[j]+G[j].E[k].w)
            {
                flag=false;
                break;
            }
    if (flag==false)
    {
        cout<<-1;
        return;
    }
    for(i=1;i<=C;i++)
        s=min(s,dist[i]);
    cout<<-s;
```
bellman\_ford过程记得dist要memset成无穷大(0x7f即可)

关键代码2(读入)

```cpp
for(i=1;i<=P;i++)
    {
        cin>>a>>b;
        G[a].E[++G[a].sum].v=b;
        G[a].E[G[a].sum].w=-D;
    }
    for(i=1;i<=F;i++)
    {
        cin>>a>>b>>w;
        G[a].sum++;
        G[a].E[G[a].sum].v=b;
        G[a].E[G[a].sum].w=-D+w;
    }
```
想必大家都懂了吧，祝大家AC！
