我来写一下我自己的做法。   

规定：字符串中左边是小的、前面；右边是大的、后面；字符串位置从1标起。

1. 题意：   
	给定字符串 ` S ` 和字符串 ` T ` ，求 在 ` S ` 中选择 **若干个（至少一个）** 互不相交（**不能有重复** 选的位置，但 **可以有空选** 位置）的 **包含 ` T ` 的** **子串** ，有 **多少种** 不同的选法。（这题翻译好像出了点问题。。。）   
	- 对样例 #3 的解释：（中括号里的是所在位置）  
    - ` S ` : $ \mathtt{d_{[1]}d_{[2]}d_{[3]}} $   
    - ` T ` : $ \mathtt{d} $   
    - 方案：$ \{\mathtt{d_{[1]}}\} $，$ \{\mathtt{d_{[1]}d_{[2]}}\} $，$ \{\mathtt{d_{[1]}d_{[2]}d_{[3]}}\} $，$ \{\mathtt{d_{[2]}}\} $，$ \{\mathtt{d_{[2]}d_{[3]}}\} $，$ \{\mathtt{d_{[3]}}\} $，$ \{\mathtt{d_{[1]},d_{[2]}}\} $，$ \{\mathtt{d_{[2]},d_{[3]}}\} $，$ \{\mathtt{d_{[1]},d_{[3]}}\} $，$ \{\mathtt{d_{[1]},d_{[2]}d_{[3]}}\} $，$ \{\mathtt{d_{[1]}d_{[2]},d_{[3]}}\} $，$ \{\mathtt{d_{[1]},d_{[2]},d_{[3]}}\} $。

1. 思路：   
	考虑字符串 ` S ` 中的每一个字符 $ s_i $，如果我们知道 所有选法中 **所选的最后一个字符串 的结尾在 $ [1,i-1] $ 中 的数量 $ sum $** ，以及 **以位置 $ i $ 开头的字符串中 包含 ` T ` 的最早位置 $ x $** ，那么依据题意，我们可以发现，可以选择所有 **单个字符串** $ s_{i...x}, s_{i..x+1}, ..., s_{i...n} $ （因为都包含 ` T `），同时可以在选择这其中的任意一个串的时候 **一并加上** 之前的 $ sum $ 种选法的 **任意一种** （因为不重叠）。   
    例如， ` S ` 是 $ \mathtt{aaaabcaa} $， ` T ` 是 $ \mathtt{abc} $，在位置 $ 3 $ 开始向后选单个字符串只有 $ \{\mathtt{aabc}\} $，$ \{\mathtt{aabca}\} $，$ \{\mathtt{aabcaa}\} $ 是符合要求的。    
    例如， ` S ` 是 $ \mathtt{abaabaa} $， ` T ` 是 $ \mathtt{ab} $，在位置 $ 3 $ 开始向后选单个字符串只有 $ \{\mathtt{aab}\} $，$ \{\mathtt{aaba}\} $，$ \{\mathtt{aabaa}\} $ 是符合要求的；而在位置 $ 3 $ 前面有方案 $ \{\mathtt{ab}\} $，于是方案 $ \{\mathtt{ab},\mathtt{aab}\} $，$ \{\mathtt{ab},\mathtt{aaba}\} $，$ \{\mathtt{ab},\mathtt{aabaa}\} $ 也符合要求。    
    例如， ` S ` 是 $ \mathtt{abaab} $， ` T ` 是 $ \mathtt{ab} $，在位置 $ 4 $ 开始向后选单个字符串只有 $ \{\mathtt{ab}\} $ 是符合要求的；而在位置 $ 4 $ 前面有方案 $ \{\mathtt{ab}\} $，$ \{\mathtt{aba}\} $，于是方案 $ \{\mathtt{ab},\mathtt{ab}\} $，$ \{\mathtt{aba},\mathtt{ab}\} $ 也符合要求。    

1. 做法：   
	考虑先用 kmp（或 hash）得出 ` T ` 在 ` S ` 中的所有匹配位置，设为 $ [l_{1...tot},r_{1...tot}] $ 。（这点不会的自己去[P3375 【模板】KMP字符串匹配](https://www.luogu.com.cn/problem/P3375)）   
    这时，可以发现每个位置 $ i $ 后的第一个 $ l_j $ 对应的 $ r_j $ 即为前面所说的最小位置 $ x_i $，所以我们先预处理出 $ x_{1...n} $。   
    然后是关键部分，即怎样维护一个 “所选的最后一个字符串结尾在 $ [1,i-1] $ 中的数量 $ sum_i $” 。我们发现，假如我们知道 所有位置 $ j \in [1,i-1] $ 的 $ sum_j $ 以及 $ x_j $ 我们可以更新出所有最后一个串从 $ j $ 开始的方案（如上2.）。这样，从 $ 1 $ 更新到 $ i-1 $ 就一定可以得出在 $ i $ 之前结束（因为在 $ i $ 之前开始）的所有方案。而得到在一个位置结束的方案数显然的办法是每次更新在相应位置加上方案数（将这个结果记为 $ a_{1...n} $，则为 $ a_k = a_k + sum_j + 1 (k \in [x_j,n]) $）。这样，由于后面不会向前更新，在 $ i-1 $ 位置结束的方案数必定已全部得出，则 $ sum_i = sum_{i-1}+a_{i-1} $。显然 $ sum_1 = 0 $，所以 $ sum_{2..n+1} $ 可求，而 $ sum_{n+1} $ 即为答案。   
    由于上面的过程实际为将 $ [x,n] $ 位置记录的数值加上 $ sum + 1 $，所以我们可以使用差分轻松解决（原理一样是只从前向后更新，不影响前面计算好的结果）。    
    时间复杂度 $ \mathbf{O}(n) $。

实际代码实现如下：
```cpp
#include<cstdio>
const int N=1e5+10,p=1e9+7;
int n,m,c[N],nxt[N],x[N],sum;
char s[N],t[N];
int main()
{
    int i,j;
    do s[1]=getchar(); while(s[1]<=32);
    for(n=0;s[n+1]>32;n++)s[n+2]=getchar();
    do t[1]=getchar(); while(t[1]<=32);
    for(m=0;t[m+1]>32;m++)t[m+2]=getchar();
    //读入
    for(nxt[0]=-1,i=1;i<=m;nxt[i++]++)
        for(nxt[i]=nxt[i-1];(~nxt[i])&&t[nxt[i]+1]!=t[i];nxt[i]=nxt[nxt[i]]);
    for(i=1,j=0;i<=n+1;i++,j++)
    {
        if(j==m)x[i-m]=i-1;
        if(s[i]!=t[j+1])  for(j=nxt[j];(~j)&&s[i]!=t[j+1];j=nxt[j]);
    }
    //kmp（也可以 hash ，但我觉得 kmp 好写）
    for(x[n+1]=n+1,i=n;i;i--)
    if(!x[i])x[i]=x[i+1];
    //求x[i]
    for(i=1;i<=n;i++)
    {
        c[x[i]]=(c[x[i]]+sum+1)%p;//差分
        c[i]=(c[i]+c[i-1])%p;//求a[i]
        sum=(sum+c[i])%p;//sum[i] -> sum[i+1]
    }
    printf("%d\n",sum);
    return 0;
}
```