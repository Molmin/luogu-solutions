### 题目翻译
有一天，爱丽丝正在清理她的地下室，她注意到了一件非常奇怪的事情：一大堆木头！每一块由五块方形瓷砖组成，四块瓷砖与第五块中央瓷砖相邻：

![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1150B/ad6ce0df252a3db4eebc7f2ae8f0d041a8339ee0.png)

在碎片旁边放着一块大的方形木板。该板分为 $n^2$ 排列成 $n$ 行和 $n$ 列的单元。一些牢房已经被贴在上面的瓷砖占据了。剩下的细胞是自由的。爱丽丝开始怀疑她是否能用找到的碎片填满黑板。当然，每一块必须正好覆盖板上的五个不同的单元，没有两块可以重叠，并且每一块都应该完全适合板，没有一些部分位于板边界之外。然而，这块木板太大了，爱丽丝无法手工铺瓷砖。你能帮我确定是否可以完全平铺木板吗？
### 题目大意
给你一个由 `#` 和 `.` 组成的点阵图，求可以通过若干个不重复覆盖的“十字形”来补充所有的 `.`，问能否把所有 `.` 覆盖完？
### 分析题目
这道题的思路大体是一个贪心。

最后的答案是每个 `.` 都要变成 `#` 于是我们可以每次找到一个 `.` 并对其进行修改。那么问题来了，按照什么顺序找 `.` 呢？
因为每个 `.` 都是要到达的所以直接从左上到右下找就行了，而且这样找到的每一个没有被更改的点都在十字的最上方。


然后对于每一个 `.` 看从它往下建一个十字有没有障碍 `#`，如果没有障碍就覆盖一个十字（要不然当前这个点就没有机会改了）。

### 注意细节

1. 数组下标问题：枚举每一个点 $c_{x, y}$ 时这个点一定在 $1 \le x < n - 1$ 和 $1 < y \le n-1$ 范围内。
2. 枚举时请注意下标为负数的情况。

### code
```cpp
#include <iostream>
#include <cstdio>
using namespace std;
int n, cntx[6] = {0, 1, 1, 1, 2}, cnty[6] = {0, -1, 0, 1, 0};
string s[55];
bool search(int x, int y)
{
	if(x < 0 || x >= n - 2 || y <= 0 || y >= n - 1)
		return false;
	for(int k = 0;k < 5;k++)
		if(s[x+cntx[k]][y+cnty[k]] == '#')
			return false;
	return true;
}
int main()
{
    cin >> n;
    for(int i = 0;i < n;i++)
        cin >> s[i];
    for(int i = 0;i < n;i++)	//注意统一下标
    {
        for(int j = 0;j < s[i].size();j++)
        {
        	if(s[i][j] == '#')
        		continue;
            if(search(i, j))
            {
            	for(int k = 0;k < 5;k++)
            		s[i+cntx[k]][j+cnty[k]] = '#';		//这两行相当于5个if
			}
            else		//如果放不了就不用再找了
            {
                cout << "NO";
                exit(0);
            }
        }
    }
    cout << "YES";
    return 0;
}
```