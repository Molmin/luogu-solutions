## 题意
给出一个由“#”和“.”组成的点阵图，求可以通过若干个不重复覆盖的“十字形”来补充所有的“.”，问能否把所有“.”覆盖完？
## 思路
从左上角开始遍历，把它转化成一个 $01$ 构成的二维数组，“.”转化成 $1$，剩下的是 $0$，再遍历一次，只要碰到 $1$ 就检查该点向下做一个十字是否都为 $1$，如果不是就一定覆盖不全结束，否则把十字都变成 $0$，继续，最后如果都填平没有结束过程序就可以。
```cpp
#include <bits/stdc++.h>
using namespace std;
int z[55][55];
int main()
{
	int s1 = 1 , s2 = 0 , s = 0 , a , b , i , h;
	char x;
	cin >> h;
	for ( int j = 1; j <= h; j++ )
	{
		for ( int i = 1; i <= h; i++ )
		{
			cin >> x;
			if ( x == '.' )
			z[i][j] = 1;//转化成二维数组
		}
	}
	for ( int f = 1; f <= h; f++ )
	{
		for ( int k = 1; k <= h; k++ )
		{
			if ( z[k][f] == 1 )
			{
				if ( z[k][f] && z[k - 1][f + 1] && z[k][f + 1] && z[k][f + 2] && z[k + 1][f + 1] )//找是否有十字
				z[k][f] = z[k - 1][f + 1] = z[k][f + 1] = z[k][f + 2] = z[k + 1][f + 1] = 0;//更改
				else
				{
					cout << "NO\n";//不行结束
					return 0;
				}
			}
		}
	}
	cout << "YES\n";//行
	return 0;
}
```