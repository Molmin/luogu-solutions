初看以为是状压，再看觉得是 DFS，结果...

爆搜就可以了！可不能对不起 $3 \leq n \leq 50$ 的数据范围，$O(n^2)$ 是能过的！

根据题目，十字架是这样子的图形：

```
#.#
...
#.#
```

具体做法有两种：

- 首先都把字符转化成数字，# 转化成 $0$，而 $.$ 转化为 $1$。

- 第一种是找十字架最上面的那个点，如果这个点连同他下面的点无法组成十字架就输出 NO，否则就把下面连同它自己归零。如果搜完没有出现这种情况（不用再去搜一遍，因为前面已经把所有的点遍历一遍了，如果有剩下的点肯定已经输出 NO 了），就直接输出 YES。

- 第二种是看这个点的四周是不是都是点，如果是就一起归零。最后再搜一遍，如果有剩余的点那么输出 NO，否则输出 YES。

这里只给第一种做法的代码，如果感兴趣的话可以尝试第二种。

CODE：
```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
int a[114][514],i,j;//恶臭数组
int main(){
	int n;
	scanf("%d",&n);
	for(i=1;i<=n;i++)
	for(j=1;j<=n;j++)
	{
		char x;
		cin>>x;
		if(x=='.')a[i][j]=1;//字符串转数字
	}
	for(i=1;i<=n;i++)
	{
		for(j=1;j<=n;j++)
		if(a[i][j]==1)
		{
			if(a[i+1][j]&&a[i+1][j-1]&&a[i+1][j+1]&&a[i+2][j])//判断十字架
			a[i][j]=a[i+1][j]=a[i+1][j-1]=a[i+1][j+1]=a[i+2][j]=0;//归零
			else
			{
				printf("NO");
				return 0;
			}
		}
	}
	
	printf("YES");
	return 0;
}
```