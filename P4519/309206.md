首先不得不说:**这道题不是很难**

**BUT,他没有翻译**

~~于是他很难~~

为了帮助大家着手解决这道题,我来翻译一下:
# 题目描述:
**现在是降临节。N米长的街道上有M个路灯（街道的米用1到N之间的数字表示）。每一盏灯都会点亮它所在街道的米数，并在该位置的左右两侧各亮K米。换句话说，如果灯光位于X米处，它将照亮从X-K到X+K的所有米的街道，包括X-K。当然，一米的街道有可能被多个路灯照亮。所有的灯都有不同的位置。
问题是，有一种可能性是，路灯并没有照亮整条街道的N米。你的任务是确定需要安装的最小数量的额外灯光（位置从1到N），以便照亮整条街道**

# 输入格式:
**输入的第一行包含数字N（1≤N≤1000）。
第二行输入包含数字M（1≤M≤N）。
第三行包含数字K（0≤K≤N）。
下面的M行中的每一行都包含一个数字。这些数字按升序排序，代表每个M路灯的位置
位置将与间隔[1，N]不同。**
# 输出格式:
**你必须按照任务中输出所需的数字** 
# 题目分析:
看见这一句了吗:"你的任务是确定需要安装的最小数量的额外灯光（位置从1到N），",尽量以最少的灯发出最亮的光

哦没错，这就得用到"贪心算法"

贪心算法:举个例子，比如有一堆钱，你肯定拿一张100元的，不会拿一张1毛钱的
.核心思想就是获取最大利益

比如说这个地方的市长，十分吝啬，为了省电不希望有灯光交织的地方

所以需要每隔一段所需距离，才有一盏灯，贪心是这么用的

转回题目，两盏灯之间的没有灯的区域（假设有，特判即可）为$pos $-$K$-$last$-$1pos$−$K$−$last$−$1$

一盏灯可以照亮自己的位置，左边KK格以及右边KK格，共计2K+12K+1格


# 代码:
```
#include<iostream>
#include<cstdio>

using namespace std;

int ans;
int n,m,k;

bool flag[1005];

void move(int x)
{
	for(int i=max(x-k,1);i<=min(n,x+k);i++)
		flag[i]=true;
	return ;
}

int main()
{
	scanf("%d %d %d",&n,&m,&k);
	for(int i=1,x;i<=m;i++)
		scanf("%d",&x),move(x);
	for(int i=1;i<=n;i++)
		if(!flag[i]) move(i+k),ans++;
	printf("%d\n",ans);
	return 0;
}
```
求过啊~



