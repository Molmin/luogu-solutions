## 题意简述

给你一个由`*`和`.`组成的字符串，要求替换掉其中一部分`*`为`x`，要求如下：

1. 必须替换掉第一个`*`和最后一个`*`
2. 替换后，每两个相邻的`x`之间的距离**不能大于** $k$（位置 $i$ 和位置 $j$ $(i<j)$ 的距离是$j-i$）

我们想让替换的个数尽可能少。求替换的个数。

## 题目分析

我们要让替换的个数尽可能少，可以让每两个相邻的`x`的间距尽可能大。但题目中已经限制了两个相邻`x`的最大值，我们就要在这个限度内达到最大。**形式化地讲**，对于每一个位置为 $i$ 的`x`，我们想让下一个`x`的位置为满足 $j\le i+k$ 的 $j_{max}$（当然位置$j$必须是个`*`）

### 明显是个贪心啊！

于是我们考虑将所有`x`**离散化**，然后用`upper_bound`找到第一个 $j\gt i+k$ 的 $j$，然后它的**前一个**就一定是最后一个满足 $j\le i+k$ 的值。这道题的解法就呼之欲出啦~

```C++
#include<iostream>
#include<algorithm>
#define N 50
using namespace std;

int pos[N];  // 离散化数组
int main() {
    string s;
    int q, n, k, l, cnt; cin >> q;
    while (q--) {
        // cnt赋值为1是因为题目要求取最后一个，要人工把它算上
        cin >> n >> k >> s, cnt = 1, l = 0;
        for (int i=0; i<n; i++) 
            if (s[i] == '*') pos[l++] = i;  // 离散化
        for (int i=0; i<l-1; cnt++)  // i<l-1是为了人工避开最后一个
            // 找出[i+1,l)中第一个大于pos[i]+k的位置，减一得到最后一个小于pos[i]+k的
            i = upper_bound(pos+i+1, pos+l, pos[i]+k) - pos - 1;
        cout << cnt << endl;
    }
    return 0;
}
```

>  代码里面有一个点要强调一下，第二个循环中要求`i<l-1`是因为，题目要求最后一个要取到，但是循环算到这里的时候就可能会出现一个问题，`upper_bound`已经找不到大于 $pos[i]+k$ 的数了。那么我们就规避掉这个问题，要求它不管最后一个了，而在前面人工给`cnt`加 $1$。