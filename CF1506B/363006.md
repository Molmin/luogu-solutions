## 一道模拟水题

这道题只要模拟有一点基础的人都能做得出。

首先，题目说明保证有解，则字符串里只有一个 ```*``` 时，答案就为 $1$，或者说，当第一个 ```*``` 的位置和最后一个 ```*``` 的位置相同的时候，答案就为 $1$。那么字符串里只有两个 ```*``` 的时候，答案必为 $2$，或者说，第一个 ```*``` 的位置到第二个 ```*``` 的位置小于等于 $k$ 时，答案为 $2$。

上面这段应该都知道，接下来讲难的了。

按照贪心思想，应该改离上一个 ```*``` 最远的但是距离在 $k$ 以内一个 ```*```。这样，才能使改的 ```*``` 最少，因为每一个 ```*``` 都有可能影响后面的 ```*```，只有在距离范围的边缘，才能使下一个 ```*``` 尽量远，改的次数越小。

基础知识讲完了，代码该怎么写呢？

关于代码，只要求出第一个 ```*``` 和最后一个 ```*``` 的位置，再设立无限循环，只要当前 ```*``` 的位置加 $k$ 大于**等于**终点的位置就可以跳出循环，而在循环中只要找距离上一个 ```*``` 最远的 ```*``` 但是距离又不超过 $k$ 的就可以了。

## 代码

文字是讲不清代码的，还是要结合代码理解：

```cpp
#include<bits/stdc++.h>

using namespace std;

int t;

int main(){
	cin >> t;
	while(t--){
		int sum = 2, sx, fx, n, k;
		cin >> n >> k;
		string s;
		cin >> s;
		for(int i = 0; i < s.size(); i++){   //找第一个*的位置
			if(s[i] == '*'){
				sx = i;
				break;
			}
		}
		for(int i = s.size() - 1; i >= 0; i--){  //找最后一个*的位置
			if(s[i] == '*'){
				fx = i;
				break;
			}
		}
		if(sx == fx){   //如果只有一个*
			cout << 1 << endl;
			continue;
		}
		if(fx - sx <= k){  //如果有两个
			cout << sum << endl;
			continue;
		}
		while(true){
			int x = sx + k;
			if(x >= fx){  //当当前*的位置距离最后一个*的距离小于等于k
				break;
			}
			for(int i = x; i >= sx; i--){  //寻找离上一个*最远但是距离在k以内的*
				if(s[i] == '*'){
					sx = i;
					break;
				}
			}
			sum++;  //修改次数+1
		}
		cout << sum << endl;  //一定要有换行
	}
	return 0;
}
```
