## 题意：
在一个字符串中， '*' 号可以被修改为 'x'，但修改后的字符串要满足任意两个 'x' 之间距离不能大于 $k$，同时第一个星号和最后一个星号必须改变。现给定字符串长度 $n$ 和 最大距离 $k$ ，求使得字符串满足条件所改变的字符的最小个数。

## 思路：
首先，题目说明**保证有解**，则字符串里只有一个 * 时，答案就为 $1$。那么字符串里只有两个 * 的时候，答案必为 $2$。

**贪心思路：**

修改离上一个 * 最远的但是距离在 $k$ 以内一个 *，能使改的 * 数最少。因为每一个 * 都会影响后面的 *。在距离范围的边缘修改，能使下一个 * 尽量远，改的次数尽量小。

**关于代码：**

求出第一个 * 和最后一个 * 的位置，当当前 * 的位置加 $k$ **大于等于**终点的位置就可以跳出循环，而在循环中只要找距离上一个 * 最远且距离又不超过 $k$ 的 * 就可以了。

## AC代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
int t, p1, p2, n, k;
int main() {
    cin >> t;
    while(t--) {
        string s;
        int sum = 2;
        cin >> n >> k >> s;
        for(int i = 0; i < s.size(); i++)//找第一个*的位置
            if(s[i] == '*') {
                p1 = i;
                break;
            }
        for(int i = s.size() - 1; i >= 0; i--)//找最后一个*的位置
            if(s[i] == '*') {
                p2 = i;
                break;
            }
        if(p1 == p2) {//如果只有一个*
            cout << 1 << endl;
            continue;
        }
        if(p2 - p1 <= k) {//如果只有两个*
            cout << 2 << endl;
            continue;
        }
        while(1) {
            int x = p1 + k;
            if(x >= p2)//当前*的位置距离最后一个*的距离小于等于k
                break;
            for(int i = x; i >= p1; i--)//寻找离上一个*最远但是距离在k以内的*
                if(s[i] == '*') {
                    p1 = i;
                    break;
                }
            sum++;//修改次数++
        }
        cout << sum << endl;//一定要有换行
    }
    return 0;
}
```
