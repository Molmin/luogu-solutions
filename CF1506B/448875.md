### 题意：
有一个长度为 n，由 * 和 . 组成的字符串。

你可以把字符串里 * 改变为 x，必须满足每两个 x 之间的距离小于等于 k。

不过，你必须把它的首尾两个 * 改变为 x。

x 的数量大于等于 1，且一定有解。

请输出在满足题意的前提下，最少的改变次数。
### 思路：
我们可以定义两个变量来存储当前点到上一个 x 的距离和离当前点最近的合法的 * 。

在与上一个 x 的距离大于 k 后，我们的试探结束了。

于是，返回到最近的 * 并把它变为 x ，刷新与上一个 x 的距离。

以此类推，就可以满足改变次数最小。

简而言之，就是找到里上一个 x 距离最远的 * 并把它变为 x。

这么做，可以使任意两个相邻 x 的距离和最短，此贪心毫无疑问是正确的。
### 实现：
我们可以找到首尾两个 * 并把它们改变为 x，每次改变答案加一。

结束之后，判断答案是否小于 2。如果小于 2，那么证明 * 的数量一定是 1，直接输出即可。

如果没有，按照上述贪心思路从头到尾寻找结果，然后计算并输出即可。
### 代码：
```c
#include<iostream>
using namespace std;
int t;//数据数 
int n,k;//长度与最长差 
char mus[600];//一个用来存放'.','*','x'的数组 
int cha;//第i个点到上一个x的差 
int las;//上一个* 
int ans;//答案 
int s,e;//第一个*与最后一个* 
int main(){
	cin>>t;
	while(t--){
		cin>>n;
		cin>>k;
		for(int i=1;i<=n;i++){
			cin>>mus[i]; 
		}
		ans=0;
		for(int i=1;i<=n;i++){//找出第一个* 并把它变为x 
			if(mus[i]=='*'){
				mus[i]='x';
				ans++;
				s=i;
				break;
			}
		}
		for(int i=n;i>=1;i--){//找出最后一个*  并把它变为x 
			if(mus[i]=='*'){
				mus[i]='x';
				ans++;
				e=i;
				break;
			}
		} 
		if(ans<2){//如果只有一个*那么直接输出不多废话 
			cout<<ans<<endl;
			continue;
		}
		cha=0;
		las=0;
		for(int i=s;i<=e;i++){ 
			if(cha>k){//如果与上一个x的差大于k就回到最近的*并把它变为x，重置与上一个x的差 
				mus[las]='x';
				cha=i-las;
				ans++;
			}
			if(mus[i]=='*'){//如果当前点是*且与上一个x的距离小于等于k那么就把它作为要变为x的点 
				las=i;	
			}
			cha++;//增加与上一个x的差 
		}
		cout<<ans<<endl;
	}
	return 0;
}
```
