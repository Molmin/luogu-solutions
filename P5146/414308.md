## 思路
此题当然可以在线更新区间内的最大值，最小值，再求所有区间最大值中最大的，但是这样未免麻烦了，下面有一个新思路：

如果可以只记录最小值以及最大的差，不断在线更新这两个，是否更加方便呢？这是一个新的思路。

我们可以从前往后扫一遍 $a_j$，其中若想使得当前差最大，且 $0 \leq i < j$，那么 $a_i$ 应当取 $[a_0,a_j]$ 这个区间的最小值,可以使差取到最大。

于是，这里就涉及到我们提到的两个在线维护的变量了：  
1. 最小值：当遍历到一个更小的 $a_j$ 时，更新。
2. 当不是最小值更新，即有可能产生更大的差，此时的差如果比原有最大差更大，则更新。
3. 若都不符合，则不执行操作。

## code
此处提醒：最好变量是 ```long long``` 类型，以防越界；另外用来记录最大差的 ```maxn``` 的初值要赋得足够小，否则 #13 测试点会出现一时间难以发现的问题。
```
#include<bits/stdc++.h>
using namespace std;

long long res, maxn = -0x3f3f3f3f3f3f3f3f, n, pre; 
//之前也有题解在此处出现了问题，原因是maxn的初值还不够小，开long long也是为了保险 
int main() 
{
	cin >> n >> pre;//自动认为第一个输入的数组元素为最小值 
	for (int j = 2; j <= n; ++j) 
	{
		cin >> res;//从2开始到n的数组元素 
		if (maxn < res - pre) maxn = res - pre;//maxn不断和当前区间最大比较，在线更新 
		if (res < pre) pre = res; //更新最小值 
	}
	cout << maxn;
	return 0;
}
```
