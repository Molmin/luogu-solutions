首先是帮大家翻译一下本题的含义：

Bessie不小心游荡出Farmer John的田地，而走进了相邻的农民的地里。她举起一个木瓜，木瓜对奶牛来说可是不可多得得美味。这个木瓜林像一般的威斯康星州的田地一样被分割成一个R行C列的网格(1 <= R <= 40, 1 <= C <= 40)。Bessie可以从一个格沿着一条跟X轴或Y轴平行的直线走到邻接的另一个格。Bessie发现一开始她自己在木瓜林的(1,1)，也就是第一行第一列慢悠悠地咀嚼着木瓜。

Bessie总是用她最信赖地双筒望远镜去数每一个邻接的格里挂着的木瓜的数目。然后她就游荡到那个有最多没有被吃掉的木瓜的邻接的格子（保证这样的格子只有一个）。

按照这种移动方法，最终Bessie总是会在(R,C)停止然后吃掉那里的木瓜。

给定这个木瓜林的大小及每个格的木瓜数F\_ij(1 <= F\_ij <= 100), 要求Bessie一共吃了多少个木瓜。

输入格式：

第一行2个分离的整数R,C（我这里是n,m）

第2行开始的i+1行表示一个二维数组表示这个木瓜丛林第i,j处有多少个木瓜

（我这里是用a数组表示）

输出格式，一个数表示她吃的木瓜数量

说明：

一个三行；四列的木瓜从林。

Bessie开始在左上角的“3”。

Bessie吃木瓜的字母顺序如下面的号码所示：

(1,1) ---> (1,C)

(1,1) 3a 3 4g 5h (1,C)

| 4b 5c 3f 2i |

(R,1) 1 7d 4e 2j (R,C)

(R,1) ---> (R,C)

她拒绝吃4的木瓜但访问所有的方格后最终吃掉39个木瓜。

【解析】

来一发用坐标增量的题解（可以更加让人理解）

const dx:array[1..4]of integer=(-1,0,+1,0);//表示她周围的木瓜的x坐标增量

dy:array[1..4]of integer=(0,+1,0,-1);//表示她周围的木瓜的y坐标增量

```cpp
var ans,i,j,n,m:longint;
    a:array[0..40,0..40]of longint;//木瓜林
procedure dfs(x,y:longint);//表示她现在到达的地方
var i,max,px,py:longint;
begin
 if (x=m)and(y=n) then exit;//到达目的地
 ans:=ans+a[x,y];//吃掉位于(x,y)的木瓜（当前地点）
 a[x,y]:=0;////当前地点的剩余木瓜为0
 max:=0; px:=0; py:=0;//px表示她四周最大木瓜数格子的x坐标增量，py表示她四周最大木瓜数格子的y坐标增量
 for i:=1 to 4 do
  if (max<a[x+dx[i],y+dy[i]])then//取四周木瓜的最大值和最大坐标增量
  begin
   px:=dx[i]; py:=dy[i];
   max:=a[x+dx[i],y+dy[i]];
  end;
 dfs(x+px,y+py);//dfs找下一个点
 end;
begin
 readln(m,n);
 for i:=1 to m do
  for j:=1 to n do read(a[i,j]);
 dfs(1,1);
 writeln(ans+a[m,n]);//不要忘记吃终点的木瓜
 a[m,n]:=0;////当终点的剩余木瓜为0（有始有终的好孩子）
end.
```