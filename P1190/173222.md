小学生又来发题解啦！

想必各位dalao都把这道题看复杂了，其实本题只要掌握想法，写起程序就非常easy了.

### 立刻进入正题——

首先，我们理解了题目，哪个人装完水之后，就轮到队伍的下一个人来接水.So,下一个来接水的人，一定是去**当前装水的m个人中最快的那个人的位置**继续装水.

Then,我们就可以从第m+1个人开始帮他找位置（PS：为什么不是从第一个人开始？因为前m个人已经在装水了，他们的位置随便定（写程序的时候不用管））.因为要去速度最快的那个人的位置，所以，**到那个位置装水的人的时间之和**也是最短的！

那么，我们就可以利用数组中前m个位置来储存相对应位置接水的人时间之和.这样的话，每次就可以先找m个接水位置中，当前时间之和最短的来装水（即把a[i]加到a[1]（当前总用时最短的位置）），就OK啦.

最后，再看一下前m个位置中那个用的时间是最短的，cout就可以完成啦！

#### 下面是代码——
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cmath>
#include<string>
#include<cstring>

using namespace std;
long long n,m;
int a[10010];
bool cmp(int x,int y)
{
	return x>y;//从大到小排序的函数
}
int main()
{
	scanf("%I64d%I64d",&n,&m);
	for(int i=1;i<=n;i++)
		scanf("%d",&a[i]);//输入每个人装水的时间
	for(int i=m+1;i<=n;i++)//从第m+1个人开始给TA找位置
	{
		sort(a+1,a+1+m);//sort一下，看看哪个位置总用时最短
		a[1]=a[1]+a[i];//找到之后，把第i个人的时间加上去就好啦（代表那个人已经装完水了）
	}
	sort(a+1,a+1+m,cmp);//最后看一下哪个位置用时最长
	cout<<a[1];//输出最长的那个位置就perfect啦
return 0;
}

```
这道题本蒟蒻就是这样子做的啦，各位dalao有什么问题的话，在右边评论区告诉我哦，下次再见~~