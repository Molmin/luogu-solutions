# P1190 【接水问题】
### 思路：
首先，我写这道题用的不是纯暴力模拟，而是改进后的模拟，时间大概是暴力模拟的二分之一   ~~也就是二分啦~~ 
### 具体做法：
用一个指针模拟现在排队排到谁了，也就是next，然后，寻找现在打水序列【也就是数组b】中的最小值MIN，找出来，那么这个打水序列最快可以在MIN的时间内腾出空位，留给下一位打水者next，从而实现二分的效果。时间复杂度是o(n*2m)      
但是纯暴力模拟的话，则时间复杂度为
### o(nm*ans),至于ans的大小，就决定了你模拟的时间复杂度
### 下面贴代码，千万别抄哦！
代码可能不好看，不喜勿喷
```cpp
#include <bits/stdc++.h>
int a[10005];
int b[105];
using namespace std;
int main(){
	int i,j,k,n,m,sum=0,ans=0,next;
	cin>>n>>m;
	next=m+1;
	for(i=1;i<=n;i++)
		cin>>a[i];
	for(i=1;i<=m;i++)
		b[i]=a[i];//这里的是模拟正在打水序列(水龙头占用中的序列)
	while(sum!=n){
		int MIN_=0x7ffffff;//每次循环赋初始值为INF
		for(i=1;i<=m;i++)
			MIN_=min(MIN_,b[i]);//找打水序列最小值
		for(i=1;i<=m;i++){
			b[i]-=MIN_;//打水序列减去最小值
			if(b[i]==0&&next<=n)b[i]=a[next],next++;//模拟指针后推
            //b[i]=a[next]填补空位
		}
		ans+=MIN_;//答案加上这个打水序列中的最小值，模拟经过的时间
		sum++;
	}
	sort(b+1,b+1+m);
		ans+=b[m];//有可能还有人没打完谁就退出循环了，所以要加上最大值
	cout<<ans;
	return 0;
}
```
写题解不容易，还希望大家给个赞，不喜欢也请大家不要喷

谢谢！