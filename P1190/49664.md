
### 方法：暴力模拟，一秒一秒地算。
### 详解：
#### 1.需要开的数组：每个人的接水时间(t[ ])以及当前使用水管接水的人还要接的秒数(p[ ])。
#### 2.每一秒钟需要做什么：
#### 1)将每个水管剩余时间减一。
#### 2)如果发现有人接完了（水管剩余时间为零）则从等待的队伍里找出下一个人来接水。
#### 3)记录有几人接完水以及等待的队伍里的人数，当等待的队伍里没有人且所有人全部接完水时，跳出循环，输出秒数。
#### 3.复杂度：
#### 时间复杂度O(n^2)；
#### 空间复杂度O(n)。
### 代码：

```cpp
#include<cstdio>
using namespace std;
int t[100010]/*每个人接水所用时间，有多少人开多大，time*/,p[100010]/*每个水管上当前使用人的剩余接水时间，有多少水管开多大，pipe*/;
int main()
{
	int n,m,i,j,k,a,b,c=0;
    //input
	scanf("%d%d",&n,&m);
	for(i=1;i<=n;i++)
	scanf("%d",&t[i]);
    //initialization
	for(i=1;i<=m;i++)
	p[i]=t[i];
    /*首先将前m个人依次放到水管1,2,...,m上*/
	b=n;a=m;
    /*b记录有多少人没接完水，a表示前a人已经开始或结束接水*/
    //the CORE code
	while(1)/*暴力的while(1)，第一层循环*/
	{
		c++;
        /*记录这是第几秒*/
		for(i=1;i<=m;i++)/*枚举每一个水管，第二层循环*/
		{
			p[i]--;
            /*将这个水管的p[]数组减一（剩余时间减一）*/
			if(p[i]==0)/*如果发现有人接完了*/
			{
            	/*再放上下一个人*/
				if(a+1<=n)/*如果等待的队伍里还有人*/
				p[i]=t[++a];/*就把这个空水管放上这个人*/
				b--;/*接完水的人多一个，也就是没接完水的少一个*/
			}
		}
		if(a==n&&b==0)break;/*跳出循环的条件，详见上方文字*/
	}
    //output
	printf("%d\n",c);
	return 0;
}
```
### 注：
#### 细心的朋友们可能会发现：如果这个水管空了，它的p[ ]值应该是零，如果此时等待的队伍里为空，那下一次循环的时候不就多算了一个(b--)吗？别担心，注意一下这句话：
```cpp
	while(1)
	{
		c++;
		for(i=1;i<=m;i++)
		{
			p[i]--;//就是这句
			if(p[i]==0)
			{
				if(a+1<=n)
				p[i]=t[++a];
				b--;
			}
		}
		if(a==n&&b==0)break;
	}
```
#### 如果这一次循环p[i]==0，那么下一次循环在判断之前就已经p[i]--了，p[i]就是-1了，也就不会作为p[i]==0进入判断，也就不会重复b--了。
### 希望能给大家提供一点思路，感谢洛谷能让我发表自己的浅见！