~~求求管理员dalao们过了我的题解吧qwq~~（逃）

本蒟蒻刚读题的时候还以为要求接水时间的最小值   
~~然而只有二十分qwq~~

~~经过我多次审题之后~~，最后，我发现这个题并没有要求最小值，而只是按照序号来接水，~~这就好办了呀~~

首先，我们先按题目要求读入数据，此处的r是指剩下没有接到水的小盆友的位置，那么我们先用一层循环找出现在正在接水的小盆友中最快能接完的那一个，很显然，我们可以用下一个要接水的小盆友的时间加到他的身上，然后清空下一个要接水的小盆友的时间，这样，到最后的时候，从第m+1个小盆友开始，到第n个小盆友，他们接水的时间都被我们加到前m个小盆友身上去了，**大家可以想象成当一个小盆友接完水以后，后面马上有一个小盆友让他帮忙打水**，然后我们将前m个小盆友此时的接水时间排序，当然这里的cmp是我以为求最小时间时候写的，可以删去，然后将输出改成w[m],这一趟的排序目的是求前m个小盆友接水时间的最大值，即总的接水时间

~~这个题还是很不算很难的~~，下面放代码


------------
	#include<bits/stdc++.h>

	using namespace std;

	int n,m,ans=-1;

	int w[10010];

	bool cmp(int a,int b)

	{

	return a>b;

	}

	int main()

	{

	//	freopen("in.txt","r",stdin);

	//	freopen("out.txt","w",stdout);

	scanf("%d%d",&n,&m);

	for(int i=1;i<=n;i++)

	scanf("%d",&w[i]);

	int r=m+1;

	while(r!=n+1)

	{

		int minn=9999999,num=0;

		for(int i=1;i<=m;++i)
	
		if(w[i]<minn) minn=w[i],num=i;

		w[num]+=w[r++];

		w[r-1]=0;

	}

	sort(w+1,w+1+m,cmp);

	printf("%d",w[1]);

	return 0;

	}