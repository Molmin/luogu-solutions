```cpp
/*
	本蒟蒻的欧拉路径做法，请大家看完别喷
	本人能力还有待提高
	谢谢
	仔细看过题目的人会发现本题目其实并不是很难 
	要注意的是每一条边都要走一次（只有一次，而每个点可以重复走） 
	我们可以用欧拉路的方法做（欧拉路指遍历图的每一条边，不懂人可以上网查一下欧拉路）
	然后一个难点是要以排序最小输出 
	其实我们可以找到一个最小的起点（0个度为奇数找最小（欧拉回路），2个度为奇数找最小的一个奇数点（欧拉路）） 
*/
#include<bits/stdc++.h>//蒟蒻的万能头文件 
using namespace std;
int n;
int g[1010][1010];//记录g的俩个下标的关系 
int du[100000];//记录下标的度 
int ans[100000];//记录答案 
int ss;
int s=1000000,d=1000000;
void find(int x)
{
    for(int i=1;i<=500;i++)//因为排序要最小 ，所以从小往大找 
    if(g[x][i])//如果有路就走，因为数据保证有解所以不用回溯等判断 
    {
        g[x][i]--;//x,i之间少了一条路 
        g[i][x]--;
        find(i);
    }
    ans[ss--]=x;//当我们找完所有路再存入数组 
}
int main()
{
    cin>>n;
    ss=n+1;//输出f+1行 
    for(int i=1;i<=n;i++)
    {
        int a,b;
        cin>>a>>b;//a,b连接 
        g[a][b]++;//表示a，b的连接关系（a,b之间可能不止一条边） 
        g[b][a]++;
        du[a]++;
        du[b]++;//度也变大 
        s=min(s,min(a,b));//找回路情况的最小 
    }
    for(int i=1;i<=500;i++)
    if(du[i]&1)//位运算做法，比正常做法快一些，相当于du[i]%2==1。 
    {
        d=min(i,d);//找是否有奇数点，并找其中最小 
    }
    if(d<1000000)//如果d变了为非回路 
    { 
        find(d);
    } 
	else//为回路 
    { 
		find(s);
    } 
	for(int i=1;i<=n+1;i++)
        cout<<ans[i]<<endl;
    /*
	这是本人第一次提交题解
	如有不到位的地方请多多包涵
	再次谢谢您耐心的看完本蒟蒻的题解 
	*/ 
}
```