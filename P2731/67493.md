## ~~第一次写绿题题解，各位大佬见谅QwQ~~

---

$\color{blue}\text{蒟蒻先来说说欧拉回路：}$

~~以下废话极多，巨佬们可以跳过~~

欧拉回路，是~~窝们伟大的~~欧拉巨佬在$1736$年发现的一个很有趣的东西。

在东普鲁士哥尼斯堡，有一条大河，河中有两个小岛。全城被大河分割成四块陆地，河上架有七座桥，把四块陆地联系起来，见以下~~抽象~~图：

![](https://cdn.luogu.com.cn/upload/image_hosting/fsx0obkl.png)

这时候人们就想：“能否从某地出发，不重不漏地走过每一座桥梁后回到原点呢？”

欧拉在经过几番思索，将七桥转化为下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/aq65tiw6.png)

进而把问题转化为：

> 能否笔不离开纸，一口气画成整个图形，且一条线段只能经过一次。

显然是不可能的。

## 为什么？


> ~~即得易见平凡，仿照上例显然，留作习题答案略，读者自证不难~~


因为，对于一个不是终点也不是起点的点来讲，我们从一条路走到它时，必须由另外一条路走出去：

![](https://cdn.luogu.com.cn/upload/image_hosting/a3t5mnsa.png)

对于点B，窝们从A进入B后，必须有一条与之对应的路，以便走出B。每经过一次B，就要出去一次。**所以，与B(这里代指所有非起点和终点的点)连接的线段数必须为偶数。**

回到七桥问题，窝们可以看到，途中每一个点都是有奇数条线段相连，因此走进一个点就出不来了，所以七桥问题最终答案是：不能。

---

于是乎，窝们所学习的OI知识内，多了一个名词：

## 欧拉回路

而满足欧拉回路的图有如下要求：

1. 连通。~~废话~~
2. 所有点的度(就是与这个点相连的线段的总数)都为偶数。

更多关于欧拉回路的知识请

[点这里](https://www.cnblogs.com/abc1604831024/p/9077112.html)

[或这里](https://baijiahao.baidu.com/s?id=1594654125138224284&wfr=spider&for=pc)

---

好的，再让窝们康康题面，有这么一句话：

 他讨厌骑马，**因此从来不两次经过一个栅栏**。你必须编一个程序，读入栅栏网络的描述，并计算出一条修栅栏的路径，**使每个栅栏都恰好被经过一次**。


~~很显然，这是一道欧拉回路的题目。~~

---

解决欧拉回路，有$Fluery$和$Hierholzer$算法，由于~~窝不会Fluery算法~~$Hierholzer$算法使用更加广泛，所以窝们就用$Hierholzer$吧。

$Hierholzer$，说通俗一点就是深搜，先找好起点，然后对于每一个经过的点，遍历它所有可以到达的点，然后一点点枚举，待到回溯的时候，将经过的点记录下来即可。这里重点说说找起点。

找起点其实不难，上面说过，**所有非起点&终点的点的度都必须是偶数**，又因为题目说必定有解，所以**窝们只需找到度为奇数的点即可**。

那万一全部点都是偶数呢？

~~反之亦然同理，推论自然成立~~

**那我们就找一个编号最小的点呗**，因为只要所有点的度都为偶数，那么我们从任何一个出发都有解。而题目说让我们找一个$500$进制表示法最小的一个（其实就是字典序最小的一个，~~不过出题人为了装|3，写的很玄乎~~），那肯定就是找编号最小的点嘛。QwQ

---

说了这么多，上代码吧。。。

```cpp
#include<cstdio>
#include<iomanip>
#include<stack>
using namespace std;
const int N=1301;

int G[N][N];
int a[N];
stack<int> s;//定义储存答案的栈，由于我们在回溯的时候存的答案，因此所储存的答案是反着的，在最后我们将其倒过来输出
int m,x,y;
int mine=0x7f7f7f7f;//定义编号最小的起点

void hierholzer(int u)
{
    for(int i=1;i<=500;i++)//枚举编号1——500的农场
    {
        if(G[u][i])//如果编号为i的农场与编号为u的农场相连通
        {
            G[u][i]--;//标记这条路走过了
            G[i][u]--;
            
            hierholzer(i);//继续 深搜（划掉）hierholzer
        }
    }
    s.push(u);//回溯时把当前点加进栈
}
int main()
{
	scanf("%d",&m);
	for(int i=1;i<=m;i++)
	{
		scanf("%d%d",&x,&y);
		G[x][y]++;//由于可能会有重边，窝们采用++的方式而不是=1的方式
        G[y][x]++;
        
        a[x]++;//储存每个点的度
        a[y]++;
        
        mine=min(mine,min(x,y));//由于出题人毒瘤（划掉），编号最小的不一定是1，窝们就得找到编号最小的那个点
    }
    
    int st=mine;//查找度为奇数且编号最小的点
    for(int i=1;i<=500;i++)
    {
    	if(a[i]%2==1)//如果当前点的度为奇数
    	{
    		st=i;//赋值完不用再找了，退出
			break;
		}
	}
	hierholzer(st);//开始 深搜（划掉）hierholzer算法
    
    while(!s.empty())//倒着输出
    {
    	printf("%d\n",s.top());
        s.pop();
    }
    return 0;
}
```

---

PS:代码可能会和一些大佬的雷同，纯属巧合。~~毕竟这题hierholzer就这么一种写法。。。~~

# 完结（撒花）\(^o^)/~