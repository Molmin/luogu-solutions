
一个欧拉路径的模板题，如果有两个奇点的话就是欧拉路，0个就是欧拉回路

用深搜遍历即可

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a,b,h[1025][1025],d[1025],c[1026],cnt;
void xx(int x)
{
	for(int i=1;i<=500;i++)
	if(h[x][i])//表示x-i有路 
	{
		h[x][i]--;//将这条路删除，以免重复 
		h[i][x]--;//同上 
		xx(i);//递归查找 
	}
	c[++cnt]=x;//存值 
}
int main()
{
	cin>>n;//n条相邻的边 
	for(int i=1;i<=n;i++)
	{
		cin>>a>>b;//a,b相邻 
		h[a][b]++;//表示a-b的路的条数 
		h[b][a]++;//同上 
		d[a]++;//算出每个点的度 
		d[b]++;//同上 
	}
	int z=1;//初始值为1，因为可能是欧拉回路，没有奇点，所以可以从任何地方开始搜索 
	for(int i=1;i<=500;i++)//因为最多只有500个顶点 
	if(d[i]%2==1)
	{
		z=i;
		break;//如果这个点的度为奇数的话，那他就是奇点，找到一个就可以结束了 
	}
	xx(z);
	for(int i=n+1;i>=1;i--)//n条边相邻，所以有n+1个点
	//因为是从起点开始，递归查找，所以前面找到的实际上是后面的，所以倒着输出 
	cout<<c[i]<<endl;
} 
```