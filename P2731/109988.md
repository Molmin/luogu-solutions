## 前置技能
在解释这道题前，我认为有必要解释一下欧拉回路和欧拉通路是什么。
### 背景
在18世纪，哥尼斯堡的一个公园里，有七座桥将普雷格尔河中两个岛及岛与河岸连接起来(如图)。问是否可能从这四块陆地中任一块出发，恰好通过每座桥一次，再回到起点？  
![1](https://cdn.luogu.com.cn/upload/pic/57092.png)  
### 证明
这个问题是不可能实现的，我们先把这个地图抽象成一个无向图：  
![2](https://cdn.luogu.com.cn/upload/pic/57095.png)  
除了起点以外，每一次当由一条边进入一个点时，同时也由另一条边离开此点。所以每行经一点时，计算两条边，从起点离开的边与最后回到始点的边亦计算两条，**因此每一个点的度必为偶数。**  然而在这个图里，每个点的度均为奇数，所以无法实现。  
这是当时的大数学家欧拉给出的证明，为了纪念他，我们把**可以从一个点开始遍历，每条边只经过一次且能回到终点的图叫做欧拉回路，可以从一个点开始遍历，每条边只经过一次但不能回到终点的图叫做欧拉通路。**
### 判定
首先，这个图必须是**联通的！**  

欧拉回路：
- 一个所有结点的度都是偶数的无向图。
- 一个所有结点的入度等于出度的有向图。 

欧拉通路:
- 一个有且仅有两个节点的度是奇数的无向图，这两个点可以分别作起点与终点。
- 一个有且仅有两个点，其入度不等于出度，其中一个入度比出度大1，为路径的起点；另外一个出度比入度大1，为路径的终点的有向图。  

掌握了这些，做出这道题就没问题了。
## 做法
提前说一句，我用矩阵存的。
### 读题+解析
题目中总会有很多关键信息~

> 所有栅栏都是连通的(也就是你可以从任意一个栅栏到达另外的所有栅栏)

这个图是连通无向图。

> 输入数据保证至少有一个解。  

这说明我们不用判定这个图是欧拉图。

> John能从任何一个顶点(即两个栅栏的交点)开始骑马，在任意一个顶点结束。

这说明这个图可能是欧拉回路，也可能是欧拉通路，需要写一个判定的算法。  
因为数据范围比较小，像我这种蒟蒻就直接遍历，找奇数点，找到一个就改值，跳出，代码如下：
```cpp
//专门有一个数组是存每个点的度的
void find_start()
{
    for(int i=1;i<=500;i++)//暴力出奇迹
        if(du[i]%2==1)//找到了一个奇数点
        {
                start=i;//改值
                return;//跳出
        }
}
```



>你的程序必须输出骑马的路径(用路上依次经过的顶点号码表示)。我们如果把输出的路径看成是一个500进制的数，那么当存在多组解的情况下，输出500进制表示法中最小的一个 (也就是输出第一位较小的，如果还有多组解，输出第二位较小的，等等)。   

我们要输出骑马的路径……等等，这个五百进制表示法是什么鬼呀！  
理解简单一点：输出路径编号最小的一个。  

至于为什么要提五百进制表示法，~~因为这样在算法标签中就能加一个  _进制_  tag啊(滑稽）~~  

那么这个要求如何去实现呢？咱们分类讨论。  

如果是欧拉回路的话，由于我这里的遍历方式是dfs，只要从第一个点可以保证是最小的，那么路径序号必然是最小的。如果是欧拉通路的话，我们用遍历的方式，能保证第一个找到的点就是最小的。  

### 代码
下面就是代码啦，题目中会有一些坑，在代码里面也会给出注释。
```cpp
#include <bits/stdc++.h>
using namespace std;

int f;
int G[510][510];//存图
int du[510];//存点的度
int start;//存起点
int minnum=0x3f3f3f3f;
stack<int> ans;
//由于我们输出要求是正序输出，
//我个人比较喜欢用栈，方便点。
//当然数组的时空复杂度更为优秀，但是在这道题中可以忽视。

void dfs(int n)//裸dfs
{
    for(int i=1;i<=500;i++)
    {
        if(G[n][i])
        {
            G[n][i]--;
            G[i][n]--;
            dfs(i);
        }
    }
    ans.push(n);//找到就加栈
}

void find_start()//找起点
{
    for(int i=1;i<=500;i++)//直接遍历
        if(du[i]%2==1)//找到一个奇数点
        {
                start=i;//赋值
                return;//跳出
        }
}

int main()
{
    cin>>f;//常规读入
    for(int i=0;i<f;i++)
    {
        int a,b;
        cin>>a>>b;
        G[a][b]++;
        G[b][a]++;
        minnum=min(minnum,min(a,b));
  		//这里是唯一一个能算上坑的点
  		//题目并没有保证最小的标号是1
  		//所以要加个找最小值的判定
        du[a]++;
        du[b]++;
    }
    find_start();
    if(start==0)
        dfs(minnum);
    else
        dfs(start);
        
    while(!ans.empty())//输出
    {
        cout<<ans.top()<<endl;
        ans.pop();
    }
    return 0;		
}
```
