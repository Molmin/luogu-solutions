来简单介绍一下欧拉回路与欧拉路径

1.在一个图中，能从一个点出发，走完所有的边，并且每条边只能走一次，最后回到出发点，这样的路径就叫做欧拉回路，有欧拉回路的路径就叫欧拉图。
在欧拉图中，所有点连接的边都为偶数条。

2.在一个图中，能从一个点出发，走完所有的边，并且每条边只能走一次，这样的路径就叫做欧拉路径（不一定回到起点），有欧拉路径的路径就叫半欧拉图。
在半欧拉图中，有两个点连接的边数为奇数条边（这两个点是路径的起点和终点），其余所有点连接的边都为偶数条。

3.
在题目中，往往需要你判断到底是求欧拉路还是欧拉回路，这时候，你就需要记录下每个点连的边的数量（例如下面代码中的b数组），从而确定dfs的起点。如果所有的点连接的边都是偶数，就可以设置起点为1.

4.求欧拉路径的主要思路是dfs,也可以用栈优化dfs,dfs部分还是比较简单的。不过有一个需要注意的地方就是，在存图和搜索的时候，存入边和删除边都是**双向的**。

5.本蒟蒻在做欧拉函数的模板题中遇到了一个问题，这个输出的路径必须是按字典序从小到大排列，~~但是蒟蒻的我并不会用栈~~，所以我想到了一个方法

例如在一个三个点的环中 我们的程序默认输出 1321
这个输出的原因应该很好理解 就是 我们在循环过程中 是从1到n 的 所以最后输出的是n，所以我开始思考可不可以把循环变成n到1。
经过测试发现输出确实变成了1231，但是在遇上更强的数据时还是会出现一些问题。

```cpp
int f( long i)
{
	int j;
	for (j=500; j>=1; j--)//这是改动过的地方
	if (a[i][j]==1) 
	{
		a[i][j]=0;
		a[j][i]=0;
		f(j);
	}
		s=s+1;
		c[s]=i;
	
}
```
6.
```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
using namespace std;
int f(long i);
int a[1000][1000],b[1000],c[1000],n,m,s=0,t,i,j,y,z;;
int main ()
{
	cin>>n>>m;
	for (i=1; i<=1000; i++)
	  for (j=1; j<=1000; j++)
	  a[i][j]=0;
	for (i=1; i<=m; i++)
	{
		cin>>y>>z;
		a[y][z]=1;
		a[z][y]=1;
		b[y]++;
		b[z]++;
    }
	t=1;
	for (i=1; i<=n; i++)
	{
			if (b[i]%2==1) t=i; 	}
	f(t);
	for (i=1; i<=s; i++)
		cout<<c[i]<<" ";
}
int f( long i)
{
	int j;
	for (j=1; j<=1000; j++)
	if (a[i][j]==1) 
	{
		a[i][j]=0;
		a[j][i]=0;
		f(j);
	}
		s=s+1;
		c[s]=i;
	
}


```