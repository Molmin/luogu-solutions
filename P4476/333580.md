# P4476 [BJWC2018]数字统计

  考试的时候写了个数位 dp，很明显我斜挂了，于是 de 了 3 个小时之后有了这篇题解。。

（看到没有类似的题解，记忆化搜索来一发）

## 算法：

### 数位 dp + 高精度

## 题目描述：

对于一个特定的变换模式，对于变换之后的数为 0 或者为 1 的条件。

## 题目分析：

首先我们需要对于题目进行分析，因为我们首先看到这个题很不好做，所以我们先转化一下题意。

我们可以发现一个很好的性质，只要我们的确定这个数字中第一个 1 的位置在哪里，后面的数字是什么都与我们的答案没有关系了，以为我们的答案在第一个 1 这个位置一定会变成 0 ，然后我们只需要分析前面的 0 的个数的奇偶性就可以了。

于是我们成功地把题意转化成了找到第一个 1 的贡献。那么就很好做了。

那么我们找到了 1 的位置之后怎么进行计算贡献呢？

我们经过手玩之后可以发现下面的结论

```reStructuredText
如果全是 0，没有 1 的情况
那么如果前面 0 的个数为奇数，那么最后的返回值为 0
若为偶数，最后返回值为 1
对于有 1 的情况
前面的 0 的个数为奇数，最后返回值为 1
若为偶数，最后返回值为 0
```

但是对于一些情况需要特判，具体见代码的注释。

于是我们就可以做这个题了。

1、 首先数位 dp 的老套路，进行差分。

2、进行记忆化搜索，我们需要三个状态。当前的位置 pos，以及第一个 1 的位置 st（如果没有出现则为 0），当前的上限的限制 lim。

再套一下我们的板子，于是就可以得到核心的代码了。



```
il i64 dfs(int pos, int st, int lim) （i64 是高精）
{
	
	if(pos > len and st == 0)//如果说当前的全是0，需要把1位数的单独拿出来进行考虑，因为手玩一下发现并不满足那个性质
	{
		if(pos == 2) return q == 0 ? 1 : 0;
		if((pos - 1) % 2 == 1) return q == 0 ? 1 : 0;
		else return q == 1 ? 1 : 0;
	}
	if(pos > len and st)//对应统计答案，同样对于1在最后一位的情况需要单独拿出来考虑
	{
		if(st == pos - 1)
		{
			if((st - 1) % 2 == 0) return q == 1 ? 1 : 0;
			else return q == 0 ? 1 : 0;
		}
		if((st - 1) % 2 == 1) return q == 1 ? 1 : 0;
		else return q == 0 ? 1 : 0;
	}
	if(!lim and dp[pos][st] != -1) return dp[pos][st];
	i64 ret = 0;
	int res = lim ? a[len - pos + 1] : 1;
	for(int i = 0; i <= res; ++i)
	{              
		if(st == 0 and i == 0) //简单的分类讨论
		{
			i64 tmp = dfs(pos + 1, st, lim and i == res);
			ret += tmp;
		}
		else if(st == 0 and i == 1) 
		{
			i64 tmp = dfs(pos + 1, pos, lim and i == res);	
			ret += tmp;
		}
		else
		{
			i64 tmp = dfs(pos + 1, st, lim and i == res);
			ret += tmp;
		} 
	}
	if(!lim) dp[pos][st] = ret;
	return ret;
}
```

这就是这个题的核心了，之后比较恶心的就是高精了，整整卡了我 3 个小时，最后还是用 bitset 高精过掉了这个题。~~vector 高精巨慢~~

[Code](https://www.luogu.com.cn/paste/jdt71r83)