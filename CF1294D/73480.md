这里说一下官方题解中没有详细说明的$O(n)$解法。

先上代码
```cpp
#include <cstdio>
using namespace std;
const int N = 4e5 + 1;

int n, x, y, cnt[N], cntcnt[N], p, q;

int main(){
	scanf("%d%d", &n, &x);
	cntcnt[0] = x;
	for(int i = 1; i <= n; i++){
		scanf("%d", &y); y %= x;
		cntcnt[cnt[y]]--;
		cnt[y]++;
		cntcnt[cnt[y]]++;
		if(!cntcnt[p]) ++p, q = 0;
		while(cnt[q] > p) q++;
		printf("%d\n", p * x + q);
	}
	return 0;
}
```
首先与官方题解一样，因为每个数可以被任意地$±x$更改，我们将数字按照$\%x$后的值归类计数，用$cnt[k]$数组表示；

由于题目是求最小的未出现的数，我们优先将小的位置填满，因此从$0$开始往更大的数去填，可以发现，填$0$到$x-1$时正好从$cnt[0]$到$cnt[x-1]$各取出一个数，而每填进$x$个数，在$cnt$数组中取数的位置又从$0$到$x-1$开始轮回。

因此，使$p$为$cnt[0]$到$cnt[x-1]$中的值的最小值，$q$为使得$cnt[q]=p$的最小下标$q$，那么答案即为$p*x+q+1$。

接下来考虑如何维护$p$和$q$这两个值，用$cntcnt[k]$来记录$cnt$数组的**值**的出现次数。 初始时因为$cnt[0$ ~ $(x-1)]$都等于$0$，所以$cntcnt[0]=x$。那么$p$即为使得$cntcnt[p]>0$的最小下标$p$，$p$的初值为$0$。

由于题目只加数不删数也不会修改数，因此$p$是单调递增的，因此每次当$cntcnt[p]=0$时将$p++$；而当$p$不发生更新的前提下，$q$也是单调递增的，因此每次加数之后执行
```
	while(cnt[q] > p) q++;
```
当$q$发生更新时，先将$p$置为$0$，然后执行上述操作。

最后证明复杂度。设将要加入$n$个数，那么$q$最多更新到$n/x$，而每次$q$更新后$p$最多从$0$移动到$x-1$，也就是移动$x$次，那么$p$的总移动次数最多为$q$的更新次数乘上每次$q$更新后$p$的移动次数，即$n/x*x=n$，所以总复杂度为$O(n)$。