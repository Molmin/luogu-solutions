## 题目大意

新定义：MEX（数列中最小未出现非负整数）

给定 $q$ 次询问，和指定的数 $x$ 。每次可以进行如下操作：

- 把给定的数插入数列中

- 选定数列中的任意数，使其增加或减少 $x$ （可进行多次）

每次询问后进行的操作都会在下一次被重置。需要保证数列中的数一直非负。

## 思路

考场上脑抽了，忘了 $x$ 是给定的...... 既然 $x$ 给定了，而且我们可以对一个数可以任意增加或减少 $x$ 的倍数，那么每一个数对我们有用的部分其实就是 $a_i\mod x$。

只要记录数组中模 $x$ 等于 $0$ ... 到 $x-1$ 的数字的个数就可以了。

对于每一次询问，我们从上一次的答案（最开始为 $0$）开始扫描，如果经过 $ans\mod x$ 时有可用的数字，那么就将记录的值 $-1$，代表我用过了，如果出现了 $ans\mod x$ 最终没有数字可用了，那么 ``MEX`` 就是 $ans$

## 部分代码

```cpp
int main()
{
	int q, x, ans = 0;
	q = rd(); x = rd();
	for(int i = 1; i <= q; ++i)
	{
		int opt = rd();
		vis[opt % x] ++; // 记录添加的数字
		while(vis[ans % x])
			vis[ans++ % x]--; // 这里有压行，实际先计算 vis[ans % x]--，再计算 ans++
		printf("%d\n", ans);
	}
	return 0;
}
```