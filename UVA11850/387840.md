### 1 题意

阿拉斯加公路总长度为 $1422$ 英里，布兰达现在想要开着她的电动车从起点（第 $0$ 英里）跑到终点，再从终点跑回起点。

在公路上有一些充电站（保证起点有一个），电动车的续航是 $200$ 英里。现在，你要根据充电站坐标，告诉她，能不能实现她的目标。

### 2 思路

##### 题意转化

本题可以转化为，每个充电站覆盖它和后面 $200$ 的公路，问可不可以覆盖整条公路（包括去程和回程）。

我们可以将回程公路看成为在去程之后的另一条公路。

输入坐充电站坐标，设它为 $j$。那么，它的坐标在去程标记为 $j$，在回程标记为 $1422\times2-j-1$（也就是 $2843-j$），然后本题可以转化为：在这一条公路上能不能跑单程。

##### 差分

这里介绍差分算法，它可以处理区间加减问题。

比如，现在有一个长度为 $5$ 的全是 $0$ 的序列，现在执行 $3$ 条操作，每一条操作形式为 `x y z`，表示从第 $x$ 个数到第 $y$ 个数增加 `z`。

如下是操作：

```
1 2 2
2 4 4
4 5 1
```

那么，经过一通暴力以后，序列是：

```
2 6 4 5 1
```

但这样时间复杂度能直接崩掉程序~~和你 AC 的希望~~。怎么办呢？

举个例子，你在公路上开车时，遇到了“限速 $60$ 千米每小时”的路牌。公路管理员不可能在每毫米都插一个这样的牌子，只会在开始处插一个，再在结束处插一个“取消限速”。

同样的道理，在上面的例子中，我们可以：

在序列的第 $1$ 项中写一个“$+2$”，再在第 $(2+1)$ 项写一个 $-2$，其它同理，最后序列就成了：

```
+2 +4 -2 +1 -4 -1
```

（最后一项似乎越界了，所以代码中，对于那条公路的数组，我多预定了 $250$ 英里的空间）

怎么转化呢？算一下前缀和，就会发现数列成了这样：

```
2 6 4 5 1
```

是不是发现什么？同样这道题也可以用差分、前缀和解决。

##### 本题如何实现

首先，让这个点自增 $1$；

然后，让这个点后的第 $200$ 个点自减 $1$。

### 3 代码与记录

```cpp
#include<cstdio>
#include<cstring>
using namespace std;
const int km=1422;//鬼知道是不是千米
int n;
int hw[(km<<1)+250];
	//用一个数组表示去程和回程，0—1421为去程，1422—2843为回程
bool ok;
int main(){
	#ifndef ONLINE_JUDGE
	freopen("UVA11850_1.in","r",stdin);
	freopen("UVA11850_1.out","w",stdout);
	#endif
	while(true){
		scanf("%d",&n);
		if(n==0){
			break;
		}
		memset(hw,0,sizeof(hw));
		for(int i=1,j;i<=n;++i){
			scanf("%d",&j);
			++hw[j];
			--hw[j+200];
			++hw[(km<<1)-j-1];
			--hw[(km<<1)-j-1+200];
		}
		ok=true;
		for(int i=0,sum=0;i<(km<<1);++i){
			sum+=hw[i];
			if(sum<=0){
				ok=false;
				break;
			}
		}
		printf("%s\n",ok?"POSSIBLE":"IMPOSSIBLE");
	}
	return 0;
}
```

[记录传送门](https://www.luogu.com.cn/record/51931359)

By **dengziyue**