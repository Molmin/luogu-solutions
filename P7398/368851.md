## 思路
**STL大法好**

此题只需对字符串进行模拟把每串有数字构成的字符串的数字统计起来，然后把这个数标记为出现过，如果这个数还没出现过就要把ans加一，然后继续去统计，我们来解释一个样例

```
borna123vitez
```
首先从第一个开始模拟直到碰到数字1，然后把数字串统计起来就成了123，然后答案就出来了，为1

```
as23dkrf23smk1asd23sam9
```
这个过程就不详解了，统计的数字为：23，23，23，1，9，虽然23出现过多次，但是只算23出现了一次，所以答案为3

因为这个数无限大，所以我们要用一个STL的map，来统计数字是否出现过，因为map可以定义一个无限大的数组

## CODE
```cpp
#include<bits/stdc++.h>
using namespace std;
map<int,bool>p;//定义一个下标为int型,类型为bool型的无限大数组,统计各个数字是否出现过 
int ans,num=0;//ans统计共有多少个不同的数字,num统计每个数字串中的数字
string s; 
int main(){
	cin>>s;
	for(int i=0;i<s.size();++i){
		if(s[i]<='9'&&s[i]>='0'){//若为数字
			while(s[i]<='9'&&s[i]>='0'){//把这一串数字统计起来 
				num=(num*10)+(s[i]-'0');//把这数字统计起来 
				i++;//下标加一 
			}
			//如果碰到字母,就把这一段统计的数字标记
			if(!p[num]){//没出现过 
				ans++;//把不同数字的个数加一 
				p[num]=1;//标记为出现过 
			}
			num=0;//初始化 
		}
	}
	cout<<ans;//输出答案
	return 0; 
}
```
