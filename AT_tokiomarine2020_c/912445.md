## [AT_tokiomarine2020_c Lamps](https://www.luogu.com.cn/problem/AT_tokiomarine2020_c)
# 题目描述

有 $N$ 个灯泡排在一条数轴上，第 $i$ 个灯泡在位置 $i$ 上。

每个灯泡有其独立的亮度 $A_i$。如果一个灯泡的亮度为 $0$，则表明它始终是黑的。令灯泡 $i$ 的亮度为 $d$，那么它可以照亮从 $\lfloor i-d-0.5 \rfloor$ 到 $\lceil i+d+0.5 \rceil$ 的位置上的所有灯泡，其中 $\lfloor x \rfloor$ 与 $\lceil x \rceil$ 分别表示不超过 $x$ 的最大整数和不小于 $x$ 的最小整数。

定义一步操作如下：对于每个灯泡 $i$，将 $i$ 照亮的灯泡数量作为其新的亮度 $A_i$。

现在你要进行 $K$ 步操作，每步操作后都需要重新计算每个灯泡的亮度。
输出 $K$ 步操作后每个灯泡的亮度。

## 数据范围

$1\le N,K \le 2\times 10^5$

$0\le A_i \le N$



# 题目分析

本题是一道~~思维难度较低的~~模拟题，考验对于差分思想的理解。

由于每次操作都会改变灯泡的亮度，根据题目的定义，我们不难发现：如果一个灯泡亮度为 $0$，那么该灯泡永远不可能变亮。

因此，在 $K$ 次操作后，所有亮度为 $0$ 的灯泡仍将保持黑暗。一个灯泡是否在某个时刻会变亮，关键取决于这个灯泡被多少个其他的灯泡照亮了。

所以，每次操作时，我们需要对于每个灯泡的照明范围进行统计，进而得到灯泡之间的影响关系，以计算出新的灯泡亮度。

根据灯泡 $i$ 的位置和亮度 $A_i$，我们可以~~轻易~~得到它控制范围内的左右端点：

$$l=\max(1,i-A_i)$$

$$r=\min(n,i+A_i)$$

也就是说，灯泡 $i$ 控制的区域是 $[l, r]$。对于每个位置 $j\in[l,r]$，它被 $\min(j-i+A_i,i+A_i-j)$ 个灯泡控制；也就是说，在位置 $j$ 被照亮的灯泡数就是这些值之和。

当我们得到了每个位置被照亮的灯泡数量后，就可以~~简单地~~计算出新的灯泡亮度了。

具体而言，我们定义差分数组 $d$，其中 $d_i$ 表示 $A_i$ 被修改的次数差，即加上 $d_i$ 次，$A_i$ 就变成了现在的值。

每次操作时，我们遍历所有的灯泡并更新相应的位置。也就是说，对于当前轮的操作，我们加上操作前后两轮中在位置 $l$ 被修改的次数差，而在位置 $r+1$ 减去这一次的值。

完成一轮操作后，我们令 $A_i$ 等于前缀和 $s_i=s_{i-1}+d_i$。如果某个时刻所有的灯泡都变成了亮的，则提前结束操作。

# 参考代码
```cpp
#include <bits/stdc++.h>
const int MAXN = 200003;
using namespace std; 

int n, k, l, r, cnt; // n为灯泡数量，k为操作次数，l和r为定义的左右边界，cnt记录全亮的灯泡数量
int light[MAXN], diff[MAXN]; // light数组为灯泡亮度数组，diff数组为差分数组，用于记录每个位置被操作的次数之差
// 差分数组用于记录区间修改，从而减少操作次数，类似前缀和的思想，但是是反着来的

int main()
{
    cin >> n >> k; 
    for(int i = 1; i <= n; i++) cin >> light[i]; // 输入灯泡亮度数组
    for(int i = 1; i <= k; i++) // k次操作
    {
        memset(diff, 0, sizeof(diff)); // 每次操作前先清空差分数组
        for(int j = 1; j <= n; j++)
        {
            l = max(1, j - light[j]); // 获取当前灯泡左右可控制的范围
            r = min(n, j + light[j]); // 防止越界
            diff[l]++; // 差分数组，左端点+1
            diff[r + 1]--; // 左端点+1，右端点-1，记录区间修改次数差
        }
        cnt = 0;
        for(int j = 1; j <= n; j++) 
        {
            light[j] = light[j - 1] + diff[j]; // 计算出每个灯泡的亮度
            if(light[j] == n) cnt++; // 统计全亮的灯泡数量  
        }
        if(cnt == n) break; // 当全亮的灯泡数等于总数，结束操作
    }
    for(int i = 1; i <= n; i++) cout<< light[i] <<' '; // 输出每个灯泡的亮度
    return 0; 
}
```
