看了下好像没状压的题解，那么本蒟蒻来水一发

~~大佬们是看到数据范围没想过就状压吗？~~

具体思路：将每个排列按照01串存储，0代表相应位置的数字没有选中，1代表相应数字选中了。

举个例子：对于序列
```
2 4 5 6 3
```
我们有01串：
```
01001
```
就相当于我们选择了`4和3`两个数。

### 我们难道要开一个非常大的数组来存储和访问这些串？

### 不需要！

我们把每个01串对应的十进制数作为数组下标即可。

例如上面的`01001`，我们可以用9来表示。

这样我们只要枚举每个01串，使得其中的1的个数等于$k$（相当于保证了选中$k$个)，并且选择的数加起来的总和是个素数即可。

那么我们可以用$f$数组来存储每个01串对应的结果即可。

比如上述选择中，$f_9 = 7$

附：代码中的位运算（状压很可能用到，是非常基础的位运算）

| C++写法 | 含义 |
| :----------: | :----------: |
| $a >> 1$ | 将$a$右移一位 |
| $a$ & $1$ | 取$a$的最后一位 |


### 注意：笔者的状压跟之前讲的是反过来写的，也就是说对于前面的01001，笔者按照代码的思路选择的是2和6（正数第一个和第四个），前面讲的是选择倒数第一个和第四个

```
#include <cstdio>
#include <cmath>

using namespace std;

int a[25];
int f[2098000];
//f数组用来存储每个状态，表示每个下标对应的01串的时候，这个总和是多少。
//在状压中一定要注意的一个问题：一般状压只能适用于n <= 20的数据，再大可能就MLE了
//本题中的数据是n <= 20，状态总共有2^20，是2,097,152，保险一点开大点。


int chk(int x){
	for(int i = 2; i * i <= x; i++){
		if(x % i == 0){
			return false;
		}
	}
	return true;
}
//用来判断是否是质数的函数。

int main(){
	int n,k,ans = 0;
	scanf("%d%d",&n,&k);
	for(int i = 1; i <= n; i++){
		scanf("%d",&a[i]);
	}
    //读入
	int q = pow(2, n);
    //求出一共有多少种状态
    
    //以下代码请认真理解！是状压的核心代码部分
	for(int i = 1; i <= q; i++){ //遍历每个状态
		int tmp = i, cnt = 1, tem = 0;
		int hm = 0;
		while(tmp){  //tmp代表的是目前的状态
			if(tmp & 1){  //如果目前的状态的最后一位是1
				tem += a[cnt]; //将a[cnt]加入temp
				hm++;  //选中的位数+1
			}
			cnt++;  //总共的位数+1
			tmp >>= 1;  //tmp右移
		}
		if((chk(tem)) && (hm == k)){//如果这个总和是素数并且选中的数的个数等于k
			ans++;
		}
		tem = 0;
		cnt = 0;
	}
    
    
	printf("%d",ans);
	return 0;
}
```