    这个题的关键在于怎么求从n中取k个数的组合。以下简单介绍取全组合的方法，这里采用递归。

- 首先定义一个数组arr[n]。这个数组包含n个数，要从中取k次，那么考虑从右向左开始取数（不从左往右是因为那样要把取数后剩下的数组单独拿出来，但从右往左取直接用原数组就可以了。）

	```cpp
arr[n] = {1,2,3,4,5};
```

- 现在假设第一个数取得是最右边的元素（arr[n-1]）。那么剩下的元素就要从这个数组中剩下的位置中取了，也就是：从arr[0]到arr[n-2].


	  	arr[n] = {1,2,3,4,5};

	                        ↑取走这个
                    
	     剩下的数组是arr[n-1] = {1,2,3,4},之后要从这里边取k-1个数。


- 因此，我们把要做的递归函数总结一下，它的功能是：从原数组中最右边取一个值，然后从剩下的数组中就是取k-1个值了，从k递减到k-1，仍然是原问题的形式，对不对？这里就是递归的核心：他需要返回k-1，并且记录下此时取走的数，可以暂时理解成我们取的最后一个数。然后返回这个数字前边的数组，作为要取k-1个值的数组，我们剩下的k-1个数要在这里边取。我们设置这个函数体声明如下：

	```cpp
void fun(int k, int n, int sum);
```
    其中k是要取多少个数，n是要从多少数取。定义sum为一组排列的和，我们的目的是调用一次fun，输出全部排列的和。

	
- 但是，我们第一次取的数并不一定非要是数组最后一位，他可以是数组下标n-1~k-1的全部数字（之所以到k-1,因为到了k-1再往前的话，就取不够k-1个数了。）然而，我们取走一个数之后，剩下的k-1个数字必须从取走的那个数之前的这个子数组中取，不能从整个数组中取。因为要保证没有重复的。我们实现这一步的循环结构如下：

	for (int i = n - 1; i >= k - 1; i--)

-     现在考虑第一个数字不从数组末尾开始取（因为他可以从任意数字开始组合。）如下：

		arr[n] = {1,2,3,4,5};
	                 ↑这次为我们取4作为第一个k
	    剩下的数组：arr[n] = {1,2,3}
    
	    现在取k-1个数的话，要从这个子数组中取，才能保证不重复。

	这样的话，我们上述for循环的i即为取的第一个数，那么子数组的长度就是i-1了。这样我们递归本函数，从arr[i-1]中取k-1个数值，并且记录下此时已经取出的i值到sum：
    ```cpp
fun(k - 1, i - 1, sum + arr[i]);
```
- 其实到这里，递归的核心就已经完成了。但我们还需要规定递归结束的边界条件，也就是当取完全部数字时,此时k=0.如果判断k=0,就输出sum，然后结束调用。
    
   ```cpp
 if (k == 0) { std::cout << sum; return; }
```
- 所以我们要求Cnk的全组合中，每一个组合的和所用的函数就如下所示：
    ```cpp
void fun(int k, int n, int sum)
{
	if (k == 0) { std::cout << sum << " "; return; }
	for (int i = n - 1; i >= k - 1; i--)
		fun(k - 1, i - 1, sum + arr[i]);
}
```
调用该函数时，首先把你的数组放入arr[]，代入数组长度n,那么fun(n,k,0);就会输出该数组全部排列分别的和啦。

- 至于这个题剩下的部分我想不用我说大家也就清楚了吧，直接把这个函数的输出部分替换成判断是不是质数就好了。

