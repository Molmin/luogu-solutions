### 前言

看到巨佬们都用的是一些奇怪的算法+数据结构，但远没有那么复杂。

~~黄题就要用黄题的方法做~~

~~标题套娃好评~~

~~翻译人名为什么要加粗QAQ~~

### 整体思路

注意到尽管 $n$ 的数据范围较大，可以卡掉 $O(n^3)$ 的暴力，但 $a_i$ 的数据范围小的可怜，于是将思路转换为枚举最大值求答案。

**注意一个细节：** 由于最大值应该是正整数，所以只用枚举 $[0,30]$ 之间的数即可。

设当前的最大值为 $i$ ，目前只要求区间元素最大和即可。

假如这个区间不是 $[l,r]$，而是 $[1,r]$ ,怎么做？

可以想到，直接枚举 $r$，对于每一个 $r$，更新答案。

**注意一个细节：** 当 $a_r>i$ 时，终止循环。

但是现在左区间并不是固定的，怎么处理？

很容易。

如果 $[1,l]$ 的元素和为负数，则 $[1,r]$ 的元素和小于 $[l,r]$ 。

根据这个，在枚举 $r$ 时特判，当 $[1,r]$ 的元素和为负数时，将计数器清零，此时 $l=r$ 。

开始想到这个做法时，我还有一个问题，在枚举最大值时，如何保证这一区间有这个最大值？换句话讲，有没有可能最后答案区间的最大值不是 $i$？

肯定是不可能的。

显而易见，答案的最大值不可能大于 $i$。

其实也不能小于 $i$，因为此时不是最优的。

用这样的一种单重限制就可以做到双重限制，实在是巧妙。

喜闻乐见的代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[100001],ans,res;
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
		scanf("%d",&a[i]);
	for(int i=1;i<=31;i++)
	{
		res=0;
		for(int j=1;j<=n;j++)
		{
			res+=a[j];
			if(a[j]>i)
				res=0;
			res=max(res,0);
			ans=max(ans,res-i);
		}
	}
	cout<<ans;
	return 0;
}
```
