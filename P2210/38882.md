#### 今天考试的一道题呀~~虽然没有过~~

~~老师的方法神似已发布某题解~~

不过我看没有解释，还是写一篇题解

------------
因为n<=12，我们可以考虑压缩状态优化时间

定义 f [ k ]中k的二进制下第i位为1 / 0表示第i个点在 / 不在集合中，

f [ k ]本身保存的是当前状态k下的最小代价(这个代价有点不一样)

由题意我们发现如果f [ k ]仅靠存集合k内所有能连上边(即两头牛是朋友)的牛所花费代价的话，状态并不好转移

不妨加一个条件：outedge 集合k向外需要连，但还没有连的边的条数(即一些牛在k内，但是朋友不在，连不起)；这时我们的代价还要加上这些未连的边在当前集合中的这一部分的代价

如 2 3 4————5 6 7 ；假设2和3连了一条边，2还要与5连边；那从右边看2连5的边在目前2 3 4内的长度(一部分)就是2

那我们现在来分析如何转移：
	
   		对于一个已知最小代价，加上一个点，只需要求没有这个点的最优解加上这个点加进来后仍然是出边的数量(+1)和加进来这个点新增的出边数(+1)，以及这个点能连回去的边数(+1)
       
括号内表示的是每一条边对答案的贡献都是1

~~虽然有代码了但我还是放上来吧~~
~~各位模拟退火大佬都好强~~

```cpp
#include <bits/stdc++.h>
#include <algorithm>
#define ll long long
#define Freopen(x) {freopen(#x".in","r",stdin);freopen(#x".out","w",stdout);}
using namespace std;
void init(),solve(); 
int fri[15][5];
int f[1<<13],n;
int main()
{
	init();
	solve();
	return 0;
}
void init()
{
	//Freopen(haywire)
	scanf("%d",&n);
	for(int i=0;i<n;i++)
		for(int j=0;j<3;j++)
			scanf("%d",&fri[i][j]),
			fri[i][j]--;//这样方便处理
	return;
}
void solve()
{
	memset(f,0x3f,sizeof(f));
	f[0]=0;
	for(int k=1;k<(1<<n);k++)//状态压缩总共有1<<n种情况 
	{
		int outedge=0;//出边数
		for(int i=0;i<n;i++)
			if(k&(1<<i))//如果第i个点在集合k内 
				outedge+=3-((k>>fri[i][0])&1)-((k>>fri[i][1])&1)-((k>>fri[i][2])&1); //那么出边就要加上i的不在k中朋友的个数
		for(int i=0;i<n;i++)
		{
			if(k&(1<<i))//第i个点在集合k内 
			{
				int c=outedge-3+((k>>fri[i][0])&1)+((k>>fri[i][1])&1)+((k>>fri[i][2])&1)
				//括i点有outedge条边，现在假设没有i，把i加进来 
				//不包括i的集合就少了3-((k>>fri[i][0])&1)-((k>>fri[i][1])&1)-((k>>fri[i][2])&1)条边
                +((k>>fri[i][0])&1)+((k>>fri[i][1])&1)+((k>>fri[i][2])&1);
				//连上原来的集合还要加上 上行的代价
				f[k]=min(f[k],f[k&~(1<<i)]+c);
                //每次加一个点的代价就是所有现在出边的长度的数量(Ta的长度加了一)和i这个点连回k集合的边的数量(长度为一)
				//printf("%d\n",f[k]);
			}
		}
	}
	printf("%d\n",f[(1<<n)-1]);
	return;
}
```
管理大大辛苦了:）  ~~所以给过吧~~