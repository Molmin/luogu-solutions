一道贪心题。

容易知道，我们要尽量把糖送给需要更少的糖的孩子，这样能满足更多的孩子，所以我们可以把孩子需要的糖的数量从小到大排序，然后一个一个去尝试满足：只要当前还剩余的糖的数量大于等于当前孩子的需求，我们就可以满足他。但是如果满足了所有的孩子仍剩余糖的话，我们就不得不把手中的糖全部给某一个孩子，那这个孩子就得不到满足，就就需要将答案 $-1$。

代码如下：

```cpp
#include <cstdio>
#include <algorithm>
using namespace std;
int a[101];
int main(void)
{
	int n, x;
	scanf("%d%d", &n, &x);
	for (int i = 1; i <= n; ++i)
		scanf("%d", &a[i]);//输入
	sort(a + 1, a + n + 1);//从小到大排序
	int ans = 0;
	for (int i = 1; i <= n; ++i)
	{
		if (x < a[i])//如果现在剩余的糖已经 < 当前孩子的需求，就不能满足了
		{
			printf("%d", ans);//输出答案
			return 0;//结束程序，不需要继续尝试，因为比当前i大的j都会使a[i] <= a[j]
		}
		++ans;//可以满足这个孩子
		x -= a[i];//糖少了a[i]快
	}
	if (x) --ans;//如果此时还剩下糖，就不得不给某一个孩子，他就得不到满足
	printf("%d\n", ans);//输出答案，注意换行
	return 0;
}
```