一道简单的**贪心**题。

我先说明一个结论：我们要让尽量多的孩子开心，就应该优先给需求最少的孩子糖，可能有些同学就不理解了，那么我举个例子：

如果我有 $6$ 颗糖果，需要让 $3$ 个孩子开心，他们的需求分别是 $2$,$3$,$6$ 颗糖果，如果我要让尽量多的孩子开心，我就应该给需求量最少的两个孩子糖果，即需求量为 $2$ 和 $3$ 的孩子，虽然这样会有 $1$ 颗糖果浪费，但是可以使更多的孩子开心。如果我给需求量为 $6$ 的孩子糖果虽然糖果没有浪费，但是不能让尽可能多的孩子开心。简而言之，我们的目的并不是避免糖果浪费，而是让尽可能多的孩子开心。因此，我们应当按照需求从小到大的顺序给孩子糖，可以使用 **sort** 实现，然后再依次扫一遍，对每一个孩子都进行判断，代码即:

```cpp
if(x>=a[i]){//可以给这个孩子糖 
	++ans;
	x-=a[i];
}
else break;//糖不够了 
```


但是问题又来了，这道题最特别的地方是给**多**也会让孩子不高兴（虽然不太合理），如果我的糖果足够多,能够满足所有孩子的需求，而孩子收到过多的糖果也会不高兴，因此我们对最后一个孩子进行特判：如果剩余糖果数量刚好等于最后一个孩子的需求量（这样不仅能排除糖果过多的情况，同时也能排除糖果不足的情况），那么我们就可以使得最后一个孩子也开心。

代码：

```cpp
#include<bits/stdc++.h>
#define I long long
#define RI register int
#define il inline
#define rt return
using namespace std;
const int N=1e2+7;

I n,x,ans,a[N];

il I d(){
	I x=0,f=1;
	char c=0;
	while(!isdigit(c=getchar()))f-=(c=='-')*2;
	while(isdigit(c)){x=(x<<1)+(x<<3)+f*(c-48);c=getchar();}
	rt x;
}

signed main()
{
	RI i,j;
	n=d();x=d();
	for(i=1;i<=n;++i) a[i]=d();
	sort(a+1,a+n+1);//从小到大排序 
	for(i=1;i<n;++i){
		if(x>=a[i]){//可以给这个孩子糖 
			++ans;
			x-=a[i];
		}
		else break;//糖不够了 
	}
	if(x==a[n]) ++ans;//如果剩下的糖刚刚好和最后一个孩子要的数量一样,那么最后一个孩子也会开心 
	cout<<ans<<endl;
	rt 0;
}

```

