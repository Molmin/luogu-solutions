## [Link](https://www.luogu.com.cn/problem/P7914)

显然，这是一道区间 $\tt DP$。

$\tt DP$ 最重要的就是设状态。考虑如何设计才能不重不漏地统计所有状态。

然后会发现非常不好转移，容易会有重复计算的状态。

按照传统区间 $\tt DP$ 的思路，我们先设 $f_{l,r,0}$ 表示区间 $[l,r]$ 的左右端点都不为 ```*``` 的方案数，$f_{l,r,1}$ 表示区间 $[l,r]$ 的左端点为 ```*``` 且右端点不为 ```*``` 的方案数，$f_{l,r,2}$ 表示区间 $[l,r]$ 的左端点不为 ```*``` 且右端点为 ```*``` 的方案数，$f_{l,r,3}$ 表示区间 $[l,r]$ 的左右端点都为 ```*``` 的方案数。

为了方便，再设一个 $f_{l,r,4}$ 表示区间 $[l,r]$ 全为 ```*``` 的方案数。

显然，$f_{l,r,4}$ 属于 $f_{l,r,3}$。

然后开始想状态转移方程。

容易得出 $f_{l,r,0}=\sum_{i=l}^{r-1}(f_{l,i,2}+f_{l,i,0})\times f_{i+1,r,0}$。

但是这是错的，例如 ```()()()```，```()``` 和 ```()()``` 会算一次，```()()``` 和 ```()``` 会再算一次。

于是我们再设 $f_{l,r,5}$ 表示区间 $[l,r]$ 的左右端点都不为 ```*```，且左右端点是同一对括号时的方案数。

显然，$f_{l,r,5}$ 属于 $f_{l,r,0}$。

那么 $f_{l,r,0}=\sum_{i=l}^{r-1}(f_{l,i,2}+f_{l,i,0})\times f_{i+1,r,5}$。

剩下的转移方程同理。

这里再写一下如何判断是否 $k$ 个 ```*``` 连在一起。

其实很简单，状态转移的时候换一个思路转移，例如 ```()*****()()``` 总是可以从旁边转移。需要再注意一下 ```()*****()``` 和 ```()``` 会重复算一次。

代码如下：

```cpp
#include<bits/stdc++.h>
#define ll long long
#define mod 1000000007
using namespace std;
int n,k;
ll f[505][505][6];
char s[505];
int main()
{
    scanf("%d%d\n%s",&n,&k,s+1);
    for(int i=1;i<=n;i++)
		f[i][i-1][4]=1;
    for(int len=1;len<=n;len++)
	{
        for(int l=1;l+len-1<=n;l++)
		{
            int r=l+len-1;
            //0：左右都不是* 
			//1：左是*，右不是*
			//2：左不是*，右是*
			//3：左右都是* 
			//4：全都是* 
			//5：左右都不是*，且最左边与最右边对应 
			//4属于3，5属于0
            for(int i=l;i<r;i++)
			{
				f[l][r][0]=(f[l][r][0]+(f[l][i][2]+f[l][i][0])*f[i+1][r][5])%mod;
                f[l][r][1]=(f[l][r][1]+(f[l][i][1]+f[l][i][3])*f[i+1][r][5])%mod;
                f[l][r][2]=(f[l][r][2]+f[l][i][0]*f[i+1][r][4])%mod;
                f[l][r][3]=(f[l][r][3]+f[l][i][1]*f[i+1][r][4])%mod;
            }
            if(len<=k&&(s[r]=='*'||s[r]=='?'))
				f[l][r][4]=f[l][r-1][4];
            if((s[l]=='('||s[l]=='?')&&(s[r]==')'||s[r]=='?'))
				f[l][r][5]=(f[l+1][r-1][4]+f[l+1][r-1][2]+f[l+1][r-1][0]+f[l+1][r-1][1])%mod;
			f[l][r][0]=(f[l][r][0]+f[l][r][5])%mod;
            f[l][r][3]=(f[l][r][3]+f[l][r][4])%mod;
        }
    }
    printf("%lld\n",f[1][n][0]);
    return 0;
}
```
