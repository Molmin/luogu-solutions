## 前言
本人是个考场上在那干坐着的蒟蒻。
赛后听了老师讲解才做出来这道题。看了众多大佬的思路，觉得还是看不懂。我太菜了，所以只能使用一个超级简化版的解法，有什么不足欢迎随时打脸。
~~（因为这是我的第一篇题解）~~


## 思路

### 状态定义
一般来说，这种需要考虑序列上最优解的都是区间DP。所以我们先进行状态定义。

令 $f_{l,r}=k$ 表示原字符串 $[l,r]$ 区间中能凑成符合题意的超级括号序列 $k$ 个（$k$ 已经取模）。

### 状态转移

在开始讲之前，我先定义如下字符串和变量。如无特殊说明，它们的边界条件都按照这里的为准。

- $str$ 表示原字符串，下标从 $1$ 到 $n$。
- $len$ 表示转移区间的长度，取值从 $2$ 到 $n$（从 $2$ 开始的原因是最短的超级括号序列长度为 $2$ ）。
- $l$ 表示转移区间的左边界，取值从 $1$ 到 $n-len+1$。
- $r$ 表示转移区间的右边界，取值为 $l+len-1$ 到 $n$。

然后我们对 $f_{l,r}$ 转移的方式进行分类讨论。

我们可以将转移方式，也就是超级括号序列的组成方式分为两大类：有括号包裹和没有括号包裹。

那什么叫“有括号包裹”？

顾名思义，当且仅当字符串 $s_{1 \ldots n}$ 中的 $s_1 = \texttt ($ 且 $s_n = \texttt )$ 时，我们称字符串 $s_{1...n}$“有括号包裹”。

言归正传，超级括号序列的构成方式中，有 5 种方式是有括号包裹的。

分别是：```()```、```(S)```、```(A)```、```(SA)``` 和 ```(AS)```。

#### 1. 我们先来考虑怎样转移前两种：```()``` 和 ```(S)```。

转移的方法很简单：$f_{l,r} = f_{l,r} + cmp(l,r) \cdot (S_{l+1,r-1} || l-r+1=2 )$。

- 其中，$cmp(l,r)$ 表示在原字符串中，$str_l$ 等于 ```(``` 或 ```?```，并且 $str_r$ 等于 ```)``` 或者 ```?```。如果是，那么返回 $1$，如果不是，那么返回 $0$。
- $S_{i,j}$ 则表示原字符串中区间 $[l,r]$ 是否全由 ```*``` 和 ```?``` 组成。如果是，那么 $S_{i,j}$ 取值为 $1$，反之则为 $0$。

#### 2. 我们再来考虑 ```(A)```。

$f_{l,r} = f_{l,r} + cmp(l,r) \cdot f_{l+1,r-1}$

- 没什么好补充的，但要注意不要和形式 ```(SA)``` 和 ```(AS)``` 弄混。

#### 3. 最后来考虑 ```(SA)``` 和 ```(AS)```。

这两种情况需要枚举一个分割中心点 $mid$ 来区分字符串 ```A``` 和字符串 ```S```。

$mid$ 的取值范围可以从 $l+1$ 一直到 $r-2$。状态转移方程如下。

(SA):


$f_{i,j} = f_{l,r} + S_{l+1,mid} \cdot f_{mid+1,r-1}$

(AS):

$f_{i,j} = f_{l,r} + f_{l+1,mid} \cdot S_{mid+1,r-1}$

- 这两个可以合并在一个循环里处理。

现在再来考虑没有括号包裹的。

没有括号包裹的只有两种：```AB``` 和 ```ASB```。

#### 1. 先考虑 ```AB```。

通过枚举中心点 $mid$（$l \leq mid \leq r-1$）,我们几乎可以直接得出下面的状态转移方程

$f_{l,r} = f_{l,r} + f_{l,mid} \cdot f_{mid+1,r}$

但我们得仔细考虑考虑，它的正确性有保障吗？

相信聪明的你不久就能想出来，它的确是有 bug 的。

考虑下面这个例子：

```
123456789
(**)(*)()

如果采用上面的状态转移方程：
f[1][4] = 1
f[5][7] = 1
f[8][9] = 1
---
f[1][7] = f[1][4] * f[5][7] = 1
f[5][9] = f[5][7] * f[8][9] = 1
---
f[1][9] += f[1][4] * f[5][9] = 1
		+= f[1][7] * f[8][9] = 1
		= 2
这明显不对
```
那该怎么解决这个问题呢？

我们考虑新维护一个 $pap_{l,r}$ 表示区间 $[l,r]$ 中能凑出多少个**必须有括号包裹且不是拼接起来的**超级括号序列。

思考一下，为什么必须要有括号包裹且不是拼接起来的呢？

那是因为如果序列 ```A``` 是 ```AC``` 形式的超级括号序列，原 ```AB``` 序列就会变成这样：```ACB```。

我们有两种分割方式：```A/CB``` 和 ```AC/B```。

而我们只允许其中的一种分割方式，不然会算重。因此原序列中的序列 ```A``` 不能是拼接起来的，这样就不会有第二种分割方式了，就像这样：```(A)/B```。

而且，如果 A 是类似 ```(D)(E)``` 这个形式的话，那就和没用括号隔开前没什么区别了，一样会算重（就像这样：```(D)/(E)B``` 和 ```(D)(E)/B```）。
 
因此，在合并的时候， ```A``` 序列必须是有括号包裹且不是拼接起来的，剩下的随意。

所以，我们得到了一个新的状态转移方程：

$f_{l,r} = pap_{l,mid} \cdot f_{mid+1,r} $

现在我们再次考虑刚才的例子。

```
123456789
(**)(*)()

如果采用新的状态转移方程
f[1][4] = pap[1][4] = 1
f[5][7] = pap[5][7] = 1
f[8][9] = pap[8][9] = 1
---
f[1][7] = pap[1][4] * f[5][7] = 1
f[5][9] = pap[5][7] * f[8][9] = 1
---
f[1][9] += pap[1][4] * f[5][9] = 1
		+= pap[1][7] * f[8][9] = 0
		= 1
这是正确的
```

#### 2. 考虑 ```ASB```。

通过枚举中心点 $q$ 和 $p$( $l \leq q < p \leq r-1$ )，我们可以得出下列状态转移方程：

$f_{l,r} = f_{l,r} + pap_{l,q} \cdot S_{q+1,p} \cdot f_{p+1,r}$

至于为什么要用 $pap$ 转移，和前面的原因类似，这里我就不再赘述了，请读者们自己思考。

### 优化

刚才我们已经得到了一份正确的代码……但是并不能 AC。因为我们最多用了四重循环（形式 ```ASB```），所以复杂度达到了惊人的 $O(n^4)$！这是肯定会TLE的（不信你算算 $500^4$ )。所以我们必须考虑一些优化。

考虑维护数组 $sb_{l,r}$ ~~（别想了，不是那个意思）~~ 表示区间 $[l,r]$ 中有多少种方法能凑成形式为 SB 的字符串（当然，它们都不是超级括号序列）。维护只要用 $O(n)$ 的复杂度枚举分割点 $mid$。其它形式的时间复杂度都没有超过 $O(n)$ 的。再加上本就有的枚举 $len$ 和 $l$ 所用的 $O(n^2)$ 时间，总时间复杂度保持在了 $O(n^3)$ 以内，可以通过本题。

## Code

对了，写代码的时候别忘了取模和开 ```long long```。而且刚才我认为我已经把思路说得挺清楚了，所以就不加注释了，还请见谅。
```cpp
#include<bits/stdc++.h>
using namespace std;
const long long mod=1000000007;
int n,k;
int s[505][505];
char str[505];
long long f[505][505],pap[505][505],sb[505][505];
bool cmp(int l,int r)
{
	return (str[l]=='('||str[l]=='?')&&(str[r]==')'||str[r]=='?');
}
int main()
{
    scanf("%d %d",&n,&k);
    scanf("%s",str+1);
    for(int l=1;l<=n;l++)
    {
        s[l][l-1]=1;
        for(int r=l;r<=n&&r<=l+k-1;r++)
        {
            if(str[r]!='*'&&str[r]!='?')
            {
                break;
            }
            s[l][r]=1;
        }
    }
    for(int len=2;len<=n;len++)
    {
        for(int l=1;l<=n-len+1;l++)
        {
            int r=l+len-1;
            f[l][r]+=f[l+1][r-1]+s[l+1][r-1]*cmp(l,r);
            f[l][r]%=mod;
            pap[l][r]+=f[l+1][r-1]+s[l+1][r-1]*cmp(l,r);
            pap[l][r]%=mod;
            for(int m=l+1;m<=r-2;m++)
            {
                f[l][r]+=s[l+1][m]*f[m+1][r-1]*cmp(l,r);
                f[l][r]%=mod;
                pap[l][r]+=s[l+1][m]*f[m+1][r-1]*cmp(l,r);
                pap[l][r]%=mod;
                f[l][r]+=f[l+1][m]*s[m+1][r-1]*cmp(l,r);
                f[l][r]%=mod;
                pap[l][r]+=f[l+1][m]*s[m+1][r-1]*cmp(l,r);
                pap[l][r]%=mod;
            }
            for(int m=l;m<=r-1;m++)
            {
                f[l][r]+=pap[l][m]*f[m+1][r];
                f[l][r]%=mod;
                f[l][r]+=pap[l][m]*sb[m+1][r];
                f[l][r]%=mod;
                sb[l][r]+=s[l][m]*f[m+1][r];
                sb[l][r]%=mod;
            }
        }
    }
    printf("%lld\n",f[1][n]%mod);
    return 0;
}

```

## THE END