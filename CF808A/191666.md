这道题的数据比较大，直接用循环枚举的话会超时

因为n最大是1000000000，如果数据就是1000000000的话，要循环9000000000次，能不超时吗？

所以，我们仔细看一下，只有是一位数或者最高位不是零其他位数都是零的情况下，才可能是幸运数字，找到幸运数字也不难，我们发现，除了最高位时就的数字之外，幸运数字就是和它同样位数，除了最高位是比原数最高位数多1，其他位数都是零的数。

而如果它的最高位是九，就是比它多一位数字，最高位数字是1，其他数字都是零的数。

好了，献上代码

```
#include<bits/stdc++.h>
using namespace std;
char s[20];
//一串字符
int a;//我们要找的幸运数字
int main(){
    cin>>s;
    int len=strlen(s);
    int cnt=1;
    int k=0;
    for(int i=len-1;i>=0;i--){
	k+=cnt*(s[i]-'0');
	cnt*=10;
    }
    //以上是把n变成整数,为了好取n的最高位，所以不一开始就是整数了
    if(s[0]=='9'){
	int x=1;
	for(int i=0;i<len;i++)
           	x*=10;		
	printf("%d",x-k);
	return 0;
    }
    //九得特判
    a=s[0]-'0'+1;
    //先取最高位
    for(int i=0;i<len-1;i++)
	a*=10;
    //找到幸运数字
    printf("%d",a-k);
    //输出
    return 0;
}
```
#### ~~求过求赞~~
