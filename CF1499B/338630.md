这是一篇另类的题解。

设计状态 $dp[i][0/1][0/1]$，表示当前到第 $i$ 个字母，最后一位是 $0/1$，第 $i$​ 个字母有没有被移除，是否存在一种移除方案满足题意。我们进行分类讨论：

1. 当前位字母为 $0$ 时，我们可以选择移除和不移除。

   - 若不移除，则转移来的字符串最后一位和当前最后一位肯定为 $0$。

   - 若移除，则 $i-1$ 位不能移除，最后一位可能为 $0$ 或 $1$。因此 $dp[i][0][1]$ 从 $dp[i-1][0][0]$ 处转移，$dp[i][1][1]$ 从 $dp[i-1][1][0]$ 和 $dp[i-1][0][0]$ 转移。

2. 当前位字母为 $1$ 时，我们同样也有两种选择。

   - 若不移除，则当前最后一位肯定为 $1$。此时 $i-1$ 位的 $4$ 种状态都可以转移过来。

   - 若移除，则 $i-1$ 位不能移除，最后一位可能为 $0$ 或 $1$。因此 $dp[i][0][1]$ 从 $dp[i-1][0][0]$ 处转移，$dp[i][1][1]$ 从 $dp[i-1][0][0]$ 和 $dp[i-1][1][0]$ 转移。

最初时没有删除任何字母，因此边界条件为 $dp[0][0][0]=1$。

最后时一定处于第 $n$​ 位，只要四种状态中有一种方案是符合题意的即为 `YES`，否则为 `NO`。

```cpp
void solve()
{
	scanf("%s",s+1);n=strlen(s+1);
	memset(dp,false,sizeof(dp));
	dp[0][0][0]=true;
	for(int i=1;i<=n;i++)
	{
		int c=s[i]-'0';
		if(c==0)
		{
			dp[i][0][0]|=(dp[i-1][0][0]||dp[i-1][0][1]);
			dp[i][0][1]|=(dp[i-1][0][0]);
			dp[i][1][1]|=(dp[i-1][1][0]||dp[i-1][0][0]);
		}
		else
		{
			dp[i][1][1]|=(dp[i-1][0][0]||dp[i-1][1][0]);
			dp[i][1][0]|=(dp[i-1][0][0]||dp[i-1][0][1]||dp[i-1][1][0]||dp[i-1][1][1]);
			dp[i][0][1]|=(dp[i-1][0][0]);
		}
	}
	bool ac=(dp[n][0][0]||dp[n][0][1]||dp[n][1][0]||dp[n][1][1]);
	if(ac)puts("YES");
	else puts("NO");
}
```

