[原题链接](https://codeforces.com/contest/1499/problem/B)  
题目大意：从一个 $01$ 字符串中删去一些字符，使得这个字符串单调不降。
但是原字符串中不能有连续的两个字符被删去。
请问这样的删除方案是否存在。字符串长度不超过 $100$。  
思路：  
这道题就是模拟。如果前方出现了连续的 $0$，意味着删 $0$ 只能到这一位为止了。同理，如果后方出现了连续的 $1$，删 $1$ 也就结束了。  
那么，我们可以贪心地找出从后往前删 $0$ 最多是哪一位后面都是有序的 $1$，从前往后删 $1$ 最多是哪一位前面都是有序的 $0$。如果这两个区间可合法覆盖整个数组，那就可以了。  
核心代码：
```cpp
void test_case(int test){
	string s;
	cin>>s;
	int first1=1e9;
	for(int i=0;i+1<s.size();++i){
		if(s[i]=='1'&&s[i+1]=='1'){
			first1=i;
			break;
		}
	}
	int last0=-1;
	for(int i=0;i+1<s.size();++i){
		if(s[i]=='0'&&s[i+1]=='0'){
			last0=i;
		}
	}
	if(last0>first1){
		cout<<"NO\\n";
	}else{
		cout<<"YES\n";
	}
}
```
