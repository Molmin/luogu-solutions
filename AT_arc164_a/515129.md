考虑对合法解的项数进行变换

由乘方的定义可以推出：

$$3^m = 3^{m-1} \times  3$$

也就是说，项数为 $K - 2x$ 且大于等于 $0$ 的构造（$x$ 为任意整数），都可以通过变换变成 $K$ 项。

你可能会问：如果原构造的所有项次数都为 $0$，那么不就无法再进行变换了吗？事实上这是不可能的，通过反证法可以证明这一点。注意到题目给出了一个条件 $K \le N$，假设原构造的所有项次数都为 $0$，则 $K - 2x = N$，得出 $K > N$ 的结论，与给出条件矛盾。所以原构造的所有项次数不可能都为 $0$。

接下来，我们来证明含有形如 $K - 2x + 1$ 项的构造无法通过变换变成 $K$ 项（反之亦然）：

一个构造的每一项都是 $3^m$ 这样的数字，也就是均为奇数，$K - 2x + 1$ 个奇数相加与 $K$ 个奇数相加的奇偶性显然不同，所以 $K - 2x + 1$ 项的构造不可能变换为 $K$ 项的构造。

由于所有项数 $\le K$ 的合法构造项数都能够被分类为 $K - 2x + 1$ 项或 $K - 2x$ 项。所以我们只需要贪心地构造出任意一个项数 $\le K$ 的数列，如果项数形如 $K - 2x$，可以通过变换变为 $K$ 项，构造出合法解，如果形如 $K - 2x + 1$，则证明无法构造出合法解。

AC 代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
 
long long T,n,k,maxp;
 
int main() {
	cin >> T;
	while(T--) {
		cin >> n >> k;
		maxp=1350851717672992089; //这个东西是>=1e18 的第一个 3 的次幂
		while(maxp) {
			if(n>=maxp && k) n-=maxp,k--;
			else maxp/=3;
		}
		if(k%2==0 && n==0) cout << "Yes" << endl;
		else cout << "No" << endl;
	}
	return 0;
}
```
