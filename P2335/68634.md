题目分析：

读题后不难想到：对于每一个黑色像素，都去进行一次广度优先搜索，找到最近的白色像素。对于每一个白色像素，最近的白色像素就是自己。但是n，m的范围过大，超时！

故此题采用：多源最短路算法

对每一个白点进行广度优先搜索，由它去更新黑点的答案，再由已经更新的黑点去更新其他黑点的答案，但每个点不是只去一次，当我们发现存在更优解时应当重新加入队列进行更新.对每一个白点进行广度优先搜索，由它去更新黑点的答案，再由已经更新的黑点去更新其他黑点的答案，但每个黑点不是只更新一次，当我们发现存在更优解时应当重新加入队列进行更新.

**代码如下：**
```cpp

#include<bits/stdc++.h>
using namespace std;
struct _
{
	int x,y;
}q[182*182+5];//存白像素点
int ans[183][183],n,m,cnt;
bool flag[183][183]; 
int dx[4]={1,-1,0,0};
int dy[4]={0,0,1,-1};//方向数组，搜四周的点 
void BFS()
{
	int h=1,t=cnt,nx,ny,i;
	while(h<=t)//BFS模板 
	{
		for(i=0;i<=3;i++)
		{
			nx=q[h].x+dx[i];
			ny=q[h].y+dy[i];
			if(nx>=1&&nx<=n&&ny>=1&&ny<=m)//首先不能越界 
			{
				if(!flag[nx][ny]&&ans[q[h].x][q[h].y]+1<ans[nx][ny])
				{//为黑点且 ！！！当前的答案比之前的更优，则选择这种方案
				//把这个本来已经扩展过的节点压入，让它去更新其它的点的更优答案
				//比如 当前点(x,y)的上一次最近距离为3，它的上面一个点(x,y+1)的距离为4
				//而现在(x,y)的距离可以被nx，ny优化到2，那么(x,y+1)自然可以优化到3
					t++;
					q[t].x=nx;
					q[t].y=ny;
					ans[nx][ny]=ans[q[h].x][q[h].y]+1;//更新 
				}
			}
		}
		h++;
	}
	//结束时所有的点的答案已经最优了(全部更新完毕) 
}
int main()
{
	int i,j;
	scanf("%d%d",&n,&m);
	for(i=1;i<=n;i++)
	{
		for(j=1;j<=m;j++)
		{
			char ch;
			cin>>ch;
			if(ch=='0')flag[i][j]=false,ans[i][j]=0x7ff;//黑点为false，ans定大方便之后更新答案 
			else//把所有的白点丢进队列 
			{
				cnt++;
				q[cnt].x=i;q[cnt].y=j;
				flag[i][j]=true;
				ans[i][j]=0; 
			}
		}
	}
	BFS();//利用所有的白点去搜索，只需一次搜索即可 
	for(i=1;i<=n;i++)
	{
		for(j=1;j<=m;j++)printf("%d ",ans[i][j]);
		printf("\n");
	}
	return 0;
}
```