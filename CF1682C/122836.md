这是一道 $1400$ 的~~诈骗~~构造题。  
首先一种很显然的直觉：将这个序列排成一个单峰序列，这样答案就是  $\Big\lceil\dfrac{len}{2}\Big\rceil$（$len$ 为这个单峰序列的长度）。  
接下来考虑相同的数字怎么处理：  
1. 如果某一个数字的出现次数只有两次，我们可以把一个放在峰的左边，另一个放在峰的右边。
2. 如果某一个数字的出现次数在两次以上，那么在保持策略 $1$ 的情况下，这个数字无论放在什么地方都不可能产生贡献。

因此：我们的策略非常简单：把某个数在数列中只保留最多 $2$ 次，多余的直接扔掉。

由于数据过大不能用桶，考虑用排序完成以上操作。
```cpp
#include<bits/stdc++.h>
using namespace std;
int t,n,a[200005],cnt;
int main()
{
	cin>>t;
	while(t--)
	{
		cin>>n;
		cnt=0;
		for(int i=1;i<=n;i++)
		{
			cin>>a[i];
		}
		sort(a+1,a+1+n);
		for(int i=1;i<=n;i++)
		{
			if(i<3||a[i]!=a[i-1]||a[i]!=a[i-2])
			cnt++;
		}
		cout<<(cnt+1)/2<<"\n";
	}
}
```