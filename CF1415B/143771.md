# CF1415B Repainting Street

贪心题，枚举将所有房子刷成第 $i$ 种颜色，然后贪心地刷，比较刷成的这 $100$ 种颜色的天数，取最优。

贪心策略为:

* 如果当前房子是要刷的颜色的，忽略它。
* 不是要刷的颜色，那么这一天就不分青红皂白连续往后刷 $k$ 个房子。

证明这样刷得到的天数最少:

首先，刷满 $k$ 个房子不会使答案更劣:

如果有一次刷 $k - p$ 栋房子，多刷一栋会使下一次起刷的第一栋房子往后移动或刷 $p$ 栋本就合法的房子，第二种情况不会影响结果，第一种情况可能使答案更优，所以每次都要刷满 $k$ 栋。

然后，没有必要从一栋本就合法的房子刷起，如果一种方案中，有一天从 $p$ 栋本就合法的连续的房子起刷，那么对应一种方案里，这一天从这 $p$ 栋房子后面第一栋不合法的房子起刷，就等价于这一天从原来的起点连刷 $k + p$ 栋房子，之前已经说明，多刷无害，所以从不合法的房子起刷无害。

综上，用这种策略求得每一种颜色的最优结果，汇总出最优颜色的最优结果。

最差时间复杂度 $O(100sum_n)$，没有问题。

## 代码

```cpp
int n, k, a[100005], t, ans, f;
int main() {
  t = RD();
  for (register int T(1); T <= t; ++T) {
    n = RD();
    k = RD();
    ans = 0x3f3f3f3f;
    for (register int i(1); i <= n; ++i) {
      a[i] = RD();
    }
    for (register int i(1); i <= 100; ++i) {  //枚举都刷成每个颜色
      f = 0;                                  //清空
      for (register int j(1); j <= n;) {  //挨个刷 (这里加上扇动的手势)
        if (i != a[j]) {                  //不符合颜色要求
          ++f;                            //刷一天
          j += k;                         //连刷k个
        } else {                          //无需再刷
          ++j;                            //忽略
        }
      }
      ans = min(f, ans);
    }
    printf("%d\n", ans);
  }
  return 0;
}
```