一开始想到的是图的联通问题

然后一看数据就是一个大法师

注意细节

# 不能跨点跳跃，每个点只能用1次，跳跃不能连续。


基本思想就是依靠i确认搜索方向后，

依靠k用力朝此方向上搜索。

就x轴而言，可以从搜索点x,y通过

公式
```cpp
tx=xx[i]*k+x
ty=yy[i]*k+y

```

计算出即将跳跃的点坐标tx,ty
然后

测试1 该点是否能跳，是否在搜索范围内，且对应qi[tx][ty]==0 （如果均真，则说明此处可跳，赶紧dfs(tx,ty,len+k) //(k!=1)

测试2 是否在搜索范围外（四个不等式确定搜索范围）&&该点是否跳过（had0数组实现）

注意break的地方，不能跨点跳跃，每个点只能用1次，跳跃不能连续。
细节考虑较多。
```c
//头文件略

int qi[100][100],
had0[100][100];//i j位曾经有过0，记录0位位置信息
int xx[]={0,0,-1,1};
int yy[]={1,-1,0,0};
int n,x,y,ans;


void dfs(int x,int y,int len){
	ans=max(len,ans);//打擂台得到最大值，原装max函数
	for(int i=0;i<4;i++){//朝某一个方向用力（k）搜索
		for(int k=1;k<101;k++){//考虑极限情况，即使从1，1开始搜索，边界只会到100，1，所以循环100次足够
			int tx=k*xx[i]+x,ty=k*yy[i]+y;//起始点x y  +偏移方向 * k值偏移量 == 尝试点tx ty
			if(tx>=0&&ty>=0&&tx<n&&ty<n&&qi[tx][ty]==0){//满足边界条件情况下，判断此点是否可跳
				qi[tx][ty]=1;
				if(k!=1)dfs(tx,ty,len+k);//k==1 意味着两点紧密相邻，不能跳.k!=1时，可以跳，并且对最终长度贡献为k
				qi[tx][ty]=0;//回溯
				break;//这个方向只能用搜到的第一个
			}else{
				if(tx<0||ty<0||tx>=n||ty>=n)break;//此方向上的用力搜索，超过了搜索边界，（剪枝）
				if(had0[tx][ty]==1)break;//遇到了曾经有过0的位置（此处0被使用过了）
			}
		}
	}
}
int main(){
	
	cin>>n>>x>>y;
	for(int i=0;i<n;i++)
		for(int j=0;j<n;j++){
			cin>>qi[i][j];
			if(qi[i][j]==0)had0[i][j]=1;//记录一下0出现的次数
		}
			
	qi[x-1][y-1]=1;//从0,0 开始存储
	dfs(x-1,y-1,0);//同上
	cout<<ans;
}

```
