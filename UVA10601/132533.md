考虑到题目是个正方体，它所具有的置换群大小比较有限。            

我们考虑使用 Burnside 定理进行解题。              

首先打表 + 手玩可以得出这个正方体的置换群为：              

不动：$1$ 种，分解为 $(1)^{12}$
 

绕相对面中心旋转 $90°$：$6$ 种，分解为 $(4)^3$
 

绕相对面中心旋转 $180°$：$3$ 种，分解为 $(2)^6$     
 

绕相对棱中心旋转 $180°$ $6$ 种，分解为 $(1)^2(2)^5$

 

绕相对对角线旋转 $120°$：$8$ 种，分解为 $(3)^4$        

~~其实这里和第一篇题解一模一样，不过他后面讲的确实太潦草了一点所以我来补个详细的。~~            

我们有一个很简单的想法：考虑每一个操作，对于所有的排列暴力拿去算不动点就好了，事实证明这个方法应该可以通过？             

不过对于此题我们有一个更简单的方法：我们考虑用 Polya 的思想，还是把问题转化成在环上染色。                     

对于每种置换操作我们把它变成一些环后，我们考虑把它抽象成这个模型：

问你有 $6$ 种颜色，每种颜色有 $c_i$ 个，然后保证 $\sum_{i = 1} ^ 6 c_i = n$ 求染色方案。我们考虑环内的所有点都得染成同一种颜色，而观察一下我们所有置换得到的环可以发现只有第四种是有大小不一样的环，其它的情况环的大小都相等，令环大小为 $x$，每种颜色也只能用 $\frac{c_i}{x}$ 次，因为如果有用不尽的情况就无法染完这个排列，就说明这种置换操作在当前是不会产生任何不动点的，贡献为 $0$ 。              

那么我们再看看我们得到了一个什么模型：现在有 $k$ 种颜色每种颜色有 $\frac{c_i}{x}$ 个，有 $\frac{n}{x}$ 个球，现在问给每个求都要染一种颜色的方案数。           

这个就是多重集的排列数啊，计算公式就是 $\frac{\frac{n}{x}!}{\prod_{i = 1} ^ 6 \frac{c_i}{x}}$ 。               

那么这一块的贡献我们都可以直接算了，现在解决最麻烦的第四种置换操作，我们发现它其实就是先要把两个大小为 $1$ 的环填了，然后剩下又是同样的操作，所以我们枚举填入的两个颜色就可以了。              

```cpp
#include "bits/stdc++.h"
using namespace std;
const int Len = 15;
#define int long long
const long long Fac[13] = {1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880, 3628800, 39916800, 479001600};
int num[15];
long long calc(int x,int siz)
{
	long long res = Fac[siz / x];
	for(int i = 1 ; i <= 6 ; i ++) 
	{
	    if(!(num[i] % x)) res /= Fac[num[i] / x];
	    else return 0;
	}
	return res;
}
inline long long read() {
    char ch = getchar();
    int x = 0, f = 1;
    while (ch < '0' || ch > '9') {
        if (ch == '-')
            f = -1;
        ch = getchar();
    }
    while ('0' <= ch && ch <= '9') {
        x = x * 10 + ch - '0';
        ch = getchar();
    }
    return x * f;
}
signed main()
{
	for(int i = 1 ; i <= 6 ; i ++) num[i] = 0;
	for(int i = 1 ; i <= 12 ; i ++) num[read()] ++;
	long long Ans = calc(1 , 12) + 6 * calc(4 , 12) + 3 * calc(2 , 12) + 8 * calc(3 , 12);
	for(int i = 1 ; i <= 6 ; i ++)
	{
		if(!num[i]) continue;
		num[i] --;
	    for(int j = 1 ; j <= 6 ; j ++) 
		{
			if(!num[j]) continue;
			num[j] --;
			Ans = (Ans + 6 * calc(2 , 10));
			num[j] ++;
		}
	    num[i] ++;	
	}
	printf("%lld\n",Ans / 24);
	return 0;
}
```