有点妙的一道题。

题意：求或运算下的最小生成树。

## 思路

由于是在位运算下进行处理，很容易能想到按位进行贪心，接下来具体说一下思路。答案最优显然是全 $0$ 的，但是这个最优不一定能时时刻刻都做到，我们考虑怎么样将损失最小化。

对比 $(10000)_2$ 和 $(01111)_2$ 两个答案可以发现，即使后一个数一共有四位是 $1$，它依然比前一个数要大，因此通过比较 $1$ 的个数显然不合适；而同样显而易见的是，较高位取 $0$ 比较低位更优。

于是我们可以从最高位向下贪心，判断每一位是否可以取 $0$，由此得到答案。具体而言，如果第 $i$ 位及以上全部取 $0$ 依然能够构造出合格的生成树，那么显然答案的这一位就可以取到 $0$。

考虑到此题思维难度不高，接下来再具体谈一谈实现方法。

## 实现

对于每一条加进来的边，要进行以下判断：

- 在已经确定为 $0$ 的高位是否出现 $1$，若出现则应抛弃。
- 当前位置是否为 $1$，如果是就抛弃。

然后进行判断，如果加入后依然不能连通，那么这一位就不得不取到 $1$。其余的和普通的 Kruskal 是类似的。进行判断的那一句话不好写，可以参考@AFewSuns 的写法。

代码：https://paste.ubuntu.com/p/CN5xmS8svW/

可能因为 pastebin 的问题导致缩进有点不太对。