## 这道题一共有两种做法
### 一、暴力枚举
这种做法的原理非常简单，就是将一天的时间全部遍历一遍，如果均可以被n，m整除，那么记录答案，最后输出即可。
```cpp
#include <iostream>//标准化输入输出流
using namespace std;
int n,m,s,ans;//ans是记录答案的个数
int main()
{
	cin>>n>>m>>s;//输入三个数据
	for(int i=1;i<=s;i++)//遍历时间点
	{
		if(i%n==0&&i%m==0)ans++;//如果满足条件，记录答案
	}
	cout<<ans<<endl;//输出答案
	return 0;//养成好习惯，正式考试中必不可少
}
```
### 二、gcd(最大公约数)做法
#### 什么是gcd?
相信学过小学奥数的同学们应该都知道，gcd就是我们俗称的辗转相除法。相比较于传统的因式分解方法，它的效率比较高。
#### 如何实现？

可以通过先用前数对后数进行取模，再将两数交换位置，不断重复上述过程，直到余数等于零时**返回非零的那个数**。在代码中，我们可以用递归算法来实现。

------------------------------
题目中还需要求最小公倍数，直接用两数的乘积除以它们的最大公约数即可。

------------------------------
下面展示此题的gcd做法
```cpp
#include <iostream>
using namespace std;
int n,m,s;//前面和之前完全一样
int gcd(int a,int b)//gcd模板
{
	if(b>0)return gcd(b,a%b);//如果余数非零，继续操作
	else return a;//有零了，返回非零的a，即为答案
}
int main()
{
	cin>>n>>m>>s;
	int tmp=n*m/gcd(n,m);//这是最小公倍数
	cout<<s/tmp<<endl;//在这时间段里有多少个数是最小公倍数的倍数
	return 0;//好习惯
}
```
谢谢大家