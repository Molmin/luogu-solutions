#### 争做最简洁最好懂题解！全部代码34行！

首先要准确理解题意，题目已经明确时间是相同的，赛跑的路段是相同的，但是，**总路程是不同的**！因为**只要有人到达终点，赛跑就结束了！**

本题有两个关键点。**第一，领先顺序如何判断？** 双方谁领先，实际上就是谁的路程多！**第二，领先顺序的变化如何判断？** 设置变量f记录初始领先状态，检查每个单位时间的大小关系，如果发现大小关系与变量f表示的关系不一致，就说明领先顺序发生了变化。

那么就有思路：模拟每一秒，判断谁跑过的路程多，路程一直多的人某一秒后变的比对方少了，显然就说明对方超过他了。由于要模拟每一个单位时间，而速度就是单位时间内的路程，所以可以直接将速度相加，这不就是**前缀和**么！

下面分析样例，如下图，每个单位时间里，双方跑的路程也在相应发生变化，这就是在第5和第7个单位时间发生领先顺序变化的原因。


![每一秒分析](http://s14.sinaimg.cn/mw690/001x7Roezy7vSJUyRoF9d&690)

注意有几个坑点：
一是**模拟路程数组要开大**，因为要拆分到每1秒记录相应的路程，最大范围就应是1000*1000。

二是要**准确标记首次的领先顺序**，因为前几秒可能都相等，要用循环，一直找到不相等时再记录位置。

三是找到领先顺序变化后，记录次数的同时，要**相应更新标记的状**态f。


```cpp
#include <iostream>
using namespace std;
int a[1000010], b[1000010], f, tm, n, m;//数组要开1000*1000
void read(int *p, int x)
{ //读入数组并计算前缀和，优先的程序员不写重复代码
    int k = 0, v, t;
    while (x--)//x个时间段，对应n和m
    {
        cin >> v >> t;//相应速度与持续时间
        while (t--)//将持续的时间拆成单位时间
            p[++k] = v, p[k] += p[k - 1];//填充到路程数组并计算前缀和
    }
    tm = k; //存储总时间
}
int main()
{
    int i, k = 0;
    cin >> n >> m;
    read(a, n);               //读入a数组并计算前缀和
    read(b, m);               //读入b数组并计算前缀和
    for (i = 1; i <= tm; ++i) //查找首次领先
        if (a[i] != b[i])     //发现领先
        {
            f = a[i] > b[i] ? 1 : 0; //标记谁领先
            break;                   //停在第一次不相等的位置
        }
    for (++i; i <= tm; ++i)//从下一个单位时间开始比较
        if (a[i] > b[i] && !f)     //a领先但标记是b领先
            k++, f = 1;            //记数，更新标记状态为a领先
        else if (a[i] < b[i] && f) //b领先但标记是a领先
            k++, f = 0;            //记数，更新标记状态为b领先
    cout << k;                     //输出解
    return 0;
}
```
