## [洛谷传送门](https://www.luogu.com.cn/problem/P5541)
## 思路
我们分别分析最小和最大次数的情况。
### 最少次数
不妨先简化问题，取消移动的限制。

此时就是要找到一个长为 $N$ 的区间，使得其中有尽可能多的点。

这些点是不用移动的，其他点都需要移动到该区间中来。

然后尝试沿⽤这个思路，将移动限制加上。

假定⽬标区间为 $[l,r]$ ，其中 $r = l + n - 1$ 。

区间中的左右端点位置分别为 ${l}' , {r}'$ 。

那么不难发现，对于位置 $l$ ，需要满⾜下列两种情况之⼀，才可能有解。

位置 $r$ 同理。

1. $l = {l}'$ ，位置 $l$ 上已经有点，该点不⽤移动，保证移动后的位置不会是左端点。

2. 位置 $l$ 不是端点，这样才能将点移动到该位置。此时还需要额外满⾜ $[ {l}' , {r}' ]$ 之间有⼀个空位，⽤于将 $l$ 左边最后剩下的端点移动进来。注意，如果位置 $r$ 也是该情况，还需要⼀个额外的空位。

实际上，位置 $l$ 和位置 $r$ 上都没有点的情况对于求解是没有意义的。

我们可以将区间向右移动到位置 $l$ 上刚好有点，此时求解的限制变得更少。

因此，我们只需要枚举所有左边界在点上的区间即可。

### 最多次数

每次移动都必然会让点的范围缩小。

为了让移动次数尽可能大，就需要让范围缩小的速度尽可能慢。

由于每次操作需要选择端点移动，所以每次移动会让左右两端的某个缝隙消失。

最优情况下，存在⻓度为 $0$ 的缝隙，这样移动后点的范围就只会缩小 $1$ 。

不难发现，最优情况是很容易实现的。

每次移动时，将选择的端点删除后，插⼊到新的任意端点内侧的最近空位。

这样每次移动后都能保证依然存在⻓度为 $0$ 的缝隙。

如果最初两端没有⻓度为 $0$ 的缝隙，我们应该选择⼀个较小的缝隙删除。
## 复杂度分析
### 时间复杂度
排序 $O(N \log N)$ 。

计算最小次数，枚举左边界 $O(N)$ ， 维护右边界总共 $O(N)$ 。

计算最⼤次数，直接计算 $O(1)$ 。

总时间复杂度为 $O(N \log N)$ 。
### 空间复杂度
记录点 $O(N)$ 。
## $code$
~~~cpp
#include <algorithm>
#include <cstdio>
#include <iostream>

using namespace std;

const int kMaxN = 1e5 + 1;

int a[kMaxN];
int n;

int C() {
  int v = 0;                                      // 初始化答案
  for (int i = 1, j = 1; i <= n; i++) {           // 枚举左边界
    for (; j <= n && a[j] - a[i] + 1 < n; j++) {  // 维护右边界，使得长度达到n
    }
    if (j <= n && (a[j] == a[i] + n - 1 || a[j - 1] - a[i] + 2 != n)) {  // 右边界存在，要么正好在点上，要么左边有缝隙
      v = max(v, j - i + (a[j] - a[i] + 1 == n));                        // 更新区间内最大点数
    }
  }
  return n - v;  // 区间内最少空位
}

int main() {
  cin >> n;
  for (int i = 1; i <= n; i++) {
    cin >> a[i];
  }
  sort(a + 1, a + 1 + n);
  cout << C() << endl;                                              // 最小次数
  cout << a[n] - a[1] + 2 - n - min(a[2] - a[1], a[n] - a[n - 1]);  // 最大次数，选择较小缝隙删除
  return 0;
}

~~~
