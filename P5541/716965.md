# 分析
题目大意是，将位于数轴上的分散的正整数点通过若干次操作变成一坨（感觉一坨非常的形象）相邻的点，每次操作只能将位于两端的一个点置于另两个点之间，求最少及最多次数所以模拟就好了，也可以找规律。
## 最小
为了保证最小，我们可以先找到奶牛最密集的一坨。再用总奶牛数减去最大的一坨奶牛，即可找到正确答案。

具体实践如下：
```
	for(int i=1;i<=n;i++){
	    while(c<n&&a[c+1]-a[i]<=n-1)
		c++;
	    x=max(x,c-i+1);
	}
	ans1=n-x;
```

## 最大

考虑一定是往一边缩的感觉，于是是端点先跳到一边的里面，然后这一边开始往里缩，直到缩成一坨。

具体实践如下：
```
max(a[n−1]−a[1]+1,a[n]−a[2]+1)−(n−1)+1;
```
最后的加一是刚开始端点往里跳的代价。
# 题解
```
#include<bits/stdc++.h>
using namespace std;
int n,a[100005],ans,ans2;//ans是最小值，ans2是最大值
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)scanf("%d",&a[i]);
	sort(a+1,a+n+1);//快排，将奶牛从小到大排序，以便计算答案
	if((a[n-1]-a[1]==n-2 && a[n]-a[n-1]>2) || (a[n]-a[2]==n-2 && a[2]-a[1]>2)) ans=2;//特判
	else
	{
		int c=1,x=0;//x记录这个范围内最大一坨的奶牛数量
		for(int i=1;i<=n;i++)
		{
	    	while(c<n && a[c+1]-a[i]<=n-1)c++;
	    	x=max(x,c-i+1);
		}//找最大一坨的奶牛的数量
		ans=n-x;//计算最小的值
	}
	printf("%d\n%d\n",ans,max(a[n-1]-a[1],a[n]-a[2])-n+2);//输出最小的和最大的值
	return 0;
}
```
望管理员通过。