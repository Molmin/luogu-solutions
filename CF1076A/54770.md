这道题有很明显的贪心特征，于是我们就用贪心做（有啥特征啊 

题意：    
给你一个字符串，可以删掉一个或不删一个字符，使得字典序最小

基础知识（大佬们可以跳过不看）：  
这道题的题目中的字典序最小是什么意思？我们可以把一个字符给哈希了，比如$abc=a*131^2+b*131+c=98*131^2+99*131+100=1694847$,而$bcd=b*131^2+c*131+d=99*131^2+100*131+101=1712140$，然后我们会发现abc的哈希值比bcd小，也就是说abc的字典序比bcd小   

我们可以发现，越靠前面的字符占的权值越大，所以说想要让字典序最小，就要删最前面的，而我们当然要删既靠前面又比后面大的。为什么？想一想，前面如果比后面大，那么删掉之后当前的这个数所占的权值就会比原来的小，哈希值也就变小了，字典序也就相应的变小了。   

还有一种特殊情况：如果所有的都不比后面大该怎么办呢？（也就是单调队列）题目中说可以不删，大家可不要被骗，无论怎样，删总是比不删的字典序靠前的，因为少了一项嘛，所以我们还是要删的，可是删哪个呢？最后一个，因为我们保证了这个序列是单调的，所以后面一定比前面大。

然后我们就可以开心地开始写代码了：
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=1000005;
string s; int n;
int main(){
	cin>>n>>s;
	int flag=n-1;//flag代表的是要删哪一个，如果flag=-1的话就代表是特殊情况（如上文所说）
	for(int i=0;i<n-1;i++)
		if(s[i]>s[i+1]){
			flag=i;
			break;
		}
	for(int i=0;i<n;i++) if(flag!=i) cout<<s[i];
	return 0; 
} 
//完美结束
```
