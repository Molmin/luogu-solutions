# CF549G Happy Line

回来辣

这道题应该没有蓝题那么难吧qaq

## PART 1 题目

emmm，前面两个神都大概把思路说了，我再做些补充好了。

首先，题意很明确，就是问可不可以通过一系列操作变成非降序列即可。

至于为什么要用到排序，我来解释一下：

- 因为求**非降**序列，因此我们要排序。

其次，我们用什么排序

- 我们知道，这样用到**交换**的题目，冒泡是最好写的，但是冒泡时间复杂度较高，会**TLE**
- 那我们用什么排序？其他的向插入啊，选择啊之类的明显不容易
- 考虑时间复杂度，我们需要一个约为$O(nlogn)$的排序方法
- 而明显$sort$是个好东西

至于为什么无法直接排序，原因如下：

- 我们考虑道**中途会有变化（指的是加一减一）**，因此直接排序后变化无法处理

那我们如何解决呢？**考虑不变量**

- 什么不变，仔细想想，其实$a_i +i $不变
- 为什么？我们以$a[i+1]$为例，把它挪到i会+1，而同时$a_i$就会-1
- 而这样$a[i+1]$就不用-1 了
- 从而可以直接排序
- 最后仍需还原

那么，注意$a[i-1]-a[i]==1$时，此时，原序列不变。

至于如何处理：

- 特判一下还原后的序列满不满足条件即可

##  PART 2 代码

```c++
#include<bits/stdc++.h>//万能头
using namespace std;

int n,m;

const int N=10000010;

int a[N];
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>a[i];
		a[i]+=i;//不变量
	}
	sort(a+1,a+1+n);//排序
	for(int i=1;i<=n;i++)
	{
		if(a[i-1]>=a[i]) //不满足的情况
		{
			cout<<":("<<endl;
			return 0;
		}
	}
	for(int i=1;i<=n;i++)
	{
		a[i]-=i;//还原
		cout<<a[i]<<" ";//输出
	}
    return 0;
}

```



