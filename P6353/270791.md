### 题目分析
这题有两种方法：
1. 先二转十，然后十转八  
这是一种比较基础的做法，这里就不做讲解了
2. 直接二转八  
为什么可以直接转换呢？  
因为 $\log_28=3$ 是一个正整数。  
举个栗子：`35`  
它拉成二进制是`100011`，拉成八进制是`43`。  
有什么发现吗？  
把`100011`每隔 $3($也就是 $\log_28)$ 位一断，即为  
`100 011`  
每段分别转成八进制，即为  
`4 3`  
诶？拼接起来以后和原数的八进制值一样啊？  
没错，这就是直接转换的奥秘。
### 代码
我们先用一个map把三位二进制转换成十进制整数：
```cpp
map <string,int> m;
int main()
{
	string str;
	cin>>str;
	m["000"]=0;
	m["001"]=1;
	m["010"]=2;
	m["011"]=3;
	m["100"]=4;
	m["101"]=5;
	m["110"]=6;
	m["111"]=7;
}
```
这里又有一个问题了：万一字符串长度不是3的倍数怎么办？  
给“扩容”不就行了  
比如`10`，它转成二进制是`1010`，那我们就在前面加2个0，`001010`，这样既不影响数值，又能方便的计算。
```cpp
	int n=str.length();str="0"+str;
	while(n%3){str="0"+str;++n;}
```
最后我们三位一断输出即可，可以采用string头文件里的substr函数（当然边做边删也是一种方法，这里就不展示了）
```cpp
	for(int i=1;i<=n;i+=3)
		printf("%d",m[str.substr(i,3)]);
```
全部代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
map <string,int> m;
int main()
{
	string str;
	cin>>str;
	m["000"]=0;
	m["001"]=1;
	m["010"]=2;
	m["011"]=3;
	m["100"]=4;
	m["101"]=5;
	m["110"]=6;
	m["111"]=7;
	int n=str.length();str="0"+str;
	while(n%3){str="0"+str;++n;}
	for(int i=1;i<=n;i+=3)
		printf("%d",m[str.substr(i,3)]);
	return 0;
}
```
$$\texttt{The End.}$$