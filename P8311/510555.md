~~想了半个多小时没想到，结果我妈一句话让我会了。~~

# 1. 简化版题意。
给定一个有 $n$ 个点但是没有边的图，第 $i$ 个点的权值为 $d_i$。已知构造一条点 $i$ 和点 $j$ 的双向边的代价为 $d_i+d_j$，求使这个图变成连通图的最小代价。

其中，$1 \leq n \leq 10^5$，且 $\forall1 \leq i \leq n$，都有 $1 \leq d_i\leq 10^9$

# 2. 这题应该怎么做？
首先，一条边可以连接 $2$ 个点，所以最少只需要 $n - 1$ 条边便可以使这个图变成连通图。

因为这道题对边的构造没有任何别的要求，所以，根据贪心的思路，我们只需要选出 $\frac{n(n-1)}{2}$ 条边中代价最少的 $n - 1$ 条边，将代价相加即可。

然而，如果真的把每条边都算出来的话，复杂度就高达 $O(n^2)$ 了。而且找出最小的 $n - 1$ 条边，最后的复杂度就会达到 $O(n^2 \log\ n^2)$ 了！照这么来算，我们的代码可能就只有 $20$ 分了！

但是……我们真的有必要将每条边都算出来吗？

如果要让一个点与其他已经连通的点连通，很明显，要让代价最小，肯定是让这个点这些连通的点中权值最小的那个点啊。如果每个点都用这样的思想去考虑的话，我们就会发现：每个点都和权值最小的那个点连接，就会使总代价最小！

假设 $minn = \min\limits_{1\le i\le n}{d_i}$（即 $min(d_1,d_2,d_3,……,d_n)$），因为有其他的 $n - 1$ 个点与这个权值最小的点相连，所以最后的答案就是 $\sum\limits_{i=1}^n(d_i+minn) - 2minn$（因为这个权值最小的点不用与自己相连，所以要减去 $2minn$），也就是 $\sum\limits_{i=1}^n(d_i) + minn(n - 2)$！

说了这么多，想必大家也听懂了，可以自己写代码了。但是为了方便大家理解，我还是贴个代码吧！![](//图.tk/6)![](//图.tk/6)![](//图.tk/6)

# AC code
```c++
#include<bits/stdc++.h>
using namespace std;
#define int1 long long
int1 n,i,a,minn = 1145141919810,s;//注意，最小值要设得很大，至少不小于10的9次方！ 
int1 read(){//仍旧是那一成不变的快读。 
	int1 x = 0,f = 1;
	char ch = getchar();
	while(!isdigit(ch)){
		if(ch == '-'){
			f = -1;
		}
		ch = getchar();
	}
	while(isdigit(ch)){
		x = (x << 1) + (x << 3) + ch - '0';
		ch = getchar();
	}
	return x * f;
}
void print(int1 x){//仍旧是那一成不变的快写。
  	if(x < 0){
    	putchar('-');
    	x = -x;
  	}
  	if(x > 9){
    	print(x / 10);
  	}
  	putchar(x % 10 + 48);
  	return ;
}
int main(){
	n = read();
	for(i = 1; i <= n; i++){
		a = read();
		minn = min(a,minn),s += a;//s就是所有点的点权值和。 
	}
	print(s + minn * (n - 2));//按题解里的结论输出就好了！ 
	return 0;
}
```