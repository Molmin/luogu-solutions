没头绪？？？打表找规律大法

发现第i个图形与第i-1个图形有关

轻而易举的写出了递推方程
```cpp
up[i]=3*up[i-1]+down[i-1];
down[i]=3*down[i-1]+up[i-1];  //不用数组也没关系
```
输出：

|n | 1 | 2 | 3 | 4 |
| :----------- | :----------- | :----------- | :----------- | :----------- |
|ans | 3 | 10 | 36 | 136 |

大家有没有发现什么？？？

可能发现不了······

呃···分解因数看一看

|n | 1 | 2 | 3 | 4 |
| :----------- | :----------- | :----------- | :----------- | :----------- |
|ans | 3=1×3 | 10=2×5 | 36=4×9 | 136=8×17 |

现在应该发现了吧······

ans=2^(n-1)×(2^n+1)

为什么会这样呢？？？

我们感性地理解一下

向上的三角形从底层向上递减，且每次减1

最底层的三角形每次分裂1倍，所以最底层共有2^n个向上的三角形

与上面的三角形形成了公差为1的等差数列，且首项为1，末项为2^n

利用等差数列求和公式 ans=(2^n+1)×2^n/2

化简一下  ans=2^(2n-1)+2^(n-1)

注意到2^(2n-1)可以用2^(n-1)表示

我们令w=2^(n-1)，则ans=w+2*w*w

由于n很大，所以使用快速幂加速（好像还能用矩阵优化，我太弱了）

快速幂不讲了，不会的点这里：[传送门](https://www.luogu.org/blog/Sleep-in-the-ground/kuai-su-mi)

代码很简单，注意取模就行了

完整代码
```cpp
#include<iostream>
#define MOD 1000000007
using namespace std;
long long mul(long long x,long long p)
{
    long long ans=1;
    while (p)
    {
        if (p&1) ans=ans*x%MOD;
        x=x*x%MOD;
        p=p>>1;
    }
    return ans;
}
int main()
{
    long long n;
    cin>>n;
    if (n)
    {
    	long long w=mul(2,n-1);
    	cout<<(w+2*w*w%MOD)%MOD<<endl;
	}
    else cout<<1<<endl;
    return 0;
}
```