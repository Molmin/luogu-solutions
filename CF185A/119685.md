 本题的意思是有一株植物，刚种下原来有1片叶子，每年都能从原来的叶子上再长出3片。

要求第$n$年向上的叶子。

首先明确，每年会在原先向上的叶子上长出$3$片向上的叶子。

原先向下的叶子上长出$1$片向上的叶子。 

所以设$a$[$0$]=$1$;$b$[$0$]=$0$;

$a$为向上的叶子数；$b$为向下的叶子数。
 
则递推转移方程为

$a$[$i$]=$a$[$i$-$1$]*$3$+$b$[$i$-$1$];

$b$[$i$]=$b$[$i$-$1$]*$3$+$a$[i-$1$]; 

而$n$的范围太大所以要想办法。

我们把递推转移方程做差得到$a$[$i$]-$b$[$i$] = $2$*($a$[$i$]-$1$-$b$[$i$]-$1$)，可得到

第i年两者之差的公式，又可知每年有$4^i$个三角，即 $a$[$i$]+$b$[$i$]=$4^i$, $a$[$i$]-$b$[$i$]=$2^n$ 两者作和

除2即为答案，快速幂即可解决。

即$a$[$n$]=$2^{n*2-1}$+$2^{n-1}$;

快速幂

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll mod = 1e9+7;
ll n;
ll p(ll a, ll k)
{
    a %= mod;
    ll ans = 1;
    while(k)
    {
        if(k&1) ans = ans*a%mod;
        a = a*a%mod;
        k /= 2;
    }
    return ans;
}
int main(void)
{
    while(cin >> n)
    {
        if(!n) puts("1");
        else printf("%I64d\n", (p(2, n-1)+p(2, 2*n-1))%mod);
    }
    return 0;
}
```

