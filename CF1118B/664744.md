# solution

- 我们拿第三个样例做一下分析，原来的情况是“奇偶奇偶奇偶奇偶奇”（以下记“空”为取走的数）：

1. 若取第 $4$ 个，数组情况变成“奇偶奇空偶奇偶奇偶”。

1. 若取第 $5$ 个，数组情况变成“奇偶奇偶空奇偶奇偶”。

1. 若取第 $9$ 个，数组情况变成“奇偶奇偶奇偶奇偶空”。

- **可以发现，每次取走的数都会对后面编号的奇偶性造成影响，而不会对前面的数的奇偶性造成影响**。

- 因此，先 $\mathcal {O}(n)$ 地处理出奇数编号和偶数编号的前缀和，然后从后往前枚举，枚举的同时处理后缀和，若取走，则后面的偶数编号都变成奇数编号，前面的不变，**因此偶数和为前面的偶数和加上后面的奇数和，奇数和为前面的奇数和加上后面的偶数和**，判断是否相等即可。

# code

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,i,j,ans;
int a[200005];
int s[200005][3];//s[i][0]是前缀偶数和，s[i][1]是前缀奇数和
int ls[200005][3];//ls[i][0]是后缀偶数和，ls[i][1]是后缀奇数和
int main(){
	scanf("%d",&n);
	for(i=1;i<=n;i++){
		scanf("%d",&a[i]);
		s[i][i%2]=s[i-1][i%2]+a[i];
		if(i%2==1) s[i][0]=s[i-1][0];
		if(i%2==0) s[i][1]=s[i-1][1];
	}
	for(i=n;i>=1;i--){
		ls[i][i%2]=ls[i+1][i%2]+a[i];
		if(i%2==1) ls[i][0]=ls[i+1][0];
		if(i%2==0) ls[i][1]=ls[i+1][1];
		if(i%2==1 && s[i][1]+ls[i][0]==s[i][0]+ls[i][1]) ans++;
		if(i%2==0 && s[i][0]+ls[i][1]==s[i][1]+ls[i][0]) ans++;//判断奇偶性进行比较
	}
	printf("%d",ans);
	return 0;
}
```
