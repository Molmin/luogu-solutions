先考虑对这些线段进行一些精简。

显然，区间内已经有点的线段可以被扔掉，完整包含了另一条线段的线段也可以被扔掉。两个过程都可以用二分实现。

观察一下整个画面现在长什么样子：大概是 一堆线段 - 一堆点 - 一堆线段 - 一堆点 这样，并且线段左端点随线段右端点递增而递增。观察一下最优方案应该长什么样子：显然，任意两个点跑过的的位置都不应该存在公共点。

设一个点初始位置为 $x$，跑过的位置为 $[l, r]$ 这个区间，那么这个点造成的花费是 $(r - l) + \min(x-l, r-x)$，变换一下形式就是 $2\min(x-l, r-x) + \max(x-l, r-x)$（其实不一定要做这个变换）。

考虑一个 dp：$dp_{i, j}$ 表示第 $i$ 个点向右跑 visit 了 $j$ 条线段时，前 $i$ 个点的答案。注意这个 dp 状态数是线性的，因为每个点向右一定不会跑过它右边的那个点（一定不优），所以总状态数就是「相邻两点之间线段数的总和」也就是 $m$。

我们设第 $i$ 和第 $i-1$ 个点之间一共有 $t$ 条线段。

有个显然的 $\mathcal O(n^2)$ dp：
$$
dp_{i, j} = \min\limits_{k} (dp_{i-1, k} + 
2\min(\text{dis}_a, \text{dis}_b) + \max(\text{dis}_a, \text{dis}_b))
$$
其中 $\text{dis}_a, \text{dis}_b$ 分别为第 $i$ 个点向左 visit $t-k$ 条线段的花费，和第 $i$ 个点向右 visit $j$ 条线段的花费。注意到 $\text{dis}_a$ 仅与 $i-1$ 和 $k$ 有关，而 $\text{dis}_b$ 仅与 $i$ 和 $j$ 有关。如果没有 $\min$ 和 $\max$ 的问题，就可以直接优化掉。

可以在存储着 $\text{dis}_a$ 的数组中二分 $\text{dis}_b$ 的位置，此位置之前 $\text{dis}_a \le \text{dis}_b$，之后 $\text{dis}_a \ge \text{dis}_b$，用前缀 / 后缀 $\min$ 分别计算着两种贡献就可以优化掉 $k$ 的枚举。时间复杂度 $\mathcal O(n \log n)$。

[并不推荐阅读的代码](https://codeforces.com/contest/1566/submission/132486068)

