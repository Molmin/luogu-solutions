本题有三种思路：搜索、贪心、dp。

### 题解
浅讲一下 dp。我们可以设 $f[i]$ 为点亮 $n$ 段 LED 灯时的最大值,
首先我们可以列出 $0 \sim 9$ 每种灯的所需要的段数。

| 数字 | 0 | 1 | 2 | 3 | 4 | 5 | 6 |7 |8  | 9 |
| -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: |
| 段数 | 6 | 2 | 5 | 5 | 4 | 5 |  6| 3 |  7| 6 |


如果要凑出段数为 $6$ 的时，我们不会选择数字 $9$ 而是 $7+7$。于是我们可以通过前一个已知的最大的 $f[i]$ 来转移到 $f[j]$。得出状态转移方程 $f[j]=\max(f[j],f[j-p[i]]+i)$，$p[i]$ 为数字所用的段数。
### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int p[2000001]{6,2,5,5,4,5,6,3,7,6};
int f[2000001];
int n;
int main(){
	cin>>n;
	f[0]=0;
	for(int i=0;i<=9;i++){
		for(int j=p[i];j<=n;j++){
			f[j]=max(f[j],f[j-p[i]]+i);
		}
	}
	cout<<f[n];
}
 
```

