本题我用的方法是 **动态规划** ，代码和完全背包很像。

初始化是一个很小的数字， 本题要求**正好用完**。

第一层循环 $i$ 枚举 $0\sim9$ 个数字， 第二层循环 $j$ 枚举 $\texttt{LED}$ 灯管数。

当段数为 $6$ 的时候， 我们不会选择数字 $9$ 而是选择两个 $7$， 所以 $7 + 7 = 14$ 很明显大于 $9$。 然后我们就可以得出 _**状态转移方程**_ ： $ \texttt{f[j] = max(f[j],f[j-shu[i]]+i)} $。

各个数字对应的 $\texttt{LED}$ 灯段数如下表：


| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| 6 | 2 | 5 | 5 | 4 | 5 | 6 | 3 | 7 | 6 |

 可以把它们存在一个数组里。

代码如下:


------------
CODE:
```cpp
#include<bits/stdc++.h>
using namespace std;

int n,shu[10]={6,2,5,5,4,5,6,3,7,6};   //w用来存每个数字所需段数 
int f[1000010];     //存最大值 

int main()
{
	memset(f,-0x7f7f,sizeof(f));
	cin>>n;
	f[0]=0;    //初始化
	for(int i=0;i<=9;i++)
	  for(int j=1;j<=n;j++)
	    if(j-shu[i]>=0)
	      f[j]=max(f[j],f[j-shu[i]]+i);     //状态转移方程 
	cout<<f[n];
	return 0;
}
```
