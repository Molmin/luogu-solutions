这道题堆在我的尝试过的题目里很久，今天终于 AC 了，这道题的细节还是非常多的。

## 题意

还是有必要说一下题意的：

在一个时钟上，有 $3$ 个针（挡着的东西）和两个点，问能否从一个点到另一个点，**注意**：如果起点与一根针是同一个位置，判断下一时刻（一瞬间）（按时针的运动顺序，顺时针走）中这根针是否挡着去路，如果挡着则过不去，否则可以过去。

其中输入的第一个数和最后两个数默认乘上 $5$（其实是因为它们是时针）。

提供两个神奇的数据来帮助理解题意：（我 WA 过的点）

Test $4$ :

```10 22 59 6 10```

这组数据，要输出 ```YES```，这就涉及了“注意”里的。这两个点是介于第一根针和第二根针里的，而第二个点与第一个针重合，但第一根针正在向着第三根针走，接下来不挡去路，所以可以到达。

Test $8$ :

```5 41 11 5 8```

这组数据，要输出 ```NO```。这与第四组数据正好相反。第一个点向着第二个点顺时针走的时候，第一根针正好也顺时针走。下一瞬间，第一根针正好挡住了去路，所以不能到达。

## 题解

首先，将三根针的位置从小到大排序，此时不用分哪根是哪根，因为它们都顺时针运动。其次，将两个点的位置也从小到大排序。

接下来，检查这两个点是否在三根针的两根中（如果在这两根中，就能到达）。设排序之后**下标**较小的针的位置为 $a$，另外一个为 $b$，两个点中位置较小的位置为 $c$，另外一个为 $d$。

分两种情况：

* $a$ 位置的针和 $b$ 位置的针，两根针跨越了 $0$ 点位置，也就是 $a>b$ 时：判断这两个点是否都在这两段中的任意一个：$0$ 点到 $b$ 点之间或者 $a$ 点到 $0$ 点之间（这里注意边界问题，即如果在 $0 \sim b$，$b$ 点是可以取到的，如果在 $a \sim 0(60)$，$a$ 点不能取到）。

* $a$ 位置的针和 $b$ 位置的针，两根针不跨越 $0$ 点位置，也就是 $a \le b$ 时：判断这两个点是否都在 $a \sim b$ 这个段即可。

注意有一个细节，即两针或三针共线：我的程序可以通过两针共线的情况，但不能通过三针共线的情况（建议手动模拟），特判即可。

## 参考代码

注：我的大括号换行和这一行的字符数有关，码风不喜勿喷。

```cpp
#include<bits/stdc++.h>
using namespace std;

bool check(int a,int b,int c,int d) // 检查 c 点到 d 点是否能在 a~b 这段走
{
    if(a>b) // 跨越 0
    {
        if((c<=b || c>a) && (d<=b || d>a)) // 是否在两段内
        {
            return 1;
        }
        else return 0;
    }
    else // 不跨越
    {
        if(c>a && d<=b) return 1; // 是否在一段内
        else return 0;
    }
}

int main()
{
    int a,b,c,d,e;
    cin>>a>>b>>c>>d>>e;
    a*=5,d*=5,e*=5; // 注意 a,d,e 要 *5
    if(a>b) swap(a,b); // 排序
    if(b>c) swap(b,c);
    if(a>b) swap(a,b);
    if(d>e) swap(d,e);
    if(a==b && b==c) cout<<"YES"; // 特判三点共线的情况
    else if(check(a,b,d,e) || check(b,c,d,e) || check(c,a,d,e))
    { // 对于每两针都检查
        cout<<"YES";
    }
    else cout<<"NO";
    return 0;
}
```