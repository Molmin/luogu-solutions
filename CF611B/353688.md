这题的题解区里大家好像都想复杂了，实际上我们只需要用 $\text{dfs}$ 构造出这样的数就行了。

从 $1$ 开始枚举，每次都判断是否满足条件，之后扩展到别的数。

设当前的数为 $x$。当 $a \le x \le b$ 并且二进制中的 $x$ 恰好有一个 `0`，这样的数就满足条件。我们可以使用一个 `bool ` 类型数判断二进制下它是否正好有一个 `0`，否则就没有 `0`（二进制下多于一个 `0` 的情况，扩展到别的数也一定多于一个 `0`，且看下文分解）。

当 $x$ 大于 $b$ 了，扩展后的数也一定大于 $b$，直接 `return;`

接下来考虑扩展到别的数。

当 $x$ 二进制下正好有一个 `0`，它只能扩展到 $x \times 2 + 1$，因为在二进制下乘上 $2$（二进制是 `10`）相当于二进制下在末尾添了一个 `0`，再加上 `1` 相当于在末尾添了一个 `1`，不会影响 `0` 的个数。

当 $x$ 二进制下没有 `0`，它可以扩展到 $x \times 2$，这样扩展后的数末尾就有了一个 `0`。它也可以扩展到 $x \times 2 + 1$，这样扩展后的数还是没有 `0`。

接下来是代码qwq：

```cpp
#include<bits/stdc++.h>
using namespace std;

long long a,b,cnt=0; // 记得要用 long long 类型 qwq

void dfs(long long x,bool if0)
// 当前的数是 x，如果二进制 x 有一个 0，if0 为 true，否则（没有 0）为 false
{
    if(x>=a && x<=b && if0) ++cnt; // 满足条件
    if(x>b) return; // 大于 b 了扩展后也大于 b，不可能
    if(if0) dfs(x*2+1,1 /* 添 1 没有改动 */); // 当二进制下 x 有一个 0，只能在末尾添 1
    else dfs(x*2,1 /* 添了一个 0，扩展后的数有一个 0 了 */),dfs(x*2+1,0 /* 添 1 没有改动 */); // 否则在末尾添 0 或 1 都行
}

int main()
{
    cin>>a>>b;
    dfs(1,0); // 从 1 开始扩展，二进制下 1 没有 0
    cout<<cnt; // 输出满足要求的个数
    return 0;
}
```