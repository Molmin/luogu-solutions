**先声明，下面文章中提及的指针，均不是C语言中真正真正意义的指针，而是“双指针”操作中的指针**。

本题思维上的难度是很低的，只要你的代码能过一些测试点就说明你大体思路是对的，但是需要注意一些细节。

思路再简单也还是要说一下的吧。

**1.思路**：

从题目入手：

(1).1~n数组中每个元素都要被染色。提取到一个要点——**应该要遍历数组**。再一看数据范围很小，所以遍历数组应该是一个可行的方案。当然，我们也应该注意到，题目**没有说不能用和a[i]相同的颜色来染a[i]**。

(2).输入k代表有1、2...k一共k种元素，都要用来染色。这就提取到第一个要点——**k种元素都要使用到**。

做法x：如果只有(1)和(2)两个点的话，那么这题就简单利用**双指针**，一个指向原数组；另一个指向1，依次向k移动，指到k以后跳回1继续循环，就可以完成了。

(3).如果原数组中的a[i]和a[j]两个元素是同种颜色的话，那么在染色的时候，不能拿相同的颜色去染a[i]和a[j]。这个要点，给我们遍历数组的时候增加了一点点限制，所以我们就不能原封不动的使用前面提到的做法x了。——我们应该想到，**既然原数组中颜色相同的不能染一样的颜色，那么我们就由1~k依次给颜色相同的元素染色**，这样就解决第(3)点了。

所以，我们只需要再添加一个指针，就可以了。

一个指针i指向1~5000的每一个元素，另一个指针j指向数组来遍历数组寻找值为i的数组元素，另外一个指针key指向1~k中每一种颜色。只有指针i和j需要循环，所以这题的做法可以是O(n^2)的复杂度。

**2.坑点**：

有可能原数组中几乎没有相同的元素，会导致key指针从来都不会移动到k，导致无法使用到所有元素。

只要注意到这个细节，那么上面的做法就基本没有问题了，下面直接上AC代码，代码中还会有一些补充助于理解。
```
#include<bits/stdc++.h>
using namespace std;
int a[5005];//接收数组
bool vis[5005];//标记当前位置是否染过色，每个地方只需要染一次色就够了
int coloruse[5005];//记录是否使用这个颜色的数组
int main()
{
    int i,j,n,k;
    cin>>n>>k;
    for(i=1; i<=n; i++)
        cin>>a[i];
    bool flag=1;
    for(i=1; i<=5000; i++)//指向1~5000每个数字，因为原数组中可能出现的数字一定在1~5000中
    {
        if(flag==0)
            break;
        int key=1;//指向1~k
        for(j=1; j<=n; j++)
        {
            if(a[j]==i&&!vis[j]&&key<=k)//如果是本来颜色就是i的话，由1到k依次染色，可以保证不会重复
            {
                coloruse[key]++;//标记当前颜色是否已经用过
                a[j]=key++;//key+1，保证下一次遇到i不会用同种颜色
                vis[j]=1;//标记这点已经被染色
            }
            else if(a[j]==i&&!vis[j]&&key>k)//如果还有等于i的点，但是颜色数量已经不够了，那可以直接退出了
            {
                flag=0;
                break;
            }
        }
    }
    if(flag==1)
    {
        j=1;//指向数组
        for(i=1; i<=k; i++)//检查1~k中是否有颜色没有使用过
        {
            if(!coloruse[i]&&j<=n&&coloruse[a[j]]>1)//保证当前颜色足够多
            {
                coloruse[a[j]]--;
                coloruse[i]++;
                a[j]=i;
                j++;
            }
            else if(!coloruse[i]&&j<=n&&coloruse[a[j]]==1)//如果当前颜色不够多的话，就找到够多的为止
            {
                while(coloruse[a[j]]==1)
                {
                    j++;
                }
                coloruse[a[j]]--;
                coloruse[i]++;
                a[j]=i;
                j++;
            }
            if(j>n&&!coloruse[i])//如果已经遍历了数组，还是没有用完颜色，那就无法完成题目要求了
            {
                flag=0;
            }
        }
    }
    if(flag==1)
    {
        cout<<"YES"<<'\n';
        for(i=1; i<=n; i++)
            printf("%d ",a[i]);
    }
    else
        printf("NO");
    return 0;
}
```