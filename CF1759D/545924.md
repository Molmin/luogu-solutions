**思路**

因为 $10=2\times5$，

所以要使得 $n\cdot k $ 的末尾 $0$ 的个数最多，就是要使得 $n\cdot k$ 中 $2$ 的因数的个数和 $5$ 的因数的个数中**较少的那一项尽可能多**。

然后我们设 $k$ 一开始等于 $1$，而我们的程序就是来求 $k$ 的，最终的答案就是 $n\cdot k $。

因此我们有了以下步骤：

1. 求出 $n$ 中 $2$ 和 $5$ 的因数个数。
2. 将 $k$ 不断乘上因数 $2$ 和 因数 $5$ 中个数较小的那一项（如果 $k$ 没有超过 $m$ 的话），使得因数 $2$ 和 因数 $5$ 的个数一样。
3. 将 $k$ 不断乘上 $10$（如果 $k$ 没有超过 $m$ 的话）。
4. 用**二分**求出 $k$ 再不超过 $m$ 的情况下最多还可以再乘上 $x$。


------------

那为什么是第二步在前，第三步在后呢？

因为第二步是用了 $\frac{x}{2} $ 或 $\frac{x}{5}$ 的代价，受益为末尾增加一个 $0$ 。

而第三步是用了 $\frac{x}{10}$ 的代价，受益也为末尾增加一个 $0$ 。

因此第二步无论如何都不会劣与第三步，所以要先执行第二步。



------------
**代码**

```cpp
void solve() {
  ll t;
  cin >> t;
  while (t--) {
    ll n, m;
    ll two = 0, five = 0, ans = 1;
    // two 为 n 中因数2的个数，five 为 n 中因数5的个数，ans 就是题目中所求的 k
    cin >> n >> m;
    ll k = n;
    while (k % 2 == 0)
      k /= 2, two++;//求因数2的个数
    while (k % 5 == 0)
      k /= 5, five++;//求因数5的个数
    while (ans * 5 <= m && five < two)
      ans *= 5, five++;//是因数5的个数与因数2的个数相匹配
    while (ans * 2 <= m && two < five)
      ans *= 2, two++;//同上
    while (ans * 10 <= m)
      ans *= 10;
    ll l = 1, r = m, x = 1;//最少乘上1，最多乘上m（当末尾0的个数不能再增加时就会乘上m）
    while (l <= r) {
      ll mid = (l + r) / 2;
      if (ans * mid <= m)
        l = mid + 1, x = mid;
      else
        r = mid - 1;
    }
    ans *= x;
    cout << n * ans << "\n";
  }
}
```

