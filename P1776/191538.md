```
题目描述

终于，破解了千年的难题。小FF找到了王室的宝物室，里面堆满了无数价值连城的宝物……这下小FF可发财了，嘎嘎。但是这里的宝物实在是太多了，小FF的采集车似乎装不下那么多宝物。看来小FF只能含泪舍弃其中的一部分宝物了……小FF对洞穴里的宝物进行了整理，他发现每样宝物都有一件或者多件。他粗略估算了下每样宝物的价值，之后开始了宝物筛选工作：小FF有一个最大载重为W的采集车，洞穴里总共有n种宝物，每种宝物的价值为v[i]，重量为w[i]，每种宝物有m[i]件。小FF希望在采集车不超载的前提下，选择一些宝物装进采集车，使得它们的价值和最大。

输入输出格式

输入格式：
第一行为一个整数N和w，分别表示宝物种数和采集车的最大载重。

接下来n行每行三个整数，其中第i行第一个数表示第i类品价值，第二个整数表示一件该类物品的重量，第三个整数为该类物品数量。

输出格式：
输出仅一个整数ans，表示在采集车不超载的情况下收集的宝物的最大价值。

输入输出样例

输入样例#1:
4 20
3 9 3
5 9 1
9 4 2
8 1 3
输出样例#1：
47
说明

对于30%的数据：n≤∑m[i]≤10^4；0≤W≤10^3。

对于100%的数据：n≤∑m[i]≤10^5；

0 <w≤4*10^4：1≤n<100。
```

------------

~~突然发现这道题好水啊orz~~

实际上，这是一道多重背包。**后排有人偷偷笑了**。

然鹅，这道题必须要优化，摆脱O(n^3)的束缚（看数据范围就知道了嘛）！

本蒟蒻在刚学时，教练教的是二进制优化，这种方法可以直接把O(n^3)变成O(n^2log(n))。在数据不是很大时，是可能水过的。

单调队列就不讲了，主要介绍一下二进制优化的思想：

众所周知，用1,2,4,8……2^(n-1)是可以凑出1~2^n-1之间的所有数的

那么，同理，当我有n个物品时，可以将它拆分成1,2,4,8……2^k(2^k<=n<2^(k+1))个独立的物品堆，来凑出1~n之间的所有数量。

但是，不是每个数都一定正好是2的正整数次幂啊，因此1+2+4+8+……+2^k不一定等于n

这时，只需要把剩下的再作为一堆物品就行了

则当小FF需要选择x件该物品时，可以用2的幂件物品来凑成x

上代码：

```
#include<bits/stdc++.h>
using namespace std;
int n,m,a[505],b[505],c[505],dp[60001];
void pidan(int p,int q){//哈哈，我的用户名
    for(int j=m;j>=p;j--){
        dp[j]=max(dp[j],dp[j-p]+q);//01背包
    }
    return;
}
void nadip(int p,int q){//哈哈，我的用户名反过来
    for(int j=p;j<=m;j++){
        dp[j]=max(dp[j],dp[j-p]+q);//完全背包
    }
    return;
}
void multiplepack(int mon,int p,int num){
    if(mon*num>=m){
        nadip(mon,p);
    }//小优化：如果该物品的总数乘以重量大于能承载的总重量，
    //即认为该物品无限供应
    else {
        int k=1;
        while(k<=num){
            pidan(k*mon,k*p);
            num-=k;
            k*=2;
        }
        pidan(num*mon,num*p);
    }//二进制拆分
    return;
}
int main(){
    cin>>n>>m;
    for(int i=1;i<=n;i++)cin>>a[i]>>b[i]>>c[i];//输入
    for(int i=1;i<=n;i++){
        multiplepack(b[i],a[i],c[i]);//多重背包
    }
    cout<<dp[m];//输出
    return 0;
}
```
在while循环中，如果调用的01背包选择了这件物品，则我们可以认为小FF选择了2^k件该物品。之前说过，如果小FF需要x件该物品，他可以选择2的幂件物品来凑成x，这样就可以不用枚举小FF选择的件数了。

教练还给我们出了一道很恶心的多重背包（可我做了满分哈哈哈）：


------------


```
【问题描述】
小 z 准备举办一个比赛。他需要提供一些甜点给参赛者来补充能量。每种甜品有一定的
能量 ti 和大小 ui，且每种甜点最多有 vi 个。
小 z 准备用箱子来包装甜点。箱子可以容纳一定体积的甜点且需要一定的费用。小 z
有一种魔法，可以将一个甜点分成多份装在箱子里，最后再合在一起（但合成之后必须是完
整的一个）。
小 z 想知道准备能量至少为 P 的甜点的最小大小和最少需要多少费用来购买箱子，如果
最少费用超过小 z 所拥有的钱数 k 则输出 FAIL。
【输入格式】
第一行为 4 个正整数 n,m,p, k( 1 ≤ n ≤ 200,1 ≤ m ≤ 200,0 ≤ p ≤ 50000, k <=
50000)分别代表甜点种类，箱子种类和参赛者比赛所需要补充的能量和小 z 所拥有的钱数。
接下来的 n 行，每行包含 3 个整数 ti, ui, vi ( 1 ≤ ti ≤ 100,1 ≤ ui ≤ 100,1 ≤
vi ≤ 100) , 代表第 i 类甜点可以提供 ti 的能量，它的大小为 ui 并且小明最多有 vi 个该
种类的甜点。
接下来又有 m 行，每一行包含 3 个整数 xi, yi, zi ( 1 ≤ xj ≤ 100,1 ≤ yj ≤ 100,1
≤ zj ≤ 100), 代表第 i 类箱子可以容纳 xi 大小的甜点，该类箱子的单价 yi,并且小 z 最
多可以使用 zi 个该类的箱子。
【输出格式】
第一行请输出最小的甜点大小。
第二行请输出最小的箱子费用，并且费用不能超过 k。否则，输出 FAIL。
【样例输入】
5 3 34 34
1 4 1
9 4 2
5 3 3
1 3 3
5 3 2
3 4 5
6 7 5
5 3 8
【样例输出】
19
12
【数据范围与约定】
对于每个测试点。 本题第一行正确得 4 分， 第二行正确得 6 分， 两行都正确得 10 分。
30%: n, m <= 15, p, k <= 1000
60%: n, m <= 50, p, k <= 5000
100%: n, m <= 200, p <= 50000, k <= 50000
```

这个大家可以多想一想，同样需要优化。