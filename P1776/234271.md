这题唯一的坑点就在于数组大小，RE*3，用的二进制优化，大佬们讲的很清楚了，我最多带一下，主要分析一下数组应该开多大QAQ

刚开始我盲开开错了，后来瞎调成10W才过的

那么明明n<=100，为什么要开这么大呢？

~~其实我也不知道~~

分析：首先我们可以看到数量mi<=10^5，折合2^19?再加上1，那么一个物品最多被分割成20份

总共有100份，辣么我们的种类最多2000种，v与w开到2000多就差不多了，而我们的m，只有在分解阶段有用，所以开100就可以惹，但我们做的是01背包，所以dp数组要开大，因为他的下标表述的是背包容量，最高只有4*10^4；

虽然这题不需要卡空间，但想明白每个数组要开多大是很重要的事情，就像我们要弄明白我们的家里有什么一样

下面就是卡空间AC代码//交了好多次，求管理员原谅QAQ

等我没那么蒟蒻且做的题多了写一写卡空间的艺术吧QWQ

其实这也不是坑，我也是看到一个小可爱问那个数组要开多大才写的，祝大家CSP RP++！

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
using namespace std;
int a[2005],b[2005],c[105],dp[40005],v,n;
int main() {
	cin>>n>>v;
	for(int i=1; i<=n; i++) {
		scanf("%d%d%d",&a[i],&b[i],&c[i]);
	}
	int k=n;
	for(int i=1; i<=n; i++) {
		for(int j=1; j<=c[i]; (j=j<<1)) {
			c[i]-=j;
			a[++k]=a[i]*j;
			b[k]=b[i]*j;
		}
		if(c[i]) {
			a[++k]=a[i]*c[i];
			b[k]=b[i]*c[i];
		}
	}
	for(int i=n+1; i<=k; i++) {
		for(int j=v; j>=b[i]; j--) {
			dp[j]=max(dp[j],dp[j-b[i]]+a[i]);
		}
	}
	cout<<dp[v]<<endl;
	return 0;
}
```
