### 倍增优化DP

题解有很多，但是很少详细讲的。这里详细的讲一下倍增优化多重背包。


------------
首先，我们要考虑的是如何把多重背包变成01背包。

一种很简单的想法是把一种宝物分为m种，然后在这上面做01背包。

比如

7可以分为1 1 1 1 1 1 1

01背包对应的是每一个数选0次或者1次，所以01背包这7个1，便可以枚举出0-7的最大值了。

但是如果这样做的话时间复杂度会到 $O(n*w*m)$ 肯定无法过本题。


------------


一种比较聪明的想法是用二进制来优化。首先，我们知道任何一个数都可以用2的幂次方之和来表示。

比如说 $9 = 2^0 + 2^3$ 

根据二进制其实就是 $9 = 1*2^0 + 0*2^1 + 0*2^2 + 1*2^3$

那么，事实上我们可以不用把一个数分为若干个1，可以分为2的幂次，大大的减少了时间复杂度。


------------


举个例子

比如说一个宝物的 $m = 7$

代表着这个宝物可以选0-7次。

那么事实上用 $2^0, 2^1, 2^2$ 中选若干个的和表示出来。

0-7中，4 可以表示为 $2^2$ ，5可以表示为 $2^2 + 2^0$ 一次类推。

所以$2^0, 2^1, 2^2$可以加起来变为0-7中任意一个数。（事实上如果知道二进制，这就是显然的）。

其实7是一个特殊的栗子，因为它刚好是 $2^3-1$。

举一个不特殊的栗子

0-12 可以表示为 $2^0,2^1,2^2,5$的和。

为什么最后一个是5呢？首先单靠$2^0,2^1,2^2$肯定是无法加起来成0-12。如果再用 $2^3$的话 那么总和就可以拼成 0-15了。这样会超过12，使得m不正确。但是如果选5的话就可以拼成且仅能拼成0-12中任意一个数。

证明：因为根据二进制，$2^0,2^1,2^2$ 可以拼成0-7。

那么0-7中任意一个数+5就可以变成5-12。既然又能拼成0-7，又能拼成5-12，所以能够拼成0-12。


------------

好了，现在说一下具体怎么求。

（这里用s代表宝物的数量不是题目中的m）

对于一个s，我们可以以次试 $2^0 + 2^1 + 2^2 ....$是否小于s。如果大于s的话，就舍去最后一个幂，然后把最后一项变成，$s- 2^0 + 2^1 + 2^2 ....2^k$。

这样拆分就可以凑成1-s中每一个数，然后用01背包求解就行了。

因为是2的幂次。所以总时间复杂度为 $O(n*w*log_2{m})$。

代码：
```cpp
#include <iostream>
#include <cstdio>
using namespace std;
const int N = 45000;
int n,m;
long long v[N],f[N],w[N];
inline int read()
{
	int ans = 0;
	char ch = getchar();
	short f = 1;
	while(ch<'0'||ch>'9')
	{
		if(ch == '-')
			f = -1;
		ch = getchar();
	}
	while(ch>='0'&&ch<='9')
	{
		ans = ans * 10 + ch-'0';
		ch = getchar();
	}
	return ans * f;
}
int main()
{
	n = read(), m = read();
	int cnt = 0;
	for(register int i=1;i<=n;i++)
	{
		int a,b,s;
		a=read(),b=read(),s=read();
		int k = 1;
		while(k<=s)
		{
			cnt++;
			v[cnt] = a*k;
			w[cnt] = b*k;
			s-=k;
			k*=2;
		}
		if(s>0) 
		{
			cnt++;
			v[cnt] = a*s;
			w[cnt] = b*s;
		}
	}
	n = cnt;
	for(int i=1;i<=n;i++)  //01背包
		for(int j=m;j>=w[i];j--)
			f[j] = max(f[j],f[j-w[i]]+v[i]);

	cout<<f[m]<<endl;
	return 0;
}
```

