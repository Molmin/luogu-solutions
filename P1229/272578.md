我感觉是前中，后中遍历的变形题
```
	a	b	c
	c	b	a
```
首先得明确几个点：
- 因为前序遍历，头节点a的下一个点一定是他的子节点b 
  后序遍历，对于前序遍历的b，一定是以b为头节点的子树
  的后序遍历的最后一个位置。
（也就是对应着第一个序列的b的位置，和第二个序列的b位置） 

- 对于序列永远都是左子树的各节点遍历完，才到右子树的各节点

- 如果第二个序列以b结尾，之后就再也没有节点了
说明a节点，只有一个子节点，上面的样例就是这种情况。


------------
```
那么给一个不是这种情况的序列，找个规律：
	a	b	c
	b	c	a   这个序列的a就有两个子节点 
```
------------

- 采用第二个的结论，当只有一个子节点b的时候这个子节点无论在父节点a 
的左孩子，还是右孩子，对前序和后序遍历都不会有影响 所以这里就有
两种情况(k==2)了;那么有两个子节点的时候，根本动不了，所以只有一种情况



```cpp
#include<bits/stdc++.h>
using namespace std;
int flag[200];
char a[1001],b[1001];
int DFS(int sa,int ea,int sb,int eb){
	if(sa>=ea) return 1; //如果只有一个节点了，或者无节点就是一种情况 
	int len=flag[a[sa+1]]-sb+1,k=1; //len得到左子树序列节点的个数
	if(sa+len==ea) k=2;      //a[sa]这个节点只有一个子节点那么这个k==2 
	return (DFS(sa+1,sa+len,sb,sb+len-1) * DFS(sa+len+1,ea,sb+len,eb)) * k; //组合数
} 
int main(){
	scanf("%s%s",a,b);
	for(int i=0;b[i]!='\0';i++){
		flag[b[i]]=i; //标识每一个点在后序遍历序列中的什么位置 
	}
	printf("%d",DFS(0,strlen(a)-1,0,strlen(b)-1));//xu chu 
}
```
