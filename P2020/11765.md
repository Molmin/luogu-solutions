貌似没有人发题解？我贡献一发

（本题解参考了jcvb和vfleaking两位大佬的题解）

题目肯定是和斐波那契数列有关，但有关在哪里呢？

由于有取模，所以我们看看有没有什么和循环有关的性质。

我们设fib[i]为斐波那契数列的第i项，而设F[i]为该数列的第i项。

把k=7作为例子，观察F[i]对k取模的序列：

1,1,2,3,5,0,

5,5,3,0,

3,3,6,2,0,

2,2,4,6,3,2,5,0,5,5,3,0, （之所以这一段前面的0不算是一段的结尾，是因为这个0不是由于减了一个1而产生的）

3,3,6,2,0,...

设fib[0]=0，则可以发现：

1.每一段的开头两个数都是相同的两个数，并且正好就是前面那一个段的最后一个非0数。

同时只有除k和0以外的k-1种数，所以最多在不超过k段的情况下就会出现循环。

（假设这个循环是存在的话。）

2.对于某一段而言，这一段都相当于一段小的斐波那契数列。

比如说某一段的开头是x，那么这一段就是

x,x,2x,3x,5x,8x,...

换言之，这一段的第i个数就是fib[i]\*x。

如果这一段有长度，那么设长度是Len，则x\*fib[Len] mod k==1.

这个时候就是我们要减掉1的时候。

 
有了以上的推导，我们不难得出具体算法：

1.根据x\*fib[Len] mod k==1求出fib[Len]

2.反推出Len

3.求出下一段的开头，也就是x\*fib[Len-1]，转回1

 
第一步里头，不难发现fib[Len]就是x-1(mod k)，所以如果逆元都不存在的话这就成了裸题。

否则，用extgcd算出逆元。

第二步，预处理出对于每个i，fib[Len]==i的最小Len。如果是不存在，那么也变成了矩阵乘法裸题。

但是可能这个Len很大啊？

有2个方法：1.估计一下fib mod k的循环节长度，直接算

2.数学证明

vfk大佬的博客上有证明，我不会证，只知道了结论：fib mod k的循环节是以0,1,1位开头的，且长度不超过6k。

就直接算了。

第三步，由于直接模拟可能超时，所以要用矩阵快速幂。


在完成了以上几步之后就是喜闻乐见的分类讨论了。。。

本题矩阵乘法要用2个矩阵，一个计算fib的矩阵和一个令fib[n]减1的矩阵，这两个都不难写，可以自己手算实现。

代码为了表达的详细写的很长，要看的话请移步[此处](http://leanote.com/blog/post/5955dff6ab64414a81000b71)。

（顺便推销了博客）
