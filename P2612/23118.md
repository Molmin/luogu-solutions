因为有abs不太好搞，考虑拆掉abs.

生成排列的方法之一：n个空位，从1到n一次插入一个空位。

这样搞的话考虑一个数的贡献

如果是`233333 1 666666` `|233333-1|+|1-666666|==233333+-1+666666-1` 所以1的贡献为-2
如果是`233333 inf 666666` `|233333-inf|+|inf-666666|==inf-233333+inf-666666` 所以inf的贡献为2inf
如果是`1 2 3` `|1-2|+|2-3|==2-1+3-2` 所以2的贡献为0
也就是说一个数的贡献为(-这个数×(sgn(左边的数-这个数)+sgn(右边的数-这个数)))

(边界上的数可以看成这个数×(sgn(相邻的数-这个数))

然后因为是从小到大插的，所以只要看这个数和多少已插入的数相邻

$f[i][j][k][l]:已经插入了i个点，共j段连续，前面数的总贡献为(k-5000)，边界共放了l个的方案数$

k的话从0~10000，C++党没负下标只好这样了，P党无所谓

插入i分多种情况


- 插入在边界，且与一段相连，贡献为i

- 插入在边界，自成一段，贡献为-i

- 插入不在边界，与一段相连，贡献为0（因为一边放了一边没放）

- 插入不在边界，自成一段，贡献为-2i

- 插入不在边界，而且这次插入使得两段相连，贡献为2i


最后统计一下每种多少种情况即可。

不~~想~~会写高精，\_\_float128大法好


k<=8用double

[代码](http://www.cnblogs.com/xzz\_233/p/7513366.html)
