显然题目要求我们把每个数都变为 $1$ 或 $-1$ .  
现在我们忽略乘积为 $1$ 这个限定，则只需贪心处理一遍即可。说得简单一些，正数变成 $1$，负数变成 $-1$ ，这样步数一定最少。

现在我们发现所有数的乘积还可能为 $-1$ ，所以需要进行调整。  
如果最初的数列中出现过 0 ，那么它必定变成了 $1$ 或 $-1$ 。如果我们采用相反的变化方式，那么它变化后的符号也会改变，这样就可以做到乘积为 $1$ 了。  
如果没有出现 0 ，我们就只能挑选一个 $1$ 或 $-1$ 再继续变化，这样答案就会加两步。

具体实现看代码吧

```cpp
#include<cstdio>
typedef long long ll;
int n,x,flag,f=0; ll ans; //注意步数可能会爆int
int main() {
	scanf("%d",&n);
	for (int i=1; i<=n; ++i) {
		scanf("%d",&x);
		if (x>0) ans+=x-1; //正数变为1
		if (!x) { flag=1; ++ans; } //flag统计是否有0出现
		if (x<0) { f=(!f); ans+=-1-x; } //负数变为-1，乘积变号
	}
	if (!f) printf("%lld\n",ans); //f=0表示乘积为正
	else printf("%lld\n",(flag?ans:ans+2)); 
	//若有0，步数无需增加；否则步数加2
	return 0;
}
```