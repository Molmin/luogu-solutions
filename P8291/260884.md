- 对自身的问题有了新的体会。
- 当你的笔头落在实处的时候，烦恼便消失无踪。
- 感谢[大佬](https://www.luogu.com.cn/user/58705)对时间复杂度的指导。
- 感谢与[大佬](https://www.luogu.com.cn/user/52881)讨论与争辩，让我对该做法有了更深刻的理解。
- 感谢[大佬](https://www.luogu.com.cn/user/52170)，[大佬](https://www.luogu.com.cn/user/58543)对题解的指导。

**题意**
- [题目链接](https://www.luogu.com.cn/problem/P8291)。
- 给一个讨论帖子,每个人都会发出至少一条学术信息和楼上楼下帖子，给帖子重排使得尽量多的楼上楼下帖子合情合理。

**分析**
- 您点开题目，快速地写了一个 $O(n!)$ 的暴力再水了 $20$ 分部分分，看到了学术帖（显然的重要性质）但是完全不知道它在提示什么。
- 剩下的时间您悠闲地思考着，您掠过了无数种想法，发现这样一种想法比较有前途：贪心，如果楼上和楼下相互照应，那么直接将它们配对即可，因为其他解如果破除它无法做到更优。
- 您发现您已经把正解归纳到性质 $C$ 上了，所以您有信心。
- 您认为它显然是个图论问题，所以您把每条的信息看成点，而连边的规则是：对 $(i,j)$ 连权值为 $w$ 的有向边当且仅当如果在排列中 $i$ 帖子在 $j$ 帖子楼上，对答案有 $w$ 的贡献，当然，第一步贪心过后，可以认为图中边的权值都为 $1$。
- 您发现这个问题可以归纳到最小路径覆盖问题：将每条路径以任意的顺序输出就是合法解，最小路径覆盖显然选出了最多的边，这个边数（包括您一开始的贪心）就是答案。
- 您发现这个图有环，而一般图的最小路径覆盖即 $\text{NPC}$，您愤怒了，感叹老天不公，回头转向了特殊性质。
- 您发现您完全没有用到每个人都至少发一条学术信息的特殊性质，于是您考虑使用它，比如 $a,b,\text{loushang}$ 且 $b,a,\text{loushang}$，那么可以将它们直接连到学术信息那里，这样我们可以看作学术信息并没有减少。
- 您发现这个性质可以消除我们网络流内部的环，于是您暴力建边用 $\text{Dicnic}$ 跑二分图最大匹配，复杂度是 $O(m^{2.5})$。
- 您不甘于此，再次感叹老天不公。
- 然后您突然想到一个有虚点的建边方式（如下图），使得图的规模为 $O(m)$，您考虑再三，发现由于边权都为 $1$，用网络流跑它是 $O(m^{1.5})$ 的，与[二分图](https://www.cnblogs.com/Itst/p/12556871.html)的证明类似，可以通过此题。
![](https://cdn.luogu.com.cn/upload/image_hosting/zwku5936.png)

**总结**
- 以上是我的全部思路，你或许觉得杂乱，但那就是我们思考的样子，这里是以上思路的总结，解释与补充，没有信息一其实也能做，但是优化较为困难。
- 第一个信息：楼上楼下相照应可以直接选，利用反证法可以证明。
- 第二个信息：拆环，上面只是一个粗浅的理解，环不一定是二元的，如下图：
![](https://cdn.luogu.com.cn/upload/image_hosting/bcb8sq8v.png)
- 注意：最小路径覆盖问题同时也求解了选出边条数最多的情况，而这正是本题的目的。
- 那么，我们上面做法的本质是：我们把做法归纳成一个最小路径覆盖问题，并妄想在一般图上跑最小路径覆盖。
- 传统在有向无环图上跑最小路径覆盖的做法会告诉你：这是不行的，因为传统的做法会跑出的不止有不相交路径，还有一些环，而环是不被允许的。
- 但我们有学术帖！所以可以将所有的环改成不相交路径！所以就可以求解这种特殊情况的“一般图最小路径覆盖”。
- 我们的暴力看上去很没有前途是 $O(m^{2.5})$ 的，但我们利用虚点换了一个建图让它变成是 $O(m^{1.5})$ 的，最终达到了本题的目的。

**代码实现**
- 我的经验是：一定要循序渐进，因为在这个过程中，复杂的模型会被简化，一些原本模糊不清的标准和问题也会显露出来，[准备](https://www.luogu.com.cn/paste/wmirpnd5)。
- 目标 $1$：$O(m^{2.5})$ 输出最优解，代码 $2.6\text{KB}$，[实现](https://www.luogu.com.cn/paste/8wyj48hj)。
- 解决的问题：分两个图实在是太麻烦，应该合并为一个图求解最小路径覆盖；一开始的贪心合并可以使用特殊的排序较为简单地实现；判断边是否相连的方法，只用了非常简单的代码段：
```cpp
bool ok=0;
if(q[i].tp==1&&q[j].tp!=4&&q[i].to==q[j].fm)ok=1;
if(q[j].tp==2&&q[i].tp!=3&&q[i].fm==q[j].to)ok=1;
if(ok)add(i,j+m);
```
- 目标 $2$：$O(m^{1.5})$ 输出最优解，代码 $2.6\text{KB}$：[实现](https://www.luogu.com.cn/paste/mkxnmnfi)。
- 目标 $3$：$O(m^{1.5})$ 小常数输出最优解，代码 $2.6\text{KB}$：[实现](https://www.luogu.com.cn/paste/q8fykz4f)。
- 解决的问题：如何卡常，反正我当前点优化试过了（这个一点效果也没有），不完全 $\text{bfs}$ 优化试过了，一次性退流优化也试过了……反正最后发现还是手工模拟比较正确的增广路会简单轻松一些（或许可以称它为：模拟最大流？）……话说复杂度正确为啥会被卡啊……
- 目标 $4$：$O(m^{1.5})$ 输出最优解和最优方案：代码 $3.4\text{KB}$，[实现](https://www.luogu.com.cn/paste/4ybao5so)。
- 解决的问题：首先把数改成一个双向链表会更加容易修改（虽然还是得有一堆特判），破环为链有更简单的方法，不需要一个个改，只需如下图：
![](https://cdn.luogu.com.cn/upload/image_hosting/1atmm51y.png)

**总结**
- 我不知道我的做法相比正解更加简单还是更加困难，或者本质就是一个东西，不过就这样吧，留下思考的痕迹。
- 我常常怀念很久以前的时候，那个时候我只有中午花午睡的时间才能学信息学，很菜，在校队排倒数，但那个时候我学得简单而快乐。
- 这道题让我重新找回了我以前的感觉，简简单单地思考一道题，不论对我来说是否困难：利用算法解决技术上的各种困难，这才是我想要的，这才是我的本心。
- 尽管限于能力，我无法在当时给出这个做法的代码实现，但这题对我的意义远不止一场比赛。
- 就这样吧。