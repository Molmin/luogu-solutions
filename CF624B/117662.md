~~这道题怎么上提高的？？？明明连普及都算不上好吧？~~


------------
## 进入正题~~~
读题，把题意化简一下就是：
#### **给你n个字母，每个字母最多用ai次，而且每个字母的使用次数都必须不一样（0当然除外啦），问能做的最长串**
他让我们最最长的，那我们就得把所有字母都用上。

但是有每个字母的使用次数，所以我们尽量让每个字符都用完，但实在有相同的，就将它减少一个，万一减少了之后又有用过的呢？

~~那就不做了~~减少了之后还有相同的呢？那就继续减，直到为0。

那这样高的次数被弄到0了会不会很亏呀？当然不会！即时这个数不减，另一个与之次数相同的也会减，那么就是一样的了。思路就这些！

至于实现，可以用桶排序的思想，如果这个数用了，就放这个数的桶里，下次有没有相同的，就可以直接查询这个桶，由于空间太大，数组装不下，就用的map来储存（~~那万恶的STL呀~~）


------------
接下来就是本蒟蒻的代码啦！
```cpp
#include<bits/stdc++.h> 
using namespace std;
map<long long , int> a; //由于数据很大，要开longlong，左边存了数字，那么右边自然就是存储这个桶有没有数的信息了 
long long n , ans = 0 , p; //n是数据范围，ans是答案个数，p是输入的数 
int main( ){
    cin >> n;
    while(n--){ //开始水题 
    	a[0] = 0; //由于0是可以重复的，要特殊处理，所以每次都设为空桶 
        cin >> p;
        while(a[p]) p--; //这个桶有就减少，直到遇到空桶 
        a[p] = 1; //这个桶有人啦 
        ans += p;
    }
    cout << ans;
    return 0;
}
```

## 溜啦溜啦