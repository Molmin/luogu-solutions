好多人都在大模拟O(NM)233...，我来个O(N^2)的算法好了，以防m过大。

我的思想对于有n个人，数到m（这是本轮情况）和有n+1个人，数到m（这是上轮情况）两种情况，我们从本轮第一个报数的同学开始排列，如果此时某人在本轮的位置为k，那么它在上轮的位置应当是(k + m)%(n + 1)，当然如果%得0，我们将其设置为n + 1即可

由于每轮的淘汰位置总是m，所以我们直接将初值设为m，向上循环即可。

注意：由于m可能超过某一轮的总人数，我们可以仿照上文%一下即可。

```cpp
#include<bits/stdc++.h>
#define rg register
using namespace std;
//注意：本题解所说的位置始终是每轮从第一个报数的人开始重排的位置，而非编号，由于第一轮的位置就是编号，得解 
int main(){
	rg int n,m;
	cin >> n >> m;
	for (rg int i = n;i>=1;--i){
		rg int x = m;//这是我们设置的初值 
		for (rg int j = i;j<n;++j){
				if (!(x % j)) x = j;
				else x = x % j;//这两行是我们防止x越界的操作 
				if (!((x + m)%(j + 1))) x = j + 1; //防止越界 
				else x = (x + m)%(j + 1);//这两行是向上“递归”的操作 ，j+1为上轮人数 
		}
		cout<<x<<' ';
	}
	return 0;	
}
```