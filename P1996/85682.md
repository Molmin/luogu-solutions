### 约瑟夫的~~杀人~~题目

我以为很多人会用这种方法~~来杀人~~呀……

翻了所有题解发现居然没有！(ΩДΩ)

那我就来补个~~杀人~~方法吧(｡◕ˇ∀ˇ◕)

先把代码贴上：
```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int m,n,k,a[1009];
int main()
{
    cin>>m>>n>>k;//输入 PS：我把n，m打反了，大家凑合着看-_-||
    for(int i=0;i<m;i++)
        a[i]=i+1;//建立一个模拟链表
    int p=0;//起始点
    for (;m>0;--m)//开始杀人(´⊙ω⊙`)
    {
        p=(p+n%m-1+m)%m;//找出倒霉的那个人的位置，也是核心公式，其作用稍后解释
        cout<<a[p]<<(m==1?'\n':' ');//手起刀落_(:з」∠)_PS：三目运算符最可爱qwq
        copy(a+p+1,a+m,a+p);//(O_O)?
    }
    return 0;//ヽ(*^ｰ^)人(^ｰ^*)ノ
}
```

注释已经基本写出思路，详细解释两点：

1.p=(p+n%m-1+m)%m;很多人问这是什么，我给大家解释一下，其实所有约瑟夫~~杀人~~问题都可以套这个公式。

p相当于指针，指向下一个要被杀的人；

n%m是由于n可能会比m打，为了减小运算量，对他先取余；

再加上p是由于这一回要从p的位置开始数，所以+p；

减去1是因为p本身也数，我们多数了一个，所以减去1；

只要有减法就可能会出现负数，防止越界要再多数一圈，也就是加m；

最后再对m取余，得出p——下个~~被杀~~出圈的人。

2.copy(a+p+1,a+m,a+p);大家更好奇的也许是这个小东西，是时候让他闪亮登场啦！【鲜花，掌声】

我们先声明一个数组a，copy需要三个参数。例如：copy(a+1,a+i+1,a+i);表示把a+1到a+i+1这区间的数拷贝到首地址是a+i的数组元素中，其原来的数值将被覆盖。

那么copy(a+p+1,a+m,a+p);大家就不难理解了，在这里正好起到了一个把刚被杀死的人从圈里踢出的作用。正好循环里写的是m--，同时圈内的人数也减少了一个，不影响运算。

我要讲的就是这么多，大家懂了吗？(*￣︶￣)