## 第一部分：简易题目。

给两组数据配对，求出所有对的最大差的最小值。


## 第二部分：思考思路。

第一步：看特点。可以很清楚的看出特点为有单调性和求最小的最大值。

第二步：思考算法，从特点可以很清晰的看出，二分答案算法最符合这个特点。


## 第三部分：二分讲解。

这一道题是典型的二分答案题，那么什么是二分答案呢？

举一个简单的“栗子”： 平时找书，如果要一个一个找，很费时间，所以为了优化时间，可以经过一下操作迅速找到：

----
1：找出一个区间的中间值。

2：如果这个中间的值等于目标值，那么退出。

3：判断这个中间值是否比目标值大，是则把左侧边界值换成这个中间值，否则把右侧边界换成这个中间值。

4：重新回到 操作 1。

-------

上面的步骤就是：“二分查找”，而“二分答案”就只需要把 操作 3 的判断条件修改就行了。

## 第四部分：具体思考。

### 1.二分。
通过第二部分的思考，我们知道了：这道题可以使用二分算法，那么就衍生出了一个问题： 二分什么？

返回题目，找到"求出所有对的最大差的最小值"这一句，那么我们就可以二分这个最小值。

然后一定一定要记得从小到大排序。
```
long long start=0,finish=1e9,mid; //定义变量。
while(start+1<finish)
{
  	mid=(start+finish)/2;//找中间值。
   if(...) finish=mid;//判断，区间边缘修改。
   else start=mid;//否则，区间边缘修改。
}
```

### 2.判断。

首先，明确一件事，就是判断部分就是看二分的最小值成不成立。

判断成不成立，就不需要看是不是最优。 

---
既然要配对，那就少不了双指针。两个指针  $(i,j)$  代表两个数据。一开始两个指针在每个数据的开头，也就是两个指针都为 1，然后看两个指针代表的数据的相差值有没有大于二分的最小值，如果没有，那么就说明配对成功，两个指针都往后找更大的数据，如果有，那么就把所代表的数据更小的指针往后找，因为如果大的往后找，找到的就是更大的，肯定也匹配不上。最后看匹配数等不等于数据量的最小值，因为原题目里有:"一定要匹配到不能匹配为止"的限制。

```
long long s=0;
for(int i=1,j=1;i<=n && j<=m;)
{
	if(abs(a[i]-b[j])<=x) i++,j++,s++;//可以就两个都往后找。
	else 
	if(a[i]>b[j]) j++;//更小的往后找。
	else i++;
}
return s==min(n,m);
```
----------
提醒：建议自己写完代码再看我的代码。


## 第五部分：代码。
```
#include<bits/stdc++.h>
using namespace std;
long long n,m,a[100005],b[100005];
bool pd(long long x)
{
	long long s=0;
	for(int i=1,j=1;i<=n && j<=m;)
	{
		if(abs(a[i]-b[j])<=x) i++,j++,s++;
		else 
		if(a[i]>b[j]) j++;
		else i++;
	}
	return s==min(n,m);
}
int main()
{
   cin>>n>>m;
   for(int i=1;i<=n;i++) cin>>a[i];
   for(int i=1;i<=m;i++) cin>>b[i];
   sort(a+1,a+1+n),sort(b+1,b+1+m);
   long long start=0,finish=1e9,mid;
   while(start+1<finish)
   {
   		mid=(start+finish)/2;
   		if(pd(mid)) finish=mid;
   		else start=mid;
   }
   if(pd(0)) finish=0;
   cout<<finish;
   return 0;
}
```

如果不通过，恳求管理员一次性把问题说完。