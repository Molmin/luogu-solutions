蒟蒻的第一篇题解。

只能说是一道水题。

~~一开始以为是红题，做完后What?黄的?~~

本题重点在于旋转的处理。

蒟蒻一枚不会旋转数组,只能模拟旋转直接输出

注意，旋转是顺时针转90°，扫描从左上往右下。

```cpp
#include<bits/stdc++.h>//万能头
using namespace std;
char p1[1001][1001];//定义字符数组存储透明纸
char p2[1001][1001];//定义字符数组存储情书
int n;
int main()
{
	cin>>n;
	for(int i=0;i<=n-1;i++)
	cin>>p1[i];//输入用cin轻松完成,gets()会把输入的n也读进去
	for(int i=0;i<=n-1;i++)
	cin>>p2[i];//输入
    //重点!!!旋转与输出
	for(int i=0;i<=n-1;i++)
		for(int j=0;j<=n-1;j++)
        //第一次直接扫描,遇到O输出即可
		if(p1[i][j]=='O')cout<<p2[i][j];
	for(int j=0;j<=n-1;j++)
		for(int i=n-1;i>=0;i--)
        //第二次,顺时针旋转90°,所以从左下往右上扫描
        //由于从上到下从左到右,所以先列后行(i,j扫描顺序互换)
		if(p1[i][j]=='O')cout<<p2[j][n-1-i];
        //输出时要注意,因为旋转,原来的(i,j)变为(j,n-1-i)可由分析样例得到这一规律(原因过会儿讲)
	for(int i=n-1;i>=0;i--)
		for(int j=n-1;j>=0;j--)
        //第三次,再转90°,所以右下往左上扫描
		if(p1[i][j]=='O')cout<<p2[n-1-i][n-1-j];
        //同理,输出时(i,j)变为(n-1-i)(n-1-j)
	for(int j=n-1;j>=0;j--)
		for(int i=0;i<=n-1;i++)
        //第四次,在转90°,从右上往左下扫描
        //同第二次,先列后行
		if(p1[i][j]=='O')cout<<p2[n-1-j][i];
        //同理,输出时(i,j)变为(n-1-j,i)
    return 0;//代码很短
}
```
下面讲一下为什么旋转后(i,j)分别变为(j,n-1-i)(n-1-i,n-1-j)和(n-1-j,i)。

如图,当n=4时,样例为

·##O#

·#O#O

·####

·###O

一次旋转后变为：

·####

·##O#

·###O

·O#O#

可以看到原来位于(0,2)的'O'旋转后在(2,3)=(2,3-0),因为这个‘O’距离整个矩阵的两边界的距离不变,所以横坐标为原来纵坐标,纵坐标为右边界-原来的横坐标

同理,旋转两次后为:

·O###

·####

·O#O#

·#O##

与原图中心对称,原来(0,2)变为(3,1)=(3-0,3-2)∵与边界距离不变,原来左上边界变为右下边界∴横纵坐标同时变为边界值-距离

同理,旋转三次后变为:

·#O#O

·O###

·#O##

·####

和第一次类似,可以直接当做逆时针旋转90°。这次只需要将原来的第一次的反过来做一遍,纵坐标为原来横坐标,横坐标为左边界-原来纵坐标。

这样就可以AC了。希望能有帮助。

~~要不是忘了换扫描方向我一遍就AC了~~