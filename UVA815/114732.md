首先其实这道题并不是很难，主要是题目很难懂

给你一张m*n的地图，然后天一直在下雨，雨水会优先流到最低的那个格子上去，

（注意不是均匀降雨然后流动到低海拔的格子，也就是说像

13

231

100

这种地形的结构最左边的那个格子是不会有水的）

填满了最低的那个格子后就开始同时填第二低和第三低的格子，以此类推下去直到所有的水都填完

然后给你下雨的量，求有水的格子所占百分比和水的高度（注意多组数据读入，另外题上也说了周围有无限高的墙，所以水不会流出去）

## 另外记得每一组输出后面还有一个回车

## 另外记得每一组输出后面还有一个回车

## 另外记得每一组输出后面还有一个回车

只是来题解区看题意的可以ctrl+w走了，

下面是题解部分
# 首看到题就能想到是二分啊
~~（因为这是我们学校二分专题里的题）~~

如果按照答案来，二分水的深度或者有水格子的占比的话显然是很难算的（大佬有别的骚操作的话就当我没说），所以我是二分枚举的最后那个被淹没的格子，比这个格子低的格子都会先被提高到和这个格子相同的海拔高度然后剩下的水再全部平分到每个格子上二分使这个格子的高度竟可能的高，但又不至于水都填不满比它还低的格子。

另外其实不用二维数组存，毕竟像之前所说的，水会优先流到最低的那个格子，也就是说可以无视地形影响，用一位数组来存还可以直接sort排序方便二分最后被淹的那个格子高度。

简单提一下二分左右界吧，至少淹一个至多淹完n*m个

最后代码附上

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
int l,r,mid,ans,js;
int n,m,w;
int a[905];
int region=0;
long long sum;
double f;
bool check(int x)
{
	sum=0;
	for(int i=1;i<x;i++)
	{
		sum+=(a[x]-a[i])*10*10;//由于排过序，所以（1~x-1）肯定都是比第x高（也就是第x个格子）矮的格子 
	}
	if(sum<w) return 1;//如果这部分都填不完的话这个方案肯定是不可实现的 
	return 0;
}
int main()
{
	while(cin>>n)//多组数据 
	{
		if(n==0) break;// 是0就结束读入 
		region++;//表示是第几组数据 
			scanf("%d",&m);
			r=m*n;//右边界就是格子数，所以可以先算了，输入数也就是右边界数 
	    for(int i=1;i<=r;i++)
	    {
	    	scanf("%d",&a[i]);//读入 
	    }
	    sort(a+1,a+n*m+1);
	    scanf("%d",&w);//读入降雨量 
		l=0;
		while(l<=r)
		{
			mid=(l+r)>>1;
			if(check(mid))
			{
				ans=mid;//比第ans矮的格子矮的会被填满 
				l=mid+1;
				js=sum;//js就是积水的拼音啊，表示填完比这个格子矮的格子要多少水 
			}
			else
			{
				r=mid-1;
			}
		}
		w-=js;//填完比它低的格子剩下的水水 
		printf("Region %d\n",region);
		printf("Water level is ");
		f=1.0*a[ans]+1.0*w/(ans*10*10);
		printf("%.2lf meters.\n",f);
		printf("%.2lf percent of the region is under water.\n",1.0*(ans*100)/(m*n));
		//剩下的水将会平均分到每一个格子上，共有ans个格子 
		printf("\n");//这个换行改了我好久。。。 
	}
    return 0; 
}
```
