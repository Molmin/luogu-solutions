$Part$ $I.$ 题意简述

求一个数组的最长子序列，其中这一子序列需要满足只有唯一的众数。

$Part$ $II.$ 思考过程

我们考虑一种情况：会不会存在一个序列存在一个数出现多于两次但不符合条件？

显然不存在。

我们尝试举例出一种最坏的情况，构造出这样一种序列，使得序列中出现次数最多与出现次数次多的一样多。

我在脑中想了一下，认为$[2,3,2,3]$这样的序列可能是有这么一种情况的。

但是，$[2,3,2]$就是最短的。那么我们就感性理解完毕了。

所以只要有出现多于两次的数，都能构成要求的子序列。我们取最接近的两个一样的数的距离，长度是$min(ans,$第二个数的位置$-$第一个数的位置$+1)$。

------------

怎么实现快速查找最接近的一样的数的位置？

拿个数组，记录数最后一次出现的位置，顺便统计答案。

反正数在之前就已经统计过了，保留没有用，已经一点都不靠近了，那肯定有比它优的答案。

那么只要拿现在数的位置减去上次的位置就能得到序列长度了。


$Part$ $III.$ 代码

```cpp
#include <iostream>
#include <cstdlib>
#include <cstdio>
#include <cstring>
using namespace std;
int T,n,a[200001],rec[200001],ans; a是序列 rec[i]记录i的直到k之前最后一次出现的位置
int main(void)
{
	scanf("%d",&T);
	while (T--)
	{
		scanf("%d",&n); ans=2147483647; //ans初始化为一个很大的数
		memset(rec,0,sizeof(rec)); //数组记得清零
		for (int i=1;i<=n;i++)
		{
			scanf("%d",&a[i]);
			if (rec[a[i]]!=0) ans=min(ans,(i-rec[a[i]]+1)); // rec[i]记录a[i]直到i之前最后一次出现的位置
			rec[a[i]]=i; //做完了,更新位置
		}
		if (ans==2147483647) printf("-1\n"); //没被更新过,因此输出无解
		else printf("%d\n",ans);
	}
}


```
