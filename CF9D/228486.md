这题是一道动态规划题。虽然题目中提到了树，但其实除了基本概念外和树没什么关系。

### 状态设计

发现直接推很难，怎么办？正难则反，我们定义一个数组 $dp$ ,其中 $dp[i][j]$ 表示 $i$ 个节点，高度小于等于为 $j$ 的树的个数。

### 状态转移

这一步需要费些脑筋。我们需要从 $1\rightarrow n$ 枚举左子树大小 $k$ ,再利用加乘原理转移。因为自己高度要比子树高度多 $1$，所以所以左子树大小为 $k$ 的树的个数是 $dp[k][h-1]\times dp[n-k-1][h-1]$ （由乘法原理）。接下来再把枚举的求和一遍即可。复杂度 $O(n^3)$，稳过。

最后输出的就是小于等于最大深度的减去小于等于h-1的，即 $dp[n][n]-dp[n][h-1]$

注意，注意英文原文说答案不大于 $9\cdot 10^18$,所以得开`long long`

接下来,是代码时间！
```cpp
#include<stdio.h>
long long dp[40][40];
int N,H;
int main(){
	scanf("%d%d",&N,&H);
	int i,j,k; 
	for(i=0;i<=N;++i)dp[0][i]=1;//这一步是必要的初始化 
	for(i=1;i<=N;++i)
		for(j=1;j<=N;++j)//枚举个数	 
			for(k=0;k<j;++k)//枚举左子树大小 
				dp[j][i]+=dp[k][i-1]*dp[j-k-1][i-1];//见前面的状态转移方程 
	printf("%lld\n",dp[N][N]-dp[N][H-1]);//小于等于最大深度的减去小于等于h-1的就是答案 
	return 0;
}

```