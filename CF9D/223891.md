# CF9D How many trees? 题解
##  [题目传送门](https://www.luogu.com.cn/problem/P1641)  
  ~~万恶的DP题对蒟蒻极不友好~~
  

------------

## 前言
   因为这道题思考得十分不顺畅，看看大佬们的题解，来谢谢来理清思路（题目翻译那么短就没有题意概述了吧）
   

------------

##  分析
  &nbsp;&nbsp;&nbsp;这是道组合数学题，但蒟蒻只会DP，看这么水（？）的数据，只有$ O(n^3) $时间复杂度。暴力就完事了。  
&nbsp;&nbsp;&nbsp;我们首先思考要求的是什么，N个节点的二叉树高度>=h的方案数。可是这样没有思路。那么我们可以尝试用转换为减法来求，也就是某些数相减得到。   
    ![](https://cdn.luogu.com.cn/upload/image_hosting/p40rsadq.png)  
&nbsp;&nbsp;&nbsp;经过一番思考，答案可以表示总种数和$ h- 1$相减得到.（不小于是合法，小于不就是不合法吗)  
&nbsp;&nbsp;&nbsp;那么思考可以用什么方法写出。仔细思考，发现与节点数n和高度H有关系。那么再具体点？
![](https://cdn.luogu.com.cn/upload/image_hosting/lifkmey5.png)

&nbsp;&nbsp;&nbsp;我们可以发现与左子树和右子树得到。那么左子树又可以视作另一个小二叉树。那么这与什么有关。DFS？还是——DP？这题具有最优子结构和无后效性，显然，可以用DP来做。（~~DFS，那是什么，大法师吗~~）
![](https://cdn.luogu.com.cn/upload/image_hosting/0tuniu39.png)  
&nbsp;&nbsp;&nbsp;我们可以假设左节点数为k，总结点数为n，高度为i。可以得出右子树=**n**（总结点数）-**1**（根）-**k**（左节点数）。则再一思考可以得出状态转移方程。$ dp[i][j]= \Sigma_{k=0}^{j-1}(dp[k][j-1])*dp[i-k-1][j-1] $.那么可以得出答案为dp[n][n] (总数，因为可以成一条线，所以高度为n)-&nbsp;&nbsp;&nbsp;dp[n][h-1]（不合法的总数）。  
那么我们再考虑边界。首先我们考虑dp[i][0],这是不可能的，因为有节点至少拥有一个高度；再说dp[0][i],因为图不可以为空，而二叉树在定义中有空树。空树可以定义为任何高度的二叉树。所以dp[i][0]=1.（详见维基百科）


------------

## 注意点
   1.**k要<j,因为是左子树**。  
   2.**注意赋初值**。  
   3.**注意dp过程**
   4.**注意范围**
   

------------

## 代码
``` 
  #include<bits/stdc++.h>
using namespace std;
long long  n,h,dp[111][111];
/* dp[i][j]为i个节点，j个高度的二叉树有多少种 */
int main()
{
//	freopen("trees.in","r",stdin);
//	freopen("trees.out","w",stdout);
	cin>>n>>h;
	for(int i=0;i<=n;i++)
	 dp[0][i]=1;//因为空树也是二叉树 (滑稽)
	 for(int i=1;i<=n;i++)//枚举高度，
	   for(int j=1;j<=n;j++)//枚举节点 
	      for(int k=0;k<j;k++) // 枚举左子树节点
		     dp[j][i]/*不止一种方案数，分类用加法*/+=dp[k][i-1]/*左子树*/ */*分布用乘法*/dp[j-k-1][i-1];//右子树
	cout<<dp[n][n]-dp[n][h-1]<<endl; //答案 
}
```


------------

## 总结
  曾经，Mr.liu说：“正难则反”。而我们谨记着：暴力是唯一的神。所以，当暴力与技巧相结合，配上一点点思路，这道~~水~~题就被A掉了
## 改动
   2025/5/30，更改了数学符号，增加了注意点，更改了总结。
    
