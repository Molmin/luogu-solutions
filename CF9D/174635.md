# 题解007 Cf9D
本蒟蒻的第一篇蓝题题解，求管理员大大通过，因为打算从一些有关的东西讲起，篇幅可能有点长。

## 01 前置芝士 Catalan数

[可以做这道题检验自己会不会写。](https://www.luogu.com.cn/problem/P1044)

此处我们不使用卡特兰数的基本定义，而是考虑这样一个经典的问题：

已知一棵有 $n$ 个结点的树，求有几种不同形态的树？

我们对其中的某一个节点进行分析，设这个节点的标号是 $k$ ，我们不难发现这个点的左子树标号范围是 $[1,k-1]$ ，而右子树标号范围是 $[n-k-1,n]$ ，那计算公式就呼之欲出了。

我们只要枚举 $k$ 就可以得到答案。递推公式如下:

$h_n=\sum\limits_{k=0}^{n-1}h_k*h_{n-k-1}$

(其中 $h_n$ 代表有 $n$ 个结点二叉树的方案数）

## 02 本题思路

### 这只是一般的卡特兰数吗

显然不是，因为我们除了参数 $n$ 以外还引入了一个参数 $h$ 来表示树的深度。
### 如何定义状态
我们定义 $dp[i][j]$ 来表示一个结点数量为 $i$ ，深度为 $j$ 的树的方案数。
### 如何确定转移
我们思考 $dp[i][j]$ 从哪里来，很显然，一定是从 $j-1$ 深度推出来的，而如何确认数量，则是 01 中所提到的卡特兰数递推所类似的了。

但是总之我们可以得到这样一个状态转移方程：

$dp[i][j]+=dp[k][j-1]*dp[j-k-1][j-1]$

而类似于卡特兰数的递推我们只需要从 $[0,n)$ 中枚举 $k$ 即可。

然后求出答案我们需要排除掉所有 $h_0<h$的方案数。

## 03 本体算法

### DP+递推

在 02 中我们已经阐明了思路，接下来就是代码实现了。我们首先分析数据范围，发现 $0<n<=35$ ，因此 $O(n^3)$ 算法复杂度是完全可以接受的。

之所以这么说是因为我们的算法需要枚举 $h,n,k$ 这三个参数，很显然这种算法的复杂度就是 $O(n^3)$。

而确定了算法的可行性，下面就让我们给出代码吧。

## 04 AC代码

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#define ull unsigned long long
using namespace std;
int n,h;
ull dp[40][40],ans;//范围问题会在易错点中说明
void catalan(){
    for(int i=1;i<=n;i++){
        for(int j=1;j<=n;j++){
            for(int k=0;k<=j-1;k++)
                dp[j][i]+=dp[k][i-1]*dp[j-k-1][i-1];//二维卡特兰数，增加了第二个标识量标识高度
        }
    }
}
void init(){
    scanf("%d%d",&n,&h);
    for(int i=0;i<=n;i++) dp[0][i]=1;
}
int main(){
    init();
    catalan();
    ans=dp[n][n]-dp[n][h-1];//我们排除小于目标高度的形态，然后就得到了答案。
    printf("%lld",ans);
}
```
不要抄代码，完全可以看一遍后自己写哟。

## 05 易错点

### 05.1 数据范围问题

这里给出卡特兰数的通项公式：

$Catalan_n=C^n_{2n}/{n+1}$

我们估算当 $n=35$ 的最大情况发现远远超过了 $int$ 的数据范围，所以我们应当使用 $long $ $long$ 或者是 $unsigned$ $long$ $long$。

 _本蒟蒻的第七篇题解，望管理员大大通过，同时祝看到的各位国庆，中秋快乐！！！_ 