[题链](https://www.luogu.com.cn/problem/CF9D)

> 这是一道代码不长，但有一定“思维”的题目。

## 问题转化
首先审题，发现求的是高度**不小于** $h$ 的二叉树的个数。很容易就想到方法是树形$\text{DP}$计数，但是递推方向是从树根到叶子结点，所以不容易求高度**不小于** $h$ 的二叉树的个数，所以我们要把问题转化为求高度**不大于** $h-1$ 的二叉树的个数，然后再拿二叉树总数一减就得到了答案。

## $\text{DP}$过程
我们设 $F_{i,j}$ 表示由 $j$ 个结点组成的高度**不大于** $i$ 的二叉树的个数。

枚举左子树结点个数 $k$，由于总共有 $j$ 个结点，可以算出右子树结点个数为 $j-k-1$，**注意要减一**，因为左子树与右子树的根结点的父亲（当前二叉树的根结点）要减掉。因为是计数问题，所以要把所有可能的 $k$ 算出的结果加起来。然后就可以写出递推柿子：
$$F_{i,j}=\sum_{k=0}^{j-1}F_{i-1,k}\cdot F_{i-1,j-k-1}$$

初始化由 $0$ 个结点组成的高度为 $i$ 的二叉树个数为 $1$，那便是空树。

最后必须注意$\text{DP}$数组要开 ```long long```，否则就 /dk 了。

## CODE
```cpp
#include <stdio.h>
int n, h; long long f[40][40];
int main(void) {
    scanf("%d %d", &n, &h);
    for (int i = 0; i <= n; ++i) f[i][0] = 1ll; //初始化
    for (int i = 1; i <= n; ++i) //枚举高度
        for (int j = 1; j <= n; ++j)
            for (int k = 0; k < j; ++k)
                f[i][j] += f[i - 1][k] * f[i - 1][j - k - 1]; //递推
    printf("%lld\n", f[n][n] - f[h - 1][n]);
    return 0;
}
```

## The end. Thanks.
（记得点赞