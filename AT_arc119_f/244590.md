### 前置——

首先我们要先确认如何保证在我们的一次构造中求出其最小的路径长度。

通过一个最简单的策略，我们可以直接设计一个朴素的 dp，令 $f_{x,y,z}$ 表示我们走到第 $x$ 位，离我们最近的 A 点是 $y$，B 点是 $z$。随后一步步的往前走，在出现“?”的时候保存一个 A 点的答案，再保存一个 B 点的答案。由于“?”的存在要求我们填充大量的 $y$ 和 $z$ 的位置，所以这个 dp 是 $O(n^3)$ 级别的，并不能满足我们的要求。

此时我们考虑为什么需要一个这样的转移，其原因在于“?”的存在让我们并不知道我们进入了什么样的一个区段，不知道要怎么跳跃转移，而是选择寻找所有之前的可行点。

如果我们可以约束转移的过程，等于我们明确这个图具备什么样的性质时可以是最优的，那么我们就能快速的进行转移。官方题解是直接优化转移式子。

### 但是——

**自动机**很明显是可以满足我们的需求的另一种选择。

在自动机内的转移状态被固定的时候，自动机的复杂度就只和状态数量，输入的串的长度相关。而我们需要考虑一些步数问题，那么也和我们需要转移的答案规模相关。每一次位置的移动都相当于在自动机上走一步，而“?”则代表两步都会走一次。

自动机内部的边就相当于一个很好的 dp 约束，告诉我们自动机的这个节点的答案只能转移到一个固定的位置。只要我们保证自动机的设计是能跑出最短路的，就能保证我们的答案是正确的。

接下来的问题就是自动机了。让我们来考虑一下最短路的策略。

### 分析

下文的“跳”代指走到一个和自己同类型的点，“走”代指走到一个节点。

很显然的，对于一个长序列“ABBBB...BBBA”，站在第一个 A 时最优的选择是从第一个 A 跳到下一个 A，否则我们就要走完中间的所有 B。

那么我们设计一个节点 AB...BA，表示我们在遇到一串 B 且开头为 A 的情况，对称的我们也需要 B 的节点。

此时的情况大概是这样的，感觉很好理解：

![](https://cdn.luogu.com.cn/upload/image_hosting/u6sl4tky.png)

（原谅我不会用它画自环）

在我们跳完这一步后，我们的位置到达了 A。如果这个序列在我们位置后面还有 A，如“ABBBB...BBBAAAA...AAB”我们应该选择往回走一步到 B 然后跳到下一个 B。

那么我们就要设计一些中继节点来弥补我们“不知道 A 的数量”这一件事，对于 B 我们对称的设计即可。先看图：

![](https://cdn.luogu.com.cn/upload/image_hosting/jo1ri6ed.png)

那些存在自环的节点的出边意味着他们发现了这个循环的结束。设计“AB”与“BA”节点是让我们拥有反悔的机会，“BAAAAABABBBBBBB”的最优显然不是让我们在第二个 B 的位置让我们进入循环。

如上，如果中间这一段 A 的数量过少，比起一下子跳过去我们不如一个一个跳，例如“ABBBB...BBBAAB”，在我们跳完第一次 A 后，最优的选择是走一步到下一个 A，这样我们能决定之后是跳 A 还是走 B 跳 B。此时往后走一步再跳到 B 的花费和现在是等价的。

这就必须让我们设计一个新的节点，我们让其表达“这个位置等效于既可以从 A 开始也可以从 B 开始”。有点类似于题目开头的第一个车站。

那么我们再新增一些节点——

![](https://cdn.luogu.com.cn/upload/image_hosting/ovj90ulp.png)

因为 csacademy 画二元环很丑，两个边的边权会重合在一起，所以我多加了一个“0”点，实际上它和“A/B”是一个点。

我们从“A/B”出发的时候，如果连续的遇到了一个“AB”或者“BA”，无论我们起始点是 A 还是 B，我们都能通过跳一步/走一步到到达这个状态。而一旦遇到连续的两个 A 或者 B，进入循环便是有意义的。

然而这个自动机还有一些节点在一些情况下没有出边，我们需要补充它的情况。

“AB”在下一个值是 A 的情况下代表着我们已经进入“A/B”。因为进入“AB”时，我们已经走了一步到 B，而这一步同样可以拿来跳 A。

“AA”在遇到 A 的时候应当还要走一步到“AAA”，因为“BAAABBBBBBBBBA”在我们落点到第一个 A 的时候，只需要走两步就可以到达第三个 A 从而跳到最后一个 A，而向后走一步、再跳一步、再走回来一步需要三步。这个节点的设计也一样是“后悔”，A 的数量大于三时显然可以进入循环，否则我们可以进入“A/B”的状态，因为从第一个 A 到第三个 A 和第二个 B 都是两步。

此时我们的自动机已经每一个点都拥有出边了（csacademy 已经会把这些边堆在一起了，所以手绘）：

![](https://cdn.luogu.com.cn/upload/image_hosting/0s3hm0d2.png)

“BA”和“AB”还需要往“A/B”分别连“B”和“A”边，不好改了/qd。

虽然有点复杂，但是手推一下还是很爽的。

实现的过程就非常简单了，如我们之前所说，遇到一个 A 就让每个节点的值都往 A 走一步，遇到一个 B 就让每个节点的值都往 B 走一步，“?”则各走一步。移动的时候记录一下步数，通过一步一步读入序列跑自动机，最后统计总开销小于 $k$ 的情况。起点显然是“A/B”点。最后的时间复杂度是 $O(13nk)$。其中 $13$ 是我们的节点个数。相比原本的式子，我们不再需要去枚举一个之前的点，少了维护一维的花费。

当然，实际上这张图边的边权各有差异，最后终点统计的时候也不能一下全收（在终点前不一定能到终点），这些具体数值的设定就在代码解释了。

### 码

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=4004,mod=1000000007;
int tr[14][3],f[N][14][2],pos,n,k,ans;
string s;
inline void init(){
	//边点转化为数值可以自己画画看看对应原图~这种东西大概率是没必要模仿的~
	//原始边，就是最基本的那些移动
	tr[1][1]=2;
	tr[2][1]=3;
	tr[3][2]=4;
	tr[4][2]=5;
	tr[5][2]=6;
	tr[4][1]=7;
	tr[1][2]=8;
	tr[8][2]=9;
	tr[9][1]=10;
	tr[10][1]=11;
	tr[11][1]=12;
	tr[10][2]=13;
	//循环边，两个循环节点的边
	tr[3][1]=3;
	tr[9][2]=9;
	//补偿边，多增加的那些补充部分
	tr[2][2]=1;
	tr[7][1]=3;
	tr[7][2]=1;
	tr[5][1]=7;
	tr[6][1]=1;
	tr[6][2]=9;
	tr[8][1]=1;
	tr[11][2]=13;
	tr[13][1]=1;
	tr[13][2]=9;
	tr[12][1]=3;
	tr[12][2]=1;
} 
inline void dp(int p){
	for(int i=0;i<=k+1;i++){
		for(int j=1;j<=13;j++){
			int to=tr[j][p],val=1;
			if(to==3||to==1||to==9||j==9||j==3){
				val=0;//我定义进出循环节点和进入A/B节点是不需要花费的，这样子很好理解。
			}else if(0){
				val=-1;//原本觉得会有边是这个样子的……
			}else{
				val=1;//正常边都要这么跑
			}
			if(i+val>=0){
				f[i+val][to][pos^1]+=f[i][j][pos];
				f[i+val][to][pos^1]%=mod;
			}
		}
	}
}
signed main(){
	cin>>n>>k;
	init();
	cin>>s;
	f[0][1][0]=1;//第i位的第j个节点走了k步的情况
	for(int i=0;i<s.size();i++,pos^=1){
		if(s[i]=='A'){
			dp(1);
		}else if(s[i]=='B'){
			dp(2);
		}else{
			dp(1);
			dp(2);
		}
		for(int j=0;j<=k+1;j++){
			for(int l=1;l<=13;l++){
				f[j][l][pos]=0;
			}
		}
	}
	for(int i=1;i<=k+1;i++){
		for(int j=1;j<=13;j++){
			if(j==3||j==9||j==12||j==6||j==13||j==7||j==8||j==2){
				if(i<=k){
					ans+=f[i][j][pos];//这些节点多存了一点贡献，他们不需要花费新的。
				}
			}else{
				if(i<k){
					ans+=f[i][j][pos];//其他的节点就需要多走一步进入终点
				}
			}
		}
		ans%=mod;
	}
	cout<<ans;
	return 0;
}
```

然后我们就解决了！

特在此感谢 [p_b_p_b](https://www.luogu.com.cn/user/76481) 和 [namelessgugugu](https://www.luogu.com.cn/user/244204) 对我的指导，没有二位就没有这篇题解。