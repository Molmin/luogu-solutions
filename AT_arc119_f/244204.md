很搞不懂为什么另一篇题解要感谢我，但总之写一下自己的做法。

#### 题意

有 $n + 1$ 个点，编号 $0 \sim n$，每个点是 A 型点或 B 型点中的一个（特别地，点 $0$ 和点 $n$ 同时是 AB 型点），点 $i$ 与点 $i + 1$ 之间有一条双向边，每个点与编号比它大的第一个同类型点之间也有一条双向边（例如 A 型点是 $0, 2, 7, n$，则会有边 $(0 ,2), (2, 7), (7, n)$）。

这 $n + 1$ 个点中，有一些点的类型已经确定，有一些还没有确定，求有多少种确定点的类型的方案使得从 $0$ 到 $n$ 的最短路长度不超过 $m$，答案对 $10^9 + 7$ 取模。

$1 \leq n \leq 4000, 1 \leq m \leq \frac{n + 1}{2}$。

#### 题解

先考虑如果所有点的类型都确定了要怎么判定。

把走一条 $(i, i + 1)$ 的边称作走，走同类型之间的边称作跳。

思考最短路可能长什么样，首先每次使用跳跃一定是跳过一整段另一种类型的连续段，而唯一可能往回走的情况是刚刚跳完一次，然后往回走一步走到另一种类型的点，方便继续跳出去。不然的话，可以发现往回走多了总会走到自己曾经到过的点，因此是不优的。

于是发现只需要记录几个信息就能做到判定：只考虑前 $i$ 个点时，第 $i$ 个点是什么类型，从起点到当前最后一个 A 型点的最短路距离，和到最后一个 B 型点的最短路距离。

这个信息也是容易做到转移的，不妨设第 $i$ 个点是 A 类型，两个距离分别是 $d_A, d_B$，则如果 $i + 1$ 是 A 类型，则新的距离 $d_A' = d_A + 1, d_B' = d_B$，否则 $d_A' = \min\{d_A, d_B + 2\}, d_B' = \min\{d_A + 1, d_B + 1\}$。

如果 $i = n - 1$ 时 $\min\{d_A, d_B\} < m$，说明这是一个合法的方案。

于是我们会简单的判定了，而且这个东西是容易套上 DP 的，直接令 $f_{i ,j, k, ty}$ 表示考虑到前 $i$ 个点，两个距离分别是 $j, k$，第 $i$ 个点的类型是 $ty$ 时的方案数即可做到 $O(n^3)$ 的复杂度。

尝试化简状态，还是不妨设 $ty = A$，则会有 $j \geq k - 1$，因为这个 $j$ 其实是从最后一个 B 后面的 A 一步一步走过来的，而设起点到在这个 B 后面的这个 A 的最短路是 $x$，则有 $j \geq x$ 而 $x + 1 \geq k$，所以有 $j \geq k - 1$。同时发现如果 $j$ 比 $k$ 大太多的话，在下一次遇到 B 型点的时候这个 $j$ 就没有用了，而如果一直不遇见 B 型点，最后统计答案时查 $\min\{j, k\}$ 肯定也和 $j$ 没啥关系。具体来说，如果 $j > k + 2$，那么和 $j = k + 2$ 是一样的，可以压进一个状态里。$ty = B$ 同理。

所以，实际上有效的状态被压到了 $O(n ^ 2)$，而转移还是 $O(1)$ 的，故复杂度降到了 $O(n ^ 2)$，可以通过。

#### 代码

```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
const int N = 2015, mod = 1000000007;
int n, m;
char s[N << 1];
int f[2][N][7][2];
inline int &getf(int o, int x, int y, int ty)
{
	x = std::min(x, y + 2), y = std::min(y, x + 2);
	return f[o][x][y - x + 2][ty];
}
inline void update(int &x, int v)
{
	x = (x + v) % mod;
	return;
}
int main(void)
{
	scanf("%d%d%s", &n, &m, s + 1), --n;
	f[0][0][2][0] = 1;
	for(int i = 0, o = 0;i < n;++i, o ^= 1)
	{
		memset(f[o ^ 1], 0, sizeof(f[o ^ 1]));
		for(int j = 0;j <= m + 2;++j)
			for(int k = j - 2;k <= j + 2;++k)
			{
				if(s[i + 1] != 'B')
				{
					update(getf(o ^ 1, j + 1, k, 0), getf(o, j, k, 0));
					update(getf(o ^ 1, std::min(j + 1, k + 1), std::min(j + 2, k), 0), getf(o, j, k, 1));
				}
				if(s[i + 1] != 'A')
				{
					update(getf(o ^ 1, j, k + 1, 1), getf(o, j, k, 1));
					update(getf(o ^ 1, std::min(k + 2, j), std::min(k + 1, j + 1), 1), getf(o, j, k, 0));
				}
			}
	}
	int ans = 0;
	for(int i = 0;i <= m + 2;++i)
		for(int j = i - 2;j <= i + 2;++j)
			if(std::min(i, j) + 1 <= m)
				ans = (1ll * ans + getf(n & 1, i, j, 0) + getf(n & 1, i, j, 1)) % mod;
	printf("%d\n", ans);
	return 0;
}
```