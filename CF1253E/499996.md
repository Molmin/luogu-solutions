题解里的其它做法都好精妙啊，我来一种好想的 $O(n^2m)$ 做法吧（3 秒的时限不慌）。

看着 $n$ 那么小，考虑把 $n$ 放进状态里。$f(i, j)$ 表示覆盖到 $i$，$i$ 被第 $j$ 个覆盖缩需要的最小代价。然后分成两种情况，第一种是 $a_j \le i$，即第 $j$ 个天线在 $i$ 之前，另一种是在其后面。

对于后面的情况，如果前面也是用天线 $j$ 来覆盖，那么就不需要再加了，因为一定已经覆盖到当前了。否则枚举之前使用的天线 $k$，有转移 $f(i, j) \leftarrow f(i-1, k) + a_j - i - s_j$，即把天线 $j$ 操作到可以覆盖当前的位置。

对于前面的情况，我们就不能这样去转移了，因为往后拓展的时候可能会多覆盖到前面，花费会变得更小，所以得从当前点关于 $a_j$ 的对称点转移过来。即 $f(i, j) \leftarrow f(2a_j-i-1, k) + i - a_j - s_i$。

但是还有一种特殊情况要考虑（感谢样例四，不然我还真发现不了），天线为了覆盖到一个点，是可以多覆盖一点东西的。对于第二种情况，这表现为 $a_j$ 更接近 $i$ 而不是更接近 $1$ 时可能是直接把 $1 \to 2a_j-1$ 整段盖过。对于前面一种情况，不存在需要特殊照顾的情况，前面已经覆盖到了，而往后多的后面会考虑。所以只要加一个特判即可。

~~这个做法其实跑得挺快，最优解第四十九页。~~


```cpp
void main() {
	std::cin >> n >> m;
	for (int i = 1; i <= n; i++) std::cin >> a[i] >> s[i];
	memset(f, 0x3f, sizeof f);
	for (int i = 1; i <= m; i++)
	    for (int j = 1; j <= n; j++)
	        if (a[j] <= i) 
	            for (int k = 1; k <= n; k++) {
    	            int w = std::max(i - a[j] - s[j], 0);
    	            if (2 * a[j] - i - 1 > 0) w += f[2 * a[j] - i - 1][k];
    	            f[i][j] = std::min(f[i][j], w);	            
    	            if (i - a[j] < a[j]) // 那个特判
        	            f[i][j] = std::min(f[i][j], std::max(0, a[j]-s[j]-1));
    	        }
    	    else {
    	        if (i != 1) f[i][j] = std::min(f[i][j], f[i-1][j]);
    	        for (int k = 1; k <= n; k++)
    	            f[i][j] = std::min(f[i][j], 
    	            ((i-1) ? f[i-1][k] : 0) + std::max(a[j]-i-s[j], 0));
    	    }
    std::cout << *std::min_element(f[m] + 1, f[m] + 1 + n); 
}
```