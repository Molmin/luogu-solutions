逛了下题解发现有许多大佬用差分做，但本蒟蒻想不到差分，于是只能纯模拟了 qwq

## 题目大意：

给定一个字符串 $s$，对其进行 $m$ 次操作，第 $i$ 次操作给一个数字 $a_i$，表示将字符串 $s$ 的第 $x$ 个位置到第 $len - x + 1$ 这段字翻转，求 $m$ 次操作后的结果。

## 思路与实现：

本题要求从 $x$ 到 $len - x + 1$ 的位置调换，那我们可以分别处理前半部分和后半部分：每读入一个 $a_i$ 就判断这个 $a_i$ 是在字符串的前半部分还是后半部分，如果是后半部分就从字符串的一半开始模拟，否则就从字符串的开头开始模拟，每次判断如果 $a_i > j$ 就交换 $a_i$ 和 $a_{len-i+1}$ 的位置，最后输出得到的字符串即可。

具体而言，实现时可以按照以下步骤进行：

读入字符串 $s$ 和操作次数 $m$；

对于每次操作，读入数字 $a_i$，并根据其在前半部分还是后半部分进行模拟；
 
对于每次模拟，从头或尾开始遍历字符串 $s$，对于位置 $i$，如果 $i \le j$，则直接跳过；

否则，交换 $s_i$ 和 $s_{len-i+1}$ 的位置；重复步骤 $2$-$3$，直到进行完 $m$ 次操作；输出最终得到的字符串。

这里就不放全部代码了，只放模拟前半部分的函数了：

## 部分代码
```cpp
void str_ans1(){
	for(int i=0;i<b;i++){
		for(int j=0;j<=c;j++){
			if(a[i]-1<=j){//因为题目中是按第一个字母是a[1]来作为输入参照的，但字符串输入默认是从a[0]开始，所以判断时要-1
				swap(q[j],q[d-j+1]);
			}
		}
	}
	return;
}
//在上述代码中：q是输入也是目标字符串，b为操作次数，a[i]为每一次操作需要翻转的位置，d是字符串q的长度，c=d/2
```
