考虑本题的数据结构意义：给定一个长度为 $n$ 的静态序列，请你选择若干个区间并预处理出这些区间中元素的和，使得任意一个预处理区间都能被分解为 $2$ 个更小的预处理区间的无交并，且任意一个询问区间都能被分解为 $\leq k$ 个你预处理出的区间的无交并，需要使得你预处理出的区间个数 $\leq\lambda n$.

当 $k=1$ 时，显然只能预处理出所有的区间，个数为 $\mathcal{O}(n^2)$.

当 $k=2$ 时，考虑猫树分治：选定一个位置 $p$，预处理出 $[1,p]$ 的所有后缀和 $[p+1,n]$ 的所有前缀，这样一来，所有包含 $p$ 或 $p+1$ 的区间都能 $2$ 分解；然后，再递归到 $[1,p-1]$ 和 $[p+2,n]$ 两侧作相同处理.

设 $F_2(n)$ 是长度为 $n$ 的分治代价，则有 $F_2(n)=F_2(\lfloor\dfrac n2\rfloor-1)+F_2(\lceil\dfrac n2\rceil-1)+(n-2)$，解得 $F_2(n)=\mathcal{O}(n\log n)$，其常数刚好可以被接受.

当 $k=3$ 时，考虑由乃救爷爷的做法：将序列分为若干块，对于每块处理出其总和以及其所有前缀、后缀的和；对于询问跨块的情况，可以掐掉一段前缀和一段后缀，转化为整块的情况；除此以外，还有询问塞进块内部的情况.

比如说以 $\sqrt n$  为大小分块，会得到 $\sqrt n$ 块：预处理出前缀后缀需要 $\mathcal{O}(n)$ 个；对于跨块的情况，由于掐掉前缀后缀已经消耗掉了 $2$ 个区间，所以必须预处理出所有的整块的区间，总计 $\mathcal{O}(n)$ 个；对于塞进块内部的情况，相当于又转化为了 $\sqrt n$ 个规模为 $\sqrt n$ 的 $k=3$ 的子问题.

我们得到 $F_3(n)=\sqrt n\cdot F_3(\sqrt n)+\mathcal{O}(n)$，解得 $F_3(n)=\mathcal{O}(n\log\log n)$；同理，可以解得 $F_4(n)=F_5(n)=\mathcal{O}(n\log^{\star}n)$，$F_6(n)=F_7(n)=\mathcal{O}(n\log^{\star\star}n)$，以此类推.

想要得到好的常数需要精细实现：设将序列分为了 $m$ 块，其大小分别为 $a_1,a_2,\cdots,a_m$，考虑 $a_i$ 的贡献：若 $a_i=1$ 则贡献为 $0$，否则预处理前缀后缀需要 $2a_i-3$，块内部还需要 $F_k(a_i-2)$；对于 $a_1$ 和 $a_m$ 来说，只需预处理出后缀/前缀，需要 $(a_i-1)+F_k(a_i-1)$；整块的部分还需要 $F_{k-2}(m-2)$，因为已经消耗掉了 $2$ 个区间.

也就是说，$F_k(n)=\min\{F_k(a_1-1)+F_k(a_m-1)+(a_1+a_m-2)+\sum\limits_{i=2}^{m-1}(F_k(a_i-2)+(2a_i-3))\}$.

显然，可以使用动态规划求出最优的 $F_k(n)$，但是其时间复杂度难以被接受，需要使用剪枝.

我所应用的剪枝如下：(1) 令 $a_2,a_3,\cdots,a_{m-1}$ 的极差 $\leq1$；(2) 令 $|a_1-a_m|\leq1$；(3) 一定有 $F_k(n)$ 的最优决策 $a_1$ 与 $F_k(n-1)$ 的最优决策 $a_1$ 之间差的绝对值 $\leq\mathcal{O}(1)$.

在剪枝之后就无法得到真正最优的 $F_k(n)$，但可以得到一个满足题目所要求常数的解.

该算法的时间复杂度为 $\mathcal{O}(n^2k)$，空间复杂度为 $\mathcal{O}(nk)$.

代码实现(具有极其严重的个人风格)：https://www.luogu.com.cn/paste/m4he787l.