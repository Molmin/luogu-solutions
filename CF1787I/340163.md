每一个区间的贡献具有条件限制，看上去比较麻烦。虽然做到这题的不可能看不出来这俩东西可以拆开，多少还是证一下。首先如果 $[s,t]$ 是区间的最大子段和，如果 $q \in [s,t)$，那么 $q'=t$ 一定比当前的 $q$ 更优。因此一个区间的贡献相当于区间的最大前缀和加上区间的最大子段和。

这显然是两个独立的问题，考虑分别计算。

首先考虑计算区间的最大前缀和之和。先计算序列的前缀和，一段区间的和为 $s_r-s_{l-1}$。固定左端点，需要计算 $\displaystyle \sum_{r=l}^n \max(0,s[l,r]-s_{l-1})$（其中 $s[l,r]$ 为区间 $[l,r]$ 内 $s$ 的最大值）。这样维护一个单调不增的单调栈，可以维护当前左端点右边的每个点选取的 $s$ 值。将上面合式的形式写成所有大于 $s_{l-1}$ 的 $s[l,r]$ 之和 $p$，并计算大于 $s_{l-1}$ 的 $s[l,r]$ 的 $r$ 的个数 $q$，左端点为 $l$ 的区间的总贡献即为 $p-qs_{l-1}$。

注意到我们已经维护单调栈，可以直接在单调栈上二分就行。

接下来是每个区间的最大子段和问题。直接考虑对序列分治，分跨过中点，全在左区间，全在右区间计算。对于后面两种实际上是子问题，只考虑跨过中点的区间的贡献。记中点为 $p$。预处理 $f$，$f_i(i \leq p)$ 表示 $[i,p]$ 这一段的最大子段和，$f_i(i > p)$ 表示 $[p+1,i]$ 这一段的最大子段和；预处理 $g_i(i \leq p)$ 表示 $[i,p]$ 这一段最大的后缀和，$g_i(i > p)$ 表示 $[p+1,i]$ 这一段的最大前缀和。那么区间 $[l,r]$ 的最大子段和就是 $\max(f_l,f_r,g_l+g_r)$。

注意到 $f,g$ 在两边均有单调性。枚举左端点，用两个指针维护选取 $f_l,g_l+g_r,f_r$ 的范围即可。

[评测链接](https://codeforces.com/problemset/submission/1787/193128878)