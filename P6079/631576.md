# [Milk Team Select G](https://www.luogu.com.cn/problem/P6079)
校内模拟赛的唯一一道树上问题，写个题解纪念一下~~比赛的时候因为一行代码挂了 64 分，我%…*&…》￥@！~~。
# 题意简明
把母女关系用一个森林表示出来。如果我们选出的点之间有直接连边的话，就会存在一个血缘关系。求出在选出的节点权值之和不小于 $x$ 的情况下，选出的节点中最多有多少对点在树上有连边。

# 思路分析
如果是森林的话不太好处理，可以把所有没有母亲的节点连向一个编号为 0 的源点，此时树形 DP 的思路其实已经很明显了。

## 状态
直接猜状态，由于最多的血缘关系数不好直接求，所以我们设 $dp_{i,j}$ 为以 $i$ 为根的子树中恰好有 $j$ 对血缘关系时的最大产奶量。为了方便，我们多加一维，记录 $i$ 有没有被选中。即 $dp_{i,j,0/1}$ 表示 $i$ 被选中或没被选中时分别的最大产奶量。

## 答案
我们发现这个状态刚好和根节点 0 不能选对接上了。所以最终答案就是使 $dp_{0,j,0} \ge x$ 的 $j$ 的最大值。

## 方程
先贴代码~~懒得写公式了~~：
```cpp
dp[u][j][0]=max(dp[u][j][0],dp[u][k][0]+max(dp[v][j-k][1],dp[v][j-k][0]));//u不选
dp[u][j][1]=max(dp[u][j][1],dp[u][k][1]+dp[v][j-k][0]);//u选v不选
if(j-k-1>=0)
	dp[u][j][1]=max(dp[u][j][1],dp[u][k][1]+dp[v][j-k-1][1]);//u选v选
```
稍微解释下：$u$ 是当前遍历到的节点，$v$ 是 $u$ 的其中一个子节点，$k$ 是一个血缘关系数，把以 $u$ 为根的子树中 $k$ 个关系时的最大值和以 $v$ 为根的子树中 $j-k$ 个关系时的最大值合并，以达到状态转移的效果。分别对应的情况是：

- $u$ 不选 $v$ 不选和 $u$ 不选 $v$ 选。（可以直接取 $\max$）
- $u$ 选 $v$ 不选。
- $u$ 选 $v$ 选。这个需要特殊注意：如果都选的话，$u$ 和 $v$ 之间会多产生一条边，则给 $v$ 的子树只留下了 $j-k-1$ 条关系供选择，才能满足总数为 $j$。

## 初始值
- $dp_{i,0,0}=0$
- $dp_{i,0,1}=a_i$

# 一些细节
- 因为产奶量可能为负数，所以 $dp$ 数组赋为 $-inf$。
- 状态转移中的 $j$ 和 $k$ 本应该从 $i$ 的子树大小开始枚举，这里我偷一下懒直接从 $n-1$ 枚举到 0。
- 在第三类转移的时候要特判 $j-k-1 \ge 0$。

然后就是快乐的代码时间！
# 代码实现
```
#include <bits/stdc++.h>
using namespace std;
int n,m,tot,a[505],head[505],dp[505][505][2];
struct edge
{
	int next,to;
}e[250005];
void add_edge(int u,int v)
{
	e[++tot].next=head[u];
	e[tot].to=v;
	head[u]=tot;
}
void dfs(int u)
{
	dp[u][0][1]=a[u];
	dp[u][0][0]=0;
	for(int i=head[u];i;i=e[i].next)
	{
		int v=e[i].to;
		dfs(v);
		for(int j=n-1;j>=0;j--)
		{
			for(int k=j;k>=0;k--)
			{
				dp[u][j][0]=max(dp[u][j][0],dp[u][k][0]+max(dp[v][j-k][1],dp[v][j-k][0]));
				dp[u][j][1]=max(dp[u][j][1],dp[u][k][1]+dp[v][j-k][0]);
				if(j-k-1>=0)
					dp[u][j][1]=max(dp[u][j][1],dp[u][k][1]+dp[v][j-k-1][1]);
			}
		}
	}
}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)
	{
		int x;
		scanf("%d%d",&a[i],&x);
		add_edge(x,i);
	}
	memset(dp,-0x3f,sizeof dp);
	dfs(0);
	for(int i=n-1;i>=0;i--)
	{
		if(dp[0][i][0]>=m)
		{
			printf("%d",i);
			return 0;
		}
	}
	printf("-1");
}
```
制作不易，希望本片题解可以帮到大家！