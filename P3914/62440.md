题目：[P3914](https://www.luogu.com.cn/problem/P3914)

## 1. 前言

本题思维简单，但是思维过程和转移方程可以说是树形DP中比较具有代(mu)表(ban)性的，因此在这里着重讨论思维过程以及正确性的证明。

## 2. 思维过程

~~实际上是树形DP的接近模板的题~~

观察题目，给出一棵树，每个节点有若干个可用的颜色，任意相邻节点颜色不能相同，求总共的染色方案数。

对于计数类问题实际上很容易可以想到递推。首先，对于一棵无根树，任意指定一个节点$root$为根，然后按照一棵有根树进行处理。

而关于相邻节点不能同色的限制，实际上可以转化为：**在树上任意节点与它的子节点的颜色不能相同**。

容易发现，在此题中，每个叶子节点染色的总方案数是已知的，而如果假定该图是菊花图，即存在一个节点$p$，当以$p$为根时它的每个儿子都是叶子节点。那么总方案数就是把每个节点分别染色的方案数的乘积，减去$P$的颜色与其每个子节点发生冲突的情况总数的总和。把该方案数设为$S_p$。

实际上对于上述情况，只需要$O(nm)$的时间遍历父节点的颜色并分别处理每个子节点的冲突情况，即可运用排列组合的思想求解。

那么如何将上述方法进一步推广呢？可以假定存在若干个类似$P$的节点$p_1,p_2,...,p_k$，它们有共同的父节点$i$，则我们可以用上述方法分别求出**以$p_i$为根的子树**染色的方案数，在计算$S_i$时，我们实际上只关心每棵子树的方案数以及该子树的根节点的颜色，而不关心该子树下其它节点的颜色。因此，可以设$F_{i,j}$表示**以$i$为根的子树在把$i$染色为$j$时的染色方案数**。对于$i$不允许的染的颜色$j$，$F_{i,j}=0$。于是：

$$S_p=\sum_{j=1}^m F_{p,j}$$

同样考虑遍历$i$的颜色，则如果$\forall p \in son(i)$，$F_p$的每一项及$S_p$已被正确求出，那么有：

$$F_{i,j}=\prod_{p \in son(i)} S_p - F_{p,j}$$

通俗地说，也就是运用乘法和减法原理，对于每个以子节点$p$为根的子树，求出这个子树在$i$染色为$j$时的可行方案数（也就是总方案数减去$p$染色为$j$的不可行方案数），最后将所有子树的可行方案数相乘即可。

在推出$i$之后，同样可以把与$i$有关的值保存下来，来推出以$i$的父节点为根的子树的染色方案数。以此类推，最后即可得到**以整棵树的根节点为根的子树的总方案数**即$S_{root}$，也就是整个问题的解。

容易发现，对于任何一个节点$i$，推出$F_i$的每一项的时间复杂度为$O(|son(i)|*m)$，而$\sum_{i \in V} |son(i)|+1=N$，因此总共的时间复杂度为$O(nm)$。

实际上，上述思想就是**自底向上的树形DP**的一种。

## 3. 实现

经过计算，输入数据最多可能达到30MB左右，因此需要使用快读。

而对于我们刚才所说的自底向上遍历，可以使用一遍DFS解决，也就是优先**遍历每个儿子$p$，递归求出$F_p$的每一项及$S_p$**；之后根据这个儿子的子树的方案数更新自身子树的方案数。遍历完所有儿子后，再根据已经求出的不同颜色的方案数进行求和。

然后是DP起点，也就是叶子节点的问题。实际上我们可以直接在输入某个节点$i$可以染的颜色$j$时，使$F_{i,j}=1$；对于其余的$j$，使$F_{i,j}=0$。那么就有以下两种情况：

1. $i$是叶子节点，此时以$i$为根而将$i$染色为$j$的方案只有$1$种，符合题意；对于不允许的颜色，方案为$0$种，符合题意。

2. $i$不是叶子节点，此时如果$i$可以染色为$j$，则根据乘法原理初始时应有$F_{i,j}=1$，最后连乘得到实际方案数，符合题意；对于不允许的颜色，无论怎样连乘，最终一定有$F_{i,j}=0$，符合题意。

在取模问题上，由于我们实际得到的$S_p$是已经经过取模才存储的，因此可能会出现$S_p-F_{p,j}<0$的情况，而对于负数的取模会被错误地转化成绝对值取模最后再加上负号。因此我们可以加上一个$10^9+7$再取模，即可变为正数取模且结果正确。

以及乘法溢出和在无根树上存图及DFS的一些细节，参见注释。

```cpp
#include<iostream>
#include<fstream>
#include<algorithm>
#include<cstring>
#include<cmath>
using namespace std;

const int mod=1e9+7;
int n,m,x,y,tot,f[5010][5010],s[5010];
//邻接表建图模板 
//注意无根树中边数=2n-2 
int head[10010],ver[10010],Next[10010];
inline void add(int x,int y){
	ver[++tot]=y,Next[tot]=head[x],head[x]=tot;
}
//快读优化时间常数 
inline void read(int &a){
    char c=getchar();
	int x=0, f=1;
    while(!isdigit(c)) f=(c=='-'?-1:f),c=getchar();
    while(isdigit(c)) x=x*10+c-'0',c=getchar();
    a=x*f;
}
//DFS进行树形DP 
inline void dfs(int x,int fa){
	for(int i=head[x];i;i=Next[i]){
		int y=ver[i];
		//注意：在无根树上有几率遍历到父节点需要舍去  
		if(y==fa) continue;
		//递归 
		dfs(y,x);
		//此时关于y的方案数已经求出，运用组合数原理更新自身 
		//注意取模以及将两个int型相乘需要临时转为long long的问题  
		for(int j=1;j<=m;j++) f[x][j]=((long long)f[x][j]*(s[y]-f[y][j]+mod)%mod)%mod;
	}
	//求和 
	for(int j=1;j<=m;j++) s[x]=(s[x]+f[x][j])%mod;
}
int main(){
	read(n),read(m); 
	for(int i=1;i<=n;i++){
		read(x);
		while(x--) read(y),f[i][y]=1;
	}
	for(int i=1;i<n;i++){
		read(x),read(y);
		add(x,y);
		add(y,x);
	} dfs(1,0); //任意指定1号节点为根  
	cout<<s[1];
	return 0;
}
```