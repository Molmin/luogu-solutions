~~本来想写dp，结果边写边优化就成了递推~~

把FGHABCD依次编为1~7号~~不按字母顺序是因为之前是写dp~~

下面是几个优化：

- 走的步数多了是因为往回走了，所以总共的步数是偶数。n为奇数时直接输出0。

- 一次走两步可以避免走到编号为奇数的点。~~（我也不知道自己怎么想到这么写的）~~

- 向两边走是等效的，于是就只要计算一边的方案数再乘2输出。

~~（于是dp就写成了递推）~~


代码细节：走两步有两种方法可以回到原来的地方，要记得乘2。


[AC](https://www.luogu.org/record/23885258)代码如下：（127ms）
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a,b;
int main()
{
	b=1;
	scanf("%d",&n);
	if(n&1)				//是奇数
	{
		putchar(48);		//输出0
		return 0;
	}
	n>>=1;				//一次走两步
	for(int i=1;i<n;i++)		//最后还要留两步去终点
	{
		a=(a<<1)+b;
		b+=a;
		while(a>999)a-=1000;	//取模，直接模比较慢
		while(b>999)b-=1000;
	}
	if((a=a<<1)>999)a-=1000;	//乘2
	printf("%d",a);			//输出
	return 0;
}
```
