## [洛谷传送门](https://www.luogu.com.cn/problem/P2233)
### 作为一位 HN OIer ，当然要为 HN 的省选的题目写题解。
## 思路
显然可以递推求方案数。

但是太慢，考虑使用矩阵乘法加速递推。

我们可以把整个路线看成一张图。

从 $n$ 号点出发，就可以到 $n - 1$ 或 $n + 1$ 号点。

于是单位矩阵就很容易的构造出来了。

$$\begin{Bmatrix}
&0 &1 &0 &0 &0 &0 &0 &1\\

&1 &0 &1 &0 &0 &0 &0 &0\\

&0 &1 &0 &1 &0 &0 &0 &0\\

&0 &0 &1 &0 &1 &0 &0 &0\\

&0 &0 &0 &1 &0 &1 &0 &0\\

&0 &0 &0 &0 &1 &0 &1 &0\\

&0 &0 &0 &0 &0 &1 &0 &1\\

&1 &0 &0 &0 &0 &0 &1 &0
\end{Bmatrix}$$

但是交上去是错的。

仔细观察题面，有一句话。

**注意 tiger 一旦到达公交站 E，他不会愚蠢到再去换车**

所以公交站 E **不会到 D 和 F** 。

所以单位矩阵应该是这样的。

$$\begin{Bmatrix}
&0 &1 &0 &0 &0 &0 &0 &1\\

&1 &0 &1 &0 &0 &0 &0 &0\\

&0 &1 &0 &1 &0 &0 &0 &0\\

&0 &0 &1 &0 &0 &0 &0 &0\\

&0 &0 &0 &1 &0 &1 &0 &0\\

&0 &0 &0 &0 &0 &0 &1 &0\\

&0 &0 &0 &0 &0 &1 &0 &1\\

&1 &0 &0 &0 &0 &0 &1 &0
\end{Bmatrix}$$

要换 $n$ 次车，所以应该是单位矩阵的 $n$ 次方。

直接套矩乘快速幂模板即可。

## $code$
~~~cpp
#include <iostream>

using namespace std;

const int Mod = 1000;
int a[8][8], b[8][8], c[8][8];  //a单位矩阵，b结果矩阵，c运算矩阵
int n;

void Mul(int a[8][8], int b[8][8]) {  //矩阵乘法
  for (int i = 0; i < 8; i++) {
    for (int j = 0; j < 8; j++) {
      c[i][j] = 0;
      for (int k = 0; k < 8; k++) {
        c[i][j] = (c[i][j] + a[i][k] * b[k][j] % Mod) % Mod;
      }
    }
  }
}

void Make() {  //构造单位矩阵和结果矩阵
  for (int i = 0; i < 7; i++) {
    a[i + 1][i] = a[i][i + 1] = b[i + 1][i] = b[i][i + 1] = 1;
  }
  a[4][3] = a[4][5] = b[4][3] = b[4][5] = 0;
  a[0][7] = a[7][0] = b[0][7] = b[7][0] = 1;
  n--;  //结果矩阵初始有1次幂，所以总次幂减1
}

void Fast_Power() {  //快速幂运算
  for (int i = 1; i <= n; i <<= 1) {
    if (n & i) {
      Mul(b, a);
      copy(&c[0][0], &c[0][0] + 8 * 8, &b[0][0]);  //将答案复制到答案矩阵
    }
    Mul(a, a);  //权重平方
    copy(&c[0][0], &c[0][0] + 8 * 8, &a[0][0]);
  }
}

int main() {
  cin >> n;
  Make();
  Fast_Power();
  cout << b[0][4];  //A为0，E为4，答案就在(0,4)
  return 0;
}
~~~