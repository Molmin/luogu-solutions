**这题其实非常简单，并不需要用到矩阵快速幂进行优化，只需要一个简单的 dp**

如果 $n$ 为奇数，显然方案数为 $0$

当 $n$ 为偶数时怎么办呢？

我们用 $0$ 表示车站 A，$1$ 表示车站 B，……，$7$ 表示车站 H。

那么车站 E 对应的数字就是 $4$。

数组 $dp[i][j]$ 表示在第 $i$ 次换车时在第 $j$ 个车站。

我们可以很快得到一个递推式：$dp[i][j]=dp[i-1][j-1]+dp[i-1][j+1]$。

其中出现的 $8$ 替换为 $0$，$7$ 替换为 $1$。

答案就是 $dp[n][4]$.

这时候我们运行代码

输入：`6`

输出：`12`

结果：WA 

再仔细读题我们发现**到达车站 E 后就不能再换乘了**，所以需要作一些修改。

$dp[i][3]$ 的值应为 $dp[i-1][2]$，$dp[i][5]$ 的值应为 $dp[i-1][6]。$

时间复杂度为 $O(8n)$，可以通过。

然而 $n$ 很大，如果正常地开数组可能会 MLE。

我们发现每次换乘时仅需要用到上一次换乘时的情况，因此可以**压位**。

AC 代码：

```c++
#include<bits/stdc++.h>
using namespace std;
int n,dp[2][8],p=1,q=0;
int main() {
	scanf("%d",&n);
	if(n%2==1) printf("0\n");
	else {
		dp[0][0]=1;
		for(int i=1;i<=n;++i) {
			for(int j=0;j<=7;++j) {
				dp[p][j]=0;
				if(j!=3) dp[p][j]+=dp[q][(j+1)%8];
				if(j!=5) dp[p][j]+=dp[q][(j+7)%8];
				dp[p][j]%=1000;
			}
			p^=1,q^=1;
		}
		printf("%d\n",dp[0][4]);
	}
	return 0;
}
```