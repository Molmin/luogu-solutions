~~分治啥玩意，又不能吃~~

思路：

大约是打表，因为$n$很小，而且只可能是二的幂：
- 如果$n=16$那么判断$0$到$15$是否单调递增，如果是，直接输出$16$并结束
- 如果$n\ge8$那么判断$0$到$7$和$8$到$15$是否单调递增，如果是，直接输出$8$并结束
- 如果$n\ge4$那么判断$0$到$3$、$4$到$7$、$8$到$11$、$12$到$15$是否单调递增，如果是，直接输出$4$并结束
- 以此类推，如果都没有直接输出$1$。

首先放出判断单调递增的函数：
```cpp
bool f(int l,int len){//左端点和长度
	if(l>=n)return 0;//如果不在范围内返回0（这个十分重要）
	for(int i=l+1;i<l+len;i++)
		if(a[i-1]>a[i])return 0;//如果不单调递增返回0
	return 1;//单调递增返回1
}
```

那么我们只需要调用函数，多次判断即可（强迫症福利）：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[16];//零浪费
bool f(int l,int len){//判断单调递增的函数
	if(l>=n)return 0;
	for(int i=l+1;i<l+len;i++)
		if(a[i-1]>a[i])return 0;
	return 1;
}
int main(){
	cin>>n;
	for(int i=0;i<n;i++)cin>>a[i];
	if(n==16)if(f(0,16)                                                           ){cout<<0x10;return 0;}//如果=16（16进制输出只是为了对齐
	if(n>=8) if(f(0,8 )||                        f(8,8)                           ){cout<<0x08;return 0;}//>=8的情况
	if(n>=4) if(f(0,4 )||        f(4,4)||        f(8,4)||         f(12,4)         ){cout<<0x04;return 0;}//>=4的情况
	if(n>=2) if(f(0,2 )||f(2,2)||f(4,2)||f(6,2)||f(8,2)||f(10,2)||f(12,2)||f(14,2)){cout<<0x02;return 0;}//>=2的情况
	puts("1");//都没有
}
```