### 思路

贪心思路非常好想，在桶里放满银木板（但是要留一个空给金木板）然后用金木板把里面的银木板全部清掉，然后再放满银木板....

这样，第一次就可以放进去 $z-1$ 块木板，第二次可以放 $z-2$ 块木板，以此类推。

然后我们就可以用**等差数列**来求这个，公式非常好推。但是有几个注意的点：

- 如果金木板的数量比桶一次能装下的木板数要多，直接输出 Merry ，因为金木板放进去就不能放出来了。

- 在执行贪心操作当中，可能当中不会有足够的金木板（比如说在某一次操作没有金木板让里面的银木板出来了）所以得在等差数列公式上考虑到这个，你只能放到 $z-x$ 块木板。

- 如果上面两个都没问题，就判断银木板是不是可以全部都放进桶就行了。

根据思路我们可以得出首项是 $z-x$ ，末项是 $z-1$ ，而且最后放完金木板还可以再放 $z-x$ 块银木板，所以推出: $\dfrac{((z-x)+(z-1))\times ((z-1)-(z-x)+1)}{2} + (z-x)$ 

化简可得最多可以放入的银木板数量是：

$\dfrac{(2\times z-x-1)\times x}{2} + (z-x)$

最后再与 y 作比较就可以了。

### 代码

知道公式就很简单了，全程开 long long 注意。

```cpp
#include<bits/stdc++.h>
using namespace std;
int tt;long long x,y,z;long long now;
int main(){
	cin>>tt;
	while(tt--){
		cin>>x>>y>>z;
		if(x>z)cout<<"Merry"<<endl; //如果连金木板都放不下
		else{
            now=(2*z-x-1)*x/2+(z-x); //刚刚推的公式
            if(now<y)cout<<"Merry"<<endl;
			else cout<<"Renko"<<endl;
		}
	}
	return 0;
}
```

总之仔细就是了。

**谢谢大家的阅读**