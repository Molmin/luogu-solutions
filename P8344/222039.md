## 简要题意  
有 $x$ 个金色木板，$y$ 个银色木板，还有一个可放下 $z$ 个木板的空容器。每向容器中放入一个金色木板后，会丢弃容器内所有银色木板（需要确保在放金色木板前，容器里至少还能再放得下一个木板）。问是否存在一种方式，使得所有木板都被放进过容器中。
## 核心思路   
我们如果把每放一块金色木板视为一次操作，我们很容易想到，对于每一次操作，我们应该放尽可能多的银色木板后再放一块金色木板清空，那么，我们可以将整个过程划分为 $x$ 次操作。  
对于每一次操作，有如下规律：     
第 $1$ 次操作，最多能放 $z-1$ 块银色木板，再放 $1$ 块金色木板清空，此时容器内放有 $1$ 块木板；  
第 $2$ 次操作，最多能放 $z-2$ 块银色木板，再放 $1$ 块金色木板清空，此时容器内放有 $2$ 块木板；  
第 $x$ 次操作，最多能放 $z-x$ 块银色木板，再放 $1$ 块金色木板清空，此时容器内放有 $x$ 块木板。    
值得一提的是，我们其实还可以在第 $x$ 次操作后，再进行第 $x+1$ 次操作，但不清空（因为金色木板已放完），即再放下 $z-x$ 块银色木板，此时容器装满。  
可以证明，这是放置木板的最优方案。   
可以发现，放下的银色木板数量呈等差数列，此时，一共放下 $\dfrac{[(z - 1) + (z - x)]\, \times \,x}{2}+ (z-x)$ 块银色木板。  
所以我们只需要判断两个条件：
1. $x$ 是否小于等于 $z$ ；
2. 在进行 $x+1$ 次操作后银色木板是否被放完。  
如果这两个条件均满足，则可以放下，输出 `Renko` ，否则输出 `Merry` 。   
注意：本题数据规模较大，请使用**long long**类型的整型变量。
## $\text{std}$:
```cpp
#include<iostream>
#include<cstdio>
using namespace std;
long long t, x, y, z;
int main() {
	scanf("%lld", &t);
	for (long long i = 1; i <= t; ++i) {
		scanf("%lld%lld%lld", &x, &y, &z);
		if(x <= z && (z - 1 + z - x) * x / 2 + z - x >= y) printf("Renko\n");
		else printf("Merry\n");
		}
	return 0;
}
```
