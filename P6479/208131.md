这题数据~~并不是很强~~啊。。。所以只有**入门的难度**而已。。。

题意是非常清晰的，在看完题目之后只要知道几点就可以写了：

1.每次有诗人出现（即1号村民），就必定会增加一首歌，并且这首歌每一个村民在夜晚前都不会，夜晚后只有参与了夜晚的村民会。

2.若没有诗人，那么每一个村民的状态在参与该夜晚后都是一样的。如有4个村民，题目的状态分别是:

```3 0 1 0 0 0 0 1 1```

```2 0 0 1 0 0 0 1 0```

```4 0 1 0 0 0 1 1 1```

```4 0 1 0 1 0 1 0 1```

那么夜晚结束之后肯定都变成：

```6 0 1 1 1 0 1 1 1```

实现此操作只需要记录每一首有村民会的歌，然后再叠加到每一个村民上即可。

3.最后输出的时候，需要输出每一首都会的村民，其实就是会的歌数等于歌总数的村民，所以用```num[1...n][0]```记录每一个村民会的歌总数即可。

有了以上思路，这题就很 _水_ 了（~~**其实本来就很水，暴力也可以过，n才100啊**~~）

## 下面是AC代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,k,sum,a[105],known[105],num[105][105];
//k是每次村民数，sum是歌总数； 
//a是数组每次来的村民； 
//known数组是每次没有诗人时至少有一个村民会的歌； 
//num数组记录每一个村民会的歌（num[1...n][0]是对应村民会的歌总数）。 
bool flag;
//flag记录是否有诗人出现 
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=m;i++)
	{
		flag=false;//初始化flag,flag=false没有诗人,flag=true有诗人 
		scanf("%d",&k);
		for(int j=1;j<=k;j++)
		{
			scanf("%d",&a[j]);//读入 
			if(a[j]==1)	flag=true;//有诗人则标记 
		}
		if(flag)//有诗人 
		{
			sum++;//有诗人，那么肯定会多一首歌 
			for(int j=1;j<=k;j++)	num[a[j]][0]++,num[a[j]][sum]=1;//每一个在场的村民都会这首新歌 
		}
		else//无诗人 
		{
			for(int j=1;j<=k;j++)	for(int l=1;l<=sum;l++)	if(num[a[j]][l])	known[l]=1;
			//记录至少有一个村民会的歌 
			for(int j=1;j<=k;j++)	for(int l=1;l<=sum;l++)	if(known[l] && !num[a[j]][l])	num[a[j]][0]++,num[a[j]][l]=1;
			//如果某歌有村民会并且该村民不会，标记。 
		}
	}
	for(int i=1;i<=n;i++)	if(num[i][0]==sum)	printf("%d\n",i);//若总数相同，输出 
}
```
