## AT2034 LRU パズル / LRU Puzzle题解
补远古 AGC 发现的思维神题... 我题解看了差不多断断续续下午才看懂那个 $k$ 是咋突然冒出来的，可能这就是菜吧... 因为你谷没题解，所以来水一发。~~什么只有三个人做过，那没事了。~~

### 题意
[洛谷传送门](https://www.luogu.com.cn/problem/AT2034) [AT传送门](https://atcoder.jp/contests/code-festival-2016-quala/tasks/codefestival_2016_qualA_e)

给出 $N$ 个长为 $M$ 的数组，刚开始每个数组里面都是 $(1,2,3,\cdot\cdot\cdot,M)$ 。给出一个长为 $Q$ 的操作序列 $a$ ，其中 $a_i$ 表示对于一个数组，我们把 $a_i$ 这个数提到第一位。我们要顺次执行完所有的操作，每次操作可以对任意一个数组施加，求能否使操作完后所有的数组都相同。($2\le N,M\le10^5,1\le Q\le10^5,1\le a_i\le M$)

### 题解
好吧，我承认我语文很差，所以翻译的玩意您们可能看不懂/kk 。所以我们再来形式化解释一下题意，正好方便后续的解释。我们设 $f_M(a)$ 表示对于长为 $M$ 的初始数组依次施加 $a$ 序列操作后得到的序列。比如如果 $M=6,a=(6,3,1,3,6,3)$ ，则 $f_M(a)=(3,6,1,2,4,5)$ （手玩一下应该没啥问题）。有个很简单 ~~(但是挺不好想的方法)~~ 来求解 $f_M(a)$，我们定义一个辅助数组 $b$ ，一开始为空。倒序遍历 $a$ 序列，如果当前正在处理的 $a_i$ 在 $b$ 中没出现过，就把它加到末尾，否则啥也不干。遍历过后，我们把剩下的没有出现过的 $1-M$ 之间的数字以递增的顺序加到 $b$ 末尾，这样之后就满足 $f_M(a)=b$ 。经过这样转化后，原问题就是：
>给一个操作序列 $a$ ，问能不能把 $a$ 分为若干个子序列 $a_1,a_2,a_3,\cdot\cdot\cdot,a_n$ ，使得 $f_M(a_1)=f_M(a_2)=f_M(a_3)=\cdot\cdot\cdot=f_M(a_N)$ 。

接下来我们注意到，如果 $f_M(a_1)=f_M(a_2)=f_M(a_3)=\cdot\cdot\cdot=f_M(a_N)$ ，则 $f_M(a_1)$ 的第一个元素应该与 $f_M(a)$ 的第一个元素相等，否则因为 $a_i$ 是 $a$ 的子序列，一定存在一个数组第一个元素与 $f_M(a)$ 的相同，与 $f_M(a_i)=f_(a_1)$ 矛盾。按照这个道理，我们可以发现，$f_M(a_1)$ 的第二，第三……个元素都应该与 $f_M(a)$ 的相同。再推广一下，就能得到新的题意：
>给一个操作序列 $a$ ，问能不能把 $a$ 分为若干个子序列 $a_1,a_2,a_3,\cdot\cdot\cdot,a_n$ ，使得 $f_M(a_1)=f_M(a_2)=f_M(a_3)=\cdot\cdot\cdot=f_M(a_N)=f_M(a)$ 。

比如我们还看刚刚的例子 $M=6,a=(6,3,1,3,6,3)$，我们可以把 $a_1=(6,3,3),a_2=(1,6,3)$ 这样分为两个部分，这样 $f_M(a_1)=f_M(a_2)=f_M(a)$ 。

秉着从简单到复杂的原则，我们先来看 $N=2$ 的情况。首先我们按照上述方法算出 $f_M(a)$ （其实也可以边做边算，之后在代码里面说吧）。然后我们设 $b_1,b_2$ 分别表示 $f_M(a_1),f_M(a_2)$ 计算过程中的辅助数组，我们的算法就是在把 $a$ 分为 $a_1,a_2$ 的过程中同时求出 $b_1,b_2$ 。因为我们想让遍历之后的 $b_1,b_2$ 在满足是 $f_M(a)$ 前缀的条件下，尽可能的长（这样才能尽可能靠近 $f_M(a)$），所以我们可以采取以下贪心做法，依然是倒序遍历 $a$ 。
- 如果当前的 $a_i$ 既不在 $b_1$ 中也不在 $b_2$ 中，就把它加到 $b_1$ 末尾。
- 不失一般性，我们假设 $a_i$ 在 $b_1$ 中而不在 $b_2$ 中，则如果能满足加到 $b_2$ 里面后不破坏 $b_2$ 是 $f_M(a)$ 前缀的性质，就加到 $b_2$ 末尾。
- 如果 $a_i$ 既在 $b_1$ 也在 $b_2$ 就啥也不干。

这些做完之后，我们把 $b_1,b_2$ 扩展到 $M$ 的长度，然后比较是否存在 $b_1=b_2=f_M(a)$ 。最终可以做到 $\mathcal{O}(M+Q)$ 的复杂度。

接下来考虑把这个算法推广到 $N\ge 2$ 的情况。首先我们还是先计算 $f_M(a)$ ，并设 $b_1,b_2,b_3,\cdot\cdot\cdot,b_N$ 分别表示 $f_M(a_1),f_M(a_2),f_M(a_3),\cdot\cdot\cdot,f_M(a_N)$ 的辅助数组。然后依然是倒序遍历 $a$ ，对于每个 $a_i$ ，找到一个 $b_j$ 满足 $b_j$ 中不含有 $a_i$ 且把 $a_i$ 加到 $b_j$ 末尾不破坏 $b_j$ 的前缀性质，然后把 $a_i$ 加到 $b_j$ 末尾。最后把所有的 $b$ 扩展到 $M$ 的长度，并比较是否存在 $b_1=b_2=b_3=\cdot\cdot\cdot=f_M(a)$ 。但非常遗憾，朴素的实现是 $\mathcal{O}(MN+NQ)$ 的复杂度，显然不能接受。

这里给粗一种可能的优化方式。因为所有的 $b$ 都是前缀，内容不重要，重要的是长度。所以我们设 $freq$ 数组，定义为：
$$freq_k=\text{在所有的}b_i\text{中长度恰好为}k\text{的个数}$$
刚开始显然 $freq_0=N,freq_i=0(0<i\le M)$ ，因为所有的 $b$ 都是空的。则当我们遍历到 $a_i$ ，需要把 $a_i$ 加到长度恰好为 $k$ 的 $b_j$ 后面（英语题解这里 $k$ 突然冒出来把我晕了好久，其实就是对着 $f_M(a)$ 看，$a_i$ 该加到哪个位置了，然后就能对应出来 $k$），那如果 $freq_k\ge 1$ ，我们就把 $freq_k$ 减一，$freq_{k+1}$ 加一，否则啥也不干。这样遍历完之后，我们就得到了 $b$ 数组的长度。如果还是朴素的根据前缀扩展每个 $b$ 然后暴力比较，依然会逃不掉 $\mathcal{O}(NM)$ 的瓶颈。注意到如果长度最小的 $b_j$ 都满足 $b_j=f_M(a)$ ，则长度更大的 $b$ 也一定满足，因为 **确定的前缀越多，表示限制越大，与 $f_M(a)$ 相等的可能就更大** 。这样我们只需要把最短的 $b$ 给扩展并比较就好了，最终时间复杂度 $\mathcal{O}(M+Q)$ ，足以通过本题。（题解给的复杂度 $\mathcal{O}(N+M+Q)$，至少我的理解和我的实现里面都没有那个 $N$ ，不太清楚题解的想法）。

### 代码
有人可能发现我的内容跟 AT 的题解差不多，对此我想说：确实。主要是英语题解不太好理解，所以我突发奇想翻译一下。好的，上代码了，一些细节代码里面吧。
```cpp
//奇短的代码
#include <cstdio>
const int N = 1e5 + 10; int q[N], fM[N], sq[N], bk[N];
int main()
{
	int n, m, Q; scanf("%d%d%d", &n, &m, &Q);
	for (int i = 1; i <= Q; ++i) scanf("%d", &q[i]);
	sq[0] = n; int frt = 0, minx;
	for (int i = Q, pos; i >= 1; --i)
	{
		//边做边求fM
		if (!(pos = bk[q[i]])) pos = bk[q[i]] = ++frt, fM[frt] = q[i];
		if (sq[pos - 1]) --sq[pos - 1], ++sq[pos];
	}
	for (int i = 1; i <= m; ++i) if (!bk[i]) bk[i] = ++frt, fM[frt] = i;
	for (int i = 0; i <= m; ++i) if (sq[i]) { minx = i; break; }
	//没必要求完，其实只需要检验一下需要补的位置是不是严格单调递增就好了
	for (int i = minx + 2; i <= m; ++i)
		if (fM[i] < fM[i - 1]) { printf("No\n"); return 0; }
	printf("Yes\n"); return 0;
}
```
