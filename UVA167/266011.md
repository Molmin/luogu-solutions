>这里是墨攸，平生没有什么爱好，就喜欢刷灰题

# 前排提醒：输出有毒！

1. **是对于每一个棋盘，输出一个答案，而不是把所有棋盘的答案加起来再输出！**

2. **每次输出要多输出五个空格！！！**（这谁想得到啊woc）

翻了UVA的原题才知道的...

## 做法

其实不考虑输出的坑的话，这题就很简单了。话说这是八皇后原题诶...只不过每个点位带上了一个权值。

使用深搜dfs来搜出每一种出现的情况，然后在所有情况里选答案的最大值即可。

**如果有不会八皇后的我还是提一下吧：（会的DALAO就可以跳过了）**

我们的深搜仅传两个值，一个是当前行数，一个是当前选取总和。

每一次递归即递归到下一行，当然选取的总和也要加上我们之前选的点。

上面这个很好理解，关键是判断皇后是否会互相攻击。

我们可以建立三个$bool$数组，分别判断列（$l$数组），左上到右下的对角线（$d$数组），右上到坐下的对角线（$c$数组），看这些位置是否被占用了。

列很好解决，如果我们发现第$i$列未被占用，直接$l[i] = true$

关键在于对角线如何处理。

对于右上到坐下的对角线，我们很容易发现：同一条对角线上，行数+列数的值是相等的。

那这样就很简单了：假设我们在$x$行$i$列，这里未被占用，我们就可以直接$c[i+x] = true$ 了。

对于左上到右下的对角线，我们同样也可以发现：同一条对角线上，行数-列数的值是相等的。

这样，处理方法就和上面差不多了，但是这里要注意：行数-列数可能小于零。所以我们要同时加上一个较大值保证数组下标不为负。（这里我选了$8$，因为$8$就是棋盘边长）。

判断都出来了，问题还不好解决吗？

直接上代码吧：

## $Code$

```cpp
#include<bits/stdc++.h>
#define AC puts("AC!qaq!");
#define inf 0x3f3f3f3f

using namespace std;

int k, ans;
bool l[10], c[20], d[20]; // l:↓ c:↙ d:↗ 
int a[10][10]; //记录每个点上的权值 

void dfs(int x, int sum) //这应该是最简单类型的dfs了 
{
	if(x == 9) {ans = max(ans, sum); return;} //这里直接取最优值 
	for(int i = 1; i <= 8; i ++) //枚举列数 
		if(!l[i] && !c[x + i] && !d[8 + x - i])
		{
			l[i] = c[x + i] = d[8 + x - i] = true;
			dfs(x + 1, sum + a[x][i]);
			l[i] = c[x + i] = d[8 + x - i] = false;
		}
}

int main()
{
	scanf("%d", &k);
	while(k --)
	{
		memset(l, 0, sizeof(l)); 
		memset(c, 0, sizeof(c));
		memset(d, 0, sizeof(d));
		ans = 0; //多测不清空，爆零两行泪 
		for(int i = 1; i <= 8; i ++)
			for(int j = 1; j <= 8; j ++)
				scanf("%d", &a[i][j]);
		dfs(1, 0);
		printf("%5d\n", ans); //输出的坑啊... 
	}
	
	return 0;
}
```