这时一篇非常详细的，比较清楚的题解（~~自我认为的~~）。
### 小贴士
前置知识 djikstra 算法可以点这里进行学习[P3771](https://www.luogu.com.cn/problem/P3371)。或者这里[P4779](https://www.luogu.com.cn/problem/P4779)。
## 题意
即给出一个含有 $N(1 \leq N \leq 100)$ 个数的序列 $A$，将序列中每个元素 $a_i$ 到 $a_i-M$ 之间的数加入序列 $A$（包括 $a_i-M$），然后算出最大不可被序列 $A$ 表示的数（当一个数可由该序列中的可重复的元素相加得到时，该数可以被表示）。
### 思路的开始
先从特殊开始，假如序列 $A$ 中只存在两个元素。

容易发现，假如有一个元素数值为 $x$，那么 $x$ 的所有倍数将会成为可以被表示的数。 

此时若序列中还存在一个元素 $y(x<y)$，设可以被表示的数为 $ z $，那么有等式 $ ax+by=z $，其中 $a,b$ 为任意自然数（即可以为 $0$）~~（用扩展欧几里得定理！bushi）~~。则可以变换一下等式，变为：

$$ by\equiv z \pmod x$$ 

那么也就是说 $z$ 与 $by$ 同余(这里要注意 $z \geq by$)，这启发我们用到刚刚提到的剩余类 $z$ 与 $by$ 同属在取模 $x$ 意义下的同一个同余类。

接下来就是本题解的需要思考重点了！

**我们发现 在正整数域对于任意一个剩余类中的可以被表示的正整数 $z$，都可以使 $z+ax$（$a$ 为任意正整数）这个数也能被表示（即这个剩余类中所有大于等于 $z$ 的整数都可以被表示），那么如果我们找到这个剩余类中最小的正整数 $z$ 那我们不就可以找到最大的不可被表示的数了吗？**

**因为这个剩余类中所有大于等于 $z$ 的整数都可以被表示，那么并且 $z$ 本身就是最小的可以被表示的数，所以 $z-x$ 为最大不可被表示的数，因为在取模 $x$ 意义下的所有剩余类覆盖整个正整数集合，那么我们只需要找到对于每个剩余类中最小的可以被表示的数 $z$ ，那么我们就能求到所有剩余类中的最大不可被表示的数，然后其中肯定有我们要的答案。**

### 思路的发展

 令 $ rm=y \bmod  x,mc=y / x$ 当 $b=1$ 时，我们可以知道所有大于等于 $rm\cdot x+c$ 且取余 $x$ 为 $c$ 的数都可以被表示（即此时暂时认为 $rm\cdot x+c$ 为该剩余类中最小可被表示的数），此时若想要得到得到这个值，我们需要从 $0$ 开始加上表示大小的 $rm\cdot x$ 然后再加上表示哪个剩余类的 $mc$，我们可以以此更新剩余类 $mc$ 中的最小值，这时就要用到最短路算法了，我们把每个剩余类当作一个节点，用路径长度表示该剩余类中最小可被表示的数的大小，那么我们就是要求从源点 $0$ 到所有点的最短路。

那么换个表示方法讲解，我们可以用 $dis_{mc}$ 表示在取模 $x$ 意义下 $mc$ 的剩余类，其到源点的距离为 $rm$（加上了多少个 $x$）。

这时如果要通过这个 $dis_{mc}$ 扩展到别的地方，我们可以通过加上另一个可以被表示的数来进行转移，我们知道每个 $dis_{mc}$ 其实本质上都是由序列 $A$ 中的元素相加得到的，那么我们可以直接通过加上 $A$ 中的元素进行转移（注意现在在考虑只有两个元素的情况，所以直接用 $y$ 来表示这个元素），假如 $y=rm_{1}\cdot x+mc_{1}$，那么我们可以写出扩展方式：
$$dis_{(mc + mc_{1} ) \mod x}=dis_{mc} + ( mc + mc_{1} )\div x + rm_{1}$$

 _PS:注意这里 $( mc + mc_{1} )\div x$ 容易漏掉，因为没有考虑到在余数相加时大于 $x$ 的情况。_ 

### 最终解法

其实经过上面的叙述后，在元素数量大于2的情况也已经可见一斑了，我们只需要找到一个作为标准的 $x$，然后用其他元素进行扩展，显而易见，我们的图中的节点数是为 $x-1$ 的，所以我们使 $x$ 取尽量小的值时，我们就可以减少时间复杂度 ~~（其实没有减少多少）~~。

我们用 $rm_i$ 表示第某个其他元素除以 $x$ 的商，其余数为 $i$，为了贪点复杂度，这里应尽量使 $rm_i$ 最小，我们只需要在每个元素除以 $x$ 后取最小值就好了。

那么依据上文转移就写成了：

$$dis_{(mc_{i}+mc_{j})\mod x}=dis_{mc_{i}}+(mc_i+mc_j)\div x+rm_j $$

### 关于-1的情况
- 存在可以用的单位为 $1$ 的栅栏
>如果存在一个可以用的栅栏（可能是被削后的）为 $1$ 时，即不存在任何不能被表示的数时，输出 $-1$。

- 所有数的 $\gcd$ 不为 $1$ 时，输出 $-1$。
>这时最大值可能无限大，其实证法挺简单的，假如所有数的 $\gcd$ 大于 $1$，应为所有可以被表示的数一定都为 $\gcd$ 的倍数，若 $\gcd$ 不为 $1$，那么可以说明存在无限个不可被表示的数（只要满足不是 $\gcd$ 的倍数就行了），此时也不可填满所有剩余类，不过其实这个不需要在意，因为题目要求 $m>0$，所以一定存在两个相邻的正整数，它们是一定互质的，此时 $\gcd$ 为 $1$。

# Code
```cpp
#include <bits/stdc++.h>
using namespace std;
#define pii pair<int,int>
int n, m, a[3001], dis[3001], rm[3001], mc[3001], cnt;
bool vis[3001];
int Min = 3001, ans;
priority_queue<pii, vector<pii>, greater<pii> >q;
int main()
{
	scanf("%d%d", &n, &m);
	for (int i = 1; i <= n; i++)
	{
		scanf("%d", &a[i]);
		Min = min(Min, a[i]);
	}
	/*以最小值为标准*/
	Min -= m;
	/*存在可用栅栏（可能是被削后的）为1时，输出-1*/
	if (Min <= 1)
	{
		printf("-1");
		return 0;
	}
	for (int i = 1; i < Min; i++) 
		dis[i] = rm[i] = 3001;
	/*找到最小的剩余类扩展方式或者是图中的边权*/
	for (int i = 1; i <= n; i++) 
		for (int j = 0; j <= m; j++)
			rm[(a[i] - j) % Min] = min(rm[(a[i] - j) % Min], (a[i] - j) / Min);
    /*找到对于rm[i]的最小的商*/
	for (int i = 1; i < Min; i++)
		if (rm[i] != 3001) 
			mc[++cnt] = i;
	q.push(make_pair(0,0));	
	while (!q.empty())
	{
		pii x = q.top();
		int k = x.second;
		q.pop();
		if (vis[k])continue;
		vis[k] = true;
		for (int i = 1; i <= cnt; i++)
			if (dis[(mc[i] + k) % Min] > dis[k] + rm[mc[i]] + (mc[i] + k) / Min)
			{
				/*dis[(i+j)%x] = dis[i] + (i+j)/x + rm[j]*/
				dis[(mc[i] + k) % Min] = dis[k] + rm[mc[i]] + (mc[i] + k) / Min ;
				q.push(make_pair(dis[(mc[i] + k) % Min], (mc[i] + k) % Min));
			}
	}
	for (int i = 1; i < Min; i++) 
	{
		/*if (dis[i] == 3001) {
			printf("-1");
			return 0;
			//剩余类未被填满时
		}因为M>0，所以被予考虑*/
		ans = max(ans, (dis[i] - 1) * Min + i);
	}
	printf("%d", ans);
	finish /(^v^)/
	return 0;
}


```
## 吐槽 & 总结
这个题目挺好的，但数据太水了，我写的时候看到自己A了9个点，本以为只是一些小错误，结果竟然是将 pair 的两个关键字写反了。 

这道题目主要考察对数字相加和取模的理解，其实考虑到这个其他就迎刃而解了，是一道非常好的题目 ~~（词穷）~~。