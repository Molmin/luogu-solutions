首先声明一点，这篇题解只是我看了别人的题解后自己的一些见解，还有为什么用   scanf 会 wa 一个点我改了好久qwq

看到题面，自己写几个数一次一次试就可以发现，购买外卖的次数和能在家的天数是两头低，中间高的一个图像（题解里说是什么单峰的函数，但小学数学水平的我不懂），这时候二分的话很显然会出错，因为二分适用于类似于单调函数的情况，那么这时候就需要三分来解决这个问题，因为求的是能宅的天数，那我们就来三分购买外卖的次数，计算每一种购买外卖次数的最优解，然后不断三分范围求出解就好了。

要想计算每一种购买外卖次数的最优解就要用到贪心了（不看标签我我就爆搜了）我们需要先按价格排序，价格相同比保质期（毕竟咱不是多有钱），从价钱最低的外卖开始买就好了，一直买到没钱或者说一份也买不起就退出循环，还要把每次购买剩下的钱加起来再去循环，然后看看哪一种能在家颓废的天数最多，返回相应的天数就好了，根据返回的天数来判断应该往哪里缩小范围，三分继续求解，直到不能再分为止。

代码：

```cpp
#include<bits/stdc++.h>
#define int long long//用这个下面int main要改成signed main 
using namespace std;
struct sss{
	int p,s;//p是价钱，s是保质期 
}e[10010];
int m,f,n,l,r,midl,midr,ans1;//l是左边界，r是右边界，mindl是三分后的左边界，midr是三分后的右边界 
bool cmp(sss a,sss b)//结构体比较函数 
{
	if(a.p!=b.p)return a.p<b.p;//金钱至上，先买便宜的 
	return a.s>b.s;//一样贵就买保质期长的 
}
int mai(int x)//买x次 
{
	int v,ans,now,w,k,p,j;
	v=m-x*f;//先减去邮费 
	w=v/x;//计算每一次可以花多少钱 
	k=v-w*x;//计算有没有剩下的，就是上面那步余下的 
	ans=0;now=0;//初始化 
	if(v<0)return 0;//单单是邮费就付不起，没钱点外卖 
	for(int i=1;i<=n;i++)//n种食物依次枚举 
	{
		if(e[i].s>=now&&w-e[i].p>=0)//如果当前食物过不了保质期并且钱够买至少一份 
		{
			p=min(e[i].s+1-now,w/e[i].p);//p存放最多可以买的第i种外卖，因为一次买的不能超过保质期，不然就坏了，所以取保质期和能买的较小值 
			now+=p;//接下来p天宅在家吃第i种外卖 
			w-=p*e[i].p;//减去花费的钱 
		}
		j=i;//记录当前已经买了多少种外卖 
		if(w-e[i].p<0)break;//买不起了就退出循环 
	}
	k+=x*w;//加上每天买外卖剩下的钱 
	for(int i=j;i<=n;i++)//从之前买不起的外卖接着买 
	{
		if(e[i].s>=now&&k-e[i].p>=0)//同样的，不过保质期，至少能买一种 
		{
			p=k/e[i].p;//计算能买几件外卖，k/e[i].p是当前钱能买的数量 
			ans+=p;//加上能买的数量 
			k-=p*e[i].p;//减去买外卖花的钱 
		}
		if(ans)break;//只要ans有值余额肯定不够买下一种的了，直接退出 
	}
	return x*now+ans;//返回k撑的天数和买第一次选择的外卖撑的天数 
}
signed main()
{
	cin>>m>>f>>n; 
	for(int i=1;i<=n;i++)
	  cin>>e[i].p>>e[i].s;///输入每一件外卖的价钱，保质期 
	sort(e+1,e+n+1,cmp);//排序 
	l=1;//左边界，最少买一次 
	if(f!=0) r=m/f+1;//计算最多可以买多少次的外卖 
	else r=m+1;//当包邮的时候特判一下，最多可以买m+1次（没准有1块的外卖
	while(l<r)
	{
		midl=l+(r-l)/3;//三分找到新的左边界 
		midr=r-(r-l)/3;//找右边界 
		if(mai(midl)>=mai(midr))//如果midl左边界撑的天数不小于midr右边界撑的天数 
		r=midr-1;//证明右边界取大了，右边界左移 
		else l=midl+1;//反之就是左边界取小了，左边界右移 
	}
	cout<<max(mai(l),mai(r))<<endl;//输出l和r中次数可以颓的久的天数（其实l==r了 
	return 0;//好习惯 
}
```
