应该是你谷首篇有证明的题解吧。这题虽然很容易 **猜** 到做法，但是认真证明的话还是挺难的，紫题当之无愧。

证明后的复杂度可以做到优于现行全体题解。

另外，部分题解其实是有误的，应该可以卡掉，但是我太懒不想卡。本文中给出了其错误方式，如果有读完本文且有兴趣去卡的读者可以试一试。

------

首先第一个观察是我们不会点了单然后不吃。这意味着每次点单都必然对应了某一天。

第二个观察是前一次点单的食物不会拖到后一次点单后再去吃（这样把它调整到后一次点单再来点必然合法）。进而一次点单，必然解决且仅解决点单时刻直到下一次点单前的生理需求。

于是我们考虑用一个函数 $f_1(x)$ 表示仅以一次点单，解决 $x$ 天内的生理需求，所需要的最少代价。

如何求出 $f_1(x)$ 呢？其实只要贪心。假如有一种食物，它保质期短还贵，我们显然不如选那些又长又便宜的食物。于是我们可以按照保质期排序后关于代价跑一个单调栈，就能求出最好的食物的备选集合，其中所有食物的价值随着保质期延长而单调增。

设这些食物分别为 $(a_1,b_1),(a_2,b_2),\dots,(a_k,b_k)$，其中 $a_i$ 表示第 $i$ 种食物的保质期加一（实际意义是该食物能满足前 $a_i$ 天的食物需求），$b_i$ 表示其价值，且按照 $a$ 严格递增排序（按照我们上述结论，此时 $b$ 亦为严格递增）。我们认为 $a_0=0$。

那么，我们显然会在 $(a_{0},a_1]$ 间用第一种食物满足，$(a_1,a_2]$ 用第二种，……，$(a_{k-1},a_k]$ 用第 $k$ 种。

翻译成数学语言，就是对于 $x\in(a_{i-1},a_i],f_1(x)=f_1(x-1)+b_i$。我们认为 $f_1(0)=F$，其中 $F$ 为题目中给出的每次点单的外卖费。 同时，对于 $x>a_k$，我们认为 $f_1(x)=+\infty$。

因为 $b_i$ 单调增，所以整个 $f_1$ 在平面直角坐标系中，应该是一个下凸壳。

这个凸壳上只有整点，不太优雅。我们认为，非整数处的 $f_1(x)$ 也是有意义的：其函数图像为前后两个整点间连线。显然，这样扩张定义域后，其仍然是凸的。

现在考虑点单 $p$ 次的结果 $f_p(x)$。这其实就是 $k$ 个 $f_1$ 凸壳作闵可夫斯基和的结果。因为 $f_1(x)$ 均是凸的，所以由凸包闵可夫斯基和相关性质，我们可以发现 $f_p(x)$ 的函数图像即为 $f_1(x)$ 上所有点的横纵坐标各自扩大 $p$ 倍的结果。

我们考虑点单 $p$ 次，使用 $m$ 的预算，所能达到的最大 $x$。其实就是 $f_p(x)$ 的函数图像与直线 $y=m$ 的交点的横坐标，记作 $g(p)$。

该横坐标可能非整数；但是我们认为其是 **有效** 的，最终求出的答案也可能是非整数，此时下取整即得真实答案。

显然，我们要求的，就是对于 $p$ 为一切正整数，求出 $g(p)$ 的最大值。

我们考虑将 $p$ 的定义域扩张为一切正实数。此时 $f_p$ 的定义仍是 $f_1$ 上所有点的横纵坐标各自扩大 $p$ 倍的结果，且其仍然是合理的定义。

这样之后，我们考虑 $g(p)$：发现，其实际上可以被写作 $f_1(x)$ 与直线 $y=\dfrac mp$ 的交点的横坐标，乘以 $p$ 倍的结果。

对于 $f_1(x)$ 上任一一点 $(x,y)$（除 $(0,F)$ 以外），我们都可以找到其对应的直线 $y=\dfrac mp$（此时 $p=\dfrac my$）。于是有 $(x,y)$ 对应了 $g(\dfrac my)=m\times\dfrac xy$。

我们发现，$\dfrac xy$ 即为点 $(x,y)$ 与原点连线的斜率的倒数。而本题中一个第一象限中的下凸壳 $f_1(x)$，其上点与原点连线的斜率，在原点到该凸壳的切点处取得最小值，自切点向左向右 **严格** 递增。取倒数后，我们发现这意味着 $g(p)$ 其实亦是一个 **严格** 的单峰函数。当然也有可能存在的不是一个切点，而是一条切线段，此时切线段中所有 $g(p)$ 均相同，两端的 $g(p)$ 亦是严格递减。但不管是哪种，都是可以三分的。（但是，这里的三分必须是在 **实数域** 上三分，整数域上的三分还是会出现两个三分点处的 $g$ 值相等进而无法判定最值到底在哪侧；因此，部分题解中的整数三分写法其实是 **有误** 的。）

当然我们亦可以不三分，直接找切点。这亦是简单的：切点其实必为 $f_1(x)$ 上的那些斜率改变的“拐点”，其实就是 $a_1,a_2,\dots,a_k$。直接去找这些拐点然后求最小斜率即可找到切点。

切点对应的 $\dfrac my$ 不一定是整数值，此时要找到向下向上取整后的 $g$ 值的较大者。

复杂度可以做到除排序严格线性。

代码中理论会乘出 $10^{54}$ 级别的东西进而爆 `__int128`，但是实际因为数据水所以过去了。好孩子不要学。

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef __int128 ii;
int n,tp;
ll ex,m;
ii res;
pair<ll,ll>p[210];
ii f[210];
ii g(ll x){
	if(m<=f[0]*x||!x)return 0;
	for(int i=1;i<=tp;i++)
		if(f[i-1]*x<=m&&m<=f[i]*x)
			return p[i-1].first*x+(m-f[i-1]*x)/p[i].second;
	return p[tp].first*x;
}
int main(){
	scanf("%lld%lld%d",&m,&ex,&n);
	for(int i=1;i<=n;i++)scanf("%lld%lld",&p[i].second,&p[i].first),p[i].first++;
	sort(p+1,p+n+1);
	for(int i=1;i<=n;i++){
		while(tp&&p[tp].second>=p[i].second)tp--;
		p[++tp]=p[i];
	}
	f[0]=ex;for(int i=1;i<=tp;i++)f[i]=(ii)(p[i].first-p[i-1].first)*p[i].second+f[i-1];
	int cp=1;
	for(int i=2;i<=tp;i++)if(f[i]*p[cp].first<f[cp]*p[i].first)cp=i;
	printf("%lld\n",(ll)max(g(m/f[cp]),g(m/f[cp]+1)));
	return 0;
}
```

