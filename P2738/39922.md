我的习惯总是直接写hash作为函数或者变量名...然后每次都CE...就是提醒大家注意保留字的问题。DEV C++写hash是没有问题的，洛谷要求更加严格，也有助于好习惯。

做法一

求无向图中的最小环。算法很简单，就是做m 遍dijkstra——每次找到一条边，拿掉，求这条边两个顶点之间的最短路，那么如果这两点间存在最短路，则这条路径与原来的边就构成了一个环。这样所有环中最小的一个就是答案。问题是题目给出的是边连通的信息而非点连通。也就是说我们得到的信息无法按照常规的方法（邻接矩阵，邻接表）来构图。这里就需要一个转化。由于我想不到什么好的算法，所以就用了一个复杂度为O(n^2)的转化。首先将每条边的两个顶点都看作单独的点（也就是说假设所有边都不连通，为了方便，可以分别设第i 条边的两个顶点编号为i\*2-1 和i\*2），然后对于两条连通的边，将连通这两条边的点并在一起。具体做法就是将其中一个点的连通情况全部赋给另一个点，并修改图中其他与该点连通的点信息使得合并成立。这里我借助了并查集，使得每次查找的时间都近似为常数，所以总的时间复杂度就是O(n^2)。其中n 是合并后总的点的个数经过上述转化以后，再用m遍dijkstra，总的算法时间复杂度就是O(mn^2)。

做法二

这道题给的数据是边之间的关系，首先想到的是构图，然后套经典的最短路做.但是这道题的数据输入会使按点构图很麻烦，其实这道题搜索即可，而且加剪枝后很快.由v条边开始搜索在它b方向的边，重复这个过程，直到回到v 而且是由a方向回到的，为了判断环可以加个判重，一个剪枝:对于路径长度大于已知最小环的可剪。

做法三

一种比较诡异的方法。就是把边变成“点”。在把“边”的长度设定为边两端的“点”（既原来的边）的长度的和。用由floyed算法改进的求最小环的算法求最小环。注意的是枚举“点”时，注意“点”连接的两“点”要是分别连接到该“点”代表的边的两个端点。这个复杂度为O(n^3)。超级快。证明略，有兴趣的自己想一下。

做法四

仍然是求最小环，先将边邻接矩阵转为点邻接矩阵，再dfs 求出所有环。可以证明时间复杂度为O(n^3)，所以能快速AC。

下附参考代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
long a[303][303]={0},n=0,m=0,l[303]={0},ans=LONG_MAX,y=0;
bool hahash[303]={false},kk[303]={0};
void dfs(long goal,long u,long t){
    if(goal==u){
        if(y<ans)ans=y;
            return;
    }
    if(y>=ans)return;
    for(long i=1;i<=n;i++)
        if(!hahash[i]&&!kk[i]&&a[u][i]==3-t){
            kk[i]=true;
            y+=l[i];
            dfs(goal,i,a[i][u]);
            y-=l[i];
            kk[i]=false;
        }
}
int main(){
    cin>>n;
    for(long i=1;i<=n;i++){
        long temp,l1,l2;
        cin >>temp;cin >>l[temp]>>l1>>l2;
        for(long j=1;j<=l1;j++){
            long p=0;cin>>p;
            a[temp][p]=1;
        }
        for(long j=1;j<=l2;j++){
            long p=0;cin>>p;
            a[temp][p]=2;
        }
    }
    for(long i=1;i<=n;i++){
        y=0;
        memset(kk,0,sizeof kk);
        for(long j=1;j<=n;j++)
            if(a[i][j]==1&&!hahash[j]){
                kk[j]=true;
                y+=l[j];
                dfs(i,j,a[j][i]);
                kk[j]=false;
                y-=l[j];
            }
        hahash[i]=true;
    }
    cout<<ans<<endl;
    return 0;
}
```