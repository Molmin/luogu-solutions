### 题意：
这里对样例 2 作出解释：
```
8
1 2 1 3 1 2 1 5
```
- $1$ 的下标分别为 $1$，$3$，$5$，$7$，成等差数列。所以输出数列的公差 $2$；
- $2$ 的下标分别为 $2$，$6$，成等差数列，所以输出数列的公差 $4$；
- $3$ 和 $5$ 只出现了一次，所以输出 $0$。

再看一组数据：
```
6
1 1 4 5 1 4
```
- $1$ 的下标分别为 $1$，$2$，$5$，不成等差数列，所以不输出。
- $4$ 的下标分别为 $3$，$6$，成等差数列，所以输出数列的公差 $3$；
- $5$ 只出现了一次，所以输出 $0$。

懂了吗？
### 解法：
~~膜你~~模拟

假设 $i$ 是当前数字，用 $c_i$ 记录 $i$ 的上一位置，$b_i$ 记录 $c_i$ 与 $i$ 的距离，然后与之前的距离进行比较，如果有一次不等，那么这个数就不能构成等差数列，也就不输出该数。否则，输出该数与其等差数列的公差。

### 代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+5;
int a[N],b[N],c[N];//b数组记录公差 c[a[i]]记录上一个a[i]的位置 
bool vis[N];//遍历数组时用 
map<int,int> t;
int main(){
    int n;cin>>n;
    for(int i=1;i<=n;i++){
        cin>>a[i];
        t[a[i]]++;
        if(t[a[i]]==1)c[a[i]]=i;//第一次出现 记录当前位置 
        if(t[a[i]]==2){
            b[a[i]]=i-c[a[i]];//计算与上一次位置的差，录入b数组
            c[a[i]]=i;//刷新c数组 
        }else if(t[a[i]]>2){//已多次出现
            if((i-c[a[i]])!=b[a[i]])//判断公差是否一致 
                b[a[i]]=0;//不一致，那么a[i]不构成等差序列 
            else c[a[i]]=i;//否则继续刷新c数组 
        }
    }
    int cnt=0;
    for(int i=1;i<=n;i++){
        if(vis[a[i]])continue;
    	vis[a[i]]=1;
        if(t[a[i]]==1)cnt++;
        else if(b[a[i]]!=0)cnt++;
    }//查找等差数列个数，相信大家看得懂，就不解释了 
    cout<<cnt<<endl;
    sort(a+1,a+1+n);//排序，因为样例要求从小到大输出 
    memset(vis,0,sizeof(vis));
    for(int i=1;i<=n;i++){
        if(vis[a[i]]) continue;
    	vis[a[i]]=1;
        if(t[a[i]]==1)cout<<a[i]<<" "<<"0"<<endl;
        else if(b[a[i]]>0)cout<<a[i]<<" "<<b[a[i]]<<endl;
    }//输出，大家肯定也看得懂 
    return 0;
}
```
