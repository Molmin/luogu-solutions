### 题目概述

给出一数组的初始状态及目标状态，有三种改变的方式，求最小代价。


------------


### 算法思路

1. 首先，看到题目要求的最小代价（~~还有数据范围~~）就可以推出要用 $dp$ 。

1. 但很显然，状态很难定义，**因为使某一堆符合条件可能会导致其他堆的初始状态改变**，所以我们尝试用二维 $dp$ 。


------------


### 推导状态转移方程

- 我们~~很容易~~能想到，用 $f[i][j]$ 表示用原先的前 $i$ 堆使前 $j$ 堆满足最后的要求，不过这很麻烦，所以，我们有了另一种定义。

- 我们可以把初始状态和目标状态进行特殊的离散化。例子如下。

	假定初始状态为：$1$ $2$ $3$ $4$，

	我们用数组 $a$ 存下它：$1$ $2$ $2$ $3$ $3$ $3$ $4$ $4$ $4$ $4$ 。

- 很明显，这样方便了许多。我们直接把泥土拆分成一个一个的，这样， $f[i][j]$ 就变成了用原先的前 $i$ 个单位泥土使最后的前 $j$ 个单位的泥土符合条件。

	（说人话： $f[i][j]$ 表示用 $i$ 个泥土去构造出 $j$ 个泥土。）

- 最后，我们不难得出状态转移方程 $f[i][j] = min(f[i-1][j]+y,f[i][j-1]+x,f[i-1][j-1]+z*abs(a[i]-b[j]))$


------------


### $Code$
```cpp
#include<bits/stdc++.h> 
using namespace std;

int n, x, y, z;
const int maxn = 1005;
int a[maxn], b[maxn];
int f[maxn][maxn];
int t1, t2;
int la, lb;

int main()
{
	cin >> n >> x >> y >> z;
	la = lb = 1;
	for (int i = 1; i <= n; i++)
	{
		cin >> t1 >> t2;
		for (int j = 1; j <= t1; j++) a[la++] = i;
		for (int l = 1; l <= t2; l++) b[lb++] = i;
	}
	f[0][0] = 0;
	for (int i = 1; i <= la; i++) f[i][0] = i * y;
	for (int i = 1; i <= lb; i++) f[0][i] = i * x;
	for (int i = 1; i <= la; i++)
	{
		for (int j = 1; j <= lb; j++)
		{
			f[i][j] = min (f[i - 1][j] + y, min (f[i][j - 1] + x, f[i - 1][j - 1] + z * abs (a[i] - b[j])));
		}
	}
	cout << f[la][lb] << endl;
	return 0;
}
```

若本题解有错误，麻烦您给本蒟蒻指出，谢谢。