挺**神奇**的一道黑题

# 题意

给你很多数对a,b，要求找出一个数s，满足在 $ s $&$ b_i $有奇数个1时$a_i$取负，使得最终$a_i$的和与原先$a_i$的和的符号相反

# 思路

首先看到位运算就应该想到按位是独立的

所以按位枚举应该是没跑了/

接下来就要考虑怎么枚举能让当前决定不存在对后面的影响

这里是**与**操作，一个比较优秀的性质就是一个数与上另一个数时只有**低于它最高位的位数才会被影响**

像$(00000110)_2$，他只会受到$2^0,2^1,2^2$这三位的影响，其他位根本没他啥事

所以从0~62枚举**最高位**就可以保证后面所作的更改不会影响到前面的决策

还有一个比较重要的就是`有奇数个1`看起来十分~~丑陋~~，要想个办法把它变得正常

由于是取相反数，所以可以想到$(-1)^n$的形式，即每次决定变化时把当前位为1的对应的a值取负就行

每次枚举到一个位的时候将所有最高位为这个数的数字加起来，若这个和与原和符号相同，说明将这位 置成1是有意义的，否则是没有意义的

然后将**所有**这个位为1的值取相反数就行

这样就保证了当前决策只会对后面的状态造成影响。

为了偷懒，如果原先的和为负数，则把他们全都取反，变成正数，就可以少一个特判了

# 代码

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
int a[300001], m[300001], hi[300001];
signed main()
{
	int n;
	cin >> n;
	int ans = 0, sum = 0;
	for(int i = 1; i <= n; i++)
	{
		cin >> a[i] >> m[i];
		int x = m[i];
		while(x)
		{
			x >>= 1;
			hi[i]++;
		}
		sum += a[i];
	}
	if(sum < 0)
	{
		for(int i = 1; i <= n; i++) a[i] *= -1;
	}
	for(int i = 0; i <= 62; i++)
	{
		int qwq = 0;
		for(int j = 1; j <= n; j++)
		{
			if(m[j] & (1ll << i) && hi[j] - 1 == i) qwq += a[j];//其实第一条判断没有用，是我之前的错误做法留下来的
		}
		if(qwq > 0)
		{
			for(int j = 1; j <= n; j++)
			{
				if(m[j] & (1ll << i)) a[j] *= -1;
			}
			ans += (1ll << i);
		}
	}
	cout << ans << endl;
	return 0;
}

```