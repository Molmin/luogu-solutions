
### 题目分析：

考虑这样的一个结论：每一个有编号比自己大的点的邻居的点一定会被删掉，每一个 3 询问就是询问有多少个点是比其所有的相邻点的编号大的。

这样的一个结论是成立的，可以由反证法证明：假设当前还有至少一个点与编号比自己大的点有连边，那么这样一个点没有被删掉一定是因为有至少一个比自己编号小的点与之连边。而这样的一个编号比自己小的点其实又是另一个“与编号比自己大的点连边的点”，他没有被删掉肯定又是因为有编号更小的点与之连边。以此类推，发现由于点的数目有限，这样的一个情况肯定不可能是无限进行下去的，所以肯定会在某一个时刻将所有的与编号比自己大的点连边的点全部删去。

然后是如何实现的问题，直接建立图的复杂度是 $O(n^2)$ 的，无法接受。重新观察题目，发现题目中给出了这样的一个条件：不存在重边，且删除的边一定存在。发现其实并不需要真的记录下某一个点到底和谁连了边，只需要记录这个点和几个比他大的点连了边就行了。

------------
### 代码：
```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
int n,m,T,x,y,cnt[200005],ans;
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=m;i++){
		scanf("%d%d",&x,&y);
		if(x>y)swap(x,y);
		cnt[x]++;
		if(cnt[x]==1)ans++;
	}
	scanf("%d",&T);
	while(T--){
		scanf("%d",&x);
		if(x==1){
			scanf("%d%d",&x,&y);
			if(x>y)swap(x,y);
			cnt[x]++;
			if(cnt[x]==1)ans++;
		}else
		if(x==2){
			scanf("%d%d",&x,&y);
			if(x>y)swap(x,y);
			cnt[x]--;
			if(cnt[x]==0)ans--;
		}else printf("%d\n",n-ans);
	}
	return 0;
}
```

