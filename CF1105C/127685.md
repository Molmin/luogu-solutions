题意：
一个整数数组，满足：
 1. 长度为$n$
 2. 所有元素都在$[l, r]$范围内
 3. 所有元素的和能被3整除
给出$n, l, r (1 \leq n \leq 2\cdot10^5,1 \leq l \leq r \leq 10^9)$
请找出符合条件的数组的个数，答案对 $10^9 + 7$取模


首先我们要处理出$[l, r]$中对3取模得结果分别为0，1，2的数的个数，在一个合乎要求的数组中，结果为1和2的数的个数必然一样，由此就可以很方便地得到所有可能的组合的个数。但新的问题来了，由于可以选用相同的数，求出这些组合的排列数几乎是一个不可能完成的任务（对我这种蒟蒻来说）。

换一种思路，我们一个数一个数地添，并把所有可能的情况都考虑进去：

设$dp[i][j]$表示有$i$个数，且它们的和对3取模结果为$j$的数组个数，数组$num[i]$中记录了$[l, r]$中对3取模得结果为$i$的数的个数，显然$dp[1][j] = num[j]$，随后，向已有的数组的尾部添加新的数字，例如：
$$dp[i][0] = dp[i - 1][0] \cdot num[0] + dp[i - 1][1] \cdot num[2]  + dp[i - 1][2] \cdot num[1]$$
$dp[i][1]$和$dp[i][2]$的情况同理，递推到$n$，$dp[n][0]$就是我们要的答案。

为什么是添加到尾部？不能插入到某个数字前吗？这样做会不会漏情况？
实际上，插入到某个数字之前会带来重复（会有另一个数被顶到尾部），举个例子：现在前$i - 1$个数的和对3取模结果为1，要添加一个结果为2的数，即$dp[i - 1][1] \cdot num[2]$，如果把它插入到前面，使一个对3取模结果为1的数被顶到了前面的话，显然就与$dp[i - 1][2] \cdot num[1]$的情况重复了，另外两种情况同理。

附关键部分代码，欢迎纠错。

    ···c++
    const int mod = 1e9 + 7;
    const int maxn = 2e5 + 5;
    ll dp[maxn][3];//有i个数，且它们的和对3取模结果为j的数组个数
    int main()
    {
        //num[i]记录了对3取模结果为i的数的个数
        dp[1][0] = num[0], dp[1][1] = num[1], dp[1][2] = num[2];
        for(int i = 2; i <= n; i++)
        {
            dp[i][0] = (dp[i - 1][0] * num[0]) % mod + (dp[i - 1][1] * num[2]) % mod + (dp[i - 1][2] * num[1]) % mod;
            dp[i][0] %= mod;
            dp[i][1] = (dp[i - 1][0] * num[1]) % mod + (dp[i - 1][1] * num[0]) % mod + (dp[i - 1][2] * num[2]) % mod;
            dp[i][1] %= mod;
            dp[i][2] = (dp[i - 1][0] * num[2]) % mod + (dp[i - 1][1] * num[1]) % mod + (dp[i - 1][2] * num[0]) % mod;
            dp[i][2] %= mod;
        }
        cout << dp[n][0] << endl;
    }
