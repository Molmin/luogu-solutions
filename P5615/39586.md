题目：[洛谷P5615 [MtOI2019]时间跳跃](https://www.luogu.org/problem/P5615)

来个非 $dp$ 做法？ 

首先，我们要知道，凸 $n$ 边形成立的条件是： $n≥3$且最大的边要小于其它所有边之和。

~~然后就没有思路了~~

不过我们可以打表，算出前面前面几项的权值和：
>
>  | n | | ans |
>| :----------: | :----------: | :----------: |
>| 4 | | 7 |
>| 5 | | 34 |
>| 6 | | 113 |
>| 7 | | 321 |
>| 8 | | 830 |
>| 9 | | 2017 |
>| 10 | | 4705 |

~~并没有什么规律~~

接着，算出每一项中的边为 $k$ 个时的权值和：

>| $n$↓$k$: | | 3 | | 4 | | 5 | | 6 | | 7 | | 8 | | 9 | | 10 |
>| :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: |
>| 4 | | 3 | | 4 | |  | |  | |  | |  | |  | |  |
>| 5 | | 9 | | 20 | | 5 | |  | |  | |  | |  | |  |
>| 6 | | 21 | | 56 | | 30 | | 6 | |  | |  | |  | |  |
>| 7 | | 39 | | 128 | | 105 | | 42 | | 7 | |  | |  | |  |
>| 8 | | 66 | | 252 | | 280 | | 168 | | 56 | | 8 | |  | |  |
>| 9 | | 102 | | 448 | | 630 | | 504 | | 252 | | 72 | | 9 |
>| 10 | | 150 | | 740 | | 1255 | | 1260 | | 840 | | 360 | | 90 | | 10 |

~~似乎有丶东西~~

然后，再算出每一项中的边为 $k$ 个时的个数（记为数组 $ans$ ）：

>| $n$↓$k$: | | 3 | | 4 | | 5 | | 6 | | 7 | | 8 | | 9 | | 10 |
>| :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: |
>| 4 | | 1 | | 1 | |  | |  | |  | |  | |  | |  |
>| 5 | | 3 | | 5 | | 1 | |  | |  | |  | |  | |  |
>| 6 | | 7 | | 14 | | 6 | | 1 | |  | |  | |  | |  |
>| 7 | | 13 | | 32 | | 21 | | 7 | | 1 | |  | |  | |  |
>| 8 | | 22 | | 63 | | 56 | | 28 | | 8 | | 1 | |  | |  |
>| 9 | | 34 | | 112 | | 126 | | 84 | | 36 | | 9 | | 1 | |  |
>| 10 | | 50 | | 185 | | 251 | | 210 | | 120 | | 45 | | 10 | | 1 |

好像跟杨辉三角有点像？

于是打出杨辉三角（记为数组 $tri$ ）并减去上面的表（ 一 一 对应）可以得到数组 $a$ （空则为 $0$ ）：

>| $i$↓$j$: | | 0 | | 1 | | 2 | | 3 | | 4 |
>| :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: |
>| 1 | | 1 | | 1 | |  | |  | |  |
>| 2 | | 1 | | 2 | | 1 | |  | |  |
>| 3 | | 1 | | 3 | | 3 | | 1 | |  |
>| 4 | | 1 | | 4 | | 6 | | 3 | |  |
>| 5 | | 1 | | 5 | | 10 | | 7 | |  |
>| 6 | | 1 | | 6 | | 15 | | 13 | | 1 |
>| 7 | | 1 | | 7 | | 21 | | 22 | | 3 |
>| 8 | | 1 | | 8 | | 28 | | 34 | | 7 |
>| 9 | | 1 | | 9 | | 36 | | 50 | | 14 |
>| 10 | | 1 | | 10 | | 45 | | 70 | | 25 |

根据上表我们可以发现以下结论：

1. 当 $0≤j≤2$ 时:

>   $a[i][j]=s[i][j]$

2. 当 $j=3$ 且 $i≥2$ 时：

>   $a[i][3]=a[i-1][2]+a[i-2][3]$

3. 当 $j≥4$ 且 $i≥j-1$ 时：

>   $a[i][j]=a[i-j+1][j]+a[i-j+1][j-1]$
    
因此，我们可以通过求出数组 $tri$ 和数组 $a$ 并相减得到数组 $ans$ 得到答案,	期望得分： $0$~$80$ 

为什么？

仔细观察内存限制，两个 $5000 * 5000$ 的数组是装不下的，至多只能开一个数组。

再看上面的结论，不难发现数组 $a$ 只与所求的一列和其上一列有关系，所以可以滚动数组 $a$ ，边求数组 $a$ 边得到数组 $ans$ ，期望得分： $100$ 

下面上代码（时间复杂度：$O(n^2)$,空间复杂度:$O(n^2)$）:

```cpp
#include<iostream>
#include<cstdlib>
#include<cmath>
#include<algorithm>
#include<cstdio>
#define N 5005
#define mod 1000000007
#define rd register int
#define ll long long
using namespace std;
int t,n,tri[N][N],a[N][2];
ll ans;

//快速幂 
inline ll ksm(ll aa,ll bb,ll p){
	ll an=1,a=aa,b=bb;
	for(;b;b>>=1,a=(a*a)%p)
		if(b&1)
			an=(an*a)%p;
	return an;
}

signed main(){
	scanf("%d",&t);
	
	//求杨辉三角
	for(rd i=1;i<N;++i)
		tri[i][0]=tri[i][i]=1;
	for(rd i=2;i<N;++i)
		for(rd j=1;j<i;++j)
			tri[i][j]=((ll)tri[i-1][j]+tri[i-1][j-1])%mod;
	
	//结论2
	for(rd i=2;i<N;++i)
		a[i][1]=((ll)tri[i-1][2]+a[i-2][1])%mod;
		
	//结论3 
	for(rd i=4,j;i<N;++i){
		for(j=i-1;j<N;++j)
			a[j][i&1]=((ll)a[j-i+1][i&1]+a[j-i+1][!(i&1)])%mod;
			
		//滚动 
		for(j=0;j<N;++j)
			tri[j][i-1]=(((ll)tri[j][i-1]-a[j][!(i&1)])%mod+mod)%mod,a[j][!(i&1)]=0;
	}
	for(rd i=1;i<N;++i)//最后一列的滚动 
		tri[i][N-1]=((tri[i][N-1]-a[i][!(N&1)])%mod+mod)%mod;
	
	//结论1 
	for(rd i=1;i<N;++i)
		tri[i][0]=tri[i][1]=tri[i][2]=0;
	
	//计算答案 
	for(rd i=1,j;i<=t;++i){
		ans=0;
		scanf("%d",&n);
		for(j=3;j<=n;++j)
			ans=(ans+((ll)tri[n][j]*j)%mod)%mod;
		printf("%lld\n",((ll)ans*ksm(ksm(2,n,mod),mod-2,mod))%mod);
	}
	return 0;
}
```
