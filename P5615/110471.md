[传送门](https://www.luogu.org/problem/P5615)

题目大意：给你$n$根木棍，第$i$根木棍的长度为$i$，每次从中随机取一些木棍（每根木棍取到的概率为$50$%），设取到的木棍数量为$m$，如果取到的木棍能组成一个凸多边形，你就能得到大小为$m$的分数，否则将得不到分数。求每次能得到的期望分数。

根据：期望$=$结果$\times$概率

对于每一种确定的取木棍的方案，它发生的概率一定是$\frac{1}{2^n}$。

所以我们只需要求出所有方案能得到的分数之和，然后再乘上概率即可。

接下来就是如何去求所有方案能得到的分数。

这里先给出如下的$DP$数组
~~~cpp
tot[i]：在前i根木棍中选取木棍的所有方案的假定权值之和（不论是否合法）
f[i]：取到的木棍长度和为i的方案的权值的和
g[i]：取到的木棍长度和为i的方案的数量
ansf[i]：在前i根木棍中选取木棍的所有方案的权值之和
~~~
首先是为何要求$f$与$g$：

让我们先考虑一下三角形的三边关系：两边之和大于第三边。其实本质就是最长边的长度一定要小于其他边的长度之和（否则将不能形成封闭图形）。

那么我们把边的关系拓展到多边形上：最长边长小于其它边长之和。

至于凸多边形的条件，你可以发现任何非凸多边形最后都能变成凸多边形，所以不予考虑。

那么我们每次选完木棍以后判断它是否能组成多边形只需要判断最长边长是否小于其它边长之和即可。

然后怎么做呢？

这时候就可以用上$f$数组和$g$数组，首先枚举最长边$i$，那么使用第$i$条边作为最长边的方案的权值和就可以表示为$\sum_{j>i}f[j]$，然而这个实现起来并不容易，因为$j$的上界是$n^2$级的，转移的复杂度太高。

不过这启发了我们使用容斥思想：因为$i$的范围很小（只到$5000$），所以我们先求出所有取木棍的方案的假定权值之和，然后再减去不合法的即可，即：$tot[i]-\sum_{0≤j≤i}(f[j]+g[j])$。

等等，为何$f[j]$要再加上$g[j]$？因为我们计算的$f$是在**已经确定边数**的前提下求出的权值之和，但是我们“确定好的边数”并没有算上最长边$i$。幸亏每个方案的权值是使用的木棍的个数，因此我们计算边$i$的贡献只需要再加上方案数即可（这里需要感性理解一下）。

$f$与$g$如何求出来呢？接着往下看。

在这之前先介绍一下$ansf$。

显然$ansf[n]$是所有方案能得到的分数，考虑如何转移。

对于前$i$条边，所需要讨论的无疑是“$i$是否是最长边”，如果不是，直接从$ansf[i-1]$中转移而来，如果是，则按照上述容斥的方法解决。

即：$ansf[i]=ansf[i-1]+tot[i-1]-\sum_{0≤j≤i}(f[j]+g[j])$

每次更新完$ansf[i]$之后，我们还要更新$tot[i]$、$f$和$g$。

因为我们考虑的是前$i-1$根木棍的方案（第$i$根木棍已经假定为最长木棍），所以应当先更新$ansf$再更新$tot$、$f$与$g$。

$tot$的更新过程和$ansf$相似，考虑是否选择第$i$根木棍，不选的贡献为$tot[i-1]$，选了的贡献为$tot[i-1]+2^{i-1}$（$2^{i-1}$即为方案数）

即：$tot[i]=tot[i-1]\times 2+2^{i-1}$

$f$与$g$的更新类似于背包，只需要考虑边$i$对数组做出的贡献即可，转移式如下：

~~~cpp
g[j]+=g[j-i]
f[j]+=f[j-i]+g[j-i]
~~~
不要忘了倒序枚举，因为新状态$f[j]$利用的$f[j-i]$是之前的旧状态。

最后的答案$answer=\frac{ansf[n]}{2^n}$。

时间复杂度：$O(n^2)$

上代码：
```cpp
#include<cstdio>
#define N 5005
#define ll long long
using namespace std;
int n,T;
ll f[N],g[N],invp[N],inv2,ansf[N];
const ll mod=1000000007;
int quick_pow(int base,int x)
{
	int res=1;
	while(x)
	{
		if(x&1)res=1ll*res*base%mod;
		base=1ll*base*base%mod,x>>=1;
	}
	return res;
}
void init()
{
	invp[0]=1,g[0]=1;
	inv2=quick_pow(2,mod-2);
	ll p=1,tot=0;
	for(int i=1;i<=5000;i++)
	{
		ansf[i]=(ansf[i-1]+tot+p)%mod;
		tot=(tot*2+p)%mod;
		p=p*2%mod;
		for(int j=0;j<=i;j++)
			ansf[i]=((ansf[i]-f[j]+mod)%mod-g[j]+mod)%mod;
		for(int j=5000;j>=i;j--)
		{
			g[j]=(g[j]+g[j-i])%mod;
			f[j]=(f[j]+f[j-i]+g[j-i])%mod;
		}
		invp[i]=1ll*invp[i-1]*inv2%mod;
	}
}
int main()
{
	init();
	scanf("%d",&T);
	while(T--)
	{
		scanf("%d",&n);
		printf("%lld\n",1ll*ansf[n]*invp[n]%mod);
	}
	return 0;
}
```
