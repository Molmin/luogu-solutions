这道题只要肯动手还是挺水的
## 进入正题
我们先枚举几个找找规律(这里先省略$x$，$y$)：

$k = 0 $：$1$

$k = 1 $: $a$ $b$

$k = 2 $: $a^{2}$ $2ab$ $b^{2}$

$k = 3 $: $a^{3}$ $3a^{2}b$ $3ab^{2}$ $b^{3}$

$.......$

去掉$a$和$b$，就能发现他就是个杨辉三角，那我们就可以先预处理好杨辉三角（~~也可以打表~~）
我们继续观察，杨辉三角上是要乘上$a$和$b$的，现在我们就要找该怎么乘了；观察次数，$a$的次数是$n$的大小，$b$也是$m$的大小，那么就可以先把$a$，$b$乘方后的数乘到他们对应的杨辉三角的数；至于乘方，我用的快速幂，其实爆乘应该也可以，看喜好吧，只要每次都$%$去哪个规定的数就行了（没试过鸭）

说了这么多，我们还没确定他们的位置，观察，由于杨辉三角的第一排其实不为$1$，所以对应的行数也就是$k+1$了，在确定列，可以发现，其实就是$m+1$；现在，就做出来啦


------------
接下来就是蒟蒻的代码啦！

```cpp
#include <bits/stdc++.h>
using namespace std;
long long a/*x*/ , b/*y*/ , k , m/*y*/ , n/*x*/ , mo = 10007 , ans;	//标记好对应的字母，以防带错值了 
long long ret = 1; //快速幂的答案 
long long f[10011][10011]; //杨辉三角 
int main(){ 
    f[1][1] = 1; //杨辉三角的第一行为1，后面才好算嘛 
    for(int i = 2; i <= 1005; i++) //数据最大为1000，所以1000多就够了 
        for(int j = 1; j <= i; j++)
            f[i][j] = (f[i - 1][j - 1] % mo + f[i - 1][j]  % mo) % mo; //每一步都%，以防答案太大 
	cin >> a >> b >> k >> n >> m;
	ans = f[k + 1][m + 1]; //答案初始化了 
	while(n){ //快速幂~~~ 
		if(n % 2 == 1) ret = ret * a % mo;
		n /= 2;
		a = a * a % mo;
	}
	ans *= ret % mo;
	ret = 1; //上一个用完就要初始化了 
	while(m){
		if(m % 2 == 1) ret = ret * b % mo;
		m /= 2;
		b = b * b % mo;
	}
	ans *= ret % mo;
	cout << ans % mo;
	return 0;
} 
```
就这么多啦，溜了溜了