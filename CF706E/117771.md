#### 解法一 数据结构

拿一个数据结构把每一行的数维护一下，修改的时候只需要切割/合并一下就行。

如果使用 `FHQ Treap` 或者 `Splay` 的话，切割次数过多导致整棵树被切得支离破碎，深度巨大。本地 `FHQ Treap` 最快跑到 $\text{7.5s}$ ，不是一般的慢。

如果加上替罪羊树的推平操作，那么可以跑到 $\text{4s}$ 左右，还是不够。

换用结构稳定的块状链表，理论复杂度 $O(qm \sqrt{n})$，看起来就过不了。

-------------------------

#### 解法二 十字链表

既然无论 $O(qm \log n)$ 和 $O(qm \sqrt{n})$ 都过不了，那就尝试 $O(q(n+m))$ 的算法。

考虑用十字链表维护矩阵，观察到交换两个矩阵只需要改动边缘的指针就可以。

如果使用链表，就没办法快速得到矩阵上的点在链表内对应的点，因为链表查找单次是 $O(n)$ 的，一次修改只能用常数次。

这里可以先 $O(n)$ 找出矩阵的左上角，再 $O(n+m)$ 把矩形的边缘顶点都找出来。

然后把指针都换一下就行了。

复杂度 $O(q(n+m))$