这是一道动规嘛
## 题意暗示
- 将所有书分成 $n$ 个区间，找到每个区间中高度最大的书，记为 $ma$ ，将所有 $n$ 个区间中的 $ma$ 相加，即为答案
## 题目分析
1. 分出的区间一定要尽可能的少，这样可以使 $ma$ 的数量减少，从而使答案更小，那么，这个区间内的总宽度就要尽可能的接近宽度上限 $L$ 。
1. 用 $f_i$ 记录放到第 $i$ 本书时，书架高度的最小值。用循环 $j$ 来枚举区间的头，$i$ 就是区间的尾，所以 $f_i$ 的值应该为  $f_i=\min(f_i,f_j-1+ma)$ 。
## 题目坑点
- 既然取最小值，那么 $f$ 数组肯定要初始化赋最大喽，而且 $f_0$ 还要赋成最小值0
- 可以用前缀和优化一下，记录在 $sum$ 数组里，防止超时。
- 不要忘了区间最大值初始化！

下面就上大家最最最关心的东西——代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,i,a[100100],b[100100],sum[100100],f[100100],ma,j;
int main(){
	scanf("%d%d",&n,&m);
	for (i=1;i<=n;i++)
		scanf("%d%d",&a[i],&b[i]),sum[i]=sum[i-1]+b[i];//前缀和优化
	memset(f,63,sizeof(f));//初始化
	f[0]=0;//赋成最小值0
	for (i=1;i<=n;i++){
		ma=0;//区间最大值初始化
		for (j=i;j>=1;j--){
			if (sum[i]-sum[j-1]>m) break;//判断总宽度是否超过 L
			ma=max(ma,a[j]);
			f[i]=min(f[i],f[j-1]+ma);//取最小值
		}
	}
	printf("%d\n",f[n]);
	return 0;
}
```
