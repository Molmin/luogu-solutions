# Contest Start

## 题目大意

有 $n$ 个人报名参加一个比赛，从 $0$ 时刻开始每隔 $x$ 分钟有一个人开始比赛，每个人参赛时间相同，均为 $t$ 。定义一个选手的**不满意度**为他结束比赛时**已经开始但尚未结束比赛**的人数，求所有选手不满意度的总和。

## 题外话

这场 $CF$ 私以为 $B$ 题才是最简单的一道题， $A$ 题比 $B$ 题要难一些，但其实也比较容易。

## 分析

我们可以先考虑分析一下样例（下展示样例 $4$ 、 $2$ 、 $5$ ）：

|  | 一号 | 二号  |三号  | 四号 |
| :----------: | :----------: | :----------: | :----------: | :----------: |
| **开始时间** | 0 | 2 | 4 | 6 |
| **结束时间** | 5 | 7 | 9 | 11 |
| **不满意度** | 2 | 2 | 1 | 0 |

其实题目告诉我们每个选手的参赛时间相同且开始时间有着相同的间隔，应该不难想到肯定又一定的**规律**存在。

就例如这组样例，虽然比较小，但是我们也能注意到，一号和二号的不满意度没有变化，想象有更多的参赛选手，是否会有更多的选手不满意度为 $2$ ？至于最后两个选手不满意度变化的原因，很显然其实是因为后面已经没有更多的选手了，所以会一次递减 $1$ 。

于是很容易想到，其实答案就是前面**一串相同**的加上后面的**等差数列**，重点是如何求前面一串相同不满意度的**个数**。

这个其实比较容易想，就是 $\lfloor \frac{t}{x}\rfloor $ ，参赛的时间除以间隔，想一想其实就是在自己参赛的这段时间内有多少人开始了比赛。

又因为**最后一个人的不满意度**肯定为 $0$ ，肯定能和前面形成一串长度未知的递减数列（如果不能，那其实就是所有人的不满意度肯定为 $0$ 了，这种情况不影响我们的讨论）。

这个数列的长度是多少呢？他肯定会一直递增到一个人的参赛时间内**最多有多少人开始比赛**的数量，也及时我们的 $\lfloor \frac{t}{x}\rfloor $ ，最后我们只需要注意一个地方，就是可能**人数不够**，只需要在该长度和 $n$ 之间取最小值就行了。

既然我们已经知道了这里的长度 $l$ ，前面一连串相等值的长度就是 $n-l$ ，加起来就完了。

## CODE

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
inline int read()
{
	int s=0,w=1;
	char ch=getchar();
	while(ch<'0'||ch>'9') { if(ch=='-') w*=-1; ch=getchar(); }
	while(ch>='0'&&ch<='9') s=s*10+ch-'0',ch=getchar();
	return s*w;
}
int k,n,x,t;
signed main()
{
	k=read();
	while(k--){
		n=read(),x=read(),t=read();
		int temp=min(t/x,n-1);
		int ans=(n-temp)*temp;
		temp--;
		ans+=(1+temp)*temp/2;
		printf("%lld\n",ans);
	}
	return 0;
}
```
