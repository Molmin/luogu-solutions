来口胡一个简单易懂的线性做法。

首先枚举绝对众数 $x$，然后把 $a_i=x$ 的看作 $+1$，其它的看成 $-1$。

然后看这个序列的前缀和 $s$，对于 $i<j$，如果有 $s_i<s_j$，那么就会对答案造成 $+1$ 的贡献。

直接做显然不行，考虑如何优化。

不难观察发现：

> 如果 $s_i$ 同时是前缀最小值和后缀最大值，那么 $s_i$ 不会对答案造成任何贡献。

证明显然。

再考虑假设 $=x$ 的数有 $k$ 个，那么序列元素和为 $2k-n$，那么本质不同的前缀最小值和后缀最大值的数量均为 $\max(n-2k,0)$。

所以有用的数量只有 $O(k)$ 个，于是总共有用的数量就只有 $O(n)$ 个。

显然对于固定的 $x$，我们可以把有用的数构成的极长连续段拉出来分别作就行了。

现在考虑对于一段 $+1,-1$ 的段计算之前的贡献。乍一看，需要单点修改，查询前缀和，好像至少要一个 $\log$。

但观察发现两次查前缀的位置分别为 $x,y$，有 $|x-y|\le 1$，于是直接开桶记录即可。

于是就 $O(n)$ 了。