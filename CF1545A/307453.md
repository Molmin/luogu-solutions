遇到这种交换又排序的题，直接考虑排序前后一个数的位置变化你就赢一半了。

对于这道题，由于每个人交换一次就会改变一次方向，而初始和最后方向需要相同，所以每个人初始和最后的位置之间相差的距离必然为偶数。

如果没有重复元素那当然排个序直接瞎判断一下就行了；然而有重复元素就有点难搞。

注意到一个元素如果移动了偶数次那么它在数组中的位置的奇偶性必然不会改变，因此我们建两个桶：用 $f_{i,0}$ 表示 $i$ 这个值在原序列偶数位上出现的次数，$g_{i,0}$ 表示 $i$ 这个值在原序列奇数位上出现的次数。$f_{i,1}$ 表示 $i$ 这个值在排序后的新序列偶数位上出现次数，$g_{i,1}$ 类似。

那么稍加思考可以发现，只需要判断是否对任意 $1\le i\le V$ 有 $f_{i,0}=f_{i,1},g_{i,0}=g_{i,1}$ 即可。其中 $V$ 为值域。

其中的道理不难讲：若存在符合条件的移动方式，那么一个元素如果原来在奇数位上，最后也一定在奇数位上，这表明对每个值 $i$，它在奇数位上的出现次数是不会改变的；偶数同理。必要性是显然的。

于是只需要排个序就行了。

时间复杂度 $O(n\log n)$，但由于值域很小其实可以用计数排序做到 $O(n)$，不过没必要。

```cpp
#include<bits/stdc++.h>

#define int long long

using namespace std;

int read(){
	int x=0,f=1;char ch=getchar();
	for(;(!(ch>='0'&&ch<='9'));ch=getchar())if(ch=='-')f=-1;
	for(;(ch>='0'&&ch<='9');ch=getchar())x=(x<<1)+(x<<3)+(ch-'0');
	return x*f;
}

const int MN=1e5+5;
int n,a[MN],f[MN],g[MN];

signed main(void){
	
	int tt=read();while(tt--){
		n=read();bool ans=1;
		for(int i=1;i<=n;i++){
			a[i]=read();
			f[a[i]]+=(i%2==0),g[a[i]]+=(i%2==1);
		}
		sort(a+1,a+n+1);
		for(int i=1;i<=n;i++)f[a[i]]-=(i%2==0),g[a[i]]-=(i%2==1);
		for(int i=1;i<=n;i++)if(f[a[i]]!=0||g[a[i]]!=0)ans=0;
		puts(ans?"YES":"NO");
		for(int i=1;i<=n;i++)f[a[i]]=g[a[i]]=0;
	}

	return 0;
}
```