[MYCui的博客，更好的体验](https://www.cnblogs.com/MYCui/p/13945384.html)
#### 前言
这是一个构造题。

点明两个公理：

+ 一个$n$个点的无向完全图最多有$\frac{(n-1)*n}{2}$条边。

+ 要使得一个$n$个点的无向图联通，至少需要$n-1$条边

#### 思路：

根据上面提到的公理，我们很明显的可以知道：

+ #### $Case1$
假如给出的$m$ < $n-1$，显然无解，输出$-1$。

+ #### $Case2$
假若$m$ = $n-1$，那么你给出的连通图必然是一棵树，当然，这个题很好满足条件，构建一朵菊花，中心点为$v$即可，即用$v$向其它$n-1$个点连边。

+ #### $Case3$

$m$ >= $n$

从上面$Case2$得到启发，我们可以先构造一朵以$v$为中心的菊花。

这样子操作后，我们就连上了$n-1$个点

我们剩下要连的边数就会等于$m-n+1$条。

我们就保证了给出的图一定是联通的。

考虑如何使得整个图按题意删除点$v$后整个图不联通。

因为整个图不连通，那么整个图至少分裂出了两个部分。

我们不妨假设其中一个图只有一个点，另外的一个图就会有$n-2$个点。

在$Case3$下上面情况下会无解？

答案是：当那一个点数为$n-2$的图已经是**完全图**的时候，仍然存在没有连完的边。

因为你把其中点数为$n-2$的那一个图已经连满了，那一个图已经无法在自己内部连了，只能连入仅有一个点的那个图了。这样子的话，就算$v$点被删除，剩下的整个图仍然会是联通的。

这样子就无解了。也就是$m - n + 1 < \frac{(n-2)*(n-3)}{2}$即无解

(下面是关于上面的做法的证明，如果不想看可以选择跳过)

有人会问：为什么一定是两个不连通的图？难道三个的，四个的就不能满足条件了吗？

我们至少得剔除一个点出来，这个点不能与其他点联通(指删除点$v$后的图)

剩下的点一共就$n-2$个了(因为点$v$)被删除了 .

证明：当剩下的$n-2$个点在同一联通块时，能连的边最多。

假设这$n-2$个点分裂成了$k$个联通块。

$k$个联通块的点数分别为$p_1,p_2,p_3...p_k$

并且满足:$p_1+p_2+p_3+...+p_k = n - 2$

能连的边的总数就会是:

$\frac{(p_1-1)*p_1}{2} + \frac{(p_2-1)*p_2}{2}$ + ... + $\frac{(p_k-1)*p_k}{2}$

把式子暴力展开变为:

$\frac{p_1^2}{2} + \frac{p_2^2}{2} + ... +\frac{p_k^2}{2} - \frac{\sum_{i = 1}^{i = k} p_i}{2}$

把证明的内容写为不等式即为：

$\frac{p_1^2}{2} + \frac{p_2^2}{2} + ... +\frac{p_k^2}{2} - \frac{\sum_{i = 1}^{i = k} p_i}{2} < \frac{(n-2)(n-3)}{2}$

不妨将$p_1 + p_2 + ... + p_k$写成$n-2$的形式。

原式等于：

$\frac{p_1^2}{2} + \frac{p_2^2}{2} + ... +\frac{p_k^2}{2} - \frac{n-2}{2} < \frac{(n-2)(n-3)}{2}$

移项，合并同类项：
$\frac{p_1^2}{2} + \frac{p_2^2}{2} + ... +\frac{p_k^2}{2} < \frac{(n-2)^2}{2}$

∵ $p_1+p_2+p_3+...+p_k = n - 2$

∴ 上面不等式恒成立 。

证毕。

使用完全图的形式使得一个点的度数尽可能多进行连边即可，这个贪心是很显然的。

把任意一个不是点$v$的点拿出来，然后剩下的$n-2$个点里面按照贪心使得一个点度数尽可能多，任意连$m-n+1$条边即可

(继续任意找一个点当做菊花的中心然后就可以递归处理问题了。这是这个题目递归标签的由来)。

这个题目就完了。

### Code
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
int n , m , v;
int arr[100005],tail = 0;
signed main()
{
	cin >> n >> m >> v;
	if(m < n - 1){cout << -1 ; return 0;}
	if(m == n - 1)
	{
		for(int i = 1 ; i <= n ; i ++)
			if(i != v)
			cout << v << " " << i << endl;
		return 0;
	}

	m = m - n + 1;
	if((n - 2) * (n - 3) / 2 < m){cout << -1 ; return 0;}//判断是否有解
	for(int i = 1 ; i <= n ; i ++)
		if(i != v)
		cout << v << " " << i << endl;//先构造一朵菊花
	int now = 0;
	while(now <= n - 2)
	{
		if(now * (now - 1) / 2 >= m)break;
		now ++;
	}
	for(int i = 1 ; i <= n - 1 ; i ++)
	{
		if(now == 0)break;
		if(i != v)tail ++ , now -- , arr[tail] = i;
	}
	for(int i = 1 ; i < tail && m; i ++)
	{
		for(int j = i + 1 ; j <= tail && m; j ++)
			cout << arr[i] << " " << arr[j] << endl , m --;
	}
	return 0;
}
```