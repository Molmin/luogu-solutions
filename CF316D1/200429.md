可以分开讨论交换一次的人和交换两次的人。

因为只要交换的方案不同，最终的排列就不同，所以可以求不同的交换方案数。

对于交换一次的人，他可以和自己玩，也可以找一个人玩。

所以设 $f[i]$ 表示有 $i$ 个只能交换一次的人的交换方案数，

$f[i]=f[i-1]+(i-1)*f[i-2]$

对于能交换两次的人，他们可选择的交换方案共有 $a!$ ( $a$ 表示能交换两次的人的个数) 种。

最后的答案就是两种方案数的积。

```cpp
#include<bits/stdc++.h>
using namespace std;
inline int read() //输入量较大，要用快读
{
   int s=0,w=1;
   char ch=getchar();
   while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
   while(ch>='0'&&ch<='9') s=s*10+ch-'0',ch=getchar();
   return s*w;
}
int f[1000005]; //定义，f[i]表示i个只能交换一次的人的交换方案数
int main()
{
	int n = read(), cnt1 = 0; //cnt1表示只能交换一次的人的个数，不要和上文中的cnt混淆
	for(int i = 1; i <= n; i++) {
		cnt1 += !(read() - 1); //记录只能交换一次的人的个数
		//当read()=1时，read()-1=0，!(read()-1)为1，所以当read()为1时，cnt++
	}
	f[0] = f[1] = 1; f[2] = 2; //初始化
	for(int i = 3; i <= cnt1; i++) {
		f[i] = (f[i - 1] + f[i-2] * 1ll * (i - 1) % 1000000007) % 1000000007; //可以和自己玩，也可以找一个人玩
	}
	int s = 1; //s表示能交换两次的人的交换方案数
	for(int i = cnt1 + 1; i <= n; i++) { //除了cnt1个只能交换一次的人，其他都是能交换两次的人
		s = s * 1ll * i % 1000000007; //求阶乘
	}
	cout << s * f[cnt1] << endl; //最后的答案就是两种方案数的积
	return 0;
}
```
