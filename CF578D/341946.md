这题我们采用 DDP 解决。

首先，我们先考虑 DP 求 LCS 的过程。
```cpp
F[i][j]=max(F[i-1][j],F[i][j-1],F[i-1][j-1]+(S[i]==T[j]);
```
有结论：$F_{i,j} \le \min(i,j)$。

我们注意到最终要求 LCS $=n-1$，且有此结论，那么 $|i-j| \ge 2$ 就不必考虑了。

我们记内部 DP 的 $g_{i,j}$ 表示 $T$ 字符串的前 $i$ 个字符与 $S$ 的前 $j$ 个字符的 LCS，那么照着上述求 LCS 的方法有如下对应的式子：
```cpp
g[i][j]=max(g[i-1][j],g[i][j-1],g[i-1][j-1]+(T[i]==S[j]));
```

我们再记外部 DP 的 $f_{i,a=0/1,b=0/1/2,c=0/1}$ 表示 $T$ 的前 $i$ 个字符满足如下条件的方案：
* $g_{i,i-1}=i-2+a$。
* $g_{i,i}=i-2+b$。
* $g_{i,i+1}=i-1+c$。

我们可以通过刷表法转移，转移的时候，先还原出 $g$ 数组，再还原出三个下标 $x,y,z$，进行转移 $f_{i,x,y,z}=f_{i,x,y,z}+f_{i,a,b,c}$。

[代码](https://codeforces.com/contest/578/submission/203037487)。