### 思路

我们知道最理想的情况是：每个数一高一矮，任取三个连续的数都至少有一个“太高的数”，这样，答案就是 $\left\lfloor\tfrac{n-1}{2}\right\rfloor$。如果 $k=1$，我们显然可以让答案变成最理想的情况，如果 $k≥2$ 呢？我们不妨来思考一下：

- 若将 $a_i$ 加 $1$，则 $a_{i-1}$ 或 $a_{i+1}$ 中至少有一项也会加 $1$，这样 $a_i$ 永远也不可能变成“太高的数”。

- 同时，若将 $a_i$ 加 $1$ 并且 $k≥3$，这样不仅 $a_{i-1}$ 或 $a_{i+1}$ 中至少有一项也会加 $1$，$a_{i-2}$ 或 $a_{i+2}$ 可能也会加 $1$，那么可能会造成原本是“太高的数”不再是“太高的数”。

所以我们得出结论：当 $k≥2$ 时，答案不但不会变优，反而可能变劣。根据结论，剩下的模拟就好。

### 代码实现

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[200005];
int main()
{
	int t,n,k;
	// 变量名见题意。 
	cin>>t;
	while(t--){
		cin>>n>>k;
		for(int i=1;i<=n;i++){
			cin>>a[i];
		}
		// 平平无奇的输入 
		if(k==1){
			cout<<(n-1)/2<<endl;
			// 如果 k 等于 1，输出 (n-1)/2，整形自动向 0 取整（在这里就是向下取整）。 
		}else{
			int tot=0;
			for(int i=2;i<n;i++){
				if(a[i]>a[i-1]+a[i+1]){
					tot++;
				}
			}
			// 否则统计答案。注意 i 要从 2 开始，到 n-1 结束，防止越界。 
			cout<<tot<<endl; 
		}
	}
	return 0;
}
```
