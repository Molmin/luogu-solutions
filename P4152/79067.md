有一个没有前途的做法，复杂度为 $O(cm\log m+Tnm)$，但是常数小，可以通过此题。并且这个做法好想好写，可以说是一个提高难度的暴力做法。

类比二维坐标系，我们有一个结论，只要若干点每一维相邻坐标值之差比相等，这些点就可以被一条直线穿过。例如三个三维点 $(1,1,4),(2,2,9),(4,4,19)$，其三维坐标值之差比分别为 $1:2$，$1:2$，$5:10$，化简后相等。下文称像 $\{1,2,4\}$ 和 $\{4,9,19\}$ 这种差之比相等的取值方案为「本质相同的方案」。

现在就有一个计数方案了，枚举每一个本质不同的方案，求出每维中于其本质相同的方案数的积。这些积的和就是答案。显然这样是不重不漏的。

现在考虑如何枚举本质不同的方案。首先我们发现其实方案数其实只和当前方案长度有关，所以我们算出与某一长度本质相同的方案数，再乘上此长度的方案数就可以了。所以我们将某一长度的方案合并计算。

容易想到一个非常朴素的 dp 方法，即对于每种本质不同的方案，我们统计其最大坐标最小的。可以钦定第一个点和最后一个点必须选，然后进行 dp。令 $f_{0/1,i,j}$ 代表选了 $i$ 个坐标，$j$ 是最大的坐标，$j$ 没有被选/被选了。可以写出代码

```cpp
f[1][1][1]=1;//这样赋初值的原因是 1 必须被选
for(int i=1;i<C;i++)
	for(int j=2;j<M;j++)
		f[0][i][j]=f[0][i][j-1]+f[1][i][j-1],
		f[1][i][j]=f[0][i-1][j-1]+f[1][i-1][j-1];
```

智慧的读者想必已经发现，这样枚举会重复计算某些方案，例如 $\{1,2,4\}$ 和 $\{1,3,7\}$ 他们本质相同，但是都会被统计进 dp 数组。所以在最后，我们需要把这些情况减去

```cpp
for(int i=2;i<C;i++)
	for(int j=2;j<M;j++){
		for(int k=j*2-1;k<M;k+=j-1)//&
			f[1][i][k]-=f[1][i][j];
		f[1][i][j]%=mod;
	}
```

解释一下标了注释那句话，一个最大坐标为 $j$ ，最小坐标为 $1$ 的方案差值扩大 $k$ 倍以后最大坐标会变为 $(j-1)k+1$。可以搓几组数据验证或者直接证明。这样我们就减掉了那些重复计算的方案。

然后考虑对于每一维，与某一长度本质相同的方案数如何 $O(1)$ 求。若该维度限制为 $m_i$ ，该方案最大坐标为 $j+1$（当然，它的最小坐标为 $1$）。它的答案应该是

![](https://s3.ax1x.com/2021/01/22/sIX77Q.png)

这个算法就是枚举把差值扩大的倍数 $k$，然后考虑最小点分别是 $1,2,3,...,(m-(kj+1)+1)$ 时各有一种方案，加起来即可。

将上面两个方法合并，就是这道题的算法了。

```cpp
#include<stdio.h>
const int M=100050,mod=10007,iv=mod/2+1,C=21;
int f[2][C][M],g[M],a[C],t,n,m,c,x;
long long ans,sm,mn,nw;
signed main(){
	scanf("%d%d%d",&t,&n,&c);
	f[1][1][1]=1;
	for(int i=1;i<C;i++)
		for(int j=2;j<M;j++)
			f[0][i][j]=(f[0][i][j-1]+f[1][i][j-1])%mod,
			f[1][i][j]=(f[0][i-1][j-1]+f[1][i-1][j-1])%mod;
	for(int i=2;i<C;i++)
		for(int j=2;j<M;j++){
			for(int k=j*2-1;k<M;k+=j-1)
				f[1][i][k]-=f[1][i][j];
			f[1][i][j]%=mod;
		}
	for(int T=0;T<t;T++){
		if(T)scanf("%d%d",&n,&c);
		ans=0,mn=M;
		for(int i=1;i<=n;i++)
			scanf("%d",&a[i]),mn=a[i]<mn?a[i]:mn;
		for(int j=c-1;j<mn;j++){
			sm=1;
			for(int i=n;i;--i)
				nw=*(a+i)/j,sm=nw*(*(a+i)-((nw+1)*j)*iv)*sm%mod;//交换了乘顺序来优化常数
			ans+=sm*f[1][c][j+1];
		}
		printf("%d\n",(ans%mod+mod)%mod);
	}
} 
```

肉眼可见预处理复杂度 $O(mc\log m)$，计算复杂度 $O(Tnm)$。常数挺小的，开个 `int`，少取点膜就过去了，还挺快。

