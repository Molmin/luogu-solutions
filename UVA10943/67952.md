## 前言
若显示出现问题请到[博客](https://www.luogu.com.cn/blog/bzlz-zdx/solution-uva10943)食用。
## 题意简述
求满足 $\sum_{i=1}^{k}s_i=n(s_i \in [0,n] \cap \mathbb{Z})$ 的数列 $s$ 的个数，答案对 $1,000,000$ 取模（为什么感觉听起来更复杂了啊）。
## 题目分析
看见这种题目，我们首先想到的自然是构造满足条件的数列（其实只有我这样想吧）。那么我们自然想到对于数列的每一项，枚举它的值，并检测这一序列的和是否为 $n$。当然，经过对数据范围的观察，我们知道这个方法是不能通过的（废话）。但是这能为我们后来的解法提供思路。  

我们发现，如果枚举数列的第一项，那么对于每一个可取的第一项 $x$，我们要解决的问题就变成了求满足 $\sum_{i=1}^{k-1}s_i=n-x(s_i \in [0,n] \cap \mathbb{Z})$ 的数列 $s$ 的个数。而这个问题的形式，和原问题是相同的。  

这时我们就成功地将原问题拆成了规模更小的同形式子问题。设 $f_{i,j}$ 表示和为 $i$，项数为 $j$ 的数列数，运用动态规划思想，我们容易得到可以通过此题的一种状态转移方程式：
$$
f_{i,j}=\sum_{l=0}^{i}f_{i-l,j-1}
$$

其中 $l$ 枚举的即为数列的第一项。容易得到边界条件：当项数为 $1$ 时，对于每一个 $i$，方案数均为 $1$。  

容易看出，对于每一组数据，此算法的时间复杂度将为 $\operatorname{O}(n^2k)$。尽管此算法并非此题的最优解，但由于它容易想到（我这种蒟蒻都能想到）以及本题数据范围较小，不失为一种较好的解法。
## 代码
记得取模以及从 $0$ 开始枚举。循环时要先枚举项数，再枚举数列的和。
```cpp
#include<cstdio>
#include<cstring>
using namespace std;
const int mod=1000000;
int n,k,f[101][101];
int main()
{
	while(scanf("%d%d",&n,&k)!=EOF)
	{
		if(!n&&!k)
			break;
		memset(f,0,sizeof f);
		for(int i=0;i<=n;++i)
			f[i][1]=1;
		for(int i=1;i<=k;++i)
			for(int j=0;j<=n;++j)
				for(int l=0;l<=j;++l)
					f[j][i]=(f[j][i]+f[j-l][i-1])%mod;
		printf("%d\n",f[n][k]);
	}
	return 0;
}
```