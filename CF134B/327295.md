看题解里都是用的搜索，~~我为了造福后人~~，写下了这篇题解。

## Solution 
首先看到题目中 $(a,b)$ 可以变成 $(a+b,b)$ 以及 $(a,a+b)$，我立马联想到了更相减损术，它是这样子的：
$$\gcd(a,b)=\gcd(b,a-b)=\gcd(a,a-b)$$

好像并没有什么用，如果直接这么写无异于暴搜，~~虽然暴搜也能过。~~ 但不要忘记它是等同于辗转相除法的：
$$\gcd(a,b)=\gcd(b,a\bmod b)$$

这样子不断转换效率快很多，那先按着这个思路走，一步一步推。

- 因为辗转相除法是倒着递归的， $n$ 是已知的，所以还要枚举另一个数，并且这个数是小于等于 $n$ 的，因为大于的话会多操作，显然不优。
- 进入递归后，因为我们递归的是 $(b,a\bmod b)$，操作次数不能一步一步加出来，但其实想想就知道这样子的操作次数是 $a/b$，加上即可。
- 假设递归时 $(a,b)$，$b$ 变成了 $1$，因为起点是 $(1,1)$，所以还要把 $a$ 变成 $1$，操作次数为 $a-1$，需加上。
- 还需要特判一下，当 $(a,b)$ 中 $b$ 成为 $0$ 后，说明该方案是不合法的，返回正无穷即可。

思路完毕，最后贴上代码。
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,min_=1e9;
int gcd(int a,int b){
    if(!b)return 1e9;
    if(b==1)return a-1;
    return gcd(b,a%b)+a/b;
}
int main(){
    scanf("%d",&n);
    for(int i=1;i<=n;i++)min_=min(min_,gcd(n,i));
    printf("%d",min_);
    return 0;
}
```
码量极小还跑的飞快，这多是一件美事啊。