先来看看样例：
```
0 0 0 0 0 0 0 1
0 0 0 0 0 0 1 1
0 0 0 0 0 1 0 1
0 0 0 0 1 1 1 1
0 0 0 1 0 0 0 1
0 0 1 1 0 0 1 1
0 1 0 1 0 1 0 1
1 1 1 1 1 1 1 1
```
貌似看不出什么来。。。（正是我月赛时的想法）

那么先把左上角的0去掉，再**镜像翻转**一下

我们就得到了这么一个东西：
```
1
1 1
1 0 1
1 1 1 1
1 0 0 0 1
1 1 0 0 1 1
1 0 1 0 1 0 1
1 1 1 1 1 1 1 1
```
这时许多大佬应该已经看出来了

如果没看出来再放一个
```
1
1 1
1 2 1
1 3 3 1
1 4 6 4 1
1 5 10 10 5 1
1 6 15 20 15 6 1
1 7 21 35 35 21 7 1
```
我终于发现了规律：
### 题目所求的正是前$2^n$行的杨辉三角对2取模的值
而且这道题的n最大值为10，也就是说最大要求1024行的杨辉三角，共运行$(1024+1)\times1024\div2\le1000000$次，也就是说程序不会TLE，太棒了！！！

那么一切都变得简单起来了

#### 上代码：
```
#include<iostream>
#include<cmath>
using namespace std;
int n,f[1025][1025];//2^n不会很大，可以放心储存二维数组
int main()
{
    cin>>n;n=pow(2,n);//直接将n替换为2^n
    for(int i=1;i<=n;i++)f[i][n]=f[i][n-i+1]=1;//初始化
    for(int i=3;i<=n;i++)//从第3行开始计算
    	for(int j=n-i+2;j<n;j++)//从每行第二项到倒数第二项
    		f[i][j]=(f[i-1][j]+f[i-1][j+1])%2;//边算边取模，不然一定会爆int，long long都没用
    for(int i=1;i<=n;i++)
    {
    	for(int j=1;j<=n;j++)cout<<f[i][j]<<" ";
    	cout<<endl;
	}//输出就好了
    return 0;
}//程序纯属本人构思，简短明了，希望月赛中也能像这样发挥......
```