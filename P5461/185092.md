# 递归
## recursion
程序调用自身的编程技巧称为递归（ recursion）。递归做为一种算法在程序设计语言中广泛应用。 一个过程或函数在其定义或说明中有直接或间接调用自身的一种方法，它通常把一个大型复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解，递归策略只需少量的程序就可描述出解题过程所需要的多次重复计算，大大地减少了程序的代码量。递归的能力在于用有限的语句来定义对象的无限集合。一般来说，递归需要有边界条件、递归前进段和递归返回段。当边界条件不满足时，递归前进；当边界条件满足时，递归返回。
## 题意
一个正方形方阵有2^n个人，将正方形矩阵均分为 4 个更小的正方形矩阵，每个更小的矩阵的边长是原矩阵的一半。其中左上角那一个矩阵的所有人都将得到赦免，剩下 3 个小矩阵中，每一个矩阵继续分为 4 个更小的矩阵，然后通过同样的方式赦免人……直到矩阵无法再分下去为止。
给出 n，请输出一个正方形矩阵，其中 0 代表被赦免，1 代表不被赦免。

先分析如何赦免右上的矩阵——（以样例一为例）
```
左上     右上      左下	    右下
0         7        0         7
4         7        0         3
4         5        0         1
4         4        0         0
```
得到规律——

左上点坐标=（前一个左上点坐标+前一个右上点坐标+1）/2

右上点坐标=前一个右上点坐标

左下点坐标=前一个左下点坐标

右下点坐标=（前一个左下点坐标+前一个右下点坐标）/2

递归边界=(x2-x1+1)%2!=0 **or** (y2-y1+1)%2!=0

……（以此类推）
# AC源代码：
```cpp
#include<bits/stdc++.h>
#define N 1025
using namespace std;
bool a[N][N];
int m,n;
void my_fill(int n1,int n2,int m1,int m2){
	for(int i=n1;i<=n2;i++)
		for(int j=m1;j<=m2;j++)
			a[i][j]=false;
}
void print(){
	for(int i=0;i<n;i++,cout<<endl)
		for(int j=0;j<n;j++)
			cout<<(int)a[i][j]<<" ";
}
void kill(int x1,int x2,int y1,int y2){
//	cout<<x1<<" "<<x2<<" "<<y1<<" "<<y2<<endl;（测试语句）
	if((x2-x1+1)%2!=0||(y2-y1+1)%2!=0)//递归边界
		return;
	else{
		my_fill(x1,(x2+x1)/2,y1,(y2+y1)/2);//赦免
		kill((x2+x1+1)/2,x2,y1,(y2+y1)/2);//递归
		kill(x1,(x2+x1)/2,(y2+y1+1)/2,y2);
		kill((x2+x1+1)/2,x2,(y2+y1+1)/2,y2);
	}
}
int main(){
	cin>>m;
	n=pow(2,m);
	fill(a[0],a[n-1]+n*n,true);
	kill(0,n-1,0,n-1);
	print();
	return 0;
}
```
