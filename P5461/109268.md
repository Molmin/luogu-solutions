(不想写LaTeX)

~~听说这是一道模拟/分治？？？就只有我用位运算吗？~~

分析了一下样例：

```
    000 001 010 011 100 101 110 111
000 0   0   0   0   0   0   0   1
001 0   0   0   0   0   0   1   1
010 0   0   0   0   0   1   0   1
011 0   0   0   0   1   1   1   1
100 0   0   0   1   0   0   0   1
101 0   0   1   1   0   0   1   1
110 0   1   0   1   0   1   0   1
111 1   1   1   1   1   1   1   1

```

1. 首先判断是否赦免的函数**一定是对称的**

为啥？

假设这个函数是 f(i,j)   (第i行，第j列）

那就有 f(i,j)=f(j,i)

**所以不可能把f（i,j）简化到f'（i-j）或f'(i/j)**

**~~经试验~~也不可能简化成f'(i+j),f'(i\*j)**

2. 由于i,j的取值在二进制上的位数都可以看做等于i，我们考虑用一下位运算

（~~我曾经设计了用位运算来求二叉树的LCA哈哈哈哈~~）

结果发现上图中 i|j=111（7）

所以有以下判断式：

**f(i,j)=((i|j)!=((1<<n)-1)?0:1);**


10行代码AC!

时间复杂度:Θ(4^n)!

OCD！

 (旁白:不要管这个沙雕,她HRM和7BH玩多了）

```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
int main(){
	scanf("%d",&n);
	for(int i=0;i<(1<<n);i++){
		for(int j=0;j<(1<<n);j++){
			printf("%d ",(i|j)!=((1<<n)-1)?0:1);}
		printf("\n");}
	return 0;}
```
