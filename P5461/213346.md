# 刚 刚 做 完 ！

咳咳，话说这道题啊嘞。。。我们可以画图来~~手动模拟~~

#### step1:

| 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 |
| 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 |
| 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 |
| 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 |
| 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 |
| 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 |
| 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 |


//这里初始都是不被赦免的，所以初始全部为1

#### step2:

| 0 | 0 | 0 | 0 | 1 | 1 | 1 | 1 |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| 0 | 0 | 0 | 0 | 1 | 1 | 1 | 1 |
| 0 | 0 | 0 | 0 | 1 | 1 | 1 | 1 |
| 0 | 0 | 0 | 0 | 1 | 1 | 1 | 1 |
| 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 |
| 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 |
| 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 |
| 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 |


//可以看到的说，题意中的分成四个小正方形其实就是指将原矩阵截为四个边长2^(n-1)的小正方形

//因为要赦免左上角的一部分嘛。。。所以说就把左上角的一部分变为0

#### step3:

| 0 | 0 | 0 | 0 | 0 | 0 | 1 | 1 |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| 0 | 0 | 0 | 0 | 0 | 0 | 1 | 1 |
| 0 | 0 | 0 | 0 | 1 | 1 | 1 | 1 |
| 0 | 0 | 0 | 0 | 1 | 1 | 1 | 1 |
| 0 | 0 | 1 | 1 | 0 | 0 | 1 | 1 |
| 0 | 0 | 1 | 1 | 0 | 0 | 1 | 1 |
| 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 |
| 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 |

//于是乎我们又把剩下的三个小正方形割了出来，~~然后就成了上面这个鬼畜的东西~~

#### step4:


| 0 | 0 | 0 | 0 | 0 | 0 | 0 | 1 |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| 0 | 0 | 0 | 0 | 0 | 0 | 1 | 1 |
| 0 | 0 | 0 | 0 | 0 | 1 | 0 | 1 |
| 0 | 0 | 0 | 0 | 1 | 1 | 1 | 1 |
| 0 | 0 | 0 | 1 | 0 | 0 | 0 | 1 |
| 0 | 0 | 1 | 1 | 0 | 0 | 1 | 1 |
| 0 | 1 | 0 | 1 | 0 | 1 | 0 | 1 |
| 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 |

//这时候我们就得到了最后的输出，共计n+1步



------------
那么这时候我们就来思考一下我们的算法——

~~模拟~~

### 暴力出奇迹！

我们可以根据我们刚才做题的思路

首先我们是从(0,0)赦免到(n/2,n/2)

然后继续分别赦免(n/2+1,0)到(n/2+1,n)……

但是我们采用的方法是一样的，都是不断的割割割割鸽鸽鸽鸽鸽……~~（逐渐本质起来）~~

而对于鸽好的每一个部分，我们就采用鸽出它的方法继续鸽

这熟悉的感觉。。。这熟悉的配方。。。这难道就是。。。

## ~~暴力~~ 分治！

~~喵喵喵!(激动得露出了本质~~

所以说我们就把这么一个

~~让kkksc03大发慈悲~~

~~善良~~

好题被我们转化成了~~暴力~~分治

上代码：

```cpp
#include <iostream> 
#include <cstring>		//比赛不敢用bits/stdc++.h（瑟瑟发抖）

using namespace std;

bool g[2000][2000];		//开两千不会爆（亲测）

void dfs(int x, int y,int n){		//（其实还是个二维dfs）
	if(n > 0){		//判断条件！避免出不来
		for(register int i = x; i < n / 2 + x; i++){	//开始赦免
			for(register int j = y; j < n / 2 + y; j++){
				g[i][j] = 0;
			}
		}
		dfs(n / 2 + x, y, n / 2);		//分治右上角，范围莫得错（不要问我为什么我会让你注意）
		dfs(x, n / 2 + y, n / 2);		//左下角
		dfs(n / 2 + x, n / 2 + y, n / 2);		//右下角
	}
} 

int main(int argc, char* argv[]){
	register int* n = new int;		//日常水指针
	cin >> *n;
	*n = 1 << *n;		//相当于2^n次幂，左移运算，相对快一些（其实就是自己懒得写快速幂）
	memset(g, true, sizeof(g));		//手写memset也行（懒得一批）
	dfs(0, 0, *n);		//从(0,0)开始分治
	for(register int i = 0; i < *n; i++){
		for(register int j = 0; j < *n; j++){
			cout << g[i][j] << " ";		//输出，没啥，别忘空格
		}
		cout<<endl;		//每行都要回车的呢。。。
	}
	delete n;		//指针党勿忘qaq
	return 0;
}
```

所以这么一道~~水~~好题就被我们轻松敲完喏！