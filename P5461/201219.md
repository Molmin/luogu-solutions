
矩阵需要用到二维数组保存。
#####  ps:"return value 3221225725"是因为数组过大主函数的内存承受不住，需要在主函数外定义（全局）。
## 具体实现：
观察样例图像，联系题目：可以得到几个部分的图像信息及规律：
下文以样例为例：
```
0 0 0 0 0 0 0 1
0 0 0 0 0 0 1 1
0 0 0 0 0 1 0 1
0 0 0 0 1 1 1 1
0 0 0 1 0 0 0 1
0 0 1 1 0 0 1 1
0 1 0 1 0 1 0 1
1 1 1 1 1 1 1 1
```
### 1：任意矩阵中，除去左上矩阵，其他三份的“形状”（即内部图像）是完全一致的；
### 2：基础的图像为：
```
0 1
1 1
```
### 3：填充图像大小由左上到右下缩小直至边长为1
###### 过程：
###### 1：从左上角（1,1）至（4,4）填充$4^{2}$大小的0.；
###### 2：从（5,5）填充$2^{2}$大小的0至（6,6）;
###### 3：在（7，7）填充$2^{2}$大小的0；（填充边长逐渐缩小，直至填充为$1^1$大小的图像）；
如此得到
```
0 0 0 0 1 1 1 1
0 0 0 0 1 1 1 1
0 0 0 0 1 1 1 1
0 0 0 0 1 1 1 1     
1 1 1 1 0 0 1 1
1 1 1 1 0 0 1 1
1 1 1 1 1 1 0 1
1 1 1 1 1 1 1 1
```
#### （ps：慢些看，~~自己写的时候都有点蒙~~打印图像的思维模式还是需要好好掌握的）
   观察发现，右下角$2^2$的小矩阵就是基础图像

   我们可以把右下角已按要求赦免的图像“复制”到该矩阵上方和左方的$2^2$矩阵

   接下来扩大复制范围，将右下角的$4^2$矩阵“复制”到上方及左方同等大小矩阵。

   以此类推，直到填充大小为原来以$2^n$次方为边长的正方形的1/4（填充来源边长为初始边长的1/2）；

#### 样例的“复制”一次的结果：
```
0 0 0 0 1 1 1 1
0 0 0 0 1 1 1 1
0 0 0 0 1 1 1 1
0 0 0 0 1 1 1 1
1 1 1 1 0 0 0 1
1 1 1 1 0 0 1 1
1 1 1 1 0 1 0 1
1 1 1 1 1 1 1 1
```

如上操作，就可以得到题目要求图像；
#### 分析完毕，得到控制图像生成的两个循环体
1：自左上向右下填充n次内容为0的矩阵，边长由 $2^{n-1}$
逐渐缩小至1。

2：“扫描”右下的 $2^{2}$ 矩阵，将该矩阵内图像向上，左两方向“复制”，随即扩大复制范围边长，直至复制边长扩大到 $2^{n-1}$。

#### 下列AC代码就直接给出了，具体过程在代码里，写了旁批方便阅读。
```cpp
#include<cstdio>
using namespace std;
int jz[1025][1025];
int main(){
	//freopen("smzf.out","w",stdout);
	int n,bc=1; 
	scanf("%d",&n);
	for(int i=1;i<=n;i++)	bc*=2;
	int BC=bc;
	for(int i=1;i<=bc;i++)
		for(int j=1;j<=bc;j++)
			jz[i][j]=1;
	int qsi=0,qsj=0;
	bc=bc/2;//边长的一半,第一次循环坐标终点； 
	int bj=bc,f=BC/2;//bj(同时控制填充0范围)；f（控制填充次数）。
	while(f>=1){ 
		for(int i=qsi;i<=bj;i++){//从起始点(起始点不断变化)开始将0填充在2的f次方为边长的正方形矩阵内； 
			for(int j=qsj;j<=bj;j++){
				jz[i][j]=0;
			}
		}	
		qsi=bj+1;//从填充终点向下走一格； 
		qsj=qsi;//从填充终点向右走一格； 
		f/=2;//填充范围边长缩小； 
		bc/=2; //新填充范围边长； 
		bj+=bc;	// 新填充范围终点点坐标; 			
	}//↑为"填充0"步骤循环体, ↓为"基础图像逐步'复制'过程"循环体； 
	int s=2,x,y;
	for(s=2;s<=BC/2;s*=2)//控制复制次数； 
		for(x=BC-s+1;x<=BC;x++)//从右下角扫描以s为边长的矩阵。 
			for(y=BC-s+1;y<=BC;y++){
				jz[x-s][y]=jz[x][y]; 
				jz[x][y-s]=jz[x-s][y];//←↑粘贴扫描结果
			}
	for(int i=1;i<=BC;i++){
		for(int j=1;j<=BC;j++)
			printf("%d ",jz[i][j]);
		printf("\n");
		}		
	return 0;
}
```
### 总结：

PS:部分采用英文标点请谅解！
#### 看到这里很感谢！话很多，但是很详细！望大家认真的看，初次写题解多多关照！

2020-03-08 简化代码注释
