## 基本思路
仔细观察输出样例，其实可以发现一些规律的。
下面是输出样例：
```
1|0 0 0 0 0 0 0 1
2|0 0 0 0 0 0 1 1
3|0 0 0 0 0 1 0 1
4|0 0 0 0 1 1 1 1
5|0 0 0 1 0 0 0 1
6|0 0 1 1 0 0 1 1
7|0 1 0 1 0 1 0 1
8|1 1 1 1 1 1 1 1
```
其实也不难发现，每一个数都是它上面的那个数和它右上方那个数异或的结果。（异或，即不同结果为1，相同结果为0）

状态转移方程：
```
f[i][j]=f[i-1][j]^f[i-1][j+1]; //^为异或运算
```
再进行降维优化，可得：
```
f[i]=f[i]^f[i+1];
即f[i]^=f[i+1];
```
主要部分已经清楚了，但是为了保证第1行能正确输出，我们要注意第0行的初始化。我们可以将第0行进行这样的处理：
```
0|1 1 1 1 1 1 1 1 0//第0行不用输出
1|0 0 0 0 0 0 0 1
2|0 0 0 0 0 0 1 1
3|0 0 0 0 0 1 0 1
4|0 0 0 0 1 1 1 1
5|0 0 0 1 0 0 0 1
6|0 0 1 1 0 0 1 1
7|0 1 0 1 0 1 0 1
8|1 1 1 1 1 1 1 1
```
思路清晰，就可以开始打代码了。
# 最简单的DP AC代码（我知道你只想要这个）
时间复杂度$O(4^{n})$
空间复杂度$O(2^{n})$
```cpp
#include<cstdio>
#include<cmath>
bool f[1025]={};
int n,l;
int main()
{
    scanf("%d",&n);
    l=pow(2,n);					//几行几列。pow(x,y)在cmath中，求x的y次方。
    for(int i=1;i<=l;i++)
    {
        f[i]=1;
    }
    for(int i=1;i<=l;i++)
    {
        for(int j=1;j<=l;j++)
        {
            printf("%d ",f[j]^=f[j+1]);	//状态转移方程。这里我计算一个输出一个。
        }
        printf("\n");				//注意格式
    }
    return 0;
}
```
月赛时因为评测机的问题出来50分，多提交了几遍，最后评测机修复后就只有85分了。。。。（可恶的乐多赛制）

为什么用dp？因为其他的我也不会，hhhhhh