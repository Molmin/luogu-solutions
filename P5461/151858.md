### 一道模拟题 P5461 赦免战俘

思路：在初始值为1的矩阵中挖0（下面的代码中是在0里挖1），类似深搜和分治,每次调用函数将右上方的正方形清零，再继续处理剩余的三个正方形，个人认为这是不加任何优化思维难度最低的常规方法。

如图:将一个方阵分成4个方阵，方阵1制为0，然后对其余3个方阵执行该过程

| 方阵1 | 方阵2 |
| :----------: | :----------: |
| 方阵3 | 方阵4 |

```cpp
#include<stdio.h>//C头文件
#include<math.h>
int map[1100][1100],n;
void sm(int x1,int y1,int x2,int y2,int cnt)
//方阵左上角坐标(x1,y1),方阵右上角坐标(x2,y2)
//cnt表示挖0的轮数(由边长等于2的n次方且方阵边长每次除以二得cnt==n时已挖完)
{
	//对两点标记的方阵挖0
	int i;
	for(i=x1;i<=(x2-x1)/2+x1;i++){
		int j;
		for(j=y1;j<=(y2-y1)/2+y1;j++){
			map[i][j]=1;//标记为“赦免”
		}
	}
    //类似深搜
	if(cnt<n){//判断轮数，亦可放在函数开始时
		sm(x1,(y2-y1+1)/2+y1,(x2-x1+1)/2+x1-1,y2,cnt+1);//方阵2
		sm((x2-x1+1)/2+x1,y1,x2,(y2-y1+1)/2+y1-1,cnt+1);//方阵3
		sm((x2-x1+1)/2+x1,(y2-y1+1)/2+y1,x2,y2,cnt+1);//方阵4
	}
	return;
}
int main()
{
	scanf("%d",&n);//输入n如题
	int bc=pow(2,n);//作弊者方阵边长
	sm(1,1,bc,bc,1);//赦免~~(sm)~~
	int i;
	for(i=1;i<=bc;i++){
		int j;
		for(j=1;j<=bc;j++){
			printf("%d ",!map[i][j]);//输出
		}
		printf("\n");
	}
	return 0;
}
```
**另外:不难发现所求“赦免”01方阵次对角线左侧均为0,可利用此修改算法，降低复杂度**

### **ACSDF·Mubuky**