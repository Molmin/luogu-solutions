题解：

这一题虽然已经有大神写过题解了，可是个人觉得他们的题解虽然看起来已经是非常简洁了，可我觉得还是太慢了。那么我这个题解就是在对烟数量的处理上加以了改进，使之更快捷。此标程仅供参考。

```delphi
var k,n,sum:longint;
begin
  read(n,k);
  sum:=n;{先将所有烟都抽了，sum用于记录总烟数所以也就等于n了}
  while n>=k do{直到烟头数不能再换烟了为止}
    begin
      n:=n-k+1;{烟头数减去k个需换烟蒂，因为又有一个烟抽了，所以再加一个烟头数}
      inc(sum);{抽的总烟数加一}
    end;
  write(sum);
end.
```
先说一下我这个题解的详细内容解释。我先是将sum记录成当前已经有的烟的数量，因为这些烟必定是会抽的，所以现在n个烟已经全部变成烟头了，然后在用个循环，第七行的意思就是烟头的总数减去能换的k个，然后就会又有一支烟了，所以烟头数再加一，然后抽的烟的总数加一。

就是这么简单，这样子写出的程序快了不只是一星半点，所以请大家要好好理解呀。
