由一个奇妙的性质：

对于第 $i$ 行 $j$ 列的格子 $(i,j)$，如果满足 $i>1$ 或 $j>1$ 且 $(i-1,j)$，$(i-1,j-1)$ 和 $(i,j-1)$ 的颜色已经确定，那么这个格子只会有一种填法。

数据不大一共 $2^3=8$ 种情况，可以手玩推出。

也就是说确定了第一列和第一行的状态之后，整个矩阵的状态就确定了。

那么现在只需要来确定第一行和第一列的状态即可。这样就变成了一个 DP 了。

设 $f[i][0/1][0/1]$ 表示前 $i$ 个格子中最后一个格子的颜色是黑色/白色，结尾是否连续放置了两个相同颜色的格子。

初始化 $f[1][0][0]=f[1][1][0]=1$。

对于所有的 $i$ 满足 $i>1$：

- $f[i][0][0]=(f[i-1][1][0]+f[i-1][1][1]) \mod 10^9+7$。既然结尾没有连续放置两个相同颜色的格子，那么上一个格子一定是另外一种颜色，所以要从 $f[i-1][1][0/1]$ 转移。

- $f[i][0][1]=f[i-1][0][0]$。既然结尾连续放置了两个相同颜色的格子，那么上一个格子一定是相同的颜色，所以要从 $f[i-1][0][0]$ 转移。

- $f[i][1][0/1]$ 的情况类似，就不再赘述。

最终答案即为

$$((\sum_{i=0}^{1} \sum_{j=0}^{1} f[n][i][j]+f[m][i][j])-2) \mod 10^9+7$$

为什么要 $-2$ 呢？因为我们漏掉了一些不合法的情况，即 $(1,1),(1,2),(2,1)$ 颜色相同。

时间复杂度 $O(n)$。

```cpp
# include <bits/stdc++.h>
# define int long long
# define rr register
const int N=100010,MOD=1e9+7;
int f[N][2][2];
signed main(void){
	int n,m;
	scanf("%I64d%I64d",&n,&m);
	f[1][1][0]=1;
	f[1][0][0]=1;
	for(rr int i=2;i<=std::max(n,m);++i){
		f[i][0][1]+=f[i-1][0][0];
		f[i][0][1]%=MOD;
		f[i][0][0]+=f[i-1][1][1]+f[i-1][1][0];
		f[i][0][0]%=MOD;
		f[i][1][1]+=f[i-1][1][0];
		f[i][1][1]%=MOD;
		f[i][1][0]+=f[i-1][0][1]+f[i-1][0][0];
		f[i][1][1]%=MOD;
	}
/*	for(rr int i=1;i<=n;++i){
		printf("%d %d %d %d\n",f[i][0][0],f[i][0][1],f[i][1][0],f[i][1][1]);
	}*/
	printf("%I64d",((f[n][0][0]+f[n][0][1]+f[n][1][0]+f[n][1][1]+(f[m][0][0]+f[m][0][1]+f[m][1][0]+f[m][1][1])-2)%MOD));
	return 0;
}
```