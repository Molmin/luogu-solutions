### 题目大意

给出每周播出的动画节目的开始和结束时间，不能同时观看超过一个节目，每周观看的节目集合必须完全相同。求每周最多能观看多少节目？

一周的时间长度是 $m$，如果某个动画节目的开始时间 $s$ 大于结束时间 $t$，意味着这个节目跨过了这一周到下一周的边界（也就是在下一周的 $t$ 时刻结束）

### 思路

我们可以将一周的起点和终点连起来，形成一个圆周。本题就变成了求一个圆周上的最多不相交区间问题。读入时对于 $s>t$ 的区间做一下处理，将 $t$ 的值增加 $m$。

### $O(n\log n)$ 做法

我们考虑枚举第一个选择的区间，然后对之后的区间求最多不相交区间数即可。

每当我们选择一个区间，下一个区间的选择由贪心法确定：选取不相交区间中，结束位置最靠前的一个。重复这一过程直到不能再选出新的区间为止。

设起始区间为第 $i$ 个区间，并按照贪心规则依次选取区间。假设选取出的区间为 $nxt[i][0],nxt[i][1],nxt[i][2],\cdots,nxt[i][k-1]$（其中 $nxt[i][0]=i$ ）。直到下一个将要选取的区间的结束位置 $t>s_i+m$。单次时间复杂度 $O(n)$ 。

由于要枚举所有 $n$ 个起始区间，所以总时间复杂度为 $O(n^2)$ ，一定超时，所以我们需要对每个起始区间，快速求不相交区间数。

注意到 $nxt[i][2]$ 实际上是“下一个”的“下一个”，于是我们可以先算出所有区间的“下一个”，然后就可以一次循环算出所有 $nxt[i][2]$ 。接下来用 $nxt[i][2]$ 算出所有 $nxt[i][4]$ ……依次倍增。

接下来对于每个起始区间 $i$ ，就可以通过二分法计算出可以选出的最多区间数。


### 得到“下一个区间”的方法

首先将环复制一遍，化成链。然后按结束位置 $t$ 从小到大排序，结束位置相同的按 $s$ 从小到大排序。对每个区间，在区间数组中向后遍历，找到第一个不相交的区间。这个方法的时间复杂度仍为 $O(n^2)$，需要优化。

我们将寻找“下一个区间”的过程分成两部分：第一步向后遍历找到第一个满足 $s_j \ge t_i$ 的区间 $j$ 。第二步判断区间 $j$ 是否满足 $t_j \le s_i+m$ 。如果满足， $j$ 就是区间 $i$ 的“下一个区间”；如果不满足，则区间 $i$ 没有“下一个区间”。

对于第一步，由于区间是按照 $t$ 从小到大排列的，如果区间 $j$ 是第一个满足 $s_j \ge t_i$ 的区间，那么第一个满足 $s \ge t_{i+1}$ 的区间就一定不可能在 $j$ 前面。据此，我们可以使用尺取法，在 $O(n)$ 时间内求出所有区间的“下一个区间”。

$O(n\log n)$ 代码

```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;
const int MR=1e5+5;
struct Anime{
	int s,t,id;
}a[MR*2];
bool cmp(const Anime& x,const Anime& y){
	if(x.t!=y.t) return x.t<y.t;
	if(x.s!=y.s) return x.s<y.s;
	return x.id<y.id;
}
int n,m;
int s[MR*2],t[MR*2];
int nxt[20][MR*2];
int main(){
	cin>>n>>m;
	//读入，变环成链 
	for(int i=0;i<n;i++){
		cin>>s[i]>>t[i];
		if(s[i]>t[i]) t[i]+=m;
		a[i].s=s[i];a[i].t=t[i];
		a[i].id=i;
		s[i+n]=s[i]+m;t[i+n]=t[i]+m;
		a[i+n].s=a[i].s+m;
		a[i+n].t=a[i].t+m;
		a[i+n].id=a[i].id+n;
	}
	//按结束时间排序 ，结束时间相同按开始时间 
	sort(a,a+2*n,cmp);
	memset(nxt,-1,sizeof(nxt));
	//nxt[0][now]=和节目now没有重叠时间的所有节目中
	//结束时间最早的一个，即“下一个区间” 
	int j=1;
	for(int i=0;i<2*n;i++){
		int now=a[i].id;
		for(;j<2*n;j++){
			if(a[i].t<=a[j].s){
				nxt[0][now]=a[j].id;
				break;
			}
		}
		if(j<2*n && a[j].t-m<=a[i].s) nxt[0][now]=a[j].id;
	}
	//接下来计算nxt[k][id]：区间id的2^k个之后的区间
	for(int k=1;k<20;k++){
		for(int id=0;id<2*n;id++){
			if(nxt[k-1][id]!=-1) nxt[k][id]=nxt[k-1][nxt[k-1][id]];
		}
	}
	//枚举起始区间，计算以i为起始区间，最多能取多少区间
	int ans=0;
	for(int i=0;i<n;i++){
		int now=i,cnt=0;
		for(int k=19;k>=0;k--){
			//尝试前进(1<<k)步
			int j=nxt[k][now];
			//如果没有走过头
			if(j!=-1 && t[j]<=s[i]+m){
				now = j;
				cnt |= 1<<k;
			}
		}
		//起始区间i是第0步，所以最多能取cnt+1个区间
		ans=max(ans,cnt+1);
	}
	cout<<ans<<endl;
	return 0;
}
```

更新： $O(n)$ 做法是错解！有hack数据：
```
10 50
14 43
11 48
35 6
38 46
45 1
3 28
9 36
37 1
6 26
46 14
```

原 $O(n)$ 做法：仍然用贪心法得到每个区间的“下一个区间”，然后构造一个有向图，每个区间向自己的“下一个区间”连一条有向边。如果某个区间没有“下一个区间”，就和向自己连一条有向边。那么图中长度最长的环的长度就是答案。

上面的数据用这个做法，得到的最长的环为 $ 0 \rightarrow 4 \rightarrow 8 \rightarrow 3 \rightarrow 9 \rightarrow 0$，但是最后的第0个节目，实际上已经是第3天的了。

