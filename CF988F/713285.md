### 题意
有一个长度为 $a$ 的区间，给定 $n$ 个有雨的区间和 $m$ 把伞的位置与重量，每次可以向右移动一个单位，代价是携带伞的总重量。在经过有雨的单位时（**注意是边而不是点，因此区间两端不算**），必须携带伞才能通过。求最小的通过区间的代价之和。


### 分析
为了能更清楚的表现出当前的局面，因此不妨考虑状态为 $i,j,v$ 分别表示前 $i$ 个单位用到了第 $j$ 把伞最小花费的代价 $v$，结果是 $i=x$ 时的任何合法状态。当状态转移不到结果时，则输出 ```-1```。

对于每一个点，有三种操作：捡伞、丢伞、换伞。每个状态可以分两次转移，分别是:（$k$ 是当前位置拥有的伞，$k$ 等于零表示没伞，$k$ 等于 $j$ 表示不变，$0 \le i \le a$，$0 \le$ 当前位置伞的数量，$w_i$ 表示第 $i$ 个伞的重量。）
$$i,j,v \rightarrow i,k,v$$
$$i,k,v \rightarrow i+1,k,v+w_k$$
第一个转移是将当前伞换成当前位置的其他伞，第二个转移是向右走一个单位。

答案就是从 $0,0,0$ 到 $a,j,v$ 花费最小代价的一条路径。

对于每一个相同的 $i,j,v$，它们对答案的贡献完全相同，只有选择的方案不同，因此可以只保留一个。

对于答案来说，我们不需要知道它每次选择的方案，只需要知道它的代价，因此我们只需要保留单个状态 $i,j,v$。

时间复杂度:$\mathit{O}(am^2)$。


### 思路
接下来就是考虑优化一下状态了，考虑状态分组。可以发现，对于每一个 $i,j$，只要它的状态最优，那么它作最优的转移之后就不会比其他状态更劣。因此我们就可以将 $i,j$ 分在一起，$v$ 作为附带属性。对于每个 $i,j$ 相等的状态，只需要保留 $v$ 最优的那个就行了。这样的话，每次转移只需要作最优的就行了。在这种情况下，就可以考虑剪枝，每次当当前状态更优时，则更新最优值，否则放弃。

虽然可以优化代码时间，但是并不会改变它的时间复杂度。当值是按照从劣到优排序时，则时间复杂度依旧是：$\mathit{O}(am^2)$。


状态优化完了，就可以优化转移了。实际上，每次转移的时间复杂度是：$\mathit{O}(m)$，而状态的数量又是：$\mathit{O}(am)$。因此只能将转移优化到：$\mathit{O}(1)$。

按照优化状态的思路，我们只需要保留最优的转移就行了。换言之，一个位置上有多把伞，我们只需要转移到重量最小的那把就行了，因为最优的状态作最优的转移，一定不会转移到比它更劣的状态上，所以优化是正确的。

时间复杂度：$\mathit{O}(am)$


### 延伸
至此，我依旧没有讲动态规划，因为从这个状态图中，$i$ 虽然具有拓扑序，但是 $j$ 没有。因为同一位置上的任意两把伞都可以互换，这样显然不具有拓扑序。但是根据搜索的解决思路：**对于每一个相同的 $i,j,v$，它们对答案的贡献完全相同，只有选择的方案不同，因此可以只保留一个**，再加上**同一个位置，无论换多少次伞，都不会增加代价**，因此我们只需要换一次伞就行了。这样的话 $j$ 就非常神奇的变得有拓扑序了。

上述思路如果没理解，可以想象成将拓扑序拉伸出来了：将 $j$ 这一维看成换之前与换之后。每次 $i,j,v$ 可以转移成 $i,k,v$（$k$ 表示当前位置拥有伞的数量）。

再根据搜索优化转移的方法，可以将没有伞的位置设为当前位置最优的状态，在由没有伞的位置去更新当前位置所拥有的伞。如果当前位置下雨，那么就将没有伞的状态设为一个极劣值。

状态转移方程：

$$1 \leq i \leq a$$
$$1 \leq j \leq m$$
$$dp_{i,0}=\min(dp_{i,j},dp_{i,0})$$
$$dp_{i,j}=\min(dp_{i,j},dp_{i,0})$$
$$dp_{i+1,j}=\min(dp_{i+1,j},dp_{i,j}+w_j)$$


### 代码
```cpp
// 状态转移方程 ：(1 <= i <= x) (1 <= j <= m) dp[i][0]=min(dp[i][j],dp[i][0])  dp[i][j]=min(dp[i][j],dp[i][0]) dp[i+1][j] = min(dp[i+1][j], dp[i][j] + a[j].second)
#include <iostream>
using namespace std;
using LL = long long;
const LL MAXN = 2005;
LL x, n, m, dp[MAXN][MAXN], ans = INT_MAX;
bool vis[MAXN];
pair<LL, LL> a[MAXN];
signed main() {
  ios::sync_with_stdio(0);
  cin >> x >> n >> m;
  fill(dp[0], dp[x] + m + 1, INT_MAX);
  dp[0][0] = 0;
  for (LL i = 1, l, r; i <= n; i++) {
    cin >> l >> r;
    fill(vis + l, vis + r, 1);//标记下雨
  }
  for (LL i = 1; i <= m; i++) {
    cin >> a[i].first >> a[i].second;
  }
  for (LL i = 0; i <= x; i++) {
    for (LL j = 1; j <= m; j++) {
      dp[i][0] = min(dp[i][0], dp[i][j]);//更新最优
    }
    for (LL j = 0; j <= m; j++) {
      a[j].first == i && (dp[i][j] = min(dp[i][j], dp[i][0]));//更新当前位置的所有状态
      dp[i + 1][j] = min(dp[i + 1][j], (!j && vis[i] ? INT_MAX : dp[i][j] + a[j].second));//向右走一步
      i == x && (ans = min(ans, dp[i][j]));//更新最终答案
    }
    vis[i] && (dp[i][0] = INT_MAX);//标为不合法
  }
  cout << (ans == INT_MAX ? -1 : ans);
  return 0;
}
```
