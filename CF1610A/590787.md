**题目大**意：
对于网格内任意一点 $(x,y)$，需要知道多少个坐标与点 $(x,y$） 的关系$(∣x−x 
i
​	
 ∣+∣y−y 
i
​	
 ∣)$，才能求出点 $(x,y)$ 的坐标.

根据题目大意，对于每次询问，可以通过列举每种情况下的答案来研究一下答案的一些规律。

* 我们不妨先解决最极端的情况：当网格只有一个点 $(n=1,m=1)$,此时可以直接猜出答案，次数为 $0$。





* 其次，我们再来看一下第二种情况：当网格呈一条线段时 $(n=1,m>1 || n>1,m=1)$,任意一点到端点的距离都不同，因此，我们只需要得出起点 $(1,1)$ 或终点的坐标与点 $(x,y)$的距离关系，即可得出 $(x,y)$,次数为 $1$。





* 最后，排除了以上两种情况后，第三种情况，即：当网格呈一个平面时$(n>1,m>1)$，如果我们只去询问一个点：即： $b=|x-x_1|+|y-y_1|$,显然，$b$ 可以拆分成多种答案，无法确定位置。**那么，我们去询问左上点 $(1,1)$ 和右下点 $(n,m)$ 与 $(x,y)$ 的关系，此时，任意不在这条左斜线上的点个和不在右斜线上的点，分别与左上点和右下点的关系都不同，即可得出 $(x,y)$ 的位置，次数为 $2$。即
$b_1=|x-x_1|+|y-y_1|$

$b_2=|x-x_2|+|y-y_2|$。*


这，就是各位大佬口中的曼哈顿的圆。~~我也是做题的时候才知道的~~~~~


#### 上代码——

## $Code$

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<cstring>
#include<algorithm>
#include<bits/stdc++.h>
using namespace std;
int t,n,m;
int main(){ 
    cin>>t;
    for(;t--;){
        cin>>n>>m;
        if(n==1&&m==1)printf("0\n");
        else if(n==1||m==1)printf("1\n");
        else printf("2\n");
    }
    return 0;
} 
```
做完这题，我不禁想到了一个东西：

如果要广播一个一维文明的坐标，需要一张点阵参照图；如果要广播一个二维文明的坐标，需要两张点阵参照图…………