诶呀，做完这道题我简直是浑身舒畅qaq

~~大家都是看到标题进来的吗~~

我好像提交了三十多次~

为了不让大家和我一样，我写了这篇题解：

------------------------

#### 看完这道题我们可以分析出这道题是DP

然后进行DP四部曲：

First状态定义：

这道题的时间限制能保证我们用三次方算法，有大佬写的是平方算法，蒟蒻看不懂呀~言归正传，我们可以用自然定义法：f[i][j][k]表示前i场比赛中，他们去看了j场比赛，小红的满意度为k。

Second决策定义：

我们可以用最原始的方法，定义决策为去第i场或不去第i场。

Third转移方程：
我们根据状态定义与决策定义很容易推出方程：

f[i][j][k]=max(f[i-1][j][k],f[i-1][j-1][k-b[p[i]]-b[q[i]]]+a[q[i]]*a[p[i]])

其中f[i-1][j][k]为不去的情况，直接i-1，也就是少一次比赛就可以了；而f[i-1][j-1][k-b[p[i]]-b[q[i]]]+a[q[i]]*a[p[i]]这个一大串是去的情况，去的话不但比赛要减一，去过的比赛数量也要减一，还有就是小红的满意程度要减去两个队帅哥数量的和，然后再最后加上小明的满意程度，再在这两个之间比较一下就OK了。

Finally边界设定：

我们要把这里的所有的各自都设成-1，因为这样可以体现那个地方是不满足条件的，在最后求出最大值时，也方便比较大小和输出。

易错点：
- 第一个是要注意，k不能大于小红的满意值，不然就会变成负数，后果你应该知道的。

- 第二个是我们应该在第二层循环处设一个min，因为j必须小于i，不然他们看的比赛场数比现有的还要多，并且j还要小于K，不然他们看的场数比实际的还多。

- 第三个是一个傻傻的错误，反正除了我这种蒟蒻别人好像不会犯，那就是设置边界的时候一定要从0开始

上代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
const int C=2005,NKM=105;
int n,m,K,c,a[NKM],b[NKM],p[NKM],q[NKM],f[NKM][NKM][C],sum;
int main(){
	memset(f,-1,sizeof(f));
	cin>>n>>m>>K>>c;
	for(int i=1;i<=n;i++) cin>>a[i];
	for(int i=1;i<=n;i++) cin>>b[i];
	for(int i=1;i<=m;i++) cin>>p[i]>>q[i],sum+=(b[q[i]]+b[p[i]]);
	for(int i=0;i<=m;i++) f[i][0][0]=0;
	for(int i=1;i<=m;i++)
		for(int j=1;j<=min(i,K);j++)
			for(int k=0;k<=sum;k++)
				if(k>=b[p[i]]+b[q[i]]&&f[i-1][j-1][k-(b[p[i]]+b[q[i]])]!=-1) f[i][j][k]=max(f[i-1][j][k],f[i-1][j-1][k-b[p[i]]-b[q[i]]]+a[q[i]]*a[p[i]]);
				else f[i][j][k]=f[i-1][j][k];
	int ans=-1;
	for(int i=c;i<=sum;i++) ans=max(ans,f[m][K][i]);
	cout<<ans<<endl;
	return 0;
}  
```
看到这里可能有些机智的同学~~比如我~~就会发现这段代码怎么看怎么像背包。没错，其实这道题就是一道背包，我也是写完之后才发现的，小红的满意度就是重量，小明的满意度就是价格，不过我没有尝试过，有兴趣的同学可以参考楼上大佬的题解。