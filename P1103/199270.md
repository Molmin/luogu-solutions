### 因为本人比较蒟蒻,所以用了3维的数组

###### 注:这一题要自己排序

$f[i][j][l]$,前$i$本书,没有被去掉的最后一本书的宽度为$j$,共去掉了$l$本数的最小不整齐度

#### 观察题目我们发现第$i$本书只有拿或不拿

- 如果拿,不整齐度就会加上它的宽度与没有被去掉的最后一本书的宽度之差的绝对值,且它就变成了没有被去掉的最后一本书,去掉的书的数目不变

- 不拿,就相当于把这本书去掉了,不整齐度不变,最后一本书不变,都是去掉书的数目加一

代码
```cpp
for(int i=2;i<=n;i++)//第几本书,从2开始,第1本书是初始化的
	{
		for(int l=0;l<=k;l++)//去掉了几本,注意从0开始
		{
			for(int j=1;j<=200;j++)//枚举前i-1本书被去掉的最后一本书
			{
				f[i][j][l]=min(f[i][j][l],f[i-1][j][l-1/*因为去掉书的数目要加一,所以用这里l-1(这里是l-1,加1不就是l来)*/]);//不拿
				f[i][a[i].w/*因为拿,最后一本更新为第i本*/][l]=min(f[i][a[i].w][l],f[i-1][j][l]+abs(a[i].w-j));//拿
			}
		}
	}
```


#### 初始化

先把所有定义为一个很大的数 
```
memset(f,25,sizeof(f));
```
但是第一本书是可以先确定的(其他的也要靠它推出来)

根据前面一本书只有拿或不拿

所以初始化第一本书也只有拿和不拿

直接上代码讲吧

```cpp
for(int j=1;j<=200;j++) f[1][j][1]=0;//不拿,前面没有书所以最后一本书可以是任意一本,之后如果有书与它计算一定是0(不影响结果不就相当于拿掉了)
f[1][a[1].w][0]=0;//拿,最后一本书就是它,但是只有一本书所以没有差值
```
#### 输出

因为最后一本不确定所以最后要枚举最后一本取最小值输出

代码
```cpp
for(int j=1;j<=200;j++) ans=min(ans,f[n][j][k]);//ans先定义一个很大的数
cout<<ans;//输出
```


完整代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,k,f[110][201][101],ans=12356478;
struct book
{
	int h,w;//h高,w宽
}a[10000];
int cmp(book s1,book s2)//送人头用的函数,表示高度从小到大排序
{
	return s1.h<s2.h;
}
int main()
{
	cin>>n>>k;
	for(int i=1;i<=n;i++)
	{
		cin>>a[i].h;
		cin>>a[i].w;
	}
	sort(a+1,a+n+1,cmp);//排序
	memset(f,25,sizeof(f));
	for(int j=1;j<=200;j++) f[1][j][1]=0;
	f[1][a[1].w][0]=0;
	for(int i=2;i<=n;i++)
	{
		for(int l=0;l<=k;l++)
		{
			for(int j=1;j<=200;j++)
			{
				f[i][j][l]=min(f[i][j][l],f[i-1][j][l-1]);
				f[i][a[i].w][l]=min(f[i][a[i].w][l],f[i-1][j][l]+abs(a[i].w-j));
			}
		}
	}
	for(int j=1;j<=200;j++) ans=min(ans,f[n][j][k]);
	cout<<ans;
}
```

