[题目传送门](https://www.luogu.com.cn/problem/CF1252A)

[提交记录](https://www.luogu.com.cn/record/109956601)



------------
**题目大意**：

给定一段长度为 $n$ 的序列，并将该序列重新排列，使得新序列与原序列每个元素的对应位置的差的绝对值之和大于等于序列的长度 $n$，若有多种情况则输出其中一种即可。


------------
**本题思路**：

既然要使新序列与原序列每个元素的对应位置的差的绝对值之和大于等于序列的长度 $n$，那么我们 **将新序列中的 $1$ 修改成 $n$，再把新序列中的 $n$ 修改成 $1$，并保持其余元素不变即可**。

那么这是为什么呢？因为既然序列中除 $n$ 和 $1$ 之外的所有元素不变，所以新序列与原序列每个元素的对应位置的差的绝对值之和就是

**$ |1-n| + |n-1| $**

又因为 $n$ 大于等于 $2$，所以原式可化简为 

 **$ 2 ( n - 1 ) $**

由此，上述结论成立。

但还有一个问题，为什么这个数列中一定会出现 $1$ 和 $n$ 呢，其实，这题的翻译有一点疏漏，在原题的输出格式中还有这么一句话：

**作为提醒，排列中的所有元素必须在 $1$ 到 $n$ 之间并且是不同的**。

看到这里，大家已经可以去愉快地打代码啦。


------------
**完整代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;

const int qaq=1e5+3;
int a[qaq];
int n;

int main(){
	ios::sync_with_stdio(false);cin.tie();cout.tie();
	
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>a[i];
	}
	for(int i=1;i<=n;i++)
	{
		if(a[i]==n)
		{
			cout<<"1 ";
			continue;
		}
		if(a[i]==1)
		{
			cout<<n<<" ";
			continue;
		}
		cout<<a[i]<<" ";
	}
	return 0;
}
```


------------
本人只是一名小蒟蒻，若有错误请指正，谢谢大家。





