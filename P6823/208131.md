这题其实就是~~简单的~~模拟，数据也~~不是很强~~

所以这题就只有**入门的难度**

其实想法很容易得到：

1.如果直接进行翻转的操作，会很复杂，那么就定义一个flag数组来标记当前数组本来应该是正的(```flag=false```)或者反的(```flag=true```)，最后再根据flag正向或者反向输出。

2.第一个操作和第二个操作其实都有初始化的功能。举个例子：```1 4 3 5 2``` 进行1号操作变成```1 2 3 4 5```，进行了2号操作变成```5 4 3 2 1```，之前进行了什么操作并没有什么关系，于是我们可以记录最后一个1或者2，再从对应位置进行后面的操作。（具体操作可以见代码）（代码里没有```sort```是因为第一次初始化之后数组就是从小到大升序排列的）

3.交换时要判断一下当前是正向还是反向的，举个例子，a数组（存储数字的数组）里的数字是：```1 7 5 3 4 2 6```，交换第4个和第6个数字，若是正向的，操作完就是：```1 7 5 2 4 3 6```，若是反向的，则就是：```1 3 5 7 4 2 6``` 。 由此可以得出：（其中q是存储问题的，详见代码）
```cpp
if(flag==false)	swap(a[q[i][1]],a[q[i][2]]);
else	swap(a[n-q[i][1]+1],a[n-q[i][2]+1]);
```

这就是大体的思路，虽然不是最优解，但AC还是足够了。

## 下面是AC代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,x=1,q[1000005][3],a[1000005];//q数组存储问题，a数组存储数字 
bool flag=false;//flag来表示数组正反，flag=false正向输出,反之就反向 
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)	a[i]=i;//初始化 
	for(int i=1;i<=m;i++)
	{
		scanf("%d",&q[i][0]);//读入 
		if(q[i][0]==1 || q[i][0]==2)	x=i;//记录最后的1或2（因为1或2具有初始化的功能） 
		if(q[i][0]==3)	scanf("%d%d",&q[i][1],&q[i][2]);//3号的读入一共3个 
	}
	if(q[x][0]==1)	x++;
	if(q[x][0]==2)	flag=true,x++;//执行最后的1或2 
	for(int i=x;i<=m;i++)
	{
		if(q[i][0]==3)
		{
			if(flag==false)	swap(a[q[i][1]],a[q[i][2]]);//正向交换 
			else	swap(a[n-q[i][1]+1],a[n-q[i][2]+1]);//反向交换是与正向交换不一样的 
		}
		if(q[i][0]==4)	flag=!flag;//改变正反向 
	}
	if(flag==false)	for(int i=1;i<=n;i++)	printf("%d ",a[i]);//正向输出 
	else	for(int i=n;i>=1;i--)	printf("%d ",a[i]);//反向输出 
}
```

**注**： _这是蒟蒻第一次写题解，可能有不足的地方，欢迎指出！~_ 