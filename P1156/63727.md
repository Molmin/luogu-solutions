
首先我们来分析题目，“**每个垃圾都可以用来吃或堆放**”，浓浓的透露出一个背包气息。我们可以类比背包问题的放或不放。于是$dp[i][j]$描述为处理前i个物品的某状态j,那么状态j代表什么呢？

~~我们可以继续分析题目并使用排除法~~

分析题目，我们需要求的答案是时间，于是很自然而然的想到j描述高度或生命，而dp数组存放时间。很显然，这样状态既不完整，也写不出转移方程。而且dp数组存的是当前状态下最大或最小的价值，似乎也不满足。

这时候我们发现，有4个值可能成为状态，高度，生命，物品和时间，难道要dp三维的吗？

再分析题目，每个垃圾都有一个下落的时间，**奶牛一定是在垃圾丢下来的时间就处理垃圾的**（可以得出这样的最优的），那么物品就可以和时间关联起来了。这时候，我们可以把时间仅仅当作干扰量给剔除了。

需要注意的是，**物品的使用顺序并不是随意的，必须按它们下落的时间顺序来先后处理。**（这里排一下序即可）

那么j代表什么呢？

一下子我们并不能得出答案。先尝试$dp[i][j]$代表前i件物品处理后在j血量时达到的最大高度。

值得一提的是，j血量表示奶牛在暂时不考虑时间时所得到的最大血量

~~据说这个是叫离线~~

试着写一下它的状态转移方程

$dp[i][j]=max(dp[i-1][j]+trash[i].h,dp[i-1][j+trash[i].c])$

发现这是对的，然而我们再想想，在关于j的一重循环里面，对j的取值我们似乎并不好判断，甚至要枚举很大。

所以我们再尝试讨论$dp[i][j]$代表前i件物品处理后在h高度时达到的最大血量。

状态转移

$dp[i][j]=max(dp[i-1][j]+trash[i].c,dp[i-1][j-trash[i].h])$

发现这样也是对的，而且j枚举起来也比较方便，于是我们选择这种算法。

------------
先讨论所谓的离线算法~~（我也不知道是不是这样叫的）（搞错了别打我）~~

意思就是先处理完所有的状态奶牛可以达到的血量再与时间进行讨论

这里我们使用填表法（填表法就是利用状态转移方程和上一个状态来推导出现在的状态）

```cpp
    for(int i=1;i<=g;i++)
        for(int j=0;j<=d;j++)
        {
            if(dp[i-1][j]>=trash[i].t)
                dp[i][j]=max(dp[i][j],dp[i-1][j]+trash[i].c);
            if(j>=trash[i].h&&dp[i-1][j-trash[i].h]>=trash[i].t)
                dp[i][j]=max(dp[i][j],dp[i-1][j-trash[i].h]);
        }
```

需要~~非常非常~~注意的是**状态的能否使用**（蒟蒻的我错了很多遍才想明白orz）

对于以前的状态$dp[i'][j']$能否使用，我们的要求是$dp[i'][j']>=trash[i].t$既它还没死（至于它为什么0血了还不会死，我只能说~~[数据已删除]~~）

~~才不会说我之前判用的是dp[ i '][ j ']!=-1(-1是我赋的初值)~~

最后扫一遍

```cpp
    int maxh=0;
    int maxt=0;
    int i;
    for(i=1;i<=g;i++)
    {
        for(int j=0;j<=d;j++)
        {
            if(dp[i][j]-trash[i].t>=0)
                maxh=max(maxh,j);
            maxt=max(maxt,dp[i][j]);
        }
        if(maxh==d)
            break;
    }
    if(maxh==d)
        cout<<trash[i].t<<endl;
    else
        cout<<maxt<<endl;
```

这里的maxt实际只用讨论$max(dp[i][0])$就行了

------------
因为蒟蒻的我开始时并没有注意到怎么判$dp[i'][j']$的能否使用性，我还写了在线的和刷表法（刷表法就是利用当前的状态，把有关联的下一状态都推出来）

这里也讨论一下

在线的思路是，$dp[i][j]$所描述的血量是当前时间（既第i件物品落下时）所真正具有的血量，而不是忽略时间。

```cpp
int maxt=0;
    for(int i=0;i<g;i++)
    {
        for(int j=0;j<=d;j++)
        {
            if(dp[i][j]>=trash[i+1].t-trash[i].t)
            {
                dp[i+1][j+trash[i+1].h]=max(dp[i+1][j+trash[i+1].h],dp[i][j]-(trash[i+1].t-trash[i].t));
                dp[i+1][j]=max(dp[i+1][j],dp[i][j]+trash[i+1].c-(trash[i+1].t-trash[i].t));
            }
            if(dp[i+1][j+trash[i+1].h]>=0&&j+trash[i+1].h>=d)
            {
                cout<<trash[i+1].t<<endl;
                return 0;
            }
        }
        if(dp[i][0]!=-1)
            maxt=max(maxt,dp[i][0]+trash[i].t);
    }
```

在这里我们边做边判断是否上去了并更新它的最长存活时间。

于是没了喵？