[题目链接：CF1574A Regular Bracket Sequences](https://www.luogu.com.cn/problem/CF1574A)

## 题目大意

给定一个 $n$，求出 $n$ 种合法（左右匹配）的 $n$ 对括号的排列方式。

例如当 $n=2$ 时，以下几种方案是合法的：

```plain
()()
(())
```

以下几种方案是不合法的：

```plain
)())
)()(
))((
```

## 解法

显然，当 $n \ge 3$ 时，合法的方案并不仅有 $n$ 种。我们只需按照一定的规律找出其中的 $n$ 种较简单的合法方案即可。

以下提供一种可行的思路：

首先，无论 $n$ 的值为多少，均存在着一种**不存在括号嵌套**的合法方案：

```plain
()()()()...
```

其次，存在 $n-1$ 种**仅存在一次括号嵌套**（一个 `(())`）的合法方案，即左边 $i$ 对连续的不嵌套的括号，中间一个 `(())`，右边 $n-i-2$ 对连续的不嵌套的括号。当 $i$ 取不同的值时，实际表现为 `(())` 在字符串中的位置不同。

因为 `(())` 为两对括号，所以 $i \in [0,n-2]$，该情况总共有 $n-1$ 种方案，加上第一种情况总共 $n$ 种。

## 实例

当 $n=1$ 时，以下是其中一种合法答案：

```plain
()
```

当 $n=2$ 时，以下是其中一种合法答案：

```plain
()()
(())
```

当 $n=3$ 时，以下时其中一种合法答案：

```plain
()()()
(())()
()(())
```

当 $n=4$ 时，以下是其中一种合法答案：

```plain
()()()()
(())()()
()(())()
()()(())
```

**注：当 $n=1$ 或 $n=2$ 时，都仅存在 $n$ 种合法方案，故此时仅存在一种合法答案。**

## 代码

```cpp
#include <iostream>
using namespace std;
int t,n;
int main()
{
	cin>>t;
	while(t--)
	{
		cin>>n;
		for(int i=1;i<=n;++i)  //不存在括号嵌套
		{
			cout<<"()";
		}
		cout<<endl;
		for(int i=0;i<=n-2;++i)  //仅存在一次括号嵌套
		{
			for(int j=1;j<=i;++j)
			{
				cout<<"()";
			}
			cout<<"(())";
			for(int j=1;j<=n-i-2;++j)
			{
				cout<<"()";
			}
			cout<<endl;
		}
	}
	return 0;
}
```