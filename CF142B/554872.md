# 0.前言
[我的AC记录](https://www.luogu.com.cn/record/55855397)

[题目传送门](https://www.luogu.com.cn/problem/CF142B)

看见提交题解的几位dalao没有用数学方法，本菜鸡来用数学方法来解一下本题。

此题没有公式，所有所谓的公式都是根据思路推出来的！下面看我的思路趴！

# 1.思路
每个“马”走一步，对应一个位置，所以相当于每个“马”可以待在两个位置的其中一个，要么是棋盘上的初始位置要么是走一步后的位置。

但每个“马”只能选择二者中的一个。

所以，除了 $1$ 和 $2$ 的特殊情况外，棋盘上放的“马”一定等于棋盘空间的**一半**。奇数 $/2+1$，偶数直接 $/2$。（证明在后面！！！）
## 2.特判：处理 $n$ , $m$ 其中一个为 $1$ 或 $2$ 的情况

**首先处理当 $n$ 或 $m$ 其中一个为 $1$ 的情况：**

当 $n$ 或 $m$ 其中一个为 $1$ 时，因为“马”走日，所以全部的格子都可以放。即：


```cpp
	if(n==1||m==1){
		cout<<max(n,m);
		return 0;
	}
```
应该很好理解。

**再处理 $2$：**

当其中一个数为 $2$ 并且另外一个数不为 $4$ 但是为 $2$ 的倍数时，简单试一下就知道结果为 $n+m$ ；

其中一个数为 $2$ 并且另一个数为 $2$ 的倍数时，结果 $\max(n,m)$ 。

再考虑奇数偶数情况即可。（奇数要 $+1$，偶数不用）

```cpp
if(n==2||m==2){
        if(max(n,m)%2==0){
            cout<<max(n,m)<<endl;
                return 0;
        }
        else{
            cout<<max(n,m)+1<<endl;
            return 0;
        }		
  }
```


其余直接输出格子数的 $1/2$。

# 3.code
AC代码如下：


```cpp
  #include<iostream>
  #include<cmath>
  using namespace std;
  int n,m;
  int main(){
      cin>>n>>m;
      if(n==1||m==1){
          cout<<max(n,m);
          return 0;
      }
      if(n==2||m==2){
          if(n==2){
              if(m%2==0&&m%4!=0){
                  cout<<n+m;
                  return 0;
              }
          }
          if(m==2){
              if(n%2==0&&n%4!=0){
                  cout<<n+m;
                  return 0;
              }
          }
          if(max(n,m)%2==0){
              cout<<max(n,m)<<endl;
              return 0;
          }
          else{
              cout<<max(n,m)+1<<endl;
              return 0;
          }
      }
      cout<<(n*m+1)/2;
  }
```
但说实话，当时我也真不知道 $2$ 为什么是这样，仅仅通过样例和一小部分数据就可以推理出来了。
# 4.总结&证明
总结：
在考试的时候，发现各种方法尝试过后都失败时，不妨试试数学的方法，自己尝试造一些数据，根据输入和输出找规律，这种方法尤其适用于只输出一个数的时候。就拿这道题举例，除了特殊情况外都为 $\max(n,m)\times \min(m,n)/2$，加 $1$ 需要判断奇偶性。对于证明，这都是后事了。

证明：
对于这道题的证明因为 $1$ 行格子马无法跳日，所以都可以放。
而对于 $2$ 来说，马可以跳日，所以某一行或某一列没有马（为了好说，所以用来构造，当然也可以有其他构造方法），这时就转换成了 $1$ 行格子的问题，只要把某一行或某一列全部填满，就能保证个数最大化，那具体选行还是列呢？直接用 $\max(n,m)$ 即可。

当格子数某一行或列为 $1$ 时：

![11](https://img-blog.csdnimg.cn/2ef713b7370f47039d6912119d89f19e.png)

$2$ 同理。

一般情况：我们用坐标来表示每只马。

当马为（奇，奇）时，会移动到（偶，奇）；

当马为（偶，偶）时，会移动到（奇，偶）。

这样就能保证我的每只马都在（奇，奇）或（偶，偶），就算跳也只能跳到（偶，奇）或（奇，偶）。

直接说不好说明，大家直接看下图，就能明白了：

偶数情况：

![11](https://img-blog.csdnimg.cn/f1e355054a214866be9f06ad9e473efa.png)

大家看出来了么，每一行刚好是一半！

奇数情况：

![](https://img-blog.csdnimg.cn/9f3da283f69644d49e9778e1f30342a4.png)

大家看出来了么，其实和偶数也差不多，但是 $+1$ 要注意一下。

那为什么这样放就是大的呢？
当这个图任意放一个一定是（偶，奇）或（奇，偶），这是因为我们原来放的马已经将（奇，奇）和（偶，偶）填满。那么这样就好办了，刚才已经说过，（奇，奇）会移动到（偶，奇）；（偶，偶）时，会移动到（奇，偶）。所以你只要在（偶，奇）或（奇，偶）放了马就一定会矛盾，也证明了无法在放下去，所以这样放就是最大的。

这就是所有的构造方法，总的来说就是 $1,2$ 的时候某一行或列全放，一般情况错着位放。