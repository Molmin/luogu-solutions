
以下提供一种不同的方法和规律计算法的详细证明。

--------
思路：将所有能 **相互攻击** 到的格子之间连一条边，问题转为求该图的最大独立集（即求一个 **最大** 点集，使任意两点间 **没有连边** ）。    
问题在于，如何求 **这些** 最大独立集？

----
注意1：别急着走，不讲图论算法相关！   
警告2：篇幅过长警告，直接拖到结尾可查看结论，或者只看加粗部分。   
警告3：图片可能 **过大** 霸屏，但我也不知道咋调。。。。（反正我试了几种方法都不行）   
注意4：以下所说的 **“点”** 和 **“格子”** 表示相同含义，只是因为有时描述为格子不好表述。   
规定5：记原 **网格** 图为 **A图**，经上述 **连边** 处理后的图为 **B图**。

---
首先要作一个证明：B图是一个二分图。即从 **任意点** 出发不可能经 **恰奇数** 次移动回到原点（无奇环证二分图）。
以下是从一个点可以攻击到的若干点示意图：（这里为了省事我直接画到点上了，一个点代表样例的一个格子）
![](https://cdn.luogu.com.cn/upload/image_hosting/u0rula29.png)   
如果我们把攻击的每个方向视为一个向量，那么，奇数次回到原点相当于奇数个向量和为 $ (0,0) $ 。**也就是说，如果经奇数次可以回到原点，设每次移动行号增加 $ x_i $,列号增加 $ y_i $，那么对于某一奇数 $ n $，必有 $ x_1 + x_2 + \dots + x_n = 0 $，同时 $ y_1 + y_2 + \dots + y_n =0 $.**   
两式相加，得 $ (x_1 + y_1) + (x_2 + y_2) + \dots + (x_n + y_n) = 0 $.    
然而，观察上图，发现任意 $ x + y = \pm 1 $ 或 $ \pm 3 $ 。   
由于 **奇数个奇数相加等于奇数**，所以上式和 **一定** 不为 $ 0 $ ，得证。

----
由此，我们可以想到，从某个点开始遍历 **该点所在连通块**，黑白染色，所有 **颜色相同** 的点之间 **一定没有边** 相连（因为不可能奇数步回来）。我们先选点数较多的那一组，可以发现，**在该联通块内**，任意加入或替换使所选点数增加的方案都会导致有点相联。    
举个例子，我把上面那张图处理建图了，向这样：
![](https://cdn.luogu.com.cn/upload/image_hosting/bg8tnrix.png)   
（可以发现任意同色点之间没有边）   
我们先选取所有红色点，共13个。   
将任意红点替换为数量相当的绿点，均发现有出现两点之间有边情况。     
所以，最优解即为染色后点数更多的那一组点。

------
说了那么多，其实大概一看是个二分图直接写就完了。
```cpp
#include<cstdio>
const int N=1010,dx[8]={-1,1,2,2,1,-1,-2,-2},dy[8]={-2,-2,-1,1,2,2,1,-1};
bool b[N][N];
int n,m;
int cnt[2],ans,q[N*N][3],hd,tl;
inline int max(int a,int b){return a>b?a:b;}
int main()
{
    int i,j,k,x,y;
    scanf("%d%d",&n,&m);
    for(i=1;i<=n;i++)
    for(j=1;j<=m;j++)
    if(!b[i][j])
    {
        b[q[1][0]=i][q[1][1]=j]=true;
        cnt[0]=1;cnt[1]=0;
        for(hd=tl=1;hd<=tl;hd++)//bfs + 染色
        for(k=0;k<8;k++)
        {
            x=q[hd][0]+dx[k];
            y=q[hd][1]+dy[k];
            if(x>0&&x<=n&&y>0&&y<=m&&!b[x][y])
            {
                cnt[q[++tl][2]=(q[hd][2]^1)]++;
                b[q[tl][0]=x][q[tl][1]=y]=true;
            }
        }
        ans+=max(cnt[0],cnt[1]);//取较多一组点
    }
    printf("%d\n",ans);
    return 0;
}
```
[AC记录](https://www.luogu.com.cn/record/32528852)

-----
$ \uparrow $ 分界线 $ \downarrow $

-----
接下来讲另一种做法（大佬们的做法）：   
还是从证明二分图那里说起。   
先把整张A图 **相邻格黑白染色**，像这样：   
![](https://cdn.luogu.com.cn/upload/image_hosting/m1whkpo2.png)     
发现（篇幅有限请自证）黑块 **只能** 与白块有边相连，而白块 **只能** 与黑块有边相连，所以 **任意同色点** 间没有边，B图是二分图,而且，**这同时还可以证明两种颜色的点点数各占一半**。   

依照刚才的理论，取点数较多的颜色，显然，答案应该是 $ \lfloor (n * m + 1) / 2 \rfloor $ 。所以直接输出就好了，问题结束（？）。   
如果你真这么做了，，，。这是因为，当行数或列数小于等于2时，某些点之间无论如何也相互达不到，这就导致得到的B图 **并不是一个完整的联通图，而是好几个连通块**，然而我们上面总结的取较多的一半点 **仅对单个联通图适用**（3 \* 3 的图是个例外，刚好对上了）。   
![](https://cdn.luogu.com.cn/upload/image_hosting/mtz1lilf.png)    
这里插入一则证明：任何行列数均大于等于3的（除3 \* 3外）均整图联通（可以从任意点到任意点）     
证明如下：如上图，3 \* 3 格子中周围八点联通；只要行列大于等于3，假设我们把一个 3 \* 3 的框（不包括中心点）**从左向右，从上向下平移**，一定可以完全覆盖所有点，而框内点相互联通，所以整图联通。   

------
所以现在的问题就是解决行数或列数小于等于2的情况。   
先考虑行或列数等于1，发现任意点之间不联通，所以直接输出点数 $ n * m $。    
然后是行数或列数等于2。观察上图，发现（篇幅有限，不写证明了），总共会有 **四个联通块**，而且 **每个田字格** 中四个联通块中的点 **均会出现一次且仅一次** 。所以，我们考虑 **分别** 对这四个联通块做处理。根据我们的发现，先将点数除以4，则商为完整田字格数，余数有两种情况：   
第一，恰好整除，则商即为 **每个联通块内都恰有的点数**（参考上图），结合之前的分析，答案为 $ 4 * \lfloor (n * m / 4 + 1) / 2 \rfloor $ 。   
第二，余数为2，则 **其中两个** 联通块点数 **为商**，**另两个** 点数 **比商多1**（参考上图），结合之前的分析，答案为 $ 2 * \lfloor ( \lfloor n * m / 4 \rfloor + 1) / 2 \rfloor + 2 *  \lfloor ( \lceil n * m / 4 \rceil  + 1) / 2 \rfloor $。   
```cpp
if(n==1||m==1)printf("%d\n",n*m);
else if(n==2||m==2)
	if(n*m%4==0)printf("%d\n",((((n*m)>>2)+1)>>1)<<2);
    else printf("%d\n",(((((n*m)>>2)+1)>>1)<<1)+(((((n*m)>>2)+2)>>1)<<1));
else printf("%d\n",(n*m+1)>>1);
```   
[AC记录](https://www.luogu.com.cn/record/32661944)   
当然，如果你想再按商膜二等于0/1再讨论一下，你可以化出和其他题解相同的结果。

-------
总结：   
1. 由于B图是一个或几个二分联通图，黑白染色，取点数较多颜色点数（注意可能不止一个连通块）。时间复杂度 $ \mathbf O (nm) $。   
2. 由于相邻格互相达不到，2 \* m 可以四个一组放，直接使用公式计算答案（公式就在上面）。时间复杂度 $ \mathbf O (1) $。