# P8758 [蓝桥杯 2021 国 A] 填空问题 题解

## problem A

枚举题。

我们只需要一一枚举 $2 \sim 20210605$ 中的数是否满足要求即可。

判断质数伪代码：

```
if n < 2
	false
for i [2...sqrt(n)]
   if x % i = 0
        false
true
```


核心代码：

```cpp
while (n)//数位拆分
{
	if (!prime(n % 10))
	{
		f = 0;
		break;
	}
	n /= 10;
}
```
答案：$1903$。

## problem B

枚举题。

暴力枚举 $2001.1.1 \sim 2021.12.31$ 之间每个日期即可，每次枚举时我们需要逐一判断数字组合的各位数字之和是否是完全平方数。注意还有闰年，闰年的判断条件是 $n \bmod 4 = 0$ 且 $n \bmod 100 \neq 0$ 或者 $n \bmod 400 = 0$。


核心代码（判断代码）：

```
int n = year / 1000 + year / 100 % 10 + year / 10 % 10 + year % 10 + month / 10 + month % 10 + day / 10 + day % 10;
if (sqrt(n) - int(sqrt(n)) == 0)
	++ ans;
```

答案：$977$。

## problem C

dp 题。


我们用 $f_i$ 表示一棵有 $i$ 个结点的树的最小权值，那么状态转移方程为:

$$f_i =  1 + 2 \times f_j + 3 \times f_{i - j - 1} + (j^2 \times (i - j - 1))$$

显而易见其中 $i - j - 1$ 是右子树的节点个数，而 $j$ 则是左子树的节点个数。

核心代码：

```cpp
for (i = 1; i <= 2021; ++ i)
{
	for (j = 0; j <= i - 1; ++ j)
	{
		f[i] = 1 + 2 * f[j] + 3 * f[i - j - 1] + j * j * (i - j - 1);//状态转移方程 
	}	
}
```

答案：$2653631372$。

## problem D

搜索题 / 状压 dp 题。

我们可以从第一个格子开始搜，如果遍历完毕则把答案 $+1$，否则如果这个格子还没放东西，那么如果他不在最后一列那就搜横着放，如果不在不在最后一行搜竖着放。如果放过东西那么如果在最后一列就往 $x + 1, 1$ 方向搜，否则往 $x, y + 1$ 方向搜。

答案：$12988816$。

## code

```cpp
#include<iostream>
using namespace std;
int main() {
    string ans [] = {
        "1903", // 双引号中替换为 A 题的答案
        "977", // 双引号中替换为 B 题的答案
        "2653631372", // 双引号中替换为 C 题的答案
        "12988816", // 双引号中替换为 D 题的答案
    };
    char T;
    cin >> T;
    cout << ans[T - 'A'] << endl;
    return 0;
}

```