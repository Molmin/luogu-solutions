## A  纯质数
先用欧拉筛求出 $20210605$ 之内的所有质数，并保存到数组 $prime$ 中，并记下求得的质数的个数 $cnt$。之后用循环枚举这 $cnt$ 个质数，判断其每一位是否是质数，若是，则结果加 $1$。
编写的函数如下。
```c
#define N 20210605
int prime[N+10],vis[N+10]={0};
int cnt=0;
void pre()      // 预处理，用欧拉筛求出20210605以内的所有质数
{
	int i,j;;
	for (i=2;i<=N;i++)
    {
		if(!vis[i])
		{
			prime[++cnt]=i; vis[i]=1;
		}
		for (j=1;j<=cnt && i*prime[j]<=N;j++)
		{
			vis[i*prime[j]]=1;
			if(i%prime[j]==0) break;
		}
	}
}
void work1()
{
    pre();
    int i,ans=0;
	for (i=1;i<=cnt;i++)   // 对每个质数进行各数位的数字检查
    {
    	int x=prime[i],flag=1;
    	while (x)
    	{
    		if (x%10!=2 && x%10!=3 && x%10!=5 && x%10!=7) flag=0;
    		x/=10;
		}
		if (flag)  ans++;
	}
    printf("%d\n", ans);
}
```
执行上面的处理函数，输出结果为：$1903$。

## B 完全日期

直接用三重循环（年、月、日）枚举 $2001$ 年 $1$ 月 $1$ 日到 $2021$ 年 $12$ 月 $31$ 日的每一天，判断该数字组合的各位数字之和是否是完全平方数；若是，则结果加 $1$。编写的函数如下。
```c
void work2()
{
    int month[2][13]={{0,31,28,31,30,31,30,31,31,30,31,30,31},
                      {0,31,29,31,30,31,30,31,31,30,31,30,31}};
    int h[73]={0};
    h[1]=h[4]=h[9]=h[16]=h[25]=h[36]=h[49]=h[64]=1;
    int y,m,d,ans=0;
    for (y=2001;y<=2021;y++)
    {
        int f;
        if (y%400==0||(y%4==0 && y%100!=0)) f=1;
        else f=0;
        for (m=1;m<=12;m++)
        {
            for (d=1;d<=month[f][m];d++)
            {
                int t=y/1000+y%1000/100+y%100/10+y%10;
                t+=m/10+m%10+d/10+d%10;
                if (h[t]==1) ans++;
            }
        }
    }
    printf("%d\n", ans);
}
```
执行上面的处理函数，输出结果为：$977$。

## C 最小权值
由题意知，每个结点的权值只和它的左右子树权值和左右子树结点个数有关。用动态规划求解。

设 $dp_i$ 表示有 $i$ 个结点的二叉树的最小权值。状态转移方程为

$dp_i=\min {\lbrace 1+2 \times dp_j+3 \times dp_{i-j-1}+(j\times j \times (i-j-1))\rbrace }$ 

其中，$j (j\le i-1) $ 是左子树的结点个数，$i-j-1$ 是右子树的结点个数。
编写的函数如下。
```c
long long min(long long a,long long b)
{
    return a<b?a:b;
}
void work3()
{
    long long dp[2025];
    int i,j;
	for (i=1;i<=2021;i++)
        dp[i]=0x7f7f7f7f7f7f7f7f;
	dp[1]=1;
	for (i=1;i<=2021;i++)
	{
		for (j=0;j<=i-1;j++)
		dp[i]=min(dp[i],1+2*dp[j]+3*dp[i-j-1]+j*j*(i-j-1));
	}
    printf("%lld\n", dp[2021]);
}
```
执行上面的处理函数，输出结果为：$2653631372$。

## D 覆盖

采用状压 DP 来求解。

每张纸片正好能覆盖棋盘的两个相邻方格，也就是每张纸片放在棋盘上时，要么是水平放置，占同一行的两个相邻单元格，要么竖直放置，占同一列的两个单元格。我们将纸片水平放置占据的单元格标记为 $0$，将竖直放置占据的单元格标记为 $1$，这样一行放满后的状态为 $1$ 个 $8$ 位的二进制数，共 $2^8=256$ 种不同的状态。这些状态中，有些状态一定是不可能出现的。例如，$8$ 位二进制数 $00011100$ 所表示的状态肯定是不可能的。因为前面有 $3$ 个 $0$，前面的两个 $0$ 表示一张纸片水平放置，第 $3$ 个 $0$ 是怎么回事呢？因此，状态中 $0$ 一定是偶数个连续出现的。用数组 $check$ 标记这 $256$ 种状态，数组元素 $check[i]=1$ 表示状态 $i$ 可合理出现，不合理的标记为 $0$。

设 $dp_{i,j}$ 表示前 $i-1$ 行已填充完，且第 $i$ 行填充状态为 $j$ 的方案数。

由于每行的填充只与上一行相关。设第 $i$ 行的状态为 $j$，第 $i-1$ 行的状态为 $k$。若状态 $k$ 中某位为 $1$，则状态 $j$ 中该位只能为 $0$；若状态 $k$ 中某位为 $0$，则状态 $j$ 中该位为 $0$ 或 $1$ 均可。即满足 $j$ 和 $k$ 的各对应位不能同时为 $1$。并且对应的 $check[j|k]=1$。
若符合这两个条件，则 $dp_{i,j}=dp_{i,j}+dp_{i-1,k}$。

编写的函数如下。
```c
void work4()
{
    long long dp[10][1<<8]={0};
    int check[1<<8];
    dp[0][0]=1;
	int i,j,k;
    for (i=0;i<1<<8;i++)     // 判断各状态中 0 是否为偶数个连续
    {
    	int tmp=0;
    	int f=0;
    	for (j=0;j<8;j++)
    	{
    		if ((i>>j)&1)   // 状态中当前位为1，前面必须偶数个0，否则不合理
    		{
    			if (tmp%2==0) tmp=0;  // 前面0的个数是偶数个，合理，之后0的个数重新计数
    			else
    			{
    				f=1;
    				check[i]=0;
    				break;
    			}
    		}
    		else tmp++;
    	}
    	if (!f)
    	{
    		if (tmp%2) check[i]=0;
    		else check[i]=1;
    	}
    }
    for (i=1;i<=8;i++)
    {
    	for (j=0;j<1<<8;j++)         // 第i行状态
    	{
    		for (k=0;k<1<<8;k++)    // 上一行（i-1行）状态
    		{
    			if ((j&k)==0 && check[j|k])
    				dp[i][j]+=dp[i-1][k];
    		}
    	}
    }
    printf("%lld\n", dp[8][0]);
}
```
执行上面的处理函数，输出结果为：$12988816$。

有了上面的处理结果，提交给本题的源程序如下。
```c
#include <stdio.h>
int main()
{
    char T;
    scanf("%c",&T);
    if (T=='A') printf("1903\n");
    else if (T=='B') printf("977\n");
    else if (T=='C') printf("2653631372\n");
    else if (T=='D') printf("12988816\n");
    return 0;
}

```
