既然写了 $T_1$ 了，这篇也顺便写写掉吧。

### 注意事项：

我的代码中可能有一些奇怪的变量名：

#### ak ：

在题中是取模用的，~~表示我对AK月赛的人的膜拜~~。

本文用到的一些算法/数据结构：桶+前缀和+排列组合

好了，步入正题！

## [$\text{题意}$](https://www.luogu.com.cn/problem/P6686)

此题是要找到三个木棒，使其构成一个等腰三角形。很明显，有两个木棒长度是相同的。

### 如何求解不是等边三角形的等腰三角形的个数？

注：此框下的所有等腰三角形均不包括等边三角形。

我们可以假设长度相同的木棒长度为 $x$，一共有 $n$ 根，则其中任取两根都可以与剩下的那根拼成等腰三角形（因为这里我们已经假设了其中有两根木棒可以和剩下的拼成等腰了）。那这样的情况一共有几种呢？

诶——这不是一道排列与组合吗？在 $n$ 个木棒中任取两根，不计顺序，不就是 $C_n^2$吗？

而我们知道 $C_n^2=\frac{n\times (n-1)}{2}$，即得到答案。

那最后一根木棒该如何求解呢?~~爆搜~~，当然会炸。。。因为我们知道等腰三角形的底边只需满足 $0<y<2x$ 即可，所以可以直接用前缀和来求解。下面给出一种优化方案。

首先，因为最大 $a_i$ 不大，所以可以用桶 $b[i]$ 记录每种长度的木棒有几个。再用前缀和 $sum[i]$ 数组求出截止到长度为 $i$ 的木棒一共有几个。这样对于腰长为 $x$ 的等腰三角形来说底边可取 $sum[2i-1]-b[i]$ 种情况。最后腰长为 $x$ 的等腰三角形的个数即是 $C_n^2\times (sum[2i-1]-b[i])$ 个。

代码：

```cpp
for(int i=1;i<=mx;i++){
	if(b[i]>1){//这判定不写也没什么事，但时间复杂度会略高一些。
		t=b[i]*(b[i]-1)/2%ak;//腰长为i时腰可取的情况数
		t*=(sum[i*2-1]-b[i]);//腰长为i时第可取的情况数
		t%=ak;//取模
	}
}
```

### 如何求解边长为 $x$ 的等边三角形个数？

这应该很简单吧，就是在 $n$ 个木棒中取三个木棒，不计顺序，即 $C_n^3$。

而 $C_n^3= \frac{n!}{(n-3)!\times 3!}=\frac{n(n-1)(n-2)}{6}$，可以快速求解。

```cpp
if(b[i]>2) t=b[i]*(b[i]-1)*(b[i]-2)/6%ak;
t%=ak;
```

好了，现在只要将两部分加起来就可以了。直接上核心代码吧。

```cpp
for(int i=1;i<=mx;i++){//mx指最大的a[i]
	if(b[i]>1){//前面已经说过了。
		t=b[i]*(b[i]-1)/2%ak;
		t*=(sum[i*2-1]-b[i]);
		if(b[i]>2) t=t+b[i]*(b[i]-1)*(b[i]-2)/6%ak;
		t%=ak;
		ans+=t;
		ans%=ak;
	}
}
```

这道题顺利过关！又A一题！