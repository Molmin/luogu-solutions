我们其实可以先抽象一下这道题：
 
要让留下来的人的分数和最大，就是求k个区间的最大和.


------------


想想刚学dp时的连续区间最大和问题，不就是k=1是的特殊情况吗？  
参考它的做法，我们设dp[i][j]表示以i结束第j段的最大和。

------------
考虑状态的转移     ：   
显然i应该为阶段   
枚举j   
接下来考虑从前面哪一个阶段转移过来   
再来一层枚举   
此时再考虑从哪里开始本阶段  
最后的式子是：   
dp[i][j]=max(dp[i][j],dp[k][j-1]+sum[l][i])   
这样的算法时间复杂度为O(n^4)  
无法通过n<=500   
考虑优化.  
（敲黑板！！！）  
我们可以O(n^2)地处理出l~i以i结束的区间最大和  
（方法参考文首）   
于是我们就可已将dp优化为O（n^3）了  
可以通过本题   
同理，枚举前一阶段的过程也可以使用线段树优化为log（n）         
(有大佬有O（n）的算法，可惜我不会。。。)   
留给大家思考   （ _懒_ ）  
最后附上AC（看完）代码   

```cpp
#include<bits/stdc++.h>
using namespace std;
int i,j,k,m,n,s,t,dp[501][501],a[501],sum[501],ans[501][501],b[501][501];
int main()
{
	cin>>n>>m;
	for(i=1;i<=m;i++)
	cin>>a[i];
	for(i=0;i<=n;i++)
	for(j=i;j<=n;j++)
	if(b[i][j-1]>0)
	b[i][j]=a[j]+b[i][j-1];//处理l到i以i结束区间最大值，原理参考 p1115
	else
	b[i][j]=a[j];
	for(i=1;i<=n;i++)//枚举状态 
	for(j=1;j<=max(i,m);j++)//我的代码强制要求区间长大于1，所以。。。 
	for(k=j-1;k<i;k++)//同上 
	dp[i][j]=max(dp[i][j],dp[k][j-1]+b[k+1][i]);//转移式子 
	int tt=0;
	for(i=0;i<=n;i++)
	for(j=0;j<=m;j++)
	tt=max(tt,dp[i][j]);//此题很坑，区间长度可以为0，所以来一波最大值 
	cout<<tt;
	return 0;
}
```
为防止大家抄题解，以上代码肯定WA，有一个小错，但关键部分没有问题    
本人第一次写题解，若有解释不清楚或错误的地方敬请指出  
谢谢








