看到题解里有人说这题数据略水感觉有点慌，不过回头看看自己代码好像也还行~~那个加强版也点不进去啊...~~

好吧，对着题面所给条件与数据范围仔细思考一下，我们可以~~轻易地~~看出这是道dp.因此,我们可以：

**用dp[i][j][0/1]表示在选第i个数时,第j段已开始用,第i个数不选/选,的最高得分**

因此，我们可以构建如下状态转移方程：

$$dp[i][j][1]=max(dp[i-1][j-1][0]+a[i],dp[i-1][j][1]+a[i]);$$

以及

$$dp[i][j][0]=max(dp[i-1][j][0],dp[i-1][j][1]);$$

此外需要注意的是，最后ans还得全部跑一边，因为有可能k个区间还没用完.
```cpp
#include<iostream>
using namespace std;
int a[501],dp[501][501][2];
//dp[i][j][0/1]表示在选第i个数时,第j段已开始用,第i个数不选/选,的最高得分 
int main(){
	int n,k;
	cin>>n>>k;
	for(int i=1; i<=n; i++)cin>>a[i];
	for(int i=1; i<=n; i++){
		for(int j=1; j<=i&&j<=k; j++){
			dp[i][j][1]=max(dp[i-1][j-1][0]+a[i],dp[i-1][j][1]+a[i]);
			//前者表示上个人没选,这个人选(即开启了一个新的区间)
			//后者表示上个人选了,这个人继续选(即延续这个区间)
			dp[i][j][0]=max(dp[i-1][j][0],dp[i-1][j][1]);
			//前者表示上个人没选,这个人也不选(即延续空档)
			//后者表示上个人选了,这个人却不选(即打断这个区间); 
		}
	}
	int ans=0;
	for(int j=0; j<=k; j++){
		ans=max(ans,dp[n][j][1]);
		ans=max(ans,dp[n][j][0]);
	} 
	cout<<ans;
	return 0;
}
```
要是加了滚动数组，还可以达到时间O（nk），空间O（k）的了