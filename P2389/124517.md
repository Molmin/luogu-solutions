## 贪心的做法！
从浩瀚无垠的题解大库例翻来覆去，怎么几乎全部都是dp的题解！

来这里来一篇贪心题解！

~~至于为什么用贪心，那当然是因为dp本人不会啊，呜呜呜~~~

首先初步分析一下题目数据的性质，输入的数据一定是正数，负数，0。

我们先抛开数据是0的情况不看，因为对于这个0，我们选ta或者不选ta都无伤大雅！！似乎是这个样的（确实是这个样的）

那么把所以的0扔去一边，留下的数据一定是一段正数，一段负数！

那么好，如果想要使答案优，那么对于每段正数或负数，我们最好同时选上或者同时不选上！

那么我们便可以把连续的正数段和连续的负数段合起来，构成一段新数据！

并且这组数据非常有特点，肯定是一个正，一个负！连续不断！

**对这里我们可以有一波小操作，** 就是第一个区间和最后一个区间，如果是负区间，那么肯定不会被选入（很显然的证明），那么在统计区间和的数组中可以去掉这两个区间！

我们可以统计一下正数段的个数cnt。

如果用了上面那波操作，那么cnt=（统计进答案的区间总数+1）>>1;

**如果cnt<=k,对于最优答案我们只需要把所以的正数段加起来便是最优解**

可是！！一个新问题来了，如果cnt>k又该怎么办呢？？

这时候的我们只有两种操作：

**操作一：去掉一段正数区间，使总答案减少~**

**操作二：加上一段负区间，使两个正区间合并起来。**

其实对于操作一，我们可以认为是把少选一个正区间，把相邻两个负区间合并起来

其实无论我们选择哪种操作，对答案的影响就是这段区间总和的绝对值~ 

那么如果我们开一个优先队列并且把所以的区间的绝对值存进去，每次去取最小的来合并区间不就可以了吗！

**合并区间怎么办呢，我们在存区间绝对值的时候维护上一个区间位置，每次我们从优先队列里取出队顶，如果这个队顶已经被合并到别的地方了，就继续取出队顶，直至这个队顶保证之前没有被合并，并且我们把这个位置的左右位置的值合并到这个位置，并且把左右位置打上标记（意思就是这俩区间已经消失了），再把这个位置的新值压入优先队列！不断往复的操作！**

那么左右位置应该怎么处理呢，用一下链表的想法，合并了以后就去更新位置的左右，和左的左位置的右，以及右的右位置的左！

那么要处理多少次呢，无论是去掉一个正区间或者加上一个负区间，我们的正区间数量都会减一，那么只需要处理到正区间个数恰好等于k便是最优解！

**总结一下，如果一开始的正区间数量cnt<=k,直接输出所以正区间的和；否则，通过cnt-k次合并操作，将正区间数量变为k，输出所以正区间和！**

------------
### 来模拟一组数据

好，那么这里我们来一组数据便于理解 ~~（斜眼笑）~~

![](https://cdn.luogu.com.cn/upload/pic/69623.png)

我们不妨先把这一长串数据合并一下

得到： 25 ，-18，12，-3，5

这样一组数据，显然这里有三个正区间，那么我们开始进行操作：

显然这里-3是绝对值最小的，那么我们俩进行合并

![](https://cdn.luogu.com.cn/upload/pic/69633.png)

显然这时，正区间数cnt=k，结束操作，并把正区间输出！

答案为39！

------------

### cpp：
```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <cmath>
#include <queue>
using namespace std;
#define maxn 550

struct Node
{
	int val,pos;
	bool operator < (const Node &h) const
	{
		return val>h.val;
	}
};

int L[maxn],R[maxn];
int a[maxn],tot;
int n,k,t,cnt,ans;
bool vis[maxn];
priority_queue <Node> q;

int main()
{
	scanf("%d%d",&n,&k);
	for(register int i=1;i<=n;i++)
	{
		scanf("%d",&t);
		if(t==0) continue;
		if(t>0&&tot==0)
		{
			a[++tot]=t;
			continue;
		}
		if(a[tot]*t>0) a[tot]+=t;
		else a[++tot]=t;
	}
	if(a[tot]<0) tot--;
	for(register int i=0;i<=tot;i++)
	{
		L[i]=i-1;
		R[i]=i+1;
	}
	for(register int i=1;i<=tot;i++) q.push((Node){abs(a[i]),i});
	cnt=((tot+1)>>1)-k;
	while(cnt>0)
	{
		int u=q.top().pos;q.pop();
		while(vis[u])
		{
			u=q.top().pos;
			q.pop();
		}
		int l=L[u],r=R[u];
		a[u]=a[u]+a[l]+a[r];
		if(l!=0) vis[l]=true;
		if(r!=tot+1) vis[r]=true;
		
		L[u]=L[l];
		R[u]=R[r];
		R[L[l]]=u;
		L[R[r]]=u;
		q.push((Node){abs(a[u]),u});
		cnt--;
	}
	for(register int i=1;i<=tot;i++) if(!vis[i]&&a[i]>0) ans+=a[i];
	printf("%d",ans);
	return 0;
}
```
## Over!