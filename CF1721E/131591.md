比较简单的一个字符串题目，前缀知识是 KMP 模式串匹配算法，对失配树有所了解更好。

## 一、题意

- 给定字符串 $s$，以及 $q$ 个串 $t_i$，求将 $s$ 分别与每个 $t_i$ 拼接起来后，最靠右的 $|t_i|$ 个前缀的 border 长度。询问间相互独立。

- $|s|\leq 10^6, q \leq 10^5, |t_i|\leq 10$ 。

## 二、解法

考虑暴力怎么做。首先我们对 $s$ 跑 KMP 求出 $fail$ 数组。

接下来每次接上 $t_i$ 时，再求出后面 $|t_i|$ 位的 $fail$ 数组（ border 长度）。

那么我们可以写出朴素的代码：



```cpp
scanf("%s", s + 1);
fail[0] = -1, fail[1] = 0;
for(int i = 2; i <= strlen(s + 1); ++i){
	int j = fail[i - 1];
	while(j != -1 && s[j + 1] != s[i]) j = fail[j];
	fail[i] = j + 1;
}
for(int i = 1; i <= q; ++i){
	scanf("%s", t + 1);
	for(int j = 1; j <= strlen(t + 1); ++j){
		int k = fail[strlen(s + 1) + j - 1];
		while(k != -1 && s[k + 1] != t[j]) k = fail[k];
		fail[j] = k + 1;
		printf("%d ", fail[j]);
	}
	printf("\n");
}
```

但是这样的复杂度是 $O(q(|s|+|t|))$ 的，因为 KMP 算法线性的原因是复杂度在整个串跑 KMP 的时候均摊掉了，而这道题每个询问都是在一个前缀（即 $s$ 串）固定的情况下继续求出后面的 $fail$ 数组，单次复杂度可以达到 $O(|s|)$ 级别。

因此，需要一些优化。注意到如果我们把 $fail_i$ 设置为 $i$ 节点的父节点 （$0$ 没有父节点）的话，一定可以形成一棵树，而每次跳转 $fail$ 就相当于走到父节点。这就是 $fail$ 树。那么我们每次求询问的第 $j$ 位的答案时，要求的本质就是在 $fail$ 树上的某一个节点上，最近的一个祖先 $x$ 存在 $t_j$ 这个转移边，即满足 $(s+t)_{x+1}=t_j$ 。 为了加速这一过程，我们用一个二维数组 $next_{i,j}$ 表示节点 $i$ 的第一个有字符 $j$ 的转移边祖先的编号。显然存在以下递推式：

$next_{0,j}= -1, j \neq (s+t)_1 $

$next_{0,j}= 0, j = (s+t)_1$

$next_{i,j} = next_{fail_i,j}, j \neq (s+t)_{i+1}$

$next_{i,j} = i, j = (s+t)_{i+1}$ 

说人话就是把父节点的状态继承下来，并更新一个转移边。

有了 $next$ 数组后，我们就可以一步跳转到应该到达的节点并更新 $fail$ 了。唯一需要注意的是当我们在串的末尾加入一个字符时（求 $fail$），应该同时更新**上一个字符**的 $next$ 数组。原因自己想。

由此，时间复杂度降低为 $O(26(|s|+q|t|))$ 。
当然也可以用可持久化线段树把 $26$ 变成 $\log 26$ ，不过没必要。

## 三、代码

提交记录： [link](https://codeforces.com/contest/1721/submission/169891936)
