一个不太一样的思路。

称一个区间 $[l,r]$ 合法当且仅当只保留 $[l,r]$ 可以组成合法括号序列。

显然 $[1,n]$ 必须是合法区间，否则无解。

把字典序最小转化为：依次考虑每一个数，贪心地选择最大的合法匹配位置。称 $i$ 的一个匹配位置 $j$ 合法当且仅当 $(i,j)$ 和 $(j,n]$ 都是合法区间且 $a_i=a_j$。

正确性其实不是很显然，但感性理解比较容易，证明又有点难说清楚，这里就不写了（

此时我们就获得了一个不太一样的 $O(n^2)$ 暴力：暴力扫一遍找到 $1$ 的最大合法匹配位置 $t$，并递归到 $(1,t),(t,n)$ 两个子问题。

考虑优化：对于一个区间 $[l,r]$ 快速找到 $t$。

因为 $(l,t)$ 是合法区间且 $a_l=a_t$，所以 $[l,t]$ 是合法区间。又因为 $[l,r]$ 是合法区间，所以 $(t,r]$ 是合法区间。而显然这又是充分的。因此我们可以发现，对于一个固定的 $r$，$t$ 只与 $a_l$ 有关。

状态数被我们减小到了 $O(n\Sigma)$，考虑 $dp$。

设 $dp_{r,i}$ 表示 $a_l=i$ 时的答案。

容易得出转移方程：

$$dp_{r,i}=dp_{dp_{r-1,a_r}-1,i}$$

边界：$dp_{r,a_r}=r$。

预处理完之后我们就可以 $O(n)$ 求出解。最终时间复杂度 $O(26n)$。

参考代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define N 100005
int n,st[N],dp[N][26];char a[N];
int main()
{
	scanf("%s",a+1);n=strlen(a+1);
	for(int i=1;i<=n;++i)
	{
		for(int j=0;j<26;++j) if(dp[i-1][a[i]-'a'])
			dp[i][j]=dp[dp[i-1][a[i]-'a']-1][j];
		if(st[0] && st[st[0]]==a[i]-'a') --st[0];
		else st[++st[0]]=a[i]-'a';dp[i][a[i]-'a']=i;
	}if(st[0]) {puts("-1");return 0;}st[++st[0]]=n+1;
	for(int i=1;i<=n;++i)
	{
		if(i==st[st[0]]) putchar(')'),--st[0];
		else putchar('('),st[st[0]+1]=dp[st[st[0]]-1][a[i]-'a'],++st[0];
	}return 0;
}
```