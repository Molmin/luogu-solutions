## 题解

类比一般的判断合法括号序列的方法，我们可以用一个**栈**，对于一个字符串**判断其是否和某个合法括号序列匹配**。（下文将“和某个合法括号序列匹配”称为“合法”）

具体而言：

- 栈用于存储当前未匹配的左括号所对应的字符，初始为空。
- 从左到右依次考虑每个字符：
	- 若当前栈不为空且当前字符和栈顶相同，令当前位置为右括号，从而和栈顶进行匹配——弹出栈顶。
	- 否则当前位置只能是左括号——将其入栈。
- 存在合法括号序列与之匹配，当且仅当最终栈为空。（栈为空这个判定条件决定了这个判定方法的正确性，因为目标是栈为空，所以能匹配则匹配一定最优）

------------

**最靠左的位置**一定是左括号，我们考虑其可以**与哪些位置匹配**。

下标为 $\mathit{p}$ 的位置能与下标为 $0$ 的位置匹配，当且仅当 $s_p=s_0$ 且 $s[1,p-1]$ 和 $s[p+1,n-1]$（$n$ 为字符串长度）均合法。（*）

对于所有满足 (*) 的位置，我们可以直观地发现，选择**其中最靠右的一个是最优的**，**证明**如下：

设 $p_l$ 和 $p_r$ 为两个满足 (*) 的位置，且 $p_l<p_r$，则 $s[1,p_l-1]$ 和 $s[1,p_r-1]$ 均合法。

引入一个引理：

> 引理：若 $s[x,z]$ 和 $s[x,y]$ 均合法，且 $y<z$，则 $s[y+1,z]$ 合法。

证明的话考虑判断 $s[x,y]$ 是否合法的过程，可以发现在考虑位置 $y$ 和位置 $z$ 以后栈均为空，故引理得证。

由引理知 $s[p_l,p_r-1]$ 合法。进而对于任意选择 $p_l$ 和位置 $0$ 进行匹配的方案，我们总可以在不改变 $[0,p_l-1]$ 中的括号的前提下，通过改选 $p_r$ 和位置 $0$ 进行匹配，将位置 $p_l$ 由右括号变为左括号。 $\blacksquare$

----

在求得和位置 $0$ 匹配的最优位置 $p_{opt}$ 后，问题转化为 $[1,p_{pot}-1]$ 和 $[p_{opt}+1,n-1]$ 这两个子问题，递归处理即可。

所以现在唯一剩下的问题是，**如何求解最优位置 $p_{opt}$**。

**结论**：$p_{opt}$ 为最大的 $x$，满足 $s_x=s_0$ 且 $s[x+1,n-1]$ 合法。**证明**如下：

只需证该条件和 (*) 中的条件等价，即“若 $s_x=s_0$ 且 $s[x+1,n-1]$ 合法，则 $s[1,x-1]$ 合法”。

首先由前述引理知 $s[0,x]$ 合法。

其次，若位置 $0$ 和位置 $x$ 匹配，命题成立。于是考虑两者不匹配的情况——设位置 $0$ 和位置 $x$ 分别与位置 $y$ 和位置 $z$ 匹配（$0<y<z<x$） ，则 $s[0,y]$ 和 $s[z,x]$ 合法，进而 $s[y+1,z-1]$ 合法。那么我们完全可以交换位置 $y$ 和位置 $z$ 的左右括号，使得位置 $0$ 和位置 $x$ 匹配。 $\blacksquare$

设 $f_{i,c}$ 表示最大的 $j$，满足 $s[j+1,i]$ 合法且 $s_j=c$，可得转移方程：

$$f_{i,c}=\begin{cases}
i, &s_i=c,\\
f_{(f_{_{i-1},s_i})-1,c}, \quad &s_i \neq c.
\end{cases}$$

说明：若 $s_i \neq c$，则考虑和位置 $i$ 匹配的位置（$f_{i-1,s_i}$），在这之前再去找满足要求的位置。

预处理 $f$ 以后，最优位置 $p_{opt}$ 就很好求了。

总时间复杂度 $O(n |\Sigma|)$，其中字符集大小 $|\Sigma|=26$。

当然你也可以使用 Hash + map 求解最优位置 $p_{opt}$，时间复杂度 $O(n\log{n})$，具体细节见[这篇题解](https://www.luogu.com.cn/blog/wsyhb/post-ti-xie-p6000-ceoi2016match)。

其实本题可以做到 $O(n)$，至于怎么做，留作思考题（

## 代码

P.S. 笔者写的是递归求解，事实上可以用循环解决，详情请阅读 [Kubic 的题解](https://www.luogu.com.cn/blog/119621/solution-p6000)的代码。

``` cpp
#include<bits/stdc++.h>
using namespace std;
const int max_n=1e5+5;
char s[max_n],st[max_n],ans[max_n];
int f[max_n][26],tp;
void solve(int l,int r)
{
	if(l>r)
		return;
	int p=f[r][s[l]-'a'];
	assert(p>l&&p<=r);
	ans[l]='(',ans[p]=')';
	solve(l+1,p-1),solve(p+1,r);
}
int main()
{
	scanf("%s",s+1);
	int n=strlen(s+1);
	for(int i=1;i<=n;++i)
	{
		if(tp>0&&st[tp]==s[i])
			--tp;
		else
			st[++tp]=s[i];
		for(int j=0;j<26;++j)
			f[i][j]=f[i-1][s[i]-'a']?f[f[i-1][s[i]-'a']-1][j]:0;
		f[i][s[i]-'a']=i;
	}
	if(tp>0)
	{
		puts("-1");
		return 0;
	}
	solve(1,n);
	printf("%s\n",ans+1);
	return 0;
}
```

## 后记

大约一年半以前，我写了这道题的题解。（[传送门](https://www.luogu.com.cn/blog/wsyhb/post-ti-xie-p6000-ceoi2016match)，上文出现过）

今天正巧又来做这道题，想了一会儿发现不会做，就去看自己原来写的题解。

以下三段是我看完题解的心理活动：

咦，为啥若“区间 $[p+1,r]$ 合法”则“区间 $[l+1,p-1]$ 也合法”？

嗯……大概是我当时想清楚了但没有写上去吧……

不过有个更大的问题啊——为啥给下标为 $l$ 的位置上的左括号匹配一个尽量靠右的右括号最优啊？

在努力回忆一番后，我判定自己当时应该是没有思考如何证明——因为觉得这个结论很直观，~~而且想水题解~~，所以就直接省略证明，一笔带过了。

而且我觉得当时写的题解好丑啊——一方面是因为“$Hash$”这种变量名，另一方面是因为加粗部分过多，以致于重点过多而没有重点。

所以我就写了这篇题解。

----

话说我写这么长，是不是不会有人有耐心读完啊……（哭）

~~拜托，我可写了一上午喂！~~

~~再说，比起我的大多数题解，这其实算比较短的……~~

可能是因为我语文太烂了？

我好菜啊……各种意义上的。