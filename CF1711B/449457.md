一道质量对我来说很高的思维题。

[我的垃圾翻译](https://www.luogu.com.cn/paste/vs4fse9c)

首先，如果 $m$ 初始为偶数，那么很显然全邀请就可以，直接输出 $\texttt{0}$。

然后我们考虑 $m$ 为奇数的情况。

我们先考虑不邀请 $1$ 个人的情况，那么这个时候，我们只能不邀请一个有奇数对朋友关系的人。此时奇数 $-$ 奇数 $=$ 偶数。

我们再考虑不邀请 $2$ 个人的情况，那么这个时候，我们有两种邀请方法：

1. 不邀请两个有奇数对朋友关系且这两个人之间有朋友关系的人。此时奇数 $-$ 奇数 $-$ 奇数 $+1=$ 偶数。
1. 邀请一个有奇数对朋友关系一个有偶数对朋友关系且这两个人之间没有朋友关系的人。此时奇数 $-$ 奇数 $-$ 偶数 $=$ 偶数。但这个时候我们发现我们完全可以邀请那个有偶数对朋友关系的人。故该方法不优，舍弃。
1. 不邀请两个有偶数对朋友关系且这两个人之间有朋友关系的人。此时奇数 $-$ 偶数 $-$ 偶数 $+1=$ 偶数。

我们这个时候想一想，我们这个时候真的有可能不邀请大于等于 $3$ 个人并且是这个方案最优吗？我们发现，这是不可能的了。对于一个不邀请方案中的一组人 $(x,y)$，不管他们是什么样的情况（这里我懒得码字了，大家自己分类讨论推推），我们都可以只保留这两个人或者去掉这两个人，这样的新名单同样符合要求，且由于新名单是通过旧名单删去一些成员得到的，故新名单更优。如果新名单仍然大于等于 $3$ 个人，我们可以继续上面的操作，减少名单上不邀请的成员的数量。因此，我们只需要枚举不邀请一个人和不邀请两个人的情况，计算最小不快乐值即可。

又因为如果不邀请两个人，这两个人之间一定有朋友关系（至于为什么参见上文），所以时间复杂度为 $O(T(n+m))$。

代码：

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int read(){
	int x=0,f=1;
	char c=getchar();
	while(c<'0'||c>'9'){
		if(c=='-') f=-1;
		c=getchar();
	}
	while(c>='0'&&c<='9'){
		x=(x<<1)+(x<<3)+c-'0';
		c=getchar();
	}
	return x*f;
}
int du[100005];
int x[100005];
int y[100005];
int a[100005];
void cf(){
	int n=read(),m=read(),ans=0;
	for(int i=1;i<=n;i++){
		a[i]=read();
		ans+=a[i];
	}
	for(int i=1;i<=m;i++){
			x[i]=read(),y[i]=read();
			du[x[i]]++;
			du[y[i]]++;
		}
	if(m&1){
		for(int i=1;i<=n;i++)
			if(du[i]&1) ans=min(ans,a[i]);
		for(int i=1;i<=m;i++)
			if((du[x[i]]+du[y[i]]-1)&1) ans=min(ans,a[x[i]]+a[y[i]]);
		printf("%d\n",ans);
	}
	else printf("0\n");
	for(int i=1;i<=n;i++){
		du[i]=0;
		a[i]=0;
	}
	for(int i=1;i<=m;i++){
		x[i]=0;
		y[i]=0;
	}
	return;
}
int main(){
	int t=read();
	for(int i=1;i<=t;i++)
		cf();
	return 0;
}
```
