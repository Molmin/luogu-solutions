[题目传送门](https://www.luogu.com.cn/problem/CF1711B)

## 题意
有 $T$ 组数据，每组数据给你一组 $n, m$ 表示共有 $n$ 个人，$m$ 组朋友关系，及一个数组 $a$ 和 $m$ 组关系的具体值。其中 $a_i$ 表示当第 $i$ 人没有来参加聚会时，所带来的不快乐值。每对朋友会吃掉一个蛋糕。问在保证吃的蛋糕总数为偶数时，能达到的最小不快乐值。

## 转化
对于朋友关系及每个人，我们考虑建一个 $n$ 个顶点，$m$ 条边的无向图。其中的 $n$ 个顶点分别为 $1 \sim n$ 个人，$m$ 条边为其中的 $m$ 条朋友关系，即若两人有朋友关系，我们就在所建的图中编号对应的两点间连上一条无向边。

那么，问题就转换为了：

给出一个包含 $n$ 个点 $m$ 条边的图，及每个点的点权（$a$ 数组）。删掉一些点和有关的边，使得图中有偶数条边。求删掉的点的点权总和最小值。

## 方法
~~在这里就以文字叙述吧...~~

我们分类讨论一下。

1. $m$ 为偶数，则不需要删边或点，直接输出 $0$ 即可。
1. $m$ 为奇数，以下分三种情况讨论。

	1. 删一个点。显然，我们只能选择一个度为奇数的点。
 
   1. 删两个点。以下再分六种情况来讨论。
   
   		1. 两点度数均为偶且有边，那么能够保证删除后边为偶数个，则两点均删除。
      1. 两点度数均为奇且有边，那么能够保证删除后边为偶数个，则两点均删除。
      1. 两点度数一奇一偶但无边，如下图。
      ![](https://cdn.luogu.com.cn/upload/image_hosting/j74fjmv3.png)
      
	   虽然能够保证删除后边为偶数个，但只删除其中的奇点 $4$ 所获的不快乐值一定会更小，那么舍去这种情况。
      
      1. 对于上述三种情况下，若两点间有无边的条件相反的情况下，则删除后对边数的改变都是减少偶数条。如下图中删 $1$，$4$ 或 $5$，$7$ 或 $3$，$4$ 号点，对边数变化为偶数无用，所以也舍去这三种情况。

      ![](https://cdn.luogu.com.cn/upload/image_hosting/5injt41o.png)
      
	1. 删大于等于三个点。显然不会更优，也舍去（可以替换成只删一个或两个点的形式，不快乐值会更低）。
    
   	如下图
 		![](https://cdn.luogu.com.cn/upload/image_hosting/8bg4jz9k.png)
        
      若要删除 $5$，$6$，$1$ 号顶点，我们可以替换为只删除 $1$ 号点，也能使图中的边数边为偶数，且不快乐值更低。
      若要删除 $1$，$2$，$3$，$4$ 号顶点，我们可以转化为只删除其中的任意一个奇点。
      
      - 而若要删除更多的点，我们只需要替换为只删一个或两个点就行。
      
## 代码

      
我们发现不用把图建出来，记录每个点的度数即可。

```cpp
#include <iostream>
#include <vector>
#include <climits>

#define int long long

using namespace std;

const int N = 1e5 + 5;

int t, n, m, cnt = 0, ans = INT_MAX, a[N];

int d[N] = {0};//记录点的度数

vector <int> e[N];

int u[N], v[N];

signed main() {
    ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr);
    
    cin >> t;

    while (t --) {
        cin >> n >> m;

        ans = INT_MAX;

        for (int i = 1; i <= n; ++ i)
            cin >> a[i], d[i] = 0;

        for (int i = 1; i <= m; ++ i) {
            cin >> u[i] >> v[i];
            
            ++ d[u[i]], ++ d[v[i]];//边的两端顶点度数加一
        }

        //m为偶
        if (m % 2 == 0) {
            cout << "0\n";

            continue;
        }
        
        //因为前面有了continue，所以不需要再加上else

        //删一个点
        for (int i = 1; i <= n; ++ i)
            if (d[i] % 2 == 1)
                ans = min(ans, a[i]);

        //删两个点
        for (int i = 1; i <= m; ++ i)
		    if ((d[u[i]] + d[v[i]]) % 2 == 0)//稍稍简化了一下，能够发现删两个点的情况都是两点度数和为偶数
			    ans = min(ans, a[u[i]] + a[v[i]]);
                
        cout << ans << "\n";
    }
    
    return 0;
}
```


------------

## Thanks For Reading


~~本来想传图的，但不知道怎么弄链接，所以就咕了。——感谢大佬帮助，我会乐。~~
