### 题意简述

~~比赛的时候看了10min才把题看懂，我太弱了~~

定义：一个无序对在集合中，当且仅当无序对的两个元素均在集合中。

给你一个有 $n$ 个元素的数列 $a$ 和 $m$ 个无序对，要求你在集合 $\{1,2,3,...,n\}$ 里选择一个集合（记为 $b$，记没有选的数 组成的集合为 $c$，设 $c$ 有 $x$ 个元素），使得在这 $m$ 个无序对中，在集合 $b$ 中的无序对的数量为偶数，并且对于 $i \in [1,x]$，$\sum a_{c_i}$ 最小。输出这个和。

### 思路

提供一种我赛时想出的、复杂度比官方题解稍优的、实现差不多但分析较简略的解法。

正难则反。我们设我们已经选择了所有的元素在 $b$ 里面，要删去一些元素。此时我们一定满足有 $m$ 个无序对。所以如果 $m$ 已经是偶数，就不用删，答案是 $0$。反之，我们就要在这 $m$ 个存在的对里面破坏掉奇数个。显然，如果一个元素，有奇数个无序对包含了它，那么如果我们删去这个元素，就可以破坏掉这些对，达到目标。否则我们先删除这一个元素，那么与这个元素在同一个对里的元素，现在就一定有奇数个对包含它。删去一个即可（见代码）。

### Code

```cpp
#include<bits/stdc++.h>
using namespace std;
int p[100010],f[100010];
struct d{
	int l,r;
}g[100010];
int main(){
	int n,a,b,ans;
	scanf("%d",&n);
	while(n--){
		ans=1e9;
		memset(f,0,sizeof(f));  //记得清空
		scanf("%d%d",&a,&b);
		for(int i=1;i<=a;i++){
			scanf("%d",&p[i]);
		}
		for(int i=1;i<=b;i++){
			scanf("%d%d",&g[i].l,&g[i].r);
			f[g[i].l]++;  //记录有几个对包含了这个元素
			f[g[i].r]++;
		}
		if(b%2==0){  //已经满足条件
			printf("%d\n",0);
			continue;
		}
		for(int i=1;i<=b;i++){
			if(f[g[i].l]%2){
				ans=min(ans,p[g[i].l]);  //情况1，有奇数个对包含这个元素
			}
			else if(f[g[i].r]%2==0){
				ans=min(ans,p[g[i].l]+p[g[i].r]);  //情况2，两个元素都有偶数个，先删第一个，再删第二个就能满足目标
			}
			if(f[g[i].r]%2){
				ans=min(ans,p[g[i].r]);  //同情况1
			}
		}
		printf("%d\n",ans);
	}
}
```

不得不说这个 Div2 B 确实跨度有点大