### 题意

有 $n$ 个人和 $m$ 个关系，每个人有一个不满意度 $a_i$，现在有一个聚会，你可以选择邀请 $n$ 的人中的任意个人，使得最后由这些人构成的子图中，恰好有偶数条边，这个聚会的不满意度定义为没有选到的人的 $a_i$ 的总和，求出最小不满意度。

### 思路

有点清新的诈骗题。

首先如果边数本来就是偶数，那全部邀请即可，输出 $0$ 即可。

如果是奇数：

我们可以想到一个结论：子图的连边 = 原图的连边 - 没选中点的度数 + 没选中点的共同边数。

这就可以引申出一个推论：不选两个及以上互不连边的点的方案一定是不优秀的。

简单证明一下：设不选的点的度数为 $siz_i$。

- 若 $\exists{i}\in[1,n] siz_i$ 为奇数，那么根据第一个结论，只选择这个点即可。

- 若 $\forall i\in[1,n] siz_i$ 均为偶数，那么偶数加偶数仍然等于偶数，选择这些点没有意义。

那根据这个推论，我们可以对 $siz_i$ 进行分类讨论：

- 若 $siz_i$ 为奇数，直接将 $a_i$ 和备选答案取最小值即可。

- 若 $siz_i$ 为偶数，我们记录一个 $tmp_i$ 表示和 $i$ 互相连边的点中 $a_i$ 的最小值，根据第一个结论，此时不选择这两个点，最后的答案也是合法的，所以将 $tmp_i + a_i$ 和备选答案取最小值即可。

给出核心代码部分：

```
int n, m, t, u, v, a[100005], tmp[100005], in[100005]; 
int main(){
	t = read();
	while(t--){
		n = read(), m = read();
		int ans = 1e9; 
		for(int i = 1; i <= n; ++i){
			a[i] = read(); tmp[i] = 1e9; in[i] = 0;
		}
		for(int i = 1; i <= m; ++i){
			u = read(), v = read();
			tmp[u] = min(tmp[u], a[v]);
			tmp[v] = min(tmp[v], a[u]);
			in[u]++, in[v]++;
		}
		if(m % 2 == 0){
			puts("0");
			continue;
		}
		else{
			for(int i = 1; i <= n; ++i){
				if(in[i] & 1) ans = min(ans, a[i]);
				else ans = min(ans, a[i] + tmp[i]);
			}
			printf("%d\n", ans);
		}
	}
	return 0;
}
 
```