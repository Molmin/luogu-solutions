如果我们想知道小于等于 $n$ 的所有素数，一个自然的想法就是对每个数做一次素数检验，但这样显然是不优的(~~虽然能过掉此题~~)。于是我们引出了一种新的算法：

## Eratosthenes 筛法
**Eratosthenes 筛法**（埃拉托斯特尼筛法，简称埃氏筛法），是一种能够筛选出 $1$ 到 $n$ 里所有素数的简单方法。

筛法基于一个简单的事实：一个数的比自己大的倍数一定是是合数。

比如 $3$ 是素数，那显然 $6,9,12...$ 都是合数。

如果我们从 $2$ 开始从小到大考虑每一个数，遍历所有比自己大的倍数并标记为合数，那么最后没有被标记的就是素数。

进一步优化，如果一个数是合数，那么就没必要遍历它的倍数了。因为它的倍数已经被它的某一个质因子遍历过了。

比如 $4$ 的倍数有 $8,12,16...$，而这些数也都是 2 的倍数，所以就不需要重复遍历了。

Eratosthenes 筛法的时间复杂度为 $O(n\log\log n)$，具体证明就不详述了。

具体的实现细节详见代码。

~~都求出所有素数了就不用说怎么找素数对了吧~~

Code:
```cpp
#include<iostream>
#include<cstdio>

using namespace std;

int n;
bool nprime[10010];

void Eratosthenes()
{
	for(int i = 2; i <= n; ++i)	//i从2开始 
		if(!nprime[i])	//如果i不是素数 
		{
			for(int j = 2; i * j <= n; ++j) //遍历i的所有比自己大的倍数（在n以内） 
				nprime[i*j] = 1;	//i*j标记为合数 
		}
}

int main()
{
	scanf("%d", &n);
	Eratosthenes();		//Eratosthenes 筛法 
	int cnt = 0;
	for(int i = 3; i <= n - 2; ++i)
		if(!nprime[i] && !nprime[i+2])	//判断素数对 
		{
			printf("%d %d\n", i, i + 2);
			++cnt;
		}
	if(!cnt) puts("empty");		//输出无解 
	
}
```

顺带提一嘴，埃氏筛可以进一步优化成线性筛，时间复杂度可以做到线性，即 $O(n)$，~~不过本文并不会介绍~~。有兴趣的同学可以自行查阅资料了解。