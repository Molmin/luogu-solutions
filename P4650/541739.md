## 前言。
推结论题，或者也可以说是**构造题**。
## 分析。
- 1.如果将数据都排在前面，正确的可能性大。

换句话说，如果将数据越排在前面，那么对的可能性就越大，即如果 $a_i$ 越大，放的地方越靠后，那么错误的可能性也越大。

为什么呢？通过题目描述可以发现，如果 $a_i$ 较大，且 $i$ 较大，那么这张牌很大概率是错误的。因为后面的牌的个数很少，也许少于 $a_i$ 的个数，那么在这张牌后面错误的个数就少于 $a_i$，所以这张牌很有可能是错误的。

- 2.将**可能错误的**的牌放在后 $k$ 位，可以使其错误的可能性增大。

这个可以通过 $1$ 来解答。

综上，我们的思路也就呼之欲出了。

代码如下，仅供参考：
```
#include<iostream>
#include<algorithm>
using namespace std;
int n,k,a[2005],ans;
int main(){
	cin>>n>>k;
	for(int i=1;i<=n;i++){
		cin>>a[i];
	}
	sort(a+1,a+n+1);//排序，时间复杂度 O(nlogn)
    //将a数组从小到大排序，可以方便将后k个数替换
	for(int i=n-k+1;i<=n-k+(k/2);i++){
		swap(a[i],a[n-i+n-k+1]);
        /*
        n-k+1表示开始被交换的错误的牌的下标
        n-k+(k/2)表示最后需要交换的牌的下标
        n-i+n-k+1是 n-(i-n+k)+1 的化简结果，表示后面交换的牌的下标
        */
	}
	for(int i=n;i>=1;i--){
		if(a[i]>ans){//统计
			ans++;
		}
	}
	if(ans==k&&k!=0){//注意判断，如果k==0那么无解
		for(int i=1;i<=n;i++){
			cout<<a[i]<<" ";
		}
	}
	else cout<<"-1\n";//无解的情况
	return 0;
}
```
交上去，惊喜的发现有 $6$ 个点 ```RE``` 了，再看一题目，不是说
```
30%的数据 N≤16。

另有40%的数据 N≤2000。
```
吗？但是对于全部的数据，在题干 $1≤N≤10^5$ 里，所以将 $a$ 数组的大小改为 $500005$ 即可通过本题。
## 后记。
大家如有疑问，请在评论区提出，我会尽力解答的。