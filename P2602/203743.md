本蒟蒻~~秉承不看题解的原则~~看了一下题解，突然发现没有本蒟蒻的做法，便来介绍一下我的做法。

首先我们可以明显看出，这是道 ~~乱搞暴力~~ 数位DP。模板在这里就不讲了，讲一下我的思路。各大佬都是每个数字分别处理，共处理10次，然而我是一次处理的。

------------
## 数组介绍（本蒟蒻码风新奇）
#### x:处理1到l-1的数字出现次数
#### y:处理1到r的数字出现次数
#### t&a:拆完数的结果（一正一反）
#### dp:动规时储存值


------------

## dp过程介绍





#### dfs参数（重申本蒟蒻码风新奇）
 
 ```cpp
dfs(int w,int d0,int zg,int s[])
```
w：正在处理哪一位

d0：前导0标记

zg：最高位限制标记

s：前一个函数内的数组（可能有点懵，跟着看下去吧）

------------
#### dp数组介绍：

dp[i][j]:第i位到最后一位时数值j出现的次数（没有前导0和最高位限制标记）


------------
然后就是dp过程了

首当其冲的是两个大家都会的判断

假如这两个判断都没有判断到 ~~（判断没用啊）~~，就先定义一个数组su，其中su[i]是数值i（0≤i≤9）从第w位到最后一位dp到的次数（受两个标记的影响）。

然后枚举所有可以的值，假如这个数i有意义（不是前导0），就把su[i]加上一个很玄学的值（后面来介绍）。然后就跟着dp下去。枚举完后，假如前导0标记和最高位限制标记都是0，就可以把su的值存储进dp数组内。

然后修改s数组的值（su不等同于s）



------------

#### 玄学值的介绍

------------
这个值分两种情况讨论：

假如最高位限制标记为0或者该位没取到最大值，就直接加上pow（10，c-w）。这个可以手动证明一下，相信不难证

假如最高位标记为1并且该位取到了最大值，该值就是后面可取的最大值+1（还有全是0这种情况）。对于这个最大值，可以用一个函数解决。
```cpp
int zh(int l,int r)
{
	int s=0;
	for(;l<=r;l++)s*=10,s+=a[l];
	return s+1;
}
```
相信挺好理解的。


------------

然后本题的大致思路都介绍完了，剩下的就是细节了 ~~（你们可能连思路都没懂，我语文太蒟了）~~。看下代码应该就可以理解了。（第三次重申本蒟蒻码风新奇）

```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#include<cmath>
#define int unsigned long long//为了省事，直接这样定义了 
#define N 15
using namespace std;
int x[N],y[N],dp[N][N],a[N],t[N]; 
int c;
inline int re()//误人子弟的快读 
{
	char h=getchar();
	int y=0,q=1;
	while(h<'0'||h>'9'){if(h=='-')q=-1;h=getchar();}
	while(h>='0'&&h<='9'){y=y*10+h-'0';h=getchar();}
	return y*q;
}
int zh(int l,int r)//算后面最大值的函数 
{
	int s=0;
	for(;l<=r;l++)s*=10,s+=a[l];
	return s+1;
}
void dfs(int w,int d0,int zg,int s[])
{
	if(w>c)return;//c是数字的长度
	if(dp[w][1]!=-1&&!zg&&!d0)
	{
		for(int i=0;i<=9;i++)s[i]+=dp[w][i];//直接把上一个函数的数组加上处理好的值 
		return;
	}
	int su[N]={};//定义单独一个数组，便于更新dp数组的值 
	int m=(zg?a[w]:9);//求出取值范围 
	for(int i=0;i<=m;i++)
	{
		if(!d0||i!=0)//假如该数有意义 
		{
			if(!(zg&&i==m))su[i]+=pow(10,c-w);//假如没有顶着最大值，就是第一种情况，加上10的c-w次方 
			else su[i]+=zh(w+1,c);//假如顶着最大值，就是第二种情况，加上后面数字的最大值 
		}
		dfs(w+1,d0&&i==0,i==m&&zg,su);//往下dfs 
	}
	if(!d0&&!zg)for(int i=0;i<=9;i++)dp[w][i]=su[i];//假如没有两个标记的限制，把值存下来 
	for(int i=0;i<=9;i++)s[i]+=su[i];//更新s数组 
}
void d(int x,int s[])
{
	c=0;
	while(x)t[++c]=x%10,x/=10;//拆数 
	for(int i=1;i<=c;i++)a[i]=t[c-i+1];//把数组反一下 
	memset(dp,-1,sizeof(dp));//初始化为-1 
	dfs(1,1,1,s);
}
signed main()//因为上面的宏定义，这里打int要报错，只能用signed 
{
	int l=re(),r=re();
	d(l-1,x);//计算1到l-1的值 
	d(r,y);//计算1到r的值 
	for(int i=0;i<=9;i++)cout<<y[i]-x[i]<<" ";//前缀和思想 
	cout<<"\n";
	//return ^-^; 
}
```
## ps：本代码已做防抄处理
### 完结撒花
~~（我太蒟了）~~