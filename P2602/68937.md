我是参照**“ac机”的题解**解的（%%%）

	数位dp：就是按照数位（个十百位等进行dp）
	本题显然用1-right区间出现的次数减去1-left区间出现的次数（~~一开始我还是没有想到~~）
	所以，问题从“变化的区间”变成了“1-某个数字”的区间
	dp过程：从个位开始计算0-9出现个位的数字总和
------------
	这里用345举例：

	个位：显而易见a[10]={34,35,35,35,35,35,34,34,34,34};易知：由于前缀零的关系，0的位置对比
    1-5位置少了一次，而6-9由于不存在346-349的数字，对比1-5位置也少出现了一次

	十位：a[10]={30,40,40,40,35,30,30,30,30,30};当然，在计算过程重要加
    个位的数组a

	百位：a[10]={0,100,100,46,0,0,0,0,0,0};

	对单个数字来说（eg：5）

	个位：5，15，25 ... 345共35个
	十位：50-59，150-159 ... 250-259共30个
	百位：共0个

	这样规律差不多就出现了

	对于某个位（个十百）的某个数字（0-9）（记作i）次数的计算，要判断与
    当前位置上数字（记作temp）的关系，（并且记temp数字之前的数字为front，之
    后为next，所在位的表示power，eg：1273718791，对于百位，temp=7，front=91，
    next=1273718，power=100）
    附带函数：
```cpp
void cul(long long n,long long* ans) {
	long long front = 0, next = n, temp, power = 1, pos = 0;
	while (next != 0) {
		temp = next % 10;
		next /= 10;
		for (int i = 0; i < 10; ++i) {
			if (i > temp)pos = 0;//i和temp的关系卡死我了，一定要注意！
			if (i == temp) { pos = 0; ans[i] += (front + 1); }
			if (i < temp)pos = 1;
			if (!i)pos = 0;//前缀零处理！
			if (i == temp && !i) pos = -1;//当前位置为零且!i时也要特殊处理！
			ans[i] += ((next + pos < 0 ? 0 : next + pos) * power);
		}
		front += (temp * power);
		power *= 10;
	}
}
```
如有不对请多指教