因为 $a$ 这个限制比较麻烦，所以想到，设求出 $1$ 到 $n$ 的数码出现次数为 $ans(n)$，则答案是 $ans(b) - ans(a - 1)$。

对于**各个位置**上的**各个数字**分别考虑，好像稍微容易点。

```
n = 1832467
      ^
    在这个位置上，数字 1 一共出现多少次？
    意思就是，下面的叉叉有几种填写方法。
    xx1xxxx <= 1832467
    前两位可以填写 0 ~ 18，后四位可以填写 0 ~ 9999。注意 1819999 也没超过 1832647。
    
    那么数字 3 一共出现多少次？稍微有点不同。
    xx3xxxx <= 1832467
    前两位可以填写 0 ~ 17，后四位可以填写 0 ~ 9999。如果前两位是 18，后面四位受到限制，只能填写 0 ~ 2467。
    
    数字 4 一共出现多少次？
    xx4xxxx <= 1832467
    前两位可以填写 0 ~ 17，后四位可以填写 0 ~ 9999。然而，前两位不能填 18，否则直接超出限制。
    
    然而数字 0 特立独行：
    xx0xxxx <= 1832467
    前面并不能填 0（否则在组成的数字中，自己是前导零），倒是可以填 1 到 18（自己不是前导零）；后接 0 到 9999。所以 0 的出现次数是 18 × 10000。

n = 1832467，处理第三位的具体方法：
      ^
    获取这位的数字 3。
    获取左边的数字 18。
    获取右边的数字 2467。
    
    数码 0 在这位上总共出现 18 × 10000 次。
    数码 1 ~ 2 在这位上总共出现 19 × 10000 次。
    数码 3 在这位上总共出现 18 × 10000 + 2468 次。
    数码 4 ~ 9 在这位上总共出现 18 × 10000 次。
```

```cpp
#include <cstdio>

typedef long long LL;

LL ten[20], cnt[10];

void process(LL n, LL sign) { // sign 用来控制加减 
  for (LL bit = 0; ten[bit] <= n; ++bit) {
    LL k = n / ten[bit] % 10, l = n / ten[bit + 1], r = n % ten[bit];
    
    if (k == 0) { // k = 0 最好特判一下。例如 n = 180233，处理第三位……
      // ……此时，k = 0, l = 18, r = 233
      if (l > 0)
        cnt[0] += (l - 1) * ten[bit] * sign;
        // 前面 0 不能填，1 ~ 17 可以填，后接 0 ~ 999
      cnt[0] += (r + 1) * sign; // 前面填 18，后接 0 ~ 233 
    }
    else { // 以下是正常情况下的结论
      cnt[0] += l * ten[bit] * sign;
      
      cnt[k] += l * ten[bit] * sign;
      cnt[k] += (r + 1) * sign;      
    }
    
    for (int d = 1; d <= k - 1; ++d)
      cnt[d] += (l + 1) * ten[bit] * sign;
    
    for (int d = k + 1; d <= 9; ++d)
      cnt[d] += l * ten[bit] * sign;
  }
}

int main() {
  ten[0] = 1;
  for (int i = 1; i <= 18; ++i)
    ten[i] = ten[i - 1] * 10;
  
  LL a, b;
  scanf("%lld %lld", &a, &b);
  process(b, 1);
  process(a - 1, -1);
  
  for (int i = 0; i <= 9; ++i)
    printf((i == 9) ? "%lld\n" : "%lld ", cnt[i]);
  return 0;
}

```