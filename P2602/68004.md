
##  题目1（模板）:
[0-9的数量](https://www.51nod.com/Challenge/Problem.html#!#problemId=1042)

[P2602](https://www.luogu.org/problemnew/show/P2602)
(两题一样的）

给出一段区间a-b，统计这个区间内0-9出现的次数.

比如 10-19，1出现11次（10,11,12,13,14,15,16,17,18,19,其中11包括2个1)，其余数字各出现1次.

从各位向前依次编号.

## 题目2：不要62
[不要62](https://vjudge.net/problem/HDU-2089)

杭州人称那些傻乎乎粘嗒嗒的人为62（音：laoer）.

杭州交通管理局经常会扩充一些的士车牌照，新近出来一个好消息，以后上牌照，不再含有不吉利的数字了，这样一来，就可以消除个别的士司机和乘客的心理障碍，更安全地服务大众.

不吉利的数字为所有含有4或62的号码.例如：
62315 73418 88914

都属于不吉利号码.但是，61152虽然含有6和2，但不是62连号，所以不属于不吉利数字之列.

你的任务是，对于每次给出的一个牌照区间号，推断出交管局今次又要实际上给多少辆新的士车上牌照了. 


# dp数组
dp[pos][sum]. 两个参数。

一个是当前枚举的位数（pos）

dp[pos][sum]整个表达的意思就是pos之前出现了dp[pos][sum]个sum。



# 拆数.

如30000-30099和20000-20099中1的个数是相同的（但是0的个数就不一样）

根据这个规律，就可以进行记忆化搜索.我们只用求出一部分的解，同类的就可以直接算.



故可以把所有的数拆开.

0-123456 中 1 的个数.

100000 - 109999

110000 - 119999

120000 - 129999

120000 - 120999

 ...
  

# limit状态.
在 00000 - 99999 这些数中。每一位最高都可以取到9.则称它们不是limit状态。

但是在 10000 - 19999 这些数中，第一位最大只能取到1，则称它是limit状态。

是否是limit状态，由输入的数决定。

比如要求 10000 - 12345 中 1 的数量。

我们可以把 12345 拆开来。

10000 - 19999 (x.第二位收到了限制。不能取到9)

10000 - 10999（第二位收到限制。只能苦逼的去统计。那么就往后一位。）

10000 - 11999

10000 - 12999（x.第三位受到限制。第三位最高为3.故也是要再往后一位分）

...

limit状态不能更新dp数组。（想一想，为什么）




 特殊情况：（只针对于题1.）
 **前导0的问题.**

 由于**0的个数也要统计进去**，故 000001 和 001 和 1 是不一样的.
 但是对于其他的题，没叫你统计每个数字出现的次数.这样 00001 和 001 都一样了.它们都代表1.这样就可以取消判断是否是前导0的这一状态.

 前导0状态不能更新dp数组。（想一想，为什么）




### 如果碰到了一些改过的题目（“不要62”）

就需要. 

# ***加参数!加特判***
如"不要62"这道题,只要特判4，并在搜索中加一个参数记录上一个搜到的数.



此为**本题**代码（抄题解会AC~~萎~~)

```cpp
#include <bits/stdc++.h>
using namespace std;

long long dp[20][20],digit[20];

long long dfs(int pos ,int sum,int num,int zero,int limit)//记忆化搜索
//pos ：当前位
//sum ：当前位前面有的num的个数.
//num ：正在统计的数出现的个数（0-9）
//zero ：当前位是否是前导0状态.（此状态可以才“不要62”等题目中去掉.而需要才这道题中保留.想一想为什么.）
//limit ：当前位是否达到了最大限制.
{
	if(pos<0)//最小拆到0位.
		return sum;
	if(!limit&&dp[pos][sum]!=-1&&!zero)//记忆化搜索!已经算过了.直接返回.
    //zero代表当前是不是前导0.
    //limit代表是否有最大数的限制.
		return dp[pos][sum];//前面有sum个num,修改前面pos位.
	long long ed,i,ret=0;
	if(limit)//如果最大有限制(比如12345有限制而12999没限制(在第三位))
    //当前位有没有到最大值.
    //确定当前pos位能选到几
		ed=digit[pos];
	else
		ed=9;
	for(i=0;i<=ed;i++)
	{
		if(zero)
		{
			if(i==0)
				ret+=dfs(pos-1,sum,num,1,limit&&i==ed);
			else
				ret+=dfs(pos-1,sum+(i==num?1:0),num,0,limit&&i==ed);
		}
		else
		{
			ret+=dfs(pos-1,sum+(i==num?1:0),num,0,limit&&i==ed);
		}
	}
	if(!limit&&!zero)
		dp[pos][sum]=ret;
	return ret;
}

long long cal(long long x,int num)
{
	memset(dp,-1,sizeof(dp));
	int pos=0;
	while(x)
	{
		digit[pos++]=x%10;//数位数组
		x/=10;
	}
	return dfs(pos-1,0,num,1,1);
}

int main()
{
	long long a,b,i;
	while(cin>>a>>b)
	{
		for(i=0;i<=9;i++)
			cout<<cal(b,i)-cal(a-1,i)<<endl;
            //0-b中i的个数-0-(a-1)中i的个数.
	}
}
```




