设[a,b]表示a~b中0~9出现的个数

我们很容易发现[a,b]=[1,b]-[1,a-1]

所以我们只要求出[1,b]和[1,a-1]即可

在本题中，1~9是很好求的，只是0的处理有些麻烦。我们不大方便直接求出0的数量，于是我们自然地想到**容斥原理——用总的数码个数-1~9的数码个数就可以了**

1~9就很好求了，对于每一个数，0~999···999中，它们出现的次数是相等的，我们可以通过打表，找规律求出，然后从高位数向低位数尾求

我们来模拟一下（模拟2345）

我们先做四位数0001~2345，我们把它分成1~999,1000~1999,2000,2345
我们最高位先不进行考虑，后三位中1~9的出现次数是相同的（我们已经打表求出），再来看最高位，只有1出现在最高位，由于1是在第4位，所以把1出现的次数+10^4。然后求2000~2345中的最高位2，只要将2的次数+（2345-2000+1）

做完了这些，我们只剩下求出1~345中1~9出现的位数就可以了，以此类推

如何求出1~x中总数码的个数比较简单，如果不会直接看程序注释

代码**（为防止恶意刷题，本程序中有一个明显的小错误，大家发现后不要在评论中说）**：
```cpp
#include<bits/stdc++.h>
using namespace std;
const long long ans[13]={0,1,20,300,4000,50000,600000,7000000,80000000,900000000,10000000000,110000000000,1200000000000}; 
//ans表示1~9在小于10^x时出现的个数
long long num(long long x) //求出1~x总共有多少个数码
{
	long long w,t,s,ans;
       //ans统计有多少个数码，t表示当前是第几位
       //w表示第t位有多少个数，s表示第（t-1）位有多少个数
	w=0;t=0;s=0;ans=0;
	while (true)
	{
		t++;s=w;w=w*10+9;
		if (x>w) ans+=t*(w-s);  //当前位数小于x的位数，则（w-s）为当前位有的数
		else {ans+=t*(x-s); return ans;} //当前位数大于x的位数，则（x-s）为当前位有的数
        //乘t表示每个数字有t个数码
	}
}
int main()
{
	long long f[10],e[10],x,k,z,t,a[14],sum;
	memset(f,0,sizeof(f));
	memset(e,0,sizeof(e));
	memset(a,0,sizeof(a));
	sum=0;
	cin>>x;
	x=x-1;
	k=x;z=1;t=0;
	f[0]=num(x);
	while (k)  //统计位数和每位上的数字
	{
		a[++t]=k%10;k=k/10;z=z*10;
	}
	z=z/10;
	while (t)
	{
		x=x%z;
		for (int i=1;i<=9;i++) f[i]+=ans[t-1]*a[t];
		for (int i=1;i<a[t];i++) f[i]+=z;
		if (a[t]) f[a[t]]+=x+1;  //0我们会另外求
		t--;z=z/10;	
	}
	for (int i=1;i<=9;i++) f[0]-=f[i];
	memset(a,0,sizeof(a));
	cin>>x;
	k=x;z=1;t=0;
	e[0]=num(x);
	while (k)
	{
		a[++t]=k%10;k=k/10;z=z*10;
	}
	z=z/10;
	while (t)
	{
		x=x%z;
		for (int i=1;i<=9;i++) e[i]+=ans[t-1]*a[t];
		for (int i=1;i<a[t];i++) e[i]+=z;
		if (a[t]) e[a[t]]+=x+1;
		t--;z=z/10;	
	}
	for (int i=1;i<=9;i++) e[0]+=e[i];
	for (int i=0;i<=9;i++) cout<<e[i]-f[i]<<" ";
	return 0;
}

```