# 提供一种简单的方法

- [题目传送门](https://www.luogu.com.cn/problem/AT4864)

- 代码很短，只有 $20$ 行左右，适合初学者食用。

---

### 做法概述

1. 我们需要对数列进行**去重**；

- 因为对于相邻的两个数，如果它们相等，那么它们一定可以在同一个子串里。

2. 这里包含了一个**贪心**的思想：如果两个数可以在一个子串里，那么我们必定把它们放到一个子串里；

- 贪心证明：

	选择一：对于两个相邻的，可以被放在一个子串里的数，如果我们把它们分开，那么总数必定加一；
    
   选择二：而如果我们把它们放在一个子串里，虽然可能使下一个数无法和当前的数放入同一个子串，但是总数最多也就加一，甚至可能更优。
   
   综上，选择二一定不会比选择一差。
   
---

### 具体做法

1. 对数列去重；

2. 定义一个变量 $flag$：

- $flag=0$：当前子串是一个单调不降子串；

- $flag=1$：当前子串是一个单调不升子串；

- $flag=2$：当前为子串的第一个数，子串类型待确定。

3. 若 $flag=2$，子串类型由下一个数和该数（子串的第一个数）之间的大小关系来决定；

	否则，如果下一个数不符合该子串类型，那就把 $flag$ 赋值为 $2$，并且把结果加上一。
    
---
### 代码实现

- 代码经过简化，简洁明了。

**AC 代码**：

```cpp
#include <bits/stdc++.h>
using namespace std;
int a[100005];
int main()
{
	int n,tot=1,flag=2,ans=1;
	scanf("%d %d",&n,&a[1]);
	for(int i=2;i<=n;i++)
	{
		int x;
		scanf("%d",&x);
		if(x!=a[tot])a[++tot]=x;
	}
	for(int i=2;i<=tot;i++)
	{
		if(flag==2)flag=(a[i-1]>a[i]);
		else if(flag!=(a[i-1]>a[i]))flag=2,ans++;
	}
	printf("%d",ans);
	return 0;
}
```