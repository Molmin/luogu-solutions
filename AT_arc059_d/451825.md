[题目传送门](https://www.luogu.com.cn/problem/AT_arc059_d)

这是一道动态规划题。

首先确定状态，我们知道题目中有两个量：$n$ 和 $s$，因此，我们会有一个初步思想：$dp(i,j)$ 表示修改 $i$ 个数后匹配了 $s$ 中的 $j$ 个数时的方案数。

然后有两点显然：

1. $s$ 的内容是无关紧要的，因为每个数位是 $\verb!0!$ 或者 $\verb!1!$ 其实都不过是字符，真正与方程挂钩的仅仅是存在字符和删除字符。

2. 既然是方案数，就不要像本人刚开始一样蠢到用 $\max$ 了，应为加起来。

知道了以上两点后，我们能根据打 $\verb!0!$ 或 $\verb!1!$ 或退格的情况，把两种情况加起来。

1. 打数字时，无论是哪种数字，都可以直接从 $dp(i-1,j-1)$ 转移过来，这点显然。

2. 打退格时，很明显从 $dp(i-1,j+1)$ 转移，但是我们这样想：删掉的字符可能是 $\verb!0!$ 或 $\verb!1!$，并且删除什么字符都不影响接下来的匹配，所以要使用 $dp(i-1,j+1)\times 2$。

但是第一种情况中 $j-1$ 是可能出现越界的，这是因为我们遍历时 $0\leq j\leq i$，需要特判一下，但是不能没有从 $j=0$ 的转移过来，否则样例都过不了。

代码：

```cpp
#include<bits/stdc++.h>
#define mod 1000000007 
using namespace std;
int main()
{
	static long long n,dp[6666][6666];
	cin>>n;
	string s;
	cin>>s;
	dp[0][0]=1;
	for(int i=1;i<=n;i++)
	{
		for(int j=0;j<=i;j++)
		{
			dp[i][j]=dp[i-1][j+1]*2%mod;
			dp[i][j]=(dp[i][j]+dp[i-1][max(j-1,0)])%mod;
		}
	}
	cout<<dp[n][s.length()];
	return 0;
}
```
