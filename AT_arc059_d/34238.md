这里给一个不依赖于乘法逆元的做法。

考虑把键盘分为两类，一类是退格，一类是普通的字符，考虑显然我们只关心敲的字符最终有哪些最后留在了屏幕上，而这些方案显然是确定的（从左到右一一匹配），而不存在于屏幕上的键是谁我们并不关心（即可以任取），设任取的位数是 $r$，则这样一个敲键盘的方案对应了 $2^r$ 种方案。

于是考虑记 $f_{i,j}$ 表示敲了 $i$ 次，最后匹配了一个长度为 $j$ 的串（我们并不关心它匹配了哪个串，因为所有长度一样的串都是等价的）的方案数。

然后转移考虑两种情况：

- 敲了 $0$ 或 $1$：那么将会多匹配一个位置，且不会导致可以任取的位增加，即 $f_{i,j}\to f_{i+1,j+1}$.
- 敲了退格，且的确退了一格，此时我们上一次敲得字符变为了可以任取的位，即 $2\cdot f_{i,j}\to f_{i+1,j-1}$，此处要求 $j > 0$.
- 敲了退格，但并未退格，即 $f_{i,0}\to f_{i+1,0}$.

然后我们就做完了，时间复杂度 $\mathcal O(n|s|)$.

```cpp
const int N = 5e3 + 5, Mod = 1e9 + 7;

int n, m, f[N][N];
char s[N];

void Get(int &x, int y) {
	x = (x + y) % Mod;
}

int main() {
	rd(n); scanf("%s", s + 1);
	m = strlen(s + 1);
	f[0][0] = 1;
	for(int i = 0; i < n; ++i)
		for(int j = 0; j <= i; ++j) {
			if(j) Get(f[i + 1][j - 1], 2 * f[i][j] % Mod);
			else Get(f[i + 1][0], f[i][j]);
			Get(f[i + 1][j + 1], f[i][j]);
		}
	printf("%d\n", f[n][m]);
	return 0;
}
```