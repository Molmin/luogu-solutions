首先题目叫我们正推，但是正推不太好做约束锕，于是我们考虑逆转整个过程，从输入串开始，每部执行：

+ 求奇数位的和；

+ 随便删一位。

我们可以先来研究一下删位的性质。首先显然有一个简单的事实：如果一堆一连成一块，删它们中的哪一个是没有所谓的，效果都是让这个连一块的长度减少恰好一。如此，我们可以不妨假设删一的时候永远删的是连一块的边界。但我们这个时候发现，除非只剩一了，否则每个连一块一定有至少一个边界挨了个零。我们意识到删这个边界一不如删零来得实惠（删完状态唯一的差异就是把那个零的位置改成了一，由于我们要最大化总价值肯定是留一比较好）。于是我们导出了一条基本性质：有零可以删的时候一定优先删零。

而不包含零之后的操作是易于刻画的，每次随便删一个一就好，统计起来高度方便，于是我们只要考虑这之前的抉择就好。我们又观察到，对于两个连在一起的一，它们在（零被删完前）任意时刻位置一定是一奇一偶，每轮都能稳定产生一的贡献，我们不妨先行统计掉这部分贡献然后把这俩一一起消掉。于是，我们现在还需要考虑的串中，不存在长度超过一的连一块。

那么现在我们的串长成了这个鬼样子：

【一堆 0】1【一堆 0】1【一堆 0】1……

我们注意到，对于一个特定的一，在它之前的零每删去一次都会导致它位置奇偶变化，至多有一半的时间可以让它被加入贡献；那剩下的时间，删它后面的零的时候，作为上限，我们希望它全部被加入贡献。而这是可以做到的——先把开头一堆零删完，然后把第二堆零删到剩一个，然后第三堆剩一个……以此类推，最后反扫一遍把这些零删完就好了。

代码非常好写，就不展示了。