### 题目大意：
$T$ 组数据，每组数据给出 $n$ 和 $m$，代表有 $n$ 个酒杯按 $1\sim n$ 标号。$m$ 次操作，每次操作会将 $x$ 号酒杯贴上纸或将除 $x$ 号酒杯的其他酒杯贴上纸。对于每组数据，输出在**至少**几次操作后所有酒杯都贴上纸。如最后还有酒杯没贴上纸，输出 $-1$。

### 分析：

首先，我们分析一下有多少种可以贴完所有酒杯的方法：

1. 只进行 $1$ 操作，那么可以开一个布尔数组和一个计数变量 $sum$，每次进行**有效的**操作后将计数加上一，如果 $sum=n$，则记下当前操作次数并把剩下的操作读完后输出即可。

2. 只进行 $2$ 操作，那么只有当两次 $2$ 操作的操作数不同时才能贴上所有酒杯。于是我们可以开一个变量 $k$ 记下第一次 $2$ 操作的操作数，以后的 $2$ 操作只需要判断操作数是否等于 $k$ 即可。

3. 同时进行 $1$、$2$ 操作。如果先进行 $1$ 操作，那么后面的 $2$ 操作要判断操作数所对应的酒杯是否被贴过纸；如果先进行 $2$ 操作，那么后面进行 $1$ 操作时要判断贴上的酒杯是否是 $2$ 操作那个唯一没有贴过纸的酒杯。

综上，我们可以通过这个思路通过本题，时间复杂度为 $O(\sum m)$，可以通过本题。

注意：每组数据要先初始化布尔数组，而最坏情况下 `memset` 会消耗大约 `750ms` 的时间（亲测），还是可以通过的。

代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std; 
int t,n,m,p,q,k,ans=0,sum=0; 
bool a[200005]={0},f=1;
int main(){
	cin>>t;
	while(t--){
		cin>>n>>m;
		memset(a,0,sizeof(a));
		k=0;f=1;ans=-1;sum=0;
		for(int i=1;i<=m;i++){
			cin>>p>>q;
			if(f){
				if(p==1){
					if(!a[q]){
						a[q]=1;
						sum++;
					}
					if(sum==n||k==q){
						ans=i;
						f=0;
					}
				}
				else{
					if(k!=0&&k!=q||a[q]){
						ans=i;
						f=0;
					}
            	else k=q;
				}
			}
		}
		cout<<ans<<endl;
	}
}
```