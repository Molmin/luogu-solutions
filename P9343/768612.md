~~这么容易的思路我为啥要写这么长的题解啊。~~

于是就删了好多废话。

酒桌上共有 $n$ 杯酒，标号为 $1\sim n$。**依次**进行 $m$ 次操作，操作有 $2$ 种类型：

- 形如 `1 x`：给 $x$ 号酒贴上 $1$ 张红纸。

- 形如 `2 x`：给除了 $x$ 号酒的其它 $n−1$ 杯酒分别贴上 $1$ 张红纸。

在**至少**几次操作后，每杯酒上至少有一张红纸（初始时一张纸都没有）？

# subtask 1

**这个部分只有 $1$ 操作。**

如果在一次操作中，一个酒**第一次**贴上纸，则称这是一次用价值的操作。

容易发现，当且仅当有价值的操作数为 $n$ 时所有酒都贴过纸。

# subtask 2

**这个部分只有 $2$ 操作。**

容易发现，如果有两次操作的 $x$ 不同，那么所有酒就都贴过纸了。

记录第一次操作的 $x$，找到第一个与其不同的操作即可。

# subtask 3

**这个部分每个 $x$ 都一样。**

容易发现，如果对同一个酒， $1$ 和 $2$ 号操作都进行过，那么所有酒就贴过纸了。

用两个变量记录是否进行过 $1$ 或 $2$ 操作即可。


# subtask 4&5

**这个部分没有特殊性质了。**

其实把前几个都结合起来就行了。

code：

```cpp
//需要注意的是：t1 和 t2 一定要用 bool 类型，不然 memset 会 TLE！
//当然手动清零也不是不行
int solve(){
	int ret=-1;//答案
	memset(t1,0,sizeof t1);//存储每个酒瓶是否进行过 1 操作
	memset(t2,0,sizeof t2);//同上，但是 2 操作
	cnt=flag=0;//有价值的操作数、第一次 2 操作的酒标号
	cin>>n>>m;
	for(int i=1;i<=m;i++){
		cin>>o>>x;
		if(ret>0) continue;
		if(o==1&&!t1[x]) cnt++,t1[x]=1;
		if(o==2) t2[x]=1,flag=flag==0?x:flag;

		if(cnt==n) ret=i;//subtask 1
		if(o==2&&flag!=x) ret=i;//subtask 2
		if(t1[x]&&t2[x]) ret=i;//subtask 3
	}
	return ret;
}
```

全文完。