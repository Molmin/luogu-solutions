想到合并，自然就想到区间dp，一个被合成的数之前是一个区间，并且由两个数比它小$1$的区间合成。可麻烦的是，我们并不知道之前的两个区间长度各是多少。这道题不像一般的区间dp，明确地知道一个区间的答案由哪些区间转移。

在这道题，我们只知道要合成$i$，就要找到两个紧接着它的两个$i-1$的区间。

既然如此，区间的长度是未知的，那我们设计状态的时候，把区间的长度设为转移的对象。

所以$f[i][j]$表示在数列上以j为起点，能合成数i的区间长度。若$f[i][j]$为$0$，说明不存在满足这个条件的区间，即在数列上以j为起点，无法合成数i。此题求解的是能合成的最大值，那就是满足$f[i][j]>0$的最大的$i$。

能和成它的区间只有接下去两个能合成$i-1$的区间，它们的长度分别是$f[i-1][j]$和$f[i-1][j+f[i-1][j]]$。从这里可以发现，第二个区间的起点位置由第一个区间的长度推导而来，这就是转移长度的原因。

显然，区间的长度是合成它两个区间的长度和，所以$f[i][j]=f[i-1][j]+f[i-1][j+f[i-1][j]]$

但是，如果合成该区间的两个区间有一个为$0$，说明能合成该区间的区间就是不存在的，那么该区间也为$0$。

这道题用动态规划也有不同的做法，可以用$f[i][j]$表示在数列上以j为起点，能合成数i的区间的右端点。不过两种方法的储存的东西本质上是一样的。知道左端点位置的前提下，右端点位置、区间长度，知道其中一个可以推出另外一个。

```cpp
#include<algorithm>
#include<cstdio>
#include<cstring>
using namespace std;
typedef int ll;
inline ll read(){
	ll rs=1,rf=0;char ch=getchar();
	while(ch<'0'||'9'<ch){if(ch=='-')rs=-1;ch=getchar();}
	while('0'<=ch&&ch<='9')rf=(rf<<3)+(rf<<1)+(ch^48),ch=getchar();
	return rs*rf;
}
const ll N=262144+10000;
ll n,f[58+10][N],ans;
int main(){
	for(ll i=n=read();i;i--)f[read()][i]=1;//每个数其实就是一个长度1的区间 
	for(ll i=2;i<=58;i++)
		for(ll j=1;j<=n;j++){
			if(!f[i][j])
				if(f[i-1][j+f[i-1][j]]&&f[i-1][j])//判断能够合成该区间的两个区间是否存在 
					f[i][j]=f[i-1][j+f[i-1][j]]+f[i-1][j];
			if(f[i][j])ans=i;
		}
	printf("%d",ans);
	return 0;
}
```

[提交记录](https://www.luogu.org/recordnew/show/21228047)
