 _这道题是智能推荐给推的_ 
 
如果你是通过找 _区间dp_ 标签找到这道题的话，你可能一时想不出方法。

官方题单里的区间dp题基本是在区间[i,j]里枚举中间点k。


------------

接下来我通过dp的基本策略来讲下。

### 表示所求值

目标是使得最大的数最大，我先想到转化成求最多能连续合并多少个。那转化后的这个问题就和官方题单里的常规区间dp题非常像了。但是，如果初始一个数非常大，但是没有经历一次合并，这个转化就马上出了问题。再多想一步，如何结合两者呢？

由于刚复习完LCA，我联想到了倍增。用 $f[i][j]$ 表示以 $i$ 为左端点，合并出 $j$ 的数字的右端点。怎么理解呢？把这个 $f$ 数组看成线段或者说是区间， $f[i][j]=0$ 的时候就代表了不存在这样的一个区间。如果存在这个区间，那这个 $j$ 就是一个得到的数，最终的答案就是最大的 $j$。

tip:之所以这个讲这么久，是因为看到大部分题解里就用一句话带过了，我个人感觉这个是有思考含量的。

### 状态转移方程

~~这题也可以选择dfs，不过我觉得这题用dfs不大方便~~

$f[i][j]=f[f[i][j-1]][j-1]$

利用了倍增思想，$2^j={s^{j-1}}^{j-1}$

### 关于58

其他题解讲的很透彻，我不再做重复。~~其实挺好想的~~。

### CODE

```cpp
#include <bits/stdc++.h>
using namespace std;

inline int gin(){//快读
	char c=getchar();
	int s=0,f=1;
	while(c<'0'||c>'9'){
		if(c=='-')f=-1;
		c=getchar();
	}
	while(c>='0'&&c<='9'){
		s=(s<<3)+(s<<1)+(c^48);
		c=getchar();
	}
	return s*f;
}

const int N=270000;
int n,ans=0,f[N][60];

int main(){
	n=gin();
	for(int i=1;i<=n;i++){
		int x=gin();
		f[i][x]=i+1;//预处理
	}
	for(int j=2;j<=58;j++)
		for(int i=1;i<=n;i++){
			if(!f[i][j])//如果没有，我们让它有
				f[i][j]=f[f[i][j-1]][j-1];//状态转移
			if(f[i][j])ans=j;//最终答案，由于j是递增的，所以直接赋值j
		}
	printf("%d",ans);
	return 0;
}

```
