### 一、题意
给你 $n$ 堆石头，$a$ 数组每堆石头的数量，可以选择三个位置，将中间位置中的石头堆中拿出两块分别放置一个在左右两个位置上，问最后将所有石子都放置在 $1$ 和 $n$ 这两个位置上需要进行多少步操作。

### 二、分析
首先很容易想到如果这堆石子的个数是偶数，那么仅用 $\frac{x}{2}$ 次就可以把这堆石头移到 $1$ 和 $n$ 或者其他位置上。那么顺着这个思路就可以把奇数考虑成一个偶数-1,所以想要让奇数变成偶数只需要在偶数迁移的时候分一个到奇数上就可以了。那么如果在中间的部分全是 $1$，那么就不能进行任何操作，所以这种情况显然是达不成目标的。那么当 $n=3$ 的时候，中间只要是奇数就不行。因为是奇数的话最后把所有石子都分完终究会剩下一个 $1$ 没有办法分走。所以我们的贪心思路是这样的：

首先先判断是否可以达成目标，然后枚举中间的每一个数。如果中间的数是奇数，那么它需要 $\frac{x+1}{2}$ 步才能移走。因为要想尽快地移走肯定先主要向 $1$ 和 $n$ 这两个位置移，只有在这堆是奇数没有办法移走的情况下才会分一个到这个奇数堆上。如果这个数是偶数，那么它需要 $\frac{x}{2}$ 次才能移走。直接加上每个数的步数就可以了，因为在这个贪心策略中这些数移走的方法都是互相独立的。

还有一种特殊情况就是中间不全都是 $1$ 的但是中间都是奇数的情况。这种情况只要知道一个不为 $1$ 的奇数也可以移到别的奇数上让别的奇数变成偶数就可以按照上一种情况做了。

### 三、代码
```cpp
# include <bits/stdc++.h>
using namespace std;
long long a[100005];
int main()
{
	int T;
	cin >> T;
	while (T--)
	{
		int n;
		cin >> n;
		for (int i = 1; i <= n; i++)
		{
			cin >> a[i];
		}
		bool flag = false;
		for (int i = 2; i <= n - 1; i++)
		{
			if (a[i] > 1) flag = true;
		}
		if (flag == false && n != 3)    //不是3但是全是1 
		{
			cout << -1 << endl;
			continue;
		}
		if (n == 3 && a[2] % 2 == 1)   //是3只要是奇数就不行 
		{
			cout << -1 << endl;
			continue;
		}
		long long ans = 0;    //比赛的时候没开long long见祖宗了。。。 
		for (int i = 2; i <= n - 1; i++)
		{
			long long sum = a[i] / 2;   //偶数 
			if (a[i] % 2 == 1) sum++;   //如果是奇数，那么还需要+1/2. 
			ans += sum;   //统计答案 
		}
		cout << ans << endl;
	}
	return 0;
}
```
谢谢观赏