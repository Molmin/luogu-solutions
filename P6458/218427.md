## 思路：
输入数据，可以使用$getline$解决，一次读入一行，在字符串中处理数据。

然后暴力循环，不要修改原来没有被污损的数据。

我们就可以判断（当然可以用表达式），如果不是$?$，就按照他的，是的话, $0$ 到 $100$ 循环。
## 注意：
已知每队最多进行 $100$ 场比赛，保证每处污损都有唯一的原数据与之对应。

因为最多进行 $100$ 场比赛，所以一定要判断是否超过了 $100$ 从而判断方案是否可行。
## 建议：
可以把答案设全局变量，方便调函数解决，那个循环处理也可以调函数。
## 代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
int n,s[1001][6];//n是比赛数，s是答案
void hanshu(int w)
{
	for(int i=s[w][2];i<=100*(s[w][2]==0)+s[w][2];i++)//s[w][2]是0的话是0~100,不是0的话就是它自己到自己循环(可以自己代入看看)
	{
		for(int j=s[w][3];j<=100*(s[w][3]==0)+s[w][3];j++)//s[w][3]是0的话是0~100,不是0的话就是它自己到自己循环(可以自己代入看看)
		{
			for(int k=s[w][4];k<=100*(s[w][4]==0)+s[w][4];k++)//s[w][4]是0的话是0~100,不是0的话就是它自己到自己循环(可以自己代入看看)
			{
				if((i+j+k==s[w][1]||s[w][1]==0)&&(i*3+j==s[w][5]||s[w][5]==0)&&i+j+k<=100)//这里要判断是否是比赛场数或者比赛场数被污损了，然后判断分数或者分数也被污损了，最后要判断是否超过了100场
				{
					s[w][1]=i+j+k;//保存一共有多少场
					s[w][2]=i;//保存胜利多少场
					s[w][3]=j;//保存平局多少场
					s[w][4]=k;//保存输了多少场
					s[w][5]=i*3+j;//保存分数
					return;//找到答案就结束了
				}
			}
		}
	}
}
int main()
{
	string str;//临时输入处理的字符串
	scanf("%d\n",&n);//输入场数
	for(int i=1;i<=n;i++)//循环
	{
		int w=1;//现在是处理第一个数
		getline(cin,str);//读取这一行的全部数据
		for(int j=0;j<str.size();j++)//循环,size是字符串的长度
		{
			if(str[j]=='?')//如果这个是未知的
			{
				s[i][w]=0;//置零，在我的函数中会用到，这个是判断是否是0的，如果是0，函数中会0~100循环
			}
			else if(str[j]>='0'&&str[j]<='9')//如果是数字
			{
				s[i][w]*=10;//乘上十
				s[i][w]+=str[j]-'0';//加上它减去0
			}
			else
			{
				w++;//处理下一个数
			}
		}
		hanshu(i);//调用函数
	}
	for(int i=1;i<=n;i++)//循环
	{
		for(int j=1;j<=5;j++)//循环
		{
			cout<<s[i][j]<<' ';//输出答案
		}
		cout<<endl;//下一行
	}
    return 0;//别忘了
}
```
谢谢观看！
