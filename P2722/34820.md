楼下就一个Pascal,我想我写的可能更清晰明了点。

---------------------------

完全背包基本思路:（来自百度）

```cpp
　　    这个问题非常类似于01背包问题，所不同的是每种物品有无限件。也就是从每种物品的角度考虑，与它相关的策略已并非取或不取两种，而是有取0件、取1件、取2件……等很多种。如果仍然按照解01背包时的思路，令f[i][v]表示前i种物品恰放入一个容量为v的背包的最大权值。仍然可以按照每种物品不同的策略写出状态转移方程，像这样：f[i][v]=max{f[i-1][v-k*w[i]]+k*c[i]|0<=k*w[i]<= v}。
　　将01背包问题的基本思路加以改进，得到了这样一个清晰的方法。这说明01背包问题的方程的确是很重要，可以推及其它类型的背包问题。
```
```pascal
uses math; //为后面的max函数调用math库
var
 i,v,k,n,m:longint;
 f:array[0..10000000]of longint; //根据题意开数组
 w,c:array[0..100000]of longint;
begin
  fillchar(f,sizeof(f),0); //习惯把数组初始化是一件好事，尤其是c++选手
  readln(m,n); // //背包容量m和物品数量n
  for i:=1 to n do
    readln(c[i],w[i]); //完全背包中每个物品的重量和价值
  for i:=1 to n do   // f(v)表示重量不超过v公斤的最大价值
    for v:=w[i] to m do
     f[v]:=max(f[v],f[v-w[i]]+c[i]);//不需用if语句，函数搞定，C++调用algorithm库
  writeln(f[m]); //输出答案
end.
```