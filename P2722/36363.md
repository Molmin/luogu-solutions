蒟蒻的第七篇题解-关于完全背包模板题（逃）


首先这道题题面很明确的说明了每一种类的题目是没有限定数量的，也就是无限次取，所以说就是一道裸的完全背包(楼下的dalao早已看破)，所以读入时间V和种类n后，利用a数组存放分数，也就是价值，b数组存放时间，也就是代价，这里是一个坑，就是因为两个看反了，本蒟蒻硬是卡了10分钟。用一维数组f来存放当时间为耗时为k的时候所得到的最多的分数，状态转移方程为f(k) = max(f(k),f(k-b(j)+a(j)) ，最后输出f(V)就可以了

**这道题目的坑点**

- 先输入的不是常规意义上的代价而是价值，不要看反了

- 种类没有规定的数量不是01背包（虽然可以转换但是本蒟蒻还是建议直接用完全背包）


下面附上代码

```cpp
//防伪标识
#include<bits/stdc++.h>
using namespace std;
int V, n;
int a[10001],b[10001],f[10001]; //根据题目数据范围开数组，大一点的数组建议开全局
int main(){
    cin >> V >> n; //输入时间，种类
    for(int i = 1;i<=n;i++)
        scanf("%d %d",&a[i],&b[i]); //这里要注意a数组为价值b数组为代价！！！
    for(int j = 1;j<=n;j++)
        for(int k = b[j];k<=V;k++) //从0开始也可以记得加上判断防止k-b(j) < 0
            f[k] = max(f[k],f[k-b[j]]+a[j]); //状态转移方程一定不要把代价和价值弄反！！！一定！
    printf("%d",f[V]);
    return 0;
}
```