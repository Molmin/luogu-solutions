简要题意：  
>把 n 个数分给 $k(1\le k\le n)$ 个小盆友，每个小盆友的力量就是他所拥有的数字的种类的数量，对每个 k 求出小盆友力量总和的最小值。

首先我们来看一下每个数加到一个小盆友手上时对总力量的贡献。若是小盆友没有这个数，则贡献为 1 ，反之贡献为 0 。为了让力量总和最少，将相同的数加到同一个小盆友手上总是最优的。而对于互不相同的数字，不论怎样分配，小盆友的力量总和总是固定的。因此我们可以将数字分成 t 堆，相同的数字放在同一堆，每一堆不论放在哪里它对总力量的贡献总是 1 。因此当堆数大于等于小盆友人数时，堆数就是总力量的最小值。当堆数跟小盆友人数一样后，随着小盆友人数的增多，势必要从某一堆中取出一个数给新的小盆友，而这个操作为使总力量 $+1$ ，因此每多出几个小盆友，总力量的最小值就增加多少。  
在对上述分析进行简化整合就可以得出最小总力量的公式： 
$$minstrength=\max(t,k)$$  
分堆过程可以用 STL 容器中的集合来很方便地实现  
附 AC 代码：  
```cpp
#include<bits/stdc++.h>
using namespace std;
int t,n,a;
int main(){
	cin>>t;
	while(t--){
		set<int> A;
		cin>>n;
		for(int i=0;i<n;i++){
			cin>>a;
			A.insert(a);
		}
		int m=A.size();
		for(int i=1;i<=n;i++)printf("%d%c",max(i,m)," \n"[i==n]);
	}
	return 0;
}
```
