我们可以先跟着样例模拟一下。

这里取样例三来模拟：

```php
7
5
4
3
7
1
2
6
```

第一次操作后，原数列变为 `1 5 4 3 7 2 6` 。

第二次操作后，原数列变为 `1 5 4 3 2 6 7` 。

不难发现，每次操作过后，都会有一个数字被踢出队列，不再对其余数的交换产生影响，若将这些数删去，我们的规律会更加明显。

一次操作， `5 4 3 7 2 6` 。

二次操作， `5 4 3 2 6` 。

设被操作的数为 $x$ ，即每次操作所求的答案就是数字 $x$ 所在的位置与队头（或队尾）的距离。

这样说可能还不太直观，我们将问题抽象一下，即原问题等价于：

**给定一个数列，长度为 $n$ ，一共进行 $n$ 次操作，设当前所操作的次数为 $x$ 。**

**若 $x$ 为奇数，则输出数字 $x/2+1$ 前有多少个有效元素，然后将数字 $x/2+1$ 标为无效元素。**

**若 $x$ 为偶数，则输出数字 $n-x/2+1$ 后有多少个有效元素，然后将数字 $n-x/2+1$ 标记为无效元素。**

这样问题就很清晰了，只要用一个树状数组便可维护上述答案。

代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
int c[100005];
int n;
int ask(int x)
{
	int ans=0;
	for(;x;x-=x&-x)ans+=c[x];
	return ans;
}
void add(int x,int y)
{
	for(;x<=n;x+=x&-x)c[x]+=y;
}
int a[100005];
int cnt[100005];
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)scanf("%d",&a[i]),cnt[a[i]]=i,add(i,1);
	for(int i=1;i<=n;i++)
	{
		int x;
		if(i%2==1)
		{
			x=i/2+1;
			printf("%d\n",ask(cnt[x])-1);
		}
		else{
			x=n-i/2+1;
			printf("%d\n",ask(n)-ask(cnt[x])); 
		}
		add(cnt[x],-1);
	}
	return 0;
}
```



