 [P2447 [SDOI2010]外星千足虫](https://www.luogu.com.cn/problem/P2447)


------------
写的应该算比较具体了，对于异或下的高斯消元做了详细介绍，如要错误欢迎指出。

------------

### 一、题意描述

给定由 $m$ 条异或方程构成的异或方程组，要求求解 $n$ 个未知数的解（$0$ 或 $1$），同时要求求出最少根据前几条方程即能得出所有解。

若 $m$ 条方程无法解出 $n$ 个未知数的**定解**，则输出 `Cannot Determine`。

方程保证有解。

PS：话说 $n\leq 1000,m\leq 2000$，$O(n^2m)$ 能直接刚过去？bitset 有点猛。

### 二、异或高斯消元

对于异或运算，它其实就是**二进制下的不进位加法**，满足交换律和结合律，所以它满足高斯消元的条件，可以使用高斯消元进行求解。

如样例 $1$：

```
3 5
011 1
110 1
101 0
111 1
010 1
```

可构造出方程（$\oplus$ 表示异或）：

$$\left\{\begin{matrix}
 x_2 \oplus x_3=1\\
 x_1 \oplus x_2=1\\
 x_1 \oplus x_3=0\\
 x_1 \oplus x_2 \oplus x_3=1\\
 x_2=1

\end{matrix}\right.$$

我们希望得到类似于 $x_i=0/1$ 的式子（即高斯消元的思想，使得只有一个式子含有 $x_i$）。

如我们想要消去除第一个含有 $x_1$ 的方程外的其他方程中的 $x_1$，那么我们可以将第一个含有 $x_1$ 的方程与下面所有含有 $x_1$ 的方程进行异或,这样除了这个方程，所有的方程中的 $x_1$ 都被消掉了。

**要注意的是，对于一个已经被拿来消其他元的方程，不能再次选择它作为消元方程（但仍然会被消）**。

如上消去 $x_1$，得到（标红为已使用）：

$$\left\{\begin{matrix}
 x_2 \oplus x_3=1\\
 {\color{red}x_1 \oplus x_2=1}\\
 x_2 \oplus x_3=1\\
 x_3=0\\
 x_2=1

\end{matrix}\right.$$


同理，消去 $x_2$ 后得到：

$$\left\{\begin{matrix}
 {\color{red} x_2 \oplus x_3=1}\\
 {\color{red}x_1 \oplus x_3=0}\\
 0=0\\
 x_3=0\\
 x_3=0

\end{matrix}\right.$$

同理，消去 $x_3$ 得到：

$$\left\{\begin{matrix}
 {\color{red} x_2=1}\\
 {\color{red}x_1=0}\\
 0=0\\
 {\color{red}x_3=0}\\
 0=0

\end{matrix}\right.$$

得到解：

$$\left\{\begin{matrix}
x_1=0\\
x_2=1\\
x_3=0
\end{matrix}\right.$$

如上，我们已经得到了一种解出多元一次异或方程组的方式。

那么，怎么才能求出最少需要几条方程能解出解呢，又如何判定该方程有多组解呢？

#### 多解情况：

如果我们无法在消任意一个未知数的时候，找不到任何一个未使用方程含有这一个未知数，那么该方程有多组解，即该元为**自由元**，不受任何条件约束。

#### 最少方程数量：

我们在整个消元过程中选择的所有用来消元方程的最后一个所在位置，就是最少的方程数量，因为若想要完全消完这 $n$ 个未知数，一定要到这里，并且到达这里，所有元肯定已经被消掉了。

对于样例，在最后消 $x_3$ 时，我们使用了第四条方程，所以最少方程数量是 $4$。

### 三、代码实现

若使用朴素的高斯消元，则我们的时间复杂度应当是 $O(n^2m)$，在该题数据规模下是无法通过的，但对矩阵的行的异或操作可以使用 bitset 对每一行进行表示，从而得到一个 $O(\dfrac{n^2m}
{32})$ 的算法。

实测不吸氧 200ms。

我们进行一层 $1\dots n$ 的循环，每次寻找第一个未选择的含有 $x_i$ 的方程，用它对每一个含有 $x_i$ 的方程进行异或。

为了方便，我们可以将被选择的方程换到上面，这样既方便输出，也可以使寻找第一个未选择的方程更加方便。

具体代码如下：

```cpp
#include<cstdio>
#include<bitset>
using namespace std;
int n,m,x,b[2005],id[2005],ans;
bitset<1005> s[2005];
char c[1005];
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=m+1;i++)//将每个方程的id记录，即它在原先位置是第几条方程
		id[i]=i;
	for(int i=1;i<=m;i++){
		scanf("%s %d",c+1,&x);
		for(int j=1;j<=n;j++)
			s[i][j]=(c[j]=='1');
		b[i]=x;
	}
	for(int i=1;i<=n;i++){
		int tmp=m+1;
		for(int j=i;j<=m;j++)
			if(s[j][i]&&id[tmp]>id[j])//第1到i-1条方程都是被使用的方程。
				tmp=j;//所以从i开始寻找id最小且含有xi的方程
		if(tmp==m+1){
			printf("Cannot Determine");//若无法找到任意一个未使用方程含有xi，则多解
			return 0;
		}
		ans=max(ans,id[tmp]);swap(s[i],s[tmp]);//取选择的id最大值，即最少需要几条方程
		swap(b[i],b[tmp]);swap(id[i],id[tmp]);//将已使用方程调换到上面
		for(int j=1;j<=m;j++)
			if(i!=j&&s[j][i])//看该方程是否含有xi
				s[j]^=s[i],b[j]^=b[i];//含有则将选择方程与该方程异或
	}
	printf("%d\n",ans);//输出答案
	for(int i=1;i<=n;i++)
		if(b[i])
			printf("?y7M#\n");
		else
			printf("Earth\n");
}
```
