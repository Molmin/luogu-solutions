这有 \*2400 ？

乍一看似乎不太好做，但是由于点的坐标互不相同，且要求点集中两两曼哈顿距离都相等，我们可以发现点集大小定然很小。

我们稍加思（da）考（biao），发现点集大小必然不超过 $4$。但其实这是很显然的，因为假设我们在平面上有两个点 $a$ 和 $b$，分别以相同的曼哈顿距离 $l$ 作正方形，最多只有两个交点，因此点集大小最多为 $2+2=4$。

再考虑题目中的另一个条件：点集内的点的距离严格小于点集内的点与点集外的点的任意距离。

从这里我们可以得出：所有合法点集之间不可能有交。

这也是显然的，因为如果有交，那么对于一个交点，它在两个点集中必然分别与非交点的距离相等，不符合严格小于的条件。

发现这个后，我们可以尝试去统计一下所有大小为 $2,3,4$ 的点集个数，然后就能计算答案了。

这也很好维护，我们只需要提前求出每个点与其它点的最小距离 $d_i$，最小距离点的数组 $g_i$。由于点集大小最多为 $4$，所以这个数组第二维只需要开到 $5$ 即可，当数组大小达到 $4$ 时无论如何它都不会对答案有贡献。

然后我们就可以用暴力的方式求出所有合法的点集了：

```cpp
for(int i=1;i<=n;i++){
		if(mncnt[i]==4 || c[i]) continue; //最小距离点超过3个，或者已经统计过这个点，跳过
		bool ok=1;
		for(int j=1;j<=mncnt[i];j++){
			if(mn[g[i][j]]^mn[i] || mncnt[g[i][j]]^mncnt[i]) ok=0;
            // 最小距离不同，或者最小距离点个数不同，显然不会是在一个点集里
			for(int k=1;k<=mncnt[g[i][j]];k++)
			    if(g[g[i][j]][k]^i && w[i][g[g[i][j]][k]]^mn[i]) ok=0;
                // g[i][j] 所连接的最小距离点并不是 i 所连接的最小距离点，也不可行
		}
		if(ok){
			t[mncnt[i]+1]++; //算上 i，点集大小为 cnt+1 的个数增加
			c[i]=1;
			for(int j=1;j<=mncnt[i];j++) c[g[i][j]]=1; //打上统计标记
		}
	}
```

怎么统计答案呢？由于 $n$ 很小，我们可以直接暴力枚举选取几个大小为 $2,3,4$ 的点集，设为 $i,j,k$，那么就剩下 $l=n-2\times i-3\times j -4 \times k$ 个大小为 $1$ 的点集，其对答案的贡献显然为：

${cnt_2 \choose i} \times {cnt_3 \choose j} \times {cnt_4 \choose k} \times {n \choose i+j+k+l} \times (i+j+k+l)!$

其中 ${n \choose i+j+k+l} \times (i+j+k+l)!$ 是因为我要在 $n$ 种颜色中选出 $i+j+k+l$ 种染色，然后对于每种选择方案都有 $(i+j+k+l)!$ 种排列方式。

至此我们解决了这个问题，时间复杂度 $O(n^3)$（实际上由于 $cnt_2\times2+cnt_3\times3+cnt_4\times4 \le n$，其效率是远高于 $O(n^3)$的，在 $n\le 2000$ 下都能轻松跑过）

[完整代码](https://codeforces.com/contest/1697/submission/170844072)