很有趣的构造题。

约定：$B$ 进制数的第 $d$ 位指的是 $B^d$ 这一位。

我们考虑在什么位置让 $a$ 出现。

由于 $a$ 不超过 $11$ 位，不妨假设是在 $[d-11,d-1]$ 这些位里填了 $a$。

只需要考虑 $b=2^{k}\bmod 10^d$ 的取值情况。

当 $k\ge d$ 的时候，$2^d|b$。

我们声称：只需要考虑 $k\ge d$ 的情况就可以构造出解。

于是只需要考虑 $\dfrac{b}{2^d}=2^{k-d}\bmod 5^d$ 的取值情况。

我们希望 $2$ 是 $5^d$ 的一个原根，这样 $2^{k-d}\bmod 5^d$ 就可以覆盖所有不是 $5$ 的倍数的数。暂时先假设这一点是成立的。

$b$ 的前 $11$ 位已经被固定下来，如果要一定能构造解，那么只需要满足 $10^{d-11}\ge 2^{d+1}$，即至少有**两个** $2^d$ 的倍数满足前 $11$ 位为 $a$。

要求有两个而不是一个是为了避免 $5$ 的倍数这种特殊情况，而相邻两个正整数里至少有一个不是 $5$ 的倍数。

根据上面这个式子我们可以得到 $d\ge 17$。那么我们直接取 $d=17$，随便写个代码验证一下即可发现 $2$ 是 $5^{17}$ 的一个原根，因此上面说的构造方法可以成立。

现在我们得到了 $b$，且 $b=2^{k-17}\mod 5^{17}$，如何求出 $k$ 呢？

一个直观的想法是直接暴力 BSGS，复杂度就过大了。

考虑在 $5$ 进制下按位构造，假设目前已经构造出了 $k$ 满足 $b\equiv 2^k\pmod{5^{d-1}}$，我们需要对 $5$ 进制下的第 $d$ 位进行调整。

可以支持的操作只有乘法，一种想法是对于每个 $d$ 找到一个 $w_d$ 满足 $5^d+1=2^{w_d}\mod 5^{17}$。可以发现，不断地给 $k$ 加上 $w_d$ 的过程中，$2^k$ 在 $5$ 进制下的 $5^d$ 这一位会遍历 $[0,4]$ 中的每一个数。因此，一定存在一个时刻满足 $b\equiv 2^{k}\pmod{5^d}$。

现在我们只需要对于每一个 $d$ 求出 $w_d$ 满足 $5^d+1=2^{w_d}\bmod 5^{17}$，直接 BSGS 即可。时间复杂度 $O(\sqrt{n}\log n+T\log n)$，已经能够通过本题。

但实际上我们还有更加智慧的构造方式。对 $w_d$ 的作用进行分析可以发现，我们实际上只需要保证 $c\times 5^d+1\equiv 2^{w_d}\pmod{5^{d+1}}$，其中 $c\in [1,4]$。构造 $w_d=\varphi(5^d)$，容易证明这个构造方法一定满足条件。

代码非常好写。

时间复杂度 $O(T\log n)$。

参考代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define N 25
#define ll long long
#define lll __int128
int T;ll n,nw,ans,pw[N],w[N],w1[N];
void init()
{
	pw[0]=w[0]=1;w[1]=4;w1[0]=2;w1[1]=16;
	for(int i=1;i<=17;++i) pw[i]=pw[i-1]*5;
	for(int i=2;i<17;++i)
	{
		w[i]=w[i-1]*5;
		w1[i]=(lll)w1[i-1]*w1[i-1]%pw[17];
		w1[i]=(lll)w1[i]*w1[i]%pw[17];
		w1[i]=(lll)w1[i]*w1[i-1]%pw[17];
	}
}
void slv()
{
	scanf("%lld",&n);n*=1e6;nw=1;ans=17;
	n=((n-1)>>17)+1;if(!(n%5)) ++n;
	for(int i=0;i<17;++i)
		while(n%pw[i+1]!=nw%pw[i+1])
			nw=(lll)nw*w1[i]%pw[17],ans+=w[i];
	printf("%lld\n",ans);
}
int main()
{
	scanf("%d",&T);init();
	while(T--) slv();return 0;
}
```