## 思路

我们先看看题意。

说给你两个矩阵，请你无限次交换第一个矩阵的任意两列，问能否将第一个矩阵变成第二个矩阵。

既然说每一次都是交换第一个矩阵的两列，因此每一列都是作为一个整体进行移动的，那么我们可以将每一列作为整体进行存储。

我们可以定义 $s_i$ 表示第一个矩阵的第 $i$ 列从上到下连成的字符串， $t_i$ 表示第二个矩阵的第 $i$ 列从上到下连成的字符串。

这样，以输入 $s$ 为例，就应该写成这样：
```cpp
char c;//将字符输入到这里，便于后面的操作
for(int i=1;i<=n;i++)//遍历每一行
{
	for(int j=1;j<=m;j++)//遍历每一列
	{
		cin>>c;
		s[j]+=c;//因为 s[i] 代表第一个矩阵的第 i 列从上到下连成的字符串，这里是第 j 列，所以要插入到 s[j] 后面
	}
}
```
那如何判断能否将第一个矩阵变成第二个矩阵呢？

可以将第一个矩阵变成第二个矩阵，**当且仅当** $s$ 与 $t$ 排完序后完全相等。

证明：

因为排序的本质是将两个内容交换， $s$ **一定能通过交换使** $s$ **有序**，假设 $s$ 有序后，得到了 $u$ 。

那么，现在的问题是 $u$ 能否变成 $t$ ，**这等价于** $t$ **能否变成** $u$ 。

由于 $u$ **是有序的**，所以 $t$ 一定也要变得有序，才有可能变成 $u$ 。

总结一下。如果 $s$ 能变成 $t$ ，因为 $s$ 能变成 $u$ ，所以 $t$ 也能变成 $u$ ，不然， $s$ 就不能变成 $t$ 。如果 $s$ 不能变成 $t$ ，因为 $s$ 能变成 $u$ ，所以 $t$ 也不能变成 $u$ ，不然， $s$ 就能变成 $t$ 。问题得证。

有了这些，就可以打代码了。与上面重复的代码注释就不写了。
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=4e5+100;
string s[N],t[N];
char c;
int main()
{
	int n,m;
	cin>>n>>m;//输入行数和列数
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			cin>>c;
			s[j]+=c;
		}
	}
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			cin>>c;
			t[j]+=c;
		}
	}
	sort(s+1,s+m+1);
	sort(t+1,t+m+1);
	//对两个字符串数组进行排序
	for(int i=1;i<=m;i++)
	{
		if(s[i]!=t[i])//如果排序后， s 和 t 的某一项不相等，就没有将第一个矩阵变成第二个矩阵的希望了
		{
			printf("No\n");
			return 0;
		}
	}
	printf("Yes\n");//否则，一定可以将第一个矩阵变成第二个矩阵
	return 0;
}
```