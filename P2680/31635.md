这道题是 **树上差分** 的典型例题，所谓树上差分，就是利用类似前缀和的思想。对于这道题，我们需要快速求出若干条路径的交集，换句话说，我们需要统计每条边被经过了几次。对于每条路径 u->v，我们需要把点 u 和点 v 的权值 +1，把 lca(u,v) 的权值 -2，这样每条边经过的次数就是以深度较大的点为根的子树中每个点的权值和。

以上很多题解都说的十分详细，我写这篇题解主要是想给出一种能优化大量常数的方法。

对于这道题我们需要遍历每个点找到符合条件的边，这个过程需要用 $DFS$，但是 $DFS$ 常数极大，我们能不能不用递归调用呢？

答案是能，我们可以用 $序DFS序$ 来代替 $DFS$ 的过程，只需要在开始时预处理出出栈序，然后用 $for$ 循环就可以达到遍历整棵树的效果，代码如下：

```c++
inline void solve(){
	maxedge = 0;
	for (int i = 1; i <= n; ++i){
		int u = DFSpath[i];
		if (tag[u] == num) maxedge = max(maxedge, sum[u][0]);
		tag[fa[u][0]] += tag[u];
	}
}
//sum[u][0]表示点 u 父亲到它的边
//fa[u][0]表示点 u 的父亲
//fa 和 sum 都可以通过 DFS 求出
```

