楼上下写的都是树上差分二分什么的，我提供个新方法。

预处理每对节点的距离（LCA），同时找出最长链，缩短的边一定在这条链上。此过程为O(nlogn)。

枚举链上每一条边，对于所有点对，可以分成两种了：1）经过这条边的点对；2）不经过的。

判断方法：割掉这条边，判断两点是否连通，仍连通，说明不经过，反之经过。于是一棵树就被拆成了两棵。对于经过的路径（包含最长的），距离都会被缩短，但因为最长的路径存在，所以无需考虑经过的其他路径；而不经过的路径之中取个最大值，将最长路径减去边的权和不经过该边的最大值中再取最大值，枚举所有边的时候再取个最小值就OK了。

在链上一条接着一条判断边时，其中的一棵子树会获得更多的节点，其中可能就包括端点，获得其中一个表示此点对经过该边，获得另一个表示不经过了，因为都在子树中连通。这个过程中判断完所有的边后，所有节点都转至子树中，复杂度为O(n)。

对于判断不经过该边的点对的最大值，维护个线段树，开始时维护第i个点对距离d[i]，在得到一个端点后修改成0，另一个也得到时修改回来。此过程为O(nlogn)。

分析结束。

本人代码比较粗劣，不放了，上面思路也很清晰了。