# 「Wdoi-4」芙兰的贤者时间

[Luogu P7871](https://www.luogu.com.cn/problem/P7871)

一道很有意思的题目。

题目中有说到：能量只会往左右两边更低的一侧流动，这也就意味着，给出 $s,t$， 我们就可以得到一连串的数的大小关系。

先手玩一下样例，会发现：

- $s=1,t=2$ 这一组没有作用，因为 $1$ 只会流向 $2$。

- $s=3,t=7 \rightarrow a_3 > a_5 > a_7, a_2 > a_4 > a_6$。

- $s=8,t=10 \rightarrow a_7 > a_9, a_8 > a_{10}$。

- $s=5,t=6 \rightarrow a_4 > a_6$。

这样模拟一下，感觉就差不多找到规律了。

首先，大小关系一定是奇数和奇数，偶数和偶数之间的（这点很好说明，因为每次能量的流向是由左右两个位置的值决定的，也就是说每次的大小关系是两个间隔 $1$ 的数形成的）。

其次，会发现当 $s<t$ 时，形成大小关系的数的区间是 $[s-1,t]$ 的（需要注意的是，题目中说到的 $t$ 是经过而不是终点）。类似的，也可以推出 $s>t$ 的方式形成大小关系的数的区间是 $[s,t+1]$。

现在，得到了大小关系，该如何转换一下变得好给出方案呢？选择对于每一组大小关系，从大数向小数连一条边，那么在最后给出方案的时候就可以用类似拓扑排序的方式给出。

但是很快遇到了一个问题，如果对于每一组 $s,t$ 都需要暴力枚举连边的话，时间复杂度是 $\mathcal O(qn)$ 的，显然是过不了 $3\times 10^5$ 的数据量的。不过可以发现，这种连边方式很像是一种区间操作，那么就可以尝试将每一组操作变成区间操作。

考虑定义 $A[i]$ 表示 $i$ 向 $i+2$ 有连边，那么对于 $s,t$ 这一组操作就可以转化为区间 $[s-1,t-2]$ 的区间赋 $1$。因为不会出现 $-1$ 的情况，所以可以用差分维护区间加的方式优化。也就是说，对于一组操作 $s,t$，只需要 $A[s-1]+1,A[t-1]+1$ 即可。类比着，可以推导出 $s>t$ 的情况。

对于无解的情况，就是有两个数之间连成了双向边（也就是既满足 $a>b$ 又满足 $a<b$），这显然是不符合的，直接 `for` 循环找一下有没有这种边就行了。

现在我们维护出来了连边的方式，考虑怎么赋值。如果直接贪心的前面的数赋值较小，然后按照图的边逐个赋值，可能会出现赋不出值的情况（如果最左侧的数在它处于的不等式链中处于一个较大的位置，并且向右是大于，如果直接贪心的赋值最左侧的数为最小值，会导致右侧的数无法赋值）。因此需要将右侧的所有数从不等式链的底端开始赋值，具体实现方式参考了题解的第一篇。

## Code

```cpp
#include<bits/stdc++.h>
#define mem(a,b) memset(a,b,sizeof a)
//#define int long long
constexpr int _SIZE = 3e5;
int n, q;
int A[_SIZE + 5], B[_SIZE + 5];
int ans[_SIZE + 5], cnt;
using namespace std;
signed main() {
	ios::sync_with_stdio(false);
	cin.tie(nullptr); cout.tie(nullptr);
	cin >> n >> q;
	for (int i = 1; i <= q; i++) {
		int s, t;
		cin >> s >> t;
		if (s < t) A[s - 1]++, A[t - 1]--; // 差分区间加
		else if (s > t) B[s]--, B[t]++;
	}
	for (int i = 1; i <= n; i++) // 差分数组还原
		A[i] += A[i - 1], B[i] += B[i - 1];
	bool noAnswer = 0;
	for (int i = 1; i <= n - 2; i++) // 判定无解
		if (A[i] && B[i]) {noAnswer = 1; break;}
	if (noAnswer) return puts("QED") & 0;
	for (int i = 1; i <= n; i++) {
		if (!ans[i]) {
			int c = 1;
			for (int j = i; j + 2 <= n && A[j]; j += 2) c++; // 找到不等式链的底端
			for (int j = 1; j <= c; j++) ans[i + 2 * c - 2 * j] = ++cnt; // 从底端向上赋值
		}
	}
	for (int i = 1; i <= n; i++) cout << ans[i] << ' ';
	return 0;
}
```