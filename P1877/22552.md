01背包问题是 一个物品拿或者不拿中求最大值的问题


这道题目就是 音量增加或者减少中求最大值的问题


但是如果生搬硬套01背包的方程用在这里肯定是不合适的。


在这里，我们想对于每次调节，也就是两种可能 在上次的基础上调大，或者是调小。但是调大不能超过上限，调小不能超过下限。


让我们再分析分析样例：


3 5 10

5 3 7

第一次调节 只能从 5开始 调小的话就是0 调大的话就是10


第二次调节 先分析0 调小不可以 调大只能是3  在分析10 调小是7 调大不可以


第三次调节 先分析3 调小不可以 调大是10 再分析7 调小是0 调大是不可以


是不是隐隐约约能摸索出这个转移方程了？


对没错，方程是 用二维bool型数组来DP，f[i][j]=true表示第i首歌音量为j可行，DP方程为：


if((f[i-1][j+c[i]]==true&&j+c[i]<=maxL)||(f[i-1][j-c[i]]==true&&j-c[i]>=0)) f[i][j]=true;

关键是f[i-1][j+c[i]] 和 f[i-1][j-c[i]]这两个，要仔细推敲。


初始值f[0][初始值]=1


最后再从大到小遍历 最后一次 调节时的最大值，如果存在输出。如果不存在则输出-1.

```cpp
#include <cstdio>
const int maxn=1005;
int n,m,MAX,c[maxn];
bool dp[maxn][maxn];
int main(){
    scanf("%d%d%d",&n,&m,&MAX);
    for(int i=1;i<=n;i++) scanf("%d",&c[i]);
    dp[0][m]=1;
    for(int i=1;i<=n;i++)
        for(int j=0;j<=MAX;j++){
            if( (dp[i-1][j+c[i]] && j+c[i]<=MAX) || ( dp[i-1][j-c[i]] && j-c[i]>=0)) 
            dp[i][j]=1;
        }
    for(int i=MAX;i>=0;i--){
        if(dp[n][i]) {
            printf("%d\n",i);
            return 0;
        }
    }
    printf("-1");
    return 0;
}
```