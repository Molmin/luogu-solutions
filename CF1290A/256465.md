## 简单翻译
你和$n-1$个朋友发现了一个含有$n$个整数的双端队列，$n$个人排队依次取走队首或队尾。你是队伍中的第$m$个人，在**所有人开始取数字前**你可以指定队伍中不同的$k$个人，使他们在取的时候听从你的指挥。一旦第一个人开始取数字，你就不能再指挥其他人或改变你之前的命令了。

求最大的整数$X$使得**无论未经你控制的人如何选择**，你能取到的数都**不小于**$X$。
## 思路：
首先这道题的数据范围很小，$n \le 3500$，所以本题用$O(n^2)$的暴力做是理所应当的。但是，可以通过单调队列的优化将时间复杂度降低到$O(n)$。

根据题意，可以发现以下两点：

- 不需要考虑排在自己后面的人。即当$k$的值超过在自己之前的人数$m-1$时，多余的受控制的人数不会对结果产生任何影响。
- 轮到自己时的情况只和之前在队首和队尾取的人数有关，和受自己控制的人取数字的先后顺序没有关系。也就是说，假设有一个人受到控制，并且已经确定他在队首(或队尾)取，那么无论他排在你前面的哪一位效果都是一样的。

自己是队伍的第$m$个人，由于之前的$m-1$人都只会取队首或队尾的元素，留给自己的一定是一个完整的且长度为$n-m+1$的区间。比较每一个区间的首尾元素并取最大值，可以得到一个值表示对于这一个区间可以取到的最大值。这样的区间一共有$m$个，所以开一个新的数组$s$来存储。

由于不受自己控制的人的选择是不可预计的，如果没有可以控制的人，那我们的$X$只能选择最坏的情况。所以控制一些人的选择可以帮助我们排除掉一些相对坏的情况。

接下来对**取队首的人**中**受到自己控制的人的数量**进行遍历，然后用一个单调队列找出每一次符合条件的最坏情况，再将所有的最坏情况取最大值，就可以找到所求的答案。这里单调队列的操作和[单调队列模板题](https://www.luogu.com.cn/problem/P1886)的操作非常相似，这种方法可以将复杂度降低到$O(n)$。

## AC代码：

```c++
#include <bits/stdc++.h>
using namespace std;
deque<int> q;
vector<int> v, a;
int main()
{
    int t, n, m, k, r, ans;
    scanf("%d", &t);
    while (t--)
    {
        ans = 0;
        a.clear();
        v.clear();
        q.clear();
        scanf("%d%d%d", &n, &m, &k);
        k = min(k, m - 1);
        for (register int i = 0; i < n; i++)
        {
            scanf("%d", &r);
            a.push_back(r);
        }
        for (register int i = 0; i < m; i++)
            v.push_back(max(a[i], a[i + n - m]));
        for (register int i = 0, j = 0; i <= k; i++)
        {
            for (; j < i + m - k; j++)
            {
                while (!q.empty() && v[q.back()] >= v[j])
                    q.pop_back();
                q.push_back(j);
            }
            while (!q.empty() && q.front() < i)
                q.pop_front();
            ans = max(ans, v[q.front()]);
        }
        printf("%d\n", ans);
    }
    return 0;
}
```
