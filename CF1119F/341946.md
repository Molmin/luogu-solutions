一道很好口糊，但是实现细节颇多的题（时间复杂度容易假掉）。

我们先考虑固定 $x$ 的情况，用 $dp[u][0]$ 表示删除点 $u$ 到其父亲的连边的最小删边代价，用 $dp[u][1]$ 表示不删除点 $u$ 到其父亲的连边的最小删边代价。对于儿子 $v$ 有两种转移方式，第一种 $dp[v][0]+cost(u,v)$，第二种 $dp[v][1]$。发现直接转移要多加一维，和树上背包类似。但是复杂度会爆炸。故而我们选择一种带反悔的方法，一开始所有都选 $dp[v][1]$，再把一些 $1$ 的换成 $0$ 的。那么只要用堆 $dp[v][0]+cost(u,v)-dp[v][1]$ 即可。

之后我们考虑从小到大枚举 $x$，对于所有度数大于 $x$ 的点的联通块按上述简易版方法跑一遍树 $\text{DP}$。那些不用跑的点我们在枚举到的度数等于它时就已经把其删除，对所有它连出去的点的大根堆放入了它的权值了（注意当前进行树 $\text{DP}$ 时已经删除的点不用操作就满足，故而不会产生额外贡献）。

时间复杂度 $O(\text{度数})$，若要更具体的可以就代码分析。

[代码](https://codeforces.com/contest/1119/submission/201200448)。