## $\mathfrak{bfs}$ 详解
题目链接 [$\mathfrak{P2622}$](https://www.luogu.com.cn/problem/P2622)。

### 题目大意
你有 $n$ 盏灯、$m$ 个按钮。状态 $a[i][j]$ 表示，按下第 $i$ 个按钮会对第 $j$ 盏灯如何操作。按下第 $i$ 个按钮，如果 $a[i][j]=1$，判断第 $j$ 盏灯是否开着，如果开着就关掉；如果 $a[i][j]=-1$，判断第 $j$ 盏灯是否关着，如果关着就打开。  

问你令所有灯全部关闭的最少步数。

### 为何此题状压 $\mathfrak{dp}$ 不应是正解？
下面给出证明。

在写状压 $dp$ 时，我们设 $now$ 为按完开关后所有灯的状态，$i$ 为原状态。  
因为初始状态是全 $1$，询问状态是全 $0$，所以需要倒序枚举 $i$。  

求出来 $now$ 之后用 $f[i]$ 更新 $f[now]$ 的值，因为 $dp$ 的无后效性，$f[i]$ 的值应是已经确定的，即 $i$ 的值应比 $now$ 大。但是在此题，显然我们算出来的 $now$ 的值既可能比 $i$ 小，也可能比 $i$ 大，所以无法保证无后效性，不应选用 $dp$ 的做法。

### 思路
此题要求最少步数。对于每一个状态，我们进行相应的操作，直到找到所有灯全部关闭，即全 $0$ 的状态。显然可以 $bfs$。

**介绍一下变量：**  
$a[i][j]$：如题，记录按下第 $i$ 个按钮对第 $j$ 盏灯进行的操作。  
$vis[ttx]$：记录状态 $ttx$ 是否入队过（即是否得到过状态 $ttx$）。  
$step[ttx]$：记录状态 $ttx$ 是第几步得到的。  
因为此题 $n<=10$，即最多有 $10$ 盏灯，所以状压最大值（全 $1$ 时）为 $2^{10}-1=1023$，数组开 $2000$ 足够够的了。

**第一步：处理输入。**  
没啥好说的，**代码实现如下：**  
```cpp
scanf("%d%d", &n, &m);
for (int i = 1; i <= m; ++i) {
	for (int j = 1; j <= n; ++j) {
		scanf("%d", &a[i][j]);
	}
}
```
注意 $n$ 为灯数，$m$ 为按钮数。

**第二步：初始状态入队。**  
把全 $1$ 的状态入队，并将其 $vis$ 值修改为 $true$。如何得到全 $1$ 的状态呢？  
手玩一下，设 $n=4$。  
首先，我们求一下 $1<<n$，得到：
```cpp
1 0 0 0 0
```
然后我们将这个值 $-1$，得到：
```cpp
0 1 1 1 1
```
这就是我们想要的初始状态。  
推而广之，我们的初始状态就应是 $(1<<n)-1$。注意运算符的优先级，此处应加括号。  
**代码实现如下：**  
```cpp
q.push((1 << n) - 1);
vis[(1 << n) - 1] = true;
```

**第三步：$bfs$ 主体。**  
首先拿出队头，队头出队：
```cpp
int tx = q.front(); q.pop();
```
然后判断一下，如果队头状态是全 $0$，输出队头的 $step$ 值：
```cpp
if (!tx) { printf("%d", step[tx]); return 0; }
```
如果队头状态不是全 $0$，我们就需要遍历全部的 $m$ 个按钮，然后将得到的新状态入队。  
对于每一盏灯的操作应如何用位运算表示？还是手玩一下。  
需要提前声明的是，为了在写代码时便于思考，我们**用最低位表示第 $1$ 盏灯，高位依次类推**。即，状态：
```cpp
0 0 0 1 0
```
表示第 $2$ 盏灯开着，其他的灯都关着。  
**假设：**$n=5$，我们已经遍历到了第 $i$ 个按钮，正在对第 $2$ 盏灯进行操作。  
**先模拟关灯的操作：**  
假设 $a[i][2]=1$，初始状态如下：
```cpp
1 0 1 1 0
```
我们要把第 $2$ 位置为 $0$。因为 $\&1$ 原值不变，$\&0$ 原值置 $0$，可以将原序列如下操作：
```cpp
  1 0 1 1 0
& 1 1 1 0 1
-------------
  1 0 1 0 0
```
推而广之，将序列 $ttx$ 第 $j$ 位置为 $0$，可以如下操作：
```cpp
ttx &= ~(1 << (j - 1));
```
**再模拟一下开灯的操作：**  
假设 $a[i][2]=-1$，初始状态如下：
```cpp
1 0 1 0 0
```
我们要把第 $2$ 位置为 $1$。因为 $|0$ 原值不变，$|1$ 原值置 $1$，可以将原序列如下操作：
```cpp
  1 0 1 0 0
| 0 0 0 1 0
-------------
  1 0 1 1 0
```
推而广之，将序列 $ttx$ 第 $j$ 位置为 $1$，可以如下操作：
```cpp
ttx |= 1 << (j - 1);
```
然后我们就得到了修改后的新状态。判断一下新状态是否已经入队，如果没有就将新状态入队，并修改 $vis$ 和 $step$ 的值。**代码实现如下：**
```cpp
if (!vis[ttx]) q.push(ttx), vis[ttx] = true, step[ttx] = step[tx] + 1;
```

**第四步：输出无解情况。**  
如果 $bfs$ 结束，程序仍然没有结束，说明无解。输出 $-1$ 即可。
```cpp
printf("-1");
```

### AC CODE
```cpp
#include <iostream>
#include <cstdio>
#include <queue>
using namespace std;

int n, m;
int a[110][15];
bool vis[2000];
int step[2000];
queue<int> q;

int main() {
	scanf("%d%d", &n, &m);
	for (int i = 1; i <= m; ++i) {
		for (int j = 1; j <= n; ++j) {
			scanf("%d", &a[i][j]);
		}
	}
	q.push((1 << n) - 1);
	vis[(1 << n) - 1] = true;
	while (q.size()) {
		int tx = q.front(); q.pop();
		if (!tx) { printf("%d", step[tx]); return 0; }
		for (int i = 1; i <= m; ++i) {
			int ttx = tx;
			for (int j = 1; j <= n; ++j) {
				if (a[i][j] == 1 && (tx & (1 << j - 1))) ttx &= ~(1 << (j - 1));//此处判断 ttx & (1 << j - 1) 亦可，因为当前位置 j 的值并未被修改 
				if (a[i][j] == -1 && !(tx & (1 << j - 1))) ttx |= 1 << (j - 1);
			}
			if (!vis[ttx]) q.push(ttx), vis[ttx] = true, step[ttx] = step[tx] + 1;
		}
	}
	printf("-1");
	return 0;
}
```
## 感谢观赏！