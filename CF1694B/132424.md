**谨以此题解纪念长时间停打 CF 后的第一场比赛**

### 思路

题目的操作方法将操作的本质给的比较含蓄。所以我们换一种方法表达：

> 对于字符串两个相邻的字符，若二者不相等，则可以删去左边的。

现在，对于一个字符串，必然是从左往右删到只剩下一个字符。所以，我们可以尝试来模拟一下操作。

考虑对于字符 $i$ 能否被删去。不难看出，若从左往右把能删的尽量全部删掉，那么 $i$ 必然会被右边第一个字符不为 $s_i$ 的位置删掉。所以，我们最后会得到这样一个串：

$xxxxxxxxx.....$

因为只能删去左边的字符，所以不难证明上面的字符串不能用其他方法删去（因为这些字符串是原串的一个后缀）。所以，我们题目要求的就是让上面的字符串长度为 $1$ 的原串个数。

所以，可以看出，当且仅当最后两个字符不相等或原串长度为 $1$ 时上述字符串长度为 $1$。所以，我们可以将串 $s$ 的字符分为两类：

* $s_i\not=s_{i-1}$，此时将 $i$ 作为原串的右端点时，左端点可以取任何不大于 $i$ 的值，答案加上 $i$。
* $s_i=s_{i-1}$，此时只能让原串长度为 $1$ 才可以。所以答案加上 $1$。

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
char s[200004];
int main()
{
	int t;
	scanf("%d",&t);
	while(t--)
	{
		int n;
		long long ans=0;
		scanf("%d%s",&n,s+1);
		for(int i=1;i<=n;i++)
			if(s[i]!=s[i-1])
				ans+=i;
			else
				ans++;
		printf("%lld\n",ans);
	}
	return 0;
}
```