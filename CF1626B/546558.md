## 题意简述
- 给出一个数 $x(10 \leqslant 10^{200000})$。
- 在其中挑选相邻的两位，用这两个数的和代替这两位数。

## 解题思路
设选取的两位分别为 $a$ 和 $b$ 考虑这两种情况：

1. $a+b \geqslant 10$，即操作完原数位数不变。
2. $a+b < 10$，即操作完数位减少 $1$。

首先，如果出现了第一种情况，那么一定选择第一种，因为
>比较两个正整数，位数多的更大。——《小学数学》

其次，如果有多处符合第一种情况，那么应该选取哪一处呢？

容易证明，如果符合第一种情况，在操作后产生的两位数一定比原数小。这会导致原数变小。

而越靠近个位，位权越小，减小的数也越小。

因此，如果出现第一种情况，应该取最靠近个位的一处。

而第二种情况呢？

>两个正整数相加，和大于任意一个加数。——《小学数学》

操作后的数字一定会大于原来两位数中远离个位的一个。比较所有可能的操作，可以发现，操作在最远离个位的位置时结果最大。

得到结论：

- 如果出现第一种情况，就选取最靠近个位的一处进行操作。
- 如果没有出现第一种情况，就选取最远离个位的一处进行操作。

## 代码实现
```cpp
#include<bits/stdc++.h>
using namespace std;
int main(void){
    ios::sync_with_stdio(0);
    cin.tie(0);
    int t,i,p,l,r;
    string s;
    bool flag;
    char c[3];
    cin >> t;
    while(t --){
    	cin >> s;
    	flag = 0;
    	l = s.size();
    	r = l - 2;
    	for(i = l-2;i >= 0;-- i){
    		if((s[i]-'0')+(s[i+1]-'0') >= 10){
    			r = i;
    			flag = 1;
    			break;
			}
		}
		if(flag){
			p = (s[r]-'0') + (s[r+1]-'0');
			s[r+1] = p % 10 + '0';
			p /= 10;
			s[i] = p + '0';
		}
		else{
			r = 0;
			c[0] = (s[r]-'0') + (s[r+1]-'0') + '0';
			c[1] = '\0';
			s.erase(r,2);
			s.insert(r,c);
		}
		cout << s << '\n';
    }
    return 0;
}
```