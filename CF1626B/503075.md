# CF1626B 题解
### 题目描述
给定正整数 $x$（$10≤x≤10^{2\times10^5}$），可对其中任意两个相邻的数字进行合并，即用这两个数字的和代替这两位数。

例如，当 $x=10057$ 时，有以下几种可能的合并：

- 选择第一位 $1$ 和第二位 $0$，将其合并，得到 $1+0=1$，于是 $x$ 变换为 $1057$；
- 选择第二位 $0$ 和第三位 $0$，将其合并，得到 $0+0=0$，于是 $x$ 变换为 $1057$；
- 选择第三位 $0$ 和第四位 $5$，将其合并，得到 $0+5=5$，于是 $x$ 变换为 $1057$；
- 选择第四位 $5$ 和第五位 $7$，将其合并，得到 $5+7=12$，于是 $x$ 变换为 $10012$。

该操作可且仅可进行一次，问经过一次该操作后，可获得的最大数。

显然，在上述示例中，获得的最大数为 $10012$。

### 思路

注意到数据范围，考虑线性复杂度做法。

采用贪心思想。要使变换后的数最大，首先变换后的数的位数一定要最多。所以我们期望找到一对相邻的数字之和不小于 $10$。继续思考，发现可能出现有多对相邻数字之和不小于 $10$ 的情况。那么如何进行操作才能使结果最大呢？不难发现，当两位数字之和大于 $10$ 时，它们的和必然小于由它们所组成的数。例如 $38$，$3+8=11$，显然 $11<38$。多举几个例子也成立。

简单证明，当 $x$，$y$ 均为正整数时，显然有 $x+y<10x+y$。

那么由此我们想到，在保证一对相邻数字和不小于 $10$ 的条件下，尽可能地使被合并的这对数出现在更靠后的位置，这样可以使结果尽可能大。那我们直接倒着枚举，当两个数和大于 $10$ 时，直接输出结果即可。

那么假如找不到一对和大于 $10$ 的相邻数字呢？

简单思考后发现，假如找不到这对数字，直接合并前两位即可。因为在这种情况下，合并后的数字肯定大于合并前。那么把合并操作尽可能靠前地完成，就可以使得结果最大，设法输出即可。

由于 $x$ 很大，直接用 $\text{string}$ 存，然后转存到数组即可。关于输出时所需要注意的，代码里都有，此处不多作解释。

### CODE
```cpp
#include<bits/stdc++.h>
using namespace std;
int t,a[200005];
void solve(){
	string s;
	cin>>s;
	int len=s.size();
	for(int i=0;i<len;i++){
		a[i+1]=s[i]-'0';
	}
	for(int i=len;i>1;i--){//倒着枚举 
		int ans=a[i]+a[i-1];
		if(a[i]+a[i-1]>=10){//优先判断是否有相邻数之和大于等于10的情况 
			a[i]=ans%10;
			a[i-1]=ans/10;//替换数字，然后输出 
			for(int i=1;i<=len;i++){
				cout<<a[i];
			}
			cout<<endl;
			return;
		}
	}
	a[2]=a[1]+a[2];//直接合并前两位 
	for(int i=2;i<=len;i++){//此时第一位为前导0，所以直接从第二位开始输出 
		cout<<a[i];
	}
	cout<<endl;
}
int main(){
	cin>>t;
	while(t--){
		solve();
	}
	return 0;
}

```
