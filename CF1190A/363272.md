本题是一道时间复杂度为 $\Theta(m)$ 左右的模拟。

首先，读入所有需要删除的数，由于题目中已经给出是**升序** $(1\le p_1 <p_2<p_3<\dots <p_{m-1}<p_m\le n)$，故我们可以不必排序，直接用一个 $pos$ 
记录当前扫到的位置即可。

对于每一次题目中所说的**操作**，我们考虑用模拟去实现。

以下是 $n=12,m=4,k=7,p_1=4,p_2=7,p_3=9,p_4=12$ 时的情况。

（注：右上角标有 $@$ 的数表示一组的开始。）

| $1^@$ | $2$ | $3$ | $4$ | $5$ | $6$ | $7$ | $8^{@}$ | $9$ | $10$ | $11$ | $12$ |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |

当进行第一次操作时，很显然，我们需要取出 $4$ 和 $7$。

在取走之后，数列变成了下面的这个样子：

| $1^@$ | $2$ | $3$ | $5$ | $6$ | $8$ | $9^{@}$ | $10$ | $11$ | $12$ |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |

再进行一次操作，取出 $9$ 和 $12$。

数列变成以下形式：

| $1^@$ | $2$ | $3$ | $5$ | $6$ | $8$ | $10^{@}$ | $11$ | 
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |

至此，操作结束。

为了解决数组在删除数据后的**后移**问题，我们可能会想到暴力，但数据范围 $(1\le n\le 10^{18},1\le m \le 10^{5},1\le m,k\le n)$ 令我们彻底死心。

此时，我们需要考虑优化。

令 $f(x)=\left \lfloor \frac{x+k-1}{k}\right \rfloor$，即求出他们在第几组。固然，同一组的 $f(x)$ 值一定相等。由此，我们联系到先前的升序，可以得出：

每一次操作时先求得当前数 $a_{pos}$ 的组别号码，然后一直增加 $pos$ 的值直到已经查询到的数的组别号码不等于本次操作的组别号码，操作结束，答案增加。

再次进行观察，我们可以发现：

已经扫过的数字数量 $used$ 等于当前的位置 $pos-1$！

至此，所有需要解决的问题解决，我们可以开始码代码了。


```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long//别忘了开long long！
int n,m,k,a[100005],pos=1,ans,used;
signed main()
{
	cin>>n>>m>>k;
	for(int i=1;i<=m;i++)scanf("%lld",&a[i]);
	while(pos<=m)
	{
		used=pos-1;
		int temp=(a[pos]-used+k-1)/k;
		for(;(a[pos]-used+k-1)/k==temp;pos++);
		ans++;
	}
	cout<<ans;
	return 0;
}
```