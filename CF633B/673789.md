## 题目大意

给定一个 $m$，让你求一个 $n$ 使得 $n!$ 末尾刚好有 $m$ 个 $0$。

## 题目分析

首先我们知道，一个数末尾有几个零说明这个数可以被 $10$ 整除几次。

因为 $10=2 \times 5$，并且 $2$ 的个数大于 $5$ 的个数所以我们只要求出 $n!$ 中有几个 $5$ 因数就可以了。

根据公式，在 $n!$ 中包含质因数 $p$ 的个数为：

$$

\lfloor \frac{n}{p^1} \rfloor + \lfloor \frac{n}{p^2} \rfloor+\lfloor \frac{n}{p^3} \rfloor+\lfloor \frac{n}{p^4} \rfloor+...  (p^k\le n)

$$

把公式带到本题当中：尾随 $0$ 的个数为： $\sum_{i=1}^{\lfloor \log_5{n}\rfloor}\lfloor\frac{n}{5^i}\rfloor$。


易得：当 $n=5^k$ 那么尾随的 $0$ 的个数为：
$\frac{n-1}{4} $，
于是我们就可以利用这一性质解决这题。

同时可以发现只要不是无解，那么输出个数必定为 $5$ 个，毕竟每 $5$ 个数才会多一个质因子 $5$。

```
#include<bits/stdc++.h>
using namespace std;
int a[8]={5,25,125,625,3125,15625,78125,390625}; //把5的平方、立方、四次方……都先打在一张表中 
int m,p,_m,cnt=7,n;
//_m来备份m 
//cnt先来枚举a的下标，后来计算因子5的个数 
int main()
{
	cin>>m;
	_m=m;
	while(m!=0)
	{
		if(m>=(a[cnt]-1)/4) //刚才说的 
		{
			m-=(a[cnt]-1)/4;
			n+=a[cnt]; 
		}
		else cnt--; //不够减就往前一个下标 
	}
	p=n; //n用来输出，验算时用p代替
	cnt=0; //i来存储当前因数5的个数 （也就是尾随0的个数） 
	while(p!=0) 
	{
		p/=5; //按照刚才的公式计算因数5的个数 
		cnt+=p;
	}
	if(cnt!=_m) cout<<"0";//与实际情况不相符
	else //有解 
	{
		cout<<"5"<<endl<<n<<" "<<n+1<<" "<<n+2<<" "<<n+3<<" "<<n+4; //把5个数都输出来 
	} 
}
```
