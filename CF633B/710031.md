## 题意

给定一个整数 $m$，计算有多少个满足条件的 $n$，使得 $n!$ 有 $m$ 个后导 $0$。

## 思路

这道题目数据范围较小，只有 $100$ 万，可以暴力枚举每一个阶乘来做。

$10 = 2 \times 5$，所以想要得到一个后导 $0$ 就需要既是 $2$ 的倍数又是 $5$ 的倍数。

在阶乘中 $2$ 因子的数量肯定比 $5$ 的多，所以我们只需要看 $5$ 因子的数量即可。

这里我们可以得出两个结论，等一下会证明：

- $k!$ 的后导 $0$ 的个数等于 $(k - 1)!$ 的后导 $0$ 的个数加上 $k$ 中的因子 $5$ 的个数。
- 只要有解，则满足条件的数量一定为 $5$ 个。

先来证明第一个结论：

因为 $n!$ 相当于 $(n - 1) \times n$，所以 $(n - 1)$ 的后导 $0$ 的个数对于 $n!$ 是不变的。我们之前已经说过，在阶乘中 $2$ 因子的数量肯定比 $5$ 的多，所以我们只需要看 $5$ 因子的数量即可。**特别注意：如果一个数中出现了多个 $5$ 因子，后导 $0$ 的个数就会增加多个。** 例如 $25$ 有两个 $5$ 因子，所以 $25!$ 的后导 $0$ 个数与 $24!$ 的后导 $0$ 个数相比就会增加两个。得证。

再来证明第二个结论：

我们之前提到过，我们只需要看 $5$ 因子的数量，那么只有到达 $5$ 的倍数时，后导 $0$ 的个数才会增加。

举个例子：$5, 6, 7, 8, 9$，只有 $5$ 是 $5$ 的倍数，其他都不是，所以这五个数的阶乘的后导 $0$ 个数是一样的。而到了 $10!$ 之后，后导 $0$ 的个数又增加了（因为 $10$ 也是 $5$ 的倍数），所以 $10$ 之后的阶乘后导 $0$ 个数也不可能会与这五个数的阶乘后导 $0$ 个数相同。大家还可以举几个例子尝试一下。

这两个结论对解题都有很大帮助。

## 方法：

我们可以先分解出每个数的因子 $5$ 的数量，然后再判断累积的因子 $5$ 的数量是否达到 $m$，若达到并且是第一次达到，输出 $5$，换行，然后如果达到，输出这个数。为了节省时间，只要累积因子数超过了 $m$，那么就立刻结束程序，因为数越大，后导 $0$ 的个数就会越多。

最后，如果无解，输出 $0$，结束程序。

其他的小细节都在注释里。

## Code：

```cpp
#include <bits/stdc++.h>
using namespace std;
// m 即题目中的 m，cnt 指累积后导 0 的个数，flag 用来记录是否第一次找到
int m, cnt = 0, x, flag = 1;
int main(){
    scanf("%d", &m);
    for(int i = 1;i <= 500005;i++){
        x = i; // 用 x 来保存 i 的值
        while(x % 5 == 0){ // 分解出因子 5 的个数
            cnt++; // 这里的 cnt 在之前不需要清零，因为后导 0 的个数只会变多
            x /= 5;
        }
        if(cnt == m){ // 判断 i 的阶乘后导 0 的个数是否达到了 m
            if(flag){ // 如果第一次找到，输出解的个数 5，换行
                printf("5\n");
                flag = 0;
            }
            printf("%d ", i);
        }
        if(cnt > m){ // 后导 0 个数超过了 m，立刻结束程序
            return 0;
        }
    }
    printf("0"); // 若无解，输出 0
    return 0; // 结束
}
```