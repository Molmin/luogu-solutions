## 题目大意

给定一个a数组，定义一个b数组，其中$b_i=2^{a_i}$，让你判断b数组中有没有其中两个子串的值相等

ps：原题范围为$n\le 2\times10^5 ,t\le 10^4$,保证$t$组$n$值的和$\le10^6$(貌似),后来改小了数据范围，然后就不计分了（

## 题目思路
这题也是一个结论题

我们看到数据范围$a_i\le10^9$就知道这题肯定不是让我们算出来b数组的值的

我们观察什么情况下才会出现两个子串相等的情况

先通过样例入手

$4\ 3\ 0\ 1\ 2\ 0$

b数组为：

$16\ 8\ 1\ 2\ 4\ 1$

样例解释说16=(8+1+2+4+1) 

的确是这样，但是为什么会出现相等呢？

在a数组中，相等的子串为$4$与$0,0,1,2,3$

我们看到：必须满足连续数字，并且最小的那个要出现两次才行

当然这种规律并不能让我们在原来的数据范围内完成这道题，我们继续探索

当时我想到，这个数组里有没有其他相同的子串呢？

我们从小范围找起，3和0120其实就是一组，是什么导致这两组相等的呢，必要条件其实是**必须有两个相等的数**，换个角度

**这两个相等的数其实就是一组相等子串**

所以不用看有没有连续序列，只要判断有没有相等的数就行了

因为$a_i\le 10^9$，所以没法用桶，只能(nlogn)排序


改小之前的数据范围保证了n的值，所以能过


## 代码
```c++
#include<bits/stdc++.h>
using namespace std;
int a[200005];
inline int read(){
    register int s=0,w=1;
    char ch=getchar();
    while(ch<'0'||ch>'9'){
        if(ch=='-')
            w=-1;
        ch=getchar();
    }
    while(ch>='0'&&ch<='9'){
        s=s*10+ch-'0';
        ch=getchar();
    }
    return s*w;
}
int main(){
	int t;
	cin>>t;
	while(t--){
		int n;
		cin>>n;
		for(int i=1;i<=n;i++){
			a[i]=read();
		}
		sort(a+1,a+1+n);
		bool ans=false;
		for(int i=2;i<=n;i++){
			if(a[i]==a[i-1]){
				ans=true;
				cout<<"YES"<<endl;
				break;
			}
		}
		if(!ans)
			cout<<"NO"<<endl;
	}
}
```