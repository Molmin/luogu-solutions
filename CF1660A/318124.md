题意：给定非负整数 $a, b$，代表有 $a$ 个面值为 $1$ 的硬币和 $b$ 个面值为 $2$ 的硬币。求不能被组合出的最小非负整数。

先给出结论：当 $a \ge 1$ 时，答案为 $2b + a + 1$；当 $a = 0$ 时，答案为 $1$。

后面半部分的结论很好证明，当 $a = 0$ 时，不管 $b$ 是多少，不管如何组合，结果都是 $2$ 的倍数，而 $1$ 是不包括在内的最小非负整数，即为答案。

现在我们来看前半部分。

$0, 2, 4, \cdots, 2b$，即 $2b$ 及以内的非负偶数，都是可以被组合成的。

因为 $a \ge 1$，所以我们可以取一个面值为 $1$ 的硬币加入 $2b$ 及以内的非负偶数，于是构成了 $0 + 1, 2 + 1, 4 + 1, \cdots, 2b + 1$，即 $2b + 1$ 及以内的非负奇数。这些数字都是可以被组合成的。

所以，由此可证，$2b + 1$ 以内所有的非负整数，都是可以被组合成的。

而从 $2b + 1$ 到 $2b + a$，都可以使用面值为 $1$ 的硬币一个一个叠加得到。

于是 $2b + a$ 及以内的所有的非负整数，都是可以被组合成的。并且组合 $2b + a$ 已经花费了所有的硬币，所以 $2b + a + 1$ 就是不能被组合出的最小非负整数。

代码如下。

```cpp
/*Copyright (C) 2013-2024 LZE*/
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
ll T, a, b;
int main() {
    scanf("%lld", &T);
    for(ll i = 1; i <= T; i++) {
        scanf("%lld%lld", &a, &b);
        if(a == 0) printf("1\n");
        else printf("%lld\n", 2 * b + a + 1);
    }
    return 0;
}
```