## [题意](https://blog.csdn.net/BeNoble_/article/details/102906687)

定义函数

$$
f(x)=
\begin{cases}
f(\frac xk)&k\mid x\\
x&k\nmid x
\end{cases}
$$

给你$n$个正整数$(a_1,...,a_n)$和一个$k$，每次可以选择两个$x,y$删去，并把$f(x+y)$加入

问最后剩下的一个数是否是$1$，如果是请输出选数的方案

$2\le n\le16,2\le k\le2000,\sum a_i\le2000$

---

## 题解

注意到$n$范围可以考虑状压$dp$，设$T$为全集

设$f_{s,p}$表示选数集合为$s$和最后的数为$p$的情况是否存在

由于$s$是从小到大枚举的

那么就有$f(s,p)=[\sum_{a_i\in s}f(s-a_i,p-a_i)>1]$

特别的如果$f(s,p\times k)=1$，那么$f(s,p)=1$

这个转移可以使用可以使用$bitset$优化

那么就有（$a_i$在状压里表示就是$2^i$）

```cpp
f[s]|=f[s-(1<<i)]<<a[i]
```
最后只要判断$f(T,1)$是否为$1$即可

这部分的时间复杂度为$O(\frac 1{\omega}n2^n\sum a_i)$

考虑如何使用上述$f$的值来打印方案

限定一个状态$f(s,p)$

>如果可以就从$f(s,pk^t)$转移过来（其中$f(s,pk^{t+1})=0,t\ge1$）
>
>否则就从$f(s-a_i,p-a_i)$转移过来（其中$f(s-a_i,p-a_i)=1,a_i\in s$）

因为$f(s,pk^t)$只能从$f(s-a_i,pk^t-a_i)$转移过来，即一定存在一种方案构造出$pk^t$

而$f(s,pk^r)(r\lt t)$不能保证一定存在一种选数方案

而题目又说输出任意一种方案即可，所以可以稳妥一点地选择$f(s,pk^t)$

那么又如何限制合并的顺序呢？

考虑$f(s,p)$的是由状态$f(s',p')$转移过来的（其中$s'=s-a_i,p'=pk^t-a_i,a_i\in s$）

如果存在$r\ge1$使得$f(s',p'k^r)=1$那么就一定要先将$s'$全部合并完了在与$a_i$合并再得出$f(s,p)$的状态，也就是$s'$的里数要比$a_i$优先选择（理由和上面类似）

那么可以每次从$f(s,p)$到$f(s,pk^t)$时给$s$里的数的优先级全加上$t$

最后优先级越高的越先合并，合并完得到的新数的优先级和取出来的两个数中的优先级最高的数相同

但是如果新数能被$k$整除，那么优先级就要相应地下降

这部分的时间复杂度是$O(n\log n+\frac{\sum a_i}k)$

总时间复杂度$O(\frac 1{\omega}n2^n\sum a_i)$