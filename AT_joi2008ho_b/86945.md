看各位大佬都没有发布题解，那我这个~~躲在角落里颤颤发抖的~~蒟蒻就来发一篇吧。设两个字符串分别为s1、s2，它们的长度分别为len1、len2，可以构造一个长len1、len2的二维矩阵g，用来记录以s1[i]、s2[j]结尾的最长子串长度，然后可以分为三部分：
1. 矩阵赋值：当s1[i]==s2[j]时，g[i][j]=1。
2. 计算子串长度：这里可以用到一种近似于前缀和的思想，当g[i][j]等于1时，就累加上以s1[i-1]、s2[j-1]结尾的最长子串，即g[i][j]+=g[i-1][j-1]。
3. 比较最大值：遍历矩阵，用打擂台的方法求出最大值。

本蒟蒻偷懒了一下，把三个步骤放在一起写了，代码如下：


------------
```cpp
#include<bits/stdc++.h>
using namespace std;
string s1,s2;
int g[4005][4005];//二维矩阵
int main()
{
	cin>>s1>>s2;
	s1='@'+s1;//在字符串前加上一个前置字符
	s2='@'+s2;//方便处理，防止数组越界
	int len1=s1.size()-1;//因为字符串下标从0开始
	int len2=s2.size()-1;//所以要减1
	int maxn=0;
	for(int i=1;i<=len1;i++)
		for(int j=1;j<=len2;j++)
			if(s1[i]==s2[j])
			{
				g[i][j]=1;//1.矩阵赋值
				g[i][j]+=g[i-1][j-1];//2.计算子串长度
				maxn=max(maxn,g[i][j]);//3.统计最大值
			}
	cout<<maxn<<endl;
	return 0;
}
```
