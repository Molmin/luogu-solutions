这是本蒟蒻的第 $39$ 篇题解，AT2418。

-----

本题为初学动态规划的 OIer 的必做题，形式化来讲，这个模型叫“最长公共子序列”，即 $\text{LCS}$。

首先我们来分析这个问题。如何求最长公共子序列呢？你可能会去建立一个四层循环，去枚举两个字符串的 $i,j$ 位置，然后定义函数去判断是否相等，再去与目前的最大值作比较，最后输出。

可是这个方法效率太低了。我们设 $|a|$ 为字符串 $a$ 的长度，$|b|$ 为 $b$ 的长度，那么时间复杂度就是 $\mathcal{O}(|a|^2|b|^2)$。为什么？你定义了两个 $0 \sim |a|$ 的循环，两个 $0 \sim |b|$ 的循环。乘在一起就是 $|a|^2|b|^2$。

有没有更快捷的方法呢？当然有。你在小奥中学过递推吗？OI 中的**动态规划**思想本质上就是递推。我们可以建立一个二维数组，用来存储字符串 $a$ 的 $1 \sim i$ 和字符串 $b$ 的 $1 \sim j$ 这两个子串的最长公共子序列。

怎么求？很简单。判断这个位置上的 $a_i$ 和 $b_j$，

$f(i,j)=\begin{cases}f(i-1,j-1)&a_i \neq b_j\\f(i-1,j-1)+1&a_i = b_j\end{cases}$

也就是判断这个位置上的两个字符是否相等，相等的话 $f(i,j)$ 显然就是上一个点 $f(i-1,j-1)$ 的长度再加 $1$，因为两个字符串的这个点也是相等的。

再优化一下，我们直接在计算出 $f(i,j)$ 之后用一个变量 $lcs$ 去获得目前的最大值。因为最长公共子序列不可能是负数，所以把 $lcs$ 的初值设为 $0$ 就可以了。

这就是动态规划（$\text{DP}$）的奇妙之处，你无需计算每一个点，根据一个推出来的递推公式就可以由前一个点扩展到这个点，从而降低复杂度，使程序运行得更快。

下面在写代码之前，我想明确两个本题的“坑”：

1. 建议在字符串输入后在最前面加一个空格，因为字符串遍历是从 $0 \sim |k|$ 的，如果不加很有可能出现数组越界。
2. $lcs$，$f$ 变量要设成 `short` 类型，否则会 $\text{MLE}$。

然后就是代码了：

```cpp
#include <bits/stdc++.h>
using namespace std;

string a, b;
short f[4001][4001];
short lcs=0; // short

int main(){
    cin>>a>>b, a=' '+a, b=' '+b; // 防止出现-1等奇葩情况
    int al=a.size(), bl=b.size();
    
    for (int i=1; i<al; i++)
        for (int j=1; j<bl; j++)
            if (a[i]==b[j]) f[i][j]=f[i-1][j-1]+1, lcs=max(lcs, f[i][j]); // dp
                
    cout<<lcs<<endl;
    return 0;
}
```

你看，我们使用动态规划后，时间复杂度就由 $\mathcal{O}(|a|^2|b|^2)$  骤降到 $\mathcal{O}(|a||b|)$ 了。

在最后，希望大家都可以把动规学好，~~其实动规学好在有些年份就能拿到 tg1= 了~~。

谢谢大家。