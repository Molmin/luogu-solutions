### 思路分析
这道题目猛一看确实挺吓人的，式子这么长，还带绝对值，绝对不是什么很好做的题目

但是认真分析，我们就可以发现 $k$ 的范围其实很小，$0 \leq 2k \leq n$，前面还带个系数 $2$。

再结合绝对值的性质，分类讨论把这个式子拆开：
- 当 $\sum_{i = 1}^n a_{2i} - a_{2i - 1} > 0$ 时
- - 对于某个 $i$ 满足 $a_{2i} - a_{2i - 1} > 0$，则它的贡献就是$a_{2i} - a_{2i - 1} - (a_{2i} - a_{2i - 1}) = 0$
- - 对于某个 $i$ 满足 $a_{2i} - a_{2i - 1} \leq 0$，则它的贡献就是 $a_{2i - 1} - a_{2i} - (a_{2i} - a_{2i - 1}) = 2(a_{2i - 1} - a_{2i})$
- 当 $\sum_{i = 1}^n a_{2i} - a_{2i - 1} \leq 0$ 时同理

所以我们想要使这个排列满足条件的话,只要**有一个且仅有一个** $i$ 满足它的贡献为 $2k$ 就够了

例如可以按照这样的规律构造：第一个数为 $k + 1$，然后其他的数按从大到小的顺序排列在后面

这样仅有且只有第一位的 $k + 1$ 和第二位的 $1$ 恰好贡献了 $2k$，且 $\sum_{i = 1}^n a_{2i} - a_{2i - 1}>0$

而 $\sum_{i = 1}^n a_{2i} - a_{2i - 1}>0$ 成立是因为后面的 $n - 1$ 个偶数位比奇数位大 $1$，$k + 1$ 比 $1$ 大 $k$，$2k \leq n$ 所以 $k \leq n$

这题就这样结束了~

Code:
```cpp
#include <cstdio>

const int maxn = 1e5 + 5;

int n, k;
int a[maxn];

void sov(int x)
{
    printf("%d ", x + 1);
    for(int i = 1; i <= n * 2; ++i)
    {
        if(i != x + 1) printf("%d ", i);
    }
}

int main()
{
    scanf("%d%d", &n, &k);
    sov(k);
    return 0;
}
```