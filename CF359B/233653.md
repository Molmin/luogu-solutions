## 0.写在前面

本题思路很妙，属于思维题，构造容易想到。本文将要详细讲一讲思维流程。

如果读者嫌本文太长的话，可以直接拉到末尾总结部分。

## 1.题意大致分析

>构造一个长度为 $2n$ 的排列 $A$ ，使得 $\sum_{i=1} ^n |A_{2i}-A_{2i-1}| -|\sum_{i=1} ^n A_{2i}-A_{2i-1}|=2k$ 。

这乍一看确实有点棘手。考虑转化？

设置 $B_i$ 为 $A_{2i}-A_{2i-1}$ ，即求出 $B$ **绝对值的和** 减去  $B$ **和的绝对值？**

显然前半部分 **绝对值的和** 大于等于 **和的绝对值** ，所以不可能取负数。

走到这里就到尽头了？好戏才刚刚开始。

## 2.从特殊情况出发

先判断 $2k=0$ 的情况，毕竟这种情况好一些。

我们观察到如果在每个 $B_i$ 都为**正数**的情况下，那么显然 **绝对值的和=和的绝对值。**

而构造这样一个**递增的序列，答案呼之欲出。直接输出 $1...2n$ 即可，每个 $B_i$ 都等于 $1$ 。**

然而，我们还没处理**一般的情况**。这该如何是好？

因为 $A$ 是一个排列，于是其中的任意交换不会影响排列的性质，于是我们考虑**如何交换**能够刚好构造答案。

我们可以把 $A$ 初始化成 $1...2n$ 。

## 3.走了弯路

当时我考虑**交换相邻两个数** $(A_{2i},A_{2i-1})$，把一个 $B_i$ 从 $1$ 变成 $-1$ 。

对于**整个答案来说**，可以贡献 $2$ 。于是**我当时就考虑交换 $k$ 轮**，这样能保证答案为 $2k$ 。

但是，这个方法**有所问题**。

比如交换太多的数，会导致 $B$ 数组中 $-1$ 的个数太多，这样的话，$B$ 的**绝对值的和**固然是 $n$ ，但是 $B$ **和的绝对值** 会大于 $0$ ！这样就**不能构造正确的答案**了。

从原理上解释，是因为随着交换次数的递增， $B_i$ 的和 $S$ 会递减；但是当 $B_i$ 的和 $S$ 的绝对值会在 $S$ 为负的时候递增。

那么，能不能**增加某一对数的贡献**，避免这种问题呢？换而言之，能不能拉低其中一个 $B_i$ 的绝对值呢？

## 4.走向正解

我们发现一个**显然的性质：如果把一段区间整体挪移一个位置，这段区间对答案的贡献都不变。**

而发生改变的，就是这段区间头和区间头前面的数的贡献。

那么，考虑**拉一个数到前面，计算答案？**

实验实验。比如序列 `1 2 3 4 5 6 7 8` ，把 $3$ 拉到前面，那么这个序列会变成 `3 1 2 4 5 6 7 8` 。

此时我们计算 $B$ 数组，那么 $B$ 数组就变成了 `-2 2 1 1` ，答案变成了 $6-2=4$ 。

如果把 $4$ 拉到前面，这个序列就变成了 `4 1 2 3 5 6 7 8` ，
$B$ 数组即为 `-3 1 1 1` ，答案变成了 $6-0=6$ .

**大胆猜想：把 $k+1$ 拉到前面，会产生 $2k$ 的贡献。**

事实证明，这个是对的。第一个会拉低 $k$ ，有一个地方可能会变成 $2$ （仅限于 $k$ 为偶数），但是答案确实是 $2k$ 。

## 5.总结

可以借助 $B$ 数组做差，辅助推理。

交换不是最终目的，但是是中途历程。

把 $k+1$ 拉到前面就可以产生 $2k$ 的贡献。

```cpp
#include<cstdio>
#define I int
I n,k,i;
I main(){
	scanf("%d%d",&n,&k);
	printf("%d ",k+1);
	for(i=1;i<=n<<1;++i)if(i^(k+1))printf("%d ",i);
	return 0;
}
```