#### 题意简述
两个 $01$ 序列，有若干位为 $?$，$?$ 表示可以填 $1$，又也可以填 $0$，将相邻两个值相同的位置取反定义为一次操作，使 $s$ 和 $t$ 相同的最小操作次数定义为两个序列的距离，求两个序列所有可能情况的距离之和。
#### 题意分析
第一次碰到这种题目，肯定会无从下手这时我们不妨仔细分析题目给的条件，我们先考虑一次操作的影响，考虑如下序列：

- …… 正正 ……

操作后变为：

- …… 反反 ……

似乎没有什么突破口，这时我们再将偶数位取反：

- …… 正反 ……
- …… 反正 ……

我们惊奇的发现交换之后这两位是相同的，所以我们可以得出一个结论：两个序列偶数位取反后，对一序列相邻位的交换操作等价于原来对一序列的相邻相同位的取反操作。这时我们将原问题简化为先将 $s$ 和 $t$ 的偶数位取反，求交换相邻位使 $s$ 和 $t$ 相等的次数和。

有一定做题量的同学应该能意识到这是一道经典的逆序对应用，典型例题是[火柴排队](https://www.luogu.com.cn/problem/P1966)，不过题目限定了每一位的取值范围，只能取 $0$ 或 $1$，这将问题求解大大简化，我们不必再求逆序对，而是贪心的考虑，$s$ 中第 $i$ 个 $1$ 一定是跟 $t$ 中的第 $i$ 个 $1$ 匹配，若不是，要么 第 $i$ 个 $1$ 绕路，要么其它的 $1$ 绕路，若是第 $i$ 个 $1$ 绕路，路线产生了交叉，一定不优，若其它的 $1$ 绕路，那么路线产生了覆盖，一定更不优，因此我们得到了最小次数的式子 $\sum_{i=1}^n |x_i-y_i|$，但是这样考虑不方便转移，我们再考虑转换。

在上述方法中，我们以序列为对像，一次跑一遍，我们能不能做到一次跑完所有呢。（这里的思考方向有点像 Dinic，都是将一次的信息利用最大化）答案是可以的，我们将 $i$ 到 $i+1$ 的交换当作研究对像，我们考虑 $i$ 和 $i+1$ 一共要交换多少次，这比较好想，就是 $s$ 中前 $i$ 位 $1$ 的数量与 $t$ 中 前 $i$ 位 $1$ 的数量的差的绝对值。因此，答案又可以表示位 $\sum_{i=1}^n|cnts_i-cntt_i|$。

这样我们就可以比较方便的在这个式子的基础上进行转移，我们设 $pre_{i,j}$ 表示两序列前 $i$ 个，$1$ 的个数差为 $j$ （不含绝对值）时交换次数之和，$nxt_{i,j}$ 表示后 $i$ 个，$1$ 的个数差为$j$ 时的交换次数之和，由乘法原理易知答案为前后缀方案数相乘，所以式子显然：
$$ans=\sum_{i'=1}^i\sum_{j=-i}^ipre_{i,j}·nxt_{n-i+1,-j}$$
$pre$ 和 $nxt$ 可以在移位时由当前位更新。
#### 代码
```cpp
const int N=2002;
char s[N],t[N],len;
int pre[N][N<<1],nxt[N][N<<1];
inline bool chk(char a,int b){return (a=='?'||a==b+'0');}
signed main(){
	//file();
	int T;scanf("%d",&T);
	while(T--){
		int n;scanf("%d%s%s",&n,s+1,t+1);
		int a=0,b=0;
		pre[0][N]=nxt[n+1][N]=1;
		rep(i,0,n-1) rep(j,-i,i)
		    if(pre[i][j+N]) rep(x,0,1) rep(y,0,1)
		        if(chk(s[i+1],x^(i&1))&&chk(t[i+1],y^(i&1)))
		            pre[i+1][j+x-y+N]=add(pre[i+1][j+x-y+N],pre[i][j+N]);
		per(i,n+1,2) rep(j,i-n-1,n-i+1)
		    if(nxt[i][j+N]) rep(x,0,1) rep(y,0,1)
		        if(chk(s[i-1],x^(i&1))&&chk(t[i-1],y^(i&1)))
		            nxt[i-1][j+x-y+N]=add(nxt[i-1][j+x-y+N],nxt[i][j+N]);
		int ans=0;
		rep(i,1,n) rep(j,-i,i) ans=add(ans,1ll*pre[i][j+N]*nxt[i+1][-j+N]%mod*abs(j)%mod);
		cout<<ans<<endl;
		rep(i,0,n+1) rep(j,0,N*2-1) pre[i][j]=nxt[i][j]=0;
	}
    return 0;
}
```
#### 总结
这题有两个很经典也很套路的转换，应当反复思考，体会其中的巧妙，在这里推荐[一道题目](https://www.luogu.com.cn/problem/AT2046)，是这题的拓展，将这题的序列变为了树和基环树，可以借此加深自己对这两个技巧性转换的理解。