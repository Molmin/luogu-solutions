看到大家用的都是二/三/四分法，我就来写一篇优选法的题解。

优选法由美国数学家J·基弗提出，由我国数学家华罗庚推广，将其投入实际生产应用中，为提高产量作出了巨大贡献。

但是，很多讲解优选法的论文都是错的，包括唯一一篇讲解了优选法的集训队论文（2005杨思雨《美，无处不在——浅谈“黄金分割”和信息学的联系》）。本题解参考了华教授的《优选法》，旨在向大家推介正确的优选法。

1.优选法可以做什么？

可以用来求解最优化问题，例如单峰函数的极值。

2.如何实现优选法？

（为了叙述的简便，我们假定要计算的区间是[0,1]）

Step1:先在(3-sqrt(5))/2和(sqrt(5)-1)/2处求值。

Step2:如果左边小就将左端点移至(3-sqrt(5))/2，假设这是在用三分法，我们还要再求出区间[(3-sqrt(5))/2,1]的两个计算点，但是优选法不用了，因为区间[0,1]的右计算点和区间[(3-sqrt(5))/2,1]的左计算点重合了。如果右边小，是同理的。

Step3:重复Step2直至左端点和右端点相差不超过最小误差。


3.为什么三分法不如优选法优秀？

最优秀的三分法两个计算点应当取在区间中点的两侧且尽量接近区间中点，这样计算两次就几乎可以将区间缩小一半，但是这两次计算的结果几乎不可能被后面的操作利用；而优选法可以将计算的结果为后面所用，节省了计算次数。

4.在本题中，三分法和优选法分别要计算几次？

最坏情况下区间是[-10,10]的，三分法要计算log(2,1000000)*2=40次，优选法则要计算log(1.618,1000000)=28次，比三分法少。大家看传统题的常数可能没有感觉，但是当限制查询次数的交互题出现时，优选法就派上用场了。

5.杨思雨的论文错在哪？

她的论文中写“这样（指三分）一次可以舍去整个[a,b]的将近50%，但是接下来每次只能舍去很小的一部分了，反而不利于较快地逼近最优点”，如果三分的要害真的只是这样，那优选法难道不是每次只能舍去[a,b]的不到40%？那华教授推广优选法，倒不如推广三分法？这个理由显然略显牵强。

长话短说，优选法的确是到目前为止求解单峰函数最高（低）点的最快算法。

代码：

```
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<string>
#include<algorithm>
#include<math.h>
using namespace std;

const double eps=1e-7;
const double gol=(3-sqrt(5))/2;//0.382...
const double gor=(sqrt(5)-1)/2;//0.618...
int n;
double l,r,t,tx,ty,sx,sy,a[15];

double sum(double x)
{
	int i;
	double ret=0;
	for(i=n;i>-1;--i)
		ret=ret*x+a[i];
	return ret; 
}

int main()
{
	int i;
	scanf("%d%lf%lf",&n,&l,&r);
	for(i=n;i>-1;--i) scanf("%lf",&a[i]);
	tx=l*gor+r*gol,ty=l*gol+r*gor;
	sx=sum(tx),sy=sum(ty);
	while(fabs(l-r)>eps)
	{
		if(sx<sy)
		{
			l=tx;
			tx=ty;
			sx=sy;//避免重复计算
			ty=l*gol+r*gor;
			sy=sum(ty);
		}
		else
		{
			r=ty;
			ty=tx;
			sy=sx;//避免重复计算
			tx=l*gor+r*gol;
			sx=sum(tx);
		}
	}
	printf("%.5lf\n",r);
	return 0;
}
```