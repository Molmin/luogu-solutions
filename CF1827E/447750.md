给定一棵 $n$ 个点的树以及 $m$ 条路线，一条 $x$ 到 $y$ 的路线允许树上 $x$ 到 $y$ 路径上的点互达，判断树上任意两点是否能通过至多两条路线互达，如果不能，找到一组不符合要求的点对。

$\sum n,\sum m\leq 5\times 10^5$，2.5s。

叶子的限制强于其它点，所以只用考虑叶子是否满足条件。这么做可以让每条路线的限制可以只在端点处考虑。

对于叶子 $u$，找出以它为端点的所有路线，这些路径对应点集的并就是 $u$ 能一步到达的点，记为 $S_u$，这是一个包含 $u$ 的连通块。那么问题转化为判断任意叶子 $u,v$，是否有 $S_u\cap S_v\neq \varnothing$。

注意到连通块的交仍然是连通块，而连通块满足点数等于边数加一，那么可以用点减边容斥得到每个 $S_u$ 与多少个 $S_v$ 有交。现在需要处理的问题只有连通块加以及连通块求和。

注意到虚树结构（点集中任意两点的 LCA 也在点集中）满足其在原树上的 dfs 序即为一种欧拉序，也就是每条边恰好被经过两次，于是把这些点拉出来执行链加链求和就可以做到 $O(n\log^2n)$，但是实际上可以一起树上差分，复杂度瓶颈只有 LCA，可以做到 $O(n\log n)$。

最后处理找点对的问题，只需要找到一个不和所有叶子连通块有交的点，对每个叶子判和它是否有重合点，也可以树上差分。[Submission](https://codeforc.es/contest/1827/submission/206061492)