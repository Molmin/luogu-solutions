没人来啊？这么简单的暴力枚举……

题意：找出大于 $a$ 的最小整数 $c$，使 $c$ 从最高位到最低位的所有 $7$ 和 $4$ 拼起来的数等于 $b$，$1\le a,b\le 10^5$。

先说下我推出的时间复杂度：$O(n\log_{10}n)$，$n<2\times 10^6$。

考虑构造一个数 $d$，在 $b$ 的最高位前添上 $1$，得到数 $d$，显然 $d$ 的 mask 是 $b$。反复在 $d$ 前面添上 $1$，直到 $d>a$。

因为 $a\le 10^5$，所以得出 $a < d<2\times 10^6$ 这个 $d$ 的范围（最坏情况或许是 $b=777777$，此时 $d=1777777$，没到 $2\times 10^6$），那么 $a<c\le d$，得出枚举范围。

求 mask 就是反复取最低位，是 $4$ 或 $7$ 就记录一下，然后舍去最低位。

求一个数的 mask 时间复杂度为 $O(\log_{10}n)$，比较的复杂度为 $O(1)$，总体来说是 $O(n\log_{10}n)$，不会超的……

贴代码（看注释）:

```cpp
#include <bits/stdc++.h>
using namespace std;
int a, b;
int Make(int x){//求一个数的 翻转后的 mask
    int ans=0;
    while(x>0){
        if(x%10==4||x%10==7)//我为什么要用时间换空间(因为取模是O(1)的运算?)
            ans = ans*10+(x%10);//发现没，mask 翻转了一遍，不影响，我也不想改，因此有了下面的语句
        x /= 10;
    }
    return ans;
}
int main(){
    cin >> a >> b;
    int bt = Make(b);//所以有了这一句
    for(int i=a+1;;i++){//没有终止条件，退出全靠下面的 break
        int t = Make(i);
        if(t==bt){//根据上面的分析，可以在一定的范围内找出 c(程序中的 t)
            cout << i << endl;
            break;
        }
    }
    return 0;
}
```

难度大约是橙？