[推销博客](https://foreverlasting1202.github.io/2019/08/16/APIO2019%E8%B7%AF%E7%81%AF/)

一道奇形怪状的线段树分治+线段树的奇怪题。
<!--more-->

我的思路好像有点奇怪。

拿到题目，直观的想法应该是直接维护这个序列。于是，就有了一种大暴力，考虑用树状数组维护单点修改和区间查询，然后每次暴力从$1$的时刻查询到$now$时刻，判断$sum[l,r]==r-l+1$即可，这样的复杂度是$O(n^2logn)$。

有没有其他办法呢？我想到了线段树分治。把单点修改扔到线段树上，然后询问看做是时间轴$[1,now]$的区间查询，也丢到线段树上，用线段树分治去维护。这样可不可行呢？

在开始，我以为再用个树状数组维护一下，再在递归回来的时候撤销一下就好了。然而这样子样例都过不了。冷静一分析，你会发现时间轴的区间$[1,now]$可能是若干个连续的区间拼凑成的，而这若干个区间的贡献却是不一的，不能直接当$1$算，这下就麻烦了。

正常人可能到了这里就会放弃线段树分治了，然后我却脑抽地继续坚持了下去。我们想想看一个点反转后，对于其他的贡献会是怎么样的。一些与这个点无关的区间若是满的（我们称一个区间为满的即这个区间全是$1$）则加上当前反转与上次反转的时间差。有了这个想法的那一刻，我突然想起了$ZJOI2019$的线段树，发现两道题其实有异曲同工之妙。于是这道题就有了这个奇怪的做法。

在线段树分治加入修改操作的时候，你维护一棵线段树，每个结点维护该结点所表示的区间满的时候的区间，这个东西是可以类似懒标记的想法下传的，所以是$log$级别的。在修改的时候，除了修改的这一条链以外，其他地方你再下传个当前时间减去上次修改时间的加法标记，表示又多了这么多的贡献。每个结点你再维护个$sum[rt]$表示当前节点所代表区间的$1$的数量，$su[rt]$表示历史上总共的答案，这一系列的东西都是可以在$pushup$和$pushdown$的时候维护出来的。查询操作就是正常的区间查询，然后你再利用启发式合并的思想合并所表示的区间满的时候的区间这个信息，保证这个合并过程也在了两个$log$的复杂度。总时间复杂度$O(nlog^3n)$。

~~实际上，如果想到将$(a,b)$看做二维坐标上的点对的话，不仅好写，而且复杂度更优。~~

~~以上均为口胡，有错误请指出。~~