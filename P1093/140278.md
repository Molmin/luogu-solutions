
### 题目描述
某小学最近得到了一笔赞助，打算拿出其中一部分为学习成绩优秀的前5名学生发奖学金。期末，每个学生都有3门课的成绩:语文、数学、英语。先按总分从高到低排序，如果两个同学总分相同，再按语文成绩从高到低排序，如果两个同学总分和语文成绩都相同，那么规定学号小的同学 排在前面，这样，每个学生的排序是唯一确定的。

任务：先根据输入的3门课的成绩计算总分，然后按上述规则排序，最后按排名顺序输出前五名名学生的学号和总分。注意，在前5名同学中，每个人的奖学金都不相同，因此，你必须严格按上述规则排序。例如，在某个正确答案中，如果前两行的输出数据(每行输出两个数:学号、总分) 是:

7 279

5 279

这两行数据的含义是:总分最高的两个同学的学号依次是7号、5号。这两名同学的总分都是 279 (总分等于输入的语文、数学、英语三科成绩之和) ，但学号为7的学生语文成绩更高一些。如果你的前两名的输出数据是:

5 279

7 279

则按输出错误处理，不能得分。


------------

### 解析：暴力出奇迹


------------
这个题解应该算是比较简单易懂的了

毕竟暴力谁都会

只要记住每次的冒泡排序三个变量都要交换就行了

注意：本代码排序时采用从小到大排序，如果想要颠倒过来，舒服一点，就可以把程序中">"变成"<","<"变成">"。

核心代码：冒泡暴力
```
for(int i=1;i<=n;i++)//开始冒泡
	{
		for(int j=1;j<=n-i;j++)
		{
			if(sum[j]>sum[j+1])//一级比较
			{
				swap(sum[j],sum[j+1]);//这个可以实现两个数的交换
                swap(num[j],num[j+1]);//记住三个变量都要交换
                swap(y[j],y[j+1]);
			}
			else
			{
				if(sum[j]==sum[j+1])//二级比较
				{
					if(y[j]>y[j+1])//三级比较
					{
						swap(sum[j],sum[j+1]);
                		swap(num[j],num[j+1]);
                		swap(y[j],y[j+1]);
					}
					else
					{
						if(y[j]==y[j+1])//四级比较
						{
							if(num[j]<num[j+1])//五级比较
							{
								swap(sum[j],sum[j+1]);
                						 swap(num[j],num[j+1]);
                				swap(y[j],y[j+1]);
							}
						}
					}
				}
			}
		}
	}
```
不说了

上完整代码
```
#include<iostream>
using namespace std;
int main()
{
	int y[1000]={0},sum[1000]={0},num[1000]={0},n;//语文、总分、序号
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		int x,z;//因为数学和英语成绩不需要单独加入排序，所以不用用数组
		cin>>y[i]>>x>>z;//输入
		sum[i]=x+y[i]+z;//累计总分
		num[i]=i;//记录序号
	}
	for(int i=1;i<=n;i++)//冒泡排序，详细见核心代码
	{
		for(int j=1;j<=n-i;j++)
		{
			if(sum[j]>sum[j+1])
			{
				swap(sum[j],sum[j+1]);
                swap(num[j],num[j+1]);
                swap(y[j],y[j+1]);
			}
			else
			{
				if(sum[j]==sum[j+1])
				{
					if(y[j]>y[j+1])
					{
						swap(sum[j],sum[j+1]);
                		swap(num[j],num[j+1]);
                		swap(y[j],y[j+1]);
					}
					else
					{
						if(y[j]==y[j+1])
						{
							if(num[j]<num[j+1])
							{
								swap(sum[j],sum[j+1]);
                				swap(num[j],num[j+1]);
                				swap(y[j],y[j+1]);
							}
						}
					}
				}
			}
		}
	}//排序结束
	for(int i=n;i>=n-4;i--)//因为采用从大到小排序，所以倒着输出
	{
		cout<<num[i]<<' '<<sum[i]<<endl;//完美输出
	}
	return 0;
 } 
```
想要查看更多题解，可以关注[我](https://www.luogu.org/space/show?uid=140278)，到[我的博客](https://www.luogu.org/blog/henyouxiudewxb/)里看一看噢：-）