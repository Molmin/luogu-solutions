# 0x00 思路
先看题。
>Johnny 仍然没有购买任何机器。他去了一家计算机商店，收到了一个包含所有 $n$ 台可用的计算机的清单。每台计算机都可以用三个属性描述：处理器内核数 $c_i$，时钟频率 $f_i$ 和价格 $v_i$。这样的计算机包含 $c_i$ 个**独立**的内核，所以他们**可以被分配不同的任务**。

>当客户订购资源时，她会指定所需的内核数 $C_j$ 和**最小**的时钟频率 $F_j$。订单还包含客户愿意支付的价格 $V_j$。如果接受订单，Bytecomp 需要提供客户所需计算能力的独占访问权。Johnny 需要选择 $C_j$ 个核心（**可能来自不同的计算机**），且它们的**时钟频率至少**为 $F_j$，**这些核心不能被分配给其它订单**。

>帮助 Johnny 赚**尽可能多**的钱：接受一个最优的**订单子集**，选择所有计算机的**一个子集**来满足所有接受了的订单。**你的目标是最大化利润，即为客户提供计算能力的收入与购买计算机的成本之差**。

那么，对于所有操作（无论是买计算机还是接受订单）都有两种操作：买（接受）或是不买（不接受）。那么我们很容易想到这些操作是非黑即白的，所以这是一个典型的 01 背包。

既然是背包，那么就需要两个东西：定义状态和状态转移方程。

# 0x01 前置
但是，在这个时候我们发现不好操作状态，所以需要再次读题。

接着，我们可以发现这两个操作是有相似点的。

为什么呢？

因为它们都有 $3$ 个参数，而且它们的参数表达的含义差不多，所以我们可以把这两个操作变为一个操作。

但是由于买电脑是支出，订单是收入，所以买电脑的价格应该取相反数。

而且由于在这里面最重要的是时钟频率，所以我们应该用时钟频率从大到小排序（因为越大越有用），在时钟频率相同时应该用价格小的排在前面（你总应该先买电脑吧……）。

# 0x02 定义状态
定义 `d[i][j]`：表示在前 `i` 个选择订单和电脑后剩下 `j` 个内核所获得的最大利润。当然，既然要最大，而且有负数，所以应该把 `d[i][j]` 赋极小值。

# 0x03 状态转移方程
当然，由于这里是两种不同的东西放在这里，所以我们也应该用不同的方式处理它们。

- 当 $v_i<0$ 时，说明是电脑。我们假设此时我们有 $j+c_i$  个内核，那么由于我们可以选择买或不买，所以 `d[i][j+c[i].c]=max(d[i-1][j+c[i].c],d[i-1][j]+c[i].v)`。

- 当 $v_i>0$ 时，说明是客户。我们假设此时有 $j$ 个内核，那么由于我们可以选择接或不接，所以 `d[i][j]=max(d[i-1][j],d[i-1][j+c[i].c]+c[i].v)`。

最后全部走一遍，找最大值即可。

# code
**不开 `long long` 见祖宗！！！**

```c++
/*众所周知，01 背包是可以压缩的，所以我们可以把第一维省略掉。*/
#include<bits/stdc++.h>
using namespace std;
typedef struct Bytecomp
{
	long long cor,fre,pri;//c,f,v
}BYTE;
BYTE com[4005];
bool cmp(BYTE a,BYTE b)
{
	return a.fre==b.fre?a.pri<b.pri:a.fre>b.fre;
}
long long d[1000005],x;
int main()
{
	int n,m,i,j;
	scanf("%d",&n);
	for(i=1;i<=n;i++)
		scanf("%lld %lld %lld",&com[i].cor,&com[i].fre,&com[i].pri),com[i].pri*=-1;
	scanf("%d",&m);
	for(i=1;i<=m;i++)
		scanf("%lld %lld %lld",&com[i+n].cor,&com[i+n].fre,&com[i+n].pri);
	sort(com+1,com+1+n+m,cmp);
	memset(d,128,sizeof(d));
	d[0]=0;
	for(i=1;i<=n+m;i++)
	{
		if(com[i].pri<0)
		{
			for(j=x;j>=0;j--)//x为假设我买了所有电脑然后没有买任何核心的核心总数
				d[j+com[i].cor]=max(d[j+com[i].cor],d[j]+com[i].pri);
			x+=com[i].cor;
		}
		else
			for(j=0;j<=x-com[i].cor;j++)
				d[j]=max(d[j],d[j+com[i].cor]+com[i].pri);
	}
	long long ans=0;
	for(i=0;i<=x;i++)
		ans=max(ans,d[i]);
	printf("%lld",ans);
	return 0;
}
```