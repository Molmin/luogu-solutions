本题中要处理字符串输入的话，有以下三种方法：

【方法$1$：用一个$int$保存（推荐指数：☆☆）】

用一个$int$保存的话，占用空间少，看起来方便，但处理起来较为麻烦。如果要如此的话，还需要再新建一个保存数码为$1$的个数的变量。然后当这个数大于$0$的时候，每一次如果这个数求余$10$为$1$就加$1$，并逐个保存位置。

【方法$2$：用$char*$保存（推荐指数：☆☆☆☆）】

可以直接使用$gets$输入并$[0,|s|)$计算'$1$'的个数（$s$为该字符串，$|s|$为字符串$s$的长度）。但是这样容易出错，因为第一行与第二行之间的换行必须考虑到。

【方法$3$：用$scanf($"$\%1d$"$,a[i]);$的格式输入（推荐指数：☆☆☆☆☆）】

这种方式我们平常使用不多——用这种方法可以有效输入一位数。

当然必须注意文件输入和输出（$CF$的很多题目都有这个规定，而且很多时候不提示——好处就是能模拟考试，但坏处就是在平时容易忽略，无缘无故地$WA$）。

这个解决了，这道题目基本上就解决了。

$AC$代码[（本蒟蒻记录）](https://www.luogu.com.cn/record/31180383)：

```cpp
#include<cstdio>
int n,i,x,y,pos[101],seq[101];//pos保存位置，seq保存数列
int main()
{
    freopen("input.txt","r",stdin);
    freopen("output.txt","w",stdout);//这两行不能忘写
    scanf("%d",&n);
    for(i=1;i<=n;i++)
    {
        scanf("%1d",&seq[i]);//每次输入一位数字
        if(seq[i])pos[++x]=i;//pos数组更新
    }
    y=pos[2]-pos[1];//距离初始化为pos[2]-pos[1]
    for(i=2;i<x;i++)
    {
        if(pos[i+1]-pos[i]-y)
        {
            printf("NO");//只要有一个距离不同就输出NO并结束程序
            return 0;
        }
    }
    printf("YES");
}
```