小白教程-从零开始认识这道题。

之前两位大佬已经将思路讲得很完整了，只是有一些具体的实现没有讲得很全，只在其代码中有体现。所以我在此做一篇主攻实现的题解。

**本题的思路**

先用 **DFS序** 将整棵树转化成一个序列(我们用 $dfn[x]$ 表示 $x$ 的DFS序，用 $low[x]$ 表示 $x$ 的子树中(含 $x$ ) $dfn$ 最大的点的 $dfn$)，用颜料数( $10^5$ )个 $set$ 维护被染上每种颜色的 **区间** (为了方便查询，此处存储的区间是反的，即 $set$ 里面的元素的 $first>second$ )，再开两个树状数组 $c1,c2$。查询时分为两部分，即 $x$ (含义如题中所示)祖先对查询的影响(也就是整棵被查询子树都被染上的颜色)与子树内部节点对查询的影响。

**本题的具体实现**

每一个 $set$ 维护的区间要保证不出现包含关系，也就是不会出现一个 $set$ 中出现两个 $pair\ p1,p2$ 满足 $p1.first<p2.first\ \&\ p1.second>p2.second$ ，这样我们在查询时才可以做到不重不漏。关于如何做到这一点，我们可以在每次插入时 $lower\_bound(p),$ 其中 $p.first=dfn[x],p.second=0$ 。如果我们搜出来的区间 **包含** 我们将要插入的区间，那么我们直接略过此次修改；如果我们搜出来的区间 **被包含于** 我们将要插入的区间，那么我们 **撤销** 那次操作的 **所有影响** ，并**继续搜索**直到搜出来的区间与我们将要插入的区间不交为止，并 **插入** 本个区间并添加其影响。

关于影响：

我们用 $c1$ 来 **差分维护** 每个节点的 **总颜色数**(比如第一次染了节点 $x1$ ，那么就在 $c2$ 的 $dfn[x1]$ 节点上加上 $1$ 的数值，在 $low[x1]$ 节点上加上 $-1$ 的数值)，用 $c2$ 来维护(普通维护)每个节点目前所做的 **贡献** (比如第一次染了节点 $x1$ ，那么就在 $c2$ 的 $dfn[x1]$ 节点上加上 $low[x1]-dfn[x1]+1$ 的数值)

查询时，我们只需查询 $c1$ 中 $1-dfn[x]$ 的部分(设为 $ans1$ )与 $c2$ 中 $dfn[x]+1-low[x]$ 的部分(设为 $ans2$ )，那么最终答案就是 $ans1 \times (low[x]-dfn[x]+1)+ans2$ ，**记得取模**。