 _ **~~这题在NOI2018中可以算是最难的题目了。蒟蒻当然做不来，仅仅是转发一下官方题解。~~**_ 
## 题意简述
 - 给出一个 $n$ 个点的树，每条边上有非负边权
 - 再给出 $m$ 条树上的链，用端点表示，每条链都有价值
 - 要求选出两条链，满足这两条链**至少有一条边相交**
 - 最大化选出的**链的权值和** + 被**至少一条链覆盖**的边的**边权和**
 - 一个测试点可能有很多组数据，$n\leq 50,000$、$m\leq 100,000$
 - 测试点内的 $n$ 和 $m$ 的和的数量级达到 $10^{6}$
 - 时间限制 $8$ 秒，空间限制 $512$ MB
 
## 大暴力
 - 测试点 $1$、$2$、$3$ 数据范围非常非常非常小
 - 可以枚举两条链，到树上去统计覆盖的边
 - $O(nm^{2}) = 15'$
 
## 聪明的暴力
 - 测试点 $1$、$2$、$3$、$4$ 数据范围有点小
 - 考虑在枚举链的时候加优化
 - 枚举第一条链，把每条边的权值 $w(e)$ 改成 $↓$
 - $w'(e) = [e$在第一条链上$]w(e)$并预处理求出树上距离的数据结构
 - 然后枚举第二条链求树上距离，注意判断是否相交
 - $O(nm) = 20'$
 
 
 ## 真·暴力
 - 仔细观察数据范围
 - 我们相信出题人为了卡乱搞，不会卡暴力
 - 于是只枚举有公共部分的链
 - 注意使用树链剖分求 LCA 来减小常数
 - 可以通过测试点 $1,2,3,4,7,8,9,10,11,12,17$
 - $55'$
 - 加上一条链的情况可以 $65'$
 ![luogu](http://wx3.sinaimg.cn/mw690/0060lm7Tly1fukuinl96qj30e10n8dhi.jpg)


 ## 基于迭代的乱搞♂
 - 前一个暴力中，我们事实上是求出了"确定了一条链后的最大答案"
 - 不难直接把这个过程改成乱搞♂
 - 随机取若干条链分别求答案取 $max$
 - 随机若干次，每次取一条链，找另一条链使得两条链答案最大，然后从另一条链出发执行操作，迭代多次并在每一步更新答案
 - 把链按照 {链代价，链长度，链经过边数} 的 {$-1,0,1$} 的系数组合排序，对前面一些链求出这些链的答案
 - 构造数据时，只需要保证每条链的答案接近，这样就能让链交部分的影响扩大到极致，从而卡掉所有这样的迭代乱搞♂
 - $\leq 30'$
 
## 链的数据
- 测试点 $4,5,6$ 中，树是一条链
- 从而每条链都是一个区间
- 枚举一条链后，直接用线段树维护即可
- $O(m$ $log$ $n) = 15'$

## 边权为 $0$
- 测试点 $4,5,6$ 中边权为 $0$
- 只需要两条链的权值和最小，链只要相交即可
- 枚举一条边，求所有经过这条边的链的最大值和次大值，用他们的和更新答案
- 求经过一条边的链可以用树上差分 + 启发式合并/可并堆完成
- $O(m$ $log$ $n) = 15'$

## 基于边的乱搞♂
- 这一个暴力同样也可以改成乱搞♂
- 对每条边求出经过它的按 {链代价，链长度，链经过边数} 的  {$-1,0,1$} 的系数组合排序的前若干大，两两之间求答案
- 然而，前面的构造方法同样可以把这个乱搞♂卡的痛不欲生
- $\leq 35'$

## LCA 两两不同 $(S_{1})$
- 对于 LCA 不同的两条链，两条链的交必然是直上直下的一段
- 因此可以把一条链拆成两条直上直下的链考虑
- 在树上枚举较下的交点 ($\color{red}\colorbox{white}{红点}$)
- 要求两条链的下端点必须在$\color{red}\colorbox{white}{红点}$的不同儿子子树中
- 长度和 + 权值和 - $\color{red}\colorbox{white}{红点}$深度 + $max$($\color{green}\colorbox{white}{绿点}$深度, $\color{blue}\colorbox{white}{蓝点}$深度 )
- 于是可以想到对每个点记 $f(i,j)$
- 下端点在 $i$ 子树内，上端点深度为 $j$ 的最大的链长度 + 权值
- 用启发式合并或线段树合并维护这个数组，$O(m$ $log$ $n) = 30'$
![luogu](http://wx4.sinaimg.cn/mw690/0060lm7Tly1fukvjr8uamj306708yq34.jpg)


## LCA 全部相同 $(S_{2})$
- 对于这一部分数据，两条链的交可能不是直上直下的
- 关键性质 : 链并的两倍 = 两条链长 + $\color{blue}\colorbox{white}{蓝点}$距离 + $\color{green}\colorbox{white}{绿点}$距离
- 那么可以考虑枚举$\color{red}\colorbox{white}{红点}$，即$\color{blue}\colorbox{white}{蓝点}$的 LCA
- 要求两个$\color{blue}\colorbox{white}{蓝点}$属于$\color{red}\colorbox{white}{红点}$不同儿子的子树
- 这时候要考虑$\color{green}\colorbox{white}{绿点}$的距离
- 如果仍然用深度减去 LCA 深度考虑，无从下手
- 事实上可以**强行树链剖分**套线段树维护，但这样太难写
- 但我们是要最大化$\color{green}\colorbox{white}{绿点}$的距离，可以直接从$\color{green}\colorbox{white}{绿点}$的**最远点对**入手
![luogu](http://wx1.sinaimg.cn/mw690/0060lm7Tly1fukvljd5ipj30bf06twev.jpg)
- 枚举$\color{red}\colorbox{white}{红点}$之后，我们的任务是 $↓$
- 选出两个属于$\color{red}\colorbox{white}{红点}$不同儿子子树的$\color{blue}\colorbox{white}{蓝点 a,b}$
- 使得它们对应$\color{green}\colorbox{white}{绿点}$ $p_{a},p_{b}$ 的距离 + 两条链链长和权值和 + 两个$\color{blue}\colorbox{white}{蓝点}$深度 $-$ $2$ $×$ $\color{red}\colorbox{white}{红点}$深度最大

- 注意到$\color{red}\colorbox{white}{红点}$深度是常数无需考虑
- 对于其他项，可以通过添加附加点 $p_{a}',p_{b}'$ 向 $p_{a},p_{b}$ 连接边权为自己所在链长 + 权值的边，转化为找**最远点对** $p_{a}',p_{b}'$
- 要求支持集合合并
- 在合并的时候，求出跨越两个集合的最远点对
![luogu](http://wx3.sinaimg.cn/mw690/0060lm7Tly1fukvsbgxmuj30cp07kq3c.jpg)
- 对于非负边权的树，两个点集的并的最远点对的一端，一定是原来两个点集中，某个点集的最远点对的一端，一定是原来两个点集中，某个点集最远点对的一端
- 只需要对点集记录最远点对端点，即可支持合并
- 这个算法只需要在树上进行 DFS，以及求 $m$ 次的 LCA
- $O(n+m) = 20'$

## 满分算法
- 两条相交的链，要么 LCA 相同，要么 LCA 不同
- 对于 **LCA 不同**的**所有情况**已经可以处理了
- 对于 **LCA 相同**的情况，考虑**同时处理**以每个点为两条链的共同 LCA 的情况
- 对每个点 $p$ 记录 $f(p,j)$ 表示在点 $p$ 处理 **LCA 为 $j$ 时**保存的$\color{blue}\colorbox{white}{蓝点}$的集合（记录的是最远点信息）
- 对 $f$ 数组进行启发式合并，复杂度 $O(n + m$ $log$ $n)$
- 也可以进行点分治，考虑所有过重心的链，转化为全过一个点的情况，复杂度 $O(n$ $log$ $n+m$ $log$ $n)$
- $O(n + m$ $log$ $n)=$ $\color{green}\colorbox{white}{100}$ $'$ 