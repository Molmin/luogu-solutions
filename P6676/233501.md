## 分析：
对于同一位置放同样拼图的情况，放 $a_i$ 值较小的解更优，所以需要对同一种类的拼图按照 $a_i$ 的值从小到大进行排序。

当前放置什么样的拼图与前一个拼图的右端的凸凹情况有关。也就是说：当上一块拼图为第 $1$、$3$、$5$ 种时，当前需要在第 $3$、$4$ 种拼图中选择；当上一块拼图为第 $2$、$4$、$6$ 种时，当前需要在第 $1$、$2$ 种拼图中选择。至于选择哪一种，当然是根据 $a_i$ 的大小决定。

考虑能放就放的策略。

当前能放第 $1$ 种拼图时：

1. 当第 $4$ 种拼图的数量大于 $0$ 时，继续放置即可。
2. 当第 $4$ 种拼图的数量等于 $0$ 且以第 $8$ 种拼图结尾时，需满足第 $2$ 种拼图的数量也为 $0$，才能放置。

当前能放第 $2$、$3$ 种拼图时：由于不会改变已有的凸凹情况，所以根据 $a_i$ 的值能放就放。

当前能放第 $4$ 种拼图时：

1. 当第 $1$ 种拼图的数量大于 $0$ 时，继续放置即可。
2. 当第 $1$ 种拼图的数量等于 $0$ 且以第 $7$ 种拼图结尾时，需满足第 $3$ 种拼图的数量也为 $0$，才能放置。

当某一位置不满足以上任意一种情况时，则无解，输出 $-1$。

## 解释
为什么考虑能放就放？

因为即使当前就能判断出无解，但一直放下去一定会出现某一位置没有拼图可放的情况。既然有简单的判断方式，又何必选复杂的呢。

为什么放置第 $1$ 种拼图时，当第 $4$ 种拼图的数量等于 $0$ 且以第 $8$ 种拼图结尾的情况一定要求第 $2$ 种拼图数量也为 $0$ 呢？

由于第 $4$ 种拼图的数量为零，所以在放置第 $1$ 种拼图之后，凹凸情况将不会再发生改变，即右端将一直维持凸的情况，若此时还有第 $2$ 种拼图，则无法放置。

放置第 $4$ 种拼图时，当第 $1$ 种拼图的数量等于 $0$ 且以第 $7$ 种拼图结尾的情况一定要求第 $3$ 种拼图数量也为 $0$ 的原因与上述情况类似。

### Code
```
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<vector>
using namespace std;
const int INF=0x3f3f3f3f;
int n;
int x,a;
int las,en;//las记录上一个拼图的种类，en记录末尾拼图种类
int id,minn;
vector<int> g[10];
int ans[100005];//存答案
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
		scanf("%d%d",&x,&a);
		if(x==5||x==6) ans[1]=a;//记录第一块拼图的a
		else if(x==7||x==8) ans[n]=a;//记录最后一块拼图的a
		g[x].push_back(a);
		if(x==5) las=5;
		else if(x==6) las=6;
		else if(x==7) en=7;
		else if(x==8) en=8;
	}
	for(int i=1;i<=8;i++) sort(g[i].begin(),g[i].end());//对每一种拼图按照a的值从小到大排序
	for(int i=2;i<n;i++)//循环内容详情见分析
	{
		id=0;minn=INF;
		if(las==1||las==3||las==5)
		{
			if(g[3].size())
			{
				if(minn>g[3][0])
				{
					id=3;
					minn=g[3][0];
				}
			}
			if(g[4].size())
			{
				if(g[1].size()||(en==7&&g[1].size()==0&&g[3].size()==0))
				{	
					if(minn>g[4][0])
					{
						id=4;
						minn=g[4][0];
					}
				}
			}
		}
		if(las==2||las==4||las==6)
		{
			if(g[1].size())
			{
				if(g[4].size()||(en==8&&g[4].size()==0&&g[2].size()==0))
				{
					if(minn>g[1][0])
					{
						id=1;
						minn=g[1][0];
					}	
				}
			}
			if(g[2].size())
			{
				if(minn>g[2][0])
				{
					id=2;
					minn=g[2][0];
				}
			}
		}
		if(id==0)//如果没有拼图可放，则无解
		{
			printf("-1\n");
			return 0;
		}
		las=id;
		ans[i]=minn;//记录答案
		g[id].erase(g[id].begin());//删除，vector删除开头元素后，第二个元素将成为新的开头，所以每次判断大小都用g[id][0]
	}
	for(int i=1;i<=n;i++) printf("%d ",ans[i]);
	return 0;
}
```