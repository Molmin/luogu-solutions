## 本蒟蒻第一次发题解望通过~~~~
一开始把这道题当成了图论...当然可以做出来，其他的大佬们都解释的很详细了。蒟蒻自叹不如在此不做说明O(∩_∩)O哈哈~。

#### 后来做完后想着想着发现——这个题是其实一道**数学题！！！** 不需要邻接矩阵或者邻接表，O(n)算法就可以过。
那这道题怎么用数论做呢？与大家分享一个公式
##### - - 如果有一组数，我们要求它们两两相乘的和，那我们所求的值就等于这组数的和的平方减去它们分别的平方
O(∩_∩)O~是不是看起来有点慌，别慌别慌举几个例子

2ab=(a+b)^2-a^2-b^2

2ab+2ac+2bc=(a+b+c)^2-a^2-b^2-c^2

**以此类推**

那这个公式对这道题有什么用呢？我们来看，![undefined](https://cdn.luogu.com.cn/upload/pic/1347.png)

这道题要求的就是一个点两边连接点的乘积和，那我们只需要枚举各个中间点，将这个点(比如说i)所连接点的权值存到下标为这个点的数组he[i]里，再把各个点的权值平方后加到另一个数组cheng[i]里，最后代入公式求出来所求就好了

那最大值怎么办呢？在枚举点的时候把一个点上最大的两个权值保存在两个数组里就好了啊~~~~

最后这道题有一种很巧妙枚举的方法，我们把每条边存下来再挨个边加一遍就行了所以看起来像是枚举边(#^.^#)，这样就省了存图或者建邻接表的时间和空间。

来看代码
```
#include<iostream>
#include<cstdio>
using namespace std;
int u[200001],v[200001],w[200001],max1[200002],max2[200001];
long long he[200001],cheng[200001];
long long ans,max3;//一定要开long long
int main()
{
	int n;//顶点数
	max3=0;//最后的最大值
	scanf("%d",&n);
	for(int i=1;i<=n-1;i++)
	{
		scanf("%d %d",&u[i],&v[i]);//存边
	}
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&w[i]);//存每个点的权值
	}
    //下面是算法核心
	for(int i=1;i<=n-1;i++)
	{
	he[u[i]]=he[u[i]]+w[v[i]];//把与u[i]相连的点的权值加进he[u[i]]里；
	he[v[i]]=he[v[i]]+w[u[i]];//无向图反着加一遍；
	cheng[u[i]]=cheng[u[i]]+w[v[i]]*w[v[i]];//这是乘方的和；
	cheng[v[i]]=cheng[v[i]]+w[u[i]]*w[u[i]];
    //下面是判断每个点所连的最大值与第二大的值
	if(w[v[i]]>max1[u[i]])
	{
		max2[u[i]]=max1[u[i]];
		max1[u[i]]=w[v[i]];
	}
	else if(w[v[i]]>max2[u[i]])
	{
		max2[u[i]]=w[v[i]];
	}
	if(w[u[i]]>max1[v[i]])
	{
		max2[v[i]]=max1[v[i]];
		max1[v[i]]=w[u[i]];
	}
	else if(w[u[i]]>max2[v[i]])
	{
		max2[v[i]]=w[u[i]];
	}
	}//加完啦O(∩_∩)O~
	for(int i=1;i<=n;i++)
	{
		ans=(ans+he[i]*he[i]-cheng[i])%10007;//代公式，别忘了mod10007；
		if(max1[i]*max2[i]>max3)
		{
			max3=max1[i]*max2[i];//判断最大值
		}
	}
	printf("%lld %lld",max3,ans);//输出
    return 0;
}
```


#### 不会邻接表的童鞋看过来！！！纯模拟加数论

### 本题解未用任何高级算法大佬们勿喷，——自动忽略就好\\(^o^)/~
### 希望对大家有所帮助，有不对的地方还请大佬们指教，不喜勿喷啊O(∩_∩)O哈哈~