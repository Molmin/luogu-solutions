~~作为一个蒟蒻表示看到底下大佬们的题解很是胆战心惊~~

然后开始好奇这道题能不能用一些数学方法来解决；

~~毕竟这里有一只连图是什么东西都不知道的蒟蒻~~

****

**那我们来分析一下：**

- 首先，题目中求的联合权值指**距离为2的两个点的权值之积**；也就是说对于每一个点，只要有两个与它相连结的点，就能产生一个联合权值；

- 很显然，这道题我们可以枚举每一个点，对于每一个点再枚举所有与它相连结的点；当然，如果你不怕被数据卡死；~~目测复杂度超过O(n^2);~~

我刚才是不是说过数学方法来着？对，这道题可以用数学方法解。

首先我们可以把这个问题拆成两个部分，先考虑如何求出这一堆联合权值的和；

- 用“C”表示联合权值之和，我们可以得到 C= 2x1y1 + 2x2y2 + ... + 2xiyi;

- 在初中我们学过完全平方公式，即(a+b)^2=a^2 + b^2 + 2ab;

- 所以我们可以把原式变形为 C=(x1 + x2 +...+ xi)^2-(x1^2 + x2^2 +...+ xi^2);

- 由此，我们可以~~野蛮地~~将复杂度降到O(n);

贴出代码：
```cpp
for(i=1;i<n;i++)
	{
		x=a[i];
		y=b[i];
		
		w[x]=(w[x]+cnt[y])%10007;//a[i],b[i];
		w[y]=(w[y]+cnt[x])%10007;
		
		sqt[x]+=(cnt[y]*cnt[y])%10007;
		sqt[y]+=(cnt[x]*cnt[x])%10007;//maxium
		
		sqt[x]%=10007;
		sqt[y]%=10007;
    }
```

我们还有一个问题，联合权值的最大值还没有求；

但是这也很好解决，上面的代码相当于把所有数据都扫了一遍，而在上面代码的基础上我们增加一个判断最大值就可以了；

**要注意的是，题目要求输出一个最大的联合权值，那么我们就要找到对于每一个点的最大权值和第二大权值，两数相乘即得解；**

那么作出修改的代码就是这个样子：
```cpp
for(i=1;i<n;i++)
	{
		x=a[i];
		y=b[i];
		
		w[x]=(w[x]+cnt[y])%10007;//a[i],b[i];
		w[y]=(w[y]+cnt[x])%10007;
		
		sqt[x]+=(cnt[y]*cnt[y])%10007;
		sqt[y]+=(cnt[x]*cnt[x])%10007;//maxium
		
		sqt[x]%=10007;
		sqt[y]%=10007;
		
		//求最大值; 
		if(m1[x]<=cnt[y])
		{
			m2[x]=m1[x];
			m1[x]=cnt[y];
		}
		else if(m2[x]<cnt[y])
		{
			m2[x]=cnt[y];//求第二大值
		}
		
		if(m1[y]<=cnt[x])//注意权值在此处是相互的
		{
			m2[y]=m1[y];//a相对b有一个权值，b相对a亦然；
			m1[y]=cnt[x];
		}
		else if(m2[y]<cnt[x])
		{
			m2[y]=cnt[x];
		}
		
		if(m1[x]*m2[x]>maxn)
		{
			maxn=m1[x]*m2[x];
		}
		else if(m1[y]*m2[y]>maxn)
		{
			maxn=m1[y]*m2[y];
		}
		//求完最大值; 
	}
```
至此核心部分结束。

## 需要注意的几个地方：

- 题目上**没说最大值也要取模**，千万别画蛇添足；

- 正因为不取模，最大值可能很大，记得long long处理；

- 由于求和公式C=(x1 + x2 +...+ xi)^2-(x1^2 + x2^2 +...+ xi^2)中存在减法，并且每次计算都需要取模，最终结果很可能为负数，此处我们需如下处理：
```cpp
ans = (ans + 10007)%10007;
```

****
想了很久还是决定把源代码贴上  
~~总之变成屎名的不是我，自重就好；~~
```cpp
#include<cstdio>
#include<cstring>
using namespace std;

int w[200005]={0},sqt[200005]={0},a[200005]={0},b[200005]={0};
int cnt[200005]={0};
int m1[200005]={0},m2[200005]={0};

int main()
{
	int n,i,ans,x,y;
	long long maxn;
	
	scanf("%d",&n);
	
	for(i=1;i<n;i++)
	{
		scanf("%d%d",&a[i],&b[i]);
	}
	
	for(i=1;i<=n;i++)
	{
		scanf("%d",&cnt[i]);
	}
	// read;
	
	memset(m1,0,sizeof(m1));
	memset(m2,0,sizeof(m2));
	
	maxn=0;
	for(i=1;i<n;i++)
	{
		x=a[i];
		y=b[i];
		
		w[x]=(w[x]+cnt[y])%10007;//a[i],b[i];
		w[y]=(w[y]+cnt[x])%10007;
		
		sqt[x]+=(cnt[y]*cnt[y])%10007;
		sqt[y]+=(cnt[x]*cnt[x])%10007;//maxium
		
		sqt[x]%=10007;
		sqt[y]%=10007;
		
		//求最大值; 
		if(m1[x]<=cnt[y])
		{
			m2[x]=m1[x];
			m1[x]=cnt[y];
		}
		else if(m2[x]<cnt[y])
		{
			m2[x]=cnt[y];
		}
		
		if(m1[y]<=cnt[x])
		{
			m2[y]=m1[y];
			m1[y]=cnt[x];
		}
		else if(m2[y]<cnt[x])
		{
			m2[y]=cnt[x];
		}
		
		if(m1[x]*m2[x]>maxn)
		{
			maxn=m1[x]*m2[x];
		}
		else if(m1[y]*m2[y]>maxn)
		{
			maxn=m1[y]*m2[y];
		}
		//求完最大值; 
	}
	
	for(i=1;i<=n;i++)
	{
		w[i]=(w[i]*w[i])%10007;
		w[i]-=sqt[i];
	}//computing;
	
	ans=0;
	for(i=1;i<=n;i++)
	{
		ans=(ans+w[i])%10007;
	}//final
	
	ans = (ans + 10007)%10007;
	
	printf("%lld %d\n",maxn,ans);//%I64d----%lld;
	
	return 0;
}


```