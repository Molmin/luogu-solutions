这道题思路非常的巧，要不是看了标签是二分答案可能还真想不到

首先，由于我们求得是中位数，中位数因为它求得是数值在中间的数，所以我们不必记录每个数的大小，只需记录它们的**相对大小**。 

我们可以二分答案并在每次$check$时将数组处理为$01$串 ，小于等于这个数的设为$0$，大于等于这个数的设为$1$。

我们在考虑怎么在$O$($n$)内进行$check$，首先我们可以想到，当有连续的两个$0$或连续的两个$1$时**只要它不贴着边缘**就一定能传到上面去。

举个例子

```
    1 
  0 1 1
0 0 1 1 0
```
这里的 两个$1$连续且不挨着边，就有两个$1$传了上去，但这里连着的两个$0$虽然连续，但贴着边，就只能传$1$个$0$上去

那怎么保证有一组$0$或$1$一路不碰边到最上层呢。

答案是：最靠近中间的那一组。

我们就可以得出结论，只要有两个连续的$1$或$0$，它们且最靠近中间那么最上面的数一定是它。

但是有一个问题：会不会有两组不相同的$0$ $1$里中间一样远。

答案是：不可能

我们假设有这种情况

因为如果你搜到这里了，中间一定是$01$交替的串组成

这是如果有两组连续的$0$或$1$，里中间一样远，那么其中一个**一定在上一个位置就搜到了**，所以这种情况不存在

举个例子
```
0 0 1 0 1 1 1 
0 0 0 1 0 1 1 
```
这里的有两组连续的$0$，$1$离中间一样远，但因为中间是$101$或$010$

就有一组在上一位就被搜到，所以不可能存在。

最后因为有可能会有全程$01$交替的存在故需要特判

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[400005],n;
int small(int i,int k)
{
	return a[i+1]<=k&&a[i]<=k;//判断小于等于 
}
int big(int i,int k)
{
	return a[i+1]>k&&a[i]>k;//判断大于
}
int check(int k)
{
	for(int i=0;i<=n-1;i++)//从中心开始看是否有两个连续的1或0
	{
		if(small(n+i,k)==1||small(n-i-1,k)==1)//如果小于等于k的数在最上面
		{
			return 1;
		}
		if(big(n+i,k)==1||big(n-i-1,k)==1)如果大于k的数在最上面
		{
			return 0;
		}
	}
   //特判 全是01交替的情况 
	if(a[1]<=k)
	{
		return 1;
	}else
	{
		return 0;
	}
}
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=2*n-1;i++)
	{
		scanf("%d",&a[i]);
	}
	int l=1,r=2*n-1;//这里r是2*n-1
	while(l<r)//二分答案
	{
		int mid=(l+r)>>1;
		if(check(mid)==1)
		{
			r=mid;
		}else
		{
			l=mid+1;
		}
	}
	cout<<r;
	return 0;
}
```
