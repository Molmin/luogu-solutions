# 网络连接

提交地址：[洛谷 Luogu7911](https://www.luogu.com.cn/problem/P7911)

## 题目大意

给出 $n$ 台计算机，有服务机（`Server`）和客户机（`Client`）。

每台服务机挂载一个 IPv4 地址（带端口），每台客户机链接一个服务机（通过 IPv4 地址）。

如果 IP 非法输出 `ERR`，如果服务机要挂载的 IP 被占用或客户机要链接的 IP 不是合法的服务机输出 `FAIL`，如果服务机成功挂载输出 `OK`，如果客户机成功链接输出连接到的服务机编号。

## 分析

没打 J 组，写题解原因是看到这篇博客（博客已经没了），然后发现原来 C++11 就有正则表达式了~~所以就写了~~。

已经有一篇正则表达式的题解了，不过不是纯正则判断合法的，这篇讲一下如何纯正则判断合法性。

于是可以使用正则表达式来判断 IP 是否合法，用哈希映射表匹配计算机。

### 正则表达式

正则表达式是一种用途很广泛的工具。

更具体正则表达式相关自行谷歌，附维基链接：[正则表达式](https://zh.wikipedia.org/zh-cn/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F)。

这里只介绍这道题用到的。

正则表达式可以通过一个模式串匹配文本串判断文本串是否符合要求。

`[0-9]` 可以匹配一个 $0 \sim 9$ 的单个数字，那么 `25[0-5]` 则可以匹配 $250 \sim 255$，匹配 `.` 时是需要使用 `\` 转义的（`.` 表示匹配除 `\r`、`\n` 外的任何单个字符），而 `\` 又是 C++ 中的转义字符，所以匹配 `.` 需要 `\\.` 才行，`:` 也需要转义。

如果想要两个匹配中的一个呢？

用 `|` 即可，如 `a|b` 表示匹配 `a` 或者 `b`。

但是注意 `a|bcd` 匹配的是 `a` 或者 `bcd`，那么怎么匹配 `acd` 或 `bcd` 呢？

加括号！用 `(a|b)cd` 就行了。

如果想匹配置顶重复次数的某个串呢？

用 `(<pattern>){<times>}` 即可，其中 `()` 将括号内作为一个整体匹配，`{}` 表示前一个字母或整体的匹配次数，那么这个模式串表示匹配 $times$ 次 $pattern$ 串。

匹配一次或两次？用 `?`。任意次？用 `*`。

综上，IPv4 地址的模式串就是：

```
(((25[0-5])|(2[0-4][0-9])|(1[0-9][0-9])|([1-9][0-9])|[0-9])\\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9][0-9])|([1-9][0-9])|[0-9])\\:((6553[0-5])|(655[0-2][0-9])|(65[0-4][0-9][0-9])|(6[0-4][0-9][0-9][0-9])|([1-5][0-9][0-9][0-9][0-9])|([1-9][0-9][0-9][0-9])|([1-9][0-9][0-9])|([1-9][0-9])|[0-9])
```

那么怎么在 C++ 中使用？

首先 C++ 标准至少为 C++11.

先包含 `<regex>` 头文件。

使用 `std::regex` 定义一个模式串，如：

```cpp
const std::regex pat("C\\+\\+((98)|(11)|(14)|(17)|(20))"); // + 也需要转义，这里不讲了
```

然后使用 `std::regex_match()` 来匹配，接受两个参数，第一个是文本串，第二个是模式串，如：

```cpp
std::regex_match("C++11", pat);
```

返回值为布尔类型，表示是否匹配成功。

刚才函数返回值应为 `true`。

### 匹配计算机

先判断 IP 是否合法，不合法直接输出 `ERR` 然后下一个。

然后判断计算机类型。

对于服务机，用哈希映射表查找 IP 是否被占用，有，输出 `FAIL` 然后下一个，没有，映射表的值附为编号，输出 `OK`。

对于客户机，用哈希映射表查找 IP 是否是合法服务机（及是否有编号），是，输出编号，否，输出 `FAIL`。

结束。

## $\rm \color{green}code$

### C++

```cpp
#include <iostream>
#include <string>
#include <unordered_map>
#include <regex>
using namespace std;
int n;
unordered_map<string, int> mp;
inline bool check(const string &ip) {
    static const regex ippt("(((25[0-5])|(2[0-4][0-9])|(1[0-9][0-9])|([1-9][0-9])|[0-9])\\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9][0-9])|([1-9][0-9])|[0-9])\\:((6553[0-5])|(655[0-2][0-9])|(65[0-4][0-9][0-9])|(6[0-4][0-9][0-9][0-9])|([1-5][0-9][0-9][0-9][0-9])|([1-9][0-9][0-9][0-9])|([1-9][0-9][0-9])|([1-9][0-9])|[0-9])");
    return regex_match(ip, ippt);
}

int main() {
    ios::sync_with_stdio(false);
    mp["Server"] = 0, mp["Client"] = 1;
    cin >> n;
    for (int i = 1; i <= n; ++i) {
        static string op, ip;
        static int typ;
        auto it = mp.end();
        cin >> op >> ip;
        if (check(ip)) {
            typ = mp[op];
            if (typ == 0) {
                it = mp.find(ip);
                if (it == mp.end()) {
                    mp[ip] = i;
                    cout <<"OK\n";
                } else {
                    cout << "FAIL\n";
                }
            } else if (typ == 1) {
                it = mp.find(ip);
                if (it == mp.end()) {
                    cout << "FAIL\n";
                } else {
                    cout << it->second << '\n';
                }
            }
        } else {
            cout << "ERR\n";
        }
    }
    return 0;
}
```

### Python

```python
import re
pat = re.compile(r"^(((((25[0-5])|(2[0-4][0-9])|(1[0-9][0-9])|([1-9][0-9])|[0-9])\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9][0-9])|([1-9][0-9])|[0-9])\:((6553[0-5])|(655[0-2][0-9])|(65[0-4][0-9][0-9])|(6[0-4][0-9][0-9][0-9])|([1-5][0-9][0-9][0-9][0-9])|([1-9][0-9][0-9][0-9])|([1-9][0-9][0-9])|([1-9][0-9])|[0-9])))$")
def check(ip):
    return not(re.match(pat, ip) == None)
s = input()
n = int(s)
mp = {"" : 0}
for i in range(n):
    s = input().split()
    op = s[0]
    ip = s[1]
    # print(re.match(pat, ip))
    if check(ip):
        if op == "Server":
            try:
                mp[ip]
            except KeyError:
                mp[ip] = i + 1
                print("OK")
            else:
                print("FAIL")
        elif op == "Client":
            flag = True
            try:
                mp[ip]
            except KeyError:
                flag = False
                print("FAIL")
            else:
                print(mp[ip])
    else:
        print("ERR")
```