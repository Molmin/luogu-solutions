# 0x00 思路
~~妥妥的《阅 读 理 解》~~

这么长的题面真让人不爽。

来吧，让我们看一看，这令人不爽的题面。

>在本问题中，计算机分为两大类：服务机（`Server`）和客户机（`Client`）。

>需要进行网络连接的计算机共有 $n$ 台，编号为 $1 \sim n$，这些机器将按**编号递增**的顺序，**依次发起一条**建立连接或加入连接的操作。

>每台机器在尝试建立或加入连接时需要提供一个地址串。**服务机**提供的地址串表示它**尝试建立连接**的地址，**客户机**提供的地址串表示它**尝试加入连接**的地址。

>一个**符合规范**的地址串应当具有以下特征：

>1. **必须形如 `a.b.c.d:e` 的格式**，其中 $a, b, c, d, e$ 均为**非负整数**。
>1. $0 \le a, b, c, d \le 255$，$0 \le e \le 65535$。
>1. $a, b, c, d, e$ 均不能含有**多余的前导** $0$。

>在本问题中，我们假定凡是**符合上述规范**的地址串**均可参与**正常的连接……**如果有两台服务机使用相同的地址串**，**后一台**尝试建立连接的服务机将会**无法成功建立连接**……如果某台提供符合规范的地址的客户机在尝试加入连接时，与**先前**某台已经**成功建立连接的**服务机提供的**地址串相同**，这台客户机就可以成功加入连接，并称其连接到这台服务机；**如果找不到**这样的服务机，则认为这台客户机**无法成功加入连接**……**多台客户机使用同样的地址串的情况是被允许的**。

好了，这就是那~~又臭又长的~~题面了。

我们可以很明确的从题面中看到，这只是一个模拟而已。

# 0x01 行动
首先我们可以发现有服务机和客户机两种机型。但这两种机型都有一个共同的输出：`ERR`。所以我们可以优先解决这种情况。

## 0x010 ERR
首先我们可以发现这一种输出是由于输入字符串不合法而导致的错误。所以我们可以对输入的字符串进行检查。

那么我们可以用地址串的格式（`a.b.c.d:e`）进行检查。

1. 我们可以发现，在地址串的**最前面**是一个**数字**，那么如果在**第一个数字前**我们找到了 `.` 或 `:`，那么一定不合法。
2. 其次，只有 $3$ 个 `.`，$1$ 个`:`，$5$ 个数字。若找到 `.`、`:`、数字个数不为 $3$、$1$、$5$（~~315，好耶~~）,则也不合法。
3. 第三，每个数前没有前导 $0$。
4. 还有，$0 \le a, b, c, d \le 255$，$0 \le e \le 65535$。
5. 最后，`:` 要是在某个 `.` 前面出现了，同样不合法。

## code
```c
bool check(string ad)
{
	int len=ad.length(),i,point=0,mao=0,num=0,sum;
	for(i=0;i<len;i++)
	{
		sum=-1;
		while(ad[i]>='0'&&ad[i]<='9'&&i<=len)
		{
			if(ad[i]=='0'&&sum==-1&&ad[i+1]>='0'&&ad[i+1]<='9')//第3条
				return 0;
			if(sum==-1)
				sum=0;
			sum=(sum<<1)+(sum<<3)+(ad[i]^48);
			if(num<4&&sum>255)//第4条
				return 0;
			if(num==4&&sum>65535)//第4条
				return 0;
			i++;
		}
		if(sum!=-1)
			num++;
		if(num>5)//第2条
			return 0;
		if(ad[i]=='.')
			point++;
		if(ad[i]==':')
			mao++;
		if(point>3||mao>1)//第2条
			return 0;
		if(point<3&&mao>0)//第5条
			return 0;
		if((point>0||mao>0)&&num==0)//第1条
			return 0;
		if(ad[i]!='.'&&ad[i]!=':'&&ad[i]!=0)//若有其他物品一律不符合规范
			return 0;
	}
	if(point!=3||mao!=1||num!=5)//第2条
		return 0;
	return 1;
}
```

## 0x011 FAIL&OK（Server）
~~对于在考场上打出 `FATL` 的选手们致以沉重的默哀。~~

对于进行连接的服务机，我们可以将所有成功连接的服务机全部存入一个 `string` 数组中或存入 `map` 中，当又有一个服务机将要创建连接时进行遍历，查看是否有重复，若有重复则输出 `FAIL`,无重复输出 `OK`。

### code
```c
if(op[0]=='S')
		{
			for(j=0;j<tot;j++)
			{
				if(h[j]==ad)
				{
					puts("FAIL");
					break;
				}
			}
			if(j!=tot)
				continue;
			h[tot++]=ad;//记录
			Had[tot-1]=i;//为 Client 做准备
			puts("OK");
			continue;
		}
```
## 0x012 FAIL&编号（Client）
同样对于所有成功建立连接的服务器进行查找。若有相同输出编号，若无相同输出 `FAIL`。
### code
```c
if(op[0]=='C')
		{
			for(j=0;j<tot;j++)
			{
				if(h[j]==ad)
				{
					printf("%d\n",Had[j]);
					break;
				}
			}
			if(j!=tot)
				continue;
			puts("FAIL");
		}
```
# code
代码已经零星给出，这里就不再重给。

~~完结撒花!!~~ <(￣ˇ￣)/