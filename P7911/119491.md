火速来一发正则表达式的题解。

regex yyds！

----

首先，你需要知道有个东西叫正则表达式。一句话就是匹配字符串的格式。

首先，我们要匹配三位整数，有两种情况：

- 0；
- 首位非零，后面为任意数字。

正则中使用 `[0-9]` 表示 0 到 9 的任意字符，而 `{0,2}` 代表出现 0 次到两次中的任意一个，所以两个规则分别就是：

- `0`；
- `[1-9][0-9]{0,2}`。

而我们可以使用 `(A|B)` 代表 `A` 或 `B`，所以对于每一位，正则表达式就是 `(0|[1-9][0-9]{0,2})`。

然后我们在中间要加上点，但 `.` 是正则关键字符（表示匹配所有字符），需要在前面加上反斜杠转义，又因为 C/C++ 的特性，所以要加两个反斜杠。

同时，正则表达式只要找到满足条件的子串就认为是合法的，所以要加上特殊定位符：`^` 代表字符串开头，（美元符号）代表字符串结尾。所以最终的正则表达式就是（将人民币符号变成美元符号）：

```
^(0|[1-9][0-9]{0,2})\.(0|[1-9][0-9]{0,2})\.(0|[1-9][0-9]{0,2})\.(0|[1-9][0-9]{0,2}):(0|[1-9][0-9]{0,4})￥
```

然后用 `regex_match` 判断一下基本格式，`sscanf` 读出每个数并判断边界，然后用 `map` 存一下就做完了。

```cpp
#include <regex> // 正则表达式的头文件
#include <cstdio>
#include <map>
using namespace std;
typedef long long ll;

const ll u[] = {1099511627776ll, 4294967296ll, 16777216, 65536, 1};

char s[30], ty[10];
map<ll, int> mp;

inline bool ir(int x, int lim = 255) { return x >= 0 && x <= lim; }

int main()
{
	
	regex pat("^(0|[1-9][0-9]{0,2})\\.(0|[1-9][0-9]{0,2})\\.(0|[1-9][0-9]{0,2})\\.(0|[1-9][0-9]{0,2}):(0|[1-9][0-9]{0,4})$");
	int n, a, b, c, d, e;
	ll qid;
	
	scanf("%d", &n);
	for (int i = 0; i < n; i++)
	{
		scanf("%s%s", ty, s);
		if (!regex_match(s, pat))
		{
			puts("ERR");
			continue;
		}
		sscanf(s, "%d.%d.%d.%d:%d", &a, &b, &c, &d, &e);
		if (ir(a) && ir(b) && ir(c) && ir(d) && ir(e, 65535))
		{
			qid = a*u[0] + b*u[1] + c*u[2] + d*u[3] + e;
			if (mp.find(qid) != mp.end())
			{
				if (ty[0] == 'C')
					printf("%d\n", mp[qid]);
				else
					puts("FAIL");
			}
			else
			{
				if (ty[0] == 'C')
					puts("FAIL");
				else
					mp[qid] = i + 1, puts("OK");
			}
		}
		else
			puts("ERR");
	}
	return 0;
}
```