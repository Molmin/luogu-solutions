# P1908 逆序对 题解

## 思路

比较求得逆序对对数

### 思路 1 ：逐一尝试

```cpp
#include<cstdio>
using namespace std;
int main()
{
    int n;
    scanf("%d",&n);//输入n的值，scanf比cin快。
    int a[n+1];
    long int sum=0;//设置总数为0，sum值有可能很大，因此用long int类型。
    int i,j;//设置两个指针进行逐一尝试。
    for(i=1;i<=n;i++)
    {
    	scanf("%d",&a[i]);//读入。
    }
    for(i=1;i<n;i++)
    {
        for(j=i;j<=n;j++)
        {
            if(a[i]>a[j])
            {
                sum++;
            }
        }
    }
    printf("%d",sum);//输出总和。
    return 0;
}
```
这种方法简单易懂，容易执行。

现在来分析这种方法的时间复杂度好空间复杂度。
时间复杂度O(1+n+n*(n+1)/2)，即为O(N^2)。
空间复杂度为n+4个int型变量和1个long int型变量，共占用22+4n个字节。

现在看时空限制：时间1000ms，空间128m。
128m=134217728字节，n的最大值为33554426，满足题目要求。

我们通常认为计算机每秒钟大约运行1000000000次。当n=500000是，运算次数为125000750001次，远大于规定时间。

所以此思路虽然简单，但因为耗时过长所以不能使用。

### 思路 2 ：归并排序 正解

#### 1. 分治思想介绍

分治，字面上的解释是“分而治之”，就是把一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题……直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。

在求解一个输入规模为n，而n的取值又很大的问题时，直接求解往往非常困难。这时，可以先分析问题本身所具有的某些特性，然后从这些特性出发，选择某些适当的设计策略来求解。这种方法，就是所谓的分治法。

采用分治法解决的问题一般具有的特征如下：
1. 问题的规模缩小到一定的规模就可以较容易地解决。
2. 问题可以分解为若干个规模较小的模式相同的子问题，即该问题具有最优子结构性质。
3. 合并问题分解出的子问题的解可以得到问题的解。
4. 问题所分解出的各个子问题之间是独立的，即子问题之间不存在公共的子问题。

设计步骤

1. 划分步：把输入的问题划分为k个子问题，并尽量使这k个子问题的规模大致相同。
2. 治理步：当问题的规模大于某个预定的阈值n0时，治理步由k个递归调用组成。
3. 组合步：组合步把各个子问题的解组合起来，它对分治算法的实际性能至关重要，算法的有效性很大地依赖于组合步的实现。

分治法的关键是算法的组合步。究竟应该怎样合并，目前没有统一的模式，因此需要对具体问题进行具体分析，以得出比较好的合并算法。

————摘自“百度百科”

想必通过上面的介绍，大家对分治思想已经有所了解。但如何实现呢？

#### 2. 实现思路：
1. 划分
2. 合并（用递归实现）

```cpp
void partition(int a,int b,...)
{
    //初始化。
    partition(c,d,...);
    partition(e,f,...);//分
    //治（合并操作代码）
    return;
}
```

#### 3. 归并操作定义及原理

归并操作指的是**将两个顺序序列合并成一个顺序序列的方法。**

工作原理：（合并成由小到大的顺序数列）

第一步：申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列

第二步：设定两个指针（i和j），最初位置分别为两个已经排序序列的起始位置

第三步：比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置

重复步骤3直到某一指针超出序列尾

将另一序列剩下的所有元素直接复制到合并序列尾

#### 4. 归并操作实现

```cpp
void merge(int l,int r)
{
    int m=(l+r)/2;//寻找中间值（看作两组数据合并为一个数组）
    int i=l,j=m+1,k=l;
    while(i<=m && j<=r)
    {
    	if(a[i]>a[j])
        {
            b[k]=a[j];
            k++;
            j++;
            }
        else
        {
            b[k]=a[i];
            k++;
            i++;
        }
    }//寻找最小值。
    while(i<=m)
    {
        b[k]=a[i];
        k++;
        i++;
    }
    while(j<=r)
    {
		b[k]=a[j];
		k++;
		j++;
    }//余下的放入数组。
    for(i=l;i<=r;i++)
    {
    	a[i]=b[i];
    }//还原回a数组中。
}
```
#### 5. 归并排序实现

要对一串无序数据进行**分**的操作，经过若干次分后会变成一个个单个的数据，可以看成是**有序**的，再利用归并操作**合并**。

分：递归

合并：归并操作

代码实现如下

```cpp
void mergesort(int l,int r)
{
    if(l==r)
    {
        return;
    }//判断是否分至最小
    int m=(l+r)/2;//中间数
    merge(l,m);
    merge(m+1,r);//递归思想
    int i=l,j=m+1,k=l;//指针
    while(i<=m && j<=r)
    {
        if(a[i]>a[j])
        {
            b[k]=a[j];
            k++;
            j++;
        }
        else
        {
            b[k]=a[i];
            k++;
            i++;
        }
    }
    while(i<=m)
    {
        b[k]=a[i];
        k++;
        i++;
    }
    while(j<=r)
    {
        b[k]=a[j];
        k++;
        j++;
    }
    for(i=l;i<=r;i++)
    {
        a[i]=b[i];
    }//归并操作
}
```
#### 6. 求解逆序对

在归并排序时，若发现有前面的数（a[i]）大于后面的数（a[j]）时,发现逆序对。此时a[l]~a[m]为有序数列，则a[i]~a[m]这一段的数都满足a[k]>a[j]（k=i~m）。此时有（m-i+1）个逆序对。则在遇到这种情况时将结果加上（m-i+1）个即可。

完整代码如下

```cpp
#include<cstdio>
#define MAXN 500005//设置最大的n的值。
int n,a[MAXN],b[MAXN];//定义固定数组和用于排序的临时数组。
long int ans=0;//ans较大。
void merge(int l,int r)
{
    if(l==r)
    {
        return;
    }
    int m=(l+r)/2;
    merge(l,m);
    merge(m+1,r);//递归过程。
    int i=l,j=m+1,k=l;
    while(i<=m && j<=r)
    {
        if(a[i]>a[j])
        {
            b[k]=a[j];
            k++;
            j++;
            ans+=(m-i+1);//逆序对核心语句。
        }
        else
        {
            b[k]=a[i];
            k++;
            i++;
        }
    }
    while(i<=m)
    {
        b[k]=a[i];
        k++;
        i++;
    }
    while(j<=r)
    {
        b[k]=a[j];
        k++;
        j++;
    }
    for(i=l;i<=r;i++)
    {
        a[i]=b[i];
    }
}
int main()
{
    scanf("%d",&n);//读入n。
    int i;
    for(i=1;i<=n;i++)
    {
        scanf("%d",&a[i]);//读入数列。
    }
    merge(1,n);//归并排序。
    printf("%ld",ans);
    return 0;
}
```
此题解毕。

提交信息：
评测状态  Accepted  100

用时: 1672ms / 内存: 4668KB

#### 推荐题目

P1116 车厢重组

P1774 最接近神的人_NOI导刊2010提高（02）

这两题也是用同样的方法，只是描述不同，可以训练。