###### ~~这个题好像已经有很多题解了~~
###### 这篇题解主要给正在学的分治的同胞们讲一下归并排序
疯狂解释
------------
总体思想：该算法采用分治法，将已有序的子序列合并，得到完全有序的序列。即先使每个子序列有序，再使子序列段间有序。（递归过程）
###### ~~什么鬼？？完全听不懂？？~~
这里详细讲解一下，我们来看一下样例是如何归并排序的:

样例： 5 4 2 6 3 1，用一个a数组表示a[1,2,3,4,5,6]；

首先：递归搜索1~6，然后进行二分（分治），将区间1~6递归分解成1~3和4~6，mid=（1+6）/2=3；(mid向下取整)  

继续：递归搜索1~3，分解为1~2和3~3，然后将1~3分解为1~1，2~2，因为l=r结束函数；  

回到1~2：mid=(1+2)/2=1，定义数组rr表示排序后的数，进行逆序对的比较。

过程：定义i=l,j=mid+1,k=l(i,j用于存储正在比较的指针，k用于存储排序后的数的指针)

###### ~~解释看不懂？继续往下看~~
此时i=1,j=2,k=1;

进行循环，只要i小于等于mid并且j小于等于r就进行逆序对的比较；

比较a[i]和a[j]，也就是5和4，由于5大于4，满足逆序对的要求，那么令rr[k]=a[j]，即rr[1]=a[2]=4，之后，j和k自加1，逆序对的数量加1；由于j此时已经大于r，结束循环。

但是此时i依然是小于等于r的，那么我们就需要对a[i]继续赋值，即令rr[k]=a[i]并让k和i自加直到i大于mid，具体的就是令rr[2]=a[1]=5；

最后，将a的值全部换为rr，结束函数;

不难发现在进行了一波变换之后，这个子区间已经变为了有序的，此时我们的a数组为

4 5 2 6 3 1

继续进行：由于3~3中l=r，直接结束

接下来进行1~3的逆序对查找（合并1~2和3~3）,mid=(1+2)/2=2

比较a[i]和a[j],即a[1]和a[3]，满足逆序对的要求，rr[k]=a[j],即rr[1]=a[3],j和k自加；

#### 但是这个时候我们发现，由于l~mid这个区间也就是1~2在之前已经是有序的了，也就是前面的总比后面的小，也就是说如果前面的i已经与j产生了一个逆序对，那么从i开始到mid都可以与现在的j产生逆序对，所以逆序对的个数不应该只加1，而是加上mid-i+1。

#### 那么会产生重复吗？并不会。因为每一次我们在判断是逆序对后会将j自加，后面的i并没有机会和前面的j进行比较了

所以继续，现在逆序对已经有3个了，由于j已经大于r，结束循环。

同上，我们令现在的rr[k]=a[i];即rr[2]=a[1]=4；继续同上，我们将a全部换为rr，现在的a数组为:

2 4 5 6 3 1

###### （~~我们的电脑原来做了这么多事情~~）

接下来，我们继续分4~6，分为4~5和6~6，同上，逆序对的个数会变为6，a数组会变为：

2 4 5 1 3 6

最后，我们会合并1~3和4~6，也就是进行1~6的逆序对查找（i=1,j=4,mid=3）

由于a[i]大于a[j]，即a[1]大于a[4]，则令rr[k]=a[j],k和j再自加，由于产生了3-1+1个逆序对，逆序对的个数加3，现在有了9个逆序对;

继续比较，由于a[i]现在小于a[j]，即a[1]小于a[5]，令rr[k]=a[i],i和k自加，逆序对个数不变；

再继续比较，由于a[i]又一次大于a[j]，也就是a[2]大于a[5],令rr[k]=a[j],k和j自加，逆序对个数增加3-2+1个，也就是2个，现在一共有11个逆序对；

继续比较，a[i]小于a[j]，即a[2]小于a[6]，rr[k]=a[i]；

再比较，a[i]小于a[j]，即a[3]小于a[6]，rr[k]=a[i]；

由于现在i越界，停止循环；

但是j还小于等于r，令rr[k]=a[j]并自加就好了；

在进行了最后一波合并之后，我们的a数组变为了

1 2 3 4 5 6

以及逆序对数量变为了11；

###### 　（~~皆大欢喜了呢~~）

最后我们只需要输出11就好了。

#### 还有一个地方需要解释，为什么每一次比较之后如果a[i]大于a[j]，j就需要自加，反之i就需要自加呢。答案其实很简单，由于我们的子区间是有序的，前面的总比后面的的小，也就是说，在i或者j自加之后，又会有形成逆序对的可能。

（完）

感谢大家看到现在，接下来是代码：）
------------
```cpp
#include<iostream>
using namespace std;
int a[500005],rr[500005],n;//看懂前面，代码不需要解释
long long ans=0; 
void gb(int l,int r)
{
    if(l==r)return ;
    int mid=(l+r)/2;
    gb(l,mid);
	gb(mid+1,r);
    int i=l,j=mid+1,k=l;
    while(i<=mid&&j<=r)
    {
    	if(a[i]<=a[j])rr[k++]=a[i++];
		else 
		{
			rr[k++]=a[j++];
			ans+=(long long)mid-i+1;
		}
	}
    while(i<=mid)rr[k++]=a[i++];
    while(j<=r)rr[k++]=a[j++];
    for(int i=l;i<=r;i++)a[i]=rr[i];
}
int main()
{
	cin>>n;
    for(int i=1;i<=n;i++)cin>>a[i];
    gb(1,n);
    cout<<ans;
    return 0;
}
```


------------
（本题解共125行）