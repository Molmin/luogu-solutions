**题目大意**：给定两个二进制字符串 $a$ 和 $b$，通过不超过 $3n$ 次操作，将字符串 $a$ 变成字符串 $b$；每一次操作将字符串 $a$ 的前 $p$ 个字符中 $0$ 变成 $1$，$1$ 变成 $0$，并将前 $p$ 个字符反转。

首先考虑暴力：**尝试所有的操作顺序，直到将 $a$ 变成 $b$。**

这样的话，时间复杂度特别大，通不过这一道题，需要优化。

经过分析，可以发现，这个操作有一个特点：**每一次操作只影响前 $p$ 个字符，对 $\left(p+1\right)\sim n$ 的字符没有影响。**

所以，可以考虑从最后一位开始，让 $a$ 的字符等于 $b$ 。

**具体方法**：从最后一位开始，如果 $a$ 与 $b$ 的最后一位不相等，那么进行操作。

操作之后，字符串 $a$ 的最后一位变成了与原字符串 $a$ 第一位不同的字符，所以交换之前应该判断字符串 $a$ 的第一位和字符串 $b$ 的最后一位是否相同。如果相同，就需要先对字符串 $a$ 的第一位进行操作，再对字符串 $a$ 进行操作。

这样从字符串 $a$ 的最后一位一直改到字符串 $a$ 的第一位即可。

**代码：**
```cpp
if(a[1]==b[i])
//如果a的第一个和b的最后一个一样，那么换完时候就不一样了
//所以，应该先把a的第一个换一下
{
	c[++k]=1;
	a[1]='0'+'1'-a[1];
}
c[++k]=i;//统计方案
for(j=1; j<=i; ++j)
	a[j]='0'+'1'-a[j];
reverse(a+1,a+i+1);//进行操作
```
这样，每到一位最多改变两次，一共有 $n$ 位，最多改变 $2n$ 次，符合要求。

时间复杂度为 $O\left(n^2\right)$ ，可以通过本题。

**代码：**
```cpp
#include<algorithm>
#include<cstdio>
#include<iostream>
using std::reverse;
const int N=1000;
char a[N+1],b[N+1];
int c[N*2+1];
int main()
{
	register int i,j,k,n,t;
	scanf("%d",&t);
	while(t--)
	{
		scanf("%d%s%s",&n,a+1,b+1);
		k=0;
		for(i=n; i; --i)//从最后开始操作
			if(a[i]!=b[i])//如果a和b最后一个字符不相等
			{
				if(a[1]==b[i])
				//如果a的第一个和b的最后一个一样，那么换完时候就不一样了
				//所以，应该先把a的第一个换一下
				{
					c[++k]=1;
					a[1]='0'+'1'-a[1];
				}
				c[++k]=i;//统计方案
				for(j=1; j<=i; ++j)
					a[j]='0'+'1'-a[j];
				reverse(a+1,a+i+1);//进行操作
			}
		printf("%d ",k);
		for(i=1; i<=k; ++i)
			printf("%d ",c[i]);
		putchar('\n');
	}
	return 0;
}
```
虽然这一个方法可以通过本题，但是这一种方法并不是时间复杂度最优的，还可以继续优化。

如果修改的时候同时考虑两个字符串的话，是很麻烦的，所以，可以考虑**一次只修改一个字符串**。

如果每一个字符串中只有 $0$ 或只有 $1$，那么最多操作一次就可以了。

这可以给我们启发：**可以将每一个字符串变成只有一种字符的字符串**。

所以，接下来的任务就是如何将每一个字符串变成只有一个字符的字符串。

这个可以从前面开始遍历，如果这个位置与后一个位置不同，那么就对这一个位置之前的进行操作，一直到最后就可以了。

举个例子：$01010\to11010\to00010\to11110\to00000$。

而且，我们经过上面的操作之后，**每一个字符串的字符与原字符串最后一个字符相同**，所以我们就不需要在数组中修改了，这样就减少了许多时间复杂度。

最后，我们**要判断这两个字符串是否一样**，如果一个全是 $0$ ，另一个全是 $1$，那么就需要对整个字符串进行操作。

还有一个问题：题目中让我们输出操作字符串 $a$ 的方案，但是我们在处理的过程中操作字符串 $b$ 了，所以输出时对字符串 $b$ 的方案应该倒着输出。

对于每一个字符串，最多操作 $n-1$ 次，最后判断是否一样，最多操作 $1$ 次，这样，总共操作不超过 $2n-1$ 次，符合要求。

时间复杂度为 $O\left(n\right)$。

**代码：**
```cpp
#include<cstdio>
#include<iostream>
const int N=1000;
char a[N+1],b[N+1];
int c[N],d[N];//c和d分别记录a和b的操作
int main()
{
	register int i,j,k,n,t;//j和k分别统计a和b的方案数
	scanf("%d",&t);
	while(t--)
	{
		scanf("%d%s%s",&n,a+1,b+1);
		j=k=0;//注意清零
		for(i=1; i<n; ++i)
		{
			if(a[i]!=a[i+1])
				c[++j]=i;//将a变成只有一种字符的字符串
			if(b[i]!=b[i+1])
				d[++k]=i;//将b变成只有一种字符的字符串
		}
		if(a[n]!=b[n])//如果两个字符串不一样，那么就要对整个字符串操作一次
			c[++j]=n;
		printf("%d ",j+k);//输出方案数
		for(i=1; i<=j; ++i)
			printf("%d ",c[i]);//输出a的操作
		for(i=k; i; --i)
			printf("%d ",d[i]);//倒着输出b的操作
		putchar('\n');
	}
	return 0;
}
```