首先感谢Timor的题解提供思路

主要思路Timor也说了，就像10转2一样，连续求余然后将余倒序输出

但是负数进制会有一些问题，比如每一位出现负数

然后我有一个小问题，有些题解的说负数模负数需要特殊处理，但是我试的时候是正常的，Don't Know Why.

上程序以及解析

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int main( ){
    int n,m,r,i,a[101]={0},k;//n，r输入不解释，m负责存储n，i循环变量不解释，a数组是存储各位数的（就像高精度一样的），k表示转化进制后的位数 
    scanf("%d%d",&n,&r); 
    m=n;//存储n，因为之后要输出n而我中途序号改变n的值 
    for(i=1;n;i++){//初步转化进制并存入a数组 
        a[i]=n%r;
        n/=r;
        k=i;
    }
    for(i=1;i<=k+10;i++){//进位与借位，而且至少上限至少k+1，k+10是为了保险 
        if(a[i]<0){//进位，因为是负数进制，所以如果某一位小于0则需要减去一个负数，即进位 
            a[i]-=r;
            a[i+1]++;
        }
        if(a[i]>=-r){//借位，因为是负数进制，所以如果某一位大于0则需要加上一个负数，即借位
            a[i]+=r;
            a[i+1]--;
        }
    }
    for(i=100;i>1;i--)//重新算一遍k保险 
        if(a[i]!=0){
            k=i;
            break;
        }
    printf("%d=",m);//我第二遍就是没打这句被坑了，意思不解释 
    for(i=k;i>0;i--){//倒序输出 
        if(a[i]<10)//用数字表示某一位 
            printf("%d",a[i]);
        else//用字母表示某一位 
            printf("%c",a[i]-10+'A');
    }
    printf("(base%d)",r); 
    return 0;
} 
```