这道题吧，开始没想太多，以为直接跟正进制一样处理就可以了，结果啊真的是：  
垂死病中惊坐起，WA一波又一波；
 
 要想有AC，还得自己推；
  
  ~~水了这么多~~，下面是分析过程了（蒟蒻在分析的后面还有一点对负进制的想（Y）法(Y)，希望大牛们看到能多多指教，不想看的同学，直接跳到代码部分就可以了；
  
分析部分
------------
首先，对于负进制，可以照题目要求，写出类似于正进制的表达； 

如果直接用字母表达有点难表达（~~实际上是懒~~） 
我们举一个例子；

35用-3进制来表示可以写作： _1 2 1 1 2_    

 也即1*（-3）^4+2*(-3)^3+1*(-3)^2+1*(-3)^1+2*(-3)^0  

写过二进制转换的同学大概知道对于正进制的基本转化思路：    

不断地除基数去掉右边的位数，最后递归的每一层进行一次模取基数就可以了； 

负进制的处理与此相似，只需要将除跟模进一步处理就可以了；
 
 现在重点讨论 35 的-3 进制：
 

------------
通过观察不难发现：12110（即35去掉“尾数”）可以整除-3，**而且，12110必然小于12112**，12110除以-3为1211；
 
 由此，可以推知，对于每一个数字，通过不断除以基数，可以不断地把位数“往前”缩；
  
  **那么直接利用除可不可以呢，由WA得证：不可能；  
   由于负数除法后内置计算仍然只是去掉浮点，而去浮点代表着除出来的数不一定小于真正的商，例如7除以-3得-2.5，但计算机的-2比-2.5要大，不符合我们刚才对于35的“ _必然小于_ ” 的分析，而模取也同理会受到限制，那我们就索性自己写一个除法跟模取的函数**； 
    
   **当除数乘以商不会小于或等于被除数时，把被除数减1，否则返回原来的内置运算结果**
   
   另外分（shui）析（wen）部分：

------------
考虑这样一个问题：实现负进制的加减（在不转化为十进制的情况下，应该如何进行 
 
 为什么不用负进制表示一些基本的数据呢：对于每一个数，对于的负基数表示都必然是唯一的，那么就不用纠结那些反补码表示方式了（蒟蒻觉得，可能是加减麻烦了一些了吧）；

------------

    
  考虑到模取跟除的联系，可以返回结构来处理；
 代码部分（由于代码比较简单，能理解上述分析的话代码基本能完全看懂，所有就把一些细节留给大家去发掘，不写出来了）上代码：
 

------------
```cpp
#include <bits/c++.h>
using namespace std;
char num[1000];
int j,o;
struct c_h{
	int sh;
	int mo;
	c_h(int m=0,int n=0):sh(m),mo(n){}
};
c_h chu(int n){
	c_h temp;
	int b=n/j;
	if(b*j<=n) temp.sh=b;
	else if((b+1)*j<=n) temp.sh=b+1;
	else if((b-1)*j<=n) temp.sh=b-1;
	temp.mo=n-temp.sh*j;
	return temp;
}
int o_o(int n){
	if(n!=0)o_o(chu(n).sh);
	if(chu(n).mo<10)num[o++]=chu(n).mo+'0';
	else num[o++]=chu(n).mo+'A'-10;
}
int main(){
int m=0;
cin>>m>>j;
o_o(m);
cout<<m<<'='<<num+1<<"(base"<<j<<')';
return 0;
}
```
题解部分就写到这里结束了，祝大家都能AC -0-；
