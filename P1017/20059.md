看到这一题的时候我也蒙逼了，然后我就想去用短除法去尝试，然后发现答案根本就不对啊，因为我根本就不知道短除法的原理，后面回去好好想了一想短除法转换进制的原理，发现是这样:**一个数例如11转化为2进制时是2^3+2^1+2^0，相信乘法分配律大家都知道（当然除法也一样），2^3和2^1都是可以被2整除的，只留下了最后一位不可以被2整除，那么此数取模2的数即为个位（当它可以整除2的时候就是0了嘛），现在我们再来看倒数第二位（倒数第一位刚才就这么出来了），把整个算式不可以整除2的部分减去，再除以2（就是相当于c++中的除以二向下取整，反正把最后一位舍掉了），在用刚才的方法模2又求出了倒数第二位！**但是现在我们面临的是负数进制，其实只要细心观察就可以发现，每一位都是正整数，但是%一个负数之后有可能还是负数，所以我们就要让它加上一个进制位变成正数了，于是负数进制的情况也就这样出来了，但是别忘了还要减去这个最后一位（在正数进制的时候不要减去是因为除以的时候自动地向下去整了，但是负数就不一样了），于是就可以接着这样不断地运算下去。。。现在看来，这题也不过如此。

附上代码

```cpp
#include<iostream>
#include<algorithm>
#include<cstdio>
#include<cstring>
#include<cmath>
using namespace std;
int main()
{
    int n,r,b,ans[100]={0},node;
    scanf("%d%d",&n,&r);
    b=n;
    node=1;
    while(abs(b)!=0)
    {
        ans[node]=(abs(r)+b%r)%abs(r);//这是关键！！将数取模并且改变正负！！！
        b-=ans[node];
        b/=r;
        node++;
    }
    printf("%d=",n);
    for(int i=node-1;i>=1;i--)
    {
        if(ans[i]>=10)printf("%c",'A'-10+ans[i]);
        else printf("%d",ans[i]);
    }
    printf("(base%d)",r);
    return 0;
}
```