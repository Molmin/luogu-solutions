# 解答一下大佬不愿意讲的点
我们都知道，首先按照**10进制转成n进制**的做法：

**对这个数不断除以n，将余数一一存储，最后倒序输出。**

那么有一个问题，此处原数和进制数都有可能为负数，也就意味着**余数可能为负数**，那么我们不可能输出像-100-100这种数。

### 那么怎么把负数转成正数？

我们基本思路分两点：

1. **把负数转成符合n进制余数规律的正数**
1. **让转得的正数符合余数的计算模式**


------------
1. **把负数转成符合n进制余数规律的正数**

我们先来探讨一下二进制余数的规律：
| 0 | 1 | 2 |  3| 4 |5  |6  | 7 |
| -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: |
| 0 | 1 | 0 |1  |0  | 1 | 0 | 1 |
那么规律就是0101010101……

那么我们只需让负数余数规律也为010101……，就解决了。

我们发现，每一组数，他们对应的**间隔区间内的数是相等的**。那么我们只需跳到它前面一个区间的数即可，因为区间长度为-m,（m为进制）。那么就转换成：

### j-=m（j为原先算出来的负数，m为进制数）



------------
1. **让转得的正数符合余数的计算模式**

光转成正数还不够，因为还不符合余数的计算。

众所周知，我们令n为被除数，m为除数和进制数,a为商,j为余数，可以得到：
### n/m=a
### n-a*m=j

根据我们刚刚推得的算法：**j-=m**，那么此时方程2两端同时减去m，得
### n-a*m-m=j-m
提公因式，得
### n-(a+1)*m=j-m
但我们还要让j-m符合余数计算模式，即符合**n-a*m=j**的形式。

显然，此时a=a+1正好符合n-a*m=j的形式。所以：

### n++（此时n已经/=m）

```cpp
#include <iostream>
using namespace std;
int n,m;
char a[100001];
int l=0;
int main(){
	int i;
	cin>>n>>m;
	cout<<n<<"=";
	while(n!=0){
		int j=n%m;
		n/=m;//十进制转n进制
		if(j<0)j-=m,n--;//讲解的点
		if(j<10)a[++l]=(char)(j+48);
		else a[++l]=(char)((j-10)+'A');//两种不同的转法
	}
	for(i=l;i>=1;i--)cout<<a[i];//倒序输出
	cout<<"(base"<<m<<")"<<endl;
}
```
