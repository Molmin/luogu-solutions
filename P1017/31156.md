检查本题，显然用普通短除法是没有办法解的


观察基为-2时的头几个数字

-2
0    0
1    1
10    -2

11    -1

100    4

101    5

110    2

111    3

没什么规律


再用短除法试试？

3  / -2 = -2 ...... 1

-2 / -2 =  1 ...... 0

1  /  2 =  0 ...... 1

观察一下，这里是说

3 = 1\*(-2)^2 + 0\*(-2) + 1\*(-2)^0

不对劲把，应该是

3 = 1\*(-2)^2 + 1\*(-2) + 1\*(-2)^0

再试下5

```cpp
5  / -2 = -3 ...... 1
-3 / -2 =  2 ...... 1
 2 / -2 = -1 ...... 0?
-1 / -2 =  0 ...... 1?
```
这个更加离谱，到底哪里有问题？

短除法本质上什么，是凑数吧？

只不过以前的凑数是一直减，现在这个，因为负数的引入，有减有加而已

对于3来说


3 - 1 = 2    这是第一位

2 + 2 = 4    这是第二位

4 - 4 = 0    这是第三位

5的情况类似

5 - 1 = 4

4 + 2 ? no need    只不过第二位没有需求

4 - 4 = 0

看到这个-1+2-4实际上是按基数递增的吧？所以每次可以用整除的方式取得数字

我们实际要做的就是每次把数据凑成可以整除就行了，调整的数值就是余数（本位的数字）

2^2 - 2 + 1


3 / 2 = 2 ...... 1

2 / 2


先试一下第一个测试用例

30000 -2

调整后      整除的值 余数

30000  -1 ? no need 15000    0

15000 +1 ? no need 7500    0

7500    -1 ? no need 3750    0

3750   +1 ? no need 1875    0

1875    -1 1874        937        1

937     +1 938          469        1

469      -1 468          234        1

234     +1 ? no need 117        0

117      -1 116          58        1

58       +1 ? no need 29        0

29        -1 28            14        1

14       +1 ? no need 7        0

7          -1 6              3        1

3         +1 4              2         1

2          -1 ? no need 1        0

1         +1 2              1        1

1          -1 0              0        1


11011010101110000

没错

负数的处理方式和正数类似

-20000 -2


调整后      整除的值    余数

-20000  -1 ? no need -10000        0

-10000 +1 ? no need -5000        0

-5000    -1 ? no need -2500        0

-2500   +1 ? no need -1250        0

-1250    -1 ? no need -625        0

-625     +1 -624         -312        1

-312      -1 ? no need -156        0

-156     +1 ? no need -78            0

-78        -1 ? no need -39            0

-39       +1 -38          -19            1

-19        -1 -20          -10            1

-10       +1 ? no need -5            0

-5          -1   -6      -3            1

-3         +1   -2      -1             1

-1          -1   -2      -1             1

-1         +1   0       0                    1


1111 0110 0010 0000

1111 0110 0010 0000

没有问题，看来只要一直当他负数处理即可



接下来试一下基数更大的情况

28800 -16

调整后  整除的值 余数

28800 -?   no need 1800        0

1800  +?   1808     113        8    1800%16=8，所以用1800+8=1808

113     -?   112       7        1    113%16=1，减，所以是113-1=112

7        +?   16         1        9    7%16=7，但因为是加，实际要用16-7=9

1         -?   0           0        1    减1即可


19180

负数的情况比较复杂

-25000 -16

调整后  整除的值 余数

-25000 -?  -25008  -1563    8    -25000%16=-8，但实际我们需要的时正数啊怎么办？还是回到原始定义

-1563  +?  -1552    -97        11    -1563%16=-11

-97       -?  -112      -7        15    -97%16=-1

-7        +?  0           0        7    -7%16=-7

7FB8
负数的实际加减方向相反了吧？ 重新调整

调整后  整除的值 余数

-25000 +?  -25008  -1563    8    -25000%16=-8，但实际我们需要的时正数啊怎么办？就当实际是正数来处理咯,16-8=8

-1563    -?  -1552   -97        11    -1563%16=-11，当正数来处理

-97       +?  -112    -7        15    -97%16=-1，-16-(-1)=-15

-7          -?  0          0        7    -7%16=-7，当正数来处理


具体代码如下：

```cpp
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <math.h>


const char digitChar[20] = {'0', '1', '2', '3', '4', 
                            '5', '6', '7', '8', '9',
                            'A', 'B', 'C', 'D', 'E',
                            'F', 'G', 'H', 'I', 'J'};
int result[30];    //无论如何都够了
int szResult; 

int main()
{
    int N, base;
    int originalNumber;
    int curDigit;
    int direction;
    
    scanf("%d%d", &N, &base);
    originalNumber = N;
    
    szResult = 0;
    if (N > 0)
        direction = -1;    //待转换数是正数，一开始都是负的，也就是要在原值上减 
    else
        direction = 1;    //待转换数是负数，一开始都是正的，也就是要在原值上加 
    if (base < 0) base = -base;    //我们做取模的时候都要用正数 
    while (N != 0)
    {
        if (N > 0)
        {
            //正数如此处理 
            curDigit = N % base;    
            if (curDigit != 0 && direction > 0)    //负数（正常）用取模值，正数（负基数特有）要用基数-取模值
                curDigit = base - curDigit;            
        }
        else
        {
            //负数的策略不同，该死的取模出来会有负数
            curDigit = N % base;
            if (curDigit != 0 && direction > 0)    //负数（正常）用取模值，正数（负基数特有）要用基数-取模值
                curDigit = -base - curDigit;            
        } 
            
        N = N + direction * curDigit;
        if (curDigit < 0)
            result[szResult] = -curDigit;    //计数的时候都要当正数来记录
        else
            result[szResult] = curDigit;    //计数的时候都要当正数来记录 
        szResult++;
        
        N = N / base;
        direction = -direction;        
    }
    
    printf("%d=", originalNumber);
    for (int i = szResult - 1 ; i >= 0 ; i--)
        printf("%c", digitChar[result[i]]);
    base = -base;
    printf("(base%d)\n", base);
    
    return 0;
}
```