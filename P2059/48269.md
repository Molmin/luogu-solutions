【题目描述】

$n$个人坐成一圈玩游戏。一开始我们把所有玩家按顺时针从$1$到$n$编号。首先第一回合是玩家$1$作为庄家。每个回合庄家都会随机（即按相等的概率）从卡牌堆里选择一张卡片，假设卡片上的数字为$x$，则庄家首先把卡片上的数字向所有玩家展示，然后按顺时针从庄家位置数第$x$个人将退出游戏。然后卡片将会被放回卡牌堆里并重新洗牌。被处决的人按顺时针的下一个人将会作为下一轮的庄家。那么经过$n-1$轮后最后只会剩下一个人，即为本次游戏的胜者。现在你预先知道了总共有$m$张卡片，也知道每张卡片上的数字。现在你需要确定每个玩家胜出的概率。

这里有一个简单的例子：

例如一共有$4$个玩家，有四张卡片分别写着$3,4,5,6$。

第一回合，庄家是玩家$1$，假设他选择了一张写着数字$5$的卡片。那么按顺时针数$1,2,3,4,1$，最后玩家$1$被踢出游戏。

第二回合，庄家就是玩家1的下一个人，即玩家$2$。假设玩家$2$这次选择了一张数字$6$，那么$2,3,4,2,3,4$，玩家$4$被踢出游戏。

第三回合，玩家$2$再一次成为庄家。如果这一次玩家$2$再次选了$6$，则玩家$3$被踢出游戏，最后的胜者就是玩家$2$。

【输入输出格式】

- 输入格式

第一行包括两个整数$n,m$分别表示玩家个数和卡牌总数。

接下来一行是包含$m$个整数，分别给出每张卡片上写的数字。

- 输出格式

输出一行包含$n$个百分比形式给出的实数，四舍五入到两位小数。分别给出从玩家$1$到玩家$n$的胜出概率，每个概率之间用空格隔开。

【输入输出样例】

- 输入样例$1$

```
4 4
3 4 5 6

```

- 输出样例$1$

```
25.00% 25.00% 25.00% 25.00% 
```

- 输入样例$2$

```
5 5
2 3 5 7 11

```

- 输出样例$2$

```
22.72% 17.12% 15.36% 25.44% 19.36% 
```

【数据范围】

对于$30$%的数据，有$1 \leq n \leq 10$；

对于$50$%的数据，有$1 \leq n \leq 30$；

对于$100$%的数据，有$1 \leq n \leq 50$，$1 \leq m \leq 50$，$1 \leq $每张卡片上的数字$ \leq 50$。

思路：这道题目很明显可以通过枚举来确定最后的胜利者是谁。然后我们就可以根据所有的结果来分析每一个人的胜率了。下面我将举出一个$n=2,m=3$的例子：
```
2 3
1 2 3

```

第$1$种情况：$1$号拿了$1$号卡牌，上面的数字是$1$。因此$1$号出局，$2$号胜利。

第$2$种情况：$1$号拿了$2$号卡牌，上面的数字是$2$。因此$2$号出局，$1$号胜利。

第$3$种情况：$1$号拿了$3$号卡牌，上面的数字是$3$。因此$1$号出局，$2$号胜利。

根据上面的结果，我们发现：$1$号赢了$1$次，$2$号赢了$2$次。因此$1$号的胜率为$\frac{1}{3}$，$2$号的胜率为$\frac{2}{3}$。将$1$号和$2$号的胜率四舍五入到两位小数时他们的胜率分别为$33.33$%和$66.67$%。$dfs()$的复杂度是$O(m^n)$的，感谢各位大佬提醒！

那么我们怎样才能够进一步地优化我们的程序呢？

其实我们可以使用一种叫做概率动态规划的算法，即我们常说的**概率DP**。

我们可以用概率DP来解决这个问题。我们可以用$f[i][j]$来表示在还剩下$i$个人时，从庄家开始数第$j$个人的获胜的概率。其实还有一种时间复杂度约为$O(\sum_1^{n-1}\sum_{j=1}^n\sum_{k=1}^{n-i} {m})$的一种方法，在这里我就不做介绍了，在这篇文章中我只介绍上面的这种时间复杂度约为$O(mn^2)$的一种办法。

首先我们可以确定当还有$1$个人时第$1$号的胜率为$100$%，即$1.0$。我们不难发现$f[i][]$的状态可以从$f[i-1][]$中转移过来。那么怎么转移我们的$f$数组呢？

> 我们可以首先枚举庄家抽到的卡牌$k$，得到这一轮被淘汰的人的位置$c$。当然，如果$c=j$ ，就不要考虑了（因为这表示此轮第$j$个人被淘汰）。

> 而第$c$个人被淘汰之后，剩下的$i-1$个人要组成一个新的环，庄家为第$c$个人的下一个。容易算出，当$c>j$时，第$j$个人是新的环里从新庄家数起的第$i-c+j$个人，当$c<j$时，第$j$个人是新的环里从新庄家数起的第$j-c$个人。

上面的引用部分里的内容摘自[@xyz32768的博客](https://www.luogu.org/blog/user29936/)，放入题解时有删改。

因此我们可以得出状态转移方程：

当$c>j$时，$f[i][j]=f[i][j]+f[i-1][i-c+j] \div m$，即$f[i][j]=f[i][j]+\frac{f[i-1][i-c+j]}{m}$；

否则当$c<j$时，$f[i][j]=f[i][j]+f[i-1][j-c] \div m$，即$f[i][j]=f[i][j]+\frac{f[i-1][j-c]}{m}$。

其中，$j \leq i$会更加优，感谢@Yunxuan的建议。

下面上$100$分（满分）代码：

```cpp
#include <cstdio>
double f[1001][1001];
int a[10001];
int main()
{
	int n=0,m=0;
	scanf("%d %d",&n,&m);
	for(int i=1;i<=m;i++)
	{
		scanf("%d",&a[i]);
	}
	f[1][1]=1.0;
	for(int i=2;i<=n;i++)
	{
		for(int j=1;j<=i;j++)
		{
			for(int k=1;k<=m;k++)
			{
				int c=(a[k]%i!=0)?(a[k]%i):i;
				if(c>j)
				{
					f[i][j]+=f[i-1][i-c+j]/m;
				}
				else if(c<j)
				{
					f[i][j]+=f[i-1][j-c]/m;
				}
			}
		}
	}
	for(int i=1;i<=n;i++)
	{
		printf("%.2lf%% ",f[n][i]*100.0);
	}
	return 0;
}
```