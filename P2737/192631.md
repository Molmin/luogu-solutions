### 题意简述

给你 $n$ 个正整数 $a_1, a_2, \cdots, a_n$，求不能用 $p_1a_1+p_2a_2+\cdots+p_na_n (p_1, p_2, \cdots, p_n\geq 0\text{且}p_1, p_2, \cdots, p_n\text{均为整数})$ 表示的最大整数。

### 算法思路分析

#### 考场上不会像其他题解一样推式子怎么办？

因为每一个数使用的次数没有限制，可以选择任何一个非负整数个，所以可以使用完全背包解决。具体完全背包算法请见 [P2722 [USACO3.1]总分 Score Inflation](https://www.luogu.com.cn/problem/P2722)，这是一道模板题。

我们可以发现，这题也和装箱问题很像，都是“能不能凑出”的问题，所以可以把上述两道题的算法融合一下，暂且称之为“布尔型完全背包”。

但是，我们看到数据范围，最大可以到 $2\times 10^9$，背包问题的复杂度是 $O(nm)$，肯定超时，数组也开不下。如果你数学很差，在考场上看到这么大的数据范围怎么办呢？

我们知道，计算机大约在一秒内可以完成 $10^8$ 次运算，也就是不考虑常数的话，循环最多只能有 $10^8$ 次。我们这题中，$1\leq n \leq 10$，背包问题的 $m$ 最多就到 $\dfrac{10^8}{10}=10^7$，因此我们可以得出：如果此题完全背包是正解，那么开 $10^7$ 的数组肯定能AC~~结果我的 $10^7$ 数组的代码交上去真的AC了~~。

所以，在数据范围非常大的时候，我们可以利用计算时间复杂度的方法算出到底需要多少数组。比如回文质数那题，$10^8$ 在 $1s$ 内很难跑完，那么不用数论知识分析，也可以猜到那题开 $10^7$ 的数组也能过。

当然，此题其实是运气好，正解就是完全背包。那么其它题解中的式子是怎么推出来的呢？

#### 小奥推式子

首先要判断什么情况下答案是$0$。也就是说，永远都有空隙。小奥告诉我们，只有当 $\gcd(a_1, a_2, a_3, \cdots, a_n)=1$时，才能有最大的不能被表示出的数。所以，读入完直接处理这种情况。

根据之前做过的一道数论题小凯的疑惑，可以知道两个数 $x, y$ 不能用 $ax+by$ 表示出来的最大整数的公式是 $xy-x-y$ 具体证明那题题解里已经有了，非常详细。

这篇题解主要讲解了在考场上因为各种原因导致没有推出来公式的情况下应该如何利用数据范围降低难度。虽然感觉有点无赖，但是确实这招还是挺好用的。

核心代码：
```cpp
for(int i = 2; i <= 255; i ++)
	{
		bool flg = true;
		for(int j = 1; j <= n; j ++)
			if(w[j] % i != 0)
			{
				flg = false;
				break;
			}
		if(flg)
		{
			printf("0");
			return 0;
		}
	}
		
	dp[0] = true;
	for(int i = 1; i <= n; i ++)
		for(int j = w[i]; j <= MR; j ++)
			dp[j] |= dp[j - w[i]];
			
	for(int i = MR - 5; i >= 0; i --)
		if(!dp[i])
		{
			printf("%d", i);
			return 0;
		}
```
