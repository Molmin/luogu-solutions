~~请无视本博客的名字~~

这题第一眼看八成就是个单调队列或贪心，毕竟都是类似员工和老板（老板要有一个条件选员工，年龄不超过某值，并是另一维度最优的一个）模型嘛。

首先理解一下题意：要去几周才可以吃遍整个菜单，可以理解成每个人和手吃几次才可以吃遍整个菜单。

假设问题是要我们求出每个人吃 $x$ 次能不能吃遍整个菜单。顺着题意我们可以把所有人分成三类：

- 挑剔的仁 总共 $p$ 个

- 贫穷的仁 总共 $q$ 个

- 普通的仁 总共 $n-p-q$ 个，总共可以吃 $x(n-p-q)$ 道菜。

显而易见，有贪心策略是：先让挑剔的仁把菜单中贵的食物捡了吃了，再把剩下的食物给贫穷的仁捡了吃了，最后再把剩下吃不完的食物给普通的仁吃。

将挑剔者的挑剔程度、贫穷者的容忍程度和美食（按照美味程度）从大到小排序，假设依次考虑到一个挑剔的仁，现在菜单上的没有吃过菜中有且仅有他什么都可以吃的下肚的，那么肯定是优先将价格大的吃掉（优先、价格大，种种迹象表明我们需要用大根堆），吃 $x$ 个或者吃到菜单没有没吃过的菜了（干饭，从大根堆中删数）。因为现在菜单上的菜自己能吃下肚，那么自然在他后面的人也能吃下肚，没有什么自己贪了一点小利，就会失去大局的地方（因为没有处理掉的，仍旧可以给后边的人处理），但是反之不然，所以根据我们的贪心策略，就要这么做。

怎么维护现在的菜单呢？我们可以使用两条指针（不是真的指针，你可以想象一下。正所谓“扫数组”，就像是抽奖时指针扫过奖励栏一样）把挑剔程度和菜单的菜的数组扫一遍，每扫一个菜单的菜之前，把所有指针后边的挑剔程度大于这道菜的美味成都的挑剔者（即吃不下这道菜的仁）进行操作，再将这道菜加入菜单，事实上就是将其价格打入大根堆中。

接下来就是看贫穷者。再使用一条指针正向扫一遍容忍程度数组，由于这些人对价格都是越来越不能容忍，所以如果菜单上的一样菜没有被吃掉（从大根堆里删掉），且价格已经大于扫到的某个人的容忍程度了，那么这样菜就更不可能被这个人后边的人容忍，也不必保留，直接删掉并且计入贫穷者处理不掉的数量了。删掉符合条件的菜之后，这个贫穷者按着挑剔者同样的方式干饭删数就行了。

最后就是普通仁了。最后不能被处理掉的菜品数量就是贫穷者处理不掉的数量+最后大根堆中还剩下的菜品数量，与所有普通仁和手能吃的菜品数量 $x(n-p-q)$ 作比较，即可知道每人吃 $x$ 次能吃遍整个菜单的可行性了。

可想而知，这题是个二分答案+大根堆题。

时间复杂度 $O(m\log^2m)$，开 $O(2)$ 就过了。

代码放了好了，麻风丑请勿喷o\_o

```
#include<bits/stdc++.h>
#define maxn 50005
#define maxm 200005
#define int long long
#define F(_i,_j,_k) for(int _i=_j;_i<=_k;_i++)
#define AF(_i,_b) for(;_b;_i++)
#define W(_b) while(_b)
using namespace std;

struct veg{
	int grt,prc;
	bool operator<(const veg&C)const{
		return grt>C.grt;
	}
}a[maxm];

int n,m,p,q,b[maxn],c[maxn],L=0,R=maxm;

signed main(){
	cin>>n>>m>>p>>q;
	if(m==0){
		cout<<0;
		return 0;
	}
	F(i,1,m)cin>>a[i].grt>>a[i].prc;
	F(i,1,p)cin>>b[i];
	F(i,1,q)cin>>c[i];
	sort(a+1,a+m+1);
	sort(b+1,b+p+1);
	reverse(b+1,b+p+1);
	sort(c+1,c+q+1);
	reverse(c+1,c+q+1);
	W(L<R-1){
		int tot=1,mid=(L+R)/2,cnt=0;
		priority_queue<int>Z;
		F(i,1,m){
			AF(tot,tot<=p&&b[tot]>a[i].grt){
				F(o,1,mid){
					if(Z.empty())break;
					Z.pop();
				}
			}
			Z.push(a[i].prc);
		}
		AF(tot,tot<=p){
			F(o,1,mid){
				if(Z.empty())break;
				Z.pop();
			}
		}
		F(i,1,q){
			W(c[i]<Z.top()&&Z.size()>0){
				Z.pop();
				cnt++;
			}
			F(o,1,mid){
				if(Z.empty())break;
				Z.pop();
			}
		}
		if((n-p-q)*mid>=cnt+Z.size())R=mid;
		else L=mid;
	}
	if(R==maxm)cout<<-1;
	else cout<<R;
	return 0;
}
```

先祝大家六一儿童节刷题快乐啊！