#### Hello,大家好,今天本蒟蒻又给大家奉献一篇题解.(感谢我的师兄们给我的赞助)


------------
# **好的,转入题目**

### 首先,我们看到这个题或许有一些慌.不要怕,让我们先分析一波.

### 题目已经说了,有些两位数比如:21可以译为U或者BA.

### 那么,只要大于等于11小于等于26(英文字母只有26个)的数都可以拆着译.

# 所以!!! 
### 由上可以得出一般的递推式f[i]=f[i-1]+f[i-2].

------------

#### 但是,如果有一个数等于0,比如20.那么20就无法拆开译(因为0不能独立译).

### 因此当一个数等于0,f[i-1]就可以忽略了,即f[i]=f[i-2].


------------
### 剩下的情况就是f[i]=f[i-1]了


------------
### 所以,这是一道很简单的递推题.
# 

------------
## 那么就上代码吧

```cpp
#include<bits/stdc++.h>
using namespace std;
char a[10001];
long long b[10001];
int main()
{
	while(cin>>a+1)//输入a+1可以更方便,循环可直接从1开始,记住strlen中的内容也要加1
	{
		memset(b,0,sizeof(b));//因为要重复输入,所以要赋初值
		b[0]=1;//递推边界
		int n=strlen(a+1);
		if(n==1&&a[n]=='0') break;//输入1个0结束程序
		for(int i=1;i<=n;i++)
		{
			if(a[i]=='0')
			{
				b[i]=b[i-2];
			}
			else
			{
                		if(a[i-1]=='1'||a[i-1]=='2'&&a[i]<='6'&&a[i]>='0')
			    	{
				    b[i]=b[i-1]+b[i-2];
			    	}
                    		//也可以用(a[i]-'0')*10+(a[i-1]-'0')判断是否大于等于11,小于等于26
				else
				{
					b[i]=b[i-1];
				}
			}
		}
		cout<<b[n]<<endl;
	}
	return 0;//完美结束
}
```

