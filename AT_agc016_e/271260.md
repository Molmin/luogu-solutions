**前言**

------------

评分虚高，此题解只是提供这种数据过小导致一道题方法大幅度改变的暴力方法。

**分析**

------------

首先我们对于此题进行最朴素的暴力，得到思路如下：

首先枚举第 $i$ 和第 $j$ 只火鸡，那么从头到尾进行选择，当遇到 $i,j$ 和其它的火鸡进行选择的时候，我们就去掉那只火鸡。如果此时那只火鸡已经被吃，就往前寻找有没有方法能使这只应当被杀的火鸡存活。

这里不分类细讲，因为这种方法很明显是严重超时的，并且难以实现。

仔细思考，删除问题的解决方法都有倒着枚举命令，这样我们就能免去拯救已经被吃的火鸡的时间了。留给我们倒着枚举的时间复杂度是 $O(m)$ 的，也就是说我们需要线性解决每对火鸡是否可行。

继续沿用删除问题的思路，我们在最后一定保留第 $i$ 和第 $j$ 只火鸡，那么每次于与它们进行选择的火鸡一定要活到那时候，我们就记录这只火鸡，让它享受和第 $i$ 和第 $j$ 只火鸡相同的待遇。如果出现两只火鸡都不能被吃的情况，那么就不计入最终答案。

那么代码就确定了，虽然在此时还可以继续优化，但是因为出题人的失误，导致我们的暴力做法也能通过此题，那么我们可以直接暴力跑路，为后面的题目留更多时间。

**code**

------------

```
#include<bits/stdc++.h>
using namespace std;
const int MAXN=4e2+5,N=1e5+5;
int n,m,x[N],y[N],ans;
bool h[MAXN];
int main() {
	scanf("%d %d",&n,&m);
	for(int i=1;i<=m;++i) scanf("%d %d",&x[i],&y[i]);
	for(int i=1;i<=n;++i) {
		for(int j=i+1;j<=n;++j) {
			memset(h,0,sizeof(h));
			h[i]=h[j]=1;
			for(int k=m;k>=1;--k) {
				if(h[x[k]]&&h[y[k]]) {
					--ans;
					break;
				}
				if(h[x[k]]) h[y[k]]=1;
				if(h[y[k]]) h[x[k]]=1;
			}
			++ans;
		}
	}
	printf("%d",ans);
	return 0;
} 
```