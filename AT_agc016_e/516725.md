# [AT_agc016_e](https://atcoder.jp/contests/agc016/tasks/agc016_e) [Poor Turkeys](https://www.luogu.com.cn/problem/AT_agc016_e)

题意
---
不需要解释了吧，直接跳过

---

思路
---

我提供一个很神奇的做法，时间复杂度为 $O(N^2M)$，看样子超时，但是常数特别的小，在随机数据下常数几乎为 $0$，然后我就过了这道题。

我们可以枚举每一对 $(i, j)$，看看能不能全部活下来，然后记录一下对数就可以了。

怎么判断能不能都活下来呢？我们可以用**倒推法**。

我们从最后一个人开始判断。一开始，我们选中的 $(i, j)$ 两只鸡都是要**被保护的**~~，因为死了就结束了~~，如果这个人选的那两只鸡就是被保护的，那么他就算 S 哪一只都会导致后面一定会 S 掉 $(i, j)$，这时直接结束判断。如果这个人选的只有一只是被保护的，那么他只能 S 另外一只，也就是前面的人都不能 S 这只鸡，即我们可以把另一只也设成要被保护的。如果把每个人都判断一遍，都可以不把被保护的鸡 S 掉，那么 $(i, j)$ 就能都活下来。

那么接下来就是实现部分了。

大家可以参考一下代码。

[AC Code](https://www.luogu.com.cn/record/92729866)
---

```cpp
#include <iostream>
using namespace std;

int v[405]; // 保护数组
int a[100005]; // 那个人选的第一只鸡
int b[100005]; // 第二只“只因”

int main()
{
	int n, m;
	cin >> n >> m;
	for (int i = 1; i <= m; i++)
	{
		cin >> a[i] >> b[i];
	}
	int cnt = 0;
	int add;
	for (int i = 1; i < n; i++)
	{
		for (int j = i + 1; j <= n; j++) // 强行枚举
		{
			add = 1;
			for (int k = 1; k <= n; k++) // 清零
			{
				v[k] = 0;
			}
			v[i] = v[j] = 1; // 被保护
			for (int k = m; k >= 1; k--)
			{
				if (v[a[k]] && v[b[k]]) // 都被保护了
				{
					add = 0; // 那就活不下来
					break;
				}
				if (v[a[k]]) // 保护另一只
				{
					v[b[k]] = 1;
				}
				else if (v[b[k]])
				{
					v[a[k]] = 1;
				}
			}
			cnt += add; // 如果循环正常退出，证明可以都活下来，加1，否则活不下来，加0。
		}
	}
	cout << cnt << endl; // 结果
	return 0;
}
```

写在最后：测试点最长时间为 $1.17s$，远远没有限制的 $2s$。这个方法是可以过的。
