## Step.0 风雨前的检查

（报告重题）

此题与 [P7256 [COCI2019-2020#6] Konstrukcija](https://www.luogu.com.cn/problem/P7256) 重复，而同场比赛其他题目题号多与本题题号相连，大概也许可能是 P7256 多余了。

----

这道题就很不厚道，不仅比较考脑壳，而且还把题目描述粉饰了一道，读题也耗费了不少功夫。

## Step.1 始自理解的征途

  1. 在一张有向无环图上，定义了「有序数组」，满足数组中每个结点都有到下一个结点的一条路径。实际上，可以理解为，有序数组就是一条路径上结点排列的一个子序列。
  2. 定义了有关有序数组的函数 $\operatorname{len}(C)$ 表示 $C$ 的结点个数。
  3. 定义了有关有序数组的函数 $\operatorname{sgn}(C)=(-1)^{\operatorname{len}(C)+1}$。也就是，当 $C$ 所包含的结点个数为奇数时 $\operatorname{sgn}(C)=1$，为偶数时 $\operatorname{sgn}(C)=-1$。
  4. 定义了有关两点 $x,y$ 的函数，$\operatorname{tns}(x,y)$ 表示所有从 $x$ 开始，到 $y$ 结束的有序数组的 $\operatorname{sgn}$ 值之和。
  
题目要求构造一张 DAG，使得 $\operatorname{tns}(x,y)=K$，$K$ 是给定的数。

比如说我们看一张 DAG。

![](https://cdn.luogu.com.cn/upload/image_hosting/dc9t2yec.png)

这里 $[1,2,5],[1,3,4,5],[1,3,5]$ 都是从 $1$ 开始，到 $5$ 结束的有序数组，但不仅仅是这些。

如上所述，我们可以将一个有序数组看成一条路径上结点序列的 一个子序列，比如 $[1,2,5]$ 就可以看成路径 $1\rightarrow2\rightarrow4\rightarrow5$ 的一个子序列，$[1,3,5]$ 既可以看成 $1\rightarrow3\rightarrow5$ 的子序列，也可以看成是 $1\rightarrow3\rightarrow4\rightarrow5$ 的子序列。这样同属于两条路径的有序数组，也是需要处理的比较关键的一点。

同时，因为是 DAG，所以结点是有拓扑先后顺序的，因此这样相邻两点之间存在路径的这一条件，严格转化为了整个有序数组串出了一条路径。

相信聪明的你已经理解了生成有序数组的充要条件，并且知道了有序数组与路径的关系。

## Step.2 从特殊到一般——链的情况

我们不妨先不讨论存在分支的 DAG，首先观察一下一条链的情况。

![](https://cdn.luogu.com.cn/upload/image_hosting/49tlji4k.png)

因为不存在分支，也就是从 $1$ 到 $5$ 仅存在一条路径，那么就可以肆意地在这条路径上讨论啦。

显而易见的是，对于中间的 $2,3,4$ 号结点，在取与不取之间选择，就可以生成 $2^3=8$ 个有序数组。推广至一般情况，对于有 $n$ 个结点的一条链，可以生成 $2^{n-2}$ 个有序数组。

然后考虑我们的 $\operatorname{tns}$ 函数，很明显可以通过计算奇数个元素的有序数组的个数，偶数个元素的有序数组个数，两者相减，但这样是没有前途的，而且时间复杂度也比较不太优秀。

试想，如果我们得到一个有序数组，并且其包含的中间结点均在 $[2,x]$ 之间，它的 $\operatorname{sgn}$ 值为 $x$，而在下一步也就是 $x$ 号结点以后，如果要选择一个结点加入有序数组，那么我们的 $\operatorname{sgn}$ 值将变为 $-x$。

为了方便表述，我们用 $W_{x,y}$ 表示中间结点均在 $[x,y]$ 之间的有序数组集合，包含无中间结点的有序数组。

那么有一种 DP 的思路，用 $f_i$ 表示中间结点均在 $[2,i]$ 之间的有序数组所产生的 $\operatorname{sgn}$ 值之和，用 $g_i$ 表示中间结点均在 $[2,i]$ 之间且包含 $i$ 的有序数组所产生的 $\operatorname{sgn}$ 值之和，那么就有 $g_i=\sum\limits_{C\in W_{1,i-1}}-\operatorname{sgn}(C)=-\sum\limits_{C\in W_{1,i-1}}\operatorname{sgn}(C)=-f_{i-1}$，$f_i=f_{i-1}+g_{i}$。

你敏锐的小脑瓜立马就发现，这不明显 $f_i=0$ 吗？确实是这样，但是接下来，正戏开场。

## Step.3 飞跃——从链窥望 DAG 的轨迹

无非就是这样。

![](https://cdn.luogu.com.cn/upload/image_hosting/xj6onm8m.png)

多了分支呗。

怎么有种似曾相识的感觉？其实是来自物理学的客人——串联与并联啦。

![](https://cdn.luogu.com.cn/upload/image_hosting/pi1rlpxk.png)

可以把结点看成定值电阻，然后由于 $1,5$ 号结点是一定要选的，所以放在电源两端。这里我们不讲电路，但一会儿会借鉴电路的思路（期待着你不用参考电路的聪明才智哦）。

我们以一张非常简单的非链的 DAG 为例，很明显存在从 $1$ 到 $5$ 存在两条路径。按照我们在 **Step.1 从理解开始的征途** 里面所讲的，我们通过两条路径生成的有序数组，独有的是选取了 $4A,4B$ 的那些有序数组，共有的是没有选取 $4A,4B$ 的那些有序数组。

这里我们将 $4$ 号结点拆成了 $4A$ 和 $4B$，如果我们将 $4A,4B$ 都看做 $4$，自然我们上面的方程就可以改为 $f_i=f_{i-1}+2g_i$。如果我们拆成了 $k$ 个结点，那么相应的有 $f_i=f_{i-1}+k\times g_i$，这是显而易见的啦。

当然我们可以把 $g_i=-f_{i-1}$ 代入进去，就可以得到 $f_i=(1-k)\times f_{i-1}$。这表示在一条链的骨架上，如果我们将一个结点拆成了 $k$ 个结点，那么在这个拓扑层次的状态转移就会是 $f_i=(1-k)\times f_{i-1}$。这说明，我们在这个拓扑层次内部拆点，只会影响当前的状态转移。

emmm，我们想到了混联电路，将每一个串联或者并联部分整体考虑，参与更高一级的混联或者串联。这里我们将拆点视为并联，然后让并联结构等效替代为一个定值电阻参与串联。

既然这样，我们既可以保证，$f_i$ 的阶段依旧有意义，并且可以通过内部 “并联” 的处理改变当前的转移方程。当然，我们可以对每个结点都进行拆点，就像这样。

![](https://cdn.luogu.com.cn/upload/image_hosting/6z9t5n3u.png)

类比混联电路。

![](https://cdn.luogu.com.cn/upload/image_hosting/ut10k7zg.png)

这里可能会有同学对拆点操作的合法性提出质疑，是不是忘了这道题其实是要求我们构造出一个 DAG 呢？拆点是一种描述性说法，表示我们构造的 DAG 可以看成一条链上的结点拆成若干结点生成的。

这样，我们对每个拓扑层次的 $f_i$，如果该拓扑层次的结点被拆成了 $k_i$ 个，那么就有 $f_i=(1-k_i)\times f_{i-1}$。思考片刻便可得知，应该初始化边界条件 $f_1=-1$，答案为 $f_{n-1}$。

到了这里，DP 的使命就结束了，我们可以直接写成

$$
\mathit{Ans}=-\prod\limits_{i=2}^{n-1}(1-k_i)
$$

我们取得了阶段性的胜利！

啊呀，这好办！将 $|K|$ 分解成几个因数 $f_1,f_2,\ldots,f_m$ 之积，除了 $1,n$ 号结点以外，中间结点放置 $m$ 个拓扑层次，每个拓扑层次放置 $f_i+1$ 个结点，相邻层次结点之间两两连边。这样我们可以得出一个 $\mathit{Ans}$，满足 $|\mathit{Ans}|=|K|$，即两者在数值上相等。如果符号不同，那么好办，在最后多放置一个 $k=2$ 的拓扑层次即可。

但是这个做法有一个致命的缺陷——如果遇到大质数，那就寄了。

## Step.4 晚会的盛大——加法的加入

我们不愿舍弃上面几近完美的算术关系式，但单纯的乘法已经不能满足题目的要求。于是，我们考虑加法。

我们稍微整理一下上面的思路，引入一些类似「阻值」的概念。不妨定义每个结点的「阻值」为 $-1$，可以总结出，并联电阻的阻值规律为 $R=\sum R_i$，串联电阻的阻值规律为 $R=\prod R_i$，最后答案为整个电路的阻值 $R$ 的相反数。

有了阻值规律，就可以随便乱搞了。可以串联套并联，并联套串联，串联套并联……每个串联或者并联结构只在作用在内部，而对外部表现的只有整体电阻的阻值。

当然，这是构造题，何必构造得那么复杂呢？太麻烦的情况交给写 SPJ 的人考虑吧。只需要知道，我们可以自由组合加法和乘法了！

这样，我们立刻想到一个常见规律，任意一个自然数都可以分解为若干不重复 $2$ 的非负整数次幂之和，以及它的经典变形，形如 $N=((1\times2+1)\times2)\times2+1)\times2+1$。也可以理解为任意自然数都有二进制表示形式。

（提示，以下内容具有一定的思维难度哦，一定要认真思考）

我们可以设想一种思路，依旧以「串联」套「并联」为骨架，对每个拓扑层次设定 $k=3$，使得每个因子均为 $-2$。在不断 $\times(-2)$ 的过程中，我们有可能需要额外 $\pm1$，这里相当于将之前串联的所有电阻整体考虑，与另外一个新的电阻并联，做完加法过后将这个并联结构整体考虑，参加下一步的串联。

听不懂？没关系。我们设在当前正在处理的拓扑层次以前，已经通过 $\times(-2)$ 和 $\pm1$ 计算出的答案为 $S$。我们分 $S$ 的正负情况讨论。

如果 $S$ 为负，$\times(-2)$ 过后变成正数，我们需要的是 $+1$，就可以这样设计。

![](https://cdn.luogu.com.cn/upload/image_hosting/o8o32eiy.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/4pm058id.png)

（关于正负号的问题，注意做乘法和加法运算之前的数应该为 $-1$，即 $f_0=-1$）

我们直接对整个串联结构并联一个定值电阻，正确性易证。

如果 $S$ 为正，$\times(-2)$ 过后变成负数，我们需要的是 $-1$，思索一下，可以这样。

![](https://cdn.luogu.com.cn/upload/image_hosting/gmzxgnbw.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/9eoz6m0u.png)

这种情况不便类比电路思考，但还是把图贴出来。

我们的做法是从 $1$ 号结点引一条边到新建结点 $3Z$，然后从 $3Z$ 引两条边到该层次 $3$ 个结点中其中 $2$ 个（图示并非真实情况）。可以这样理解，我们新增的有序数组分为三类，包含 $3Z$ 而不包含 $3A,3B$ 的，包含 $3Z,3A$ 而不包含 $3B$ 的，包含 $3Z,3B$ 而不包含 $3A$ 的。稍微思索一下可以证明其正确性。

于是，我们完成了加法的伟业。

至此，我们已经构造出了满足题意的 DAG，总结一下，思路就是以串联套并联为骨架，生成 $-2$ 因子，具体拓扑层数以 $|K|$ 的二进制位数决定。如需 $\pm1$，则分正负情况，如上述讨论。最后，如果需要，再调整一下答案的正负号（**Step.3 飞跃——从链窥望 DAG 的轨迹** 中讲过）。完成。

另外，特判一下 $K=0$ 的情况，这样设计一个 $1\rightarrow2\rightarrow3$ 的链即可。

## Step.5 回望来时的路

分析一下，我们一共需要建立 $\log_2K$ 个拓扑层次，每个拓扑层次最多放置 $4$ 个结点，因此 $N$ 最大约为 $4\log_2K$。

正数的拓扑层次，每个结点最多有 $4$ 条边到自己，负数的，每个结点最多有 $3$ 条边到自己，因此 $M$ 最大约为 $14\log_2K$。

最大时，$N$ 远不及 $1000$，$M$ 恰好在 $1000$ 以下。

时间复杂度 $O(\log K)$，随便跑。

## Step.0 结语

这个构造题还是有点思维难度的哈，多思考才能理解。

emmm，今天讲题的时候思路不太清晰，有些同学应该没听懂吧，如果你看到了这篇题解，希望能够帮助你理解这道题。

Over.

```cpp
/**                          MAIN THOUGHT
 * Regard each step as (-1).
 * Because of odd numbers of steps result in (1), we set Node 1 as (0). **/

#include <cstdio>
#include <cmath>

long long K, T, S = -1;

int N = 1, M = 0, f = 1, r = 1, u[1005], v[1005];

int main()
{
    scanf("%lld", &K);

    if (K == 0)
    {
        puts("3 2\n1 2\n2 3");
        return 0;
    }

    T = llabs(K);    // Ignore the sign, we divide it into several parts like (2^i).
    long long h = 1;
    while (h <= T) h <<= 1;
    h >>= 1;
    for (h >>= 1; h; h >>= 1)
    {
        if (S < 0)
        {
            for (int i = 1; i <= 3; ++i)    // Every time we set 3 nodes here, it brings 4 choices - do(-) for 3 and don't(+) for 1. Therefore, we get (S = S * -2).
            {
                ++N;
                for (int j = f; j <= r; ++j)
                {
                    ++M;
                    u[M] = j;
                    v[M] = N;
                }
            }
            S = S * -2;    // Then, (S) is positive.

            if (T & h)    // Just add a node, we'll get a extra (1).
            {
                ++N;
                ++M;
                u[M] = 1;
                v[M] = N;
                S = S + 1;
            }

            f = r + 1;    // All the added nodes must be used next time.
            r = N;
        }
        else
        {
            if (T & h)
            {
                ++N;
                ++M;
                u[M] = 1;
                v[M] = N;
                ++M;
                u[M] = N;
                v[M] = N + 1;
                ++M;
                u[M] = N;
                v[M] = N + 2;
            }

            for (int i = 1; i <= 3; ++i)    // As the same.
            {
                ++N;
                for (int j = f; j <= r; ++j)
                {
                    ++M;
                    u[M] = j;
                    v[M] = N;
                }
            }
            S = S * -2;    // Then, (S) is negative.

            if (T & h) S = S - 1;

            f = N - 2;
            r = N;
        }
    }

    if ((S < 0 && K > 0) || (S > 0 && K < 0))    // Wrong sign. Set two nodes to transform the sign.
    {
        for (int i = 1; i <= 2; ++i)
        {
            ++N;
            for (int j = f; j <= r; ++j)
            {
                ++M;
                u[M] = j;
                v[M] = N;
            }
        }
        f = r + 1;
        r = N;
    }

    ++N;
    for (int i = f; i <= r; ++i)    // All roads lead to Node N.
    {
        ++M;
        u[M] = i;
        v[M] = N;
    }

    printf("%d %d\n", N, M);
    for (int i = 1; i <= M; ++i) printf("%d %d\n", u[i], v[i]);

    return 0;
}
```