一道十分经典的树状数组的题目。

看到这道题目时，我莫名地想到了那道求冒泡排序操作数的题，但是这道题与那道题不同的是，这道题的对象是固定唯一的。但是我们仍然可以将其转化为冒泡排序的题。

很容易，我们能发现这个这个序列可以分为两部分，一部分是位于前段的“非有序序列”，里面包含的元素**不是一直单调递增的**。另一部分是位于后段的“有序序列”，里面的元素肯定是单调递增的。而第一部分的末尾，就是两部分的分界，也是第一问的答案。

要想求出这个分界点，我们只需从后往前枚举，保证元素从后往前递减就行了（千万不要从前往后，我刚开始就是错在这里的）。

这时候，我们考虑前半部分，那是需要操作的部分。

我们将后半部分作为参照，前半部分里每个元素作为需要移动的对象，从左往右枚举对象，一个对象需要移动的距离是其位置与分界的距离，加上在后半部分其应呆的位置与分界的距离。说起来有点绕，但是说白了就是在后半部分找到一个位置，使其前面的元素刚好小于当前对象，后面的元素刚好大于当前对象，然后用这个位置与对象的位置求取距离，这就是一个对象需要移动的距离，也就是第二问的答案。

要想快速求取后半部分中比对象小的元素，我们可以用线段树来维护，然后用求在第二部分里有多少数是小于这个对象的。

```cpp
#include<iostream>
#include<cstdio>
#define Maxn 120000
using namespace std;
typedef long long ll;
int n,num[Maxn],ans1;
struct Tree{//树状数组 
	ll tree[Maxn];
	ll lowbit(ll x){return x&(-x);}
	void add(ll i,ll x){for(;i<=n;i+=lowbit(i)) tree[i]+=x;}
	ll search(ll i){ll res=0;for(;i;i-=lowbit(i))res+=tree[i];return res;}
}t;
int main(){
	scanf("%lld",&n);
	ans1=n;
	for(ll i=1;i<=n;i++) scanf("%lld",&num[i]);
	while(ans1&&num[ans1-1]<num[ans1]) ans1--;//一定要从后往前枚举 
	ans1--;//分界是在第一部分的，而此时的 ans1 是在第二部分的临界点的，所以要跳到第一部分去 
	printf("%lld\n",ans1);
	for(ll i=ans1+1;i<=n;i++) t.add(num[i],1);//我们将第二部分存入树状数组中作为对照 
	for(ll i=1;i<=ans1;i++){printf("%lld ",ans1-i+t.search(num[i]));t.add(num[i],1);}//经典的逆序对问题 
	//移动的距离是当前位置与分界的距离加上在第二部分有多少数是小于当前对象点的
	//在处理完一个对象后，我们要将它放入后半部分中，也就是存入树状数组中 
	return 0;
}
```
