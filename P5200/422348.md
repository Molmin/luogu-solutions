
### 十分建议做这道题前把两道树状数组的模板题做好

## 题目大意

有 $n$ 个数字，按照打乱的顺序排放。你每次可以操控第一个数字，让它往后移任意位。最后要求这些数按照从小到大的顺序排列。

第一问是：最少移动几次可以移动完。

第二问是：每次移动几个。

这道题把第一小问做出来了，第二小问其实就迎刃而解了。

## 分析
本蒟蒻当然不会一下就想到正解，于是就随便拿两组数据试了试：

| 样例 | 移动次数 |
| -----------: | -----------: |
| 124356 | 3 |
| 342516 | 4 |
| 516342 | 5 |

到这里其实很多大佬已经可以看出来了，但本人毕竟还是蒟蒻，没看出来规律。因为对那些不用移动的数字特别烦感，于是决定把它们拿出来研究研究。

| 样例 |不用移动的数字| 移动次数 |
| -----------: | -----------: | -----------: |
| 124356 | 356 | 3 |
| 342516 | 16 | 4 |
| 516342 | 2 | 5 |
通过上图，本蒟蒻终于发现了其中的奥妙。
#### 不用移动的数字其实就是从结尾开始倒着看的不上升连续序列
我们来证实一下：

因为最后要排列成上升序列，并且还要移动次数最少，所以我们要把前面的数插在一个最一开始就上升的子序列里，这样就可以不用移动这个序列中原本的元素，达到最少移动的效果，但是每次只能移动第一个数字，所以这个序列必须是连续的，并且最后一位是结尾。

### 第一问就这样搞定了！
```cpp
	int ans;
	for(ans=n;a[ans]>a[ans-1];ans--){
		......
	}
	......
	cout<<ans<<endl;
```
做第二问的时候需要看这个数在第一问求出的不用移动的数字中应该排在第几位，这就用到了树状数组。

每次找到一个不用移动的数字，就在把这个数字作为下标在树状数组中加一。之后插入数字的时候只用查树状数组中有多少个比待插入的数字小的就可以得到往后移动几位了。

## 代码
代码还需要吗？

```cpp
#include<bits/stdc++.h>
using namespace std;

int t[500010],g_n,g_m;//本题不开long long 也可以

int lowbit(int x){
	return x&-x;
}
int g_a[500010];
void modify(int x,int delta){//标准树状数组函数
	for(int i=x;i<=g_n;i+=lowbit(i))
		t[i]+=delta;
}

int query(int x){
	int ans=0;
	for(int i=x;i>0;i-=lowbit(i)){
		ans+=t[i];
	}
	return ans;
}
int main(){
	cin>>g_n;
	for(int i=1;i<=g_n;i++){
		cin>>g_a[i];
	}
	int ans;
	for(ans=g_n;g_a[ans]>g_a[ans-1];ans--){//第一问
		modify(g_a[ans],1);
	}
	modify(g_a[ans--],1);
	cout<<ans<<endl;
	for(int i=1;i<=ans;i++){
		cout<<ans-i+query(g_a[i])<<" ";//这个原理上面解释了
		modify(g_a[i],1);
	}
	return 0;
}

```
