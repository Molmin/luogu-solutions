### 题目如下：
输入由几个测试用例组成，表示旅程中一晚上床位的占用情况。每一行都出现在单独的一行中，包含一系列 `.` 和 `X`（最多 $500000$ 个字符）。点表示空床，而 `X` 表示占用的床位。保证至少有一个空床和一个占用的床位。对于每个测试用例，输出一行，其中包含您可以在所选床位和最近邻之间拥有的最大可能空床位数。

### 形式化题意：
找距离相邻 `X` 最远的 `.`。

### 思路及做法：
优美的暴力模拟也许会超时（~~所以我们只需换一种更优美的~~）。

这个问题可以通过扫描字符串来解决。我们可以从左到右遍历字符串，记录当前空床位的数量和最大空床位数量，以及最近的 `X` 出现的位置。当我们遇到 `X` 时，我们可以更新最近的 `X` 位置，并将当前空床位数量重置为 $0$。当我们遇到一个空床位时，我们可以将当前空床位数量增加 $1$，并更新最大空床位数量。在遍历完整个字符串后，我们将最大空床位数量输出即可。

这种做法时间复杂度为 $O(n)$，对于题目所要求的（最多 $500000$ 个字符），完全可以直接 A 掉。

代码如下：
```cpp
#include <iostream>
#include <string>
#include <algorithm>
using namespace std;

int main() {
    string s;
    while (cin>>s) {
        int e = 0,/*空床位*/ me/*最大空床位*/ = 0, cx/*相邻空床位*/ = -1;
        for (int i = 0; i < s.length(); i++) {
            if (s[i] == 'X') {
                if (cx == -1) {
                    me = e;
                } else {
                    me = max(me, e / 2);//相邻之间的距离
                }
                e = 0;
                cx = i;
            } else {
                e++;
            }
        }
        me = max(me, e);//取最大
        cout << me-1 << endl;
    }
    return 0;
}
```