极其有趣的一道题对吧?


题意很明晰,暴力很明确,没有卡时限,但**细节不少**;

且听我娓娓道来...

------------

**尽量减少之后的麻烦！**

不如在代码里体会吧!

超多超多的注解，应该好理解的吧！

//~~我打了足足一个小时，应该够良心吧(?)~~


------------


```cpp
#include<bits/stdc++.h>
using namespace std;

int b[1005][1005];//这个数组存着二维角度俯视的各格高度；

bool chk[1005][1005][2][10];//这个数组看看有没有重复访问；
//前两维是每层的横纵坐标,后面分别是两个方向以及层数 

long long sum;//当然就是答案了；

int n,m;

int maxh=-10000;//是全部方块堆的最高高度；


//请先看看main里的内容,再看这个DFS；
void bfs(int x,int y,int h){

    if(x<n-1&&chk[x][y][0][h]==0) {
        //试着向x+1,y寻找相贴；
        //同时判断这个相贴计算了没有；
        chk[x][y][0][h]=1;
        if(h<=b[x+1][y]&&b[x][y]>=h){//这个可以判出是否相贴的对吧；
            sum-=2;
        }
        bfs(x+1,y,h);
    }
    
    if(y<m-1&&chk[x][y][1][h]==0){
        //再试着向x,y+1寻找相贴；
        //同时判断这个相贴计算了没有；
        chk[x][y][1][h]=1;
        if(h<=b[x][y+1]&&b[x][y]>=h){//同上咯；
            sum-=2;
        }
        bfs(x,y+1,h);
    } 
}
int main(){
	//按字符读会比较好处理吧,个人意向;
    register char input;
    //由于这个读入的字符很常用,就register咯；
    scanf("%d%d",&n,&m);
    
    for(int i=0;i<n;i++){
        for(int j=0;j<m;j++){
            cin>>input;
            b[i][j]=input-'0';//一定要记得减'0'啊亲!；
            maxh=max(maxh,b[i][j]);
            //这样就找出了总体的最高高度，
            //为将来的逐层的dfs提供最高层数；
            sum+=6*(b[i][j]);
            //这样统计出了所有面积，之后减去贴着的面就得到了答案；
            if(b[i][j]>1) sum-=2*(b[i][j]-1);
            //这就是我所说减少麻烦的一步：
            	//高上的垛叠造成的相贴可在输入中计算出来; 
        }
    }
    for(int i=1;i<=maxh;i++){
        bfs(0,0,i);
        //i表示层数，之前已经统计过了；
        //(0,0)表示该层起始的坐标；
        //走，去看看DFS！
    }
    
    
    printf("%lld",sum);
    return 0;
}
```


------------

看懂的小伙伴赞一个好不好(/ / /w/ / /)

不理解的一定要回复一下交流一下哦！！
