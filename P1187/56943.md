其实这道题要注意的细节还是挺多的

先说下算法吧：

首先我们可以先来造一组简单的数据
```cpp
2 2
25
52
```

由此可以画出一张俯视图：
![](https://cdn.luogu.com.cn/upload/pic/21900.png)

可能有人会问：为什么要在周围加上一圈格子呢？先别急，我们慢慢来。

我们把这四个格子想象成四个**长宽相同**的长方体，数字即为长方体高度；对于每个长方体，有前后左右四个面，计算表面积要注意的无非就是两个长方体贴在一起的情况，**贴在一起的面是不能算入表面积里的**。

对于左上角这个高度为2的长方体，前面和左面都没有长方体贴着(面积=2)，右面和后面都贴着一个比它高的长方体，则右边和后面这两个面都不能被算入表面积(即为0)。
所以现在表面积S=S+(前)+(后)+(左)+(右)=0+(2)+(0)+(2)+(0)=4      最后考虑上下两个面，则S+=2;

而对于右上角的长方体，前面和右面无其它长方体，不多说，面积分别等于(5-0)=5；左面和后面分别贴着两个比它矮的长方体，则高出的部分要算入表面积，即(5-2)=3。
则S=S+(前)+(后)+(左)+(右)=6+(5)+(2)+(2)+(5)=20，当然还有上下两个面，S+=2。

因为此长方体**对应面面积**与**长方形的高在**数值上相同，所以可以直接用高来表示面积

所以可得出规律：

 _每个位置对于任意一个面，如果 (高 -相邻长方体的高 )>0，则表面积 S+=(高 -相邻长方体的高 ),反之则 S+=0，每判断完一个位置，S+=2_ 

**当然，对于长方体在模型边缘的情况，我们可以将边缘的面看成与一个高度为0的长方体相贴，于是就有了上图中外面的一圈。这样做的优点是不用特判边缘。**

------------

**接下来，要注意的细节**

1.**读入**。由于输入的矩阵中没有空格，所以需要用字符或字符串读入，如果你选择读入单个字符的方式，请注意考虑**换行符**

2.本题模型底面积也要考虑在内，刚刚的方法里已经将其考虑进去了。

3.对于样例2中的"0"，由于其本质是"**无长方体**"，所以不应计算上下面积，即 S 在判断完四个面之后不需加 2 。

4.如果你用三视图的方法计算的话，请考虑**凹槽**，当然，本方法不需要考虑。

5.如果你用本方法，请注意，储存模型的二维数组要略大，且下标从 [1][1] 开始，原因请看分割线上方加粗字。



------------
emmm大概就是这么多了，下面放代码：
```cpp
#include<cstdio>
#include<cstring>
using namespace std;

int map[1005][1005]={0};  //储存模型 
char cache[1005];   //读入用 
int n,m;
long long S;   //表面积 

void solve()
{
	int i,j;
	for(i=1;i<=n;i++)
	{
		for(j=1;j<=m;j++)
		{
			S+=(  ( (map[i][j]>map[i+1][j])?(map[i][j]-map[i+1][j]):0 ) + ( (map[i][j]>map[i-1][j])?(map[i][j]-map[i-1][j]):0 ) + ( (map[i][j]>map[i][j+1])?(map[i][j]-map[i][j+1]):0 ) + ( (map[i][j]>map[i][j-1])?(map[i][j]-map[i][j-1]):0 ) + ((map[i][j]==0)?0:2)  );
			//套公式部分。。。具体请看思路的斜体字部分。
			//这里只是用“?:”运算符将式子弄成了一行 
		}
	}
	printf("%lld",S);    //输出表面积S 
}

int main()
{
	scanf("%d %d",&n,&m);
	int i,j,k;
	for(i=1;i<=n;i++)     //读入部分，每次读入一个字符串 ，也就是一行 
	{
		scanf("%s",cache);
		for(j=0;j<strlen(cache);j++)
		{
			map[i][j+1]=cache[j]-'0';   // j+1的问题请看 细节部分的第5条 
		}
	}
	
	solve();
	
	return 0;
}
```

结束~~~>_<