有一说一  ，这道题还蛮有意思的 ， 所以写个题解

看到这道题应该可以想到前缀和这个东东 ， 别问我为什么 ，问就是直觉 ，我们先把玩一波样例（~~这个样例太复杂了 ，我们自己整一个~~


```cpp
zdf[i].len 表示满足题目要求时此时的这个数并或不合并的最小值，若不需要合并也就是他自己本身 
```
可能略有些绕口 ，我们来推一下 ， 第一个数自然没有要求，也就是他本身 ， 第二个数我们来分类讨论 ，若第二个数 >= 第一个数 ，我们便不用将他们合并 ，也就是若sum[2] - sum[1] >= zdf[1].len ,则让 zdf[2].len = sum[2] - sum[1] （也就是不动）

但是要是第二个数 < 第一个数要怎么办呢 ？ 这时候就要把第二个数和第一个数合并 ，以此类推取一个满足条件的最小值 

![](https://cdn.luogu.com.cn/upload/image_hosting/n1swbt3j.png)

我们康康这组数据 ：可知zdf[1].len = 8 , zdf[2].len = 8 , zdf[3].len = 15 , zdf[4].len = 9

搞懂了这个奇怪的东西 ， 状态转移方程便迎刃而解了 //zdf[i].f 就是dp数组啦

dp[i] 表示前i个需要几次操作变成合法序列 
状态转移方程 ：dp[i] = dp[j] + (i - j  - 1)//也就是说再加上i+1到j需要合并的次数 

```cpp
	for (int i = 1 ; i <= n ; i++) {
		for (int j = 0 ; j < n ; j++) {
			if (sum[i] - sum[j] - zdf[j].len >= 0) {
				zdf[i].f = zdf[j].f + i - j - 1 , zdf[i].len = min(zdf[i].len , sum[i] - sum[j]) ; 
			}
		} 
	}
```
以上是核心代码

可能说的有些啰嗦了 ， 小萌新的第一篇题解 ， 希望可以给dalao们讲明白 orz 

