- DP，但可以用 $O(n^2)$ 水过

在我发这篇题解的时候，前面已经有 9 位 dalao 发过了，我本以为自己的做法肯定重了，但是一一看完之后发现自己的做法和别人还是有区别的。

**题目大意：**

可以将任意一个数“移”到与它相邻的数上，所谓“移”，就是把这个数加到与它相邻的数上，然后把这个数删掉。问最少移几次能是这个序列成为一个非降序列。

**解题思路：**

- 定义一维**前缀和**数组 $a$，$a_i$ 表示初始状态下从第 $1$ 个数到第 $i$ 个数的总和，这里直接边输入边做前缀和即可，就像这样

```cpp
for(int i=1; i<=n; i++) cin>>a[i],a[i]+=a[i-1];
```

- 状态是二维的，比较乱，可以理解为 $f_{i,j}$ 表示当前已经合并完前 $i$ 个啦，现在管的是第 $i+1$ 个，且 $i+1$ 个是第 $j+1$ 个到第 $i$ 个合成的。

- 再枚举一个 $k$ 表示在满足 $a_j-a_k\le a_i-a_j$ 并且 $f_j<f_i$ 的情况下，$f_{i,j}$ 相当于 $f_{j,k}+i-j-1$。为什么要 ```+i-j-1``` 呢，因为我们不难看出，合并的区间是 $[i,j]$，所以合并次数就是 $i-j-1$ 啦。

- ~~获得成就：~~ 结束了？当然没有！，我们可以看到，这样的话时间复杂度是 $O(n^3)$，而 $n\le5000$ 然后就 TLE 啦。

- **优化**，我们真的必须要枚举 $k$ 吗，当然不用，我们不难想到用一个数组来记录，就叫它 $fm$ 吧，一开始的 $k$ 必定是 $0$，所以 $fm_0$ 为 $0$，后面，在满足 $a_j-a_k\le a_i-a_j$ 并且 $f_j<f_i$ 的情况下，$fm_i=j$。此时，我们就可以把 $k$ 替换为 $fm_j$，然后，我们的任务就完成啦！

- 注意初始化，$f$ 数组和 $fm$ 数组要赋值成为极大值。

~~这么简单的题就没必要附[代码](https://www.luogu.com.cn/paste/0k5e324m)了吧~~