首先我们有经典子序列计数 dp，维护以 $0$ 或 $1$ 结尾的方案数 $f_i$ 和总方案数 $f_{all}$，每次会将 $f_i'\leftarrow f_{all},f_{all}'\leftarrow f_i+f_{all}$。

然后有一个显然的性质：在模 $2$ 意义下，一次操作等价于交换 $f_i$ 和 $f_{all}$。因此只要交换到 $all$ 那里，就会是奇数。

还有一个性质，就是可以将位置划分为若干个等价类，每个等价类内任选两个位置组成子串，子序列数就会是奇数的。这个证明很显然，就是任何一个有奇数个子序列的子串，都会形如 $(10\dots01)(10\dots01)\dots(01\dots10)$，也就是可以被拆成若干个形如 $011\dots1110$ 或 $100\dots0001$ 的基本单元，若干基本单元拼出来的一定是有奇数个子序列的子串，而这些基本单元间的那些位置就是等价类。

等价类怎么维护呢，一种简单的方法是表示成**当前的**、**加 $0$ 能得到的**、**加 $1$ 能得到的**三类。由基本单元的性质，不难想到加入一个数后会交换**当前的**和**加 $i$ 能得到的**——只要再有任意一个 $i$，都会把它切到**当前的**。

接下来使用 dp 套 dp 进行计数。注意到这三个等价类产生的贡献是 $\frac{size\times(size-1)}2\bmod2$，因此有用的只是它模 $4$ 的余数，所以可以把 dp 状态压到 $4\times4\times4=64$ 种。然后我们对这些 dp 状态进行 dp ，维护每种 dp 状态的方案数。

一种计算方法是矩乘优化，这需要 $O(64^3\times n)$ 的预处理复杂度和 $O(64^3\times\log n)$ 的单次询问复杂度。这是不可接受的，因为 $64^3=262144$。另一种好一点的计算方法是猫树分治，利用了 $O(64^2)$ 加一个数的性质和最后有用状态有限的特点实现 $O(64)$ 合并，可以做到 $O(64^2n\log n+64m)$。

略微卡常，注意常数优化。