找到了新的地方进行优化后得到了这篇更优的题解，复杂度 $O(64n\log n+8m+m\log n)$，使用四毛子可以去掉 $m\log n$，应该是本题最优算法了。

本题核心是找到一种 dp 来维护「奇数个不同子序列」以及拥有其的子串数，利用 dp 套 dp 统计方案。

（下文称拥有「奇数个不同子序列」的子串为合法子串）

本题解所采用的是一种常见的计算不同子序列个数的方法，维护总方案数和以 `0`、`1` 结尾的方案数。在模 $2$ 意义下每次在原串后面加入一个字符 `0` 或 `1` 等价于交换以它结尾的方案数和总方案数，因此只有 $3$ 种 dp 状态，我们表示为 $(1,0,0),(0,1,0),(0,0,1)$，初始为 $(1,0,0)$。

**接下来考虑手动模拟这个 dp，找到合法子串的规律。**（但是这个规律比较绕，看不懂还是去找其他题解吧）

发现形如 `100....001` 和 `0111...110` 的子串是合法的。手动模拟一下，会先从 $(1,0,0)$ 到 $(0,1,0)$ 或 $(0,0,1)$，在最后一个字符时会变回 $(1,0,0)$。若干由这种子串拼接而成的子串也是合法的。不能由这种子串拼接而成的子串都是不合法的。

这可以导出一个结论：一个子串，如果删去它的一个合法前缀或后缀，所得子串仍然合法。

首先我们先定义【位置】。一个长为 $n$ 的字符串有 $n+1$ 个位置，我们将其编号为 $0\sim n$。$n-1$ 个在两相邻字符之间，$2$ 个在开头结尾。任意两个位置之间有一个子串。

然后我们定义【等价类】为一个位置集合。满足等价类内的位置任选两个得到的子串合法，不同等价类内的位置任选两个得到的子串不合法。证明显然，因为合法关系具有传递性，$i,j$ 合法 $j,k$ 合法一定推出 $i,k$ 合法。（这包含了 $i<k<j$ 等情况，因为删去合法（前）后缀后仍然合法）

通过观察我们发现等价类最多有 $3$ 个，因为只有 $3$ 种 dp 状态（证明比较绕，感性理解一下，就是同一 dp 状态的是同一等价类）。

然后维护方法就是每次新加入一个位置，先看这个位置前一个字符，并交换 $(1,0,0)$ 和另一个对应 dp 状态的等价类，再把当前位置加入 $(1,0,0)$ 的等价类。初始 $0$ 在 $(0,0,1)$ 等价类。

---

然后我们需要维护等价类的不同大小的方案数。

接下来的分析**默认使用猫树分治**，因为这个状态易于添加单点而不易于合并，猫树会比莫队和线段树都更优。由于复杂度都是 $O(s_1n\log n+s_2m+m\log n)$ 的形式（四毛子优化 $m\log n$），所以直接用二元组 $(s_1,s_2)$ 表示复杂度。

一种比较直接的思路是每个等价类的大小对 $4$ 取模的值才是有用的，所以用 $f_{i,t0,t1,t2}$ 表示第 $i$ 位三个等价类大小分别为 $t0,t1,t2$ 时的方案数。由于等价类的位置会交换，我们还需要在状态里添加初始的状态 $t0',t1',t2'$。每次询问时枚举左边的 $t0,t1,t2$，这也是右边的 $t0',t1',t2'$，右边的 $t0,t1,t2$ 与处理掉。复杂度 $(64^2,64)$。

优化#1：发现维护 $t0',t1',t2'$ 有点多余，我们只是交换而已，从 $(0,0,0)$ 开始并维护交换后的顺序就好了。有一边可以不用维护交换顺序。复杂度 $(64\times6,64^2)$。（实际上是 $(\frac{64+448}{2},64^2)$）

优化#2：由于位置个数已知，所以不用维护三个，只用维护两个，剩下一个用总和减其它即可。复杂度 $(96,256)$。（实际上是 $(\frac{96+16}{2},256)$）

优化#3：发现不一定要对 $4$ 取模，对 $2$ 取模并且维护当前（这部分）的总方案数即可，复杂度 $(48,32)$。（实际上是 $(\frac{48+8}{2},32)$）

优化#4：回退掉优化#1，再加上一位来维护总和（相当于优化#2只用了一半），复杂度 $(64,8)$。

到这里应该就是这种技术线路的极限了，因为状态起码有 $8$ 种。

但是这题还可以考虑增大字符集来加强，思路不变只用增加状态即可。字符集每增大 $1$，$s_1$ 变 $2$ 倍，$s_2$ 变 $4$ 倍。