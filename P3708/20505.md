我太菜了看不懂官方题解orz

感觉有些像..

看看样例的例子:

```cpp
造了一张i mod j的表... 
  i=1   2   3   4   5   6   7   8   9   10
j↓ 
1---0   0   0   0   0   0   0   0   0   0
2---1   0   1   0   1   0   1   0   1   0
3---1   2   0   1   2   0   1   2   0   1
4---1   2   3   0   1   2   3   0   1   2
5---1   2   3   4   0   1   2   3   4   0
6---1   2   3   4   5   0   1   2   3   4
7---1   2   3   4   5   6   0   1   2   3
8---1   2   3   4   5   6   7   0   1   2
9---1   2   3   4   5   6   7   8   0   1
10--1   2   3   4   5   6   7   8   9   0
   
ans=9   16  22  25  29  27  29  24  21  13
``` 
案就是算出每列的和,只能找每列与前一列的关系了.

某列的每个数都比前一列对应位置的数大1,或变成了0,那么第j行出现0的位置都是j的整数倍...

而这些0的位置是可以枚举的,在f[k\*j]的位置-j..~~(就和官方一样了)~~

答案就是上一个答案+n-f[i]..蒟蒻想减小下常数就把第一行忽略了

```cpp
#include<bits/stdc++.h>
using namespace std;
#define rep(i,x,y) for(int i=(x);i<=(y);i++)
long long n,f[1000002],sum;
int main(){
  cin>>n;
  rep(i,2,n) for(int j=i;j<=n;j+=i) f[j]+=i;
  rep(i,1,n) printf("%lld ",sum=sum+n-1-f[i]);
  return 0;
}
```