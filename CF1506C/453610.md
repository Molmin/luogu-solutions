题目传送门：[CF1506C](https://www.luogu.com.cn/problem/CF1506C)

现在 $div.3$ 的C题变难了啊。一般 $D$、$E$ 题才会考这种题啊。

不过理解起来不是很难，有点像KMP字符串匹配的反配题。

而且数据范围也很小！！！

### 题意概述：

对于两个字符串，只能删掉他们的头或者尾。如果要使这两个字符串是匹配的，求最少需要的删除操作之和。

## 思路：
体面非常不难理解，思路也是比较好想的。

我们可以从侧面看一下这个题面中**只能删头和尾**这一段内容。因为只能去头或去尾，所以最终删完得到部分的一定是连着的。根据这一结论，我们不难想到这道题其实就是一个取最长公共子串长度的题。
### 首先考虑暴力：两种方法。
1.直接从第一个字符串的每个位置上查找第二个字符串的相应位置，然后暴力记录最长公共部分。

2.对于第一个字符串中的每个字符，都在第二个字符串中找相同的，然后在每个位置上往后匹配。

虽然复杂度很高，但是数据范围小啊，我们可以随便霍霍（bushi）。

还是想一想有没有什么好的办法？当然有，还有好多。我们仍然选择好用的DP来做。

### 既然是DP，那就要考虑 ：      **状态和转移**。


#### 状态：
设这两个字符串分别为a和b，然后设 $dp_{i,j}$ 为以 $a_{i-1}$ 和 $b_{j-1}$ 
作为结尾的两个公共子串的长度，初始值为0。

#### 转移：

1.如果 $a_i$ 与 $b_j$ 是一样的，说明这里可能是公共子串的开头，也有可能这个地方可以承接之前的公共子串，那么继续往后扫，公共子串的长度也就加一。所以转移方程就很容易得出 :

###   $dp_    {i+1,j+1}=dp_{i,j}+1$ .
                   
2.如果 $a_i$ 与 $b_j$ 是不同的，说明这时公共子串的结尾是他们的上一个字符，那么此时以这两个地方为结尾的字符串最长公共子串长度为 $0$ 。那么转移方程也就呼之欲出：

###    $dp_{i+1,j+1}=0$ .


#### 最后处理答案：
既然要求删掉的次数，那就求出来剩下的，因为剩下的东西在两个串里是一样的，那答案就是：两个字符串的长度和减去最长公共子串的长度的两倍。

思路已经很明确了吧，下面直接上代码：

```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<string>
using namespace std;
int dp[25][25];
string a,b;
int t,maxl;
int main(){
	cin>>t;
    while(t--){
        cin>>a>>b;
        maxl=0;
        memset(dp,0,sizeof(dp));
        for(int i=0;i<a.size();i++){ 
            for(int j=0;j<b.size();j++){
            	if(a[i]==b[j]) dp[i+1][j+1]=dp[i][j]+1;
            	else dp[i+1][j+1]=0;
                maxl=max(maxl,dp[i+1][j+1]);
            }
		} 
        cout<<a.size()+b.size()-maxl*2<<endl;
    }
    return 0;
}
```
