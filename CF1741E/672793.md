# 思路
动态规划。

## 步骤
### 第一步
定义 $f$ 数组，$f_i$表示截止前 $i$ 个数，是否可以完成变换。能则为 $1$，否则为 $0$.
### 第二步
状态转移方程推导：
因为在变换之前的数组 $a$，要分成若干段，再将长度，加入数组前面或后面，所以有两个状态转移方程。
#### 放前面
我们假设第 $i$ 个数是增加的长度。那么 $i-a_i$ 就是这段变化段的起始位置。那如果说 $i-a_1-1$ 是可以完成变换的，那就说明除了 $i-a_i$ 及以后的数以外，其余都分好了。那截止第 $i$ 个数，不就一定可以完成变换吗？

所以代码表达如下

`if(i-a[i]-1>=0&&f[i-a[i]-1]) f[i]=1; //记得判断下标，不可越界`
#### 放后面
同理，我们假设第 $i$ 个数是增加的长度。那么 $i+a_i$ 就是这段变化段的终止位置。那如果说 $i+a_1+1$ 是可以完成变换的，那就说明除了 $i+a_i$ 及以后、前的数以外，其余都分好了。那截止第 $i$ 个数，不就一定可以完成变换吗？

别急，有个小细节，$i+a_i+1$ 在 $i$ 后面，所以我们可以到过来，目前的 $i$ 若经过第一个状态转移方程后，以可以完成变换，那么我们则将 $i+a_i+1$ 的值附为 $1$。

所以代码表达如下

`if(f[i]) if(i+a[i+1]+1<=n) f[i+a[i+1]+1]=1;//同样需判断下标`

### 第三步
循环遍历后，判断 $f_n$ 输出即可。

# code
下面附上 AC 代码！！！
```
#include<bits/stdc++.h>
#define int long long
#define pii pair<int,int>
#define x first
#define y second
#define rep1(i,l,r) for(int i=l;i<=r;i++)
#define rep2(i,l,r) for(int i=l;i>=r;i--)
const int N=1e6+10;
using namespace std;
int t,n,a[N];
bool f[N];
void getans()//处理每组数据
{
	cin>>n;
	memset(f,0,sizeof f);//清空数组
	rep1(i,1,n) cin>>a[i];
	f[0]=1;//递推起点 
	rep1(i,0,n)//循环遍历
	{
		if(i-a[i]-1>=0&&f[i-a[i]-1]) f[i]=1;//第一个状态转移方程 
		if(f[i]) if(i+a[i+1]+1<=n) f[i+a[i+1]+1]=1;//第二个状态转移方程 
	}
	if(f[n]) puts("YES");//如果可以变换
	else puts("NO");//否则
    return;
}
signed main()
{
	cin>>t;
	while(t--) getans();//循环要答案
	return 0;//收场
}
/*
思路：
DP：
f[i]表示截止第i个数，是否能够满足
状态转移方程：
1.如果f[i-a[i]-1]=1,那么f[i]=1
i-a[i]是如果f[i]是加入前a[i]个数后的长度 ，如果i-a[i]前一位可以完成操作，那么一定在f[i]可以完成
2.如果f[i+a[i]+1]=1,那吗f[i]=1
i+a[i]是如果f[i]是加入后a[i]个数前的长度，如果 i+a[i]后一位可以完成操作，那么一定在f[i]可以完成
dp过程：
先判断f[i-a[i]-1]是否OK，若OK，f[i]=1，再由f[i]拓展出f[i+a[i]+1]=1 
*/ 
```
