**UPD:2022/07/18 改了几个语病/错别字。** 

### 题目大意

给一个长度为 $n$ 的序列 $a$，你需要进行以下操作使得序列 $a$ 的前 $n-1$ 项均为 $0$。

每个操作分为 $3$ 步：

1. 选择两个下标 $i$ 和 $j$，其中 $i<j$，并且 $a_i,a_{i+1},...,a_{j-1}$ 严格大于 $0$。

2. 把 $a_i$ 设置为 $a_i-1$。

3. 把 $a_j$ 设置为 $a_j+1$。

### 题目总评

这题首先考视力，笔者视力不好，一开始把 $a_i-1$ 看成 $a_{i-1}$，然后瞪了半天样例没看懂样例在干啥。好不容易发现了，结果又没开 long long，然后交了 N 发之后放弃了这道题。由于错得比较凄惨，写篇题解纪念一下。

### 解题方案

首先你会发现操作一次之后序列总和是不变，因为 $a_i+a_j=a_i+1+a_j-1$。所以你可以把这个操作看成是从 $i$ 这个地方挪了 $1$，然后到 $j$ 这个地方，有点像瞬移的感觉。

然后我们看一下我们的目标，就是把所有的数全部挪到 $a_n$ 上。你想一想，如果我们能一次性把一个数挪到最后该多好啊！可惜，如果中间有 $0$ 的话，我们就不能一次性转移到后面去。怎么办呢？

是零我们就把它变成非零的数，其实就是 $1$，因为变成 $1$ 的代价最小。怎么变？

举个例子 $[3,0,0,0]$。

这时我们发现 $3$ 的后方有 $0$ 不能直接转移，那么就把后方除了最后一个 $0$ 都填了。

1. $i=1,j=2$ 此时序列为 $[2,1,0,0]$。
2. $i=1,j=3$ 此时序列为 $[1,1,1,0]$。

此时序列除了最后一个 $0$ 以外的 $0$ 都被我们填掉了。并且发现了后面有几个 $0$ 就要填几次的重要~~废话~~结论。

有的小朋友就要问了，如果序列长这样 $[2,0,0,0,0]$，我们需要填 $3$ 个 $0$，但是我们只有 $2$ 怎么办？刚才的结论还成立吗？

模拟一下就好了。

1. $i=1,j=2$ 此时序列为 $[1,1,0,0,0]$。
2. $i=1,j=3$ 此时序列为 $[0,1,1,0,0]$。
3. $i=2,j=4$ 此时序列为 $[0,0,1,1,0]$。

至此，后方除了最后一个 $0$ 都填好了。可以发现这其实就是一个向后转移的过程。非常像一个游戏，叫推箱子。

都分析完了，开码！
### 代码实现

你需要向后填充的 $0$ 的个数用的是 `zero` 这个变量存储。当然你可以发现，第一个有数值之前的 $0$ 我们是不用去管它们的，因而不计入 `zero` 之中。

当你把后面的 $0$ 全部填充好了之后，还需要转移的次数就是除开最后一个数的和了。当然，最后一个数完全没有用，所以我就把它读掉，什么都不处理就行了。

操作次数就是 `zero+sum`。

**没啥用的代码：**

```cpp
#include<bits/stdc++.h>
using namespace std;
long long t,n,a,sum,zero;
int main(){
	cin>>t;
	while(t--){
		sum=0,zero=0;
		bool fl=false;
		cin>>n;
		for(int i=1;i<n;i++){
			cin>>a,sum+=a;
			if(fl&&!a) zero++;	//需要填充的0
			if(a!=0) fl=true;	//是否读到了有数值的数
		}
		cin>>a;
		cout<<sum+zero<<endl;
	}
	return 0;
}
```

填空：十年OI一场空，不开 (    ) 见祖宗。