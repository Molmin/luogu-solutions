### 题意：
给你一个 $n$ 个数的序列 $a$，你可以进行这样的操作：

选择一段满足区间 $[i,j-1]$ 内的数都严格大于 $0$ 的区间 $[i,j]$，之后给 $a_i$ 减 $1$，$a_j$ 加 $1$，即 $a_i\gets a_i-1$，$a_j\gets a_j+1$。

问至少需要几次操作使得 $a_1=a_2=a_3=\ldots=a_{n-1}=0$。
### 思路：
首先对于非 $0$ 的 $a_i(i<n)$，我们希望通过 $[i,n]$ 区间操作 $a_i$ 次使得 $a_i\gets 0$，但操作的要求是要满足区间内的树严格大于 $0$。因此对于 $a_j=0(i<j<n)$，我们可以通过 $[i,j]$ 使得 $a_j\gets1$。

那万一 $[i,j]$ 不满足呢？那就继续像上面的操作。其实我们就是从 $i$ 按顺序将 $0$ 填上。根据上面操作规则，容易得出将 $0$ 填上只要多花 $1$ 的贡献。

所以我们先找到第一个不为 $0$ 的数，然后加上它后面的所有数。特殊地，$0$ 加上 $1$ 的贡献。

时间复杂度是线性的，即 $O(\sum n)$。
### 代码：
```cpp
namespace solution{
void main(){
	int T,n,x;
	bool f;
	long long ans;
	cin>>T;
	while(T--){
		cin>>n;
		f=false,ans=0;
		for(int i=1;i<n;++i){
			cin>>x;
			if(x)
				f=true;
			ans+=x;
			if(f&&!x)
				++ans;
		}
		cin>>x;
		cout<<ans<<'\n';
	}
}
}
```
