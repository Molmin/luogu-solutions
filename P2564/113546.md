### 看了下题解里的讲法感觉没太理解，自己写一篇吧...

题目大意：有n个k种颜色的点，选出一个长度尽量短的区间，使得每种颜色的点都在区间内出现。

用队列实现即可。（说真的不太懂这个算不算单调队列）

首先按照坐标从左到右进行排序，有一件事是显然的：右端点最靠左的可选区间应该是每种颜色坐标的最小值的最大值。也就是$\max \limits _{1<=i<=k}l[i]$，其中$l[i]$指第$i$种彩珠最靠左的位置。

什么意思呢？比如说样例，考虑到如果右端点小于5，则无论如何也不可能在区间里出现第一种彩珠，因此右端点的最小值为5。这里我们可以开一个变量al，表示目前已经出现多少种彩珠，只有当$al=k$时才更新答案。

另外，我们考虑在右端点确定的情况下决定最优的左端点位置（其实就是要尽量靠右），保证每种彩珠都有出现，因此我们可以开变量$cnt[i]$表示第$i$种彩珠目前在区间出现了多少次，另外用一个队列$q$保存当前在区间里的彩珠。

如果队首元素（坐标最小）出现的次数大于1，则可以删去，这是因为删去后依然有这种彩珠存在，如果出现的次数恰好等于1，则不能删去，因为删去后这种彩珠就不再出现再队列中。

因此只要维护$cnt$数组，并在枚举时将当前彩珠加入队列，检查队首是否可以删去，即可解决问题。

时间复杂度为排序的$O(nlogn)$。

```cpp
#include <bits/stdc++.h>
using namespace std;
struct P {
	int x,u;
}p[1000010];
int cnt[70],al,n,k,t,ans,cnt1;
queue <P> q;
bool cmp (P a,P b) {
	return a.x<b.x;
}
int main () {
	ans=1e9;
	scanf("%d%d",&n,&k);
	for (int i=1;i<=k;i++) {
		scanf("%d",&t);
		for (int j=1;j<=t;j++) {
			scanf("%d",&p[++cnt1].x);
			p[cnt1].u=i;
		}
	}
	sort(p+1,p+n+1,cmp);
	for (int i=1;i<=n;i++) {
		if (cnt[p[i].u]==0) {
			al++;
		}
		cnt[p[i].u]++;
		q.push(p[i]);
		while (!q.empty()&&cnt[q.front().u]>1) {
			cnt[q.front().u]--;
			q.pop();
		}
		if (al==k) {
			ans=min(ans,p[i].x-q.front().x);
		}
	}
	printf("%d\n",ans);
	return 0;
}
```