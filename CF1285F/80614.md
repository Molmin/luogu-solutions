果然这类数对最值问题我肯定不会做。

首先将 $\text{lcm}(x,y)$ 拆解成 $\dfrac{xy}{\gcd(x,y)}$，也就是说，我们需要枚举 $\gcd(x,y)=g$ 然后找到最大的 $xy$ 使得 $\gcd\left(\frac{x}{g},\frac{y}{g}\right)=1$。

一种朴素的想法是从大到小枚举 $x$ 然后暴力找与 $x$ 最大的互素数 $y\text{ }(x\le y)$，这样最劣要枚举 $O(n^2)$ 次。

但是我们发现若存在与 $x,y$ 不同的元素 $z$ 使得 $x\le z\le y$ 的话，那么 $z$ 其实是没用的。

容易发现这其实就是个栈模型，若在枚举 $x$ 的同时找到了一个数 $y$，那么在更新答案之后需要把 $z$ 全部弹出。

但这复杂度依然是 $O(n^2)$ 的，因为你根本不知道 $y$ 是什么，最坏的情况就是这个栈里根本没有互质的元素然后你每次枚举了一遍栈。

注意到“栈里根本没有互质元素”这句话，也就是说，如果我们可以通过一些手段提前知道当前栈中 $x$ 有没有互质元素，我们就能避免其程序变得效率低下。

当然这样肯定还会被卡，只要每个最大的互质元素在距离栈顶很近的位置就行，在不妨换句说法，如果我们可以通过一些手段提前知道当前栈中 $x$ 有多少个互质元素，我们就能避免其程序变得效率低下。

为什么呢？

因为知道了互质元素个数，我们就能精确地枚举到最后一个，这样前面地那些数就能被刚好枚举一遍然后被消掉，后面的那些数也不会被枚举到，这样枚举次数就是栈中元素个数级别的。

那么问题来了，如何快速算出当前栈中有多少个与 $x$ 互质的数呢？

很简单，用莫反即可，每次枚举一遍 $x$ 的因数，总共只需要枚举 $O(\sum d(x))=O(n\ln n)$ 次。

所以时间复杂度是 $O(a_i\ln a_i\log a_i)$