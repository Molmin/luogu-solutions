众所周知这道红题是一道~~黑题~~好题。

这道题我们可以先假设一个函数 $f(x)$ 为当前猪总数为 $x$ 时的最坏情况的操作次数。

那么~~显然~~ $f(x)=0$ 也就是不用称就知道了。

~~解锁成就:未卜先知~~。

那么对于 $x>1$ 时我们如何考虑呢？

我们先不考虑 $m$ 的限制，并将 $x$ 分为三组。

由于一个整数除以三的余数只可能为 $0,1,2$ 所以对于任意 $x$， $x$都可以表示为:

① $x=3k$

② $x=3k+1$

③ $x=3k+2$

注:以下的“\”均为向下取整。

我们先看情况①。

我们的最优策略一定是分成三组。

group1: $k$

group2: $k$

group3: $k$

~~顺便 mod 一下 kkk~~

我们称完 group1 & group2 后。

这样我们只需要称一次就能排除掉 $2k$ 只正常的猪。

所以对于当前情况 $f(x)=f(x/3)+1$

对于情况②。

我们的最优策略依然是分成三组。

group1: $k$

group2: $k$

group3: $k+1$

~~显然~~我们称完 group1 & group2 后，最倒霉的情况是两边相等，即重的猪在 group3 中。

因为 group3猪的数量最多，所以此情况最倒霉。

那么对于当前情况 $f(x)=f(x/3+1)+1$

对于情况③。

我们的最优策略又双叒叕是分成三组。

group1: $k+1$

group2: $k+1$

group3: $k$

我们称完 group1 & group2 后。

要使得当前情况最极端(daomei)剩余要处理的猪应该越多(排除的越少)。

那么最多剩下 $k+1$只猪。

则该情况同上，即 $f(x)=f(x/3+1)+1$

综合①②③可以得

## $f(x)=\lceil \dfrac{x}{3} \rceil+1$

但是并没有结束，我们还有一次一边限称重 $m$的限制。

所以上面的式子只在 $x<=3m+1$ 的情况下成立。

因为此时天平两边正好为 $m,m$ 剩余一组 $m+1$ 不能再大了。

所以对于 $x>3m+1$的情况,我们每次可以取出 $2m$ 只猪称重(左 $m$ 右 $m$ )。

即最极端(daomei)情况为每次只排除 $2m$ 只猪。

即可得 $f(x)=f(x-2m)+1$

这里递归时，我们可以用乘法处理(减少递归次数)，那么答案就很明显了。

## code:

```cpp
#include<iostream>
#include<cstdio>
typedef long long ll;
using namespace std;
ll n,m;
ll upz(ll x,ll y){return (x+y-1)/y;}//向上取整模板
ll f(ll x){
	if(x==1)return 0;
	if(x<=3*m+1)return f(upz(x,3))+1;
	if(x>3*m+1){
		ll res=x-(3*m+1);//计算需要减少多少个2m才能符合情况②
		ll cnt=upz(res,2*m);//结果上取整
		return f(x-cnt*2*m)+cnt;//加上对应次数
	}
}
int main(){
	scanf("%lld%lld",&n,&m);
	printf("%lld",f(n));
	return 0;
}
```

~~人生第一道红题题解...~~