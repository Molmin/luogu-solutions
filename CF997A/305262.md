## 分析
求最小花费让整个字符串变成1，看到最小花费，是不是想到了$Dp$，想到$Dp$就条坑里去了，用$Dp$的话，你会发现状态没法转移，因为它既涉及到了区间反转，又涉及到了区间更新。

　　两种操作还要分类讨论，很麻烦，这两种操作有什么内在联系呢？手动模拟一下会发现，反转一段区间，可以将两段0合并成一段，而区间更新没有限制，除了是一段连续区间外，所以，反转区间和合并区间的操作是等价的，故如果有$k$段0需要处理，可以先将它们合并成1段，再集中处理，最后一次更新区间肯定是要用的，因为0不可能平白无故变成1，所以讨论一下$k-1$次处理的选择方式就好，显然是取最小值，因为答案让求最小嘛。	
```
#include<iostream>
const int N=3e5+10;
char a[N];
using namespace std;
int main(){
    int n,x,y;
    cin>>n>>x>>y>>a+1;
    long long cnt=0ll;
    a[0]='1';
    for(int i=1;i<=n;i++)
        if(a[i]=='0'&&a[i-1]=='1')
            cnt++;
    if(cnt==0)cout<<0;
    else cout<<(cnt-1)*min(x,y)+y;
}
```