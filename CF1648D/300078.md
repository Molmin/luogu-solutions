> 一个 $3\times n$ 的矩阵 $a$，一三行可行、第二行全是障碍物。有 $q$ 个可选操作：耗费 $w_i$ 将 $a_{2,[l_i,r_i]}$ 炸掉。从 $(1,1)$ 出发去往 $(3,n)$，经过 $(i,j)$ 获得 $a_{i,j}$ 价值，求总价值减总代价的最大值。$n,q\le 5\times 10^5$

如果从第二行的位置入手的话很难列状态，应该从操作入手看能更新哪些 $f[i]$。具体地，设 $f[i]$ 表示 $(1,1)$ 去 $(2,i)$ 的最小代价（这个很好想到），对于一个区间 $[l,r]$，有：
$$
f[i]\gets f[l-1]+pre_{2,i}-pre_{2,l-1}-w,\forall i\in [l,r]\\
f[i]\gets \min_{j\in[l,i]}(pre_{1,j}+pre_{2,i}-pre_{2,j-1}-w),\forall i\in[l,r]
$$

两个式子中的 $pre_{2,i}$ 都可以拎出来最后算。对于第一个式子，$f[i](i\ge l)$ 用 $f[l-1]$，说明应按左端点递增顺序处理操作，进而常规区间修改。对于第二个式子，相当于是这次 $[l,r]$ 内部所有人对后面的人做 $pre_{1,j}-pre_{2,j-1}$（常数，记为 $t_j$）的贡献，利用算法本质特征，在每次线段树左边回溯时带上来左边已经更新的 $t_j$ 的最大值，接下去做右边；对于线段树一个节点代表一个区间的，就先用 $\text{tag}$ 保存标记，在 `pushdown` 时做类似性质的操作。
答案就是 $\max(f[i]+pre_{3,n}-pre_{3,i-1})$。