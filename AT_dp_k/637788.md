# Description
如果当前玩家没有石头可以取的话，那么他的对手获胜。
如样例 1：
```
2 4
2 3
```
四个石头，可以拿 $2,3$。
先手拿了 $3$ 后手只能拿 $2,3$，但只剩下 $1$，什么也拿不了，所以先手 win。
如样例 2：
```
2 5
2 3
```
四个石头，可以拿 $2,3$。
先手拿了 $3$ 后手只能拿 $2,3$，但只剩下 $2$，可以拿 $3$，先手就不能拿了，所以后手 win。
# Solution
## 构造
因为题目问的是有 $k$ 个石头时，谁赢。
所以很自然得想到设 $dp_i$ 为石头个数为 $k$ 时的答案，$dp_i = 0$ 时后手赢。
## 初值
$dp_0 = 0$。
## 终值
$dp_n$。
## 动态转移方程
因为**双方都以最优策略行动**，所以只要有一个方案能让他赢，他一定能赢。

那是什么时候能赢呢，在他拿了 $arr_x$ 个石头后，后手赢的时候，因为他拿完他就变成了“后手”了。
## code
```cpp
#include <bits/stdc++.h>
using namespace std;
int n, k;
bool f[100005];
int arr[100005];
int main() {
	cin >>  n >> k;
	for (int i = 1; i <= n ; i++) cin >> arr[i];
	for (int i = 1; i <= k; i++) { // 枚举每个石头数的方案
		for (int j = 1; j <= n; j++) {
			if (arr[j] <= i) {
				if (!f[i - arr[j]]) {
					f[i] = 1;
					break;
				}
			}
		}
	}
	if(f[k]) cout << "First";
	else cout << "Second";
}
```