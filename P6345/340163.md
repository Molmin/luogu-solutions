本来不想写题解，但是看不懂题解区在说什么……就来写一篇吧。

考虑一根柱子插入之后的贡献。这个贡献并不好直接描述。于是构建笛卡尔树，一根柱子的贡献就是顺着其所在的左/右链一直走走到拐弯为止的点的高度减去插入的柱子的高度。

注意到可以重排，考虑从大到小插入，相当于每次插入一个点到叶子上。比如排序后满足 $h_1 < h_2 < \cdots < h_n$，我们现在插入 $h_i$，新造成的贡献可能是 $h_{i+1}-h_i, h_{i+2}-h_i, \cdots ,h_n-h_i$。有一个关键结论是这些可能的贡献都有对应的方案，也就是这些可能都是合法的。下面给出证明：

比如现在造成贡献的为 $h_p-h_i$。如果 $h_p$ 在整棵笛卡尔树的左/右链上，是显然可以造成贡献的；否则 $h_p$ 一定造成了 $h_q-h_p$ 的贡献，我们将 $p$ 的整棵子树移走，减少 $h_q-h_p$，并且存在一个位置满足 $p$ 不会造成贡献（即插入到左右链，以插入到右链为例，其左子树仍然为 $p$ 的左子树，右子树插入到右链，递归处理），然后再将 $h_i$ 插入产生 $h_q-h_i$ 的贡献，总贡献就是 $h_p-h_i$。

因此对于每一个 $i$ 枚举一个大于 $i$ 的 $j$（并且 $j \neq n$，因为不会产生 $h_n-h_i$ 的贡献）转移就好了。只需要处理可达性，并且是 01 背包的形式，可以用 `bitset` 优化。

时间复杂度为 $O\left(\dfrac{n^2h^2}{\omega}\right)$，因为 $h_j-h_i=0$ 时没必要转移。但是懒了下面的代码复杂度其实是 $O\left(\dfrac{n^3h}{\omega}\right)$ 的。

[完整代码](https://www.luogu.com.cn/paste/mpxd2l14)。