## 题意

动态维护中位数（~~够简洁吧~~）

## 分析

有两种做法：一种是使用**对顶堆**的在线做法（读入的同时及时计算答案），一种是使用**链表+Hash**的离线做法（完全所有读入后进行计算然后再同意输出）。

这里提供一种对顶堆做法。

### 对顶堆

为了维护动态中位数，我们可以建立两个二叉堆：一个小根堆，一个大根堆。在读入整个序列时，我们设当前的序列长度为 $M$，我们只需把排名 $1$ 到 $M/2$ 的数存在大根堆中，把排名 $M/2+1$ 到 $M$ 的数存在小根堆中。当然，如果有时候某个堆中元素过多或过少，打破了这个性质，就把元素数量多的堆的堆顶插入另一个堆。

这样一来，此时的中位数要分 $2$ 类：
1. 当 $M$ 是奇数时，小根堆的堆顶即为所求的中位数；
2. 当 $M$ 是偶数时，大根堆的堆顶即为所求的中位数；

当每次新读入一个数值 $X$ 后，若 $X$ 为 $-1$，就输出当前的中位数，并将其弹出；若 $X$ 比中位数小，则插入大根堆，否则插入小根堆，每一步都维护上面的性质即可。

这就是对顶堆做法。

## Waiting-Code

（PS：为了方便~~懒~~，我在代码里用了个技巧：只建立两个小根堆，把一个小根堆的数都变为其相反数，伪装成大根堆。）

```cpp
#include<bits/stdc++.h>
using namespace std;
priority_queue<int> q1, q2;
int n,a,t,s;
void weihu()//维护两个堆
{
	while (q1.size() > (q1.size()+q2.size()) / 2) {
		q2.push(-q1.top());
		q1.pop();
	}
	while (q1.size() < (q1.size()+q2.size()) / 2) {
		q1.push(-q2.top());
		q2.pop();
	}
}
int main()
{
    cin>>t;
    for(int ii=1;ii<=t;ii++)
    {
    	int i=0;
	    while (q1.size()) q1.pop();//有多组数据，每次应把堆清空
	    while (q2.size()) q2.pop();
    	do
    	{
    		cin>>a;
    		i++;
    		if(a<0)
    		{
    			if((q1.size()+q2.size())%2)//判断序列长度的奇偶
    			{
    				cout<<-q2.top() <<endl;
    				q2.pop();
				}
				else
				{
					cout<<q1.top()<<endl;
					q1.pop();
				}
				weihu();
			}
			if(a>0)
			{//插入
				if(i==1)//特判第一次
				q2.push(-a);
				else
				if (a < -q2.top()) q1.push(a);
				else q2.push(-a);//把插入q2的数变成其相反数，伪装成大根堆
				weihu();
			}
		}while(a!=0);
	}
	return 0;
}
```
祭：不知为什么我提交的代码都是**Waiting**QWQ。