看着题解写完了题，来写篇博客加深一下印象。

本蒟蒻实在太弱......居然没看出来是「没有上司的舞会」，还以为是某种二维背包......

发现是树上背包之后：

·将i的仇恨对象设置为i的fa，构造出整个图

·不难发现整个图有若干连通块，那么答案就是每个连通块内所能取到的答案之和。

·对于每个连通块（实际上就是一个「根在一个简单环」上的树）：

·做法同P1352「没有上司的舞会」。

对于一个点，她的答案（以她为根节点的最大子树和）就是：

max(「她自己的权值+她所有孙子的答案之和」，「她所有儿子的答案之和」)。

·具体来说，就是以下几点dfs时的技巧（**此处才是本题的重难点**）：



1.首先要找出该连通块的根，做法如下：从任意一个在连通块中的点x出发，不断向上跳到x的父节点，同时标记vis[x]=1;

如果一个节点被访问两次，那么说明此点在环中，而环中的任意一点都可以作为根。于是停止。

代码实现：
```cpp
    vis[x]=1;
    root=x;
    while(!vis[fa[root]]){
        root=fa[root];
        vis[root]=1;//向上,直到fa[root]已经被访问过
    }
```

2.在找到根之后：断掉根与根的父亲之间的边，从而形成一棵真正的树，否则dfs会陷入环中。

所谓断边，其实是说：**在dp时，如果遇到「u的某个儿子v是root」这种情况，就不往下dfs。**

3.更新答案的dp部分：

没什么好说的，只是要记住，要以root和fa[root]为根节点分别dp两次，取最大值。

代码实现：

```cpp
void dfs(int x){
    vis[x]=1;
    root=x;
    while(!vis[fa[root]]){
        root=fa[root];
        vis[root]=1;//找根 
    }
    dp(root);
    LL temp=max(f[root][0],f[root][1]);
    vis[root]=1;
    root=fa[root];
    dp(root);
    temp=max(temp,max(f[root][0],f[root][1]));
    ans+=temp;
    return;
}
```

嗯就这样。

**这道题并没有什么高级的知识点，而完全考验思维能力和代码实现能力，尤其是上面说的几点细节。**

~~所以本蒟蒻一想到NOIP可能会出这样的题就瑟瑟发抖QAQ~~

