本来想写二维，$f[i][j]$代表在第i行第j列的最优解，显然，这样写对于我这个蒟蒻来说很难，所以改成了三维$f[i][j][k]$,表示在第i行第j列，k用来表示从哪一状态转移过来，$k=1$代表从左边（即$i,j-1$）转移过来，$k=2$代表从上面（即$i-1,j$）转移过来，当前状态转移，只与上一状态和上上状态有关，结合图形，我们可以推得以下公式
```cpp
f[i][j][1]=min(f[i][j-1][1]+a[i-1][j]+a[i+1][j]+a[i][j+1],f[i][j-1][2]+a[i][j+1]+a[i+1][j]);
f[i][j][2]=min(f[i-1][j][2]+a[i][j-1]+a[i][j+1]+a[i+1][j],f[i-1][j][1]+a[i][j+1]+a[i+1][j]);
```

举个栗子，对于$f[i][j][1]$来说，它由$f[i][j-1][1]$和$f[i][j-1][2]$转移过来，一种是三个状态（当前状态，上一状态，和上上状态）横着排列，那么最新看到的老鼠为$a[i-1][j]$，$a[i+1][j]$，$a[i][j+1]$，另一种状态是上一状态由上上状态向下转移，当前状态由上一状态向右转移，那么新看到的老鼠只有$a[i][j+1]$，$a[i+1][j]$，很明显就可以看出来。
关于初始化，将f数组初始化为无穷大，dp的时候在$（1,1）$的位置特判一下就ok了

下面是代码（带注释）
```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=1000+10;
int f[maxn][maxn][2];//维护三维dp数组
int a[maxn][maxn];
int main(){
	int n,m;
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			scanf("%d",&a[i][j]);
		}
	}
	memset(f,0x7f,sizeof(f));//初始化
	for(int i=1;i<=n;i++){//枚举行数
		for(int j=1;j<=m;j++){//枚举列数
			if(i==1&&j==1){//特殊处理一下
				f[i][j][1]=a[i][j]+a[i+1][j]+a[i][j+1];
				f[i][j][2]=a[i][j]+a[i+1][j]+a[i][j+1];
			}
			else{//进行转移
				f[i][j][1]=min(f[i][j-1][1]+a[i-1][j]+a[i+1][j]+a[i][j+1],f[i][j-1][2]+a[i][j+1]+a[i+1][j]);
				f[i][j][2]=min(f[i-1][j][2]+a[i][j-1]+a[i][j+1]+a[i+1][j],f[i-1][j][1]+a[i][j+1]+a[i+1][j]);
			}
		}
	}
	printf("%d\n",min(f[n][m][2],f[n][m][1]));//最后在（n，m）位置的两个状态中取个最小值就ok了
}
```