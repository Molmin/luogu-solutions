## 题目
[题目链接](https://www.luogu.com.cn/problem/P2295)
## 分析
经典的一个$dp$模型，这个题中给出了小象的移动方向，我们就可以预处理每个点能够看到的不同种老鼠数量，然后进行状态转移，首先定义状态数组为$f[i][j]$是到$i$行$j$列的害怕值。

题目中给出了小象会害怕的一个范围：
$$|x1-x2|+|y1-y2|\le 1$$
我们就可以根据这个推出来只有老鼠在小象的上下左右时才会害怕，然后开始预处理。

但是预处理也是有点门道的，我在开始预处理的时候想的是在当前点上下左右的都加起来，但是写完以后发现答案要大好多，仔细分析一下，我们可以发现几个特点：

$1$、当前点由左边或上边转移而来，所以左边或上边已经能够看到当前点的左边和上边的点，所以只需要预处理该点下和右边的数量。

$2$、当前点是从左或上转移而来，如果上边的点仍然从上边转移来，那么该点的左边一定是没有统计过的，而从左边转移来的点上一次转移还是左边也是一样的，该点上边的点一定没有统计，所以我们就需要第三维来记录从左还是上转移而来。数组也就变成了$f[i][j][1]$，和$f[i][j][0]$，分别表示从左边来还是从右边来。如果一直从左转移，那么需要加上上边的害怕值，从上同理。

那么我们这样就得到了状态转移方程和预处理。预处理$val[i][j]$数组表示第$i$行$j$列会得到的害怕值，根据上边的分析得到只需要看这个点右边和下边即可。然后就是状态转移方程：
$$f[i][j][1] = min(f[i][j-1][1]+val[i][j]+a[i-1][j],f[i][j-1][0]+val[i][j]);$$
$$f[i][j][0] = min(f[i-1][j][1]+val[i][j],f[i-1][j][0]+val[i][j]+a[i][j-1]);$$

最后只需要比较$f[i][j][1]$和$f[i][j][0]$的最小值就好了。

## 代码
```cpp


#include<bits/stdc++.h>
using namespace std;
const int maxn = 1e3+10;
int a[maxn][maxn],f[maxn][maxn][3];
int val[maxn][maxn];
int n,m;
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;++i){
		for(int j=1;j<=m;++j){
			scanf("%d",&a[i][j]);
		}
	}
	for(int i=0;i<=n;++i){
		for(int j=0;j<=m;++j){
			if(a[i][j+1] != 0)val[i][j]+=a[i][j+1];//加上右边的老鼠
			if(a[i+1][j] != 0)val[i][j]+=a[i+1][j];加上下边的老鼠
		}
	}
	memset(f,0x3f,sizeof(f));//初始化极大值
	f[1][0][0] = f[1][0][1] = val[1][0];//边界初始化
	f[0][1][0] = f[0][1][1] = val[0][1];
	f[1][1][0] = f[1][1][1] = 0;
	for(int i=1;i<=n;++i){
		for(int j=1;j<=m;++j){
			f[i][j][1] = min(f[i][j-1][1]+val[i][j]+a[i-1][j],f[i][j-1][0]+val[i][j]);//从左转移来
			f[i][j][0] = min(f[i-1][j][1]+val[i][j],f[i-1][j][0]+val[i][j]+a[i][j-1]);//从上转移来
		}
	}
	int ans = min(f[n][m][1],f[n][m][0]);//统计最小值
	printf("%d\n",ans);
	return 0;
}

```
