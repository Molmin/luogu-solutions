蒟蒻考试的时候刚开始打了个暴力，然后玄学dp，dp本来是只考虑了当前点与下一个点的关系，后来发现没那么简单（好吧其实是样例都没过的原因），当前点与上一点都会影响下一点的老鼠值（因为每只老鼠只能见一次呀）   


------------
题目上说的看见老鼠的条件第一眼看上去很感jio很复杂（可能是我太弱了），实际上就是上下左右四个点

于是画图 ，发现有四种情况 

以下颜色说明，蓝色是第一个点，红色是移动一次后的点，黄色是移动两次后的点，被颜色覆盖的点说明该点的老鼠能被看见，有多种颜色的，说明被覆盖了多次

第一种，向下再向下（图画的丑，请求谅解）![](http://ae01.alicdn.com/kf/Had9667ca00d04988b40e8a67f3a15ab9i.png)

我们可以观察到，当前到达的点(x,y)（黄色），实际能看到的老鼠（在到达该点之前没有被看光），只有(x,y-1),(x,y+1),(x+1，y)的老鼠能看

所以，以此类推，向下再向右，向右再向下，向右再向右的点都可以找到规律啦（好吧是图太难画了）

当前点的老鼠与上个点与上上个点走的方向有关，所以我们设计两个状态，0往下走，1往右走

上代码（里面有注释）

```cpp
void work()
{
	//h[3]={1,0},l[3]={0,1},0是向下走，1是向下走
	//f[i][j][0/1]是到点(i,j)看老鼠的最小值 
	f[1][1][0] = f[1][1][1] = a[1][1]+a[2][1]+a[1][2]; //第一个点特殊处理 
	for(int i = 1;i <= n; i++)
	{
		for(int s = 1;s <= m; s++)
		{
			if(i==1 && s==1) continue;//起点怕出错，所以特判了一下 
			
			int li=i-h[0] , ls=s-l[0];//走下面 	
			if(li>0&&li<=n && ls>0&&ls<=m)
			f[i][s][0] = min(f[li][ls][0]+a[i+1][s]+a[i][s-1]+a[i][s+1] , f[li][ls][1]+a[i][s+1]+a[i+1][s]);
			//f[li][ls][0]+a[i+1][s]+a[i][s-1]+a[i][s+1] 上一个点是上上一个点走下边来的，剩下的都一样啦 
			//画图理解更好
			li=i-h[1] , ls=s-l[1]; //走右边
			if(li>0&&li<=n && ls>0&&ls<=m)
			f[i][s][1] = min(f[li][ls][0]+a[i][s+1]+a[i+1][s] , f[li][ls][1]+a[i-1][s]+a[i+1][s]+a[i][s+1]); 
		}
	}
}


蒟蒻第一次题解，如有错帮忙指出，谢谢巨佬们！！
```
