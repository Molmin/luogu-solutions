## 这道题我们需要用贪心来解决

#### 先声明一下下面文字中用到的变量的含义：
>$sum$: 排在当前同学之前的同学的总用时（包括不及格的同学）

>$m$: 考试的总时间

### 1.思路：


我们先把排在这个同学之前的同学的用时的和求出来，如果这个和加上当前同学需要的时间不超过$m$那么不做任何处理，直接让 $sum$ 加上当前同学需要的时间然后输出“$0$”，接着处理下一个同学。

如果当前 $sum$ 加上同学的时间超过了考试时间 $m$ 那么从优先队列中取出用时最大的同学的时间，让 $sum$ 减去它，同时表示答案的 $cnt$ 加 $1$（需要不及格的同学加一个）。重复上述操作，直到 $sum\le m$。
#### 较为简短的思路：
由于我们要在让当前同学通过的情况下让数量最小的的同学不及格，所以我们需要让耗时最大的同学不及格，以为当前的同学争取更多的做题时间。

### 2.代码：
```cpp
# include <bits/stdc++.h>
using namespace std;
int arr[110];
priority_queue<int> q;//定义大根堆
int main(){
	int n,m;
	cin>>n>>m;
	for(int i=0;i<n;i++){
		cin>>arr[i];
	}
	int sum=0;
	for(int i=0;i<n;i++){
		for(int j=0;j<i;j++){
			q.push(arr[j]);//把当前同学之前的同学的用时放进优先队列
		}
		sum+=arr[i];//sum加上当前元素，求出前i个同学的用时和
		if(sum<=m){
			cout<<0<<" ";//满足条件（不会超过考试时间），输出0（即前面的同学都可以及格）
		}else{//不满足条件，计算要让多少个同学不及格
			int sum_=sum;//备份sum，因为sum要存储当前同学之前的同学的用时总和，值不能改变
			int x=0;//记录要让多少个同学不及格
			while(sum_>m){
				sum_-=q.top();//sum减去当前用时最大的同学的用时
				q.pop();//弹出当前同学的时间
				x++;
			}
			cout<<x<<" ";//输出答案
		}
		while(!q.empty()){//清空队列，为下一次循环做准备
			q.pop();
		}
	}
	return 0;
}
```