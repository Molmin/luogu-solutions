为了方便分析，以下所有zombie用z替代

由于这题只有6行，

所以我们可以将每行中的每个z出现的时间分别存入对应的以行数命明的数组里

将所有z出现的时间存入数组后，

如何计算最少需要几个坚果成了最重要的问题

计算方法其实很简单

因为所有z在出现后的59个时间段后，便会到达第1列

而这时，你不得不用一个坚果把它干掉

干掉它的同时，它后面的z也会被干掉

所以我们可以分段计算

设第一行第n个z的出现时间为x[n]

首先第一个z的到达时间为x[1]+59，在这个时间段我们就不得不干掉它

而它后面的所有z都会被干掉

接下来，再计算没被干掉的第一个z的到达时间，并重复以上的运算

二到六行也是如此

代码如下：

```cpp
#include<iostream>
#include<algorithm>
using namespace std;
int n,x,y,x1[2001],x2[2001],x3[2001],x4[2001],x5[2001],x6[2001],t1,t2,t3,t4,t5,t6;
int f(int n,int x[])
{
    if (n==0) return 0;
    sort(x+1,x+1+n);
    int t=x[1]+59,tt=0;
    x[n+1]=x[n]+60;
    for (int i=1;i<=n;i++)
    {
        if (t==0) t=x[i]+59;
        if (x[i]<=t&&x[i+1]>t) {tt++;t=0;}
    }
    return tt;
}
int main()
{
    cin>>n;
    for(int i=1;i<=n;i++) 
    {
        cin>>x>>y;
        if (x==1) {t1++;x1[t1]=y;}
        if (x==2) {t2++;x2[t2]=y;}
        if (x==3) {t3++;x3[t3]=y;}
        if (x==4) {t4++;x4[t4]=y;}
        if (x==5) {t5++;x5[t5]=y;}
        if (x==6) {t6++;x6[t6]=y;}
    }
    cout<<f(t1,x1)+f(t2,x2)+f(t3,x3)+f(t4,x4)+f(t5,x5)+f(t6,x6);
    return 0;
}
```