# 这题其实就是个裸的最小生成树模板，用Kruskal和Prim算法都没问题。

# 蒟蒻用的是Prim算法，个人认为比较好理解，解释一下：

在一棵树中，首先取出一个节点加入**集合V**，剩下的节点在**集合U**中， 每次寻找**与V中某节点相连的且另一端不在集合V中的代价最小边**，并将其另一端加入集合V。当集合U为空时，最小生成树建立完毕，建树代价为各边权值之和。

（注：**此处加入集合V即意味着离开集合U**）

由于此题求最早通车时间，即意味着求最小生成树中代价最大边，故将+=改成=，另，在输出时要加以特判，判断ans是否为初值，如为初值，输出-1。

下面附上代码：（详见注释）
```cpp
#include<cstdio>
int f[6000][6000],f1[6000],n,m,x,y,z;
//f数组为邻接矩阵，f[i][j]表示i与j之间边的权值
//f1数组为辅助数组，记录当前节点与其他边的权值
bool visit[6000];
//visit数组表示节点是否在集合V中，在为1，不在为0
void prim()
{
	int s=0,ans=0;
	//s表示边数，初始为0
	while(s<n)
	//建立最小生成树
	{
		int minn=1<<30,to=0;
		//minn为所要加入边的权值，to为另一端
		s++;
		//边数+1
		for(int i=1;i<=n;i++)
			if(!visit[i]&&f1[i]<minn)
			{
				minn=f1[i];
				to=i;
			}
		//寻找要加入边
		if(minn!=1<<30)ans=minn;
		//当有符合条件的边时，更新答案
		for(int i=1;i<=n;i++)
            if(f1[i]>f[to][i]&&!visit[i])
                f1[i]=f[to][i];
        //更新f1数组
        visit[to]=1;
        //to加入集合V
	}
	printf("%d",ans==0?-1:ans);
	//输出及特判
}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
			f[i][j]=1<<30;
	//初始为无限大，表示不可达到
	for(int i=1;i<=m;i++)
	{
		scanf("%d%d%d",&x,&y,&z);
		if(f[x][y]>z)f[y][x]=f[x][y]=z;
	}
	//仅当权值小于原权值时，更新权值（其实没用）
	for(int i=1;i<=n;i++)f1[i]=f[1][i];
	visit[1]=1;
	//首先将节点1加入集合V（可以加入任一节点）
	prim();
	//建树
}
```