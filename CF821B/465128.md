### 题目大意

给你一条直线 $y = -\frac{x}{m}+b$，在平面直角坐标系中的**给定的直线下**画一个**四条边平行于坐标轴**的矩形。当且仅当 $x,y$ 均为**非负整数**时，在 $(x,y)$ 这个点上有 $x+y$ 个香蕉。问所画矩形的内部和边界上加起来最多能有几个香蕉。

### 思路

注意到给定的直线、$x$ 轴和 $y$ 轴围成了一个底边长度为 $b \times m$，高为 $b$ 的直角三角形。因此考虑直接暴力枚举所画矩形右上角的 $x$ 坐标。（这里枚举 $y$ 坐标可能会漏掉一些情况）

枚举出右上角的 $x$ 坐标后，$y$ 坐标和矩形内的香蕉数量也就确定了。其中矩形内的香蕉数量为：

$$\sum_{i=0}^{x}\sum_{j=0}^{y}(i+j)$$

但是如果对于枚举出的每个矩形都这样计算答案，会超时。所以进入推式子环节：

$$\sum_{i=0}^{x}\sum_{j=0}^{y}(i+j)$$

$$=\sum_{i=0}^{x}\sum_{j=0}^{y}i+\sum_{i=0}^{x}\sum_{j=0}^{y}j$$

$$=\sum_{i=0}^{x}(y+1)i+\sum_{i=0}^{x}\frac{y(y+1)}{2}$$

$$=\frac{(x+1)(y+1)x}{2}+\frac{(x+1)(y+1)y}{2}$$

$$=\frac{(x+1)(y+1)(x+y)}{2}$$

这样，计算答案的部分的时间复杂度就是 $O(1)$ 了，总体的时间复杂度为 $O(b \times m)$。

### 代码

最后附上短小精悍的代码。其中有一个坑点，c++ 中的整型除以整型是**向0取整**而不是向下取整，因此需要用 cmath 中的向下取整函数。

```cpp
#include <cstdio>
#include <iostream>
#include <cmath>
using namespace std;
int m,b;
long long y,ans;
int main(){
    scanf("%d%d",&m,&b);
    for(long long x = 0;x <= m * b;x++){
        y = floor(b - x / (double)m);
        ans = max(ans,(x + 1) * (y + 1) * (x + y) / 2);
    }
    printf("%lld",ans);
    return 0;
}
```