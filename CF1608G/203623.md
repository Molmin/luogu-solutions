一个非常自然的想法就是把所有的串和询问的链放到一个 SA 里面，然后用哈希进行比较排序得出 SA。

不过更好的做法是每次将链在 SA 里面二分定位。

关于比较一条链和一个后缀的字典序以及求 LCP：

维护字符串的 hash 和树上由下自上和由上自下的 hash 前缀和。然后分成两段到 lca 的段树上倍增计算。细节繁多。

定位后进行二分。找到区间满足其中所有的后缀均包含链。二维数点即可。

总结：

SA 在一些奇怪的题会有异常的表现。这里的 hash 实际上是在后缀组成的 trie 上进行快速匹配。

不过相当难写，或许可以匹配 *3500 的难度。

[评测记录](https://codeforces.com/contest/1608/submission/146836050)