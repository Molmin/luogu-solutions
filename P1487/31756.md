这题真的有楼下那些大佬们讲的那么复杂吗？来一个二分的题解。

首先现根据题目里的
$$a_i = {(a_{i-1} + a_{i+1}) \over 2} + d$$

用一点小学数学知识变换一下，得到
$$a_{i+1} = {a_{i-1} - 2(a_i - d)}$$

把下标减$1$，得到递推式
$$a_i = a_{i-2} - 2(a_{i-1} - d)$$

然后我们分析$a_n$与$a_2$的关系

我们先观察$a_3 = a_1 - 2(a_2 - d)$，$a_2$前面是负号，显然$a_2$越大，$a_3$越小。

同理$a_3$越大，$a_4$越小。所以$a_2$越大，$a_4$越大。

结论就很~~显然~~了，$a_2$越大奇数项（不要管$a_1$）越小，偶数项（不要管$a_0$）越大。

然后呢？

我们**二分**$a_2$，因为上面已经说明了每一项与$a_2$的大小关系，就有了**单调性**，用$a_2$的值递推出$a_n$，然后**判断**。

贴代码：（时间复杂度$O(n log n)$）
```cpp
#include <cstdio>
const double eps = 1e-12; //我<del>不</del>感觉这题卡精度啊
double d, a[100], an; //an表示给定的a[n]的值
int n, m; //总的项数和要求的一项

bool check(){ //判断是否a[n] >= an
	for(int i=3; i<=n; i++)
		a[i] = a[i-2] - 2 * (a[i-1] - d); //根据递推式计算
	return a[n] >= an;
}

int main(){
	scanf("%d%d", &n, &m);
	scanf("%lf%lf%lf", &d, &a[1], &an);
	double l = -1e12, r = 1e12;
	while(r - l > eps){
		a[2] = (l + r) / 2; //二分a[2]的值
		if(check())
			if(n & 1) l = a[2]; //根据n的奇偶性分类
			else      r = a[2]; //偶数项和a[2]是一样的大小变化关系
		else
			if(n & 1) r = a[2]; //奇数项和a[2]相反
			else      l = a[2];
	}
	printf("%.3lf\n", a[m]);
	return 0;
}
```