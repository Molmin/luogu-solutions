@hsfzLZH1 的题解已经非常详细了，大部分内容都可以看那篇题解，这里解决其中的一个问题：为什么只对前50位进行运算可以保证精度？  
#### 前置知识：  
1.斐波那契数列到第92项左右就会爆long long。  
2.斐波那契数列中位数一定的数最多有6个。（假设前两个数最小，最高位都为1，则前6项为1,1,2,3,5,8，第7项位数一定会更多）  
3.斐波那契数列的第99,999项有20,899位，第50000项有10,451位。  
接下来粗略证明文章初提出的问题。  
首先模拟一下误差的产生。假设现在有两个数，它们的第50位被删去，且被删去的两位都是9，且它们的首位都是1，则前6位的误差分别是：  
```cpp
9
9
18
27
45
72
117
```
到第7个数，位数增加1，则最后一位被删去，此时产生的误差为11。  
那么到第99,999项时呢？通过实验得出，假设这是第50000位的误差（理想情况，误差最大），因为第50000项有10,451位，所以误差在10400-10401位。而到了100000项，误差将会对20,852位产生影响。  
虽然这只是一个粗略的估计，实际误差会更大，但通过实验发现：  
```cpp
25974069347221724166155034021275915414880485386517//精确计算斐波那契数第100000项的前50位
25974069347221724166155034021275915414880485363731//粗略计算的前50位
```
可以发现，当计算到99999项时，误差只影响了最后5位，而前45位仍然保持正常。而且计算前50位能保证不超时，而精确计算99999项需要14秒左右，一定会超时（虽然这题时限10s）。  
下面是我的代码（静态Trie树），包括一些细节：  
```cpp
#include<cstdio>
#include<cstring>
int T,a[2][52]={{1},{1}},len,inf;
int trie[4586400][10];//计算获取的最优len,Trie最大4586377层 
int vis[4586400];
char s[50];
void del(int *a)
{
	for(int i=0;i<=50;i++)a[i]=a[i+1];//数组开52位，这里可以直接赋值0 
}
void insert(int *a,int v)
{
	int i=50;
	while(!a[i])i--;
	for(int now=0;i>=0;i--)
	{
		if(!trie[now][a[i]])trie[now][a[i]]=++len;
		now=trie[now][a[i]];
		if(vis[now]==inf)vis[now]=v;//这句在后面 
	}
}
void query(char *s)
{
	int now=0;
	for(int i=0;s[i];i++)
	{
		int x=s[i]-'0';
		if(!trie[now][x]){printf("-1\n");return ;}
		now=trie[now][x];
	}
	printf("%d\n",vis[now]);
}
int main()
{
	memset(vis,0x3f,sizeof(vis));
	inf=vis[0];
	insert(a[0],0);
	for(int i=2;i<100000;i++)//注意原题规定不取100000 
	{
		if(a[1][50]||a[0][50])del(a[1]),del(a[0]);//移位 
		for(int j=0;j<50&&a[j];j++)//高精加法,数组压缩 
		{
			a[i&1][j]+=a[(i&1)^1][j];
			a[i&1][j+1]+=a[i&1][j]>=10;
			a[i&1][j]%=10;
		}
		insert(a[i&1],i);
	}
	scanf("%d",&T);
	for(int _=1;_<=T;_++)
	{
		scanf("%s",s);
		printf("Case #%d: ",_);
		query(s);
	}
	return 0;
}
```