一样的代码，不一样的理解
```cpp
#include <bits/stdc++.h>

using namespace std;

/*
问题思路：
这道题很多地方都像背包问题，因此我们考虑以背包问题的范式求解
干草总数H对应背包容量
干草包重量P对应单个物品所占容量
干草包开销C对应单个物品价值
可以卖出无限多的干草包对应每个物品可以选无数次
“采购至少H单位干草使开销最小”对应“选择总占容量至少为H的一组物品使总价值最小”
乍一看这不符合背包问题的定义，然而我们可以用如下思路将其转化为背包问题来解
首先求出以H开始的一系列容量下严格装满背包的背包问题的解，然后在这一系列解中择出最优
按照这个思路求解，需要解决的一个问题是这一系列容量以何结束
为了解决这个问题，我们需要知道：给定物品总数，自由选取物品可得的最小价值会随着物品总数的增长而增长
上面的命题非常显然，因为C是正的，无论怎么选取物品对价值的影响都是增大
而当背包容量超过H+Pmax时为了严格装满背包，选定物品显然会比最优解所选物品多出至少一个，最小价值自然增大
基于上述理由，我们只需要求以H开始以H+Pmax结束的一系列容量下的解就可以了
*/

int dp[55005];

int main()
{
    // 读入
    int n, h; cin >> n >> h;
    // 接下来求解一个严格装满背包的求最小价值的无界（完全）背包问题
    memset(dp, 0x3f, sizeof(dp)); // 因为是求最小值我们需要设无效状态为正无穷，与背包九讲中刚好相反
    dp[0] = 0;
    for (int i = 0; i < n; ++i)
    {
        int p, c; cin >> p >> c; // 在线求解
        for (int j = p; j <= h + 5000; ++j) // 单个物品所占最大容量为5000
            dp[j] = min(dp[j], c + dp[j - p]); // 状态转移方程
    }
    // 接下来在得出的一系列最小价值中选出最小的
    int ans = INT_MAX;
    for (int i = h; i <= h + 5000; ++i)
        ans = min(ans, dp[i]);
    // 输出
    cout << ans << endl;
    return 0;
}
```
