出于对本题的深仇大恨（卡了我三天）

我决定来写篇题解

目录

1.思路

2.错误记录

3.坑

4.带注释的代码

1.思路

1）差分+前缀和

会的神犇，请跳过这里

如果不会，请看一下举例

假设此时你在做一道数学题

说给出10个数都是0，然后呢，第一个数到第三个数加6，第

二个数到第八个数加9，最后把第一个数到第十个数加10086

请写出现在第一个数到第十个数（注意每次加包括首尾）

我们一般人就是正常的加法，对吧？

第一次加完：6 6 6 0 0 0 0 0 0 0

第二次加完：6 15 15 9 9 9 9 9 9 0

第三次加完：10092 10101 10101 10095 10095 10095 10095 10095 10095 10086

就这些了

但是呢，我们现在可以这么做，算差。

我们聚焦到第一次

是不是第一个数和第二个数之间的差不变（因为同加一个数，差不变，数学）

第二个和第三个，同理

但是第三个和第四个则差有变化，减少了6（此时差可能负数，均为，第n个-第n-1个）

还有第一个和第零个，增多了6

而此时把差加起来，神奇的事情发生了，竟然和原结果一样！
那是不是所有的都可以这么加呢

是的，可以

而刚刚的求差就是差分，求和就是前缀和

2）上面的一大堆东西是用来除去TLE的

说点干货

后面用min，总共两种，买卡和不买卡

买卡：a[i]*经过的次数

不买卡：b[i]*经过的次数+c[i]

那个便宜选那个

2.错误记录（选典型）

1）0分：题目理解+作死

2）60分：TLE

3）0分：看错题目了（what the ****）

4）70分：没开long long

5）100分：终于对了

3.坑

1）long long

2）差分

4.代码（其中的typedef可以忽略）

```
#include<cstdio>
#include<iostream>
#include<algorithm>
typedef long long L;//给long long取一个别名
using namespace std;
L n,m;//long long n，m
L p[100005];
L a[100005],b[100005],c[100005];
L money;//最终的钱
L each[100005];//每段铁路经过的次数
int main()
{
	cin>>n>>m;
	for(int i=1;i<=m;i++){
		cin>>p[i];
		if(i==1){
			continue;
		}
		each[min(p[i-1],p[i])]++;//差分
		each[max(p[i-1],p[i])]--;
	}
	for(int i=1;i<=n;i++){
		each[i]+=each[i-1];
	}
	for(int i=1;i<n;i++){
		cin>>a[i]>>b[i]>>c[i];
		money+=min((a[i]*each[i]),(b[i]*each[i]+c[i]));
	}
	cout<<money;//完美结束
	return 0;
}
```
