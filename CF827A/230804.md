#### 题目大意

给定一系列字串及它所在字符串中的位置，要求拼凑出符合题意且字典序最小的字符串

#### 思路分析

~~(暴力出奇迹)~~

一、首先我们可以知道的是，因为这是一定保证有解的，那么我们可以得到以下的性质

出现在同一个位置的子串，一定是相同的一个子串不一样长的一些部分，那么长度较大的一定会包含着长度较小的，所以我们此时就可以对比以下，然后把每个位置都更新成长度最大的

二、输入处理完后，在输出上也有一些小技巧

看一些特殊的情况

当找到一个位置没有字符串出现时，输出字典序最小的$a$

当找到一个位置有字符串出现时,此时会出现两种情况

1.在输出一个字符串的时候，在这其中的位置上出现了其他的字符串

上例子来解释一下

```
当前输出的字串 aabbcc
部分重合的字串    bccdd   

```
当我们输出到第四位的时候，出现了一个与他部分重叠的字串，那么我们现在要直接跳出该层循环，转移到下一层去

为什么呢，因为读题目可以知道的是，我们只知道这个字串的初始位置，并不知道这其中所有的位置标号，所以说，在每个位置所储存的字符串下标中，有一部分可能是$0$，但是包含在了字串当中，所以循环会直接出去略过去，并不会造成影响。

而当前这种情况，如果我们将当前输出的字串输出到了最后，那么出现的情况是下一个位置的标号是$0$，不能进行匹配，只好输出$a$，导致答案错误。

处理的时候只需要判断一下当前字符串$i$的长度是否小于已经输出了的长度$dis$+部分重合的字串$j$之和

符合弹出的条件为：

$$len_{i} < len_j+dis$$

#### 优化

别忘了用scanf，不然会T，QWQ

#### 代码实现

```
#include<iostream>
#include<cstdio>
#include<cstring>
#include<queue>
#include<stack>
#include<algorithm>
#include<map>
using namespace std;
const int N=1e7+9;
const int M=1e6+9;
int n;
int maxn;
string k[M];//用来存储每个字符串 
int a[N];//存储当前的位置是应用的哪一个字符串 
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		int x;
		cin>>k[i];
		cin>>x;
		for(int j=1;j<=x;j++)
		{
			int place;
			scanf("%d",&place); 
			if(k[a[place]].length()<k[i].length())
			a[place]=i;
			//如果该字符串的长度大于原来的字符串的长度
			//那么就说明以前的小字符串一定包含在当前的字符串里
			//那么就把位置更新一下 
			maxn=max(place,maxn);
		}
	}
	for(int i=1;i<=maxn;i++)
	{
		if(!a[i])//当前位置没有字符串，就输出字典序最小的
		{
			printf("a");
			continue;	
		}
		int j;
		for(j=0;j<k[a[i]].length();j++)
		{
			if(k[a[i+j]].length()+j>k[a[i]].length())
			//也就是说，在输出的时候遇到了另外的一个区间并且没有包含完全
			//那就不输出了
			break;
			else 
			{
				printf("%c",k[a[i]][j]); 
			}
		}
		i+=j;
		if(j!=0) i--;
	}
	return 0;
}
```
