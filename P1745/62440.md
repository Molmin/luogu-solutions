[P1745](https://www.luogu.com.cn/problem/solution/P1745)

## 1. 关于 2-SAT 问题

其实这个题开头已经给出了是2-SAT问题变种的构造题，所以可以套用2-SAT的思想转化为图论。

2-SAT问题的思路是说，假定把一个位置 $i$ 是 $1$ 以及是 $0$ 的情况拆分成两个结点 $i$ 和 $-i$，则可以转化成如下问题：

> 给出 $n$ 个集合，每个集合有两个元素，已知若干个 $(a,b)$，表示选择 $a$ 则必须选择 $b$ 矛盾（其中 $a$ 与 $b$ 属于不同的集合）。然后从每个集合选择一个元素，判断能否一共选 $n$ 个两两不矛盾的元素。

用一条边 $(u,v)$ 表示如果选择 $u$ 就必须选择 $b$，就可以在刚才建立的有 $2n$ 个结点的有向图中进行选择。其大致思路为，每次尝试选择一个可以选择的点 $x$，然后选择这个点可以到达的所有点，并且将 $-x$ 及可以到达 $-x$ 的所有点标记为不可选择。如果发生矛盾，则回溯并且尝试选择 $-x$。

容易发现，任何一条边 $(u,v)$ 存在，则相当于 $(-v,-u)$ 也存在。也就是说，图中存在**对称性**。而任何一条边 $(u,v)$ 存在且 $(v,w)$ 存在，则隐含着 $(u,w)$ 也必定存在。也就是说，图中存在**传递性**。

此时，该题目转化为：

> 构造一个 $2n$ 个结点的 2-SAT 有向图，使得该有向图恰好只能选择出给定的 $3$ 种方案。

例如：`1 0 1 0 1 1` 可以看作选择 ${1,-2,3,-4,5,6}$ 这 $6$ 个结点。

## 2. 关于本题

显然，本题内应该尽量纵向地考虑，即 $\forall i$，$a_i,b_i$ 和 $c_i$ 的关系。显然有以下三种：

1. $a_i=b_i=c_i=0$。此时可以用矛盾的办法，规定限制 `xi -> !xi`，也就是如果该位置为 $1$ 会产生矛盾，从而确保这一位的数值。
2. $a_i=b_i=c_i=1$。类似于1。
3. 三个数中有 $1$ 个$1$，$2$ 个 $0$，或者有 $1$ 个 $0$ 和 $2$ 个 $1$。

假如把某个位置 $i$ 的所需情况表示为 $a_i,b_i,c_i$，那么第三种情况可以分以下三个**类型**：

1. $1,1,0$ 和 $0,0,1$。
2. $1,0,0$ 和 $0,1,1$。
3. $0,1,0$ 和 $1,0,1$。

以第一类为例子，输入数据为：

```
5
0 1 1 0 0
1 1 1 0 0
1 0 0 1 0
```

首先对于 $0,0,0$，由于它可以自给自足，所以可以不在 2-SAT 过程中考虑这一列。之后尝试手算属于第 $1$ 类的中间 $3$ 列，发现满足条件的限制组合中可能包括以下几项：`x2 -> x3, !x2 -> !x3, x2 -> !x4, !x1 -> x4`。

转化成 2-SAT 图（注意以下图省略了边 $(u,v)$ 的对称边 $(-u,-v)$）：

![](https://cdn.luogu.com.cn/upload/image_hosting/ufcvfv2t.png)

这时，我们刚才推导的**对称性**和**传递性**就产生了作用。对于任何一个结点，它的选择取决于它的前代结点有没有被选择，而前代结点是否被选择关系到其前代结点是否被选择。以此类推，我们发现实际上 `x2 -> x3, x3 -> !x4` 这一类限制都可以转化成图中的 `x2 -> !x4`，也就是在不构造环的前提下，想要最小化限制的数目，就应该把限制都转化成 `u -> v` 的形式，且 **$u$ 没有前代结点**。

回归刚才的例子，可以联想到这样的过程就类似于**并查集**中的路径压缩，把其中一个 $1,1,0$ 对应的结点 $2$ 作为**代表节点**，统一连向所有其它形如 $1,1,0$，$0,1,1$ 的结点。这样**只要代表节点所处位置的值确定，其它形如它的位置的值都确定了**。例如在例子中，当位置 $2$ 的值为 $1$，就已经确定了位置 $3$ 为 $1$，位置 $4$ 为 $0$，反之同理。

在这一基础上，当**所有限制条件在 2-SAT 图上对称**，那么也就是说所有的可能情况实际上构成了若干个**弱联通分量**。可以发现，一共只有 $3$ 种类型，由于对称性，实际上就至多有 $6$ 个弱联通分量。

对于每个弱连通分量，很明显是一个菊花图，也就是实际上**所有其它结点都被代表结点所唯一确定**，因此得到终极推论：

**原问题和由不超过 $6$ 个代表节点所组成的 $n\le3$ 的问题等价。**

## 3. 解决

思路很简单，先在输入过程中处理出每个位置 $i$ 的**类型**，然后确定每种类型的从左往右数第一个位置为**代表结点** $u$ 的位置，按照思路向之后的每个同类结点 $v$（或 $-v$）建立限制。如果两者恰好相反（如$0,0,1$，$1,1,0$）就向 $v$ 和 $-v$ 两个结点中和自己的符号相反的那个建边。注意每个位置有 $2$ 个代表，所以每次要建立两条边 $(u,v),(-u,-v)$。

通过朴素算法测试发现，假如最后发现总共只有 $1$ 种类型的序列（除去三个元素都相同的那些序列），表示数据出现 $a,b,c$ 重复的情况，不符合题意；如果 $3$ 种都有，那么无论如何都**不可能对三个代表结点正确地互相限制**，进而会出现无解。

换言之，**只有恰好出现 $2$ 种本质不同类型序列时，才会有解**。

根据之前的分析，我们只需要考虑对代表结点进行限制，也就是问题转化成类似于：

```
2
1 0
1 1
0 0
```
显然可以把简化后的 $a',b',c'$ 看成两位二进制数，共有四种情况，其中没有出现在 $a',b',c'$ 中的就是需要排除掉的那一种，例如在本例子中，为了排除 $0,1$ 这种情况，增加限制 `!x1 -> !x2`、`x2 -> x1` 均可。

增加的这个限制加上最开始对于 $0,0,0$ 和 $1,1,1$ 的限制以及以**代表结点**为起始点建立的那些限制，即为答案。

```cpp
#include<iostream>
#include<fstream>
#include<cstring>
#include<algorithm>
#include<cmath>
#include<vector>
using namespace std;

int n,a[52],b[52],c[52];
int x[505],y[505],num;
bool tg[4];
//记录每个位置的类型 
int f[52],g[52];
//每个类型的代表结点位置 
int head[4];
//记录共有多少种类型、出现过的类型的编号(0,1,2) 
int cnt,s[4]; 
//一次加两条边 
inline void add(int ax,int ay){
	if(ax==ay) return;
	x[++num]=ax,y[num]=ay;
	x[++num]=-ax,y[num]=-ay;
}
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++) scanf("%d",a+i);
	for(int i=1;i<=n;i++) scanf("%d",b+i);
	for(int i=1;i<=n;i++){
		scanf("%d",c+i);
		//对全0或全1加以限制 
		int t=a[i]+b[i]+c[i]; 
		if(t==0) x[++num]=i,y[num]=-i;
		else if(t==3) x[++num]=-i,y[num]=i;
		//100,010,001 
		else if(t==1) f[i]=(a[i]?0:(b[i]?1:2)),g[i]=1;
		//011,101,110 
		else f[i]=(!a[i]?0:(!b[i]?1:2)),g[i]=-1;
	}
	//从代表节点向其它结点连边 
	for(int i=1;i<=n;i++){
		if(!g[i]) continue;
		if(!head[f[i]]) cnt++,head[f[i]]=i,s[cnt]=f[i];
		//注意判断正负性 
		else add(head[f[i]],g[i]*g[head[f[i]]]*i);
	}	
	if(cnt==2&&num<=497){
		//限制没有出现在两个代表位置中的数 
		int tx=head[s[1]],ty=head[s[2]];
		tg[a[tx]*2+a[ty]]=1;
		tg[b[tx]*2+b[ty]]=1;
		tg[c[tx]*2+c[ty]]=1;
		for(int i=0;i<4;i++){
			if(!tg[i]) x[++num]=(i/2)?tx:-tx,y[num]=(i%2)?-ty:ty;
		}
	} else {
		printf("-1");
		return 0;
	}
	printf("%d\n",num);
	for(int i=1;i<=num;i++){
		if(x[i]<0) printf("!");
		printf("x%d -> ",abs(x[i]));
		if(y[i]<0) printf("!");
		printf("x%d\n",abs(y[i]));
	}
	return 0;
}
```