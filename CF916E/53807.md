考虑到这题要换根，

有一种很简单的想法就是直接拿高级动态树等数据结构过去。

我们考虑一种更简单的做法

---

我们先随便以 $1$ 为根，倍增预处理出每个节点的 $2^k$ 级父亲

然后每次是要询问子树内的信息，我们把它映射到 $\text{DFS}$ 序上。

考虑到操作 $2$ 需要询问 $\text{LCA}$，我们有两种方法

第一种是在询问的时候处理，第二种是在修改的时候处理

这里讲的是修改时候处理的方法。

我们分类讨论 $u,v$ 的情况，

我们考虑先求出 $u,v$ 在新的树中的 $\text{LCA}$

这个 $\text{LCA} = lca(u,v),lca(u,root),lca(v,root)$ 中深度最大的点。

我们发现 $\text{DFS}$ 序发生了变化，有点难处理

事实上，我们可以换个角度思考，我们只需要知道在原树上我们需要修改的东西。

如果求出的 $\text{LCA}$ 在原树中是 $root$ 的祖先，那么我们要修改的区间相当于 $[1,n] +x$ ，以及将多余部分 $-x$

多余部分在字典序上是连续的，读者可以思考一下

如果不是，那就直接修改 $\texttt{LCA}$ 的子树

时间复杂度 $O(nlogn)$ 就拿线段树维护一下 $\text{DFS}$ 即可