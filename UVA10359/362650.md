
对于刚学递归的蒟蒻（~~本人~~）来说，这道题是一道很好的**模板题**。

（~~首先别告诉我你连题目描述也看不懂~~）

假如你看懂了，就可以发现，这其实就是一道图形覆盖的递归。

递归的边界：$f_0=f_1=1$（无法覆盖也算一种），$f_2=3$。

首先，我们看到第一种情况：

![](https://i.postimg.cc/d0frYx58/image.png)

这时候，我们可以很轻易地得出，$f_i=f_{i-1}$。

然后是第二种：

![](https://i.postimg.cc/VLjNsVkj/2.png)

这时候，我们又可以很轻易地得出，$f_i=f_{i-2}$。

最后是第三种：

![](https://i.postimg.cc/Fz0hRYN9/3.png)

这时候，我们仍然可以很轻易地得出，$f_i=f_{i-2}$。

如果还想往下推，我们会发现，变成了这三种形式的组合。换句话说，

**这是最基础的三种情况。**

于是，我们就可以得出递推式：$f_i=f_{i-1}+f_{i-2}\times 2$。

-----------------

**但是，这就结束了吗？**

做题时会突然注意到，题目中的 $n \leq 250$。

我们粗略估计，发现这数据范围实在是大的一批。

那么这时候，就**只能**用高精度了。（~~本蒟蒻实在是懒得打高精度~~）

这时候，我们定义 $f_{i,j}$ 为 $2 \times i$ 这个长方形的方案数的每一位。

那么，递推式就有一定的更改：$f_{i,j}=f_{i-1,j}+f_{i-2,j}\times2+x$。

其中，$x$ 指的是前一位的进位。

最后，去除前导 0，倒序输出即可。

--------------------

**AC 代码**
 ~~~~cpp
 #include<bits/stdc++.h>
 using namespace std;
 int f[260][250];
 int main(){
	 int n,b=0;//b 处理进位 
	 f[0][1]=1;//递归边界 
	 f[1][1]=1;
	 f[2][1]=3;
	 for(int i=3;i<=250;i++)
	 	 for(int j=1;j<=250;j++){
			 f[i][j]=f[i-1][j]+2*f[i-2][j]+b;//递归 + 高精度 
			 b=f[i][j]/10;
			 f[i][j]%=10;
		 }
	 while(cin>>n){
		 int k=250;
		 while(!f[n][k]&&k) k--; //去除前导 0 
		 for(int i=k;i>=1;i--) cout<<f[n][i]; //倒序输出 
		 cout<<endl;
	 }
	 return 0;	
 }
 ~~~~