## 题目大意

把从 $1$ 到 $n^2$ 的 $n^2$ 个数排成一个 $n \times n$ 的矩阵，使得矩阵每两个相邻的数的差组成的可重集中不同的数的数量最多。

## 基本思路

首先，显而易见的可以看出数量最多时从 $1$ 到 $n^2-1$ 都曾在集合里出现过。

那么问题便转化成了保证这些数都曾在矩阵相邻元素的差值中出现过。

考虑将矩阵变为长度为 $n^2$ 的一条链，然后保证这些元素在该链相邻元素的差值中出现过。

假设第一个数放 $1$，由于所有数都要出现，所以第二个数必然是 $n^2$，
以此类推可以得到一个序列是最大最小数相互交替,满足以上要求。

得到了这样的序列我们可以将其转化为矩阵并保持相邻的数依然相邻，这样的矩阵必然是符合要求的。

可以将序列蛇形排列，例子:

```
链： 

1 9 2 8 3 7 4 6 5

矩阵： 

1 9 2
7 3 8
4 6 5
```

这样问题就解决了。

## 代码实现

赛时代码，十分简单：

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(void)
{
	int T;
	cin>>T;
	while(T--)
	{
		int n;
		cin>>n;
		int a[2550],b[55][55];
		for(int i=1;i<=n*n;i++)
		{
			if(i%2==1)a[i]=(i/2)+1;
			else a[i]=n*n-(i/2)+1;
		}
		int sum=0;
		for(int i=1;i<=n;i++)
		{
			if(i%2==1)
				for(int j=1;j<=n;j++)
				{
					++sum;
					b[i][j]=a[sum]; 
				}
			else 
				for(int j=n;j>=1;j--)
				{
					++sum;
					b[i][j]=a[sum];
				}
		}
		for(int i=1;i<=n;i++)
		{
			for(int j=1;j<=n;j++)
				cout<<b[i][j]<<" ";
			cout<<endl;
		}
	}
	return 0;
}
```

