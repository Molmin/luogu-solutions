### 题目大意：

对于一个 $n\times n$ 的矩阵，对于每一对相邻（有公共边）的值 $a,b$，写下 $|a-b|$（即 $a$ 与 $b$ 差的绝对值）。定义这个矩阵的美丽度为写下的不同的值的个数。以如下的矩阵为例：

$$\left(\begin{matrix}1&3\\4&2\end{matrix}\right)$$

则所有相邻值的绝对值分别是 $|1-3|=2,|1-4|=3,|3-2|=1,|4-2|=2$。共有 $1,2,3$ 三种不同的值，则这个矩阵的美丽度为 $3$。

给你 $t$ 次询问，每次询问给定一个正整数 $n$。输出任意一个 $n\times n$ 的矩阵，满足 $1\sim n^2$ 在矩阵中各出现一遍，并且该矩阵的美丽度最大。

---

### 题解：

首先，相邻值的差的绝对值，一定在 $1\sim n^2-1$ 之内。

然后我们考虑差。$1$ 必须跟 $n^2$ 相邻，因为只有它们能构造出 $n^2-1$ 的差。然后为了构造出 $n^2-2$ 的差，可以再让 $n^2$ 与 $2$ 相邻。同理 $2$ 跟 $n^2-1$ 相邻，$n^2-1$ 再跟 $3$ 相邻……这样，就可以构造出 $1\sim n^2-1$ 的所有差了，而且数还不重复。

然后我们就把数填入矩阵中就好了。可以“之”字形填，也可以螺旋形填……我用的是前者。只要保证应该相邻的数相邻就好了。

举个例子，如果 $n=3$，按照刚才说的方法填，可以填出如下的矩阵：

$$\left(\begin{matrix}1&9&2\\7&3&8\\4&6&5\end{matrix}\right)$$
 
时间复杂度 $O(t\times n^2)$。代码如下：

```cpp
#include<iostream>
using namespace std;
int a[60][60];
int main()
{
    int t;
    cin>>t;
    while(t--)
    {
        int n;
        cin>>n;
        a[1][1]=1;
        int last=1,now=n*n-1,p=1;
        for(int i=1;i<=n;i++)
        {
            if(i%2)
                for(int j=(i==1?2:1);j<=n;j++)
                {
                    a[i][j]=last=last+now*p;
                    p=0-p,now--;
                }
            else for(int j=n;j>=1;j--)
                {
                    a[i][j]=last=last+now*p;
                    p=0-p,now--;
                }
        }
        for(int i=1;i<=n;i++)
        {
            for(int j=1;j<=n;j++)
                cout<<a[i][j]<<" ";
            cout<<endl;
        }
    }
    return 0;
}
```