一种做法是 SA + Hash，其他题解已经介绍。另一种是我看 [Itst 的代码](https://codeforces.com/contest/917/submission/72507193) 学的，广义 SAM + 点分治。两个做法的核心思想是一致的，只是对某个子问题的实现方式有所不同。我采用的是后者，故这里讲后者。

首先点分治，考虑跨过分治重心的链，可以分为左边一条从下往上的链，和右边一条从上往下的链。

模板串完全出现在其中某一条链的情况是简单的，只需要对 $n$ 个模板串（及其反串）事先建好 ACAM，然后把当前的分治子树按 DFS 序遍历，遍历时放到 ACAM 上走即可。

对于跨过分治重心的匹配，一定是左边匹配上了 $s_k$ 的一段前缀，右边匹配上了 $s_k$ 的一段后缀，且两者长度加起来等于 $|s_k|$。假设已经找到了 $s_k$ 的最长前缀 $P$，使得是左边的串的后缀，那么其他可行的前缀，一定是 $P$ 的 border，而 $P$ 的所有 border 就是 $s_k$ 的 Fail 树上 $P$ 的所有祖先；同理右边可行的后缀也是 $s_k$ 的反串的 Fail 树上某个 $Q$ 的所有祖先。对于正串的 Fail 树上的某个节点，在反串的 Fail 树上有唯一的一个与之对应的节点，满足两者长度之和等于 $|s_k|$，于是这就是个二维数点，离线后在一棵树上 DFS 并用 BIT 维护即可。

现在唯一的问题是找到 $P$。这个问题抽象出来就是：有一个 Trie 和若干个串 $s_i$，以及若干个询问，每个询问给定 Trie 上任意的某个节点，设其对应的串为 $t$，找到 $t$ 最长的前缀 $P$，使得 $P$ 是 $s_k$ 的后缀。

至此，与 SA 做法没有不同。

对所有 $s_i$ 建立广义 SAM，然后在 Trie 上 DFS，并维护一个在 SAM 上走的指针，这样就知道 Trie 上每个点在 SAM 中对应的点是谁了。那么对于 Trie 上的节点 $x$，其可能的 $P$ 一定是 $x$ 的最深的祖先 $g$，满足 $g$ 能**完整地**被 SAM 中的某个等价类 $y$ 包含，且 $y$ 是 $s_i$ 在 SAM 中对应的节点的 parent 树上的祖先。于是，可以在 DFS 的过程中往 $g$ 所在的等价类 $y$ 里面塞一个 $dep(g)$，表示该等价类有一个这样的候选答案，回溯时再撤销，每次在 $s_i$ 的祖先中找到最大的候选答案。观察到一个性质，parent 树上的点由浅到深，如果有候选答案，则候选答案依次增大（因为候选答案一定等于等价类中某个串的长度，而等价类的串长是递增的）。于是，只需要找到 $s_i$ 的祖先中最深的候选答案（且满足 $\le |s_i|$）即可。可以对 parent 树重链剖分，每条重链维护升序的候选答案，则对于当前所在重链可以 $O(1)$ check 是否有可行答案，并且可以二分找到可行的答案。因此这部分的复杂度是 $O(\log n)$ 的。而由于在 trie 上 DFS 时 $dep(g)$ 递增，所以插入的候选答案一定也是递增的，不需要额外的 DS 处理，那么直接用 `vector` 维护即可。因此总复杂度为线性对数。

综上，我们处理了所有情况。算上最外层的点分治，总复杂度为 $O(n\log^2 n)$，可以通过本题。

实际上把 SAM 稍微处理一下就可以当做 ACAM 用，所以不需要额外写个 ACAM。

[代码](https://codeforces.com/contest/917/submission/193704295)

