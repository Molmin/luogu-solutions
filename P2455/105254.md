作为刚刚刷完模板题想来练练手的蒟蒻，还没摆脱模板题top1题解的影响，于是就想拿  _高斯-约旦消元法_  来过这道题。

然而当我读完题后，才发现 _高斯-约旦消元法_  那美妙的"\\"字形在这题并不能体现，于是~~菜的不行的~~窝就去翻题解...

遗憾的是，当时我只找到了一篇来自~~小~~**诗乃**的[**题解**](https://www.luogu.com.cn/blog/asadashino/solution-p2455)，可这篇题解的代码也有很多**冗余的计算**。

最后，我就只好自力更生了

---
- 我们先来回顾一下用于消元的工具 **增广矩阵** ；以及它的两种变换：交换行，对两行数字做加减。这两种变换后得到的矩阵**本质上是没有变化的**

- 现在再来回顾  _高斯-约旦消元法_  （**假设有唯一解**）的步骤：

1. 以列遍历，从一侧到另一侧；为了方便操作，通常从上至下遍历行，将操作行转移至当前行
2. 先从当前操作行及尚未操作的行找到一个主元（通常取当前列系数最大的，可以证明这样精度误差最小（~~虽然我不会证~~）），再从除该行的所有行里消去这个元
3. 重复`2`，直至遍历完毕

如果你手推过或仔细观察过它的过程，你会发现这个算法**有两点重要的性质**（为了描述方便，以下均默认用上文描述为" _通常_ "的操作方式）：

- 每次消元完后，当前列只有当前行不为$0$
- 当前列左边的数均为$0$

---
现在我们回到这道题；因为  _高斯-约旦消元法_  并不一一待会，显然其难点就在于**无解**和**无穷解**的判定

假设一个遇到找不到主元的情况（即当前及下面的行的该列均为$0$）

我们可以发现：

- 当前列左边的数仍均为$0$
- 当前操作列及其下面的数均为$0$

于是便想到**转而处理下一列，操作行不变**，以**维持**这样的性质

---

现在我们按上述算法遍历完了所有列，当前矩阵也仍满足性质：

- 每次操作列左边的数均为0
- 每次操作列从那次操作行下面一行开始全为$0$

于是发现它就是一个"**坡度不一"的"倒三角**"（不考虑等式右边常数项），对于**未操作的行**（即"三角"下面的行），**其中的系数全为0！**

这样的"**倒三角**"中可以确定最下面的一个未知数（或可能已经给出解），**往上一一带回一定可以求解**；
\
也就是说**只要判定下面未操作行是否会导出矛盾**就可以对整个方程组做出判定了！

那么就好办了，反正**系数全为**$0$，常数项只要都为$0$就是**无穷解**，否则就是**无解**

---
$\color{#ffb464}\texttt{顺便推下我的}$[$\color{#32dddd}\texttt{博客}$](https://www.luogu.com.cn/blog/105254/)

---
### 参考代码
```cpp
#include <cstdio>
#include <cmath>
#include <iostream>
using namespace std;

double A[50][51];
int N;

int main(){
	scanf("%d", &N);
	for(int i =0; i < N; ++i) for(int j =0; j < N+1; ++j)
		scanf("%lf", &A[i][j]);
	int nwline =0;
	//k指主元序号(列) 
	for(int k =0; k < N; ++k){//需要考虑无穷解，循环到N 
		int maxi =nwline;
		for(int i =nwline+1; i < N; ++i)
			if(abs(A[i][k]) > abs(A[maxi][k])) maxi =i;
		if(A[maxi][k] == 0) continue;
		for(int j =0; j < N+1; ++j)
			swap(A[nwline][j], A[maxi][j]);
		for(int i =0; i < N; ++i){
			if(i == nwline) continue;
			double mul =A[i][k]/A[nwline][k];
			//A[nwline][i] =0;//这里判不判无所谓，因为这一列其他的项之后都可以推出来了(0)，不用再访问 
			for(int j =k+1; j < N+1; ++j)
				A[i][j] -=A[nwline][j]*mul;
		}
		++nwline;
	}
	//最后的元随机分配就行了，结果不会有差，不如说左边一定都是0
	if(nwline < N){
		while(nwline < N)
			if(A[nwline++][N] != 0) return puts("-1") && 0;
		return putchar('0') && 0;
	}
	for(int i =0; i < N; ++i){
		printf("x%d=", i+1);
		if(int(A[i][N]/A[i][i]*100) == 0) puts("0");
		else printf("%.2lf\n", A[i][N]/A[i][i]);
	}
}
```
