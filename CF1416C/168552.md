# CF1416C XOR Inverse题解
原题链接 https://www.luogu.com.cn/problem/CF1416C

看题解多是 01tree，于是写了一份暴力的算法(也更好理解）。

首先读题，题干要求我们从在范围内找到一个 $x$，对数列 $a$ 的每个元素异或 $x$，使得异或后的 $a$ 数组的逆序对最小。

最简单的暴力思想是直接枚举 $x$，但是很明显数据范围要炸。

所以我们考虑如何优化枚举的过程。

我们观察一个数异或上另一个数，每次异或，都是对当前位置产生影响，而不会影响后面或前面的位置，所以对于一个数的异或，我们考虑在二进制下进行。

考虑所有数字的二进制表达。

我们先关注最高位，只有 $0$，$1$ 两种数字。

我们异或上去的这个数字，要么在这一位是 $0$，也就不改变这一位的数字；

要么异或上去这个数字，在这一位是 $1$，就会使得最高位 $0$ 变 $1$，$1$  变 $0$ 。

目前看来，就这两种情况。

1. 那么我们先考虑这两种情况会产生的逆序对数目，在只关注最高位的情况下，我们只知道，最高位为 $1$ 的数字，一旦出现在了最高位为 $0$ 的数字前面，那么他们一定形成逆序对。

2. 而对于最高位相同的数字，由于我们目前只关注最高位，所以我们看不出它们的差异。

因此我们目前只用考虑第 $1$ 种情况下的逆序对数目，来确定最高位到底是异或  $0$ 还是 $1$ 更优。

从 $2$ 的 $32$ 次方开始枚举，可以完全覆盖需求。

定义一个数 $xo$ 表示最后的答案，最开始令 $xo$ 为 $0$ 。

从 $2$ 的 $32$ 次方开始枚举每一位数，先令 $xo$ 加上这个数，让 $xo$ 对 $a$ 数组进行异或操作，判断结果是否更优。如果更优，则保留加上的这一位，否则去掉。然后继续枚举到 $2$ 的 $0$ 次方，这样我们就得到了结果。过程中记录一下逆序对个数最小值，输出即可。

```c++
#include<cstdio>
#include<iostream>
#include<cstring>
using namespace std;
typedef long long ll;
ll a[500010],c[500010];
ll ans,minn,xo;
ll b[500010];
int n;
void msort(int x,int y)//归并排序求逆序对
{
    if(x==y)  return;
    int mid=(x+y)/2,i=x,j=mid+1,k=x;
    msort(x,mid),msort(mid+1,y);
    while(i<=mid&&j<=y){	 
    	if(a[i]<=a[j])c[k++]=a[i++];
    	else c[k++]=a[j++],ans+=mid-i+1;
    }	
    while(i<=mid)c[k++]=a[i++];
    while(j<=y)c[k++]=a[j++];
    for(int i=x;i<=y;i++)a[i]=c[i];
} 
void deal(){//复原a，c数组
	for(int i=1;i<=n;i++){
		a[i]=b[i];
	}
	memset(c,0,sizeof(c));
}
int main()
{
    scanf("%d",&n); 
    for(int i=1;i<=n;i++)scanf("%lld",&b[i]),a[i]=b[i];
    ll xx=2147483648;//枚举起点
    msort(1,n); deal();//初始化
    minn=ans;//记录最开始的值
    for(int i=31;i>=0;i--){
		ans=0;   //每次先把ans复原，用来存储逆序对个数
		xo^=xx;  //xo+=xx
		for(int j=1;j<=n;j++){
			a[j]^=xo; //暴力修改每一个数
		}
		msort(1,n);deal();//求值并复原
		if(ans<minn){//如果更优则替换
			minn=ans;
			xo^=xx;//因为下面操作还要异或一次，所以这里必须先进行一次
		}
		xo^=xx;//不优则复原
		xx>>=1;//枚举下一位
	} 
    printf("%lld %lld",minn,xo);
    return 0;
}
```
（谢谢dottle老师教我写题解的格式！）