## 题意

给一个 $ 0|1 $ 序列 $ A $，每一次变化会将原序列 $ A $ 上的元素 $ A_i $ 变为 $ A_{i - 1}\bigoplus A_{i + 1} $（每一个元素的更改同时进行互不影响）。

## 思路

看到异或，因为其本质实际上是不进位加法，于是就联想到加法，然后发现如果把原来变化换成加法然后在把奇数看成 $ 1 $，偶数看成 $ 0 $，这两实质上是一样的，并且每一位数字的值的贡献只会给两个相邻的元素，并且自己不受自己影响~~然后再通过打表发现寻找每一个 $ 1 $ 最终能影响什么 [打表程序（附图，浅显易懂）](https://www.luogu.com.cn/paste/sw0kx528)~~ 。

考虑一个位置上如果有 $ 1 $ 会影响什么，因为异或或加法是符合结合律的，所以可以通过扩展得到整个数列会影响什么。

感性地理解后，我们可以发现当只有一个 $ 1 $ 的时候，并把异或运算变为加法运算时，整个序列的结构与[杨辉三角](https://baijiahao.baidu.com/s?id=1607063654204393620)相似，未经过更改时，初始序列在第 $ 1 $ 层，整个数列每经过第 $i$ 次操作其实就像是从杨辉三角的第 $ i + 1 $ 层变为第 $ i + 2 $ 层，并且更换奇数（即 $ 1 $ 的位置的奇偶性）。

事实上这样的类似杨辉三角结构的三角形叫做[谢尔宾斯基三角形](https://cn.mathigon.org/course/fractals/sierpinski)。

如果整个序列是个谢尔宾斯基三角形，那么就会有一个性质，谢尔宾斯基三角形的第 $ 2^i $ 层上的数全是 $ 1 $，此在第 $ 2^i + 1 $ 层时会发现，这时候会发现只有两个数字会为 $ 1 $（两个被更改为 $ 1 $ 的位置距离原来的 $ 1 $ 的距离为 $ 2^i $）~~然后比赛时就傻瞪着这个结论坐了两小时不知道干什么~~。

![](https://pic3.zhimg.com/80/v2-646bcd3eff9aad3f18b0d8842d09f956_720w.webp)

发现了这个性质后，希望如果 $ k $ 正好为 $ 2 $ 的次幂的形式就好做了，为这样的话序列上的每一个 $ 1 $ 只需要考虑对序列中两个其他位置的影响。为每一次变化都是一样的，么就想到了把 $ k $ 次操作分开来考虑。

实际上这时做法就很明显了，了简化操作，我们可以对变化总数 $ k $ 变成多个二次幂次的变化分别依次进行的形式，$ k = 2^{q_1} + 2^{q_2} + 2^{q_3} + \cdots + 2^{q_{m-1}} + 2^{q_m} $，我们发现这样操作次数就从原来的 $ O ( k ) $ 次化简为 $ O ( \log k ) $ 次，这样的话因为每一次整个序列最多存在 $ n $ 个 $ 1 $，每次都模拟每一个 $ 1 $ 怎样影响别的位置，复杂度都是 $ O ( n \log k ) $ 次，就是 $ 6 \times 10^5 $ 左右的量级，这个复杂度是对的。

## Code

```cpp
#include<bits/stdc++.h>
using namespace std;
bool a[500001],b[500001];
char s[500001];
int main() {
	int n;
	long long k;
	scanf("%d%lld%s",&n,&k,s+1);
	for(int i=1; i<=n; ++i) {
		if(s[i]=='1') {
			a[i]=1;
		} else a[i]=0;
	}
	//a数组存储当代的情况 
	long long ch=1;
	while(k>=ch) {
		if(k&ch) {
			//每一次操作时用b数组模拟下一代，操作结束时再将b数组的值重新赋给a 
			for(int i=1; i<=n; ++i)b[i]=0;
			for(int i=1; i<=n; ++i) {
				if(!a[i])continue;
				b[((i-ch)%n+n-1)%n+1]^=a[i];
				b[(i+ch-1)%n+1]^=a[i];
			}
			for(int i=1; i<=n; ++i)a[i]=b[i];
		}
		ch<<=1;
	}
	for(int i=1; i<=n; ++i) {
		if(a[i])putchar('1');
		else putchar('0');
	}
	return 0;
}
```