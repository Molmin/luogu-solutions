## 题解

我们将原串下标从 $0$ 至 $n - 1$ 编号，用 $s_p$ 表示位置 $p$ 上的数字。首先有如下结论：

对于一个位置 $p$，若 $s_p$ 在经过 $c(c = 2^k)$ 次变换后为 $1$，当且仅当环上从 $p$ 开始左数第 $c$ 个位置上的数字与右数第 $c$ 个位置上的数字不相同。

证明如下：

- 首先，当 $c = 1$（即 $k = 0$）时显然成立。
- 考虑 $c = 2$（即 $k = 1$）。
    - 考虑 $p$ 左数 $2$ 个位置与右数 $2$ 个位置的值不相同，不妨设 $p = 2$，原串为 $0???1$。由于 $s_2$ 只有 $0/1$ 两种取值，换句话说，$s_2$ 必然与 $s_0, s_4$ 的其中一个相同，与另一个不相同，这样，我们在经过一次变换后得到的 $s_1$ 与 $s_3$ 也不相同，故 $2$ 次变换后 $s_2$ 必为 $1$。
    - 考虑 $p$ 左数 $2$ 个位置与右数 $2$ 个位置的值相同，也不妨设 $p = 2$，原串为 $0???0$。由于 $s_2$ 无论取 $0/1$，都必然为：要么和 $s_0, s_4$ 都相同，要么和 $s_0, s_4$ 都不相同，这样经过一次变换后得到的 $s_1$ 与 $s_3$ 一定相同，故 $2$ 次变换后 $s_2$ 必为 $0$。

  故 $c = 2$ 时结论成立。
- 注意在上述 $c = 2$ 的分析过程中，无论 $s_2$ 取何值，我们都能得到两个 $c = 1$ 的子问题，且若两端值不同，这两个子问题的结果也必然不同；若两端值相同，这两个子问题的结果也必然相同。由此可以推广得到：通过 $c = 2^k$，我们可以得到两个 $c = 2^{k - 1}$ 的子问题。这样当 $k$ 更大时，结论显然也是成立的。

有了该结论后，本题就可以通过将 $T$ 拆位后在 $O(n \log T)$ 的时间内解决了。

## 代码

~~~cpp
#include<bits/stdc++.h>

using namespace std;

#define rg register

typedef long long ll;

const int N = 1e5 + 10;

int n;
ll k;
char s[N], t[N];

inline void trans(int len) {
  for (rg int i = 0; i < n; ++i) {
    t[i] = '0' + (s[(i - len + n) % n] ^ s[(i + len) % n]);
  }
  memcpy(s, t, sizeof t);
}

int main() {
  scanf("%d%lld%s", &n, &k, s);
  for (rg int i = 60; ~i && k; --i) {
    if (k >> i & 1) {
      trans((1ll << i) % n);
      k -= 1ll << i;
    }
  }
  printf("%s\n", t);
  return 0;
}
~~~