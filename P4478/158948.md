考场打了普通 Lucas 就开始划水的题，下来 3min 就秒了qwq，逛了一圈题解发现都做麻烦了，给个简单的处理办法。（sto @[_ Enthalpy](https://www.luogu.com.cn/user/42156)）

首先 $T$ 的范围小的让人不习惯（毒瘤赛做多了），范围给这么小直接暴力容斥即可。

随便口胡一下容斥过程：

考虑随便从起点走到终点，假设没看到障碍，于是可能经过不能走的点。

减去经过了一次非法点的方案，就会多减了经过两次的，再加回来又会加多，以此类推，不难看出容斥过程。

于是我们钦定经过了 $k$ 次障碍点，容斥系数就是 $(-1)^k$，考虑求方案数。

发现这个方案数可以 DP，于是就做 DP，设 $f_{i,j}$ 表示当前在第 $i$ 个点，钦定了 $j$ 个障碍点被经过的方案。

然后从左下角的障碍点转移过来即可，状态 $O(T^2)$，转移 $O(T)$，其实可以用 DS 优化转移，但难得出题人良心只开 $T=200$，直接 $O(T^3)$ 即可。

看一眼坐标范围，发现事情没这么简单，先考虑 $P=100003$。

由于是个质数而且还比较小，可以预处理在 $P$ 以内的组合数，$P$ 以外的就用 Lucas 就没问题了。

~~考场由于不想推 CRT，打到这里就溜了（~~

再考虑 $P=1019663265$，发现 $1019663265=3* 5* 6793* 10007$，如果你比较勤快可以直接写一个扩展 Lucas，或者采用以下办法：

发现质因子只有一次，对每一个质因子当做模数做一遍，然后找到一个同时符合这四种模数的答案即可。

只要学过 CRT 的都能看出来这就是 CRT（，那么这也就是唯一的。

但我不想推 CRT 欸，~~那去写插值吧~~，发现质因子都很小，可以直接枚举。

其实这就是暴力 CRT，通过枚举而不是直接推式子快速算到，复杂度是 $O(k\max_{1\le i\le k}{p_i})$，其中 $p_i$ 是第 $i$ 个质因子，$k$ 是质因子个数，出题人给的模数良心放给你用都不用？

枚举即可，~~由于太简单都不知道对暴力 CRT 说点什么~~，看一眼代码实现相信大家都会了：

```
//ans：当前答案
//mod：当前模数
//anss[]：每个质因子分别做的答案
//pre[]：每个质因子
	ans=anss[0];
	int mod=pre[0];
	for(i=1;i<4;i++)
	{//枚举新的质因子及答案进行合并
		for(j=-pre[i];j<=pre[i];j++)
		{//枚举一个符合模数的答案，即j*mod+ans，判断是否和新的模数契合。
			if(M((LL)j*mod+ans,pre[i])==M(anss[i],pre[i]))
			{//找到契合的就走人
				ans=M((LL)j*mod+ans,mod*pre[i]);
				mod*=pre[i];
				break;
			}
		}
		assert(j<=pre[i]);
	}
	writenum(ans,10);
```