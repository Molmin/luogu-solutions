显然对于所有 $\texttt{AND}$ 型结点，如果其在某一时刻权值变为 $0$，那么在后续时刻将不再变化权值。$\texttt{OR}$ 型结点同理在变为 $1$ 后不再发生变化。所以我们考虑对于所有最终权值为 $0$ 的结点，将 $\texttt{OR}$ 型称为**强制型**，$\texttt{AND}$ 型称为**非强制型**，最终权值为 $1$ 的结点反之。

可以发现对于所有强制型结点，其自身和周围结点的权值必须始终保持和该点最终权值相同，也就是要满足下面两个条件：

1. 自身和周围结点的最终权值相同。
2. 自身和周围结点的初始权值均和该点最终权值相同。

而对于所有非强制型结点，其初始权值不一定要和最终权值相同，其可以利用周围结点来传入最终权值。

根据上面的条件，显然对于一条连接两个**最终权值不同**的结点的边，其连接的两点均为非强制型结点。

那么对于一个**最终权值相同**的连通块，其最终权值满足条件需要满足下面两个条件之一：

1. 连通块内存在某个点，其初始权值和最终权值相同。
2. 连通块外存在某个和该连通块相邻的点，其初始权值和该连通块最终权值相同（因为那个点以及其在该连通块内相连的点均为非强制型结点）。

于是我们可以设 $f_{i,0/1,0/1,0/1}$ 表示以 $i$ 为根的子树内，结点 $i$ 的初始权值和最终权值相同/不同，结点 $i$ 为非强制型/强制型结点，$i$ 所在的连通块还未满足/已经满足最终权值的条件时的初始权值和类型的组合数，直接根据上面要求来转移即可。此时已经做到复杂度 $O(n)$

进一步观察，可以发现上面的 $8$ 种状态中我们真正需要的只有 $4$ 种：

+ 初始权值相同，强制型，已满足。
+ 初始权值相同，非强制型，已满足。
+ 初始权值不同，非强制型，已满足。
+ 初始权值不同，非强制型，未满足。

其余 $4$ 种容易发现其状态并不存在，所以我们直接在上面 $4$ 种情况之间 dp 即可。

```cpp
#include<bits/stdc++.h>
#define p 998244353
using namespace std;
int lw[200005],bi[400005][2],bs;
int f[200005][4],g[4];
int n,a[200005];
int dr()
{
	int xx=0;char ch=getchar();
	while(ch<'0'||ch>'9')ch=getchar();
	while(ch>='0'&&ch<='9')xx=xx*10+ch-'0',ch=getchar();
	return xx;
}
void tj(int u,int v){bi[++bs][0]=lw[u],bi[lw[u]=bs][1]=v;}
void dfs(int w,int fa)
{
	f[w][0]=f[w][1]=f[w][3]=1;
	for(int o_o=lw[w];o_o;o_o=bi[o_o][0])
	{
		int v=bi[o_o][1];
		if(v!=fa)
		{
			dfs(v,w);
			memset(g,0,sizeof(g));
			if(a[w]==a[v])
			{
				g[0]=1ll*f[w][0]*(f[v][0]+f[v][1])%p;
				g[1]=1ll*f[w][1]*((f[v][0]+f[v][1])%p+(f[v][2]+f[v][3])%p)%p;
				g[2]=(1ll*f[w][2]*((f[v][1]+f[v][2])%p+f[v][3])+1ll*f[w][3]*(f[v][1]+f[v][2]))%p;
				g[3]=1ll*f[v][3]*f[w][3]%p;
			}
			else
			{
				g[1]=1ll*f[w][1]*(f[v][1]+f[v][2])%p;
				g[2]=(1ll*f[w][2]*((f[v][1]+f[v][2])%p+f[v][3])+1ll*f[w][3]*(f[v][2]+f[v][3]))%p;
				g[3]=1ll*f[v][1]*f[w][3]%p;
			}
			memcpy(f[w],g,sizeof(g));
		}
	}
}
int main()
{
	n=dr();
	for(int i=1;i<=n;i++)a[i]=dr();
	for(int i=1;i<n;i++)
	{
		int x=dr(),y=dr();
		tj(x,y),tj(y,x);
	}
	dfs(1,0),printf("%d",((f[1][0]+f[1][1])%p+f[1][2])%p);
}
```
