## 题意翻译
  有一个保险柜锁，开始的时候针头指向0。将针头拨到A的位置，再将针头拨到B的位置，最后再将针头拨回0的位置，这样就可以将锁打开了。
  每次只能向左或右拨1个单位，问最少拨多少次可以把锁打开。
  
（A,B,0互不相等，-100<=A,B<=100）

（锁是不可以循环拨的，即不能从100拨到-100）
#### 输入格式
一行，两个数字，即A和B的位置。
#### 输出格式
一个数字，就是需要拨的最少次数。要求在结尾输出一个换行符。
## 做法：
因为这道题不需要考虑循环拨，所以每次直接向目标拨过去就行了。

只要求出A和B之间的距离，就是从A到B的最小拨动次数。打开锁需要0->A->B->0，所以只要求3次两点间距离，再累加起来输出就可以了。

可以把锁看成一个数轴，只要用两点中的大坐标减去小坐标，得的结果就是两点间距离了。

看代码吧
## AC代码：
  ```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#include<cmath>
#include<algorithm>


using namespace std;


int main() {
    int a,b,s=0;//s为所求的最小次数

    cin>>a>>b;
    if(a>0) {
        s+=a;//即a-0
    }
    else {
        s+=s-a;
    }//计算从0拨到A需要的最少次数
    if(b>a) {
        s+=b-a;
    }
    else {
        s+=a-b;
    }//计算从A拨到B需要的最少次数
    if(b>0) {
        s+=b;
    }
    else {
        s+=-b;
    }//计算从B拨回0需要的最少次数
    cout<<s<<endl;//输出结果
}

```
这是本蒟蒻的第一篇题解，希望dalao们不喜勿喷，不好的地方望谅解。