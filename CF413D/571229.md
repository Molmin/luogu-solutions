# 题意
给出 $n$ 个数 $a[1\cdots n]$，是 $0$ 或者 $2$ 或者 $4$，你可以将 $0$ 换成 $2$ 或者 $4$，最后往右合并，问合并出来超过 $2^k$ 数的方案数。
# 思路
这个题翻译对合并过程的解释很有启发性，维护一个栈实现这个操作。

则不难想到将这个栈存到状态中，在这个题的特殊条件下（栈中的数都是 $2$ 的幂且唯一）是可以实现的。

我们可以将合并看做进位操作，所以加入数字也就变成了做加法，如果加入一个无法被合并的数，则就从这里重新开始维护一个栈即可。

具体的，我们使用一个状压表示这个栈，其中二进制第 $i$ 位表示栈中 $2^i$ 这个数是否存在，并且从高位开始排列，举个例子，就大概长这样： $2^{10},2^8,2^4,2^2,2$ ，这些数的和就是我们的状压表示，而超过 $2^k$ 的数没有意义，所以最大只需要 $2^k$ 就行了。

于是状态就简单了，$F_{i,j}$ 表示考虑到第 $i$ 个数，当前栈的状压表示是 $j$ ，由于新加入的数只有 $2,4$ 两种情况，所以可以讨论一下，这里使用填表法比较方便。

1. 加入 $2$，因为 $2$ 是最小的数，所以一定能加进去 $F_{i,j}\to F_{i+1,\min(j+2,2^k)}$ 

2. 加入 $4$ ，如果栈顶不是 $2$ 则可以直接加入，反之 $4$ 就是新的栈底了（新开了一个栈）


总结一下，转移有三种：

$$
F_{i,j}\to \begin{cases} 
F_{i+1,\min(j+2,2^k)}&a_i\neq 4\\
F_{i+1,\min(j+4,2^k)}&a_i\neq2  \wedge \frac{j}{2}\equiv 0\mod{2}\\
F_{i+1,4}&a_i\neq2  \wedge \frac{j}{2}\equiv 1\mod{2}
\end{cases}
$$

由于数学语言最好不带位运算，后面两个就是 $j$ 的二进制第 $1$ 是否为 $1$ 的意思，可对照代码理解。


# 代码

这里取 min 操作不仅有防止溢出的作用，而且如果这个数列提前就到了 $2^k$ 但是后边有加入了一个 $2$ 一个 $4$ ，那不就直接新开一个栈了吗，所以这里有得到一个就停手的意思。
```cpp
int F[MAXN][MAXN];//考虑到前 i 个元素，栈状压表示是 j 的方案数，显然只有 j >=k 的时候会产生大于 k 的数 
signed main()
{
	int n=R(),k=R();
	F[0][0]=1;
	for(int i=0;i<n;i++)
	{
		int x=R();
		for(int j=0;j<=(1<<k);j++)
		{
			if(x!=4)(F[i+1][min(1<<k,2+j)]+=F[i][j])%=mod;//选择 2 
			if(x!=2)// 选择 4 
			{
				if((j>>1)&1)(F[i+1][4]+=F[i][j])%=mod;
				else (F[i+1][min(1<<k,j+4)]+=F[i][j])%=mod;
			}
		}
	 } 
	 cout<<F[n][1<<k];
	return 0;
}
```
