这题第一眼看过去，毫无思路。

所以我们考虑部分分出正解。

首先我们先推一个柿子

$f_i$表示到达$i$的时间，$g_i$表示离开$i$的时间。

$mx_i$表示从$i$开始的那个最后上车的乘客的时间

$cnt_i$表示到$i$结束的人数

$ans=(\sum_{i=2}^nf_i\times cnt_i)-\sum_{i=1}^mT_i$

$f_i=g_{i-1}+d_{i-1}$

$g_i=\max\{f_i,mx_i\}$

显然这就是k=0做法了

考虑k=1的做法：

- 法1，枚举删边然后重新统计ans取max，复杂度O(n^2)

- 法2，考虑对于每条边统计其贡献，直接统计，O(n)

我们这里着重考虑第二种做法。

发现，如果d[i-1]--，那么意味着f[i]--，也就是说，ans-=a[i]。

也就是说减d[i-1]这条边实际上贡献了a[i]（负）的答案。

没完呢，考虑f[i]--的贡献，发现如果原来的f[i]>mx[i]，那么g[i]--，f[i+1]--，也就是说，f[i]>mx[i]，那么我们的贡献可以【延续下去】

如果f[i]<=mx[i]，那么f[i]的减少和g[i]就没什么关系了。

所以我们要做的是，每次找到一个开始点然后考虑把它d[i]-1之后做的贡献，接下来向下枚举，看是否能延续，如果能延续那么当前的sum（贡献）+=cnt[i+1]，否则以他为新起点。（注意考虑d[i]=0）

如果不看细节的话，这就是O(n)了。

于是我们发现k<=100000，只需要k个O(n)就可以做到O(kn)的复杂度了。

因为这题数据水，所以过了。

那么一个正确的复杂度是什么呢？

其实要改的话很简单，考虑每次减多个d[i]就好了。

我们找到那个贡献最大的d[i]，用$mnn$记录他可以被减多少次，然后直接减。

看似只是个常数优化，然而复杂度变成了O(n^2)。

为啥？

我们把【延续】看成是把区间分成了若干个块，那么一次减完，相当于把这个块再次细分成好几个小块（因为不连续了)

显然，切块的这个过程最多O(n)次，所以总复杂度是O(n^2)的。

当然，使用数据结构优化或者奇怪的堆卡常（用分治切块+堆）是可以做到nlogn（后者是接近nlogn）的时间来完成这个题的。

但是我太菜，就不会了。

最后$CSP2020RP++$