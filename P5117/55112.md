### 题解

```USACO 2018.12月赛 铜组 第二题```

其实这题只要动动脑筋（大佬：动什么脑筋！）就很简单了，其实就是离散化的思想（雾）

因为挤奶的时间范围很小，而又没有重复，所以只要用```used[]```数组表示当前所需要的桶的数量。

对于每个开始时间让```used[s]=b```，即需要用桶，对于每个结束时间则让```used[t]=-b```，即挤完奶桶在这个时间换回去了，桶的需求量减少了$b$（因为有加才有减，所以根本不需要考虑负数的情况）

最后再从最早时间（方便来说就是$1$）枚举到最晚时间（方便来说就是$1000$），寻找```used[]```的最大值即可。

---

### 代码

```cpp
#include<stdio.h>
int n,s,t,b,used[1010],now,res;
int main()
{
    scanf("%d",&n);
    while(n--)
    {
        scanf("%d%d%d",&s,&t,&b);
        used[s]=b; //需要用桶
        used[t]=-b; //可以换桶了
    }
    for(register int i=1;i<=1000;++i)
    {
        now+=used[i]; //累加用的桶的数量
        if(now>res) res=now; //找出最大值
    }
    printf("%d\n",res);
    return 0;
}
```