~~赛时本应该拿 $70$ 跑路的。~~

## 思路

### 总体思路

题目说询问一个区间，其实就是询问左右端点。

把左右端点分开考虑，分别**二分**求，每次询问中间点是否在区间内。

这样确定每个点需要询问 $\lceil \log_2 1500 \rceil =11$ 次，共 $22$ 次，能过 $70$ 分。

核心代码（二分）

```cpp
while(l<=r){ //二分求左端点
	mid=(l+r)>>1;
	if(Query(mid)==-1) l=mid+1; //在区间外，偏左
	else r=mid-1,L=mid; //在区间里，偏右，记录答案
}
while(l<=r){ //二分求右端点
	mid=(l+r)>>1;
	if(Query(mid)!=1) l=mid+1,R=mid; //在区间里，偏左，记录答案
	else r=mid-1; //在区间外，偏右
}
```

### 优化 1

首先一步很显然的优化，在求左右端点时第一次询问的点其实是同一个点（也就是整个数组的中间点），所以这次询问的结果可以**共用**。

于是在求左端点的时候，记录一下第一次询问的答案，这样求右端点的第一次询问就可以直接使用记录下的答案省略掉了。

这样可以优化 $1$ 次，变成 $21$ 次。但是还差 $1$ 次。

### 优化 2

这一步优化应该是这道题最巧妙的地方。

观察数据范围：$n \le 1500$，很容易产生疑惑：$2^{10}=1024,2^{11}=2048$，和 $1500$ 都差的很远，为什么数据范围不设成 $1000$ 或 $2000$ 呢？

有了这样的思考，再想目前的 $21$ 次的解法，$21$ 分为第一次公用的和左右端点各 $\lceil \log_2 750 \rceil =10$ 次，也就是 $21=1+\lceil \log_2 750 \rceil+\lceil \log_2 750 \rceil$，观察这个式子，然后~~突然灵光乍现~~发现可以让两边稍微不平均一点，**两边变成 $500$ 和 $1000$**，这样式子变成 $1+\lceil \log_2 500 \rceil+\lceil \log_2 1000 \rceil$，也就等于 $20$ 了。

具体做法，就是第一次询问的点取在左侧 $\frac{1}{3}$ 的位置，就可以做到 $20$ 次了。

但是有一个比较重要的细节，就是左右端点可能都取在有 $1000$ 个数的区间中（也就是都 $> \frac{n}{3}$），就又变成 $21$ 次了，不过这也问题不大，因为既然第一次二分进入相同区间，第二次询问的点又是同一个点，**又可以共用**结果（相当于前面的优化 $1$），就可以优化掉 $1$ 次，变回 $20$ 次了。

## 代码

~~这道题因为月赛的时候各种小细节改了很多遍，码风可能比较难看，大家凑合着看。~~

```cpp
#include<cstdio>
#include<iostream>
#define PII pair<int,int>
using namespace std;
int Query(int x);
void init(){} //用不上
PII Guess(int n,int c){
	int L,R; //大写的 L,R 记录最终答案
	int l=1,r=n,mid=(l+r)/3,nl,nr; //二分变量，nl,nr 是第二次二分的初始值
	int d=Query(mid); //第一次询问共用答案，取在 1/3 处
	if(d==-1) l=mid+1; //缩短第一次二分的区间
	else r=mid-1,L=mid;
	if(d!=1) nl=mid+1,nr=n,R=mid; //缩短第二次二分的区间
	else nr=mid-1,nl=1;
	if(d==-1){ //特判左右端点都在右 2/3 的情况，上面的过程再来一遍
		mid=(l+r)>>1;
		d=Query(mid);
		if(d!=1) nl=mid+1,nr=n,R=mid;
		else nr=mid-1,nl=l;
		if(d==-1) l=mid+1;
		else r=mid-1,L=mid;
	}
	while(l<=r){ //二分求左端点
		mid=(l+r)>>1;
		if(Query(mid)==-1) l=mid+1;
		else r=mid-1,L=mid;
	}
	l=nl,r=nr; //利用优化得到的范围比较小的初始值
	while(l<=r){ //二分求右端点
		mid=(l+r)>>1;
		if(Query(mid)!=1) l=mid+1,R=mid;
		else r=mid-1;
	}
	return make_pair(L,R); //华丽结束
}
```

看完不要忘了点赞~