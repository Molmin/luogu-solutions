一个十分暴力的做法。

首先我们知道，如果 $[l,r-len]=[l+len,r]$ 相等，那么 $len$ 就是 $[l,r]$ 的循环节。

而 $len$ 又必须是 $r-l+1$ 的因数。

所以：

枚举 $r-l+1$ 的因数，每次验证第一个条件是否相等，即可解决本题。

然后，对于判断两个区间是否相等，可以使用哈希。

对于区间的哈希值，使用前缀和和直接自然溢出啥事没有维护即可。

详细些说：

前缀和数组 $p$ 应当用 `ull` 类型。因为他不仅范围大，而且对于小于 $0$ 也会溢出。即模数为 $2^{64}$。

构造出来，$p_i=a_i\times hash^i+p_{i-1}$，$hash$ 建议取一个较大的数，我用的是 $23333333333$。

这样子方便对比区间。设 $sum(l,r)$ 为区间 $[l,r]$ 的哈希值（$p_r-p_{l-1}$），对于验证条件 $1$，判断 $sum(l,r-len)\times hash^{len}$ 和 $sum(l+len,r)$ 是否相等。因为两个区间的哈希值事实上还差了一个 $hash^{len}$。

时间复杂度证明：

因数个数是 $\sqrt n$ 级别的，所以总时间复杂度应当是 $n+q\sqrt n$ 是过不去的。但是：

* 因数个数 $\sqrt n$ 是一个宽松的上界。事实上 $\le 5\times 10^5$ 的数中因数最多的有 $160$ 个。

* 不一定有要全部验证完。找到一个可行的就退出了。

当然上面的是最坏的时间复杂度，期望时间复杂度是：

$l,r$ 在区间 $[1,n]$ 内随机生成。所以 $r-l+1$ 也是 $n$ 级别的。在 $[1,k]$ 随机取一个数，它的因数个数期望是 $\log k$。所以，期望时间复杂度是 $n+q\log n$。