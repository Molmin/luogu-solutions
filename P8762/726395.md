## 分析+思路+代码

#### 前附阅读本题解所必须掌握的算法[前缀和](https://www.luogu.com.cn/blog/ztntonny/qian-zhui-hu-jian-shu)，大佬请忽略。

观察下面的表格：

| 数列 | 1 | 1 | 2 | 1 | 2 | 3 | 1 | 2 | 3 | 4 | 1 | 2 | 3 | 4 | 5 |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| 序号 | num.1 | num.2 | num.3 | num.4 | num.5 | num.6 | num.7 | num.8 | num.9 | num.10 | num.11 | num.12 | num.13 | num.14 | num.15 |
| 层级 | lev.1 | lev.2 | lev.2 | lev.3 | lev.3 | lev.3 | lev.4 | lev.4 | lev.4 | lev.4 | lev.5 | lev.5 | lev.5 | lev.5 | lev.5 |

其中“层级”是一个关键，我们分析这个数列，是多个等差数列组成的，那么就自然想要模拟，但是看到 $10^{12}$ 的数据规模又望而生怯，所以通过一些技巧来拿下。下面利用一些前缀和的思想来实现，我们把数列形象的划成一个等差数列：

```
{1},{1,2},{1,2,3},{1,2,3,4},{1,2,3,4,5}......
```

从而每一项的数值都代表了该段所对应的子等差数列的项数，那么将其转化为前缀和形式：

```
{1},{1+2},{1+2+3},{1+2+3+4},{1+2+3+4+5}......
```

更直观的：

```
{s[1]},{s[2]},{s[3]},{s[4]},{s[5]}......
```

其中 ```s[i]``` 代表 $1$ 到 $i$ 的数值和，也就是一个前缀和数组 ```s[]```，从而写出前缀和代码：

```
for ( int i = 1; i < 2000005; i++ )
	s[i] = s[i - 1] + i;
```

然后再分析数组本身的前缀和，可以先不考虑具体到每一个数值得，但是要每一个元素对应的，也就是这个数组：

```
{s[1]},{s[2]},{s[3]},{s[4]},{s[5]}......
```

为了求每一个元素对应的前缀和，那么写出预处理代码：

```cpp
for ( int i = 1; i < 2000005; i++ )
	s[i] = s[i - 1] + i , f[i] = f[i - 1] + s[i];
```

```f[i]``` 即为所求，但是这没有精确到数值，设要求的数值 $a$ 在第 $lev$ 层，那么还需要再补一个循环：

```cpp
for ( int i = 1; i <= a - s[lev]; i++ )	sum += i;
```

来弥补在 $a$ 所在阶梯内部的小于 $a$ 的数值和，易发现这个可以简化为：

```cpp
sum += ( a - s[lev] + 1 ) * ( a - s[lev] ) / 2;
```

就是 $\mathcal{O(1)}$ 的时间复杂度了，那么如何求出 $lev$ 呢？用一个stl库的自带二分查找函数来解决，也可以手写：

```cpp
ll lev = max( 0ll , (ll)( lower_bound( s , s + 2000005 , a ) - s - 1 ) );
//不过好像直接暴力搜也可以，没试过还是用最省时间的啦 ：)
```

那么现在写出了求出第 $i$ 个数值的对应前缀和的核心代码：

```cpp
for ( int i = 1; i < 2000005; i++ )
	s[i] = s[i - 1] + i , f[i] = f[i - 1] + s[i];
cin >> t;
while ( t-- )
{
	cin >> a;
	ll lev = max( 0ll , (ll)( lower_bound( s , s + 2000005 , a ) - s - 1 ) );
	ll sum = f[lev];
	sum += ( r - s[lev] + 1 ) * ( r - s[lev] ) / 2 ;
	cout << sum << endl;
}
```

下面应用前缀和的思想，$r$ 到 $l$ 的和就是 ```sum[l]-sum[r - 1]```，列出主程序：

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
ll s[2000005] , f[2000005] , ans , t , r , l; 
int main()
{
	for ( int i = 1; i < 2000005; i++ )
		s[i] = s[i - 1] + i , f[i] = f[i - 1] + s[i];
	cin >> t;
	while ( t-- )
	{
		cin >> r >> l;
		r--;
		ll levr = max( 0ll , (ll)( lower_bound( s , s + 2000005 , r ) - s - 1 ) ) , levl = max( 0ll , (ll)( lower_bound( s , s + 2000005 , l ) - s - 1 ) );
		ll sumr = f[levr] , suml = f[levl];
		sumr += ( r - s[levr] + 1 ) * ( r - s[levr] ) / 2 , suml += ( l - s[levl] + 1 ) * ( l - s[levl] ) / 2;
		cout << suml - sumr << endl;
	}
	return 0;
}
```

于是我们就完美的AC啦~希望这份题解对您有帮助！

```cpp
//对了补一句，大家不要忘了开long long哦————要不然会得到满屏热血沸腾的颜色（doge
```