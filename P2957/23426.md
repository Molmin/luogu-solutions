由于本人比较蒻,所以只能用模拟做这道题... 



------------我只是一条分割线------------

下面说正题.

题目中的第一段全是~~精髓~~废话
题目的意思非常明朗,就是给出两个字符串,让你求出这两个字符串当中的最大连续重叠部分.

好的,读完了题,就可以开始解题了,不难想到,把字符串1和字符串2的字符一个一个扫描,只要发现相等就用while语句往后搜,
求出连续字符串的长度,与max相比较(max刚开始要清0)

但这样做,非常浪费时间,会不会超时呢?

只要看到字符串长度的数据范围,惊奇的发现小于等于~~8000~~
 80,而按照我们的思路,时间复杂度最大为
#  $O(n^3)$
 所以,不会超时,可以放心大胆的做了.
 下面附上代码
 ```pascal
var
  s1,s2:string;//因为字符串长度最大为80，所以不用ansistring
  i,j,d,t1,t2,max,s:longint;
begin
  readln(s1);//读入字符串1
  readln(s2);//读入字符串2
  max:=0;//最大值初始化
  for i:=1 to length(s1) do//线性扫描字符串1
   for j:=1 to length(s2) do if s1[i]=s2[j]  then begin //判断字符是否相同
   s:=1;
   t1:=i+1;
   t2:=j+1;
   while (s1[t1]=s2[t2])and(t1<=length(s1))and(t2<=length(s2)) do begin //开始寻找连续相同字符串
   inc(s);
   inc(t1);
   inc(t2);
   end;
   if s>max then max:=s;//如果大于,则更新max
   end;
   writeln(max);//输出最终值
end.//程序结束


```



