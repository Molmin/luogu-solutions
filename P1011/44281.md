这题原是堂堂noip，而洛谷却给出一堆那么水的数据，我也是醉了

我用的也是递推，但是我总觉得我的递推和dalao们有些不同，于是就写了这篇题解

我们假设第二站上来的人数是x人，一直往下推：

第一站上了a人，车上剩a人

第二站上了x人，下了x人，车上剩a人

第三站上了a+x人，下了x人，车上剩2a人

第四站上了2x+a人，下了a+x人，车上剩2a+x人

第五站上了3x+2a人，下了2x+a人，车上剩3a+x人

以此类推

这是一个表：

车上人数-------车上人数------下车人数

1a+0x-----------0x+1a---------1x+0a

1a+0x-----------0x+1a---------1x+0a

2a+0x-----------1a+1x---------1x+0a

2a+1x-----------2x+1a---------1a+1x

3a+2x-----------3x+2a---------2x+1a

1a+4x-----------5x+3a---------3x+2a

6a+7x-----------8x+5a---------5x+3a

9a+12x---------13x+8a-------- 8x+5a

14a+20x-------21x+13a-------13x+8a

22a+33x-------34x+21a-------21x+13a

35a+54x-------55x+34a-------34x+21a

56a+88x-------89x+65a-------55x+34a

于是我们很容易发现

在某一站中剩的人数是t1[i]\*a+t2[i]\*x（t1[i]，t2[i]为自然数）

而t1[i]从第四站开始就有了规律，及t1[i]=t1[i-1]+t1[i-2]-1;

而t2[i]则是t2[i]=t2[i-1]+t2[i-2]+1;

所以，很明显当总站数或询问站数小于等于3时都需要特判，

而打出上面的表后，很容易就可以找到要输出的内容，这里不明确说明

而实现主要是先算出题目给出的总站数的两个系数t1，t2，然后用(m-t1\*a)/t2这条算式算出x

而如果算出小数，说明不可行，输出"No answer."。

而如果可行，则再循环一次，算出询问站数的系数t1，t2，最后直接用t1\*a+t2\*x就是结果了

注意，如果询问站数是最后一站，直接输出0，因为题目已明确表明在最后一站中人会下光；

还有，为了防止有人照套题解给出算式，我故意让某些变量重叠，请管理员们不要见怪。

由于洛谷的反作弊系统已经完善，我放心地给出代码，不给解释：

```cpp
#include<iostream>
#include<algorithm>
#include<cmath>
using namespace std;
long long a,n,x,t1,t2,s1,s2,tt,ss;
double t,m;
int main()
{
    cin>>a>>n>>m>>x;
    if (n==x) {cout<<0<<endl;return 0;}
    if (x<=2||n<=3) {cout<<a<<endl;return 0;}
    if (x==3) {cout<<a*2<<endl;return 0;}
    t1=1;t2=2;s1=s2=0;
    for (int i=4;i<=n-1;i++)
    {    
        tt=t1;t1=t2;
        t2=tt+t2-1;    
        ss=s1;s1=s2;
        s2=ss+s2+1;    
    }    
    t=(m-t2*a)/s2;
    if (trunc(t)<t) {cout<<"No answer.";return 0;}
    t1=1;t2=2;s1=s2=0;
    for (int i=4;i<=x;i++)
    {    
        tt=t1;t1=t2;
        t2=tt+t2-1;    
        ss=s1;s1=s2;
        s2=ss+s2+1;    
    }    
    cout<<t2*a+s2*t;
    return 0;
}
```