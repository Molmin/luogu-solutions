  1. 引言： 显而易见的，这是一道和斐波那契数列有关的数论题。对于大多数提高组oier的正常状态来说，此题应该是可以轻易的a掉。但天有不测风云，人总有状态不好的时候。在考场上，如果你突然脑袋短路，找不到其中的规律，那么必然会惊慌失措，方寸大乱。从而使你愈发难以想出正解。即使你跳过了此题，不甘与惶恐也将把你攻陷。所以，我们为了预防这种情况，就需要找到一种稳定而好想的解题方法。
  

------------
  1. 转入正题，此题最好想的解法无疑是模拟。题目要问我们车上的人数，我们就模拟这个公交的行进过程。即使用up数组表示上车人数，down数组表示下车人数。而up[j]=up[j-1]+up[j-2]，down[j]=up[j-1]，也是题目上就告诉我们的。
  1. 但我们现在还面对这一个问题，我们并不知道第二站上车人数，所以无法求出第x站车上人数。但我们观察题面，发现他给了我们最后一站车上的人数。顿时，如何求第二站上车人数的方法也能脱口而出————枚举！我们可以枚举第二站上车的人数，在递推到最后一站，看是否满足。
  1. 因此，我们得到了第二站上车人数，第x站也可以顺利成章的推出了。
  

------------
代码如下：
```
#include<bits/stdc++.h>
using namespace std;
int up[100],down[100],a,n,m,x,i,j,ans;
int main()
{
	cin>>a>>n>>m>>x;
	up[1]=a;
	for(i=0;i<=m;i++)//枚举，注意第二站可能上0个人
	{
		up[2]=i;
		ans=a;
		for(j=3;j<=n-1;j++)  //推断是否满足条件
		{
			up[j]=up[j-1]+up[j-2];
			down[j]=up[j-1];
			ans+=up[j]-down[j];
		}
		if(ans==m){
			ans=a;
			for(j=3;j<=x;j++)  //推出答案
			{
				ans+=up[j]-down[j];
			}
			cout<<ans;
			return 0;
		}
	}
}
```

------------
ALL IN ALL：
因为这题的数据并不大，且不算强，我们用这个方法可以ac掉。而考场上肯定不会有这么好的运气。但是它山之石可以攻玉，我们可以在考场上模拟出答案，在通过答案寻找规律，这样比起自己苦想要简单不少。与此同时，在有了这份暴力分的保障，我们的心态也能更加从容。


------------
ALL IN ALL IN ALL:祝各位oier rp++，考出好成绩

------------
本人刚入提高蒟蒻，代码或思路如有问题，欢迎指出。

