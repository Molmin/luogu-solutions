第一眼看以为可以方程解 后来发现似乎似乎似乎不可以解方程......
好了 其实都看得出 这题是可以推公式的 斐波那契数列而已。

话不多说 以下是我的题目步骤 看一下就会懂，就先推六个吧。

注 a=初始上客数 b=第二站上客数。

|站台数N  |1  |2  |3  |4  |5  |6  |...  |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| 上客数 | a |b  | a+b |a+2b  |2a+3b  |3a+5b  |...  |
| 下客数|  0|  b|  b|a+b  |a+2b  |2a+3b  |...  |
|  总数|  a|(b)-(b)+a=a|(a+b)~~-(b)+(b)~~-(b)+a=2a  |(a+2b)~~-(a+b)+(a+b)-(b)+(b)~~-(b)+a=2a+b  | (2a+3b)~~-(a+2b)+(a+2b)-(a+b)+(a+b)-(b)+(b)~~-(b)+a=3a+2b | (3a+5b)~~-(2a+3b)+(2a+3b)-(a+2b)+(a+2b)-(a+b)+(a+b)-(b)+(b)~~-(b)+a=4a+4b |  ...|

好了 这样可见 当N>=2时  总数m=当前上客数-第二站上客数+初始上课数。

在n=1 另做 其他通过公式 求出b的值 再套入其中 便可求出。

辣鸡代码 大佬别喷


```pascal
var
 a1,b1,i,j,n,m,k,t,max:longint;
 a,b:array[1..25] of longint;
begin
  read(a1,n,m,k);
  a[1]:=1;
  a[2]:=0;
  b[1]:=0;
  b[2]:=1;//初始化
  for i:=3 to n do
   begin
   a[i]:=a[i-1]+a[i-2];
   b[i]:=b[i-1]+b[i-2];//建造表格
   end;
  if n=1 then 
         begin
         write(m);//n=1时特别注意
         exit;
         end;
  b1:=(m-(a[n-1]+1)*a1) div (b[n-1]-1);//最后一个下车数为前一个车站的总人数
  write((a[k]+1)*a1+(b[k]-1)*b1);
end.
```