~~据说发题解可以升级，所以我才写的~~

### 咳咳 这道题最主要的思想就是找规律，规律找出来就Code就出来了

我个人的思路其实没必要用到上车人数，但列表需要，也就把他写出来吧 

这里说一下，假设第二站上下车人数为b，其余的数字用题目中已有的变量代替

## 精华来了
|  | 第一站 |第二站  |第三站  |第四站  |第五站  |第六站  |第七站  |
| -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: |
|上  |a  |b  |a+b  |a+2b  |3b+2a  |3a+5b  |无  |
|下  |0  |b  |b  |a+b  |a+2b  |2a+3b  |4a+4b  |
|余  |a  |a  |2a  |2a+b  |3a+2b  |4a+4b  |0  |

不难发现，只要得到“下”这一行的前四项，就可以推出后面几项是前两项的和；
同时，也可以发现“余”这一行前三项得到后，从第四项起的每一项都是上一列的二三两行之和。那么，在一通初始化之后，用递推的思路写就可以了

这里尤其要注意，我们把系数和常数项分开写，最后用终点站人数减去n-1站的常数再除以系数就可以了，这里就是一个解方程的思想

## 上Code！
```cpp
// 抵制抄袭，从我做起 QWQ 
#include<iostream>
using namespace std;
struct station{ //station结构体定义 
	int k; //未知项的系数 
	int x; //常数项 
};
int main() //主函数 
{
	int a,m,n,x,unknown_number;//unknown_number即表格中的b（本人喜欢用这种逼格很高的变量名QWQ ） 
	station yu[22],down[22]; //表格中的第二行（下车人数）和表格中的第三行（余下人数） 
	cin>>a>>n>>m>>x;//输入 
//以下内容其实可以写在定义上，但本人技术菜，并不会QWQ	
	down[1].k=0; down[2].k=down[3].k=down[4].k=1;
	down[1].x=down[2].x=down[3].x=0; down[4].x=a;
	yu[1].k=yu[2].k=yu[3].k=0; yu[1].x=yu[2].x=a; 
	yu[3].x=2*a; //进行表格中的初始化  
	for(int i=5;i<=n-1;i++) //规律从第五列开始 
	{
		down[i].k=down[i-1].k+down[i-2].k;//得到下车人数的系数 
		down[i].x=down[i-1].x+down[i-2].x;//得到下车人数的常数 
	}
	for(int i=4;i<=n-1;i++) //规律从第四列开始 
	{
		yu[i].k=yu[i-1].k+down[i-1].k;//得到余下人数的系数 
		yu[i].x=yu[i-1].x+down[i-1].x;//得到余下人数的常数 
	}
	unknown_number=(m-yu[n-1].x)/yu[n-1].k;//类似于解方程的一个操作 
	cout<<yu[x].k*unknown_number+yu[x].x<<endl;//将unknown_number代入输出第x站开走时的人数，即x站余下的人数 
	return 0;//完美の结束 
 } 
```
求管理员大大给过啊！  ~~顺便把我的蓝名升一下呗QWQ~~