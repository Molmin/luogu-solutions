大家都可以发现这个问题和斐波那契数列有关（当我废话）；【以下多余文字请自动省略】

那么问题是如何简单解决的呢？【抄袭某位da lao的】

我们需要一个简单的模拟，也就是我们已经知道这个斐波那契数列有多少项了，也知道初值是多少，现在只要求出第二站上车的人是多少就可以知道答案了

1   k   1+k   2\*k+1   3\*k+2...这是每次上车的人数，然后我们需要知道的是最后一次的b的系数，然后就可以知道b是多少了，然后题目让我们求的是x站时车上还剩下多少人

下面我用的是s,u两个核心数组（好像很NB de 词汇），先解释一下，不然有点难堪

==============================================================

```cpp
  1  2  3  4  5...//这是站数
u:1  0  1  1  2...//这个是存第一次上站的人数在后面每次上车人数中占的系数比
   0  1  1  2  3...//这个是存第二次上站的人数在后面每次上车人数中占的系数比
==============================================================
```
1  2  3  4  5...
s:1  1...

0  0...

//用来存当前车上还有多少人，因为每次都有下车的（好烦），而且分别是第一次和第二次上车人数占的比例

【这个比例就是系数的意思，因为一开始是a我用1简化一下，需要运算的时候再乘一下就行了】

（下面是我的code，请欣赏，简单暴力，为了防止某些人强迫症，我分割线打得很整齐）

==============================================================

```cpp
program station;
var
      s,u:array[1..20,1..2]of longint;
      i,j,n,m,a,x,k:longint;
begin
      //assign(input,'station.in');reset(input);
      read(a,n,m,x);
      s[1,1]:=1;s[2,1]:=1;//此处需赋初值，至少两个站
      u[1,1]:=1;u[2,2]:=1; 
      for i:=3 to n do
      begin
            u[i,1]:=u[i-1,1]+u[i-2,1];//典型的斐波那契数列
            u[i,2]:=u[i-1,2]+u[i-2,2];
            s[i,1]:=u[i-2,1]+s[i-1,1];//不同于直接求和，大家可以想一下，为什么这么加，有助于帮你理清思路
            s[i,2]:=u[i-2,2]+s[i-1,2];
      end;
      k:=(m-s[n-1,1]*a)div s[n-1,2];//把第一次上车的人系数a给它乘上，然后就可以求上面所说的b了
      write(s[x,1]*a+s[x,2]*k);//由于我有这个数组，可以直接算出结果了（舒服）【>~<】
end.

```