# 一道小学生都会做的数学题。。。
## 看了几篇题解，感觉写得都有点长啊，其实远没那么麻烦。
## 没抓住此题的精髓——
首先我们可以把上下车的人数列一个表格，把第二站上车的人数设为b：
| 车站 | 第一站 | 第二站 | 第三站 | 第四站 | 第五站 | 第六站 | 第七站 | 第八站 |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| 上车 | a | b | a+b | a+2b | 2a+3b | 3a+5b | 5a+8b | …… |
| 下车 | 0 | b | b | a+b | a+2b | 2a+3b | 3a+5b | …… |
1，1，2，3，5，8……
 
发现了什么？
 
### 不就是斐波那契数列吗？

那么我们就可以求出一个站上上车的人数（分别有几个a和b）

由于第一站和第二站a没有连续增加，从第三站才开始连续加，所以一个站上上车的a的系数就是f[第几站-2]。

由于b从第二站就开始连续加了，所以一个站上上车的b的系数就是f[第几站-1];

所以一个站上上车的人数就是f[第几站-2]*a+f[第几站-1]*b;

通过观察表格可知，每一站上还有的人，除这一站上车的人，第一站上车的a人和第二站下车的b人，其余都可以消掉。（自己去看看就知道了）所以在每个站上还有的人数就是：(f[第几站-2]+1)*a+([第几站-1]-1)*b

m实质上就是上一站还有的人，最关键的方程就列出来了：

### m=f[n-1-2]*a+f[n-1-1]*b+a-b

化简得：

### b=(m-(f[n-3]+1)*a)/(f[n-2]-1)

再把算出来的b带到第x站就行啦！代码很简洁：
```cpp
#include<bits/stdc++.h>
using namespace std;
int a,n,m,x,b,f[20];
int main(){
    scanf("%d%d%d%d",&a,&n,&m,&x);
    f[1]=1;
    for(int _=2;_<=n-1;f[_]=f[_-1]+f[_-2],_++);
    b=(m-(f[n-3]+1)*a)/(f[n-2]-1);
    cout<<(f[x-2]+1)*a+(f[x-1]-1)*b<<endl;
    return 0;
}
```