没想到 $O(2^nn^2)$ 可以过 $20$。  
但是我会乱搞。

首先，如果对每个 $i$ 连有向边 $i\to a_i$，那图是一个基环森林。  

定义 $adj(x)=\{x\}\cup\{y\mid (x,y)\in E\}$（邻居和自己），那合法的充要条件是：对于每个（基环森林上的）环，其 $adj(x)$ 的并集是 $\{1,\dots,n\}$。  
充分性显然；至于必要性，如果不满足，那环上的点一定走不到那个不在并集里的点。

有了这个结论，可以发现，森林中如果有 $\ge 2$ 个环，那一定可以只保留其中一个环。所以我们可以默认只有一个环。

有这样一个做法：找一棵生成树，然后枚举每条**原图的边**（可以是树边），看其在生成树上构成的环上的 $adj(x)$ 并集是否是 $\{1,\dots,n\}$。这样做是不对的，因为答案中的环可能包含多条非树边。

但是我们可以随机边的顺序，按照这个顺序构造一个生成树（类似 kruskal，不联通就连）。这样可以构造出很多种生成树，对每种都执行上面的算法，加个卡时，就可以 ac 了。也欢迎各位 hack。

[提交记录](https://codeforc.es/contest/1804/submission/197641789)

彩蛋：一开始写的是
```cpp
std::shuffle(edg + 1, edg + m + 1, std::mt19937 (1206));
```
也就是说，每次随机的都是同一个顺序。。这样会 wa on test 21。
