题目大意：给一张无向图，无自环重边。要给每个点选择一条有向出边，使得最后所有点对间均存在一条路径，满足只有最后一步经过的边可以未被选择。

有向出边，就是说若选择 $(x,y)$ 但没选择 $(y,x)$，那么从 $y$ 走到 $x$ 的边视为未被选择。

先考察一下选中边最后大概构成了一个什么图。由于每个点恰有一个出度，所以不难发现，只保留选中的边，最后形成的应该是一个基环内向树森林。接下来继续考察性质。

以下称被选中的边为树边，其余边为非树边，并且均按有解情况考虑。

- 存在一种构造方案，基环树的环上点的每个子树大小均为 $1$。

如图，黑边为树边，红边为非树边。手绘图可能略丑，见谅。

$1$ 号点是可以很容易到达环上的。但根据构造要求，环上的点也一定要能到达 $1$ 号点。

由于是基环内向树，因此环上的点不可能通过走树边来靠近 $1$ 号点，换而言之 $1$ 号点一定与环上的点有边（图中红边）。

![](https://cdn.luogu.com.cn/upload/image_hosting/9jkb4xsx.png)

进一步的，我们断掉 $1$ 与父亲的连边，连上红边。如此做下去，每个基环树一定是一个环挂着一堆单个节点，显然对于这个子图而言合法。

- 存在一种构造方案，森林中只有一棵树。

若我们需要两个环上的点能相互到达，必然需要满足，只考虑两端点分别在两个环上的点的非树边，则每个点都会被至少覆盖一次。否则总会有一条路径传过去后必须再走树边才可到达。同时，环上的点对另一环的所有子树也必须有边，理由相同。

那么如图，我们随便选取跨越两个环的一条边，将这条边替换进我们的方案里。

![](https://cdn.luogu.com.cn/upload/image_hosting/smr07vby.png)

此时 $(3,4)$ 这条路径看起来会有麻烦，因为 $3$ 不能通过原来的环走到 $4$ 了。但由于左侧环对右侧环所有点均有边，所以 $3$ 依旧可以通过左侧环到达 $4$。换而言之，此时的图依旧合法。然后接着沿用性质一压缩子树即可。

所以可得：有解时，**存在一种构造方案，使得图是一个基环内向树，且所有不在环上的点对应的树边均直接指向环**。

然后这题就看起来可做多了。

环外的点肯定要后处理，先考虑确定环。观察到 $n\le20$，考虑状压。

设 $dp_{S,x}$ 表示走完点集 $S$，最后一步位于 $x$ 时，**可行的起点集合**。转移时，枚举 $x$ 的出点 $y$ 即可。

那么对于一个 $dp_{S,x}$，其能构成一个环，当且仅当 $x$ 存在一个可到达的点，属于可行的起点集合。所以读入的时候顺手预处理每个点能到达哪些点。

但我们还要关注一个问题：环上的点要能够一步到达环外的所有点。相似的，用预处理出来的取并集现判断就行。

确定环的起点和终点后，我们就可以通过正常的动态规划构造方案的流程，记录可行转移点，倒推出环上的所有点的顺序了。

之后，对于环外的点，直接随便连到一个它能到达的环上的点即可。

```
#include<cstdio>
int n,r[21];
int a[21][21],dp[1048576][21];
int to[21];
void dx(int s,int st,int nw){
	if(s==(s&(-s)))return;
	int i,nx=s-(1<<nw);
	for(i=0;i<n;i++){
		if(!(s&(1<<i)))continue;
		if(!a[i][nw])continue;
		if(!(dp[nx][i]&(1<<st)))continue;
		to[i]=nw;
		dx(nx,st,i);
		break;
	}
}
int main(){
	int i,j,k,m;
	scanf("%d%d",&n,&m);
	while(m--){
		int x,y;
		scanf("%d%d",&x,&y);
		x--;y--;
		a[x][y]=a[y][x]=1;
		r[x]|=1<<y;
		r[y]|=1<<x;
	}
	m=1<<n;
	for(i=0;i<n;i++)dp[1<<i][i]=1<<i;
	for(i=1;i<m;i++){
		for(j=0;j<n;j++){
			if(!(i&(1<<j)))continue;
			if(!dp[i][j])continue;
			for(k=0;k<n;k++){
				if(!a[j][k])continue;
				if(i&(1<<k))continue;
				dp[i|(1<<k)][k]|=dp[i][j];
			}
		}
	}
	int rh=0,rs=0,rd=0;
	for(i=1;i<m;i++){
		if((i&(-i))==i)continue;
		int ch=0;
		for(j=0;j<n;j++)if(i&(1<<j))ch|=r[j];
		if((ch|i)!=m-1)continue;
		for(j=0;j<n;j++){
			if(!dp[i][j])continue;
			bool te=0;
			for(k=0;k<n;k++){
				if(!a[j][k])continue;
				if(!(dp[i][j]&(1<<k)))continue;
				rs=k;te=1;
				break;
			}
			if(!te)continue;
			rd=j;rh=i;
			break;
		}
		if(!rh)continue;
		break;
	}
	if(!rh)return printf("No"),0;
	printf("Yes\n");
	dx(rh,rs,rd);to[rd]=rs;
	for(i=0;i<n;i++){
		if(rh&(1<<i))continue;
		for(j=0;j<n;j++){
			if(!(rh&(1<<j)))continue;
			if(!a[i][j])continue;
			to[i]=j;
		}
	}
	for(i=0;i<n;i++)printf("%d ",to[i]+1);
}
```