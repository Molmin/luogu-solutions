### 题意简述：

给出 $n$ 个数，以及一个数 $m$，每一次操作可以使得一个数加一，用最小次数使得这 $n$ 个数模 $m$ 之后恰好每一种余数都是 $\dfrac{n}{m}$ 个。

-----
### 解题思路：

增加数的思路肯定是要把某一些数量比较多的数挪到数量比较少的数上，那么就考虑怎样增加数使得总代价最小。

显然有，将每一个缺少的数与之前的最后一个比他小的多余的数配对可以得到最优解。

----------
然后考虑如何实现，这里有两种方法：

1. Codeforces 的官方题解上介绍了这样一种方法，用一个栈（读作栈，写作 vector）维护当前剩下的可用的数，每当遇到一个比预计值大的数就放进栈中，比预计的小则从栈中取出栈顶，没有则不取。这样一共做两遍，可以在第一遍的时候保证每一个多余的数都放进了栈中，在第二遍的时候所有的数都从栈中取出，显然是正确的。这种方法非常巧妙。

2. 但是我太菜了，想不到上面那一种方法，于是就用了一个俗一点的方法。用三个指针分别指向从前往后第一个有剩下，从前往后第一个缺的，从后往前第一个有剩下的。每一次操作之前更新这三个指针。当缺少的那一个的位置在第一个指针之后的时候，第一个指针所指向的位置就是所要求的的最近的位置；反之，如果缺少的指针指向的位置在从前往后第一个剩下的位置之前，那么从第一个剩下的位置就需要绕一圈才能到达，此时的最优位置一定是从后往前第一个剩下的位置。

这里有一个环形的概念，理解的时候需要注意。

----------
### 代码：

```
#include<cstdio>
#include<vector>
using namespace std;
long long n,a[200005],m,sz[200005],x,l1,l2,l3,ans,top[200005],pri[200005];
vector <long long> num[200005];
int main(){
	scanf("%lld%lld",&n,&m);
	for(int i=1;i<=n;i++){
		scanf("%lld",&a[i]);
		num[a[i]%m].push_back(a[i]);
		sz[a[i]%m]++;
	}
	l3=m-1;
	while(l1<m&&l2<m){
		//l1 >,->  l3>,<-      l2 <
		while(sz[l1]<=n/m&&l1<m)l1++;
		while(sz[l3]<=n/m&&l3>=0)l3--;
		while(sz[l2]>=n/m&&l2<m)l2++;
		if(l1>l3||l2>=m)break;
		if(l2>l1){
			sz[l1]--;sz[l2]++;
			ans+=(l2-l1+m)%m;
			num[l1][top[l1]]=num[l1][top[l1]]+(l2-l1+m)%m;
			top[l1]++;
		}
		else{
			sz[l3]--;sz[l2]++;
			ans+=(l2-l3+m)%m;
			num[l3][top[l3]]=num[l3][top[l3]]+(l2-l3+m)%m;
			top[l3]++;
		}
	}
	printf("%lld\n",ans);
	for(int i=1;i<=n;i++){
		printf("%lld ",num[a[i]%m][pri[a[i]%m]++]);
	}
	return 0;
}
```


