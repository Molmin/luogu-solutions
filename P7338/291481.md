#### 题意
有一个 $2 \times n$ 的方格纸，其中一些格子必须被涂成红色，每次涂两个相邻的格子，一个涂成红色，另一个涂成蓝色。给你希望涂成的样子，问是否可能实现。

#### 思路
对于每个需要被染成红色的格子，有三种可能的染色方法：横着染色且当前格子在右侧，如下方左图；竖着染色；横着染色且当前格子在左侧，如下方右图。

![](https://cdn.luogu.com.cn/upload/image_hosting/n2tv1eto.png)
![](https://cdn.luogu.com.cn/upload/image_hosting/pe2if4kr.png)

我们可以从左到右，按列处理需要被染色成红色的格子。因为是从左往右处理，所以当我们碰到需要被染成红色的格子时，如果这个格子左侧没有被染过颜色，则优先按照第一种方法染色（即蓝色格子在左边），因为给左侧未染色的点染上颜色不会对接下来的处理产生任何影响，所以优先按第一种方法染色；如果这个格子左边被染过颜色了，那么如果它同一列的格子没被染色，就优先把与它同一列的格子染上蓝色，因为在同一列染色最多只会对当前格子右侧的一列造成影响，影响较小，所以这种情况下优先选择第二种方法；如果当前点的左侧、同一列都被染过颜色，那么如果当前点的右侧还没被染过颜色，就把右侧染成蓝色。这种染色方式可能会影响右侧两列的染色，影响最大，所以当前两种情况都不满足时，用第三种方法染色；如果当前点需要被染成红色，但同行的左/右，同列都被染过颜色了，说明不存在合法的染色方法使当前点被染成红色，此时输出```++```，如果到了最后一列都合法，则输出```RP```。

时间复杂度 $O(Tn)$。

#### 代码

```cpp
#include <cstdio>
#include <cstring>
int T;
char p[100010],q[100010];//读入的01串
int u1[100010],u2[100010];//记录第一行，第二行的第i个格子是否被染过颜色 0为没被染过，1为已经/需要被染色
int N;
int main()
{
	scanf("%d",&T);
	while(T--)
	{
		int i,fl;
		fl=0;
		scanf("%d",&N);
		scanf("%s%s",&p,&q);
		for(i=0;i<N;i++)
		{
			u1[i+1]=p[i]-'0';
			u2[i+1]=q[i]-'0';
		} 
		u1[0]=1;u2[0]=1;//注意两侧边界不能染色
		u1[N+1]=1;u2[N+1]=1;
		for(i=1;i<=N;i++)
		{
			if(p[i-1]=='1')//处理第一行
			{
				if(u1[i-1]==0)
					u1[i-1]=1;
				else
					if(u2[i]==0)
						u2[i]=1;
					else
						if(u1[i+1]==0)
							u1[i+1]=1;
						else
						{
							fl=1;
							break;
						}
			}
			if(q[i-1]=='1')//处理第二行
			{
				if(u2[i-1]==0)
					u2[i-1]=1;
				else
					if(u1[i]==0)
						u1[i]=1;
					else
						if(u2[i+1]==0)
							u2[i+1]=1;
						else
						{
							fl=1;
							break;
						}
			}
		}
		if(fl)
			printf("++\n");
		else
			printf("RP\n");
	}
} 
```
注意：本题虽然有多组数据，但使用```memset```容易在sub7TLE。