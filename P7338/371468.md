## 0. 题目描述

小 M 同学有一张 $2$ 行 $n$ 列的方格纸，一开始所有格子都是白色的。

她决定对一些格子染色，具体地，每次她会选择两个**相邻的（四联通的，也就是有公共边的）白色**格子，其中一个染成红色，另一个染成蓝色。

她的目标是通过**任意次操作**让指定的一些格子变成红色，**对其他格子没有要求**。请你帮她判断一下，能否通过上述操作达成目标呢？

## 1. 题目分析&主要代码

考察点：贪心

题目难度：普及/提高-

时间复杂度：$\Theta(n)$

### 题目分析

赛时我先想到的是傻做法，暴力搜索，时间 $\Theta(\operatorname{feb}(n))$（注：这是递推出来的结果），而经（Python）测试，$\operatorname{feb}(1000)\approx7e+200$，这肯定是不行的。

于是我仔细看了下数据范围，1e6，能行的只有 $\Theta(n)$ 的贪心和 $\Theta(n\sim n^{1.5})$（本蒟蒻算不出来）的动规。

先试试贪心，~~没准还能爆标呢（事实证明除了 $\Theta(\log n)$ 以外不可能爆标）~~

贪心，怎么贪呢？我最开始想到了这样的设计：判断每一个 $2\times2$ 区域如果一个**红方块**（指必须涂红的方块）边上有一个方块没有规定颜色，那么这个红方块就是“安全”（指不会导致无方案）的。否则如果红方块在右面，那么这个红方块还有可能恢复“安全”，因为下一个区域还包含这个红方块。如果红方块在左边，就完全废了，直接输出 `++`。

后来（大概十分钟）我又想到了一个完美的方法，把上面的“在左边”“在右边”合并起来，就得到了一个更好的方法：我们遍历 $i$ 从左到右，如果 $i$ 列 $1$（索引从 $1$ 开始）行是红方块，那么按照 `左->上->右` 判断，如果某个方向可以放蓝方块，就放蓝方块。这样优先判断上次遍历剩下的方块，达到了局部最优性。  
如果 $i$ 列 $2$ 行是红方块，这时候还是如此，不过变成了 `左->下->右` 。  
如果某一次判断完成后没有可放的地方，那么说明失败，输出 `++`。遍历全部完成，输出 `RP`。

这样，我们成功在 $\Theta(n)$ 复杂度下完成了这样的判断。

### 主要代码

注意讲解时索引从 $1$ 开始，但代码索引从 $0$ 开始！

首先，使用两个 $(1e6,2)$ 的二维数组 `p` 和 `u`，`p` 是题面的变量名，代表是否必须涂红色；`u` 就是 `used`，代表某格是否已经涂上蓝色。
```cpp
bool p[1000000][2],u[1000000][2];
```

接下来我们使用一个“保护壳”，就是一个判断索引是否合法的函数，例如第 $1$ 列，我们不可能再判断左侧，为了防止读取到错误的值导致 WA。因为这个函数判断的是 `p` 数组，我们取名为 `p_`。
```cpp
inline bool p_(int x,int y){
    if(x<0||x>=n||y<0||y>=2){
        return 0;
    }
    return 1;
}
```

好了，现在才是重头戏，主函数 `do_`（防关键字）。
```cpp
cin>>n;
memset(u,0,sizeof(u));//多测不清空，爆零两行泪
string s;
cin>>s;
for(int i=0;i<n;++i){
    p[i][0]=s[i]-'0';
}
cin>>s;
for(int i=0;i<n;++i){
    p[i][1]=s[i]-'0';
}
```
读入部分不用多说了，不过这里用到了一个小技巧，因为输入的 `01` 串是连起来的，所以不能直接输入一个数，采用先输入成字符串，再逐字符拷贝的方式。**注意这里有个大坑，记得 `-'0'` 哦！**  
大大大坑：**多 测 不 清 空，爆 零 两 行 泪**！

接下来是主循环的循环体：
```cpp
if(p[i][0]){
    bool f=0;
    if(p_(i-1,0)){
        if(p[i-1][0]==0&&u[i-1][0]==0){
            u[i-1][0]=1;
            f=1;
        }
    }
    if(f==0){
        if(p[i][1]==0&&u[i][1]==0){
            u[i][1]=1;
            f=1;
        }
    }
    if(f==0){
        if(p_(i+1,0)){
            if(p[i+1][0]==0&&u[i+1][0]==0){
                u[i+1][0]=1;
                f=1;
            }
        }
    }
    if(f==0){
        cout<<"++"<<endl;
        return;
    }
}
```
`f` 代表是否已经成功涂上蓝色格子。

左侧判断：
```cpp
if(p_(i-1,0)){
    if(p[i-1][0]==0&&u[i-1][0]==0){
        u[i-1][0]=1;
        f=1;
    }
}
```
注意用到的 `p_` 函数。

上/下判断：
```cpp
if(f==0){
    if(p[i][1]==0&&u[i][1]==0){
        u[i][1]=1;
        f=1;
    }
}
```
注意这里又没有用到 `p_` 函数，因为只有两行，两行的代码可以分开写，一段只向下判断，一段只向上判断。

右侧判断：
```cpp
if(f==0){
    if(p_(i+1,0)){
        if(p[i+1][0]==0&&u[i+1][0]==0){
            u[i+1][0]=1;
            f=1;
        }
    }
}
```

再不行就是这组数据不行了，输出 `++`。
```cpp
if(f==0){
    cout<<"++"<<endl;
    return;
}
```
没必要继续执行下去。

这只是第一行的代码，第二行代码同理，可以复制后少量修改，见完整代码。

主函数没必要看，不过还是放出来吧：
```cpp
int main(){
    ios::sync_with_stdio(false);//IO加速
    int t;
    cin>>t;
    while(t--){//多测专用
        do_();
    }
    return 0;
}
```

## 2. 完整代码

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
using namespace std;
bool p[1000000][2],u[1000000][2];
int n;
inline bool p_(int x,int y){
    if(x<0||x>=n||y<0||y>=2){
        return 0;
    }
    return 1;
}
void do_(){
    cin>>n;
    memset(u,0,sizeof(u));
    string s;
    cin>>s;
    for(int i=0;i<n;++i){
        p[i][0]=s[i]-'0';
    }
    cin>>s;
    for(int i=0;i<n;++i){
        p[i][1]=s[i]-'0';
    }
    for(int i=0;i<n;++i){
        if(p[i][0]){
            bool f=0;
            if(p_(i-1,0)){
                if(p[i-1][0]==0&&u[i-1][0]==0){
                    u[i-1][0]=1;
                    f=1;
                }
            }
            if(f==0){
                if(p[i][1]==0&&u[i][1]==0){
                    u[i][1]=1;
                    f=1;
                }
            }
            if(f==0){
                if(p_(i+1,0)){
                    if(p[i+1][0]==0&&u[i+1][0]==0){
                        u[i+1][0]=1;
                        f=1;
                    }
                }
            }
            if(f==0){
                cout<<"++"<<endl;
                return;
            }
        }
        if(p[i][1]){
            bool f=0;
            if(p_(i-1,1)){
                if(p[i-1][1]==0&&u[i-1][1]==0){
                    u[i-1][1]=1;
                    f=1;
                }
            }
            if(f==0){
                if(p[i][0]==0&&u[i][0]==0){
                    u[i][0]=1;
                    f=1;
                }
            }
            if(f==0){
                if(p_(i+1,1)){
                    if(p[i+1][1]==0&&u[i+1][1]==0){
                        u[i+1][1]=1;
                        f=1;
                    }
                }
            }
            if(f==0){
                cout<<"++"<<endl;
                return;
            }
        }
    }
    cout<<"RP"<<endl;
    return;
}
int main(){
    ios::sync_with_stdio(false);
    int t;
    cin>>t;
    while(t--){
        do_();
    }
    return 0;
}
```
## 3. ~~出题人挖坑不埋~~

1. 多测不清空，爆零两行泪；
2. `p_` 函数很重要，虽然没测过，但 RE 就不值得了；
3. 别忘了判断如果 `f==0` 才能继续判断，否则一个红格就会导致最多三个格变蓝，会导致 WA；
4. 输入用 `string`（`char` 亦可），并且记得 `-'0'`。

## 4. Update

写题解写到一半，发现数据加强我 TLE 了，检查题面发现 $T$ 变成了 $65536$，别人居然还能 $17ms$ 过，所以是常数导致我 TLE。分析一下，也就是读入可以优化。我先是在读入的同时改一下 `u` 数组，去掉 `memset`，然后又发现 `string` 可以搞成 `char`，但是我用了 `iostream` 优化，所以只能继续用 `cin cout`。令我惊喜的是，$66ms$ 成功 AC。新的代码重新展示一下：
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
using namespace std;
bool p[1000000][2],u[1000000][2];
int n;
inline bool p_(int x,int y){
    if(x<0||x>=n||y<0||y>=2){
        return 0;
    }
    return 1;
}
void do_(){
    cin>>n;
    char c;
    for(int i=0;i<n;++i){
        cin>>c;
        p[i][0]=c-'0';
        u[i][0]=0;
    }
    for(int i=0;i<n;++i){
        cin>>c;
        p[i][1]=c-'0';
        u[i][1]=0;
    }
    for(int i=0;i<n;++i){
        if(p[i][0]){
            bool f=0;
            if(p_(i-1,0)){
                if(p[i-1][0]==0&&u[i-1][0]==0){
                    u[i-1][0]=1;
                    f=1;
                }
            }
            if(f==0){
                if(p[i][1]==0&&u[i][1]==0){
                    u[i][1]=1;
                    f=1;
                }
            }
            if(f==0){
                if(p_(i+1,0)){
                    if(p[i+1][0]==0&&u[i+1][0]==0){
                        u[i+1][0]=1;
                        f=1;
                    }
                }
            }
            if(f==0){
                cout<<"++"<<endl;
                return;
            }
        }
        if(p[i][1]){
            bool f=0;
            if(p_(i-1,1)){
                if(p[i-1][1]==0&&u[i-1][1]==0){
                    u[i-1][1]=1;
                    f=1;
                }
            }
            if(f==0){
                if(p[i][0]==0&&u[i][0]==0){
                    u[i][0]=1;
                    f=1;
                }
            }
            if(f==0){
                if(p_(i+1,1)){
                    if(p[i+1][1]==0&&u[i+1][1]==0){
                        u[i+1][1]=1;
                        f=1;
                    }
                }
            }
            if(f==0){
                cout<<"++"<<endl;
                return;
            }
        }
    }
    cout<<"RP"<<endl;
    return;
}
int main(){
    ios::sync_with_stdio(false);
    int t;
    cin>>t;
    while(t--){
        do_();
    }
    return 0;
}
```

所以说，有时候静态差错真的、真的、真的很重要！（手机端改完被卡没了，还得重改。。。）