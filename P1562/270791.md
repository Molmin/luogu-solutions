这题是搜索题，但是爆搜肯定炸，所以要剪枝。  
笔者费尽心思剪枝，最后还是70分，那么只好拿出优化大杀器——位运算。  
### 位运算
鉴于并不是所有人都会位运算，笔者这里简单介绍一下。  
1. 按位或(`|`)  
比如`3|5`:  
先把3,5拉成二进制：  
011  
101  
然后对每一位做或运算为：  
111  
转成十进制即为7。  
所以`3|5=7`  
2. 按位与(`&`)  
还是以3,5为例：  
拉成二进制  
011  
101  
对每一位做与运算即：
001  
转成十进制是1  
所以`3&5=1`
3. 按位异或(`^`)
把3,5拉成二进制：  
011  
101  
比较每一位，如果不相同返回1，相同返回0，那么得到：  
110
转成十进制是6
所以`3^5=6`
4. 左移运算符(`<<`)和右移运算符(`>>`)  
就是把二进制的值往左一位和往右一位。  
由于这是“二”进制，所以：`x<<1=x*2;x>>1=x/2`。  
比如`1<<n` $=2^n$。
5. 按位取反(`~`)  
这个运算符是单元运算符。  
其实就是把二进制的每一位取反，这在待会运用位运算优化时尤其有用。  
至于取反后的十进制值，可以用一个公式表示(无论正负)：`~x = -x-1` 。
为什么呢？这就涉及到二进制的表示法了，下面将重点介绍。  

二进制的表示方法有三种：原码，反码和补码。
1. 原码：即数字本身的二进制值。整数直接展开，负数把符号位设为1，其它不变。  
以带符号4位二进制为例：    
$2\to(0010)_2$  
$-2=-(2)\to(1010)_2$  
这样会有一个问题：  
$2+(-2)=(0010)_2+(1010)_2=(1100)_2=-4$，显然不对。  
所以就有了反码。  
2. 反码：  
**正数的原码和反码一样**  
负数的反码则是将原码按位取反，符号位不变。  
比如在四位带符号二进制数中，$-0=(1111)_2,-1=(1110)_2,-2=(1101_2)$  
这样，$-2+2=(0010)_2+(1101)_2=(1111)_2=-0$，貌似没有问题了。  
但此时拿两个不同的负数相加又会出问题了。  
$(-1)+(-2)=(1110)_2+(1101)_2=(1011)_2=-4$  
那么就有了补码。   
3. 补码：  
**计算机里用的都是补码**   
**正数的原码、反码和补码都一样**   
大多数的书上就一句话：**负数的补码等于反码+1**，这也确实精辟的解释了补码。    
或者说，**负数的补码等于他的原码自低位向高位，尾数的第一个‘1’及其右边的‘0’保持不变，左边的各位按位取反，符号位不变。**  
可能不太好懂，其实看两个实例就行了。    
$6+(-2)=(0110)_2+(1110)_2=(0100)_2=4$  
$(-1)+1=(1111)_2+(0001)_2=(0000)_2=0$  
看上去很不错哦。  

回到`~`运算符，如果x为正数，那么取反后其实就是它的相反数的反码，但计算机中用的是补码，在反码的基础上多了1，所以最后再减掉1，即为最终的十进制值。  
如果x为负数，设`~x=k`，则`~k=x`，所以`x=-k-1`，移项得`k=-x-1`，这样解释似乎更容易理解呢。  
### 普通N皇后
普通的搜索代码大致是这样的：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define N 15
int n,ans;
long long s[3][2 * N + 1];
int cb[N];
void queen(int row){
	if(row > n){
		ans ++;
		return;
	}
	for(int i = 1;i < cb[row - 1] - 1;i ++)
	{
		if( s[0][i] || s[1][i + row] || s[2][i - row + n] )continue;
		s[2][i - row + n] = s[1][i + row] = s[0][i] = 1;
		cb[row] = i;
		queen(row + 1);
		s[2][i - row + n] = s[1][i + row] = s[0][i] = 0;
	}
	for(int i = cb[row - 1] + 2;i <= n;i ++){
		if(s[0][i] || s[1][i + row] || s[2][i - row + n]  )continue;
		s[2][i - row + n] = s[1][i + row] = s[0][i] = 1;
		cb[row] = i;
		queen(row + 1);
		s[2][i - row + n] = s[1][i + row] = s[0][i] = 0;
	}
}
int main()
{	
	scanf("%d",&n);
	cb[0] = n + 2;
	queen(1);
	printf("%d\n",ans);
	return 0;
}
```
这份代码的复杂度是铁的$O(n!)$，在 $n\le14$ 的时候还是会超时。  

加了位运算的代码是这样的：
```cpp
#include <bits/stdc++.h>
using namespace std;
int upp;//位运算优化 
int ans;//答案 
inline int read()
{//快读 
	int x=0,f=1;
	char c=getchar();
	while(!isdigit(c)){if(c=='-')f=-1;c=getchar();}
	while(isdigit(c)){x=(x<<1)+(x<<3)+c-'0';c=getchar();}
	return x*f;
}
void queen(int row,int ld,int rd)
{
	/*
		row代表当前行由于列冲突的第几列不能选(1不能0能)
		ld代表当前行由于左对角线冲突不能选(同上)
		rd代表当前行由于右对角线冲突不能选(同上)
	*/
	int pos,p;
	if(row != upp)//如果 row 全是1则达到要求 
	{
		pos = upp & (~(row|ld|rd)); //取出当前第一个可放置列(即第一个0)
		while(pos)
		{
			p=pos&(~pos+1);
			pos -= p;
			queen(row|p,(ld|p)<<1,(rd|p)>>1);
		}
	}
	else ++ans; 
}
int main()
{
	int n=read();
	upp = (1<<n) -1;//初始化(每一位都是1) 
	queen(0,0,0);
	printf("%d\n",ans);
	return 0;
}
```
可能会一脸蒙圈，笔者第一次看到这份代码也是这种感觉。  
那么这里稍微解释一下。

首先这个$upp$，它放的是最终结果(0~n-1位每一位都是1)，它的十进制值就是$2^n-1$，用位运算直接搞定。  
$row,ld,rd$存放的都是二进制的状态，$row$是列冲突，$ld$是左对角线，$rd$是右对角线。0表示这个位置上没有，还可以放；1表示这个位置上已经放过了，不用再放了。  

如果当前的状态($row,ld,rd$任取一个皆可)和$upp$完全相同，说明达到要求，直接$ans+1$然后退出，反之继续下面的操作。  

对$row,ld,rd$进行按位或运算，得到新的二进制值，它表示的是最终能否放置的状态。对这个数进行按位取反给$pos$，现在1表示可以放，0表示不可以。  
接下来取出$pos$最末端的1，这里稍微讲解一下方法。  

假设已找到这个1，在第$x$位上，那么把原数-1后，$x$左边不动，$x$这里变成0，$x$右边全是1。  
然后对这个数按位取反，现在$x$左边1变0,0变1，$x$这里是1，$x$右边全是0。  
用这个数按位与上原数，$x$前面都不一样，自然返回0，$x$本身是1，$x$右边本来就全是0，与一遍还是0。  
现在取到的数的十进制值就是$2^x$。  
所以取的方法就是`pos&(~(pos-1))`

我们用`p=pos&(~(pos-1))`来找到这个值，然后把pos减去p（以免重复），递归queen函数继续查找。  
这里传入的$row$直接在原来基础上按位或$p$即可（其实用异或也可以），$ld$则先按位或$p$，然后左移一位（想想左对角线的形状），$rd$先按位或$p$，然后右移一位。  
只要$pos\neq0$，那么就继续做以上操作。  
普通N皇后就这样解决了。  
位运算写成的代码，效率非常高，但是可读性非常差，没有一点想象力是不行的。  
### 还是N皇后
这题不过是多一个放置限制罢了，先把普通N皇后的模板复制一遍，在上面做些修改即可。  
把输入输出写上：
```cpp
#include <bits/stdc++.h>
using namespace std;
int upp;//位运算优化 
int ans;//答案 
bool c[20][20];
inline int read()
{//快读 
	int x=0,f=1;
	char c=getchar();
	while(!isdigit(c)){if(c=='-')f=-1;c=getchar();}
	while(isdigit(c)){x=(x<<1)+(x<<3)+c-'0';c=getchar();}
	return x*f;
}
void queen(int row,int ld,int rd)
{
	/*
		row代表当前行由于列冲突的第几列不能选(1不能0能)
		ld代表当前行由于左对角线冲突不能选(同上)
		rd代表当前行由于右对角线冲突不能选(同上)
	*/
	int pos,p;
	if(row != upp)//如果 row 全是1则达到要求 
	{
		pos = upp & (~(row|ld|rd)); //取出当前第一个可放置列(即第一个0)
		while(pos)
		{
			p=pos&(~pos+1);
			pos -= p;
			queen(row|p,(ld|p)<<1,(rd|p)>>1);
		}
	}
	else ++ans; 
}
int main()
{
	int n=read();
	char a;
	for(int i = 0;i < n;++ i)
		for(int j = 0;j < n;++ j)
		{
			cin >> a;
			if(a == '.') c[i][j] = 1;
		}
	upp = (1<<n) -1;//初始化(每一位都是1) 
	queen(0,0,0);
	printf("%d\n%d",ans);
	return 0;
}
```
首先queen里面要多传一个参数$cnt$，表示当前是哪一行。  
然后我们在递归前要判断这个位置能不能取，即$c[cnt][\log_2p]$是否是1。  
为了避免多次使用log函数，我们对其进行初始化：
```cpp
int lg[1<<15];//主函数之前加上这个数组
for(int i = 0;i <= n;++ i)
	lg[1<<i] = i;//输入n了以后加上这个循环
```
代码很好懂，这里就不解释了。  
那么再递归前加上这一句即可：
```cpp
if(c[cnt][lg[p]]) continue;
```
全部代码如下：
```cpp
#include <bits/stdc++.h>
using namespace std;
int upp;//位运算优化 
int ans;//答案 
bool c[20][20];
int lg[1<<15];
inline int read()
{//快读 
	int x=0,f=1;
	char c=getchar();
	while(!isdigit(c)){if(c=='-')f=-1;c=getchar();}
	while(isdigit(c)){x=(x<<1)+(x<<3)+c-'0';c=getchar();}
	return x*f;
}
void queen(int cnt,int row,int ld,int rd)
{
	/*
		row代表当前行由于列冲突的第几列不能选(1不能0能)
		ld代表当前行由于左对角线冲突不能选(同上)
		rd代表当前行由于右对角线冲突不能选(同上)
	*/
	int pos,p;
	if(row != upp)//如果 row 全是1则达到要求 
	{
		pos = upp & (~(row|ld|rd)); //取出当前第一个可放置列(即第一个0)
		while(pos)
		{
			p=pos&(~pos+1);
			pos -= p;
			if(c[cnt][lg[p]]) continue;
			queen(cnt+1,row|p,(ld|p)<<1,(rd|p)>>1);
		}
	}
	else ++ans; 
}
int main()
{
	int n=read();
	char a;
	for(int i = 0;i <= n;++ i)
		lg[1<<i] = i;
	for(int i = 0;i < n;++ i)
		for(int j = 0;j < n;++ j)
		{
			cin >> a;
			if(a == '.') c[i][j] = 1;
		}
	upp = (1<<n) -1;//初始化(每一位都是1) 
	queen(0,0,0,0);
	printf("%d\n",ans);
	return 0;
}
```
实测结果：总用时$1.45s$，较大的数据点平均是$300$~$700s$，相比爆搜还是有很大提升的。  

$\mathrm{The\ End.}$