### 题意简述
- 给定一个 $H \times W$ 的棋盘，一个车在位置 $(x_1,y_1)$，每次它可以移动到同行的一个位置或同列的一个位置，不能移动到它原来的位置。求正好移动 $K$ 步到 $(x_2,y_2)$ 的方案数。

- $2 \le H,W \le 10^9$，答案对 $998244353$ 取模。

### 导入
由于这道题转移比较复杂，因此考虑先用动态规划来做。设状态为 $\{i,j,k\}$，表示车移动到 $(i,j)$ 用了 $k$ 步的方案数，因此转移就是：

$$dp_{i,j,k} = \sum_{x=1 \ x \not=j}^{W}dp_{i,x,k-1}+\sum_{y=1 \  y \not=i}^{H}dp_{y,j,k-1}$$

转移表示**同行**与**同列**转移过来但位置不同，初始状态 $dp_{x_1,y_1,0}=1$，最终状态是 $dp_{x_2,y_2,k}$。

[代码](https://www.luogu.com.cn/paste/ub6iltmj)

由于时空复杂度非常高，因此根本不可能过此题，接着就要优化了。

### 分析 / 思路
依然是动态规划，不过需要优化状态与转移。

```
1  | .     #     .     .
   |
2  | *     N     *     *
   |
3  | .     #     .     .
   |
4  |_._____#_____._____.___ 

     4     3     2     1
```

首先考虑状态。上图把棋盘分成了四部分，位于 `#` 和 `*` 的部分只需要一步就可以转移到 `N`，而 `.` 则需要两步。实际上在转移过程中单个符号的值与变化是一样的，因此我们只需要将状态分成四份就行了。分别是 $dp_{i,0 \sim 3}$。因为题目最终答案是在位置 $(x_2,y_2)$，因此我们只需要关注这个位置就行了。

在这里，它们分别表示：

1. 终点

2. 终点同行不同列的点

3. 终点同列不同行的点

4. 终点不同列不同行的点


接着考虑优化转移。对于每个状态来说，我们只需要运用排列组合的思想转移就行了（具体操作看状态转移方程）。

$$(1 \le i \le k)$$
$$dp_{i,0} = dp_{i-1,1}+dp_{i-1,2}$$
$$dp_{i,1} = dp_{i-1,0} \times (W-1) + dp_{i-1,1} \times (W-2) + dp_{i-1,3}$$
$$dp_{i,2} = dp_{i-1,0} \times (H-1) + dp_{i-1,2} \times (H-2) + dp_{i,3}$$
$$dp_{i,3} = dp_{i-1,1} \times (H-1) + dp_{i-1,2} \times (W-1) + dp_{i-1,3} \times (H+W-4)$$

对于每个状态看来说，都要记得取模。初始状态就是 $(x_1,y_1)$ 所在的区域为 $1$，最终状态就是 $a$。

时间复杂度：$\operatorname{O}(K)$。

#### 代码

```cpp
#include <iostream>
#define int long long
#define debug(a) cout << #a << ' ' << a << '\n'
using namespace std;
const int mod = 998244353, MAXN = 1e6 + 5;
int n, m, k, x1, y1, x2, y2, dp[MAXN][4]; 
signed main() {
  ios::sync_with_stdio(0);
  cin >> n >> m >> k >> x1 >> y1 >> x2 >> y2;
  (x1 == x2 && y1 == y2) && (dp[0][0] = 1);
  (x1 == x2 && y1 != y2) && (dp[0][1] = 1);
  (x1 != x2 && y1 == y2) && (dp[0][2] = 1);
  (x1 != x2 && y1 != y2) && (dp[0][3] = 1); //以上为初始状态
  for (int i = 1; i <= k; i++) { 
    dp[i][0] = (dp[i - 1][1] + dp[i - 1][2]) % mod;
    dp[i][1] = (dp[i - 1][0] * (m - 1) % mod + dp[i - 1][1] * (m - 2) % mod + dp[i - 1][3]) % mod;
    dp[i][2] = (dp[i - 1][0] * (n - 1) % mod + dp[i - 1][2] * (n - 2) % mod + dp[i - 1][3]) % mod;
    dp[i][3] = (dp[i - 1][1] * (n - 1) % mod + dp[i - 1][2] * (m - 1) % mod + dp[i - 1][3] * (n - 2 + m - 2) % mod) % mod; //转移
  }
  cout << dp[k][0];
  return 0;
}
```