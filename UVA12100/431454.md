在做这个题之前刚好做了P1996约瑟夫问题。

从题干中的一句：

     “如果队列里有比J更急的任务，
  
      则直接把J放到打印队列尾部，
  
      否则打印任务J（此时不会把它放回打印队列）”
  
这看着就像是循环队列，因为如果有它更急的任务那么就要把他放在队列尾部，但是最终还是会打印到它，那么这个题的本质就相当于是：遍历一个循环队列，依次对优先级最高的进行标记，直到标记到关注的任务就结束，然后输出所关注的任务是第几个被标记的。

代码是基于以上思路写出的，以下为代码以及相应注解：
```cpp
#include<bits/stdc++.h> //万能头文件。
using namespace std;

int t, n, top, dq[105], ok[105];
//t,n,top意义和题干意义相同，dq为循环队列，ok为标记数组
pair<int,int> pa;
//用pair代替结构体，干净简洁！pa.first表示任务优先级，pa.second表示pa.first在dq的相应位置（数组下标）
int main(){
    
    cin>>t;
    while(t--){
        int ct=0;
        cin>>n>>top;
        for(int i=0;i<n;i++) cin>>dq[i]; //读入打印队列
        for(int i=0;i<n;i++) ok[i] = 0;  //对于每一组数据都应该重新初始化
        //以上为每组数据的初始工作。
        
        for(int i=0;ok[top]==0;i++){ //条件为没有打印所关注的任务
            pa.first = 0;
            pa.second = 102;
            for(int j=i;j<i+n;j++){
                if(dq[j%n]>pa.first&&ok[j%n]==0){
                    pa.first = dq[j%n];
                    pa.second = j%n;
                }
            }   //这里去寻找当前优先级最高的且在队列前面的。
            
            ok[pa.second] = 1; //打印
            ct++;   //打印花费1分钟
            i=pa.second;
            //这里注意：若是不这样做的话，那么第二次循环的时候将会从i=1开始，会造成一些错误
            //比如：样例的第三组数据：119111, 打印了优先级为9的任务后，应该打印9后面的1，而不是前面的1，
            //对i进行这样的更新就能解决这个问题，
        } 
        
        cout<<ct<<endl;  //输出该组数据的值
    }//读入t组数据并处理
    return 0;
}
```
