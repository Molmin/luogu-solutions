今天晚上的第二道题解,我的网不快，但是事实证明我的是最优解，啦啦啦~

思路非常简单，首先要把所有的“C”标记为1，所有的“.”标记为0，然后找出每行每列1的个数，找规律发现此行此列有n个1则会有（1+2+……+n-1）对巧克力，为方便提前打表降低时间复杂度，然后输出加和即可。

话不多说，贴代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int Map[101][101]; 
int flag[101]={0,1,3,6,10,15,21,28,36,45,55,66,78,91,105,120,136,153,171,190,210,231,253,276,300,325,351,378,406,435,465,496,528,561,595,630,666,703,741,780,820,861,903,946,990,1035,1081,1128,1176,1225,1275,1326,1378,1431,1485,1540,1596,1653,1711,1770,1830,1891,1953,2016,2080,2145,2211,2278,2346,2415,2485,2556,2628,2701,2775,2850,2926,3003,3081,3160,3240,3321,3403,3486,3570,3655,3741,3828,3916,4005,4095,4186,4278,4371,4465,4560,4656,4753,4851,4950,5050};//打表出奇迹
int main()
{
	int n;
	scanf("%d",&n);
	char ch[101];
	int ans=0;
	int p;
	for(int i=1;i<=n;i++)
	{
		scanf("%s",ch+1);
		p=0;//清零
		for(int j=1;j<=n;j++)
		{
			if(ch[j]=='C')Map[i][j]=1,p++;//输入同时顺便统计每行1的个数 
			else Map[i][j]=0;
		}
		ans+=flag[--p];//记得找寻（n-1）位
	}
	for(int i=1;i<=n;i++)
	{
		p=0;
		for(int j=1;j<=n;j++)
			if(Map[j][i])p++;
		ans+=flag[--p];
	}//统计每列的巧克力对数
	cout<<ans;
	return 0;
}

```