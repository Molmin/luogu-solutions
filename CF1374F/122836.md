神似 [P3516](https://www.luogu.com.cn/problem/P3516) 的一道题。

考虑让数字从小到大归位。

利用选择排序，每次选择当且未归位的数中最小的那个往前跳。

图像模拟一下，我们用红色表示要归位的，蓝色表示最终位置，$X_i$ 表示其他无关紧要的位置。

以如下序列为例：

$$1,2,3,\textcolor{blue}{X_1},X_2,X_3,\textcolor{red}4\ldots$$

我们可以操控红色位置前两个的位置做循环位移，这样红色就往前跳了两格：

$$1,2,3,\textcolor{blue}X_1,\textcolor{red}4,X_2,X_3$$

当然最后跳两格可能会跳过头（像上面），这时候我们连续操控一次蓝色位置，就可以让红色位置后移一格，然后在跳两格，即：

$$1,2,3,X_2,\textcolor{blue}X_1,\textcolor{red}4,X_3$$
$$1,2,3,\textcolor{red}4,X_2,\textcolor{blue}X_1,X_3$$

每次归位一个数都不影响之前的数，因此每次都可以完美的归位一个数从而影响问题规模。

但这样有一个问题，最后两个数的时候动不了了，要交换的位置超过了上限。

比如：

$$1,2,3,5,4$$

此时有结论：遇到这种情况下，若有重复数字，有解，否则无解。

有重复数字的构造：

1. 倒数第三个数字和倒数第一个数字重复。

直接令倒数第三个数字循环位移即可，例：

$$1,2,1\to1,1,2$$

2. 之前有数字重复。

例：
$$1,2,2,3,5,4$$

构造下列做法：

+ 找到最后一对相邻的重复的数字，并先将后面一个循环位移，再将前面一个循环位移，即：

$$1,2,2,3,5,4$$
$$1,2,5,2,3,4$$
$$1,2,2,5,3,4$$

然后重做一遍选择排序的流程，可以证明有解。

关于上面做法的证明：

首先若我们交换相邻两个不同的数，序列逆序对奇偶性改变（加一或减一）。

然后一次循环位移可以被拆成两次相邻交换，因此若序列没有重复数字，经过任意多次操作都不会改变逆序对奇偶性。

发现我们上面唯一无解情况恰巧就是：有一个逆序对，序列无重复数字，这个时候你不可能改变奇偶性变成零个。

而有重复数字时，我们上面的做法本质上是构造了一次值指交换相邻两个数操作，这个操作会改变奇偶性，把原来奇数个变成偶数个，然后我们后面没有归位的数字中又没有重复的，因此一定可以把逆序对置零，因此一定可以排序。

操作次数和时间复杂度均为 $\mathcal{O}(n^2)$，但是完全到不了这个上界。

[码](https://codeforces.com/contest/1374/submission/212345307)