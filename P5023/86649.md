给出一种~~暴力~~递推做法

本质上应该是状压

一共需要14个数列用于递推

首先证明几个结论：

1.交换n和m，答案不变

感性理解就是：可以把一个合法方案翻转，则任意一对路径字典序大小关系反转，产生的01串大小关系也反转

下面是~~严谨~~的证明

对于任意一种方案（合法的或不合法的），构造一个方案，如果$(x,y)=0$，则新方案中$(y,x)=1$，如果$(x,y)=1$，则新方案中$(y,x)=0$

![](https://cdn.luogu.com.cn/upload/pic/57572.png)

直观看就是将原方案对称一下，再把每个点状态反转

原方案与新方案一一对应

这样，对于任何一条路径$(x_1,y_1),(x_2,y_2),...,(x_{n+m-1},y_{n+m-1})$，设其对应字符串为$a_1,a_2,a_3,...a_{n+m-1}$，产生的01串为$b_1,b_2,b_3,...b_{n+m-1}$

则翻转后，令这条路径对应$(y_1,x_1),(y_2,x_2),...,(y_{n+m-1},x_{n+m-1})$，对应字符串变为$\overline{a_1},\overline{a_2},\overline{a_3} ...\overline{a_{n+m-1}}$，产生的01串变为$\overline{b_1},\overline{b_2},\overline{b_3},...\overline{b_{n+m-1}}$

这条路径中，原来向下走的变为向右走，向右走变为向下走，

而01串中，新位置恰好和原位置的字符相反

所以翻转后，这两个串每一位都被反转了

对于一个合法方案：

>如果$w(P_1) > w(P_2)$，那么$s(P_1) ≤ s(P_2)$

先考虑翻转前后的大小关系

在比较时，首先跳过开头相同部分

如果最后没有剩下任何东西，则说明相等

这种情况下，反转后的两个串依然满足每一位相等

否则，找到第一个不相同位

翻转后，前面部分依然相同

而原来这一位是0的串，翻转后这一位变为1

原来这一位是1的串，翻转后这一位变为0

这样，大小关系就反过来了

接下来考虑任意两条满足$w(P_1) > w(P_2)$的路径$P_1,P_2$

翻转后，路径满足$\overline{w(P_2)} > \overline{w(P_1)}$

如果$s(P_1) = s(P_2)$，那么翻转后有$\overline{s(P_1)} = \overline{s(P_2)}$

如果$s(P_1) < s(P_2)$，那么翻转后有$\overline{s(P_2)} < \overline{s(P_1)}$

如果$s(P_1) > s(P_2)$，那么翻转后有$\overline{s(P_2)} > \overline{s(P_1)}$

结论：翻转前一个方案中，合法的一对路径，与翻转后合法的一对路径一一对应

合法方案中任意一对路径，翻转后依然是合法的，因而可以对应一个合法方案

这样，原合法方案与新合法方案也一一对应，也就是：数量相等

2.每条对角线方向上的数，必须满足右上方的比左下方的小或相等

![](https://cdn.luogu.com.cn/upload/pic/57575.png)

这样，如果走红色线，则路径的字典序就会有一个"D"，如果走青色先，则这一位就是"R"，很显然，走红色线字典序小

而01串中，红色线这一位是"0"，青色线对应位是"1"，走红色线字典序小，因而非法

这样可以看出，每条对角线方向上的数，应该类似于"00...0111...1"

3.对于每一对角线方向上相邻且相同的数，会导致这两个数右下方一片矩形区域必须满足每条对角线方向上的数均相同

![](https://cdn.luogu.com.cn/upload/pic/57573.png)

这样可以找到两条路径，直到第二次分叉前，01串字典序依然相等

这时候可以看出，走红色线字典序较小

但是再走一步，就会发现：如果红色点填"0"，蓝色点填"1"，虽然满足第二条结论，但会导致走红色线产生的01串比蓝色线的01串小，这个方案就是非法的

接下来就可以想办法递推了

首先把棋盘形状变一下：

![](https://cdn.luogu.com.cn/upload/pic/57570.png)

这样，对角线就变成了水平线，便于讨论

根据第二条结论，结果就是一行需要满足一定次序

根据第三条结论，观察一下受到限制区域的形状：

![](https://cdn.luogu.com.cn/upload/pic/57576.png)

在新的图中，一行两个相同的数，产生的受限制区域大概就是这样的

![](https://cdn.luogu.com.cn/upload/pic/57577.png)

左边这个图中，被同一条黑线穿过的，必须填相同的数

而观察右边的图，两块受限制区域相邻时，在下一行合并为一个更大的受限制区域

接下来发现每填一层，下一层发生变化的情况一共三类：在末端增加一个点，不变，删除开头的一个点

考虑分三类情况转移

先压缩状态：对于一段受限制区间，到下一行也会产生一段受限制区间，并且这一段区间必须填相同的数

把这一段压缩成一个点，这个点可以仅表示一个受限制的点（注意：到下一行就会导致两个点受限制），也可以表示很多个受限制的点

这里状态表示：填完上一行，这一行的限制的形状为某一个的情况总数

把所有情况的转移大力讨论出来就可以

我讨论的结果：

```
o
oo
ooo
oxo
oxoo
oxxo
ooxo
ox
oxx
oox
n
x
xx
xo
```
x表示一段受限制的区间

o表示一个不受限制的点

另外，n表示没有任何点，也就是当最后一行不受限制时，填完所有格子的情况

而x也可以表示最后一行受限制时（当然并没有什么用），填完所有格子的情况

然后考虑转移

这里就不把所有情况列出来了，递推公式可以直接看代码

一个例子：当增加一个点时，状态ooxo

情况1：开头的两个o填不同的数

可以看出，只有一种情况

这时候，x把末尾的o吞并了，但又冒出一个o

而其它位置填相同的数并不会产生有效的限制区间

因而可以产生状态ooxo，也就是它自身

情况2：开头两个o填相同的数

一共4种情况

这时候，在下一行会产生一个新的限制区间，也就是oxxo

转移时，把对应状态加上上一行某些状态的情况数就可以

剩下的情况请读者自行讨论

这样就可以得出一个14元线性递推数列

最后可以得出三种递推规则

根据n和m确定每个规则的使用次数就可以

时间复杂度$O(n+m)$，空间可以优化到$O(1)$

如果使用矩阵快速幂~~优化~~，则时间复杂度变为$O(\log n+\log m)$，但是会有一个超大的常数（~~常数再大也是常数~~）

讨论的时候务必细心，只要错一点，就会WA

最后是代码
```cpp
#include<iostream>
#include<cstdio>
using namespace std;
const long long M=1000000007;
int n,m;
long long fpow(long long a,int n){
    if(n==0)return 1;
    long long ans=fpow(a,n>>1);
    ans=ans*ans%M;
    if(n&1)ans=ans*a%M;
    return ans;
}
long long seed;
namespace mogician{
	int nc,mc;
	long long a[2],b[2],c[2],d[2],e[2],f[2],g[2],h[2],k[2],l[2],m[2],n[2],p[2],q[2];
	long long* arr[]={a,b,c,d,e,f,g,h,k,l,m,n,p,q,0};
	void mod(){
		for(int k=0;k<14;k++){
			arr[k][1]%=M;
		}
	}
	void sw(){
		for(int k=0;k<14;k++){
			swap(arr[k][0],arr[k][1]);
		}
	}
	void put(){
		for(int k=0;k<14;k++){
			cout<<arr[k][0]<<" ";
		}
		cout<<endl;
	}
	void cal1(){
		a[1]=0;
		b[1]=2*a[0];
		c[1]=b[0];
		d[1]=2*b[0]+4*d[0]+5*f[0];
		e[1]=c[0]+e[0];
		f[1]=2*c[0]+4*e[0]+4*g[0];
		g[1]=c[0]+g[0];
		h[1]=0;
		k[1]=0;
		l[1]=0;
		m[1]=0;
		n[1]=0;
		p[1]=0;
		q[1]=0;
		mod();
		put();
		sw();
	}
	void cal2(){
		a[1]=2*a[0];
		b[1]=3*b[0];
		c[1]=c[0];
		d[1]=3*c[0]+5*e[0];
		e[1]=0;
		f[1]=0;
		g[1]=0;
		h[1]=4*d[0]+5*f[0]+3*h[0]+4*k[0];
		k[1]=4*g[0]+3*l[0];
		l[1]=g[0]+l[0];
		m[1]=0;
		n[1]=0;
		p[1]=0;
		q[1]=0;
		mod();
		put();
		sw();
	}
	void cal3(){
		a[1]=b[0];
		b[1]=0;
		c[1]=0;
		d[1]=0;
		e[1]=0;
		f[1]=0;
		g[1]=0;
		h[1]=c[0]+g[0]+l[0];
		k[1]=0;
		l[1]=0;
		m[1]=2*a[0];
		n[1]=2*b[0]+4*d[0]+5*f[0]+3*h[0]+4*k[0]+2*n[0]+3*p[0]+3*q[0];
		p[1]=2*c[0]+4*e[0]+4*g[0]+3*l[0];
		q[1]=c[0]+e[0];
		mod();
		put();
		sw();
	}
	long long calc(){
		a[0]=1;
		
		for(int i=2;i<=nc;i++)cal1();
		for(int i=nc+1;i<=mc;i++)cal2();
		for(int i=mc+1;i<=nc+mc;i++)cal3();
		put();
		long long ans=0;
		for(int k=0;k<14;k++){
			ans+=arr[k][0];
		}
		ans%=M;
		return ans;
	}
};
int main(){
    ios::sync_with_stdio(false);
    cin>>n>>m;
    if(n>m)swap(n,m);
    mogician::nc=n;
    mogician::mc=m;
    cout<<mogician::calc();
    return 0;
}
```