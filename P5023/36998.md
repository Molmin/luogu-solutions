这题状压dp？感觉不对，因为我（独立地）推出式子了！（时间复杂度只跟快速幂有关，n、m再大也没关系。也算是比较严格地证明了，而不是打表找规律。~~我考场上暴力挂了……~~）~~草稿纸用了三面半，用了好几个小时~~

### 如果有任何问题，或证明中的bug，欢迎在评论里指出（最好可以私信我）

其实这题可以~~疯累~~分类讨论

为了方便，我把题目中格子看成点，格子间的交点看成格子。比如题目中第一个图的右半图可以写成：

```plain
0-1
| |
0-1
```

先来看一些引理（S代表左上角的点，T代表右下角的点。）

### 引理1：一个方格对角线上，右上方格子的数小于等于左下方的数

#### 证明：

```plain
S
⋮
P⋯C-A
  | |
  B-D⋯Q
      ⋮
      T
```

对于这个图来说，w(S->P->CAD->Q->T)>w(S->P->CBD->Q->T)，除了A、B都相等，所以A<=B。为了方便，**下边说的对角线都是从左下到右上的。**

有了这个引理，我们可以用另一种方法来表示一个合法的方案，就是在每一个方格里填入小于或等于，表示右上方格子的数和左下方的数的关系。为了方便，这里用/表示等于，\*表示小于（我也不知道我为什么要这样表示）。

### 引理2：若一个方格填/，则它的右下方的所有格子（除了正右和正下方）都应该填/

#### 证明：

设命题P(x, y)，表示任意一个填/的格子(a, b)，对于0<i<=x, 0<j<=y，有(a+i, b+j)填/。引理2就是P(n, m)

先证明P(1, 1)

```plain
S
⋮
P⋯A-B
  |/|
  C-D-E
    | |
    F-G⋯Q
        ⋮
        T
```

因为w(S->P->ABDFG->Q->T)>w(S->P->ACDEG->Q->T)>w(S->P->ACDFG->Q->T)，B和C相等，所以有E<=F<=E，即E=F。

再证明P(1, n)和P(m, 1)。先证P(1, n)。

```plain
S
⋮
P⋯A-B
  |/|
  C-D-E
    | ⋮
    F G
    ⋮ |
    H-I⋯Q
        ⋮
        T
```

用数学归纳法，假设P(m-1, 1)是正确的。w(S->P->ABDF->HI->Q->T)>w(S->P->ACDE->GI->Q->T)>w(S->P->ACDF->HI->Q->T) ，B=C，又因为P(m-1, 1)是正确，所以s(E->G)=s(F->H)，所以有G<=H<=G，就有H=G。

类似地，可以证明P(m, 1) 。

最后证明P(n, m)。

```plain
S
⋮
P⋯A-B
  |/|
  C-D⋯F⋯G
    ⋮   ⋮
    H   I
    ⋮   |
    J⋯K-L⋯Q
          ⋮
          T
```

还是用数学归纳法。假设P(n-1, m)和P(n, m-1)都是正确的，那么也就是说s(D->F->G->I)和s(D->H->J->K)只有I和K的区别。而因为w(S->P->ABD->H->J->KL->Q->T)>w(S->P->ACD->F->G->IL->Q->T)>w(S->P->ACD->H->J->KL->Q->T)，所以I<=K<=I，即I=K。证明完毕。

可以用反证法再得到一个推论。

### 推论1：若一个方格填\*，则它的左上方的所有格子（除了正左和正上方）都应该填\*

不过，还有一个比较重要的性质没讲。

### 性质1：一个满足题意的01矩阵，当且仅当满足引理1（即能化成用\*和/表示的矩阵），且化成用\*和/表示的矩阵后能满足引理2

#### 证明：

首先，一个满足题意的01矩阵显然满足引理1和引理2（已经证明过了）。而满足引理1和引理2的化成用\*和/表示的矩阵，是不是一定可以对应（不一定要一一对应）所有的满足题意的01矩阵呢？

先看下面这个图：

```plain
S
 ⋱
  A-B
  | |
  C-D
     ⋱
      T
```

对于这两条不同的路径，假设都沿相同的路径到A，然后不管它怎么到T。这时，w(S->ABD->T)>w(S->ACD->T)。因为它们都沿相同的路径到A，所以到A前它们的s相同。根据引理1，B<=C，所以要么B<C，s(S->ABD->T)<s(S->ACD->T)，要么B=C，此时根据引理2，它们D->T的路径的s一定相同，因为以D为右上角的子矩阵中，都有每个格子对角线相等（根据引理2），再加上些思考就可以得出这个子矩阵的对角线上填的数相等，在加上些思考，就可以得到这个结论。所以s(S->ABD->T)=s(S->ACD->T)。综上所述，s(S->ABD->T)<=s(S->ACD->T)。

再看不满足这个图的两个路径，假设w(P1)>w(P2)，则每次把P1根据前面这个规则变换（把RD变为DR），根据不等号的传递性，只要能把P1变为P2就满足条件。而这个变换很好实现，可以从P1和P2的交点出发，把w(P1)的RR...RRD改成RR...RDR然后一直改改到DRR...RR。就可以把交点下移一个。可以一直这么改，直到RDR...R改成DRR...R后，若P2是DR开头，即改后不止多一个交点，这时要注意，要把P1剩下的后边全改成P2的剩下的。（似乎讲的太抽象了……但其实这个还算是显然的。）然后根据不等式的传递性，w(P1)<=w(P2)就证出来了。

**下文中的n和m代表这个方格的行和列，即n和m在下文中代表输入的n和m分别减1的结果。**

注意到我前面没说一一对应，一个这样的填法中，对答案的贡献是2^(没有\*的对角线的个数)，因为一个对角线有了\*，其实就可以确定这条对角线，\*左下方都填1，右上方都填0；而都是/的对角线上可以都填0或都填1，有两种。一共有n+m-1个对角线。**因为原图中左上和右下的方格这里没考虑到，而且显然每个路径都有经过，不管填什么都行，所以最终答案应该再乘4。**有了这样的性质，就可以只看这样填后的图了。

**为了方便，接下来的讲述没有轮廓线，只有/和\*，然后不确定的用.表示**

好了，接下来看一下这个图还有什么有趣的性质。

### 性质2：\*只出现在前两行或前两列

~~出乎意料吧~~

#### 证明：

若出现在了前两行或前两列以外的地方，则这个左上方至少会有2\*2的方格要填。

```
...
...
..*
```

根据推论1，有

```
**.
**.
..*
```

然后发现这个图在

```
.*.
*..
...
```

这条对角线上有两个\*，而\*表示小于，但只有0或1两个数可以填，出现了矛盾。所以\*只出现在前两行或前两列。

有了这个性质，就更方便~~疯累~~分类讨论了。

**下面所说的贡献在同一段里是加起来算的，所有的贡献是乘起来算的（具体要算什么和为什么要这样建议再看一下性质1的最后）。下面所说的是n行m列，同时需要保证n<=m（若n>m则交换n和m）。**同时在说一下，下文中的n和m代表这个方格的行和列，即n和m在下文中代表输入的n和m分别减1的结果。

### A：\*只出现在第一行和第一列

```
........
.///////
.///////
.///////
```

看第一行的第一个，可以是/或\*，/的贡献是2，\*的贡献是1，加起来的贡献是3

看第一行的第2到n个，每一个所代表的对角线上，有两个地方可以填\*，贡献为2\*1；也可以不填，贡献为2。加起来的贡献是4，因为有n-1个，所以是4^(n-1)

再看第一行的第n+1到m个 ，每一个所代表的对角线上，有一个地方可以填\*，贡献是1；也可以不填，贡献为2。加起来的贡献是3，因为有m-n个（前n个已经被讨论过了），所以是3^(m-n)

最后来看最后一列的第2到n个，贡献都是2，因为有n-1个，所以贡献是n-1个

所以这一类对答案的贡献是$3\times4^{n-1}\times3^{n-m}\times2^{n-1}$（可以化简一下）

请尽量理解，因为下面的分析更复杂。~~而且到后面我会比较偷懒~~

### B：第二行第二列是\*，同时第二行和第二列没有其他\*（除了第一行第二列和第二行第一列） (n>=2)

```plain
*./....
.*/////
///////
.//////
.//////
```

可能需要解释一下。因为第二行第二列是\*，根据推论1，第一行第一列也是\*，同时因为一个对角线上最多只有一个\*（不理解的看性质2最后一个图的下面一段），所以第一行第三列和第三行第一列是/。

~~接下来说一下我怎么偷懒……~~我把每一条对角线的贡献都标注在第一行和最后一列的右上角（所以先确保分类A彻底理解了）。

这里需要对n和m的大小进行讨论。

#### 1. m=2

```plain
 14
*.1
.*
```

解释一下这个4，有两种方法填\*，贡献是2\*1；还可以不填，贡献是2。加起来是4。

所以总的贡献是4

#### 2. n=2 m>2

```plain
 141333
*./...2
.*////
```

我们是限定了第二行和第二列没有其他\*（除了第一行第二列和第二行第一列），所以第二行第三列是/

4的解释同上。3的话是有一种方法填\*，贡献是1；还可以不填，贡献是2。加起来是3。

注意到有m-3个3。所以总的贡献是$8\times3^{m-3}$

#### 3. n>2

```plain
 141443333
*./......2
.*///////2
/////////2
.////////2
.////////
```

最左边的4和右边的3的解释见上。中间那些4其实也差不多，有两种方法填\*，有一种方法可以填/。

有m-n个3，n-1个2，n-2个4（前n个当中有2个1，其它都是4）。所以总的贡献是$3^{n-m}\times2^{n-1}\times4^{n-2}$

然后这种情况讨论完了。

### C：除了第两行的前两列，以及第两列的前两行外，还有在其他第二行或第二列的地方有\*(m>2, n>=2)

还可以用一下推论1。其实它一定会出现：

```plain
*****.
.....*
```

然后就不可能出现第二列和第二行（除了第两行的前两列，以及第两列的前两行外）都有\*的情况，因为会这样：

```plain
***.
*..*
*...
.*..
```

第一行第二列和第二行第一列这个对角线上出现了两个\*，就不可以。

我们记第二行**最后一个**\*为第i列，或记第二列最后一个\*为第i行。（i>2）

然后开始讨论n和m的情况。（然后刚开始我的讨论没有充分，这时候其实可以信仰提交然后看哪错了再修改……不过为了思考少一些，我就先讨论n和m-n足够大的情况，然后看每个区间是不是有问题）

#### 1. 3<=i<n

```plain
 111514433
***./....2
//.*/////2
/////////2
.////////2
/////////2
.////////2
.////////
```

因为第一行第二列是\*，所以第二行第一列是/。因为第二行第四列是\*，所以第一行第五列和第五行第一列是/。根据i的定义，第一行第五列的是/。

5的话是因为有三个地方可以填\*，贡献是3\*1；可以不填，贡献是2，总的贡献是5。剩下的解释见上。

有1个5，n-i-1个4（因为第i+1行第一列和第二行第i列是在同一条对角线上的，下面有n-i-1个.，所以有n-i-1个4），m-n个3，n-1个2，总的贡献是$5\times4^{n-i-1}\times2^{n-1}\times3^{n-m}$，这个需要等比数列求和。当n=3时没什么问题，这个和会变成0，但当n=2时就不要计算这个贡献。

还可以顺便讨论\*出现在第二列，那将会是这样：

```plain
 111514433
*//./....2
*////////2
*.///////2
.*///////2
/////////2
.////////2
.////////
```

其实和上边那个图的贡献是一样的，只要把这个贡献乘以2即可。

#### 当m=n时，i=n

```plain
 1115   1115
***.1  *//.1
//.*2  *///2
////2  *.//2
.///   .*//
```

5的解释同上。

有一个5，n-2个2。这两个图的贡献相同。总的贡献是$5\times2^{n-2}\times2$

#### 当m>n时，i=n
```plain
 111513   111513
***./.2  *//./.2
//.*//2  */////2
//////2  *.////2
./////   .*////
```

有一个5，m-n-1个3（前n-1个是1，第n个是5，第n+1个是1，后面m-n-1个全是3），n-1个2。这两个图的贡献相同。总的贡献是$5\times3^{m-n-1}\times2^{n-1}\times2$
#### 当m>n时，n<i<m
```plain
 11114133
****./..2
///.*///2
////////
```
4是因为有两个地方可以填\*，贡献是2\*1，可以不填，贡献是2。加起来是4。

有一个4，m-i-1个3，n-1个2。答案的贡献是$4\times3^{m-i-1}\times2^{n-1}$。需要等比数列求和。（当n+1=m时直接求和的结果会是0，对答案没有影响）
#### 当m>n时，i=m
```plain
 11114
****.1
///.*2
/////
```
有1个4，n-2个2，对答案的贡献是$4\times2^{n-2}$

好了，可以写代码了（别忘了最后的乘4）。~~感觉我自己都不知道我在说什么了，我还是某一天再改一下这题解吧……~~代码（我这等比数列求和写得……别喷我）：
```cpp
#include <bits/stdc++.h>
using namespace std;
const int kcz=1000000007;
const int inv4=250000002;
const int inv3=333333336;
typedef long long ll;
inline ll qpow(ll a,ll k)
{
    k%=kcz-1;
    if(k<0) k+=kcz-1;
    ll res=1;
    while(k)
    {
        if(k&1) res=res*a%kcz;
        if(k>>=1) a=a*a%kcz;
    }
    return res;
}
ll ans,n,m;
// 1+x+...+x^n x!=1
inline ll sum(ll x,ll n) { return (1-qpow(x,n+1))*qpow(1-x,-1)%kcz; }
int main()
{
    scanf("%lld%lld",&n,&m);
    if(n>m) swap(n,m); n--; m--;
    if(!n) ans=qpow(2,m-1);
    else
    {
        ans=qpow(3,m-n+1)*qpow(8,n-1)%kcz;
        if(n>=2)
        {
            if(m==2) (ans+=4)%=kcz;
            else if(n==2) (ans+=8*qpow(3,m-3))%=kcz;
            else (ans+=qpow(2,3*n-5)*qpow(3,m-n))%=kcz;
        }
        if(m>2 && n>=2)
        {
            if(4<=n) (ans+=10*qpow(4,n-1)%kcz*(sum(inv4,n-1)-sum(inv4,2))%kcz*qpow(2,n-1)%kcz*qpow(3,m-n))%=kcz;
            if(n==m) (ans+=5*qpow(2,n-1))%=kcz;
            else
            {
                if(n!=2) (ans+=5*qpow(3,m-n-1)%kcz*qpow(2,n))%=kcz;
                (ans+=qpow(2,n))%=kcz;
                (ans+=qpow(2,n+1)*qpow(3,m-1)%kcz*(sum(inv3,m-1)-sum(inv3,n)))%=kcz;
            }
        }
    }
    printf("%lld\n",(ans*4%kcz+kcz)%kcz);
    return 0;
}
```
### 后话
感谢您看完了我这么长的题解（是我旷野大计算的题解字节数的4/5左右），我只想说，这是一个好题，值得研究，不要局限于打表找规律，要深入研究它背后的数学原理。这也是我认为它作为noip题不好的一点（也可能是因为我暴力打挂了才这么想），数据范围又给这么小，让人养成只想着用一种不通用的方法做对，以为自己懂了，却不深入研究的坏习惯。