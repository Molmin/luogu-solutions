~~居然只有 1 个人写题解？来，我写一篇。~~

这道题差不多是按照一个规则执行 n 次，创建一个分形图形。

首先，n=1 时，这个图形自然是

```
 /\
/__\
```

而当 n=2 时，它是

```
   /\   
  /__\  
 /\  /\ 
/__\/__\
```

而当 n=3 是，它是
```
       /\       
      /__\      
     /\  /\     
    /__\/__\    
   /\      /\   
  /__\    /__\  
 /\  /\  /\  /\ 
/__\/__\/__\/__\
```

有没有发现什么？

我们发现，一个 n 阶分形，可以表示为 3 个在不同首位置的 n-1 阶分形。

所以不难想到（如果这个词伤害了你，我表示非常抱歉），可以将【阶数】，【起点 x 坐标】，【起点 y 坐标】作为参数做一个函数，使用【递归】的方式解决问题。

**【提示 1】如果你是因为看不懂题而不会做，那么解释之后，请自己认真做一遍。自己做，虽然比较累，但是收益的是自己。**

**【提示 2】本题要多次输入，每次输入之后给出输出，如果输入是 0，就结束运行。**

```cpp
#include<bits/stdc++.h>
int n;
char a[3000+5][3000+5];
const char CX='/',CY='\\',CZ='_'; //C++ 中，\ 是转义的意思，例如 '\n'。如果要表示正确的 '\'，需要使用 '\\'
void set(int lv,int sx,int sy) //参数前面说过，阶数，起点坐标
{
    if(lv==1) //别忘了递归的边界条件
    {
        a[sx][sy+1]=CX;
        a[sx][sy+2]=CY;
        a[sx+1][sy]=CX;
        a[sx+1][sy+1]=CZ;
        a[sx+1][sy+2]=CZ;
        a[sx+1][sy+3]=CY;
        //其实这个巨大的分形图形，就是由一个个小的三角形组成的。团结力量大嘛~~~
    }
    else //没有到达边界条件时递归
    {
        int k=(1<<(lv-1));
        set(lv-1,sx,sy+k);
        set(lv-1,sx+k,sy);
        set(lv-1,sx+k,sy+2*k);
    }
    return;
}
int main()
{
    while(std::cin>>n && n) //只要在输入数据，而且不是 0，就循环
    {
        memset(a,' ',sizeof(a)); //设置初始值为空格，这样就不用人为控制数量了
        set(n,1,1); //设置 a 数组
        for(int i=1;i<=(1<<n);i++) //输出
        {
            for(int j=1;j<=(2<<n);j++)
                printf("%c",a[i][j]);
            printf("\n");
        }
        printf("\n"); //别忘了换行
    }
    return 0; //养成良好的习惯，给一个返回值
}
```