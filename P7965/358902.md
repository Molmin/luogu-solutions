#### 前言

题目[Link](https://www.luogu.com.cn/problem/P7965)

首先呢，看到这道题目，先审题，这道题目想让我们干的事情是`判断一个有向图的两点之间是否存在一条边`，这道题我们考虑先构建图，使用**最短路**算法

#### 解法

~~如果BFS能过的话，那floyd就都能过了呗？~~

我们来考虑一下用那种最短路算法（这里重点是`Floyd`）：

- `Dijkstra`算法；

但是显然，要用的话，一定要注意“松弛”操作中的数组设定，不然的话，会直接爆掉；

- `Floyd`算法；

~~显然我不会说只用3个`for`循环就能搞定~~

但其实真是那样的，`Floyd`最大的有点就是代码很短，只用三个`for`就能搞定，然而这三层`for`本来长这个样子：
```cpp
for (int k = 1; k <= n; k++) {
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= n; j++) {
			dis[i][j] = min(dis[i][k] + dis[k][j], dis[i][j]);
		}
	}
}

```
但是这道题并没有让我们来求最短路，于是，可以适当修改一下，但是仍旧是这个思路：
```cpp
for (int k = 1; k <= n; k++) {
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= n; j++) {
			if (dis[i][k] != 0 && dis[k][i] != 0) {
				dis[i][j] = 1;
			}
		}
	}
}
```
但是我们发现如果光这样写是肯定过不去的，会直接被卡掉；

于是我们考虑加进去快读的板子吸氧，同时开 o2：
```cpp
int init(){
    char c = getchar();
    int x = 0, f = 1;
    for (; c < '0' || c > '9'; c = getchar())
        if (c == '-') f = -1;
    for (; c >= '0' && c <= '9'; c = getchar())
        x = (x << 1) + (x << 3) + (c ^ 48);
    return x * f;
}
```
这样才能通过；

主要使用`Folyd`是因为3层循环里面的数较小，不然的话时间复杂度 $O(N^3)$ 是会被直接卡掉的；

- `SPFA`算法；

众所周知，关于`SPFA`他死了；

其实这道题里面`SPFA`确实是会死的；

由于某些数据太大了，直接让`SPFA`当场死亡；

但是还是可以优化的；（这里我就不详细讲了，因为其他大佬已经都讲过了）

这道题目就到介里，再见喽；