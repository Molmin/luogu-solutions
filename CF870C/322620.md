贪心。

我们发现，最小合数是 $4$，所以考虑拆成多个 $4$ 相加的结果。

但是这样可能会有余数，例如，$22 \bmod 4 = 2$。

这样我们可以分类讨论：

- 余数为 $1$：考虑拼到 $4$ 上，由于 $4 + 1 = 5$，$5$ 是质数，而我们再拼一次，那么就拼出了 $9$，而 $9$ 是合数，损失 $1$ 个合数。
- 余数为 $2$：由于 $4 + 2 = 6$，所以直接拼到 $6$ 上，不会损失。
- 余数为 $3$：由于 $4 \times 3 + 3 = 15$，需要损失 $2$ 个合数，不划算。考虑将 $3$ 拆成 $1$ 和 $2$，这样就转换为上面做法了。损失 $1$ 个合数。

接下来是无解情况：

- $0, 1, 2, 3$：由于最小合数为 $4$，显然不可能。
- $5$：$5$ 以下的合数只有 $4$，其中一个为合数的拆分只有 $4 + 1 = 5$，$1$ 不是合数，故不可能。
- $7$：$7$ 可以拆分成 $4 + 3$ 和 $6 + 1$。$3$ 和 $1$ 都不是合数，故不可能。
- $11$：$11$ 可以拆分成：$4 + 4 + 3, 6 + 4 + 1, 6 + 5, 9 + 2$。$3, 1, 5, 2$ 不是合数，故不可能。

代码：
```c
#include <bits/stdc++.h>
using namespace std;
int main() {
    int T;
    scanf ("%d", &T);
    while (T--) {
        int x;
        scanf ("%d", &x);
        if (x == 0 || x == 1 || x == 2 || x == 3 || x == 5 || x == 7 || x == 11) puts("-1");
        else if ((x % 4) % 2 == 1) printf ("%d\n", x / 4 - 1);
        else printf ("%d\n", x / 4);
    }
}
```