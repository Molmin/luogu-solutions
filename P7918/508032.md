# 前言
在想到了解法之后，我回来看了看题目中的这句话：

注意：输入数据不保证 $\gcd(a,b)=1$。

然后有了一句劝世良言：

**忽略它！**
# Solution
## 题意理解
我们可以把题目理解为：每选出一条直线，就会将这条直线上的所有交点都去掉，直到将交点数变为 $0$，求出最小要选多少条直线。

但是我们发现，把一条直线上的所有交点都去掉，其实也就相当于去掉了这条直线。

因为题目中说了没有三线共点和两线重合，那么我们就又可以把题目转化为：

在有 $n$ 条直线的平面直角坐标系中，选出最少的直线，使得剩下的直线没有产生交点。

没有产生交点？**那不就是平行线吗！**

于是原来的问题就有了答案：**保留包含最多直线的一组（可能不止两条）平行线，这样就可以在去掉最少直线的情况下，使剩下的部分没有交点。**
## 代码实现
前置知识：**如果两条直线平行，它们的斜率相等。**

于是我们用一个浮点数组来记录每组平行线的斜率，再用另一个整型数组来计算每组平行线的直线数量。

特殊处理： $y$ 可能等于 $0$。此时将斜率记录为 $1000000001$。

在处理完了所有直线之后，查找出所含直线最多的那组平行线就行了。
# AC代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,i,a,b,c,ll[100003],j,g,k,ans=0;double l,p[100003];
int main()
{
	cin>>n;
	for(i=1;i<=n;i++)
	{
		scanf("%d%d%d",&a,&b,&c);
		if(b) l=-double(a)/double(b);
		else l=1000000001;
		k++;p[k]=l;ll[k]=1;
		for(j=1;j<k;j++)
		{
			if(p[j]==l)
			{
				k--;
				ll[j]++;
				break;
			}
		}
	}
	for(j=1;j<=k;j++)
	{
		if(ll[j]>ans) ans=ll[j];
	}
	cout<<n-ans;
	return 0;
} 
```
