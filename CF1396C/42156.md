显然是一个 dp。

在每一层有三种抉择：

- 用第一种枪 $a_i$ 次，再用 AWP；
- 用第一种枪 $a_i+1$ 次，逃走，等会再来；
- 用第二种枪，逃走，等会再来。

**本题的难点在于设一个好的状态。** 设 $f_{i,0}$ 为打了前 $i$ 层，第 $i$ 层的 boss 打完了，现在在 $i$ 的最优解；$f_{i,1}$ 为打了前 $i$ 层，第 $i$ 层的 boss 还有一滴血，**现在在 $i$，需要逃走等会回来**的最优解。直接转移即可，转移不是重点，略去。

最后的答案两种情况：可以是 $f_{n,0}$，亦可以是从没打完的 $n-1$ 层到 $n$，打完 $n$ 再回到 $n-1$ 清除 boss。相信这一点也不难想到。

这里重复一遍：本题的关键在于状态的定义，特别是 $f_{i,1}$，若没有明确定义就会出现“到底能不能直接攻击 boss？”之类的问题，需要推敲一下才能得到以上的定义。

```cpp
#include<iostream>
using namespace std;
typedef long long ll;
ll f[1000005][2],c1,c2,c3,d,a[1000005];
int n;
int main(){
	ios::sync_with_stdio(0),cin>>n>>c1>>c2>>c3>>d;
	for(int i=1;i<=n;i++)cin>>a[i];
	f[1][0]=c1*a[1]+c3,f[1][1]=min(c2,c1*(a[1]+1));
	for(int i=1;i<n;i++){
		f[i+1][1]=f[i][0]+min(c2,c1*(a[i+1]+1))+d;
		f[i+1][1]=min(f[i+1][1],f[i][1]+d+min(c2,c1*(a[i+1]+1))+c1+2*d);
		f[i+1][0]=f[i][0]+c1*a[i+1]+c3+d;
		f[i+1][0]=min(f[i+1][0],f[i][1]+d+c1*a[i+1]+c3+d+c1+d);
		f[i+1][0]=min(f[i+1][0],f[i][1]+d+min(c2,c1*(a[i+1]+1))+2*d+2*c1);
	}
	cout<<min(f[n][0],f[n-1][1]+d+c1*a[n]+c3+d+c1);
    return 0;
}
```