### 题目描述

给定宽度为 $2$，高度为 $1$ 的若干枚多米诺骨牌，每枚多米诺骨牌牌面上有两个数字。将两枚多米诺骨牌**固定**放置在一行的两端，在中间留下 $n$ 块宽度为 $2$ 的空白，再给定 $m$ 枚多米诺骨牌，请问是否可从 $m$ 枚多米诺骨牌中选出某些骨牌填满这 $n$ 块空白，并且能使相邻骨牌连接处的数字相同。

### 样例解释

给定初始骨牌 $(0,1)$ 和 $(3,4)$，中间留有 $3$ 块宽度为 $2$ 的空白，$4$ 枚候选骨牌为 $(2,1)$，$(5,2)$，$(2,2)$，$(3,2)$，则可以按如下方式进行填充：`(0,1) (1,2)(2,2)(2,3) (3,4)`

### 首先讲一下搜索是什么。

搜索有很多种，我今天讲的是 **深度优先搜索**。

深度优先搜索就是埋头一直走，走到头了再返回。给一个例子：在 $1$~$5$ 内取 $3$ 个数，求出他所有组合方案。

此题就是一个很好的例子：

首先，我们取 `1,2,3`。发现 $3$ 个到了，就把 `3` 换掉，变成 `4` ，之后再把 `4` 换掉，变成 `5`。

于是生成了以下 $10 $ 种**组合**，不是排列：

```
1,2,3
1,2,4
1,2,5
1,3,4
1,3,5
1,4,5
2,3,4
2,3,5
2,4,5
3,4,5
```

### 回到这一题

很显然，我们就是要在 $m$ 个多米诺骨牌中取 $n$ 块进行排列，使得满足条件。

但是，我们发现这样的效率很低，因为 $n \le m \le 14$，如果先生成所有的排列，那么时间复杂度就是 $O(14!)$ ，一定超时。

所以，我们要

- 确定回溯的初始状态和终止状态。由于是要求 相邻骨牌连接处的数字相同，那么就从此入手，设连接处的数字为状态，初始状态即为给定的位于最左侧的固定骨牌的右侧数字，终止状态即为给定的位于右侧固定骨牌的左侧数字。例如，在第一组样例输入中，初始状态为 $1$，终止状态为 $3$。 
- 根据当前状态和候选骨牌进行回溯。在第一组样例输入中，由于初始状态为 $1$，那么需要确定候选骨牌中是否有一侧数字为 $1$ 的骨牌可用，如果有这样的骨牌未使用，则将其标志为已使用状态，因为候选骨牌只能被使用一次，后续将不能再次使用。找到符合要求的骨牌后，回溯进入下一层，对应的状态将改变为已使用骨牌的对侧数字，已填充的空白块数加 1。需要注意的是，在本题中候选骨牌是可以翻转使用的，如骨牌 $(2,3)$ 可作为 $(3,2)$ 使用，但数字相同的骨牌翻转使用效果相同，为了不增加回溯的深度，可以预先判断并予以剔除。

- 确定是否达到终止状态。当回溯的深度达到预期时，需要对解进行检查，查看其是否符合题意要求。在本题中，当填满的空格块数达到 $n$ 时，需要检查当前状态，即骨牌末尾处的数字是否和终止状态的数字相同。如果相同，表明找到了符合要求的骨牌排列方案，否则此搜索分支应该停止。为了减少不必要的搜索，在找到符合要求的方案后，可以设置完成标识以便尽早退出回溯过程。

##### 特别鸣谢 @寂静山林 提供帮助。
***
接下来就放上代码

```cpp
#include <cstdio>
#include <cstring>
using namespace std;

const int N = 17;

int n, m, fi, se;
int dominoes[N][2];
int vis[N], flag;

inline void mem()
{
    flag = 0;
    memset(vis, 0, sizeof(vis));
}

inline void swap(int &x, int &y)
{
    int t = x;
    x = y;
    y = t;
}

inline void dfs(int x, int now)
{
    if(flag) return ; // 找到了就不必再找了
    if(x == n+1)
    {
        if(now == se) flag = 1;
        return ;
    } // 如果到头了，那么返回
    for(int i=1; i<=m; i++)
    {
        int f = dominoes[i][0]; 
        int s = dominoes[i][1];
        if(vis[i]) continue; // 如果用过就不能用了
        if(f == now) // 如果可以放那么就接下去
        {
            vis[i] = 1; // 打标记
            dfs(x+1, s);
            vis[i] = 0;
        }
        if(f == s) continue; // 如果两个一样就没有交换的必要了
        swap(f, s); // 交换，因为多米诺骨牌可以翻转。
        if(f == now)
        {
            vis[i] = 1;
            dfs(x+1, s);
            vis[i] = 0;
        }
    }
}

int main()
{
    while(scanf("%d", &n) && n>0)
    {
        mem();

        scanf("%d", &m);
        int x, y;
        scanf("%d%d", &x, &y);
        fi = y; // 记录开始
        scanf("%d%d", &x, &y);
        se = x; // 记录结束
        for(int i=1; i<=m; i++)
            scanf("%d%d", &dominoes[i][0], &dominoes[i][1]);
        dfs(1, fi);
        if(flag) puts("YES");
        else puts("NO");
    }
}
```

