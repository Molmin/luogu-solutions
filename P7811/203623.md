我们认为 $n,m$ 同级，下面一律写为 $n$；令 $v=\max\{a_i\}$。

sol：$O(n(\sqrt v+\sqrt n))$ 时间，$O(v+n)$ 空间。

code：$O(n(\sqrt v+\sqrt n))$ 时间，$O(v\log v+n)$ 空间（为了卡常数，有人用线性空间过题了请通知我，谢谢！）。

根号分治。

我们令分治界为 $\Theta(\sqrt v)$。

当 $k\le \sqrt v$ 时，将所有 $k$ 相同的询问同时处理。此时使用 $O(n)-O(\sqrt v)$（注意 $O(\sqrt v)$ 是个上界） 的 RMQ 数据结构即可。因为询问是 $O(n)$ 级别，序列长度总和为 $O(n\sqrt v)$ 级别的。

当 $k> \sqrt v$ 时，枚举 $p=ck$，$p\le v$，$c$ 为自然数。求所有的 $\min\{a_x-p|l\le x\le r\land a_x\ge p\}$ 的 $\min$ 即 $\min\{a_x|l\le x\le r\land a_x\ge p\}-p$，即 $p$ 的区间不严格后继（再减去 $p$）。这个问题可以这样转化是因为本质上 $a\bmod b=a-cb,cb\le a<(c+1)b$，然后虽然这样做每个数进行了大量非取模操作，但是唯一的一次取模操作一定小于其他的非取模操作。

关于区间不严格后继问题，可以通过序列和询问同步排序扫描的方式转化为单点修改区间 $\min$ 的问题。具体的，询问按 $p$ 排序，序列也需排序。枚举询问。维护一个单调递减的在序列上的指针，对于每个 $p$，通过指针单调移动将序列中的大于等于 $p$ 的数加入数据结构中。那么此时数据结构中维护的数就是所有大于等于 $p$ 的数，区间 $\min$ 即为 $p$ 的区间后继。

注意到修改 $\Theta(n)$ 次而查询 $O(n\sqrt v)$ 次，所以允许修改时间复杂度升高。可以通过分块降低猫树（二区间合并）更新复杂度的方式做到。即维护每块的前缀后缀 $\min$，和整块的 $\min$ 组成的长度为 $\Theta(\sqrt n)$ 的序列的猫树。

查询的时候，若 $l,r$ 在同一个块中，则直接暴力（这实质上是第二个根号分治，不是“区间不严格后继”暴力，而是直接按题暴力，即不进入 $k>\sqrt v$ 的根号分治），复杂度为 $O(\sqrt n)$；否则由左块的后缀，右块的前缀和猫树维护的中间块组成。更新前缀后缀复杂度为 $O(\sqrt n)$，更新猫树的复杂度仍为 $\Theta(\sqrt n)$。所以此时做到了 $O(n(\sqrt v+\sqrt n))$ 的复杂度。

另外枚举 $p$ 时不能把每个询问都存下来，否则空间复杂度会退化。

卡常数大家就各显神通吧（流汗黄豆

代码不放了，需要者私信。

![](https://cdn.luogu.com.cn/upload/image_hosting/73iq08qk.png)