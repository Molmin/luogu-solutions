#### Update：修改了笔误

我的代码非常短。

最开始没看出什么规律，于是我花了 30 分钟写出了 前 42 个数。

前 15 个没啥规律，唯一引人注目的就是它覆盖了 1 至 15 的所有数：

$$1,2,3,4,8,12,5,10,15,6,11,13,7,9,14,\cdots$$

继续写（鬼知道我怎么那么有耐心）：

$$16,32,48,17,34,51,18,35,49,19,33,50$$

$$20,40,60,21,42,63,22,43,61,23,41,62$$

$$24,44,52,\cdots$$

你应该可以容易地发现：$3$ 个 $3$ 个分组，第一个数总是从 $2^{2k}$ 开始顺序排列，到 $2^{2k+1}-1$，这些三元组刚好覆盖完 $2^{2k}\sim2^{2k+2}-1$ 的所有数。

可是后面两个数没啥规律，，，考虑写出二进制表示。显然第一个数异或第二个数等于第三个数，只需求第二个即可。

第二个数显然是大于等于 $2^{2k+1}$ 的，考虑写出其相对于 $2^{2k+1}$ 的增量。

写出来是这样的：

$$00000$$

$$00010$$

$$00011$$

$$00001$$

$$01000$$

$$01010$$

$$01011$$

$$01001$$

$$01100$$

看出来了吗？从最后两位开始，每两位都从 $00\to 10\to 11\to 01$ 递变！于是写出代码就很容易了。

代码如下。一些 $+1-1$ 的细节需要自己斟酌一下。

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
using namespace std;
typedef long long ll;
ll n,f[]={0,1,2,3,4,8,12,5,10,15,6,11,13,7,9,14},ff[]={0,2,3,1};
int main() {
	int T;
	scanf("%d",&T);
	while(T--){
		scanf("%lld",&n);
		ll tmp=n;
		if(n<=15){
			printf("%lld\n",f[n]);
			continue;
		}
		ll now=0;
		while(tmp)tmp/=4,now++;
		tmp=(n+2)/3;
		ll from=(1ll<<(2*(now-1)))+(n-(1ll<<(2*(now-1))))/3;
		if(n%3==1)printf("%lld\n",from);
		else {
			ll sx=(n-(1ll<<(2*(now-1))))/3;
			ll tmp=(1ll<<(2*now-1));
			ll ii=1;
			while(sx)tmp+=ii*ff[sx%4],sx/=4,ii*=4;
			if(n%3==2)printf("%lld\n",tmp);
			else printf("%lld\n",from^tmp);
		}
	}
}
```