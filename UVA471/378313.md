#### 翻译：
#### 题目描述
编写一个程序，查找并显示所有整数对 $s_1$ 和 $s_2$ ，以便：

1. $s_1$ 和 $s_2$ 都没有重复的数字；和

2. $s_1/s_2=N$ ，其中 $N$ 为给定整数；

#### 输入

输入文件的开头是一个整数，表示测试用例的数量，后面是一个空格

线每个测试用例由一行包含 $N$ 的输入组成。

两个输入用一个空行分隔。

#### 输出

对于每个输入，输出由零行或多行组成，每行包含 $s_1/s_2=N$，

其中 $s_1$ 、 $s_2$ 和 $N$ 是上述整数。当有两个或多个解决方案时，对它们进行排序

通过增加分子值。

两个连续的输出集将由一个空行分隔。

#### 样本输入

1.

1234567890

#### 样本输出

$1234567890 / 1 = 1234567890$

$2469135780 / 2 = 1234567890$

$4938271560 / 4 = 1234567890$

$6172839450 / 5 = 1234567890$

$8641975230 / 7 = 1234567890$

$9876543120 / 8 = 1234567890$


首先，我们因为 $a$ 的各个数位上的数互不相同，所以最大值为 $9876543210$ .

所以，因为 $9876543210$ 没有超时，所以我们直接暴力枚举即可，时间复杂度为 $O(n)$

最后，我们需要一个判断是否有重复数字的函数
（预处理和最后判断都可以）

如果可以，输出；不可以，继续找。

## 接下来就是我的代码思路：

1.头（头文件&名空间）

2.预处理（函数）

3.主函数（定义&输入 & 预处理 & for（枚举））

4.AC。

```cpp
#include<bits/stdc++.h>
#define FOR(i, a, b, c) for(int i = a;i <= b;i += c)
using namespace std;
long long a, t;
int c[10];
using namespace std;
bool f(long long m)//判重
{
	memset(c, 0, sizeof(c));//清零
	while (m != 0)
	{
		long long t = m % 10;
		if(++c[t] >= 2) return 0;
		else m /= 10;
	}
	return 1;
}
int main()
{
	cin>>t;
	FOR(i, 1, t, 1)
	{
		if(j != 1) cout << endl;
		//注意数据间空行
		scanf("%d", &a);
		FOR(i, a, 9876543210, a)
			if(f(i) && f(i / a)) 
			    printf("%lld / %lld = %lld\n", i, i/a, a);
			    //枚举 a 的倍数
	}
	return 0;
}
```
