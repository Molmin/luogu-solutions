首先将 $A_i$ 从小到大排序得到 $B_i$，那么答案的最大值一定不能超过 

$$\sum_{i=n+1}^{2n}B_i-\sum_{i=1}^{n}B_i$$

可以用绝对值不等式证明。

接下来证明这个最大值确实可以取到。

将所有 $i\in[n+1,2n]$ 的 $B_i$ 在 $A$ 中所对应的位置都标为 $1$，其他位置标为 $0$，则现在得到了一个长为 $2n$ 的，$0$ 和 $1$ 数目相等的 $0/1$ 序列 $val$。

要想取到上文所述的最大值，需要构造一个长度为 $2n$ 的合法括号序列，满足其中所有相匹配的括号所对应下标的二元组 $(a,b),a<b$ 都有 $val_a \neq val_b$。

显然，对于一个非空的 $0$ 和 $1$ 数目相等的 $0/1$ 序列，总能找出相邻的两个位置，满足这两个位置上的数值不相等。直接将这两个位置匹配，并在序列中删去这两个位置，将余下部分顺次连接，得到一个新的序列，它有着和原先序列相同的性质，可以递归处理它，直到序列为空。

所以，依照以上实现方法，总能使答案达到理论上界。但朴素的实现是 $\mathcal{O}(n^2)$，需要优化。

可以这样做：维护一个处理队列，队列中的元素是二元组 $(a,b)$，表示 $a$ 和 $b$ 即将匹配。

对于初始的序列，找出所有满足 $val_i \neq val_{i-1}$ 的位置 $i$，并将 $(i-1,i)$ 放入处理队列。

这时会发现部分下标可能在队列中出现多次，所以需要再记录一个数组 $vis_i$ 表示下标 $i$ 是否为空。只有当队首取出的二元组 $(a,b)$ 的 $a$ 和 $b$ 都是空的情况下才处理它。

设 $l_i$ 表示 $i$ 左端（包括 $i$）第一个为空的位置，$r_i$ 表示 $i$ 右端（包括 $i$）第一个为空的位置。

将 $(a,b),a<b$ 进行匹配之后，唯一可能新出现的可以匹配的位置就是 $(l_{a-1},r_{b+1})$。判断 $val_{l_{a-1}}$ 和 $val_{r_{b+1}}$ 是否不等来决定其是否加入处理队列即可。

朴素维护 $l_i$ 与 $r_i$ 的复杂度依然为 $\mathcal{O}(n^2)$。借助并查集的思想，当 $(a,b)$ 匹配后，直接令 $l_a,l_b \leftarrow a-1,r_a,r_b\leftarrow b+1$；当查询 $l_x/r_x$ 时，不断令 $x\leftarrow l_x/r_x$ 直到 $x=l_x/r_x$ 为止，沿途路径压缩。

这样一来就可以单次 $\mathcal{O}(\log n)$ 维护和查询 $l_i$ 和 $r_i$，由于总共的匹配个数为 $n$，所以总复杂度为 $\mathcal{O}(n\log n)$。