本人第一篇题解。

$2022/12/27/10:08$ 修改汉字与数学公式应该空格的错误，重新提交审核。

$2022/12/27/11:16$ 审核通过。

### 题目大意：

题目给出 $N-1$ 个数的一个数列 $S=(S_1,S_2,\ldots ,S_{N-1})$。另外给出 $M$ 个互不相同的整数 $X_1,X_2,X_3,\ldots,X_M$
。这 $M$ 个数是 “幸运数”。
我们假定有一个 “原序列” ，使得对于任意一个 $i\in[1,N-1]$ ，有 $S_i=A_i+A_{i+1}$
。
我们希望构造一个 “原序列” ，使原序列中存在尽可能多的 “幸运数”。请问这个原序列中最多有多少个
“幸运数”。当原序列中存在某个幸运数多次的时候，幸运数个数按多次计算。

### TLE 做法：

~~我不相信这题只有绿~~

我们可以很容易发现一个入手点，就是**若我们能推出 $a_i$，可以使用若干次推导知道 $a$ 数组** (由 $s_{i-1}-a_i$ 求出 $a_{i-1}$，由 $s_{i}-a_i$ 求出 $a_{i+1}$，然后递推下去)。

不难发现，若 $a_i$ 可以推出 $a_1$，$a_1$ 也可以推出 $a_i$，设 $a_i$ 推出的 $a_1=v$，并且 $a_i$ 推出的 $a_1$ 与 $a_j$ 推出的 $a_1$ 相同，则通过 $v$ 可以推出 $a_i$，也可以推出 $a_j$，**则说明 $a_i$ 与 $a_j$ 可以在一个合法的序列中同时存在**。

可以想到，**我们希望有多个幸运数同时存在**，我们可以把一个幸运数所推出来的 $a_1$ 当做这个幸运数的标识，若出现重复则**说明可以构造一个原序列使得这两个幸运数可以同时出现**，重复几次就代表有几个幸运数可以同时出现。

但是复杂度应该不太能通过本题。

### 大优化：
我们发现可以优化的部分就是知道 $a_i$ 求得 $a_1$ 的部分，我们要想办法通过预处理 $O(1)$ 解决。

我们可以知道：

$$
\left\{
\begin{aligned}
A_2 & = S_1-A_1 \\
A_3 & = S_2-A_2 \\
A_4 & = S_3-A_3 \\
& \ldots\ldots \\
A_n & = S_{n-1}-A_{n-1}
\end{aligned}
\right.
$$

因为 $A_3=S_2-A_2$，且 $A_2=S_1-A_1$，可以将 $A_2$ 换为 $S_1-A_1$ 推出 $A_3=S_2-(S_1-A_1)=S_2-S_1+A_1$。

以此种规律递推可以知道：

$$
\left\{
\begin{aligned}
A_2 & = S_1-A_1 \\
A_3 & = S_2-S_1+A_1 \\
A_4 & = S_3-S_2+S_1-A_1 \\
A_5 & = S_4-S_3+S_2-S_1+A_1\\
& \ldots\ldots \\
A_n & = S_{n-1}-S_{n-2}+S_{n-3}-S_{n-4}+\ldots+(-1)^{n} \times A_1
\end{aligned}
\right.
$$

既然我们已经知道了知道 $A_1$ 求 $A_n$ 的求法，不难反推知道 $A_n$ 求 $A_1$ 的求法。

$$A_n = S_{n-1}-S_{n-2}+S_{n-3}-S_{n-4}+\ldots+(-1)^{n} \times A_1$$
$$-((-1)^{n} \times A_1) = (S_{n-1}-S_{n-2}+S_{n-3}-S_{n-4}+\ldots-A_n)$$
$$(-1)^{n+1} \times A_1 = (S_{n-1}-S_{n-2}+S_{n-3}-S_{n-4}+\ldots)-A_n$$
$$A_1 = \frac{S_{n-1}-S_{n-2}+S_{n-3}-S_{n-4}+\ldots-A_n}{ (-1)^{n+1}}$$

很显然，$S_{n-1}-S_{n-2}+S_{n-3}-S_{n-4}+\ldots$ 一部分可以用预处理 $O(1)$ 解决。

这里本人思路将 $S_{n-1}-S_{n-2}+S_{n-3}-S_{n-4}+\ldots$ 定义为 $B_n$，递推公式可以有上述所推：

$$B_i=S_{n-1}-S_{n-2}+S_{n-3}-S_{n-4}+\ldots$$
$$B_i=S_{i-1}-(S_{n-2}-S_{n-3}+S_{n-4}-\ldots)$$
$$B_i=S_{i-1}-B_{i-1}$$

则 $O(1)$ 求知道 $A_n$ 求 $A_1$ 的方法为：

$$A_1=\frac{B_n-A_n}{ (-1)^{n+1}}$$

由于本人为了看起来更方便，并且由于 $\frac{X}{1}$ 或$\frac{X}{-1}$ 均等于 $X \times 1$ 与 $X \times (-1)$，所以可将其换成：

$$A_1=(B_n-A_n)\times(-1)^{n+1}$$

下面给出 $\color{green}AC$ 代码：

```c++
#include <iostream>
#include <map>
#define MAXN 100010
#define MAXM 15
#define ll long long
using namespace std;
ll n,m;
ll s[MAXN],luky[MAXM];
ll a[MAXN],b[MAXN];
map<ll,ll> mp;
ll k;
int main(void) {
    cin>>n>>m;
    for (ll i=1;i<n;i++)
        cin>>s[i];
    for (ll i=1;i<=m;i++)
        cin>>luky[i];
    for (ll i=2;i<=n;i++)
        b[i]=s[i-1]-b[i-1]; //递推公式，上文已做推导
    for (ll i=1;i<=n;i++)
        for (ll j=1;j<=m;j++)
            mp[(b[i]-luky[j])*(i%2?-1:1)]++; //luky[i] 对应文中 a[n]
    for (map<ll,ll>::iterator it=mp.begin();it!=mp.end();it++)
        k=max(k,it->second); //查找最多相同的 a[1]
    cout<<k;
    return 0;
}
```