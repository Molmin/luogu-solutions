这个题的题面有诸多错误或描述不清的地方，在此统一说明一下：
1. 不是循环右移，而是循环左移；
2. 字符串长度不是 $50$ 而是 $60$。

好了，现在我们可以正常地做这道题了。题面说的也很简洁，我们只需要按照顺序，一步步地倒回去即可。

1. 将加密字符串大小写反转，我们只需要判断每个字符是大写还是小写，然后根据 ASCII 码中大小写字母相差 $32$ 就可以完成了。
2. 反转字符串，algorithm 库中为我们提供了一个 `reverse` 函数，它可以通过 `reverse(a,a+n)` 来翻转一个长度为 $n$ 的数组。
3. 将字母循环右移三位，我们可以直接将其对应的 ASCII 码 $+3$，但是要注意边界的处理，这里我们采用对 $26$ 取模实现（如果你不了解模运算请参照[这里](https://baike.baidu.com/item/%E5%8F%96%E6%A8%A1%E8%BF%90%E7%AE%97/10739384?fr=aladdin)）。

核心代码如下：
```cpp
int n;
char s[100];//注意数组要开得比数据范围稍大
char Shift(char c){//将字符循环移位，我这里为了方便使用了函数
  if(c>='A'&&c<='Z')return ((c-'A'+3)+26)%26+'A';
  else return ((c-'a'+3)+26)%26+'a';
}
int main(){
  scanf("%s",s),n=strlen(s);//n 是字符串的长度
  for(int i=0;i<n;i++){
    if(s[i]>='A'&&s[i]<='Z')s[i]+=32;
    else s[i]-=32;
  }
  reverse(s,s+n);
  for(int i=0;i<n;i++)s[i]=Shift(s[i]);
  printf("%s",s);
  return 0;
}
```