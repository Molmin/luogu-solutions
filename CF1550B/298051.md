由乘法分配律可得，分数为 $a \times n + b \times op$ （ $op$ 为操作次数）。  

如 $b \leqslant 0$ ，则需要最大化操作次数，显然是一个个去，答案最大为 $an+bn$ 。  

如 $b<0$ ：  
显然，如有 $x$ 个 A 串和 $y$ 个 B 串 ( $x \leqslant y$ )  
那么尽可能少的去除次数显然为 $x+1$ 次（去除 $x$ 次 A ，一次去完所有 B ）  
因为如果 A 没有去完而去去 B 的，最多每去一次 B 连起来两个 A 的，即多一次 B 省一次 A ，显然没有更优。  
故答案最大为 $(x+1)b+na$ 。  

代码：
```cpp
/*
    Code by xkcdjerry
    Time: 2021-07-14
    Generated by cf-tools
*/
#include <cstdio>

#define int long long
#define N 110
char s[N];
void once()
{
    int n,a,b;
	scanf("%lld%lld%lld%s",&n,&a,&b,s);
	if(b>=0)
	{
		printf("%lld\n",(a+b)*n);
		return;
	}
	else
	{
		int run0=0,run1=0;
		int p=0;
		while(p!=n)
		{
			if(s[p]=='0')
			{
				while(s[p]=='0') p++;
				run0++;
			}
			else
			{
				while(s[p]=='1') p++;
				run1++;
			}
		}
		printf("%lld\n",run0<run1?(run0+1)*b+n*a:(run1+1)*b+n*a);
	}
}
#undef int


int main()
{
    int t;
    scanf("%d",&t);
    while(t--) once();
    return 0;
}
```

[AC记录](https://www.luogu.com.cn/record/53429648)