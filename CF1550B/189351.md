## 题意

给出一个 $\text{01}$ 序列，每次可以删除一段连续的子串，这个子串中每个数都必须相同，删除一段长度为 $l$ 的子串你会获得 $l \times a + b$ 的值，现在，你要清空这个序列，而且你要让你获得的值尽量大，请输出最大的值。

## 分析

可以证明无论如何都要有 $a \times n$ 的值（乘法分配律），然后再可以思考 $b$ 的大小对序列结果的影响。

首先如果 $0\le b$，那么我就要尽可能多的删除次数，那么就可以一个一个删除数字，获得的值是 $b\times n$。

然后考虑 $b < 0$，我们要尽可能少的删除次数，考虑将每一段连续的相同的串的长度对结果没有影响，只有每个元素相同的串的个数对长度有影响，那么 $O(n)$ 搞出每个元素相同的串的个数 $cnt$，那么最优的情况是从最中间往外取，多造几个情况试试就知道应该是 $\lfloor \frac {cnt} 2 \rfloor + 1$ 次，这个 $+1$ 是代表无论如何都要在最中间取一次才能让两边的数合并。

## 代码

```cpp
# include <bits/stdc++.h>
using namespace std;

int T, N, A, B, res;
char s[105];

int main () {
	cin >> T;
	while (T--) {
		cin >> N >> A >> B >> s + 1;
		if (B < 0) {
			int cnt = 0; res = A * N;
			for (int i = 1; i <= N; i++) {
				cnt++;
				while (s[i + 1] == s[i] && i + 1 <= N) i++;
			}
			cout << A * N + (cnt / 2 + 1) * B << endl;
		}
		else cout << (A + B) * N << endl;
	}
	return 0;
}
```