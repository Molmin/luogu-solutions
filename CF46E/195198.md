我调了 50 分钟才做出来的题，很练习代码能力。建议评为蓝题。

首先看到这道题，就自然而然的想到了状态：$dp_{i,j}$ 表示选了前 $i$ 行，第 $i$ 行选了 $j$ 个时题目要求的最大值。

状态转移方程很自然地想到了：

如果 $i$ 为奇数，那么 $dp_{i,j} = \max_{k=1}^{j-1}(dp_{i-1,k} + \sum_{l=1}^{k}a_{i,l})$ （只能选 $k$ 比 $j$ 小的状态，原因见题目）

否则 $i$ 为偶数，那么 $dp_{i,j} = \max_{k=1}^{j-1}(dp_{i-1,k} + \sum_{l=1}^{k}a_{i,l})$ （只能选 $k$ 比 $j$ 大的状态。）

这个复杂度是 $O(n^4)$ 显然会 T 飞。

## 优化一

那个 $l$ 的循环显然可以在 $k$ 循环的时候顺便求出来。这样时间复杂度降到了 $O(n^3)$。交上去，发现第 18 个点 T 飞了。

## 优化二

我们先把优化一之后的转移的核心代码写出来：

```cpp
if(i&1)
{
	int sum=0; //前缀和
	for(int j=1;j<=m;j++)
	{
		sum+=a[i][j]; //优化
		for(int k=1;k<j;k++)
			dp[i][j]=max(dp[i][j],dp[i-1][k]+sum); //转移
	}
}
else
{
	int sum=0;
	for(int j=1;j<=m;j++)
	{
		sum+=a[i][j];
		for(int k=j+1;k<=m;k++)
			dp[i][j]=max(dp[i][j],dp[i-1][k]+sum);
	}
}
```

我们发现，在 $i$ 为奇数的时候，$dp_{i,j}$ 能取到的 $k$ 的范围随着 $j$ 的增加而增加，且每次 $j$ 增加 1，$k$ 的取值范围也增加 1.。因此我们可以每次取得 $\max$ 要么是上次所有取值已经求出的 $\max$ 值得来的，要么是当前能取到的 $dp_{i-1,j-1}$。$i$ 为偶数的时候，我们更改循环顺序为倒序就可以了。

你也许看蒙了，给你们放上转移代码结合一个例子再理解一下：

```
3 3
-1 2 5
-3 6 -1
2 1 -4
```

第一行显然：

$dp_{1,1} = -1,dp_{1,2} = 1,dp_{1,3} = 6$

第二行的推导： 因为是偶数所以倒序推。

$dp_{2,3}$ 会用到第一行第四个往后这些状态（因为只能取 $j>3$ 的上一行状态。）然后发现没法转移，所以赋成 ```INF```。

$dp_{2,2}$ 会用到第一行第三个及往后的这些状态（理由同上）那么这次相当于上一次取得所有 $\max$ 和现在新增的取值 $dp_{1,3}$ 取 $\max$。加上预处理的和，得出这个等于 $6 + 3 = 9$。

$dp_{2,1}$ 会用到第一行第二个及往后的状态（理由略）那么这次相当于上一次取得所有的 $\max$ 和现在新增的取值 $dp_{1,2}$ 取 $\max$。因为 $dp_{1,2}$ 太逊了没有 $dp_{1,3}$ 大，因此 $\max$ 还是 $dp_{1,3}$。加上预处理的和，得出这个等于 $6 + (-1) = 5$。

第三行是奇数行，方法和第二行同理，只不过顺序是从 $1$ 到 $m$ 逐个处理。

### 希望您听懂了。如果没听懂，麻烦您请画个图（我画的太烂了）模拟一下。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
int a[1505][1505],dp[1505][1505];
signed main()
{
	ios_base::sync_with_stdio(false);
	memset(dp,-0x3f,sizeof(dp)); //一定要记得！！！会有负数情况！！！
	int n,m; cin>>n>>m;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			cin>>a[i][j];
	for(int i=1;i<=m;i++) dp[0][i]=0;
	for(int i=1;i<=n;i++)
	{
		if(i&1)
		{
			int sum=0; //前缀和
			for(int j=1;j<=m;j++)
			{
				sum+=a[i][j];
				dp[i][j]=max(dp[i][j-1]-sum+a[i][j]/*因为这里每次转移之后加上了 sum 所以还原的时候要减掉 sum*/,dp[i-1][j-1])+sum; //转移
			}
		}
		else
		{
			int sum=0;
			for(int j=1;j<=m;j++) sum+=a[i][j]; //由于是倒序需要先预处理
			for(int j=m;j>=1;j--)
			{
				dp[i][j]=max(dp[i][j+1]-sum-a[i][j+1],dp[i-1][j+1])+sum;
				sum-=a[i][j]; //每次减掉已经用完的
			}
		}
	}
	int ans=-1e9; //一定要记得！！！会有负数情况！！！
	for(int i=1;i<=m;i++)
		ans=max(ans,dp[n][i]); //最后对答案取 max
	cout<<ans; //实而不华的输出！
	return 0;
}
```

完结撒花！~~~