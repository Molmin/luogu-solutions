首先去想怎么算排列的总方案数，我们先将 $a$ 数组排序，显而易见方案数为 $\prod\limits_{i=1}^{n}a_i-i+1$，具体意思就是你保证了 $a$ 数组从小到大，那么你第 $i$ 个数可以选 $[1,a_i]$ 的数，其中必有 $i-1$ 个数被选过了。

再考虑如何去统计逆序对，发现这样有限制非常难做 dp，于是考虑去算贡献。

我们假设 $i<j$，考虑 $p_i>p_j$ 的**方案数**，然后对于每一对 $(i,j)$ 把方案数加起来就是答案了。

这里我们默认 $a_i>a_j$，对 $i,j$ 的大小关系讨论（如果相等就按照编号排）并设 $rk_i$ 表示 $a_i$ 的排名，$id_i$ 表示 排名为 $i$ 的位置，$tot$ 表示总方案数。

1. $i>j$，那么 $(i,j)$ 对答案的贡献就为 $\frac{(a_j-rk_j+1)\times(a_j-rk_j)}{2}\times\frac{tot}{(a_i-rk_i+1)(a_j-rk_j+1)}\times \prod\limits_{t=rk_j+1}^{rk_i-1}\frac{a_{id_t}-t}{a_{id_t}-t+1}$，这个式子的含义：第一项是 $i,j$ 的方案数，第二，三项是除了 $i,j$ 的方案数，第三项代表你把第 $i$ 项相当于插到了第 $j$ 项的前面去了，相当于优先考虑了第 $i$ 项，因此 $[rk_i+1,rk_j-1]$ 的选泽就减少了 $1$。将式子约分可得：$Ans(i,j)=\frac{tot\times(a_j-rk_j)}{2\times(a_i-rk_i+1)}\times \prod\limits_{t=rk_j+1}^{rk_i-1}\frac{a_{id_t}-t}{a_{id_t}-t+1}$

2. $i<j$，直接容斥，逆序对方案数=总方案数-顺序对方案数，贡献为 $tot-Ans(i,j)$（Ans 的定义前面已经讲过了）

然后这样已经可以 $n^2$ 做了，优化这个过程就去想是否可以按某个顺序加点，然后用数据结构维护呢？

于是我们考虑按照排名加点，查询完当前点和已经加进去的点构成的贡献和后，再把这个点加进去。由于前面钦定了 $a_i>a_j$ ，因此 $Ans(i,j)$ 中的 $j$ 一定比 $i$ 先加入。

先把含 $i$ 的以及常数提取出来，发现就剩下了 $(a_j-rk_j)\times \prod\limits_{t=rk_j+1}^{rk_i-1}\frac{a_{id_t}-t}{a_{id_t}-t+1}$，由于是排名顺序枚举的，因此 $id_i$ 在单次查询中是固定的。我们只需要维护一个线段树表示区间 $(a_j-rk_j)\times \prod\limits_{t=rk_j+1}^{rk_i-1}\frac{a_{id_t}-t}{a_{id_t}-t+1}$ 的和就行，每次加一个点就是先进行一个全局乘，再进行一个单点加。（注意线段树维护的是位置，所以是给 $id_i$ 这个位置加上 $a_{id_i}-i$。）

由于 $i<j$ 需要用 $tot$ 去减，因此你还得用一棵树状数组记录区间已被加入的点的数量。

时间复杂度 $O(n\log n)$。

<https://atcoder.jp/contests/agc023/submissions/33516176>