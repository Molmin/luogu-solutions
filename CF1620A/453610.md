### 题意：

给你一个只有 E , N 的字符串，其中 E 表示这个数的后一个要和这个数相同， N 则表示后一个数和这个数不同。且要求这个序列是一个环（即最后一个数和第一个数也是有关系的）。求有没有一个序列满足所给字符串的要求。

### 思路：

#### 什么情况无解？

例如样例， EN ，设 E 为 $1$ ，则 N 上的数也是 $1$ 。

而 N 则要求 E  即 $1$ 不能等于 $1$ ，这显然是矛盾的，所以是无解。

再仔细想想，如果他这个字符串中要是有 N ，则数一定会有变化，而如果只变化一次，就意味着变不回来了，所以我们可以锁定 N 的数量为 $1$ 这一特殊情况来考虑。

此时，字符出里只有一个 N ，其他的自然全是 E 。这就意味着，在 $N$ 的后面，所有数都与 N 前面的数不一样了。而我们又要求同一个位置不能自相矛盾，所以得出结论， 如果字符串中只有一个 N ，无解，输出 No 。

#### 再考虑有解。

~~不是无解自然是有解（~~

除去无解，那么 $N$ 的数量一定大于 $1$ 了。那此时可能符合要求的数列里就有多种可能的变化机会，即在可能发生矛盾的时候通过 N 这个机会来改变为与原来相同的数。

例如样例， NENN ，则第一个数可以是 $1$ ，第二个数可以是 $2$ ，那第三个数必须是 $2$  ，则第四个数只要不是 $1$ ，就是符合条件的序列。

其实我一开始看的时候也不太明白，但稍微思考一下就能理解了。

综上所述，字符串中 N 的数量为 $1$ 时，输出 No ；反之输出 Yes 。

### 代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
    int t;
    cin>>t; 
    while(t--){
    	string s;
    	cin>>s;
    	int ans=0;
		for(int i=0;i<s.size();i++){
			if(s[i]=='N')ans++;
		}
		if(ans==1)cout<<"NO"<<endl;
        else cout<<"YES"<<endl;	
	}
	return 0;
}
```
