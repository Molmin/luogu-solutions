#  1. 题意
 
 一个由问号与小写字母组成的长度为 $N$ 的字符串 $S$，可以将问号替换为小写字母，保证替换完成的字符串中没有一个连续子串中的某一个字母数量大于字串长度一半。求出所有可能的情况数对 $998244353$ 取余。
 
#  2. 分析
## 2.1 性质
不难发现，形同 `aa`，`aba` 一类的字符串都是不合法的，通过第 $2$ 类 长度为 $3$ 的字串，我们可以看出：只要保证字符串的所有长度为 $3$ 的字串都合法，我们就可以保证字符串整体合法。
## 2.2 状态
考虑dp，不难设出第一维状态 $i$ 为前 $i$ 个字符，考虑 $2.1$ 中推出的性质，我们只需要记录 $i-1$ 与 $i-2$ 位字符是什么，即可保证当前字符串合法。最后设出状态：

$dp_{i,j,k}$ 表示前 $i$ 个字符中，第 $i-1$ 位字符串为 $j$，第 $i$ 位字符串为 $k$ 的所有情况和。

## 2.3 转移
三重循环枚举 $i,j,k$ 是用来枚举前 $i-1$ 位字符填成了什么样子，第四重循环 $l$ 枚举当前第 $i$ 位字符填什么，转移易得：

$dp_{i,j,k}=\sum{dp_{i-1,j,l}}(l\ne j,l\ne k)$

# 3.代码

```cpp
#include<bits/stdc++.h>
#define mod 998244353
using namespace std;
int n,dp[5005][30][30],ans;
char s[5005];
int main(){
	cin>>n>>(s+1);
	dp[0][26][26]=1;
	for(int i=1;i<=n;i++)
		for(int j=0;j<=26;j++)
			for(int k=0;k<=26;k++)
				if(dp[i-1][j][k])
					for(int l=0;l<26;l++)
						if((s[i]=='?'||s[i]==l+'a')&&l!=j&&l!=k)
							dp[i][k][l]=(dp[i][k][l]+dp[i-1][j][k])%mod;
	for(int i=0;i<=26;i++)for(int j=0;j<=26;j++)ans=(ans+dp[n][i][j])%mod;
	cout<<ans;
	return 0;
}
```