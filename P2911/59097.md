感觉有些题解都好长，甚至还有用期望做的同学，这不是让新学的童鞋们更懵嘛。我就写一篇篇幅较短且容易理解的代码，来给新学的童鞋们感受一下c++。。。（大佬请忽略~~（话说大佬也不会看这种题的题解吧）~~）

首先有三个骰子，每个骰子面数不同，s
个面的骰子上，每一个面上的点数为1~s，然后扔骰子，求出三个骰子上的点数和，最后让我们输出出现次数最多的和。

我们就可以枚举三个骰子上的点数，并且求和。但是这个出现次数最多的怎么处理呢？我们可以想到，先把所有的和存下来。但是这样，次数又记不下来，怎么办呢？我们可以开一个数组q[]，专门用来记点数和出现次数，即q[i]的意思是点数和为i的出现次数，数组大小就是maxS1+maxS2+maxS3=20+20+40=80，但是**数组我们一般需要开大一点**，避免超出数组大小而出现的奇怪的错误。

最后就只需要在q数组中全部扫一遍，找出q[i]最大的，则i就是出现最多的点数和。

下面看代码：

```cpp
#include<bits/stdc++.h>//万能头文件 
using namespace std;
int s1,s2,s3;//这三个骰子分别有S1、S2和S3个面 
int q[85];//储存点数和的出现次数 
int maxx,t;//maxx记录最多出现次数，t记录出现次数最多的和 
int main()
{
	cin>>s1>>s2>>s3;//输入这三个骰子的面数  
	for(int i=1;i<=1s;i++)//枚举第一个骰子上的点数 
		for(int j=1;j<=s2;j++)//枚举第二个骰子上的点数 
			for(int k=1;k<=s3;k++)//枚举第三个骰子上的点数 
				q[i+j+k]++;//i+j+k就是点数和，q数组记录这种和出现次数 
	for(int i=1;i<=a+b+c;i++)//最大的和就是a+b+c，所以只要从1枚举a+b+c 
		if(q[i]>maxx)//不断更新最大的出现次数 
		{
			maxx=q[i];//更新最大值 
			t=i;//i就是当前出现最频繁的和 
		}
	cout<<t;//输出出现次数最多的和  
	return 0;//程序结束 
}
```

ps

桶排序和这道题的思想很想，所以一定要掌握这种思想方法：用一个数组q[i]记录数子i出现次数。