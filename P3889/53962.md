题目大意：给出一个长度为 $n$ 的序列 $a$，$m$ 个询问，每个询问给出 $l,r$，在 $[l,r]$ 与 $[1,l)∪(r,n]$ 中各选择一个数字，使得这两个数字的 $\gcd$ 最大。

重点讨论如何在 $[1,l)$ 与 $[l,r]$ 中选择两个数使得它们的 $\gcd$ 最大。因为 $[l,r]$ 与 $(r,n]$ 的 $\operatorname{maxgcd}$ 与之求法是一样的。

我们考虑枚举 $[1,l)$ 中每一个数的所有因子 $d$。然后找到 $[l,n]$ 中下一个拥有因子 $d$ 的位置 $p$。那么我们就用 $d$ 来更新 $p$ 与 $[1,l)$ 的 $\operatorname{maxgcd}$。将 $[1,l)$ 中每一个数的每一个因子全部找到对应的 $p$ 并且更新后，取 $[l,r]$ 的最大值即可。

那么就将每一个询问按 $l$ 升序排序，先预处理出每一个数的因子，以及下一个同样包含这个因子的数字的位置。那么对于连续的两组询问 $[l_i,r_i],[l_{i+1},r_{i+1}]$，我们将 $[l_i,l_{i+1})$ 中所有数每一个因子的贡献存到一棵线段树中。例如在这个区间内一个数有一个因子 $d$，然后通过预处理得到下一个包含因子 $d$ 的数字在位置 $pos$，那么就在线段树中将 $pos$ 的 $\operatorname{maxgcd}$ 与 $d$ 取最大值，然后维护即可。

为什么这样一定是正确的呢？因为我们对于每一个数的每一个因子维护的是距离它最近的下一个含有同样因子的数字 $p$，如果 $p\in [l_i,l_{i+1})$，那么当我们枚举到 $p$ 的时候又会往下一个含有该因子的位置更新；如果 $p\in(r_{i+1},n]$，那么现在 $[l_{i+1},r_{i+1}]$ 中不含有因子 $d$，所以不进行更新。

由于 $a[i]\leq 100000$，可以大力跑出每一个数的因子个数不超过 $d=128$。所以时间复杂度为 $O(n\sqrt{n}+md\log n)$。算是勉强能卡在线内。