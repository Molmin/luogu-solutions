如果注意到了一些性质和结论，这题还是挺简单的qaq

$$
\quad
$$

看这个数据范围就知道要 $O(n)$ 做了。而且不会更快了，因为输入的复杂度就是 $O(n)$。

我们简单思考一下，发现 $x=y$ 的时候很好弄，直接输入的时候顺便计算即可。于是问题的关键在于 $x$ 不等于 $y$ 时如何做出计算。

显然当第一个变量 $x$ 确定之后，第二个变量 $y$ 也是可以确定下来的。我们枚举 $x$ 的时候能否快速确定 $y$？

我们发现决定 $f$ 的大小的有两个因素，分别是较小值和下标之和。因此我们有个显然的结论：当 $\min\{k_x,k_y\}$ 固定时，下标之和越大则函数值越大。

我们**强制枚举到位置 $i$ 时 $i$ 作为函数的第一个变量**。注意到 $f(x,y)=f(y,x)$，即二变量之间的先后顺序是不影响函数的值的。因此：

- 我们每枚举一个位置作为函数第一个变量时，**每次只需要在这个位置的同一侧寻找另一个变量**。因为当我们继续枚举的时候，这个位置会考虑作为函数的第二个变量，所以这样是不会遗漏的。
- 我们在**确定另一个变量的时候，要让这个变量尽可能的大**。

$$
\quad
$$

使用 $ans$ 实时记录答案，用 $y$ 记录第二个变量，从后往前枚举第一个变量 $i$。

卡常题，过不过看评测机心情。

```cpp
const ll SIZE=10000005;
ll n,ans,y,k[SIZE];
int main(){
	n=read();
	for(ll i=1;i<=n;i++)
		k[i]=read(),ans=max(ans,i*k[i]);
	y=n;
	for(int i=n-1;i>=1;i--){
		ans=max(ans,min(k[i],k[y])*(i+y));
		if(k[y]<k[i])y=i;
	}
	printf("%lld",ans);
	return 0;
}
```

给一张图qaq

![](https://cdn.luogu.com.cn/upload/image_hosting/6lfbwawz.png?x-oss-process=image/resize,m_lfit,h_670,w_825)

下面证明正确性：

- 若我们扫描到 $i$ 并更新 $ans$ 后，$k_i>k_y$。此时如果不更新 $y$ 的值，再向前枚举 $i$ 无论如何都不会优于当前的 $ans$ 值。所以此时决策后更新 $y$ 为当前的 $i$ 不会更劣。
- 若我们扫描到 $i$ 并更新 $ans$ 后，$k_i\leq k_y$。此时如果更新了 $y$ 的值为 $i$，则再向前枚举 $i$ 的时候，之后的二变量较小值不会更优，下标之和绝对更劣。所以此时不更新比更新更优。

这样正确性得到了保证。