简单组合数学题。

我们把所给数的 key 计算出来，按照题意模拟即可。将这个 key 打乱顺序，再还原回去，就可以得到 key 相同的数。

考虑打乱顺序后哪些 key 是合法的。

首先， key 的最后一位不能为 $0$ ，因为这样的话在前一位这个数就已经变成 $0$ 了，不符合题意。

由于 key 的每一位都代表一个余数，而除数是从 $2$ 开始的，所以第 $i$ 位的数不能大于 $i$ 。

满足以上两个条件的 key 都是合法的，因为我们一定能够通过这个 key 还原出原数。

考虑如何计算。我们从大到小枚举 key 中的数。设当前有 $j$ 个可用位置，枚举到 $i$ ， key 中有 $a$ 个 $i$ 。初始时答案为 $1$ ， $j=1$ 。那么我们可以从 $j$ 个位置选出 $a$ 个加入 $i$ ，所以答案乘上 $C(j,a)$ 。 每枚举完一个数，就增加一个可用位置（注意枚举到 $0$ 时可用位置不增加）。

考虑如何处理第一条限制。我们只需固定最后一位为 $0$ ，再按上述方法计算一遍，将答案减去不合法的个数即可。

注意要减去自己，因此答案最后要减 $1$ 。

代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
ll c[23][23];
int f[23];
int main(){
	int i,j,k,t;
	ll a,s,p;
	scanf("%d",&t);
	c[0][0]=1;
	for(i=1;i<21;++i){
		c[i][0]=1;
		for(j=1;j<=i;++j)c[i][j]=c[i-1][j-1]+c[i-1][j];
	}//预处理组合数
	while(t--){
		memset(f,0,sizeof(f));
		scanf("%lld",&a),i=2,s=p=1;
		while(a)++f[a%i],a/=i,++i;
		k=i;
		for(i-=2,j=1;i>=0;--i,++j){
			if(!i)--j;
			s*=c[j][f[i]],j-=f[i];
		}//第一遍计算
		i=k-1,--f[0];
		if(f[k-2])p=0;
		else for(i-=2,j=1;i>=0;--i,++j){
			if(!i)--j;
			p*=c[j][f[i]],j-=f[i];
		}//第二遍计算
		printf("%lld\n",s-p-1);
	}
	return 0;
}
```
