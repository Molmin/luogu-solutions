**0. 前言**  
Upd 过审之前改不用写吧（

**0.5 题意**  
给定序列 $b$，求出一个好的序列 $a$ 到 $b$ 的最短距离。好的序列的定义是，对于一个长度为 $2n$ 的序列，若任意的 $n$ 个元素积等于其余元素和，则它是好的。两个序列的距离是对应元素差的绝对值的和。  

**1. 分析**  
先特判 $n=1$，这个不用说了吧。  
若所有元素相等为 $a$：  
>$a+a+\dots+a=a\times a\times\dots\times a$  
即 $n\times a=a^n$  
若 $a\neq 0$，有 $n=a^{n-1}$。  

即 $a=0$ 或 $a=\sqrt[n-1]{n}$。  
第一个解显然符合题意，我们来考虑第二个解。  
找个网站画一下函数图像就可以发现，对于任意 $n>2$ 有 $1<\sqrt[n-1]{n}<2$，取不到整数。  
所以“好的”序列已经有：$\{0,0,\dots,0\}$ 和 $\{2,2,2,2\}$  

还有一个显然的结论，序列全部元素的积是不变的。但是想到从这里入手不容易。  
若不是两两相同的序列，就可以找到一对不等元素 $a,b$，考虑划分 $\{a,\dots\},\{b,\dots\}$，我们假设两个子序列里其余元素的和分别为 $c,d$，积为 $e,f$。再考虑两个子序列交换 $a,b$ 这对元素的划分。  

根据不同划分元素总乘积相等，有 $ae\times bf=af\times be$，根据好序列性质代换可得 $(b+d)(a+c)=(a+d)(b+c)$。  
化简，得 $(b-a)(c-d)=0$。因为 $b-a\neq 0$，所以 $c-d=0$。  
我们就有了一个结论：两个子序列去除任意一对不等元素后，元素和相等。  
>首先，至少有某一个序列有至少两个元素两两不等。若两个序列都由单一元素构成，交换除首元素的任意一对元素之后得到这样的序列。  

>其次，假设两个序列分别是 $\{x,\dots,x,y,\dots,y,\dots\}$（$x\neq y$）和 $\{z_1,\dots,z_n\}$，对于任意 $x\neq z_i$：  
>>若 $y\neq z_i$，则两个序列分别去除 $x,z_i$ 后的和与分别去除 $y,z_i$ 后的和应该一样（因为第二个序列的去除方案并未改变），但根据假设（$x\neq y$），第一个序列的剩余和会改变。矛盾。  

>则对于任意 $x\neq z_i$，有 $y=z_i$。同理对于任意 $y\neq z_i$，有 $x=z_i$。  
我们将两个序列互换，可以得到这样一个结论：两个序列都是若干个 $a$ 和 $b$ 组成的。  

而如果这是一个好序列，我们就可以将它任意划分都满足性质。它只由两种数组成，那必有一种达到了至少一半，我们就可以将达到一半的那一种划分到一起。
>我们进行形如 $\{a,\dots,a,b,\dots,b\}$ 和 $\{b,\dots,b\}$ 的划分。将两组分别去掉一个 $a$ 和一个 $b$，得 $(k-1)a+[(n-1)-(k-1)]b=(n-1)b$，化简得 $(k-1)(a-b)=0$。根据假设，$a\neq b$，所以 $k=1$。  

这意味着，原序列必然是形如 $a,b,\dots,b$ 的形式。  
我们将它任意分割，可以得到 $a+(n-1)b=b^n$ 和 $a\times b^{n-1}=b\times n$。两侧分别相减并化简得 $a-b=-(a-b)b^{n-1}$，根据假设 $a\neq b$，所以 $b^{n-1}=-1$。  

$\sqrt[n-1]{-1}$ 只当 $n$ 是偶数时有 $-1$ 一个根。此时有 $a=n$ （$b=-1$ 带入上一段后式）。  
也就是说，任意的偶数 $n$ 有一组额外的 $\{n,-1,\dots,-1\}$ 解。  

**2. 结论**  
这是我写题解第一次给结论单分一个版块。  
对于 $n=1$，任意 $\{a,a\}$ 均可。  
对于 $n>1$，有 $\{0,\dots,0\}$  
对于 $n=2k$，额外有 $\{n,-1,\dots,-1\}$  
对于 $n=2$，额外有 $\{2,2,2,2\}$。  

**2.5 统计**  
对于 $\{n,-1,\dots,-1\}$ 的情况，我们考虑枚举 $n$ 放在哪一位去统计，先假设所有的位都是 $-1$，然后计算将其中某一个替换成 $n$ 能节约的距离。即 $|a_i-n|-|a_i+1|$ 的最小值。这建立在改变某一元素的值并不改变其他元素的距离上。

**3. 代码**  
```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<algorithm> 
#define int long long
#define maxn 200005

using namespace std;

int _, n, a[maxn * 2];
void work() {
	int ans = 0, asn = 0, mn = 0x3f3f3f3f3f3f3f3fll;
	cin >> n;
	for(int i = 0; i < n * 2; i++) {
		cin >> a[i], ans += abs(a[i]), asn += abs(a[i] + 1);
		if(n % 2 == 0) mn = min(mn, abs(a[i] - n) - abs(a[i] + 1));
	}
	if(n == 1) {
		cout << abs(a[0] - a[1]) << endl;
		return ;
	}
	if(n == 2) {
		ans = min(ans, abs(a[0] - 2) + abs(a[1] - 2) + abs(a[2] - 2) + abs(a[3] - 2));
	}
	ans = min(ans, asn + mn);
	cout << ans << endl;
}

signed main() {
	ios_base::sync_with_stdio(false);
	cin >> _;
	while(_--) work();
}
```