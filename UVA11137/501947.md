相信大家都是从蓝书慕名而来的吧......

## 简单的思路

首先很容易看出是一道动态规划，大致分为两步

1. 预处理所有答案

2. 对于询问，输出

## 蓝书的做法

蓝书上的状态: $d_{i,j}$ 表示用不超过 $i$ 的立方，累加和为 $j$ 的方案数

那么蓝书给了这么一段代码

```cpp
    d[0][0] = 1;
    for (int i = 1; i <= MAXI; i++)
        for (int j = 0; j <= MAXN; j++)
            for (int a = 0; j + a * i * i * i <= MAXN; a++)
                d[i][j + a * i * i * i] += d[i - 1][j];
```

答案是$d_{MAXI,MAXN}$

这个代码的正确性是显然的，足以通过本题，但时间复杂度为 $O(n\;^3\sqrt{n\;log \;n} )$ ,(这个是蒟蒻算的，可能不太对)

我们能不能优化呢？

## 蓝书的提示

蓝书说了可以优化，并给了一个提示

$$
d_{i,j}=d_{i-1,j}+d_{i,j-i^3}
$$

这个式子给人一种“看起来是对的”的感觉，直接照这个式子来就能 AC ，

但是蒟蒻想带大家认识这种做题的思维

## 是的，完全背包

一看到本题凑数，方案，就容易想到背包

再发现可以动态规划，就更笃定是一道背包了

因为每种数字可以无限使用，所以是完全背包

首先，数字 $x$ 可以理解为重量为 $x^3$ 的物品

然后，我们想要让物品正好填满背包，不难打出式子


$$
d_{i,j}=d_{i-1,j}+d_{i,j-i^3}
$$

如果你背包足够熟练的话，就不需要多说什么了吧.....

注意：很容易认为，如果 $j<i^3$ 就 $d_{i,j}=0$ ,其实不是

如果 $j<i^3$ ，我们仍然要继承前面的结果，所以要

$$
d_{i,j}=d_{i-1,j}
$$

然后就很简单了

作为一个完全背包，你也可以优化成一维

## 核心代码

```cpp
	d[0][0]=1
	for(int i=1;i<=MAXI;i++) 
	{
		for(int j=0;j<=MAXN;j++)
		{
			d[i][j]+=d[i-1][j];
			if(j>=i*i*i)d[i][j]+=d[i][j-i*i*i];
		}
	}
```