### 声明

在本篇题解的复杂度表示时，记字符串字符集大小为 $|\Sigma|$，且认为 $N,M,K$ 同阶．

### 题目大意

维护一个字符串集合，支持插入固定母串的一个子串．每插入一个串后输出有多少个本质不同的字符串是集合中至少 $(K+1)$ 个字符串的后缀，以及满足上述要求的最长的字符串的长度．允许离线．

### 做法 $\bf 1$

考虑维护一个哈希表，每次插入一个串后，计算出其所有后缀的哈希值，将哈希表对应键值 $+1$，记录每个串出现第 $(K+1)$ 次出现的时间．最后前缀和即可．

时间复杂度 $O(N^2)$，空间复杂度 $O(N^2)$，期望得分 $35$ pt．

### 做法 $\bf 2$

显然所有符合条件的字符串都是母串的一个子串，考虑建立对于母串的后缀树．对于后缀树的每个结点维护一个权值．每次插入一个串后，将这个串的所有后缀对应后缀树的结点的权值 $+1$．并维护每个权值第一次大于等于 $(K+1)$ 的时刻．然后使用类似做法 1 的方法解决．

根据后缀树的性质，一个串的后缀对应的结点一定是这个串对应的结点或者该结点的祖先．因此，我们可以得到一个推论：

> 每次向集合插入字符串时相当于把这个字符串所对应结点到根路径上的点权 $+1$．

但你会发现上述推论是错误的，考虑当母串 $= \texttt{abc}$ 时，依次插入 $\texttt{bc}$ 和 $\texttt{c}$．由于这两个字符串的 endpos 集合相等，即对应后缀树上的结点相同，故上述做法会认为字符串 $\texttt{bc}$ 作为了集合中 $2$ 个串的后缀出现，得到错误的答案．

解决此问题的一种方式是对后缀树上的每个结点进行拆点．根据 endpos 等价类的性质，对于同一等价类，将类中的所有子串按长度非递增的顺序排序，每个子串都不会比它前一个子串长，与此同时每个子串也是它前一个子串的后缀．我们可以将后缀树上的每个结点拆成一条链，链中结点个数等于该结点对应字符串的个数．以此保证正确性．但我们发现，若按照上述方法拆点后得到的树中的结点个数等于母串的本质不同子串个数，其是 $O(N^2)$ 级别．观察发现，拆点后得到的树有些点是「不需要拆」的，考虑询问离线，只拆需要拆的点，得到一个类似类似虚树的东西，以此同时保证正确性和时间复杂度．

接下来要解决的是如何在后缀树上定位一个区间对应的结点．考虑构建 SAM 时记录母串的每个前缀对应的结点．预处理倍增父亲数组，查询时从前缀对应的结点开始向上倍增跳，跳到深度最小的满足 $\mathrm{len} \ge r-l+1$ 的结点即位符合要求的结点．

考虑采用重链剖分和线段树维护树上修改．线段树维护区间最大值，由于每个值只会由小于 $K$ 到大于等于 $K$ 变换一次．故可以做以下转化：每次修改后二分出第一个大于 $K$ 的位置，记录后将其修改为 $-\infty$．

时间复杂度 $O(N|\Sigma| + N \log^2 N)$，空间复杂度 $O(N|\Sigma| + N \log N)$，期望得分 $60$ pt．

### 做法 $\bf 3$

前面部分应该是无法再继续优化了，考虑优化后面的数据结构部分．

考虑一种离线方式，在每个结点上放一个时间维的线段树，第 $i$ 次链加就把链端点上的线段树 $i$ 位置 $+1$，最后 DFS 一遍把儿子的线段树合并到父亲上，线段树上二分出第一个前缀和大于 $K$ 的位置，就为第一次变化到权值大于 $K$ 的时间．

需要特别注意的是，倍增数组大小只需开到 SAM 的结点数即可，不要因为开了过大数组造成内存超限．

时间复杂度 $O(N|\Sigma| + N \log N)$，空间复杂度 $O(N|\Sigma| + N \log N)$，期望得分 $100$ pt．