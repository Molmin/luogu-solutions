题意：维护一个字符串集合，支持加入给定母串的一个子串，查询至少为集合内 $K+1$ 个元素的后缀的字符串的个数，和它们的最长长度。

暴力思路：每次加入一个字符串时，就给它所有的后缀打一次标记。那么我们要维护的就是那些被打了至少 $K+1$ 次标记的串。字符串到标记次数的对应关系可以用哈希表维护，时间复杂度 $O(NM)$。

考虑如何对这个思路进行优化。注意到一个串的所有后缀对应了后缀自动机 fail 树上这个串对应节点的所有父节点。我们可以建出后缀自动机 fail 树，就可以把所有后缀标记转化为某点到根的链标记。这里有一个小问题，后缀自动机上的节点是一个等价类，可能会出现要打标记的串是这个节点的一部分这种情况。可以按照长度进行拆点，保证每次标记的都包含了整个节点。

拆完点我们得到了一棵树，现在要做的是：某点到根的链打标记，查询标记至少 $K+1$ 次的点的信息。有两种做法：

在线做法，用重链剖分或者全局平衡二叉树把链修改转化为区间修改，由于每个点只会在第 $K+1$ 次标记的时候更新一次，因此可以直接在线段树上暴力更新。复杂度 $O(M\log^2N+N\log N)$（朴素重链剖分）或者 $O((M+N)\log N)$（全局平衡二叉树）。

离线做法，我们只需要知道每个点第 $K+1$ 次标记是在什么时候。把每次链修改操作的时间插入到链底节点上，那么某个点第 $K+1$ 次标记的时间就是子树里第 $K+1$ 小的数字。通过 dfs 序把子树查询转化成区间查询，这是个静态区间 kth 问题，可以主席树解决。时间复杂度 $O((N+M)\log N)$。子树 kth 用线段树合并也是可以的，时间复杂度相同。