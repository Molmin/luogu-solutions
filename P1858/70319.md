题目链接：[[P1858 多人背包]](https://www.luogu.com.cn/problem/P1858)

------------

理一下思路

题意在第一句写的很清楚了，**求01背包前k优解的价值和**。

并且有个条件：**背包必须装满**。

根据01背包的递推式：

$$ f[i][j]=\min \{ f[i][j] ,  f[i][j-v[i]]+w[i] \} $$

不难发现**每一轮 $i$ 循环中 $f[i][j]$ 的变化只与其上一行 $f[i-1][j]$ 及 $f[i][j-v[i]]+w[i]$ 有关。**

而我们的结果是背包必须装满的情况，即 $f[N][V]$ 。

所以我们可以考虑：

**对于每一个 $i$ ，记录一个 _单调_ 的k优解序列，每次对于 $i$ 的k优解序列，从 $i-1$ 的k优解中转移。** 具体的来说，即 $f[i-1][j]$ 的k优解与 $f[i][j-v[i]]$ 的k优解加上 $w[i]$ 。

由于这个最优解序列是单调的，因此可以采取类似归并排序的方式进行转移。

又因为每轮 $i$ 的结果只和 $i-1$ 的结果有关，因此仍然可以采用**滚动数组优化**。

边界条件：体积为 $0$ 时仅有不装这一最优解，其他情况均为 $-\infty$ 。

------------

在01背包的基础上进行一些修改：

- 增加一维用于保存k优解序列

- 每次转移时转移整个k优解序列

- 最终求```f[V][k]```的和

```cpp
for(int i=0;i<=V;i++)
		for(int j=0;j<=K;j++)
			f[i][j]=-1e9;
f[0][1]=0;
for(int i=1;i<=N;i++){
	for(int j=V;j>=v[i];j--){
		c1=1,c2=1,k=0;
		while(k<=K){//归并转移本层的k优解 
			if(f[j][c1] > f[j-v[i]][c2]+w[i])
				t[++k]=f[j][c1++];
			else
				t[++k]=f[j-v[i]][c2++]+w[i];
		}
		for(int k=1;k<=K;k++){//覆盖
			f[j][k]=t[k];
		}	
	}
}
for(int k=1;k<=K;k++)
		ans+=f[V][k];
```