本题解灵感来源于[题解 P1858 【多人背包】](https://www.luogu.com.cn/blog/RPdreamer/p1858)

sto [顾z](https://www.luogu.com.cn/user/87960) orz

本篇题解仅仅是对该题解的解释和说明。

主要对原题解的解析部分加以补充：

该文章中刷表的地方，是通过两个值去更新新的解。

这句话的意思是，因为我们原来01背包的 $f(j)$ 只有可能从 $f(j)$ 和 $f(j - v_i) + w_i$ 中更新，所以我们当前版本的值只会被更优版本的解更新，也就是只会取之前更优的解中没有更新更优解的次略解更新（此处可以类比 k 短路来理解）。

所以我们相当于从大到小枚举所有的次略解，去更新当前解。

> 一个正确的状态转移方程的求解过程遍历了所有可用的策略，也就覆盖了问题的所有方案。

这是 顾z 大佬的原话

也就是

```cpp
while(cnt<=k)
{
    if(f[j][c1]>f[j-V[i]][c2]+W[i])
    now[++cnt]=f[j][c1++];
    else now[++cnt]=f[j-V[i]][c2++]+W[i];
}
```

其他地方那篇文章已经讲得十分详细了，本文不多赘述。