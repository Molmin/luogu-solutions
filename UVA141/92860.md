这道题是一道非常普通的模拟题。

旋转代码可以直接试出来：
```cpp
	//a[i][j]代表第 i 行第 j 列的子量

	for(int i=1;i<=n;i++)
	for(int j=1;j<=n;j++) //普通形态

	for(int i=n;i>=1;i--)
	for(int j=1;j<=n;j++) //旋转90度形态
                         
	for(int i=n;i>=1;i--)
	for(int j=n;j>=1;j--) //旋转180度形态
      
	for(int i=1;i<=n;i++)
	for(int j=n;j>=1;j--) //旋转270度形态
```


难点是如何判断重复。

空间上能过妥妥的，问题是时间每次扫一遍我们UVA的小平台经受不了啊！

于是思路迅速理出来，
# 模拟+优化！

### 优化一！
由于是系统的数据我们可以直接用bool来存棋盘情况。

~~（事实上这个优化是用来凑数的......）~~

### 优化二！
相比于 现今情况 比较 一种历史情况 的 4 种形态，
#### 每种 历史情况 比较 现今情况 的 4 种形态显然更好啊！

### 优化三！
## 终于讲到重点了！
~~（满地打滚后敲黑板）~~

# 哈希优化！

#### 什么是哈希（Hash）

###### 维基百科关于哈希算法的解释：

> 散列函数（或散列算法，又称哈希函数，英语：Hash Function）是一种从任何一种数据中创建小的数字“指纹”的方法。散列函数把消息或数据压缩成摘要，使得数据量变小，将数据的格式固定下来。该函数将数据打乱混合，重新创建一个叫做散列值（hash values，hash codes，hash sums，或hashes）的指纹。散列值通常用一个短的随机字母和数字组成的字符串来代表。

###### 《区块链行业词典》的解释：

> 哈希值通常用一个短的随机字母和数字组成的字符串来代表，是一组任意长度的输入信息通过哈希算法得到的“数据指纹”。因为计算机在底层机器码是采用二进制的模式。

> 因此通过哈希算法得到的任意长度的二进制值映射为较短的固定长度的二进制值，即哈希值。此外，哈希值是一段数据唯一且极其紧凑的数值表示形式，如果通过哈希一段明文得到哈希值，哪怕只更改该段明文中的任意一个字母，随后得到的哈希值都将不同

看完这两段严谨的解释，再配以不太严谨的类比和举例，应该就能对哈希有一个更深入的认识。

哈希算法是一个函数，能够把几乎所有的数字文件都转换成一串由数字和字母构成的看似乱码的字符串。

中学我们都学过函数y=f(x),对应到哈希函数，输入任意值x，进过f函数（在这里就是哈希算法）的运算，得到一个y（在这里也叫哈希值）。

哈希函数作为一种加密函数，其拥有两个最重要特点：

* 不可逆性。输入信息得出输出的那个看似乱码的字符串（哈希值）非常容易，但是从输出的字符串反推出输入的结果却是却非常非常难。

从数学理论上来讲，函数都是可逆的，知道输出结果和函数关系，一定可以推出输入值。而现在计算机所采取的方法就是暴力破解，采取枚举的方法，一个一个试（哈希碰撞），直至试出正确的结果。

* 输出值唯一性和不可预测性。只要输入的信息有一点点区别，那么根据哈希算法得出来的输出值也相差甚远。

好了废话少说，我的哈希加密代码如下：

u+=a[i][j],u*=1091,u%=1000151;

其中1091,1000151是质数。

这样，每一种情况的u的返回值几乎都不一样。

这样，我们就把一个数组比较问题变成了数据比较问题。

# ~~6不6！！！~~

好了，上代码！
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
bool a[100][100]; //优化一 
int b[10000],n,s,d,Die;
char k;
int Mi(int l) //旋转+加密 
{
	int u=0;
	if(l==1)
	for(int i=1;i<=n;i++)
	for(int j=1;j<=n;j++) u+=a[i][j],u*=1091,u%=1000151;
	if(l==2)
	for(int i=n;i>=1;i--)
	for(int j=1;j<=n;j++) u+=a[j][i],u*=1091,u%=1000151;
	if(l==3)
	for(int i=n;i>=1;i--)
	for(int j=n;j>=1;j--) u+=a[i][j],u*=1091,u%=1000151;
	if(l==4)
	for(int i=1;i<=n;i++)
	for(int j=n;j>=1;j--) u+=a[j][i],u*=1091,u%=1000151; //优化三 
	return u;
}
int main()
{
	while(~scanf("%d",&n))
	{
		if(n==0) break;
		memset(a,0,sizeof(a));
		memset(b,0,sizeof(b));Die=0;b[0]=0;
		for(int i=1;i<=2*n;i++)
		{
			cin>>s>>d>>k;
			if(Die!=0) continue;
			if(k=='+') a[s][d]=1;
			if(k=='-') a[s][d]=0;b[i]=Mi(1);
//			cout<<"-->"<<b[i]<<endl;
			for(int j=0;j<i;j++) //优化二 
			{
				if(b[j]==Mi(1)||b[j]==Mi(2)||b[j]==Mi(3)||b[j]==Mi(4)) {Die=i;break;}
			}
		}
		if(Die==0) cout<<"Draw"<<endl;
		else printf("Player %d wins on move %d\n",1+Die%2,Die);
	}
}
```
**点赞吧~！**