~~我是不会告诉你们这道题我肝了三天之久~~

(楼上各位大佬的代码各显神通，所以就不在这里放完整代码了)

## 下面来讲一讲我对这道题每一个部分的理解吧qwq

（挑选食用效果更佳w）

### 1-0 关于蚂蚁

#### 1-1 蚂蚁的出生：

蚂蚁出生很好写，把需要维护的信息考虑全就行，对于每只蚂蚁，我们需要以下信息，还有要注意只有当前蚂蚁数量小于6并且（0,0）没有蚂蚁时才能出生：

```cpp
struct ant{
	int x,y,prex,prey;//当前位置与上一步位置 
	int old;//年龄 
	int base;//等级 
	int rest;//血量 
	bool die,cake;//是否死亡，是否拿到蛋糕 
	double maxx;//最大血量 
}a[200005];
```

然后蚂蚁出生：

```cpp
void appear(){
	mp[0][0]=1;tot++;numant++;
	a[tot].x=0;a[tot].y=0;a[tot].base=(tot-1)/6+1;
	double Health=floor(4*pow(1.1,a[tot].base));
	a[tot].rest=(int)Health;a[tot].maxx=Health;
	a[tot].die=0;a[tot].old=0;a[tot].cake=0;
	a[tot].prex=a[tot].prey=-1;
}
```

这里的坑点在于需要用一个double去维护最高血量，不然在以后计算时会掉精度

还有一个坑点是蚂蚁的初始年龄是0

#### 1-2 蚂蚁留下信息素：

虽然这里只要写一个for循环就行了，但是我建议在写这种码量很大的代码时，将每一步函数化，这样就会清楚的知道自己在干什么，毕竟思路清楚是最重要的xd（太简单就不放代码了）

#### 1-3 蚂蚁拿蛋糕：

同样很easy，这里CAKE记录蛋糕是否在原位，target记录惨遭集火的蚂蚁qwq

```cpp
void getcake(){
	if (!CAKE) return;
	for (int i=1;i<=tot;++i){
		if (a[i].die) continue;//逝者长眠
		if (a[i].x==n && a[i].y==m){//就位 
			CAKE=0;target=i;//蛋糕消失，成为目标 
			a[i].cake=1;a[i].rest+=(int)(a[i].maxx/2);//保证精度 
			a[i].rest=min(a[i].rest,(int)a[i].maxx);//不能暴血 
			return;
		}
	}
}
```

#### 1-4 蚂蚁死亡：

在炮塔攻击后需要的打扫战场工作，血量小于0的记录死亡，如果有蛋糕记得归位（同样不贴代码）

#### 1-5 蚂蚁长大：

for循环++old即可（同样不贴，因为重头戏在后面）

#### 1-6 蚂蚁移动：

本题难点之一，难在情况多、代码繁琐，需要注意的：

1.活动时间是5的倍数（叛逆期）的蚂蚁逆时针转动

2.如果不能动一定记得把上一步的位置赋值成当前位置，因为下一步就可以走不动前的那个位置了（被坑过qwq）

3.注意题中“如果此时仍有多种选择……直到找到可以去的方向”这句话，这里的多种选择是指那些信息素最大且相同的位置，而不是能走到的所有位置（被坑过qwq也可能是我语文不好）

（这里我也不贴代码了，因为我写的又蠢又丑，读者可以参考楼上各位大佬的w）

### 2-0 关于炮塔

#### 2-1 确认目标：

由于炮塔是同时开火的，也就意味着会打一些血量已经小于0的蚂蚁，所以要先统一确认目标再统一扣血，当然有集火目标先集火：

```cpp
void look(int i){
	goal[i]=0;
	double mindis=1e9,dis;
	if (target && !a[target].die){//有活着的集火目标 
		dis=dist(towerx[i],towery[i],a[target].x,a[target].y);
		if (dis-r<=eps){goal[i]=target;return;}//在射程内 
	}
	for (int j=1;j<=tot;++j){
		if (a[j].die) continue;//逝者长眠 
		dis=dist(towerx[i],towery[i],a[j].x,a[j].y);
		if (dis-r<=eps && dis<mindis) mindis=dis,goal[i]=j;
	}
}
```

#### 2-2 意大利炮式无情打击：

这里有个显然的事情，只有在打蛋糕蚂蚁时才有可能波及到一些躺枪的蚂蚁，不然一定会选择更近的蚂蚁

```cpp
void shoot(int tow,int at){
	for (int i=1;i<=tot;++i){
		if (a[i].die || i==at) continue;
		if (online(tow,at,i)) a[i].rest-=d;//无辜躺枪 
	}
}
```

#### 2-3 判断是否躺枪：

本题难点之二，难在需要一些数学知识

（先声明，这里借用了楼上一位大佬的思路，很巧妙）

我们设炮塔位置A，蛋糕蚂蚁位置B，无辜躺枪者位置C

先特判如果C就是蛋糕蚂蚁就直接打

然后如果C到AB距离大于0.5就不在这条线上，这里要用到点到直线距离公式（我默认直线方程的A、B、C读者都会求）：

```cpp
inline double calc(double X,double Y,double A,double B,double C){
	return (abs(A*X+B*Y+C))/(sqrt(A*A+B*B));
}
```

这时我们注意到，这是一条线段，而不是直线，所以C一定要在A、B之间才会躺枪。一个巧妙的判断方法：AB经过圆C，当且仅当∠CAB和∠CBA都是锐角（画个图就明白了）

```cpp
	int cos1,cos2;
	cos1=(tx-cx)*(nowx-cx)+(ty-cy)*(nowy-cy);
	cos2=(cx-tx)*(nowx-tx)+(cy-ty)*(nowy-ty);
	if (cos1>0 && cos2>0) return true;
```

因为这里是通篇思路，不可能讲清楚每一个细节，希望读者不仅仅要看懂，还要自己亲身去实践，这样才会有提高，具体的可以参考楼上大佬的详解xd

### 3-0 一些idea

1.在你想要无限颓废的时候，可以写一写这样的题to calm down

2.这种题不要觉得没有巧妙的算法与优美的数据结构就不去写他，要知道，代码能力有时比算法与数据结构更加管用，尤其是在OI生涯中，在想崩正解时，如何高效的写出优秀的暴力。算法与数据结构冗杂丰富，不是写一两道题就ok的，但是写一次这种300多行的大模拟，对你的代码能力提高有很大帮助

3.尤其在大赛将至时，可以写一写这种题，一来找手感，二来培养耐心（显然你在大赛中是不能弃疗且自闭的qwq）

4.在你调不出某些点时，千万千万不要放弃，一个小时调不出来就调两个小时，一天调不出来就调两天，弃疗与自闭永远提高你的能力，当你花了十万分精力看到满屏的绿色AC时，你的信心与能力都会有质的飞越

5.还有在你写这种大模拟时，思路是第一位的，先捋清思路再着手代码，争取一气呵成，记住某位神犇说过的话：think twice,code once

最最最后，祝大家OI生涯顺利，noip2018++rp

（一个半小时写的，求管理大大给过啊orz）








