题目没有翻译，这里个出一下。

## 题目翻译

在一个电视娱乐节目中，你一开始有 $1$ 元钱。主持人会问你 $n$ 个问题，每次你听到问题后有两个选择：

一是放弃回答该问题，退出游戏，拿走奖金；二是回答问题。

如果回答正确，奖金加倍；如果回答错误，游戏结束，你一分钱也拿不到。

如果正确地回答完所有 $n$ 个问题，你将拿走所有的 $2^n$ 元钱，成为 $2^n$ 元富翁。

当然，回答问题是有风险的。每次听到问题后，你可以立刻估计出答对的概率。
由于主持人会随机问问题，你可以认为每个问题的答对概率在 $t$ 和 $1$ 之间均匀分布。
输入整数 $n$ 和实数 $t$($1 \le n \le 30,0 \le t \le 1)$，你的任务是求出在最优策略下，拿走的奖金金额的期望值。

这里的最优策略是指让奖金的期望值尽量大。

## 题目解析

我们令 $d_i$ 为答对 $i$ 题后的最大期望奖金。

假设刚开始游戏，如果直接放弃，奖金为 $1$。

如果回答，期望奖金为 $p\times d_1$。

答对概率为 $p$，期望奖金的最大值 $= \max(2^0, p \times d_1)$，

这里故意写成 $2^0$，强调这是“答对 $0$ 题后放弃”所得到的最终奖金。

上述分析可以推广到一般情况，但是要注意一点：到目前为止，一直假定 $p$ 是已知的，

而 $p$ 实际上并不固定，而是在 $t$ 到 $1$ 内均匀分布。可以得到：$d_i = max(2^i, p \times d_{i+1})$。

因为有 $\max$ 函数的存在，需要分两种情况讨论，即 $p \times d_{i+1}<2^i$ 和 $p \times d_{i+1} \ge 2^i$ 两种情况。

令 $p0=\max(t, 2^i/d_{i+1})$（加了一个 $\max$ 是因为根据题目，$p≥t$ ），则：


$p<p0$ 时，$p \times d_{i+1}<2^i$，因此“不回答”比较好，期望奖金等于 $2^i$。


$p≥p0$ 时，“回答”比较好，期望奖金等于 $d_{i+1}$ 乘以 $p$ 的平均值，即 $(1+p0)/2 \times d_{i+1}$。

在第一种情况中，p的实际范围是 $[t,p0)$，因此概率为 $p1=(p0-t)/(1-t)$。


根据全期望公式，$d_i = 2^i \times p1 + (1+p0)/2 \times d_{i+1} \times (1-p1)$。

边界是 $d_n = 2^n$，逆向递推出 $d_0$ 就是本题的答案。

## 参考代码

```
#include <cstdio>
#include <algorithm>
using namespace std;
const int UP = 30 + 5;
double d[UP];
int main()
{    
    int n;
    double t;
    while(scanf("%d%lf", &n, &t) && n) {
        d[n] = 1<<n;
        for(int i = n-1; i >= 0; i--) {
            double p0 = max(t, (double)(1<<i) / d[i+1]);
            double p1 = (p0-t) / (1-t);
            d[i] = p1 * (1<<i) + (1-p1) * (1+p0)/2 * d[i+1];
        }
        printf("%.3f\n", d[0]);
    }
    return 0;
}
```
