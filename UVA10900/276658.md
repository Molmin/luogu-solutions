这一道题设计到概率论和随机过程中的一些基础思想。但是想要单纯解这道题用不到解析证明。

首先理解一个概念，连续化操作中当前操作期望首后面的结果影响。这样的话就可以得出第一个递归式子：

d[i] = max(2^i ,  p* d[i-1])

反正就是突出一个递归加上连续积分化的概率变量。

其中注意，这个概率本身都是随机的，即累次随机，不过这又不是随机过程考试，管他的呢。能理解就行。

因为所求积分本身不一定连续，所以设计到讨论：p* d_{i-1}和2^i的大小关系。

解出临界值后还需注意有一个下确界：t，变成的时候加入其中，得到临界值：

p0 = max(t,2^i/d[i+1]);

p<p0即放弃，p>=p0即可勇闯天涯（继续走）。

此时得出坚持走下去为更优策略的概率：ans = (p0-t)/(1-t);

代码如下：

```cpp
#include<iostream>
using namespace std;
double d[1000];
int main(){
    double t;
    int n;
    while((scanf("%d %lf",&n,&t)==2)&&(n!=0)){
        d[n] = 1<<n;
        for(int i = n-1;i>=0;i--){
            double p0 = max(t,(1<<i)/d[i+1]);
            double p1 = (p0 - t)/(1 - t);
            d[i] = (1<<i)*p1+(1+p0)/2*d[i+1]*(1-p1);
        }
        printf("%.3lf\n",d[0]);
    }
}
```
