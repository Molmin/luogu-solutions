
更新于
$2020$ 
$3.30$
,
用
$markdown$
美化了题解，望管理员通过。

### 数据范围分析：

额，首先拿到题目大家都会不约而同地想到搜索（也可以说成回溯）+模拟这个算法。

然后疯狂打代码，再自信满满地提交——恭喜你，你
$TLE$
了！

然后再回过头来看数据：
$1≤n≤2$
$\times$
$10^5$
$-1$
,
$1≤s≤10^9$

现在想想恨不得抽自己一个大嘴巴子。

好的，现在我们不得不想另一种方法了。

### 先来普及一下中位数的知识
#### ~~（我才不会告诉你是我去问度娘的qwq）~~

一、中位数定义

中位数，统计学中的专有名词，代表一个样本、种群或概率分布中的一个数值，其可将数值集合划分为相等的上下两部分。

二、中位数的意义

中位数将数据分成前半部分和后半部分，因此用来代表一组数据的“一般水平”。

三、中位数的求法

对于一组有限个数的数据来说，它们的中位数是这样的一种数：这群数据里的一半的数据比它大，而另外一半数据比它小。 

计算有限个数的数据的中位数的方法是：把所有的同类数据按照大小的顺序排列。如果数据的个数是奇数，则中间那个数据就是这群数据的中位数；如果数据的个数是偶数，则中间那
$2$
个数据的算术平均值就是这群数据的中位数。


------------
### 排序分析：

既然是中位数，就要保证数组有序（上面也提到了），所以第一步先排序，也是方便我们下面的查找。

------------

### 情况$1$

拿样例来说：

$n=3$
,
$s=8;$


| 数组元素 | $5$ | $6$ | $8$ |
| :----------: | :----------: | :----------: | :----------: |
| 下标 | $1$ | $2$ | $3$ |
| 中位数所在 |  | ↑ |  |
|期望| $5$  |$\color{red}\text{8}$ |$8$ |
|修改|  |$2$|  |
一共修改
$2$
次

---------

再比如：
$n=7$
,
$s=20;$


| 数组元素 | $11$ |$ 12 $|$ 12$ |$ 15$|$19$ |$20$ |$21$ |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| 下标 |$ 1$ |$ 2 $| $3$ |$4$|$5$|$6$|$7$|
| 中位数所在 |  |  |  |↑ | | | |
|期望| $ 11$  |$12$ |$12$ |$\color{red}\text{20}$|$\color{red}\text{20}$|$20$|$21$
|修改| | | |$5$|$1$| | |

一共修改
$6$
次

---------

#### 情况$1$总结发现 
通过这两组数据我们可以发现：如果中位数的值
$<s$
，则从中位数向右查找至
$n$
，如果当前位置的值
$<s$
就将总数$+=s-$
当前位置的值，最后输出总数

------------

### 情况$2$

举个例子：

$n=5$
,
$s=6$


| 数组元素 | $5$ |$ 7$ |$ 9$ | $10$|$11$|
| :----------: | :----------: | :----------: | :----------: |:----------: |:----------: |
| 下标 | $1$ | $2 $| $3$ | $4$| $5$ |
| 中位数所在 |  |  | ↑ | | |
|期望| $5$  |$\color{red}\text{6}$ |$\color{red}\text{6}$ |$10$|$11$
|修改| |$1$|$3$| | |

一共修改
$4$
次

----------

#### 情况$2$方法总结：

通过这以上数据我们可以发现：如果中位数的值>s，则从中位数向右左查找至
$1$
，如果当前位置的值
$>s$
就将总数
$+=$
当前位置的值
$-s$
，最后输出总数

---------

### 情况$3$：
这一种是最简单的情况，也就是中位数等于
$s$
的情况，那我们直接输出
$0$
就可以了。

举个例子：

$n=3$
,
$s=1$


| 数组元素 | $1$ | $1$ |$ 1$ |
| :----------: | :----------: | :----------: | :----------: |:----------: |:----------: |
| 下标 | $1$ |$ 2$ |$ 3$ |
| 中位数所在 |  |↑  | |
|期望| $ 1$  |$1$|$ 1$|
|修改 |  |  |  |

一共修改
$0$
次

----------

### 三种情况的总结：

1. 中间位的值$==s$，直接输出$0$。
2. 中位数的值$>s$，向左找，累加$>s$的值。
3. 中位数的值$<s$，向右找，累加$<s$的值。

--------

### 原理：

根据三种不同情况的分析，我们发现这其实是一道并不怎么难想的贪心题。

贪心的有
$n$
个点：

1. 只需要判断中间值的大小，然后向一边查找即可。举个例子：如果要把一个排序好的数组的中间位置改大一些，那在此位置左边的数，也就是比中间值小的数，对于这些数来说，改大中间值并没有对它们造成任何影响。
1. 对于向左找只需要改$>s$的数，因为向左找的是较小的数，如果较小的数已经$<s$了，那修改也就毫无意义了。
1. 修改的时候只需要把不符合要求的统统修改成$s$就可以了，因为再多增加$1$或者少$1$已经毫无意义，因为已经符合要求了。

当然，右边的也一样。

------

### 代码区：

```cpp
#include<bits/stdc++.h>  //文件头
using namespace std;   //定义空间名
long long n,s,d,dd,a[1000010];  //定义，记得开long long
int main()
{
	cin>>n>>s;
	for(int i=1; i<=n; i++)
	cin>>a[i];    //输入
	sort(a+1,a+1+n);  //排序
	if(a[(n+1)/2]==s)   //情况一
	{
		cout<<0;
	}
	if(a[(n+1)/2]>s)   //情况2
	{
		for(int i=1; i<=(n+1)/2; i++)  //向左找
		if(a[i]>s)d+=abs(s-a[i]);//累加>s的值
		cout<<d; //输出
	}
	if(a[(n+1)/2]<s)  //情况3
	{
		for(int i=(n+1)/2; i<=n; i++)  //向右找
		if(a[i]<s)dd+=abs(s-a[i]);//累加《s的值
		cout<<dd;	//输出
	}
	return 0;
}
```
声明一下：我并不是因为懒而不写超时的代码qwq。

PS：程序里面没有坑！！！~~显然这是此地无银三百两，但是你想多了~~

看我写题解那么不容易，就给我点个赞吧！~~跪求各位大佬~~
