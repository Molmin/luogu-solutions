# 题面
[方伯伯的商场之旅](https://www.luogu.com.cn/problem/P3286)
# 题解
如果是单个的情况，将它面前的石子往中位数的位置移肯定是最优的。

但是由于数的范围很大，这样做只能单独处理，所以显然不能这么做。

考虑上述思路的局限性，每个数面前的石子的中位数都要单独处理，也就是每个集合内的石子会移到不同且需要我们去求的位置，所以我们在规定的时间内无法做。

考虑我们能求出什么，如果我们知道了每个集合内的石子往哪里移，并且移到相同的位置，我们就可以用数位 DP 求出总花费。

但是这和我们要求的有什么联系呢。

接下来就是神仙转化。

我们先将每个集合内的石子移到位置 $1$， 然后再从左往右扫，求出答案的减小量，如果减小量为正，就更新答案，为了把范围内的总花费求出来，我们统计答案要以前缀和的形式统计。

# 数位 DP 的代码帮助理解：

用 $sum$ 表示减小量。

每次把移的位置往右移一位到 $p$，如果对于位置小于 $p$的，那么把要移的位置右移一位到 $p$ 时，总花费变大，那么对于减小量的贡献就是负的当前位置的值乘上多的距离 $1$，对于在 $p$ 右边及在 $p$ 上的，同理总花费变小，对减小量的贡献为正。

因为我们数位 DP 的时候从高位往低位扫，所以每次对减小量的贡献是从正的变成负的，所以一旦 $sum < 0$，那么它就不可能再变成正的了，而负的减小量是不能更新总花费的，所以直接返回 $0$。
```cpp
LL dfs(int now, int sum, int p, int lim) {
	if(sum < 0) return 0;
	if(!now) return max(sum, 0);
	if(!lim && ~f[now][sum]) return f[now][sum];
	int num = lim ? a[now] : k - 1; LL res = 0;
	for(int i = 0; i <= num; i++)
		res += dfs(now - 1, sum + ((p == 1) ? i * (now - 1) : (now < p ? -i : i)), p, lim & (i == num));
	if(!lim) return f[now][sum] = res;
	return res;
}
```