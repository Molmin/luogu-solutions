#### 发一弹题解biu!biu!biu!

题意：~~开局两个1，运算全靠拼~~，咳咳，给你一个初始数字对（1,1），你可以将（a，b）这个数字对变成（a+b,b）或（a，a+b）问最少用多少次其中一个数字能变成给定的数字n

第一眼一看，水题，一个dfs+剪枝就行，提交后，~~60分的好成绩~~

数据范围$10^6$，啊这，深搜要出多少分枝啊

那么怎么办呢？该优化的都优化了，$O^2$也开了。

于是咱们可以倒着搜

由（1,1）能变换到（i，n）同样也能从（i，n）变换成（1,1），只是把加变成减，但是这个i我们没有啊！怎么办？枚举呗，枚举1~n-1就行，为什么不枚举到n以及n以上呢，因为如果是两个n肯定相减得零，不成立啊。大于n可以转换成（i，m-n）这还多了一步呢。

于是乎咱们写一个倒推回去的函数，每次用大数减去小数，直到两个数都变成1或者有一个小于1时return。

复杂度$(nlogn)$，循环n次，推回去logn

代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,ans;
void oper(int a,int b,int time)//对数对进行一次操作 
{
	if(a==1&&b==1)//如果成功返回到数对（1,1）那么更新最小步数 
	{
		ans=min(time,ans);
		return;
	}
	if(a<1||b<1)//如果有一个小于1肯定不成立 
	{
		return;
	}
	if(a<b)oper(a,b-a,time+1);//对数对进行如题反变换 
	else
	{
		oper(a-b,b,time+1);
	}
} 
int main()
{
	cin>>n;
	ans=n-1;//这里，因为（1,1）数对用一个1一直加另一个加n-1次肯定能得到答案 
	for(int i=1;i<n;i++)oper(n,i,0);//便利 
	cout<<ans;//输出 
}
```

还有个问题请教一下，我这玩意放我电脑上运行大于40000就算不出来，怎么你谷可以评测呢？？？

### 题解千万条，理解第一条。直接抄题解，棕名两行泪。