我们可以先举一个例子来熟悉一下题目（第一行为$k$，第二行为字符串）：

2

0 1 0 1 0（为了方便，我加了空格）

接下来我们研究一下，要想有两个$k$，那么这个字串的结尾应在第二个1即以后。

**但是，还有0呀**。后面的0我们可以不用管，因为可以往后扫，就自动算上了。那前面的咋办呢？那我们可以用一个数组 $s0_i$，意思是第i个1后有多少个0。**我们初始化时应将这个数组的第一个设为1**，因为开头没算没有0（也就是0个0）的情况。

比如这个例子，我们就应该从第二个1开始看起，前面有一个0，所以有两种选择（1个或0个）。继续往后到最后一个字符，前面还是两种，所以加起来为4。

上代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define MAXN 1000005
int k,s0[MAXN]={1},s1=0;//初始化
char s;//用char输入会简单一点
long long ans=0;
int main(){
    cin>>k;
    while(cin>>s) {
        if(s=='1')s1++;//累计有多少个1
        if(s1>=k)ans+=s0[s1-k];
        s0[s1]++;//累加第s1个1后的0的个数
    }
    cout<<ans<<endl;
}
```
