约定：

+ $\&$ 表示按位与。
+ $\mid$ 表示按位或。
+ $\sim$ 表示按位取反，和 C 语言的符号一样。

题意就是对于每一个 $a_i$，求任意一个可能的 $a_j$ 使得 $a_i\ \&\ a_j=0$。

直接按位与似乎不是很好做。既然 $a_i\ \&\ a_j=0$，那么必然会有 $(\sim a_i)\ \&\ a_j=a_j$。

证明也很显然：对于 $a_j$ 的某一位，如果是 $0$ 则显然在这一位成立，取反之后再按位与这一位得到的还是 $0$；如果是 $1$ 那么 $a_i$ 这一位必然是 $0$，取反之后这一位必然是 $1$，按位与之后这一位必然还是 $1$。

反之依然成立，证明类似。

接下来问题转化成：找到一个 $a_j$ 使得 $(\sim a_i)\ \&\ a_j=a_j$。

设 $f_x$ 表示 $\sim a_i=x$ 时，一个合法的 $a_k$。

容易想到，$a_j\ \&\ m=a_j$，$a_j\ \&\ (m\mid p)=a_j$。

那么转移就很自然了，当 $y\ \&\ x=y$ 且 $f_y$ 有解时，$f_x$ 可以从 $f_y$ 转移。

这样就可以实现了。

$\log_2 (4\times10^6)<22$，所以 $f$ 存到 $2^{22}$ 即可。

```cpp
#include <iostream>
#define rep(i,l,r) for(i=l;i<=r;++i)
using namespace std;
int n,cnt,i,j;
int a[1000005],b[1000005],f[1<<22|5];
int main() {
	cin>>n;
	rep(i,1,n)
	{
		cin>>a[i];
		f[a[i]]=a[i];//初始化，a[i] & a[i]=a[i]
	}
	cnt=(1<<22)-1;
	rep(i,0,21)
		rep(j,0,cnt)
			if((j&(1<<i)) && f[j^(1<<i)])//j 从 j^(1<<i) 转移
				f[j]=f[j^(1<<i)];
	rep(i,1,n)
	{
		b[i]=cnt^a[i];//也就是取反。
		cout<<(f[b[i]]?f[b[i]]:-1)<<' ';
	}
	return 0;
}


```