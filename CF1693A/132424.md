**谨以此题解纪念长时间停打 CF 后的第一场比赛**

### 思路

这题爆 ```long long``` 吃了 150 罚分，人麻了 qwq

又是结论题。~~结论题专场了属于是~~

先分析一下，假设第一次一直到了位置 $i$。因为最后需要回到 $1$ 号下标，所以除了 $1$ 号下标会加一，$i$ 号下标会减一以外其他的都会抵消掉。

所以，我们可以看出来总和是恒为 $0$ 的，那么对于总和不为 $0$ 的直接输出 ```No``` 即可。

现在，我们可以把问题变成：

> 你可以选择一些长度大于 $1$ 的区间，要求第一个区间左端点为 $1$，现在可以将这些区间的左端点加一，右端点减一，问能否将全是 $0$ 的数组变为目标数组。

那么，我们设选出来的区间分别为 $l_i,r_i$，则这些区间可以对应原操作：

$l_1->r_1->l_2->r_2->l_3->r_3->...->r_k->1$

为了方便，我们可以让 $r_i$ 是单调不增的。因为若 $r_{i+1}>l_{i+1}>r_i$，对应到原操作 $r_i$ 并没有加一，出现了错误，而若 $r_{i+1}>r_i>l_{i+1}$，则原操作与 $l_i->r_{i+1}->l_{i+1}->r_{i}$ 是等价的。所以，每一些操作都可以对应成一组右端点单调不增的区间，而每一组这样的区间也可以对应到一些正确的操作。

因为右端点是单调递减的，所以第一个区间的右端点一定是右边第一个目标不为 $0$ 的数。因为若为 $0$，则该下标作为右端点时会减去 $1$，而因为右端点单调递减，所以左端点不可能为该下标。那么它就再也无法变回目标 $0$ 了。因为第一个操作十分特殊，所以我们可以强行让 $a_1$ 减一，然后 $a_{last}$ 加一。

现在我们可以考虑剩下的区间如何选择。我们从最终状态倒退回初始状态，不难得到有两种会使序列无法达到的情况：

* 左端点不够 对于一个 $a_i$ 小于 $0$ 的数，若它左边 $a_i$ 大于 $0$ 的数的和比它的绝对值小，那么将左边的数都变成小于等于 $0$ 的后，当前数还是小于 $0$ 的，那么此时永远也无法变回全都是 $0$ 的状态。

* 右端点不够 对于一个 $a_i$ 大于 $0$ 的数，若它右边 $a_i$ 小于 $0$ 的数的和的绝对值比它小，那么将右边的数都变成大于等于 $0$ 的后，当前数还是大于 $0$ 的，那么此时永远也无法变回全都是 $0$ 的状态。

这两种情况可以用前缀或后缀和是否大于等于 $0$ 来判断。于是，若上述错误都没发生，原序列一定有办法能够达成。

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int NN=2e5+4;
int a[NN];
int main()
{
	int t;
	scanf("%d",&t);
	while(t--)
	{
		int n,last=0;
		scanf("%d",&n);
		for(int i=1;i<=n;i++)
		{
			scanf("%d",&a[i]);
			if(a[i])
				last=i;
		}
		if(!last)
		{
			puts("Yes");
			continue;
		}
		a[1]--,a[last]++;
		long long res=0;
		for(int i=1;i<=n;i++)
		{
			res+=a[i];
			if(res<0)
				break;
		}
		if(res>0||res<0)
		{
			puts("No");
			continue;
		}
		for(int i=n;i;i--)
		{
			res+=a[i];
			if(res>0)
				break;
		}
		if(res>0)
			puts("No");
		else
			puts("Yes");
	}
	return 0;
}
```