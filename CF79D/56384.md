51nod上某题的弱化版中的弱化版

原题需要跑一般图最小权匹配这种十分不可写的东西……

不过这题因为就20个点，大力状压dp即可通过本题
_________________________

好了题目意思简单明了……给定一个初始状态全0的串然后可以对长度为一些特定值的区间进行01翻转操作，求将这个串变成给定的串至少需要几次操作

特殊限制是目标串当中最多有10个1

# 本题题解

那么我们来看，如果我们可以通过一通操作将原串翻转成目标串，那么我们将这些操作全部倒过来做就会把目标串翻转成一个全0串

所以问题变成了如何使用最少的操作次数将目标串变成全0的

那么我们发现我们唯一可以做到的操作就是区间取反这个操作

区间取反是等于区间异或上1的而区间异或上1相当于在模2剩余系下进行区间+

那么我们的目标是通过一系列区间+将这个目标串清0

区间加太麻烦了，我们考虑把区间加变成单点修改，发现好像的确可办到……，众所周知，区间加是等于在差分数组上进行两次单点修改的，所以我们把目标串在模2剩余系下差分一下，那么问题就变成了我们可以给间距为一些特定值的两个点进行翻转，求最小的翻转次数使得所有点都变成0，(因为差分全0的数组一定是全0数组，并且全0数组的差分数组都是全为0的)

那么这个问题该怎么求解呢？

这就是一个经典套路了，通过一系列骚操作把这个问题转化成一般图的最小权匹配问题

我们进行这样一个转化，如果我们可以通过一次操作将$(i,j)$翻转的话，我们就在$(i,j)$之间连上一条边，那么**同时翻转u,v而不影响其他点的状态**这个操作的代价就是$(u,v)$之间的最短路

证明非常简单，首先由于最短路径一定是一个简单路径，所以除了u，v之外这条路径上的点恰好有两条最短路上的边和它相连，换句话说这个点被翻转了两次，状态自然是不变的，而u和v恰好有一条边和他们相连，所以恰好被翻转了

那么现在我们就可以处理出所有1两两间的最短路，这题由于最多20个1并且边权全部是单位边权所以我们可以大力从每个起点开始bfs一发求出所有1之间的最短路

设第i个1和第j个1之间的最短路为$dis_{i,j}$那么我们可以发现最优的方案一定是把这些1一对一对的翻转然后消掉(因为借助别的1作为一个跳板进行翻转这种情况已经在最短路中被考虑过了)

也就是说，如果我们在$i,j$之间连一条长度为$dis_{i,j}$的边，来建一张新图的话，我们的最小代价就是这张图的**最小权完美匹配**，之所以强调是完美匹配是因为如果这张图不存在完美匹配的话，我们就无法通过翻转一堆点对的方式来完成将所有1消掉了(比如说奇数个点的话就一定没有完美匹配了)

当然这道题是没必要去写鬼畜的一般图最小权完美匹配了，因为我们发现最多有20个1

这就十分nice了，设$dp_{S}$表示将S这个集合消成0的最小消去步数，大力状压dp进行转移即可

最后一个问题，我们维护前向差分也好后向差分也罢，都会出现在处理前缀/后缀翻转的时候只是改变了一个差分点的辣手情况，解决这个问题也很简单，我们在序列的最前端/末尾补一个0点带着一起差分，这样的话差分数组的长度变成n+1，此时我们进行任意的翻转都是同时翻转两个点了，也就可以进行状压dp了

上代码~

```C
#include<cstdio>
#include<algorithm>
#include<queue>
using namespace std;const int N=1e4+10;const int P=1048576+10;const int Y=30;typedef long long ll;
int tr[N];int cnt;int cf[N];int a[N];int n;int m;int k;int cst[Y][Y];int d[N];int dp[P];queue <int> q;
inline void bfs(int s)//大力bfs求出最短路 
{
    for(int i=1;i<=n+1;i++)d[i]=0x3f3f3f3f;d[s]=0;int nw;int i=1;
    for(q.push(s);!q.empty();)
        for(nw=q.front(),q.pop(),i=1;i<=m;i++)
        {
            int v1=nw+a[i];if(v1<=n+1&&d[v1]==0x3f3f3f3f)d[v1]=d[nw]+1,q.push(v1);
            int v2=nw-a[i];if(v2>=1&&d[v2]==0x3f3f3f3f)d[v2]=d[nw]+1,q.push(v2);
        }
    for(int i=1;i<=n+1;i++)if(tr[i]!=-1)cst[tr[s]][tr[i]]=d[i];
}
int main()
{
    scanf("%d%d%d",&n,&k,&m);
    for(int i=1,t;i<=k;i++){scanf("%d",&t);cf[t]=1;}
    for(int i=1;i<=m;i++)scanf("%d",&a[i]);
    for(int i=n+1;i>=1;i--)cf[i]^=cf[i-1];cnt=-1;//求差分数组 
    for(int i=1;i<=n+1;i++)tr[i]=-1;
    for(int i=1;i<=n+1;i++)if(cf[i])tr[i]=++cnt;
    for(int i=1;i<=n+1;i++)if(cf[i])bfs(i);
    for(int i=1;i<(1<<(cnt+1));i++)dp[i]=0x3f3f3f3f;
    for(int i=0;i<(1<<(cnt+1));i++)//大力状压dp 
    {
        if(dp[i]==0x3f3f3f3f)continue;
        for(int j=0;j<=cnt;j++)
        {
            if((i>>j)&1)continue;
            for(int k=j+1;k<=cnt;k++)
                if(((i>>k)&1)==0)dp[i+(1<<j)+(1<<k)]=min(dp[i+(1<<j)+(1<<k)],dp[i]+cst[j][k]);
        }
    }int ans=dp[(1<<(cnt+1))-1];
    printf("%d",(ans==0x3f3f3f3f)?-1:ans);return 0;//拜拜程序~ 
}
```







