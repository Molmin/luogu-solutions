### 贪心题为什么没有人证明正确性呢？

这道题是一道贪心题，做法是先排序，再在目前的最大值和最小值中看能否匹配，能匹配就只需要$1$个盒子，否则需要$2$个，正确性证明如下：

对于目前最大值$a_x$，如果他和目前最小值无法匹配，那他和其他的物品更无法匹配，只能自己一组，而目前最小值可以和比目前最大值小的物品匹配，所以直到目前最大值能够和目前最小值匹配时，立即匹配，也就是我们上文提到的实现方法，证毕。

PS：题解区清一色的while循环，我偏要用for（逃）。

（细节注释见代码）。

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>//包含sort快速排序
using namespace std;
int a[100001];
int main()
{
	int n,c;
	scanf("%d%d",&n,&c);
	for (int i=1;i<=n;i++)
		scanf("%d",&a[i]);//输入不再解释
	sort(a+1,a+n+1);//排序，sort是左闭右开区间
	int ans=0;
	for (int l=1,r=n;l<=r;--r)//l<=r的时候继续循环，无论能否匹配，r都会自减，所以我放到了循环里
	{
		if	(a[l]+a[r]+1<=c)	++l;//能匹配则左指针+1
		++ans;//需要的盒子+1
	}
	printf("%d\n",ans);//输出答案，一定要换行
	return 0;
}
```