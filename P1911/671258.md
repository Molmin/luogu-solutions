[题目链接](https://www.luogu.com.cn/problem/P1911)

**思路：**

通过题目可以发现 $2^n\times2^n\bmod3=1$。

一个边长为 $2^n$ 的正方形可以分成四个长为 $2^{n-1}$ 的正方形。

但是其中只有一个正方形有军营，其他三个没有，那么就给它们设立一个。

方式如下，$X$ 表示军营。

```
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
0 0 X 0 0 0 0 0
0 0 0 0 0 0 0 0
```

设立三个后：

```
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 1 1 0 0 0
0 0 0 0 1 0 0 0
0 0 0 0 0 0 0 0
0 0 X 0 0 0 0 0
0 0 0 0 0 0 0 0
```

现在边长为 $8$，现在用递归进入下一层，处理边长为 $4$ 的。

```
0 0 0 0 0 0 0 0
0 2 2 0 0 3 3 0
0 2 0 0 0 0 3 0
0 0 0 1 1 0 0 0
0 0 0 0 1 0 0 0
0 5 5 0 0 0 4 0
0 5 X 0 0 4 4 0
0 0 0 0 0 0 0 0
```
最后是处理边长为 $2$ 的。

```
4 4 5 5 8 8 9 9
4 2 2 5 8 3 3 9
6 2 7 7 10 10 3 11
6 6 7 1 1 10 11 11
12 12 13 13 1 16 17 17
12 5 5 13 16 16 4 17
14 5 X 15 18 4 4 19
14 14 15 15 18 18 19 19
```

最后按照从小到大的顺序输出即可。

代码时间复杂度 $O(2^n\times2^n)$。
```cpp
#include<stdio.h>
int n,x,y,l,tot,ans[1050][1050],prt,k[1100000];
void dfs(int a,int b,int c,int d,int x,int y){
//正方形左上角是a行b列，右下角是c行d列,军营在x行y列
	int h=(a+c)/2,l=(b+d)/2;
	int p=(x>h)*2+(y>l);
//p记录军营在正方形的哪个位置
//0表示左上，1表示右上，2表示左下，3表示右下
	if(p==0) ans[h][l+1]=ans[h+1][l]=ans[h+1][l+1]=++tot;
	else if(p==1) ans[h][l]=ans[h+1][l]=ans[h+1][l+1]=++tot;
	else if(p==2) ans[h][l]=ans[h][l+1]=ans[h+1][l+1]=++tot;
	else ans[h][l]=ans[h+1][l]=ans[h][l+1]=++tot;
	if(c-a>=3){
		if(p==0) dfs(a,b,h,l,x,y);
		else dfs(a,b,h,l,h,l);
		if(p==1) dfs(a,l+1,h,d,x,y);
		else dfs(a,l+1,h,d,h,l+1);
		if(p==2) dfs(h+1,b,c,l,x,y);
		else dfs(h+1,b,c,l,h+1,l);
		if(p==3) dfs(h+1,l+1,c,d,x,y);
		else dfs(h+1,l+1,c,d,h+1,l+1);
	}
}
int main(){
	scanf("%d%d%d",&n,&x,&y);
	l=1<<n;
	dfs(1,1,l,l,x,y);
	for(int i=1;i<=l;i++){
		for(int j=1;j<=l;j++)
		if(ans[i][j]){
			if(!k[ans[i][j]])
				k[ans[i][j]]=++prt;
			printf("%d ",k[ans[i][j]]);
		}else printf("0 ");
		puts("");
	}
	return 0;
}
```