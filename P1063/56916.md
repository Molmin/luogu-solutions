**第三次交题解，希望能过**

本身蒟蒻一枚，刚学环状DP可能更能理解蒟蒻的感受

这道题和石子合并那道题差不多，典型环状DP

推环状DP，我觉得从区间DP入手更好推，推出区间的环状自然也就出来了

推区间DP我觉得就是一个以小见大，从刚好需要进行DP的小区间推，再转移到大区间

这道题我们可以从合并三个珠子开始推（也就是四个数）

开一个数组f[i][j]存储合并i，j珠子的最大值

**10①2②3③5**

如果我们合并①③的话，就有两个策略取值大的（也就是max）

**⑴先合①②再合③**

这样就是f[1][2]+10X3X5;

**⑵先合②③再合①**

这样就是f[2][3]+10X2X5;

那⑴来说，仔细看我们其实在写式子时，已经将f[3][3]当0来看忽略掉了，再把10X3X5换成更一般的就是a[1]Xa[3]Xa[4]（a数组存数）

所以仔细一想我们就高兴地推出了状态转移方程

**f[i][j]=max(f[i][j],f[i][k]+f[k+1][j]+a[i]Xa[k+1]Xa[j+1]);**（k为中转值）

再数值扩大一倍，就变成了环

C++AC代码如下
```
#include<bits/stdc++.h>//注意比赛不能用
using namespace std;
int f[201][201],n,a[202],ans;
int main(){
    cin>>n;
    for(int i=1;i<=n;i++) cin>>a[i],a[i+n]=a[i];
    for(int i=1;i<=n*2-1;i++) f[i][i+1]=a[i]*a[i+1]*a[i+2];//这里我们先把区间长度为2的值先算出来，因为他们不用DP
    for(int i=1;i<=n*2;i++) f[i][i]=0;//如果相同就是0
    for(int i=n*2-1;i>=1;i--){//DP过程
        for(int j=i+1;j<=n*2;j++){
            for(int k=i;k<j;k++){
                f[i][j]=max(f[i][j],f[i][k]+f[k+1][j]+a[i]*a[k+1]*a[j+1]);
            }
        }
    }
    for(int i=1;i<=n;i++) ans=max(ans,f[i][i+n-1]);//列举以每个为开头的情况（就是看环）
    cout<<ans;
    return 0;
}
```