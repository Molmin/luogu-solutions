引路双倍经验 [$\tt CF1119F$](/problem/CF1119F)，还有我那题的 [题解](https://www.luogu.com.cn/blog/368107/solution-cf1119f)。

---

考虑固定 $x$ 怎么做。我们树形 $\tt dp$，记

+ $f_{u,0}$ **删除 $u$ 到父亲的边**，让 $u$ 子树符合度数条件的最小代价
+ $f_{u,1}$ **保留 $u$ 到父亲的边**，让 $u$ 子树符合度数条件的最小代价
+ $d_u$ 为 $u$ 的度数，$u$ 点要删除的总边数是 $de_u-x(de_u\gt x)$。

然后对于若干个 $u$ 的儿子 $v$ 以及它们之间边权 $w$，每种都有

1. 删除 $u$ 到 $v$ 的边，代价 $f_{v,0}+w$（一类贡献 $a_1$）
2. 保留 $u$ 到 $v$ 的边，代价 $f_{v,1}$（二类贡献 $a_2$）

+ 对于 $f_{u,0}$ 的计算而言，需要至少删除 $de_u-x-1$ 条到儿子的边（在至少 $de_u-x-1$ 个儿子那里取 $a_1$，剩下儿子取 $a_2$）
+ 对于 $f_{u,1}$ 的计算而言，需要至少删除 $de_u-x$ 条到儿子的边（在至少 $de_u-x$ 个儿子那里取 $a_1$，剩下儿子取 $a_2$）

我们先假设全部取 $a_2$，然后在找出代价最小的某种方式，替换若干个 $a_2$ 为 $a_1$。

我们先计算出所有 $v$ 的 $a_2$ 的和，然后对于每个 $v$ 我们计算出 $a_1-a_2$ 的值，挑出最小的那些加上到这个和里面即可（注意 $a_1-a_2=f_{v,0}+w-f_{v,1}$）。

对于 $u$ 的 $\tt dfs$ 过程中，我们用堆维护出所有 $a_1-a_2$ 的值，然后从小往大加到 $a_2$ 的和里面（即完成了替换若干个 $a_2$ 为 $a_1$ 这步）。

总复杂度 $\mathcal O(n\log n)$。

---

现在考虑从小往大计算每一个 $x_0$ 怎么做。

我上面说树上 $\tt dfs$ 时要对每个点维护一个堆，但是那个堆是对每个点而言的，一旦这个点的计算结束之后，这个堆也就没用了。

如果我们是朴素的对每个 $x_0$ 都计算，总有某些信息会被重复计算，所以我们这里给每个点都维护堆，加上“从小往大枚举”这个条件，尝试让后来的计算可以利用以前算过的信息。

观察从小往大这个条件，如果一个 $u$ 有 $d_u\le x_0$，那在后续的 $x_0\sim n$ 的计算中，这个 $u$ 就没用了，因为它的度数已经满足条件了。而一个点 $u$ 只会有用 $d_u$ 次，而 $\sum d_u=O(n)$，所以我们对于每个 $x_0$ 都只计算当前有用的点，时间是可行的

我们以有用的点为根进行 $\tt dfs$，无用点视为叶子，虽然有若干个由有用点构成的子树共用一个叶子（无用点将会有多个父亲），但是无妨因为无用点根本不会处理，可以当作其不存在。

![](https://cdn.luogu.com.cn/upload/image_hosting/0wohinyb.png)

如图，$u$ 是无用点，$p,q$ 是两个有用点的子树，我们从 $p,q$ 中任意挑一个点开始 $\tt dfs$ 都可以把这个子树给 $\tt dfs$ 完一遍。因为无用点是叶子，此时它相邻的有用点（$p_3,q_2$）全都可以视为它父亲。

因为只会计算有用的点，所以一个点被标记无用之后，就应该处理它余留的贡献。由这个父子关系，它带给每个父亲的贡献是一个 $u$ 的 $a_1-a_2$ 的权。因为无用点没有子树，所以不删边没有子树代价（$a_2=0$），删边只会有删边自身的代价（$a_1=w$），这个权就等于 $w$，即这个点连向他父亲的边的权，我们把这个权放进它父亲的堆里就把这个点的余留贡献处理完了。

然后考虑这个 $\tt dfs$ 的过程。首先肯定要计算所有儿子 $a_2$ 的和，然后把 $a_1-a_2$ 的值放到堆里。堆里此时会有两类元素。

1. 无用点儿子带来的贡献（所有无用点儿子 $v_0$ 的 $w_0$ 值）这个东西在后面的计算中还有用，因为无用点儿子的父子关系是不会变的。
2. 有用点儿子带来的贡献（所有有用点儿子 $v_1$ 的 $a_1-a_2$ 权值）这个东西只在这轮计算中有用，因为下一轮又有些点会变得没用，有用点树形态发生改变。

我们可以考虑在这轮 $\tt dfs$ 完之后撤销堆中二类元素的加入。复杂度分析还是 $\sum d_u\log d_u=\mathcal O(n\log n)$。

在处理好堆中的东西之后，我们计算前若干小的元素之和，这个可以通过动态维护堆元素和，然后踢掉多余元素的方法解决。但是你踢掉的可能有不应该踢掉的一类元素，所以此时还需要撤销这些踢掉的操作。

总体而言就是需要一个可删除撤销删除，插入操作的堆。这个可以维护两个堆分别表示插入和删除，插入元素放插入堆删除元素放删除堆，求 `top` 需要先踢掉两个堆顶部的相同元素，复杂度可以均摊。

---

实现时很容易不小心让复杂度带上一个 $n^2$，也需要一些优化。

然后注意这个题是交互，点编号是 $0\sim n-1$，并且 $n$ 的范围小一点就行了。

[代码](https://www.luogu.com.cn/paste/q3d23958) 没有注释要的话可以去我原题题解看。