#### 既然这道题收在了「省选基础-打表」里，那么我就来写一个打表的做法。

对于这个数据范围 $ (n \leq 2×10^9) $ ，一次性肯定不能把表打出来。所以我们先打一部分进行尝试。先解决 $ (n \leq 5×10^8) $ 的情况。
~~本蒟蒻实在太菜所以打表的算法跑得不是很快。但还是可以在十分钟内跑出来的。~~

```cpp
#include<cstdio>
using namespace std;
short a[500000001];
int main()
{
	for(int i=1;i<=500000000;++i)
		for(int j=i;j<=500000000;j+=i)
			a[j]++;
	int maxn=0;
	for(int i=1;i<=500000000;++i) 
    	if(a[i]>maxn) {maxn=a[i];printf("%d,",i);}
	return 0;
}
```

当打出了 $ 0 $ 到 $ 5×10^8 $ 范围的表之后，我们可以发现打出来的数很少，也就是说此题可以通过打表解。然后，我们可以求出这次打表打出来的最后一个数的约数个数，于是我们可以知道，约数个数不会超过short的范围。

由于short最大可以开到5e8（本机），那么我们可以分四次将表打全。我们可以将上次打表所求出的最后一个数的约数个数作为此次打表的maxn。

这里提供第二次打表的代码：

```cpp
#include<cstdio>
using namespace std;
short a[500000001];
int main()
{
	for(int i=1;i<=1000000000;++i)
		for(int j=(500000000/i)*i+i;j<=1000000000;j+=i)
			a[j-500000000]++;
	short maxn=1152;
	for(int i=1;i<=500000000;++i) if(a[i]>maxn) {maxn=a[i];printf("%d,",i+500000000);}
	return 0;
}
```

于是，我们可以将四次打表的结果组合起来得到一个完整的表。

表打完后用二分或直接暴力找到第一个小于等于n的数即可。

```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
int a[100001]={1,2,4,6,12,24,36,48,60,120,180,240,360,720,840,1260,1680,2520,5040,7560,10080,15120,20160,25200,27720,45360,50400,55440,83160,110880,166320,221760,277200,332640,498960,554400,665280,720720,1081080,1441440,2162160,2882880,3603600,4324320,6486480,7207200,8648640,10810800,14414400,17297280,21621600,32432400,36756720,43243200,61261200,73513440,110270160,122522400,147026880,183783600,245044800,294053760,367567200,551350800,698377680,735134400,1102701600,1396755360,2000000001};
int main()
{
    int n;
    scanf("%d",&n);
    int num=lower_bound(a,a+68,n)-a-1;
    if(a[num+1]&&a[num+1]<=n) ++num;
    printf("%d",a[num]);
    return 0;
}
```