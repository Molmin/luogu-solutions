这道题实际上是求1~n中因数最多的数中最小的。

因为我们知道，任意一个大于1的整数都可以拆分成多个质数（或质数的幂）相乘

所以我们可以用前几个质数（10几个就够了【标签的打表题应该就是在这里打表了】）构建反素数。

为什么是十几个呢？我们看一下题目的数据范围，一个数N（1<=N<=2,000,000,000）。

【而前9个质数2\*3\*5\*7\*11\*13\*17\*19\*23\*29=6,469,693,230>2,000,000,000】所以实际上只需要前10个质数就可以啦

那么我们每个数S必然可以分解为S=2^x1+3^x2+...+p^xn(p仍旧为质数）

因数的总数cnt=(x1+1)\*(x2+1)\*(x3+1)\*……

我去网上找了个证明：http://blog.csdn.net/baidu\_36786519/article/details/53727982

我们需要构建其中因数最多的。因数最多的若有多个则取最小的其中一个并且输出。

但是x1,x2,x3这样的的数怎么枚举呢？

我们不难发现，x1,x2,x3是严格不上升的。为什么呢？

证明：若存在两个数，a^x1+b^x2,和a^x2+b^x1。a<b,x1>x2。两个数的因数个数相同，但是第一个比较小，所以选择第一个。

所以我们这题就大概这么结束了！

CODE:
```cpp
#include<bits/stdc++.h>
using namespace std;
int num[1000]={0,2,3,5,7,11,13,17,19,23,29,31,33};
long long i,j,n,ans,best;
void dfs (long long x,long long y,int z){
    if (x>best)    {
        best=x;
        ans=y;
    }
    if(x==best&&ans>y)ans=y;
    if(z>11)return; 
    for(int i=1;i<=50;i++){
        if(y*num[z]>n)break;
        dfs(x*(i+1),y*num[z],z+1);
        y*=num[z];
    }
}
int main(){
    scanf("%lld",&n);
    ans=10000000;
    dfs(1,1,1);
    printf("%lld",ans);
}
```