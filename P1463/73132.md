这个题硬确实不好做；
所以本人采用打表；
我具体说一下怎么打表；
首先，我们知道对于任意正整数N；
可以将N进行质因数分解（不知道的去百度）；
可以发现只需要10个质数就能把【1,2e10】的数全部质因数分解；
同时我们知道，N的因数个数就是每个质因数的次方+1后的累积；
那么我们去筛数的时候，只需要记录前面我们记录的最大的G（x），如何判断当前G(x)是否大于max（G(i)）;
若满足条件，就记录下来；
最后我们就会得到一张反素数表；
代码如下：
```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<cstring>
using namespace std;
int pnum[11]={2,3,5,7,11,13,17,19,23,27,29};
int maxx;
int cnt(int n,int k){
	int sum=0;
	if(k==11)return 1;
	while(n%pnum[k]==0){
		sum++;
		n/=pnum[k];
	}
	return (sum+1)*cnt(n,k+1);
}

int main(){
	for(register int i=1;i<=2100000000;i++){
		int now=cnt(i,0);
		if(maxx<now){
			maxx=now;
			printf("%d ",i);
		}
	}
	return 0;
}
```
然后输出就行；
```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<cstring>
using namespace std;
long long int ans[100]={1,2,4,6,12,24,36,48,60,120,180,240,360,720,840,1260,1680,2520,5040,7560,10080,
15120,20160,25200,27720,45360,50400,55440,83160,110880,166320,221760,277200,332640,
498960,554400,665280,720720,1081080,1441440,2162160,2882880,3603600,4324320,
6486480,7207200,8648640,10810800,14414400,17297280,21621600,32432400,36756720,
43243200,61261200,73513440,110270160,122522400,147026880,183783600,245044800,294053760,
367567200,551350800,698377680,735134400,1102701600,1396755360,2001000000};
long long int n;
int main(){
	scanf("%lld",&n);
	for(register int i=0;;i++){
		if(ans[i]>n){
			printf("%lld",ans[i-1]);
			return 0;
		}
	}
}
```
