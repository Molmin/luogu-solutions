因为 $K$ 很大，所以纯暴力会寄掉。

容易证明经过城镇的序列循环节长度不超过 $n$：若循环节长度超过 $n$，则一个循环节中经过一个城镇两次或以上，则下一个城镇也一样。这样一直推下去就会得到一个矛盾的结果。

从 $1$ 一直走下去，记录**每一次到达的城镇**和**每个城镇最后一次到达时间**。如果访问到一个之前走过的城镇，算出周期 $d$。设 $b_i$ 为传送 $i$ 次到达的城镇，则易得 $b_i=b_{i+d}=b_{i+2d}=\cdots=b_{i+jd}$（$j$ 为正整数）。

之后如果传送了 $x$ 次，满足 $x\equiv K(\bmod\space d)$，则 $b_x=b_K$，输出 $b_x$ 即可。

- 如果 $K$ 比较小，没出现循环节时就走了 $K$ 次，则可以直接输出 $b_K$。

代码如下，比较简洁：

```cpp
const int N=4e5+10;
int n,m,a[N],vis[N],b[N],len,d;
void solve()
{
	n=read(),m=read();
	for(int i=1;i<=n;i++)
		a[i]=read();
	for(int i=0,j=1;;i++,j=a[j])
	{
		if(i==m||d&&i%d==m%d)
			write(j),exit(0);
		if(vis[j])
			d=i-vis[j];
		vis[j]=i,b[len++]=j;
	}
}


```