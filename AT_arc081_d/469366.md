这道题其实就是一个普通的悬线法：通过若干次操作后找出最大全$1$矩阵，关键在于如何确定障碍点和非障碍点。

观察一下样例一

可以画出下面这个图

![](https://cdn.luogu.com.cn/upload/image_hosting/63rg72ls.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

看左上角那个$2×2$的矩阵，我们可以通过反转第一行来使它变成一个全$1$矩阵。

而对于左下角那个$2×2$的矩阵的矩阵而言，可以发现无论做多少次操作它都无法变成一个全$1$矩阵。

通过对比发现：左上角那个$2×2$的矩阵可以变成一个全$1$矩阵是因为它有偶数个$1$，而左下角那个$2×2$的矩阵的矩阵无法变成一个全$1$矩阵是因为它有奇数个$1$。

所以可以得出结论：

**对于有偶数个1的矩阵，
可以通过若干次操作后使它变成一个全1矩阵，
反之则不能。**

------------

 _在这里声明一下：下文提到的 “全 $1$矩阵 ”是指可以通过若干次操作后变成全 $1$矩阵的矩阵（即有偶数个1的矩阵），它在操作之前不一定是全 $1$矩阵_

------------

因为所有的大矩形都是由若干个$2×2$矩阵组成的，所以一个矩阵里要全部是全$1$矩阵，那么这个矩阵必定也是一个全$1$矩阵；同理，如果一个矩阵里包含了非全$1$矩阵，那么这个矩阵一定不是全$1$矩阵。

我们可以把所有的$2×2$矩阵看成点，有偶数个$1$的$2×2$矩阵标记为$1$，就是非障碍点，反之为$0$，就是障碍点。

这样我们就确定了障碍点和非障碍点，就可以通过枚举所有的极大子矩阵（即所有全$1$矩阵），来找出最大子矩阵。

特别地，对于样例二，我们可以把所有的点转化为$1$，所以整个大矩阵就是一个全$1$矩阵，面积为$16$。

------------

至于悬线法，
[戳这里](https://oi-wiki.org/misc/hoverline/)

（这是oi wiki里的一篇文章，本人当时就是看这篇文章学习的悬线法 ^_^）



------------

Code
```cpp
#include "iostream"
#include "cstdio"

#define N 2005

using namespace std;

int n,m,ans;
int l[N][N],r[N][N],up[N][N];
bool a[N][N];

int main()
{
	scanf("%d%d",&n,&m);
	ans=max(n,m);
	for(int i=1;i<=n;i++)
	{
	    for(int j=1;j<=m;j++)
	    {
	    	char c;
	    	cin>>c;
	    	if(c=='#')
	    		a[i][j]=true;
	    }
	}
	n--;m--;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
		{
	    	a[i][j]=!((a[i][j]+a[i+1][j]+a[i][j+1]+a[i+1][j+1])&1);
	    	l[i][j]=r[i][j]=j;
	    }
	for(int i=1;i<=n;i++)
		for(int j=2;j<=m;j++)
	    	if(a[i][j]&&a[i][j-1])
				l[i][j]=l[i][j-1];
	for(int i=1;i<=n;i++)
	    for(int j=m-1;j;j--)
	    	if(a[i][j]&&a[i][j+1])
	        	r[i][j]=r[i][j+1];
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			if(a[i][j])
				up[i][j]=up[i-1][j]+1;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
		{
			if(a[i][j]&&a[i-1][j])
			{
	    		l[i][j]=max(l[i][j],l[i-1][j]);
	         	r[i][j]=min(r[i][j],r[i-1][j]);
	       	}
	       	ans=max(ans,(r[i][j]-l[i][j]+2)*(up[i][j]+1));
		}
	printf("%d\n",ans);
	return 0;
}
```

------------

蒟蒻的第一篇题解，刚交的时候没有过……原因是不够详细。

现在改了改，希望内容质量能有所提升~