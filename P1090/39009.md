emmm.....某谷最弱的蒟蒻的第一篇题解.....
首先，我们来看一下题。关于这道题，我不会各位大佬们说的桶排，也不会什么乱七八糟的神奇操作。(~~还不是我太弱了~~)      
我想了想，其实这道题吧，用优先队列就好了，stl可以帮我们解决这个问题，但是，stl里面默认的是队首是最大的元素，如果不加处理的话，会导致算的结果与题目要求完全相反，所以，我们可以先取反，然后加入，取出的时候再取反一遍，就成了原来的元素，而且队列变成了队首是最小元素（取反之后）    
为什么呢？？             
因为我们可以求证的；   
首先，假设有三个堆，代价为a，b，c；    
设a>b>c;
如果直接从a到b再到c合并，其代价为   
(a+b)+[(a+b)+c]=2a+2b+c；   
如果，我们先合并b和c，其代价为   
(b+c)+[(b+c)+a]=2b+2c+a;   
我们发现，上面的式子是大于下面的式子的；   
多举几个例子也无妨。   
然后我们证得，每次合并当前最小的两堆，直到合并完毕，就是我们的问题所求解。   
然后。。。。
把队头取出，弹掉，然后再取一个，弹掉，再加入一个。
emmm....(~~我就是这么弱啊。。。~~)
话不多说，上代码（~~个人认为简单易懂~~）
```
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cmath>
#include<queue>
using namespace std;
priority_queue<int >q;//优先队列
int main () {
    int n,ans=0,t;
    scanf("%d",&n);
    for(int i=1;i<=n;i++){
        scanf("%d",&t);
        q.push(-t);//取反读入
    }
    while(n!=1){//只有一堆时，即全部合并完毕
        int o=0,s=0,he;//he是表示当前合并两个堆所需代价
        o=q.top();
        q.pop();
        n--;//合并一次总堆数减一
        s=q.top();
        q.pop();
        he=-o-s;
        q.push(-he);//取反压入
        ans+=he;
    }
    cout<<ans;
}
```