这道题只需要把最小的两个果堆加起来就可以了，好多大佬都用的是优先队列，但由于本人太菜，只好用数组做。

如果这样想，那么每合并一次都需要排一次序，但事实上并不需要这么做（而且这样会超时，我之前用sort函数排就过了四个点，后面全都tle了），只需要给新合并的果堆找到所在的位置，并且将空的果堆删除就可以了。

下面AC代码。

    
    
    
        

```cpp
     #include<bits/stdc++.h>//（万能库）
    using namespace std;
    int a[100000];//(用一个数组来代替队列)
    int main(){
    int n,sum=0;
    cin>>n;
    for(int i=1;i<=n;i++)
    {
        cin>>a[i];//（读入数据）
    }
    sort(a+1,a+n+1);//（初始排序）
    while(1){//（开始合并循环，其实可以用for代替）
        int j=1;
        while(a[j]==0)
        j++;
        //（其实这里懒了，当时做的时候用的是sort,可以用别的做法）
        if(j==n) break;//（此时只存在一个堆，退出循环）
        else {
            a[j]+=a[j+1];
            sum+=a[j];//（i和j 合并成一个果堆，增加所用的力气）
            for(int l=j+1;l<n;l++)
             {
                a[l]=a[l+1];//（将j后面的果堆向前一位）
            }
            n--;//（减少一个堆）
        }
        for(int l=j;l<n;l++)
        {
            if(a[l]>a[l+1])//（为新的堆找到位置）
            {
                swap(a[l],a[l+1]);
            }
        }
    }
    cout<<sum;//（输出力气）
    return 0;//（功德圆满）
    }
如有需要改进的地方，还请各位大佬提出建议。
```