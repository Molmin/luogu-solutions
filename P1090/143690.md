# 一道带有旷古之思的题啊！

## 我是真的被这个题给坑了！

### 但是一旦想明白了又发现很简单！

------------------------------------------------------------------------------------------------(**进入正题**）

**看到了很多用堆啊，或用优先队列啊的大佬。**

还有很多用排序，~~但是根本不测试就往上发那种一定会TLE代码的沙雕~~

然而无论怎样，他们的效率大概都在一个点十几毫秒

我就不一样了，我的效率能达到一个点几毫秒！！！

首先我们要知道，合并一下，排一下序是一定会TLE的  
而且卡死你，就算你用sort,也只能过4个点（我就这么被坑的）  
然而如果我们控制一下，用四指针去控制原始数列和合并后的数列  
那么我们只需要在一开始排一下序就行了  
我个人用的是经典二分快排!当然你其实在这里用一下sort是没有问题的  
只不过我为了提高代码效率。

首先给你们看一下主函数！

```
int main()//我知道你们单独看主函数是看不懂的！！
{
    read();
    quick(1,n);
    print();
    return 0;
}
```
是不是一脸懵逼呢（要的就是这个效果）

我解释一下啊！！稍微有点英语底子的人啊，都能看懂read是读入函数！quick是快排！print是输出！

给你们看一下头文件和函数定义！
```
#include <iostream>
#include <cstdio>

using namespace std;
void read();//读入函数
void quick(int c,int b);//排序函数
int sum();//判定and合并函数
void print();//输出函数
int n,a[10002];//其实也可以双数组（QAQ）
```
我在这里用了单个数组，我写起来使用了四指针，其实也可以分开看，会更容易懂！

## 我的注释超好看！所以你会懂的！

快排代码！见下！
```
void quick(int c,int b)//写了一个简单的快排！
{
    int f,e,k;//三个变量疯狂互换
    if (c==b)return;//正常快排的判定！如果前后指针重叠，跳出！
    f=c;//记录一下变量
    e=b;
    k=a[c];//定义一下中值
    while (f!=e)//两个数不是一个数时！！
    {
        while ((a[e]>=k)&&(e>f))e--;//后面大于中值且两个的下标也是后面大于中值时我们就直接再往前串一个继续搜！
        if (a[e]<k)//诶，当后面小于中值时！
        {
            a[f++]=a[e];//先把头换一下，再往后串一下！
            while((a[f]<k)&&(f<e))f++;//从头搜一下要是一直小于中值就非常棒棒，就一直搜下去直到找到大于中值的！！
            if(a[f]>=k)//等我搜到大于中值的时候！嘿嘿嘿！
            {
                a[e--]=a[f];//我就再把头换过去！！
            }
        }

    }
    a[f]=k;//然后我再定义一下中值
    if (f-c>1) quick(c,f-1);//疯狂二分递归前半部分！
    if (b-f>1) quick(f+1,b);//疯狂二分递归后半部分！
    return;
}
```
这就是个简单的，普通的快排！！

比较难理解的是下面这个合并和指针控制的函数！能不能懂就看造化了。我为了让你们懂我还是写了挺多的！

合并函数！见下！
```
int sum()//合并部分！！我自己看的都头晕争取让大家看懂！！
{
    int Af,Ae,Bf=1,Be,sum=0;//Af，Ae是初始队列的头,尾。Bf，Be是合并后队列的头和尾
/*就是因为这个部分，所以我说了可以用两个队列（数组），一个存合并，一个存初始，然后疯狂删减，但是要注意的是
初始队列是在不停删，合并队列却在不停加，要注意好控制两个指针的位置，并且要关注，初始队列是可能被清空的，清
即跳出*/
    if (n==1)return a[1];//其实一堆的话我不费力气的，但是我要以第一堆为基础！！他也肯定不会只给我一堆的对吧！
    a[1]=a[1]+a[2];//合并，第一堆等于前两堆之和！
    Af=3;//前两堆已经合并了，我让他从第三个开始！
    Ae=n;//然后在第n个结束！
    Bf=1;//合并队列现在什么都没有所以开始和结束都在“1”的位置上！
    Be=1;
    sum+=a[Be];//记录力气！
    while(Bf<n-1)
    {
        if((a[Af]<=a[Bf])&&(Af<=Ae))//我把合并后的这个值就直接记录一下，如果这个队列后面的值小于这两个值合并后的值！！
        {
            if ((a[Af+1]<a[Bf])&&(Af+1<=Ae))//如果后两个值都小于这个值，那么！！
            {
                a[++Be]=a[Af]+a[Af+1];//我下一步一定是让后两个值加在一起
                sum+=a[Be];//并且把两个值也都存起来
                Af=Af+2;//直接跳过这两个值再继续搜
            }
            else
            {
                a[++Be]=a[Af]+a[Bf];//如果只有后面的一个值小于合并后的这个值
                sum+=a[Be];//那么我就应该让合并后的值和后面的那个值加一起！！
                Af++;//然后初始数列没了一个值！
                Bf++;//合并后的数列也没了一个值!
            }
        }
        else//如果后面那个数比我大！！
        {
            if (((a[Af]<a[Bf+1])&&(Bf+1<=Be)&&(Af<=Ae))||((Bf==Be)&&(Af<=Ae)))//如果后面那个数只是比我合并完的其中一个数大！！
            {
                a[++Be]=a[Af]+a[Bf];//我就合并这个小于他数的和后面的值，
                sum+=a[Be];
                Af++;
                Bf++;
            }
            else//如果他大于两个合并后的值!!
            {
                a[++Be]=a[Bf]+a[Bf+1];//那我就合并这两个我合并后的值！！
                sum+=a[Be];
                Bf=Bf+2;//要注意因为合并了两个合并后的值！所以要+2！
            }
        }
    }
    return sum;//把力气输出来！！
}
```
正因为控制起来不容易，所以效率超级高！比一般的优先队列，或者是用堆！

下面就比较简单了！

输出函数！见下！
```
void print()//看这个你们也看不懂的！！输出的是直接合并完并且排完顺序的！！
{
    printf("%d\n",sum());
    return;
}
```
这个还是比较好理解的哈！

这个的效率真的超高！

还有啊，我跟你们说，其实这种代码是基础，不要沉迷于STL，STL固然好，但是只会STL是不可能的！

完整代码见下!
```
#include <iostream>
#include <cstdio>

using namespace std;

void read();
void quick(int c,int b);
int sum();
void print();
int n,a[10002];
int main(){
    int i;
    read();
    quick(1,n);
    print();
    return 0;
}
void read(){
    int i;
    scanf("%d",&n);
    for (i=1;i<=n;i++){
        scanf("%d",&a[i]);
    }
    return; 
}
void print(){
    printf("%d\n",sum());
    return;
}
void quick(int c,int b){
    int f,e,k;
    if (c==b)return;
    f=c;
    e=b;
    k=a[c];
    while (f!=e){
        while ((a[e]>=k)&&(e>f))e--;
        if (a[e]<k){
            a[f++]=a[e];
            while((a[f]<k)&&(f<e))f++;
            if(a[f]>=k){
                a[e--]=a[f];
            }
        }
    }
    a[f]=k;
    if (f-c>1) quick(c,f-1);
    if (b-f>1) quick(f+1,b);
    return;
}
int sum(){
    int Af,Ae,Bf=1,Be,i,sum=0;
    if (n==1)return a[1];
    a[1]=a[1]+a[2];
    Af=3;
    Ae=n;
    Bf=1;
    Be=1;
    sum+=a[Be]; 
    while(Bf<n-1){
        if((a[Af]<=a[Bf])&&(Af<=Ae)){
            if ((a[Af+1]<a[Bf])&&(Af+1<=Ae)){
                a[++Be]=a[Af]+a[Af+1];
                sum+=a[Be];
                Af=Af+2;
            }
            else {
                a[++Be]=a[Af]+a[Bf];
                sum+=a[Be]; 
                Af++;
                Bf++;   
            }
        }
        else {
            if (((a[Af]<a[Bf+1])&&(Bf+1<=Be)&&(Af<=Ae))||((Bf==Be)&&(Af<=Ae))){
                a[++Be]=a[Af]+a[Bf];
                sum+=a[Be];     
                Af++;
                Bf++;
            }
            else {
                a[++Be]=a[Bf]+a[Bf+1];
                sum+=a[Be]; 
                Bf=Bf+2;    
            }
        }
    }
    return sum;
}
```
本人是一个蒟蒻！

虽然不是第一次发题解，但是！

是第一次写这么全的注释，所以！

请给个赞！或者你还可以！emm

给我发个私信，这样我们以后还！

可以一起探讨问题！交流编程！

超级喜欢交朋友！