## 思路
$$\texttt{Solution 1}$$
$$O(n^2)$$

首先，我们可以进行**枚举**。考虑进行 DFS，对于每个节点，枚举左边和右边最多能到达哪里，这是深搜的模板题。

对于每个节点的枚举是 $O(n)$ 的效率，一共有 $n$ 个节点，故时间复杂度 $O(n^2)$。可以通过 $n\le 1000$ 的数据点。

但是，有没有更优秀的算法呢？

$$\texttt{Solution 2}$$
$$O(n)$$

想一想，优化时间的一个常见方法是**用空间换时间**。显然第一种除了初始数组，空间复杂度为 $O(1)$。所以我们考虑**动态规划**。

对于每个节点，设它左边能浇灌的最远节点与其的距离为 $f_i$，右边则为 $g_i$。那么最终的答案就是 $\text{max}\{f_i+g_i\}+1$。

那么 $f_i$ 怎么求呢？如果 $a_i\ge a_{i-1}$，那么 $f_i=f_{i-1}+1$；否则，$f_i=0$。

综上，我们用 $O(n)$ 的效率处理了 $f$ 数组，同理可以处理 $g$ 数组，然后统计答案的复杂度 $O(n)$，所以总体时间复杂度是 $O(n)$，非常优秀！

有没有更优化的算法呢？即使有，也没有必要研究了，因为单单是输入就已经耗费 $O(n)$ 的时间复杂度了。

## 代码

下面给出 $\texttt{Solution 2}$ 的代码。
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1005;
int n;
int a[N];
int f[N],g[N];
int ans=0;
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++) scanf("%d",&a[i]);
	f[1]=0;//因为没有定义 a0，所以要初始化f1。
	for(int i=2;i<=n;i++){
		if(a[i]>=a[i-1]) f[i]=f[i-1]+1;
		else f[i]=0;
	}
	g[n]=0;//同理，g数组的处理方式相反
	for(int i=n-1;i>=1;i--){
		if(a[i]>=a[i+1]) g[i]=g[i+1]+1;
		else g[i]=0;
	}
	for(int i=1;i<=n;i++) ans=max(ans,f[i]+g[i]);
    //统计答案
	printf("%d\n",ans+1);
    return 0;//点个赞再走呀~
}
```