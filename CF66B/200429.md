这道题可以枚举每一块地方，再从这个位置向左右两边延伸，直到不能再往下流为止，这样每次延伸的时间复杂度最多会到$O(n)$，总的时间复杂度最多就是$O(n^2)$。

可以先进行预处理，计算出这个位置往左最多能流多少个，往右最多能流多少个。

计算这个位置往左最多能流多少个，就从头开始计算，如果能流到前一个位置，就是前一个位置往左最多能流的个数加一，流不到就是0个。

再计算这个位置往右最多能流多少个，就从头开始计算，如果能流到后一个位置，就是后一个位置往右最多能流的个数加一，流不到就是0个。

然后再打擂台，每个位置能流到的就是往左加上往右的，比较出最多能流到的，时间复杂度就是$O(n)$。

代码：
```cpp
#include<bits/stdc++.h> //头文件
using namespace std;
inline int read() //快读
{
   int s=0,w=1;
   char ch=getchar();
   while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
   while(ch>='0'&&ch<='9') s=s*10+ch-'0',ch=getchar();
   return s*w;
}
int a[1005],l[1005],r[1005]; //定义数组，l表示这个位置往左最多能流多少个,r表示这个位置往右最多能流多少个。
int main()
{
    int n,s=0;
    n=read(); //输入
    for(register int i=1;i<=n;i++)
    	a[i]=read();
    l[1]=0; //第一个位置往左没有了，所以往左最多能流0个
	for(register int i=2;i<=n;i++)
		if(a[i-1]<=a[i]) //比较能否流到前一个
			l[i]=l[i-1]+1; //如果能流到前一个位置，就是前一个位置往左最多能流的个数加一，流不到就是0个（数组初始就是0）
	r[n]=0; //和第一个位置一样，最后一个位置往右也最多能流0个
	for(register int i=n-1;i>=1;i--)
		if(a[i+1]<=a[i]) //比较能否流到后一个
			r[i]=r[i+1]+1; //如果能流到后一个位置，就是后一个位置往右最多能流的个数加一，流不到就是0个
	for(register int i=1;i<=n;i++) //打擂台
		s=max(s,l[i]+r[i]+1); //比较
	cout<<s<<endl; //输出
    return 0;
}
```
