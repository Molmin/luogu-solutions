本蒟蒻一看到题目就立刻开始写程序——非常地简短：

```cpp
#include<cstdio>
long long x,i;
int main()
{
    scanf("%lld",&x);//输入
    for(;;i++)if((1<<i)>x)break;//1<<a等同于2的a次方，这里判断幂是否超过输入的数
    printf("%lld",x-(1<<(i-1))+1);//输出最终答案
}
```

本蒟蒻信心满满地交付了评测：[传送门](/record/32875429)。

因此我们必须要重新改变算法。由于样例输入输出永远是最简单的情况，所以我们必定要好好地理解题目——不一定要在最后加，可以一边加，一边分解。本蒟蒻也就是在这里没有考虑到。

最容易想到的思路就是——一边除以$2$，一边对余数为$1$的情况加$1$，即：

```cpp
#include<cstdio>
int x,n;
int main()
{
    scanf("%d",&x);
    while(x)
    {
        n+=x&1;//a&1等同于a%2
        x>>=1;//a>>=1等同于a/=2
    }
    printf("%d",n);
}
```

当然，我们仔细分析一下，可以发现，最终答案为这个输入的数在二进制下$1$的个数，即：

```cpp
#include<cstdio>
int x,n;
int main()
{
    scanf("%d",&x);
    while(x)
    {
        x-=x&-x;//二进制表达式中最低位的1所对应的值
        n++;//计数器加1
    }
    printf("%d",n);
}
```

不过，还是第二份代码的效率更高一些，其实后两份的算法类似。