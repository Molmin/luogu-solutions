## 题目描述

[题目传送门](https://www.luogu.com.cn/problem/P4516)
## 思路简述

~~题解区感觉好像没有我这么复杂而垃圾的做法。~~

显然是树形 dp。

不妨设 $f[i][j][z][0-3]$ 分别表示结点 $i$ 访问到第 $j$ 个孩子，放置了 $z$ 个监听设备，状态为 $0$ 到 $3$ 的方案数。

这里我们规定：
+ $0$ 表示没被上面的点监视且不放置监听设备。
+ $1$ 表示没被上面的点监视且放置监听设备。
+ $2$ 表示被上面的点监视且不放置监听设备。
+ $3$ 表示被上面的点监视且放置监听设备。
+ 当然可以简单理解为**当前状态可以使用 $2\times [\texttt{上面的点是否放了监听设备}]+[\texttt{当前点是否放了监听设备}]$ 表示。**（这里可能文字表述更为清楚）

### 情况1

如果一个点没被上面的点监视，且当前这个点没有/有放置监听设备

那么可以这么思考，一个点可以放置或不放置监听设备，但他一定得有一个儿子放置监听设备。

对于它的一个孩子 $v$ ， 就有 $2$ 种可能：

1. 之前的所有孩子都没有放置监视点，那么它可以选择放置监听设备。
1. 之前的孩子中有放置监视点，那么它放置或不放置监听设备都可。

容易想到还需要维护一个 $g[i][0-1][j]$ 表示访问到第 $i$ 个孩子，此时父结点不放置/放置监听设备，且一共放置了 $j$ 个监听设备，同时孩子都没有放置监听设备的方案数。

### 情况2

如果一个点被上面的点监视，且当前这个点没有/有放置监听设备。

直接更新即可。

---

综上，状态转移方程易得：
+ $t \in [0,1]$，$v$ 表示 $i$ 的第 $j$ 个孩子
+ $sz[i][j]$ 表示节点 $i$ 遍历到第 $j$ 个儿子所统计的子树大小。
+ $cnt[i]$ 表示节点 $i$ 的儿子个数。
+ 钦定当前子树根节点是 $u$。
+ $f[u][j][z][t]=\sum_{l=\max(0,z-sz[u][j]+sz[v][cnt[v]])}^{\min(z-t,sz[v][cnt[v]])} f[u][j-1][z-l][t+2]
\times (f[v][cnt[v]][j][1|(t\times 2)]
+f[v][cnt[v]][l][t\times 2]) $ 。
+ $f[u][j][z][t]=\sum_{l=\min(i-t,sz[v][cnt[v])}^{\max(0,i-sz[u][j]+sz[v][cnt[v]])}
f[u][j-1][z-l][t]
\times (f[v][cnt[v]][l][1+t\times 2]+f[v][cnt[v]][l][t\times 2])+g[t][i-j] \times f[v][cnt[v]][j][1+t\times 2]$。
+ $g[i][t][j]=\sum_{l=\min(i-t,sz[v][cnt[v]])}^{\max(0,j-sz[u][i]+sz[v][cnt[v]])}g[i-1][t][j-l]\times f[v][cnt[v]][l][t\times 2]$。

初始化：

$f[u][0][1][3]=f[u][0][0][2]=1$，$g[0][1][1]=g[0][1][1]=1$，其余皆为 $0$ 。

想必上面的状态转移方程有点恶心，然而枚举是第几个儿子的这一维是可以用滚动数组优化掉的。

## 丑陋の代码
[click here](https://www.luogu.com.cn/paste/n0iu2bqe)