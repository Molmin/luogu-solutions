## $\texttt{Content}$

给一棵 $n$ 个点的树，试选取 $k$ 个点，使得树中的每一个点都至少与该 $k$ 个点中的一个点直接相连。( $k$ 个点中的点不与自身相连 ）

$n \le 10^5,k\le 100$

## $\texttt{Solution}$

可以发现这是一个树形 dp。

**设计状态**：

我一开始想的是设 $f_{0/1,u,i}$ 表示以 $u$ 为根的子树中有 $i$ 个被选取的点，$0/1$ 表示 $u$ 是否选取。

但是后来发现这样设计是不对的。因为这样在转移的过程中会出现后效性。

即我在以 $u$ 为根的子树中选取的点会对我接下来的递推产生影响。

所以说考虑进一步设计状态。一般来说，对于有后效性的一些 dp，我们可以通过增加状态的方式来把后效性干掉。

于是考虑增设一维 $0/1$ 表示点 $u$ 是否被覆盖到。

于是状态 $f_{0/1,0/1,u,i}$ 表示以 $u$ 为根的子树中有 $i$ 个被选取的点，第一个$0/1$ 表示 $u$ 是否选取，第二个 $0/1$ 表示 $u$ 是否被覆盖。

**状态转移**：

在设计出状态以后，转移方程就很好推了。

只需分类讨论即可。

- 当 $u$ 没有被选取，且没有被覆盖。

则

$f_{0,0,u,i+j} =  \sum \limits_{i=0}^k(f_{0,0,u,i} \times f_{0,1,v,j})$

- 当 $u$ 没有被选取，但被覆盖了。

则

$f_{0,1,u,i+j} = \sum \limits_{i=0}^k(f_{0,1,u,i } \times(f_{1,1,v,j} + f_{0,1,v,j}) + f_{0,0,u,i} \times f_{1,1,v,j}) $

- 当 $u$ 被选取，但没有被覆盖。

则

$f_{1,0,u,i+j} = \sum\limits_{i=0}^k(f_{1,0,u,i} \times (f_{0,1,v,j} + f_{0,0,v,j}))$

- 当 $u$ 被选取，且被覆盖。

则

$f_{1,1,u,i+j} =  \sum\limits_{i=0}^k(f_{1,1,u,i} \times (f_{1,1,v,j} + f_{0,1,v,j} + f_{1,0,v,j} + f_{0,0,v,j}) + f_{1,0,u,i}\times (f_{1,1,v,j} + f_{1,0,v,j}))$

## $\texttt{Code}$
```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 1e5+5, P = 1e9+7;
int n, k;
vector<int> g[N];
int f[2][2][N][101], siz[N], cmp[101][2][2];

//作树上 dp
void dfs(int u, int fa) {
	siz[u] = f[0][0][u][0] = f[1][0][u][1] = 1;
	for(int i = 0;i < g[u].size();i ++) {
		int j = g[u][i];
		if(j == fa) continue;
		dfs(j, u);
		for(int k1 = 0;k1 <= min(k, siz[u]);k1 ++) {
        		//防止在更新过程中多次更新(01背包)
			cmp[k1][0][0] = f[0][0][u][k1];
			f[0][0][u][k1] = 0;
           		cmp[k1][0][1] = f[0][1][u][k1]; 
			f[0][1][u][k1] = 0;
            		cmp[k1][1][0] = f[1][0][u][k1]; 
			f[1][0][u][k1] = 0;
            		cmp[k1][1][1] = f[1][1][u][k1]; 
			f[1][1][u][k1] = 0;
		}
        	//dp过程
		for(int k1 = 0;k1 <= k && k1 <= siz[u];k1 ++) {
			for(int k2 = 0;k2 + k1 <= k && k2 <= siz[j];k2 ++) {
				f[0][0][u][k1+k2] = (1ll * f[0][0][u][k1+k2] + 1ll * cmp[k1][0][0] * f[0][1][j][k2]) % P;
				f[1][0][u][k1+k2] = ((1ll * f[0][1][j][k2] + 1ll * f[0][0][j][k2]) % P * 1ll * cmp[k1][1][0] % P + 1ll * f[1][0][u][k1+k2]) % P;
				f[0][1][u][k1+k2] = (((1ll * f[1][1][j][k2] + f[0][1][j][k2]) % P * 1ll * cmp[k1][0][1]) % P  + 1ll * f[0][1][u][k1+k2] + 1ll * cmp[k1][0][0] * f[1][1][j][k2] % P) % P;
				f[1][1][u][k1+k2] = (1ll * f[1][1][u][k1+k2] + (1ll * f[1][1][j][k2] + f[0][1][j][k2] + f[1][0][j][k2] + f[0][0][j][k2]) % P * 1ll * cmp[k1][1][1] % P + cmp[k1][1][0] * (1ll * f[1][1][j][k2] + f[1][0][j][k2]) % P) % P;
			}
		}
		siz[u] += siz[j];
	}
}

int main() {
	cin >> n >> k;
	for(int i = 1, a, b;i < n;i ++) {
		cin >> a >> b;
		g[a].push_back(b), g[b].push_back(a);
	}
	dfs(1, 0);
	//输出时,有两种可能的方案
	cout << (1ll * f[1][1][1][k] + f[0][1][1][k]) % P;
	return 0;
} 
```
