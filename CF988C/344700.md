## 题目翻译

时间限制 $ 2s $​   |   空间限制 $ 256\text{MB} $​​



#### 题目描述：

在 $n$ 个长度不一定相同的序列中任选两个序列，两个序列都删去他们中的一个数，使得这两个序列的和相同。



#### 输入格式：

第一行一个整数 $k$ ( $2 \le k \le 2 \cdot 10^5$​​ )。

接下来有 $k$ 组数据。

对于第 $i$​​ 组数据第一行是一个整数 $n_i$​​ （ $1 \le n_i \le 2 \cdot 10^5$​​ ），表示这个序列有 $n_i$​​ 个数。第二行则是 $n_i$​​ 个数 $a_{i,1}, a_{i,2}, \dots, a_{i,n_i}$​ ，表示这个序列。对于每一个 $a$​ 保证其都在闭区间 $[-10^4, 10^4]$​ 内，并且每个序列的和都不超过 $2\cdot 10^5$​​ ，$n_1, n_2, n_3, \dots, n_k \le 2\cdot 10^5$​ 。

#### 输出格式：

第一行输出 `YES` 或 `NO` 表示 **有解** / **无解** 。

对于 `YES` 的情况，接下来两行分别输出 **序列号  位置** ，位置从1开始，表示要删除的数。

对于 `NO` 的情况，输出文件无其余内容。




#### 样例解释：

样例一：

选取 $[2,3,1,3,2]$​ （序列 **1** ） 和 $[1,1,2,2,2,1]$​ （序列 **2**）。 可以通过删除第一个序列的第 **二** 个元素得到 $[2,1,3,2]$​ 并且通过删除第二个序列的第 **六** 个元素得到 $[1,1,2,2,2]$​ . 这样两个序列的和就都变为 $8$​​​ 了，符合题意​。

样例二：

无解。

样例三：

选取 $[2,2,2,2,2]$​​​​ （序列 **2**）和 $[2,2,2,2,2]$​​​​ （序列 **4**）。 可以通过删除第二个序列的第 **二** 个元素得到 $[2,2,2,2]$​​​​ 并且通过删除第四个序列的第 **一** 个元素得到 $[2,2,2,2]$​​​​ . 这样两个序列的和就都变为 $8$​​​​​ 了，符合题意。

## 题解

#### 解题思路：

可以在输入时就对每个序列进行求和并记录，读入完之后就拿到了这个序列的 **初始和** 了。之后进行暴力枚举删除每个数，并记录在一个键值对应的映射表 `map` 中。其中因为枚举出来的是和，所以令和是键，要输出的数据是值，可以定义一个结构体 `Node_t` 来存储。

#### 参考代码：

```cpp
#include <bits/stdc++.h>

using namespace std;

struct Node_t
{
    //序列
    __int64 sequences;

    //对应下标
    __int64 index;
};

__int64 k/*数据组数*/, a[200005]/*当前序列*/, n/*元素数*/, nowsum/*当前的和*/;

map<__int64, Node_t> mp;

inline void quick_cppio(void)
{
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    return ;
}

inline void init(void)
{
    nowsum = 0;
}

int main()
{
    quick_cppio();
    cin >> k;
    for (__int64 i = 1; i <= k; ++i)
    {
        init();
        cin >> n;
        for (__int64 j = 1; j <= n; ++j)
        {
            cin >> a[j];
            nowsum += a[j];
        }
        for (__int64 j = 1; j <= n; ++j)
        {
            //枚举删掉的数
            __int64 now = nowsum - a[j];//删掉这个数之后的和
            if (mp.count(now) && mp[now].sequences != i)
            {
                cout << "YES" << endl << mp[now].sequences << " " << mp[now].index << endl << i << " " << j << endl;
                goto end;
            }
            else
            {
                Node_t tmp;
                tmp.index = j;
                tmp.sequences = i;
                mp[now] = tmp;
            }
        }
    }
    cout << "NO" << endl;
    end:
    return 0;
}
```

