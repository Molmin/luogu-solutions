### 这道题其实难度不大，具体做法可以采用 map 或者数组。
先来看一下题目的大概意思。
## 题目
题目给出 $k$ 个序列，请找出两个序列 $a$ 和 $b$ 以及分别从两个序列中找出两个数 $a_{i}$ 和 $b_{j}$。使得 $a$ 序列的和减去 $a_{i}$ 等于 $b$ 序列的和减去 $b_{j}$。

有解输出  YES，无解输出 NO。

如果有解输出任意一组 $a$ 在所有序列中的编号 $n$ 和从 $a$ 序列中找到的数在 $a$ 序列中的编号 $i$，以及 $b$ 在所有序列中的编号 $m$ 和从 $b$ 序列中找到的数在 $b$ 序列中的编号 $j$。

## 思路

由于题目的时间限制 $2s$, 空间限制 $256\text{MB}$。而且 $ 2 \le k \le 2 \cdot 10^5 $,$ 1 \le n_{i} \le 2 \cdot 10^5 $。所以我们我法去记录所有输入的值而在所有输入结束后统一判断，但是我们的时间足够，可以采用 $O(nk)$ 的边输入便判断的方法。由于每个序列的总和都在 $-10^4$ 到 $10^4$ 之间，所以可以理解为所有可能的总和数量不超过 $2\times10^4$，再减去一个数，可能数量没有太大的差异，而数组在符合题意的情况下至少能开 $10^7$。所以我们可以用一个数组来记录每一种可能结果，但设计到负数结果，我们可以直接采用 map 进行存储，当然数组经过处理也是可以存储的。

在每次输入完序列后进行遍历所有本序列肯能的值（值代表着此序列的和减去任意此序列的一个数）。然后在 map 中查询这个值是否存在，如果存在并且不是本序列出来的值，那么可以直接进行配对，得出一个答案并输出，后续的输入可以不用管了。但如果没有就将这个值得到的信息存储到 map 中对应得地方，方便后续其它数组得出的其它值进行配对。

我们可以用一个布尔类型的变量去存储答案是否存在，初始值设为假。当找出答案后将答案直接输出或者用变量进行存储，布尔类型变量改为真。所有判断结束后如果值为真则有解，否则无解。

在 map 中我们只需要存储这个值得出的序列编号以及此序列的和减去的数在此序列中的编号，因为每次从新输入新序列，前面输入的序列不会保留，所以我们需要将需要存储的值的信息存全方便之后配对的查询以及输出。

当然，你得出答案后可以直接结束程序，这样就不需要布尔类型的变量去存储状态，但为了保险起见，我选择让他把所有数据都输完。

具体执行内容看代码。

## 代码

```cpp
#include<iostream>
#include<map>//重要头文件 
#include<algorithm>
using namespace std;
int a[200010];//这里是每次输入暂时存储输入序列的地方 
map<int,int> x;//这个map用来存储这个值对应的序列的编号 
map<int,int> y;//这个map用来存储这个值对应的序列中减去的数在此序列中的编号
map<int,bool> z;//这个map用来存储这个值在以前是否出现过
//当然，写了这么多的map也可以用结构体将其化为一个map,具体写法如下
/*
struct node{
	int x,y;
	bool z;
};
map<int,node> m;
*/
//查询时用m[n].x这种形式查询 
int main()
{
	bool cmp=false;//用来存储现在的状态是否有解 
	int ans1,ans2,ans3,ans4;//分别对应题目简介中的：a序列在所有序列的数在a中的编号，这个值减去的数在a中的编号，b序列在所有序列中的编号，这个值减去的数在b中的编号。  
	int k;//序列数量 
	cin>>k;
	for(int i=1;i<=k;i++)//可以改为while(k--)，因为我最开始以为要在循环后找出答案，所以没敢损坏k的值，一样的作用 
	{
		int sum=0;//为了方便后续每个值的枚举，我们先用sum存储整个序列的和然后在遍历减去每一个数，值就可以o(1)得到了 
		int n;//此序列的长度 
		cin>>n;
		for(int j=1;j<=n;j++)
		{
			cin>>a[j];//输入序列 
			sum+=a[j];//加和 
		}
		if(cmp) continue;//如果已经有解，后续就不需要进行查找，可以直接跳过 
		for(int j=1;j<=n;j++)//开始用o(n)枚举所有此序列可能的值 
		{
			if(!z[sum-a[j]])//如果此值从未出现 
			{
				z[sum-a[j]]=1;//出现了 
				x[sum-a[j]]=i;//存储此序列的编号 
				y[sum-a[j]]=j;//存储减去此值在此序列中的编号 
			}
			else if(x[sum-a[j]]!=i)//如果出现并且不是此序列中出的值，就代表找到解了 
			{
				cmp=1;//将状态改为真，代表找到解了 
				ans1=x[sum-a[j]];//存储答案，如上文 
				ans2=y[sum-a[j]];//存储答案，如上文 
				ans3=i;//存储答案，如上文 
				ans4=j;//存储答案，如上文 
				//break; 
			}
		}
	}
	if(cmp)//有解 
	{
		cout<<"YES"<<endl<<ans1<<" "<<ans2<<endl<<ans3<<" "<<ans4<<endl;//输出答案 
	}
	else cout<<"NO";//无解 
	return 0;
}//简简单单60行，问题全部解决，stl爆率真的高！ 
```

## 总结

这道题不难想，可以锻炼使用 map 或者经过处理后使用数组，时间也很宽松。

但注意事项是，加入在查询中找到已经出现过此值，不要直接得出答案，记得判断不要是从此序列中出来的值，不然就是相同的序列，不符合题意了。(~~本蒟蒻就因此哇了一次 qwq~~)