## 题意

对于一个字符串，定义它的 `MEX` 为不作为连续子字符串出现的最短字符串。

如果有多个 `MEX`，则选择字典序最小。

现在给出一个长度为 $n$ 的字符串，输出它的 `MEX`。

## 思路

题目中对于 `MEX` 并没有解释清楚。我们举个栗子理解一下。

对于字符串 `TANAKIOI`，他的连续子串有 `T`,`TA`,`AN`,`NAKI`……。它的 `MEX` 就是不是它连续字串的长度最短，字典序最小的字符串，也就是 `B`。（似乎比原来更绕？）

那么本题的做法也十分明显了，枚举 
`a`,`b`,...,`z`,`aa`,`ab`,...，只要找到一个不是原字符串的连续子串就输出（第一个找到的肯定是最小的）。

判断它是不是原字符串的连续子串，可以用 `c++` 的自带函数 `find()` 进行判断。对于 `find()` 函数的使用方式，请[右转出门 csdn 一下](https://blog.csdn.net/weixin_34345560/article/details/90093329)。

重点是如何去进行枚举。我们可以先把枚举的字符串的最后一位加一，也就是 `st[st.size()-1]++;`，然后去进行判断。如果最后一位已经超过了 `z`，就把最后一位归 `a`，它的前一位加 $1$，如果前一位也超过了 `z`，就继续把那一位归 `a`，更前一位加 $1$。以此类推，如果一直推到第一位都超过 `z`，就需要把第一位变成 `a`，在字符串的前面加上一个 `a`，也就是 `st='a'+st`。

最后我们来考虑一下这个算法的极限时间复杂度：已知 $n\leq1000$,我们来找一下它最多可以枚举到几位 $26^1=26<1000$，$26^2+26^1=676+26=702<1000$，$6^3+26^2+26^1=17576+676+26=18278>1000$。

那么我们最多只能枚举 $3$ 位。为了方便计算，我们算它可以枚举 $18278$ 次，每次枚举 $3$ 位，就算再乘上 $T$（最大 $1000$），也只有 $54834000$，还不会超时。何况题目保证了所有的 $n$ 加起来不超过 $1000$，同时刚才我们的所有数字都估打了，实际上肯定没有那么多。综上所述，这种算法不会超时。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int t,n;
string st;
int main(){
	scanf("%d",&t);
	while(t--){
		scanf("%d",&n);
		cin>>st;
		string st_fd="a";
		while(1){
			if(st.find(st_fd)==-1){
				cout<<st_fd<<'\n';
				goto loop;
			}
			st_fd[st_fd.size()-1]++;
			for(int i=st_fd.size()-1;i>=0;i--)
				if(st_fd[i]>'z'){
					if(i!=0)
						st_fd[i]='a',st_fd[i-1]++;
					else st_fd[i]='a',st_fd='a'+st_fd;
				}
//			cout<<st_fd<<'\n'; 
		}
		loop:;
	}
	return 0;
}
```

## 补充

在对进行枚举的字符串操作时，其实有一种较为简便的方法，可以使用类似 $27$ 进制的方法，枚举一个十进制数，在需要使用的时候把它转成类似 $27$ 进制。在这种类似 $27$ 进制中：`A` 代表 $1$，`B` 代表 $2$,……，`AA` 代表 $27$，`AB` 代表 $28$。