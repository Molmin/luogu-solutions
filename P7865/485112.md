## 写在前面

这篇题解主要讲述了二维前缀和的知识。

看到这道题有个“线段树”标签，本蒟蒻认为，用线段树切掉这题属实是杀鸡用牛刀了。这题的数据给的很善良：

$1 \leq n, m \leq 3000$。

这样的数据，无论是空间和时间复杂度，二维前缀和+差分都绰绰有余。

那么，建立了思路，让我们来研究一下细节。

***

## 二维前缀和&差分

关于二维前缀和，建议大家去切掉[这题](https://www.luogu.com.cn/problem/P2280)，是一道标准的二维前缀和，那里的题解也写得很详细。

标准的二维前缀和是（要求一个矩阵内的数字和）：

我们设前缀和矩阵是 `sum` 二维数组，其中要求的矩阵左上角坐标是 `[i][j]`，右下角坐标是 `[k][l]`。

于是，这个矩阵的数字和就是 `sum[k][l] + sum[i][j] - sum[i - 1][l] - sum[k][j - 1]`。

大家在草稿纸上模拟一下，会发现还是很有容斥原理的味道的。

***

关于二维差分，建议大家去切掉[这题](https://www.luogu.com.cn/problem/P3397)，很有帮助。

标准的二维差分（假设要把一个矩阵内同时加上 $w$）：

令差分矩阵是 `b` 二维数组，其中要维护的矩阵左上角坐标是 `[i][j]`，右下角坐标是 `[k][l]`。

于是，处理差分矩阵的过程是：

```cpp
b[i][j] += w;
b[k + 1][l + 1] += w;
b[i][l + 1] -= w;
b[k + 1][j] -= w;
```

大家也可以模拟一下。

***

接下来，要解决这题，还有一个重要的性质：

**前缀和和差分（不管是几维）互为逆运算。**

想到这里，各位读者是否露出了笑容？

***

## 思路

先在输入的时候把差分矩阵处理好。

接下来用前缀和（差分的逆运算）还原矩阵，再跑一遍循环扫一遍矩阵，统计哪些地方被无人机覆盖到了（没覆盖记为 $0$，覆盖了记为 $1$）。

接下来，让我们想想这件事情：如果一个矩阵内数字和就是它的面积，能否说明它全部被覆盖了？

答案是肯定的。

于是，对于 $L$ 组询问，依次使用前缀和算出矩阵内数字和即可。

***

## 代码

警告：洛谷拥有强大的反作弊系统。

**有一个细节需要注意，本题给你的坐标是左下角和右上角，直接使用上面说的套路会WA，需要进行一些细节的修改。**

```cpp
#include <iostream>
#include <algorithm>
#define MAXN 3005
#define MAXM 3005
#define MAXS 1000005
using namespace std;

int n, m, s, l;
int squ[MAXN][MAXM]; // 使用一个矩阵即可

int main()
{
	std::ios::sync_with_stdio(false);
	
	cin >> n >> m >> s;
	
	for (int i = 1; i <= s; i++)
	{
		int a1, b1, a2, b2;
		cin >> a1 >> b1 >> a2 >> b2;
		
		squ[a1][b1]++;
		squ[a2 + 1][b2 + 1]++;
		squ[a2 + 1][b1]--;
		squ[a1][b2 + 1]--;
	}
	
	for (int i = 1; i <= n; i++)
	{
		for (int j = 1; j <= m; j++)
		{
			squ[i][j] += squ[i - 1][j] + squ[i][j - 1] - squ[i - 1][j - 1];
		}
	}
	
	for (int i = 1; i <= n; i++)
	{
		for (int j = 1; j <= m; j++)
		{
			if (squ[i][j]) squ[i][j] = 1;
		}
	}
	
	for (int i = 1; i <= n; i++)
	{
		for (int j = 1; j <= m; j++)
		{
			squ[i][j] += squ[i - 1][j] + squ[i][j - 1] - squ[i - 1][j - 1];
		}
	}
	
	cin >> l;
	
	for (int i = 1; i <= l; i++)
	{
		int r1, c1, r2, c2;
		cin >> r1 >> c1 >> r2 >> c2;
		
		int sum = squ[r2][c2] - squ[r1 - 1][c2] - squ[r2][c1 - 1] + squ[r1 - 1][c1 - 1];
		if (sum >= (r2 - r1 + 1) * (c2 - c1 + 1)) cout << "Yes" << endl; // 为了保险，用了大于等于
		else cout << "No" << endl;
	}
}
```

2022-07-24 upd：更改了一处笔误  
2022-10-14 upd：感谢 @int_R，更改了二维差分介绍处的错误