想看证明的。。。蒟蒻不会，请看楼上【】

------------
配图不错。不过题目很。。。。

------------
一眼看到题目，肯定排列组合啊【】

然而。。。蒟蒻想了半天，写了一个$C_m^{a+b}$。。然后懵了


------------
懵了以后怎么办？当然打暴力了

很容易就能想出一个dp

【1.你把dp叫暴力？    2.“很容易”【其实一点也不容易】】


------------
![](https://cdn.luogu.com.cn/upload/image_hosting/w0i4y1jy.png)

我们可以考虑是否取第一个数（是奇数）

如果取，转化成$dp[1][m-1][a-1][b]$

如果不取

![](https://cdn.luogu.com.cn/upload/image_hosting/i9go1r5e.png)

如果不取，转化成$dp[0][m][a][b]$

再看dp[0][m][a][b]，同理

考虑是否取第一个数（是偶数）

如果取，转化为$dp[0][m-1][a][b-1]$

如果不取，转化为$dp[1][m-1][a][b]$

于是，我们可以用$O(m^3)$来算出答案（可以拿到50分）

------------
暴力写完了，打表呐。
```cpp
for(int m=0;m<=10;m++)
	dp[1][m][0][0]=dp[0][m][0][0]=1;
for(int m=1;m<=10;m++)
	for(int i=0;i<=m;i++)
		for(int j=0;j<=m;j++)
		{
			if(i==0&&j==0)continue;
			dp[0][m][i][j]=((j==0?0:dp[0][m-1][i][j-1])+dp[1][m-1][i][j])%mod;
			dp[1][m][i][j]=((i==0?0:dp[1][m-1][i-1][j])+dp[0][m][i][j])%mod;
		}
for(int m=1;m<=10;m++)
{
	cout<<m<<endl;
	for(int i=0;i<=m;i++)
	{
		for(int j=0;j<=m;j++)
			printf("%7d ",dp[1][m][i][j]);
		cout<<endl;
	}
	cout<<endl;
}
结果：
1
      1       1
      1       0

2
      1       2       1
      2       1       0
      1       0       0

3
      1       3       3       1
      3       4       1       0
      3       1       0       0
      1       0       0       0

4
      1       4       6       4       1
      4       9       6       1       0
      6       6       1       0       0
      4       1       0       0       0
      1       0       0       0       0

5
      1       5      10      10       5       1
      5      16      18       8       1       0
     10      18       9       1       0       0
     10       8       1       0       0       0
      5       1       0       0       0       0
      1       0       0       0       0       0

6
      1       6      15      20      15       6       1
      6      25      40      30      10       1       0
     15      40      36      12       1       0       0
     20      30      12       1       0       0       0
     15      10       1       0       0       0       0
      6       1       0       0       0       0       0
      1       0       0       0       0       0       0

7
      1       7      21      35      35      21       7       1
      7      36      75      80      45      12       1       0
     21      75     100      60      15       1       0       0
     35      80      60      16       1       0       0       0
     35      45      15       1       0       0       0       0
     21      12       1       0       0       0       0       0
      7       1       0       0       0       0       0       0
      1       0       0       0       0       0       0       0

8
      1       8      28      56      70      56      28       8       1
      8      49     126     175     140      63      14       1       0
     28     126     225     200      90      18       1       0       0
     56     175     200     100      20       1       0       0       0
     70     140      90      20       1       0       0       0       0
     56      63      18       1       0       0       0       0       0
     28      14       1       0       0       0       0       0       0
      8       1       0       0       0       0       0       0       0
      1       0       0       0       0       0       0       0       0

9
      1       9      36      84     126     126      84      36       9       1

      9      64     196     336     350     224      84      16       1       0

     36     196     441     525     350     126      21       1       0       0

     84     336     525     400     150      24       1       0       0       0

    126     350     350     150      25       1       0       0       0       0

    126     224     126      24       1       0       0       0       0       0

     84      84      21       1       0       0       0       0       0       0

     36      16       1       0       0       0       0       0       0       0

      9       1       0       0       0       0       0       0       0       0

      1       0       0       0       0       0       0       0       0       0


10
      1      10      45     120     210     252     210     120      45      10
      1
     10      81     288     588     756     630     336     108      18       1
      0
     45     288     784    1176    1050     560     168      24       1       0
      0
    120     588    1176    1225     700     210      28       1       0       0
      0
    210     756    1050     700     225      30       1       0       0       0
      0
    252     630     560     210      30       1       0       0       0       0
      0
    210     336     168      28       1       0       0       0       0       0
      0
    120     108      24       1       0       0       0       0       0       0
      0
     45      18       1       0       0       0       0       0       0       0
      0
     10       1       0       0       0       0       0       0       0       0
      0
      1       0       0       0       0       0       0       0       0       0
      0
【格式有点。。。。】
```
然后就是盯着表看环节

看了很久，发现每个a=b的时候都是完全平方数【然而并没用】

想到这是一个排列组合题目，画了个杨辉三角对照
![](https://cdn.luogu.com.cn/upload/image_hosting/ei24t6ux.png)

突然感觉表中的数字可以由杨辉三角中行列乘积表示

然后就行了。。。耗时嘛emmm。。。。

结果是$C_{m-a}^b * C_{m-b}^a$。

------------
最后需要注意的。。
求逆元不用线性筛会死【】
```cpp
#include<iostream>
#include<cstdio>
using namespace std;
const long long mod=998244353;
long long jc[1000001],inv[1000001];
long long C(long long a,long long b)
{
	return jc[a]*(a!=b?inv[a-b]:1)%mod*(b!=0?inv[b]:1)%mod;
}
int main()
{
	inv[1]=1;
    for(int i=2;i<=1000001;i++)
        inv[i]=(long long)(mod-mod/i)*inv[mod%i]%mod;
    for(int i=2;i<=1000000;i++)
		inv[i]=inv[i]*inv[i-1]%mod;
	jc[1]=1;
	for(int i=2;i<=1000000;i++)
		jc[i]=jc[i-1]*i%mod;
	int T;scanf("%d",&T);
	while(T--)
	{
		long long m,a,b;scanf("%lld%lld%lld",&m,&a,&b);
		if(a+b>m)printf("0\n");
		else printf("%lld\n",((C(m-b,a)*C(m-a,b))%mod+mod)%mod);
	}
	return 0;
}
```
最后，奉劝大家考场上话20分钟拿到那50分就走人吧qwq

不然会死人的awa。。