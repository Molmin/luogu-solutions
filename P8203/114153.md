根号好题。前半部分思路来自我，后半部分来自 @abruce（adj.）。

___

建出 AC 自动机过后，问题变成了**虚树交**。

- 这一步如果不懂不建议你做这个题。

但是这个东西不是很好预处理与维护，于是我们考虑这样一个臭活：

设总串长（虚树大小和）是 $S$，询问次数是 $q$，两个虚树的大小是 $x,y$，如果我们可以在 $O(\bold{min}(x,y))$ 内回答一个询问，并将**询问记忆化**，那么总时间复杂度是 $S\sqrt q$。

- 证明：考虑能怎么卡你。取出前 $q$ 大的 pair 来询问，假设将虚树按大小从大到小排序依次为 $\{T_i\}$，那么至多给你卡到 $\sum_{i=1}^{O(\sqrt q)}i|T_i| \le O(S\sqrt q)$（考虑阶梯状求和即证）。

那么问题变成了设计算法以支持在 $O(\bold{min}(x,y))$ 的时间内回答询问。

一个暴力至极的思路是这样的：

- 观察到：任意到根链上关于 “子树内是否包含大虚树点” 有**单调性**。

- 因此，考虑枚举小虚树的叶子，找到其到根链上**最深的包含大虚树点的点**。
	
    - 这里需要使用**倍增**处理，于是带上了 $\log$。 

- 将所有这些点抽出来再做一次**树链并**（虚树权值和）就是答案。

	- 树链并中的 LCA 采用欧拉序 $O(1)$ 实现。 

复杂度 $O(S\sqrt q \log S)$，由于时间充裕，不排除可以过的可能性。

考虑如何去 $\log$。

将倍增那一步反过来看：如果我们**枚举大虚树**，预处理每一个点的到根链上最深的大虚树上点，就可以 $O(1)$ 了。

但是每枚举一个大虚树，我们都需要 $O(S)$ 的时间遍历整个 Trie 树，复杂度就爆了。

考虑**平衡**。我们真的有必要枚举所有大虚树吗？

如果一个虚树的 siz 大于我们设置的一个阈值 $B$，那么我们对它进行一次上述预处理。复杂度 $O(S\sqrt S)$。

- 为了减少常数，类似于 CF1039D，我们可以**使用 dfn 序上扫代替 dfs**。

这样如果询问中大虚树 siz $\ge B$，就可以不带 log。

否则两个虚树 siz 都 $\le B$，直接暴力在虚树上做复杂度也不超过 $O(B)$。

- 具体地，你可以归并合并点集过后暴力求交；

- 更好的实现是，对于每一个小虚树中的点，在大虚树中双指针找到其**前驱后继**，其对应的 “最深包含大虚树的祖先” 一定是其与前驱后继的 LCA 中深度较大的那个。

于是就做完了。复杂度 $O(S\sqrt S+S\sqrt q)$。