显然无论如何需要先建出关于 $s$ 的 AC 自动机。不难发现答案即为 fail 树上的虚树交中所有点权之和（点权即为在此结束的 $s$ 数量）。

考虑将长度较小的 $y$ 挂到长度较大 $x$ 上离线，不难发现如果能够在 $O(y\text{ polylog})$ 的复杂度内解决一次询问，则经典结论是记忆化后总复杂度是 $O(n\sqrt n\text{ polylog})$。

而 $\rm polylog$ 的做法是容易的。考虑对于 $y$ 中的每个点，找出其所有祖先中最深的在 $x$ 虚树上的点，并对这些新点再建虚树。剖一遍后维护所有重链上最深的在 $x$ 虚树上的点是什么即可，一只 $\log$。

考虑怎么不带 $\log$。再次使用根分（上一次是记忆化所有带来的自然根分），如果 $x$ 的长度大于阈值 $B$，那么考虑 dfs 整颗树处理出所有点的答案；否则抽出 $x,y$ 所有点的 dfn 序，双指针维护 $y$ 的每个 dfn 序在 $x$ dfn 中的前驱后继，则其所有祖先中最深的在 $x$ 虚树上的点即为与这两点 lca 中深度较大者。使用 $O(1)$ LCA 容易做到 $O(n\sqrt n)$。