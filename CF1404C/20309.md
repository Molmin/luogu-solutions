好久没写博客了，瞎写一下：

VP 了这场，结果这题一开始写了一个假算法，导致排名只有 240+ /kk ...

但是我的做法比其他人简单很多？不过转化比较多有点烧脑就是了。

首先考虑怎么单次查询。

设$i$前面已经删了$j$个，那么$i$能删当且仅当$i-j=a_i$。

发现这个东西有后效性，仿佛连 $O(n^2)$ dp 都做不了...那怎么办？

注意到一个性质，最后一个数删除对后面没有任何影响。

所以可以很自然的想到：开一个堆，每一次删除最后面的，再更新一下那些可以重新加入。这样就可以$O(n\log_2 n)$，强行优化可以$O(n)$。

多组询问？显然这个询问可以转化成$[l,r]$的区间查询。然后怎么方便维护？

~~发现最前面那个数可以最后删除，然后我就灵感爆发，写了莫队，一看时间限制 4s 马上开写，写着写着发现假了，当场去世。~~

单词查询这个做法启示了我们可以考虑最后一个数。考虑扫描线，维护$[l,r]$最多能删除多少次，如果次数$\geq i-a_i$，那么一定有一种方法可以删掉它。

接下来等价于需要维护一个数据结构，支持：

- 把大于 x 的数全部加上 1。

- 单点查询。

一看就很不正常，冷静一下发现这个答案是关于$l$单调递减的。那么每一次“把大于 x 的数全部加上 1”只需要区间加法即可。

那么使用线段树（区间加单点查询）+二分就做完了。时间复杂度$O(n\log_2^2 n)$，如果使用线段树上二分可以做到$O(n\log_2 n)$。当然时限 4s，随便过。

如果把每一个$r$的信息用主席树记录下来就可以做到强制在线了，时空复杂度都是$O(n\log_2 n)$。