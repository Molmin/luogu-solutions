## 题意

一个长度为 $n$ 序列 $a[]$，每次可以进行一个操作，当且仅当 $a[i]=i$ 的时候，你可以去掉这个数，然后后边每个数的下标减1。

有 $m$ 次询问，每次去掉前 $x$ 个，和后 $y$ 个，问如何操作可以去掉最多的数，输出去掉的数最多的个数。

## Solution

巧妙的解法，我们重写 $a[]$ 序列即可，具体的操作是：用 $i-a[i]$ 替换 $a[i]$，（若$i-a[i]$ 为负数，那么令其为 $INF$）这样一次操作就变成了：去掉一个0，将后边的数全部减1。

不妨设询问的 $l=1$，这样便于思考。使用动态规划的思想，我们之前最多取 $f(i-1)$ 个数，那么，只要 $a[i]\le f(i-1)$，那么我们就有 $f(i)=f(i-1)+1$, 否则 $f(i)=f(i-1)$。

这样子我们做了全部 $l=1$ 的情况，对于询问，我们按照 $r$ 排序，对于一个 $r$，维护每个 $l$ 的答案。每次从末尾添加一个数的情况，我们可以二分出来刚好 $\ge a[i]$ 的下标，而后树状数组修改即可。

考虑要完成区间加，单点查询，那么我们只要把维护的值差分即可。

如果强制在线，可以考虑使用主席树来完成。关于主席树的区间操作，由于没有复杂的 `tag` 维护，所以可以采用不下放 `tag` 的写法，即每个 $sum(k) = sum(ls(k))+sum(rs(k))+tag(k)*(R-L+1)$，查询的时候注意下就好了。

这样子你就可以切了他了，代码就不放了。