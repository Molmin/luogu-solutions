# 前言

我来到这道题的方式其实是 [通过这道题的多倍经验来到的](https://www.luogu.com.cn/discuss/475739)。

然后我把代码直接复制，粘贴，提交，不出所料，$0$ 分了。（
# Solution

虽然题目有一定的区别，但其实整体解法和 [P2125](https://www.luogu.com.cn/problem/P2125) 是差不多的。

大家可以先看那一道题，也可以参照 [我那一道题的题解](https://www.luogu.com.cn/blog/int08/solution-p2125)。

所以我们就在想如何让这一道题使用和那一题差不多的方法解出来。

同样设第 $i$ 个书架给了上个书架 $p_i$ 本书（这个数值可以为负数）。

于是我们得到一个有 $n$ 个未知数，$n$ 个方程的方程组。

但是其中有一个方程是跟前面的方程等价。

所以这是一个有 $n$ 个未知数，$n-1$ 个方程的不定方程组。

我们所需要求出的就是 $\sum\limits_{i=1}^n|p_i|$ 的最小值。

## 具体做法

### 计算 $p_i$
我们先给 $p_1$随便代一个值（例如我的代码中代入的是 $1$）。

于是我们就可以想如何用已知的 $p_1$ 求出其他的 $p_i$。

然后我们愉快地发现这道题中我们所需要的式子只是和上一道题有较小的区别而已。

具体的说本题中我们所获得的式子为：

$p_i=a_{i-1}-b_{i-1}-p_{i-1}$

于是我们照样可以把其他的 $p_i$ 求出来。

那么以下就和那道题是一样的了，~~我直接复制粘贴了啊哈。~~

### 使得结果最小化

容易发现这些数当且仅当同时加或者减相同的值时候，方程仍成立。

那我们如何让结果 $\sum\limits_{i=1}^n|p_i|$ 最小化呢？

同样容易发现，当 $p_i$ 大多数是正数的时候，对所有的数减 $1$ 之后，结果变得更小。（因为大多数的绝对值减了 $1$，少部分绝对值加了 $1$。）反之，当 $p_i$ 大多数是负数的时候，对所有的数减 $1$ 之后，结果变得更大。

那么最小值就出来了：当 $a$ 数组中正数和负数一样多的时候，结果达到了最小。

（因为此时不管是增加或者减少，都只能让结果变得更大。）

同时，因为所有数只能同加同减相同的值，所以说这些数的大小顺序其实是固定的。

那么什么时候正数和负数一样多呢？

~~C位出道的~~中位数闪亮登场！

没错，**当中位数正好被调整为0的时候，数组内正数和负数一样多，答案达到最小。**

所以我们只需要模拟一下以上的调整过程，时间复杂度 $O(n)$，就可以了。

这其中我们需要求中位数。~~方法一是使用 STL，~~ 方法二是先排一遍序，再找到中位数，时间复杂度 $O(n\text{log}n)$，方法三是使用快速排序的二分思想，平均时间复杂度 $O(n)$。

~~但是以本题的数据大小方法二就已经够用了，不需要再使用方法三写一大串代码。~~

于是这道题就做出来了。

# AC code
```cpp
#include<bits/stdc++.h>
using namespace std;
namespace IO{
	char ibuf[(1<<20)+1],*iS,*iT;
	#if ONLINE_JUDGE
	#define gh() (iS==iT?iT=(iS=ibuf)+fread(ibuf,1,(1<<20)+1,stdin),(iS==iT?EOF:*iS++):*iS++)
 	#else
	#define gh() getchar()
	#endif
	#define reg register
	inline long long read(){
		reg char ch=gh();
		reg long long x=0;
		reg char t=0;
		while(ch<'0'||ch>'9')   t|=ch=='-',ch=gh();
		while(ch>='0'&&ch<='9') x=x*10+(ch^48),ch=gh();
		return t?-x:x;
	}
}
using IO::read;
long long n,i,j,a[5555555],b[5555555],p[5555555],q[5555555],an,ans;
int main()
{
	n=read();b[1]=read();a[1]=read();
	p[1]=q[1]=1;
	for(i=2;i<=n;i++)
	{
		b[i]=read();a[i]=read();q[i]=p[i]=a[i-1]-(b[i-1]-p[i-1]);
	}
	sort(q+1,q+n+1);
	an=q[(n+1)/2];
	for(i=1;i<=n;i++)
	{
		p[i]-=an;
		ans+=abs(p[i]);
	}
	cout<<ans<<endl;
	return 0;
}
```
~~容易发现自从上次比赛之后，我每次都使用的是那次比赛的快读模板。~~