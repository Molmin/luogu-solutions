与本年 T2 一样，仍然是一道不符合 CSP 风格的题目。所以说很容易看出，这是一道很模板的 DP。

题目大意：从 $  n $ 个坐标中选择若干个，使得横坐标不减，且纵坐标不减，同时可以插入 $ k $ 个任意位置的点，使得选择的点和差入的点相邻两个点之间距离为 1，求最大点的数量。

考虑一个更简单的问题：令 $ k = 0 $ ，则问题变成了从 $ n $ 个坐标中选择若干个，使得横坐标不减，且纵坐标不减，相邻点之间距离为 1，求最大点数。

感觉有一种熟悉的味道？没错，就是最长上升子序列！此时容易想到对 $ n $ 个点排序，先按横坐标排序，再按纵坐标排序。如此，再对这 $ n $ 个点求最长上升子序列即可。

记 $ f[i] $ 为以 $ i $ 结尾的最长上升点序列最大长度，则有：  
若 $ {j\in[1,i-1]} $ ，则 $ f[i] = \max ( f[i], f[j] + 1 ) $

此时，我们再考虑 $ k > 0$，只需对上述状态增加一维，记 $ f[i][p] $ 为以$ i $结尾，且已经插入了 $ p $ 个额外点的最长上升点序列最大长度，则有：

若 ${ j\in[1,i-1], p\in[d,k] }$ ，则 $ f[i][p] = \max ( f[i][p] , f[j][p-d] + d + 1 )$ $ d = a[i].x - a[j].x + a[i].y - a[j].y - 1 $


**所以推得动态转移方程为：**

```cpp
int d=a[i].x-a[j].x+a[i].y-a[j].y-1;
......
f[i][p]=max(f[i][p],f[j][p-d]+d+1);
```

当然，别忘了初始化：
给定一个点 $ i $ ，可以在前面插入 $ j $ 个点，怎么插入上升点列最长？
当然是直接插入 $ j $ 个点！

```cpp
for(i=1;i<=n;i++)
{
	for(j=0;j<=k;j++)f[i][j]=j+1;
}
```

**完整代码**

```cpp
#include <bits/stdc++.h>

using namespace std;
#define x first
#define y second
int i,j,p,n,k,f[505][105]; // f[i][j]: 前 i 个点，插入了 j 个点后最大长度
pair<int,int>a[505];
int main()
{
	cin>>n>>k;
	for(i=1;i<=n;i++)cin>>a[i].x>>a[i].y;
	sort(a+1,a+n+1);
	for(i=1;i<=n;i++)
	{
		for(j=0;j<=k;j++)f[i][j]=1+j; // 直接在 i 点前插入 j 个点
	}
	// 类似最长上升子序列
	for(i=2;i<=n;i++)
	{
		for(j=i-1;j>=1;j--) // j -> i
		{
			if(a[j].y>a[i].y)continue;
			// 从 j 到 i 要插入 d 个点才能满足
			int d=a[i].x-a[j].x+a[i].y-a[j].y-1;
			for(p=d;p<=k;p++)f[i][p]=max(f[i][p],f[j][p-d]+d+1);
		}
	}
	int ans=0;
	for(i=1;i<=n;i++)ans=max(ans,f[i][k]);
	cout<<ans;
	return 0;
}

```
