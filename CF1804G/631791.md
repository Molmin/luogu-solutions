## $\text{Statement}$

在一个带宽为 $b$ 字节每毫秒的网络中，有 $n$ 个用户需要传输数据。

第 $i$ 个用户会在第 $s_i$ 毫秒到第 $t_i$ 毫秒（包含端点）使用该网络，其初始传输速度为 $d_i$。也就是说，这名用户在 $s_i$ 毫秒开始使用该网络，此时其传输速度为 $d_i$。随后传输速度会遵循以下程序而改变。

假设在第 $x$ 毫秒有 $m$ 个用户使用该网络，第 $i$ 个用户当前的传输速度为 $t_i \ge 0$。

1. 若 $m = 0$，此时没有用户在使用网络。什么都不会发生。
2. 如果所有 $t_i$ 的和 $\le b$，每个使用网络的用户都能成功传输数据（第 $i$ 个用户传输了 $t_i$ 字节）。在这之后，每个用户的传输速度（即每个 $t_i$）都会增加 $1$。
3. 如果所有 $t_i$ 的和 $> b$，会发生网络拥塞。没有用户在该毫秒内能传输数据。在这之后，每个用户的传输速度都会除以二（即每个 $t_i$ 被替换为 $\left\lfloor \frac{t_i}{2}\right\rfloor$）。

给定 $n, b$ 和每个 $s_i, t_i, d_i$，请计算所有用户总共可以传输的数据量。

$1\le n\le 2\times 10^5, \ 1\le b, d_i \le 10^9, \ 1\le s_i\le t_i\le 10^9$。

## $\text{Solution}$

记值域为 $V$。

首先可以发现，如果没有元素的变化，在至多 $O(\log V)$ 次除二操作后，所有用户的传输速度都会在确定的值间循环，这启发我们将加一和除二分开进行。下面先不考虑加入/删除元素，也就是说，我们视 $\forall i,j, \ s_i = s_j, t_i = t_j$。

根据上面的讨论，我们不难发现在所有值变为相同元素前，除二操作的总次数是 $O(n\log V)$ 的。同时，不难快速计算连续的加一操作的次数和对答案的贡献。如果我们知道了 $m$ 和 $s = \sum t_i$，我们就能够 $O(1)$ 地计算出加一的次数，即 $c = \frac{b - s + m}{m}$，从而可以计算这些加一操作的贡献，即 $sc + m\frac{c(c - 1)}{2}$。这样总时间复杂度只取决于除二操作。

我们需要为每个值加 $k > 0$、为每个值除二，在这过程中合并相同值，维护值的个数 $m$ 和值的和 $s$。

考虑朴素维护（每次 $O(m)$ 地遍历所有值做操作）的复杂度。设最开始不同的 $t_i$ 共有 $v$ 个。假设 $\forall i,\ t_i < t_{i + 1}$，我们能知道 $t_i$ 会在 $O(\log(t_{i + 1} - t_i))$ 次操作内与 $t_{i + 1}$ 合并，这样操作次数是均摊 $O\left(v + \sum_{i = 1}^{v - 1} \log(t_{i + 1} - t_i)\right)$ 的，首先需要 $O(v)$ 的复杂度做加法，随后不断除 $2$。总复杂度通过均摊可以得到。

在具体实现上，可以通过并查集维护代表元的方式得到 $O(n\alpha (n)\log V )$ 的复杂度，或是线段树朴素递归的方式得到 $O(n\log n\log V)$ 的复杂度。这两种实现都支持快速加入或删除元素。不难证明加入新元素不会影响 $O(n\log V)$ 次除二操作带来的总时间复杂度。

这样我们只需要考虑所有值都在确定的值间循环的情况了，这是容易判断和处理的。我们只需要记录两次除二操作后答案的差值和花费的操作次数，就可以快速计算到下次加入/删除元素前有多少个周期。得到这之后就可以快速跳到最后一个周期了。

总时间复杂度 $O(n\log n\log V)$（线段树）。

[Submission](https://codeforces.com/contest/1804/submission/198043297).