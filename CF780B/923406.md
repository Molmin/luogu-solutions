## 附言
题目名称：[The Meeting Place Cannot Be Changed](https://www.luogu.com.cn/problem/CF780B)

在另外一个课集训时候做的，老师还讲了，那就交一发题解吧。
## 二分
这是一道二分题（判断算法这件事看感觉，~~但有个技巧就是看数据范围~~）。

二分的特点是：处理单调序列；能够把求最优解的问题转换为判断性问题。

知道是二分了，怎么二分？
## 思路

一条数轴上有很多人，第一感觉是枚举点。

但是点好像没有什么可以二分的，硬来枚举复杂度只能变成一个标准的二次函数，当然，还是因为点不具备单调之类的特殊性质，尤其在出发点不可控的情况下。

那么就可以从另外一个要素：时间，来考虑。

众所周知，人们可以行走到的区域是随着时间的增加和变广的。

事实上，如果有一个有一个点使得所有人都可以走到，即说明这个点是合法的开会地点。因此大体的思路是：二分遍历行走的时间，然后在这种时间下寻找一个所有人都可以到达的点，没有就增加时间，有就减少然后继续找。

但是如何快速的寻找这个点是一个问题，如果用普通循环先遍历，再记录，再搜索，时空复杂度明显大了些。

因此考虑一种优化算法。容易理解，所有人都可以向左行走一定的距离，也可以向右行走相同的距离。在两个方向中，总有人到达的地方较近（注意，是位置不是距离，也就是说有可能一个行走速度快但是位置遥远的人他到达的距离并没有一个很慢的人远）。注意，向左走的时候落点越小越远，向右走的时候越大越远。显而易见，落点越远，覆盖的距离越大，同时比它近的落点它都能覆盖到。（好好理解）

那么如果左右落点最近的两个人他们的可以达到的范围都有交点，那落点远的必然也有焦点，这样问题就解决了。而且这种方法时间复杂度也相对比较小。思路完，代码实现。

看看其他三位大佬的思路和我差不多，我也想不出更好的方法，也就在细枝末节上优化优化吧。

## 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
int N, x[60005], y[60005];
bool check(double t) {
	double lmin, rmin;
	rmin=2147483645; 
	lmin=-2147483645;
	for(int i=1;i<=N;i++) {
		lmin=max(lmin,x[i]-y[i]*t);//关键思路; 
		rmin=min(rmin,x[i]+y[i]*t); 
	}
	return (lmin<=rmin);
}
int main () {
	double l=0, r=0;
	scanf("%d", &N);
	for(int i=1;i<=N;i++) {
		scanf("%d", &x[i]);
		r=max(r,(double)x[i]);//max貌似只能处理同一个类型的变量 
	}
	for(int i=1;i<=N;i++) {
		scanf("%d", &y[i]);
	}
	double mid, t, cnt=0;
	while(++cnt<=70) {//此处是处优化，由于小数极有可能产生精度问题，所以采用这种提前限制范围的方法比较好。此处是经过计算了的。 
		mid=(l+r)/2.0;//板子 
		if(check(mid)) {
			r=mid;
		} else {
			l=mid;
		}
	}
	printf("%.12lf", l);//看清楚位数！细节决定成败 
	return 0;
} 
```
