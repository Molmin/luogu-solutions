将每个数的平方因子除掉，原题即任意排列一些球使同色球不相邻。

尝试按颜色排序后依次放入 DP。定义不合法空隙为相邻两个同色球之间的空隙；不合法空隙的颜色为两个同色球的颜色。若一个球放入与其同色的不合法空隙，则会新增一个不合法空隙；若放入与其异色的不合法空隙，则会减少一个不合法空隙。

因此，设 $f_x(i,j)$ 表示当前正在放入第 $x$ 个球，此时序列中有 $i$ 个异色不合法空隙，$j$ 个同色不合法空隙。

记 $x$ 前面有 $q$ 个与 $x$ 同色的球，则有以下转移：

- 消除一个异色不合法空隙：$g(i-1,j)\gets i \cdot f(i,j)$。
- 新增一个同色不合法空隙：一段同色不合法空隙的左右两侧也可以插入。可插的空数为 $j+2(q-j)=2q-j$：$g(i,j+1)\gets (2q-j)f(i,j)$。
- 放在合法空隙内。减去以上两者：$g(i,j) \gets (x - (2q - j) - i)f(i,j)$。

```cpp
const int N = 305;
const ll P = 1000000007;

int n, a[N];
map<int, int> col;

ll f[N][N]; // 有 i 个非 a_x 的同色对，j 个 a_x 的同色对
 
int main() {
	rd(n); if (n == 1) return puts("1") & 0;
	
	U (i, 1, n) {
		rd(a[i]);
		D (t, sqrt(a[i]), 1) if (!(a[i] % (t * t))) {
			a[i] /= t * t;
			break;
		}
	}
	
	sort(a + 1, a + n + 1);
	f[0][0] = 1;
	int q = 0;
	U (x, 1, n) {
		ll g[N][N] {};
		U (i, 0, x) U (j, 0, x) {
			if (i)
				(g[i - 1][j] += ll(i) * f[i][j]) %= P;
				
			(g[i][j + 1] += ll(2 * q - j) * f[i][j]) %= P;
			(g[i][j] += ll(x - (2 * q - j) - i) * f[i][j]) %= P;
		}
		++q;
		
		if (x == n || a[x] != a[x + 1]) {
			ms(f, 0);
			U (i, 0, x) U (j, 0, x) if (g[i][j])
				(f[i + j][0] += g[i][j]) %= P;
			q = 0;
		} else {
			swap(f, g);
		}
	}
	
	printf("%lld", f[0][0]);
}
```