### 题解：

这道题虽然简短，但是思维难度并不小.

解题思路：

左括号与右括号的个数都应该是 n / 2.若n为奇数，则无解.

取模：因为对 4294967296 即 2 ^ 32 取模，我们可以用 unsigned int，但不要所有数都开这个东西，常数太大会TLE.

问题转换：我们可以把小写字母看作左括号，大写字母看作右括号，那么要求正好配对，也就是求括号序列匹配问题，有 25 种括号(没有 x/X ).

首先我们考虑 n ^ 2 且只有一种括号的传统括号序列做法.

  - 我们设状态 f(i, j) 表示已经考虑了前i个数，现在还有j个左括号没有匹配的方案数.
  
  - 则可以有两种转移情况：1.第 i + 1 个数是左括号，则可以转移为 f(i + 1,j + 1). 2.第 i + 1 个数是问号，则可以转移为 f(i + 1,j - 1)与 f(i + 1,j + 1).
  
我们再来看这道题的情况.这与上面传统情况的不同之处是他擦去了所有的右括号以及一部分的左括号.

- 令 f(i, j) 表示 假设括号只有一种，前 i 个数里面，填了 j 个右括号的方案数.
  
- 第 i 个数是问号.1.当前填左括号: f(i, j) += af f(i - 1, j) 2.当前填右括号: f(i, j) += f(i - 1, j - 1).
 
- f(n, n / 2)即为答案
  
- 利用一种情况的方案数计算多种括号的方案数.
  
  - 我们开文章一开始就说了，我们有25种括号，且左括号个数是 n / 2 个.
    
  - 假设序列中已有 p 个左括号，那么 ?(即要填的数的个数) 里面就有 n / 2 - p 个左括号.
    
  - 每一个左括号有 25 种选择，那么 ans = 25 ^ (n / 2 - q) * f(n, n / 2).
  
我们又可以发现，第一位状态可以去掉，则本题就愉快的AC了.

还有一点，对于当前的 j 只需要从合法的方案即i / 2开始倒序枚举即可

下面上代码(我知道各位大佬也不需要代码)：

```
#include<iostream>

#define N 100005
#define LL unsigned int

using namespace std;

int n,p;
LL f[N<<1]={1},ans=1; // 全部开unsigned是要TLE的米多利亚少年.
char c[N];

int main()
{
	cin>>n;
	
	if(n&1)  cout<<"0"<<endl; // n为奇数
	else
	{
		int m=n>>1;cin>>c+1;//最多有m个右括号or左括号.
		for(int i=1;i<=n;i++)
		if(c[i]=='?')
			for(int j=i>>1;j>=i-m&&j;j--)  
			f[j]+=f[j-1];
		else  p++; // 计算当前已有的左括号个数
		for(int i=1;i<=m-p;i++)  ans=ans*25; // 在剩余的左括号中，每个有25种可能性.
		cout<<(LL)ans*f[m]<<endl;  
	}
	
	return 0;
}
```

### [Plus Ultra!!!](https://www.luogu.org/blog/OnePunchManGO/)

祝大家CSP2019 RP++！！！

  