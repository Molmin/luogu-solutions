本人的此题的思路与他人不太一样，为染色，使用两个表示列的指针 $l$ 和 $r$，以及一个表示行的 $top$ 指针。  
一开始 $l$ 和 $r$ 在中间位置即 $n/2+1$，$top$ 则在1的位置。  
当 $top$ 还没到行的一半时，$l$ 和 $r$ 是向外拓展的，而到了行的一半之后，$l$ 和 $r$ 就要向内收缩。  
每次将 $l$ 和 $r$ 之间的数组即 $a(top,i) (l \leq        i \leq r)$ 染色成D。  
最后将整个二维数组输出，被染色的部分输出D，否则就输出*。  
下面附上代码       

```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
int l,r;//l和r分别是两个指针，其作用上文已经讲过。
char a[1000][1000];//这个是二维数组。
int main()
{
	cin>>n;
	int top=0;
	l=r=n/2+1;//初始化定义，l和r在中间，而因为是++top，所以top初始化为0。
	while(top<n/2+1)
	{
		++top;//行加一
		for(int i=l;i<=r;i++)
		a[top][i]='D';//将l和r中间的部分进行染色。
		l--;r++;//l和r向外拓展。
	}//进行前半部分的染色。
	l=2,r=n-1,top=n/2+1;//中间部分初始化时将 l 定为2， r 定为n-1，是因为直接从中间后的下一行开始了。
	while(top<=n)
	{
		++top;
		for(int i=l;i<=r;i++)
		a[top][i]='D';
		l++;
		r--;
	}//进行后半部分的染色，过程同上，只是 l 和 r 向内收缩
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=n;j++)
		if(a[i][j]=='D')
		cout<<"D";
		else
		cout<<"*";
		cout<<endl;
	}//输出整个二维数组，如果被染色就输出 D ，未被染色就输出 * 。
	return 0;
}

```
本题解释到此为止，因为是第一次写题解，所以有些部分写的还不太好，请见谅。

