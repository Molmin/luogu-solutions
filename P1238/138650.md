### 前言
>记得这是我第一篇写的题解了（没过），那时候我只是一个可耐的小萌新（虽然现在也是），我一定要弥补这段空缺！

------------
### 题目描述

有一个$m* n$格的迷宫(表示有$m$行、$n$列)，其中有可走的也有不可走的，如果用$1$表示可以走，$0$表示不可以走，文件读入这$m* n$个数据和起始点、结束点(起始点和结束点都是用两个数据来描述的，分别表示这个点的行号和列号)。现在要你编程找出所有可行的道路，要求所走的路中没有重复的点，走时只能是上下左右四个方向。如果一条路都不可行，则输出相应信息(用$-1$表示无路)。

优先顺序：$左上右下$

------------
### 思路：
看完题目，发现要输出路径，当然用DFS好点啦（规定了顺序）。所以我们只需要根据题目意思进行DFS就OK惹（在搜索过程中记录路径）

下面看到代码！
### 完整代码：
```cpp
#include<bits/stdc++.h>
using namespace std;

int m,n,q1,q2,z1,z2,num[8005][2],h[5]={0,0,-1,0,1},l[5]={0,-1,0,1,0};
//num：路径存储 h：行移动 l:列移动（按题目顺序）q：起点 z：终点
int c=1,yes=0;
//c:层数 yes：有没有走到终点
bool a[20][20],b[20][20];//a：地图 b：是否走过
void print(int ww)//输出路径
{
	for(int i=1;i<ww;i++)
	{
		cout<<"("<<num[i][1]<<","<<num[i][2]<<")"<<"->";
	}
	cout<<"("<<num[ww][1]<<","<<num[ww][2]<<")"<<endl;
}
void ss()
{
	if(num[c][1]==z1&&num[c][2]==z2)//如果到了终点就输出路径
	{
		yes=1;print(c);return;
	}
	for(int i=1;i<=4;i++)
	{
		//从四个方向找
		if(num[c][1]+h[i]>=1&&num[c][2]+l[i]>=1&&num[c][1]+h[i]<=m&&num[c][2]+l[i]<=n)
		{
			if(a[num[c][1]+h[i]][num[c][2]+l[i]]==1&&b[num[c][1]+h[i]][num[c][2]+l[i]]==0)//可以走
			{
				b[num[c][1]+h[i]][num[c][2]+l[i]]=1;
				num[c+1][1]=num[c][1]+h[i];num[c+1][2]=num[c][2]+l[i];c++;
				ss();
				b[num[c][1]][num[c][2]]=0;c--;//回溯
			}
		}
	}
}

int main()
{
	cin>>m>>n;
	for(int i=1;i<=m;i++)
	{
		for(int j=1;j<=n;j++)
		cin>>a[i][j];
	}//读入地图
	cin>>q1>>q2>>z1>>z2;
   //读入起点与终点
	num[1][1]=q1;num[1][2]=q2;
	b[q1][q2]=1;
	ss();//搜索
	if(yes==0)cout<<"-1";//没有找到任何一个路劲输出"-1"
	return 0;
}
```
