  蒟蒻第一次发题解，有点小紧张······
  
  这题用搜索，深搜宽搜都能做
  
  ~~我比较喜欢深搜，所以我就用的它~~
  
  这道题的思路是
  
  1、从起始点开始
  
  2、依次深搜（每一步的坐标都要标记）
  
  3、到达目的地（但有时候还不能到）
  
  4、输出每一步坐标
  
  以下是代码，代码里会有较为详细的介绍呢qwq
  
```
#include<bits/stdc++.h>
using namespace std;

int mmap[20][20],//地图 
	m,n,//地图尺寸 
	a,b,//起始点坐标 
	c,d,//终止点坐标 
	s1[120],s2[120],//记录每一步的坐标 
	sum=1,//走的步数 
	dir[4][2]={{0,-1},{-1,0},{0,1},{1,0}};//四个方向 

bool flag=false;//判断有没有可行的路 

void dfs(int x,int y){//深搜 
	if ((x==c)&&(y==d))//如果到达了目的地 
	{
		cout<<"("<<s1[0]<<","<<s2[0]<<")";//输出起始点 
		for (int i=1;i<sum;i++)
		  cout<<"->("<<s1[i]<<","<<s2[i]<<")";//输出每一步 
		cout<<endl;
		flag=true;//表示有可行的路 
		return;//返回 
	}
	else//如果没有到达 
	{
		for (int i=0;i<4;i++)//尝试四种方向 
		{
			int xx=x+dir[i][0],yy=y+dir[i][1];//新坐标 
			if (mmap[xx][yy]!=0)//如果新坐标有用 
			{
				mmap[xx][yy]=0;//标记已走过 
				s1[sum]=xx;s2[sum]=yy;//记录新坐标 
				sum++;//多走一步 
				dfs(xx,yy);//继续深搜 
				sum--;//回溯 
				mmap[xx][yy]=1;//取消标记 
			}
		}
	}
}

int main()
{
	cin>>m>>n;//输入 
	for (int i=0;i<=m+1;i++)//打边框 
	  for (int j=0;j<=n+1;j++)
	    mmap[i][j]=0;
	for (int i=1;i<=m;i++)//输入 
	  for (int j=1;j<=n;j++)
	    cin>>mmap[i][j];
	cin>>a>>b>>c>>d;//输入 
	mmap[a][b]=0;//起始点标记 
	s1[0]=a;s2[0]=b;//起始点坐标标记 
	dfs(a,b);//开始深搜 
	if (!flag)//如果没有可行的路 
	  cout<<"-1"<<endl;
	return 0;
}
```
  其实吧，你也可以选择不打边框，但你就会多许多判断语句
 
  但我个人还是选择了打边框（即使它会占用一定时间与空间）
  
  因为我觉得，C++也是一门语言，它也有属于它的文学美，在保证性能的前提下，我们也要像写作文一样，让我们的代码更富美感。
  
  ~~QAQ~~