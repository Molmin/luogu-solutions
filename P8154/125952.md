易证 $n\le4$ 时无法构造。

对于 $5\le n\le 9$ 的情况，构造 $n$ 边形即可，我们在草稿构造出来 $n=5,6,8,9$ 的答案，$n=7$ 直接抄样例即可（代码中，crd 为坐标数组，第一维为 $n-5$，第二维前 $n$ 个点为白点，后 $n$ 个点为黑点，第三维分别为 $x$ 坐标和 $y$ 坐标）：
```cpp
int crd[5][18][2] = {
	{{1, 1}, {2, 2}, {0, 3}, {-2, 2}, {-1, 1}, {0, 0}, {4, 1}, {6, 6}, {-6, 6}, {-4, 1}},
	{{1, 1}, {2, 2}, {1, 3}, {-1, 1}, {-2, 2}, {-1, 3}, {0, 0}, {3, 1}, {3, 3}, {0, 4}, {-3, 1}, {-3, 3}},
	{{2, 4}, {2, 6}, {4, 6}, {5, 4}, {6, 4}, {6, 2}, {4, 2}, {0, 6}, {2, 8}, {6, 6}, {8, 2}, {6, 0}, {3, 0}, {2, 2}},
	{{1, 1}, {2, 2}, {2, 4}, {1, 5}, {-1, 1}, {-2, 2}, {-2, 4}, {-1, 5}, {0, 0}, {2, 1}, {3, 3}, {2, 5}, {0, 6}, {-2, 1}, {-3, 3}, {-2, 5}},
	{{6, 6}, {18, 18}, {18, 24}, {12, 30}, {0, 36}, {-6, 6}, {-18, 18}, {-18, 24}, {-12, 30}, {0, 0}, {18, 6}, {21, 21}, {18, 27}, {4, 38}, {-18, 6}, {-21, 21}, {-18, 27}, {-4, 38}}
};
```
对于 $N>9$ ( $N$ 为输入，$n$ 表示图形黑白点数)的情况，我们先放 $\left \lfloor \frac{N}{5}\right \rfloor-1$ 个 $n=5$ 情况的图形，再放一个 $n=N\bmod5-5(n=5,6,7,8,9)$ 情况的图形即可。

如何避免图形间产生冲突？题目给的范围足够大，我们可以完全随机放，冲突概率很低，实在不行换个种子。

白点直接输出，黑点需在全部白点输出完后才能输出，所以用一个 queue 队列记录黑点，最后再输出。
```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
typedef pair<int,int> PR;
int n;
int crd[5][18][2] = {
	{{1, 1}, {2, 2}, {0, 3}, {-2, 2}, {-1, 1}, {0, 0}, {4, 1}, {6, 6}, {-6, 6}, {-4, 1}},
	{{1, 1}, {2, 2}, {1, 3}, {-1, 1}, {-2, 2}, {-1, 3}, {0, 0}, {3, 1}, {3, 3}, {0, 4}, {-3, 1}, {-3, 3}},
	{{2, 4}, {2, 6}, {4, 6}, {5, 4}, {6, 4}, {6, 2}, {4, 2}, {0, 6}, {2, 8}, {6, 6}, {8, 2}, {6, 0}, {3, 0}, {2, 2}},
	{{1, 1}, {2, 2}, {2, 4}, {1, 5}, {-1, 1}, {-2, 2}, {-2, 4}, {-1, 5}, {0, 0}, {2, 1}, {3, 3}, {2, 5}, {0, 6}, {-2, 1}, {-3, 3}, {-2, 5}},
	{{6, 6}, {18, 18}, {18, 24}, {12, 30}, {0, 36}, {-6, 6}, {-18, 18}, {-18, 24}, {-12, 30}, {0, 0}, {18, 6}, {21, 21}, {18, 27}, {4, 38}, {-18, 6}, {-21, 21}, {-18, 27}, {-4, 38}}
};
queue<PR> bl;
int main(){
	scanf("%d",&n);
	if (n <= 4) printf("NO\n");
	else{
		printf("YES\n");
		srand(23333);
		int q = n/5-1, r = n%5+5, x, y;
		while (q--){
			x = rand(); x = (x*1000+rand())%300000-150000;
			y = rand(); y = (y*1000+rand())%300000-150000; // 随机基准坐标
			for (int i=0;i<5;++i) printf("%d %d\n",x+crd[0][i][0],y+crd[0][i][1]);
			for (int i=5;i<10;++i) bl.push(PR{x+crd[0][i][0],y+crd[0][i][1]});
		}
		for (int i=0;i<r;++i) printf("%d %d\n",crd[r-5][i][0],crd[r-5][i][1]);
		for (int i=r;i<r*2;++i) bl.push(PR{crd[r-5][i][0],crd[r-5][i][1]});
		while (!bl.empty()){
			PR now = bl.front(); bl.pop();
			printf("%d %d\n",now.first,now.second);
		}
	}
    return 0;
}
```



------------
