## 题目分析
注意到当某些 $i$ 满足 $a_i = 1$ 时，这些 $i$ 必定能被同时选为某个独立集中的元素，并注意到我们最多分别只能选择一个 $i$，满足 $a_i$ 为 $2$ 或 $3$，所以只需记录使 $a_i=1$ 的 $i$ 的个数记为答案，再从左到右扫描,如有一个 $i$，满足 $a_i=2$ 且对于 $k<i$ 的所有 $k$ 不满足 $a_k=1$，则答案++，同理对于 $a_i=3$ 的情况从右往左扫描即可，还要注意特判没有  $i$ 满足 $a_i=1$ 的情况，这种情况把答案--即可。

正确性证明：显然所有满足 $a_i = 1$ 的 $i$ 能够同时被选中，如有一个 $j$ 满足对所有 $k<j$ 都有 $a_k≠ 1$，则将这个编号为 $j$ 的节点同时选入独立集中不影响先前被选入的元素。如果没有这样的 $j$，则选入某个使 $a_i=2$ 的 $i$ 将会至少使答案减少 $1$，而选入这个节点将会使答案增加 $1$，并且只能同时选入一个这样的 $j$，所以答案不会增大。 $a_j=3$ 时的情况同理。当序列中不存在 $j$，使 $a_j=1$ 时，显然最多选取一个 $i$，但这种做法会同时选入两个节点，使它们对应的 $a_i$ 分别等于 $2$ 和 $3$，此时只需把答案 $-1$ 即可。
## 代码

注:代码中已省略快读和头文件。

```cpp
int n;
int A[510005];
signed main()
{
	int C=0;
	int cnt=0;
	n=read();
	for(int r=1;r<=n;r++)
	{
		A[r]=read();
		if(A[r]==1)
		{
			cnt++;
			C++;
		}
	}
	for(int r=1;r<=n;r++)
	{
		if(A[r]==1)
		{
			break;
		}
		else if(A[r]==2)
		{
			cnt++;
			break;
		}
	}
	for(int r=n;r>=1;r--)
	{
		if(A[r]==1)
		{
			break;
		}
		else if(A[r]==3)
		{
			cnt++;
			break;
		}
	}
	if(!C)
	{
		cnt--;
	}
	cout<<cnt;
	return 0;
}
```
