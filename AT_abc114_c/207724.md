[题目链接](https://www.luogu.com.cn/problem/AT4276)  
## 题意解释：
问在不超过 $n$ 的正整数中，只由若干个 $3,5,7$ 组成的数的个数。  
例如：$35753$ 是符合要求的数，$35743$ 就不是符合要求的数。
## 思路 & 方法：
本题 $n$ 的范围较大，使用 $\Theta(n)$ 算法将每个数都遍历一遍显然不行，故我们换个思路，不妨通过一些方式去构造所有符合要求的数。  
有一个显然的事实：**在一个符合要求的数的任意一位插入 $3,5,7$ 当中的一个数字，这个数字也是符合要求的。**  
因此，我们可以利用这个事实，不停的在数后面加上 $3,5,7$，最后判断一下此数是否集齐了 $3,5,7$ 三个数字就可以累加答案了。此过程可以用递归实现，其中在判断累加的时候使用到了位运算的知识。  
具体操作见代码注释。

------------
`Solve` 函数中的 $x$ 代表当前构造的这个数字，$cnt$ 可看为一个三位的二进制数，各位分别表示 $3,5,7$ 是否在 $x$ 中出现，$1$ 表示出现过，$0$ 表示没出现过。  
主函数中调用 `Solve` 时 $x$ 在一开始用 $0$ 表示。不难看出，$x$ 的各位中永远不会存在除 $3,5,7$ 外其他的数，故只需判断 $3,5,7$ 是否全部存在即可。
### 核心代码
```cpp
#define LL long long
int n, ans;
inline void Solve(LL x, int cnt) { 
	if (x > n) return;
	if (cnt == 7) ans++; // 即cnt在二进制下为111，说明3,5,7均在x中出现过
	Solve(x * 10 + 3, cnt | 4); // 4在二进制下为100，cnt|4意为将cnt的左数第1位变成1， 以下类似
	Solve(x * 10 + 5, cnt | 2); // 2在二进制下为010
	Solve(x * 10 + 7, cnt | 1); // 1在二进制下为001
	// 递归，每次在x的末尾加上3,5,7
	return;
}
int main() {
	n = Read();
	Solve(0, 0);
	cout << ans;
	return 0;
}
```
### 结束~Over~
