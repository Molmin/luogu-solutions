## **1. 编程思路**

   当 $n$ 等于 1 的时候，很明显方案数为 1。
   
   当 $n>1$ 时，设起始数字为 $x$，且设波动序列为 $ x,x+d_1,x+d_1+d_2, ... , x+d_1+d_2+...+d_{n-1} $
   
   其中，差值序列为 $D={d_1,d_2,d_3,...,d_{n-1}}$，任意 $d_i$ 的值为 $+a$ 或 $-b$ 之一。

   则  
   $ s =x+(x+d_1)+(x+d_1+d_2)+...+(x+d_1+d_2+...+d_{n-1})$
   
  $$     =nx+(n-1)d_1+(n-2)d_2+...+d_{n-1} $$
   由于式中任意 $d_i$ 的值为 $+a$ 或 $-b$ 之一，设 $+a$ 在和式 $s$ 中出现 $y$ 次（ $ 0 \le y \le n(n-1)/2 $ ），则 $ -b $ 一定出现 $ n(n-1)/2-y $ 次。
   
   因此，和式
   $$ s = nx + ay - b( n(n-1)/2 - y )$$ 
  $$       s+b( n(n-1)/2 )  = nx + (a+b)y $$
   
   由于 $ n,s,a,b $ 均是整数，所以原问题等价于求方程 $s+b( n(n-1)/2 ) = nx + (a+b)y$ 的整数解的个数。
   
   另外，对于 $y$ 的每种情况，可能有不同的排序。由于 $0 \le y \le n(n-1)/2$，因此 $y$ 值可看成是集合 $ U = { 1，2，3，…，n-1 } $ 的子集的所有元素之和。即对于每个 $[0, n(n-1)/2 $] 之间的每个 $y$ 值，需要知道集合 $U$ 中有多少个子集之和等于它。
   
   这个问题用 dp 解决。
   
   设 $dp[i][j]$ 表示从集合 $U$ （假设集合中元素从小到大排列）中前 $i$ 个数中选择，使得和为 $j$ 的方案数，则有
   
   1）初始状态
   
 $  dp[0] [ j] = 0 $  （前 0 个数的和非 0，显然是不可能的）
   
$ dp[i][0]=1 $  （前 $ i $ 个数的和为 0，即一个数不选，只有 1 种可能）  
   
   2）状态转移方程
   
   当 $i >j $ 时，此时第 $i$ 个元素不能选（因为选了的话元素之和肯定大于 $j$），则
$$ dp[ i][ j] = dp[ i-1][ j] $$ 
   
   当 $i \le j$ 时，第 $i$ 个元素要么选，要么不选，则有   
   
$$　dp[i][ j] = dp[i-1][ j] + dp[i-1][ j- i]   $$
 
 实质上，数组元素 $dp[i][j]$ 表示了波动序列的前 $i$  项中 $a$ 使用的次数为 $j$ 时的方案种数。前 $i$ 项中 $a$ 的使用次数和为 $j$，显然与序列顺序是有关的，即 dp 记录的方案数是与序列有关的。但只要确定了波动序列中 $a$ 的各项的分布顺序，$-b$ 也就确定了，即为一种合法的变化序列。
   
   最后，由于题目中的数据规模较大，采用二维数组进行 dp 过于浪费存储空间。因为每次更新 dp 数组时，只有它的前一个状态与当前状态有关系，因此采用一维数组完成。仿照用一维数组生成杨辉三角形的方法。
    
## 2. 源程序
```c
#include <stdio.h>
#define MOD 100000007
#define maxn 1000010
int dp[maxn];
int main()
{
    long long n,s,a,b;
    scanf("%I64d%I64d%I64d%I64d",&n,&s,&a,&b);
    int temp = n*(n-1)/2;
    dp[0] = 1;
    int i,j;
    for (i=1;i<n;i++)
    {
        for (j=i*(i+1)/2;j>=i;j--)
        {
            dp[j] = (dp[j] + dp[j-i])%MOD;
        }
    }
    // 设x为序列第一个数，a的个数为y，0=<y<=n(n-1)/2
    // 求方程 s+b*n*(n-1)/2=nx + (a+b)y的整数解个数
    int ans = 0;
    for (int y=0; y<=temp; y++)
    {
        long long tt =s+b*temp-(a+b)*y;
        if (tt%n==0)
        {
            ans = (ans + dp[y])%MOD;
        }
    }
    printf("%d", ans);
    return 0;
}

```
