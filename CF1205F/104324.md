既然这个题需要求连续段，那么析合树是一个不错的选择。但这道题是要我们构造一个析合树，我们考虑怎么运用析合树的性质把它构造出来。  
设 $C_x=\frac{x(x+1)}{2}$。
#### 1.析合树的合点儿子个数至少为 $2$，析点儿子个数至少为 $4$。  
合点儿子个数 $\ge 2$ 比较显然，因为只有一个儿子的点没有任何意义。  
析点儿子个数 $\ge 4$ 的原因是如果儿子数为 $2$，肯定要么顺序要么倒序，不满足定义。如果儿子数为 $3$，第 $2$ 个儿子肯定和第 $1$ 个或第 $3$ 个中的至少一个相邻，也不满足定义。  
#### 2.一个合点贡献的连续段个数为 $C_k$，一个析点贡献的连续段个数为 $k+1$，其中 $k$ 为儿子个数。  
合点的任意一段儿子拼起来都是一个连续段，只需要任选一个区间即可。注意这里是统计了这个合点本身构成的连续段的，因为它相当于整个区间。  
而析点任意一段儿子拼起来都不是连续段，所以任选一个儿子，再加上本身所构成的连续段即为答案。  

------
有了上面两个性质，我们就可以写出 dp 方程。  
设 $f_{i,j}$ 为 $i$ 个数构造 $j$ 个连续段是否可行。我们有两种转移方式。  
第一种是新建一个有 $k(k\ge 2)$ 个儿子的合点，其中第一个儿子用先前的，后面 $k-1$ 个儿子直接连到叶子上。会新产生 $C_k-1$ 个连续段，因为第一个儿子的自身的贡献已被计算。  
转移方程：$f_{i+k-1,j+C_k-1}=1(f_{i,j}=1)$。  
第二种是新建一个有 $k(k\ge 4)$ 个儿子的析点，其中第一个儿子用先前的，后面 $k-1$ 个儿子直接连到叶子上。会新产生 $k$ 个连续段，因为第一个儿子的自身的贡献已被计算。  
转移方程：$f_{i+k-1,j+k}=1(f_{i,j}=1)$。  
询问时检查 $f_{n,k}$ 是否合法即可判断是否存在。  

------
但是这道题还让我们输出方案，我们考虑根据 dp 数组和 $n,k$ 如何构造一个合法的排列。  
我们考虑 dfs 处理。
假设我们现在需要处理的区间为 $l,r$，我们在其中要构造出 $k$ 个连续段，设 $le=r-l+1$。  
#### 1.如果 $k=C_{le}$。  
我们直接在这里构造一个有 $r-l+1$ 个儿子的合点，它的所有儿子都是叶子。  
#### 2.我们需要在这里构造一个有 $i$ 个儿子的合点。  
首先条件是 $k>C_i+le-i$ 以及 $f_{le-i+1,k-C_i+1}=1$，因为这个合点产生了 $C_i$ 个连续段，还剩 $le-i$ 长度区间需要递归，至少会新产生 $le-i$ 个连续段。而且需要满足递归进去的区间能构造出合法的序列。  
于是先递归 $dfs(l+i-1,r,k)$，后面 $l+i-2\sim r$ 直接一字排开。  
但是有一个问题，合点的相邻儿子不能被合并在一起，所以我们需要将一些区间翻转。因此需要再记一维 $o$ 表示这个区间应该正着加还是倒着加。倒着加方法是类似的。  
#### 3.我们需要在这里构造一个有 $i$ 个儿子的析点。  
条件是 $f_{le_i+1,k-i}=1$，因为需要满足递归进去的区间能构造出合法的序列。这里没有 $k$ 关于 $i$ 的限制是因为无论 $i$ 是多少，连续段最少都是 $le$，所以没有必要。  
怎么合法地构造出一个析点呢？我们考虑间隔排开，这样每个数位置相邻的都不是在值上相邻。但有可能最后一个数与下一个区间相邻了。我们与倒数第三个数交换即可。  

上代码。  
```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=105;
int a[maxn],n,k,q,cnt,c2[maxn];
bool f[maxn][maxn*maxn];
void dfs(int l,int r,int k,bool o) {
	//表示当前在处理l~r区间，需要k个连续段，合点要求它正序还是倒序
	int le=r-l+1;
	if(k==c2[le]) {
		//直接对这个区间建一个合点，直接连叶子的。
		for(register int i=o?r:l; o?i>=l:i<=r; o?i--:i++)a[i]=++cnt;
		return;
	}
	for(register int i=2; i<le; i++) {
		if(k<=c2[i]+le-i||!f[le-i+1][k-c2[i]+1])continue;
		//建一个具有i个儿子的合点，第一个儿子继续递归。
		dfs(o?l+i-1:l,o?r:r-i+1,k-c2[i]+1,o^1);
		for(register int j=o?l+i-2:r-i+2; o?j>=l:j<=r; o?j--:j++)a[j]=++cnt;
		return;
	}
	for(register int i=4; i<=le; i++) {
		if(!f[le-i+1][k-i])continue;
		//建一个具有i个儿子的析点，第一个儿子继续递归。
		for(register int j=r-i+2; j<=r; j+=2)a[j]=++cnt;
		dfs(l,r-i+1,k-i,0);
		for(register int j=r-i+3; j<=r; j+=2)a[j]=++cnt; //奇偶分开，避免产生连续段
		if(i&1)swap(a[r-2],a[r]);//避免和后面的东西产生连续段
	}
}
int main() {
	for(register int i=1; i<maxn; i++)c2[i]=i*(i+1)/2;
	f[0][0]=1;
	for(register int i=1; i<maxn; i++)f[i][c2[i]]=1;
	for(register int i=4; i<maxn; i++)f[i][i+1]=1;
	for(register int i=2; i<maxn; i++)
		for(register int j=1; j<=c2[i]; j++) {
			if(!f[i][j])continue;
			for(register int k=2; k<maxn-i; k++)f[i+k-1][j+c2[k]-1]=1;
			//建一个有k个儿子的合点（至少有两个儿子），需要新加k-1个点，会产生 k*(k+1)/2 个连续段，但有一个是之前统计过的，所以减掉。
			for(register int k=4; k<maxn-i; k++)f[i+k-1][j+k]=1;
			//建一个有k个儿子的析点（至少有四个儿子），需要新加k-1个点，会新产生那k-1个点以及这个析点共k个连续段。
		}
	scanf("%d",&q);
	while(q--) {
		scanf("%d%d",&n,&k);
		if(!f[n][k])puts("NO");
		else {
			puts("YES"),cnt=0,dfs(1,n,k,0);
			for(register int i=1; i<=n; i++)printf("%d%c",a[i]," \n"[i==n]);
		}
	}
}
```