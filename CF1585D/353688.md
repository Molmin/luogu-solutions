## 思路

看到交换和排序后的数组，可以想到逆序对。

一个逆序对的结论：**在一个没有重复数字的序列中交换两个不同的位置 $i,j$（$i<j$），逆序对的个数奇偶性改变**。

证明：

首先，如果交换相邻的位置，则逆序对的个数只会被它们两个的关系改变，即会 $+1$ 或 $-1$。在模 $2$ 意义下相当于 $+1$。

**可以将交换不同的位置转换成交换相邻的位置**。设最左边的那个数是 $a$，右边的是 $b$，中间的区间为区间 $R$。则最开始的顺序是 $\text{aRb}$。首先，将 $a$ 和区间 $R$ 从左到右交换，此时的顺序变成了 $\text{Rab}$。其次，交换 $a$ 和 $b$，此时的顺序变成了 $\text{Rba}$。最后，将 $b$ 和区间 $R$ 从右到左交换，此时的顺序变成了 $\text{bRa}$，就完成了交换。可以发现，相邻的位置交换了 $1+(j-i-1) \times 2$ 次，所以**逆序对的个数奇偶性改变**。

但是这道题中有重复的数，所以我们先处理重复的数。当有重复的数时，**利用两个重复的数可以做到将一个重复的数与其他的一个数交换**。所以最初可以先将两个重复的数填到该放的位置上。

这个性质可以扩展到，**利用重复的数可以交换任意两个数**。比如 $\text{abc}$，$a,b$ 是要交换的两个数，$c$ 是一个重复的数。那么首先交换 $a,c$，变成 $\text{cba}$，接下来交换 $c,b$，变成 $\text{bca}$，最后交换 $c,a$，变成 $\text{bac}$，就完成了交换。

这样，剩下的数通过交换就可以都放到它们该放的地方了。因此，**重复的数一定可以排序**。

剩下的情况便是没有重复的数的情况了。考虑原操作用交换来表现出来。原操作是将 $\text{abc}$ 变成 $\text{cab}$。这个操作就等价于交换，$a,b$，变成 $\text{bac}$，然后交换 $b,c$，变成 $\text{cab}$。那么因为交换一次逆序对奇偶性改变，所以交换两次，**即原操作，逆序对奇偶性就不会改变**。而排序后的数组逆序对个数为 $0$，所以我们猜测**当且仅当逆序对个数为偶数的时候可以排序**。

首先，逆序对个数为奇数的时候，奇偶性不改变，所以一定不能排序。接下来需要构造一个方案使得任意逆序对个数为偶数的时候都可以排序。考虑先将前 $n-2$ 个位置归位。当归位第 $i$ 个位置的时候，用操作将第 $i$ 个位置、该填在这个位置的数、最后一个位置一起执行操作轮换过去即可。最后剩下两个数，此时逆序对一定为偶数，所以它们的关系一定也是顺序的。这样就排好序了。

## 代码

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n; int a[500010];
int tree[500010];
bool vis[500010];
void upd(int wz,int x)
{
	while(wz<=5e5+5)
	{
		tree[wz]+=x;
		wz+=wz&-wz;
	}
}
int get_sum(int wz)
{
	int sum=0;
	while(wz)
	{
		sum+=tree[wz];
		wz-=wz&-wz;
	}
	return sum;
}
signed main()
{
	int t; cin>>t; while(t--)
	{
		cin>>n;
		for(int i=1; i<=n; ++i) cin>>a[i];
		bool flag=0;
		memset(vis,0,n+5);
		for(int i=1; i<=n; ++i)
		{
			if(vis[a[i]]) { flag=1; break; }
			vis[a[i]]=1;
		}
		if(flag) { puts("YES"); continue; }
		int nxd=0;
		for(int i=1; i<=n; ++i)
		{
			nxd+=i-1-get_sum(a[i]);
			upd(a[i],1);
		}
		for(int i=1; i<=n; ++i) upd(a[i],-1);
		puts(!(nxd&1)?"YES":"NO");
	}
	return 0;
}
```