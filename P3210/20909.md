**HNOI2010 D2T1 纯贪心**~~+博弈论~~（不会博弈论照样可以做）

算法难度普及（小学奥数）

编程难度省选

**计算方法：**

因为石子总数固定，问题可以转换为（先手取得的总石子数-后手取得的总石子数）的差最大是多少。

用已有的0将数列分成多个子串，因为每个子串哪些石子情况不会受其余子串的影响，所以每一个子串先单独处理，再贪心选择。

**贪心策略：**

对于所有不含0连续三个数a1,a2,a3，如果a2>a1且a2>a3，唯一情况是一个人取a1和a3，另一个人取a2，所以可以将三个数合并为a1+a3-a2。

先将整个数列做上面的处理，直至没有可以合并的数为止。

处理完后，每一个子串只会有V字形、单调递增、单调递减三种情况。

对于中间的子串（即两边都可以取），直接贪心取即可，所以将处理后所有的石子堆排序，双方从最大的开始轮流取即可（易证这个过程中对于任何一堆石子，取的时候至少有一边为空）。

对于开头和结尾的子串（即只有一边可以取），开头单调上升和结尾单调下降的部分，取得时候不受影响，和中间的子串一样处理即可。其余需要特殊处理（这套题最复杂的地方）。

**特殊处理：**

这里以开头为例，结尾反过来即可。

对于单调下降的部分，如果没有，直接忽略。

如果是偶数堆石子，先取者肯定是不利的，所以双方都不愿意先取，而且即使不取也不会影响其他堆石子。所以直接轮到最后，根据取得次数可以算出哪方必须要取。

如果是奇数堆石子，情况就很多了，但有一种简单的处理方法，因为单调上升和单调下降交汇处的石子堆肯定存在（如果只有单调下降，就特指最后一堆），且使用两种处理方法皆正确，所以可以通过取舍使单调下降部分为偶数堆。

**时间复杂度：**

计算部分是O(n)，但因为需要排序，总时间复杂度是 O(nlogn)。

**调试数据：**

这个数据不是最终的测试数据，是我自己生成用来对拍的，仅供参考。

输入：

10

8042 6816 9577 4242 7198 1422 0 2363 3427 3927

输出：

30857 16157


**下面是代码，看不懂可以私信我。**

```cpp
#include<cstdio>
#include<algorithm>
using namespace std; 
long long a,b,c,d,e,f,g,h,r,s,i,m,n,x[2000000]={0},w[2000000]={0};
int main()
{
scanf("%lld",&a);
c=0;
d=0;
n=0;
g=1;
for(i=1;i<=a;i++)
{
	scanf("%lld",&b);
	d+=b;
	if(b>0)
	{
		c++;
		x[c]=b;
		while((c>2)&&(x[c-1]>x[c])&&(x[c-1]>x[c-2]))
		{
			x[c-2]=x[c]+x[c-2]-x[c-1];
			c-=2;
		}
	}
	else
	{
		if(g==1)
		{
			r=1;
			if(c>0)
			{
				f=x[1];
				m=2;
				while((m<=c)&&(x[m-1]>=x[m]))
				{
					f=-f;
					f+=x[m];
					r^=1;
					m++;
				}
				if(r==1)
				{
					m--;
					f-=x[m];
					f=-f;
					if(m>1) r=0;
				}
				for(;m<=c;m++)
				{
					n++;
					w[n]=x[m];
				}
			}
			g=0;
		}
		else
		{
			for(m=1;m<=c;m++)
			{
				n++;
				w[n]=x[m];
			}
		}
		c=0;
	}
}
s=1;
if(c>0)
{
	g=x[c];
	m=c;
	while((c>1)&&(x[c]>=x[c-1]))
	{
		g=-g;
		g+=x[c-1];
		c--;
		s^=1;
	}
	if(s==1)
	{
		g-=x[c];
		g=-g;
		c++;
		if(c<=n) s=0;
	}
	for(m=1;m<c;m++)
	{
		n++;
		w[n]=x[m];
	}
}
sort(w+1,w+n+1);
h=0;
for(m=n;m>=1;m-=2)
{
	h=h+w[m]-w[m-1];
}
if(r==0)
{
	if(n%2==0) h+=f;
	else h-=f;
}
if(s==0)
{
	if(n%2==0) h+=g;
	else h-=g;
}
printf("%lld %lld\n",(d+h)/2,(d-h)/2);
}
```