## 题意

给定一个由左括号，右括号和问号这三种字符组成的串，问号可以换作左括号或右括号。问换完所有问号后能形成的合法括号序列有多少种，对 $998244353$ 取模。

## 思路

经典 `dp` 题。

容易知道合法括号序列的每一个前缀子串都满足左括号数量大于等于右括号数量且该括号序列总的左括号数量等于右括号数量。

设 $dp_{i,j}$ 表示前 $i$ 个字符确定后左括号数量减去右括号数量的个数为 $j$ 的情况总数。则答案即为 $dp_{n,0}$。

下面考虑状态转移。

当第 $i$ 个字符为左括号时，$dp_{i,j}\leftarrow dp_{i,j}+dp_{i-1,j-1}$。

当第 $i$ 个字符为右括号时，$dp_{i,j}\leftarrow dp_{i,j}+dp_{i-1,j+1}$

当第 $i$ 个字符为问号时则以上两种转移都做。

## 代码

注意几个特判。

```cpp
string s;
ll n,dp[3005][3005];
int main(){
	IOS
	cin>>s;
	n=s.size();
	dp[1][1]=1;
	if(s[0]==')'||s[n-1]=='('||(n%2))over(0)
	for(int i=2;i<=n;i++){
		if(s[i-1]!=')'){
			for(int j=1;j<=i;j++)dp[i][j]=(dp[i][j]+dp[i-1][j-1])%mod;
		}
		if(s[i-1]!='('){
			for(int j=0;j<=i-2;j++)dp[i][j]=(dp[i][j]+dp[i-1][j+1])%mod;
		}
	}
	over(dp[n][0])
}
```
