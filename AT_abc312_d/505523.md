## 题目大意

给定包含左右括号和问号的字符串 $S$。有 $2 ^ X$ 种方法将问号改为左右括号，其中 $X$ 是 $S$ 中的问号数量。请你求出有多少种更改方法使得结果字符串为合法括号串。

题意很简单，但是思路不是很好想。

## 思路

这个题其实就是一个二维 DP，我们设 $f_{i,j}$ 为前 $i$ 个字符中 $val$ 为 $j$ 的方案数，在这里我们定义 $val$ 为一个参数，如果当前的字符 $T$ 为左括号则 $val+1$，如果当前的字符 $T$ 为右括号则 $val-1$,如果当前的字符 $T$ 为问号则分别枚举 $T$ 是左括号和右括号的情况。

## 状态转移

我们考虑最后一步决策，如果当前是左括号，我们就可以从 $f_{i-1,j-1}$ 转移过来。如果当前是右括号，我们就可以从 $f_{i-1,j+1}$ 转移过来。如果是问号呢？我们可以分别枚举它是左括号，右括号，如果是左括号，我们上面说了可以从 $f_{i-1,j-1}$ 转移过来，如果是右括号，我们上面也说了可以从 $f_{i-1,j+1}$ 转移过来，所以我们可以把这两个加在一起就可以得到我们问号的转移方程了，就是$f_{i-1,j-1} + f_{i-1,j+1}$。

## 初始化和输出答案

初始化：$f_{0,0}=1$。

输出答案：$f_{n,0}$，为什么要输出这个呢？因为我们最终要找的是前 $n$ 个中 $val$ 为 $0$ 的答案。

## 代码

~~~cpp


#include <bits/stdc++.h>
#include <bits/stdc++.h>
#define TNTMAX INT_MAX
#define db double
#define ll long long
#define ex exit(0);
using namespace std;
string s;
ll f[4000][4000];
int main() {
	cin >> s;
	ll len = s.size();
	s = ' ' + s;
	f[0][0] = 1;
	for (int i = 1; i <= len; i++) {
		for (int j = 0; j <= len; j++) {
			if (s[i] == '(' && j >= 1) {
				f[i][j] += f[i - 1][j - 1];
			}
			if (s[i] == ')') {
				f[i][j] += f[i - 1][j + 1];
			}
			if (s[i] == '?') {
				if (j >= 1) {
					f[i][j] += f[i - 1][j - 1];
				}
				f[i][j] += f[i - 1][j + 1];
			}
			f[i][j] %= 998244353;
		}
	}
	cout << f[len][0];
	return 0;
}


~~~