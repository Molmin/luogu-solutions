### 题意：

由 ``(`` 和 ``)`` 组成的字符串 $S$ 是括号字符串，当且仅当满足以下三个条件：

1. 对于所有 $i$，$S$ 的前 $i$ 个字符包含更多的 ``(`` 而不是 ``)``。

2. $S$ 包含相同数量的 ``(`` 和 ``)``。

3. 这可以通过对 $S$ 的长度进行归纳来表示。

现在给出由 ``(`` 和 ``)`` 和 ``?`` 组成的字符串，其中 ``?`` 可以代表左括号也可以代表右括号，问可以形成的括号字符串的个数 $\bmod$  $998244353$。

### 思路：

很明显，这题是个动态规划问题。

首先，我们定义一个二维数组 $dp$，其中 $dp_{i,j}$ 表示在字符串 $S$ 的前 $i$ 个字符中，有 $j$ 个左括号未匹配时，生成括号字符串的方式数量。

然后，我们从左到右遍历字符串 $S$ 的每个字符，同时更新 $dp$ 数组。

**状态转移方程如下：**

1. 如果当前字符是左括号 ``(``，那么会多一个左括号没有匹配，所以我们将 $dp_{i,j}$ 更新为 $dp_{i-1,j-1}$。

2. 如果当前字符是右括号 ``)``，那么它可以匹配一个左括号，所以我们将 $dp_{i,j}$ 更新为 $dp_{i-1,j+1}$。

3. 如果当前字符是问号 ``?``，那么它可以作为左括号或右括号使用，两种情况都要考虑，因此，我们将 $dp_{i,j}$ 更新为 $dp_{i-1,j-1} + dp_{i-1,j+1} \bmod 998244353$。

最终，$dp_{n,0}$ 就是我们的答案，因为括号字符串肯定是都匹配了的，所以第二维是 $0$。

### 完整代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=3030,mod=998244353;
inline ll read(){ //快读 
    ll x=0,f=1;
    char c=getchar();
    while(c<'0'||c>'9'){
        if(c=='-')
            f=-1;
        c=getchar();
    }
    while(c>='0'&&c<='9'){
        x=(x<<1)+(x<<3)+(c^48);
        c=getchar();
    }
    return x*f;
}
inline void write(ll x){ //快输 
	if(x<0){
		putchar('-');
		x=-x;
	}
	if(x>9)
	  write(x/10);
	putchar(x%10+'0');
}
char s[N];
ll n;
ll dp[N][N];
int main(){
    cin>>s;
    n=strlen(s);
    dp[0][0]=1;
    for(int i=1;i<=n;i++){
        for(int j=0;j<=i;j++){
        	if(s[i-1]=='('||s[i-1]=='?'){
        		if(j>0)
        		  dp[i][j]=(dp[i][j]+dp[i-1][j-1])%mod;
			}
        	if(s[i-1]==')'||s[i-1]=='?')
        	  dp[i][j]=(dp[i][j]+dp[i-1][j+1])%mod;
        }
    }
    write(dp[n][0]);
    return 0;
}
```

