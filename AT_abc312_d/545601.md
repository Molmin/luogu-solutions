# ABC312D题解
### 备注
本文中的 $|S|$ 表示字符串 $S$ 的长度。
## 题意简述
给出一个仅包含 `(`、`)` 和 `?` 的字符串 $S$，每个 `?` 都需要替换成 `(` 或 `)`，求有多少种方案使得最终的替换结果合法，答案对 $998244353$ 取模。
## 解法介绍
由于 $|S|$ 只有 $3000$，因此考虑使用动态规划。

设状态 $f_{i,j}$ 表示现在操作执行到第 $i$ 个字符，操作中 `(` 的数量减去 `)` 的数量等于 $j$。

显然，在操作过程中，如果 $j < 0$，则说明不合法。

初始化 $f_{0,0} = 1$（未开始操作时只有一种结果）。

状态转移分为三种情况：
- 若 $s_i$ 为 `(`，则下一个状态使用的是第 $i + 1$ 个字符，左括号多使用了一个，是 $j + 1$，因此转移方程为 $f_{i + 1, j + 1} \gets f_{i + 1, j + 1} + f_{i, j}$。
- 若 $s_i$ 为 `)`，则下一个状态使用的是第 $i + 1$ 个字符，右括号多使用了一个，是 $j - 1$，因此转移方程为 $f_{i + 1, j - 1} \gets f_{i + 1, j - 1} + f_{i, j}$。**注意 $j = 0$ 时不能进行此操作。**
- 若 $s_i$ 为 `?`，则前两种状态转移操作都要执行。


$i, j$ 在 $[0, |s| - 1]$ 中跑一遍，最终答案为 $f_{|S|,0}$（操作完成后 `(` 和 `)` 的数量应当一样多）。
### 注意事项
操作时要取模！
## 代码
```cpp
#include <iostream>
#include <algorithm>
#define ll long long
using namespace std;
string s;
ll f[3005][3005];
const ll mod = 998244353;
int main()
{
    cin >> s;
    f[0][0] = 1;
    for (ll i = 0; i < s.size(); i++)
    {
        for (ll j = 0; j < s.size(); j++)
        {
            if (s[i] == '(') f[i + 1][j + 1] = (f[i + 1][j + 1] + f[i][j]) % mod;
            else if (s[i] == ')')
            {
                if (j) f[i + 1][j - 1] = (f[i + 1][j - 1] + f[i][j]) % mod;
            }
            else
            {
                f[i + 1][j + 1] = (f[i + 1][j + 1] + f[i][j]) % mod;
                if (j) f[i + 1][j - 1] = (f[i + 1][j - 1] + f[i][j]) % mod;
            }
        }
    }
    cout << f[s.size()][0];
}
```