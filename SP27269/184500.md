### ~~听说~~考试之前发题解会$rp++$
作为第一个A掉这道题的人要为更多人提供~~copy~~学习资源 （有错别字，别介意，不要吐槽码风问题）  
好了，不说废话了：  
16号$CSP 2019$,这里用这道题为例谈谈蒟蒻（像我）如何考试吧！  
#### $1$.[题目传送](https://www.luogu.org/problem/SP27269)：  好好读题
##### $1.1$题面与语言
如果您打过CF就该能读懂题； 假如你不懂英语，那这道题大意是：给出一个正整数（$<1×10^5$)最少可由几个正整数的立方和组成。
##### $1.2$数据范围
这道题是小于$1×10^5$的多组数据，我们会想到用$O(nT)$或者$O(n log n)$
$(n代表数据大小，t代表数据组数)$，而这道题的时限是3s，也就是可以考虑$O(n^2)$的算法，如果你不会估算时间复杂度(我似乎也不会)，可以记下此表（1.00s）：

| 复杂度 | 能承受的大致规模 | 常见算法 |
| :----------: | :----------: | :----------: |
| $O(1)$ | 任意 | 推公式题（还有大水题） |
| $O(logn)$ | 差不多也是任意了 | 二分查找、快速幂|
| $O(n)$ | 以百万计（五六百万） | 贪心算法、扫描和遍历 |
| $O(nlogn)$| 以十万计（三四十万） | 带有分治思想的算法，如二分法 |
| $O(n^2)$ | 以千计数（两千） | 枚举、动态规划 |
| $O(n^3)$ | 不到两百 | 复杂动态规划 |
| $O(2^n)$(有时是$O(3^n),易卡常$) | 24 | 爆搜 |
| $O(n!)$ | 10 | 全排列 |
| $O(n^n)$ | 8 | 密码暴力破解 |

（呼~~）
##### $1.3$题目提示
~~有的题则没有~~ 作为c++党，这句话必须看：“For c++ users, you can use while(scanf("%d",&n)!=EOF); to read input until EOF.”他告诉你：你应该用这句话读入！！！
##### $tips$:
考试时先把三道题全读完，然后捡软的捏。
#### 2.ideas
##### $2.1$初步想法（很重要）
见到“最少” “最多”这类词首先就应该考虑贪心和$dp$，当然它俩有时是相通的（[例题 luogu P1650](https://www.luogu.org/problem/P1650)）,大多时候$dp$总是对的：
#### $dp$大法好，万物皆可$dp$,在你打暴力前先想想能否$dp$!!!
你可以在本上笔演一下思路，当然可以简证一下（一场比赛10草稿纸了解下），
当然也可以打在你的程序上（别忘了注释掉）。
##### $2.2$确定了之后
你最好写下伪代码，以防在码题时忘掉思路（大佬请跳过）
##### $2.3$假如你发现错误
可以先写下错误，如果时间充足，可以做别的题冷静下，一会再回来做此题；
### 考试番外篇（重点）：
对于此题思路：  
我们考虑设f[i]代表数i最少可由几个数个立方和组成；
#### Q1:为啥这样设？
#### A1：像数学方程应用题一样，尽量考虑求谁设谁。
#### Q2：为什么是一维数组？
#### A2：一位数组有好写又节省空间（就算这个题有1.4GB）。正经些：此题只有两个变量（出了数据组数）：数的大小，此数最少可由几个数个立方和组成，如果你将后缀设成后者，将导致统计不全（当然可以用求谁设谁理解）。
#### Q3：动态转移方程？
#### A3：急什么这是后面的戏，别抢。
~~下一步就是动态转移方程了~~，我花了老长时间A掉之后，同桌就来切它：他的方程是：$f[i]=min(f[i],f[i-pow(j,3)]+f[pow(j,3)]$  
然而就炸了，我就帮他调程序（我第一次给他调，~~大哥看到别怼我~~）：$f[pow(j,3)]$不就是1吗？
#### 这就是区间$dp$!!
#### 所谓区间$dp$就是把一段大区间分成两个或多个区间去$dp$，在我不会时，做区间的题自己$yy$的算法（放心，我爆零了）类似二分（还是倍增？），不过他俩是真的像！
所以方程就是$f[i]=min(f[i],f[i-pow(j,3)]+1)$,然后主程序就是
```
int main()
{
	f[0]=0;
	f[1]=1;//初始化
	while(scanf("%d",&n)!=EOF)
	{
		for(int i=n;i<=n;i++)
		{
			for(int j=1;j*j*j<=i;j++)
			{
				f[i]=min(f[i],f[i-pow(j,3)]+1)；
			} 
		}
		cout<<"Case #"<<k<<": "<<f[n]<<"\n";
		k++;
	}
	return 0;
}
```
试了试样例还是炸了。
#### Q4：为啥？
#### A4：~~你咋又来了？~~由于数组f未初始化 ,c++初始定义的变量、数组初始值都是$0$（bool型是false），在做min函数时一定都返回0（除了f[1]）。
#### Q5:那也就是说初始化不全喽，除了f[1]全赋成一个大于$1×10^5$的数不就行了？比如2147483647。再把$f[j^3]$赋成1不就好了？
#### A5：可以是可以，不过挺麻烦，还要算$log_3(1×10^5)$次乘法和一个memset，不如这样：
```
if(f[i]>=f[i-j*j*j]+1||f[i]==0) f[i]=f[i-j*j*j]+1;
```
#### 这就排除了f[x]=的危害；
终于过了样例，提交下结果${\color{Blue}TLE}$
#### Q6:$dp$错了？
#### A6:让我看看，emmmm......,如果后面要求求出的如果以算过就不用算了。只用定义一个变量$maxn$表示更新到的最大数值，如果输入的$n<maxn$，那就直接输出$f[n]$。否则就进行循环，$i$从$maxn$开始扫就行了，大概像搜索剪枝一样吧，$dp$的本质就是记忆化搜索吧！
下面给出代码：
```
int main()
{
	f[0]=0;
	f[1]=1;
	while(scanf("%d",&n)!=EOF)
	{
		if(maxn>=n)
		{	
			cout<<"Case #"<<k<<": "<<f[n]<<"\n";
		}
		else 
		{
			for(int i=maxn;i<=n;i++)
			{
				for(int j=1;j*j*j<=i;j++)
				{
					if(f[i]>=f[i-j*j*j]+1||f[i]==0) f[i]=f[i-j*j*j]+1;
				} 
			}
			maxn=n;
			cout<<"Case #"<<k<<": "<<f[n]<<"\n";
		}
		k++;
	}
	return 0;
}
```
你以为这片题解终于完结了？——这只是番外篇（手动滑稽）
#### 番外篇结束
#### $3$.打完代码
##### $3.1$当然是代入样例了
##### $3.2.1$如果样例过了：
假如样例比较水，那你可以自己$hack$自己的程序（有些违和感），也可以生成大数据；  
如果你打了两种程序（建议），可以打一下对拍（蒟蒻不会，在线求！！）验证一下。
##### $3.2.2$但如果样例没过呢：
如果时间充足，那你可以考新思路；  
如果时间较为紧张，可以考虑骗分（暴力也属于偏分），假如你不懂如何骗分，可以参考这篇博客：[tql](https://vijos.org/discuss/5343eb6c48c5fc86468b457d)（我相信你将收获巨大）  
不过还有更高级的调试法（假如你不会c++调试更改看看）：
### 人工调试（我想大佬还是跳过吧）：
就是让计算机输出他每一步的运算结果（高大上的名字，无比$low$的内涵）：
此题我的人工调试就帮我找到了错误，代码（改完后的代码，该之前的找不到了）：
```
int main()
{
	f[0]=0;
	f[1]=1;
	while(scanf("%d",&n)!=EOF)
	{
		if(maxn>=n)
		{	
			cout<<"Case #"<<k<<": "<<f[n]<<"\n";
		}
		else 
		{
			for(int i=maxn;i<=n;i++)
			{
				for(int j=1;j*j*j<=i;j++)
				{
					//f[i]=min(f[i],f[i-j*j*j]+1);
					//cout<<i<<" "<<f[i]<<" "<<j<<" "<<f[i-j*j*j]+1<<"\n";
					if(f[i]>=f[i-j*j*j]+1||f[i]==0) f[i]=f[i-j*j*j]+1;
					//else f[i]=f[i];
					//cout<<"f["<<i<<"]=="<<f[i]<<"\n";
                                     	//像打表一样输出每一步的dp过程
				} 
			}
			maxn=n;
			cout<<"Case #"<<k<<": "<<f[n]<<"\n";
		}
		k++;
	}
	return 0;
}
```
~~（我线段树也是用这个调的呢）~~
##### $3.3$如何检查：
###### $3.3.1$文件输入输出
检查你的$freopen$对没对，常出现的问题：  
$3.3.1.1$ 文件名对不对，少没少字母，多没多字母（建议直接复制）；  
$3.3.1.2$ 先写$r$，在写$w$；   
$3.3.1.3$ $in$和$out$的顺序（如果你下面直接从上面复制更改注意）；  
简单的判断方法：自己让它自己跑一次就好了
###### $3.3.2$特殊情况
很重要：有时就是省队和裸省一的区别：[例题 luogu P2158](https://www.luogu.org/problem/P2158)  
###### $3.3.3$注释
注释该删的删，该写的写，不能马虎（论%你赛如何爆零）
###### $3.3.4$输出格式
~~这个题我就因为冒号后面的空格被卡了两次，改的时候只改了后面的情况~~  
对了，还有字母的大小写；  
最后个人建议最后输出一个换行符，最好用$endl$,有人被$\n$卡掉了（真是飞来横祸）
#### Q7：就这些吗？
#### A7：咳咳，你是番外篇的演员，不怕被解雇？ 当然不是，不过类似数据稍稍开大，运算顺序，变量存储，$long long$,$SPFA$等问题就~~当~~你们都知道吧。
#### $4$ 关于时间（非复杂度问题）
##### $4.1$模拟STL加速
##### $4.2$入果您钟爱于$cin$和$cout$，请使用健胃消食片（ios::sync_with_stdio(false);）以防撑着
##### $4.3$如果还不行请想想更快的算法，或~~背过~~以下$fread$代码:
```
inline int read()
{
    int X=0,w=1; char c=getchar();
    while (c<'0'||c>'9') { if (c=='-') w=-1; c=getchar(); }
    while (c>='0'&&c<='9') X=(X<<3)+(X<<1)+c-'0',c=getchar();
    return X*w;
}
```
使用方法:  
$cin>>n$$ \xLeftarrow{} \xRightarrow{} $$n=read()$ 
在文章的结尾，我相信能看完此帖的大佬你定会留些一个赞吧！
### 对了，似乎忘了什么，哦，是小Q和留下一个：
## ${\color{Red}CSP2019 rp++}$