用一些小技巧可以做到 $O(n\sqrt n)$。

瓶颈在于 $O(\sqrt n)$ 计算那个诡异的预处理数组。

我们预处理一个东西：每个八位前缀对应的后缀的 $\max$，然后在上面建 01trie，这个显然是 $O(\sqrt n)$ 的。

然后要对 $x\in [0,256)$ 求出每个数的最优匹配。

按位考虑每一位。

* 如果这里同时有 $0,1$，那么我们把所有 $0$ 都去匹配 $1$，所有 $1$ 去匹配 $0$ 即可。
* 如果这里只有 $0/1$。那么所有的数都只能匹配这个 $0/1$。

用一个 dfs 维护上面的过程。会发现填到最后有一些位是确定的，其他的不确定。

先把确定的位压起来，考虑不确定的位。

会发现如果有 $x$ 个不确定的位，把这些位置用栈存起来，可以直接 $O(2^x)$ 再用一个 dfs 求出对应的每个数。这里总时间复杂度 $O(\sqrt n)$，因为保证了每个数只被求一次。

比较抽象，可以看[~~洛谷评测记录~~](https://www.luogu.com.cn/record/89262469)[CF 评测记录](https://codeforces.com/contest/840/submission/175229652)。

btw，这题解法和值域没啥关系。纯粹是因为复杂度要求 $O(n2^k+\dfrac {nq} {2^k})$，取 $2^k=\Theta(\sqrt q)$ 而已。