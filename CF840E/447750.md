给定一棵有根树，带点权 $a_i$，$q$ 次给定 $u$ 是 $v$ 的祖先，询问 $\max_{p\in path(u,v)}\{a_p\oplus dis(p,v)\}$。

$1\leq n\leq 5\times 10^4$，$1\leq q\leq 1.5\times 10^5$，$0\leq a_i\leq n$。

考虑序列上的问题：询问 $i\in [l,r]$ 最大的 $a_i\oplus dis(i,r)$。朴素地，在右端点从左往右移动的时候以某种方式维护答案，把询问挂到 $r$ 处并回答。如果每步的操作把右端点增加 $S$，原本贡献为 $a_i\oplus dis_i$ 的则会改为 $a_i\oplus (dis_i+S)$，考虑到异或和加法之间的性质非常不优美，所以我们希望其能够都是同一类运算。 并且由于步长为 $S$，可以看作每次都是以当前的 $r$ 为右端点，从右向左每 $S$ 个分一个块。

观察到当我们可以始终把 $dis_i$ 写为 $d_i+D\times S$，其中 $d_i$ 是以当前的 $r$ 从右往左每 $S$ 个分一个块，$i$ 到块尾的距离，值在 $0$ 到 $S-1$ 之间，每个 $i$ 对于不同的分块类型，有 $S$ 个值不同的 $d_i$，并且这个值不会因为右端点的移动为改变，仅会由于分块类型不同而不同，后面考虑的都是当前右端点为某个块末尾时对应的 $d_i$。则当 $S=2^k$ 时，有 $d_i+D\times S=d_i\oplus(D\times S)$。

此时一个很清晰的思路是，如果维护了 $S$ 类分块（代价是空间变为 $O(nS)$），在从左向右枚举右端点的情况下，贡献可以被改写为 $a_i\oplus d_{x_r,i}\oplus(D\times S)$，其中 $d_{x_r}$ 是上面提到的，以 $r$ 从右向左每 $S$ 个分一个块，每个点到右端点的距离，表示一类 $d$ 的初值；$D$ 是 $i$ 所在的块与 $r$ 所在的块中间有多少个整块。

发现可以对于每种分块类型 $x_r$（取值仅有 $S$ 种），维护块内 $a_i\oplus d_{x_r,i}$ 的 01Trie（共 $n$ 棵，每棵 $S$ 个元素），枚举 $D$（取值仅有 $\frac{n}{S}$ 种）去对应整块的 Trie 上查询 xor 最大值，散块暴力询问，这样时间复杂度为 $O(nS\log V+q\frac{n}{S}\log V+qS)$，分别对应每类分块的插入和查询，视作 $n,q$ 同级，则取 $S$ 为 $O(\sqrt n)$ 时时空复杂度做到 $O(n\sqrt n\log V)$，并且还需要 $S=2^k$，于是取 $S=256$。

注意到 $D\times S$ 的后 8 位都是 0，于是只需要向 Trie 插入 $a_i\oplus d_{x_r,i}$ 的前 8 位，并在叶子结点维护对应后八位的 $\max$，则 $\log$ 小了一半，但空间依然难以接受。发现没有必要真的把 $n$ 个块对应的 Trie 树全部保留，只需要对于每个点分别建一次 Trie，预处理答案，然后这棵 Trie 就不必保留了。则时间复杂度为 $O(n\sqrt n\log V+q\sqrt n)$，空间复杂度为 $O(n\sqrt n)$。

对于树上问题，从每个点维护向上 $S$ 个点构成的块，查询答案时逐步跳 $S$ 级祖先。[Submission](https://codeforces.com/contest/840/submission/176818628)。