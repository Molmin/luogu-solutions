说句闲话，本题对标的是[洛谷的P1145](https://www.luogu.com.cn/problem/P1145)，可以先做那道。

**1.题意简述**

一个环形数组，前 $k$ 个为好人，后 $k$ 个为坏人，从第一个人开始报数，第一个人报 $1$，以此类推，报到 $m$ 的人就会移除数组，如果这个人是好人，则当前的 $m$ 不成立，如果是坏人，且是当前唯一一个还在数组里的坏人，则 $m$ 成立，换句话说，找到一个最小的成立的 $m$，使得坏人在第一个好人“走”前，全部移除。

**2.做法**

因为 $k$ 是已知的条件，所以我们也就知道，数组有 $2k$ 个元素，爆搜肯定 TLE，但枚举 $m$ 依旧是这题最简单的思路，由于第一个坏人在 $k+1$ 处，所以 $m$ 的值最小为 $k+1$，由样例看出，这个 $m$ 的值理论上没有上限，所以要使用 while 循环。

“所有坏人要在第一个好人处死前全被处死”，看出整个过程需要杀死所有坏人，则共进行 $k$ 次报数，由于这样枚举会超时，所以可以记录下上一个死人的位置，下一次用上个人的位置加 $m$ 即可，环状数组还要模上当前数组长度。

确定要杀的人后，看看他是不是坏人，如果是，判断他是不是最后一个坏人，如果是，则 $m$ 成立，直接输出；如果他不是坏人，当前 $m$ 就不成立了。

可是交后还会超时，所以我们想到可以学 dfs 处理这种问题的方法——记忆化！运行后，记录当前 $k$ 对应的答案 $m$，等下次遇到就直接输出（这么说可以打表咯）。

**3.代码**

```cpp
#include<iostream>
using namespace std;
int a[15];
int main(){
	int n,m,k;
	while(cin>>k&&k){
		if(a[k]){
			cout<<a[k]<<endl;
			continue;
		}
		m=k;
		bool flag=1;
		while(flag){
			m++;
			int pt=0;
			for(int i=0;i<k;++i){
				pt=(pt+m-1)%(2*k-i);
				if(pt<k)break;
				if(i==k-1)flag=0;
			}
		}
		cout<<m<<endl;
		a[k]=m;
	}
} 
```
