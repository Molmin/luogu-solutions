[传送门](https://www.luogu.com.cn/problem/UVA305)

这题真的算是双倍经验了，和 [P1145](https://www.luogu.com.cn/problem/P1145) 一模一样。所以如果按照 P1145 的难度，这题绿确实是评高了。

# 题意

直接去 P1145 看。对于这里的题面，补充一句：$k$ **个好人和坏人分别站在一起。**

# 思路

这题是约瑟夫问题的改版，首先先了解什么是约瑟夫问题。

**约瑟夫问题原版**

有 $n$ 个人**围成一圈**，从第一个人开始数数，数到 $m$ 的人出局。然后从这个人的下一个人开始数数，依次类推。求最后剩下的一个人。

例如 $n=4,m=3$ 的约瑟夫：

- 第一次淘汰，$3$ 号出局；

- 第二次淘汰，$2$ 号出局；

- 第三次淘汰，$4$ 号出局；

最后剩下 $1$ 号。

思路有非常多，最暴力的思路就是枚举出局的 $n-1$ 人的顺序，然后数 $m$ 次，跳过出局的人。

**约瑟夫问题改版**

题目在 P1145 里面有。先假设 $k$ 个坏人的编号为 $k+1$ 到 $2k$。

首先 $m$ 必然大于 $k$，否则第一个淘汰的就是好人。然后枚举 $m$，求出出局者编号，如果出局者编号编号小于 $k$，那么代表淘汰了好人，就下一个 $m$。

如果淘汰人数恰好等于 $k-1$，那么代表 $k$ 个坏人恰好都被淘汰了，然后就确定了最小的 $m$。

# 代码

改版的代码在这里。

```cpp
#include <cstdio>
#include <iostream>
using namespace std;

int main(){
    int k,i;
    cin>>k;
    bool flag = true;
    int m = k;
    while (flag){
        m++;
        int tmp = 0;
        for (i = 0; i < k; i++){
            tmp = (tmp + m - 1) % (2 * k - i); //出局者编号
            if (tmp < k) break; //好人是否被淘汰
            if (i == k - 1) flag = false; //所有坏人均被淘汰。
        }
    }
    printf("%d\n",m);
    return 0;
}
```

# 另外的东西

然而，这题是**多组数据**。但是它并没有数据组数的范围。

复杂度 $O(kq)$。如果 $q$ 大的离谱，就会 TLE。

大概这题评绿的原因是希望我们通过优化原来的思路来 AC 题目，但是我们可以打表。

因为 $k$ 的范围是一样的，所以可以直接用 P1145 的代码打表，实现 $O(1)$ 查询。

打表代码：

```cpp
#include<iostream>
using namespace std;

int a[20]={0,2,7,5,30,169,441,1872,7632,1740,93313,459901,1358657,2504881};
int n;
int main(){
    cin>>n;
    cout<<num[n]<<endl;
    return 0;
}
```

