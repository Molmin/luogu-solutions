## 题目描述

对于一个序列 $X$，我们设函数 $f(X)$ 表示将 $X$ 修改为回文串需要修改的数的数量。

现在，给定一个长度为 $N$ 的序列 $A$，问 $A$ 的所有连续的子序列（也就是子串）的 $f(X)$ 的值的和。

## 样例输入输出

```
5
5 2 1 2 2
```

```
9
```

## 数据范围

$1 \le A_i \le N \le 2 \times 10^5$

## 思路

对于一对数，如果两个数不相同，则称这个对是“坏对”，否则这个对是“好对”。

如果要求所有的 $f(X)$ 的值的和，就相当于要求所有的坏对会影响到的区间的总数。

什么叫做影响到的区间呢？

![image](https://img1.imgtp.com/2023/04/08/4oyJjmLe.png)

上图中，如果 $3$ 与 $5$ 是不同的，那么如果要求 $f(3, 4, 5)$ 或 $f(2, 3, 4, 5,6)$ 时，由 $3$ 和 $5$ 所构成的影响数就各多了 $1$。因此我们就称 $3$ 和 $5$ 这个坏对所造成的影响为 $2$。

## 暴力

如果找到一个坏对，那么它就会造成若干各不好的影响。形象到的区间的总数为 $\min(l, n-r+1)$。

如果存在一个坏对，那么他会影响到它左右两边的区间，并且这个区间两个端点距离当前这个坏对的端点的距离是一样的。那么，只需要求出左右两边各存在多少个点，并取最小值即可。

```cpp
for(int i=1; i<=n; i++){
	for(int j=i; j<=n; j++){
		if(a[i] != a[j]){
			res += min(i, n-j+1);
		}
	}
}
```

暴力时间复杂度是 $\Theta(n^2)$，显然不可取。

## 优化

如果要求坏对影响的数量，那么可以求出所有对影响区间的数量，再减去所有对影响区间的数量。

求解这两个值我们使用双指针算法。

### 所有对影响区间的数量

令 $l$ 指向第 $1$ 项，$r$ 指向最后 $1$ 项。

首先分别统计出当前 $l$ 即 $l$ 左边元素的数量为 $x$，$r$ 即 $r$ 右边元素的数量为 $y$。那么就有 $x = l, y = n - r + 1$。

如果左边的数量小于右边的数量，那么产生的影响为 $(r - l) \times x$。此时我们认为与 $l$ 构成的对已经算完了，那么将 $l$ 向右移动。

否则，如果左边的数量大于右边的数量，那么产生的影响为 $(r - l) \times y$。此时我们认为与 $r$ 构成的对已经算完了，那么将 $r$ 向左移动。

```cpp
l = 1, r = n;
while(l < r){
	int x = l;
	int y = n - r + 1;
	if(x < y){
		res += (r-l) * x;
		l++;
	}
	else{
		res += (r-l) * y;
		r--;
	}
}
```

### 好对影响区间的数量

首先统计出所有数字出现的位置存于 `vector<int> v[N]` 。

统计出来后，我们每个数字的看，这样就保证目前统计的数都是相同的。

再令 $l$ 指向当前数字位置的第 $0$ 项，$r$ 指向最后 $1$ 项。（`vector` 是从 $0$ 开始）

对于每一次计算得到的 $l, r$ 对，首先找到两个值再原数组中的实际位置，即 `int ll = v[e][l], rr = v[e][r];`。

与上面类似，分别统计出当前 $ll$ 即 $ll$ 左边元素的数量为 $x$，$rr$ 即 $rr$ 右边元素的数量为 $y$。那么就有 $x = ll, y = n - rr + 1$。

如果左边的数量小于右边的数量，那么产生的影响为 $(r - l) \times x$。此时我们认为与 $l$ 构成的对已经算完了，那么将 $l$ 向右移动。

否则，如果左边的数量大于右边的数量，那么产生的影响为 $(r - l) \times y$。此时我们认为与 $r$ 构成的对已经算完了，那么将 $r$ 向左移动。

```cpp
for(auto e : s){		// 枚举所有出现过的元素，s 表示出现过的元素所构成的集合 
	int l = 0, r = v[e].size() - 1;
	
	if(v[e].size() >= 2){		// 必须能构成对 
		while(l < r){
			int ll = v[e][l], rr = v[e][r];
			int x = ll, y = n - rr + 1;
			
			if(x < y){
				res -= (r - l) * x;
				l++;
			}
			else{
				res -= (r - l) * y;
				r--;
			}
		}
	}
}
```

## 代码

```cpp
AC 代码
#include <iostream>
#include <vector>
#include <set>

using namespace std;

const int N = 2e5 + 10;

int n, x, res;
vector<int> v[N];
int l, r;
set<int> s;		// 出现过的元素构成的集合 
int a, b;

signed main(){
	// 读入 
	scanf("%lld", &n);
	
	for(int i=1; i<=n; i++){
		scanf("%lld", &x);
		v[x].push_back(i);		// x 元素在 i 上出现了一次 
		s.insert(x);
	}
	
	// 所有对影响区间的数量
	l = 1, r = n;
	
	while(l < r){
		if(l < n - r + 1){
			res += (r - l) * l;
			l++;
		} 
		else{
			res += (r - l) * (n - r + 1);
			r--;
		}
	}
	
	// 好对影响区间的数量
	for(auto e : s){
		l = 0, r = v[e].size() - 1;
		while(l < r){
			a = v[e][l], b = v[e][r];
			if(a < n - b + 1){
				res -= (r - l) * a;
				l++;
			}
			else{
				res -= (r - l) * (n - b + 1);
				r--;
			}
		}
	}
	
	// 输出 
	printf("%lld", res);
	
	return 0;
}
```
