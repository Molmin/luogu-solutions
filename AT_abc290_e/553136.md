#  1. 题意
 
一个长度为 $N$ 的序列 $X$，求将 $X$ 的每个连续子序列分别变成回文串所需要的最小操作次数。
 
#  2. 分析
将每一对点 $l$ 和 $r$ 进行连线：如果相等，称作它们的连线为好线，如果不等，称作坏线。

为什么要这样做呢？我们发现，对于每一对坏线，他都会在一定的区间内，产生答案的贡献。举例：$A={1,2,4,2,3}$，对于 $a_2$ 和 $a_3$，它们之间连了一条坏线，会使 $[2,3]$ 和 $[1,4]$ 两个区间的答案增加，从而对总答案产生贡献。

不难发现，只有坏线会对总答案产生贡献，而坏线其实不好直接计算，我们考虑用总线的数量减去好线的数量。发现数据范围：所有的 $a_i \le n$，开一个数组，记录某个数出现的所有位置，从而计算好线的对答案的贡献。好线的贡献，也可以理解为这对线能让最终答案减少多少。如果 $a_i=a_j$，那么他们对答案的贡献就是 $min(l,n-r+1)$。

接下来，假设 $P_x$ 数组存储了 $x$ 这个数在序列中所有出现的位置，比如 $A={1,2,4,2,3}$，则 $P_2={2,4}$。

设 $l=0$，$r=size(P_x)-1$，可以发现，如果 $P_{x,l}<n+1-P_{x,r}$，那么对于 $P_{x,l}<n+1-P_{x,r-1}$，$P_{x,l}<n+1-P_{x,r-2}$，...，$P_{x,l}<n+1-P_{x,l+1}$，它们都是成立的，所以它们的贡献都是 $P_{x,l}$。总共献即 $(r-l) \times P_{x,l}$。同时，以 $l$ 为左端点的所有区间都处理完了，所以 $l+1$，另外一种情况同理。

细节见代码。
# 3.代码

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,a[200005],ans;
vector<vector<int> >V(200005);//V[i]存储数i的所有出现位置 
signed main(){
	cin>>n;
	for(int i=1;i<=n;i++)cin>>a[i],V[a[i]].push_back(i);
	for(int i=1;i<=n;i++){
		ans+=(n-i+1)*(i/2);//计算所有线的数量 
		int l=0,r=V[i].size()-1;
		while(l<r){
			ans-=(r-l)*min(V[i][l],n+1-V[i][r]);//ans减去"好线"的数量就是坏线的数量 
			(V[i][l]<(n+1-V[i][r]))?l++:r--;//类似双指针写法 
		}
	}
	cout<<ans;
	return 0;
}
}
```