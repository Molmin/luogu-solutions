> 第一个完全自己想出来并且一次过还拿了最优解的 dp 紫题 qaq

> 做法大体同其它题解一致，但这里判断左侧指针位置用的方式稍有不同，是根据段的划分位置而非完整装饰子集的构成。也许这样常数稍微小一点？

根据插板法的老套路，将 $n$ 个元素分为若干段，其中有 $n-1$ 处可作为两段的分界，则问题转化为将若干插板放在 $n-1$ 个有序位置。

根据集合原理类比位运算，一个数 $a_i$ 不在“装饰子集”中即存在一个 $j$ 使得 $a_i\neq a_j$ 且 $a_i\&a_j=a_i$，也就是说 $a_i$ 中有的位 $a_j$ 都有，而且 $a_j$ 中还有些 $a_i$ 中没有的位，那么可以感性理解成 $a_i$ 被 $a_j$ 完爆了。。。

现在可以认为装饰子集的元素就是那些没有被别人完爆的大佬。。。相比原来，分段后只是踢出了一些人，没被踢出的大佬一定还是大佬。。。不妨称 **整个数组装饰子集中的元素为优势元素**，所以分段后，**对于每个优势元素，它在分段后一定还在它所在段的装饰子集**。当然，根据每段装饰子集一致的要求，可推出 **对于每个优势元素，它在每一段中至少出现了一次 【条件 A】**。

接下来讨论非优势元素。它们能不能再分段后翻身做大佬呢？假设一个非优势元素翻身成功了，据题意则每个区间它们都加入了装饰子集，那么原来完爆它的大佬就无处安放了 qaq。因此 **对于每个非优势元素，它在分段后中一定仍不在该段的装饰子集中 【条件 B】**。

$a_i$ 比较小，我们可以考虑枚举优势元素。不过在这之前，我们要先找出所有的优势元素。原始的想法是枚举所有 $i\&j=j,i\neq j$，但这样时间复杂度不可接受。考虑到 $j$ 可以通过 $i$ 删去若干位 $1$ 得到，我们将 $i$ 和所有“删去一位 $1$”得到的 $j$ 连边，那么 $i$ 一定能直接或间接走到所有满足条件的 $j$。这样，总边数是 $\max\{a_i\}\log_{\max\{a_i\}}$ 级别的，边总是由大向小连的，拓扑排序就行了。

显然如果条件 A 满足了，条件 B 也自动满足，因此我们只讨论条件 A。对于每个 **优势元素** $x$，找到它在数组中所有出现位置：

![](https://cdn.luogu.com.cn/upload/image_hosting/bh3l8al0.png)

我们根据这些位置设置一些限定条件（见上图）：

$\small\tt\color{#6cf}蓝色区间$：最左侧 $x$ 的左边和最右侧 $x$ 的右边，这区间总是贴着边缘的，直接维护不在蓝色区间的左右端点就行了。（当然，如果存在一个 $x$ 只出现一次，那么就可以直接输出 $1$ 跑路啦）

$\small\tt\color{#39c5bb}绿色区间$：每两个相邻 $x$ 的中间部分。这个范围内最多插一个版，我们把这个区间记下来，作为一个“最多一个”的区间。

我这里的插板位置 $i$ 指的是 $a_i$ 和 $a_{i+1}$ 的间隔，因此左侧 $a_l$，右侧 $a_r$ 的区间对应下来就是 $[l,r-1]$。

接下来，我们将提取所有 **有效的“最多一个区间”**。若 $[l_1,r_1]$ 是“最多一个区间”那么 $[l_2,r_2]\ (l_1\leq l_2\leq r_2\leq r_1)$ 也是“最多一个区间”， 设 $rp_i$ 为满足 $[i,rp_i]$ 为“最多一个区间”的最大值，用以下三步骤得到 $rp_i$：

1. 显然 $[i,i]$ 是“最多一个区间”，$rp_i$ 初值设为 $i$。

2. 对于所有以 $i$ 为左侧的绿色区间 $[i,r]$，将 $rp_i$ 与 $r$ 取最大值。

3. 若 $rp_{i-1}\geq i$，则 $[i,rp_{i-1}]$ 也是“最多一个区间”，将 $rp_i$ 与 $rp_{i-1}$ 取最大值。

因为左端点比较好维护，我们称 **所有 $[i,rp_i]$ 为有效区间**。我们 **设 $dp_i$ 为最后一个版插在 $i$ 处的方案数**。

![](https://cdn.luogu.com.cn/upload/image_hosting/mhy0linb.png)

（见上图）那么，可以得到状态转移方程：

$$dp_i=\begin{cases}1+\sum_{1\leq j<i,rp_j<i}dp_j\small\ (i\ 不在蓝色区间内)\\0\small\ (i\ 在蓝色区间内)\end{cases}$$

我们动态维护一个指针 $p$（初始为 $0$），表示满足 $rp_p<i$ 的最大值。因为 $rp_i$ 是单调不减的，所以 $p$ **也是单调不减的，直接维护双指针+前缀和即可**。

最终答案即为 $1+\sum_{i=1}^{n-1}dp_i$

Code（143 ms，暂时是最优解）:

```cpp
#define lowbit(x) (x&(-x)) // 求 x 最低位的 1
int main() {
	int n=read(), mx=0;
	// pre[i] : 前一个与 a[i] 相同数的位置
	// lst[i] : 最后一个值为 i 的位置
	for (int i=1; i<=n; ++i) {
		int x = read();
		pre[i]=lst[x]; lst[x]=i;
		mark[x]=2; mx=max(mx,x);
		rp[i] = i; // rp 计算的第一步
	}
	// mark[i] : (0:i 未被数组元素完爆，但也未出现; 1:i 被数组元素完爆; 2:i 是优势元素)
	int accl=1, accr=n-1; // 未在蓝色区域的左右边界
	for (int i=mx; i>=0; --i) {
		if (!mark[i]) continue; // 未出现、被直接完爆或间接完爆，无法参与拓扑排序的标记
		if (mark[i]==2) { // 枚举每个优势元素 i
			int pos=lst[i]; accr=min(accr,pos-1); // a[pos] 是最右侧的 i，设置右侧的蓝色区域
			if (!pre[pos]) { // i 只有一个，挡板无处可放
				printf("1"); return 0;
			}
			int nxt=pos; pos=pre[pos];
			while (pos) {
				rp[pos] = max(rp[pos],nxt-1);
				// a[nxt] 和 a[pos] 是两个相邻的 i，在 [nxt,pos-1] 设立绿色区域，rp 计算的第二步
				nxt=pos; pos=pre[pos];
			}
			accl = max(accl,nxt); // a[nxt] 是最左侧的 i，设置左侧的蓝色区域
		}
		if (accl>accr) { // [1,n-1] 已被蓝色区域填满，挡板无处可放
			printf("1"); return 0;
		}
		int pos = i;
		while (pos) {
			int val=lowbit(pos); mark[i^val]=1;
			// val 为 i 中的每一位 1，i^val 即将 i 的一位 1 换成 0 的结果，让它被完爆
			pos ^= val; // 类似树状数组，枚举 i 每位 1 的套路
		}
	}
	--n; for (int i=1; i<=n; ++i) rp[i]=max(rp[i],rp[i-1]); // rp 计算的第三步
	int pos=0, res=1, pre=1; // 别忘了没插挡板的情况
	for (int i=accl; i<=accr; ++i) { // 在蓝色区域的位置已被该循环忽略
		while ((pos<n)&&(rp[pos+1]<i)) { // 因为 i 的增加，p 动态右移
			++pos; pre+=dp[pos]; if (pre>=MOD) pre-=MOD; // 同时统计 dp 前缀和
		}
		dp[i]=pre; res+=pre; if (res>=MOD) res-=MOD;
	}
	printf("%d", res);
	return 0;
}
```

> 这题的确解法非常巧妙，不需要高级的算法和数据结构却能环环相扣，最后柳暗花明又一村，好久没体验到这种 OI 独有的快乐了呢。 （最后一提 miku 赛高!qwq）