## [题目链接](https://www.luogu.com.cn/problem/CF1425A)

这题。。。emmm

有坑点。

一开始想着呢，直接能除就除，不然就减，然后$WA$了

然后想着偶数时把先减的算一下，先除的也算一下，取较大值，然后$WA$了

后面仔细思考了一下，发现果然思路不对

举个栗子，假如是$12$

------------

## 开始思路：

小A取$6$，还剩$12-6=6$；小B取$3$，还剩$6-3=3$

小A取$1$，还剩$3-1=2$；小B取$1$，还剩$2-1=1$

小A取到最后的$1$，那么小A取到总值：$6+1+1=8$

但这不是最优解

------------

## 最优解：

小A若先只取$1$，还剩$12-1=11$；小B取$1$，还剩$11-1=10$

这时小A取$5$，还剩$10-5=5$；小B取$1$，还剩$5-1=4$

小A取$2$，还剩$4-2=2$；小B取$1$，还剩$2-1=1$

小A取到了最后的$1$，那么小A取到总值：$1+5+2+1=9$

------------

那这两个的区别在哪呢？

可以发现：偶数最优解中小B不可能取到比1大的数字

而你如果去尝试将奇数代进去时，小A不可能取到比1大的数

那怎么做呢？

可以看到：当12时，小A没有取一半，为什么？

因为取一半后，就会剩6，那小B就能取一半

那我们只要判断下（当前剩余的数/$2$）%$2$是否为$0$

这样就能让另一方一直取$1$了

## 但是4不一样

取到4时，就取一半，这样能取到$3$

如果你跟别的一样判，那么只能取到2了

------------

CODE：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int T,x,ans,flag;
signed main(void)
{
	std::ios::sync_with_stdio(false);
	cin>>T;
	while(T--)
	{
		cin>>x;
		ans=0,flag=0;
		while(x)
		{
			if(!flag)
			{
				flag=1;
				if(x%2==1)
				{
					ans++;
					x--;
				}
				else{
					if((x/2)%2==0&&x!=4)
					{
						ans++;
						x--;
					}
					else{
						ans+=x/2;
						x-=x/2;
					}
				}
			}
			else{
				flag=0;
				if(x%2==1)
				{
					x--;
				}
				else{
					if((x/2)%2==0&&x!=4)
					{
						x--;
					}
					else{
						x-=x/2;
					}
				}
			}
		}
		cout<<ans<<endl;
	}
	return 0;
}
```
