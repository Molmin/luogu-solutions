这题非常的有趣呵~

[原题传送门](https://www.luogu.com.cn/problem/AT2299)。[在窝的博客中食用更佳](https://www.luogu.com.cn/blog/MZY666/solution-at2299)。

### 【 题意概括 】

先输入一个大于 $3$ 的奇数 $n$，表示有 $n$ 张牌。随后输入每一张牌 $a_i$ 。

现在可以进行下述操作无限次，求最多能剩下多少张不重复的牌。

可进行的操作：选 $3$ 张牌出来，弃掉最小和最大的那两张牌，再将剩余的那张重新放入牌堆中。

### 【 思路 】

欢迎来到精华部分。

首先如果要保证尽可能地“多剩下不重复的牌”，那么牌堆不可能为空。

因此可以用一种类似贪心的想法。

每次取两个已经和前面重复过的牌出来，再随便拿一张之前它们一样的某一张牌来“垫一下”，（反正最后会把这张牌放回去），就可以达到去重的目的。

这样每次可以去掉 $2$ 张与前面相同的牌。

那如果只剩一张与前面重复的牌又该怎么办呢？

这个时候就只能舍去一张没有重复过的牌了。没办法嘛。这一点需要注意。

来，是时候看看完整代码了。这样才好说清。

### 【 代码实现 + 注释 】

```cpp
#include<bits/stdc++.h>//万能头文件可好 
using namespace std;
#define ll long long//个人习惯
bool a[100005];//a[i]表示是否有i这么一张牌，初始值为false
int main(){//主函数 
	ll n,k,i,again=0;//k用于暂存输入，again记录重复的次数。
	scanf("%lld",&n);//输入n
	for(i=1;i<=n;i++){
		scanf("%lld",&k);
		if(a[k])again++;//如果这个数之前有过,again++
		else a[k]=true;//否则将此数标记为true
	}
	again+=again%2;//这就是讨论是否有单独剩下的一张无法配对去重的情况。
	printf("%lld",n-again);//输出剩余的牌数
	return 0;//over~
}
```

最后，由于作者自愿禁言了，如果有建议请私信。否则将**无法**回复您哦！

完结撒花~（疯狂暗示 OwO