一个比较简单的小贪心吧。
### 题目描述：
有一堆牌，每张牌上有一个数字。每次可以取出其中三张，丢掉数字最大的和数字最小的牌，把中间那张再放回牌堆。要求最后所有剩余牌上的数字互不相同，求最多能剩几张牌。
### 做法：
第一眼看到之后没大有思路，但是其实这个题就是个小贪心而已。

首先，$A_i$ 的范围很小，是可以直接开桶记录个数的。

我们记录下来每一个数出现的次数，然后手摸一下，发现：

一个数出现的次数只能是一次或两次！！

为什么这么说呢？

因为题目没有规定每次取的牌必须各不相同，所以我们干脆三张牌都取自己，然后删掉两张，这样的话我们会发现最后一种牌只会出现一次或两次。

接下来，出现一次的我们不敢动，我们动这些出现两次的。

然后又是非常神奇！

取两个相同的较小的，一个较大的，就能把这两堆牌都变成一张，比如：

$$1,1,2,2,3,3,4,4$$

我取 $1,1,2$，就可以把 $1$ 和 $2$ 消成一个。$3,4$ 同理。

这样总共会出现两种情况，一个是消完之后正好，都剩下一个。

另一种就是剩下一种牌有两个。

第一种情况直接输出答案，第二种情况我们就不得不牺牲一种牌了……

### 代码：
```c
int n, a, top, js;
int maxx=0;
int cnt[100005];
int main(){
	n=read();
	for(int i=1; i<=n; ++i) {
		a=read();
		++cnt[a];
		maxx=max(maxx, a);
	}
	for(int i=1; i<=maxx; ++i) {
		if(cnt[i]) {
			++top;//新牌
			js+=(!(cnt[i]&1));//自己消自己之后个数为2的牌，自己手模一下就知道为什么这么写了。
		}
	}
	if(js&1) printf("%d", top-1);//如果剩下一种,多牺牲一种牌。
	else printf("%d", top);//反之正好能两两配对。
	ByKonnyaku41377;
	/*ACdate:2022.6.9*/
}
```