大家都知道，一个数的各位数字之和如果是9的倍数，那么这个数就是9的倍数。
那么这道题就可以转化为：**l到r之间所有数除以9的余数之和模9等于几的问题。**
于是我们惊奇的发现，两个可以被9整除的数之间，所有数除以9的余数只有1，2，3，4，5，6，7，8这几种情况（~~接下来才是见证奇迹的时刻！~~）
不难看出：1+8=9，2+7=9，3+6=9，4+5=9；
于是可以得出一个奇妙的结论：**任何两个可以被9整除的数之间，所有数字的总和必定能被9整除。**
所以我们只需要求出l到从左往右第一个能被9整除的数以及r到从右往左第一个能被9整除的数之间的所有数对9取余后的和，之后再对9取余即可。
显而易见这是一道可以循环做的题（~~手动滑稽~~）
上代码：
```
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
int main()
{
	int q;
	cin>>q;
	while(q--)
	{
		long long l,r,t1,t2,ans=0;//题目数据需要开成long long
		cin>>l>>r;
		t1=r;
		t2=l;
		for(long long i=l;i<=r;i++)//找从左往右第一个能被9整除的数
		{
			if(i%9==0)
			{
				t1=i;//记录从左往右第一个能被9整除的数的位置 
				break;
			}
		}
		for(long long i=r;i>=l;i--)//找从右往左第一个能被9整除的数
		{
			if(i%9==0)
			{
				t2=i;//记录从右往左第一个能被9整除的数的位置 
				break;
			}
		}
		if(t1==r&&t2==l)for(long long i=l;i<=t1;i++)ans+=i%9;//l~r之间没有能被9整除的数只需从头加到尾即可 
		else
		{
			for(long long i=l;i<=t1;i++)ans+=i%9;
			for(long long i=t2;i<=r;i++)ans+=i%9;//求出从左往右第一个能被9整除的数以及r到从右往左第一个能被9整除的数之间的所有数对9取余后的和 
		}
		ans%=9;//一定记住还要取一次余 ！！ 
		cout<<ans<<endl;
	}
	return 0;
}
```

