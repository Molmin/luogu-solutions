~~做了一晚上也没做出来的好题~~

# 标签：数论

## 先来看这样一个问题：

对于一个数 mod 9 的结果，可以用数学相关知识来求解。

假设 x = (a_1a_2a_3a_4....a_n+1)，其中ai表示数x对应位置的数字，

那么有：

		x = a_1 * 10 ^ n + a_2 * 10 ^ (n - 1) + ... a_n+1 * 1;
	
		将10 ^ i分解为 9999...9 + 1的形式，那么就有以下操作：
        
        x = a_1 * 99..9 + a_2 * 99..9 + ... a_n * 9
        	+ a_1 + a_2 + ... a_n+1;
        
        因为99..9 mod 9 = 0，所以 a_i * 99..9 mod 9 = 0；
        
        那么我们就可以得出在 mod 9 的情况下 x 与 a_1 + a_2 + ... a_n+1 同余。
        
## 再来看这个问题

对于一个数，每一位由 l ~ r 对应的数字组成，求这个数 mod 9 的结果。

首先我们按照刚才那个结论可以得出：
	
    这个数 mod 9 的结果与它各位数字之和 mod 9 的结果是一样的。
    
由于 l 和 r 给定，那么我们可以暴力的求出 l 到 r 的数字位之和之后再 mod 9 从而得出答案。

但是这样循环只能拿 70 Points，怎么办呢，考虑优化。

### 优化1

	前缀和优化计算速度。
    
    首先递推出每个数的数字位之和，再维护一个前缀和数组，在数组内就 O(1) 查询，否则暴力求解。
    
    这个优化方法可以拿到 80 Points。
    
```cpp
	inline void make() {
    	for(int i = 1;i < size;i++) {
        	cnt[i] = cnt[i / 10] + i % 10;
        	sum[i] = ((cnt[i] % 9) + (sum[i - 1] % 9)) % 9;
    	}
	}
```
	
    是不是很像求二进制下 x 中 1 的个数那种方法？
    
### 优化2

	再次利用最开始那个结论。
    
    将排列出来的数 x 写成以下形式：
    
    x = l * 10 ^ k_1 + (l + 1) * 10 ^ k_2 + ... + r
      
      = l * 99..99 + (l + 1) * 99..99 + .. + r
      	+ l + (l + 1) + ... + r;
    
    同理可以得出 x 与 l + (l + 1) + ... + r 在 mod 9 的情况下是同余的。
    
    所以说只要计算出 l + (l + 1) + ... + r 再 mod 9 就可以了。
    
    利用等差数列求和公式可以很轻松地得出：
    	
        l + (l + 1) + ... + r = (l + r) * (r - l + 1) / 2;
        
    然后计算求解即可。
    
    代码如下：(100 Points)
    
```cpp
	
    #include<iostream>
	#include<cstdio>
	using namespace std;
	typedef long long ll;

	int main() {
   		int T;
    	scanf("%d", &T);
    	while(T--) {
        	ll l, r;
        	scanf("%lld%lld", &l, &r);
        	ll a, b;
        	a = l + r, b = (r - l + 1);
        	if(a % 2) b /= 2; // 防止除以2后向下取整之后出现错误答案
        	else a /= 2;
        	a %= 9, b %= 9;
        	printf("%lld\n", (a * b) % 9);
    	}
    	return 0;
	}
```