这题一看上去裸的宽搜

但这题因为要记录拐弯的次数，而不是最短路。。。

# 误区 路短不代表拐弯少

所以不能用常规宽搜QWQ~~太麻烦了，要回溯，多次搜，搜出所有路~~

这时我们需要对宽搜进行一下特殊的加强~~处理~~

让它只搜一次就出答案

我们可以利用

# 洪水填充~~机房某大佬取的名~~
的方法对一个点的4个方向进行搜索

这样就不用多次搜了

至于洪水填充是啥，我具体讲一下

这个方法是对宽搜进行优化，但某些情况反而会有有拖累

~~不过应该没人卡这种蒟蒻优化~~

实现这个方法，你只要在进行搜索跑点时在多加一个for循环

来模拟当前这条路能跑多远，向前延伸多远，像水一样向直线拓展

即让坐标点的变量乘上一个常数，让该点4条直线上延展

下面上代码QWQ
```
#include<cstdio>
#include<iostream>
using namespace std;
struct pd{int x,y;}hrb[20050];//队列，存状态
int lxy[101][101],n,m,i,j,k,r=1,l,x,y,emm[101][101];
//lxy起bool的作用，emm记录拐弯次数
int xy[4]={1,-1,0,0},yx[4]={0,0,-1,1}；//坐标变量
char tu[101][101];//原图
int main()
{
    //freopen("ddos.in","r",stdin);
    //freopen("ddos.out","w",stdout);
    scanf("%d",&n);
    for(i=1;i<=n;i++)
    for(k=1;k<=n;k++)
    {
        cin>>tu[i][k];
        if(tu[i][k]=='A')hrb[l].x=i,hrb[l].y=k,lxy[i][k]=1;
        if(tu[i][k]=='B')x=i,y=k;
        if(tu[i][k]=='x')lxy[i][k]=1;
        //对图进行处理
    }
    while(l<r)//开搜
    {
        for(i=0;i<4;i++)//枚举坐标变量，进行4方移动
        for(k=1;;k++)//用于洪水填充的数组
        {
            int xx=hrb[l].x+k*xy[i],yy=hrb[l].y+k*yx[i];
            //枚举一个常数k，与坐标变量相乘
            if(lxy[xx][yy]==1)break;
            if(xx<=0||xx>n||yy<=0||yy>n)break;
            //碰边或走过了，停止填充
            lxy[xx][yy]=1;//打标记
            emm[xx][yy]=emm[hrb[l].x][hrb[l].y]+1;
            //停了，说明该转弯了，于是当前点的次数为原坐标的加1
            //该处不用取min，是因为洪水填充记得是拐弯次数，到目标点，拐弯次数自然是最少的
            hrb[r].x=xx;
            hrb[r].y=yy;
            r++;//进行队列
        }
        l++;
    }
    if(emm[x][y]!=0)
    printf("%d",emm[x][y]-1);//终点不为0，就说明到过这，输出答案减去1，因为开始方向不定QWQ~~理解一下~~
    else
    printf("-1");//说明到不了
    return 0;
}
```
搜索其实是优雅的暴力QWQ

面对不同题目，要用各种骚操作

比如，这题常规宽搜要搜几次才能出答案，试出所有路才能出答案

加了洪水填充，就只有一次，搜完，是不是很快，是不是很神奇

# 所以，这不点赞，关注，~~投食，素质三连~~，一波