[博客](https://wallbreaker5th.github.io/2018/%E9%A2%98%E8%A7%A3-P4035-JSOI2008-%E7%90%83%E5%BD%A2%E7%A9%BA%E9%97%B4%E4%BA%A7%E7%94%9F%E5%99%A8/)

洛谷题号：P4035

bzoj题号：1013

---

题目：

> ## Description

> 有一个球形空间产生器能够在n维空间中产生一个坚硬的球体。现在，你被困在了这个n维球体中，你只知道球
面上n+1个点的坐标，你需要以最快的速度确定这个n维球体的球心坐标，以便于摧毁这个球形空间产生器。

> ## Input

> 第一行是一个整数n(1<=N=10)。接下来的n+1行，每行有n个实数，表示球面上一点的n维坐标。每一个实数精确到小数点
后6位，且其绝对值都不超过20000。

> ## Output

> 有且只有一行，依次给出球心的n维坐标（n个实数），两个实数之间用一个空格隔开。每个实数精确到小数点
后3位。数据保证有解。你的答案必须和标准输出一模一样才能够得分。

> ## Sample Input

> > 2

> > 0.0 0.0

> > -1.0 1.0

> > 1.0 0.0

> ## Sample Output

> > 0.500 1.500

> ## HINT

> 提示：给出两个定义：1、 球心：到球面上任意一点距离都相等的点。

> 2、 距离：设两个n为空间上的点A, B的坐标为(a1, a2, …, an), (b1, b2, …, bn)，
则AB的距离定义为：$dist = \sqrt{(a1-b1)^2 + (a2-b2)^2 + ... + (an-bn)^2}$

---

这是一道高斯消元比较裸的题目了，除了板题以外这题是我AC的第一道高斯消元题目。

我们假设这N+1个点的坐标分别为：


$P_1    (a[1][1]  ,a[1][2]  ,...a[1][n])$

$P_2    (a[2][1]  ,a[2][2]  ,...a[2][n])$

$...$

$P_{n+1}(a[n+1][1],a[n+1][2],...a[n+1][n])$

圆心的坐标为：

$P_0(a[0][1]  ,a[0][2]  ,...a[0][n])$

那么$|P_1P_0|=|P_2P_0|=......=|P_{n+1}P_0|$

单独拿$|P_1P_0|=|P_2P_0|$出来：

- $|P_1P_0|=|P_2P_0|$

- $|P_1P_0|^2=|P_2P_0|^2$

- $(a[0][1]-a[1][1])^2+(a[0][2]-a[1][2])^2+...+(a[0][n]-a[1][n])^2$

$=(a[0][1]-a[2][1])^2+(a[0][2]-a[2][2])^2+...+(a[0][n]-a[2][n])^2$

- $a[0][1]^2-2a[0][1]a[1][1]+a[1][1]^2+...+a[0][n]^2-2a[0][n]a[1][n]+a[1][n]^2$

$=a[0][1]^2-2a[0][1]a[2][1]+a[2][1]^2+...+a[0][n]^2-2a[0][n]a[2][n]+a[2][n]^2$

- $2(a[1][1]-a[2][1])a[0][1]+2(a[1][2]-a[2][2])a[0][2]+...+2(a[1][n]-a[2][n])$

$=a[1][1]^2-a[2][1]^2+a[1][2]^2-a[2][2]^2+...+a[1][n]^2-a[2][n]^2$

（公式太长只能换行，为清楚用了无序列表）

也就是关于$a[0][1],a[0][2],...,a[0][n]$的一个线性方程，把$|P_1P_0|=|P_3P_0|,|P_1P_0|=|P_4P_0|,...,|P_1P_0|=|P_{n+1}P_0|$都转化一下，就可以得到一个线性方程组，用高斯消元就可以解出来。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=105;
double a[N][N+1];
bool u[N];
double x[N+1][N];
int main(){
	int n;
	cin>>n;
	cout<<fixed<<setprecision(3);
	for(int i=0;i<n+1;i++){
		for(int j=0;j<n;j++){
			cin>>x[i][j];
		}
	}
	for(int i=0;i<n;i++){//第i+1个点 
		for(int j=0;j<n;j++){
			a[i][j]=2*(x[0][j]-x[i+1][j]);
			a[i][n]+=x[0][j]*x[0][j]-x[i+1][j]*x[i+1][j];
		}
	}
	for(int i=0;i<n;i++){
		bool ok=false;
		int j=0;
		for(;j<n;j++){
			if(a[j][i]&&!u[j]){
				ok=true;
				u[j]=true;
				break;
			}
		}
		if(!ok){
			cout<<"No Solution";
			return 0;
		}
		if(a[j][i]==0){
			cout<<"No Solution";
			return 0;
		}
		double orz=a[j][i];
		for(int k=0;k<n+1;k++){
			a[j][k]/=orz;
		}
		for(int k=0;k<n;k++){
			if(k==j)continue;
			orz=a[k][i]/a[j][i];
			for(int l=0;l<n+1;l++){
				a[k][l]-=orz*a[j][l];
			}
		}
		/*for(int i=0;i<n;i++){
			for(int j=0;j<n+1;j++){
				cout<<a[i][j]<<" ";
			}
			cout<<endl;
		}
		cout<<endl;*/
	}
	for(int i=0;i<n;i++){
		cout<<a[i][n]<<" ";
	}
	return 0;
}
```