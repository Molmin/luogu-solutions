这是一道少见的满分是50分的题呢

蒟蒻不会STL，因此发一个纯模拟的题解

#### 思路

开四个桶，分别表示对应花色点数为 $i$ 的扑克牌出现的次数。由于每种花色的扑克牌只有13种不同的点数，所以作为桶的数组只要开到14位就够了。读入的数据，可以将整个字符串读入，然后离线处理每种扑克牌出现的次数。用一个循环，三个字符三个字符的处理每张牌的信息。设这三个字符分别为 $c_1$ $c_2$ $c_3$，则这张扑克牌的花色是 $c_1$，这张牌的点数是 $(c_2-48) * 10 + (c_3-48)$ ，然后将对应颜色对应牌的数量+1。然后再用一个循环统计是否有牌出现重复，如果有牌出现重复则输出```GRESKA```，如果没有牌有重复则统计每种花色没有出现的牌的个数，然后一行输出四种花色的缺少的个数就可以了。

#### 代码如下

```cpp
#include <cstdio>
#include <cstring>
int P[15],K[15],H[15],T[15];//分别记录四种花色的牌是否出现过 
char c[1010];//读入的字符串 
int main()
{
	scanf("%s",c);
	int l;
	l=strlen(c);
	l/=3; //计算读入数据总共有几张牌 
	int i,j;
	int a;
	for(i=0;i<l;i++)
	{
		a=10*(c[i*3+1]-48)+(c[i*3+2]-48);//计算这张牌的点数
		if(c[3*i]=='P')
			P[a]++;
		if(c[3*i]=='K')
			K[a]++;
		if(c[3*i]=='H')
			H[a]++;
		if(c[3*i]=='T')
			T[a]++;
	}
	for(i=1;i<=13;i++)//如果有牌超过一张，输出"GRESKA" 
	{
		if(P[i]>1||K[i]>1||H[i]>1||T[i]>1)
		{
			printf("GRESKA\n");
			return 0;
		}
	}
	int p,k,h,t;
	p=0;k=0;h=0;t=0;
	for(i=1;i<=13;i++)
	{
		if(P[i]==0)
			p++;
		if(K[i]==0)
			k++;
		if(H[i]==0)
			h++;
		if(T[i]==0)
			t++;
	}
	printf("%d %d %d %d\n",p,k,h,t);
}
```
