## 暴力模拟+switch  
**题目**：[在这里](https://www.luogu.com.cn/problem/P6529)  
**主要思路**：  
1、**读入**一个字符串；  
2、**三个为一组**，记录每种花色**出现的次数**与每种花色的牌的**点数是否出现**；
3、如果有**重复**的牌，则**输出** $GRESKA$ 并**结束循环**   
4、**重复第2步**直到字符串**被遍历完**；  
5、如果循环到这里，那么**肯定没有重复的牌**，就**直接输出剩下的牌的个数**； 

#### 主要代码实现如下：
（我是喜欢全部**读入完后再进行遍历**
```cpp
for(int i=1; i<=len; i+=3)//三个为一组分组
    {
        switch (s[i])//switch看起来方便一些
        {
        case 'P'://如果是‘P’
            n=(s[i+1]-'0')*10+(s[i+2]-'0');
            if(!a[1][n]) a[1][n]=1, f[1]++;
            else//有重复输出GRESKA，并结束程序
            {
                printf("GRESKA\n");
                return 0;
            }
            break;
        case 'K'://如果是‘K’
            n=(s[i+1]-'0')*10+(s[i+2]-'0');
            if(!a[2][n]) a[2][n]=1, f[2]++;
            else//有重复输出GRESKA，并结束程序
            {
                printf("GRESKA\n");
                return 0;
            }
            break;
        case 'H'://如果是‘H’
            n=(s[i+1]-'0')*10+(s[i+2]-'0');
            if(!a[3][n]) a[3][n]=1, f[3]++;
            else//有重复输出GRESKA，并结束程序
            {
                printf("GRESKA\n");
                return 0;
            }
            break;
        case 'T'://如果是‘T’
            n=(s[i+1]-'0')*10+(s[i+2]-'0');
            if(!a[4][n]) a[4][n]=1, f[4]++;
            else//有重复输出GRESKA，并结束程序
            {
                printf("GRESKA\n");
                return 0;
            }
            break;
        }
    }
    
    printf("%d %d %d %d\n", 13-f[1], 13-f[2], 13-f[3], 13-f[4]);
    //如果没有重复的，那么输出每张牌差的个数
```
感谢阅读本题解，希望此题解能够给您带来便利！