这道题我个人认为只有一句话    ~~暴力出奇迹~~

看了一下数据n只有20，完全可以用暴力来枚举所有的情况。

可是怎么来枚举呢？
## （重点，敲板凳）模版/算法：二进制穷举
```
	//双手奉上代码 
	b[n]=1;//初始化二进制数的第一位为1;
	while(b[0]==0)
	{	bool flag=0;//flag用来标记此情况是否成立 
		for(int i=1; i<=n; i++)
			if(b[i]==1) 
			{
				if(/*如果不满足条件*/)
				{
					flag=0;
					break;//标记后break; 
				}
			}
		if(/*如果满足条件，答案++*/)ans++;
		int j=n; 
		while(b[j]==1)j--;
		b[j]=1;
		for(int i=j+1; i<=n; i++)b[i]=0;
		//核心代码：模拟将一个二进制加一的过程，具体如下 
	}
	//该模板是建立在这道题之上的，可根据题目适当修改 
```
首先我们要明白二进制穷举在什么时候可以使用，二进制穷举的局限性较大，主要用于**动态规划的暴力**打法，比如01背包；二进制穷举只有在当题目要求只有**取与不取**两种状态。比如这道题，我们可以把它看成取与不取这个旅馆里的问题，二进制穷举的中心思想就是：暴力枚举所有情况，判断该情况是否成立。

再来讲一下二进制穷举的工作原理：我们先假设现在只有4个旅馆四个旅馆分别是 0 1000 3000 5000，a=3500,b=5000。处在0位置的旅馆可以不看那么到目前为止有这几种可能性：

取1000，3000，5000；

取1000，3000；
取1000，5000；
取3000，5000；

取1000；取3000；取5000；

共7种，如果把取看成1，不取看成0 ,
可以得到7种可能:

001,010,011,100,101,110,111.
这7种可能正好是二进制数0-111(2^3-1)的枚举；
而我们又可以看出一个二进制数的过程分解可以并成两步：加1，进位。但二进制只有0和1，如果为一，后面进1，进位，为0，等于一。

又可以简化成从**最后一位查找，第一个不是0的数加1，在其之后的数全部变为0**。

最后奉上完整代码
```
#include<iostream>
#include<algorithm>
using namespace std;
const int maxn=7000;
int a[55]= {0,990,1010,1970,2030,2940,
            3060,3930,4060,4970,5030,5990,6010,7000
           };
bool b[55];//b用来模拟二进制，b[i]表示二进制的第i位数
int ans;
int main()
{
	int x,y,n;
	cin>>x>>y>>n;
	n+=13;//输入 n预处理，加上原有的旅馆数
	for(int i=14; i<=n; i++)cin>>a[i];
	sort(a+1,a+n+1);
	b[n]=1;//初始化二进制数的第一位为1;
	if(y>=maxn)ans=1;//特殊情况：不用住在旅馆里，直接到目的地
	while(b[0]==0)
	{ 
		bool flag=1;
		int last=0;
		for(int i=1; i<=n; i++)
			if(b[i]==1)
			{
				if(a[i]-last<x||a[i]-last>y)
				{
					flag=0;
					break;
				}
				last=a[i];
			}
		if(flag==1&&(!(maxn-last<x||maxn-last>y)))ans++;
		/*{不解释，不懂看上面  
			ans++;
			for(int j=1; j<=n; j++)
				cout<<b[j];
			cout<<' ';
		}*/
		int j=n;
		while(b[j]==1)j--;
		b[j]=1;
		for(int i=j+1; i<=n; i++)b[i]=0;
	}
	cout<<ans;
	return 0;
}
```
本人文笔不好，有什么写的不好的尽管指出。

# 谢谢！