# 据说这题是DP，可是我一个暴搜就AC了呀...
~~可能这就是这题是橙题的原因了吧。~~   
看了一眼题解，貌似我的做法只有pascal语言，码一发c++题解。
# ①状态定义
说实话，看到这道题的题目我不是很理解，想了一会才发觉——

**可以把旅馆当成可以停留的地方，如果是，就可以转移至下一个状态，如果不是，就不能转移。**

当达到7000M的时候就可以```return```了，那么我们自然而然就可以想到，用现在到达的距离用作转移的状态，即可以这么定义：
```cpp
bool is_hotel[7005]={0};
int least,most,ans;
void dfs(int meter)
```
由于7000很小，我们可以用一个```is_hotel[]```数组来标记是否有旅馆（可以到达）。
# ②状态转移
 _个人认为不只有dp才能状态转移，其实搜索也有状态转移的思想。_
 
 其实就是很简单的dfs模板，这里不再赘述，尽在注释中。
 ```cpp
//输入
void dfs(int meter)
{
	//printf("meter=%d\n",meter);
    //以上是调试用语句，推荐使用
	if(meter==7000)//到达目的地，回溯
	{
		ans++;
		return;
	}
	for(int i=least;i<=most&&meter+i<=7000;i++)
    //从最小行程到最大行程开始枚举，如果超出目的地，停止枚举
	 if(ishotel[i+meter])dfs(meter+i);//如果有旅馆，转移！
}
```
本题由于相同的参数值会有不同的映射（即不同的效果），故不能采用记忆化。
# ③ AC！
