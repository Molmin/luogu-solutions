题目说明 $n$ 是一个 $2$ 的整数次幂，那么就可以使用折半递归的分治思想来解决。

首先，从「好串」的第一个条件看，如果字符串长度仅为 1，那么是否需要修改，取决于这个字符是否达到要求。

判断单个字符是否达到要求，只需要看这个字符是否和字母表中的第 $\left((\log_2 n)+1\right)$ 个小写字母相同。如长度为 8 的字符串中选一个长度为 1 的子串，且这个子串的字符是 `d`，那么它就是「好串」。

第二个步骤，让两段字符合并，并在新串内找出最优答案。

假设总共长度为 8，那么：

- 如果子串为 `dc`，那么不需要修改，因为该串满足「好串」的**条件三**。

- 如果子串为 `cb`，那么 `c` 是满足该层条件的，而 `b` 照此想法需要放到下一层**并且修改为 `d`**，共修改 1 个字符。

- 如果子串为 `cccb`，那么此时有两种决策——
	- 把 `cc` 修改为满足条件的 `bb`，并且把 `cb` 放到下一层递归（由上可知此处需要修改 1 个字符），共修改 3 个字符；
    - 把 `cb` 修改为 `bb`，并且把 `cc` 放到下一层**并且修改为
`cd` 或 `dc`**，共修改 2 个字符。
	- 然后把 3 和 2 取最小值，就可以得到子串内的最优解。
    
还有如果我们在选择使用条件二、条件三方案的时候，还是那样逐个统计需要修改字符的数量，那还是太慢了。

所以若想要快速求出形如「`aaab` 中所有字符变成 `b`」需要修改的字符数量，可以使用二维前缀和。

具体办法就是统计每个字母在各个前缀序列中的出现次数，然后 **子串长度 - 子串包含目标字符的个数** 就是需要修改的字母数量。

时间复杂度为 $O(26\times n+n\log n)$，可以通过。

```cpp
#include <cstdio>
#define INF 1e9
#define eps 1e-6
typedef long long ll;

int t, n;
char s[200010];
int sumc[200010][26];

inline int min(int a, int b){		// 最小值函数
	return a < b ? a : b;
}

int search(int l, int r, int now){	// now 代表层数
	if(l == r){
	// 对于长度为 1 的子串，如果字母不符深度条件，那么就要修改
		if(s[l] == 'a' + now) return 0;
		return 1;
	}
	int mid = (l + r) >> 1;			// 折半
	int lc = (mid - l + 1) - (sumc[mid][now] - sumc[l - 1][now]);
	// 上一行为左半边变为规定字符串时需要修改的字符数，下一行为右半边的
	int rc = (r - mid) - (sumc[r][now] - sumc[mid][now]);
	return min(search(l, mid, now + 1) + rc, search(mid + 1, r, now + 1) + lc);	// 选择更好的方案
}

int main(){

	scanf("%d", &t);
	while(t--){
		scanf("%d%s", &n, s + 1);
		for(int i = 0; i <= 25; i++){	// 统计字符出现次数的前缀和
			sumc[0][i] = 0;
			for(int j = 1; j <= n; j++)
				sumc[j][i] = sumc[j - 1][i] + (s[j] - 'a' == i);
		}
		// 此处和代码前的说明有不同，是以第 0 层开始计数的，不要搞混
		printf("%d\n", search(1, n, 0));
	}

	return 0;
}

```