## 题目大意
------------

模拟题。

给出一个 $n$ , 然后有 $n$ 个日期，每个日期对应新添加的节假日。包括周六周日在内，让求出 $2012$ 年中最长的连续假期。

## 思路

------------
按题意模拟即可。

首先，$2012$ 年是闰年，$2$ 月有 $29$ 天。

其次，对于给出的日期，若这个日期已经是周末，还要往后推。

我们先考虑用二维数组，前一个变量存月份，后一个存日期。

但是，我们需要考虑一对周六周日不在同一个月内或一个假期还要推到下一个月的情况，那么用二维数组要考虑月份之间的转换，整体码量很大。那么我们直接合并成一个一维数组存日期，再开一个数组存每月之前的累计日期。

如下：

```cpp
int dat[366];
int mon[15]={0,31,60,91,121,152,182,213,244,274,305,335};
```
当查询日期时就可以表示为 ```dat[mon[m-1]+d-1]``` 。

我们先来考虑周末的标记方式。$2012$ 年 $1$ 日正好是周日，那么在这一年当中天数的处理就很方便。我们将第一天的数组下标设为 $0$，就有如下：

```cpp
for(int i=0;i<366;i++)
	 if(i%7==0||i%7==6) dat[i]=1;
```
对于输入的每个日期，如果这个日期不是周末就标记，如果是就跑一个 $while$ 循环，找到离他最近的平日再标记。

最后，全年循环一遍，找到假期当前天数增加，找到平日就先更新答案，然后赋零。

最最后再更新一遍！因为最长的连续假期有可能持续到最后一天，但在循环中不会被更新。

下面附上代码：

```cpp
#include<bits/stdc++.h>
#define lxl long long
#define N 114514
using namespace std;

int dat[366];
int mon[15]={0,31,60,91,121,152,182,213,244,274,305,335};
int n,m,d;
int cnt=-1;
int ans=0,hop=0;

bool cmp(int x,int y){
	return x>y;
}

int main(){
	for(int i=0;i<366;i++)
	 if(i%7==0||i%7==6) dat[i]=1;
	cin>>n;
	while(n--){
		scanf("%d/%d",&m,&d);
		if(dat[mon[m-1]+d-1]==0) dat[mon[m-1]+d-1]=1;
		else{
			cnt=mon[m-1]+d-1;
			while(cnt<366){
				if(dat[cnt]==0){
					dat[cnt]=1;
					break;
				}
				cnt++;
			}
		}
	}
	for(int i=0;i<366;i++){
		if(dat[i]==1) hop++;
		else{
			ans=max(ans,hop);
			hop=0;
		}
	}
	ans=max(ans,hop);
	cout<<ans<<endl;
	return 0;
}
```
