# 题目大意：
给定 $ n $ 个日期，它是节假日，除了它之外，每周六和周日也是节假日，问这一年最长休假多少天。

# 思路：
直接模拟。用一个数组标记这一天是不是节假日，先从第一天起跑一遍，用一个数组将周六日的编号记录下来。另外一个数组 $ sum[i] $ 表示前 $ i - 1 $ 个月的天数总和，再加上输入的 $ d $ 可以表示这一天的编号。

对于输进来的每一个日期，如果它原本不是节假日，就将它改为节假日，否则，就将它之后离它最近的平日改为假期。

全部完成之后，从第 $ 1 $ 天到第 $ 367 $ 天跑一遍，如果节假日是连续的，就记录下来，如果它不再连续，就将它和 $ ans $ 进行比较，取较大值。

# 注意：
1.$ 2012 $ 年 $ 1 $ 月 $ 1 $ 日是周日，翻译有误，务必注意。

2.$ 2012 $ 年是一个闰年，所以二月有 $ 29 $ 天，全年共 $ 366 $ 天。

3.最后一次循环需要跑到 $ 367 $，因为可能会有一个假期持续到第 $ 366 $ 天，而到 $ 367 $ 就可以将本次终结，从而防止答案更新出现错误。

4.岛国的题一定要换行！！！

# 代码奉上：
```
#include<bits/stdc++.h>
using namespace std;
int sum[20],mon[20]={0,31,29,31,30,31,30,31,31,30,31,30,31};
int n,m,d,l,ans;
bool day[370];
int main(){
	scanf("%d",&n);
	for(int i=1;i<=12;++i)
	  sum[i]=sum[i-1]+mon[i];
	for(int i=1;i<=366;++i)
	  if(i%7==0||i%7==1)
		day[i]=true;
	for(int i=1;i<=n;++i){
		scanf("%d/%d",&m,&d);
		if(day[sum[m-1]+d]==true){
			for(int j=day[sum[m-1]]+d+1;j<=366;++j){
				if(!day[j]){
					day[j]=true;
					break;
				}
			}
		}
		else{
			day[sum[m-1]+d]=true;
		}
	}
	for(int i=1;i<=367;++i){
		if(day[i]==true){
			l++;
		}
		else{
			ans=max(l,ans),l=0;
		}	
	}
	ans=max(ans,l);
	printf("%d\n",ans);
	return 0;
}
```
希望可以帮大家理解。