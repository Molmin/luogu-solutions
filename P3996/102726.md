一道很不错的数论题呢~，就是有点冷门。

蒟蒻数论全谷最菜，感谢出题人的题解。在此重新总结一下，~~放一份简单点的代码。~~

________

出题人的题解很详细了，我再总结一下：

这题有很多细节，~~还不能下数据~~，导致我WA了五六次。

首先是判$0$的情况，因为不能空选，所以$n=0$时,$A[0]$和$b$都必须也是$0$。

先把这个情况判掉，因为$a$无论是几，这种情况都符合。

然后是对$a$的分类：

#### a>1时：

很显然，或简单用归纳法证明一下，每一项$A[i]$都是要比前面的所有项的和都要大的。不难想吧~

因为每个数都是上一个数至少乘以$2$之后再加一个数，加的数$b$是$0$无所谓，只要不是负数就行。而对于$A[0]$是$0$的情况，既然$A[1]=b$，那显然还是成立的。除非$A[0]$和$b$都是$0$呢，这种情况开始已经判掉了~

既然每个数都比前面的所有数的和大，如果我不选择这个数，前面的数是无法弥补这么大的空缺的，所以倒着枚举每个数，只要$n$比此项大，就减去此项，最后如果$n=0$，有解，否则无解，不难证明。

#### a=1时:

这就比较麻烦了：不会exgcd的建议去做一做[青蛙的约会](https://www.luogu.org/problem/P1516)。

当a=1时，我们把每一项列出来：

```
A[1]=A[0]+b; A[2]=A[0]+2*b; A[3]=A[0]+3*b; A[4]=A[0]+4*b;...
```

既然只由$A[0]$和$b$组成，解个$exgcd$就行了~

然后你解出了一组解：$x*A[0]+y*b=n$。接下来我们简单分个类：

**1. 当b=0时**：只要$n$能除尽$A[0]$得到$x$，你只要随便**选x个项**即可。

**2. 当A[0]=0时**：如果$n$能除尽$b$得到$y$，我们直接选**第y项**不就行了~

**3. 当两个都等于零时**：用我再说一遍吗？。。。开始已经判掉了。。。

**4. 当两个都不等于零时：** 我们发现我们希望$y$越大越好，因为每个数只能选一次，而且$b$的系数有无数个取值，$y$越大我们选择的空间就越大。

而限制是：$x$必须是正整数，我们尽量让$x$小，$y$就能很大，于是，解出$x$的最小正整数解。这里有个细节：$x$不是自然数，而是正整数。如果你解出来的$x$是$0$，你必须再把$x$加数变成正数。（害的我WA了次）。

我们解出了$x$的最小解，发现这$x$即为项数（不考虑$A[0]$与$b$的关系，假设你的$A[0]$就是选择每一项中的$A[0]$，$b$就是每一项中的$b$），那么在什么时候符合$y$能够变成每一项$b$的系数和呢？

很显然我们从小开始选择，因为想让$y$剩余的越大越好。那么选择$x$项，$y$最小即为$(1+2+3+...+x) = (1+x)*x/2;$ 只要$y$比此值大，$y$可以用$x$项$b$的系数表示，就有解了，否则无解。

所有情况考虑完了，就放代码吧，~~感觉我的码风还是勉强可以的：~~

```cpp
#include<algorithm>
#include<iostream>
#include<cstdio>
#include<cmath>
#define ll long long             //记得开long long， 在x*(x+1)/2的时候会爆int 
using namespace std;
ll T,ans,  x,y,  a,b,n,A[123];   //A数组开很小就行了，因为数量是log级的。

ll exgcd(ll aa,ll bb) {          //板子 
	if(!bb) {
		x = 1; y = 0;
		return aa;
	}
	ll res = exgcd(bb,aa%bb);
	ll t = x; x = y; y = t - aa/bb * y;
	return res;
}

void work1() {                    //a>1时的情况 
	int now = 0;
	while(A[now] < n) { now++; A[now]=A[now-1]*a+b; } //计算每一项，大于n后跳出。 
	for(int i=now;i>=1;i--) if(n>=A[i]) n -= A[i];   //能减就减 
	if(!n) ans++;                 //n可以被表示，ans++ 
}

void work2() {                     //a=1时的情况，看不懂的话去做青蛙的约会 
	ll GCD = exgcd(A[0],b); if(n%GCD) return ;
	n /= GCD; b /= GCD; A[0] /= GCD;
	x = x*n % b; x = (x+b) % b; 
	if(x==0) x += b;               //注意：x必须是正整数！ 
	y = (n-A[0]*x) / b;
	if(y >= (x*(x+1)/2) ) ans++;   //y可以表示成b的系数的和，ans++ 
}

int main() {
	scanf("%lld",&T);
	while(T--) {
		scanf("%lld%lld%lld%lld",&A[0],&a,&b,&n);
		if(!A[0] && !b) { if(n==0) ans++; continue; }   //A[0]与b都为零时的特判，记得continue！ 
		if(n==0) continue;         //若此时n=0，必然无解，continue 
		if(a > 1) work1();
		else {
			if(!A[0]) { if(n%b==0) ans++; }
			else if(!b) { if(n%A[0]==0) ans++; }
			else work2();
		}
	}
	printf("%lld",ans);
	return 0;
}

```