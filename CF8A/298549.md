貌似有很多人正最短题解，但是目前看来我的码量似乎最少，长度也是最短。（大雾（准备好被打脸。  
闲话少说，切入正题——


------------
题目看起来很饶人，我们一起来把~~恶臭的~~题面简化一下：  
> 在母串中**依次**查找 $s1$ 和 $s2$ 或者在反转中的母串**依次**查找 $s1$ 和 $s2$。  

为什么是依次呢？因为 Peter 不可能在看到 $s2$ 之前看到 $s1$ ~~否则 Peter 怕不是个透视眼外星人。~~  

把题意概括了，那么我们基本上可以构造一个简单的思路，就是先在原串中先查找 $s1$ 再查找 $s2$，然后再在反转后的原串重复这一操作。对于每个操作的答案进行判断并输出。  


------------
既然构造好了解决的算法，我们就要考虑如何用程序实现。  
Q1：用什么类型存储？  
A1：```string``` 字符串类型，自带 STL 各种神仙的~~常数大的~~函数。 

Q2：怎样查找？  
A2：运用 ```string``` 中的 ```find``` 函数进行查找。如果要查找某字符串 / 字符第一次出现的位置，可以这样写：```母串.find(要查找的字符串)```。如果要查找某个在 $pos$ 位置后的字符串的位置，可以这样写：```母串.find(pos,要查找的字符串)```。  

Q3：怎样反转？  
A3：运用 STL 的 ```reverse``` 函数！  

~~也就是说这个就是个 STL 应用题对不对（~~  


------------
上 9 行的代码！
```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{ 
	string s1,s2,s3,cs1;
	cin>>s1>>s2>>s3,cs1=s1,reverse(cs1.begin(),cs1.end());
	int pos1=s1.find(s2),pos2=cs1.find(s2),f1=s1.find(s3,pos1+s2.size()),f2=cs1.find(s3,pos2+s2.size());
	cout<<((pos1==-1&&pos2==-1)?("fantasy"):((f1!=-1&&f2==-1)?("forward"):((f1==-1&&f2!=-1)?("backward"):((f1!=-1&&f2!=-1)?("both"):("fantasy"))))); 
}
```