## 单次欧拉函数的求解
前置芝士：唯一质因数分解

欧拉函数的模板题

题解的很多大佬都直接套用了欧拉线性筛的板子，而我这篇题解则面向欧拉函数的初学者。

首先，了解欧拉函数的定义，对于一个数 $x$ , $\varphi(x)$ 代表从 $1$ 到 $x$ 的非负整数与其互质的数的数量，两个数互质代表其最大公约数为 $1$ 。

然后考虑欧拉函数的推导(请记住如下的三种情况，很重要)：
1. 情况一：对于一个质数 $x$ ，显然， $\varphi(x)=x-1$ ；
2. 情况二：对于一个合数 $x$ 满足 $x=p^k$ ，可以推导出 $\varphi(x)=x-x/p$ ，如 $8=2^3$ 与他不互质的数是 $2,4,6,8$ ，数值上等于 $x/p$ ，显然，与他互质的数的数量就是 $x-x/p$ ；
3. 情况三：对于任意一个数 $x$ ，都可以写成 $\boldsymbol{\Pi_1^n}p_i^{k_i}$ 的形式，其中 $p_i$ 是一个质数， $k_i$ 是这个质数的指数 。

看见这个令人头疼的式子先不要怕，我来仔细分解：

其实这个式子又称为唯一质因数分解，举个例子 $60$ 可以写成 $60=2^2\times3^1\times5^1$ 的形式，此时我们好像可以根据情况二得出单个欧拉函数的计算方法。

什么意思呢，还是请亲爱的 $60$ 同学为我们讲解：

我们已经写出了60的唯一质因数分解式子,然后分析每一个因子：
- 对于 $2^2$ 这个因子， $60$ 内因子含有 $2$ 的数的数量等于 $60/2$ 即30。
- 对于 $3^1$ 这个因子， $60$ 内因子含有 $3$ 的数的数量等于 $60/3$ 即20。
- 对于 $5^1$ 这个因子， $60$ 内因子含有 $5$ 的数的数量等于 $60/5$ 即12。

那么好像可以得出， $60$ 内与它不互质的个数是 $52$，$\varphi(60)=8$，同样显而易见，这个答案是错的。

为什么呢? 

因为，对于像 $6,12$ 这种数，你在计算因子 $2^2$ 时算上了它们，在计算$3^1$时又算上了它们。

这里有一种解决方案，看我演示:

- 对于 $2$ 这个因子， $60$ 内因子含有 $2$ 的数的数量等于 $60/2$ 即 $30$ ，此时 $60$ 内还没被筛选出来的数数量是 $30$ ，然后我们让 $60$ 一直除 $2$ ，直到不能整除为止，就是 $15$ 。 
- 对于 $3$ 这个因子， $15$ 能整除 $3$ ， $30$ 个数中含有因子 $3$ 的个数是 $10$ 。
- 对于 $5$ 这个因子， $5$ 能整除 $5$ ， $20$ 个数中含有因子 $5$ 的个数是 $4$。

此时可得出 $\varphi(60)=16$，经过证实答案正确。

请各位客官选个略小的数推导一下这个过程。

于是乎代码实现如下
```
void eular(int x)
{
	int sum=x;
	for(int i=2;i*i<=x;i++)//（x不是质数的情况）枚举因子只需要从2枚举到根号x，由于是从小到大枚举因子，很容易得出合数不会被枚举，因为在枚举合数之前已经枚举了它的所有因子（事实上是质因子）
	{
		if(x%i==0)//如果是这个数的因子
		{
			sum-=sum/i//减一下所有数中含有这个因子的数的个数
			while(x%i==0)x/=i;//剔除这个因子
		}
	}
	if(x>1)sum-=sum/x;//如果求解欧拉函数的数本身是个质数，那么要筛掉它自身
	printf("%d\n",sum);//输出这个数的欧拉函数
}
```
这个就是对单个欧拉函数的求解，时间复杂度为 $\sqrt{x}$ ,显然求解 $n$ 个欧拉函数的复杂度就是 $n\sqrt{x}$ 。这个题数据比较水，本解法提提裤子能跑20ms。

## 线性欧拉筛
前置芝士：素数筛，[欧拉函数的积性证明](https://www.luogu.com.cn/blog/lx-2003/mobius-inversion)

众所周知，欧拉函数是一个积性函数。意思就是当且仅当$gcd(a,b)=1$ 时 ， $\varphi(a\times b)=\varphi(a)\times\varphi(b)$ 。

积性函数的证明可以直接套公式 $\varphi(x)=\boldsymbol{\Pi_1^n}(x-x/p_i)$ 证明两个数的所有 $p_i$ 在它们互质的情况下互不相等，这样把两个数的欧拉函数乘起来就是它们积的欧拉函数。

然后线性素数筛则选择欧拉筛，欧拉筛能在处理出素数表的情况下求解积性的函数。

代码如下：
```cpp
//phi[x]代表x的欧拉函数
//prim[cnt]是一个存储素数的数组
//flag[x]是1代表这个数是合数，是0就是素数
void eular()
{
	phi[1]=1;
	for(int i=2;i<=maxn;i++)
	{
		if(flag[i]==0)//如果这个数是素数
		{
			prim[++cnt]=i;//放入素数数组
			phi[i]=i-1;//可以求解出它的欧拉函数
		}
		for(int j=1;j<=cnt;j++)
		{
			int P=prim[j];//P代表枚举的素数
			int v=i*P;//表示通过i*P枚举到的数
			if(v>maxn)break;//如果v太大了，对解本题没有帮助
			flag[v]=1;//v能被两个整数相乘枚举到说明是合数
			if(i%P==0)//情况A
			{
				phi[v]=phi[i]*P;
				break;
			}
			else phi[v]=phi[i]*phi[P];//情况B
		}
	}
}
```
对于我在代码欧拉函数求解过程中提到的情况B，就是两个数互质的情况，根据欧拉函数的积性直接让两个欧拉函数相乘就行了。所以：$\varphi(v)=\varphi(i)\times \varphi(P)$。\
而情况A稍微复杂：分析之前可以得到 $P$ 是 $i$ 的最小质因子(因为从小到大枚举且枚举到 $P$ 就打破循环了)，我们套用公式：
- $\varphi(i)=i(1-1/p_1)(1-1/p_2)……(1-1/p_n)$
- $P=p_1$
- $\varphi(i)p_1=ip_1(1-1/p_1)(1-1/p_2)……(1-1/p_n)=\varphi(ip_1)$
- $\varphi(v)=\varphi(ip_1)=\varphi(iP)=\varphi(i)P$

叙述完毕，总代码如下：
```cpp
#include<cstdio>
const int maxn=1000010;
int n,x,cnt;
int prim[maxn],phi[maxn];
bool flag[maxn];
inline int read()
{
	int x=0;
	char r=getchar();
	while(r<'0'||r>'9')r=getchar();
	while(r>='0'&&r<='9')
	{
		x=x*10+(r^'0');
		r=getchar();
	}
	return x;
}
void eular()
{
	phi[1]=1;
	for(int i=2;i<=maxn;i++)
	{
		if(flag[i]==0)
		{
			prim[++cnt]=i;
			phi[i]=i-1;
		}
		for(int j=1;j<=cnt;j++)
		{
			int P=prim[j];
			int v=i*P;
			if(v>maxn)break;
			flag[v]=1;
			if(i%P==0)
			{
				phi[v]=phi[i]*(phi[P]+1);
				break;
			}
			else phi[v]=phi[i]*phi[P];
		}
	}
}
signed main()
{
	int x,n;
	eular();
	n=read();
	for(int i=1;i<=n;i++)
	{
		x=read();
		printf("%d\n",phi[x]);
	}
}
```