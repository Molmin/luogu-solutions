### 题目翻译

定义 $f()$ 为把矩阵的每一个元素替换为它相邻的元素之和对 $2$ 取模所得的结果。

给定一个 $n$ 组 $3 \times 3$ 的仅包含 $0$ 和 $1$ 的矩阵，求经过多少次 $f()$ 后矩阵的每一个元素都为 $0$，若无需变换则输出 $-1$。

### 题目思路

我们可以按照题意模拟 $f()$ 并在每次变换之后检测矩阵的元素是否全部为 $0$，最终输出变换的次数。

### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;

int n, ans;
int g[3][3];

void func() {
	int h[3][3];
	h[0][0] = (g[0][1] + g[1][0]) % 2; // 模拟矩阵变换
	h[0][1] = (g[0][0] + g[1][1] + g[0][2]) % 2;
	h[0][2] = (g[0][1] + g[1][2]) % 2;
	h[1][0] = (g[0][0] + g[1][1] + g[2][0]) % 2;
	h[1][1] = (g[0][1] + g[1][0] + g[1][2] + g[2][1]) % 2;
	h[1][2] = (g[1][1] + g[0][2] + g[2][2]) % 2;
	h[2][0] = (g[2][1] + g[1][0]) % 2;
	h[2][1] = (g[2][0] + g[1][1] + g[2][2]) % 2;
	h[2][2] = (g[2][1] + g[1][2]) % 2;
	for (int i = 0; i < 3; i++) {
		for (int j = 0; j < 3; j++) {
			g[i][j] = h[i][j]; // 最后再赋值
		}
	}
}

bool isZero() {
	for (int i = 0; i < 3; i++) {
		for (int j = 0; j < 3; j++) {
			if (g[i][j] == 1) {
				return false; // 一旦有非零（为 1）的元素则直接返回假
			}
		}
	}
	return true; // 没有非零（为 1）的元素
}

int main() {
	cin >> n;
	while (n--) {
		ans = -1; // 计数器初始化
		for (int i = 0; i < 3; i++) {
			for (int j = 0; j < 3; j++) {
				char ch; // 这里使用字符进行读取并转换为整型
				cin >> ch;
				g[i][j] = ch - '0'; // 转换
			}
		}
		while (!isZero()) { // 切记要用 while，不断变换直到全部为零
			func(); // 变换
			ans++; // 次数
		}
		cout << ans << endl; // 输出
	}
	return 0;
}
```