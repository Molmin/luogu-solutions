shadowice大爷讲了一个$n^2$的做法 这里补一个$KlogK$的做法

也是倒序考虑每一个操作，对于一个操作$[l, r]$，他产生的影响区间将是$[r+1,r + r + l - 1]$，如果$r+l-1>K$的话，$K$之后的区间我们是不关心的。

暴力扫描这个区间 然后对于每一个位置，维护一个类似于并查集的东西。

扫到位置$i$，定义数组$f$ 表示$i$这个位置上的字符是由$f_i$这个位置上的字符填充得到的。然后删除$i$。

这个东西具体怎么搞？我们可以弄一个长度为K，初始化为1的序列。获得第$i$个位置就是这个序列上第$i$个1，然后删除这个位置上的字符，就是把序列上该位置的1变成0。维护这个序列的话树状数组+二分或者树状数组+倍增花式搞，我选择后者，毕竟前者复杂度多一个$log$。不会的话可以看lyd那本书的P203(第一版)，或者做一下poj 2182.

当然线段树维护也是可以的啦~

所以我们就得到如下算法：

倒序扫描每一个操作，维护一个变量$now$表示我们关心的区间末尾，对于每次操作的区间$[l,r]$，用一个变量$x$扫描$[r+1,r+l-1]$所要填充的字符的位置。每填充一个数$now$就减一，如果$r>now$就直接停止。因为$now$的缘故，最多填充次数为$K$。每次填充时，设$tmp$为01序列中第$r+1$个1，那么将$tmp$位置上的数减一，然后更新$f_{tmp}$为第$x$个1的位置

然后从左往右求解，如果$f_i$存在，那么$ans_i=ans_{f_i}$，不然$ans_i=s_{j+1},j++$ 由于$f_i$必然比$i$小 所以这样做一定是正确的

代码可见我的[cnblog](https://www.cnblogs.com/Rorshach/p/9846884.html)