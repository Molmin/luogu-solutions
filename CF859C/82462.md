虽然我也不知道为什么会被评成黑题（这题顶多蓝题难度），因为就连我这样的蒟蒻都能几分钟切掉它....

总有一种恶意评级的感觉来着........

数据范围简直神坑（50很容易让人想到n^3或者以上的算法啊.....）。

然而实际上的时间复杂度是O（n），就算是1e6都能做....（我还一直以为是错的不敢交）

好的那我们步入正题，这道题实际上是一道比较具有博弈性质的题。

介于两方都需要以最优策略进行操作，贪心是肯定行不通的，于是我们考虑dp

首先我们可以发现，由于双方进行的操作**对后面的状态会产生影响**
所以说如果我们直接正着dp，定义dp[i]为选到了前i个城市的时候先手（其实先后手一样）能够取得的最大收益，我们会发现：**它的状态和选择方式（选或者不选以及这里先手到底能不能选）会产生后效性**,因为你这一步选了跟不选，一方面会影响之后的选择的结果，另一方面会影响到之后另一个人最优决策的方式，这样就使得dp的值不仅与它所存在的状态有关系，同时也与**到达这个状态的方式**有关系，这个是dp所不能允许的（就算记录选或不选的状态也解决不了这个问题）

所以我们考虑倒着dp,定义dp[i]为当前的人在从i开始选，一直到游戏结束所能够获得的最大收益，那么我们会发现这个dp的重要性质：由于你选择一个物品之后的最优解是单一的，转移过后最终推得的结果仅与这个状态本身有关系，而两人之后的最优决策都固定了，所以就拥有了无后效性，于是可以使用dp来解决
我们定义从i开始的后缀和为sum[i],那么dp方程就确定了

dp[i]=max(dp[i+1],sum[i+1]-dp[i+1]+a[i]);

如果考虑不选，那么选了这次以后，选择权仍然在自己手上，那么我们直接用下一个的dp值就好（因为i+1的选择权仍然在自己手上）
如果选择了的话，那么我们就会选择所有除去对手选择范围之外的所有城市，再加上这次选择这个城市能够得到的价值

先后手这种问题就在sum[1]-dp[1]和dp[1]之间二选一跟着样例拍一下就知道啦~~~~
```cpp
#include<cstdio>
#include<cctype>
#include<algorithm>
const int MAXN(1e5+5);
inline int read()
{
	char ch(getchar());
	int x(0);
	int flag(1); 
	while(!isdigit(ch))
	{
		if(ch=='-')
		{
			flag=-1;
		}
		ch=getchar();
	}
	while(isdigit(ch))
	{
		x=(x<<1)+(x<<3)+(ch^48); 
		ch=getchar();
	}
	return flag*x;
}
int sum[MAXN];
int a[MAXN];
int dp[MAXN];
int main()
{
	int n(read()); 
	for(int i=1;i<=n;i++)
	{
		a[i]=read();
	}
	for(int i=n;i>=1;i--)
	{
		sum[i]=sum[i+1]+a[i]; 
		dp[i]=std::max(dp[i+1],sum[i+1]-dp[i+1]+a[i]);
	}
	std::printf("%d %d\n",sum[1]-dp[1],dp[1]);
	return 0;
}
```