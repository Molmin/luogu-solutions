### 【题意描述】
你有一个细菌培养皿，现在要通过这个培养皿完成一些事情……培养皿中有 n 个细菌，每个细菌的大小为Ai,并给出一个常数 k 。然后他们要互相吞噬。而 i 菌能吞噬 j 菌的条件为 Ai > Aj而且Ai + k < Aj，但吞噬完成后 Ai 的大小是不变的(QwQ)。请你求出吞噬停止时培养皿中的细菌数量。

### 【分析】
这道题只要仔细分析，不难想到正解。~~（主要是英语太弱）~~既然 i 和 j 并没有相邻的要求，那么可以**将它们从小到大排序，然后扫一遍让后面一个满足条件的细菌吞噬前面一个细菌**。可是怎么处理数据中大小相同的细菌呢？因为如果直接排序两个大小相同的细菌并不能在O(n)的处理中完成。所以可以再利用一个 b[ ]数组。**b 的下标表示此细菌的大小，储存了此大小的细菌有几个的信息**。这样就像使用一个 set ，保证其中数据不重复，再排序 b[ ] 即可。

### 【核心代码】
1、读入处理 b[ ]。
```cpp
for(int i = 1; i <= n; i++)
	{
		t++;
		cin >> a[t];
		if(b[a[t]] != 0)
		{
			b[a[t]]++;
			t--;//下一个读入直接覆盖上一个多余的
		}
		else
			b[a[t]]++;//如果已经出现直接数量++
	}
```

2、O(n)扫一遍，如果满足条件就吞噬，ans减去此菌的数量
```cpp
ans = n;
for(int i = 1; i <= t - 1; i++)
	if(a[i] + k >= a[i + 1])
		ans -= b[a[i]];
```

### 【正解】
```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
using namespace std;

int n, k, t, ans;
int a[1000010], b[1000010];
//Ai的值小于10的6次方，注意数组范围

int main()
{
	cin >> n >> k;
	ans = n;
	for(int i = 1; i <= n; i++)
	{
		t++;
		cin >> a[t];
		if(b[a[t]] != 0)
		{
//			t--;
			b[a[t]]++;
			t--;
		}
		else
			b[a[t]]++;
	}
	sort(a + 1, a + t + 1);
	
	for(int i = 1; i <= t - 1; i++)
		if(a[i] + k >= a[i + 1])
			ans -= b[a[i]];
	
	cout << ans;
	
	return 0;
}
```