[题目传送门](https://www.luogu.com.cn/problem/CF990B)

标签：排序

思维含量相对较高，但代码实现难度不大。

### 思路：

首先我们来思考一个问题：为什么标签是排序呢？

（下面的解读仅限于中文翻译，不包括英文题意）

我们仔细读一下题（当然，翻译版的已经相当简洁了），就会发现，只要满足 $a(j)< a(i)$ 和 $a(i)\le a(j)+k$ 这两个条件（$i$ 为任意数），就要将 $a(j)$ 就会被删去，最后统计有多少个 $a(j)$ 会被删去（也就是有多少个 $a(j)$ 符合条件）。

可能会有大佬说用这个那个数据结构，不过这个其实纯粹计数加标记就行，不必真的从数组中删除。

很明显，只有当 $a(i)>a(j)$ 时，$a(j)$ 和 $a(i)$ 才可能满足条件。所以我们需要把 $a$ 数组排成升序，然后从一个点往前排查，看能否删除。能删除就让答案减一。

注：降序也可以实现，不过都要反过来。

### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,k,ans;	//n,k如题 
int a[200005],f[200005];	//a记录数据，f标记是否走过 
int main(){
	cin>>n>>k;
	for(int i=1;i<=n;i++){
		cin>>a[i];
	}
	sort(a+1,a+n+1);	//cstring库里的sort函数 ，第三个参数不写默认为升序 
	ans=n;	//ans初始设为n，按题意一个一个删 
	for(int i=2;i<=n;i++){
		int j=i-1;
		while(f[j]==0&&j>=1&&a[j]<a[i]&&a[i]<=a[j]+k){	//满足3个条件的数可以删掉 
			ans--;
			f[j]=1;	//做好标记，避免重算 
			j--;
		}
	}
	cout<<ans;
	return 0;
}
```