# 题目：P4752 Divided Prime 2018 洛谷7月月赛 T1
## 题目描述
给定一个数字 $A$ , 这个$A$由 $a_1$,$a_2$...$a_N$ 相乘得到。  
给定一个数字 $B$ , 这个$B$由 $b_1$,$b_2$...$b_N$ 相乘得到。  
如果$\frac{A}{B}$是一个质数，请输出 $YES$ , 否则输出 $NO$。  
**保证对于一个数字，其在** $b_i$ **中出现的次数不多于于** $a_i$ **中出现的次数。**  
## 分析
$1$ . 对于数据范围$1≤a_i$,$b_i≤10^{12}$, 很明显不能暴力乘积或用数组储存出现次数，都会超过$long \ long$。( 除非你想高精 , 但会加上复杂度 )  
$2$ . 注意题目 (黑体部分) , 感觉这句话有所玄机， 拿出笔好好模拟一下。  
$3$ . 有了基本思路，要优化，还要尽量避开算出乘积，否则会TLE。  
## 解答
$1$ .仔细推理一波，我们会发现，当 $n$ 等于 $m$时，$a$和 $b$ 数组(在没$1$的情况下 )绝对不可能满足相除为质数，即使当两者完全相同时都只能得到非质非合的 $1$ ; 当 $n$比 $m$大$2$及以上时，即使 $a$，$b$前 $n$项完全相同时（在没$1$的情况下),剩余两个数，乘积明显为合数,即：    
$\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ n=m+1$ 时符合$YES$条件.    
$2$ .我们还需要比较两数组 ，将它们升序排列，设定 $l$ , $r$两数组的指针 ，当$a_l=b_r$时,上下可以消去，继续向后移动指针直到上下不相等，需要寻找新的$a_l$,使重新相等，将$l$指针单独向后移动 ，注意判定范围，不要越到 “TLE领域”（因为那里都是$0$，上下相等，停不下来）,即：  
$\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ if(a_l=a_i)then\ inc(l\ and\ r)$  
$\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ else\ inc(l)\ ...$  
$3$ .如何避免TLE呢，其核心是提前因某些充要条件跳出循环，当我们用 $sum$记录下 $a$ 数组中比 $b $多出数字的乘积，思考发现 ，如果 $sum$ 已经是合数了（或者说是多出了两个以上，这是大多数人的思路 ）就可以跳出循环打出 $NO$，即：
$\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ sum=sum\times a_l$  
$\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ if(sum\ not\ a\ prime\ or\ cnt=2)\ break$  
$4$ .当$r=m $时，最坏的情况是两数组之前完全相同 ，$a$ 数组可能还差最后一项没有判定是否为质数，就需要判定一下，在统计时乘上即可。  
$5$ .如果这一切你都没听懂，我模拟给你看：  
样例中$a={5,7,7,7}$  , $b={5,7}$;  
$5,7,7,    ->7,7->7(left)$  
$5,7\ \ \ \ \ \  ->5\  \ \ ->NO$  
上代码，其中有细节问题：
```cpp
inline bool judge(LL x)//判是否为质数。
{
  if(x==1||x==0)return false;
  if(x==2)return true;
  for(int i=2;i<=sqrt(x);i++)
    if(x%i==0)return false;
  return true;
}
LL t,n,m,l,r,sum,a[N],b[N],flag_1,flag_2;//sum:记下乘积，flag_1:判断是否是解答4的情况。
inline void inti()//多组数据，不要忘记。
{
  memset(a,0,sizeof(a));
  memset(b,0,sizeof(b));
  sum=l=r=1;
  flag_1=flag_2=false;
}
int main()
{
  t=read();
  while(t--)
  {
    inti();
    n=read(),m=read();
    for(int i=1;i<=n;i++)a[i]=read();
    for(int i=1;i<=m;i++)b[i]=read();
    if(n-m>=2||n==m){printf("NO\n");continue;}//解答1的情况（其实我偷懒了，没有判定数组中有1的情况。
    sort(a+1,a+n+1);
    sort(b+1,b+m+1);
    while(true)
    {
      if(l>n)break;
      else if(r>m){flag_1=true;break;}
      if(a[l]==b[r]){l++,r++;continue;}
      else sum*=a[l],l++;//其实这样可以避免数组中有1的情况，cnt记录次数就无法避免，还要写很多代码来判定。
      if(!judge(sum)){flag_2=true;break;}//解答3的情况。
    }
    if(flag_1)sum*=a[n];//循环外别忘了乘上最后一项。
    if(!judge(sum)||flag_2)printf("NO\n");
    else printf("YES\n");//注意，大写，大写，大写，我被坑了。
  }
  return 0;
}
```
## 总结  
$1$ .面对这种大数据，不要头铁，好好优化。  
$2$ .这个题我改了很久，在小细节上吃了不少亏，务必写好特判。  

感谢大观看题解，代码不是很简洁（某利益文同学说的），但是速度还可以，好歹暂时能进第二面，不喜勿喷，谢谢。