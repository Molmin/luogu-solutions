这题我们究其本质，首先可以发现，操作的顺序对结果没有影响，那么我们可以找一种处理起来最方便的处理方式。  
可以发现从后往前处理最方便。因为一次操作可以对其前面的字符产生影响，但对后面的字符是没有影响的。

于是我们从后往前扫描这个字符串。  
如果当前的字符为 `a`，那么它和它后面的字符组成的字符串一定是 `abbb...baaa...a`，也就是它后面一定是紧跟着一串 `b`（当然可以是 $0$ 个 `b`），然后又是一串 `a`（当然也可以是 $0$ 个 `a`），因为如果还有 `b` 在 `a` 前面那么还需要操作。  
然后，考虑操作的内在含义，可以发现每次操作都会让这个 `a` 后面的 `b` 的个数 $-1$，所以对于字符 `a`，让操作数加上其后 `b` 的个数。  
**同时我们也可以发现，其后 `b` 的个数其实就是当前扫到的 `b` 的个数。（当然也包括操作产生的 `b` 的个数）所以可以用一个计数器来记录当前扫到的 `b` 的个数。**  
同时，每次操作都会使 `b` 的个数 $+1$，那么做完这一整串的操作后，`b` 的总个数就应该 $\times 2$。  
那么如果当前扫到的字符是 `b` 呢？让 `b` 的个数的计数器 $+1$ 即可。  

具体实现见Code：
```cpp
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;
string s;
int ans,b;//b是计数器
const int mod=1e9+7;
int main()
{
	cin>>s;
	for(int i=(int)s.length()-1;i>=0;i--)
		if(s[i]=='a') ans=(ans+b)%mod,b=b*2%mod;
		else b++;
	printf("%d\n",ans);
	return 0;
}
```