[不出你的意料，今天我又来写题解了（你可能会问我为什么还没有开学）。这一次我写的题解是一道交互题的题解，毕竟是第一次写这种交互题的题解，写得不太好请大家别太在意，您可以在评论区来留言，我会根据你的留言来完善一下本篇题解或是下一篇题解。](https://oi-master.github.io/post/codeforces-contest-1010-b-and-1011-d-ti-jie/)

好的，我们仍然按照老配方，题面先。

## 题面
### 英文题面
如果你以前看过我写 Codeforces 的题解，你应该很清楚， [这里](https://codeforces.com/contest/1010/problem/B)会挂个链接，而不会写题面。
### 中文题面
请去 [洛谷站内](https://www.luogu.com.cn/problem/CF1010B) 了解。嘿，有点过分，上次是直接复制洛谷的翻译，这次只给个链接？！是的，没错，翻译的很好，“抽风”这个词十分得恰当。
## 思路
省掉了题面，这一篇文章短多了。我们首先假设，火箭不会抽风，那么你会怎么做？很显然，我们可以二分一下这个值，每次输出 $mid$ ，看一下交互器的相应。

但是，事实上没有这么好，火箭随时可能抽风，那么假设我们知道抽风的序列 $p$ ，那么是不是这一道题也很简单？我们看见本轮火箭要抽风了，我们就把火箭的答案反转一下，也可以二分。

问题是，现在我们并不知道 $p$ ，那么怎么搞？等等，我们先放着。

我们可以先了解一下，二分至 $10^9$ 要多少次。我们用 Python 求一下吧。

```python
tmp=1
tot=0
while tmp<1000000000 :
    tot+=1
    tmp*=2
print(tot)

```

输出了 $30$，这时候我们貌似想到了什么……
我们惊讶地发现，火箭抽风的周期也是 $30$ ，加起来就是 $60$ 次！

那么很显然，我们可以拿前 $30$ 次来确定火箭抽风的序列，然后把后 $30$ 次用来二分。这个想法实在是太好了！

还有，我们前 $30$ 次怎么确定？其实我们只需要一直输出 $1$ 就可以了，如果它输出 $1$ ，那么本轮就不会抽风，如果是 $-1$ ，那么就说明会抽风，如果是 $0$ ，那么数据太巧，要特判。

然后，就是可爱的代码啦。
## 代码
```cpp
/* Generated by powerful Codeforces Tool
 * You can download the binary file in here https://github.com/xalanq/cf-tool
 * Author: OI_Master
 * Time: 2020-04-07 07:13:12
**/
#include<bits/stdc++.h>
using namespace std;
#define int long long
signed main() {
	ios::sync_with_stdio(false);
	cin.tie(0);
	int n,m;
	cin>>n>>m;
	int a[m+1],tmp;
	for(int i=1;i<=m;++i){
		cout<<1<<endl;
		cout.flush();
		cin>>tmp;
		if(tmp==0)
			return 0;
		if(tmp==-2)
			return 0;
		if(tmp==1)
			a[i]=1;
		else
			a[i]=0;
	}
	int left=2;
	int right=n;
	int mid;
	int mod=0;
	while(left<=right){
		++mod;
		if(mod==m+1)
			mod=1;
		mid=(left+right)/2;
		cout<<mid<<endl;
		cout.flush();
		cin>>tmp;
		if(tmp==0)
			return 0;
		if(tmp==-2)
			return 0;
		if(a[mod]==0)
			tmp=-tmp;
		if(tmp==1)
			left=mid+1;
		else
			right=mid-1;
	return 0;
}
```