## 题目描述
给你 $t$ 个 $01$ 数列，可以把一个元素删除并把它加到另一个元素上，让你分别求出使它们变成不降数列的最小操作次数。
## 思路
最简单的思路就是：把数列变成 $000...111$ 这样的数列。
那么如何将数列变成这样的数列呢？

第一种情况是：把前面的 $1$ 补到后面的 $0$ 上，删除前面的 $1$，这样是最优的。第二种情况是：删除 $0$，这样不优，因为第一种情况其实和这种情况是等价的，而且还把前面的 $1$ 顺便删除了。第三种情况是：删除 $1$ 补到后面的 $1$ 上，这样同样不优，因为这样还是会出现多余操作的情况，比如有这样一个数列：$100101$，将第一个 $1$ 补到后面的 $1$ 上，则数列变为 $00102$,不如第一种情况 $00111$ 优异。

根据上面的推论，就可以开始写代码了。

## 代码
```c++

#include<bits/stdc++.h>//万能头
using namespace std;
int t,n,a[100001],ans;
int main()
{
    cin>>t;
    for(int i=1;i<=t;i++)
    {
        cin>>n;
        for(int i=1;i<=n;i++) cin>>a[i];
        int l=1,r=n;
        ans=0;
        while(l<r)//进行删除&累计操作
        {
            while(!a[l]&&l<r) ++l;
            while(a[r]&&r>l) --r;
            if(l>=r) break;
            a[l]=0;a[r]=1;ans++;
        }
        cout<<ans<<'\n';
    }
}
```

点个赞再走吧~