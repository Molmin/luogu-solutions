思维难度巨大的一题。~~(对于我这种菜鸡来说)~~

### part 1 是否有解？

首先，肯定不能直接模拟操作，因为有无解的情况存在。所以说，我们要找出一个结论：在XXX的情况下，可以达到目标状态，即所有数字相同。

假设有一个数据长这样：
```
5 4
a b c A B
```
可以看到，$k$ 之前的部分用小写字母表示，而 $k$ 和之后的部分用大写字母表示。

开始模拟：

1. 复制 $A$ 到结尾，删除 $a$。 `b c A B A`
2. 复制 $B$ 到结尾，删除 $b$。 `c A B A B`
3. 复制 $A$ 到结尾，删除 $c$。 `A B A B A`
4. 复制 $B$ 到结尾，删除 $A$。 `B A B A B`

……

可以看到，几步操作后，所有的小写字母全没了。这也就告诉我们，如果有解，即所有数字相等，就一定要让所有的大写字母相等。

于是我们可以推出一个结论：只有 $k$ 和之后的部分所有数字相同的情况下，有解。

我们就可以写出如下判断是否有解的代码：

```cpp
for(reg i=k;i<=n;i++)
{
	if(s[k]!=s[i])
	{
		cout<<-1;
		return 0;
	}
}
```

### part 2 要操作几次？

已经可以确定是否有解了，是不是就可以模拟了？其实根本不需要。

再模拟一组数据：
```
5 4
a b c A A
```
1. ~~`a`~~$\ \ $`b c A A A`
1. ~~`b`~~$\ \ $`c A A A A`
1. ~~`c`~~$\ \ $`A A A A A`

可以看到，如果 $a,b,c\ne A$，那么 $ans=3$，即 $k-1$；

而如果在小写字母部分的最后有一些与 $A$ 相同的数，每有一个，$ans-1$。

就像这样：
```
6 5
a b A A|A A

ans=2
```
也就是说，答案为 $n-$ 右边那些 $A$ 的数量，即从最后往前数字相同部分数字的个数。

**总结一下，如果 $k$ 和之后的部分所有数字不相同，无解；**

**否则结果为： $n-$ 从最后往前数字相同部分数字的个数。**

### part 3 Code

```cpp
#include<iostream>
#define reg register int
using namespace std;
int s[100005];
int main()
{
	int n,k,t,f;
	cin>>n>>k;
	for(reg i=1;i<=n;i++)//读入
		cin>>s[i];
	for(reg i=k;i<=n;i++)//判断是否有解
	{
		if(s[k]!=s[i])
		{
			cout<<-1;
			return 0;
		}
	}
    
	bool tmp=true;//特判已经符合要求（即数字全相等）的情况，否则容易WA
	for(reg i=1;i<=n;i++)
		if(s[i]!=s[1])
		{
			tmp=false;
			break;
		}
	if(tmp)
	{
		cout<<0;
		return 0;
	}
    
	int ans=n;
	for(reg i=n;i>=1;i--)//倒着枚举后面相等的部分
	{
		if(s[n]==s[i])
			ans--;//每有一个与后面相等的,ans-1
		else
			break;
	}
	cout<<ans;
	return 0;
}
```
码字不易，点个赞呗~