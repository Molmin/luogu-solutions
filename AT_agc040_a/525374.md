### 题意描述
构造一个数列 $a$，使得所有的 $1\leq i\leq {N-1}$ 都满足以下条件：

- $a_i$ 为非负整数。
- 若 $S_i$ 为小于号，则 $a_i<a_{i+1}$；
- 若 $S_i$ 为大于号，则 $a_i>a_{i+1}$。

求数列 $a$ 的每一项之和。


### 解题思路
显然每一次加或减的数都要为 $1$。

如果出现大于号，就非常容易减出一个负数来。但是又要求了数列中的每一个数都是非负整数，所以可以想到，这题要顺着倒着都做一遍。

首先顺着做一遍。如果我们遇到了小于号，那么就让 $x_i=x_{i-1}+1$。

然后逆着做一遍。如果我们遇到了大于号，那么就让 $y_i=y_{i+1}+1$。

求出来的 $x$ 和 $y$ 序列都不一定是正确答案。正确答案应该是他们每一项的较大值。即对于所有的 $1\leq i \leq N$，有 $ans_i=\max(x_i,y_i)$。经检验，发现这是正确的。

举个例子，当 $S$ 为 ```>><><``` 时：

- 首先顺着做一遍。每一次遇到小于号，都要将其设定为前一个数加 $1$。序列 $x$ 就为 $[0,0,0,1,0,1]$。
- 然后逆着做一遍。每一次遇到大于号，都要将其设定为右边的数加 $1$。序列 $y$ 就为 $[2,1,0,1,0,0]$。
- 将所有的 $1\leq i \leq N$ 中的 $ans_i$ 设定为 $\max(x_i,y_i)$。 序列 $ans$ 就为 $[2,1,0,1,0,1]$。

所以，就应该输出 $5$。

### 代码
两个注意点：

- 注意字符串的长度与构造出的序列的长度相差 $1$。
- 要使用 long long。
```cpp
#include<bits/stdc++.h>
using namespace std;
string st;
long long len,x[500010],y[500010],ans;
int main(){
		cin>>st;
		len=st.size();
		x[0]=0;//使用x表示顺序遍历。 
		y[len]=0;//使用y表示逆序遍历。 
		for(int i=1;i<=len;i++)
			if(st[i-1]=='<')x[i]=x[i-1]+1;
		for(int i=len-1;i>=0;i--)
			if(st[i]=='>')y[i]=y[i+1]+1;
		for(int i=0;i<=len;i++)
			ans+=max(x[i],y[i]);
		cout<<ans<<endl;
		return 0;
}
```
写在最后：管理大大求过。

