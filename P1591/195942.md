**思路**：高精+枚举

**首先**，我们计算出来n!用高精储存。

如果用int型数组存储的话，其实每一个int的数可以存储6位(0-999999)。
```cpp
#include<cstdio>
int main()
{
	int i=0x7FFFFFFF;
	printf("%d %d",i,i/1000);
}
```
这个程序输出： _2147483647_   _2147483_ ，那么意味着6位最大的int数乘以1000也不会爆炸。

用6位的int参与计算可以提速，减少内存。因此我们可以充分地利用int。

**然后**，我们枚举每一位的数字是不是数码a即可。
```cpp
#include<cstdio>
#define N 1000000 //宏定义，每个int变量取6位存储 
int main()
{
	int x[500]={}; //500个int变量，足以表示 1000! 
	register int T,n,h,a,i,j,sum;  //register提速 
	scanf("%d",&T);
	while(T--)  //T组数据 
	{
		scanf("%d%d",&n,&a);
		x[0]=1,h=0,sum=0;  //每次开始都要赋初值 
		for(i=1;i<=n;i++)  //计算n! 其中h表示栈顶 
		{
			for(j=0;j<=h;j++) //各位相乘 
				x[j]*=i;
			for(j=0;j<=h;j++) //进位 
				x[j+1]+=x[j]/N,x[j]%=N;
			if(x[h+1])h++; //如果溢出原来的栈顶，栈顶+1 
		}
		while(x[h]) //栈顶数据的6位不是每一位都可以枚举 
		{           //比如000001，数码a=0的话前5个0不能要 
			if(x[h]%10==a)sum++;
			x[h]/=10;  //这里可以方便计算，顺便清零 
		}
		for(i=0;i<h;i++)  //非栈顶数据枚举各位数字 
		{
			j=6; //枚举6次 
			while(j--)
			{
				if(x[i]%10==a)sum++;
				x[i]/=10;  //这里可以方便计算，顺便清零 
			}
		}
		printf("%d\n",sum);  //输出 
	}
}
```
