首先要处理输入，题目说了，输入是按深度优先给出的。

然后要考虑拿不拿画。  
其实这就是01背包。对于每一幅画，我们可以要，也可以不要。那么我们就定义一个状态 $f\,[\,i\,]\,[\,j\,]$ ,表示在节点 $i$ 花费了 $j$ 秒可以得到的最大价值。再定义一个 $d$ 数组，用于统计每次偷画的价值。

如果小偷在展室，那么对于 $d\,[\,k\,]$ ，应等于  
$\max(\,d\,[\,k\,]\,,\,d\,[\,k\,]-\,b\,[\,x\,][\,i\,]\,]\,+\,a\,[\,x\,][\,i\,]\,)$  
其中， $d\,[\,k\,]$ 表示当前最大的的价值， $b\,[\,x\,][\,i\,]$ 和 $a\,[\,x\,][\,i\,]$ 分别表示偷画需要的价值和时间。
最后再把值赋给 $f$ 数组。

如果小偷还在走廊（连接两个走廊的那种），那么 $f\,[\,i\,][\,j\,]$ 应等于 $\max\,(\,f\,[\,i\,][\,j\,]\,,\,dp\,(\,i\,\times\,\,2\,,\,$ 时间 $\,)\,+\,dp\,(\,i\,\times\,2\,+\,1\,,\,j\,-\,$ 走左子树用的时间 $\,-\,t\,[\,x\,]\,)\,)$    
$i\,\times\,\,2\,,\,$ 表示左子树， $\,i\,\times\,2\,+\,1\,$ 表示右子树

AC代码
```cpp
#include<cstdio>
#include<vector>
#include<cstring>
#include<iostream>
using namespace std;
const int N=607;
int s,t[N],h[N],f[N][N],d[305],a[N][N],b[N][N];
void dfs(int x)//其实题目的输入是按dfs的顺序输入的，所以用dfs来处理 
{
	scanf("%d %d",&t[x],&h[x]);
	t[x]*=2;//小偷是要回到起点的，所以要来回 
	if(!h[x])//说明这里连接的是走廊 
		dfs(x*2),dfs(x*2+1);//x*2代表左子树， x*2+1代表右子树
	else//负责这就是展室 
		for(int i=1;i<=h[x];i++)
			scanf("%d %d",&a[x][i],&b[x][i]);
} 
int dp(int x,int k)
{
	if(f[x][k] || !k)//说明已经访问过了，或者没时间了 
		return f[x][k];
	if(h[x])//说明里边有画 
	{
		memset(d,0,sizeof(d));
		for(int i=1;i<=h[x];i++)
			for(int j=k-t[x];j>=b[x][i];j--)//01背包模板 ，j=k-t[x]意思是当前剩下的时间（总时间-过走廊的时间），然后j必须大于等于b[x][i]（偷画时间），不然就没办法偷到画 
				d[j]=max(d[j],d[j-b[x][i]]+a[x][i]);//d[j-b[x][i]]+a[x][i]表示偷完画以后获得的价值 
		f[x][k]=d[k-t[x]];
		return f[x][k];
	}
	for(int i=0;i<=k-t[x];i++)//说明这连接的是走廊 
		f[x][k]=max(f[x][k],dp(x*2,i)+dp(x*2+1,k-i-t[x]));//取能获得的最大价值 
	return f[x][k];
}
int main()
{
	scanf("%d",&s);
	dfs(1);
	dp(1,s-1);//小偷不能在第s秒回去，最多只能s-1 
	printf("%d",f[1][s-1]);
	return 0;
}
```
