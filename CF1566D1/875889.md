# 题目大意
给你 $T$ 组样例，每组样例中有 $n\times m$ 个人的视力值（但因为题目说 $n$ 等于 $1$，所以也就相当于是 $m$ 个数），现在，想让你求出**靠前的人的视力值比后面的人的小**的组数。


------------

# 分析
这道题完全就是一个暴力题，每枚举到一个位置，就从他前面看看哪个值小于当前位置的值，并且累加起来，最后输出即可。


------------
# 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int T,n,m,ans,a[310]; //定义变量。因为n等于1所以只用一维数组 
int main(){
	cin>>T;
	while(T--){
		ans=0;
		scanf("%d%d",&n,&m); //输入 
		for(int i=1;i<=m;i++){
			scanf("%d",&a[i]); //把它们当一位数组来输入 
			for(int j=1;j<i;j++) //从第一个位置到i的前面一个位置遍历 
				if(a[j]<a[i]) //如果前面的比后面的小，组数++ 
					ans++;
		}
		printf("%d\n",ans); //输出答案 
	} 
	return 0;
}
```
