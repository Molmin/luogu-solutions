## 这道题最重要的是明确你的解题方法
#### 思路：
这道题就是让你把一窜字符串转化成字典序最小的字符串，并且题目给出的是只有三个数字成的，所以这道题我们可以先思考一下，想要字典序最小，也就是让Ascll顺序最小，所以我们可以把小的数尽量放前面，大的尽量放后面。我们先输入字符串，然后我们可以先把里面的$1$的个数先找出来，让$2$之前的$0$都先输出，有人可能会问，2之后的$0$怎么办呢，因为$2$不能和$0$调换，所以$2$之后的$0$只能原地不动。在前面依次输出$0$后遇到了$2$后，要使字典序最小，我们可以再把所有的$1$依次输出来，再来输出$2$，如果$2$后面有$0$，依然输出。

模拟以上做法，这道题就迎刃而解啦！
#### 提示
返回字符串长度属性（整数）： $s.length()$

进入下一重循环： $continue$

上AC代码（ c++ ）
```cpp
#include<bits/stdc++.h>
using namespace std ;
int ans ;
int k ;
int main()
{
	string s ;  
	cin >> s ; //输入字符串 
	for ( int i = 0 ; i < s.length() ; i++ )
	{
		if ( s[i] == '1' ) //统计字符串内1的个数 
	    {
            ans++ ;
        }
     }  
	for ( int i = 0 ; i < s.length() ; i++ )
    {			
		if ( s[i] == '0' ) //如果是0直接输出 
        {
        	cout << 0 ;
        	continue ; //不必往下走了 
 		} 
        if ( s[i] == '1' ) //如果是1直接进入下一重循环 
        {
            continue ;
        }
        if( s[i] == '2' ) //判断是否是2 
        {
             if ( k == false ) //再判断是否是第一个2 
            {
                for ( int j = 1 ; j <= ans ; j++ ) //如果是的话就把所有的1输出来 
                {
                	cout << 1 ;
                }
                k = true ; //记录下来 
            }
            cout << 2 ; //然后再直接输出2 
        }
    }
    if ( k == false ) //如果字符串中没有2，那就直接把所有的1输出来，不要漏掉这一步 
    {
        for ( int i = 1 ; i<=ans ; i++ )
        {
			cout << 1 ;
        }
	}
	return 0 ; //好习惯 
}
```
真心希望能帮助到大家！