###### ~~我就是个蒟蒻， 本人第一次写题解， 希望管理大大给我过~~
------------
## 下面进入正题
首先我们分析一下题目：
求等差数列中丢失的一项

因为提示中已经说了：确保有解 ，  那我们就不用想太多，而且是多解题，我仅提供我AC的版本

### 我们先排个序
```cpp

#include<cstdio>
#include<algorithm>
using namespace std;
int a[10];

  
//省略main函数
  
	scanf("%d%d%d", &a[1], &a[2], &a[3]);
	sort(a+1, a+4);
```
```


------------
我总结了三种情况：（使用我自己举的例子， 第x项指从小到大排序的第x项）

①：缺失第二项    例如： 5 ，（） ，13, 17

我们很容易可以分析出，第二项为9。 怎么分析？
第三项-第一项 > 第四项-第三项
所以：

if(a[3]-a[2] > a[2]-a[1]) printf("%d", a[3]-(a[2]-a[1]));
```


②：缺失第三项    例如：5 ,  9 ，（），17

其实等同于第二种，不多赘述
```cpp
if(a[3]-a[2] < a[2]-a[1]) printf("%d", a[2]-(a[3]-a[2]));
```

③：缺失最大/小的那项

这种最好判断 如果题目给的三个数已构成等差数列，就直接输出第一/四项（我选择第四项）

```cpp
if(a[3]-a[2] == a[2]-a[1]) printf("%d", a[3]+a[3]-a[2]);
```
然后就~~不出意外~~AC了    ~~（是不是很神奇呢？）~~

下面给AC代码， 仅供参考

```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
int a[10];

int main()
{
	scanf("%d%d%d", &a[1], &a[2], &a[3]);
	sort(a+1, a+4);
	if(a[3]-a[2] == a[2]-a[1]) printf("%d", a[3]+a[3]-a[2]);
	else if(a[3]-a[2] > a[2]-a[1]) printf("%d", a[3]-(a[2]-a[1]));
	else if(a[3]-a[2] < a[2]-a[1]) printf("%d", a[2]-(a[3]-a[2]));
	return 0;
}
```

~~再次希望管理大大给本蒟蒻一个机会~~