我的思路：先读入那三个数，再排序一下。然后计算出第 2 小的数的与第 1 小的数的差 c1 和第最大数与第 2 小的数的差 c2。

然后分三种情况讨论：

我们设数列中的四个数分别为： m1, m2, m3, m4 。

1. c1 = c2 这样差一样，一定有一种情况是已输入 m1, m2, m3，我们输出 m4 = m3 + 公差 即可。

1. c1 > c2 这样前面的差大，一定有一种情况是已输入 m1, m3 ,m4 ,我们输出 m2 = m3 - 公差 或 m1 + 公差 即可。

1. c1 < c2 这样后面的差大，一定有一种情况是已输入 m1, m2 ,m4 ,我们输出 m3 = m4 - 公差 或 m2 + 公差 即可。

最短代码：

[三目运算符请参阅](https://miller2019.blog.luogu.org/solution-cf1169a)


```cpp
#include<bits/stdc++.h>
int n[3],c1,c2,c3;
int main()
{
	scanf("%d%d%d",n,n+1,n+2); //读入 n[0],n[1],n[2]。
	std::sort(n,n+3);//排序一下，因为我们是从下标 0 使用到下标 2 的，所以排序的起始位置是 n (或 n+0 )，结束位置是 n+3。
	c1=n[1]-n[0],c2=n[2]-n[1]; //计算差。
	printf("%d",c1==c2?n[2]+c1:(c1>c2?n[1]-c2:n[2]-c1));
    	//这里用了三目运算符，我们先判断是否是第 1 种情况，执行计算；如果不是，在判断是否是第二种情况。最后计算出表达式的值，输出即可。
	return 0;
}
 
```
亲测：16ms /  696.00KB	

感觉有点慢，我就优化了一下。因为数据中可能有排好序的数据，可以用 `is_sorted` 判断一下,其它跟上面一样。

这里 `is_sorted` 默认检测是否已经是从小到大排序的，是则返回 1 ，反之返回 0。我们也可以编写 cmp 函数改变规则（同 sort）。

但是请注意： `is_sorted` 是 C++11 的函数。 

```cpp
#include<bits/stdc++.h>
int n[3],c1,c2,c3;
int main()
{
	scanf("%d%d%d",n,n+1,n+2);
	if(!std::is_sorted(n,n+3))std::sort(n,n+3);//如果不是有序的，则执行 sort ；反之不执行。
	c1=n[1]-n[0],c2=n[2]-n[1];
	printf("%d",c1==c2?n[2]+c1:(c1>c2?n[1]-c2:n[2]-c1));
	return 0;
}
```
亲测：14ms /  728.00KB 

这样有效提高了在输入数据是有序情况下的速度。

这是目前评测记录最优解第 3（不算 O2）。

蒟蒻橙后第 2 篇题解。