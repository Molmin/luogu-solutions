好像没有pascal代码······给P党也发份福利。

~~我是CPP党！马蜂丑陋勿喷。~~

首先思路：

相当于原始为空的图。

每次加一条边，保证不形成环。

直到全部联通求加边方案数。

由于先加后加是一样的，不妨设为同时加~

~~小猴打群架。~~

最后再乘上$(n-1)!$

另外，没有环又连通，你想到了什么？

**树！！！**

没错，最终形成的一定是一棵树。

现在已经很清晰了，相当于$n$个点求构成树的数量。

相当于求$n$个点完全图生成树个数。

这个是有定理的（好像叫$Prufer$定理？），总个数为$n^{n-2}$.

大致证明思路就是把每棵生成树和一个长度为$n-2$,每个数可以取1到$n$的序列一一对应起来。

所以最后答案就是$(n-1)!\times n^{n-2}$

代码（Pascal）：
```pas
var n,ans,i:int64;
begin
    readln(n);
    ans:=1;
    for i:=1 to n-2 do ans:=(ans*n) mod 9999991;
    for i:=1 to n-1 do ans:=(ans*i) mod 9999991;
    writeln(ans);
end.
```
想要C++代码的可以去看其他dalao的题解。

Over.