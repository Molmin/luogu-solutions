//2019-05-15修正一处公式错误（感谢@Frame用户的指出）
## 这道题和[P4981](https://www.luogu.org/problemnew/show/P4981)异曲同工，只不过更为繁琐（~~简单~~），这里对于公式给出证明。

一句话题意，就是问你$n$个有编号的结点的无根生成树个数。

首先，我们知道对于一棵结点没有差异的有$n$个结点的无根树，其形态有$n^{n-2}$种。

证明在我在P4981的[题解](https://york2005.blog.luogu.org/solution-p4981)里面有。但是我还是不要脸的复制过来。（在最下面）

然后呢，对于每一种结点之间没有差异的树，给它的每一个结点打上编号一共有$n!$种方法。

所以答案就是很简单的
$$n ^ {n - 2} * (n-1)!$$
乘法原理推导即可。

```
#include<cstdio>

int n;
long long ans = 1;

int main()
{
    scanf("%d", &n);
    for(int i = 1;i <= n-2;i ++) ans = (ans * n) % 9999991;
    for(int i = 1;i <= n-1;i ++) ans = (ans * i) % 9999991;
    printf("%lld", ans);
}
```

## 【证明】（~~重点~~）
p.s 学习自https://www.cnblogs.com/dirge/p/5503289.html

首先引入$prufer$编码（这个单词的正确写法不是这样，但是很难打出来，以下以此代称）

一棵无根树的$prufer$编码的值运算如下：
```
首先定义无根树中度数为1的节点是叶子节点。
找到编号最小的叶子并删除，序列中添加与之相连的节点编号，重复执行直到只剩下2个节点。
```
（转载自https://www.cnblogs.com/dirge/p/5503289.html）

举个例子，对于下图的树
![](https://cdn.luogu.com.cn/upload/pic/58231.png)

它的$prufer$编码就是4, 3, 3

显然，一棵有$n$个结点的无根树，它的$prufer$编码是唯一的，且有$n-2$个可能相同的元素。

### 那么如何由一个$prufer$编码转化为二叉树？
那个博客上的巨佬是这么说的：
```
设点集V={1,2,3,...,n}，每次取出prufer序列中最前面的元素u，在V中找到编号最小的没有在prufer序列中出现的元素v，给u，v连边然后分别删除，最后在V中剩下两个节点，给它们连边。最终得到的就是无根树。
```
很显然，每一个$prufer$序列与一棵无根树一一对应。

因此，对于一棵已知有$n$个结点的无根树，一定有一个$n-2$长度的序列，那么，我们枚举所有长度为$n-2$的序列，发现其与所有可能形态的无根树一一对应。而这种序列，根据**乘法原理**，有
$$n ^{n - 2}$$
个可能的序列。

因此，对于一个已知的$n$，有$n^{n-2}$种不同的无根树。

