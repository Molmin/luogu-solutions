先不考虑修改，考虑查询的实质。

题目里给了一个差分数组单调上升的条件，我们自然地去将问题放到差分数组上考虑。记 $c,d$ 为 $a,b$ 的差分数组，然后你会发现我在 $(i,j)$ 位置往下走/往右走一步相当于将 $c_{i+1}$ / $d_{j+1}$ 加入后面所有步的贡献。

进一步的，由差分数组单调上升，我们容易得到每次选取 $c_{i+1}$ 和 $d_{j+1}$ 中更小的那个必然不劣。

若我们将 $c$ 和 $d$ 归并得到数组 $x$，那么答案可以表示为：

$(n+m-1) \times (a_1+b_1) + \sum\limits_{i=1}^{n+m-2} (n+m-1-i) \times x_i$

而修改操作对差分数组就是后缀加。

但是每次查询都进行归并的话显然是吃不消的。我们注意到 $n \le 100$ 看上去很有用，我们可以这么做：

对于 $c$ 数组的修改直接暴力，而 $d$ 数组在线段树上维护。

对于查询的贡献我们分成三部分：$c$ 数组自身的贡献；$d$ 数组自身的贡献；将 $c$ 和 $d$ 归并起来时，额外造成的贡献。

$c$ 自身的贡献即为 $\sum\limits_{i=1}^{n-1} c_i \times (n-i)$，$d$ 同理。这个是好维护的。

每次归并的时候只需要考虑将 $c_i$ 插入 $d$ 数组时的贡献。$d$ 数组中所有比 $c_i$ 小的数会多一步贡献，而其他数会给 $c_i$ 造成一步贡献。容易用线段树二分实现。

总时间复杂度 $O(nq \log m)$，我 CF 上跑了 5500ms，鉴定为人傻常数大。

[code](https://codeforces.com/contest/1609/submission/203618558)