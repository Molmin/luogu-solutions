**翻译**

给你正整数 $n,d,k$。你的任务是标记数，按如下方法标记：
1. 第一步标记 $0$。
2. 如果上一个标记的数是 $a$，标记 $(a+d)\bmod n$，如果这个数被标记过了，标记 $(a+d+1)\bmod n$，如果依然被标记过了，继续标记下一个数，直到它没有被标记过。
3. 如果 $0$ 到 $n-1$ 都被标记了，停止；否则重复步骤 $2$。

求第 $k$ 次标记的是什么数。

**分析**

看这题数据范围，就知道只能是 $O(t)$ 的，也就是说对于每一组数据，都必须是 $O(1)$ 的，说明这是数学题。

首先很明显，如果 $k$ 是 $1$，直接输出 $0$ 即可。

正常情况下，第 $k$ 次标记的数应该就是 $((k-1)\times d)\bmod n$，但是有些情况会往前进位。那么“正常情况”是什么呢？很容易想到，那就是 $\gcd(n,d\bmod n)=1$ 时。

遇到非“正常情况”应该怎么办呢？易发现，除了那个特殊的 “$0$” 以外，加一情况是有规律地出现的，这时我们就可以计算它的循环节，也就是多少个数会出现一次加一。易知，出现加一情况的次数一共是 $n\div \gcd(n,d\bmod n)$。我们先算出 $((k-1)\times d)\bmod n$，再给输出的答案加上这个循环节数量就行了。

**AC Code**
```
#include <bits/stdc++.h>
using namespace std;
int main()
{
	long long t,n,d,k,tp,xhj;
	cin>>t;
	for(int i=1;i<=t;i++)
	{
		tp=0;
		cin>>n>>d>>k;
		if(d%n==0)//如果d是n的倍数，那明显就是一个一个加的
		{
			cout<<k-1<<endl;
			continue;
			
		}
		if(k==1)//特判k=1
		{
			cout<<0<<endl;
			continue;
		}
		if(__gcd(n,d%n)==1)//判断是不是“正常情况”
		{
			tp=((k-1)*d)%n;
			cout<<tp<<endl;
			continue;
		}
		xhj=n/__gcd(n,d%n);//统计循环节
		tp+=(k+xhj-1)/xhj-1;//答案加上循环节数量
		tp+=((k-1)*d)%n;//加上k-1个d
		cout<<tp<<endl;
	}
	return 0;
}
```
