## Codeforces Round 506 Div.3 C

个人觉得我的题解是最粗暴的。。。望各位dalao斧正。

____

时隔4个多月，终于把这道题给搞懂了。。。而且还是巧合之下搞懂的。

当时我做的时候，一直在想怎么处理这个删除操作。

我就想啊，怎么也会有个贪心的策略吧，于是便是一通乱弄。

结果？四个样例都有没过的。

然后又是拼命的想啊想。。。

结果硬是搞了一个多小时没有搞出来。。。我的第一次CF就这样结束了，以两题的弱鸡成绩告终。

现在想想，其实那时自己是根本不会打CF。这种题交给我现在来打，少说一场也有三四道。（不存在的）

___

下面进入正题。

到底是怎么想出来的呢？主要是2018年12月初的一天，一个dalao同学给了我这么一道题：

>给出一个序列，全部为1~1e7的正整数。输入序列长度N以及这个序列，输出N行，第I行表示除第I个数外剩余所有数的最大公约数。$N\le 500000$。

我看到这题，第一想法就是线段树。

结果那个dalao说：“如果不要数据结构呢？”

我又看了一会儿，看到数的范围不是很大，只有1e7，就想了一个用筛表+质因数分解的做法，似乎随机数据能卡过，但如果造一些全是大质数的，那就会爆掉了。

这时，另一个dalao走了过来。听了题目，他略想了一两秒钟，给出了$O(N)$的做法：

>存储两个数组l和r，分别表示“前缀GCD”和“后缀GCD”。

>那么对于第$I(1<I<N)$个数，答案就是$gcd(l[i-1],r[i+1])$。

>对于头尾两个数，答案分别是$r[i+1]$和$l[i-1]$。

>同理，这个做法可以推广到删去$[l,r]$所有的数后剩余数的GCD的题目。

我一下子豁然开朗。干嘛非得要先把它加入GCD，然后再分离出来呢？直接避开加入的过程不就好了？

这个思想是很有用的。比如，对于星球大战那道题，它让你删边，但实际上可以离线掉，直接加边搞定。

> 记住，往往比忘掉容易。

> ————某个动漫（雾）

> 插入，往往比删除容易。

> ————我（大雾）

在很多题中，这个思路都是极其重要的。

本题也是如此。思路如下：

>记录前缀区间交和后缀区间交数组lp和rp。

>扫描两次数组，把lp和rp求出来。

>则对于每条线段，删去后的区间便是$[max(lp[i-1].l,rp[i+1].l),min(lp[i-1].r,rp[i+1].r)]$。

就这样，扫描了三遍数组，巧妙地解决了本题。

可能计算过程中，会导致左端点大于右端点，不符合区间书写标准，但是我们不用理它，因为可以把$l>r$的区间$[l,r]$看作不合法区间，长度为-1。

代码如下：
```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
const int iz=3e5+5;
int lpl[iz],lpr[iz],rpl[iz],rpr[iz];//前缀与后缀
int l[iz],r[iz];//线段们
int n;
int main(){
	scanf("%d",&n);
	memset(lpr,0x7f,sizeof(lpr));
	memset(rpr,0x7f,sizeof(rpr));
	for(int i=1;i<=n;i++){
		scanf("%d%d",&l[i],&r[i]);
		lpl[i]=max(lpl[i-1],l[i]);
		lpr[i]=min(lpr[i-1],r[i]);
	}//读入&求出lp
	for(int i=n;i>=1;i--){
		rpl[i]=max(rpl[i+1],l[i]);
		rpr[i]=min(rpr[i+1],r[i]);
	}//求出rp
	int maxn=0;//把不合法的区间和长度为0的区间排除
	for(int i=1;i<=n;i++){
		maxn=max(min(lpr[i-1],rpr[i+1])-max(lpl[i-1],rpl[i+1]),maxn);//取区间长度最大值
	}
	printf("%d",maxn);
}
```