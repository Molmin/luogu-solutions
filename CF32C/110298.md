打个小广告：[点我](https://www.luogu.org/blog/hhhh123/)

以下正文：

------------
### 思路
我们用a和b来记录行和列用步数整除后分别还剩下几格,也就是a=n%s,b=m%s

然后再用c和d来记录用步数可以把行列分别分成几段,也就是c=n/s,d=m/s 

其中：a加c乘s等于n,b加d乘s等于m

于是我们便可以很容易地发现：a和b是c和d除以s以后的余数。

所以a和b就被活生生的浪费掉了。但是为了得到最大值，我们就必须要把a和b利用起来。我们浪费a和b的根本原因是只把一个点作为了起点。如果我们能够把好几个点都作为起点，就能让行和列分成的段数(c和d)的值加一，只不过每次取的格子是余数，而不是每段格子数。

最后在输出a乘b乘c乘d的值，就233啦。
### 注意
(1)如果a或b的值是0,那行或列中的每段我们都可以挑,这时a=s或b=s

(2)本题测试数据较大，需要开long long
### 代码
以下是我的超短萌新代码
```cpp
#include <bits/stdc++.h>//万能头文件
using namespace std;
long long n,m,s,a,b,c,d;
int main()
{
	cin>>n>>m>>s;//输入
    a=n%s;b=m%s;//初始化a和b的值
    c=n/s;d=m/s;//初始化c和d的值
    if(a==0) a=s;//特判a等于0的情况
    else c++;//否则就把c的段数加一
    if(b==0) b=s;//特判b等于0的情况
    else d++;//否则就把d的段数加一
    cout<<a*b*c*d;//输出
    return 0;//233啦
}

```