最近在练贪心，被这道题卡了好久，写完了发一篇题解加深印象。

题意题目已经讲得很清楚了，对于 $B$ 数组就是允许任意排列的意思。

根据题意，我们要处理的数组是 $A$ 数组，保证 $A$ 中的数字互不相等，而且只能对元素进行 $+1$ 操作。

于是判断当前位置的 $A_i$ 珂以转化为的最小的数是多少。

我们从大到小排序 $A$ 数组（具体原因后面代码里讲解）,然后我们珂以处理出当前选择的数改变后的最小的数。

珂以通过递归实现：
```cpp
set<int> st;
int find(int x){
	set<int>::iterator it=st.lower_bound(x);
	if(x==*it)return find(x+1);
	else {st.insert(x);return x;}
}
```
观察朴素的递归发现，时间复杂度为 $O(n \log n)$，加上 $n$ 次循环复杂度无法承受。

于是我们考虑优化：

递归函数的实现珂以考虑记忆化，而且处理结果对于相同的数单调递增。

于是我们写出了查找代码：

```cpp
int find(int x){return f[x]=(f[x]==0?x+1:find(f[x]));}
```

空间不够用 map 优化一下。

从大到小排序的原因：只能进行 $+1$ 运算，所以数字只可能变大，从大到小处理珂以避免改变过多的数字导致答案过大。

我们那样例 $2$ 举例：

```cpp
3 3 4
```
正序是这样的：
```cpp
f[a[i]]: 4,5,6
```
因为 $f$ 数组在递归时会多计算一次，所以作差时要额外减去 $1$ 。

最后得出的差是：$0,1,1$ , 通过计算最终得出错误的答案 $3$ 。

而从大到小排序则得出的差是 $2,0,0$ , 从大到小贪心的正确性也被证明。

最后把得到的差排序，然后数量多的和 $b_i$ 小的乘积，累加得到正确答案。

或者写成数学表达式

$\sum_{i=1}^n derta_i\times b_i $

完结撒花

管理员同志审核题解辛苦了

