**前言：我们在做题的时候就是把一道新的问题归约成已知的模型（其实OI考察的就是泛化模型的能力），“学”的时候你就好好学，只管见模型，就算是看了代码也不可耻，重点是，“学”完之后“习”的方式，或许“习”指的并不是温习，而是应用模型的能力。**

我写这么一大段话的原因是什么呢？

此题不就是[最短哈密顿路径](https://www.acwing.com/problem/content/93/)的变式嘛？怎么就紫了？？？

[【此题是最长哈密顿问题】AT2673 Tree and Hamilton Path](https://www.luogu.org/problem/AT2673)

---
接下来讲一下如何把此题归约成最短哈密顿路径的模型

---
先瞄一眼数据范围
$1\le m\le n\le 18$

为什么这么小呢？考虑暴力做法，极端情况m==18，全排列枚举路径,再遍历这条路径计算长度，时间复杂度：

$O(18! \times 18)$

有什么方法能把指数型的时间复杂度优化到多项式呢？

您的模型告诉你：状压DP

---
每道菜只有吃和不吃两种状态,我们找到了一个**对立态**，可以用01表示，哟，状压妥儿了。

在吃完一道菜x之后紧接着吃另一道菜y会有加成$w_{x,y}$，我们可以把这个条件看做x到y的一条边权为 $w_{x,y}$的有向边。因为n很小，我们可以直接使用邻接矩阵存储

**状态定义**：

我们把菜吃了记为1 ，没吃记为0，那么我们可以用一个01串i来描述这些菜的情况，也就是一个**局面**

`f[i][j]`表示吃了第j道菜后形成i局面下的最大满意度，和最短哈密顿路径一模一样，这题只是加了一个初始权值而已

**转移方程**：

$f[i][j]=max(f[i][j],f[i\ xor\ (1<<j-1)][k]+a[j]+w[k][j])$

其中j表示当前的菜，k枚举的是上一道菜

**初始化**：

`f[1<<(i-1)][i]=a[i];`

**终态**：
很显然，如果没有只选m个菜的限制的话，这就是个最短哈密顿路径的裸模板，那我们遍历一下所有状态，只选1的个数是m的状态来记录答案，由于所有点都可以作为结束节点，遍历一下就好了。

```
#define int long long//可耻的定义全局long long，并省掉了头文件和宏定义

const int N=18,M=1<<N;
int a[N+5],w[N+5][N+5];
int n,m,k;
int f[M+5][N+5];

inline int get_num(int x){
	int res=0;
	while(x){
		x&=(x-1);
		res++;
	}
	return res;
}

#undef int
int main(){
#define int long long
	rd(n),rd(m),rd(k);
	rep(i,1,n){
		rd(a[i]);
		f[1<<(i-1)][i]=a[i];
	} 
	rep(i,1,k){
		int u,v,z;rd(u),rd(v),rd(z);
		w[u][v]=z;
	}
	for(int i=0;i<1<<n;++i)	
		rep(j,1,n)
			if(i>>(j-1)&1)
				rep(k,1,n)
					if((i^(1<<(j-1)))>>(k-1)&1)
						f[i][j]=max(f[i][j],f[i^(1<<(j-1))][k]+a[j]+w[k][j]);
	int ans=0;
	for(int i=0;i<1<<n;++i){
		if(get_num(i)==m)//判断是否选了m个
			rep(j,1,n)
				ans=max(ans,f[i][j]);
	}
	printf("%lld\n",ans);
	return 0;
}
```

**后记：我为什么写这篇题解呢，不是因为我闲的痛，而是……马上要考状压了……我还没学会k进制状压，打算巩固一下二进制状压模型……而不是去“学”一下k进制状压模型，hh点题了。**