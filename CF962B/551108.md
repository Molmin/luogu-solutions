### 题目大意

有一个长度为 $n$ 的只含 `*.` 的字符串，你可以把其中的 `.` 换成 `A` 或 `B`，要求 `A` 不超过 $a$ 个， `B` 不超过 $b$ 个，且连续两个字符不能同时是 `A` 或者 `B`，求最多有多少个 `.` 被替换掉。

### 题目分析

我们可以以 `*` 为断点，将字符串分为很多个连续的 `.`，根据连续 `.` 的数量，我们可以分成如下两类：

1. `*.*`、`*...*`，单数个 `.`：我们可以把 `.` 染成任意形如 `ABA` 或 `BAB` 的形式，`A` 的个数和 `B` 的个数永远差 $1$，由于 `A,B` 的个数都是有限制的，为了使尽可能多的 `.` 被替换掉，我们可以优先染成剩余个数多的字母。

2. `*..*`、`*....*`，偶数个 `.`：我们可以染成 `ABAB` 或 `BABA` 两种形式，`A` 和 `B` 的个数是一样的，所以如何染色并无本质上的差别。

但是有可能在替换某个连续 `.` 段时替换到一半 `A` 或 `B` 的个数就用完了，所以我们在替换每个 `.` 段时都从剩余个数多的字母开始替换，然后交替替换，当某个字母用完后就用另一个字母间隔替换。

总的时间效率是 $O(n)$ 的。
### code
```cpp
#include <iostream>
#include <cstdio>
using namespace std;
int n, a, b, ans;
string s;
int main()
{
	scanf("%d %d %d", &n, &a, &b);
	cin >> s;
	if(s[0] == '.')
	{
		if(a > b)
			a--, s[0] = 'A', ans++;
		else if(b)
			b--, s[0] = 'B', ans++;
	}
	for(int i = 0;i < n;i++)
	{
		if(s[i] != '.')
			continue;
		if(s[i-1] == '*' || s[i-1] == '.')
		{
			if(a > b)
				a--, s[i] = 'A', ans++;
			else if(b)
				b--, s[i] = 'B', ans++;
		}
		else
		{
			if(b && s[i-1] == 'A')
				b--, s[i] = 'B', ans++;
			if(a && s[i-1] == 'B')
				a--, s[i] = 'A', ans++;
		}
	}
	printf("%d", ans);
	return 0;
}
```