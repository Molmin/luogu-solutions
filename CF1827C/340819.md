## [CF1827C](https://www.luogu.com.cn/problem/CF1827C)   
不是很难，比这场的 B 好多了。    

考虑对于一个美丽的字符串，它一定有一个唯一的最小偶回文拆分，接下来证明。   

因为对于一个偶回文串，如果其存在一个偶回文串后缀，则其必定可以再次拆分。假设大回文串长度为 $2x$，回文后缀长为 $k$，如果 $k\leq x$，则 $[2x-k+1,2x]$ 与 $[1,k]$ 与 $[k+1,2x-k]$，均为偶回文串，就完成了一次分解。如果长度过半，可以用对称性对称过去解决。    

所以说，如果存在多个最小偶回文拆分（这里最小的定义为段数最多），那么一定存在其中一个的拆分属于另一边某一个字符串的后缀，就不是最小偶回文拆分了（语文不好将就着看吧）。     

于是我们考虑 $dp$。首先预处理出每个点的最长回文半径，因为不会马拉车，所以写了 $\Theta(n\log n)$ 的二分字符串哈希。令 $g_i$ 表示以 $i$ 为结尾的最短偶回文串长度，$f_i$ 表示以 $i$ 结尾的美丽串个数，则有如下转移：  

如果 $g_i=0$，$f_i=0$。   
否则 $f_i=f_{i-g_i}+1$。   

对于 $g_i$ 可以使用线段树来维护，复杂度带一个 $\log$，实现的不好可能会 [TLE](https://codeforc.es/contest/1827/submission/205985055)，于是就写完了，复杂度 $\Theta(n\log n)$。  

[代码](https://codeforc.es/contest/1827/submission/205987760)