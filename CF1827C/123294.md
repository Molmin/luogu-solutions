### [CF1827C Palindrome Partition](https://www.luogu.com.cn/problem/CF1827C)

对于一个偶回文串，若它有一个偶回文串后缀，那它一定可以划分为若干更短的偶回文串。根据回文串的性质手动模拟一下即可。

因此，对于每个好串，将其划分为极小偶回文串的方式是唯一的：找到最短偶回文串后缀，然后删去。这给予我们如下 DP 思路：

设 $f_i$ 表示以 $i$ 结尾的最短偶回文串长度，$g_i$ 表示以 $i$ 结尾的好串数量。若 $f_i$ 不存在，则 $g_i = 0$。否则 $g_i = 1 + g_{i - f_i}$。

借助 Manacher 求出以每个间隔为回文中心的最大回文半径（以间隔为回文中心保证了回文串长度为偶数），按位置从小到大考虑每个间隔，就是对 $f$ 做区间赋值。倒过来考虑到间隔 $i - 1\sim i$ 时，相当于：将一段左端点为 $i$ 的区间内所有还未被删去的位置的 $f$ 值赋为某个关于 $i, j$ 的值，并将这些位置删去。用双向链表维护即可做到 $\mathcal{O}(n)$。

[代码](https://codeforces.com/contest/1827/submission/205930853)。