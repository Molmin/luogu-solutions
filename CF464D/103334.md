
### 这道题我们考虑概率DP

### 设dp[i][j]表示打赢只要求出了前i只怪兽后某种装备被替换后价值为j的期望。

### 为什么是某装备？

### 因为所有装备的期望值是相同的，所以我们只要求出一种装备的期望，再乘上k即可。

### 有两种情况：

## 1.爆出了等级为j+1的神装。（概率为$1/(j+1)$）

### dp[i][j]+=(dp[i-1][j-1]+j)/j+1。

## 2.只得到等级<=j的装备。（概率为$j/(j+1)$）

### dp[i][[j]+=(dp[i-1][j]+(j+1)/2)*j/(j+1);//因为1至j是等概率出现的，所以取平均（j+1）/2。

### 但是这样你打出来你会发现自己MLE或TLE了，为什么？

## i过于大，j也过于大。

### 优化：1.dp[i][j]的更新只需要他前一个的情况，所以我们可以考虑用滚动数组记录。

### 2.因为这个状态的转移是会收敛的，所以j越大他所产生的变化就越小，最终小到可以忽略不计，所以j只用取到很小就可以当作答案用了（有很多神仙j取600就过了，不过保险起见最好取1000）。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,k,s=1;
double dp[2][1010];
int main()
{
	scanf("%d%d",&n,&k);
	for(int i=1;i<=n;i++,s^=1)
	{
		for(int j=min(n,1000);j;j--)
		{
			dp[s][j]=((dp[s^1][j+1]+j)/(j+1.0)+(dp[s^1][j]+(j+1)/2.0)*j/(j+1.0))/double(k)+dp[s^1][j]*(k-1.0)/double(k);
		}
	}
	printf("%.11lf\n",dp[s^1][1]*k);
	return 0;
}
```