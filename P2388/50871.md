我的想法是这样的，假设$ n=5,6,7,8,9 $，那么后面的$ 0 $的个数只会递增$ 1 $，若$ n=10,11,12,13,14 $，则后面的$ 0 $将递增$ 2 $。那么根据这样的原理，我设一个数组$ x[1...y] $，存放$ 5 $的倍数的数，保证数组中的所有数据都小于$ n $，然后设$ i=5,10,15...(n-k) $，其中$ n-k $为$ 5 $的倍数，再将其与数组中的数据取余，看其能够取余到数组中的第几个数据，于是设$ q $为增长量，初始为$ 0 $，增长量在$ i-5,i-4,i-3,i-2,i-1 $中是一样的，所以我们只要隔五个考虑即可。对了，这里考虑的不是$ i $及其后面四个连续的数，而是$ i $的前面五个连续的数，例如$ i=5 $时，考虑的是$ 0,1,2,3,4 $，此时增长量为$ 0 $，故总和为$ 0 $。当$ i $超过了$ n $，循环还会将其增加五，考虑到$ n $不一定为五的倍数，因此将$ i $减五，然后再自增到$ n $。而此时$ q $恰为其增长量，于是只要一个一个加上去就行了（貌似乘上去就无需循环了——我想麻烦了）。这样就能求出答案了。

然而，我的程序不是很快的，但还是好懂吧，希望大家多多指教。

以下是程序主要部分：


```cpp
for(i=5;i<=n;i+=5)
    {
        for(j=1;j<maxi;j++)
        {
            if(i%x[j]!=0)
            {
                b+=q*5;//0-4,5-9,10-14...
                q+=j-1;//0  ,1  ,2    ...
                break;
            }
        }
    }
    for(i-=5;i<=n;i++)
    {
        b+=q;
    }
```