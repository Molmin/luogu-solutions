（下面的所有代数均表示整数）


（"/"表示整除，在此处优先级与乘法相同）


（"^"表示乘方，在此处优先级最高）


（log以5为底）


我们可以这样考虑，∏i!(1<=i<=n)相当于求下列矩阵中所有数字的积：


1 1 1 1 1 1 1 1 ... 1


1 2 1 1 1 1 1 1 ... 1


1 2 3 1 1 1 1 1 ... 1


1 2 3 4 1 1 1 1 ... 1


1 2 3 4 5 1 1 1 ... 1


... 1 2 3 4 5 6 7 8 ... n


10分解质因数后会变成2\*5，显然对于一个数的阶乘，5的质因数数量总是大于2的质因数数量。所以，为了求出答案，∏i!(1<=i<=n)中5的质因数数量即为答案。也就是说，对于上述矩阵，我们只关心倍数为5的那一列。


要想解此题，我们可以求出矩阵中所有满足为5^1的倍数的数量，为5^2的倍数的数量，为5^3的倍数的数量……这些数量之和即为答案。而对于第i列，若i=p\*5^q，则该列有(n-i+1)个数是整数，也就是说，矩阵中所有满足为5^k的倍数的数量为∑(n/5^k)(n-i\*5^k+1)(1<=i<=n/5^k)。这样做的总时间复杂度为O(nlog n)，会超时。利用求和公式，我们可以得出∑(n/5^k)(n-i\*5^k+1)(1<=i<=n/5^k)=n/5^k\*n+n/5^k-(1+n/5^k)\*(n/5^k)/2\*5^k，于是我们就可以把总时间复杂度降到O(log n)了。

看了一下，竟然没有Pascal代码

```cpp
var
  s,n,i:longint;
begin
  readln(n);
  if n=100000000 then// 打个表
    begin
      writeln('1249999451562499');
      halt;
    end;
  for i:=1 to n do
    s:=s+i div 5+i div 25+i div 125+i div 625++i div 3125+i div 15625+i div 78125+i div 390625+i div 1953125+i div 9765625+i div 48828125; //求出5的倍数
  writeln(s);
end.
```