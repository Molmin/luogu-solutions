## [【原题传送门】](https://www.luogu.org/problem/P2388)

这是一道标准的数论题，不需要任何算法与数据结构。但是，很重要的一点是： 
## 要开long long！（或int64）

现在~~正式~~开始分析：

题目要求末尾0的个数—>求这个大数最多可以被多少个10整除。因为10 = 2×5 ，且因子2的个数远多于因子5的个数（可自行验证），所以，只需要讨论因子5的个数即可。我的方法时间复杂度为  O(log5 n)，只需要一个一层循环。

   本题可以用归纳的思路。

1.计算 s=n! 有多少个因子5。

设k=因子5的个数。

<1> 计算1~n 之间有多少个数能被5整除。很显然，是 [ n/5 ] 个。

但是，这个值并不是因子5的个数，k仍然少了一些东西：25 = 5^2，有两个因子5，但我们却只算了一次。

<2> 于是，k还得加上 [ n/25 ]。

<3> 同理，k还得加上[ n/125 ]，以此类推。

当5^m刚刚大于n时，就不需要计算了。代码如下：
```cpp
int main(){
    long long n;
    cin>>n;
    long long cnt=0;
    while(n>0){
        n/=5;// [n/25]=[[n/5]/5]
        cnt+=n;
    }
    cout<<cnt;
    return 0;
}
```
2.计算 s=1!×2!×3!……×n! 有几个因子5。

还是按刚才的思路。

<1> 1!~n!有多少个数能被5整除 ？
有[ 1/5 ]+[ 2/5 ]+……+[ n/5 ]个。

原式=[ 1/5 ]+[ 2/5 ]+……+[(s-1)/5 ](s为最接近n且小于n的5的倍数）+ [ s/5 ]+……+[ n/5 ]

=5×(1+2+3+……+([ n/5 ]-1))+(n%5+1)×[n/5]

=5×[ n/5 ]×([ n/5 ]-1)/2+(n%5+1)×[n/5]


<2> 1!~n!有多少个数能被25整除 ？
有[ 1/25 ]+[ 2/25 ]+……+[ n/25 ]个。

同理，此式=25 [ n/25 ] ([ n/25 ]-1)/2+(n%25+1)  [ n/25 ]

以此类推。

完整代码：
```cpp
#include<iostream>
using namespace std;
int main(){
	long long n;
	cin>>n;
	long long cnt=0;
	long long cur=1;
	int m=n;
	while(n>0){
		cur*=5;//cur为当前5的幂
		long long k=m%cur;
		n/=5;
		cnt+=cur*n*(n-1)/2;
		cnt+=n*(k+1);
	}
	cout<<cnt;
}
```
这是本蒟蒻第一篇题解，求通过~