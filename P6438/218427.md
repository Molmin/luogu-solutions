## 思路：
这道题目可以用搜索做，如果遇到一个点是$*$或者$.$说明这个点在窗户以内，然后用搜索来计算有几个$*$，这样可以知道这个窗户的状态。
## 代码：
```cpp
#include <bits/stdc++.h>//头文件
using namespace std;
char w[1001][1001];//输入的窗户
int ans[6],t=0,n,m;//ans记录答案
int fx[4]={0,0,1,-1};//四个横坐标的方向，可以减少代码长度
int fy[4]={1,-1,0,0};//四个列坐标的方向，可以减少代码长度
void dfs(int x,int y)//定义这个搜索
{
	if(w[x][y]=='*')//判断这个格子是否是*
	{
		t++;//如果是个数加一
	}
	w[x][y]='#';//把这个格子置为#，因为搜过了就没用了
	for(int i=0;i<=3;i++)//枚举四种方向
	{
		int nx=fx[i]+x,ny=fy[i]+y;//记录经过方向后到达的位置
		if(nx>=1&&nx<=n&&ny>=1&&ny<=m&&w[nx][ny]!='#')//判断它是否到达图外面或者不是窗户
		{
			dfs(nx,ny);//继续搜索
		}
	}
}
int main()
{
	cin>>n>>m; //输入有多少行和多少列
	n=n*5+1;//先算出有多少行，因为有5n+1行，所以先算出来后面就不用计算了
	m=m*5+1;//先算出有多少列，因为有5m+1行，所以先算出来后面就不用计算了
	for(int i=1;i<=n;i++)//循环输入
	{
		for(int j=1;j<=m;j++)//循环输入
		{
			cin>>w[i][j];//输入这个格子的状态
		}
	}
	for(int i=1;i<=n;i++)//循环判断
	{
		for(int j=1;j<=m;j++)//循环判断
		{
			if(w[i][j]=='*'||w[i][j]=='.')//如果这个格子是这两种状态的话，说明是窗户
			{
				t=0;//先把它置零
				dfs(i,j);//对这个格子进行搜索
				ans[t/4]++;//这个窗户*的个数除以4就是窗户的状态
			}
		}
	}
	for(int i=0;i<=4;i++)//循环输出
	{
		cout<<ans[i]<<' ';//输出答案
	}
	return 0;//别忘了
}
```
