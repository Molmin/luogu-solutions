这题如果不用字符串去做的话，可以使用$char*$，并用$strcmp$比较。本题中用了有关$strcmp$和引用、指针的用法。

在很多$void$函数的参数中都有引用的地址。例如：

```cpp
void swap(int &a,int &b)//参数都引用原变量
{
    int t=b;
    b=a;
    a=t;
}
```

上述函数中，如果不引用原变量就会是：

```cpp
void swap(int a,int b)//正常参数
{
    int t=b;
    b=a;
    a=t;
}
```

不引用原变量的函数无任何实际效果，只不过是在函数内部进行操作。因此，只有引用原变量，才能直接影响到主函数中使用该参数的变量。因此相似地我们可以编写下列函数：

```cpp
inline void f(char &c)
{
    if(c>='A'&&c<='Z')c-='A'-'a';
}
```

这个函数的参数是$\&c$，函数的意图也很简单，即把大写转换为小写。而虽然我们可以用$char$函数加一个判断取而代之，但是用$void+$引用就只需要一行代码就能完成，方便、简洁、快速。

关于$strcmp$的用法：

$strcmp$函数包含在$cstring$库中，因此要调用该头文件。假设我们有两个字符数组$a[20],b[50]$，而它们是这样的：

|$0$|$1$|$2$|$3$|$4$|$5$|$6$|...|$19$|$20$|...|$49$|$50$|$...$
|-:|-:|-:|-:|-:|-:|-:|-:|-:|-:|-:|-:|-:|-:|-:|
|$a$|$N$|$O$|$I$|$P$|$!$|\\$0$|||$-$|$-$|$-$|$-$|$-$|
|$b$|$N$|$O$|$I$|$P$|$!$|\\$0$||||||$-$|$-$|

上述表格中的\\$0$字符表示空字符，虽然无含义，但包含在字符数组中。表格中的$-$表示超出数组范围。而如果比较$a==b$，则永远返回假，因为$a,b$的数组元素总数不同。这时就需要$strcmp$的帮助。$strcmp$对于相同内容的两个字符数组返回$0$，不同返回$1$。

例如：$strcmp(a,b)$返回$0$（$a,b$均为"$NOIP!$"，但数组元素一个为$20$，一个为$50$，与上述相同。

如果我们新建$string$ $a,b$，赋值与上述相同的话，$a==b$就会返回真，即满足$a==b$。然而在字符数组中需要多加注意。

~~啰嗦了许久，你们等急了的~~$AC$代码~~来了~~：

```cpp
#include<cstdio>
#include<cstring>
char a[101],b[101];
int i,s[2]={-1,1};
inline void f(char &c)//inline节约时间，char类型变量c必须必须必须加取引用符号，否则该函数没有任何效果，满盘皆输！
{
    if(c>='A'&&c<='Z')c-='A'-'a';//统一转换为小写
}
int main()
{
    scanf("%s%s",a,b);
    for(;a[i];i++)
    {
        f(a[i]);
        f(b[i]);//a，b长度相等，所以一起转换为小写
    }
    if(!strcmp(a,b))printf("0");//用strcmp判断，相同为0，不同为1。
    else
    {
        for(i=0;a[i];i++)
        {
            if(a[i]!=b[i])
            {
                printf("%d",s[a[i]>b[i]]);//只要有不同就直接返回，如果a比b大就返回1，否则返回-1。s数组的目的是为了方便输出
                return 0;//直接退出程序
            }
        }
    }
}
```
