这道题主要考察的是埃拉托色尼筛法，相对于暴力的判断素数，这种方法会快一点，码量也较少。

由于素数是不能被除了它本身与1的数整除的，所以只要这个数是素数，它的倍数就是合数。这题与埃拉托色尼筛法唯一的区别便是要将扫到的素数也划掉。

**思路：**
- 设一个专门用来判断素数的数组p，所有元素的初始状态是0（素数），再设一个记录被划掉的数的数组t。
- 从2开始将n以内的数扫一遍，如果这个数是素数（是0），则在循环中把它的合数和它本身划掉。
- 最后输出t数组下标为k的元素即可。

这里还有一个坑，帮大家指出一下：如果这个数已经被划掉了，所以无需再划了。为了避免重复计算，需要在划数的那个循环中加个特判：
```
if(p[j]==1) continue;
```

**代码:**
```cpp
#include<bits/stdc++.h>
using namespace std;
int p[2000]; //是否是素数，一开始全部设为0. 
int main(){
	int n,k;
	cin>>n>>k;
	int t[2000]; //被划掉的数。 
	int s=1;  
	for(int i=2;i<=n;i++){
		if(p[i]==0){ //如果这个数是素数。 
			for(int j=i;j<=n;j+=i){ //由于这个素数本身也要划掉，所以从i开始。 
				if(p[j]==1) continue; //为了避免重复计算，需要特判。 
				p[j]=1; //这个数是合数。 
				t[s++]=j;
			}
		}
	}
	cout<<t[k];
	return 0;
}
```
