# 前言

- 给过吧QWQ，至今没过过题解

# 思路

- 由于 B 的作用似乎更大一些，所以我们可以考虑节约用 B 。

- 我们注意到，若 B 与 A 匹配，则一个 B 便可以对答案作出 -2 的贡献，而 B 与 B 匹配则需要两个 B 。

- 这就意味着，我们要尽可能多地将 B 与 A 匹配。

- 那么怎么匹配呢？

- 显然， B 只能与其前面的 A 匹配，所以便有了以下几点：

  - 当某一位是 B 时，如果还有 A 未被匹配，则将 B 与该 A 匹配，如果没有，则在后面的位置也不可能再有 A 与 B 匹配（因为顺序一定），可以将其扔入“废品堆”（即无法继续与 A 匹配的 B）。
  
  - 当某一位是 A 时，将 A 的数量加一，方便后面的 B 匹配。

- 注意到我们只是简单粗暴地统计 A 的个数，那么，怎么保证 B 一定能匹配到前面的 A 呢？  

- 这并不难，由于原序列只有 A 和 B 两种字符，那么在原序列中，当前的 B 与想与其匹配的 A 中间只会有 A 与 B 两种字符。

- 而它们中间能够匹配的 A 与 B 都已经两两匹配，如果中间剩余了一个 B ，那么该 A 一定会优先与剩余的 B 匹配而不是当前的 B，反之，如果中间剩余了若干个 A，那么当前的 B 一定会优先与最靠后的 A 匹配。

- 综上所述，当找到一个 B 并且还有 A 没有匹配时，该 B 一定能够成功匹配。

- 统计完了以后，对于没有匹配 A 需要直接计入答案，而剩余的 B 则可以两两匹配，剩余的 B 与其奇偶性一致。

- 根据以上思路，我们可以写出以下代码。

# 代码

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<string>
#include<cstring>
using namespace std;
int AA,BB,T;string s;
int main(){
	scanf("%d",&T);
	while(T--){
		AA=0,BB=0;
		cin>>s;int le=s.length();
		for(register int i=0;i<le;++i)
			BB+=((AA==0)&&(s[i]=='B')),
			AA+=((s[i]=='B')?((AA==0)?0:-1):1);
		printf("%d\n",AA+(BB&1));
	} 
	return 0;
}
```

# 后语

- 这是一道不错的贪心题，值得研究。

- 另外，给蒟蒻过了吧QWQ