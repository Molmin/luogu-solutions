## 思路

$L$ 代表从右边走过来，走向左；$R$ 代表从左边走过来，走向右。

我们不妨分析一下。

首先，所有的 $L$ 和 $R$ 必须全部挨在一起，不然的话，就一定会存在一段，使得这一段呈：

$1$、```LRL``` 状：$L$ 在两边 $R$ 在中间，此时两个 $L$ 不能同时走到，不成立；

$2$、```RLR``` 状：$R$ 在两边 $L$ 在中间，同理，两个 $R$ 也不能同时走到，不成立。

综上，$L$ 与 $R$ 必须同类挨在一起，呈 ```LR``` 或 ```RL``` 状。

然而，```LR``` 其实是不成立的。

分析一下，在左端有 $L$，右段有 $R$，意为你需要从右边走到最左边同时从左边走到最右边，此时只能满足一个，而另一个会被覆盖不同的脚印，绝对不可能是 ```LR``` 状。

所以，我们总结一下，符合规律的有以下几种：

$1$、全是 $L$，例：```LLLLLL```。此时答案为从最右边走到最左边。

$2$、全是 $R$，例：```RRRRR```。此时答案为从最左边走向最右边。

$3$、左边 $R$、右边 $L$，例如：```RRRRLLL```。此时答案为从 $R$ 第一个到 $R$ 最后一个，或者从 $L$ 最后一个到 $L$ 第一个。我们注意到一句话：```The first test sample is the one in the picture.```，所以两种都可以，我们就用第一种：从 $R$ 第一个走到 $R$ 最后一个就行了。

## AC Code

已经论证了情况数，实现就非常简单。

具体的代码实现，看注释。

```cpp
#include<btis/stdc++.h>
using namespace std;

int main()
{
    string s; // 原雪地脚印
    int Rfst, Rlst, Lfst, Llst, n; 
    // R 的第一个、R 的最后一个；L 的第一个、L的最后一个；s 长度
    cin >> s;
    n = s.size(); // 存长度于 n
    s = " " + 1; // 从 1 开始
    for (int i = 1; i <= n; i++)
        if (s[i] == 'R')
        {
            Rlst = i; // 因为正序最后一个 R 肯定是最后一个，座椅直接覆盖
            if (Rfst == 0) Rfst = i; // 只有前面没有 R 才是第一个
        }
        else if (s[i] == 'L')
        {
            Llst = i; // 与 R同理 
            if (Lfst == 0) Lfst = i; // 与 R 同理
        }
    // 1、没有 L，只有 R，即 L 连第一个都没有
    if (Lfst == 0) cout << Rfst << " " << Rlst << endl;
    // 2、没有 R，只有 L，即 R 连第一个都没有
    else if (Rfst == 0) cout << Llst << " " << Lfst << endl;
    // 3、RRRRLLLL
    else cout << Rfst << " " << Rlst << endl;
    return 0;
}
```

思维题，只要想通了就非常简单了，预处理和简单判断就过了。