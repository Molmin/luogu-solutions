观察题意，不难发现是个 $\rm dp$。

我们一列一列地处理，这样每一列上小熊就不能走“回头路”。

设 $dp_{i,j}$ 表示走到格子 $(i,j)$ 时的最优解。

- $dp_{i,j,0}$ 表示上一步方向向右
- $dp_{i,j,1}$ 表示上一步方向向下
- $dp_{i,j,2}$ 表示上一步方向向上

自然写出方程：

$$dp_{i,j,0}=a_{i,j}+\max(dp_{i,j-1,0},dp_{i,j-1,1},dp_{i,j-1,2})$$

注意上一步方向对该步方向的影响，即上一步如果向上，这一步不能向下，反之亦然。

所以有极为类似的两个方程：

$$dp_{i,j,1}=a_{i,j}+\max(dp_{i,j-1,0},dp_{i,j-1,1})$$

$$dp_{i,j,2}=a_{i,j}+\max(dp_{i,j-1,0},dp_{i,j-1,2})$$

---

下面梳理一下循环结构：

如上文所说，第一重循环应当循环每一列，按行处理会导致“回头路”的出现。

第二重循环，就是按行号从上到下扫一遍，再从下到上扫一遍，每扫一次“无脑”地跑一下上面三个方程就行。

---

代码部分：

```cpp
inline void relax(int i,int j){//更新 (i,j) 位置的答案
	if(j>1){
		if(dp[i][j-1][0]!=-inf)dp[i][j][0]=mx(dp[i][j][0],dp[i][j-1][0]+a[i][j]);
		if(dp[i][j-1][1]!=-inf)dp[i][j][0]=mx(dp[i][j][0],dp[i][j-1][1]+a[i][j]);
		if(dp[i][j-1][2]!=-inf)dp[i][j][0]=mx(dp[i][j][0],dp[i][j-1][2]+a[i][j]);
	}
	if(i>1){
		if(dp[i-1][j][0]!=-inf)dp[i][j][1]=mx(dp[i][j][1],dp[i-1][j][0]+a[i][j]);
		if(dp[i-1][j][1]!=-inf)dp[i][j][1]=mx(dp[i][j][1],dp[i-1][j][1]+a[i][j]);
	}
	if(i<n){
		if(dp[i+1][j][0]!=-inf)dp[i][j][2]=mx(dp[i][j][2],dp[i+1][j][0]+a[i][j]);
		if(dp[i+1][j][2]!=-inf)dp[i][j][2]=mx(dp[i][j][2],dp[i+1][j][2]+a[i][j]);
	}
}
```

其他的不展示了，边界位置注意判断好就好了。

---

$\rm\small\texttt{UPD~2020.11.11：自己发现打错了字。}$