upd  2021.7.10： 对部分文字上的错误进行修改


------------
  

由于有三个方向，所以在普通二维dp上再加一个**方向**维度，用三维数组进行dp。

+ $f[i][j][$→$]$（$f[i][j][0]$） 表示从当前格子的左边走到当前格子能取到的最大整数之和。
+ $f[i][j][$↓$]$ （$f[i][j][1]$） 表示当前格子的上边走到当前格子能取到的最大整数之和。
+ $f[i][j][$↑$]$ （$f[i][j][2]$） 表示当前格子的下边走到当前格子能取到的最大整数之和。  

### 思路
先进行第 $1$ 列的填值。  
因为其处在整个地图的最左侧，所以只有 ↓ 方向是可以取到格子里的数的（如果向上走，最后必将无路可走）。  
```f[i][1][1] = f[i-1][1][1] + a[i][1]```  
然后再进行第 $2$ ~ $m$ 列的填值。  
先填 → 方向及 ↓ 方向的值，再从下往上填 ↑ 方向的值。  
```
f[i][j][0] = max(f[i][j-1][0],f[i][j-1][1],f[i][j-1][2]) + a[i][j]
f[i][j][1] = max(f[i-1][j][0],f[i-1][j][1]) + a[i][j]
f[i][j][2] = max(f[i+1][j][0],f[i+1][j][2]) + a[i][j]
```  
最后输出：
```
max(f[n][m][0],f[n][m][1],f[n][m][2])
```
## $Code$
```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define inf -1e17
ll f[1005][1005][3];
ll a[1005][1005];
int n,m;
ll maxx(ll a,ll b)
{
    return a>b ?a :b;
}
int main()
{
    cin>>n>>m;
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=m;j++)
        {
            cin>>a[i][j];
            f[i][j][0] = inf;
            f[i][j][1] = inf;
            f[i][j][2] = inf;

        }
    }
    f[1][1][0]=a[1][1];
    f[1][1][1]=a[1][1];
    f[1][1][2]=a[1][1];
    for(int i=2;i<=n;i++)
    {
        f[i][1][1] = f[i-1][1][1] + a[i][1];
    }
    for(int j=2;j<=m;j++)
    {
        for(int i=1;i<=n;i++)
        {
            f[i][j][0]=maxx(f[i][j-1][1],maxx(f[i][j-1][0],f[i][j-1][2]))+a[i][j];
            if(i>=2) f[i][j][1]=maxx(f[i-1][j][0],f[i-1][j][1])+a[i][j];  //↓方向
        }
        for(int i=n-1;i>=1;i--)  //↑方向
        {
            f[i][j][2]=maxx(f[i+1][j][0],f[i+1][j][2])+a[i][j];
        }
    }
    cout<<maxx(f[n][m][0],maxx(f[n][m][1],f[n][m][2]));
    return 0;
}
```
