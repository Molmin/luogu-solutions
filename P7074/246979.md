这篇题解重点剖析动态规划的设计。

我们知道，动态规划对状态空间的遍历构成一张有向无环图，遍历顺序就是该有向无环图的一个拓扑序。有向无环图中的节点对应问题中的状态，图中的边对应状态之间的转移，转移的选取就是动态规划中的决策，最优决策就是最终的选取方案。

分析题目可以发现：此题中，同一列之间可上可下，但是不同列之间只能够从左向右。因此考虑将每一列作为一个阶段；边界条件为第一列。这一列只能向下，求前缀和即可。

其次，我们发现此题的上下两个方向非常难受。因此考虑将惯常的 

$$
f_{i,j}=\max\{f_{i,j-1},f_{i-1,j}\}+a_{i,j}
$$ 

增加一个维度，表示方向。这里暂且认为$0$为向右，$1$为向下，$2$为向上。

对于每个阶段，我们可以先从上到下转移每一个点的向右和向下。然后再从下到上转移之前没考虑到的向上方向即可。注意向上转移的时候，没有 $f_{i+1,j,1}$ 这个决策，否则会出现一个格子走两次的情况。

#### 总结一下：

- **阶段划分**：每一列
- **状态表示**：$f_{i,j,k}$表示到$i$行$j$列为止，从方向$k$过来的最大数值之和。
- **边界**：第一列，直接求$f_{i,1,1}$的前缀和。
- **目标状态**：$\max\limits_{0\leq k<3}\{f_{n,m,k}\}$

```cpp
//边界
for(long long i=0;i<3;i++)f[1][1][i]=a[1][1];
for(long long i=2;i<=n;i++)
	f[i][1][1]=f[i-1][1][1]+a[i][1];
//枚举阶段：每一列
for(long long j=2;j<=m;j++){
	//枚举状态
	for(long long i=1;i<=n;i++){
		f[i][j][0]=max(f[i][j-1][0],max(f[i][j-1][1],f[i][j-1][2]))+a[i][j];
		if(i>1)f[i][j][1]=max(f[i-1][j][0],f[i-1][j][1])+a[i][j];
	}
    //从下往上
	for(long long i=n-1;i>0;i--)
		f[i][j][2]=max(f[i+1][j][0],f[i+1][j][2])+a[i][j];
}
//目标状态
cout<<max(f[n][m][0],max(f[n][m][1],f[n][m][2]));
```