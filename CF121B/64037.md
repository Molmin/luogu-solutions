# 这题有点水

这道题的大致意思就是找一个x最小的d[x]==4，d[x+1]==7,然后如果x为奇数,则令d[x+1]=4,反之则令d[x]=7。

显然，暴力的每次去找这个x在1e9这么大的数据下肯定会爆。

## 那怎么办呢？

在每次更改完成后，会发现需要重新判断的只有d[x-1]，所以我们可以不用每次都找出x，而可以顺序的查找一遍，每次更改完后退一格重新判断即可。

考虑到有开头序号为奇数的477，此题会让它在477与447中不断转换，则只需考虑剩下转换的情况即可。

那么贴上代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,k;
char m[1000001];
int main(){
    scanf("%d",&n);
    scanf("%d%s",&k,m);
    for(int i=0;i<n&&k;i++)
    {
        if(m[i]=='4'&&m[i+1]=='7'&&m[i+2]=='7'&&!(i&1))	k=k%2;//找477
        if(k&&m[i]=='4'&&m[i+1]=='7'){
            if(i&1) m[i]=m[i+1];
            else m[i+1]=m[i];
            i-=2;
            k--;//剩下的就普通操作
        }
    }	
    printf("%s",m);
    return 0;
}
    

```