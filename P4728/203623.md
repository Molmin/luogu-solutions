一个随机化乱搞做法

其实我觉得随机化挺有意义的，毕竟思维难度低。在省选上有限的时间推这题的 dp 不如写个随机化。

有一个非常好想的思路：

对 $a$ 扫一次，维护两个队列 $x,y$。一开始两个队列都为空，当扫到 $a_i$ 如果大于其中一个队列的末尾就说明可以加入这个队列。如果都不行则说明无解。

但是这样有个问题，就是当两个都可以时你不知道加哪一个。

那就随机。经过若干次的实验发现，如果 $[rand(0,p)+i<rand(0,p)]$ 则加入第一个队列这个函数的效果很好，$p$ 我取 $10$。

这里我后来看了代码才发现一个实现细节：最后没有判断队列长度是否为 $\dfrac n 2$。直接如果可以扫完就输出 `Yes!`。

这个东西看起来毫无正确性。。但它还是过了，事实上我也不是很清楚它为什么能过。

跑 30 次就没有大问题了。

```cpp
s=prea=preb=0;
for(j=1;j<=n;j++)
{
	if(a[j]>a[prea]&&a[j]>a[preb])
	{
		if(s+rand()%10<j-s-1+rand()%10)
			prea=j,s++;
		else
			preb=j;
	}
	else
	{
		if(a[j]>a[prea]) prea=j;
		else if(a[j]>a[preb]) preb=j;
		else break;
	}
}
```
