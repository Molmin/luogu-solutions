这题主要是状态定义。

我们可以定义$dp[i][j][k][l]$是$1$序列的末尾是$i$，$2$序列的末尾是$j$，$1$序列选了$k$个，2序列选了$l$个，明显转移是会超时的。

但是大家会发现，状态可以省略到$dp[i][j][k]$，因为如果我们知道现在$2$个序列的长度总和为$i$，$1$序列选了$k$个，则$2$序列一定是$i-k$个。

但是这样依然会超时。。。

我们能不能只枚举$2$维呢？

我们会发现上面定义的状态，$dp[i][j][k]$的存在意义仅仅是表示这样的状态成立（也就是$dp$是个$bool$类型），而实际上我们可以存更多的东西。

我们设定$dp[i][j]=k$表示做到第$i$个位置，且$i$为$1$序列末尾，$1$序列里$j$个元素，$dp[i][j]$为$2$序列的末尾的可能的最小值，也就是$k$,因为$1$序列和$2$序列无差异(名字不同而已)。

若我们做到$i$,发现$a[i]>a[i-1]$,那么第一种转移是$dp[i][j]=dp[i][j-1]$，若我们发现$dp[i][j]>dp[i-1][i-j]$（$i-j$表示i-1的时候2序列的长度，2后来和1序列交换了），我们就可以把二序列和一序列交换然后更新。

一开始dp为不合法，无穷大，只有必选的为0；

```
#include <bits/stdc++.h>
using namespace std;


int t;
int n;
int a[2006];
int dp[2005][2005];

int main()
{
    scanf("%d",&t);
    while(t--)
    {
        scanf("%d",&n);
        for(int i=1; i<=n; i++)
            scanf("%d",&a[i]);

        memset(dp,0x3f,sizeof(dp));

        dp[1][0]=a[1];
        dp[2][1]=a[1];
        dp[2][0]=a[2];
        dp[2][2]=0;
        dp[1][1]=0;

        for(int i=3; i<=n; i++)
        {
            dp[i][0]=a[i];
            for(int j=0; j<=i; j++)
            {
                if(a[i]>a[i-1]&&j-1>=0)
                    dp[i][j]=min(dp[i-1][j-1],dp[i][j]);
                if(a[i]>dp[i-1][i-j]&&i-j>=0)
                    dp[i][j]=min(a[i-1],dp[i][j]);
            }
        }
        if(dp[n][n/2]<100000000)
        {
            printf("Yes!\n");
        }
        else
            printf("No!\n");
    }
    return 0;
}

```