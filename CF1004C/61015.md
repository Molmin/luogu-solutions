解题思路：

想法一：硬生生的枚举开头和结尾，并进行一定的优化，但是呢，除非你牛得不得了，否则算法复杂度都会保持在O（N * N）。绝对会炸，我们班上已经有一个炸了。

想法二：他既然要求的只是总数，为什么要枚举每个状态呢，只要算总数就行了。就是一个O（n）的算法。

本程序操作如下：

1.定义三个数组a,b,c，数组a存储的是读入的数组，数组b存储的是到目前为止，余下数组内，每个数字出现的此数（为何是余下的数组，后文会有解释）。

2.读入不做解释，但读入时我干了两件事。第一件：在数组b内操作，不断更改现在每个数出现的次数。第二件：若此数第一次出现，则在变量s中累加，可以用```b[a[i]]==1```来判断（之所以是等于一，是因为我是先加再判断）

3.操作分三步。第一步：在b数组中将目前所指向的数字的出现次数减一；第二步：若```b[a[i]]==0```，那么说明余下的数组中已经没有此数了，```s--```（此时的s表示后面数字的总类别数）；第三步：如果```c[a[i]]==0```表示```a[i]```是第一次出现，那么在答案变量ans里加上目前的s；并把```c[a[i]]```设为一；

4.输出，这个不做解释。

5.#注意：答案一定要开long long 不然会爆，~~我已经爆过了~~。