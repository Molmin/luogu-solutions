题意：给你一序列，每个数能和它后面的数两两组成数对，求数对个数，重复的数对只记1次。

比如序列1 2 1 3。对于数字3来说没有数对，对于3旁边的1来说，有（1，3）这个数对，对于2来说，有（2，1）（2，3）两个数对，对于最左边的1来说，有（1，2）（1，1）两个数对。所以一共5个数对。

其中，（2，1）和（1，2）是不同的数对，所以记为2。而（1，3）会重复出现，只记一次。

看到这种题，第一眼会想到暴力，但是数据范围是1e5，所以O(n^2)的复杂度是会超时的。

不过这题的话，是有O（n）的做法的，在此我使用了类似**链式前向星**的方法。

其实我们是可以发现的，由于数**对不能重复，所以每个位置能和后面的数字形成多少种数对，实际上是和它后面有多少种数字是有直接关系的**。

我拿一个长一点的序列举例，比如1 2 3 4 5 1 6 7这个序列。

对于6来说，其后边有一种数字，所以是1个数对，对于最右边的1来说，其后边有两种数字，所以是2个数对，对于5就同理了，有3个数对。

然后你会发现，有两个1，数对不能重复，所以最左边的1所能形成的数对，其实就是看在两个1之间有多少不同的数字。显然有4种，（不记录（1，1），（1，1）（2，2）这种会另外处理）。

至此，大家应该可以想到了，采用我们需要统计每个数字之后，一共有多少种数字，这就需要**前缀和**。

同时，如果出现了像上面序列中出现了两个1（重复出现数字）的情况，那么我们就另**外需要数组来判断当前位置的数字，在其后面是否存在相同的数字，如果不存在，组成的数对数量就是其后面不同种类的数字数量；如果存在，组成的数对数量就是两个相同数字之间不同种类数字的数量**。这就需要**链式前向星**。

所谓链式前向星，就是用一个nex数组让我们知道当前位置的数字，在其后面第一次出现的位置是哪里，如果没出现那么就是0。同时需要一个head数组来不断保存数字最新出现的位置。

同时，我们还需要vis数组，来记录某个数字出现的次数，如果某个数字x出现了两次或者更多，那么一定可以组成（x，x）数对，这就是我前面说的另外处理。

下面就是AC代码，附有详细注释。
```
#include<bits/stdc++.h>
using namespace std;
int a[100005];//接收数字
int head[100005],nex[100005];//链式前向星
int num[100005];//前缀和，记录当前这个位置之后有多少不同种的数字
int vis[100005];//记录每个数字出现数量
inline int read()//快读
{
    int x=0,f=1;
    char c=getchar();
    while(c<'0'||c>'9')
    {
        if(c=='-')
            f=-1;
        c=getchar();
    }
    while(c>='0'&&c<='9')
    {
        x=x*10+c-'0';
        c=getchar();
    }
    return x*f;
}
int main()
{
    int n;
    int i;
    n=read();
    for(i=1;i<=n;i++)
        a[i]=read();
    for(i=n;i>=1;i--)//由于我们需要的是每个数字后面的情况，所以我们倒着跑数组
    {
        if(vis[a[i]]==0)//前缀和
            num[i]++;
        num[i]+=num[i+1];
        vis[a[i]]++;
        
        //链式前向星
        nex[i]=head[a[i]];
        head[a[i]]=i;
    }
    long long ans=0;//记录答案
    
    for(i=0;i<=100000;i++)//如果某数字x出现两次，那么一定能组成（x，x）数对
        if(vis[i]>1)ans++;
        
    for(i=n;i>=1;i--)//开始遍历
    {
        if(nex[i]==0)//如果为0，说明这个数字的后面没有出现过相同数字，直接利用前缀和。
                     //为什么要-1？因为前缀和保存的是当前位置及其后面不同种类数字的数量，如果当前位置之后是没有这个数字的，那么后面数字的种类肯定比num[i]少一。
            ans+=num[i]-1;
        else
            ans=ans+num[i]-num[nex[i]];//两相同数字之间的不同数字种类数量
    }
    printf("%lld",ans);
    return 0;
}
```