## 思路
首先，在读完题之后，可以发现这道题最关键的地方在于**判重**。一开始本来想用排列组合的思路去解，后来因为~~我不会~~所以放弃了。后来想到，如果判重的话其实就是，从前往后找第一个数，如果这个第一个数被找过了，那就直接跳过就行了。

然后就是关于优化找第二个数的复杂度，可以用一个桶，记一下找到的第一个数后面又多少个不同的数字，那么这个第一个数就能组成多少个数对，这里注意，因为是看每一个数的后面，所以直接从后往前去扫一遍 $O(n)$ 即可。因为第一个判重，所以就不需要考虑两个数相同的情况。

## 代码
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,a[100005],t[100005],b[100005],ans;
signed main()
{
	scanf("%lld",&n);
	for(int i=1;i<=n;i++) scanf("%lld",&a[i]);
	for(int i=n;i>=1;i--)//桶
	{
		t[a[i]]++;
		if(t[a[i]]==1) b[i-1]++;
		b[i]+=b[i+1];
	}
	memset(t,0,sizeof(t));//懒得再开一个数组了，之前清空接着用
	for(int i=1;i<=n;i++)
	{
		if(!t[a[i]]) ans+=b[i];//记录答案
		t[a[i]]=1;
	}
	printf("%lld",ans);
	return 0;
}
```
