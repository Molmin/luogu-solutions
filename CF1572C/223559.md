### $\text{Difficulty : 2700}$
---
### 解题思路：

完全不能理解如何直接想到正解，那就一步一步来吧。

在进行具体做题之前，将所有相同颜色段缩成一个会有利于想题，直接代码中实不实现就随意了。

首先是一个一眼就能看出来的朴素 $\text{DP}$，$f_{i,j,k}$ 表示把 $[i,j]$ 染色成 $k$ 的最小代价，转移就是枚举一个中间点和两边的颜色算个染色贡献。复杂度是多少方都懒得算，正确性保证了就行。

---
接下来的一步也是容易发现的，当固定 $i,j$ 的时候，所有的 $k$ 中 $f_{i,j,k}$ 取值最大和最小的差值不超过 $1$，超过了就用 $1$ 的代价整体染色一次就行。

优化过后的转移方程为 $f_{i,j,k}=\min_{l=j}^k{f_{i,l,k}+f_{l,j,k}}$。针对这个转移方程，可以发现连续段越长被优化的可能性就越大，因为任意的一个连续段都不劣于拆开的若干段。

发现此时制约复杂度的最大难题在于状态，而区间 $[i,j]$ 又很难被优化，所以就将注意力放在染成的颜色上，而直接省去颜色又指向了将颜色取出其最特殊的两个代表，两端颜色上。

此处首先可以发现将整个颜色染成两端任意的一种颜色的代价一定是相同的，且一定是所有颜色的两种取值中较小的那一种。证明比较简单，不赘述。

不那么一眼的部分在于不同的颜色去更新大区间颜色时是否会造成转移错误的情况。此处可以用归纳法进行证明，此处只给出一个证明思路。同时注意到两端对称，以下都以将区间染色右端的颜色为例。

奠基过程考虑最大的一个区间 $[1,n]$，和所有区间一样，一定存在一种方案使得所有的位置染色成 $c_n$，且使用的操作次数最少。

归纳过程，需要证明对于任意一个区间，即使认为所有的 $c_j\neq c_l$ 的位置上都有 $c_l$ 是较多转移次数的那一个位置，也不会影响最终的答案。此时可以写出相应的转移方程 $f_{i,j}=\min_{l=i}^j f_{i,l}+f_{l+1,j}+1-[c_j=c_l]$。

这其中很清晰地分为两个部分，$c_j=c_l$ 的位置不用考虑，反正这一个部分在一开始就是这样的，对于 $c_j\neq c_l$ 的位置，结合之前长区间更优的结论，可以将所有的不等情况直接放到 $f_{i,j-1}+f_{j,j}+1$，也就是 $f_{i,j-1}+1$ 考虑。而在这种情况下问题就非常明了了，如果 $f_{i,j-1,c_j}$ 确实是较小的一个，则在它的区间之内一定有 $c_j$ 颜色存在，而此时用内部的更新一定不劣。

由此就得到最终解法，由于每一个颜色的位置不算很多，记录下每一种颜色的所有位置就能快速求解了。最后的总复杂度为 $O(n^2)$。


---
### 代码：

```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
const int MAXN=3005;
int T,n,a[MAXN],pre[MAXN],u[MAXN],f[MAXN][MAXN];
int main(){
	scanf("%d",&T);
	while(T--){
		scanf("%d\n",&n);
		for(int i=1;i<=n;i++)pre[i]=u[i]=0;
		for(int i=1;i<=n;i++){
			scanf("%d",&a[i]);
			pre[i]=u[a[i]];
			u[a[i]]=i;
		}
		for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
		if(i!=j)f[i][j]=1000000000;
		for(int len=2;len<=n;len++){
			for(int i=1;i<=n-len+1;i++){
				int j=i+len-1;
				f[i][j]=f[i][j-1]+1;
				for(int l=pre[j];l>=i;l=pre[l])
				f[i][j]=min(f[i][j],f[i][l]+f[l+1][j]);
			}
		}
		printf("%d\n",f[1][n]);
	}
	return 0;
}
```
