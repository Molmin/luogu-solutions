这题我们如果对于每个点枚举可以打到多少奶牛肯定是会超时的，对于每个奶牛枚举能打到它的地方也有可能超时，所以我们要换个思路。

上面两个想法都是一个点一个点地判断，那么我们能不能一下子判断整一条直线呢？

当然可以。对于每个奶牛：

- 列：奶牛所在的整一列都能打到奶牛，我们让 $l_y++$（$y$ 是奶牛的纵坐标）
- 行：奶牛所在的整一行都能打到奶牛，我们让 $h_x++$（$x$ shi 奶牛的横坐标）
- 左斜线（像这样`\`）：奶牛所在的整一个左斜线都能打到奶牛，他每向右下移一格横纵坐标都 $+1$，向左上移同理，所以在同一条左斜线上的点横纵坐标的差相同，我们让 $zx_{x-y}++$（注意没有绝对值）
- 右斜线（像这样`/`）：奶牛所在的整一个右斜线都能打到奶牛，他每向左下移一格横坐标 $+1$ 但纵坐标 $-1$，向右上移同理，所以再同一条右斜线上的点的横纵坐标的和相同，我们让 $yx_{x+y}++$

那么我们就找到了可以打到每个奶牛的行、列和两条斜线，接下来我们就可以枚举每个点，然后找到他所对应的行、列和两条横线的奶牛数，把他们加起来如果等于 $k$，那么就是满足条件的点。  
时间复杂度 $O(n^2+k)$。

下面是两个注意点：

1. 若奶牛的横坐标小于纵坐标，那么 $x-y$ 就会是负数，而下标不能是负数，所以我们给他加个 $100$ 或 $n$  
2. 若 bessie 和一些奶牛站在一起，那么这些奶牛就会被算 $4$ 次，我们要减掉 $3$ 次（也就是容斥）

具体实现见**code**：
```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
int n,k,ans;
int f[105][105];
int h[105],l[105],zx[205],yx[205];//横线，竖线，左斜线（差相等），右斜线（和相等）
int main()
{
	scanf("%d%d",&n,&k);
	for(int i=1;i<=k;i++)
	{
		int x,y;
		scanf("%d%d",&x,&y);
		h[x]++,l[y]++;
		zx[x-y+100]++;
		yx[x+y]++;
        //标记
		f[x][y]++;//这里标记具体坐标，容斥用
	}
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
			if(h[i]+l[j]+zx[i-j+100]+yx[i+j]-3*f[i][j]>=k) ans++;//注意减去多余的
	printf("%d\n",ans);
	return 0;
}
```