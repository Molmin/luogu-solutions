## 读题目，理解题意

八个方向分别是：正北，正南，正东，正西，东北，东南，西北，西南。

这八个方向呈“米”字状，如下图：

![](https://s1.ax1x.com/2020/03/22/8oAcZV.png)

（黑色点Bessie，红色点为Bessie可以射击到的格子，绿色点为Bessie射击不到的地方。）



------------

## 解题思路

分析题目，我们可以知道，奶牛所站立的地方必定为一个可以射击到所有对手的格子，即对于每一个对手，可以构造一个“米”字状，这些“米”字状的公共的交点即为解答。

因此容易想到每输入一个$K$，我们可以将能射击到该对手的所有位置打上标记，最后将矩阵遍历，找到被所有$K$打上标记的点，这些点就是奶牛Bessie可以站立的格子。其时间复杂度为$O(NK)$。

在本题中，$O(NK)$的复杂度足以通过此题，那么有没有更快的方法呢？

可以知道，暴力枚举Bessie所在的格子时间复杂度为$O(N^3)$，在本题中，比$O(NK)$要快，因此我们采取暴力枚举的方法。



------------


## 解答

1.给对手做标记（**可能有两个奶牛在同一位置上。**）：
```cpp
for (int i = 1 ; i <= k ; ++i)
	{
		int r , c;
		scanf("%d%d" , &r , &c);
		a[r][c]++;	//直接增加该位置上的奶牛数量。
	}
```

2.搜索“米”字状：
```cpp
void search(int r , int c)	//r即当前搜索到的行，c为列。
{
	int kill = 0;	//标记在该位置可以射击到的对手数。
	for (int i = 1 ; i <= n ; ++i)	//东、南、西、北四个方向搜索。
	{
		if (a[r][i])
			kill += a[r][i];
		if (i != r && a[i][c])	//此处若不进行特判，会对坐标为(r,c)的格子进行两次判断。
			kill += a[i][c];
	}
	int p = r , q = c;
	while (p > 1 && q > 1)	//东南、东北、西南、西北四个方向进行搜索。
		if (a[--p][--q])
			kill += a[p][q];
	p = r , q = c;
	while (p < n && q > 1)
		if (a[++p][--q])
			kill += a[p][q];
	p = r , q = c;
	while (p < n && q < n)
		if (a[++p][++q])
			kill += a[p][q];
	p = r , q = c;
	while (p > 1 && q < n)
		if (a[--p][++q])
			kill += a[p][q];
	if (kill == k)	//判断可以射击到的对手数
		ans++;
}
```


