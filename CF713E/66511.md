这篇题解做法上与另一篇重复了，但我会尽可能讲的详细一些的。（据说解释“详尽而深入”可以通过）

## 【题意】
有$n$个人站在一个有$m$个点的环上，每个人每一单位时间可以走到另一个相邻的点，求每个点都被至少一个人经过过所需要的最短时间。

## 【分析】
考虑到要求最短时间，而且显然时间越长任务越可能完成，符合单调性。考虑二分。

那么$check$函数需要的复杂度为$O(n)$。

因此考虑环形DP。

## 【思路】
首先要思考如何破环为链，但显然我们目前没有任何可以破环为链的依据，此时我们先考虑状态的设计。

我们先看看这道题有什么性质。

### 性质1
--------------
题目里说了，每一个人一旦走了，都只会永远朝着一个方向走。

---------------

因此，我们在进行$check$时，所需的$mid$设定为**每个人所能覆盖的点数**，由此把人走路的过程抽象成线段覆盖的过程。

那么我们就可以设计状态了。

### 【状态设计】

我们先假设首尾断开，采取之后再强制连接的做法。

设$dp[i]$表示第$i$个人所能覆盖到的最远点数，设本次$check$中一个人能覆盖的点数为$x$，设第$i$个人的位置为$b[i]$，下面考虑状态转移，这里需要分类讨论。

1、如果上一个人能够覆盖到当前这个人所在的位置，即$dp[i-1]\geq b[i]-1$

也就是说这个人到上一个人这段区间已经完全被覆盖了，我们可以完全往更远的地方覆盖
$dp[i]=b[i] + x$

2、如果上一个人不能够覆盖到当前这个人所在的位置，即$dp[i-1]\geq b[i]-x-1$当前这个人就得回去帮上一个人，由于『性质1』的约束，他能走到的最远的点便永远变成了他现在所在的位置。$dp[i]=b[i]$

3、还有一种可能性，也许上一个人的上一个人的覆盖我们往回走就可以把坑填上，即$dp[i-2]\geq b[i]-x-1$，那么上一个人就没事干了$dp[i]=b[i-1]+x$

有人可能会问这第3种情况有什么用，其实是有用的。

如：
```
1----2-3
```
假设长度为$3$，那么点$1$只能覆盖到下图中的$o$点：
```
1ooo-2-3
```
然而此时$2$必须去填坑，如下图的$x$：
```
1oxxx2-3
```
那么$3$也得回来填坑，如下图@：
```
1oxxx2@3
```
但我们发现如果这样：
```
1ooo@2@3
```
我们的$2$节点就可以省出来向右扩展了，因此这种情况是必要讨论的。

至于为什么不考虑**上一个人的上一个人的上一个人**，这是因为如果我们通过上述方法节省空间，最优的方案就已经是节省出**上一个人**向右扩展了，所以不必讨论。

### 【得出结论】
然后我们就发现，我们上述的分类讨论都是基于**两点之间距离**的，凭借这个结论，我们可以发现对于环上距离最远的两个点，它们之间的绝对不存在互相覆盖的关系，即如果把环上最远的两个点设为$1$与$n$，不用考虑$1$和$n$互相覆盖的情况，因此我们从最远的两个点处直接破环为链即可。

### 【初始状态设计】
刚才只设计完了状态转移，现在设计初始状态。

由于已经破环为链，我们考虑分析第一个点的状态。

发现第一个人可以选择向右（2）或者向左（n）走。

因此我们再次分类讨论。

1、向左走，$dp[1]=0$，没什么好说的。最后要求$dp[n]\geq m-x-1$

2、向右走，然后我们发现又有两种情况

2.a.向右走，没走到$2$，$x\leq b[2]$那么可怜的$2$号就要给$1$号填坑向左走了。$dp[2]=b[2]$，最后要求$dp[n]\geq m-1$（因为$2$也走不到。。。）

2.b.向右走，走过$2$了，$x\geq b[2]$那么其实还应该让$2$往左走，$dp[2]=x$，最后要求$dp[n]\geq m + b[2] - x - 1$，不向右走的原因在于，$n$~$1$这段区间一定是最长的（或之一），那么我们填这段区间显然更好，因为如果$1$向左走，填的是$n$~$1$与$1$~$2$，而$1,2$都向右走填的是$2$~$3$与$1$~$2$，而填$2$~$3$显然不如填最长的区间好（哪怕相等也是一样好）

那么就这样跑两次DP就做完了，详细看代码。

## 【代码】
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;
LL n, m;
LL a[200010], b[200010], l, r, ans;
inline void init(){//初始化，破环为链
    int it = 1;
    for (register int i = 2;i <= n;i ++) if(a[i + 1] - a[i] > a[it + 1] - a[it]) it = i;
    r = a[it + 1] - a[it] - 1;//将最长区间的长度设为二分的上界
    for (register int i = 1;i <= n;i ++) b[i] = a[i + it];
    LL tmp = b[1];
    for (register int i = 1;i <= n;i ++) b[i] -= tmp;
}

LL dp[200010];
inline bool ck(LL x){
    dp[1] = 0;//向左走
    for (register int i = 2;i <= n;i ++){
        dp[i] = dp[i - 1];
        if(dp[i - 1] >= b[i] - 1) dp[i] = max(dp[i], b[i] + x);
        if(dp[i - 1] >= b[i] - x - 1) dp[i] = max(dp[i], b[i]);
        if(i > 2 && dp[i - 2] >= b[i] - x - 1) dp[i] = max(dp[i], b[i - 1] + x); 
    }
    if(dp[n] >= m - x - 1) return 1;
    dp[2] = max(b[2], x);//向右走的两种情况
    for (register int i = 3;i <= n;i ++){
        dp[i] = dp[i - 1];
        if(dp[i - 1] >= b[i] - 1) dp[i] = max(dp[i], b[i] + x);
        if(dp[i - 1] >= b[i] - x - 1) dp[i] = max(dp[i], b[i]);
        if(dp[i - 2] >= b[i] - x - 1) dp[i] = max(dp[i], b[i - 1] + x); 
    }
    if(dp[n] >= min(m - 1, m + b[2] - x - 1)) return 1;
    return 0;
}

int main(){
    scanf("%lld%lld", &m, &n);
    for (register int i = 1;i <= n;i ++){
        scanf("%lld", &a[i]);
        a[i + n] = a[i] + m;//先暂时倍长
    }
    if(n == 1) {//特判只有一个点的情况
        printf("%lld", m - 1);
        return 0;
    }
    sort(a + 1, a + (n << 1) + 1);//排个序
    init();
    while(l <= r){
        LL mid = (l + r) >> 1;
        if(ck(mid)) ans = mid, r = mid - 1;
        else l = mid + 1;
    }
    printf("%lld\n", ans);
}
```