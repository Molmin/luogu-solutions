P8266题解：

这道题其实非常简单（~~建议改成入门级别~~）。
## 思路：
我们将输入的字符串 $s$ 两两分一组，可以得到以下 $4$ 种可能性：

1. “GG”，这个不需要翻转，因为反转之后还是一样的。
2. “HH”同理，这个也不用翻转。
3. “GH”，这个需要翻转，转后变为“HG”，‘G’在偶数位上。
4. “HG”，这个不需要翻转，因为‘G’在偶数位上。

当然，我这里说的需不需要翻转是对于个体的。如果第三种情况和第四种情况相邻，例如“GHHG”，那需要翻转“GH”。又例如，“HGGH”，那就要翻转“HG”得到“GHGH”，然后翻转整个，得到“HGHG”。

按上面的思路，我们就可以知道，当第三种情况与第四种相邻时，需要翻转一次。如果结尾是第三种情况，还得翻转一次。遇到第一、二种情况就不管它，因为对结果没有影响，所以直接跳过。

不妨假设“GH”的为 $1$，“HG”的为 $0$，这样就可以用数组分别开来它们俩了。
## 代码实现：
```cpp
for(i=1;i<=n;i+=2)
	if(s[i]!=s[i+1])//两两一组
		if(s[i]=='G'&&s[i+1]=='H')
			p.push_back(1);
		else
			p.push_back(0);
int cnt=0;
for(i=1;i<p.size();i++)//遍历动态数组
	if(p[i-1]!=p[i])
		cnt++;
if(p.size()==0)cout<<cnt<<endl;
else cout<<cnt+p[p.size()-1]<<endl;//如果最后一个是1，那答案要加1
```
这是另一篇题解中的核心代码，用的是``vector<int>p;``，但是我个人觉得这个方法很浪费空间，可能也有点浪费时间。
## 优化：
虽然我刚开始想的也是那个写法，但是觉得空间太大，~~强迫症患者~~想要优化空间。

首先先将两个循环连接起来，然后用 $f_1$ 表示上文中的 $p_{i-1}$，那 $f_2$ 就是 $p_i$ 咯。利用滚动思想，可以大幅度优化空间。
- 但是优化后会出现头和尾的计算问题，怎么办呢？
1. 先解决头部，也就是输入的这个字符串 $s$ 的开头。我们把开头的“GG”和“HH”过滤掉，然后初次计算 $f_1$ 即可。
2. 接下来解决尾部，其实只要把原本的``cout<<cnt+p[p.size()-1]<<endl``改成``printf("%d",ans+f2)``（当然我这里用的不是 $cnt$ 而是 $ans$）就好了。

## AC&优化后代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
string s;
int n,ans,i,f1,f2;//f1和f2相互滚动可以大幅度节省空间。
int main()
{
	scanf("%d",&n);
	cin>>s;
	while(s[i]==s[i+1]) i+=2;//过滤掉“GG”和“HH”的情况。
	if(s[i]=='G'&&s[i+1]=='H') f1=1;//初次计算f1。
	for(i+=2;i<n;i+=2)//记得是i+=2，因为是两两为一组。
	if(s[i]!=s[i+1])//s[i]==s[i+1]（即“GG”和“HH”的情况）就没有必要算了。
	{
		f2=s[i]=='G'&&s[i+1]=='H'? 1:0;//“GH”情况等于1，“HG”情况等于0.
		if(f1!=f2) ans++;//不相等就翻转。
		//printf("%d,%d",i,ans);
		f1=f2;//滚动。
	}
	printf("%d",ans+f2);//如果最后一项是1就加上。
	return 0;
}
```
按照我说的方法分四类讨论就可以成功地解决这个问题了，是不是很简单呢？

$\color{white}人家辛苦写了题解给你看，你就点个赞吧！$