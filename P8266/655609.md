题意
给定一个 $GH$ 串，只能对长度为偶数的前缀进行翻转，要求偶数位置上的 $G$ 尽可能多，求最少翻转次数。

思路
首先要思考如何让偶数位置的 $G$ 尽可能多。由于只能对偶数长度的前缀进行翻转，所以每次翻转会让一个前缀的所有位置变化奇偶性，如果去考虑每个 $G$ 的变化，情况会比较复杂，不便于分析，所以需要先化简一下状态。

根据翻转的特性，不妨每两位作为一个整体进行考虑，不难发现，如果连续两个位置是相同的，那么翻转不会对它产生影响，所以可以忽略这种情况。还剩下两种情况，因为要让 $G$ 尽可能在偶数位，可以假设 $HG$ 是 $1$ ，而 $GH$ 是 $0$ 。那么原串可以转换成一个 $01$ 串，同时原串的一次前缀翻转对应到新串变成了一次前缀的翻转加 $01$ 变换，目标就是让新串的 $1$ 尽可能多。

此时问题就变得很简单了，新串由很多 $01$ 段组成，我们可以不断的对第一段进行操作，这样翻转不会对第一段产生影响，但第一段会 $01$ 互换，然后与第二段合并到一起，不断这样操作，最终就可以让串变成全 $1$ ，这个答案是最优的。

不难发现每次操作最多减少一段，所以这种操作方案也是操作次数最少的，所以最终答案就是最后一个 $0$ 段所在的段数。

复杂度
时间
逐两位分析并计算段数 $O(N)$。

空间
存储串 $O(N)$。

代码：

```
#include<bits/stdc++.h>
using namespace std;
int n,ans;//定义 
string a; 
char last;//上一组 
int main () {
	cin >> n >> a;
	for (int i=0; i<n; i+=2) {
		if (a[i]!=a[i+1]){//GG,HH忽略掉 
			if (a[i]!=last && (last=='G' || last=='H')){// 前后不一样并且不是第一个 
				ans ++;//计数 
			}
			last=a[i];//更新上一个 
		}
	} 
	cout << ans+(last=='G');//最后一个特殊处理 
	return 0;
}
```
