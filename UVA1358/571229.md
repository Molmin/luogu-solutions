## 题意

给出一个字符串，每次随机生成一个字符，问这样生成出给定字符串所需要的期望长度是多少。

## 思路

知乎上有篇文章是讲这个问题的（找不到原文了，找到的可以评论区留言），这个问题是有线性方法的。

考虑如下问题（下文假设字符集大小是 $26$），有一个字符串 $s$，无数个赌徒在赌博，每个赌徒初始有 $1$ 元，每分钟都会有一个赌徒带着一元钱进入，也会有一个新的字符产生，当前在场上的所有赌徒都会参与赌博，赌这个产生的字符是 $s_{k+1}$ ，$k$ 表示上次赌的位置，初始为 $0$ ，如果猜对了，拥有的钱翻 $26$ 倍，接着赌下一个字符是不是 $s$ 的下一个字符，猜错了则资产清零离场，直到有一个人猜出了完整字符，这个游戏结束。

有人会问，这个问题和这个题有什么关系呢？

我知道你很急，但是先别急，我们先分析完这个问题。

当游戏结束的时候，场上还在的赌徒一定会有一个非常幸运的人，赌出了所有字符，假设这个赌徒的序号是 $N+1$，比如字符串 $\text{ABACABBABA}$ 长度为 $10$，一个幸运的人赌完了整个字符串，那 $N$ 之前的赌徒已经输完了，$N+1$ 赌完了，$N+2$ 就会输个精光，只有 $N+8$ 猜对了 $3$ 个，$N+10$ 猜对了 $1$ 个，则场上的赌徒一共还有 $26^1+26^3+26^{10}$ 元。

这个问题是一个公平赌博（期望收益为 $0$ ），所以赌徒的收益是鞅（我也不懂，知道就行），记第 $k$ 个赌徒在生成 $n$ 个字符后的收益为 $A_{n}^{(k)}$，所有赌徒的总收益就是：
$$
S_n=\sum_{i=1}^{\infty} A_n^{(k)}-1
$$
令 $T=N+|s|$，
我们已经分析出来 $S_{T}=26^1+26^3+26^{10}-T$，则我们知道 $E(S_T)=0$ （因为这是公平博弈，可以不管鞅的概念）。则我们计算出来：

$$
E(T)=26^1+26^3+26^{10}
$$
所以 $E(T)$ 即为所求。


文末补充一句，这里的公平赌博源于一个赌徒用 $x$ 去赌，有 $\frac{1}{26}$ 的概率得到 $25x$ 收益 ，$\frac{25}{26}$ 的概率得到 $-x$ 收益，所以期望收益是 $0$。这显然对每个赌徒的每次赌博成立。

## code

这里相信看了上面的例子都明白如何求了吧，就使用 kmp 求出 $nxt$ 数组，然后不断跳 $nxt$ 即可。

可以通过预处理幂做到完全线性，不过没有必要。

```cpp
ll ksm(ll a,ll p)
{
	ll ans=1;
	for(;p;p>>=1,a=a*a)if(p&1)ans=ans*a;
	return ans;
}
char s[MAXN];
int nxt[MAXN];
signed main()
{	
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	int T;
	cin>>T;
	for(int I=1;I<=T;I++)
	{
		int n;
		cin>>n;
		cin>>(s+1);
		for(int i=2,j=0;s[i];i++)
		{
			while(j&&s[j+1]!=s[i])j=nxt[j];
			if(s[i]==s[j+1])j++;
			nxt[i]=j;
		}
		int u=strlen(s+1);
		ll ans=0;
		while(u)ans+=ksm(n,u),u=nxt[u];
		cout<<"Case "<<I<<":\n"<<ans<<'\n';
		if(I!=T)cout<<'\n';
	}
	return 0;
} 
```


