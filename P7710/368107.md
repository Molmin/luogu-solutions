[$\tt Link$](/problem/P7710)

## 前言

经过了一周的挣扎，终于对这题有了一点理解（我太弱了（悲

我的做法目前的复杂度是**根号带 $\log$ 的**，需要**神奇的卡常技术**。但是在我的疯狂卡常下（**后面会给出详细方法**），获得了**最优解前 $7$** 的好成绩。

## 题解

首先这个题长得非常像 [[Ynoi] 初始化](/problem/P5309)，考虑根号分治。

---

对于 $x\gt\sqrt n$ 的修改，这种修改要改的层数是 $\sqrt n$ 级别的。我们考虑存下树的每一层，然后把每一层都按 $\tt DFN$ 排序。对于每一层的修改可以二分出子树在这一层上对应的区间，二分完之后区间修改。查询直接在那个点所在层上单点查询。分块 $O(1)$ 区间修改 $O(\sqrt n)$ 单点查询即可平衡复杂度。

然后你意识到一个问题：**二分是复杂度瓶颈**。于是你想了很久如何把这个 $\log$ 优化掉，然后打开题解区，发现了长链剖分。。。~~如果早知道要用长剖，我甚至宁愿写高复杂度做法~~

发现了可以离线处理每一层，然后构造二分数组。但是好像这样子的话更容易复杂度爆炸，果然我是大口胡选手/kk

---

对于 $x\le\sqrt n$ 的修改，考虑离线问题，然后枚举 $d$ 作为修改的模数，$r$ 作为修改的余数 $(1\le d\le\sqrt n,0\le r\lt d)$，提取出 **所有 $x=d,y=r$ 的修改** 以及 **询问的点深度模 $d$ 余 $r$ 的询问**，然后把这个奇怪的修改转化为子树加，询问转化为单点查，跑出 $\tt DFS$ 序即可。

你又意识到一点：这种情况下每个修改只会被用一次，但是每个询问会被拆成 $\sqrt n$ 个（对于每个模数它都会被拆出一个），所以你需要使用 $O(\sqrt n)$ 区间修改 $O(1)$ 区间查询的分块就行了。

如何提取出我们想要的修改和询问呢？可以考虑枚举 $d=1,\cdots,\sqrt n$ 作为模数，使用 $d$ 个 `vector` 装下每个 $r=0,\cdots,d-1$ 作为余数的询问。

+ 对于一个修改，如果模数 $=d$，余数 $=k$，考虑将其装入第 $k$ 个 `vector` 里。
+ 对于一个询问，如果 $a$ 的深度模 $d=k$，考虑将其装入第 $k$ 个 `vector` 里。

---

再给一组数据

$\texttt{in.txt}$

```
9 7
1 1 2 2 3 4 4 8
1 3 1 0 2
2 6
1 1 3 1 1
1 4 8 2 4
2 3
2 2
2 9
```

$\texttt{out.txt}$

```
2
3
1
5
```

关于样例过不了的 $\tt debug$：考虑将根号分治的阈值分别调到 $0$ 和 $10$，然后跑样例或者我的数据，就可以直接测试根号分治两部分的程序是否正确。

## 实现

这个不太简单，我还是需要讲几点。

$x\gt\sqrt n$ 的部分。首先你只需要存每一层的 $\tt dfn$ 就行了。毕竟你也只需要将其排序并在这里面二分。接着是关于 `vector` 的问题。看到有的题解说 数组+内存静态分配 会更快，但是我实践下 `vector` 快得多。

$x\le\sqrt n$ 的部分。你不是要用 $\sqrt n$ 个 `vector` 来存询问吗？那你如何清空一个 `vector` 呢？有一种写法是先 `clear()` 再 `shrink_to_fit()`$\texttt{(c++11)}$。但是实践下更快的方式是将这个 `vector` 与一个空的 `vector` 进行 `swap`。

没卡常的代码，删去快读、头文件等部分，[我放在了这里](https://www.luogu.com.cn/paste/42y2ltq5)

[$\tt 50pts$](https://www.luogu.com.cn/record/74222973)

瞎条块长可以获得更好的成绩（块长为 $0$ 可以获得 $\tt 59pts$），这部分就不讲了，下面全是更好的优化

## 卡常

卡常的技巧分为以下几个阶段。（块长这种主要是和常数有关，所以我的和您的可能不太一样）

1. 使用一个 `flg` 数组，如果 $x\le\sqrt n$ 部分枚举出了一个 $d$，但是这个 $d$ 没有任何与之配对的修改，那么就跳过（毕竟询问也只能是 $0$）。

2. 使用一个 `Flg` 数组，如果 $x\le\sqrt n$ 部分枚举出了一个 $d$，那么标注出所有的 $r=1,\cdots,d-1$，$r$ 有没有对应的修改，没有就跳过。

3. 瞎调阈值，发现 $\sqrt n$ 过不去（显然复杂度就有问题），$\sqrt{n\log n}$ 也过不去（因为造数据人卡了）。

+ 选在 $\sqrt n$，上面部分点 $\tt AC$，下面部分点 $\tt TLE$。
+ 选在 $\mathtt{900\sim 1000}$，上面部分点 $\tt TLE$，下面部分点 $\tt AC$。
+ 最后请来 [$\tt\color{black}o \color{red}rz\_z$](https://www.luogu.com.cn/user/257146)，他帮我优化了快读，改为了 $\texttt{C++98}$，加了 `register`，以及**把块长适度调小**，获得了更高的成绩。

4. 适当弃用 `STL`。我想过丢掉 `vector`，但是变慢了。于是我尝试手写了 `lower_bound` 和 `upper_bound`，然后快了很多。

5. 最后的一步了。这时我已经能把所有的点 $\tt AC$ 一遍（但不是同时），于是我决定写一个程序来优化自己的阈值的选择。

```cpp
// 计算以 Lm 为阈值，要计算多少次。;
const double d1,d2,d3,d4;
// d1：x>lim部分的修改常数
// d2：x<=lim部分的修改常数
// d3：x>lim部分的询问常数
// d4：x<=lim部分的询问常数
int blkcnt(int Lm){
	int cnt = 0
	for(int i = 1;i <= m;++i){
		a = qa[i],x = qx[i];
		if(qo[i] == 1){
			if(x > Lm) cnt += (K - dep[a]) / x * d1 + 1;
			else cnt += sqrt(n) * d2;
		} else {
			cnt += sqrt(C[dep[a]]) * d3;
			cnt += Lm * d4;
		}
	}
	return cnt;
}
```

然后用 $\tt 550$ 和 $\tt 950$ 来计算，用总次数最小的那个值来做块长。

然后分没有变，我意识到不能只用两个，我用了 $\mathtt{200\sim 1150}$ 的所有 $\tt 50$ 的倍数的数测试，又稍微更改了 $d1,\cdots,d4$ 的取值，获得了 $\tt AC$。

[**AC 代码**](https://www.luogu.com.cn/paste/waz4mgqb)