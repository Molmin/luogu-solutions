## 前言  
[Stop learning useless algorithms, go and solve some problems, learn how to use binary search.](https://www.luogu.com.cn/paste/v8ytdvos)  

神仙题，只能膜拜 bensonlzl 和 oolimry。 

[话说 severkiller 的那场 GR 的 \*3500 压轴题出题人好像也是 oolimry 来着？](https://programming.blog.luogu.org/solution-cf1491i)

审核题解的管理员顺便把这题评黑了吧，\*3500 没有不黑的道理。

## 题意  

**题意仅为简单回顾，具体内容建议还是去看[原题面](https://www.luogu.com.cn/problem/CF1428H)。**    

- $n$ 个长度为 $m$ 的圆弧覆盖在大小为 $n\times m$ 的圆周上。  
- 每次询问可以选择一个圆弧，朝某个方向（顺时针或逆时针）移动单位距离，然后交互库返回圆周上没有圆弧覆盖的地方的总长度。  
- 你需要在 $15000$ 次询问内求出当时所有圆弧的相对位置（**不是最初的相对位置**）。  
- $n \le 100,m \le 20$。

## 题解

**完全不知道这个思路是怎么想出来的，只能膜拜出题人！！**  

### 做法

首先为了便于描述，我们将 $n\times m$ 的圆周摊平成 $n \times m$ 的数组，下标循环。向右移动为顺时针，向左移动为逆时针。并且称第 $0$ 段弧为 $C$，某段弧的位置为其左端点的位置，没有圆弧覆盖的地方的总长度为 $k$。 


--------------

我们需要找到与 $C$ 重合的弧。   

如果设当前 $C$ 的位置在 $p$，我们将 $C$ 向右移动并且 $k$ 变大了，那么说明原先 $p$ 这个位置没有其他的弧。因此，如果我们再次向右移动 $C$ 并且 $k$ 没有变大，由于 $p$ 没有弧而 $p+1$ 有弧，我们可以肯定在有另一个弧的位置在 $p+1$，然后我们再将 $C$ 向左移动。 

--------------

我们现在进入**检测阶段**，以找到在该位置与 $C$ 重合的任何弧，将此位置记为 $x$。  

设 $S$ 是我们**不知道其位置**的弧集（最开始包含所有 $1$ 到 $n-1$），$T$ 和 $F$ 是空集。$T$ 表示所有候选弧（可能与 $C$ 重合的弧）的集合，$F$ 将包含我们向左移动的所有弧。

取出 $S$ 中的所有元素并将它们放入 $T$ 中，然后选择 $S$ 中的一半元素并将它们添加到集合 $F$ 中。  

我们现在将 $F$ 中的所有元素左移，并将 $C$ 向左移动以检查是否有弧在位置 $x-1$。

如果存在，那么我们知道最初在 $x$ 处重合的弧在 $F$ 中。在这种情况下，$T \gets T \cap F$，选择 $T$ 中的一半元素向右移动并从 $F$ 中删除那些元素。

如果在位置 $x-1$ 处没有弧，那么我们正在寻找的弧位于 $\complement_TF$。$T \gets \complement_TF$ 并选择 $T$ 的一半向左移动并将它们添加到 $F$。然后我们将 $C$ 向右移动并递归。  

当我们将 $T$ 缩小到恰好 1 个弧时，我们就知道该弧现在的确切位置。我们将该弧向左移动，使其右端点在 $x-2$ 处，这样它就不会覆盖位置 $x-1$，我们可能仍需要使用该位置。现在我们移除从 $S$ 中找到的弧并离开检测阶段并继续搜索其他弧。

一旦我们找到了所有 $n-1$ 条其他弧，我们就会找到 $C$ 的相对位置并将它们输出。  

-------------


### 查询次数分析  

每当我们将 $C$ 向右移动并且不在**检测阶段**时，我们使用 $1$ 移动。这最多发生 $2nm-m$ 次，因为它需要最多 $nm-m$ 向右移动以找到 $C$ 重合的第一个位置，并再次遍历整个圆以找到所有弧。

每当我们进入检测阶段时，当我们将 $C$ 向右移动然后向左移动时，我们会找到一个弧并最初使用 $2$ 个移位，总共产生 $2n-2$ 个这样的移位。每次二分查找需要 $2\log|T|$ $C$ 的移动，因此在 $n-1$ 个**检测阶段**，询问次数总数最多为 $2n\log n$。  

执行二分搜索的方式在这里非常重要。以 naive 的方式执行它（例如向左移动一半，测试然后向后移动）最多可以使用 $n^2$ 个查询，可能因此就被卡了。

相反，我们将在二分搜索的每次迭代中移入/移出 $F$ 的元素数量设置为较小的一半。这样我们就可以保证候选弧所做的移位次数最多是首先候选弧的总数。这样询问次数变成了 $\dfrac {n(n-1)} 2$，因为我们从 $n-1$ 条候选弧开始，并在每个检测阶段后将该数量减少 $1$。

当我们将每条弧向左移动 $m$ 或 $m+1$ 时（取决于当我们将其缩小到 $1$ 弧时它们是否在 $F$ 中），我们最多使用 $(n-1)(m+1)=nm+n -m-1$ 次移动。

--------

因此，我们总共最多使用 $2nm-m+2n-2+2n \log n + \dfrac {n(n-1) } 2 +nm+n-m-1=12607<15000$ 次询问。  

实际上代码实现的时候稍微拉一点多几个 $n$ 或 $m$ 没什么影响，因为瓶颈实际上在 $3nm$ 和 $\dfrac {n (n-1)} 2$ 处。  


---------------

## 代码  

实现方式是从 CF 上卡过来的，凑合着看吧。  
```cpp
int n,m,w,cur,ans[N],S[N],flag;
int ask(int r,int d){cout<<"? "<<r<<" "<<d<<endl;int x;cin>>x;swap(cur,x);return cur-x;}
void find(){cout<<"! ";for (int i=1;i<n;i++) cout<<ans[i]<<' ';cout<<endl;exit(0);}
signed main()
{
    cin>>n>>m;w=n*m;ask(0,1);
    vector<int> S(n-1);
    for (int i=1;i<n;i++) S[i-1]=i;
    ask(0,1);
    while (1) if (ask(0,1)>0) flag=1;else if (flag) break;
    ask(0,-1);
    for (int i=0;i<w;i++)
    {
        if (ask(0,1)>0) {flag=1;continue;} else if (!flag) continue;
        if (S.empty()) continue;
        ask(0,-1);
        int l=0,r=S.size();
        bool out=0;
        while (r-l>1)
        {
            int mid=(l+r)>>1;
            if (!out) for (int j=mid;j<r;j++) ask(S[j],-1);
            else for (int j=l;j<mid;j++) ask(S[j],1);
            if (ask(0,-1)<0) r=mid,out=0;else l=mid,out=1;
            ask(0,1);
        }
        int p=S[l];
        for (int j=out-1;j<m;j++) ask(p,-1);
        ans[p]=(i-m-1+w)%w;S.erase(S.begin()+l);
        i--;ask(0,-1);flag=ask(0,1)>0;
    }
    find();
}
```