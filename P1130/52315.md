据我同学（DP小王子）&&众多题解说，这题就是数字三角形的变式。然后他经过深思熟虑（？），给我这么一个方程：
```cpp
f[i][j]=min(f[i-1][j-1],min(f[i-1][j],f[i-1][j+1]))+a[i][j];
```
我看了一眼，直接怼他没好好看题。然后，然后他就不肯帮我做了。。。

————————————分割线————————————

这一题首先要注意输入顺序，要把输入的矩阵“立起来”，也就是横行变竖列，竖列变横行。~~事实上，我知道要这样，但由于不当的转换还是错了不少~~

然后是方程。我虽然看到了题目的边界转换处理，但我同时也被那个同学带偏了：

（以下jiayi（，jianyi）函数为题目意义的对一个数加（剪）一，也就是n变1（,1变n），其他不变）
```
      f[i][j]=min(f[i-1][j],min(f[i-1][jianyi(j)],f[i-1][jiayi(j)])+a[i][j]);
```

后来经过无数的wa之后我意识到**只能正向换小组**，也就是说，f[i][j]只能从f[i-1][j]和f[i-1][jianyi(j]]转移。~~然后我又删错了函数导致wa，样例还调不出来~~

附AC代码（我把jianyi函数删掉了，抄题解的小心点）
```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,m,i,j,a[2010][2010],f[2010][2010],s;
int main()
{
    scanf("%d%d",&n,&m);
    for (i=1;i<=m;i++)
     for (j=1;j<=n;j++)
      scanf("%d",&a[j][i]),f[j][i]=1e15;
    for (i=1;i<=n;i++)
     for (j=1;j<=m;j++)
      f[i][j]=min(f[i-1][j],f[i-1][jianyi(j)])+a[i][j];
	s=f[n][1];
	for (i=2;i<=m;i++) s=min(s,f[n][i]);
	printf("%d\n",s);
	return 0;
}
```