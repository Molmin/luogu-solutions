**首先，这道题最优方法应该是DP，再加上空间大约是2001^2 *2 *4B（2001^2是int二维数组，一个存本来数据，一个存DP的值）并不超。**

主要思想：顺序递推，一定按天数，一天一天往后推，**两层循环千万别写反了！！！**

具体实现：

```
#include<bits/stdc++.h>
using namespace std;
int m,n,a[2001][2001],f[2001][2001];
int main()
{
	scanf("%d %d",&m,&n);
	for(int i=1;i<=n;i++)
	for(int j=1;j<=m;j++)        //1
	cin>>a[i][j];
	for(int i=1;i<=n;i++) f[i][1]=a[i][1];    //2
	for(int j=2;j<=m;j++)
	for(int i=1;i<=n;i++)
	{
		if(i==1) f[i][j]=min(f[i][j-1],f[n][j-1])+a[i][j];      //3
		else f[i][j]=min(f[i][j-1],f[i-1][j-1])+a[i][j];
	}
	int ans=1e9;

	for(int i=1;i<=n;i++) ans=min(ans,f[i][m]);    //4
	
	cout<<ans;
	return 0;

}
```

1:输入。可以看到，题目中是先输入行，后输入列。该代码中用
m表示行，n表示列，故先输入m,后输入n.

2:DP初始化。众所周知，在第一天时，选择哪个小组的最小天数，就是哪个小组第一步的天数。n是小组数，在矩阵里是行数，在第一个下标。

3：DP核心部分。 _**两个循环一定不要写反！**_ 这是我说第二遍了。（如果写反了，遍历到第三步就会出问题。）可以看到，每个小组在每一步的最小天数就是在前一步中，该小组的最小天数，和前一小组的最小天数的最小值，再加上该小组这一步的天数（有点绕，其实可以这么理解：如果在前一步中，从该小组顺延过来的天数比从前一小组换过来的天数少，就将这部分天数顺延过来，再加上这一步的天数，反之亦然）。当然，还有一个特殊情况：如果i(小组号）为1，那他只能从n组换过来,这就是特判的原因了。

4：计算答案：我们要计算的，是f[1][m]到f[n][m]之间的最小值，这是为了比较出执行完全部m步后的最优方案，故先初始化
ans为1e9(即1000000000,10的9次方），然后遍历比较，得出答案。


最后说一句，若有哪位奆佬知道怎么更好解决环状数据，可以在评论区留言，谢谢！
