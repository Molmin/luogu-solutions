# P8850 题解
想了一节语文课（对不起语文老师），终于推出来了！
感觉自己解法不太一样？

upd:noip考完退役了


------------


显然，如果我们确定了起点 $x$ 的位置，就能线性算答案。我们考虑环上离起点距离为 $i$ 的点中，转移权值 $1$ 到起点的期望（注意这里  $i$ 的定义有变化），不妨设其为 $E_i$ ，考虑对其他期望的贡献及环本身的对称性，则有：

$$E_0 = 0$$

$$E_i = E_{n-i}$$

$$2E_i = E_{i-1}+E_{i+1} + 2$$

转换一下：

$$E_{i+1}-E_i =  E_i - E_{i-1}-2  $$ 

发现这是一个等差数列，对前 $n-1$ 项求和，可以由上述式子得到:

$$E_1 = n-1$$

对前 $i-1$ 项做前缀和，可以得到：

$$E_i = (n-i) i$$

这样我们就可以得到每个 $1$ 转移到起点的期望了。暴力的话就是枚举每个起点算答案。

考虑优化，发现这是个二次函数，其相邻整点函数值的差的差分为定值  $2$ 或 $-2$，而在本题中，令起点从左向右移一个单位，除起点外的所有点在函数上左移一个单位（相当于向右移动起点每个点离起点的距离 $-1$ ），原起点加到所有点最后，那么除原起点以外的点的期望值的增量必为 $-2$ .

单独考虑前起点$i$，其期望值增量由最后的 $-(n-1)$ ，变为 $(n-1)$ ，增量为 $2n-2$（以上皆为权值$1$的增量，计算时只需乘上对应的 $a_i$ ）。

这样就可以方便的维护增量。考虑移动起点，则起点从$i$到$i+1$增量的变化量为:

$$2na_i-2\sum_{j=1}^{j\leq n} a_{j}$$

初始增量为:

$$(n-1)a_1-\sum_{j=2}^{j\leq n} a_{j}(E_{j-1}-E_{j-2})$$

后者是朴素的前缀和，每个点的增量可以常数级别维护，于是做完了。唯一要注意的是数据范围会爆 long long。代码如下:
```cpp
#include<bits/stdc++.h>
using namespace std;
int T,n;
long long a[1000005];
__int128 ans=1e36,sum,add,p = 1004535809,b[1000005],E[1000005];
//sum表示现在的答案，add表示增量
int main(){
	scanf("%d",&n);
	for(int i = 1; i <= n; i++){
		scanf("%lld",&a[i]);
        b[i]=b[i-1]+a[i];//可以直接用一个变量维护，懒得改了
        E[i-1] = (__int128)1ll*(n+1-i)*(i-1);/计算初始期望
        sum+=E[i-1]*(__int128)a[i];//计算初始答案
        if(i>1)add+=(E[i-2]-E[i-1])*(__int128)a[i];//维护初始增量
	}
    add+=(n-1)*a[1];
    ans=sum;
    for(int i = 2;i <=n;i++){
        sum+=add;
        add-=b[n]*2;
        add+=2*n*a[i];//根据上述式子计算新的增量
        ans=min(ans,sum);
    }
    cout << (long long)(ans%(__int128)1004535809);
	return 0;
}
```


