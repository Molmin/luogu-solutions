$\color{blue}{\texttt{[Analysis]}}$

**本题解并不提供正确的思路，但是会分析这道题中大家容易出错的地方。**

看到数据范围中的 $1 \leq n \leq 20$，就想到这道题应该用状压 dp。

先约定，当前所有节点的颜色状态用一个整数 $S$ 表示。如果 $S$ 二进制的第 $i$ 位是 $0$，则该节点当前颜色为 `R`，否则为 `B`。

很容易想到的这样一个思路：用 $f_{s}$ 表示从起始状态变化为当前状态最少需要多长时间。状态转移不算特别复杂，但是时间复杂度有问题。

第一，你不能用普通的 dp，因为状态之间不保证谁先出现，谁后出现，所以你只能用记忆化。

但是如果你用记忆化的话，如果只有 $s$ 这一个状态，你很有可能会在同一个节点反复操作导致死循环。

如果你不想死循环，就必须要多加一个状态 $C$，表示是否在第 $i$ 个节点上进行过操作。我们知道，不同的 $C$ 下，$f_{s}$ 的值不同，你就必须把 $f_{s}$ 变成 $f_{s,C}$。于是，MLE 了。

所以这样简单粗暴的方式是有问题的。

正解很巧妙，大家可以看这篇[题解](https://www.luogu.com.cn/blog/ducati/solution-p7732)。

但是，如果你就这么兴冲冲地开始写代码，你可以会 TLE。

大家看题解中的这一段代码：

```cpp
for (int k=0;k<=n;++k){
	for (rg int s=0;s<(1<<n);++s){
		if (f[k][s]){
			f[k+1][s]=1;
			for (int i=1;i<=n;++i)  f[k+1][s^fuck[k][i]]=1;
		}
	}
	if (f[k+1][best_msk]) {printf("%d\n",k);lastans=k+1;break;}
}//Copy from ducati
```

`ducati` 把 $k$ 这一维放在了前面。但是很多同学（包括笔者）喜欢把大的一维（即 $\text{best\_msk}$ 的那一维）放在前面，并且获得了 TLE $45$ 分的好成绩。为什么？

因为这题卡常数。

大概的原因是因为电脑在找数据的时候是一个一个地址线性搜索的，如果把 $\text{besk\_msk}$ 那一维放在前面的话，会导致指针左右大幅度地跳来跳去，于是就 TLE 了。