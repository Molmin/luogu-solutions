这是NOIP 2017最后一道题

不知道这道题有没有人代码写的和我一样麻烦.
### Solution
#### 30分暴力
维护每行每列的元素.

每次删除一个元素的时候, 需要修改一行一列

因此复杂度上界$O(nmq)$.

#### 50分链表
因为查询操作比较少
然后又需要支持快速删除一个数的操作.
显然可以用链表来处理.

具体一点就似乎

#### 70分线段树
这20分的部分分来自于队伍只有一行的情况.

这个做法是比较重要的吧!
应该是100分做法的基础.

用线段树维护队列前m-1个位置.
这个位置有人记为1, 没人记为0, 那么线段树上二分第一个$s_i=x$的位置, 这个地方类似于主席树吧!

#### 100分动态开点线段树
发现如果按上面70分的做法开n + 1颗线段树分别维护每一行的前 m - 1个元素和最后一列.
这样做的话, 肯定会超过空间限制的.
但是发现一共修改q次的话线段树没必要每个节点都开.
所以正解大概就是这样的呀.

我不知道我是咋写的反正出来好多细节
因为考虑的比较周到加上70分做法的基础
大概是写对了

不过有一个不知道该如何处理的问题
就是我每颗线段树开节点都是$2 ( m - 1)$, 也就是说如果修改都在一行内进行并且q大于m的话, 我是处理不了的
70分做法也有这样的问题, 不过不是动态开节点的话就随便处理一下就OK了.
这个如果严格的按照m - 1 + q开节点的话, 比较难办.

所以我的解决方案是第一行的线段树建$2q$个节点, 再把第$m-q$个节点暴力修改就OK了.
如果有人有更好的解决方案, 请多多指教.

### Code
**指针警告!**

我一般不会刻意卡常, 写的开心就好.(不需要卡常呀) 所以很慢.

根据以往卡常的经验, 开内存池, 使用正确的`long long`姿势, 读入优化等常规优化应该能快一点.

#### 50分
[50分链表](https://paste.ubuntu.com/p/7D4ny8bFz3/)

#### 70分
[70分线段树](https://paste.ubuntu.com/p/4KYTQ7N5xH/)
#### 90分
[90分线段树](https://paste.ubuntu.com/p/8Q57ddBC7T/)

#### 100分
[100分](https://paste.ubuntu.com/p/SgGZxnQvzw/)