# Solution [USACO21JAN] Dance Mooves S

这道题如果纯模拟，50分可以到手，但是想拿满分，就需要得出几个结论

我们不妨先以样例作参考，实践一下：

```
5 4
1 3
1 2
2 3
2 4
```

共有5只奶牛，4次**循环操作**，具体操作如下：

	第一项和第三项互换：1  2  3  4  5  ->  3  2  1  4  5

	第一项和第二项互换：3  2  1  4  5  ->  2  3  1  4  5

	第二项和第三项互换：2  3  1  4  5  ->  2  1  3  4  5

	第二项和第四项互换：2  1  3  4  5  ->  2  4  3  1  5

小伙伴们可以继续算下去，知道第$n*k$ 次互换后，数组为：

	1  2  3  4  5

与原数组相同，再多试几组数据，就会发现**每过** $n*k$ **次运算后，与原数组相同**

既然如此，操作会进行无数次，为循环类型出现。因此，**同一个点在不同循环节中经过的点是相同的**，然而每次循环后，会有许多路经相同的点，即：$A$从1走到2，$B$从3走到1，然后一定会走到2。因此，我们可以得出结论：经过$K$次操作后，一定会出现许多个环（路经相同的点们），当然，也可能有1个点组成的环。

### 根据以上说明，可以得出此题的特点：

1. 每经过$n*k$次操作，数组复原

1. 经过$k$次操作后，一定会出现许多个由路经相同的点组成的环，当然，也可能有1个点组成的环。

那我们怎样维护这个环呢

- 用a记录变化数组

- 用并查集记录形成的环

- 用vector记录每个点路过的点

- 用set记录答案（蒟蒻也是第一次用。。。）

详细解释在代码中体现：

## AC代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,k,a[100005],fa[100005];
vector <int> v[100005];
set <int> ans[100005];
int find(int x){//并查集找父亲
	if(fa[x]==x) return x;
	return fa[x]=find(fa[x]);
}
int main(){
	cin>>n>>k;
	for(int i=1;i<=n;i++){//并查集和原数组重置
		fa[i]=i;
		a[i]=i;
	}
	for(int i=1;i<=k;i++){
		int x,y;
		cin>>x>>y;
		swap(a[x],a[y]);//交换
		v[a[x]].push_back(y);//载入经过的点
		v[a[y]].push_back(x);
	}
	for(int i=1;i<=n;i++) v[a[i]].push_back(i);//载入改点的原点
	for(int i=1;i<=n;i++) fa[find(i)]=find(a[i]);//合并并查集
	for(int i=1;i<=n;i++){
		for(int j=0;j<v[a[i]].size();j++){
			ans[find(a[i])].insert(v[a[i]][j]);//用set载入a[i]的答案
		}
	}
	for(int i=1;i<=n;i++) cout<<ans[find(i)].size()<<endl;//输出答案
	return 0;
}
```

在下蒟蒻，大佬勿喷