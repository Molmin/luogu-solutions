这道题需要先用分治的思路找规律，找到规律这道题就特别简单了。
我们先来看一个例子：

![](https://cdn.luogu.com.cn/upload/pic/66728.png )

## 思路
很明显，要把n个数合并成一个数，需要合并n-1次

我们要让代价尽可能的小，
最大的第5个数就应该尽可能少的和别的数合并。

由于第5个数不可避免的要和左右两边的数各合并一次，所以第5个数至少被计算2次，那我们就让它只合并两次。

要让它只合并两次，就要先合并左边的4个数，再合并右边的3个数，最后和第5个数合并。

接下来我们分治地合并左右两个子区间，下面举出几个数的例子，大家找找规律：

作为左边4个数中最大的数，第2个数也要被计算2次，但第8个数因为右边没有数了，就只用计算1次，而第4个数是夹在第2个数和第5个数之间这个区间最大的数，它只用在和第3个数合并时计算1次，而最小的第6个数合并时不会被计算。

找到规律了吗，规律就是**一个数被计算的次数就是它两边紧挨着的比它小的数的个数**，看看是不是这样。

找到了这个规律，一个蓝题就变成了一个红题了。

### 2019/10/5 update

感谢@[暮光闪闪](https://www.luogu.org/user/19811)提醒：

如果相邻两数相等，仍然必须选出一个较大的数，比如选择左边为较大的数。如果判断时一个数右边的数等于该数于那么该数应计算，而它的左边等于时就不应计算。

## 代码：
```cpp
#include<iostream>
using namespace std;
long long a[1000005];//每个数的值
int main(void)
{
    long long n,ans=0;//n表示数的数量，ans是代价
    cin>>n;//输入数的个数
    for(int i=1;i<=n;i++)
    {
        cin>>a[i];//整个程序大部分时间都花在这步上了qwq
    }
    for(int i=1;i<=n;i++)//枚举每个数
    {
        if(i>1&&a[i-1]<a[i])//如果左边小于它
        {
            ans+=a[i];
        }
        if(i<n&&a[i+1]<=a[i])//如果右边小于等于它
        {
            ans+=a[i];
        }
    }
    cout<<ans<<endl;//输出
    return 0;
}
```