### 题目大意
  $T$ 组数，每一组选取两个数减一，另一个数加二，问最后让其中两个数为 $0$ 的次数，不能则输出 $-1$。
### 做法

- 先排序。

- 找有没有两个相同的数,找到了就直接输出其中一个。

原因：找到两个数就可以让他们同时不断减一，最后这两个数可以同时清零，剩下第三个数。

- 找是否有两个数的差值为三的倍数，找到就更新最小值。

原因：每次操作会让两个数减一，另一个数加二,所以一个数会与另外两个数的差距缩小三。如果有两个数的差值为三的倍数，就能让他们两个数归零，次数为 $\min(a,b)$。

- 没有差值为三的倍数的即为无解。

原因：每次操作会让一个数与另外两个数的差距缩小三，而三个数中没有两个数差值为三的倍数的，就不可能清零。
### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n, m,a[10];
int main()
{
    int T;
    cin>>T;
    while(T--)
	{
        cin>>a[1]>>a[2]>>a[3];
        sort(a+1,a+4);//升序排序
        if(a[1]==a[3])//找有没有相同的
		{
            printf("%d\n",a[1]);
            continue;
        }
        if(a[1] == a[2])
		{
            printf("%d\n",a[1]);
            continue;
        }
        if(a[2] == a[3])
		{
            printf("%d\n",a[2]);
            continue;
        }
        int minn=2147483647;
        if((a[2]-a[1])%3==0)//差值为三就更新最小值
		{
            minn=min(a[2],minn);
        }
        if((a[3]-a[1])%3==0)
		{
            minn=min(a[3],minn);
        }
        if((a[3]-a[2])%3==0)
		{
            minn=min(a[3],minn);
        }
        if(minn!=2147483647) //更新过就输出
			printf("%d\n",minn);
        else 
			printf("-1\n");//没更新过就无解
    }
    return 0;
}

```