## 前言

做法和楼上大佬差不多，但是我可能会稍微讲得详细一些。

## 题目描述

一条直线上有 $n+2$ 个点 $0,1,2,...,n+1$，其中 $1,2,...,n$ 号点上有传送点，你刚开始在 $0$ 号点，有 $c$ 枚金币。如果你现在在 $i$ 号点，你可以：

- 当 $i\neq0$ 时，向左走一步，花费 $1$ 金币。
- 当 $i\neq n+1$ 时，向右走一步，花费 $1$ 金币。
- 当 $i$ 号点有传送点时，花费 $a_i$ 个金币传送到 $0$ 号点或者 $n+1$ 号点（你可以选择传送到哪儿），同时 $i$ 号点的传送点消失。

求你最多能使用几个传送点。

## 分析

考虑每一次使用传送点，必定会重置到 $0$ 或 $n+1$，而下一次走到传送点必定是从 $0$ 和 $n+1$ 开始的。于是我们得出一个显然的结论，我们只需要统计每个传送点从 $0$ 与 $n+1$ 开始走所要花费的金币即可。

也就是对于传送点 $i$，从 $0$ 开始所需即为 $i+a_i$ 金币，从 $n+1$ 开始即为 $(n-i+1)+a_i$。

再一想，每一次是从 $0$ 还是从 $n+1$ 是由我们自己决定的，所以我们不妨只计算当前传送点最优走法所需金币，具体来说，就是所需金币 $s_i=\min(i+a_i,(n-i+1)+a_i)$。

但是上面我们都没有考虑初始点是 $0$ 这个因素，也就是说我们必定要有一个传送点我们取它的从 $0$ 开始的路径。我们可以枚举这个传送点。于是，问题变成了在取了这个传送点之后，最多能取多少个其他传送点。

显然贪心，可以预先对 $s_i$ 排序，再在枚举时取最小的（即从 $s_1$ 开始的）一段数。既然是一段，我们就可以使用前缀和。依据前缀和的单调性，直接在 $s$ 上二分即可，找最长的所需金币数 $\le a_i+i$ 的区间右端点（左端点为 $1$）。其中 $i$ 表示枚举的那个从 $0$ 开始的传送点。

当然，我们在二分的时候要注意去掉枚举的 $i$ 造成的影响，可以预先记录位置，特判即可，详见代码。

## Code:
```cpp
#include<bits/stdc++.h>
#define maxn 2900001
#define int long long
using namespace std;
int T,n,m,ans,a[maxn],s[maxn];
int check(int c,int x,int id){//二分最长的合法前缀区间
	int l=1,r=n,sum=-1;
	while(l<=r){
		int mid=l+r>>1;
		if(s[mid]-(mid>=id?x:0)<=c)
        	 sum=mid+(mid>=id?-1:0),l=mid+1;//不要忘记特判x的影响
		else r=mid-1;
	}
	return sum==-1?0:sum;//注意可能无解
}
signed main(){
	scanf("%lld",&T);
	while(T--){
		ans=0;
		map<int,int>mp;//记录位置
		scanf("%lld%lld",&n,&m);
		for(int i=1;i<=n;i++) scanf("%lld",&a[i]),s[i]=min(a[i]+(n-i+1),a[i]+i);//取最小花费
		sort(s+1,s+n+1);
		for(int i=1;i<=n;i++) mp[s[i]]=i,s[i]+=s[i-1];//前缀和
		for(int i=1;i<=n;i++){
			if(m-a[i]-i<0) continue;//可能不合法
			ans=max(ans,check(m-a[i]-i,min(a[i]+(n-i+1),a[i]+i),mp[min(a[i]+(n-i+1),a[i]+i)])+1);//注意要加上当前点i
		}
		printf("%lld\n",ans);
	}
	return 0;
}
```

欢迎评论区指出问题！