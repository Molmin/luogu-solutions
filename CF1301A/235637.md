

------------
本题题解分为两个部分:

一个是讲解思路和实现方式.

更有价值的是纠正部分人的坏习惯导致的“样例全过，提交全WA”

------------
一，思路与实现方式

题目要求：t组数据，每组3个字符串，a与b可以跟c相同位置可调换，最后判段调换后a,b是否完全相同。

手动模拟的话可以模拟而得，其实就是从c里面找有没有与a或者b相同的字符。
**如果C同一位置与b相同,就调换当前位置的a；如果C同一位置与a相同,就调换当前位置的b**（ _~~看不明白可以看下面的伪代码~~_ ），即：

```cpp
if(a[i]==c[i]) b[i]=c[i];

if(b[i]==c[i]) a[i]=c[i];
```
~~此段伪代码仅供理解题意~~

实际写代码的时候题目没有要求输出最后调换完的字符串，所以只需要判断当每一个位置都满足以上关系就输出“YES”，只要有一个不满足就输出“NO”。

------------

 
 _看到这，你就可以去自己写写尝试一下了_ 

------------
二，纠正习惯性错误

 _**如果你样例全过，但全一提交全WA了，然后又回来了，那么这篇题解的真正价值可能就实现了（~~虽然也可能不是我这里指出的错误~~）**_ 

当写循环判断的时候可能有些人习惯写从1开始循环到字符串长度末尾，即这种：	**for(int j=1;j<a.size();j++)** ~~这可能是很多人的习惯~~

但是是否有人还记得： _**字符串读入的时候是从0开始读入的**_ ，所以循环时应该从0开始，即：**for(int j=0;j<a.size();j++)**

（比较坑的是这个毒瘤样例没法打掉这个错误，你造的数据也可能默认第一位相同）

------------
然后给出简短的全代码：

```cpp
#include<iostream>
using namespace std;
string a,b,c;int k,t;
int main(){
	cin>>t;
	for(int i=1;i<=t;i++){
		cin>>a>>b>>c;
		for(int j=0;j<a.size();j++){
			if(a[j]==c[j]||b[j]==c[j]) continue;//满足条件直接跳过 
			k=1; //一个小标记 ，确认他是没满足条件 
			printf("NO\n");break;
		}
		if(k==0)printf("YES\n");k=0;//确认是否满足所有条件 +重置标记 
	}
}
```
谢谢观看（~~写题解不易，不喜勿喷~~）
