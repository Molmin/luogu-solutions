这题好水，甚至比 $C$ 要水......
## 思路
首先看到这个题目，根据 CF 系列题目一贯的风格，肯定是个小贪心，我们继续仔细阅读题目，发现这个 $k$ 很大，$n$ 却较小，这表明我们要分两种情况讨论，一种是 $k≥n$，还有一种就是 $k<n$。

$\bullet \ \ k≥n$：我们**首先可以花费 $n$ 步把所有的蘑菇都取完**，然后的 $k-n$ 步我们开始**捡单位时间内长出来的蘑菇**。在 $k$ 的时间内每个格子我们可以捡到 $k$ 个长出来的蘑菇，但是由于我们需要从序列一段移动到另一端，我们无法捡拾的蘑菇总和就是 $n+(n-1)+...+1$，本来可以捡到的蘑菇总和是 $n \times k$，减一减我们发现可以捡到 $(k-1)+(k-2)+...+(k-n)$，**等差数列**求个和就是 $\frac{(k-1+k-n) \times n}{2}$，再加上最初的总蘑菇数量。

$\bullet \ \ k<n$：首先我们要明确，如果我们当前位置在 $x$，我们是从 $x-1$ 移动而来的。我们有**三个选择**，一种是捡**自己长出来的**，有一个，一种是拾取 **$x-1$ 长出来的**，有两个，一种是**拾取 $x+1$ 的**，总共有 $y+t$ 个，其中 $y$ 表示原有数量，$y≥1$，$t$ 表示已用步数，$t≥1$，所以 $y+t≥2$。**综上所述，我们选取的区间是一个连续的，且长度为 $k$ 的，所以只要前缀和一下就好了。**

关于为什么要经过尽可能多的蘑菇，因为加入你在位置 $a$，你是从位置 $a-1$ 过来的。第一种情况是你再回到 $a-1$，那么你得到的蘑菇数是 $1$，第二种情况是你往前走，你得到的蘑菇数一定 $≥1$，所以我们肯定选第二种。注意到第二种情况就是**不走回头路**，经过**尽可能多的蘑菇**。
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long//要开 long long！
int const N=2e5+10; 
int s[N];
signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	int t;cin>>t;
	while (t--){
		int n,k;cin>>n>>k;
		for (int i=1;i<=n;i++){
			int x;cin>>x;
			s[i]=s[i-1]+x;//求前缀和
		}
		if (k>n){cout<<((k-1+k-n)*n/2)+s[n]<<'\n';continue;}//分类讨论
	    int ans=0;
		for (int i=k;i<=n;i++)
		    ans=max(ans,s[i]-s[i-k]+((k-1)*k/2));
		cout<<ans<<'\n';
	} 
	return 0;
}
```
