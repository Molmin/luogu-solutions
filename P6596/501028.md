蓝书讲的很清晰但不是很清晰，所以我只能勉强看懂。

在无向图中，不含割边的极大联通子图称为双连通分量。若把每个双联通分量看为节点，则所有双连通分量和割边构成一棵树的形状。如下图，每个框框是个双连通分量。

![](https://cdn.luogu.com.cn/upload/image_hosting/let5d21f.png)

于是设 $f_{i,j}$ 表示 $i$ 个节点构成的包含 $j$  条割边的无向连通图数量。先考虑 $j>0$ 的情况：

看下面这张图：

![](https://cdn.luogu.com.cn/upload/image_hosting/hxexkknu.png)

如果删除一个双连通分量，图就会变成若干个连通块（上图蓝圈圈出了的两个联通块），从每个连通块出发，有一条边连向删除的双连通分量。

于是可以枚举删除的双连通分量大小，假设为 $k$。然后以 $1$ 号节点为基准点，再从 $i-1$ 个点中选 $k-1$。点选完了，然后大小为 $k$ 的双连通分量有 $f_{k,0}$ 种形态，故方案数为 $f_{k,0}\times C_{i-1}^{k-1}$。

> - 思考为什么要设基准点（为什么不是直接在 $i$ 个点中选 $k$ 个）。这是计数 dp 中的一类思想。如果能围绕这个基准点能构造一个整体，且不重不漏，那么这么做就是对的。
>
>- 以 $1$ 号节点为基准点，删除其所在的双连通分量构造图的方式，肯定能构造出所有情况。每次删除的双连通分量是特定的，这样就不会重复。
>
>- ~~编不下去了，先鸽这~~。感性理解一下（或者画图思考一下）。

设 $g_{i,j,k}$ 表示 $i$ 个节点构成的，有 $j$ 个连通块的，有 $k$ 条割边的无向图数量。

先抛式子：

$f_{i,j}=\sum\limits_{k=1}^{i-1}(f_{k,0}\times C_{i-1}^{k-1}\times \sum\limits_{p=1}^{min(i-k,j)}g_{i-k,p,j-p}\times k^p)$。

>- 外面连通块数量 $p$ 是未知的，故需要枚举。最极限就是每个节点是一个连通块，故向 $i-k$ 取 $\min$。

>- 每个连通块向大小为 $k$ 的双连通分量连边，会产生 $p$ 条割边，所以 $g$ 里割边数量是 $j-p$。

>- 连的 $p$ 条割边每条都能连双连通分量里 $k$ 个点中任意一个，有 $k^p$ 种连法（魔法少女 XD 跟我在这吵了半小时，这里给个图理解。注意相同颜色的边其实是一条边，这里只是把连法全部画出来了）。

>![](https://cdn.luogu.com.cn/upload/image_hosting/dl37927q.png)

>- 先抛出一个问题，这里没有考虑每个连通块内部是哪个节点与双连通分量里的点连的。

对于 $j=0$ 的情况，设 $h_{i}$ 表示 $i$ 个节点的无向连通图数量，则状态转移方程为：

$f_{i,0}=h_{i}-\sum\limits_{j=1}^{i-1}f_{i,j}$。很好理解，不解释了。

>- 关于 $h_{i}$ 的求法，其实就是[这道题](http://poj.org/problem?id=1737)。

>- 用 $i$ 个节点构成的无向图数量减去非连通的无向图数量即可。

>- $h_{i}=2^{i\times (i-1)/2}-\sum\limits_{j=1}^{i=1}h_{j}\times C_{i-1}^{j-1}\times 2^{(i-j)\times (i-j-1)/2}$。

>- $i$ 个节点构成的无向图至多有 $i\times (i-1)/2$ 条边，每条可有可无，故有 $2^{i\times (i-1)/2}$ 种。

>- 一个非连通图可以由多个连通块组成。还是以 $1$ 号节点为基准枚举其所在的连通块大小为 $j$，类比上面分析双连通分量，共 $h_{j}\times C_{i-1}^{j-1}$ 种。

>- 剩下的 $i-j$ 个点构成任意无向图。

最后考虑 $g$ 的计算方法。

注意双连通分量我们已经以 $1$ 为基准了，这里便以编号最小的节点所在的连通块为基准。显然要枚举这个连通块的大小 $p$ 和割边数 $q$。构成这个连通块有 $f_{p,q}\times C_{i-1}^{p-1}$ 种。

回到刚刚抛出的问题，这个连通块里选一个节点与删除的双连通分量相连（算 $f$ 时未考虑到的，因为当时不知道具体每个连通块大小），共有 $p$ 种。

式子：

$g_{i,j,k}=\sum\limits_{p=1}^{i}\sum\limits_{q=0}^{k} f_{p,q}\times C_{i-1}^{p-1}\times p\times g_{i-p,j-1,k-q}$。

然后这道题就做完了。

关于顺序，先算出 $h$，再以 $i$ 为阶段，分别求解 $f$ 和 $g$。观察下标，可以发现这么做是对的。

初值：$g_{0,0,0}=1$，取模勤一点，不然会爆。

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;

const int N=51,M=N*(N-1)/2,P=1e9+7;
int n,m;
int C[N][N],f[N][M],g[N][N][M],h[N];

inline int qpow(int a,int b)
{
    int res=1;
    for(;b;b>>=1,a=1ll*a*a%P)
        if(b&1) res=1ll*res*a%P;
    return res;
}

int main()
{
    cin>>n>>m;
    for(int i=0;i<=n;i++)//注意要从 0 开始
    {
        C[i][0]=C[i][i]=1;
        for(int j=1;j<i;j++)
            C[i][j]=(C[i-1][j]+C[i-1][j-1])%P;
    }
    for(int i=1;i<=n;i++)
    {
        h[i]=qpow(2,i*(i-1)/2);
        for(int j=1;j<i;j++)
            h[i]=(h[i]-1ll*h[j]*C[i-1][j-1]%P*qpow(2,(i-j)*(i-j-1)/2)%P+P)%P;
    }
    g[0][0][0]=1;
    for(int i=1;i<=n;i++)
    {
        ll s1=0;
        for(int j=1;j<i;j++)
        {
            for(int k=1;k<i;k++)
            {
                int s2=0;
                for(int p=1;p<=min(i-k,j);p++)
                    s2=(s2+1ll*g[i-k][p][j-p]*qpow(k,p)%P)%P;
                f[i][j]=(f[i][j]+1ll*f[k][0]*C[i-1][k-1]%P*s2)%P;    
            }
            s1=(s1+f[i][j])%P;
        }
        f[i][0]=(h[i]-s1+P)%P;
        for(int j=1;j<=i;j++)
            for(int k=0;k<i;k++)
                for(int p=1;p<=i;p++)
                    for(int q=0;q<=k;q++)
                        g[i][j][k]=(g[i][j][k]+1ll*f[p][q]*C[i-1][p-1]%P*p%P*g[i-p][j-1][k-q])%P;
    }
    ll ans=0;
    for(int i=0;i<=min(n,m);i++) ans=(ans+f[n][i])%P;
    cout<<ans;
}
```
