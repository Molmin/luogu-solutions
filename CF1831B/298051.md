送分题吃了 $3$ 发罚时，难绷

不妨设数 $x$ 在 $a$ 和 $b$ 中的最长连续出现次数分别为 $f_x$ 和 $g_x$，那么在合并后的数组中最长连续出现次数为 $f_x+g_x$，证明如下。

不妨设两次连续出现分别为 $[L_a,R_a],[L_b,R_b]$，那么：

* 通过先取走 $a$ 的 $[1,L_a-1]$，$b$ 的 $[1,L_b-1]$，然后再以任意次序取走 $a$ 的 $[L_a,R_a]$ 和 $b$ 的 $[L_b,R_b]$ 就能构造出 $x$ 连续出现 $f_x+g_x$ 次的序列，即最大连续出现次数一定不小于 $f_x+g_x$。
* 假设最终数列中有 $x$ 连续出现大于 $f_x+g_x$ 次，那么由于这一段后显然一定由 $a$ 和 $b$ 中连续的元素 merge 而成，那么等于说 $a,b$ 中能各取出一段连续的 $x$ 使得长度和大于 $f_x+g_x$，与 $f_x,g_x$ 的定义矛盾，故 $x$ 的最大连续出现次数一定不大于 $f_x+g_x$。

综上所述，对于任意一个数 $x$ 都有其在所有合并方式中的最大连续长度为 $f_x+g_x$。

那么我们 $O(n)$ 扫一下 $a$ 和 $b$ 计算出 $f,g$ 然后依次更新即可，一些细节问题已在注释里说明。

代码：

```c++
#include <cstdio>
#define N 200010
//限制了ai,bi<=2n所以可以用数组
//值域开到 1e9 什么的就要离散化或者用 map 了
int n,a[N],b[N],f[2*N];
int max(int x,int y) {return x>y?x:y;}
void once()
{
    scanf("%d",&n); int ans=0;
    for(int i=1;i<=n;i++) scanf("%d",a+i);
    for(int i=1;i<=n;i++) scanf("%d",b+i);

    //多测不清零，爆零两行泪
    for(int i=1;i<=2*n;i++) f[i]=0;
    //利用越界值避免特判
    a[0]=b[0]=a[n+1]=b[n+1]=0;

    for(int i=1,run=0;i<=n+1;i++)
    {
        if(a[i]!=a[i-1])
        {
            f[a[i-1]]=max(f[a[i-1]],run);
            //可能有些 a 中出现的值 b 中不会出现但是还是最大结果
            //所以这里也要更新答案，我因为这个吃了三次罚时
            ans=max(ans,run);
            run=0;
        }
        run++;
    }

    for(int i=1,run=0;i<=n+1;i++)
    {
        if(b[i]!=b[i-1])
        {
            //注意这里的实现会导致用 x=0 更新答案，上面同理
            //本题中不会有问题但是其他题中可能会影响答案需要特判掉
            ans=max(ans,run+f[b[i-1]]);
            run=0;
        }
        run++;
    }
    printf("%d\n",ans);
}
int main()
{
    int t; scanf("%d",&t); while(t--) once();
}
```