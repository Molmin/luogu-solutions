**又是一道bfs的模板 ~~水~~ 题**
来吧，让我们一起分析这道题！


------------
### STEP 1 提炼题意

1.初始有1个1；

2.一次可以使用一个变化规则变成其它个数个1；

3.是否能变成n个1？如果能，**最少需要几步**？

看到上面粗体的条件没？啥也别说了，广搜~~没跑的~~！

~~因为这道题比较水，实际上是我懒得打了~~ 我们直接贴AC代码以及注释吧！相信你一定会看懂的！

------------
### STEP 2 介绍算法

**①什么是广搜？**

广搜，全名广度优先搜索，用来处理各种从起始点到终止点最少距离。

**②为什么要用广搜？**

广搜一般是用来处理地图的，但是在这道题里面，有起始点（1个1），有终止点（n个1），有行走方式（变化规则），需要求最短距离（最少所用的变化规则），所以，毋庸置疑，用广搜！

**③广搜比起深搜用什么优点？**

广搜是利用队列逐层搜索，而深搜是一条线路不撞南墙不回头地搜，搜到了才返回。

一般来说，广搜比较耗费空间（队列需要拉进去很多元素），深搜比较耗费时间（不但要回阙而且容易跑偏）。

而这道题里，因为要求最短路，而用广搜可以逐层搜索，不但节省时间，而且方便寻找，所以，这道题广搜比深搜好。


-------------
### STEP 3 AC代码&&完整注释
```
#include <bits/stdc++.h>//万能头文件
using namespace std;
int m,n,a[90001],b[90001],v[20000];
//分别记录如题的m,n，以及每个变化的第一个数和第二个数，还有记录每个数量的1是否走过的数组.
//刚开始我把300²看成300了……白提交了4次呜呜呜
struct node{
	int l,x;
};//结构体，记录每个点对应的个数以及变化次数
node ydn;//这个纯属没啥用（还是有那么一丁点的）
queue<node> q;//结构体队列
int main() {
	scanf("%d %d",&m,&n);
	for (int i=1;i<=m;i++){
		scanf("%d %d",&a[i],&b[i]);
	}//正常输入
	if (n==1){//因为后面是变化后判断，所以初始位置无法判断，要特判一下1
		printf("1\n");
		return 0;
	}
	ydn.l=1;ydn.x=1;//赋值起始点
	q.push(ydn); //放入起始点（看吧还是有用的）
	v[1]=1;//初始点以走过
	while (!q.empty()){
		node no=q.front();//提取队列第一项
		q.pop();//删除
		for (int i=1;i<=m;i++){//循环每一个变化规则
			if (no.x>=a[i]){//现有的1的数量要大于该变化规则至少需要的1的数量
				node noo;//新建一个结构体
				noo.l=no.l+1;
				noo.x=no.x-a[i]+b[i]; //放入下一个点的数据
				if (v[noo.x]==0&&noo.x<=n+300){//如果将要演变的点未走过且在范围内
					if (noo.x==n){//如果符合就输出（这就是为什么要特判1，因为轮不到1）
						printf("%d\n",noo.l);
						return 0;
					}
					v[noo.x]=1;//标记
					q.push(noo);//推入
				}
			}
			
		}
	}
	printf("-1\n");//循环完还没输出，那肯定无解
	return 0;//好习惯++
}
```


------------
### STEP 4 完结撒花！

本篇题解就这么完美地结束了！如果还有什么不懂的问题，欢迎在评论区问我哦，我会第一时间回复的。

如果全部听懂了，就点个赞纪念一下你的成长吧！