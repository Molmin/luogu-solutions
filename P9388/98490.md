什么几把破题，赛时很快就会了，没时间写，赛后写了好久，然后卡常卡一年。

这个题和 [回转寿司](https://loj.ac/p/2736) 比较像，但是修改是全局的，而且数据范围也没办法分块。

用类似的思路，因为观察到一个修改操作经过一个区间，对于区间和的影响就是把这个数放进来，然后把最小值扔掉，然后可以发现操作顺序无影响，因此可以把操作放到一个堆里，然后和区间里的数合并。

然后考虑一个询问是咋操作的，相当于是 $[1,l-1]$ 这个区间里的数和堆里的数去合并，去除前（询问个数）个元素，然后再和 $[l,r]$ 去合并，选出 $r-l+1$ 个最大的数，这就是答案。

具体咋维护呢，就是直接主席树上二分得到最后答案的数的区间然后加起来即可，然后询问的堆用一个权值线段树去维护。

一开始写的是二分然后再询问，复杂度 $O(n\log^2 n)$，结果一个点跑了 $20$ 秒。

换成主席树上直接二分，复杂度 $O(n\log n)$，然后跑了 $7$ 秒，因为线段树询问次数较多，常数比较大。

卡常半天，当天在 [loj 上过了](https://loj.ac/s/1789638)，但是这个代码跑得非常惊险，而且不用快读过不去，洛谷上无法通过。

今天又来卡常，终于在洛谷上过了，[code](https://loj.ac/s/1814470)，甚至跑得比 loj 上快。

卡常小技巧：

```cpp
void Ad(seg, int x, int z) {//AC
  s[p] += z, sum[p] += 1ll * x * z;
  if (l == r) return;
  x <= mid ? Ad(lid, x, z) : Ad(rid, x, z);
}

void Ad(seg, int x, int z) {//TLE
  if (l == r) {
    s[p] += z, sum[p] += 1ll * l * z;
    return;
  }
  x <= mid ? Ad(lid, x, z) : Ad(rid, x, z);
  s[p] = s[ls[p]] + s[rs[p]], sum[p] = sum[ls[p]] + sum[rs[p]];
}
```

这就是个普通的线段树单点修改操作，上面的是在递归的过程中直接修改，下面的是修改叶子然后 up 上来。

loj 上，每个点快 0.1s，洛谷上，每个点快 0.5s+。

不懂了啊，反正过了。