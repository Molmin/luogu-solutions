这是一个来自真·萌新做本题的思路与过程，也是我的第一篇题解

刚开始像无头苍蝇一样想了二三十分钟，最后画起了01背包的图...
就在对比着第i 个公司与第 i-1 个公司的分配时，突然想到了状态转移方程：

把已扫过的公司看作一个整体=f[1][x];
把当前公司看作待加入的整体=f[2][x];
当分配i台机器时(i=1->m);

**f[1][i]=max{f[1][i]+f[2][0],f[1][i-1]+f[2][1],...,f[1][0]+f[2][i]};**

解释：在第 i 个公司分配 j 个机器时，她有如下的选择：
{一个也不要，从之前公司中抢一个，从之前公司中抢两个，……全都要（j个）}

而f[1][0],f[1][1],……f[1][j]分别为：
{前 (i-1) 个公司没有机器时的最大利益，前 (i-1) 个公司有一个机器时的最大利益，前 (i-1) 个公司有两个机器时的最大利益，……前 (i-1) 个公司有 j 个机器时的最大利益}

决策就是从这之中做出选择，而决策的标准就是“谁最大”，即max{}。
决策过后，我们能获得前 i 个公司获得 j (j=1->m) 个机器时的最大利益。
于是整个问题就可以通过递推（应该是这么说的吧）解决了。

这时我还没有意识到第二问（求各个公司各获得了多少机器），但已经想到了把数组压缩一维（因为我还想着01背包），再看转移方程：

f[1][i]=max{f[1][i]+f[2][0],f[1][i-1]+f[2][1],...,f[1][0]+f[2][i]};
在 i=1->m 中我们需要用到的之前的状态范围为 0->i，也就是说，这个过程不需要 i 以后的数据，所以可以用从后向前推的方式压缩掉一维，状态转移方程变为：

**f[i]=max{f[0]+w[i],f[1]+w[i-1],……，f[i]+w[0]}**

其中i 从m到0，w数组代指当前公司获得 k 台机器时的回报。

然后打完了，提交，发现还有第二问……

解第二问的思路：字符串 c[i][j] 。一个字符串对应一个f[i]。
使用memset初始化字符串为 ’0’ 后，字符串内部应该是这样的：

c={“0000000000000000”,”0000000000000000”,……}
每个字符串（从第0位开始）第 i 位的数字即为该条件下第 i 个公司的机器数。
如：c[1][2]=’1’ 即表示分配1个机器时第2个公司获得了1个机器。

然而写题解时发现一个问题，如果一个公司获得的机器多于9个呢，岂不是直接爆了？然而我ac了，正想嘲笑数据太弱时，看了一眼我的输出：
printf("%d %d\n",i,c[m][i]-48);

原来我一直把char类型当数字用了，换句话说，这个c用int也可以。所以那个“+-48”就毫无必要了？
有必要，因为在char类型中0是’\0’，strncpy函数就用不了了。
然而由于重构成int 类型成本比较高，可能要开三维数组或是加入其他运算（好吧其实是我懒），所以这样用就行了，反正0~15的机器数量怎么也爆不了，反而可能会快些？

看了看大神们的代码，发现我还是要好好多学习学习啊。

下面是我的完整代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int m,n;
int a[11][16];		//存放数据 
int f[16];		//用来第一问的推导 
char c[16][16];		//16个字符串对应f[16];
//"000000...","010250..." 方便输出但不方便理解 
int main()
{
	memset(c,48,sizeof(c));			//把c变成"00000000000..."; 
	scanf("%d%d",&n,&m);
	for(int i=1;i<n+1;i++)
	{
		for(int j=1;j<m+1;j++)
		{
			scanf("%d",&a[i][j]);
		}
	}
	//万一设备多了收益反而降了呢？
	//想起了做了无数遍的一元二次方程题...
	int xyem=0,itp=0;			
	for(int i=1;i<m+1;i++)		
	{
		if(a[1][i]>xyem)
		{
			f[i]=a[1][i];
			c[i][1]=i+48;
			xyem=a[1][i];
			itp=i;
		}
		else
		{
			f[i]=xyem;
			c[i][1]=itp+48;
		}
	}
	for(int i=2;i<n+1;i++)
	{
		for(int j=m;j>0;j--)
		{
			//f[j]初始状态为f[j]+a[0](a[0]显然为零),
			//所以k不需要=j就可以包括转移方程中的所有情况; 
			for(int k=0;k<j;k++)
			{
				//小于就可以保证字典序最小了
				if(f[j]<f[k]+a[i][j-k])
				{
					f[j]=f[k]+a[i][j-k];
					strncpy(c[j],c[k],m+1);
					c[j][i]=c[j][i]+j-k;
				}
			}
		}
	}
	//以下是输出 
	printf("%d\n",f[m]);		 
	for(int i=1;i<n+1;i++)		
	{
		printf("%d %d\n",i,c[m][i]-48);
	}
	return 0;
}
```

