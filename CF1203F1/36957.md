$\rm Difficulty = \color{orange}2100$

我们发现当 $b_i\ge 0$ 与 $b_i<0$ 情况不同，考虑分类讨论：

一个显然的观察得出，如果我们做任务 $x,y$，那么无论以什么顺序完成这些任务，即不论 $(x,y)$ 和 $(y,x)$，是没有对后面其他任务产生影响的。**于是我们只用关心相邻两个任务的顺序问题。**

注意到如果我们无论如何安排 $x,y$ 两个任务的顺序都只能完成其中的 $1$ 个或者 $0$ 个任务了，那么对于顺序的考虑是没有意义的。

也就是说，如果我们无论怎么调节这两个的任务的被考虑顺序，都不能找到一种两个任务都被完成的方案，那么这两个任务的被考虑的顺序是无关的。

说的通俗一些，只完成一个任务（或者不完成任务）硬着头皮完成它就行了，考虑个鬼的顺序！

于是我们思考两个任务都被完成的情况。

**显然我们先做 $b_i\ge0$ 的任务。**

**当 $b_i\ge0$ 的时候，我们对 $a_i$ 从小到大排序，然后依次考虑，如果能做就一定做。**

我们来简单说明以上结论的正确性。

注意到一个关键性质，就是说完成更多的 $b_i\ge 0$ 的问题，只会让评分上升（或保持不变），一定不会让评分下降，因此

+ 原先完成不了的任务，完成了一些其它任务之后回过头来继续完成这个任务，有可能还是完成不了，也有可能可以完成了。

+ 原先可以完成的任务，完成了一些其它任务之后回过头来继续完成这个任务，一定还可以完成。

对于一对完成顺序是相邻的两个任务 $x,y$，不妨设 $a_x\le a_y$。

我们考虑交换 $x,y$，则 $y$ 被先做。

如果原先的评分不足，是不可以完成 $y$ 的，而我们有可能通过先完成 $x$ 上涨评分后完成 $y$。这样就多完成任务 $y$。

如果原先评分连 $x$ 都不能完成，那么 $y$ 更不能完成了，评分的上涨一定是 $0$。

**当 $b_i<0$ 的时候，我们对 $a_i+b_i$ 从大到小排序，然后依次考虑。用动态规划解决问题。**

我们来简单说明以上结论的正确性。

注意到一个关键性质，就是说完成更多的 $b_i<0$ 的问题，只会让评分下降，一定不会让评分上升（或不变），因此

+ 原先完成不了的任务，完成了一些其它任务之后回过头来继续完成这个任务，还是完成不了。

+ 原先可以完成的任务，完成了一些其它任务之后回过头来继续完成这个任务，有可能还可以完成，也有可能完成不了了。

对于一对完成顺序是相邻的两个任务 $x,y$，不妨设 $a_x\ge a_y$。

最初的时候，评分一定要 $\ge a_x$，否则一定不能把两个任务都完成，也就失去了寻找他们被考虑顺序的意义。

所以，我们只需要想考虑这两个任务之前，评分 $\ge a_x$ 的情况。

因为评分 $\ge a_x$，所以也一定 $\ge a_y$ 所以我们无论先完成哪一个任务都是可以的，唯一只需要考虑在完成了第一个任务以后，另外一个任务是否可以完成。

记考虑这两个任务之前，评分为 $r$。

如果我们先完成任务 $x$，那么我们要保证 $r+b_x\ge a_y$ 才能再完成任务 $y$。

如果我们先完成任务 $y$，那么我们要保证 $r+b_y\ge a_x$ 才能再完成任务 $x$。

由于我们要完成更多的任务，于是要考虑更松的下界。

先完成 $x$，要求 $r\ge a_y-b_x$。

先完成 $y$，要求 $r\ge a_x-b_y$。

所以我们比较 $a_y+b_x$ 与 $a_x+b_y$ 的大小关系，来得出考虑 $x$ 与 $y$ 的先后顺序。

移项，可以知道当 $a_x+b_x>a_y+b_y$ 的时候，先完成 $x$ 更优秀；当 $a_x+b_x<a_y+b_y$ 的时候，先完成 $y$ 更优秀。如果 $a_x+b_x=a_y+b_y$, 那么先完成谁都可以。

这样，我们解决了任务的考虑顺序这一问题。

对于 $b_i\ge 0$，我们显然是能完成更多任务就完成更多。

对于 $b_i<0$，我们则需要使用动态规划，因为有些先被考虑的任务，可能因为 $b_i$ 太小，对评分的扣减太多，而不去完成。

如何做这个动态规划呢？

我们记 $dp_{i,j}$ 为考虑完评分为 $i$ 的任务后，当前评分为 $j$ 的最多完成多少个任务。

$dp_{i,j}$ 从哪里转移过来呢？我们只需要考虑完成 $i$ 号任务和不完成 $i$ 好任务就行了两种情况就行了。

记考虑完 $b_i\ge 0$ 的任务后积累的评分为 $r$，总共完成了 $k$ 个任务。

完成 $i$ 号任务，则完成任务前原先的评分 $j'$ 为 $j-b_i$。一定要满足 $a_i\le j'\le r$。

不完成 $i$ 号任务，则完成任务前原先的评分 $j'$ 为 $j$。$j'$ 不需要满足额外的额外的条件。

在满足条件的情况下，$dp_{i,j}=\max{dp_{i-1,j'}+1}$。

初始条件如果 $x=r$ 那么 $dp_{0,x}=k$，否则 $dp_{0,x}=0$。

完成任务的总数目 $s$，就是 $\max\limits_{x=0}^{r}dp_{n,r}$，这是因为最后剩余的评分只要大于 $0$ 一定是可以的，当然它也不可能 $>r$。

当 $s=n$ 的时候，我们可以完成所有问题，否则不可以。

于是我们就解决了这个问题。

代码如下：

```cpp
#include<cstdio>
#include<cstdlib>
#include<utility>
#include<algorithm> 
int n,r,m,cnt,dp[105][100005],ans=0;
std::pair<int,int> p[105],s[105];
int cmp(std::pair<int,int> a,std::pair<int,int> b){return a.first+a.second>b.first+b.second;} 
int main()
{
	scanf("%d%d",&n,&r);
	for (int i=1;i<=n;i++)
	{
		int x,y;
		scanf("%d%d",&x,&y);
		if (y>=0) p[++m]=std::make_pair(x,y);
		else s[++cnt]=std::make_pair(x,y);
	}
	std::sort(p+1,p+m+1);
	std::sort(s+1,s+cnt+1,cmp);
	for (int i=1;i<=m;i++) if (r>=p[i].first) r=r+p[i].second,++ans;
	for (int i=0;i<=cnt;i++) for (int j=0;j<=r;j++) dp[i][j]=-1000000000;
	dp[0][r]=ans;
	for (int i=1;i<=cnt;i++)
		for (int j=0;j<=r;j++)
		{
			dp[i][j]=dp[i-1][j];
			if (j>=s[i].first+s[i].second&&r+s[i].second>=j) dp[i][j]=std::max(dp[i][j],dp[i-1][j-s[i].second]+1);
		}
	ans=0;
	for (int x=0;x<=r;x++) ans=std::max(ans,dp[cnt][x]);
//	printf("%d\n",ans);
	ans==n?puts("YES"):puts("NO");
	return 0;
}
```

时间 $\tt 90ms$ 内存 $\tt 40.04MB$ 代码长度 $\tt 971B$ 