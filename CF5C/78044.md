这是一道动态规划题

---

首先`)`肯定匹配最近的没有匹配的`(`，不然一定出现没有匹配的或者交替匹配的。


可以把`(`入栈，遇到`)`出栈，而两个`()`之间的括号序列一定是匹配的。


于是可以把`(`的**位置**入栈，出栈时计算即可知道当前括号序列的长度。


但题意里表明了除了`(...)`，`(...)(...)`也是合法的括号序列。


于是设ans数组管理**到目前位置的合法括号序列长度**，每次出栈时更新相应位置的值，使用了动态规划的思想。


最后输出的答案1即是ans数组里的最大值，答案2即是答案1在ans数组里出现的次数。


答案1的计算可以在遍历字符串时计算，也可以在遍历字符串之后计算。


```cpp
#include<cstdio>
#include<cstring>
int sta[1000001],head,ans[1000001];
    //sta数组是栈，存储'('的位置。
    //ans[i]代表遍历到s[i]时的合法括号序列长度
char s[1000001];
int main() {
    int ans1=0,ans2=1;    //最大子串长度，最大子串个数(初值应为1)
    scanf("%s",s);
    for(int i=0;s[i];++i) {
        if(s[i]==')') {    //准备出栈
            if(!head)        //栈为空，无栈可出
                continue;
            head--;            //出栈
            ans[i]=i-sta[head]+1+ans[sta[head]-1];    //更新值
            if(ans1==ans[i])
                ans2++;
            //如果答案1等于ans[i]，更新答案2
            else if(ans1<ans[i]) {
                ans1=ans[i];
                ans2=1;
            }
            //如果答案1小于ans[i]，更新答案1，重置答案2为1(初值)
        }
        else
            sta[head++]=i;    //入栈
    }
    printf("%d %d",ans1,ans2);
    return 0;
}
```

---