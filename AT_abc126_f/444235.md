## Part 1 : 样例分析

其实这道题并没有看起来那么难，只是样例给得很特殊而已。

比如说下面这组样例：

```
Input：
3 4

Output
0 1 2 3 5 6 7 4 7 6 5 3 2 1 0 4
```

看起来很有规律是不是？

只是把 $0\sim2^m-1$ 的每一个非 $k$ 的数正序输出，然后输出 $k$，再倒序输出一遍非 $k$ 的数，最后输出 $k$。

但是，为什么要这么做？

## Part 2 ：题目分析

结果等于```-1```是很好判断的，由于异或运算的结果必定小于等于进行计算的两个数
，所以 $k$ 必定小于等于整个序列中的任何一个数。
```cpp
if(k>pow(2,m)-1){
    printf("-1");
    return 0;
}
```


------------


首先要明确一点，对于下面这样的一个序列，按位异或后的结果必定为 $1$。

```
0 1 2 3 3 2 1 0
```
因为众所周知，异或 ( xor ) 运算是具有结合性的。

拿上面这个序列来说，就是把

```
0 xor 1 xor 2 xor 3 xor 3 xor 2 xor 1 xor 0
```

分为了

```
0 xor 1 xor 2 xor 3
```
和
```
3 xor 2 xor 1 xor 0
```
因为已知异或是具有交换性的，所以前半段的结果必定等于后半段的结果，那么最终的结果就一定等于 $0$。

更多关于异或的内容可以参见[这里](https://www.ruanyifeng.com/blog/2021/01/_xor.html)。


------------

明确了这一点，要完成这道题目就比较容易了。

现在我们做到了让两个相同的数构成的子序列按位异或结果为 $0$，那么怎么使它为 $k$ 呢？

先分析一个实例:

```
2 3 4 4 3 2
```
这样它的异或结果为 $0$，是因为 $a\oplus a=0$。

如果我们尝试将这个序列分割一下，就会变成

```
(2 3 4) (4 3 2)
```
如果令 ```(2 3 4)``` 为 $A$，那么这个序列按位异或就可以写成

```
A xor A (异或的交换性)
```
上面这个式子等于零，如果要让它等于 $k$,就需要让它变成

```
A xor A xor k
```
因为 $a\oplus 0=a$。

所以再把这个式子还原，就可以写成

```
2 3 4 k 4 3 2
```
就成了 Part 1 部分的样例那样了。



------------
接着就只剩下了 $k$ 的子序列了。

我们接着分析实例：

如果 $m=2$，$k=2$，则结果应该为

```
0 1 3 2 3 1 0 2
```
单独把 $k$ 抓出来，就是

```
2 3 1 0 2
```
把这个序列整理一下，就可以变成

```
0 1 2 3 2
```
经过尝试可以发现，$0\sim2^m-1$ 中的左右数按位异或的值为 $0$。

所以这个序列就成了

```
0 2
```
又因为 $a\oplus 0=a$，所以这个序列的最终结果就是 $2\oplus 0=2$，也就是 $k$。

## Part 3 : 代码

当我做完后，我才发现，其实样例竟然是一个特殊情况？！

所以需要特判。

```cpp
#include<iostream>
#include<stdio.h>
#include<algorithm>
#include<string.h>
#include<math.h>
using namespace std;
int main(){
	int m,k;
	scanf("%d %d",&m,&k);
	if(m==1){ //特判 
		if(k==0) printf("0 0 1 1");
		else printf("-1");
		return 0;
	}
	if(k>=pow(2,m)){
		printf("-1");
		return 0;
	}
	for(int i=0;i<pow(2,m);i++){ //正序 
		if(i==k) continue; //不输出k 
		printf("%d ",i);
	}
	printf("%d ",k);
	for(int i=pow(2,m)-1;i>=0;i--){ //倒序 
		if(i==k) continue; //不输出k 
		printf("%d ",i);
	}
	printf("%d ",k);
	return 0;
}
```
