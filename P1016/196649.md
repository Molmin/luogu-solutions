## 我承认以下是Dalao的思路
### 但是，为了总结经验，我决定把这篇题解写出来
这个题目考的就是贪心吧，貌似没有其他的什么了 ~~（除了队列操作？）~~

贪心思路：

1. 经过当前加油站，加满油可以到下下站，那么这一站和下下站中间的那一站可以舍去，本站入队；
1. 如果即使在本站加满油，也无法到达下下站，那么我们一定要经过下一站，在此时分情况取最优解；
1. 如果有一站即使加满了油也无法到达下一站，那就是无解；

以上是预处理；

4. 预处理完成后，我们舍掉了一部分加油站，我们用队列存储了可以“直达”的加油站，现在剩下两种情况：

**第一种：“下一站”的油更贵；**

**第二种：“下一站”油更便宜；**

- 如果下一站更贵，那我们就在当前站加满，并记录油箱到了下一站之后还剩多少油，然后我们更新当前的指针到下一站，这样我们就“抵达”下一站了；

- 如果下一站的油更便宜，我们在本站加的就越少越好，那么，如果油箱里省的油够我们跑到下一站，我们就把要用的油减掉,当前位置指针转向下一站，我们就“抵达”下一站了；否则，油箱里的油不够我们走到下一站，那就不得不加油，我们只要加的刚刚好就行，所以剩下的油就是0，位置指针移动，“抵达下一站”。

当然，加了多少油就要加相应的钱数，这个不用解释了；

所以以上就是本题的解题思路

完整代码：

```cpp
//认真看，杜绝抄袭 
#include<cstdio>
#include<queue>
using namespace std;
struct travel{
	double distance,pay;
}k[10];
//distance表示距离，pay表示花费 
double d1,c,d2,left,ans;
int n,temp=0,now=0;//temp  now用途往下看； 
queue<int> q;
int main()
{
	scanf("%lf %lf %lf %lf %d",&d1,&c,&d2,&k[0].pay,&n);
	//第一次输入的油价花费是起点的油价， 直接存入 
	for(int i=1;i<=n;i++)
	{
		scanf("%lf %lf",&k[i].distance,&k[i].pay);
	}
	k[0].distance=0;
	k[n+1].distance=d1;//到达终点的距离 
	k[n+1].pay=0x3f3f3f3f;
	//看下面代码就知道了，这边必须枚举到n+1，否则第n个加油站可能要经过却没有被存入 
	//所以到 n+1(即终点) 虽然不用加油，但终点的油价也要赋一个最大值，避免误判和死循环，后面计算时恢复成0 
	
	for(int i=1;i<=n+1;i++)
	{
		if(k[i].distance-k[i-1].distance>c*d2)//加满油都到不了，无解 
		{
			printf("No Solution");
			return 0; 
		}
		else if(k[i].distance-k[temp].distance<=c*d2 && k[i].pay<k[temp].pay)
		//这里的temp指针指向本站，而i却会指向下下站，仔细思考下为什么？ 
		{
			q.push(i);
			temp=i;//更新本站位置； 
		}
		else if(k[i].distance-k[temp].distance>c*d2)//如上，没办法到下下站，或者是下下站比这站更贵(贪心) 
		{
			q.push(i-1);//那么这站是要取的，进 
			temp=i-1;//指针移动到下一站； 
			i--;
			//保证i指针不是指向下下站，而是指向下一站
			//(每次循环i都会自加1，导致进入下下站，这样就可以抵消了) 
		}
		//解答上面的疑问：
		//如果上面的3个if都没有执行，那指针就指向下下站了； 
	}
	q.push(n+1);k[n+1].pay=0;
	//最后终点也要到达，n+1也算一站，进；同时恢复到终点的油价为0，避免出错； 
	while(!q.empty())
	{
		int x=q.front();q.pop();//出发去“下一站”，“下一站”出队
		//贪心过程： 
		if(k[x].pay>k[now].pay) //“下一站”更便宜 
		{
			ans+=c*k[now].pay;//钱记得加，油不是免费的~ (下同)
			left=c-(k[x].distance-k[now].distance)/d2;
		}
		else //否则就要讨论 
		{
			double need=(k[x].distance-k[now].distance)/d2;
			if(left>=need)//剩下的油够，那么不用加油 
			{
				left-=need;
			}
			else//剩下的油不够，那么还要加油，加到刚好能到下一站就行 
			{
				ans+=(need-left)*k[now].pay;//同上，油钱加上 
				left=0;
			}
		}
		now=x;//“抵达”下一站 
	}
	printf("%.2lf",ans);//保留两位小数 
	return 0;
} 
```

这次就是总结经验吧~（以及表示对Dalao的膜拜）
