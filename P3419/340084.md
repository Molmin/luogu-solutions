# 题目
[题目链接](https://www.luogu.com.cn/problem/SP688)

# 分析
这个题的主要思路就是贪心，具体思路楼下说的应该挺清楚了，这里再进行一番具体的分析（~~魔改~~）

### 思路
题意是我们要求出来最小的步数能让$Jasio$把所有想玩的玩完。那么我们就可以跟~~饿狼~~一样贪了。

考虑一下，假如说地上不足$k$个物品并且当前地上没有$Jasio$想要玩的玩具，那么肯定就直接取下来就行。

假如地上已经满足了$k$个东西了，那么这时候是需要放回一个物品，所以放回哪个物品就是这个题的关键。

因为地上的东西已经有$k$个了，而从当前向后可能还会有要玩某个玩具的需求，那么我们就可以找出当前地上所有东西之中，下一次玩最靠后的那个玩具拿走就行，而这个下一次玩最靠后的玩具可以用大根堆来进行维护，在前边反着枚举预处理。

因为大根堆（优先队列）无法进行单独的删除操作，每次只能把堆顶取出，但是如果之前入过队的，但是和当前需要入队的玩具是同种，那么直接取出是不行的，但是当前这个玩具的下一次玩肯定是比上一个要靠后，那么我们就可以把$k++$，让上一个这种玩具永远保留在里边，为了记录这个玩具出队，我们可以使用一个$vis$数组，每次堆中元素个数等于$k$了，就让堆顶元素的$vis$清空，然后弹出堆顶，然后统计答案并将当前要玩的东西加入队列即可。

# 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn = 1e5+10;
const int maxm = 5e5+10;
int jl[maxm],a[maxm];
int vis[maxn],pos[maxn];
priority_queue<pair<int,int> >q;//按pair第一个元素大根堆排序
int main(){
	int n,k,p;
	scanf("%d%d%d",&n,&k,&p);
	for(int i=1;i<=p;++i){
		scanf("%d",&a[i]);
	}
	for(int i=p;i>=1;--i){//反着枚举
		if(!pos[a[i]])jl[i] = 0x3f3f3f3f;//后边不出现了就极大值，不影响
		else jl[i] = pos[a[i]];//记录下一次当前玩具出现的时候
		pos[a[i]] = i;//记录出现位置
	}
	int ans = 0;
	for(int i=1;i<=p;++i){
		if(vis[a[i]]){//如果之前取过但是没出队，就保留着
			k++;//保留了一个就让限制++
			q.push(make_pair(jl[i],a[i]));//入队
		}
		else{
			if(q.size() == k){//地上放不下了，就出队
				vis[q.top().second] = 0;//出队了说明没取，vis数组清除
				q.pop();
			}
			ans++;//答案++
			q.push(make_pair(jl[i],a[i]));//入队
			vis[a[i]] = 1;//记录当前玩具入队了
		}
	}
	printf("%d\n",ans);
}

```