非常巧妙的一道题目。

首先考虑easy version，发现我们每次询问都是对于一个**合法的括号序列**来进行操作。

那么我们可以建立出括号树，**注意有些部分的括号并不合法，需要去除掉**。

对于一次询问，我们考虑一个括号区间所在的位置一定是树上点 $u$ 所在子树儿子的一个连续段（如果我们按照从左到右的顺序从小到大安排对应的括号的情况下）。

那么我们先DP出一个子树的贡献和，这部分是很简单的。

然后对于每个点维护一个树状数组维护他的儿子的贡献和。

每次对于一个询问 $[l,r]$ ，我们先定位，然后找出他们的父亲，在父亲的对应儿子的`vector`上二分出这两个点对应的编号，然后差分一下就行了。

复杂度 $O((n+q)\log n)$ 。

当然，对于easy version，前缀和即可。

现在想来其实不用二分，只有对每一个点 $u$ 维护一个标号，表示他在父亲的儿子中的编号即可。

这样复杂度 $O(n+q)$ 。

对于hard version，每次删除一个叶子结点。

显然他不仅会对他的父亲有贡献（删去这个点的贡献），而且还会对整条链产生影响，我们额外再用一个树状数组维护即可（**链加单点查可以做到**  $O(n\log n)$）。

这样复杂度就是 $O((n+q)\log n)$ 。

在打的时候，我把二分的上界写错了，然后一直调不出来。

我好想不太会官方题解中的 $O((n+q)\sqrt n)$ 的做法。

bouns：如果删除的是一对匹配的括号对，而不是中间全空的括号对怎么做？