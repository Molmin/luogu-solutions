首先上[链接](https://www.luogu.com.cn/problem/P4573)

然后开始讲题

**注意：为了数学上的方便~~及省空间~~，整篇题解中所有数字（包括数独里的）均以 $0$ 开始计数。牢记！**
# 算法分析
在被[靶型数独](https://www.luogu.com.cn/problem/P1074)数独搞自闭后再来做这道题时被吓一跳。

冷静思考一下，发现靶型数独多给的是计分方式，而这题多出来的是约束条件。

（什么？靶型数独还给了你已知数？给了 $24$ 个已知数不还是把我卡到自闭……）

所以这题完全可以从上到下，从左到右依次枚举。

（好像讨论区有 $hack$ ？没加到 $lougu$ 数据里来不管了）

最终我们的策略是 $dfs$，每次 $dfs$ 枚举到 $x$ 行 $y$ 列，$dfs$ 开头时 `y++` ，若 $y$ 为 $9$ 了则换行，若 $x$ 也为 $9$ 了则输出答案。

当然也不能无脑枚举完后再判断解是否合法。我们应在枚举时就剪掉一些不合法的枝。

好的下面是伪代码：
```
void dfs(int x,int y)
{
	if(y==9){
		x++;
		if(x==9){
			for(int i=0;i<9;++i){
				for(int j=0;j<9;++j){
					putchar(ans[i][j]+'1');
					putchar(' ');
				}
				putchar('\n');
			}
			fla=1;//fla用于出解时及时退出
			return;
		}
		y=0;
	}
	for(int i=0;i<9&&!fla;++i){
		if(/*$1*/){
			//$2
			dfs(x,y+1);
			//$3
		}
	}
} 
```
`$` 的部分是用来判断合法性的，也是这篇题解的重点。
# 读入数据
由于我比较蒻所以我就把输入不做任何位置上的处理就放进了一个叫 $mor$ 的二维数组。

至于数值上的处理还是有的，只是把 '<' 和 'v' 换成 $0$，'>' 和 '^' 换成 $1$。

不过这里还要推一下第 $i$ 行的列数为 `((i%5)&1)*3+6`。

大致思路是：我们发现每行字符数其实是以 $6$ $9$ $6$ $9$ $6$ 每 $5$ 个数循环一次的，故有了 `i%5`。而这个循环节又是 $6$ $9$ 交替的，所以用 `&1` 取 `i%5` 的奇偶性，$0$ 为偶 $1$ 为奇。最后 `*3+6` 把 $0$ 和 $1$ 映射到 $6$ 和 $9$。

为什么会循环我待会讲。为什么是 $6$ 和 $9$ 呢？因为每行不是上下大于号（'^'、'v'）就是左右大于号（'<'、'>'），上下大于号每行 $9$ 个，左右大于号每行 $6$ 个。

放代码：
```
char c;
for(int i=0;i<15;++i){
	for(int j=0;j<((i%5)&1)*3+6;++j){
		do{
			c=getchar();
		}while(c!='<'&&c!='>'&&c!='^'&&c!='v');
		mor[i][j]=(c=='>'||c=='v');
	}
}
```
# 合法性判断
首先是常规的数独的部分，只要开个桶记录一下就行了。

注意九宫格的编号可以为 `x/3*3+y/3`，至于为什么可以类比三进制推导。

这下我们就可以得出 `$2` 和 `$3` 怎么写了：
```
$2:col[x][i]=row[y][i]=squ[x/3*3+y/3][ans[x][y]=i]=1;
$3:col[x][i]=row[y][i]=squ[x/3*3+y/3][ans[x][y]=i]=0;
```
$col$ 记录行，$row$ 记录列，$squ$ 记录九宫格，$ans$ 记录答案。

同时还可以得出 `$1` 的前半部分怎么写：
```
$1.1:!col[x][i]&&!row[y][i]&&!squ[x/3*3+y/3][i]
```
所以后半部分呢？
***
我们发现题目中给的条件还没用呢。

那我们怎么用呢？

我们到一个单元格，可以先判断它与它的上下左右单元格大小关系是否合法再填进去。

然而我们发现，用我们刚才看似无脑的枚举顺序，正好可以保证当前单元格的右边和下面为空（没有枚举过）！

也就是说我们完全可以只判断是否与上面的和左边的单元格的大小关系是否合法。

那最重要的是找到上面的符号和左边的符号的坐标。相邻的单元格的坐标就只需加减横纵坐标了。

我们一个一个来。
***
找上面的符号。

然而我们发现在 $x%3==0$ 时压根没上面的符号……

不等于呢？

观察可得符号的列数（在`mor`中，下同）就是当前单元格的行数。

符号的行数就麻烦一些。

我们发现其实在九宫格边界都没有符号。

那么整个数独就会被横向的九宫格节分成 $3$ 行。

每行九宫格的字符分布情况也基本是复制粘贴。

这就解释了上面每行的字符数为什么会循环。

并且也可以应用在此时此刻。

我们同样可以将单元格行数 `x%3` 再处理。

不过是求坐标。

所以还要加上 `x/3*5` 来补上被我们忽略过的数（分割后每块有 $5$ 行字符）。

故 `$1` 的下半部分的上半部分也出来了。
```
$1.2.1:&&(!(x%3)||(mor[x/3*5+x%3*2-1][y]^ans[x-1][y]<i))
```
我这里用了个异或运算符，你们可以手玩一下。而 `*2-1` 就是对模出来的数的处理。这个式子可以观察得出也可以自己手推。
***
~~胜利就在眼前了，同志们坚持住！~~

接下来我们来推左边的运算符的坐标。

同理可得在 $y%3==0$ 时没有左边的符号。

同时还很容易发现左边的运算符的行数就是上面的运算符的行数加 $1$。

所以这次麻烦在列数，因为这次的列数就不是简单地相等了。

我们还是可以分割数独，但是这次是以纵向的九宫格界分割。

这样每块有 $6\div3=2$ 列左右大于号。

于是我们就可以和上面一样处理了！

`$1` 的下半部分的上半部分就出来了：
```
$1.2.2:&&(!(y%3)||(mor[x/3*5+x%3*2][y/3*2+y%3-1]^ans[x][y-1]<i)
```
# 最后
至此我们集齐了所有代码，可以召唤~~神龙~~ $AC$ 了！

完整代码就不放了，把上面的代码合起来再缝补一下就行。

完整代码非常短，连 $1KB$ 都不到（应该是最短的了）。这就是数学公式的魅力。什么四维数组、检查可行性时开 $for$ 循环都不要了。

不过你其实会发现上面讲的东西完全可以用打表替代。

不过打表的话代码就不短了呀！