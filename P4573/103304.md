改啊改，终于把这道题A了，其实这道题只不过是一个普通的数独加上一大堆判断罢了，应该来说想是挺好想的，但是写起来特别麻烦。

**先来谈一下思路：**

DFS，相当于枚举每一个点的取值，然后判断当前这个点能不能取这个值，不行就下一个，从$(1,1)$开始枚举，如果最终到达了（9,9）这个点，那么就一定是解，就可以输出了。

**实现过程：**

用一个二维数组**h**来表示在这个数这一行的数字分布情况，有这个数字就是1，没有就是0。**l**数组表示这一列的数字分布情况，作用和**h**相同，一个g数组表示在这个数字所在的小九宫格的数字分布情况。

**以上是实现基本数独所需要的**，要完成这道题，还需要一个数组（map）来映射大小关系，在这里，我使用的是一个四维数组，前两维表示一个点的坐标，后面两维用来表示另外一个点的坐标，数组存的是一个二者的最小值坐标。

**这里存最小值坐标的方法：**

考虑到这道题的坐标范围不会超过9，所以可以用$x*10+y$这个表达式来存取坐标，这样是绝对不会冲突的。

那么做好了上面的所有准备，只需要每一次填数的时候进行一堆判断，最后答案就可以出来了。

**以下是代码（略微过长，还有很多可优化的地方）：**

```cpp
#include<iostream>
#include<algorithm>
#include<map>
using namespace std;
const int N=110;
bool h[N][N],l[N][N],g[N][N];//行，列，方块 
int op[N/10][N/10][N/10][N/10];//表示两个相邻的点大小情况 
int m[N][N];//存图 
void printf()//输出 
{
	for(int i=1;i<=9;i++)
	{
		for(int j=1;j<=9;j++)
		{
			cout<<m[i][j]<<" ";
		}
		cout<<endl;
	}
	return;
}
bool pd(int x,int y,int i)//位置，要填的数 
{
	int next=x*10+y;//下一个方位hash 
	if(op[x][y][x-1][y]==next)//和上面的做比较,自己小一点 
	{
		if(m[x-1][y]<=i&&m[x-1][y]!=0)
		{
			return false;
		}
	}
	if(op[x][y][x-1][y]!=next&&op[x][y][x-1][y]!=0)//自己比上面的大 
	{
		if(m[x-1][y]>=i)
		{
			return false;
		}
	}
	if(op[x][y][x+1][y]==next)//和下面的做比较，自己小 
	{
		if(m[x+1][y]<=i&&m[x+1][y]!=0)
		{
			return false;
		}
	}		
	if(op[x][y][x+1][y]!=next&&op[x][y][x+1][y]!=0)//自己大 
	{
		if(m[x+1][y]>=i)
		{
			return false;
		}
	}	
	if(op[x][y][x][y-1]==next)//左边的做比较 ,自己小 
	{
		if(m[x][y-1]<=i&&m[x][y-1]!=0)
		{
			return false;
		}
	}	
	if(op[x][y][x][y-1]!=next&&op[x][y][x][y-1]!=0)//自己大 
	{
		if(m[x][y-1]>=i)
		{
			return false;
		}
	}		
	if(op[x][y][x][y+1]==next)//自己小 
	{
		if(m[x][y+1]<=i&&m[x][y+1]!=0)
		{
			return false;
		}
	}	
	if(op[x][y][x][y+1]!=next&&op[x][y][x][y+1]!=0)
	{
		if(m[x][y+1]>=i)
		{
			return false;
		}
	}	
	return true;
}
void dfs(int x,int y)
{
	if(m[x][y]!=0)
	{
		if(x==9&&y==9)
		{
			printf();
			exit(0);
		}
		if(y==9)
		{
			dfs(x+1,y);
		}
		else
		{
			dfs(x,y+1);
		}
	}
	if(m[x][y]==0)
	{
		for(int i=1;i<=9;i++)
		{
			if(h[x][i]==0&&l[y][i]==0&&g[(x-1)/3*3+(y-1)/3+1][i]==0)//数独标准配合 
			{
				if(pd(x,y,i)==true)//判断成功 
				{
					m[x][y]=i;
					h[x][i]=1;
					l[y][i]=1;
					g[(x-1)/3*3+(y-1)/3+1][i]=1;
					if(x==9&&y==9)
		   			{
		      		    printf();
						exit(0);   	
		  		    }              
	       			if(y==9)  
		   			{
		 				dfs(x+1,1);   	
		  			}  
		  			else	 
		  			{
		 			  	dfs(x,y+1);
		 			}  
					m[x][y]=0;	
					h[x][i]=0;
					l[y][i]=0;
					g[(x-1)/3*3+(y-1)/3+1][i]=0;					
				}
			}
		}
	}
}
void sign(char a,char b,char c,char d,char e,char f,int h)//左右方向映射 
{
	if(a=='<')
	{
		op[h][1][h][2]=h*10+1;
		op[h][2][h][1]=h*10+1;			
	}
	if(a=='>')
	{
		op[h][1][h][2]=h*10+2;
		op[h][2][h][1]=h*10+2;			
	}
	if(b=='>')
	{
		op[h][2][h][3]=h*10+3;
		op[h][3][h][2]=h*10+3;		
	}
	if(b=='<')
	{
		op[h][2][h][3]=h*10+2;
		op[h][3][h][2]=h*10+2;
	}			
	if(c=='<')	
	{
		op[h][4][h][5]=h*10+4;
		op[h][5][h][4]=h*10+4;
	}		
	if(c=='>')	
	{
		op[h][4][h][5]=h*10+5;
		op[h][5][h][4]=h*10+5;
	}
	if(d=='>')	
	{
		op[h][5][h][6]=h*10+6;
		op[h][6][h][5]=h*10+6;
	}
	if(d=='<')	
	{
		op[h][5][h][6]=h*10+5;
		op[h][6][h][5]=h*10+5;
	}
	if(e=='>')
	{
		op[h][7][h][8]=h*10+8;
		op[h][8][h][7]=h*10+8;		
	}
	if(e=='<')
	{
		op[h][7][h][8]=h*10+7;
		op[h][8][h][7]=h*10+7;		
	}
	if(f=='>')
	{
		op[h][8][h][9]=h*10+9;
		op[h][9][h][8]=h*10+9;		
	}
	if(f=='<')
	{
		op[h][8][h][9]=h*10+8;
		op[h][9][h][8]=h*10+8;		
	}			
}
void upsign(int i,char c,int j)
{
	if(c=='^')//上面比下面小 
	{
		if(i==2)//第二行 
		{
			op[1][j][2][j]=1*10+j;
			op[2][j][1][j]=1*10+j;//映射成最小的 
		}
		if(i==4)
		{
			op[2][j][3][j]=2*10+j;
			op[3][j][2][j]=2*10+j;		
		}
		if(i==7)
		{
			op[4][j][5][j]=4*10+j;
			op[5][j][4][j]=4*10+j;		
		}
		if(i==9)
		{
			op[5][j][6][j]=5*10+j;
			op[6][j][5][j]=5*10+j;		
		}
		if(i==12)
		{
			op[7][j][8][j]=7*10+j;
			op[8][j][7][j]=7*10+j;		
		}
		if(i==14)
		{
			op[8][j][9][j]=8*10+j;
			op[9][j][8][j]=8*10+j;		
		}		
	}
	else//上面 比当前大 
	{
		if(i==2)//第二行 
		{
			op[1][j][2][j]=2*10+j;
			op[2][j][1][j]=2*10+j;//映射成最小的坐标 
		}
		if(i==4)
		{
			op[2][j][3][j]=3*10+j;
			op[3][j][2][j]=3*10+j;		
		}
		if(i==7)
		{
			op[4][j][5][j]=5*10+j;
			op[5][j][4][j]=5*10+j;		
		}
		if(i==9)
		{
			op[5][j][6][j]=6*10+j;
			op[6][j][5][j]=6*10+j;		
		}
		if(i==12)
		{
			op[7][j][8][j]=8*10+j;
			op[8][j][7][j]=8*10+j;		
		}
		if(i==14)
		{
			op[8][j][9][j]=9*10+j;
			op[9][j][8][j]=9*10+j;		
		}				
	}

}
int main()
{
	int h=0;
	for(int i=1;i<=15;i++)
	{
		if(i==2||i==4||i==7||i==9||i==12||i==14)//上下方向 
		{
			for(int j=1;j<=9;j++)//9个方向 
			{
				char c;
				cin>>c;
				upsign(i,c,j);//标记大小 
			}
			continue;
		}		
		h++;
		char a,b,c,d,e,f;
		cin>>a>>b>>c>>d>>e>>f;
		sign(a,b,c,d,e,f,h);//标记大小 
	}
	dfs(1,1);
	return 0;
} 
```