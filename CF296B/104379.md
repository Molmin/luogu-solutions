## $Solution$

勾巴题，复杂度 $O(n)$

设 $f_{i, 0/1, 0/1}$ 表示做到 $i$ ，$s_i > w_i$ 是否满足， $w_i > s_i$ 是否满足时的方案数。

转移讨论这一位有几个问号

如果两个都不是直接根据两者的偏序关系继承或者转移

如果有一个是就乘上合法的方案数

如果两个都是就暴算

具体实现看代码，注意细节。

```cpp
if (a[i] == -1 || b[i] == -1) {
	if (a[i] == -1 && b[i] != -1) {
		Add(f[i][0][0], f[i - 1][0][0]);
		Add(f[i][0][1], (f[i - 1][0][0] * b[i] % P + f[i - 1][0][1] * (b[i] + 1) % P) % P);
		Add(f[i][1][0], (f[i - 1][0][0] * (9 - b[i]) % P + f[i - 1][1][0] * (10 - b[i]) % P) % P);
		Add(f[i][1][1], ((f[i - 1][0][1] * (9 - b[i]) % P + f[i - 1][1][0] * b[i] % P) % P + f[i - 1][1][1] * 10 % P) % P);
	}
	if (a[i] != -1 && b[i] == -1) {
		Add(f[i][0][0], f[i - 1][0][0]);
		Add(f[i][0][1], (f[i - 1][0][0] * (9 - a[i]) % P + f[i - 1][0][1] * (10 - a[i]) % P) % P);
		Add(f[i][1][0], (f[i - 1][0][0] * a[i] % P + f[i - 1][1][0] * (a[i] + 1) % P) % P);
		Add(f[i][1][1], ((f[i - 1][0][1] * a[i] % P + f[i - 1][1][0] * (9 - a[i]) % P) % P + f[i - 1][1][1] * 10 % P) % P);
	}
	if (a[i] == -1 && b[i] == -1) {
		Add(f[i][0][0], f[i - 1][0][0] * 10 % P);
		Add(f[i][0][1], (f[i - 1][0][0] * 45 % P + f[i - 1][0][1] * 55 % P) % P);
		Add(f[i][1][0], (f[i - 1][0][0] * 45 % P + f[i - 1][1][0] * 55 % P) % P);
		Add(f[i][1][1], ((f[i - 1][0][1] * 45 % P + f[i - 1][1][0] * 45 % P) % P + f[i - 1][1][1] * 100 % P) % P);
	}
} else {
	if (a[i] > b[i]) {
		Add(f[i][1][0], (f[i - 1][0][0] + f[i - 1][1][0]) % P);
		Add(f[i][1][1], (f[i - 1][0][1] + f[i - 1][1][1]) % P);
	}
	if (a[i] < b[i]) {
		Add(f[i][0][1], (f[i - 1][0][0] + f[i - 1][0][1]) % P);
		Add(f[i][1][1], (f[i - 1][1][0] + f[i - 1][1][1]) % P);
	}
	if (a[i] == b[i]) {
		f[i][0][0] = f[i - 1][0][0], f[i][1][0] = f[i - 1][1][0];
		f[i][0][1] = f[i - 1][0][1], f[i][1][1] = f[i - 1][1][1];
	}
}
```
$ps:$ $Add$ 是两数相加函数。