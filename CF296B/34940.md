update4:加上了中文标点。

update3:去掉了头图。

update2:在所有英文字符前后加了空格。

update1:把公式里的中文换成了 & 和 | , latex 前后加了空格。


目前是最优解rk1。

**阴间题**,大力转移要转一页纸.写码时最好标注好 dp 数组意义(~~不然就忘了~~)。

## **题意**
给定两个由数字和问号组成的等长字符串 $A , B$ ,定义性质 P : 存在 $ 1 \le i,j \le len$ ,满足 $A_i < B_i \&\& A_j > B_j$ ,求将问号替换成数字使 $A,B$ 满足性质 $P$ 的方案数。


## **题解**

**状态设计**:考虑序列 `dp` ,观察到性质是**两方面的**,一方面是令 `A`  中有数大于 `B` ,另一方面则是小于,这两方面显然**不能在一次转移**中完成,故在状态设计中加入两维,分别记录是否已满足这两方面性质,再加一维表示序列的前 $i$ 个,即用 $dp_{0/1,0/1,i}$ 存储方案数.初始化较为显然: $dp_{0,0,0}=1$ , $dp_{1,1,n}$ 即为答案。

**考虑转移**:由于不可能一次满足两方面性质,显然满足一个性质的要从不满足任何性质和满足**同一性质**转移过来,而满足两个性质的要从**两种**满足一个性质和已经满足两个性质的转移过来,不满足任何性质的只能从之前不满足任何性质的转移过来,同时注意根据问号数量讨论:若都不是问号,根据**数字大小关系**直接转移;若有一个及以上问号,考虑在满足给定性质时问号的方案数,显然种类并不多,可以提前算出,即:**两个问号没有任何限制为100种,要求严格大于有45种,非严格大于有55种**.另外,有一个为括号时要根据给定的数字判断方案,也要注意严格大于小于和非严格大于小于的区别.至此,易得转移方程:( $D(x)$ 为 `is_digit(x)` )。

$$dp_{i,0,0}=\left\{
\begin{array}{rcl}
dp_{i-1,0,0},D(A_i)\| D(B_i) \\
10dp_{i-1,0,0},!D(A_i)\&\& !D(B_i)
\end{array}
\right.
$$
$$
dp_{i,0,1}=\left\{
\begin{array}{rcl}
dp_{i-1,0,1},A_i=B_i\\
dp_{i-1,0,0}+dp_{i-1,0,1},A_i<B_i\\
(10-A_i)dp_{i-1,0,1}+(9-A_i)dp_{i-1,0,0},D(A_i)\&\& !D(B_i)\\
(B_i+1)dp_{i-1,0,1}+B_idp_{i-1,0,0},!D(A_i)\&\& D(B_i)\\
45dp_{i-1,0,0}+55dp_{i-1,0,1},!D(A_i)\&\& !D(B_i)
\end{array}
\right.
$$
$$
dp_{i,1,0}=\left\{
\begin{array}{rcl}
dp_{i-1,1,0},A_i=B_i\\
dp_{i-1,0,0}+dp_{i-1,1,0},A_i>B_i\\
(10-B_i)dp_{i-1,1,0}+(9-B_i)dp_{i-1,0,0},!D(A_i)\&\& D(B_i)\\
(A_i+1)dp_{i-1,1,0}+A_idp_{i-1,0,0},D(A_i)\&\& !D(B_i)\\
45dp_{i-1,0,0}+55dp_{i-1,1,0},!D(A_i)\&\& !D(B_i)
\end{array}
\right.
$$
$$
dp_{i,1,1}=\left\{
\begin{array}{rcl}
dp_{i-1,1,1},A_i=B_i\\
dp_{i-1,1,0}+dp_{i-1,0,1},A_i\not =B_i\\
B_idp_{i-1,1,0}+(9-B_i)dp_{i-1,0,1}+10dp_{i-1,1,1},!D(A_i)\&\& D(B_i)\\
(9-A_i)dp_{i-1,1,0}+A_idp_{i-1,0,1}+10dp_{i-1,1,1},D(A_i)\&\& !D(B_i)\\
45dp_{i-1,0,1}+45dp_{i-1,1,0}+100dp_{i-1,1,1},!D(A_i)\&\& !D(B_i)
\end{array}
\right.
$$
## 代码

```cpp
//写转移时始终想着一次最多只能满足一方面性质就会好写很多
#include<iostream>
#include<cstdio>
using namespace std;
const int N=100005,Mod=1000000007;
int n,a[N],b[N];
long long dp[2][2][N];
string s1,s2;
int main() {
	ios::sync_with_stdio(false);
	cin>>n>>s1>>s2;
	s1=' '+s1,s2=' '+s2;//让下标从1开始
	for (int i=1; i<=n; i++) {
		if (s1[i]=='?')a[i]=-1;//问号标为-1
		else a[i]=s1[i]-'0';
		if (s2[i]=='?')b[i]=-1;
		else b[i]=s2[i]-'0';
	}
	dp[0][0][0]=1;
	for (int i=1; i<=n; i++) {
		if (a[i]!=-1&&b[i]!=-1) {
			if (a[i]==b[i]) {//直接转移
				dp[0][0][i]=dp[0][0][i-1]%Mod;
				dp[0][1][i]=dp[0][1][i-1]%Mod;
				dp[1][0][i]=dp[1][0][i-1]%Mod;
				dp[1][1][i]=dp[1][1][i-1]%Mod;
			}
			if (a[i]>b[i]) {//只能满足一方面性质
				dp[1][0][i]=dp[0][0][i-1]%Mod+dp[1][0][i-1]%Mod;
				dp[1][1][i]=dp[0][1][i-1]%Mod+dp[1][1][i-1]%Mod;
			}
			if (a[i]<b[i]) {//另一方面
				dp[0][1][i]=dp[0][0][i-1]%Mod+dp[0][1][i-1]%Mod;
				dp[1][1][i]=dp[1][0][i-1]%Mod+dp[1][1][i-1]%Mod;
			}
			continue;
		}
		if (a[i]!=-1&&b[i]==-1) {//单问号
			dp[0][0][i]=dp[0][0][i-1]%Mod;
			dp[0][1][i]=dp[0][1][i-1]*(10-a[i])%Mod+dp[0][0][i-1]*(9-a[i])%Mod;
			dp[1][0][i]=dp[1][0][i-1]*(a[i]+1)%Mod+dp[0][0][i-1]*a[i]%Mod;
			dp[1][1][i]=dp[1][0][i-1]*(9-a[i])%Mod+dp[0][1][i-1]*a[i]%Mod+dp[1][1][i-1]*10%Mod;
			continue;
		}
		if (a[i]==-1&&b[i]!=-1) {//单问号
			dp[0][0][i]=dp[0][0][i-1]%Mod;
			dp[0][1][i]=dp[0][1][i-1]*(b[i]+1)%Mod+dp[0][0][i-1]*b[i]%Mod;
			dp[1][0][i]=dp[1][0][i-1]*(10-b[i])%Mod+dp[0][0][i-1]*(9-b[i])%Mod;
			dp[1][1][i]=dp[1][0][i-1]*b[i]%Mod+dp[0][1][i-1]*(9-b[i])%Mod+dp[1][1][i-1]*10%Mod;
			continue;
		}
		if (a[i]==-1&&b[i]==-1) {//双问号
			dp[0][0][i]=dp[0][0][i-1]*10%Mod;
			dp[0][1][i]=dp[0][0][i-1]*45%Mod+dp[0][1][i-1]*55%Mod;
			dp[1][0][i]=dp[0][0][i-1]*45%Mod+dp[1][0][i-1]*55%Mod;
			dp[1][1][i]=dp[0][1][i-1]*45%Mod+dp[1][0][i-1]*45%Mod+dp[1][1][i-1]*100%Mod;
			continue;
		}
		cout<<"Fail"<<endl;
	}
	cout<<dp[1][1][n]%Mod<<endl;
}