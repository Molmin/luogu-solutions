水一个题解 （ 

这题一开始怎么看怎么像DP , 后来感觉状态转移很麻烦 ， 便想到了容斥。

设$ans$ 所有情况 （包括不合法的情况 + 合法情况） ， 不难想到 ，不合法的情况就只有全部等于 ， 全部大于 ， 和 全部小于这三种

便设

$res1$ = 全部大约的情况

$res2$ = 全部小于的情况

$res3$ = 全部等于的情况

那答案是不是就是 $ans$ $ - $ $res1$ $-$ $res2$ - $res3$ 呢 ? 

稍后在代码中给出答案$qwq$

求$res1$的代码
```cpp
void EI1 () { // A[i] > B[i]
    for (int i = 0 ; i < n ; i ++) {
    	if (A[i] == '?' && B[i] == '?') res1 = (res1 * 55) % mod ;
    	else if (A[i] == '?' && B[i] != '?') res1 = (res1 * (10 - (B[i] - '0'))) % mod ;
    	else if (A[i] != '?' && B[i] == '?') res1 = (res1 * ((A[i] - '0') + 1)) % mod ;
    	else if ((A[i] - '0') < (B[i] - '0')) { // 注意这里 ， 我写的不是小于等于 ， （留下伏笔
    		res1 = 0 ;
    		break ;
		}
	}	
}
```
$res2$ 以此类推 

$res3$ 代码 
```cpp
void EI3 () {
	for (int i = 0 ; i < n ; i ++) {
		if (A[i] == '?' && B[i] == '?') res3 = (res3 * 10) % mod ;
		else if((A[i]=='?' && B[i]!='?') || (A[i]!='?' && B[i]=='?')) continue ; // 为了保证一样 ，啥都不需要干 
		else if (A[i] != B[i]) {
			res3 = 0 ;
			break ;
		}  
	}
}
```
ans 显而易见就是 遇到问号就 * 10 就可以了 

最后答案
```cpp
cout << (ans + (mod * 2) - res1 - res2 + res3) % mod ;
// 为什么这里我们把res3 加上了 呢 ， 因为我们减去了两个相等的情况 ， res1 上 包括一个 ， res2 上 包括一个 ， 为了保证答案的正确性 ， 我们便要加上一个 
```

