这题很珂学啊～

这里提供一种用暴力卡过的方法

因为一个数的因数个数并不会很多，用`std::set`维护每个因子的倍数出现的位置，

执行操作的时候直接暴力`lower_bound`找出对应的位置然后判断是否删除就可以了，区间和用一个树状数组维护一下就行。

就如题解里面所说，这样是过不了的，我开了`O2`也只得到了`39`分

这个时候别人说要手写平衡树然后在树里面`DFS`删除..而且需要各种各种卡常，想想就好麻烦

其实STL是很强大的

直接把`std::set`换成`std::vector`然后就可以辣。

因为按照顺序把数插入`std::vector`删除也是顺着删除，所以`vector`自然有序

虽然想到`vector.erase()`的复杂度貌似很爆炸。。

而`std::vector`是一个神奇的东西，就可以卡过了。。

大概是删除的东西也不会很多，数据的因子比较分散造成的吧

出题人也没有卡这个毒瘤做法呢。。。

貌似复杂度很爆炸，特别是每次`erase`竟然是O(因子个数)的，要卡其实很好卡掉的QAQ

但是这个比其它5KB，6KB甚至更长的代码好写多了吧

因为没有`O2`STL会慢一点，我也没怎么特意去卡常，所以会T后两个点。。

开`O2`可以把最后一个点用`3960ms`卡过去。。。

[代码](https://www.luogu.org/paste/h9k1arud)