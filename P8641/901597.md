[题目传送门](https://www.luogu.com.cn/problem/P8641)

## 题意

本题的目标是求出一个顺时针卡片序列中，从任意一张卡片开始顺时针数数，能够赢得的最多球票数。


## 思路

解决这个问题，可以使用模拟方法。首先遍历圆圈中的每一张牌，并从那张牌开始模拟游戏。对于每一张起始卡，都会记录收集的卡的总数，并返回最大总数。


为了模拟游戏，首先在起始牌上设置一个可变电流。然后，我们在圆圈中迭代，每次将 $x$ 递增 $1$，如果到达圆圈的末尾，则循环到圆圈的开头。如果 $x$ 等于当前卡片上的数字，我们将该数字加在总数中，然后将卡片从圆圈中移除。我们继续，直到我们不能再收集任何卡片为止。

## C++ Code

```cpp
#include <iostream>
#include <algorithm>
using namespace std;

int main() {
    int n;
    cin >> n; //读入卡片数目
    int a[n];
    int maxn = 0;
    for (int i = 0; i < n; i++) {
        cin >> a[i]; //读入卡片数字
        maxn = max(maxn, a[i]); //先算出所有卡片的最大值
    }
    int maxi = 0;
    for (int i = 0; i < n; i++) {
        int f[n] = {0}; //标记卡片是否已经被收集
        int x = 1; //报数器
        int sum = 0; //已经收集的卡片数字之和
        int j = i; //当前卡片的下标
        int m = n; //剩余未收集的卡片数目
        while (true) {
            if (f[j] == 0) { //如果当前卡片未被收集
                if (x == a[j]) { //如果报数器等于当前卡片数字
                    sum += a[j]; //将当前卡片收入囊中
                    f[j] = 1; //标记当前卡片已被收集
                    x = 0; //重置报数器
                    maxi = max(maxi, sum); //更新最大收集数
                    m--; //剩余未收集的卡片数目减1
                }
                x++; //报数器加1
            }
            if (x > maxn || m <= 0) break; //如果报数器大于所有卡片的最大值或卡片数量小于等于0，就结束循环
            j++; //移动到下一个卡片
            if (j == n) j = 0; //如果已经到了最后一个卡片，就从头开始
        }
    }
    cout << maxi << endl; //输出所有起点的最大值
    return 0;
}
```


## 代码解释

这段代码使用了两个循环来模拟游戏的过程。第一个循环用来枚举起点，第二个循环用来模拟从当前起点开始的游戏过程。在第二个循环中，使用了一个数组 $f$ 来标记卡片是否已经被收集，一个变量 $x$ 来表示当前的报数器，一个变量 $sum$ 来表示已经收集的卡片数字之和，一个变量 $j$ 来表示当前卡片的下标，一个变量 $m$ 来表示剩余未收集的卡片数目。如果当前卡片未被收集，就判断报数器是否等于当前卡片数字，如果是，就将当前卡片收入囊中，并更新 $sum$ 和 $maxi$，然后重置报数器和标记当前卡片已被收集。最后，如果报数器大于所有卡片的最大值或卡片数量小于等于 $0$，就结束循环。


[已AC，请放心食用](https://www.luogu.com.cn/record/110607169)
