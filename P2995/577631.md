[luogu](https://www.luogu.com.cn/problem/P2995)

------------------------

现在假设 $n=5$ ，这是我们的初始目标序列：

```cpp
1 2 3 4 5

逆序对数量：0
```
将它进行一次循环，我们得到了：

```cpp
2 3 4 5 1

逆序对数量：4
```

每一次循环，逆序对的数量发生了什么变化？我们不必每次都暴力求出

我们发现，此次移动的数字 $1$ ，在原序列中是小于其他数的元素，但却在其他数的前方，所以不构成任何一个逆序对

但当它走到序列最后时，依然小于其他数，却在其他数的后方了。所以与其他所有数都构成了逆序对

循环多次，我们不难得到一个结论：

对于数 $x$ ，在它循环到序列末端时，先前**不与它构成逆序对**的所有数，现在**都与它构成逆序对**。

反之，先前**所有与它构成逆序对**的数，现在都**不与它构成逆序对**。

-------------

要让给出的序列变成**初始**目标序列，对它求逆序对即可，这是初始的交换次数

我们记录下所有数所在的位置，对于每个数，计算它在序列末端做出的贡献，得到新的交换次数


```cpp
int cowat[N];
int endans;
signed main(){
	n=read();
	int ans=0;
	loop(i,1,n){
		nun[i]=read();
		cowat[nun[i]]=i;
	}
	loop(i,1,n){
    	//初始序列逆序对
		add(nun[i],1);
		ans+=(i-query(nun[i]));
	}
	endans=ans;
	loop(i,1,n){
		ans=ans+(n-cowat[i])-(cowat[i]-1);
		endans=Min(endans,ans);
	}
	cout<<endans;
	return 0;
}
```
