[题目传送门](/problem/P1544)

## 题目大意

与[P1216 数字三角形](/problem/P1216)相似，但是本题可以选择不超过 $k$ 个数，使它们的值变成原来的 $3$ 倍。

## 思路

从顶部走到底部，会经过 $n$ 个点。当 $k>n$ 时，我们只需要修改路径上的 $n$ 个点即可。因此当 $k>n$ 时，我们可以把 $k$ 的值变为 $n$。这样，我们就可以使 $n,k$ 同阶。

假设有 $k+1$ 层相同的数字三角形，编号为 $0\sim k$。从第 $0$ 层数字三角形的顶部开始走。在一个点上，我们可以走到与它同层，且在它左下方或右下方的点。如果这个点不在最底层，我们还可以走向它的下一层，且在它左下方或右下方的点。

向下走一层，可以视为将走到的点所对应的值变成原来的 $3$ 倍，即使用了一次修改的机会。有 $k+1$ 层数字三角形，显然走了不超过 $k$ 层。这样就可以满足题目中"选择不超过 $k$ 个数，使它们的值变成原来的 $3$ 倍"的条件。

容易发现，第 $p$ 层的点，用了 $p$ 次修改机会。

考虑如何推出状态转移方程。

我们用 $f_{i,j,p}$ 表示走到 $(i,j,p)$（第 $p$ 层，第 $i$ 行，第 $j$ 列）的最大得分。

如果现在走到了点 $(i,j,p)$，那么我们可以：

* 不走向下一层：走到 $(i+1,j,p)$ 或 $(i+1,j+1,p)$。
* 向下走一层：走到 $(i+1,j,p+1)$ 或 $(i+1,j+1,p+1)$。

如果不走向下一层，我们就加上到达的点所对应的值。否则加上到达的点所对应的值的 $3$ 倍。

即可得到转移方程：

```cpp
f[i+1][j][p]=max(f[i+1][j][p],f[i][j][p]+a[i+1][j]);
f[i+1][j+1][p]=max(f[i+1][j+1][p],f[i][j][p]+a[i+1][j+1]);
f[i+1][j][p+1]=max(f[i+1][j][p+1],f[i][j][p]+a[i+1][j]*3);
f[i+1][j+1][p+1]=max(f[i+1][j+1][p+1],f[i][j][p]+a[i+1][j+1]*3);
```

最后，我们取走到每一层的底部得分的最大值即可。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define endl '\n' 
#define ll long long
const ll inf=1e18;
ll f[110][110][110];
ll a[110][110];
signed main()
{
    ios::sync_with_stdio(0);
    cin.tie(0);cout.tie(0);
    int n,k;
    cin>>n>>k;
    if(k>n) k=n;
    for(int i=1;i<=n;i++)
        for(int j=1;j<=i;j++) cin>>a[i][j];
    for(int i=1;i<=n;i++)
     for(int j=1;j<=i;j++)
      for(int p=0;p<=k;p++)
       f[i][j][p]=-inf;//将所有点初始值设为无穷小
       
    f[1][1][0]=a[1][1];//走到(1,1)处用了0次乘三的机会，即(1,1)没变成三倍
    f[1][1][1]=a[1][1]*3;//走到(1,1)处用了1次乘三的机会，即(1,1)变成了三倍

    for(int i=1;i<=n;i++)
        for(int j=1;j<=i;j++)
            for(int p=0;p<=k;p++)//遍历 k+1 层的每一个点
            {
                f[i+1][j][p]=max(f[i+1][j][p],f[i][j][p]+a[i+1][j]);
                f[i+1][j+1][p]=max(f[i+1][j+1][p],f[i][j][p]+a[i+1][j+1]);
                f[i+1][j][p+1]=max(f[i+1][j][p+1],f[i][j][p]+a[i+1][j]*3);
                f[i+1][j+1][p+1]=max(f[i+1][j+1][p+1],f[i][j][p]+a[i+1][j+1]*3);
            }
    ll ans=-inf;
    for(int i=1;i<=n;i++) for(int p=0;p<=k;p++) ans=max(ans,f[n][i][p]);//取每一层底部的最大值
    cout<<ans;

    return 0; 
}
```