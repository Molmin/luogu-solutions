首先有 $(a_i,b_i)$ 里面应该有一个 $\leq n$ 和一个 $>n$ 的，否则最终一定不合法。接下来默认 $a_i<b_i,a_i=i$。

考虑最终 $a$ 序列由一段 $\leq n$ 的前缀和 $>n$ 的后缀拼接，$b$ 序列由一段和 $a$ 前缀长度相同的 $>n$ 的前缀和 $\leq n$ 的后缀拼接，于是前缀后缀是独立的，讨论一下非法的情况。

一个直觉是如果 $a_i<a_j,b_i<b_j$ 的对是特殊的，但是发现我们如果把 $i,j$ 不同时丢到前缀和后缀就不会出现问题，那么我们在这样的 $i,j$ 之间连边，最终得到的如果是二分图就可以在每个连通分量中选择代价较少的一边作为答案，否则不合法，于是得到了一个 $O(n^2)$ 的做法。

考虑当 $i<j<k,(i,j),(j,k)$ 边都存在时，那么 $(i,k)$ 之间也有边，则形成了一个奇环，就无解了。那么每个点不能同时存在向前和向后的连边。

另外一个暴力做法是从前往后先扫一遍，维护一个 `std::set`，对于 $i$ 找到 $j<i,b_j<b_i$ 的 $j$，并把 $i,j$ 连边，标记 $j$ 只能有出边，$i$ 只能有入边。如果出现类型非法的边那么就无解了。同样的从后往前扫一遍。这样就得到了所有的边。

观察到我们需要的信息并不是所有的边，而是每个点属于哪个连通分量，于是在从前往后加边之后就可以把 `set` 中第二个元素到 $j$ 全部删掉，从后往前加边之后就把 `set` 中 $j$ 到倒数第二个元素删掉，均摊就对了。正确性显然，相当于合并了 $j$ 这个前缀/后缀到一起。

时间复杂度 $O(n\log n)$，[提交记录](https://codeforces.com/contest/1503/submission/159981926)。

