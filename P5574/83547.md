### 题目大意

给定一个长度为 $n$ 的排列 $p$，将 $p$ 按照原顺序划分成 $k$ 段，使每一段的顺序对个数和最小。$n\le 25000,k\le 25$

### 动态转移方程

转移方程

$$F_{i,j}=\min_{0\le k<i}\{F_{k,j-1}+w(k+1,i)\}$$

其中，$F_{i,j}$ 表示将前 $i$ 个数分为 $j$ 段时每一段顺序对个数和的最小值，$w(i,j)$ 表示区间 $[i,j]$ 内的顺序对个数。这么做是 $O(n^2k)$ 的。

### 优化

我们发现，$w(i,j)$ 是满足四边形不等式的，所以该转移方程满足决策单调性。但是 $w(i,j)$ 不是很好算，而且 $n$ 是比较大的，这么一来就不能使用常规做法。

不过我们发现 $k$ 比较小，而且 $j$ 只会从 $j-1$ 转移而来，所以我们可以考虑做相同的转移 $k$ 次。现在我们将问题转换为了，用上一次的结果 $[0,n-1]$ 去转移这一次的 $[1,n]$。

这边我们要介绍一个全新的东西，它叫做决策单调性分治。由于决策单调性，当前所求的一段连续的区间(就是状态转移方程中 $i$ 那一维的下标)一定是从上一次所求的一段连续的区间转移而来的。我们记 $Solve(l,r,L,R)$ 表示用 $[L,R]$ 这一段上一次所求的连续的区间可以转移至 $[l,r]$ 这一段当前所求的的连续的区间。我们取 $[l,r]$ 的中点 $mid$，然后找到 $mid$ 的最优决策点 $p$(这里当然就算出了动态转移方程中 $mid$ 处的取值)，那么 $[l,mid-1]$ 只可能从 $[L,p]$ 转移而来，$[mid+1,r]$ 只可能从 $[p,R]$ 转移而来，这一步可以由决策单调性得出。于是如此递归分治下去，显然边界就是 $l=r$，不过这里不用特判，因为找 $mid$ 的最优决策点时已经算出动态转移方程 $mid$ 处的取值，而此时 $l=mid$。

注意到算法过程中计算 $w(i,j)$ 都是扩展一格左边界，那么计算 $w(i,j)$ 可以使用类似莫队的思想，用树状数组维护即可。每一层分治的时间复杂度为 $O(n\log n)$，一共分治 $O(\log n)$ 层，这样的分治进行 $k$ 次，故总时间复杂度为 $O(nk\log^2 n)$。

### Code

```cpp
// lst[]=>上一次求出的答案，now[]=>当前求的
void Solve(int l,int r,int L,int R){//如上文所述
    int mid=(l+r)>>1,p=mid;
    for(REG int i=L;i<=Min(mid-1,R);++i){
        int ans=w(i+1,mid);
        if(lst[i]+ans<=now[mid]) now[mid]=lst[i]+ans,p=i;
    }
    if(l<mid) Solve(l,mid-1,L,p);
    if(r>mid) Solve(mid+1,r,p,R);
}

int Work(){
    for(REG int i=1;i<=n;++i) lst[i]=now[i]=0x7f7f7f7f;
    for(REG int i=1;i<=k;++i){
        Sovle(1,n,0,n-1);//从[0,n-1]转移至[1,n]
        for(REG int j=1;j<=n;++j) lst[j]=now[j];
    }
    return now[n];
}
```

