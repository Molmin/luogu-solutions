模拟题。

首先将序列按照元素单调递增的顺序来排序。

对于排好序的序列，我们要将其分成两个序列，需要满足两个序列的长度的差的绝对值要小于等于 $1$，那么我们就将当前序列均分成两个序列，如果到最后剩下一个元素那么就放到第一个序列里。

然后要满足两个序列的差值小于等于 $n$ 个数中最大值，那么我们可以将序列分成 $\lfloor \frac{n}{2} \rfloor$ 组，其中每一组序列包含两个元素，第一个元素放入第一个序列中，第二个元素放入第二个序列中即可。如果到最后剩下一个元素不在任意的一组内部，那么我们将其放入第一个序列即可。

这样做满足条件的证明：如果不考虑最后有可能剩下的那一个元素，那么第一个序列一定小于等于第二个序列。最后剩下的那一个元素一定是最大的那一个元素，将这一个元素放入第一个序列里面一定是最优解，由于题目保证数据一定有解，那么输出最优方案即可。

**Code**

```cpp
#include <bits/stdc++.h>

using namespace std;

struct Node {
    int x, id;
    Node () { x = id = 0; }
    friend bool operator < (const Node & _1, const Node & _2) {
        return _1.x < _2.x;
    }
} a[1000010];

signed main() {
    int n;
    cin >> n;
    for (int i = 1; i <= n; i ++) {
        scanf ("%d", &a[i].x); a[i].id = i;
    } sort (a + 1, a + n + 1); // 按照关键字 `x`，也就是数字的大小从小到大排序
    cout << n - (n >> 1) << '\n'; // 输出第一个序列长度
    for (int i = 1; i <= n; i ++) {
        if (i & 1) cout << a[i].id << ' '; // 输出第一个序列的元素
    } cout << '\n' << (n >> 1) << '\n'; // 输出第二个序列的长度
    for (int i = 1; i <= n; i ++) {
        if (! (i & 1)) cout << a[i].id << ' '; // 输出第二个序列的元素
    } cout << '\n';
    return 0;
}

```
