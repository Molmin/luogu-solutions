### 题目分析
考虑到要让乘积为 $n$ ，我们容易想到的就是将其分解质因数，同时，由于 $x\,y\,>\,x\,+\,y$，因此，当将其分解之后，所有数加起来的和应该是能达到的最小和，也就是说，如果这个和小于 $m$ ，那么就有可能，不足的和用 $1$ 来补，不会改变积，但是如果这个和大于 $m$ ，就是无解情况。

还有一个问题，题目限制 $a_i$，的大小，这显然不会超过 ```1000```，因为 $n$ ，最大才 ```100``` 嘛，同时 $m$ 也不可能超过 ```1000```，因为最多也只可能出现 ```100``` 个 $1$。

剩下的细节就放在代码里了。

------------
```cpp
#include <bits/stdc++.h>
using namespace std;
int n, k, tot, m;
int p[105]; //用来存每一个质因数的个数
vector<int> C; //用来存分解的质因数
int main() {
	cin >> n >> k;
	for (int i = 2; i <= n; i++) {
		//这里并不需要判断质数，因为从小往大，非质因子一定会被前面的分解
		if (n % i == 0) {
			C.push_back(i);
			while (n % i == 0) {
				p[i]++;
				n /= i;
				tot += i; //更新最小和
				m++; //统计个数
			}
		}
	}
	if (tot > k) cout << "-1"; //无解情况
	else {
		cout << m + k - tot << endl;
		for(int t : C) { //遍历vector的简单写法
			for (int j = 0; j < p[t]; j++) {
				cout << t << " ";
			}
		}
		while (k - tot) { //不足的拿1补齐
			cout << 1 << " ";
			tot++;
		}
	}
	return 0;
}
```
完结撒花！