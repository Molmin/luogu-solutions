## 题目大意

构造数列 $a$, 使得 

$$ \prod_{i=1}^{t_a}a_i=n,\sum_{i=1}^{t_a}a_i=k$$

**以下部分中 $t_x$ 均表示 $x$ 数列中元素个数。**

## 分析

本题有两个量：和与积。我们考虑维护一个量，枚举另一个量是否符合。由于维护和的枚举量比较大，所以考虑维护乘积 $n$。

对于乘积 $n$ ，我们从 1 开始，一个个寻找 $n$ 的约数。不断地除以这个约数并且存入数列中，直到不可约为止。在每一次存入数列时，我们判断目前累加的和再加上剩下的数（也就是分拆的约数和）是否**小于等于**所要求的和 $k$。（注意是**小于等于**，因为如果和不够可以补 1，而 1 对积则没有影响）如果是，就可以直接输出答案。

如果循环结束仍没有找到解，输出 -1。

那么如何证明这个构造法正确呢？（证明部分其实可以跳过）

**引理** （小学数学结论）积一定，差小和小。

**证明**  考虑极端情况：当这个数已经被分拆成为所有质因数相乘的形式时，我们可以将这个分拆过程看作**不断寻找差最小的两个约数，直到不可约为止**。此时得出的所有约数之和一定是最小的，即：

$n=w_1\times w_2$ $······$ $(A)$ ，其中 $w_1,w_2$ 是 $n$ 中最接近的两个约数。

$(A)=v_1 \times v_2 \times v_3 \times v_4$ ，其中 $v_1,v_2$ 是 $w_1$ 中最接近的两个约数, $v_3,v_4$ 是 $w_2$ 中最接近的两个约数。

如此分解，直到 $n=p_1 \times p_2 \times ··· \times p_{t_p}$，其中数列 $p$ 均为质数。那么一定有：

$$\sum_{i=1}^{t_p}p_i \leq ··· \leq \sum_{i=1}^{t_v} v_i \leq \sum_{i=1}^{t_w} w_i \leq n$$

即 $p_1,p_2···p_{t_p}$ 为所有分拆方案中和最小的。如果最小的和都比题目要求的 $k$ 大，那么一定没有满足题意的方案。

反之，若不比 $k$ 大，一定存在一种方案：即**不断加 1，直到等于 $k$ 为止**。

至此证毕。

总结：本题虽然简单，但还是一道值得思考的构造题，尤其是构造方案的正确性。

### Code：
```cpp
#include <bits/stdc++.h>
using namespace std;
int n, m, k, p, s;
int a[1007];
int main(){
	scanf ("%d%d", &n, &k);
	m = n;//n随时变化，所以要先赋值给m 
	for (int i=2; i<=m; i++){
		while (n % i == 0){
			a[++p] = i, n /= i, s += i;
			if (s + n <= k){
				a[++p] = n;//注意一定要把剩下的数存入数组中 
				int yu = k - s - n;
				printf ("%d\n", p + yu);
				for (int j=1; j<=yu; j++) printf ("1 ");
				for (int j=1; j<=p; j++) printf ("%d ", a[j]);
				return 0;
			}
		}
	}
	puts ("-1");
	return 0;
}
```