### 引子
这题当然可以用搜索。但很容易超时，可能会超 $3$ 个点。因为时间卡的很紧，只有 $500ms$。

### 思路
我们需要让 $n$ 的因数尽可能小，最好让最后所有的因数加起来的“因数和” $s$ 别大于 $k$ 就行，但途中如果不能找出一项 $a_i$ 那就输出 `-1` 在退出。然而剩下的 $k - s$ 的差全用 $1$ 来弥补就行，之所以用 $1$ 补，是因为我们发现一个积乘以无数个 $1$ 还是自己，就可以用这一点，不会改变 $n$，只会凑出 $k$。

### 代码

```cpp
#include <cmath>
#include <cstdio>
#include <iostream>
using namespace std;
int sum[1005] = {0}, cnt, n, k, s;
int main() {
  cin >> n >> k;
  // 下面为给 n 找出所有因数代码。
  while (n != 1) {                  // n 没有因数了。
    for (int i = 2; i <= n; i++) {  // n还有因数时（现在别找“1”，因为后面还有用。）， 要把n的因数都找出来。
      if (n % i == 0) {             // 可以尽量的小，因为可能还要预留一些“1”做因数给k做加数。
        n /= i;
        sum[++cnt] = i;  // 储存因数。
        s += i;          //将 n 的因数作为 k 的加数。
        break;
      }
    }
  }
  // cnt + (k - s) 指 n 的因数个数与待会儿要用“1”补给k的个数合起来的总个数。
  if ((cnt + (k - s)) <= 0) {
    cout << -1;
    return 0;
  }
  cout << cnt + (k - s) << endl;
  for (int i = 1; i <= cnt; i++) {
    cout << sum[i] << " ";
  }
  for (int i = 0; i < k - s /*n 的因数加起来缺的，全用“1”补上。*/; i++) {
    cout << 1 << " ";  // 大家都知道 1 可以给 k 来凑加数。并且作为因数给 n 用肯定不会改变积的。
  }
  return 0;
}
```