先从 $n \le k$ 的情况考虑，那么输出方案即为先输出 $n$，再输出 $k - n$ 个 $1$。

为什么呢？

因为，$n + 1$ 正好比 $n \times 1$ 多 $1$，输出 $n - k$ 个 $1$ 以后，比原来多 $n - k$ 来，而 $n \times 1$ 则是 $n$ 本身，那么符合题意，构造方案正确。

接下来考虑其余情况。可以考虑先把 $n$ 质因数分解，变成一个数组 $a$，这样 $a$ 序列的和就小于等于 $n$ 了。

因为由于 $a$ 是通过质因数分解得到的，所以 $a$ 序列所有数相乘等于 $n$，$a$ 序列所有数相加**一定小于等于** $a$ 序列所有数相乘。

至于为什么会这样，首先，$a$ 序列所有数因为是**由 $n$ 质因数分解而来的**，所以**必定为质数**，而众所周知，质数大于等于 $2$，这是非常关键的。

如果 $a$ 序列中只有两个元素 $a_1, a_2$，那么因为 $a_1, a_2 \ge 2$，所以是这样的：

- 如果 $a_1 \le a_2$，则 $a_1 + a_2 \le 2 \times a_2 \le a_1 \times a_2$。
- 反之，如果 $a_1 > a_2$，则 $a_1 + a_2  < 2 \times a_1 \le a_1 \times a_2$。

同样，如果有三个元素，$a_1, a_2, a_3(a_1, a_2, a_3 \ge 2)$，那么，$(a_1 + a_2) \times a_3 \le a_1 \times a_2 \times a_3$，并且，$a_1 + a_2 + a_3 \le (a_1 + a_2) \times a_3$，因为我们可以把 $a_1 + a_2$ 看成一个整体，这样又变成了只有两个元素时的情况了，所以，$(a_1 + a_2 + a_3) \le (a_1 + a_2) \times a_3 \le (a_1 \times a_2 \times a_3)$，以此类推。

如果这样，$a$ 序列元素相加之和还是大于 $k$，那么输出`-1`，因为没有合适的方案，同时由于 $a$ 序列中全都是质数，**无法继续分解了**。否则，可以考虑先算出 $a$ 序列相加之和，设为 $q$，再输出 $a$ 序列所有元素和 $k - q$ 个 $1$。

Code：
```cpp
#include <bits/stdc++.h>
using namespace std;

int t[101], sz_t, zhs = 2, q;

int main() {
	int n, k, p;
	cin >> n >> k;
	p = n;
	while(p > 1) {//分解质因数
		while(p % zhs == 0) {
			
			t[++sz_t] = zhs;
			p /= zhs;
		}
		++zhs;
		
	}
	if (p > 1) t[++sz_t] = p;
	for (int i = 1; i <= sz_t; ++i) q += t[i];
	if (q > k) return puts("-1"), 0;//无解情况
	else {
		cout << sz_t + (k - q) << endl;//输出
		for (int i = 1; i <= sz_t; ++i) cout << t[i] << ' ';
		for (int i = q + 1; i <= k; ++i) cout << 1 << ' ';
	}
}
```