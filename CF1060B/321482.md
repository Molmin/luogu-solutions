## 前言
写这篇题解有三个目的：加咕值、纪念橙名的第一天，给深中高三学长加油！
## 前置芝士
学过小学奥数的应该都知道，加法运算中，如果两个一位数相加大于 $10$ ，就需要进位，即前面一位的结果 $+1$ 。
## 做法
通过这个知识点，我们下面来考虑 $S(a)+S(b)$ 与 $S(a+b)$ 的大小。

首先，如果在 $a+b$ 的过程中不存在进位，那么每一位仅仅是 $a$ 与 $b$ 中的数位相加，因此 $S(a+b)=S(a)+S(b)$ 。现在考虑每一次进位，设这一位上 $a$ 与 $b$ 的数码分别为 $x$ 与 $y$ ，则进位后 $a+b$ 的这一位是 $x+y-10$ ，而其后面一位的结果 $+1$ ，由此可知，每次进位 $S(a+b)$ 在不进位基础下 $-9$ ，换句话说，就是进位次数越多，相加后的数码和就越小。

回到原题，设 $a+b$ 过程中进了 $k$ 位，有 

$S(n)=S(a+b)=S(a)+S(b)-9k$ 

从而得到：

$\boxed{S(a)+S(b)=S(n)+9k}$

由于 $S(n)$ 的值固定，要是 $S(a)+S(b)$ 最大，必然有 $k$ 最大。因此只需要考虑一个数表达为两个数之和最多进的位数。设 $n$ 为 $t$ 位数。当末位不为 $9$ 时，如果首位 $\leqslant3$ ，则最多进行 $t-1$ 次进位；如果首位 $\geqslant 4$ ，则最多进 $t$ 位。当末位为 $9$ 时，每种情况比前一种少 $1$ （这应该很好理解，因为最后一位不能进位），这样思路就出来了。
## 代码
按照思路写的代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
long long n, first, last, d, s;
int main()
{
	cin >> n;
	last = n % 10;
	while (n)
	{
		if (n < 10) first = n;
		s += n % 10;
		d++;
		n /= 10;
	}
	//cout << first << " " << d << " " << s;
	/*若末位为9*/
	if (last == 9)
	{
		if (first <= 2) cout << s + 9 * (d - 2);
		else cout << s + 9 * (d - 1);
	}
	else
	{
		if (first <= 2) cout << s + 9 * (d - 1);
		else cout << s + 9 * d;
	}
}
```
交了之后，[第一个数据](https://www.luogu.com.cn/record/77060188)都过不去，恶心的是 CF 不能看评测结果。随手试了下 $0$ ，输出 $-9$ ，好像一位数要特判

代码就不贴了，因为[………](https://www.luogu.com.cn/record/77060531)

看来思路和 AC CODE 之间还是有差距的，又试了试 $39$ ，得到 $21$ ，因为第一位和最后一位 $9$ 挨在一起，所以两位数也要特判 