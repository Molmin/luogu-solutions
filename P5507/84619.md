基本思路和算法（A*）大佬们都讲的很详细了，上面的代码写的也很清楚，这里就提供一个小小的但很实用优化。

离AC只差一步的可以来看看

《算法竞赛进阶指南》第124页写到“估价函数的估值不能大于未来的实际价值”，但在这题中，稍稍提高一点估值可以大大提高程序运行效

[优化前](https://www.luogu.org/record/23140709)

[优化后](https://www.luogu.org/record/23154481)

优化前后效率快了将近一倍，而优化所做的所有改变就是在估价函数上乘了一个系数

一般的估价函数：每个旋钮距离目标状态（1）的差值之和除以2（取上整）
```cpp
bool operator < (const e &a) const {
      return s + (v >> 1) + (v & 1) > a.s + (a.v >> 1) + (a.v & 1);
}
```
注：

1、s指当前状态已经操作的次数，v表示每个旋钮距离目标状态的差值之和（估价函数）

2、加上（v&1）是为了取上整（也许没什么用）

3、该比较函数写在结构体中,结构体名称为e

不难发现，这个估价函数是一个很美好的理想状态（每次操作都让两个旋钮向目标状态靠近），但现实中很难达到，可以让估值更准确一些，于是我在 v 上乘一个稍大于1的系数（1.1, 1.2, 1.3）均可（下面代码中写的1.3，因为这个比较快），可以自己调试

变成这样：
```cpp
bool operator < (const e &a) const {
      return s + (v >> 1) * 1.3 + (v & 1) > a.s + (a.v >> 1) * 1.3 + (a.v & 1);
}
```

小小的改变就上效率大大提高，快了将近400ms（数据最大的点快了300ms，~~虽然巨佬们总用时都不到300ms~~）

其他代码就不放了，上面的写得好看多了qwq