## 期望DP/概率DP

一般来说，期望DP找到正确的状态定义后，转移是比较容易想到的。

有时期望DP需要以最终状态为初始状态转移，即逆推.如 $f[i]$ 表示期望还要走 $f[i]$ 
步到达终点。形如 $f[i]=Σp[i->j]*f[j]+w[i->j]$ 其中 $p[]$ 表示转移的概率， $w[]$ 表示转移对答案的贡献。一般来说，初始状态确定时可用顺推，终止状态确定时可用逆推

## SP1026 FAVDICE - Favorite Dice
[SP1026 FAVDICE - Favorite Dice](https://www.luogu.com.cn/problem/SP1026)

## 题意
有T组数据，每组数据一个整数 $n$ ，表示给你一个 $n$ 面的骰子，求期望掷几次能使每一面都被掷到

## Solution
### 状态设计
$f[i]$ 表示已经掷到过i个不同的面，还期望掷多少次使得每一个面都被掷到

由我们设计的状态可以知道，最终状态是 $f[n]$ 即已经掷完所有面，还需掷多少次
，易知 $f[n]=0$ ,所以我们是已知最终状态,可以进行逆推

### 状态转移

对于 $f[i]$ ，现在每掷一次骰子，
都会有以下两种情况

* 1.有 $\frac{i}{n}$ 的概率掷到已经掷到过的面，此时还是需要多 $f[i]$ 次

* 2.有$\frac{n-i}{n}$的概率掷到没有掷到过的面，此后就已经掷到过 $i+1$ 个面了，还需掷 $f[i+1]$ 次

注意，无论是上面的哪一种情况都需要掷一次骰子,所以状态转移方程可以表示为

 $f[i]=$ $\frac{i}{n}$$ *f[i]+$$\frac{n-i}{n}$$*f[i+1]$

移项化简得

 $f[i]=f[i+1]$+$\frac{n-i}{n}$
 
 下面是代码
 
 ```
 #include<bits/stdc++.h>
using namespace std;
const int N=1005;
int t,n;
double f[N];
int main()
{
	scanf("%d",&t);
	while(t--)
	{
		scanf("%d",&n);
		f[n]=0;
		for(int i=n-1;i>=0;i--)
			f[i]=f[i+1]+1.0*n/(n-i);
		printf("%.2lf\n",f[0]);
	}
} 
 ```