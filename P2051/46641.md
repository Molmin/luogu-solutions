　　在qbxt学了这个题，虽然也没怎么听明白，但是在改了八次状态转移方程之后，我终于！终于！过了这个题（心塞）

　　那么，用钟长者的话来说，这个题就属于『瞎DP』。

### 思路

　　八九不离十的DP。那么，该怎么表示状态呢？

　　三维数组f[i][j][k]（要不是钟长者我也想不到Orz）

　　i表示已经搞完了几行，j表示有几列放了1个棋子，k表示几列放了2个棋子。为什么要这么表示呢？象棋我觉得大家都会（都比我强orz），如果某一行或者某一列有三个炮的话，两边的炮就会隔着中间的炮打起来。（中间的炮：你们......？）

　　所以，每一列的状态只有可能是：没有炮，一个炮和两个炮。一个炮用j表示，两个炮用k表示，没有炮就用（m - j - k）表示。

　　那么，就开始我们的表演吧！
### 状态转移

```cpp
	f[i + 1][j][k] = (f[i][j][k] + f[i + 1][j][k]) % mod;
	if(j >= 1) f[i + 1][j - 1][k + 1] = (f[i + 1][j - 1][k + 1] + f[i][j][k] * j) % mod;
	if((m - k - j) >= 1) f[i + 1][j + 1][k] = (f[i + 1][j + 1][k] + f[i][j][k] * (m - k - j)) % mod;
	if(j >= 2) f[i + 1][j - 2][k + 2] = (f[i + 1][j - 2][k + 2] + f[i][j][k] * C(j)) % mod;
	if((m - j - k) >= 2) f[i + 1][j + 2][k] = (f[i + 1][j + 2][k] + f[i][j][k] * C(m - j - k)) % mod;
	if((m - k - j) >= 1 && j >= 1) f[i + 1][j][k + 1] = (f[i + 1][j][k + 1] + f[i][j][k] * (m - k -  j) * j) % mod;
```

　　好长，看的眼晕（反正对我来说是这样子......）

　　一句一句来看：

```cpp
f[i + 1][j][k] = (f[i][j][k] + f[i + 1][j][k]) % mod;
```

　　这句的意思就是啥也不放，这样就加上自己本来的状态以及上一行的状态就可以了

```cpp
if(j >= 1) f[i + 1][j - 1][k + 1] = (f[i + 1][j - 1][k + 1] + f[i][j][k] * j) % mod;
```

　　这句就是如果有一列或几列只放了一个炮的话，那我们不就可以往这一列来一（个）炮？这样的话，这一列就变成有两个炮了，所以，有一个炮的列就少了一。所以我们将j减1，k加1.乘以j是因为有j种可能。本来应该是C（1，j），但是这个东西的答案就是j，所以就直接写j了

```cpp
if((m - k - j) >= 1) f[i + 1][j + 1][k] = (f[i + 1][j + 1][k] + f[i][j][k] * (m - k - j)) % mod;
```

　　关于(m - k - j)我们之前也提到过了，就是『没有炮的列』。那么如果有没有炮的列，也可以往上来一炮，那么有一个炮的列就多了一个。

```cpp
	if(j >= 2) f[i + 1][j - 2][k + 2] = (f[i + 1][j - 2][k + 2] + f[i][j][k] * C(j)) % mod;
    if((m - j - k) >= 2) f[i + 1][j + 2][k] = (f[i + 1][j + 2][k] + f[i][j][k] * C(m - j - k)) % mod;
    if((m - k - j) >= 1 && j >= 1) f[i + 1][j][k + 1] = (f[i + 1][j][k + 1] + f[i][j][k] * (m - k -  j) * j) % mod;
```

　　既然前面明白了，这地方也就会好明白的多。就是如果有两个没有炮的列，或者两个有一个炮的列，又或者一个有一个炮的列一个没炮的列，那就可以往上放俩炮，对吧？注意一下相应的列的数量的改变（语言逐渐暴躁）。

　　那么在这里就给出整个程序好啦。那个C表示的是排列组合，下边（还是上边？？）那个数是2.

```cpp
#include <iostream>
#include <stdio.h>
using namespace std;
#define ll long long
#define maxn 110
#define mod 9999973

int n, m;
int C(int _){
    return _ * (_ - 1) / 2;
}
ll f[maxn][maxn][maxn];
//数组表示已求前i行，有j列放了1个炮，有k列放了2个炮
int main(){
    cin >> n >> m;
    f[0][0][0] = 1;
    for(int i = 0; i <= n; ++i)
        for(int j = 0; j <= m; ++j)
            for(int k = 0; j + k <= m; ++k)
                if(f[i][j][k]){
                    f[i + 1][j][k] = (f[i][j][k] + f[i + 1][j][k]) % mod;
                    if(j >= 1) f[i + 1][j - 1][k + 1] = (f[i + 1][j - 1][k + 1] + f[i][j][k] * j) % mod;
                    if((m - k - j) >= 1) f[i + 1][j + 1][k] = (f[i + 1][j + 1][k] + f[i][j][k] * (m - k - j)) % mod;
                    if(j >= 2) f[i + 1][j - 2][k + 2] = (f[i + 1][j - 2][k + 2] + f[i][j][k] * C(j)) % mod;
                    if((m - j - k) >= 2) f[i + 1][j + 2][k] = (f[i + 1][j + 2][k] + f[i][j][k] * C(m - j - k)) % mod;
                    if((m - k - j) >= 1 && j >= 1) f[i + 1][j][k + 1] = (f[i + 1][j][k + 1] + f[i][j][k] * (m - k -  j) * j) % mod;
                }
    ll ans = 0;
    for(int i = 0; i <= m; ++i){
        for(int j = 0; i + j <= m; ++j){
            ans = (ans + f[n][i][j]) % mod;
        }
    }
    cout << ans << endl;
    return 0;
}

```

　　顺便安利我的新视频：[【外传】【初音÷oi】状态转移](https://www.bilibili.com/video/av29799588/)