好像这里的题解我都看不明白啊，算了，自己做吧！

其实这题就是状态转移比较多，比较混杂吧。

其实认认真真的想还是有点思路的，

现在我想把我的思路分享给大家，

这可能是本题题解中唯一一篇pas写的但是也是唯一一篇正常蒟蒻看的懂的题解吧？


题目大意：n\*m的棋盘上放若干颗棋子，要求每3颗棋子不共行，不共列求放法总数。

首先大状态：F[i,j,k]前i行 有j列放了一个棋子，k列放了2个棋子的  可能性个数

那么此时没有放棋子的列有：m-j-k 列

状态的种类数：没放棋子（empty）、空行、一列放了1个棋子，一列放了2个棋子，1列空棋子，

所以状态总数：没放棋子、放一个棋子在原有1个棋子上的、放1个棋子在没有放棋子的列上的、放两个棋子都在没有放棋子的列上、两个棋子都放在两个有1个棋子的列上、一个棋子在无棋子列且一个棋子放在有一个棋子的列上。

Sum（求和） {

- 没放棋子 F[i-1,j,k]

explain: Empty，不解释了；

- 放一个棋子在原本有一个棋子列上的 F[i-1,j+1,k-1] \* (j+1)f[i,j,k]

explain: 由于f[i,j,k]是由F[i-1,j+1,k-1]转移而来，所以用过去状态推现在状态，j+1表示1个棋子的列原来要多一个（现在少一个），k-1表示1个棋子的列原来要少一个（现在多一个），乘上(j+1)表示原来可以有j+1个位置可供放。

- 放一个棋子在原本没有棋子列上的 F[i-1,j-1,k] \* (m-(j-1)-k)

explain: 有些东西2中说过了，这里不再赘述，看上面就可以了，其实比较简单。原来没有多出1列有1个棋子的现在多出来了，所以从f[i-1,j-1,k]转移，这里发现一共有(m-(j-1)-k)列是空的（只有这几列能放）

- 放两个棋子，都在没有棋子的列上的 F[i-1,j-2,k]  \* C(m-j-k,2)

explain: 原来1个棋子列现在多了两个，所以从f[i-1,j-2,k]转移，原来一共有(m-j-k)个空位，现在要取其中的两个所以一共的可能性是C(m-j-k,2)

- 都在有一个棋子的列上 F[i-1,j+2,k-2] \* C(j,2)

explain: 原来有1个棋子的列少了2个，有2个棋子的列多了2个，所以从f[i-1,j+2,k-2]推出，原来一共有j个位置可放，现在要放2个棋子，所以可能性是C(j,2)

- 一个放在无棋子列，一个在有一个棋子的列上 F[i-1,j,k-1] \* j\* (m-j-（k-1))

explain: 对于f[i,j,k]中放在有1个棋子的行上的j的数目不变，k的数目增加所以前i行的k的数目要-1，可能性放在有1个棋子的格子上是有j个可能，放在空的格子上有的可能是m-j-(k-1)；


  }
AC的代码：

```cpp
var f:array[0..100,-2..100,-2..100]of   qword;
    n,m,i,j,k,ans:longint;
function ff(x:longint):longint;//求上述的C排列
begin
 exit(x*(x-1) div 2);
end;
begin
 readln(n,m);
 fillchar(f,sizeof(f),0);
 f[0,0,0]:=1;
 for i:=1 to n do
  for j:=0 to m do
   for k:=0 to m-j do
    f[i,j,k]:=(f[i-1,j,k]+f[i-1,j+1,k-1]*(j+1)+
    f[i-1,j-1,k]*(m-j-k+1)+f[i-1,j-2,k]*ff(m-j+2-k)+
    f[i-1,j+2,k-2]*(j+2)*(j+1) div 2+
    f[i-1,j,k-1]*j*(m-j-k+1)) mod 9999973;
 for i:=0 to m do
  for j:=0 to m do
   ans:=(ans+f[n,i,j])mod 9999973;
 writeln(ans);
end.

```