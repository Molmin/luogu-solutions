不同于其他人的做法，我提出了一种时空复杂度较低的算法，在本题中为 $O(\max(N,M)^2)$。  
考虑 $ f[i][j][k] $ 表示有 $i$ 行 $j$ 列，并且在第 $i$ 行选了 $k$ 个的答案，$0\le k\le 2$ （后面 $k$ 扩展到了 $3$ ）。  
发现两条性质：  
1. 显然有不管在第 $i$ 行选了 $k$ 个，还是在别的行选了 $k$ 个，答案都是一样的。    
2. 显然有“ $i$ 行 $j$ 列且行选 $k$ 个”等价于“ $j$ 行 $i$ 列且列选 $k$ 个”。  

令 $f[i][j]$ 从 $f[i-1][j][...]$ 转移，会发现 $k$ 为 $0$ 或 $1$ 很好维护。  
+  $k=0$ 时，$f[i][j][0]=f[i-1][j][0]+f[i-1][j][1]+f[i-1][j][2]$   


+  $k=1$ 时，所在**列j**必须只选了 $1$ 或 $0$ 个，选的值有 $j$ 个位置去放。进而根据性质：  
	 $f[i][j][1]=j*(f[j][i-1][0]+f[i-1][j][1])$   


+  $k=2$ 时情况比较复杂，组合数计算出位置有 $j*(j-1)/2$ 种方案，每种方案都要求要有两列都选少于两个。**因此引入“** $i$ **行** $j$ **列，有两列都选一个”为** $f[i][j][3]$ ，发现很好搞：  
	 $f[i][j][2]=j*(j-1)/2*(f[j-1][i-1][0]+2* f[j-1][i-1][1]+f[j][i-1][3])$   
   其实还是蛮难理解的， $f[j-1][i-1][0]$ 等于 $i-1$ 行 $j$ 列有两列都选 $0$ 的个数，$f[j-1][i-1][1]$ 等于 $i-1$ 行 $j$ 列有两列选 $01$ 或 $10$ 的个数，故乘 $2$ 。  


+  $k=3$ 时，我们愉快地发现，不用再新加入 $4$ 或 $5$ 等等去维护了！  
	 $f[i][j][3]=j*(j-1)* (f[j-1][i-2][0]+2* f[j-1][i-2][1]+f[j][i-2][3])+j* f[j][i-2][0]$   
   前面一大项是 $2$ 列选两个 $1$ 不同时在同列的个数，后面一小项表示在同列的个数。  

至此，递推式完成了。  
不过会发现递推顺序很奇怪，需要类似先剥洋葱一样遍历 $\min(N,M)^2$ ，然后再遍历余下部分。我比较懒，于是使用了记忆化搜索去搞。  
递推边界： $i<0||j<0$ 时为 $0$，$i=0\&\&j=0$ 时，$k$ 为 $0$ 则为 $1$，否则为 $0$。  
说句闲话，如果每行每列最多放 $3$ 个那就不适用这种算法了（尽管复杂度可以，思路会很复杂）。  
```  
#include<iostream>
#include<cstdio>
#include<cstring>
#define LL long long
#define check(i,j,k)  if(f[i][j][k]==-1){f[i][j][k]=dfs(i,j,k);}
using namespace std;
const int maxn=1010,mod=9999973;
int N,M;LL f[maxn][maxn][4];
int qd(){
	int rt=0;char c=getchar();
	while(c<'0'||c>'9')  c=getchar();
	while('0'<=c&&c<='9')  rt=(rt<<3)+(rt<<1)+c-48,c=getchar();
	return rt;
}
LL dfs(int x,int y,int k){
	if(x==0||y==0)  return f[x][y][k]=(k?0:1);
	if(x<0||y<0)  return 0;
	if(k==0){
		check(x-1,y,0);check(x-1,y,1);check(x-1,y,2);
		f[x][y][k]=(f[x-1][y][0]+f[x-1][y][1]+f[x-1][y][2])%mod;
	}
	if(k==1){
		check(y,x-1,0);check(y,x-1,1);
		f[x][y][k]=y*(f[y][x-1][0]+f[y][x-1][1])%mod;
	}
	if(k==2){
		check(y-1,x-1,0);check(y-1,x-1,1);check(y,x-1,3);
		f[x][y][k]=y*(y-1)/2*(f[y-1][x-1][0]+2*f[y-1][x-1][1]+f[y][x-1][3])%mod;
	}
	if(k==3){
		check(y,x-2,0);check(y-1,x-2,0);check(y-1,x-2,1);check(y,x-2,3);
		f[x][y][k]=(y*(y-1)*(f[y-1][x-2][0]+2*f[y-1][x-2][1]+f[y][x-2][3])+y*f[y][x-2][0])%mod;
	}
//	printf("%d %d %d:%lld\n",x,y,k,f[x][y][k]);
	return f[x][y][k];
}
int main(){
	N=qd(),M=qd();
	memset(f,-1,sizeof(f));
	printf("%lld\n",dfs(N+1,M,0));
	return 0;
}
```