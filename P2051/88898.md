题目描述
==

这次小可可想解决的难题和中国象棋有关，在一个$N$行$M$列的棋盘上，让你放若干个炮（可以是$0$个），使得没有一个炮可以攻击到另一个炮，请问有多少种放置方法。大家肯定很清楚，在中国象棋中炮的行走方式是：一个炮攻击到另一个炮，当且仅当它们在同一行或同一列中，且它们之间恰好 有一个棋子。你也来和小可可一起锻炼一下思维吧！


----------


输入输出格式
==

输入格式：
--
一行包含两个整数$N$，$M$，之间由一个空格隔开。

输出格式：
--
总共的方案数，由于该值可能很大，只需给出方案数模$9999973$的结果。

输入输出样例
--

输入样例#1： 
--
$1 3$
输出样例#1： 
--
$7$


----------


说明
==

样例说明
--

除了$3$个格子里都塞满了炮以外，其它方案都是可行的，所以一共有$2*2*2-1=7$种方案。


----------


数据范围
==
$100$%的数据中$N$和$M$均不超过$100$

$50$%的数据中$N$和$M$至少有一个数不超过$8$

$30$%的数据中$N$和$M$均不超过$6$


----------


合理分析
==
根据此题的数据范围，是网络流/状态压缩DP的复杂度，显然可以看出这是一个状态压缩DP，因为每列最多只能放0~2个棋子，所以可以考虑敲一个3进制的状态压缩DP，下面附上代码及解决思路

```
#include<cstdio>
#include<iostream>
#define maxn 110
#define mod 9999973
using namespace std;
long long  f[maxn][maxn][maxn];
long long n,m;
int main()
	{
	cin>>n>>m;
	f[0][0][0]=1;
	for(int i=1;i<=n;i++)
		{
			for(int j=0;j<=m;j++)
		{
			int MAX_K=m-j;
			for(int k=0;k<=MAX_K;k++)
				{
				f[i][j][k]=f[i-1][j][k];//一个棋子也不放的情况
				if(j>=1) f[i][j][k]=(f[i][j][k]+f[i-1][j-1][k]*(m-k-j+1))%mod;//放置1个棋子，并且此棋子放置在原来有0个棋子的一列上
				if(k>=1) f[i][j][k]=(f[i][j][k]+f[i-1][j+1][k-1]*(j+1))%mod;//放置1个棋子，并且此棋子放置在原来有1个棋子的一列上
				if(j>=2) f[i][j][k]=(f[i][j][k]+f[i-1][j-2][k]*(((m-j-k+1)*(m-j-k+2))/2))%mod;//放置两个棋子，并且两个棋子都放置在原来有0个棋子的两列上
				if(j&&k) f[i][j][k]=(f[i][j][k]+f[i-1][j][k-1]*(j*(m-j-k+1)))%mod;//放置两个棋子，并且两个棋子分别放置在原来有0个棋子的一列和原来有1个棋子的一列上
				if(k>=2) f[i][j][k]=(f[i][j][k]+f[i-1][j+2][k-2]*(((j+1)*(j+2))/2))%mod;//放置两个棋子，并且两个棋子都在原来有1个棋子的两列上
				}
		}	
		}
	long long ans=0;
	for(int i=0;i<=m;i++)
		{
		int max_n=m-i;
		for(int j=0;j<=max_n;j++)
			{
				ans=(ans+f[n][i][j])%mod;
			}
		}
	cout<<ans<<endl;
	return 0;
	}
```