学C++以来终于怼过了第一道紫题我真是嗨到不行啊！！！！！（以指凿颅ing）

首先我们要知道最基本的规则；每一行每一列的~~妻子~~棋子数不可以超过两个。最开始我们想到的便是玄学打表，但是在最大数据量为100x100的情况下就算除模都有792607个方案，而且除模的次数不下二十次，如果一个个方案打表的话必定会TLE。

那该怎么办呢？这时候我们就要将思维给逆转过来 （成步堂龙一脸）

我们所要求的仅仅是方案数（取模后的结果），也就是说我们可以试着在不求出各种方案具体方法的情况下直接得出方案数。

那么该怎么做才能做到只求方案数呢？答；开一个三位数组f[i][j][k]，表示做到第i行/列有j个列/行有一个~~妻子~~棋子，k列/行有两个棋子时的方案数。

之后就是对于方案的讨论，

    不放棋子的时候，我们直接继承上一行的方案数，即f[i][j][k]=f[i-1][j][k]

放一个棋子时有以下方案

    在有一个棋子的一列放，此时方案数f[i][j][k]+=f[i-1][j+1][k-1]*（j+1）
    在没有棋子的一列放，此时方案数f[i][j][k]+=f[i-1][j-1][k]*(m-(j-1)-k)
    
 放两个棋子时有以下方案
   
    两个棋子都分别放在没有棋子和有一个棋子的一列,此时方案数f[i][j][k]+=f[i-1][j][k-1]*(j*(m-j-k+1))
    两个棋子都放在没棋子的列，此时方案数f[i][j][k]+=f[i-1][j-2][k]*(((m-j-k+1)*(m-j-k+2))/2)
    对于乘的这个数，请各位自行回去翻课本找无序数组这一章看看_(:з」∠)_
    两个棋子都放在有一个棋子的列，此时方案数f[i][j][k]+=f[i-1][j+2][k-2]*(((j+1)*(j+2))/2)
    
最后是要注意的几个要点；

    1.数组一定要开longlong，就算你是在算方案过程中除模，也有可能会加到超过int范围的数（我因为这个原因这一题三天40pts所以一定要说）
    2.若是开三层循环，i要从1开始进行，倘若从0进行就会在方案数中加一个f[-1][j][k]，这显然是要出问题的
    3.倘若按我这种思路，数组边界要开到103，因为i=100时我们可能会要加f[100][102][100]，若是只定到101加超界数组是药丸的。
    4.最好在运算时就去取模，虽说这一题没必要，但未来若是出现n,m到1000,10000时可能会有long long也装不下的情况
    5.这题有动规吗？？？？（黑人问号）
    
最后是期待已久的总代码

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cmath>
#include<cstring>
using namespace std;
int mod=9999973;
//题目所需的膜， -1s-1s-1s-1s..... 
long long f[104][104][104];
//f[i][j][k]第i行有j列一棋子，k列二棋子的方案数  
int n,m;
inline int C(int x)    
{
    return ((x*(x-1))/2)%mod;
}
//数学中的C ,如果不知道什么意思建议回去翻一下高中课本（____________________光速后退________(:з」∠)_ ) 
inline int read()
{
    int ret=0;
    char c=getchar();
    while (c<'0' || c>'9') c=getchar();
    while (c>='0' && c<='9'){
        ret=ret*10+c-'0';
        c=getchar();
    }
    return ret;
} //"简单"的读入优化 
int main()
{
    n=read(),m=read();
    f[0][0][0]=1;
    for (int i=1;i<=n;i++)
    {
        for (int j=0;j<=m;j++)
        {
        	int maxj=m-j;
            for (int k=0;k<=maxj;k++) 
            {
                f[i][j][k]=f[i-1][j][k];
				//一个棋子也不放的情况
                if(j>=1) f[i][j][k]=(f[i][j][k]+f[i-1][j-1][k]*(m-k-j+1))%mod;
				//放置1个棋子，并且此棋子放置在原来有0个棋子的一列上
                if(k>=1) f[i][j][k]=(f[i][j][k]+f[i-1][j+1][k-1]*(j+1))%mod;
				//放置1个棋子，并且此棋子放置在原来有1个棋子的一列上
                if(j>=2) f[i][j][k]=(f[i][j][k]+f[i-1][j-2][k]*(((m-j-k+1)*(m-j-k+2))/2))%mod;
				//放置两个棋子，并且两个棋子都放置在原来有0个棋子的两列上
                if(j&&k) f[i][j][k]=(f[i][j][k]+f[i-1][j][k-1]*(j*(m-j-k+1)))%mod;
				//放置两个棋子，并且两个棋子分别放置在原来有0个棋子的一列和原来有1个棋子的一列上
                if(k>=2) f[i][j][k]=(f[i][j][k]+f[i-1][j+2][k-2]*(((j+1)*(j+2))/2))%mod;
				//放置两个棋子，并且两个棋子都在原来有1个棋子的两列上
                }
            }
    }
    long long ans=0;
    for (int i=0;i<=m;i++)
    {
    	int maxi=m-i;
        for (int j=0;j<=maxi;j++)
        {
            ans=(ans+f[n][i][j])%mod;
        }
    }
    cout<<ans;
    return 0;
}
```

今天瘟疫之星开了吗.....（国际服仓鼠没瘟疫之星要死了....）

