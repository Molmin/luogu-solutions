关于$Chess$的题目真是越来越多，日新月异。最经典的莫过于$8$皇后，乃至$n$皇后，而本题也非常值得练习（~~居然是黄题难度~~）。

话不多说，我们先来分析一下样例$1$：

![](https://cdn.luogu.com.cn/upload/image_hosting/5pxlwbvy.png)

对于样例$1$，我们先将车放在$a1$，把马放在$b2$。根据上图，我们可以发现，车控制着它所在的行和列（除非中间有棋子阻挡，事实上任何车都是如此）。而在本题中，如果车和马位于同行或同列，就直接输出$0$并退出程序。而马则能“走日”，因此它可以控制$8$个格子（除非超出棋盘边界）。但是，由于第三个放置的棋子为马，因此对于马吃马的现象就不需考虑，而对于马吃车的情况还需要注意——图中用橙色的$X$表示（这里马不能位于$b3,c2$，否则会有$Nxa1$）

样例$2$的图如下：

![](https://cdn.luogu.com.cn/upload/image_hosting/52um9vy5.png)

对于样例$2$，我们放置棋子之后，用上述的符号表示占领情况——车依然占领它所在的行、列，而马这次把$8$个格子都占领了。我们可以发现，$b6,c7$是不可以放置马的，因为这样就会有$Nxa8$。

对于程序的思路，我们先设置一个马的走向常量，即马每一次的走法可以是：（用$(a,b)$表示向上$a$单位，向右$b$单位）

$(-2,-1),(-1,-2),(-2,1),(-1,2),(1,-2),(2,-1),(2,1),(1,2)$

简单来说，就是马可以向上$±1$，向右$±2$或者向上$±2$，向右$±1$。还需注意的是，国际象棋中没有“蹩马腿”一说，因此这大大简化了操作难度。

而输入之后，我们可以直接进行如下基本判断：

①如果马和车位于同行或者同列，输出0并直接退出程序

②如果车所在格子被马控制，输出0并直接退出程序

有了①的特判，就不可能出现“挡子”的现象——除非新加入的马被车所控制。

该题对于马的位置的枚举，可以暴力$[a,h],[1,8]$枚举，因为这样时间复杂度也不高。当然，在循环过程中，只要出现与车同行同列就直接用$continue$语句直接跳过该次循环。

我们可以设置一个$bool$二维数组来保存对应位置是否可以放马，最后再进行统计。

等了好久，你们最喜欢的$AC$代码终于来了：

```cpp
#include<cstdio>
int N[2][8]={{-1,-2,-2,-1,1,2,2,1},{-2,-1,1,2,-2,-1,1,2}},ry,ny,rx,nx,i,j,k,s;
//rx,ry保存车的坐标，nx,ny为马的坐标，N[][]为马的位置增量坐标，i、j、k为循环使用，s保存可放马的格子数量
bool a[9][9];//bool数组的用途，上面已经说过
int main()
{
    scanf("%c%d\n%c%d",&rx,&ry,&nx,&ny);//把整型变量直接当字符输入（强制转换）
    rx-='a'-1;
    nx-='a'-1;//把输进来的字符进行操作，让它变成整型（例如：a-->1，h-->8）
    if(rx==nx||ry==ny)
    {
        printf("0");
        return 0;
    }//特判——上文已提及
    for(i=1;i<9;i++)
    {
        for(j=1;j<9;j++)
        {
            if((i==rx&&j==ry)||(i==nx&&j==ny))continue;
            if(i==rx||j==ry)continue;//特判——上文已提及
            a[i][j]=1;//初始来说，这个坐标的bool值为真
            for(k=0;k<8;k++)//对马的占领格子进行讨论
            {
                if(i+N[0][k]<1||i+N[0][k]>8||j+N[1][k]<1||j+N[1][k]>8)continue;//超出边界就跳过该次循环
                if(i+N[0][k]==rx&&j+N[1][k]==ry)//如果能够使得Nx{rx}{ry}，就直接标记为0，跳过该次循环（国象大佬勿喷）
                {
                    a[i][j]=0;
                    break;
                }
                if(i+N[0][k]==nx&&j+N[1][k]==ny)//同理可得，如果能马吃马，就标记为0
                {
                    a[i][j]=0;
                    break;
                }
            }
        }
    }
    for(i=1;i<9;i++)for(j=1;j<9;j++)if(a[i][j])s++;//计算出值为真的数量
    printf("%d",s);//完美输出
}
```