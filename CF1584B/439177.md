看到大佬们的方法都比我简单，那么小人就阐述一下自己的思路吧。

通过计算，我们可以得到用 $1×3$ 的方式最优，所以我们要尽可能地多用。

其实有特殊情况，如果 $n,m$ 中至少有一个为 $3$ 的倍数就输出 $n×m÷3$

除此之外，我们要用比较法计算矩阵中个数为 $3$ 的倍数的最大子矩阵计算 $n×m÷3$ 的公式。

排开刚才的最大 $3$ 倍数子矩阵，那么所剩下的子矩阵一定不是 $3$ 的倍数，我们又在这个子矩阵中找到剩下的最大 $3$ 倍数子子矩阵，又套用公式 $n×m÷3$ 。

刚才两次操作之后，剩下的子矩阵一定不是 $3$ 的倍数了，一定！！！！！

此时矩阵的 $n,m$  都小于等于 $2$ ，所以我们用他的 $n,m$ 最小值就可以了。

累加以上答案即可 AC。

然后我这复杂而晦涩的代码就是这个：

```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
	int T;
	cin>>T;
	while(T--)
	{
		long long n,m;
		cin>>n>>m;
		cout<<min(n/3*m+(m/3)*(n%3),m/3*n+(n/3)*(m%3))+min(n%3,m%3)<<endl;
	}
	return 0;
}
```