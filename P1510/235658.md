## 01背包“水题”

  是的，它确实是一道水题，但是它多了一个求最少体力的问题，如果思路不清楚就可能混乱。~~（比如我第一遍打完01背包模板没过样例，回过头看自己程序都不知道自己在写什么）~~
  
  但理好思路后一切就变得豁然开朗了起来。这道题让我们算精卫是否能把东海**填平**，并求能填平的最小**体力**。我们可以看到体力是本题的要点，那我们不妨设数组f[i]表示消耗i的体力可以搬运的最多石子。然后套用01背包模板，算出每一个f的值
  
  不会用一维数组实现01背包的看一下我的博客，里面有超级详细的解释[01背包，完全背包](https://www.luogu.org/blog/llzzxx712/solution2-p2722)
  
  最后我们就可以判断用全部的体力（也就是i==c）是否能填平，如果不能，就输出“Impossibel”，不然就一直向下找，直到找到刚好够填平时消耗的体力，用总体力一减，就是答案了，总代码只有20行，是不是很棒呢？
  
------------
下面附上AC代码
```cpp
#include<iostream>
using namespace std;
int v,n,c,tj[10002],tl[10002];//v,n,c同题目意思， tj表示体积，tl表示体力 
int f[10002];//f[i]表示消耗i的体力最多可以搬运的石子 
int main()
{
	cin>>v>>n>>c;
	for(int i=1;i<=n;i++) cin>>tj[i]>>tl[i];//输入v,n,c和每块石头的体积和搬它要消耗的体力 
	for(int i=1;i<=n;i++)
		for(int j=c;j>=tl[i];j--)
			f[j]=max(f[j],f[j-tl[i]]+tj[i]);//一维数组求01背包，不断更新消耗j的体力可以搬多少石子
	if(f[c]<v) cout<<"Impossible";//最终结果出来后，如果用上所以体力（c），能搬的体积仍小于需要的体积，那么就输出不能 
	else{//如果可以 
		int i=c;
		while(f[i]>=v) i--;//那么就不断递减找到刚好够搬所需的体力（注意：这里并不一定要刚好填满） 
		cout<<c-(i+1);//由于while循环找到的是刚好不能搬时的体力，所以刚好够搬的体力就是现在的i加上1 
	}//再用总体积减一下，就是剩下的最大体力了 
	return 0;
}

```
