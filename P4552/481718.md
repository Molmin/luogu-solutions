## 题目思路：
这题差分即可，经典题，区间变数，多次区间修改，用差分数组。将两数之差存到另一个数组中就是差分数组，若这个数组为 $diff$ ，原数组为 $a$，则 $diff_i=a_i-a_{i-1}$。

好，开始画图：
| 原数组： | 1 | 3 | 4 | 6 | 9 | 2 |
| -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: |
| 差分数组： | 1 | 2 | 1 | 2 | 3 | -7 |
如上图，其实差分数组最后还有个 2，我画了个图，有点丑，请谅解：
![](https://cdn.luogu.com.cn/upload/image_hosting/yz3n36a7.png)
好，然后我们通过这个数据来过一下。  

看第一问：因为我们要把原数组之间的差变为相同的数，也就是说，我们要把 $diff$ 数组都变为 0，但注意，由于差分数组的性质，$diff_1 =a_1$，所以我们应该从 2 开始循环。我们要把 $diff_2$ 到 $diff_n$ 中的数变为 0。一次选一正一负，因为差分数组中为正数时，原数增加，差值减少；若为负数，原数增加，差值减少。  
详细可以见图：
![](https://cdn.luogu.com.cn/upload/image_hosting/kxu92bkp.png)

到这里我们可以发现，结果多出来了个 1，为什么呢？  
因为我们没包含 $diff_1$ 和 $diff_{n+1}$，所以结果必多出来一点，可是我们不需要把这两个也包含进去。

求最少次数，把正数和和负数和的绝对值取较大值即可，原因如下：
![](https://cdn.luogu.com.cn/upload/image_hosting/v6rpo21g.png)
此图，正数和大于负数和（取过绝对值），所以取正数和。因为无论怎样，抵消完后总会多一个数，而这个数想消掉，必须要单独处理，至于如何处理，我们不管，因为我们不需要管他，正数大，则永远都会剩下一个正数，操作次数就是这个正数，直接输出；负数同理。


------------
然后第二问：	求可能的种数。

简单，差分数组当中的正数和与负数和之和 +1 即可，注意要 +1。

这一问的值，一般与第一问的值比较接近（废话），	联系上一问，我们可以定义两个累加器，分别加正数的和负数的和。

所有答案的可能性都在差分序列当中，其实就是求 $diff_1$ 的可以有多少种，有两种操作可以求 $diff_1$，一步步加或减（不同时进行操作）。因为 $diff_1$ 本身就是个值，所以这也算一种，而一步步的操作和为正数和与负数和的最大值减去最小值，化简为：正数和与负数和的绝对值加 1。
![](https://cdn.luogu.com.cn/upload/image_hosting/wubshak5.png)

最后代码附上前，我还要提出个问题：出于严谨性我希望加强下数据，$a_i$ 的最大值在题目中暴了 int，但是[这样的代码](https://www.luogu.com.cn/paste/68fc57vg)还是能过。

我给一份数据：
```
10
5
1
0
2 
2147483648 
2147483647
2147483648 
2147483647
2147483648 
2147483647
```
正确输出：
```
2147483650
2147483643
```
错误输出：
```
2147483647
2147483643
```
其中，有些人的题解代码也是可以被这个数据给 Hack 掉的，我不点名。

## 代码：
```cpp
#include<bits/stdc++.h>
//#include<iostream>
using namespace std;
const int N=1e5+5;
long long n,a[N],diss[N],ans=0,z=0,f=0;//注意开 long long
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
		diss[i]=a[i]-a[i-1];//差分数组
	}
	for(int i=2;i<=n;i++){//注意从2开始循坏
		if(diss[i]>0){
			z+=diss[i];//正数情况
		}else{
			f+=diss[i];//负数情况
		}
	}
	cout<<max(z,-f)<<endl<<abs(z+f)+1;
   //因为f为负所以加上个-号就为正数了，记得取max；第二问
   //要记得+1，两个累加器直接相加取绝对值。
	return 0;
}
```