# 一道经典差分。

### 进入正题

#### 先考虑输出第一行：

要求最少操作使得数列全部相等。

- 如果我们将数列差分起来，就要让全部数都相等，那么就是要让差分数组中每一项都为0，如果我们留下第一项的，只将[2,n]的差分数组变为0，那么数列就都是第一项的值了。所以我们只在[2,n]的差分序列上做操作。我们操作的可以转换成了让dif[l]+1,dif[r+1]−1和dif[l]−1,dif[r+1]+1，所以我们考虑将差分数组中的正数和负数一一配对互消，那么最后如果剩下一些正数，那么就修改dif[i]+1,dif[n+1]−1。

#### 接下来考虑第二问：

- 上面讲过，我们留下了第一项，所以数列中所有数会变成第一项的数，所以就考虑最优情况下，第一项可以有多少种取法即可。

- 也就是考虑剩下的那些正数（或负数）和第一个位置互相抵消一部分（剩余的再和n抵消）的的情况，就是dif[1]+1,dif[i]−1

代码：

 ```cpp
#include <bits/stdc++.h> 
using namespace std;
#define N 1000010  
int a[N],b[N],n,i;  
long long x,y,ans; 
int main()  
{  
    scanf("%d",&n); 
    for (i=1;i<=n;i++) scanf("%d", &a[i]);  
    for (i=2;i<=n;i++)  
    {  
        b[i]=a[i]-a[i-1];  
        if (b[i]>0) x+=b[i]; else y-=b[i];  
    }  
    if (x > y){
        printf("%lld\n",x);
        ans=x-y;
    }
    else{
        printf("%lld\n",y);
        ans=y-x;
    } 
    ans++;
    printf("%lld\n",ans);  
    return 0;  
}  

```
