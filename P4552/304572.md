
求出a的差分序列b,其中 $b_{1}=a_{1}$，$b_{i}=a_{i}-a_{i-1}(2≤i≤n)$。令 $b_{n+1}=0$。(一会有大用)

题目对序列a的操作，相当于每次可以选出 $b_{1},b_{2},…,b_{n+1}$ 中的任意两个数，一个加1，另一个减1。目标是把 $b_{2},b_{3},…,b_{n}$ 变为全零。最终得到的数列 $a$ 就是由 $n$ 个 $b_{1}$ 构成的。

从 $b_{1},b_{2},…,b_{n+1}$ 中任选两个数的方法可分为四类:
1. 选 $b_{i}$ 和 $b_{j}$，其中 $2≤i,j≤n$。这种操作会改变 $b_{2},b_{3},…,b_{n}$ 中两个数的值。应该在保证 $b_{i}$ 和 $b_{j}$ 一正一负的前提下，尽量多地采取这种操作，更快地接近目标。
2. 选 $b_{1}$ 和 $b_{j}$，其中 $2≤j≤n$。
3. 选 $b_{i}$ 和 $b_{n+1}$，其中 $2≤i≤n$。
4. 选 $b_{1}$ 和 $b_{n+1}$，这种情况没有意义，因为它不会改变 $b_{2},b_{3},…,b_{n}$ 的值，相当于浪费了一次操作，一定不是最优解。

设 $b_{2},b_{3},…,b_{n}$ 中正数总和为 $p$，负数总和的绝对值为 $q$。首先以正负数配对的方式尽量执行第1类操作，可执行 $\min(p,q)$ 次。剩余 $|p-q|$ 个未配对，每个可以选与 $b_{n}$ 或 $b_{n+1}$ 配对，即执行第2或3类操作，共需 $|p-q|$ 次。

综上所述，最少操作次数为 $\min(p,q)+|p-q|=\max(p,q)$ 次。根据 $|p-q|$ 次第2、3类操作的选择情况，能产生 $|p-q|+1$ 种不同的 $b_{1}$ 的值，即最终得到的序列a可能有 $|p-q|+1$ 种。

摘自《算法竞赛进阶指南》

知道这些之后，你就会惊奇的发现，这道题不用差分序列！
只要在读入时维护正数的和以及负数和的绝对值就可以了，避免了不必要的空间浪费。

代码：
```cpp
#include<iostream>
#include<cstdio>
using namespace std;
const int Maxn=100010;
long long a[Maxn],b;
int main(){
	int n;
    long long p=0,q=0;  //分别维护正数的和以及负数和的绝对值
	scanf("%d",&n);
	scanf("%lld",&a[1]);  //要先读入第一个数，因为第一个数没有差分
	for(int i=2;i<=n;i++){
		scanf("%lld",&a[i]);  //读入
		b=a[i]-a[i-1];  //你可以理解为一个临时的差分序列
		if(b>=0)p+=b;
		if(b<0)q+=-b;
	}
	printf("%lld\n",max(p,q));  //输出最少操作次数
	printf("%lld\n",p>q?p-q+1:q-p+1);  //输出结果数，即|p-q|+1
	return 0;
}

```
