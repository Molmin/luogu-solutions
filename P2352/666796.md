不妨将每个区间转化为一对括号，不难发现**最优解一定在某个右括号上**。

这里给出证明：

反证法，若最优解在某个**区间中**，那么分情况讨论：

+ 当前区间不套着小区间

显然此时将最优解向右挪动一个单位，优于原先最优解，矛盾。

+ 当前区间套着小区间

其实等价于在情况 $1$ 内添加一个小区间，不妨将大区间设为 $A$，小区间设为 $B$。

![](https://cdn.luogu.com.cn/upload/image_hosting/q4y8hf0u.png)

红色区间是一定不会被选择的：
+ 对于区间 $1$，不妨选择 $A$ 的右端点，对于区间 $2$，不妨选择 $A$ 的右端点，**越靠右越优**。

那么对于中间的这一段，覆盖数量都是 $2$，不妨选择右端点的位置，最大化 $x$。

+ 区间套区间套 $\cdots$ 套区间

如果都是新区间完美被旧区间嵌套的情况，显然每套一个区间就会多出两段红色部分，依然像上文那样论证即可。

但是如果新区间不能被完美嵌套再旧区间时，情况如下图：
![](https://cdn.luogu.com.cn/upload/image_hosting/1g0xxbe2.png)

此时不妨将新区间切开，显然两部分的情况综合即为新区间的所有情况。
![](https://cdn.luogu.com.cn/upload/image_hosting/zsp2gmsh.png)

此时问题转化为上一种情况。

那么整个问题就转化为了，在所有 $n$ 个区间的右端点中，选择一个点使其在最多的括号内。

考虑括号能被取到的范畴，对于一个右端点而言，数轴上其前的左端点是最多的括号数量，右括号在其前的括号，是提前结束，即不把当前左端点包含的一对括号。不妨维护一个指针，指向**第一个坐标在当前右端点之后的左括号的下标**，不妨设其为 $ptr$，那么所有在 $ptr$ 之前的右括号都满足在当前右端点前开始，总共有 $ptr-1$ 个。对于右端点，所有在当前右端点之前的右括号都是已经结束的括号，总共 $i-1$ 个，那么满足要求的区间数量总共是 $(ptr-1)-(i-1)=ptr-1-i+1=ptr-i$ 个。

代码：
```cpp
#include<bits/stdc++.h>

using namespace std;

const int N = 100010;
long long a[N], b[N], res = INT_MIN, n;

int main()
{
	scanf("%lld", &n);
	for(int i(1);i <= n; ++ i)
		scanf("%lld %lld", &a[i], &b[i]);
	sort(a + 1, a + 1 + n), sort(b + 1, b + 1 + n);
	int ptr = 1;
	for(int i(1);i <= n; ++ i)
	{
		while(ptr <= n and a[ptr] <= b[i])
			++ ptr;
		res = max(res, (ptr - i) * b[i]);
	}
	printf("%lld", res);
	return 0;
}
```