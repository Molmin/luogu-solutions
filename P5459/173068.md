# CDQ分治+队列维护 #

暂时看本题还没什么题解，就发一篇。发现正解应该是树套树？不过本题是我看同机房大佬[青葱](https://www.luogu.org/space/show?uid=139717)在做的一道题，他说可以用CDQ分治做，正好我最近练习CDQ分治，就看了一眼，并受青葱大佬的指点，本蒟蒻终于做出了这道题。



------------
本题解会加入一些笔者对CDQ分治的理解，好了，废话不多说

题意：有$n$个点组成的序列，对于第$k$个点（$1<=k<=n$），询问从第$k$个点到第$j$个点的和大于等于$L$,小于等于$R$（$j<=k$），求所有$k$满足要求的$j$的数量之和。

**如果学过CDQ分治的dalao们可以跳到第二板块**

## 1、浅谈CDQ分治 ##
最基本的CDQ分治：拥有插入和查询的功能，可以完成序列上的数量查询。

### CDQ分治总结：
左区间修改（插入），右区间记录左区间对右区间的影响

### CDQ分治的理解：
看了很多讲解，一直对左区间和右区间没什么直观感受，这要慢慢自行yy。在此多说一些自己的理解：在序列上，**一个查询是由之前就存在（插入）的值来影响的**。

比如$1$ ,$3$ ,$7$ ,$2$ ,$5$ ,$4$ ,$8$这个序列，求值为$5$的数之前有多少数比他小，显然有$1$, $3$, $2$, 三个数，而排在$5$后面的$4$没有影响到$5$的统计。

明白这一点之后，CDQ分治的核心基本已经讲清楚了。

接着，我们将CDQ分治 ，分为**CDQ**和**分治**（自己强行分开）

**分治**：在此不多说，可以看[p1908 逆序对](https://www.luogu.org/problemnew/show/P1908)的题解，并自己做一做。分治就是将序列递归到最低层，并返回的时候，根据大小归并排序。

**CDQ**:将插入和查询根据时间放入序列，所以我们分为四个部分：

左区间中插入：由于左区间可以对右区间影响（因为左区间在前面）

左区间的查询：由于左区间的查询已经结束，右区间不能对左区间影响，所以左区间的查询可以不用管

右区间的插入:由于右区间的插入不能对左区间的查询造成影响，所以可以不用管

右区间的查询：由于右区间的查询可以被左区间的插入值所影响，故将左区间的合法影响统计下来（可以用树状数组维护）

**对于左区间的统计，已经在上一层序列统计完了，而右区间的统计，上一层序列值统计了一部分，在这一层还有比它更前面的数没有统计**

在此，CDQ分治的基本已经讲完了。

我推荐几道题：
[p3374树状数组1](（https://www.luogu.org/problemnew/show/p3374）)  [p3810三维偏序](https://www.luogu.org/problemnew/show/p3810)  [p2163园丁的烦恼](https://www.luogu.org/problemnew/show/p2163)  [p3157动态逆序对](https://www.luogu.org/problemnew/show/p2163)

## 2、本题讲解
我们先来分析一下为什么能用CDQ分治：1）一个序列 2）有插入有查询（只不过这道题查询和插入在一起） 

满足要求，那么就可以上CDQ分治了。因为是连续的子序列，所以我们很容易想到用前缀和，用两点的差代表序列。接着根据序列的顺序进行CDQ分治，在CDQ分治里面，我们可以用队列维护序列和大于等于$L$和小于等于$R$的位置，因为CDQ分治后，左区间和右区间内的值都是有序递增的，那么$L$和$R$的满足的下标也是递增的，所以可以用队列维护边界。

上代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define MAXN 100010
int n,vl,vr,sum[MAXN],tmp[MAXN],q[MAXN],ans;

void CDQ(int l, int r){
	if(l == r) return;
	int mid = l+r>>1;
	CDQ(l,mid); CDQ(mid+1,r);
	int p1 = l, p2 = mid+1, t = l-1, cur = l-1, cl = l, cr = l;
	while(p1 <= mid && p2 <= r){
		if(sum[p1] <= sum[p2]){//归并排序，比较值
			q[++cur] = sum[p1];
			tmp[++t] = sum[p1++];
		}else{
			while(cl<=cur && sum[p2]-q[cl] >= vl) cl++;
			while(cr<=cur && sum[p2]-q[cr] > vr) cr++;
			ans += cl-cr;
			tmp[++t] = sum[p2++];
		}
	}
	while(p1 <= mid){
		tmp[++t] = sum[p1++];
	}
	while(p2 <= r){
		while(cl<=cur && sum[p2]-q[cl] >= vl) cl++;
		while(cr<=cur && sum[p2]-q[cr] > vr) cr++;
		ans += cl-cr;
		tmp[++t] = sum[p2++];
	}
	for(int i=l; i<=r; i++){
		sum[i] = tmp[i];
	}
}

int main(){
	scanf("%d%d%d",&n,&vl,&vr);
	for(int i=1; i<=n; i++){
		scanf("%d",&sum[i]);
		sum[i] += sum[i-1];
	}
	CDQ(0,n);//注意要从0开始，因为是记录前缀和，不然1的值没法表示
	printf("%d",ans);
	return 0;
}

```
自己的代码实在有点丑，可能是最初学的CDQ分治模板不一样，导致自己的版本的CDQ分治太长了。还有有人用sort在CDQ分治里面排序，很简洁美观，不过不是稳定的$O(logn)$复杂度。