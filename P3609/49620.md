虽然不太明白重复解法是指什么……但是用mod判输赢也算有创新吧……其它的都开得数组，其次这次我连dp也换成滚动的了……不要那么严格嘛……

首先H,P,S，这三个字母我们就当做0,1,2，那么假设贝西出的的x，FJ出的y，贝西能赢FJ当且仅当（x+1）%3==y，这个式子可以让状态转移时更简洁。

然后考虑状态转移，定义dp[i][j][v],表示第 i 轮还剩 j 次可以变化的时候出 v 所能赢的最大局数。

如果这个 v 能赢这一局，那么dp[i][j][v]应该是 dp[i-1][j][v]+1,dp[i-1][j+1][(v+1)%3]+1,dp[i-1][j+1][(v+2)%3]+1这三个中的最大值。

如果本来就是 v 那么就说明不用 j，所以是dp[i-1][j][v],然后就是另外两种手势，可以在用一次j的情况下使用，所以是

dp[i-1][j+1][(v+1)%3]+1和dp[i-1][j+1[(v+2)%3]+1

这种转移只在 v 能赢的时候才有意义，因为不赢的时候根本不可能使用一次 j，变化一次之后结果还不赢，这种事情聪明的贝西怎么可能做……。 所以对于 v 不能赢的情况，直接：

dp[i][j][v]=dp[i-1][j][v];

这一步是必须的，要不然之后的转移会错。

并且可以用滚动数组减掉i那一维，省空间……

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,k;
int dp[25][3];//第i局还剩j次变换机会出0,1,2时赢的最大场数
int main(){
    scanf("%d%d",&n,&k);
    for(int i=1;i<=n;i++){
        char s[2];
        scanf("%s",s);
        int o;
        if(s[0]=='H')o=0;else if(s[0]=='P')o=1;else o=2;//o存下FC的手势 
        for(int j=k;j>=0;j--)
            for(int v=2;v>=0;v--)
                if((v+1)%3==o)
                    dp[j][v]=max(dp[j][v],max(dp[j][v]+1,max(dp[j+1][(v+1)%3]+1,dp[j+1][(v+2)%3]+1)));
                else
                    dp[j][v]=dp[j][v];	
    }
    printf("%d",max(dp[0][0],max(dp[0][1],dp[0][2])));//三种手势都可能最优秀 
    return 0;
}
```