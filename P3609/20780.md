仅限个人理解qwq,如有写的不好的地方，欢迎指出。dalao勿喷qwq。

Warning:"以下内容或许让你感到不适，请坚持到底，多多少少应该会有些收获的"

我们看这道题目，理解一下题意，然后看到“最多能赢多少场”，这道题目差不多就是用dp做了(某位dalao说得好，这道题必须一眼看出用dp,%%%%)(:зゝ∠)_

我们可以看出来，（原谅我这么说qwq）对于每个回合，都有一个最优解。这样，第一维就出来了f[i]中的i表示在第i个回合能赢的最大次数。

这样，思路就基本上出来了。对于i来说，前一个要么不改变，要么改变。这样就可以把它给表示出来。f[i]=(f[i-1]+当前改变得到的值)或者是(f[i]+当前不改变得到的值)。当然，我们在两者中选择的时候，应该要取最大值。

这时候，我们就会发现。。。当我们只用f[i-1]来表示f[i]时，它就会出现错误。因为我们在从f[i-1]推导到f[i]的时候，它少了一些必要的数据（比如:它在f[i-1]的最优情况下换了几次）。辣么这时候怎么办？

那我们就多加一维，变成了f[i][j],代表第i回合最大换j次时的最大值。我们再来进行转移。f[i][j]=(f[i-1][j-1]+当前改变得到的值)或者是(f[i-1][j]+当前不改变得到的值)，我们又在这两个中间选到最优值。想一想：为啥有一个是j,有一个是j-1?qwq

我们一看，这个方程已经可以通过这个表达式进行转移了，但是，我们在写代码的时候，又会发现我们的推导式没有错误，但是对于这个状态，它改不改变得到的值依旧不明朗。它在f[i-1][j]或者是f[i-1][j-1]这个最优值的时候选的是蹄子，剪刀，还是布呢?于是我们就再加一维，表示当前情况下选的是蹄子，剪刀或者是布。

我们就可以表达式写出来了qwq(pk[p][q]表示p与q进行对决的结果,1表示p打败q，0表示p要么打平，要么输了q,而a[i]则表示另一个人第i回合的手势,S表示除了k的手势集合)

### f[ i ][ j ][ k ] = {f[ i - 1 ][ j ][ k ] + pk[ k  ][ a[ i ] ],f[ i - 1 ][ j - 1][ l ] + pk[ k ][ a[ i ] ] | l ∈ S}
然后再求这个集合中的最大值就o~~jb~~k啦啦啦~\(≧▽≦)/~
也可以写得通俗一点qwq

f[i][j][k]=f[i-1][j][k]+k与a[i]对决的值 

				或者是 

f[i-1][j-1][其他手势]+k与a[i]对决的值

注意：j要从0开始，在l的循环中要加上j!=0,~~我才不会说就因为没有这个条件然后WA了两个点怎么都检查不出来~~

题解如下啦:
```cpp
#include<map>
#include<cstdio>
#include<iostream>
using namespace std;
map <char,int> qwq;
int pk[4][4];
void orz(){
	qwq['H']=1;	qwq['S']=2;	qwq['P']=3;
	pk[1][2]=1; pk[2][3]=1; pk[3][1]=1;
	return ;
}
int a[100010],f[100010][21][4];
int main(){
	orz();
	int n,s;
	char x=' ';
	cin>>n>>s;
	for(int i=1;i<=n;i++){
		cin>>x;
		a[i]=qwq[x];
	}
	for(int i=1;i<=n;i++)
		for(int j=0;j<=min(s,i);j++)
			for(int k=1;k<=3;k++){
				int t=pk[k][a[i]];
				f[i][j][k]=max(f[i-1][j][k]+t,f[i][j][k]);
				for(int l=1;l<=3;l++)
					if(l!=k&&j)
						f[i][j][k]=max(f[i-1][j-1][l]+t,f[i][j][k]);
			}
	int ans=0;
	for(int i=1;i<=3;i++)
		ans=max(f[n][s][i],ans);
	cout<<ans;
	return 0;
}
```
