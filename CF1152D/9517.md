先放代码（因为代码太简单了）

```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#define md 1000000007
using namespace std;

int n,f[2005][2005],ans,i,j;

int main()
{
	cin>>n;
	f[1][1]=1;
	for(i=2;i<=n+1;i++)
		for(j=1;j<=i;j++)
			f[i][j]=(f[i-1][j]+f[i][j-1])%md,(i+j)%2==1?ans=(ans+f[i][j])%md:0;
	cout<<ans;
	return 0;
}
```

就是求

$$f_{i,j}=f_{i-1,j}+f_{i,j-1}$$

$$ans=\sum_{(i+j)\bmod 2=1}f_{i,j}$$

所以这为什么是对的呢？

先来看这样一种**构造选中的边集**的方法：

- 选$trie$树上所有深度为**偶数**的点和其**父节点**的连边（如果有多条边冲突就保留一条）

（把$trie$的根深度视为$0$）

括号序列的长度是$2n$，**偶数**，也就是说$trie$树的**叶子**深度为偶数，按这种方法我们覆盖了所有深度为**奇数**的点，而所有边都连接两个深度奇偶不同的点，所以这样选就得到了最大的边集

- 答案就是$trie$树上深度为**奇数**的点的**个数**

上面那个构造方法的解释顺便解释了这一点

所以只需要求$trie$上深度为奇数的点有几个就行了

- 求上面的那个$f$显然是递推求卡特兰数的一种方法

根据卡特兰数与括号序列的关系（或者把左括号看成$i+=1$，右括号看成$j+=1$）显然可以知道$f_{i,j}$就是有$i$个左括号,$j$个右括号，且是**合法括号序列的前缀**的括号序列的个数。对应到$trie$上就是$f_{i,j}$个点

所以把$i+j\bmod 2=1$的$f_{i,j}$加起来就得到$trie$上深度为奇数的点的个数，也就是答案



