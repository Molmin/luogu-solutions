提供一种与题解不一样的做法，很好想但不太好写。

首先把所有元素离散化，使其值域为 $[1,n]$，且 $C_i=i$。

然后考虑钦定了所有卡牌的选择情况后如何判断合法：对于每个 $i$，值不大于 $i$ 的卡牌数 $\geq i$。这个条件显然是充要的。那么我们可以记一个序列 $c_i=cnt_i-i$，$cnt_i$ 为值不大于 $i$ 的卡牌数。合法的条件即为 $\forall i,c_i \geq 0$ 。

然后考虑怎么求出一组询问的答案：

首先我们钦定所有卡牌正面朝上，求出 $c$ 数组。然后若正面权值大于反面权值，可以发现将第 $i$ 张卡牌翻面等价于给 $c$ 的某段区间 $[l_i,r_i]$ 加 $1$。

这样问题就转换为了给定一个数组和若干区间，选择最少的区间，并将数组的这段区间加 $1$，最终使得数组的每个元素非负。

这个问题可以直接用堆从前往后贪心，从 $1$ 到 $n$ 扫描每个位置 $p$，我们将所有 $l_i=p$ 的 $r_i$ 塞入堆中。然后若 $c_p<0$，我们就一直选择当前堆中 $r_i$ 最大的区间给 $c$ 加 $1$，并将这个区间弹出堆，直到 $c_p \geq 0$ 为止。因为每次我们不用考虑小于 $p$ 的位置，所以这个贪心显然正确。

同时我们发现，不论正着扫，反着扫，还是正反交替扫（初始 $p_l=1,p_r=n$，每次考虑位置 $p_l$ 或位置 $p_r$，按照类似的贪心思路操作），这个贪心思路都是正确的。

接下来我们考虑怎么处理所有询问：

我们可以枚举询问卡牌的选择方式，选择后等价于给 $c$ 的某一段后缀 $[x,n]$ $+1$。 我们可以考虑对于所有 $x$ 算出答案，也就是使得 $\forall i \leq x,c_i \geq 0, \space  \forall i > x, c_i \geq -1$ 的最少选择区间数。

我们可以直接把上面的贪心套上一个分治：

每次我们处理区间 $[l,r]$，表示 $l \leq x \leq r$。取区间中点 $m = \lfloor \frac{l+r}{2} \rfloor$，则若 $x \leq m$，那么 $\forall m < i \leq r, c_i \geq -1$，若 $x>m$，那么 $\forall l \leq i \leq m, c_i \geq 0$。我们直接按照上面的贪心思路做就可以了。

实现时可能需要 $\text{set}$ 并且要支持撤销。

时间复杂度 $O(n \log^2 n)$ 。