$\ast$2600

CF 有些评分真是一眼难尽，你说 CF1477E:$\ast$3300 我认了，但你说 CF1083F:$\ast$3300 高的过分吧，你说这道题 $\ast$2600 我觉得也低了。（或者是我太菜了）

------------

首先由最短路的性质每条边只能在同层和下层的点之间连边，否则会被松弛。

又由于最短路唯一，故每个下层的点在上层只有唯一的父亲，是棵最短路树加上一些同层边。

题目还有个要求是树上点编号递增，于是同层的点编号必定连续，考虑一层一层的转移。

一号点比较特殊，没有父亲必须往下层连 $d_i$ 个点，特殊搞掉后考虑 DP。

------------

下文参考了 kls，但它的公式和定义解释实在是不堪入目。

设 $f_{i,j}$ 表示已经考虑了前 $i$ 个点，最后 $j$ 个点与第 $i$ 个点在同一层的方案数。

同时设 $g_{i,j,k}$ 表示这一层有 $i$ 个点，上一层度数为 $2$ 的点有 $j$ 个，度数为 $3$ 的点有 $k$ 个，这一层与上一层的树边和上一层的非树边的方案数。

注意：这里不考虑这层 $i$ 个点内部以及向下一层的连边，即这层的 $i$ 个点都当做度数为 $1$ 用于接到当前的最短路树上。

同时上层的点都默认用了 $1$ 的度数接到最短路树上，也即实际上为 $j$ 个度数剩余为 $1$ 的点和 $k$ 个度数剩余为 $2$ 的点。

------------

令 $cnt2_{i,j}=\sum_{k=i}^j[d_k=2],cnt3_{i,j}=\sum_{k=i}^j[d_k=3]$，即区间内度数为 $2/3$ 的点数下面是简单的式子。

- $f$ 的初值：

  $$f_{du_1+1,du_1}=1$$
  
- 最后的答案：

  $$ans=\sum_if_{n,i}\times g_{0,cnt2_{n-i+1,n},cnt3_{n-i+1,n}}$$
- $f$ 的转移：

  $$f_{i,j}=\sum_kf_{i-j,k}\times g_{j,cnt2_{i-j-k+1,i-j},cnt3_{i-j-k+1,i-j}}$$
- $g$ 的初值：

  $$g_{0,0,0}=1$$
- $g_{0,0,k},k>0$ 的转移：

  $$g_{0,0,k}=\sum_{l=2}^{k-1}g_{0,0,k-l-1}\binom{k-1}{l}\frac{l!}2$$

  这个有必要解释一下，可能是全题唯一要动下脑子的式子。
  
  由于当前层全是度数为 $3$（度数剩余为 $2$）的点，而且下层无点，于是肯定是内部连出多个环。
  
  考虑包含最后一个点的那个环，枚举这个环大小为 $l+1$。
  
  首先最后一个点已经被钦定了，于是从 $k-1$ 个点里选出 $l$ 个点，方案数 $\binom{k-1}{l}$。
  
  考虑把这 $l+1$ 个点排成环，环排列方案是 $l!$，但这道题换物顺序，有翻转同构于是要 $\div 2$，即 $\frac {l!}2$。
  
- $g_{0,j,k},j>0,k\ge0$ 的转移：

  $$g_{0,j,k}=g_{0,j-2,k}\times (j-1)+g_{0,j,k-1}\times k$$

  考虑先搞掉最后一个 $2$ 度（剩余度数为 $1$）点，要么和另一个 $2$ 度配对，否则一个 $3$ 度点掉成 $2$ 度点。
  
- $g_{i,j,k},i>0,j\ge0,k\ge0$ 的转移：

  $$g_{i,j,k}=g_{i-1,j-1,k}\times j+g_{i-1,j+1,k-1}\times k$$

  考虑先搞掉最后一个当前层的点，要么和另一个 $2$ 度配对，要么一个 $3$ 度点掉成 $2$ 度点。
  
空间复杂度 $O(n^3)$，时间复杂度 $O(n^3)$。

代码写着挺舒服，直接放这里吧：

```cpp
signed main()
{
	#ifndef ONLINE_JUDGE
	freopen("_.in","r",stdin);
//	freopen("_.out","w",stdout);
	#endif
	int i,j,k,l;n=read();for(i=1;i<=n;i++)du[i]=read();
	for(fac[0]=i=1;i<=n;i++)fac[i]=Ml(fac[i-1],i);
	for(C[0][0]=i=1;i<=n;i++)for(C[i][0]=j=1;j<=n;j++)C[i][j]=Ad(C[i-1][j-1],C[i-1][j]);
	int*g1=G[0][0];
	for(g1[0]=k=1;k<=n;k++)for(l=2;l<k;l++)Add(g1[k],Ml(g1[k-l-1],Ml(C[k-1][l],Ml(fac[l],Inv2))));
	#define g2 G[0]
	for(j=1;j<=n;j++)for(k=0;k<=n;k++)g2[j][k]=Ad(j>1?Ml(g2[j-2][k],j-1):0,k?Ml(g2[j][k-1],k):0);
	for(i=1;i<=n;i++)for(j=0;j<=n;j++)for(k=0;k<=n;k++)G[i][j][k]=Ad(j?Ml(G[i-1][j-1][k],j):0,k?Ml(G[i-1][j+1][k-1],k):0);
	for(i=1;i<=n;i++)ct2[i]=ct2[i-1]+(du[i]==2),ct3[i]=ct3[i-1]+(du[i]==3);
	for(F[du[1]+1][du[1]]=1,i=du[1]+2;i<=n;i++)
	{
		int*f1=F[i];
		for(j=1;j<=i;j++)
		{
			int*f2=F[i-j];
			for(k=1;k<=i-j;k++)Add(f1[j],Ml(f2[k],G[j][ct2[i-j]-ct2[i-j-k]][ct3[i-j]-ct3[i-j-k]]));
		}
	}
	int*f=F[n];
	for(i=1;i<=n;i++)Add(ans,Ml(f[i],g2[ct2[n]-ct2[n-i]][ct3[n]-ct3[n-i]]));
	writenum(ans,10);
	return output;
}
```