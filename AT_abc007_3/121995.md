啊这，双向bfs的题解就 $1$ 篇，我这里详细讲解一下吧awa。

双搜可以**大幅度地减少搜索范围和时间复杂度**，对于一些**给定起始状态和终止状态的题目**无比适合。

比如这道题目，给出了起始坐标和终止坐标。

那么我们即可新建两个队列，**一个队列 $q$ 存从起始点开始遍历、扩展的bfs搜索树，一个队列 $p$ 存从终点开始遍历、扩展的bfs搜索树。**

每次一次性扩展两个队列的头端，先扩展 $q$，再扩展 $p$ 。

扩展函数和普通的bfs大同小异，但是不同的地方在于**要开两个标记数组**，一个 $b[i][j]$ 存从起始点出发到 $(i,j)$ 点的距离，一个 $d[i][j]$ 存从终点出发到 $(i,j)$ 点的距离。

要是在 $q$ 队列里扩展中遇到了这个点没有在之前的 $q$ 队列里访问过，且不走出边界和这个地方不是墙，即可扩展；

但是在扩展时注意判断，如果这个 $(x,y)$ 点的 $d[x][y]$ 并不是 `inf` ，那么全部搜索结束，答案即为 $d[x][y]+b[x][y]-1$ ；

对于 $p$ 队列的扩展，也是同理。

伪代码如下：

```cpp
Q,P<-queue
d[maxn][maxm],b[maxn][maxm]<-int
DBFS(sx,sy,ex,ey)
 Q.push(sx,sy,0)
 P.push(ex,ey,0)
 while(Q不为空&&P不为空)
  extend(Q);
  extend(P);
  
extend(Que)
 往四个方向枚举;
  x=新扩展出的x坐标,y=新扩展出的y坐标;
  if(合法)
   丢进新队列;
   if(在另一个队列所构成的搜索树里有相应的(x,y)坐标)
    答案=到了此搜索树里(x,y)坐标的层数+
         另一棵搜索树里(x,y)坐标的层数-1;
    退出所有扩展与DBFS;
 队列去头;
```