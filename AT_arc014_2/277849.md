# set去重+字符串模拟
话说题目名字有点眼熟 ~~，找到你了，水题。~~

### 考虑下那几种情况会导致游戏结束
1. 某个字符串被重复使用
2. 当前字符串的第一个字符和上一个字符串的最后一个字符不同
3. 所有字符串都用完了（没有出现上面两种情况）

### 解决方案
对于1. 而言，我们使用STL里的set就可以方便的判重。

对于2. 而言，每次记录下上次的字符串是什么就行（当然也可以只记录上次字符串的最后一个字符，这里交给读者去做好了~~不是因为懒~~）。另外对于第一个字符串，要进行特殊处理，因为它前面没有字符串。

对于3. 而言，只要出现前两种情况就退出程序，如果整局游戏都没有出现前两种情况，那么3. 就是合法的。

### 如何判断是谁输了
我们假设高桥君的回合从1开始，分身回合从2开始，那么不难发现，如果当前回合数为奇数，就是高桥君输了，否则就是分身输了。

## 喜闻乐见的代码
__仅供参考，切勿抄袭__

```cpp
#include <iostream>
#include <set>
using namespace std;
set<string > sset;
int main() {
	ios::sync_with_stdio(false), cin.tie(0), cout.tie(0); 
	int T;
	cin >> T;
	string pre = "1919810";
	string now;
	int cnt = 1;
	while (T--) {
		cin >> now;
		// 首先，对于第一个字符串要进行特判，因为它之前就没有别的字符串了，其次，如果某个字符串
		// 出现了多次，那么不管是否是合法的，都说明有人输了 
		if (now[0] != pre[pre.size() - 1] && pre != "1919810" || sset.count(now)) {
			cout << (cnt % 2 ? "LOSE" : "WIN") << endl;
			return 0;
		}
		// 更新字符串集合、前一个单词、回合数 
		sset.insert(now), pre = now, cnt++;
	}
	cout << "DRAW" << endl;
	return 0;
}
```