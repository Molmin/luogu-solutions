## 题目意思
题目已经描述得很清楚了，就是有 $n$ 个客人来访，每个客人来访时间为 $t_i$，离开时间为 $t_i+1$。现在有 $k$ 根蜡烛，需要求最小点燃时长。

## 主要思路
思路：既然蜡烛有限，应该让它们的**利用价值最大**，在相邻两个时间段的差值，即 $t_{i+1}-t_i$ 最大时熄灭炉子，这样每根蜡烛就可以节省尽量多的点燃时间。

实现方法：先将相邻两个时间段的差值**从大到小**排序，算出总时间，然后将**前 $k-1$ 个差值减掉**（相当于用掉 $k-1$ 根蜡烛）。

**注意，这里是 $k-1$ 个间隔，因为第一次点燃火炉要消耗一根蜡烛。**

## 一些小坑
1. 算两点之间的间隔时，注意只有 $n-1$ 个间隔。
1. 注意答案初始值需要设为 $t_i-t_1-1$，即从第一个客人来时点燃火炉，最后一个客人离开时关闭火炉。
1. 排序时注意是从大到小排序（从小到大排序的话是减掉后 $k-1$ 个间隔）。

## 代码
建议各位看完本蒟蒻的题解后尝试自己写，以下代码仅供参考。

Code：
```cpp
#include<bits/stdc++.h>
using namespace std;

const int N = 100000 + 10;
int n, k, ans, t[N];

bool cmp(int x, int y){return x > y;}
//排序规则

int main(){
	cin >> n >> k;
	k--;//现在的k已经是前文的k-1了
	for(int i=1;i<=n;i++)	cin >> t[i];//读入不解释
	ans = t[n] - t[1] + 1;//初始情况全部打开 
	for(int i=1;i<=n;i++)	t[i] = t[i + 1] - t[i] - 1;//求两位客人间隔，直接用原数组即可，节省空间
	sort(t + 1, t + n, cmp);//从小到大排个序 
	for(int i=1;i<=k;i++)	ans -= t[i];//减掉前k-1个间隔
	cout << ans << endl;
	return 0;
} 
```
如果本篇题解对你有启发，点个赞再走吧。