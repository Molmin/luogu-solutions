题目大意：现在有n个数，你可以进行任意次如下操作：将二进制下的一个数中的两个位置交换，问你一番操作后能不能使得这n个数的异或和为0，求出有多少个序列。

大致思路：首先我们看一下异或和为0需要什么条件。不难发现，只有当每一位上1的个数为偶数个的时候那这一位的异或和就是0，由此推出，这n个数转为二进制后1的个数为偶数个。于是我们可以利用前缀和来维护，每次O（1）的查询。

但是，仅仅是这样是不够的，因为还有一种情况，比如4 63 2 2 3这组数据如果按照刚刚的算法看是可行的，但是没法操作，因为63的1的个数为6，其他为1 1 2，于是我们又知道了一个条件：一段数中的最大的1的个数不超过总共1的个数/2。

因为每个数都至少可以提供一个在二进制下的1的个数，所以每次我们查询最大值都只需要在前64个数里面找，如果超过了64那么就只需要满足1的个数为偶数即可。

```
#include <bits/stdc++.h>
using namespace std;
int n,anss[300010],num[300010],cnt[2]={1};
long long ans=0;

int main() 
{	cin>>n;
	for(int i=1;i<=n;++i)
	{
		long long x;
		cin>>x;
		while(x>0)
		{
			num[i]+=(x%2);
			x/=2;
		}
		anss[i]=anss[i-1]+num[i];
		ans+=cnt[anss[i]%2];
		for(int j=i,k=i+1,maxn=0;j>=1 && j>=i-64;--j)
		{
            while(k>j) 
				maxn=max(maxn,num[--k]);
            if(maxn*2>anss[i]-anss[j-1] && anss[i]%2==anss[j-1]%2) 
				--ans;
        }
        ++cnt[anss[i]%2];
	}
	cout<<ans<<endl;
	return 0;
}
```
