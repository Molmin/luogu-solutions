### 题意简述：
给你一个含有 `?` 的二进制字符串，你要把问号替换成 `0` 或 `1`，可以反转字符串的任意连续子串作为一次操作，要求以非降序的方式对字符串进行排序，输出操作数最小的满足要求的字符串。

### 思路分析：
推结论。我们把相邻的 $0$ 看做一段，相邻的 $1$ 看做一段，如果字符串的最后是 $1$ 的段，反转次数为 $1$ 的段数减一；如果没有，反转次数为 $1$ 的段数。我们可以设置从左往右的贪心策略，尽可能让 $1$ 的段连起来：如果第一个是问号，设置为 $0$，这样就可以确保第一个字符是最小的，如果这个字符是问号，就让它与上一个字符相同，否则就是原来的。这种情况可保证操作次数是最少的。

### Code:
```cpp
#include<bits/stdc++.h>
using namespace std;
inline void solve(){
	string s;
	cin>>s;
	int l=s.size();
	s="0"+s;//小技巧，如果第一个字符是问号可以将其变成0
	for(int i=1;i<=l;i++)
		if(s[i]=='?')s[i]=s[i-1];//转换
	for(int i=1;i<=l;i++)putchar(s[i]);
	putchar('\n');
}
signed main(){
	int T;
	scanf("%d",&T);
	while(T--)
		solve();
	return 0;
}
```

## The End!