## [题目](https://codeforces.com/problemset/problem/1837/C)|[链接](https://www.luogu.com.cn/problem/CF1837C)

### 题目大意

给出一个不完整的 $01$ 字符串，可以在 $?$ 里填 $0$ 或 $1$。每一次操作，你可以把一个字串反转。求出一种方案，使得可以用最少的操作数让字符串升序排序。

### 题目分析

先举个例子：

`001110`

我们可以把**连续的相同字符**看作一个整体，就变成了这样：

`010`

由于题目中给出的操作是将子串反转，所以这个字符串的操作是：

- 将子串 `10` 反转。

也就是将原串的 `1110` 反转，得到 `000111`，操作数为 $1$。

再举个例子：

`1111111001111100`

这个字符串看起来很长，实际上可以看成：

`1010`

其中一种操作为：

- 将子串 `10`（第一个）反转，得到 `0110`；
- 将子串 `110` 反转，得到 `0011`。

由此不难看出，本题的字符串只有两种形式（连续的相同字符看作一个字符）：

1. `010101......`
1. `101010......`

而使操作数最小的关键，就是“**连续的相同字符**”这一整体最少。

如何达到这一要求呢？只需在填 $?$ 时使其与前一个字符相同。

特别的，若 $?$ 在字符串顶端，前一个字符默认为 $0$，毕竟是升序排序。

敲代码时，还要注意以下几点：
1. 有多组数据；
1. 输入速度。

### 参考代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int t;
string s;
int main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	cin>>t;
	while(t--){
		cin>>s;
		char a='0';
		for(int i=0;i<s.size();i++)s[i]=='?'?s[i]=a:a=s[i];
		cout<<s<<endl;
	}
	return 0;
}
```
感谢你看到这里，Bye~Bye~ヾ(￣▽￣)！