## Update on 2020.12.1
首先，感谢一下大佬们对我的启发。~~（不然我可能一辈子都没法AC）~~

下面开始正题。


------------
# Step 1：分析动归方程
先假设没有一天一天循环。

设$f(i,j,0/1)$表示从第i个小时开始，已经睡了j个小时，当前有没有在睡觉（0表示不在睡觉，1表示在睡觉）。


动归方程：

（初始化为$f(1,1,1)=f(1,1,0)=f(1,0,0)$,其他为-0x3f）
	
    
```cpp
f[i][j][0]=max(f[i-1][j][0],f[i-1][j][1]);

f[i][j][1]=max(f[i-1][j-1][1]+a[i],f[i-1][j-1][0]);
```



  
结果：$max(f(n,b,0),f(n,b,1))$



------------
# Step 2：改进动归方程
这题一看就能看出来是环形区间dp，而解决这种问题最常见的方法有两种。

- **倍长区间**
- **强制连接**

个人比较推荐第一种
~~（我绝对不会告诉你因为我不会第二种）~~。

但是这题倍长找不出关系，所以只好强制连一下了。

步骤为：先按step 1中的dp一遍，再强制让第一个小时熟睡dp一遍。也就是说第二遍初始化时让$f(1,1,1)$=$a[1]$ 就可以了。

结果：	$f(n,b,1)$ (由于第一个小时必须熟睡）



------------
以上两个结果取最大值就可以了。


------------
# Step 3：Code
下面附上代码：
```cpp
#include <iostream>
#include <cstring>
using namespace std;

int n,b,a[3831],ans;
int f[3831][3831][2];//f[i][j][0、1]表示从第i段开始睡j段当前（没睡、睡）的最大u

int max(int a,int b)//自己写的max，更快
{
	return a>b?a:b;
}

void read()//读入
{
	int i;
	for(i=1;i<=n;i++)
	{
		cin>>a[i];
	}
}

void dp()//动归函数
{
	int i,j;
	for(i=2;i<=n;i++)
	{
		f[i][0][0]=f[i-1][0][0];
		for(j=1;j<=b;j++)
		{
			f[i][j][0]=max(f[i-1][j][0],f[i-1][j][1]);
			f[i][j][1]=max(f[i-1][j-1][1]+a[i],f[i-1][j-1][0]);
		}
	}
}

int main()
{
	int i;
	memset(f,-0x3f,sizeof(f));//初始化为-inf
	cin>>n>>b;
	read();
	f[1][1][1]=0;
	f[1][1][0]=0;
	f[1][0][0]=0;
	dp();
	ans=max(f[n][b][0],f[n][b][1]);
	memset(f,-0x3f,sizeof(f));
	f[1][1][1]=a[1];
	f[1][0][0]=0;
	f[1][1][0]=0;
	dp();
	ans=max(ans,f[n][b][1]);//取最大
	cout<<ans<<endl;//输出
	return 0;
}

	

```





# 第一篇题解，求通过！


