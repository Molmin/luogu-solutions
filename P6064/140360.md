## 题目大意


------------
给一个环，有 $N$ 个有权值的节点。选取其中的 $B$ 个，使其权值和最大，但是对于每一段节点连续的区间，第一个点的权值不计入答案（“第一个”当然是从同一个方向而言）。


------------
## 解决方案
很明显是环形 DP 啊。要思考这道题，不妨假设第 $N$ 个点和第 $1$ 个点是断开的。

我们**设 $f_{i,j,1}$ 指前 $i$ 个点中取了 $j$ 个，且当前点选择了。设 $f_{i,j,0}$ 指前 $i$ 个点中取了 $j$ 个，且当前点没有选择**。如果前 $i$ 个点中取了 $j$ 个，且前一个点选上了，那么 $f_{i,j,1}$ 就应该是从以下两种方案取最大值：前一个数没选，当前数是接下来一串元素的首个；前一个数选了，我们把当前数加到前一个数选了的答案中（方程中注意 $j$ 要减 $1$！因为前 $i$ 个数中选的 $j$ 个数包含了当前数字）。如果当前数不选，也差不多，看看方程也好理解。转移方程如下：
```
f[i][j][1]=max(f[i-1][j-1][0],f[i-1][j-1][1]+w[i]);
f[i][j][0]=max(f[i-1][j][0],f[i-1][j][1]);

```
别忘了初始化！

```
f[1][0][0]=0;
f[1][1][1]=0;
//其余为负无穷
```

然而残酷的是，前面的一切都建立在一个美好的设想上：第 $N$ 个点和第 $1$ 个点是断开的。那么我们应该如何处理这一点呢？


------------

#### 方法一

受[石子合并](https://www.luogu.com.cn/problem/P1880)启发，设第 $N$ 个点和第 $1$ 个点是断开的，我们考虑把这个区间复制一份放到原来的这个区间后面，然后 DP。最后从这个长度为 $2 * N$ 的区间里所有长度为 $N$ 的情况中取最优解。但我没这么搞，而且空间似乎有问题。不知道行不行得通，反正我们有更好的方法！！！

#### 方法二

我们分类讨论DP 两次！

##### 情况一

第 $N$ 个数不选。这样即使选了第 $1$ 个数，它的值也没什么用，所以完全可以假设第 $N$ 个点和第 $1$ 个点是断开的了。

##### 情况二

第 $N$ 个数选。这样就不可以假设第 $N$ 个点和第 $1$ 个点是断开的了。但这样我们可以强制选取第 $N$ 个数。第 $N$ 个数选了，那么第 $1$ 个数的权值就可以发挥作用了。转移方程不变，只要改动一下初始化即可：
```
f[1][0][0]=0;
f[1][1][1]=w[1];
//其余为负无穷
```


------------
## 上代码
```
#include<bits/stdc++.h>
using namespace std;
int w[3840];
int f[3840][3840][2];
int INF=0x3f3f3f3f;
int main(){
	int n,m;
	cin>>n>>m;
	for(int i=1;i<=n;i++)
		cin>>w[i];
	memset(f,-0x3f,sizeof f);
	f[1][0][0]=0;
	f[1][1][1]=0;
	for(int i=2;i<=n;i++){
		for(int j=0;j<=m;j++){
			f[i][j][0]=max(f[i-1][j][0],f[i-1][j][1]);
			f[i][j][1]=-INF;
			if(j)
				f[i][j][1]=max(f[i-1][j-1][0],f[i-1][j-1][1]+w[i]);
		}
	}
	int ans=f[n][m][0];
	memset(f,-0x3f3f3f,sizeof f);
	f[1][0][0]=0;
	f[1][1][1]=w[1];
	for(int i=2;i<=n;i++){
		for(int j=0;j<=m;j++){
			f[i][j][0]=max(f[i-1][j][0],f[i-1][j][1]);
			f[i][j][1]=-INF;
			if(j)
				f[i][j][1]=max(f[i-1][j-1][0],f[i-1][j-1][1]+w[i]);
		}
	}
	ans=max(f[n][m][1],ans);
	cout<<ans<<endl;
}
```
下面这个加了滚动数组，吸口氧就是目前最优解哦！（~~其实是大佬们懒得吸氧~~）

```
#include<bits/stdc++.h>
using namespace std;
int w[3840];
int f[2][3840][2];
int INF=0x3f3f3f3f;
int main(){
	int n,m;
	cin>>n>>m;
	for(int i=1;i<=n;i++)
		cin>>w[i];
	memset(f,-0x3f3f3f,sizeof f);
	f[1][0][0]=0;
	f[1][1][1]=0;
	for(register int i=2;i<=n;i++){
		for(register int j=0;j<=m;j++){
			f[i&1][j][0]=max(f[(i+1)&1][j][0],f[(i+1)&1][j][1]);
			f[i&1][j][1]=-INF;
			if(j)
				f[i&1][j][1]=max(f[(i+1)&1][j-1][0],f[(i+1)&1][j-1][1]+w[i]);
		}
	}
	int ans=f[n&1][m][0];
	memset(f,-0x3f3f3f,sizeof f);
	f[1][0][0]=0;
	f[1][1][1]=w[1];
	for(register int i=2;i<=n;i++){
		for(register int j=0;j<=m;j++){
			f[i&1][j][0]=max(f[(i+1)&1][j][0],f[(i+1)&1][j][1]);
			f[i&1][j][1]=-INF;
			if(j)
				f[i&1][j][1]=max(f[(i+1)&1][j-1][0],f[(i+1)&1][j-1][1]+w[i]);
		}
	}
	ans=max(f[n&1][m][1],ans);
	cout<<ans<<endl;
}
```