### 题意简述

给出 $n$ 个可能的密码以及正确的密码。从短到长尝试密码，只有试完一种长度的所有密码，才可以去试下一个长度的密码。对于一种长度的所有密码，每次试的时候都是随机尝试的。每试一个密码需要一秒钟的时间，连续 $k$ 次试错需要多等待五秒。求最好情况和最坏情况各需要多长时间。

### 题目分析

题目难度：普及-

$\text{AC code}$ 时间复杂度大概为 $\Theta(n)$

### 解题思路 

因为每个密码的长度都不超过 $100$ ,所以可以把每个密码字符串的长度开桶储存一下，然后利用桶来统计出长度小于正确密码长度的字符串的数量，在这个基础上，最好的情况是只需要再试 $1$ 次就可以了，最坏的情况是需要把所有长度等于正确密码长度的字符串都尝试一遍才能取到正确答案，统计出次数之后按题中的要求计算出所需时间即可。

### AC code

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,k,a[105];
string str;
int main()
{
	ios::sync_with_stdio(false);//cin、cout优化 
	cin>>n>>k;
	for(int i=1;i<=n;i++)
	{
		cin>>str;
		a[str.length()]++;//字符串的内容没有用，按长度存在桶里就可以了。 
	}
	cin>>str;
	int l=str.length();//l代表密码字符串的长度。 
	int s=0;
	for(int i=0;i<l;i++)
	{
		s+=a[i];//s代表长度小于l的字符串的数量。 
	}
	int x=s+1,y=s+a[l];//x和y分别代表最好和最坏情况所需尝试的次数。 
	cout<<(x-1)/k*5+x<<" "<<(y-1)/k*5+y<<endl;
	return 0;//完结撒花 
}
```