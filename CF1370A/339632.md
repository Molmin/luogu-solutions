这道题想明白了就很简单了~

我们来看思路。数据范围不允许我们暴力，那我们就来看看$O(1)$的做法吧~

### 本文中$/$运算符均指向下取整。

对于一列数$1,2,3,4,5,6$，我们不难发现$gcd(3,6)=3$是最大的。

这个$3$恰好是$6/2$。哎，测试数据好像都符合这个规律。

难道它是对的？

恭喜你，AC了：

```cpp
#include <iostream>
using namespace std;
int main()
{
    int t,n;
    cin>>t;
    while (t--)
    {
        cin>>n;
        cout<<n/2<<endl;
    }
    return 0;
}
```
代码太简单，就不解释了。

好了，接下来我们来详细证明一下这个结论。

首先，对于$n/2$这个值一定是可以取到的：

如果$n$是偶数，取$n/2,n$；否则，取$n/2,n-1$。

那么为什么$n/2+1$这个值一定取不到呢？我们来把所有$n/2+1$的倍数列出来：

$n/2+1,n+2$（或$(n-1)+2=n+1$）。很显然第二项**一定大于$n$**。

这个时候我们就可以说明：在$<=n$的整数中，有且只有一个整数是$n/2+1$的倍数，这个值取不到。

好了，这篇题解就到这里了，求赞！