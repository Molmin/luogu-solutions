- Update on 2022.10.27：修改 typo。

> [CF1063F String Journey](https://www.luogu.com.cn/problem/CF1063F)

提供一个线性且 DP 部分非常好理解，非常好写的做法。

将字符串翻转，$t$ 的限制更新为 $t_i$ 为 $t_{i + 1}$ 的子串，显然这不影响答案。

我们有以下两条结论，其它题解已经解释得很清楚了：

- $|t_i| = i$。找到第一个使得 $|t_i| > i$ 的位置，一定可以删去开头或末尾且不影响合法性。
- 设 $f_i$ 表示使得存在 $t_k$ 满足 $t_k$ 以 $s_i$ 结尾的最大的 $k$，即对 $s[1, i]$ 求解原问题且 $|t_k| = k$ 且强制 $t_k$ 取到 $s_i$，那么 $(i - 1) - f_{i - 1} + 1 \leq i - f_i + 1$。反证法，易证若 $f_i$ 可以更大，若 $f_{i - 1}$ 总可以更大。

既然 $i - f_i + 1$ 随着 $i$ 增大具有单调性，不难想到双指针。我们实时维护 $l, r$ 表示 $l = r - f_r + 1$，则 $l, r$ 单调不降。建出 SAM，维护 $p$ 表示 $s[l, r]$ 在 SAM 上的状态。

当 $r\to r + 1$ 时，我们检查当前 $s[l, r]$ 是否可以作为 $t_k$，称为合法。若不合法，则不断将 $l$ 增大，直到 $l = r$。判定合法的条件容易通过实际意义推导得出：当且仅当存在 $s[l', r']$ 使得 $r' < l$ 且 $s[l', r']$ 为 $s[l, r]$ 去掉开头或结尾且 $s[l', r']$ 合法。此外，若 $s[l, r]$ 合法，则对于任意 $i\in [l, r]$，$s[i, r]$ 合法。

综合上述分析，结合 $l$ 不降的性质，可以得到如下算法：

- 维护 $g_p$ 表示 SAM 上状态 $p$ 对应的最长合法子串长度。

- 在指针状态为 $l, r$ 时，$g$ 只考虑所有右端点小于 $l$ 的合法串。
- 检查 $s[l, r]$ 是否合法，只需检查 $s[l, r - 1]$ 对应的 $g$ 和 $s[l + 1, r]$ 对应的 $g$ 的较大值是否 $\geq r - l$。若合法则退出。
- 若不合法，则将所有以 $l$ 为右端点的合法串 $s[i, l](l - f_l + 1\leq i \leq l)$ 标记为合法。具体地，考虑 $p$ 表示 $s[l - f_l + 1, l]$ 对应的状态，将 $g_p$ 和 $f_l$ 取 $\max$。然后不断跳 $p$ 的祖先，若 $g_p = \mathrm{len}(p)$，说明当前 $p$ 的所有祖先 $a$ 均满足 $g_a = \mathrm{len}(a)$，不需要再向上跳了；否则令 $g_p$ 更新为 $\mathrm{len}(p)$。最后 $l\to l + 1$。

小细节：当前 $s[l, r]$ 的状态 $p$ 容易维护，而 $s[l, r - 1]$ 的状态可以在 $r\to r + 1$ 之间记录 $q = p$ 快速求得。

$\max f_i$ 即为所求。视字符集为常数，时间复杂度均摊 $\mathcal{O}(n)$。[代码](https://codeforces.com/contest/1063/submission/177820601)。