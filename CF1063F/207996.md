## 声明

博客编辑页和管理员题解审核页使用的 $\KaTeX$ 版本较低，不支持 `\def` 指令，可能会导致本题解中的部分公式渲染异常．而在题目对应的题解展示页面和个人博客渲染页面使用的 $\KaTeX$ 为高版本，则无此问题．

## 做法 1

首先我们可以将字符串 $s$ 前后翻转，问题转化为令每个 $t_i$ 是 $t_{i+1}$ 的真子串．可以发现转化后的问题与原问题答案相同．

**性质 1.** 一定至少存在一种 $k$ 最大的方案 $t_1, t_2, \cdots, t_k$，使得对于整数 $i \in [1,k-1]$，均有 $t_{i+1} \in \{\mathtt{c} + t_i,  t_i + \mathtt{c}\}$，其中 $\mathtt c$ 为任意小写英文字母，$+$ 表示字符串拼接．

> **证明.** 假设有一组 $k$ 最大的方案 $t_1, t_2, \cdots, t_k$，不满足上述性质．我们找到第一个不满足上述性质的字符串 $t_i$，则 $t_{i+1}$ 一定能表示成 $a + t_i + b$ 的形式，且字符串 $a,b$ 有至少一个非空．假设 $a$ 非空，我们令 $a'$ 为 $a$ 的最后一个字符，令 $t_{i+1} = a' + t_i$；假设 $b$ 非空，我们令 $b'$ 为 $b$ 的第一个字符，令 $t_{i+1} = t_i + b'$．显然修改后的 $t_{i+1}$ 为为原 $t_{i+1}$ 的子串，且 $t_i$ 依然满足为 $t_{i+1}$ 的真子串．又由于「真子串的子串也是真子串」，所以修改后的 $t_{i+1}$ 是 $t_{i+2}$ 的真子串．我们对这组方案重复这个过程，即可得到一组符合性质的方案．$\square$

考虑设 $\operatorname{dp}(i)$ 为钦定 $t_k$ 以 $s$ 中的下标 $i$ 结尾，此时 $k$ 的最大值．转移 $\operatorname{dp}(i) \gets k+1$ 成立的充要条件是存在至少一个 $j$ 满足：

1. $k \le \operatorname{dp}(j)$．
2. $j+k \le i$．（为了防止 $t_k$ 和 $t_{k-1}$ 重叠）
3. $s_{[j-k+1,j]} \in \{s_{[i-k+1,i]}, s_{[i-k,i-1]}\}$．（根据性质 1）

直接转移困难．考虑可以二分 $k$ 的值，然后判断是否存在合法的 $j$．问题转化为：维护一个集合，支持向集合中插入一个字符串的所有后缀，查询一个字符串是否在集合中存在．我们可以对 $s$ 建立 SAM，在后缀树上维护单点标记，查询子树中是否存在标记来做到这一点．但是注意到可能会出现多个长度不同不同的 $s$ 的子串共用一个后缀树结点，需要改为维护子树标记的 $\mathit{len}$ 的最大值来解决．又由于存在 $j+k \le i$ 的限制，我们需要对线段树进行可持久化，并在对应版本上查询．

该做法时间复杂度为 $O(n |\Sigma| + n (\log n)^2)$．其中的两个 $\log$ 分别是「二分」和「倍增找到后缀树对应结点和线段树操作」．由于时间复杂度过高，该做法无法通过此题，需要进一步优化．

## 做法 2

**性质 2.** 对于整数 $i \in [2,k]$，有 $\operatorname{dp}(i) \le \operatorname{dp}(i-1) + 1$．

> **证明.** 考虑反证，假设存在 $i$ 不满足以上性质，设 $\operatorname{dp}(i)=k$，并记录这个 DP 值对应的方案为 $t_1, t_2, \cdots, t_k$．根据性质 1，$t_k$ 一定是 $t_{k-1}$ 在首或尾添加一个字符得到的．分类讨论：
>
> - 若是在首添加，我们可以找到 $t_k$ 的最后一个字符是从 $t$ 序列的第几个字符串开始被添加进来的，记这个字符串在 $t$ 中的下标为 $p$，则我们可以将 $t_p$ 从序列中删除，并将 $t_{p+1}, t_{p+2}, \cdots, t_{k}$ 的最后一个字符删掉．
> - 若是在尾添加，我们可以删掉 $t_k$ 的最后一个字符并将 $t_{k-1}$ 从序列中删除．
>
> 经过以上操作，我们得到了一个最后一个字符串以下标 $(i-1)$ 结尾且长度为 $(k-1)$ 的方案．由此可知 $\operatorname{dp}(i-1) \ge k - 1$，与假设矛盾．$\square$

我们可以将二分 DP 值 $k$ 改为从 $(\operatorname{dp}(i-1)+1)$ 到 $1$ 依次枚举尝试．根据性质 2，DP 值变化量是 $O(n)$ 的．同时由于枚举的过程中 $i-k$ 单调不降，故我们可以将线段树的可持久化删除，改为扫描线，因此进一步缩小常数．

该做法时间复杂度为 $O(n |\Sigma| + n \log n)$．相较做法 1 去除了二分的 $\log$．可以通过此题．

### 代码参考

```cpp
inline int Jump(int x, int len) {
  per (i, 20, 0)
    if (sam.d[fa[x][i]].len >= len) x = fa[x][i];
  return x;
}

inline bool Ck(int i, int k) {
  int j = Jump(i, k), res = seg.Ask(dfn[j], dfn[j] + sz[j] - 1, 1, 1, sam.tot);
  return res >= k;
}

signed main() {
  ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
  cin >> n >> (s + 1);
  reverse(s + 1, s + n + 1);
  re (i, n) ed[i] = sam.Add(s[i] - 'a');
  rep (i, 2, sam.tot) e[sam.d[i].lk].push_back(i);
  Dfs1(1);
  int p = 1;
  dp[1] = 1;
  int ans = 1;
  rep (i, 2, n)
    for (dp[i] = dp[i - 1] + 1; dp[i] > 1; --dp[i]) {
      while (p <= i - dp[i]) seg.Cha(dfn[Jump(ed[p], dp[p])], dp[p], 1, 1, sam.tot), ++p;
      if (Ck(ed[i], dp[i] - 1) || Ck(ed[i - 1], dp[i] - 1)) {
        up(ans, dp[i]);
        break;
      }
    }
  cout << ans << '\n';
  return 0;
}
```
