[传送门](https://www.luogu.com.cn/problem/AT4740)

---

题目大意：

* 你会以相同的几率得到一个在 $1$ 到 $n$ 之间的正整数。

* 当这个数在 $[1, k-1]$ 时，它有 $\dfrac 1 2$ 的几率翻倍；有 $\dfrac 1 2$ 的几率归零；对得到的新数重复这一步骤。

* 若最后这个数大于等于 $k$ 则获胜。求获胜的概率。

* $n$、$k \le 10^5$。

注意到本题范围：$n \le 10^5$，这对于数学题来说是比较小的，可以考虑暴力求解。

思路：

1. 对每一个 $1$ 到 $n$ 之间的数分别求概率。

2. 通过模拟来求得每个数最后大于等于 $k$ 的概率。

---

#### 模拟部分：

~~如果这部分看不懂，直接看代码就好了。~~

设 $x$ 最终大于等于 $k$ 的几率为 $P(x)$。

设当前数为 $j$，那么这个数有 $\dfrac 1 2$ 的几率增加至 $2j$，有 $\dfrac 1 2$ 的几率变成 $0$。即 $P(j)=\dfrac 1 2P(2j)+\dfrac 1 2P(0)$。

而若得到 $0$，则直接失败，即 $P(0)=0$。

故 $P(j)=\dfrac 1 2P(2j)$。

以此类推，$P(2j)=\dfrac 1 2P(4j)$，$P(4j)=\dfrac 1 2P(8j)$ $\text{……}$如图。

![图](https://z3.ax1x.com/2021/05/13/gDAeXV.png)

即 $P(j)=\dfrac 1 {2^m} P(2^mj)$，直到 $2^mj \ge k$，此时有 $P(2^mj)=1$。

代码：

```cpp
double p=1;
while(j<k) {
	j*=2;	//j 变为 2j
	p/=2;	//乘上 1/2
}
ans+=p/n;	//由于只有 1/n 的几率得到 j，所以要除以 n
```

复杂度证明：

由于开始时得到的 $j \ge 1$，而 $j\ge k$ 时 `while` 就会终止，每次将翻倍，故 `while` 最多执行 $\log k$ 次，时间复杂度 $\Theta(n\log k)$。

---

主体部分已经有了，完整代码就不给出了（