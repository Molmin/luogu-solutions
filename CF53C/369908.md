### 1. 分析

首先，理解题意后，就可以很明显的看出是一道模拟题，一般这种题可以先找到一种方案，再用代码执行。

**这道题的思路还是比较好找的，首先看到题目中没有限定青蛙对多走几米，只限定了两次跳跃路径的长度不同，那么这道题可自由度就很高了。下面是一种最常用的方法**

### 2. 方法
#####   ~~秘技之左右横跳~~：
 
 为了不使跳跃路径长度重复，可以**从较大跨度慢慢往较小跨度**去跳，~~就像在天平上摆砝码一样~~，从大往小放。所以先从第一个土堆跳到第n个土堆，这时候跳了我 $n-1$ 步，然后从第n个土堆跳到第2个土堆，这时跳了 $n-2$ 步，一直循环到最中间，然后没走一个来回输出两个走到的土堆，这就是这种解法的核心思路。代码如下：

------------

```cpp
	for(int i = 1; i <= n / 2; i++){
		cout << i << ' ' << n - i + 1;
	}
```


------------


**注意，如果 $n$ 是奇数的话，最中间的那个数是遍历不到的**。举个栗子：
 当n为5时，按照原来的思路，这使得路径是：1-5-2-4，会发现3没有被遍历到,所以当n为奇数时，我们需要补一个 $(n/2+1)$ 。
 


### 3. 代码实现

现在思路已经清晰地出来了，下面是完整代码：

------------
```cpp
#include <bits/stdc++.h>
using namespace std; 

int main(){
	int n;//n表示土堆 
	cin >> n;
	for(int i = 1; i <= n / 2; i++){//因为是来回遍历，一次输出两个数，所以为了避免重复，循环条件是i<=n/2 
		cout << i << ' ' << n - i + 1 << ' ';
	}
	if(n % 2 == 1){//特判当n为奇数时的情况 
		cout << n / 2 + 1;
	} 
	return 0;
}
```


### 谢谢食用