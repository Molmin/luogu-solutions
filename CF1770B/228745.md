## 题目大意

给定两个整数 $n$ 和 $k$ ，要求构造一个长度为 $n$ 的排列使得该排列所有长度为 $k$ 的字段的最大值和最小值之和中的最大值最小。

## 具体思路

- 我们首先考虑 $k=2$ 的情况

	此时问题等价于让所以相邻点对的和的最大值最小。
	
	考虑将从 $1$ 到 $n$ 的 $n$ 个整数依次插入一个初始为空的序列。

	不难想到，每次依次插入当前的最大值和最小值，若最后剩余一个则直接插入即可，这样可以使得每个相邻点对的和尽量平均，从而让和的最大值	最小。

	例子：

	```
	input:
	5 2
	output:
	5 1 4 2 3
	```

- 我们接着考虑 $k=3$ 的情况

	此时考虑的情况相当于将之前 $k=2$ 时的每个区间考虑范围向后拓展一	个，并且删去上述情况中的最后一个区间。

	由于每次依次插入最大值和最小值，所以区间向后扩展出的数必然小于原区间最大值，大于原区间最小值,这样向后扩展出的数对原答案没有影		响，所以我们依然可以使用在上一情况中使用过的构造方法。

- 最后我们讨论 $k$ 为其他数的情况

	假设 $k=4$ ，此时的情况仍相当于 $k=3$ 时的区间扩展一步，所以同	述情况的证明可得，原构造方法仍成立，对于其他情况也可以类推证明，**	故所有情况下均可用原构造方法：考虑将从 $1$ 到 $n$ 的 $n$ 个整数依次插入一个初始为空的序列，每次依次插入当前的最大值和最小值，若最后剩余一个则直接插入即可。**

## 代码实现

实现很简单，赛时代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
int t;
int main(void)
{
	cin>>t;
	while(t--)
	{
		int n,k;
		cin>>n>>k;
		for(int i=1;i<=n;i++)
		{
			if(i%2==1)cout<<n-(i+1)/2+1<<" ";
			else cout<<i/2<<" ";
		}
		cout<<endl;
	}
	return 0;
}
```



