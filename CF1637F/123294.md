> CF1637F Towers

考虑这样一个过程：我们总会在某两个经过 $h_{\max}$ 的叶子 $x, y$ 处放上 $h_{\max}$，那么 $x, y$ 之间所有点均被覆盖。接下来，每选择一个叶子 $u$，我们都希望能够利用 $x$ 或 $y$，在 $u$ 处放一个尽量小的塔，能够覆盖从 $u$ 到离它最近的一个已经被覆盖的节点（不含）的所有节点，其权值即这些节点的 $h$ 值的 $\max$。

根据上述理解，我们有如下贪心算法：考虑在一开始在所有节点处都放上 $h$，然后将所有标记 **下放**。具体地，从权值最大的节点开始（因为它最特殊，要有两个叶子才能覆盖，其它节点只要一个叶子：利用已经放上 $h_{\max}$ 的 $x$ 或 $y$）对整棵树进行深度优先搜索。对于根节点，它要有 **两棵** 子树各一个叶子节点放上 $h_{\max}$。对于其它节点 $u$，它只需要有某个子树的某个叶子节点放上 $\geq h_u$ 的权值即可。

因此，记录 $f_u$ 表示子树 $\max h$。对于叶子节点 $v$，令答案加上 $h_v$。对于非根节点 $u$，令答案加上 $\max(0, h_u - \max\limits_{v\in \mathrm{son}(u)} f_v)$。对于根节点 $R$，令答案加上 $2h_R$ 减去其子节点最大的两个 $f$ 值。最终答案即为所求。时间复杂度是极其优秀的线性，[代码](https://codeforces.com/contest/1637/submission/146185023)。

赛时做法：以最大值节点为根对整棵树进行深度优先搜索，标记根节点。按权值从大到小遍历每个非最大值节点，若当前节点 $u$ 没有被覆盖，则找到最近的被覆盖的祖先 $a$。若 $a$ 的路径已经延伸到其它子树里面（这意味着 $u$ 不是 $a$ 的 $f$ 值最大的子树），说明我们可以将 $u$ 的子树的某个叶子放上 $h_u$，从而覆盖 $u\to a$ 上的所有节点，令其权值为 $h_u$。否则，我们可以直接让 $a$ 的路径延伸到 $u$，令其权值为 $a$ 的权值。每个叶子的权值之和即为所求。注意若祖先为根节点，则必须向下延伸 $2$ 条路径，$u$ 才能在自己的子树内放上 $h_u$ 而非 $h_a$。[代码](https://codeforces.com/contest/1637/submission/146132848)。