我高度怀疑这是不是 `*2500` 难度的题，感觉我这种脑子不应该这么快想出来吧（

## 思路

一眼想到一个性质：最好就是把每个点涵盖到根到叶子节点的路径上，这样应该是最优的情况。所以，我们根尽量放最大的。另外，如果在一个非叶子节点放一个塔，把它移到叶子结点，只会使答案更优，不会更劣。所以，我们对于每一个非根节点，都可以从他的子树里面选出一个节点把它包含到这个节点到根的路径里面。

就比如对于点 $u$，他子树内有一个点 $k$，它的高度是 $h_k$。我们只需要让 $h_k \geq h_u$ 就可以，因为根节点的 $h$ 一定是最大的，已经满足了条件。所以我们贪心的从子树选最大 $h$ 来比较即可，这样可以最大化减少不满足条件的情况。

具体实现就是很简单的，对于每个节点，记录一下子树最大值，每次和这个节点判断一下谁更大。如果是子树内更大，那么已经包含就去了就不用管了；否则，就把那个节点加上还差的数量。不过这里不用去记录是哪一个节点，因为上传之后这个节点是否修改并不会答案造成影响。

最后处理根节点，我们直接找到最大和次大的两个节点，把它们都改成根的大小，这样根就包含在了一个从下到根，再向下的这么一个路径上。

然后就处理完了所有情况。注意一下代码细节即可。

## 代码

注意开 long long，虽然看上去可能不用。~~别问我怎么知道的~~。

```cpp
#include <bits/stdc++.h>
#define ll long long 
using namespace std;
const int MAXN=200005;
ll a[MAXN],b[MAXN],ans=0;
vector<int> E[MAXN];
void dfs(int u,int fa){
	ll mx1=0,mx2=0;
	for(int i=0;i<E[u].size();i++){
		int v=E[u][i];
		if(v==fa) continue;
		dfs(v,u);
		if(b[v]>mx1) mx2=mx1,mx1=b[v]; // 更新最大值、次大值 
		else if(b[v]>mx2) mx2=b[v];
	}
	b[u]=max(mx1,a[u]); // 数组记录方便上传最大值 
	if(a[u]>mx1) ans+=(a[u]-mx1); // 如果 a[u] 比子树内最大的还大，说明需要补 
	if(fa==-1 && a[u]>mx2) ans+=(a[u]-mx2); // 根节点时 fa=-1，这个时候需要用次大值更新答案 
}
int main(){
	int n,rt=0; cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
		if(a[i]>a[rt]) rt=i; // 找到 a[i] 最大的 i 作为根节点 
	}
	for(int i=1;i<n;i++){
		int u,v; cin>>u>>v;
		E[u].push_back(v);
		E[v].push_back(u);
	}
	dfs(rt,-1);
	cout<<ans;
	return 0;
}
```

~~另：50 紫题祭，菜死了/kk。~~