## 分析

我们看到这道题，很容易想到一个广为人知的算法`DFS`！！

但是我们悄悄看一眼数据范围，脑子里思考一下，会超时

那我们怎么办呢?

我们来看一看到达一个格子的方案是从哪里来的?

发现一个格子的到达的方案总数是它**上面的格子的方案总数**加上**左边的格子的方案总数**

这不就是一个动态规划的简单题吗?

我们定义$dp_{i,j}$表示坐标为$(i,j)$的格子的到达的方案总数。

于是我们就得到了一个转移公式$dp_{i,j}=dp_{i-1,j}+dp_{i,j-1}$。

但值得注意的是，我们的地图中有一些格子是无法到达的，这是要将这个格子的$dp$值赋为$0$，这样就不会对之后的操作有影响了。

最后注意$dp_{1,1}$要赋为$1$，一开始就在$(1,1)$处，算作一种方案

## 代码
```c++
#include <bits/stdc++.h>
using namespace std;
int h, w, dp[1005][1005];
char c[1005][1005];
int main()
{
    cin >> h >> w;
    for(int i = 1; i <= h; i ++)
    {
        for(int j = 1; j <= w; j ++)
        {
            cin >> c[i][j];
        }
    }
    dp[1][1] = 1;//初始值
    for(int i = 1; i <= h; i ++)
    {
        for(int j = 1; j <= w; j ++)
        {
            if(c[i][j] == '#' || (i == 1 && j == 1)) continue;//特殊处理，在上文中有提到。
            dp[i][j] = (dp[i - 1][j] + dp[i][j - 1]) % (1000000007);//状态转移(记得取模!!)
        }
    }
    cout << dp[h][w] << endl;//输出
    return 0;
}
```