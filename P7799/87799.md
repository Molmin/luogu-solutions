前置基础：解一元一次方程 (包括会判无解和无数解的情况)

先将这些标准音全部减去第一个标准音。因为第一个音一定弹对，所以后面会好做一些。(当然，不减也可以做，只是麻烦一些) 

考虑把弹的音用 $ak$ 来表示。(对于每一个 $i$ , $a$ 为常数,但可以通过计算得到)

比如,对于样例,标准音为 $\{2,1,-6,-2,1,6,10\}$ , 那么可以计算出 $a=\{0,-1,-2,-1,0,1,2\}$。

然后再对于每个音，求出要弹对这个音，$k$ 应该是多少。(要特判 $a=0$ 的情况) 求解过程就是解一元一次方程。

比如对于样例，$\text{k=\{任意,1,4,4,无解,4,4\}}$，这些任意或无解都是 $a=0$ 的情况。

弹对音的个数最多,需要少数服从多数，$k$ 数组中出现最多的值就作为 $k$ 值。那么总弹对个数就是 $\text{出现次数+任意解个数}$ 。

如何求出现最多的数?最简单的办法是桶。但是桶显然装不下。所以考虑参照桶排序方法逆向优化。

即把所有数不装在桶中，**装在一个数组中**，然后将其**排序**。

所有相同的数都被放在了一起，所以就统计这些数，取最大值就可以了。(不细讲这个步骤，见代码)

时间复杂度:$O(n\times\log_{2}(n))$。
```cpp
#include<iostream>
#include<algorithm>
using namespace std;
int zyl[1000005]; //每个数的k值。 
int main(){
	int n,i,A,B=0,ykb=0,tot=0,Max=0,maxid=-1,sum=1,tkr=1,first=0; //ykb:当前的数是k*ykb,就是原文中的a;tkr:任意解的数量。A为当前输入的数,B为上一次输入的数。 
	cin>>n>>first;
	for(i=1;i<n;i++){
		scanf("%d",&A);
		A-=first;
		if(A>B){
			ykb++;
		}
		if(A<B){
			ykb--;
		}
		if(!ykb){ //如果ykb==0,A=0那么说明有任意解,A!=0,说明无解。
			tkr+=(!A);
		}else{
			if(!(A%ykb)&&A/ykb>=0){ //判是否是非负整数。
				zyl[tot++]=A/ykb;
			}
		}
		B=A; //下一次的上一次就是本次的A。
	}
	sort(zyl,zyl+tot);
	zyl[tot]=-20181110; //一定要赋成一个与数组中其他元素不同的数,方便i=tot时的操作,可见下行注释。
	for(i=1;i<=tot;i++){ //数组本来是0~tot-1,但是由于最后一次的结果没取max,所以就执行i=tot,并且让此时zyl[i]!=zyl[i-1](上行的操作),将其计算进Max。而当i=0时访问a[i-1]会数组越界,并且当i=0时一定与上一位不同(毕竟都没有上一位),因此跳过了i=0。
		if(zyl[i]==zyl[i-1]){
			sum++;
		}else{
			if(sum>Max){
				Max=sum;
				maxid=zyl[i-1];
			}
			sum=1;
		}
	}
	cout<<tkr+Max<<endl<<maxid;
	return 0;
}
```
题外话:

一开始把题目看成了 如果下一个音符的标准音大于当前弹的音就加 $k$;... 然后想了半天发现自己不会做黄题。(这个~~坑人~~样例竟然以这个错误的方式都可以过...)

后面又发现,上一个标准音等于这一个标准音,根本就不会变。(还是这个~~坑人~~样例,连等于的情况都没有)

所以读题要仔细,样例都可能发现不了读题问题。