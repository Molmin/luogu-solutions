前方高能预警：巨大坑题\*1！。。。

楼下各位大佬都说此题很简单，但我想说的是比赛中要一次性拿到100分绝对不容易（至少对我而言），因为众所周知，noip竞赛中的模拟题都是坑上加坑，让你感觉会做但也别想拿满分（详见：寻宝，排座椅，字符串的展开等）。更何况，本题AC的人也不多。

好了，言归正传，本题算法：模拟，标签上写的什么“交叉模拟”，不管了。

这题坑就坑在它不是一行读完，而是会分多行，这样字符串读入就相当困难了，只能一个个字符读进去。我的思路是第一次边读边做，把11进制的处理完并塞到一个字符数组里去，然后第二次扫描字符数组，完成对21进制的处理即可。

代码有点长，但好像比楼下大佬的要好理解一些。。

上AC代码：

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
int a11=0,b11=0,a21=0,b21=0;
char c,s[100000]; //第一个坑点，这题读入的字符串贼大。
void work1() //第一次处理：边读边做，算11进制
{
     int t=0;
     while(true)
     {
        if(c=='W'||c=='L') 
        {
        s[t]=c; t++; //将每一个“W”或“L”放入字符数组中
      }
      if(c=='E') break;
      if(c=='W') a11++;
      if(c=='L') b11++; 
      if((a11>=11||b11>=11)&&(abs(a11-b11)>=2))
      {
        printf("%d:%d\n",a11,b11);
        a11=0; b11=0;
      }
      scanf("%c",&c); //简单模拟，不解释
    }
     printf("%d:%d\n\n",a11,b11); //第二个坑点，不管最后是不是0：0都要输出
}
void work2() //第二次处理：利用字符数组计算21进制
{
     for(int i=0; i<strlen(s); i++)
    {
      if(s[i]=='W') a21++;
      if(s[i]=='L') b21++;
      if((a21>=21||b21>=21)&&(abs(a21-b21)>=2))
      {
        printf("%d:%d\n",a21,b21);
        a21=0; b21=0;
      }
    }
    if(!(a21==0&&b21==0)) printf("%d:%d\n",a21,b21); //此处同上，不解释
}
int main()
{
     scanf("%c",&c); 
     if(c=='E') //特判，不然第一个数据一上来就是个E就傻了。。
     {
        printf("0:0\n\n");
        printf("0:0\n");
        return 0;
     }
     work1(); //计算11进制
     work2(); //计算21进制
     return 0;
} //结束
```