Upd3 on 2020/9/25:

恭喜 YL·工具人·鸽子·Wang 成功使用 $O(2^4nlog nlogT)$ 的复杂度通过了本题，这也证明了我下面描述的算法的正确性。

大家可以去[他的博客](https://www.luogu.com.cn/blog/YLWang/solution-cf1419f#)里帮他点个赞，也非常感谢他所做出的贡献（

在 $n=1000$ 的情况下上面的做法被暴力老哥按在地上捶，所以我们要把 $n$ 开到 $10^5$（

Upd2 on 2020/9/24:

YLWang 神仙说这东西有一部分假掉了，修了一下部分内容

Upd1 on 2020/9/24:

看到了 YLWang 神仙用线段树分治把我那个转化后的数据结构题（雾）切掉了，特别开心，因为这可能是本题唯一的一个优化复杂度的方向了。但是他的做法是 $2$ 只 $log$ 的（除去二分的部分），个人认为应该可以做到 $1$ 只 $log$，这里详细说明一下。

之前没看过这篇题解的可以先看完原答案

考虑这样一个问题：

现在你有 $n$ 次操作 $(n\le 1000)$，每次操作给定一个点的坐标 $(x,y)$ 和两个正整数 $t,id$，$(|x|,|y|\le 10^9)$且均为整点

对于 $id=1$，每次操作你需要把所有距离 $(x,y)$ 为 $t$ 的整点全部染成红色。

对于 $id=2$，每次操作你需要把所有距离 $(x,y)$ 为 $t$ 的整点全部染成蓝色。

对于 $id=3$，每次操作你需要把所有距离 $(x,y)$ 为 $t$ 的整点全部染成紫色。

对于 $id=4$，每次操作你需要把所有距离 $(x,y)$ 为 $t$ 的整点全部染成绿色。

求最后平面上是否存在一个点是四色的。

考虑扫描线，随便找个维度扫，比如说从上往下扫吧

考虑维护列的线段树，

每次扫到一列就把那列的那个颜色单点 $+1$，那列结束后就单点 $-1$

每次扫到一行，就把那一行分成 $k$ 段，每一段对应的颜色补集是相同的。然后对于每一段，查询一下是否存在操作颜色的补集就好了。

还要注意的是扫到列的时候也要判断是否达成目标（可能一个点被列扫了 $4$ 次之类的

时间复杂度大概是 $O(nlogn*2^4)$，空间复杂度是 $O(n*2^4)$

---

原答案：

这里给一种比较蠢的做法。

首先二分答案 $t$，把距离每个点小于 $t$ 的点 $\text{merge}$ 进一个并查集，那么这样就有 $k$ 个集合

如果 $k=1$ 那么就不需要加点

如果 $k>4$ 那么不管怎么加点都不可能成立，这个可以用反证法证明：我们考虑存在一个点 $(x,y)$ 满足这个点到 $k$ 个集合的最近距离 $\le t$，那么根据咕巢原理，至少有 $k-3$ 个与添加点匹配的点在同一个方向上，那么这些在同一个方向上的点应该在一个集合里，与 $k>4$ 矛盾

具体的，上个图 ![](https://cdn.luogu.com.cn/upload/image_hosting/ywm7j2os.png)

比如说上幅图中，$(0,2)$就是我们要添加的点，$k=5$

你会发现下面两个点在同一个方向上，如果更远的那个点距离 $(0.2)\le t$ 那么这些在同一个方向上的点之间的距离全都 $\le t$，这些点就都应该被 $\text{merge}$ 到一个集合里，推出矛盾。

然后就是数据结构学傻综合症的患者给大家带来的无脑做法了，我们不需要分类讨论 $k$，反正 $k$ 最大也就 $4$，我们考虑对于每一个不同的集合的点$(id,x,y)$（$id$ 表示集合编号），把所有距离 $(x,y)\le t$ 的点全部染成 $id$ 色，那么对于一个点如果存在 $k$ 种颜色，这个方案就是可行的。

具体的话可以直接把点离散化，如果暴力染色的话染色部分的复杂度是 $O(n^2)$ 的，当然也可以用数据结构优化到 $O(nlogn)$(或许可能可以 $O(n)$)
