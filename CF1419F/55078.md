## 1. 算法 1

因为可以在任意位置停留，$T$ 显然满足可二分性。

那么问题就变成了判定性问题。

我们对于每一行和每一列中的距离小于 $mid$ 的点连边。具体可以使用并查集实现。

如果最后仅有一个连通块则不用加入点 $T = mid$ 可行。

关于加入一个点，官方 sol 给出了一个 $O(n^2)$ 的基于目前连通块个数分类讨论的方法。我写的是一种相对暴力的方法。

考虑到一个点可能且仅可能落在 $a_i - mid, a_i, a_i+mid$ 三个位置，我们把它们全部离散化。然后枚举每一个点，并把当前点所在的行和列暴力的 merge 到一个可撤销并查集中，每次加入后检查即可。这个做法是**大常数**的 $O(n^2\log n)$，但还是可以通过。

[提交记录](https://codeforces.com/contest/1419/submission/93295033)


---

## 2. 算法 2


看了 Loveti 的题解觉得很有意思于是去实现了一个两只 log 的做法。~~实在不会一只log，有会的大佬麻烦教教我~~

首先我们考虑最后的问题等价于是否存在一个被四个联通块均覆盖的点。那么问题就变成了一个二维平面上线段增加一种颜色，并查询全局有没有一个被四个颜色覆盖的点。

那么第一思路就是扫描线。然后发现我们并不会维护每个位置上有没有四个数。因为我们要支持删除，于是不能进行区间或一类的不可逆操作。

于是考虑对 $x$ 轴进行线段树分治。分治以后只有插入了可以进行区间或了。

然而我们还是不能简单地维护最大值。读者自证不难。~~也有可能是我naive~~了。

于是我们状压每个区间内每个颜色的出现次数或者是否出现，用 $0-15$ 之间的整数表示状态。这是容易 pushup 和 pushdown 的。

那么总复杂度就是 $O(2^m n\log^2 n\log T)$ 再带一个离散化的常数，其中 $m \leqslant 4$，有点跑不过 $n^2$ 老哥。

[代码](http://codeforces.com/contest/1419/submission/93602185)还是很好写的，不算恶心。

---

## 3. 算法 3


Loveti 给出了一个 log 的做法。其实挺 naive 的但我没有注意到。菜得真实。

我们考虑这个线段加具有的特殊性质。

- 单点加。可能会持续很久。

- 区间加。只会持续 1。

这就启示我们不要往线段树上 apply 区间加，只 apply 单点加。而区间加则可以通过处理之后查询来判断是否合法。容易发现，这样的复杂度是 $O(2^m n\log n\log T)$。

[提交记录在这儿。](https://codeforces.com/contest/1419/submission/93640848)

这玩意还是跑不过暴力老哥，但已经跑得飞快了。或许是我的实现过于奔放而没有任何卡常的原因吧。

---

## 4. 总结
本文给出的三个算法涉及了不同方面的数据结构知识，思维难度由浅入深，如能仔细研究一遍并自己实现应该能大有收获。

若有任何问题请私信 YLWang。

本文的第三个代码实现同时作为 Loveti 的题解的代码实现。~~工具人 YLWang~~。

最后，本题解前后耗时两天写成。希望觉得有帮助的同学们给一个赞让更多人看到。（其实这是我第一次在博内求赞，因为觉得这篇文章确实很有价值，还请帮个忙。）

