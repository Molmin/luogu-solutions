##   一种采用sort的快速排序的方法（分步骤讲解）
   这道题目鄙人的解法主要有两大步骤，首先是去重，接着是排序。
#### 去重
   鄙人去重的方法是通过**bool类型的数组f**来存储在数据范围内（小于30000）每一个数的出现情况。使用for循环，来对输入的每一个数据进行判断。若这个数在输入的数据中出现过，则f[这个数]为true，否则为false。然后在这个数没有出现过的情况下，才把这个数加入新的数组b，同时统计处理过的数据数量（num），并调整f[这个数]的状态为出现过。在对于旧的数据全部处理过后，再对新的数组进行排序（详见下一部分）。
#### 排序
   鄙人采用了**stl里面的sort**快速排序，sort函数进行排序的时间复杂度为O(NlogN)，执行效率比较高，默认为降序。（本程序我们使用降序更加方便）。sort函数使用原则是要左闭右开。最后再判断，如果第k小的数存在，那么就输出排序后的数组的第k个元素，否则就输出NO RESULT。到这里，这道题就搞定了。（程序如下）

  
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[10001],b[10001];
bool f[30001];//判断数字是否出现过
int main() 
{
	int n,k,i,num=0;
	cin>>n>>k;
	for(i=1;i<=n;i++)
		cin>>a[i];//输入相应数据
	for(i=1;i<=n;i++)
	{
		if(f[a[i]]==false)//此数据未出现过的情况下执行，否则跳过
		{
			num++;
			b[num]=a[i];
			f[a[i]]=true;//新的数据总数加1，并把此数据加入新数组，同时把情况改为true（已出现）
		}
	}//去重
	sort(b+1,b+num+1);//对新数组快速排序（左闭右开，降序）
	if(k<=num)//判断删除之后新数据总数是否少于原先要求的k
		cout<<b[k];
	else
		cout<<"NO RESULT";
	return 0;
}
```
