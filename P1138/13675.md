~~~~**这题蒟蒻还是做出来了······~~~~（dalao勿喷）~~

这道题的思路就是先利用数组计数去重，然后排序，输出第k小整数或NO RESULT**

请看程序，本蒟蒻在程序中已标注想法（dalao勿喷）

         
```cpp
#include<iostream>
#include<algorithm>//蒟蒻文件头······ 
using namespace std;
int n,k,i,a,ma,gs; 
int zs[1000000],dn[1000000];//事实证明，变量和数组千万不要一起定义······ 
int main()
{
    ma=-1; 
    cin>>n>>k;//输入有几个数和第几小的数 
    for(i=1; i<=n; i++) //输入数据 
    {
        cin>>a;//同上 
        if(a>ma) ma=a;//由于题目说相同大小的整数只计算一次，所以我们要去重 
        zs[a]++;//大家是否做过“明明的随机数”，那道题也是要去重。可这道题不一样，它还要把去重完的数列储存起来。所以我们可以使用数组计数的的方法。这里，我们下个循环再解释······(手动滑稽)  }
    for(i=1; i<=ma; i++)//当当当当，第二个循环来了！！！ 
    {
        if(zs[i]>0) //前面我们已经做好了数组计数，出现过的数字数量都已储存。所以······只要我们判断一个下标中的数字不为0，那我们就视为它这个数出现过。那么······请看下句
        {
            gs++;//我们后面还要排序，所以我们要保证它的新数组的储存是连续的，所以我们存一个才更新一次下标（即为+1） 
            dn[gs]=i;//然后将那个数储存 
        }
    }
    sort(dn+1,dn+1+gs);    //c++快排，要记住你排序的数组存的数字个数是前面更新下标的变量（就是gs） 
    if(dn[k]==0) cout<<"NO RESULT";//因为不会有一个数为0，所以只要第k下标里的数字为0，就视为它无解 
    else
    cout<<dn[k];//否则就输出第k小的数 
    return 0;//求通过！！！谢谢！！！ 
}
```