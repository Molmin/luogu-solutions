### 题目分析 ：

输入两个非负整数  $ a $ , $ b $ ，转为二进制数按位进行 $ Mofiz $ 运算。

```cpp

Mofiz 运算法则：

0 + 0 = 0

1 + 0 = 1

0 + 1 = 1

1 + 1 = 0
```



------------


### 思路

也就是说，当两个数相同时， $ Mofiz $ 运算的结果为 $ 0 $ ， 否则为 $ 1 $ 。  

只需要暴力枚举 $ a $ , $ b $ 在二进制下每一位 $ Mofiz $ 运算的结果，再转换回十进制数就行了。


那如何求非负整数 $ x $ 在二进制的下第 $ i $ 位呢 ？

我们可以先打一个表  $ f $  , $ f[i] $  的值为 $ 2 $ 的  $ i $  次幂 ，默认 $ x $ 为 $ 0$ 。 从后往前枚举 $ f $ 数组 ， 如果 $ x $ 大于 $ f[i] $ ，那么将 $ x $ 在二进制的下第 $ i+1 $ 位的值改为 $ 1 $  ，操作完记得将 $ x $ 的值 减去 
$ f[i] $ 。


------------


### 打表代码：

```cpp

#include<bits/stdc++.h>
#define ll long long
using namespace std;
ll sum = 1;

int main(){
	cout<<"1,";
	for(int i=1;i<=32;i++){
		sum*=2;
		cout<<sum<<",";
	}
    return 0;
}

```



------------


### AC 代码 ：

```cpp

#include<bits/stdc++.h>
#define ll long long
using namespace std;
ll a ,b ,ans;
ll f[40]={1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,262144,524288,1048576,2097152,4194304,8388608,16777216,33554432,67108864,134217728,268435456,536870912,1073741824,2147483648,4294967296};

int main(){
	while(~scanf("%d%d",&a,&b)){
		ans = 0;                         //记得重置
		for(int i = 32 ;i >= 0 ;i--){    //枚举每个二进制位
			bool A = 0 , B = 0;          // a , b 当前二进制位是否为 1
			if(a >= f[i]){               // a 的当前二进制位是 1
				a -= f[i];
				A = 1;
			}
			if(b >= f[i]){               // b 的当前二进制位是 1
				b -= f[i];
				B = 1;
			}
			if(A != B){                  //如果 a , b 当前二进制位不同
				ans += f[i];             //那么结果加上 f [i] (结果当前二进制位为 1)
			}
		}
		cout<<ans<<endl;
	}
    return 0;
}


```

