## 题意
有 $n$ 个人，第 $i$ 人刚开始有一个字符串 $a_i$，想要换成字符串 $b_i$。问 **能不能** 在同一时刻没有两个人手持的字符串相同的情况下完成调换？
## 样例解释
拿第一个样例和第二个样例举个例子。
```
2
b m
m d
```
第一步：将第二个人的 $m$ 换成 $d$。

第二步：将第一个人的 $b$ 换成 $m$。
```
3
a b
b c
c a
```
尝试满足第一个人，但调换后会跟第二个人重复。

尝试满足第二个人，但调换后会跟第三个人重复。

尝试满足第三个人，但调换后会跟第一个人重复。

所以不行。
## 解题思路
赛后，看了一眼同学的代码，发现是拓扑排序。可我觉得这道题是萌萌的深搜咩。

首先用 `map` 记录每个人手持的字符串。再用哈希记录每个人更改过没有。扫一遍，如果发现有一个人没更改过，就开始深搜。

深搜时，分类讨论：如果这个字符串目前还没有人目前有，就直接换掉，更改 `map` 的数据。反之，就继续深搜那一个阻拦他更改的人，直至找到一个人满足前面的条件，就回溯。若发现进入了一个环，那么也就是说是更改不了，也就是 `No`。

不懂？来，上代码。
## AC code
```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
string a[100010],b[100010];
map<string,int> m;
int h[100010];
map<string,int> id;
void dfs(int x,int dep){
    if(dep>n){//出现环
        cout<<"No";//更改不了这个人，再见
        exit(0);
    }
    if(m[b[x]]){//发现有人阻碍更改
        int y=id[b[x]];
        dfs(y,dep+1);//调查阻碍更改的人
        if(m[b[x]]){//发现还是不行
            cout<<"No";
            exit(0);
        }
        else{//阻碍更改的人没威胁了
            m[a[x]]--;
            m[b[x]]++;//更改
            a[x]=b[x];
            h[x]=1;
            return;
        }        
    }
    else{//没人阻碍更改
        m[a[x]]--;
        m[b[x]]++;//直接更改
        a[x]=b[x];
        h[x]=1;
        return;
    }
}
main(){
    cin>>n;
    for(int i=1;i<=n;i++){
        cin>>a[i]>>b[i];
        m[a[i]]++;
        id[a[i]]=i;//记录位置和次数
    }
    for(int i=1;i<=n;i++){
        if(h[i]==0){//没有更改过
            dfs(i,0);//尝试更改
        }
    }
    cout<<"Yes";
    return 0;
}
```