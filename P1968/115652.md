~~蒟蒻的dp一直很烂，写的不好的地方还请大佬多多关爱。~~

蒟蒻最开始用了一点贪心的思路，如果这一步需要转换的话就全部转化掉，因为转换是为了收益（转换一定收益），不收益就不转换，因此部分转换的话，
那一部分没有转换的本可以转换掉来取得更大的收益，这样便很容易理解不完全转换一定达不到最大收益。

我用了dp的方法处理以下的问题。 

假设现在拿在手里的是马克，如果上一步比现在汇率更高，如果只是在这里就转换为美元，固然会有收获，但如果下一步比现在的汇率更低，
这样便不是最优解了，怎么办？

我的解决方法是在当下处理两种情况，下一步如果比现在的汇率更低，下一步便从这一步转移存下的马克的数量，继续增值，否则就需要存下上一步转化
为美元的情况，避免贬值。这里可以理解的话，便也能理解当前的每一步需要做什么：如果比上一步汇率低，从上一步转移马克数量，处理当前的马克数量
和这一步转化成美元的数量，如果比上一步汇率高，转移上一步转化成的美元的数量（相当于“决定在上一步的那也时间点把手里的马克换为美元”），当前
的美元数量就是上一步转化出美元数量，当前的马克数量也需要存下，下一步如果比这一步的汇率低是需要使用的。

至于初始化，因为第一步拿在手里的是美元，自然的令第一步从“汇率比第零步高”的情况下转移过来就好了。 

可能说的有点复杂，但是蒟蒻觉得dp这种东西写起来可能没有这么复杂，想要理解是怎么来的这样的思考过程还是要有的。~~也许是蒟蒻太笨了别的大佬的题解一般是看不懂怎么想出来的。。。。。~~

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
double a[1000]={0},g[1000]={0},f[1000]={0};//g:当前马克数，f:当前美元数 
int main()
{
	int n;
	cin>>n;
	for(int i=1; i<=n; i++)
	{
		cin>>a[i];
	}
	f[0]=100;
	for(int i=1; i<=n; i++)
	{
		if(a[i]>=a[i-1])
		{
			f[i]=f[i-1];
			g[i]=f[i]/100*a[i];
		}
		else
		{
			g[i]=g[i-1];
			f[i]=g[i]/a[i]*100;
		}
	}
	printf("%.2f\n",f[n]);
	return 0;
}
```
