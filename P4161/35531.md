# 毒瘤


好吧其实是蒟蒻一开始做不出来（~~自闭一晚上和同班巨佬才讨论出来的题，但真的想了好久QAQ~~）

____


## 题目大意

**将n个数按一定排列，再置换，求所有可能不同排列的个数**


**1、首先，单理解题意，这道题似乎很难从正面下手，那我们换一个角度来思考问题，每次将数列置换，最后会变回原来的数列，这样的话，我们很容易想到一个环。那么问题中将数列的置换就变成一个环了。**
#### 2、那么，进一步讲问题转换，原题目中所要求的排列数，即为求所有可能大小环的 最小公倍数 的个数（这个可以自己举例画一下图，想一想）

#### 3、继续问题转化，原题目就变成，将n个数分成m个集合，求这些集合个数所有可能的  最小公倍数  的个数

#### 4、由于最小公倍数可以拆成若干个质因子的乘积，显然，当每个数可以用p的k次方表示是最优情况，所以最终所要求的为  （因为形如10，可以分成4和6，也可以分成，3,4,1,1,1但两者的最小公倍数是相同的，情况归为一种）
#### 5、最终问题的转化为：求和小于等于n的多个数所有可能  最小公倍数  的个数（因为有些数可以自成一个环\集合，不影响结果）
#### 6、那么问题渐渐明了，接下来设计状态，我们设f[i][j]表示前i个质数，总和为j的方案数（形如背包，p的k次方为代价）
#### 7、状态设计出来了，方程也随之而出
### 即
## f [i] [j] = Σ f [i-1] [j-pi^k] (k>=0 && j-pi^k>=0)


#### 8、最后就是时间复杂度和空间复杂度，都为O(N^2),完全符合题目的小范围qwq （其实一开始想打表的说。。。。。）


##### 附一下样例解释

##### <=10的素数都有  2,3,5,7；
#####  所以可选的数为
| 2 | 3 |5  | 7 |
| :----------- | :----------- | :----------- | :----------- |
| 4 | 9 |  |  |
| 8 |  |  |  |
##### 选0个数（不选，即为原数列） 方案数为1
##### 选1个数  方案数为7
##### 选2个数  所有方案为：（2,3）（2,5）（2,7）（4,3）（4,5）（3,5）（3,7）方案数为7
##### 选3个数  方案为（2,3,5） 方案数为1
##### 所以  1+7+7+1=16


##### 上代码（~~我知道你们只看这个qwq~~）




```cpp
#include <iostream>
#include <cstdio>
#include <iomanip>
#include <algorithm>
#include <cstring>
#include <cstdlib>
#include <cmath>
#include <queue>
#include <map>
#define ll long long
#define maxn 10000010

using namespace std;

bool prime[maxn];
int sum[maxn];
int x;
ll f[1005][10005];
int cnt;
int k;

inline void primes(int n)//素数筛求出前比n小的所有素数
{
	memset(prime,false,sizeof(prime));
    prime[1]=true;
    for(int i=2;i<=n;i++)
    {
    	if(!prime[i])
    	{
    		sum[++cnt]=i;
		}
		for(int j=1;j<=cnt&&i*sum[j]<=n;j++)
		{
			prime[sum[j]*i]=true;
			if(i%sum[j]==0) break;
		}
	}
 } 
 
int main()
{
	scanf("%d",&x);
	primes(x);
	f[0][0]=1;//初始化
	for(int i=1;i<=cnt;i++)//枚举所有小于x的素数
	{
		for(int j=0;j<=x;j++)//dp
		{
			f[i][j]+=f[i-1][j];
			k=sum[i];
			while(j>=k)
			{
				f[i][j]+=f[i-1][j-k];//转移方程
				k*=sum[i];
			}
		}
	}
		ll ans=0;//注意是longlong   不然会WA5个点
		for(int i=1;i<=x;i++)   ans+=f[cnt][i];
		printf("%lld",ans+1);//由于不选的代价为0，所以要加一，当然也可以从i=0开始循环
		return 0;
	
}
```

