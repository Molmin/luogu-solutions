（没过pj组的）蒟蒻的第一篇题解

不多说，进入正题

### DP+数论（主要是质数） 

首先（个人感觉）这就是思维难度 省选 知识点提高 代码的dp题

 观察一下题面，要求不同的可能排列数有几种，~~（一开始蒙蔽好久以为是求不同的对应排列）~~
 
然后思考一下排数有什么含义，可以发现排数实际上就是多少次变化后可以变回原来的序列~~（这不是废话吗）~~

 然后变化次数又是什么？我们考虑一组替换什么情况下会变回原来的顺序
如果a—>b，那么b一定可以经过某几次变换再变成a，那么a——>b——>...最后回到a的过程

如果我们将一个数连一条边到它对应的数字上，那么可以替换的n个数就会组成一个n元环

那么成环后排数会变成什么？，很显然一个n元环变换n次后会还原。那全部还原的变换次数显然就是每个环中点的个数的lcm（最小公倍数）。而且需要注意的是，每个点可以自己组成一个1元环

而且这个一元环对lcm不会产生任何影响，所以题目等价于<=n的数拆分后可以形成多少种不同的lcm。根据唯一分解定理我们求这些数可能拆分的lcm时，将每个数拆成k个p^r幂的积显然是最优的

因为n个数的lcm实际上就是它们的质因数中取最高次幂再相乘，全部分解质因数才能保证我们组成的lcm尽可能的多，而如果分解出合数很显然会浪费掉可能的组合数

其实这样我们就将这个问题转化成了一个背包问题，背包容量从1~n，选数，累加起来就好了

我们可以用f[i][j]表示使用前i个质数，和为j的方案数，那么转移如下：

## **f[i][j]=Σk(f[i-1][j-pi^k])**

预处理一下前n个数中的质数~~（反正n小于等于1000随便暴力）

~~简单的埃氏筛好像就足够了~~ （~~总感觉我的埃氏筛哪里有锅~~）

剩下的好像也没有什么了？下面是代码

```cpp

#include<bits/stdc++.h>
using namespace std;
bool a[2004]; 
int p[2004],cnt,logo;
long long int dp[1010]={1};
int main(){
	a[1]=a[0]=1;// 求素数 
	int n;
	cin>>n;
	if(n==1) {//直接输出掉 
		cout<<1;
		return 0;
	}
	if(n==2) {//同上 
		cout<<2; 
		return 0;
	}
	for(int i=2;i<=n;i++)//个人感觉好像有锅？ 
	  if(!a[i])
	  for(int j=2*i;j<=n*2;j+=i)
	   a[j]=1;
	for(int i=1;i<=n;i++)
	 if(!a[i]) p[++cnt]=i;//奇葩素数表 
	for(int i=1;i<=cnt;i++) //枚举使用的素数个数 
		for(int j=n;j>=p[i];j--)   //使用第i个素数 
			for(int logo=p[i];logo<=j;logo*=p[i])// logo不能大于当前差的数 
				dp[j]+=dp[j-logo];
		
		long long int f=0;
		for(int i=0;i<=n;i++)
		f+=dp[i];
        cout<<f;
	    return 0;
} 
```

```
