这道题是我点“相关题目”点出来的，~~没想到这么恶心（人工zz真™毒瘤）~~，

-----

这道题的关系有那么一些小乱，~~所以题解也会相应地有些**~~，但是，相信草稿，草稿是做题之本（手动滑稽），



设$f[i][j]$中的$i$表示：第$i$秒（在后面也会和$D[i]$中的$i$重合）;$j$表示：在第$i$秒时的疲劳值

在这个题目中，我们可以对每一秒到底是**跑步**还是**休息**进行讨论：

1. 当Bessie要休息的时候，是要一休息就**休息完剩下所有时间**的（因为：参见样例，我也是这样看懂的，~~我怎么这么毒瘤~~），所以在做的时候，**每一次**都要判断当前是否要**开始休息**直到结束，所以**把疲劳值恢复为0所需要的时间是j，加上i一定不能超过N**，然后，**恢复时走的距离是不变的**，所以，**恢复完体力后所走的距离就是恢复体力前所走的距离。**
   
   下面是相对应的dp方程：
   
   $f[i + j][0] = max(f[i + j][0], f[i - 1][j + 1])(i + j <= N)$

   p.s.1：这后面的$f[i - 1][j + 1]$为什么要$j + 1$呢？
   请仔细琢磨**恢复体力前**，也就是说（~~我胡扯的~~）：当前决定恢复体力时，体力为$j$，那么当初的体力就是$j + 1$了。
   
2.还是休息：
   
  如果到了一直休息的情况，那么如果当前的疲劳值（也就是$j$）为0的话，就可能是**上一秒在休息，这一秒也在休息**，那么：
  
  $f[i][j] = max(f[i][j], f[i - 1][0])$
  
3.~~就是我们喜闻乐见的~~跑步：
  
  第$i$秒走的距离就应该是$f[i - 1][j - 1]$（$[i - 1]$表示：**上一秒时**，$[j - 1]$表示:**疲劳值比现在少1时**（因为现在要**消耗1个点的疲劳值**）），
  
  相对应的状态转移方程是：
  
  $f[i][j]=max(f[i][j],f[i-1][j-1]+D[i])$
  
我终于讲完了所有的东西（我简直比****还毒瘤），接下来就直接上代码吧，~~累死我了qwq~~：

```
#include<bits/stdc++.h>

const int MaxN = 10000 + 100;
const int MaxM = 500 + 50;

long long N, M, D[MaxN], ans[MaxN][MaxM]; 
//这里的ans数组和上面的f是一样的
int main() {
    scanf("%d %d", &N, &M);
    for (int i = 1; i <= N; ++i) scanf("%d", &D[i]);
    
    for (int i = 1; i <= N; ++i) {
    //这里不用再加物品的循环，因为i循环既代表了时间，又代表了D数组 
        for (int j = M; j >= 0; --j) {
        //我的心情告诉我要逆序（滑稽）
            if (i + j <= N) {
                ans[i + j][0] = std::max(ans[i + j][0], ans[i - 1][j + 1]);
            }
            if (j == 0) {
                ans[i][j] = std::max(ans[i][j], ans[i - 1][0]);
            } else {
                ans[i][j] = std::max(ans[i][j], ans[i - 1][j - 1] + D[i]);
            }
        }
    }
    
    printf("%d", ans[N][0]);
    return 0;
}

```
  
  

