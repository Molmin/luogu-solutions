## DP题。

~~感觉绿题难度还是有点过了吧？~~

大致思路就是建一个二维数组dp【i】【j】表示第i分钟疲劳度为j跑的距离 

这时候就大致可以得出**动态转移方程**了，如下

------------
1.第i分钟从1至N枚举

------------
2.此时j疲劳度从1枚举至i与m中较小的一个。

------------
3.此时当第i分钟如果疲劳度想变为0，自然是选```前一秒疲劳度为0，自然这一秒疲劳度也为0的距离```或者```前j秒时跑的距离再休息j秒```中较大的一个。


------------
4.此时再次枚举j，自1枚举至m，此时dp【i】【j】则为```前1s跑的距离（此时疲劳度也少1）再加上跑这1s的距离```

------------


故状态转移方程代码如下：

```
 for(int i=1;i<=n;i++){
        for(int j=1;j<=min(i,m);j++) 
		dp[i][0]=max(dp[i][0],max(dp[i-1][0],dp[i-j][j]));
        for(int j=1;j<=m;j++) dp[i][j]=max(dp[i][j],dp[i-1][j-1]+a[i]);
    } 
```

最后输出dp【n】【0】则为正解。

------------


发现了吗？实际上代码很精简的。只要你有心，提高难度在你眼里都将是水题！


```
#include<bits/stdc++.h>
using namespace std;
int n,m,a[10002],ans,dp[10002][502];//dp[i][j]表示第i分钟疲劳度为j跑的距离 
int main(){
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++)scanf("%d",&a[i]);
    for(int i=1;i<=n;i++)
	{
        for(int j=1;j<=min(i,m);j++) 
		dp[i][0]=max(dp[i][0],max(dp[i-1][0],dp[i-j][j]));
        for(int j=1;j<=m;j++) dp[i][j]=max(dp[i][j],dp[i-1][j-1]+a[i]);
    } 
    cout<<dp[n][0];
}
```

>PPS：这是@M_sea dalao給我们讲解的，深入浅出Orz

>PPPS：应该没有题解与这个相似吧？因为我们全机房都是听的M_sea dalao讲解的，所以可能机房会有与我相似的题解投上来QAQ