由于本人过于蒟蒻,dp是不可能dp的,于是这里用了记忆化搜索

#### 记忆化搜索主要就是边界条件要处理好,不然自己都不知道怎么错的 ~~(血与泪的教训)~~

- 用jy[x][y]表示在第x分钟后与疲劳值为y时能跑的最大距离

- 其中jy[n][0]=0,jy[n][1]=0,jy[n+1][0]=0(因为当第n分钟时只能选择休息, 第n+1分钟表示已经跑完, 疲劳值必须为0, 都不会增加跑的距离)

- jy[n][2~m+1]与jy[n+1][1~m+1]都等于-100000000(表示不可以)



------------

#### 然后就是处理跑和休息了:

- 跑就搜索下一分钟,疲劳加一的情况的返回值再加上跑的距离(假设得到值为a)

- 休息的话就休息y(表示疲劳值)分钟,如果y==0就休息一分钟(用x+max(y,1)),也就是搜索分钟+max(1,y)疲劳值为零的情况的返回值(假设得到值为b)

- 在a,b中选较大值作为自己的返回值

搜到边界条件时,层层返回自己的值最后到search(1,0)再赋值给答案,输出



------------

### 完整代码:

```
#include<bits/stdc++.h>
#define search sea//因为有一个STL中的函数是search,所以下面打的是search实际上是sea(看得舒服)
using namespace std;
const int inf=100000000;
long long jy[10001][501],d[1010001],n,m,ans;//d[i]表示第i分钟跑的距离,ans为答案
long long search(int x,int y)//表示在第x分钟后与疲劳值为y时能跑的最大距离
{
	if(jy[x][y]==-1)//表示还未搜过
	{
		long long b=-inf;//inf=100000000,因为如果下面两个条件(if语句)都不满足那么jy[x][y]就为-100000000表示不可以
		if(x+max(1,y)<=n+1)  b=max(b,search(x+max(1,y),0));//休息,题目说一定要休息到0且当疲劳值为0时也可以休息所以用max(1,y);
		if(y+1<=m&&x+1<=n+1) b=max(b,search(x+1,y+1)+d[x]);//跑,x+1和上面的x+max(1,y)要小于n+1是因为可以直接跑到或休息到结束
		jy[x][y]=b;//b为休息和跑之中的较大值
	}
	return jy[x][y];//返回这个值
}
int main()
{
	cin>>n>>m;//输入总时间与最大疲劳值
	memset(jy,-1,sizeof(jy));//初始化
	jy[n][1]=0;//初始化
	jy[n+1][0]=0;//初始化
	jy[n][0]=0;//初始化
	for(int p=1;p<=2*m;p++) jy[n][p+1]=-inf,jy[n+1][p]=-inf;//初始化
	for(int p=1;p<=n;p++) cin>>d[p];//输入跑的距离
	ans=search(1,0);//从第一分钟,0疲劳开始
	cout<<ans;//输出
	return 0;
}
```

