

~~趁着题改了赶紧水一发题解（与此同时还在和对面的同学抢时间）~~

看到这道题有2个思路：全排序和BFS（保证最优）

但是谁会作死去写全排序~~骗分~~2333

那么就用一维BFS，每一次都刷新6个做法

每一个做法保存当前状态

这样的话结构体的构造就出来了

```cpp
struct sb//别问我这个是什么意思
{
    int a,b;//两个桶中的水量
    int f;//步骤数
    string s="";//竟然用字符串存具体做法！（其实是懒得开动态数组），但是记得要赋空串
};
```
主函数好理解吧

```cpp
int main()
{
    scanf("%d",&t);
    for(i=1;i<=t;i++)
    {
        scanf("%d %d %d",&a,&b,&u);//打scanf的养成好习惯
        bfs();
    }
return 0;
}
```
开始暴力地打模板
```cpp
void bfs()
{
    queue<sb>q;//建队
    sb x;//把初始的状态入队
    x.a=0;
    x.b=0;
    x.f=0;
    q.push(x);
    while(q.size()!=0)
    {
        sb t=q.front();
        q.pop();
        for(int o=1;o<=6;o++)//六个做法（可能有点繁琐）
        {
            sb k=t;
            k.f++;
            if(o==1)//下面的都好理解，模拟倒水
            {
                k.a=a;
                k.s=k.s+"1";
            }
            if(o==2)
            {
                k.b=b;
                k.s=k.s+"2";
            }
            if(o==3)
            {
                k.a=0;
                k.s=k.s+"3";
            }
            if(o==4)
            {
                k.b=0;
                k.s=k.s+"4";
            }
            if(o==5)
            {
                if(k.b+k.a>a)
                {
                    k.b=k.b-(a-k.a);
                    k.a=a;
                }
                else 
                {
                    k.a=k.b+k.a;
                    k.b=0;
                }
                k.s=k.s+"5";
            }
            if(o==6)
            {
                if(k.b+k.a>b)
                {
                    k.a=k.a-(b-k.b);
                    k.b=b;
                }
                else 
                {
                    k.b=k.a+k.b;
                    k.a=0;
                }
                k.s=k.s+"6";
            }
			if(k.b==u)//完成了倒水就退出该函数
            {
                print(k);
                return;
            }
        }
    }
}
```
还有print函数养成好习惯
```cpp
void print(sb p)
{
    printf("%d ",p.f);
    for(int i=0;i<p.s.size();i++)printf("%c ",p.s[i]);//为了节省内存，在输出的时候再来加空格
    printf("\n");
}
```
但是大家可能会想这道题怎么莫名地简单了起来，那我再来分析一下

比如这个数据：3,5,4

把A倒空的方法其实有很多：

①一次倒空；

②把B倒空，再把A倒给B

③倒空A，加满A，倒空A，加满A，倒空A，加满A，倒空A，加满A，倒空A，加满A，倒空A，加满A，倒空A，加满A，倒空A，加满A，倒空A，加满A，倒空A......~~调皮了~~

在我们的BFS中，因为每次都会有6个状态入队，所以说重复的做法有非常多

于是我想到了一种类似桶排，数字控制的下标的标记法

核心代码如下

```cpp
if(f[k.a][k.b]>k.f)
/*
f的两个下标是A桶的水量和B桶的水量，存的是达到这个状态需
要的最小步骤，如果有一个方法比这个优，那么就刷新并入队。
这句要加在BFS函数的内循环的判结束的前面，还要记得赋极大
*/
{
	f[k.a][k.b]=k.f;
	q.push(k);
}
```
涉及到题解的长度问题，全部的代码我就不加了2333。

祝Noip2018 RP++