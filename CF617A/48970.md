## 题意简述
数轴起点坐标为0，终点坐标为x，可以向前移动1/2/3/4/5个单位长度，问最少几步可以从起点到终点。
## 题目描述
一只大象决定去拜访他的朋友。结果，大象的房子位于0点0，他的朋友的房子位于点X。每一步大象可以向前移动1、2、3、4或5个位置。问：他最少走多少步才能到达他的朋友的房子。
## 输入输出格式
### 输入格式：
输入共一行，只有一个整数x（ $1<=x<=1000000$）表示朋友家的坐标。
### 输出格式：
输出共一行，只有一个整数，表示大象到达他的朋友的房子的最少步数。
## 样例说明
在第一个样例中，大象需要走一步长度为5，以到达X点。
在第二个样例中，如果大象移动3，5和4步，可以到达X点。还有其他方法三步到达，但大象不能以少于三步的方法到达X点。
## 思路提示
这个题真的是一个大水题，一眼看出是裸的递推（或者说$DP$吧）……  
但是绝不能把它当成斐波那契数列那种，要看清题目，这可不是让你求方法数诶，题目让你求最小步数。  
这也很好办，我们定义一个$f$数组，用$f[i]$表示第i个位置最少需要几步到达，那么，边界状态为$f[1] = f[2] = f[3] = f[4] = f[5] = 1$，状态转移方程为$f[i] = min(f[i-1],f[i-2],f[i-3],f[i-4],f[i-5]) + 1$;  
一个小小的细节：这里的$min$函数推荐自己写，因为需要比较的数比较多，用库函数的话会比较长的一行……（而且老慢了，虽然不会被卡）  
王宇嘉最棒了（逃）  
下面上代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int f[1000001];
int wyj(int u)
{
    int ans = f[u-1];
    if(f[u-2] < ans || ans == 0)	ans = f[u-2];
    if(f[u-3] < ans || ans == 0)	ans = f[u-3];
    if(f[u-4] < ans || ans == 0)	ans = f[u-4];
    if(f[u-5] < ans || ans == 0)	ans = f[u-5];
    return ans;
}
int main()
{
    int n;
    scanf("%d",&n);
    f[1] = f[2] = f[3] = f[4] = f[5] = 1;
    for(int i = 6; i <= n; i++)	f[i] = wyj(i) + 1;
    printf("%d\n",f[n]);
    return 0;
}
```
最后一句忠告，CF的题请不要抄题解，不然后果自负~~~