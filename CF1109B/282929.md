## 结论

简单观察后，直接~~扔~~猜出一个结论：答案只有 `Impossible`，$1$ 或者 $2$。

## 证明

于是我们尝试证明这个结论。设字符串长度为 $l$，并令 $t=\lceil\frac l 2\rceil$。

直接证比较难，但是我们可以发现判定 `Impossible` 是比较简单的，大致有两种情况。

1. 全部都是同一个字母，比较显然。
2. $l$ 为奇数，并且除了 $s_{t}$ 之外，其余字母都相同。这样的话这个字母一定放在中间，所以无论怎么换，一共就一种可能的回文串，即原串。

于是，我们在判断完 `Impossible` 之后，发现剩下的 $s$ 都是有解的，于是我们发现 $s$ 一定满足一个性质：总是存在至少两个 $i\ (1\leqslant i<t)$ 满足 $s_i\neq s_{i+1}$。并且容易发现 $l\geqslant 4$。

为什么满足此性质？因为如果不满足此性质的字符串都是 `Impossible` 的。

现在我们来证明需要的切分次数不多于 $2$：

根据上面的性质，我们可以找到第二个 $j$ 使 $1\leqslant j<t$，我们将 $s$ 划分成 $1\sim j+1,\ j+1\sim l-j-1,\ l-j\sim l$ 三段。

由于 $s$ 为回文串，并且第一段与第三段长度相等的。在第一段中，除了最后一个字符之外，其余均相等；在第三段中，除了第一个字符外，其余均相等。又 $s_1=s_l,s_{j+1}=s_{l-j}$，所以第一段和第三段不相等。因此交换后，新串与原串不相等。

交换第一段和第三段之后，由于原串的回文性质，第二段是回文串，第一段和第三段正好是互相翻转的结果，所以新串也是回文串。

于是，只要按此方法交换，切分次数一定不多于 $2$，证毕。

## 思路

先判断 `Impossible`，很简单，从 $1$ 扫到 $t$ 即可。

其次，已经证明答案是 $1$ 或 $2$。由于需要最小值，不难发现更重要的是判断 $1$ 可不可行。

实际上这是很简单的，我们枚举在哪里切分即可，对于每次切分，直接暴力交换与判断回文，观察到 $l\leqslant 5000$，这样做是 $l^2$ 的，可以通过。

如果枚举完之后没有可行的，说明 $1$ 次切分不能满足，输出 $2$ 即可。

## 代码

```C++
#include <string>
#include <iostream>
#include <algorithm>
using namespace std;
string s; bool d;
int main()
{
    cin >> s; const int l(s.size()); s = ' ' + s; // 下标从 1 开始，方便处理
    for (int i(2); i <= l >> 1; ++i) if (s[i] != s[1]) { d = true; break; }
    if (!d) { puts("Impossible"); return 0; } // 不可行
    for (int i(1); i <= l >> 1; ++i) {
        const string t(s.substr(i + 1) + s.substr(1, i));        // 交换
        string r(t); reverse(r.begin(), r.end());                // 翻转
        if (s.substr(1) != t && r == t) { puts("1"); return 0; } // 判断
    } puts("2"); return 0;
}
```