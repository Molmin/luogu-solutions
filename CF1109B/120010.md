看到大家都是采用分奇偶分类讨论的方法，那我就来一篇不一样的题解吧。

答案只有三种情况，Impossible，$1$ 或者 $2$。

先考虑 Impossible 的情况：如果该回文串内全是同一个字母（如果字符串长度为奇数不包括最中间的字符），那么必定无解。因为你所有字符相同（若长度为奇数，中心的字符显然不能移动）无论如何都找不出与原串不同的方案。

由于给定的是回文串，除去 Impossible 的情况，那么左右两端肯定会存在两种不同的字母，我们一定可以由外向内的前缀（或后缀）中找到一个由两段不同字母组成的串，交换位置之后产生的串必然与原串不同。所以答案不会超过 $2$。

我们最后考虑只分成两段的情况。我们可以暴力枚举断点，将两段字符串颠倒位置后重新拼接。然后再继续判断该新串是否回文，我们可以将该串倒置，与原新串进行比较，如果相同那么回文，反之则不然。以上这些部分都可以用 **Hash** 解决，时间复杂度为 $O(n)$。

但是如果我们因转来转去麻烦而不想写 **Hash** 该怎么办？

可以观察到字符串的长度不超过 $5000$，显然 $O(n^2)$ 的算法是可以接受的。那么我们就可以使用 **STL** 中的 **string** 以及它的库函数 **substr** 来解决问题（懒人专属且 **string** 的内部重定义运算常数大，都需产生新串来运算，运算复杂度为 $O(|s|)$ 的，数据量一大就 **GG** 了，所以不推荐，所以还是建议写 **Hash**）。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,res;
string s,S,T;
int main(){
	std::ios::sync_with_stdio(0);cin.tie(0);
	cin>>s;n=s.size();
	for(int i=0;i<n>>1;i++)res+=(s[i]!=s[0]);
	if(!res)return puts("Impossible"),0;//判断无解
	for(int i=1;i<=n>>1;i++){
		T=s.substr(i,n)+s.substr(0,i);//获得新串
		S=T;reverse(S.begin(),S.end());//翻转新串
		if(S==T&&S!=s)return puts("1"),0;//判断是否回文，且是否与原串一致
	}
	puts("2");
	return 0;
}
```




