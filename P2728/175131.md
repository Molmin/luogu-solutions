模拟。其实没什么好说的，读入处理可以有很多种方法，最后枚举时间，一层一层枚举缺口，最后就能AC掉。

### 我在这里想和大家探讨一下关于这种圆轮题怎么处理：
先上代码再解释：
```cpp
#include<cstdio>
#include<cstring> 
using namespace std;
int speed[6];
int s[6];
int p[6][6],width[6][6];
int v[361]; 
int main() 
{
    for(int i=1;i<=5;i++)
    {
        scanf("%d%d",&speed[i],&s[i]);
        for(int j=1;j<=s[i];j++)
            scanf("%d%d",&p[i][j],&width[i][j]);
    }
    for(int t=0;t<=360;t++)
    {
        memset(v,0,sizeof(v));
        for(int i=1;i<=5;i++)
            for(int j=1;j<=s[i];j++)
            {
                for(int k=p[i][j];k<=p[i][j]+width[i][j];k++)
                    v[k%360]++; 
                p[i][j]=(p[i][j]+speed[i])%360; 
            }
        for(int i=0;i<=359;i++)
            if (v[i]==5)
            {
                printf("%d",t); 
                return 0;
            } 
    }  
    printf("none");
    return 0; 
}
```
在这里我采用了~~合理的~~压行。

所谓**圆轮题**是我给起的名，大体就是那种收尾相连的串，如果用数组的话会越界，再就会WA，因为根据题意，1的前面是n，n的后面是1，如果用数组模拟的话，我的想法是开三倍的数组，然后把串复制三份扔进去，再...

#### 哇，麻烦死了。

### 所以我们想到了另外一种做法。

我们的数组不用开三倍，开一倍的即可，当我们需要找数组下标时怎么办呢?

很简单，把枚举到的数（可能会超出n的范围），对n取模即可。

很好理解吧！然后就可以进行后续的操作。

针对本题，不仅在v[k%360]的时候用到了这个思想，在它的下一行——p[i][j]=(p[i][j]+width[i][j])%360的时候也同样用到了这样的原理。

希望同学们多多体会。

### 也希望管理大大给过！！

最后祝大家生活愉快！！——FSW