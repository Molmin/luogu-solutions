咋一看，好简单啊，然后WA了两次过后开始深思（捂脸）

理清了思路后我们不难发现：

- **如果n是奇数，就一个一个加1就可以满足**，因为奇数个连续的数的平均数一定在其中一个数。（如1 2 3 4 5 的平均数是3）

- **如果是偶数，我们也采用类似的方法一个一个加1，但到了最后一个列或最后一行时就要改一下**，因为偶数个连续的数的平均数是中间两个数的平均数（如1 2 3 4 的平均数是2.5）最后一个数就要强行让这一列数满足关系，我们把最后一个数改成6，（1 2 3 6的平均数是3），**即要再加上0.5×4=2（0.5是2.5比3少的部分，4是n）**，之后的每一行的数都加上一个数使他们无法重复，最小就可以加上a[1][n]，**对于最后一行的数我们也用类似方法算得要再加3×n×n÷4**，当然2是不满足的，我们特判一下即可。

```cpp
#include <bits/stdc++.h>
using namespace std;
int a[105][105];
int main()
{
    int n;
    cin >> n;
    if(n==2)
    {
        cout << "-1" << endl ;
        return 0;
    }
    else if(n%2)
    {
        int now=1;
        for(int i=1;i<=n;i++)
        {
            for(int j=1;j<=n;j++)
            {
                a[i][j]=now++;
            }
        }
    }
    else
    {
        int now=1;
        for(int j=1;j<n;j++)
            a[1][j]=now++;
        a[1][n]=3*n/2;
        int c=a[1][n];
        for(int i=2;i<n;i++)
            for(int j=1;j<=n;j++)
                a[i][j]=a[i-1][j]+c;
        for(int j=1;j<=n;j++)
            a[n][j]=a[n-1][j]+c+3*n*n/4;
    }
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=n;j++)
        {
            if(j==1)
                cout << a[i][j];
            else
                cout << " " << a[i][j];
        }
        cout << endl ;
    }
    return 0;
}

```
