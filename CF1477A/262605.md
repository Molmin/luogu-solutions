

整理的算法模板合集： [***ACM模板***](https://fanfansann.blog.csdn.net/article/details/105493218)

[可能会是更好的阅读体验（](https://fanfansann.blog.csdn.net/article/details/113655626)



## D - Nezzar and Board
 **Problem A Nezzar and Board**



我们在黑板上写了 $n$ 个数，$x_1,x_2,\cdots,x_n$。

我们可以无限此地使用一个操作：从黑板上的数字中选择两个数 $x$ 和 $y$ （$x$ 和 $y$ 可以是同一个数）将 $2x-y$ 写到黑板上去（$x$ 和 $y$ 还在）。求整数 $K$ 能否被写到黑板上去。

$1\le T\le10^5,1\le k,x_i\le10^{18}$.

**Solution**

**我这里不需要猜结论或者证明结论**，我的解法只需要**一步步按部就班地往后推就行了**。

首先我们知道每次可以选择两个数 $x$ 和 $y$ 得到 $2x-y$。

这个 $2x-y$ 看上去毫无头绪，因为一个乘以二，一个是本身，两个好像和 $x$ 与 $y$ 毫无关系。我们可以把它们拆开,得到 $x+(x-y)$。

逐渐好起来了，看上去有些头绪了，因为这里实际上表示的是从一个数 $x$ 开始，加上这个数与另一个数的差值，然后得到了一个新数。

我们可以模拟一下：

我们假设：

$x_i=x_j+(x_j-x_k)$

$x_a=x_i+(x_i-x_c)$

$x_b=x_a+(x_a-x_d)$

那么 $x_b$ 就可以表示为：

$x_b=x_j+(x_j-x_k)+(x_i-x_c)+(x_a-x_d)$

我们可以从特殊到一般，得到所有能写到黑板上的数的表达式（为了理解方便，看起来舒服，我们就设能写到黑板上的数为我们题目中想要我们来判断的 $K$）：

那么我们得到了一个表达式：

$x_i+\sum_{j,k}(x_j-x_k)=K$

其中 $j,k$ 可以是我们得到 $K$ 的途中使用的任意一个数的下标，甚至 $x_i$ 可以替换为任意一个 $x$ ，这一点我们下面再详细说明。

特别的，由于题目中特别说明了可以每次选的两个数 $x$ 和 $y$ 可以是同一个数（" **not necessarily distinct** "）所以我们这个表达式不仅可以表示新写到黑板上的数，还可以表示原来就在黑板上的数：$x=x+(x-x)$。

这样我们得到的这个表达式就可以表示所有的黑板上的数字了。

我们可以把左边的 $x_i$ 移到右边，这样两边的形式看上去统一一些，并且也不会影响答案的正确性。

即：

$$\sum_{j,k}(x_j-x_k)=K-x_i$$

其中， $x_i$ 可以换为 $x_1$ ，因为不管 $x_i$ 是谁，我们都可以移动到左边，变成正数 $x_i$，而黑板上的任意一个数都可以由 $x_1$ 通过两次操作得到，例如我们想由 $x_1$ 得到 $x_n$ :

**第一次操作：** 选择 $x_1$ 和 $x_n$ ，得到新数：$x_1+(x_1-x_n)$，写到黑板上。

**第二次操作：** 选择 $x_1$ 和 $x_1+(x_1-x_n)$ ，得到：$x_1+\{x_1-[x_1+(x_1-x_n)]\}=x_1+x_1 -x_1-x_1+x_n=x_n$

（实际上就是第一次是减去它们两个之间的差，那么我们减去这个差不就是加上这个差，也就得到了另一个数。）

同理我们也可以把式子里所有的 $x_k$ 换成 $x_1$。

为什么要换成 $x_1$ 呢，很显然如果还是当作 $x_i$，$x_k$ 来用的话，我们并不知道 $x_i$，$x_k$ 到底是谁 ~

而我们归为一类以后，只有一个变量 $j$ ，我们只需要一次 `for` 循环即可。

最终得：

$$\sum_{j}(x_j-x_1)=K-x_1$$


我们可以设 $a_i$ 表示 $x_i-x_1$，$y_i$ 表示方程的未知数

这样就可以把上述方程转化为一个好看的丢番图方程（线性方程）：

$$a_1y_1+a_2y_2+a_3y_3+\cdots+a_ny_n=K-x_1$$

实际意义就是我们选 $y_1$ 个$a_1$（$a_1=x_1-x_1$），$y_2$ 个 $a_2$（$a_2=x_2-x_1$），$\cdots$，凑成 $K-x_1$。（$y_i$ 可以为 $0$ 嘛）

我们只需要判断这个丢番图方程有解即可。若该方程有解，则说明最开始的式子 $x_i+\sum_{j,k}(x_j-x_k)=K$ 有解（我们全程所有的式子的含义都没有变化，只是形式上的改变），说明 $K$ 可以被通过题中所给的操作凑出来，也就是可以写到黑板上，也就是输出 `YES`。

判断丢番图方程有解，很容易想到裴蜀定理：

**设 $a,b$ 是不全为零的整数，则存在整数$x,y$，使得$ax+by =  \gcd(a,b)$。** 若$m$ 是 $\gcd(x,y)$ 的倍数，方程同样有解（很显然，因为我们只需要两边同时乘上倍数即可。） 

那么对于多个变量同样适用：

即：若 $K-x_1$ 是 $\gcd(x_1-x_1=0,x_2-x_1,x_3-x_1,\cdots,x_n-x1)$  的倍数，则该丢番图方程有解，即 $K$ 一定能够被凑出来写到黑板上，输出 `YES` 。


**Code**

非常简单的代码：
```cpp
#include <cstdio>
#include <iostream>
#include <cstring>
#include <algorithm>
#include <map>
#include <vector>
#include <unordered_map>

using namespace std;
typedef long long ll;
typedef int itn;
const int N = 5e5 + 7, mod = 1e9 + 7;
const ll INF = 1e18 + 7;

ll x[N], n, m, t, k;

int main()
{ds
    scanf("%lld", &t);
    while(t -- ) {
        scanf("%lld%lld", &n, &k);
        for(int i = 1; i <= n; ++ i)
            scanf("%lld", &x[i]);
        ll gcd = 0;
        for(int i = 1; i <= n; ++ i)
            gcd = __gcd(x[i] - x[1], gcd);
        if((k - x[1]) % gcd == 0)
            puts("YES");
        else puts("NO");
    }
    return 0;
}

```

看懂了叭 ~ 超级清晰有没有 (●ˇ∀ˇ●) 我真棒（

点个赞呗![/kel](https://cdn.luogu.com.cn/upload/pic/62226.png)
