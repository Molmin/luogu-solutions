## 题目大意
有一数字个数为 $n$ 的数列，且每个数个不相同。

两个玩家轮流操作，每次操作将某一数变为 $0$，当操作后,如果所有数的异或和为 $0$，则该玩家获胜。

若先手有必胜策略，输出 `Win` ，否则输出 `Lose` 。

## 题目分析

首先我们知道：
$$\begin{matrix}\underbrace{0\oplus0\oplus0\oplus\cdots\oplus0\oplus0\oplus0}\\n\end{matrix}=0$$
这说明我们只要把每一个数都变为 $0$ 所有数的异或和就能变为 $0$。每个人操作 $1$ 那么 $n$ 个数就要操作 $n$ 次，而如果当 $n$ 为奇数，最后一个数就一定是先手操作的，同时先手也就是赢家（代码如下）。
```cpp
if(n%2==1)
	cout<<"Win";
```
但是当 $n$ 为偶数，就一定没有必胜策略吗？

怎么可能！样例 $3$ 说明 $n$ 为偶数时也是可能有必胜策略的：

分析一下，如果 $n$ 为偶数，那么当先手操作 $1$ 次后，剩下就是 $n-1$ 个数，个数是奇数，而此时的后手也会变成先手，根据以上的结论，此时后手必胜。

所以此时先手赢的机会只有在第一次操作时候，也就是如果只操作一次就能使所有数的异或和为 $0$，换句话就是如果除了某个数以外其他数的异或和为 $0$，先手就能赢。

而我们知道异或的逆运算还是异或，那只要先求出所有数的异或和，再一一枚举每个数，用总的异或和异或一下枚举的数，那么当前枚举的这个数就能被抵消，而剩下的就是除它外其他数的异或和了，接着我们再根据以上结论判断即可。

## 代码如下

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[400005],x;
bool flag;
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>a[i];
		x^=a[i];//求出所有数的异或和
	}
	if(n%2==1)//n为奇数先手就肯定有必胜策略
		cout<<"Win";
	else
	{
		flag=false;
		for(int i=1;i<=n;i++)//一一枚举每个数
			if((x^a[i])==0)
				flag=true;
		if(flag)
			cout<<"Win";
		else
			cout<<"Lose";
	}
	return 0;
}

```
