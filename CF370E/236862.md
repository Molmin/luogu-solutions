官方题解是 dp，但是这题看着就很可以贪心。

本题题面有次数的限制 $L=2,R=5$，本做法可以扩展到 $L,R$ 任意的情况。

我想最大化 $a_n$，一个直观的想法就是每个数我尽量出现 $2$ 次就去下一个。

于是考虑维护两个二元组 $up_i$ 和 $low_i$，$up_i=(upval,upcnt)$ 表示在尽量出现次数少的情况下 $upval$ 位置值的上限 $upcnt$，与此时 $x$ 已经连续出现了 $y$ 次。$low_i$ 表示在尽量出现次数多情况下的。

那么遇到一个 $a_i>0$ 时，我们就根据其与 $a_i$ 的大小关系调整 $up$ 与 $low$：

+ $upval_i<a_i$ 或 $lowval_i>a_i$，显然无解。

+ $upval_i>a_i$，则我们需要将 $upval_i$ 修改为 $a_i$，并将 $upcnt_i$ 修改为极大值 $2$（因为必然可以调整到 $a_i$ 出现了两次的情况）

+ $lowval_i<a_i$，则我们需要将 $lowval_i$ 修改为 $a_i$，并将 $lowcnt_i$ 修改为极小值 $1$（同理）

然后最后只需要从后向前贪心的取答案即可。当然也要再利用 $low$ 判一下无解。

这里我们在调整时不需要去调整 $i$ 之前的 $up$ 和 $low$ 的值，因为我们在求答案时，如果当前 $upval_i$ 值比 $a_{i+1}$ 大，说明后面的数限制了 $i$ 的取值，我们可以直接根据 $a_{i+1}$ 目前的出现次数继续构造 $a_i=a_{i+1}$ 或 $a_i=a_{i+1}-1$。

具体实现也可以参考一下代码。时间复杂度 $O(n)$。

[code](https://codeforces.com/contest/370/submission/212230863)