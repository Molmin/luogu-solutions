**题意**  

先手把 $1,2,3,\cdots 2n$ 分成 $n$ 个二元组，后手在每个 $2$ 元组里选择一个数，使得它们的和是 $2n$ 的倍数。如果可以做到后手赢，否则先手赢。  

你可以选择是先手还是后手，请你赢得胜利。  

**题解**  

第一次在看懂题意 2 分钟内秒了一道 \*2800 的题，写篇题解纪念一下。  
其实感觉难度没有 \*2800。  

顺便吐槽一下，这个输入怎么分组的方式为什么放在那么隐蔽的位置啊。  

考虑一个简单的想法，他要求是 $2n$ 的倍数，假如我是先手，我可以想办法让后手对 $2n$ 取模的变化尽可能少。  

于是想到将 $i,i+n$ 分为一组，这样后手每次更改组内选择哪个，都只会改变 $n$ 的倍数。  
这样的话，后手得到的和只能是 $\frac {n(n+1)} 2 +kn = n(\frac {n+1} 2 +k)$  

显然当 $n+1$ 是奇数，即 $n$ 为偶数的时候先手这么构造就能胜利。  

然后考虑 $n$ 是奇数的情况，猜一波后手必胜。  
我们考虑，假如能够选择这样 $n$ 个数，使得他们对 $n$ 取模后是 $0,1,2,\cdots n-1$。那么和一定是 $ n \cdot(k+\frac {n-1} 2)$。  
如果 $k+ \frac {n-1} 2$ 为奇数，我们就选择正好相反的那一组数，和变为 $n \cdot (2n+1-k- \frac {n-1} 2)$。    
考虑 $(k+\frac {n-1} 2)$ 和 $ (2n+1-k- \frac {n-1} 2)$ 奇偶性相反，这样一定可以。  

然后看上去就是能够选择出这样一组数的，我们来证明一下。  

首先，对于一组数 $(i,j)$ 进行连边。  
然后，对 $(i,i+n)$ 进行连边。  

这样每个数只会连出去 $2$ 条边（算上重边）。因此整张图一定由若干个环组成。且每个环上，$i$ 和 $i+k$ 是相邻的。  
对于每个环，我们隔一个取一个就一定能取出满足条件的 $n$ 个数。  

这样就做完了。  

**代码**  

吐槽一下，我把 `cin` 打成快读调了一年。（汗）
```cpp
int n,S;
int o[N],G[N];
bool v[N],t[N];
void dfs(int x){if (v[x]) return;S+=x,t[x]=v[x]=1;int y=x+n;if (y>2*n) y-=2*n;v[y]=1,dfs(G[y]);}
signed main()
{
	cin>>n;
    if (n%2==0) {cout<<"First"<<endl;for (int j=1;j<=2;j++) for (int i=1;i<=n;i++) cout<<i<<" ";cout<<endl;} else 
    {
        cout<<"Second"<<endl;
        for (int i=1,p;i<=n*2;i++) {cin>>p;if (o[p]) G[i]=o[p],G[o[p]]=i;else o[p]=i;}
        for (int i=1;i<=n*2;i++) if(!v[i]) dfs(i);
        for (int i=1;i<=n*2;i++) if (t[i]!=(S&1)) cout<<i<<" ";cout<<endl;
    }
}
```