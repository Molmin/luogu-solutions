这一题考察对异或性质的运用。让我们先来分类讨论一下:


------------

1. $n$ 为奇数的情况。

举个例子:

```cpp
2
3 1
1 3 2
3 2
1 3 2
```

我们发现，这两组数据的答案是一样的。

这是因为我们在进行第二次操作时，每个数会变成剩余偶数个数的异或和，而剩余的每个数加起来包含了偶数个原数组下操作数对应下标的数和奇数个其他下标下的数。而偶数个相同的数的异或和为 $0$，因此结果为原数组下其他下标上的数的异或和，也就是操作数。

还是按上面样例解释一下:

```cpp
1 3 2 //原数组
1 3 2 //第一次操作后
3^2 1^2 1^3 //第二次操作过程
1^2^1^3 3^2^1^3 3^2^1^2 //分解
2^3 1^2 1^3 //就是第一次操作的过程
```

相信大家应该懂了吧，当 $n$ 为奇数时，输出原数组异或积一次后的数组。

------------
2. $n$ 为偶数的情况。

还是来举个例子:

```cpp
4
4 1
1 2 3 4
4 2
1 2 3 4
4 3
1 2 3 4
4 4
1 2 3 4
```

我们发现，所有 $k$ 为奇数下的答案是相同的，所有 $k$ 为偶数的答案也是相同的。

按照 $n$ 为奇数时的推导过程，可以推出操作数变为了偶数个原数组的其他下标上的数的异或和与奇数个原数组对应下标上的数的异或和相异或的结果。而偶数个相同的数的异或和为 $0$，因此结果就是原数组上对应下标上的数。

仍然是解释一下样例:

```cpp
1 2 3 4 //原数组
5 6 7 0 //第一次操作后的结果
6^7^0 5^7^0 5^6^0 5^6^7 //第二次操作过程
1^3^4^1^2^4^1^2^3
2^3^4^1^2^4^1^2^3
2^3^4^1^3^4^1^2^3
2^3^4^1^3^4^1^2^4
//分解后的四个数
1 2 3 4 //化简后得到了原数组
```

------------
综上，我们得到了结论:

- 当 $n,k$ 中有一个为奇数时，输出原数组异或积一次后的数组。

- 否则输出原数组。

------------
那么问题来了，如何快速得到异或积一次后的数组？

其实很简单，只需要先计算原数组的异或和。因为异或积后每个数变为原数组其他下标上的数的异或和，并且两个相同的数异或后会变成 $0$，因此异或积后每个数变为原数组的异或和与原数组对应下标上的数异或后的结果。

这样，我们就能愉快地 AC 本题了！

代码如下:

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,k,t;
unsigned int a[100001],sum=0;
int main(){
    cin>>t;
    while(t--){
        cin>>n>>k;
        sum=0;//初始赋值为0
        for(int i=1;i<=n;i++){
            cin>>a[i];
            sum^=a[i];
        }
        if(n%2||k%2){
            for(int i=1;i<=n;i++){
                cout<<(sum^a[i])<<' ';
            }
        }
        else{
            for(int i=1;i<=n;i++){
                cout<<a[i]<<' ';
            }
        }
        cout<<endl;//记得换行
    }
    return 0;
}
```

The end~