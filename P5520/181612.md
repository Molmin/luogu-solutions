## 组合数学（雾）

说起来你可能不信，这是一道数学题（废话）

它可以建模为：n个盒子放m个球，每个盒子最多放一个球，且相邻的两个盒子不能同时有球。

我们的第一思路肯定是这样：考虑前n个盒子放m个球的方法数$f(n, m)$。根据题意可得，$f(n, m)=Σdp(i,m-1)$，其中$2m-3≤i≤n-2$，自己想想为什么是这个范围，不会就画图。

但是，咳咳，题目范围是多少？一百万、两百万！完蛋了吧。

并没有，都说了这是个数学题，这只是说明我们用递推的方法行不通。

但我们这个模型依然是正确的，只是思考的方法可以不同。考虑两个球中间相隔的空盒子数，有m个球，中间就有m-1个空隙，每个空隙有至少1个空盒子。

但这样依然不够美，因为我们并未考虑两端的空盒子，导致这些空盒子的个数限制并不统一。

题目并未规定两端必须有空盒子，但我们可以人为制造。现在有n个盒子，我们可以给两端分别加一个空盒子，并且规定这两个盒子必须为空。这样就有n+2个盒子，但这m个球必须放在中间的n个盒子内。m个球的中间、加上两端，就有m+1个空隙，每个空隙至少有1个空盒子。比如下面$f(6,3)$的情况：

0 | 1 0 1 0 0 1 | 0

那么，这些空盒子的总个数是多少呢？当然是n+2-m咯。

所以，问题转化为：求不定方程$Σ_{i=1}^{m+1}x_i=n-m+2\ \ \ (x_i≥1)$的整数解个数。

这个问题在组合数学中是个模板了，公式为$C_{n-m+1}^m$。不会的可以百度“不定方程整数解个数”。

这就完了吗？注意了啊，我们还有题目中的一个条件没用到呢，当排列顺序不同的时候，算作不同的方案。所以，最终答案应该乘上m的全排列：

$C_{n-m+1}^m*m!=(n-m+1)!/(n-2m+1)!$。

两个阶乘的除法非常简单，手推一下就能解决。

于是，这个复杂度立刻变成线性的：

```cpp
#include <stdio.h>
#include <stdlib.h>

using namespace std;

int main() {
    int t;
    long long i, n, m, p, ans = 1;
    // 注意用long long，两个10^9相乘必爆int
    scanf("%d %lld %lld %lld", &t, &n, &m, &p);
    for (i = n + 1 - m; i > n + 1 - 2 * m; i--) {
        ans *= i;
        ans %= p;
    }
    printf("%lld", ans);
    return 0;
}
```