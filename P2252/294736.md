写在前面：  
首先看一眼这道题：  
博弈论！！！我三分钟水了他  
~~第二眼：不会，百度~~


------------

我们来介绍一下这题的做法：  
$$\huge\text{威佐夫博弈}$$   
这种情况下是颇为复杂的。我们用$(a_k,b_k)(a_k \leq b_k \;k=1,2,3,\cdots,n)$表示两堆物品的数量并称其为局势，如果甲面对$(0,0)$，那么甲已经输了，这种局势我们称为奇异局势。前几个奇异局势是:$(0,0)\;(1,2)\;(3,5)\;(4,7)\;(6,10)\;(8,13)\;(9,15)\;(11,18)\;(12,20)$  

给定任意一个局势，如何判断他是不是奇异局势呢，我们有如下公式：
任意一个奇异局势，满足
$a_k=\lfloor k*\dfrac{(1+\sqrt5)}{2}\rfloor$ 
$b_k=a_k+k$  
找找规律就能找到了（~~个鬼~~）
于是我们就可以愉快的枚举了，如果想了解更多关于威佐夫博弈的东西，[点这里（~~电脑是搜狗没办法~~）](https://baike.sogou.com/v70054942.htm?fromTitle=%E5%A8%81%E4%BD%90%E5%A4%AB%E5%8D%9A%E5%A5%95)  
上代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define T sqrt(5.0)//懒人必备#define
int main()
{
    int a,b;
    while(~scanf("%d %d",&a,&b))//只要输入就一直做
    {
        if(a>b)//我们取a和b中的最小值
        {
            int t=a;
            a=b;
            b=t;
        }
        int t=b-a;//观察发现，每个奇异局势对应的k都是他们两个的差
        if(a==floor(t*(1+T)/2))printf("0\n");//直接判断好了
        else printf("1\n");
    }
    return 0;
}
```


------------

写在后面：  
我不会证明，对不起chen_zhe我太弱了  
错误数据已修正  



