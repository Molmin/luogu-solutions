## 1. 题目大意
有两堆石子，数量任意，可以不同。游戏开始由两个人轮流取石子。游戏规定，每次有两种不同的取法，一是可以在任意的一堆中取走任意多的石子；二是可以在两堆中同时取走相同数量的石子。最后把石子全部取完者为胜者。现在给出初始的两堆石子的数目，你先取，假设双方都采取最好的策略，问最后你是胜者还是败者。

显然，这是一道威佐夫博弈的板子题。输出部分的 `-1` 是忽悠人的。
## 2. 威佐夫博弈
### 2.1 定义
有两堆各若干个物品，两个人轮流从任一堆取至少一个或同时从两堆中取同样多的物品，规定每次至少取一个，多者不限，最后取光者得胜。

### 2.2 奇异局势
用（$a_k,b_k$）,$a_k ≤ b_k ,k\in [0,n]$ 表示两堆物品的数量并称其为局势，如果甲面对 $(0,0)$，那么甲已经输了，这种局势我们称为奇异局势。前几个奇异局势是：$(0,0)$,$(1,2)$,$(3,5)$,（4，7）,（6，10）,（8，13）,（9，15）,（11，18）,（12，20）。（注：$k$ 表示奇异局势的序号， 第一个奇异局势 $k=0$）。

可以看出，$a_0=b_0=0$，$a_k$ 是未在前面出现过的最小自然数,而 $b_k= a_k + k$。
### 2.3 性质
1. 任何自然数都包含在一个且仅有一个奇异局势中（放缩）。

$a_k > a_{k-1},b_k=a_k + k > a_{k-1} + k > a_{k-1} + k - 1 = b_{k-1} > a_{k-1}$

2. 任意操作都可将奇异局势变为非奇异局势。

3. 采用适当的方法，可以将非奇异局势变为奇异局势。

4. 一个状态是必败态，当且仅当它的所有后继状态都是必胜态；而一个状态是必胜态，只要它的后继状态有一个以上的必败态即可。

5. $(a,b)$ 和 $(b, a)$ 的胜负性是相同的 $(a \neq b)$。

6. 若 $(a, b)$ 是必败态，则对于所有的 $x \neq a$ 和 $y \neq b$，$(x, b)$ 和 $(a, y)$ 是必胜态（分类讨论）。

7. 若 $(a, b)$ 是必败态，则对于所有的 $d > 0,(a + d, b + d)$ 是必胜态。

8. 在所有的必败态中，每个数字恰巧出现一次（鸽巢原理）。

9. 矩阵中每行第一个数恰巧是前面每一行中没有出现过的最小正整数。矩阵第 $i$ 行的第二个数正好为第一个数加上 $i$（数学归纳法）。

10. Betty 定理
### 2.4 结论
两个人如果都采用正确操作，那么面对非奇异局势，先拿者必胜；反之，则后拿者取胜。

任给一个局势 $(a,b)$，判断它是不是奇异局势有如下公式：
$a_k=\left[\dfrac{k(1+\sqrt{5} )}{2}\right]$,$bk= ak + k$，$k\in [0,n]$ (方括号表示取整函数)

其中出现了黄金分割数 $(1+\sqrt 5)/2 = 1.618\cdots$。因此，由 $a_k,b_k$ 组成的矩形近似为黄金矩形，由于 $\dfrac{2}{1+\sqrt 5}=\dfrac{\sqrt 5-1}{2}$，可以先求出 $j=\left[\dfrac{a(\sqrt 5-1)}{2}\right]$，若 $a=\left[\dfrac{j(1+\sqrt 5)}2\right]$，那么 $a = aj$，$bj = aj + j$，若不等于，那么  $a = aj+1$，$b = aj + j + 1$，若都不是，那么就不是奇异局势。然后再按照上述法则进行，一定会遇到奇异局势。

关于黄金分割比的证明可用 Betty 定理。具体请参考大神 @蒟蒻wyx。

## 3. 完整代码
```cpp
#include<iostream>
#include<cmath>
#include<cstdio>
using namespace std;
#define re register
#define gc getchar()
inline int read(){
    re int x=0,f=1; re char c=gc;
	while(!isdigit(c)){
		if(c=='-') f=-1;
		c=gc;
	}
	while(isdigit(c)){
		x=(x<<1)+(x<<3)+(c^48);
		c=gc;
	}
	return x*f;
}//快读（虽然没啥用）
int main(){
    double p=(sqrt(5.0)+1.0)/2.0;//黄金分割
    int n=read(),m=read();//数入
    cout<<(min(m,n)==(int)((double)(abs(n-m))*p)?0:1);//计算输出 0 或 1
    return 0;
}
```