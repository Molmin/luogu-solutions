[AT2340 [AGC011D] Half Reflector ](https://www.luogu.com.cn/problem/AT2340)

$2022:10:11$ 修复部分 $\text{Latex}$。


大家好，因为我非常喜欢暴力，所以我用暴力模拟草过了这题。~~其实是自己做的时候没有发现 $2n$ 循环节的规律。~~



题目大意：有 $n$ 个门排成一排，每个门会开着或者关着，如果门开着球就可以直接通过，关着的话球撞到上面就会反弹。只要球碰到一个门，这个门就会改变自己的形态。现在有 $k$ 个球，依次从所有门的最左端滚进去，问 $k$ 次后每个门的状态。门开着用 $B$ 表示，门关着用 $A$ 表示。



为方便表达，本文令开为 $\texttt{0}$，关为 $\texttt{1}$，球为 $\texttt{*}$，球的方向为 $\texttt{>}$ 或 $\texttt{<}$。



我们可以通过手玩发现一个很有意思的事情，如果第一个门是关着的，那么球就会直接被弹回去而不会影响后面的门。而剩余第一个门开着的情况，球就一定会从最右边出来。



我们可以简单证明一下，如果第一个门是开着的，球经过后这个门就会关上，而当第二个门（第一个门后面第一个关上的门，可以不一定是第二个，类比即可）是关上的时候，球就会反弹，此时将第二个门打开，又弹到第一个门，再将第一个门打开，于是又弹回第二个门，将其关上，然后继续向下走。如果觉得抽象可以看下面这个图： $\texttt{*>01} \to \texttt{1*>1} \to \texttt{1*<0} \to \texttt{0*>0} \to \texttt{01*>}$。



很容易发现，球过了第二个门之后第二个门也关上了，这就又构成了一个子问题，把第二个门也当作第一个门来看，因此发现球永远不会再从头出来。



发现递归这个性质以后我们可以考虑归纳法。设球现在滚到了第 $i$ 个门，若第 $i$ 个门是关上的，那么球会弹回去，再将第 $i$ 个门打开，于是我们就确定了此时的门状态为 $0$。



接下来分类讨论，设第 $i$ 个门状态为 $0$，$i+1$ 个门状态也为 $0$，那么球经过后第 $i$ 个门一定会变成 $1$，因为球经过第 $i$ 位后就会立即通过 $i+1$ 位，不会再回到第 $i$ 位（也就是开头的结论）。此时状况：$\texttt{*>00} \to \texttt{1*>0} \to \texttt{11*>}$。



若第 $i$ 个门状态为 $0$ ，第 $i+1$ 个门状态为 $1$ ，那么球经过后第 $i$ 个门一定会变成 $0$ 。因为球一开始通过第 $i$ 个门时它变为 $1$ ，而球会被 $i+1$ 个门反弹回来，然后在被 $i$ 反弹回去通过 $i+1$ ，然后就不会再回到 $i$ 了。此时状况：$\texttt{*>01} \to \texttt{1*>1} \to \texttt{1<*0} \to \texttt{0*>0} \to \texttt{01*>}$ 。



于是我们可以发现除了最后一位以外，每一个门在通过一个球之后的状态都是它下一个门的状态的取反，而最后一个门则固定关上（球通过开了的门出去，然后门关上了），而除了球一开始就被弹飞的情况外第一个门都是开的，因此我们可以把门的状态看成一个环，除了球被弹飞以外的状况，其他都是将环循环左移一位并取反。



于是我们只需要维护一个指针指向第一个门，在维护一个是否取反的变量，循环 $k$ 次即可。时间复杂度 $O(k)$，因为常数极小所以最慢的点也只需要 $100ms$，完全不用考虑 $2n$ 的循环节。（因为我不会证明）



AC Code:

```C++
#include<bits/stdc++.h>
using namespace std;
const int maxn=2e5+10;
typedef long long ll;
int a[maxn];
char s[maxn];
int main()
{
	int n,k;
	cin>>n>>k;
	cin>>(s+1);
	for(int i=1;i<=n;i++)
	{
		if(s[i]=='A')
			a[i]=1;
		else
			a[i]=0;
	}
	int tp=1,f=0;
	for(int i=1;i<=k;i++)
	{
		if(f==0)
		{
			if(a[tp]==1)
				a[tp]=0;
			else
				f=1,tp++;
		}
		else
		{
			if(a[tp]==0)
				a[tp]=1;
			else
				f=0,tp++;
		}
		if(tp==n+1)
			tp=1;
	}
	if(f==0)
	{
		for(int i=tp;i<=n;i++)
			if(a[i]==1)
				putchar('A');
			else
				putchar('B');
		for(int i=1;i<tp;i++)
			if(a[i]==1)
				putchar('A');
			else
				putchar('B');
	}
	else
	{
		for(int i=tp;i<=n;i++)
			if(a[i]==0)
				putchar('A');
			else
				putchar('B');
		for(int i=1;i<tp;i++)
			if(a[i]==0)
				putchar('A');
			else
				putchar('B');
	}
	return 0;
}
```

