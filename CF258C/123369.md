# [Portal](https://www.luogu.com.cn/problem/CF258C)

因为 $\operatorname{lcm}\{b_i\}=\max\{b_i\}$ 它等价于所有的 $b_i$ 都是 $\max\{b_i\}$ 的因数，所以我们可以构思出如下的算法：

我们从 $1$ 到 $\max\{a_i\}$ 枚举 $\max\{b_i\}$，设一个值 $i$ 表示它。然后，我们求出 $i$ 的所有因数，并将其从小到大排序。设排完序后我们得到了 $p_1,p_2,\dots,p_m$。

则我们枚举每段间隙 $[p_1,p_2),[p_2,p_3),\dots,[p_{m-1},p_m),[p_m,\max\{a_i\}]$，并求出每段间隙中有多少个 $a$ 中的数。则间隙 $[p_k,p_{k+1})$ 中的每一个数，都有 $k$ 种不同的取值（即 $p_1\sim p_k$），答案乘上 $k^{num}$，其中 $num$ 是个数。

但是需要特判的是最后一个间隙 $[p_m,\max\{a_i\}]$，它里面每个数都有 $m$ 种不同取值，但是必须保证**至少有一个数**取到了 $p_m$。故这里乘上的应是 $m^{num}-(m-1)^{num}$。

关于如何求出每段间隙的 $num$，这个可以通过将 $a$ 排序后在里面二分求出，但这样要多一个 $\log$；另一个方法是通过 two-pointers+前缀和求出，是 $O(1)$ 的，可以参见代码。

最后是复杂度分析。显然它的复杂度应是 $O(\sum\limits_{i=1}^{\max\{a_i\}}d_i)$ 的，其中 $d_i$ 是因数个数。乍一看这是 $O(n\sqrt{n})$ 的，但实际上是 $O(n\log n)$ 的，因为关于每个因数的贡献分析后会发现它就等于调和级数。

$O(n\sqrt{n})$ 的做法是对于每个 $i$ 都 $\sqrt{i}$ 地暴力求出因数；而 $O(n\log n)$ 的做法是预处理因数（某个数 $i$ 是所有形如 $\alpha i$ 的数的因数，而 $\alpha\in[1,\dfrac{\max\{a_i\}}{i}]$）。这里为了方便是 $O(n\sqrt{n})$ 的方法。

[代码戳这儿](https://www.luogu.com.cn/record/37523282)