想了好长时间这个题呢……  
  
设 $dp[i]$ 表示钱数为 $i$ 元时的方案数，菜的价钱为 $a[i]$ 所以就有  
$$dp[i]+=dp[\ i-a[i]\ ]$$  
就是说 **当前钱数的方案数** 就等于 **当前钱数的方案数** 与 **当前钱数减去菜价所剩钱数 的方案数** 的和  
* 我们还发现，菜是一个一个的处理过去的，所以处理完的菜对之后的答案就没有什么影响了，于是我们可以边读边操作  
*  因为每种菜只有一个，所以要从我们最多的钱数向当前菜品$+1$的价钱进行操作  
* 在我们进行完上面的操作后我们再处理当前菜品的价格，当然是给当前菜品价钱对应的方案数$+1$啦!  
* **为什么要最后处理当前菜品呢？**当然是排除当前菜品对当前方案的影响，什么意思呢？如果这个当前的菜价钱为2，如果提前给$dp[2]+1$,而$dp[4]=dp[4-2]$,很明显我们多算了一次~和倒着处理答案道理是一样的

```cpp
#include<bits/stdc++.h>
using namespace std;
int m,n,a,dp[10010];
int main(){
	scanf("%d %d",&n,&m);
	for(int i=1;i<=n;++i){
		scanf("%d",&a);
		for(int j=m;j>a;--j)	
        	dp[j]+=dp[j-a];
		++dp[a];
	}
	printf("%d",dp[m]);
	return 0;
}
```