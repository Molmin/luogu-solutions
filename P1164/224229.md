### 这是一道很好的 背包DP 练习题
**先摆出动态转移方程   dp[ j ] = dp[ j ]+dp[ j - a[i] ]**

**下面就来说一下怎么推出的**

首先，题目要求是求出方案总数，所以不能像普通的0/1背包一样，用 max 或 min 函数求最大或最小值。

用 dp[ j ] 表示达到当前钱数时，已经求出的方案数；用 a[ i ] 表示点第 i 样菜需要花费的钱；那么，就可以用 dp[ j - a[i] ] 表示花费 j - a[i] 时的方案数。

再将两者想加，就是这个状态转移方程

**下面代码：**
```cpp
#include<bits/stdc++.h>//万能头文件，求方便
using namespace std;
int n,m,a[1005],dp[1005];//a储存每样菜的价格

int main()
{
	cin>>n>>m;
	for(int i=1;i<=n;i++)
		cin>>a[i];
```
**这里必须先把 dp[ 0 ] 的初值赋为 1**

因为当钱数==0时，说明当前方案已经成立，所以方案总数加 1
```
	dp[0]=1;
	for(int i=1;i<=n;i++)
		for(int j=m;j>=0;j--)
			if(j-a[i]>=0)
				dp[j]=dp[j]+pd[j-a[i]];
	cout<<dp[m]<<endl;//最后输出钱数为 m 时的方案总数
	return 0;
}
```
