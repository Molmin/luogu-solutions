此题解仅当充数。

这题正解用背包是很明显的，但机房一众巨佬都用爆搜过了...

我这道题用了三天死扯出一个背包（尽管这个背包很玄学又很模糊不清）

咱不说那些令人伤心的事情。

首先只把这题当普通的 01 背包来看。背包的容量在这里为数据上限 $10^5 \times 3$。

那么为什么乘上 $3$？

其实稍微想想就可得。既然说要集齐三种维生素，又要求答案最小，那么含有相同维生素的饮料我们就只选择一种喝。

按照上述思路，想集齐三种维生素，最多需要三种果汁就行，容量自然就是 $3 \times 10^5$。

但是每次都从 $3 \times 10^5$ 开始往前 DP，面对如此数据难免会 TLE，所以我们设一个变量存储当前得到价值的最大量，随着输入更新。

按照“含有相同维生素的饮料我们只选择一种喝”的思想，可以对 DP 过程进行一些玄学优化。

这里简要介绍一下状态压缩和位运算。

状态压缩简单说就是，假如你有一个布尔型数组，你可以使用二进制来把这个数组存储的信息压缩到一个变量里。

具体怎么做呢？

假设你的数组长这样：`{true,true,false,true}`，你就可以用`1`代替`true`，`0`代替`false`，把数组记作`1101`，转换成十进制即为 $13$。这样你就用一个变量存储了一个数组！是不是很棒？

你会问了：既然我已经状态压缩了，怎么再对数组进行操作呢？

这就要用到——神奇的位运算！

关于位运算，可以去看专门讲解的博客，这里就不再赘述，只介绍一下接下来会用到的运算符：按位与`&`和按位或`|`。

这里有两个二进制数字：`0110`，`1101`，分别代表十进制的 $6$ 和 $13$。如果我把这俩数进行与运算，就相当于是把两个数字的每一位两两对应分别进行与运算，也就是`0&&1,1&&1,1&&0,0&&1`，结果为`0100`，即十进制的 $4$。或运算也一样，把两个数字的每一位两两对应分别进行或运算，结果为`0||1,1||1,1||0,0||1`，即`1111`，也即十进制的 $15$。

科普时间结束，上代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,c,ma,ans=-1;
string s;
struct vtms{
	bool is;int vtm;
}f[300003]; //背包数组
int main(){
	scanf("%d",&n);
	f[0].is=true;
	for(int i=1;i<=n;++i){
		cin>>c>>s;
		int v=0;
		for(int i=0;i<s.length();++i)
			v+=pow(2,s[i]-'A'); //进行状态压缩，存储维生素的种类
		for(int l=ma+c;l>=c;--l)
			if(f[l-c].is){ //如果这个价值能够得到
				int vt=v|f[l-c].vtm; //使用按位或得到这个价值能够获取的维生素
				if(vt>f[l-c].vtm&&vt>f[l].vtm){ //如果比原来多了某种维生素
					f[l].is=true; //那就存下来
					f[l].vtm=vt;
					ma=max(ma,l); //更新当前最大价值
				}
			}
	}
	for(int l=0;l<=ma;++l) //进行筛选
		if(f[l].is&&f[l].vtm==7){ //如果这个价位集齐了所有维生素
			printf("%d\n",l);
			return 0; //输出答案，结束程序
		}
	printf("-1\n"); //没有一个价位能够集齐维生素
	return 0;
}
```