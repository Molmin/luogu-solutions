纪念本人这周绿钩的题解 qwq  
很久以前教练拿这道题给我做，当时我菜死了，用各种手段套到数据写了一份非常容易 Hack 的贪心。在 CF 上闲逛的时候偶然发现了这道题，决定做一下。  
这篇题解是给初学者看的，大佬请自动跳过  
闲话少说，切入正题：  

---
看到这道题，第一反应是状压 dp。  
把 $\texttt{A}$ 压成 $(100)_2$，$\texttt{B}$ 压成 $(010)_2$，$\texttt{C}$ 压成 $(001)_2$  

根据这样的规则，有了字符，字符串就是几个字符的二进制累加起来。

所以我们以 $k_i$ 为状压后的字符串，这是转换部分的代码：  
```cpp
void get_base_two(int i,string str)//i 是位置，str 是字符串
{
	int ans=0;
	for(int p=0;p<str.size();p++)
		if(str[p]=='A')ans=ans+(1<<2);//<<
 是左移，这里表示二进制左移 2 位，就是 (100)_2，就是 (4)_10
		else if(str[p]=='B')ans=ans+(1<<1);//同上
		else if(str[p]=='C')ans=ans+(1<<0);//同上
	k[i]=ans;
}
```

状压的精髓就在于将一个难以表示的状态转化成一个二进制数。  

---
我们已经状压好了，开始 dp  

建立一个一维数组 $f$ 表示状态，$f_i$ 表示当前二进制串（状压后的字符串）为 $i$ 时，最少的花费。

然后我们要初始化。因为只有 $7$ 个状态，是求最小值，所以我们每个都赋值为 $0x3f3f3f3f$ 就行了。  

代码：  
```cpp
for(int p=1;p<=7;p++)
		f[p]=INF;
```

这个时候我们就要开始写 dp 的框架了。  
第一层枚举的一般都是物品，第二层一般枚举二进制串。  
长这样：  
```cpp
for(int p=1;p<=n;p++)
		for(int i=7;i>=0;i--)//二进制串是从 7（111）到 0（000）
```

下面就是方程。  
首先我们需要知道一个道理，$x|y$ （$|$ 是位运算的或，两个位有一个为 $1$ 就是 $1$）就是两个二进制串的并集，这个很好想，稍微懂点脑子就可以了。  

所以我们每次可以更新 $f_{i|k_p}$，这就表示选择 $p$ 个物品时刚好二进制串是 $i$ 的最大值。

然后我们每次都会有两种状态，选择这个物品和不选择这个物品对吧。  

最好考虑的，如果不选择这个物品，$f_{i|k_p}$ 还是 $f_{i|k_p}$，所以是 $f_{i|k_p}$。  

如果是选择这个物品呢？那么应该是 $f_i+v_p$（$v_p$ 是价格），为什么呢？我们更新的是 $f_{i|k_p}$ ，这是已经处理过的，但是没处理过的呢？就无法或上一个 $k_p$，也就是只剩下 $i$，所以说是 $f_i$。算上 $p$ 的话价值肯定要加上，所以是 $f_i+v_p$  

方程写出来了：  
$f_{i|k_p}=\min(f_{i|k_p},f_i+v_p)$  

代码：  
```cpp
for(int p=1;p<=n;p++)
		for(int i=7;i>=0;i--)
			f[i|k[p]]=min(f[i|k[p]],f[i]+v[p]);
```

最后我们要输出答案  
```cpp
cout<<((f[7]==INF)?(-1):(f[7]))<<endl;
//f[7]==INF 是判断无解，这个时候无法 | 变成 (111)_2，更新不了 f[7]，所以是 INF
```

完结撒花~ 