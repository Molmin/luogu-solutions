经过一天的奋斗，终于A了这题。概括性地，这题就两个字：**细节**。思维难度并不是很大，这是这个细节有点恶心。~~口胡五分钟，打码两小时~~。

看了题解区的8篇题解：4篇平衡树，4篇树状数组（~~很平衡~~）由于我的做法是树状数组，就不评价平衡树做法了。4篇树状数组中，1篇只讲了一点点核心，没有讲细节。还有三篇都各有所长。有两篇我个人感觉代码和文章有点不对应的感觉。而且，都没有讲如何想到，以及纯暴力的部分分的过程。所以我个人就尽己所能，能综合就综合一点。能讲明白就讲明白一点。

简明题意：1、三种操作：**插入**、**删除**、**询问**。 2、插入一个不等式 3、删除一个不等式。 4、查询当前$x=k$，有多少个满足题意的不等式。

解法一：暴力

对于插入操作；设置一个结构体数组，存储参数$a$，$b$，$c$。

对于删除操作：标记序号。

对于询问操作：扫一遍结构体数组，如果没有标记过，就判断是否满足不等式，如果满足，$ans$++。 扫完后输出。

时间复杂度$O(N^2)$，显然不行。期望得分40分，实际得分40分。

解法二：平衡树（~~蒟蒻不会~~）

解法三：树状数组

思考过程：观察询问操作，给出$k$。将$k$带入不等式。判断是否满足，那么我们可以先把不等式解出来：$ax>c-b$ 当$a>0$时，$x>(c-b)/a$；此时$k>(c-b)/a$即可。当$a<0$时，$x<(c-b)/a$，此时$k<(c-b)/a$即可;当$a=0$时，$ax$恒$=0$，当$c-b<0$时，恒成立，此时无论k是多少都可以；当$c-b≥0$时，恒不成立，此时无论$k$是多少都不行。（先不用管有什么用，我们要有这个思维转换的过程，因为题解写的是那条正确的路，在做题思考的时候应该多想，多试，不一定做题就会一次走上正确的路）

现在，题目就变成了，**插入两种数。删除某个数**。查询某个值可以满足多少数的大小关系（由上面的分析可以得出：两种大小关系$<$和$>$）**也就是对$<$的那种数里查找有几个数是小于大于$k$的**；**对$>$的那种数里查找有几个数是大于$k$的**。到了这里，就可以联想到[P1908 逆序对](https://www.luogu.com.cn/problem/P1908)的树状数组做法，（这里其实强烈建议不会这题的小伙伴可以先去用树状数组做一下$P1980$再来做这题）求$Ai$前有几个小于$Ai$的数。那么这里一个是求大于，一个是求小于。求小于的可以用那一题的做法，那求大于呢？这时，我们就需要转换一下了：**将区间转置**，**用值域的上界减去这个数（$k=1e6+1-k$）**，那么原来大的数就变成了小的数，原来大的数就变成了小的数。这样就可以依然套用求小于的方法求大于了。

到这，事情就变得很明了了。我们来捋一捋思路：
1、插入：分成大于和小于两类数进行插入。（$a=0$时特殊处理）
2、删除：插入时是$y=1$，删除时就是$y=-1$。 3、询问，直接前缀和查询两类数，输出。

题目到这里似乎就已经解决了。但是如果这么简单的话，又怎么会是蓝题呢？~~最多黄题~~下面是重头戏：**细节**

**细节**：1、对于a=0的特殊处理 2、因为$a$,$b$,$c$的值达到了$10^8$，但是$k$的值只有$10^6$，这明显是可以舍去一些特殊情况的（不舍不影响正确性。但是树状数组最后的时间复杂度是$O(nlogk)$，且空间是按值域开的，不舍去的话，不仅会爆时间，~~貌似也会爆空间~~（空间我没试过，时间我试过了）） 3、删去操作的判重，因为数据中可能会出现：**同一个不等式被删除多次的情况**。如果不判重，首先会影响一部分时间复杂度，其次同一个数被删两次（实际只删一次），影响计数。 4、我们知道树状数组查询小于，值域只能∈$[1,+∞)$。而题目中的数据会出现负数。5、因为$k$是整数，但是$(b-c)/a$却不一定是整数，而且树状数组的查询也需要是整数

明白了哪些细节之后就开始处理细节。 1、当$a=0$时，有两种情况：一、无论k是多少，都成立；二、无论k是多少都不成立。我们可以设置一个计数变量$res$统计有多少个恒成立的值，在$ans$处$加上res$。恒不成立的其实可以不用管，只要象征性的在插入这个操作让序号++，保持序号正常即可。 2、当$a>0$时，$x>(c-b)/a$，如果右边$<-10^6$，不等式恒成立，如果右边$>10^6$，不等式恒不成立。当$a<0$时，$x<(c-b)/a$，如果右边$>10^6$，不等式恒成立，如果右边$<-10^6$，不等式恒不成立。（**对恒成立和恒不成立的不等式，处理方式同1**） 3、对于重复出现的删除只需要加一个数组标记是否出现过即可。（ $if(vis[x]) continue;$ ） 4、对于出现的负数，其实也很简单，只要**把$k$和$(c-b)/a$所得的值都$+10^6$+1**，就都$≥1$了。   5、对于解集为$x>p$的不等式，则将其转化为 $x\geq\lfloor p \rfloor-1$。 对于解集为$x<p$的不等式，则将其转化为 $x\leq\lceil p \rceil+1$

时间复杂度度$O(Nlogk)$ 空间复杂度$O(K)$。期望得分$100$分，实际得分$100$分

搞定，上代码：

$Code$

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=1e6+5;
struct node{
	int a,d;
}q[2*maxn];
int tail,res,d,n,ans,cnt,cet,xans,head;
double a,b,c1,num;
int c[2*maxn],C[2*maxn],sna[2*maxn];
bool st[2*maxn],vis[2*maxn],ts[2*maxn];
inline int read()
{
    int x=0,f=1;
    char ch=getchar();
    while(ch<'0'||ch>'9'){
        if(ch=='-')
            f=-1;
        ch=getchar();
    }
    while(ch>='0'&&ch<='9'){
        x=(x<<1)+(x<<3)+(ch^48);
        ch=getchar();
    }
    return x*f;
}//快读可有可无
int lowbit(int x)
{
	return x&(-x);
}
void update1(int x,int y)
{
	while(x<=2*maxn)
	{
		c[x]+=y;
		x+=lowbit(x);
	}
}
int sum1(int x)
{
	 xans=0;
	while(x)
	{
		xans+=c[x];
		x-=lowbit(x);
	}
	return xans;
}
void update2(int x,int y)
{
	while(x<=2*maxn)
	{
		C[x]+=y;
		x+=lowbit(x);
	}
}
int sum2(int x)
{
	 xans=0;
	while(x)
	{
		xans+=C[x];
		x-=lowbit(x);
	}
	return xans;
}//树状数组的板子，只不过我这里写了两遍，可以加上一个数组的参数，这样就只需要写一遍了
int main()
{
	string s;
	int i,x,k;
	n=read();
	for(i=1;i<=n;i++)
	{
		cin>>s;
		if(s=="Add")
		{
			a=read();b=read();c1=read();
			num=(c1-b)/a;//a，b，c要用double型
			if(a>0){
				if(num>1e6){
					ts[++tail]=1;
              continue;//恒不成立的情况，标记一下就可以了
				}
				else if(num<-1e6){
					st[++tail]=1;
					res++;continue;//恒成立的情况，计数++
				}
			}
			else if(a<0){
				if(num>1e6){
					st[++tail]=1;
					res++;continue;
				}
				else if(num<-1e6){
					ts[++tail]=1;
              continue;
				}	
			}
			if(a>0){
				d=(int)floor(num)+1;
				d+=maxn;
				q[++tail].a=a;
				q[tail].d=d;
				update1(d,1);
			}
			else if(a<0){
				d=(int)ceil(num)-1;
				d=maxn-d;//区间倒置
				q[++tail].a=a;
				q[tail].d=d;
				update2(d,1);//树状数组统计
			}
			else if(a==0){
				if(c1-b<0) {
					res++;
					st[++tail]=1;
				}
				else if(c1-b>=0){
					ts[++tail]=1;
				}
			}
		}
		else if(s=="Del")
		{
			x=read();
			if(vis[x]==1) continue;
			if(ts[x]==1){
				ts[x]=0;
			}
			else if(st[x]==1){
				res--;
				st[x]=0;
			}
			else if(q[x].a>0){
				update1(q[x].d,-1);
			}
			else if(q[x].a<0){
				update2(q[x].d,-1);
			}
			vis[x]=1;
		}
		else if(s=="Query")
		{
			k=read();
			cnt=sum1(k+maxn);
			cet=sum2(maxn-k);//查询的时候自然也要转置
			ans=cnt+cet+res;
			sna[++head]=ans;
		}
	}
	for(i=1;i<=head;i++)
	printf("%d\n",sna[i]);
 	return 0;
}

```
