真的很简单啊（逃

做题必须好好读题：

>有一个有$n$个人的队伍，其中第$i$个人需要$t_i$分钟来服务，期间后面的人就要等着。如果一个人等待的时间大于了他被服务的时间，他就会失望。你的任务是重排队伍，使失望的人尽量的少，并只需输出不失望的人的数量的最大值。

不难想到，先服务服务时间少的，后面的人等的时间就少。

所以，可以用排序的思想，定义一个$a$数组，$sort$一下。

然后遍历$a_1-a_n$，如果当前的人并没有失望，则$x+1$，$sum+=a_i$。

请你务必把数组**开大点**。。

代码实现起来就很简单了：

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[100001],n,x=0,sum;
int main() {
	scanf("%d",&n);
	for(int i=1; i<=n; i++) scanf("%d",&a[i]);
	sort(a+1,a+n+1);
	for(int i=1; i<=n; i++) {
		if(sum<=a[i]) {
			x++;
			sum+=a[i];
		}
	}
	printf("%d\n",x);
	return 0;
}
```
