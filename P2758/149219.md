一看就知道这是dp，用dp就要明白dp的三大步骤：

1、定义状态（dp数组）

2、找出状态转移方程

3、初始化边界条件

我们来依次解决这三大问题：

### 1：定义状态，dp数组

这道题有两个字符串，显然就要用到二维数组。那二维数组怎么定义呢？

他要我们求最少字符操作次数，自然要把dp[i][j]定义为在a[i]与b[j]时已编辑的步数

### 2：找出状态转移方程

编辑时有三种可能，自然有三种可能，需要用min判断最小的

如果两个字母一样，就肯定不用变呀

```cpp
dp[i][j]=min(dp[i-1][j],min(dp[i][j-1],dp[i-1][j-1]))+1;//三种情况 
if(a[i]==b[j]) dp[i][j]=dp[i-1][j-1];//如果一样就不变 
```


### 3：初始化边界条件

这一步可以循环做，初始化为循环的变量（最多步骤肯定是字符串距离啦）

于是就可以上代码了：

```cpp
#include<bits/stdc++.h>
using namespace std;
string a,b;
int dp[10005][10005],maxx,ls,lt;
int main()
{
	cin>>a;
	cin>>b;
	a="0"+a;//加一个零用来避免越界
	b="0"+b;//同理 
	ls=a.size();//求长度 
	lt=b.size();
	for(int i=1;i<=ls;i++) dp[i][0]=i;//初始化边界条件 
    for(int i=1;i<=lt;i++) dp[0][i]=i;
	for(int i=1;i<ls;i++){//加了0就从1开始循环，否则会数组越界 
		for(int j=1;j<lt;j++){
			dp[i][j]=min(dp[i-1][j],min(dp[i][j-1],dp[i-1][j-1]))+1;//三种情况 
			if(a[i]==b[j]) dp[i][j]=dp[i-1][j-1];//如果一样就不变 
		}
	}
	cout<<dp[ls-1][lt-1];//输出 
	return 0;//结束了，结束了！
}
```