[P8671 [蓝桥杯 2018 国 AC] 约瑟夫环](https://www.luogu.com.cn/problem/P8671)。

这题分四种做法，一种模拟，一种队列，这两种都超时了，第三种递归，第四种线段树二分，但是这一种我不会。

## 第一种做法：模拟（22ps）。
做法是开一个数组，然后再用一个循环一圈一圈的找。

时间超限。

## 第二种做法：队列。
做法是开一个队列，然后再一个一个枚举。和模拟差不多，也就少那么一点点时间。


## 第三种做法：递归。敲黑板！
递归要推公式。

先把题目描述一下吧。

$0$，$1$，$\cdots$，$n-1$。从数字 $0$ 每次把第 $m$ 个数删除。求最后剩下的数字。

思考操作过程，可以想到我们可以看到每一轮中移走的是第 $m$ 个数字。所以每一轮的第 $m+1$ 会成为下一轮数字为 $0$ 的数。

解决约瑟夫环问题，我们采用倒推，我们倒推出：最后剩下的这个数字，在最开始的数组中的位置。

1. 剩下最后一个数字（简称“它”）的时候，总个数为 $1$，目前下标为：$0$。
2. 那么它在上一轮也是安全的，总个数为 $2$，目前下标为：$(0+m)\bmod{} 2$。
3. 那么它在上上一轮也是安全的，总个数为 $3$，目前下标为：$((0+m)\bmod2+m)\bmod3$。
4. $\cdots$

一共执行 $n$ 次。

答案就为 $((0+m)\bmod2+m)\bmod3 \cdots +m\bmod{n}$。

具体思路就是这样。

具体的数学推导过程和证明方法请看这里：[知乎帖](https://zhuanlan.zhihu.com/p/121159246)。

程序：
```
#include <bits/stdc++.h>
using namespace std;
long long n,k;
long long X(long long x,long long y)
{
	if(x==n) return (y+k)%n;
	return X(x+1,(y+k)%x);
}//答案的子函数。
int main(){
    cin>>n>>k;
    cout<<X(2,0)+1;//因为下标是从0开始的，所以要加1.
    return 0;
}
```