# 题面

[题目传送门](https://www.luogu.com.cn/problem/P8671)

**题目大意：**

约瑟夫问题，给出人数 $n$ 和 $k$，求最后剩下的人是第几号。

# 思路

其实是加强版的[**约瑟夫**](https://www.luogu.com.cn/problem/P1996)。
$n$ 和 $k$ 的范围都是 $10^6$，直接用队列模拟是肯定会 TLE 的，所以得想一种复杂度接近或等于 $O(n)$ 的算法。我们先来看看淘汰某人后约瑟夫环的规律，我们每次把要杀掉的人都放在圈顶（首位），就可以发现，每次要杀掉一个人，整个圈就会逆时针转 $k$ 次。所以我们可以根据这个发现写出如下递推式：
$$F(i)=(F(i-1)+k)\bmod n$$
$$F(1)=0$$
这条式子的意思是，用上一次淘汰的人加上 $k$（正着是减，反着就要加回来）并判断这个位置是在循环圈里的第几位。那么代码就容易写了，直接套用函数即可，复杂度 $O(n)$，不用再考虑优化了。

# 代码
``` cpp
#include<bits/stdc++.h>
using namespace std;
int n,m;//方便和k区分写成m
int f(int n,int k){//直接套用
    if(n<=1)
        return 0;
    return (f(n-1,k)+k)%n;
}
int main(){
    cin>>n>>m;
    cout<<f(n,m)+1;//加一是因为正常mod n结果范围从0开始，而答案要求是从1开始
    return 0;
}
```