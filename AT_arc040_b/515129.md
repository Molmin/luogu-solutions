[题目传送门](https://www.luogu.com.cn/problem/AT_arc040_b)

## Part 1 暴力部分分

dfs 每次二操作的位置，非常暴力，大概是刚学 dfs 的小朋友会写的东西，时间复杂度 $O(n!)$，代码实现没什么细节，这里不给出，不能通过此题。

## Part 2 动态规划

考虑 dp，设 $\mathit{dp}_{i,j}$ 为前 $i$ 个方格已经全部变成了 `o`，现在自己在第 $j$ 个方格。根据转移方式不同，时间复杂度在 $O(n^2)$ 到 $O(n^3)$ 之间，在此题的数据范围可以通过，但是不是本题的最优复杂度，本篇题解不深入讨论这种做法，读者可以自行思考。


## Part 3 贪心

**这是本篇题解的重点。**

可以注意到，如果自己的左边还有 `.` 点，那么这种解法绝对是不符合要求的（因为没有方法将左边的 `.` 点变为 `o` 点）。所以每一次都在碰到 `.` 点时进行二操作可以保证进行的二操作次数最少（因为每次二操作都在允许的范围的最右边，可以保证把最多的 `.` 点变为 `o` 点）。但是这不能保证一操作最优。若是想要将所有 `.` 点变为 `o` 点，那么最后一次二操作的覆盖范围不能比最后一个 `.` 点的位置更左，在满足上述条件的情况下将最后一次二操作的位置尽量挪左，就可以使得一操作最少。

我们发现，如果按照二操作最优的方法先构造，然后调整最后一个二操作的位置使得一操作最优并不会改变二操作次数。也就是说这样构造的方法总步数是最少的。这种做法可以在 $O(n)$ 的时间复杂度内解决该问题。

### Part 3.1 代码实现

如果从前往后扫的话最后一个二操作的位置很难确定，我们不妨从最后扫起，将操作反过来，这样就可以确定最后一次二操作的位置了。

代码如下：

```cpp
#include<iostream>
using namespace std;

int n,s;
string str; //存储平面 

int main() {
	cin >> n >> s;
	cin >> str;
	int step=0,tag=0; //初始化计数变量 
	for(int i=str.size()-1;i>=0;--i) {
		if(str[i]=='.') {
			tag=max(tag,i+1-s); /*计算最后需要向右移动的最少次数*/
			++step;//累加二操作的次数
			for(int j=i;j>=0&&j>=i-s+1;--j) str[j]='o'; //进行操作 
		}
	}
	cout << tag+step << endl; 
	return 0;
} 


```
