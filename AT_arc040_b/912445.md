# [ARC040B] 直線塗り题解
## [传送门](https://www.luogu.com.cn/problem/AT_arc040_b)

## 题目大意

在平面上有 $n$ 个方格，你最开始在1号方格上。每一秒，你可以执行以下两种操作之一：

- 向右移动一格。
- 假设你当前在第 $i$ 个方格，你可以将第 $i$ 个方格到第 $i+s-1$ 个方格涂成黑色。

给定这些方格的初始状态，其中 `.` 表示白色空方格,`o` 表示已经涂成黑色的方格。

问将所有方格都涂成黑色所需的最少时间。
## 分析
这是一个简单的求解最少时间的问题。我们可以使用贪心的思想来解决。

1. 遍历方格的过程中，尽可能涂黑连续的方格。当遇到一个白色空方格时，我们可以选择将它和它后面的 $R-1$ 个方格涂黑，以尽快涂黑更多的方格。

2. 在涂黑连续方格时，需要考虑使得涂黑方格的最远位置尽量靠前。这是因为我们希望在涂黑过程中尽可能多地移动到已涂黑区域之前的方格，以减少总的时间。

具体来说，我们定义一个计数变量 `count` 来记录涂黑的方格数量。然后定义一个变量 `maxPos` 来记录涂黑方格的最远位置。

接下来，从最后一个方格开始向前遍历。如果当前方格是白色空方格（即 `S[i] == '.'`），则将该方格和它后面的 `R-1` 个方格涂黑。同时更新 `maxPos` 的值为当前方格位置减去 `R-1`。然后将计数变量 `count` 加1，并将遍历指针 `i` 减去 `R-1`。

最后，最少时间等于涂黑方格的数量 `count` 加上 `maxPos` 的值。输出最少时间即可。

## 代码实现

```cpp
#include <iostream>
#include <string>

using namespace std;

int main() {
    int N, R;
    string S;

    cin >> N >> R >> S;

    int count = 0;
    int maxPos = 0;

    for (int i = N - 1; i >= 0; i--) {
        if (S[i] == '.') {
            maxPos = max(maxPos, i - R + 1);
            count++;
            i -= R - 1;
        }
    }

    int ans = count + maxPos;
    cout << ans << endl;

    return 0;
}
```
## 复杂度
这个算法的时间复杂度是 $O(N)$，其中 $N$ 是方格的数量。因为我们只需要遍历一遍所有的方格。
