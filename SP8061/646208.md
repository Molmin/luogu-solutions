### 算法一

由于我们要选 $k$ 个孩子，与他们在全部 $n$ 个孩子中的位置无关，因此我们可以先把数组排序。

因为要让最高的与最矮的人高度差尽可能小，所以要让这 $k$ 个孩子的位置尽量连续。

所以可以排序后用尺取法枚举区间两端，将答案更新为区间尾与区间头之差的最小值。

时间复杂度：$O(n\log n)$。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;

int main()
{
    int t;
    cin>>t;
    while(t--){
        int n,m,a[100007],ans=1e9+7;
        ans=1e9+7;
        cin>>n>>m;
        for(int i=1;i<=n;i++) cin>>a[i];
        sort(a+1,a+n+1);
        for(int i=1;i<=n-m+1;i++)
	    {
		    ans=min(ans,a[i+m-1]-a[i]);
	    }
	    cout<<ans<<'\n';
    }
}
```

### 算法二

因为要让最高的与最矮的人高度差尽可能小，也可以想到二分。我们这里定义二分的上界为 $r$，下界为 $l$，$\lfloor (l+r)/2 \rfloor$ 为 $mid$。

我们二分这个高度差，每次检查可以使得多少个孩子使得高度差小于 $mid$。如果这个数大于等于 $k$ ，就可以缩小二分的上界。否则就缩小二分的下界。

时间复杂度也是 $O(n\log n)$。