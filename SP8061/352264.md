### 题目意思
有 $t$ 组数据，每组数据有 $n$ 个数，要求你从中选出 $k$ 个数，问你这几个数最大值与最小值的差值最小是多少，输出这个值。
### 样例分析
```cpp
3
3 1
2 5 4
3 2
5 2 4
3 3
2 5 4
```
+ 第一组数据只用选一个数，随便选一个即可，差值最小是 $1-1=0$。
+ 第二组数据需要选两个数，故选 $5$ 和 $4$，差值最小是 $5-4=1$。
+ 第三组数据需要选三个数，故选 $2$，$5$ 和 $4$，差值最小是 $5-2=3$。
### 题目思路
可以从样例中看到，我们选的数要符合以下几个要求。
+ 在 $k$ 个数里面，要想保证答案最优，这 $k$ 个数必须要尽可能接近。
+ 我们必须反复更新最小值，确保答案最优。

我们肯定会想到暴搜。可是看一下题目的数据范围，$1 \le k \le 20000$，所以暴搜必定会超时。那我们就要考虑另外一种算法了。

思考：有没有办法能让这 $n$ 个数按顺序怎么选都能保证尽量接近呢？其实我们可以先对这 $n$ 个数进行排序，这样我们就可以遍历这 $n$ 个数，从中按顺序选出 $k$ 个数。因为我们对这 $n$ 个数排了序，所以每一次取都能保证这 $k$ 个数尽量接近，我们只需要不断更新最小值就可以了。

考虑到时间复杂度的问题，我算出的时间复杂度是 $O(n \log n)$。完全不会超时。
### 正确代码
```cpp
#include<bits/stdc++.h>
using namespace std;
long long t,n,mi,k;
int a[20005];
int main()
{
    cin>>t;
    while(t--)
    {
        cin>>n>>k;
        for(int i=1; i<=n; i++)cin>>a[i];
        sort(a+1,a+1+n);
        mi=2147483647;//确保每一次去k个数都能保证这k个数尽量接近 
        for(int i=k; i<=n; i++)mi=min(mi,(long long)a[i]-a[i-k+1]);//更新最小值 
        cout<<mi<<endl;//输出正确答案 
    }
    return 0;
}
```
