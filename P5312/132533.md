由于不卡空间不卡常，所以就提供一种比较随便的做法。

如果想要做此题的加强版，可以尝试 P5612。

由于这个排序比较拉跨，只能全局排，所以序列是由一段排好序的前缀加上未排好序的后缀组成。

先考虑维护后缀，比较简单的可以想到开个线段树，对于 $1$ 操作就直接在开好的线段树上预存空间，然后加进去；对于 $2$ 操作在线段树上拆位维护即可，对于 $3$ 操作线段树上下放标记即可；对于 $4$ 操作将后缀加入前缀，清空后缀；

对于前缀，考虑开个 trie 树维护。对于 $2$ 操作维护排名为 $[l,r]$ 的数的和，可以拆位维护；对于 $3$ 操作直接 trie 树上左右反转的同时重新维护每位的数量；对于 $4$ 操作就让后缀插入前缀即可。

这样可以获得时空 $O(n \log ^ 2 n)$ 的简单做法，没实现，应该是会被卡常的。

考虑一种常数较小的做法。

假设全局都按位异或上一个数那么新插入的数都必须按位异或上这个数再插入，这样的话就可以每次预处理 trie 每一层的实际交换顺序，同时实现也更方便。

对于后缀不用数据结构，直接维护后缀内每一位出现数量的前缀和，这样就把后缀的 $2,3$ 操作时间复杂度降了只 $O(\log n)$，同时不使用数据结构维护也带来了一定的常数优势。

虽然空间 $O(n \log ^ 2 n)$ 就可以通过了，但是想获得更优的空间就只能牺牲点时间，离线下来对于每一位单独跑一遍操作，即可将空间压到 $O(n \log n)$，貌似再在 Trie 上搞一些操作可以把空间卡成线性复杂度。

个人只~~贺~~了时空 $O(n \log ^ 2 n)$ 的做法就跑路了，如果仅为了通过此题直接写就好了。如果是为了练习压位 Trie 之类的数据结构也可以来写一下此题，只不过看了一些实现感觉常数也一般，就快了一点，不知道是为什么，毕竟全位运算实现的话应该快很多。

PS：刚才又想了下，貌似这个压位 trie 压了还不如不压（（（        