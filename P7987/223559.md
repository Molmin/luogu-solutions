### 解题思路：

挺麻烦的 $\text{DP}$ 题。

首先发现题目中的两个问题本质一样，将其中一个问题乘上 $-1$ 之后就变成了另一个，所以不妨只考虑一种。下面的题解以求最小为例。

---

先考虑一种朴素的 $\text{DP}$ 思路，记 $f_{i,j}$ 表示考虑到第 $i$ 个位置，其中已经匹配好的一共有 $j$ 个。

然后考虑转移。很明显，根据周边的位置的情况需要分出不同的情况讨论。

首先可以令 $i$ 不被匹配，由于答案单调不减，这种情况下需要从距离 $i$ 长度超过 $k$ 的位置里面选一个最靠右的转移。这个位置对于递增的 $i$ 同样是单调的，可以直接从前一个推过来。

不过这种转移方式并不是一定可行的，如果之前的位置上出现了奇数个被认为是已经匹配的，就要求这个位置的前一个可以和后一个进行匹配，否则在令 $i$ 不匹配之后，就会出现不可能的情况。否则，在任意位置上不存在出现奇数个最近的两个相邻的区块需要进行匹配的情况之后就一定能够说明存在至少一组可行的匹配。

也可以令 $i$ 和之前的某一个位置进行匹配。这样就需要分两种情况讨论，之前如果有奇数个未匹配的就和之前的匹配，反之就和之后的进行匹配。这个地方有一个很显然的贪心就是选择相邻的两个进行匹配一定是最有可能实现的情况，所以直接判断和之前或者之后的最近的位置是否能够匹配就行了。

---
这样的时间复杂度是 $O(n^2)$ 的，不能通过。

但是根据上面的转移，可以发现其实真正决定匹配的是 $j$ 的奇偶性，直接记录下这个就行了。

优化后总复杂度 $O(n)$。

---
### 代码：

```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
const int INF=1000000000;
int T,n,k,x[100005],y[100005],l,ans,f[100005][2],ti,now;
int main(){
	scanf("%d%d%d",&T,&n,&k);
	if(T==2)ti=-1;
	else ti=1;
	for(int i=1;i<=n;i++){
		scanf("%d%d",&x[i],&y[i]);
		y[i]*=ti;
	}
	x[0]=-INF;
	x[n+1]=2*INF;
	for(int i=0;i<=n+1;i++)
	f[i][0]=f[i][1]=INF;
	f[0][0]=0;
	for(int i=1;i<=n;i++){
		while(x[i]-x[l+1]>k)l++;
							f[i][i&1]=min(f[i][i&1],f[l][!(i&1)]+y[i]);
		if(x[i+1]-x[i-1]<=k)f[i][!(i&1)]=min(f[i][!(i&1)],f[l][i&1]+y[i]);
		if(x[i]-x[i-1]<=k)	f[i][i&1]=min(f[i][i&1],f[i-1][i&1]);
		if(x[i+1]-x[i]<=k)	f[i][!(i&1)]=min(f[i][!(i&1)],f[i-1][!(i&1)]);
	}
		
	printf("%d",n&1?f[n][1]*ti:f[n][0]*ti);
	return 0;
}
```
