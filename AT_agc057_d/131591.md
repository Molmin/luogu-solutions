update on 01/30/2023：之前题解太抽象了不是给人看的，在 @hyzhutao 的帮助下修改了大部分表述。

## 一、题意

给定一个正整数 $S$ ，称一个正整数集合 $A$ 是好的，当且仅当它满足以下条件：

1. $A$  中元素在 $[0,S)$ 之间

2. 不能用 $A$ 中元素多次相加得到 $S$

考虑所有好的集合中元素数量最大且字典序最小的集合 $A$ ，多次询问，求集合 $A$ 从小到大排序后的第 $k$ 项，或集合大小小于 $k$

$ T \le 1000 , S \le 10^{18} $

其实这个题意写的不太清楚，到底是需要先保证字典序最小还是先保证元素数量最多？所以先澄清一下，题目要求的应当是先保证字典序最小再保证元素个数最多，也就是我们需要做一个简单的的贪心：从 $1$ 扫描到 $S$ ，每次能新加一个元素就加进去，有矛盾加不进去的话就不加。

## 二、一个直观感受

$A_1$ 是**最小的不是** $S$ 的约数的正整数，这一点在我们的前面提到的贪心成立的前提下是显然成立的。

比如 $S = 120$ 则 $A_1 = 7$ 。

所以我们又可以有一个直观感受：这个 $A_1$ 大概不会太大，因为 $S$ 是 $lcm(1, 2, ...A_1 - 1)$ 的倍数。

于是我们可以计算得到： $A_1 \leq 43$ 。

## 三、解决问题

既然 $A_1$ 很小，可以利用 $A_1$ 来解决问题。

下文中设 $A_1=m\leq 43$ ，最终所选数字的集合为 $B$。（和题面有所不同）

- 引理 1. 若 $a,b\in B$ 且 $a+b<S$，则 $a+b\in B$。

$a+b$ 是 $a,b$ 的一个线性组合，若 $a,b$ 在集合 $B$ 中，且此时 $B$ 中元素不能用线性组合表示出 $S$，那么加入 $a+b$ 后也不可能就能表示出 $S$ 了。秉持着能加则加的原则，可以把 $a+b$ 加进 $B$。

更进一步地，若当前 $B$ 中元素为 $A_1,A_2,A_3,...A_r$ 且 $\sum_{i=1}^{r}k_iA_i < S$，则 $\sum_{i=1}^{r}k_iA_i\in B$。

据此可以得出 $m,2m,3m,4m...$ 必定在集合 $B$ 中，但我们不满足于此。把所有 $[1, S - 1]$ 中的正整数按照模 $m$ 的余数分成 $m$ 个剩余类，并将第 $i$ 类中的元素按照升序排序为 $Q_i$。

- 引理 2. $B$ 中含有的第 $i$ 类元素，只要该类非空，则其应该是 $Q_i$ 的一段后缀。

这个引理可以根据引理 1 来说明。

分成 $m$ 类有什么用处呢？只要我们求出了所有第 $i$ 类元素的开头元素 $st_i$，就能知道集合 $B$ 中的所有元素，于是可以用二分查找法找到第 $K$ 个元素。具体实现的方法：二分一个数 $o$，找出每一类中不大于它的元素的个数，即可求出 $o$ 在 $B$ 中的位置。

我们现在只知道 $A_1=m$，$st_0=m$，剩下的问题是如何快速求出其他 $st_i$。

考虑这件事情：假设我们有一个集合 $C$，$C$ 中元素为 $D_1,D_2,D_3...D_t$，它满足 $D_1=m$，但不符合题目要求，即它能够线性表示出 $S$，我们把表示 $S$ 的表达式列出来：

$k_1m+\sum_{i=2}^{t}k_iD_i=S,k_i\in N$。

事实上，右边并不一定需要是 $S$，如果右边是 $S-Km$ 的话，也能说明 $C$ 并不符合要求。

更进一步地，若存在 $k_i$ 序列使得 $\sum_{i=2}^{t}k_iD_i = S \mod m$ 且 $\sum_{i=2}^{t}k_iD_i \leq S$，即可说明 $C$ 不符合要求。

所以，记 $P_i$ 表示以当前 $B$ 中元素所能表示出的模 $m$ 余 $i$ 的数中的最小值。初始时，我们先加入一个元素 $A_1=m$，令 $P_0=0,P_i= \text{inf}(i>0)$。

每当我们加入一个 $st_i$ 时，每个 $P_j$ 都有可能被更新。

具体一点，新加入一个数字 $x$ 进入集合中时，对于每个 $i$ ，枚举 $x$ 的出现次数 $w$ ，用 $P_{i-xw \mod m} + xw$ 尝试更新 $P_i$ 。$w$ 最多只需要枚举到 $m-1$ ，因为 $m$ 个 $x$ 可以用 $x$ 个 $m$ 来代替。

最后的问题是：如何决定每次新加入哪个剩余类的数字？

显然我们需要加入能加入的数字中最小的一个。枚举 $st_i$ 仍然为空的所有剩余类 $i$，我们若想保证加入的数字 $qm+i$ 不会使得集合 $B$ 不合法，只需要保证这个数字在线性表示中前面的系数为 $1,2,...m-1$ 时仍然不能与其他 $P_w$ 凑出 $S$ 即可，原理同上，$m$ 个 $qm+i$ 可以替换成 $qm+i$ 个 $m$。用数学语言来说的话，就是 $\forall j\in[1,m-1]$，有 $j(qm+i)+P_{S-ij\mod m}>S$，由此可求出对于每个 $j$ ，$qm+i$ 的最小值，然后在所有 $j$ 中取最大的最小值 $z_i$。最后再找到这一轮更新中 $z_i$ 的最小值并把它加入就行。

这样的话，每次决定新加入的数字消耗 $O(m^2)$ 的复杂度，用其更新 $P$ 消耗 $O(m)$ 的复杂度，总共最多加入 $O(m)$ 次，所以单个测试点复杂度为 $O(m^3)$。

总时间复杂度：$O(T\cdot m^3)$，可以通过。

四、代码

```cpp
#include <bits/stdc++.h>
#define ll long long
const ll inf = 2ll * 1e18;
int T, m;
ll S, K, st[51], p[51];
void add(ll x){
	for(int i = 1; i <= m - 1; ++i){
		if(1ll * i * x > S) break;
		for(int j = 1; j <= m - 1; ++j){
			int tmp = j - i * (int)(x % (1ll * m));
			tmp = (tmp % m + m) % m;
			p[j] = std::min(p[j], p[tmp] + 1ll * i * x);
		}		
	}
	return ;
}
ll fd(ll x){
	ll res = 0ll;
	for(int i = 0; i <= m - 1; ++i)
		if(st[i] <= x)
			res += (x - st[i]) / m + 1ll;
	return res;	
}
signed main(){
	scanf("%d", &T);
	while(T--){
		scanf("%lld%lld", &S, &K);
		for(int i = 2;; ++i) if(S % i) {m = i; break;}
		p[0] = 0ll;
		st[0] = 1ll * m;
		for(ll i = 1; i <= m - 1; ++i) p[i] = st[i] = inf;
		while(true){
			int y = 0; ll z = inf;
			for(int i = 1; i <= m - 1; ++i){
				if(st[i] != inf) continue;
				ll w = 1ll * i;
				for(int j = 1; j <= m - 1; ++j){
					int tmp =(int)(S % (1ll * m)) - j * i;
					tmp = (tmp % m + m) % m;
					if(p[tmp] != inf) 
						w = std::max(w, 
						(S - p[tmp] + 1ll * j) / (1ll * j));
				}
				if(w % (1ll * m) < i) w += 1ll * i - (w % (1ll * m));
				else if(w % (1ll * m) > i) 
					w += 1ll * m + 1ll * i - (w % (1ll * m));
				if(w < z) z = w, y = i;
			}
			if(z == inf) break;
			//printf("y = %d z = %lld\n", y, z);
			st[y] = z;
			add(z);
		}
		ll o = 0ll;
		for(int i = 0; i <= m - 1; ++i) 
			if(st[i] < S)
				o += (S - st[i] - 1ll) / m + 1ll;
		if(K > o) printf("-1\n");
		else {
			ll L = m, R = S - 1ll;
			while(L < R){
				ll mid = L + R >> 1ll;
				if(fd(mid) >= K) R = mid;
				else L = mid + 1ll;
			}
			printf("%lld\n", L);
		}
	}
	return 0;
}
```
