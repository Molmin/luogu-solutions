# 二分

### 前言

推柿子的时候把 $k=i$ 写成 $k=1$ 了，从而推了一下午好不容易找出 $bug$ /ll。

其实这道题貌似比 $E$ 要好想一点，把柿子推出来基本就 $A$ 了。

挂一下我的 [$E$](https://uperficial.blog.luogu.org/solution-cf1490e) 题题解（

题目链接：[$\text{Link}$](https://www.luogu.com.cn/problem/CF1490F)。

### 题意简述

给定长度为 $n$ 的序列 $a$，一次操作可删去序列中一个元素，求要使得序列中所有不同元素出现次数相等的最小操作次数。

### 题目分析

设 $cnt_{i}$ 为序列中 $a_i$ 出现次数，每当删去一个数 $a_i$ 也就会使相应的 $cnt$ 减一。

于是题目就转化成了每次可将 $cnt$ 的某个位置 $-1$，使 $cnt$ 的数量相等，求最小操作次数。

我们假设最终 $cnt$ 的数量都会变成 $R$。

那如果对于一个位置 $i$ 有 $cnt_i<R$ 的话怎么办？

昨晚我在机房讲这道题时有人说 $R$ 不合法。

~~但我觉得这更像是一个脑筋急转弯~~

直接把 $cnt_i$ 删光光不就行了？然后这个数就不在序列中了。

一次操作可以使 $cnt_i$ 减一，把 $cnt_i$ 删光就需要 $cnt_i$ 次操作。

那如果 $cnt_i\ge R$ 呢？那就需要把它删到 $R$，操作次数为 $cnt_i-R$。

很容易想到，假设我们要找出哪些是 $cnt$ 是大于 $R$ 的，哪些 $cnt$ 是小于 $R$ 的，我们事先可将 $cnt$ 从小到大排序。

假设我们找到了一个位置 $i$ 使得 $cnt_i\ge R$ 且 $cnt_{i-1}<R$，那么说明位置 $i-1$ 之前都需要减到 $0$，$i$ 之后需要减到 $R$。

便可得出一个此时操作次数的柿子：
$$
\sum_{k=1}^{i-1}cnt_k+\sum_{k=i}^n \left(cnt_k-R\right)
$$
但是注意，此处的 $n$ 是指 $cnt$ 的数量，并不是原题中的 $n$。

然后把括号拆开：
$$
\sum_{k=1}^{i-1}cnt_k+\sum_{k=i}^ncnt_k-\sum_{k=i}^nR
$$
没错，就是我，在推柿子的时候把最后一个求和的中的 ${k=i}$ 写成了 ${k=1}$（（（

发现前两个可以合并：
$$
\sum_{k=1}^ncnt_k-\sum_{k=i}^nR
$$
现在就变得好办多了，第一项是一个常数项，只需要把 $i$ 给找出来就好了。

经过排序后，$cnt$ 数组已经是**有序的了**。

我们要是想在某个有序数组上 $a$ 上查找一个位置使得 $i$ 使得 $a_i\ge x$ 会用到啥？

二分。

直接 `lower_bound(cnt+1,cnt+1+n,R)-cnt` 就可以得到 $i$ 了。

往原式直接带进去，只不过还要转化成：
$$
\sum_{k=1}^ncnt_k-(n-i+1)R
$$
就完事了，别忘 $R$ 是要枚举的，$cnt$ 数组自己处理就好，剩下的细节看代码吧。

时间复杂度 $O(n\log n)$。

空间复杂度 $O(n)$。

[$AC$ 记录](https://www.luogu.com.cn/record/46939750)

[$code$](https://paste.ubuntu.com/p/phyj3d3xpG/)
$$
\texttt{The End.by UF}
$$
