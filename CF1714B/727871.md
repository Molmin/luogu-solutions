## 简要题意

给出 $t$ 组数据，每组数据当中有一个整数 $n$，以及一个长度为 $n$ 的整数序列，请问至少要从前往后删多少个元素，才能保证序列中剩下的元素互不相同？

## 分析

如果我们完全按照题意，每删掉一个数 $a_i$ 就访问第 $i+1$ 个元素到第 $n$ 个元素，看它门当中有没有相同的元素的话，时间复杂度就会是 $O(n^2)$，花费的时间过长。

但我们可以换一个角度来思考，从第 $n$ 个数开始，从后往前枚举，用一个桶来标记第 $a_i$ 个元素是否有出现过。如果发现第 $i$ 个元素在第 $i+1$ 到第个 $n$ 元素中已经出现过了，则证明删除前 $i$ 个元素能保证序列中剩下的元素互不相同，且删除元素的数量最少，输出 $i$，然后退出循环。如果序列中的每一个元素都互不相同，则在循环结束后输出 $0$。该算法的时间复杂度为 $O(n)$。

程序代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[200010];//用来存储整数序列的数组
bool number[200010];//桶数组
int main()
{
    int t,n,flag;
    scanf("%d",&t);
    while (t--)
    {
        memset(number,0,sizeof(number));//初始化桶数组
        scanf("%d",&n);
        for (int i=1;i<=n;i++)
        {
            scanf("%d",&a[i]);
        }
        flag=0;
        for (int i=n;i>=1;i--)
        {
            if (number[a[i]]==1)//判断这个元素是否有出现过
            {
                printf("%d\n",i);
                flag=1;//表示有需要删除的元素
                break;
            }
            number[a[i]]=1;//标记一下这个元素已经出现过
        }
        if (flag==0)//如果没有需要删除的元素
        {
            printf("0\n");//则输出0
        }
    }
    return 0;
}
```