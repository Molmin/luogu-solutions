### 题意简述

有一个有 $n$ 个数的数组 $a$，求出一个最小的 $i$，使得 $a_i,a_{i+1},...,a_n$ 都互不相同。

### 思路

我们可以从后往前，记录一下 $a_i$ 是第几次出现。比如样例最后一组，原数组为 $[1,2,1,7,1,2,1]$，记录后的数组就是 $[4,2,3,1,2,1,1]$。这时要求所有数都不同，也就是说一个数最多出现一次，就找记录后的数组最长且连续的 $1$ 的后缀就可以了。

### Code

```cpp
#include<bits/stdc++.h>
using namespace std;
int p[200010],q[200010],w[200010];
int main(){
	int n,a,ans;
	scanf("%d",&n);
	while(n--){
		ans=0;
		memset(w,0,sizeof(w));  //记得清空
		scanf("%d",&a);
		for(int i=1;i<=a;i++){
			scanf("%d",&p[i]);
		}
		for(int i=a;i>=1;i--){
			q[i]=++w[p[i]];  //从后往前记录出现次数
		}
		for(int i=1;i<=a;i++){
			if(q[i]>1){
				ans=i;  //找到最后一个大于1的数，它及它前面的所有数都需要删去。
			}
		}
		printf("%d\n",ans);  //如果所有数都只出现了一遍，那么就要输出0，ans初始化为0即可
	}
}
```