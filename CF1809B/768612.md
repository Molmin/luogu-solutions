题目[传送门 1](/problem/CF1809B)，[传送门 2](https://codeforces.com/problemset/problem/1809/B)。

简单题，~~珂以乱搞过~~。

***

## 题意

坐标为 $(x,y)$ 的点的权值为 $\lvert x\rvert+\lvert y\rvert$，$n$ 个点的权值为每个点权值的最大值。现在要将 $n$ 个点放在平面直角坐标系上，使得每个点都是整点，且两点间的欧几里得距离都**严格大于** $1$，求出 $n$ 个点的权值最小多大。

***

## 解法 1：乱搞

~~乱搞是一种做 CF 思维题的好方法！~~

在第四种数据中，输出结果为 $987654321$，非常巧妙的数字。说明什么？出题人可能是先出了输出数据，再据此反推出了输入的 $975461057789971042$。于是，这道题很有可能存在一个 $\operatorname O(1)$ 的通项公式，可以快速算出结果，并根据答案反推输入。

打开计算器，很容易发现：

$$987654321^2+1=975461057789971042$$

即答案为 $\sqrt{n-1}$。

或者：

$$\lfloor\sqrt{975461057789971042}\rfloor=987654321$$

即答案为 $\lfloor\sqrt{n}\rfloor$。

又或者：

$$\lceil\sqrt{975461057789971042}\rceil-1=987654321$$

即答案为 $\lceil\sqrt{n}\rceil-1$。

显然，第一式不一定能得到整数解，由题意知答案为整数，所以是错的。

把其他三组数据带进第二式，发现也有误。

而第三式是都符合的。于是你可以快乐的 AC 这道题。

事实上，经过推导，正确答案也是 $\lceil\sqrt{n}\rceil-1$。

***

## 解法 2：正儿八经做

容易发现，一个点的权值 $\lvert x\rvert+\lvert y\rvert$ 其实就是这个点到坐标原点的曼哈顿距离。

那么题目转化成：求出一个 $d$，使得存在 $n$ 个整点，每个整点到原点的曼哈顿距离不大于 $d$。

考虑**贪心**，点尽可能地靠近原点放。

自己手动模拟几下，可以发现，当 $n$ 为偶完全平方数时，放下的点一定组成一个斜的方阵，那么 $d=\sqrt{n}-1$。

当 $n$ 为其他情况时，放下的点可以看成 $m$ 个点中去掉最外边一些，$d$ 一定是 $\sqrt{m}-1$，其中 $m$ 是大于 $n$ 的最小偶完全平方数。

所以答案为 $\lceil\sqrt{n}\rceil-1$。

***

## 代码

非常短。

```cpp
#include<bits/stdc++.h>
using namespace std;
long long t,n;
signed main(){
	scanf("%lld",&t);
	while(t--){
		scanf("%lld",&n);
		printf("%lld\n",(long long)ceil((long double)sqrtl(n))-1);
	}
	return 0;
}
```

***

全文完。