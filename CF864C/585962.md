这道题是一个模拟题。
# 我们考虑：

如果想让加油的总次数最小，我们就要让每次加油后跑的尽可能远，所以我们能先不加油就先不加油，等到迫不得已再加油，这样加油的总次数就尽可能小了，好像有点像贪心的思路。

我们对于每个来（回）分别考虑加不加油的情况就行了，时间复杂度大约是 $O( k )$ 的。


**~~reader : talks are cheap , show me the code !!!~~**

接下来就是一些边界及细节的处理，详细注释放代码里了。

 _**code:**_ 
 
 ```cpp
#include<bits/stdc++.h>
using namespace std;
int a,b,f,k;
int l,r,y;
int ans;
int main(){
	scanf("%d%d%d%d",&a,&b,&f,&k);
	if(b<f){						//如果到不了加油站，就更到不了终点了，直接-1。
		printf("-1\n");
		return 0;
	}
	l=f,r=a-f,y=b-f;
	//l是从起点到加油站的距离，r是加油站到终点的距离，y表示还剩多少油。
	//我们前面已经确认了从起点能到加油站，所以我们直接默认到了加油站，故y=b-f，接下来对于每个来（回）我们都以加油站为中界点，分别考虑加油和不加油的情况。
	for(int i=1;i<=k-1;i++){
		if(i&1){					//等同于 i%2==1。
			if(y>=2*r) y-=2*r;		//如果剩下的油能从加油站到终点，回来还能到加油站，最优肯定不先加油。
			else{					//不能撑到再回来到加油站，我们就必须加油。
				y=b-2*r;		
				ans++;
				if(y<0){			//加了油都不能撑到再回来到加油站，直接-1。
					printf("-1\n");
					return 0;
				}
			}
		}
		else{						//思路同上
			if(y>=2*l) y-=2*l;
			else{
				y=b-2*l;
				ans++;
				if(y<0){
					printf("-1\n");
					return 0;
				}
			}
		}
	}
	//最后加油站到终点的一小段路我们得拿出来，分别考虑，请读者自己思考。
	if(k&1){
		if(y<r){					//剩下的油不够到终点，就得再加一次油。
			y=b-r;
			ans++;
			if(y<0){				//加了油都不能到终点，直接-1。
				printf("-1\n");
				return 0;
			}
		}
	}
	else{
		if(y<l){					//思路同上。
			y=b-l;
			ans++;
			if(y<0){
				printf("-1\n");
				return 0;
			}
		}
	}
	printf("%d\n",ans);
	return 0;
}
```

最后提几个可能错的点吧：

- 循环要写循环到 ```k-1``` ，因为最后一个来（回）的加油站到终点的一小段路我们得拿出来，分别考虑。

- 记得分清 $l$ 和 $r$ 。

[完结撒花！！！](https://www.luogu.com.cn/record/76314151)
