## 耶耶耶！终于AC了一道省选题目耶！开心！  
## （然而并没有什么用）  
***********
下面进入正题。。  
相信大家应该都能想到动态规划的计算方向吧：将点按照高度升序排序，再按照排序结果进行计算。因为只有这样，才能保证状态转移时前面的状态都已经计算过了。  
那么本题解存在的意义是什么呢？？？  
答案是：**讲一个个人觉得很interesting的小技巧(huá jī)。**  
## 技巧(huá  jī)：二维压一维。
不知道大家想到上面的计算方向以后，有没有跟我当初一样，为排序而发愁呢？  
STL的sort函数要求传入一个连续的内存区间，但是数组开成二维以后，却难以保证想要排序的区域是连续的。也就是说
```cpp
	sort(a+1, a+r*c+1);
```
会哇（*WA*）。怎么办呢？？？  
答案是：把数组开成**一维**的！  
对于这样的一个$5 \times 5$格子

|     |  1  |  2  |  3  |  4  |  5  |  
|:---:|:---:|:---:|:---:|:---:|:---:|
|1   |      |      |      |     |  |
|2   |      |      |      |     |  |
|3   |      |      |      |     |  |
|4   |      |      |      |     |  |
|5   |      |      |      |     |  |

对它的每个格子进行编号，使每个格子的编号唯一。相信最简单的方法应该就是这样了吧：  

|     |  1  |  2  |  3  |  4  |  5  |
|:---:|:---:|:---:|:---:|:---:|:---:|
|1   |  1  |  2  |   3 |  4  |  5  |
|2   |  6  |   7 |    8|   9|  10|
|3   |  11| 12 |  13| 14 | 15 |
|4   |  16| 17 | 18 | 19 |  20|
|5   | 21 |  22|23  | 24| 25|
那么，按照这种思路，题目样例就可以被存成这样：  

|  $i$  |  1 | 2|3|4|5|6|7|8|9|10|11|12|13|14|15|16|17|18|19|20|21|22|23|24|25|
|:------:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
|$a_i$|1|2|3|4|5|16|17|18|19|6|15|24|25|20|7|14|23|22|21|8|13|12|11|10|9|
可是，向上下左右格子的编号又分别是什么呢？？  
由**观察法**易得：  
设格子一共有$R$行$C$列，当前已知的格子编号是$X$，那么其周边的格子编号如下（**不考虑边界**）:  

| $X-C-1$ | $X-C$ | $X-C+1$ |  
| :----------: | :----------: | :----------: |  
|  $X-1$  |   $X$   |  $X+1$ |
| $X+C-1$ | $X+C$ | $X+C+1$ |  
可是问题来了：**如何考虑边界？？？**  
很简单：
* 当且仅当$X-C \leq 0$时，$X$位于最上一行；
* 当且仅当$X+C > R \times C$时，$X$位于最下一行；
* 当且仅当$X mod C = 0$时，$X$位于最右一行；
* 当且仅当$(X-1) mod C = 0$时，$X$位于最左一行。 
 
这样，排序的问题也就“顺带着”解决了。  
顺便讲一下，为了避免排序时打乱点的相对位置，这里使用间接排序：使用另一个数组保存点编号，对这个数组进行排序。  
核心代码如下：  
```cpp
    for(int i = 1; i <= len; ++i) s[i]=i;//点序号
    for(int i = 0; i < r; ++i)
    for(int j = 1; j <= c; ++j)
        cin>>a[i*c+j];
    sort(s+1, s+1+len, cmp);//间接排序
    for(int i = 1; i <= len; ++i){//DP
        dp[s[i]] = 1;
        if(s[i]-c>0&&a[s[i]]>a[s[i]-c]) dp[s[i]] = max(dp[s[i]], dp[s[i]-c]+1);
        if((s[i]-1)%c&&a[s[i]]>a[s[i]-1]) dp[s[i]] = max(dp[s[i]], dp[s[i]-1]+1);
        if(s[i]%c&&a[s[i]]>a[s[i]+1]) dp[s[i]] = max(dp[s[i]], dp[s[i]+1]+1);
        if(s[i]+c<=len&&a[s[i]]>a[s[i]+c]) dp[s[i]] = max(dp[s[i]], dp[s[i]+c]+1);
    }
```
其中cmp函数定义如下：
```cpp
bool cmp(int x, int y){
    if(a[x] < a[y]) return true;
    return false;
}
```