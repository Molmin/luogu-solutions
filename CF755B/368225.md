## CF755B 【PolandBall and Game】

#### 题意：

两个人玩游戏，他们各知道一些单词，每轮他们分别说出自己会的一个单词，不能重复，求先手是否有必胜策略。

两个人都非常聪明。

个人认为原题目中


Note that one Ball cannot know a word more than once (strings are unique), but some words can be known by both players.


是非常重要的，因为这说明同一个人会的单词输入中不会重复。

#### 分析：

两个人都会先说出对方知道自己也知道的单词，这样可以减少对方的词汇量。

首先先手词汇量不能少于后手。

否则在两人说完共同掌握的词汇后，先手词汇量就会占劣势。

举例证明：

先手词汇量$6$，后手$7$，设两人共同掌握四个单词。

则两回合后，先手还剩两个，后手还剩三个，此时轮到先手，必败。

设两人共同掌握三个单词。

一个半会合后，先手还剩三个单词，后手还剩四个，此时轮到后手，必败。

其次，当两人的总词汇量相等时，考虑共同掌握的单词的奇偶。

举例证明：

先手后手掌握八个单词。

共同掌握$4$个单词。

两回合后后两人剩余词汇相等，轮到先手，必败。

共同掌握$3$个单词。

（还是按奇偶分类举例）

一个半会合后两人剩余词汇相等，轮到后手，必胜。

看懂了吗？

这其实是一个先后手转移的过程，若干会合后，两人词汇量必定相等且没有重复。

这是胜负取决于这时轮到先手还是后手，显然，轮到谁谁输。

###### 本段总结

设先手会$m$个单词，后手$n$个，共同的有$k$个。

先手胜：

$m>n$||$m=n$&&$k%2==1$。

#### 代码部分 丑陋的代码

```cpp
#include<bits/stdc++.h>
#define F(i,j,r) for(int i=j;i<=r;++i)

using namespace std;
const int N=1e5+5;

int n,m,tot=0;
string a[N],x;
map < string , int > mp;
int main(){
	scanf("%d%d",&n,&m);
	F(i,1,n)
		cin>>a[i];
	F(i,1,m){
		cin>>x;
		mp[x]=1;
	}
	F(i,1,n)
		tot+=mp[a[i]];
	puts((m>n||(m==n&&tot%2==0))?"NO":"YES");
    return 0;
}

```

注释就不写了，关于字符串的储存我们使用了$map$。最后判定并输出。

$wtrl$。
