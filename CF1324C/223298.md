### 题目翻译

现在有$n+2$个格子，青蛙在 0号格子上，第1到第n个格子都有一个字符$s_i$，青蛙可以在跳之前选择一个d (不能改变)，然后从0号格子向右跳最多d个，当他在1到n号格子时，如果$s_i$为 'L'，则可以向左最多跳d个，如果$s_i$为'R'，则可以向右跳最多d个。

请你确定一个最小的d，使得青蛙能够从0号格子跳到$n+1$号格子

#### 输入格式

第一行一个整数T，表示T组数据

接下来T行，一个字符串s

#### 输出格式

T行 表示每组数据最大的d

### 题目分析

考虑贪心。

首先我们可以把0号格子看做一个'R'，因为它只能往右跳。

想要使d尽量小，我们每次跳跃就要尽量小，那么如果我们想要跳到一个'R'，从它往左边最近的那个'R'跳过来肯定是最优的。对于终点，从终点往左边最近，也就是最靠右的'R'跳过来肯定是最优的。

所以我们只需要记录每个'R'之间距离最长的即可。

### Code:

```cpp
#include<iostream>
#include<cstdio>
#include<string>
#include<cstring>
using namespace std;
int n,T,last,ans;
char ch[200001];
int main()
{
	scanf("%d",&T);
	while(T--){
		scanf("%s",ch+1);//从下标1开始读 
		last=0;
		//last代表的是上一个'R'出现的位置，这里我们把0号格子也看做'R' 
		ans=0;//答案 
		ch[0]='R';
		n=strlen(ch);//n就是字符串的长度
		for(int i=1;i<=n;i++)
		{
			if(ch[i]=='R')//如果遇到'R'，就要重新判断是否要更新答案 
			{
				ans=max(ans,i-last);//即答案为最大的 两个 'R'的距离 ” 
				last=i;
			}
		}
		ans=max(ans,n-last);//从最后一个'R'跳到n+1号格子 
		printf("%d\n",ans);
	}
	return 0;
}
```
