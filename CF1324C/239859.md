## 题目大意
   一只青蛙要从0跳到n+1格，第一次往右跳，它每次最多可以跳d格，如果脚下是“L”，则可以跳到[max(0,i−d);i−1],如果是“R”则可以跳到 [i+1;min(n+1;i+d)]，求最小的d。

## 题目分析
   这是Div.3的c题，挺水的。吐槽一句：样例解释什么鬼啊，真是完美误导。如果我们落在一个“L”上就要往左跳，往左跳肯定是到不了终点的，怎么办呢？就要再跳到“R”上。结果绕了一圈又回来了，我们发现：
## 落在“L”上没有任何意义!
   知道了这一点后我们只需要让青蛙每一步落在右侧里最近的“R”就可以保证ｄ最小，因为两个“R”中不管怎么跳都会跳出两格的距离一步。所以我们只需要设maxn这一个变量来不断更新青蛙跳的最大距离就可以了。

所以，我们可以得出代码：
```
#include<cstdio>
#include<iostream>
using namespace std;
int main()
{
	int t,i,j;
	scanf("%d",&t);
	for(i=1;i<=t;++i)
	{
		int len,maxn=0,v=-1;//v是用来记录前面一个"R"的 ,因为s第一个字符的下标为0，所以v设成-1 
		string s;
		cin>>s;//读入字符串s 
		len=s.length();
		s[len]='R';//设终点为"R" 
		for(j=0;j<=len;++j)
		{
			if(s[j]=='R')
			{
				if(maxn<j-v)
				maxn=j-v;
				v=j;
			}
		}
		printf("%d\n",maxn);
	}
	return 0;
}
```
