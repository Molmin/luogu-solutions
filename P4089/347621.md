#### 题目：
[P4089](https://www.luogu.com.cn/problem/P4089)
#### 分析：
最开始想到的算法肯定是暴力，但一看数据范围 $1 \le N \le 10^5$，肯定超时。考虑把牛之间的位置关系看成一张有向图，把每一个位置看成一个点，把 $a_i$ 看成从 $i$ 到 $a_i$ 的一条有向边。对于每一个点，如果它的入度为 $0$，也就是说没有牛会转移到这个点上，那么这个位置上下一次 ```shuffle``` 必然不会有牛。如果连接到某个点的所有点在经过一定次数的 ```shuffle``` 过后都会被空置，那么这个点未来也一定会被空置。是不是有点绕？看下面这个例子：         
这是一组样例：
```
6
6 1 1 2 2 3
```
表示在图上就是这样：
![](https://cdn.luogu.com.cn/upload/image_hosting/xf89rwu7.png)
$4$、$5$ 两头牛所在的点的入度为零，一轮过后就空了，那么图就变成了这样：
![](https://cdn.luogu.com.cn/upload/image_hosting/1aki2oou.png)
$4$、$5$ 两头牛此时所在的点虽然开始时入度不为 $0$，但连接到它的所有点在经过一次的 ```shuffle``` 过后都被空置了，因此此时它的入度也变成了 $0$，下一轮过后就空了，如图：
![](https://cdn.luogu.com.cn/upload/image_hosting/r4a0vsfm.png)
而右侧的三个点形成了一个环，入度一直大于 $0$，上面一直有牛，所以这组样例的答案就是 $3$。         
经过一次模拟，我们得出了一个结论：如果一个点上永久存在牛，那么这个点满足所有指向它的点中，至少有一个点上永久存在牛。换句话来说，就是这个点处在一个环中。       
所以，问题就转换成了求出处在环之中的点的个数，一个简单的拓扑排序判断环就可以搞定。有不懂拓扑排序的同学可以看其他几篇题解，我就不过多阐述了。
#### 代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,x;
int ans;
int a[500000];
int s[500000];
queue<int> q;
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
    {
    	scanf("%d",&a[i]);
    	s[a[i]]++;    //计算入度
	}
	for(int i=1;i<=n;i++)
	    if(!s[i]) q.push(i);     //先把入度为0的节点放入队列
	while(!q.empty())
	{
		x=q.front();        //从队列中取出一个节点
		q.pop();
	    if(s[a[x]]>0)
	    {
	    	s[a[x]]--;        //将这个节点指向的节点入度减一
	    	if(!s[a[x]]) q.push(a[x]);  //如果入度变为零，放入队列
		}
	}
	for(int i=1;i<=n;i++)
		if(s[i])
			ans++;      //统计入度不为0的点数（也就是处在环中的点的个数）
	printf("%d\n",ans);			
	return 0;
}
```