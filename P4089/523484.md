~~惊奇地发现这题居然还能提交题解。。~~

1. 题意： $n$ 头奶牛，开始时第 $i$ 头站在 $i$ 位置，随后每次变换站在 $i$ 位置上的奶牛会换到 $a_i$ 的位置。问的是对于所有的 $i \in n$，有多少个位置始终有奶牛。

2. 思路：如果考虑用图的方式来存，那么这个图是个有向图，且每个点 $u$ **有且仅有 $1$ 个后代** $v$ ，即指向 $v$ 。我们发现，如果图中存在环，则在环上每个点的奶牛怎么也拐不出去，就会出现情况：环上的每个点总是有奶牛的。答案即是所有环上点的个数。这个过程可以用拓扑排序来解决，看到已经有很多拓扑的题解了，在这里就介绍一下环套树的做法。

3. 算法：先建立一个数组 pre ，用来记录每个点被访问的时间戳，即 Dt (Dfstime) 。每次访问到一个点时， ++Dt ，并把 pre 里点的位置设为 Dt 。这样访问过的点就都有值，反之没有被访问过的点就没有值。当在 dfs 的时发现他的子节点已经被访问过了，则说明出现环了。现在的点 $u$ 到子节点 $v$ 的边 $(u,v)$ ，环上点的个数就是 $pre_u-pre_v+1$ 。把所有环的结果加起来就是答案。

4. 代码：先循环遍历每一个点，如果这个点的 $pre_i$ 值为 $0$ ，就开始一次新的遍历。由于每次遍历颜色要不同，遍历前要把颜色加 $1$ 。 dfs 的时候把点的时间戳和颜色标好。如果后代节点未被遍历，递归遍历；反之判断如果当前节点的颜色和子节点的颜色相同，说明两个点在一个环上，就累计答案。

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int n,Dt=0,Dc=0,ans=0;
int nxt[100001],pre[100001],clr[100001];
void dfs(int now){
	pre[now]=++Dt,clr[now]=Dc;
	if(pre[nxt[now]]==0){
		dfs(nxt[now]);
	}
	else if(clr[now]==clr[nxt[now]]){
		ans+=pre[now]-pre[nxt[now]]+1;
	}
}
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		scanf("%d",&nxt[i]);
	}
	for(int i=1;i<=n;i++){
		if(pre[i]==0){
			Dc++,dfs(i);//一定要注意是每次染色后 Dc++ ，而不是找到环后 Dc++ 
		}
	}
	printf("%d\n",ans);
	return 0;
}
```