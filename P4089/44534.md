看题，可以想象成是有N个点，每个点的出度都为1(可能有自环?)，每个节点开始都有1只(头?)牛，每回合每个节点上**所有**的牛都沿着该节点**唯一的出边**走向~~死亡~~下一个节点，求该图中无论过了几回合后都一直拥有至少1只牛。

该图中**所有的环的长度之和**即为答案。

分析：首先我们来想一下为什么答案不会是0。如果答案为0，就意味着每个节点都在某个(不同)回合没有了牛。因为所有节点的出度都=1，所以从节点A到节点B的路(无论是直接还是间接)**有且仅有一条**，并且节点A在**最多一个环**中。所以如果节点A一旦失去了所有的牛，那么就再也不会有任何的牛到达节点A。

举一个例子。设想节点A。如果想要A失去所有牛之后再获得牛，那么我们可以知道至少有一个节点(记为B)有一条到A的有向边(记为B->A)。因为我们需要让A先失去牛，所以当A有牛时，B必然没有牛(因为B不能再向其他节点连边)，而下一个回合，A失去牛之后，B又要拥有牛。回到初始状态，**所有节点都有一只牛**，因此不会出现A(或B)先失去牛又获得牛的情况。

那么现在知道了如果节点A一直都拥有牛，那么A必定在一个环内。

所以，对于该有向图，只要去除所有不在环内的点，然后判环出答案就可以了。
Main Code:
```cpp
int n,to[200005],id[200005],ans=0;
bool inring[200005],useless[200005];
int dfs(int now)
{
    if(inring[now])return 0;
    inring[now]=1;
    return dfs(to[now])+1;
}
void dfs2(int now)
{
    useless[now]=1;
    --id[to[now]];
    if(!id[to[now]])dfs2(to[now]);
}
int main()
{
    int a;
    cin>>n;for(int i=1;i<=n;++i){cin>>a;to[i]=a;++id[a];}
    for(int i=1;i<=n;++i)if(!id[i]&&!useless[i])dfs2(i);
    for(int i=1;i<=n;++i)if(!inring[i]&&!useless[i])ans+=dfs(i);
    cout<<ans<<endl;
    return 0;
}
//将该代码小改后可以A掉NOIP2015的“信息传递”(P2661)
```