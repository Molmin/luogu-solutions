[题面传送门](https://www.luogu.com.cn/problem/P2255)

这题是一道**区间贪心**。

一般的区间贪心题是给你 $N$ 个区间，你的任务是尽量让更多的区间两两**不重合**。

对于一般的区间问题，我们要把每个区间的**右端点**从小到大排序，再按排好序的顺序来处理，因为这样可以使每个任务结束时间更早，以便安排下一个区间。

一般的区间贪心题有[自私的放牧](https://www.luogu.com.cn/problem/P2970)和[线段覆盖](https://www.luogu.com.cn/problem/P1803)。（~~其实是一模一样的题目，你交同一份代码都能AC，暗示着双倍经验~~）

接下来看这道题，这道题与一般的区间贪心的**唯一**区别是约翰的录音机非常神奇，可以同时记录两个节目。（~~两个节目的声音互相干扰真不知道约翰怎么录的~~）于是我们可以看做约翰有两个录音机，每一个都可以单独记录节目。我们每次处理节目，要尽量让每个录音机的空闲时间少，再按普通区间贪心的做法来解决。

了解完思路后，我们可以开一个结构体，分别存储每个任务的开始和结束时间，这里 $s$ 表示开始时间，$e$ 表示结束时间。

```cpp
struct cow
{
  int s,e;
};
```

然后我们要写比较函数，按**右端点**也就是**结束时间**排序。


```cpp
int cmp(cow a,cow b)
{
  if(a.e<b.e)
    return 1;
  return 0;
}
```


接下来我们读入 $n$，在 $main$ 函数里定义有 $n$ 个元素的动态结构体数组。（~~不直接开普通数组的原因是我不想看数据范围~~）


```cpp
  cin>>n;
  cow a[n+1];
```


定义完之后，就是读入和排序。


```cpp
for(int i=1; i<=n; i++)
    cin>>a[i].s>>a[i].e;//输入 
  sort(a+1,a+n+1,cmp);//按cmp也就是比较函数排序
```


我们可以定义 $p1$ 和 $p2$ 分别作为录音机1和录音机2处理任务的结束时间，然后按顺序处理，并让每个录音机空闲时间尽量少。
```cpp
int p1=0,p2=0;//开始时两个录音机的处理任务的结束时间都是0 
  for(int i=1; i<=n; i++)
  {
    if(a[i].s>=p1/*假如能处理*/&&p1>p2/*这样写是让录音机空闲时间尽量少*/||(a[i].s>=p1&&a[i].s<p2)/*或者录音机2不能处理*/)
    {
      c++;//答案加一 
      p1=a[i].e;//更新录音机1的结束时间 
    }
    else if(a[i].s>=p2)//如果录音机1没有处理录音机2又能处理就让录音机2处理 
    {
      c++;//答案加一 
      p2=a[i].e;//更新录音机2的结束时间
    }
  }
```
最后输出答案就行啦！~\(≧▽≦)/~