## 题意
给定长度为 $n$ 的数组 $a$，可以选择一段连续子串**向前**复制,使得数组中所有数相等。求最少操作次数。（题意仅供回忆原题，具体请看[原题](https://www.luogu.com.cn/problem/CF1631B)）

## 解法
由于只能向前复制，那么要使数组中所有数相等，只能让它们都变成最后一个数。考虑使用指针模拟复制操作，每次尽可能从后往前选择相同的数向前复制。

需要注意的是进行操作后要再次往前找相同的数再进行操作。

## 代码
为了方便，本蒟蒻将原数组颠倒过来从前往后操作，思考难度更小。具体细节见注释。
```cpp
#define REP(i,a,n) for(int i=(a);i<(n);i++)
...
int n;
int a[200005];
int ans;
void Main() {
	cin>>n;
	ans=0;
	REP(i,0,n)cin>>a[n-i-1]; //反过来输入。注意i从0开始。
	int x=0;
	for(;x<n-1&&a[1+x]==a[0];x++);  //第一次找最后一个连续的与第一个数相同的数
	while(x<n-1){
		x=x*2+1;
//x下标从0开始，复制（*2）使注意先还原成起始下标为1的数，操作后再还原：x=(x+1)*2-1=x*2+1
		ans++;
		while(x<n-1&&a[1+x]==a[0])x++;
	}
	cout<<ans<<endl;
}
```