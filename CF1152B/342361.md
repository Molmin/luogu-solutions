### 1.题意
给定一个数 $n$，给你两种操作 ：  
1. $n=n⊕(2^k-1)$ 
2. $n+1$

求将 $n$ 变为 $2^k-1$ 要多少步，并且对于 1 操作需要输出每次 $k$ 的值。操作顺序为：12121212......

### 2.分析
首先我们来重点分析操作 1，我们发现所有的 $2^k-1$ 在二进制下每一位都是 $1$。所以现在我们只剩下异或没有解决了。异或的运算法则就是在二进制里，相同的位上的数不同为 $1$，相同为 $0$。因为 $n$ 异或的数的每一位全是 $1$。而且题目要我们求的东西是 $2^k-1$。这个数的二进制每一位也都是 $1$，所以我们要达成这个目的就必须让一次异或得尽量多，将更多的 $0$ 变成 $1$。又因为异或的数的每一位都是 $1$，所以我们每次从 $n$ 当前的值的二进制的第一个 $0$ 开始，因为这个 $0$ 前面肯定没有更多的 $0$ 了，所以一次变出的 $1$ 肯定是最多的。  
那么剩下的 $1$ 变成了 $0$ 怎么办呢？  
其实不用担心这个问题，因为就算你不把最高位的 $0$ 变成 $1$，你到了后面还是要用 $+1$ 的操作慢慢地将它变成 $1$ (因为最后的目标是二进制全变为 $1$)，这样反而会更费次数。

所以现在我们来用这个方法模拟一下样例，再次检测一下咱们的方法正不正确：  
首先 $39$ 转成二进制是这样的，$100111$  
然后我们进行第一次异或操作 $111000$，此时 $k=5$   
然后 $+1$，$111001$  
再异或，$111110$ 此时 $k=3$  
最后 $+1$，$111111$ 成功！

既然思路有了，接下来就是代码实现了。

### 3.代码实现
```cpp
# include <bits/stdc++.h>
using namespace std;
bool erjinzhi[1000000];     //用来存每次n的二进制 
bool s[1000000];    //将二进制倒过来 
int ans[100];   //储存每次异或操作的k 
int tme = 0;   //见check函数 
bool check(int x)
{
	int rmp = 1;
	while (rmp <= 10000000)
	{
		if (x == rmp) return true;
		rmp *= 2;
		tme++;
	}
	return false;
}
int main()
{
	int n;
	cin >> n; //输入 
	int tmp = 1;  //记录操作次数 
	int poo = 1; //记录多少次异或操作，便于输出ans数组 
	for (int jj = 1; jj <= 41; jj++)   //最多40次操作 
	{
		memset(erjinzhi, 0, sizeof(erjinzhi));  //每次算二进制前清零 
		memset(s, 0, sizeof(s));
		int p = 1;     //二进制数组下标 
		int tishen = n;   //动态模拟改变n 
		while (1)     //十进制转二进制 
		{
			if (tishen / 2 > 0)
			{
				erjinzhi[p] = tishen % 2;
				tishen /= 2;
				p++;
				continue;
			}
			else if (tishen > 0)
			{
				erjinzhi[p] = tishen % 2;
				tishen /= 2;
				p++;
				continue;
			}
			break;
		}
		int m = 1;
		for (int i = p - 1; i >= 1; i--)     //将倒着存的二进制正过来 
		{
			s[m] = erjinzhi[i];
			m++;
		}
		int pos = 0;
		for (int i = 1; i < m; i++)  //寻找第一个0 
		{
			if (s[i] == 0)
			{
				pos = i;
				break;
			}
		}
		if (pos == 0) break; //如果发现达成全为1的情况，即完成了 
		int k = m - pos;     //计算k，异或到0这一位 
		if (check(n + 1)) break;   //如果满足就不需要再进行操作了 
		n ^= (1 << k) - 1;  //进行异或操作 
		ans[poo] = k;  //记录k 
		poo++;
		tmp++;  //增加次数 
		if (check(n + 1))     //如果不需要++了 
		{
			break;
		}
		n++;  //操作2 
		tmp++;
		if (check(n + 1))   //如果不要进行下一次异或了 
		{
			break;
		}
	}
	tmp--;      //因为退出的时候发现tmp多加了下一步不必要的操作 
	cout << tmp << endl;
	for (int i = 1; i < poo; i++)
	{
		cout << ans[i] << " ";
	}
	cout << endl;
	return 0;
}
```
谢谢观赏