### 2 pts 

复制样例 $2$ 输出谁不会嘞！

### 2 pts ~ 68 pts

先想想如果只有 $1$ 、 $2$ 操作该怎么办

很容易想到不可能每次都对每一个 $x$ 的倍数进行贡献，遇到那些小一点的 $x$ 就挂了。

所以我们从询问入手，把每一次 $1$ 操作的值存放到 $b$ 数组中。众所周知可以每次 $\sqrt{n}$ 获得因数的贡献。当然，也可以 $\sigma_0(n)$ 查找，除去了一些非因数的冗余操作。由于 $n \le 10^5$ ，可以得知 $\sigma_0(n) \le 128$ , 而 $\sqrt{n} \le 316$ ，因而也算是一个较好的常数优化。 

$\sqrt{n}$ 询问 :

```
for(int i = 1; i <= sqrt(x); i++){
		if(x % i == 0){
			if(i * i == x) ans += b[i];
			else ans += b[i] + b[x/i];
		}
	}
```

$\sigma_0(n)$ 询问我用的是递归：

```
inline void pre(){//预处理出所有数的一个质因数
	for(int i = 2; i <= n; i++){
		if(!vis[i]) prime[++cnt] = i, m_prime[i] = i;
		for(int j = 1; prime[j] * i <= n; j++){
			vis[prime[j] * i] = 1;
			m_prime[prime[j] * i] = m_prime[i];
			if(i % prime[j] == 0) break;
		}
	}
}

inline void get_prime(int p){//找出这个数的因数及其指数
	top = 0;
	while(p != 1){
		que[++top] = m_prime[p];
		num[top] = 0;
		int w = m_prime[p];
		while(p % w == 0){
			p /= w;
			num[top]++;
		}
	}
	ans = 0;
	dfs(1, 1);
}

inline void dfs(int p, int now){//然后枚举每一个质因子的指数，获得所有因数，并对答案做出贡献
	if(p == top + 1){
		ans += b[now];
		return ; 
	}
	int w = 1;
	for(int j = 0; j <= num[p]; j++){
		dfs(p + 1, now * w);
		w *= que[p];
	}
}

```
然鹅题目并没有只有 $1$、$2$ 操作的点，所以还是只能获得 $2$ 分的好成绩。

如果再加上 $3$ 操作，通法常法是~~直接调用~~

如果再加上 $4$ 操作，通法常法是~~直接调用~~

如果真就这么做，可以获得 $58$ pts 的好成绩。

想想对于 $4$ 操作的一个小优化，我们可以通过路径压缩避免了过多的重复调用，这样就多了 $10$ pts 了。

### 100 pts

## 解题关键是 3 、4 操作区间不重合

想想 **异或** 有什么性质

对于两个数 $x$ 、$y$ , $x \oplus y \oplus y = x$ ，这是显而易见的。

所以，对于所有的 $3$ 操作，我们只需要从 $u - 1$ 处继承状态，将 $u \rightarrow v$ 所有操作忽略，再将 $v + 1 \rightarrow i - 1$ 所有 $1$ 操作执行一遍即可。因而我们想到用可持久化线段树保存每一个状态的 $b_i$，并在其上进行各种操作即可。由于区间不重合，每个 $1$ 操作只会因此调用 $1$ 次，可以证明其复杂度为 $O(m\times log_n)$。

接下来只需要考虑调用 $3$ 操作的 $4$ 操作即可。显然我们不可以从 最终调用点开始进行类似上述操作，但是我们可以想到， 对于 $x$ 、$y$ , $x \oplus y \oplus y … \oplus y$ ，我们显然只需要找到上一个 $\oplus y$ 之前的位置，与当前 $\oplus y$ 抵消影响即可，所以我们又得用 $nxt$ 数组保存调用当前 $3$ 操作的最后一个操作编号，初始值为原本 $3$ 操作的编号。同理可证其复杂度为 $O(m\times log_n)$。

因为使用了线段树，询问的复杂度多了一个 $log_n$ ，故该解法复杂度为 $O(m \times \sigma_0(n) \times log_n)$ ，约为 $3\times10^5 \times 128 \times 17 = 6 \times 10^8 $ ，极限数据为先对每个位置进行 1 操作，再询问范围内因数最多的数的值，约为 $4 \times 10^8 $ ，故最大时限设为 2.5 s ，并开启 O2 ，为 std 的 1.5 倍。如果单纯 $\sqrt{n}$ 找因数，会比较慢一些。

#### UPdate: 人人吊踩std !
#### Update: 由于样例是手造的，所以疏忽了题目的限制了呜呜，谢罪(T﹏T)ノ｜！