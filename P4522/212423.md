### 前言：
考试这道题寄了。
### 思路：
这道题就是一个 ~~很简单的~~ DP，第一眼看题目感觉像博弈论，但蒟蒻不会，所以就想到了 DP，很容易便推出了状态转移方程：$dp \left[i\right]\left[j\right]$ 表示第 $i$ 只羊时还剩下 $j$ 颗石子可取，它的值表示此时的状态是最后哪一种羊胜利，很容易可以想到，当还剩下一颗石子时此时将要取的那一只羊必败，所以我们就可以利用这个性质来进行初始化，当然，如果之后连续的一段羊全都是同一种类的，那么，如果现在的这一只羊与之后的羊种类都不同，它肯定是必败的（这里后面可以优化），反之，如果后面的状态有羊和此时的羊种类相同，那么就可以胜利。
### 优化：
当然，以上算法的时间复杂度是 $O(nmk)$，要炸，所以我们可以用一个数组来存 $dp$ 数组的前缀和，如果一段的和为零，那么这一段一定全都是零，反之，如果它的和和此时的长度相等，那么这一段一定全都是一,所以我们就可以利用这个性质来判断每一只羊之后的所有状态是否为必败或者可以通过状态转移到胜利。
### Code：
```cpp
#include<bits/stdc++.h>
using namespace std;
int m,k,nxt[100005],sum[5005][5005],n;
bool a[100005],dep[5005][5005];
int main(){
	//freopen("kami.in","r",stdin);
	//freopen("kami.out","w",stdout);
	cin>>n>>m>>k;
	for(int i=0;i<n;i++){
		cin>>a[i];
		nxt[i]=(i+1)%n;
		dep[i][1]=!a[i];
		sum[i][1]=dep[i][1];
	} 
	for(int i=2;i<=m;i++){
		for(int j=0;j<n;j++){
			if(sum[nxt[j]][i-1]-sum[nxt[j]][max(0,i-k-1)]!=(a[j]^1)*min(i-1,k))dep[j][i]=a[j];
			else dep[j][i]=!a[j];
			sum[j][i]=sum[j][i-1]+dep[j][i];
		}
	}
	for(int i=0;i<n;i++){
		cout<<dep[i][m]<<" ";
	}
}
```
