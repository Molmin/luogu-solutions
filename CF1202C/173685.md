[CF1202C You Are Given a WASD-string...](https://www.luogu.com.cn/problem/CF1202C)

给定一个长度为 $n$ 的 `WASD` 组成的移动序列，四个字母分别对应在方格纸上向上左下右走一格，定义权值为最小的能包含所有被经过的格子的矩形的面积，求至多在序列任意位置插入任意一个上述移动后能达到的最小权值。

$1\leq n\leq 2\times 10^5$。

首先发现横纵坐标是独立的，假设原本移动序列的权值为 $a\times b$，则猜想答案会是 $\min\{(a-1)\times b,a\times (b-1)\}$，即插入的操作使得长的那边退回来一步，但是考虑这样一个操作序列 `ADAD` 原本是 $1\times 2$，但任意添加操作之后并不能让权值变为 $0\times 2$，甚至不能变为 $1\times 1$，这启发我们更深入地思考。

我们把问题转化为分别检查 $a,b$ 是否能减一，因为减一就是最大可能的贡献，即得到了一个 `+1/-1` 序列，将其做前缀和，贡献就是前缀和的 $\max-\min+1$，问是否能在其中插入一个 `+1/-1` 使得这个贡献减一，也就是将其前缀和数组的一个后缀 `+1/-1`。

不难发现，若这个后缀中同时存在最大值和最小值，那么显然是不行的，因为它们同时改变是不会贡献的；若这个后缀以外的前缀中同时存在最大值和最小值，那么也是不行的，因为它们根本就没有受到影响。所以我们需要找到这样一个位置，使得它能够把最大值出现的位置和最小值出现的位置分开，即最大值只出现在这个位置之前，最小值只出现在这个位置之后或者反过来，那么我们就可以在这里插入一个操作使得贡献减一。

特殊的是，若出现了分割点是最值，分割点的前一个位置是另一种最值，即序列的前缀和在 `0,-1` 或是 `0,1` 之间横跳，也是不行的，所以实现上我们只需要检查最后一个最大值的位置加一是否小于第一个最小值的位置，或者反过来。

于是就 $a,b$ 分开检查再最和计算答案，时间复杂度 $O(n)$，[一份参考代码实现](https://www.luogu.com.cn/paste/nvseqyrl)。