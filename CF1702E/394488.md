题目链接[（CF](https://codeforces.com/problemset/problem/1702/E)，[洛谷）](https://www.luogu.com.cn/problem/CF1702E) | 强烈推荐[博客](https://ttzytt.com/2022/07/CF1702/)中观看。
## 题意
给你 $n$ （$n$ 为偶数，$2 \le 2 \cdot 10^5$）个，数对。数对中的每个数字都是从 $1$ 到 $n$ 的。

现在问你是否能将这些数对分到两个集合中。使得每个集合中没有任何一个重复的数字。

比如有下面这四个数对：$\{1, 4\}, \{1, 3\}, \{3, 2\}, \{4, 2\}$。

那么可以这样分配这些数对：
- 第一个集合包含数对 $\{1, 4\}$ 和 $\{3, 2\}$。第二个包含 $\{1, 3\}$ 和 $\{4, 2\}$。

## 思路
看起来是个贪心，能放一个集合的就放，不能就放另一个，另一个还不行就输出 $\texttt{NO}$ ，但毕竟是个 E 题，所以没那么简单。（~~别学我直接交了个贪心上去，还半天都想不明白为什么错~~）。

要证明这个贪心是错的，只需要举一个反例，顺便吐槽一下，这个题的样例还是挺坑的，你用贪心完全能过。

比如给你下面这样一个数据：
```
6
1 2    
5 4
2 3 
4 3  
5 6
6 1
```

如果我们用贪心做，设第一个集合为 $A$，第二个为 $B$，就可以把前两个，也就是 $\{1, 2\}$ 和 $\{5, 4\}$ 放到 $A$ 中。到第三个，就会发现 $\{2, 3\}$ 中的 $2$ 和 $\{1, 2\}$ 的 $2$ 重复了，于是放到 $B$ 中。

而对于第四个数对 $\{4, 3\}$ ，可以发现不管放到哪里都有重复的。

然而，这个数据是可以合法的分到两个集合的：

$$
A: \{1, 2\} \ \{4, 3\} \ \{5, 6\} \\
B: \{2, 3\} \ \{5, 4\} \ \{6, 1\}
$$


我们可以把数对拆称每个数字来看。

从 $1$ 开始，所有数对中，包含 $1$ 的有两个：$\{1, 2\}$ 和 $\{6, 1\}$。那么我们知道，因为两个数对都有 $1$，所以肯定不能放到一个集合里。

按照相同的方式来看 $2$。包含 $2$ 的数对有两个：$\{2, 3\}$ 和 $\{1, 2\}$。所以这两个也一定在不同的集合中。

按照这样的方法从 $1$ 到 $n$ 的列出包含这些数字的集合，可以得到：

$$
1 \to \{1, 2\} \ \{6, 1\}\\
2 \to \{2, 3\} \ \{1, 2\}\\
3 \to \{2, 3\} \ \{4, 3\}\\
4 \to \{4, 3\} \ \{5, 4\}\\
5 \to \{5, 4\} \ \{5, 6\}\\
6 \to \{5, 6\} \ \{6, 1\}
$$

然后我们检查这些条件，发现似乎没有矛盾的，并且你可以根据这些条件得到我之前给出的分配方法。

这样一看，告诉你两个东西在不同的集合中，并且让你判断这些规则是否能满足，那不就是一种带逻辑关系的并查集吗？ 

如果你不熟悉，可以去看看这些题目：
- [洛谷P1892 [BOI2003]团伙](https://www.luogu.com.cn/problem/P1892)
- [P2024 [NOI2001] 食物链](https://www.luogu.com.cn/problem/P2024)

的确，这个题是可以用带逻辑关系的并查集来做的，tourist 就是[这么做的](https://codeforces.com/contest/1702/challenge/163478635)。

不过，我们还可以从图论的角度来思考。

如果我们给一个数对中的两个数字连上一条边，就可以得到下面这样的图：

```
1 <--> 2 <--> 3
|             |
6 <--> 5 <--> 4
```

可以发现，因为和之前一样的原因，对于一个数字，比如 $2$。我们不可能把包含 $2$ 的两个数对，也就是 $\{2, 3\}$ 和 $\{1, 2\}$，放到一个集合里。

也就是说可以从边的角度思考，$2$ 这个节点连了两个边，而我们不能同时选 $2$ 的两条边放到一个集合里。

那么唯一能满足这个要求的办法就是交替的把边分配到集合中。

比如：

```
1 <--> 2 <==> 3    or     1 <==> 2 <--> 3 
||            |   <--->   |             ||
6 <==> 5 <--> 4           6 <--> 5 <==> 4
```

其中 `<-->` 这样的边和 `<==>` 这样的边代表边上的两个节点会被放到不同的集合中。

接下来我们可以分类讨论一下，不同的图是否能满足要求。

首先，如果一个节点连了三个及以上的边，那么一定是不能满足交替放入不同集合中的。

比如：

```
    A 
   /|\
  / | \
 B  C  D
```

因为如果要把这三条边放入两个集合中, $A$ 会不可避免的出现了两次。

其次，如果图中只有一个链，那么交替的放入不同集合中是一定能满足的。

最后，如果图是一个环，并且有偶数的边（就像上面那样），那是一定可以满足交替出现的要求的。而奇数就不行了。

判断环奇偶的办法其实比较直观，我们给每个边设置一个颜色的属性，共有两种颜色，然后用 dfs 去遍历一遍这个环。

遍历时尝试给边交错的染上颜色，如果我们不能成功的交错染色，那一定是奇环，反之亦然。（如果能交错的染色，那么两种颜色的数量一定是相等的，因此一定是偶环）。

还有一点在具体实现时需要注意，我们建出来的图不一定是联通的，所以需要尝试对每一个节点 dfs，同时，之间按照输入建图可能有重边，而我们需要避免。

## 代码
整体来说，代码还是比较简洁的。

```cpp
// author: ttzytt (ttzytt.com)
#include <bits/stdc++.h>
using namespace std;
#define ll long long
struct E {
    int to, color;
};

const int MAXN = 2e5 + 10;

vector<E> e[MAXN];
set<int> have_e[MAXN];

bool iseven_cycle(int cur, int fa, bool cur_color) {
    if (e[cur].size() < 2) return true;
    // 小优化，size 小于 2 说明是一个链的终点。
    // 那么一个链是一定可以交错的染色的，这时候直接返回 true
    for (E &nex : e[cur]) {
        if (nex.to == fa) continue;
        if (nex.color == -1) // -1 是初始值，所以直接给它染和当前边不同的颜色
            nex.color = !cur_color;
        else if (nex.color == cur_color)// 如果发现下一个边和当前边同色，那肯定是不能成功染色的
            return false;
        else if (nex.color == !cur_color)// 有颜色了，但是是我们想染的。
            return true;
        if (!iseven_cycle(nex.to, cur, !cur_color)) return false;
    }
    return true;
}

int main() {
    int t;
    cin >> t;
    while (t--) {
        int n;
        cin >> n;
        for_each(e + 1, e + 1 + n, [](vector<E> &a) { a.clear(); });
        for_each(have_e + 1, have_e + 1 + n, [](set<int> &a) { a.clear(); });
        // 每次清空一下数据。

        bool isable = true;
        map<int, int> bkt; // 记录每个节点的度，如果大于 2 那一定不行（原因如上文）
        for (int i = 1; i <= n; i++) {
            int x, y;
            cin >> x >> y;
            bkt[x]++, bkt[y]++;
        
            if (bkt[x] > 2 || bkt[y] > 2 || x == y) isable = false; // 发现度大于 2
        
            if (!have_e[x].count(y)) { //用于避免重边
                e[x].push_back({y, -1});
                have_e[x].insert(y);
            }
            if (!have_e[y].count(x)) {
                e[y].push_back({x, -1});
                have_e[y].insert(x);
            }
        }
        for (int i = 1; i <= n && isable; i++) {
            if (e[i][0].color == -1) 
                isable = iseven_cycle(i, 0, 1); 
                // 建出来的图不一定联通，所以尝试对每个节点 dfs   
        }
        if (isable)
            cout << "yes\n";
        else
            cout << "no\n";
    }
}
```
最后，希望这篇题解对你有帮助，如果有问题可以通过评论区或者私信联系我。