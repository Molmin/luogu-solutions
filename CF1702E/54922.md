#### 基本题意
- 给定 $n$（偶数）个二元集，每个元素属于 $[1,n]$
- 要求判断能否将这些二元集对半分成两组，使得每组中都没有两个相同的元素
- $ 2 \le n \le 2 \cdot 10^5 $

#### 题目分析
这道题有一个错误的思路是直接从前往后枚举进行贪心，既对于每一个二元集，两个都没有被放过的话放在第一组，否则进行判断再放，但这道题处理二元集的顺序对最终答案有影响，所以这个做法是错误的。

为了改变这个错误的做法，只需将这些二元集按序处理。

具体来说，我们在枚举时，如果当前这个二元集可以随便放，将其放在第一组。

否则的话，前往第二个元素的另外一个对应集合（显然为了有解，每个元素当且仅当出现两遍），然后对这个对应的集合进行放置。

像这样形成一条处理的链式结构，直到发现二元集的两个元素都被放置过时返回，然后前往下一个可以随便放置的二元集。

这里我使用了一个方法来区分一下两次出现的同一个元素，当一个元素 $x$ 第二次出现的时候，我将其标记为 $x+2 \cdot 10^5$，这样之后表示的时候会方便一些。

然后注意一下在有元素只出现了一次直接输出 NO 就可以了。


#### 代码

具体实现方面，我定义了五个数组，$a$ 数组和 $b$ 数组代表输入的二元集，$c$ 数组是计数数组，代表每个数出现的次数，可用来判断是否有明显的 NO，$d$ 数组记录每个数最终放在哪个组里，$e$ 数组记录每个数在二元集中的对应数。

我用了一个 while 循环来模拟 dfs，因为 dfs 的话可能会因为层数过多而爆栈。

```cpp
#include<iostream>
#include<cstring>
using namespace std;
int n,a[200001],b[200001],c[400001],d[400001],e[400001];
int oppo(int x)//计算本是同一个数的数现在是什么
{
    if(x<200000)
        return x+200000;
    return x-200000;
    //两个本是同样的数现在差2e5
}
int opp(int x)//两个可以放的组，一个为1一个为2
{
    if(x<2)
        return 2;
    return 1;
}
int main()
{
    ios::sync_with_stdio(false);
    cin.tie(0);
    int t,p,i,side;
    bool f;
    cin>>t;
    while(t--)
    {
        cin>>n;
        for(i=1;i<=n;i++)
            cin>>a[i]>>b[i];
        f=0;
        memset(c,0,sizeof(c));
        memset(d,0,sizeof(d));
        for(i=1;i<=n;i++)
        {
            c[a[i]]++;
            c[b[i]]++;
            if(c[a[i]]==2)//第二次出现
            {
                c[a[i]]--;
                a[i]+=200000;
                c[a[i]]=1;//用多2e5的数来记录
            }
            if(c[b[i]]==2)
            {
                c[b[i]]--;
                b[i]+=200000;
                c[b[i]]=1;
            }
            e[a[i]]=b[i];//记录对应关系
            e[b[i]]=a[i];
        }
        for(i=1;i<=n;i++)
            if(c[i]!=1||c[i+200000]!=1)//明显错误
            {
                cout<<"NO\n";
                f=1;
                break;
            }
        if(f)
            continue;
        p=1;//p记录当前位置
        side=1;//side记录当前是哪一组
        while(1)
        {
            if(d[e[p]]==opp(side))//出现矛盾
            {
                cout<<"NO\n";
                f=1;
                break;
            }
            d[p]=side;//记录当前side
            if(!d[e[p]])//如果下一组没选过
            {
                d[e[p]]=side;
                p=oppo(e[p]);
                side=opp(side);
                continue;
            }
            bool f1=0;
            for(i=min(p,oppo(p));i<=n;i++)//这里可以直接从min(p,oppo(p))开始枚举的原因是前面的过程必然形成环，否则必有矛盾
                if(!d[i])//如果还没枚举过
                {
                    p=i;
                    side=1;
                    f1=1;
                    break;
                }
            if(f1)
                continue;
            break;//说明已经全枚举完
        }
        if(!f)
            cout<<"YES\n";//没问题就YES
    }
    return 0;
}
```
