记 $f'$ 为 $f\bmod n$ 的结果，先打个表找下规律（下标从 $1$ 开始，最后一个括号中的内容为循环）：

$n=2,f'=\{1,1,0,1,1,0,1,1,0...\},\{1,1,0\}$

$n=3,f'=\{1,1,2,0,2,2,1,0,1,1,2,0,2,2,1,0...\},\{1,1,2,0,2,2,1,0\}$

$n=4,f'=\{1,1,2,3,1,0,1,1,2,3,1,0...\},\{1,1,2,3,1,0\}$

$n=5,f'=\{1,1,2,3,0,1,1,2,3,0...\},\{1,1,2,3,0\}$

不难发现，在 $n=\{2,3,4,5\}$ 时，$f'$ 总会有循环节。又因为 $f$ 数组满足 $f_i=f_{i-1}+f_{i-2}$，$f'$ 数组也满足这个规律，于是只要出现 $0,1$ 接下来就肯定循环了（其中 $0$ 为上一个循环的末尾，$1$ 为下一个循环的开头）。

那么对于任意 $n$ 是否都有这规律？由于模 $n$ 的余数只有 $n$ 种，那么最多到 $n^2$ 项就能找到循环节了，而 $1\le n\le 1000$，每所以次找循环节这个方法是可行的。而找到循环节后，只需求出 $a^b$ 模循环节长度的结果，那么问题就迎刃而解了。

注意，当 $n=1$ 时，$f'$ 中的所有数均为 $0$，得特判一下。

```cpp
#include <bits/stdc++.h>
#define int unsigned long long
using namespace std;
const int N = 1e6 + 5;
int f[N], mod; 
int qpow(int a, int b) {
	a = a % mod;
	int res = 1;
	while (b) {
		if (b & 1) res = res * a % mod;
		a = a * a % mod;
		b = b >> 1; 
	}
	return res;
}
signed main() {
	int T;
	cin >> T;
	while (T--) {
		int a, b, n, i = 2;
		cin >> a >> b >> n;
		if (n == 1) {
		    cout << "0\n";
		    continue;
		}
		f[1] = 1;
		for (i = 2; ; i++) {
			f[i] = f[i - 1] + f[i - 2], f[i] %= n;
			if (f[i] == 1 && f[i - 1] == 0) break;
		}
		mod = i - 1;
		int ans = qpow(a, b);
		cout << f[ans == 0 ? mod : ans] << "\n";
	}
	return 0;
} 
```