**声明**

------------

本题解中若没有声明，则使用的算法都为自己想出来的算法，通常情况下是有着超高时间空间复杂度，不能与其他大佬相比较的，本题解只是有着一些思路引导。

**法一 博弈（dp）**

------------

对于这么庞大的数据，我的数组方法肯定无了，但我们可以打个小范围的列一下。

- 对于 $dp[i][k]$ ，$i$ 为剩下石子数量，$k$ 为上一次的人取得石子数量。
- $dp[i][k]$ 为1则表示在剩下石子数量为 $i$，当前取得石子数量为 $k$ 的时候先手者有必胜策略，反之则不是必胜（可以理解为必败）。

1. $k \ge i$ 时 $dp[i][k]=1$（可以一次取完）。
2. $k < i$ 时 若 $j=[1,k]$ 中有 $dp[i-j][j*2] = 0$，$dp[i][k] = 1$，否则 $dp[i][k] = 0$
（当不能一次取完时，若有一种取法能让下一个取的人作为先手时必败则这种取法必胜）。

按照这个规则，我们打 $10*10$ 的一个表（i，k均从1开始,i为纵轴，k为横轴）。

```
1 1 1 1 1 1 1 1 1 1
0 1 1 1 1 1 1 1 1 1
0 0 1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1
0 0 0 0 1 1 1 1 1 1
1 1 1 1 1 1 1 1 1 1
0 1 1 1 1 1 1 1 1 1
0 0 0 0 0 0 0 1 1 1
1 1 1 1 1 1 1 1 1 1
0 1 1 1 1 1 1 1 1 1
```

在推的过程中，我们可以发现，只要在同一行，左边是1那么他就是1。

- 情况1: $k+1 >= i$。
- 情况2：已经尝试过 $[1,k]$，只需要额外尝试 $k+[1,2 \times k]$ 即可。

列到 $20*20$ 我们会发现……我们可以把dp数组缩成一维。

- 对于 $dp[i]$，$i$ 为剩下石子数量。
- $dp[i]$ 表示当剩下石子数量为 $i$ 时，$k$ 至少为 $dp[i]$ 就可以保证必胜。

真不戳，但中间出了点问题……

好像要求输出的是 $[1,n-1]$ 个石子时开始可以取k个石子是能必胜的次数……

最终30分到手，数组还是太大了，O2只能救一个点，所以……

此方法终，止步于此。

**法二 找规律**

------------

有着 $10^{18}$ 那么庞大的数据，我们肯定是不能用数组实现的，我们需要找规律。

我们再列一列一维dp的数值。

```
1 2 3 1 5 1 2 8 1 2 3 1 13 1 2 3 1 5 1 2 21 1 2 3 1 5 1 2 8 1 2 3 1 34 1 2 3 1 5 1 2 8 1 2 3 1 13 1 2 3 1 5 1 2 55 1 2 3 1 5 1 2 8 1 2 3 1 13 1 2 3 1 5 1 2 21 1 2 3 1 5 1 2 8 1 2 3 1 89 1 2 3 1 5 1 2 8 1 2 3
```

在这些看似无序的数列中断断续续出现了斐波那契数列！

可惜它们中间有一些其他的数，我们对每个斐波那契数列中的数中相隔的数字数量列出来。

```
0 0 1 2 4 7 12 20
```

好奇怪啊，每一项都是前两项相加再加一耶！

我们再把中间隔的数字列出来……

- $3-5:   1$
- $5-8:   1,2$
- $8-13:  1,2,3,1$
- $13-21: 1,2,3,1,5,1,2$
- $21-34: 1,2,3,1,5,1,2,8,1,2,3,1$
- $34-55: 1,2,3,1,5,1,2,8,1,2,3,1,13,1,2,3,1,5,1,2$

真奇怪，我们可以得到这个式子。

$str[n]=str[n-1]+char(n-2)+str[n-2]$

那么真相大白了吧！

我们只需要对于每一段能够大于 $k$ 的数字数量存到数组里

而对于多出不是完整的一段的数列，我们可以使用递归将其拆分至完整的几小段

占用内存极小，但也需要用到大量数组进行递推

code：

```cpp
#include<bits/stdc++.h>
using namespace std;
int x;
long long k,n,sum;
long long fib[96]={0,1},rfib[96]={1,1};//1 2 3 5 8 13 21 34
long long f[96]={0,0};//0 0 1 2 4 7 12 20 33 54 88 143 232 376 609 986 1596 2583 4180 6764 10945 17710 28656
long long val[96],xval[96];
void dfs(long long dep,int fl) {
	if(dep>=n) return;
	//cout<<dep<<" "<<fl<<" "<<f[fl-1]<<endl;
	if(dep+f[fl-1]<=n) {
		sum+=val[fl];
		//cout<<dep+1<<" to "<<dep+f[fl-1]<<" "<<fl<<" is all ready "<<val[fl]<<endl;
	}
	else {
		dfs(dep,fl-1);
		if(fl<2) return;
		if(dep+f[fl-2]+1>n) return;
		if(rfib[fl-2]<=k) {
			//cout<<dep+f[fl-2]+1<<" is smaller than k "<<endl;
			sum++;
		}
		dfs(dep+1+f[fl-2],fl-2);
	}
	return;
}
int main() {
	int t;
	cin>>t;
	for(int i=2;i<=91;i++) {
		f[i]=f[i-1]+f[i-2]+1;
		fib[i]=fib[i-1]+f[i-2]+1;
		rfib[i]=rfib[i-2]+rfib[i-1]; 
	}
	while(t--) {
		cin>>k>>n;
		n--;
		if(n<=0||k<=0) {
			cout<<0<<endl;
			continue;
		} 
		x=3,sum=0;
		xval[1]=0,xval[2]=0;
		if(k>=1) xval[1]=1;
		if(k>=1) xval[2]=1;
		if(k>=2) xval[2]=2;
		//cout<<1<<" "<<xval[1]<<" "<<fib[1]<<" "<<val[1]<<endl;
		//cout<<2<<" "<<xval[2]<<" "<<fib[2]<<" "<<val[2]<<endl;
		while(fib[x]<=n) {
			val[x]=val[x-1]+val[x-2];
			if(rfib[x-2]<=k) val[x]++;
			xval[x]=xval[x-1]+val[x-1];
			if(rfib[x]<=k) xval[x]++;
			//cout<<x<<" "<<xval[x]<<" "<<fib[x]<<" "<<val[x]<<endl;
			x++;
		}
		dfs(fib[x-1],x-1);
		if(fib[x-1]<=n) cout<<xval[x-1]+sum<<endl;
		else cout<<xval[1]<<endl;
	}
	return 0;
} 
```
**总结**

------------

很好一道……博弈论？这道题其实是以思路为主，很需要理解能力与代码实现能力（对于我而言），这道题重在懂得这道题的一些特殊之处，如：

- k越大先手越容易获胜
- 想出此题的一维数组解法
- 找到规律

这道题需要的代码能力在蓝题难度，但打着打着很容易把自己打混乱（我的做法），对于判断不能完全组合成斐波那契数列的数列需要单独把多出来的数列进行分解判断优化。

此题坑点很多，包括但不限于：

- $n$ 和 $k$ 有可能为 $0$
- 第 $n$ 个数不算在内
- 有可能 $n$ 为 $1$，但你直接输出的是 $n=2$ 的情况了

我做此题时间太长，所以还是要加以进步的

**祝大家AC快乐！**