~~打表找规律好题~~

取到最后一颗石子的输，因为这里只有一个游戏所以不需要 $anti-sg$ 定理，可以直接认为是取到倒数第二颗石子的获胜。

设 $f_{i,j}$ 表示还剩 $i$ 颗石子，这一次能取 $[1,j]$ 颗石子时是否能取胜，转移为：（$\oplus$ 表示或）
$$
f_{i,j}=\oplus_{k=1}^{j}[f_{i-k,2k}=0]
$$
容易发现，当 $i$ 确定的时候，随着 $j$ 的增大，$f_{i,j}$ 一定会从某一刻开始变成 $1$。

设 $a_i$ 表示最小的 $j$ 使得 $f_{i,j}=1$ ，那么一定有 $a_{i-a_i}\geq 2a_i$，然后就可以计算 $a$ 并打出前若干项：

| $a_0$    | $a_1$ | $a_2$ | $a_3$ | $a_4$ | $a_5$ | $a_6$ | $a_7$ | $a_8$ | $a_9$ | $a_{10}$ | $a_{11}$ | $a_{12}$ | $a_{13}$ |
| -------- | ----- | ----- | ----- | ----- | ----- | ----- | ----- | ----- | ----- | -------- | -------- | -------- | -------- |
| $\infty$ | 1     | 2     | 3     | 1     | 5     | 1     | 2     | 8     | 1     | 2        | 3        | 1        | 13       |

可以发现，这个数列的生成方式类似斐波那契数列，设 $f_i$ 表示斐波那契数列的第 $i$ 项，$a$ 的前 $f_i$ 项就是将前 $f_{i-2}$ 项接在第 $f_{i-1}$ 项后面，然后将第 $f_i$ 项替换成 $f_i$。

~~不说人话就是 $a_i$ 等于 $i$ 在斐波那契进制下的 lowbit~~

现在要求的答案是 $\sum_{i=0}^{i=n-1}[a_i\leq k]$，因为 $a$ 内本质不同的数字个数只有 $O(logn)$ 个，所以可以分别统计出现次数。

设 $s_{i,j}$ 表示前 $f_i$ 项中 $f_j$ 的出现次数，那么 $s_{i,j}$ 可以 $O(log^2n)$ 计算出来，用类似斐波那契进制的就可以 $O(log^2n)$ 地回答询问了。

容易发现可以上一个简单的前缀和优化达到 $O(log^2n+Tlogn)$ 的总复杂度。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define FOR(i,a,b) for(int i=a;i<=b;i++)
#define ROF(i,a,b) for(int i=a;i>=b;i--)
const int N=90;
int p,T;
long long n,k,ans,f[N+2],s[N+2][N+2];
int main(){
	f[0]=1,f[1]=1;
	FOR(i,1,N){
		f[i+1]=f[i]+f[i-1],s[i][i]=1;
		FOR(j,1,i)s[i+1][j]=s[i-1][j]+s[i][j]-(j==i-1);
	}
	FOR(i,1,N)FOR(j,1,N)s[i][j]+=s[i][j-1];
	for(scanf("%d",&T);ans=p=0,T--;cout<<ans<<'\n'){
		for(scanf("%lld%lld",&k,&n);f[p+1]<=k;p++);
		ROF(i,N,1)if(n>f[i])n-=f[i],ans+=s[i][p];
	}
	return 0;
}
```