~~在冬令营听讲座根本听不懂的我跑过来水题解了~~

乍一看题面：哇，这是什么，根本不可做的样子！那个奇奇怪怪的限制好像并不是很好转移的样子！

然后讲座就说了：我们可以将这道题转换成一个图论问题，建出$n$个点，我们把原问题中的每个点$(x,y)$转换为：在新图中，连一条有向边$(x,y)$。如果图中存在边$(x,y),(y,z)$，连边$(z,x)$，求最终得到的图中边的数量。

首先，这个问题肯定是关于弱连通分量（即将所有有向边看作无向边形成的连通块）独立的。

我们发现，在一次操作中，必有点$y$的入度和出度都不为$0$。

我们关于一个出入度都不为$0$的点$y$做分析：

显然，所有被$y$指向的点都会连一条边指向所有指向$y$的节点。

那么我们就可以关于这个$y$点将图分成三层：指向$y$的，$y$本身，被$y$指向的。

我们对于任何一个这样的$y$，都进行分层。

如果层与层之间相互独立（即不同的$y$的分层结果并不冲突），那我们就得到了一张有三部分的图。第一部分是在原图中指向某一个$y$的，第二部分是在原图中的某个$y$，第三部分是在原图中被某个$y$所指向的。

各部分内部没有边，而第一部分所有点连向第二部分所有点，第二部分所有点连向第三部分所有点，第三部分所有点连向第一部分所有点。

稍等，我们原分析中，不是只有“第三部分所有点连向第一部分所有点”吗？另外两条是怎么冒出来的？

我们可以将第一部分看作新的第二部分，第二部分看作新的第三部分，第三部分看作新的第一部分，这样便说明了三部分之间是互相连边的。

那么，这种情况下，这个弱连通分量的贡献就是$t_0*t_1+t_1*t_2+t_2*t_0$，其中$t_0,t_1,t_2$依次表示第一部分、第二部分、第三部分的节点数。

当然还有其它情况，即不同的$y$的分层结果冲突了。这可能意为着各部分内部连了边，可能意味着在某些部分间的边反掉了。

但不管怎么样，最终都会连成一张完全图。

我们可以证明一下：首先，如果多出来这么一条边，那肯定会出现一个二元环（同部分间的边一定可以直接连一条反边，异部分之间的边本来就成环）。

我们把这个二元环部分缩成一个点。则不管是连进来的边还是连出去的边，都可以连一条反边。而一旦反边被连，就又构成二元环，又可以缩进去。直到整个弱连通分量全都缩成一个点。

则如果出现分部冲突的局面，那直接贡献$sz^2$的答案。其中$sz$是弱连通分量大小。

我们可以通过染色解决这个问题。颜色$0$代表第一部分，颜色$0$的点指向的点为颜色$1$；颜色$1$代表第二部分，颜色$1$的点指向的点为颜色$2$；颜色$2$代表第三部分，颜色$2$的点指向的点为颜色$0$……

如果染色冲突，就是$sz^2$的那种情形；否则，就是$t_0*t_1+t_1*t_2+t_2*t_0$的情形。

等等，我们好像忘了一种极端情况！如果不存在这样出入度都不为$0$的点$y$怎么办？

还能怎么办！不存在这样的$y$，就意味着不存在可以连边的地方。答案为这个弱连通分量中边的个数。在染色中的体现，就是不存在某一部分。

代码：
```
#include<bits/stdc++.h>
using namespace std;
int n,m,head[100100],cnt,col[100100],tot[3],TE;
typedef long long ll;
ll res;
struct node{
	int to,next,val;
}edge[200100];
void ae(int u,int v){
	edge[cnt].next=head[u],edge[cnt].to=v,edge[cnt].val=1,head[u]=cnt++;
	edge[cnt].next=head[v],edge[cnt].to=u,edge[cnt].val=-1,head[v]=cnt++;
}
bool Dye(int x){
	tot[col[x]]++;
	bool ret=true;
	for(int i=head[x];i!=-1;i=edge[i].next){
		TE+=(edge[i].val==1);
		if(col[edge[i].to]==-1){
			col[edge[i].to]=(col[x]+edge[i].val+3)%3;
			ret&=Dye(edge[i].to);
		}
		else ret&=(col[edge[i].to]==(col[x]+edge[i].val+3)%3);
	}
	return ret;
}
int main(){
	scanf("%d%d",&n,&m),memset(head,-1,sizeof(head)),memset(col,-1,sizeof(col));
	for(int i=1,x,y;i<=m;i++)scanf("%d%d",&x,&y),ae(x,y);
	for(int i=1;i<=n;i++){
		if(col[i]!=-1)continue;
		memset(tot,0,sizeof(tot)),TE=0;
		col[i]=0;
		if(!Dye(i)){res+=1ll*(tot[0]+tot[1]+tot[2])*(tot[0]+tot[1]+tot[2]);continue;}
		if(!tot[0]||!tot[1]||!tot[2]){res+=TE;continue;}
		res+=1ll*tot[0]*tot[1]+1ll*tot[1]*tot[2]+1ll*tot[2]*tot[0];
	}
	printf("%lld\n",res);
	return 0;
} 
```
