加强版：[CF652F Ants on a Circle](https://www.luogu.com.cn/problem/CF652F)

题意：给你 $n$ 只不同位置的蚂蚁、长度为 $l$ 的一个环和总时间 $t$，每只蚂蚁每秒走 $1$ 长度。然后给你每只蚂蚁的位置和方向（顺时针或逆时针），让你求 $t$ 秒之后每一只蚂蚁的位置（顺序同输入顺序）。

解题思路：假如我们站在很高很高的山上看这群蚂蚁在绕着这个环转，那么我们会很惊奇的发现，两只蚂蚁碰到之后，他们居然穿过了对方！而且，因为是一个环，每一只蚂蚁只要碰到对方就掉头，那么，排在一只蚂蚁顺时针方向的蚂蚁永远不会到这只蚂蚁的逆时针（指相对位置），排在一只蚂蚁逆时针方向的蚂蚁永远不会到这只蚂蚁的顺时针。于是我们得到，他们的相对位置是永不变的。

因为这一题里面输入的蚂蚁位置是升序的，所以我们不需要排序。

于是我们只需要紧盯着一只蚂蚁，我取了排完序后距离最小的第一只蚂蚁，然后求出它的精确位置，于是我们就可以得到所有蚂蚁的位置了。

由于是在环上，我们之前取的第一只蚂蚁走过 $t$ 秒后并不一定就还是最靠前的（相对于环上的位置 $0$），我们记 $0$ 为蚂蚁运动时一个固定的“路标”，如果有蚂蚁顺时针经过了 $0$，那么 $1$ 号蚂蚁前面就多了一只蚂蚁（在以 $0$ 位置为起点 $0\degree\sim360\degree$ 时）。如果有蚂蚁逆时针经过了 $0$，那么 $1$ 号蚂蚁前面就少了一只蚂蚁。因为我们是拿 $0$ 作为参考系的，所以 $1$ 号蚂蚁经过 $0$ 也要处理。由此，我们就可以计算出 $1$ 号蚂蚁前面有多少只蚂蚁了，然后我们从 $1$ 号蚂蚁依次把排序完后的所有蚂蚁最终的位置传给每一只蚂蚁就行了。

我们能这么做的原因是：你可以想象一只带着光源的蚂蚁，然后他从 $x$ 位置出发，如果他碰到了一只蚂蚁，那么他就把光源传给了他碰到的那一只蚂蚁，然后那一只蚂蚁又碰到了另一只蚂蚁，那么那一只蚂蚁就把光源传给了另一只蚂蚁……由此看来，我们根本无需在蚂蚁爬行时那么在意他们的编号。

Code:

```cpp
#include<bits/stdc++.h>
using namespace std;
const int MaxN=1e5+5;
int n,l,t,first_ant_place;
struct hh{
	int place,towards,ends;//towards=1-->往数值大的地方走,towards=2-->往数值小的地方走
	bool friend operator < (hh x,hh y){
		return x.ends<y.ends;
	}
}a[MaxN];
int main(){
	scanf("%d%d%d",&n,&l,&t);
	for(int i=1;i<=n;i++){
		scanf("%d%d",&a[i].place,&a[i].towards);
		if(a[i].towards==1){
			a[i].ends=a[i].place+t;
		}else{
			a[i].ends=a[i].place-t;
		}
		first_ant_place=(first_ant_place+(int)floor(1.0*a[i].ends/l)%n+n)%n;
		a[i].ends=(a[i].ends%l+l)%l;
	}
	sort(a+1,a+n+1);
	for(int i=1;i<=n;i++){
		printf("%d\n",a[(first_ant_place+i-1)%n+1].ends);
	}
	return 0;
}
```