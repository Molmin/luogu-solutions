好久没写题解力。题解区大家都写的是 $2 \sim 4$ 维 dp，于是我想写写自己的线性空间复杂度 dp。

**题意**：

有 $n$ 座山，第 $i$ 座高度为 $a_i$。其中的一个山上能建房，当且仅当其左右两边的山（如果有的话）的高度均严格比其小。如果可以花费 $1$ 元把某座山的高度减 $1$（山的高度可以非正），对于所有 $k\in[1,\lceil\frac{n}2\rceil]$，求使 $k$ 个山上能建房的最小花费。

$1\le n\le 5\times10^3,1\le a_i\le 10^5$。

**解题思路**：

通过题目条件，结合样例，可以看出能建房的两座山有如下两种位置关系：

- 相隔一座山

  ![](https://cdn.luogu.com.cn/upload/image_hosting/66djfr6a.png)
  
  以此图为例，第一座山为了建房，把第二座山切到了 $1$ 单位高度，因此，第三座山要建房，无需处理左边的山。
  
  可以看出，当某座山需要建房时，若离上一座房子仅一座山，则需要考虑上一座房子的高度处理。
  
- 相隔多于一座山

  ![](https://cdn.luogu.com.cn/upload/image_hosting/ptqxr15j.png)
  
  以此图为例，后一座房子的建立和前一个房子的建立没有关系，后者房子只需处理自己左右的山，无需考虑前一座房的处理。
  
显然，两座房不可能相邻。

第二种情况让我们想到了使用动态规划：设 $f_{i,j}$ 表示第 $i$ 座山上建第 $j$ 座房需要的最小代价，则如果只有第二种情况，则递推式如下：

$$\small{f_{i,j}=\min\{\max\{0,a_{i-1}-a_i+1\}+\max\{0,a_{i+1}-a_i+1\}+f_{k,j-1}\}(1\le k\le i-3)}$$

即，第 $i$ 座山上建第 $j$ 座房需要的最小代价等于建这个房本身的代价加上在前面的位置建前 $j-1$ 座房的最小代价。

现在考虑第一种情况：前一座房所在的山高为 $a_{i-2}$，中间的山原来高度为 $a_{i-1}$。当 $a_{i-2}>a_{i-1}$ 时，中间的山无需处理，高仍为 $a_{i-1}$；否则，中间的山高度需要减为 $a_{i-2}-1$。因此 $\min\{a_{i-1},a_{i-2}-1\}$ 即为中间的山在前一座房处理后的高度。

可得递推式如下：

$$\small{f_{i,j}=\max\{0,\min\{a_{i-1},a_{i-2}-1\}-a_i+1\}+\max\{0,a_{i+1}-a_i+1\}+f_{i-2,j-1}(3\le i\le n)}$$

综合两种情况，就可以得到一个完整的 dp 过程：

```cpp
namespace{
	const int N=5e3+3;
	int n,a[N],f[N][N];
	void work(){
		n=read();
		memset(f,0x3f,sizeof(f));
		a[0]=a[n+1]=-inf;//方便处理 1 和 n 的情况
		F(i,1,<=n){
			a[i]=read();
		}
		F(i,1,<=n){//枚举山的序号
			f[i][1]=max(0,a[i-1]-a[i]+1)+max(0,a[i+1]-a[i]+1);//特别处理第一次建房的情况
			F(j,2,<=(i+1)/2){//枚举在这座山上建的房的序号
				f[i][j]=max(0,min(a[i-1],a[i-2]-1)-a[i]+1)
				+max(0,a[i+1]-a[i]+1)+f[i-2][j-1];//隔一座山的情况
				F(k,1,<=i-3){//隔多座山的情况，枚举上一座山
					f[i][j]=min(f[i][j],max(0,a[i-1]-a[i]+1)+max(0,a[i+1]-a[i]+1)+f[k][j-1]);
				}
			}
		}
		F(i,1,<=(n+1)/2){
			Int ans=inf;
			F(j,1,<=n){//求建完第 i 座山后的最小价值
				ans=min(ans,f[j][i]);
			}
			cout<<ans<<' ';
		}
	}
}
```

时间复杂度 $\mathcal O(n^3)$，空间复杂度 $\mathcal O(n^2)$，可以拿到 $75$ 分。

**优化**：

可以发现，整个 dp 的过程中，求“隔多座山的情况”耗费了大量时间枚举 $f_{k,j-1}$ 的最小值。在此基础上，我们可以设计一个前缀最小值：

$$s_{i,j}=\min\{f_{k,j}\}(1\le k\le i)$$

因此优化后的代码如下：

```cpp
namespace{
	const int N=5e3+3;
	int n,a[N],f[N][N],s[N][N];
	void work(){
		n=read();
		memset(f,0x3f,sizeof(f));
		memset(s,0x3f,sizeof(s));
		a[0]=a[n+1]=-inf;//方便处理 1 和 n 的情况
		F(i,1,<=n){
			a[i]=read();
		}
		F(i,1,<=n){//枚举山的序号
			f[i][1]=max(0,a[i-1]-a[i]+1)+max(0,a[i+1]-a[i]+1);//特别处理第一次建房的情况
			F(j,2,<=(i+1)/2){//枚举在这座山上建的房的序号
				f[i][j]=min(max(0,min(a[i-1],a[i-2]-1)-a[i]+1)+max(0,a[i+1]-a[i]+1)+f[i-2][j-1],//隔一座山的情况
				s[i-3][j-1]+max(0,a[i-1]-a[i]+1)+max(0,a[i+1]-a[i]+1));//隔多座山的情况
			}
			F(j,1,<=(i+1)/2){//计算前缀最小值
				s[i][j]=min(s[i-1][j],f[i][j]);
			}
		}
		F(i,1,<=(n+1)/2){
			cout<<s[n][i]<<' ';//求建完第 i 座山后的最小价值
		}
	}
}
```

时间复杂度 $\mathcal O(n^2)$，空间复杂度 $\mathcal O(n^2)$，已经可以通过本题了。

**再优化**：

可以发现，上述的 $f$ 和 $s$ 的第二维在枚举时只用到了前一组数据，因此可以类似 01 背包问题优化为一维数组。此时 $f_j$ 表示在前 $j$ 座山建 $i$ 座房的最小价值（$i$ 在循环中定义），$s_j=\min\{f_k\}(1\le k\le j)$。

```cpp
namespace{
	const int N=5e3+3;
	int n,a[N],f[N],s[N],ans[N];//ans[i] 记录建 i 个房子的答案
	void work(){
		n=read();
		memset(f,0x3f,sizeof(f));
		memset(s,0x3f,sizeof(s));
		a[0]=a[n+1]=-inf;//方便处理 1 和 n 的情况
		F(i,1,<=n){
			a[i]=read();
		}
		F(i,1,<=n){//提前处理第一次建房的情况
			f[i]=max(0,a[i-1]-a[i]+1)+max(0,a[i+1]-a[i]+1);
			s[i]=min(s[i-1],f[i]);
			ans[1]=s[n];
		}
		F(i,2,<=(n+1)/2){//枚举房子的序号
			R(j,n,>=1){//类似 01 背包的空间优化，倒序枚举
				if(j>=i*2-1){
					f[j]=min(f[j-2]+max(0,min(a[j-2]-1,a[j-1])-a[j]+1)+max(0,a[j+1]-a[j]+1),//隔一座山
					s[j-3]+max(0,a[j-1]-a[j]+1)+max(0,a[j+1]-a[j]+1));//隔多座山
				}else f[j]=inf;
			}
			F(j,1,<=n) s[j]=min(s[j-1],f[j]);//求前缀最小值
			ans[i]=s[n];
		}
		F(i,1,<=(n+1)/2){
			cout<<ans[i]<<' ';
		}
	}
}
```

时间复杂度 $\mathcal O(n^2)$，空间复杂度 $\mathcal O(n)$。实际上可能因为常数原因跑得也非常快，在加上简单快读和一些计算优化后，题解提交时在[最优解](https://www.luogu.com.cn/record/list?pid=P6304&orderBy=1)上仅次于楼顶的 `fread` 大佬。