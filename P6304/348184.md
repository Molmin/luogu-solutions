ejoi - hills

和大家做法都不太一样的dp~

首先考虑这道题的性质：当我们可以建山的时候 ，要保证当前的山的高度$h_i > h_{i - 1}  ,  h_i > h_{i-1}$ , 则就必然没隔一个山才能建房子 。 

刚刚开始看到这个题很好想到$f_{i,j}$前$i$个山 ， 建造$j$个山的最小花费 ， 但是对于每隔一个才能建不是很好转移 ， 所以再加上一维 , 变成
 $\Rightarrow f_{i , j , k}$ 表示前$i$个山 ， 建造$j$个山 ， 且当前山$i$建不建山 ,（0表示不建/1表示建造）

状态转移：
这个转移很像0/1背包 ， 因为没座山只有建或者不建两种选择。

对于第$i$座山不建 $\Rightarrow f_{i,j,0} = min (f_{i - 1 , j , 1} , f_{i - 1 , j , 0})$ 对于这个点不建造 ， 直接那前一座山建$j$个房子来转移 。

对于第$i$个点建造的话我们分为两种情况$A,B$ 。情况$A$ : 当前的山满足题目要求。情况$B$为不满足。
对情况$A$转移 ， 由于没有花费 ， 直接转移即可 ， $f_{i,j,1} = f_{i - 1 , j-1 , 0}$ 。 
对于$B$情况只需要再加上一个使当前第$i$座山满足题目要求的$cost$即可 $f_{i,j,1} = f_{i - 1 , j-1 , 0} + cost$ 。 

最后一些小提示 
1.*初始化*：  需要把$f_{i,0,0}$都改成$0$。
2.对于$cost$的计算 ： 由于可能出现减去重复的情况 ， 也就是对于第i座山$h_{i-1} >= h_{i}$ ， 如果我们直接将$cost$赋值为$h_{i-1}-h_{i}+1$的话可能会出现一点$bug$ , 如果$f_{i-1,j-1,0}==f_{i-2,j-1,1}$的时候，我们就重复减了两次$cost$。解决方法：分条件转移即可。

贴下代码~

```cpp
	for (int i = 1 ; i <= n ; i ++) {
		for (int j = 1 ; j <= k ; j ++) {
			bool Goal = 0 ;
			if (a[i] > a[i - 1] && a[i] > a[i + 1]) Goal = 1 ;
			int part = i / 2 + (bool)(i % 2 == 1) ;
			if (j > part) continue ; 
			if (Goal == 1) {
				f[i][j][0] = min (f[i - 1][j][0] , f[i - 1][j][1]) ;
				f[i][j][1] = f[i - 1][j - 1][0] ;
			}
			else {
				f[i][j][0] = min (f[i - 1][j][0] , f[i - 1][j][1]) ;
				int worth1 = a[i] > a[i - 1] ? 0 : a[i - 1] - a[i] + 1 ; // 前面的cost 
				int worth2 = a[i] > a[i + 1] ? 0 : a[i + 1] - a[i] + 1 ; // 后面的 cost  
				if (i == 1) {
					f[i][j][1] = f[0][0][0] + worth2 ;
					continue ;
				}
				
				if (a[i - 2] > a[i - 1]) f[i][j][1] = min (f[i - 1][j - 1][0] , f[i - 2][j - 1][1]) + worth1 + worth2 ; 
				if (a[i - 2] <= a[i - 1]) {
					int worth3 = a[i] > a[i - 2] - 1 ? 0 : a[i - 2] - 1 - a[i] + 1 ;
					f[i][j][1] = min (f[i - 1][j - 1][0] + worth1 + worth2 , f[i - 2][j - 1][1] + worth3 + worth2) ; 
				}				  
			}
		}
	}
```
哦 ， 对了 ， 时间复杂度为$O(nk)$。