来看一篇Python题解吧~

先来看思路。读完题目，我们明白题目其实就是**让你找出在起床时间前最接近的符合要求的幸运时间**。这里符合要求指闹铃时间与起床时间差$x$的倍数分钟。

这时候，很容易想到，从起床时间往回找是更快的，而不是从前往后找，等到时间比起床时间大了就break。

为什么呢？因为前者可以在计算的时候就标记$ans$，更快一点。

这道题的思路其实就是这样了，并不难。更为复杂的是跨天数的时间计算（如$23:59-00:00$）。

按照我们的做法（从后往前），这里的计算只涉及从后面一天回到前面一天。来看个例子吧：

$00:05$减$7$分钟等于？

我们先减分钟变成：$00:-2$。显然这是不对的。

那我们就要向小时那一位借$1$小时也就是$60$分钟。像这样：$0-1:-2+60$，也就是$-1:58$。

小时怎么是负的了？没关系，这个时候我们变成$23$时即可（$0$时往前$1$个小时是$23$时）：$23:58$

好了，现在我们把这个过程搞清楚了，那就没问题啦。上代码！

```python
import sys
x=int(input())
h,m=map(int,input().split()) #输入时分，前导0会自动舍去
ans=0 #记录答案
while 1: #无限循环，直到找到答案退出
    if h%10==7 or m%10==7: #先判断，以防原来的时间就是幸运时间
        print(ans) #满足条件就输出ans并结束程序
        sys.exit()
    ans+=1 #没有找到答案，ans+1，表示多按一次
    m-=x #往回x分钟
    if m<0: #分钟是负的
        m+=60 #借来60分钟
        h-=1 #被借走1小时
    if h<0: h=23 #小时是负的，直接变成23时
```
好了，就到这里啦。希望大家喜欢！