## 题意
使用递归方式求解等差数列的和。

## 分析
~~明明有更方便的求和公式为什么不用~~

我们遇到了第一个问题：什么是递归？

以下摘自百度百科：

“**程序调用自身的编程技巧称为递归**。递归做为一种算法在程序设计语言中广泛应用。 一个过程或函数在其定义或说明中有直接或间接调用自身的一种方法，它通常**把一个大型复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解**，递归策略只需少量的程序就可描述出解题过程所需要的多次重复计算，大大地减少了程序的代码量。递归的能力在于用有限的语句来定义对象的无限集合。一般来说，递归需要有**边界条件、递归前进段和递归返回段**。当边界条件不满足时，递归前进；当边界条件满足时，递归返回。”

### 我们可以从中提取几点有用的信息：

1. 递归就是程序调用自身。
1. 递归的思想可以把大型问题转化为较小规模问题。
1. 递归的必要条件是边界条件、递归前进段和递归返回段。

第二个问题：如何程序实现递归？

其实上文已经给出了答案：程序调用自身。

比如说：
```
int digui(int a) {
	digui(a - 1);
}
```
这就是一次程序（函数）的自我调用。但是当我们试着运行这个函数是，却发现程序异常退出了。这显然不是完整的递归。

我们再看看上文：**递归的必要条件是边界条件、递归前进段和递归返回段。**

于是我们明白了：在这个函数中，只有递归前进段（即递归调用），而没有边界条件和递归返回段。

为什么边界条件和递归返回段是必要的？

很简单，如果没有设定递归边界，那么这个递归调用就永远不会结束。在生活中，这种情况被称作**无限套娃**。而在计算机中，这种情况叫做**无限递归**。由于递归占用计算机栈内存，通常表现为计算机**栈内存溢出**。

避免栈溢出的方式，就是添加递归边界。
```
int digui(int a) {
	if(a == 1) return 1;
    return digui(a - 1);
}
```
由此，我们得到了一个完整的**递归函数**。

将这个函数结合本题题意进行修改：
边界条件和递归返回段。
```
int solve(int n) {
    if(n == 1) return 1;
    return(solve(n - 1) + n);
}

```
这样，就得到了最后的程序。
```
#include<bits/stdc++.h>
using namespace std;

int solve(int n) {
    if(n == 1) return 1;
    return(solve(n - 1) + n);
}

int main() {
    int a;
    cin >> a;
    cout << solve(a);
    return 0;
}
```