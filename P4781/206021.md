### 题目的意思
就是有$n$个点$P_i(x_i,y_i)$，记经过这$n$个点的最多$n-1$次多项式记作$f(x)$，求$f(k)$的值

---
### 分析
这个多项式函数你要怎么来构造出来呢？

$Part1:$

很显然，对于这个多项式函数一定有：



$$ f(x)=\sum_{i=0}^{n-1} a_ix^i$$
上面的$a_i$为系数，$a_i$可以为$0$，毫无疑问，如果存在一个函数使得满足题意要求，那么这个多项式一定可以写成这种形式。且**满足将任意$x_i$带入多项式得到的一定为$y_i$** ，那么很简单的一个暴力就是你直接把这个每个$x_i$与$y_i$往里面带，最后进行高斯消元，然后求出了每一项的系数，然后要求解$f(k)$的时候算一遍就完事了。时间复杂度是$O(n^3)$的,对点对的限制并没有任何要求。

$Part2:$

这样我们画一个图，把每一个点$(x_i,y_i)$在$x$轴上的投影点，即横坐标$(x_i,0)$给保存下来，记作$H_i$，对于每一个$i$我们选择出对应点$P_i$，在这上面画一个经过它的曲线且让曲线在其他$x_i$位置，值取为$0$，然后由开始到后面曲线慢慢变化,然后使得构造出这个多项式函数$f(x)$。

是不是很抽象，摆一张示例图如下：

![](https://cdn.luogu.com.cn/upload/image_hosting/xjxcwk97.png?x-oss-pbrocess=image/resize,m_lfit,h_170,w_225)

如图所示黑线等于的是红线，绿线，蓝线三线加起来。


~~但其实你现在也不会很明白我在说什么，但其实并不重要，因为我也很乱~~

就你会得到$n$个$g_i(x)$满足$(1 \leq i \leq n)$使得在对应的$x_i$的取值为$y_i$，那么你构造出来的$g_i(x)$表达式应该就是像下面这样的:



 $$g_i(x)=y_i \prod_{j!=i} \frac{(x-x_j)}{(x_i-x_j)}  $$
 
 
这个是正确的，首先你可以知道$f(x)=\sum_{i=1}^{n}gi(x)$，你把每一个$x_i$带入都可以发现，在其他地方，它的取值都为0,而当它在$x_i$位置时可以取到$y_i$ ,所以相加后$x_i$的取值为$y_i$，所以最后满足经过点集$P$,所以公式就为:

$$ f(x)=\sum_{i=1}^{n}y_i\prod_{j!=i}    \frac{(x-x_j)}{(x_i-x_j)}$$
$$f(x)=\sum_{i=1}^ny_ig_i(x)$$

然后，就可以用暴力进行扫，在$O(n^2)$的时间求出所有系数，然后就可以进行计算了，不过我是按照$OI-Wiki$上没算系数，直接将$k$带进去算的。

然后这道题是需要进行逆元的求解的，相信这个应该都会，不会的可以滚粗了，用快速幂求解，先同时分别计算分子$s1$，分母$s2$，最后让$ s1=s1*power(s2,p-2) $这里的$power$为快速幂，$p$为模数。然后在$log$的时间完成，这一步复杂度总体为$O(nlog(p-2))$，所以总体复杂度为$O(n^2)$,当然，你也可以用线性求逆元，做得更严格。

示例代码：
```cpp
    for(int i=1;i<=n;i++){
	int a=y[i]%p;
	int b=1;
	for(int j=1;j<=n;j++){
		if(i==j) continue;
		a=a*(k-x[j])%p;
		b=b*(x[i]-x[j])%p;
	}
	ans=(ans+a*power(b,p-2)%p+p)%p;
     }
```

$Part 3:$

这是一种对点对有特殊要求的方法，**当且仅当$x_i=i$时适用**，这叫差分法。首先你可以把$x_i=i$带入之前的公式中去则有了：
$$f(x)=\sum_{i=1}^ny_i\prod_{j!=i}\frac{(x-j)}{(j-i)}$$
$$f(x)=\sum_{i=1}^ny_i\frac{\prod_{j!=i}(x -j)}{\prod_{j!=i}(i -j)}$$
对于分子，我们可以进行处理出如下两个东西:
$$pre_i=\prod_{j=1}^{i} (x-j)$$
$$suf_i=\prod_{j=i}^{n} (x-j)$$
不难发现分子即为:
$$pre_{i-1}*suf_{i+1}$$
对于分母，自己展开一下可以发现，这是一个断开了的阶乘形势，那么我们就用$fac_i$表达$i!$,但这里我们发现一件事，这个最后乘出来，**当且仅当$n-i$为奇数时**，这个符号要给它**加个负号**，那么分母的表达式即为：
$$fac_i*fac_{n-i}$$

最后得出结论：
$$f(x)=\sum_{i=1}^ny_i\frac{pre_{i-1}\times suf_{i+1}}{fac_{i} \times fac_{n-i}}$$
注意正负的特判，复杂度是线性的

代码先咕一波，年前补上。

$Part 4:$

关于拉格朗日插值公式，如果有一个点被我加入进来，那么我就需要重新计算一遍系数，如果有$n$个点待加入，那么复杂度就是$O(n^3)$的。于是，有这么一个东西，叫做重心拉格朗日插值法。
首先我们开始对式子进行简化:
$$f(x)=\sum_{i=1}^ny_i\frac{\prod_{j!=i}(x -x_j)}{\prod_{j!=i}(x_i -x_j)}$$

$$f(x)=\sum_{i=1}^ny_i\frac{\prod_{j=1}^n (x -x_j)}{\prod_{j!=i}(x_i -x_j)*(x-x_i)}$$
令$\omega(i)=\prod_{j!=i}(x_i -x_j)$
$$f(x)=\prod_{i=1}^n(x-x_i)\sum_{i=1}^n\frac{y_i}{(x-x_i)\omega(i)}$$
那么每次更新时，你只需要更新所有的$\omega(i)$就完事了，复杂度为线性的。

代码先咕一波，年前补上。

引用资料：

[OI-wiki](https://oi-wiki.org/math/poly/lagrange/)

[大佬博客](https://www.luogu.com.cn/blog/attack/solution-p4781)

[大佬博客](https://www.luogu.com.cn/blog/e-e-thinker/solution-p4781)