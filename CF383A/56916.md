不要怀疑这道题为什么紫，他不是代码难，而是思路难（~~假装很难~~）

首先这道题运用贪心思路，这一点应该明确；

那么，怎么贪？客官，莫急，往下看。

首先如果一个方向的奶牛已经全部被挤奶，那么对于剩下的另一方向（以面向左为例）的奶牛，只需要每次找到那个最右边的，挤它，那么这个方向所有的奶牛对答案的贡献就是
# **0**

多棒啊

所以我们就要先挤完同一方向的奶牛，然后按以上方向去挤另一方向

那么这同一方向如何去挤(⊙o⊙)？（以面左为例）

假设甲、乙两牛还没确定顺序，其他均已确定，且甲在乙左边

那么如果我们先挤甲，再挤乙，甲就会算在乙的答案，但先挤乙，再挤甲，乙就不会算在甲的答案里

而对于除甲乙外的牛无论甲乙顺序如何，都不会影响挤甲乙对答案的贡献

所以，对面向左的牛，我们先挤靠右的

贪心完成

仔细想想这就是统计了一下所有面左的牛的左边有多少面右的牛

AC代码

```
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
long long sum,ans;
int n,x;
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		scanf("%d",&x);
		if(x) sum++;
		else ans+=sum;
	}
	printf("%lld",ans);
	return 0;
}
```