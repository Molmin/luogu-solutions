个人认为这道题难度评分过于低下，感觉评个黑题都不过分！！！（自闭了好一会才会做>_<）

首先发现如果单次操作在第一个和第二个数列中都选择了超过一个数，那么答案肯定不是最优的（拆开来算显然更划算），所以最后删数的形式肯定是从一个数列中选了一个数，并在另一个数列中选了若干个数。

所以说高赞的那位上古老哥讲的“**所以当每次两个数列都只取一个数时结果最小。
但是，两个数列不等长，无法一对一消除。所以可能出现一对多的情况。**”是不对的！！

那么就可以设dp状态进行转移了！（这一步我又想了一好会>_<）。

这个dp还是蛮巧妙的，具体就是因为你只要求最优答案，所以那样子做是对的！

Q_Q




```c
#include<bits/stdc++.h>
#define ll long long
using namespace std;
int n,m,i,j,a[2010],b[2010],f[2020][2010];
int main(){
	scanf("%d%d",&n,&m);
	for(i=1;i<=n;i++)scanf("%d",&a[i]);
	for(i=1;i<=m;i++)scanf("%d",&b[i]);
	for(i=1;i<=n;i++)a[i]--;
	for(i=1;i<=m;i++)b[i]--;
	memset(f,44,sizeof(f));
	f[1][1]=a[1]*b[1];
	for(i=1;i<=n;i++)
	 for(j=1;j<=m;j++){
	 	if(i>1&&j>1)f[i][j]=min(f[i][j],f[i-1][j-1]+a[i]*b[j]);
	 	if(i>1)f[i][j]=min(f[i][j],f[i-1][j]+a[i]*b[j]);
	 	if(j>1)f[i][j]=min(f[i][j],f[i][j-1]+a[i]*b[j]);
	 }
	printf("%d",f[n][m]);
}
```
