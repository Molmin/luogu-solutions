本题解重点讲解构图的思路，请着重留意括号内内容。

奇奇怪怪的题目，考虑网络流。这里没有一个人多次使用的情况，且求的是最小，那么考虑最小割。

假设没有「合作」这样复杂的状态。对于一个人，存在「同意」和「不同意」两种状态，我们二者只取其一。并且有一个额外的花费存在于组内，建立于一个人同意且另一个人不同意的基础上。

先考虑单一的一个人：一个人要么同意，要么不同意，我们就建出一个点表示人，并且这个点分别往前面和后面的某个点连了一条边，表示「同意」和「不同意」（注意到我并不知道这个边的实际意义），并且保证我们的实际方案中，只割掉其中的一条边（**一个人不可能同意也不同意**）。

然后考虑组内人与人之间的关系，一个人选择「同意」，割掉了代表同意的边，但是在另一个人「不同意」的情况下还是造成了一定的不满值，这个不满值代表的边从「源点到汇点经过组内第一个人的点的路径」到了「源点到汇点经过组内第二个人的点的路径」上。注意到第二个人选择的是「不同意」（**这代表连向后面的边，代表的意义绝不是「同意」**），那么我们之前一个人连向前后的点的边的意义就清晰了。连向前面的点的边，代表的是「不同意」，边权 $d_i$；连向后面的点的边，代表的是「同意」，边权 $c_i$。第 $i$ 个人连向组内另一个人的边代表 $i$ 选择「同意」但另一个人「不同意」造成的不满值，流量为 $e_i$（另一个人流向 $i$ 的边也是要加上的）。

然后考虑「合作」这个状态（**这个状态理应不同于二者同时「同意」的状态，因此之前无论是「同意」或者是「不同意」都不该被割掉**，不要被两者「同意」是「合作」的基础这一想法束缚）。我们将组内两个人「不同意」的边指向同一个点，该点（在之后记作 $i$ 组的同意点）向后面的某个点连一条边，流量为 $c_i+c_{i+1}$。这个后面的点表示二人「合作」时的状态（**我们将二者「同意」与「合作」两种状态分割开的标准是，最终进行一个可行的割，二者同意会使这个新点留在 $T$ 集，否则会留在 $S$ 集**）。

验证一下只有一组的情况：

- 如果两者「合作」：割掉了 $c_i+c_{i+1}$ 边；   
- 如果两者皆「不同意」：割掉了 $d_i,d_{i+1}$ 两条边；   
- 如果两者皆「同意」，但不「合作」：割掉了 $c_i,c_{i+1}$ 两条边；   
- 如果 $i$「同意」但 $i+1$「不同意」：割掉了 $c_{i},d_{i+1},e_i$ 两条边。

容易验证，上面的割法可以使 $S,T$ 不连通，且意义与题目符合。

在做完组的基础上继续弄组与组之间的关系，处理这个关系的难点在于不知道到底从谁指向谁。考虑一个「喜欢」关系 $A \to B$：

- $A$ 没有和队友合作（没有割掉 $c_i+c_{i+1}$ 边），且 $B$ 选择了愿意（割掉了 $c_i$ 边），会产生 $a_i$ 不满值；   
- $A$ 选择了不愿意（割掉了 $d_i$ 边），但 $B$ 和队友合作（割掉了 $c_i+c_{i+1}$ 边），会产生 $b_i$ 不满值。

先考虑第一部分：既然 $A$ 组中，我们没有割掉 $c_i+c_{i+1}$ 边（**这代表了 $A$ 这一组前面的边已经被割到源点不能从 $A$ 组到汇点**），那我们只能选择从 $B$ 到 $A$。其中边为从代表 $B$ 这个人的点连向 $A$ 组的同意点，流量为 $a_i$ 的边（不连向同意点后面的点的原因是，这样无论同不同意都要求割掉这个边，且放在同意点不影响意义，还有答案……？）。

第二部分类似：$B$ 组割掉了 $c_i+c_{i+1}$ 边，我们又不好从 $A$ 直接导向 $B$ 组任意一个点（放在 $B$ 组同意点前会导致这条边没有意义，已经不连通；放在后面与意义不符合，这个边按道理来说一定要割），那么又是从 $B$ 到 $A$。我们建一条 $B$ 组同意点指向代表 $A$ 这个人的点，流量为 $b_i$。正确性分析类似于上面。

但是其实上面的做法只是保证了割特定边集的意义是正确的，我可能会避免关系导致的不满值，而让一个人同时「同意」和「不同意」。但是一组里面，一个人要么「同意」要么「不同意」，我们让选择「同意」/「不同意」花一点巨额花费，最后减掉就好了。也就是说记 $c_i' = c_i + ∞,d_i' = d_i + ∞$，一样的建边。只是最后答案要减去 $2n \times ∞$。

可以说是集网络流千万套路的题目。图可以自己手画懒了。

只给出关键的建图代码。

```cpp
int main(){
	n=read(),m=read();
	S=3*n+1,T=S+1;
	for(LL i=1;i<=2*n;i+=2)
	{
		LL cx=read(),dx=read(),ex=read(),cy=read(),dy=read(),ey=read();
		addEdge(S,i,dx+der),addEdge(S,i+1,dy+der);
		addEdge(i,i+1,ex),addEdge(i+1,i,ey);
		addEdge(i,(i+1)/2+2*n,cx+der),addEdge(i+1,(i+1)/2+2*n,cy+der);
		addEdge((i+1)/2+2*n,T,cx+cy+2*der);
	}
	for(LL i=1;i<=m;++i)
	{
		LL A=read(),B=read(),a=read(),b=read();
		addEdge(B,(A+1)/2+2*n,a);
		addEdge((B+1)/2+2*n,A,b);
	}
	LL ans=0;
	while(bfs())	ans+=Dinic(S,inf);
	write(ans-2*n*der);
	return 0;
}
```