首先容易发现这就是对杨辉三角（进行 $F(\cdot)$ 运算后）的前 $n$ 行求和。

$16$ 分的部分分直接 $O(n^2)$ 暴力计算就可以了。

由于 $53$ 分是正解的不够优秀的实现，因此直接讲正解。看到数据范围很大，尝试打表找规律。

打出来表后尝试几种方法求和。我的做法是对每行依次求和，会发现行和都是 $2$ 的幂。于是猜测规律在这个幂次上，并考虑合并相同的幂，于是只需要求出 $2^k$ 的个数就可以了。

由于 $F$ 是模 $3$，考虑三进制。表示完之后会发现一件事情：若第 $n$ 行的答案为 $2^k$，则 $k$ 是 $n$ 的三进制表示中 $1$ 的个数。

然后就是计数型数位 dp，设 $f_{i,j}$ 表示 $[0,3^i)$ 之中三进制有 $j$ 个 $1$ 的数个数（代码中的 `num` 数组），显然可以 $O(\log^2{n})$ 预处理（$i,j=O(\log{n})$）。

计算 $n$ 的答案时，考虑拆三进制位处理。首先记 $res_i$ 为 $[0,n)$ 中三进制有 $i$ 个 $1$ 的数个数。设 $n=3^ki+n'$，其中 $0 \le n'<3^k,i \in \{1,2\}$，则我们需要处理的是 $i$ 个末 $k$ 位取遍 $[0,3^k)$ 的整段的一个末 $k$ 位为 $[0,n')$ 的段的贡献。因此我们只需作一些整段的处理后将 $n$ 变为 $n'$ 继续处理。但是变为 $n'$ 时我们需要注意更高位的 $1$ 带来的影响，所以需要记录一个值 $vl$ 表示更高位中 $1$ 的个数。下面对 $i$ 的值分情况讨论。

$i=1$：我们需要计算 $[0,3^k)$ 对答案的贡献，即

$$res_{i+vl} \leftarrow res_{i+vl}+f_{k,i}$$

这是因为更高位贡献了 $vl$ 个 $1$。接下来，这一位会给后面的低位贡献一个高位的 $1$，因此需要 `++vl`。

$i=2$：我们先像上面一样计算 $[0,3^k)$ 对答案的贡献，接着需要计算 $[3^k,2 \times 3^k)$ 对答案的贡献，即

$$res_{i+vl+1} \leftarrow res_{i+vl+1}+f_{k,i}$$

这是因为当前处理的这段区间的首位上有一个 $1$。这一位不会给后面的低位贡献高位 $1$，故 $vl$ 不变。

容易发现上面的过程是 $O(\log^2{n})$ 的，故总时间复杂度为 $O(t\log^2{n})$。

$53$ 分部分分就是直接把上面的东西随便怎么处理一下就可以了。

Code:
```cpp
#include<cmath>
#include<cstdio>
#define rg register
#define ll long long
const int ntf=1732073999;
ll pw3[37];
inline int getb(ll x)
{
	int bt=int(log(x+0.9)/log(3));
	if((bt==30&&x>=pw3[31])||(bt==33&&x>=pw3[34]))++bt;
	if((bt==32&&x<pw3[32])||(bt==33&&x<pw3[33])||(bt==35&&x<pw3[35]))--bt;
	return bt;
}
ll num[37][37];
ll res[37],sum;
inline void solve(ll x)
{
	int tg=0,vl=0;
	while(x)
	{
		int bt=getb(x);x-=pw3[bt];
		for(rg int i=0;i<=bt;++i)res[i+tg+vl]=(res[i+tg+vl]+num[bt][i])%ntf;
		(x>=pw3[bt])?(tg=1):((tg)?(tg=0):(++vl));
	}
}
int t,b;
ll n,mxn;
int main()
{
	scanf(" %d %lld",&t,&mxn);
	num[0][0]=1,pw3[0]=1;
	while(pw3[b]<=mxn)
	{
		num[++b][0]=(1ll<<b)%ntf,pw3[b]=pw3[b-1]*3;
		for(rg int i=1;i<=b;++i)num[b][i]=((num[b-1][i]<<1)+num[b-1][i-1])%ntf;
	}
	while(t--)
	{
		scanf(" %lld",&n),sum=0;
		for(rg int i=0;i<=b;++i)res[i]=0;solve(n+1);
		for(rg int i=0;i<=b;++i)sum=(sum+(1ll<<i)%ntf*res[i])%ntf;
		printf("%lld\n",sum);
	}
	return 0;
}
```

补个结论的证明。

用 Lucas 定理，设 $n$ 表示成三进制数后有 $a_0$ 位为 $0$，$a_1$ 位为 $1$，$a_2$ 位为 $2$。对于某个 $m$，若 $m$ 的某一位上数值比 $n$ 对应位大，由 Lucas 定理知 $3 \mid \binom{n}{m}$。否则，$n$ 为 $0$ 的位置上 $m$ 只能为 $0$，对余数的贡献为 $1$。$n$ 为 $1$ 的位置上 $m$ 可能为 $0,1$，对余数的贡献均为 $1$，故对总和的贡献为 $2$。$n$ 为 $2$ 的位置上 $m$ 可能为 $0,1,2$，对余数的贡献分别为 $1,-1,1$，故对总和的贡献为 $1$。由乘法原理，$n$ 对总和的贡献即为 $2^{a_1}$。