挺妙的一道题，充分的体现了换个角度看问题的重要性。建议读者先看前面的部分，自己想后面的处理细节。

**提示：观察每个点的运动轨迹。**

如果你专注于整个图形的轨迹来看的话，那就会发现无法得到任何有用的结论。但是如果你专注于一个特定的点的话，很显然，它每次都会运动 **相同的增量**。

形式化地，设第一轮运动组成的点集为（$x_0=0,y_0=0$）
$$
P_1=\{(x_0,y_0),(x_1,y_1),\cdots,(x_n,y_n)\}
$$

设运动一轮的增量为 $a=\Delta x,b=\Delta y$，其中易得 $\Delta x=x_n,\Delta y=y_n$（因为一开始的点是 $(0,0)$）。

那么运动完第 $i$ 轮的点集为：
$$
P_i=\{(x_0+(i-1)a,y_0+(i-1)b),(x_1+(i-1)a,y_1+(i-1)b),\cdots,(x_n+(i-1)a,y_n+(i-1)b)\}
$$

答案为 $|P_1\cup P_2\cup\cdots\cup P_k|$。

--------------

后面的部分建议读者自行思考。

此时就可以推断出每一个点运动轨迹都是直线，并且斜率都为 $\displaystyle\frac{b}{a}$。

唯一需要处理的问题就是有些点可能走着走着就到了另一个点，这样就 **重叠** 了，贡献不能算 $k$。

考虑什么样的点会重叠，显然需要满足 $(x_1,y_1)=(x_0+da,y_0+db)$。

那么怎样处理呢？实际上可以用一个 `map` 来维护 $x\bmod a$ 和 $\displaystyle y-b\cdot\frac{x-x\bmod a}{a}$ 即可，理由就拿斜截式一次函数方程推一下就行，非常简单。

这样就可以把所有都压在一个 `vector` 里，并对它们的 $d$ 排序，可以得到答案为 $\sum\min(\text{相邻两个的 d 之差},k)+k$。

时间复杂度 $\mathcal{O}(n\log n)$。

----

下面有几个实现代码需要注意的细节：

+ 若 $a=0,b=0$，则直接用 `map` 统计答案。
+ 若 $a=0$，则将 $a,b$ 交换。
+ 若 $a<0$，则将 $a$ 取反。
+ 对 $a$ 取模注意 $x$ 为负数的情况。

[代码](https://atcoder.jp/contests/abc219/submissions/37748215)。