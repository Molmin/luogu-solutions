## 前言
挑战本题最短代码。
## 题意
给你一个字符串，判断是否能通过将这个字符串重新排列的方式使这个字符串变为由 $k$ 个相同字串组成的字符串。能就输出这个字符串，不能就输出 ```-1```。
## 思路
使这个字符串变为由 $k$ 个相同字串组成的字符串，那么就可以看做把每一种字母都平均地分成 $k$ 份，每一份都存在于一个小子串中。那么如何判断这能不能变成由 $k$ 个相同字串组成的字符串呢？只需要判断是否从“a”到“z”每一个字符都是否能被 $k$ 整除即可。如果全能，那么就可以的，一组一组输出即可。如果有一个不能，那么输出 ```-1```。
## Code
```cpp
#include<bits/stdc++.h>
using namespace std;
int k,i,f[10001],n,j;
char t,ch,s[10001];
int main(){
	scanf("%d",&k);
	scanf("%s",s);n=strlen(s);//读入+取出长度
	for (i=0;i<n;i++) f[s[i]]++;//计数，累计每一个字符出现次数。
	for (ch='a';ch<='z';ch++)
		if (f[ch]%k!=0){printf("-1");return 0;}//判断是否能正好分成k组
	for (ch='a';ch<='z';ch++) f[ch]/=k;//求出每组每一个字符的出现次数
	for (i=1;i<=k;i++){//一组组地输出
		for (ch='a';ch<='z';ch++)//遍历查找，进行输出
			for (j=1;j<=f[ch];j++)
				printf("%c",ch);
	}
	return 0;
}

```
