**Upd 2022.5.18 $\LaTeX$ 炸了一个**（描述 $b$ 的中间那里）  
**0.前言**  
写题解永远不会注重结论是什么，重头戏也不是如何推导结论，而是如何证明结论正确。  

**1.题意**  
[原题](https://www.luogu.com.cn/problem/CF1674D)  
给定一个数组 $a$ 问能否经过下列的操作使 $c$ 数组成为一个单调不减的数组。  
重复执行直到 $a$ 为空：将 $a$ 的最后一个元素取出并放入$b$ 的中间，其中 $b$ 的中间指 $b\{^{\text{ 的正中间（当}b\text{ 拥有偶数个元素）}}_{ \text{ 正中间元素的两侧之一的位置，可以自选左或右（当}b\text{ 拥有奇数个元素）}}$  
接下来，重复执行直到 $b$ 为空：将 $b$ 中间的元素（这里奇数个时指正中间，偶数个指正中间两个任选一个）拿出放入C数组的末尾。  
经过上述操作使C数组变得有序，可能则输出 `YES` 不可能输出 `NO`。  

**2.推结论**  
对于 $n=2$，$n=3$，$n=4$ 分别枚举所有情况：  
$n=2$：$\{a, b\}$ 可能变成 $\{a, b\}, \{b, a\}$  
$n=3$：$\{a, b, c\}$ 变成 $\{a, b, c\}, \{c, b, a\}$  
$n=4$：$\{a, b, c, d\}$ 变成 $\{a, b, c, d\},\{b, a, c, d\},\{a, b, d, c\},\{b, a, d, c\}$  
那么就可以进行一个初步的推测：相邻且这两个数后面有偶数个数的两个数在操作之后可能互换位置。  

**3.证结论**  
首先，我们不难发现，当 $n$ 为奇数的时候，数组第一个数被放进去时一定有偶数个数，只能放在正中间，然后就一定是最先拿出来的，放在 $c$ 数组的第一个。所以处理奇数个就等于第一个最小+去掉第一个处理偶数个。  
我们接下来只分析偶数情况。  
考虑接下来该放入 $a_{2i+1}$ 和 $a_{2i}$ 的时候。  
因为只考虑偶数情况，所以已经放入了偶数个元素。  
正中间正好有一个空位（固定的）可以放入 $a_{2i+1}$。而放入$a_{2i+1}$ 之后 $a_{2i}$ 一定在他左边或者右边（紧挨着）。  
同理可得它们之间会插入剩下的全部元素。  
最后取出的时候，它们两个一定在原来的两个位置上，但是顺序可能调换。  
对于排过序的数组，一定满足 $a_{2i}\le a_{2i+1}$。  
所以对于任意的 $a_{2i}>a_{2i+1}$ 就 $swap(a_{2i},a_{2i+1})$。  
然后判断交换完的数组是否完全等于排过序的数组（一一枚举）  
相等输出 `YES`，不等输出 `NO`。  
做完啦！放个代码（真的很简单，会了就不要看下面了）  
```cpp
#include<cstdio>
#include<queue>
#include<cstring>
#include<algorithm>

using namespace std;

int n, a[200005], b[200005];

int main() {
	int t;
	scanf("%d", &t);
	while(t--) {
		scanf("%d", &n);
		for(int i = 0; i < n; i++) {
			scanf("%d", &a[i]);
			b[i] = a[i];
		}
		sort(b, b + n);
		int I = 0;
		if(n & 1) I++;
		for(; I < n; I += 2) {
			if(a[I] > a[I + 1]) swap(a[I], a[I + 1]);
		}
		bool flag = false;
		for(int i = 0; i < n; i++) {
			if(a[i] != b[i]) {
				printf("NO\n");
				flag = true;
				break;
			}
		}
		if(!flag) printf("YES\n");
	}
}