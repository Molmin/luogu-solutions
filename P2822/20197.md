安利一发自己的博客：[http://www.cnblogs.com/OIerShawnZhou/](http://www.cnblogs.com/OIerShawnZhou/)

（我平常写的题解都会往博客里发，欢迎各位大佬前来拍砖）

做一次不爽一次。仅仅是对我去年考场上没想起来c(i,j) = c(i-1,j) + c(i-1,j-1)的垃圾行为而感到绝望的愤怒。

（LaTeX用得还暂时不熟练，各位谅解）

我实在是想不起来我当时是有多大的勇气，在这道题写完暴力不管不问的情况下就去刚T2T3。

如果您还没学排列组合，那这道题可能暂时不适合您来做。

如果您学过排列组合（高中数学选修2-3相关内容），应该对一个式子不陌生，就是我刚才在上面写的那个c(i,j) = c(i-1,j) + c(i-1,j-1)。

这是组合数的一个性质，要完成这道题需要用这个式子进行一下预处理。

暴力思想很简单，暴力算阶乘，暴力算组合。如果在暴力时稍加改进会如何？

看到n只有2000，所以可以考虑先把这个范围内的所有c[i][j]都先求出来，就用那个公式，全都推出来就好，边界是c[i][0] = c[i][i] = 1（依据组合数的性质）

这样我们就有了一个表。如果您学过排列组合，可以输出一下看看，这个表长什么样？

这可是杨辉三角啊！

实际上，为了求解方便，在推的时候可以把值对k取模，这样推出来后的c[i][j]如果是0，那么这个就是k的倍数。

按要求输出即可，这题到此结束。








哦？是吗？那你可只有90分啊。

后面那10分卡在哪里了？输出。

如果不加任何处理，在输出的时候我们也是要遍历一次c数组的，这个操作比较费时间。

既然c数组可以打表，答案为什么不可以？

令s[i][j]表示在所有的c(i,j) (1≤j≤i)的里面，为k的倍数的有多少个，那么处理数组的时候就是s[i][j] = s[i][j-1] ，每找到一个s[i][j]为0就让值+1。

按要求输出即可，这题到此结束。

行了，这次可以A了。

参考代码：

```cpp
#include <iostream>
#define maxn 2005
using namespace std;
int c[maxn][maxn];
int s[maxn][maxn];
int t,k,n,m;
int main(){
    cin >> t >> k;
    for (int i=1;i<maxn;i++){
        c[i][0] = 1;
        c[i][i] = 1;
        for (int j=1;j<i;j++)
            c[i][j] = (c[i-1][j] + c[i-1][j-1]) % k;
    }

    for (int i=1;i<maxn;i++)
        for (int j=1;j<=i;j++){
            s[i][j] = s[i][j-1];
            if (c[i][j] == 0)
                s[i][j]++;
        }

    for (int time=1;time<=t;time++){
        cin >> n >> m;
        int ans = 0;
        for (int i=1;i<=n;i++){
            int j = min(i,m);
            ans += s[i][j];
        }
        cout << ans << endl;
    }    
    return 0;
}
```