#### 要写出这道题，你需要掌握：

### 组合数与杨辉三角的关系、前缀和

//当然我说的是AC，如果只会前者也能90分

------------

AC代码：

```
#include <bits/stdc++.h>
using namespace std;
#define ll long long
ll t,flag[2002][2002];
int k,f[2002][2002];
void yh(){
	f[0][0]=f[1][0]=f[1][1]=1;
	for (int i=2;i<=2000;i++){
		f[i][0]=1;
		for (int j=1;j<=i;j++){
			f[i][j]=(f[i-1][j-1]%k+f[i-1][j]%k)%k;
			flag[i][j]=flag[i-1][j]+flag[i][j-1]-flag[i-1][j-1];
			if (f[i][j]==0) flag[i][j]++;
		}
		flag[i][i+1]=flag[i][i];//本篇题解的重点，这里想明白了这题就很简单了
	}
}
int main (){
	scanf("%lld%d",&t,&k);
	yh();
	while (t--){
		int m,n;
		scanf("%d%d",&n,&m);
		if(m>n) printf("%lld\n",flag[n][n]);
		else printf("%lld\n",flag[n][m]);
	}
	return 0;
}
```


------------

先说说一开始的思路。**不用任何高级做法就能拿到90这个看起来还能过得去的分数你敢信吗？**

同学们如果接触过杨辉三角，并且对它有一定的了解的话，一定会知道有这样一个性质：

**第n行的m个数可表示为 C(n-1，m-1)，即为从n-1个不同元素中取m-1个元素的组合数。**

所以在这道题里面，完全可以通过杨辉三角把需要用到的组合数给算出来，%k判一下存到数组 f[i][j] 里，若 f[i][j]==0,则计数器ans+1。最后输出ans的值就好啦。

那么怎么通过杨辉三角把需要用到的组合数给算出来呢？看代码。

```
void yh(){
	f[0][0]=f[1][0]=f[1][1]=1;//初始化前两行
	for (int i=2;i<=2000;i++){
		f[i][0]=1;//每行第一个都是1
		for (int j=1;j<=2000;j++){
			f[i][j]=(f[i-1][j-1]+f[i-1][j])%k;//这句很重要！！！【tip1】
			if (f[i][j]==0) flag[i][j]=1;//bool型的flag数组用来存f是否符合要求【tip2】
		}
	}
}
```
【tip1】因为杨辉三角的性质（上文提到过），组合数实际上是和杨辉三角里每个数一一对应的，那就可以将题目要求的组合数转化为杨辉三角了。

```
f[i][j]=f[i-1][j-1]+f[i-1][j];//不带任何优化的杨辉三角递推公式
```

但，杨辉三角到下面会变得很大，不带任何优化无疑过不了。题目中明确地说明了：只要统计满足是k的倍数的C(i，j)。

那么很显然，**先把k给%了再说啊**！！这样一来f数组里的数字小了很多，所以就是上面代码里的写法了。

【tip2】照应前面没放出来的主函数部分代码
```
for (int i=0;i<=n;i++){
	for (int j=0;j<=min(i,m);j++){
	    ans+=flag[i][j];//因为flag里现在符合要求的是1，不符的是0，所以直接加就好啦
	}
}
```

------------
看起来很有道理是吧？除去部分超大数据能拿不少分是吧？然鹅lz却拿到了美丽的50分。

![](https://cdn.luogu.com.cn/upload/pic/70880.png)
是不是很美腻qwq

为什么会50？看一眼圣诞树般的评测记录，结合数据范围，可以看出一开始的代码所有t是long long的点都WA了。检查，果然t开到int去了。

```
#define ll long long
ll f[2002][2002],y,ans,flag[2002][2002];
int t,k;// <=就是这里
```
超微扯出来一点，像“范围没开够”这种错误实际上并不少见，当只过了部分的时候，不妨好好看看数据范围。下图即为本题数据范围，很明显，只要是t过大的点就是红的。

![](https://cdn.luogu.com.cn/upload/pic/3457.png)

------------

改好这个，然后还是50.。。原来WA的点还是WA，下了数据（为了写文件输入输出对比还翻出了陈年笔记）。结果比答案大很多，由此推断是累加器出问题了。果然ans忘记在循环里初始化了。。。（过去最常犯的错误）

```
while (t--){
	ans=0;//一定不要忘记初始化！！！
    //……（中间代码略去）
	printf("%d\n",ans);
}
```
------------


于是90了，剩下要用前缀和只能现学：[一篇谁都能看懂的前缀和](https://blog.csdn.net/k_r_forever/article/details/81775899)

二维前缀和的公式：$ ans[i][j]$=$ ans[i][j−1] $ + $ ans[i−1][j] $ − $ans[i−1][j−1] $

**BUT!!!!你离成功还有一步！！！**（也正是这一步卡了我好久）

## 敲黑板，这是本篇题解最重要的部分，别的题解都没有写到。


#### 前方低能，请大佬光速撤离以免窥探蒟蒻的世界！没完全搞懂的童鞋们可以看过来了!

虽然AC代码开头就放过了，但不麻烦大家翻了，把重要部分再放一次：

```
void yh(){
	f[0][0]=f[1][0]=f[1][1]=1;
	for (int i=2;i<=2000;i++){
		f[i][0]=1;
		for (int j=1;j<=i;j++){
			f[i][j]=(f[i-1][j-1]%k+f[i-1][j]%k)%k;
			flag[i][j]=flag[i-1][j]+flag[i][j-1]-flag[i-1][j-1];
			if (f[i][j]==0) flag[i][j]++;
		}
		flag[i][i+1]=flag[i][i];//本篇题解的重点，这里想明白了这题就很简单了
	}
}
```
是的，重点就是“$ flag[i][i+1]$=$flag[i][i]$;”这句看起来简单的话，实际上，就算你会了前缀和，不加上这句话也A不了。

WHY?我们来看个实例感受一下就知道了。

![](https://cdn.luogu.com.cn/upload/pic/70898.png )

（鼠标写字丑，谅解一下。下面就用颜色来说了，如果有色盲或者色弱的同学lz表示抱歉）

以上三个输出的是什么呢，当输入k的时候，将代码中的flag数组前10x10 位打出来，此处k=5.

图1，是正确的写法，代码如下：（和前面差不多，此处只是为了输出比较，可以跳过这个代码不看）

```
void yh(){
	f[0][0]=f[1][0]=f[1][1]=1;
	for (int i=2;i<=2000;i++){
		f[i][0]=1;
		for (int j=1;j<=i;j++){//图3是j<=2000，为了把整个矩形打出来看
			f[i][j]=(f[i-1][j-1]%k+f[i-1][j]%k)%k;
			flag[i][j]=flag[i-1][j]+flag[i][j-1]-flag[i-1][j-1];
			if (f[i][j]==0) flag[i][j]++;
		}
		flag[i][i+1]=flag[i][i];//图1的写了这句重要的话，图2没写
	}//i是行数，j是列数 
	for (int i=0;i<=10;i++){
		for (int j=0;j<=10;j++){
			cout<<flag[i][j]<<"   ";
		}
	    cout<<endl;
	}
}
```
图2图3代码与图1的区别在上面代码的注释中

对比1、2的结果来看，从 j=6开始，输出就不一样了（米色笔圈出来的地方），**且2的输出要比1的小**。

为了方便说明原因举个栗子，如图中用白色光标点出来的部分（图1是7，图2是3）。为什么图2会比正确答案小呢？我们看看图3就知道了。图3中蓝笔圈出来的，就是图1没打出来的部分flag数组。

关注点转移到三个结果都用绿色笔圈出来的部分。由3可一看出，1中（绿色圈出来的）**右上角没打出来的其实是4**，（因为$flag[i][i+1]$=$flag[i][i]$，**这个4实际上是由空格处前一个的4转移来的**）；而因为没用这句话，**2中右上角的空格实际上是0**（没有进行过操作，就是flag数组的初值0）

如果将这个空格里的数设为x，白色光标的数设为y的话，那么由于flag中的数是由前缀和算出来的，y=x+4+7+4-4=x+4+7.如果没用这句话，那么结果就会像2中一样，反而比前面小。**范围大了反而符合要求的数字变少了，这很显然就是错误的。**

还有一点，为什么这个式子就是正确的？

既然要证实这个，我们不妨抛弃掉所以有技巧的方法，就用最最基本的公式死算暴力出答案看看是不是这样的，实验结果如下：

![](https://cdn.luogu.com.cn/upload/pic/70910.png)

（代码是第一篇题解里给出的30分代码，非lz自己写的，特此声明）

可以看出，$flag[i][i+1]$和$flag[i][i]$的的确确是一样的，那么$ flag[i][i+1]$=$flag[i][i]$就能合情合理且正确地用了。简单理解可以就把它认为是设置边界。

------------
完结撒花 ★,°*:.☆(￣▽￣)/$:*.°★* 。
