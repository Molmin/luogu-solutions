##对于本题，其实想法很简单，由于查询次数很多，n，m的值又比较小，我们可以打一个表再去询问每一个点;

#根据公式C[i][j]=C[i-1][j]+C[i-1][j-1],得到每个点的值

**注意要初始化并且每次对K取模(不取模能拿55分，取模不加优化就90分了，这个挺重要的)**


这里的表我们用F[i][j]表示F[n][1 to i];

##这样90分骗到手，时间复杂度O （T\*m2)

#另外10分怎么拿？

由于每次查询的时候我们会有重复计算，不如也打个表，这样每次直接取值，将复杂度降到O（T）；

###递推式可以写成C[i][j]=C[i-1][j-1]+C[i][j-1]-C[i-1][j-1],这样的递推关系是一个正方形，所以 J必须从1-->2000循环，否则会遗漏；

###另外也可以 C[i][j]=C[i][j-1],这里递推关系是线性的，j循环到i即可；注意每次 当F[i][j] == 0时 C[i][j]++;


#贴代码（第一种）

```cpp
cpp
#include<bits/stdc++.h>
using namespace std;
int t,k;
int f[2005][2005];
int c[2005][2005];
int main(){
    scanf("%d%d",&t,&k);
    for(int i=0;i<=2000;i++)f[i][0]=f[i][i]=1;
    for(int i=1;i<=2000;i++)
     for(int j=1;j<=i;j++){    
     f[i][j]=((f[i-1][j-1]%k)+(f[i-1][j]%k))%k;} 
     for(int i=1;i<=2000;i++)
      for(int j=1;j<=2000;j++)
     {c[i][j]=c[i-1][j]+c[i][j-1]-c[i-1][j-1];
     if(!f[i][j]&&i>=j)c[i][j]++;
     }
    for(int i=1;i<=t;i++){
    int n,m;
    scanf("%d%d",&n,&m);
    printf("%d\n",c[n][m]);     
    }   
}

```