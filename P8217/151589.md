题意：给出正方体字符画，求出有多少正方体。

换种思路，从侧面数。

如果我们知道每个侧面的位置 $(x, y)$（图中 `#`）以及与侧面那一**排**（左右相邻）正方体对应的字符 `.` 的数量 $c$，就可以求出这一排正方体的数量 $=\dfrac{y-c}{4}$。（侧面如图中 `#` 所示，相对应的字符 `.` 如图中 `@` 所示）

在第一幅图中，与被统计的侧面对应的 `.` 的个数为 $0$。

```plain
..+---+---+
./   /   /|
+---+---+#|
|   |   |#+
|   |   |/.
+---+---+..
```

```plain
....+---+........
.../   /|........
..+---+ |........
..|   | +---+---+
..|   |/   /   /|
@@+---+---+---+#|
./   /   /|   |#+
+---+---+ |   |/|
|   |   | +---+ |
|   |   |/   /| +
+---+---+---+ |/.
|   |   |   | +..
|   |   |   |/...
+---+---+---+....
```

但是，有时 `.` 会被正方体挡住，这时如何数呢？

```plain
....+---+---+....
.../   /   /|....
..+---+---+ |....
./   /|   | +---+
+---+ |   |/   /|
@@  | +---+---+#|
|   |/   /|   |#+
+---+---+ |   |/|
|   |   | +---+ |
|   |   |/   /| +
+---+---+---+ |/.
|   |   |   | +..
|   |   |   |/...
+---+---+---+....
```

由于重力，在每个 $1 \times m$ 的区域，最左侧的 $A_{i, 1}$ 个正方体一定是左对齐的，因此只要找到没有被挡住的、和被统计这排正方体左对齐的 `.` 就行了。（没有被挡住的、对齐的 `.` 如图中 `%` 所示）

```plain
....+---+---+....
.../   /   /|....
%%+---+---+ |....
./   /|   | +---+
+---+ |   |/   /|
@@  | +---+---+#|
|   |/   /|   |#+
+---+---+ |   |/|
|   |   | +---+ |
|   |   |/   /| +
+---+---+---+ |/.
|   |   |   | +..
|   |   |   |/...
+---+---+---+....
```

如何统计呢？由于重力，在每个 $1 \times m$ 的区域，正方体是像图中这样排列的，因此只要不断向左向上找 `.` 就行了。

```plain
..+---+........
./   /|........
+---+ |........
|   | +---+....
|   |/   /|....
+---+---+ |....
|   |   | +---+
|   |   |/   /|
+---+---+---+ |
|   |   |   | +
|   |   |   |/.
+---+---+---+..
```

时间复杂度：$O(\text{能过})$。

代码：

```cpp
int r, c;
char s[maxn][maxn];
int A;

bool isx(int x, int y) { return x >= 0 && x < r && y >= 0 && y < c && s[x][y] == '|'; }

int main()
{
    scanf("%d%d", &r, &c);
    for (int i = 0; i < r; ++i) {
        char ch = getchar();
        while (ch != '.' && ch != '+' && ch != '|' && ch != '-') ch = getchar();
        for (int j = 0; j < c; ++j) s[i][j] = ch, ch = getchar();
    }
    for (int i = 0; i < r; ++i) {
        for (int j = 0; j < c; ++j) {
            if (isx(i, j) && isx(i + 1, j) && isx(i - 1, j + 2) && isx(i - 1, j + 2)) {
                int x = i - 1, y = j;
                while (y && s[x][y - 1] != '.') {
                    if (s[x][y - 1] == '-') y -= 4;
                    else x -= 3;
                }
                A += (j - y) / 4;
            }
        }
    }
    printf("%d", A);
    return 0;
}
```