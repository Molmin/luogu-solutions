非常简单，~~我们甚至可以用视频里的教程做（猝不及防）~~

视频里怎么说的的？

> 学霸题

> 数正方体

> 头顶标数法

OK ，那么我们就用头顶标数法来做就好了（

首先是找头顶：遍历整个图找到所有的顶层（这个：

```
  +---+
 /   /
+---+

```

)

然后标数：判断一下这个顶层是第几层；

然后累计答案就可以了。

然后怎么判断第几层呢？

```
假设我们在这
 ->  +---+
    /   /
   +---+
  /   /
 +---+ 
 |   |

```

```
尝试沿棱向南方移动
     +---+
    /   /
-> +---+
  /   /
 +---+ 
 |   |

```

```
继续尝试沿棱向南方移动
    	 +---+
    	/   /
       +---+
      /   /
  -> +---+ 
     |   |
     |   |
     +---+

```

```
发现不能向南方移动，发现可以向下一层移动，同时这个块的高度+1，接下来继续尝试向南方移动
    	 +---+
    	/   /
       +---+
      /   /
     +---+ 
     |   |
     |   |
  -> +---+

```

然后一直移动到不能动就好了。

先以为是个大模拟，结果只有30行（

```
#include<bits/stdc++.h>
using namespace std;
int r,c,ans;
char mmp[2000][2000];
bool check(int x,int y){
	if(x+2>r||y-2<1||y+4>c||mmp[x+2][y-2]!='+'||mmp[x][y+4]!='+'||mmp[x+2][y+2]!='+'||mmp[x][y+1]!='-'||mmp[x][y+2]!='-'||mmp[x][y+3]!='-')
		return false;
	else
		return true;
}
int main(){
	cin>>r>>c;
	getchar();
	for(int i=1;i<=r;i++){
		for(int j=1;j<=c+1;j++)
			mmp[i][j]=getchar();
	}
	for(int i=1;i<=r;i++)
		for(int j=1;j<=c;j++){
			int x,y;
			if(mmp[i][j]=='+'&&check(i,j)){
				x=i,y=j;
				while(x+2<=r){
					while(mmp[x+2][y-2]=='+')
						x=x+2,y=y-2;
					while(mmp[x+3][y]=='+')
						x=x+3,ans++;
				}
			}
		}
	cout<<ans;
}
```
