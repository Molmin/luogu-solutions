## 思路
### 1、分析
这是一道 dp 题 ~~（大概还是比较容易看出来的吧）~~，状态有：时间、出逃情况、篡改的记录。时间这个状态可以用一个维度表示。出逃情况包含出逃总的次数和每次出逃分别的时间，每次出逃分别的时间——这看起来不太好维护。但是我们思考：状态的转移需要用到每一次的出逃时间吗？在状态转移时，假设我们要转移到第 $k$ 天，出逃次数为 $j$ 的状态，那么我们可以选择在某天出逃，那么就只要出逃次数为 $j-1$ 的状态；我们也可以选择不出逃，那么我们就需要当前出逃次数下的最后一次出逃的时间。

最后我们发现：**对于出逃情况，其实状态的转移只会用到总的出逃次数和最后一次出逃时间。** 所以我们：**记 $dp[k][i][j]$ 表示到第 $k$ 天，总共出逃 $i$ 次，最后一次出逃是在第 $j$ 天的这种状态下，最少的篡改记录次数。**

### 2、转移方程

这天不出逃：
$$dp_{k,i,j}=\min(dp_{k-1,i,j}+opt)$$
$opt$ 为 $a[k]$ 是否等于 $k-j$，是则为 $0$，否则为 $1$。

如果不出逃，就通过原有的出逃 $i$ 次的状态来转移；最后一次出逃是在第 $j$ 天，那么从第 $j$ 天开始，正确数据就是 $0,1,2,3\dots$所以到第 $k$ 天时正确数据就应该为 $k-j$，我们就只需要看第 $k$ 天计数器读数（$a[k]$）是不是等于正确数据（$k-j$），以此决定是否要在 $k-1$ 天、出逃 $i$ 次、最后出逃在第 $j$ 天的状态上加一；

这天出逃：
$$dp_{k,i,j}=\min(dp_{j-1,i-1,x}+opt)$$
$opt$ 为计数器读数从第 $j$ 天到第 $k$ 天，篡改数据的数量。

选择出逃，也就是说最后在第 $j$ 天出逃，那么状态就需要从到第 $j-1$ 天、出逃次数 $-1$ 的状态转移得来，在这些状态中取 $min$ 即可；由于最后是在第 $j$ 天出逃，所以从 $j$ 开始所对应的正确数据就是 $0,1,2,3\dots$那么就还得看计数器在从 $j$ 到 $k$ 的这段时间的记录否等于正确数据；若不是则篡改次数加一。

时间复杂度 $O(n^4)$，$n$ 很小只有 $100$，~~不用优化都稳稳当当~~能过，但是可以优化。

### 3、优化
我们发现在选择出逃状态转移需要用到从到第 $j-1$ 天、出逃次数 $-1$ 的状态最小值（这里最后一次出逃的时间是需要枚举的），那么我们可以用一个二维数组 $ans[i][j]$ 来存到第 $i$ 天，出逃次数为 $j$ 的所有状态中，篡改次数的最小值，这样就可以直接使用而不需要枚举。

除此之外在选择出逃状态的状态转移还需要用到当最后一次出逃是在第 $j$ 天时，计数器读数从第 $j$ 天到第 $k$ 天，篡改数据的数量（也就是从 $a[j]$ 到 $a[k]$ 与 $0,1,2,3\dots$不同的数据的数量），这个我们是遍历来求的，但是我们在开始 $dp$ 前可以预处理一下，用 $dif[i][j]$ 来存假设从第 $i$ 天出逃，到第 $j$ 天不发生新的出逃的数据与计数器读数不同数据的数量，也就是篡改数据的数量，这样在状态转移时就可以直接使用啦^_^。

时间复杂度 $O(n^3)$。

## 变量

$a[i]$：计数器第 $i$ 天的读数；

$dp[k][i][j]$：到第 $k$ 天，总共出逃 $i$ 次，最后一次出逃是在第 $j$ 天的这种状态下，最少的篡改记录次数；

$ans[i][j]$：到第 $i$ 天，出逃次数为 $j$ 的所有状态中，篡改次数的最小值；

$dif[i][j]$：从第 $i$ 天出逃，到第 $j$ 天（不发生新的出逃）数据被篡改了的数量。

## 代码
```cpp
#include<iostream>
#include<string.h>
using namespace std;
int N,a[108],dp[108][108][108],dif[108][108],ans[108][108];
int main()
{
	int i,j,k;
	cin>>N;
	for(i=1;i<=N;i++) cin>>a[i];
	memset(dp,0x3f,sizeof(dp));
	memset(ans,0x3f,sizeof(ans));
	dp[1][1][1]=(a[1]==0?0:1);
	for(i=1;i<=N;i++)
		for(j=i;j<=N;j++)
			dif[i][j]=dif[i][j-1]+(a[j]==j-i?0:1);
	for(k=1;k<=N;k++)
	{
		for(i=1;i<=k;i++)
		{
			for(j=i;j<=k;j++)
			{
				dp[k][i][j]=min(dp[k][i][j],ans[j-1][i-1]+dif[j][k]);
				dp[k][i][j]=min(dp[k][i][j],dp[k-1][i][j]+(a[k]==k-j?0:1));
				ans[k][i]=min(ans[k][i],dp[k][i][j]);
			}
		}
	}
	for(i=1;i<=N;i++)
		cout<<ans[N][i]<<endl;
	return 0;
}
//2023.5.9 by Jessica2333 ^_^
```
