### 1 题目分析
题目说在一个牛棚里有一个计数器，用来记录每一天有没有奶牛逃跑。  
假设今天是第 $i$ 天，如果今天有奶牛逃跑，那么计数器就为 $0$  。   
如果在第 $i-j$ 天有奶牛逃跑，那么计数器就为 $j$   。  
但是记录有可能被篡改，给定一个记录的数列（有可能被篡改过），求在有 $i$ 个奶牛逃跑时的最小被篡改量。  
### 2 思路
因为求的是最小值，我们可以想到 dp 。  
我们可以用 $dp[i][j]$ 表示到第 $i$ 天为止有 $j$ 头奶牛逃跑时的最小被篡改数量  。  
容易得出，对于每一个 $u(i<u<=n)$ ，有 $dp[u][j]=min(dp[u][j],f[i][j-1]+$ 第 $i+1$ 到第 $u$ 天的篡改量)  。  
如果在循环内求出第 $i+1$ 到第 $u$ 天的篡改量，那么时间复杂度是 $O(n^4)$ ，有点憋屈。那么我们考虑优化  。  
新开一个数组 $sum$ ， $sum[i][j]$ 表示如果第 $i$ 天有人出逃那么到第 $j$ 天位置有几个地方被篡改过  。   
那么我们可以 $n^2$求出每一个 $sum$ ，状态转移也变成了 $f[u][j]=min(f[u][j],f[i][j-1]+sum[i+1][u])$ 。    

最终时间复杂度 $O(n^3)$ 。  
### 3 code
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[110];
int sum[110][110];
int f[110][110];//f即dp
int main(){
    memset(f,127,sizeof(f));//初始值无穷大
    int n;
    cin>>n;
    for(int i=1;i<=n;i++) cin>>a[i];
    for(int i=0;i<=n;i++){//n^2预处理
        int cnt=0;
        for(int j=i;j<=n;j++){
            if(a[j]!=j-i) cnt++;//如果不一样计数
            sum[i][j]=cnt;
        }
    }
    f[0][0]=0;
    for(int i=0;i<=n;i++)//枚举i
        for(int j=1;j<=n;j++)//枚举j
            for(int u=i+1;u<=n;u++)//对于每一个u
                if(f[u][j]>f[i][j-1]+sum[i+1][u])  f[u][j]=f[i][j-1]+sum[i+1][u];//状态转移
    for(int i=1;i<=n;i++)cout<<f[n][i]<<endl;//输出
    return 0;//完结撒花！！！
}
```
