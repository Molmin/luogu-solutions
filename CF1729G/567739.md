- 很呆很显然，但是为什么没人这样写，难道真的是因为太呆了吗？

- 容易想到动态规划，于是开始设状态。令 $dp_{i,j,k}$ 表示 $s$ 串中前 $i$ 个，删了 $j$ 个的方案数，$k \in [0,1]$ 表示第 $i$ 个是原串中不删或删的某次的终点。

- 于是转移就出来了，令 $v_i$ 表示 $s_{i-m+1}$ 到 $s_{i}$ 这段是否等于 $t$ ，即这个位置是否是一次目标串在原串中的出现终点，我们有：

$$dp_{0,0,0}=1$$

$$ dp_{i,j,1}=\begin{cases}

dp_{i-m,j-1,1}+dp_{i-m,j-1,0} & j>0 & and & v[i]=1\\

\end{cases}$$

$$ dp_{i,j,0}=\begin{cases}
dp_{i-1,j,0}+dp_{i-1,j,1} & v[i]=0\\
\sum_{k=i-n+1}^{i-1} dp_{k,j,1} & v[i]=1\\

\end{cases}$$

答案就是 $i$ 和 $dp_{n,i,1}+dp_{n,i,0}$，其中 $i \in [1,m]$ 是满足 $\forall j \in[1,i-1]$， $dp_{n,j,0}=dp_{n,j,1}=0$ 且 $dp_{n,i,0} + dp_{n,i,1} >0$ 的最小整数。

这样我们就会 $O(n^2m)$ 了，直接就能过，跑得飞快，实测只跑了 $15ms$。

滚一下数组和前缀和就是时间 $O(n^2)$，空间 $O(n)$ 了。

- *2100 ？ *800 ！