### 0.样例解释：

它的样例输出是乱写的，就只是告诉别人要递增。

~~我还认真看了好久~~

### 1.题目分析

题目大意就是给你一个固定的图，要求你求出一笔画的要所有方案数。那么，图都给你了，还这么简单，怎么办？搜索即可。但这个题的搜索不是简单的暴力枚举每个起点，因为有一个美妙的结论：

如果一个无向图是连通的，且最多有两个奇点，则一定存在欧拉道路。如果有两个奇点，必须从其中一个奇点出发，另一个奇点终止。（一笔画定理）

然后知道这个结论，就可以愉快的搜索了。

```
#include<bits/stdc++.h>
using namespace std;
int n,mp[10][10],st[10];
void dfs(int s,int d){
	if(d==9){
		for(int i=1;i<=8;i++)
			printf("%d",st[i]);
		printf("%d\n",s);
		return;
	}
	st[d]=s;
	for(int i=1;i<=5;i++)
		if(mp[s][i]){
			mp[s][i]=0;
			mp[i][s]=0;
			dfs(i,d+1);
			mp[s][i]=1;
			mp[i][s]=1;
		}
}
int main(){
	mp[1][2]=mp[2][1]=1;
	mp[1][3]=mp[3][1]=1;
	mp[1][5]=mp[5][1]=1;
	mp[2][3]=mp[3][2]=1;
	mp[2][5]=mp[5][2]=1;
	mp[3][4]=mp[4][3]=1;
	mp[3][5]=mp[5][3]=1;
	mp[4][5]=mp[5][4]=1;
	dfs(1,1);
	return 0;
}
```

然后因为数据太小，我们可以选择一种更为前卫的方式：打表

```
#include<bits/stdc++.h>
using namespace std;
int main() {
	puts("123153452");
	puts("123154352");
	puts("123451352");
	puts("123453152");
	puts("123513452");
	puts("123543152");
	puts("125134532");
	puts("125135432");
	puts("125315432");
	puts("125345132");
	puts("125431532");
	puts("125435132");
	puts("132153452");
	puts("132154352");
	puts("132534512");
	puts("132543512");
	puts("134512352");
	puts("134512532");
	puts("134521532");
	puts("134523512");
	puts("134532152");
	puts("134532512");
	puts("135123452");
	puts("135125432");
	puts("135215432");
	puts("135234512");
	puts("135432152");
	puts("135432512");
	puts("152134532");
	puts("152135432");
	puts("152345312");
	puts("152354312");
	puts("153123452");
	puts("153125432");
	puts("153213452");
	puts("153254312");
	puts("153452132");
	puts("153452312");
	puts("154312352");
	puts("154312532");
	puts("154321352");
	puts("154325312");
	puts("154352132");
	puts("154352312");
}
```