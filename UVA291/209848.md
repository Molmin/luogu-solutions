## 题意：
题目要求从1开始一笔画完整个房子并且保证每条边只被画过一次，这题是一道很明显的欧拉路，也就是一笔画问题。欧拉是图论的鼻祖，解决过很有名的[哥尼斯堡七桥问题](https://baike.so.com/doc/5392559-5629390.html)。

### 判是否存在欧拉道路的方法：
![](https://cdn.luogu.com.cn/upload/image_hosting/u8wf6rlw.png)

不难发现，在欧拉道路中，“进”和“出”是对应的——除了起点和终点外，其他点的“进出”次数一个相等。换句话说，除起点和终点外，其他点的 **度数（$degree$）** 应该是偶数。很可惜，在七桥问题中（如图），所有四个点的度数均是奇数（这样的点也称奇点），因此不可能存在欧拉道路。上述条件也是充分条件——如果一个无向图是连通的，且最多有两个奇点，则一定存在欧拉道路。如果有两个奇点，必须从其中一个奇点出发，另一个奇点终止。
## 思路：
![](https://cdn.luogu.com.cn/upload/image_hosting/f8fjtrlq.png)

此题数据范围小，只有8条边，因此十分 $easy$，我们只要先按照题目建一个无向图：在1到5建一条无向边，在1到2建一条无向边，在1到3建一条无向边$······$我们可以发现只有1、 2两个奇点，根据判是否存在欧拉道路的方法，这个图存在欧拉道路且必须以1为起点，以2为终点（如果题目没有要求从1开始，可以以2为起点，以1为终点）。此题只用 $dfs$ 跑一遍就行了，详细做法见代码以及注释。

## 代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int n=5,m=8;//n是点数，m是边数 
int a[10][10],b[20],c[10][10];//a是个邻接矩阵，存储边的情况，b是访问各点的顺序，c是判断某一条边是否走过 
void dfs(int dep,int x)//在点x，正要走第dep条边 
{
	if(dep>m)//如果m条边都正好走过了 
	{
		for(int i=1;i<=m+1;i++)//输出经过的m+1个点，m条边会连接m+1个点 
			cout<<b[i];
		cout<<'\n';//听说\n比endl快？ 
		return;//结束这层递归 
	}
	for(int i=1;i<=n;i++)
		if(!c[x][i]&&a[x][i])//如果这条边没走过且能走 
		{
			b[dep+1]=i;//标记经过i点 
			c[x][i]=c[i][x]=1;//标记经过边x,i 
			dfs(dep+1,i);//在点i，正要走第dep+1条边 
			c[x][i]=c[i][x]=0;//走完再标记成没走过，以统计后面的路 
		}
}
void bian(int d,int e)//加一条连通d和e的无向边 
{
	a[d][e]=a[e][d]=1;
}
int main()
{
	ios::sync_with_stdio(false);
	bian(1,2);	
	bian(1,5);	
	bian(1,3);		
	bian(2,3);	
	bian(2,5);	
	bian(3,4);	
	bian(3,5);	
	bian(4,5);//按题目中的图片一样逐个加边 
	b[1]=1;//规定从1开始就先把第一个点赋成1 
	dfs(1,1);//从点1开始，正要走第1条边 
	return 0;
}

```

请勿打表或抄题解，这样只是浪费自己的时间和评测资源。题目就这样解决啦。