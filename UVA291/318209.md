[题目在此](https://www.luogu.com.cn/problem/UVA291)

## 补充一下
不难发现这是个图，还是个无向图，而且图也已经给了我们，那么，$dfs$不就能过么......

为了节省空间~~没必要啊~~，我把图和$dfs$的判断是否走过的数组放在了一起

## 思路
![](https://cdn.luogu.com.cn/upload/image_hosting/u9r87jkq.png)

数据范围极小，只要先建图，再$dfs$即可，而根据一笔画定理，起点必为1，终点必为2，就可以直接$AC$了~

## 代码

```c++
#include <cstdio>
int b[9];//存数字
bool a[6][6] = {
	{1, 1, 1, 1, 1, 1},
	{1, 1, 0, 0, 1, 0},
	{1, 0, 1, 0, 1, 0},
	{1, 0, 0, 1, 0, 0},
	{1, 1, 1, 0, 1, 0},
	{1, 0, 0, 0, 0, 1}//1代表不可通行或已走过，0代表可通行且未走过
};
void dfs(int x, int y) {//走到了编号为x的点，已经走了y条边
	if (y == 8) {//走完了8条边
		for (int i = 0; i <= 8; i++) printf("%d", b[i]);//printf比cout快
		putchar('\n');//据说这样会更快
		return;//真的不用加这一行，因为下面的循环if根本进不去
	}
	for (int i = 1; i <= 5; i++) {//遍历每个点，看能不能走
		if (!a[x][i]) {//两点连通且未走过
			b[y + 1] = i;//更新答案
			a[x][i] = a[i][x] = 1;//标记为走过（注意有两个要设置）
			dfs(i, y + 1);//下一层
			a[x][i] = a[i][x] = 0;//回溯
		}
	}
    	
}
int main() {
	b[0] = 1;//第1个一定是1
	dfs(1, 0);//从1出发，已经走了0条边
	return 0;
}
```

望管理员大哥通过~