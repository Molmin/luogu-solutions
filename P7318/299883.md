### 题意：
给定一个数列 $a$ 的前两项，且这个数列满足 $a_i=a_{i-2}\times a_{i-1}\bmod 10$。求此序列的第 $k$ 项。

### 思路：
乍一看题想到暴力递推，但是 $1\le k\le 10^{12}$ 让我们必定 TLE。但是还是能够得到 $30$ 分的部分分。代码量很小：

```cpp
#include<cstdio>
int n,m,k,a[1000001];
int main(){
    scanf("%d%d%d",&n,&m,&k);
	a[1]=n;
	a[2]=m;
	for(int i=3;i<=k;i++)a[i]=(a[i-1]*a[i-2])%10;
	printf("%d\n",a[k]);
    return 0;
}
```

但是在纸上随便写几组数据我们便发现我们可以找到数列中的规律。



比如：$n=2,m=2$ 的序列就是：$2,2,4,8,2,6,2,2,4,8,2,6,2......$。

循环节为 $6$。

继续往下推我们还会发现：

- 数字 $0,1,5,6$ 会死循环。
- 数列前两个数可能不属于循环
- 循环节不会超过 $6$。
- 只要连续两个数与之前某连续两数相同，说明找到了循环。

所以我们无需将序列全部递推出来。只需推出前面 $20$ 项左右并找出其循环节，再将 $k$ 取模即可。

由此，我们不妨进行如下操作：

1. 递推出此序列的前 $20$ 项。
2. 随意在此序列（除前两个数）找到连续的两个数充当基准数，然后向后循环查找。
3. 找到两个连续的数与基准数相同，求出循环节。
4. 将 $k$ 取模。

于是此题就变成了模拟。

### 程序如下：
```cpp
#include<cstdio>
#define ll long long
#define rll register long long
ll n,m,k,a[21],key1,key2,len;
int main(){
    scanf("%lld%lld%lld",&n,&m,&k);
    a[1]=n,a[2]=m;
    for(rll i=3;i<=20;i++)a[i]=a[i-1]*a[i-2]%10;//先递推法求出前20项
    key1=a[8],key2=a[9];//设a[8]和a[9]为基准数
	if(k<=20){//如果k小于等于20就没必要继续下面的操作
		printf("%lld\n",a[k]);
		return 0;
	}
    if(key1==key2&&(key1==0||key1==1||key1==5||key1==6)){//特判判0,1,5,6的死循环
    	printf("%lld\n",key1);
    	return 0;
	}
    for(rll i=9;i<20;i++)
    	if(a[i]==key1&&a[i+1]==key2){//循环查找循环节，如果查到了就与基准数下标相减得出循环节
    		len=i-8;
    		break;
    	}
    k-=7;//取模之前先减去循环节之前的部分
	k%=len;//取模
	printf("%lld\n",a[k+7]);//在数组中的下标还要加上循环节之前的部分
    return 0;
}
```
### THE END