## 一道并查集好题：思维难度：中，程序实现难度：简单

感觉翻译的不太好，因为不是$i$这个数能与$i±d[i]$交换，而是第$i$个格子中的数能与第$i±d[i]$个格子中的数交换。

大致题意：给你一串数字为$1$~$n$，然后告诉你每一个格子能与哪些格子中的数字交换，问你最后能不能得到给你的一组排列

本蒟蒻想了好久也没想出来，看到算法标签才顿悟：这个并查集藏得好深！

我们先证明一个东西：如果有一串数字，每相邻两个数字都可以交换，必然可以得到这组数字的所有全排列

我们先来看一组：

$ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ 位置：$1$ $ $ $2$ $ $ $3$ $ $ $4$ $ $ $5$

位置上的数：$1$ $ $ $2$ $ $ $3$ $ $ $4$ $ $ $5$

要得到的数：$5$ $ $ $3$ $ $ $1$ $ $ $2$ $ $ $4$

那么我们先考虑$1$这个数字，它如果要从第$1$个位置到第$3$个位置，必须先与第$2$个位置上的数字交换，然后与第$3$个位置上的数字交换，就能到第$3$个位置了！

$ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ 位置：$1$ $ $ $2$ $ $ $3$ $ $ $4$ $ $ $5$

位置上的数：$2$ $ $ $3$ $ $ $1$ $ $ $4$ $ $ $5$

要得到的数：$5$ $ $ $3$ $ $ $1$ $ $ $2$ $ $ $4$

现在我们再来考虑$2$这个数字，如果它要从第$1$个位置到第$4$个位置，就必须先和第$2$个位置上的数交换，然后和第$3$个位置上的数交换，然后再和第$4$个位置上的数交换，就可以到第$4$个位置啦！

$ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ 位置：$1$ $ $ $2$ $ $ $3$ $ $ $4$ $ $ $5$

位置上的数：$3$ $ $ $1$ $ $ $4$ $ $ $2$ $ $ $5$

要得到的数：$5$ $ $ $3$ $ $ $1$ $ $ $2$ $ $ $4$

这时候我们发现，$1$不在第$3$个位置了！那么我们再把$1$调到第$3$个位置：

$ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ 位置：$1$ $ $ $2$ $ $ $3$ $ $ $4$ $ $ $5$

位置上的数：$3$ $ $ $4$ $ $ $1$ $ $ $2$ $ $ $5$

要得到的数：$5$ $ $ $3$ $ $ $1$ $ $ $2$ $ $ $4$

那么这时候，$1$和$2$都已经调整好了，那我们看到$3$，把$3$用以上操作调到第$2$个位置

$ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ 位置：$1$ $ $ $2$ $ $ $3$ $ $ $4$ $ $ $5$

位置上的数：$4$ $ $ $3$ $ $ $1$ $ $ $2$ $ $ $5$

要得到的数：$5$ $ $ $3$ $ $ $1$ $ $ $2$ $ $ $4$

我们来检查一下$1$和$2$，发现$3$的调整没有影响到$1$和$2$，那么我们看到$4$

我们要把$4$调整到第$5$个位置，那么就会变成这样：

$ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ 位置：$1$ $ $ $2$ $ $ $3$ $ $ $4$ $ $ $5$

位置上的数：$3$ $ $ $1$ $ $ $2$ $ $ $5$ $ $ $4$

要得到的数：$5$ $ $ $3$ $ $ $1$ $ $ $2$ $ $ $4$

发现$1$、$2$和$3$的位置都被改变了，那么我们从右往左依次把$2$、$1$、$3$调整好，就会变成这样：

$ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ 位置：$1$ $ $ $2$ $ $ $3$ $ $ $4$ $ $ $5$

位置上的数：$5$ $ $ $3$ $ $ $1$ $ $ $2$ $ $ $4$

要得到的数：$5$ $ $ $3$ $ $ $1$ $ $ $2$ $ $ $4$

一对照，发现一样，成功啦！

那么我们总结出一条规律：$1$~$n$依次调整，每调整完一个数就检查前面的数，这样下来总归可以成功

那我们来看一下这道题：

他说第$i$个格子能与第$i±d[i]$个格子上的数交换

那我们不妨把所有能交换的格子排成一列，这样交换过程就变成了与相邻的格子交换，那如果$f[i]$这个数在这一列中，说明总归可以交换成功

这样一说，并查集就暴露了吧

把所有能交换的格子放在一个并查集里，最后检查$i$与$f[i]$是否在一个并查集里，这道题就$A$了！

上代码！$music$！

~~鸡你太美！oh，baby！鸡你太美！~~

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,fa[105],f[105],d[105];
int father(int x)     // 并查集基本操作之找爸爸
{
	if(fa[x]!=x) fa[x]=father(fa[x]);
	return fa[x];
}

void un(int x,int y)      //并查集基本操作之加一个爸爸
{
	int u=father(x),v=father(y);
	if(u!=v) fa[u]=v; 
}

int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
	{
	    cin>>f[i];     //在输入过程中顺便初始化一下
	    fa[i]=i;
	}
	for(int i=1;i<=n;i++)
	{
		cin>>d[i];
		if(i>d[i]) un(i,i-d[i]);    //在合并的时候一定要注意不要越界了
		if(i+d[i]<=n) un(i,i+d[i]);
	}
	for(int i=1;i<=n;i++)
	{
		if(father(i)!=father(f[i]))     //最后的判断
		{
			cout<<"NO"<<endl;
			return 0;
		}
	}
	cout<<"YES"<<endl;
	return 0;
}
```

还算比较好理解……把