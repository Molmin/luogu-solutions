本题解使用 **Floyd** 算法进行求解
### 思路
本题主要是求能否交换成给定的样式，

即原本的点 $i$ 能否交换成给定的点 $j$

聪明的我们可以把题目转换成

这幅图中点 $i$ 与点 $j$ 是否相通

所以我们可以采用 **Floyd** 算法求解
### Floyd 算法
1.时间复杂度 
$O(n^3)$

~~数据范围才100嘛~~

2.代码实现简单（三十行不到）

### 重点
1.Floyd 算法的本质是动态规划，$k$ 是阶段，$i$ 和 $j$是附加状态。

我们采用标记的方法

$b[i][j] = 1$ 表示从点 $i$ 可以到达点 $j$

那我们的问题马上就解决了

2.代码中有一部分**位运算**

1 与运算 (&)

两个位都为1时，结果才为1

e.g:

$b[i][k]$ & $b[j][k]$ 表示如果从点 $i$ 能到达点 $k$，并且从点 $j$ 也可以到达点 $k$，那么就可以从点 $i$ 到达点 $j$ 

（$b[i][k]$ & $b[k][j]$ 亦然）

2 或运算 （$|$)

两个位都为0时，结果才为0

我就不解释了吧……~~其实是我懒~~

### 上代码
```cpp
#include <iostream>
using namespace std;
int a[101], b[101][101];
int main() {
	int n, d;
	cin >> n;
	for (int i = 1; i <= n; i++) cin >> a[i];
	for (int i = 1; i <= n; i++) b[i][i] = 1; //b[i][j] = 1为从i点可以到达j点
	for (int i = 1; i <= n; i++) {
		cin >> d;
		if (i - d >= 1) b[i][i - d] = 1;
		if (i + d <= n) b[i][i + d] = 1; 
	} 
	for (int k = 1; k <= n; k++) {
		for (int i = 1; i <= n; i++) {
			for (int j = 1; j <= n; j++) {
				b[i][j] |= (b[i][k] & b[j][k]) | (b[i][k] & b[k][j]);
			}
		}
	}
	for (int i = 1; i <= n; i++) {
		if (!b[i][a[i]]) {
			cout << "No";
			return 0;
		}
	}
	cout << "Yes";
	return 0;
} 
```

#### 既然你看得那么认真，那就点个赞再走吧qwq