### $\text{Difficulty : 2000}$
---
### 解题思路：

首先可以知道的是，当整个数组连 $k$ 都不存在的时候，一定无解。那么接下来的所有文字都是建立在 $k$ 在序列中存在的前提下的。

考虑一些特殊的情况：如果这其中出现了两个连续的 $k$，那么直接由这两个往外拓展，每一次在这两个数的外围选择一个，就一定将中位数设置为 $k$，这样就能将所有的数都变成 $k$。

否则考虑转化为这种情况。将整个数组分成三种数大于 $k$ 的数，小于 $k$ 的数和 $k$。如果一个比 $k$ 大的数出现在了 $k$ 的旁边，那么选择这两个数就能将问题转化为之前的情况。而如果 $k$ 旁边有一个比 $k$ 小的数，再旁边又是比 $k$ 大的数，那么同样能转化为之前的情况。间隔更长就不行了。

从上面这些特殊情况可以发现，真正妨碍最后结果其实那些没有 $k$ 大的数，因为选择的时候中位数会向小的一侧偏移。那么，更一般地，考虑不比 $k$ 小的数的拓展。从上面的特殊情况可以发现当两个不比 $k$ 小的数的距离不超过 $2$ 的时候，就能够向外拓展到整个序列，那么也就一定能拓展到某一个 $k$ 的旁边。

综上所述，只要序列中有 $k$，而且存在两个不比 $k$ 小的数的距离不超过 $2$，就一定有解，否则一定无解。

---
如果对这个结论还不放心，可以将不满足上述的序列抽象为任意一个不比 $k$ 小旁边有两个连续的比 $k$ 小的数，那么无论怎么取区间都是不能使得中位数不比 $k$ 小的，也就是无解。

---
### 代码：

```cpp
#include<cstdio>
using namespace std;
int n,T,a[100005],k,last,flag;
int main(){
	scanf("%d",&T);
	while(T--){
		scanf("%d%d",&n,&k);
		flag=0;
		for(int i=1;i<=n;i++){
			scanf("%d",&a[i]);
			if(a[i]==k)flag=1;
		}
		if(flag==0){
			printf("no\n");
			continue;
		}
		if(n==1){
			if(flag)printf("yes\n");
			else printf("no\n");
			continue;
		}
		last=0;flag=0;
		for(int i=1;i<=n;i++){
			if(a[i]>=k){
				if(last!=0&&i-last<=2)flag=1;
				last=i;
			}
		}
		if(flag)printf("yes\n");
		else printf("no\n");
	}
	return 0;
}
```
