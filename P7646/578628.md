本篇题解的解题思路为使用单源最短路。
### 解题思路
本题和一般最短路问题的最大不同在于“超级管道”的出现。如果将“超级管道”中的点两两连边，边数会达到 $1e9$，显然会爆内存。考虑对于每条管道新建一个结点，从该点向管道中各点连无向边。这样从管道中每个点都可以通过该点而到达管道中另外一个点。新建的点的下标肯定会大于 $n$，所以可以很轻易的辨识哪些点是我们新建的。因为要求的是最少经过几个站台，所以最后跑最短路即可。
### AC代码
下面贴出**核心**代码，以引出下一段讲解。

```cpp
//核心代码如下
void dijkstra(){//朴素最短路 
	memset(dis,114514,sizeof(dis));
	dis[1]=1;q.push(node{1,1});
	//起点也得算上 
	while(q.size()){
		node t_=q.top();q.pop();
		int x=t_.p;
		if(vis[x])continue;
		vis[x]=1;
		for(int i=0;i<l[x].size();i++){
			int to=l[x][i];
			if(dis[to]>dis[x]+(to<=n)){
				dis[to]=dis[x]+(to<=n);//←Why?
				if(!vis[to])
					q.push(node{dis[to],to});
			}
		}
	} 
}
int main(){
	for(int i=1;i<=m;i++)
		for(int j=1,t;j<=k;j++){
			cin>>t;
            //建边操作
			l[t].push_back(i+n);
			l[i+n].push_back(t);
		}
}
```
注意到这段代码的第 $13(14?)$ 行被打上了 `Why?` 的注释。该语句是本篇题解讲解的重点。这是因为由题意从原有的点走到另一个未经过的原有的的点会将该点标记为已经经过，边权为 $1$，所以我们假设从原有的点走到通道新建的点的边权为 $0$（因为走到通道新建的点不计入到答案内），从通道新建的点走到一个原有的未经过点的边权为 $1$ （因为走到已给出的未经过的点需要计入到答案内），原有的点下标是 $\le n$ 的，所以如果该点下标 $\le n$，就计入到答案，就有了这条语句。
### 时间复杂度
建边之后有 $n+m$ 个点，$mk$ 条无向边（$2mk$ 条边），所以该做法的时间复杂度为 $\Theta\small(mk\log(n+m))$。