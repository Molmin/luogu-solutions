# 牛顿迭代 题解


比赛时一看题目，妙啊，前几天才看过牛顿迭代，于是果断把牛顿迭代写上去了

## 0、审题

题目大意：

已知 $n,a,b$ 

$k=floor(n^a+n^b)$

求以下两个方程的根之差

$x^a+x^b=(k+1)$

$x^a+x^b=k$

求解方程第一反应二分查找，然而这么做会各种超时XD

所以就需要用到牛顿迭代大法

## 1、牛顿迭代简介
牛顿迭代是用于求函数的零点的重要的方法，输入一个初始值，通过迭代，可以不断逼近函数的零点，换个角度来说，就是不断提高方程近似解的精度

**公式:**

### $x_{n+1}=x_n-\frac{f(x_n)}{f(x_n)'}$

来自百度百科：

>已经证明，如果函数是连续的，并且待求的零点是孤立的，那么在零点周围存在一个区域，只要初始值位于这个邻近区域内，那么牛顿法必定收敛

## 2、解题思路

既然题目给出了两个方程，那么这可以以n为初始值，通过牛顿迭代求近似根

首先把方程转换成函数的形式

$f_1(x)=x^a+x^b-k$

$f_2(x)=x^a+x^b-k-1$

再求导

$f_1(x)'=f_2(x)'=ax^{a-1}+bx^{b-1}$

然后套牛顿迭代公式写出如下代码

```cpp
int x=n,a_=a-1,b_=b-1;
for(int i=0;i<1000;++i)
	x-=(pow(x,a)+pow(x,b)-k)/(a*pow(x,a_)+b*pow(x,b_));
```

本来想着说慢慢减少迭代次数，结果减着减着发现只需要迭代一次就正确了

于是把for去掉上交了一次，TLE四个点，看样子还有优化的余地

中场休息吃个午饭，猛然醒悟，既然只迭代了一次，那么为什么不继续化简呢,于是就有了

### $ans=\frac{n^a+n^b+k}{ax^{a-1}+bx^{b-1}}-\frac{n^a+n^b+k-1}{ax^{a-1}+bx^{b-1}}=\frac{1}{ax^{a-1}+bx^{b-1}}$

这样一来就只要进行两次乘方了

成功AC，为了排名又把op=1的点特判了一下，优化常数时间复杂度，最终成功混到了同分中运行时间最短，++排名

## 3、最终代码

```cpp
#include<bits/stdc++.h>
using namespace std;
double n,a,b,sum=0;
int T,op;//我把生成器里的变量op拿出来了

//----------Mker我就省略了

void sol(){
	while(T--) Mker::read(n,a,b),sum+=1/(a*pow(n,a-1)+b*pow(n,b-1));
	cout<<sum;
}
void sol_(){
	while(T--) Mker::read(n,a,b),sum+=0.5/(a*pow(n,a-1));
	cout<<sum;
}
int main(){
	cin>>T;
	Mker::init();
	if(op) sol_();
		else sol();
	return 0;
}
```

运行时间([提交记录](https://www.luogu.org/record/23251811))
