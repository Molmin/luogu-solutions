### 题意

>小 A 有一个群。这个群正在玩一个小游戏：给出一个函数 $f$，从某一个时间点起，发送第 $x$ 条消息，而 $f(x)=1$ 的群友会受到一个小惩罚。当群内消息总数达到 $m$ 时游戏结束。
>
>但小 A 是个话痨，这段时间他在这个群发了 $n$ 条消息，他发的第 $i$ 条消息在整个消息记录里是第 $a_i$ 条消息。
>
>但是小 A 不想受到惩罚，而小 A 恰好是管理员，他可以撤回任何时刻、任何群成员发的任何消息，注意这会导致这条消息之后的消息排名改变。
>
>但是撤回消息太多容易被当成暴政，因此他要尽可能减少撤回信息次数，不管是自己的还是别人的。
>
>接下来你也猜到你要干什么了：假如其他群成员不操作，给出 $n$、函数 $f$ 和 $a_i$，求出他至少要撤回几条消息。

### 思路

题目要求的是小 A 不被惩罚。

因此我们直接针对小 A 被惩罚时的措施，来做分类讨论即可。

显然，当小 A 会受到惩罚时，只有两种解决办法，撤回他自己的消息，或是撤回他前面的人的消息。

而无论是哪种情况，对后面消息的改变都是一样的，都会向前移动。

而如果出现 $f_{i-1}=f_i=1$ 的情况，在撤回前面的消息后，小 A 仍然会受到惩罚。

综上所述，可以得到，撤回自己的消息是优于撤回他人消息的。

---

实现的话，我们考虑使用一个变量 $y$，记录前移的次数。

显然，小 A 的一条初始编号 $a_i$ 的消息的当前编号应为 $a_i-y$，因此只要遍历小 A 的消息 $a_i$，判断 $f_{a_i-y}$ 是否为 $1$，是则撤回，消息前移，对应的 $y$ 加 $1$，否则继续往后遍历。

最后的撤回次数，其实也就是前移的次数，只要输出 $y$ 即可。

时间复杂度 $O(n)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m;
int a[1000005];
int main(){
	cin>>n>>m;
	string f;
	cin>>f;
	f=" "+f;
	for(int i=1;i<=n;i++)
		cin>>a[i];
	int y=0;
	for(int i=1;i<=n;i++){
		if(f[a[i]-y]=='1')
			y++;
	}
	cout<<y<<endl;
	return 0;
}
```
