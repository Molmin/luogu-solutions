这道题很简单，本人觉得是这次月赛中最简单的题了。

首先看题目，当自己会受到惩罚时，小 A 很明显可以有两种操作，一种是撤回别人发出的，一种是撤回自己的。

容易发现，这两种操作都会使得撤回消息之后的小 A 发出的消息排名减少 1，而对撤回消息之前的消息没有影响，所以可以从小 A 发出的消息的第一条一次往后扫，如果自己发出的消息会被惩罚，判断是撤回这条消息之前别人发布的消息还是撤回自己发出的消息（不需要考虑之后的消息，因为不论你选择是撤回自己的消息还是撤回在自己消息之前的别人的消息，在这之后的消息排名都只会减少 1）。

其实撤回别人消息与撤回自己消息是本质上是一样的，对于后面的消息没有区别，都只是减去 1。

根据以上结论，即可写出一份模拟代码：

```cpp
for(int i=1;i<=n;i++){
	if(f[a[i]-1]=='1'){
		ans++;
		for(int j=i;j<=n;j++) a[j]--;
	}
}
```

但是很明显，这段代码时间复杂度是 $O(n^2)$,无法通过本题。

观察代码，只能在撤销消息后之后的消息排名都只会减少 1 这一模拟步骤进行优化。容易想到，变量` ans`，就代表已经撤销了多少条消息，从而将时间复杂度优化为 $O(n)$，通过此题。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,ans,a[100005];
string f;
int main(){
	cin>>n>>m>>f;
	for(int i=1;i<=n;i++) scanf("%d",&a[i]);
	for(int i=1;i<=n;i++)
		if(f[a[i]-1-ans]=='1')
			ans++;
	cout<<ans;
	return 0;
}
```
