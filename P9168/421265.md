看题目，如果没有修改的话不难想到一个贪心：把员工按照能力值排序，如果子树内还有空间就放进去，而为了避免安排员工的操作，我们把这里的“放”当做把当前节点储存的员工加一，查询的时候直接查询子树内的总员工。

可以证明这样的操作是正确的，只要是由这种操作构造的解法一定有一种安排方法，而一种合法的安排方法也一定可以以这种形式表示，而排序操作保证了最优性，因为没放进来的肯定整个子树所有数的能力值都比他高。

那带修改了怎么办呢，多次修改再采取这个操作的时间复杂度是 $O(nq)$ 的，发现排序和重新操作是我们的最大障碍，我们得考虑抛离了排序怎么做，考虑加入一个员工会对整颗树造成什么影响，类似上一步，只要子树内有空间无脑放，没空间就找子树内最小的扔出来再把它放进去。

又发现这个操作我们刚好可以通过树链剖分加上线段树实现，那剩下的就只剩删除操作了，发现每个员工有固定的出现时间段，直接套路转成线段树分治，时间复杂度 $O(n\log^3 n)$。