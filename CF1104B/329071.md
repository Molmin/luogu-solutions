[点我看题](https://www.luogu.com.cn/problem/CF1104B)

题目大意：
```
读入一个字符串。

有两个人，每个人每次可以消掉两个相连且相同的字符。

最终无法再一次消除的人输。

假设两人均采用最优策略，若先手会输则输出No，否则输出Yes。
```

看到各位dalao都详细的讲过了栈和判断奇偶性的写法，那我这个蒟蒻就来补充一种朴素的模拟的做法。

思路：~~显然是模拟题，没什么好说的~~。每一次操作时从头到尾扫描一遍，寻找能消除的字母。如果有，就消除之，换下一个人操作；如果没有，输出结果

方法（以一次操作为例）：

- $1.$ 从头到尾寻找是否存在两个可以消除的字符（连续且相同）；

- $2.$ 如果能找到，消除之，后面补上来，换下一个人操作；

- $3.$ 如果不能找到，退出循环，输出答案。

代码：

```cpp
#include<bits/stdc++.h>
#define LL long long//个人习惯 
using namespace std;
char s[100005];//s数组是当前的字符串（如题意） 
int ans=1,l;//ans是当前轮到哪一个人操作（1为A取，-1为B取），l是字符串长度 
int main()
{
	scanf("%s",s);//输入 
	l=strlen(s);//计算长度 
	while(1)//死循环 
	{
		int ok=0;//ok是由于储存是否存在两个可以消除的字符的（0为没有，1为有） 
		for(int i=0;i<l-1;i++) 
		{
			if(s[i]==s[i+1])//如果它们连续且相同 
			{
				for(int j=i;j<l-2;j++)
				{
					s[j]=s[j+2];//把后面的往前移，补上删除后的空位
				}
                //这里因为刚才那个循环时已经把消除的两个字母替换了（等同于清除了），所以就不用管了 
				ok=1;//找得到可以消除的 
				l-=2;//因为删除了两个字符，所以串的长度要减2 
				break;//退出查找 
			}
		}
		if(ok)ans=!ans;//如果找到了，变成下一个人操作  
		else break;//如果没找到，就退出循环   
	}
	if(ans)printf("No");//如果轮到A取时不能再取了，A就失败了
	else printf("Yes");//如果轮到B取时不能再取了，A就胜利了
	return 0;//结束程序 
}
```

$2021.1.3$ ：增加了一部分 $\LaTeX$ ，增加了注释并增加了一部分说明。