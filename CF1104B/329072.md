这题不就是一个消消乐吗，只是一次只能消除两个，判断是否能赢

由于不能消除了就输了，所以

#### 有能消的就会消，所有成对出现的字符都会被消掉

那我们统计能消掉的次数即可

由于中间的消掉了，两边的就相邻了，那么建立一个栈，按序存未被消掉的字符，栈顶就是最后一个未被消掉的字符，消掉后，下面的字符就成了栈顶，所以用栈很方便

操作方法：

每读入一个字符，就拿它和栈顶（上一个未被消除的字符）比较，如果相同，就删除栈顶（消除），如果不相同，就把它入栈（因为它成为了最后一个未被消掉的字符了）

代码如下：
```cpp
#include<bits/stdc++.h>//万能头
using namespace std;
char s;
int ans;
stack <char> x;//STL库里的栈
int main()
{
	cin>>s;
	x.push(s);//先把第一个放进去，不然会RE
	while(cin>>s)//边读边处理
	{
		if(x.size() > 0&&s == x.top())x.pop(),ans++;//相同
		else x.push(s);//不同
	}
	if(ans % 2 == 1)cout<<"Yes";//能胜利
	else cout<<"No";//不能胜利
	return 0;
}
```
