本题其他的题解过于简单，我来个**纯模拟**的题解。
### 前置知识
**模拟**即可。
## 分析题目

给定长度为 $n$ 的字符串，只包含 `L` 和 `R`。这是一个命令串。
有一个机器人会按照顺序执行字符串上的命令。它一开始在点 $0$。如果当前命令是 `L`，那么它会向**左**移动一单位距离。如果当前命令是 `R`，那么它会向**右**移动一单位距离。

机器人是**坏的**，它可能会只执行**一部分命令**，并且我们不知道机器人会执行哪些命令。您需要求出机器人执行完命令后**可能会停在的点的数量**。

根据题意模拟即可。

如 `5 LLRLR` 这组数据，模拟过程如下（以下 `LRR:1` 表示取 `LRR` 后 zoma 在 $1$ 处）：

$\begin{cases}1.'LLL':-3\\2.'LL':-2\\3.'L':-1\\4.'':0\\5.'R':1\\6.'RR':2\end{cases}$

不难得出：每组数据中，zoma 移动最左的时候（记作 $l$）是 `L` 的个数，移动最右的时候（记作 $r$）是 `R` 的个数：

$\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;-3\;\;\;\;\;\;\;\;\;\;\;0\;\;\;\;\;\;\;2$

$_____________|__________|______|__________________$$\Large_{>}$

其中，$l$ 至 $r$ 的所有点都可以到达（见上模拟过程）。

那么，代码应运而生！

## $Code:$

```cpp
#include <cstdio>
using namespace std;
int main(){
    char c;
	int n,left=0,right=0;
	scanf("%d",&n);
	for(int i=0;i<n;i++){
		scanf("%c",&c);
		if(c=='L') left--;
		else right++;
	}
	printf("%d",right-left+1);//别忘了加上代表0的点!
	return 0;
}
```
## $End:$

题解编号 $20200304$，总第 $15$ 篇。