[原题](https://www.luogu.com.cn/problem/AT4323)

#### 前置知识：

位运算。

#### 题意：

- 求 $A,\,A+1,\,\dots,\,B$ 的异或和。

- $0\le A\le B\le 10^{12}$。

为叙述方便，下文提到“第 $k$ 位”时默认是指二进制下的第 $k$ 位，且 $k\ge0$，即指 $2^k$ 这一位。

#### 分析：

暴力显然超时。我们可以直接从定义出发，计算 $A,\,A+1,\,\dots,\,B$ 的第 $k$ 位有多少 $1$，如果是奇数，则答案第 $k$ 位为 $1$，否则为 $0$。

进行差分。$A,\,A+1,\,\dots,\,B$ 中第 $k$ 位为 $1$ 的数量，即 $0,\,1,\,\dots,\,B$ 中第 $k$ 位为 $1$ 的数量减去 $0,\,1,\,\dots,\,A-1$ 中第 $k$ 位为 $1$ 的数量。

问题转化为在较快的时间内求 $0,\,1,\,\dots,\,X$ 中第 $k$ 位为 $1$ 的数的数量。

设 $X=2^{k+1}c+d$（$0\le d<2^{k+1}$）。

对于所有在 $[0,\,2^{k+1}c)$ 中的数：

- 如果数 $x$ 的第 $k$ 位为 $1$，则 $x-2^k$ 的第 $k$ 位为 $0$ 且也在这个范围内；

- 如果数 $x-2^k$ 的第 $k$ 位为 $0$，则 $x$ 的第 $k$ 位为 $1$ 且也在这个范围内。

容易发现 $x,\,x-2^k$ 是一一对应的，即第 $k$ 位为 $1$ 的数和 第 $k$ 位为 $0$ 的数是一一对应的。故这个区间内第 $k$ 位为 $1$ 的数的数量为区间大小的一半。

再考虑 $[2^{k+1}c,\,X]$ 中的数。容易发现 $2^{k+1}c$ 对答案并没有贡献，所以这一部分的数与 $[2^{k+1}c-2^{k+1}c,\,X-2^{k+1}c]$ 即 $[0,\,d]$ 等价。

分类讨论。若 $d<2^k$，显然所有数的第 $k$ 位均为 $0$，对答案贡献为 $0$。若 $d\ge2^k$，则 $[0,\,2^k)$ 中所有数第 $k$ 位为 $0$，$[2^k,\,d]$ 中所有数第 $k$ 位都为 $1$，$1$ 的数量即为这个区间的大小。

至此，我们就求出了 $[0,\,X]$ 中有多少数第 $k$ 位为 $1$。

#### 思路：

1. 根据定义逐位求解。

2. 分类讨论计算 $[0,X]$ 中有多少数第 $k$ 位为 $1$。

---

没有太多技巧，直接给出代码。

```cpp
#include <bits/stdc++.h>
using namespace std;
long long L, R, ans;	//记得开 long long
long long cal(long long x, int k) {
	if(x<0) return 0;	//L-1 可能为 -1，此时返回 0
	long long c=x>>k+1, d=x-(c<<k+1), res=0;
	res+=c<<k;	//即 c<<k+1>>1
	if(d>=1ll<<k) res+=d-(1ll<<k)+1;
	return res;
}
int main() {
	scanf("%lld%lld", &L, &R);
	for(int k=0; k<=40; ++k) if(cal(R, k)-cal(L-1, k)&1) ans+=1ll<<k;
	//如果 cal(R)-cal(L-1) 为奇数则累计答案
	printf("%lld", ans);
	return 0;
}
```