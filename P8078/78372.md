回顾一下这道我翻车的 DS... 越来越菜了

### 其他做法

两种根号做法大家应该都会，就不讲了。

算了还是提一下：分块就是考虑值域块知道前驱后继是可以合并的，变成了 Set Merging；莫队就是需要维护前驱后继，带删除容易用链表维护就回滚一下。

### 正解

说点前置转化，把这个过程想象为：我一开始身处 $[l,r]$ 中最小值的位置，需要在序列上走路去按权值顺序遍历 $[l,r]$ 这个区间，答案是我走的步数。

离线分治，$\operatorname{Solve}(l,r)$ 时解决跨越 $mid = \dfrac{l+r}{2}$ 的询问，也就是说如果这个询问是 $[L,R]$ 的话我把它劈两半，分别计算出在 $[L,mid]$ 与 $[mid+1,R]$ 中走的步数。

以 $[L,mid]$ 为例来说明，令 $N$ 为区间长度。假设我已经知道了区间中权值的大小顺序 $p_1,p_2, \ldots, p_{N}$ ($a_{p_1}<a_{p_2}<\ldots<a_{p_{N}}$)，那么我考虑相邻两个数 $p_i$ 与 $p_{i+1}$ 的贡献 $f(p_i,p_{i+1})$：

- 若 $a_{p_i}$ 与 $a_{p_{i+1}}$ 在询问区间 $[L,R]$ 中是相邻的两个权，则贡献为 $|p_i - p_{i+1}|$；
- 否则贡献为 $(mid-p_i)+(mid-p_{i+1})$。

我们把 $i$ 从 $mid \to l$ 扫，每次解决左端点为 $i$ 的询问。此时相当于添加一个元素 $a_i$ 同时维护贡献的增量，也就是 $f(P,S)-f(P,a_i)-f(S,a_i)$，其中 $P,S$ 分别表示 $a_i$ 在 $(i,mid]$ 中的前驱后继。

添数查前驱后继可以时间倒流 $O(N)$ 维护。那么我现在手上有 $O(N)$ 组 $f(x,y)$，需要对于左端点在 $i$ 的每个右端点 $R$ 求出这些 $f$ 的和。

现在需要找出合理的方式刻画「在 $[L,R]$ 中相邻」这个条件，不难发现可以使用「从左往右第一个值域在 $[p_i,p_{i+1}]$ 的位置 $>R$」来做，把它记为 $\operatorname{find}(p_i,p_{i+1})$。回到原问题，我们得到了 $f(x,y)$ 的取值：

$$
f(x,y)=\begin{cases}
2mid-x-y &\operatorname{find}(x,y)\leq R\\
|x-y| &\rm{otherwise}
\end{cases}
$$

统计在扫到 $L$ 之前加入、且 $\operatorname{find}(x,y)\leq R$ ($>R$) 的 $\sum f(x,y)$，明示离线二维数点。

可以使用树状数组维护，时间复杂度 $O(n \log^2 n+m \log n)$，也可以使用多叉线段树平衡复杂度至 $O\left(\dfrac{(n+m) \log^2 n}{\log\log n}\right)$。
