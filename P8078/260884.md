- 以前作者的措辞可能不太恰当，但是我觉得这是能够理解的，毕竟你如果生病了就希望世间无病，你退役了就希望大家能够实现自己的梦想，但是这终究只是愿望而已。
- 作者早已退役，但是，如果各位不嫌弃我的祝福的话，我希望大家不要留下遗憾。

**题意**
- [链接](https://www.luogu.com.cn/problem/P8078)。
- 给定一个 $1$ 到 $n$ 的排列，$m$ 次查询一个区间内的所有（区间内）排名相邻的数（对）位置的差（的绝对值）之和。
- $n,m\le 5\times 10^5$。

**分析**
- 容易得到 $O(mn\log n)$ 的做法，即对于每个询问暴力排序。
- 对于 $m=O(n^2)$ 的部分我们可以想到 $O(n^2\log n)$ 的做法：即用 $\text{set}$ 动态更新。
- 如果你学过莫队，只要你学过莫队，你就可以想到 $O(n\sqrt m\log n)$ 的做法，后面的基于删除操作可以用链表 $O(1)$ 维护的回滚莫队优化我都不讲，~~因为我也不会~~因为这不是本文的重点。
- 还有一种值域分块的做法，基于区间询问导致的块内本质不同的方案数在平方级别，好处是容易消耗空间做到在线，这里也略去~~因为我还是不会~~。
- 某位大佬曾经说过：“所以如果在分治结构上很难快速合并某些信息，我们就可以利用分块来做。”
- 反过来，我们如果想要用任何的分治结构做这道题，我们都需要发现一个性质，支持某种程度上比暴力更快地合并区间信息的性质。
- 如何找到支持合并的性质呢？在这之前我们先介绍一个简单的算法。

**猫树分治**
- [有关博客](https://www.luogu.com.cn/blog/command-block/yi-suo-chang-yong-di-shuo-ju-jie-gou-wei-hu-shou-fa)。

```cpp
- 选取所有询问都包含的某个位置,分别向左向右预处理某些东西。
- 对于询问的回答,只需要在左端点取信息,在右端点取信息,再组合即可。这要求(答案/状态)能够合并。
- 然后我们套用猫树分治,就能够处理更一般的情况了。
```

![](https://cdn.luogu.com.cn/upload/image_hosting/4n1p4sv5.png)
- 上图文来自大佬的博客，大佬高产似那啥。
- 这是我在刷大佬的博客中看到的最有希望的篇目（这是因为它只需要**一次**合并），但是它有一个要求：那就是信息能够支持某种意义上的快速合并（即使只需要一次，即使只需要前缀上均值能过），那这道题目是否满足这样的要求？

**性质**
- 我们同样通过 $O(n^2\log n)$ 的做法（或莫队做法），从单点信息的更新推出区间信息的合并。
- 为了方便，我把答案表示成一个链表的形式，横坐标（相对位置）代表其位置，纵坐标（相对位置）代表其大小，连线代表有贡献的相邻字符，答案就是每条连线在横坐标上的投影的和。
- 暴力（或莫队）的增删操作的形式是这样的，找到前驱和后继，然后更新距离的差值。
![](https://cdn.luogu.com.cn/upload/image_hosting/2ngp4o85.png)
- 让我们看看它对两个区间的情况吧。
![](https://cdn.luogu.com.cn/upload/image_hosting/cagvb83v.png)
- 所以我们至少可以看到：如果要快速合并两个区间的话，首先我们关心的是这样的一些数对，它跨过了左右两个区间，如果得到了这样的数对，我们即可支持合并。
- 接下来，我们发现：其实甚至数对我们都不需要，我们对原图劈一刀，我们很快发现我们只需要判断某个点**是否存在**比原序列更前的前驱和后继。
![](https://cdn.luogu.com.cn/upload/image_hosting/z849km1e.png)
- 等等，回忆猫树的过程（从分治中心向左向右预处理某些信息），而这个判断是满足单调性的，所以我实际上只需要在当前处理出让左/右端点存在更前的前驱/后继所需要的左/右区间所需要延长的长度，使用 $\text{set}$ 处理这个问题的复杂度是 $O(n\log n)$ 的，后面的操作相对常规~~对于作者除外~~：
- 对于具体的猫树分治（实现细节），先计算目标区间左边部分的贡献和右边部分的贡献，这里只考虑左边的贡献：
- 首先对目标询问排序。我们从分治中心暴力向左扫，用 $\text{set}$ 维护前驱后继形成的一个有序链表，然后我们考虑链表之间相邻元素对答案的贡献：
- 也就是考虑一条边的贡献，容易发现它分成两个部分：在这两个之间没有一个元素时候的贡献，在这两个之间至少有一个元素时候的贡献，涉及的区间加我们可以用树状数组维护，而查询本质上是一个区间查询操作，我们可以使用线段树。
- 接下来的操作就显得相当无脑，删边相当于删贡献，加边相当于加贡献，还有啥能比这个更简单呢？
![](https://cdn.luogu.com.cn/upload/image_hosting/vnjnk5ab.png)
- 以上操作的时间复杂度是 $O(n\log n)$，这意味着这个做法的时间复杂度是 $O(n\log^2n+m\log n)$。
- 若使用主席树代替那个维护区间加的树状数组则容易做到在线，只不过空间需求略大。

**代码实现**
- 为了表达作者对自己思维实现和代码能力的深刻反省~~同时照顾作者的码力~~，作者决定写多种复杂度的做法。

![](https://cdn.luogu.com.cn/upload/image_hosting/1nym1h20.png)
- 各位同志可以想象一下当时我看到这段文字的心情，来自[这篇](https://www.cnblogs.com/rainybunny/p/15851882.html)，那时我完全看不懂大佬在写啥。
- $O(nm\log n)$ 暴力做法：[代码实现](https://www.luogu.com.cn/paste/ja9updwx)。
- $O(n\sqrt m\log n)$ 普通莫队做法：[代码实现](https://www.luogu.com.cn/paste/rl59v6pi)。
- $O(n\sqrt m\log n/\log w)$ 压 $w=64$ 位 $\text{Trie}$ 维护普通莫队做法：[代码实现](https://www.luogu.com.cn/paste/1869nobo)。
- ~~数据是否太水~~，我觉得出题的时候把 $m$ 开大一点可以卡啊，不卡莫队它和莫队模板有啥区别。
- $O(n\sqrt m)$ 回滚莫队做法（_不加莫队_）：[代码实现](https://www.luogu.com.cn/paste/q333yn25)。
- $O(n\sqrt m)$ 值域分块做法（_Ynoi 风格的纯纯分块预处理_）：[代码实现](https://www.luogu.com.cn/paste/bdztwffm)（被卡常）。
- $O(n\log^2n+m\log n)$ 猫树分治（_polylog 的正解_）做法：[代码实现](https://www.luogu.com.cn/paste/amrdsmkz)（被卡常）。
- 综上，我认为回滚莫队才是此题正解，因为回滚莫队代码极短，而且过这题根本不需要卡常（或许是我的实现太菜了）。