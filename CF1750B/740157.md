## 题意

给定 $T$ 组数据，每一组数据包含一个 01 字符串的长度 $n$ 和一个 01 字符串 $s$。

定义：在该字符串之中，有 $x$ 个 $0$， $y$ 个 $1$。

字符串的价值 $val_s=\left\{\begin{aligned}
&x\cdot y\quad & x>0,y>0\\
&x^2\quad & x>0,y=0\\
&y^2\quad & x=0,y>0 \end{aligned}\right.$。

求给定字符串的子串 $t$，使其价值最大，输出该价值。

## 分析

对于所给的三种情况，可以分别取最大值并输出，所以模拟即可。

对于第一种情况：记录原字符串中的 $0,1$ 的个数，相乘并记录。

对于第二种情况，要使 $x^2$ 最大，必然要使 $x$ 最大，所以记录连续出现的 $0$ 的总个数，取其最大值。

对于第二种情况，要使 $y^2$ 最大，必然要使 $y$ 最大，所以记录连续出现的 $1$ 的总个数，取其最大值。

## 提示

如果你在 #5 出错了，可以查看一下 $n$ 的数据范围。

$n \le 2 \times 10^5$，所以 $x,y \le 10^5$，相乘或平方会爆 `int`，所以要开 `long long`。

如果你一个测试点也没有对，可以试一试“多组测试，清空数据”。

其余情况则应是程序内部构造出错，可以尝试静态查错，调试一下，也许是变量名引用错了呢。

### 实现

我们对于字符串的读入之后，按位去判断，等于 $0$ 或等于 $1$，记录出现字符总数和连续出现字符个数。如果与前一位不同，则将值归为 $1$，重新记录。

代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
int t;
string s;
long long n,s0,s1,c0,c1,z0,z1,ans;//记得开long long，n为字符串长度。s0，s1分别表示原字符串中的0,1个数。c0，c1记录当前连续出现的0,1个数。z0，z1记录0,1连续出现的最长长度。ans记录答案。
int main(){
	scanf("%d",&t);
	while(t--){
		ans=0,c0=1,c1=1,z0=1,z1=1,s0=0,s1=0;//多测清空
		scanf("%lld",&n);//scanf里的占位符也不能忘记更改
		cin>>s;
		for(int i=0;i<n;i++){//字符串是从第0位开始记录的
			if(s[i]-'0'==0){//如果当前位置是0
				s0++;//计数器增加一
				if(i!=0){//如果不是第0位，防止越界
					if(s[i-1]-'0'==0){
						c0++;//当前个数+1
						z0=max(z0,c0);//传参
					}
					else{
						z0=max(z0,c0);
						c0=1;//归成1
					}
				}
			}
			else{
				s1++;
				if(i!=0){
					if(s[i-1]-'0'==1){
						c1++;//当前个数+1
						z1=max(z1,c1);//传参
					}
					else{
						z1=max(z1,c1);
						c1=1;//归成1
					}
				}
			}
		}
		ans=max(ans,s0*s1);//第一种
		ans=max(ans,z0*z0);//第二种
		ans=max(ans,z1*z1);//第三种
		printf("%lld\n",ans);//输出的占位符别忘了
	}
	return 0;
}
```