>给定一个插有小写字母的合法括号字符串，从左到右扫描字符串
>- 如果遇到 ``(`` 就什么都不做
>- 如果遇到 ``)`` 就向前找到最远能匹配这个右括号的左括号，并将括号内的所有小写字母的值赋为 0
>- 如果遇到小写字母，若这个字母值为 1，就中止并输出 ``No``，否则将这个字母的值赋为 1 并继续向后扫。

此题最大的难点在于日语的翻译。

在得知题意之后，我们可以直接读入字符串，并从左往右模拟操作。

开一个 $0/1$ 桶存储二十六个小写字母的值，碰到小写字母就直接操作，碰到 ``(`` 直接无视。

如果碰到了 ``)``，则考虑向前找需要操作哪些小写字母。

考虑向前找到匹配的 ``(``。可以证明原题面所说最远的同级的 ``(`` 可以直接优化到最近的同级的 ``(``，向前匹配的过程中，扫到的所有小写字母全部赋为 0。

复杂度 $O(n^2)$，大概率是跑不过 $|S|\leq 3 \times 10^5$ 的。

考虑优化，一个非常基础的优化方案是右括号向前匹配的时候扫一个删一个，保证不会出现同一个字符被多次扫描的情况，在忽略 string 自带的  ``erase()`` 函数带来的影响后，时间复杂度是 $O(n)$ 的。

如果拿链表维护字符串的话，应该可以严格线性。

核心 Code：
```cpp
bool check()
{
    for(int i=0;i<s.size();++i)
    {
        if(s[i]=='(') ;
        else if(s[i]==')')
        {
            while(s[i]!='('){yt[s[i]]=false; s.erase(s.begin()+i); i--;}
            s.erase(s.begin()+i);i--;
        }
        else{ if(yt[s[i]]) return false; else yt[s[i]]=true;}
    }
    return true;
}
```

建议加上标签：模拟