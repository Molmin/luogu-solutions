## Discription  
给定一个由括号和小写字母组成的字符串 $S$ ，字符串有合法的括号匹配。现在给你一个盒子，对字符串进行顺序遍历，并同时执行以下操作，判断最后是否能顺利完成所有操作：  
1. 如果 $S_i$ 为小写字母，则把这个字母放到盒子中。如果这个字母已经在了盒子中，则操作失败。
2. 如果 $S_i$ 为 `)` ，则不进行任何操作。
3. 如果 $S_i$ 为 `(` ，则找到距离 $S_i$ 最近的字符 `(` ，并把这两个括号之间的子字符串的所有字母从盒子中拿出来。

## Solution  
本质就是一个括号匹配多了一些背景，不改变这是道栈入门题的本质。  
思路和括号匹配一样，顺序遍历字符串，将字符串中每个不是 `)` 的字符压入栈中，并且用一个布尔数组代表各个小写字母是否已经在盒子中。当读入 `)` ，就一直出栈，同时修改字母在盒子中的存在情况，直到遇到结束的 `(` 。如果能顺利遍历整个字符串且没有遇到失败情况，则成功。  
思维量实际只有 ABC 的 C 题。
## Code
```cpp
#include <bits/stdc++.h>
using namespace std;
int idx=0,i;
char st[300010],c;
bool alp[26];
int main()
{
	while((c=getchar())!='\n')
	{
		if(c=='(')
		{
			st[idx++]='(';
		}
		else if(c>='a' and c<='z')
		{
			if(alp[c-'a'])
			{
				cout<<"No";
				return 0;
			}
			alp[c-'a']=1;
			st[idx++]=c;
		}
		else if(c==')')
		{
			for(i=idx-1;;i--)
			{
				if(st[i]=='(')
				{
					idx=i;
					break;
				}
				alp[st[i]-'a']=0;
			}
		}
	}
	cout<<"Yes";
}
```
---
#### 22/12/29 Upd: 修复了代码问题，评论区 Hack 数据通过