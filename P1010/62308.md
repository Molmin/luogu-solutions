#####这道题其实不算难=-=

#####我的思路是这样的：

#####定义divide(int x)函数，其实就是本程序的核心了，这个函数先分解传进来的数，例如137就分解为[7,3,0]，再对每一项输出，如果不是0或1就再递归一层，否则输出2(0)或2，因为数据量不大，所以这样是不会超时的

#####具体见代码：

#####1、准备部分

```cpp
#include <iostream> //不解释
#include <cmath> //其中有log2(x)和pow(x,y)函数，具体作用往下看
using namespace std;
```
#####2、边分解边输出边递归的divide函数

```cpp
void divide(int x)
{
    bool flag = false; //...判断是否是第一个，如果是的话就不输出加号
    while (x != 0)
    {
        int t = int(log2(x));
        /*
        log2(x)这个函数求以2为底x的对数，例如log2(8)返回3，因为2^3=8
        而这里把返回值强制转换为int是为了找到离x最近又小于x的能表示为2^k的数
        例如int(log2(137))就能返回7，而2^7=128，恰为离137最近的能表示为2^k的数
        */
        if (flag) cout << "+"; //开头不输出加号
        if (t == 1) cout << "2"; //如果这一项是1，输出2，不递归
        else if (t == 0) cout << "2(0)"; //如果这一项是0，输出2(0)，不递归
        else
        {
            cout << "2(";
            divide(t); //递归一层，把括号里的数分解输出
            cout << ")";
        }
        x -= pow(2,t); //继续处理下一项
        flag = true;
    }
}
```
#####3.根本不需要解释的主程序

```cpp
int main()
{
    int n;
    cin >> n;
    divide(n);
    return 0;
}
```
#####完结撒花=-=
