**打表大法好！！！打表大法好！！！打表大法好！！！**

本题我用了一种奇怪（？）的打表方法。打表的思路跟之后的算法差不多。

因为2^14<n<2^15 所以打表是很方便的

思路是：把n减去最大的小于n的2的幂次方，然后把打的表用字符串记下。

注意：要把最后的加号删去。



```cpp
var
 a:array[0..15]of string;
 b:array[0..15]of longint;
 i,j,k,n,m:longint;
 s:string;
begin
 readln(n);
 a[0]:='2(0)';//1
 a[1]:='2';//2
 a[2]:='2(2)';//4
 a[3]:='2('+a[1]+'+'+a[0]+')';//8
 a[4]:='2(2(2))';
 a[5]:='2('+a[2]+'+'+a[0]+')';
 a[6]:='2('+a[2]+'+'+a[1]+')';
 a[7]:='2('+a[2]+'+'+a[1]+'+'+a[0]+')';
 a[8]:='2('+a[3]+')';
 a[9]:='2('+a[3]+'+'+a[0]+')';
 a[10]:='2('+a[3]+'+'+a[1]+')';
 a[11]:='2('+a[3]+'+'+a[1]+'+'+a[0]+')';
 a[12]:='2('+a[3]+'+'+a[2]+')';
 a[13]:='2('+a[3]+'+'+a[2]+'+'+a[0]+')';
 a[14]:='2('+a[3]+'+'+a[2]+'+'+a[1]+')';
 a[15]:='2('+a[3]+'+'+a[2]+'+'+a[1]+'+'+a[0]+')';
 b[0]:=1;
 for i:=1 to 15 do
  b[i]:=b[i-1]*2;
 for i:=15 downto 0 do
 if n>=b[i] then
  begin
   s:=s+a[i]+'+';
   n:=n-b[i];
  end;
 delete(s,length(s),1);
 writeln(s);
end.
```