由于本蒟蒻没学过递归，几次超时都没找出原因，终于，AC了......

这题其实挺晕的，（如果试图用脑子来模拟递归过程的话）

首先要看清题目：‘符合约定的n的0，2表示’

包括：2（2）、2、2（0）；

即只有4、2、1符合要求，其他一律要分解（递归）；

注意几点：

1、每次分解要记得将分解数t减少，分解完记得将总量n减少；

2、记得每次分解添加加号；

3、注意括号位置，第一次分解不用在前后加括号；

代码：

```cpp
#include<iostream>
#include<algorithm>
#include<cstdio>
#include<cmath>
using namespace std;
int n;
void ss(int n)
{
    int s=0,t1=0,t=0;//t1记得清零 
    while (n>0)//分解 
    {
        s=1;t=0;//每次s清1，t记得清零 
        while (s*2<=n)//算出0每次n能承受的2的最大次方数 
        {
            t++;//如果可以乘，记得加1 
            s*=2;//改变s值（*2） 
        }
        if (t!=0&&t!=1&&t!=2) {printf("2(");ss(t);n-=s;printf(")");}
        //如果不符合 2（2）、2、2（0），就用递归分解，分解完记得把n-相对应的s，注意不要漏掉括号
        //下面则是判断，符合，输出相对应的次方，记得把n-对应数s； 
        if (t==0) printf("2(0)"),n-=1;
        if (t==2) printf("2(2)"),n-=4;
        if (t==1) printf("2"),n-=2;
        if (n>0) printf("+");//n>0代表后面还要加，输出加号 
    }
}
int main()
{
    cin>>n;//输入n 
    ss(n);//运行ss 
    return 0;
}

```