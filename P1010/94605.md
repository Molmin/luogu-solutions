似乎没有题解详细讲位运算的

发一篇题解

首先，根据题目的137 = 2^7 + 2^3 + 2^0，我们可以发现其实对应着 137 的二进制

137的2进制就是  10001001

二进制中是1的下表从右往左数是  0   3   7
也对应着 2^0   2^3    2^7

所以不难想出，这道题就是转2进制，递归

对于每一个数，把他二进制下包含1的坐标递归然后输出

那么怎么找出一个数在2进制下某一位包不包含1呢？

首先，以137为例

137的二进制是 10001001，我们想知道它的第3位有没有1（从右往左，第一个下表是0）

我们可以将 137 & 1<<3

1<<3 在二进制下是 1000 （也就是1，然后后面添加3个零）

&上以后就会让1<<3的第3位跟137的第3位比，如果137的第3位是1，就返回一，否则返回零

不懂的话就看代码注释吧：


```cpp
#include <iostream>
#include <cmath>
using namespace std;
void f(int x)
{
	if(x==0)
	{
		cout<<0;
		return ;
	}
	int n = log(x)/log(2);   //判断一个数在二进制下的位数（log2(x) = log10(x) / log10(2)
	bool first = 1;  //判断一个数是否是第一次
	for(int i=n;i>=0;i--)   //因为输出要从大到小输出，所以for得反着来（否者的话位运算的下表是从右到左，会先输出 2(0) + ...
	{
		if(x&(1<<i))
		{
			if(i==1)      //如果是2^1次方的话，不用输出2(1)直接输出2，所以要特判
			{
				if(first)
				{
					first = 0;
					cout<<"2";
				}
				else

				continue;
			}
			if(first)
			{
				first = 0;
				cout<<"2"<<"(";
				f(i);
				cout<<")";
			}
			else 
			{
				cout<<"+"<<"2"<<"(";    //如果不是第一次的话就要前面加一个+号
				f(i);
				cout<<")";
			}
		}
	}
}
int main()
{
	int n;
	cin>>n;
	f(n);
	return 0;
}
```


