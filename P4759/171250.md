之前没看讨论中的翻译订正导致我算了最大数最小的情况，结果最后显示OLE， 经过六、七次修改、提交都没过 ，所以特地先提醒大家：

# 做题前一定先好好读题！！！！！

在这之后，这道题目的难度就会大大下降。首先假设将n分成i项，由于这i项是连续自然数，故他们的平均数的小数部分为0或0.5（自己试试，会发现 _**它们的平均数等于中位数**_ ）。

**若i是奇数，则n/i必定为整数**（n/i为各项的平均数，0.5乘以奇数不可能为整数），**若i是偶数，则n/i的小数部分必定为0.5**（偶数个连续自然数的中位数为中间两个数的平均数），从而我们得出只要满足：
    **((i%2==1&&n%i==0)||(i%2==0&&n%i==i/2))**
就能将n分成连续i项，但如果要满足这i项是自然数，还要保证n/i-i/2（i项中的最小数，i为偶数要+1）>=0（i为奇数>=1），可列出以下算式：**n/i-i/2>=0 -> i/2<=n/i -> i^2<=2n -> i<=sqrt(2*n)**

同时题目要求找最小数最大的情况，而n/i-i/2随i的增大而减小，所以i要**从小到大枚举**。

------------
 _代码如下：_ 

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,p,a[30000000],c,i,f;//开大点不会错
int main()
{cin>>n;
 for(int i=1;i<=n;i++)cin>>a[i];//读入
 for(int t=1;t<=n;t++)
   {p=floor(sqrt(2*a[t]));//确定取值范围
    c=0;//c=0表示无解，c=1表示i为偶数，c=2表示i为奇数
    for(i=2;i<=p;i++)//本题i要从小到大枚举
    //若要求出最大数最小的情况，i要从大到小枚举（证明较复杂）
      {if ((a[t]%i==i/2)&&(i%2==0))//情况1：i为偶数
         {c=1;
          break;
         }//i一旦满足情况1就停止
       if ((i%2==1)&&(a[t]%i==0))//情况2：i为奇数
         {c=2;
          break;
         }//i一旦满足情况2就停止
	  }
    if(c==0) cout<<"IMPOSSIBLE"<<endl;//判断无解
    else 
      {cout<<a[t]<<" =";
       f=c>1? a[t]/i-i/2:a[t]/i-i/2+1;//三目运算符判断情况1或2
       for(int j=f;j<=a[t]/i+i/2-1;j++)cout<<" "<<j<<" +";
       //空格是本题的又一难点
       cout<<" "<<a[t]/i+i/2<<endl;
       //i为奇数或偶数时，最大值均为n/i+i/2（代个值就知道了）
      }
   }
return 0;
}
```