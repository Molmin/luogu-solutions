# 数论推理题
### 对于这种类型的题目，还有[P1147 连续自然数和](https://www.luogu.org/problemnew/show/P1147)
### 因为P1147这题数据范围不大，所以之前我用前缀和加二分水过了。这题数据有10位，数组根本存不下，所以这题
## 必须要用纯数论分析！！！

####  首先可以设(L)+(L+1)+(L+2)+...+(R)=n,所以$\frac{(L+R)*(L-R+1)}{2}$=n,所以(L+R)*(L-R+1)=2n。 可以设k1*k2=2n,其中假设k1是较小的数，所以k1=(L+R),k2=(L-R+1),所以可以解方程得L=$\frac{k2-k1+1}{2}$,R=$\frac{k2+k1-1}{2}$，且k1！=1。 并且可以由L,R均为自然数，得出k1,k2一定为一奇一偶。

####  到达这一步后，相信大家都知道可以通过枚举k1来得出L,R，也就是最终的答案了。因为设的k1<k2（其中，对于k1=k2的情况，大家可以通过计算，发现若k1=k2，则L=$\frac{1}{2}$,所以不存在）。 又因为k1*k2=2n,所以可得出k1<sqrt(2n),所以枚举k1为2到sqrt(2n)，对于这样k1,可以由2n%k1得出k2是否为自然数，若是，则继续判断k1,k2是否为一奇一偶，若均符合，则说明已找到符合题意的答案，输出退出即可。

### 一些细节会在题解中体现。

```cpp
#include <bits/stdc++.h>
using namespace std;
long long i,j,t,n,l,r,k1,k2; //注意输入的数都用long long 定义比较保险
bool jc;
int main(){
	scanf("%lld",&t);  
	for (i=1; i<=t; i++){
	scanf("%lld",&n);
	jc=false;  //标记是否能找到答案
	for (k1=2; k1<=sqrt(2*n); k1++) //从2到sqrt（2n）枚举k1
	if (2*n%k1==0 && (k1+2*n/k1)%2==1) { //判断此刻的k1,k2是否符合要求
	jc=true; 
	k2=2*n/k1;
	l=(k2-k1+1)/2;
	r=(k2+k1-1)/2;
	printf("%lld = ",n);
	for (j=l; j<r; j++) printf("%lld + ",j);
	printf("%lld\n",r);
	break;  //对于符合要求的k1,k2,求出L,R,输出答案
	}
---------------------------------------------------------------------
其中，对于k1的枚举，要强调一下。
题意中说是求出最大数最小的情况，但翻译有错，实际是输出最小数最大。
由于最小数是L，所以要使(k2-k1+1)/2最大，由于k2,k1为反比例关系，
所以当k1小时k2大，（k2-k1+1）/2大，所以k1从小到大枚举。
---------------------------------------------------------------------
if (jc==false) {printf("IMPOSSIBLE");puts(" ");} 
//若不能找到答案则按题意输出不可能
	
}
return 0;	
}

```

## 纯数论推理，这应该是一篇简洁易懂的良心题解了。
### 对于这一类问题，还能用伸缩区间做，O(n)复杂度，但这题不能。感谢大佬WZJ的新思路。
```cpp

//使用伸缩区间
#include<bits/stdc++.h>
using namespace std;
int main(){
    int n;
    cin>>n;
    int l=1,r=0,sum=0;
    while(l<n){
        while(sum<n){
            r++;sum+=r;	
        }
        if(sum==n){
            cout<<l<<" "<<r<<endl;
            sum-=l;l++;
        }
        while(sum>n){
            sum-=l;l++;
        }
    }
    return 0;
} 

```