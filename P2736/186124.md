机房老师给找的题，没想到是个绿题dp，于是写个题解吧。

那么对于每一首歌，我们有三种决策方案：

1.不管这首歌

2.将这首歌刻在现在已经用过的但有剩余的唱片上

3.用一张新唱片去刻录这首歌

那这样就很清晰了，设dp[i][j][k]为前i首歌，用j张唱片，且该唱片可以用k分钟。

则有dp[i][j][k]=max

{

	dp[i-1][j][k] 不管这首歌
    
   	(k>=a[i])dp[i-1][j][k-a[i]]+1 刻在用过唱片上
    
    (k>=a[i])dp[i-1][j-1][t]+1 用一张新唱片去刻录这首歌(注意这里要从上一张唱片的最大歌曲数转移，也就是k=t)
}

其实这样我们就可以AC了，但是根据上面的分析我们发现这是个01背包，所以去考虑降维！（三维to二维）

将第一维去掉，因为我们发现转移方程都是第一维都是i-1，所以我们可以倒着dp，只保存最近的两个状态。

贴一下降维代码
```cpp
#include<iostream>
using namespace std;
int n,m,t,a[21],dp[21][21];
int main()
{
	cin>>n>>t>>m;
	for(int i=1;i<=n;i++) cin>>a[i];
	for(int i=1;i<=n;i++)
	for(int j=m;j>=1;j--)
	for(int k=t;k>=a[i];k--)//dp[j][k]表示j张唱片，第j张唱片用了至多k分钟所可以录下的最大歌曲数目 
	dp[j][k]=max(dp[j][k-a[i]]+1,dp[j-1][t]+1); 
	cout<<dp[m][t]<<endl;
	return 0;
}
```

