哇，前一篇题解写的挺复杂的…… 我来讲一个更简单的理解方法。

### 题目大意

有一个 $n \times m$ 的矩阵。求出它的**各个点走到 $(r, c)$ 这个格子的最短路径长度**（每一步只能往上、下、左或右走一格）中的**最大值**。

换个说法，求这个矩阵里离 $(r,c)$ 最远的一格走到 $(r, c)$ 需要几步。

### 做法

以样例 $2$ 为例。

![](https://tva1.sinaimg.cn/large/0081Kckwgy1glcmlu0f8mj30k80aq40l.jpg)

圆圈那个点就是 $(r, c)$，目标的格子。

那么离这个格子最远的肯定就是**四个在角落的格子中的一个**。（就是图上的 $4$ 个 `X`）。

左上角那个X离点O的距离是竖着的 $1$ 加上横着的 $3$，距离为 $4$。

右上角那个X离点O的距离是竖着的 $1$ 加上横着的 $1$，总和为 $2$。

剩下两个X同理。

那么离他最远的那个格子就是左上角（或者左下角）的那个格子了。

### 结论

格子 $(x, y)$ 与格子 $(r,c)$ 的距离（需要走的步数）是 $|x - r| + |y - c|$。

离 $(r, c)$ 最远的格子一定是 $(1, 1), (1, m), (n, 1), (n, m)$ （四个角落）中的一个。

他们到 $(r, c)$ 的距离分别是：

- $(1, 1): \ r - 1 \ + c - 1$
- $(n, 1): \ n - r + c - 1$
- $(1, m): r - 1 \ + m - c$
- $(n, m): n - r + m - c$

我们要求的就是 $\max\{r - 1 + c - 1, n - r + c - 1, r - 1 + m - c, n - r + m - c\}$。

不难发现，这个式子可以被简化为 $\max(r-1, n-r) + \max(c-1, m-c)$。

所以就可以写出我们的代码了。

### 代码

```cpp
#include <cstdio>
#include <iostream>
int t;
int main() {
	scanf("%d", &t);
	while (t--) {
		int n, m, r, c;
		scanf("%d%d%d%d", &n, &m, &r, &c);
		const int a = std::max(n - r, r - 1);
		const int b = std::max(m - c, c - 1);
		printf("%d\n", a + b);
	}
	return 0;
}
```