$n$ 个点 $m$ 条边的有根树森林，每棵树的根是其中编号最小的点，Alice 和 Bob 轮流选择一个没被删除的点并删除它以及它的所有祖先，问 Alice 是否必胜。

$1\leq \sum n\leq 2\times 10^5$，$0\leq m\leq n-1$。

SG 定理，每棵树之间独立，并且操作一棵树之后根一定会被删除，可以把 SG 值记录在根节点。设 $f_u$ 是以 $u$ 为根的子树的 SG 值，转移时如果删 $u$，那么会加入一种 $\oplus_{v\in son_u}f_v$ 的情况；如果删非根结点 $v$，那么会剩下 $v$ 到 $u$ 路径上每个点的所有子树去掉 $u,v$ 路径上除了 $v$ 结点以外的点的子树，即记 $g_u=\oplus_{v\in son_u}f_v$，会加入一种 $g_u\oplus_{w\in(u,v)\land w\not = u}(g_{fa_w}\oplus f_w)$ 的情况，去掉的原因是被已经删除了。

这样一来做法就很明了了，每个结点维护一棵 01Trie 表示子树内每个点到它的 $(g_{fa_v}\oplus f_v)$ 的出现情况，转移时把儿子 $v$ 的 Trie 全局异或 $g_u\oplus f_v$（处理边 $u-v$ 的贡献）再合并到 $u$ 上来，把儿子处理后合并到自己身上之后就可以把 $g_u=\oplus_{v\in son_u}f_v$ 插入 $u$ 点的 Trie，在树上二分求出此时的 mex 作为 $f_u$。

需要实现一个可以快速合并，单点插入，全局异或，查询全局 mex 的 01Trie，全局异或可以打个标记在 Trie 上，本质是交换了一些左右儿子。

时间复杂度 $O(n\log n)$。