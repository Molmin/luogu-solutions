这道题数据量小，爆搜都可以过了（5重循环，我试了可以AC），但是要多加优化！！！

核心代码：（其中都是0的情况在主程序中已处理，最小都是1）

```cpp
int search()
{
int k,x,y,i,j,f;
for(k=min(n,m);k>=2;k--)//穷举长度，如果2都不行就是1了
{
for(x=1;x<=n-k+1;x++)//穷举第一行
for(y=1;y<=m-k+1;y++)//穷举第一列
{
f=1;//做标记
for(i=x;i<x+k;i++)//枚举横坐标
{
for(j=y;j<y+k;j++)//枚举纵坐标
if(!a[i][j]){f=0;break;}//如果发现格子为0就提前结束
if(!f)break;//****不是全1的提前结束穷举，否则可能会超时
}//end for i
if(f)return k;//如果矩阵里全是1就可以返回k的值，提前结束了
}//end for x、for y
}//end for k
return 1;//min(n,m)~2都不行就一定是1
}//注意：*****如果穷举k=1，x、y就会穷举n^2遍，再加上i、j的判断，可能会超时
```