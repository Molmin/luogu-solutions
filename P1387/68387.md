题目分析：

本题方法非常多：

可以用搜索；可以用二分枚举边长；甚至可以不用二分直接枚举

在这里，我给大家讲一下动态规划的解法

本题采用动态规划的解法是最高效的

而且从代码长度来说，也是最短的

时间复杂度为O（n\*m），可以过1000\*1000的数据

如果其他方法这么大过不了，会超时

算法描述：

以当前这个点为右下角和它的左边、上面和左上三个方向有关

假设当前这个点的坐标为（x，y）

那么它所形成的最大长方形与（x-1，y），（x，y-1），（x-1,y-1）有关

动态规划方程式 f[i,j]:=min(f[i-1,j],f[i-1,j-1],f[i,j-1])+1;

限制条件（当前这个坐标值为1）

这个方程式在程序中会有体现

min(f[i-1,j],f[i-1,j-1],f[i,j-1])表示和它有关的最小的正方形

如果当前坐标值为1的话，那么便可以新成为一个原边长+1的正方形

1 1 1
1 1 1
1 1 1
最右下角的1关联的点已经包含了剩下的8个点

如果当前为1的话，就说明边长可以增加1

如果大家不是很好理解这个的话

我们把样例中的每个点为右下角所形成的正方形给求一遍

样例
4 4
0 1 1 1

1 1 1 0

0 1 1 0

1 1 0 1

值：
0 1 1 1

1 1 2 0

0 1 2 0

1 1 0 1

我们便可以很清楚的发现这个规律

程序解说：

```cpp
var n,m,i,j,max:longint;
    a,f:array[0..1000,0..1000] of longint;   //a数组存放矩阵，f数组存放以当前坐标点为正方形右下角的最大正方形边长
function min(x,y,z:longint):longint;  //求三个数里最小的
begin
min:=x;
if y<min then min:=y;
if z<min then min:=z;
end;
begin
readln(n,m);
for i:=1 to n do
  for j:=1 to m do read(a[i,j]);
for i:=1 to n do
  for j:=1 to m do
    begin
    if a[i,j]<>0 then f[i,j]:=min(f[i-1,j],f[i-1,j-1],f[i,j-1])+1;
    //如果当前的点为1，那么就可以用我们的方程式求出以它为右下角所形成的最大正方形的边长
    if f[i,j]>max then max:=f[i,j];
    //保存最大的边长
    end;
writeln(max);
end.
```
注：我看到楼下的大佬们大多数用的是C++，那我就发个Pascal的吧
如果题解写的不好，请多多包涵
