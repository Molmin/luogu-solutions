~~这题
有点水~~

7分钟代码时间然后1次就过了emm

思路很简单
预处理当前节点左边有多少连续的1
上面有多少连续的1

dp过程：
f[i][j]=min(f[i-1][j-1]+1,min(l[i][j],u[i][j]))

解释一下
f[i][j]是(i,j)处正方形的最大边长

l[i][j]是当前节点左边有多少连续的1(left的简写~~啦啦啦~~）

同理，u[i][j]是当前节点上面有多少连续的1(up的简写~~啦啦啦~~）


给组数据看看

1 1 1

0 1 1 

1 1 1 

对于（3,3）

左上（2,2）的最大正方形边长为1，如果继承这个正方形，最多（注意是最多）只能继承它的边长+1

（不然左上那个点就无能为力了）

然后还要确定当前这个节点是否可以完全继承左上的正方形//l[i][j],u[i][j])

如果不行的话那也只能放弃左上那个正方形的一部分

（不然当前这个点就无能为力了）

因为这里的动归目测是线性的

所以可以保证其正确性

然后记得要特判左上没有正方形的情况

来来来放代码


```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
int n,m,a[101][101],l[101][101],u[101][101],f[101][101],maxn=-1;
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			scanf("%d",&a[i][j]);
			if(a[i][j])
			{
				l[i][j]=l[i][j-1]+1;
				u[i][j]=u[i-1][j]+1;
			}
		}
	}
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			if(a[i][j]) 
			{
				f[i][j]=min(f[i-1][j-1]+1,min(l[i][j],u[i][j]));
				f[i][j]=max(1,f[i][j]);
			}
			maxn=max(maxn,f[i][j]);
		}
	}
	printf("%d",maxn);
}
```
