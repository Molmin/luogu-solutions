### 思路：动态规划
分析：

我们设有2个数组：$a$与$f$

$a$：
```
1 1 1 0
1 1 0 0
1 1 0 0
1 1 1 1
```
我们能知道，每个里头是$1$的至少能形成$1\times1$的正方形

$f$：
```
1 1 1 0
1 1 0 0
1 1 0 0
1 1 1 1
```
我们会发现：有些是很明显能构成正方形的；比如左上角的：$a$数组
```
1 1
1 1
```
则$f$数组会变成：
```
1 1
1 2
```
$f$数组的意思是：以该点为正方形的右下角的点时，可以形成最大的正方形。

所以上面的操作是：发现左，左上与上面都能构成的最大正方形为1，都有1格的空位，则因为这个点是1，使得这个部分可以构成的正方形为$2\times2$的，即$(1+1)\times(1+1)$的

既然这样，我们在dp时就会用到假面这个判断语句：
```
if(a[i-1][j-1]==1&&a[i][j-1]==1&&a[i-1][j]==1) ...
```
简化：（1为真，0为假）
```
if(a[i-1][j-1]&&a[i][j-1]&&a[i-1][j]) ...
```
或者这样：（$\because$ $a$中的最大值为1，所以和的最大值为3，仅当$a_{i-1,j-1}==1 \text{ and } a_{i-1,j}==1 \text{ and } a_{i,j-1}==1$时和为3）
```
if(a[i-1][j-1]+a[i][j-1]+a[i-1][j]==3) ...
```
再举个例子：

$a$：
```
1 1 1 1
1 1 1 1
1 1 1 1
1 1 1 0
```
$f$：

①
```
1 0 0 0
0 0 0 0
0 0 0 0
0 0 0 0
```
②
```
1 1 1 1
1 0 0 0
0 0 0 0
0 0 0 0
```
根据上面
```
1 1
1 1
```
在$f$中是：
```
1 1
1 2
```
③
```
1 1 1 1
1 2 2 2
1 2 2 2
1 2 2 0
```
等等，$f_{3,3}$不是$3$吗？：
```
1 1 1 1
1 2 2 2
1 2 3 2
1 2 2 0
```
好，$f_{4,3}$，会发现周围是2个2，1个3，应该选哪一个呢？

如果选3+1，就会有问题：
```
1 1 1 1
1 2 2 2
1 2 3 2
1 2 4 0
```
发现它的左边不能构成正方形，也就是说这是错误的，所以我们应该选2+1：
```
1 1 1 1
1 2 2 2
1 2 3 2
1 2 3 0
```
同理，最后$f$数组应该是这样：
```
1 1 1 1
1 2 2 2
1 2 3 3
1 2 3 0
```
转移方程：
```
f[i][j]=(a[i-1][j-1]+a[i][j-1]+a[i-1][j]==3?min(min(f[i-1][j-1],f[i][j-1]),f[i-1][j]):0)+1;
```
当然，当`a[i][j]`为0时，`f[i][j]`也为0，所以特判可以不要：
```
f[i][j]=min(min(f[i-1][j-1],f[i][j-1]),f[i-1][j])+1;
```
最后，注意答案不是`f[n][n]`，而是$f$数组中所有数的最大值

啰嗦了这么多，应该看代码了：
```
#include <iostream>
#include <stdio.h>
#include <cstring>
using namespace std;
#pragma GCC optimize("Ofast")
//快读与快输出
int input()
{
    int re=0; char c=getchar();
    while(c<'0' or c>'9') c=getchar();
    while(c>='0' and c<='9') re=(re<<3)+(re<<1)+(c^48),c=getchar();
    return re;
}
void print(int x)
{
    if(x<10) {putchar(x^48);return;}
    print(x/10);putchar((x%10)^48);
}
const int N=105;
int map[N][N],f[N][N],n,m,ans=-1;
int min(int x,int y){return x<y?x:y;}
int max(int x,int y){return x>y?x:y;}
int main()
{
    n=input(),m=input();
    int x,y;
    for(register int i=1;i<=n;i++)
    for(register int j=1;j<=m;j++)
    map[i][j]=input();
    //分开写让大家理解
    for(register int i=1;i<=n;i++)
    for(register int j=1;j<=m;j++)
    {
    	if(map[i][j]) f[i][j]=min(min(f[i-1][j-1],f[i][j-1]),f[i-1][j])+1;//dp
        ans=max(ans,f[i][j]);//取最大值
    }
    //其实可以写在一起省时间,为了清楚一点,多写几行
    print(ans),puts("");
    return 0;
}

```