这里是群论做法。

Soulist 聚聚发现了一个这种神仙结论题的一般解法。~~我只是一个搬运工。~~

**侵联删。**

不知道群论的可以看 [Soulist 的博客](https://www.luogu.com.cn/blog/Soulist/solution-p4980)

（到子群那个地方就和这篇题解无关了）

“不限制操作次数”意味着我们可以想到所有的字符串可以分成若干个等价类。

然后根据楼上的证明，字符串 S 能转换到 T 那么 T 肯定能转换到 S。

等价类里的字符串互相可达，而不同等价类的字符串互相不可达。

---

既然是群论，那么我们定义一下这个群的几个要素。

集合：就是这些等价类。

运算：从两个等价类中分别随便选两个字符串拼接所得到的字符串所在的等价类。

很绕口，~~建棵表达式树~~多读几遍应该读的懂。

虽然是随便选两个，但是一定在同一个等价类里。

注意这里字符串的拼接是有序的，且拼接一般不满足交换律。

有封闭性：显然。（你把两个字符串拼起来肯定还是一个字符串而不是变成一个奇奇怪怪的东西）

有结合律：显然。

存在单位元：显然是空串所在等价类。

存在逆元：考虑定义，一个元素存在逆元意味着它可以通过拼接上一个串变成单位元。

但你不可能把一个非空字符串拼成空串。

但是我们可以拼成空串所在的等价类。

在这个题中，每个等价类中肯定有一个全 A 或 B 的序列，然后再接几个 A 或 B 消一消就变成空串了。

---

直接搞这个群显然不行，我们可以考虑把它映射到我们熟悉的运算。

以这个题为例。

我们可以把它的操作翻译成下面三句话：

+ `A` 和 `BB` 在同一个等价类里。

+ `B` 和 `AA` 在同一个等价类里。

+ `AAA`、`BBB` 以及空串在同一个等价类里。

这三个等价类我们分别用 $X$、$Y$ 和 $E$ 表示，拼接运算就用 $\circ$ 表示。

根据定义 $E$ 是单位元。

然后就有：

$$X\circ X=Y$$

$$Y\circ Y=X$$

$$X\circ X\circ X=E$$

$$Y\circ Y\circ Y=E$$

显然上面的运算是满足交换律的，所以可以使用加法乘法异或之内的东西替代这个拼接运算。

接下来确定等价类个数更容易发现结论。

上面的四个式子随便带入一下就可以发现：

$$X\circ Y=E$$

即 $X$ 是 $Y$ 的逆元。

而只需 $X$ 和 $Y$ 进行运算就可以得到所有等价类。

所以每个等价类要么是单位元，要么可以只用含 $X$ 或 $Y$ 的运算就能表示。

但是两个 $X$ 进行运算就会变成 $Y$，$Y$ 也如此。

综上，**所有等价类只有 $E$、$X$ 和 $Y$**。

到这里我们就可以考虑映射了。

只有三个元素的运算是什么？

在 3 的同余系内的某个运算。

稍加带入就会发现加法符合所有条件。

把拼接映射到 3 的同余系内的加法，$E$ 映射到 0，$X$ 映射到 1，$Y$ 映射到 2。

于是乎预处理一下前缀和这题就没了。

嫌麻烦吗？

我也嫌麻烦。

但是对于某些类似神仙结论题十几个等价类还是在用人类智慧打表打出来的自动机上做转移来说。

这种方法好太多了。

代码：

~~放不放应该无所谓吧只要上面的看懂了。~~

```cpp
#include<bits/stdc++.h>
using namespace std;
const int _maxn = 100011;
int slen, tlen, q, pres[_maxn], pret[_maxn], a, b, c, d;
char s[_maxn], t[_maxn];
int main() {
    scanf("%s%s%d", s + 1, t + 1, &q);
    slen = strlen(s + 1);
    tlen = strlen(t + 1);
    for(int i = 1; i <= slen; ++i) {
        if(s[i] == 'A') {
            pres[i] = (pres[i - 1] + 1) % 3;
        } else {
            pres[i] = (pres[i - 1] + 2) % 3;
        }
    }
    for(int i = 1; i <= tlen; ++i) {
        if(t[i] == 'A') {
            pret[i] = (pret[i - 1] + 1) % 3;
        } else {
            pret[i] = (pret[i - 1] + 2) % 3;
        }
    }
    while(q--) {
        scanf("%d%d%d%d", &a, &b, &c, &d);
        if((pres[b] - pres[a - 1] + 3) % 3 == (pret[d] - pret[c - 1] + 3) % 3) {
            printf("YES\n");
        } else {
            printf("NO\n");
        }
    }
    return 0;
}
```