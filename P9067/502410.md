### Part1 前言

绝对不是刻意刷 Ynoi，只是感兴趣看一看然后秒了。

### Part2 寻找思路

我看到这道题最先想到的是 [[Ynoi2012] 梦断 SCOI2017](/problem/P5529)，然而这道题我并没有做过，本题颜色数如此之多，也肯定不能 ETT。

前几天写过一道侮辱智商的[题目](/problem/P3302)，本想着每 $\sqrt m$ 次询问重构一下，即可做到 $O(n\sqrt m\log_2n)$，结果发现只有 Link 而无 Cut 时可以启发式合并，于是轻松做到了 $O(n\log_2^2n)$，本题由于每次该颜色都是整个连通块一起改，所以不存在分裂连通块的情况，总共的合并次数不超过 $n-1$，当然必要时也可以启发式合并。

考虑一次改连通块颜色的操作，只可能将它与它父亲，或连通块下的其它连通块合并，和父亲合并只需要判断一下就可以，但我们需要快速找到连通块下特定颜色的连通块有哪些。

为了方便，可以用一个连通块深度最浅点来表示这个连通块，可以在这个点存储连通块下的连通块最浅点，为了快速查找，需要按颜色排序（显然不能直接 `sort`）。

在将连通块 $x$ 并到 $y$ 中时，连通块 $x$ 下的连通块就都会连到连通块 $y$ 下面，这时，我们需要进行一次合并。

如何寻找一个节点的连通块最浅点？

用并查集维护即可，这部分不用过多赘述。

### Part3 非暴力不可过解

我最先想到的是使用 `std::set` 来维护，当然是可行的，但是我们需要支持在合并连通块时合并两个 `set`，需要启发式合并。

这样时间复杂度为 $O(n\log_2^2n+(m+n)\alpha(n))$，空间 $O(n)$，不能通过，优点是码量小。

### Part4 非暴力可过解（正解）

这时，我们应当都想到了使用 01trie 合并来维护这个“连通块下连通块最浅点按颜色排序”，由于同种颜色的点可能有多个，这里有多种实现方式，我使用的是链表，由于链表插入、删除、合并都是 $O(1)$ 的，所以并不影响时间复杂度。

这时，时间复杂度为 $O(n\log n+(m+n)\alpha(n))$，空间 $O(n)$，可以通过。

### Part5 后记

很多较难的数据结构题或许并不需要多么高级的数据结构来维护，更多的是思维的练习，要能够想到。