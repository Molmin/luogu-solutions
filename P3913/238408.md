## 移行列，得矩形；求面积，算剩余




首先，肯定不可能模拟棋盘，因为数据范围太大了；

那么，就在行列上做文章。

题目要求我们求出被攻击的格子数，那我们先算出**不被攻击的格子数**，最后把棋盘的格子数减去它不就行了？


------------
如何算出不被攻击的格子数呢？

我们把每个棋子所在的行和列平移一下，会得到一个矩形。

**矩形所占的面积就是不被攻击的格子数**。

那我们只需要求出长和宽，其实就是求不被攻击的行数和列数。

------------

每个棋子都会攻击所在的行和列，$K$个棋子所攻击的行数和列数其实就等于$K-a$和$K-b$。

其中$a$为被重复攻击的行数，$b$为被重复攻击的列数。

**那我们的问题就变成了求a和b，也就是去重**


------------

一维数组的去重很简单，各种五花八门的方法都可以用，不再赘述。这道题我们用$sort$实现


------------

### 代码如下：
```
#include<cstdio>
#include<iostream> 
#include<algorithm>//调用algorithm库，以使用STL自带的sort函数
using namespace std;
const int maxn=1000001;//定义数组的规模
int cnt1[maxn],cnt2[maxn];//存储行、列
int main(){
	long long n,k,sum1=1,sum2=1,ans;
//sum1和sum2为被攻击的行数与列数，注意要初始化为1
	cin>>n>>k;
	for(int i=1;i<=k;++i){
		scanf("%lld%lld",&cnt1[i],&cnt2[i]);
//scanf能够加快读入速度
	}
	sort(cnt1+1,cnt1+1+k);//快速排序
	sort(cnt2+1,cnt2+1+k);
	for(int i=2;i<=k;++i){
		if(cnt1[i]!=cnt1[i-1]) sum1++;
		if(cnt2[i]!=cnt2[i-1]) sum2++;
	}
	ans=(n-sum1)*(n-sum2);//计算未被攻击的格子数
	cout<<n*n-ans;//输出被攻击的格子数
	return 0;
} 
```
