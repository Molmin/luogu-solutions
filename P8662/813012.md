### 
## 题意分析:
先用所属岛屿的编号标记所有陆地，再标记所有会被淹没的岛屿，统一淹没。最后统计剩余岛屿，相减即可得出被淹没数

------------
## 一些坑：
1. 如果一个岛被淹没变成两块陆地，它们仍然只算一个岛
2. 如果不先标记会被淹没的陆地，可能导致淹没本不该淹没的陆地

[题目传送门](https://www.luogu.com.cn/problem/P8662)
## AC 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[1234][1234],f[1234567][2],c[1234],h=1,c1,c2,fl;
int cx[5]={0,1,0,-1,0},cy[5]={0,0,1,0,-1};//用于上下左右移动 
char s[1234][1234];
void ranse(int x1,int y1,int s1){//x1,y1代表原坐标,s1代表岛屿编号 
	for(int i=1;i<=4;i++){//for循环遍历上下左右移动 
		int x=x1+cx[i],y=y1+cy[i];//用x,y代表新坐标 
		if(x>0&&x<=n&&y>0&&y<=n&&s[x][y]=='#'&&a[x][y]==0){//将移动控制在地图范围内，且为陆地，且并未被岛屿编号标记 
			a[x][y]=c1;
			ranse(x,y,c1);
		}
	}
}
int main(){
	cin>>n;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
			cin>>s[i][j];//读入s[i][j]
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
			if(s[i][j]=='#'){//如果是岛 ,则将岛上的全部陆地标记为岛的编号，用a[][]储存, c1作为编号 
				if(a[i][j]==0){
					c1++;//岛屿数++
					a[i][j]=c1;//全部标记 
					ranse(i,j,c1);
				}
				//一个岛会被淹没的判定:上下左右至少有一格海洋 
				for(int l=1;l<=4;l++){
					int x=i+cx[l],y=j+cy[l];
					if(x>0&&x<=n&&y>0&&y<=n&&s[x][y]=='.'){
						f[h][0]=i;//标记为会被淹没,之后统一淹，避免重复淹没其他陆地 
						f[h++][1]=j;//用f[][0]存i,f[][1]存j,h作为被淹判定的计数变量 
                      	break;//被标记就无须再找了
					}
				}
			}
	for(int i=1;i<h;i++)
		s[f[i][0]][f[i][1]]='.';//开始淹没 
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
			if(s[i][j]=='#')//如果还有陆地则利用岛屿标号的桶去记录还有多少个岛幸存
				for(int l=1;l<=c1;l++)
					c[a[i][j]]=1;
	for(int i=1;i<=c1;i++)
		if(c[i]==1) c2++;//将幸存岛屿统计 
	cout<<c1-c2;//最后有原来的岛屿数减去幸存的岛屿数,得到淹没的岛屿数 
	return 0;
}
```