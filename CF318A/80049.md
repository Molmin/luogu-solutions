虽然是一道入门题，然而奇特的数据量导致会TLE。那我们采取什么策略？说出来你不信：

### 能优化就优化！卡时间（主要是for加速）

奇特的是我竟然AC了：

	提交时间 2018-08-03 09:14:08
	耗时/内存 692ms, 16KB

不多说，开始讲思路：


------------


1） 最好用scanf和printf，因为这样比cin和cout更快~~（然而并无卵用）~~

2）位运算是能用就用，比如这里我们要判断n是奇数还是偶数，那么就用n&1的位运算判断。这里就很有必要跟广大新手说说&（按位与）

	   为什么行呢？因为n会转为2进制，只有0和1。而&是双方都是1，返回1，否则0，这样&1会很奇妙，不可忽略的是1前面的自动补0。举个例子：
      
		4&1->100&001->000
		3&1->11&01->01
		7&1->111&001->001
		10&1->1010&0001->0000

		结果很明显：奇数&1返回1，偶数并1返回0。∵奇数在二进制里的末尾一定是1，偶数则一定是0，加上（后者的）1前面的补0，那么前面一定是0，关键是最后一位，∴自行continue
     
3）说了这么多，为什么要判断奇偶呢？因为要**加速**，减少for循环量！取奇偶，主要是找出奇数序列与偶数序列的分界线，即**最后一个奇数**，再与k比较一下，如果k比分界线大，那就直接找偶数，反之亦然。至于分界线怎么求，自己想吧（很简单哟(＾Ｕ＾)ノ~）

4）不得不提的是，枚举奇数序列的初始值最好不要定1开始，因为奇数是从1开始算的，所以定1-2=-1，偶数亦然。当然具体情况还是要看你的循环是怎么算的。

------------

献上完整代码：
```cpp
#include<iostream>
#include<cstdio>
using namespace std;
typedef long long ll;//懒得打那么多long long
ll n,k,t,j;
int main()
{
	scanf("%I64d%I64d",&n,&k);//按题目要求来
	t=n/2+bool(n&1);//这里是个简写。根据规律可以知道，奇数序列的分界线总是比中间数的位置多1个，正好n&1为奇数时返回1，否则0，那就直接相加就好了。PS：C++奇数/2自动向下取整，因此直接除就好
//	(n&1?(n/2+1):(n/2));这是另外1种写法。条件表达式?:相当于if…else…
	if(t>=k)//跟k比一下看是在奇数当中还是偶数当中
	{//奇数部分
		j=-1;//注意初始值
		for(int i=1;i<=k;i++)
	     j+=2;
	} 
	else
	{//偶数部分
		j=0;//注意初始值
		for(int i=1;i<=k-t;i++)//枚举时注意枚举的个数是k-t，要减去前面的奇数个数
		 j+=2;
	}
	printf("%I64d",j);//按要求输出……
    
    while(1);
	return string::npos;
} 
```

~~上面2行什么东西我就不说了自己用脚趾想吧~~