## 前言

我选择复习一遍 【清华集训2014】主旋律

## 正文

首先，题意可以转化为给每一条边定向或不定向，然后把不定向的边缩起来后是个 DAG 的方案数。（缩点内部不能有有向边）

你考虑缩点这个条件不大好做，所以你选择枚举无向边以及缩完点后图的形状。我们见考察在新图上 DAG 的个数。下面所指的每个点均为缩完以后的新点。

--------

套路的考虑容斥原理，考虑设 $g[s_2][s_1]$ 表示 $s_1$ 中满足 DAG 的入度为 $0$ 的点的集合至少为 $s_2$ 的方案数，而 $f[s_2][s_1]$ 则是恰好。注意到 $f$ 不大好转移，我们希望借助 $g$ 进行辅助转移。

我们记录 $[$ $s_1$ 内部没有钦定的边 $]$ = $C(s_1)$。那么 $f,g$ 有值必须满足 $C(S)$ 为 $1$。（入度为 $0$ 的点不能互相连边）那么我们设 $f[s_1]=\sum_{s_2\in s1,s_2 \not = \emptyset}C(s_2)f[s_2][s_1]$。注意 $s_2$ 若为空集显然不成立，那么有转移：

$$
g[s_2][s_1]=C(s_2)f[s_1/s_2]
$$

这是因为我们钦定 $s_2$ 必须为入度为 $0$ 的点，存不存在其他入度为 $0$ 的点随意，因此可以直接从 $f[s_1/s_2]$ 转移。接下来：

$$
g[s_2][s_1]=C(s_2)\sum_{s_2\in s_3\in s_1}f[s_3][s_2]
$$

这个是根据 $f$ 和 $g$ 定义列的式子。观察到若 $C(S)$ 为 $1$，则对于 $T\in S$，$C(T)$ 也为 $1$。这是因为 $S$ 里面没有未钦定的边的限制强于 $T$ 里面没有未钦定的边的限制。因此我们可以把 $C(s_2)$ 去掉。即：

$$
g[s_2][s_1]=\sum_{s_2\in s_3 \in s_1}f[s_3][s_2]
$$

那么这符合子集反演的形式。（注意上一个式子由于 $\sum$ 前面带了判断是不能直接子集反演的，这同样解释了为什么我们为什么集合里面的点只能都是新点——否则你 $\sum$ 前面至少带一个旧点集合能否缩点的条件），即：

$$
f[s_2][s_1]=\sum_{s_1\in s_3\in s_2}(-1)^{|s_3|-|s_1|}g[s_3][s_1]
$$

这里有点小问题：$s_1\in s_3\in s_2$ 和子集反演的形式长得不一样——这容易，注意到 $s_1$ 不变，那么把 $s_1$ 看成全集即可。

---------

接下来我们考虑直接求解 $f[s_1]$ 的值，即：

$$
f[s_1]=\sum_{s_2 \not = \emptyset ,s_2\in s_1}f[s_2][s_1]
$$
$$
=\sum_{s_2 \not = \emptyset ,s_2\in s_1}\sum_{s_1 \in s_3 \in s_1}(-1)^{|s_3|-|s_1|}g[s_3][s_1]
$$
$$
=\sum_{s_2 \not = \emptyset ,s_2\in s_1}\sum_{s_1 \in s_3 \in s_1}(-1)^{|s_3|-|s_1|}C(s_3)f[s_1/s_3]
$$

稍微和式变换一下下

$$
=\sum_{s_1/s_3 \in s_1}C(s_3)f[s_1/s_3]\sum_{s_2 \not =\emptyset ,s_2\in s_3}(-1)^{|s_3|-|s_2|}
$$
$$
=\sum_{T\in s_1}C(s_1/T)f[T]\sum_{t\not = \emptyset,t\in s_1/T}(-1)^{|s_1/T|-|t|}
$$

-----------
 >后面的式子形如：

>$$
\sum_{T\not = \emptyset,T\in S}(-1)^{|S|-|T|}=\sum_{T\not = \emptyset,T\in S}(-1)^{|T|-|S|}
$$
$$
=(-1)^{-|S|}\sum_{T\not = \emptyset,T\in S}(-1)^{|T|}=(-1)^{|S|}\sum_{T\not = \emptyset,T\in S}(-1)^{|T|}
$$

>我们用二项式反演的角度考虑，我们考虑大小为 $i$ 的集合个数：恰好是在 $S$ 中选择 $i$ 个元素的方案数，即原式等于：

>$$
=(-1)^{|S|}\sum_{i=1}^{|S|}C_{|S|}^{i}(-1)^{i}
$$

> 运用二项式定理可得：


>  $$
=(-1)^{|S|}(\sum_{i=0}^{|S|}C_{|S|}^{i}(-1)^{i} -1)
$$
$$
=(-1)^{|S|}((1-1)^{|S|}-1)=(-1)^{|S|+1}
$$

---------

那么带回原式子，可得：

$$
f[s_1]=\sum_{T\in s_1}f[T]\sum_{t\not = \emptyset,t\in s_1/T}(-1)^{|s_1/T|-|t|}
$$
$$
=\sum_{T\in s_1}C(T/s_1)(-1)^{|T|+1}f[T]
$$

----------------

现在我们知道了在缩完点之后的计算方案，但是我们毕竟不能枚举缩点方案，那么考虑化简——只有可能求方案数和的时候才能通过代数运算尝试化简。设 $dp[s_1]$ 表示 $s_1$ 内合法的方案数。

![1688977518065.png](https://img1.imgtp.com/2023/07/10/o7u4pqBl.png)

（因为 luogu 不方便打中文文字）。

另外不会构造，摆烂。

```cpp
#include<bits/stdc++.h>
#define int long long 
using namespace std;
const int N=18,M=(1<<17)+100,mod=998244353;
int n,m,cnt;
int e[N];
int fa[N];
int f[M],g[M];
int find(int x){return x==fa[x]?x:fa[x]=find(fa[x]);}
void merge(int x,int y){x=find(x),y=find(y);if(x!=y)cnt--,fa[x]=y;}
signed main()
{
	scanf("%lld%lld",&n,&m);
	for(int i=1,x,y;i<=m;i++)
	{
		scanf("%lld%lld",&x,&y);x--,y--;
		e[x]|=(1<<y);e[y]|=(1<<x);
	}
	for(int s=0;s<(1<<n);s++)
	{
		for(int i=0;i<=n;i++)fa[i]=i;cnt=__builtin_popcount(s);
		for(int i=0;i<n;i++)if((1<<i)&s)
		{
			int t=e[i]&s;
			for(int j=0;j<n;j++)if((1<<j)&t)merge(i,j);
		}
		f[s]=(cnt&1)?1:mod-1;
	}
	g[0]=1;
	for(int s=1;s<1<<n;s++)
	{
		if(__builtin_popcount(s)==1){g[s]=1;continue;}
		for(int t=s;t;t=(t-1)&s)(g[s]+=f[t]*g[s^t])%=mod;
	}
	printf("%lld\n",g[(1<<n)-1]);
	return 0;
}
```


## 后记

相关题目：P6295，【清华集训2014】主旋律。主旋律的前大半部分根上面极为相似，建议自己手推加强记忆。

至于为什么要花那么大力气推式子，一方面是因为后面两道题因为题设条件更为复杂，需要更清晰的推导式子。诚然，依赖代数直觉是一种方便又快捷的方法，但当你的水平不大够或者疏忽时，往往会出错。运用基础容斥式子得到的答案更为广泛，清晰和通用。

我的语文老师对高考背答题板子不以为然，认为是背板子害了中考状元（虽然但是高考 $696$ 分，听说英语第一次考寄掉了），这是因为一次模考考了相近却不相似的题目。但我也不以为然，考炸了怪板子？这是人能做出来的事？虽然角度不同，但我还是看不惯不找自身原因的分析。

我记得具体数学里说过，数学公式是用来辅助更为普遍的计算的工具，我对此深以为然。