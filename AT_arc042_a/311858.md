题解区可真是八仙过海呀，先在此表达对其它题解的敬仰之情。

来介绍一个较简单的方法。

[原题传送门](https://www.luogu.com.cn/problem/AT1409)。[在窝的博客中食用更佳](https://www.luogu.com.cn/blog/MZY666/solution-at1409)。

### 【 题意概括 】

先输入一个正整数 $n$ ，表示有一个 $n$ 个数的数列，其中第 $i$ 个数的初始值为 $i$ 。

随后输入一个正整数 $m$ ，表示有 $m$ 次操作。

接下来 $m$ 行每行输入一个正整数 $a$ ，表示把这个数列中值为 $a$ 的那一项移动到最前面来。

操作完毕后输出当前数列即可。每个数都要分行输出。

### 【 思路 】

对于提到前面的数，按往前提的顺序倒着先输出即可。

什么意思呢？咱们来陪着代码消化：

用一个整型数组 $a$ 储存输入的要求进行操作的数。

用一个布尔数组 $used$ 记录被提到前面过的数。

```cpp
int a[1000005];
bool used[1000005];//初始值为false
for(i=1;i<=m;i++)scanf("%d",&a[i]);
for(i=m;i>=1;i--){//从后往前
	if(!used[a[i]]){//如果这个数之后没有再次被提到最前面
		printf("%d\n",a[i]);//输出这个数，记得换行
		used[a[i]]=true;//标记，提过这个数
	}
}
```

随后再依次输出没有被提到前面的数即可。

来，是时候看看全盘代码了。

### 【 代码实现 + 注释 】

```cpp
#include<bits/stdc++.h>//万能头文件可好 
using namespace std;
int a[1000005];
bool used[1000005];//初始值为false
int main(){//主函数 
	int n,m,i;//定义 
	scanf("%d%d",&n,&m);//输入 
	for(i=1;i<=m;i++)scanf("%d",&a[i]);//输入 
	for(i=m;i>=1;i--){
		if(!used[a[i]]){
			printf("%d\n",a[i]);//输出，记得换行
			used[a[i]]=true;//标记
		}//上文有解释
	}
	for(i=1;i<=n;i++)
		if(!used[i])printf("%d\n",i);//依次输出没有被提到前面的数
	return 0;//over~
}
```

~~这算不算是一种投机取巧的方法？~~ 算了，能A才是王道。

最后，由于作者自愿禁言了，如果有建议请私信。否则将**无法**回复您哦！

完结撒花~（疯狂暗示 AOA