## 解题思路:

反 $\text{Nim}$ 游戏经典题。

---
### SG 函数部分：

这一般的 $\text{Nim}$ 游戏一样。

没有石子时无法取，也就是说：$G(0)=0$，然后每一个 $G(x)$ 都可以任意地取 $G(x-k)$ 其中整数 $k \in[1,x]$，根据 $SG$ 函数的定义，得到：$G(x)=MEX(G(x-k))=x$。

---
### 反 $\text{Nim}$ 游戏部分

分情况讨论。

1. 当有且仅有石子数为 1 的堆的时候，直接根据奇偶性判断最终结果。

2. 当有且仅有一堆不为 1 的时候，根据奇偶性调整取完有多余石子的一堆，必胜。

3. 否则和一般的 $\text{Nim}$ 一样，求出所有数的异或和。每一个异或和为 0 的状态一定只能转换到异或和不为 0 的状态或者转化到情况 2，即让下一个取的玩家必胜。而每一个异或和不为 0 的状态一定能转化到为 0 的状态。显然异或和为 0 是必败态，否则为必胜态。

---
综上所述，也就是比一般的 $\text{Nim}$ 游戏多了一个全为 1 的特判。感性理解一下就是原 $\text{Nim}$ 中全为 1 的情况和一般情况的结果重合，而这里反过来了。


---
## 代码：

```cpp
#include<cstdio>
using namespace std;
int n,T,x,ans,flag;
int main(){
	scanf("%d",&T);
	while(T--){
		scanf("%d",&n);
		ans=0;flag=1;
		for(int i=1;i<=n;i++){
			scanf("%d",&x);
			ans^=x;
			flag&=(x==1);
		}
		if(flag==1)ans=!(n&1);
		if(ans==0)printf("Brother\n");
		else printf("John\n");
	}
	return 0;
}
```
