个人感觉这道题是比赛中最简单的一道题，~~但是考试时没有打出正解qwq~~

## 20pts 做法

拿到前两个测试点的分还是比较容易的。

对于每个询问，```dfs``` 枚举每个数，再加上一些玄学剪枝，基本上就能得 $20$ 分。

~~其实这个 20 只是大概，我也没有试过~~

## 60pts 做法（重点）

拿到 $60$ 分才是关键。

通过样例解释其实可以想到**贪心**的思路：让**大数和大数乘**，**小数和小数乘**，也就是**让积不平均**。

那么怎么实现这样的贪心呢？我在考试中联想到了一道你谷月赛题 [P5887](https://www.luogu.com.cn/problem/P5887)。（我也在这道题上发过题解QAQ）

于是就想到：求 $n$ 和 $k$ 最大公约数，记为 $t$，那么 $t$ 就是**互不相关的环的个数**。（如果不好理解可以画几个图）

那么答案最大的情况就是**大的放在一个环中**，**小的放在一个环中**，从而实现积的不平均。

或者说，记 $n/t=p$，那么第 $1$ 到第 $p$ 大的放在一个环中，第 $p+1$ 到第 $2p$ 大的放在一个环中，以此类推。

最后注意一下 $k=0$ 的情况和边界，代码就能写出来了。（这里就不贴了）

这样做在洛谷能拿 $80$，但 $O(nm)$ 的复杂度应该是过不了测试点 $7$ 和 $8$ 的，可能是因为洛谷的数据比较小(~~shui~~)。

## 100pts 做法

我在考试时感觉这么做只有 $60$，没往下想，结果后来才发现满分就在 **60 分的做法上优化**就行qwq

考虑到一个数的因子很少，这道题 $n$ 又是固定的，也就是说 $t,p$ 的个数很少，所以只用**记忆化**就行了。只要 $p$ 相同结果就相同，如果以前算过 $p$，就直接输出答案。

还要注意这题 $ans$ 要开 ```long long```，并且 $a$ **数组也要开**，因为乘起来的时候如果本身不是 ```long long``` 就会算成 ```int```。（或者在算答案的时候强转也可以）

## AC 代码

下面放 AC 代码（有注释）——

（~~我知道你们只看这里QAQ~~）

```cpp
#include<cstdio>
#include<algorithm>//要用sort
#define ll long long
using namespace std;
const int MAXN=2e5+10;
ll a[MAXN],f[MAXN];//f是记忆化
int read(){//快读
	int x=0,f=1;
	char c=getchar();
	while(c<'0'||c>'9'){
		if(c=='-') f=-1;
		c=getchar();
	}
	while(c>='0'&&c<='9'){
		x=x*10+c-'0';
		c=getchar();
	}
	return x*f;
}
int gcd(int a,int b){//求最大公约数
	if(b==0) return a;//算完了
	return gcd(b,a%b);//辗转相除
}
int main(){//主函数
	int n=read(),m=read();
	for(int i=1;i<=n;i++) a[i]=read();
	sort(a+1,a+n+1);//排序
	while(m--){
		ll ans=0;//记录结果
		int k=read();
		if(k==0||n==1){//特判k=0和n=1，n=1不特判会出bug，但好像没有n=1的测试点
			for(int i=1;i<=n;i++) ans+=a[i]*a[i];//算平方和
			printf("%lld\n",ans);
			continue;
		}
		int t=gcd(n,k),p=n/t;//计算t和p
		if(f[p]){//以前算过
			printf("%lld\n",f[p]);//直接输出
			continue;
		}
		for(int i=1;i<=n;i+=p){//枚举环
			for(int j=0;j<p-2;j++) ans+=a[i+j]*a[i+j+2];//枚举每个乘积，记录
			ans+=(a[i]*a[i+1]+a[i+p-1]*a[i+p-2]);//加上前后两个边界
		}
		printf("%lld\n",ans);
		f[p]=ans;//记忆化
	}
	return 0;//华丽结束
}
```
最后祝大家~~爆零快乐~~，别忘了点个赞！