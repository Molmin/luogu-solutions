这是一道普及-(~~即使我认为它有普及难度~~)的题目，中缀表达式转为后缀表达式。

做这道题，如果要用模拟做法（因为还有递归实现的方法，~~可惜我不太解释得来~~，所以讲模拟算法），首先我们要知道，什么是前缀、中缀和后缀以及栈（~~废话~~）。

如果你不知道什么叫前缀、中缀和后缀以及栈，请认真阅读分割线以内的文字。
————————————————————————————————

这个“缀”是指运算符在算术表达式中的位置。

比如一个算术表达式：a+b，a和b是运算数，+是运算符

a+b就是它的中缀表达式，也是我们一般习惯的形式。

+ab是它的前缀表达式，即运算符放在运算数之前。

ab+是它的后缀表达式，即运算符放在运算数之后。

前缀、中缀和后缀讲清楚了（~~我认为的~~），接下来就是栈了。

栈其实就是一个坑（至于为什么，看后面）……

首先，栈有两个基本操作：入栈和出栈（也叫压栈和弹栈）。

要明白栈到底是个什么东西，且先听个故事。

一天，a、b、v（别问为什么不是c，~~关于c，他死了~~）三个人按先后顺序走在路上（这就是一个准备入栈的序列）。

突然，a掉坑里了（栈从空转为非空，当然这题与栈空不空没多大关系）……

此时一种神秘的力量指向了a（栈顶指针），~~“少年，你就是被命运选中的人！”~~咳咳，不好意思，莫名犯中二了。

此时a便是栈里唯一的元素，他可以出来继续走路，也可以在坑里当个地头蛇。

我们假设他选择当了地头蛇。

之后，b也掉进来了。那股神秘的力量又指向了他，~~“少年……”~~咳咳。

此时他也可以选择走或留，不过他不能动a，因为a是大哥，比他厉害。

后面的v和b差不多，也是这么个情形。哪怕后面有再多的人，他们如果进了这个坑，依旧只能自己选择，而不能左右别人，包括入栈序列里的人，因为他们没有加入这个栈（~~坑~~）。

因此，栈只可以对栈顶元素进行操作（就是只能处理最后掉坑的人，~~因为他是萌新~~，而下面的人都是他大哥，后面的人都和他没关系，他除了自己谁也动不了）。

————————————————————————————————

好了，(~~假装~~)概念都说清楚了，算法（~~其实也就是模拟~~）就看代码注释吧（~~逃~~）。
```
#include<iostream>
#include<cstdio>
#include<string>
using namespace std;
string s; //这是要读入的字符串。 
char x[405];  //这是储存字符的栈。 
int top=0;  //这是栈顶指针。 
int main()
{
	freopen("transfer.in","r",stdin);
	freopen("transfer.out","w",stdout);
	int n;
	cin>>n;  //n个中缀表达式。 
	while (n--)
	{
		cin>>s;  //在这里我们要明确一件事，题目里说明保证有唯一解，也就是说不会出现x+y+z这种东西。 
		//而是把x+y作为一个基本形式。 
		for (int i=0;i<s.size();i++)
		{
			if (s[i]>='a' && s[i]<='z')
				cout<<s[i];  //如果是字母直接输出，因为后缀表达式的运算符要放在运算数之后。 
			if (s[i]=='(' || s[i]=='+' || s[i]=='-' || s[i]=='*' || s[i]=='/' || s[i]=='^')
				x[++top]=s[i];  //如果是前括号或是运算符，压入栈。 
			if (s[i]==')')  //碰见后括号了，把到前括号之前的运算符全输出。 
			{
				while (x[top]!='(')
					cout<<x[top--];
				top--;  //注意把压入的前括号给删了（其实也不是删 ，而是把栈顶指针移到前括号下面，再有要压入栈的元素就会把它覆盖掉）。 
			}		
		}
		cout<<endl;  //注意要回车。 
	}
	fclose(stdin);
	fclose(stdout);
	return 0;
}
```