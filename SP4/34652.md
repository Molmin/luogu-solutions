# 禁止抄袭，但思路可以借鉴
## **首先我认为本题的考点为递归而不是单纯的模拟**
然后思路为递归到最小括号，然后依次解决。

详见代码

代码如下：（自认为很详细）
```cpp
#include<bits/stdc++.h>//头文件 
using namespace std;
int p=0,n;//变量，不做解释 
string s;//全局变量，不做解释
string dg()
{ 
	string s1,s2,s3;//s1表示第一个完整的括号例如((a+b)*(z+x))中的a，b，s2 表示该括号之外的数字（z,x）因为题目讲解不可能出现a*b*c情况所以可以这么写，s3为符号。 
	int f=0;//判断是不是第一个括号 
	while(p<s.size())//从字符0~结尾循环 
	{
		if(f==0&&s[p]=='(')//情况1 ，可以根据上述的实际意义理解，不做过多解释 
		{
			p++;f=1;s1=dg();//p指针++，f标记为1，递归直到最小括号 
		}
		else if(f==1&&s[p]=='(')//第二个括号出现 
		{
			p++;s2=dg(); 
		}
		else if(f==0&&s[p]>='a'&&s[p]<='z')//情况3 
		{
			f=1;s1=s[p];//已经出现括号 可以整理数字 
		}
		else if(f==1&&s[p]>='a'&&s[p]<='z')
		{
			s2=s[p];//第二个括号的数字处理 
		}
		else if(s[p]==')') break;//情况4，如果是）就结束 
		else s3=s[p];//依次存入字符 
		p++;
	}
	return (s1+s2+s3);//后缀表达式的输出方式 
}
int main()//主程序过于简单不做过多解释 
{
	cin>>n;
	for(int i=1;i<=n;i++)//循环 
	{
		p=0;
		cin>>s;
		cout<<dg()<<endl;//依次输出 
	}
}
```