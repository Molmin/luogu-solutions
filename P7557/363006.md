## 一道二分答案的水题

首先，你必须知道二分答案是什么（否则你来做这题干什么）。

其次，这题目有些坑。

## 坑点

1. 必须排序，因为你综述引用的被引用的文章次数（简称输入的数）越大，那么 $h$ 指数**可能**就会越大，如果不排序，会错几个点。

2. 题目说明最多有 $k$ 篇综述，而每篇综述只能引用 $l$ 篇论文，而且每篇论文只能引用**一次**，但是，每一篇综述都可以引用一篇文章一次，所以你可以看成有一篇综述，能引用 $k * l$ 篇文章，每篇文章能够引用 $k$ 次（题目简化版）。

3. 题目说明 $k ≤ 10 ^ 5$，并且 $l ≤ 10 ^ 5$，所以要开长整型。

## 设计

1. 其中，最小值设为 $-1$，最大值设为$n + 1$。因为最小可能是 $0$，最大可能是 $n$，而最小值要减 $1$，最大值也要加 $1$，所以如上。

2. 检查函数的设计。检查函数，只需判断如果 $c_i$ 大于 $x$，答案加 $1$， 然后如果 $c_i$ 加上 $k$ 大于 $x$ 并且这时的综述可引用次数大于**等于** $k$，答案加 $1$，并将综述可引用次数减去 $x - c_i$。

3. 由于是求最大值，所以如果答案可行，应该是 $l = mid$，并且最后的输出是 $l$。

## 代码

你们最想要的，代码来喽：

```cpp
#include<bits/stdc++.h>

using namespace std;

long long n, l, c[100005], k;   //开long long

bool check(int x){
	long long sum = 0, L = l * k;
	for(long long i = 1; i <= n; i++){
		if(c[i] >= x){     //如果不需要综述引用
			sum++;    //答案++
		}
		else if(c[i] >= x - k && L >= x - c[i]){    //如果可以引用综述
			sum++;
			L -= (x - c[i]);   //综述次数-=(x - c[i])
		}
	}
	return sum >= x;    //如果sum >= x 为真，返回true，否则返回false
}

bool cmp(int x, int y){    //cmp排序函数
	return x > y;
}

int main(){
	cin >> n >> k >> l;
	for(int i = 1; i <= n; i++){
		cin >> c[i];
	}
	sort(c + 1, c + 1 + n, cmp);   //排序
	int l = -1, r = n + 1;    //l和r要设清楚
	while(l + 1 < r){
		int mid = (l + r) / 2;
		if(check(mid)){   //如果可行
			l = mid;
		}
		else{
			r = mid;
		}
	}
	cout << l;    //是输出l
	return 0;
}
```
