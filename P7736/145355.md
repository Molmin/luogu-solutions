注：本题为 NOI2021 D1T2。

## 题解

首先有一个很麻烦的限制，就是 $n_j \; (2 \le j \le k-1)$ 不一定等于 $n_1$——这似乎使我们不得不枚举每一层选了哪些以合并信息。

但由于题目只考虑交点的奇偶性，我们不妨大胆猜测：**两条路径交点个数的奇偶性，与将其起点和终点直接相连的交点个数的奇偶性相同。**

------------

其实**证明**也很简单：

考虑任意两条不相交路径在任意三层之间的交点个数。

设其中一条路径依次经过这三层的 $a_1,x,b_1$，另一条路径依次经过这三层的 $a_2,y,b_2$，不妨设 $x<y$，则有如下四种情况：

| 编号 | 1 | 2 | 3 | 4 |
| :----------: | :----------: | :----------: | :----------: | :----------: |
| $a_1$ 和 $a_2$ | $a_1<a_2$ | $a_1<a_2$ | $a_1>a_2$ | $a_1>a_2$ |
| $b_1$ 和 $b_2$ | $b_1<b_2$ | $b_1>b_2$ | $b_1<b_2$ | $b_1>b_2$ |
| 交点个数 | 0 | 1 | 1 | 2 |
| $a_1,b_1$ 与 $a_2,b_2$ 分别直接相连的交点个数 | 0 | 1 | 1 | 0 |

故任意相邻两段合并成一段后，交点个数奇偶性不变。（一段即指两层之间）

进一步有，所有段合并成一段后，交点个数奇偶性不变。

------------

至此，我们可以直接通过两条路径的起点和终点，判断它们之间交点个数的奇偶性。

更形式化地说，**设以第 $1$ 层的 $i$ 号点为起点的路径的终点为第 $k$ 层的 $p_i$ 号点，那么一种方案的交点个数的奇偶性，与其对应的排列 $p$ 的逆序对数量的奇偶性相同**。

由于问题是“偶数个交点的路径方案数比有奇数个交点的路径方案数多多少个”，即**偶数个逆序对的方案数带有系数 $+1$，奇数个逆序对的方案数带有系数 $-1$**，因此可以联想到**行列式**。

设 $M[i][j]$ 表示以第 $1$ 层的 $i$ 号点为起点，以第 $k$ 层的 $j$ 号点为终点的路径数。

考虑 $M$ 的行列式：

$$det(M)=\sum_{\sigma}(-1)^{\tau(\sigma)}\prod_{i=1}^{n_{_1}}M_{i,\sigma(i)}$$

（其中 $\sigma$ 表示一个 $1$ 到 $n_1$ 的排列，$\tau(\sigma)$ 表示 $\sigma$ 的逆序对数）

我们发现，虽然行列式中的系数满足奇偶性的要求，但这其中包含了存在路径相交的情况。

尽管如此，**每一个存在路径相交的偶数个逆序对的方案，与每一个存在路径相交的奇数个逆序对的方案一一对应**。（注意这里的路径相交不包括：起点/终点相同）

对应方法有很多种，此处举个例子：对于一个存在路径相交的偶数个逆序对的方案，选出其中与其他路径相交的起点编号最小的路径 $x$，再选出与 $x$ 相交的起点编号最小的路径 $y$，然后选出 $x$ 和 $y$ 的公共点中层数编号最大的一个点，记其层数编号为 $p$，将 $x$ 和 $y$ 在第 $p$ 层到第 $k$ 层之间的部分交换，易证这样的逆序对个数会变成奇数。

**故答案即为 $M$ 行列式的值。**

至于怎么求 $M$，邻接矩阵求矩阵乘法/分层递推/BFS均可。

## 代码

注意一个坑点：中间层的点数最大为 $200$。

``` cpp
#include<bits/stdc++.h>
using namespace std;
const int max_k=100+5;
int n[max_k],m[max_k];
const int mod=998244353;
inline void add(int &a,int b)
{
	a=a+b-(a+b>=mod?mod:0); 
}
inline int qpow(int a,int n)
{
	int res=1;
	while(n)
	{
		if(n&1)
			res=1ll*res*a%mod;
		a=1ll*a*a%mod;
		n>>=1;
	}
	return res;
}
const int max_n=200+5;
int f[max_n][max_n],g[max_n][max_n];
inline int det(int n)
{
	int val=1;
	bool flag_neg=false;
	for(int i=1;i<=n;++i)
	{
		int k=i;
		while(k<=n&&!f[k][i])
			++k;
		if(k>n)
			return 0;
		if(k!=i)
		{
			for(int j=i;j<=n;++j)
				swap(f[i][j],f[k][j]);
			flag_neg^=1;
		}
		val=1ll*val*(f[i][i]+mod)%mod;
		int t=qpow(f[i][i],mod-2);
		for(int k=i+1;k<=n;++k)
		{
			int t0=1ll*t*f[k][i]%mod;
			for(int j=i;j<=n;++j)
				f[k][j]=(f[k][j]-1ll*f[i][j]*t0)%mod;
		}
	}
	return flag_neg?mod-val:val;
}
int main()
{
	int T;
	scanf("%d",&T);
	while(T--)
	{
		int k;
		scanf("%d",&k);
		for(int i=1;i<=k;++i)
			scanf("%d",n+i);
		for(int i=1;i<=k-1;++i)
			scanf("%d",m+i);
		for(int i=1;i<=n[1];++i)
			for(int j=1;j<=n[1];++j)
				f[i][j]=(i==j);
		for(int i=1;i<=k-1;++i)
		{
			for(int j=1;j<=m[i];++j)
			{
				int p,q;
				scanf("%d%d",&p,&q);
				for(int x=1;x<=n[1];++x)
					add(g[x][q],f[x][p]);
			}
			for(int p=1;p<=n[1];++p)
				for(int q=1;q<=n[i+1];++q)
					f[p][q]=g[p][q],g[p][q]=0;
		}
		printf("%d\n",det(n[1]));
	}
    return 0;
}
```