## 前言

APIO 打得难受，会这题结果寄了。

写篇题解纪念一下。

## 题意

给定一个序列，求出子区间里中位数出现的次数的最大值。

## 思路

首先看到中位数想到转 $1$ 和 $-1$，即钦定一个数设定小于它的数的权值为 $-1$，大于它的数权值设为 $1$。若在一个区间中权值为 $0$（偶数长度的区间为 $-1$ 或 $1$），则钦定的这个数为中位数。证明显然。

那么对于本题有多个数可能相同的时候，只需要将中位数设为 $-1$ 时权值 $\le0$，设为 $1$ 时权值 $\ge0$ 这个数就是中位数了。证明亦显然。

显然，若两个区间中位数相同，包含了另一个区间的区间一定不会劣于另一个区间。有了这个想法后，现在考虑如何钦定这个中位数是什么。考虑枚举区间的左端点，将左端点的这个数钦定为中位数，寻找最大的右端点。

然而，这样的定义是错误的，无法找到最大的区间。因为我们钦定的这个中位数不一定是区间的左端点。所以，我们考虑计算包含钦定的区间的所有区间中是否存在一个区间使得该数为中位数。不难发现，这样仍然能找到答案。

那么这个算法如何去完成呢？假定右端点为 $l-1$ 的所有区间的权值的最大值为 $a$，最小值为 $b$，钦定区间的权值为 $t$，那么若 $a+t\ge0$ 且 $b+t\le0$ 则一定能找到一个包含钦定区间的区间使得 $l$ 的数为中位数。考虑证明这个结论，因为 $t$ 是一个定值，所以不考虑 $t$，直接加到 $a,b$ 上。考虑 $a$ 到 $b$ 之间是如何变化的。不难发现，我们将权值为 $a$ 对应的区间一次去掉或增加一个左端点，直到变成权值为 $b$ 的区间，这个区间的权值每次增加或减少 $2$ 或不变，则从非正数变成非负数的过程中一定会存在一个区间权值为 $0$ 且右端点为 $l-1$，满足我们的定义。对于右端点，我们可以类似地处理。

考虑如何计算一个区间的权值，只需要建一个线段树，所有点的权值钦定为 $1$，从小到大枚举所有的数，将当前枚举到的数变成 $-1$ 之前计算得到 $t1$，变成 $-1$ 后计算得到 $t2$，则我们要找的就是是否存在 $a+t1\ge0$ 且 $b+t2\le0$。

但是 $a$ 和 $b$ 这样定义并不好求。因为 $a$ 和 $b$ 的右端点是固定的，所以我们可以将线段树改成前缀和或后缀和的最大值、最小值的形式。这样我们就可以轻松地求得 $a,b$。

我们有了一个快速判断包含区间的所有区间中是否存在合法区间的方法。不过，这样仍然无法在 $n^2$ 以内求得答案。但是，我们可以发现经过刚刚的修改会有一个惊人的性质：单调性。具体的，当我们钦定了 $l,r+1$ 且满足要求后，则 $l,r$ 一定也满足要求。证明显然。那么，我们就可以进行二分了。直接二分是 $O(n\log^2n)$ 的，但是若在线段树上二分可以做到 $O(n\log n)$，具体就不赘述了，大家应该都会，不会的网上讲得好的资料也不少。

代码不难写，而且考场代码写的很屎怕误导大家，这里就不放了，读者不妨自行完成。