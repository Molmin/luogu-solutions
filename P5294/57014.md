首先考虑 $50pts$，我们可以直接上保序回归，也就是整体二分之后，枚举 $mid$ 与 $mid+1$ 的分界点，然后找出最大值即可。也有一个更直接的方法：

类似于 $P4331$，考虑最后的序列一定是可以分成若干段区间，使得区间内所有数相等，且这段区间的所有数为本身这段区间的平均数。

考虑 $\sum_{i}(A_i-x)^2$，我们需要支持快速合并。不难得出其为 $\sum_{i=l}^rA_i^2-\dfrac{(\sum_{i=l}^rA_i)^2}{r-l+1}$，那么只需要维护区间平方和，区间和，区间长度即可快速合并两端区间。然后维护一个单调栈，每次新家一个元素，如果可以比单调栈栈顶的元素值小，那么必须不断合并，否则的话新开一个元素，我们可以 $O(N)$ 处理每一个询问。

考虑到每次询问是独立的，考虑最终的答案一定是存在一个 $[L, R]$，使得区间 $[L, R]$ 的的平均数为 $x$，然后 $[1, L-1], [R+1, N]$ 还是原来的情况。

考虑用主席树处理出每一个前缀对应的单调栈以及每一个后缀对应的单调栈。先假设每次修改是给 $x$ 进行单点加操作。那么此时 $[1, x]$ 的单调栈仍然合法，且 $[x+1,n]$ 的单调栈仍然合法。如果是单点减操作，那么 $[1, x-1]$ 的单调栈仍然合法，且 $[x,n]$ 的单调栈仍然合法。

考虑给定两个单调栈如何计算答案，如果第一个单调栈的最大值小于第二个单调栈的最小值，那么我们已经可以计算出答案了。现在的问题是第一个单调栈最后一个元素可能大于第二个单调栈第一个元素。这个时候我们就需要将其合并。考虑原来的暴力，不难证明只保留单调栈的元素做暴力仍然是正确的。

设 $v[L, R]$ 表示**单调栈**上 $L, R$ 的加权平均数，$v[x]$ 表示 **单调栈**上 $x$ 的权值。

那么我们需要合并两个单调栈，就需要找到一个 $[L, R]$，满足 $v[L-1]<v[L, R]<v[R]$。

假设将 $R$ 固定了，考虑找到一个 $L$，满足 $v[L-1]<v[L, R]$ 怎么做。假设 $L$ 是合法的，即满足 $v[L]<v[L+1, R]$，又因为在单调栈上 $v[L-1]<v[L]$，所以 $v[L-1]<v[L, R]$，所以 $L$ 存在单调性。同理 $R$ 也存在单调性。

由于这是单调栈，注意到 $L$ 在满足 $v[L-1]<v[L, R]$ 时，$L$ 越大 $v[L, R]$ 越大，所以我们需要二分找到最大的合法的 $L$，才能使得 $v[L, R]$ 最大。对于一个 $R$，找到了以它为右端点最大的 $L$ 之后，只需要判断 $\max(v[L, R])$ 与 $v[R + 1]$ 的大小关系即可。

复杂度 $O(nlog^2n)$。