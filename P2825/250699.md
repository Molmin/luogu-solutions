二分图好题，我将详细的解释如何想到使用二分图到如何把此题转化为普遍的二分图
最大匹配求法。层层推进，搭建思维体系。

匈牙利算法求二分图最大匹配是个类似于协商的过程，这里就不展开说算法流程了。
首先考虑如果没有硬石头，只有软石头这题该怎么做。

二分图匹配模型有两个要素：

$0.$ 节点能分成独立的两个集合，每个集合内部有0条边。

$1.$ 每个节点只能与 $1$ 条匹配边相连。

我们把这两个要素简称为 $0$ 要素和 $1$ 要素。

我们可以把横坐标看成一个顶点集，纵坐标看成一个顶点集，我们把一个点的坐标看
做横坐标与纵坐标的一个连边，所有的边都是横坐标与纵坐标之间的，顶点集内没有
边。满足 $0$ 要素。一个点的横坐标和纵坐标之间有匹配边就意味着选中这个点，
同一行/同一列不能出现两个炸弹，也就是说不能出现一个横坐标对应两个纵坐标或一
个纵坐标对应两个横坐标，满足 $1$ 要素。所以这个题可以转化为求二分图的最大
匹配。软石头所在的点横坐标和纵坐标之间不连边就行，意味着不能选这个点。有连
边意味着可以选这个点，但匹配边才是真正选的了点。其他就是模板。

这个题有了硬石头，怎么处理呢？

**建立二分图**是本题的核心，图建好了，剩下的也都是模板。

考虑我们之前说的 $0$ 要素和 $1$ 要素，由于这里出现了硬石头，可能会把某一行
分成若干个部分，最简单的情况就是两部分，那如果我们还是按照之前的建图方式，
还满足 $0$ 要素和 $1$ 要素吗？只有满足 $0$ 要素和 $1$ 要素我们才能转化为
二分图匹配问题。显然，要素 $1$ 是不满足的，因为有了硬石头阻挡在一行的中
间，我们在两边可以各放一个炸弹。这样一个横坐标可以匹配两个纵坐标了。但这显
然不符合我们二分图求最大匹配的前提。其实简单来说，就是两个点横坐标和纵坐标
其中有一个相同的，那么这两个点就不能同时选。必须横纵坐标都不相同才能同时
选，按原始的建图方式违背了题意。那我们怎么把它转化呢？可以考虑染色法，以#为分界线染色，类似于tarjan缩点。把一段缩成一个点。这样，给每一段赋予
新的横坐标和纵坐标（详见代码）后，就满足了要素 $1$ 。这一段请务必自己画图理解。

```
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
using namespace std;
int n,m;
struct node{
	int nxt,to;
}edge[3600];
int head[3600],vis[3600],match[3600];
int x1[60][60],y1[60][60];//记录每个新点的新的横纵坐标，其实严格意义上不是横纵，就是我们重新定义的。 
char a[60][60];
int ans,idx,tot;
void add(int u,int v)
{
	edge[++idx].nxt=head[u];
	edge[idx].to=v;
	head[u]=idx;
}
int dfs(int x)
{
	for(int i=head[x];i;i=edge[i].nxt)
	{
		int v=edge[i].to;
		if(!vis[v])
		{
			vis[v]=1;
			if(!match[v]||dfs(match[v]))
			{
				match[v]=x;
				return 1;
			}
		}
	}
	return 0;
}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=n;j++)
		{
			scanf(" %c",&a[i][j]);
		}
	}
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=n;j++)
		{
			if(a[i][j]=='#')
			continue;
			if(j==1||a[i][j-1]=='#') 
			tot++;
			x1[i][j]=tot;
		}
	}
	for(int j=1;j<=m;j++)
	{
		for(int i=1;i<=n;i++)
		{
			if(a[i][j]=='#')
			continue;
			if(i==1||a[i-1][j]=='#') 
			tot++;
			y1[i][j]=tot;
		}
	}
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			if(a[i][j]!='*')
			continue;
			add(x1[i][j],y1[i][j]);
		}
	}
	for(int i=1;i<=tot;i++)
	{
		memset(vis,0,sizeof(vis));
		ans+=dfs(i);
	}
	cout<<ans;
	return 0;
}