#### 题目描述

有一个序列 $a$ , 你可以选择不超过 $k$ 项使其变为 $x$ , 求最后序列最小和。

- $1 \leq k \leq n \leq 100$
- $x < \min ${ $ a_i | i\in [1,n] $ }
- $a_i \geq a_{i-1}$ , 其中 $i\in(1,n]$。

#### 思路

有没有感觉可以贪心？

~~是的正解就是贪心~~。

贪心策略应该也容易想到：

既然 $x$ 小于 $a_i(i\in [1,n])$ 中最小值了，那么$x$ 也小于 $a_i(i\in [1,n])$，故将任何一项家务使其仅用 $x$ 的时间节省的时间都是正的 ,。

我们注意到序列 $a$ 是单调**非**严格增的。

容易想到将 $a_i,i\in [1,n-k]$ 保留不变，$a_i,i\in (n-k,n]$ 变为 $k$，下面是证明（可以跳过）：

---

考虑序列 $free$，其中 $free_i = a_i - x$，则原问题变化为这样：

你可以选择序列 $free$ 中不超过 $k$ 项（设和为 $sum$），使 $\sum_{i=1}^n a_i - sum$ 最大。

先啰嗦一句，既然序列 $a$ 是单调非严格增且每一项均大于 $x$ 的，那么序列 $free$ 也应是单调非严格增的，且每一项大于 $0$。

要使 $\sum_{i=1}^n a_i - sum$ 最大，而 $\sum_{i=1}^n a_i $ 为恒定值，那么就应使 $sum$ 最大。既然序列 $free$ 每一项大于 $0$，那么选出 $k$ 项一定是最优的。若选择了 $free_i$ 而未选择 $free_j$ $(i < j)$，由于序列 $free$ 单调非严格增，所以$free_i<free_j$，那么该方案一定没有不选$free_i$ 而选择 $free_j$ 优。

要使不存在这种情况，那么应使 $free_n$ 被选，$free_{n-1}$ 被选，...，$free_{n-k+1}$ 被选。

对应至序列 $a$，则是将 $a_i,i\in [1,n-k]$ 保留不变，$a_i,i\in (n-k,n]$ 变为 $k$。

---

由于给出序列已是单调，所以边读入边处理就好。判断是否要节省时间只需看下标即可。用一个 $s$ 每次把时间加上。

#### 代码

```cpp
#include<stdio.h>

int main( void )
{
	int n , k , x;
	scanf( "%d%d%d" , &n , &k , &x );
	int s = 0 , chore;
	for( register int i = 0 ; i < n ; i++ )
	{
		if( i < n - k  )
		{
			scanf( "%d" , &chore );
			s += chore; 
		}
		else
			s += x;
	}
	printf( "%d" , s );
} 
```