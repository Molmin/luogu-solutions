讲一种用 set+贪心 预处理的做法。

这题的关键就是单位分数 $\dfrac 1a$ 等于 $\dfrac 1{a+1}+\dfrac1{a(a+1)}$。因此任何一个大小为 $n$ 的集合总可以扩展成一个大小为 $n+1$ 的集合。因为 $1=\dfrac12+\dfrac13+\dfrac16$，因此对于所有 $n\geq 3$ 都可以从 $\{2,3,6\}$ 经过若干次拆分得到。

考虑贪心。每次选一个最大的分数（也就是分母最小的），然后把它按照刚才所说的拆开即可。选最大是因为要保证数列分母最大值增长最慢，尽量使他小于等于 $10^9$。

当然你会发现有时候拆最大的分数可能在数列中已经存在，与题意不符。那我不拆就完了。拆下一个呗。可以发现重复的实在不多，预估序列最大的数不超过 $n^3$。写完程序跑一下程序发现序列中最大的数就是 $246512$。

预处理部分（核心代码），复杂度 $O(n^2 \log n)$：

```cpp
set<int> ans[501];

void pret() {
    ans[3].insert({2,3,6}); // 基础集合
    for(int i=3;i<500;i++) {
        int x;
        for(int j:ans[i]) if(!ans[i].count(j+1)&& // 找到拆开没有重的数
            !ans[i].count(j*(j+1))) {x=j; break;}
        for(int j:ans[i]) if(j!=x) ans[i+1].insert(j); // 其它保持原样
        ans[i+1].insert(x+1); // 拆分成两个新分数
        ans[i+1].insert(x*(x+1)); // 拆分成两个新分数
    }
}
```

注意特判一下 $n=1$ 和 $n=2$ 的情况。