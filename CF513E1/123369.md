这题整整调了我一晚上……

首先，我们看到这个式子：

$|s_1-s_2|+|s_2-s_3|+|s_3-s_4|+\dots+|s_{k-1}-s_k|$

我们不如随便把那些绝对值符号拆掉，换成正或负号，这样原式的最大值就是所有拆绝对值的方案中最优的那种。

例如这就是一种合法的方案：

$-(s_1-s_2)+(s_2-s_3)-(s_3-s_4)-\dots+(s_{k-1}-s_k)$

我们再把括号删掉，观察每一项的系数：

$-s_1+2s_2-2s_3+0s_4-\dots+0s_{k-1}-s_k$

发现了什么？

第一项和最后一项的系数必定是$\pm1$，其它项的次数必定是$\pm2$或$0$。且正负号的方案必定是$+,0,\dots,0,-,0,\dots,0,+,0,\dots,0,-,\dots$

即，一个正数，后面跟一堆$0$，然后再来一个负数，然后又是一堆$0$……或者是正负颠倒的情况。

然后就考虑DP。

设$f[i][j][0/1/2][0/1]$表示：

前$i$位，分成$j$段，第$i$个数的符号是：$0\rightarrow-$，$1\rightarrow+$，$2\rightarrow0$，并且上一个非$0$数的符号是$0/1$。

则有：

$\begin{cases}f[i][j][0][0]=max\{f[i-1][j][0][0],f[i-1][j-1][1][1],f[i-1][j-1][2][1]\}-2*num[i]\\f[i][j][1][1]=max\{f[i-1][j][1][1],f[i-1][j-1][0][0],f[i-1][j-1][2][0]\}+2*num[i]\\f[i][j][2][0]=max\{f[i-1][j][2][0],f[i-1][j-1][2][0],f[i-1][j-1][0][0],f[i-1][j][0][0]\}\\f[i][j][2][1]=max\{f[i-1][j][2][1],f[i-1][j-1][2][1],f[i-1][j-1][1][1],f[i-1][j][1][1]\}\end{cases}$


注意，序列中是可以有位置不选的。因此，相邻的两个$2$，可以分成两段，也可以不分。并且，一段连续的$2$，可以被看作是一段$0$，也可以被看作是一段不选的位置，

然后，边界条件为：$f[i][1][0][0]$与$f[i][1][1][1]$是前缀最大子串和。最终结果是$f[i][m-1][0][0]$与$f[i][m-1][1][1]$加上后缀最大子串和的最大值。因为只有$s_1$和$s_m$是$\pm1$，所以要特判掉。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,f[30100][210][3][2],num[30100],sum[30100],s[2][30100][2],res=0x80808080,ass[30100][2];//0- 1+ 20
int main(){
	scanf("%d%d",&n,&m),memset(f,0x80,sizeof(f));
	for(int i=1;i<=n;i++)scanf("%d",&num[i]);
	for(int i=1;i<=n;i++)f[i][1][0][0]=max(f[i-1][1][0][0],0)-num[i],f[i][1][1][1]=max(f[i-1][1][1][1],0)+num[i];
	for(int i=1;i<=n;i++)f[i][1][2][0]=max(f[i-1][1][2][0],f[i][1][0][0]),f[i][1][2][1]=max(f[i-1][1][2][1],f[i][1][1][1]);
	for(int i=1;i<=n;i++)for(int j=2;j<m;j++){
		f[i][j][0][0]=max({f[i-1][j][0][0],f[i-1][j-1][1][1],f[i-1][j-1][2][1]})-2*num[i];
		f[i][j][1][1]=max({f[i-1][j][1][1],f[i-1][j-1][0][0],f[i-1][j-1][2][0]})+2*num[i];
		f[i][j][2][0]=max({f[i-1][j][2][0],f[i-1][j-1][2][0],f[i-1][j-1][0][0],f[i-1][j][0][0]});
		f[i][j][2][1]=max({f[i-1][j][2][1],f[i-1][j-1][2][1],f[i-1][j-1][1][1],f[i-1][j][1][1]});
	}
	for(int i=n;i>=1;i--)ass[i][0]=max(ass[i+1][0],0)-num[i],ass[i][1]=max(ass[i+1][1],0)+num[i];
	for(int i=m-1;i<n;i++){
		res=max(res,max(f[i][m-1][0][0],f[i][m-1][2][0])+ass[i+1][1]);
		res=max(res,max(f[i][m-1][1][1],f[i][m-1][2][1])+ass[i+1][0]);
	}
	printf("%d\n",res);
	return 0;
}
```
