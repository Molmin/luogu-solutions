算法是莫队 最重要的是怎么算移动产生的贡献

```
//考虑怎么算贡献
//cnt 出现次数为x的数有多少个
//bit 数x出现了多少次
//res 当前的答案
//v 已经离散化好了的值
void del(rg int v){
	if(res==bit[v]&&cnt[bit[v]]==1)res--;
	//如果当前答案正好是我们要修改的值 并且我们修改后他就并不是我们当前答案了
	//那么当前的答案是不是就会-1？
	//假设出现次数最多为5 只有一个数 如果我们减去单个他的贡献
	//那么他出现次数就是4了 就不是答案了
	//但是出现次数为4的数就一定会存在
	//因为他就是出现次数为4的数嘛
	//所以res--就可以了
	cnt[bit[v]]--;//出现次数为bit[v]的数--
	bit[v]--;//v出现次数--
	cnt[bit[v]]++;//出现次数为bit[v]++
}
void add(rg int v){
	if(res==bit[v])res++;
	//如果当前答案是我们要修改的值呢？
	//v的出现次数已经是当前最大的次数了
	//如果他再增大一个 是不是一定会更新答案
	//同样的 res++就可以了
	cnt[bit[v]]--;
	bit[v]++;
	cnt[bit[v]]++;
	
}

```