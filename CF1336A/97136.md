### 题意简述：
在一棵树上，标记 $k$ 个点，使得从这 $k$ 个点到 $1$ 的路径上经过的未被标记的结点数量最多。

### 思路解析：

这道题看上去十分像一个树形 $dp$，用 $dp[i][j]$ 表示以第 $i$ 个结点为根的子树中选择 $j$ 个结点标记的最大距离。但是这个算法的时间复杂度明显是 $O(n\times k)$，会 $TLE/MLE$，是不可取的。

如果是用树形 $dp$ 的话，这个方法是没有办法再优化的了，因为肯定有一个 $n$ 要用来记录结点编号，另一个 $k$ 要记录选择的点数，所以就要想一想是不是不用树形 $dp$就能解决。

如果不用树形 $dp$，而且要用 $O(n)$ 或 $O(n\times log(n))$ 的时间复杂度，同时又要取最大值，那么基本可以肯定要用贪心来做这道题，那么我们先想一下怎么贪心。

如果是贪心的话，就要有一个贪心的顺序。所以首先一定能推导出一个定理，那就是：

**定理 $1:$** 如果要标记一个结点，那么这个以这个结点为根的子树上的结点都必须被标记。

**证明**：反证法，如果这个点被标记了，并且它的子孙结点没有被标记，则一定可以放弃标记这个点。转而标记它的那个子孙结点，因为这个结点的没被标记的子孙结点到 $1$ 号结点的路径更长，并且对它的其他子孙结点的答案影响更小。注：这里的影响更小指的是如果不标记这个结点，原本这个结点其他的子孙结点到 $1$ 的答案都会增加，因为它们到 $1$ 的路径上就会少被标记一个结点。
证毕。

如果有了定理 $1$，我们可以得出一件事，那就是如果要标记一个结点，一定会标记一整个子树，所以我们要怎么排序呢？当然是按一个结点对整个答案的贡献来排序啦。

**定理 $2:$** 设一个结点的 $dep$ 表示这个结点到 $1$ 的路径经过的结点数（不包括这个点自己），一个结点的 $siz$ 表示这个以这个结点为根的子树包含的结点数量，则这个结点 $x$ 对答案的贡献就是 $dep[x]-siz[x]+1$。

**证明**：新标记一个结点 $x$ 的能够得到的就是它到 $1$ 号结点的路径中经过的结点数，即 $dep[x]$，因为有定理 $1$，所以可以肯定在考虑这个结点时这个结点的祖先结点还不会被标记。但是这个结点对答案的损失就是它的子孙数，因为原本它的子孙 $y$ 的贡献为 $dep[y]$，而现在 $y$ 结点到 $1$ 的路径中经过的结点数 $dep[y]$ 会变少一个，因为这个路径上多标记了一个点，而减少总量就是这个结点的子孙结点数，即 $siz[x]-1$，而贡献减去损失就是 $dep[x]-(siz[x]-1)$，即 $dep[x]-siz[x]+1$。

而我们的贪心的排序关键字就是每个结点对答案的贡献。特别的，就算贡献为负数也要加上，因为必须是正好 $k$ 个。

**具体步骤**

$1.$ 读入，建图

$2.$ 一遍 $dfs$ 初始化出每个结点的 $dep$ 和 $siz$。

$3.$ 用一个 $num$ 数组作为贪心排序关键字，$num[i]=dep[i]-siz[i]+1$，在定理 $2$ 中已经证明。

$4.$ 按 $num$ 从大到小排序，并让 $ans$ 加上前 $k$ 个 $num$ 值。

$5.$ 输出答案。

**总结**

这道题也做完了，那就来总结一下这道题吧。这道题的最大的难点有三个，分别是如何判别这道题是贪心而不是树形 $dp$，定理 $1$ 的证明，和定理 $2$ 的证明。其中我觉得最难的就是怎么打破树形 $dp$ 的思维定式，能想到贪心。所以我总结了一下什么时候会用贪心而什么时候要用 $dp$。

老师或教练教的肯定是“能通过局部最优做出全局最优”，但是这个东西并不通俗易懂，那么我就把这个翻译成人话吧。

就是说当要取 $k+1$ 个东西时，我们取的东西肯定包含只让我们取 $k$ 个东西时我们要取得东西（有可能还取别的但这 $k$ 个东西我们肯定还取）。比如说这一道题，在树的结构固定时，我们取 $k+1$ 个东西时肯定只用考虑第 $k+1$ 个东西怎么取，因为之前取的 $k$ 个东西我们肯定还取。其他的贪心题比如合并果子等经典贪心也会满足这个条件。再回头看一看 $dp$ 问题，就不一定了，比如说最经典的 $01$ 背包 $dp$ 问题。你的最大背包容量为 $k+1$ 时取得物品不一定包含最大背包容量为 $k$ 时取得物品。所以背包问题必须要用 $dp$ 而不能用贪心。

好了也说了不少了，下面上代码：

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int NR=2e5+10;
int n,k;
int to[NR<<1],nxt[NR<<1];
int head[NR];
int tot=1;
void add(int x,int y)
{
	to[tot]=y;
	nxt[tot]=head[x];
	head[x]=tot++;
}
int siz[NR],dep[NR];
void dfs(int x,int fa_)
{
	siz[x]=1;
	for(int i=head[x];i;i=nxt[i])
	{
		int y=to[i];
		if(y==fa_) continue;
		dep[y]=dep[x]+1;
		dfs(y,x);
		siz[x]+=siz[y];
	}
}
int num[NR];
int read()
{
	int x=0,f=1;char ch=getchar();
	while(ch>'9'||ch<'0'){if(ch=='-')f=-1;ch=getchar();}
	while(ch<='9'&&ch>='0'){x=(x<<3)+(x<<1)+(ch^48);ch=getchar();}
	return x*f;
}
int main()
{
//	freopen("1.in","r",stdin);
//	freopen("1.out","w",stdout);
	n=read(),k=read();
	for(int i=1;i<=n-1;i++)
	{
		int x=read(),y=read();
		add(x,y),add(y,x);
	}
	dfs(1,0);
	for(int i=1;i<=n;i++)
	{
		num[i]=dep[i]-(siz[i]-1);
	}
	sort(num+1,num+n+1);
	ll ans=0;
	for(int i=n;i>=n-k+1;i--)
	{
		ans+=num[i];
	}
	printf("%lld",ans);
	return 0;
}
 
```