### 题目翻译

Monocarp 有 $h_C$ 滴血和 $d_C$ 点攻击力，而敌人有 $h_M$ 滴血和 $d_M$ 点攻击力。

他们轮流按照以下步骤攻击对面：

+ Monocarp 攻击敌人，让敌人的血量减少 $d_C$。
+ 敌人攻击 Monocarp，让 Monocarp 的血量减少 $d_M$。
+ 如此循环，直到一个人的血量降为 $0$ 或以下，则对面胜利。

Monocarp 可以每次花 $1$ 个金币买护甲升级或者武器升级，每份护甲升级可以让他的初始血量增加 $a$，每份武器升级可以让他的初始攻击力增加 $w$。

Monocarp 有 $k$ 个金币，请判断他能否打败敌人。

多组数据，$\sum k\le 2\cdot 10^5$。其他范围见原题面。

### 思路

#### 流程

题面很长，变量很多，不妨先考虑判定问题。

血量和攻击力范围很大，不适合枚举。

容易发现，Monocarp 和敌人能抗住对面伤害的次数比较好计算，分别为 $\lceil \dfrac{h_C}{d_M}\rceil$  和 $\lceil \dfrac{d_C}{h_M}\rceil$。

Monocarp 能取胜当且仅当敌人能抗住对面伤害的次数小于 Monocarp 能抗住对面伤害的次数。

然后我们就可以通过这两个变量来 $O(1)$ 算出是否能取胜。

解决了判定问题，我们再来看整个题面：

首先贪心。因为 $a,w>0$，所以花金币买升级比不买升级一定不会更劣，所以我们~~豪横一把~~直接全用。

注意到 $k$ 的范围允许我们去枚举，所以直接枚举即可。

枚举 $i$ 表示用 $i$ 个金币升级武器，$k-i$ 个金币升级护甲，然后用上述判定方法是否满足能打败对面即可。

时间复杂度为 $O(\sum k)$ ，可以通过本题。

### 代码

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
int t;
signed main()
{
	cin>>t;
	while(t--)
	{
		ll hc,dc,hm,dm,k,w,a;//有些变量很大，记得开long long，我这里为了方便就全开了。
		cin>>hc>>dc>>hm>>dm>>k>>w>>a;
		bool flag=false;
		for(ll i=0;i<=k;i++)//注意从0开始！
		{
			dc+=i*w,hc+=(k-i)*a;//花金币买升级。
			if((hc+dm-1)/dm>=(hm+dc-1)/dc)//这里是两个上取整操作。
			{
				flag=true;
				puts("YES");
				break;
			}
			dc-=i*w,hc-=(k-i)*a;//判定完后记得把对应变量恢复默认值！（我就在这里卡了30min）
		}
		if(!flag) puts("NO");
	}
    return 0;
}

```

### Bonus

Q：`ceil` 那么好用，为什么不用 `ceil`？

A：因为浮点数误差。在这道题中用了 `ceil` 需要把 `int` 强制转成浮点数，而常用操作是使用 `1.0*`。但是由于本题数据范围比较大，存在浮点数误差使得精确度下降，而我们要求的是准确值，就可能会造成悲剧。

Q：我就想用 `ceil` ！

A：也不是不行，你可以强制类型转换成 `long double`，这样应该就能应付大多数的题目了。

~~ps：在本题中，`ceil` 不强制类型转换亲测可过，但是为了保险还是加上吧。~~ 