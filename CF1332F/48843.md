### 题意

给出一棵 $n ~ (2 \le n \le 3 \cdot 10 ^ 5)$ 的树，求其所有 $2 ^ {n  - 1} - 1$ 种非空的边导出子图中，点独立集个数之和。对 $998\ 244\ 353$ 取模。

### 题解

我写的似乎是一种很奇怪的做法，转移非常冗杂。

首先考虑如果所有边都保留，点独立集个数如何求。

这是一个树上 DP，类似 [没有上司的舞会](https://www.luogu.com.cn/problem/P1352)。以 $1$ 号点为根转成有根树，设 $f_{u, 0 / 1}$ 表示处理完了 $u$ 子树内，$u$ 是否选择的方案数。枚举儿子是否选择进行转移，把那题的取 $\max$ 改成求和就好了。

考虑当边可以断开时，会发生什么样的变化。

- 相邻的两个点可以都进行选择，只要断开中间的那条边。
- 当一个点周围的所有边都被断开时，这个点会在图中被删除，相当于必须不选择。

我们再增加一维，$f_{u, 0/1, 0/1}$ 表示处理完了 $u$ 子树内，$u$ 是否选择，$u$ 从儿子上来的边是否全部断开。

接下来讨论当儿子 $v$ 的答案加入 $u$ 时，怎样进行转移。为了方便，我们设加入前 $u$ 的 DP 数组为 $g_{0/1, 0/1}$。

---

$f_{u, 0, 0}$ 表示不选择 $u$，且从儿子上来的边没有全部被断开。首先分原来情况如何进行讨论，再分 $v$ 的情况进行讨论：
  - $g_{0, 0}$：原来 $u$ 就有从儿子上来的边，那么此时 $u - v$ 的边删不删无所谓，无强制性要求。
    - $f_{v, 0, 0}$：不选择 $v$ 且 $v$ 肯定不会成为孤立点。那么此时 $u - v$ 这条边选不选都是可行的。因此对 $f_{u, 0, 0}$ 贡献为 $2 \times f_{v, 0, 0} \times g_{0, 0}$。
    - $f_{v, 0, 1}$：不选择 $v$ 且 $v$ 可能成为孤立点。选择 $u - v$ 这条边显然没问题；若不选择这条边，相当于让 $v$ 成为孤立点，也就是 $v$ 强制不选择，这与 DP 状态中 “不选择 $v$” 相符，所以也是可以转移的。因此对 $f_{u, 0, 0}$ 贡献为 $2 \times f_{v, 0, 1} \times g_{0, 0}$。
    - $f_{v, 1, 0}$：选择 $v$ 且 $v$ 肯定不会成为孤立点。那么此时 $u - v$ 这条边选不选都是可行的。因此对 $f_{u, 0, 0}$ 贡献为 $2 \times f_{v, 1, 0} \times g_{0, 0}$。
    - $f_{v, 1, 1}$：选择 $v$ 且 $v$ 肯定不可能成为孤立点。此时只有选择 $u - v$ 这条边是可行的，若不选择，则会与状态矛盾（原因见上文 $f_{v, 0, 1}$ 转移部分）。因此对 $f_{u, 0, 0}$ 贡献为 $f_{v, 1, 1} \times g_{0, 0}$。
  - $g_{0, 1}$：原来 $u$ 没有从儿子上来的边，此时有了，说明 $u - v$ 这条边一定选择。
    - $f_{v, 0, 0}$：不选择 $v$ 且 $v$ 肯定不会成为孤立点。显然选择 $u - v$ 这条边可行。因此对 $f_{u, 0, 0}$ 贡献为 $f_{v, 0, 0} \times g_{0, 1}$。
    - 剩下三种状态类似，都在对 $g_{0, 0}$ 转移分析中认为可行，对答案都有系数为 $1$ 的贡献。重复的分析省略。

---

$f_{u, 0, 1}$ 表示不选择 $u$，且从儿子上来的边全部被断开。类似的进行分类讨论分析：
  - $g_{0, 0}$：原来 $u$ 有从儿子上来的边，但此时要求没有从儿子上来的边，条件不符合。这一大类直接被剪去。
  - $g_{0, 1}$：原来 $u$ 就断开了所有儿子上来的边，那么此时 $u - v$ 的边同样需要断开。
    - $f_{v, 0, 0}$：不选择 $v$ 且 $v$ 肯定不会成为孤立点。显然选择 $u - v$ 这条边可行。因此对 $f_{u, 0, 1}$ 贡献为 $f_{v, 0, 0} \times g_{0, 1}$。
    - 仔细观察，发现这段和 $f_{u, 0, 0}$ 内 $g_{0, 1}$ 的转移是完全一样的，故这里也略过。

---

$f_{u, 1, 0}$：表示选择 $u$，且从儿子上来的边没有全部被断开。分类讨论如下：
  - $g_{1, 0}$：原来 $u$ 就有从儿子上来的边，那么此时 $u - v$ 的边删不删无所谓，无强制性要求。
    - $f_{v, 0, 0}$：不选择 $v$ 且 $v$ 肯定不会成为孤立点。那么此时 $u - v$ 这条边选不选都是可行的。因此对 $f_{u, 1, 0}$ 贡献为 $2 \times f_{v, 0, 0} \times g_{1, 0}$。
    - $f_{v, 0, 1}$：不选择 $v$ 且 $v$ 可能成为孤立点。根据上文分析 $u - v$ 这条边选不选都是可行的。因此对 $f_{u, 1, 0}$ 贡献为 $2 \times f_{v, 0, 1} \times g_{1, 0}$。
    - $f_{v, 1, 0}$：选择 $v$ 且 $v$ 肯定不会成为孤立点。此时由于点独立集的限制，这条边必须断开。因此对 $f_{u, 1, 0}$ 贡献为 $f_{v, 1, 0} \times g_{1, 0}$。
    - $f_{v, 1, 1}$：选择 $v$ 且 $v$ 可能成为孤立点。若不断开边，会违反点独立集的限制；若断开边，会违反孤立点的限制。因此这里无法进行转移。
  - $g_{1, 1}$：原来 $u$ 没有从儿子上来的边，此时有了，说明 $u - v$ 这条边一定选择。
    - $f_{v, 0, 0}$：不选择 $v$ 且 $v$ 肯定不会成为孤立点。显然选择 $u - v$ 这条边可行。因此对 $f_{u, 1, 0}$ 贡献为 $f_{v, 0, 0} \times g_{1, 1}$。
    - $f_{v, 0, 1}$：不选择 $v$ 且 $v$ 可能成为孤立点。显然选择 $u - v$ 这条边可行。因此对 $f_{u, 1, 0}$ 贡献为 $f_{v, 0, 1} \times g_{1, 1}$。
    - 上下两种状态由于点独立集的限制，都不满足条件，无法进行转移。

---

$f_{u, 1, 1}$：表示选择 $u$，且从儿子上来的边全部被断开。
  - $g_{1, 0}$：原来 $u$ 有从儿子上来的边，但此时要求没有从儿子上来的边，条件不符合。这一大类直接被剪去。
  - $g_{1, 1}$：原来 $u$ 就断开了所有儿子上来的边，那么此时 $u - v$ 的边同样需要断开。
    - $f_{v, 0, 0}$：不选择 $v$ 且 $v$ 肯定不会成为孤立点。显然断开 $u - v$ 这条边可行。因此对 $f_{u, 1, 1}$ 的贡献为 $f_{v, 0, 0} \times g_{1, 1}$。
    - $f_{v, 0, 1}$：不选择 $v$ 且 $v$ 可能成为孤立点。断开 $u - v$ 这条边可行。因此对 $f_{u, 1, 1}$ 的贡献为 $f_{v, 0, 1} \times g_{1, 1}$。
    - $f_{v, 1, 0}$：选择 $v$ 且 $v$ 肯定不会成为孤立点。断开 $u - v$ 这条边可行。因此对 $f_{u, 1, 1}$ 的贡献为 $f_{v, 1, 0} \times g_{1, 1}$。
    - $f_{v, 1, 1}$：选择 $v$ 且 $v$ 可能成为孤立点。因为必须断开这条边，这就不满足孤立点的限制。因此这里无法进行转移。

于是就讨论完了，码就完事了。最后的答案为 $f_{1, 0, 0} + f_{1, 0, 1} + f_{1, 1, 0} - 1$（因为有减去空集的情况，而且 $f_{1, 1, 1}$ 存在 $1$ 号点作为孤立点却被选择所以不合法）。

时间复杂度 $\mathcal{O}(n)$。
  
代码：

```cpp
#include <algorithm>
#include <bitset>
#include <cassert>
#include <climits>
#include <cmath>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <ctime>
#include <functional>
#include <iostream>
#include <queue>
#include <string>
#include <utility>
#include <vector>
 
const int MaxN = 300000;
const int Mod = 998244353;
 
struct Graph {
  int cnte;
  int Head[MaxN + 5], To[MaxN * 2 + 5], Next[MaxN * 2 + 5];
 
  inline void addEdge(int from, int to) {
    cnte++; To[cnte] = to;
    Next[cnte] = Head[from]; Head[from] = cnte;
  }
};
 
int N;
int Fa[MaxN + 5], F[MaxN + 5][2][2];
Graph Gr;
 
inline int add(int x, int y) { return (x += y) >= Mod ? x - Mod : x; }
inline int sub(int x, int y) { return (x -= y) < 0 ? x + Mod : x; }
inline int mul(int x, int y) { return 1LL * x * y % Mod; }
inline int pw(int x, int y) { int z = 1; for (; y; y >>= 1, x = mul(x, x)) if (y & 1) z = mul(z, x); return z; }
inline int inv(int x) { return pw(x, Mod - 2); }
inline int sep(int x, int y) { return mul(x, inv(y)); }
inline void inc(int &x, int y = 1) { x = add(x, y); }
inline void dec(int &x, int y = 1) { x = sub(x, y); }
 
void init() {
  scanf("%d", &N);
  for (int i = 1; i < N; ++i) {
    int u, v;
    scanf("%d %d", &u, &v);
    Gr.addEdge(u, v);
    Gr.addEdge(v, u);
  }
}
 
void dfs(int u) {
  F[u][0][1] = F[u][1][1] = 1;
  for (int i = Gr.Head[u]; i; i = Gr.Next[i]) {
    int v = Gr.To[i];
    if (v == Fa[u]) continue;
    Fa[v] = u;
    dfs(v);
    int f[2][2];
    f[0][0] = F[u][0][0], f[0][1] = F[u][0][1], f[1][0] = F[u][1][0], f[1][1] = F[u][1][1];
    F[u][0][0] = add(mul(f[0][0], add(add(mul(F[v][0][0], 2), mul(F[v][0][1], 2)), add(mul(F[v][1][0], 2), F[v][1][1]))), mul(f[0][1], add(add(F[v][0][0], F[v][0][1]), add(F[v][1][0], F[v][1][1]))));
    F[u][0][1] = mul(f[0][1], add(add(F[v][0][0], F[v][1][0]), F[v][0][1]));
    F[u][1][0] = add(mul(f[1][0], add(add(mul(F[v][0][0], 2), mul(F[v][0][1], 2)), F[v][1][0])), mul(f[1][1], add(F[v][0][0], F[v][0][1])));
    F[u][1][1] = mul(f[1][1], add(add(F[v][0][0], F[v][1][0]), F[v][0][1]));
  }
  // printf("f[%d] = (%d, %d, %d, %d)\n", u, F[u][0][0], F[u][0][1], F[u][1][0], F[u][1][1]);
}
 
void solve() {
  dfs(1);
  printf("%d\n", sub(add(add(F[1][0][0], F[1][1][0]), F[1][0][1]), 1));
}
 
int main() {
  init();
  solve();
  return 0;
}
```