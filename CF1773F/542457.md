由于 $a$ 和 $b$ 的值已经固定，可以分几种情况考虑：

1. 如果 $n=1$，那么只能是 $a:b$，此时第一行如果 $a=b$，输出 $1$，否则输出 $0$。
2. 如果 $1<n\le a+b$，那么可以通过 $n-1$ 个 $1:0$ 或 $0:1$ 和 $1$ 个剩余的 $x:y$ 来使平局次数降到 $0$，但是注意 $x$ 不能等于 $y$，为了避免，可以先输出 $a$ 和 $b$ 更小的那一边为 $1$，这样 $y$ 恒小于 $x$ 或 $x$ 恒小于 $y$，就不会出现这种情况。在这里还有一种特殊情况，就是 $n=a+b$，此时会输出 $a$ 个 $1:0$ 和 $b$ 个 $0:1$。在这第二种情况，平局数一定为 $0$。
3. 如果 $n>a+b$，即使输出 $a$ 个 $1:0$ 和 $b$ 个 $0:1$，剩下的赢球数和输球数都是 $0$ 了，剩下的局数还没“用”完，那么剩下只能是 $0:0$ 了。此时平局数有 $n-(a+b)$ 个。

下面给出 C++ 代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	ios::sync_with_stdio(false);
	int n,a,b,bu,yao,chao,dai,ma;cin>>n>>a>>b;//输入
	if(n==1){//第一种情况 
		if(a==b)cout<<1<<endl<<a<<":"<<b;//只有1局比赛，无论如何都只能是a:b，如果a=b，那么就是1局平局 
		else cout<<0<<endl<<a<<":"<<b;//如果a≠b,就没有平局 
		return 0;
	}if(n<=a+b){//第二种情况 
		cout<<0<<endl;//保证没有平局
		if(a<b){//为了防止上面“x=y”的情况出现 
			while(a--&&(n--)-1){//意思是，每次循环a-=1，n-=1，重复循环直到a=0（则赢球局数用完）或n=1（剩下1局输出剩下的x:y）时 
				cout<<"1:0\n"; 
			}a++;//最后一次判断中a多减了一次，加回来（因为逻辑与的特性，如果因为a为零退出循环，n不会多减） 
			while(b--&&(n--)-1){//同上 
				cout<<"0:1\n"; 
			}//此时n=1，输出剩下的x:y（因为判断了n<=a+b,所以不会发生“n>1,a=b=0”的情况）
			b++;//同上 
			cout<<a<<":"<<b<<endl; 
		}else{
			while(b--&&(n--)-1){//反过来，先减b，因为b<=a，不会导致最终输出是平局 
				cout<<"0:1\n"; 
			}b++;
			while(a--&&(n--)-1){//减完b，如果n还是大于1就再减a 
				cout<<"1:0\n"; 
			}//此时n=1，输出剩下的x:y（因为判断了n<=a+b,所以不会发生“n>1,a=b=0”的情况）
			a++;
			cout<<a<<":"<<b<<endl; 
		} 
		return 0;
	}if(n>a+b){//第三种情况 
		cout<<n-a-b<<endl;//前面说了，有n-(a+b)个平局；不要忘记换行 
		for(int i=0;i<a;i++){//这里输出的顺序无所谓 
			cout<<"1:0\n";
		}for(int i=0;i<b;i++){
			cout<<"0:1\n";
		}//此时输出完了a个胜局，b个负局，但是还有n-a-b局，只能是n-a-b个0:0
		for(int i=0;i<n-a-b;i++){
			cout<<"0:0\n";
		} 
	}
	return 0;
}//虽然看起来长，但是实际上很简单，如果把循环、判断的行压一压，会发现实际上很短 
```
