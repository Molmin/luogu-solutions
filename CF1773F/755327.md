

### 题意总结：

给定球队的比赛次数 $n$ 、这些比赛中的进球数 $a$ 以及这些比赛中失球数 $b$ ,计算球队比赛可能出现的**最低**平局数。

### 思路


- 比赛总和固定，在总和的限制下**可能会使一些比赛打成 $0:0$** ，为了避免这种情况，我们应当让进球数尽可能少，即 $0:1$ 和 $1:0 $ 。

- 特判比赛次数为 $1$ 的，这样的情况下直接输出，然后终止程序。


比赛次数不为 $1$ 的情况下,我们就可以安排结果为 $x:0(x>0)$ 的 $\min(n-1,a)$ 场比赛，和结果为 $0:y(y>0)$ 的 $\min(n-\min(n-1,a),b)$ 场比赛。

剩下的比赛，由于总和达到了限制，所以只能打成 $0:0$ 。

那么，做法明显。

我们贴上时间复杂度 $\mathcal{O(n)}$ 的部分代码。

### 代码区

首先读入数据，然后特判比赛次数。

```
	cin>>n>>a>>b;
	if(n==1) {
		cout<<(a==b)<<endl<<a<<":"<<b<<endl;
		return 0;
	}
```
为了方便，我们定义 $3$ 个变量 $:s1,s2,s3$，分别表示结果为 $x:0$ 的比赛次数、结果为 $0:y$ 的比赛次数以及剩余的比赛次数（即结果为 $0:0$ 的）。

那么这时候，需要输出的第一个东西——最低平局数，已经到手了，可以先输出了。

```
	int s1=min(a, n-(b?1:0));
	int s2=min(b, n-s1);
	int s3=n-s1-s2;//为了方便观看所以分了三行
	cout<<s3<<endl; //输出最低平局数,别忘了换行！
```
这时候，用 $for$ 循环依次判断条件输出就可以啦。

```
	for(int i=1; i<=s3; i++) cout<<"0:0"<<endl;
	for(int i=1; i<=s1; i++) {
		if(i<s1) cout<<1;
		else cout<<a-(s1-1);
		cout<<":0"<<endl;
	}
	for(int i=1; i<=s2; i++) {
		cout<<"0:";
		if(i<s2) cout<<1<<endl;
		else cout<<b-(s2-1)<<endl;
	}
	return 0;
```


### 注意

- 当 $b=0$ 的时候（即球队没有输球），不需要预留比赛次数给球队输球的比赛，那么此时比赛结果为 $x:0$ 的比赛次数是 $\min(a,n)$ 。 

- 记得不要漏掉换行。
