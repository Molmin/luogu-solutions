**题意**  
有一条数轴，你站在数轴的原点上，你每一步可以选择向左或向右移动 $2$ 个单位长度或 $3$ 个单位长度，给定一个终点 $n(1 \le n \le 10^9)$，问最少需要几步才能到达终点。  
**分析**  
因为终点始终在数轴的正半轴上，所以我们可以贪心地考虑：每一步尽可能的向右走，即每一步向右走 $3$ 个单位长度，直到再向右走 $3$ 个单位长度就会到达终点的右侧为止，此时共走了 $\lfloor\frac{n}{3}\rfloor$ 步。  
此时就会出现 $3$ 种情况：分别为到达终点；还有 $1$ 个单位长度到达终点；还有 $2$ 个单位长度到达终点。用式子表示分别为 $\begin{cases} n \equiv 0 \pmod 3\\n \equiv 1 \pmod 3\\n\equiv 2 \pmod 3\end{cases}$。  
对于第一种情况，不需要过多的考虑，因为已经到达终点了。对于第三种情况，也不需要过多的考虑，只需下一步向右走 $2$ 个单位长度即可。唯一需要考虑的是第二种情况，不过也很容易发现，只需将最后一步的向右移动 $3$ 个单位长度变为两步向右移动$2$个单位长度即可。  
**但**有一个特殊情况：$n=1$。  
为什么说它特殊呢？因为它属于第二种情况，但在判断之前并未有过移动。我们找不到它向右移动 $3$ 个单位长度的一步，那就特殊判断 $n=1$，它只需向右走 $3$ 个单位长度，再向左走 $2$ 个单位长度，共 $2$ 步。  
最终式子如下:  
$$ ans=\lfloor\frac{n}{3}\rfloor+\begin{bmatrix}n \div 3\text{有余数}\end{bmatrix}$$  
**代码**
```cpp
#include<bits/stdc++.h>
using namespace std;
int t,n;
signed main(){
	cin>>t;
	while(t--){
		cin>>n;
		if(n==1){//特判n=1的情况
			puts("2");
		}
		else{//其它情况
			printf("%d\n",n/3+(n%3>0));
		}
	}
	return 0;
}

```