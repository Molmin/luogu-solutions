[题目传送门](/problem/P8819)

场上没想出来，我是什么彩笔。

发现只要判定每次每个点出度为 $1$ 且从每个点出发都能走到环即可。

但其实后面那个条件是废的，因为每个点出度为 $1$ 一定是内向基环树森林，怎么可能走不到环，所以只需判断每个点出度是否为 $1$。

发现好像没什么数据结构可以维护，考虑随机权值的哈希。

但是判 $1$ 不好做，不如把条件转化成点数等于边数且所有点出度全为奇数。

这样维护当前边数和每条边起点的异或和就行了。

具体的，给每个点赋一个 $[0,2^{64})$ 的随机权值，并在每一个点上维护其完好、不完好入边的条数以及完好、不完好入边的起点的权值异或和，当更改单条边时直接修改，当更改所有边时将其中一个变为 $0$ 即可。

时间复杂度 $O(n+m+q)$。核心代码如下：
```cpp
int n, m, q, op, u, v, c[500009], d[500009];
ull a[500009], f[500009], g[500009], nw, ok; mt19937_64 rnd(time(nullptr));
int main()
{
	read(n), read(m);
	For(i, 1, n) ok ^= a[i] = rnd();
	For(i, 1, m) read(u), read(v), g[v] ^= a[u], nw ^= a[u], c[v]++;
	read(q); For(qq, 1, q)
	{
		read(op), read(u);
		if ( op == 1 )
			read(v), g[v] ^= a[u], f[v] ^= a[u], nw ^= a[u], m--, c[v]--, d[v]++;
		if ( op == 3 )
			read(v), g[v] ^= a[u], f[v] ^= a[u], nw ^= a[u], m++, c[v]++, d[v]--;
		if ( op == 2 )
			f[u] ^= g[u], nw ^= g[u], g[u] = 0, m -= c[u], d[u] += c[u], c[u] = 0;
		if ( op == 4 )
			g[u] ^= f[u], nw ^= f[u], f[u] = 0, m += d[u], c[u] += d[u], d[u] = 0;
		puts(m == n && nw == ok ? "YES" : "NO");
	}
	return 0;
}
```