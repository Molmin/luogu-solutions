## 题意
有一条直线公路，给定汽车的油箱容量、初始油量和 $N$ 个加油站的位置与单价，求到达终点的最少费用。

## 思路
由于移动是连续的，所以不妨先将加油站按照位置进行排序，这样更加便于处理。

从起点到达终点可能会需要多次加油，所以问题的关键就在于要求出到达每个加油站时需要加多少油。显然，应该在尽可能便宜的加油站加油，基于这个想法，不难得到一个贪心策略：

对于当前到达的加油站，要判断是否加油，主要取决于之后更便宜的最近加油站 $j$ 的位置：
1. 如果油箱的容量足够从 $i$ 到 $j$，那就只需要确保油足够到达 $j$ 即可，因为 $j$ 不仅更靠后，价格还更低，没有在 $i$ 加更多油的必要。所以我们加到油足够，然后直接到 $j$。
2. 如果油箱的容量不足以从 $i$ 到 $j$，说明路途中还需要加油，且价格还要更贵，所以肯定要在当前站把油加满，移动到 $i + 1$ 再说。

我们可以按顺序来考虑每个加油站，并用栈维护一个价格递增的序列，每次要添加一个新加油站时，将栈尾价格不低于当前的都退栈，再将新加油站加入，这个新加油站就是所有退栈加油站的最近更便宜的加油站。

由于起点不能加油，所以我们可以先移动到第一个加油站，然后令终点单价为 $0$，并贪心求解即可。

## 复杂度
### 时间
* 排序 $\mathcal O(N \log N)$
* 计算每个加油站最近的更便宜加油站 $\mathcal O(N)$
* 贪⼼移动 $\mathcal O(N)$
* 总时间复杂度为 $\mathcal O(N \log N)$

### 空间
* 记录加油站 $\mathcal O(N)$

## 代码
```cpp
#include <algorithm>
#include <icecream>

using namespace std;
using LL = long long;

const int kMaxN = 5e4 + 2;

struct E {                                                // 加油站
  int x, y, p;                                            // 位置、价格、最近的更优加油站
  bool operator<(const E &_e) const { return x < _e.x; }  // 按照坐标排序
} e[kMaxN];
int a[kMaxN], n, g, b, d, m;

LL C() {                     // 计算答案
  LL r = 0;                  // 初始化答案
  b -= e[1].x;               // 先移动到第1个站
  for (int i = 1; i < n;) {  // 从位置1开始直到n
    if (b < 0) {             // 油箱容量不足
      return -1;             // 无解
    }
    if (e[e[i].p].x - e[i].x <= g) {            // 当前油箱容量足够到达更优站
      LL v = max(0, e[e[i].p].x - e[i].x - b);  // 需要加的油
      r += v * e[i].y;                          // 累加费用
      b += v - (e[e[i].p].x - e[i].x);          // 消耗油量
      i = e[i].p;                               // 移动到更优站
    } else {                                    // 不足以到达更优站
      r += 1LL * (g - b) * e[i].y;              // 加满油的费用
      b = g - (e[i + 1].x - e[i].x);            // 移动后剩下的油量
      i++;                                      // 移动到下个相邻站
    }
  }
  return b < 0 ? -1 : r;
}

int main() {
  cin >> n >> g >> b >> d;
  for (int i = 1; i <= n; i++) {
    cin >> e[i].x >> e[i].y;
  }

  sort(e + 1, e + 1 + n);

  e[++n] = {d};                              // 加入终点
  for (int i = 1; i <= n; i++) {             // 计算每个站的最近更优站
    for (; m && e[i].y <= e[a[m]].y; m--) {  // 当前站比之前的更优则删除栈尾
      e[a[m]].p = i;                         // 记录
    }
    a[++m] = i;  // 加入当前站
  }
  cout << C();
  return 0;
}
```