## 简要题意

> 给定 $n\times n$ 的围棋残局。现轮流下黑子和白子，每下一个子都不能发生提子（即任何一个同色棋子连通块边上都要有至少一个空格），谁不能继续下棋则判定失败。你需要输出一种可能的下棋顺序。  
$n\le 600$ 。保证残局合法。


## 题解

现提供一个目前 $(2020.4.8)$ 时间最短+代码最短（尽管不排除压行嫌疑……）的思路。

根据围棋的「气」的定义，我们能够发现，一个同色棋子连通块没有「气」当且仅当它的四周不存在空格。所以我们只要维护每个连通块四周**与空格相邻的边的个数**就行了。不妨设为 $S$ 值。

本题中只存在下棋操作。也就是说，只存在**合并同色棋子连通块**的操作。因而很容易想到要用并查集进行维护。我们将信息存储在并查集中的祖先节点，只要你对并查集有初步运用，就能写同色棋子连通块的合并操作。我们使用路径压缩进行优化，用来保证这部分复杂度的正确性。

对于残局，我们只要合并相同颜色的棋子所在的连通块就行了（写 $\rm dfs/ bfs$ 是不可能的，这辈子也不可能写的）。考虑从上到下从左往右枚举每个棋子，若其与上方棋子同色，就进行合并；若其与左方棋子同色，也进行合并。但要注意形如以下情况：

$$\def{\arraystretch}{1.5}\begin{array}{|c|c|}\hline\bigcirc&\bigcirc\cr\hline\bigcirc&\triangle\cr\hline\end{array}$$

我们枚举到了三角形位置，并且要进行合并。当我们把它和上方节点所在连通块合并后，就没有必要合并左侧连通块了，因为二者已经在同一连通块中。

关于下棋，有一个非常巧妙的结论：如果某种颜色的棋子（不妨设颜色为 $c$），不能下在 $(x,y)$ ，那么它就永远不能下在 $(x,y)$ 了。证明非常简单，它不能下在 $(x,y)$ ，当且仅当这里不是空格，或者下在这里后存在某同色连通块没有气。对于后者，会出现这种情况时，就说明 $(x,y)$ 是这个连通块与外界相邻的唯一格子了。不会有其他地方的棋子会影响到它「气」的判定。

所以开两个指针，维护两种颜色的棋子分别扫到了哪，容易发现总共扫描的次数是不超过 $2\cdot n^2$ 的。下面要做的就是快速判定下在某个位置（比如 $(x,y)$ ）下个颜色为 $c$ 的棋子是否合法。

我们可以试错。也就是在 $(x,y)$ 这个地方下个棋子，如果发现它不能下，我就撤回。但这样就要写可撤回并查集，会很麻烦。事实上只要维护下了 $(x,y)$ 后是否存在连通块没有气（就是某连通块的 $S$ 值是否变成了 $0$ ）就行了。显然，这个棋子只会影响到它四周最多 $4$ 个连通块的判定，因而只要考虑这 $4$ 个，这也是复杂度的保证之一。

- 我们先把它周围四条边全减掉。如果存在**异色**连通块没气了就说明不能下，需要进行撤回操作。同色连通块略微复杂一些，因为涉及到合并操作。

- 然后合并**同色**连通块。注意，这里是**伪**合并，我们并没有真正合并并查集，只要求出合并后的连通块的 $S$ 值就行。这是比较简单的，但有个小坑：相同连通块不要计算多次。这可以用类似哈希表一样的玩意判重，**但是要记得撤销标记**。如果伪合并后这个连通块 $S=0$ ，需要进行撤回操作。

- 如果需要进行撤回操作，我们就把 $4$ 条边加回去就完事了。由于我们压根没有真正合并任何连通块，所以不需要可撤回并查集。

- 如果这个地方可以下棋，就把同色连通块真正合并起来即可。

要注意的是，如果 $(x,y)$ 不能下颜色为 $c$ 的棋，就要把对应指针向后移，直到指针遍历完所有 $n^2$ 个可能位置，直接退出就行了。

实现细节比较多，容易卡人。具体可以见代码。

## 参考代码

```cpp
#include<bits/stdc++.h>
#define up(l,r,i) for(int i=l,END##i=r;i<=END##i;++i)
using namespace std;
#define to(x,y) ((x-1)*n+y)
#define gt \
    int nx=x+D[d][0],ny=y+D[d][1]; if(!isalpha(W[nx][ny])) continue; \
    int g=gtf(to(nx,ny))
const int XN=600+3,XM=XN*XN,D[4][2]={{1,0},{0,1},{-1,0},{0,-1}},C[2]={'X','O'};
int n,o,F[XM],t,tt,p[2]={1,1},S[XM]; char W[XN][XN]; bool V[XM];
int gtf(int x){return x==F[x]?x:F[x]=gtf(F[x]);}
int main(){
    scanf("%d",&n); up(1,n,i) scanf("%s",W[i]+1);
    up(1,n,i) up(1,n,j){
        t=F[to(i,j)]=to(i,j); if(W[i][j]=='.') continue;
		up(0,3,d) S[t]+=(W[i+D[d][0]][j+D[d][1]]=='.');
        if(W[i][j]==W[i-1][j]&&t!=(tt=gtf(to(i-1,j)))) S[t]+=S[tt],F[tt]=t;
        if(W[i][j]==W[i][j-1]&&t!=(tt=gtf(to(i,j-1)))) S[t]+=S[tt],F[tt]=t;
	}
    while(p[0]<=t&&p[1]<=t){
        int x=(p[o]-1)/n+1,y=(p[o]-1)%n+1,s=0,q=to(x,y); ++p[o];
        if(W[x][y]!='.') continue;
        up(0,3,d) {s+=(W[x+D[d][0]][y+D[d][1]]=='.');gt; --S[g];}
        up(0,3,d){
			gt; if(W[nx][ny]==C[o])s+=(!V[g])*S[g],V[g]=1;else if(!S[g]) s=-1e9;
		}
        up(0,3,d){gt; V[g]=0;} if(s<=0) up(0,3,d){gt;++S[g];} else {
			S[q]=s,W[x][y]=C[o],printf("%d %d\n",x,y);
			up(0,3,d){gt;if(W[nx][ny]==C[o])F[g]=q;} o^=1;
		}
	}
	puts("-1 -1");
    return 0;
}
```