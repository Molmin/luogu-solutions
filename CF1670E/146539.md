## 题意

   给定一个节点数为 $n$ 的树，保证树的节点数量为2的幂次，即 $n = 2 ^ p (p \in \mathbb{N})$。你需要给每条边一个边权，同时给每个点一个点权。所有点的点权与所有边的边权应形成一个长度为 $2 n - 1$ 的排列。然后你需要指定一个根节点，使得从这个根节点到达所有点**或边**的路径异或和最大值最小。

## 思路

1. 由 $1 \leq p \leq 17$ 可得，我们显然要用 $O(n)$ 左右的时间复杂度解决这个问题。
2. 仔细观察题目给的翻译发现，两个样例的异或和的最小值都为 $n$ 。那么我们可以考虑是否任何一棵树都可以使得异或和最小值为 $n$。
   - 可以发现，最小值不可能低于 $n$ 。因为一定存在一个点与一条边，使得点权小于 $n$ 而边权大于等于 $n$，且因为 $n$ 为2的幂次，那么此时异或和一定不会小于$n$ 。因此如果可以构造出最小值为 $n$ 的方案，那么该方案一定为最优解。
3. 题目说可以指定根节点，那么我们首先要尝试的应该是，如果随机根节点，比如无论树的形状，指定根节点为1，是否可以直接构造出最优解。

---

有了以上的条件，我们的目标就变成了让任意一个点与一条边的异或和不超过 $n$ 。那么对于每一个不小于 $n$的数字 $x$ ，与它相连的两条边的边权（如果这个数字作为了点权）或两个点的点权（如果这个数字被作为了边权）$y$，必须满足以下条件之一：

- $x \oplus y < n$ (下文以 $\oplus$ 代指异或)：此时由于$x \geq n$，那么 $y \geq n$ 也需要成立。
- $x \oplus y = n$ : 此时由于 $x \geq n$，那么 $y = n - x$ 。

于是我们发现，如果从一个节点要扩展到另一个节点，需要使用两个整数。而对于 $n$ 个节点的树，需要扩展 $n - 1$ 次。每次使用的两个整数必须满足以下两种情况之一：

- 一个数不小于 $n$ ，另一个数小于 $n$。
- 两个数都小于 $ n $。

这样才可以有可能令每个路径的异或和不超过 $n$。

作为一个构造题，我们在这两种情况中抉择后（可能需要经过一番思考），可以选择一个数不小于 $n$, 另一个数小于 $n$， 找到这样的 $n - 1$ 组数据，就可以构造出这个树。

此时我们发现如果根节点为 $n$ 时，有一些不错的性质。我们可以若令边权为 $n + k$， 下一个点的点权为 $k(1 \leq k \lt n)$ 可让，即到达下一个点时的异或和为 $0$。

同时如果到当前节点异或和为 $0$ 时，我们只需要让边权为 $k$，下一个点的点权为 $ n + k$，即可使到达下一个点的异或和为 $n$。形成了一个奇妙的循环。



## 做法

我们可以将第一个点的权值设为 $n$ ，同时用DFS去更新每条边和每个点的权值。更新时，下一个边权和点权的设置值与当前点的权值有关。

- 当前点异或和为 $n$ 时，下一条边权值为 $n + k$ ，下一个点的权值为 $k$ 。
- 当前点异或和为 $0$ 时，下一条边权值为 $k$ ，下一个点的权值为 $n + k$ 。



## 代码

```c++
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int maxn = 1000005;
typedef pair<int,int> PII;
vector<PII> e[maxn]; // 存每条边的终点及边的序号
int node_ans[maxn], e_ans[maxn]; // 每个节点的点权和每个边的边权
bool vis[maxn]; // 每个点是否被访问过
int num = 1;
int n, p;
void dfs(int now, int flag) {
    vis[now] = true;
    for (int i = 0; i < e[now].size(); i++){
        int nxt = e[now][i].first;
        int e_num = e[now][i].second;
        if (vis[nxt]) continue ;
        e_ans[e_num] = flag ^ num;
        node_ans[nxt] = flag ^ n ^ num;
        num ++;
        dfs(nxt, flag ^ n);
    }
}

void solve(){
    cin >> p;
    n = 1 << p;
    num = 1;
    for (int i = 1; i <= n; i++) vis[i] = false;
    for (int i = 1; i <= n; i++) e[i].clear();
    for (int i = 1; i <= n - 1; i++){
        int u, v; cin >> u >> v;
        e[u].push_back({v, i});
        e[v].push_back({u, i});
    }
    node_ans[1] = n;
    dfs(1, n);
    cout << 1 << endl;
    for (int i = 1; i <= n; i++){
        cout << node_ans[i] << " \n"[i == n];
    }
    for (int i = 1; i <= n - 1; i ++){
        cout << e_ans[i] << " \n"[i == n - 1];
    }
}

int main() {
    int T;
    T = 1;
    cin >> T;
    while (T--){
        solve();
    }
    return 0;
}
```













