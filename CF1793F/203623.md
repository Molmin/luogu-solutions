小清新分治。应该是目前最好的解法。

考虑将序列值域按照中位数划分为 $[l,mid]$ 和 $[mid+1,r]$ 两部分，计算值域在这两部分之间的贡献。

按中位数划分是平凡的。

记 $b_i$ 为 $|a_i-mid|$，左边的 $x$ 和右边的 $y$ 的距离就是 $b_x+b_y$，然后同个部分的两个数的贡献显然是无效的，不用管。

按原数组下标排序，考虑每个数 $k$ 对应的关键点 $(i,k),i<k$。

设 $i<j<k$，那么必须满足

* $b_i+b_k<b_i+b_j$
* $b_i+b_k<b_j+b_k$

即 $b_k<b_j,b_i<b_j$。

即 $b_i$ 应该是 $k$ 的后缀最小值，也就是维护一个单调栈，单调栈中的元素。

注意到 $b_k<b_j$，也就是说 $b_j$ 的取值实际上是插入 $b_k$ 后单调栈弹出的元素。那么 $b_i$ 也应该在这个范围内。

所以维护单调栈求关键点即可，共有 $O(n)$ 个关键点。分治求出 $O(n\log n)$ 个关键点，按 $r$ 排序区间跑扫描线，veb 维护单调栈状结构维护后缀最小值，时间复杂度 $O(n\log n\log \log n+q\log\log n)$。

区间树上最近距离做法相同。