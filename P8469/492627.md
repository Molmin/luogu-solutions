# 题意

略，题目写得很清楚了。

# 题解

本题分为两个部分，第一求最大的 $\gcd$ 的值，第二求方案总数。

第二部分是依托于第一部分的，所以我们先考虑如何求值。

显然，对于任意一个数组，这个数组的所有元素相同时， $\gcd$ 最大，即这个数组内那个相同的元素。

由于题中有对 $b$ 数组的约束，导致了 $b$ 数组的上限被确定。

给出一个结论，最大的 $\gcd$ 就是 $\min{a}$。

证明：

首先证明是否有这种构造方案，显然，当所有的 $b_i=\min a$ 时，这个方案成立。

然后证明正确性：

我们假设有更大的 $\gcd$，而这个数为 $x$，满足 $x > \min a$，这时候有没有构造方案呢？

答案是没有，对应 $\min a$ 位置的 $b_i$ 上限为 $\min a$，如果有更大的数，就要求 $\forall i,b_i\mid x$，即 $b_i$ 都是 $x$ 的整数倍，那么就要 $b_i > x$，既然对于那个位置的 $b_i$ 上限为 $\min a$，而 $x>\min a$，显然两者矛盾了，证毕。

现在我们思考如何求方案数，下面设上述的最大的 $\gcd$ 为 $x$。

显然对于不同的 $i$，都有不同的方案，而这又满足乘法原理，我们只需要把所有 $b_i$ 能够取的值搞出来，全部乘起来答案就出来了。

现在问题又转换为了对于每个 $b_i$ 的方案求法。

我们知道 $\gcd(b_1, b_2\dots b_n) = \gcd(b_1, \gcd(b_2, \dots))$。

全部的 $\gcd$ 取决于两两的 $\gcd$。

既然如此，我们又知道了 $\gcd$ 的取值（上面一大堆证明的东西），就可以求了。

当这个数组内的数都是 $x$ 的倍数时就满足条件了。

给出了一个数的上限，还要求这个数为 $x$ 的倍数，显然对于任意的 $b_i$ 都有不同的 $a_i \div x$ 的方案。

于是我们线性算就完了。

```cpp
int n;
std::cin >> n;

std::vector<int> a(n);
int mn = inf;
for (int i = 0; i < n; i++) {
	std::cin >> a[i];
	mn = std::min(mn, a[i]);
}

std::cout << mn << " ";
Z ans = 1;
for (int i = 0; i < n; i++) {
    ans *= (a[i] / mn);
}
std::cout << ans.val() << "\n";
```
有人可能会问了， 你这没取摸啊， $Z$又是什么类型？

这里我给一个自动取模的模板，可以放心使用。

用法自己看就知道了。

自己呕心沥血多时的模板就这样给你了。

[自动取模的模板](https://www.luogu.com.cn/paste/n6d6wxgy)