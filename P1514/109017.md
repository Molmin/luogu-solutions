[【P1514】引水入城](https://www.luogu.org/problemnew/show/P1514)

标签：深搜与回溯 动规

思路：

枚举起点从第一行开始搜索，把搜过的地方打标记。第一问问你沙漠旁边是不是都有水，也就是最后一行是不是都被搜索过，所以只需搜索结束后把最后一行拿出来看看标记有没有打满就可以了。

第二问比较难想，考虑到如果最终最后一行存在没搜到的程序会提前判断并结束，而这种情况下求没被搜索过的方格数是很容易的，所以我们只需要思考在最后一行都被经过后至少需要多少起点就可以了。显然枚举起点的时候还不能判断，只好在考虑在搜索~~做点手脚~~，看下能不能搜完了以后可以得到结果。那不妨**把“有多少起点”转化成“结束后有多少个不同起点覆盖的区域”。**

![来自题目](https://cdn.luogu.com.cn/upload/pic/300.png)

  _比如这里的不同区域就有三个“3,2”、“2,1,2”、“2” _
  
  
而基于一个事实：这些起点不同的区域各自**内部联通**且**相邻两个不同区**彼此其实也是联通的，我们只需要找到不同区域最左端、最右端就可以确定一个区域，而且知道一个区域的最右端我们就可以确定下一个区域的最左端，对不对？

这样的话我们可以在搜索的时候就找到当前位置可以到的最左端和最右端，那么某一起点覆盖的区间也就得到了。最后枚举起点，如果这个起点能到的最左端小于当前查询区间左端点，这个起点的能到的最右点就有可能成为我当前查询区间的右端点。然后更新左端点（最后当前区间的右端点的下一个），答案加一（找到一个新区域），继续找下一个区间。最后如果我左端点大于列数就跳出程序，这时候答案就是不同区域的数量，也就是蓄水站的数量。

程序细节

1. 由于同一位置只能建一种水利设施，建了输水站就肯定不能蓄水站。而且并没有规定靠近湖泊不能建输水站，因此有可能之前的蓄水站把某个可以作为蓄水站的点变成了输水站，这种情况下我们就不能选它做起点了。所以我们需要一个bool数组记录这个点有没有被经过过。最后dfs前如果这个点被访问过（做过输水站），就不能再以它为起点（蓄水站）搜索。

2. 当前点到的最左、最右端在程序实现时可以在回溯的时候从它到的点和它自己做比较，比右是比大，比左是比小，因此需要初始化“左端点数组”为一个较大值。

代码

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
using namespace std;

int n,m,a[1001][1001],l[1001][1001],r[1001][1001],tot;
bool f[1001][1001],flag;
int dx[6]= {0,1,0,-1,0},dy[6]= {0,0,1,0,-1};

void dfs(int x,int y) {
	f[x][y]=1;
	for (int i=1; i<=4; i++) {
		int xx=x+dx[i],yy=y+dy[i];
		if(xx<1||xx>n||yy<1||yy>m) continue;//多方向扩展搜索矩阵图时考虑跳出矩阵情况
		if(a[xx][yy]>=a[x][y])continue;//根据题意海拔比原点低，则不连通
		if(!f[xx][yy])dfs(xx,yy);
		l[x][y]=min(l[x][y],l[xx][yy]);
		r[x][y]=max(r[x][y],r[xx][yy]);//记忆化搜索？回溯的时候由它到过的点推出它能到的最左最右点。
	}
}

int read() {
	char ch=getchar();
	int k=0;
	while(ch<'0'||ch>'9') {
		ch=getchar();
	}
	while(ch>='0'&&ch<='9')k=k*10+ch-48,ch=getchar();//快读
	return k;
}

int main() {
	n=read(),m=read();
	memset(l,0x3f,sizeof(l));//初始化
	for (int i=1; i<=n; i++)
		for (int j=1; j<=m; j++)
			a[i][j]=read();
	for (int i=1; i<=m; i++)
		l[n][i]=r[n][i]=i;
	for (int i=1; i<=m; i++) {
		if(!f[1][i]) dfs(1,i);//建了输水站就不可以建蓄水站
	}
	for (int i=1; i<=m; i++)
		if(!f[n][i]) flag=1,tot++;
	if(flag) {
		printf("0\n%d",tot);//有不连通的直接结束程序
		return 0;
	}
	int left=1;
	while(left<=m) {
		int maxr=0;
		for (int i=1; i<=m; i++)
			if(l[1][i]<=left)
				maxr=max(maxr,r[1][i]); //找到当前覆盖的最右点
		tot++;      
		left=maxr+1;//区间连续所以可以这样找
	}
	printf("1\n%d",tot);
	return 0;
}
```