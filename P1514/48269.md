【参考资料】

liusu201601的博客 - luogu1514 引水入城(宽搜+DP)：https://blog.csdn.net/liusu201601/article/details/79801394

【题目描述】

在一个遥远的国度，一侧是风景秀美的湖泊，另一侧则是漫无边际的沙漠。该国的行政区划十分特殊，刚好构成一个$n$行$m$列的矩形，如上图所示，其中每个格子都代表一座城市，每座城市都有一个海拔高度。

![](https://cdn.luogu.com.cn/upload/pic/299.png)

为了使居民们都尽可能饮用到清澈的湖水，现在要在某些城市建造水利设施。水利设施有两种，分别为蓄水厂和输水站。蓄水厂的功能是利用水泵将湖泊中的水抽取到所在城市的蓄水池中。

因此，只有与湖泊毗邻的第$1$行的城市可以建造蓄水厂。而输水站的功能则是通过输水管线利用高度落差，将湖水从高处向低处输送。故一座城市能建造输水站的前提，是存在比它海拔更高且拥有公共边的相邻城市，已经建有水利设施。由于第N 行的城市靠近沙漠，是该国的干旱区，所以要求其中的每座城市都建有水利设施。那么，这个要求能否满足呢？如果能，请计算最少建造几个蓄水厂；如果不能，求干旱区中不可能建有水利设施的城市数目。

【输入输出格式】

- 输入格式

输入文件的每行中两个数之间用一个空格隔开。输入的第一行是两个正整数$n$和$m$，表示矩形的规模。接下来$n$ 行，每行$m$ 个正整数，依次代表每座城市的海拔高度。

- 输出格式

输出有两行。如果能满足要求，输出的第一行是整数$1$，第二行是一个整数，代表最少建造几个蓄水厂；如果不能满足要求，输出的第一行是整数$0$，第二行是一个整数，代表有几座干旱区中的城市不可能建有水利设施。

【输入输出样例】

- 输入样例 #1
```
2 5
9 1 5 4 3
8 7 6 1 2
```
- 输出样例 #1
```
1
1
```
- 输入样例 #2
```
3 6
8 4 5 6 4 4
7 3 4 3 3 3
3 2 2 1 1 2
```
- 输出样例 #2
```
1
3
```
【说明】

- 样例$1$ 说明

只需要在海拔为9 的那座城市中建造蓄水厂，即可满足要求。

- 样例$2$ 说明

![](https://cdn.luogu.com.cn/upload/pic/300.png)

上图中，在$3$ 个粗线框出的城市中建造蓄水厂，可以满足要求。以这$3$ 个蓄水厂为源头

在干旱区中建造的输水站分别用$3$ 种颜色标出。当然，建造方法可能不唯一。

【数据范围】

![](https://cdn.luogu.com.cn/upload/pic/301.png)

【题解】

- 我会骗分！

由于有部分测试点的$n=1$，也即有部分城市既是沿水城市又是干旱城市，所以可以根据这个特性来骗分，期望得分$0$~$10$分。

- 我会搜索！

我们可以通过搜索来判断是否能够满足要求（若不能够满足要求则能够求出有几座干旱区中的城市不可能建有水利设施），因此可以得到部分的分数，期望得分$0$~$30$分。

- 我会搜索+动态规划！
我们可以根据前面的一种方法来进行改进，我们可以用动态规划来求出能够满足时最少需要的蓄水厂的个数，我们可以在宽搜的时候求出每个点所能够去到的最左的点（左端点）和最右的点（右端点），然后用$fz[i][j]$来表示$i$和$j$之间最少需要建多少座蓄水厂，并且用$d[i]$来表示$1$~$n$最少需要多少座蓄水厂（注意一开始要将这两个数组初始化为$\infty$哦）。我们可以将**可以到达其他出口且不被其他入口所到达的点**的左端点至右端点的值改为$1$，例如左端点$=2$，右端点$=7$时将$fz[2][2]$~$fz[2][7]$的值改为$1$。得到$fz[][]$数组之后我们就可以求出$d[]$数组了，不难想出状态转移方程：

$$d[i]=min(d[i],d[j]+fz[j+1][i])$$

由此得解，最后的答案即为$d[m]$。

下面上$100$分代码~

```
#include <cstdio>
#include <cstdlib>
#include <cstring>
int ma[501][501],fl[501][501],t[501][501],d[501];
struct nodea{ int v,l,r; } a[1000001];
struct nodeb{ int x,y; } f[1000001];
int dx[4]={1,0,-1,0};
int dy[4]={0,1,0,-1};
int fz[501][501];
int v[1000001];
int n=0,m=0;
int min(int x,int y)
{
	return x<y?x:y;
}
int max(int x,int y)
{
	return x>y?x:y;
}
void bfs(int sx,int sy)
{
	memset(fl,0,sizeof(fl));
	if(n==1)
	{
		v[sy]=1;
		a[sy].l=a[sy].r=sy;
	}
	int tou=1,wei=2;
	f[1].x=sx,f[1].y=sy;
	fl[sx][sy]=1;
	while(tou<wei)
	{
		for(int i=0;i<=3;i++)
		{
			int nx=f[tou].x+dx[i];
			int ny=f[tou].y+dy[i];
			if(ma[nx][ny]<ma[f[tou].x][f[tou].y] && fl[nx][ny]==0)
			{
				if(nx>=1 && nx<=n && ny>=1 && ny<=m)
				{
					if(nx==1)
					{
						a[ny].v=0;
					}
					if(nx==n)
					{
						v[ny]=1;
						a[sy].l=min(a[sy].l,ny);
						a[sy].r=max(a[sy].r,ny);
					}
					f[wei].x=nx;
					f[wei].y=ny;
					fl[nx][ny]=1;
					wei++;
				}
			}
		}
		tou++;
	}
}
void soua()
{
	for(int i=1;i<=m;i++)
	{
		a[i].l=999999999;
		a[i].r=0;
		a[i].v=1;
		v[i]=0;
	}
	for(int i=1;i<=m;i++)
	{
		if(a[i].v==1)
		{
			bfs(1,i);
		}
	}
}
void soub()
{
	int su=0;
	for(int i=1;i<=m;i++)
	{
		if(v[i]==0)
		{
			su++;
		}
	}
	if(su!=0)
	{
		printf("0\n%d",su);
		exit(0);
	}
}
void dp()
{
	for(int i=1;i<=m;i++)
	{
		d[i]=999999999;
		for(int j=1;j<=m;j++)
		{
			fz[i][j]=999999999;
		}
	}
	for(int t=1;t<=m;t++)
	{
		if(a[t].r!=0)
		{
			for(int i=a[t].l;i<=a[t].r;i++)
			{
				for(int j=i;j<=a[t].r;j++)
				{
					fz[i][j]=1;
					if(i==1)
					{
						d[j]=1;
					}
				}
			}
		}
	}
	for(int i=1;i<=m;i++)
	{
		for(int j=1;j<=i-1;j++)
		{
			d[i]=min(d[i],d[j]+fz[j+1][i]);
		}
	}
	printf("1\n%d",d[m]);
}
int main()
{
	scanf("%d %d",&n,&m);
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			scanf("%d",&ma[i][j]);
		}
	}
	soua();
	soub();
	dp();
	return 0;
}
```