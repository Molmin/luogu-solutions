思路 ：

搜索从第一排开始能覆盖最后一排的区间L ~ R（代码里是x ~ y），但搜索必须满足一个条件才能搜——if(q[1][i - 1] <= q[1][i] && q[1][i + 1] <= q[1][i])，这个条件的原因是如果当前点能覆盖第一排的相邻点，那么选它的相邻点做蓄水厂就没有意义了；而等于号是因为如果它的相邻点覆盖不了它，它就可以选，否则就是无意义的点了。搜索时如果搜到了最后一排，就当前点改为“搜到了”，并存下L和R，L取min，R取max（注意：这里每个点的L和R需要初始化，即L = INF， R = -INF）。搜完以后，判断有没有最后一排的任意一个点没有被改为“搜到了”，如果有就输出“0” + 没有改为“搜到了”的数量。否则就排序 + 贪心区间覆盖——每次贪心取左边界 ≤ l && 右边界 > r的区间（l初始值为1，r初始值为0，然后l每次都重新赋值为r + 1，r反复取 { 左边界 ≤ l && 右边界 > r } 的右边界），最后取最小覆盖的次数（即要安蓄水厂的最小数量）为答案，输出“1” + 最小覆盖的次数。

全文 + 代码：[这里](https://www.cnblogs.com/qqq1112/p/11118486.html)