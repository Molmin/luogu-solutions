注意互相不能攻击的定义：

> 在任何一行中最多只有一辆车，在任何一列中最多只有一辆车。

再根据棋盘上已有 $n - 1$ 辆车，容易发现该棋盘的 $n$ 行中有 $n - 1$ 行有一辆车，$1$ 行没有车；$n$ 列中有 $n - 1$ 列有一辆车，$1$ 列没有车。显然这没有车的一行和一列的交汇点就是我们要寻找的第 $n$ 个放置车的点。

于是问题被转化成了：

- 在 $n$ 行中找到 $1$ 个没有放置车的行；

- 在 $n$ 列中找到 $1$ 个没有放置车的列。

由于可以将棋盘转置把第二问转化为第一问，所以此处仅讨论第一问的求解过程。

考虑二分。二分该棋盘的行，设 $l$ 为二分左端点，$r$ 为二分右端点，$mid = \dfrac{1}{2} \times (l + r)$，则对于 $l$ 至 $mid$ 这个区间内做一次 `? l mid 1 n` 的询问（求列时询问 `? 1 n l mid`）。

Q：为什么要有一个 $1$ 和一个 $n$ 混入询问操作？

A：显然我们此时只关心哪一行（或列）没有放车，则对于列（或行）只需要询问一组 `1 n`，询问全部区间，相当于没有询问（并不会影响行（或列）的返回结果）。

显然，只有两种可能的返回结果：

1. $mid - l + 1$：说明 $l$ 行至 $mid$ 行全部放了车，那么没放车的那行只会在 $mid + 1$ 行至 $r$ 行中，将 $l$ 设定为 $mid + 1$。

2. $mid - l$：说明 $l$ 行至 $mid$ 行中有一行没放置车，将 $r$ 设定为 $mid$。

接下来证明只有这两种可能的返回结果：

对于一个非上述两种情况的返回结果，有两种可能：

1. 小于 $mid - l$：说明有不止一个行没放置车，与题意不符，舍去。

2. 大于 $mid - l + 1$：说明有少于 $0$ 个点没放置车，显然不可能。

根据上述条件去不断二分，最终当 $l = r$ 时，就得到了唯一没放置车的一行。列同理。

因此，该算法询问次数为 $2 \times \left\lfloor\log_2n\right\rfloor$。在 $n = 1000$ 的最大限度时该算法需要询问正好 $20$ 次，可以通过。

```cpp
#include <iostream>
using namespace std;
int n,x,y,l,r,ans;
int main(){
	cin>>n;
	l=1,r=n;
	while(l<r){
		int mid=l+r>>1;
		cout<<"? "<<l<<" "<<mid<<" 1 "<<n<<endl;
		cin>>ans;
		if(ans==mid-l+1) l=mid+1;
		else r=mid;
	}
	x=l;
	l=1,r=n;
	while(l<r){
		int mid=l+r>>1;
		cout<<"? 1 "<<n<<" "<<l<<" "<<mid<<endl;
		cin>>ans;
		if(ans==mid-l+1) l=mid+1;
		else r=mid;
	}
	y=l;
	cout<<"! "<<x<<" "<<y<<endl;
	return 0;
} 
```
