[**CF319A Malek Dance Club**](https://www.luogu.com.cn/problem/CF319A)

---
* Update 8/26
添加更详细的解释
---

在这里提供一种递推/递归做法。

观察题目，发现给出的 `x` 是以二进制形式的，不难想到把 $1$ ~ $2^n-1$ 用二进制表示出来：

```
---|-----
   |
 0 | ...
   |
---|-----
   |
 1 | ...
   |
---|-----
```

可以发现，在这 $2^n$ 个数中，前 $2^{n-1}$ 个数的首位均为 $0$，后 $2^{n-1}$ 个数的首位均为 $1$。

由异或的规则可以得出以下结论：

1. 当 $x$ 首位为 $0$ 时，原先首位为 $0$ 的仍为 $0$，首位为 $1$ 的仍为 $1$，因此 $1$~$2^n-1$ 中的逆序对的数量等于 $1$~$2^{n-1}-1$ 中的逆序对数量加上 $2^{n-1}$~$2^n-1$ 中的逆序对数量之和。又因为这些数是从小到大依次排列且差为 $1$ ，所以在不看首位的情况下这两部分是一样的，这表明这两部分在异或后的逆序对数是相等的，在计算时可以直接计算一部分然后乘二。
2. 当 $x$ 首位为 $1$ 时，原先首位是 $0$ 的会变成 $1$，首位是 $1$ 的会变成 $0$。显而易见的，异或后前一半的数一定会大于后一半。这恰好满足了逆序对的要求，因此该情况除了包含同 情况一 一样的逆序对外，还会新产生 $2^{n-1}\times2^{n-1}=2^{2\times(n-1)}$ 对逆序对（乘法原理）。

综上，如果设序列 $0,1,2,...,2^n-1$ 对 $n$ 位二进制 $x$ 异或后的逆序对数量为 $f(n,x)$，$x$ 剔除首位后为 $g(x)$，首位为 $h(x)$。

那么有：
$f(n,x)=\begin{cases}0&n=1\text{ 且 }x=0\\1&n=1\text{ 且 }x=1\\2\times f(n-1,g(x))&h(x)=0\\2^{2\times(n-1)}+2\times f(n-1,g(x))&h(x)=1\end{cases}$

实际上，由于我们读入的就是 $x$ 的二进制形式，我们可以在递归/递推时很方便的用当前处理到的 $x$ 的位置来推出 $f(n,x)$ 所需要的 $n,g(x)$ 和 $h(x)$ 。

由于数据规模较小，使用递归、递推均可，在这里提供递归版的代码。

```
#include <stdio.h>
#include <string.h>
unsigned long long p2[200];
char x[200];
int len;
const unsigned long long MOD=1e9+7;
unsigned long long func(int pos)
{
    // 传入当前 x 的首位位置可以推出当前的 n=len-pos
    if(pos==len-1)
    {
    	// n==1
        return x[pos]=='1';
    }
    if(x[pos]=='0')
    {
        return ((func(pos+1)%MOD)*2)%MOD;
    }
    return (p2[2*(len-pos-1)]+((func(pos+1)%MOD)*2)%MOD)%MOD;
}
int main()
{
    p2[0]=1;
    scanf("%s",&x);
    len=strlen(x);
    for(int i=1;i<=len*2;++i)
        p2[i]=(p2[i-1]*2)%MOD; // 预处理 2 的幂
    printf("%llu",func(0));
    return 0;
}

```