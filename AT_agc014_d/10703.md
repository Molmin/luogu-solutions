在博客园食用更佳：[https://www.cnblogs.com/PinkRabbit/p/AGC014.html](https://www.cnblogs.com/PinkRabbit/p/AGC014.html)。

考虑一个叶子，先手把这个叶子连接的那个点染白，则后手必须染黑那个叶子，否则下一步先手即可把叶子染白赢得游戏。

考虑如果有一个点连接了两个叶子，那么先手先把它染白，后手就因为无法顾及两个叶子而输掉游戏。

假设已经不存在这种情况，考虑连续的三个点 $a, b, c$，考虑一个时刻 $a, c$ 周围的除了 $b$ 之外的点全部染白，此时先手将 $b$ 染白。

那么同上，后手将会输掉游戏。我们此时考虑以 $b$ 为根时 $a, c$ 的子树，如果除了 $a, c$ 本身外均有偶数个点，可以证明后手必败。

这是因为先手可以每次找到 $a$ 或 $c$ 子树中深度最大的叶子节点，把它的双亲结点染白，逼迫后手染黑那个叶子。

此时完全等价于把这两个被染色的点从树中删去，用数学归纳法可知最终会删成 $a, c$ 无孩子节点的情况，将 $b$ 染白赢得游戏。

也就是说：如果存在一个节点，以它为根时存在至少两个子树方向上的点数为奇数则先手必胜。

显然如果 $N$ 为奇数，任取一个连接叶子节点的点，必存在另一个点数为奇数的子树，这是因为除了它和叶子还有奇数个点。

所以 $N$ 为奇数时先手必胜。如果 $N$ 为偶数？我们可以做一次 DFS 来计算是否存在这样的点，如果存在也是先手必胜。

如果不存在呢？我并不清楚为何不存在时先手必败，此时我直接把代码提交上去就 AC 了（我当时在 virtual participating）。

赛后查看题解，发现我的 DP 过程（请看代码）竟然等价于求树上是否存在一个完美匹配，即选取一半的边覆盖所有点。

此时思路就清晰了，如果存在完美匹配，先手每染白一个点，后手就染黑它的匹配点，很显然每个点最终都会被染黑。

```cpp
#include <cstdio>
#include <vector>

const int MN = 100005;

int N;
std::vector<int> G[MN];

int Ans, siz[MN];
void DFS(int u, int p) {
	siz[u] = 1;
	int s = 0;
	for (int v : G[u]) if (v != p) {
		DFS(v, u);
		s += siz[v];
		siz[u] ^= siz[v]; 
	}
	if (s >= 2) Ans = 1;
}

int main() {
	scanf("%d", &N);
	if (N & 1) return puts("First"), 0;
	for (int i = 1, x, y; i < N; ++i) {
		scanf("%d%d", &x, &y);
		G[x].push_back(y);
		G[y].push_back(x);
	}
	DFS(1, 0);
	puts(Ans ? "First" : "Second");
	return 0;
}
```