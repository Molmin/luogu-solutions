## 前言

[题目传送门](https://www.luogu.com.cn/problem/P8837)

~~沙发题解，水一波咕值~~ 在阅读本篇题解之前，请确保你已经熟悉以下算法、数据结构：

- 贪心算法
- 排序算法及 `sort` 函数
- 堆及优先队列 `priority_queue` 的使用

## 解题思路

这是一道较好的贪心题。我们来分析贪心策略。

> 每个人至多买一个物品，每个物品只能被买一次，问最多有多少人能买到物品。

考虑将客户和商品一一匹配。题目中要求最大化买到商品的客户人数，所以不难得出，我们应该每次取**最小的** $w$ 和**最大的** $c$ 进行匹配。因为，如果我们不是按这种策略贪心的话，若最小的 $w$ 都能和最大的 $c$ 匹配，我们将得不到最优解。

先将 `w` 数组升序排序，定义游标 $i=1\sim n$ 来对每一个 $w_i$ 进行检查，接着采用大根堆（代码中使用优先队列），将 `c` 数组存入堆中，每次取堆顶（即 `c` 数组当前的最大值，记为 $top$），检查是否满足 $w_i \ge top$，若是，则答案加一，同时将 $top$ 自堆中去除。否则，直接跳过，进行下一轮循环。

## 参考代码

代码中加了注释，读到这里不懂的可以再看看。但是，不要直接复制。

```cpp
//以上省略头文件以及快读部分 
const int N=100010;
int n,m,ans;
int a[N],b[N];
priority_queue<int,vector<int>,greater<int>> q;
/*
	n,m 如题意所述 
	a,b 数组分别表示题目中的 w,c 
	q 即为上文所述的堆 
*/
int main () {
	in(n),in(m);
	for(int i=1;i<=n;++i)
		in(a[i]);
	for(int i=1;i<=m;++i)
		in(b[i]),q.push(b[i]); //将 b 数组入堆 
	sort(a+1,a+1+n); //a 数组升序排序，sort 函数默认升序 
	for(int i=1;i<=n;++i) //如上文所述，进行检查 
		if(a[i]>=q.top()) { //若可以配对 
			++ans; //更新答案 
			q.pop(); //弹出 b 数组中当前的最大值 
		}
	printf("%d\n",ans);
	return 0;
}
```