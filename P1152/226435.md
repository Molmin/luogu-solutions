这道题目的基本思路，就是**相邻**两数作差（千万别读成每两个元素的差），在用桶来标记，再将桶遍历验证，这事就结了。

#### 那么，什么是桶？

桶其实是对数组的巧妙运用，对于一个一维数组a，它的某一项ai是可以保存两个数的，一个是ai，还有一个是下标i。桶的思想，就是用下标表示数，值表示该数是否出现或出现过几次。这是个牺牲空间换时间的操作。

可以看到这个题目的空间复杂度为O(n-1)，因为有n-1个差。不会超空间，时间更不会超。所以直接看代码：
```
#include<bits/stdc++.h>
using namespace std;
int a[1001],ton[1001],n;
int main()
{
    cin>>n;
    memset(ton,0,sizeof(ton));
    for(int i=1;i<=n;i++) cin>>a[i];   //输入
    for(int i=1;i<n;i++)
    if(abs(a[i]-a[i+1])<n)   //作差，一定要加abs不然有可能是负的，小于n防越界
    ton[abs(a[i]-a[i+1])]=1;  //标记
    for(int i=1;i<n;i++)   //遍历1到n-1
    if(ton[i]!=1)   //如果有数没出现过
    {
        cout<<"Not jolly";   //不是欢乐的跳
        return 0;
    }
    cout<<"Jolly";
    return 0;
}
```

最后说一句，对于初用桶的蒟蒻来说，循环终止条件一定是循环变量大于最大的数，而不是数的个数！！！！！！不然就会WA！那片鲜艳的红色是我们最不想看到的东西......