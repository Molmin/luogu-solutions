数论蒟蒻在线讲题......这个题呢，是关于**欧拉函数**的一个很典型的题目，欧拉函数这个东西，初学起来可能会有点懵，但是如果学会了，你会发现它极其简单！跟着我来，相信大家一定能走过这个坑！废话不多说，咱们开始吧~

欧拉函数讲的到底是怎样一个故事呢？首先，咱们先来一波定义：

> **欧拉函数**表示的是**小于x**的**与x互质的数**的个数，我们把它写成$\varphi(x)$

（不会读？可以把这个符号读成fai）

for example:

与6互质的整数是1，5，一共2个，所以$\varphi(6)=2$

与10互质的整数是1，3，7，9，有4个，所以$\varphi(10)=4$

搞清了定义，那接下来咱们来研究一下这东西吧！别急，先从最特殊的情况入手！

> 当$x$为**质数**时，$\varphi(x)=x-1$

好理解！既然$x$是质数，那**除了1和它本身，$x$没有其他因数**，也就是说**小于$x$的$x-1$个数和$x$都是互质的**，所以$\varphi(x)=x-1$

进一步发现……？

> 当$x$可以写成质数的乘方，即$x=p^k$($p$为质数)的时候，$\varphi(x)=p^{k-1}\times(p-1)$

这个理解起来也不是很难，既然它可以写成质数的k次方，那咱们就把**每一段分开处理**！把它每到$p$分成一段，一共分成$\frac{p^k}{p}=p^{k-1}$段，根据刚才的性质，每一段有$p-1$个数与$x$互质，所以一共就是$p^{k-1}\times(p-1)$

另外，欧拉函数还有一条性质：

>$x$与$y$互质时，$\varphi(x \times y)=\varphi(x)\times\varphi(y)$

这个也好理解，**乘法原理**嘛！这也说明，欧拉函数是个**积性函数**，也就是说**函数的值可以通过乘积来算**

有了这几条性质，就可以研究一般的数的欧拉函数啦！通过前两个性质的铺垫，这里思路也渐渐浮出水面了：**把x分解质因数**！

也就是说，我们把x分解成这个形式：$x=\prod^{s}_ {i=1}p_i^{k_i} $

(其中$s$为质因数个数，$p_i$为第$i$个质因数，$k_i$为第$i$个质因数的个数)

哇，又出现新符号啦！好多小伙伴肯定要问了：这个$\prod$又是个什么妖孽！其实啊，这个符号和求和的$\sum$差不多，只不过它是用来求乘积的，也就是说：

$$\prod^n_{i=1}a_i=a_1 \times a_2 \times a_3 \times …\times a_n$$

好的，这回懂了吧，接下来抓稳啦！咱要推导欧拉函数$\varphi(x)$的最终公式啦！

首先，根据刚才的分解质因数，可以知道：



$$x=\prod^{s}_ {i=1}p_i^{k_i} $$

也就是说：

$$\varphi(x)=\varphi(\prod^{s}_ {i=1}p_i^{k_i})$$

然后呢，在利用一下**欧拉函数的第3个性质**，也就是**乘积**的那个

$$\varphi(x)=\varphi(\prod^{s}_ {i=1}p_i^{k_i})$$
$$=\prod^{s}_ {i=1}\varphi(p_i^{k_i})$$

再根据关于**质数乘方**的**第2条性质**

$$\varphi(x)=\prod^{s}_ {i=1}\varphi(p_i^{k_i})$$
$$=\prod^{s}_ {i=1}p_i^{k_i-1}\times(p_i-1)$$

然后咱们在**稍微调整一下下**，**把$p_i^{k_i}$单拎出来**，因为这个式子正好等于$x$嘛！

$$\varphi(x)=\prod^{s}_ {i=1}p_i^{k_i-1}\times(p_i-1)$$
$$=\prod^{s}_ {i=1}p_i^{k_i}\times(1-\frac{1}{p_i})$$
$$=\prod^{s}_ {i=1}p_i^{k_i}\times\prod^{s}_ {i=1}(1-\frac{1}{p_i})$$
至此，我们得到了欧拉函数的公式：

$$\varphi(x)=x\prod^{s}_ {i=1}(1-\frac{1}{p_i})$$

其实这个式子也可以这么理解：咱们要找的是与$x$互质的数，每找到一个质数$
p_i$，就有$\frac{x}{p_i}$个数是不和$x$互质的，那自然就有$x\times(1-\frac{1}{p_i})$个数，对于不同的质数，我们还是用乘法原理，要乘起来得到答案！这样一来，欧拉函数的公式自然就是$x\prod^{s}_ {i=1}(1-\frac{1}{p_i})$啦！

------------

公式有了，但怎么求欧拉函数呢？一个一个算？还要分解质因数，太麻烦了qwq

这里呢，我们可以用**筛法**解决问题！代码是这样的：

```cpp
bool p[10000001]={0,1};//初始化，1不是质数
for(int i=2;i<=n;i++){
		if(p[i]) //如果已经确定不是质数，就没有筛的必要了
      continue;
		for(int j=i*2;j<=n;j+=i) //既然找到这个数，那它的倍数就都不是质数了
		  p[j]=1;
}
```
（吃瓜群众：怎么觉得哪里怪怪的呢）

对不起各位，我不小心（其实是故意）拿错了，这是[筛法求质数](https://www.luogu.com.cn/problem/P3383)的代码......

不过话说回来，筛法求欧拉函数和筛法求质数的代码其实没什么差，就改改中间的部分就行啦！

改哪些部分呢，还是根据公式，一步一步分析

$$\varphi(x)=x\prod^{s}_ {i=1}(1-\frac{1}{p_i})$$

- 首先，公式是$\varphi(x)=x$再乘另外一大坨，所以咱先把每个phi[x]初始化成x
- 其次，和筛法一样，对于找到的没筛过的每一个数，对它的倍数相应处理
- 处理什么呢？注意到如果一个数是$p$的倍数，那它的质因数肯定有$p$这个数，根据公式，我们可以把它的m每一个倍数乘上个$1-\frac{1}{p_i}$，也就是$\frac{p_i-1}{p_i}$

这样的话，筛法求欧拉函数的代码就有了：

```cpp
for(int i=2;i<=n;i++){
	phi[i]=i;//先把每一个数初始化成它自己
}
for(int i=2;i<=n;i++){
	if(phi[i]!=i)//如果已经求过了，直接continue就行
	continue;
	for(int j=i;j<=n;j+=i)  
	phi[j]=phi[j]/i*(i-1);//对于每个倍数，乘上公式里的后面那一项
}
```
回过头来再看这个题：有位大佬已经很快get到了思路：**对于每个坐标$(x,y)$,只要$x$与$y$互质，那就能看到**！注意，**这里说的“坐标”是从0开始，到n-1结束的**

为啥这样就行嘞？因为**不互质的都被互质的挡住了**呗！

还有一个要注意的是，由于最左边的横坐标为0，和最下边的纵坐标为0（就是x轴和y轴），它们需要单独处理，在这里面**只有两个人是能被看到的**（也就是下图中用绿框框起来的那两位），所以我们**把答案初始化为2，到时候坐标从1开始统计**

另外，别忘了**特判n=1的情况**哟！

![](https://cdn.luogu.com.cn/upload/image_hosting/bnkf3v8s.png)

(上图中，浅橙色表示能看到的人，深橙色表示被挡住的人)

这样，我们就有了一份完美的~~36分~~代码：

```cpp
#include<iostream>
#include<cstdio>
using namespace std;

int gcd(int x,int y){//最大公因数gcd——数论开始的地方
	if(x%y==0) return y;
	else return gcd(y,x%y);
}

int main(){
	int n,ans=2;
	cin>>n;
	if(n==1){ //特判n=1的情况
		cout<<0;
		return 0;
	} 
	for(int i=1;i<n;i++){
		for(int j=1;j<n;j++){
			if(gcd(i,j)==1) ans++;//按照刚才的结论暴力枚举
		}
	}
	cout<<ans;
	return 0;
}
```
现在有了欧拉函数，就可以变得快好多啦!而且，我们发现：**两边能看到的人数关于对角线对称**！所以我们只需要用欧拉函数**算出一边的情况，再乘2，加1即可**！为什么要加1呢？因为我们**没有算对角线上的那一个人**

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int phi[40005];
int main(){
	int n;
	scanf("%d",&n);
	if(n==1){//特判n=1的情况
		printf("0");
		return 0;
	}
	for(int i=2;i<=n;i++){//筛法求欧拉函数
		phi[i]=i;
	}
	for(int i=2;i<=n;i++){
		if(phi[i]!=i)
		continue;
		for(int j=i;j<=n;j+=i)
		phi[j]=phi[j]/i*(i-1);
	}
	int ans=1;//ans初始化（因为最后要乘2，当然初始化成1咯）
	for(int i=1;i<n;i++)//把每个互质的个数输出出来
	ans+=phi[i];
	printf("%d",ans*2+1);//乘2，加1，输出！
	return 0;
}
```
欧拉函数get!

The   end~