竟然没有打表题解，那我就来发一篇吧。

首先，身为蒟蒻的我看到这道题显然不会做，只会一个n^2算法，但是再一看数据范围，n<=40000,貌似可以打表过，不会跑太久。于是打了个表，点击了提交，然后，[代码过长].......仔细看一下发现自己的打表代码有100KB,而我似乎记得代码长度限制好像是50KB。但是我不服气，难得一道似乎可以打表过的题目我就不行过不了。

于是，我想到了可以再打表的基础上稍微打下暴力。比如可以打出所有n%1000==0的n的答案，再在上面进行暴力，时间就快了很多。

于是，便有了下面的程序:

```cpp
#include <bits/stdc++.h>

#define re register

using namespace std;

int n,cnt;

int gcd(const int &x,const int &y)
{
    return y==0?x:gcd(y,x%y);
}

int main()
{
    scanf("%d",&n);
    if(n==1||n==0)
    {
        puts("0");
        return 0;
    }
    re int len=1;
    for(re int i=1;i<n;++i)
    {
        for(re int j=1;j<=i;++j)
            if(gcd(i,j)==1) cnt+=(i==j)?1:2;
        if((i+1)%1000==0) printf("%d,",cnt+2);
    }
    return 0;
}

```

然后就打出了所有0-40000的1000的倍数的数的答案，However,当我兴致勃勃地交上去后，竟然T了3个点，然后测了一下39999,好像跑了5s。

那么就只能再减小范围了，把1000改成100，就能~~完美的~~AC了！

放一下主程序：

```cpp
#include <bits/stdc++.h>

#define MAXN 56000
#define re register

using namespace std;

int n,cnt;
int ans[]={2,6009,24305,54637,97037,151833,218681,297557,388861,492173,607585,735437,874933,1026729,1191217,1367565,1555185,1756905,1969157,2193477,2431577,2680685,2940889,3215393,3501389,3797757,4108897,4431193,4764705,5111961,5470777,5840905,6223977,6619089,7025801,7446225,7877801,8320833,8777929,9245101,9724005,10218645,10722205,11239189,11769085,12309593,12860913,13427489,14005837,14593509,15196917,15811033,16436445,17075245,17725765,18386041,19063485,19749721,20446441,21161097,21883129,22616889,23368049,24127621,24897733,25684117,26480773,27284665,28108545,28942137,29785493,30643897,31513121,32392729,33287137,34194825,35109777,36043233,36984177,37936437,38905165,39882765,40872273,41879701,42892741,43917045,44961429,46012953,47072441,48151745,49238237,50337477,51452861,52576489,53711481,54863673,56023265,57195017,58384493,59579725,60786973,62013625,63245161,64487825,65751673,67022869,68299541,69599537,70907169,72222281,73556741,74899533,76253245,77622873,79004301,80394089,81800229,83215673,84640905,86086149,87538117,89000357,90481213,91968573,93465893,94986717,96510133,98044789,99602257,101164589,102730405,104323349,105923069,107527525,109156853,110791985,112436385,114098289,115770985,117447841,119153485,120858545,122575321,124312845,126052101,127807069,129583001,131363853,133152609,134964669,136780633,138604121,140451529,142307625,144169445,146051213,147940213,149838937,151758541,153684369,155619897,157578237,159541385,161512033,163504685,165503029,167509237,169542389,171576593,173618917,175688109,177762137,179837421,181943569,184053181,186171825,188309093,190451393,192606261,194779993,196964693,199153397,201367153,203582769,205810457,208059605,210315541,212574505,214861705,217154097,219447925,221773161,224102741,226434021,228791197,231159549,233531601,235927845,238326629,240734481,243164793,245601193,248047789,250517237,252989765,255473725,257978013,260483089,263004285,265546889,268086105,270639765,273222545,275805973,278392553,281010653,283630605,286255137,288907945,291564745,294225877,296910549,299605145,302304129,305029725,307756501,310491817,313255897,316015945,318787977,321590101,324394157,327194513,330034269,332873789,335711933,338584217,341458273,344343717,347251925,350159481,353079793,356021061,358967045,361921445,364901969,367885425,370880737,373897845,376910929,379940181,382995665,386055309,389110373,392206165,395299273,398391929,401524577,404653709,407786945,410952677,414120533,417289737,420488201,423696333,426901685,430141733,433377645,436623209,439896933,443171701,446449545,449767849,453081233,456391257,459741477,463086461,466437181,469822225,473208953,476599361,480022389,483440145,486873505,490321197,493781125,497244149,500737125,504228721,507727857,511263557,514786121,518324717,521893621,525460593,529028253,532642613,536241905,539842305,543485021,547127549,550772541,554443253,558125821,561808533,565516341,569231337,572950921,576693973,580445165,584202277,587985733,591771409,595559293,599389757,603206953,607034173,610894977,614760053,618616473,622504769,626405093,630308449,634239241,638166297,642109201,646069133,650039933,654011821,658022165,662027749,666027101,670079321,674109573,678157809,682240761,686321033,690394405,694516565,698633321,702744381,706895101,711045345,715200253,719386557,723579333,727765865,731987473,736213877,740446169,744707877,748967125,753230425,757526949,761813457,766115125,770458401,774787813,779119569,783497493,787865857,792235977,796644833,801049253,805460221,809901061,814343545,818793589,823275605,827750801,832231421,836755009,841265357,845778421,850344121,854881013,859442429,864035277,868621377,873208689,877839905,882465365,887090701,891754293,896416797,901080393,905771009,910479497,915176809,919908725,924645929,929382217,934156169,938923801,943706245,948510873,953308877,958118121,962974753,967816633,972659433};

inline void File()
{
    #ifdef Mr_Chen
        freopen("Luogu.in","r",stdin);
        freopen("Luogu.out","w",stdout);
    #endif
}

inline int read()
{
    re int res=0;re bool f=1;
    re char ch=getchar();
    while(ch<'0'||ch>'9')
    {
        if(ch=='-') f=0;
        ch=getchar();
    }
    while(ch>='0'&&ch<='9')
    {
        res=(res<<3)+(res<<1)+(ch&15);
        ch=getchar();
    }
    return f?res:-res;
}

int gcd(const int &x,const int &y)
{
    return y==0?x:gcd(y,x%y);
}

int main()
{
    File();
    n=read();
    if(n==1||n==0)
    {
        puts("0");
        return 0;
    }
    cnt=ans[n/100];//找到n对应的ans值
    for(re int i=100*(int)(n/100);i<n;++i)
    //这里枚举注意是从100*(int)(n/100)开始的
        for(re int j=1;j<=i;++j)
            if(gcd(i,j)==1) cnt+=(i==j)?1:2;
   	//只要gcd(i,j)为1，就说明有一个答案，如果i!=j,就说明gcd(j,i)也可以加一
    printf("%d\n",cnt);
    return 0;
}

```

~~希望管理员不要加强数据~~