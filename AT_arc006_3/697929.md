## 题意：

已知会有 $n$ 个箱子，会按照从先到后的顺序排列，第 $i$ 个箱子的重量为 $w_i$，现在要把箱子堆积起来，要满足上面的箱子重量必须小于等于下面箱子的重量，否则将会压烂箱子，如果大于下面箱子重量的需要另起一堆，求最小会有几堆箱子。


------------

## 思路：
不难看出此题为一道贪心题，读懂题后我们可以简化一下题意：
问我们如果每堆箱子都必须从大到小进行排列安放，至少会有几堆箱子。

没有必要定义数组来表示每个箱子的重量，该题重点是每次放完箱子后最上面的箱子的质量，可以直接用 $w$ 来表示箱子的重量，然后每次循环完成后更新最大承受重量。


------------
## 核心部分

首先第一个箱子肯定会先堆成第一堆，因此我们可以用一个数组 $a$ 来模拟，先输入第一个箱子重量，把 $w$ 的值赋给 $ a_1$。


------------


```cpp
int n,w,sum = 1,ans = 1;cin>>n;
	bool b ;//定义b判断是否有比该箱子质量更大的箱子
	cin>>w;
	a[sum] = w;	
```


------------


然后从 $2\sim n$ 输入该箱子的重量，然后与每堆箱子可承受的最大重量进行比较。如果小于等于，就可以把可承受重量最大值更新为 $w$，反之则增加一堆箱子，值赋给新一堆箱子可承受重量的最大值。

循环完成再输出答案换行即可。


------------

```cpp
for(int i = 2 ; i <= n ; i++ ) {
		cin>>w;
		b = false;//赋初值
		for(int j = 1 ; j <= sum ; j++ ) {
			if(w <= a[j]) {
				a[j] = w ;
				b = true;
				break;
			}
		}
		if(b==false ) {//如果为假，则答案增加
			ans++;
			a[++sum] = w; 
		}
}
```

------------
最后奉上完整代码，仅供参考。

------------
## 代码：
```cpp
#include<bits/stdc++.h>

using namespace std;
const int Maxn = 100010;
int a[Maxn];
int main(){
	int n,w,sum = 1,ans = 1;cin>>n;
	bool b ;
	cin>>w;
	a[sum] = w;	
	for(int i = 2 ; i <= n ; i++ ) {
		cin>>w;
		b = false;
		for(int j = 1 ; j <= sum ; j++ ) {
			if(w <= a[j]) {
				a[j] = w ;
				b = true;
				break;
			}
		}
		if(b==false ) {
			ans++;
			a[++sum] = w; 
		}
	}
	cout<<ans<<endl;
	return 0;
}
```





 