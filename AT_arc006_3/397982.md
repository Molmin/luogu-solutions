#### 题意：你有 $n$ 个物品，你需要按照读入顺序去放置物品。
#### 每一堆的物品重量必须是**递减的**，即底部最大，顶部最小。

~~好像原来的题意有亿点问题~~

## solution:
按照贪心的思想去操作。

由于我们只关心堆顶上的物品的重量，所以只用一个数组存储即可。

我们考虑每新读入一个物品，进行以下操作：

从第一个位置开始，如果有一个位置的堆顶的值 $>$ 这个值就将其加入此堆中，更新堆顶。

注意，这个算法成立的条件是各个堆顶的值单调减。

这是没有问题的，因为当只有一个堆时，明显是单调减的

而加入物品的操作**并不会**破坏单调性。

~~不放心的话Sort一遍也可以，反正也不会超时~~

否则，这个物品的值比其他堆顶都小，新开一个堆。

最后只需要输出堆的个数 $T$ 即可。

## code:
```cpp
#include<iostream>
using namespace std;
const int N=2e5+5;
int n;
int a[N],t;
int main(){
    cin>>n;
    for(int i=1;i<=n;i++){
        int q;
        cin>>q;//输入箱子重量
        int fl=0;//初始化
        for(int j=1;j<=t;j++){
            if(a[j]>=q){//可以相等
                a[j]=q;//更新堆顶的值
                fl=1;//标记
            }
            if(fl) break;//只能更改一次
        }
        if(!fl) a[++t]=q;//如果都无法更新，新建一个堆
    }
    cout<<t<<endl;//输出堆数
    return 0;
}
```
