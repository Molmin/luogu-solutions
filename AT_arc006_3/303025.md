### AT217 题解
本人因为理解错题意而惨遭保龄，已改好。有感而发。

Pascal题解哦！

------------

首先，我要提醒大家，本题翻译疑似有误，请到 [这里](https://atcoder.jp/contests/arc006/tasks/arc006_3)去真正理解题意。


------------
#### 题意解释
根据输入顺序去放置物品。第 $i$ 个物品可以放置在 $1$~$i$-$1$ 的物品上面，但是不能放在  $i$+$1$~$n$ 的物品上面。当一个物品的上面有一个物品比他大的话，这个物品就会被压成奥利给。所以，第 $i$ 个物品如果在前 $i$ 个物品上都放不上去的话，就得单独放一堆。


------------

#### 注意事项
- 还是那句话，AT输出要换行。


------------
#### 帮助理解题意
如果还是不懂题意，没关系，~~我刚开始也不太懂~~，可以借助样例和机翻来理解。

说实在的，Google的机翻都比本题的翻译强。

来几组样例。

###### 样例输入1
```
5
4
3
1
2
1
```
###### 样例输出1
```
2
```
###### 样例输入2
```
7
93
249
150
958
442
391
25
```
###### 样例输出2
```
3
```

###### 样例输入3
```
4
100
100
100
100
```
###### 样例输出3
```
1
```
[Google的Chrome机翻](https://s3.ax1x.com/2021/03/14/60SXAU.png)


------------
#### 代码
```Pascal
var//Pascal来一发！！
i,n,x,j,t:longint;//定义一些杂七杂八的整型变量
p:boolean;//一个哨兵，用来判断用不用单独开
dx:array[0..1000000]of longint;//dx[i]表示第i号堆当前最上面的那个
 begin
  readln(n);//物品的个数
  for i:=1 to n do//一个循环，边读边处理
   begin
    readln(x);p:=false;//开始放置，p为哨兵
    for j:=1 to t do//循环跑一遍，看看可不可以放
     if dx[j]>=x then
      begin
       p:=true;
       dx[j]:=x;
       break;//如果可以放，那就将p标记为true，并将最上面的物品大小更新
      end;
    if not p then begin inc(t);dx[t]:=x; end;//放不了，另开一个堆。并且更新堆的数量
   end;
  write(t);//输出堆的数量
 end.//结束
```


------------

码字不易，点个赞呗![kel](https://cdn.luogu.com.cn/upload/pic/62226.png)