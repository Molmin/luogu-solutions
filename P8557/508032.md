# 前言
几乎是历史最难第一题。（如果按大月赛规模来算）
# Solution

看见这个数据，我几乎就已经认为这是一道复杂度为 $O(1)$ 的结论题。~~但事实证明我是错的。~~

我们来思考一下，为什么我们看到这道题没有思路:

因为我们不知道每个熔炉里装了哪些金属，一号熔炉里既可能同时装着 $1,2$ 号金属，也可能一个金属都不装，全部留给二号熔炉。

放到其他熔炉也是这样，所以很难用一个数学表达式把它写出来。

但是转念一想：**如果我们不从熔炉角度考虑，我们从金属角度考虑，这道题是不是会变简单。**

其实想到这一点之后，这题已经几乎做出来了。

还是先拿样例举例：$1$ 号金属可能放在一号熔炉里，也可能放在二号熔炉里，也有可能同时放在两个熔炉里，但至少要放在某一个熔炉，绝对不能不在任何一个熔炉里。

所以这块金属有 $3$ 种放法，同理 $2$ 号金属也有 $3$ 种放法。所以最后答案为 $9$。

接下来我们就扩展到正常的数据：对于某一块金属来说，它可以放在这一个熔炉里，也可以不放在这一个熔炉里。情况数为 $2$。因为有 $k$ 个熔炉，所以这一块金属放在这 $k$ 个熔炉中的情况总数就是 $2^k$。

噢对了，由于某一块金属**不能不放在任何一个熔炉里**，所以在情况总数中应该减去这么一种情况，总情况数应该为 $2^k-1$。

同时又因为有 $n$ 块金属，所以最后答案为 $(2^k-1)^n$。

与此同时，（看一眼本题的数据规模）这道题的数据让我们必须要写快速幂。

不知道怎么写的康这里：[P1226 【模板】快速幂||取余运算](https://www.luogu.com.cn/problem/P1226)
## 注意逝项
1、虽然这道题的数据好像在整型范围之内，不过还是开个 long long 保险一点吧。

2、如果快速幂写的不太好，就需要特判。

# AC code

```cpp
#include<iostream>
using namespace std;
typedef long long ll;
const ll mod=998244353;
ll fast_power(ll b,ll p,ll m){
    ll r=1;
    while (p>0){
        if(p&1){
            r=r*b%m;
        }
        p>>=1;
        b=(b*b)%m;
    }
    return r;
}
ll n,k;
int main(){
    scanf("%lld%lld",&n,&k);
    printf("%lld",fast_power((fast_power(2,k,mod)+mod-1)%mod,n,mod));
    return 0;
}
```
# The End.