这个题主要是对表的利用

![](http://cdn.luogu.com.cn/upload/pic/30.png)

乍一看这个图，卧槽，这尼玛是什么东西，一脸懵逼。但仔细一看是能读出规律的。

表的横坐标和纵坐标分别代表明文（也就是你最后求得）和密钥，表中的点代表的是密文（也就是你需要破解的）

（当然横纵坐标分别代表什么取决于个人思路，因为表是对称的）

注意:

千万不要搞混这个图！ 千万不要搞混这个图！千万不要搞混这个图！（作为把密文二次加密的人，我表示：重要的事情说三遍）——————————————————————————————————————————————————————————————

首先我们来分析这个图，我们用字母序代替字母（A=1，B=2.....）,我们不难发现，横坐标（明文 ）=密文（表中的数）-纵坐标+1

如果密文-纵坐标<0，则明文=密文-纵坐标+26+1。

例如：

纵坐标（密钥）为P，密文为G，因为P的字母序为16，G的字母序为7，7-16=-9<0，所以密文所对应的数为-9+26+1=18，而18所对应的字母为R，则R即为所求明文。

——————————————————————————————————————————————————————————————

由于密钥的长度<=密文的长度，当密钥长度<密文长度时需要将密文大于密钥的部分用密钥循环覆盖。

例如：

密钥长度为3，为abc，而密文长度为6，则需要将密钥长度变为6，为abcabc，来与密文对应。

——————————————————————————————————————————————————————————————

此外，还需要注意到大写字母问题

话不多说，放程序。

——————————————————————————————————————————————————————————————

    
```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#include<algorithm>
#include<cmath>
using namespace std;
int mapx[27][27];
char K[1001],C[1001];//用K和C来存输入，K为密钥，C为密文，类型是字符类型
int m[1001],k[1001],c[1001],Bigc[1001];//Bigc用来判断密文中的大写字母，m，k，用于将K，C输入的字母转为整数类型的字母序。
//打表，用mapx[x][y]来打表记录XY对应的明文。原理在上面讲过。
void PRINTS()
{
    for(int i=1;i<=26;i++)
        for(int j=1;j<=26;j++)
        {
            if(j-i<0)
                mapx[i][j]=j-i+26+1;
            else mapx[i][j]=j-i+1;
        }
    return;
}
int main()
{
    cin>>K;
    memset(Bigc,0,sizeof(Bigc));
    int len=strlen(K);//记录密钥的长度
    for(int i=0;i<len;i++)
    {
        if(K[i]<97)//大写字母的ASCII码为65—90，小写字母为97—122。当小于97时为大写字母，减64即为字母序。
        {
            k[i]=K[i]-64;
        }
        else
            k[i]=K[i]-96;//同理，小写字母减96即为字母序。
    }
    cin>>C;
    int len1=strlen(C);
    for(int i=0;i<len1;i++)
    {
        if(C[i]<97)
        {
            c[i]=C[i]-64;
            Bigc[i]=1;//记录是否为大写字母。
        }
        else 
            c[i]=C[i]-96;        
    }
    if(len1>len)//将K的大小扩大到M的大小
    {
        for(int i=0;i<len1;i++)
        {
            if(i>=len)
                k[i]=k[i-len];
            else 
            k[i]=k[i];
        }
    }
    PRINTS();//打表
    for(int i=0;i<len1;i++)
    {
        m[i]=mapx[k[i]][c[i]];//用m来存明文的字母序
    }
    for(int i=0;i<len1;i++)
    {
        if(Bigc[i]>0)
        {
            m[i]+=64;//如果对应位置的密文为大写字母，那么明文也变为大写字母
        }
        else
            m[i]+=96;//变成小写字母
        cout<<(char)m[i];
    }    
}
```
——————————————————————————————————————————————————————————————
代码比较冗杂，但比较容易理解，非常浅，纯模拟。
