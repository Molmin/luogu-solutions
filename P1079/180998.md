我看了一下，应该没有和我思路一样的

~~如果有就是我眼瞎~~

         ——————>
         
       1 2 3 4..................................26
![](https://cdn.luogu.com.cn/upload/pic/30.png)
## 让我们观察一下这个图

我们把A到Z标为1到26

不难发现，每一个**45度斜**的一行横纵坐标**加和**是一样的

## 我们可以暴力把每一个斜行的**加和**存到一个数组x[]里
```
	for(int i=1;i<=26;i++)
		x[i]=i+1,x[26+i]=i+1+26;
```
左上角的A加和为2，往后依次++

通过观察，发现这个表中从**左上**到**右下**把A~Z遍历一遍后又从A~Y遍历一遍这样就有了x[i]=i+1,x[26+i]=i+1+26

（虽说第二个Z没用，但写了也无妨）

然后用**加密文**中字母所对应的数字找到**x**[]中所对应的加和减去**密钥**字母所对应的数字就是原文本所对应的数字了

再用阿斯克码还原成字母就行了

## 这里还需要一个v[]数组

用来记录**大写字母**

这道题是有大写字母的，对应的原文也得是大写字母，所以要记下来

**PS**：本人阿斯克码弱的一批，所以字符、数字转换麻烦了一些，大佬凑合看吧

AC代码：
```
#include<bits/stdc++.h>
using namespace std;
char a[1010],b[110],c[1010];//存字符， a密文  b密钥  c原文 
int a1[1010],b1[110],c1[1010];//存数字 
bool v[1010];//v[i]为1则c[i]为大写 
int x[60];//存每一斜行加和 
int main()
{
	cin>>b>>a;
	for(int i=1;i<=26;i++)  //预先把加和打好 
		x[i]=i+1,x[26+i]=i+1+26;
	int l=strlen(a),l2=strlen(b);
	for(int i=0;i<l;i++){       //a转化成数字 
		if(a[i]>='a'&&a[i]<='z')
		a1[i]=a[i]-'a'+1;
		else{
			a1[i]=a[i]-'A'+1;
			v[i]=1;
		}	
	}
	for(int i=0;i<l2;i++){    //b转换为数字 
		if(b[i]>='a'&&b[i]<='z')
		b1[i]=b[i]-'a'+1;
		else
		b1[i]=b[i]-'A'+1;
	}
	int n=0;
	for(int i=0;i<l;i++){//作差求原文 
		if(x[a1[i]]>b1[n])//这里为什么要判断一下呢？前面说了，同一字母会在不同斜行中出现两次 
		c1[i]=x[a1[i]]-b1[n];
		else
		c1[i]=x[a1[i]+26]-b1[n];
		n++;
		if(n==l2) n=0;
	}
	for(int i=0;i<l;i++){//再把c转化成字符 
		if(!v[i])
		c[i]=c1[i]-1+'a';
		else
		c[i]=c1[i]-1+'A';
	}
	cout<<c;
	return 0;
}
```

撒花。。
