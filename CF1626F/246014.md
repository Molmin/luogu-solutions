## CF1626F 【A Random Code Problem】

### 题意

+ 长度为 $n$ 的数组 $a$，初值为 $0$ 的变量 $ans$，进行 $k$ 次操作；
+ 第 $i(i\in[1,k])$ 次等概率选 $a_j$，$ans\Leftarrow ans+a_j$，$a_j\Leftarrow a_j-a_j\bmod i$；
+ 求所有可能的情况下，第 $k$ 次操作后 $ans$ 的总和（即 $E_{ans}\times n^k$）；
+ $n\le10^7$，$k\le17$，$a_i<998244353$。

### 做法

记录了我的思考过程，想认真学习优化方法的可以从头阅读，想直接看正解的麻烦空降方法三。

方法一：

$k$ 很小，容易联想到 $O(2^k)$ 枚举。对于 $a_j$，枚举选中这个数的操作集合，计算产生的贡献，稍加预处理可做到复杂度 $O(nk2^k)$，可以把算贡献和枚举集合同时完成，复杂度 $O(n2^k)$，但依然无法通过。

方法二：

把 $a_j\Leftarrow a_j-a_j\bmod i$ 称为 $a_j$ 被 $i$ 修改，注意到在最后一次操作前，一个数只可能被集合 $S\subseteq[1,16]$ 内的元素按升序依次修改，不妨设 $L=\operatorname{lcm}(1,2,\dots,16)=720720$，$x=\lfloor\frac{a_j}{L}\rfloor$，$y=a_j\bmod L$，则 $a_j=xL+y$，容易发现，无论 $a_j$ 被如何修改，$xL$ 始终不变，即 $a_j$ 被修改，相当于 $y$ 被修改。

所以把 $a_j$ 拆开算贡献，$xL$ 部分不用修改，复杂度 $O(n)$。$y$ 部分值域为 $[0,L)$，开个桶，多个数同时统计，从而节约计算时间。计算方法和方法一相同，复杂度 $O(n+L2^k)$。总复杂度 $O(n+L2^k)$，又有一定优化，但依然无法通过。

方法三：

枚举过程中，如果 $a_j$ 被修改，其实就变成另一个数，可以一起计算，从而节约计算时间。比如设 $a_j=5$，被 $2$ 修改后就等于 $4$，那 $5$ 先被 $2$ 修改后，再被 $4,5,7,13$ 依次修改，和 $4$ 被 $4,5,7,13$ 依次修改，其实可以一起统计，很自然地，就联想到动态规划。

设 $dp_{i,j}$ 为第 $i$ 次操作前，$a$ 数组中 $y=j$ 的个数。特别地，$dp_{1}$ 就是方法二中的桶。考虑转移，第 $i$ 次操作有 $n-1$ 种方法不选到某个 $y$，在下一次操作前 $y$ 不变，即 $dp_{i+1,j}\Leftarrow dp_{i+1,j}+(n-1)\times dp_{i,j}$；第 $i$ 次操作有 $1$ 种方法正好选到某个 $y$，在下一次操作前 $y$ 变为 $y-y\bmod i$，即 $dp_{i+1,j-j\bmod i}\Leftarrow dp_{i+1,j-j\bmod i}+dp_{i,j}$。最后统计答案，别忘了 $xL$ 的部分。复杂度 $O(n+Lk)$，可过。