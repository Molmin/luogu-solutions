加了翻译之后好受多了……

第一篇题解，仍有生疏请关照。

其实这一题远远没有标签上写的那么难，暴力加优化就能过。首先朴素地思考一下，这题的位置范围一直到$10^9$，一个点一个点来绝对是不可能的，而对于一个两个相邻草堆围成的区间，要是其中一个点能够跑出去，那么这个区间内的其他点也能跑出去。单个区间内的加速值等于该区间的长度，一旦到达另一个区间，这一次逃脱的加速值就最大为原加速值+该区间的长度。

这样我们就得到了最简单最简单，最暴力最暴力的算法，一个区间一个区间判断，如果能够跑出去就让ans加上该区间的长度。复杂度显然是$n^2$，会TLE66分。然后我们往上叠一个很简单的优化。

如果在向左右猪突的过程中进入了一个原本就能跑出去的区间，由于是从旁边的区间进入该区间，所以这时的加速值一定比原本在该区间开始时大，而原本的加速值就足以跑出去，那么这时绝对也能跑出去。我们只需要用一个数组记录下能够跑出去的区间，或者用一个变量记录下最右边的能跑出去的区间的编号，一旦进入该区间就更新该变量（不过这点空间还没到用不起的地步）。

这题的数据强度显然不足，上面的本质还是$n^2$算法，一旦设置一个全部都跑不出去的数据点就能卡洗你，官方的正解也要求用$nlogn$算法，仍然推荐研究一下。以下为参考代码：

```cpp
#include<bits/stdc++.h>
using namespace std;;
long long n,ans;
bool mk[100005];
struct grass{
    long long s,p;//大小与位置 
}gra[100005];
bool cmp(grass a,grass b){
    return a.p<b.p;
}
int main(){
    cin>>n;
    for(int i=1;i<=n;i++)
        cin>>gra[i].s>>gra[i].p;
    sort(gra+1,gra+n+1,cmp);//使草堆按照位置排序 
    for(int i=1;i<n;i++){//枚举起始点为第i个草堆的区间 
        int now=gra[i+1].p-gra[i].p,l=i,r=i+1;
        bool flag=1;
        while(1){
            bool done=1;
            if(gra[l].s<now&&l>=0){//向左猪突 
                done=0;
                now+=gra[l--].p-gra[l].p;
            }
            if(gra[r].s<now&&r<=n+1){//向右猪突 
                done=0;
                now+=gra[r+1].p-gra[r++].p;
            }
            if(r==n+1||l==0||mk[l]==1){//到达边界或者向左猪突到了一个本身就能出去的区间 
                flag=0;
                break;
            }
            if(done)
                break;//在能够打破草堆的情况下一直尝试向左右猪突 
        }
        if(flag)
            ans+=gra[i+1].p-gra[i].p;
        else mk[i]=1;//flag==0该区间能够跑出去，记录下来。 
    }
    cout<<ans;
}
```
I'm Schwarzkopf Henkal.