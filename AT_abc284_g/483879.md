# ABC284G 题解

## 考场思路

注：这个思路是 **错误** 的。

当时想的是对 $i\rightarrow A_i$ 建边，得到一个内向基环树森林，然后子树 `dp`？

显然 `dp` 还要套背包，或许可以做，但是时间至少 $O(n^2)$ 直接炸掉。

## 正解

重点：$n$ 个数是 **对称** 的，所以只需要计算 $S_1\times n$。

发现 $B_1$ 应该是先出现唯一的 $x$ 个数，然后重复出现 $y$ 个数。

要统计的就是 $x$ 的和。

考虑枚举 $k=x+y$。

- 先选出前 $k$ 个数，应用乘法原理就是 $(n-1)\times(n-2)\times\dots\times(n-k+1)$；
- 再分配其他的数的 $A_i$，即 $n^{n-k}$；
- 在上面都选好以后，对于每一个 $0\le x\lt k$，都有唯一一种分配 $A_{B_{k}}$ 的方式对答案贡献是 $x$。

乘起来就是 $(n-1)\times(n-2)\times\dots\times(n-k+1)\times n^{n-k}\times \frac{k(k-1)}{2}$。

注意模数不是质数所不可以用阶乘逆元算，但是可以对前半部分直接累乘，后半部分快速幂或预处理。

记得最后乘 $n$！

看实现方法，时空复杂度是 $O(n)$ 或 $O(n\log n)$，可以解决此题。

## 代码

```c++
int n,p;
int qp(int a,int b){
	int c=1;
	while(b){
		if(b&1)(c*=a)%=p;
		(a*=a)%=p;b>>=1;
	}
	re c;
}
void run(){
	cin>>n>>p;
	int ans=0,cur=1;
	rept(i,1,n+1){
		(cur*=n-i+1)%=p;
		(ans+=(i*(i-1)/2)%p*cur%p*qp(n,n-i)%p)%=p;
	}
	cout<<ans*n%p<<"\n";
}
```

## 背景

当时老师叫我们打 abc，只做最后两题，想了一整场 g 都没做出来（