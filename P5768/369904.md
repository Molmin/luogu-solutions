首先，我们需要明白一个道理，由于匹配的时候只匹配掩码的长度，设为 $l$ 。那么我们只插入前 $l$ 个字符即可。

其次我们考虑如何求出在 $l$ 和 $r$ 之间求出连接个数。

在考虑具体问题之前，有一点很重要

$ans(r,l)=ans(1,r)-ans(1,l-1)$
 
 根据这个性质，我们分别求出 $ans(1,r)$ 与 $ans(1,l-1)$ 即可。

我们 trie 最开始标记的是当前字符是否出现过。然而在这个题目背景下，我们考虑标记插入的时间。

那么，我们现在知道标记的时间，该如何求出连接个数呢。

举个例子。

![](https://cdn.luogu.com.cn/upload/image_hosting/d8uf8bf0.png)

这种情况下是显然的，这两个节点就是我标记好的节点，直接计算中间的节点数即可。

但现在有一个问题，如果情况变成这种该怎么办呢？

![](https://cdn.luogu.com.cn/upload/image_hosting/07at9yhu.png)

我们要求 $l$ 和 $c$ 之间的连接个数。

我们发现，$c$ 是废的。因此我们在这种情况下就不考虑 $r$ 节点了。

看到这，我们发现，这个结构类似于单调栈。

即，当我后插入的节点比前面的节点小时，那么前面的节点就不要了。

因此我们考虑用一个单调栈来维护。

每次把比当前时间靠后的节点弹出去，所剩下的元素个数就是我们要求的答案。


