[题目传送门](https://www.luogu.com.cn/problem/P9391)。

分析：

很水的一道题，思路做法都比较多。（遗憾的是我考试时竟然一直超时，考完才想出来。）我的做法是，每次操作前先将 $a _ m$ 取模后记录初始坐标，再每次加 $a _ m$ 并将这个数标记（无论这个点有没有标记过，直接标记不会有影响）。直到加到了初始坐标停止。但这样肯定会超时，所以每次先判断初始坐标没有标记过才开始标记，否则跳过。

解释：

当到了 $a _ m$ 时，若果当前这个数被标记过，这说明它前面至少有一个等于它，或它为前面那个数倍数。那因为所有它能标记的数，已经都被前面那个数标记过了，所以这个数也就无用了。

------------
代码：
```cpp
#include<bits/stdc++.h> 
using namespace std;
int a,s,d,f,g,h;
bool aa[500005];//标记数组。 
signed main(){
	cin>>a>>s;
	for(int i=1;i<=s;i++){
		cin>>d;
		g=0;
		h=d;
		d%=a;//必需模，否则可能超过n。 
		f=d;
		if(aa[d]==0)//关键代码，否则超时。 
			do{
				if(!aa[d])
					aa[d]=1,g++;
				d+=h;
				d%=a;
			}
			while(d!=f);
		printf("%d ",g);
	}
	return 0;
}
```
蒟蒻的一篇题解，如有不满敬请见谅。