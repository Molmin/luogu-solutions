## 题意简述

在一个字符串中删掉最少的字母使这个字符串能由词典里若干个字符串拼接而成。

## 确定状态

$f_i$ 表示母串的前 $i$ 个字符能由字典的单词拼成所要删除的最少字母数。

## 转移方程

分两种情况讨论。

1. 删掉当前的字符。
2. 删掉若干个字母，使其中一个字典中的字符串是当前的后缀。

第一种情况很好想，直接 $f_i=f_{i-1}+1$。

第二种情况要枚举每个单词，即 $f_i=\min(f_p+i-p+1-lth)$。

其中，$lth$ 表示当前枚举的字符串的长度，$p$ 指的是如果当前枚举到的单词要成为母串前 $i$ 项的后缀，当前枚举的单词的第一个字母可以在的最靠右的位置。

## 怎样求 $p$

设 $dp_{i,j,k}$ 是第 $j$ 个字符的后 $k$ 项成为母串的前 $i$ 项的后缀时，当前枚举到的单词的第 $k$ 个字母可以在的最靠右的位置。

求 $dp_{i,j,k}$ 时，可以用一个游标 $w$，初始值是 $dp_{i,j,k+1}-1$ 。游标往前走，直到字符匹配成功，即母串的第 $w$ 项等于子串的第 $k$ 项时，游标停止，将 $dp_{i,j,k}$ 更新为 $w$。

当 $w$ 为负数时，即无论如何都无法使第 $j$ 个单词是母串前 $i$ 项的后缀。

## 总代码
```cpp
#include <bits/stdc++.h>
using namespace std;
int w,l;
int f[305],dp[305][605][30];
string s,c[605];
int main(){
	cin>>w>>l;
    cin>>s;
    for(int i=1;i<=w;i++)cin>>c[i];
    for(int i=0;i<l;i++){
    	for(int j=1;j<=w;j++){
    		dp[i][j][c[j].size()+1]=i+1;
    		for(int k=c[j].size();k>=1;k--){
    			int nw=dp[i][j][k+1];
    			nw--;
    			while(s[nw]!=c[j][k-1]&&nw>=0)nw--;
    			dp[i][j][k]=nw;
			}
		}
	}
	for(int i=0;i<l;i++){
		f[i]=f[i-1]+1;
		for(int j=1;j<=w;j++){
			if(dp[i][j][1]>=0)f[i]=min(f[i],f[dp[i][j][1]-1]+(i-dp[i][j][1]-(int)c[j].size()+1));
		}
	}
	cout<<f[l-1];
}
```
