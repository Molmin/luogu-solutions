看到还没有人具体证明过，为什么题目中描述的操作是求后缀和，所以我来简略证明y一下：

考虑到我们有一次修改操作，在位置 $a$ 上修改；一个查询操作，在 $b$ 位置上。

我们先将两个操作的代码摆在下面：

```cpp
void Mdf(int x) {
    for (; x; x -= lowbit(x))
        s[x] += 1;
}

int Qry(int x) {
    int ret = 0;
    for (; x <= n; x += lowbit(x))
        ret += s[x];
    return ret;
}
```



1、当 $a<b$ 时：

我们考虑修改操作会涉及到的树状数组中的位置均 $\leq a$ ，而查询操作中会涉及到的数组中的位置均 $\geq b$ ，所以这次修改操作不可能会对这次查询操作有贡献。

2、当 $a = b$ 时：

此时必然在 $s[x]$ 处修改操作会对查询操作有贡献。

3、当 $a>b$ 时：

我们考虑它们的二进制的样子：


$$
\begin{aligned}
a:0110 \dots 01x \\
b:0110 \dots 01y
\end{aligned}
$$

假设二进制总长 $M$ ，它们前面有k位相同 $k \in [0,M)$ ，抛去$a$ 和 $b$ 前 $k$ 位，剩下的分别是 $x,y$ ，因为 $a>b$，所以 $x$ 的第一位是 $1$ ，$y$ 的第一位 $0$。这个时候我们再分类讨论

+ 1、当 $y$ 全是零的时候，一直执行修改操作的 $-=lowbit(x)$ 有一个时刻会把 $x$ 全变成 $0$ ，此时 $a,b$ 相同，而且之后的操作 $a$ 不会变大，$b$ 不会变小，所以它们当且仅当会在 $\lfloor \frac{x}{2^{M-k}} \rfloor \times 2^{M-k}$ 这一个位置产生贡献。
+ 2、当 $y$ 不全是零的时候，因为 $x>y$，而且第一位就已经不同了，所以我们一直执行查询操作的 $+=lowbit(x)$ 直到 $y$ 的第一位变成 $1$ ，此时 $y$ 除了第一位都是 $0$ 。再一直执行修改操作的 $-=lowbit(x)$ 直到 $x$ 的第一位以外都变成 $0$ 为止，此时 $x=y$，因为操作的过程中 $x$ 一直减小，$y$ 一直增大，所以在执行操作的过程中一直有 $a>b$ ，同理之后再一直进行操作会一直有 $a<b$，所以此时它们当且仅当会在$\lfloor \frac{x}{2^{M-k-1}} \rfloor \times 2^{M-k-1}$ 这一个位置产生贡献。

这样我们就证明了当且仅当修改操作的位置 $\ge$ 查询操作的位置是才会对查询操作产生贡献。

之后就只剩下树套树维护两点之间同时存在的概率，和喜闻乐见的卡常环节了。QAQ

