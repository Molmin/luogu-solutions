### 题意：

定义一种由  `()` `[]` `{}` 做成的表达式：ss表达式。

其中，空串为ss表达式，ss表达式中括号嵌套 : `[]` 中不能有 `{}` ,`()`中不能有 `[]` 和 `{}`。

给定三种括号的数量，要求深度为 k 的ss表达式共有多少种。

### 题解：

我们设状态：$dp[b1][b2][b3][d]$ 为使用了b1个`{}`，b2个`[]` ，b3个`()`，且深度小于等于d的方案数量。

接下来是重头戏：如何转移状态？

- 我们可以将一个ss表达式外面加上括号，转移到另一个ss表达式；
- 也可以将两个ss表达式拼接起来，转移到另一个ss表达式。

显然这有两种转移规则并不好弄，并且第二条还有致命问题 

我们考虑ss表达式 `{[(())[()][]]}` ，我们发现它只能从 `[(())[()][]]` 转移来，这很显然。

~~也就是`()`转移到`(())`。~~

但是对于ss表达式 `[()()][(())][]` , 我们发现我们既可以将 `[()()]` 接上个 `[(())][]` 得到，也可以从 `[()()][(())]` 接上 `[]` 来得到。

~~也就是`()`到`()()()`和`()()`到`()()()`。~~

考虑将这两种转移方式统一，更重要的是不能出现重复情况。

我们考虑采用： `A` 转移到 `(A)B` 的转移方式。
这样我们从`[()()]`转移到 `[()()][(())][]`，转移方案唯一。

特别的，当B为空串的时候就相当于在ss表达式外面套了一个括号。

确定了转移方式那么就很好想了。
我们枚举A外面的括号种类。
当为大括号的时候则：
```cpp
FOR(b1,a1-1) FOR(b2,a2) FOR(b3,a3){
(dp[a1][a2][a3][d] += dp[b1][b2][b3][d-1]*dp[a1-b1-1][a2-b2][a3-b3][d]%P)%=P;		
}

```
中括号的时候：
```cpp
FOR(b2,a2-1) FOR(b3,a3){
(dp[a1][a2][a3][d] += dp[0][b2][b3][d-1]*dp[a1][a2-1-b2][a3-b3][d]%P)%=P ;				
}
```
小括号的时候
```cpp
FOR(b3,a3-1){
(dp[a1][a2][a3][d] += dp[0][0][b3][d-1]*dp[a1][a2][a3-b3-1][d]%P)%=P;
}
```

当我们枚举A外面的括号种类时，我们要在转移方程里将这种括号减去一个。然后将A的方案数与B的方案数相乘。
转移边界是 $dp[0][0][0][d] = 1$


完整代码：
```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
#define ll long long
#define FOR(x,y) for(int x = 0;x <= y;x ++)
#define Pri 
using namespace std;

int read()
{
	int a = 0,x = 1;
	char ch = getchar();
	while(ch > '9' ||ch < '0'){
		if(ch == '-') x = -1;
		ch = getchar();
	}
	while(ch >= '0' && ch <= '9'){
		a = a*10 + ch-'0';
		ch = getchar();
	}
	return a*x;
}
const int N=100,P=11380;
int l1,l2,l3,D;
ll dp[20][20][20][N];
int main()
{
	l1=  read(),l2 = read(),l3 = read(),D = read();
	FOR(a1,l1) FOR(a2,l2) FOR(a3,l3) FOR(d,D){
		if(a1 == 0 && a2 == 0 && a3 == 0){
			dp[a1][a2][a3][d] = 1;
				continue;
		}
		if(!d) continue;
		FOR(b1,a1-1) FOR(b2,a2) FOR(b3,a3){
					(dp[a1][a2][a3][d] += dp[b1][b2][b3][d-1]*dp[a1-b1-1][a2-b2][a3-b3][d]%P)%=P;		
				}
			
		
		FOR(b2,a2-1) FOR(b3,a3){
				(dp[a1][a2][a3][d] += dp[0][b2][b3][d-1]*dp[a1][a2-1-b2][a3-b3][d]%P)%=P ;				
			}
		
		FOR(b3,a3-1){
			(dp[a1][a2][a3][d] += dp[0][0][b3][d-1]*dp[a1][a2][a3-b3-1][d]%P)%=P;
		}
				
	}
	if(D == 0){
		printf("%lld",dp[l1][l2][l3][D]);
		return 0;
	}
	printf("%lld",(P+dp[l1][l2][l3][D] - dp[l1][l2][l3][D-1])%P);
	return 0;
}
```
