根据标签来看，这是一道动态规划的题目。

对于给出的这些变量，设 $f[i][j][k][d]$ 表示串中有 $i$ 个( )、$j$ 个[ ]、$k$ 个{ }、深度不大于 $d$ 时的方案总数。

由定义可知，两个 SS 串拼在一起也是一个 SS 串，我们可以借此来进行动态规划。但是，若一个 SS 串为 ABC，在计算时就会将 $AB+C$ 和 $A+BC$ 作为两个方案计算在内，但实际上是同一种方案。

因此，为了避免重复，可以在动态规划时令一个串强制在最外面加上一个括号(就是满足要求的最小括号)。

所以，首先枚举一个串中有的每种括号的数量，然后把所有括号分成两部分，对答案的贡献即为分成的两个串的乘积。

不过要注意取模。

那么输出的答案是什么呢？？？

显而易见，如果 $d$ 的值为 $0$，那么我们只用输出
```
f[l1][l2][l3][d]
```
深度都是 $0$ 了，那肯定输出这个呀！！


反之，就输出
```
(f[l1][l2][l3][d]-f[l1][l2][l3][d-1]+mod)%mod
```
注意不要写成
```
(f[l1][l2][l3][d]-f[l1][l2][l3][d-1])%mod
```
这两个式子不一定相等（虽然我也算不出来为什么，只不过是猜对的）。。

代码如下：
```
#include<bits/stdc++.h>
using namespace std;
const int mod=11380;
int l1,l2,l3,d;
int f[15][15][15][35];
int main()
{
    cin>>l1>>l2>>l3>>d;
    f[0][0][0][0]=1;
    for(int i=0;i<=l1;i++)
    {
    	for(int j=0;j<=l2;j++)
    	{
    		for(int k=0;k<=l3;k++)
    		{
    			for(int l=1;l<=d;l++)
    			{
    				if(i!=0||j!=0||k!=0)
    				{
    					int F=0;
    					for(int a=0;a<k;a++)
    					{
    						F=(F+f[i][j][k-a-1][l]*f[0][0][a][l-1])%mod;
						}
						for(int a=0;a<j;a++)
    					{
    						for(int b=0;b<=k;b++)
    						{
    							F=(F+f[i][j-a-1][k-b][l]*f[0][a][b][l-1])%mod;
							}
						}
						for(int a=0;a<i;a++)
						{
							for(int b=0;b<=j;b++)
							{
								for(int c=0;c<=k;c++)
								{
									F=(F+f[i-a-1][j-b][k-c][l]*f[a][b][c][l-1])%mod;
								}
							}
						}
						f[i][j][k][l]=F;
					}
					else
					{
						f[i][j][k][l]=1;
					}
				}
			}
		}
	}
	if(d>0)
	{
		cout<<(f[l1][l2][l3][d]-f[l1][l2][l3][d-1]+mod)%mod;
	}
	else
	{
		cout<<f[l1][l2][l3][d];
	}
    return 0;
}
```

我是一个爱写题解的初一党蒟蒻。。