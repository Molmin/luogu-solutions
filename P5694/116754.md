# 一、题目大意

求出所有由L1个{}、L2个[]以及L3个()组成的合法括号串中，深度为D的个数。这里合法的定义为()不能套在[]、{}的外面，[]不能套在{}的外面。对于一个合法的串S，深度d(S)={0 S为空串；d(A)+1 S=(A)、[A]、{A}；max{d(A),d(B)} S=AB}。

# 二、思路

今天老师上课给我们讲的题，这里发个题解再深刻理解一下~~

既然已有dalao发了记忆化搜索的题解，这里就用纯dp的写法。

考虑状态f[l1][l2][l3][d]为选l1个{},选l2个[],选l3个()并且深度为d的个数。分析一下一个合法串的样子，只有可能是两种：S=(A)、[A]、{A}或S=AB，分别转移一下。第一种情况比较容易，枚举一下最外层是什么括号，需要注意的一点是若外面是[]，那么A就不能含有{}；若外面是()，那么A就不能含有{}、[]。

第二种情况，我们发现，要让max{d(A),d(B)}=d的AB枚举起来十分繁琐，此时我们想一下是否可以微调一下状态。我们考察状态f[l1][l2][l3][d]为选l1个{},选l2个[],选l3个()并且深度**不超过**d的个数。我们再反观一下这种状态的情况一，发现转移方程和之前的一模一样。不过这时的情况二相较而言就好写一些，
但是仍需注意下面的code是有问题的：
```
f[l1][l2][l3][d] += f[i][j][k][d] * f[l1 - i][l2 - j][l3 - k][d]
```
因为对于

### S=()()(),

### A=()、B=()()；

### A=()()、B=()

会被多算一次。

所以我们要保证A为**最短的**形如A=(A')、[A']、{A'}的合法串。这时我们只需枚举合法的A'(注意是A’不是A)和B就可以了，其正确性也是显然的：

对于S=A1B1,S=A2B2,只需说明至多会被这两个算一次。不妨A1比A2长。

S=(__ A1'__)B1

S=(A2')(A2'')B2'，这就与A1的最小性矛盾。

# 三、细节

此题细节比较多。

1.初值：不仅对于f[0][0][0][0]=1，f[0][0][0][0~D]都要赋成1。

2.第二种情况时，要减掉B为**空串**时，因为这已经被第一种情况算过了。

3.由于code比较麻烦，所以要时刻警惕()不能套在[]、{}的外面，[]不能套在{}的外面。

4.答案：对于D=0时，直接输出f[L1][L2][L3][D]；其余情况输出f[L1][L2][L3][D]-f[L1][L2][L3][D-1]。

5.要对11380取模。

# 四、code
```
# include <bits/stdc++.h>
# define MOD 11380
using namespace std;

int L1, L2, L3, D;
int f[15][15][15][35];

int main()
{
    scanf("%d%d%d%d", &L1, &L2, &L3, &D);
    for (int i = 0; i <= D; i++) f[0][0][0][i] = 1;
    for (int l1 = 0; l1 <= L1; l1++)
        for (int l2 = 0; l2 <= L2; l2++)
            for (int l3 = 0; l3 <= L3; l3++)
                for (int d = 1; d <= D; d++) {
                    if (l1) f[l1][l2][l3][d] = (f[l1][l2][l3][d] + f[l1 - 1][l2][l3][d - 1]) % MOD;
                    if (!l1 && l2) f[l1][l2][l3][d] = (f[l1][l2][l3][d] + f[l1][l2 - 1][l3][d - 1]) % MOD;
                    if (!l1 && !l2 && l3) f[l1][l2][l3][d] = (f[l1][l2][l3][d] + f[l1][l2][l3 - 1][d - 1]) % MOD;
                    for (int i = 1; i <= l1; i++)
                        for (int j = 0; j <= l2; j++)
                            for (int k = 0; k <= l3; k++) {
                                int tmp = f[l1 - i][l2 - j][l3 - k][d];
                                if (i == l1 && j == l2 && k == l3) tmp = (tmp - 1 + MOD) % MOD;
                                f[l1][l2][l3][d] = (f[l1][l2][l3][d] + f[i - 1][j][k][d - 1] * tmp) % MOD;
                            }
                    for (int j = 1; j <= l2; j++)
                        for (int k = 0; k <= l3; k++) {
                            int tmp = f[l1][l2 - j][l3 - k][d];
                            if (l1 == 0 && j == l2 && k == l3) tmp = (tmp - 1 + MOD) % MOD;
                            f[l1][l2][l3][d] = (f[l1][l2][l3][d] + f[0][j - 1][k][d - 1] * tmp) % MOD;
                        }
                    for (int k = 1; k <= l3; k++) {
                        int tmp = f[l1][l2][l3 - k][d];
                        if (l1 == 0 && l2 == 0 && k == l3) tmp = (tmp - 1 + MOD) % MOD;
                        f[l1][l2][l3][d] = (f[l1][l2][l3][d] + f[0][0][k - 1][d - 1] * tmp) % MOD;
                    }
                }
    if (!D) printf("%d\n", f[L1][L2][L3][D]);
    else printf("%d\n", (f[L1][L2][L3][D] - f[L1][L2][L3][D - 1] + MOD) % MOD);
    return 0;
}
```
