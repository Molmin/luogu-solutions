# 感谢@我叫啥名字 的结论，根据这个结论，我推出了证明过程。

## 题意简析

给出一个数列 $A_1 , A_2 ... A_n$ .

求在这个数列的全排列中，有多少个排列满足对于任意 $i$ , $P_i$ 的前面任意一项大于 $P_i$ 或前面任意一项小于 $P_i$

## ~~哔哔~~ 证明过程

### 废话有点多，但是很严谨

大佬给出的结论是对于 $n$ , $ans=2^{n-1}$ .

首先证明： $P$ 数组除去第 $1$ 项可以拆分成两个数字顺序与原数组相同的数列 $X , Y$ 满足 $X_i = X_{i-1}-1 , Y_i = Y_{i-1}+1$ . 且 $X_1 = P_1 - 1 ,Y_1 = P_1 + 1 ,$

人话：当定下 $P_1$ 时，后面的数要不就是一直比前面的数减一，要不就是一直比前面的数加一。这两种情况可以共存，即 $P=[5,6,4,7,3,8,2,9,1] $ 是合法的.

现在为了防止歧义，定义“前面”：若 $P_i$ 位于 $X$ 或 $Y$数组，则"前面一个数字"意味着 $P_i$ 在 $X$ 或 $Y$ 数组中的位置 $Side$ 的前一个索引对应的数字。

若 $Side=1$，则前面一个数字是 $P_1$

给出这个命题的等效命题:对于任意 $x,y$ 在数列中的位置 $1,r (1<r)$ ，满足区间 $[1,r]$中一定有整数 $z$ 满足 $x<z<y$ .

这下就很容易证明了。一旦区间 $[1,r]$ 中没有 $z$  , 那么 $z$ 的位置是大于 $r$ .这是不合法的：一旦大于 $r$ ，那么就会出现与题意不符的情况：题目要求的两项仅选一项满足的都满足了。

据结论简化题意：我们设比前面一项减一（位于 $X$ 数组） 的数字是 $1$ ，比前面一项加一 (位于 $Y$ 数组) 的数字是 $0$ ，既然它们互不干扰，当初始项 $P_1$ 是 $M$ 时，可得出是要我们求 $M-1$ 个 $1$ 和 $N-M$ 个 $0$ 的排列数量。（“前面一项”已给出定义） 

这个用数学语言表述是： $L_m = C{n-1 \choose m-1}$ 从 $n$ 里选$m-1$ 项.

因为 $P$ 后面的 $n-1$ 项不是 $1$ 就是 $0$ ，而两个数组长度相加再加上 $1$ 就是 $n$

值为 $1$ 的数有 $m-1$ 项时，就是从 $n-1$ 里找出 $m-1$ 个位置放进一个 $1$

接下来，考虑到 $m (0<=m<=n-1)$ 有 $n-1$ 种情况，故结论为 $\sum_{i=0}^{n-1} (L_i)$

接下来本来是不知道怎么证的，甚至一度怀疑我证错了，后来随手查了查万能的度娘，得到如下公式，直接用了：

因为对于任意 $n$ $(n>=0)$ ，定义 $(L_x=C{n \choose x})$ 时：

$\sum_{i=0}^{n} (L_i) = 2^n$ 

所以原式 $=2^{n-1}$

完结撒花！！！

特别鸣谢：我并不认识的提供思路的网友“疯7”，和文头的楼上大佬。

## AC代码

和楼上一样，快速幂求 $2^{n-1}$ 即可。

```cpp
#include <bits/stdc++.h>
using namespace std;

long long n;

long long power2(long long t){
	long long ans=1;
	long long bs=2;
	for(long long i=t;i!=0;i>>=1){
		if(i&1){
			ans=(ans*bs)%998244353;
		}
		bs=(bs*bs)%998244353;
	}
	return ans%998244353;
}

int main(){
	cin >> n;
	cout << power2(n-1);
	return 0;
} 
```


