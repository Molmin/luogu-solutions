# P7243 最大公约数 C++题解
## 题意简述

- 给定一个 $n\times m$ 的矩阵 $a$。
- 每一个点 $a_{i,j}$ 有一个值。
- 有若干次操作，每一次操作中每一个点变为自身以及所有周围点（存在的）的最大公约数。
- 求经过多少次操作后，目标点 $a_{x,y}$ 将变为 $1$。
- 若目标点无法变为 $1$ ，则输出 $-1$。
## 题意分析
看到这一题，这就是一个~~简单的~~模拟题吧。
### 错误解法
首先我想到的是这一个解法，纯粹的模拟。每次更新一遍矩阵，直到点 $a_{x,y}$ 为 $1$ 时输出即可。当一次下来矩阵没有变化时，那么就意味着无解，此时输出 $-1$ 即可。

显然，这段代码会T掉。因为这个解法中，时间复杂度很高（我自己也算不出来到底多高）。

### 正确解法
那么，这段代码就需要优化。

定义目标点变为另一点与其的最大公约数，此时称该点”影响“了目标点。

我们可以推导出如下结论：

在最坏情况下，必须是所有点的最大公约数才能得到 $1$，此时所有的点都需要”影响“到目标点。

我们可以确定，要么当若干个点”影响“到目标点后，目标点会变为 $1$；要么全部”影响“到目标点后也无法变为 $1$。

而一点如果要”影响“到目标点，必然需要经过 两点间的曼哈顿距离 次操作，而曼哈顿距离最大也就是 $n+m$。

最后，任意一点最多只需要一次”影响“目标点，没必要重复”影响“。

因此，综合上述结论，得出如下解法：
1. 若 $a_{x,y}=1$ ，输出 $0$ 即可。
1. 设立一个数组`d`，记录第 $i$ 次操作目标点的值，数组`d` 初始化为目标点的值。
3. 开始遍历数组，取 $a_{i,j}$ 到 $a_{x,y}$ 的曼哈顿距离`dis`，`dis`即$|x-i|+|y-j|$。让`d[dis]`赋值为`d[dis]`与`a[i][j]`的最大公约数，即模拟每一个点如何”影响“目标点。
3. 最后补一下，从前往后，让`d[i]`赋值为`d[i]`与`d[i-1]`的最大公约数，即同步一遍”影响“，如果`d[i]`为 $1$ 就输出`i`并退出。
5. 若直到现在也没有结束，那么输出 $-1$ 。

最终得到时间复杂度为 $O(nm\times \texttt{GCD的时间复杂度}+n+m)$。
## AC代码
```
#include<bits/stdc++.h>
#define LL long long
using namespace std;
const int MAXN=2e3+10;
LL a[MAXN][MAXN],d[MAXN<<1];	//两个数组要开long long类型，数组d要开为 n+m 的最大值
LL GCD(LL a,LL b)
{
    LL c=0;
    while((c=a%b))
    {
        a=b;
        b=c;
    }
    return b;
}
int main()
{
    int n,m,x,y;
    cin>>n>>m;
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)
            cin>>a[i][j];
    cin>>x>>y;
    if(a[x][y]==1)
    {
        cout<<0;
        return 0;
    }
    for(int i=0;i<=n+m;i++)
        d[i]=a[x][y];
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)
            if(i!=x||j!=y)	//注意需要排除自身
            {
                int dis=abs(x-i)+abs(y-j);
                d[dis]=GCD(a[i][j],d[dis]);
            }
    for(int i=1;i<=n+m;i++)
    {
        d[i]=GCD(d[i-1],d[i]);
        if(d[i]==1)
        {
            cout<<i;
            return 0;	//提前结束程序
        }
    }
    cout<<-1;
    return 0;
}
```
当然这不是最优解，如果用BFS的话可以进一步压缩时间。不过这么写我个人认为是比较简练的，没有什么高深的优化。欢迎大家来Hack本题解。
# The End