我来分享另外一种贪心思路， 虽然这种思路要比题解区其他 dalao 的方法要复杂一些。

当然，一个显然的思路就是转化为如何让 Trie 树中的节点最多。

$k = 1$ 时，显然答案为 $n$ ，此时只能插入一个长度为 $n$ 的字符串。

如果 $k \ge 2$， 则字符串 $A$ 和 $B$ 是一定要选取的，我们可以证明如果存在最优解不包含 $A$ 和 $B$，那么就一定存在最优解包含 $A$ 和 $B$。大体思路是可以将一个既不是 $A$ 又不是 $B$ 的字符串改成选择 $A$ 或者 $B$ ，节点数不会变少，这里由于版面原因不再细述。

接着我们考虑插入字符串时要怎样走才合法。首先，它一定走过 $A$ 和 $B$ 的最长公共前缀，然后在 $B$ 走 `b` 边时往 `a` 走， $A$ 走 `a` 边时往 `b` 走，之后就可以随便走了。其中有一次在 $A$ 和 $B$ 分叉时出现。

最后考虑随便走的范围，由题意这是一棵完全二叉树，我们第一次走这里时就会新增和树高一样大的节点数，但是再来走这棵树时由于之前走过了一些节点所以就无法再新建那么多节点了。可以归纳证明，我们从一棵树高为 $H$ 的完全二叉树中抽取出一条链，那么会剩下树高为 $1, 2, \dots , H-1$ 的完全二叉树。我们下一次走的时候，就可以贪心走最高的完全二叉树。

下面是代码。我们在选择了 $A$ 和 $B$ 之后，贪心地选取最高的二叉树来统计答案。这其中涉及到区间加的操作，而这里可以懒惰增加——计算出之前操作对该值的影响，从而降低时间复杂度。

```cpp
#include <cstdio>

const int MAXN = 1000010; 
char s1[MAXN], s2[MAXN];

int tong[MAXN]; //用于维护当前各种树高的完全二叉树的数量

int n, k;
int main() {
	scanf("%d%d", &n, &k);
	scanf("%s%s", s1 + 1, s2 + 1);
	int dif;
	for(dif = 1; s1[dif] == s2[dif] && dif <= n; ++dif);
	if(s1[dif] > s2[dif]) {
		puts("0");
		return 0;
	}
	if(k == 1 || dif > n) {
		printf("%d", n);
		return 0;
	}
	for(int i = dif + 1; i <= n; ++i) {
		if(s1[i] == 'a')
			tong[n - i + 1] += 1;
		if(s2[i] == 'b')
			tong[n - i + 1] += 1;
	}
	long long int ans = n + n - dif + 1;
	k -= 2;
	long long int aris1 = 0; // 用于维护影响大小
	for(int i = n; i; --i) {
		tong[i] += aris1;
		if(k > tong[i])
			ans += 1ll * tong[i] * i,
			k -= tong[i],
			aris1 += tong[i];
		else{
			ans += 1ll * k * i;
			break;
		}
	}
	printf("%lld", ans);
	return 0;
}
```