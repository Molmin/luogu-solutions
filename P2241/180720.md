## 总体思路：枚举、暴力再加上一点点数学知识

首先做法是很透彻的：**枚举每一个格子，看以它为左上角的矩形共有多少个（正方形与长方形同属于矩形）**

那么我们怎么计算以一个格子为左上角的矩形个数呢？其实很好算：我们观察得到只要确定一个左上角和一个右下角就能确定一个矩形。所以对于任一个格子，我们只需要计数以其为左上角的矩形的右下角个数即可：

假设我们枚举道第i行，第j列格：那么当前盘面如下：
```
x x x x x x
x x x x x x
x x o . . .
x x . . . .
x x . . . .
```
当前枚举到o（i，j）格（左上角为（0,0））

现在我们只需要数标‘.’的格子即可（根据上面的思路，数右下角）而标x的格子则无关，此时所有.的总数为（n-i）*（m-j）

**如要构成正方形** ，可能的右下角（用*标出，还有o本身）如下：
```
x x x x x x
x x x x x x
x x o . . .
x x . * . .
x x . . * .
```
我们发现，所有的*与o的个数加起来恰好等于n-i！
我们再看一个例子：
```
x x x x x x
x x x x x x
x x x x o .
x x x x . *
x x x x . .
```
这时个数却是m-j。
再举几个例子之后，我们会发现：对于任一个格，以其为左上角的正方形的个数为
min（n-i，m-j）

**计算出正方形个数之后，长方形的个数就等于矩形的个数减去正方形的个数了。**
所以，长方形个数为：（n-i）*（m-j）-min（n-i，m-j）。

然后我们就分析完了，上代码：
```cpp
#include <bits/stdc++.h>//头文件
using namespace std;//命名空间
int main()
{
	int n,m;//长和宽
	cin>>n>>m;//input
	long long z=0,c=0;//z记录正方形的个数，c记录长方形的个数
	for(int i=0;i<n;i++)
	{
		for(int j=0;j<m;j++)//二重循环遍历每个格子
		{
			int tem=min(n-i,m-j);
			z+=tem;
			c+=(n-i)*(m-j)-tem;//按照以上所述计算
		}
	}
	cout<<z<<" "<<c<<endl;//output
	return 0;
}
```
**注意其中记录矩形个数的两个变量不开long long会溢出**