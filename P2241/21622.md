简单题

这跟p1548一样，只不过数据大了点而已

分析：

首先对于n*m方格的棋盘中的任意的正方形而言，只要确定了左上角的位置和边长后，该正方形就完全确定了，如果两个正方形的左上角位置不同或左上角位置相同但边长不同，则这两个正方形显然不相同，因此只要穷举出最下面和最右边之外的所有格点（两条边的交叉点），算出以它们作为正方形的左上角位置时边长不同的正方形个数，然后累加起来即得到全部的正方形个数。同样地，以某一个格点为长方形的左上角位置的长方形（包括正方形）个数也可以类似地算出来，然后累加起来即得到全部的长方形个数，再去掉前面算出的正方形个数即为程序中要求的长方形个数了。

为了求出以某一个格点为正方形的左上角位置时的正方形个数，我们对所有的边进行编号，将从上到下的m+1条横向边定为第0行道第m行，将从左到右的n+1条纵向边定位第0列到第n列，这样以第i行与第j列的交叉点为正方形的左上角位置的正方形边长最大只能为m-i与n-j中的最小值，因此以第i行与第j列的交叉点为正方形的左上角位置的正方形个数为min(m-i,n-j),类似地以第i行与第j列的交叉点为正方形的左上角位置的长方形个数（包括正方形）(m-i)*(n-j)个，因为长方形的高可以取1到m-i中的任一值，长方形的宽可以取1到n-j中的任一值。

源程序：
```
var i,j:longint;
    n,m,s:int64;    //存放正方形和长方形的个数；(注意要用int64，不然只对4个点)
begin
  readln(n,m);
  s:=0;
  for i:=0 to n-1 do
     for j:=0 to m-1 do
        if n-i<m-j then
          s:=s+n-i
        else
            s:=s+m-j;                          //算正方形个数；
  write(s,' ');       //输出；
  s:=-s;         //记住，重新赋值；
  for i:=0 to n-1 do
     for j:=0 to m-1 do
        s:=s+(n-i)*(m-j);      //公式：s:=s+(n-i)*(n-j）；
  write(s);
end.
```