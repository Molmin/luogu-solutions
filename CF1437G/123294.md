Upd on 2022.4.8：重写题解，补充了线性对数的做法。

Upd on 2022.9.3：修改一处笔误。

> *XIV. [CF1437G Death DBMS](https://www.luogu.com.cn/problem/CF1437G)
>
> [AC 自动机](https://www.cnblogs.com/alex-wei/p/Common_String_Theory_Theory_automaton_related.html)。

刻画子串结构最方便的工具就是后缀字符串结构。考虑对 $s_i$ 建出 ACAM。

我们知道，若 $i$ 是 $j$ 的祖先，则 $i$ 对应的字符串 $t_i$ 是 $t_j$ 的 border。并且，若将字符串 $q$ 放在 $s_i$ 的 ACAM 上面跑，那么跑到的每个位置就依次是 $q$ 的对应前缀的最长的与某个单词的前缀匹配的后缀。

因此，判断 $s_i$ 是否是 $q$ 的子串，只需要判断将 $q$ 按字符加入自动机后依次得到的状态 $Q_j(1\leq j\leq |q|)$ 经过了 $s_i$ 在 fail 树上的子树。或者说，为了求出答案，我们只需查询每个 $Q_j$ 在 fail 树上到根的路径上所有表示某个单词 $s_i$ 的节点的对应单词的权值的最大值。树剖 + 线段树维护。

注意，由于字符串可能相等，所以一个节点可能表示了多个单词。对于这种情况，用 multiset 维护该节点表示单词的权值最大值即可。

如果不想写树剖，也可以直接转子树添加权值 + 单点查询，这部分用 dfs 序拍平转化成区间加入 / 删除一个数，单点查询被加入的所有数的最大值。线段树 + multiset 维护即可（注意，子树操作弱于区间操作，因为前者可归约到后者，但后者不可归约至前者）。[代码](https://codeforces.com/contest/1437/submission/152990355)。

上面两种方法都是线性对数平方的。接下来介绍线性对数的魔法。

在线是没啥前途的，考虑离线把问题搞简单一点。离线有一个好处，那就是我们知道了每个节点对应权值被修改的时刻。从而得到对于每个节点 $i$，存在若干时刻的连续段 $[l_j, r_j, v_j]$ 使得在 $l_j\sim r_j$ 时刻，$i$ **对应的单词** 的权值为 $v_j$。如果一个节点没有表示单词，它对答案显然不会有任何贡献。这样一来，一次询问 $q$ 就转化为所有 $Q_j$ 到根的路径上所有单词节点 $i$ 的 $v_k$ 的最大值，其中查询时刻 $t\in [l_k, r_k]$。

子树限制和区间限制的不同点在于，前者拍平转化为后者时，区间满足非常好的性质：对于任意两个区间，**只有包含或相离** 的关系，不会相交。尽管经过离线后，所有矩形加数在所有单点查询之前，但仍然难以做到单 $\log$（甚至不可能）。

这里有一个非常精彩且适用范围非常广的技巧，那就是 **通过 dfs 解除子树限制**。具体来说，我们按照 dfs 的顺序考虑每个单词节点 $i$ 的连续段 $[l_j, r_j, v_j]$ 的贡献，在进入一个节点时，将贡献加上，离开时撤销。这样一来子树限制就没了，只剩下时间限制 $[l_j, r_j]$。这是容易考虑的，用线段树维护时间轴上的区间 checkmax 和单点查询。撤销是容易的，记录进入该节点时所有 $[l_j, r_j, v_j]$ 对线段树的修改即可。

换种角度考虑，对于一般的矩形加数单点查询最值，我们通过对一维扫描线转化为区间加 / 删数以及单点查最值。删数是很不好处理的，我们不得不使用 multiset。但若扫描线的那一维 $D_1$（dfs 序维度）的区间只有包含或相离的关系，那么在 $D_1$ 的某个区间 $[L, R]$ 的右端点（$[L, R]$ 是 dfn 区间）处删除另一维 $D_2$（时间维度）上一段区间的数时，所有在 $D_1$ 上包含于 $[L, R]$ 的区间的影响已经没有了，相当于我们此时面对着刚好加入当前要被删除的一段区间的数的局面，这意味着我们只需要撤销操作而非删除。可以想象成括号序列进栈（加入贡献）出栈（撤销影响）。

总结一下，树上问题可以通过离线 dfs 去掉形如 “包含在某个节点的子树内” 的限制，并将其转化为在端点处撤销，而撤销是 trivial 的。但是序列问题通过扫描线去掉 “包含在某个区间内” 的限制后，只能在端点处删除，对于 **不可减的信息** 而言复杂度更劣（但对于可减信息并没有太大差别）。换言之，对于子树限制，拍平到序列上后限制区间两两不交，这是非常棒的性质。个人认为这种技巧有很大的应用空间，读者需认真体会。

时间复杂度 $\mathcal{O}(n|\Sigma| + q\log n)$，[代码](https://codeforces.com/contest/1437/submission/152996143)。