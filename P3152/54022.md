把spirit dalao（！）和本蒟蒻的想法大致描述一下


本蒟蒻想法同楼下一致，

给楼下补个最优性证明：

定义 mid = (1 + n) / 2

如果我们选择一个数a（a < mid）

那么序列就分为 1 - a 和 a - mid两段

相减后最优为 1 - a和 1 - n - mid

但因为 a < mid

而取 mid 相减后为1 - mid 和 1 - mid

因此最大的数（n）减小的幅度没有取 (1 + n) / 2时大

而当 a > (1 + n) / 2 时

证明是类似的


spirit dalao（！）想法：

把1 - n看作二进制数

如 n = 5:

0001 0010 0011 0100 0101

每一次某些数减去当前（二进制下）最高位的权值

如相减后变为：

0001 0010 0011 0000 0001

再相减

0001 0000 0001 0000 0001

再相减

0000 0000 0000 0000 0000

这个想法还是很妙的。

orz dalao

这个显然是log2的操作次数。


下面


```cpp
#include <cstdio>
using namespace std;
int n, ans;
int main() {
    scanf("%d", &n);
    printf("%d", log2n + 1);
    return 0;
}
```