首先看到这道题，就想到了状压 dp，再看到 $n$ 的范围是 $8≤n≤16$，那就可以直接用状压了。   
**题意**：有 $n$ 个点的一张无向图，求所有连起来子图的乘积，注意是权值的乘积和。   
**思路**：我们用 $f[i]$ 来表示当它为 $i$ 时的数量(方案数),$dp[i]$ 来表示连起来的子图数量，再定义一个数来记录点集 $i$ 的所有子图的方案数，然后这个时间的复杂度为 $O(n^3)$。   
数组要注意开的范围，考虑实际上我们固定 $n$ 点的意义，就是使得其余的所有点的状态只有两种，这样我们枚举子集转移就会做到不多不少，考虑它所在的连通图的节点个数进行计数。   

参考代码：  
```cpp
#include <bits/stdc++.h>
using namespace std;
long long f[1<<18],dp[1<<18],c[18][18];
int main(){
	long long n,cnt=0;
	cin>>n;
	cnt=(1<<n)-1;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			cin>>c[i][j];
		}
	}
	for(int k=0;k<=cnt;k++){
		f[k]=1;
		for(int i=1;i<=n;i++){
			if(k&(1<<i-1)){
				for(int j=i+1;j<=n;j++){
					if(k&(1<<j-1)){
						f[k]=f[k]*(c[i][j]+1)%1000000007;记得%
					}
				
				}
			}
		}
	}
	for(int k=1;k<=cnt;k++){
		dp[k]=f[k];
		int arr=k^(k&-k);
		for(int i=arr;i;i=(i-1)&arr){
			dp[k]=(dp[k]-f[i]*dp[k^i]%1000000007+1000000007)%1000000007;//记得%
		}	
	}
	cout<<dp[cnt];
}
```
