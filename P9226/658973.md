[传送门](https://www.luogu.com.cn/problem/P9226)

题目的意思是你要把 $n+x$ 个物品分成若干组，每组**刚好要有** $k$ 个物品，其中 $x$ 大于 $0$，求 $x$ 最小可以是多少。

我们先来看看样例吧。

样例 $1$ 中它告诉我们 $n=10$，$k=3$，让我们求 $x$。我们可以借助画图来理解，就像这样：
```
1   2    3    4
000 000  000  0
```
一个 `0` 表示一个物品，$1$ 至 $4$ 表示每组的编号。我们要让每组都刚好有 $k$ 个物品，前三组都满足条件，只有第 $4$ 组只有一个物品。我们要把第 $4$ 组凑成有 $k$ 个物品，也就是有 $3$ 个物品，我们就得再往第 $4$ 组放入两个物品，所以 $x$ 为 $2$。

其实我们不难发现，前三组的物品数总和能被 $k$ 整除，也就是说第四组的物品数就等于 $n\bmod k$。我们要从 $n\bmod k$ 变为 $k$，就要用 $k$ 减掉 $n\bmod k$ 算出需要加入多少个物品，也就是 $x$。

再看样例 $2$：
```
1    2    3    4    5
0000 0000 0000 0000 0000
```
我们可以发现按照样例给出的数据前四组都刚好能有 $k$ 个物品，那么答案应该等于 $0$ 才对啊，所以刚才的结论不成立。其实不对，因为还有一个要求 $x$ 大于 $0$ 没被注意到。那么也就是说前 $4$ 组虽然都正好是 $k$ 个物品，但我们还得再自加一组，为第 $5$ 组，第 $5$ 组刚开始为 $0$ 个物品，所以我们得放入 $k$ 个物品才能使其的物品数刚好等于 $k$，也就是 $x=4$。这也证明了结论的正确性。

# CODE:
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,k;
int main()
{
    scanf("%d%d",&n,&k);
    printf("%d",k-n%k);
    return 0;
}
```