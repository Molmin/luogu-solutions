
## 题目大意

------------


甲，乙两个人玩Nim取石子游戏。
 nim游戏的规则是这样的：地上有n堆石子，每人每次可从任意一堆石子里取出任意多枚石子扔掉，可以取完，不能不取。每次只能从一堆里取。最后没石子可取的人就输了。假如甲是先手，且告诉你这n堆石子的数量，他想知道是否存在先手必胜的策略。
 
# 分析过程
------------
### 1.了解定义（什么是博弈论）
	我们要知道博弈问题通常有的两种状态：必胜态和必败态。
	所谓必胜态，就是在当前的局面下，先手必胜
	必败态，就是在当前的局面下，先手必败。
	那么，这个游戏的必败态我们显然知道，就是所有石子堆都为00时。

### 2简单分析

例如，(3,3,1)(3,3,1)表示一共三堆石子，第一二堆有三个，第三堆有一个。

显然(3,3,1)(3,3,1)和(1,3,3)(1,3,3)是同一种局面，即交换每堆顺序不影响答案。

如果初始局面只有一堆石子，则甲有必胜策略。
	甲可以一次把这一堆石子全部取完，这样乙就无石子可取了。

如果初始局面有两堆石子，而且这两堆石子的数目相等，则乙有必胜策略。
	因为有两堆石子，所以甲无法一次取完；
	如果甲在一堆中取若干石子，乙便在另一堆中取同样数目的石子；
	根据对称性，在甲取了石子之后，乙总有石子可取；
	石子总数一直在减少，最后必定是甲无石子可取。

对于初始局面(1)，甲有必胜策略，而初始局面(3, 3)，乙有必胜策略。

局面的加法:(a_1, a_2, …, a_n) + (b_1, b_2, …, b_m) = (a_1, a_2, …, a_n, b_1, b_2, …, b_m)(a 1 ​	,a 2 ​	,…,a n ​	)+(b 1 ​	,b 2 ​	,…,b m ​	)=(a 1 ​	,a 2 ​	,…,a n,b 1,b 2,…,b m ) 所以(3) + (3) + (1) = (3, 3) + (1) = (3, 3, 1)(3)+(3)+(1)=(3,3)+(1)=(3,3,1)。
所以(3) + (3) + (1) = (3, 3) + (1) = (3, 3, 1)(3)+(3)+(1)=(3,3)+(1)=(3,3,1)。

对于局面A, B, SA,B,S，若S=A+BS=A+B，则称局面SS可以分解为“子局面”AA和BB。
局面(3, 3, 1)(3,3,1)可以分解为(3, 3)(3,3)和(1)(1)。

如果初始局面可以分成两个相同的“子局面”，则乙有必胜策略。
	设初始局面S=A+AS=A+A，想象有两个桌子，每个桌子上放一个AA局面；
	若甲在一个桌子中取石子，则乙在另一个桌子中对称的取石子；
	根据对称性，在甲取了石子之后，乙总有石子可取；
	石子总数一直在减少，最后必定是甲无石子可取。

对于局面S，若先行者有必胜策略，则称“S胜”。
对于局面S，若后行者有必胜策略，则称“S负”。
若A=(1)A=(1)，B=(3, 3)B=(3,3)，C=(2, 2, 5, 5, 5, 5, 7, 7)C=(2,2,5,5,5,5,7,7)，则AA胜，BB负，CC负。
我们要做的，就是如何判断局面的胜负。

	如果局面SS胜，则必存在取子的方法S→TS→T，且TT负。
	如果局面SS负，则对于任意取子方法S→TS→T，有TT胜。

设初始局面SS可以分解成两个子局面AA和BB（分解理论）。

若A和B一胜一负，则S胜。
	不妨设AA胜BB负；
	想象有两个桌子AA和BB，桌子上分别放着AA局面和BB局面；
	因为AA胜，所以甲可以保证取桌子AA上的最后一个石子；
	与此同时，甲还可以保证在桌子BB中走第一步的是乙；
	因为BB负，所以甲还可以保证取桌子BB中的最后一个石子；
	综上，甲可以保证两个桌子上的最后一个石子都由自己取得。

若A负B负，则S负。
	无论甲先从AA中取，还是先从BB中取，都会变成一胜一负的局面；
	因此，乙面临的局面总是“胜”局面，故甲面临的SS是“负”局面。

即：若BB负，则SS的胜负情况与AA的胜负情况相同。

若A胜B胜，则有时S胜，有时S负。
	如果S=A+C+CS=A+C+C，则S的胜负情况与A相同。
	令B=C+CB=C+C，则S=A+BS=A+B且BB负，故SS的胜负情况与AA相同。
	
初始局面(3, 3, 1) = (3) + (3) + (1)(3,3,1)=(3)+(3)+(1)，与局面(1)(1)的胜负情况相同。
初始局面(3, 3, 1)(3,3,1)是“胜”局面，甲有必胜策略。

如果局面SS中，存在两堆石子，它们的数目相等，
那么这堆石子可以被拿掉，且新局面与原来局面的胜负相同。

这叫做局面的简化，当一个局面不能被简化后，这个局面就被称做最简局面。

最简局面中不会有两堆相同的石子，故可以用一个集合来表示最简局面

如果只关心局面的胜负，则一个局面可以用一个集合来描述，而这正是我们需要的。
如：局面(3, 3, 1)(3,3,1)，可以用集合\{1\}{1}来描述。

三、类比与联想
设大写字母ABAB表示局面，小写字母abab表示二进制

若AA和BB相同，则A+BA+B负 →→ 若aa和bb相等，则a+b=0a+b=0
若AA胜BB负，则A+BA+B胜 →→ 若a=1a=1且b=0b=0，则a+b=1a+b=1
若BB胜AA负，则A+BA+B胜 →→ 若b=1b=1且a=0a=0，则a+b=1a+b=1
若AA负BB负，则A+BA+B负 →→ 若a=0a=0且b=0b=0，则a+b=0a+b=0

## 有没有发现什么?（重点QAQ）

若aa和bb相等，则aa^b=0b=0
若a=1a=1且b=0b=0，则aa^b=1b=1
若b=1b=1且a=0a=0，则aa^b=1b=1
若a=0a=0且b=0b=0，则aa^b=0b=0

局面的加法与异或运算的性质完全相同。

能否用一个二进制数，来表示一个局面呢？

用符号#SS，表示局面SS所对应的二进制数。
如果局面SS只有一堆石子，则用这一堆石子数目所对应的二进制数来表示#SS。
#(5)=5=101(5)=5=101。

若局面S=A+BS=A+B，则#S=S=#A+A+#BB。
局面(3, 3)=(3)+(3)(3,3)=(3)+(3)，所以#(3, 3)=(3,3)=#(3)+(3)+#(3)=11+11=0(3)=11+11=0。
局面(3, 3, 1)=(3, 3)+(1)(3,3,1)=(3,3)+(1)，所以#(3, 3, 1)=(3,3,1)=#(3, 3)+(3,3)+#(1)=0+1=1(1)=0+1=1。

注：如果这里不理解，把‘+’换成‘^’再试一下
--------------------- 
## 标程

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,ans=0,shu=0;//定义全局变量，更加保险，向 ~~ QYY ~~ 巨佬学习 
int main()
{
    cin>>n; //读入局数； 
	for(int _o=1;_o<=n;_o++)//外部循环尽量就拒绝使用i，j等通用变量 ； 
	{
	     ans=0; //每一次ans按时清零QAQ ； 
             cin>>m;// 读入石子堆数 ； 
             for(int i=1;i<=m;++i)
		{
                 cin>>shu; //读入石子数量 ； 
                 ans^=shu; 
                 }
        if(!ans) printf("No\n");//如果最终结果符合 (!ans)，则先手必输 
        else printf("Yes\n");//反之...... 
    }
} 
```


------------
## 文字来源：部分摘自{_Desolate ()}的文章
原文：https://blog.csdn.net/weixin_44023181/article/details/85619512 ！