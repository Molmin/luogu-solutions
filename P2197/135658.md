## 博弈
### 思路
- 在解决这个问题之前，我们先来看一些预备知识。

- 如果你有认真听艾吉奥讲课的话，就会知道$mex$函数，她返回集合中第一个没有出现的非负整数，例如$mex\{1,2,3\}=0,mex\{0,1,4\}=2$.

- 如果你对博弈稍有了解的话，就会知道一个重要的概念$-SG$，我们来看看她的定义：**除** **任意一步所能转移到的子局面的$SG$值**以外的**最小非负整数**，即$SG[cur]=mex\{SG[nex_1],SG[nex_2]...SG[nex_k]\}$ 。等等，居然是递归定义的，她究竟是做什么用的？一般境况下，$SG[cur]=0$表示在$cur$这种局面下当前操作者必败，$SG[cur]$为其他值（$1,2,3...$）表示当前操作者必胜。

- 举一个简单的栗子：有$a$个石子聚成一堆，$Alice$和$Bob$轮流取，女士优先，足够聪明，首先不能取者输。你会说这不是SB题吗？只要$a$不为$0$，$Alice$必胜，直接全部取完。别着急，你刚刚已经说出了一个重要结论，$SG[0]=0$，剩下$0$个石子时当前执行者必输，再来看看$a$不为$0$时，可以拿$1,2,3...a$个，也就是说可以转移到剩下$a-1,a-2,a-3...0$个石子的状态，于是有$\begin{cases}SG[1]=mex\{SG[0]\}=1\\SG[2]=mex\{SG[0],SG[1]\}=2\\...\\SG[a]=mex\{SG[0],SG[1]...SG[a-1]\}=a \end{cases}$，的确符合$SG\not=0$时$Alice$胜。

- 加个条件，一次最多拿$3$个石子，这是很显然的，你拿$1$个，我就拿$3$个；你拿$2$个，我就拿$2$个；你拿$3$个，我就拿$1$个$...$，只要$a$不是$4$的倍数我就稳赢。这么做的依据是什么呢？剩$a$个石子的状态可以转移到剩$a-1,a-2,a-3$个石子的状态。于是有：$\begin{cases}SG[1]=mex\{SG[0]\}=1\\SG[2]=mex\{SG[0],SG[1]\}=2\\SG[3]=mex\{SG[0],SG[1],SG[2]\}=3\\SG[4]=mex\{SG[1],SG[2],SG[3]\}=0\\...\\SG[a]=mex\{SG[a-1],SG[a-2],SG[a-3]\}\qquad(if\ 4|a\quad then\quad SG[a]=0)\end{cases}$，这很合理。

- 进过很久很久的研究，数学家们得出一个完美的结论：**对于由若干个独立个体组成的系统，$SG$也是适用的，系统的$SG$值为其各个独立个体的$SG$值的异或值，即$SG[A]=SG[a_1]\wedge SG[a_2]\wedge...\wedge SG[a_k]$。** 那么$nim$游戏的解决方法也很显然了，判断$SG[a_1]\wedge SG[a_2]\wedge...\wedge SG[a_n]$是否为$0$即可，又∵$SG[i]=i$，∴判断$a_1\wedge a_2\wedge ...\wedge a_n$是否为$0$即可。

### 代码
```cpp
#include <cstdio>
int kase, n, ans;
int main() {
    scanf("%d", &kase);
    while(kase--) {
        ans = 0;
        scanf("%d", &n);
        for(int i = 1, x; i <= n; i++) 
            scanf("%d", &x), ans ^= x;
        ans ? puts("Yes") : puts("No");
    }
    return 0;
}
```