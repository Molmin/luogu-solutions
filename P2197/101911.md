# 阅读初感
（最近做到了几道博弈论的题，但貌似都没学过这个玄学的东西，所以找到模板题来学习一下博弈论）
	首先，我们必须要知道，什么是博弈论？就是你在和一个高手玩游戏，他们不会犯错，都会按照最优做法做。你可以选择先手或后手，看看是否有必胜策略。以本题为例，你只能先手取石子，一次可以取任意一堆中的若干个，但不能不取，你的对手很聪明，一直按照最优做法取石子。告诉你这几堆石子各有几个石子，看看先手的你是否有必胜策略。
	看到这种题目，只要有点智商都知道这个题会有一些玄学又巧妙的方法可以过，但方法是什么呢？已经不知不觉A了一道博弈论的题的我自信的开始推方法，想了很多种方法，但总是鲜红的WA，于是，就找到了题解……



# 算法实现
	首先，对于一个很大的数据，我们可以从小数据入手，一步步的推导大数据。这就有点DP的意思了，但这没有DP那么变态，仅仅只包含了递推的思想而已。
	对于输入的数组a，我们可以把它拆成两个更小的数组b和c，那么数组a就可以表示为a=b+c。我们设胜为1，负为0，那么a的胜负肯定就被b，c的胜负所影响，那么怎么影响呢？这里可以分类讨论一下

	1.当b=0，c=0时：因为在b中后手取胜，那么b中后手肯定取掉b的最后一些石子，换句话说，在c中就是先手方先取。那么在c中的先手方（也就是b中的先手方）必输，所以在这种情况中先手方必输。
	2.当b=1，c=0时：在b中先手方必胜，那么后手方在c中先取。但是c中的先手方必输，所以这种情况中先手方必胜。
	3.当b=0，c=1时：这种情况其实和上面的情况一样，换了一个顺序而已，也是先手方必胜。
	4.当b=1，c=1时：这种情况比较复杂，有胜有败。	当b==c的时候，先手方必输，这与为什么，自己试试吧。	当b!=c时，先手方反而可能取胜
	
那么总结下来拆分的时候总共有4种结果，用算式表示出来是这样的：
1.	b=c=1——>b+c=0
2.	b=0,c=0——>b+c=0
3.	b=0,c=1——>b+c=1
4.	b=1,c=0——>b+c=1

怎么样，看着熟悉吗这不是和”^”的运算一样吗？那么上面的的算式都可以表示为：
1.	b=c=1——>b^c=0
2.	b=0,c=0——>b^c=0
3.	b=0,c=1——>b^c=1
4.	b=1,c=0——>b^c=1

那么到这里，nim游戏的大致做法也差不多成型了。不过之前说过，要找到大数据的解要从小数据的解入手。那么不断的分解大数据，最后剩下的是什么呢？没错，那就是数组中的每一个数字，那么从左往右循环一次即可。那么区间就从原来的a[1]到a[1~2]到a[1~3]一直到a[1~n],那么输出a[n]所代表的意思即可。


# 代码实现
```c
#include<bits/stdc++.h>
using namespace std;
int n,m;
int a[10039];
int main()
{
	scanf("%d",&m);
	while(m--)
	{
		scanf("%d",&n);
		for(int i=1;i<=n;++i)
		scanf("%d",&a[i]);
		for(int i=2;i<=n;++i)
		a[i]=a[i-1]^a[i];
		if(a[n]==0)
		printf("No\n");
		else
		printf("Yes\n");	
	}
	return 0;
}

```
