## 题意

给定一个只含小写字母 $\mathtt{a}, \mathtt{b}$ 的字符串 $s$，每次你可以执行以下两种操作：

1. 选取 $s$ 中连续的两个字符 $\mathtt{aa}$，把它们删去，替换成一个字符 $\mathtt{b}$。

2. 选取 $s$ 中连续的两个字符 $\mathtt{bb}$，把它们删去，替换成一个字符 $\mathtt{a}$。

请你求出执行若干次操作后，能够得到的本质不同的字符串有多少个，答案对 ${10}^9 + 7$ 取模。

## 分析

这可能是比较简单的做法（确信）

一看就是一道 $dp$ 题，但这道题里面有些小 $\text{trick}$。

首先不难发现转化完后每个字符都是原字符串一个区间里面的运算结果。那么，怎么处理一个区间会变成什么字符呢？这里有个小 $\text{trick}$：我们把 $a$ 赋值为 $1$，$b$ 赋值为 $2$，则有无论怎么操作，字符的值之和模 $3$ 都是固定的（两个操作都符合这个性质，所以这个值就是字符串的**不变量**）。利用这个小技巧，我们就可以迅速地求出会变成哪一个字符了。不过，这里要注意：权值和模 $3$ 可以是 $0$，那么这就说明可能不能变成长度为 $1$ 的字符串了，在后面的 $\text{dp}$ 可以不加以考虑。

接下来的 $dp$ 中，如果这个字符是**可达成的**，那么就要先把 $f_i$ 赋为 $1$。接下来我们只需要加上除了自己外的其它 $f$ 值之和，即 $f_{lst_0} + f_{lst_1} + f_{lst_2} - f_{lst_{s_i}}$，其中 $lst_i$ 表示上一个为 $i$ 的字符的位置。

最后的答案就是我们求出来的 $f_n$ 了。不过，如果相邻字符都不相同，要特判输出 $1$

## 代码

```cpp
#include <stdio.h>
#include <string.h>
const int N = 100010;
const int mod = 1e9 + 7;
int n, ans;
int f[N], lst[N], s[N], a[N];
char str[N];
int main() {
	scanf("%s", str + 1);
	n = strlen(str + 1);
	bool none_same = 1;
	for (int i = 2; i <= n; ++ i)
		if (str[i] == str[i - 1]) {
			none_same = 0;
			break;
		}
	if (none_same) { // 特判全不相同的情况，没得操作
		puts("1");
		return 0;
	}
	for (int i = 1; i <= n; ++ i) {
		a[i] = str[i] - 'a' + 1;
		s[i] = (s[i - 1] + a[i]) % 3; // 模 3 之和
	}
	for (int i = 1; i <= n; ++ i) {
		if (s[i] >= 1) ++ f[i]; // 可达成的
		f[i] = (f[i] + f[lst[0]] + f[lst[1]] + f[lst[2]] - f[lst[s[i]]]) % mod; // 除了自己外的所有东西
		lst[s[i]] = i; // 记录 lst[s[i]]
	}
	printf("%d\n", f[n]);
}
```