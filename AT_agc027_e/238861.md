[传送门](https://atcoder.jp/contests/agc027/tasks/agc027_e)

## 分析

### 0x01

首先，对于有多种操作或限制的题目，我们应该第一个考虑能不能把操作或限制统一，这题可以把 $\texttt{a}$ 看作 $1$，把 $\texttt{b}$ 看作 $2$，操作就是把相邻的两个数变为它们的和模 $3$，并且中途不能出现 $0$。

以下用 $sum(s)$ 表示把 $\texttt{a}$ 看作 $1$，把 $\texttt{b}$ 看作 $2$，s 中所有字符所代表的值的总和模 $3$。

这里就有了两个结论：

1. 一个串 $s$ 可以变成字符 $\texttt{a}$ 当且仅当 $s$ 中有相邻相同的字符，且 $sum(s)=1$。

   Proof：归纳一下，既然有相邻相同，肯定能操作一次，即能变成长度减小 1 的串，而且因为 $sum(s)$ 是保证的，可以发现操作后不会变成没有相邻相同的串，且最后变成的字符肯定是 $\texttt{a}$。

2. 一个串 $s$ 可以变成字符 $\texttt{b}$ 当且仅当 $s$ 中有相邻相同的字符，且 $sum(s)=2$。

   Proof：同理。

（注：以上均没有考虑 $s$ 长度为 $1$ 的情况。）

### 0x02

接下来处理本质不同这个限制。发现一个结果串，设为 $t$，它本质上是将 $s$ 划分成了 $\mid t\mid$ 个子段，每个子段变成 $t$ 中的一个字符。

为了处理本质不同，我们要构造一种方法，把 $t$ 映射到唯一的分段方式，这里我们考虑贪心分段即找到 $s$ 中最短的一个可以变成 $t_1$ 的前缀，然后删掉，以此类推。最终这种方法会把 $s$ 分成前面 $\mid t\mid$ 段，以及后面一段没匹配的。

现在又有了一个问题，后面多出来了一段，怎么保证加上这一段后前面还能组出 $t$ 呢？

这时又有一个结论：加上后面一段后还是合法的当且仅当 $s$ 中有相邻相同的字符，且后面那一段的 $sum()=0$。

后面的 $sum()=0$ 这个显然，但是前面那个是为什么？

分类讨论，如果后面那段或者匹配的最后一段有相邻相同的字符，显然让它直接和匹配的最后一段拼在一起就好了，这时因为前面的结论，拼上去之后肯定还能变出想要的字符。

如果没有相邻相同的字符，假设最后一段为 $\texttt{abab}\ldots\texttt{ab}$（$\texttt{baba}\ldots\texttt{ba}$ 也是同理）。

发现匹配的最后一段只可能一个字母 $\texttt{a}$ 或 $\texttt{b}$，因为它没有相邻相同的，根据上面的结论，它的长度只可能是 $1$ 了。

如果最后一个匹配段是 $\texttt{a}$，接上去之后就有相邻相同的了，如果是 $\texttt{b}$，那么这个串的后缀应该就是 $\texttt{babab}\ldots\texttt{ab}$，我们不妨把匹配的最后一段变成最后那个 $\texttt{b}$，这样剩下来的空段就是 $\texttt{baba}\ldots\texttt{ba}$，又是一个类似的结构，我们可以拿它和倒数第二个匹配段再进行同样的过程，不行就第三个一直做下去。

这样就可以发现一直做下去都和前面的段拼不到一起的唯一情况就是 $s$ 中根本就没有相邻相同的字符。

### 0x03

代码实现的化就很简单了，一开始先特判一下 $s$ 中是否没有相邻相同的字符，如果是直接输出 $1$。否则 $f_i$ 代表把 $s$ 中前 $i$ 个分段的方案数，随便乱搞即可。

### 0x04

毕竟是 oier，大胆猜测，不用证明，oier 应该一想到结论感觉一下它对不对，不用太仔细地去证，所以我这里给出的证明不会特别严谨，而更偏向证明思路。感觉在考场的时候对待一个结论也是这样，想到证明思路就行了。

[Code](https://atcoder.jp/contests/agc027/submissions/29579111)

