## 题面定位

[题面](https://atcoder.jp/contests/agc027/tasks/agc027_e)，大致题意如下：

> 给定一个 $\text{a,b}$ 构成的字符串，每次可以选择两个连续的 $\text{a}$ 换成 $\text{b}$，或两个连续的 $\text{b}$ 换成 $\text{a}$，问可以构造出多少不同的字符串。
>
> $1\leqslant\left|s\right|\leqslant 10^5$。

定位：**贪心+DP**，主要在贪心及其推论的证明和 DP。

## 分析

显然，形如 $\text{abababab...}$ 的字符串是无法进行任何操作的，此时答案为 $1$。

进一步，显然，只要存在一对连续的 $\text{a}$ 或 $\text{b}$，都可以进行操作。因此一个无法操作的序列一定是 $\text{a,b}$ 交替的。且任何可操作的序列一定可以通过若干次操作转化为一个不可操作的序列（$\left|s\right|=1$ 视为不可操作序列）。

因此对于可操作序列 $s$，考虑其能否转化为一个不可操作序列 $t$。

因为 $t$ 不可操作，$s$ 可操作，因此不妨认为 $s$ 的若干个不重叠的子串，分别进行操作后，对应到了 $t$ 的一个字符。

**随意提取 $s$ 的一个子串（长度大于 $1$），这个子串可以被缩成一个字符，只需要满足其可操作即可。为什么？**

----

+ 对于不可操作且长度大于 $1$ 的字符串，其一定不能被缩成一个字符。
+ 对于一个可以操作的字符串，进行一次操作后，长度会缩减 $1$。此时若其仍然可以操作，则继续操作。
+ 若一个可操作的字符串进行一次操作后不可操作，则本处操作后缩成的字符和其两边的字符都不相同，即 $\text{aaaa}$ 形式，操作中间的两个 $\text{a}$，但是这样就说明被操作的字符和其两旁的字符都相同，为什么不先操作左右两边的 $\text{aa}$ 呢？

因此对于一个长度大于 $1$ 的可操作序列 $s$，其一定能通过至少一种方法，经过若干次操作后缩减为一个字符。

----

**如何快速确定一个子串会被缩成什么字符？**

发现这样一个性质：如果把 $\text{a}$ 看成 $1$，$\text{b}$ 看成 $2$（即给这两个字符赋予权值），且每次操作相当于把两个连续且相同的数加起来模 $3$。

那么我们求出字符串转换后的序列的权值和（在模 $3$ 意义下） $sum$，无论对这个字符串进行多少操作，$sum$ 不变。

所以维护前缀和就可以得出一个子串会被缩成什么字符。

进一步，结合前面的内容，得到：对于一个可操作序列 $s$，其一定可以被缩成一个字符：若其权值和为 $1$，则一定可以被缩为 $\text{a}$；若其和为 $2$，则一定可以被缩为 $\text{b}$。

**如果权值和为 $0$？**

说明这一段子串 $\text{a}$ 和 $\text{b}$ 数量相等，此时要么说明这个子串不可操作，要么就可以划分成两段权值和不为 $0$ 的子串。

**怎么把 $s$ 变成 $t$（怎么判断 $t$ 能被变出来）？**

根据前文所述，我们已经默认了 $s$ 是可操作序列，$t$ 也可以通过操作变成不可操作序列，但是这里还是假设 $t$ 是任意字符串，不然后面转移就会多下亿点功夫。

记 $s_{l...r}$ 表示 $s$ 的一个子串 $[l,r]$ 的权值和模 $3$，$t_{l...r}$ 同理，设 $s$ 长为 $n$，$t$ 长为 $m$。

根据权值和在模 $3$ 意义下无论怎么操作都不变，$s_{1...n}=t_{1...m}$。不满足的一定不可以。

现在从左往右依次给 $s$ 分段，使得 $s$ 的第 $i$ 段对应 $t$ 的对应字符 $t_i$。

要让这个做法能够推广到计数问题，最好还是让变换的方法确定成唯一的。

不妨做个假设：每次分段都分得尽量小。

假设我们拿到的 $s=\text{abaabbaba},t=\text{aab}$：

+ $s_1=1=t_1$，分段：$s=\text{a|baabbaba}$。
+ $s_{2...4}=1=t_2$，分段：$s=\text{a|baa|bbaba}$。
+ $s_{5}=2=t_3$，分段：$s=\text{a|baa|b|baba}$。

我们发现 $t$ 已经用完了，但 $s$ 还有剩余，这是否能代表 $s$ 不能转化为 $t$ 呢？

考虑 $s$ 的最后剩下的是什么：$\text{baba}$，它的权值和为 $0$，而且是标准的不可操作序列。

但是考虑 $s_5=2,s_{6...9}=0$，那么 $s_{5...9}=2+0=2$，也就是说，把这两段合并成一段，其权值和不变，根据前面得到的结论，这一段区间一定也可以缩成 $b$。

因此就有了一个模糊的想法：先把 $s$ 按照最短原则分段，如果最后有剩余，则剩余部分的权值和一定为 $0$。

我们证明了符合这个条件的 $t$ 一定能被 $s$ 缩出来，如何证明不符合条件的情况？

---

用上述方式分段后，$s$ 被划分为 $m+1$ 段，且最后一段的权值不为 $0$。

+ 因为 $s$ 的每一段要和 $t$ 一个字符匹配，因此 $s$ 被分成的段数一定为 $n$。
+ 因为前面按照最短原则分段，因此把 $m+1$ 段缩减为 $m$ 段，只能合并两个相邻的段，不能拆分一个段，否则这一段无法再与 $t$ 的字符匹配。
+ 因为前 $m$ 段已经和 $t$ 匹配了，因此前 $m$ 段中，每段的权值和都是 $1,2,1,2\cdots$ 交替出现的。合并任意连续的两段，都会导致合并的那一段权值和不等于原来的权值和，即 $t_i=s_{old}\neq s_{new}$。
+ 因此只能合并最后剩下的一段和倒数第二段，倒数第二段就是第 $m$ 段，它的值也不能改变。但是最后一段全值不为 $0$，因此一定会导致合并后第 $m$ 段权值和改变。

因此，按照最短原则分段，如果有剩余段，这一段全值不为 $0$，一定不符合条件。

----

符合条件一定能得到，不符合条件一定得不到，所以我们只需要统计符合这个条件的情况即可。

**前置都铺垫好了，那就开始DP吧**。

设 $f_i$ 表示考虑到 $s_{1...i}$，能够分段后匹配多少个 $t$，用刷表法做。

$t$ 的对应段可能是 $1$ 也可能是 $2$，因此根据最短原则，我们应该预处理每一个位置 $i$ 的下一个最近的位置 $j$，满足 $s_{i...j}=1$，同理还需要找到下一个最近的位置 $k$，满足 $s_{i...k}=2$。

这样转移的时候就可以快速找到根据最短原则，以 $i$ 为上一个段的末尾，下一个段对应的区间是什么。假设以 $i$ 为一段开头，段的末尾（根据段权值和为 $1,2$）分别记为 $R_{i,1},R_{i,2}$，有：
$$
f_i\rightarrow
\begin{cases}
f_{R_{i+1,1}} \\
f_{R_{i+1,2}}
\end{cases}
$$
初始状态 $f_0=1$。

**注意此时的 $f_n$ 为分段后恰好和 $t$ 匹配的 $t$ 的数量**，还需要补充上分段后多出来一段，但是这一段的权值和为 $0$ 的情况。

在转移的时候判断一下，如果 $s_{i+1...n}=0$，则最终答案还应该加上 $f_i$ 的值，即到这里为止的 $t$ 的数量，这些 $t$ 也是满足条件的。别忘了 $s_{1...n}=0$ 特判。

## 代码

核心处理如下：

```cpp
if(a[n]==1){
    R[n][1]=n,
    R[n][2]=R[n][0]=n+1;
}
else{
    R[n][2]=n,
    R[n][1]=R[n][0]=n+1;
}
for(register int i=n-1;i>=1;--i){
    if(a[i]==1){
        R[i][0]=R[i+1][2],
        R[i][1]=i,
        R[i][2]=R[i+1][1];
    }
    else{
        R[i][0]=R[i+1][1],
        R[i][1]=R[i+1][2],
        R[i][2]=i;
    }
}
f[0]=1;
for(register int i=0;i<n;++i){
    f[R[i+1][1]]+=f[i],f[R[i+1][1]]%=mod,
    f[R[i+1][2]]+=f[i],f[R[i+1][2]]%=mod;
    if((s[n]-s[i])%3==0 && i)
        ans+=f[i],ans%=mod;
}
```

如果对完整代码有需要可以来我的[评测记录](https://atcoder.jp/contests/agc027/submissions/28294822)查看。



