~~不喜欢长代码的先不要跑！~~

~~我的码绝对好理解！！~~

前面有人用map过了这道题，但是思路和我不太一样（我也没看懂）而且用了一些过时的东西，所以我来写一篇好理解的，完整的。

## 首先来翻译一下题面

>1.密文可以翻译只有在字母‘A’~‘Z’全部有唯一对应的时候。

>2.如果出现一个某个字母有两个密文对应，或者一个密文对应两个字母则输出错误。

是的，就这么简单。

## 接着来思考解决方案

那么我第一反应就是建立映射，让每个密文对应其原文，并记录每个字母出现情况。

也就是说，我们要这样去想：

>1.如果字母A~Z**存在**一个字母没对应，则无法解密，输出“Failed”。

>2.如果子母中出现了一个密文对应两个**不同**字母，则输出“Failed”。当然，如果一个密文出现了两次，但是对应了相同的字母，那是没问题的。

>3.如果一个原文字母被**两个或多个**密文对应，则无法解密，输出“Failed”。

>4.其余情况可以解密，直接输出密文逐个字母对应即可。

## map映射的基本操作

	什么是map？

你可以简单的理解为，它是一个下标可以是任何类型（整形，浮点数，字符串，甚至结构体里的东西），存储的内容可以是任意类型的数组，非常自由。
	
    定义方法

```cpp

	map<下标类型，存储类型>变量名;

```

	调用方法

和数组一致，直接变量名\[下标\]即可。

	注意事项：

类似于vector，这东西你用多少就开多少内存，所以最好**不要滥用STL**。

## 最后上代码解释细节

~~代码都在注释里~~

注释都在代码里

```cpp
#include<bits/stdc++.h>//NOIP、CSP已经允许使用万能头 
using namespace std;

map<char,char>mm;//mm用来存储密码与原文对应数值，以密文为下标，原文为存储值。 
map<char,bool>yes;//yes用来记录密文的A-Z是否都出现过 
map<char,bool>yes2;//yes2用来记录原文中的A-Z是否都出现过 
int main(){
	string sm,sy,sd;//sm是密文，sy是原文，sd是待翻译的 
	cin>>sm>>sy>>sd;//输入 
	int len1=sm.length(),len3=sd.length();//STL中的string可以使用 字符串名.length()来获取一个整形的长度 
		for(int i=0;i<len1;i++){//遍历密文 
			if(yes[sm[i]]&&mm[sm[i]]!=sy[i])//判断密文中的每个字母是否都出现过，如果出现过并且和上一次出现的不同，则无法解密 
			{
				cout<<"Failed";//依照题目要求输出 
				return 0;//直接结束程序 
			}
			mm[sm[i]]=sy[i];//如果没出现过或者前后一致，再存一遍也无妨。没出现过直接映射一次，以密文为下标，原文为存储值。 
			yes[sm[i]]=1;//记录密文出现过 
			yes2[sy[i]]=1;//记录原文出现过 
		}
		
	for(char i='A';i<='Z';i++)//扫一遍两个记录器，看是否有漏网之鱼（没出现过的字母） 
	{
		if(yes[i]&&yes2[i]);//如果A-Z每个字母原文和密码都出现了，那就继续 
		else {
				cout<<"Failed";//存在没出现的，依照题目要求输出 
				return 0;//直接结束程序 	
		}
	}
	for(int i=0;i<len3;i++)//都出现了，可以解密，那么对待解密密文遍历 
		cout<<mm[sd[i]];//输出密文对应的原文字母即可 
	return 0;//最后结束程序 
}
```
我的程序A掉了这道题。但是有一点不足，是数据水造成的，不过并无大碍，思路和程序是正确的。有发现的dalao可以评论区留言。