来一波短一点的C++代码


由题目可得

>1． 所有信息扫描完毕，‘A’-‘Z’ 所有 26 个字母在原信息中均出现过并获得了相应的“密字”。

>2． 所有信息扫描完毕，但发现存在某个（或某些）字母在原信息中没有出现。

>3． 扫描中发现掌握的信息里有明显的自相矛盾或错误（违反 S 国密码的编码规则）。例如某条信息“XYZ”被翻译为“ABA”就违反了“不同字母对应不同密字”的规则。

所以我们可以得出：

1.**A-Z必须有相应的密字** 不然就输出Failed；

2.如果**同一个字母的密字重复**了，就输出Failed；

3.**同一个密字不可给多个字母使用**；


所以就很好写了，我们可以把代码分成**3大块**

- **输入**

这个就不用我说了吧，大家都会

- **求解密字**

我们可以知道前面两个相对应的加密信息和原信息长度是一样的，我们可以在其中判断：

如果这个字母还没有密字，并且相对应的原信息的那个字母还没被当做密字使用过 就存进去，并且往判断已经有几个字母有密字的变量里加一

如果这个字母有了密字但是目前的原信息对应字母不同于密字 直接输出Failed

如果这个字母没有密字，但对应的原信息字母已经用过 直接输出Failed

如以上两种情况同时出现，也是直接输出Failed

待得全部原信息和加密信息中的密字相对应完，长度不足26就输出Failed 如果足够就继续

- **输出**

最后只需要按照第二部分求出的密字对应输出就行了


代码在这↓↓


```cpp
#include<iostream>
#include<cstdio>
#include<string>
#include<cstring>
#include<algorithm>
using namespace std;
string x,y,z;
int c[27],s=0;
bool f[27],t[27];
int main()
{
    memset(c,0,sizeof(c));
    memset(f,false,sizeof(f));
    memset(t,false,sizeof(t));
    cin>>x>>y>>z;
    for(int i=0;i<x.size();++i)
    {
        if(!f[x[i]-'A'+1]&&!t[y[i]-'A'+1])//判断密字是否用过和原信息中的字母有无相应密字
        {
            c[x[i]-'A'+1]=y[i];//存入相应密字的ASCLL码
            f[x[i]-'A'+1]=t[y[i]-'A'+1]=true;//密字和原信息字母使用过了
            ++s;    //往判断有多少字母有密字中的函数加一
        }    
        else if(c[x[i]-'A'+1]!=y[i])//如果密字不同于原来有的密字
        {
            cout<<"Failed";
            return 0;    
        }
    }
    if(s!=26)//密字不够26个字母
    {
        cout<<"Failed";
            return 0;    
    }
    for(int i=0;i<z.size();++i)//输出
    {
        printf("%c",c[z[i]-'A'+1]);    
    }
}    

```