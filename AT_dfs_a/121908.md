### 看到之前的大佬们都没人写BFS的题解，我就来水一发吧

BFS(**广度优先搜索**，又称**宽度优先搜索**)是最简便的图的搜索算法之一，~~不会的大佬们可以去百度一下~~

BFS大部分情况下要用到**队列**~~（不会的大佬们也可以去问度娘）~~。

本题BFS核心思想：从初始节点开始，将初始节点入队，然后搜索每一个队中元素一步可以到达的另一个节点（不重复），这样每次搜索成为一次**扩展操作**，再将搜索到的这些节点加入队。这样循环操作，直到每一个节点都被访问过，即**队头指针和队尾指针相等**为止。

关于队列的实现：队头指针指向待扩展的节点，队尾指针指向新搜索到的节点，当所有节点都被扩展完毕，即队头指针和队尾指针相等时，退出循环，如果此时目标节点仍未被访问，说明**初始节点和目标节点不联通**，即**无法到达终点**。

值得一提的是：BFS在第一次搜索到目标节点时即可输出答案，无需继续进行后面的循环

参考代码：

```cpp
#include<iostream>
using namespace std;
const int dx[4]={1,0,-1,0},dy[4]={0,-1,0,1};    //方向数组，和DFS一样
int a[250001],b[250001],x,y,sx,sy,ex,ey,n,m,map[501][501];
char s[501][501];
bool check=false;    //是否已经搜索到终点的判断
int main()
{
    int i,j;
    cin>>n>>m;
    for(i=1;i<=n;i++)
    for(j=1;j<=m;j++)
    cin>>s[i][j];    //输入
    for(i=1;i<=n;i++)
    for(j=1;j<=m;j++)
    {
    	if(s[i][j]=='.') map[i][j]=0;
    	if(s[i][j]=='#') map[i][j]=1;
    	if(s[i][j]=='s'){sx=i; sy=j; map[i][j]=0;}
    	if(s[i][j]=='g'){ex=i; ey=j; map[i][j]=0;}
    }    //map[i][j]为1代表不可行，0代表可行，sx和sy是起点坐标，ex和ey是终点坐标
    int head=0,tail=1;
    map[sx][sy]=-1;
    a[tail]=sx;
    b[tail]=sy;    //初始化，a数组储存x坐标，b数组储存y坐标
    while(head!=tail)    //借助队列实现BFS，算法的主体
    {
        head++;    //队头指针指向待扩展节点
        for(i=0;i<4;i++)    //可向四个方向移动
        {
            x=a[head]+dx[i];
            y=b[head]+dy[i];    //搜索与此节点相连的四个点
            if(x<=n&&x>0&&y<=m&&y>0&&!map[x][y])    //边界和障碍物以及是否访问过的判断
            {
                //如果在地图内且不是障碍格且未被访问过
                tail++;    //队尾指针加1，指向新搜索到的节点
                a[tail]=x;
                b[tail]=y;    //将此节点入队
                map[x][y]=-1;    //标记为已被访问过（障碍格为1，已访问过的格为-1）
                if(x==ex&&y==ey)  //找到了终点
                {
                    cout<<"Yes"<<endl;
                    check=1;    //后面的操作无需继续进行，退出循环
                }
            }
        }
        if(check==true) break;    //退出循环
    }
    if(check==false) cout<<"No"<<endl;    //当所有可以走到的节点都被访问之后，仍找不到目标节点，输出No
    return 0;
}
```
**在最后顺带弱弱地问问管理员：这道题现在用的翻译好像是我做的,能不能在翻译后加上我的用户名QAQ**