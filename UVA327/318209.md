~~为什么大佬用的方法都好 nb~~

### 题目大意
给出一个含有 `+`，`-`，`++`，`--`，以及 26 个小写字母（表示变量）的 **C** 语言表达式，求值，并输出每个**出现的变量**的值。每个变量的初始值为：`a = 1, b = 2, c = 3, ..., z = 26`。数据保证不会有 `+++` 或 `---` 等未定义情况出现。

### 分析

首先，此题与经典的表达式求值有以下不同点：

- 没有括号；

- 含有可以变化的变量；

- 有 C/C++ 特有的 `++`、`--` 运算。

对于第一点，对我们有一定帮助（废话，不过个人认为是为了避免歧义）。

对于第二点，可以用数组维护每个变量的值，遇到 `++` 和 `--` 时更新。

第三点是本题的一个难点。很容易想到，由于 `++` 和 `--` 的优先级最高，可以在遇到的时候直接处理，而不用像经典的表达式求值一样进栈。

举个例子，在你遍历表达式的时候，出现了一个 `'-'`。此时判断下一个字符是否也是 `'-'`，如果是，说明出现了 `--` 运算（要确定是不是在变量前面而非后面）。此时直接将其后面的变量值减一，然后将这个值放进数据栈。`++` 同理。

如果在变量后遇到了 `--`，就把变量的值放进数据栈，在将变量的值减一。`++` 同理。注意此时可以直接把遍历用的指针移到 `++` 或 `--` 后面，防止重复计算。

基本上就将此题解决了。但要注意，输入的字符串有可能空格，会阻碍判断。预处理掉空格。这里我用了双指针的方法：

用两个指针 $i$ 和 $j$，初始值均为 $0$。让 $j$ 去遍历字符串。如果当前 $j$ 指向的字符不是空格，就让 $i$ 所指向的位置变为 $j$ 指向的字符，并让 $i$ 加一。

其实很好理解。如果 $j$ 指向的字符不为空格，就要放入新的字符串。$i$ 其实就指向了新字符串的结尾。为什么可以在原字符串上操作呢？因为 $j$ 每次都要移动， $i$ 则只有遇到非空格字符时才移动，所以 $i\leq j$，即不会覆盖需要的位置。

（~~话说可以不用栈吧qwq~~）

#### Code

```cpp
//变量/函数名解释：
//s:表达式
//vis:变量是否出现
//num:数据栈
//op:符号栈
//node:变量值
//ord:运算符优先级，越大越先算
//calc():取出两个数，计算
void calc() {
	char c = op.top(); op.pop();
	int x2 = num.top(); num.pop();
	int x1 = num.top(); num.pop();
	if (c == '+') 	   num.push(x1 + x2);
	else if (c == '-') num.push(x1 - x2);
}
int solve() {
	memset(vis, 0, sizeof(vis));
	for (int i = 0; i < 26; ++i) {
		node[i + 'a'] = i + 1;//多测不清空，爆零两行泪
	}
	for (int i = 0, j = 0; j < s.length(); ++j) {
		if (s[j] != ' ') s[i++] = s[j], n = i;//去空格
	}
	while (num.size()) num.pop();
	while (op.size()) op.pop();
	for (int i = 0; i < n; ++i) {
		if (s[i] == '+' && s[i + 1] == '+') {
			num.push(++node[s[i + 2]]);
			vis[s[i + 2]] = 1;
			i += 2;
			continue;
		} else if (s[i] == '-' && s[i + 1] == '-') {
			num.push(--node[s[i + 2]]);
			vis[s[i + 2]] = 1;
			i += 2;
			continue;//判前面的++/--
		} else if (s[i] >= 'a' && s[i] <= 'z') {
			vis[s[i]] = 1;
			if (s[i + 1] == '+' && s[i + 2] == '+') {
				num.push(node[s[i]]++);
				i += 2;
				continue;
			}
			if (s[i + 1] == '-' && s[i + 2] == '-') {
				num.push(node[s[i]]--);
				i += 2;
				continue;
			}//判后面的++/--
			num.push(node[s[i]]);
		} else {
			while (op.size() && ord[op.top()] >= ord[s[i]]) 
				calc();
			op.push(s[i]);
		}
	}
	while (op.size()) 
		calc();
	return num.top();
}
```
