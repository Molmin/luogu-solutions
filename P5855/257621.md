一道很不错的模拟题……

[题目传送门](https://www.luogu.com.cn/problem/P5855) [博客食用更佳哦](https://www.luogu.com.cn/blog/5y2d1n/solution-p5855)

**言归正传……下面就开始我们本道题的题解吧！**

------------
### STEP 1 审题&&整理条件

1.给出密码；

2.给出每一位尝试的范围；

3.给出已经尝试的密码；

4.输出（还有几次密码没试||-1）


------------
### STEP 2 思路概述

- **如何储存数据**

密码用字符串储存，每一位的密码范围用结构体（自愿）分别储存长度和密码

- **如何判断无解（-1）**

当密码的任何一位不包含在尝试范围内时，无解，应该输出-1

- **如何判断答案**

设置$unsigned$ $long$ $long$变量$ans$储存，初始输入时用组合的方式算出全部可能；

然后判断尝试密码是否每一位都在范围内，如果是的话$ans$减去1即可


------------
### STEP 3 AC代码实现及完整注释
```c
#include<bits/stdc++.h>//万能头文件
using namespace std;
int n,k;//如题
unsigned long long ans=1;。//答案
string m;//真正密码
bool ma[20][10];//每一位的每一个数字是否是密码
struct node{
	int l;//长度
	string k;//每一位的范围
}kn[19];//每一位的结构体
int main(){
    scanf("%d %d",&n,&k);
    cin>>m;//输入
    for (int i=0;i<n;i++){
    	cin>>kn[i].l>>kn[i].k;
    	ans*=kn[i].l;//先组合答案
    	for (int j=0;j<kn[i].l;j++){
    		ma[i][kn[i].k[j]-'0']=1;
		}//标记
	}
	for (int i=0;i<n;i++){//挨个判断密码的每一位
		if (ma[i][m[i]-'0']==0){//只要有一位不在尝试范围内
			printf("-1\n");
			return 0;//输出-1
		}
	}
	while (k--){//判断你每一个尝试的密码
		bool f=0;//打标记的变量
		string c;//暂存尝试密码
		cin>>c;
		for (int i=0;i<n;i++){//判断每一位
			if (ma[i][c[i]-'0']==0){有一位不在尝试范围内就标记
				f=1;
				break;	
			} 
		}
		if (f==0) ans--;//没打过标记就将答案-1
	}
	cout<<ans<<endl;//输出
    return 0;//好习惯++
}
```


------------
### STEP 4 完结撒花！

本次题解就这么愉快的结束啦！如果还有没弄明白的地方，评论区随时等着你！我会第一时间回复哒！

如果全部明白了，就点个赞记录一下你的成长吧！


