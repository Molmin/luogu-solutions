- **NOIP普及组 2011 第四题**

## 题目描述

对于 1 位二进制变量定义两种运算：

![](https://cdn.luogu.com.cn/upload/pic/99.png)

运算的优先级是：

1. 先计算括号内的，再计算括号外的。

2. “ $×$ ”运算优先于“ $⊕$ ”运算，即计算表达式时，先计算× 运算，再计算 $⊕$ 运算。例如：计算表达式 $A ⊕ B × C$ 时，先计算 $B × C$，其结果再与 $A$ 做 $⊕$ 运算。

现给定一个未完成的表达式，例如 ``_+(_*_)``，请你在横线处填入数字 $0$ 或者 $1$ ，请问有多少种填法可以使得表达式的值为 $0$ 。

## 输入输出格式

- ### 输入格式

共 $2$ 行。

第 $1$ 行为一个整数 $L$，表示给定的表达式中除去横线外的运算符和括号的个数。

第 $2$ 行为一个字符串。包含 $L$ 个字符，其中只包含’``（``’、’``）``’、’``+``’、’``*``’这 $4$ 种字符，其中’``（``’、’``）``’是左右括号，’``+``’、’``*``’分别表示前面定义的运算符“ $⊕$ ”和“ $×$ ”。这行字符按顺序给出了给定表达式中除去变量外的运算符和括号。

- ### 输出格式：
共 $1$ 行。

包含一个整数，即所有的方案数。注意：这个数可能会很大，请输出方案数对``10007``取模后的结果。

## 输入输出样例

```
Input:
4
+(*)
Output:
3
```

## 样例解释

- ### 输入输出样例说明

  给定的表达式包括横线字符之后为：``_+(_*_)`` 

  在横线位置填入``(0 、0 、0) ``、``(0 、1 、0)`` 、``(0 、0 、1) ``时，表达式的值均为 $0$ ，所以共有 $3$ 种填法。 

## 数据范围

对于 $20\%$ 的数据有 $0 ≤ L ≤ 10$ 。

对于 $50\%$ 的数据有 $0 ≤ L ≤ 1,000$ 。

对于 $70\%$ 的数据有 $0 ≤ L ≤ 10,000$ 。

对于 $100\%$ 的数据有 $0 ≤ L ≤ 100,000$ 。

对于 $50\%$ 的数据输入表达式中不含括号。

## 题解

在这里我们将用**栈**来解决这个问题。

首先我们有一个符号栈 $t$ ，用来存储操作符。

接下来我们有两个数字栈 $a$ 和 $b$ ，分别表示当前运算结果为 $0$ 和为 $1$ 的方案数。

这三个栈的栈顶分别为 $topt,topa,topb$ 。

- $E.g.1$

```
*+
```

当前的栈 $t,a,b$ 都是空的，如图。

![无标题.png](https://i.loli.net/2019/01/05/5c30bfc9c141b.png)

接下来我们弹入了一个乘号，由于乘号是除括号外最高级的，所以我们要先把它前面的乘号算完（但是要注意如果一个乘号的右边是一个左括号就不能够直接算了）。但是由于它前面已经没有乘号了，所以我们先不管它。

对于每一个字符，我们要判断它的前面和后面是否能够放数字，及样例解释中为下划线的地方。

如果能放，就在 $a$ 栈和 $b$ 栈的栈顶各放入一个 $1$ 。

此时状态：

$t:\times$

$a:$

```
1
1
```

$b:$

```
1
1
```

接下来我们把一个加号放进来。由于加号优先级比乘号低，所以我们要把这个加号前面的乘号给消掉。消之前的图是长这样的。

![无标题2.png](https://i.loli.net/2019/01/05/5c30bfc9b8b30.png)

下面是消的方法。

![无标题3.png](https://i.loli.net/2019/01/05/5c30bfc9c2ff3.png)

这就是消完后的图啦。

![无标题4.png](https://i.loli.net/2019/01/05/5c30bfc9a2c2f.png)

加号的话还是差不多。

$$e=a*c$$

$$f=a*d+b*c+b*d$$

左括号的话就直接把它丢到符号栈里面就可以了。

如果是右括号的话就一直消，直到消到左括号为止。

注意右括号左边可能是乘号，也要把它算进去。

然后两个括号之间乘号基本上都被消掉了，大部分都是加号，可以放心算。

最后 $a$ 栈的栈底（顶）就是答案。

为了防止消不尽可以在式子的两边加括号qwq。

例如样例加了括号就变成这样了。

```
（+(*)）
```

如果还有不理解的可以尝试联系代码来理解qaq，最好是自己动手写。

## 代码（仅供参考）

```
#include <cstdio>
char st[1000001],t[1000001];
int a[1000001],b[1000001];
int main()
{
	int topt=0,topa=0,topb=0,n=0;
	scanf("%d",&n);
	scanf("%s",st+2);
	st[1]='(',st[n+2]=')';
	for(int i=1;i<=n+2;i++)
	{
		if((st[i]=='+' || st[i]=='*') && st[i-1]!=')' && st[i-1]!='+' && st[i-1]!='*')
		{
			a[++topa]=b[++topb]=1;
		}
		if(st[i]=='(')
		{
			t[++topt]=st[i];
		}
		if(st[i]=='*')
		{
			if(st[i+1]=='(')
			{
				t[++topt]=st[i];
				continue;
			}
			while(true)
			{
				if(t[topt]!='*')
				{
					break;
				}
				int aa=a[topa],ab=b[topb];
				int ac=a[topa-1],ad=b[topb-1];
				int e=aa*ac+aa*ad+ab*ac;
				int f=ab*ad;
				e%=10007,f%=10007;
				topa--,topb--;
				a[topa]=e,b[topb]=f;
				topt--;
			}
			t[++topt]=st[i];
		}
		if(st[i]=='+')
		{
			while(true)
			{
				if(t[topt]!='*')
				{
					break;
				}
				int aa=a[topa],ab=b[topb];
				int ac=a[topa-1],ad=b[topb-1];
				int e=aa*ac+aa*ad+ab*ac;
				int f=ab*ad;
				e%=10007,f%=10007;
				topa--,topb--;
				a[topa]=e,b[topb]=f;
				topt--;
			}
			t[++topt]=st[i];
		}
		if(st[i]==')')
		{
			while(true)
			{
				if(t[topt]=='(')
				{
					break;
				}
				if(t[topt]=='+')
				{
					int aa=a[topa],ab=b[topb];
					int ac=a[topa-1],ad=b[topb-1];
					int e=aa*ac;
					int f=aa*ad+ab*ac+ab*ad;
					e%=10007,f%=10007;
					topa--,topb--;
					a[topa]=e,b[topb]=f;
					topt--;
				}
				else if(t[topt]=='*')
				{
					int aa=a[topa],ab=b[topb];
					int ac=a[topa-1],ad=b[topb-1];
					int e=aa*ac+aa*ad+ab*ac;
					int f=ab*ad;
					e%=10007,f%=10007;
					topa--,topb--;
					a[topa]=e,b[topb]=f;
					topt--;
				}
			}
			topt--;
		}
		
		if((st[i]=='+' || st[i]=='*') && st[i+1]!='(')
		{
			a[++topa]=b[++topb]=1;
		}
	}
	printf("%d",a[1]%10007);
	return 0;
}
```