## 前置定义

为保证流畅的阅读，特列出本文中所用到的一些基本定义，下文将不再进行说明。

对于字符串 $A$ 和 $B$：

- $A+B$ 为将 $A$ 和 $B$ 首尾相接所得到的字符串，例如 $\texttt{356}+\texttt{123}=\texttt{356123}$。
- $A<B$ 表示 $A$ 的字典序严格小于 $B$，例如 $\texttt{12}<\texttt{123}<\texttt{13}$。（$>,\le,\ge$ 同理）
- $|A|$ 表示 $A$ 的长度，例如 $|\texttt{9876}|=4$。

对于序列 $Q$，将其中的元素任意打乱得到序列 $P$，则称 $P$ 为 $Q$ 的元素的排列，简称为 $Q$ 的排列。例如 $P=[9,4,6,1]$ 为 $Q=[1,4,6,9]$ 的一个排列。

除另有说明外，若大写字母表示字符串，则对应的小写字母表示其对应的十进制整数。例如：若 $A=\texttt{1234}$，则 $a=1234$。

## 题解

首先，由于要将若干个数首尾相接拼成一个数，可以**将数视为字符串**。

无论顺序如何，**最终结果的总长度是不变的**，因此可转化为如下问题：

> 给定 $n$ 个只包含数字 $0$ ~ $9$ 的字符串 $S_i$（对应输入中的 $a_i$），求 $S$ 的排列 $T$，使得 $T_1+T_2+\cdots+T_n$ **字典序最大**。

为求得最优解，一个简单的想法是，**考虑相邻两项是否需要交换**。

若 $S_{i+1}+S_i>S_i+S_{i+1}$，则显然交换后更优——只要存在这样的情况，我们就应当进行交换。

可以证明，**交换操作会在有限步内停止**，且**最终所得序列为最优序列**。（详细证明见后文）

有了上述结论以后，我们只需将字符串按照上述规则进行排序，即可得到答案。

使用 STL 的 `sort`，时间复杂度为 $O(n\log{n}\cdot\max{|S|})$，其中串长 $|S| \le 10$。

## 证明

证明包含以下两个部分。（引用部分为每一部分所证的命题）

> 交换操作会在有限步内停止。

即证明存在 $S$ 的排列 $T$，满足对于任意的 $1 \le i < j \le n$，$T_i+T_j \ge T_j+T_i$。

考虑两个字符串 $A$ 和 $B$，则 $A+B \ge B+A$ 等价于 $a \cdot 10^{|B|}+b \ge b \cdot 10^{|A|}+a$（同样是因为长度相等），移项即得 $\dfrac{a}{10^{|A|}-1} \ge \dfrac{b}{10^{|B|}-1}$。

因此，按 $\dfrac{s}{10^{|S|}-1}$ 从大到小的顺序对 $S$ 中的元素进行排列，即可得到满足条件的排列 $T$。

> 最终所得序列 $T$ 为最优序列，即 $T_1+T_2+\cdots+T_n$ 的字典序取到最大值。

先证明：对于任意满足 $\dfrac{s}{10^{|S|}-1}$ **非严格单调递减**的排列 $T$，结果 $T_1+T_2+\cdots+T_n$ 为定值。

考虑 $\dfrac{s}{10^{|S|}-1}$ 相等的一段，设为 $T_l,T_{l+1},\cdots,T_r$，则对于任意的 $l \le i < j \le r$，$T_i+T_j=T_j+T_i$。（将前一部分证明中的 $\ge$ 改为 $=$ 即证）

这意味着，交换区间 $[l,r]$ 中的任意相邻两项，结果不变。进一步得，$[l,r]$ 中元素的顺序不会影响结果。

------------

再证明：不满足 $\dfrac{s}{10^{|S|}-1}$ 非严格单调递减的排列不优。

设 $P$ 为 $S$ 的排列，且存在 $1 \le i < j \le n$，使得 $\dfrac{p_{_i}}{10^{|P_{_i}|}-1}>\dfrac{p_{_j}}{10^{|P_{_j}|}-1}$。

于是存在 $1 \le i <n$，使得 $\dfrac{p_{_i}}{10^{|P_{_i}|}-1}>\dfrac{p_{_{i+1}}}{10^{|P_{_{i+1}}|}-1}$，进而得 $P_i+P_{i+1}>P_{i+1}+P_i$。

由于交换 $P_i$ 和 $P_{i+1}$ 后会更优，所以这样的 $P$ 一定不为最优的排列。

------------

综合这两点，知 $T$ 一定为最优的排列，第二部分得证。

## 代码

``` cpp
#include<bits/stdc++.h>
using namespace std;
const int max_n=20+5;
string S[max_n];
bool cmp(const string &A,const string &B) // & 表示引用，如果不理解也可以不用 
{
	return A+B>B+A; // 注意此处不能写成 >= 
}
int main()
{
	int n;
	cin>>n;
	for(int i=1;i<=n;++i)
		cin>>S[i];
	sort(S+1,S+n+1,cmp); // 记得传入自定义的比较函数 
	for(int i=1;i<=n;++i)
		cout<<S[i];
	cout<<"\n";
	return 0;
}
```