# 思路
根据贪心的思想，如果想让拼接出来的数最大，那么高位上的数就应该尽可能的大。

但是不同数字的长度不一，为了让高位的数尽可能大，我们可以考虑排序的方法，如何让排序后的数拼接后最大是需要解决的问题。

首先，根据数字的大小从大到小排序肯定是行不通的，列举一组数据：
```
2
1111 9
```
如果根据数字大小从大到小排序的话结果是 $11119$，但正确答案应该是 $91111$。

我们可以考虑把数字转化成字符串来做。排序的时候比较 $\overline{xy}$ 和 $\overline{yx}$ 的大小（其中 $\overline{xy}$ 表示以 $x$ 在前 $y$ 在后的形式连接）。取他们中的最大值，如果 $x$ 排在前面更优，那么就把 $x$ 的位置往前排，反之则往后排，这样顺序输出的结果一定为最大值。

# 为什么这样排序
由题目可知，最后的结果一定为 $\overline{abcd \dots xyz}$ 的形式。每次取出其中的两个元素来比较，设取出的两个元素分别为 $x$ 和 $y$， $\overline{xy}$ 和 $\overline{yx}$ 中，假设 $\overline{xy}$ 大于 $\overline{yx}$，这说明 $x$ 比 $y$ 更适合排在序列的前面，$x$ 的位置应当往前挪动，$y$ 的位置应该往后挪动，之后 $x$ 和 $y$ 再以相同的方式和其他元素比较，这样的最终结果一定是最适合排到第一个位置的数排在第一个位置，最不适合排到第一个位置的数排到最后一个。

以上面的一组数据为例，这里的 $\overline{xy}=11119$，$\overline{yx}=91111$。很显然 $91111>11119$，所以拼接时将 $9$ 拼接在前面，$1111$ 拼接在后面。
# 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
string s[30];
int n;

bool cmp(string a, string b) {
	return a + b > b + a;
}

int main() {
	scanf("%d", &n);

	for (int i = 1; i <= n; i++) {

		cin >> s[i];
	}

	sort(s + 1, s + 1 + n, cmp);

	for (int i = 1; i <= n; i++) {

		cout << s[i];
	}

	return 0;
}


```
