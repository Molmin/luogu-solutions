## 一个一波三折的题解（~~惨痛的回忆~~）

------------

##### 好吧，其实我也是用四边形不等式做的，而且做法也没有优于已有的题解。但是做都做了，还是提供一下思路吧。毕竟，~~经验+3，岂不美哉?~~

------------
大佬都在刷各种神仙方法，但是我觉得DP题还是要先从本源（~~暴力~~）说起，再慢慢考虑优化。反正这是我做DP的方法，不喜勿喷。

## 1.暴力

首先，我们考虑只有一个邮局的情况，即在坐标为 $d[1...n]$ 的村庄中选一个求最小距离和。可以发现邮局在中位数处一定最优，即 $k=(i+j)/2$ ，于是有:$w[i,j]=|d[i...j]-d[k]|$ 

由此可以提前计算出所有 $w[i,j]$ ，计算时直接引用（da biao）。

再看状态转移方程。状态 $m[i,j]$ 表示前j个村庄建立i个邮局的最小距离和。根据这类DP的套路，把这个距离分成两部分：前 $k$ 个村庄建立 $i-1$ 个邮局的最小距离和 $m[i-1,k]+d[k+1..j]$ 之间建立第i个邮局的最小距离和 $w[k+1,j]$ 。所以得状态转移方程: $m[i,j]=min(m[i-1,k],w[k+1,j])$

~~40分到手，岂不美哉~~


------------
## 2.优化——四边形不等式


#### 前言

Q（某dalao）：为什么要用四边形不等式？

A:因为在枚举 $k$ 时花费了太多时间，所以急需一种方法减小其范围。

Q（不要脸地）：四边形不等式太男了，不能用WQS二分吗？

A：这个故事告诉我们，蒟蒻就好好做个蒟蒻吧。。。

Q：什么是四边形不等式？

A：。。。还是百度吧 [四边形不等式](https://baike.baidu.com/item/%E5%9B%9B%E8%BE%B9%E5%BD%A2%E4%B8%8D%E7%AD%89%E5%BC%8F/7556574#1)。附：四边形不等式的基本应用 [[NOI1995]石子合并](https://www.luogu.com.cn/problem/P1880)

这里不得不说，四边形不等式的题真是有心，让人先AK NOI,再AK IOI，多有成就感！

#### 对于本题

要使用四边形不等式优化，我们就“猜测”取最优 $k$ 值的决策函数 $s[i,j]$ 单调，即  。

首先需要证明以下两个性质（证明过程繁而不难，省去）：


#### 性质1. w [ i , j ] + w [ i ’ , j ’ ] <= w [ i ’ , j ] + w [ i , j ’ ]  ，i <= i ’ <= j <=j ’


#### 性质2. m [ i , j ] + m [ i ’ , j ’ ] <= m [ i ’ , j ] + m [ i , j ’ ] ，i <= i ’ <= j <= j ’


#### 最后，即可证明:性质3.  s [ i - 1 , j ] <= s [ i , j ] <= s [ i , j + 1 ]

证明这个性质有什么用呢？这就达到了我们的初衷——限定最优值 $k$ 的取值范围！~~不忘初心，方得始终~~


------------

以上就是基本思想，其实知道结论后代码男度很小（...），所以考场上能否自己推出来就看各位的数学功底和对这类特殊题目的敏感度了。（~~本人表示自己还真不能独立把所有性质证出来~~。）

某dalao： _**Talk is cheap, show me the code.**_

```cpp
#include<bits/stdc++.h>
#define re register int
using namespace std;
const int M=1<<30;

int n,m;
int a[3005];
int w[3005][3005];
int f[3005][305];
int s[3005][305];

int main(){
	ios::sync_with_stdio(false);
	cin>>n>>m;
	for(re i=1;i<=n;i++) cin>>a[i];
	sort(a+1,a+1+n);
	for(re i=1;i<n;i++){
		for(re j=i+1;j<=n;j++){
			w[i][j]=w[i][j-1]+a[j]-a[(i+j)/2]; //懒人打表
		}
	}
	for(re i=1;i<=n;i++){
		f[i][1]=w[1][i]; //状态转移方程的边界条件
		s[i][1]=1;
	}
	for(re i=1;i<=m;i++) s[n+1][i]=n-1;
	for(re j=2;j<=m;j++){ //保证无后效性
		for(re i=n;i>=j;i--){
			f[i][j]=M;
			for(re k=s[i][j-1];k<=s[i+1][j];k++){ //四边形不等式的成果
				if(f[k][j-1]+w[k+1][i]<f[i][j]){ 
					f[i][j]=f[k][j-1]+w[k+1][i];
					s[i][j]=k; //更新决策点
				}
			}
		}
	}
	printf("%d",f[n][m]);
	return 0;
}