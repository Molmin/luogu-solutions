此题需要用四边形不等式优化
  ~~我相信40分的代码大家应该都能打出来吧~~
  
###  如果没有推出 dp 方程，建议关掉题解思考出转移方程再研究此类优化
  
  那我们直接上优化
## 以下是我对四边形不等式优化的一些理解


### 什么是四边形不等式优化
  
此类优化主要针对二维区间 dp，转移方程大多为 
 $$dp[i][j]=\min(dp[i][k]+dp[k+1][j]+w[i][j])$$ 
方程含义： 

$dp[i][j]$ 表示从 $i$ 状态到 $j$ 状态的最小花费。题目一般是求 $dp[1][n]$，即从起始点 $1$ 到终点 $n$ 的最小花费。

$dp[i][k]+dp[k+1][j]$ 体现了递推关系。$k$ 在 $i$ 和 $j$ 之间滑动，$k$ 有一个最优值，使得 $dp[i][j]$ 最小。

$w[i][j]$ 是和题目有关的费用，如果它满足四边形不等式和单调性，那么用 DP 计算 $dp[]$ 的时候，就能进行四边形不等式优化。

这类问题的经典的例子是“石子合并”，它的转移矩阵就是上面的 $dp[i][j]$， $w[i][j]$ 是从第 $i$ 堆石子到第 $j$ 堆石子的总数量

对于此题，不难得出方程 
 $$dp[i][j]=\min(dp[k][j-1]+w(k+1,i))$$ 

只需一个简单的优化操作，就能把上面代码的复杂度变为  $O(n^2)$ ~~至于这个证明我懒不想说~~。这个操作就是把循环 $i \le k < j$ 改为 $s[i][j-1] \le k \le  s[i+1][j]$ 其中 $s[i][j]$ 记录从 $i$ 到 $j$ 的最优分割点。在计算 $dp[i][j]$ 的最小值时得到区间 $[i,j]$ 的分割点 $k$，记录在 $s[i][j]$ 中，用于下一次循环

```
for(int i=1;i<=n;i++){
	dp[i][i]=0;
	s[i][i]=1;
}
for(int len=2;len<=n;len++){
    for(int i=1;i<=n-len+1;i++){
        int j=i+len-1;
        for(int k=s[i][j-1];k<=s[i+1][j];k++){
            int t=dp[i][k]+dp[k+1][j]+w[i][j];
            if(f[i][j]>t){
                f[i][j]=t;
                s[i][j]=k;
            }
        }
    }
}
```


------------

虽说这只是一个模板~~与此题无关~~，但也有许多疑问

代码的复杂度是多少 \?

为什么能够在保证正确性的前提下把 $i \le k < j$ 缩小到 $s[i][j-1] \le k \le s[i+1][j]$ \?


------------

### 四边形不等式的证明
在四边形不等式 DP 优化中，对于 $w[]$，有2个关键内容：四边形不等式定义、单调性。

四边形不等式定义1：设 $w$ 是定义在整数集合上的二元函数，对于任意整数 $i \le i' \le j \le j'$，如果有 
 $$w(i,j)+w(i',j') \le w(i,j')+w(i',j)$$ 
则称 $w$ 满足四边形不等式。

四边形不等式可以概括为：两个交错区间的 $w$ 和，小于等于小区间与大区间的 $w$ 和。

四边形不等式定义2：对于整数 $i < i+1 \le j < j+1$，如果有 
$w(i,j)+w(i+1,j+1) \le w(i,j+1)+w(i+1,j)$
 称 $w$ 满足四边形不等式。

四边形不等式定理：如果 $w(i,j)$ 满足四边形不等式和单调性，则用 DP 计算 $dp[][]$ 的时间复杂度是 $O(n^2)$ 的。

这个定理是通过下面2个更详细的引理来证明的。

引理1：状态转移方程 $dp[i][j]=\min(dp[i][k]+dp[k+1][j]+w[i][j])$，如果 $w[i][j]$ 满足四边形不等式和单调性，那么 $dp[i][j]$ 也满足四边形不等式。

引理2：记 $s[i][j]=k$ 是 $dp[i][j]$ 取得最优值时的 $k$，如果 dp 满足四边形不等式，那么有 $s[i][j-1] \le s[i][j] \le s[i+1][j]$，即 $s[i][j-1] \le k \le s[i+1][j]$。
引理2直接用于 DP 优化，复杂度 $O(n^2)$。

这两个引理的证明论文可[戳这里](http://www.cs.ust.hk/mjg_lib/bibs/DPSu/DPSu.Files/p429-yao.pdf)

最后，贴上蒟蒻代码~~大佬勿喷~~
```
#include<bits/stdc++.h>
using namespace std;
const int N=3009;
int f[N][N],s[N][N],a[N],num[N],n,m;

inline int val(int l,int r){
	int mid=(l+r+1)>>1;
	return a[mid]*(mid-l+1)-(num[mid]-num[l-1])+num[r]-num[mid]-a[mid]*(r-mid);
}

int main(){
	memset(f,0x3f3f3f,sizeof(f));
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++){
		scanf("%d",&a[i]);
		num[i]=num[i-1]+a[i];
	}
	for(int i=1;i<=n;i++){
		f[i][1]=val(1,i);//注意初始化
	}
	for(int i=1;i<=m;i++){
		s[n][i]=1;
	}
   //开始dp
	for(int j=2;j<=m;j++){
		s[n+1][j]=n;
		for(int i=n;i>=1;i--){
			for(int k=s[i][j-1];k<=s[i+1][j];k++){
				int t=f[k][j-1]+val(k+1,i);
				if(f[i][j]>t){//四边形不等式优化
					f[i][j]=t;
					s[i][j]=k;
				}
			}
		}
	}
	printf("%d",f[n][m]);//dp非常注重f[][]的定义
	return 0;
}
```
~~其实证明看不懂应该不要紧吧，会用就好了~~