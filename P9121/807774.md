## 题目翻译

- 有一头奶牛，如果能吃干草的话，每天 **会且只会** 吃一捆甘草。
- 有 $n$ 天，对于这些 $d_i$ 天农场主会送来 $b_i$ 捆干草。
- 求 $t$ 天前一共会吃多少捆干草。仓库一开始是空的。

## 思路简述

可以发现，$t$ 的值非常的大，于是考虑通过干草的变化来求最终答案。

因为在没有变化的时候，奶牛都会吃一捆干草，当干草不够了，它也没办法，只能在那里等。于是可以得出模拟 $n$ 次更改即可。定义一个变量 $last$ 来储存现在还剩多少干草块，对于每个 $b_i$，加上即可。

接下来的重点即在于如何判断吃不吃完：

这其实也很简单，当两次送干草的时间相差大于等于 $last$ 时，干草块就会吃完，吃的块数即为剩余数。

当相差小于 $last$ 时，干草块不会吃完，这 $d_i-1$ 到 $d_i$ 天每天都会吃一捆。

记得将 $last$ 减去吃的量，加上送的量。

对于 $d_n$ 以后的天数，我们并没有管，于是需要我们特殊处理一下。

## AC 代码（橙题没必要 ctj 了吧，应该很好想的）

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;//t 那么大明摆着让你开long long
ll n,t,ans,last,d[100050],b[100050];
int main(){
	cin>>n>>t;
	for(ll i=1;i<=n;i++){
		cin>>d[i]>>b[i];//边输入边处理，简洁一点
		if(last>=d[i]-d[i-1]){//够吃
			last-=d[i]-d[i-1];
			ans+=d[i]-d[i-1]; 
		}else{//不够
			ans+=last;
			last=0;
		}
		last+=b[i];//加上，别忘
	}
	if(last>t-d[n])cout<<ans+t-d[n]+1;//对于我们没有循环到的最后这几天要进行特殊处理，请思考为什么这里要加上 1
	else cout<<ans+last;
	return 0;
}
```
