# CF1148A
哈喽大家好，我是你们的WT20071112.我又来讲题目啦！
## 0、[博客](https://www.luogu.com.cn/blog/WT20071112/)
## 1、题意分析
一个字符串只由A和B构成，现有a个$"a"$,b个$"b"$.c个$"ab"$,问用这些字符串最长可以拼接为的满足$"a"$与$"b"$交替出现的字符串的长度。

#### 不好理解？

翻译：给你a个$"1"$,b个$"0"$.c个$"10"$,尽可能多的把他们连接起来，使得没有任何两个相邻的位置的数字是相同的。（或者理解为间隔出现）
## 2、算法选择
1、先将总个数设为0，先加上所有$ab$,然后单独处理$a$与$b$，即最小值乘二，然后如果$a$与$b$个数不相等，则再加一。

这是目前留下题解的大佬们的共同想法，英雄所见略同啊！

#### 而蒟蒻我……第二种：
2、给好的$ab$，咱们把他给拆了，转换为c个$a$和c个$b$，加到$a$与$b$的个数上。反正最后都是要岔开，存在哪里无所谓。于是我们就只剩了$a$与$b$的个数了。
## 3、关键代码
首先就是将$ab$转换为$a$、$b$的过程啦！
```
long long x,y,z,a,b;
    cin>>x>>y>>z;
    a=x+z;
    b=y+z;
```
之后就要判断输出，a==b则输出全部，否则输出$min(a,b)*2+1$.
```
if(a==b)
    {
      cout<<2*a<<endl;
      return 0;
      }
    else
    {
      cout<<2*min(a,b)+1<<endl;
      return 0;
      }
```
## 4、整体实现
```
#include<bits/stdc++.h>
using namespace std;
int main()
{
    long long x,y,z,a,b;//定义。
    cin>>x>>y>>z;//输入。
    a=x+z;//关键转化1。
    b=y+z;//关键转化2。
    if(a==b)
    {
      cout<<2*a<<endl;//输出。
      return 0;
      }
    else
    {
      cout<<2*min(a,b)+1<<endl;
      return 0;
      }
    //为什么不加return 0呢？因为上面if-else的两个分支中都已分别加了return 0.上面不加这儿加也行啊。
}
```
## 5、后记
[AC记录必看](https://www.luogu.com.cn/record/36069907)

这道题目还是很适合~~像我这样的~~新手们练手的，很不错哦。祝大家早日AC。

我是WT20071112，有问题可以评论或私信哦。

再见啦~（码字不易，就不点个赞再走嘛？）