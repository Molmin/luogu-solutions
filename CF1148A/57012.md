## 很经典的贪心

我们先设 

'a' 的个数为 $S_a$

'b' 的个数为 $S_b$

'ab' 的个数为 $S_{ab}$

题目要求**不重复**的最长字符串长度

那我们很容易就可以看到 'ab' 这个子串是可以**相互组合**的

*Such as：*

>ababababababab

所以我们要将 'ab' 这种子串全部用完

*总长度* $ += S_{ab} * 2$

------------

那 'a' 和 'b' 怎么办？？？

其实有了上面的经验，我们很自然地就会想到把 'a' 和 'b'组合成 'ab' ，在接到原先数列的后方

*总长度* $ +=max( S_a ,S_b )* 2$

------------

那**最后剩下的**那些怎么办？？？

我们前面处理后选出来的字符串应该是长这样的

>ababababababab

很显然，这中间是不能再插入任何东西的了

而我们选完后剩下的应该是只有 'a' 或者只有 'b' 存在或者刚好选完

那我们就在**两端**做功夫

如果是剩下'a'，那我们就再在字符串末尾加上一个'a'

*总长度* $ += 1 $

如果是剩下'b'，那我们就再在字符串末尾加上一个'b'

*总长度* $ += 1$

如果一个都不剩，那直接输出总长度

最后我们不难发现，这样操作之后，你再也不可能再加入任何东西了

那我们的程序就到此**结束**


------------

上代码


``````cpp
#include <iostream>
#include <cstdio>
#define ll long long
using namespace std;
ll a,b,ab,ans;//开long long 不然会爆
ll combine;
int main()
{
	scanf("%lld%lld%lld",&a,&b,&ab); //输入 'a' 'b' 'ab' 的个数
	combine=min(a,b);//组合'a' 'b'
	ans=(combine+ab)<<1;//ans加上长度，记得要乘二
	if(a!=b) ans++;     //处理剩下的
	printf("%lld",ans); //完美输出
	return 0;
} 
```