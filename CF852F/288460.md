题意：

有一个长度为 $n$ 的数组全部元素都是 $a$ 。

现在进行 $m$ 次操作，每次操作将 $A[i]$ 变为 $A[i]*A[i+1]$ ，最后一个元素不变。

现给出 $n,m,a,Q$，输出 $m$ 次操作后的 $A$ 数组，每个元素对 $Q$ 取模。

$n,m\leq 10^6+123$ 。

----


这个题的操作不算复杂，而且给出的初始数组元素种都是 $a$ ，可以看出来是让我们直接计算出每一位的值

$ a^1 \ a^1 \ a^1 \ a^1 \ a^1 \ a^1 \ a^1$

$a^2 \ a^2 \ a^2 \ a^2 \ a^2 \ a^2 \ a^1$

$a^4 \ a^4 \ a^4 \ a^4 \ a^4 \ a^3 \ a^1$

$a^8 \ a^8 \ a^8 \ a^8 \ a^7 \ a^4 \ a^1$

$a^{16} \ a^{16} \ a^{16} \ a^{15} \ a^{11} \ a^5 \ a^1$

$…$

如果不是最后一个数的“干扰” $m$ 次过后应该会变成 $a^{(2^{m-1})}$，但是最后一个元素始终是 $a$ ，所以我们提取出每一位数的指数与 ${2^{m-1}}$ 的差值，为了方便找规律，我们再把序列反转，可以得到：

$0 \ 0\ 0\ 0\ 0\ 0 \ 0…$


$1 \ 0\ 0\ 0\ 0\ 0 \ 0…$


$3 \ 1\ 0\ 0\ 0\ 0 \ 0…$


$7 \ 4\ 1\ 0\ 0\ 0 \ 0…$


$15 \ 11\ 5\ 1\ 0\ 0 \ 0 …$



$31  \ 26\ 16\ 6\ 1\  0 \ 0 …$


$61 \ 57\ 42\ 22\ 7\ 1\ 0 …$

$…$

可以看出来是类似杨辉三角形式的，一个数是上面相邻两数之和，每行第一个数是 $2^{i-1}-1$ ，每行最后一个不是零的数是 $1$ 。

由于 $n,m$ 是 $10^6$ 级别的，所以不能爆算每一位的值，需要找到捷径。

再对这个数列取一个差分（就是后面的一位减去前面的一位），得到如下的东西。

$0 \ 0\ 0\ 0\ 0\ 0 \ 0…$


$1 \ 0\ 0\ 0\ 0\ 0 \ 0…$


$2 \ 1\ 0\ 0\ 0\ 0 \ 0…$


$3 \ 3\ 1\ 0\ 0\ 0 \ 0…$


$4 \ 6\ 4\ 1\ 0\ 0 \ 0 …$



$5  \ 10\ 10\ 5\ 1\  0 \ 0 …$


$6 \ 15\ 20\ 15\ 6\ 1\ 0 …$

$…$

这就十分的眼熟了，第 $i$ 行 第 $j$ 列竟是 $\tbinom{i-1}{j}$。

但还有个问题：这里我们求的是指数上的数，这个问题的数规模会很大，要用为指数取模，这里不必用到[欧拉定理](https://www.luogu.com.cn/problem/P5091)，只要枚举出 $a^i \mod Q=1$ 的 $i$ 即可，由题意得，这个 $i$ 也是 $10^6$ 级别的，然后指数都对这个 $i$ 取模即可。

---

核心代码：

```cpp
int main(){
	scanf("%d%d%d%d",&n,&m,&A,&Q);
	int i;
	for (i=A%Q,mod=1; i!=1; mod++) 
		i=(ll)i*A%Q;fac[0]=1;
	for (i=1; i<mod; i++) 
		fac[i]=(ll)fac[i-1]*i%mod;f[0]=1;
	for (i=1; i<=m; i++)
    	f[i]=(f[i-1]+(ll)fac[m]*inv(fac[i])%mod*inv(fac[m-i]))%mod;
	for (i=m+1;i<=n; i++) 
		f[i]=f[i-1];
	for (i=n; i; i--)
		printf("%d%c",ksm(A,f[i-1],Q),(i>1)?' ':'\n');
}
```

