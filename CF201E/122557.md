**PS：该题解非本人所写（本人仅略加整理），不过原作者没有署名,所以我不知道原作者是谁qwq**

>原文链接: https://pan.baidu.com/s/1DFRbm3z2k0a-ZrTM7tyrlQ 
>
>提取码: 4fq9

题目大意:给定一个1~n的排列，每次可以同时查询<=m个位置的值但返回的是值的集合(无序)，求最坏情况下最少进行多少次询问可以确定排列。$n,m\le10^9$。

因为限制条件是$\le m$所以满足单调性，考虑二分，问题转化为判断能否用k次询问查询出$n$个位置。

两个数字所在位置可以被区分，即至少存在一个询问，这两个数字在这次询问中出现状态不同。所有数字在什么位置都可以区分，等价于$n$个长度为k的二进制串两两不同。$m$实际上限制了任何一列(一次查询)内1的个数不超过某个值。

即如果存在一种方式给[1,n]分配一个$[1,2^k]$内的标号，且不存在一个二进制位上有超过$m$个标号有$1$，那么就可以查询出结果。注意到n实际上和k是无关的，考虑直接求:
$\max |S|:Si∈[1,2^k]$，S中不存在二进制位上有超过$m$个标号有$1$。

实际上，只需要考虑这样的集合，满足$1$的总个数不超过$k×m$即可。考虑如果存在一种标号方案达到了最大集合$|S|$，其中有一个位置A的1的个数超过了$m$个。那么因为总数一定，所以存在某个位置B不到m个。那么将某一个串$s$中第$A$位的1挪到第B位，这样不会使s和无关的串冲突，只有可能s和另一个第$A$位为$0$第B位为1的串冲突。但是第$A$位为$0$第B位为$1$的串的总数严格小于第$A$位为$1$第$B$位为$0$的串的个数，所以总存在一个$s$不会和任何串冲突。那么就可以执行这一次移动，迭代直到每个位置都不超过$m$。

那么问题就是求:
$max |S|:Si∈[1,2^k]，Σic[Si] <= km$。
不同$1$的个数之间一定不会冲突，一定是1个数越小的越优:即每次肯定是取完$C(k,i)$个长度为i的串(或其中一部分)，如果$1$的个数还有剩余，才会取$C(k,i+1)$。
因为$C(k,i)$是指数级的，只需要贪心迭代$log$次$km$就会用完。
加上二分复杂度$O(\log2n)$。
																