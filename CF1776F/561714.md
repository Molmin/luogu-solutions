### 1 题目大意

有一个 $n$ 点 $m$ 边简单无向连通图，请用若干（至少为 $2$）种颜色对每条边染色，使得：

* 对于每种颜色，仅由该颜色的边组成的生成子图不连通。

* 对于每两种颜色，仅由该颜色的边组成的生成子图连通。

**注意：**

* $\sum{n} \leq 5000$

* $3 \leq n \leq 50$

* $n - 1 \leq m \leq \frac{n(n-1)}{2}$

### 2 解题分析

纯纯诈骗题。

显然，我们发现 $k$ 越大，答案越难构造。所以，我们考虑最简单的情况：$k = 2$。

当 $k = 2$ 时，不难想到让一种颜色构成的子图连接不上其中一个点。这样，我们就可以选择一个度数最小的点，把不与这个点相连的所有边染颜色 $1$，再把与这个点相连的边染颜色 $2$。

兴高采烈的写完代码后一测样例：WA 了！于是，我们发现又一种特殊情况：当我们选择的结点度数为 $n - 1$ 时，颜色 $2$ 构成的生成子图是连通的！所以我们可以任意选择一条颜色为 $2$ 的边，把它改成颜色 $3$ 即可。

于是，这道题就完成了。十分诈骗。

### 3 AC Code

细节很少，这里只放核心代码。

```cpp
void solve() {
    cin >> n >> m;
    f (i, 1, n)
        deg[i] = 0;
    f (i, 1, m) {
        scanf("%lld %lld", &u[i], &v[i]);
        deg[u[i]] ++;
        deg[v[i]] ++;
    }
    int mndeg = 2e18, col = -1;
    /*找点*/
    f (i, 1, n)
        if (mndeg > deg[i]) {
            mndeg = deg[i];
            col = i;
        }
    /*染色 1*/
    f (i, 1, m)
        if (u[i] != col && v[i] != col)
            c[i] = 1;
    /*染色 2*/
    f (i, 1, m)
        if (u[i] == col || v[i] == col)
            c[i] = 2; 
    /*特殊情况：完全图*/
    f (i, 1, m)
        if (n * (n - 1) / 2 == m && c[i] == 2) {
            c[i] = 3;
            break;
        }
    /*输出时也要注意特殊情况*/
    printf("%lld\n", 2ll + (n * (n - 1) / 2 == m));
    f (i, 1, m)
        printf("%lld ", c[i]);
    printf("\n");
}
```