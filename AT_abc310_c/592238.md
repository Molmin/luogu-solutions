[传送门](https://www.luogu.com.cn/problem/AT_abc310_c)    
本题解将提供两种做法。     
## 题意     
我们定义，如果两个字符串 $a$ 和 $b$ 半相等，那么 $a=b\lor a=\operatorname{reverse}(b)$，其中 $\operatorname{reverse}(s)$ 表示把字符串 $s$ 反转。    
给定 $n$ 个字符串，判断有多少个字符串不是半相等的。         
## 做法 1：朴素做法     
我们发现如果一个一个判断，那么还得判断反转的情况。那么我们可以规定所以字符串的顺序是相对正向的或相对逆向的。字符串的顺序我们容易想到字典序，所以我们对于任意一个字符串 $s$，选 $s$ 和 $\operatorname{reverse}(s)$ 中一个字典序较小的字符串作为判断条件即可。这样，我们只需进行一次去重就可以得到答案。        
去重我们可以使用 unique，但是记得要排序。          
当然，我们也可以使用 unordered_map，时间复杂度为 $O(n)$。    
如果使用排序，时间复杂度 $O(n\log n)$，瓶颈在排序上。   
[CODE（排序+去重）](https://www.luogu.com.cn/paste/yn5x1oif)       

## 做法 2：哈希   
发现判断相等，容易想到哈希。      
因为正反都要作为判断条件，所以我们对任意一个字符串 $s$ 可以正反都做一次哈希，之后将两次哈希值乘起来。             
我们 $base$ 可以取 $128$。发现本题字符串挺多的，模数取太小可能会产生哈希冲突。    
所以，我们可以开 unsigned long long，进行自然溢出，这相当于是模了 $2^{64}$。   
我们记录下每一次的哈希值，后面就和上面一样了。     
[CODE（排序+去重）](https://www.luogu.com.cn/paste/b96ql5ke)