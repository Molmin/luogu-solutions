### 题意简述
各位大佬应该看了题目都应该知道吧。

题目的意思就是：有两种操作，一种操作是吃掉一个蛋糕，另一个操作是放比上一次放的个数多一个的蛋糕。给定操作的总数和还剩下的蛋糕。求吃掉了几个蛋糕。

### 题目分析

题意非常显然，直接从   $0-n$   枚举吃的蛋糕个数，在计算判断即可，时间复杂度为   $O(n)$ ， 但这道题实在~~太水了~~ 所以也能过。但我们细细想。她每次吃的个数是固定的  $1$ 个，放的蛋糕也是依次递增的。很容易表示出来。所以可以只用解个一元二次方程就可以做出来了。时间复杂度为  $O(1)$ ，已经为最优了。接下来就是高光的数学时刻了。

设珂朵莉一共吃了 $x$ 次蛋糕，所以珂朵莉一共放了   $n-x$ 次蛋糕。

因为每次放的蛋糕比上一次放的个数多一个的蛋糕，且第一次放了  $1$  个。

所以珂朵莉最后一次放蛋糕时放了  $n-x$  个。

所以珂朵莉一共放了  $\sum_{i=1}^{n-x}i$  个。

用等差数列求和公式化简得到珂朵莉一共放了 $\dfrac{(1+n-x)(n-x)}{2}$  。

但珂朵莉有吃掉了  $x$  个，所以 $k= \dfrac{(1+n-x)(n-x)}{2}-x$ 。

化简得  $x^2-(2 \times n+3)\times x +n^2+n-2 \times k =0$ 。

所以用一元二次方程求根公式就能把它解出来 。

一元二次方程：

形如 $a \times x^2+b \times x +c=0$ 的方程为一元二次方程 。

它的解为 $x=\dfrac{-b\pm \sqrt{b^2-4 \times a \times c}}{2 \times a}$ 。

二元一次方程一般有两个解，我们肯定只考虑符合实际意义的解。也就是说答案是小于 $n$ 的那个解 。

### AC code

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;//不然过不了
ll qpow(ll a,ll b){//快速幂模板
	ll ans=1;
	while(b){
		if(b&1) ans*=a;
		a*=a;
		b>>=1;
	}
	return ans;
}
int main(){
	//方程为x^2-(2*n+3)*x+n^2+n-2*k=0;
	ll n,k;
	scanf("%lld%lld",&n,&k);
	ll a=1,b=-2*n-3,c=qpow(n,2)+n-2*k;//处理参数，不然写起来很晕
	ll x1=(-b+sqrt(qpow(b,2)-4*a*c))/(2*a);
	ll x2=(-b-sqrt(qpow(b,2)-4*a*c))/(2*a);
   //方程的两个根
	if(x1<=n) printf("%lld",x1);
	else printf("%lld",x2);
   //判断是否符合实际意义
}
```

（蒟蒻码风丑，不喜勿喷）

这道题确实很水，方程其实很容易就能想出来，代码实现起来也非常容易。

蒟蒻如有说错的地方，请各位大佬随时私信我 。

感谢观看，**请勿抄袭**。