考虑最严的限制就是每个字串的出现次数等于其单个字符的出现次数，也就是说，对于 $a\in S$，每当 $a$ 出现，则其必须是出现在 $S$ 中；换言之，每当一个 $a$ 出现，我们需要在其前后补上若干个字符，把它补成 $S$。

我们并不总能将一个 $a$ 补成 $S$，那我们现在来考虑在哪些情况下这是不能做到的；即，若以下条件满足，$a$ 和 $S$ 中出现的所有字符都不能在答案串中出现。

首先，$a$ 应当有一个后继，在补全的过程中，需要将其置于 $a$ 后。如果 $a$ 拥有了两个不同的后继，则显然不能做到。例如 $\{1,3,5\}$ 和 $\{1,2,4\}$，对于前驱也是同理。 

其次，不能出现循环，例如 $\{1,2\}$ 和 $\{2,1\}$，这样显然是补不全的。

对于前者，我们维护每个数有几个不同的前驱后继；对于后者，用一个并查集来判环即可。

最终，我们拿合法的字串来跑一个背包就可以了。注意对于长度一样的串，我们可以一次性转移，而长度不同的串是 $O(\sqrt k)$ 的。最终复杂度按同阶来算就是 $O(n\sqrt n)$。

```cpp
for(int i=1;i<=n;i++){
	cin>>ln[i]>>pr;
	for(int j=2;j<=ln[i];j++,pr=nw) {
		cin>>nw;
		if(a[pr][nw])continue;
		a[pr][nw]=1;
		l[pr]++,r[nw]++;
		int fx=gf(pr),fy=gf(nw);
		if(fx==fy||l[pr]>1||r[pr]>1||l[nw]>1||r[nw]>1)
        	fl[fy]=0;//fx==fy -> 有循环 
            		 //后面一坨 -> 前驱后继有多个
		fl[fx]&=fl[fy];
		if(fx!=fy)sz[fx]+=sz[fy],fa[fy]=fx;		
	}
}
for(int i=1;i<=k;i++)
	if(gf(i)==i&&fl[i])
		w[sz[i]]++;
for(int i=1;i<=k;i++)
	if(w[i])
		tr.push_back(i);
f[0]=1;
for(int i=0;i<=m;i++)
	for(auto k:tr)
		(f[i+k]+=f[i]*w[k])%=mod;
cout<<f[m];
```