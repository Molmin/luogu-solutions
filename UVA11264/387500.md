## UVA11264 Coin Collector
[原题链接](https://www.luogu.com.cn/problem/UVA11264)

通过六人且零题解。写篇题解吧。
## 题意
作为一个收藏家，你希望收集尽可能多种类的硬币。现在你可以在银行取无限多的钱来换硬币（？），换硬币时优先给你小于等于总金额（或总金额减去已经换成硬币的金额）的面额最大的硬币，询问一次取款最多可以收集多少种硬币。

- 输入：第一行为询问数据总数 $T$，其中每组数据都以 $n$ 开始，表示有 $n$ 种不同的硬币。接下来 $n$ 个数据 $C_{1},C_{2},\dots,C_{n}$ 表示每种硬币的面值。

- 输出：对于每组数据，输出一行最多可以收集的硬币数量。

## 分析

我们可以写一组数据：

- 10 20 40

1. 如果取 60￥ ，可以得到 20，40 面值的硬币

2. 如果取 110￥ ，可以得到 10，20，40 面值的硬币

3. 如果取 50￥ ，可以得到 10，40 面值的硬币

观察1、2，如果不选面值最大的硬币，取的钱数一定比它小，即 $k<c[n]$，这时如果取 $k+c[n]$ 的钱兑换一定可以得到更多硬币。得到第一条结论：

**1. 面值最大的硬币 $c[n]$ 一定要选。**

观察 1、3，如果不选面值最小的硬币，可以少取一点钱把所选的最小硬币转化成面值最小的硬币，总硬币数不变。得到第二条结论：

**2. 面值最小的硬币 $c[1]$ 被选时不影响结果。**



------------


再写一组数据：

- 10 30 40 60

设 $k(i)$ 是 $c[1] \sim c[i]$ 中被选的硬币面值之和，我从 $i=1$ 开始存储。

- 选 10，40 面值的硬币时， $i=3$ ， $k(i)$ 的值为 50 ， $c[i+1]$ 的值为 60 。此时 $k(i)<c[i+1]$。

当然，只用一组数据是无法确定式子正确的。我们可以反证假设： $k(i) \ge c[i+1]$ 时，根据换钱规则，银行要找给你 $c[i+1]$ 面值的硬币，但 $k(i)$ 不可能包含 $i+1$ 的面值，不等式正确。

通过结论 2. 我们直接选中第一枚硬币，从 $i=2$ 开始枚举当前硬币能否被选中即可。综合上文推出的不等式，得到贪心策略：

**当 $k+c[i]<c[i+1]$ 时，选中硬币 $c[i]$。**

最后需要注意一点：**需要特判只有一种硬币的情况**。

## Code

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int c[1010];
int ans=1;
int main(){
	int t;cin>>t;
	int k,n;
	for(int i=1;i<=t;i++){
		cin>>n;
		if(n==1){ //特判n=1时，只能选这一种硬币 
		    cout<<n;
		    return 0;
	}
		ans=2;k=0; //直接选中第一枚和最后一枚硬币 
		for(int i=1;i<=n;i++)cin>>c[i];
		for(int i=2;i<=n-1;i++){ //跳过1，n两枚硬币
			if(k+c[i]<c[i+1]){ //贪心选择 
			    k+=c[i]; //更新当前k值 
			    ans++; //计数累加 
			}
		}
		cout<<ans<<endl;
		return 0 //end 
	}
}
```



