**首先要铭记，这是一道T2！**

## 先明确要求什么

**求出所有取模结果（去重后）的第二大的值**

憨批如我第一次就把题看成了求“重复”部分的第二大的值，还和山东刘亦菲疯狂吃饭的时候讨论。

大家谨记一定要**仔细读题**。


## 开始分析

### 方案一：

求出所有结果，找出第二大（去重）的值。

对于$n$个整数，一共会有$n × (n-1)$个结果，复杂度$O($n^2$)$

对于$70\%$数据，$n=3 \times 10^3$，不超时。

对于$100\%$数据，$n=2 \times 10^5$，显然超时。

**期望分70**

**再次铭记，这是一道T2！所以这种显然不让求所有余数的数据范围，显然就是要讨论出个结论**


### 方案二：

对于取模式子 $m\%n=p$ 来说

假设$m>n$，那么$0 \leq p <n $

假设$m=n$，那么$p=0$

假设$m<n$，那么$p=m$

所以$p\leq min(m,n)$

那么对于序列a来说，可以计算出的余数一定$\leq$ 序列中的最大值$a_{max1}$

1. 是否存在余数$p=a_{max1}$ ？显然不存在，因为只有$m<n$，那么$p=m$才会成立。

2. 是否存在余数$a_{max2}<p<a_{max1}$(序列中第二大的数)？显然不存在，因为没有一个$m>$ $a_{max1}$


3. 是否存在余数$p=a_{max2}$(序列中第二大的数)？显然存在，$a_{max2}$ $\%$ $a_{max1}$ $=$ $a_{max2}$ 

4. 是否存在余数$a_{max3}<p<a_{max2}$？有可能存在， $a_{max3}$ $<$ $a_{max1}$ $\%$ $a_{max2}$ $<$ $a_{max2}$

5. 是否存在余数$p=a_{max3}$(序列中第三大的数)？有可能存在，$a_{max3}$ $\%$ $a_{max2}$ $=$ $a_{max3}$

综上所述，余数中第二大的数，不是情况$4$就是情况$5$。

## 口胡做法

1. 从大到小排个序

2. 找到第一大的数（一定是a[1]），第二大和第三大的数（去重之后的）

3. 如果没找到第二大的数（所有数都相同），直接输出-1

4. 如果没找到第三大的数，输出上述的情况4

5. 如果都找到了，比较情况4和情况5谁大输出谁

## 丑陋但是直白的代码
```c++
#include <bits/stdc++.h>
using namespace std;
bool cmp(int x, int y) { return x > y; }
int a[200007], n, k, l;
int main() {
    cin >> n;
    for (int i = 1; i <= n; i++) cin >> a[i];
    sort(a + 1, a + n + 1, cmp);
    k = 2;
    while (k <= n && a[k] == a[k - 1]) k++;
    l = k + 1;
    while (l <= n && a[l] == a[l - 1]) l++;
    if (k > n)
        cout << -1;
    else if (l > n)
        cout << a[1] % a[k];
    else
        cout << max(a[l], a[1] % a[k]);
    return 0;
}
```
## 留空修改

洛谷现在的数据比较水，少考虑最后的max比较的情况也过了（也可能是我考虑多了？）

上课和我一起口胡思路的xsj@不知名网友，和吃饭时疯狂讨论读错题面下的解法的山东刘亦菲@yiiiiiiiiii

~~要是正解出来发现错了就让他俩背锅，嘿嘿~~