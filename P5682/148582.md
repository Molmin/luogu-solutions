萌新第一篇题解，有错误请指正（卖萌.jpg）

【题目链接】[传送门](https://www.luogu.com.cn/problem/P5682)

【题目大意】给你n个可能重复的数，每次挑两个（若不相同）互相除，所有的组合挑完之后问第二大的余数是多少。

【解题思路】看完数据范围首先想暴力......首先因为重复的都是不合法的组合所以去重（双层循环里还要判断“若i==j则continue”）,之后暴力枚举计算第二大的结果即可。——70%

之后我们想想正解——两个数，是大的除小的余数大，还是小的除大的余数大？实在想不通可以举例论证嘛

```
5%2=1
2%5=2
3%8=3
8%3=2
1%5=1
5%1=0
//大数模小数结果小于小数
//小数模大数结果等于小数
//当然小数膜大数大了
```

刚才我们得到一个很重要的结论，将它推理后可知

```
排序去重后，第二大的数是最大的答案
又可知
排序去重后，第三大的数是第二大的答案
//这题不就做出来了？（我的思考过程）
```
——100%

还有就是去重用桶可能会爆，第一、第二、第三大的数可以滚动更新。

最后处理下特殊情况：若去重之后只剩1个数，输出-1；若只剩两个数，根据举例论证的结论，大数模小数第二大，输出即可。

【正解代码】

```cpp
#include<bits/stdc++.h> 
using namespace std;
int a[300000],max1,max2,max3;
int main()
{
	int n,cnt=0;cin>>n;
	for(int i=1;i<=n;i++)cin>>a[i];
	sort(a+1,a+n+1);
	max1=a[1];
	for(int i=2;i<=n;i++)
	{
		if(a[i]==a[i-1])
		{
			cnt++;
		}
		else //排完序了，后数小于等于前数；又去了重，肯定比前数（刚刚更新的答案）大
		{
			max3=max2;
			max2=max1;
			max1=a[i];
		}
	}
	if(cnt==n-1)//特判1
	{
		cout<<-1;
		return 0;
	}
	if(cnt==n-2)//特判2
	{
		cout<<max1%max2;
		return 0;
	}
	cout<<max3;
	return 0;
}
```
