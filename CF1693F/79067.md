## 提示

1. 你可以对任意区间操作，并且各个区间的代价还是不同的。这看起来很麻烦，能否将其转化为一种更好的操作形式？

2. 最终的目的是将 1 放在后面，那按怎样的顺序操作是最好的？

## 思路

先考虑一下答案的上界，就是 $|c_0-c_1|+1$，即一次性操作完毕。我们现在需要干的就是多做几次操作使得答案减少一点$(\star)$。

对任意区间操作，各个区间的代价不同——这样的形式非常的麻烦，使得我们很难把握题目的性质。考虑能否将操作转化为更好的形式。考虑 $|c_0-c_1|$ 这个代价其实是很不划算的。感觉上就是你多做几次操作会比一次操作 $c_0,c_1$ 差太多要好一点，因为你要干的 $(\star)$ 其实也就是这个事情。然后稍微证一下发现确实是这个样子的，单次 $|c_0-c_1|=d$ 的操作可以调整为至多 $d+1$ 次 $c_0=c_1$ 的操作。然后相当于就是把决策严格化了，我们可以更好地考虑贪心了。

后面就感觉比较简单一点了啊，这里我们是想把 1 尽可能往后放，那很自然地想到每次要操作一个前缀。不然的话你第一个 1 和后面 1 距离就变远了，感觉就很亏。然后写一发发现过了。

## 题解

首先可以假定整个序列 $c_0\ge c_1$；否则我们把 0 变成 1，1 变成 0，并翻转序列。新序列答案与原序列相同。

**结论**：仅操作 $c_0=c_1$ 的区间的最小答案和原题一致。

**证明**：考虑操作了一个 $c_0-c_1=d$ 的区间。区间第一个数，若是 0，那我们的操作区间其实不应该包含它。也就是说第一个数是 1，那么我们找到一个 1 和 0 数量相等的前缀将其排序，第一个数就变成了 0。然后我们把它去掉，就花费 $1$ 的代价进入了 $d-1$ 的子问题，直到 $d=0$ 可以一次性排序。这就相当于是把原操作拆成了 $d+1$ 个 $c_0=c_1$ 的操作。

得知这个结论以后，就可以考虑贪心了。

**贪心策略**：每次操作一个最长的 $c_0=c_1$ 的前缀，然后把其中的 $0$ 删掉。若此时 $c_0\le c_1$ 了，就可以从删掉的里面补回来一些 $0$，然后一次排好；否则重复此过程。

正确性可以感性理解，在最后一次操作前，前 $c_0-c_1$ 个数应当全是 0。那么第一个 1 肯定是需要往后，而且肯定是越早越好。

具体实现，我们求出 $a_i$ 表示最大使得每个前缀中 0 比 1 多的 $i$ 个的位置。就可以在每次删掉若干个 0 后求出下一段 01 个数相等的最长前缀了。这一步并不太难，可以参考一下我的代码实现。

时间复杂度 $O(n)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
 
void solve(){
	int n,res=0;cin>>n;
	string s;cin>>s;
	if(is_sorted(s.begin(),s.end())){cout<<0<<endl;return;} 
	
	int _0=count(s.begin(),s.end(),'0'),_1=n-_0;
	if(_0<_1){swap(_0,_1);reverse(s.begin(),s.end());for(auto&x:s)x='0'+'1'-x;}
	
	vector<int> mx(n+1);
	for(int i=0,ns=0;i<n;i++){
		ns+=s[i]-'0'?-1:1;
		if(ns>=0)mx[ns]=i;
	}
	int delta=_0-_1,nw=0;
	while(nw<n&&s[nw]=='0')nw++;
	while(nw<delta){
		res++;
		nw+=(mx[nw]+1-nw)/2;
	}
	cout<<res+1<<endl;
}
 
main(){
	ios::sync_with_stdio(0);
	int _T=1;cin>>_T;
	while(_T--)solve();
}
```