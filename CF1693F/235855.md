题面很清楚，这里就不搞了。

看到这个区间操作是 $|cnt_1-cnt_0|+1$ 的代价就感觉很难去维护，也很难看出有什么性质。

于是稍微写了几个数据玩玩。测试了几次之后，发现对于 $cnt_0=cnt_1$ 的情况往往能使得其步骤取到最小值。

**可以稍微进行证明:**

首先是 $0$ 是 $1$ 并不重要，我们可以反转，其结果是一样的。所以就不妨设 $cnt_1 \leq cnt_0$ , 两者的差值为 $d$ 。

由于我们是为了尽量让 $1$ 往后推， $0$ 往前拉。

我们不妨设对于一个区间来说先取了 $x$ 个 $0$ ， $y$ 个 $1$ 。那么其区间前 $x$ 个位置已经排好不用再管，于是后面紧跟着 $y$ 个 $1$ ， 剩余部分占有 $cnt_1+d-x$ 个 $0$ 和 $cnt_1-y$ 个 $1$ 。 代价为 $|y-x|+1$ 。

那么对于剩下的区间来说，相当于前面的 $x$ 个位置已经排完，还剩下 $cnt_1+d-x$ 个 $0$ 需要排。



发现前后的 $1$ 的个数是完全一致的，有关于 $0$ 的排列次数只与 $x$ 的大小有关，也就是当 $x$ 一定时，无论如何取 $y$ ， 最后所需要排的 $0$ 的个数是相同的。

而此时如果有 $y=x$ ，也即是取 $0$ 和 $1$ 各 $x$ 个，恰好能使得在初始要排 $cnt_0$ 的情况下， 排到还剩 $cnt_0+d-x$ 个 $0$ 的代价最小化。

**也即是结论：对于取 $cnt_0=cnt_1$ 的情况往往能使得其步骤取到最小值。**

考虑最坏的情况，若每一次的 $x$ 只能取 $1$ ，那么要使得最后剩下 $cnt_0=cnt_1$ 的位置就可以再取一次，总的代价就是 $d+1$ 。就等于其直接对于此区间进行操作的代价。

所以其取相同的 $cnt_0$ 和 $cnt_1$ 操作的上界就等于直接对于此区间进行操作的值，所以就不用担心这个方法劣。

那么很明显，在 $d$ 一定的情况下我们要使得 $x$ 的值最大，也就是尽量多取 $x$ 。

但考虑到可能对于 $cnt_1+d-x \leq cnt_1$ 的情况不难想到去补零，维护其 $cnt_0-cnt_1$ 的值，也即是记录对于任何一个 $cnt_0-cnt_1$ 其最大位置在哪里。

我们用 $las_d$ 代表 $cnt_0-cnt_1=d$ 出现的最大位置，那么就可以在每次删除 $x$ 个 $0$ 之后求出下一段等长的 $01$ 最长前缀长度。

时间复杂度是 $O(n)$ 。

```cpp
#include<bits/stdc++.h>
#define For(i,a,b) for(int i=a;i<=b;i++)
#define Rep(i,a,b) for(int i=a;i>=b;i--)
using namespace std;
const int maxn=200050;
inline int read()
{
	int x=0,f=1;char c;
	for(;!isdigit(c);c=getchar()) if(c=='-') f=-f;
	for(;isdigit(c);c=getchar()) x=(x<<1)+(x<<3)+(c^48);
	return x*f;
}
inline void solve()
{
	int n=read();
	string s;cin >> s;
	if(is_sorted(s.begin(),s.end()))
		return cout << '0' << endl,void();
	int cnt0=0,cnt1=0;
	For(i,0,n-1) 
		if(s[i]=='0') cnt0++;
		else cnt1++;
	if(cnt0<cnt1)
	{
		swap(cnt0,cnt1);
		reverse(s.begin(),s.end());
		For(i,0,n-1)
			s[i]='0'+'1'-s[i];
	}
	int sum=0;
	vector<int> las(n+5);
	For(i,0,n-1)
	{
		sum+=(s[i]-'0')?-1:1;
		if(sum>=0)
			las[sum]=i;
	}
	int d=cnt0-cnt1,ans=0,pos=0;
	while(pos<n&&s[pos]=='0') pos++;
	while(pos<d)
		ans++,pos+=(las[pos]+1-pos)/2;
	cout << ans+1 << endl;
}
signed main()
{
	int T=read();
	while(T--)
		solve();
	return 0;
}
```


------------

写在最后(应该没人看吧):

这道题目也是思维题，我是比较侥幸猜中结论的这种人。

想的时间也很长，思维的强度是越来越弱了。

最近开始复健才发现周围的人都已经比我强太多了，我感觉不仅我的练习量不够，天赋也不行。而且也不知道自己的思路什么的对不对，上边的这篇文章一定也会有很多问题（写的和稀烂一样），希望大家能及时提出，能让我很快修改。

最后，希望你我前行的路上不只有苦痛的荆棘，还有满山开遍的玫瑰。