### 题目大意

由于下周末是万圣节，Gappu 有一个非常忙碌的周末。他计划尽可能多地参加聚会。因为是万圣节，所以这些派对都是服装派对。Gappu 总是希望自己的服装与朋友们的融为一体。

因为他将参加很多万圣节派对，他将多次更换服装。所以，为了让事情变得简单一点，他可以穿上一件又一件的服装（也就是说，他可以穿着很多件衣服）。但是，请记住，Gappu 不喜欢穿不干净的衣服，所以。脱下某种制服后，他不能在万圣节之夜再穿，如果他再次需要某种制服，他就必须换一件。他可以脱下任何数量的服装。但是，如果他在服装 B 之前穿上服装 A，那么为了脱下 A，他必须脱下 B。请找到 Gappu 在万圣节夜晚需要的最少服装数量。

### 题目分析

开始想到贪心，但很明显太慢了，过不了。

所以这道题的正解是区间 DP。

设 $f[i][j]$ 表示从第 $i$ 次派对到第 $j$ 次派对所需衣服的数量。

- 如果第 $i$ 次派对到第 $j$ 次派对穿的衣服一样，那么可以让 $i \sim j$ 次派对穿在当前衣服之外，第 $j$ 次派对将之前穿的都脱掉，这样第 $j$ 次派对穿的就是第 $i$ 次的那件。即 $f[i][j] = f[i][j-1]$。
- 如果第 $i$ 次派对到第 $j$ 次派对穿的衣服不一样，我们可以在第 $j$ 次派对时将第 $i$ 次派对之后穿的都脱掉，使现在穿的是第 $i$ 次派对的衣服，然后再穿上第 $j$ 次派对的衣服，即 $f[i][j] = f[i][j-1] + 1$。
- 前面两种说的是从 $i$ 直接变为 $j$，还有可能从 $i$ 到 $j$ 是分多次变到的，所以要枚举一个中间结点 $k$，即用 $f[i][k] + f[k+1][j]$ 更新 $f[i][j]$。（$f[i][k]$ 也有可能是多次变来的，所以上述状态转移方程不代表是两部分变来的。）

状态转移方程讲完了，然后来处理一下边界问题。

- 首先，$f[i][i] = 1$，因为从第 $i$ 次派对到第 $i$ 次派对所需衣服的数量最小一定是 $1$。
- 其次，$i$ 应该从 $1 \sim n$ 枚举，$j$ 从 $i + 1 \sim n$ 枚举，$k$ 从 $i \sim j - 1$ 枚举。

### code
```cpp
#include <iostream>
#include <cstdio>
using namespace std;
const int N = 1e2 + 5;
int T, n, m, a[N], f[N][N];

int main()
{
	scanf("%d", &T);
	for(int i = 1;i <= T;i++)
	{
		scanf("%d %d", &n, &m);
		for(int j = 1;j <= n;j++)
		{
			scanf("%d", &a[j]);
			f[j][j] = 1;
		}
        	//这是另一种枚举方式，跟上述枚举本质上是一样的，主要看个人习惯。
		for(int j = 2;j <= n;j++)				//枚举区间长度
		{
			for(int k = 1;k <= n - j + 1;k++)		//枚举左端点
			{
				(a[k] == a[k+j-1]) ? f[k][k+j-1] = f[k][k+j-2] : f[k][k+j-1] = f[k][k+j-2] + 1;
				for(int l = k;l < k + j - 1;l++)	//枚举中间结点
					f[k][k+j-1] = min(f[k][k+j-1], f[k][l] + f[l+1][k+j-1]);
			}
		}
		printf("Case %d: %d\n", i, f[1][n]);
	}
	return 0;
}
```