第十一分块。

首先先吐槽一下，为什么 cmd 的题解写的这么潦草，至少我连分块的思想都没看懂，也许是我太拉跨了吧（                  

本篇题解也许会稍微讲细一点，毕竟这道题还是太哕了一点/ll            

虽然 lxl 没评，不过个人还是觉得这道题可以有 $9$ 吧，冲这分块的思想我就没想到/ll           

本人比较手残，经常打错字，所以如果打错了字请原谅/ll

------------------------------

首先我们不难发现如果不考虑单次加点度数啊啥的影响，你就假设它是条链，那么相当于每次加入一个点就只会合并相邻的两个连通块，那么我们只要使用回滚莫队（我习惯的是右边只增而左边可撤回的写法），对于右边我们只要用线段树合并一直合就好了（合并部分就直接按照题意模拟就好了），对于左边我们可以考虑开辅助数组，最后直接用栈撤回就好了。                  

我们现在有了一个 $O(n \sqrt n \log n)$ 对于序列的做法，这很好！不过距离做出来这道题真的太远了……                   

先不考虑更优的时间复杂度实现，我们只想把问题搬到树上去，此时需要将度数考虑到分块的方式里面去，这是个很难的问题。              

我们不妨先来想一些比较简单的问题：假设我要查一次全局的答案，那么我是不是直接就从右扫到左直接线段树合并？这个显然是 $O(n \log n)$ 的，发现还不是一个很大的量级，可不可以在这上面做一些手脚？             

我们先假设已经分好了块，我们发现时间复杂度的瓶颈其实是在左段的回滚上面，我们必须得保证在任意情形下加入整个左端块的时间复杂度在 $O(\frac{n \log n}{\sqrt m})$ 之内，不然我们肯定连最基本的 $O(n \sqrt m \log n)$ 的时间复杂度都不能保证了。                

观察一下，可以得到一些比较不错的性质：              

- 计算加入整个左端块的最劣时间复杂度会在右边所有点都被加入的情况下产生。            

这个~~显然~~，因为我们知道你是一棵树，那么想卡满你就是要你做更多次合并并且合并的点量尽量多，那肯定是点更多你的时间复杂度更爆炸。        

- 所有块的最劣时间复杂度之和为 $O(n \log n)$             

这个地方得靠理解，由于我们一个块的最劣时间复杂度定义在右边所有点加入的情况下，并且我们全局的最劣时间复杂度也是 $O(n \log n)$，所以我们每个块的最劣时间复杂度等于全局最劣时间复杂度 $O(n \log n)$，借 @[gxy001](https://www.luogu.com.cn/user/55707) 的话说可以看作是对一个长为 $O(n \log n)$ 的序列分块。                 

这两条性质是此做法的基础，后面相关时间复杂度的证明都会用到这两个性质，请务必理解。                     

那么我们考虑初始化时直接模拟一遍加点的过程，每次分块时保证在块右端的所有点都被加入的情况下加入一个整块的时间复杂度必须在 $O(\frac{n \log n}{\sqrt m})$ 以内即可。               

不妨证明一下总的时间复杂度，首先模拟分块的过程肯定是 $O(n \log n)$ 的，这里不再赘述。               

对于每个块有一个一直向右滚的右指针，令 $B = \frac{n \log n}{\sqrt m}$，那么块的数量级为 $O(\frac{n \log n}{B}) = O(\sqrt m)$，向右端滚动的最坏时间复杂度为 $O(n \log n)$，所以右指针的总时间复杂度为 $O(n \sqrt m \log n)$。              

对于左指针，每次加入/回撤时的时间复杂度量级为 $O(B)$，总的时间复杂度为 $O(mB) = O(n \sqrt m \log n)$。                 

于是你愉快地写了这个做法发现空间不仅炸裂开来，还被卡 T 了……        

考虑值域比较小，严格小于 $2 ^ {15}$，所以我们直接上 Trie 树合并，并且压位将 Trie 树变成 $32$ 位压位 Trie，并且这里只能动态开点合并压位 Trie。                   

这样就可以把时空复杂度都压到 $O(n \sqrt m \log_w V)$ 了，在精细的实现下可以通过此题。                 

接下来是比较重要的实现环节。

对于维护一个压位 Trie 内出现次数为奇数的颜色，我们可以启发式合并。用小的 Trie 往大的 Trie 上面接，我们只标记出现次数为奇数的颜色，如果两棵 Trie 有共同出现次数为奇数的颜色就得递归合并，如果小的 Trie 上面有出现次数为奇数的颜色但是在大的 Trie 上面只出现了偶数次就得把小的 Trie 的该节点往大 Trie 上面接。                       

不难证明这么做的时间复杂度还是可以当作 $n$ 个点 $n$ 次合并总时间复杂度 $O(n \log_w V)$ 的，就是个线段树合并。              

然后关于记录儿子是谁，这个可以直接开一个二维的 $O(n \log n)$ 数组记录，不会爆空间的。                       

然后要分开向右的真实合并所用的数组和向左滚动时使用的辅助数组，一个块里面的暴力查询也得用分开向右的真实合并所用数组，细节很多写挂一个就没了，一定格外小心。                  

对于向左滚动时，我们可以考虑一种~~多快好省~~的写法：我们把可能用到的点都给保存下来，并且使用辅助的维护父亲的数组，此时我们可以破坏树的形态，只需要让最后该联通的点联通在一起就可以了。

所以先假定所有在莫队回滚时回滚到的点为根并将所有点保存下来，然后向外拓展时拓展的节点如果在辅助的父亲数组内没有父亲，就把其父亲置为拓展到它的节点并将其作为可能用到的节点保存下来；如果有父亲就说明之前被合并过，就找到根上去再执行类似的操作但不保存下来。                   

这里注意莫队回滚时回滚到的点也有可能在最后不会成为根，不过没关系反正我们都可以最后判。                    

现在我们发现我们大致连出来了很多个菊花图，扫一遍保存下来的所有可能用到的节点，在找到其所处连通块的实际根后首先减去所有连通块原本的贡献，如果是根节点就等所有合并结束后拿出来把贡献加上，非根节点就往它所属的根上面合并就好了，还是比较精细的实现。                

这一部分的代码如下：

```cpp
int ans = res;G.clear(); 
for(int k = Sec[now].l ; k < R[i] ; k ++)//莫队滚左端时遍历到的所有点 
{
	fa[k] = k , in[k] = 1 , G.push_back(k);//加入左端节点 
	ans += A[1];//加上初始贡献 
	for(int e = head[k] ; e ; e = edge[e].next)//拓展点 
	{
		int to = edge[e].to;
		if(in[to])//这个点出现过 
		{
			int rtt = findSet(to , relfa);//先找到根节点，relfa 是实际合并时用到的 fa 数组，fa 是辅助的 fa 数组 
			if(!fa[rtt]) fa[rtt] = k , G.push_back(rtt);//没有父亲，保存下来作为可能用到的节点 
			else fa[findSet(rtt , fa)] = k;//找到根节点继续合并 
		}
	}
}
for(int p = 0 ; p < G.size() ; p ++)
{
	int noww = G[p];
	if(fa[noww] == noww) rt[noww] = relrt[noww] , sz[noww] = relsz[noww] , ans -= A[relsz[noww]];//辅助数组初始化 
}
for(int p = 0 ; p < G.size() ; p ++)
{
	int noww = G[p];//这里我们要抽象理解，因为是一个连通块所以我们无需计较图的形态，直接接一个菊花图出来就好了 
	if(fa[noww] != noww) 
	{
		int rtt = findSet(noww , fa);//找根 
		ans -= A[relsz[noww]];//删贡献 
		if(sz[rtt] > relsz[noww]) rt[rtt] = rollmerge(rt[rtt] , relrt[noww] , sz[rtt] += relsz[noww] , 0 , 0 , 2);
		else rt[rtt] = rollmerge(relrt[noww] , rt[rtt] , sz[rtt] += relsz[noww] , 0 , 0 , 2);//启发式合并 
	}
}
for(int p = 0 ; p < G.size() ; p ++)
{
	int noww = G[p];
	if(fa[noww] == noww) ans += A[sz[noww]];//加回贡献 
}
Print[now] = ans;
gxy001_Orz();//回撤部分 
for(int k = Sec[now].l ; k < R[i] ; k ++) in[k] = 0;
for(int p = 0 ; p < G.size() ; p ++){int noww = G[p];fa[noww] = 0;}//清空
```

此题真的细节很多，我的实现基本也是参考 @[gxy001](https://www.luogu.com.cn/user/55707) 的，如果需要代码参考可以找他或我。               