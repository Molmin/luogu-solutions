大家好这里是一个傻逼，他把一个可撤销并查集写挂了四个地方并调了整整一天。

---

### 题意简述：

给定一张 $n$ 个点 $m$ 条边的 **有向图**。要求支持三种操作：断边、单点加，查询一个点所在强联通分量中排名前 $k$ 的数的和。

### 题解

非常牛逼的一个题。

一开始没看到有向图这个东西，直接嘴巴了一个倒序加边跑并查集维护的权值线段树合并（全是套路，不会的可以看其他的题解）。写了三十分钟仔细读了读题。

![](https://cdn.luogu.com.cn/upload/pic/14789.png)

于是不会。打开题解。发现是个整体二分。关上题解。

这怎么和整体二分扯上的关系？

我们根据刚才那个做法来想一想正解。

为什么我们不能直接并查集维护？因为我们不知道把 $u$ 和 $v$ 连起来之后，他们什么时候会在一个强联通分量里头。

那我们求出来对于每个加边 $u$ 和 $v$，最晚什么时候开始 $u$ 和 $v$ 会在同一个强联通分量里头。

注意这里的时间轴 $[0, q]$ 是倒序的。也就是说，答案是 $x$ 的时候，在询问 $[0, x]$ 之间，$u$ 和 $v$ 均在一个强联通分量里头。

暴力的时间复杂度劣在哪儿？每次都要重新把图建出来。

于是这个东西一脸整体二分的样子。具体地，我们，对于当前答案区间 $[l, r]$ 和询问备选区间 $[L, R]$, 先将所有 $[r + 1, q]$ 中的边丢进图里，对于中间的每一个询问，如果其存在时间是晚于 $mid$ 的，则把他也丢进图中。然后跑一遍 tarjan，递归就完了。

再看一眼发现复杂度非常不对。


![](https://cdn.luogu.com.cn/upload/pic/14789.png)


不对在哪儿？我们还是重复地加入了大量的边。

我们发现，在上一层往左递归的时候，很多的边其实是有用的。

于是，我们直接用并查集维护缩点，每次只把当前区间内的边连出来。在往两边递归的时候清空。这个并查集则在往右递归的时候清空。

这样的话我们不仅成功做对了复杂度，还保证了正确性。

何来的正确性？

对于每一条边，他要么在强联通分量里头 —— 他已经被缩进了点。

否则他就不在——但他一定会在往左递归的时候被再加进去。 原因很简单，我们把当前区间不符合的全部丢到了左边，自然会被再加一遍。

于是就做完了。

这个题的代码实现很有技巧，我这种写着写着就重名的只能 namespace 封装了。

[代码](https://www.luogu.com.cn/paste/ooal4qgk)思路挺清晰的，还是挺好看的。


