# P3413 题解
数位$dp$裸题啊
## 题意
求$[l,r]$内的萌数有多少个。
## 解答
虽然是裸的数位$dp$，但我还是要来讲一下暴力。

暴力做法很简单，就是$[l,r]$之间枚举一下，枚举到一个萌的数就$+1$就行了。  
放一个伪代码吧
```cpp
for i=l to r
	if meng(i) cnt++
cout<<cnt
```
~~暴力讲完了~~真的讲完了

接下来就是**数位**$dp$
## 数位$dp$
这是个什么呢？读它的字面意思就知道了，数位$dp$就是通过枚举数位的某些特性解决问题。通常，数位$dp$的复杂度是$\Theta(\log_{10}n)$的，所以其实数位$dp$只要写对，几乎没法卡。  

那么我们从最简单的一道例题开始：统计$[l,r]$区间内出现了多少个**包含$1$的数**。

这当然可以用小奥方法做，在此不赘述了。  
我们从预计算讲起  
设$f_i=1$到$i$位数中包含$1$的数的个数。  
设$f_{ij}=1$到$i$位数，**首位为**$j$的数中包含$1$的数的个数。

转移方程：
$$f_i=9 \times f_{i-1}+10^{i-1}$$
$$f_{ij}=\begin{cases}10^{i-1}&\text{have1}\\\sum\limits_{k=1}^9f_{ik}&\text{else}\end{cases}$$  
然后根据这个**从高位到低位枚举首位并统计**就能解决这个例题了。这个过程我们可以采用**记忆化搜索**。  
参考伪代码：
```cpp
ll dfs(ll pos,bool flag){//pos:当前这一位,flag:pos之前的位中是否有1
	已经遍历完所有的数位,直接返回这个数是否有1
	答案初始化为0
	枚举首位i
	如果更高位没有1,那么可以放心的加
	如果有1,那么所有的这些情况都包含1,直接加上10的pos次方
	当前答案+(pos-1位数,比pos-1高的位数中有没有1)的答案
}
```

***
###### $\tiny{\color{grey}华丽的分割线}$

好了我们回归原题。  
根据我们数位$dp$的经验，我们肯定是要枚举数位的，那么这样一来就有一个问题：例如判断一个```12345678987654321```是否回文，我们难道要记录那么长一个状态吗！？
![](https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=159178527,2126930547&fm=26&gp=0.jpg)  
~~你看众多巨佬的题解代码哪个有那么长~~  
那么，我们发现```12345678987654321```其实核心在于有一个**回文子串**```898```，所以只要```898```回文，它就回文了。  
所以**任意回文串一定有长度为$2$或$3$的回文子串**（证明也太简单了）  

因此我们只要考虑两个数的情况：
1. 相邻(xx)
2. 隔一个数(xnx)

你以为这样就结束了？$\texttt{\Huge{\color{red}No}}$！  
发现对于一个```000123```具有前导$0$回文的数，如果只用前面的算法，这个数也会被判断为萌数，而实际上他并不是，所以我们还需要**判断前导**$0$。

那么我们可以快乐的写$dfs$了：
```cpp
ll dfs(ll l, ll pp, ll pp2, bool zr1, bool zr2, bool lmt)
{
	edge(l, pp, pp2, zr1, zr2, lmt);//一些情况的特殊处理
	ll sum=0;
	if (lmt)
	{//有限制
		for(ll i=0; i<=s[l]; i++)
			if((zr1 || i!=pp) && (zr2 || i!=pp2))
				sum+=dfs(l+1, i, pp, zr1 && (i==0), zr1, lmt && i==s[l]);
		f[l][pp][pp2][zr1][zr2][lmt]=sum;
		return sum;
	}
	else
	{//无限制
		for(ll i=0; i<=9; i++)
			if((zr1 || i!=pp) && (zr2 || i!=pp2))
				sum+=dfs(l+1, i, pp, zr1 && (i==0), zr1, 0);
		f[l][pp][pp2][zr1][zr2][lmt]=sum;
		return sum;
	}
}
```
那个啥关于$r<=10^{1000}$的你用字符串处理一下不就行了吗。

完结撒花~同时求赞$qwq$