首先，显而易见，单次询问后答案增加的数量为新节点的深度。

那么，这个问题将会从一个模拟问题抽象为数学问题。

首先，我们可以直接模拟，但是在树退化为链的情况下，时间复杂度会达到惊人的 $O(n^2)$。

很明显，我们要优化。那么首先我们考虑可以在哪里进行加速。

关键性质：节点的祖先要么是数值比他小中的最大数，要么是比他大的最小数。考虑二分。但很明显，二分要求有序序列，那么复杂度瓶颈将会在插入上。如果使用链表，则会无法进行二分。那么显然二分是不可行的。

那怎么办呢？没关系，我们已经想到了链式结构，我们先放一下。

考虑建一个数组，值为零则该下标没有被加入，值为一则表示已经被加入到二叉树。那么可以从左往右，从右往左直接找。

虽然时间复杂度没变，但是很明显可以进一步优化。

我们同时从左往右和从右往左搜索。只要一边搜索出来，直接退出。

那么我们可不可以不用往另一边找了呢？很明显可以。使用链表维护左右关系，那么只要知道一边的数，就可以知道另一边。然后就可以直接求了。最坏复杂度 $O(n \log n)$。另外，记得看数据范围。

附上代码及链接：

[Link](https://www.luogu.com.cn/record/105339854)

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
int a[300010];
int l[300010],r[300010];
int d[300010];
signed main(){
	int n;
	cin >> n ;
	int x,ans=0;
	cin >> x;
	a[x]=a[0]=a[n+1]=1;
	l[x]=0;
	r[0]=x;
	r[x]=n+1;
	l[n+1]=x; 
	cout << 0 << endl;
	for ( int i = 1 ; i < n ; i++ )
	{
		cin >> x;
		a[x]=1;
		int lp=x-1,rp=x+1;
		while(!a[lp]&&!a[rp])
		{
			lp--;
			rp++;
		}
		if(a[lp])
		{
			rp=r[lp];
		}else{
			lp=l[rp];
		}
		r[lp]=x;
		l[rp]=x;
		r[x]=rp;
		l[x]=lp;
		d[x]=max(d[lp],d[rp])+1;
		ans=ans+d[x];
		cout << ans << endl;
	}
	return 0;
} 
```