注：下面的 $(x,y,z)$ 表示一个 $a=x,b=y,c=z$ 的方案。
# 题目分析
首先我们可以发现一件有趣的~~小学一年级都会的~~事情：$3+4=7$

~~好的此题完结。~~

这意味着什么？一个圆规可以拆成一支笔和一本笔记本，反过来，一支笔和一本笔记本也可以合成一个圆规。

那么所有的方案 $(x,y,z)$ 都可以通过拆圆规来变成 $(0,y+x,z+x)$，也就是说每个方案都对应着且仅一个 $x=0$ 的方案。

由于这个操作是可逆的，所以所有的 $x=0$ 的方案就把所有合法方案分成了若干个方案组，而每个方案组中都有且仅有一个方案 $x=0$。

因为我们求出所有的 $(0,y,z)$ 便可通过 $(x,y-x,z-x)$ 得轻易得出该方案组所有方案，所以我们可以使用以下策略：

求出所有方案组中的组内最优解，然后再通过比较组内最优解得全局最优解。
# Step 1
先考虑如何找出所有方案组。

当然，我们没必要列举出所有方案组中的方案，这样会TLE+MLE。我们只需求出每个方案组中的代表 $(0,y,z)$ 即可。

那怎么求呢？

把 $a=0,b=y,c=z$ 代入 $7a+4b+3c=n$ 得：$4y+3z=n$

这个不就是二元一次不定方程吗？用扩展欧几里得即可。

不会也没关系，$n\le10^5$，枚举 $y$ 即可。
# Step 2
然后考虑如何求一个方案组中的最优解。

题目要求最优解满足三个条件：
1. $a+b+c=n$

2. 满足条件 1 的情况下，$\min(a,b,c)$ 最大。

3. 满足条件 2 的情况下，$a+b+c$ 最大。

条件一不用管，主要看条件二和条件三。

由于一个方案组中的方案均可表示为 $(x,y-x,z-x)$，而  $y,z\in\mathbb N$，所以 $x\le\min(y,z)$。

注意到一个性质：在一个方案组中，$a+b$ 和 $a+c$ 是恒等的且在当前方案组中其值分别为 $y$ 和 $z$，而 $\min(a,b,c)$ 又要最大，所以最好的情况是 $x$ 和 $\min(y-x,z-x)$ 尽量接近。而刚开始 $x=0$，所以要把 $\min(y,z)$ 均摊给 $x$。

但同时又要满足 $a+b+c$ 最大，而肯定是 $a$ 越小时方案更优，这样就有更多的钱去买别的。所以遇到 $\min(y,z)$ 为奇数我们就把它向下取整赋给 $x$。

所以最优解就是：
$$(\frac{\min(y,z)}{2},y-\frac{\min(y,z)}{2},z-\frac{\min(y,z)}{2})$$
# Step 3
求全局最优解就不用说了吧，先保存一份最优解，如果当前答案比之前的最优解更优就有当前答案更新它。

~~我考场上竟然又用 sort 求最优解。~~

总复杂度 $O(n)$，可以通过该题数据。


当然您也许看到了最小值的最大值，可以二分答案来吊打这篇题解。（我太蒻了没试过）
# 参考代码
```cpp
#include<bits/stdc++.h>
using namespace std;
#define MAXN 100011
int n,l,t,as,bs,cs,a,b,c;
inline int minn(int x,int y)
{
	return x<y?x:y;
}
int main()
{
	scanf("%d",&n);
	for(int i=0;4*i<=n;++i)//枚举y
		if((n-4*i)%3==0)//z是否为整数
		{
			a=minn(i,(n-4*i)/3)/2;
			b=i-minn(i,(n-4*i)/3)/2;
			c=(n-4*i)/3-minn(i,(n-4*i)/3)/2;
			if(minn(a,minn(b,c))==minn(as,minn(bs,cs))?a+b+c>as+bs+cs:minn(a,minn(b,c))>minn(as,minn(bs,cs)))//三目运算符……
			{
				as=a;
				bs=b;
				cs=c;
			}
			t=1;
		}
	if(!t)//判断有无解
		printf("-1");
	else
		printf("%d %d %d",as,bs,cs)
	return 0;
}//说句闲话：这不是我考场代码
```