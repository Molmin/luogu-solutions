考场上唯一能拿分的题就这么爆炸了

这道题就是按照三个条件的优先级不同，依次枚举来满足三个条件。我们依次来看：

1.n 元钱必须正好用光，即 $7a+4b+3c=n$

但是如果直接枚举这个条件的话枚举量过大，我们不如先看第二个条件：

2.在满足以上条件情况下，成套的数量尽可能大

这样我们就可以枚举一共选几套，然后看每种情况下能不能把钱全部花光。扣除成套购买所需的钱了之后，我们来看下一个条件：

3.在满足以上条件情况下，物品的总数尽可能大

显然，我们再枚举物品时就不能选7元的东西了，而是选3元和4元的，那么就枚举三元的物品买几件，看看剩下的钱能不能被4整除，从所有可行解中找最优的就可以

注意：枚举套数的时候要倒着枚举，因为如果较大的套数时出现了可行解，就不需要枚举更少的套数了，枚举3元物品的个数同理

还有，一定注意n是14的倍数的情况，以及n=0的情况！！！

时间复杂度：最坏$O(n^2)$

这是本蒟蒻的考场代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a=0,b=0,c=0,flag=0;//flag表示有无可行解 
int main(){
	//freopen("order.in","r",stdin);
	//freopen("order.out","w",stdout);
	cin>>n;
	if(n%14==0){//对n是14倍数的特判 
		cout<<n/14<<" "<<n/14<<" "<<n/14<<endl;
		return 0;
	}
	if(n<3){//也是特判一下 
		cout<<"-1"<<endl;
		return 0;
	}
	for(int i=n/14;i>=0;i--){//枚举套数 
		int maxsum=0;
		int cc=0,bb=0;
		int sum=0;
		int temp=n-14*i;
		for(int j=temp/3;j>=0;j--){//枚举3元物品的件数 
			if((temp-j*3)%4==0){
				flag=1;
				if(j+(temp-j*3)/4>sum){//如果有更优的解，更新答案 
					sum=j+(temp-j*3)/4;
					a=i;
					c=j+i;
					b=(temp-3*j)/4+i;
				}
			}
		}
		if(flag==1) break;//有可行解了，终止枚举 
	}
	if(!flag){
		cout<<"-1"<<endl;
		return 0;
	}
	else cout<<a<<" "<<b<<" "<<c<<endl;
	return 0;
}

```
