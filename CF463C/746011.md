## 前言（一些废话）
本蒟蒻的第一篇题解，我看其他题解讲的不是特别清楚（其实就是我太垃了看不懂），于是决定发一篇题解，供像我一样的蒟蒻食用。

[一个推销](https://www.luogu.com.cn/user/746011)
## 正文
[题目传送门](https://www.luogu.com.cn/problem/CF463C)

### 题目分析
首先，我们知道，国际象棋中两个象不能攻击到同一个格子的充要条件是两个象行列数相加的奇偶性不同，证明比较简单，我就不详细证明了。根据题目的意思，在两个象行列数相加的奇偶性确定后，它们就没有其他的约束条件，也就是不再影响了，所以很适合贪心算法。

接下来，我们要考虑如何在平方复杂度内计算每一个格子所在的两个斜行的分数总和。根据象的行走规则，象的行数加上一个数时，列数就要相应地加上或减去这个数。那么我们就可以推出，如果两个格子在同一斜行，它们的行列数相加或相减后的值是一样的。所以，我们可以开两个数组，一个记录行列数相加的值相等的格子的分数总和，另一个记录行列数相减的值相等的格子的分数总和。

最后，我们遍历数组，找出最大值即可。
### 代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
long long n, x, y, x2, y2, ans1, ans2, a[2005][2005], b[4005], c[4005];//b,c 数组要开两倍，不然会当场 RE
int main() {
    scanf("%lld", &n);
    for (int i = 1; i <= n; ++i)
        for (int j = 1; j <= n; ++j) scanf("%lld", &a[i][j]);
    for (int i = 1; i <= n; ++i) {
        for (int j = 1; j <= n; ++j) {
            b[i + j - 1] += a[i][j];
            c[n + j - i] += a[i][j];//加 n 防越界
        }
    }
    for (int i = 1; i <= n; ++i) {
        for (int j = 1; j <= n; ++j) {
            if ((i + j) % 2) {
                if (b[i + j - 1] + c[n + j - i] - a[i][j] >= ans1) {
                    ans1 = b[i + j - 1] + c[n + j - i] - a[i][j];
                    x = i;
                    y = j;
                }
            } else {
                if (b[i + j - 1] + c[n + j - i] - a[i][j] >= ans2) {
                    ans2 = b[i + j - 1] + c[n + j - i] - a[i][j];
                    x2 = i;
                    y2 = j;
                }
            }
        }
    }
    printf("%lld\n%lld %lld %lld %lld", ans1 + ans2, x2, y2, x, y);
    return 0;
}
```
### 注意事项
1. 一定要开 long long，我没开当场暴毙。
2. 在更新答案时判断条件要用大于等于，不然会被出题人用全 0 数据 hack 掉。（别问我怎么知道的）
3. 在计算得分时，要把该格子的分减掉，因为它加了两次。
4. ~~珍爱账号，远离棕名~~。

## 后记（还是废话）
第一次写题解，没啥经验，有什么问题大家多多指出，本蒟蒻会努力改正的。