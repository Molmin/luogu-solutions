[原题链接](https://www.luogu.com.cn/problem/P1790)

我是参照第一篇题解的思路写的，大家可以这篇文章当成第一篇题解的一个参考。

# 为什么是暴搜

显然，当我们看到 $1 \leq a,b \leq 6$ 的时候，差不多就能确定这是一个非常暴力的算法。并且基本上什么复杂度都能过，如 $O(n^n)$ ， $O(n!)$ 等等。而像暴搜这种不稳定的算法也可以轻松过掉。并且再加上对方格的处理，暴搜肯定是最好想，最好写的算法。

# 处理想法

我们不难发现如果处理格子的话，很难设计搜索的边界条件。若把找到答案的条件设为`if(x==1||x==n||y==1||y==m)`，那么我们就无法找出单列或单行的格子因为进去后就会直接返回。

例：

[![RCHKgA.png](https://z3.ax1x.com/2021/06/19/RCHKgA.png)](https://imgtu.com/i/RCHKgA)

如图，我们就不可能分到这个图形，因为如果我们从 $(1,1)$ 开始搜，那么我们会直接返回。

所以该怎样处理呢？很简单，我们只需转化一下，不是格子图不好做吗？转化成点图。也就是说把上面那个例子变成这样：

[![RCXCmn.png](https://z3.ax1x.com/2021/06/19/RCXCmn.png)](https://imgtu.com/i/RCXCmn)

然后来考虑一下怎样来满足这个条件：
>每个部分至少各自均有一个方格是在大矩形的最外边上。

这句话更直接的意思是：让你找出一个子矩形，使这个子矩形至少有一个顶点在大矩形的四条边上。

这时我们就可以巧妙运用我们的点图。如何确定一个矩形？只需要知道它对角线的两个端点就可以了。所以我们可以把一个符合要求的矩形看成从大矩形内部的一个点指向其边缘的一个点就可以了。所以我们最开始的那个例子就可以变成这样：

[![RP96IA.png](https://z3.ax1x.com/2021/06/19/RP96IA.png)](https://imgtu.com/i/RP96IA)

如果没懂的话可以再看一个例子：

这个矩形

[![RPCuod.png](https://z3.ax1x.com/2021/06/19/RPCuod.png)](https://imgtu.com/i/RPCuod)

可以变成这个样子

[![RPCHmD.png](https://z3.ax1x.com/2021/06/19/RPCHmD.png)](https://imgtu.com/i/RPCHmD)

所以此时我们就可以看成从一个点深搜直到边缘，然后添加答案，返回的的过程。

但是这仅仅是主题思路，还有许多分割与判重的细节需要注意，大家可以参照第一篇题解。

代码就不放了，大家可以想清楚后尝试写一写。