注：blog观看效果更佳

# ~~打表是数学。~~

我看了一下数据范围，据说这数据很弱，$1\leq a \leq 6 , 2\leq b \leq 6$。

这种数据，用用打表应该是个不错的选择。

关键在于，打表的时间复杂度是$O(1)$(常数级别）哇！！！

下面先附上打表的代码：

```cpp
#include<iostream>
using namespace std;

int n,m;
int a[]=
{1,2,3,4,5,6,15,28,45,66,15,52,143,350,799,28,143,614,2431,9184,45,350,2431,16000,102147,66,799,9184,102147,1114394}; //数全是自己算的

int main(){
	cin>>n>>m;
	cout<<a[(n-1)*5+(m-2)];
	return 0;
}
```

------------

下面切入正题：如何用DFS求解呢？？？

不要着急，咱慢慢来。

这个数据很小，首先想到的是最暴力的搜索：直接将所有的格子的状态进行枚举。但是仔细一算就不难发现，这样运算次数达到了$2^{36}$次，一般$10^8$就危险了，那么前面这种算法就不可能能用了。

其次就是要分析了。根据题目，要分割，实际上就是求矩形中有效的分割线。首先想到，能否偷个懒，找找计算公式？可是，似乎并没有。

那该怎么办呢？？？

现在就来讲讲：用DFS求解！！！

------------

既然要用DFS，不妨先搞清楚要干什么。显然，要找分割线。分割线必须以格点出发，再以另一个格点结尾。如此，DFS的思路应该已经有一些了。

当然，应该注意以下情况：如果出现分割在$(2,1)$与$(2,2)$之间，那么，我们必须手动预防这种情况的发生。

那么，究竟该怎么预防呢？

对此，我们有以下策略：

1. 提前把“危险的”那个坐标设为$1$，即禁止访问；
2. 在搜索时跳过这一格，直接搜索下面一个。

------------

现在，来理理思路：

1. 输入；
2. 清零（如果是全局变量，则不用清零）
3. 对行进行搜索（即从$(i,2)$开始搜索，先把“危险坐标”$(i,1)$设为$1$;
4. 对列的处理与行相同；
5. 完美的输出！！！

好了，说了好多，上代码最要紧。代码有详细解释，大家可以看看。注：代码可以直接复制并AC，但是骗分过样例提醒您：非紧急情况尽量不要使用！

```cpp
#include<iostream>
using namespace std;

int ans; //统计个数 
int n,m; //行、列 
int vis[20][20]; //访问数组 

const int dx[4]={0,1,0,-1}; 
const int dy[4]={1,0,-1,0}; 

void dfs(int x,int y){ //搜索函数 
	vis[x][y]=1; //先标记1 
	if(x==1||y==1||x==n||y==m){ //判断是否成功 
		ans++;
		vis[x][y]=0;
		return; //回溯并返回 
	}
	for(int i=0;i<4;i++){
		int nx=x+dx[i];
		int ny=y+dy[i];
		if(nx>=1&&nx<=n&&ny>=1&&ny<=m&&!vis[nx][ny]){ //边界条件判断 
			dfs(nx,ny);
		}
	}
	vis[x][y]=0; //回溯、返回 
	return;
}

int main(){
	cin>>n>>m; //输入 
	n++,m++; //行、列加1，因为共有(n+1)*(m+1)个点 
	for(int i=2;i<n;i++){ //循环 
		vis[i][1]=1; //为了预防上述情况，即出现无效分割，做如下处理 
		dfs(i,2); //搜索！！！ 
		vis[i][1]=0;
	}
	for(int i=2;i<m;i++){ //操作同上 
		vis[1][i]=1;
		dfs(2,i);
		vis[1][i]=0;
	}
	cout<<ans; //输出！！！ 
	return 0; //完美的结束！！！ 
}
```