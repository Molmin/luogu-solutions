这里是 0-1 Trie 官方题解。

这是一个没有 OI 思维的菜鸡的思路，您可能感觉他吃多了，希望轻喷 qwq。

个人感觉这个题的感觉需要一些画图理解，由于电脑上不好施展，这个艰巨的任务就得由各位做题的巨佬来实现了。   

我感觉这个做法更好：[神仙 @SOSCHINA 的题解](https://www.luogu.com.cn/paste/oxt9jmql)。

还有一种做法：[神仙 zmx_wzx_JY 的题解](https://www.luogu.com.cn/paste/kii3datm)

#### 为了方便，我们记有 $n$ 个 $\mathbf{1}$ 和 $n+m$ $\mathbf{0}$ 且认为两者同阶。

### **Step 1** 寻找合理的转化  

首先直接枚举是不行的，大概有 $10$ 分的样子，而且挺难写的。

我们可以理解成从有唯一构造方案的 $m=0$ 开始， $m$ 的增加代表着对每一种情况插入 $0$，那么，插入的 $0$ 的数量增加 $1$ ，树的节点数的增量 $\Delta$ 是如何变化的呢?    

可以发现 $\Delta$ 可以形式地表示为： 

$$(\sum x_i)+y-z$$  

这是什么玩意？我们慢慢来讲。   

容易发现一个性质，在 Trie 树上插入 $0$ 的时候，我们假设钦定在 $a-b$ 之间建设插入点，这个插入点如果合法，那他下边一定没有分支。  

这时候我们想到记录每一个和向下与 $1$ 接壤的 $0$ 节点 $i$ 的下面还有 $x_i$ 个节点，那么在这个位置插入得到的增量是 $x_i+1$。  

怎么理解呢？我们可以理解成在这个位置先复制一条链，递归地向下插入，然后同时在他下面建一条新链，同时在他和它下面的 $1$ 中间插入一个 $0$，一次增量是 $x_i+1$。  

但是有一个特殊点，就是处于末位位置的插入点，这时候不需要再递归下去了，而且他下面只有一个节点 $1$，于是，需要减掉。  

那么 $\Delta=(\sum x_i)+y-z$ 的含义也就十分明了了， $\sum x_i$ 不必多说，$y$ 代表插入可行的位置数， $z$ 代表叶节点的个数。

### **Step 2** 将增量数字化  

由于前面提到的性质：  

> 在 Trie 树上插入 $0$ 的时候，我们假设钦定在 $0-1$ 之间建设插入点，这个插入点如果合法，那他下边一定没有分支。  

我们其实容易归纳得到推论：  

> 对于一条链，如果他有 $y$ 个可以插入的点，那么这条链上的 $\sum x_i=y^2$（实质上是对 $2i-1$ 求和）。   

这是一个关键点，现在，我们只需要解决每一条链上有多少可以插入的点。  

我们模拟一下插入的过程，会发现一个比较显然的性质：  

> 对于一条有 $y$ 个插入点的链，插入后形成 $y$ 条新链，可插入的点分别为 $1,2......y$。   

其实我们可以看做是一个长为 $n$ 的数组 $a_i$，开始只有 $a_n=1$，每次插入操作等同于将每个数组加上下标大于它的数组的和，再进行计算。

有经验的巨佬一定知道这是一个经典的组合数学的问题，具体的式子我们一会再讨论。  

$z$ 的求法比较显然，其实就是问有多少种构造方案，是一个插板法的问题。  

容易发现，$m$ 次插入操作，减去的 $z$ 的和为：  

$$\sum_{i=0}^{m-1}\dbinom{n+i-1}{n-1}=\dbinom{n+m-1}{n}$$    

同样我们将 $(\sum x_i)+y$ 的和表示一下：  

我们为了方便，将第二次插入操作编号为 $0$，然后加上第一次操作的增量。  
$$\sum\left((\sum x_i)+y\right)=\sum_{i=0}^{m-2}\sum_{j=1}^n (j^2+j)\dbinom{n-j+i}{i}+n^2+n$$

到了这里，我们直接依式子模拟即可，时间复杂度 $\mathcal O(Tn^2)$，期望得分 $30$ 分。

ps：这三个性质的寻找大概是本题最难的地方了，我发现神仙 fyy 给出了一种很神仙的 dp（虽然暂时拿不到满分），貌似避过了这个阴间的问题，我似乎感觉我又做麻烦了。

ps：fyy 神仙已经用另类的方式（不过貌似我的方法更另类）推出并通过了此题，我只能膜拜 Orz。

ps：这个 dp 可能挺套路的，不过我做题比较少，没有想到，似乎把这道题质量给拉下来了？

### **Step 3** 推式子  

我们对 $\sum\left((\sum x_i)+y\right)$ 中比较繁琐的那一部分进行化简，首先交换求和符号：  

$$\sum_{j=1}^n(j^2+j)\sum_{i=0}^{m-2}\dbinom{n-j+i}{n-j}$$  

运用一下经典的组合求和恒等式：  

$$\sum_{j=1}^n(j^2+j)\dbinom{n+m-j-1}{n-j+1}$$   

以上的推导十分 naive，且比较套路，但是我们可以做到 $\mathcal O(Tn)$，期望得分 $60$ 分。

我们考虑一下：$j^2+j=2\dbinom{j+1}{2}$，于是：  

$$2\sum_{j=1}^n \dbinom{j+1}{2}\dbinom{n+m-j-1}{m-2}$$


这像极了范德蒙德卷积: 

$$\dbinom{n+m}{k}=\sum_{i=0}^k\dbinom{n}{i}\dbinom{m}{k-i}$$  

我们从组合意义上理解应该颇为简单，同理我们在组合意义上来说：  

$$\dbinom{k+1}{n+m+1}=\sum_{i\ge n\&k-i\ge m}\dbinom{i}n{}\dbinom{k-i}{m}$$  

因此，我们对答案进行化简，一定要注意枚举的范围：  

$$\text{原式}=2\left(\dbinom{n+m+1}{m+1}-\dbinom{n+2}{2}\dbinom{m-2}{m-2}\right)$$  

我们展开一下，并加上第一轮的增量，得到的式子为：  

$$2\dbinom{n+m+1}{n}-2n-2$$   

我们将 $\sum z$ 减去，然后别忘了初始的大小为 $2n$，得到答案：  

$$2\dbinom{n+m+1}{n}-\dbinom{n+m-1}{n}-2$$  

### **Step 4** 代码实现   

这个模数比较小，只有不到 $2e7$，我们线性处理逆元和阶乘，组合数的计算直接 Lucas 即可，这个地方的组合数计算不会超过 $3$ 次，几乎可以认为是线性。

当然我们要注意**在本题题意中**若 $n>m$ 无解则需要特判。

复杂度是 $\mathcal O(18888913+T\log n)$，注意一下常数即可获得 $100$ 分。

由于进行了一定程度上的卡常，导致 std 比较难看...

```cpp
#include"iostream"
#include"cstdio"
using namespace std;

#define ll long long
#define MOD 18888913
#define MAXN 19000005
#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)

int t,rt=0;
ll n,m;
int fac[MAXN],inv[MAXN];
char buf[1<<21],*p1=buf,*p2=buf;

inline ll read()
{
	ll x=0;
	char c=getchar();
	while(c<'0'||c>'9') c=getchar();
	while(c<='9'&&c>='0') x=(x<<1)+(x<<3)+c-'0',c=getchar();
	return x;
}

inline int Lucas(ll n,ll m)
{
	int ans=1;
	for(register int x,y;m&&ans;)
	{
		x=n%MOD,y=m%MOD;
		ans=x<y?0:1ll*ans*fac[x]%MOD*inv[fac[y]]%MOD*inv[fac[x-y]]%MOD;
		n/=MOD,m/=MOD;
	}
	return ans%MOD;
}

int main()
{
	inv[1]=1,fac[0]=fac[1]=1;
	for(register int i=2;i<MOD;i++) inv[i]=1ll*(MOD-MOD/i)*inv[MOD%i]%MOD,fac[i]=1ll*fac[i-1]*i%MOD;
	scanf("%d",&t);
	for(register int i=1;i<=t;i++)
	{
		n=read(),m=read();
		if(n>m) continue;
		rt^=((Lucas(m+1ll,n)*2-Lucas(m-1ll,n)-2+MOD+MOD)%MOD); 
	}
	printf("%d\n",rt);
	return 0;
}
```

------------

### **extra** 一些彩蛋

我作为一不务正业的 whk 人，学考的考场上匆忙做完题，来推这个题，大概是一场物理和一场政治的功夫，我得到了这道题的 $\mathcal O(Tn)$ 的做法，那天回家大概是给了一种错误的  $\mathcal O(T\log n)$ 的解法，晚上随便举了个例子就错了。

当时因为乱套范德蒙德卷积，第二天发现类比的方法时大概激动得不行，所以就翘了几节网课把这道题贡献了一下。

对，那几个性质我也不知道我怎么发现的，就感觉十分神奇，果然，这并不是唯一的突破方式。