这道题一看，就知道是一道数学题，找规律，推公式。

我们从n=1开始（后面写的是一种分的方式）：

n  ans

1   1 ：1

2   2 ：1 1

3   2： 1 2 

4   3： 1 2 1

5   3： 1 2 2

6   3： 1 2 3

7   3： 1 2 4

8   4： 1 2 4 1

9   5： 1 2 4 2
      
10  4： 1 2 4 3

11  4： 1 2 4 4

12  4： 1 2 4 5

13  4： 1 2 4 6

14  4： 1 2 4 7

15  4： 1 2 4 8

16  5： 1 2 4 9

......

我们可以明显看出：

答案为1有有1个

答案为2的有2个

答案为3的有4个

答案为4的有8个

这1 2 4 8......不是等比数列嘛，于是我调用了一下马上快忘记的等比数列前k项和公式：Sn=a1×(1-q^k)/(1-q)，然后带入这里的a1=1，q=2，得到：Sn=2^k-1（注意这里的Sn是题目中的n）。因为maxn=1e9，所以解一下不等式2^k-1<=1e9，大概k的枚举范围就是1~31。因为有很多的n对应的答案可能都是同一个ans，所以我们需要判断一下：if(pow(2,k-1)-1<=n&&pow(2,k)-1>n)，就说明n的答案在k-1~k之间，所以ans=k。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=31;i++)
	{
		if(pow(2,i-1)<=n&&pow(2,i)>n)
		{
			printf("%d",i);
			return 0;
		}
	}
}
```

接着，我们可以发现，我们根本不用枚举一遍来一个一个检查，我们可以直接一个算是解决：ans=log2(n)+1。~~（不要问为什么，我也不知道，反正推出来的数据满足这个式子qwq）~~

于是一篇跟a+b problem 一样长的代码就出来啦：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
int main()
{
	scanf("%d",&n);
	printf("%d",(int)log2(n)+1);
	return 0;
}
```
~~（其实可以再短一点）~~