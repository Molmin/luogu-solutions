### 题意简述

给定一个长度为 $n$ 的无重复数字序列，其逆序对个数为 $t$。求出：

（1）有多少个序列满足条件；

（2）若序列是 $1\sim n$ 的全排列，请输出满足条件的字典序最小的序列。

### 题目分析

#### 第一问：DP

我们设数组 $dp_{i, j}$ 代表考虑了前 $i$ 个数，有 $j$ 个逆序对的满足条件的序列总数。

由于只有一个数时无法构成逆序对，所以 $dp_{1,0}=1$。

设我们在一个原来长度为 $n$ 的序列中在最后插入一个数，那么就可以多形成 $0\sim n$ 个逆序对（原因显而易见，当插入的是序列中最小值时可以和前面任何一个数形成逆序对，是最大值时无法形成任何逆序对）。

那么，当我们已经考虑了前 $i$ 个数，逆序对的个数为 $j$ 时，如果去除最后一个数，序列可能减少的逆序对个数就为 $0\sim j-i$。我们只需要把这一部分内的 $dp$ 数组的值加起来就可以了。

所以，这道题的状态转移方程就是：

$$dp_{i,j}=\sum_{k=0}^{k<i, k\le j}dp_{i-1, j-k}$$

显而易见地，最终答案即为 $dp_{n,t}$。

#### 第二问：贪心

由于我们要输出字典序最小的那一个序列，所以我们初始就要让序列的字典序尽量小。在 $1\sim n$ 的全排列中，字典序最小的那一个就是 $1,2,3,\cdots,n$，此时逆序对的数量为 $0$。将其设为初始的序列。

为了构造出 $t$ 个逆序对，我们可以从后往前遍历序列，找到第一个比当前数小的数就交换，这样每次只会增加一个逆序对。由于是从后往前遍历，可以保证字典序最小。当逆序对的数量到达 $t$ 的时候立即停止遍历，输出此时序列即可。

注意：答案可能会超出 `int` 范围，且 $t=0$ 时需要特判（此时无逆序对，仅有一种情况，即为 $1,2,3,\cdots,n$）。

### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAXN = 205; 
long long n, t, a[MAXN], cnt = 0, dp[MAXN][MAXN];
int main(){
	scanf("%lld%lld", &n, &t);
	if(t == 0){ // 特判 t = 0 情况
		printf("1\n");
		for(int i = 1;i <= n;i++){
			printf("%d ", i);
		}
		return 0;
	}
    // 第一问
	dp[1][0] = 1; // 设置边界条件
	for(int i = 2;i <= n;i++){ // 开始 DP
		for(int j = 0;j <= i * (i - 1) / 2;j++){
			for(int k = 0;k < i && k <= j;k++){
				dp[i][j] += dp[i - 1][j - k]; 
			}
		}
	}
	printf("%lld\n", dp[n][t]);
	// 第二问，cnt 代表已构造出的逆序对个数
	for(int i = 1;i <= n;i++){ // 初始序列即为 1~n
		a[i] = i;
	}
	for(int i = n - 1;i >= 1;i--){
		for(int j = n;j > i;j--){
			cnt++;
			swap(a[i], a[j]);
			if(cnt == t){
				for(int i = 1;i <= n;i++){
					printf("%lld ", a[i]);
				}
				return 0;
			}
		}
	}
	return 0;
}
```