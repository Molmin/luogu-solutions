[题目传送门](https://www.luogu.com.cn/problem/P4452)

吐槽：为什么写题的人这么少呢？

### 1.算法
- 图论

飞机飞来飞去，又有边权（时间&费用），那就是图论了 ~~（雾）~~

- 网络流VS最长路

每个收益之间有限制，还有只收益1次的限制，以及时间的限制，还要收入支出，约束条件多，用网络流肯定是得心应手

- 最小费用最大流

看到最大收益就是费用流没跑了吧

补充：

在这里其实是求最大费用，但是SPFA可以处理负边权，所以就把花费变成其相反数，然后跑最短路，花费再取负；或者直接把SPFA改成最长路
### 2.建图
**毒瘤网络流，建模最毒瘤**

- 建模对象：点或请求

如果按照点来建边，需要按时间分层，然后一同乱搞，会显得比较复杂

选择请求来建边，则只需要关注请求与请求之间的关系，时间一维可以处理掉，显得更简单了，那对象就是它了

- 源点

先判断从0可不可以直达请求的起点，然后建边，流量$inf$，费用$f[0][a]$

但是我们又关注到$k$架飞机这个条件，不知道$k$会去那条路，所以就再建一个真正的源点，向先前的源点（表示基地）建一条流量$k$，费用0的边

- 汇点

判断请求结束后能不能在规定时间内到达基地点0，然后建边，流量$inf$，费用$f[b][0]$

- 请求之间的转移

根据贪心，能够不回基地，就不要回去，所以我们要考虑请求之间的转移

那么怎么转移呢？

其实只要$m^2$枚举每个请求之间能不能满足 前一个结束后有时间到达后一个的开始时间 即可

然后就连边 流量$inf$，边权$f[b_i][a_j]$

这里要注意的是，很多题解（目前为止）都没有说明的是：

$$
t_{ij} <=t_{ik} +t _ {kj} 
$$
$$
f_{ij} <=f_{ik} +f _ {kj}
$$

也就是说，数据范围里面保证了最短路

我觉得说还是提示一下比较好，~~主要是我太菜了~~

如果没有保证，那就要手动跑最短路了

- 控制请求的**净收益**

其实就是每个请求只有1次贡献

这个如果在座的大佬题目写多了，就会发现这是套路来着的

给个[套路题](https://www.luogu.com.cn/problem/P4013)

其实就是拆点，把一个请求拆成入点和出点，然后连一条  流量1，费用$c$ 的边，就可以解决问题

如果两个请求之间可转移，那么就从出点连向入点

**完结撒花**

### 3.代码
这里只给出建图代码，跑最小费用最大流模板就不要影响~~美观度~~了

一些不成大问题的就在注释里说了

```cpp
void add(int u,int v,int w,int f){add_edge(u,v,w,f),add_edge(v,u,0,-f);} \\懒人反向边建图，add_edge就是邻接表建边了，大家都懂吧

struct pp{
	int a,b,c,s,t;
}q[maxn];
int time[maxn][maxn],f[maxn][maxn];
int main()
{
   	scanf("%d%d%d%d",&n,&m,&k,&T);
   	s=0,t=2*m+2;\\s是真源点，假源点是t-1
   	for(int i=1;i<=n;i++)
   		for(int j=1;j<=n;j++)
   			scanf("%d",&time[i][j]);
   	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
			scanf("%d",&f[i][j]);
	for(int i=1;i<=m;i++) scanf("%d%d%d%d%d",&q[i].a,&q[i].b,&q[i].s,&q[i].t,&q[i].c),q[i].a++,q[i].b++;\\读入点从1开始，所以++
	for(int i=1;i<=m;i++) 
	{
		add(i,i+m,1,-q[i].c);\\反向边代码在上面哦
		if(q[i].t+time[q[i].b][1]<=T) add(i+m,t,inf,f[q[i].b][1]);
		else continue;\\都不能回家怎么还能转移呢
		if(q[i].s>=time[1][q[i].a]) add(t-1,i,inf,f[1][q[i].a]);
		for(int j=1;j<=m;j++)
			if(q[i].t+time[q[i].b][q[j].a]<=q[j].s)
				add(i+m,j,inf,f[q[i].b][q[j].a]),add(i,j,inf,f[q[i].b][q[j].a]);\\这里多建了一条入点到入点的边，不加也没有问题的
	}
	add(s,t-1,k,0);\\控制k架飞机
	Dinic();\\跑最小费用最大流
	printf("%d",-cost);\\因为是边权全部取反，所以答案也要取反
    return 0;
 } 
```