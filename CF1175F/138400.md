泻药，提供一个不需要哈希且思路容易理解且复杂度线性的做法。

容易得到一个区间是子排列的充要条件：

1. 区间内元素互不相同；
1. 最大值为 $r-l+1$。

观察到第一个，显然是满足各种单调性的，即对于一个左 / 右端点，合法的右 / 左端点是前 / 后缀；并且对于左 / 右端点们，它所对应的最远右 / 左端点是单调的。于是我们可以枚举右端点，two-pointers 求最小左端点。

然后考虑第二个条件，我们可以维护每个位置的最大值，恰好套用这个扫描线的套路。直接在线段树上维护感觉不太行（分块可以考虑考虑），我们发现最大值显然也是单调的，单调栈轻松维护。但是对于每个右端点单调栈中每个区间的贡献方式又是会变的，要是每次都扫一遍单调栈显然会炸。我们可以考虑这样一个思路：对于每个区间记录它被加入的时间戳，然后被弹出的时候就总结一下它的一生，显然可以常数。

复杂度显然线性。

以上。