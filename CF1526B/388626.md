--->[传送门](https://www.luogu.com.cn/problem/CF1526B)

### 前言
今天确实有点闲的没事干，随便跳了一道题过来的

### 题目大意
~~翻译挺明白的了~~

问给你一数 $x(1≤x≤10^9)$ ，能否用 11,111,1111…… 这些数表示出来

### 思路

**注意这个思路是假的**:

刚开始看的时候感觉这不就是个暴力嘛，因为 $x$ 最大是 $10^9$ 所以只需要 11~11111111 这些数来表示就行。然后再贪个心，把 $x$ 从最大数11111111开始减，直到减不动为止，看最后 $x$ 是否变成了 0 。

事实证明，[Too young too simple](https://www.luogu.com.cn/record/51574054)

**这个思路只是真的**:

首先我们考虑对 11~11111111 进行质因数分解，可以得到：

$11$->$11$

$111$->$111$

$1111$->$11\times100+11$

$11111$->$11\times1000+111$

$111111$->$1111\times100+11$->$11\times1000+1111$

…………

根据上面的柿子，我们能够发现，对于各位数全是 1 的 $n$ ($n$>3)位数，都能表示为 $11\times10^{n-2}+$ 各位全是 1 的 $n-2$ 位数
，而又因为 $n>3$ ，所以各位全是 1 的 $n-2$ 位数
又可以表示为 $11\times10^{n-4}+$各位全是 1 的 $n-4$ 位数
，由此循环下去，最终你会发现，只要是 $n>3$ 的各位全是 1 的一个数，都能被表示为:

$11\times x+111\times y$

111 又可以表示为 $11\times10+1$

原式就可以表示为 $11\times(x+10y)+y$，然后对其进行%11操作，发现余数为 $y$ 说明询问的数对 $11$ 进行取模后，必须保证有 $y$ 个 111，所以我们只需要判断该数对 11 进行取模后的余数乘上 $y$ 是否小于等于该数就可以了
### 代码

灰常简单qwq

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ri register
inline int read()
{
	int x=0,f=1;
	char ch=getchar();
	while(ch>'9'||ch<'0')
	{
		if(ch=='-')
		{
			f=-1;
		}
		ch=getchar();
	}
	while(ch>='0'&&ch<='9')
	{
		x=(x<<3)+(x<<1)+(ch^48);
		ch=getchar();
	}
	return x*f;
}
int main()
{
	int n;
	n=read();
	while(n--)
	{
		int x;
		x=read();
        //取模&乘111
		int temp=x%11;
		temp*=111;
        //和原数比大小
		temp<=x?cout<<"YES"<<endl:cout<<"NO"<<endl;
	}
	return 0;
}
```
