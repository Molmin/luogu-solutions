蒟蒻的第一篇博客隆重登场……然而并不隆重，依旧是老样子的水一篇题解，还是一道比较简单的红题，日常练手（划掉)。


---------------超级可爱的分割线------------------

**首先进行简单的分析我们需要干些什么，就是根据每一次对于打卡状态进行分析，统计，根据题目的要求进行计算，刷新答案，最后输出就可以了。**


如果是打了卡，也就是输入“1”的时候，我们需要做的就是更新两个天数以及答案。

连续天数的更新：

**1、判断有没有连续不打卡的天数，然后用现有的天数减去pow（2，不打卡天数-1），如果天数小于0了，变为0**

**2、把天数+1**


答案的更新：

**加上连续天数对应的奖励活跃就可以了

这里有一个小小的偷懒秘籍：为了不写那么多的if语句，可以先开一个b数组存放当连续i天打卡奖励的活跃b[i]**

下面是这个偷懒的神奇代码

```cpp
for(int i = 1;i<=2;i++)b[i] = 1;
    for(int i = 3;i<=6;i++)b[i] = 2;
    for(int i = 7;i<=29;i++)b[i] = 3;
    for(int i = 30;i<=119;i++)b[i] = 4;
    for(int i = 120;i<=364;i++)b[i] = 5;
    for(int i = 365;i<=1000;i++)b[i] = 6;
```
介于天数n很小只有1000所以我们可以开足够达到数组打表


不打卡天数的更新：

**变成0**


如果没有打卡，也就是输入“0”的时候……

**把不打卡天数+1**


######以上就是所以的思路啦

-------------------------------------


接着放代码

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cmath>
using namespace std;
int a[1001];
int lx = 0;
int yl = 0;
int ans = 0;
int b[1001];
int main(){
    int n;
    for(int i = 1;i<=2;i++)b[i] = 1;
    for(int i = 3;i<=6;i++)b[i] = 2;
    for(int i = 7;i<=29;i++)b[i] = 3;
    for(int i = 30;i<=119;i++)b[i] = 4;
    for(int i = 120;i<=364;i++)b[i] = 5;
    for(int i = 365;i<=1000;i++)b[i] = 6;
    scanf("%d",&n);
    for(int i = 1;i<=n;i++){
        scanf("%d",&a[i]);
        if(a[i] == 1){
            if(yl != 0){
            lx -= pow(2,yl-1); 
            if(lx < 0) lx = 0;
            yl = 0;
        }
            lx += 1;
            ans += b[lx];
        //    printf("%d %d %d\n",lx,b[lx],ans);
        }
        else {
            yl ++;
        }
    }
    printf("%d",ans);
    return 0;
}
```
注释就不写啦，毕竟代码比较简单
