[博客食用更佳](https://www.luogu.com.cn/blog/Jiangyuchen-2010/solution-cf681c)

## Part 0: 前置芝士 
关于 C++ 的小根堆，简单说一下基本使用方法：

```cpp
priority_queue <int, vector<int>, greater<int> > q;// 定义int类型的小根堆

q.push(x) 	// 插入一个数

q.pop()		// 弹出优先级最高（最小）的数

q.size()	// 返回容器内元素个数

q.top()		// 返回优先级最高（最小）的数

q.empty()	// 返回优先队列（堆）是否为空
```


------------
## Part 1: 阅读与理解

简要题意：让你修正关于小根堆的指令集。  

修改方法见下文。

------------
## Part 2: 分析与解答

三种指令的修正方式：   

```insert x``` 操作不会出现错误，放心加入元素即可。
 
```getMin x``` 操作有两种错误类型：  
1. 优先队列队首**大于** $x$ 或队列为空：在当前指令前先将 $x$ 加入队列。
1. 优先队列队首**小于** $x$：弹出队首直到队首等于 $x$（正确）或小于 $x$（转换为错误情况 1）。

```removeMin``` 操作有一种错误类型：
1. 优先队列中没有任何元素：先往队列中加入**任意一个元素**，然后再执行操作。



------------


我第开始想用结构体（字符串 + 整型）来存储每条指令，思路上没什么问题：

 _代码-0x01（代码在文末）_ 

注意事项：           
1. 建议把每项操作写进函数，使代码更加简洁；
2. **在使用函数 ```pop()``` 和 ```top()``` 的时候，一定要先判断是否为空（```empty()```）！不然会 RE！**

但是当我写完代码提交时，发现有 2 个点 TLE 了！

~~经调查~~，我发现代码慢在储存 ```string``` 类型。

优化：把结构体（字符串 + 整型）改成（整型 + 整型），最后在输出的时候处理下就好了。

 _代码-0x02_ 
 
这样就通过了。

------------
## Part 3: 回顾与反思

本题难点：
1. 码量较大，需要仔细调试。
2. 数据范围较大，需要一些小优化。

本题还是很适合用作复习堆。

# [代码！](https://www.luogu.com.cn/paste/8bsj2p7k)

有问题或建议可在评论区指出，蒟蒻会随时改进的。

Ps：这是蒟蒻的第 3 篇题解。