# CF1678B2 Tokitsukaze and Good 01-String 


## 题意简述：

给定一个 $01$ 串，问其最少修改几次可以合法。合法的定义为：

如果将该串按最长的连续的 $0/1$ 分段，每段的长为偶数，那么该串合法。如 $11001111$ 就是一个合法的 $0/1$ 串，可以分为 $11$，$00$，$1111$ 这三段。每段的长度均为偶数。

在最少操作次数的前提下，还要输出修改使其合法后的最少的段数。

## 题目分析：
### 第一问：

可以发现如果每一段的长度都是偶数，那么该 $0/1$ 串可以收缩为长度为 $\frac{n}{2}$、每段长为原来 $\frac{1}{2}$ 的一个串。也就是说：相邻的 $s_{2k}$ 和 $s_{2k+1}$ 可以合为一个。

由此可以发现：如果 $s_{2k} \not = s_{2k+1}$，我们就需要一次操作去更改 $s_{2k}$ 或 $s_{2k+1}$ 使得其相等，并让 $ans$ 加一。

### 第二问：

在第一问的前提下可以看出：$s_{2k}$ 和 $s_{2k+1}$ 有两种情况：

- 情况一：$s_{2k} = s_{2k+1}$。

  这对数就不应浪费操作次数去修改，从而数值不变。

- 情况二：$s_{2k} \not = s_{2k+1}$。

  这对数对 $ans$ 有贡献，数值却是不定的，从而 $s_{2k}$ 和 $s_{2k+1}$ 也就可以依附于左边或右边像第一种情况那样的“对”，因此第二种情况可以忽略不看。

所以我们只需统计第一种情况 $0/1/0/1 \cdots$ 变换了多少次（在忽略第二种情况后，如果相邻两（多）**对** 颜色相同，应只算一次），作为第二问的答案。

要注意的是：如果所有的“对”都是第二种情况，就没有第一种情况的“对”让其依附，这时按照上述方法第二问答案为 $0$，这时就要特判第二问答案为 $1$。


## 参考代码：

```c++
#include<bits/stdc++.h>
using namespace std;
const int maxn=2e5+10;
int t,n,ans,a[maxn],la;
string s;
void init()
{
    cin>>n>>s;
}
void work()
{
    for(int i=0;i+1<n;i+=2)
    {
        if(s[i]!=s[i+1]) ans++;//第一问
    }
    for(int i=0;i+1<n;i+=2)
    {
        if(s[i]==s[i+1])//第二问 第一种情况
        {
            if(la==0 || a[la]!=s[i]-'0') //颜色一样只算一次
                a[++la]=s[i]-'0';
        }
    }
}
int main()
{
    cin>>t;
    while(t--)
    {
        la=ans=0;
        init();
        work();
        cout<<ans<<" "<<max(la,1)<<endl;//第二问特判
    }
    return 0;
}
```

