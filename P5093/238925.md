这是一道**贪心**的题目。

问题是要求最短的不出现序列的长度。但是看着感觉很麻烦，无从下手。

因此，我们将问题转化一下，可以先求出最长的在序列中出现过的长度，只要将长度$+1$输出，这样问题就迎刃可解了。

思路：我们将输入的序列分为若干段，每一段都要包含$1$到$k$中的数，记录最多可分为的段数,同样$+1$就可以了。

证明：大家知道这是为什么吗?因为如果每一段都含有$1$到$k$中的数，这样只要在每段中任选一个数组合，就可以拼成所有相同位数的数。所以只用将最多可分为的段数$+1$输出即可。

$Code:$

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,k,tot,x,ans,f[100005];
int main() {
	scanf("%d%d",&n,&k);tot=0;
	for(int i=1;i<=n;i++){
		scanf("%d",&x);
		if(!f[x]){
			f[x]=true;
			tot++;
		}
		if(tot==k){
			ans++;
			tot=0;
			for(int j=1;j<=k;j++)f[j]=false;
		}
	}
	printf("%d\n",ans+1);
	return 0;
}

```
