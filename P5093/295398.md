
### 题意简述
在值域为 $ 1 $ 到 $ k $ 的序列中，求非该序列子序列序列的最短长度。
### 思路
这道题的思路还是非常好想的 很快就能够想到了用划分区间。此言怎讲，将该序列划分为若干子区间，满足子区间中的数恰满足 $ 1 $ 到   $ k $ 的数都出现，这样我们能发现每个区间的最后一个值一定是只出现过一次的，这里我就简单地来证明一下。

如果该数出现了不止一次，那么该区间是不是应该早结束了（至少是在前一位就结束了是吧） 好了，证明完毕。

接着，既然该数是该区间中最后出现的数且仅出现了一次，那么再提醒你一点，再该数后任意接一个数构成的子序列是不是一定不会在该区间内出现且是最短的，以此类推在多个区间的情况下，将每个区间最后一个值取出再任意添加一个数是不是就是最短的非原序列的子序列的序列——即为所求。
所以,我们只需要将分的组数加 $ 1 $ 即是答案！！！


------------

AC code：
```cpp
#include<bits/stdc++.h>//OvO~
#define N 10010
using namespace std;
bool sg[N];
int main()
{
	int n,m;
	scanf("%d%d",&n,&m);
	int k(0),tot(0);//初始化
	for(int i=1;i<=n;i++)
	{
		int tp;
		cin>>tp;
		if(!sg[tp])  sg[tp]=1,k++;//记录
		if(k==m)  tot++,k-=k,memset(sg,0,sizeof sg);//重置
	}
	printf("%d",tot+1);
	return 0;//perfect ending!!!
 
}
```