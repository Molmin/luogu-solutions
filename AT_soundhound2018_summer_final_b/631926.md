### 题目大意

给你一个 $N$ 长的整数序列 $b_i$，你可以进行若干次如下操作：

- 将连续的 $K$ 个整数变为 $0$。

你要使 $\sum b_i$ 最大化。

### 思路分析

显然，这是一道动态规划题。

$f_{i,0}$ 表示前 $i$ 项可以不受限制地将整数变为 $0$ 时的最优解。

$f_{i,1}$ 表示前 $i$ 项的最优解。

$f$ 的初始值为 $f_{0,0}=f_{0,1}=0,\textrm{others}=-\infty$。

状态转移方程为，

$$f_{i+1,0}=\max\{f_{i,0},f_{i,1}\}+b_i$$

即前 $i+1$ 项不受限制的最优解等于前 $i$ 项不受限制的最优解与前 $i$ 项受到限制的最优解加上第 $i$ 项的值。

$$f_{i+1,1}=\max\{f_{i+1-k,0},f_{i,1}\}$$

即前 $i+1$ 项受到限制的最优解等于前 $i+1-k$ 项不受限制的最优解（即 $i+1-k$ 后的 $k$ 项均变为 $0$）与前 $i$ 项受到限制的最优解的最大值。

答案即为 $f_{n,0}$ 与 $f_{n,1}$ 的最大值。

### AC Code

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
int n, k, b[200020], dp[200020][2];

signed main() {
	cin >> n >> k;
	for (int i = 0; i < n; i++) {
		cin >> b[i];
	}
	memset(dp, 0x80, sizeof dp);
	// 这句话将 dp 全部赋值为 0x8080808080808080 = -9187201950435737472。
	dp[0][0] = dp[0][1] = 0;
	// 设置初始值。
	for (int i = 0; i < n; i++) {
		dp[i + 1][0] = max(dp[i][0], dp[i][1]) + b[i];
		if (i + 1 - k >= 0)
			dp[i + 1][1] = max(dp[i + 1 - k][0], dp[i][1]);
	} // 进行状态转移。
	cout << max(dp[n][0], dp[n][1]);
	// 输出答案。
	return 0;
}
```

运行编号：43568962。

运行时间：80 ms。

运行内存：8280 KB。

时间复杂度：$O(n)$。