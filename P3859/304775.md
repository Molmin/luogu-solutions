# 一、题目大意

有 $n$ 个袋子，每个带中有许多不同种类的宝石。取走袋子中的宝石需要花一定的时间，每个袋子都有一个关闭时间 $c_i$。你需要在 $t$ （$t \le \forall c_j$，$j=1-i$）前取走第 $i$ 个包里面的宝石。并且在 $c_0$ 时刻前完成操作。求你最多能得到宝石的价值。

# 二、 算法思路

显然这是一个背包问题。物品是宝石，背包容积就是时间。

注意到有这样一句话：

> 而且所有屋子里各种宝石的数量都是无限多的。

我们可以确定这是一个完全背包。

但是每一个物品的取走时间都是受限制的，我们会发现每一个包（房间）的关闭时间不仅仅收到它本身的约束，还受到它前面所有关闭时间的约束。

**所以一个房间真正的约束时间是它前面所有约束时间的最小值。**

即 $c_i=\min{c_j}$，$1<j \le i$ 。

之后就可以进行完全背包的常规操作了。

注：这道题的良心之处在于它直接告诉我们物品分别是属于哪个房间的，而没有让我们依次把物品从房间中“提取”出来。

# 三、代码

代码有注释。

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;

//const int NR=105;
const int MR=1005;

int n,m,f[MR];
int c[MR],r[MR],v[MR],t[MR];
 
int main()
{
	memset(f,0,sizeof(f));
	cin>>n>>m;
	for(int i=0;i<n;i++)
		cin>>c[i];
	for(int i=1;i<=m;i++)
		cin>>r[i]>>v[i]>>t[i];
	for(int i=1;i<n;i++)
		c[i]=min(c[i],c[i-1]);
		//预处理每一个房间关闭时间
	for(int i=1;i<c[0];i++)//枚举时间
	{
		f[i]=f[i-1];//一维动态规划要赋初值
		for(int j=1;j<=m;j++)//完全背包正序枚举物品
		{
			if(i<c[r[j]]&&i>=t[j])
			//既要能取，房间门还不能关
				f[i]=max(f[i],f[i-t[j]]+v[j]);
		}
	}
	cout<<f[c[0]-1];//大门关前一秒溜走
	return 0;
}
```
**若有错误，欢迎指出！**