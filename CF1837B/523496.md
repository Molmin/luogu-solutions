### 先来解释一下题意：

- 给你一个长度为 $n$ 的由 &lt; 和 &gt; 构成的字符串 $s$，如果一个数列 $a$ 能满足将字符串 $s$ 的所有大于号和小于号按顺序填入后满足大小关系，则 $a$ 数列和 $s$ 字符串是“相容的”。
- 定义一个数列的花费是这个数列中不同元素的数量。
- 已知字符串 $s$，让你求出与 $s$ 相容的所有数列中花费最小的数列的花费。


### 然后我们进行分析：

首先我们注意到，当出现像 $a_{i}$ &lt; $a_{i+1}$ &gt; $a_{i+2}$ 的时候，$a_{i}$ 和 $a_{i+2}$ 一定可以取成同一个数，从而减少花费。出现 $a_{i}$ &gt; $a_{i+1}$ &lt; $a_{i+2}$ 的时候也是同理。然后我们试图将这两种情况连接起来，就可以得到类似于 &lt; &gt; &lt; &gt; &lt; &gt; &lt; 这样的情况，也就是题目中的第四个样例，只需要 $2$ 的花费就可以。 **也就是说对于任意长度的没有连续的 &lt; 和 &gt; 的字符串来说，只需要 $2$ 的花费即可，中间一个花费，两边一个花费。**

接下来我们考虑有连续的 &lt; 或连续的 &gt; 的情况，注意到，比如说一个连续的关系为 $a_{i}$ &lt; $a_{i+1}$ &lt; $a_{i+2}$ &lt; $a_{i+3}$，其中四个数都要不同，然后我们把这种情况套进上面分析的例子中：$a_{i}$ &lt; $a_{i+1}$ &lt; $a_{i+2}$ &lt; $a_{i+3}$ &gt; $a_{i+4}$，我发现 $a_{i}$ 和 $a_{i+4}$ 又可以取成一样的了， **也就是说中间连续的小于关系我们可以看作一个整体，也就是上面说的中间，然后左右两个数看作上面说的两边，那么整个的花费就是两边一共一个加上中间一堆。**

所以最后我们得到贪心策略：寻找字符串中最长连续的 &lt; 或 &gt;，计算长度 $l$，$l+1$ 就是最终的答案。

### 以下是代码：


```cpp
#include<bits/stdc++.h>
using namespace std;
int t,n;
char s[5010];
int main(){
	scanf("%d",&t);
	while(t--){
		scanf("%d",&n);
		scanf("%s",&s);
		int cnt1=0,cnt2=0;
		int sum1=0,sum2=0;
		for(int i=0;i<n;i++){
			if(s[i]=='>'){
				cnt2=max(cnt2,sum2);
				sum2=0;
				sum1++;
			}
			else if(s[i]=='<'){
				cnt1=max(cnt1,sum1);	
				sum1=0;
				sum2++;
			}
		}
		cnt1=max(cnt1,sum1);
		cnt2=max(cnt2,sum2);
		printf("%d\n",max(cnt1,cnt2)+1);
	}
	return 0;
}
```

### 后记

如果对题解的内容有建议或者指正，请在在评论区里说或者私信我.