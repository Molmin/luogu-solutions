## 前言。
找规律题。
## 分析。
题意就是让我们在一个字符串中填充数据，从而使这个表达式成立。

因为我们要使得填充的数最少，所以要尽可能地多的填充相同的数字。  
我们观察下面几组数据：

1. ```<>```  
要使这个表达式成立，那中间的数就要大于两边的数，我们可以填充为 ```a<b>a``` 的形式，这样可以使填充的数最少，为 $2$ 个。

2. ```<<>><>>```  
我们首先在最左边填充，这样因为有两个小于号，则我们要至少填充 $3$ 个数，同时满足三个大小关系，后面的两个大于号就可以将前面填充的数倒过来。再看后面，我们又可以找到一个由两个大于号组成的子串，可以和前面一样填充三个数，此时也满足前面的小于关系，即填充后为 ```a<b<c>b>a<c>b>a``` 的形式，答案为 $3$ 个。

通过分析，我们可以发现，在最前填充 $a$ 后，为了使满足的关系式最多，我们可以在后面的一个相反的符号上填充 $a$ 从而达到时填充的数最少的目的。

换句话说，就是如果有一个小于号（或大于号）且前面已经有过了一个大于号（或小于号），即前后符号相反，我们就可以填充同一个数。

那我们可以推断，只要找到一个最长的连续相同符号的子串，就可以求得所需数的总个数。因为一个符号需要有两个数据才能成立，所以这个总个数就是这个子串的长度加一。

但是有一个特殊情况，就是所有符号相同，此时没有办法填充同一个数，则答案为 $n+1$ 个。

代码如下，仅供参考：
```
#include<iostream>
#include<algorithm>
using namespace std;
int t,n,maxx,ans;
char s[105];
int main(){
    cin>>t;
    while(t--){
        maxx=0;
        ans=1;//注意清空。
        cin>>n>>s;
        char jl=s[0];
        for (int i=1;i<n;i++){
            if(s[i]==jl){
                ans++;
            }
            else{
                maxx=max(maxx,ans);
                ans=1;//找到目前的最大长度子串，重新统计。
                jl=s[i];
            }
        }
        maxx=max(maxx,ans);//判断特殊情况。
        cout<<maxx+1<<"\n";
    }
    return 0;
}
```
## 后记。
大家如有疑问，可以在评论区提出，我会尽力解答的。