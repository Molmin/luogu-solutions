```cpp
//这道题算法是蒟蒻自己想出来的 竞赛课上被坑了一节课 终于想了出来一个方法
//代码可能有点长 但大部分都是代码风格原因orz 核心代码并不多
//我会尽量写出详细的解释 感谢观看。
/*
这里我的算法是：
1.正向扫一遍转弯处
2.反向扫一遍转弯处
3.正向扫一遍算出两点之间可达到的最大速度
那么，怎么扫呢？
我们可以发现 从上一个点(转弯处 下文简称"点")到下一个点 速度的增加和减少是受到距离限制的 而且变化量和距离相同。
这样如果画出一个平面直角坐标系 以x轴为t(距离)，以y轴为s(速度) 描上所有的点之后 他们的连线的斜率 就是我们“扫”的关键。
简单来说，正向扫的时候就是斜率<=1的我们不管，斜率>1的我们把斜率搞成斜率=1，而反向的时候就是斜率>-1的我们搞成斜率=-1。
怎么搞呢？
先正向枚举每一个点 如果当前点限速比上一个点限速大 且两点之间距离小于限速之差 那么就把枚举到的点的限速降低到上一个点的限速+两点之间距离(即Bessie能够在这段距离内达到的最大速度) 如果当前点比上一个点限速小 那就先不管 等着反向扫描帮我们处理。
反向的时候：基本相同 如果上一个点限速比当前限速大 且两点之间距离小于限速之差 那么就处理上一个点的限速到当前点的限速+两点距离 如果上一个点比当前点限速小 因为我们在正向的时候已经处理过了 所以不管。
最终我们会得到一个漂亮的坐标系图象 而聪明的你们会发现 其实在两点之间的这段距离中 Bessie的速度没有限制，也就是说我们可以在两点之间先加速再减速到限速大小 这样就能得到可能的最大值。
所以再枚举一遍所有的点 不过计算的是两点之间的最大速度(两点之间的最大速度>=限速较高的点的速度) 如何计算呢？看代码注释orz
最后 别忘了冲过终点的速度没有限制 所以比较一下得到的答案和最后一个点的限速+与终点距离。
*/
#include<cstdio>
#include<cctype>
#include<cmath>
#include<algorithm>

inline int readin()//优化读入
{
	int x = 0;
	bool shit = false;
	char ch = getchar();
	for(;!isdigit(ch); ch = getchar()) (ch == '-') && (shit = true);
	for(; isdigit(ch); ch = getchar()) x = (x << 3) + (x << 1) + ch - '0';
	return shit ? -x : x;
}

inline int max(int x, int y)//手写max 快
{
	return x > y ? x : y;
}

struct node//结构体储存转弯处信息
{
	int t;//离起点距离
	int s;//限速
}a[233333];

int l, n, maxn;//l总长度 n转弯个数 maxn最终答案

inline bool cmp(node x, node y)//结构体排序比较
{
	return x.t < y.t;
}

int main()
{
	//freopen("testdata.in", "r", stdin);
	l = readin();
	n = readin();
	for(register int i = 1; i <= n; ++i)//常规读入
	{
		a[i].t = readin();
		a[i].s = readin();
	}
	a[0].t = 0;//初始化起点处离起点距离为0(废话
	a[0].s = 1;//这里设置初速度为1 题干中有说过 别忘了
	std::sort(a + 1, a + n + 1, cmp);//注意，给出的转弯顺序可能不是有序的
    //接下来是核心代码
	for(register int i = 1; i <= n; ++i)//正向扫一遍拐弯
	{
		if(a[i].s > a[i - 1].s)//如果当前点限速比上一个转弯处高
		{//注:初始状态也需要看作一个"转弯处"
			if(a[i].t - a[i - 1].t < a[i].s - a[i - 1].s)
			{
            	//如果两点之间距离比限速之差要小 证明从上一个点到当前点(i)不受速度限制 可以一直增加 速度增加的量就是两点距离 即a[i].t-a[i-1].t 然后加上上一个点的速度
				a[i].s = a[i].t - a[i - 1].t + a[i - 1].s;
			}
            //其他情况不管
		}
	}
	for(register int i = n; i >= 1; --i)//反向扫描
	{
		if(a[i - 1].s > a[i].s)//之前讲的比较清楚了 看代码
		{
			if(a[i].t - a[i - 1].t < a[i - 1].s - a[i].s)
			{
				a[i - 1].s = a[i].t - a[i - 1].t + a[i].s;
			}
		}
	}
	for(register int i = 1; i <= n; ++i)//比较一遍
	{
		int ta = a[i - 1].t + abs(a[i].s - a[i - 1].s);
        //我们如何计算两点之间速度的最大值呢？很明显我们构造的是一个斜边水平放置的等腰直角三角形 使两个点紧靠在直角边上 直角所在的点就是最大值 不过需要下取整
        //ta就是 与当前点关于三角形斜边上的高对称的点的横坐标 ta=上一个点的横坐标+两点限速之差 画个图就能清楚明白啦 
		int sa = max(a[i].s, a[i - 1].s);
        //sa是对称点的纵坐标 sa=两点间限速较大值
		int ans = (a[i].t - ta) / 2 + sa;
        //精髓 直角点纵坐标是对称两点的距离/2(下取整)+sa
		maxn = max(maxn, ans);
        //更新答案
        //可能有同学会问：遇到前一个点比后一个点高的情况怎么办？你这个不就凉了吗？其实并不是 如果分情况讨论，最终化简出的式子是一模一样的。
	}
	maxn = max(maxn, l - a[n].t + a[n].s);//比较终点 别忘了
	printf("%d", maxn);
	return 0;
}
```