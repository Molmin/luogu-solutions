[总长一定，可以考虑根号分治。](https://www.luogu.com.cn/problem/CF587F)

设 $sum=\sum|s|$。认为 $n=m$。

把每个 $s_k$ 分别处理。设根号分治阈为 $b$。

如果这个 $|s_k|>b$，这样的 $s_k$ 不超过 $\dfrac {sum} b$ 个。直接用 SAM 或者 ACAM 匹配每个串在 $s_k$ 中的出现次数，区间 $\max$ 用线段树等 $O(n)$ 建立的东西。

如果 $|s_k|\le b$，我们考虑用 $O(|s_k|)$ 的复杂度回答一个询问。

考虑分治。对于 $mid=(L+R)/2$，若询问 $l\le mid <r$，我们就用 $[l,mid]$ 和 $[mid+1,r]$ 的信息合并回答。

那么对 $s$ 序列分治。以回答 $[l,mid]$ 的询问为例，就是做一个 $mid\rightarrow L$ 的扫描线。

这个好像被称为“猫树分治”。

那么就是维护一个集合 $S$，支持插入一个字符串，和对于一个长度 $\le \sqrt n$ 的字符串 $x$，求 $\max w(S_i,x)$。

建立 ACAM。那么就是支持标记一个点为关键点，和给出 $O(\sqrt n)$ 个临时点，询问关键点的子树中的临时点数量的最大值。

对临时点建虚树（这个虚树最好进行一些预处理），按子树中临时点数量枚举，判断每个点到根的路径上是否存在关键点。

那么就是单点加链求和，转化为区间加单点求值。

比较糟糕的事情是单点加次数为 $O(n\log n)$，这里要用 $O(n^k)$，$k\in [0,0.5)$ 修改，$O(1)$ 查询的分块。

其实是这样的：

令块长 $b=\sqrt n$，整块打 tag，散块暴力加，得到一个 $O(\sqrt n)$ 的做法。

再分块一次，对打 tag 的过程使用上面的做法，设块长为 $b'$，则时间复杂度为 $O(b'+\sqrt{\dfrac n b'})$。解得 $b'=n^{1/3}$。

所以得到了一个 $O(n^{1/3})$ 修改的东西。或者对散块也用 $O(\sqrt n)$ 的做法维护，得到 $O(n^{1/4})$。


另一种方法是，转化为区间赋 $1$ 单点查询，这个可以在一般的分块上压位把修改的时间复杂度除掉 $w$，也可以做到比较可以的时间复杂度。

时间复杂度为 $O(n^{1+eps}\log n+\dfrac {sum^2} b+nb)$ 或者 $O(n\sqrt n+\dfrac {sum^2} b+nb)$，解得 $b=\dfrac {sum} {\sqrt n}$

因此时间复杂度 $O(sum\sqrt n)$，空间 $O(sumc)$，$c$ 为字符集大小。不过理论上是线性空间。

感觉不是很难啊，一年前的题还能作为现在的 F 吗。