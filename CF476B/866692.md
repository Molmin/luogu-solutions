# 题目意思
给你一个字符串 $a$ 和字符串 $b$,你要按照 $a$ 路线走一次，找到终点的位置，再按照 $b$ 路线走一次，求走到终点的概率为多少（保留 $12$ 位小数），已知当符号为加号时代表向前走一格，减号代表向后走一格，问号代表向前走一格或向后走一格，且你的初始位置为 $0$。
# 代码思路
~~这题比较水，可以直接暴力搜索。~~

首先我们按照 $a$ 路线走一次，找到终点的位置，然后从 $0$ 开始走，并从第 $1$ 个字符开始读取，当该字符不为 $?$ 时，我们就依题意走，如果该字符为 $?$，那么我们就分别把它当做 $+$ 和 $-$ 各走一遍，当路线走完时，就把 $zf$ 加上 $1$，再判断这个方案可否到达终点，如果可以就把 $kx$ 加上 $1$，最后输出。
# 代码实现
```
#include<bits/stdc++.h>
using namespace std;
string a,b;
int zf,kx,aa,zd;
void f(int n,int y){
	if(n>aa){
		zf++;//记录总方案
		if(y==zd)kx++;//记录可行解
		return ;
	}
	if(b[n]=='+')f(n+1,y+1);
	else if(b[n]=='-')f(n+1,y-1);
   	//当该字符不为?时
	else{
		f(n+1,y+1);
		f(n+1,y-1);
        	//当该字符为?时
	}
}
int main(){
	cin>>a>>b;
	aa=a.length();
	a=' '+a;
	b=' '+b; 
	for(int i=1;i<=aa;i++){
		if(a[i]=='+')zd++;
		if(a[i]=='-')zd--;
     		//求终点的位置
	}
	f(1,0);//开始搜索
	printf("%.12lf",kx*1.00/zf);
	return 0;
}
```
