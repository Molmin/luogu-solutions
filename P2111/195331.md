这题是概率dp  
设$f_{i,j}$为前$i$题对$j$题的概率。很明显$f_{i,j}$会由$f_{i-1,j}$和$f_{i-1,j-1}$转换过来，分别对应这题没做对和做对。  
对于每个$f_{i,j}$，如果这题（指第$i$题，下同）是$0$，即答案不同，那么结果就是小红这题做错的概率（$f_{i-1,j}$）乘上小明的正确率（$A\%$）（小红没做对对应小明作对，因为他们的答案不一样）加小红这题作对的概率（$f_{i-1,j-1}$）乘上小明的错误率（$1-A\%$）。也就是：
$$f_{i,j}=f_{i-1,j} \times A\% + f_{i-1,j-1} \times (1-A\%)$$
而如果答案相同，很明显和上面相反，也就是：
$$f_{i,j}=f_{i-1,j} \times (1-A\%) + f_{i-1,j-1} \times A\%$$
那么，式子推出来了，就没有什么问题了。

接下来是~~大家喜闻乐见的~~代码：
```cpp
#include<cstdio>
using namespace std;
int n,q;
double ans,a,f[55][55];
//注意这些要开double哦！
int main()
{
	scanf("%d%lf%d",&n,&a,&q);
	a/=100;//百分数转小数
	if(q==0)//特判一下
	{
		printf("1.000\n");
		return 0;
	}
	f[0][0]=1;//明显，前0题对0道的概率是100%
	for(int i=1;i<=n;i++)
	{
		int x;
		scanf("%1d",&x);//边读入边处理
		for(int j=0;j<=n;j++)
			if(!x) f[i][j]=f[i-1][j]*a+f[i-1][j-1]*(1-a);//答案不同的情况
			else f[i][j]=f[i-1][j]*(1-a)+f[i-1][j-1]*a;//答案相同的情况
	}
	for(int i=q;i<=n;i++) ans+=f[n][i];
    //最后要枚举一遍前n道作对q~n道的概率，把他们加起来，这样才是作对>=q道题的概率
	printf("%.3lf",ans);
	return 0;
}
```
最后浪费您一点时间，安利一下[我的博客](https://www.luogu.com.cn/blog/195331/)  
如果$\LaTeX$挂了也可以去我的博客查看