## 算法

每个块用一个`vector`记录。每次取完一个果篮后，如果需要合并块，则再扫一遍所有`vector`，然后暴力合并。

## 复杂度分析

设有$k$次取完果篮后需要合并，那时间复杂度是多少呢？取果篮的时间是$O(n)$，因为每个水果最多被取到一次。合并块的时间是$O(kn)$。于是，总的时间复杂度是$O(kn)$。

下面证明，$k≤O(\sqrt{n})$。
* 先看最后一次合并，合并以后至少有$1$块，那么合并前至少有$3$块，所以这次取的果篮里至少有$3$个水果。
* 再看倒数第二次合并，合并后至少有$3$块，那么合并前至少有$5$块，所以这次取的果篮里至少有$5$个水果。
* 再看倒数第三次合并，合并后至少有$5$块，那么合并前至少有$7$块，所以这次取的果篮里至少有$7$个水果。
* ……

依次类推，总共至少有$3+5+7+9+...(2k+1)=O(k^2)$个水果，所以$k$至多是$O(\sqrt{n})$，证毕。

因此，总的时间复杂度$O(kn)≤O(n\sqrt{n})$。而在最坏情况下，`010011000111000011110000011111…`能让本算法达到$O(n\sqrt{n})$的复杂度。