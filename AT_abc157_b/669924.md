## 题目大意
有一个 $3 \times 3$ 的宾果卡。
现在，主持人给你 $b$ 个数，每个数小于 $100$，问能否形成宾果。
## 思路
第一个想到的就是二维数组。

先输入宾果卡。因为每个数小于  $100$，所以我们把每个主持人说的数字运用循环宾果卡里寻找，找到就赋值为 $100$。
最后再判断有没有 $3$ 个 $100$ 连成一条线。
## 宾果的方式
如果同一行，同一列或者对角线都被主持人念到，就算宾果。

同一行：

 $ A_{1,\ 1} $   $ A_{1,\ 2} $   $ A_{1,\ 3} $ 




同一列：


 $ A_{1,\ 1} $   $ A_{2,\ 1} $   $ A_{3,\ 1} $ 



对角线：

 $ A_{1,\ 1} $   $ A_{2,\ 2} $   $ A_{3,\ 3} $ 



## 代码
（建议自己根据思路编写程序，有遇到困难再来看代码）

```cpp
#include<bits/stdc++.h>
using namespace std;
int main() {
	int a[4][4];
	//输入宾果卡 
	for(int i = 1;i <= 3;i++) {
		for(int j = 1;j <= 3;j++) {
			scanf("%d",&a[i][j]);
		}
	}
	int b;
	scanf("%d",&b);
	for(int i = 1;i <= b;i++) {
		int c;
		scanf("%d",&c);
		//找到赋值成100 
		for(int j = 1;j <= 3;j++) {
			for(int k = 1;k <= 3;k++) {
				if(c == a[j][k]) {
					a[j][k] = 100;
				}
			}
		}
	}
	//以此判断每种方法 
	for(int i = 1;i <= 3;i++) {
    	//同一行
		if(a[i][1] == 100 and a[i][2] == 100 and a[i][3] == 100) {
			printf("Yes");
			return 0;
		}
        //同一列
		if(a[1][i] == 100 and a[2][i] == 100 and a[3][i] == 100) {
			printf("Yes");
			return 0;
		}
	}
    //对角线
	if(a[1][1] == 100 and a[2][2] == 100 and a[3][3] == 100) {
			printf("Yes");
			return 0;
	}
	if(a[3][1] == 100 and a[2][2] == 100 and a[1][3] == 100) {
		printf("Yes");
		return 0;
	}
	//没有输出No 
	printf("No");
}

```
