为防歧义，以下将按题意划分的连续的段称为**小段**，需要求代价的段称为**子段**。  
先稍微翻译一下题意： 
- 某个子段的代价就是它的小段数+每个小段的 MEX。  
- 求所有子段的代价的最大值之和。  

再找找特殊的地方：  
- 不含 0 的小段的 MEX 为 0 。  
- 一个子段的代价也是它的小段的代价和。

来分析下划分的策略 (假设元素数量为 cnt ) ：
- 若某个子段不含 0 ，那么它的代价就是它的小段数（因为所有小段 MEX 均为 0 ），所以代价的最大值就是 cnt 。
- 若某个子段含 0 ，假设它其中一个含 0 小段的 MEX 为 k ，那么这个小段的代价就是 $k+1$ ，又显然 $k\le cnt$ ，所以这个小段的代价的最大值就是 $cnt+1$ ，而其它小段不含 0 ，最大代价便是 cnt 。由此可知，含 0 子段的最大代价是 $cnt+1$ 。  

再通俗一点：
- 非 0 元素对每个子段的贡献为 1 ， 0 对每个子段的贡献为 2 。

因此只需要把所有元素的贡献加起来就行了。  
**注意**：每个元素在几个子段中，它就贡献了几次。  
附 AC 代码：  
```cpp
#include<bits/stdc++.h>
using namespace std;
int t,n,a;
int main(){
	cin>>t;
	while(t--){
		cin>>n;
		int ans=0;
		for(int i=1;i<=n;i++)cin>>a,ans+=i*(n+1-i)*(!a+1);
		cout<<ans<<endl;
	}
	return 0;
}
```


