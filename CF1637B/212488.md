先考虑对于一个固定的序列，怎么求他的“划分”的最大代价。

经过多组观察（在做这种 D2B 级别的题的时候观察非常有效），我们可以发现，每个元素单独作为划分的一段一定是最优的，然后大胆写上去就过了这题。下面给出简要证明。

假设当前划分的一段包含了 $\{0, 1, 2,\cdots, m\}$ 中的所有数，共有 $k$ 个元素，则其代价为 $1 + \operatorname{mex}\{0,1,\cdots, m\} = m + 2$，然后我们将其划分为一个元素一段后，代价为 $k + \operatorname{cnt}(0)$，而 $m + 1\le k$，$\operatorname{cnt}(0)\ge 1$，所以将每个元素作为一段不会更劣。

再假设当前划分的一段包含了 $\{0, 1, 2,\cdots, m\}$ 中的数和其他若干 $> m$ 的数，共有 $k$ 个元素，则其代价为 $m + 2$，然后划分为一个元素一段后的代价为 $k + \operatorname{cnt}(0)$，用类似上文的分析方法可知每个元素作为一段是不会更劣的。

再假设当前划分的一段不包含 $0$，有 $k$ 个元素，则其代价为 $0$，划分为一个元素一段后代价为 $k$，所以这种情况下划分为一个元素一段是严格更优的。

综上我们完成了证明。现在考虑如何计算每个连续子段的贡献。

注意到一个元素作为一段会产生 $1$ 的贡献，所以这部分的贡献是 $\sum_{i=1}^ni(n - i + 1)$，然后是 $0$ 元素产生的 $\operatorname{mex}$ 为 $1$ 的贡献，对于 $a_i = 0$ 来说，其贡献就为 $i\times(n - i + 1)$。

所以这题其实是可以加强到 $O(n)$ 的，，，不知道为什么出题人的数据范围是 $100$。

```cpp
const int maxn = 105;
int n, a[maxn];

int main() {
    int T; read(T);
    while (T--) {
        read(n);
        FOR(i, 1, n) read(a[i]);
        int ans = 0;
        FOR(i, 1, n) {
            ans += (n - i + 1) * i;
            if (!a[i]) ans += (i) * (n - i + 1);
        }
        print(ans);
    }
    return output(), 0;
}
```