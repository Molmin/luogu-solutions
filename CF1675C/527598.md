## 题意：

有 $n$ 个人依次进入了 $\text{Polycarp}$ 的房间。这之后，他发现房间里的一幅画被偷走了。他询问了那 $n$ 个人在他们进去时有没有那幅画。

- 每个人都会回答 “有” “没有” “不知道” 三种中的一种。

- 小偷的回答可能是真话也可能是假话，其他人的回答都是真话。

## 思路：

因为小偷偷走画前画还在，所以小偷前面所有的人都会说“有”“不知道”两种中的一种；

同样的思路，因为小偷偷走画后画不在，所以小偷后面所有的人都会说“没有”“不知道”两种中的一种；

综上所述，我们只需要找出最后一个说“有”的人和第一个说“没有”的人，夹在这两个人之间的人都有可能是小偷。这样做的时间复杂度和空间复杂度都是x线性的。

注意点：可以在最前面插入一个说“有”的人，在最后插入一个说“没有”的人，以免出现没有人说“有”或“没有”的情况。

## 代码（ $\text{C++}$ ）:

```cpp
#include<iostream>
#include<string>
using namespace std;
bool a[200005],b[200005];
//A数组表示第i个人是否是（最后一个及之前）说了“是”或“不知道”的人；
//同样，B数组表示第i个人是否是（第一个及之前）说了“不是”或“不知道”的人。
int main(){
    int t;
    cin>>t;
    while(t--){
        string s;
        cin>>s;
        a[0]=b[0]=true;
        //初始条件
        for(int i=0;i<s.length();i++)
            a[i+1]=a[i]&&(s[i]=='1'||s[i]=='?');
            //处理A数组:
            //等价于 if(a[i]==true&&(s[i]=='1'||s[i]==0)) a[i+1]=true;
            //如果要再优化（比如说抢最优解）可以在出现a[i]==false的时候break;
        for(int i=s.length()-1;i>=0;i--)
            b[s.length()-i]=b[s.length()-i-1]&&(s[i]=='0'||s[i]=='?');
            //和处理A数组一样的思想
        int ans=0;
        for(int i=0;i<s.length();i++)
            if(a[i]&&b[s.length()-i-1])
                ans++;
                //如果当前位置：
                //在说了“是”的人之后，
                //在说了“不是”的人之前，
                //则答案加一
                //当然如果还要优化，可以在出现第一个不符合时break;（因为以后肯定也不符合，所有可能的位置是连在一起的）
        cout<<ans<<'\n';//输出
    }
    return 0;
}
```