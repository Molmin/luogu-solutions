# [题目传送门](https://www.luogu.com.cn/problem/AT_arc137_c)

## 题意分析：

给定长为 $N$ 的非负整数列 $A=(A_1,…,A_N)$，保证 $A$ 中元素互不相同。

Alice 和 Bob 在玩游戏。Alice 为**先手**，两人轮流操作。每次操作选手可以如下进行：

选择当前 $A$ 中**最大的元素**，将其替换为一个**更小的非负整数**。

要求替换后 $A$ 中元素仍**互不相同**。

首先无法操作的一方失败。当两人都采取最优策略时，求谁有必胜策略。

数据范围为

$2 \leq N \leq 3 \times10^5$

$0 \leq A_1<A_2<⋯<A_N \leq 10^9$

正常开 `int` 即可。

### 题外话：

本蒟蒻第一眼看到这道题还以为是大模拟，然后读题读着读着发现不太对。

一看标签，贪心+博弈论，~~直接仰天长啸~~。

~~简简单单的~~思考了两个半小时后才终于有思路。

## 思路：

这道题可以首先判断最大的元素与前一个元素的差是否大于 1。

如果大于 1，说明当前的最大元素是不可操作的，也就是无论谁操作都无法改变该元素的值。那么无法操作的一方 （Bob） 失败，另一方 （Alice） 即为胜利者。

如果最大元素与前一个元素的差不大于 1，那么需要进一步观察剩余可操作次数和总元素个数的奇偶性。

如果剩余可操作次数为奇数，那么操作结束时轮到 Bob 进行最后一次操作。

如果剩余可操作次数为偶数，那么操作结束时轮到 Alice 进行最后一次操作。

最后一次操作可以让最大元素替换成一个比它小的非负整数，让对方无法再进行操作。这样最后一个元素就归属于自己。因此，最后一步的操作者有必胜策略。

#  _AC Code_ :

```c
#include <bits/stdc++.h>

using namespace std;

int n,a[3000005]; //定义变量，数组

string check(int n,int a[]) //定义函数check
{
	if (a[n]-a[n-1] > 1) return "Alice"; //最大的元素与前一个元素的差是大于1，Alice赢
	else if((a[n]-n+1)%2==1) return "Bob"; //最大元素与前一个元素的差不大于1且剩余可操作次数为奇数
	else if((a[n]-n+1)%2==0)return "Alice"; //最大元素与前一个元素的差不大于1且剩余可操作次数为偶数
}
int main()
{
	cin>>n; //读入n
	for (int i=0;i<n;i++) cin>>a[i]; //读入数组a
	cout<<check(n-1,a); //输出结果
	return 0;
}
```
# [AC](https://www.luogu.com.cn/record/113135134)