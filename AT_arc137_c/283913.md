# Description

给定一个有 $n$ 个元素的集合 $a$，保证元素之间两两不同且均为非负整数。A 和 B 在对集合 $a$ 博弈，轮流操作，每次操作取出 $a$ 中最大的元素，然后将它变成一个更小的非负整数，不能破坏元素两两不同的性质。问最后胜利者是谁。

$n \le 3 \times 10^5$，时限 2s。

# Solution

怎么这场的 ABCD 题都是结论题啊……

赛时的想法是最终局面必然是 $0 \sim n-1$ 的排列，然后从这个性质入手去做，把问题简化成最初的石子取数模型，但是这样做规则很复杂，根本做不了。

而官方题解则利用了本问题的“决策包容性”，即一个状态若能到达它所能到达的状态所能到达的状态，则这个状态必然是必胜态。

利用这个性质，我们考察原问题的第一步操作。我们首先将集合中的元素从小到大排序，显然，若 $a_n-a_{n-1}>1$，则能到达 $a_1, \cdots,a_{n-1},a_{n-1}+1$ 的局面。若这个局面为必败态，则原局面必然是必胜态。若不是的话，原局面必然能到达它所能到达的必败态，因此原局面为必胜态。

对于 $a_n-a_{n-1}=1$ 的情况，容易发现先后手一定为了不输一定一直保持这个性质。不难得到此时的胜负由 $a_n-n$ 决定的结论。

# Code

```cpp
const int N=3e5+5;
int n,a[N];
int main() {
	scanf("%d",&n);
	for (int i=1;i<=n;i++) scanf("%d",&a[i]);
	if (a[n]-a[n-1]>1) puts("Alice");
	else if (abs(a[n]-n)&1) puts("Bob");
	else puts("Alice");
	return 0;
}

```
