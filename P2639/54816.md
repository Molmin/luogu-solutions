# P2639 [USACO09OCT]Bessie的体重问题Bessie's We…



### 题目描述

$Bessie$像她的诸多姊妹一样，因为从$Farmer John$的草地吃了太多美味的草而长出了太多的赘肉。所以$FJ$将她置于一个及其严格的节食计划之中。她每天不能吃多过$H (5 <= H <= 45,000)$公斤的干草。 $Bessie$只能吃一整捆干草；当她开始吃一捆干草的之后就再也停不下来了。她有一个完整的$N (1 <= N <= 500)$捆可以给她当作晚餐的干草的清单。她自然想要尽量吃到更多的干草。很自然地，每捆干草只能被吃一次（即使在列表中相同的重量可能出$2$次，但是这表示的是两捆干草，其中每捆干草最多只能被吃掉一次）。 给定一个列表表示每捆干草的重量$S_i (1 <= S_i <= H)$, 求$Bessie$不超过节食的限制的前提下可以吃掉多少干草（注意一旦她开始吃一捆干草就会把那一捆干草全部吃完）。

### 输入输出格式

##### 输入格式：
* 第一行: 两个由空格隔开的整数: H 和 N * 第2到第N+1行: 第i+1行是一个单独的整数，表示第i捆干草的重量S_i。

##### 输出格式：
* 第一行: 一个单独的整数表示Bessie在限制范围内最多可以吃多少公斤的干草。

### 输入输出样例

##### 输入样例#1： 复制
$56$ $4$

$15$

$19$

$20$

$21$
##### 输出样例#1： 复制
$56$
### 说明

##### 输入说明:

有四捆草，重量分别是$15$, $19$, $20$和$21$。$Bessie$在$56$公斤的限制范围内想要吃多少就可以吃多少。

##### 输出说明:

$Bessie$可以吃$3$捆干草（重量分别为$15$, $20$, $21$）。恰好达到她的$56$公斤的限制。





最近都在做      动态规划,动规,dp      的题。

因为，我个人比较喜欢做这种题。

这种题，思维上比较有挑战性，代码却比较短。

好了，闲话少说，回归正题。

这次讲的是      背包      类型的题。

而且是属于比较简单的$01$背包。

那我们的思路是逆推，也就是搭积木，从上往下看是否可以放。

如果可以就放，否则继续往下看。

所以，要注意f[0]=1。

因为最低也就到地板。

每个都做一次之后，从上往下搜一次就可以找到结果了。

## 核心大放送：

### 先做一次01背包

### 注意f[0]=1

### 最后再从上到下扫一次



### 代码$dalao$：

```
//P2639 [USACO09OCT]Bessie的体重问题Bessie's We…

//题目提供者 FarmerJohn2
//评测方式 云端评测
//标签 动态规划,动规,dp 背包 USACO 2009
//难度 普及-
//时空限制 1000ms / 128MB

#include<cstdio>//调用      scanf和printf      的库 
#include<cstring>//调用      memset      的库 
#define ll long long//习惯定义long long 
const ll mx=510;
ll h,n;
ll a[mx],f[mx*90];
//定义变量和数组 
int main(){
	memset(f,0,sizeof(f)),f[0]=1;//清0，注意f[0]=1 
	scanf("%lld %lld",&h,&n); 
	for(ll i=1;i<=n;i++)scanf("%lld",&a[i]);
	//输入 
	for(ll i=1;i<=n;i++){//枚举每一个 
		for(ll j=h;j>=a[i];j--){//逆推 
			if(f[j-a[i]]==1)f[j]=1;//如果可以落脚就搭 
		}
	}
	//做01背包 
	for(ll i=h;i>0;i--){//从上到下 
		if(f[i]==1){ 
			printf("%lld",i);//如果有就输出 
			break;//退出 
		}
	}
	//扫一遍 
	return 0;//结束 
}
```