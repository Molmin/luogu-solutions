因为是裸题，所以来水一波01背包的压维优化。

博客食用口味更佳：

[背包九讲—上—简单背包](https://www.cnblogs.com/fusiwei/p/11544682.html)


## 0/1背包问题

#### 题目类型

 有$N$件物品和一个容量为$V$的背包。第$i$件物品的费体积是$v[i]$，价值是$val[i]$，求将哪些物品装入背包可使价值总和最大。

#### 问题解析

0/1背包问题是最基础的背包问题，可以这么说：0/1背包是所有背包的祖先。因为0/1背包是用线性动归的思路来求解的，而其他的背包是用0/1背包的思想来求解的。所以，为了解决这个问题，我们来用线性DP的基本内容来思考。

* **决策**

因为是动态规划，所以我们在思考的时候一定要牢记DP的两个性质：无后效性和最优子结构，也就是说，设置决策是解决动归的灵魂。回归0/1背包的问题，我们容易得出一个性质：每件物品只会面临一个决策：放还是不放。那么，我们接下来的部分就可以用这两个选择来继续进行。

* **状态**

状态的定义建立在子问题的基础上，针对0/1背包，我们的状态被设置成：$dp[i] [j]$表示前$i$件物品中任选若干件放入容量为$j$的背包所能得到的最大价值。

* **状态转移方程**

$$
dp[i] [j]=max(dp[i-1] [j],dp[i-1] [j-v[i]]+val[i])
$$

我们有必要好好理解这个方程。这个方程表示的是一个决策的过程，因为我们在决策一件物品放或不放的时候，牵扯到的数据只是在放它之前的那个状态。那么易知：如果不放的话，那$dp[i] [j]$就是$dp[i-1] [j]$，因为容量没有变，如果放了的话，那么就需要在原来的背包中腾出一个$v[i]$那么大的空位，否则这个新物品将无处可放。当然，如果放了这个物品，那么还需要加上$val[i]$。

* **答案**

综上所述，最终要求的答案就是$dp[n] [V]$。

#### 空间复杂度的优化

我们发现，上面的$dp$数组是一个二维数组，那么假如背包最大容量和物品件数都特别大的时候，这样的空间复杂度肯定会爆炸。所以我们需要采取手段来优化它的空间复杂度。01背包的空间复杂度优化方式有两种：一种是**滚动数组**优化，另一种是**压维**优化。

我们会发现，0/1背包的状态转移方程只用到了$dp[i-1] [j]$的数据。也就是说，我们在求取答案的时候，$1-(i-2)$的数据是啥用没有的。那么我们考虑不再存储这些数据，而将数组“滚动”起来，依次覆盖上一次用不着的数据，这样就可以把dp数组的第一维只开2位，而完成0/1背包的DP操作，大大地降低了空间复杂度。

在此我不讲解滚动数组的代码实现，因为特别麻烦。但是又不得不说这个滚动数组，因为这是理解下一个优化：压维的重要知识铺垫。

我们来看一下压维操作。

因为每种物品只有放或者不放这两种可能，所以我们在处理的时候可以把存物品的那一维省略，直接用背包容量来进行DP，更大地压缩了空间复杂度。

实现的时候非常简单：

```cpp
for(int i=1;i<=n;i++)
	for(int j=V;j>=v[i];j--)
		dp[j]=maxn(dp[j],dp[j-v[i]]+w[i]);
```

细心的读者可能已经注意到了，这里的第二维$j$是从$V$到$V[i]$开始枚举的。这是为什么呢？

我们的外层循环进行的是逐物品枚举，而内层循环只起到一个作用：持续更新当前容量的价值最大值。所以状态转移方程的意义就是：当前物品的放与不放是否会对当前的答案产生影响。这就是0/1背包的压维优化了。

---

综上所述，这道题可以把重量和体积划等号，然后直接应用模板解决。

代码：
```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
int n,h;
int v[510];
int dp[45001];//dp[i]表示其在i范围内能吃多少干草
int main()
{
    scanf("%d%d",&h,&n);
    for(int i=1;i<=n;i++)
        scanf("%d",&v[i]);
    for(int i=1;i<=n;i++)
        for(int j=h;j>=v[i];j--)
            dp[j]=max(dp[j],dp[j-v[i]]+v[i]);
    printf("%d",dp[h]);
    return 0;
}
```