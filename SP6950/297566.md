## 题外话：
题解里另外[那位老哥](https://279700.blog.luogu.org/solution-sp6950/)的思路好像是错的(也可能是我没看懂）。

## 正题：
讲一下我的思路：

我们记砖块 $i$ 的长度为 $a_i$ 。  

首先按照从小到大排序，然后插入砖块。

我们考虑一个砖块有多少个地方能插入：

#### 一、

因为是从小到大排的序，所以当前的砖块一定比所有已经插入的长，所以肯定能放在最底下。

方案数等于 $1$。

#### 二、
设当前要插入的砖块为 $i$ ，首先在已经插入的砖块中找到一个砖块 $j$ 使它满足 $ a_i \le a_j+d$，那么我们就可以在 $j$ 上面的位置插入砖块，证明（其实很显然）：

设当前的塔中（插入 $i$ 之前）在砖块 $j$ 上面的砖块为 $k$。

因为当前的砖块一定比所有已经插入的长，所以 $a_i$ 一定大于 $a_k$，并且  $ a_i \le a_j+d$ ，所以在 $j$ 上面的位置插入砖块一定是合法的。

方案数等于
$
\sum_{j=1}^{i-1} [a_i \le a_j+d] 
$。
______
两者相加就是每一步的方案数。

最后，根据乘法原理，答案等于每一步的方案数的积。

## 代码：
```
#include<bits/stdc++.h>
#define int long long 
using namespace std;
const int N=620000+10;
const int mod=1000000009;
int n,d;
int a[N],ans=1,l=1;
signed main()
{
	cin>>n>>d;
	for(int i=1;i<=n;i++)
		cin>>a[i];
	sort(a+1,a+n+1);
	for(int i=1;i<=n;i++)
	{
		while(l<=n && a[l]+d<a[i]) l++;
		ans=ans*(i-l+1)%mod;
	}
	cout<<ans;
}
```

时间复杂度：$O(n \log_2n)$

