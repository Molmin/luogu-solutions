### 题意：

有 $N$ 个物品。

每个物品是以下三种之一：拉环罐头、普通罐头或开罐器。

第 $i$ 个物品由一个整数对 ($T_i$, $X_i$) 描述，如下所示：

- 如果 $T_i = 0$，则第 $i$ 个物品是一个拉环罐头；如果你获得它，你会得到 $X_i$ 的幸福值。
- 如果 $T_i = 1$，则第 $i$ 个物品是一个普通罐头；如果你获得它并使用开罐器打开它，你会得到 $X_i$ 的幸福值。
- 如果 $T_i = 2$，则第 $i$ 个物品是一个开罐器；它可以用来打开最多 $X_i$ 个罐头。

找出在 $N$ 个物品中获得 $M$ 个物品时的最大总幸福值。

### 思路：

~~有点儿水的 F 题……~~

提供一种 $O(n)$ 的思路，如果我们要选 $k$ 个拉环罐头，那么我们肯定尽量选幸福值前 $k$ 大的，选普通罐头也是。

如果直接这样去维护，肯定会 TLE，所以考虑使用前缀和，首先将拉环罐头的幸福值存入数组 $a$ 里面，普通罐头的幸福值存入数组 $b$ 里面，将开罐器的使用次数存入数组 $c$ 中。

我们设其中有 $l_1$ 个拉环罐头，$l_2$ 个普通罐头，$l_3$ 个拉罐器。首先将 $a,b,c$ 三个数组都从大到小排序，然后将 $a$ 数组的前缀和存入 $A$ 中，$b$ 数组的前缀和存入 $B$ 中。

这样可以保证选拉环罐头或者普通罐头的时候，幸福值是当前最大的，那么为什么要将可开罐次数从大到小排序呢？因为我们使用开罐器需要消耗一个物品的选择的，所以尽量从最大使用次数开始。

重点来了，如何找出在 $N$ 个物品中获得 $M$ 个物品时的最大总幸福值呢？

我们发现，可以通过枚举使用普通罐头的数量来确定答案，为什么呢？因为普通罐头与开罐器直接相关，设 $j$ 为当前选择的普通罐头数量。

因为可以不选普通罐头，所以 $j$ 从 $0$ 开始枚举到 $m$，现在在定义一个变量 $cnt$，表示总共可以开多少个普通罐头。

这个 $cnt$ 我们可以用一个 while 循环进行维护，定义一个 $c$ 数组的指针 $p$，从第一个数开始逐渐加到 $cnt$ 里面，只要 $cnt \ge j$ 或者指针指遍历完了，那么就退出循环。

因为之前我们将 $c$ 数组从大到小排序了的，所以这样可以保证可以选择最少的开罐器开 $j$ 个普通罐头，当然，如果所有开罐器的次数都加起来，还是小于 $j$ 的话，我们就开不了 $j$ 个普通罐头，就可以结束枚举。

否则，我们需要判断一下还剩下几个物品的选择，就可以选择拉环罐头。剩余的选择为 $k=m-p-j$，如果 $k < 0$，那么代表选多了，也退出枚举。

否则，我们就可以计算选择 $j$ 个普通罐头的最大幸福值，即 $ans=A_k+B_j$，最后我们只用输出 $ans$ 中的最大值即可。

注意一下如果 $k > l1$ 了， 前缀和如果只计算到了 $l1$ 就停止了的话，那么这个位置的值就是 $0$ 了，有两种解决方法，一种是将前缀和计算到 $m$ 这个位置，还有一种是如果 $k>l1$ 了，那么就直接加上 $A_{l1}$。

对于 $j > l2$ 也是可以用一样的处理方法。

### 完整代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll N=200200;
inline ll read(){ //快读 
    ll x=0,f=1;
    char c=getchar();
    while(c<'0'||c>'9'){
        if(c=='-')
          f=-1;
        c=getchar();
    }
    while(c>='0'&&c<='9'){
        x=(x<<1)+(x<<3)+(c^48);
        c=getchar();
    }
    return x*f;
}
inline void write(ll x){ //快输 
	if(x<0){
		putchar('-');
		x=-x;
	}
	if(x>9)
	  write(x/10);
	putchar(x%10+'0');
}
ll m,n,p,cnt,t,l1,l2,l3,ans=0,sum=0;
ll A[N],B[N],a[N],b[N],c[N];
int main(){
    n=read(),m=read();
    for(ll i=0;i<n;++i){
    	t=read(); 
        if(t==0)
		  a[l1++]=read();
        if(t==1)
          b[l2++]=read();
        if(t==2)
          c[l3++]=read();
    }
    sort(a,a+l1,greater<ll>());
    sort(b,b+l2,greater<ll>());
    sort(c,c+l3,greater<ll>());
    for(ll i=1;i<=l1;++i)
	  A[i]=A[i-1]+a[i-1];
    for(ll i=1;i<=l2;++i)
	  B[i]=B[i-1]+b[i-1];
    for(ll j=0;j<=m;j++){
        while(cnt<j&&p<l3){
            cnt+=c[p];
			p++;
        }
        if(cnt<j)
		  break;
        ll k=m-j-p;
        if(k<0)
		  break;
        ans=A[k<l1?k:l1]+B[j<l2?j:l2];
        sum=max(sum,ans); 
    }
    write(sum);
    return 0;
}
```
