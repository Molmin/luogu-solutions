## 楼下的两个状压题解都只能拿 80 ？这里给出 AC 的状压题解。

状压的思路是一样的。用 v [ i ] [ j ] 来表示 i 状态下走到第 j 个地方的最小值。这里的 i 实质上是一个二进制数，每一位是 0 是 1 即表示每个地方有无去过，但是转为十进制表示状态，这便是状态压缩的基本思想。先从 3（二进制 11） 枚举 i，每次给 i 加 2（因为第一位所表示的第一个地方是起点，不管如何都去过，因此其永远是 1）。得到可能的 i 后，枚举 i 的除第一位外每个为 1 的位，并替换 1 为 0 得到能转移到状态 i 的状态 s，具体转移过程就不多说了，总之位运算什么的详见代码。

那么如何进行优化呢？下面就是几个好办法：

- 1 . 首先如果规定 n = 5，即有售货员要去五个地方，枚举到 i = 3（二进制 00011） 时，我们不一定需要从最低位一直枚举到第 n 位，因为第 n 位可能在枚举 i 的很久以后才能变成 1，这之前都是 0，浪费时间复杂度，因此我们可以规定整数 k，表示目前可能为 1 的最高位的位数。当 i 超过 2 的 k 次方时，更新 k，即为 k 自增。这里 2 的 k 次方可以暂时用变量 p 表示，k 更新时用位运算给 p 向左移一位。

- 2 . 尽量不用 STL 的 min，虽然好用，但是宁愿用 define 手打 QAQ，另外其他联系到位运算的，比如取某数二进制位下的某位的值，也可以用 define 而不是新建什么内联函数。

- 3 . 对于状态 i，其由不同的状态 s 转移而来，因此，我们倒推 s 的时候，先确认其可行性，再枚举 l ，用 v [ s ] [ l ] 更新 v [ i ] [ j ] 的最小值。

个人认为第 2 点优化程度是最大的。下面给出代码：

```cpp
#include <cstdio>
#define Replace(a , b) (a ^ (1 << b-1))
#define Get(a , b) ((a >> b-1) & 1)
#define min(a , b) ((a) < (b) ? (a) : (b))
#define MaxAns 2000000000

int n , m , v[1 << 20][20] , r[20][20] , ans = MaxAns , s;

int main(){
    scanf("%d" , &n);
    m = (1 << n) - 1; // 得到最大的状态 i 是多少 
    for(int i = 1 ; i <= n ; i++)
        for(int j = 1 ; j <= n ; j++)
            scanf("%d" , &r[i][j]);
    for(int i = 1 ; i <= m ; i += 2)
        for(int j = 1 ; j <= n ; j++)
            v[i][j] = MaxAns;
    v[1][1] = 0; // 初始化 
    for(int i = 3 , k = 2 , p = 4 ; i <= m ; i += 2){
        if(i > p)
            p = p << 1 , k++;
        // 更新当前的 k 和 p 
        for(int j = 2 ; j <= k ; j++){
            if(Get(i , j)){ // 确认状态 i 的第 j 位是否为 1 
                s = Replace(i , j);    // 利用位运算替换并得到状态 s 
                for(int l = 1 ; l < j ; l++)
                    v[i][j] = min(v[i][j] , v[s][l] + r[l][j]);
                for(int l = j + 1 ; l <= k ; l++)
                    v[i][j] = min(v[i][j] , v[s][l] + r[l][j]);
                // 枚举时 l ≠j，因为状态 s 的第 j 位一定是被替换的 0 
            } 
     }
    }
    for(int i = 2 ; i <= n ; i++)
        ans = min(ans , v[m][i] + r[i][1]);
    // 由于最后要回到起点，还需一个循环来寻找最终答案 
    printf("%d" , ans); 
    return 0;
}
```