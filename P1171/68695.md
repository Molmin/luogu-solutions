### 这道题就是著名的NP完全问题——旅行商问题。 

旅行推销员问题（英语：Travelling salesman problem, TSP）是这样一个问题：给定一系列城市和每对城市之间的距离，求解访问每一座城市一次并回到起始城市的最短回路。它是组合优化中的一个NP困难问题，在运筹学和理论计算机科学中非常重要。

最早的旅行商问题的数学规划是由Dantzig（1959）等人提出，并且是在最优化领域中进行了深入研究。许多优化方法都用它作为一个测试基准。尽管问题在计算上很困难，但已经有了大量的启发式算法和精确方法来求解数量上万的实例，并且能将误差控制在1%内。

[更多资讯尽在百度~~](https://www.baidu.com/link?url=jW14QepHXS7Zd58egAMi67DbHTj0z6e4Y7xoeUZMg8cET_jfzaz-DhyHkcoXQUzuix1xcP7RoMDBU8R01-22EqLeRAYtKPaLDErgodwJ0KtyKmzVQutDduYvzgRHjI_a5VBJP3sQdM2P2UQU_ZSbUa&wd=&eqid=fc2776f700058996000000055bb8a434)

这道题的做法，在更大规模上，会有更厉害的做法（~~虽然不是本蒟蒻所能理解的~~）在NOIP2006的提高组初赛最后一题有体现。

TSP问题已经成为了各种算法初出茅庐时的竞技舞台（遗传，模拟退火...）

~~下面切入正题：~~

本蒟蒻使用的也是状压DP，虽然和各位大佬一致，~~但调了很久，忍不住发一波题解...~~

这里用二进制串（状态压缩）表示集合。比如集合{1,3,5,6,7}表示成二进制串用1110101，其中集合里面有的数对应的位数写成1，没有的写成0。要判断第3位是不是1，就把 1110101右移(3-1)位，得到11101，然后结果和00001进行 & 运算，如果结果是1说明第3位是1，否则说明第3位是0。

综上所述，公式出现：对于数字x，要看它的第i位是不是1，只要判断((x >> (i - 1) ) & 1) == 1！

请看代码及注释：

```cpp
//Jesu Domine! Amen!
//日常求神拜佛请忽略。 
#include<iostream>
using namespace std;

int dp[21][20000];
int map[21][21]={0};
int n,s;

int main()
{
	cin>>n;
	for(int i=0;i<n;i++)
	for(int j=0;j<n;j++)
	{
		cin>>map[i][j];
	}//玄学输入... 
	for(int i=0;i<n;i++)
	{
		dp[i][0]=map[i][0];
	}//良心题面，连邻接矩阵都给了... 
	//但是，我们必须看到：第一行就是两点距离！
	//当初我竟然把这忘了... 
	for(int j=1;j < 1<<(n-1);j++)
	{        
    	for(int i=0;i<n;i++)
		{               
    	    dp[i][j]=0x7ffff;//初始化步骤一定要有哦！ 
     		if(((j>>(i-1))&1)==1) continue;  
        	for(int k=1;k<n;k++)
			{       
            	if(((j>>(k-1))&1)==0) continue;
            	if(dp[i][j]>map[i][k]+dp[k][j^(1<<(k-1))])
				{//动态转移在这里，决定转移的节点 
                	dp[i][j]=map[i][k]+dp[k][j^(1<<(k-1))];
            	}
        	}
   		}
	}//本人这一个循环有点翻转可能引起不适请谅解... 
	cout<<dp[0][(1<<(n-1))-1]<<endl;
	return 0;
}
//终于结束了，Amen！ 
```