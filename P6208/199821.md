一道 **移动类 DP** 入门题。

题目描述说，$(x,y)$ 可以移动到 $(x-1,y+1)$，$(x,y+1)$ 或 $(x+1,y+1)$。

换句话说，$(x,y)$ 只可能从 $(x-1,y-1)$，$(x,y-1)$ 或 $(x+1,y-1)$ 过来。

但是，我们希望金币越多越好。

所以，从 $(x-1,y-1)$，$(x,y-1)$ 和 $(x+1,y-1)$ 中找一个金币最多的就行。

得到状态转移方程：

$$dp(x,y)=\max(dp(x-1,y-1),dp(x,y-1),dp(x+1,y-1))+t(x,y)$$

在 $dp(x,y)$ 算出之前，$dp(x-1,y-1)$，$dp(x,y-1)$ 和 $dp(x+1,y-1)$ 肯定是要算好的。

所以要先枚举列，再枚举行。

另外要把 dp 数组初始化成一个很小的数。（就是这里让我调了很久。）

原因：比如说数据如下时：

```
3 4
1 1 1 1
1 1 1 1
1 25 1 1
```

如果 dp 数组初始值为 0，状态转移时 $dp(3,2)$ 就会变成 25，从而导致后面出错。

代码如下：

```cpp
#include <bits/stdc++.h>
using namespace std;
int r, c, t[110][110], dp[110][110];

int main()
{
	memset(dp, -0x3f, sizeof dp);
	scanf("%d%d", &r, &c);
	for (int i = 1; i <= r; i++)
		for (int j = 1; j <= c; j++)
			scanf("%d", &t[i][j]);
	dp[1][1] = t[1][1];
	for (int j = 2; j <= c; j++)
		for (int i = 1; i <= r; i++)
			dp[i][j] = t[i][j] + max(dp[i - 1][j - 1], max(dp[i][j - 1], dp[i + 1][j - 1]));
	printf("%d\n", dp[r][c]);
	return 0;
}
```
其实也可以逆推，方法和顺推类似，可以试着做一下。