### Solution1 暴力

首先拿到这个题我们首先想到的是暴力循环  
但是注意这肯定是不会让你全过的（至少我不会

------

### Solution2 线段树

究其原因是我们取出一段区间的和耗时间  
然后会想到线段树优化  
~~但是线段树又臭又长~~  
那么我们就拿出前缀和，用前缀和相减的方式表示区间和  

-----

### Solution3 单调队列

但是我们在这里首先要注意  
我们是**可以不取数字**的（如果最大子段和必须选则是负数的情况  

既然线段树这一条线被掐断了  
~~那么我们思维就得跳出去（毕竟求这个是dp过程~~  
考虑优化最先的定义  
如果我们要是枚举每一个i，都要进行枚举下一维，  
一定是爆炸的  
那么我们根据最大子段和的定义   
对于每一个以$i$结尾的数字  
其前缀和可以表示成
$$
\max\{sum[i]-sum[j],0\},j\in[i-m,i-1]
$$
我们考虑优化，就是固定$i$，那么这个式子就变成了  
$$
\max(0,sum[i]-\min\{sum[j]\}),j\in[i-m,i-1]
$$
很显然对于每一个$i$  
我们只需要知道最小的前缀和$sum[j]$就可以更新答案了  
同时我们还需要及时排除过时决策（  
因此我拿出了**单调队列**！  

------

为什么要用单调队列呢？   
首先明白答案上什么具有**单调性**   
这个题是最大子段和   
而且有长度限制  
所以是一定长度上的**前缀和单调递增**  
**队头**存储的下标的**前缀和最小**

因此我们**维护一个前缀和单调递增的单调队列**  
只有在这个单调队列里的下标其表示的前缀和才有可能会被更新  
然后及时排除过时决策就OK

-----

code:

```cpp
#include <iostream>
#include <cstdio>

using namespace std;
inline int Read() //快读
{
    int num = 0;
    char ch = getchar();
    bool flag = false;
    while (!isdigit(ch))
        flag |= ch == '-', ch = getchar();
    while (isdigit(ch))
        num = (num << 1) + (num << 3) + (ch ^ 48), ch = getchar();
    return flag ? -num : num;
}
// 数组模拟单调队列，前缀和
int q[500086], sum[500086];
// 队头，队尾，数字个数，数字限制 
//答案注意有可能是负数
int l, r, n, m, ans = -2147480000; 

int main()
{
    n = Read(), m = Read();
    for (int i = 1; i <= n; i++)
    {
        sum[i] = sum[i - 1] + Read();
    }
    // 队列初始化
    l = r = 1, q[1] = 0;
    for (int i = 1; i <= n; i++)
    {
        // 如果过时那么弹出队头
        while (l <= r && q[l] < i - m)
            l++;
        // 更新决策
        ans = max(ans, sum[i] - sum[q[l]]);
        // 如果队尾的前缀和大于当前的前缀和
        // 弹出这些前缀和
        while (l <= r && sum[i] <= sum[q[r]])
            r--;
        // 压进当前决策
        q[++r] = i;
    }
    printf("%d\n", ans);
    return 0;
}
```

------

做过其他单调队列的题你会发现都是一个特点

有一个东西和你要的一个答案相关  

然后这个答案要及时排除过时决策

~~基本貌似都是这个尿性~~

有空继续upd然后解释详细一点