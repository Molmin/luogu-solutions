这是一道考验思维~~找规律~~的题，很有可做性。

真 · 思考两小时 写码两分钟



------------
# 正文
## 题意
一个 n * m 的矩阵，从左上角（1 , 1） 开始，先向下走直到最下方，再向右走到最右，再向上走一个，再走到最左......一直走到（1 , 2）为止

然后问你走完第k步后当前的坐标



------------
## 分析

正常走然后算是不行的，时间太长，而且还很难写。

既然行走规则是固定的，那我们就试着找一下规律。

### 我们把行走分成两部分：

- **第一部分：从（1 , 1）开始一直走到（n ，1）的过程（也就是从左上角走到左下角的过程）。**

  这个过程我们可以知道，走完第k步的坐标是（k+1 ， 1）；
- **第二部分，从（n ，2）开始走回到（1 ， 2）的过程。**
  
  这个过程我们首先可以看出，当走到第 n - i 行时，若 i 是偶数，则是从左向右走，是奇数则相反；

然后问题就转化成了求当前行是从左往右走还是从右往左走，那我们就把 k 截取第二部分的步数，根据 k 与 m-1（因为第一行已经走过） 的商是否为偶数来判断走向，然后根据在当前行走的步数来确定具体走到哪一格；

这样的方法可以确定 y ，那怎么确定 x 呢？

~~你确定了行数 x 不就出来了吗~~


------------
## 代码

ps：注释掉的是我一开始的写法，思路一样但是比较冗余，化简后就是这个亚子了
```cpp
#include<iostream>
#include<cstdio>
#include<queue>
#include<cstdlib>
#include<cmath>
#define maxn 100010

using namespace std;

long long n,m,k,ans,x,y;

int main(){
	cin>>n>>m>>k;
	if(k<n){
		cout<<k+1<<" "<<1;
		return 0;
	}
	k=k-n+1;
	long long t=(k-1)/(m-1);
	long long q=(k-1)%(m-1);
	x=n-t;
	if(k==0){
		cout<<n<<" "<<1;
		return 0;
	}
//	if(q==0 &&t%2!=0){
//		y=m;
//		cout<<x<<" "<<y;
//		return 0;
//	}
//	if(q==0 &&t%2==0){
//		y=2;
//		cout<<x<<" "<<y;
//		return 0;
//	}
	if(x%2==0){
		y=q+2;
		cout<<x<<" "<<y;
//		if ( ((t%2)+1)%2==0 ){
//			y=m-q+1;
//		}
//		if ( ((t%2)+1)%2!=0 ){
//			y=q+1;
//		}
	}
	else cout<<x<<" "<<m-q;
//	cout<<k<<" "<<q<<" "<<t;
	return 0;
}
```

若有问题请及时告知我，制作不易，不喜勿喷，谢谢。