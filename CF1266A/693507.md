这道题我们需要判断 $n$ 个可能有前导 $0$ 的数是否可以通过重新组合数位的方式被 $60$ 整除，可以就输出 $red$，否则输出 $cyan$。显然使用字符串是一个极好的方法。 

我们来分析一下：一个能被 $60$ 整除的数，必然是个整十数（即最后一位为 $0$），并且是 $3$ 的倍数，它的十位（即倒数第二位）必须是偶数。同时满足以上三点的数就能被 $60$ 整除。  

转化到这个问题，我们做的就是要判断这个数的所有数位加起来是否为 $3$ 的倍数（众所周知，一个能被 $3$ 整除的十进制数，它的各个数位之和也能被 $3$ 整除，反之亦然）；判断它是否含有至少一个 $0$；判断它去掉一个 $0$ 之后是否各个数位上还能找出一个偶数。  

可能废话有些多，上代码： 
```cpp
#include<bits/stdc++.h>
using namespace std;
bool f(string s){//使用函数判断，简单明了
	int sum=0;//用于统计各个数位上数字的和
	bool a=0,b=0;
   //a用于判断是否有0，b用于判断除此之外还有没有偶数
	for(int i=0;i<s.size();i++){
		int x=s[i]-'0';//x表示这个数位上的数
		sum+=x;//统计数位上数字之和
		if(x==0&&a==0){
			a=1;
            //如果在此之前没有0则将a的值改为1
		}else if(x%2==0){
			b=1;
            //除此之外有偶数，让b为1
		}
	}
	if(sum%3==0&&a==1&&b==1)return 1;
 //同时满足有0，除掉一个0还有偶数，各个数位的数之和能被三整除则返回1
	return 0;
 //否则返回0
}
int main(){
	int n;
	cin>>n;//我们需要判断n个数
	for(int i=1;i<=n;i++){
		string s;//使用字符串进行判断
		cin>>s;
		if(f(s)==1){
			cout<<"red"<<endl;
		}else{
			cout<<"cyan"<<endl;
		}//输出不解释
	}
	return 0;
}
```
