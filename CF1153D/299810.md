## 想出来后才发现不是什么难题哈哈


刚开始看真是无从下手,想$dp$却又确定不了最大值。

但是突然发现答案具有单调性,那二分呀!!

**那我们直接去check这个二分的mid就好了**

设$dp[u]$表示$u$为了达到$mid$这个值,子树的最小花费(需要使用几个大于$mid$的值)

若$u$是叶子节点,$dp[u]=1$,因为只需要$u$选一个大于等于$mid$的填上

**当u不是叶子节点时**

显然当$u$节点取$max$时,在所有儿子中选一个最小的$dp[son]$即可

当$u$节点取$min$时,每个儿子都要达到$mid$,所以$dp[u]=\sum{dp[son]}$

那么1节点到达mid需要的最小花费是$dp[1]$

而一共有$k-mid+1$个数大于等于$mid$($k$表示叶子节点个数)

所以当$k>=dp[1]$时二分成功,继续缩小范围

[二分dp代码](https://paste.ubuntu.com/p/XYyphQrmsC/)

但是我竟然的发现树型dp的过程中完全没有用到二分的$mid!$

这说明每次$dfs$得到的$dp$数组相同,不需要每次二分都去$dfs$

**实际上连二分都不需要了**

回想一下设计的状态$dp[i]$

实际上就表示$i$节点要达到$x$,需要有$dp[i]$个比x大的数字!!

也就是$k-x+1>=dp[1]$

$x<=k+1-dp[1]$

$x$最大取$k+1-dp[1]$

$至于代码和那个二分的一摸一样,就是去掉了二分而已.$

