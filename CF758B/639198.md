# 题面

[题目传送门](https://www.luogu.com.cn/problem/CF758B)

**题目大意：**

四种颜色构成的花圈，其中任意四个一组颜色中没有重复颜色。要求补全原花圈所需的各种颜色数量。

# 思路

其实一些比较粗略的思路在前几篇题解里面都讲到了，这里带大家深入一下。

前面一篇指出了这个字符串必须得四个颜色重复构成，为什么？假如我把其中一个颜色往后推一格，那么中间空出来的格子就必须得用别的颜色，但是别的颜色与这个格子的间隔小于四，所以不能“舍人为己”地放颜色。

那么有了这个前提之后，我们就能知道每组中各个位置的颜色都是确定的，并且其他组相同位置的颜色也必须是一样的。我们可以设置四个动态下标和一个答案数组，其中四个下标指向的位置就是当前颜色在每一组中的位置，答案数组用于储存感叹号（不确定颜色）在每一组中相同位置出现的次数。让这个动态下标和答案数组联系起来，就能知道这个颜色在组中的位置进而知道所需要的颜色数量。

还有一点，面对一些强劲的数据时前面题解会输出错误答案。比如 $\verb!R!!!!$，我们知道，这三个感叹号除了 $\verb!R!$ 其他颜色都能填。但前面题解的思路和做法会直接不管，输出一些离谱的答案。那么对于这个问题，我们可以考虑设置初始值，让答案数组默认随便一个颜色就行了。但是你可能会问：那万一后来确定了不就有重复下标了吗？为了保证每组各个颜色位置确定，可以用交换变量的方式，我不能填，那就让我要填的那个格子去顶罪。

# 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
string s;
int ans[5]={0,0,0,0,0};//答案数组
int r=1,g=2,y=3,b=4;//动态下标，设置初值避免相同问题
int main(){
    cin>>s;
    for(int i=0;i<s.size();i++)
        switch(s[i]){
        case'R'://i%4+1的位置是R，找出替罪羊交换
        	if(g==i%4+1)
				swap(r,g);
			else if(y==i%4+1)
				swap(r,y);
			else if(b==i%4+1)
				swap(r,b);
            break;
        case 'G'://i%4+1的位置是G，找出替罪羊交换
        	if(r==i%4+1)
				swap(g,r);
			else if(y==i%4+1)
				swap(g,y);
			else if(b==i%4+1)
				swap(g,b);
            break;
        case 'Y'://i%4+1的位置是Y，找出替罪羊交换
        	if(r==i%4+1)
				swap(y,r);
			else if(g==i%4+1)
				swap(y,g);
			else if(b==i%4+1)
				swap(y,b);
            break;
        case 'B'://i%4+1的位置是B，找出替罪羊交换
        	if(r==i%4+1)
				swap(b,r);
			else if(g==i%4+1)
				swap(b,g);
			else if(y==i%4+1)
				swap(b,y);
            break;
        default:
            ans[i%4+1]++;//是感叹号，那么这个位置就需要多一个颜色
        }
    cout<<ans[r]<<" "<<ans[g]<<" "<<ans[y]<<" "<<ans[b];//联系下标和答案数组得到最终答案
    return 0;
}
```