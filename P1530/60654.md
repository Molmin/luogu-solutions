 ## [USACO2.4]Fractions to Decimals【分数化小数】
~~本奆鶸这道题做了三天，呜呜呜！  
我竟然看错样例输入卡了一天，忘记76换一行又卡一天，忘记计算整数部分的位数又卡一天。。。~~
这道题，_先输出整数部分及小数点_，然后：  
**1.整除。**  
输出0。  

**2.有限小数**  
求小数部分时直接输出，余数0结束。
我们知道分母质因数只有 2或5 时，这个数能被除尽，以此判断是否是有限小数。  

**3、无限小数**  
计算循环节，只要余数相同就是循环节。  

最后是~~恶心的~~输出。先算上整数部分及小数点的位数，接着用v记录是否有“（”，判断时用（i+v）%76即可。  
代*码*如*下*:
```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
int n,d,z=0,flag,v,a[110000],bk[1100000];
int main()
{
    scanf("%d%d",&n,&d);
    printf("%d.",n/d);//整数部分
    if(n%d==0){printf("0");return 0;}//整除
    int t=d;//准备计算能否除尽
    while(t%5==0)t/=5;
    while(t%2==0)t/=2;//先把2和5的因子去掉
    if(t==1)//如果没有别的质因数就会剩下1
    {
        while(n%d!=0)//余数0就除完了
        {
            n=(n%d)*10;//求小数部分
            printf("%d",n/d);
        }
    }
    else//否则就是无限循环
    {int q=n/d;v++;//小数点
    	if(!q)v++;//如果整数部为0要特判
    	while(q)q/=10,v++;//整数位数
        while(!bk[(n%d)*10])//这个余数没出现过
        {
            n=(n%d)*10;
            a[++z]=n/d;bk[n]=z;//记录这个余数的位置，待会有用
        }flag=bk[(n%d)*10];//重复的余数的位置就是加括号的位置
        for(int i=1;i<=z;i++)
        {
            if(i==flag)printf("("),v++;//括号算输出的一个位
            printf("%d",a[i]);//输出记录的数字
            if((i+v)%76==0)printf("\n");//76换行
        }printf(")\n");
    }return 0;
}
```