```
求求管理造造数据吧……
```

嗯嗯嗯感觉这是$\text{CSPJX2019}$最难的题，没有之一。

对于每个人，我们预处理出他**到达任意一个出口的最短时间**和**这个出口的编号（下称目标出口）**，不妨记为$t_i$和$id_i$。

对于一个出口，我们发现，如果它的限制$l_i$降为$0$，那么这个出口就不再有意义，直接删掉。这启发我们，用一个环形链表维护出口。不妨维护链表$nxt_j,pre_j$，分别表示当**沿逆时针**前进时，第$j$个出口的**下一个出口**和**上一个出口**。

容易想到将$t_i$按升序排序（相同时按$i$排序）。我们依次考虑每一个人。

显然，第一个人出去的出口就是他第一个到达的出口（因为不会有人跟他抢）。记他出去的出口为$j$，则$l_j=l_j-1$。

若此时$l_j>0$，则所有出口仍然可用。

若$l_j=0$，那么这个出口就不能再出人了。那么可以发现，我们要把所有原来所有目标出口为$j$的人的目标出口改掉，对于逆时针行走的人，目标出口变为$nxt_j$，到达时间也增加；对于顺时针行走的人，目标出口变为$pre_j$，同样增加到达时间。

对于后面的人，这个分析同样适用。

如果暴力更改所有人的目标出口和到达时间，时间复杂度将上升至$O(nm)$，无法承受。必须优化。

发现：如果两个人$i_1,i_2$开始时目标出口相同，那么只要他们还没有出去，他们的目标出口也一定相同。考虑对于每个出口$j$，维护一个变量，表示目标出口。

为了方便利用上文的$nxt_j,pre_j$数组进行维护，我们作如下处理：对于每个人$i$，记他的目标出口的**上一个出口**（以他的前进方向为基准）为他的**出发出口**$start_i$，那么在任何一个时刻，对于逆时针行走的人，他目前的目标出口为$nxt_{start_i}$；对于顺时针行走的人，目标出口为$pre_{start_i}$。这样，维护目标出口时仅需更改$nxt_j,pre_j$数组即可，时间复杂度降为$O(1)$。

但还有一个问题：我们要处理**到达时间**的更改。

可以发现，如果$l_j$降为$0$，那么所有以$j$为目标出口的**逆时针行走的人**，时间增加的量相同（就是$j$和$nxt_j$间的距离）；**顺时针行走的人**同理。

而我们每步要找出**到达时间最短**的人。也就是说，我们要维护一个**区间加，区间最值**的问题，想到用线段树。

为了方便进行区间修改，考虑更改排序方式。我们把**所有逆时针行走的人放在顺时针行走的人前面**；在同一段内，再**按位置排序**（不再按$t_i$的大小排序，改用线段树维护最值）。这样，每次修改的$t_i$都会尽可能相邻。

题中还有要求：同时到某一出口的人，编号小的优先。于是，设计另一个值$val_i=t_i\times n+i$，由于$1\leq i\leq n$且$t_i$都是非负整数，那么可以发现：当$t_i$不同时，一定是$t_i$小的那个$val_i$小；当$t_i$相同时，编号小的那个$val_i$小，正好符合了我们的需求。

综上，我们最终的算法是：

- 读入，预处理出数组$nxt_j,pre_j,start_i,val_i$；
- 排序，建线段树，记录每个人在树中的位置，顺便记录树中每个位置对应的人的编号；
- 每步找到$val_i$最小的人（这样的人一定唯一，因为$val_i$两两不同），确定这个人离去的出口$k_i$的值，并让$l_{k_i}=l_{k_i}-1$，在线段树中把这个人的$val_i$赋为正无穷；
- 如果$l_{k_i}=0$，在链表中删去出口$k_i$，同时在线段树中区间增加$val_i$的值（可以发现，一次最多更改$4$段区间）；
- 不断重复$3,4$步，直到所有人都找到出口（即线段树中的最小值就是正无穷），或者所有出口都满人（即修改时发现$l_{k_i}=0$且$nxt_{k_i}=pre_{k_i}=k_i$），此时终止操作；
- 根据$k_i$计算答案，输出，终止算法。

总时间复杂度$O((n+m)\log n)$。