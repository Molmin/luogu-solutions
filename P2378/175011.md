细节十分丰富的一道题，实际难度应该不止黄题，打了快半个小时才过。

我们先来分析一下题意，大概的意思是:

给你类似与$x^2+ax+b$的柿子，让你对他进行因式分解，将他写成$(x+a_1)(x+b_1)$的形式。保证计算过程中出现的数都是**整数**。

我一开始想的是十字相乘法，但发现有负数时较难处理。

然后注意到**保证计算过程中出现的数都是整数**

我想:

如果要求$a_1$与$b_1$,其实可以直接将柿子看做一个方程，直接利用公式求解。由于计算工程中出现的数都是**整数**,就不需要注意什么精度之类的问题了，直接用整形存储。

让后判定输出即可。

我的代码分为三部分

# 1.从原字符串中提取a,b

```cpp

void tiqu() {
	t=1;//判断正负
	for(int i=0; i<s.length(); i++) {
		if(s[i-1]!='^'&&s[i]!='^') {
			if(s[i]=='-') {//若有'-'
				t=-1;//将t修改为-1
			}
			if(s[i]>='0'&&s[i]<='9') {//若读入的是一个数字，则将对k进行更新
				k=k*10+(s[i]-'0');
			}
			if(s[i]=='x'&&!(s[i-1]>='0'&&s[i-1]<='9')) {//若读到一个x，说明系数读到头了，在此x前无数字，则将系数修改为为1
				if(f==0) a=1*t,f++,k=0,t=1;//别忘了重置k与t
				else if(f==1) b=1*t,f++,k=0,t=1;
			} else if(s[i]=='x') {//记录系数
				if(f==0) a=k*t,f++,k=0,t=1;
				else if(f==1) b=k*t,f++,k=0,t=1;
			}
		}
	}
	c=k*t;//加上才能AC
}

```
# 2.计算根

```cpp
void calc() {//直接使用公式即可
	x1=(-b+(sqrt(b*b-4*a*c)))/(2*a);
	x2=(-b-(sqrt(b*b-4*a*c)))/(2*a);
}
```

# 3.输出

这题的输出极为复杂细节十分之多，由于x1>x2,所以我先对x1进行判断,再一一分类输出。

但只要分请x1,x2的大小关系，以及a1,b1的大小关系。确定x1,x2谁前谁后，谁需要取相反数。

# 代码:
```cpp
void print() {
	if(x1==x2) {
		if(x1<0) printf("(x+%d)^2",-x1);
		if(x1>0) printf("(x-%d)^2",x1);
		if(x1==0) printf("x^2");
	} else if(x1>0) {
		if(x2<0) printf("(x+%d)(x-%d)",-x2,x1);
		if(x2>0&&abs(x1)>abs(x2)) printf("(x-%d)(x-%d)",x2,x1);
		if(x2>0&&abs(x1)<abs(x2)) printf("(x-%d)(x-%d)",x1,x2);
		if(x2==0) printf("x(x-%d)",x1);
	} else if(x1<0) {
		if(x2<0&&abs(x1)<abs(x2)) printf("(x+%d)(x+%d)",-x2,-x1);
		if(x2<0&&abs(x1)>abs(x2)) printf("(x+%d)(x+%d)",-x1,-x2);
		if(x2>0) printf("(x+%d)(x-%d)",x1);
		if(x2==0) printf("(x+%d)x",-x1);
	} else if(x1==0) {
		if(x2>0) printf("(x-%d)x",x2);
		if(x2<0) printf("(x+%d)x",-x2);
	}
}
 ```
 
 对于这种题目，一定要细心，不然错了就很麻烦。但若真错了，细心手动模拟造数据，一定还要有耐心，才能提交AC的代码。