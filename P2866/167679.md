## 一份好理解的单调栈
翻了一下其他题解,用单调栈的其实方法大同小异,但不用那么麻烦.

------------
- 首先分析思路,牛只能向右看,所以仅需扫一遍单调栈即可.
- 接下来,由于牛只能看见他右侧比他低的牛,所以我们可以考虑使用单调递减的栈:
对于新元素,若高度小于栈顶元素就加进来,同时更新答案 **(** 这个新元素能被栈内原有的所有牛看见(因为他是递减的),所以答案要加上top-1的数量,将看见转换为被看见去理解 **)**.
若高度大于等于的话就一个一个弹栈直到小于即可;

------------
具体实现见~~简短~~的代码:
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
ll ans=0;
ll a[100050]={0};
ll zhan[100050]={0};
int n,top=0;
int main()
{
cin>>n;
for(int i=1;i<=n;i++)
	scanf("%lld",&a[i]);
for(int i=1;i<=n;i++)
{
	while(top&&a[i]>=zhan[top])//一定要加上等于号!题意是严格递减.
	{
	top--;//弹栈
	}
	zhan[++top]=a[i];
	ans+=(top-1);//核心!可以自己手画模拟一下	
}
cout<<ans;
return 0;
}
```

