**解题思路：** 使用dfs求最短路，中间特判空白格子情况。详细解释请看代码。

**AC Code：**
```cpp
#include<bits/stdc++.h>
using namespace std;
inline int read()//快读 
{
    int x=0,k=1;char c=getchar();
    while(c<'0'||c>'9'){if(c=='-') k=-1;c=getchar();}
    while(c>='0'&&c<='9') x=(x<<3)+(x<<1)+(c^48),c=getchar();
    return x*k;
}
int m,n,g[110][110],ans[110][110];
int dx[]={1,0,-1,0};//x坐标的四个方向
int dy[]={0,-1,0,1};//y坐标的四个方向
void dfs(int x,int y,int f)//从(x,y)出发进入下一步搜索，f为1表示(x,y)有色，0表示无色 
{
	for(int i=0;i<4;i++)//从(x,y)，搜索下一个格子 
	{
		int nx=x+dx[i],ny=y+dy[i];//当前策略从(x,y)走到当前格(nx,ny) 
		if(nx>=1&&nx<=m&&ny>=1&&ny<=m)//如果当前格子的坐标没有越界记录相关信息 
		{
			int s=-1;//用s临时记录从上一格到当前格需要花的金币数 
			if(g[x][y]==g[nx][ny]&&g[nx][ny]!=0) s=0;//如果当前格子跟前一格颜色相同（非无色） 
			else //如果当前格跟上一格的颜色不同，或当前格为无色 
			{
				if(g[nx][ny]) s=1;//如果当前格有色且跟前一格颜色不同则临时记录要花一个金币 
				if(!g[nx][ny]&&f) s=2;//当前格没有颜色且前一格是有色的，可使用魔法，临时记录为两个金币 
			}
			if(s==-1) continue;//如果前一格是无色的，当前格子也无色，则本次无法到达，跳过 
			if(ans[x][y]+s<ans[nx][ny]||!ans[nx][ny])//如果当前格子已经到达过，且新的走法花费金币数更少 
			{
				ans[nx][ny]=ans[x][y]+s;//更新当前花费金币更少的走法 
				if(s==2)//如果当前格子是无色的，临时变色走到当前格子，需用特殊方法记录颜色信息 
				{
					g[nx][ny]=g[x][y];//把当前格子临时变色的颜色记录下来 
					dfs(nx,ny,0);//从当前格子(nx,ny)开始进行下一步搜索，且要把f置成0 
					g[nx][ny]=0;//本次走过之后，务必要将当前格子的颜色恢复成无色 
				}
				else dfs(nx,ny,1);//若当前格子是有色的常规格子，就直接进行下一步搜索 
			}
		}
	}
}
int main(void)
{
	m=read(),n=read();//m*m的方格棋盘上有n个各自带有颜色的格子（红色或黄色） 
	for(int i=0;i<n;i++)//n行给出了n个格子上的颜色信息 
	{
		int x,y,z;
		x=read(),y=read(),z=read();//坐标为(x,y)的格子上的颜色为z（0为红色，1为黄色） 
		g[x][y]=z+1;//g[x][y]为1表示(x,y)上的颜色为红色，为2表示为黄色，为0表示为无色 
	}
	ans[1][1]=1;//ans[i][j]表示到达坐标(i,j)上需要花费的金币数+1，最后结果要-1 
	dfs(1,1,1);//从左上角坐标(1,1)出发开始搜索，寻找到达右下角的最佳解 
	printf("%d",ans[m][m]-1);//输出右下角的数字-1 
}
```
PS：从我们老师处转载