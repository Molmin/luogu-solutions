来自蒟蒻的DFS题解：
首先题目的变化很多，处理时比较复杂（因为我是蒟蒻），注意细节也很重要。
单纯的DFS程序时间不行，所以要采用剪枝的方法。

```c
#include<bits/stdc++.h>
using namespace std;
int m,n,a1,b1,c1,minn=999999999;
int a[101][101]={0},e,c[101][101]={0};//a数组是存放棋盘的，c数组是标记目前到某个点的最优解。
bool b[101][101]={0},d[101][101]={0};//b数组是标记是否在目前路径上走过的点，d数组是标记棋盘中的某个点是否曾经到达过。
int q1[5]={0,1,-1,0,0},w1[5]={0,0,0,1,-1};//方向数组
int dfs(int xz,int yz,int o,int ans)//xz，yz为坐标，o表示上一位置是否用过改变无色方块的魔法，ans记录目前花费的金币
{
	int f=0;
	if(xz==m&&yz==m)//达到目标，判断答案是否更优
	{
		if(minn>ans)
		{
			minn=ans;
			++e;//说明题目有解，最后输出时判断用
		}
		if(o==1)a[xz][yz]=0;//如果最后一个点是无色的，返回前，要把他颜色改回来。
		return 0;
	}
	if(d[xz][yz]==0||c[xz][yz]>ans)//d数组判断他是否到过，从没到过就把状态更新一下。如果到过且目前节点的步数更优，也更新状态，否则return0，因为继续下去没意义（剪枝）。
	{
		c[xz][yz]=ans;
		d[xz][yz]=1;
	}
	else
	{
		if(o==1)//返回前，如果这个点原本无色，那么要将颜色改成无色
		a[xz][yz]=0;
		return 0;
	}
	int i,j,q,w;//w记录花几块钱，q记录是否用了魔法改变过无色方块
	for(int x=1;x<=4;x++)//四个方向搜索
	{
		q=0,w=0;
		i=xz+q1[x];
		j=yz+w1[x];
		if(i>0&&j>0&&i<=m&&j<=m&&b[i][j]==0)//判断是否越界或目前的路径中走过
		{
			b[i][j]=1;
			if(a[i][j]!=a[xz][yz])
			{
				if(a[i][j]!=0)//如果颜色不同，且下一个点有色那么花一块
				{
					w=1;
				}
				else
				{
					if(o==1)如果本身已经在原本无色方块上，就不能再到无色的方块了
					{
						b[i][j]=0;
						continue;//直接跳出循环
					}
					q=1;
                    w=2;
                    a[i][j]=a[xz][yz];//将无色方块颜色置成目前方块的颜色
				}
			}
			dfs(i,j,q,ans+w);
			b[i][j]=0;
		}
	}
	if(o==1)a[xz][yz]=0;//如果这个点原本无色，要将他改回无色状态
	return 0;
}
int main()
{
	cin>>m>>n;
	for(int x=1;x<=n;x++)
	{
		cin>>a1>>b1>>c1;
		a[a1][b1]=c1+1;//此处加一意思是，没有颜色的地方标记零，好区分。
	}
	b[1][1]=1;//开始的点自己要标记，说明走过了
	dfs(1,1,0,0);
	if(e>0) 
	cout<<minn;
	else
	cout<<-1;//e==0，说明题目无解，输出-1
}
```
