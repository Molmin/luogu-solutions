## BFS好题啊...

~~不过我是不会告诉你我才懒得写 BFS 呢（笑）~~

### 言归正传，讲暴力（~~正解~~）做法：

首先审题，发现病毒是向四方向传播的，每一个小时只能传播一格的距离...

所以病原体感染领主的时间不就是他们之间的距离吗...

**So** 这道题可以用计算**曼哈顿距离**来水过。

曼哈顿距离就是两个点之间的横纵坐标之差的和$ abs(x1-x2)+abs(y1-y2)$。

但是但是...

a和b的数据范围是$ 1e5 $耶...$ O(ab) $，但是不想放弃暴力（别管那个纯暴力水过了的巨佬$ QAQ $），我们考虑剪枝。

首先在读入的时候用一个$ map $数组记录病原体所在位置，再在下面读入领主位置的时候判断，去掉领主就是病原体的情况。

然后暴力$ O(ab) $去算（最坏情况）。

由于$ n $只有$ 500 $，总共也就只有$ 250000 $个位置，病原体占据了最多$ 100000 $，领主如果和病原体互不侵犯位置也会占有$ 100000 $个位置，那么必定有许多领主就是和病原体相邻的。

所以当统计这个领主感染时间时答案小于等于1了，直接$ break $，去找下一个领主的最短感染时间。

### 代码实现也十分简单，代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,k,t,a[100003],b[100003],c[100003],d[100003],ans[100003],xd[503][503];
signed main(){
	scanf("%d%d%d%d",&n,&m,&k,&t);memset(ans,0x3f3f3f3f,sizeof(ans));
	for(int i=1;i<=k;i++){scanf("%d%d",&a[i],&b[i]);xd[a[i]][b[i]]=1;}
	for(int i=1;i<=t;i++){scanf("%d%d",&c[i],&d[i]);if(xd[c[i]][d[i]])ans[i]=0;}
	for(int i=1;i<=t;i++){
		if(ans[i]&&(xd[c[i]-1][d[i]]||xd[c[i]+1][d[i]]||xd[c[i]][d[i]-1]||xd[c[i]][d[i]+1])){ans[i]=1;continue;}
		for(int j=1;j<=k;j++) ans[i]=min(ans[i],abs(c[i]-a[j])+abs(d[i]-b[j]));
	}
	for(int i=1;i<=t;i++)printf("%d\n",ans[i]);return 0;
}
```

500ms就可以跑过哦$ QwQ $

异常舒服（暴力和没开$ O2 $的$ BFS $跑一样快）

我是蒟蒻，巨佬勿喷