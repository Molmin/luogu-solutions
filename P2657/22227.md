本文章将同步到 [Luogu 博客](https://www.luogu.org/blog/mraymes) ~~以及 [WordPress 博客](https://mraymes.home.blog)~~ 这东西不支持 `Markdown` 所以没弄好.

一道 (稍微难一点的) 数位 DP 模板题.

数位 DP 貌似有两种做法, 一个是递推, 一个是用记忆化搜索. 这里将的是递推做法. ~~(因为我太菜了不会用记忆化搜索)~~

递推数组 `f` 定义: `f[i][j]` 表示位数为 `i` (包括前导零), 最高位为 `j` 的数中一共有多少个 windy 数.

程序分两步骤:
- 初始化 (即根据题目中的条件求出每个需要求的 `f[i][j]` 的值)
	- 这里切记: **任何关于前导零等特殊情况都不能在这里处理, 因为 "特殊情况" 并不适用于所有的情况.** 例如:

		`f[5][0]` 求的是以 `0` 开头的五位数, 其中像 `01357` 这样的数字是不被算进去的, 因为计算的时候将 `0` 也当做一个正常的数字, 并没有忽略掉. 一般来说这样的数字也算是 windy 数, 应该加进去, 但是如果它被当做一个后缀用来递推出六位数中 windy 数的数量, 即 `0` 不再是前导零时, 就必须要舍去了. 这个错误我在做另一题时也同样犯过. ~~(足以证明了我的菜.)~~

		因此, 在面对像前导零这样的情况时, 我们加一个 `g` 数组. 当一个有前导零的数不被作为后缀时 (即单独成一个数), 那么 `g` 数组的值就可以用来弥补漏算的数. `g[i]` 表示 `i` 位数有几个漏算的带有前导零的数.

	- 算的时候, 将长度比当前值小 1, 并且开头数字与当前要算的数字之差的绝对值大于等于 2 的所有 windy 数加起来即可. 具体见代码:

		```cpp
		for (int i = 0; i <= 9; i++) {
		    f[1][i] = 1;
		}
		g[1] = 2; // 漏算的数: 0, 1, 2
		
		for (int i = 2; i <= 15; i++) {
		    // i - 1 位中 0 与 1 开头的数都未被算进去
		    // 再加上已经处理完的 g[i - 1]
		    // (因为这些数也没有算在 f[i - 1][0], f[i - 1][1] 之中)
		    g[i] += f[i - 1][1] + f[i - 1][0] + g[i - 1];

		    for (int j = 0; j <= 9; j++) {
		        for (int k = 0; k <= j - 2; k++) { // 两位数差的绝对值 <= 2
		            f[i][j] += f[i - 1][k];
		        }
		        for (int k = j + 2; k <= 9; k++) { // 同上
		            f[i][j] += f[i - 1][k];
		        }
		    }
		}
		```
- 计算

	计算就是将要求的数字拆分成 10 的幂次方的倍数, 如 `24103` 可拆分成 `20000 + 4000 + 100 + 3`, 由此可知 `[0, 26503]` 区间内的 windy 数计算方式为 `(f[5][0] + f[5][1]) + (f[4][0] + f[4][1] + f[4][2] + f[4][3]) + (f[3][0]) + (f[1][0] + f[1][1] + f[1][2]) + f[1][3]`. 括号内的为一组, 根据数字的位数 (前导零算进去) 分组.

	更详细地讲:

	- `[0, 9999]` - `f[5][0]`
	- `[10000, 19999]` - `f[5][1]`
	- `[20000, 20999]` - `f[4][0]`
	- `[21000, 21999]` - `f[4][1]`
	- ...
	- `[23000, 23999]` - `f[4][3]`
	- `[24000, 24099]` - `f[3][0]`
	- `[24100, 24100]` - `f[1][0]`
	- `[24101, 24101]` - `f[1][1]`
	- `[24102, 24102]` - `f[1][2]`
	- `[24103, 24103]` - `f[1][3]`

	这里虽然类似 `f[4][1]` 的计算的并不是五位 windy 数的个数, 但是这些数是被当做**后缀**处理, 因此可以算. `2`**`0246`** 中, **`0246`** 为后缀. (这也就是前面为什么不能在第一步骤中处理前导零的原因, 因为 `0135` 本身是合法的, 但是作为后缀时, 如 `2`**`0135`** 就不合法了.)

	注意每一组的 `f` 数组的第二位最大只取到相应数位上的数减去 1, 那是因为 `f[5][2]` 是 `[20000, 29999]` 区间内的 windy 数的数量, `f[4][4]` 是 `[4000 - 4999]` 区间内 windy 数的数量, 以此类推, 而这些区间都不完全包括在区间 `[0, 26503]` 之内. 由于第一位为特殊情况, 需要单独加上 (`f[1][3]` 单独分一组, 见上述式子), 我们为了方便计算, 让计算函数 (`cnt()`) 处理形如 `[0, x)` 的区间 (`x` 不算进去). 由于函数处理的是**半开区间**, 调用的时候需要加上 1 (和 `sort()` 函数类似).

	```cpp
	// 求 [0, x) 区间内的所有 windy 数
	int cnt(int x) {
	    // 特殊情况 (其实也用不到)
	    if (x <= 0) {
	        return 0;
	    }
	
	    // 将数字的各个数位分离出来, 便于计算
	    int num[20];
	    int len = 0;
	    while (x) {
	        num[++len] = x % 10;
	        x /= 10;
	    }

	    int sum = 0;
	    // 枚举位数
	    for (int i = len; i >= 1; i--) {
	        // 当前为最高位
	        if (i == len) {
	            // 最高位取数无限制
	            for (int j = 0; j < num[i]; j++) {
	                sum += f[i][j];
	            }
	            // 是否存在带有前导零的数字 (num[i] 等于 0 无法保证)
	            if (num[i] >= 1) {
	                // 补充未计算的带有前导零的合法的 windy 数
	                sum += g[i];
	            }
	            continue;
	        }
	        // 非最高位
	
	        // 不超过上一位的数减去 2 (num[i + 1] - 2)
	        // 又保证不超过当前数位最大值 (num[i])
	        for (int j = 0; j <= min(num[i] - 1, num[i + 1] - 2); j++) {
	            sum += f[i][j];
	        }
	
	        // 至少为上一位的数加 2
	        // 又保证不超过当前数位最大值 (num[i])
	        for (int j = num[i + 1] + 2; j < num[i]; j++) {
	            sum += f[i][j];
	        }
	
	        // 如果到当前数位为止的前缀不合法则跳过
	        // 例如: x 为 54135
	        // i 为 2 (num[i] 为 4)
	        // 当前前缀为 54
	        // abs(5 - 4) < 2, 不合法, 因此跳出循环
	        if (i < len && abs(num[i] - num[i + 1]) < 2) {
	            break;
	        }
	    }

	    return sum;
	}
	```

	函数用法: (假设要求的区间为 `[l, r]`)

	```cpp
	cnt(r + 1) - cnt(l)
	```

最后贴上完整代码:
```cpp
#include <bits/stdc++.h>

using namespace std;

int f[20][10], g[20];
int l, r;

int cnt(int x) {
    if (x <= 0) {
        return 0;
    }
    int num[20];
    int len = 0;
    while (x) {
        num[++len] = x % 10;
        x /= 10;
    }

    int sum = 0;
    for (int i = len; i >= 1; i--) {
        if (i == len) {
            for (int j = 0; j < num[i]; j++) {
                sum += f[i][j];
            }
            if (num[i] >= 1) {
                sum += g[i];
            }
            continue;
        }
        for (int j = 0; j <= min(num[i] - 1, num[i + 1] - 2); j++) {
            sum += f[i][j];
        }
        for (int j = num[i + 1] + 2; j < num[i]; j++) {
            sum += f[i][j];
        }
        if (i < len && abs(num[i] - num[i + 1]) < 2) {
            break;
        }
    }

    return sum;
}

int main() {
    for (int i = 0; i <= 9; i++) {
        f[1][i] = 1;
    }
    g[1] = 2;

    for (int i = 2; i <= 15; i++) {
        g[i] += f[i - 1][1] + f[i - 1][0] + g[i - 1];
        for (int j = 0; j <= 9; j++) {
            for (int k = 0; k <= j - 2; k++) {
                f[i][j] += f[i - 1][k];
            }
            for (int k = j + 2; k <= 9; k++) {
                f[i][j] += f[i - 1][k];
            }
        }
    }

    while (cin >> l >> r) {
   		cout << cnt(r + 1) - cnt(l) << '\n';
   	}
    return 0;
}

```
