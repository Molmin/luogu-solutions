题目中说所有的 $n$ 个字符串首尾相接形成一个环，对于环的问题比较复杂不好考虑，我们把问题简化成一个从 $1$ 到 $n$ 的链，要求链上相邻两个位置不能取相同的数字。定义一个二维的状态 $dp[i][0]$ 表示前 $i$ 个位置满足相邻位置数字不同，且第 $i$ 个位置和第一个位置用不同数字的方案数。$dp[i][1]$ 表示前 $i$ 个位置满足相邻位置数字不同，且第 $i$ 个位置和第一个位置用相同数字的方案数。当我们求出 $dp$ 数组的值以后，最终答案里面首尾不能用相同的数字，所以最终答案就在 $dp[n][0]$ 里面。

下一步考虑状态转移，首先考虑如何求 $dp[i][0]$，如果第 $i-1$ 位置用的跟开头不同，当前位置就既不能跟开头相同，也不能跟 $i-1$ 位置相同，所以只有 $m-2$ 种可选数字。如果第 $i-1$ 位置用的跟开头相同，那么当前位置只要从 $m-1$ 种跟开头不同的数字当中选一个就行了。所以有：

$$dp[i][0] = dp[i - 1][0] \times (m - 2) + dp[i - 1][1] \times (m - 1)$$

同理，对于 $dp[i][1]$，因为已经确定了当前位置要填的数字，所有 $i-1$ 位置跟开头不同的数字都可以转移过来，所以：

$$dp[i][1] = dp[i - 1][0]$$

总的复杂度 $O(n)$，可以通过本题。

代码：

```cpp
#include <iostream>
#include <cstring>
#include <cstdio>
#include <algorithm>
#include <vector>

using namespace std;
typedef long long ll;
const ll MAXN = 1e6 + 5;
const ll MOD = 998244353;

//dp[i][0]表示前i个位置满足相邻位置数字不同，且第i个位置和第一个位置用不同数字的方案数
//dp[i][1]表示前i个位置满足相邻位置数字不同，且第i个位置和第一个位置用相同数字的方案数
ll n, m, dp[MAXN][2];

int main() {
    cin >> n >> m;
    dp[1][1] = m;
    for (ll i = 2; i <= n; ++i) {
        dp[i][0] = (dp[i - 1][0] * (m - 2) % MOD + dp[i - 1][1] * (m - 1) % MOD) % MOD;
        dp[i][1] = dp[i - 1][0];
    }
    cout << dp[n][0] << endl;
    return 0;
}
```
