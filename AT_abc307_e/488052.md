### 题意

$n$ 个人站成一圈，有 $m$ 种颜色，给每个人涂一种颜色，且相邻的人不同色。求涂色方案数，答案对 $998244353$ 取模。

这么简洁的题面，一般来说要么 DP 要么数学。巧的是，这题两者皆可。

## DP 解法

先看在序列上怎么做。

定义 $dp[i][c]$ 为前 $i$ 个人站成一列，相邻两个人颜色不同，且第 $i$ 个人颜色为 $c$ 的方案数。

在环上，我们只需要多考虑一步第 $n$ 个人和第 $1$ 个人的颜色是否相同。所以我们可以枚举第一个人的颜色，跑一遍序列 dp，然后把第 $n$ 个人和第 $1$ 个人的颜色相等的情况去掉，再求和。

即 $\displaystyle \sum_{clr1=1}^{m} \sum_{clrn\ne clr1} dp[n][clrn]$。

但是这样的空间复杂度是 $O(nm)$ 的，显然会爆掉。

考虑优化状态。发现我们并不关心最后一个人是什么色，我们只关心他和第一个人的颜色是否相同。而这样定义，等我们跑完 dp，最终的答案也不用循环来求了。

改定义 $dp[i][0]$ 为前 $i$ 个人站成一圈，且第 $i$ 人的颜色与第一人不相同的方案数；$dp[i][1]$ 为前 $i$ 个人站成一圈，且第 $i$ 人的颜色与第一人相同的方案数。

转移方程也很简单：

$dp[i][0]=(m-2)dp[i-1][0]+(m-1)dp[i-1][1]$.

$dp[i][1]=dp[i-1][0]$.

答案是 $dp[n][0]$。

```
#include <bits/stdc++.h>

using namespace std;
typedef long long ll;
const int MOD = 998244353;

ll n, m;
ll dp[2][1000010];

int main() {
	cin >> n >> m;
	dp[1][1] = m;
	for (int i = 2; i <= n; i++) {
		dp[0][i] = ((m - 2) * dp[0][i - 1] % MOD + (m - 1) * dp[1][i - 1] % MOD) % MOD;
		dp[1][i] = dp[0][i - 1] % MOD;
	}
	cout << dp[0][n];
	return 0;
}
```

## 数学解法

这其实是一个很经典的环形染色的数学题。

我们先考虑直线染色。

$n$ 个人排成一列，有 $m$ 种颜色的方案数很好算。第一个人有 $m$ 种颜色可以选，之后 $n-1$ 人每一个人的颜色都要与左边的人不同。因此总方案数为 $m(m-1)^{n-1}$。

再推广到环形染色。

记 $i$ 人排成环，涂 $m$ 种颜色的方案数为 $a_i$。

对于 $n$ 个人直线染色的方案数，我们尝试将其对应到环上。

如果第 $1$ 个人和第 $n$ 个人的颜色不一样，那把这种直线染法头尾相接，形成一个环，得出一种 $n$ 个人的环形染色法。

如果第 $1$ 个人和第 $n$ 个人的颜色相同，头尾相接后，可以把第 $1$ 个人和第 $n$ 个合并起来，得出一种 $n-1$ 个人的环形染色法。

因此 $a_{n-1}+a_n=m(m-1)^{n-1}$。其实到这里已经可以递推了，但我们还可以更进一步。

$a_{n-1}+a_n=m(m-1)^{n-1}=(m-1)(m-1)^{n-1}+(m-1)^{n-1}=(m-1)^n+(m-1)^{n-1}$.

移项得：$a_n-(m-1)^n=-(a_{m-1}-(n-1)^{m-1})$。

1. $a_n=(m-1)^n$，而 $a_2=m(m-1)$，与之矛盾，舍；

2. 否则令 $b_n=a_n-(m-1)^n$，则 $\frac{b_n}{b_{n-1}}=-1$，为等比数列。

	则 $b_n=(-1)^{n-2}\cdot b_2=(-1)^n\cdot b_2$，代入 $b_n=a_n-(m-1)^n$。
    
    得：$a_n=(m-1)^n+(-1)^n\cdot(m-1)$。
    
那我们只需要用一个简单的快速幂就可以了。

```
#include <bits/stdc++.h>

using namespace std;
const int MOD = 998244353;

long long n, m;

long long fpow(long long a, long long b) {
	long long mul = 1;
	while (b) {
		if (b & 1)
			mul = mul * a % MOD;
		a = a * a % MOD;
		b /= 2;
	}
	return mul;
}

int main() {
	cin >> n >> m;
	cout << (fpow(m - 1, n) % MOD + ((n % 2 == 1 ? -1 : 1) * (m - 1) + MOD) % MOD) % MOD << endl;
	return 0;
}
```
    
    
    
    