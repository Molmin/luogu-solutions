首先，这个丑数是基于线性递推的，因为对于第$k$个丑数我们显然不可能在$O(1)$时间求出。那么如何递推呢？

考虑前面的丑数如何转移到当前的丑数：必然是前面某个较小的丑数乘以某一个质因数得到。对于样例$[2,3,5,7]$来说，$7$后面的丑数$8$就是由之前的丑数$4$乘以$2$得到；对于$14$来说，它是由之前$7$乘以$2$得到。

但是这存在一个问题：我不知道是前面哪一个丑数乘以哪一个质因数得到当前的丑数。所以要解决这个问题。

这个时候要注意到一个单调性：丑数本身具有单调性。也就是说，后面的丑数一定比之前的丑数大。把这个反映到它的构成，即是：**若两个丑数都由之前相同的丑数乘以某一个质因数得到，那么大的丑数乘以的质因数更大；若两个丑数都由同一个质因数乘以不同的前面的丑数得到，那么大的丑数乘以的前面的丑数也更大。**

考虑利用这个性质。用数组$id$记录第$i$个质因数在构成比当前丑数更大丑数所用的最小的丑数下标。如果用$ans$数组来记录丑数的话，那么$id$数组的定义即是：一个最小的num，满足$primes[i]\times ans[num]>ans[now]$，其中$ans[now]$为当前的丑数，那么$id[i]=num$。由上面的单调性可知，这个$id$数组内的数单调递增。

因而我们就可以构建起这样的算法流程：

**对于每一个质因数$primes[i]$，找到能与它相乘大于当前丑数的丑数编号并记录，然后更新下一个丑数值。**

代码如下：

```cpp
    int nthSuperUglyNumber(int n, vector<int>& primes)
    {
        sort(primes.begin(),primes.end());
        int m=primes.size();
        vector<int>id;
        id.resize(m);
        vector<int>ans;
        ans.push_back(1);//初始化，1为最小的丑数
        for(int i=1;i<=n;i++)//再往后找n次
        {
            int min=2147483647;
            for(int j=0;j<m;j++)
            {
                while(primes[j]*ans[id[j]]<=ans[i-1])//逐一判定。但是由于id的单调性因而省去不少时间。注意不能去掉等号
                    id[j]++;
                if(primes[j]*ans[id[j]]<min)
                    min=primes[j]*ans[id[j]];//min就是当前大于它的最小丑数
            }
            ans.push_back(min);
        }
        return ans[ans.size()-1];
    }
```
（这里有必要说明一下：这里故意使用的我在力扣提交的代码，请各位不要抄袭）