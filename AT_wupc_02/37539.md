题意：给定一条长为N的路，每一单位的路段可能为 _X_ （水坑）或  _._  （空地），要求经过最少的水坑到达N这里，每一步可以走1、2、3单位长的距离。

可以使用动态规划（雾）来做，用一个一维数组，第i个元素存走到i时最少经过的水坑数，而第i个数的值应为i-1，i-2，i-3中最小的数加上当前是否是水坑，是就加1，否则不加。最后需要输出数组第N个数，即为答案。

公式：**f[i]=(road[i]=='X')+min(f[i-3],min(f[i-2],f[i-1]))**

```cpp
#include<bits/stdc++.h>
using namespace std;
int n;//路的长度
string road;//存输入数据
int f[110];//动态规划的数组
int main(){
    cin>>n;
    cin>>road;
    f[0]=(road[0]=='X');
    f[1]=(road[1]=='X');
    f[2]=(road[2]=='X');
    //前三个特判一下，免得-3，-2，-1出问题
    //也可以让数组从3开始，前三个元素置为0，下面循环到N+3
    for(int i=3;i<n;++i){
        f[i]=(road[i]=='X')+min(f[i-3],min(f[i-2],f[i-1]));
    }//动态规划过程
    cout<<f[n-1]<<endl;//我的数组从0开始，所以输出是第N-1个
    return 0;
}
```