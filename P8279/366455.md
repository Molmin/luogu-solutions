### 题目描述

+ 有一个长度为 $n$ 的整数数组 $a$。
+ $p,s$ 分别为这个数组的前缀、后缀异或和，即 $\forall i\in\mathbf{Z}\wedge1\le i\le n,p_i=a_1\oplus a_2\oplus\cdots\oplus a_i,s_i=a_i\oplus a_{i+1}\oplus\cdots\oplus a_n$。
+ 有一些前缀、后缀异或和未知，用 $-1$ 表示。刚好有 $n$ 个前缀、后缀异或和已知。
+ $1\le n\le10^5,\forall i\in\mathbf{Z}\wedge1\le i\le n,0\le a_i<2^{60}.$
+ 你只需要其中一个答案即可，保证至少有一个解。

### 题目分析

异或的性质大家都清楚吧，不清楚建议先查一下。

首先考虑没有后缀和的情况，和 A 题类似，输入的时候记录上一个异或和的值，当前的数字 $=-1\Rightarrow$ 直接输出 $0$，否则输出当前数字异或上一个异或和的值即可。

现在加入后缀和，我们只需要想办法把所有后缀和都转成前缀和就行了。发现只要求出整个数组的异或和，然后把它分别异或上每个后缀和的情况就可以得到它对应的前缀和。

怎么求总和呢？我们发现，$p_n$ 已经给出 $\vee s_n$ 已经给出 $\Rightarrow$ 整个数组的和可以轻松得出。$p_i$ 已经给出 $\wedge$ $s_{i+1}$ 已经给出 $\Rightarrow$ 总和也能得出，为 $p_i\oplus s_{i+1}$。

总和一定可以通过这种方式得出吗？答案是肯定的。为了方便描述，下面把 $s$ 数组左移一位，变成 $s_0,s_1\cdots s_{n-1}$。于是上面的算法就可以进一步简化。

我们可以得出，总和可以求出 $\Leftrightarrow\exists i\in\mathbf{Z}\wedge0\le i\le n,p_i$ 已经给出 $\wedge s_i$ 已经给出。考虑 $p_0,s_n$ 的实际意义，它们都是 $0$，所以已经给出。

接着会使用到[鸽巢原理](https://mp.weixin.qq.com/s?__biz=MzU3NTg3MTYyMQ==&mid=100006133&idx=6&sn=ef5ab6480b0a78ca09599402d233586c&scene=19#wechat_redirect)。小学数学书上有，忘了可以点击链接学习（其实不学也行）。我们根据上面的结论，发现一共有 $0\sim n$ 这 $n+1$ 种对应的关系，满足其中一条就可以得到总和。因为输入给出了 $n$ 个已知条件，我们又制造了两个已知条件（$p_0,s_n$），所以一共有 $n+2$ 个已知条件，至少会有两个已知条件对应，因此总和一定可以通过这种方式得出。

具体实现可以看代码

```cpp
//这里已经按照上面讲的左移过的顺序进行读入。
for(auto i = p.begin(), j = s.begin(); i != p.begin() + n + 1; ++ i, ++ j)
    if(*i != - 1 && *j != - 1)
    {
        sum = *i ^ *j; //如果两个都给出了，算出总和。
        break;
    }
last = 0;
for(auto i = p.begin() + 1, j = s.begin() + 1; i != p.begin() + n + 1; ++ i, ++ j)
{
    if(*j != - 1)
        *i = sum ^ *j;
    ++ cnt; //因为后面用了前置的递减，所以这里必须先加一下，同时也方便没有给出的情况。
    if(*i == - 1) //如果没有给出，那么增加一下计数器，方便之后输出 0。
        continue;
    while(-- cnt) //没有给出的全部输出 0。
        cout << "0 ";
    cout << (*i ^ last) << " "; //输出当前的答案。
    last = *i;
}
```
