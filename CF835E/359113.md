有趣。

众所周知，异或运算有自反性：$a\operatorname{xor}a=0$。

那么我们每次 Query 得到的值只可能是：$0$，$x$，$y$，$x\operatorname{xor} y$。  
其中，$y$ 与 $x\operatorname{xor} y$ 表示查询的集合中有奇数个 $y$，（即一个 $y$）。

我们想到，假若我可以确定在某一个集合中有且仅有一个 $y$，那么我可以通过二分的做法在 $\log n$ 的查询次数下找到 $y$。

那如何确定呢？

即考虑在什么时候 $p_1$ 和 $p_2$ 会被分开（即有何不同）。

唯一的条件是，$p_1 \neq p_2$。

那自然想到对下标做二进制分组：我们做 $\log n$ 次分组，第 $i$ 次分组将第 $i$ 位为 $1$ 的下标和 $0$ 的下标分到两边。

这样的话，我们可以在 $\log n$ 实现确定一个集合有且仅有一个 $y$。

但是这样最劣是 $3\log n$ 的，还差一点点。

发现在做二进制分组时，我们已经求出了 $p_1 \operatorname{xor} p_2$，那只需做一次二分求出 $p_1$ 即可。

[$\color{green}{\checkmark}$](https://codeforc.es/contest/835/submission/205528080)。