这个题很显然是可以用**dfs**解决的，无奈数据范围太大（1≤n≤10^100),高精又太复杂，~~作为一名资深数竞玩家~~,自然而然的联想到**Python+找规律**。

答案如下：
```cpp
ans=2*(n-1)//n为输入值，且n≥2
```


证明（这里运用了**数学归纳法**）：对于n=2结论显然成立。不妨设当n=k时结论成立，则最多可填入2*(k-1)个象，那么当n=k+1时，棋盘增加一行一列，那么又可以往里面放入两个象，此时答案为2*(k-1)+2,即**2*(k-1+1)**,那么由**第一数学归纳法**原理，结论成立.

Python代码如下：
```python
while True:
	n = int(input())
	print(2*(n-1))
```
PS:其实Java也自带高精，只不过不是默认，需要使用
```java
import java.math.BigInteger;
```
