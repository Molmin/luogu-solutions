# 题意

___


有 $n$ 天，每天可获得钱  $a_i$  

有 $m$ 个建筑，每个建筑有估算费用 $b_j$  和实际拆毁费用 $p_j$ 

问：  **当且仅当**   $a_{i}$  $\geq$ $b_j$  可以拆除,最多可以拆毁几个建筑?

 注意：估算费用不一定是满足一定大于等于实际拆毁费用的。

 ___

# 输入

___

-  **n** 天 **m** 个建筑

-  第 **i** 天可获得的经费 $a_i$

-  第 **j** 个建筑估算费用 $b_j$

-  第 **j** 个建筑实际拆毁费用 $p_j$

___


# 思路


___


通过思考，这个题因该显然是 **贪心**，所以我们要找到贪心策略。( why :  因为最终的答案一定是通过局部最优解所推得的全局最优解）

**先思考一个角度**
若考虑每天拆哪些建筑，并不容易实现，因为受预算和估测值的制约, **所以果断放弃该角度** 。

**换一个思路** ，考虑每个建筑在哪一天被拆。
**首先** 考虑第 $j$ 个建筑什么时候可以被拆,不考虑之前已经花费的钱数。
因此，当且仅当 $a_k$ $\geq$ $b_j$ 时，可以在第 $k$ 天拆，从而得出第 $j$ 个建筑可被拆除的时间是,满足 $a_k$ $\geq$ $b_j$ 条件的所有天。 
**进一步理解** ，对于第 $j$ 个建筑，我们只要在满足    $a_k$  $\geq$ $b_j$ 的最大的k那一天去考虑是否要拆它就行了,
因为如果还存在一个 $k_2$ 满足 $a_{k_2}$ $\geq$ $b_j$ ,并且 $k_2$ $<$ $k$ ,显然在 $k_2$ 那一天拆不如在 $k$ 这一天拆。因为不拆的话，可以把 ${p_j}$ 的钱省到第 $k$ 天来拆,选择 $k$ 不会比选择 $k_2$ 更差。


**如果在第  $k$  天有很多符合条件的建筑可以拆，怎么选择？**  显然是选择 $p_j$ 最小的拆掉。


**如果第 $k$ 天还有钱多怎么处理？** 
显然第 $k$ 天的钱只能用在第 $k$ ~$n$ 天，对于前 $k-1$ 天都是不能用的。那么我们就可以倒着枚举每一天钱往哪花。

#### 则 **贪心策略** 应是：对于一个建筑 $j$ 放在 $a_k$ $\geq$  $b_j$ 对应的 $day_{max_{isk}}$ （即最大的天是k）拆，若钱不足以全部拆除满足 $day_{max_{isk}}$ 号的建筑，拆最小的满足 $a_k$ $\geq$ $b_j$ 的最小 $p_j$ ，若仍有剩余处理其他的满足该条件的建筑。
**代码思路** ：
每一天都把当天能用的钱（不一定能直接拆毁）的建筑加入一个小跟堆里。每次从堆中取出 $p$ 最小的建筑拆毁,堆中 $p$ 最小的建筑也无法拆毁，加入还剩 $v$ 的钱，那么就把这些钱都投入到这个建筑中，把  $p$ 赋值为   $p-v$ 这样做的意义实际上就是为这个建筑攒 $ν$ 的钱，为了能在某一天把它拆毁掉。
___
# 代码实现
```cpp
int n,m,mx,tot,ans;
int a[N],b[N],p[N];
//less 是大根堆 greater是小根堆
//而priority_queue默认是大根堆
priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>> > q;
vector<pair<int,int>> s;
int main(){
    read(n),read(m);
    for(int i=1;i<=n;i++) read(a[i]);
    for(int i=1;i<=m;i++) read(b[i]),s.push_back(make_pair(b[i],i));
    for(int i=1;i<=m;i++) read(p[i]);
    sort(s.begin(),s.end());
    //逆序相当于对于一个建筑j放在该建筑对应的最大的天数k拆
    for(int i=n;i>=1;i--){
        mx=max(mx,a[i]);
        //按建筑估算费用从小到大，把实际费用放到在堆里
        while(tot<s.size()&&s[tot].first<=mx){
            int x=s[tot].second;
            q.push(make_pair(p[x],x));
            tot++;
        }
        //每次从堆中取出p最小的建筑拆毁
        while(!q.empty()&&a[i]>=q.top().first){
            ans++;
            a[i]-=q.top().first;
            q.pop();
        }
        //堆中 p 最小的建筑也无法拆毁，加入还剩v的钱，那么就把这些钱都投入到这个建筑中，把 p 赋值为p-v这样做的意义实际上就是为这个建筑攒ν的钱，为了能在某一天把它拆毁掉。
        if(!q.empty()){
            pair<int,int> u=q.top();
            q.pop();
            u.first-=a[i];
            q.push(u);
        }
    }
    write(ans);
    return 0;
}
```

