高精斐波那契数列

本题一看数据范围就知道是高精，很多人看到高精就不会了，因为高精确很好理解却很难打代码，这很让人头疼，其实不难，我将讲一个比较易懂实用的方法，希望对大家有所帮助

**上思路**

思路和斐波那契一样，不过特判a[0][1]=0a[1[1]=1,a[2][1]=1，之后，a[i][j]=a[i-1][j]+a[i-2][j]，这是主要公式，为什么开二维数组呢，因为用到高精，一直循环到n-m，这是斐波那契的主要思路，难点在于如何打高精，接下来我将讲如何打高精的代码

刚才提到的二维数组的第二维是进位用的，满十进一，每个数位加起来，就是高精了（不用字符和字符串），代码是这样

```
//因为1000的fb比较大，所以位数也要大，干脆就加600次
//PS：不会超时
for(int j=1;j<600;j++) 
  a[i][j]=a[i-1][j]+a[i-2][j];
//然后是进位，也是循环600次，看每一位是不是>9了
//如果某一位大于9，高一位++，该位-10，知道该位<10
for(int j=1;j<600;j++)
{
    while(a[i][j]>9)
    {
        a[i][j+1]++;
        a[i][j]-=10;
    }
}
```

**上代码的主要思路**

为了使大家好看代码，在代码上我就不写注意事项了，先在前面说清楚了，然后把无注释的代码奉上。

定义的n,m是输入的蜂房，t是存n-m的，a数组存走法，pd判断输出的最高位是不是0。

主函数首先输入m和n，t为n-m

特判0,1,2这三个数，因为这3个是已知的。

从3开始循环，一直到t，主要的高精代码在前面解释了就不在多说了。

然后该输出n的结果了，从600循环到2，如果该位是0且是最高位，那么不满足数字的要求，就循环下一位，如果该位！=0，那么pd变成1，证明如果再出现0就不是最高位了，可以输出这个0

**注意**

最后的个位是不能在循环里输出的，因为个位比较特殊，如果n是0的话，按照循环里面的规则的不满足输出数的规律的，所以最后一位放到循环里面的话，n==0是输出不了正确答案的，所以个位要放循环外面特判，这样就满足了所有的条件，这道题就能过了

S：因为答案是0的只有n==0，所以也可以刚开始就特判0，最后循环输出的时候加上个位，大家喜欢哪种就用哪种就好了

上代码

```
#include<cstdio>
using namespace std;
int n,m,t;
bool pd=0;
int a[1001][601];
int main()
{
	scanf("%d%d",&m,&n);
	t=n-m;
	a[0][1]=0;
	a[1][1]=1;
	a[2][1]=2;
	for(int i=3;i<=t;i++)
	{
		for(int j=1;j<600;j++) 
		a[i][j]=a[i-1][j]+a[i-2][j];
		for(int j=1;j<600;j++)
		{
			while(a[i][j]>9)
			{
				a[i][j+1]++;
				a[i][j]-=10;
			}
		}
	}
	for(int i=600;i>1;i--)
	{
		if(!pd&&a[t][i]==0)continue;
		pd=1;printf("%d",a[t][i]);
	}
	printf("%d",a[t][1]);
	return 0;
}
最后希望大家能看懂，有所帮助，谢谢