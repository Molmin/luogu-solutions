Hello，本蒟蒻来发题解了

 今天我们讲P5755 【[NOI2000]单词查找树】

# 这道题其实是一道看起来比较水的题
#### （但我调试了一小时）

首先，我们要对建树的过程有一个了解。对于当前被处理的单词和当前树：在根结点的子结点中找单词的第一位字母，若存在，则进而在该结点的子结点中寻找第二位.......

如此下去z直到单词结束，即不需要在该树中添加结点；或单词的第n位不能被找到，即将单词的第n位及其后的字母依次加入单词查找树中去。

**但，这道题只是问你结点总数，而非建树方案，且有37K文件，所以应该考虑能不能通过建树就直接算出结点总数？**

为了说明问题的本质，我们给出一个定义：一个单词相对于另一个单词差：设单词1的长度位L，且与单词2从第N位开始不一致，则说单词1相对于单词2的差位L-N+1，这是描述单词相似程度的量。

可见，将一个单词加入单词树的时候，须加入的结点数等于该单词树中已有单词的差的最小值。

单词的字典顺序排序后的序列则具有类似的特性，即在一个字典顺序序列中，第m个单词相对于第m-1个单词的差必定是它对于前m-1个单词的差中最小的。于是，得出建树的等效算法！

1. 读入文件
1. 对单词列表进行字典顺序排序
1. 依次计算每个单词对前一单词的差，并把差累加起来，注意：第一个单词相对于“空”的差为该单词的长度。
1. 累加和再加上1（根结点），输出结果

求结点数的过程如下表:

| 原单词列表 | 排序后的列表 | 差值 | 总计 | 输出 |
| :----------: | :----------: | :----------: | :----------: | :----------: |
| A | A |1  | 12 |  13|
|  AN| AN |  1|  
| ASP |AS  |  1|  
| AS | ASC | 1 |  
|  ASC|  ASCLL|2  |  
|  ASCLL|ASP  | 1 |  
| BAS |BAS  |  3| 
| BASLC |BASLC  | 2 | 

献上代码

```
#include<bits/stdc++.h>
using namespace std;
int i,j,n,t,k;
string a[8001];
string s;
int main()
{
  while(cin>>a[++n]);//读入文件中的单词存储到数组中
  n--;
  for(i=1;i<=n;++i)//或快排sort(a+1,a+n+1)
    for(j=i+1;j<=n;j++)
    if(a[i]>a[j])//两个单词交换
    {
       s=a[i];
       a[i]=a[j];
       a[j]=s;
    }
  t=a[1].length();//先累加第一个单词的长度
  for(i=2;i<=n;i++)//依次计算每个单词对前一单词的差
  {
    j=0;
    while(a[i][j]==a[i-1][j]&&j<a[i-1].length())j++;//求两个单词相同部分的长度
     t+=a[i].length()-j;//累加两个单词的差
  }
  cout<<t+1<<endl;
  return 0;
}
```
# 求赞




