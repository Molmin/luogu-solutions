## 由于本人今年CSP凉了，特来写写NOI的题以弥补内心的悲伤

### 1.题意
这道题其实重点不在算法难度上（$dalao:$~~橙题有什么难度？~~），好吧，其实是有一些不易注意到的坑，本蒟蒻在此跟大家填一填。

首先，这显然只会出现**大写的英文字母**，因此我们最开始就会想，是不是只要判断每个字母有没有出现就行了，然而，样例就告诉我们思路的错误性，因为每一个单词中是有优先级的！比如：
$$AS$$
$$ASCII$$
$$BASIC$$
如果我们用上面的方法去做，就会出现一种情况，程序告诉我们运行后出现过的字母有$A,B,C,I,S$，因此输出$5$，然后$WA$掉。

真正的树应该是这样的（由于本人没有建图软件，所以有些潦草，请见谅）：

[![Dn4Rk6.png](https://s3.ax1x.com/2020/11/18/Dn4Rk6.png)](https://imgchr.com/i/Dn4Rk6)

于是我们会发现，每个字母的优先级的大小（就是它是该单词的位置的前后），决定了它能否被合二为一。

同时，每一个节点（除了叶节点）能合并的条件是，它往上所有的父节点（它的父亲，它父亲的父亲......一直到根节点，当然根节点肯定只有一个），都必须与要合并的单词可以合并，这一个节点才能进行合并。

还有注意一点就是根节点也算一个节点

### 2.代码
```cpp
#include<bits/stdc++.h>
using namespace std;
string s[32770]; //存每一个单词。 
int main()
{
	int z=0; //存有多少个单词。 
	while (cin>>s[++z]); //输入每一个单词。 
	z--; //++z还要减回来。 
	sort (s+1,s+z+1); //按字典序排序。 
	long long sum=1; //存节点个数。 
	for(int i=1;i<=z;i++) //每一个字母开始循环起 
    {
        int j=0; //存可合并的有多少个数。 
        while(s[i][j]==s[i-1][j] && j<s[i-1].size())j++; //如果前一个可合并且此节点不为叶节点，即可合并。 
        sum+=s[i].size()-j; //sum加上单词的字母数量减去可合并的字母数量。 
    }
	cout<<sum; //最后输出答案。 
	return 0;
}
```

### 3.结语
这是本蒟蒻熬夜写完的，请大家多多支持吧！！！
# 谢谢观看！！！