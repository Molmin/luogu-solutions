翻译了一下官方题解.

首先是证明上界

先假设 $N\geqslant M$ ,
记 $H=2^N,W=2^M$.

我们取出 $W(W-1)/2$ 组满足 $1\leqslant j_1\leqslant j_2\leqslant W-1$ 的 $(j_1,j_2)$.

用 $f(i)(0\leqslant i\leqslant H-1)$ 表示 $S(1,i,j_1,j_2)$ 那么满足 $S(i_1,i_2,j_1,j_2)$ 是奇数的方案数就是使得 $f(i)$ 为 $0$ 的 $i$ 的数目乘上使得 $f(i)$ 为 $1$ 的 $i$ 的数目. 这个值的上界是 $(H/2)*(H/2)$ 因此答案的上界是 $\dfrac {H^2} 2 \times\dfrac{W(W-1)}2$

然后是证明上界能够被构造出.

当 $N=M$ 时, 我们使用数学归纳法证明.
此时的答案上界是 $2^{3N-3}(2^N-1)$
1. 当 $N=1$ , 填上 $1$ 即可.
2. 假设和 $N=K$ 时有解,
当前的最优答案是 $2^{4K-3}-2^{3K-3}$,
我们要构造出一个 $N=K+1$ 的解,
这个解的答案是 $2^{4K+1}-2^{3K}$,
首先我们把 $N=K$ 的解放在四个角上,
然后剩下了一个宽度为 $1$ 的一个 "十字形" 空,
我们在他的中间即 $(2^K,2^K)$ 填上一个 $1$ ,
其余的填 $0$ .

(然后官方题解说没时间了没有证明)

我们可以考虑中间点的贡献,
只要证明增加了这个中间点对答案的贡献是之前和之后的贡献之差即可.

当 $N>M$ 时,
我们可以把 $M$ 置为 $N$ 求解,
然后输出的时候按照给定的大小输出即可.

但是实际上实现的时候也没有必要这样写,
可以直接考虑每次在中间填一个数,
然后递归四个角,
这样可以在 $N=M$ 的时候同样正确.

(一般看到 $2^N$ 可以猜一下二分下去递归构造).

代码

```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 2e3 + 5;

int n, m;
int a[N][N];

void cons(int l, int r, int x, int y) {
    if (l > r || x > y) return;
    int mx = (l + r) >> 1, my = (x + y) >> 1;
    a[mx][my] = 1;
    cons(l, mx - 1, x, my - 1);
    cons(mx + 1, r, x, my - 1);
    cons(l, mx - 1, my + 1, y);
    cons(mx + 1, r, my + 1, y);
}

int main() {
    scanf("%d%d", &n, &m);
    cons(1, (1 << n) - 1, 1, (1 << m) - 1);
    for (int i = 1; i < 1 << n; ++i, puts(""))
        for (int j = 1; j < 1 << m; ++j) printf("%d", a[i][j]);
}
```