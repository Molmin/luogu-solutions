打表找规律出奇迹！！！

但本篇题解不仅会告诉你规律，还会告诉你是怎么找到的，同时也分享一下个人比赛时的经历。

做完 A 和 B 之后，一看 C，完全没思路（虽然好像很简单），D 和 F 也跳过了，看向可这个仿佛是结论的 E。

由于我 $A,B$ 做的很慢，不再做出一道就要掉 Rating,我就尽全力去搞这道题。

样例给的太简单，自己手推几个稍微大一点的，发现：答案的 $1$，$0$ 是分布的很均匀的，于是，第一次，我提交了这样的一种形式。

```cpp
101
010
101
```

手推了几个小样例，都能过，于是交了一发。

结果不出所料，只 A 了 $6$ 个点（没那么简单）。

之后手写了一个 $2^{2^{nm}} \times 2^{nm^4}$ 的暴力做法，打了一些小的表，但解太多，不好得出结论。

之后我又加了一些条件：只输出中心对称图形，然后我找到了这样一个图形。

```cpp
01000
10100
01010
00101
00010
```

然后我算了算 $n=3,m=3$ 的情况（如果找到更优解就直接退出，这样能更高效的判断是否存在更优解），好像是最优的。

再考虑 $n\neq m$ 的情况，可以将上述的图形复制几遍，打表得出，中间的几个无论填什么都可以。

交上去，也只 A 了$6$ 个点。

虽然这个方法 WA 了，但这为正解做了铺垫。

这时，我又看了看题目，发现，求的方阵是 $2^n-1,2^m-1$ 的形式，结合之前的方法得出，这可以用几个正方形拼起来。

而遇到这种 $2^n-1$ 的形式，可以用划分的方法解决，也就是说左上角，右上角，左下角，右下角都是一样的，然后中间的一行一列单独考虑，为了确保 $0,1$ 均衡，自己试了几个规律，最后发现了一个似乎是最优解的方法。

在最中间的格子填 $1$，然后处理左上角，右上角，左下角，右下角。

其实我比赛的时候交了很多次，只不过有小毛病，就不再提了。

当时的我其实不确定一个长方形是否能由几个正方形拼起来，所以我只写了正方形的情况。然后我加了一句：
```cpp
if(n<10||m<10)while(1);
```

出题人肯定会出 $n=10,m=10$ 的数据。

然后打开提交记录，我看到了 $16$ 个 T 和 $1$ 个A！

这比我看到 $16$ 个 A 和 $1$ 个 WA 还高兴！

我加上了长方形的情况，交了一遍。

AC 了？！

AC 了！！

排行榜上排名升了 $800$ 名，Rating++。（似乎 Rank 2 都没做出来这道题）

总结一下:遇到一些结论题，可以通过打表(oeis)的方法来找规律，同时可以通过剪枝的枚举（找到更优解就退出）来检验，在观察题目中的一些特殊性质（比如 $2^n$）和表的一些性质（$0,1$ 分布均衡）再加上手算得到最优解。

附上代码（重点在上面，代码没有难度）：

```cpp
#include<algorithm>
#include<iostream>
#include<iomanip>
#include<cstring>
#include<cstdio>
#include<cmath>
#define re register
using namespace std;
int n,m;
int mp[2052][2052];
inline void work(re int x,re int y,re int X,re int Y){
	if(x==X&&y==Y){
		mp[x][y]=1;
		return;
	}
	mp[x+X>>1][y+Y>>1]=1;
	int midx=x+X>>1,midy=y+Y>>1;
	work(x,y,midx-1,midy-1);
	work(midx+1,y,X,midy-1);
	work(x,midy+1,midx-1,Y);
	work(midx+1,midy+1,X,Y);
}
signed main(){
	int tmp=0;
	scanf("%d%d",&n,&m);
	if(n<m){
		for(re int i=1;i<=(1<<m);i+=(1<<n)){
			work(1,i,(1<<n)-1,i+(1<<n)-2);
		}
	}
	else{
		for(re int i=1;i<=(1<<n);i+=(1<<m)){
			work(i,1,i+(1<<m)-2,(1<<m)-1);
		}
	}
	for(re int i=1;i<(1<<n);++i){
		for(re int j=1;j<(1<<m);++j)
		printf("%d",mp[i][j]);
		putchar('\n');
	}
}
```
