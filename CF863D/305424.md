## 题意

给你一个数列 $a$ 和 $q$ 次操作，$m$ 次询问：求出操作完的数列的第 $m_i$ 个数字是多少。

操作分两种：给定 $t,l,r$。若 $t=1$，将每个 $x \in [l,r-1]$ 向右移一位，将 $a[r]$ 移动到 $a[l]$ 的位置。若 $t=2$，翻转区间 $[l,r]$。

## 思路

我在此介绍一个比较朴素的做法——倒推。对于每次询问可以 $O(q)$ 解决，因此不会超时。

我们倒着模拟，设最终下标为 $x$，我们可以这样来求初始下标：从最后一次操作开始，依次向前推出每次操作前的下标。

对于每次操作，如果 $t=1$，分类讨论如下：若 $x<l$ 或 $x>r$，那么 $x$ 不变。若 $x \in [l+1,r]$，那么 $x=x-1$，若 $x=l$，那么 $x=r$。

如果 $t=2$，分类讨论如下：若 $x<l$ 或 $x>r$，那么 $x$ 不变。若 $x \in [l,r]$，那么 $x=l+r-x$。因为这里反转前后对应下标之和为 $l+r$。

注意得出初始下标后要输出的是 $a_x$ 这一数值，而并非 $x$ 这一下标！

## 代码

根据思路，我们就可以写出以下精简的代码。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,q,m,a[200005],c[200005][5];
int main(){
    ios::sync_with_stdio(0);
    cin.tie(0);
    cin>>n>>q>>m;
    for(int i=1;i<=n;i++)cin>>a[i];
    for(int i=1;i<=q;i++)cin>>c[i][1]>>c[i][2]>>c[i][3];
    while(m--){
	int x;
	cin>>x;
	for(int i=q;i>=1;i--){
	    if(x<c[i][2]||x>c[i][3])continue;
            if(c[i][1]==1){
		if(x==c[i][2])x=c[i][3];
		else x--;
	    }
            else x=c[i][2]+c[i][3]-x;
	}
	cout<<a[x]<<" ";
    }
    return 0;
}
```
