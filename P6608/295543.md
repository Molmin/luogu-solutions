首先我们必须保证任意时刻 $a_i\leq i$。

因为如果 $a_i>i$ 那么我们再也无法操作 $i$ 这个位置了。所以我们任意时刻操作的数都是最小的 $i$ 满足 $a_i=i$。

也就是说，如果我们知道这个序列长什么样子，我现在就可以通过模拟知道它是否可以变为全 0。

正难则反，我们考虑倒着来搞，如果我们当前的序列是全 0 的。我们经过 $k$ 次逆操作，这个序列会变成什么样子？

这里定义逆操作为 选择最小的 $a_i=0$ 将所有 $j<i$ 的位置全部减一，将 $a_i$ 还原为 $i$。

我们可以打个表看一眼我们每次操作的位置构成的操作序列是什么：
```
1 2 1 3 1 4 1 2 1 5 1 6 1 2 1 3 1 7 1 2 1 8 1 4 1 2 1 3 1
9 1 2 1 10 1 5 1 2 1 3 1 11 1 2 1 4 1 12 1 2 1 3 1 6 1 2 1 13
```
我们惊奇地发现位置 1 每两次会操作一次。细想确实是这样，因为我们每次还原一个后面的数，都会使位置 1 减一。

进一步的，如果我们把所有位置 1 拿掉。我们会发现序列变成：

```
2 3 4 2 5 6 2 3 7 2 8 4 2 3 9 2 10 5 2 3 11 2 4 12 2 3 6 2 13
```

我们又惊奇地发现，位置 2 每三次会操作一次。细想也确实是这样，因为我们每次还原 2 后面的一个数，都会使 2 这个位置的数减一。所以每操作两次后面的数我都得回来操作一次 2。

进进一步的，如果我们把所有位置 2 拿掉。序列就变成了：
```
3 4 5 6 3 7 8 4 3 9 10 5 3 11 4 12 3 6 13
```

我们又又惊奇地发现，位置 3 每四次会操作一次。证明同上。

那么我们想，如果我能知道序列长度是多少，也能知道操作次数是多少，我们能否还原出这个序列？

答案是可以的，我们设 $b_i$ 表示位置 $i$ 的操作次数，则：
$$b_i=\lceil \frac{(n+k-\sum_{j<i}b_j)}{i+1} \rceil $$
 
含义是，对于第 $i$ 的位置，我们除去 $j<i$ 所有位置的操作数，每 $i+1$ 个位置，出现一次操作 $i$。

那么我们的初始序列 $a_i$ 也可以通过这个操作序列算出来:

$$a_i=\begin{cases}
0 & (\sum_{i\leq j}b_i)\bmod (i+1)=0 \\
i-((\sum_{i\leq j}b_i)\bmod (i+1)-1) & (\sum_{i\leq j}b_i)\bmod(i+1)\not=0
\end{cases}$$

这个式子的含义就是我现在把所有 $j<i$ 的操作都拿掉。那么之后每操作 $i+1$ 次 就会操作一个 $i$。那么我的周期就是 $i+1$ 。如果我的周期是完整的，那么我这个位置的初始状态就是 0。如果我的周期不完整，那么我剩的操作 -1 就是 $k>i$ 的最后一个周期的操作次数，每操作一次就会使我减小 1。

现在，我们只需要二分一下序列长度，算一下操作次数够不够就可以了。


