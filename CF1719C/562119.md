# CF1719C 题解
## 前言
这题好细节啊，似乎是我第 $3$ 道 $\ge$ \*1400 的 Div.2C。

由于是在 archive 里做的，所以放开交了（

下面请欣赏——

![](https://cdn.luogu.com.cn/upload/image_hosting/db7vkgud.png)
## 题意
翻译有点麻烦了，但是很准确。

简单地说就是给定 $n$ 个数，每次把 $a_1$ 和 $a_2$ 进行比较，大的作为 $a_1$，小的放到队尾。$q$ 次询问，每次给定下标 $i$ 和比较次数 $k$，求 $k$ 次比较中 $a_i$ 赢的次数。

注意，$a$ 是一个全排列，因此 $a$ 中**无重复元素**，这一点非常重要。
## 分析
### 0.时间复杂度
容易发现，$n,q\le10^5$，所以询问必须是 $O(1)$ 的回答，预处理也应该是 $O(n)$ 或者 $O(n\log n)$ 的。

这里我写的是 $O(n\log n)$ 的二分。
### 1.观察性质
注意到，当第 $i$ 个数轮到自己的第一次比较时，一定是与 $\max\{a_{[1,i-1]}\}$ 进行比较，因此我们可以找出它前面的最大值，然后比较。如果它比 $\max$ 小，那么它不可能赢任何一次。否则，它会赢至少一次。

但是这里注意到，当 $i=1$ 时，这个是不适用的，所以这题的第一个 corner case 就在这里（对于我的二分而言）。

接着我们观察，看到如果 $a_i$ 后面仍有一段连续的比 $a_i$ 小的序列，那么 $a_i$ 还会赢一些轮。

又可以发现一个 detail，那就是 $k\le10^9$，也就是说，有的数会一直赢。

容易发现这个数就是最大值，因为最大值一旦轮到队首会一直呆在那里。
### 2.寻找最大值
我们发现，对于 $a_i$，如果要求它能赢的次数，我们必须知道最大的 $j$ 使得 $a_{[1,j]}<a_i$，即第一个大于 $a_i$ 的数的前一个。

我们可以感性地把 $a_{[1,j]}$ 理解为 $a_i$ 的「势力范围」。

如何求这个 $j$ 呢？

$O(n^2)$ 的暴力肯定行不通。

容易发现，我们可以维护 $f[i] = \max\{s_{[1,i]}\}$，递推式也很好写，就是 $f[i] = \max(f[i-1],s[i])$。

接着，我们会发现 $f$ 是单调不递减的，可以二分。

于是我们可以愉快地二分到一个 $f[i]$ 使得 $f[i]\le s[i]$，然后 $[1,i]$ 就是 $s[i]$ 的「势力范围」。

这里我用的是 `upper_bound`。
### 3.处理询问
$k$ 是最为细节的地方。

首先，如果 $i$ 的 「势力范围」 在 $i$ 前面，那肯定没戏。

或者如果 $k$ 轮都还轮不到 $i$，那也没戏，即 $k+1<i$。

接着我们开始判断了：
- 如果 $s[i]$ 是最大值，那么答案就是 $k+2-i$。

当然这是错的，因为没有特判 $i=1$。

正确的答案见 code（~~其实是为了让你们好好看看代码，毕竟我调了几十分钟~~

- 否则，如果 $k$ 足够大，那么就是 $j+1-i$。

当然这也是错的，因为没有特判。

- 如果 $k$ 不够大，那么就是 $k+1-i$。

~~当然这也是错的，因为没有特判。~~

正确答案见 code。
### 4.关于 $i=1$
这个时候为什么要特判呢？

当 $i=1$ 且 $s[i]$ 为最大值时，显然会赢 $k$ 轮。

但是如果反之，$i$ 不为 $1$，那么会赢 $k+2-i$ 轮，比如当 $i=2$ 时，会赢 $k$ 轮，但是如果 $i=1$，此时 $k+2-i=k-1$，是不对的。

其他时候也是同理。

根本的角度来说，就是因为 $s_1$ 会参与第一轮，但是 $s_2$ 也会！
## 代码
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N = 2e5 + 7;
int s[N],a[N],ans[N];
void solve(){
	int n,q;
	cin>>n>>q;
	memset(a,0,n+10);
	for(int i=1;i<=n;++i){
		cin>>s[i];
	 	a[i] = max(a[i-1],s[i]);
	}
	for(int i=1;i<=n;++i){
		auto p = upper_bound(a+1,a+n+1,s[i]);
		if(*p!=s[i]) --p;
		ans[i] = p-a;
	}
	while(q--){
		int id,k;
		cin>>id>>k;
		if(ans[id]<id || k+1<id) cout<<"0\n";
		else{
			if(ans[id]==a[n]) cout<<k+1-max(id-1,1ll)<<'\n';
			else cout<<min(ans[id],k+1)+(id==1?0:1)-id<<'\n';
		}
	}
}
signed main(){
	//freopen("test.in","r",stdin); 
    ios::sync_with_stdio(0);
    cin.tie(0);cout.tie(0);
    int T;cin>>T;
	while(T--) solve(); 
    return 0;
}
```
## 总结
不要摆烂！

吃了很多发罚时仍然有可能 Accept，就像开头的图片一样。

**心态是最为重要的，在任何方面。**