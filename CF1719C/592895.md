## 大家好我非常不喜欢DS所以我没用DS做这道题

思路：二分找到第一个大于本士兵战力的第一个士兵，然后模拟即可。

以下令 $q$ 为被查询士兵的位置，$k$ 为战斗轮数。

$%另外还有几个特殊情况。$

1. 如果士兵是体力最大的那个（表现为他的战力等于总人数 $n$），那么他战无不胜，只要他一上场就开始连胜。所以胜利轮数为 $\max(k-q+2-[q=1],0)$。其中 $q-1$ 为他前面的人数，$q-2+[q=1]$ 为他刚好未加入战斗时的轮数。答案对 $0$ 取 $\max$ 是因为有可能他没上场时前面的答案为负数；减去 $[q=1]$ 是因为他站第一个位置和站第二个位置都$%一样参加第一场战斗，但前者多加了一个 \$1\$，要减掉。$是直接从第一轮起略杀全场，胜利轮数都为 $k$。

否则，二分出第一个大于本士兵战力的士兵的下标，记为 $r$。

2. 如果士兵站第一个位置，那他将会击败 $(1,r)$ 内的所有士兵。也就是说，答案是 $\min(k,r-2)$。

3. 如果 $r<p$，那么这意味着在这个士兵上场之前，已经有更nb的人霸占了这个场地，那么，他不可能赢，也就是直接输出 $0$。

4. 否则，$r>q$，他击败 $\min (\max(k-q+2,0),r-q)$ 人。$r-q$ 是因为他最多赢这么多人；$k-q+2$ 是他最多参加了这么多轮。

最后附上代码，注释是考场上写的。
```cpp
int n,m;
int a[N];
int maxa[N];//[1,i]内最大值。
bool major(){
	n=read();int qwq=read();
	for(int i=1;i<=n;i++)a[i]=read();
	for(int i=1;i<=n;i++)maxa[i]=max(a[i],maxa[i-1]);
	// for(int i=1;i<=n;i++)disp(1,maxa[i]);
	while(qwq--){
		int q=read(),k=read();
		if(a[q]==n){
			printf("%d\n",max(0,k-q+2-(q==1)));
			//站在第一个位置和第二个位置是一样的
			continue;//enter next query
		}
		//binary_search.
		int l=0,r=n+1;
		while(l+1<r){
			itn mid=l+r>>1;
			if(maxa[mid]>a[q])r=mid;
			else l=mid;
		}
		//r为第一个大于该点a值的下标；r!=q.
		if(r<q){puts("0");continue;}
		if(q==1){
			//r代表他最长能活多久。
			printf("%d\n",min(k,r-2));//第一个人只能打败(1,r)区间内的人
			continue;
		}
		printf("%d\n",min(r-q,max(k-q+2,0)));
		// disp(2,114,r);
	}
	return 114514;
}
```