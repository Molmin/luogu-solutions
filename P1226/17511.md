题目已经说明了要使用快速幂，当然这道题是一个模板题。

例如 实际上A^7=A^1\*A^2\*A^4这样每次计算乘法乘的因子都是递增的，而且还是指数递增，还有这些因子是可以递推产生的就是可以利用上次的计算每次平方就可以了，这中其实是使用的二进制的思想，因为任意一个数都可以，表示成二进制，故 A^N以定可以写成A^(一个二进制数如101010)=A^(100000)\*A^(00000)\*A(1000)\*A^(000)\*A^(10)\*A^(0)=A^(2^5)\*A^(2^3)\*A^(2^1)

下面给出的代码就是应用的这种思想并且这个算法是log2(n)(表示以2为底n的对数) 的复杂度，还有一个系数，大约是2 实际上计算次数就是2\*log2(n) 而普通的连乘计算的复杂度是n 乘法计算次数是n-1

这是代码：

```cpp
#include<iostream>
using namespace std;
long long b,k,p;//long long型的变量
long long work(long long a,long long b,long long c)//快速幂函数
{
    long long tt=a,ans=1;
    while(b)
    {
        if(b%2) ans=tt*ans%c;//如果是奇数就乘上外带每步取模
        tt=tt*tt%c;//做平方运算加每步取模
        b>>=1;//此处用右移而不是  /2  因为右移快一些
    }
    return ans%c;
}
int main()
{
    cin>>b>>k>>p;
    cout<<b<<"^"<<k<<" mod "<<p<<"="<<work(b,k,p);//苛刻的输出要求，注意  mod  前后的空格（刚开始被坑了TAT）
    return 0;
}//本蒟蒻代码不精，大神勿喷
```