# [博客食用效果更佳](https://www.cnblogs.com/qf-breeze/p/10415945.html)

## 前言：乘法的时间复杂度是O(1)，所以快速幂的时间复杂度O(logN)成立

## Input ：2 10 9

## Output：7

>2^10%9=7 没毛病

>普通幂:废物过程 可你有没有发现这个很烦？

>可是 算到2^64就炸了qwq （__int128啥的给我走开）

```
b=2,p=10,k=9
2^1=2 2%9=2 
2^2=4 4%9=4 
2^3=8 8%9=8 
2^4=16 16%9=7 
2^5=32 32%9=5 
2^6=64 64%9=1
2^7=128 128%9=2
2^8=256 256%9=4
2^9=512 512%9=8
2^10=1024 1024%9=7
```

> 递推幂：甚至还可以在优化 成 b^k-1%p*b 其实也就是递推 这样就好一丢丢吧 大数字的时候可以这样暂且优化一下（至少不容易爆精度） 也是比较有实用性的 orz 这样就可以得到 
```cpp
a[1] = b ;
    for (register int i=2;i<=k;i++) a[i] = a[i-1] % p * b ;
```

>这样不就是个递推了吗 海星 用数组只是好理解 而且不太会爆精度 不知道多少分（应该比较优秀的分数吧）

```
b=2,p=10,k=9
2%9=2 
2*2%9=4 
4*2%9=8 
8*2%9=7 
7*2%9=5 
5*2%9=1
1*2%9=2
2*2%9=4 
4*2%9=8 
8*2%9=7 
```
>看图 其实有一部分是循环节（我还复制了） 可以通过循环节来处理加速（不建议）万一没有循环节呢

>mod：是时候叫出快速幂（超级飞侠）来帮忙了 每次遇到困难...（不玩梗了）

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;
inline LL quickpow (LL x , LL y , LL mod){ LL ans = 1;//自定义函数可作为快速幂模型
	for ( ; y ; x = x * x % mod , y >>= 1) y & 1 ? ans = ans * x % mod : 0;
	return (LL) ans % mod ;
}
signed main() {
	LL b,k,p;
	cin >> b >> k >> p ;
	cout << b << '^' << k << " mod " << p << '=' << quickpow(b , k , p) << endl ;
	return 0;
}
```


 >这个代码可以作为模板使用
 ~~（背就完事了哪那么多话）~~