说起快速幂，大家可能有点陌生（如果你是第一次见过的话），当然会快速幂的人也可以看一下。

首先我先给大家举一个最简单的例子——乘法，为什么是乘法呢？等讲完了之后你就明白了。

大家肯定会竖式吧（不会的话那就没办法了），假设现在我们算71×29，如果你是直接用加法计算的话至少算29次效率肯定很低，当然如果你用竖式的话（竖式长这个样子）
```
        7  1

   *    2  9
————————————————————
     6  3  9

  1  4  2   
————————————————————
  2  0  5  9
```
如果我们依照竖式的思路的话，先算71×9，这样用加法就算9次，再算71×20，71×2算2次。还剩个10，很简单，往左移一位即可，时间复杂度O（log n(对数底数为10))，当然这个时间复杂度常数会非常大，假设计算99999×99999，那么常数就非常大，因为要加9次吗，所以我们不妨用二进制来算，将两个因数的最小的一个变为二进制数，因为99999=99999，所以我们就把99999化为二进制数，则二进制数为：
```
11000011010011111
```
从最右边的第一位开始，如果是1，就加上另外一个因数，反之则不加，然后再将这个因数加上自己变为2倍的自己。

这样的话时间复杂度就会降到O（log n（对数底数为2）），而且常数也很小。

但是一个是O（log n（对数底数为2））常数小，一个是O（log n（对数底数为10））常数大，到底哪个效率高。

要考虑效率谁高，我们就得从他们的最坏的时间效率算起。

O（log n（对数底数为2））常数最大是1，因为最多加1次。O(log n(对数底数为10）常数最大是9，因为最多加9次

好了，现在我们可以得出来两个式子 log n（对数底数为2）和9 log n（对数底数为10）我现在得比较这两个数的大小

如果我将这两个数同时除以9，就可以得到

```
（log n （对数底数为2））/9
log n（对数底数为10）
```

其实就是
```
log n （对数底数为512）
log n（对数底数为10）
```
这个就很好想了，因为512>10，所以还是O（log n（对数底数为2））效率高

但是有没有可能三进制，四进制……效率比二进制还高。

其实就是证明二进制效率是不是最高的。

其实就是证明2^（n-1）>n 即2^n>2n （n>2)

画个函数图像就行了，当n=2时函数f(x)=2^n 和 f(x)=2n 相交，等到n>2 时 2^n就开始指数爆炸单调递增了。而2n还是按照原来速度单调递增

因为本蒟蒻是一个数学蒟蒻，所以暂时无法直接证明。望大家谅解。

好了接下来就是说快速幂了，在c++中，目前没有乘方O（1）的算法，pow是O（n），现在我让大家来手算一个题

```
6745^7387 mod 10007
```
现在开始吧！

大部分人可能会直接竖式，但你不怕累的话(再不怕累看到这个也会累了，除非你是速算大神)

那我们怎么办？这个跟之前谈的乘法竖式是一样的，我们可以将指数从一个一个算变成log级别，当然还要利用之前的证明，用二进制最好，所以我们将7387变成二进制数（二进制数为1110011011011）

这时再用之前的思想，只不过换一下（1则乘，0则否，往左移，后平方）和之前的（1则加，0则否，往左移，后乘2）差不多，注意的是初始化为1，不为0，要不然就爆零。

这一下，就能很快地算出来6745^7387 mod 10007=8077了（几十分钟，当然肯定比7387次快），如果是几亿亿次方怎么办，没事，你就可以放心地交给我们伟大的计算机就可以了，即使是100亿亿次方（10^18）也秒出。
```cpp
#include<cstdio>
using namespace std;
int main(){
	int b,d;
	long long ans,a,k,c;
	scanf("%lld%d%lld",&a,&b,&k);
	c=a;
	d=b;
	ans=1%k;
	while(b){
		if(b%2){
			ans=(ans*a)%k;
		}
		a=(a*a)%k;
		b/=2;
	}
	printf("%lld^%d mod %lld=%lld",c,d,k,ans);
	return 0;
}
```
好了，现在我已经讲完了，现在我们来谈论一下这么好的东西会有什么用呢？

首先，它是个时间复杂度降级算法，所以这必然是个优化的好东西（如果你碰到需要连乘或乘方的话，二话不说，直接用快速幂。

现在就讲到这里了，拜拜（希望你能对此有收获）