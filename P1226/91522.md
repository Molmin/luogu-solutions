## 在这里讲一下快速幂的**原理**

## 快速幂是什么？
就是能把$pow(num)$算法效率达到$ O(log_2N) $。

利用的就是**二进制** 。

我们可以把$a^b$中的$b$拆成二进制，该二进制数第i位的权值是2^(i-1)

**E.X.** 当$b$=11时，$ a^{11} $ = $a^{2^0+2^1+2^3}$ ，~~很简单吧？~~

**Why** 11的二进制是$1011$，$11=2^{3}×1 + 2^{2}×0 + 2^{1}×1 + 2^{1}×1$

因此，我们将$a^{11}$转化为算 $a^{2^0+2^1+2^3}$ ，看出来快的多了吧原来算11次，现在算三次，那么**怎么算个数？**

有一个神奇的操作**&1**:取二进制的最末位,还可以判断奇偶。

还有一个神奇的操作**>>1**:二进制去掉最后一位。

其实也很好理解，以b=11为例，b=>1011,二进制从右向左算，顺序是 $a^{2^0}×a^{2^1}×a^{2^3}$，是从左向右的，我们不断的让$base$累乘即可。

## 实现

```cpp
ll Pow(ll a,ll b) {
	ll sum=1;//一定要初始化为1，不然返回0
	while(b) {//b!=0执行
    	//如果末位为1累乘
		if(b&1) sum=sum*a%Mod;//取MOD，题目要求
		a=a*a%Mod,b>>=1;//每操作一次，去掉末位
	}
	return sum;
}
```