## 题意

原题请看 <https://www.luogu.org/problemnew/show/P2375>

### 题目大意

给出一个字符串 $S$， 求 $\sum (num_i+1)$ ，其中对于字符串 $S$ 的前 $i$ 个字符构成的子串，既是它的后缀同时又是它的前缀，并且该后缀与该前缀不重叠，将这种字符串的数量记作 $num_i$ 

## 题解

根据 $KMP$ 算法的相关知识，我们可以发现，对于字符串 $S$ 的前 $i$ 个字符构成的子串，既是它的后缀同时又是它的前缀的串的集合就是 $A = \{next_i, next_{next_i}, \dots 0\}$. 

那么如果不考虑**不重叠**这个限制，我们可以得到一个 $cnt_i = |A|$，$cnt_i$ 可以通过 $cnt_i = cnt_{next_i} + 1$ 在线性时间复杂度内递推求出. 那么如何考虑这个限制呢?

我们可以发现，$Next_i$ 就相当于表示了点 $i$ 的父亲， 也就是说，所有 $Next_i$ 形成了一棵树（$Next_i$ 表示点 $i$ 的父亲），而我们要求的 $ans_i$ 就相当于点 $i$ 到根的路径上满足深度 $\leq \lfloor {i \over 2} \rfloor$的点的个数.  

那么就可以考虑**倍增后二分**，具体来说，就是对于每个点 $i$，找到 $pos = max\{x \in A \, | \, x \leq \lfloor {i \over 2}\rfloor\}$ ，那么 $num_i = cnt_{pos} - 1$，这个求解最大值的方法可以利用类似求 $LCA$ 的方法通过倍增来实现 $O(\log n)$ 的二分，具体实现可以看代码。这样总的时间复杂度就是 $O(n \log n)$ . 这个算法是**能够通过**的，但是需要一些卡常的技巧，比如……

> 倍增的数组可以是这样的：$fa[N][LOGN]$，也可以是这样的：$fa[LOGN][N]$
>
> 但是前者比后者慢**很多**！！！这点在 $N$ 比较大的时候尤为明显.
>
> **测试信息**
>
> 本人由于太懒，不想使用 $NOI \ Linux$，所以就用了**洛谷**。总计 $5$ 组数据，每组数据都是 $5$ 个长度为 $10^6$ 的全 $a$ 串。可以看到，时间相差了**接近 $3$ 倍**。
>
> ![https://cdn.luogu.com.cn/upload/pic/47252.png](https://cdn.luogu.com.cn/upload/pic/47252.png)

------

这样虽然可以卡过，但是不够优秀，这道题是有 $O(n)$ 的算法的. 可是优化的动机在哪里呢？

其实上面的算法中，倍增本质上是用来优化一个从点 $i$ 往上跳的过程，一个暴力往上跳的过程；如果这道题中这棵树就是普通的树（*指没有其它性质，节点编号也是乱的*），我们发现是很难优化到 $O(n)$ 的，也就是说，我们需要考虑一些 $Next_i$ 数组的特殊性质。

而我们要利用的性质，是一个非常显然而简单的性质：$Next_i \lt i$，这个性质由 $Next_i$ 的定义保证；这个性质在树上的表现是什么呢？就是**父亲节点的编号一定比其儿子节点的编号要小**，那么我们就可以这样做：

> 我们深搜树的同时，维护一个栈，中间有一个指针，它指向的数是栈中二倍不超过x的最大值。由于这个栈是单调递增的，所以指针只要左右移动。$ans_i$ 就是加入 $i$ 的那一刻，指针左边的数（包括指针所指的数）的个数+1.
>
> 参考 <https://www.luogu.org/blog/user31435/solution-p2375>, 写的非常好，用 $DFA$ 来分析此题

由于刚才那个性质我们可以保证中间那个指针只会向右移动，那么就可以做到在 $O(n)$ 时间复杂度内得到答案。

