由于要求最后的子序列是一个 $0,1$ 交替出现的串，一个很自然的想法是枚举每个元素属于哪个子序列。

考虑一个子序列，它的最后一位是 $0$ 。那么显然它的下一位只能是 $1$ 。这有点像纸牌游戏：黑 $6$ 只能接在红 $7$ 上。

那么我们就可以开若干个 vector ，来存储每个子序列。

对于第 $i$ 个元素，我们在所有 vector 中找一个能让第 $i$ 个元素接上去的序列，将它接上去。如果找不到，我们就只能为它单独开一个序列了。

然后您信心满满的交了上去，然后 `Time limit exceeded on test 4`

~~也许您是欧皇没 T ，反正我是 T 了的。~~

为什么呢？

考虑这样一组数据：

```
6
111111
```

按照我们的做法，每个字符都得枚举一遍所有序列，最后新开一个序列。如果整个字符串全部都是 $0$ 或 $1$ ，那我们的做法就相当于是个 $O(n^2)$ 的做法。然后 $1\le n\le 2\times 10^5$ ……~~您觉得您能 $n^2$ 过十万敬请尝试~~

怎么优化呢？

我们发现对于每个字符，我们实际上只想知道有没有一个能让它接上去的序列。如果枚举，这个过程中将做大量无用功。能否将这部分的时间节省下来？

当然是可以的。我们维护一下当前有哪些序列以 $0$ 结尾，哪些序列以 $1$ 结尾，那么对于一个元素，我们直接看它要接上的序列是否存在就好了：

- 存在，接上去；

- 不存在，新开一个。

至于怎么维护哪些序列以 $0$ 结尾，哪些序列以 $1$ 结尾，直接各开一个队列存储序列的编号就可以了。~~但是我因为贪图少打几个字符，开了两个堆，结果是多带了一个 $log$ 。~~

```cpp
#include <bits/stdc++.h>
#define min(x,y) ((y)^(((x)^(y))&(-((x)<(y)))))
#define max(x,y) ((x)^(((x)^(y))&(-((x)<(y)))))
using namespace std;
int t,n,cnt[200005];
string s;
priority_queue<int,vector<int>,greater<int> > p,q;
int main(){
    ios::sync_with_stdio(false);
    cin.tie(0),cout.tie(0);
    cin>>t;
    while(t--){
        cin>>n>>s;
        int k=1;cnt[0]=1;
        if(s[0]=='0')q.push(1);//对1来说，最靠前的以0结尾的序列编号是1
        else p.push(1);//对0来说，最靠前的以1结尾的序列编号是1
        for(int i=1;i<n;i++){
            if(s[i]=='0'){
                if(p.empty())q.push(++k),cnt[i]=k;//如果当前是0，而且没有以1结尾的序列，就只好单开一个了
                else cnt[i]=p.top(),p.pop(),q.push(cnt[i]);//否则接上去，把原序列从以1结尾的队列中删掉，换到以0结尾的队列中。
            }else{
                if(q.empty())p.push(++k),cnt[i]=k;
                else cnt[i]=q.top(),q.pop(),p.push(cnt[i]);//同上
            }
        }
        cout<<k<<endl;
        for(int i=0;i<n;i++)cout<<cnt[i]<<' ';
        cout<<endl;
        while(!p.empty())p.pop();//记得清空
        while(!q.empty())q.pop();
    }
    return 0;
}
```