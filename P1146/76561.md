## **题意概括：**
**给定一个长度为n的数列a[1],a[2],...,a[n],初始值均为0，现进行每次操作：选定该数列的某一个数不取反，其余n-1个数均取反。最终使得该数列值均为1。求最少的操作次数和字典序最小的操作方式。**

## **解题思路：**

这道题要解决两个问题：1、最少的操作次数。2、字典序最小的操作方式。

#### 第1问：最少的操作次数是多少？

对于数列的a[i],设a[i]取反的次数为b[i],显然b[i]为奇数。

设最少的操作次数为m,则有：b[1]+b[2]+ ... +b[n] = m * (n - 1),等式左边为偶数，等式右边的（n - 1）为奇数，所以m定为奇数。

同时有：（m - b[1]) + (m - b[2]) + ... +(m - b[n]) = m,设c[i]为a[i]不取反的次数, 则有c[1] + c[2] + ... + c[n] = m,因为m为奇数，所以全部的c[i]均为奇数，要使m最小，显然是让c[i]最小，所以c[1] = c[2] = ... = c[n] = 1，所以m = n，即最少的操作次数是n。

#### 第2问：字典序最小的操作方式是什么？

由于在第1问中得到c[1] = c[2] = ... = c[n] = 1,所以说明对于每个a[i],都有且仅有1次不取反的机会，所以怎么安排这些不取反的机会就很重要。

显然，要让字典序最小，就是让高位尽量小，又因为0 < 1，结合样例得到：对于第i次操作，选定a[i]不取反，其余n-1个数均取反是字典序最小的操作方式。

## **代码实现：**
```cpp
#include <cstdio>

const int MAXN = 100;

bool a[MAXN + 5];

int main() {
	int n;
	scanf("%d", &n);
	printf("%d\n", n); //n就是最少的操作次数
	for(int i = 1; i <= n; i++)
		a[i] = 0; //初始序列均为0 
	for(int i = 1; i <= n; i++) {
		for(int j = 1; j <= n; j++) {
			if(i != j) //第i次让a[i]不取反 
				a[j] = !a[j];
			printf("%d", a[j]);
		}
		putchar('\n');
	}
}
```
