# 这题好水啊！！！！！


## 翻n-1枚硬币，就是有一枚不翻，也可以理解为翻一枚
### 其实这题我~~想了好久~~，广搜，深搜，~~暴搜（下下策）~~……~~（因为老师说这题是搜索，emmm~）~~

然后才发现：

## 翻n-i枚硬币，就是有一枚硬币没有翻，相当于翻了一枚硬币

所以题目就变成了：

#### *在桌面上有一排硬币，共N枚，每一枚硬币均为正面朝上。现在要把所有的硬币翻转成反面朝上，（再次重申，0或1就是正或负，也代表正反两面），题意是每次可翻转任意1枚硬币（正面向上的被翻转为反面向上，反之相反）。求一个最短操作序列（将每次翻转N-1枚硬币就是一次操作）。*


## 很简单是不是？上代码！
```
#include<bits/stdc++.h>
using namespace std;
bool a[101];//,因为数据最大是一百，所以数组开到101。
//我上次就因为开小了，就QAQ。
//a数组负责存储硬币的状态
int n;
int main()
{
    cin>>n;
    cout<<n<<endl;//因为相当于只翻一枚，所以翻n次即可
    for(int i=0;i<n;i++)//i表示这是第几次翻
    {
        for(int j=0;j<n;j++)//表示当前翻得是第几枚硬币
        {
            if(j!=i)//如果j不等于i,则两数不相等，即一正一反
            {
                if(a[j])//也可以表示成if(a[j]==ture)或if(a[j]==1),新手最好写成这样，易于理解。意思是如果不为第i枚 。                        
                {
                     a[j]=false;//利用bool数组的非负即正的性质来翻面。0与1就代表负和正，即正面和反面。
                }
                else//也可以表示成if(!a[j])、if(a[j]==false)或if(a[j]==0)。意思是如果为第i枚 。
                {
                    a[j]=true;//翻面
                }
            }
            cout<<a[j];//处理一个就输出一个，很快捷。
        }
    }
    return 0;//完结撒花！！！！！
}
```
### 代码完结，从这一题我们知道或复习了**bool**数组的性质，非负即正（记住，它 _极其好用_ ）
# 拜拜～(￣▽￣～)(～￣▽￣)～ 

