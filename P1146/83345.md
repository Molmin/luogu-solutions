~~一道水的不能再水的题~~

纯模拟直接AC~~~O(∩_∩)O

讲一下主要思想：如果仔细审题，不难看出，只要把正面向上的硬币翻动奇数次，则他一定会变成反面向上。所以每经过一个硬币就把除这个硬币以外的硬币都翻动一下，一定能达到要求。（因为除掉这个硬币以外只剩N-1个硬币，题目又说N是偶数，所以上过小学的同志们都知道，N-1必定是奇数）

起初本蒟蒻是利用for循环来实现翻动的，后来发现好像有BUG：
	
    for(int i=1;i<=1;i++)
    {
    	cout<<"xxx";
    }
    
本蒟蒻惊喜的发现：运行结果竟然是"xxx"而不是没有！！！
于是本蒟蒻又改成了while循环
	
    int p=1;
    while(p<1)//这下就不会一下子就执行了
    {
    	cout<<"xxx";
    }

没错，运行结果确实是什么都没有。然后本蒟蒻又惊喜的发现：while循环放到实际程序里太麻烦了。作为蒟蒻的我当然无法胜任这么复杂的操作TAT。。。——然后我又发现，要用两个for翻动前面的和后面的硬币，前面翻一次不该翻的硬币，后面再翻一次不就等于什么都没干么？？好像问题就这样解决了诶！！！(本蒟蒻表示很高兴〃'▽'〃)
	
    int n=0; 
	for(int i=1;i<=1;++i)
    {
    	if(n==0)
        {
        	n=1;
        }
        else
        {
        	n=0;
        }
    }//第一次翻了不该翻的硬币
    for(int i=1;i<=1;++i)
    {
    	if(n==0)
        {
        	n=1;
        }
        else
        {
        	n=0;
        }
    }//第二次又把它给翻回来了
    
很神奇对不对？？？~~反正本蒟蒻不信~~

好了废话不多说，接下来请欣赏本场重头戏——无敌的AC代码！！
    
    #include<iostream>		//不用说了-_-||
	using namespace std;
	int a[1000001];    //这里用来存储硬币的状态：0为正，1为反
	int main()
	{
		int n;
		cin>>n;    //输入硬币的枚数
		cout<<n<<endl;    //一共要翻动n次，每次不翻第i枚，所以
    //总共只需翻n次，直接输出n。
		for(int i=1;i<=n;++i)//通通初始化为0，及正面朝上
		{
			a[i]=0;
		}
		int p=1,p2,po,po2;//用while循环时用的指针，废物变量，
        //不要管它
		for(int i=1;i<=n;++i)//现在开始从第一个硬币开始翻动
		{
			for(int k=1;k<=i;++k)//翻动第i枚硬币前面的
			{
				if(a[k]==1)//翻动，是0则1，反之亦然
				{
					a[k]=0;
				}
				else
				{
					a[k]=1;
				}
			}
			for(int k=i;k<=n;++k)//翻动第i枚硬币后面的
			{
				if(a[k]==1)//同上
				{
					a[k]=0;
				}
				else
				{
					a[k]=1;
				}
			}		
			for(int k=1;k<=n;++k)//状态输出
			{
				cout<<a[k];
			}
			cout<<endl;
		}
        while(1)//反作弊，谁都不想棕名对吧？？？
	}