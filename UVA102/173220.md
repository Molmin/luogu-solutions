## Problems
题目会给出若干组数据，每组数据都有 $9$ 个数，现在要你求用最少的移动步数，使得每个垃圾桶只包含一种颜色的瓶子
## Answer
由于题目中只有 $3$ 种颜色的玻璃，分别为棕色($B$)，绿色($G$)和透明($C$)，通过排列我们可以发现，将三种颜色排列只有以下 $6$ 种情况：$BCG,BGC,CBG,CGB,GBC,GCB$

接下来问题就变得简单了，我们只需要根据以上 $6$ 种排列去枚举 $6$ 种不同的方案，然后再进行比较，得到最小比较次数在数组里的位置。最后输出即可

## Code
```pascal
var
    i,min,k:longint;
    f:array[0..6]of longint;
    a:array[1..3,1..3]of longint;
    s:array[1..6]of string=('BCG','BGC','CBG','CGB','GBC','GCB');//将6种情况存好
begin
    while not eof do//因为数据的组数不清楚，所以需要用eof来判断文件是否结束
    begin
        readln(a[1,1],a[1,2],a[1,3],a[2,1],a[2,2],a[2,3],a[3,1],a[3,2],a[3,3]);//表示每种颜色所能接受的瓶子数
	f[1]:=a[1,2]+a[1,3]+a[2,1]+a[2,2]+a[3,1]+a[3,3];
        f[2]:=a[1,2]+a[1,3]+a[2,1]+a[2,3]+a[3,1]+a[3,2];
        f[3]:=a[1,1]+a[1,2]+a[2,2]+a[2,3]+a[3,3]+a[3,1];
        f[4]:=a[1,1]+a[1,2]+a[2,1]+a[2,3]+a[3,3]+a[3,2];
        f[5]:=a[1,1]+a[1,3]+a[2,2]+a[2,3]+a[3,2]+a[3,1];
        f[6]:=a[1,1]+a[1,3]+a[2,1]+a[2,2]+a[3,2]+a[3,3];//以上6句为计算每种排列所得到的交换次数
	min:=f[1];k:=1;
	for i:=2 to 6 do
	        if(f[i]<min) then
		begin
		        min:=f[i];
			k:=i;
		end;//找到最小的交换次数
	writeln(s[k],' ',f[k]);//输出是那种排列以及这种排列的交换次数
    end;
end.

```