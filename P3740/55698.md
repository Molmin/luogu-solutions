## 感觉本题真不难
一看题目，便觉得应是数组上的操作

#### 正常思维肯定是从第一块想后覆盖，最后顺着扫一遍计数输出。

这应该会**TLE**的。~~但据说过了。（真水）~~

首先来看离散化，并不是太好办的。

##### …………而且难写，这是关键！！！

所以嘛，从最后贴上取得一个开始就可以了，不覆盖，只添加。

### ~~（一下解说有点脑洞）~~

既然从头往后不行，为何不从结束状态考虑：覆在同一层上的，只有最后一个可以看见。那么，没覆过的记为0，覆盖过的记录编号，遇上已被覆盖过的格子，直接跳到该格子编号对应的末尾（应为保证中间任何一个格子是已经被覆盖的）。

废话不多说，献上31行的代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int num[10000010];
int n,m,out; 
int in[10010][2];
int main()
{
	cin>>n>>m;
	for(int i = 1;i <= m;i++)
	{
		cin>>in[i][0]>>in[i][1];		//先读下来
	}
	for(int i = m;i >= 1;i--)			//从后向前
	{
		bool l = 0;
		for(int j = in[i][0];j <= in[i][1];j++)
		{
			if(num[j] == 0)
			{
				if(l == 0)
				out++;			//记数
				num[j] = i;		//填充
				l = 1;			//标记，以免重复技术
			}
			else
			j = in[num[j]][1];  		//跳跃
		}
	}
	cout<<out;
	return 0;
}
```
