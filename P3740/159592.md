## 本蒟蒻发布下题解，请勿喷
## 我比较弱，在老师（~~超神犇~~）和同学（~~神犇~~）的全力讲解下，终于会了线段树的解题方法（~~然而只会线段树~~）
# 区间树和点树都可以，先讲区间树(只讲大意)
![69519](https://cdn.luogu.com.cn/upload/pic/69519.png )
## 看清题目的输入要求，虽然题目输入的是1到4，但是因为题目给的数据是单位区间而不是坐标，所以真实的坐标表示应该是1到5
```cpp
for(int j=1;j<=m;j++)     
      {
      scanf("%d%d",&b[j].l,&b[j].r); 
       b[j].r++;//需要加1，来表示真实坐标    
       k[++id]=b[j].l;
       k[++id]=b[j].r;
       //k数组把坐标记下来，待会要用
      } 
```
## 然后，再注意一下，题目给的海报长度n<=10000000,因为线段树的构造原理，我们至少要建4乘以长度，同时时间复杂度（n*log(n)），所以直接处理的话，肯定就炸了，所以我们要离散化
```cpp
    sort(k+1,k+2*m+1);//排序操作
    int num=unique(k+1,k+2*m+1)-k;//去重操作
    get(1,1,num);//这时候进行建树操作，树最长也就是2*m，当然就不会炸了
    for(int j=1;j<=m;j++)
     {
      int l=lower_bound(k+1,k+num,b[j].l)-k;  
      //lower_bound()用来找出第一个大于等于你的数的位置
      int r=lower_bound(k+1,k+num,b[j].r)-k;        
      ins(1,l,r,j);//插入操作。   
     }
```
## 在这里要着重的一个问题，就是去重，因为如果你不去重的话，原来与你共点的点，和原来和你相邻的点，都会增加一段不存在的距离，而导致数据错误，这里其实还涉及了一个问题，但我们在点树讲
# 插入操作
```cpp
void ins(int rt,int l,int r,int k)
{
 if(l>=a[rt].r || r<=a[rt].l)    
     return;//因为是区间树，所以重点无交集，算是相离状况
      //而点树不算相离状况
 if(l<=a[rt].l && a[rt].r<=r)
    {
      a[rt].c=k;         
      return;//只有在覆盖区间的时候，才进行染色
    }    
 pushd(rt);
 ins(rt<<1,l,r,k);
 ins(rt<<1|1,l,r,k);
 pushup(rt);
}
 ```
# pushd()与pushup()涉及了线段树的延迟操作（lazy）
## 当你要覆盖颜色的区域与你当前节点的区域相交时，你不能直接去改变子节点的颜色，因为上一次的改变只停留在父节点，所以要把父节点的信息传给子节点
```cpp
void pushd(int rt)
{
 if(a[rt].c!=-1)//-1表示杂色，如果本身是杂色，则不需要向下传递    
  {
  a[rt<<1].c=a[rt<<1|1].c=a[rt].c;                                    
  }   
}
```
## 然而子节点的情况也会影响父节点（改变子节点可把父节点由纯色改为杂色，也可由杂色改为纯色）
```cpp
void pushup(int rt)
{
 if(a[rt<<1].c==a[rt<<1|1].c)
    a[rt].c=a[rt<<1].c;    
 else
   a[rt].c=-1;    
}
```

# 然后查询
```cpp
void an(int rt)
{
  if(a[rt].c>0)
  {
   if(!col[a[rt].c])//用一个数组，来看颜色是否出现过，避免重复             
     {
      col[a[rt].c]=1;
      ans++;                           
     }    
   return;//查到纯色，便不再往下查     
  }
 if(a[rt].l+1==a[rt].r)
     return;//最终叶节点
 pushd(rt);//因为可能插入的时候没有穿越
         //所以仍要往下传递
 an(rt<<1);
 an(rt<<1|1);
}
```

## 从树的根节点开始查，查询有多少种颜色，注意：在建树的时候，必须要给树上底色，查询的时候查到底色，是不能算作海报的
# 现在来讲点树（区别在离散化，其余都一样）
## 前面说到题目在输入数据的时候，是在输入单位区间，所以右界要加加，但那是因为区间树的叶节点是一个区间
## 但是点树的叶节点是单独的一个点，所以我们就可以把单位区间看作一个点，所以右界不需要加加，直接输入就好了
## 然后重点来了，离散化（认真看，难点就在这里）![69544](https://cdn.luogu.com.cn/upload/pic/69544.png )
## 这是离散化的效果图（假设底部还有颜色）
## 如果是区间树的话，（1,2）与（2,3）是相离的，（2,3）与（3,4）是相离的，所以（2,3）区间代表了原（3,5）区间，所以（3,5）区间仍然存在（有同学可能会想这会不会把原相邻的改为不相邻，不用担心，在区间树时，我们把r进行了加加，所以离散化时处理的是二次数据，原相邻的变成了交集，而原空一个的变成了相邻，所以不影响）
## 但如果是点树，（2,2）和(3,3)都是点，而它们共同影响了（2,3），所以原（3,5）区间消失了，所以在离散化时要判断这一点与上一点是否相邻，如果不相邻，则要隔开
```cpp
    sort(x+1,x+k+1);
      x[0]=-1;//预防第一位是0的情况
      k=0;//计数
      for(int i=1;i<=n*2;i++)
      {
        
         if(x[i]!=x[i-1])
           x[++k]=x[i];//去重操作
      }
      for(int i=k;i>=1;i--)
      {
        if(x[i]！=x[i-1]+1)
          x[++k]=x[i-1]+1;//有空隙则创造新数据
      }
      sort(x+1,x+k+1);//再排序，原相邻的数据就隔开了
      get(1,1,k);
      for(int i=1;i<=n;i++)
      {

        int l,r;
        l=lower_bound(x+1,x+k+1,b[i][0])-x;
        r=lower_bound(x+1,x+k+1,b[i][1])-x;
        ins(1,l,r,i);   
      }
```








