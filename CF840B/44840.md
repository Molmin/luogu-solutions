这篇题解主要讲一下证明过程，如果懒得看可以去看@lemonfor 写的题解

---
首先，对于一张图，其中度数为奇数的点的个数一定为偶数个（因为度数之和为偶数），所以就可以先判断按题目要求是否能构成一张图，顺便把 $-1$ 处理了，代码如下：
```
	//w1表示奇点个数的奇偶性，w[i]表示点的度数要求
	for(int i=1;i<=n;i++)if(w[i]==-1)
	{
		if(w1)
		{
			w1=0;
			w[i]=1;
		}
		else w[i]=0;
	}
	if(w1)
	{
		puts("-1");
		return 0;
	}
```
---
题目的要求可以转化为把所给的奇点两两连接，因为连接两点的路径只会改变两端点的度数的奇偶性，路径上其它点的奇偶性不变，所以就可以用bfs搜索出答案。

但是还有一个问题：搜出来的路径可能会把图划分为两或更多个不连通的子图，如果有子图中奇点的个数为奇数时，就会无解了，如果加上回溯，那么就会T到怀疑人生。但是如果一条边可以选多次，问题就简单很多了。

那么我们就假设每条边可以选无限次，那么如果一条边被选了两次，那么就可以把这两次选择都去掉，因为对于这条边，它的两个端点的度数都会减少 $2$，对答案是没有影响的，就可以对于边开一个标记数组，每次选择时将其中的值 $Xor1$ 就可以了。

但是这样做的复杂度是 $n \times m$ 的，还是不能通过此题。

---
因为每两对点之间只要有一条路径就可以了，所以，为了使算法更优，就可以随便提出一棵树来，然后在树上进行操作。

对于一棵子树，如果其中度数为奇数的点有奇数个，那么子树的树根到它的父节点的边一定要选，否则一定不选，原因是度数为奇数的点可以两两连接，如果有剩的点就一定需要连出去。

于是就可以用dfs来求出要选的边，然后输出。总复杂度 $ n+m $。

---
代码：（码风非常邪教，不建议学习）
```
#include<bits/stdc++.h>
using namespace std;
int n,m,u,v,w[300001],a[600001],a1[600001],a2[300001],a4[600001],a5,b[300001],ansn;
bool w1,ans[300001],vis[300001];
int find(int i){return b[i]==i?i:b[i]=find(b[i]);}
bool dfs(int i)
{
	if(vis[i])return 0;
	vis[i]=1;
	int a3=a2[i];
	bool ans1=w[i];
	while(a3)
	{
		if(dfs(a[a3]))
		{
			ans1^=1;
			++ansn;
			ans[a4[a3]]=1;
		}
		a3=a1[a3];
	}
	vis[i]=0;
	return ans1;
}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=m;i++)b[i]=i;
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&w[i]);
		if(w[i]==1)w1^=1;
	}
	for(int i=1;i<=n;i++)if(w[i]==-1)
	{
		if(w1)
		{
			w1=0;
			w[i]=1;
		}
		else w[i]=0;
	}
	if(w1)
	{
		puts("-1");
		return 0;
	}
	for(int i=1;i<=m;i++)
	{
		scanf("%d%d",&u,&v);
		if(find(u)!=find(v))
		{
			b[b[u]]=b[v];
			a[(++a5)<<1]=v;
			a1[a5<<1]=a2[u];
			a2[u]=a5<<1;
			a[a5<<1|1]=u;
			a1[a5<<1|1]=a2[v];
			a2[v]=a5<<1|1;
			a4[a5<<1]=a4[a5<<1|1]=i;
		}
	}
	dfs(1);
	printf("%d\n",ansn);
	for(int i=1;i<=m;i++)if(ans[i])printf("%d ",i);
	return 0;
}
```
