（注：本文中所说的单调如非特别注明，皆指非严格单调）  
由于 Bad Triple 满足  $|x_1-x_2|+|x_2-x_3|=|x_1-x_3|$ , $|y_1-y2|+|y_2-y_3|=|y_1-y_3|$    

所以显然当且仅当 $x_1,x_2,x_3$ 单调，$y_1,y_2,y_3$ 单调时 $(x_1,y_1)$ $(x_2,y_2)$ $(x_3,y_3)$ 为 Bad Triple  

   由此可得若 $b$ 存在 $y_1 \neq y_2 \neq y_3$ 使得其为Bad，那么必定有 $y_1<y_2<y_3$ 或 $y_1>y_2>y_3$  
   
由于第二种情况可以令 $y_1=y_3$ , $y_2=y_2$ , $y_3=y_1$，转化为第一种情况。  
那么不妨令 $y_1<y_2<y_3$

由上可得 $b$ 为 good 当且仅当 $b$ 中不存在长度 $\geqslant 3$ 的单调子序列。    
Erdős–Szekeres定理曰：
> 对于任意 $r$, $s$ ，任何长度为 $(r-1)(s-1)+1$ 的实数数列均存在长度为 $r$ 的单调递增子序列或长度为 $s$ 的单调递减子序列

（论文在 [这里](http://www.numdam.org/article/CM_1935__2__463_0.pdf) ）  


所以为了不出现长度为 $3$ 的单调子序列，代入 $r=s=3$ 可得数列长度若 $\geqslant 5$ 则必定不能避免出现。故得到选出的子串长度 $\leqslant 4$ 的结论。  
即暴力枚举所有长度 $\leqslant 4$ 的子串 $b$ 即可：  
* 如 $|b|=1$ : $n$ 个  
* 如 $|b|=2$ : $n-1$ 个  
* 如 $|b|=3$ : 满足 `!(b1<=b2<=b3||b1>=b2>=b3)` 即可  
* 如 $|b|=4$ : 暴力验证所有长为三的子序列（4个）  

复杂度： $O(n)$  
  
代码：
```cpp
/*
    Code by xkcdjerry
    Time: 2021-07-14
    Generated by cf-tools
*/
#include <cstdio>

#define int long long
#define N 200010
inline bool test3(int a,int b,int c)
{
	return !((a<=b&&b<=c)||(a>=b&&b>=c));
}
inline bool test4(int a,int b,int c,int d)
{
	return test3(a,b,c)&&test3(a,b,d)&&test3(a,c,d)&&test3(b,c,d);
}
int a[N];
void once()
{
	int n;
	scanf("%lld",&n);
	for(int i=0;i<n;i++) scanf("%lld",a+i);
	int ans=2*n-1;
	for(int i=0;i<=n-3;i++)
		if(test3(a[i],a[i+1],a[i+2]))
			ans++;
	for(int i=0;i<=n-4;i++)
		if(test4(a[i],a[i+1],a[i+2],a[i+3]))
			ans++;
	printf("%lld\n",ans);
}
#undef int


int main()
{
    int t;
    scanf("%d",&t);
    while(t--) once();
    return 0;
}
```