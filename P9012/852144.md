## 闲话

说实话这题特别水，但是作为一个铜组考生，看不懂英文，结果没交代码，赛后一看中文翻译，全会……

## 思路

对于每一个输入的字符串，要把它删除或修改成 `MOO` 样式的字符，首先肯定要进行删除，把它的长度修改成 $3$，那么此时已经进行了 `s.size()-3` 次操作，接下来就是枚举剩下的 $3$ 个字符，首先如果这个字符串是 `MOO` 的话，此时正是最小次数，其次中间的字符是 `M` 的话，这个字符串就是不能将它改变成 `MOO` 的了，对于剩下的两个字符，如果开头的那个字母不是 `M`，操作次数要 $+1$，如果末尾的字母不是 `O`，操作次数也要 $+1$，最后对之前的答案进行取 $\min$ 的操作就可以了，如果答案还是同初始化的一样的话，那么这就是一个无解的字符串，直接输出 $-1$。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	int T;
	scanf("%d", &T);
	while(T--){
		string s;
		cin >> s;
		int ans = 1919810, len = s.size();//ans初始化为一个大点的数字，之后要比较
		for(int i = 0; i <= len - 3; i++){
			string str = s.substr(i, 3);//取一段长度为3的字符串
            int cnt = 0;
			if(str == "MOO"){//已经不用修改了
				ans = 0;
				break;
			}
			if(str[1] == 'M') continue;//中间字符是M，不可能成立
			if(str[0] == 'O') cnt++;//如果开头的是O/不是M，操作次数+1
			if(str[2] == 'M') cnt++;//如果开头的是M/不是O，操作次数+1
			ans = min(ans, cnt);//取min操作
		}
		if(ans == 1919810) puts("-1");//如果没有进行任何一次取min（没有修改原来的值），就是无解
		else printf("%d\n", ans + len - 3);//否则输出
	}
	return 0;
}
```