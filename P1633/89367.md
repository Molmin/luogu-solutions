看到楼下dalao的题解表示的状态感觉不是很直观，可能是我~~太弱~~了吧。

然后我想到一个更容易直观表述的状态d[i][a][b][c][1/0]。不过这次的状态表述是指在第i位a，b，c已经有几位是1。最后一个状态表示c的第i位是0还是1。

这样比表述第i位之前的状态的表述且讨论是否进位的要明了多了
不过这样需要改一下状态转移方程：
```cpp
long long v=d[i][a][b][c][0];
            d[i+1][a  ][b  ][c  ][0]=min(d[i+1][a  ][b  ][c  ][0],v         );
            d[i+1][a+1][b+1][c+1][1]=min(d[i+1][a+1][b+1][c+1][1],v+(1<<i)  );
            d[i+1][a+1][b  ][c+1][0]=min(d[i+1][a+1][b  ][c+1][0],v+(1<<i-1));
            d[i+1][a  ][b+1][c+1][0]=min(f[i+1][a  ][b+1][c+1][0],v+(1<<i-1));
            v=d[i][a][b][c][1];
            d[i+1][a  ][b  ][c  ][0]=min(d[i+1][a  ][b  ][c  ][0],v         );
            d[i+1][a+1][b+1][c+1][1]=min(d[i+1][a+1][b+1][c+1][1],v+(1<<i  ));
            d[i+1][a+1][b  ][c  ][1]=min(d[i+1][a+1][b  ][c  ][1],v+(1<<i-1));
            d[i+1][a  ][b+1][c  ][1]=min(d[i+1][a  ][b+1][c  ][1],v+(1<<i-1));
```
最后只需要判断f[n][A][B][C][0]和f[n][A][B][C][1]的其中的最小值就可以了（
~~虽然可以直接判断n+1位~~）