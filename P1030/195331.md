这题本蒟蒻的AC路程也是很波折，实在做不下去了，来看看题解，然后一脸懵逼看不懂，后来自己好不容易才写出来的  
主要思路还是差不多，就是递归，具体步骤如下：  
1. 输出该部分后序遍历最后一项（后序遍历是左右根，所以最后一项是根）
2. 在中序遍历中找到他
3. 分成左右两部分
4. 判断是否为空
5. 如果不为空，回到第1步

这里有一个问题，就是在中序和后序中的位置对不好，以样例为例，当输出A和B之后，中序的DC位于2、3的位置（位置用0--3表示），而后序在1、2位置，这怎么办呢？  
其实，通过观察，我们会发现，一个位置，每被划分为右半部分一次，中序和后序的位置就会错开1。还是以样例为例，DC在有且仅有第一次划分是被分到右边，所以中序和后序的位置会错开1个点。
那么，了解了这点以后，就不会有什么大问题了  
**代码：**
```cpp
#include<bits/stdc++.h>
using namespace std;
string s2,s3;
void dg(int l,int r,int s)//l和r分别是左右边界，以中序为准，s是被划分为右半部分的次数
{
    cout<<s3[r-s];//由于会错开s，所以位置要减s
    for(int i=l;i<=r;i++)
     if(s2[i]==s3[r-s])//找到输出的点
     {
         if(i!=l) dg(l,i-1,s);//如果是l，那么左边就不会有节点了，就不用做了，下面同理
         if(i!=r) dg(i+1,r,s+1);
     }
    return ;
}
int main()
{
    cin>>s2>>s3;
    int l=s2.length();
    dg(0,l-1,0);
    return 0;
}
```
## [完美撒花](https://www.luogu.org/blog/yhdhg1395754790/)