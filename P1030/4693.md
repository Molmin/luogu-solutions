通过一个结点，要知道左右子树根节点地址，也要知道左右子树结点数量，用分治法重建树。剩下的就是按先序遍历输出了。

下面代码中s1,t1为中序遍历序列，s2,t2为后序遍历序列.

输入完毕后先将后序t2反过来，则t2[0]必为**整棵树的根节点**。

对于中序遍历来说，从t1中查找根节点位置，因为t1是中序遍历，所以该位置将左右子树一分为二，通过地址相减来得到**p(左子树结点数)**。t1是**左子树根节点地址**，t1+p+1是**右子树根节点地址**。

而对于后序遍历来说，t2+1是**右子树根节点地址**，t2+n-p(n-p为右子树节点数)为**左子树根节点地址**。

有了**3个根节点的地址和左右子树的结点数**，于是递归求解，按照先序遍历的顺序，每次先往左走，左边没有结点再往右走，每走到一个结点直接输出结点的字符。

下面是**C代码**（Ps:参考了刘汝佳《算法竞赛入门经典》中的求后序遍历的程序）

```cpp
#include<stdio.h>
#include<string.h>
void build(int n, char* t1,char* t2)//t1为中序遍历，t2为后序遍历。 
{
    if(n==0) return;//无结点，返回 
    if(t2[0]!='\0') 
    printf("%c",t2[0]);//先序输出
    int p=strchr(t1,t2[0]) - t1; // p为左子树结点数量 (根节点位置 - t1首地址 = 左子树结点数量)
    build( p ,     t1     , t2+n-p ); //左子树结点数,中序遍历左子树根节点地址，后序遍历左子树根节点地址
    build( n-p-1 , t1+p+1 , t2+1   );
}
int main(void)
{
    char s1[10000],s2t[10000],s2[10000]={'\0'};
    scanf("%s%s",s1,s2t);
    int i=0,len=strlen(s2t)-1;
    while(len>=0)
        s2[i++]=s2t[len--];        //将后续遍历反过来。 
    build(strlen(s1),s1,s2);
    return 0; 
}
```