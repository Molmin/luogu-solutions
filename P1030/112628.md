给出一棵二叉树的中序与后序排列。求出它的先序排列。（约定树结点用不同的大写字母表示，长度<=8）。

这道题我们想要知道其先序遍历，关键在于找到根，然后拆成左右子树递归，那么我们可以写一个dfs函数来做这件事，传入 44 个参数l1, r1, l2, r2，表示当前考虑的子树，中序遍历是整棵树中序遍历序列的l1到r1这一段，后序遍历是整棵树后序遍历序列的l2到r2这一段。

如果这棵子树为空，也就是l1 > r1了，当然我们始终保持两段大小相同的话，此时也肯定是l2 > r2了，那么就返回。le 8≤8）。

这道题我们想要知道其先序遍历，关键在于找到根，然后拆成左右子树递归，那么我们可以写一个dfs函数来做这件事，传入 4 个参数l1, r1, l2, r2，表示当前考虑的子树，中序遍历是整棵树中序遍历序列的l1到r1这一段，后序遍历是整棵树后序遍历序列的l2到r2这一段。

如果这棵子树为空，也就是l1 > r1了，当然我们始终保持两段大小相同的话，此时也肯定是l2 > r2了，那么就返回。
```cpp
#include <iostream>
#include <cstring>
using namespace std;
char s1[15],s2[15];
void dfs(int l1,int r1,int l2,int r2){
    if (l1>r1){
        return;
    }
    int p;
    for (int i=l1;i<=r1;++i){
        if (s1[i]==s2[r2]){
            p=i;
        	break;
        }
    }
    cout<<s1[p];
    dfs(l1,p-1,l2,l2+p-1-l1);
    dfs(p+1,r1,r2-r1+p,r2-1);
}
int main() {
    int len;
    cin >> s1 >> s2;
    len = strlen(s1);
	dfs(0,len-1,0,len-1);
    return 0;
}
```