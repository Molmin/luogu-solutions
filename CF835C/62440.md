一开始看到题目时想到前缀和，发现这个模数是固定的就考虑了统计矩形中的星星总亮度和数量，把时间造成的亮度增加与原先的亮度分别取模后计算。

但是这个思路的问题在于，最后输出时并没有同样取模，这也意味着模数的性质在这里显然不能使用。然而可以发现，这里的模数 $c$ 只有 $10$ 种取值，实际上非常小，而这个输入的 $t$ 同样在取模 $c$ 后不会影响答案，也只有 $10$ 种取值。

所以就可以导出一种正确的做法：对于取模后每个 $t$ 预处理一遍这时的二维前缀和，这样规避掉上述的问题从而可以得到正确答案。

注意一个位置实质上可能有多个星星，有些实现会受到这个条件的影响而不能正确处理前缀和。

```
#include <bits/stdc++.h>
using namespace std;

int n, m, mod, x, y, z, x2, y2;
long long s[202][202][12];
int main() {
    scanf("%d%d%d", &n, &m, &mod), ++mod;
    for (int i = 0; i < n; ++i) {
        scanf("%d%d%d", &x, &y, &z);
        for (int j = 0; j < mod; j++) s[x][y][j] += (z + j) % mod;
    }
    for (int i = 1; i <= 200; ++i)
        for (int j = 1; j <= 200; ++j)
            for (int k = 0; k < mod; ++k)
                s[i][j][k] += s[i - 1][j][k] + s[i][j - 1][k] - s[i - 1][j - 1][k];
    while (m--)
        scanf("%d%d%d%d%d", &z, &x, &y, &x2, &y2), z %= mod,
            printf("%lld\n", s[x2][y2][z] - s[x - 1][y2][z] - s[x2][y - 1][z] + s[x - 1][y - 1][z]);
    return 0;
}
```