## CF388D Fox and Perfect Sets 题解

来一篇记忆化搜索的题解，顺便把做题思路给捋捋。

### 题意这里不再赘述

[CF388D Fox and Perfect Sets](https://www.luogu.com.cn/problem/CF388D)

### 朴素分析

看着题里面给出的限制，我们可以意识到，一个完美集合的所有元素一定可以表达成一组线性基及其互相异或得到的值加上个 $0$ 的形式。

那不难想到，这题我们可以从线性基计数入手来处理这题。首先有个问题，即一个完美集合可能可以由多组线性基生成，可能会重复计算。为了避免这种情况，可以使用一个方法对线性基进行重构，而我们只需要统计重构后的线性基个数即可。

了解线性基的朋友可能知道，如果想要求所有异或值的 $kth$，就需要对线性基进行重构，即要保证在排名上高位的基底的贡献要严格大于低位的基底。什么意思呢？总结起来就是**若第 $i$ 位对应的基底存在，那么其它的任意基底第 $i$ 位都应是 $0$，否则不受限制**。

以这种构造方式，查找 $kth$ 时可以直接从高位向低位贪心，用来重构的代码大概长这样：（注意不是本题的代码）

```cpp
inline void rbu(){
	for(rint i=B;i>=0;--i){
		for(rint j=i-1;j>=0;--j)
			if(_p[i]>>j&1)_p[i]^=_p[j];
		if(_p[i])p[bt++]=_p[i];
	}
}
```

那么如果进行了这样的重构，我们就可以保证，本质相同（即产生的完美集合相同）的线性基都会变成同一个线性基。并且这样重构还有一个优秀的性质：**异或最大值恰好是所有基底的异或和**，那么有了这些条件，我们就可以发现这可以转化为 DP 的形式，接下来我们分析如何 DP。

### DP 分析

我们发现从高位向低位考虑是比较方便的，那我们可以设状态 $f_{i,j,0/1}$ 表示从高到低考虑到第 $i$ 位（正着从 $0$ 开始数），大于等于 $i$ 位的基底有 $j$ 个（这个接下来会用到），当前位是否顶到了 $n$ 对应位置的上界的答案。

然后就是个比较正常的数位 DP 了。DP 过程中我们要假定低于当前位的那些位置在所有的基底里面都是 $0$，等到考虑到那里再往里面加。

至于为什么要记录这个 $j$，根据刚才重构后的线性基特点，如果让当前位没有对应的线性基，那么高位的基底对应位可以任取。那我们想要控制异或最大值当前位是 $0$ 还是 $1$，因为异或最大值是前面基底的异或和，所以相当于我们要控制前面基底对应位有奇数个还是偶数个 $1$，那假设前面有 $j>0$ 个基底，奇数个偶数个的情况均是 $2^{j-1}$ 种，就可以进行转移。

### 最后

没有解释太多的转移方程，但在代码里注释写的比较全，具体转移方程可以看代码。

这里“顶位”意思即当前位及之后是否卡住了 $n$ 的上界。

### 贴代码

```cpp
#include <bits/stdc++.h>
#define lint long long
#define rint register int
using namespace std;
inline lint read(){
	char c;lint f=1,res=0;
	while(c=getchar(),!isdigit(c))if(c=='-')f*=-1;
	while(isdigit(c))res=res*10+c-'0',c=getchar();
	return res*f;
}
const lint B=30,md=1e9+7;
lint f[B+5][B+5][2],n,ans,cnt[B+5],mx=-1;
inline void add(lint &x,lint y)
	{x=(x+y%md)%md;}
//从高到低考虑到第i位 已有j个基 到当前位是否顶位 
lint F(int i,int j,int k){
	if(f[i][j][k]!=-1)
		return f[i][j][k];
	if(!j&&!cnt[i]){//特判边缘情况 
		if(k)return f[i][j][k]=1;
		else return f[i][j][k]=0;
	}else if(j>max(cnt[i],mx-i))//如果i位及以后不可能拥有j个基底 
		return f[i][j][k]=0;
	lint res=0,x=j?(1ll<<j-1):0,y=j?(1ll<<j-1):1;
	//x为奇数情况对应 y为偶数情况对应 
	if(k){//当前位顶位则高位也需要顶位
		//需要在最大值上多出一个当前位
		if(n>>i&1){
			//独自成一基
			if(j)add(res,F(i+1,j-1,1));
			//没有当前位的基 高位有奇数个1
			add(res,F(i+1,j,1)*x); 
		}else//否则高位有偶数个1 
			add(res,F(i+1,j,1)*y);
	}else{//当前位不顶位
		//高位也不顶位 
		//独自成基
		if(j)add(res,F(i+1,j-1,0));
		//不独立成基 剩下位乱搞
		add(res,F(i+1,j,0)<<j);
		//高位顶位 n当前位为1且最大值该位为0
		if(n>>i&1)add(res,F(i+1,j,1)*y);
	}
	return f[i][j][k]=res;
}
int main(){
	n=read();
	memset(f,-1,sizeof f);
	for(rint i=B;i>=0;--i){
		cnt[i]=cnt[i+1]+(n>>i&1);
		if(mx==-1&&cnt[i])
			mx=i;
		//cnt记录当前位及以后有多少个1
		//mx记录最高位的1的位置 
	}
	for(rint i=0;i<=B;++i){
		add(ans,F(0,i,0));
		add(ans,F(0,i,1));
	}
	printf("%lld",ans);
	return 0;
}


```
