题目分析：

要求输出方案，所以考虑构造。

首先根据异或同一个数两次得到原数，可以得到：若操作的序列为 $x,x,y$，得到的结果就是 $y,y,y$。

然后根据这条性质，可以考虑先将序列异或成一个类似于 $x,x,y,y,z,z...a$ 的序列，其中最后一个数 $a$ 可以等于之前的某一个数，然后再用最后的一个 $a$ 一点一点异或回去，就能得到一个全部相等的序列。

再考虑如何构造这样的序列，显然有：把连续三个数异或完后下一次再带上这一次三个数的最后一个数向后异或三个数，举个例子就是：$a,b,c,d,e$ 一步操作（前三个）后变成：$x,x,x,d,e$，再操作一次（后三个）就是 $x,x,y,y,y$，达成了之前要求的序列形式。

计算一下总操作数，设 $n$ 表示原来的序列长度：则需要 $\dfrac{n-1}{2}$ 次操作来构造新串，然后还需要 $\dfrac{n-1}{2}-1$ 次操作来使得所有数相等，总共需要 $n-2$ 次操作。

但这样的序列显然不是所有长度的原序列都能构造的，根据构造规则，假如 $2\mid n$，那么最后一步就不能实现，也就导致构造序列最后有两个数是无法控制的，还原操作后还有一个数无法控制。

然后考虑如何判断这样的一个偶数序列是否能满足条件。发现每一次操作后三个数的总异或不变，而如果能构造成一个全相等序列，则其总异或一定是 $0$，那么就只需要判断原来的序列总异或是否为 $0$ 即可。

最后输出方案，这道题不需要输出最小的，可行就行（~~不然他就不是一道绿题了~~），那么就考虑一般构造：对于奇数个数的序列，每三个操作一次，然后再从后往前作相同操作，而对于一个可行的偶数序列，直接将其减一然后直接项奇数一样做，可以证明使得前 $n-1$ 个数构成相等的序列的最终值一定是等于一开始被抛弃的那一个数的。

------------
代码：
```cpp
#include<cstdio>
using namespace std;
int n,x,sum;
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		scanf("%d",&x);
		sum^=x;
	}
	if(n%2==0){
		n--;
		if(sum!=0){
			printf("NO\n");
			return 0;
		}
	}
	printf("YES\n");
	printf("%d\n",n-2);
	for(int i=1;i<=n-2;i+=2)printf("%d %d %d\n",i,i+1,i+2);
	for(int i=n-2;i>=3;i-=2)printf("%d %d %d\n",i,i-1,i-2);
	return 0;
}
```

