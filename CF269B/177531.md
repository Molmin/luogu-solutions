## CF269B 题解

稍加思考，题目可以简化为：给到每一株植物的品种以及其原位置的序列，要我们求出需要对植物进行多少次移位，使得序列的 $ \text{LIS} $ 长度为 $ n $，即使序列满足**非严格单调递增**（对于 $ \forall x_1,x_2 \in [1,n] $ 且 $ x_1<x_2 $，总有 $ a[x_1] \leq a[x_2] $）。

我们注意到，每株植物是有一个位置的。根据题意，**这个位置在数轴上**。这就代表着，当进行移动时，只用考虑被移动的植物，而不用考虑其它植物给它让位子。

这样的结论很容易证明。在数轴上，可以找到任意实数所在的位置。**数轴是无限可分割的**。

举个例子，有三株植物 $ A,B,C $，它们所在的位置分别是 $ 1,2,3 $，现在要将 $ A $ 移到 $ BC $ 之间，使序列满足最优子结构性质。如果限定在 $ Z $ 中，我们当然要让植物 $ C $ 给植物 $ A $ 让位；但这题位置的范围是 $ R $，而 $ 2 $ 和 $ 3 $ 之间有无穷多个实数。

有了以上思考，我们完全可以**忽略每株植物的位置**。

我们可以先求出原序列中满足非严格单调递增的子序列的长度，记为 $ len $。容易想到用一个基本得不能再基本的 $ \text{DP} $ ——**最长不下降子序列**求解：

边界：$ dp[i]=1, i\in [1,n] $

转移：$ dp[i]=max\{dp[i],dp[j]+1\}, i\in [2,n], j\in [1,i), a[i]>a[j] $

目标：$ max\{dp[i]\}, i\in [1,n] $

那么剩下的植株在一开始并不满足题目的要求，数量是 $ n-len $。

考虑如何移动。

根据以上的推论，我们容易得到：

对于 $ \forall x$，总能在 $ \forall k_1, k_2, a[k_1]<a[x]<a[k_2] $ 之间找到一个位置，供 $ x $ 移动。因此，对于每一株起始时并不满足题目要求的植物，**仅需要移动一次**。

则答案为 $ n-len $。

### 完整代码：

```cpp
#include <iostream>
#include <cstdio>
using namespace std;

const int MAXN=5001;
int n,m,LIS,a[MAXN],dp[MAXN];
double tmp;

int main()
{
	scanf("%d%d",&n,&m);
	
	for(int i=1;i<=n;i++)
	{
		scanf("%d%lf",&a[i],&tmp);
		dp[i]=1;
	}
	
	for(int i=2;i<=n;i++)
		for(int j=1;j<i;j++)
			if(a[i]>=a[j])
				dp[i]=max(dp[i],dp[j]+1);
	
	for(int i=1;i<=n;i++)
		LIS=max(LIS,dp[i]);
	
	printf("%d",n-LIS);
	return 0;
}
```
