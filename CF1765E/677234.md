看到这题数据范围，肯定是要 $\text{O}(T)$ 到 $\text{O}(T\log n)$ 左右的时间复杂度。但是根据题意，貌似无法将基础的暴力优化成 $\log$ 级别的算法，所以考虑 $\text{O}(1)$ 时间复杂度。

那么 $O(1)$ 复杂度基本就是数学了。我们进行思考可以发现，如果你用一枚金币买到的银币数无法获得利益，即 $a\le b$，就不进行交易（应为此时进行交易无法把手中的金币数量变的更多，不如不进行交易）。否则，可以不断的进行交易，这样金币数量越来越多，只需要一次探险即可。所以，对 $a$ 与 $b$ 的数量关系进行分类讨。$a\le b$ 则直接一直进行探险，直到金币的数量足够交易成 $n$ 枚银币。否则就探险一次，然后不断进行交易，代码如下：

```
#include <bits/stdc++.h>
using namespace std;
int T;
int main() {
  for( cin >> T; T; T -- ) {
    int n, a, b;
    cin >> n >> a >> b;
    if( a > b ) {
      cout << 1 << endl;
    }
    else {
      cout << n / a + bool( n % a ) << endl;
    }
  }
}
```
