### 推导公式
线段树每一个节点当中维护的是s0、s1，用于后续的公式推导！其中f为斐波那契数列；其中l-r为线段树每段所维护的左右区间！
```
s[0] = a[l]*f[0] + a[l+1]*f[1] + a[l+2]*f[2] + ... + a[r]*f[r-l];
s[1] = a[l]*f[1] + a[l+1]*f[2] + a[l+2]*f[3] + ... + a[r]*f[r-l+1];
s[2] = a[l]*f[2] + a[l+1]*f[3] + a[l+2]*f[4] + ... + a[r]*f[r-l+2];
s[3] = a[l]*f[3] + a[l+1]*f[4] + a[l+2]*f[5] + ... + a[r]*f[r-l+3];
...
s[x] = a[l]*f[x] + a[l+1]*f[x+1] + a[l+2]*f[x+2] + ... + a[r]*f[r-l+x];
```
由上述公式可以推导得到：
```
s[2] = s[1]+s[0], s[3] = s[2]+s[1] = 2*s[1]+s[0], s[4] = s[3]+s[2] = 3*s[1]+2*s[0];
```
由斐波那契数列性质以及以上推导得到：
```
s[x] = f[x-1]*s[1] + f[x-2]*s[0]; 
```
维护线段树当中的每一段的s0、s1;

### 两段合并：

因为左子树段下标始终在右子树段前面，所以合并时左段的子树 (s[0] + 右段对应的s[x],左子树段有多少个值，右子树段就从值的个数开始!)
例如左段有k个值那么右段合并时，右段值就为s[k],即需要满足第二个条件；
对于第三个条件就是用懒标记，推导公式：

带入s[0] 得到 
```
ans = (a[l]+d)*f[0] + (a[l+1]+d)*f[1] + (a[l+2]+d)*f[2] + ... + (a[r]+d)*f[r-l];
```
化简得到 
```
ans = a[l]*f[0] + a[l+1]*f[1] + a[l+2]*f[2] + ... + a[r]*f[r-l] +   d(f[0]+f[1]+f[2]..+f[r-l]) = s[0] + d(f[0]+f[1]+f[2]..+f[r-l]);
```
所以修改线段树每一段保留值：
```
s[0] = s[0] + d(f[0]+f[1]+f[2]..+f[r-l]); 
s[1] = s[1] + d(f[1]+f[2]+f[3]..+f[r-l+1]);  s[1]同理 
```