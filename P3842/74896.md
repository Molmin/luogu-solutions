一道比较不错的题

### 【题意描述】
在一个 $n*n$ 的平面上，在每一行中有一条线段，第 i 行的线段的左端点是$(i, L(i))$，右端点是$(i, R(i))$，其中 $1 ≤ L(i) ≤ R(i) ≤ n$。
从$(1, 1)$点出发，要求沿途**走完所有的线段**，最终到达$(n, n)$点，且所走的路程长度要尽量短。

### 【题意关键】

1. 每条线段要**走完**

1. 向下走也要**计算步数**

1. 目标是从$(1,1)$走到$(n,n)$

### 【设计转移】

 $f[i][0]$表示走到第 $i$ 行的线段的左端点的最少步数

 $f[i][1]$表示走到第 $i$ 行的线段的右端点的最少步数

 $l[i],r[i]$表示第 $i$ 行线段的左端点和右端点
 
 ### 【注意细节】
 
 最开始的初值：$f[1][1]=r[i]-1$这个没什么问题
 
 注意从$(1,1)$走到线段左端点要先走到右端点再返回左端点，这样才能**走完**第一条线段，即$ f[1][0]=r[1]+r[1]-l[1]-1$
 
 ### 【代码实现】
 ```
#include<bits/stdc++.h>
using namespace std;
const int N=20005;
int n,l[N],r[N],len[N],f[N][2],o;
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++) scanf("%d%d",&l[i],&r[i]),len[i]=r[i]-l[i]+1;//注意此处加1的含义 
    memset(f,127,sizeof f);
    //f[i][0]=abs(上一行左端点的坐标-本行右端点的坐标)+本行线段长度
    f[1][0]=r[1]+r[1]-(l[1]+1);//(1,1)-->右端点-->左端点 
    f[1][1]=r[1]-1;//(1,1)-->右端点 
    for(int i=2;i<=n;i++)
	{
        f[i][0]=min(f[i][0],f[i-1][0]+abs(r[i]-l[i-1])+len[i]);//左-->左
        f[i][0]=min(f[i][0],f[i-1][1]+abs(r[i]-r[i-1])+len[i]);//右-->左
        f[i][1]=min(f[i][1],f[i-1][0]+abs(l[i-1]-l[i])+len[i]);//左-->右
        f[i][1]=min(f[i][1],f[i-1][1]+abs(r[i-1]-l[i])+len[i]);//右-->右
    }
    printf("%d",min(f[n][0]+n-l[n],f[n][1]+n-r[n]));//min(右-->(n,n),左-->(n,n))
    return (o^0^o);//卖个萌 
}
 ```
 ### 【空间优化】
 
 我们发现转移只与上一个状态有关，所以可以运用滚动数组
 
 ```
 #include<bits/stdc++.h>
using namespace std;
const int N=20005;
int n,l[N],r[N],len[N],f[2][2];//好小有木有
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++) scanf("%d%d",&l[i],&r[i]),len[i]=r[i]-l[i]+1;
    f[1][0]=r[1]+r[1]-(l[1]+1),f[1][1]=r[1]-1;
    for(int i=2;i<=n;i++)
	{
        f[i&1][0]=min(f[(i+1)&1][0]+abs(r[i]-l[i-1])+len[i],f[(i+1)&1][1]+abs(r[i]-r[i-1])+len[i]);
        f[i&1][1]=min(f[(i+1)&1][0]+abs(l[i-1]-l[i])+len[i],f[(i+1)&1][1]+abs(r[i-1]-l[i])+len[i]);
    }
    printf("%d",min(f[n&1][0]+n-l[n],f[n&1][1]+n-r[n]));
    return 0;
}
 ```