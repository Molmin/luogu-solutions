### 题意

给一个位数不超过 $18$ 的数 $n$，有 $a$ 次机会给其一位加 $1$，若此位为 $9$ 则变为 $0$，有 $b$ 次机会给其一位减 $1$，若此位为 $0$ 则变为 $9$。

### 思路

做这种使一个数修改后最大的题有一个很显然的性质，就是先使高位数字最大一定是最优的。

本题数据范围很小，可以直接暴力。

因为操作使对每一位进行的，所以从高位向低位依次执行 $\text{dfs}$。

题目没有要求操作次数必须全部用完，所以在保证数最大且使用同种操作的情况下，能少使用操作次数就尽量少用操作次数：

对于每一位，我们当然希望他变成 $9$，因为这样可以保证在高位确定时结果是最大的。当当前位数字为 $u$ 时，通过加 $1$ 使其变为 $9$ 需要的次数为 $9-u$，通过减 $1$ 使其变为 $9$ 需要的次数为 $u+10-9=u+1$。

对数位减 $1$ 的操作除特殊情况（$0$ 变 $9$）外，都只会使原数最小，所以当前数字不能通过减小到 $9$ 时不尝试减 $1$ 操作。

### 代码

```
#include<bits/stdc++.h>
#define maxn 10010//实际上dfs出的结果会很少
using namespace std;
string s,now,ans[maxn];
int len,a,b,sum;
void dfs(int x,int a,int b){
	if(x==len)return ans[++sum]=now,void();//储存结果
	int u=s[x]-'0';
	if(9-u<=a){//通过加1可以到9
		now[x]='9';
		dfs(x+1,a+u-9,b);
	}
	if(u+1<=b){//减1可以到9，否则不考虑减1操作
		now[x]='9';
		dfs(x+1,a,b-u-1);
	}
	if(9-u>a&&u+1>b){
		now[x]=u+a+'0';
		dfs(x+1,0,b);//低位可能可以通过减1到9，所以还要继续dfs
	}
}
int main(){
	cin>>s>>a>>b;
	len=s.size();
	now=s;
	dfs(0,a,b);
	sort(ans+1,ans+sum+1);//将结果排序
	cout<<ans[sum]<<endl;
	return 0;
}
```