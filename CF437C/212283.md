## 题意

$n$ 个带权点，$m$ 条无向边，删除一个点就要付出所有与之有联系且没有被删除的点的点权之和的代价。

求删除所有点的最小代价。

## 分析

一看，这是一道贪心。再一看，一开始可以存起来所有点的代价，每次删掉一个点，就把和它相连的点代价全部减掉我的点权，然后再选择点权最大的点删掉……看着像拓扑排序。

但是这并不是一个 DAG，可能存在环，所以这并不能过。

于是你想到了，这应该是需要转化的。既然从点入手不那么顺，那么就从边入手吧。考虑图被删光的最后结果，一定是 $0$ 边 $0$ 点，那么我们删掉所有边，就等效于删掉所有点。

对于每一条边，它的最优情况下的贡献就是较小的那个点权。因为我们可以谋划删点顺序，对于每条边总是删除点权较大的那个点，从而最大限度的降低删除其他点时的代价，因此我们会付出较小点权的那个代价。

那么存边的时候顺便累加一下答案即可。

## 代码

于是代码就出人意料地简单。

```cpp
#include<bits/stdc++.h>
#define rint register int
using namespace std;
int n,m,ans,a[1005];
signed main(){
    scanf("%d%d",&n,&m);
    for(rint i=1;i<=n;i++)scanf("%d",&a[i]);
    for(rint i=1;i<=m;i++){
        int x,y;
    	scanf("%d%d",&x,&y);
    	ans+=min(a[x],a[y]);
	}printf("%d\n",ans);
    return 0;
}

```