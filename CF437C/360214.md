这道题有一种特别帅的解法。

我们以第一个样例为例，并进行如下步骤：

![](https://cdn.luogu.com.cn/upload/image_hosting/v4oh5bpu.png)

1. 将这个图上的所有节点按照点权从小到大排序，并把边标在上面（如上图所示）
2. 从后往前一个一个删点

3. 统计答案并输出
4. 等待 AC

这是从点的角度考虑的问题。为什么它是对的呢？我们需要从边的角度考虑。

对于每一条边，我们都有如下事实：

1. 它总是要被删掉
2. 当删掉自己连接的**其中一个节点**时自己就被删掉了
3. 自己被删掉时对答案产生的贡献是**没有被删掉的**那另一个节点

综上所述，因为每一条边的贡献之和就是答案，所以如果我们使得每一条边的贡献最小，那么答案也就最小。

很显然，我们只要保证每一条边的删除都是由**点权较大**的点造成的就可以了。从后往前删点正好能保证这一点。

那么如何统计答案呢？答案就隐藏在文中，每一条边的**贡献之和**就是答案！这道题不就完了？

AC 代码：

```C++
#include<iostream>
#define N 1000
using namespace std;

int w[N];
int main() {
    int n, m, ans = 0; cin >> n >> m;
    for (int i=0; i<n; i++)
        cin >> w[i];
    for (int i=0, u, v; i<m; i++)
        cin >> u >> v, ans += min(w[u-1], w[v-1]);
    return cout << ans, 0;
}
```

