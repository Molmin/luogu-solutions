提供一个比现有题解的时间复杂度更优的 $O(n)$ 做法。

首先显然对于一个序列，奇数位和偶数位可以分开进行赋值。设这两个序列为 $A,B$，并设两个序列中数 $x$ 的出现次数为 $cnt_a[x],cnt_b[x]$。

欲使赋值的次数最小，那么就要求保留的数最多。所以当序列 $A$ 和 $B$ 中出现次数最多的数不相等时，分别保留其出现次数最多的数就是最优的方案。

所以现在唯一的限制就是要求最终的序列 $A,B$ 中的数不相等。

考虑原序列 $A$ 中出现次数为 $cnt_a[x]$ 的任意一个数 $x$，如果我们需要保留 $x$ 为最终序列 $A$ 的值，那么我们就应当选取序列 $B$ 中这样的数 $y$：$y\neq x$，且 $cnt[y]$ 在 $y\neq x$ 的前提下最大。枚举 $A$ 中的每一个数 $x$ 并从中选取最优者即可。

那么现在问题就转化为了对于一个 $x$，查询 $cnt_b[1\sim x-1]$ 和 $cnt_b[x+1\sim V]$ 中的最大值，$V$ 为值域。

所以求出序列 $cnt_a,cnt_b$ 之后，对 $cnt_b$ 做一遍前缀最大值，再做一遍后缀最大值存到两个数组中，查询时直接 $O(1)$ 查询前缀和后缀最大值即可。

```cpp
n=read();
for(int i=1;i<=n;i++)c[i]=read();
for(int i=1;i<=n;i+=2)a[c[i]]++;
for(int i=2;i<=n;i+=2)b[c[i]]++;
for(int i=1;i<N;i++)pre[i]=max(pre[i-1],b[i]);
for(int i=N-2;i;i--)suf[i]=max(suf[i+1],b[i]);
for(int i=1;i<N;i++)
	if(a[i])ans=max(ans,a[i]+max(pre[i-1],suf[i+1]));
printf("%d\n",n-ans);
```

值域 $V$ 最大值与 $N$ 相等，时间复杂度为 $O(n)$。