题解区怎么清一色等比数列 + 无穷级数求和，吓得我......

---

读完题面，想到期望 dp。

为方便表示，下文中的 $p_a$ 与 $p_b$ 表示原题中的 $\dfrac{p_a}{p_a+p_b}$ 与 $\dfrac{p_b}{p_a+p_b}$。

设 $f_{i,j}$ 表示当前序列里有 $i$ 个 ```a```，并且已经有了 $j$ 个 ```ab```。

考虑如何转移。

* 当下一步插入一个 ```a``` 的时候，由于不新增 ```ab```，所以只有 $f_{i+1, j}$ 对 $f_{i, j}$ 产生贡献。贡献为 $p_a \times f_{i+1, j}$。
* 当下一步插入一个 ```b``` 的时候，由于新增 $i$ 个 ```ab```，但是不影响 ```a``` 的个数，所以只有 $f_{i, j+i}$ 对 $f_{i, j}$ 产生贡献。贡献为 $p_b \times f_{i, j+i}$。

所以得到转移方程：

$$f_{i, j} = p_a \times f_{i+1, j} + p_b \times f_{i, j+i}$$

（注意，这题的期望不是步数，是最终状态时的 ```ab``` 个数，所以不要在后面 $+1$）

----

但是这个 dp 没有边界，所以我们需要构造一个边界。

我们不难发现，当 $i + j \ge k$ 时，只要再插入一个 ```b``` 就必定会结束。

因此，当满足该条件时，我们可以将原转移方程重写：

$$f_{i, j} = p_a \times f_{i+1, j} + p_b \times (i + j)$$

但是这样还是无穷的，怎么办呢？

考虑到状态 $f_{i + 1, j}$ 依旧是插入一个 ```b``` 就必定会结束。和状态 $f_{i, j}$ 的区别只有一个 ```a```，对于 $f_{i, j}$ 所计算到的每种情况，$f_{i + 1, j}$ 就可以对应一种多一个 ```ab``` 的情况。

或者说，先把这个多了的一个 ```a``` 拿掉，这样就是 $f_{i, j}$，最后结束的时候再放回去。因为只加了一个 ```b``` 就结束了，所以这个 ```a``` 后面只多了一个 ```b``` 和若干个 ```a```，对于答案也就是多了一个 ```ab```。

综上，我们可以得到 $f_{i + 1, j} = f_{i, j} + 1$。

代入，可得：

$$f_{i, j} = p_a \times (f_{i, j} + 1) + p_b \times (i + j)$$

$$(1 - p_a) \times f_{i, j} = p_a + p_b \times (i + j)$$

$$f_{i, j} = \dfrac{p_a}{p_b} + i + j$$

（注：$p_a + p_b = 1$）

----

如果你仔细观察，你会发现还有一个特殊情况！

$$f_{0, 0} = p_a \times f_{1, 0} + p_b \times f_{0, 0}$$

(0 . 0)

这时，我们故技重施，把 $f_{0, 0}$ 都移到左侧，就可以得到：

$$f_{0, 0} = f_{1, 0}$$

当然，你也可以理解为在开头放的所有 ```b``` 对于答案没有任何贡献，所以可以直接放上一个 ```a``` 再进行计算！

----

考虑时间复杂度！

由于状态保证 $i + j < k$，所以状态数量的量级是 $O(k^2)$，而考虑每个状态的计算，无论涉及的状态是否满足 $i + j < k$，都是 $O(1)$ 的。所以总时间复杂度就是 $O(k^2)$，且常数较小！

----

> Talk is cheap, show me the code!

```cpp
inline ll DFS (ll i = 1, ll j = 0)
{
	if (i + j >= k) return (i + j + P) % mod;
	if (f[i][j]) return f[i][j];
	return f[i][j] = (Pa * DFS (i + 1, j) % mod + Pb * DFS (i, j + i) % mod) % mod;
}

int main ()
{
	std::cin.tie (nullptr), std::ios::sync_with_stdio (false);
	cin >> k >> pa >> pb;
	Pa = pa * Inv (pa + pb) % mod, Pb = pb * Inv (pa + pb) % mod;
	P = pa * Inv (pb) % mod;
	cout << DFS () << endl;
	return 0;
}
```

----

总结：不错的期望 dp 练手题，可以时不时回顾一下。