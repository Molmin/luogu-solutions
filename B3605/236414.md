## 二分图介绍

学习二分图最大匹配，首先我们先来了解二分图。

二分图，就是像这样的一个图：
![](https://i.loli.net/2021/02/28/97q2gZpwTodCt4l.png)

一共有两堆东西，左边一堆，右边一堆，左边的点和左边的点不能连边，右边的点和右边的点不能连边，只有左边的点和右边的点可以连边。

像这样的就叫做完全二分图：![](https://i.loli.net/2021/02/28/IJWHnuz2SEMBYbN.png)
左边和右边每两个点连了一条边。

二分图最大匹配，指如果每个左边的点只能和右边的点连一次，求最多能让多少左边的点和右边的点连在一起。

## 算法讲解

求最大匹配的算法叫匈牙利算法。

>> 匈牙利算法是一种在多项式时间内求解任务分配问题的组合优化算法，并推动了后来的原始对偶方法。美国数学家哈罗德·库恩于1965年提出该算法。此算法之所以被称作匈牙利算法，是因为算法很大一部分是基于以前匈牙利数学家Dénes Kőnig和Jenő Egerváry的工作之上创建起来的。设 $G=(V,E)$ 是一个无向图。如顶点集 $V$ 可分割为两个互不相交的子集 $V_1,V_2$ ，选择这样的子集中边数最大的子集称为图的最大匹配问题（maximal matching problem)。
如果一个匹配中， $|V_1| \leq |V_2|$ 且匹配数 $|M|=|V_1|$ ，则称此匹配为完全匹配，也称作完备匹配。特别的当 $|V_1|=|V_2|$ 称为完美匹配。

——选自百度百科。

比如说第一个图，最大匹配就是 $3$ 。因为 $(3,1)$ 相连， $(2,3)$ 相连， $(1,2)$ 相连，所以最大匹配是 $3$ 。

那么怎么求二分图最大匹配呢？

就拿第一个图来看吧。

首先，我们先假设 $(1,1)$ 相连。

就变成了这个样子：
![](https://i.loli.net/2021/02/28/sTRw1LyhYldmIQb.png)
图中的 $match$ 数组代表右边的第几个点和左边的哪个点匹配上了。如果 $match[i]$ 为 $0$ ，那么就代表没有点和它匹配上。图中的右边 $1$ 号点和左边的一号点匹配上了。

然后，我们继续。图：
![](https://i.loli.net/2021/02/28/iuO8AtbUl3rN9JW.png)

从右边的第 $1$ 个开始循环，循环到 $2$ 时就连了一条边， $match[2]$ 又为 $0$ ，所以就可以匹配。

继续。图：

![](https://i.loli.net/2021/02/28/EB4Pi5X9LN3HFzQ.png)

这时，左边的 $3$ 要和右边的 $1$ 匹配，但是右边的 $1$ 已经被左边的 $1$ 匹配了，所以最重要的来了：将左边的 $1$ 和右边的 $1$ 拆开，不匹配了。接着，将左边的 $1$ 与右边的 $2$ 匹配，但是右边的 $2$ 又被左边的 $2$ 匹配了，于是将左边的 $2$ 与右边的 $2$ 拆开。再接着，将左边的 $2$ 与右边的 $3$ 匹配，成功了。于是，左边的 $2$ 与右边的 $3$ 匹配，左边的 $1$ 与右边的 $2$ 匹配，左边的 $3$ 与右边的 $1$ 匹配。

继续，不画图了。因为右边的三个点都被匹配完了，左边的 $4$ 号点无论如何都不能匹配到点了，所以算法结束了，答案为 $3$ 。

## 算法总结

总结一下算法的过程。首先，将左边的点全部循环一遍。每次进入算法，看看这个点是否可以匹配到右边的点。然后，算法里就将右边的点从1开始不重复循环一遍，每次看看将左边的点匹配到右边的点后，原来左边匹配右边这个点的点是否可以匹配到右边新的点，一直递归。如果递归的最后的点可以匹配到右边的一个空点（即没有被匹配的点），就将左边所有递归的点都匹配到右边的新点上去。否则，不修改任何东西。

这个算法的复杂度最坏为：

邻接矩阵： $\Theta(n^3)$ 邻接表： $\Theta(nm)$ 。

空间复杂度为：

邻接矩阵： $\Theta(n^2)$ 邻接表： $\Theta(n+m)$ 。

## 算法证明

为什么这个算法是正确的呢？因为左边每个如果可以匹配到右边的点，就一定会匹配，将左边其他的点安排到右边其他的点上去。所以可以匹配到的数量一定是最大的。


## 代码

```c
#include<string.h>
#include<stdio.h>
#include<stdbool.h>
int read()
{
	int i = 0, f = 1;
	char ch;
	for(ch = getchar(); (ch < '0' || ch > '9') && ch != '-'; ch = getchar());
	if(ch == '-')
	{
		f = -1;
		ch = getchar();
	}
	for(; ch >= '0' && ch <= '9'; ch = getchar())
	{
		i = (i << 3) + (i << 1) + (ch ^ 48);
	}
	return i * f;
}
void write(int a)
{
	if(a < 0)
	{
		putchar('-');
		a = -a;
	}
	int sta[100] = {}, cnt = 0;
	while(a)
	{
		cnt++;
		sta[cnt] = a % 10;
		a /= 10;
	}
	while(cnt)
	{
		putchar(sta[cnt] + '0');
		cnt--;
	}
}
int a[501][501],match[501],n,m,e,ans;//a是用来建图的，match是用来匹配的，ans是答案。
bool p[501];//p是用来dfs判重的。
bool dfs(int x)
{
	for(int i = 1; i <= m; i++)//将右边的点循环一遍，找可以匹配的点。
	{
		if(a[x][i] && !p[i])//如果两个点之间有一条边并且右边这个没有被左边的x匹配过。
		{
			p[i] = 1;//标记，防止死循环。
			if(match[i] == 0 || dfs(match[i]))//只要满足没有被任何点匹配过或者匹配它的点可以找到另外可以匹配的点，就匹配。
			{
				match[i] = x;//匹配。
				return 1;//记得要返回真。
			}
		}
	}
	return 0;//如果匹配不到，返回假。
}
int main()
{
	n = read(),m = read(),e = read();
	for(int i = 1; i <= e; i++)
	{
		int u = read(),v = read();
		a[u][v] = 1;//将u和v建一条边。
	}
	for(int i = 1; i <= n; i++)
	{
		memset(p,0,sizeof(p));
		if(dfs(i))ans++;//如果可以匹配，就匹配，答案加一。
	}
	write(ans);
	return 0;
}
```