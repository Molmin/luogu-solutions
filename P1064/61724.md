# 还没有人写泛化背包的题解，我来补充上
泛化背包是解决背包问题的大杀器，尤其是复杂的树形依赖背包，比如本题。

## 什么是泛化物品
考虑这样一种物品，它并没有固定的费用和价值，而是它的价值随着你分配给它的费用而变化。这就是泛化物品的概念。

更严格的定义之。在背包容量为$V$的背包问题中，泛化物品是一个定义域为$0..V$中的整数的函数h，当分配给它的费用为$v$时，能得到的价值就是$h(v)$。
这个定义有一点点抽象，另一种理解是一个泛化物品就是一个数组$h[0..V]$，给它费用$v$，可得到价值$h[V]$。

一个费用为$c$价值为$w$的物品，如果它是01背包中的物品，那么把它看成泛化物品，它就是除了$h(c)=w$其它函数值都为$0$的一个函数。如果它是完全背包中的物品，那么它可以看成这样一个函数，仅当$v$被$c$整除时有$h(v)=v/c*w$，其它函数值均为$0$。如果它是多重背包中重复次数最多为$n$的物品，那么它对应的泛化物品的函数有$h(v)=v/c*w$仅当$v$被$c$整除且$v/c<=n$，其它情况函数值均为$0$。

一个物品组可以看作一个泛化物品$h$。对于一个$0..V$中的$v$，若物品组中不存在费用为v的的物品，则$h(v)=0$，否则$h(v)$为所有费用为$v$的物品的最大价值。P07中每个主件及其附件集合等价于一个物品组，自然也可看作一个泛化物品。

## 泛化物品的和
如果面对两个泛化物品$h$和$l$，要用给定的费用从这两个泛化物品中得到最大的价值，怎么求呢？事实上，对于一个给定的费用$v$，只需枚举将这个费用如何分配给两个泛化物品就可以了。同样的，对于0..V的每一个整数v，可以求得费用$v$分配到$h$和$l$中的最大价值$f(v)$。也即$f(v)=max{h(k) +l(v-k)|0<=k<=v}$。可以看到，$f$也是一个由泛化物品$h$和$l$决定的定义域为$0..V$的函数，也就是说，$f$是一个由泛化物品$h$和$l$决定的泛化物品。

由此可以定义泛化物品的和：$h、l$都是泛化物品，若泛化物品$f$满足$f(v)=max{h(k)+l(v-k)|0<=k<=v}$，则称$f$是$h$与$l$的和，即$f=h+l$。这个运算的时间复杂度是$O(V^2)$。

泛化物品的定义表明：在一个背包问题中，若将两个泛化物品代以它们的和，不影响问题的答案。事实上，对于其中的物品都是泛化物品的背包问题，求它的答案的过程也就是求所有这些泛化物品之和的过程。设此和为s，则答案就是$s[0..V]$中的最大值。

## 背包问题的泛化物品
一个背包问题中，可能会给出很多条件，包括每种物品的费用、价值等属性，物品之间的分组、依赖等关系等。但肯定能将问题对应于某个泛化物品。也就是说，给定了所有条件以后，就可以对每个非负整数v求得：若背包容量为v，将物品装入背包可得到的最大价值是多少，这可以认为是定义在非负整数集上的一件泛化物品。这个泛化物品——或者说问题所对应的一个定义域为非负整数的函数——包含了关于问题本身的高度浓缩的信息。一般而言，求得这个泛化物品的一个子域（例如0..V）的值之后，就可以根据这个函数的取值得到背包问题的最终答案。

综上所述，一般而言，求解背包问题，即求解这个问题所对应的一个函数，即该问题的泛化物品。而求解某个泛化物品的一种方法就是将它表示为若干泛化物品的和然后求之。

## 小注
以上这些文字来源于侯天翼的《背包九讲》，它对泛化背包进行了详尽的描述。美中不足的是，《背包九讲》没有给出详尽的C语言代码。这里我针对树形依赖背包这一问题编写了C++代码，C/P党可以参考实现。

可以看到，尽管是复杂的题目，也可以实现得比较优雅和简洁。

在存储方面，我将物品看做树的节点，除了价值$v$、价格$w$外，还有哥哥节点的编号$n$和节点的编号$c$。这类似于图论中的前向星存图方式。

## AC代码
这个解法是标准的泛化背包解法，但性能有些问题，需要开启O2，以及对容量预处理
```cpp
#include <bits/stdc++.h>

using namespace std;

struct Item {
    int v, w, n, c;
} items[65];

// 第i号物体，背包容量有m
int f[65][21000];

void dfs(int r, int cap) {
    for (int i = items[r].c; i; i = items[i].n) {
        dfs(i, cap - items[r].w);
    }

    // 先选附件
    for (int i = items[r].c; i; i = items[i].n) {
        // 对于每种容量
        for (int j = cap; j >= items[r].w; --j) {
            // 刨去保留的容量
            for (int k = 0; k <= j - items[r].w; ++k) {
                f[r][j] = max(f[r][j], f[r][j - k] + f[i][k]);
            }
        }
    }

    // 选上自己
    for (int j = cap; j >= items[r].w; --j) {
        f[r][j] += items[r].v;
    }

}

int main() {
    int m, n;
    cin >> m >> n;
    for (int i = 1; i <= n; ++i) {
        int p;
        cin >> items[i].w >> items[i].v >> p;
        items[i].w /= 10;
        items[i].v *= items[i].w;
        items[i].n = items[p].c;
        items[p].c = i;
//            cout << i << " " << items[i].w << " " << items[i].v << " " << p << endl;
    }
    dfs(0, m / 10);
    cout << f[0][m / 10] * 10 << endl;
    return 0;
}

```
原来的解法，这个解法不是泛化背包问题，比较tricky，但可以解决一层的依赖问题，性能比上述的强
```cpp
void dfs(int id, int m)
{
    for (int i = items[id].c; i; i = items[i].n)
    {
        // for ( int j = 0; j <= m - items[i].w; ++j )
        // {
        // 	dp[i][j] = dp[id][j];//为所有子树的根节点赋予初值
        // }
        memcpy(dp[i], dp[id], 4 * max(0, m - items[i].w + 1));
        dfs(i, m - items[id].w);
        for (int j = m; j >= items[i].w; --j)
        {
            dp[id][j] = max(dp[id][j], dp[i][j - items[i].w] + items[i].v);
        }
    }


}
```