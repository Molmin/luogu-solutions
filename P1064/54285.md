
理解了就非常简单了~~~不说多，贴代码~~~


```cpp
#include<iostream>
using namespace std;
//一维数组不超过 3000 0000
//!!!聪明把最多2件物品的重要度、价格都保存在主件上-这样看每个物品有3个
//v[4][0]-v[4][1]-v[4][2]表示第4件物品的主件价格-第4件物品第1件附件价格
//v-p都变成了二维 [61][3] 
int n,m;//n是总的钱--相当于以前的c， 有m件物品---相当于n 
int v[61][3];//第i件物品的价格：每个物品最多有2个附件下标全部从1开始
//每件物品的价格,v[i][0]表示主件编号i的价格
//v[i][1]表示主件编号i的附件1的价格
//v[i][2] 示主件编号i的附件2的价格
int p[61][3];//第i件物品中的重要度 
//每件物品的重要度,p[i][0]表示主件编号i的重要度
//p[i][1]表示主件编号i的附件1的重要度 p[i][1]
//p[i][2] 表示主件编号i的附件2的重要度 p[i][2]
//f[i][j]=前i件物品总花费为j的选择物品的总和价值最大
/*f[i][j]=max{
f[i-1][j];//1、不背第i件物品
f[i-1][j-v[i][0]]+p[i][0]*v[i][0];     //2、只背主件 
f[i-1][j-v[i][0]-v[i][1]]+p[i][0]*v[i][0]+p[i][1]*v[i][1] //3、背主件只要附件1 
f[i-1][j-v[i][0]-v[i][2]]+p[i][0]*v[i][0]+p[i][2]*v[i][2]//4、背主件只要附件2 
```
f[i-1][j-v[i][0]-v[i][1]-v[i][2]]+p[i][0]\*v[i][0]+p[i][2]\*v[i][2]
+p[i][1]\*v[i][1];//5、背主件加两个附件 

}
1000  5

800 2 0

400 5 1

300 5 1

400 3 0

500 2 0


\*/
int f[61\*3][32000];//f[i][j]前i件物品总钱为j的价值和最大:61\*3个附件

```cpp
void read()
{ int i,j,a,b,c,num=0;//num计主件的个数 
int map[61]={0};
cin>>n>>m;//读入总钱数和m件物品
n=n/10;//每件物品都是10的整数倍，可以优化程序
for(i=1;i<=m;i++)
{ cin>>a>>b>>c;//先用变量保存--判断好是主还是附近再赋值
 if(c==0) //先填主件，c才是主件
  { num++;//！！计一共有多少个主件，附件都记在主件第二维下标[1][2] 
   v[num][0]=a/10;
   p[num][0]=b;//i=4，是第4件其实不是的-因为前面的有可能是附件，而附件不记数 
   map[i]=num;//记下第i个物品的主件序号 
   continue;
  }
//c是物品的序号是i，不是num，而本题所有的附件要放在num主件上 
c=map[c];//i=2,c=1时 c=map[1]=1, i=3时，c=1 ,c=map[1]=1
//i=4,map[4]=2,i=5,map[5]=3
if(v[c][1]==0)//如果第c件物品的第1个附件还没有
        { v[c][1]=a/10; p[c][1]=b;
         continue;
        } 
    else { v[c][2]=a/10;p[c][2]=b;
         }    
```
}//填好 v,p两个数组
```cpp
//用背包;--主件和附件最多只被1次- 
for(i=1;i<=num;i++)//穷举所有的主件物品:
{
for(j=n;j>=0;j--)    //j是总重量总价格n：！！这是修改j>=0因为j<v[i][0]也要算 
{ //情况1：不选主件    :这里把j<v[i][0]的情况也要计算吧
 f[i][j]=f[i-1][j];//这时候f[i][j]=f[i-1][j]这个要执行.
 //情况2：只选主件
 //背得动
 if(j>=v[i][0])    //重要度*价格 
   f[i][j]=max(f[i][j],f[i-1][j-v[i][0]]+p[i][0]*v[i][0]);
//情况3：选主件和附件1
if(j>=v[i][0]+v[i][1])
  f[i][j]=max(f[i][j],f[i-1][j-v[i][0]-v[i][1]]+p[i][0]*v[i][0]+p[i][1]*v[i][1]);
 //情况4：选主件和附件2 
if(j>=v[i][0]+v[i][2])
f[i][j]=max(f[i][j],f[i-1][j-v[i][0]-v[i][2]]+p[i][0]*v[i][0]+p[i][2]*v[i][2]);
//情况5：主件+2个附件
if(j>=v[i][0]+v[i][1]+v[i][2])
f[i][j]=max(f[i][j],f[i-1][j-v[i][0]-v[i][1]-v[i][2]]+p[i][0]*v[i][0]+
p[i][1]*v[i][1]+p[i][2]*v[i][2]);  // if(a[i]>x) x=a[i]  x=max(x,a[i]);
} //end for j
}//end for i
cout<<f[num][n]*10;        
}
int main()
{read();
return 0;
}
```