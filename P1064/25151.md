此题应该注意的是，不用在意配件的状态，

因为每个配件是从属于其主件的，可以将其与主件合并，又因为每个主件最多有两个配件，也就是说：每个主件最多有四个状态：

w[主]；

w[主]w[副一]；

w[主]w[副二]；

w[主]w[副一]w[副二]；

所以就这样在读入时就预处理出每个主件及其配件，然后再动归时就是一个只用考虑每主件的01背包了。

详细的就不多讲，可以参考楼下，我也是参考了他的状态才改对的。

代码如下（也不是多完美）：



```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
int n,m;
int v[70],p[70],q[70];
int q1[70],q2[70];
int dp[40000];//dp[i]表示选取时花费为i时的题目要求的最大值 
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=m;i++)
    {
        scanf("%d%d%d",&v[i],&p[i],&q[i]);
        if(q[i]!=0)//预处理每个主件的附件 
        {
            if(q1[q[i]]==0) q1[q[i]]=i;
            else q2[q[i]]=i;
        }
    }
    for(int i=1;i<=m;i++)
    for(int j=n;j;j--)//至于为什么是n~1请查看01背包的一维操作，新手也可以先试试二维，这里就提供这个一维的 
    if(q[i]==0)//只用枚举主件的状态 ，下面整个就是01背包一维操作 
    {
        if(j-v[i]>=0) dp[j]=max(dp[j],dp[j-v[i]]+v[i]*p[i]);//主件状态一 
        if(q1[i]!=0&&j-v[i]-v[q1[i]]>=0) dp[j]=max(dp[j],dp[j-v[i]-v[q1[i]]]+v[i]*p[i]+v[q1[i]]*p[q1[i]]);//主件状态二 
        //如果有第一个附件 并且当前状态的钱能够买下主件i和其第一个附件 
        if(q2[i]!=0)//如果有第二个附件 
        {
            if(j-v[i]-v[q2[i]]>=0) dp[j]=max(dp[j],dp[j-v[i]-v[q2[i]]]+v[i]*p[i]+v[q2[i]]*p[q2[i]]);//主件状态三 
            if(j-v[i]-v[q1[i]]-v[q2[i]]>=0) dp[j]=max(dp[j],dp[j-v[i]-v[q1[i]]-v[q2[i]]]+v[i]*p[i]+v[q1[i]]*p[q1[i]]+v[q2[i]]*p[q2[i]]);
            //这两个if都是判断当前枚举的钱是否买得起第i主件和其第二附件或一二附件 
        }
    }
    printf("%d",dp[n]);//最后表示花n元获得最大价值（想想为什么？若不知道，想想dp表示的状态的意义） 
    return 0;
}
```
最后如有疑问，欢迎私信我。