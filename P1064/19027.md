#带有先决条件的背包问题

啊啊啊这个题。。。交了5次终于过了啊啊啊啊qwq。。。

这个题主要是**带有先决条件的背包问题**。

##【总体思路】说说思路

**先把备选物品中所有的带有先决条件的物品进行组合，组合成不同的购买方式，并把每一种购买方式单独视为一件商品。

比如在样例中：可以选择：买1、买1,2、买1,3、买1,2,3这三种选择。这四种选择组成一个集合，让这四件商品在自己的组中进行dp，决策出在每种状态下最大的值，然后再返回原来的dp数组进行比较、取最值。**

————————————————————无耻の分割线————————————————————

##【代码讲解】还是先说一下我的大体代码思路。

- 首先，读入数据。在读入数据的过程中，将数据存储在一个链表中。对于没有先决条件的物品，单独给予一个组。对于有先决条件的物品，将它连接在其先决条件的链表所在组中。并且在这个组里先前有的元素中全部再添加一种情况，就是有这个新元素的情况。（因为在加入这个元素之前，组内的元素都不包含这个新的元素。因此扩大这个组，生成“有这个新元素”和“没有这个新元素”的两种情况。）

- 然后直接开始dp。设置dp为主要的dp数组，tdp为temp\_dp组内使用的dp数组。在组内进行选择时，只需要按照顺序读取链表中存储的内容即可。链表中存储的情况全部拿出参与比较，注意并不像外面的主dp一样，这里的组内选举具有**唯一性**，即组内的数据只能有一种存在。

- 组内dp完成后，tdp数组中存在的内容就是组内最优解。与主dp数组取最大值。

- 当然，即便是一个物品没有附属物品也没有关系，因为那样对应组中只有一个元素，即它本身。因此会正常进行决策。

- 完成后，dp数组内存储的dp[m]就是最优解。

- 如果有人问为什么dp数组是一维而不是二维。。。这是一种背包问题的**空间复杂度压缩**。这种压缩不改变结果和时间复杂度，而且使用方便。

不压缩空间复杂度的dp伪代码：

```cpp
for(int i=2;i<=n;i++)
{
for(int j=price[i];j<=m;j++)
{
dp[i][j]=max(dp[i-1][j],dp[i-1][j-price[i]]++value[i]);
}
}
```
压缩空间复杂度的dp伪代码：

```cpp
for(int i=2;i<=n;i++)
{
for(int j=m;j>=price[i];j--)
{
dp[j]=max(dp[j],dp[j-price[i]]+value[i]);
}
}
```
好了。。。讲这么多，下面放代码。

有请代码君。。。啪啪啪啪啪啪啪鼓（da）掌（lian）。。。。

————————————————————无耻の分割线————————————————————

```cpp
#include<iostream>
#include<cstdio>
using namespace std;

struct base{int n,m,wm,next;};//存放组的结构体
base group[65];//组
int head[65],n,m,mlin=0;//head：每个物件对应的元素在链表中的第一个位置。如果元素是有先决条件的元素，则没有独立组。mlin：指向链表的最后一个元素。
int dp[32005],tdp[32005]; //dp数组。

int main()
{
    scanf("%d%d",&m,&n);
    for(int i=1;i<=n;i++)
    {
        int m,p,q;
        scanf("%d%d%d",&m,&p,&q);
        if(q==0)//表明该物品没有先决条件，直接连上一个新的组。
        {
            mlin++;
            group[mlin]=(base){i,m,p*m,head[i]};
            head[i]=mlin;
        }
        else//有先决条件，添加组合方式。
        {
            for(int j=head[q];j>0;j=group[j].next)
            {
                mlin++;
                group[mlin]=(base){i,m+group[j].m,p*m+group[j].wm,head[q]};
                head[q]=mlin;
            }
        }
    }
    for(int i=1;i<=n;i++)//主dp stand by。。。
    {
        for(int j=head[i];j>0;j=group[j].next)//在组内的dp
        {
            int mm=group[j].m;
            int wm=group[j].wm;
            for(int k=m;k>=mm;k--)//组里的dp
            {
                tdp[k]=max(max(tdp[k],dp[k]),wm+dp[k-mm]);
            }
        }
        for(int k=m;k>=1;k--)//执行完组内的dp，然后与主dp数组取最大值。
        {
            dp[k]=max(dp[k],tdp[k]);
            tdp[k]=0;
        }
    }
    printf("%d",dp[m]);
    return 0;
}
```
————————————————————无耻の分割线————————————————————

后记：终于写完了，感觉这道题令我很有收获，毕竟wa了5次呢。。。qwq。。。
