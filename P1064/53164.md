本题中，金明可以选择主件和附件，是一个典型的依赖背包

看到别人写的大多数是枚举四种情况，我就来写一个背包九讲P07的方法

```cpp
#define 重量 价格
#define 价值 重要度*价格
```
------------

因为本题中不存在依赖多个物品或者一个附件依赖另一个附件的情况，所以我们可以直接将主件及其附件看成一个组合，就转化成了P06的组合背包。

当然，有一个一定要选主件的限制，所以我们可以枚举所有选择附件的情况

### 例如我们有两个附件，我们可以直接枚举
		0.什么都不选（主件也不选）

		1.不选择附件

		2.选择第一个附件

		3.选择第二个附件
    
    	4.选择第一个附件和第二个附件
------------

但是，这样的方法其实有些低效（事实上，设有n个附件，则策略有2^n+1个，为指数级。）
（本题其实没关系）

那么如果有很多很多的附件我们应该怎么办呢？

这时我们想到，可以先把这个组合里的附件先通过01背包，将不同空间下的最大价值求出来，然后将这个空间和其最大价值看成一个新的附件

例如我们可能求出
		
        重量	0	1	2	3	4
		价值	0	4	5	5	7

那么我们就可以把它们看成是五个新的物品（重量，价值）
		
        （0,0），（1,4），（2,5），（3,5），（4,7）

这样每个再加上主件的重量和价值做一下组合背包就行了。

不过，细心的同学可能会发现，（2,5）和（3,5）的价值是一样的，但是重量上有区别。动态规划中，我们一直在追求最佳的选择，那么在同等价值的情况下，重量更小的肯定是占据优势的。

### **~~（如果一个物品比你轻还比你更有价值，那你就打不过它了）~~**


所以我们可以再删去（3,5）这个物品，这其实对应了P02中“一个简单有效的优化”

因此，我们就可以写出以下的代码

```cpp
#include<bits/stdc++.h>
using namespace std;

int n,m,x;
int w[61],v[61],dp[32003];
int group1[61][61],g1[61],g2[61];
pair<int,int> group2[61][32003];

int main()
{
    std::ios::sync_with_stdio(false);
    cin>>m>>n;
    for(int i=1;i<=n;++i)//读入 
    {
        cin>>w[i]>>v[i]>>x;
        v[i]*=w[i];//算出价值
        if(!x) group1[i][0]=i; //存主件
        else group1[x][++g1[x]]=i;//存附件
    }
    for(int i=1;i<=n;++i)//01背包&优化 
    {
        if(group1[i][0]==0) continue;//不是主件跳出
        memset(dp,0,sizeof(dp));     //清空dp数组 
        for(int j=1;j<=g1[i];++j) 
            for(int k=m-w[i];k>=w[group1[i][j]];--k) 
                dp[k]=max(dp[k],dp[k-w[group1[i][j]]]+v[group1[i][j]]);//附件01背包
        for(int j=0;j<=m-w[i];++j)
            if(dp[j]>dp[j-1])//01背包中，后一个空间的最大价值肯定≥前一个空间的最大价值
            {
                group2[i][++g2[i]].first+=j+w[i];
                group2[i][g2[i]].second+=dp[j]+v[i];//在group2中存数据； 
            }
        group2[i][0].first+=w[i];
        group2[i][0].second+=v[i];//因为0空间时主件的数据在前面被忽略掉了，所以现在我们要加回来
    }
    memset(dp,0,sizeof(dp));
    for(int k=1;k<=n;++k)//分组背包 
    {
        if(group2[k][0].first==0) continue;//不是主件跳出
        for(int j=m;j>=group2[k][0].first;--j)
            for(int i=0;i<=g2[k];++i)
                if(j>=group2[k][i].first) 
                    dp[j]=max(dp[j],dp[j-group2[k][i].first]+group2[k][i].second); 
    } 
    cout<<dp[m];
    return 0;
}
```