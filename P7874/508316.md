根据测试点我们逐个讨论。

## Testcase #0
输出样例，不用我多说了吧。

## Testcase #1
$k=2$，也就是只有两个集合。

因为相邻的数不能放在一个集合，所以 $1$ 和 $2$ 不在同一个集合中。

那么，这两个集合中的最小值就分别为 $1$ 和 $2$。

所以，答案就是 $a_1+a_2$。

## Testcase #2
留给暴力的。

## Testcase #3

$k=3$，也就是只有三个集合。

当只有两个集合的情况下，前两个集合贡献的答案是固定的，于是我们只需要讨论第三个集合。

显然，我们可以构造出第三个集合中最小值分别为 $3$ 到 $n$ 的情况，因为当第三个集合中的最小值为 $mn$ 时，我们可以将 $3$ 到 $mn - 1$ 的数字分给第一个集合或者第二个集合。

所以第三个集合贡献的答案就是 $a_3$ 到 $a_n$ 的最大值。

所以，答案就是 $a_1+a_2+max_{a_3-a_n}$

## Testcase #4
留给复杂度好一点的暴力。

## Testcase #5

需要正解了。

当你做到 Testcase #3 时，正解其实已经离你不远了。

我们发现，前两个集合贡献的答案是固定的，也就是 $a_1+a_2$。

所以我们对剩下的 $k-2$ 个集合进行讨论。

猜想：剩下 $k-2$ 个集合的答案就是从大到小取 $k-2$ 个数。

于是你过了这道题。

至于为什么是这样呢？

首先按照上面的猜想将使答案最大的 $k$ 个数先填充进 $k$ 个集合。

显然，剩下的 $n-k$ 个数可以再放入这 $k$ 个集合中并且与集合中的任意一个数不相邻，且不影响答案。

因为对于剩下的 $n-k$ 个数中的任意一个数 $p$，都可以塞到第一个集合中，因为没有正整数比 $1$ 小，所以不影响答案。

所以正解的答案就是 $a_1+a_2$ 再加上前 $k-2$ 大的数，并且这前 $k-2$ 大的数不能是 $a_1$ 或 $a_2$。

## 核心代码

```
if (k == 2) {
	printf ("%lld\n", a[1].val + a[2].val);
}
	
else {
	int mx = -1;
       
    long long ans = a[1].val + a[2].val;
	
	sort (a + 1, a + 1 + n, cmp);//从大到小排序。 
			
	int tot = 0;
			
	for (int i = 1; i <= n; i ++) {
		if (a[i].id != 1 && a[i].id != 2) {//不取a1和a2。 
			ans += a[i].val;
				
			tot ++;
		}
				
		if (tot == k - 2) {
		//取了 k-2 个数。 
				
			break;
		}
	}
			
	printf ("%lld\n", ans);
}
```

按照子任务一步一步做真的好容易启发正解的思路！
