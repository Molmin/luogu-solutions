首先，看到度数限制，就想到用 prufer 序列。

一棵树的 prufer 序列的生成方式就是以 $1$ 为根，每次选定编号最小的叶子，删除之并将它的父亲加入序列，直到只剩下两个点。

我们得到一个 prufer 序列后可以还原出树。具体地，每次设序列中的第一个点为 $x$，序列中不存在且没有父亲的编号最小点为 $y$，则连边 $x \to y$。最后连 $1$ 和没有父亲的唯一的点即可。

根据以上的生成方式和构造，我们可以实现树和序列的对应。

又因为对于任意一个长为 $n-2$ 的序列，第 $i$ 步时序列里还有 $n-1-i$ 个数，还有 $n-i$ 个点没有父亲，所以一定可以找到满足要求的点，故这个序列必定作为某棵树的 prufer 序列与之对应。

又由于定义中“最小”的确定性，不存在两棵树拥有相同的 prufer 序列，也没有两个序列能对应到同一棵树。这个的证明很容易，略去。

再给出一个结论：一个点的度数为 $d$ 则它在 prufer 序列里出现了 $d-1$ 次。这个结论很好证，只要注意到除 $1$ 号点外的每个点被它的所有儿子各塞进序列一次，$1$ 号点恰有一个儿子没有把它塞进序列，就是显然的了。

于是我们得到满足题目要求的树就是对应一个由 $d_1-1$ 个 $1$，$d_2-1$ 个 $2$，$\dots$，$d_n-1$ 个 $n$ 组成的序列对应回去的树。因此由双射结论我们只要求这样的序列的个数就行了。这种序列的个数可以直接上可重排列公式，显然我们把同样值的数全看作不同的能得到 $(n-2)!$ 种排列，然后去重，$k$ 个同样的数被计算了 $k!$ 次，因此最后的结果就是 $\dfrac{(n-2)!}{\prod_{i=1}^n(d_i-1)!}$。需要判断无解情况。

由于答案在计算过程中直接用阶乘相除会爆，最大可能到 $148!$ 远超 `__int128` 范围，所以我们可以用处理每个质数幂次的方法避免计算过大的数。只要对阶乘进行预处理就好了。

Code:
```cpp
#include<cstdio>
#define rg register
#define ll long long
int pr[37]=
{
	2,3,5,7,11,
	13,17,19,23,29,
	31,37,41,43,47,
	53,59,61,67,71,
	73,79,83,89,97,
	101,103,107,109,113,
	127,131,137,139,149
};
int n,d;
int cnt;
ll ans=1;
int res[37];
int fac[37][173];
int main()
{
	scanf(" %d",&n);
	for(rg int i=2,j;i<n;++i)
	{
		j=i;
		for(rg int k=0;k<35;++k)
		{
			fac[k][i]=fac[k][i-1];
			while(j%pr[k]==0)++fac[k][i],j/=pr[k];
		}
	}
	for(rg int i=0;i<35;++i)res[i]=fac[i][n-2];
	for(rg int i=0;i<n;++i)
	{
		scanf(" %d",&d);cnt+=d;if(d>=n)ans=0;
		for(rg int j=0;j<35;++j)res[j]-=fac[j][d-1];
	}
	if(cnt!=((n-1)<<1))ans=0;
	for(rg int i=0;i<35;++i)
	{
		while(res[i]>0)ans*=pr[i],--res[i];
	}
	printf("%lld\n",ans);
	return 0;
}
```