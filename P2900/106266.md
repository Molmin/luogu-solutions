本题适合刚接触并已经理解斜率优化+DP原理和过程的选手上手练习。


------------
看了题目，打包购买土地，价值为最大长与最大宽之积。这个地方就是本题的难点所在。

两块土地的长（a）与宽（b）共有下面几种情况：

1.两块土地长与宽大小分别相交。 即：a1<a2&&b1>b2或者a1>a2&&b1<b2
                                            
2.一块土地包含另一块。 即：a1<a2&&b1<b2或者a1>a2&&b1>b2;

第二种情况可以看出来，**被包含**的那一块土地实际上是可以与那块**包含**它的**大土地**一起购买，这样小土地价值即为0，称为“**免费购买**”

所以，在这样的情况下，我们可以以长度**从小到大**排序，借助一个单调栈，维护每块土地宽的**单调递减**（因为新进元素长度必定大于栈内元素，而宽度只要大于栈顶，即可包含该土地，使其价值为0，弹出。）

代码：
```cpp
for(i=1;i<=n;i++)scanf("%lld%lld",&p[i].a,&p[i].b);
sort(p+1,p+n+1,cmp);
for(i=1;i<=n;i++)
{
    while(top&&p[s[top]].b<=p[i].b)top--;
    s[++top]=i;
}
```


这样的话所有元素就仅仅剩下第一种情况了，我们可以用DP来考虑 。

设f[i]为购买第1~i块土地最小总价值

1.时间复杂度：O（n^2）

我们将栈内的元素由i从1到栈顶（top）枚举，j枚举0~i-1中元素，表示由第j块土地开始，将价值转移到f[i]上去

方程为：f[i]=f[j]+p[i].a*p[j+1].b（1<=i<=top&&0<=j<i）

(此刻最大的长必定是p[i].a,因为我们已经排过序了。最大的宽即为p[j+1].b,因为从0开始且由于单调栈以维护了1~j之间j元素的宽最大)

这时再看数据 1 ≤ N ≤ 50000  ~~（啊，推了这么久的初始化就炸了吗？！）~~

很容易可以看出来这时我们即可运用一种优化方法——**斜率优化**

------------
请读者在阅读一下思路前先了解一下斜率优化原理 ~~（否则可能会引起不适）~~

[留下一位大佬链接](https://blog.csdn.net/bill_yang_2016/article/details/54667902)

2.时间复杂度：O（n）

我们一样将i从1到top枚举，这时我们将i看做一个定值，把含有j的值表示出来，即可得到转移方程：

f[j]=-p[i].a*p[j+1].b+f[i];

乍一看，这有点像我们初中学的一次函数：y=kx+b

由于i确定，所以-p[i].a与f[i]均确定，而f[j]，p[j+1].b此时就成了变量。

因此y=f[j], x=p[j+1].b, k=-p[i].a, b=f[i],这个k的绝对值也就是我们所讲的斜率了。

于是我们大致得到这样一个函数图像：~~（初中数学不要问我为什么）~~
![无标题.png](https://i.loli.net/2019/06/14/5d0302a12d7d566617.png)
但在实际计算中，由于一个一个元素遍历，我们就必须维护这样一条直线，使得当前状态f[i]最小（回归题目所求）。

函数中：f[j]=-p[i].a*p[j+1].b+f[i];

当f[i]↓，f[j],p[j+1].b保持不变，则-p[i].a↑，即abs（-p[i].a）=p[i].a↓（用数学知识仔细想下）

所以我们要在算法中尽量维护斜率更小，这时可以用到数据结构：单调队列。
维护一个斜率递减的集合
即：

这时新进入一个元素，将存在这样两种情况需要维护

1.![无标题1.png](https://i.loli.net/2019/06/14/5d02f944ec70894916.png)

我们发现新进元素斜率必定小于队首，将其延长
![无标题2.png](https://i.loli.net/2019/06/14/5d02fa43e5b7431133.png)
则当前斜率下的直线与y轴交点即为b，也就是f[i],显然当前状态f[i]小于队首状态，维护单调性，将前面出队，只留下队尾元素和新进元素这一最优策略
代码：
```cpp
while(l<r&&f[s[q[l+1]]]-f[s[q[l]]]<=(p[s[q[l]+1]].b-p[s[q[l+1]+1]].b)*(p[s[i]].a))l++;
```
此时的队首元素j=q[l]即为最优决策，转移出f[i]的值
```cpp
j=q[l];
f[s[i]]=f[s[j]]+p[s[i]].a*p[s[j+1]].b;
```
2.![无标题4.png](https://i.loli.net/2019/06/14/5d02fe875b7ff91302.png)
可以发现此时有一个上凸点，不论直线斜率为多少，最优决策不可能是R，所以将其出队，并继续维护队尾的单调性。
```
while(l<r&&(f[s[q[r]]]-f[s[q[r-1]]])*(p[s[i+1]].b-p[s[q[r]+1]].b)<=(f[s[i]]-f[s[q[r]]])*(p[s[q[r]+1]].b-p[s[q[r-1]+1]].b))r--;
```
（这里代码看不懂程序里还有详解）
最后，我们再将当前元素i进队就可以啦！

上代码：
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
int n,q[2000005],s[2000005],top;long long f[50005];
struct node{
    long long a,b;
}p[50005];
bool cmp(node x,node y)
{return x.a<y.a;}//这里最好不用operator，有些网站编译器可能会CE
int main()
{
    int i,j,k,x,y;
    cin>>n;
    for(i=1;i<=n;i++)scanf("%lld%lld",&p[i].a,&p[i].b);
    sort(p+1,p+n+1,cmp);//按长度排序
    for(i=1;i<=n;i++)
    {
        while(top&&p[s[top]].b<=p[i].b)top--;
        s[++top]=i;
    }//初始化免费土地
    int l=0,r=0;
    for(i=1;i<=top;i++)
    {
        while(l<r&&f[s[q[l+1]]]-f[s[q[l]]]<=(p[s[q[l]+1]].b-p[s[q[l+1]+1]].b)*(p[s[i]].a))l++;//判断队首斜率与当前斜率大小关系，注意不等式符号的变化
        j=q[l];
        f[s[i]]=f[s[j]]+p[s[i]].a*p[s[j+1]].b;//状态转移
        while(l<r&&(f[s[q[r]]]-f[s[q[r-1]]])*(p[s[i+1]].b-p[s[q[r]+1]].b)<=(f[s[i]]-f[s[q[r]]])*(p[s[q[r]+1]].b-p[s[q[r-1]+1]].b))r--;//判断当前斜率与队尾关系，这里最好在草稿上解一解，符号的变化很可能导致错误
        q[++r]=i;
    }
//注意：1.我是将/号全换做了*号（看着舒服点）读者也可直接用tan三角函数计算斜率。
//	2.这里s数组存的是编号，i遍历的是栈的编号，关于i的引用，队列等均需套一个s数组。
    printf("%lld\n",f[s[top]]);//输出
}
```
小结：当见到一道斜率优化题，可以先将这道题的暴力代码和思路想出来，再根据暴力的状态转移方程，将i值确定，用函数方式表示枚举的j状态，将y，x与斜率分别指代的数值明确，注意在斜率以及截距b必须以带i的状态表示（因为已确定），带入套路求解即可。