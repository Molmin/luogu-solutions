# 从零开始的CF47B题解
本蒟蒻的第三篇题解，希望管理员大大给过。（虽然已经有好多题解了，但是看了一样，我这个还是有点不一样。）

Update：为了符合博客风格，修改了标题。

## 01 $char$ 与 $int$ 的关系

介于这是道入门题，有必要介绍一下字符与 $int$ 类型的对应关系。

### ASCII码

[啥也不知道的建议看这](https://baike.baidu.com/item/ASCII/309296?fr=aladdin)

根据 $ASCII$ 码的基本概念我们可以知道，每个字符都有一个对应的整数（当然事实上是8位二进制码）。

而利用这一点我们可以直接将字符作为数组下标来表示该编号硬币的质量。

这也是我思路的关键。

## 02 本题算法

在入门题中使用拓扑排序和结构体显然不太友好，所以我们愉快的采用模拟。~~其实是我不咋会拓扑排序。~~

## 03 本题思路

### 质量计算
因为输入的只有三个字符串，因此我们不妨直接采取固定格式的输入。不妨把三句输入认为是 $a1[n]$ , a2[n]$ , a3[n]$ ,我们通过读取 $a1[1]$ , a2[1]$ , a3[1]$ 来寻找三个数之间的关系。

而如果符号是 $>$ 的话，我们则将较大元素质量加一，这个时候就可以体现 01 中的关系了。

这也就是本题最重要的部分，部分代码见下。

```cpp
scanf("%s%s%s",a1,a2,a3);
    if(a1[1]=='>') ans[a1[0]]++;//以下6行对于<，>进行判断来处理质量关系
    else ans[a1[2]]++;
    if(a2[1]=='>') ans[a2[0]]++;
    else ans[a2[2]]++;
    if(a3[1]=='>') ans[a3[0]]++;
    else ans[a3[2]]++;
```

### 大小判断
我认为的较优方法是使用结构体，但是那样不太友好，考虑到规模小，我们通过记录 $maxx$ , $minn$ 的方法来计算出中间硬币的质量（已知总质量为3），再通过遍历的方法找到这个质量对应的元素。

### 判断 $Impossible$ 条件

观察题目，题中说到三枚硬币质量不同，这也就是我们的边界条件了：

${ans['A']=ans['B']} (1)$

${ans['C']=ans['B']}(2)$

${ans['A']=ans['C']}(3)$

只要 $(1),(2),(3)$中的一个式子成立则可以判断该情况不存在。

## 04 AC代码

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
char a1[20],a2[20],a3[20];
int ans[200],maxx,minn=1e9,maxx1,minn1,midd1,midd;
int main(){
    scanf("%s%s%s",a1,a2,a3);
    if(a1[1]=='>') ans[a1[0]]++;//以下6行对于<，>进行判断来处理质量关系
    else ans[a1[2]]++;
    if(a2[1]=='>') ans[a2[0]]++;
    else ans[a2[2]]++;
    if(a3[1]=='>') ans[a3[0]]++;
    else ans[a3[2]]++;
    for(int i=65;i<=67;i++){
        if(ans[i]>maxx){maxx=ans[i];maxx1=i;}
        if(ans[i]<minn){minn=ans[i];minn1=i;}
    }//这几行来判断大小，朴素的排序方法，因为只有3个数
    midd=3-maxx-minn;
    for(int i=65;i<=67;i++){
        if(ans[i]==midd) midd1=i;
    }//遍历法找到中间数
    if(maxx==midd||minn==maxx||midd==maxx){
        cout<<"Impossible";
        return 0;
    }//判断不存在情况边界
    printf("%c%c%c",minn1,midd1,maxx1);
}
```
抄题解没有意义，可以看过一遍后自己边想边写。

## 05 小小的易错点

### 下标关系

因为我们是以字符串的方法读入的，因此下标范围是 $0-2$ 而不是 $1-3$ 。

 _祝每个看到题解的人都能AC，然后祝本题解能够过审。_ 
