本题只有3枚硬币，如果你只是想A掉此题，你可以跳过本题解。如果你是神仙，也可以跳过本题解。本题解将讨论如果不只有3枚硬币，而是$10^6$枚时应如何应对。

本题解将介绍**拓扑排序**。（如果您已经会了就略过本题解吧。）
______________________________________________

前置知识：图的基本概念、图的存储、队列的基本应用。

首先介绍如何将本题转化为一张图。

对于每一组输入，如果是 $u>v$ 的形式，我们把 $u$ 和 $v$ 交换一下，让它变成 $u<v$ 。

然后将 $u$ 向 $v$ 连一条有向边。表示 $u$ 比 $v$ 小。

将所有数据读入，图顺道就建好了。

我们先想一想，什么情况下会“Impossible”。

很明显，我们刚刚建的图**有环**就会“Impossible”。



------------

下面开始讲拓扑排序。

定义：**拓扑序列**：对一个有向无环图G进行拓扑排序，是将 $G$ 中所有顶点排成一个线性序列，使得图中任意一对顶点 $u$ 和 $v$，若边 $<u,v> \in E(G)$ ，则 $u$ 在线性序列中出现在 $v$ 之前。

感性的理解一下：就是本题让你输出的东西。

举个例子：

![none](https://cdn.luogu.com.cn/upload/image_hosting/ct58bfwl.png)



























对于这个图，有拓扑序列：1→2→4→3和1→4→2→3。

我们再理解一下，就是这个节点的“父亲”（将就着理解吧）都被输出了，它才能被输出。

还有一点，一张图的拓扑序列可能不唯一。比如上边那张图就有2个。

**拓扑排序的任务就是输出一种拓扑序列，同时也可以判环。**



------------



算法思路：
- 统计每个节点的入度 $in$（这个在建图时就可以计算）。

- 首先将所有 $in=0$ 的节点进入队列 $q$。 

- 循环以下几步直至 $q$ 空：

- 取出队头，将对头标记为已访问过（判环用），将所有队头指向的节点 $in-1$。

- 输出队头。

- 如果队头指向的节点已经被访问过，证明本图有环。

- 如果队头指向的某一（些）节点 $in=0$ ,将这一（些）节点入 $q$。

这个就是拓扑排序了。



------------

但本题有特殊的地方：

1. 拓扑排序第四步在本题先要将输出的数存到一个队列 $out$ 里。因为有可能会“Impossible”，但在“Impossible”之前就输出了一些东西。

2. 本题可能根本就没有入度为1的点，那个图就是一整个环。有可能会什么也没输出，所以要特判一下。



------------
代码：

```cpp
#include<iostream>
#include<cstdio>
#include<queue>
#define n 3
using namespace std;
int h[n+10],tot=0,vis[n+10],in[n+10];
bool p=0;
char d,f,c;
queue <int> q,out;
struct edge
{
	int u,v,next;
}e[2*n+10];
void add(int u,int v)
{
	tot++;
	e[tot].u=u;
	e[tot].v=v;
	e[tot].next=h[u];
	h[u]=tot;
}
int main()
{
	int i,j,u,v;
	//建图 ↓ 
	for(i=1;i<=n;i++)
	{
		cin>>d>>c>>f;
		if(c=='>')
		{
			swap(d,f);
		}
		u=(d-'A'+1);
		v=(f-'A'+1);
		add(u,v);
		in[v]++;
	}
	//拓扑排序 ↓ 
	for(i=1;i<=n;i++)
	{
		if(in[i]==0)
		{
			q.push(i);
		}
	}
	while(!q.empty())
	{
		u=q.front();
		q.pop();
		vis[u]=1;
		out.push(u+'A'-1);
		p=1;
		for(i=h[u];i;i=e[i].next)
		{
			in[e[i].v]--;
			if(vis[e[i].v]==1)
			{
				cout<<"Impossible"<<endl;
				return(0);
			}
			if(in[e[i].v]==0)
			{
				q.push(e[i].v);
			}
		}
	}
	//输出 ↓ 
	while(!out.empty())
	{
		cout<<char(out.front());
		out.pop();
	}
	//特判是不是没有in=0的点 ↓ 
	if(!p)
	{
		cout<<"Impossible"<<endl;
		return(0);
	}
	cout<<endl;
	return(0);
}
```

咕咕咕~

20200215 修改程序注释的锅