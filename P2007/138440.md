这一题真的很考验耐心和细心，如果家里有魔方的话可以拿家里的魔方自己试一试，如果没有也可以手动在草稿纸上推一下，主要是理清楚相邻两面在旋转时棱块和角块如何变动，再来就是耐心把代码写出来吧！
```cpp
#include<bits/stdc++.h>
using namespace std;
char magic[6][3][3]; //定义一个魔方，6表示六个面，第一个3表示每一面的行数，后一个3表示每一面的列 
char move[102]; //输入移动方法 
int main(){
	scanf("%s",&move); //输入步数 
	for(int i=0;i<6;++i) //输入魔方 
		for(int j=0;j<3;++j)
			for(int k=0;k<3;++k)
				cin>>magic[i][j][k];
				
	int len=strlen(move); 
	
	for(int i=0;i<len;++i){ //进行每一步操作 
		if(move[i]=='1'){ //操作一
			char a,b,c;
			//右边一列的旋转,方式为下面的右侧移动到前面的右侧 前面的右侧移动到上面的右侧
			//上面的右侧移动到后面的右侧 后面的右侧移动到下面的右侧 
			a=magic[0][0][2]; 
			b=magic[0][1][2];
			c=magic[0][2][2];
			
			magic[0][0][2]=magic[5][0][2];
			magic[0][1][2]=magic[5][1][2];
			magic[0][2][2]=magic[5][2][2];
			
			magic[5][0][2]=magic[1][0][2];
			magic[5][1][2]=magic[1][1][2];
			magic[5][2][2]=magic[1][2][2];
			
			magic[1][0][2]=magic[4][0][2];
			magic[1][1][2]=magic[4][1][2];
			magic[1][2][2]=magic[4][2][2];
	
			magic[4][0][2]=a;
			magic[4][1][2]=b;
			magic[4][2][2]=c;
			//注意旋转时侧面也会旋转
			//而且是左上移动到右上 右上到右下 右下到左下 左下到右上
			//上层的棱块到右侧 右侧棱块到下层 下层棱块到左侧 左侧棱块到上层 
			a=magic[3][0][0];   
			magic[3][0][0]=magic[3][2][0];
			magic[3][2][0]=magic[3][2][2];
			magic[3][2][2]=magic[3][0][2];
			magic[3][0][2]=a;
			a=magic[3][0][1];
			magic[3][0][1]=magic[3][1][0];
			magic[3][1][0]=magic[3][2][1];
			magic[3][2][1]=magic[3][1][2];
			magic[3][1][2]=a;
		}
		else if(move[i]=='2'){ //操作二 
			char a,b,c;
			//右边一列的旋转,方式为下面的右侧移动到后面的右侧 后面的右侧移动到上面的右侧
			//上面的右侧移动到前面的右侧 前面的右侧移动到下面的右侧 
			a=magic[0][0][2]; 
			b=magic[0][1][2];
			c=magic[0][2][2];
			
			magic[0][0][2]=magic[4][0][2];
			magic[0][1][2]=magic[4][1][2];
			magic[0][2][2]=magic[4][2][2];
			
			magic[4][0][2]=magic[1][0][2];
			magic[4][1][2]=magic[1][1][2];
			magic[4][2][2]=magic[1][2][2];
			
			magic[1][0][2]=magic[5][0][2];
			magic[1][1][2]=magic[5][1][2];
			magic[1][2][2]=magic[5][2][2];
	
			magic[5][0][2]=a;
			magic[5][1][2]=b;
			magic[5][2][2]=c;
			//注意旋转时侧面也会旋转
			//而且是左上移动到左下 左下到右下 右下到右上 右上到左上 
			//上层的棱块到左侧 左侧棱块到下层 下层棱块到右侧 右侧棱块到上层 
			a=magic[3][0][0];   
			magic[3][0][0]=magic[3][0][2];
			magic[3][0][2]=magic[3][2][2];
			magic[3][2][2]=magic[3][2][0];
			magic[3][2][0]=a;
			b=magic[3][0][1];
			magic[3][0][1]=magic[3][1][2];
			magic[3][1][2]=magic[3][2][1];
			magic[3][2][1]=magic[3][1][0];
			magic[3][1][0]=b;
		}
		else if(move[i]=='3'){ //操作三 
			char a,b,c;
			//上面一层的旋转,方式为前面的上层移动到左面的上层 左面的上层移动到后面的上层 
			//后面的上层移动到右面的上层 右面的上层移动到前面的上层 
			a=magic[0][0][0]; 
			b=magic[0][0][1];
			c=magic[0][0][2];
			
			magic[0][0][0]=magic[2][0][0];
			magic[0][0][1]=magic[2][0][1];
			magic[0][0][2]=magic[2][0][2];
			
			magic[2][0][0]=magic[1][0][0];
			magic[2][0][1]=magic[1][0][1];
			magic[2][0][2]=magic[1][0][2];
			
			magic[1][0][0]=magic[3][0][0];
			magic[1][0][1]=magic[3][0][1];
			magic[1][0][2]=magic[3][0][2];
	
			magic[3][0][0]=a;
			magic[3][0][1]=b;
			magic[3][0][2]=c;
			//注意旋转时顶层也会旋转
			//而且是左上移动到右上 右上到右下 右下到左下 左下到右上
			//上层的棱块到右侧 右侧棱块到下层 下层棱块到左侧 左侧棱块到上层 
			a=magic[4][0][0];  
			magic[4][0][0]=magic[4][2][0];
			magic[4][2][0]=magic[4][2][2];
			magic[4][2][2]=magic[4][0][2];
			magic[4][0][2]=a;
			b=magic[4][0][1];
			magic[4][0][1]=magic[4][1][0];
			magic[4][1][0]=magic[4][2][1];
			magic[4][2][1]=magic[4][1][2];
			magic[4][1][2]=b;
		}
		else if(move[i]=='4'){ //操作四 
			char a,b,c;
			//上面一层的旋转,方式为前面的上层移动到右面的上层 右面的上层移动到后面的上层 
			//后面的上层移动到左面的上层 左面的上层移动到前面的上层 
			a=magic[0][0][0];  
			b=magic[0][0][1];
			c=magic[0][0][2];
			
			magic[0][0][0]=magic[3][0][0];
			magic[0][0][1]=magic[3][0][1];
			magic[0][0][2]=magic[3][0][2];
			
			magic[3][0][0]=magic[1][0][0];
			magic[3][0][1]=magic[1][0][1];
			magic[3][0][2]=magic[1][0][2];
			
			magic[1][0][0]=magic[2][0][0];
			magic[1][0][1]=magic[2][0][1];
			magic[1][0][2]=magic[2][0][2];
	
			magic[2][0][0]=a;
			magic[2][0][1]=b;
			magic[2][0][2]=c;
			//注意旋转时顶层也会旋转 
			//而且是左上移动到左下 左下到右下 右下到右上 右上到左上 
			//上层的棱块到左侧 左侧棱块到下层 下层棱块到右侧 右侧棱块到上层 
			a=magic[4][0][0]; 
			magic[4][0][0]=magic[4][0][2];
			magic[4][0][2]=magic[4][2][2];
			magic[4][2][2]=magic[4][2][0];
			magic[4][2][0]=a;
			b=magic[4][0][1];
			magic[4][0][1]=magic[4][1][2];
			magic[4][1][2]=magic[4][2][1];
			magic[4][2][1]=magic[4][1][0];
			magic[4][1][0]=b;
		}
	}
	for(int i=0;i<6;++i) //输出 
		for(int j=0;j<3;++j){
			for(int k=0;k<3;++k)
				printf("%c",magic[i][j][k]);
				printf("\n");
		}
	return 0;
}
```

写完后自己再检验一下，因为代码可能很长就很容易出错，最后祝大家可以通过这一题
