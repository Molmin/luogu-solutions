我们可以把 $s$ 与 $u$ 都设定成 $i$。每一次，只要条件满足，就可以把 $u$ 加一，即发现了右边也合法，更新山的长度。

```cpp
while (u < n && h[u] < h[u + 1]) ++u;//在t前面
while (u < n && h[u] > h[u + 1]) ++u;//在t后面
```

那么，就可能会有重复出现，这样怎么办呢？

我们可以把重复情况分为 $2$ 种，第一种是一座山**完全**包含另一座，即下图情况：

![](https://ftp.bmp.ovh/imgs/2021/05/6e9fb01fc5469841.jpg)

这样，$s_1$ 比 $s_2$ 小，$u_1$ 比 $u_2$ 大，那么 $u_1 - s_1 + 1$ 肯定比 $u_2 - s_2 + 1$ 大，而题目要我们求出**最大**的，于是可以忽略。

第二种是两座山在某个点共用。如下图：

![](https://ftp.bmp.ovh/imgs/2021/05/52013b20fc10ba9a.jpg)

这样，我们可以每一次加上一个特判，就是如果新的一座山发现前面一座山与它重复（即满足条件），那么我们就可以把 $s$ 减 $1$，这样就可以了，但是要注意是不是第一座山，如果是就不用把 $s$ 减 $1$ 了。

```cpp
if (s > 1 && h[s - 1] < h[s]) s--;
```

但是，不可能出现两座山有一段区域重复，因为题目保证不会有两个位置高度相等，那么前一座山单调递减（不能单调递增，否则就会变成第一种情况）而后一座山单调递增，但是，这一段区域高度**不会**既递减又递增，所以不可能。