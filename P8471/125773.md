> ## 题意简述
>
> 给定一个字符 $\texttt{A, B}$ 构成的字符串，求一个与它等长的字符串，也由 $\texttt{A, B}$ 构成，且包含 $a$ 个 $\texttt A$，和原串有 $e$ 处不同。

## 解法

与其求一个新串，我们不如考虑在原串上进行 $e$ 次 **修改**，每次改一个字符。

对修改后的串的要求，只有 “要有 $a$ 个 $\texttt A$” 一条，这就告诉我们，只需关注 $\texttt A$ 与 $\texttt B$ 的 **数量，而它们的位置则是任意的**。这也是本题有多解的原因。

那么，我们要求出新串 **之一**，就只需知道，要把多少个 $\texttt A$ 改为 $\texttt B$，以及要把多少个 $\texttt B$ 改为 $\texttt A$。我们把这两个数量设为 $x$ 和 $y$。

如何求 $x$ 和 $y$ 呢？到题目中找条件。

- **所求串的长度为 $2n$。** 无论修改多少次，串的长度都是 $2n$，故无法列出关于 $x, y$ 的方程。

- **所求串由 $\texttt{A, B}$ 构成。** 同样，无论无论修改多少次都能满足这个条件，也无法列出方程。

- **所求串包含 $a$ 个 $\texttt A$。** 有用的来了！原串中 $\texttt A$ 的数量 $a'$ 只要遍历一遍原串即可求，或者我们 ~~偷个小懒~~ 用 `a_ =  count(s.begin(), s.end(), 'A')` 也行（`count` 函数在 `algorithm` 头文件里）。而一次 $\texttt A$ 改为 $\texttt B$ 会少一个 $\texttt A$，一次 $\texttt B$ 改为 $\texttt A$ 会多一个 $\texttt A$，故有：

$$ a'+x\cdot(-1)+y\cdot 1=a$$
$$ -x+y=a-a'\ (1) $$

- **所求串和原串有 $e$ 处不同。** 由于两种修改都会造成一处不同，故

$$ x+y=e\ (2) $$

OK，条件看完了，我们发现，两个未知数，两个方程，可以解出来！

$$\frac{(1)+(2)} 2: y=\frac{a-a'+e} 2$$
$$\frac{-(1)+(2)} 2: x=\frac{-a+a'+e} 2$$

**这时必须保证：** 我们的 $x$ 是 $0\sim a'$ 的整数，$y$ 是 $0\sim b'$ 的整数。（不然你就没法修改了对不对）如果不符合，输出 `-1`。
 
> 如何判整数？可以看分子，如果 `(-a+a_+e)&1==1` ，$x$ 即为整数。而且只需判一次，因为两个数和为整数，所以只要 $x$ 是整数，$y$ 肯定也是。

那最后就很简单了：把原串里的前 $x$ 个 $\texttt A$ 换成 $\texttt B$，把原串里的前 $y$ 个 $\texttt B$ 换成 $\texttt A$ ——此处注意，必须一个循环里同时做这两件事；如果你先一次全部 $\texttt A \to \texttt B$ 后，再 $\texttt B$ 换成 $\texttt A$，就会把你刚刚变出来的 $\texttt B$ 又变回去了。这个时候本来的 $2$ 次更改就会变成 $0$ 次，不符合题意。

最后输出得到的串即可。

> PS: 感觉这个可以评橙的，你看这年头 KMP 都才黄（

```
int a_ = count(s.begin(), s.end(), 'A'), b_ = count(s.begin(), s.end(), 'B');
if((a-a_+e)&1) {cout<<"-1\n"; continue; }
int x=-a+a_+e>>1, y=a-a_+e>>1;
if(x<0 || x>a_ || y<0 || y>b_) cout<<"-1\n";
else{
	int A_edited=0, B_edited=0;
	for(int i=0; i<2*n; i++){
		if(s[i]=='A' && A_edited<x){
			s[i]='B';
			A_edited++;
		}
		else if(s[i]=='B' && B_edited<y){
			s[i]='A';
			B_edited++;
		}
	}
	cout<<s<<"\n";
}