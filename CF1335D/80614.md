这道题要求最多只能修改 $9$ 个格子的数，但是题目给的就是一个已经填好的标准数独（每行，每列，每宫的数字均不重复且均为 $1$~$9$）现在要变成（每行，每列，每宫有且仅有两个数字重复）但是我们肯定是每行要改一个数字，这样的肯定要把 $9$ 次修改机会全部用上，我们知道，一旦你在一个格子修改了一个数，那么这个格子的所在行，列，宫就已经满足条件了，以后就不能再修改了。所以，你选的 $9$ 个格子要满足任意两个格子不在一行上，一列上，也不在一个宫上。然后再将这 $9$ 个格子上的数字改一下就行了。

可能你自己构造出这 $9$ 个格子的位置比较麻烦，你可以另写一个程序来得出这 $9$ 个格子的位置，下列推荐一个能够构造出这 $9$ 个格子的位置的程序，每次确定一个格子就将这个格子的所在行，所在列和所在宫的所有格子标记上，以后就不能选了。你也可以进行全排列（这个全排列的数就是某一行的要选的格子的所在列）然后再判断这些各自是不是都在不同的宫里。这样可以获得所有的可以选择的这 $9$ 个格子的位置（其实选择一种就行，所以还是强烈建议选择第一种方法）。

# code:
```cpp
#include<cstdio>
using namespace std;
char a[15][15];
int main(){
    int t;
    scanf("%d",&t);
    while(t--){
        int i;
        for(i=1;i<=9;i++){
            scanf("%s",a[i]);//这里每行第0个字符代表第一个格子
        }
        a[1][0]=a[1][1];
        a[2][3]=a[2][4];
        a[3][6]=a[3][7];
        a[4][1]=a[4][0];
        a[5][4]=a[5][3];
        a[6][7]=a[6][6];
        a[7][2]=a[7][1];
        a[8][5]=a[8][4];
        a[9][8]=a[9][7];
        for(i=1;i<=9;i++){
            printf("%s\n",a[i]);
        }
        printf("\n");
    }
    return 0;
}
```

# 构造格子位置代码： 
```cpp
#include<cstdio>
using namespace std;
bool a[15][15];
void print(int x,int y){
    int i,j,n,m;
    for(i=1;i<=9;i++){
        a[x][i]=1;
        a[i][y]=1;
    }
    n=(x-1)/3+1;
    m=(y-1)/3+1;
    for(i=n*3-2;i<=n*3;i++){
        for(j=m*3-2;j<=m*3;j++){
            a[i][j]=1;
        }
    }
    return ;
}
int main(){
    int i,j;
    for(i=1;i<=9;i++){
        for(j=1;j<=9;j++){
            if(!a[i][j]){
                printf("%d %d\n",i,j);
                print(i,j);
            }
        }
    }
    return 0;
}
```
