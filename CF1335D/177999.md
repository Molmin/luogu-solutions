# CF1335D Anti-Sudoku
## 题目大意:
本题共有 $t$ 组数据, 对于每一组数据, 给定一个保证正确的已经完成的数独, 请你改动**至多 $9$ 个**数独中的数, 使得改动后数独中每行每列每宫中都至少有两个数相等, 请输出一个可行的改动后的数独。
## 解法:
玩玩数独就可以知道, 改变数独中的一个格子中填的数, 会使它所在的那一行、那一列以及那一宫都出现一组重复的数。而我们知道改变一个数会仅使它那一宫出现一组重复的数, 而题目中要求每一宫都有一组重复的数, 所以我们必定要改动 $9$ 个数。在综合前面的结论以及简单构造就可以知道, 改动 $(1, 1), (2, 4), (3, 5), (4, 2), (5, 5), (6, 8), (7, 3), (8, 6)$ 以及 $(9, 9)$ 这几个位置上的数就可以满足要求。然后这题就做完了。

下面是我的Code:
```cpp
#include<iostream>
using namespace std;
typedef long long ll;
ll ans, cnt, n, b, c, t;
char a[10][10];
int main(){
	cin >> t;
	while(t--){
		for(int i = 1;i <= 9;i++){
			for(int j = 1;j <= 9;j++){
				cin >> a[i][j];
			}
		}
		a[1][1] = (char)((a[1][1] - '0') % 9 + 1 + '0');
		a[4][2] = (char)((a[4][2] - '0') % 9 + 1 + '0');
		a[7][3] = (char)((a[7][3] - '0') % 9 + 1 + '0');
		a[2][4] = (char)((a[2][4] - '0') % 9 + 1 + '0');
		a[5][5] = (char)((a[5][5] - '0') % 9 + 1 + '0');
		a[8][6] = (char)((a[8][6] - '0') % 9 + 1 + '0');
		a[3][7] = (char)((a[3][7] - '0') % 9 + 1 + '0');
		a[6][8] = (char)((a[6][8] - '0') % 9 + 1 + '0');
		a[9][9] = (char)((a[9][9] - '0') % 9 + 1 + '0');
		for(int i = 1;i <= 9;i++){
			for(int j = 1;j <= 9;j++){
				cout << a[i][j];
			}
			cout << endl;
		}
	}
	return 0;
}
```
上述算法的复杂度为 $O(t)$, 可以通过此题。