考虑用二分来求解。

## 【思路】：

对于每一个 $1$ 到 $n$ 的数，都用一个向量来存其每次出现的下标，而查询时用二分查找，查第一个大于等于 $l$ 和大于 $r$ 的位置，相减既是答案，因为其中间的必符合要求。

这里的二分查找不必手写，可以调用 STL 中的函数：

- `bin_search(数组名 + 1, 数组名 + 元素个数 + 1, 查找元素)`：如果给定数组中有查找元素，返回最早出现的下标，否则返回 $-1$。

- `lower_bound(数组名 + 1, 数组名 + 元素个数 + 1, 查找元素) - 数组名`：查找第一个大于等于查找元素的值的下标。

- `upper_bound(数组名 + 1, 数组名 + 元素个数 + 1, 查找元素) - 数组名`：查找第一个大于（注意没有等于）查找元素的值的下标。

## 【代码】：

懒得贴了，完结撒花。