**前排提示：这篇题解主要讲解基于二叉排序树的排序。**

## 基本概念
二叉排序树是具有一下几种性质的**二叉树**：
- 任何节点的左或右儿子不空，则左或右子树上所有节点均小于他的根节点的值。
- 这棵树的所有子树也均为二叉排序树。
- 一般情况下没有 $key$ 值相等的节点。

二叉排序树的最大特点就是有序性。对于任意一个节点，它的左子树上所有节点的值都小于它的值，其右子树上所有节点的值都大于它的值。因此，对于一个二叉排序树，它的中序遍历结果是一个递增的有序序列。

最朴素的二叉排序树的插入删除操作复杂度均为树高。每次操作期望 $O(\log_2n)$，最坏 $O(n)$（原数列有序，树退化成一条链）。其支持动态查询，改进版的二叉排序树可使树高恒为 $\log_2n$，如   $\operatorname{Treap}$ 等。

## 二叉排序树的插入

由于二叉排序树的有序性，所以插入操作可以使用二分查找的思想来实现。具体来说，对于一个节点，如果要插入一个值 $v$，我们可以比较 $v$ 和该节点的值，如果 $v$ 小于该节点的值，则在左子树中插入；如果 $v$ 大于该节点的值，则在右子树中插入。

如果你还是不太会写，我们具体来分一下步骤：

1. 若 $t$ 为空树，则将 $v$ 作为根节点插入，否则执行步骤 $2$。
2. 若 $v$ 等于根节点节点的值，返回即可，否则执行步骤 $3$。
3. 若 $v$ 小于根节点节点的值，则将 $v$ 插入到该节点的左子树，否则执行步骤 $4$。
4. 把 $v$ 插入到右子树。

代码实现：
```cpp
const int N=500005;
int n,cnl,rt=0,a[N],t[N],chi[N][3];
int b[N];
void insert(int &x,int v){//插入一个值为 v 的节点
	if(x==0){//为空节点，则插入
    	++cnl;//节点个数+1
      	x=cnl;//更新节点标号
        t[x]=v;
       	return ;//返回
    }
    if(v<t[x]) insert(chi[x][1],v);//去左子树
	else insert(chi[x][2],v);
}
```

## 二叉排序树的查找

同上，可以使用二分查找的思想来实现查找操作。具体来说，对于一个节点，如果要查找它的值v，我们可以比较 $v$ 和该节点的值，如果 $v$ 小于该节点的值，则在左子树中查找；如果 $v$ 大于该节点的值，则在右子树中查找。

如果你还是不太会写，我们具体来分一下步骤：

1. 若 $t$ 为空树，直接返回查找失败，否则执行步骤 $2$。
2. 若 $v$ 等于根节点的值，查找成功，返回即可，否则执行步骤 $3$。
3. 若 $v$ 小于根节点的值，则 $v$ 搜索该节点的左子树，否则执行步骤 $4$。
4. $v$ 搜索右子树。

这里就不给出代码实现了，因为本题不会用到。

## 二叉排序树的中序遍历

当所有节点插入完毕，我们就可以对其进行中序遍历，然后输出即可。这里采用递归的方法实现：
```cpp
void zdfs(int u){
	if(!u) return ;
    zdfs(chi[u][1]);
    cout<<t[u]<<' ';
    zdfs(chi[u][2]);
}
```

注意，在排序前要把数组随机打乱，使得复杂度不会退化。

## 代码实现
如果你已经按照我说的打了一遍，就会发现最后两个点 TLE 了，是因为相同的元素也会拉长链，这时，我们引入一个数组记录每个点的元素个数即可（把相同元素放入同一节点，输出时输出 $tcnt_i$ 次）。

最终代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=100005;
int n,cnl,rt=0,a[N],t[N],chi[N][3];
int tcnt[N];
mt19937 Rnd(N);
int b[N];
void insert(int &x,int v){//插入一个值为 v 的节点
	if(x==0){//为空节点，则插入
    	++cnl;//节点个数+1
      	x=cnl;//更新节点标号
        t[x]=v;
        tcnt[x]=1;
       	return ;//返回
    }
    if(v<t[x]) insert(chi[x][1],v);//去左子树
	else if(v>t[x]) insert(chi[x][2],v);
	else if(v==t[x]) tcnt[x]++;
}
void zdfs(int u){
	if(!u) return ;
    zdfs(chi[u][1]);
    for(int i=1;i<=tcnt[u];++i) cout<<t[u]<<' ';
    zdfs(chi[u][2]);
}
int main(){
//	freopen("P1177_4.in","r",stdin);
    cin>>n;
    for(int i=1;i<=n;++i) scanf("%d",&a[i]);
    for(int i=1;i<=n;i++)
        swap(a[i],a[(Rnd()%n)+1]);
    for(int i=1;i<=n;++i) insert(rt,a[i]);
	zdfs(rt);
    return 0;
}
```

## 补充内容

### 其他应用

二叉排序树还有许多应用，如删除操作等等。二叉排序树的复杂度容易退化，但一些方法可以使其平衡，树高保持在 $\log_2 n$，那么其各种操作的复杂度为 $O(\log_2n)$，十分优秀。其平衡方法可以自行查找资料。

### 快速排序

至于 stl 中的其他排序，如快速排序，这里也给出用法。

其“固定搭配”基本为：
```cpp
sort(a+1,a+n+1);//数组名称为 a，下标从 1 到 n，从小到大排序
sort(a,a+n) //数组名称为 a，下标从 0 到 n-1，从小到大排序
sort(a+1,a+n+1,cmp) //数组名称为 a，下标从 1 到 n，排序规则为cmp
```