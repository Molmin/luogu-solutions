#### 题意

将一个数组从小到大排序后输出。

#### 归并排序

归并排序用的是分治的思想。

什么是分治？就是把一个问题拆分成若干个小问题，逐个解决，然后再合并。

投射在数组排序上，就是先把一个数组拆成若干个小部分，然后给每个小部分依次排序后再合并。

说得具体一点：先将一个数组平均分成长度相同的两段，然后把每一段再平均分，分到只剩下一个数。

然后，考虑一下如何合并两个数？当然是小的在前大的在后。

现在你手上有两个长度为 $2$ 且各自分别有序的数组了，如何合并？

举个例子。

| 轮次 | 数组 1 | 数组 2 | 合并结果 |
| :----------: | :----------: | :----------: | :----------:|
| $0$ | $\text{[}$ $1$ $,$ $5$ $\text{]}$ | $\text{[}$ $2$ $,$ $3$ $\text{]}$ | 无 |
| $1$ | $\text{[}$ $\color{Red}{1}$ $,$ $5$ $\text{]}$ | $\text{[}$ $2$ $,$ $3$ $\text{]}$ | $\text{[}1\text{]}$ |
| $2$ | $\text{[}$ $\color{Grey}{1}$ $,$ $5$ $\text{]}$ | $\text{[}$ $\color{Red}{2}$ $,$ $3$ $\text{]}$ | $\text{[}1,2\text{]}$ |
| $3$ | $\text{[}$ $\color{Grey}{1}$ $,$ $5$ $\text{]}$ | $\text{[}$ $\color{Grey}{2}$ $,$ $\color{Red}3$ $\text{]}$ | $\text{[}1,2,3\text{]}$ |
| $4$ | $\text{[}$ $\color{Grey}{1}$ $,$ $\color{Red}5$ $\text{]}$ | $\text{[}$ $\color{Grey}{2}$ $,$ $\color{Grey}3$ $\text{]}$ | $\text{[}1,2,3,5\text{]}$ |

长度更大的情况也是类似的，可以自己试着推一下。

~~大量实验表明~~合并时每次向结果数组里新添加的元素，一定是两个原数组首元素中较小的那一个。

>证明：假设当前最小的元素不是两个原数组的首元素中的任何一个。那么，无论它在哪一个数组里，都比该数组的首元素小，与“原数组各自有序”矛盾。

代码就非常好写了。(读入在 $a$ 数组)

```cpp
void merge(int l,int r)//处理区间[l,r]
{
    //以下是“分”的部分
    if(l==r)return;//只有一个数，不能再分了，直接返回
    int mid=(l+r)/2;
    merge(l,mid);
    merge(mid+1,r);//分成两个区间
    
    //以下是“治”的部分（执行到这一步的两个原数组都是有序的了）
    int i=l,j=mid+1;
    int cur=l-1;
    while(i<=mid&&j<=r)//每次取原数组的剩下元素中的首个进行比较
    {
        if(a[i]<=a[j])
            b[++cur]=a[i++];//结果统计在b数组
        else
        {
            b[++cur]=a[j++];
        }
    }
    while(i<=mid)//处理剩下的元素
        b[++cur]=a[i++];
    while(j<=r)
        b[++cur]=a[j++];
    for(int i=l;i<=r;i++)//把排序后的结果存回a数组
        a[i]=b[i];
}
```

顺便提一句，归并排序还可以处理逆序对问题。不是本题重点，可以移步[【模板】逆序对](https://www.luogu.com.cn/problem/P1908)。