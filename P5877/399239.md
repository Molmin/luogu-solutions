前言无~


------------
我们看题，统计共有多少个连通块，首先想到 $bfs$。

但再看，他要我们求多次，可 $bfs$ 效率太低，

~~说句闲话：记录联通块的最好方法是——~~

并查集。	~~祝你们学会~~ ~~（逃。~~

所以我们要用并查集。

思路：用并查集记录联通块个数，输出。

但并查集是线性的，此题为二维，故要降成一维，

用 $b=x*N+y$ 来表示一个坐标为 $(x,y)$ 点

那么，下面就见代码吧：


```cpp
#include<bits/stdc++.h>//万能头很香 
using namespace std;
int f[501][501];
int N,M;
int ans=0;
int a,b;
int x,y,z;
int bcj[260100];//并查集 线性 指降成一维 
//--------------------------------------------// 并查集求联通编号 ， 
inline int fa(int x){                        //        不是那个“联通 ”别瞎想 。 
	if(bcj[x]!=x)return bcj[x]=fa(bcj[x]);  // 
	else return x;                         // 
}                                         //
//---------------------------------------// 
//----------------------------------------------------------// 
inline void bfs(){                                         // 
	b=y*N+z;                                              // 
	ans++;                                               // 
	if(z+1<=N)if(f[y][z+1]==f[y][z])                    // 向四周 ， 
	{a=fa(y*N+z+1);if(a!=b){bcj[a]=b;ans--;}}          // 看看有没有可以联通的 区域 。 
	                                                  // 
	if(y+1<=N)if(f[y+1][z]==f[y][z])                 // 注：由于蒟蒻太懒，故在本题中 b 没减 N  ， 
	{a=fa(y*N+z+N);if(a!=b){bcj[a]=b;ans--;}}       //      不过数组开大点就好了。 
	                                               // 
	if(z-1>0)if(f[y][z-1]==f[y][z])               // 
	{a=fa(y*N+z-1);if(a!=b){bcj[a]=b;ans--;}}    // 
	                                            // 
	if(y-1>0)if(f[y-1][z]==f[y][z])            // 
	{a=fa(y*N+z-N);if(a!=b){bcj[a]=b;ans--;}} // 
}                                            //
//------------------------------------------// 
int main(){
	scanf("%d%d",&N,&M);

	for(int i=1;i<=260001;i++)//重要：并查集初始化 
	bcj[i]=i;

	for(int i=1;i<=M;i++){//在线算法，省数组 
		scanf("%d%d%d",&x,&y,&z);
		f[y][z]=x+1;
		bfs();
		printf("%d\n",ans);
	}
}
```



这篇题解就到这里了，

我还没写过几次，有不到之处请多多指教


