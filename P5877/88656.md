## Part 1. 题意

现有大小为 $n \times n$ 的棋盘，一共加入 $m$ 个棋子，有不同的颜色（黑白两种）。每次加入后统计连通块数目。

## Part 2. 分析

维护连通块，我们会想到什么？ bfs? dfs? 不过用在这题会慢了点。因为我们有多个修改-查询。

如果想想并查集呢？并查集也可以维护连通性呀~

这是个二维的题目，而我们常见的并查集中，$father$ 是个一维数组。如果我们把二维的棋盘编个号，不就可以转化为一维的情况了吗。

我们可以分析一下下面这个表

| **1** | **2** | **3** | **4** | **5** |
| :----------: | :----------: | :----------: | :----------: | :----------: |
| **6** | **7** | **8** | **9** | **10** |
| **11** | **12** | **13** | **14** | **15** |
| **16** | **17** | **18** | **19** | **20** |
| **21** | **22** | **23** | **24** | **25** |

我们可以得到如下规律，如果现在放下一枚棋子在第 $x$ 行第 $y$ 列的话，那这枚棋子的编号就是 $(n-1) \times x + y$ 了。

然后另外一个重点是如何计算连通块数目了。

当然，我们假设加入一个棋子之后肯定增加了连通块数量。

但是减少的情况咋确定呢？

为了分析得更好，我们找点~~恶心~~有代表性的例子吧。

![](https://cdn.luogu.com.cn/upload/image_hosting/v4f9hw0q.png)

变化前有 $4$ 个连通块，变化后只有 $1$ 个连通块。

我们会开始想，只要每次试着检查上下左右有没有棋子（当然颜色也需要考虑，这里讨论的是相同的情况，因为不相同的分开考虑就行），有的话，连通块数量就减 $1$ 了。

![](https://cdn.luogu.com.cn/upload/image_hosting/j1tanqoq.png)

这种呢？变化前有 $3$ 个连通块，变化后也同样只有 $1$ 个

其实很相似的。但是没减得那么多啊。这时要发挥并查集的作用了。我们一边检查，一边合并，就可以把状况排除掉。

所以说，算法的流程是这样的：

1. 把棋子所在的位置记录为已有棋子。

2. 对应连通块数量加一。

3. 检查上下左右棋子出现状态，有出现的话合并，并且连通块要减一（注意边界！）。

4. 输出连通块数量（黑色的数量加白色的数量就是答案）。

## Part 3. 代码

```cpp
#include <iostream>
#include <cstdio>
using namespace std;
int n,m,c,x,y,visited[2][501][501],fa[2][501*501],ans[2];

//visited(c,x,y)代表颜色c在棋盘第x行第y列中有没有出现过
//fa(c,k) 代表颜色与一维坐标
//ans(x) 代表颜色x连通块数量

int find(int type,int a)
{
	if (fa[type][a]!=a) return fa[type][a]=find(type,fa[type][a]);
	return fa[type][a];
}
void merge(int type,int x,int y)
{
	if (find(type,x)==find(type,y)) return;
	fa[type][find(type,x)]=find(type,y);
	ans[type]--; //连通块减一
}
int main(void)
{
	scanf("%d%d",&n,&m);
	for (int i=1;i<=n*n;i++)
	{
		fa[0][i]=i;fa[1][i]=i;
	}
	/*
		初始化并查集
	*/
	for (int i=1;i<=m;i++)
	{
		scanf("%d%d%d",&c,&x,&y);
        
		//1. 把棋子所在的位置记录为已有棋子。
        
		visited[c][x][y]=1;
        
		//2. 对应连通块数量加一。
        
		ans[c]++;
        
		//3. 检查上下左右棋子出现状态，有出现的话合并（注意边界！）。
        
		//left
		if (y>1&&visited[c][x][y-1]) merge(c,(x-1)*n+y,(x-1)*n+y-1);
		//right
		if (y<n&&visited[c][x][y+1]) merge(c,(x-1)*n+y,(x-1)*n+y+1);
		//up
		if (x>1&&visited[c][x-1][y]) merge(c,(x-1)*n+y,(x-2)*n+y);
		//down
		if (x<n&&visited[c][x+1][y]) merge(c,(x-1)*n+y,x*n+y);
        
		//4. 输出连通块数量（黑色的数量加白色的数量就是答案）。
        
		printf("%d\n",ans[0]+ans[1]); //黑色跟白色
	}
	
	
}
```


