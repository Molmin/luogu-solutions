又一道被恶意评分的题……

洛谷的题意翻译感觉不是很清晰，这里提供一个~~自认为~~比较清晰的[翻译](https://www.luogu.org/paste/e9h6np1v )供参考。

这里带来一个~~很假的~~数学方法。~~这题明明可以快乐地模拟为何要必要如此！~~

根据题意，对于两只蟾蜍，对应的车站编号每次分别加$1$或减$1$，分别只有在第$1$站和第$n$站时才会对应地变为第$n$站和第$1$站。如果我们把从第$1$站到第$n$站或从第$n$站到第$1$站这种编号不是相邻的编号变换称为编号跃迁，则两只蟾蜍显然分别只会进行最少$0$次，最多$1$次的编号跃迁。因此，我们只要分别尝试四种情况，即丹尼尔和弗拉德分别进和不进行编号跃迁组成的四种情况。

如何尝试？显然，当进行编号跃迁时，相当于编号加上$n$或减去$n$。在尝试的同时，还要保证$x$值和$y$值分别与改变后的$a$值和$b$值相差不超过$n$且$x$和$y$分别要在$a$和$b$的行进方向上，这样既方便计算又保证了正确性。这个思想与许多环形问题的断环成链的思想类似。

显然，当两只蟾蜍不进行编号跃迁且相对行进时，它们相遇的车站即为$(a+b)/2$。显然，只有当$a+b$为偶数时，两只蟾蜍才能在不进行编号跃迁的条件下相遇。并且，相遇的地点还要保证分别不超过$i,j$。于是就有了以下的判定条件：（$u,v,i,j$分别表示当前情况下的$a,b,x,y$）

- $u<=v$
- $(v-u)$%$2=0$
- $j<=(u+v)/2<=i$

实现起来自然就很简单了！

代码：
```cpp
#include<iostream>
#include<cstdlib>
using namespace std;
int n,a,x,b,y;
void pf(string s)
{
	cout<<s;
	exit(0);//直接结束程序
}//输出
bool check(int u,int v,int i,int j)
{
	i=i<u?i+n:i-u>=n?i-n:i,j=j>v?j-n:v-j>=n?j+n:j;//保证i,j的范围
	return u<=v && (v-u)%2==0 && (u+v)/2<=i && (u+v)/2>=j;//判定是否可行
}   
int main() 
{
	cin>>n>>a>>x>>b>>y;
	if(check(a,b,x,y) || check(a-n,b,x,y) || check(a,b+n,x,y) || check(a-n,b+n,x,y))//分别尝试四种情况
		pf("YES");
	pf("NO");//都不行则说明不可行
}
```
