嗯……今天我们就来讲一下这一题……

首先，看题目，题目的大意是有一个长度为n的数列，数列的第i项为a[i]，在第j天你可以卖掉目前剩下的数列的最左边或者最右边，这时你的money就会加上你卖掉的数×j的积，每一天只能卖一个，求最大的总钱数……

那么，设f[i][j]表示从i买到j的最优价格~~（欲购从速！）~~，那么
……明显这是个区间ＤＰ对吧？

区间ＤＰ的思想就是：设f[i][j]表示从i到j的最优值，然后由一个小的区间枚举到一个大的区间，这样一步一步的选，最终求出f[1][n]的值。

这道题直接打动归很麻烦，所以我们可以考虑一下记忆化……？

记忆化相信大家都听说过，就是“搜索的模样，动归的心”，最大的优点就是能避免重复计算，使得效率大大加快。

首先从1,n,d开始递归，这里设放进递归的第一个数为l（数列的最左边），第二个数是r（数列的最右边），第三个数是d（当前第几天），然后……看代码去！
```
#include<cstdio>
int n;
int a[2001],f[2001][2001];
int dfs(int l,int r,int d)
{
	if(r<l)return 0;
	if(l==r)return a[l]*d;
	if(f[l][r])return f[l][r];
	f[l][r]=f[l][r]>dfs(l+1,r,d+1)+a[l]*d?f[l][r]:dfs(l+1,r,d+1)+a[l]*d;
	f[l][r]=f[l][r]>dfs(l,r-1,d+1)+a[r]*d?f[l][r]:dfs(l,r-1,d+1)+a[r]*d;
	return f[l][r];
}
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)scanf("%d",&a[i]);
	printf("%d",dfs(1,n,1));
}
```