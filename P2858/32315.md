这题说简单也不简单，说难也不难~

这题就是一个普通的区间DP，非常适合区间DP入门的同学。我们设dp[i][j]表示售出第i份零食到第j份零食所能获得的最大价值。

于是状态转移方程就很好推了：dp[i][j]=max(dp[i+1][j]+a[i]*t,dp[i][j-1]+a[j]*t)(这里的a[i]就是第i份零食的初始售价，t就是这份零食是第几天售出的)

接下来就是这题的唯一的难点了：当前这份零食是在第几天被售出的呢？（t=?）

这个问题在初次做这题时的确很难，但当你把dp[i][j]和题目连起来一想，它就迎刃而解了——一共有n份零食，要把它们在n天内售出，而dp[i][j]的跨度l刚好就是售出了l份零食，所以就可以得到t=n-l+1

有了这一点，剩下的就只剩板子了

参考代码:
```
#include <bits/stdc++.h>
using namespace std;
int n,a[2004],dp[2004][2004];
int main()
{
	cin>>n;
	for (int i=1;i<=n;i++)
	{
		cin>>a[i];
		dp[i][i]=a[i]*n;
		//初始化：第i份零食能获得的最大价值就是把它留到第n天卖 
	}
	for (int l=2;l<=n;l++)//枚举区间跨度 
		for (int i=1;i+l-1<=n;i++)//起点 
		{
			int j=i+l-1;//终点 
			dp[i][j]=max(dp[i+1][j]+a[i]*(n-l+1),dp[i][j-1]+a[j]*(n-l+1));
		}
	cout<<dp[1][n];//输出1~n 
	return 0;
}
```
做完这题，有余力的同学可以去做一下[P1005 矩阵取数游戏](https://www.luogu.org/problem/P1005)，和这题基本没什么区别