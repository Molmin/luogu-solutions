这一题算是一个背包问题

大概的思路是，乍看一眼题目里有钢轨数目n，长度l，和花费b三种维度的变量，作为背包，我们肯定是要从中选取几个作为设计的状态。那么，我们发现三个都选肯定是不现实的，发现题目的问题是修建长度为l的铁路，并且还给出了每根钢轨的起点和长度，那么长度l（或者位置）就必须作为状态里的维度之一。又因为花费b必须作为维度之一，相比之下，铁轨数目n如果作为一个状态维度的话就既不好转移也没有实际意义。因此，我们可以设出一个这样的dp数组：dp[i][j]表示在正好花费为i的情况下修建从0-j的铁路的最大有趣值。

很容易得出转移方程，dp[i][j]=max(dp[i][j],a[k].f+dp[i-a[k].c][j-a[k].w])

上面式子里的k表示，因为我们目前的铁路是修到j位置的所以自然目前用的这块铁轨就要在j结束。于是我们就枚举铁轨编号k，如果枚举到的铁轨正好在k结束那么就可以进行转移了。

这里还要注意一点：k的范围如果是从1-n，那么时间复杂度会超时。于是做这样的优化：先按照每条铁轨的终点进行排序每次需要转移的时候从连续的重点正好是j的铁轨里取用即可。这部分的细节具体实现在代码里，给了注释。

另外还要注意一点：就是某些状态是不合法的，不可以由他们转移而来（就是这里如果不注意到只有30分）。首先每一种状态对应的的铁轨修建方式必须从0开始（这句话有些绕）

大概是什么意思呢，就是比如这种修建方式就是不合法的：

（1，2）-（2，3）-（3，4）

而这种修建方式是合法的

（0，1）-（1，2）-（2，3）-（3，4）

于是我们可以把那些不合法的状态用-1来表示，初始值是dp[0][0]=0，其他的都是-1。每次只能从初始值不是-1的地方转移。

代码：
```
#include<bits/stdc++.h>
using namespace std;
int n,dp[2001][2001]={-1},ans=-1,l,b,s[10001]={0},cnt=0;
struct cow{
	int x,w,f,c,e;
}a[200001];
bool cmp(cow a,cow b){
	return a.e<b.e;
}
int main(){
	for(int i=0;i<=2000;i++)for(int j=0;j<=2000;j++)dp[i][j]=-1;
	cin>>l>>n>>b;
	for(int i=1;i<=n;i++){
		cin>>a[i].x>>a[i].w>>a[i].f>>a[i].c;
		a[i].e=a[i].x+a[i].w;
	}
	sort(a+1,a+n+1,cmp);
	dp[0][0]=0;
	for(int i=1;i<=n;i++)s[a[i].e]=i;//用s数组记录s[i]表示排序后的a数组中最后一个终点为a[i].e的铁轨编号是多少，因为排序了，所以保证终点为一个定值的铁轨一定是连续的
	for(int i=1;i<=b;i++){
		for(int j=1;j<=l;j++){
			for(int k=s[j];k>=1;k--){
				if(a[k].e!=a[s[j]].e)break;
				if(i>=a[k].c&&j-a[k].w==a[k].x&&dp[i-a[k].c][j-a[k].w]!=-1){dp[i][j]=max(dp[i][j],a[k].f+dp[i-a[k].c][j-a[k].w]);}
			}
		}
	}
	for(int i=1;i<=b;i++)ans=max(ans,dp[i][l]);
	cout<<ans<<endl;
	return 0;
}

```
