设 $n, q$ 同阶。

**做法一**：

出现次数，考虑根号分治。

对于出现次数大于 $B$ 的值，不超过 $\frac n B$ 个，可以直接暴力，这部分复杂度 $\mathcal{O}(\frac {n ^ 2} B)$。

对于出现次数小于 $B$ 的值，我们可以将整棵树的 dfs 序划分为 $\mathcal{O}(occ)$ 段，使得每一段所有点的子树内该值的出现次数相同，共有 $\mathcal{O}(occ ^ 2)$ 种组合方案。每种组合方案相当于往矩形内加入一个值，询问相当于单点查最优值。这个问题在一般限制下只能做到 $\log ^ 2$，所以这部分复杂度 $\mathcal{O}(nB\log ^ 2 n)$。

取 $B = \frac {\sqrt n} {\log n}$，得到最优复杂度 $\mathcal{O}(n\sqrt n \log n)$。但是空间复杂度为 $n\sqrt n$，看上去不太好。注意到第二部分查询单点的复杂度仅为 $\log n$，查询总复杂度 $n\log n$，从这点下手，我们每次只处理一些出现次数小于 $B$ 的值，使得它们的 $\mathcal{occ}$ 之和不超过 $K$，这样产生了 $\frac n K$ 轮查询，但空间降为 $KB\log n$。令 $K = \sqrt n$，得到空间复杂度 $\mathcal{O}(n)$，时间复杂度不变。

没写，看起来太难写了，也不知道能不能通过。

**做法二**：

考虑只有一个点 $u$，dfs 拍平后相当于区间查询出现次数最大的数的最小值。区间众数是经典不可 $\mathrm{polylog}$ 问题，考虑莫队。对于众数最小值，则需要对记录每个值出现次数的序列分块，以避免移动指针时产生 $\log$。这样单次查询复杂度为 $\mathcal{O}(\sqrt n)$。

两个点类似，四维莫队，时间复杂度 $\mathcal{O}(n ^ {7 / 4})$。

没写，太无脑了。

**做法三**：

做法二只是将树拍平到了序列上，但 **子树在 dfs 序上形成的区间 $[l_u, r_u]$ 存在比序列上的随机区间更好的性质**。或者说，把树拍平会损失一些性质。

考虑 dsu on tree 的过程，**轻子树暴力遍历，重子树直接继承**。重子树回到它的父亲的时候，需要重新添加轻子树的信息。离开轻子树时，需要清空轻子树内所有节点产生的影响。根据轻子树大小之和为 $\mathcal{O}(n\log n)$ 的性质，dsu on tree 的复杂度为 $\mathcal{O}(n\log n)$。

借鉴思想，我们优先访问轻儿子，再访问重儿子，然后将根加入遍历序列。在遍历序列中移动时，如果当前点 $u$ 和目标 $v$ 之间有祖先后代关系，那么相当于将 $l_u$ 移动至 $l_v$，$r_u$ 移动至 $r_v$。否则直接删去 $l_u\sim r_u$，加入 $l_v\sim r_v$。可以证明从序列头移动至序列尾的代价为 $\mathcal{O}(n\log n)$，那么带权莫队即可，相当于在一个长为 $n\log n$ 的序列上进行 $q$ 次 “区间” 询问。时间复杂度 $\mathcal{O}(n\sqrt n\log n)$。

因为常数较小，所以跑得很快。[代码](https://codeforces.com/contest/1767/submission/185581746)。