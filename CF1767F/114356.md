CF1767F Two Subtrees 题解。

首先得构造一个数据结构支持插入、删除、查询众数。这个之后再说。

把树拍扁到 dfs 序上，设为 $w$。然后就变成了序列上两个区间的众数查询问题。

直接四维莫队可以做到 $O(n^{7\over 4})$。

但这样完全没有利用树的性质。我们希望树的性质能够带来更优的时间复杂度。

不妨先考虑一维的情况。此时从序列前端移动到后端的花费为 $\sum Q(w_i,w_{i+1})$。而 $Q(x,y)=|in_x-in_y|+|out_x-out_y|$。

任意序列的花费显然不可接受。但如果将每个点的重儿子都作为第一个儿子，可以证明其花费为 $O(n\log n)$ 级别。证明见最后。

这样，就可以设 $\displaystyle s_i=\sum_{j=1}^{i-1}Q(w_j,w_{j+1})$，$s$ 为 $O(n\log n)$ 级别。一个询问 $(w_x,w_y)$ 在该序列上移动到 $(w_a,w_b)$ 的代价即为 $|s_{w_x}-s_{w_a}|+|s_{w_y}-s_{w_b}|$。

此时再上莫队即可。算出来块长取 $\sqrt n\log n$ 最优。此时共 $O(n\log n\sqrt n)$ 次查询，$O(n)$ 次修改。

最后设计一下开头提到的数据结构。根据上述分析，采用 $O(1)$ 修改 $O(\sqrt n)$ 查询的值域分块（对值域开桶，然后对桶做值域分块）。

总时间复杂度 $O(n\log n\sqrt n)$。

算出来其实和 $O(n^{7\over 4})$ 差不多。或许好写一些。

---

最后证明上面提到的结论。

当从 $c_i$ 向 $c_{i+1}$ 移动时，如果加入一个新点 $p$，说明 $c_i$ 不为 $c_{i+1}$ 祖先。那么 $c_{i+1}$ 不为重儿子，因为重儿子的前一个总是其父亲。所以 $c_{i+1}$ 父亲的子树大小至少为其轻儿子 $c_{i+1}$ 的两倍。对于 $p$ 来说，$c_{i+1}$ 这样的祖先最多存在 $\log n$ 个。所以得证。