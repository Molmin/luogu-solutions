**题目描述**

有 $n$ 天，每天老板给工人 $x$ 枚代币，每个工人都可以退还 $w$ 枚代币以获得一定数量的美元（ 为 $\left\lfloor\dfrac{w\times a}{b}\right\rfloor$ ）。要帮 $Mashmokh$ 计算每一天他在获得最多钱时可以保存的代币数量。

**题目思路**

要获得更多钱，必须要退还更多代币。

如果要尽可能多的省下代币，只要上交刚好能获得最多的美元数量的代币就行了。

不难发现公式是 $\left\lfloor\dfrac{w\times a\bmod b}{b}\right\rfloor$。

举个栗子

样例一中， $a$ 为 $1$ ， $b$为 $4$ 。

第一天获得 $12$ 枚代币。

| $退还的代币$ | $得到的美元$ | $剩下的代币$ |
| -----------: | -----------: | -----------: |
| $1$ | $0$ | $11$ |
| $2$ | $0$ | $10$ |
| $3$ | $0$ | $9$ |
| $4$ | $1$ | $8$ |
| $5$ | $1$ | $7$ |
| $6$ | $1$ | $6$ |
| $7$ | $1$ | $5$ |
| $8$ | $2$ | $4$ |
| $9$ | $2$ | $3$ |
| $10$ | $2$ | $2$ |
| $11$ | $2$ | $1$ |
| $12$ | $3$ | $0$ |


可以发现退还 $12$ 枚代币获得 $3$ 美元是最多的。剩下的几天读者可以自己推一下。

知道了公式，问题就迎刃而解了。

**Code**

```cpp
#include <bits/stdc++.h>
using namespace std;
int main(){
	long long a,b,n;
	cin.tie(NULL);
    cin >> n >> a >> b;
    while(n--){
    	long long x;
        cin >> x;
        cout << (x*a%b)/a << " ";
    }
    return 0;
}
```




