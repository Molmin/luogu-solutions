
**前言：**

1.我的方法是我在出好这道题之前想出的，当时先想的对线性序列的操作，出这道题时改为树上操作，而且为了增加难度，每个节点上元素数量可能不相同，于是需要对树链剖分进行较大的变形。

2.很幸运，这道题方法不唯一，它可以用我不会的数据结构做，但具体怎么做我就不知道了。（可以请教AC的大佬）。

---

考察知识：树链剖分，线段树，链表，排序，二分，字符串处理

算法难度：XXXXX 实现难度：XXXXX

---

分析：算法较复杂，代码量大（板子太多）！这是一道典型的考场上正解不如写暴力的题！

先介绍**暴力算法**（55分）：

如果你的程序超时，你可以先尝试这道题：[PION后缀自动机（数据弱化版）](https://www.luogu.org/problemnew/show/U41487)

算法难度：XXX 实现难度：XXX+

显然储存文件后缀信息不能用数组，空间开不下，所以我们用链表储存所有文件夹中文件的后缀信息；

然后是后缀的处理，注意到字符串长度小于6，如果我们用 1 表示 a ，2 表示 b ，... ... ，26 表示 z，这就相当于将字符串看做一个27进制数，这样我们就可以在 int 范围内用数字表示字符串了

解决了上面两个问题之后，我们就可以建树然后对每个操作用暴力的 “逐步爬山法” （即按路径一个节点一个节点的统计）解决了，实现难度不大

其实这种方法对随机数据效果还是比较好的（甚至比下面的满分算法还略快一点），但是你觉得数据可能完全随机么？

时间复杂度：极端情况约$O(mn)$

**满分算法：**

代码量比较大。

看到这道题我们应该可以想到用树链剖分来做。

我们先考虑怎么对序列进行统计和修改，对于操作2，我们需要找到一个序列中的子序列。我们可以用一个结构体来储存，结构体储存序列中每个元素的值（字符串的hash值）和序列中每个元素在序列中的位置。然后将这个结构体序列按元素值的排序（元素值相同的按在序列中的位置排序）。当我们需要查找一个序列相同数值所在的区间的时候用 lower_bound 和 upper_bound 就可以完成，对于查找出来的目标区间，还需要用二分法来查找该区间中元素的下标在目标子序列中的数量。

至于修改，用线段树的区间维护实现。

解决了对序列的修改，我们还要解决树中每个节点含有的文件数目不相同的问题，如果一个节点没有文件，那么一个简单的方法是新建一个伪文件，可以将hash值赋为 -1。

之后就是树链剖分了，不同于树链剖分模板，我们还要新建一个辅助数组 low[i] ，表示节点 i 的重子孙可以到达的最深节子节点的编号，我们先对$[\,top[i],low[i]\,]$排序，之后查询的时候我们按树链剖分树上路径查询的方法查询$[\,top[i],low[i]\,]$之间的序列即可。

这道题在树上将路径拆开查询的思想类似于分块。

其实吧，上面只是代码实现的一部分，具体细节远不止这些，更多的细节请参考代码。

时间复杂度：极端情况约$O((n+m)log^2n)$

---

代码请参考：[【洛谷】NOIP2018原创模拟赛DAY2题解T3](https://blog.csdn.net/hi_ker/article/details/82820861#t3)