~~这大概这题中文的第一篇题解~~

标签：期望，$\rm dp$。（做的人太少cf上都没标签）

题目大意：

有 $n$ 个球，包含黑球和红球，给出 $p_i (0 \leq i \leq n)$ 表示初始有 $i$ 个红球的概率 和 $c$ 取出一个球的花费。若取出红球可以获得 $1$ 的收益，那么最优策略下期望可以得到多少的收益。（$n \leq 10000$）。

---

在cf中，常数偏小的 $O(n^2)$ 的算法可以在 $\rm 250ms$ 不到跑完，更何况题目中开了 $\rm 2s$。

所以我们直接设 $dp_{i,j}$ 表示总共取了 $i$ 个球，已经取了 $j$ 个红球时以后的最大收益，那么答案为 $dp_{0,0}$ 且第一维可以滚存。

在这个局面下我们考虑策略（取或者不取），有如下的转移：

$$dp_{i,j}=\max(0,P_{i,j}\times(dp_{i+1,j+1}+1)+(1-P_{i,j})\times dp_{i+1,j} - c)$$

其中 $P_{i,j}$ 为在共取了 $i$ 个球，已经取了 $j$ 个红球时下一个球是红球的概率。



$$P_{i,j}=\sum_{k\leq j}^{n-i+j} \dfrac{P(\text{总共有 k 个红球 | 取 i 个球中有 j 个红球 })\times (k-j) }{n-i}$$

这个式子比较好懂，可以自行理解。其中 $P(A|B)$ 表示在发生 $B$ 的条件下 $A$ 发生的概率，那么根据贝叶斯公式有

$$P(A|B)=P(A) \frac{P(B|A)}{P(B)}$$


把分子上的 $P$ 展开就可以搞到一个 $O(n^3)$ 的算法了。

我们要获得更好的时间复杂度必须优化计算 $P_{i,j}$ 的过程。

这个 $\Sigma$ 看起来很坏，我们把它搞掉（本质上就是减少重复计算）。

我们发现，当 $i=n-1$ 时候 $k$ 只有 $j+1$ 和 $j$ 两种取法。

那么 $P_{n-1,j}=P(\text{总共有 j+1 个红球 | 取 n-1 个球中有 j 个红球})$

$=P(\text{总共有 j+1 个红球}) \dfrac{P(\text{取 n-1 个球中有 j 个红球 | 总共有 j+1 个红球})}{P(\text{取 n-1 个球中有 j 个红球})}$


$=\dfrac{P(\text{总共有 j+1 个红球})}{P(\text{取 n-1 个球中有 j 个红球})} \times \dfrac{j+1}{n}$

那如果 $i \not = n-1$  又如何？

根据上面所推可以得知 $P_{i,j}=\dfrac{P(\text{ i+1 个球中有 j+1 个红球})}{P(\text{ i 个球中有 j 个红球})} \times \dfrac{j+1}{i+1}$

这里应该已经可以看出做法了，设一个 $q_{i,j}$ 表示在 $i$ 个球中有 $j $ 个红球的概率，其中 $q_{n,i}=p_i$ 。

那么这个 $q_{i,j}$ 的转移就是 

$$q_{i,j}=\frac{j+1}{i+1}q_{i+1,j+1}+\frac{i+1-j}{i+1}q_{i+1,j}$$

最后滚掉 $q,dp$ 的第一位就好了。

---

核心代码：

```cpp
#define u (i&1)
scanf("%d%lf",&n,&c);c/=1e6;
for(int i=0;i<=n;i++)scanf("%lf",&q[n%2][i]),q[n%2][i]/=1e6;
for(int i=n-1;i>=0;i--)
for(int j=0;j<=i;j++){D p;
	//i总取了多少,j表示取了多少红球 
	q[u][j]=1.0*(j+1  )/(i+1)*q[u^1][j+1]+
			1.0*(i+1-j)/(i+1)*q[u^1][j  ];
	if(q[u][j]<1e-18) continue;//防止div0 
	p=q[u^1][j+1]*(j+1)/q[u][j]/(i+1);
	dp[u][j]=max(0.0,dp[u^1][j]*(1-p)+(dp[u^1][j+1]+1)*p-c);
}
printf("%.10f",dp[0][0]);

```




