一看数据范围$m,n≤10^9$，就知道不能用$O(n)$或$O(m)$做

所以顶多只能用$O(\sqrt{m})$或$O(\sqrt{n})$的算法



------------

# 简要分析

给定$n$和$m$，求末项不大于$n$的非负等差数列，使其公差为$1$，和为$m$。

小学知识，易知$m=$首项末项之和$\times$项数$\div$2

所以先把$m$乘上$2$

于是可以知道首项末项之和与项数之积为$m$。

设首项末项之和为$sum$，项数为$t$

从公差为$1$可知$sum>t$

不妨依次枚举$t$

由于要从小到大输出，所以$t$要从大到小枚举

当$t\mid m$时，就能知道$sum$了

且首项末项之差就是$t-1$

则由基本的和差问题可知，首项为$\frac{sum+t-1}{2}$，末项为$\frac{sum-t+1}{2}$

证毕，上14行简洁代码：

```cpp
#include<bits/stdc++.h>
int n,m,sum;
int main()
{
	scanf("%d%d",&n,&m);
	m*=2;//提前乘2 
	for(int i=sqrt(m);i;--i)
	{
		if(m%i)continue;//判断是否整除 
		sum=m/i;//首项末项之和 
		if((sum-i+1)&1||(sum+i-1)/2>n)continue; //判断答案是否合规范 
		printf("[%d,%d]\n",(sum-i+1)/2,(sum+i-1)/2);//输出答案 
	}
	return 0;//华丽结束 
}
```
~~写完了，我溜了~~
