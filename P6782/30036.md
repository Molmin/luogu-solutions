
直观的想法根据不同的 $\deg$ 执行不同的算法，小 $\deg$ 的部分等价于二维数点问题，通过分块来均摊复杂度可以做到 $\mathcal O(q\deg+n\sqrt{n})$，但是大 $\deg$ 的部分不好做了。

考虑暴力一点，对于具体的一个大 $\deg$，考虑对整个序列进行染色，又可以等价于统计 $l\sim r$ 编号内的颜色平方和，假定此处的查询有 $t$ 次，则单独的处理可以通过莫队解决，复杂度为 $\mathcal O(n\sqrt{t})$

设每个点处的查询次数为 $q_i$，其 $\deg$ 为 $c_i$，则处理一个点的复杂度为 $\min(n\sqrt{q_i},q_ic_i)$

事实上，处理编号的部分的复杂度不应当为 $n\sqrt{q_i}$ 而应为 $\textrm{size}_i\sqrt{q_i}$

于是复杂度为 $\mathcal O(\sum \min\{\textrm{size}_i\sqrt{q_i},q_ic_i\})$

对每个点判断那个算法更优以执行做法即可得到一个感性上分析出来大概是 $\mathcal O(n^{\frac{8}{5}})$ 的算法（实际上是因为可以构造出这个级别的反例）

接下来考虑将每个点的重儿子拿掉（即单独做 RMQ），然后执行此算法，复杂度会降低，构造了一段时间，感觉只能卡到 $\mathcal O(n^{1.5})$

接下来的部分是卡空间。

由于扫描线的部分需要离线，这意味着空间存储暴力做是 $\mathcal O(q\cdot \deg)$ 的。

由于查询次数过多所以空间处理很麻烦。

考虑对 $\rm dfn$ 序做扫描线，查询存储在父亲节点上，每次枚举扫到 $i$ 的时候枚举其父亲并处理其父亲的查询即可。

注意到儿子的 $\rm dfn$ 序是连续的，这意味着本次查询需要差分减去的值就是之前计算的值，所以对每种查询记录一个 $\rm bef$ 就真的做完了。

代码还挺好写的。（好像没卡常就过了？）