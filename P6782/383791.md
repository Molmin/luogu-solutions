为什么别人的最优解放我这里卡了好几页？

**Solution:**

最开始通过计算可以得出答案的形式：令 $siz_x$ 表示以 $x$ 为根的子树中在 $[l,r]$ 里的节点个数，$son_x$ 表示与 $x$ 距离为 $1$ 且在其子树内的子节点集合，则答案为 $siz_x^2-\sum\limits_{u\in son_x}siz_u^2$，第一项很好搞（~~二维分块~~），拆成差分形式离线下来就行（但是有平方，所以第一次询问得保存答案）。

对于第二项，没办法直接求，需要枚举每个 $u$，所以考虑根号分治，令 $T$ 为阈值：

- 小于 $T$：

枚举 $u$ 就行，但是得 $O(1)$ 查，还是考虑拆成差分形式离线下来，然后扫一遍 $dfn$ 序，用 $O(\sqrt n)-O(1)$ 的分块，这样就 $O(1)$ 查。注意，还是有平方，所以得记录第一次询问的答案。

- 大于等于 $T$：

这样的节点一共不过 $\frac{n}{T}$ 个，所以离线到节点上处理：考虑对每个子树的节点在原序列上染色，把有颜色的子序列提出来（不然就像我一样爆炸），然后跑个维护平方和的莫队，类似于[小 B 的询问](https://www.luogu.com.cn/problem/P2709)。但是在极端情况下（lxl 肯定会造这种），那 $\frac{n}{T}$ 个节点的子树节点数量和是 $O(n\sqrt n)$，再合理分配一下每个节点的询问数（卡满复杂度的那种），然后复杂度就是 $O(n^{\frac{7}{4}})$，~~裂开~~。

由于每个询问都以差分形式离线 $T$ 个子节点总复杂度不变，所以考虑把最大的几个子树离线下来，即离线 $T$ 个重儿子，这样下来复杂度最大的情况就是 $T$ 叉树，这样显然不会爆，于是这题就**快**结束了。

**卡空间：**

一共有 $O(n\sqrt n)$ 个离线询问，显然 $128MB$ 无法接受，所以只有写线性空间，考虑到每个询问拆下来的节点的的父亲是 $x$，所以可以考虑 $dfn$ 序的一个性质：那些节点对应的区间**相邻且不相交**，直接滚动就行。

**注意**：`vector.clear()` 并**不能**释放空间，要接上 `vector.shrink_to_fit()` 才行。

由于代码太烂就不放了 qwq。