upd: 修陈年破题解

明显的 `dp`。

记 $f_{i,j}$ 表示摆完前 $i$ 种花，目前已经有了 $j$ 盆花的方案数。

可以考虑先枚举当前摆第 $i$ 种花，然后再枚举摆完第 $i$ 种花之后，目前已经有了 $j$ 盆花。

不难发现，这种情况下，第 $i$ 种花有可能摆了 $0, 1, 2, \ldots, \min(a_i, j)$ 盆。

那么就可以得到：

$f_{i,j}=(f_{i-1,j}+f_{i-1,j-1}+...+f_{i-1,j-\min(a_i, j)}) \pmod {10^6+7}$

边界条件：$f_{0,0}=1$。

然后不难发现的是，我们计算第 $i$ 层的 `dp` 值是只需要第 $i-1$ 层的答案的。可以只存当前层和上一层的 `dp` 值。

如果枚举 $j$ 是从大到小枚举，那么我们可以发现，此时的 $j$ 只需要比它小的那些位置的 `dp` 值，那么在我们更新 $f_{i,j}$ 的时候，$f_{i,j+1},f_{i,j+2},\ldots,f_{i,m}$ 都是我们已经不需要的信息了。这时候我们发现，我们无论何时需要的信息都只是恰好 $m$ 个。那么我们甚至可以将第一维完全去掉，只需要一维就足够我们计算了。

$\rm Code:$


```cpp
#include <bits/stdc++.h>
using namespace std;
const int mod = 1000007;
int n, m, a[105], dp[105];
int main() {
    scanf("%d%d", &n, &m);
    for(int i = 1; i <= n; i++) scanf("%d", &a[i]);
    dp[0] = 1;  //边界条件
    for(int i = 1; i <= n; i++) //枚举每一种花
        for(int j = m; j >= 1; j--)  //枚举每一个摆花的结束点
            for(int k = 1; k <= a[i] && j - k >= 0; k++)  //枚举摆花的盆数
                dp[j] = (dp[j - k] + dp[j]) % mod;  //求和
    printf("%d\n", dp[m]); //输出
    return 0;
}
```