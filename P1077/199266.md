### 解题思路  
m 和 n 的范围都很小，不用对数字类型做特殊处理。至于如何求解，起码你得先搞懂题意，这个题目有一个对应的模板题目：“求和问题”。把题目翻译过来就是有 n 个数字，每个数字有自己的取值范围，从 0 到 ai , 求取出 n 个数字的和刚好为 m 的组合数。m 和 n 的范围都不大，为什么这个题强调了要对结果取模呢？我们先来分析一下这个问题。
对比一下递推公式的推导过程：  
摆花时摆当前的花时，需要在摆放完上一盆花产生的结果中进行累加
由于传球游戏只能从左右两个相邻位置相加，所以数字的范围不会太大。但是摆花时，如果当前的花有 10 盆，那么当前的花摆放 0、1、2…10 产生的都是不同的结果，都需要考虑，所以可能的情况是非常多的，可能的情况多，那种对应的方案数也会大，取模就变得很必要了。  
根据上述对题目的分析，递推公式也很显然了，假设状态转移都保存在数组 dp[n][m] 中，第一维表示当前对第 i 种花作分析，第二维表示当前摆放的所有的花盆数量和。递推公式如下：  
dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + … dp[i-1][j-ai]   
dp[i][j] 的含义是放第 i 种花时，花盆总数刚好是 j ，第 i 种花最多有 ai 盆，所以 dp[i-1] 中只要花盆数量大于 j - ai 的情况都能凑成 dp[i][j]。 有了递推公式，问题就解决了一半了，参考代码如下：  
```cpp  
#include <bits/stdc++.h>
using namespace std;
int m,n,dp[103][103],a[103],mod = 1000007;

int main()
{
    cin>>n>>m;
    for(int i = 1;i <= n;i++)
        cin>>a[i];
    dp[0][0] = 1;
    for(int i=1;i <= n;i++)
        for(int j = 0;j<= m;j++)
            for(int k=0;k<=min(j,a[i]);k++)//注意这里保证 k <= j 
                dp[i][j] = (dp[i][j]+dp[i-1][j-k])%mod;


    cout<<dp[n][m];
    return 0;
}  
```  
最内层遍历寻找 dp[i - 1] 中能凑出 j 的数量时，除了要确保 k 不能超过 ai ，还要注意 j -k 不能 < 0，这两个条件二合一就成了 k<=min(j,a[i]) ，这也是一个技巧。  
下面来看看能不能压缩一下空间，跟传球游戏一样，每一次计算只跟上一次的结果相关，所以肯定可以压缩成 dp[2][m] ，参考代码如下：  
```cpp  
#include <bits/stdc++.h>
using namespace std;
int m,n,dp[2][103],a[103],mod = 1000007;

int main()
{
    cin>>n>>m;
    for(int i = 1;i <= n;i++)
        cin>>a[i];
    dp[0][0] = 1;
    int t = 0;
    for(int i=1;i <= n;i++){
        t = 1-t;//保证t在0和1之间切换
        for(int j = 0;j<= m;j++){
            dp[t][j] = 0;//这一步一定得有，不然会把之前的数字给加进去
            for(int k=0;k<=min(j,a[i]);k++)//注意这里保证 k <= j 
                dp[t][j] = (dp[t][j]+dp[1-t][j-k])%mod;
        }
    }

    cout<<dp[t][m];
    return 0;
}  
```