#### **本蒟蒻的第二篇题解**

##### 望大哥手下留情，让蒟蒻发一篇题解[磕头]
______________________________________
##### **好的言归正传，本蒟蒻的方法有点玄乎（傻逼）。是一个三维数组！！！**

### f[i][j][k]表示前i朵花，第j种花，有k株。
##### 好的~其实第三维完全可以舍去，但是蒟蒻还是“蒟蒻”的打出了“蒟蒻”的代码

<献上代码>
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,a[101],f[101][101][101],ans=0,x,y,z;
int main(){
	scanf("%d%d",&n,&m);
	for (int i=1;i<=n;i++) scanf("%d",&a[i]);      //读入，没什么好说的！ 
	for (int i=0;i<=n;i++)
	    f[0][i][0]=1;                             //这是一个神奇的预处理，~~表示前0朵花，第i种花种了，0株~~。可以选择自动忽略~ 但是如果没有预处理，后面就全是0，WAWA大哭———— 
	for (int i=1;i<=m;i++)
	    for(int j=1;j<=n;j++)
	        for (int k=0;k<=min(a[j],i);k++){
	        	if (k>1) f[i][j][k]=f[i-1][j][k-1];
	        	    else for (int z=0;z<=min(a[j-1],i-k);z++) f[i][j][k]+=f[i-k][j-1][z],f[i][j][k]%=1000007;
			}//暴力的三重循环，没什么好解释的 
//对了，转移方程是从前k朵花，第j-1种花，种了K朵转移来的（当k>1时）（其实这就是把数据搬运到了后面，可以改为二维的 
//不然就从前一盆花转移过来 
	for (int i=0;i<=min(m,a[n]);i++)
	    ans+=f[m][n][i],ans%=1000007;        //找到最后一朵花种都种掉了时，ans的最大值，不要忘了“0” “0” “0” （种0朵的情况）！！！！ 
    printf("%d",ans);                        //垃圾圾的结束 
//    while(true){scanf("%d%d%d",&x,&y,&z);printf("%d",f[x][y][z]);}
    return 0;
}
```