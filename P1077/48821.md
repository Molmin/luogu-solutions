#  洛咕万岁
额，不扯这些了（大家都应该知道的道理）


------------
这道题看似好难，但是其实~~很简单~~
先把题目中所让你设的变量都设好，该输入的都输入
你会发现这道题好像成功了一半，为什么呢？？？

因为设完后你会发现你不需要再添加任何变量，已经足够了。
可能最难的地方，就在于状态转移方程式了

先从三重循环说起，第一层1——n没问题

第二层0——m也没问题

第三层为什么是a[i]，因为你不知道最后总和是几，我们到底要选这种花多少合适，所以这一层循环意义在于k来枚举选这种花的数量。。。

所以状态转移方程式完成了一半————**f[...][j-k]**

因为想要知道总方案数那么前面的i-1种花是不能落下的

于是方程式前半段也有了——**f[i-1][...]**

于是整个状态转移方程式就有了

**f[i][j]=(f[i][j]+f[i-1][j-k])%mod**//一定要取模


------------

### 那么就。。。完结，撒花！！！

```cpp
#include<bits/stdc++.h>
using namespace std;
const int M = 1100;
const int mod = 1000007;
int n,m,s;
int a[M],f[M][M];
int main()
{
	cin>>n>>m;
	for(int i=1;i<=n;i++)
		cin>>a[i];
	f[0][0]=1;//不要问我为什么，因为我也//不知道//
	for(int i=1;i<=n;i++)
		for(int j=0;j<=m;j++)
			for(int k=0;k<=a[i];k++)
			{
				f[i][j]=(f[i][j]+f[i-1][j-k])%mod;//状态转移方程式
			}
	cout<<f[n][m];
	return 0;
}
```