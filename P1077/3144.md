首先，纠正一下楼下的题解，他们的时间复杂度是O(NM)，并不是O(N^2)，尽管N和M都只有100，但NM和N^2还是有区别的。


那么接下来看一下我的思路，应该是最朴素的思路：

首先，我们用背包的思想去想这道题，这道题的意思就是 把N个物品装进背包容积为M的背包且恰好装满的方案总数（MOD 1000007）。这里每个物品的体积都是1。但是每个物品都有数量限制a[i]，即多重背包。

但是，这道题的好处就在于，数据范围并不大，所以三重循环完全可以水过去。

很容易可以得出以下方程：

f(i,j) = f(i - 1, j) + sum{ f(i - 1, j - k) | 1 <= k <= min{ a[i], j } }

其中f(i - 1, j)表示这种花不选，后面的sum{ f(i - 1, j - k) | 1 <= k <= min{ a[i], j }表示枚举这种花选多少件。

即
f(i,j) = sum{ f(i - 1, j - k) | 0 <= k <= min{ a[i], j } }

优化为一维空间，即

```cpp

    for(i = 1 ... n)
        for(j = m .. 1)
            for(k = 1 ... min{a[i], j})
                f[j] += f[j - k]                //因为f[j]继承了上一阶段的值，所以k从1开始枚举

```

关键代码如下：

```cpp

F[0] = 1LL;
for(i = 1; i <= N; i++)
    for(j = M; j >= 1; j--)
        for(k = 1; k <= A[i] && k <= j; k++)
            (F[j] += F[j - k]) %= Mod;

```

这里的初始化的意思就是，把前0件物品放进背包容积为0的背包，且恰好装满的方案数为1.


[color=white][delete]如果NOIP2015也考这种题就好了[/delete][/color=white]
