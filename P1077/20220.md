这题和多重背包的方案总数非常像，但除了初始化和枚举容量没别的相同点了   0.0

因为第i个有不超过a[i]个，所以f走到j时f[j]取决于前a[i]个和上一轮的f[j]的值；（因为可能出现f到负数的情况，所以初始点设在f[100]）

如样例：

第0轮     0  1  2  3  4

1  0  0  0  0

第1轮    0  1   2  3  4  （倒着循环，避免当前轮次影响）

↑   ↑  ↑   ↑

所以  f[4]=f[1]加3个i过来，即f[4]=f[1]+f[2]+f[3]+f[4];

∴0  1   2   3  4

1   0   0  0  0

第二轮   0  1  2  3  4

↑   ↑  ↑  ↑

∴0  1  2  3  4

1  0  0  1

五轮后    0  1  2  3  4

1  1  1  1   0

  
开始i=2，第二种花

第六轮    0  1  2  3  4            ←其实这里就可以停了；

↑   ↑  ↑

∴0  1  2  3  4

1  1  1  1  2


第七轮   0  1  2  3  4

↑   ↑  ↑

∴0  1  2  3  4

1  1  1  2  2

第八轮  ...



代码如下 ：









    
                    
                
            

    


```cpp
#include<iostream>
using namespace std;
long long n,m,f[202],a[202],i,j,l,he,k;
int main()
{
    cin>>n>>m;
    f[100]=1;
    for(i=1;i<=n;i++)cin>>a[i];
        for(i=1;i<=n;i++)
            for(l=m+100;l>=101;l--)
            {
                he=0;
                for(k=l-a[i];k<=l;k++)
                {
                    he+=f[k]%1000007;
                }
                f[l]=he%1000007;
            }
    cout<<f[m+100];
}

```