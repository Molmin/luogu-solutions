update in 2019.08.26：格式出锅了，改一下

【解题思路】

这一题乍一看有些难度，理解后看一下觉得其实还蛮简单的。

主要思路是：先开一个二维数组$b[][]$，存储放i种j盆花的方案总数。

首先进行初始化，大家想想,无论有多少种花，如果一盆都没有，那是不是只有一种方案总数了（什么也不放）？

所以初始化为$b[i][0]=1(0<=i<=m)$。然后呢，我们进行三重循环。变量i表示有多少种花，j表示有多少盆花，k则是用于计算某种花放多少盆。

从总盆数开始循环到总盆数-最大盆数，如果k小于0（说明最大盆数大于总盆数）就退出循环。我们得到的状态转移方程则是：

$b[i][j]+=b[i-1][k](j>=k>=j-a[i])$

最终的答案就是$b[n][m]$。

当然，随时加上%1000007会更保险。然后就AC啦。



【代码】

```
#include <iostream>
using namespace std;
long long b[101][101],n,m,a[101]; //定义数组
int main()
{
    cin>>n>>m;
    for(int i=1;i<=n;i++)cin>>a[i];
    for(int i=0;i<=m;i++){b[i][0]=1;} //初始化，不管有多少种花，只要是0盆花，就只有1种可能性，啥都不放
    for(int i=1;i<=n;i++)//几种花
    for(int j=1;j<=m;j++)//几盆花
    for(int k=j;k>=j-a[i];k--)//这种花放多少盆？我们用变量k来循环
    {    
	if(k>=0){b[i][j]+=b[i-1][k]%1000007;b[i][j]%=1000007;}//每次    mod以防万一
        else break; //如果超出限制就退出循环
    }
    cout<<b[n][m]<<endl; //输出（因为每次都mod了所以最后不用mod）
}

```