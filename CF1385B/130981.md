## 题意

给定一个长度为 $2n$ 的数组 $a$，求长度为 $n$ 数组 $p$ 满足 $p$ 中的数为 $1$~$n$，且数组 $a$  可以由两个数组 $p$ 组合得到。

这里两个数组组合指的是第二个数组的每个元素按顺序插入第一个数组的任意空中。例如两个 $p=[3,1,2]$ 可以组合成 $[3,1,2,3,1,2], [3,3,1,1,2,2], [3,1,3,1,2,2]$，但不能组合成 $[1,3,2,1,2,3], [3,1,2,3,2,1], [3,3,1,2,2,1]$。

给定 $n$ 和长度为 $2n$ 的数组 $a$，求满足要求的数组 $p$，保证唯一解。

## 分析

数组 $a$ 满足 $1$~$n$ 每个数都有两个。不妨设 $1$~$n$ 每个数在 $a$ 数组中出现靠前的那个是第一个数组 $p$ 的，靠后的是第二个数组 $p$ 的。也就是一个数在 $a$ 数组第一次出现的数，原本是第一个 $p$ 中的。

只看 $1$~$n$ 每个数**第一次出现的位置**，因为第一个 $p$ 数组的顺序在组合之后不变，所以每个数第一次在 $a$ 中出现的顺序就是第一个 $p$ 数组的顺序。

于是只需要用一个数组 ```flag``` 记录每个数是否已经出现过。第一次遍历到一个数（也就是第一次出现），就输出这个数，并标记 ```flag```，之后看到一个数的 ```flag``` 被标记过（也就是第二次出现）跳过就行了。

## 代码

~~都看到这了，代码还不会写吗？~~

```cpp
#include<cstdio>
#include<cstring>
using namespace std;
const int MAXN=55;
bool flag[MAXN];//标记
int read(){
	int num=0,sign=1; char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')sign=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){num=num*10+ch-'0';ch=getchar();}
	return num*sign;
}
int main(){
int T=read();while(T--){
	memset(flag,0,sizeof(flag));//注意清空
	int n=read(),a;
	for(int i=1;i<=2*n;i++){
		a=read();
		if(flag[a]) continue;//第二次，直接跳过
		flag[a]=1;//第一次，标记
		printf("%d ",a);//输出
	}
	printf("\n");//注意换行
}
	return 0;//华丽结束
}
```
看完点赞，不留遗憾~