### 解题思路：

汉诺塔问题的一个拓展问题，将原本全都为 $1$ 的移动权值改成可变的权值，但是思想还是一样的。

原本的汉诺塔问题是通过不断递归缩小问题来求解的。那么同样，考虑将每一个盘子的状态分解成移动上面的若干个盘子和最下面的一个盘子，然后通过在这一步解决上面的若干盘子和最下面的盘子的移动，并将上面若干个盘子的移动通过递归函数求解。

所以下一步，也是核心的一步就是讨论当前的如何移动。由于不同柱子移动的代价不同，所以通过另一个柱子中转一下并不一定不优，这一点和最短路很相似。那么这里就有了两种不同的转移方式，为了方便记述，记上面的若干柱子为 $A$，最下面的一个柱子为 $B$，现在要从 $1$ 号柱子移动到 $3$ 号。

1. $A$ 从 $1$ 移动到 $2$，$B$ 从 $1$ 移动到 $3$，$A$ 从 $2$ 移动到 $3$。

2. $A$ 从 $1$ 移动到 $3$，$B$ 从 $1$ 移动到 $2$，$A$ 从 $3$ 移动到 $1$，$B$ 从 $2$ 移动到 $3$，$A$ 从 $1$ 移动到 $3$。

其中第二种方案虽然看起来用的步骤多，但是避免了上面的大量盘子通过 $2$ 的移动，所以当通过 $2$ 移动的代价较大时，这一种移动方式可能反而是更优的。

注意这里的 $A$ 可以为空，这样想的话，也就避免了其他题解中的对于单个盘子移动的讨论。

具体实现的时候可以采用记忆化搜索的方式。

---
### 代码：

```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
#define int long long
int n,dis[5][5],f[5][5][50];
int dfs(int x,int y,int num){
	if(f[x][y][num])return f[x][y][num];
	int mid=6-x-y;
	if(num==0)return 0;
	return f[x][y][num]=min(dfs(x,mid,num-1)+dfs(mid,y,num-1)+dis[x][y],
	dfs(x,y,num-1)+dfs(y,x,num-1)+dfs(x,y,num-1)+dis[x][mid]+dis[mid][y]);
}
signed main(){
	for(int i=1;i<=3;i++)
	for(int j=1;j<=3;j++)
	scanf("%I64d",&dis[i][j]);
	scanf("%I64d",&n);
	printf("%I64d",dfs(1,3,n));
	return 0;
}
```
