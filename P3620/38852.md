首先呢

简要题意：

从$n$个点中选取$k$个点，最小化每对点之间的距离

明确一点：要使得每对点之间的距离最小，那这两个点一定是相邻的

由此，我们可以得到一个简单的想法：将距离两两差分，直接从中选出最小的$k$个

但是，这样的想法存在一种可能，也就是我们所选取的$k$个距离可能重复选取两个相同的办公楼。不满足题中所言"**任一个办公楼都属于唯一的配对组(换句话说，这 2K 个办公楼一定是相异的)**"

所以，我们假设选取了差分后的第$i$段，则第$i-1$段和第$i+1$段均无法被选取，但最终答案也可能是选取第$i$段和$i+1$段

因此可以再选取了第$i$段后，将第$i-1$和第$i+1$段标为不可选，再将$len[i-1]+len[i+1]-len[i]$加入可选段中，代表同时选择第$i-1$和第$i+1$段。
（ps:$len[i]$代表差分数组）
  
那要同时选择第$i-1$和第$i+2$段呢？

如果同时选择第$i-1$和第$i+2$段而不是第$i-1$和第$i+1$段的话则必须要满足$len[i+2] \leq len[i+1]$
先选择第$i$段的条件是$len[i] \leq len[i-1]$
则$len[i+2] \leq len[i+1]+len[i-1]-len[i]$

于是乎呢第$i-2$段和第$i$段同时被选择，答案更优，与假设矛盾

因此得到贪心算法：
- 将输入的序列差分成$n$段，且将$n$段放入堆中
- 选出堆中答案最小的一段，加入答案中
- 将该段的前一段和后一段标为不可用
- 将该段在下一次的选择中的权值改为$len[pre]+len[nxt]-len[now]$
- 最后重复上述步骤$k$次，得到答案


最后看一下代码吧：
$vis$数组用于标记一段是否可用，
$sum$呢是所谓的差分，
$q$呢为优先队列
```cpp
for(int i=1;i<=k;i++){
    while(vis[(q.top()).id])q.pop();
    node x = q.top();q.pop();
    ans+=x.num;
    int a=pre[x.id],b=nxt[x.id];
    int v=sum[a]+sum[b]-sum[x.id];
    sum[x.id]=v;
    q.push((node){v,x.id});
    pre[x.id]=pre[a];nxt[pre[a]]=x.id;vis[a]=1;
    nxt[x.id]=nxt[b];pre[nxt[b]]=x.id;vis[b]=1;
    }
```


