今日血压：有且仅有一个数组开小了。要不是 CF 有数组越界提醒，我可能这辈子都看不出这个错误。

---
### 解题思路：

简单数数题。~~就这我还 WA 了两发。~~

正难则反，考虑先算出所有可能的取值然后再减去不可行的方案数。

由于不存在完全相同的二元组，一组方案不可行是三个中有一组 $a$ 相同的同时有一组 $b$ 相同的充分必要条件，那么算出后者即可。

由于要选出的是三个二元组，如果不满足条件就一定意味着有一个二元组的 $a$ 与其中一个相等，同时，$b$ 与另一个相等。那么就考虑每一次枚举这个感觉在中心的二元组，然后用初始化的各个元素的数量计算出可行的方案数。

可以发现，这样的计算由于不存在完全相同的二元组，所以一定没有重复，而且可能的情况也只有这一种，所以一定不存在漏解。


---
### 代码：

```cpp
#include<cstdio>
using namespace std;
#define int long long
int T,n,a[200005],b[200005],cnta[200005],cntb[20005],ans;
signed main(){
	scanf("%I64d",&T);
	while(T--){
		scanf("%I64d",&n);
		ans=0;
		for(int i=1;i<=n;i++)
		cnta[i]=cntb[i]=0;
		for(int i=1;i<=n;i++){
			scanf("%I64d%I64d",&a[i],&b[i]);
			cnta[a[i]]++;
			cntb[b[i]]++;
		}
		ans=n*(n-1)*(n-2)/6;
//一开始看错题，以为是所有的都不能一样，然后就有了下面的容斥
//		for(int i=1;i<=n;i++){
//			ans-=cnta[i]*(cnta[i]-1)/2*(n-cnta[i]);
//			ans-=cntb[i]*(cntb[i]-1)/2*(n-cntb[i]);
//		}
		for(int i=1;i<=n;i++){
			ans-=(cnta[a[i]]-1)*(cntb[b[i]]-1);
		}
		printf("%I64d\n",ans);
	}
	return 0;
}
```
