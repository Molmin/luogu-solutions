### Preface  
神仙题，也是利用差分减少码量的一道题。  
### Problem  
有编号从 $ 1 $ 到 $ N $ 的 $ N $ 家烧烤店，烧烤店在一条线上按照编号顺序排序，第 $ i $ 家烧烤店与第 $ i + 1 $ 家烧烤店的距离是 $ A_i $ 。   
你有编号从 $ 1 $ 到 $ M $ 的 $ M $ 张烧烤券，不管是在哪一家烧烤店都可用烧烤券来吃烧烤，在第 $ i $ 家烧烤店用烧烤券 $ j $ 可以吃到一顿美味度为 $ B_{i,j} $ 的烧烤，每一张烧烤券只能使用一次，但是在一家烧烤店你可以使用任意多张烧烤券。  
你想从自己选择的一家烧烤店开始（随意选择一个开始），然后不断地用未使用的烧烤券去另一家烧烤店。你最终的幸福值是所吃所有烧烤的美味度减去所走的总路程。求最大可能的最终幸福值（ $ M $ 张券必须用完）。  
数据范围：
输入的数字都是整数。  
$ 2 \leq N \leq 5 \times 10^3 $  $ 1 \leq M \leq 200 $   $ 1 \leq A_i \leq 10^9 $  $ 1 \leq B_{i,j} \leq 10^9 $  
### Solution  
我们发现这个数据范围十分鬼畜，看起来不太像是传统的 $n\log n$ 复杂度。  
然后我们发现了一个性质：选一段内的烧烤店时只需要从一头走到另一头就是最短的走路路程。于是我们确定了一个子段内的走路长度，只需要最大化吃烧烤的快乐度就可以了。  
很显然可以搞出一个 $n^2m$ 的暴力，看起来很对。但是鬼畜的数据范围在这时又一次发挥了它的作用：这个复杂度是会超时的。  
看着 $n$ 的大小，我们肯定可以确定我们要搞出一个近似于 $n^2$ 复杂度的解法了，但是坏消息是：仅仅是枚举子段的复杂度就达到了 $n^2$。这让我们十分头疼，毕竟不太可能 $O(1)$ 统计吧！  
我们掏出一个惯用套路：固定子段的一头并把其看作常量，枚举另外一头，这个时候子段就最多只有 $n$ 了。  
在这里我们固定左端点并逐渐往左移动。  
然后我们发现了：往左移动一步之后会受到影响的是有一个烧烤卷的收益比这个端点小的子段。  
我们发现我们确实可以存下每个子段的每个烧烤卷在哪里用掉了。  
然后根据前面的分析，我们的操作应该是在固定左端点并枚举一种烧烤卷的情况下枚举使用贡献小于端点的烧烤店的子段并把它们的这种烧烤卷的使用地改为左端点。   
发现由于每个烧烤店能管到的子段只能是右端点在其之后的子段。这其实就是一个单调栈的流程，于是我们打出 $m$ 个单调栈。  

在上述流程中，扔掉烧烤店后还需要把所有在这个烧烤店买烧烤的子段全部换成左端点的贡献。思考一下什么情况子段会在一个烧烤店买烧烤？由于这是一个单调栈，所以从这个烧烤店开始到下一个在栈内的烧烤店，所有的点与目前左端点组成的子段都在这个烧烤店买烧烤，把这一段都给换成左端点贡献即可。  

每个点自己组成的子段直接就是当前所在烧烤店包场拿到的收益。  

直接在每个左端点处理完后枚举右端点取 $\max$ 更新答案即可。

上面的操作已经可以用线段树做了，但是我们并不甘心：“我推了这么久的东西你还要我再花时间打个线段树？这还是个不怎么优的带 $\log$ 解法？ ”   
欸，这个时候差分就要派上用场了！  
我们发现上述操作其实只有最后要拿到所有的元素，也就是说只询问一次，于是我们可以直接用一个差分数组来代替线段树来进行区间修改。  
code：
```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int N=5010;int now;
int n,m;int b[N][N];int a[N];
int ans;int Stack[N][N];int tot[N];int d[N];
void modify(int l,int r,int x){d[l]+=x;d[r+1]-=x;}
signed main(){
	ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);
	cin>>n>>m;
	for(int i=1;i<n;i++)cin>>a[i];
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++)cin>>b[i][j];
	}
	for(int i=n;i>=1;i--){
		for(int j=1;j<=m;j++){
			while(tot[j]>0&&b[Stack[j][tot[j]]][j]<=b[i][j]){
				if(tot[j]>1)
					modify(Stack[j][tot[j]],Stack[j][tot[j]-1]-1,b[i][j]-b[Stack[j][tot[j]]][j]);
				else modify(Stack[j][tot[j]],n,b[i][j]-b[Stack[j][tot[j]]][j]);
				tot[j]--;
			}
			modify(i,i,b[i][j]);Stack[j][++tot[j]]=i;
		}modify(i+1,n,-a[i]);now=0;
		for(int j=i;j<=n;j++)now+=d[j],ans=max(ans,now);
	}
	cout<<ans;
}
```
