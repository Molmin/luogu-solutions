### 放在前面
- ~~2200难度的题我能在比赛时做出来真是个奇迹~~
- ~~再说一句，B1我还真不会~~
### 理论
- 我们列一个表（例子五）
- 7 2 3
- 3 0 2 1 3 0 1
```cpp
除以6
余3-6 3 5 4 6 3 4
余4-5 2 4 3 5 2 3
余5-4 1 3 2 4 1 2
余0-3 0 2 1 3 0 1
余1-4 1 3 2 4 1 2
余2-5 2 4 3 5 2 3
余3-6 3 5 4 6 3 4
```
注意：表是经过变形的，从余3开始
- 显而易见，应该从**开始退潮后**离海岸最近的一列**第一次**进入安全水位后入海。
- 接下来，将表的安全水位用1标出，其余用0。
```cpp
0 1 0 0 0 1 0
0 1 0 1 0 1 1
0 1 1 1 0 1 1
1 1 1 1 1 1 1
0 1 1 1 0 1 1
0 1 0 1 0 1 1
0 1 0 0 0 1 0
```
解法显而易见了
- 接下来**能往右下角走**的就**往右下角走**（普通列），不行就等到能往前走，遇到**无论什么时候都在安全水位**的列（特殊列）就等到**重新退潮**再继续走。
- 显然要重新回到第一行就要通过**无论什么时候都在安全水位**的列。（等到最后一行后循环到第一行）
- 以上过程对于每列都可以用max（普通列）和直接移动到第一行+max（特殊列）来用1至2次运算实现
### 无法到达的判定
无法向右下角走，也无法向下走
### 程序
```cpp
#include <bits/stdc++.h>
using namespace std;
long long a,n,k,l,m,las,p;
int main()
{
	cin>>a;
	for(int i=0;i<a;i++)
	{
		p=1;
		las=0;
		cin>>n>>k>>l;
		for(int j=0;j<n;j++)
		{
			cin>>m;
			if(m>l)//走不通
			{
				p=0;
			}
			else if(m+k<=l)//特殊列
			{
				las=0;
			}
			else if(las<k)//普通列
			{
				las=max(las+1,k-(l-m));
			}
			else
			{
				if(k+(l-m)<las+1)//走不通
				{
					p=0;
				}
				else
				las++;//往下一行，往前一列
			}
		}
			if(p==1)
			cout<<"Yes"<<endl;
			else
			cout<<"No"<<endl;
	}
    return 0;
}
```
## 写在后面
~~不知道cf上dp的tag是从哪来的~~