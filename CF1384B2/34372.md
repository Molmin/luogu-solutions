考虑维护在一个位置上可以停留的时刻。

如果前一个位置可以一直停留，那这个位置的合法时刻会形如 $[0,d_{max}]\cup [2k-d_{max}+1,2k]$，其中 $d_{max}=l-d$。为了便于处理，我们把 $[0,k]$ 的区间向右平移 $2k$ 个单位，它就是一个关于 $2k$ 对称的区间 $[2k-d_{max},2k+d_{max}]$。

前一个位置不能一直停留，考虑用前一个位置的区间 $[l,r]$ 推出下一个位置的区间。如果 $[l,r]\cap[2k-d_{max},2k+d_{max}]\neq \emptyset$，这个位置是合法的，并且可以停在 $[\max(l,2k-d_{max}),2k+d_{max}]$ 中，把它向右平移 $1$ 就是下一个位置的区间；否则无解。注意特判。

（感觉其他题解做法都好奇怪。）

```cpp
scanf("%lld%lld%lld",&n,&k,&l);
a=k,b=3*k,flag=1; //区间 [a, b], 答案
for(int i=1;i<=n;i++) {
	scanf("%lld",&d);
	if(a>2*k+(l-d)||b<2*k-(l-d)||l<d) flag=0;
	a=max(a,2*k-(l-d))+1,b=2*k+(l-d)+1;
	if(b>3*k) a=k,b=3*k;
}
puts(flag?"Yes":"No");
```