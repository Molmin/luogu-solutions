[传送门](https://www.luogu.com.cn/problem/CF1452D)

### 题面：

一行有n个城市，在一些城市上放上信号塔，每个城市放上信号塔的概率互不影响，都为$\frac 1 2$，求有多少概率使得放完信号塔之后，存在一个各个信号塔信号分配方案，满足以下条件：

- 1到n的所有城市都有信号，且0和n+1城市没有信号

- 所有城市可以接收到信号的城市只有1个

一个信号塔分配了r的信号，就可以覆盖包含自身在内的半径为r的范围内的城市

第二条限制解释：01010是不合法的方案，因为给2塔和4塔半径为2的信号虽然满足第一条限制，但由于3城市可以接收到信号的城市有2和4两个，所以不满足第二条限制

答案对998244353取模

### Solution：

有概率不好搞，但看样例解释很容易发现，其实$\frac 1 2$这个数字没用，最终答案一定为$\frac {a_n} {2^n}$，$a_n$表示方案个数，也就是求出方案个数再乘上2的次幂对998244353的逆元即可

求方案个数：不难想到暴力$dp$，枚举最左端被覆盖的半径

```cpp
a[0] = a[1] = a[2] = 1;
for (int i = 3; i <= n; ++i)
	for (int j = 1; j <= i; j += 2)
		a[i] = (a[i] + a[i - j]) % P;
```

看式子，不难想到前缀和优化，因为每次是```j+=2```，所以奇偶分开统计前缀和，令$f[i],s[i]$分别表示i为偶数和奇数时的奇偶性相同的前缀和，因为方程中下标每次减的都是奇数，所以i为奇数的时候要从偶数前缀和统计答案，然后将算出的$a_i$加入奇数前缀和

### Code：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int N = 2000005, P = 998244353;
int a[N], f[N], s[N];
inline int power(int a, int b) {
    int res = 1;
    for (; b; b >>= 1, a = a * a % P)
        if (b & 1) res = res * a % P;
    return res;
}
signed main() {
    int n;
    cin >> n;
    a[0] = a[1] = a[2] = 1;
    s[1] = 1, f[2] = 2;
    for (int i = 3; i <= n; ++i) {
        if (i & 1) {
            a[i] = f[i - 1];
            s[i] = (s[i - 2] + a[i]) % P;
        } else {
            a[i] = s[i - 1];
            f[i] = (f[i - 2] + a[i]) % P;
        }
    }
    cout << power(power(2, n), P - 2) * a[n] % P;
    return 0;
}
```