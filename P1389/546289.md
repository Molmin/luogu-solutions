我们发现这题每次只能取连续段，很像区间 *dp*，于是往这方面脑补，结果还是不会（悲）。

其实这题的确是区间 *dp*，作者觉得这题真特难想（作者很菜，如有意见请勿喷）。

+ 最暴力做法

先不着急求**可取部分**的情况，先把**全部取完**的情况求出来再通过**全部取完**转移成**可取部分**

我们用 $f_{l,r}$ 表示**全部取完** $l$ 到 $r$ 时的最大收益。对于 $f_{l,r}$，枚举全部取完 $l$ 到 $r$ 的最后一步取了哪些点，并将**全部取完这些点的收益与全部取完这些点之间的空隙区间的收益之和**取最大值，就是 $l$ 到 $r$ 区间的最大收益。

我们使用区间 *dp* 按区间长度从短到长求解，上述的空隙区间一定会在这之前求出。

设 $ans_{l,r}$ 为 $l$ 到 $r$ 的区间**可取部分**时的最大收益，可以直接暴力枚举断点，然后与 $f_{l,r}$ 比较，最后与啥都不取的 $0$ 比较（经典模板）。

可是这样很明显是过不了的。

+ 正解

考虑通过纯 *dp* 来代替搜索。

对于 $l$ 和 $r$ 不在同一次取走的情况，只需枚举断点即可，像这样：

```cpp
for (int k = l; k < r; k++)
	f[l][r] = max (f[l][r], f[l][k] + f[k+1][r]);
```

对于 $l$ 和 $r$ 在同一次取走的情况，说明取走 $l$ 和 $r$ 的这一步一定是全部取完 $l$ 到 $r$ 的最后一步。

由于合法的取数序列数值必定为先递增后递减（包括完全递增和完全递减），总之为山峰状。

我们可以枚举全部取完该区间的最后一步的取数序列中的最大值的位置 $k$（即峰顶），然后把该取数序列分成递增部分和递减部分。递增部分的开头是 $l$，结尾是 $k$，递减部分的开头是 $k$，结尾是 $r$。

既然两部分的开头和结尾都定下了，因为合法取数序列的数必须两两相差 $1$，两部分的长度也固定下来，为 $a_{k}-a_{l}+1$ 和 $a_{k}-a_{r}+1$。

那么全部取完该区间的最后一步的取数序列长度就是固定的了，现在只需要使得他们之间的空隙区间的收益和最大就行。于是我们考虑利用数组维护最大收益。

我们用 $u_{l,r}$ 表示两端分别为 $l$ 和 $r$ 且可以作为递增部分的取数序列中空隙区间的最大收益，用 $d_{l,r}$ 表示两端分别为 $l$ 和 $r$ 且可以作为递减部分的取数序列中空隙区间的最大收益。

转移长这样：

```cpp
for (int k = l; k <= r; k++) 
	f[l][r] = max (f[l][r], getAns (l, k, r));
```
那么怎么维护 $u$ 和 $d$ 呢？

对于已经求好的 $f_{l,r}$，尝试将取完 $l$ 到 $r$ 的取法换成 $f_{l,r}$ 的取法，$l-1$ 和 $r+1$ 归到最后取完 $l$ 到 $r$ 的那一步去，除 $l$ 到 $r$ 以外的部分用他们目前的取法，与原来的收益比较。因为相同的 $a_{i}$ 不会超过 $7$ 个，所以这样不会超时。

像这样：

```cpp
if (a[l-1] + 1 == a[r+1])
	for (int k = 1; k < l; k++)
		for (int q = r + 1; q <= n; q++)
			u[k][q] = max (u[k][q], u[k][l-1] + u[r+1][q] + f[l][r]);
if (a[l-1] == a[r+1] + 1)
	for (int k = 1; k < l; k++)
		for (int q = r + 1; q <= n; q++)
			d[k][q] = max (d[k][q], d[k][l-1] + d[r+1][q] + f[l][r]);
```
+ 献上代码一份

```cpp
#include <bits/stdc++.h>
#define N 200
#define Inf 2e9
using namespace std;

int u[N][N], d[N][N], f[N][N], ans[N][N], n, a[N], v[N];
//由于取值方便，up数组和down数组不包括最后一次操作的收益
int getAns (int l, int m, int r)	//得到分别是 up 和 down 的两个相邻区间组合后的答案 
{
	if (2 * a[m] - a[l] - a[r] + 1 > n) return -Inf;	//防止爆数组（不然凉凉） 
	if (a[m] < a[l] || a[m] < a[r]) return -Inf;
	return u[l][m] + d[m][r] + v[2*a[m]-a[l]-a[r]+1];
}

int main ()
{
	cin >> n;
	for (int i = 1; i <= n; i++)
		cin >> v[i];
	for (int i = 1; i <= n; i++)
		cin >> a[i];
	memset (f, 245, sizeof (f));
	memset (u, 245, sizeof (u));	//初始化 	
	memset (d, 245, sizeof (d));
	for (int i = 1; i <= n; i++) u[i][i] = d[i][i] = 0, f[i][i-1] = 0;	 
	f[n+1][n] = 0;
	for (int i = -1; i < n; i++)	//细节，i的初值为 -1 
	{
		for (int j = 1; j + i <= n; j++)
		{
			int l = j, r = j + i;
			for (int k = l; k <= r; k++)	//l 和 r 属于同一次 
				f[l][r] = max (f[l][r], getAns (l, k, r));	//通过 up 和 down 组合成 取完该区间的那次操作 
			for (int k = l; k < r; k++)		//l 和 r 不属于同一次 
				f[l][r] = max (f[l][r], f[l][k] + f[k+1][r]);	//只需枚举断点，取 max 即可 
			if (a[l-1] + 1 == a[r+1])	//因为右边比左边大 1，所以更新 up 数组 
				for (int k = 1; k < l; k++)	//枚举需要更新的区间 
					for (int q = r + 1; q <= n; q++)
						u[k][q] = max (u[k][q], u[k][l-1] + u[r+1][q] + f[l][r]);
			if (a[l-1] == a[r+1] + 1)	//因为右边比左边小 1，所以更新 down 数组 
				for (int k = 1; k < l; k++)
					for (int q = r + 1; q <= n; q++)
						d[k][q] = max (d[k][q], d[k][l-1] + d[r+1][q] + f[l][r]);
			//更新方法：枚举需要更新的区间，考虑将区间内 l~r 这一段的取法变为 f[l][r] 的取法，
			//左侧和右侧都用 up 或 down 的取法，最后将三段的收益之和取 max，并与原来的取法比较，是否更新答案。 
		}
	}	//求 全部取完 的答案 
	for (int i = 0; i < n; i++)
	{
		for (int j = 1; j + i <= n; j++)
		{
			int l = j, r = j + i; ans[l][r] = max (ans[l][r], f[l][r]);	//初始值为 max(0, f[l][r]) 
			for (int k = l; k < r; k++)	//枚举断点 
				ans[l][r] = max (ans[l][r], ans[l][k] + ans[k+1][r]);
		}
	}	//求 取部分 的答案 
	cout << ans[1][n];
	return 0;
}

```
吸氧 $42ms$ 轻松拿到最优解。

+ 后记

做了这题感觉区间 *dp* 实力有提升，以前做的区间 *dp* 都是三重循环套板子的，这题就比较灵活。个人觉得是道好题。