[用来凑字数的题目传送门：Santa Claus and Robot。](com.cn/problem/CF748C)

## Part 1：题目翻译。
这个翻译令人满意。但是要注意一点：在翻译中并没有写 ```RULD``` 到底对应上下左右哪一个，这四个字母分别对于右上左下。

## Part 2：题目算法分析。
这道题是为了寻找一个机器人用最短路径到达一定个数的点数，已经给出机器人路径，输出最少有多少必定经过的点。

由于数据大小：$ 1 \leq n \leq 2·10^{5} $。所以第一个想出的是贪心。

那么要怎么“贪”呢？题目说明这个机器人一定走的是最短路径，如果目前来看不是的话，那么就说明这一个必定经过的地点到目前下一个中间还隔了一个必定经过的地点。这样一分析，我们所要达到的目标由最开始的转变成了找到有多少个非最短路径。

那么怎么判断呢？对于每一步，由于我们对下一个目标不确定，所以我们只能通过目前与之前来判断，那么~~我目前只能想到的~~就只有“走回头路”。我们可以用两个变量来记录目前自己的上下和左右的方向，如果目前的与之前的相矛盾，那么就说明这个地点有一个必定经过的点，答案更新。

## Part 3：代码。
```
#include <bits/stdc++.h>
using namespace std; 
long long n,ans;
char x=' ',y=' ';
string a;
int main() 
{
   	cin>>n>>a;
   	for(int i=0;i<a.size();i++)
   	{
		if(a[i]=='R' || a[i]=='L')
			if(x==' ' || x==a[i]) x=a[i];
            //如果目前的方向与之前的不矛盾，那么不变。
            //特殊的，如果之前这个方向不确定，那么我们就可以明确目标，将 x 赋值。
			else  x=a[i],y=' ',ans++;   
            //否则，更新这个方向的路线，然后将另一个方向转化为不确定，记得答案增加。
		else
			if(y==' ' || y==a[i]) y=a[i];
			else  y=a[i],x=' ',ans++;  	
            //同上
	}
	cout<<ans+1;
    return 0;
} 
```