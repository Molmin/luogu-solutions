####  这一题是一道典型的dp题，但是我们可以用各种思想处理这道题
- 前置知识点

1.前缀和:比较广泛出现在代码中，可以用来求前k个数的和，略过不讲

2.矩阵前缀和：用来存一个以(1,1)为起点，(x,y)为终点的矩阵之和，当然也可以通过各种操作来处理更多的题目，基础代码如下:

------------
```cpp
sum[i][j]=sum[i-1][j]+sum[i][j-1]-sum[i-1][j-1]+a[i][j]
//a[i][j]代表(i,j)的值
//sum[i][j]代表以(1,1)为起点，以(i,j)为终点的矩阵和
```
------------
如果有不懂的可以通过画图来自行理解这段代码。

- 题目

似乎刚刚的知识点根本没办法扯到题目中去啊
先来看题：求(i,j)权值为零时，第i行与第j列之和。

- 解题

1. 我们要先判断是否有格子权值为零

2. 我们要求出最大值//因为(i,j)为零所以不用去重

我们先来维护一下矩阵前缀和，如果矩阵之和等于矩阵元素数（n*n）那么输出Bad Game

------------
```cpp

	if(sum[n][n]==n*n){
		printf("Bad Game!");
		return 0;
	}
```
------------
然后我们要求出每一行和每一列的和，这里我们只要用(i,j)与(i-1,j)做差就能求出第i行的值；

同理，我们只要用(i,j)与(i,j-1)做差就能求出第j列的值；

代码实现如下：


------------
```cpp

	for(register int i=1;i<=n;++i){
		a[i][0]=sum[i][n]-sum[i-1][n];//第i行的和
		a[0][i]=sum[n][i]-sum[n][i-1];//第j列的和
	}
```


------------
然后穷举所有i，j即可：

参考代码如下：


------------
```cpp
#include<bits/stdc++.h>
using namespace std;
int sum[1010][1010],a[1010][1010],n,ans;
int main() {
	scanf("%d",&n);
	for(int i=1; i<=n; ++i) {
		for(int j=1; j<=n; ++j) {
			scanf("%d",&a[i][j]);
			sum[i][j]=a[i][j]+sum[i-1][j]+sum[i][j-1]-sum[i-1][j-1];
		}
	}
	if(sum[n][n]==n*n) {
		printf("Bad Game!");
		return 0;
	}
	for(int i=1; i<=n; ++i) {
		a[i][0]=sum[i][n]-sum[i-1][n];
		a[0][i]=sum[n][i]-sum[n][i-1];
	}
	for(int i=1; i<=n; ++i) {
		for(int j=1; j<=n; ++j) {
			if(!a[i][j]) {
				ans=max(ans,a[i][0]+a[0][j]);
			}
		}
	}
	printf("%d\n",ans);
}
```
