算法呢，这题可以看成一道二维数组的题目，逐个查找，
是0的就可以每一行每一列的加起来，因为0的地方是没敌
人的，所以要先判断是否是0，不是才能加起来，而且还
要判断是不是最大的，输出最大的。
代码如下： 
```
#include<iostream>
#include<fstream>
#include<algorithm>

using namespace std;
int a,gw,da=-210000000;//da=-210000000是为了判断最大，而且也是为了判断能不能有位。 
int aa[1005][1005]; //本人的好习惯，多定义几个位置，以防数组爆 。 
int main()
{
    cin>>a;//输入矩阵大小。a*a大小 
	for(int i=0;i<a;i++)
	{
		for(int j=0;j<a;j++)//二维数组需要用2个for，第一个定i第二个不能定i，所以定j。 
		{
			scanf("%d",&aa[i][j]);//因为最大的情况是1000*1000=1000000>100000，所以为了不TLE所以使用scanf来输入。 
		}
	} 
    for(int i=0;i<a;i++)
	{
		for(int j=0;j<a;j++)//逐数组位枚举 
		{
		if(aa[i][j]==0)//判断是否是空位，不是不运行，是才运行if里的程序。 
		{
		for(int k=0;k<a;k++)//在前面因为有了i和j，所以定k 
		{
			gw+=aa[i][k];//枚举所在那一行的敌人的敌人个数 
		}
		for(int k=0;k<a;k++)
		{
			gw+=aa[k][j];//枚举所在那一列的敌人的敌人个数
		}	
		}
		if(gw>da){da=gw;}//判断这个位能击败的敌人个数是否大于最大能击败的敌人个数，大于的话就更新大。 
		gw=0;//敌人数清0. 
		}
	} 
	if(da==-210000000){cout<<"Bad Game!";}//判断有没有位置，没有输出Bad Game!。 
	else{cout<<da;} //否则输出最多能击败敌人的个数。 
    return 0;
    //严禁抄袭程序！！！！ 
}
```


