[题面](https://www.luogu.com.cn/problem/CF1284E)

有参考各位大佬和 codeforces 官方题解的思路，主要补充了一些其他题解缺少的小细节，比如破环为链的细节。不喜勿喷。

点数:2500

### 前置知识：

#### 极角排序。

在 $n$ 个点中选择一个点作为原点，并计算其他节点的相对于原点的极坐标，可以理解为重建坐标系，建成一个极坐标系。之后我们按照新坐标对其排序。得到的就是一个用斜率排序，和距离排序的点集了。

### 凸包

自己去学吧，我不会（懒得）讲。

## 分析

这是一道神奇的组合数+容斥题。

定义 5-set 为：从给定的点集选择任意 5 点组成的子集。

我们发现其实题目可以转化为求 5 给节点使得 4 个节点包围另外一个，这 4 个节点连成的图形刚好应该是这 5 个节点的凸包，因为这样才能保证包围另一节点。考虑每一组 5 个节点。注意到不存在任意三点共线，那么对于所有的 5-set 的凸包只存在 3 中情况：

1. 凸包为一个三角形。对答案贡献为 2。容易发现凸包内部两点满足题意。
2. 凸包为一个四边形。对答案贡献为 1。容易发现只有不在凸包上的那一点满足要求。
3. 凸包为一个五边形。对答案无贡献，任意选择一点都不在另外四个点连成的四边形内部。

设这三种情况的个数分别为 $x_1$，$x_2$，$x_3$，答案就是 $2x_1+x_2$。其中我们发现 $x_1+x_2+x_3=\dbinom{n}{5}=C_n^5$。这时 codeforces 的官方题解引入了一个巧妙的容斥。我们发现 $ans=5\times\dbinom{n}{5}-5\times x_3-4\times x_2-3\times x_1$。设 $y=5\times x_3-4\times x_2-3\times x_1$ 那么 $y$ 相当于就是所有 5-set 的凸包边数之和。问题转化为求左右 5-set 的凸包的边数之和。

直接枚举 5 个节点的时间复杂度显然是不能接受的，我们尝试计算每条边对此的贡献，即枚举每一条边。一条边确定了两个点，那么只需再找出 3 个节点使得已经确定的边在凸包上。由于我们不关心另外 3 个点的任何情况，可以发现这三点只需都在这条直线一侧即可。这时我们进行极角排序，双指针维护即可。注意！在极角排序之后这些点挨个连在一起实际上形成了一个环而不是一条链，这时需要我们破环为链进行维护。原因很简单，我们发现枚举的边的斜率是具有单调性的，但是我们假设我们从斜率最小的边 $x$，开始枚举，当枚举到某一条边时，这条边右侧（这里指这个人在这条边离原点近的点朝向离原点较远的点）的点实际上就是边 $x$ 的左侧的点，所以实际是一条链。这里读者可以自己画图辅助理解。

这题卡精度和系统自带的三角函数，用向量叉积替代。

复杂度：$O(n^2\log n^2)$。核心代码如下：

```cpp
const ll MAXN=5007;
ll n,C[MAXN][7];
struct node
{
	ll x,y;
}a[MAXN],v[MAXN];
ll cross(const node& xx,const node& yy)
{
	return xx.x*yy.y-xx.y*yy.x;
}
bool cmp(const node& xx,const node& yy)
{
	ll flagx=(xx.y<0)|((xx.y==0)&(xx.x>0)),flagy=(yy.y<0)|((yy.y==0)&(yy.x>0));
	if(flagx!=flagy)return flagx<flagy;
	return cross(xx,yy)>0;
}
int main()
{
	n=read();
	for(ll i=1;i<=n;i++)
	{
		a[i].x=read(),a[i].y=read();
	}
	for(ll i=0;i<=n;i++)
	{
		C[i][0]=1;
		if(i<=5)C[i][i]=1;
		for(ll j=1;j<=min(i,5);j++)
			C[i][j]=C[i-1][j-1]+C[i-1][j];
	}
	ll ans=0;
	for(ll i=1;i<=n;i++)
	{
		ll cnt=0;
		for(ll j=1;j<=n;j++)if(j!=i)
			v[++cnt]=node{a[j].x-a[i].x,a[j].y-a[i].y};
		sort(v+1,v+cnt+1,cmp);
		for(ll j=1;j<=cnt;j++)v[cnt+j]=v[j];
		ll las=1;
		for(ll j=cnt+1;j<=(cnt<<1);j++)
		{
			while(las+cnt<=j||cross(v[j],v[las])>0)las++;
			ans+=C[j-las][3];
		}
	}
	write(5*C[n][5]-ans);
	return 0;
}
```

