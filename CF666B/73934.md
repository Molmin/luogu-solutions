**思路：**

- $bfs$+~~暴力~~枚举

> 找到$a,b,c,d$四点，使得$a$到$b$的最短路$+b$到$c$的最短路$+c$到$d$的最短路最长

首先，可以想到枚举四点，计算最短路，$O(n^5)$

然后，发现可以预处理出多源最短路，因为边权相同，可以对每一点$bfs$~~（反正bfs比spfa快）~~，$O(n^4)$

接着，发现只要预处理出连向$b$点的尽量远的一点，$c$连向的尽量远的一点就可以以$O(n^2)$完成

*但我们仅仅预处理出连向$b$点的**最**远的一点，$c$连向的**最**远的一点就够了吗？*

假如$c$点连向的最远的一点为$k$，连向$b$点的最远的一点为$l$，

若$k=l$。。。

所以最远是不够的

*但我们仅仅预处理出连向$b$点的**最**远，**次**远的一点，$c$连向的**最**远，**次**远的一点就够了吗？*

假如$c$点连向的最远的一点为$k_1$，次远的一点为$k_2$；连向$b$点的最远的一点为$l_1$，次元的一点为$l_2$

若$k_1=l_1\& k_2=b$

所以次远是不够的

第三远呢？

假设最远相同，次远已被选被，还有第三远

因此第三远已足够

时间复杂度$O(n^2)$

**核心代码：**

``` cpp
#include <bits/stdc++.h>
using namespace std;

···

	for (int j = 1; j <= n; j++) {
		for (int k = 1; k <= n; k++) {
			if (j == k) {
				continue;
			}
			for (pii p1 : pre[j]) {
				int i = p1.sec;
				if (i == j || i == k) {
					continue;
				}
				for (pii p2 : nxt[k]) {
					int l = p2.sec;
					if (i == l || j == l || k == l) {
						continue;
					}
					if (sum < dis[i][j] + dis[j][k] + dis[k][l]) {
						sum = dis[i][j] + dis[j][k] + dis[k][l];
						ans[1] = i, ans[2] = j, ans[3] = k, ans[4] = l;
					}
				}
			}
		}
	}
```

与@王景毅 大佬的~~暴力~~枚举相似。。