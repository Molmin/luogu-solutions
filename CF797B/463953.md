# 思路：
根据贪心思想，我们肯定首先要把所有的正数加起来，这样保证了最大。

但是这个时候有一种特殊情况：所有正数的和为偶数。这就引出了两种情况：

1. 需要减去一个最小的奇数正数

1. 需要加上一个最大的奇数负数

根据小学数学原理 1：偶数减奇数一定为奇数，可得上面的两种情况正确且最优。

如果是这样的话，我们直接贪心加暴力即可。

## Code：
```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
    int n;
    cin>>n;
    int a[n];
    for(int i=0;i<n;i++)
    cin>>a[i];
    int sum=0;
    for(int i=0;i<n;i++)
    if(a[i]>=0)sum+=a[i];//标记1
    if(sum%2==0)//标记2
    {
        int maxn=-999999;
        for(int i=0;i<n;i++)
        if(a[i]<0&&a[i]%2!=0&&maxn>a[i])maxn=a[i];
        if(maxn=-999999)
        {
            //找最小正数的代码与上面一段相似，就不贴了
        }
        cout<<sum+maxn<<endl;
        return 0;
    }
    else
    {
        cout<<sum<<endl;
        return 0;
    }
}
```

但是这一段代码有一个缺点：要是数据再大一点你不 T 掉算我输。

所以我们要考虑优化。

# 优化：
上面的算法的时间复杂度（忽略输入时间且考虑最不利情况）为 $ O(2n) $。能不能再优化？

注意看上面代码标记 1 的部分：这是在求正数的和。标记 2 则是在求最大的奇数负数。

其实我们可以把这个数组分成两段：正数段和负数段，一个快排就好啊。之后我们只要从后往前加正数，从前往后找负数就好啊。

但是这里还有一个优化：我们在从后往前加正数的时候就可以定义变量 $ xb $ 来保存正数和负数的分界点。

这样我们直接从分界点所指向的数 $ a_{xb} $ 来找就好了！

### 结语：

优化真的非常重要！为了防止有人喜欢 Ctrl+C，代码就不贴了，勤于动脑噢！