这道题算是一个思考题吧

## 题目概要：

有两个相同长度的字符只有 4 和 7 的字符串，要把这两个字符串变得相同，

可以有两种操作：

* 在第一个字符串中单独改变一个数

* 在第一个字符串中交换任意两个数

问最少的操作次数是多少？

## 题目分析：

如果要把两个**只有两种字符**的字符串变得相同，可以想到：

1. 如果两个字符串的相同位置的字符一样，那么这个位置的字符不用改变 。

2. 如果两个字符串的相同位置的字符不一样：

> * 如果有另一个相同位置的字符不一样且那个字符恰好与这个字符不一样，交换两个数。

> * 如果没有上述那种情况，就单独改变这个数。

原因很明显，交换一次两个不相同的数字就相当于改变两次数字，

在达到同样目的的情况下，前者操作次数比后者少，

所以尽量用交换的操作总是没错的。

## 大概流程：

1. 读入两个字符串

2. 同时扫描两个字符串：

> * 如果字符相同，不做操作。

> * 如果字符不同，对第一个字符串的数字进行统计，如果是 4 对 4 进行计数；如果是 7 对 7 进行计数。

我们可以想象，4 和 7 相互抵消，操作数为 4（7） 的数量，

同时剩下需要改变的数字只有 4 或者只有 7，

剩下的只能单独改变，所以要加上剩下的操作数。

所以最后输出 ``max（对 4 的计数， 对 7 的计数）``。

## 代码实现：

```
#include <iostream>
#include <cstdio>
#include <cstring>
#include <string>
#define F1(i, a, b) for (int i = a; i <= b; ++i)

std :: string a, b;

int main() {
	int l4 = 0, l7 = 0, l; // l4 为对 4 的计数， l7 为对 7 的计数
	std :: cin >> a >> b;
	l = a.length();
	F1(i, 0, l - 1) {
		if (a[i] != b[i]) { // 如果相同位置的字符不一样
			if (a[i] == '4') ++l4; // 对 4 计数
			else ++l7; // 对 7 计数
		}
	}
	printf("%d", std :: max(l4, l7)); // 输出
	return 0;
}
```