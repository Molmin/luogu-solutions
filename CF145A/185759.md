## 这题恶意评分...其实实质是道红题！！！

### 题面翻译：

给你两个由 $ 4 $ 和 $ 7 $ 构成的字符串 $ a,b $ ，并给你两种变换方式：

1. 把字符串 $ a $ 中的任意一个字符从 $ 4 $ 变成 $ 7 $ 或者从 $ 7 $ 变成 $ 4 $ 。

2. 把字符串 $ a $ 中的某两个元素（这两个元素一定是一个 $ 4 $ 一个 $ 7 $ ）交换位置。

然后，让你求出把字符串 $ a $ 变为字符串 $ b $ 所需的最少步骤数。

### 思路：

两种变换方式其实实质上都是按要求把 $ 4 $ 变成 $ 7 $ 或者把 $ 7 $ 变成 $ 4 $ ，只不过使用一次第二种方法可以比第一种方法节省一步。

所以，根据上面那个~~废话~~，我的思路就初步形成了：

1. 先找到字符串 $ a $ 中到底有多少个 $ 4 $ 和多少个 $ 7 $ 与字符串 $ b $ 不同，分别放到变量 $ p4 $ 和 $ p7 $ （变量名你随便定义，我选了 $ p4 $ 和 $ p7 $ ）中去。

2. 然后我们知道，如果都是按照第一种方案来做，那么答案是 $ p4+p7 $ （这个就是要消耗的最多的步数（全部都只做方法一，一次只改变一个字符））。

   但是我们还有方案二（交换两个位置上的字符），每使用一次方案二就可以节约 $ 1 $ 步，只不过它有要求必须每次交换是一个 $ 4 $ 和一个 $ 7 $ 。
   
   而两个字符串中不一样的字符我们在上一步中已经分别求出，所以最多可以匹配 $ min(p4,p7) $ 个 $ 4 $ 和 $ 7 $ ，也就是说最多可以节省的步数是 $ min(p4,p7) $ 步。

3. 所以，所需的最少步数就是最多的步数减去最多可以减掉的步数，即 $ p4+p7-min(p4,p7) $ 上述式子显然可以化简（因为 $ min(p4,p7) $ 必定是 $ p4 $ 和 $ p7 $ 中较小的那一个，所以减去之后剩下的应该是 $ p4 $ 和 $ p7 $ 中较大的那一个），化简结果就只剩下 $ max(p4,p7) $ 。所以， $ max(p4,p7) $ 就是这道题的最小解。

### 下面贴上我的AC代码：

```cpp
#include<bits/stdc++.h>
#define int long long
//其实这个好像完全没必要，我属于手残党，每次都会写这个...
using namespace std;
string a,b;
signed main(){
	cin>>a>>b;
	int len=a.length(),p4=0,p7=0;//记录字符串长度以及p4,p7的初始化
	for (register int i=0;i<len;i++){
		if (a[i]!=b[i] && a[i]=='4') p4++;//统计a中有几个4和b中的不一样
		if (a[i]!=b[i] && a[i]=='7') p7++;//统计a中有几个4和b中的不一样
	}
	printf("%lld\n",max(p4,p7));//手推完公式后的答案
	return 0;//完美结束程序
}
```

[我的AC记录](https://www.luogu.org/recordnew/show/18113090)