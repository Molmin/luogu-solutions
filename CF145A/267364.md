严重怀疑恶评，咋可能是绿色wq   
  
_______    
  
首先，这道题本身并不难qwq  
  
先来看看题目：   

```
定义幸运数字为只含有“幸运字符”（4和7）的正整数。如4，7，744是，而5,17,467不是。

现有两个等长的字符串a，b，只含“幸运字符”，对a进行下面两个操作中的任意一种：
  
1. 将任意一个a中的字符从4变7，或者从7变4。

2. 将a中任意两个字符位置互换。

求能使a变成b的最小操作次数。
```   
  
先看操作一，既然是等长且只有两个字母，那么就很好办了：不是 4 就是 7 吖。   
  
接着看看操作二能对操作一有什么优化：可以将任意两个字符交换。   
  
因为只有两种交换可能，相同与不相同的交换，很明显相同的交换并没什么用，故只可能将不同的两个字符交换，这一步操作可以代替两步操作一。   
  
那么答案已经出来了：尽量地用第二种操作，直到不能用了，再进行第一步操作。    
  
那么什么时候才不能用第二种操作呢？根据操作二的条件，可以得知是没有两个不符合字符串 $b$ 的字符相同，于是我们可以得出答案为 **若 $a_i = '4'$ 且 $b_i = '7'$ 的情况大于 $a_i = '7'$ 且 $b_i ='4'$ 的情况，那么答案就是前者，否则为后者。**    
  
code:  
   
```
#include <bits/stdc++.h>

using namespace std;

signed main() {
	
	string a, b;
	int di4 = 0, di7 = 0;
	
	cin >> a >> b; //因为没有空格所以采用 cin
	
	for (int i = 0; i < a.size(); i ++) {
		
		if (a[i] != b[i]) //两个字符必须要不同才能进行下面的判断
			if (a[i] == '4' && b[i] == '7')
				++ di4;/*两种不同要区分开来*/ else ++ di7;
	}
	
	printf ("%d", max (di4, di7));
	return 0;
}
```  
  
码风较差，求大佬们少点吐槽（