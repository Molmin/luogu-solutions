# [ARC154C] Roller

## 题面翻译

$t\ (1\ \le\ T\ \le\ 5000)$ 组数据，每组给出 $n$ 和长度为 $n$ 的两个序列 $a,b\ (1\ \le\ A_i,B_i\ \le\ N)$。定义一次操作为将 $a_{i}$ 赋值为 $a_{i+1}$，特别的，$a_{n+1}=a_1$。问 $a$ 是否能操作到 $b$。

## 思路

初看本题，模拟不行，那么就去找它的数学规律。

我们从序列 $a$ 中所含有的数字种类（不考虑数字的数量）来分类讨论：

- $a$ 中缺少 $b$ 中的任意数字。

毋庸置疑，这种情况下 $a$ 无法操作到 $b$。

- $a$ 中有 $b$ 中的任何数字且有 $b$ 中没有的数字

这种情况我们把多余的数字看成空白即可，因为我们很容易就可以将 $a$ 进行操作，使得 $a$ 变成下面这种情况。

- $a$ 中含有的数字恰好与 $b$ 中的数字相同。

这种情况我们需要着重考虑。

首先观察题目：$a_{i}$ 可以赋值为 $a_{i+1}$，$a_{n+1}=a_1$，很明显是一个环形结构。

我们不考虑每个数字的数量，只考虑每种数字与其他数字的相对位置。经过证明，我们得出：如果 $a$ 中每种数字与其他数字的相对位置与 $b$ 中每种数字与其他数字的相对位置相同，则能。反之则不能。

这一点也很好证明。

如果 $a$ 与 $b$ 初始状态就相同，那么 ~~结案~~ 肯定能操作。

如果 $a$ 与 $b$ 初始状态不同且每种数字与其他数字的相对位置在 $a$ 和 $b$ 中均相同，那么就肯定有数字多了，有数字少了。那么我们就可以让多了的数字（我们假定它为 $i$）后面的数字“侵占”$i$ 的位置，让 $i$ 的数量与 $b$ 中 $i$ 的数量相同，然后不断重复这个操作。这个操作就像推箱子，$i$ 多了，多出来的位置就相当于空位，有空位我们就可以慢慢地、一步一步的把箱子往前移，直到变成 $b$。

如果存在 $a$ 中某种数字与其他数字的相对位置与 $b$ 中的不同的情况，那么经过模拟，我们发现，除非让某些（种）数字全部消失，否则不可能让相对位置变成正确的。

例如 $[a_1,b_1,b_2,c_1,d_1,d_2,d_3,e_1,e_2]$序列中，我们要让数字 $b$ 出现在 $d$ 后面，考虑环形结构，我们就要覆盖 $a_1,e_2,e_1$ 这三个数字才行。如果这些数字是 $b$ 中没有的，那么可以进行操作。但是这种情况（即“$a$ 中含有的数字恰好与 $b$ 中的数字相同”）保证每种数字都有用，那么就不能进行操作了。

## 代码实现

我们将 $a$ 复制一遍接在 $a$ 末尾（这是处理环形问题的基本套路了）。把 $a$，$b$ 去重储存在数组 $ta,tb$ 中。注意，如果原数组的首位字符相同，则忽略末尾的数字。

首先判断是否“ $a$ 中缺少 $b$ 中的任意数字”。若否，则继续，去掉 $a$ 中多余的数字（即 $b$ 中没有的数字种类），枚举环 $a$ 的起点，与 $b$ 进行逐一比对。

如果满足要求，我们还需要检查一下 $a$ 中每种数字的个数。若每一种数字都只有一个，但位置和 $b$ 却是错位的，这种情况也不能操作（就相当于推箱子时缺少了最初的空位）。

## Code

```C++
/*////////ACACACACACACAC///////////
       . Coding by Ntsc .
       . ToFind Chargcy .
       . Prove Yourself .
/*////////ACACACACACACAC///////////

#include<bits/stdc++.h>
#define ll long long
#define db double
#define rtn return
#define i1n int i=1;i<=n;i++
#define in1 int i=n;i>=1;i--
using namespace std;

const int N=2e5+5;
const int M=1e5;
const int Mod=1e5;
const int INF=1e5;

int t,n,a[N],b[N],ta[N],flg,tb[N];

bool judge(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++)scanf("%d",&a[i]),a[i+n]=a[i];
	for(int i=1;i<=n;i++)scanf("%d",&b[i]);
	int na=0,nb=0;//记录去重后的数字个数
	for(int i=1;i<=n;i++)if(a[i]!=a[i%n+1])ta[++na]=a[i];//去重并处理环形
	for(int i=1;i<=n;i++)if(b[i]!=b[i%n+1])tb[++nb]=b[i];
	if(!na)ta[++na]=a[1];
	if(!nb)tb[++nb]=b[1];
	if(na==n&&nb==n){//说明每个数字都恰好只有一个(特判:每一种数字都只有一个，但位置和b却是错位的)
		for(int i=1;i<=n;i++)
			if(a[i]!=b[i])return 0;
		return 1;
	}
	for(int i=1;i<=na;i++){
		int idb=1;
		for(int j=0;j<na;j++){
			int ida;
			if((i+j)%na)ida=(i+j)%na;//处理环形
			else ida=na;	
			if(ta[ida]==tb[idb])idb++;
		}
		if(idb>nb)return 1;
	}
	return 0;
		
}

signed main(){
	cin>>t;
	while(t--){
		if(!judge())cout<<"No\n";
		else cout<<"Yes\n";
	}
	return 0;
}

```


