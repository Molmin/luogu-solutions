## 题解 P2338
其实这是一道数学题&模拟题，想到怎么去做就很简单了（那肯定的）

让我们来看一下这道题

仔细发现，($1<=n<=10000$)

知道$O(n^2)$的算法应该过不了

QwQ我太菜了，$O(n^2)$都不会敲

---------------------------------------------------我是~~超级可爱的~~分割线----------------------------------------------------

注：D表示D x存下来的数组，T表示T x存下来的数组

我们可以for循环一遍他某个时间变换速度的情况，然后用一个指针从D数组开始往右移，并且不停更改从当前这个D是否在T后面，代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=10009;
int a[N],b[N],n,m;

int main()
{
	char ch;
	int T;
	cin>>T;
	while(T--)
	{
		cin>>ch;
		if(ch=='T') scanf("%d",&a[++n]);
		if(ch=='D') scanf("%d",&b[++m]);
	}
	sort(a+1,a+n+1); //按时间排序 
	sort(b+1,b+m+1); //按距离排序 
	double s=0,t=0;
	int j=1,sp=1;
	for(int i=1;i<=n;i++)
	{
		double tmp=s+(a[i]-t)*1.0/sp; //统计当前所在时间到a[i]这个时间所走到的位置 
		while(b[j]<tmp && j<=m) t+=(b[j]-s)*sp,sp++,s=b[j++],tmp=s+(a[i]-t)*1.0/sp; //不停更新从b[i]这个位置的时间点开始到a[i]所走到的位置 
		s+=(a[i]-t)*1.0/sp,t=a[i],sp++; //到a[i]时刻 
	}
	while(j<=m) t+=(b[j]-s)*sp,s=b[j++],sp++; //把最后还未统计完的距离加入 
	if(s<1000) t+=(1000-s)*sp; //如果仍然未到终点，就走到终点 
	printf("%.0lf\n",t); //四舍五入输出答案 
	return 0;
}
```
