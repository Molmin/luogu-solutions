### 贪心

对于第一棵树，砍了倒左边。其他的尽量倒左边，否则倒右边。

两边都不行再不砍。

证明：

对于第一棵树，很显然要倒左边。因为如果倒右边可能会对第二棵树有负面影响，如果不砍，那么对于第二棵树的影响和砍一样，但是不会的砍树总数。

对于第$i$颗数，如果能够倒左边（和第$i-1$颗砍倒后不会冲突），肯定倒左边，因为如果倒右边可能会对第$i+1$课带来负面影响，如果不砍不会增加总数。

如果不能倒左边，那么看是否能倒右边。如果能倒右边就倒右边。

因为如果能倒右边，不外两种情况。

1）倒右边后和下一颗倒左边不冲突。

这样很显然要倒右边，因为如果倒右边不会对下一颗造成负面影响。

2）倒右边后和下一颗倒左边会冲突。

这种情况依然要倒右边。因为我们现在讨论的只是不能倒左边的情况。那么如果倒右边，总数会加$1$，但是下一颗不能倒左边。如果这颗不砍，下一颗倒左边的话，总数仍然会加$1$，所以是一样的。但是为了程序简便，所以倒右边。

AC $1.26s$，暂居rk2。


代码：
```cpp

#include <stdio.h>
int x[100005],h[100005];
inline int read()
{
	int ans = 0;
	char ch = getchar();
	while(ch<'0'||ch>'9') ch = getchar();
	while(ch>='0'&&ch<='9')
	{
		// ans = ans * 10 + ch - '0';
		ans = (ans<<1) + (ans<<3) + (ch^48);
		ch = getchar();
	}
	return ans;
}
void write(int x)
{
	if(x>9)
	{
		write(x/10);
	}
	putchar(x%10 + '0');
}	
int main()
{
	int n = read();
	int tot = 1; //第一棵树向左、
	for(register int i=1;i<=n;i++) x[i]=read(),h[i]=read();
	int pre = 0; //记录上一棵树向右的高度。
	x[n+1] = 2e9+10;
	for(register int i=2;i<=n;i++)
	{
		if(x[i-1]+pre < x[i]-h[i]) //当前树向左
		{
			pre=0,++tot;
		}
		else if(x[i]+h[i]<x[i+1]) //当前树向右
		{
			pre = h[i],++tot;
		}
		else	//不砍
			pre = 0;
	}
	write(tot);
}

```