###### 注：本篇题解较细致讲解，新手向

从某贪心题单来到这，感觉这是一道$dp$ ，但还是忍住打了贪心。

讲一下贪心的思路：

每棵树都有两种情况，向左或向右，显然这是对称的，所以我们从一边过去考虑即可。这里我从左边开始考虑（显然这符合一般人的逻辑）。若从左边考虑，分两种情况：

- 向左倒可行，那么往左倒一定是最优的，不会干扰后续树的选择。

- 向左不可行，此时看看向右是否可行，若可行，又分两种

 	
    - 自己向右倒	
   - 自己右边那棵向左倒
 	- 这两种若不冲突，那是最好，若冲突，两者取一对后续选择还是没有干扰，所以随便选一个（这里为了方便选自己向右倒），之后再移到下一棵树进行判断。
 
注意点：

- 第一棵和最后一棵显然向两边倒

- 为了后续操作的的连贯性，向右倒时可以将树的坐标向右移，向左倒就不用管他。

代码：

~~~cpp
#include<bits/stdc++.h>
using namespace std;
int loc[100005],tree[100005];
int main(){
	int n;cin>>n;
	for(int i=1;i<=n;++i){	
		scanf("%d%d",&loc[i],&tree[i]);
	}
	int sum=2;
	for(int i=2;i<n;++i){
		if(loc[i]-tree[i]>loc[i-1]) ++sum;
		else if(loc[i]+tree[i]<loc[i+1]) ++sum,loc[i]+=tree[i];
	}
	int ans=n==1?1:sum;
	printf("%d",ans);
} 
~~~

