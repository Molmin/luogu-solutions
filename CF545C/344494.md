本题纯贪心

[题目传送门](https://www.luogu.com.cn/problem/CF545C)

# 分析

这题先判断是否一棵树，如果是一棵树就输出一（WA了两遍！！！）。

```c
if(n==1){
	printf("1");
	return 0;
}
```
然后，最左边的树让它倒向左边，最右边的树让它倒向右边，这样可以保证这两棵树不干涉其他的树。所以输出时答案加二。
```c
printf("%d",ans+2);
```
最后，贪心的过程：尽量都往左边倒。

### 证明如下：

**反证法**：若一棵树往左倒之后比往右倒的树木少，那么他的最优解一定是往右倒。此时有两种情况：

(1)右边的树比左边的矮，那么他们都往左倒比向右倒更优，矛盾。

(2)右边的树比左边的树高，那么左边的树往左不比往右差，矛盾。

证毕。

按照往左倒优先的顺序做完贪心即可。

```c
for(int i=2;i<=n-1;i++){
	if(num[i]-h[i]>num[i-1])ans++;
	else if(num[i]+h[i]<num[i+1]){
		ans++;
		num[i]+=h[i];
	}
}
```