### 矩阵快速幂的好题!

先讲点前置的知识

首先，矩阵是个好东西。

什么是矩阵呢？

矩阵顾名思义，是一个矩形的数阵，如下，是一个2×3的矩阵

| 3 | 1 | 4 |
| - | - | - |
| 5 | 2 | 9 |

#### 矩阵的运算法则

矩阵加法：当两个矩阵的行数与列数相同时，两个矩阵可以相加，相加后的矩阵的行数和列数等于原矩阵的行数和列数，每个元素则是原来两个矩阵中对应元素之和。

但是这个我们用不上，我们要用矩阵乘法，如下

矩阵乘法：当一个矩阵的行数和另一个矩阵的列数相等时两个矩阵可以相乘，即一个$n×m$的矩阵$A$可以和一个$m×q$的矩阵$B$相乘，相乘后是一个$n×q$的矩阵$C$。这个矩阵的$AC_{i,j}$是第一个矩阵的第i行的每一个元素与第二个矩阵第j行的对应每一个元素相乘后相加结果。

举个栗子

| 1 | 0 |
| -----------: | -----------: |
| 0 | 1 |
| 1 | 1 |

与

| 0 | 1 | 1 |
| -----------: | -----------: | -----------: |
| 1 | 0 | 0 |

相乘

那么新矩阵规模是2×2，下面每个元素来逐步运算。

$C_{1,1}=A_{1,1}×B_{1,1}+A_{2,1}×B_{1,2}+A_{3,1}×B_{1,3}=1$

$C_{1,2}=A_{1,2}×B_{1,1}+A_{2,2}×B_{1,2}+A_{3,2}×B_{1,3}=2$

剩下两个我就不推了(~~因为我太懒了~~)

整个矩阵如下

| 1 | 2 |
| -----------: | -----------: |
| 1 | 0 |

那么矩阵乘法有什么用呢？用C++如何实现呢

我们可以将它作为数字转换的工具

像这道题说的那样，我们可以根据题意构造出一个矩阵对数列进行乘法操作从而变换，例如

数列$[1,2,3]$想将每个数字向前移动一格，怎么办？

这里先引入一个知识点：单位矩阵

单位矩阵就是一个除了对角线是1，其他地方都是0的方阵(行数和列数相等的矩阵)，相当于乘法中的1

比方说，我们的数列$[1,2,3]$乘以它的单位矩阵

```
1 0 0
0 1 0
0 0 1

```

之后，还是它本身

那么把它往前移一位呢？

那么我们将它的单位矩阵每一列向前移一位即可，这样矩阵变成

```
0 0 1
1 0 0
0 1 0
```

乘起来就可以将我们的数列转换成$[2,3,1]$了

同样的，我们向将$A_s,A_m$交换，将单位矩阵中的两列交换即可。

矩阵乘法是符合结合律不符合交换律的，因此将得出的两个矩阵乘起来再计算k次，用初始数列乘以这个结果，答案就出来了！

构造一个转换数列的矩阵是很重要的问题

矩阵相乘代码实现

```cpp
//c++
struct _jz//矩阵结构体
{
	long long a[81][81];
};
_jz cheng(_jz a,_jz b)
{
	_jz c={};答案矩阵
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=n;j++)
		{
			for(int k=1;k<=n;k++)//A矩阵的第i行与B矩阵的第j列相乘(反过来也可以)
			{
				c.a[i][j]+=a.a[i][k]*b.a[k][j];
			}
		}
	}
	return c; 
}
```


#### 快速幂

知道了矩阵乘法，那么我们需要进行幂运算，C++有个自带函数`pow(a,b)`计算a的b次方，但是这个太慢且容易溢出，那么我们自己来写一个快一点的呢？

暴力算法处理如下

```cpp
int pow_1(int a,int b)
{
	int c=1;
	while(b>0)
	{
		c*=a;
		b--;
	}
	return c;
}
```

那么这个算法运行速度是$O(n)$，当题目的数据范围一旦很大的时候就会超时

有更快的吗？

有

计算$2^{10}$

暴力算法算10次

那么如果我们算$4^5$呢？

只用6次(还有一次先将$2^10$处理成$4^5$)

按照这种思路继续分解，再算下去，诶？5除不尽2？！

怎么办？那么此时我们将5变成4，再将此时的底数4乘入答案，再次进行运算

接下来变成了$16^2$

再接下来试$256^1$，此时又是奇数幂，那么我们再次将256乘入答案，接下来，指数变成0了，运算完成，结果也是1024，共运算了5次，这个算法复杂度是$O(logn)$，在数字非常大时非常有用，为什么这个算法正确？

比方说计算$3^7$

那么我们将这个指数看成二进制

`1 1 1`

现在应该部分读者已经明白了，每次指数除以二的操作其实就是在二进制下向前移一位，我们每次将底数乘2就是将指数的平方转移到底数上，这也是相当于将指数除以二(自行搜索 初二 幂运算)。

有的时候运算需要取模，那么边取模边乘即可。

矩阵快速幂与数字快速幂相同

快速幂模板

```cpp
//c++
#define mod 1000000009
int pow_2(int a,int b)
{
	int ans=1;
	while(b>0)
	{
		if(b&1)
		{
			ans*=a;
			ans%=mod;
		}
		b/=2;
		a*=a;
		a%=mod;
	}
	return ans;
}
```

那么我们整个题目的代码也出来了，如下

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,s,m,k;//如题
struct _jz//矩阵结构体
{
	long long a[81][81];
};
_jz d1,d2,d3,ans;//前移矩阵，交换矩阵，两个矩阵乘起来，以及答案矩阵（虽然是数列，但这样可以方便一些，其他的地方是0，乘了不会增加）
_jz cheng(_jz a,_jz b)//矩阵乘法
{
	_jz c={};
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=n;j++)
		{
			for(int k=1;k<=n;k++)
			{
				c.a[i][j]+=a.a[i][k]*b.a[k][j];
			}
		}
	}
	return c; 
}//矩阵乘法
void ksm(long long z,_jz sss)
{
	if(z==0)return;
	if(z&1)
	{
		ans=cheng(ans,sss);
	}
	sss=cheng(sss,sss);
	z/=2;
	ksm(z,sss);
 }//递归快速幂(递归快速幂第一人)
int main()
{
	cin>>n>>m>>s>>k;//输入
	for(int i=2;i<=n;i++)
	{
		d1.a[i][i-1]=1;
	}
	d1.a[1][n]=1;//构造转换矩阵
	for(int i=1;i<=n;i++)
	{
		d2.a[i][i]=1;	
	}
	d2.a[s][s]=0;
	d2.a[m][m]=0;
	d2.a[s][m]=1;
	d2.a[m][s]=1;//构造交换矩阵
	d3=cheng(d2,d1);//相乘
	for(int i=1;i<=n;i++)
	{
		cin>>ans.a[1][i];//输入
	}
	ksm(k,d3);
	for(int i=1;i<=n;i++)cout<<ans.a[1][i]<<" ";//输出
}
```

#### 题解千万条，理解第一条。无脑抄题解，棕名两行泪。

如有不足之处请指出，感谢。