这是本蒟蒻的第一篇题解。

如有错误，请各位大牛提出。（不喜勿喷）
## 题意
 - 求在长度为 $K$ 的子串中所有数的和。
 - $a_i$ 有可能是负数。
 - $N≤5×10^5$，数组不要开小了。

------------
## 样例说明
样例如下：

```cpp
6 3

2 0 2 -1 0 -4
```

也就是说 $N = 6$， $K = 3$，所以总共要求 $6 - 3 + 1$ 次子串和。

经过我们口算可得 
$2 + 0 + 2 = 4$，
$0 + 2 + (-1) = 1$，
$(-1) + 0 + (-4) = (-5)$，

所以输出 $4$、$1$、$1$ 和 $-5$。


------------
## 思路
这道题我们可以运用前缀和的思想。

首先我们要开一个存答案的数组 $b$，然后计算 $b_1$。
```cpp
for(int i = 1; i <= k; i++)
        b[1] += a[i];
```
接下来就是核心部分：

从 $b_2$ 开始，每一组的结果都可以简化为：

删去上一组的第一个数，加上上一组的下一个数，即  $b_N$ = $b_{N-1}$  -  $a_{N-1}$ +  $a_{N+K-1}$。

代码如下：
```cpp
for(int i = 2; i <= n-k+1;i++)
        b[i] = b[i-1] - a[i-1] + a[i+k-1];
```
## AC代码
接下来，本蒟蒻将会双手奉上AC代码。
```cpp
#include <bits/stdc++.h>
typedef long long ll;
int a[500005];
ll b[500001];
int n, k;
int main()
{
    scanf("%d%d",&n,&k);
    for(int i = 1; i <= n; i++)
        scanf("%d",&a[i]);
    for(int i = 1; i <= k; i++)
        b[1] += a[i];
    for(int i = 2; i <= n-k+1;i++)
        b[i] = b[i-1] - a[i-1] + a[i+k-1];
    for(int i = 1; i <= n-k+1; i++)
        printf("%lld\n",b[i]);
    return 0;
}
```  
感谢各位阅读本蒟蒻的第一篇题解。



