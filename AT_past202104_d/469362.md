这是本蒟蒻的第 $2$ 篇题解，AT_past202104_d。

本题用普通的方法比较麻烦，这里介绍一种算法——前缀和。

算法的定义简单的要死，就是一个数组 $a$，像阶梯一样输入的过程中计算 $a_1, a_1+a_2, \cdots, a_1+a_2+\cdots+a_n$。算法的实现就不用我说了吧。建立另一个数组 $s$，每一次 $s_i=s_{i-1}+a_i$，这么简单。和它相似的还有差分。

然后怎么使用？想要计算某一段的和，比如计算 $a_l+a_{l+1}+\cdots+a_r$，就可以直接通过 $s_r-s_{l-1}$ 来获得，大大减少了重复运算的效率，这种问题也被称作 RMJ 问题（重复贡献问题），至于为什么是 $l-1$ 而不是 $l$，想想都知道。

然后说本题。稍微看一下样例就会发现什么 $n-k+1$ 啊，$i+k-1$ 啊，都是形式化忽悠人玩的。看看题目名称，即使不会日本語也知道，这是一道求一个数列中连续 $k$ 项的和的问题。就是 $a_i+a_{i+1}+\cdots+a_{i+k-1}$。

嗯，然后问题就变成了一个 `for` 循环 $i=k \sim n$（这个不用我过多解释了吧），每一次输出 $s_i-s_{i-k}$（$i-k$ 也不用我说了吧）换行即可。

**另外，前缀和数组需要开 `long long`**！！！！！！！！！坑死人了。

好了好了上代码力。

```cpp
#include <bits/stdc++.h>
using namespace std;

int n, k, a;
const int maxn=5e5+1;
long long qzh[maxn];

int main(){
    cin>>n>>k;
    for (int i=1; i<=n; i++) cin>>a, qzh[i]=qzh[i-1]+a; // 你甚至输入可以通过变量完成！
    for (int i=k; i<=n; i++) cout<<qzh[i]-qzh[i-k]<<endl;
    return 0;
}
```

谢谢大家。