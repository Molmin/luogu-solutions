题意：给定一个长度为 $n$ 的序列和两种操作，求将序列所有项变为 $0$ 的最小操作次数。两种操作是：
- 改变 $a_1$
- 在 $a_1\sim a_{i-1}$ 为 $0$ ， $a_i$ 为 $1$ 时改变 $a_{i+1}$ 

核心思想：递推

解：

令 $f(n)$ 为改变 $n-1$ 个 $0$ 后的一个状态的最小操作数（如 $f(4)=0000\leftrightarrow 0001$ ）， $g(i)$ 为将给定序列的前 $i$ 项变为全 $0$ 的最小操作数。

易知 $f(1)=1$ 且 $\forall i>1,\:f(i)=2f(i-1)+1$ （先把第 $i-1$ 位变成 $1$ ，花一步把第 $i$ 位变成 $0$ ，再把第 $i-1$ 位变回 $0$ ），故 $f(i)=2^i-1$ 。

又可知有 $g(1)=a_1$ ，分类讨论递推方式：
1. 若 $a_i=0$ ，显然有 $g(i)=g(i-1)$ ；
2. 若 $a_i=a_{i-1}=1$ ，有 $g(i)=g(i-2)+1+f(i-1)=g(i-2)+2^{i-1}$ （先变成只有最后两位 $1$ ，再花费 $1+f(i-1)$ 步变成全 $0$ ）；
3. 若 $a_i=1$ 且 $a_{i-1}=0$ ，由于 $0\rightarrow 1$ 和 $1\rightarrow 0$ 在最后一位上是等价的，可以构造序列 $b_i$ 在且仅在 $i-1$ 项与 $a_i$ 相异。则也有 $g_a(i)=g_b(i-1)+1+f(i-1)=g_a(i-2)+2^{i-1}$ （因为 $b_{i-1}=0$ ， $g_b(i-1)=g_b(i-2)=g_a(i-2)$ ）。

对 $a_{i-2}$ 分类讨论可证对于所有序列，都有 $g_a(i-1)+g_b(i-1)=2^{i-1}-1$ ， $g_a(i)=2^{i-1}-1-g_a(i-2)+2^{i-1}=2^i-1-g_a(i-1)$ 。

用任一个递推式解均可。需要高精。

代码：
```
#include <bits/stdc++.h>
using namespace std;
int n, s[1001], a[1001][1001], pw[1001], flag;
int main()
{
	cin>>n;
	for(int i=1; i<=n; i++)
		cin>>s[i];
	if(s[1]==1)
		a[1][0]=1;//初始值
	pw[0]=1;
	for(int i=2; i<=n; i++)
	{
		for(int j=0; j<=1000; j++)
			pw[j]*=2;
		for(int j=0; j<=1000; j++)
		{
			pw[j+1]+=pw[j]/10;
			pw[j]%=10;
		}//计算2的幂
		if(s[i]==0)
			for(int j=0; j<=1000; j++)
				a[i][j]=a[i-1][j];//项为0
		else if(s[i-1]==1)
		{
			for(int j=0; j<=1000; j++)
				a[i][j]=a[i-2][j]+pw[j];
			for(int j=0; j<=1000; j++)
			{
				a[i][j+1]+=a[i][j]/10;
				a[i][j]%=10;
			}
		}//第一个递推式
		else
		{
			for(int j=0; j<=1000; j++)
				a[i][j]=pw[j]*2-a[i-1][j];
			a[i][0]--;
			for(int j=0; j<=1000; j++)
			{
				if(a[i][j]<0)
				{
					a[i][j+1]+=a[i][j]/10-1;
					a[i][j]=a[i][j]%10+10;
				}
				a[i][j+1]+=a[i][j]/10;
				a[i][j]%=10;
			}
		}//第二个递推式
	}
	for(int i=1000; i>=0; i--)
	{
		if(a[n][i]!=0)
			flag=1;
		if(flag==1)
			cout<<a[n][i];
	}//输出
	return 0;
}
```

