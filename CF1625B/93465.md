先考虑两个相等的数 $a_i,a_j(1\le i<j\le n)$ ，再确定怎么以此为基础选出两个段。

除了 $a_i=a_j$ 外并没有元素值方面的限制，因此我们可以让两个段分别以 $a_i,a_j$ 为原点，向左右两端延长，只要保证下标不越界即可。

当第一段的左半部分是 $a_1\sim a_i$ ，第二段的右半部分是 $a_j\sim a_n$ 时，显然两段的长度取到极大值，为 $i+n-j$ 。

要使 $i+n-j$ 最大，也就是 $j-i$ 最小。  
其实就是找位置最接近的相等元素。

下面给出核心代码

```cpp
    scanf("%d",&n),ans=-1;
    for (int i=1; i<=n; ++i) {
        scanf("%d",a+i);
        if (v[a[i]]) ans=max(ans,v[a[i]]+n-i);
        v[a[i]]=i;
    }
    for (int i=1; i<=n; ++i) v[a[i]]=0;
    printf("%d\n",ans);
```