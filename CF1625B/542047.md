### 思路

请注意：对于每一对最佳的字符串，正确的和谐字符串确实以最后一个字符结尾。

证明：假设它是错的。然后，我们可以将字符串向右扩展一个字符，它们将保持和谐。

现在，证明下面的陈述，这将帮助我们解决这个问题：如果答案是 $n-\min(v-u)$，其中最小值是所有 $u$ 和 $v$，这样 $u<v$ 以及 $a_u=a_v$。

证明：考虑两个元素 $u$ 和 $v$。这样的话，$u<v$，$a_u=a_v$。假设它们在一对和谐子串中处于相同位置，那这些子串的最大长度是多少？

通过上面的证明，我们知道可以将字符串向右展开。我们取以 $u$ 开头的第一个字符串和以 $v$ 开头的第二个字符串。在进行展开操作以后，我们得到的是长度为 $n-v+1$ 的串。

不过，这还不够。因此，我们也将字符串从左侧展开。展开后，字符串的长度将变为 $n-v+u$，做个幼儿园数学计算后，得到 $n-(v-u)$。$v-u$ 越小，长度越大。

为了解决这个问题，我们需要找到一对最近的相等元素。我们可以执行以下操作：存储每个元素的所有位置（即 $a_i=1$，$a_i=2$ 等的所有位置），然后我们在 $a_i$ 的基础上迭代，并检查相邻位置对并计算最小值，答案就出来了。

### 代码

看似很难，但是我们前面的一步步推算都是为了后面的结论。代码很简单：
```python
def solve():
    n = int(input())
    a = [int(x) for x in input().split()]
    pos = {}
    ans = -1
    for i in range(n):
        if a[i] in pos:
            ans = max(ans, pos[a[i]] + 1 + (n - 1 - i))
        pos[a[i]] = i
    print(ans)
for _ in range(int(input())):
    solve()
```
没错，结束了！