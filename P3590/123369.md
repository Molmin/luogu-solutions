这里是**有正确性证明**的**复杂度正确**的线性做法。

------------

考虑钦定右端点为 $r$。这时，考虑左端点。

如果长度为 $r$ 的前缀中三种字符出现次数各自不同则显然不用管。

否则，如果三种字符出现次数都相同，则我们可以把左端点 $l$ 由 $1$ 移到 $2$，这样三种字符出现次数就不都相同了。

则此时应该有两种字符出现次数相同。考虑找到这两种字符中任何一个出现的最前位置，并将 $l$ 移至其后一格处。

假如此时三种字符出现次数都不同，则显然合法。否则，则又有两种字符相同，需要重新开始检索。

显然我们没有余裕去一直执行这样的检索。考虑每次检索后，得到的态必然是两个字符出现次数相同且第三个字符出现次数是上述次数加减一，不然把 $l$ 回移一步就无法得到一个不同的两个字符出现次数相同的态。

我们存在将 $r$ 右移一格以及左移一格的选项。明显如果某次检索失败，则下次检索必然至少会使得区间长度减小一，故无论是左移还是右移只要成功就一定不更劣。左移在 $r=1$ 时不合法，但明显 $r=1$ 时能贡献的长度至多为 $1$，故不用考虑；右移在 $r=n$ 时不合法，但是对于 $r=n$ 时就算不断检索复杂度也可以承受，故亦不用考虑。

相邻两次检索时，出现次数相同的两个字符必然在两次检索中不完全相同——这是显然的。

若存在两次检索，其中第三个字符出现次数都为前两个字符出现次数减一，且前两个字符在两次检索中不完全相同。不妨设第一次检索时 $a,b$ 相同，而后一次检索时 $a,c$ 相同。假如右移会使 $a,b$ 之一出现次数增加，则只需在第一次检索时右移 $r$ 即可；否则，则右移会使 $c$ 增加，则只需在第二次检索时右移 $r$ 即可。

同理，若存在两次不同检索，其中第三个字符出现次数为前两个字符加一，则上述分析对左移 $r$ 类似生效，也不用考虑。

则依据上述分类讨论，我们无法处理的就仅有如下一种情形：第一次检索，$a,b$ 相同，$c$ 等于其加一；第二次检索，$a,c$ 相同，$b$ 等于其减一，其后的检索不断重复这一流程。或者与之相反，即第一次检索中是减一，第二次检索中是加一。

注意到这种流程仅限于连续的 `BCSBCSBCS` 串间。于是我们预处理一下，假如检索到了连续的 `BCS` 段，则跳过整段。这样，有效检索次数就只是常数的。

对于每个 $r$，检索次数都是常数次的，而 $r=n$ 特别地需要额外 $O(n)$ 次检索，故共计 $O(n)$ 次检索。检索的复杂度用子序列自动姬即可做到常数，验证区间合法与否的复杂度也可用前缀和做到常数，故总复杂度线性。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,nex[1001000][3],sum[1001000][3],mx;
char s[1001000];
bool chevalid(int l,int r){
	if(l>r)return true;
	int a0=sum[r][0]-sum[l-1][0],a1=sum[r][1]-sum[l-1][1],a2=sum[r][2]-sum[l-1][2];
	if(a0==a1||a1==a2||a2==a0)return false;
	mx=max(mx,r-l+1);return true;
}
int main(){
	scanf("%d%s",&n,s+1);
	for(int i=1;i<=n;i++){
		if(s[i]=='B')s[i]=0;
		if(s[i]=='C')s[i]=1;
		if(s[i]=='S')s[i]=2;
	}
	for(int j=0;j<3;j++)nex[n][j]=n+1;
	for(int i=n-1;i>=0;i--){
		for(int j=0;j<3;j++)nex[i][j]=nex[i+1][j];
		nex[i][s[i+1]]=i+1;
	}
	for(int i=1;i<=n;i++){
		for(int j=0;j<3;j++)sum[i][j]=sum[i-1][j];
		sum[i][s[i]]++;
	}
	for(int r=1;r<=n;r++){
		int l=1;
		if(chevalid(l,r))continue;
		if(sum[r][0]==sum[r][1]&&sum[r][1]==sum[r][2])l++;
		while(l<=r){
			int a0=sum[r][0]-sum[l-1][0],a1=sum[r][1]-sum[l-1][1],a2=sum[r][2]-sum[l-1][2];
			if(a0==a1)l=min(nex[l-1][0],nex[l-1][1])+1;
			if(a1==a2)l=min(nex[l-1][1],nex[l-1][2])+1;
			if(a0==a2)l=min(nex[l-1][0],nex[l-1][2])+1;
			if(l>r)break;
			if(r!=n&&chevalid(l,r+1))break;
			if(chevalid(l,r))break;
			if(chevalid(l,r-1))break;
		}
	}
	for(int l=1,r=1;l<=n;l=r){
		while(r<=n&&s[l]==s[r])r++;
		mx=max(mx,r-l);
	}
	printf("%d\n",mx);
	return 0;
}
```