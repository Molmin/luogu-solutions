因为每个数字左上角都是`#`，所以可以从左到右，从上到下枚举图上每个点，如果是`#`号就用1-9的模型覆盖，覆盖成功就把数字用`.`覆盖掉。

上代码
```
#include <iostream>
using namespace std;
char m[20][100010];
//打数字表
char num[10][5][3]={
{
'#','#','#',
'#','.','#',
'#','.','#',
'#','.','#',
'#','#','#'
},
{//1的图形只用到前两列，为防把0，8误判成1，在右边多加一列小数点
'#','.',' ',
'#','.',' ',
'#','.',' ',
'#','.',' ',
'#','.',' ',
},
{
'#','#','#',
'.','.','#',
'#','#','#',
'#','.','.',
'#','#','#'
},
{
'#','#','#',
'.','.','#',
'#','#','#',
'.','.','#',
'#','#','#'
},
{
'#','.','#',
'#','.','#',
'#','#','#',
'.','.','#',
'.','.','#'
},
{
'#','#','#',
'#','.','.',
'#','#','#',
'.','.','#',
'#','#','#'
},
{
'#','#','#',
'#','.','.',
'#','#','#',
'#','.','#',
'#','#','#'
},
{
'#','#','#',
'.','.','#',
'.','.','#',
'.','.','#',
'.','.','#'
},
{
'#','#','#',
'#','.','#',
'#','#','#',
'#','.','#',
'#','#','#'
},
{
'#','#','#',
'#','.','#',
'#','#','#',
'.','.','#',
'#','#','#'
}
};
void fg(int x,int y)//覆盖
{
	bool yes;
	for(int kk=0;kk<=9;kk++)//枚举数字
	if(kk==1)//特判1
	{
	  yes=1;
	  for(int ii=0;ii<=4;ii++)
	    for(int jj=0;jj<=1;jj++)
	      if(m[x+ii][y+jj]!=num[kk][ii][jj]) 
	      yes=0;
	  if(yes==1) //覆盖成功，用.填掉四格
	  {
	  	cout<<kk;
	  	for(int iii=x;iii<=x+4;iii++)
	  	  m[iii][y]='.';
	  	return;
	  }
	  }
	else//其他数字同理
	{
	  yes=1;
	  for(int ii=0;ii<=4;ii++)
	    for(int jj=0;jj<=2;jj++)
	      if(m[x+ii][y+jj]!=num[kk][ii][jj]) 
	      yes=0;
	  if(yes==1) 
	  {
	  	cout<<kk;
	  	for(int iii=x;iii<=x+4;iii++)
	  	  for(int jjj=y;jjj<=y+2;jjj++)
	  	  m[iii][jjj]='.';
	  	return;
	  }
	 }   
	 return;
}
int main()
{
	int a,b;
	cin>>a>>b;
    //为判出最右边的1，在右边加一列小数点
	for(int i=0;i<=a;i++)
	  m[i][b+1]='.';
	for(int i=1;i<=a;i++)
	  for(int j=1;j<=b;j++)
	    cin>>m[i][j];
	for(int j=0;j<=b;j++)
	   for(int i=1;i<=a;i++)
        if(m[i][j]=='#')
        {fg(i,j);continue;}//小优化
	return 0;
 } 
 ```