# 看到各位大佬的暴力手法，我也来写一个不一样的暴力。
我的不一样在于：我用了一个 $for$ 循环，对每一个数字直接进行 $if$ 语句判断是否满足，然后如果满足就 $ans$ 加上这个对应的数字（$ans$ 是字符串）。代码自我感觉~~简单清晰易懂~~良好（其实只要找到 $#$ 后就调用函数就好）。

具体请看代码（全注释AC）：
```cpp
#include<iostream>
#include<cstring>
using namespace std;
string ans="";//定义ans为空（初始化）
int n,m,k[10]={8,6,9,3,2,0,5,7,4,1};//这个顺序是因为如果直接按0-9判断的话，满足8的格子会先满足2的情况，所以要改变顺序
char a[11][100005]={0};//初始化 
void dfs(int x,int y)
{
    for(int i=0;i<=9;i++)
    {
        switch(k[i])//注意我的判断顺序
        {
            case 1://如果是一，判断下面四个是否为‘#’
                if(a[x+1][y]=='#'&&a[x+2][y]=='#'&&a[x+3][y]=='#'&&a[x+4][y]=='#')
				{
                			ans+="1";//如果满足这种情况，ans加上一个"1" 
                			return;
				}
                break;
            case 2://二的情况，方法同上
                if(a[x][y+1]=='#'&&a[x][y+2]=='#'&&a[x+1][y+2]=='#'&&a[x+2][y]=='#'&&a[x+2][y+1]=='#'&&a[x+2][y+2]=='#'&&a[x+3][y]=='#'&&a[x+4][y]=='#'&&a[x+4][y+1]=='#'&&a[x+4][y+2]=='#')
				{
                			ans+="2";//如果满足这种情况，ans加上一个"2"
                			return;
				}
                break;
            case 3://三的情况，方法同上
                if(a[x][y+1]=='#'&&a[x][y+2]=='#'&&a[x+1][y+2]=='#'&&a[x+2][y]=='#'&&a[x+2][y+1]=='#'&&a[x+2][y+2]=='#'&&a[x+3][y+2]=='#'&&a[x+4][y]=='#'&&a[x+4][y+1]=='#'&&a[x+4][y+2]=='#')
				{
                			ans+="3";//如果满足这种情况，ans加上一个"3"
                			return;
				}
                break;
            case 4://四的情况，方法同上
                if(a[x][y+2]=='#'&&a[x+1][y]=='#'&&a[x+1][y+2]=='#'&&a[x+2][y]=='#'&&a[x+2][y+1]=='#'&&a[x+2][y+2]=='#'&&a[x+3][y+2]=='#'&&a[x+4][y+2]=='#')
				{
                			ans+="4";//如果满足这种情况，ans加上一个"4"
                			return;
				}
                break;
            case 5://五的情况，方法同上
                if(a[x][y+1]=='#'&&a[x][y+2]=='#'&&a[x+1][y]=='#'&&a[x+2][y]=='#'&&a[x+2][y+1]=='#'&&a[x+2][y+2]=='#'&&a[x+3][y+2]=='#'&&a[x+4][y]=='#'&&a[x+4][y+1]=='#'&&a[x+4][y+2]=='#')
				{
                			ans+="5";//如果满足这种情况，ans加上一个"5"
                			return;
				}
                break;
            case 6://六的情况，方法同上
                if(a[x+1][y]=='#'&&a[x+2][y]=='#'&&a[x+3][y]=='#'&&a[x+4][y]=='#'&&a[x][y+1]=='#'&&a[x][y+2]=='#'&&a[x+2][y+1]=='#'&&a[x+2][y+2]=='#'&&a[x+4][y+1]=='#'&&a[x+4][y+2]=='#'&&a[x+3][y+2]=='#')
				{
                			ans+="6";//如果满足这种情况，ans加上一个"6"
                			return;
				}
                break;
            case 7://七的情况，方法同上
                if(a[x+1][y+2]=='#'&&a[x+2][y+2]=='#'&&a[x+3][y+2]=='#'&&a[x+4][y+2]=='#'&&a[x][y+1]=='#'&&a[x][y]=='#'&&a[x][y+2]=='#')
				{
                			ans+="7";//如果满足这种情况，ans加上一个"7"
                			return;
				}
                break;
            case 8://八的情况，方法同上
                if(a[x+1][y]=='#'&&a[x+2][y]=='#'&&a[x+3][y]=='#'&&a[x+4][y]=='#'&&a[x][y+1]=='#'&&a[x][y+2]=='#'&&a[x+2][y+1]=='#'&&a[x+2][y+2]=='#'&&a[x+4][y+1]=='#'&&a[x+4][y+2]=='#'&&a[x+3][y+2]=='#'&&a[x+1][y+2]=='#')
				{
                			ans+="8";//如果满足这种情况，ans加上一个"8"
                			return;
				}
                break;
            case 9://九的情况，方法同上
                if(a[x+1][y]=='#'&&a[x+2][y]=='#'&&a[x+4][y]=='#'&&a[x][y+1]=='#'&&a[x][y+2]=='#'&&a[x+2][y+1]=='#'&&a[x+2][y+2]=='#'&&a[x+4][y+1]=='#'&&a[x+4][y+2]=='#'&&a[x+3][y+2]=='#'&&a[x+1][y+2]=='#')
				{
                			ans+="9";//如果满足这种情况，ans加上一个"9"
                			return;
				}
                break;
            case 0://零的情况，方法同上
                if(a[x+1][y]=='#'&&a[x+2][y]=='#'&&a[x+3][y]=='#'&&a[x+4][y]=='#'&&a[x][y+1]=='#'&&a[x][y+2]=='#'&&a[x+2][y+2]=='#'&&a[x+4][y+1]=='#'&&a[x+4][y+2]=='#'&&a[x+3][y+2]=='#'&&a[x+1][y+2]=='#')
				{
                			ans+="0";//如果满足这种情况，ans加上一个"0"
                			return;
				}
                break;
        }
    }
}
int main()
{
    cin>>n>>m;
    for(int i=0;i<n;i++)//输入
    {
    	for(int j=0;j<m;j++)
    	{
    		cin>>a[i][j];
		}
	}
    for(int j=0;j<m;j++)//注意！这里要从上至下再从左到右，否则会判断多次同列的“#”，可能会tle
    {
    	for(int i=0;i<n;i++)
    	{
       	 	if(a[i][j]=='#')
        	{
        		dfs(i,j);
        		if(ans[ans.size()-1]=='1') j+=2;//如果判断出的是一，就移左两列，可以少判断很多格
        		else j+=4;//不是一的话，因为本来数字就占用三格，就要移左4格开始判断
        		i=-1;//i=-1，因为循环会自动加一，所以下一个循环是从a[0][j]开始判断
        	}
    	}
	}
    for(int i=0;i<ans.size();i++)
	{
		cout<<ans[i];//输出字符串
	}
    return 0;
}
```

暴力难写，调试不易，希望管理大大通过（已改排版再次提交）