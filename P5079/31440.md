看上去很吓人的题目 其实仔细想想并不难写  
### 这里先做一个小的处理
2~0都是3x5的矩阵 只有这个1是1x5 由于题目中说了数字不会贴在一起 我们可以把1左右各加一列 '.'  
就像这样
```cpp
数字的组成方式：
. # .   # # #   # # #   # . #   # # #   # # #   # # #   # # #   # # #   # # # 
. # .   . . #   . . #   # . #   # . .   # . .   . . #   # . #   # . #   # . # 
. # .   # # #   # # #   # # #   # # #   # # #   . . #   # # #   # # #   # . # 
. # .   # . .   . . #   . . #   . . #   # . #   . . #   # . #   . . #   # . # 
. # .   # # #   # # #   . . #   # # #   # # #   . . #   # # #   # # #   # # # 

所代表的数字：
  1       2       3       4       5       6       7       8       9       0
```
题目中又说 数字不会上下排放 只会左右排放 所以可以建立一个数组存每一列有多少个'#'  
然后从头到尾扫一遍，如果有一列含有'#'数不是零，就通过每三列的'#'数量判断这是哪个数  
这里考虑到1的问题我是枚举中间那一列
```cpp
数字的组成方式：
0 1 0   4 3 4   4 4 5   3 1 5   4 3 4   5 3 4   1 1 5   5 3 5   4 3 5   5 2 5
. # .   # # #   # # #   # . #   # # #   # # #   # # #   # # #   # # #   # # # 
. # .   . . #   . . #   # . #   # . .   # . .   . . #   # . #   # . #   # . # 
. # .   # # #   # # #   # # #   # # #   # # #   . . #   # # #   # # #   # . # 
. # .   # . .   . . #   . . #   . . #   # . #   . . #   # . #   . . #   # . # 
. # .   # # #   # # #   . . #   # # #   # # #   . . #   # # #   # # #   # # # 

所代表的数字：
  1       2       3       4       5       6       7       8       9       0
```
但是2,5是相同的,~~那就写个特判吧~~
```cpp
# # #   # # #
. . *   # . *
# # #   # # #
# . .   . . #
# # #   # # #
```
2和5打星号的地方是不一样的 从上往下枚举知道找到第一个'#' 然后通过那一格判断2还是5  
~~好吧，我承认这个方法确实有点繁 不过比较好想好写点~~
## 上代码
```cpp
#include <cstdio>
#include <cmath>
#include <iostream>
#include <algorithm>
#include <cstring>
#define LL long long
using namespace std;
int mp[15][100050] = {0}; // 存图
int row[100050] = {0}; // 存每列'#'数量
char ch;
int main(){
	int r,c;
	cin >> r >> c;
	for(int i = 1;i <= r;i ++){
		for(int j = 1;j <= c;j ++){
			cin >> ch;
			if(ch == '#') mp[i][j] = 1;
			row[j] += mp[i][j]; // 有'#'就+1
		}
	}
	for(int j = 1;j <= c;j ++){
    	// 判断2,5
		if(row[j] == 3 && row[j - 1] == 4 && row[j + 1] == 4){
			for(int i = 1;i <= r;i ++){
				if(mp[i][j + 1]){
					if(mp[i + 1][j + 1]){
						printf("2");
					}
					else{
						printf("5");
					}
					break;
				}
			}
		}
        // 直接判断出2,5以外的所有数
		if(row[j] == 5 && row[j - 1] == 0 && row[j + 1] == 0) printf("1");
		if(row[j] == 3 && row[j - 1] == 3 && row[j + 1] == 5) printf("3");
		if(row[j] == 1 && row[j - 1] == 3 && row[j + 1] == 5) printf("4");
		if(row[j] == 3 && row[j - 1] == 5 && row[j + 1] == 4) printf("6");
		if(row[j] == 1 && row[j - 1] == 1 && row[j + 1] == 5) printf("7");
		if(row[j] == 3 && row[j - 1] == 5 && row[j + 1] == 5) printf("8");
		if(row[j] == 3 && row[j - 1] == 4 && row[j + 1] == 5) printf("9");
		if(row[j] == 2 && row[j - 1] == 5 && row[j + 1] == 5) printf("0");
	}
	return 0;
}
```