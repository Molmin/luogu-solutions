本人是通过网上查找区间 DP 练习题来到这里的。

那么很明显，这道题是可以用区间 DP 完成的。我们首先定义状态 $dp_{i,j}$ 表示区间 $[i,j]$ 的最小长度，但是我们发现这样并不能实现状态转移，因为本题当中相同的数才能进行合并，比如 `2 2 2 2` 可以进行合并变成 `8`，但是我们不能确定中间的 `4 4` 是否可以进行合并。

所以应该怎么进行改进呢？这是我们就需要第二个 DP，为什么要这么想呢？根据所给的 $a_i$，我们只能直接合并 $a_i$ 和 $a_{i+1}$ 得到 $k$，但是如果旁边还有一个 $k$ 可以合并，我们就需要记录 $k$ 的值进行判断，而为了记录 $k$ 的值，我们就可以想到定义一个新的数组 $f_{i,j}$ 表示当 $[i,j]$ 的长度可以变成 $1$ 的时候，所得到的最终数字。这样一来，当 $[i,k]$ 和 $[k+1,j]$ 都可以合并成一个数的时候，因为记录的 $f_{i,k}$ 和 $f_{k+1,j}$ 是相等的，所以可以又一次合并得到 $f_{i,j}=f_{i,k}+1$。否则就不能进行转移。

所以最终结果：

$$dp_{i,j}=\text{max}(dp_{i,j},dp_{i,k}+dp_{k+1,j})$$

$$dp_{i,j}=1,~f_{i,j}=f_{i,k}+1~(f_{i,k}=f_{k+1,j})$$

那么代码就可以轻轻松松打出来了：

```cpp
int main()
{
	memset(dp,0x3f,sizeof(dp));
	cin>>n;
	for(int i=1;i<=n;i++)	cin>>f[i][i],dp[i][i]=1;//区间长度为1，f[i][i] 的结果就是 a[i]
	for(int len=2;len<=n;len++)
	{
		for(int i=1;i<=n-len+1;i++)
		{
			int j=i+len-1;
			for(int k=i;k<j;k++)
			{
				dp[i][j]=min(dp[i][j],dp[i][k]+dp[k+1][j]);//拼接两个区间的长度
				if(dp[i][k]==dp[k+1][j]&&dp[i][k]==1&&f[i][k]==f[k+1][j])	dp[i][j]=1,f[i][j]=f[i][k]+1;//可以进行合并
			}
		}
	}
	cout<<dp[1][n];
	return 0;
}
```