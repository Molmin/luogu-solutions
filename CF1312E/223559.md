### 解题思路：

两个简单的区间 DP。

首先求出对于一段区间 $[l,r]$，如果能将其合并为一个值，那么这样的一个值一定是确定的，所以用一个 $f_{i,j}$ 来记录这个值是多少。

对于某一段区间，这样的一个值可以从中间的任意一个断点处合并起来，所以在这样的一个区间中枚举断点来进行转移，由于这样的值是唯一确定的，所以一旦找到就可以立即退出枚举断点的循环。

复杂度 $O(n^3)$。

---

然后考虑如何取到一个最短的合并后序列。

用一个 $dp_i$ 记录下从一合并到 $i$ 号元素最短需要多少个数，然后对于每一个 $i$，向前枚举一个断点使得断点到 $i$ 全都合并成一个元素。

需要注意的是，这样的一个点有可能就是 $i$，也就意味着 $i$ 这个点单独挪开。

复杂度 $O(n^2)$。

---

总复杂度 $O(n^3)$，由于基本没有什么常数，$n\le 500$ 的数据范围也是可以接受的。

---

### 代码：

```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
int f[505][505],n,dp[505];
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	scanf("%d",&f[i][i]),dp[i]=i;
	for(int i=2;i<=n;i++){
		for(int j=1;j<=n-i+1;j++){
			for(int k=j+1;k<=i+j-1;k++){
				if(f[j][k-1]==f[k][i+j-1]&&f[j][k-1]!=0){
					f[j][i+j-1]=f[j][k-1]+1;
					break;
				}
			}
		}
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=i;j++){
			if(f[j][i]!=0)
			dp[i]=min(dp[i],dp[j-1]+1);
		}
	}
	printf("%d",dp[n]);
	return 0;
}
```
