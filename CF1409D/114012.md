翻了翻机房dalao的提交记录，本来想找另一题的代码，但是看到了这道题~~发现可以水题解~~……

### 关于本题解

因为这道题很简单，本题解主要目的在于贡献一份比较~~平易近人~~的代码。题解区dalao的码风~~奇奇怪怪~~，自认为自己的思路和代码比较好理解。

### 思路

将 $n$ 加上一个数 $k$ ，使得到的数**各位数之和**小于 $s$。

先特判 $n$ 的各位数之和是否小于 $s$ ，若是则输出 $0$.

正如其他题解分析的一样，设 $n$ 的**各位数之和**为 $p$，如果做不进位加法，$n+k$的**各位数之和**必然大于 $p$。



将 $n$ 各位数看做一个序列，如：$n=100$，看做一个长度为 $3$ 的序列 $a$，其中 $a_3=1$。那么做进位加法，我们能保留的是从 $n$ 的最高位开始的一段区间 $T$（长度可为零），$T$区间的**右一位**为原数加 $1$，之后到序列尾都变为 $0$.根据题意，我们应使$T$区间的长度尽量长，这样我们的加数$k$就会尽量小。

假设 $T$ 区间长度为 $t$，$n$的位数为 $h$，最高位为第 $h$ 位，按照题意进行进位加法之后应该有 $h-t-1$个零。那么答案就为 $n\bmod 10^{h-t}- (a[h-t]+1) \times 10^{h-t-1}$

### Before the Code
看文字似乎挺难理解……代码的实现我采用了一种简单粗暴的方式，注释也比较详细，可以作为参考。如果发现本题解有错误或有疑问欢迎评论或私信！

### Enjoy the Code
```cpp
#include<cstdio>
#include<iostream>
using namespace std;
const int maxn=50;
long long n,s,w,k=1,p;
int a[maxn],cnt,sum,f;
int main(){
	int T;
	scanf("%d",&T);
	while(T)//多组数据
	{
		T--;
        //初始化
		cnt=0;
		p=0,sum=0;
		int flag=0;
        
		scanf("%lld%lld",&n,&s);
		w=n;
		while(w)//取出n的每一位
		{
			cnt++;//相当于文中的h
			sum+=w%10;//记录n的各位数之和
			a[cnt]=w%10;
			w/=10;		
		}
		if(sum>s)//需要做进位加法
		flag=1;
		if(flag)
		{
			sum=0;//重复利用很环保
			f=cnt+1;//f相当于文中的h-t
			for(int i=cnt;i>=1;i--)//从最高位开始向后找，因为T区间要从最高位开始
			{
				if(sum+a[i]+1<=s)//使t尽量大，f就尽量小
					f=i;
				sum+=a[i];
			}
			k=a[f]+1;
			for(int i=1;i<f;i++)//结合文字食用
			k*=10;
			for(int i=f;i>=1;i--)//n mod 10^f就是将n的后f位取出来
			p*=10,p+=a[i];
			printf("%lld\n",k-p);
		}
		else
			printf("0\n");
	}
	return 0;
}
```
### See Ya！