第一眼看到显然是一个多重背包

也很显然复杂度不对……

我们可以用另一种思想

## 差分

举一个很简单的例子：区间加减 // ~~其实没有这样的表达但是这样好理解~~

$$[2,+\infty]-(3,+\infty]=[2,3]$$

显然我们只需求出$[2,+\infty]$和$(3,+\infty]$就能算出$[2,3]$

那这道题能不能这样？

我们可以用**完全背包**先预处理出没有钱数限制是的所有情况

再把所有不合法的情况（即某种硬币超过了所给数量）减去，最后得到的就是答案

$$ans=f[s]-\sum^4_{i=1}{f[s-c_i*(d_i+1)]}$$

下面一个问题：$\sum^4_{i=1}{f[s-c_i*(d_i+1)]}$要怎样计算呢？

肯定不是直接累加，因为有可能第1种物品超过限制的同时，第二种物品数量也超过了限制，如果直接累加会把这种情况计算两次，显然是不正确的

所以我们再引入一个原理：

## 容斥原理

>在计数时，先不考虑重叠的情况，把包含于某内容中的所有对象的数目先计算出来，然后再把计数时重复计算的数目排斥出去，使得计算的结果既无遗漏又无重复，这种计数的方法称为容斥原理。

简单来说，就是把**重复计算**的部分**去掉**，把**多去掉**的部分**加回来**

针对本题而言，就是：

不合法数目$=$ $1$超出的部分$+$ $2$超出的部分$+……-$ $1,2$共同超出的部分$-$ $2,3$共同超出的部分$……$ $+$ $1,2,3$共同超出的部分……（后面以此类推）

代码实现就比较容易了

下面有详细注释

```
#include<bits/stdc++.h>
using namespace std;
int T,n,c[5],d[5],s;
long long ans,f[100010];
void pack_pre()
{
	f[0]=1;
	for(int i=1;i<=4;i++)
	    for(int j=c[i];j<=100001;j++)
	        f[j]+=f[j-c[i]];
}
void dfs(int now,int sum,int flag)
//now是现在搜到的硬币种类
//sum是目前还能用的金额数目
//flag是符号（控制+,-符号）
{
	if(sum<0) return;//能用的钱没了就返回
    if(now>4) {ans+=f[sum]*flag;return;}//所有硬币种类都搜完了
	dfs(now+1,sum,flag);//合法的部分
	dfs(now+1,sum-(d[now]+1)*c[now],-flag);//不合法的部分
}
int main()
{
	for(int i=1;i<=4;i++) scanf("%d",&c[i]);
	pack_pre();//完全背包预处理
	scanf("%d",&T);
	while(T--)
	{
		ans=0;//记得清零
		for(int i=1;i<=4;i++) scanf("%d",&d[i]);
		scanf("%d",&s);
		dfs(1,s,1);
		printf("%lld\n",ans);
	}
}

```



