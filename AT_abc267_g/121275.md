一个几乎不需要思考的做法，就是单纯的按照题意硬做。

按照套路，我们从小到大放数。为了方便，我们称一个 $b_i<b_{i+1}$ 为山峰。先考虑所有数都不同的情况下，$dp_{i,j}$ 表示放了前 $i$ 个数，当前有 $j$ 个山峰的方案数。我们发现这样非常好转移。我们考虑当前用 $dp_{i-1,j}$ 转移，那么转移的时候，你有 $j+1$ 个位置可以让山峰不变（插第一个或者某一个山峰中间），$i-j-1$ 个位置可以让山峰 $+1$。直接 $n^2 \ \ \ dp $ 就可以了。

然后考虑推广到有重复数的情况，设 $dp_{i,j}$ 表示前 $i$ 种数有 $j$ 个山峰的方案数。你考虑转移的时候枚举一个 $t$，表示 $i$ 这种数会使得数列增加 $t$ 个山峰，考虑到 $\sum t=n$，因此如果可以 $O(1)$ 转移还是不会出问题。实际上转移就是 $dp_{i-1,j}\to dp_{i,j+t}*y$，$y$ 表示转移系数，我们只考虑求转移系数即可。

再定义 $num_i$ 表示第 $i$ 种数的个数，$sum_i$ 表示前 $i$ 种数的个数和。你考虑这个转移系数就是必须选择 $t$ 个可以使得山峰 $+1$ 的位置，$num_i-t$ 个可以使得山峰不变的位置去插入。

首先把所有 $i$ 的数都看做相同的，答案最后乘以一个 $(num_i)!$ 即可。观察再发现，你在每一个位置的后面如果插入了 $k$ 个数（$k>1$)，等价于只插入 $1$ 个。那么你可以把当前状态（$dp_{i-1,?}$ 的状态）中的**每一个空位外加第一个前面**都看做一个盒子。于是这个转移系数就转化成了你需要把 $num_i$ 个相同的球放入 $sum_{i-1}+1$ 个不同的盒子，这其中有 $sum_{i-1}-j$ 个特殊盒子，你必须保证放完球后**恰好** $t$ 个特殊盒子非空的方案数。

考虑直接列出式子，特殊盒子恰好 $t$ 个我们考虑直接钦定，方案数是 $\binom{num_{i-1}-j}{t}$，然后我们考虑枚举有 $q$ 个**非空非特殊盒子**，然后再放球，那么方案数就是 $\sum_{q}\binom{j+1}{q}\binom{num_{i}-1}{t+q-1}$，这式子的意义就是，前者是选 $q$ 个盒子的方案数，后者就是放球问题的方案数。

然后发现后面这个东西可以范德蒙德卷积一下，就做完了。转移系数就是 $(num_i!)\binom{sum_{i-1}-j}{t}\binom{num_i+j}{t+j}$。

复杂度 $O(n^2)$。

不怎么好看的代码：

```cpp
signed main()
{
	int T=1;
	pre();
	while(T--)
	{
		rdn;rdk;upn rd(a[i]);sort(a+1,a+n+1);
		dp[0][0]=1;
		int tot=1;
		up(i,2,n)
		{
			if(a[i]!=a[i-1])
			{
				c[++m]=tot;tot=0;
			}
			tot++;
		}
		c[++m]=tot;
		int sm=0;
		up(i,1,m)
		{
			//前i段
			up(j,0,n)
			{
				if(!dp[i-1][j])continue;
				int w1=j+1;
				int w2=sm-j;
				up(t,0,min(c[i],w2))
				{
					int w3=c[i]-t;
					int res=0;
					int q=C(w2,t);
					int rw=min(w3,w1);
					res+=C(w1+c[i]-1,w1+t-1);res+=mod;res%=mod;
					Add(dp[i][j+t],res*fac[c[i]]%mod*dp[i-1][j]%mod*q%mod);
				}
			}
			sm+=c[i];
		}
		cout<<dp[m][k];
	}
}
```