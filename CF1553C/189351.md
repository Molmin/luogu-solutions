## 题意

两个球队进行点球比赛，比赛规则是两队轮流点球，总共点 $10$ 次，最后进球多的球队获胜，**注意，在这种比赛规则下，两个球队可能会出现平局**，$T$ 组询问每组询问给出一个长度为 $10$ 的字符串，字符串的第 $i$ 位代表第 $i$ 次点球的结果 `1` 代表成功，`0` 代表失败，`?` 代表不知道结果，现在想知道，在 `?` 的所有结果中，哪种可以让点球比赛最快结束，输出结束的时刻即可。

例如，当点球的结果为 `101010????` 时，无论如何第二队都不可能获得胜利，所以提前结束并且输出 $6$。

## 分析

首先，我们可以用 $2^{10} = 1024$ 的复杂度暴搜，然后再来判断当前这种情况的结束时刻。

现在我们通过爆搜获得了一个长度为 $10$ 的由 `0`、`1` 组成的字符串。然后维护两个数组 $a$、$b$，$a_i$ 维护的是 $i$ 队在当前时刻进球数量之后最多进球的数量，$b_i$ 维护的是 $i$ 队在当前时刻已经进球的数量，显然当有一队的当前进球数量比另外一队的预测数量还要多的时候结束。

时间复杂度：$1024T$。

## 代码

```cpp
# include <bits/stdc++.h>
using namespace std;

int T, N;
char s[15];
int stk[15], top, res;

void DFS (int id) { // 2^n 枚举
    if (id > top) { // On check
        int a[2] = {5, 5}, b[2] = {0, 0};
        for (int i = 1; i <= N; i++) {
            int j = (i & 1); // j:当前球队编号 j^1:另一个球队编号
            if (s[i] == '0') a[j]--; else b[j]++;
            if (b[j] > a[j ^ 1] || b[j ^ 1] > a[j]) {
                res = min (res, i); // 判断是否出现一个球队碾压的情况
                return ;
            }
        }
        return ;
    }
    // 修改问号的位置为 0 或者 1
    s[stk[id]] = '0';
    DFS (id + 1);
    s[stk[id]] = '1';
    DFS (id + 1);
    return ;
}

int main () {
    cin >> T; N = 10;
    while (T--) {
        cin >> (s + 1); top = 0; res = 10; // 将 ? 的位置记录下来，方便 DFS
        for (int i = 1; i <= N; i++) if (s[i] == '?') stk[++top] = i;
        DFS (1); cout << res << endl;
    }
}
```