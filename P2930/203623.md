显然是每次操作后统计贡献。

看到 $C\le 15$ 果断选择维护 $C$ 个同一类数据结构支持这个操作。

然后就变成了序列上的操作。

用珂朵莉树做相当简单。对于一个连续段，统计其与“目标画”的不同的数的数量。若此连续段为 $1$ 则为目标这段区间中 $0$ 的个数，反之亦然。

维护目标的前缀和即可。

每次推平的时候减去区间中连续段的贡献，再加上推平后的贡献即可。

复杂度是对的。每次 split 增加了常数个元素，每次遍历后删除此元素，所以每个元素最多被访问一次。总访问复杂度 $\log q$。

总复杂度 $RC+qC\log q$，跑得挺快的。