神奇的题目。

挖性质，首先考虑什么样的树（不考虑删边）最大匹配唯一。发现，如果有结点未匹配，得知该结点连接的所有点都匹配（否则此时的匹配不是最大的），那么把任意一个点变成与该结点匹配，最大匹配数不变，但变成了另一种方案。

所以，**只有所有点都匹配** 或者 **只有一个点** 的树才有可能最大匹配唯一。当然，对于存在所有点都匹配的连通块，我们每次可以选择连通块的叶子结点，然后令他和其父亲匹配（由于是叶子，所以只连接他的父亲），之后删掉这两个点。重复上述操作，即可得到最大匹配。不难发现此时必定是唯一的最大匹配。

所以对于割去若干条边后所形成的的森林，去掉只有一个点的树，剩下的树都应该满足存在每个点都匹配的方案。利用最大匹配唯一的条件，我们可以直接围绕最大匹配来统计原树。

设 $f_{u,0/1/2}$ 表示在 $u$ 子树割去若干条边后找最大匹配，必须保证除了 $u$ 其他点要么自己构成一个点的连通块，要么匹配的方案数。第二维表示： $u$ 匹配 / $u$ 不匹配但是 $u$ 所在连通块大于一个点 / $u$ 单独构成一个点的连通块。

首先对于 $f_{u,0}$，假设 $(u,v)$ 匹配，其中 $v$ 是 $u$ 的儿子，那么其他儿子构成的子树单独作为一个子问题，且与 $u$ 的连边要么割要么不割。

其次 $f_{u,2}$，显然割去连向儿子的所有边，然后算儿子子树的贡献。

最后是 $f_{u,1}$，只需把所有儿子子树的贡献和边割或不割的贡献全部算起来，减去 $f_{u,2}$ 即可。

计算 $x$ 为 $u$ 不匹配的答案，$y$ 为 $u$ 匹配的答案，$f_{u,2}$ 单独计算，那么 $f_{u,0}=y,\space f_{u,1}=x-f_{u,2}$，$x$ 和 $y$ 则为树形 DP 简化背包，计算简单。

时间复杂度 $O(n)$。

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const ll maxn=6e5+10,mod=998244353;
ll n,u,v,head[maxn],tot,f[maxn][3],siz[maxn],pw[maxn];
struct edge
{
	ll v,nxt;
}e[maxn];
void insert(ll u,ll v)
{
	e[++tot]=(edge){v,head[u]};
	head[u]=tot;
}
void dfs(ll u,ll fa)
{
	siz[u]=1;
	ll x=1,y=0;//fill    no fill but not 1    no fill but 1
	f[u][2]=1;
	for(ll i=head[u];i;i=e[i].nxt)
	{
		ll v=e[i].v;
		if(v!=fa)
		{
			dfs(v,u);
			siz[u]+=siz[v];
			y=(y*(f[v][0]*2+f[v][2])%mod+x*(f[v][1]+f[v][2]))%mod;
			x=x*(f[v][0]*2+f[v][2])%mod;
			f[u][2]=f[u][2]*(f[v][0]+f[v][2])%mod;
		}
	}
	f[u][0]=y;
	f[u][1]=(x-f[u][2]+mod)%mod;
}
int main()
{
	scanf("%lld",&n);
	pw[0]=1;
	for(ll i=1;i<=n;i++) pw[i]=pw[i-1]*2%mod; 
	for(ll i=1;i<n;i++)
	{
		scanf("%lld%lld",&u,&v);
		insert(u,v);
		insert(v,u);
	}
	dfs(1,0);
	printf("%lld",(f[1][0]+f[1][2])%mod);
	return 0;
}
```