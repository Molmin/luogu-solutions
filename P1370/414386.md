## 题解

### 前言

[博客](https://www.luogu.com.cn/blog/yousa22/solution-p1370)

[题目](https://www.luogu.com.cn/problem/P1370)

这其实是一道非常好的题，但是感觉题解没有那么详细，~~我每写一步都有一个新的问题~~。所以我特意写一篇题解来帮助大家。

### 正题

首先看要求什么

$$\sum_{l=1}^n\sum_{r=l}^nF(l,r)$$

我们发现就算能 $\text{O}(1)$ 求出每个值也会超时，其实有很多这样的题目，就是求每一个区间的值的和，因为我们并不关心每一个的区间的值，所以我们可以把一些区间绑起来一起算，一般是固定左或者右端点，具体看题目性质，我们为什么要这样做？就是因为我们希望通过一个较低的复杂度一次性推出一些区间的值的和。

比如这个题，可以令 $dp_l=\sum_{r=l}^nF(l,r)$，因为我们注意到如果 $l<l'$，那么计算 $l$ 为开头的值是必须会把后面的，也就是包含了 $l'$ 的值 ，那么答案就是 $\sum_{i=1}^ndp_i$，我们再来看怎么转移，比起一多很多个数加入，我们肯定希望每次只需要多算一个数的贡献，所以每一次从他右边一个来推出。

假设当前我们算到了 $i$，这个时候有两种情况：

> **1.** $i$ 右边的数字都不与 $a_i$ 相等，那么对于所有的 $F(i,r)$ 他们的值就是 $F(i+1,r) \times 2$，因为 $a_i$ 可以选或者不选，然后注意 $F(i,i)=2$（选自己和空），发现对于除了 $F(i,i)$，剩下的就是 $\sum_{l=i+1}^n F(l,r) \times 2 = dp_{i+1} \times 2$，那么总的就是 

> $$dp_i=dp_{i+1} \times 2 +2$$

> **2.**  $a_i$ 与后面的有相同，我们先从最简单的开始。

>> 1. **除了值为 $a_i$ 其他都不重复而且只有一个与 $a_i$ 相等（不妨设这里为 $j$）**，那么我们发现，只有在选了 $a_i$ 和选了 $j+1$ 后面的数组成的序列会和 $a_j$ 和后面的数组成的序列相同，或者就是 $i$ 和 $j$ 相同，那么重复的方案数其实就是 $dp_{j+1}+1$，**我们就可以看做是减去了 $a_j$ 为开头的那一部分**。


>> 2. **除了值为 $a_i$ 其他都不重复但是值为 $a_i$ 的会有多个**，这个时候就有人（其实只有我）不知道 $a_i$ 是应该只算离他最近的还是都算了，我们注意到，如果选了 $i$ 和 选了 $j\ (a_i= a_j)$ 的序列要一样，那么 $j$ 前面的等于 $a_i$ 的就不应该选， 其实这也等价于 $j$ 前面等于 $a_i$ 的选了，后面等于的不选（设为下标 $k$），然后随机选后面的数字（$>k$），因为数值都一样嘛。那么对于所有的 $j ,a_j=a_i$ 其实都可以把他的答案等价到离 $i$ 最近的那个 $j$ 上面，而且 $dp_{j+1}$ 本身就包含了这些答案 ，所以 2.1 提到的方程仍然使用。


>> 3. **题目要求，无特殊限制**，这时候可能就有人问，啊，你之前计算重复的都没有包括 $i,j$ 之间的数，如果是类似于 $2,\ldots,3,\ldots,2,\ldots,3,\ldots$ 怎么办？其实这在计算 $3$ 的时候就已经去掉了后面那个 $3$ 的答案了，之后的转移就相当于只有一个，然后再对 $2$ 的去重的时候中间的数字没有计算，所以不会有重复减少的情况了，2.1 的方程仍然使用

我们记录下来最左边值的为 $i$ 的下标 $Lst_i$，当然这一步需要离散化后计算，不然爆空间，则总方程是，注意加上模数防止爆负：

$$dp_i=(dp_{i+1}\times 2 +2 -dp_{Lst_{a_i}}-1+Mod)\%Mod$$

$$Lst_{a_i}=i$$

时间复杂度：离散化 $\text{O}(n \log n)$，Dp $\text{O}(n)$

代码：

（前面有一坨很大的模板不放上来了，$100\%$ 原创，[Template](https://www.luogu.com.cn/paste/3swxk4ey)）

```cpp
//Template By (HMS_Cheshire)小柴郡喵喵喵
#include<bits/stdc++.h>
using namespace std;
using lll = __int128;
using ll = long long;
const int maxn=1e5+10;
const ll Mod=998244353;
int n;
vector<int>a,Lst;
vector<ll>dp;
int main(){
	read(n);
	a.resize(n+1);
	dp.resize(n+2);
	Lst.resize(n+1);
	for(int i(1);i<=n;++i)read(a[i]);
	vector<int>Rank=Saratoga::Discretization(a.begin()+1,a.begin()+1+n,[](int A,int B){
		return A<B;	
	});
	for(int i(1);i<=n;++i)a[i]=Rank[i];
	for(int i(n);i>=1;--i){
		dp[i]=(dp[i+1]*2+2)%Mod;
		if(Lst[a[i]])dp[i]=(dp[i]-dp[Lst[a[i]]+1]-1+Mod)%Mod;
		Lst[a[i]]=i;
	}
	ll ans=0;
	for(int i(1);i<=n;++i){
		ans=(ans+dp[i])%Mod;
	}
	write(ans);
	return 0;
}
```

