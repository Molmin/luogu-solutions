看到有些大佬做的都是二分，我自己没去试，就索性替 P 党发个麻烦一点的做法吧~ ~~(去了快排也没多少)~~


------------

此题比较关键的一步就是把题目的 **一维区间** 看成 **几个点**，然后 **线性处理**。

我用的是 **前缀和** ：
_sum[i]_  表示第  _i_  个音阶的 **起始时间**

则  _sum[1]=0_ (边界) 且  _sum[i+1]=sum[i]+第 i 个音阶持续时间_ (递推式，只用推到 n+1 即可).

而为什么可以这样用前缀和来实现呢？ 就拿样例举例子(a[i] 为第 i 个音阶 **持续时间**)： 

	sum[1]=0；            //第1个音阶起始时间
    sum[2]=sum[1]+a[1]=2；//第2个音阶起始时间
    sum[3]=sum[2]+a[2]=3; //第3个音阶起始时间
    sum[4]=sum[3]+a[3]=6; (虚设的，下面有用）//第4个音阶起始时间

于是对于每个询问，我们可以判断 _Ti_  是否 **大于等于** 被标记音阶的下个音阶的 **起始时间**  (线性处理)：

 _**若是大于等于**_ ，则意味着超过此音阶敲击时间，于是我们就可以让标记 **跳到下个音阶的位置**，直到 **小于** 下个音阶的起始时间为止(想想为什么可以这样得到答案，为什么是大于等于，并想想为什么这里不用处理边界)；

** _若是小于_ ** ，不用怀疑，答案就是它！

时间复杂度：O(n^2);（最坏情况下）

------------


做完了！？  

大大的
## TLE 
送给你！！！ ~~（虽然我没试过~）~~

友情提醒：

#  _**数据范围**_ 

看了木有？？？ 

## 1<=n<= 50000 啊

稳稳的  _**TLE**_  到手！



------------


下面说说正解（咳咳，敲黑板）：

这么灰心干嘛？其实加个 **排序** 和一些 _小手 (shu) 段  (zu) _  就可以完成啦~！

既然每次都要归零重搜，还不如直接 **一遍搜完**。

什么？还可以一遍搜完？？？

那当然，不过一遍搜完的 最最最最最最···(此处省略一万个字) 常规方法就是 **排序** ！！！

当然，O(n^2) 的排序会超时，这里就要用 O(n log n) 的排序啦~ ~~(建议快排，因为可以 ctrl c + ctrl v)~~

按什么来排序呢？自己想！！！

由于排完序后编号会乱，所以一遍搜完后不能直接输出，而是运用 **小技(shu)巧(zu)** 存起来，然后按原序输出就可以啦~~~

------------

所以做完了吗？？？

## 并不！！！(时间复杂度自己算！)

是不是特别 **_崩溃_** ？（斜眼笑）

其实做完了。。。~~(我才没骗你呢~)~~

嘻嘻，我要谢谢你对我的滋瓷，念在你这么有耐心地看到这里，这次我没删部分代码，代码中也有注释~~(哪个代码中没有？)~~~~~(掌声)

废话不多说， _**Diu**_  代码！

------------

```pascal
var
        i,k,m,n:longint;
        a,b,c,d:array[0..1000001] of int64;
        //把 int64 改为 longint 好像也行，不过以防万一~
        //a 为计算前缀和的数组，即上文的 sum；
        //b 为每个询问的信息；
        //c 为每个询问快排后的的编号；
        //d 为每个询问的答案，但 d[i] 中的 i 是每个询问的原始编号。
procedure qsort(l,r:longint); //快排，不多说。
var
	i,j,x,y:longint;
begin
        i:=l;
        j:=r;
        x:=b[(l+r) div 2];
        repeat
           	while b[i]<x do inc(i);
           	while x<b[j] do dec(j);
           	if not(i>j) then
             	begin
                	y:=b[i];
                	b[i]:=b[j];
                	b[j]:=y;
                    y:=c[i]; //编号也要交换哦~
                    c[i]:=c[j];
                    c[j]:=y;
                	inc(i);
                	j:=j-1;
             	end;
        until i>j;
        if l<j then qsort(l,j);
        if i<r then qsort(i,r);
end;
begin
        readln(n,m);
        for i:=1 to n do //读入
        begin
                readln(k);
                a[i+1]:=a[i]+k; //前缀和，会一直算到 n+1 (想想)
        end;               
        for i:=1 to m do
        begin
                c[i]:=i; //每个询问的编号，现在赋值为原始编号，快排后会改变。
                readln(b[i]); //每个询问的信息，即 Ti
        end;
        qsort(1,m); //排序
        k:=1; //起始标记的位置
        for i:=1 to m do //对排序后的询问来寻找答案
        //由于询问是排过序的，所以后面询问的答案肯定在前面询问过的答案之后。
        //所以搜到第 k 个音阶时 不必再去搜前 k-1 个音阶
        begin
                while b[i]>=a[k+1] do inc(k); 
                //跳至符合的音阶，不必再从0跳了，因为前一个询问的答案便为此次询问的起始位置(想想)。
                d[c[i]]:=k; //记录答案。(c[i] 为编号)
        end;
        for i:=1 to m do
                writeln(d[i]);
                //i 即为原始询问的编号(想想)，按原始输入的顺序输出所记录的答案即可。
end.
```