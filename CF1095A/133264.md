# CF1095A Repeating Cipher  第三篇题解
## 先看题：
给一个字符串,有如下机密规则:
    
对于一个字符$s_i$,将它复制$i$遍,然后放到加密串的末尾.
    
现在给出加密串,要求还原原串.
#### 看了一下，前面的大佬们好像都没讲清楚题意&思路，我来讲一下吧
### 题意：
简单来说，就是现在有一个字符串$s$，然后将$s_1$写$1$遍，然后将$s_2$写$2$遍，然后将$s_3$写$3$遍。。。。。。然后将$s_n$写$n$遍,得到一个字符串$s'$

$for$ $example:$ $bab$->写一遍$s_1$(就是b)->写两遍$s_2$(就是a)->写三遍$s_3$(就是b)->得到$s'$(就是baabbb)

输入格式：第一行输入一个数$n(1≤n≤55)$,表示字符串$s$的长度
第二行输入字符串$s'$（注意输入的是$s'$，这是一个解密过程）

输出格式：一行，字符串$s$
### 思路：
我们想想，$s_i$会出现在$s'$的哪里呢？

在字符串$s$里，$s_i$前面有$i-1$个字符

则在字符串$s'$里，$s_i$前面有$1+2+3+……+(i-1)$即$\frac{i*(i-1)}{2}$个字符，这说明$s_i$会出现在$s'$的$\frac{i*(i-1)}{2}+1$个字符到$\frac{i*(i+1)}{2}$个字符的位置

那么我们只需要输出第$\frac{1*(1-1)}{2}+1$个字符，第$\frac{2*(2-1)}{2}+1$个字符，第$\frac{3*(3-1)}{2}$个字符……第$\frac{n*(n-1)}{2}+1$个字符就相当于输出了字符串$s$啦！

于是我们就愉快的开始敲代码啦
### 还有一点：不用万能头！
代码在这：
```cpp
#include<cstdio>
using namespace std;
int i=0,l,n=0;//初始化
char s[60];//字符串s
int main(){
	scanf("%d%s",&l,s);//读入
	for(;i<l;i+=n+1,n++) printf("%c",s[i]);//输出
    return 0;
}
```