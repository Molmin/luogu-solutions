我下文说的贡献就是 $d_i^2v_i$，其中 $d_i$ 是不固定的。

证明在最下面。

## 算法思路：

有一个显然的结论：每个点度数至少为 $1$。所以先假设每个点都已经连好了，且每个点的度数都为 $1$。

因为每个点的度数都得为 $1$，所以肯定是两两互相连。

这时要分类讨论：

* $n$ 为偶数时：

刚好可以两两分组，所以可以分成 $\frac{n}{2}$ 组。

此时要把这 $\frac{2}{n}$ 个组连成一棵树，所以需要 $\frac{n}{2}-1$ 条边。

每条边会使得它连接的两个点的度数都 $+1$，所以一条边产生 $2$ 个贡献。

所以会产生 $n-2$ 个贡献。


* $n$ 为奇数时：

$n-1$ 个点可以两两分组，分成 $\frac{n-1}{2}$ 组，需要 $\frac{n-1}{2}-1$ 条边连。

产生 $n-3$ 个贡献。

剩下 $1$ 个点随便找一组连。

但这样会使得某一个点的度数 $+1$，从而增加一个贡献。

所以会产生 $n-2$ 个贡献。


**综上：此题的答案为所有点的初始贡献之和+前 $n-2$ 小的度数大于 $1$ 的贡献。**

## 实现过程：

前者输入时直接加就行，后者用优先队列维护。注意加入优先队列的贡献是从度数为 $2$ 开始算起的。

每次取出最小贡献的点后，设此当前点的度数为 $d$,繁忙度为 $v$，则产生的贡献为 $(d^2-(d-1)^2)v$（事实上优先队列也是通过这个值来排序的），且将 $d$ 更新为 $d+1$ 再放进优先队列。


## （感性）证明

开始已经把每个点自己向外连的贡献算了，没算的是连到的点产生的贡献。

之后用优先队列每次取贡献相当于确定这些点所连的是哪条边。因为 $n>2$ 时才会进行到这个步骤，所以可以认为不会自己连自己。

