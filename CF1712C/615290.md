## 简化题意

给定一个正整数列 $a_1,a_2,\dots,a_n$，每次操作选择一个正整数 $x$，使数列中所有满足 $a_i=x$ 的元素都变为 $0$，求使数列单调不降所需的最小操作次数。

## 题目分析

因为原数列中的元素均为正整数，所以 $0$ 是操作后整个数列中的最小值。

而题目要求通过若干次操作使数列单调不降，即 $\forall 1\le i<n,a_i\le a_{i+1}$。

因此在操作结束后，数列的形态为 $0,0,\dots,0,a_k,a_{k+1},\dots,a_{n-1},a_n$，其中 $a_k,\dots,a_n$ 未被改变过且单调不降。

显然，若在某次操作中 $a_k$ 被改为了 $0$，那么在后续的操作中，必须把 $a_1,\dots,a_{k-1}$ 的值均改为 $0$。如果存在 $i(1\le i<n)$ 使得 $a_i>a_{i+1}$，则 $a_1,\dots,a_i$ 均需设为 $0$。

为了使序列单调不降，最长不降后缀之前的元素必定会在某一时刻被更改。

在程序中，设 $t$ 为需要更新为 $0$ 的最后一个位置。开始时将 $t$ 设为最长不降后缀的起始位置的前一元素。每次操作，若需要更改 $t$ 以后的位置，则更新 $t$ 的值。如此不断循环直到不用继续更新为止。

由于 $1\le a_i\le n$，值域较小，直接开数组记录每个可能的 $x$ 所能改变的最后一个元素的下标即可。

## 参考代码

~~参考代码仅供参考(bushi)~~

以下是 赛时代码 + 码风优化 + 注释。

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
ll T,n,t,ans,a[100005],nxt[100005],i;bool f[100005];
//a保存原数组，nxt记录最后一个被改变的元素下标，f记录该数是否已被改变过
void work(){
	cin>>n;
	for(i=1;i<=n;i++)nxt[i]=f[i]=0;//多测记得初始化
	for(i=1;i<=n;i++){
		cin>>a[i];
		nxt[a[i]]=max(nxt[a[i]],i);//记录a[i]对应值的最晚出现的下标
	}
	for(i=n;i>1;i--)if(a[i]<a[i-1])break;//找第一个不满足单调性的数
	t=i-1;ans=0;
	for(i=1;i<=t;i++)//从头开始枚举
		ans+=(!f[a[i]]),//若没有标记过则操作次数+1
		f[a[i]]=1,//添加标记
		t=max(t,nxt[a[i]]);//更新枚举次数
	cout<<ans<<'\n';
}
int main(){
	ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
	cin>>T;while(T--)work();
}
```