## 题意简述

给定一个长度为 $n$ 的数列 $\{a_n\}$。

单次操作可以：
 
- 选择任意整数 $x$
- 将数列中**所有**等于 $x$ 的项均赋值为 $0$

要求求出使该数列变为单调不减数列（$a_i \leq a_{i+1}$）的最小操作数。

初始时所有 $a_i \in [1,n]$。

## Solution

首先，不难看出，从后往前看，如果某一个点比它后面的数要大，就必须把它之前的数全部置 $0$。

> 因为使 $a_i$ 减小的唯一方法就是将其置 $0$，而由于所有 $a_i$ 均为正数，为了满足单调不减的性质，必须将其前面的元素一起置 $0$。

如果这题没有“单次必须对所有等于 $x$ 的项操作”这一项性质，那么这道题已经结束了：只需求出从后往前第几个元素比后一项元素大即可。

然而这道题确实存在这样一项性质，并且对解题产生了影响。考虑样例第 $2$ 组：
```
4
1 3 1 3
```
在这组样例中，从后开始数，第一个打破单调不增性质的元素显然是第 $2$ 项：$3$。然而将该项置 $0$ 会使得第 $4$ 项同时被置 $0$，迫使第 $4$ 项之前的所有数也必须置 $0$。

由此大约就能想到此题的解法：从后向前遍历，同时记录从第几个数开始，前面的数必须全部置 $0$。

不妨将上面出现的这个数记为 $del$。因此，我们可以在读入数据时维护一个 `lst` 数组，记录每个数最后出现的位置。只需要递归维护  
$$del = \max_{i=1}^n\{lst_i\}\ (\text{第}\ i \ \text{个或其后某个元素不符合单调不减性质})$$ 
即可。

求出 $del$ 以后就是将其前面所有数删除。

如何保证每个数只被删一次？`lst` 数组记录每个数最后出现的位置，可以规定如果 $lst_i$ 为 $0$ 即代表这个数没有出现过。于是在删掉一个数的同时，将 $lst_i$ 赋值为 $0$ 即可。

下面是 AC 代码：

```cpp
#include<bits/stdc++.h>
#define MAXN 100007
using namespace std;
int t,n,a[MAXN],lst[MAXN];
int main(){
    scanf("%d",&t);
    while(t--){
        scanf("%d",&n);
        for(int i=1;i<=n;i++)lst[i]=0;
        for(int i=1;i<=n;i++){
            scanf("%d",&a[i]);
            lst[a[i]]=i;
        }
        int del=0,pre=10000007;
        for(int i=n;i>=1;i--){
            if(a[i]>pre){
                del=max(del,lst[a[i]]);
            }
            else{
                pre=a[i];
            }
        }
        int ans=0;
        for(int i=1;i<=del;i++){
            if(lst[a[i]]){
                ans++;
                lst[a[i]]=0;
            }
        }
        printf("%d\n",ans);
    }
return 0;}
```