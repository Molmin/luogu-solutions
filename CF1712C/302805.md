**0. 前言**  
这场比赛可能是最惨的一次了  
A 00:06 B 00:11 C 00:24 D -7 。。。  

**1. 分析**  
题目要求最后变成**单调不降**的数组。  
很显然，如果对于任意的 $1\le i<n$ 有 $a_i\le a_{i+1}$ 就满足要求了。  
如果本来存在 $a_i<a_{i+1}$，但是后来因为某种原因导致所有和 $a_{i+1}$ 相等的都赋为 $0$，那么就需要再考虑一次 $a_i$ 和 $a_{i+1}$ 这对数。不难发现，**只需要从大到小判断每个数值是否应该被赋为 $0$** 就可以了。（证明甩在后面）  
我们又发现，$a_i$ 的值域是 $[1,n]$，那么又可以省去离散化了。  
只需要从大到小枚举每个可能的值 $k$，然后判断对于 $a_i=k$ 是否满足 $a_i\le a_{i+1}$ 如果不满足，那么记录一下，跳出循环，然后再把每个 $a_i=k$ 赋值为 $0$。  
**但是这里有一个坑。** 正常程序在数组最后一个元素后面一定存着一个 $0$，但是实际上是不需要考虑这个 $0$ 的，所以要特判一下。也就是说判断是否满足的时候要避开最后一个元素，**但是赋值的时候不要**。  

然后就是轻松愉快的证明了。  
假设数组里的元素从大到小排序再去重得到的结果是 $k_1,k_2,\dots,k_m$。  
那么对于每个 $k$ 只有赋值和不赋值两种选择。  
假设当前已经进行过了前 $j$ 个 $k$ 的选择，我们来到了第 $j+1$ 个。如果我们不执行操作，并且存在一个相邻数的逆序对（很显然靠左的那个等于 $k_{j+1}$，因为另一情况已经在枚举前 $j$ 个 $k$ 的时候判断过了。），那么就会出现矛盾。因为无论以后怎么操作靠右的那个数肯定只会不变或者变成 $0$，这个逆序对就永远存在了，不合题意，因而必须执行操作。  

反之，如果没有一个相邻数的逆序对其中靠左的是 $k_{j+1}$，那么就无需执行操作，显然对于任意的 $a_i=k_{j+1}$ 此时满足 $a_i\le a_{i+1}$（$i=n$ 除外），那么 $a_{i+1}$ 由于已经枚举过了（或者等于 $a_i$），则永远不会被赋值，不会制造一个逆序对。  

**2. 代码**  
实际上可以用 `vector` 记录一个值的每次出现的下标，枚举的时候直接遍历 `vector`，由于每个数最多遍历 $2$ 次（判断一次，赋值一次）故不超时。  
```cpp
#include<iostream>
#include<cstdio>
#include<vector>
#include<cstring>
#define maxn 100005

using namespace std;

int t, n, a[maxn];
bool z[maxn];

vector<int> g[maxn];

int main() {
	cin >> t;
	while(t--) {
		int ans = 0;
		memset(z, 0, sizeof(z));
		cin >> n;
		for(int i = 1; i <= n; i++) {
			g[i].clear();
		}
		for(int i = 0; i < n; i++) {
			cin >> a[i];
			g[a[i]].push_back(i);
		}
		for(int i = n; i >= 1; i--) {
			for(int j : g[i]) {
				if((a[j] > a[j + 1] || z[a[j + 1]] == 1) && j != n - 1) {
					z[i] = true;
					ans++;
					break;
				}
			} 
		}
		cout << ans << endl;
	}
}  
```