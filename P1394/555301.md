数据实在太小了。

对于 $m$ 条边，设输入时的顺序是 $u$ 和 $v$，那么从 $u$ 和 $v$ 中选择海拔较高的那个点作为起点，另一个点作为终点，连一条单向边，表示从水从起点可以流向终点，最终的答案就是在这里建水库后水可以流向所有点的那个点。因为是有向图且图中不可能有双向边，所以这种点最多有一个，可以邻接矩阵存图，用 floyd 传递闭包解决。但是这样的时间复杂度是 $\mathcal O(n^3)$，考虑优化。

对于每个点，在建图的同时记录它的入度。这样如果某个点入度不为 $0$，说明至少有一个点的水可以流向这个点，也就说明这个点不能建水库。即水库必须建在入度是 $0$ 的点上。可以证明，入度是 $0$ 的点必然存在。

如果有多于 $1$ 个点入度是 $0$，因为水库只能建一个，如果在其中某个点建了水库，那么至少有一个点（除了建水库的那个点外其他入度是 $0$ 的点）没有水，说明无法建水库，输出 `Non`。

如果只有一个点入度是 $0$，那么如果这个点能通往其他所有的点，水库就可以建在这个点上。这个判断可以用单源最短路的思想，比原先的 $\mathcal O(n^3)$ 优。

继续优化。其实如果这个图中有且仅有一个点入度是 $0$，那么这个点就可以建水库，无需判定是否能通往其他的点。证明如下：

假设有一个图，有且仅有一个点入度是 $0$，设为 $p$ 点，但存在一个点，设为 $q$ 点，从 $p$ 出发无法到达 $q$，假设 $q$ 点唯一。因为 $q$ 的入度不为 $0$，所以必定存在至少一个点（设为 $k$）可以通向 $q$，但因为 $q$ 点唯一，所以 $k$ 点必定可以从 $p$ 点出发到达，因而 $p$ 点出发可以到达 $q$，矛盾！

证毕。代码非常简单，只需存下每个点的入度就行了，连存图都省了。复杂度 $\mathcal O(n+m)$。

```cpp
#include <bits/stdc++.h>
using namespace std;
int n, m, h[301], in[301], ans;
int main() {
    cin >> n >> m;
    for (int i = 1; i <= n; i++)
        cin >> h[i];
    for (int i = 1; i <= m; i++) {
        int u, v;
        cin >> u >> v;
        if (h[u] > h[v])
            in[v]++;
        else if (h[u] < h[v])
            in[u]++;
    }
    for (int i = 1; i <= n; i++)
        if (!in[i])
            if (ans) {
                cout << "Non";
                return 0;
            }
            else
                ans = i;
    cout << "Oui, j'ai trouve la solution.\n" << ans;
    return 0;
}
```