[博客地址](https://www.cnblogs.com/1436177712qqcom/p/10375786.html)
## 题目大意

给出一个n个点m条边的DAG，记为G。

可以删掉若干条边成为G′，显然有 $2^{m}$种不同的G′。

连边保证：若有 ($x^{}_{i}$ → $i^{}_{i}$)边，则$x^{}_{i}$ < $i^{}_{i}$。

初始点1和点2有一个标记，Alice和Bob玩游戏，每次可以将任意一个标记沿边移动。

不能移动#者输，求这$2^{m}$张图有多少先手必胜。

对 $2^{9} + 7$ 取模。

------------
## 思路

这题的1和2两个点显然是可以互相独立的

所以可以分开考虑，当做两个不同的子游戏

根据sg定理可以知道当sg[ 1 ]与sg[ 2 ]不同时先手必胜

但是发现直接算不同的情况并不好做

正难则反 

因为所有的情况的方案数显然地可以知道有$2^{m}$种

我们就可以考虑sg[ 1 ]与sg[ 2 ]相同时的方案数

总方案数减去相同的方案数即可得出必胜的方案数

### 呢么 相等的情况该怎么做

发现n很小 最大只有15

可以考虑状压枚举dp和保存状态 

在枚举状态时枚举的是是否考虑这个点

因为要求sg[ 1 ]=sg[ 2 ] 所以不符合的都直接判掉

对于每种枚举到的总点集

我们可以分成sg值为0和非0两部分

#### 设当前枚举到的总点集为s

#### 分得的 sg非零的点集为t,sg为0的点集为u也就是s-t(状压里面就是^)

#### 当前点集的符合要求的方案数为dp[ s ]
 
根据sg定理可知在符合题目给出的图下（连边就是转移状态）

1.u的点不能之间互相连边

2.t中的每个点至少向u连一条边

3.u中的点随便向t连边

4.t中的点互相连接有dp[ t ]种

可能对于第4点会有疑问 为什么呢

#### 可以这么理解

我们从要点集t的方案推出它对于点集s的贡献

转移的实质是这种方案在原来的点集t上加了点集u

而所有的点集t上的点都要向点集u至少连一条边

点集t原来的终点都接在点集u上 终点改到了u上

这样就相当于点集t上所有的点的sg值都加1

而要使方案合法 点集t上的点相对之间的关系都不变

所以内部连接的方案数就是dp[ t ]

### 最后再总结下来
### 设s的每种分两部分的情况数为ans,每种情况刚开始ans=1,$2^{x}$为cf[ x ]
### 1.初始状态--dp[ 0 ]=1
### 2.转移方程--dp[ s ]+=dp[ t ]*ans
### 注.上面这条式子的i是指第几个点不是1左移i位 而代码中写的是左移多少位

剩下来具体的过程还是看代码

------------
## 代码

```c
#include<bits/stdc++.h> 
using namespace std;
#define ll long long
#define C getchar()-48
inline ll read()
{
    ll s=0,r=1;
    char c=C;
    for(;c<0||c>9;c=C) if(c==-3) r=-1;
    for(;c>=0&&c<=9;c=C) s=(s<<3)+(s<<1)+c;
    return s*r;
}
#define find __builtin_popcount 
//这个函数是找一个数的2进制中有几个1 
const int N=15,M=1<<15,p=1e9+7; 
int n,m;
int g[N],dp[M],cf[M];
inline int add(int x,int y)//算两数相加模p意义下的值 
{
	return ((x+=y)>p)?x-p:x;
}
int main()
{
    n=read(),m=read();
    dp[0]=cf[0]=1;//初始状态 
    for(int i=1;i<=m;i++) cf[i]=(cf[i-1]<<1)%p;//预处理2的x次方 
	for(int i=1;i<=m;i++){int x=read()-1,y=read()-1;g[x]|=(1<<y);}//2进制存x能到达的边 
	for(int s=1,sed=1<<n;s<sed;s++) if((s&1)==(s>>1&1))//枚举s  因为1和2的点的状态相同所以直接判掉  下面同理 
	for(int u=s;u;u=u-1&s) if((u&1)==(u>>1&1))//枚举u 
	{
		int ans=1;
		for(int i=0;i<n;i++) if(s>>i&1)//枚举被选到点 
		{
			if(u>>i&1) ans=1ll*ans*cf[find(g[i]&(s^u))]%p;//假如为点集u的点 
			else ans=1ll*ans*(cf[find(g[i]&u)]-1)%p;//假如为点集t的点 
		}
		dp[s]=add(dp[s],1ll*dp[s^u]*ans%p);//转移 
	}
	cout<<(cf[m]-dp[(1<<n)-1]+p)%p;
    return 0;
}
```



















