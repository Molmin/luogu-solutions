注意到两个石头互不影响，问题可以看作是两个 DAG 上的博弈。

于是先手会赢等价于 $\rm SG(1) \oplus SG(2)\ne 0$

于是答案等于 $2^m-$ 使得 $SG(1)\oplus SG(2)=0$ 的方案。

考虑通过 dp 来统计，我们发现可以根据 SG 函数的值对 DAG 进行分层，然后问题就是使得 $1,2$ 在同一层。

现在考虑如何进行分层统计，我们可以每次考虑从未被选择的点新增部分点作为新的一层，然后统计方案。（ 类似于 NOIP2017 宝藏 ）

那么对于新增的一层，他们都是最底层，所以这些点彼此之间无法连边，原本被选中的点至少向其中一个点连一条边（这样才能保住原本的 SG 值恰好变为 $+1$ ）同时这些点可以任意的跨层连边，只是不能同层连边。

然后只需要抱着每次增加一层的时候把 $1,2$ 同时增加了即可。

容易发现我们的代码需要枚举超集，类似于枚举子集，下面这一段代码可以有效的实现枚举超集的过程：

```
for( int i = S; i <= maxn; i = ( i + 1 ) | S ) 
```

对于每次新增一层的点的时候需要算一下内部的点遍历到其中的点至少有一个方案的方案数，这玩意儿显然每个点的贡献是独立的，所以预处理一下 $f_{i,S}$ 表示 $i\to S$ 至少有一个点的方案数。

然后还需要超集 ( T ) 外部的点互相不连边但是和集合 $S$ 内的点任意连边的方案数，这里貌似只能暴力遍历超集外部的点....前面那个也就没有必要预处理了/fad，复杂度我只能做到 $O(n\cdot 3^n)$，有没有神仙给一个更优的做法啊/fad（比如$O(3^n)$）

代码比较简单就不贴了