题外话：做完这题，感觉自己不会买东西了

#### 题意：

市场上有 $n$ 种商品，每种商品的价格都是 $2$。现在你需要买第 $i$ 种商品 $a_i$ 件。但是对于第 $i$ 种商品有一个属性 $b_i$，意味着如果你已经买了 $b_i$ 件商品（不一定是这一种商品），那么此商品打折，价格会降到 $1$。

你需要最小化你的代价。

其中 $1\le n \le 1\times 10^5,1\le a_i,b_i\le 1\times 10^{14}$。

#### 题解：

数据范围太大，考虑贪心：

我们把每种商品按 $b_i$ 升序排序，现在面临两种局面：

1. 有一种商品可以 $1$ 元买下

此情况下，直接买完这种商品。

注意，如果满足此情况，那么 $b_i$ 最小的商品必然可以 $1$ 元买下。

2. 没有商品可以 $1$ 元买下

此情况下，我们购买 $b_i$ 最大的商品，直到**这种商品买够 $a_i$ 个**或者发现**有新的商品开始打折**。

这个贪心为什么是对的？

第一种情况下，购买这种商品显然不会使答案更劣。

问题出在第二种情况：为何要购买 $b_i$ 最大的商品？

因为如果购买 $b_i$ 小的商品，会发现我们一直买，买完这件商品，后面的商品都未必打折。而购买 $b_i$ 较大的商品很有可能引起前面的物品打折。

#### 复杂度

排序为瓶颈，复杂度 $O(n\log n)$。

#### 代码实现

对 $b_i$ 排序之后，我们可以维护一个**碰撞指针**，从两侧向中间逼近。左、右指针的处理分别对应上述的$1/2$两种情况。

```cpp
#include<bits/stdc++.h>
using namespace std;
namespace Acc{
	const int N = 1e5+10;
#define int long long
	struct node{int a,b;}a[N];
	int z,n;
	void work(){
		cin>>n;
		for(int x,y,i=1;i<=n;i++)cin>>x>>y,a[i]={x,y};
		sort(a+1,a+n+1,[](node x,node y){return x.b<y.b;});
		for(int l=1,r=n,s=0,x;l<=r;)
            if(a[l].b<=s)s+=a[l].a,z+=a[l].a,l++;
			else{
				s+=(x=min(a[r].a,a[l].b-s)),z+=x*2,a[r].a-=x;
				if(!a[r].a)r--;
			}
		cout<<z<<'\n';
	}
#undef int
}
int main(){
	return Acc::work(),0;
}
```