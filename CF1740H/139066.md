首先肯定把树离线下来考虑一个个加点到贡献。

然后分析答案的范围。

记如果要拼凑出 $i$ 这个答案至少要多少个点，不难得出递推式 $f_i = \sum_{j=0}^{i-1}{f_j}+1=(\sum_{j=0}^{i-2}{f_j}+1)+f_{i-1}=2 \cdot f_{j-1}$。

所以实际上 $f_i=2^i$。

那么每个节点的 `mex` 就是 $\mathcal{O}(\log n)$ 的了。

同时不难发现每次我们改动一个点，那么只会改变一条链上点的 `mex`。

所以这启发我们考虑能不能 `ddp`，因为前面对 `mex` 的数量级分析告诉我们跳轻链的暴力更新过程是可以接受的。

考虑如何快速维护重链上的信息，因为题目中是对所有儿子做 `mex`, 所以在重链中每次都只会从下面弄上来一个值的变化，所以这个信息应当是非常好维护的。

因为最多只会引入一个新的值，所以 `mex` 就只会有两种变化情况。

一种是我们重儿子贡献的那个值等于只算轻儿子的 `mex`，那么我们就可以预处理出下一个可能的 `mex`，直接快速更新。

另一种就是重儿子贡献的那个值不等于只算轻儿子的 `mex`，那么就不会有任何影响。

具体的，这相当于我们对一条重链维护一个类似于自动机的信息，他有一个输入代表从底部传入的值，同时有两个输出一个是经过这条重链之后的 `mex`，还有一个是这个重链的 `mex` 的和。

这个自动机一样的信息肯定是可以合并的，稍加分讨即可。

那么就做完了，复杂度 $\mathcal{O}(n \log^2 n)$ 。

需要注意的是每次求出一条重链的值一定要从重链底部到顶部全部查询。