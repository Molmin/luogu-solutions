考虑先读入整棵树，然后重链剖分。

类似 ddp，我们考虑维护一种信息，使得能够在重链上从下往上合并 mex。

把重链顶的 $\operatorname{mex}$ 以及整条重链上的 $\operatorname{mex}$ 和视为一个关于重链最底部叶子的值 $x$ 的函数 $f:\mathbb N\mapsto \mathbb N^2$。当重链长度为 $1$ 时，也就是把点 $y$ 的值视为关于 $son(y)$ 的函数。可以发现，一条重链的函数就是每个点单独的函数从下往上依次复合的结果。

注意，每个点单独的函数 $f(p)$ 总是几乎为常数函数，且总恰有一个与其它位置函数值不同的点。所以 $f(p)$ 的信息量是 $O(1)$ 的。进一步，$f(p)$ 的复合也是 $O(1)$ 的，且复合后也是一样的形式。用线段树维护复合即可。

在链顶处为了更新链顶父亲的函数，需要计算链顶父亲的儿子的权值 mex。你可以用一棵权值线段树，但其实权值不超过 $O(\log n)$，所以暴力计算就好了。

时间复杂度 $O(n\log^2 n)$。

代码：https://codeforces.com/contest/1740/submission/178517969