其实这道题也是比较简单的。

先翻译一下题目：

1. 第 $1$ 步，如果 $a=0$ 或者 $b=0$ ，结束过程。否则，跳到第 $2$ 步。

2. 第 $2$ 步，如果 $a>=2\times b$，则把 $a$ 变成 $a-2\times b$，跳到第 $1$ 步。否则，跳到第 $3$ 步。

3. 第 $3$ 步，如果 $b>=2\times a$ ，则把$b$ 变成 $b-2\times a$，跳到第 $1$ 步。否则，结束过程。

于是这道题我们很轻松的想到模拟。

但是这道题有几个坑。

1. 数据范围是 $1<=n,m<=10^{18}$ ， $int$类型装不下，所以我们必须开 $long$ $long$ 。

2. 我们发现，第 $2$ 步和第 $3$ 步中如果用减法会非常慢，为什么呢？ 

	试想一组极端数据：$a=10^{18},b=1$，那么此时如果一直做减法，则会做 $5\times 10^{17}$次减法，此时肯定会超时。
    
    那我们怎么办呢？还是用上面那组数据，我们发现，我们一直在用 $a$ 去减 $2\times b$ ，直到 $a$ 小于$2\times b$为止，其实就是 $a$ 除以 $2\times b$的余数，不就是取模的运算吗？
    
    所以在减法的过程就直接可以用取模来做就行了，节省了不少时间。
    
于是我们就可以上代码了：

```cpp
#include<bits/stdc++.h>//万能头文件 
using namespace std;
int main()
{
	long long a,b;//注意定义long long 
	cin>>a>>b;
	while(1)//循环 
	{
		if(a==0||b==0) break;//第一步 
		if(a>=2*b) a%=(2*b);//满足第二步的条件 
		if(a==0||b==0) break;//跳到第一步 
		if(b>=2*a) b%=(2*a);//满足第三步的条件 
		if(!(a>=2*b&&b>=2*a)) break;//判断结束条件 
	} 
	cout<<a<<" "<<b;
	return 0;
}
```
完结散花！