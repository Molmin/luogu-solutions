我不会状吖，于是来一点状吖。

题意：给你 $n\le20$ 个以内的括号串，括号串总长度不超过 $4\times10^5$，你可以把这 $n$ 个串重排，问最后构成的最长合法括号序列长度是多少。

我只能膜拜cmll02/bx

你一下子发现这是个状压题，然后你开始思考这个东西怎么状压。

$2^{20}$ 就 $1e6$ 了，于是思考 $n2^n$ 做法。

你观察一个括号串，你记 $'('=1,')'=-1$，你记 $pre_i$ 为这个串的前缀和，你发现如果 $a$ 串和 $b$ 串相连产生了更长的括号序列，必然是这个串的整个串的权值为非负数，设这个非负数是 $k$，那么设 $b_i$ 的 $pre=-k$，而且 $b$ 的 $pre$ 的前缀最小值是 $-k$，为什么要保证前缀最小值也是 $-k$ 呢？因为如果前面有更小的，那么前面的右括号肯定多于过左括号，那么这个连起来的必然不能接起来然后长度加 $k$。

于是你状压，用 $f_0(S)$ 表示集合 $S$ 时，集合 $S$ 连起来不能在后面增加括号串以达到增加答案的情况时的答案，如`(())))`，$f_1(S)$ 表示集合 $S$ 后面还可以增加括号串达到增加答案的情况时的答案，如`(((`。

于是你就得到了一个方程：
```cpp
if(sm[S]+mpre[i]>=0)f[T][1]=max(f[T][1],f[S][1]+g[i][-sm[S]]);
else f[T][0]=max(f[T][0],f[S][1]+g[i][-sm[S]]);//sm表示S集合pre_n总和
```
上式意思就是，如果转移时后面还可以增加，就转移到 $f_{T,1}$ 里，否则转移到 $f_{T,0}$ 里，但注意到无论如何都不可能从 $f_{S,0}$ 中转移出去。

然后注意到有负下标，做一个总体平移即可。

```cpp
#define maxn 400010
int n,len;
char s[maxn];
int pre[20],mpre[20];
int g[20][maxn*2];
int f[1<<20][2],sm[1<<20];
signed main(){
	cin>>n;
	rep(i,0,n-1){
		cin>>s+1;
		len=strlen(s+1);
		mpre[i]=1145141919;
		rep(j,1,len){
			pre[i]+=s[j]=='('?1:-1;
			mpre[i]=min(mpre[i],pre[i]);
			if(pre[i]==mpre[i])g[i][400000+pre[i]]++;
		}
	}
	rep(i,1,(1<<n)-1)
	rep(j,0,n-1)if(i>>j&1)sm[i]+=pre[j];
	rep(i,1,(1<<n)-1)f[i][0]=f[i][1]=INT_MIN;
	int ans=0;
	rep(S,0,(1<<n)-1)rep(i,0,n-1)if(!(S>>i&1)){
		int T=S|(1<<i);
		if(sm[S]+mpre[i]>=0)f[T][1]=max(f[T][1],f[S][1]+g[i][400000-sm[S]]);
		else f[T][0]=max(f[T][0],f[S][1]+g[i][400000-sm[S]]);
	}
	rep(i,0,(1<<n)-1)ans=max(ans,max(f[i][0],f[i][1]));
	cout<<ans;
}
```
被埋伏到了，除空集外的 $f$ 不初始化为 $-\infty$ 的话会出现大问题。