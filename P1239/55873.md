  # 普及减用数位dp？？
真实感受到自己的弱小
## 回归普及难度，~~开始找规律~~
规律（价值->个数）：  
100->11  21 20 20……   
1000->192  301 300  ……  
10000->2893   4001   4000   4000……    
#### 由此拓展      
100里对1有价值的只有1,11,21……和11 12 13 14……最后100   
那么1->10+10+1=21    
1000呢     
百位是1时，有一百个     
十位是1时，有一百个    
个位是1时，有一百个    
1000自带一个     
所以100+100+100+1   
100是10的二次方，1000是10的三次方，观察所加10,100个数发现规律    
并且发现不管是100还是1000里面对1有意义的数都是规律、集中分布的    
并发现2~9都相等->一定范围内可获得价值相等       
200就变成             +20+20,  
2000—>+200+200+200=+(3* 2 )乘100） ……     
//具体看程序 
```
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
inline int read(){
	int ret=0;char c;
	while((c=getchar())<'0'||c>'9');
	while(c>='0'&&c<='9')ret=ret*10+(c-'0'),c=getchar();
	return ret;
}
int  n;
ll a[10];
ll b[10];//c
ll c[10]={0,1};//b{01
ll d[10]={0};//a{0
ll zero[10]={1,11,192,2893,38894};
           //1  2   3   
//规律（价值->个数）：
//100->11  21 20 20……
// 1000->192  301 300  ……
//10000->2893   4001   4000   4000……
// 由此拓展 
//100里对1有价值的只有1,11,21……和11 12 13 14……最后100
//那么1->10+10+1=21
//1000呢
//百位是1时，有一百个
//十位是1时，有一百个
//个位是1时，有一百个
//1000自带一个
//所以100+100+100+1
//100是10的二次方，1000是10的三次方，观察所加10,100个数发现规律
//并且发现不管是100还是1000里面对1有意义的数都是规律、集中分布的
//并发现2~9都相等->一定范围内可获得价值相等
//200就变成+20+20,2000->+200+200+200=+3*（2*100） …… 
//具体看程序 
int main(){
	n=read();
	//规律程序  
	int m=1;
	for(int k=1;k<=10;k++){
		m*=10;
		if(m>n)break;
		if(n==m){
	int x=n/10;
	int y=n;
	int z=0;
	while(y/=10){
	z++;
	}
	//cout<<z<<endl; 
	x*=z;
	int j=10;
	a[0]=x;
	for(int i=1;i<=z-1;i++){
		a[0]-=j;
		j*=10;
	} 
	a[0]=a[0]+z-1; 
	a[1]=x+1;
for(int i=2;i<=9;i++){
	a[i]=x;
	
}
for(int i=0;i<=9;i++)
printf("%lld\n",a[i]);
return 0;}
}
/*int x,y,z;
for(int i=0;i<10;i++){
	int m=1;
	while(m<=n){
		x=n/(m*10);
		b[i]+=x*m;
		if(x!=0&&i==0)b[i]-=m;
		y=(x*10+i)*m;
		if(y<=n&&y!=0){
			z=n-y+1;
			if(z>m)z=m;
			b[i]+=z;}
		m*=10;}}
for(int i=0;i<10;i++){
	if(i!=0)printf("\n");
	printf("%lld",b[i]);
}*/
//正解程序 
int x=0,k;
     k=n;
     while(k>0) {
	 	x++;//存位数 
		b[x]=k%10;
		k/=10;}//取出每一位上的数 
     for(int i=2;i<=9;i++)
	  c[i]=c[i-1]*10;//预存0,1,10,100,1000,10000…… 
     k=n;
     for(int i=x;i>=1;i--)
     {//从最高位往后看 
         for(int j=0;j<=9;j++)//计算0~9每个数能由这一位获得的价值 
		 d[j]+=c[i-1]*(i-1)*b[i];//规律发现的计算价值方法 
		 //比如232，这样就把4~9都直接找出来了，
         //因为此时4~9一样的232最多影响到这个100里多出不是正好成组的3 
		 //例如100（i==3）->10*2*1 
         for(int j=1;j<=b[i]-1;j++) 
		 d[j]+=c[i];
		 //但每一位上的数字不一定是整齐的，还要单独找一遍 
		 /*例如n=232
		 x=3;
		 b[2]=3;
		 这时候b[2]-1=2;发现31里有成组1,2 
		 d[1]+=c[2]…
		 */ 
         d[b[i]]+=k%c[i]+1;
         cout<<"#"<<d[5]<<endl;
        //对于d[3],+=n(232)%100+1 //30 31 32 
     }
     //for(int i=1;i<=x;i++)
	  //d[0]-=c[i];
     for(int i=0;i<=9;i++)
         printf("%lld\n",d[i]);
     return 0;
 }


```