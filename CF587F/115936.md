*3000 。

求串与串之间的包含关系还是很典的，建出 ACAM 的 fail 树以后利用 dfs 序和 size 转到区间操作即可。

每个串都跑一次，然后统计来源的串，复杂度 $O(n^2)$ 。

考虑根号分治，设 $B$ 为根号级别的常数，从母串的长度去分治。

若 $len\ge B$ ，那么这样的串不超过 $B$ 个，对于每个串暴力在 fail 树上加上，然后遍历一遍 fail 树自下而上统计即可，由于 fail 树一共只有 $O(n)$ 个结点，所以这部分的复杂度为 $O(nB)$ 。**这里的 $n$ 指所有字符串的总长度，而不是题目中的 $n$ 个字符串。**

对于 $len < B$ ，考虑类似扫描线的做法，一个个串按顺序在 ACAM 中扫，相当于最后一个字符所在的位置在 fail 树上的子树加，把询问拆成 $[1,r]-[1,l-1]$ 的两个询问，然后每次询问枚举母串的每个字符对于的位置单点查询求和。因为每个母串复杂度只有 $O(B)$ ，所以这部分的复杂度只有 $O(qB\log n+n)$ 。

总的复杂度为 $O(nB+qB\log n+n)$ ，好像有严格根号的做法，但是我暂时不会，多个 $\log$ 也不慢，能在 $1s$ 内跑完。

https://codeforces.com/contest/587/submission/159912094