多模匹配，考虑建出 AC 自动机和 fail 树，可以看出，$s$ 在 $t$ 中出现次数可以看作 $s$ 结束节点在 fail 树中的子树内 $t$ 的所有结束节点出现次数之和。

首先可以对询问差分，将询问区间都转成前缀。

注意到 $\sum |s_i|$ 是有上界的，考虑平衡规划，不难想到对 $|s_k|$ 进行平衡规划，设阈值 $L$。

- $|s_k|>L$，则我们可以对于每个 $i$ 求出 $s_i$ 在 $s_k$ 中出现了多少次，具体的，我们给 fail 树中 $s_k$ 的所有节点都打上标记，然后统计对其他节点统计子树和，这部分的时间复杂度 $\mathcal{O}(\frac{nq}{L})$。
- $|s_k|\leq L$，可以发现，上述统计方式不再奏效，我们考虑倒着统计，对 $s_k$ 统计 $s_{1,\dots,i}$ 的贡献，具体的，我们给 $s_i$ 结束节点的子树 $+1$，最后统计 $s_k$ 所有节点的节点和，即可得到答案。考虑扫描线，每次遍历 $s_k$ 的所有节点获得答案。现在我们要维护一个支持区间加，单点查的数据结构，注意到区间加次数少，查询次数多，考虑使用 $\mathcal{O}(\sqrt n)-\mathcal{O}(1)$ 的分块，复杂度 $\mathcal{O}(q(\sqrt n+L))$。

不难发现，$L$ 取 $\sqrt n$ 时最优，时间复杂度 $\mathcal{O}(q\sqrt n+n\sqrt q)$，空间复杂度 $\mathcal{O}(nc)$。

