多重背包模板题……

------------
## 01背包

**【题目】：** 您现在有$n$个物体，每个物体有一个体积和价值，现在您还有$1$个背包，容积为$C$，求在物体体积之和$\leq C$的前提下，价值之和**最大**为多少？（每种物体只能选**一次或零次**）

**【思路】：** 我们记$f_{i,j}$表示考虑到第$i$个物体，容积为$j$时的最大价值和。现在考虑某物体$k$，容积为$l$的转移状态（$W_i$表示物体$i$的体积，$C_i$表示$i$的价值）：

$(1)$不选$k$，则$f_{k,l}=f_{k-1,l}$

$(2)$选$k$，那么我们只剩下$l-W_k$的容积，可以选$[1,k-1]$中的所有物体，所以转移状态为：

$$f_{k,l}=f_{k-1,l-W_k}+C_k$$

只需在两者间取较大值即可。

**【优化前代码】：**
```cpp
for(int i=1;i<=n;i++)
	for(int j=1;j<=C;j++)
		if (j<w[i]) f[i][j]=f[i-1][j];//第i个物体一定不能更新f[i][j]
		else f[i][j]=max(f[i-1][j],f[i-1][j-w[i]]+c[i]);//尝试用第i个物体去更新f[i][j]
```

**【优化】：** 以上```dp```的时间复杂度和空间复杂度都是$O(N \times C)$，似乎时间复杂度**无法优化**了，所以我们想想如何优化空间复杂度。

事实上，$f_{i,j}$只和$f_{i-1,k}(1\leq k \leq j \leq C)$有关。所以我们可以用**滚动数组**优化。

滚动数组这东西听着很高大上，其实也很简单，因为对于任意$k,l$，如果满足$1 \leq k < i-1,1 \leq l \leq j$，那么$f_{k,l}$一定不能**直接**更新$f_{i,j}$，既然如此，那我们就干脆把$f_{i,j}$直接压缩成$f_{j}$，不就少了一维了吗？

其实，这不知优化了空间，也在一定程度上优化了时间。为什么？因为二维数组的**随机访问**比一维数组的**随机访问**慢得多！

**【注意】：** 我们发现单纯加入优化而不作任何其他修改的$dp$会```WA```，原因很简单：**不保证**每个元素只选了一次或零次！优化后的 ```01背包``` 对容积的循环必须改为**倒序循环**。

**【优化后代码】：**
```cpp
for(int i=1;i<=n;i++)//枚举考虑到第i个物体
	for(int j=C;j>=w[i];j--)//注意枚举顺序
		f[j]=max(f[j],f[j-w[i]]+c[i]);//这转移是不是非常的简单？
```
为什么这样就对了？因为$W_i>0$，所以对于任意的$j$都有$j-W_i<j$，因为我们使用**倒序循环**，所以在更新$f_j$时，$f_{j-W_i}$时并没有被更新，保存的还是原来的$f_{i-1,j-W_i}$的值，所以就达到了异曲同工的效果，而且把空间复杂度降为了$O(C)$。

------------
## 完全背包

```完全背包``` 和 ```01背包``` 其实很相似，就是每种物体可以选**无限个**。其实代码也很像，只需把 ```01背包``` 中的倒序循环又改会**正序循环**即可了。

**【代码】：**
```cpp
for(int i=1;i<=n;i++)
	for(int j=w[i];j<=C;j++)//又变成正序了
		f[j]=max(f[j],f[j-w[i]]+c[i]);
```
------------
## 二维背包

也就是每个物体有**两个**体积了……

一个体积就一维$dp$，那么两个体积就二维$dp$吧！

事实也就是这样……

解释一下开头的**多重背包**是什么东西。你们可以简单的了解为**不止**一维背包。

**【代码】：**
```cpp
for(int i=1;i<=n;i++)
	for(int j=W1[i];j<=C1;j++)//j和k的枚举顺序因题目是01背包还是完全背包而已，这里以完全背包为例
		for(int k=W2[i];k<=C2;k++)//事实上01背包也只是把j和k改为倒序即可……
			f[j][k]=max(f[j][k],f[j-W1[i]][k-W2[i]]+C[i]);
```

------------
**【本题代码】：**

```cpp
int c,w1,w2,i,j,k,n;
int m1,m2,f[550][550];
int main(){
//	freopen("t1.in","r",stdin);
	scanf("%d%d%d",&m1,&m2,&n);
	for(k=1;k<=n;k++){
		scanf("%d%d%d",&c,&w1,&w2);
		for(i=m1;i>=w1;i--)
		for(j=m2;j>=w2;j--)
		f[i][j]=max(f[i][j],f[i-w1][j-w2]+c);
	}
	cout<<f[m1][m2];
	return 0;
}
```
