为什么没有人交这道题...当我点进CF官网时发现..每道题必须用不同的语言提交..果断放弃，不过题解还是要水的
### 题目分析
```
由于该题只是询问每个“条纹”的长度是否相同，所以我们可以直接O(n)算出每条条纹的长度，在这里我选择了用set来维护（set自带去重功能，只要判断最后的大小是否为1即可）
```
### 代码
```
#include<iostream>
#include<set>
using namespace std;
int n,a[100001],top=1;//因为每个0 or 1 对应就算一点长度所以初始化为1
set<int>q;//这里用set维护条纹的长度
int main(){
    cin>>n;
    for(int i=1;i<=n;i++) cin>>a[i];
    for(int i=2;i<=n;i++){
    	if(a[i-1]==a[i]) top++;//如果前一个等于这一个延续该条纹即条纹长度+1
    	else q.insert(top),top=1;//否则将当前条纹长度存入，重置条纹长度
	}
	q.insert(top);//由于最后一个时for循环已退出，所以要把最后一个条纹存入
	if(q.size()==1) cout<<"YES";//如果set内只有一个元素代表条纹的长度都相同输出YES
	else cout<<"NO"; 
    return 0;
}
```
### 另外的做法（用XXX代替set）
- 用类似桶排的思想，定义一个数组q[100001]，具体实现就是定义一个bool类型表示是否为第一个，如果为第一个那么直接存入，否则如果q[top]为假那么输出NO并停止程序，程序的最后输出YES（map也可以实现类似操作，占的空间还小..）
- 以第一个条纹作为基准不断与后面的条纹长度进行比较，实现与上述类似
- ......
------------
