这是一道很简单的模拟。

# 解题思路：

我们定义两个变量 $cnt1$ $cnt2$，分别用于记录上一个连续 $0/1$ 区间的长度和这一个连续 $0/1$ 区间的长度。只要这个连续区间的长度不等于上个区间的长度，那么直接输出`NO`，然后`return 0`就可以了(因为这里不一样后面就无需判断，这是一个小优化)。如果相等，那么 $cnt2$ 清零，重新计算新的连续区间的长度，以此类推计算就可以了。

那么这个过程怎么实现呢？

对于代码实现来说，对于当前的 $a_i$ 来说，分两种情况：

- 如果 $a_i$ 等于 $a_{i-1}$ ，那么说明还在当前的区间中，那么 $cnt2+1$ ，长度加 $1$ 。

- 如果 $a_i$ 不等于 $a_{i-1}$ ，那么按照上面的思路判断就可以了。


这里需要注意一些细节：加一个特判，判断 $cnt1$ 是不是 $0$ ，并在`cnt2=1`前面把 $cnt1$ 修改为 $cnt2$ ，就可以了。然后把 $a_{n+1}$ 赋值为 $2$ ，循环到 $n+1$ 就可以处理最后一次的问题。

ps：一定要从 $2$ 开始循环，要不然会出问题，为什么呢？

因为从 $1$ 开始循环，那么 $a_0$ 的值始终是 $0$ ，我们无法确定 $a_1$ 是零是一，这样就会造成 $cnt$ 错误。

如果大家还是看的不清楚，可以看代码里的注释。

# Code:

```cpp
a[n+1]=2;
for(int i=1;i<=n;i++){
	cin>>a[i];
}
for(int i=2;i<=n+1;i++){
	if(a[i]==a[i-1]){  //如果和上一个数字相同
		cnt2++; //说明这个区间还没有结束，长度++
	}
	else{ //不相同
		if(cnt2!=cnt1&&cnt1){   //与上次长度不相同且不是第一次计数
			cout<<"NO"<<endl;   //NO
			return 0;
		}
		cnt1=cnt2;    //长度赋值，防止出现第一次cnt1=0的情况
		cnt2=1;   //长度清空为1，因为这是新区间的第一个数
	}
}
	cout<<"YES"<<endl;
```

这个写法应该是目前特判比较少的解法了吧。