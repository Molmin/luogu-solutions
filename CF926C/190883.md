嗯...蒟蒻我又来了。
当我看到这道题时，我想着：这题太水了！马上A掉它！（感觉这题马上就变红了

然后，我就调了两天的代码（可能是我太蒻了

在这里感谢一下@[暗夜之光](https://www.luogu.com.cn/user/191748)大佬，Ta的代码给了我一点灵感来简化了我的代码。


------------
一开始,我的思路是酱紫的:直接循环,数字一个一个读,在读的时候特判来记录第一个数的值和第一个条纹的长度。记录上一个数，判断当前数字是否等于上一个数字。然后在当前条纹结束时判断条纹长度是否相同，相同继续；不同就结束。代码就不放了，又臭又长QAQ。
但是，看了@[暗夜之光](https://www.luogu.com.cn/user/191748)的程序后，我发现开始可以这样写：

```cpp
	cin>>n>>x;//x作为第一个数
	for(i=1;i<n;i++)//因为之前输入了一个数,所以i<n
	{
		cin>>a;
      		...
   	}
```
然后就愉快的省去了一次特判QwQ！

当我按照我的思路将代码打出来的时候，#21WA了QAQ，接着我就开始找错误，为什么本地AC交上去就WA呢？~~然后我就找了两天错误点。~~

这里友情提供一下我WA过的数据：
```
2
1 0
YES

2
1 1
YES

3
1 1 0
NO

9
1 1 1 0 0 0 1 1 1
YES

4
1 0 1 1
NO

4
1 0 1 0
YES
```
搞定这些，你就可以AC了。~~（大概吧~~

然后我把我的代码又重新码了一遍，思路在代码里,可能这样讲的更清楚QAQ。

## 喜闻乐见的代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
	int n,a,m=1,m1=-1,b=0,i,x;
	cin>>n>>x;
	for(i=1;i<n;i++)
	{
		cin>>a;
		m++;
		if(a!=x)//如果和上一个数不一样
		{
			x=a;//记录
			if(m1==-1)//第一次
			{				
				m1=m-1;//记录
				if((i==n-1)&&(n!=2))//n=2的情况要特判 
				{
					cout<<"No";
					return 0;
				}
				m=0;//归零 
				continue;
			}
			if(m1!=m)//条纹长度不一样
			{
				cout<<"NO";
				return 0;//超度它(物理上的 
			}
			else
			m=0;//记得清零! 
		}
		if(i+1==n)//这里要特判一下最后一个数 
		{
			if(a==x)
			m++;
			if((m!=m1)&&(m1!=-1))//判断下最后是不是条纹长度不一且m1被更改过 
			{
				cout<<"NO";
				return 0;
			}
		}
	}
	cout<<"YES";//能到这就是真的斑马(假斑马会在路上暴毙 
	return 0; 
}
```
这个代码特判~~有点多~~非常多，所以以后有时间可能会再重新码一次特判少亿点的代码。