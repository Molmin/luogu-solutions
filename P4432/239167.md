题目很简单，就是给定一个首字母，输出这个首字母对应的出现次数最少、字典序最小的字符串

分析题目我们可以得到，对于每一个字符串，**只要它被输出一次，它的优先级就会降到最低而排在最后面**  

所以我们可以用一个二维队列，用二维队列的下标对应字符串的首字母，先按字典序将所有字符串插入到队列中，每次询问直接输出队头的字符串，然后将队头的字符串扔到队尾,不停循环,就可以达到目的，因为我们循环都是按顺序的，所以不管怎么操作都是字典序

~~(其实vector的写法空间更小时间更快，但是我是个懒狗，就直接用队列模拟了)~~

下面是代码详解
```cpp
#include<bits/stdc++.h>
using namespace std;

int n, k;
string str[100005];
queue<string> q[128];
//c++中ASCII码是从0~127,所以定一个128大小的二维队列就ok

int main()
{
	scanf("%d%d", &k, &n);
	for(int i = 1; i <= k; i++)
		cin >> str[i];
	sort(str+1, str+k+1);//string类型可以直接用'<'、'>'进行操作,直接sort是没有问题的
	for(int i = 1; i <= k; i++)
		q[str[i][0]].push(str[i]);//把每个字符串按下标入队
	for(int i = 1; i <= n; i++)
	{
		char ch[3];
		scanf("%s", ch);
		//你谷的getchar()有毒,我用getchar()读字符RE一片,换成读入字符串就AC了...
        
		cout<<q[ch[0]].front()<<endl;//输出给定字符对应的字符串
		
		q[ch[0]].push( q[ch[0]].front() );//让这个字符串再次从队尾入队
		q[ch[0]].pop();//这个字符串出队
	}
    return 0;//愉快的AC了!
}
```