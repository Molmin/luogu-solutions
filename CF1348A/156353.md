[个人博客食用可能更佳](https://156353.blog.luogu.org/solution-cf1348a)
## 题目大意
有n个数字为$2^1,2^2,2^3 ,......, 2^n$，将这些数字分为个数相等的两拨，求这两拨数字的和的差的最小值。
## 思路
我们可以把它看成二进制, $2^1,2^2,2^3......2^n$ 就是 $(1)_2,(10)_2,(100)_2......(1\overbrace{000...000}^{n*0})\tiny\text{注：因为这个latex插入中文会有问题,所以"*"用"个"代替了}$

因为一个进制的高位数一定大于它的低位数之和，而如果要让两组差最小的话那么就要最小的 $n-1$ 个 $2^i$ 。

#### 举个栗子:

$n=6$

$2^1,2^2,2^3,2^4,2^5,2^6$

那么 $2^6$ 一定是最大的，所以要把最小的给它。

就是: $2^1,2^2,2^6$

然后答案就是$(2^1,2^2,2^6)-(2^3,2^4,2^5)=14$

## 代码
```
#include<bits/stdc++.h>
using namespace std;
int main()
{
	int t;
	cin>>t;
	while(t--)
	{
		int n,a=0,b=0;
		cin>>n;
		a=2<<(n-1);
		for(int i=1;i<n/2;i++)//把最小的n-1个2^i给最大的
		{
			a+=2<<(i-1);
		}
		for(int i=n/2;i<n;i++)//把剩下的加起来
		{
			b+=2<<(i-1);
		}
		cout<<a-b<<endl;//因为a里有最大的，所以a一定>b
	}
	return 0;
}
```