这题一看就知道要用DFS，其实也可以算作是一题新手练手题吧，练练DFS

有人说可以暴力？！反正我只会DFS……

第二篇题解，各位神犇dalao们请谅解（好像两篇都是DFS?）

废话不多说，下面奉上我的AC代码（具体说明见注释）：

```cpp
#include<cstdio>
#include<algorithm>//头文件，min和abs在algorithm中（STL大法好）！
struct perket//定义结构体
{
    int sour,sweet;//sour表示酸度，sweet表示甜度
}a[11];//配料
int s=1,w,ans=2147483646,n;//ans一开始开2147483647莫名RE，用2147483646就好了。。。。。。
long long ok;//ok表示所用配料数
inline void read(int &a)//这里详细解释一下快速读入，inline的作用为加快该函数所用时间，注意：若不止一个输入输出文件，则不可用inline！
{
    char c;//定义字符存储变量
    int k=1;a=0;//定义系数（初始为1）与所读入变量
    c=getchar();//读入字符
    while(c<'0'||c>'9'){if(c=='-')k=-1;c=getchar();}//如果该字符不为数字，跳过该字符，注意：由于本题有负数，所以要加判断是否为-号，如为-号，系数变为-1
    while(c>='0'&&c<='9'){a=a*10+c-'0';c=getchar();}//如果该字符为数字，原数*10+该字符-‘0’,其实*10+是特别特别有用的一个东西，不在这里详细论述，以后有时间的话会专门发一篇文章来解释*10+与其作用
    a*=k;//原数乘上系数
}
inline void print(int a)//快速输出
{
    if(a>10)print(a/10);//如果当前该数超过10，输出除个位外部分
    putchar(a%10+'0');//输出个位
}
void DFS(int i)//DFS，i表示当前搜索到第i个配料
{
    if(i==n+1)return ;//如果全部搜索完毕，回溯
    s*=a[i].sour;//当前酸度乘上该配料酸度
    w+=a[i].sweet;//当前甜度加上该配料甜度
    ok++;//所用配料数+1
    ans=std::min(ans,abs(s-w));//更新答案，取原答案与甜酸度之差的最小值，有人说可以加一个特判：当ans=0时，直接输出！我没有这么做，因为个人感觉没啥用
    DFS(i+1);//向下继续搜索
    s/=a[i].sour;//当前酸度除以该配料酸度
    w-=a[i].sweet;//当前甜度减去该配料甜度
    ok--;//所用配料数-1
    //这里解释一下：递归之前改变的值，递归过后一定要改回原值，即使你不再向下搜索，这也是递归的基本特征之一！！！
    DFS(i+1);//向下继续搜索，这是为了保证答案的全面性
}
int main()
{
    read(n);
    for(int i=1;i<=n;i++){read(a[i].sour);read(a[i].sweet);}//输入，不解释
    DFS(1);//DFS，从第一种配料开始搜索
    print(ans);//输出答案
}
```
#最后，强调一下：禁止抄袭！禁止抄袭！禁止抄袭！

~~求洛谷一定要给过！~~
