- [博客食用更佳](https://www.luogu.com.cn/blog/yx20070829/solution-cf43c)
- 首先说思路
1. 暴力搜索
	- 不行的#12超时~~，试过了~~
2. 简单贪心
	- 小定理：x%3=0 , y%3=0 , 则(x+y)%3=0 ; (x%3+y%3)%3=0 , 则(x+y)%3=0。 
	- 不难推出来，举个例子：
		 - 6%3=0,9%3=0 , 则(9+6)%3=0。
		 - (5%3+8%3)%3=0 , 则(5+8)%3=0
		 - 实际上这与小学学的3的倍数的各位和是3的倍数有关
	- 有兴趣可以自己推一下
	- 如何使用：
		1. 读入
		2. 统计%3为0，%3为1，%3为2的分别个数
		3. 先用第一条定理，将%3为0的数两两匹配能组成3的倍数的数统计出来
		4. 接着用第二条定理，将%3为1/2的数两两匹配能组成3的倍数的数量统计出来
		5. 输出答案
	- 代码：
   
   ```cpp
	#include<bits/stdc++.h>	//懒人万能库
	using namespace std;
	int a[3],n,ans; //a数组用桶排计数，n为元素个数，ans就是答案
	int main()
	{
		scanf("%d",&n);//读入没得说
		for(int x,i=1;i<=n;i++)
		{
			scanf("%d",&x);//读入一个元素
			a[x%3]++;//统计%3后的数量
		}
		while(a[0]>=2)//第一条定理，首先保证能两两配对
		{
			ans++;//答案++
			a[0]-=2;//减去两个配对完成的元素
		}
		while(a[1]>=1&&a[2]>=1)//第二条定理，保证每个至少一个，才能配对
		{
			ans++;//答案++
			a[1]--;//减去元素
			a[2]--;
		}
		printf("%d",ans);//输出
		return 0;
	}
	```
3. 在贪心上改进
	- 不难看出上面的代码主要运算有两个部分，也就是上文的两个定理所产生的代码
	- 首先看第一部分
    
	```cpp
	while(a[0]>=2)
	{
		ans++;
		a[0]-=2;
	}
	```
	- 可以改进为ans+=a[0]/2
		- 只要求出两两配对的极限就可以
   - 第二部分同理可以改成ans+=min(a[1],a[2]);
		- 因为是%1的和%2的配对，配对数量自然就是最小值
   - 改进完成代码：
   
   ```cpp
	#include<bits/stdc++.h>	
	using namespace std;
	int a[3],n,ans; //同上
	int main()
	{
	    scanf("%d",&n);//读入
	    for(int x,i=1;i<=n;i++)
	    {
			scanf("%d",&x);
			a[x%3]++;//桶排
		}
		ans=min(a[1],a[2])+a[0]/2;//将上面代码改进
		printf("%d",ans);//输出
		return 0;
	}
	```
