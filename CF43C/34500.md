### 数学题

- **推导**


首先看到
>输出最多有多少个 **_3的倍数_**

既然是3的倍数，那我们来回顾一下小学奥数中3的倍数规律：
>
> 3的倍数的各位数之和为3的倍数

那么我们可以用除以3的余数将所有数分类   
余数分别可能有：0、1、2

- 对于余数为0的数，本身就是3的倍数  
- 对于余数为1的数，可以与余数为2的数拼接让余数变为（1+2）%3=0，即可通过拼接变为3的倍数   
- 对于余数为2的数，同理

由此可以开一个ys数组，存储每种类别数的个数  
我们统计一下每一个数的类别，保存于ys数组就可以了

```
#include<bits/stdc++.h>
using namespace std;
int ys[5],n,α;
int main()
{
	cin >> n;
	for(int i=1;i<=n;i++)
		cin >> α,ys[α%3]++;//%3可得出类别
	cout << ys[0]+min(ys[1],ys[2]) << endl;
   //ys[1]的数可以和ys[2]的数拼接，但是其中多处来的就没有办法得出3的倍数，故此取min
	return 0;
}
```
没毛病是不是？交一下试试会发现第1个点就错了。

怎么回事？

看题目：
>没有进行匹配的数不算   
>没有进行匹配的数对答案没有贡献

那可怎么算啊？  
想想，每次需要凑出3的倍数，也可以由2个3的倍数相加而得

所以将ys[0]除以2就可以啦

真正的代码：
```
#include<bits/stdc++.h>
using namespace std;
int ys[5],n,α;
int main()
{
	cin >> n;
	for(int i=1;i<=n;i++)
		cin >> α,ys[α%3]++;//%3可得出类别
	cout << ys[0]+min(ys[1],ys[2]) << endl;
   //ys[1]的数可以和ys[2]的数拼接，但是其中多处来的就没有办法得出3的倍数，故此取min
	return 0;
}
```
~~珍爱生命，请勿复制~~   
~~这反作弊做得好~~