写一个题解没有的思路。

说实话，这题真的很水。

只能说挺有意思的一道题吧。

题目描述：

0 维空间的元素是点，这个毋庸置疑。

2 个 0 维空间的元素可以围成一个 1 维空间的元素，线段。

4 个 1 维空间的元素可以围成一个 2 维空间的元素，正方形。

6 个 2 维空间的元素可以围成一个 3 维空间的元素，正方体。

8 个 3 维空间的元素可以围成一个 4 维空间的元素，超正方体。

$\cdots$

一个正方形中，有 4 个（顶）点，4 条线段（边），1 个正方形。

一个正方体中，有 8 个（顶）点，12 条线段（棱），6 个正方形（面），1 个正方体。

$\cdots$

我们的问题是：给出 $a$ 与 $b$，请求出：在a维空间的元素中，包含着多少个 $b$ 维空间的元素。答案可能很大，只需要输出它除以 1000000007 的余数。

看到这题我们第一眼当然想到找规律。

首先，一个很显然的规律：一个 $x$ 维空间的元素需要 $2 \times x$ 个 $x - 1$ 维的元素组成。

那么根据这个规律，我们就会想，那四个一维元素组成一个二维元素，一维元素有 2 个顶点 1 条边，那二维元素应该有 8 个顶点 4 条边呀？为什么它只有 4 个顶点 4 条边呢？

看到点少了，我们自然想到容斥。

从容斥角度思考，我们发现有一些低维的元素是被重复利用的，比如零维的点，在一维上一个零维点引导一条一维线段，在二维上一个零维点引导两条二维线段，在三维上引导三条。然后我们继续扩展，发现一维线段也被更高维度的元素重复利用，在二维上一条一维线段属于一个面，在三维上属于两个面。

于是我们得到了很简单的性质：一个 $x$ 维的元素在 $n$ 维会被 $(n - x)$ 个$(x + 1)$ 维的元素利用。

由此我们再根据一开始退的规律：一个 $x$ 维空间的元素需要 $2 \times x$ 个 $x - 1$ 维的元素组成，直接将需要多少元素倒着递推过去即可。

总之就是一个 $x$ 维的东西在 $n$ 维会被 $(n - x)$ 个 $(x + 1)$ 维的东西用 

具体看代码理解吧。

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<cstdlib>
#include<cmath>
#define int long long
#define rad scanf
using namespace std;
const int mod = 1e9 + 7, kM = 1e6 + 10;
int shu[kM], inv[kM], a, b;
void init()
{
	inv[0] = inv[1] = 1;
	for(int i = 2; i <= a - b; i++)
	{
		inv[i] = ((mod - mod / i) * inv[mod % i] + mod) % mod;
	}
}
signed main()
{
//	freopen("course.in", "r", stdin);
//	freopen("course.out", "w", stdout);
	rad("%lld%lld", &a, &b);
	if(b > a)
	{
		cout<<0;
		return 0;
	}
	init();
	int base = b * 2;
	int shu = 1;
	for(int i = a; i >= b + 1; i--)
	{
		shu = shu * (((2 * i) * inv[(a - (i - 1))]) % mod) % mod;
	}
	cout<<(shu + mod) % mod;
	return 0;
}
/*
3 1
*/
```
