这题有两种~~不正经的~~方法。

## Sol. 1
列表！找规律！

|  | 零维 | 一维 | 二维 | 三维 |
| :----------: | :----------: | :----------: | :----------: | :----------: |
| 包含零维 | $1$ | $2$ | $4$ | $8$ |
| 包含一维 | $0$ | $1$ | $4$ | $12$ |
| 包含二维 | $0$ | $0$ | $1$ | $6$ |
| 包含三维 | $0$ | $0$ | $0$ | $1$ |
首先，很明确，若 $a<b$ ，输出 $0$ 。

在我的一番猜 (luan) 想 (zuo) ，推 (xia) 倒 (gao) 后，找到了规律：

$$C_a^b×2^{a-b}$$

~~别问我咋搞的，累死了~~

大家读到这里应该就要去写了吧。慢着！还没证明~~贴代码~~呢！
## Sol. 2(Proof)
首先，考虑 $C_a^b$ 的意思。

都知道这是 $a$ 维正方体，要问有多少$b$维正方体，那么至少得先从这 $a$ 个维度中选出 $b$ 个来构造对吧。

这就很容易解释 $C_a^b$ 的意思了。

其次，考虑 $2^{a-b}$ ，这玩意很难想。

考虑从 $a-1$ 维到 $a$ 维时增加的 $b$ 维的数量。

设在 $a-1$ 维中有 $x$ 个 $b$ 维正方体。

可以想象 $a-1$ 维到 $a$ 维是 $a-1$ 维正方体移动的过程。

移动后两端是两个 $a-1$ 维正方体。所以 $a-1$ 维中已有的 $b$ 维正方体数量会变成两倍。

由于 $b$ 维中 $b$ 维正方体有 $1$ 个， $b+1$ 维有 $2^1$ 个， $\dots$ ， $a$ 维中就有 $2^{a-b}$ 个。

将两个相乘即可。

~~证明真繁琐，结论真简单~~

## Code

你们猜猜复制粘贴有用吗？
```cpp
#include <bi/*防抄袭标识*/ts/stdc++.h>
#defin/*防抄袭标识*/e int long long
using nam/*防抄袭标识*/espace std;
int const MOD = 1/*防抄袭标识*/e9 + 7;  
int con/*防抄袭标识*/st MAX = 200000;  
int fac[MAX + 5], inv_fac[MAX + 5];   
 //预处理阶乘
int q/*防抄袭标识*/pow(int x, int n)  {  
    int res = 1;  
    wh/*防抄袭标识*/ile(n){  
        if(n & 1)  
            re/*防抄袭标识*/s = (res * x) % M/*防抄袭标识*/OD;  
        x = (x * x) % MO/*防抄袭标识*/D;  
        n >>= 1;  
    } /*防抄袭标识*/ 
    ret/*防抄袭标识*/urn res;  
}  
//阶乘逆元 
vo/*防抄袭标识*/id pre()  {  
    fac[0] = 1;  
    f/*防抄袭标识*/or(int i = 1; i <= MAX; i++)  
        fac[i] = (fac[i/*防抄袭标识*/ - 1] * i) % MOD;  
    inv_fa/*防抄袭标识*/c[MAX] = qp/*防抄袭标识*/ow(fac[MAX], MOD - 2);  
    for(int i = MAX - 1; i >= 0; i--)  
        inv_fac[i] = (inv_/*防抄袭标识*/fac[i + 1] * (i + 1)) % MOD;   
}  
//C
int C(int a,int b){
	ret/*防抄袭标识*/urn ((/*防抄袭标识*/fac[a]*inv_fac[a-b])%M/*防抄袭标识*/OD*i/*防抄袭标识*/nv_fac[b])%MO/*防抄袭标识*/D;
}
sign/*防抄袭标识*/ed mai/*防抄袭标识*/n(){
	in/*防抄袭标识*/t a,b;
	cin>/*防抄袭标识*/>a>>b;
	p/*防抄袭标识*/re();
	if(a/*防抄袭标识*/<b){
		c/*防抄袭标识*/out/*防抄袭标识*/<<0;
		retu/*防抄袭标识*/rn 0;
	}
	//C_a^b * 2^(a-b)
	cout<<(/*防抄袭标识*/C(a,b)*qp/*防抄袭标识*/ow(2,a-b))%M/*防抄袭标识*/OD;
	retur/*防抄袭标识*/n 0;
}

```