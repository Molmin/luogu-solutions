## 分析

首先我们先分析最简单的情况：

1、如果$n$个数都是正序排列，那么肯定是没有逆序的情况的。

2、如果$n$个数全部都是逆序排列，那么每个数都比后边的数大，也就是逆序。那么很容易就能知道这种情况下一共有$1+2+3+……+n-1$种。

根据以上两个基础情况，我们就可以推出来动规状态转移方程：

我们定义$f[i][j]$数组表示前$i$个数组成的序列，共有$j$个逆序对的情况数，那么根据上边的情况，首先是一号方程：

$$f[i][j] = f[i-1][j]+f[i-1][j-1]+...+f[i-1][j-i+1]$$
这里表示的是前$i$个数组成的有$j$个逆序对的情况就是前$i-1$个数的所有可能的情况求和。因为现在$i$是最大的数，所以我们把$i$放到$1\to i-1$的序列中，可以让$i$的位置改变从而增加$0\to i-1$对逆序对，那么一号方程就求出来了。

然后是二号方程：
$$f[i][j-1] = f[i-1][j-1]+f[i-1][j-2]+...+f[i-1][j-i]$$
其含义与一号方程一样，就是逆序对个数减少了一个，我们把一号和二号方程合并，就能够得出来总的方程：
$$f[i][j] = f[i-1][j]+f[i][j-1]-f[i-1][j-i]$$
这就是状态转移方程。

唯一需要注意的一点就是：因为状态转移方程最后需要减去一个$f[i-1][j-i]$，所以必须保证$i\le j$避免出现负数下标，同时在循环的过程中，我们应该记录前$i$个数总的方案数，假如逆序对个数$j$比他大，那么就直接跳出当前的循环，也算一种时间效率的优化吧。

## 代码
```cpp


#include<bits/stdc++.h>
using namespace std;
const int maxn = 1e2+10;
int f[maxn][maxn*maxn];
int sum,n,k;
const int Mod = 10000;
int main(){
	scanf("%d%d",&n,&k);
	for(int i=1;i<=n;++i){
		f[i][0] = 1;//初始化正序时没有逆序对的情况数为1
	}
	for(int i=1;i<=n;++i){
		sum+=i-1;//前i个数u最大逆序对数
		for(int j=1;j<=k;++j){
			if(j>sum)break;//当前逆序对比最大情况还要大就跳出循环
			f[i][j] = (f[i-1][j]+f[i][j-1])%Mod;
			if(j>=i)
				f[i][j] = (f[i][j]-f[i-1][j-i]+Mod)%Mod;//记得边加边取模
		}
	}
	printf("%d",f[n][k]);
	return 0;
}

```