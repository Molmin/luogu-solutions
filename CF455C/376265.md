以下的 “ 树 $x$ ”均代指 $x$ 节点所在的树。

### 题意：

$n$ 个点 $m$ 条边的一个森林，共 $q$ 次询问，做以下两种操作：

1.输出 树 $x$ 的直径。

2.将 树 $x$ 和 树 $y$ 的某两个点之间连边形成新树，要求这个新树的直径最小（若两者本来就在同一棵树中则忽略此操作）。

$1 \leqslant m < n \leqslant 3 \cdot 10^5$

$1 \leqslant q \leqslant 3 \cdot 10^5$

### 解法：

#### 暴力解法：

首先我们考虑暴力做法：

关于判断两个点是否在一棵树中，很明显用并查集维护。

预处理：每棵树用两次 dfs 求树的直径，时间复杂度为 $O(n)$ 。

对于操作一：可以用两次 dfs 求树的直径 ，单次复杂度为 $O(n)$ ，执行 $q$ 次复杂度为 $O(nq)$ 。

对于操作二：枚举两棵树中的每一个节点，连边之后求树的直径，找到最小直径的连边方式。单次复杂度为 $O(n^3)$ ， 执行 $q$ 次复杂度为 $O(n^3q)$ 。

总复杂度为 $O(n^3q)$ 。

#### 优化算法：

观察数据范围不难发现这题需要在 $O(n)$ 或 $O(n\log n)$ 的复杂度内完成，$O(n\sqrt{n})$ 就基本卡不过了。

所以我们需要找到暴力算法的瓶颈：

预处理是 $O(n)$ 的，复杂度很优秀，所以瓶颈处于两种操作。

目标很明确了：如何快速算出一棵树的直径，并找到两棵树合并后直径最小的连接方式。

我们不妨把两棵树的直径抽离出来分析，观察下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/aowbesq7.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

这是一棵直径为 3 与一棵直径为 2 的两棵巨树。

手玩这个小样例，不难发现当树的直径为 $siz$ 时，第 $i$ 个点可以把一棵树的直径划分为 $i - 1$ 和 $siz - i + 1$ 两部分。

所以树直径的公式就为 $\max(siz_1 , siz_2 , \min(\max(i - 1 , siz_1 - i + 1) + \max(j - 1 , siz_2 - j + 1) + 1))$ 。

对这个式子进行分析，发现当 $i , j$ 都取直径中点的时候新树直径最小，此时新树的直径的公式为 $\max(siz_1 , siz_2 , \lceil \frac{siz_1}{2} \rceil +\lceil \frac{siz_2}{2} \rceil + 1)$ 。

到此为止，我们就找到了操作 1 和 2 的 $O(1)$ 处理方式了：用 $str[i]$ 表示 树 $i$ 的直径大小，然后动态使用公式维护新树的直径即可。

[Code](https://www.luogu.com.cn/paste/wa4y4sxd)

#### 时间复杂度：

并查集带 $\log n$ 的复杂度，其他的单次操作复杂度 $O(1)$ ，操作次数为 $q$ 次。

总复杂度为 $O(q \log n)$ 。

#### 总结：

这道题是很常规的森林中两棵树的合并问题，关键在于发掘合并的性质。

虽然是蓝题但是算比较简单的那一类，完全可以放在提高组第一题。这题应该是和廊桥分配难度差不多。

还有种树的合并方式叫启发式合并，也很有意思，这里只是提一下不多做赘述。