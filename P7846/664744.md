这道题我不知道怎么评价，调了我一天，结果是数组开小了......

# solution

- 这道题有两个问，分别求组合的总方案数和最小情况。以下记 $m$ 为题目中的 $R$。

### Q1

- 对于第一个问题，先引入一个小背景：需要构造一个序列，要求相邻两个数不能相同，求可能的方案数，设序列长度为 $n$，值域为 $m$。

- 这是很经典的排列组合的问题（不知道算不算），序列的第一个数肯定是有 $m$ 个选择，因为第二个数要和第一个数不同，所以第二个数有 $m-1$ 个选择，第三个也是有 $m-1$ 个选择......以此类推（感性理解一下）。把序列每个位置可选择的方案数用数组 $a$ 存下，则 $a_{1}=m$，其余为 $m-1$。设答案为 $ans$，则有以下式子：
$$ans=\prod\limits_{i=1}^na_{i}$$

- 这个弄懂之后第一问也就迎刃而解了，读懂题目其实就会发现跟这个没什么区别。其中，$t_{i}=0$ 时就是刚刚那个问题，答案乘上 $r-1$ 即可； $t_{i}=1$ 时没有限制，那么也是有 $r$ 个选择，答案乘上 $r$ 即可；$t_{i}=2$ 时要求相同，也就是被上一个选择限制了，也可以理解为选择数为 $0$，答案乘上 $1$ 就行。

- 这个问题的实现把整颗树遍历一遍，判断边权即可。

### code

```cpp
void dfs(int a,int la){//la是a的父亲节点
	if(a==1) f[a]=m; //根节点没有限制直接赋值为m 
	for(int i=h[a];i;i=d[i].n){
		int b=d[i].b,c=d[i].c;
		if(b!=la){//防止重复遍历
			dfs(b,a);
			if(c==0) f[b]=m-1;
			if(c==1) f[b]=m;
			if(c==2) f[b]=1;//这里也可以选择直接乘
		}
	}
}//这里的代码只是把每个位置的选择存了下来，所以最后要遍历一次f数组乘起来
```

### Q2

- 第二个问题就是标准的树形 dp 啦，定义数组 $f1_{i,j}$ 表示 $i$ 节点点权选 $j$ 的最小总和。

- 显然，$f1_{i,j}$ 的值与 $i$ 的儿子节点有关系，即由叶子结点向根传递，定义 $i$ 点的某个儿子节点为 $b$。

1. 当 $t_{i}=0$ 时，要求是选的值不能相同，那么枚举每种可能的值，即枚举 $f1_{i,j}$ 中的 $j$，在 $i$ 节点的每个儿子节点中找出所有 $f1_{b,p}(j \ne p)$，取出最小值，累加进 $f1_{i,j}$ 即可。

1. 当 $t_{i}=1$ 时，没有限制，那么在每个儿子节点中找出 $\min \{f1_{b,p}\}(1 \le p \le m)$ 累加即可。

1. 当 $t_{i}=2$ 时，要求值相同，那么直接把 $f1_{b,j}$ 的值直接累加进 $f1_{i,j}$ 中即可。

- 最后别忘了每个状态都要加上自己的值。

### code

```cpp
void check(int a,int la){
	for(int i=1;i<=m;i++) f1[a][i]=i;//先加上自己的值
	for(int i=h[a];i;i=d[i].n){
		int b=d[i].b,c=d[i].c;
		if(b!=la){
			check(b,a);
			if(c==0){
				for(int j=1;j<=m;j++){
					int sum=1e9;
					for(int p=1;p<=m;p++){
						if(j==p) continue;//不选相同的
						sum=min(sum,f1[b][p]);
					}
					f1[a][j]+=sum;
				}
			}
			if(c==1){
				for(int j=1;j<=m;j++){
					int sum=1e9;
					for(int p=1;p<=m;p++){
						sum=min(sum,f1[b][p]);//任意最小值
					}
					f1[a][j]+=sum;
				}
			}
			if(c==2){
				
				for(int j=1;j<=m;j++){
					f1[a][j]+=f1[b][j];//只能选相同的
				}
			}
		}
	}
}
```

- 但是以上代码的最坏复杂度是 $\mathcal {O}(nR^2)$，必然超时，因此考虑对 $t_{i}=0$ 及 $t_{i}=1$ 的情况进行优化（~~当然你也可以选择吸氧直接过~~）。

- 先看 $t_{i}=1$ 的情况，仔细观察就会发现每次遍历都是一样的内容，和遍历一次没有区别，因此一次遍历就将最小值存下，再循环赋值。

- 思考一下就会发现若按照 $t_{i}=1$ 的情况先找最小值，其实在 $t_{i}=0$ 时整个值域中只有一个状态不会累加进最小值，其余都会累加进，所以我们再记录个次小值给这个不累加最小值的状态即可。

### code

```cpp
void check(int a,int la){
	for(int i=1;i<=m;i++) f1[a][i]=i;
	for(int i=h[a];i;i=d[i].n){
		int b=d[i].b,c=d[i].c;
		if(b!=la){
			check(b,a);
			if(c==0){
				int sum1=1e18,sum2,w1,w2;//sum1是最小值，sum2是次小值，w1记录最小值的下标，w2记录次小值的下标
				for(int j=1;j<=m;j++){
					if(f1[b][j]<sum1){
						w2=w1,w1=j;
						sum2=sum1;
						sum1=f1[b][j];
					}
					else if(f1[b][j]<sum2) sum2=f1[b][j],w2=j;
				}
				for(int j=1;j<=m;j++){
					if(j!=w1) f1[a][j]+=sum1;
					else f1[a][j]+=sum2;
				}
			}
			if(c==1){
				int sum=1e18;
				for(int j=1;j<=m;j++){
					sum=min(sum,f1[b][j]);
				}//这里一次遍历找最小值
				for(int j=1;j<=m;j++){
					f1[a][j]+=sum;
				}
			}
			if(c==2){
				for(int j=1;j<=m;j++){
					f1[a][j]+=f1[b][j];
				}
			}
		}
	}
}
```
- 整个代码复杂度为 $\mathcal {O}(nR)$，全部代码就不给了，可能是昨晚做了 [P4084](https://www.luogu.com.cn/problem/P4084) 的原因，思考时一直是以 $R=3$ 的例子想的，搞得我写代码 $f1$ 数组第二维只开了 $5$，这点小问题调了一天（[做题记录](https://www.luogu.com.cn/record/list?pid=P7846&user=664744&page=1)）。