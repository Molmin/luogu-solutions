典型的区间类动态规划题，当然要用迪屁喽！


这是一道区间dp十分经典的模板题，让我们揣测一下，前辈们是如何得到这个状态转移方程的。

首先，要计算合并的最大值、最小值，既然是动态规划，我们需要洞悉其中一些关联且确定的状态。

以下以最大值为例。

既然是最大值，那么求得的结果是否满足每一区间都是该区间所能达得到的的最大值？

显然是这样的。反证法：倘若有一个区间不是，那么换做该区间取得最大值的方案，最终结果将比原得分大。显然必定满足任意区间得分一定是该区间内的最大值。

这样我们可以定义状态f[i][j]，表示i到j合并后的最大得分。其中1<=i<=j<=N。

既然这样，我们就需要将这一圈石子分割。很显然，我们需要枚举一个k，来作为这一圈石子的分割线。

这样我们就能得到状态转移方程：

f[i][j] = max(f[i][k] + f[k+1][j] + d(i,j));其中，1<=i<=<=k<j<=N。

d(i,j)表示从i到j石子个数的和。

那么如何编写更快的递推来解决这个问题？

在考虑如何递推时，通常考虑如下几个方面：

是否能覆盖全部状态？

求解后面状态时是否保证前面状态已经确定？

是否修改了已经确定的状态？

也就是说，在考虑递推顺序时，务必参考动态规划的适应对象多具有的性质，具体参考《算法导论》相关或百度百科或wiki。

既然之前说过我们需要枚举k来划分i和j，那么如果通过枚举i和j进行状态转移，很显然某些k值时并不能保证已经确定过所需状态。

如，i=1 to 10,j=1 to 10,k=1 to 9.当i=1,j=5,k=3时，显然状态f[k+1][j]没有结果。

那么，我们是不是应该考虑枚举k？

但这样i和j就难以确定了。

我们不难得到一个两全的方法：枚举j-i，并在j-i中枚举k。这样，就能保证地推的正确。 By TIMI_k 

上代码[cpp] By myself
`````cpp
#include<iostream>
using namespace std;
const int maxn=205,MAX=0x7fffffff/2; //MAX：可以看做无穷大
int f1[maxn][maxn],f2[maxn][maxn],s[maxn][maxn]={0};
int a[maxn],sum[maxn]={0},n,i,ans1,ans2;
void init()
{
	cin>>n;
	for(i=1;i<=n;i++){cin>>a[i];a[i+n]=a[i];}
	for(i=1;i<=n*2;i++){sum[i]=sum[i-1]+a[i];f2[i][i]=0;f1[i][i]=0;}
}
void dp()
{
	int j,k,L,ans;
	for(L=2;L<=n;L++)	//以合并的堆数为阶段 
	  for(i=1;i<=2*n-L+1;i++) //合并的起始位置 
	  {
	  	j=i+L-1; //合并的结束位置 
	  	f1[i][j]=0x7fffffff/2;f2[i][j]=0;
	  	for(k=i;k<j;k++)
	  	{
	  	   f1[i][j]=min(f1[i][j],f1[i][k]+f1[k+1][j]);
	  	   f2[i][j]=max(f2[i][j],f2[i][k]+f2[k+1][j]);
		}
		f1[i][j]+=sum[j]-sum[i-1];
		f2[i][j]+=sum[j]-sum[i-1];
	  }
	  ans1=0x7fffffff/2,ans2=0;
	  for(i=1;i<=n;i++) ans1=min(ans1,f1[i][i+n-1]);
	  for(i=1;i<=n;i++) ans2=max(ans2,f2[i][i+n-1]);
}
int main()
{
	init();
	dp();
	cout<<ans1<<endl<<ans2<<endl;
	return 0; 
}

````cpp

```