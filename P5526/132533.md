感觉得降紫啊，感觉这道题确实和 Qtree6 没有什么本质区别？         

离线做法，默认大家都会 LCT 维护子树信息。

首先很容易想到 Qtree6 的那个黑白染色块的套路，如果我们将每种颜色都拿去跑黑白染色块，将该种颜色视为白色另一种颜色视为黑色那么我们就可以维护所有黑色染色块大小的平方以获得有多少条路经上没有该种颜色，减一减就是该种颜色在树上路径的出现次数了。                

假设你比较猛，直接开了 $n$ 棵 LCT，那么你发现每次修改操作只会影响两棵 LCT 而其它的 LCT 根本不变，可以将 $m + 1$ 次操作看成时间，一棵 LCT 会对 $m + 1$ 时间里面的某些段时间内贡献一个固定的值，那么不难发现所有 LCT 的段大小加起来总共也只会有 $O(n + m)$ 级别，那么我们只要对应的跑出来这些段的贡献后差分滚前缀和即可。            

这里讲一下为什么不能直接维护子树大小然后平方。在 Qtree6 时我们直接就维护了个子树大小然后就结束了，但是这道题里面你运用同样的方法维护，你是无法知道假根是把哪些连通块合在了一起，自然而然就不能直接维护子树大小了。               

也比较好解决，根据 LCT 的原理我们知道有根树内一个点的子树就是在原实根在 LCT 的根上时它的虚子树加上它自己，所以我们直接维护一下虚子树的大小平方之和就好了。               

注意一下别少开 long long，别开小空间，别把 LCT 写假了基本上就能过了，不卡常还可以。

时间复杂度 $O((n + m) \log n)$。

