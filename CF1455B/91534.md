本文同步发表在[我的blog](https://www.cnblogs.com/TEoS/p/14074708.html)


------------


先假设全部执行第一种操作，然后把其中几个操作改为第二次操作。那么在第 $k$ 次执行的第二种操作就是走 $-k-1$ 。

显然我们应该先用第一次操作走过 $x$ 后再改其中的几个操作往回走。设最开始先走 $p$ 次第一种操作，则 $p$ 应该为最小的满足 $\frac{p(p+1)}{2}\geq x$ 的 $p$ 。通过枚举可以找到这个 $p$ 。然后我们需要往回走 $\frac{p(p+1)}{2}-x$ 步。

通过把第一种操作改成第二种操作可以往回走的步数范围显然为 $[2,p+1]$ ，而显然有 $\frac{p(p+1)}{2}-x\in[0,p-1]$ 。可以发现，步数为 $[2,p-1]$ 的情况都可以通过把一个第一种操作改成第二种操作来实现，步数即为 $p$ ；而相差 $0$ 步显然不用走；只有相差 $1$ 步的情况需要多执行一次第二种操作，此时答案为 $p+1$ 。

综上，先枚举到最小满足 $\frac{p(p+1)}{2}\geq x$ 的 $p$ ，然后判断 $\frac{p(p+1)}{2}-x$ 是否为 $1$ ，若为 $1$ 则答案为 $p+1$ ，否则为 $p$ 。

```c++
#include<iostream>
#include<cstdio>
using namespace std;
int T,n,p;
int main()
{
	scanf("%d",&T);
	while(T--)
	{
		scanf("%d",&n);
		for(p=1;p*(p+1)<n*2;p++);//暴力枚举
		printf("%d\n",p+(p*(p+1)/2-n==1));//特判输出
	}
	return 0;
}
```

