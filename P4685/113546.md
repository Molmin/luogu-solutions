## P4685 [IOI2008] Linear Garden

之前仅有的一篇题解我是真没看懂，而且看起来方法和我完全不同，所以我自己写一篇吧...

考虑满足题目要求的几何意义：遇到一个 $L$ 就向上走一格，遇到一个 $P$ 就向下走一格，而满足要求的花园中任意一段的 $L$ 与 $P$ 的数量差不超过 $2$，其实就等价于在图像上任取两个点，纵坐标的差不能超过 $2$，也就是说图像在一个宽度最多为 $2$ 的区域内，如图：

![](https://cdn.luogu.com.cn/upload/image_hosting/ll0gq653.png)

接下来转化一下问题：原来我们要求的是某个状态的字典序，其实就是问有多少个状态字典序更小，可以枚举 $i$，固定前 $i$ 位与给定状态相等，第 $i+1$ 位比给定状态小，而 $i+2$ 位之后随意安排，这样就可以不重不漏地统计所有字典序更小的状态，这是数位 DP 的思想。

于是我们按照套路，先解决计数问题，即：在宽度为 $2$ 的区域内走 $i$ 步，有多少种走法。显然从中间一行开始走和从两边的行开始走答案不同，设 $dp(0,i)$ 和 $dp(1,i)$ 分别表示从两边/中间的行开始行走 $i$ 步的方案数，两边只能走到中间，而中间可以走到任意一边，所以：

$$dp(0,i)=dp(1,i-1)$$

$$dp(1,i)=2\times dp(0,i-1)$$

边界状态：

$$dp(0,0)=dp(1,0)=1$$

然后就可以开始数位 DP，按照给定状态走，遇到一个 $L$，让当前位置往上一格，同时维护曾经走过的最高和最低位置，如果遇到一格 $P$ 就要统计贡献了，先当它是 $L$ 计算一次后面的位的贡献，设曾经走过的最高和最低位置分别是 $mx,mn$，当前所在的位置是 $pos$：

1. $mx=mn+2$，那么宽度为 $2$ 的区域已经框定（即 $[mn,mx]$），如果 $pos=mx$ 或者 $pos=mn$，那么就是从这个区域的两边开始走，贡献是 $dp(0,n-i)$，其中 $i$ 是当前位置；反之如果 $pos=mn+1=mx-1$，那么就是从中间开始走，贡献是 $dp(1,n-i)$；

2. $mx=mn+1$，那么宽度为 $2$ 的区域可以是 $[mn,mx+1]$，也可以是 $[mn-1,mx]$，容易发现不管 $pos$ 是 $mx$ 还是 $mn$，都有一种情况处在两边，一种情况处在中间，所以贡献是 $dp(0,n-i)+dp(1,n-i)$，但是还要注意这两种情况是有交集的，也就是不断在 $[mn,mx]$ 之间反复横跳，这种状态多数了一次，要减掉一次，所以实际贡献是 $dp(0,n-i)+dp(1,n-i)-1$。

别忘了答案要在上面的基础上加 $1$，因为算的是排名。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAXN=1000010;
int dp[2][MAXN],ans,n,p,mx,mn,nw;
char c[MAXN];
int main () {
	scanf("%d%d",&n,&p);
	dp[0][0]=dp[1][0]=1;
	for (int i=1;i<=n;i++) {
		dp[0][i]=dp[1][i-1];
		dp[1][i]=(dp[0][i-1]+dp[0][i-1])%p;
	}
	scanf("%s",c+1);
	ans=1;
	for (int i=1;i<=n;i++) {
		if (c[i]=='L') {
			nw++;
			mx=max(mx,nw);
			mn=min(mn,nw);
		} else {
			nw++;
			int tmx=max(mx,nw);
			int tmn=min(mn,nw);
			if (tmx-tmn==2) {
				if (nw==tmx||nw==tmn) {ans=(ans+dp[0][n-i])%p;}
				else {ans=(ans+dp[1][n-i])%p;}
			} else if (tmx-tmn==1) {
				ans=(ans+dp[0][n-i]+dp[1][n-i]-1)%p;
			}
			nw-=2;
			mx=max(mx,nw);
			mn=min(mn,nw);
		}
	}
	printf("%d\n",ans);
	return 0;
}
```
