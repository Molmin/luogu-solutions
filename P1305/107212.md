# 题解
  这篇题解是我专门为新人写的（我真是臭不要脸我也是新人），也不用关注我，我闲的没事也不发题解，心血来潮来赚取一点活跃分。题解来之不易，且看且珍惜。（有什么可以改进的地方随时提出就好了，谢谢各位大佬）
  
  至于思路，是我根据单词方阵的启发（好歹我曾经也是一个橙名的男人，十几天没登录就…………）
  其实这题还是很好的，很好做，还可以锻炼手速，做对了还能提高信心，作为一名蒟蒻我还是很容易受打击的。

  废话不多说（但我还是说了不少废话……），上题解


```cpp



#include<iostream> 
#include<cstdio>//不管，就是喜欢这个头文件，长得太好看了 
using namespace std;
struct programmer//struct定义，好把树的节点连接起来，具体可以看代码呀 
{
	char lc;//左孩子X1（left child，简称lc） 
	char rc;//右孩子X1（right child，简称rc） 
}lt[130];//数组，这个十分重要，一会儿输入字符的时候还要用这个串起来，其实真正起作用的只有lt[73]~lt[122],说这个是为了防止一些人不多想，方便理解的
char h,h1;//储存一会儿要输入的节点，多定义一个h1是为了一会儿将根节点保留下来先代入函数
void sm(char x)//我是谁，我杀了谁，谁又杀了我 
{
	if(x=='*') return;//如果是*说明此乃空节点，那就不用再往下探了 
	cout<<x;//先把它给输出出来，碰着一个就踢出去一个，输出的顺序是可以保障的，至于为什么可以看后面，我解释了 
	sm(lt[x].lc);//找到他的左孩子，继续往下探（如果左孩子是*的话，会返回的，可以看上一句的上一句） 
	sm(lt[x].rc);//找到他的右孩子，继续向下探索 
/*这里我举个例子： 例如输入abc和bcd,a的ASC码是73，所以lt[73].lc是b（ASC码74），接着再从b开始探，lt[74].lc之前有过输入，是个c。再从序
号为'c'（75）的lt数组继续往下探索，一探索到*,就会往回跑。回到c数组的rc，往回探，所以顺序问题可以保证,要是还是理解不了，可以画画试试，亲测有
效。这个函数和输入其实就是在数组的各个部分之间不断穿梭，用字符的ASC码值作为连接节点的线，数组的左右孩子就是下一个要寻找的数组的代号*/ 
}
int main()
{
	int n;//n在题目上说了，输入几个节点 
	scanf("%d",&n);//为了方便大家观看，我把输入拆成三部分 
	cin>>h1;//输入第一个字母，第一个字母比较特殊，所以单独输入 
	cin>>lt[h1].lc;//左孩子，h1所代表的字符再次会转换为ASC码 
	cin>>lt[h1].rc;//右孩子，道理和上面相同，就不用我多费口舌了 
	for(int i=2;i<=n;i++)//这里大家都懂的吧，输入 
	{
		cin>>h;
		cin>>lt[h].lc;
		cin>>lt[h].rc;
	}
	sm(h1);//进入函数，用的是递归，但我也是AC了才敢来发题解的 
	return 0;
}
```