这其实是一道学习二叉树很经典的题目哈

而我的思路很简单，分三步走：

1、存哪几个字母在里面，谁是孩子（在判断时直接用输入时存的数组就可以了，没必要再开一个）

2、找谁不是孩子但是出现过，这就是根，从此处开始递归

3、由于他让我们求前序（先序）遍历，先输出当前递归的量（父节点），再看他有没有左右两个孩子，如果有，先递归左孩子，再递归右孩子

上代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
string a[1001];
int n,er[1001],cun[1001],st;//er代表他是不是一个节点的儿子，cun代表他有没有出现过 
void dfs(int u){//不要被这东西误导了，这不是dfs 
	char now=u+'a';//其实可以直接导入字符 
	cout<<now;//输出父节点 
	for(int i=1;i<=n;i++){//在条件中寻找 
		if(a[i][0]==now){//如果这是父节点 
			if(a[i][1]!='*'){//依次查看他有没有左右两个孩子 
				dfs(a[i][1]-'a');//转换，递归
			}
			if(a[i][2]!='*'){
				dfs(a[i][2]-'a');
			}
			break;//节省时间 
		}
	}
}
int main(){
	cin>>n;//输入 
	for(int i=1;i<=n;i++){
		cin>>a[i];//用字符串方便一些 
		if(a[i][1]!='*'){//如果输入的东西不为* 
			cun[a[i][1]-'a']=1;//它存在过 
			er[a[i][1]-'a']=1;//因为最先输的是父亲，所以后来的两个十二子 
		}
		if(a[i][2]!='*'){//判断右节点 
			cun[a[i][2]-'a']=1;
			er[a[i][2]-'a']=1;
		}
		cun[a[i][0]-'a']=1;//父节点肯定不为* 
	}
	for(int i=0;i<26;i++){//在二十六个字母中寻找 
		if(cun[i]==1&&er[i]==0){//如果它存在过又没有当过儿子 
			st=i;//根即为他 
			break;
		}
	}
	dfs(st);//递归就好了 
	return 0;
}

```

我觉得我的代码对新手足够友好了，如有不正尽请指出qwq