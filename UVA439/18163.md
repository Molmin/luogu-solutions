题目意思就是：给你一个国际象棋的棋盘，求一个马从a点走到b点的最小距离是多少。

这道题许多巨佬都用的是BFS，但是本蒟蒻认为这道题用 $A*$ 算法效率更高。

那么我们先介绍一下什么是 $A*$ 算法

- $A*$ 算法

是一种启发式搜索，启发式搜索就是在搜索时对每一个位置进行评估，得到最好的位置，再从这个位置进行搜索直到目标。这样可以省略大量无谓的搜索路径，提高了效率。
    
其实大家熟知的BFS算法就是 $A*$ 算法的一种特殊情况，因为BFS总是将当前节点能到达的所有节点全部存入队列中，因此不存在启发性。BFS的速度虽然很快，但是它搜到的不一定是最佳路径。
    
在这里我所说的启发性大家可以理解为是搜索的方向性，即搜索方向总是趋向于终点，而不是盲目搜索。
    
$A*$ 算法的另一种特例就是Dijikstra算法，因为它在搜索时虽然能找到最佳路径，但是在时间上就不如BFS快。$A*$则集两家之大成，既能快速搜索，又能得出最佳路径。

$A*$ 算法的特点： $A*$ 算法在理论上是时间最优的，但是也有缺点：它的空间增长是指数级别的。

$IDA*$ 算法：即迭代加深 $A*$ 算法，可以有效的解决 $A*$ 空间增长带来的问题，甚至可以不用到优先级队列。~~因为我不会~~ 所以不再赘述。

### 重要公式：$F=G+H$

其中 $F$ 为我们的启发式函数，$G$ 为从起点移动到当前方格的花费，$H$ 为估价函数。

![](https://s2.ax1x.com/2019/10/19/KnrNZD.png)

此图中，橙色为当前节点，绿色为起点，红色为终点，红箭头为 $G$ ，紫箭头为 $H$ 。

- 估价函数：

即为从当前节点移动到目标节点的预估费用：这个估计就是启发式的。在寻路问题和迷宫问题中，我们通常用曼哈顿（manhattan）估价函数预估费用。这一估价值我们通常用字母 $H$ 表示。

$H$ 值可以用不同的方法估算。我们这里使用的方法被称为曼哈顿方法，它计算从当前格到目标格之间的曼哈顿距离乘以 $10$ 。

需要注意的是，无论在当前格到终点的路径上是否有障碍物（蓝色格），我们都选择忽视。这是对剩余距离的一个估算，而非实际值，这也是这一方法被称为启发式的原因。

另外，因为我们寻找的是最短路，那么估价函数应取最小值，所以我们就要用优先队列来维护。当然不要忘了重载自定义节点的比较操作符。

掌握了上面的基础知识，我们就可以开始搜索了！

1. 首先，将起点压入优先队列，寻找起点周围所有可到达的方格，并把他们加入队列。将所有这些方格的“父方格”设为起点。

2. 从队列中弹出起点，并检查所有在队列中的节点，选取 $F$ 值最小的进行搜索。（详见代码）

3. 重复以上过程直到终点被加入队列。

在这一过程中，我们记录的父节点就可以成为寻找路径的依据（尽管本题中不需要）。

更详尽的搜索过程请看[这里](https://blog.csdn.net/cug_wx/article/details/17760061)

最后上我丑陋的代码：

```cpp
#include <bits/stdc++.h>
#define x1 xxx1
#define y1 yyy1 //防止神奇变量干扰编译 
#define x2 xxx2
#define y2 yyy2
using namespace std;
const int dir[8][2]={{2,1},{2,-1},{-2,1},{-2,-1},{1,2},{-1,2},{1,-2},{-1,-2}};//走位数组 
int x1,y1,x2,y2,ans;
bool vis[8][8];
struct node{
	int x,y,step,g,h,f;
	bool operator < (const node & u)const{ //为优先队列重载运算符 
		return f>u.f;
	}
}k;
priority_queue<node>q;
bool check(node u){ //判是否出界 
	if(u.x<0 || u.y<0 || u.x>=8 || u.y>=8)return 0;
	return 1;	
}
int gujia(node u){ //估价函数 
	return (abs(u.x-x2)+abs(u.y-y2))*10;	
}
void astar(){ //A*算法 
	while(!q.empty()){
		node u=q.top(); q.pop();
		vis[u.x][u.y]=1;
		if(u.x==x2 && u.y==y2){
			ans=u.step; break;	
		}
		for (int i=0;i<8;i++){
			node v;
			v.x=u.x+dir[i][0],v.y=u.y+dir[i][1];
			if(check(v) && !vis[v.x][v.y]){ //计算当前点的位置与函数 
				v.g=u.g+23;
           //取23的原因是骑士每走一步都是2*1的，23=根号5乘以十再向上取整
				v.h=gujia(v);
				v.f=v.g+v.h;
				v.step=u.step+1;
				q.push(v);
			}
		}
	}
}
int main(){
	char c[10];
	while(gets(c)){
		x1=c[0]-'a',y1=c[1]-'1';
		x2=c[3]-'a',y2=c[4]-'1';
		memset(vis,0,sizeof vis);
		k.x=x1,k.y=y1,k.g=k.step=0,k.h=gujia(k),k.f=k.g+k.h;
		while(!q.empty())q.pop(); //多组数据须清空队列 
		q.push(k);
		astar();
		printf("To get from %c%c to %c%c takes %d knight moves.\n",c[0],c[1],c[3],c[4],ans);
	}
	return 0;
}

```
RP++ 希望不要初赛AFO

谢谢大家！！