很多人这道题做错不是因为不会做，而是因为没看懂题导致贪心策略出错。

题目上的样例解释没有翻译，我来翻译一下
```cpp
样例一：
5 
2 4 
1 12 
4 5 
7 10 
7 8 
解释：
这些牛喜欢吃草的范围分别为（2，4），（1，12），（4，5），（7，10）和（7，8）。
根据牛们的喜好，我们可以进行分析：
第一、第三和第四（或第五）头牛可以同时吃草。
如果第二头牛在吃草，其他牛就不能吃草了。
另外，第四和第五头牛不能一起吃草，所以最多只有三头牛可以一起吃草。
故结果为3.
```
手动翻译，水平有限，请见谅。

那么我们可以制定贪心策略：
1.先将每头牛的吃草范围按右端点（注意不是左端点，不懂就看样例分析）从小到大排序（结构体快排）

2.遍历牛群，如果一头牛的左端比现在的右端点大，那么就选取并更新当前右端点（贪心求解）

具体实现：

预处理：
```cpp
inline void pre()
{
	n=read();
	for(fint i=1;i<=n;i++)
	a[i].l=read(),a[i].r=read();
	sort(a+1,a+n+1,cmp);
}
```
贪心求解：
```cpp
inline int begin_todo()
{
	int tot=1;
	for(fint i=1;i<=n;i++)
	if(i==1)
	now=a[i].r;
	else
	if(now<=a[i].l)
	now=a[i].r,tot++;
	return tot;
}
```
结构体排序
```cpp
struct node
{
	int l;
	int r;
}
a[p];
inline bool cmp(node aa,node bb)
{
	return aa.r<bb.r;
}
```
这样，我们就做出来这道题了，祝大家ac愉快