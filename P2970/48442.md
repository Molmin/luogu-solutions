其实看到楼下的题解跟我基本上一样，我本来是不想发的，结果发现楼下的解释特别简略啊，所以我也来贡献一下吧～

在考试的时候看到这道题，我的第一感觉是：这道题好像很难啊...

结果看完了考试的题目，才发现好像这个银组的题目已经是最简单的了...

看着隔壁x\_faraway\_x大佬写了一个DP，但我怎么觉得这道题不用DP啊，我这下估计又要爆零了...

好吧，我们回归一下正题。

废话不多说，习惯性的定义一个结构体变量。

这里的**.e** 是指末尾

这里的**.s**是指开头

一开始我的思路是按照开头排一遍，结果发现好像不行

Eg:
我有1 17| 3 4| 5 9| 15 18 的四头牛。如果按照开头从小到大排序的话很明显选择的是“1 17”这一头牛，发现只能选择一个。 而最优解很明显是“3 4→5 9→15 18”这三头牛。
所以我就放弃了按照开头升序排序的思路，转投按照结尾升序排序。

排完了，突然发现这一道题好像可以用贪心来解？！

为了保险起见，我还是证明一下吧（可能有错啊我是个蒟蒻）：

**我们把n头奶牛看成是n个工作，而每个工作的价值都是1，有s和e，即开始时间和结束时间。**

很明显，我们想要获得最多的价值，就应该选择先结束的工作，以便让其他的工作尽早做。所以我们先按照结束时间升序排序一下，然后从第二个找能选择的工作（奶牛）即可。 ））这里为什么是从第二个开始呢？因为我们这里的第一个很明显是结束时间最早的，而他前面是没有工作的，所以无论如何第一个都是必须选择的。

代码如下：

```cpp
#include <cstdio>
#include <iostream>
#include <algorithm>
#include <cstring>
using namespace std;

int n;

struct Node
{
    int s;
    int e;
}cow[50005]; // 定义一个结构体数组，s代表工作开始的时间，e代表工作结束的时间

bool cmp(Node a, Node b) // 按照结束时间从小到大排序
{
    if(a.e == b.e) return a.s > a.s;
    return a.e < b.e;
}

void init(void) // 输入函数，我想就不用多说了
{
    scanf("%d", &n);
    for(int i = 1; i <= n; i++)
        scanf("%d %d", &cow[i].s, &cow[i].e);
    sort(cow + 1, cow + 1 + n, cmp);
    return;
}

void work(void)
{
    int ans = 1, last = cow[1].e; // ans代表能选择的工作（奶牛）的数量，last代表上一次选择的工作的结束时间，ans直接置为1，last直接置为第一个的结束时间，因为第一个必选
    for(int i = 2; i <= n; i++)
    {
        if(cow[i].s >= last) // 只要这个工作（奶牛）能选，就把他加上
        {
            last = cow[i].e;  // 更新上一个的结束时间
            ans++; // 计数器++
        }
    }
    printf("%d", ans); // 输出答案
    return;
}

int main(void)
{
    init();
    work();
    return 0;
}

```
如果大家直接看我的代码而不看我的解释基本上是看不懂为什么我这里说是工作的，所以大家还是先看文字解释比较好
