只看一眼就可以发现此题是一个搜索题，但是用什么搜索是很需要思考的。

1. BFS 或 DFS
> 明显不行，在题目中，交换次数是可以无限的，但是 bfs 和 dfs 没有限制，点会不断往搜索树里添加，会 T/M 。

2. A*
> 可以，题目中使用 A* 加上估价函数可以有效的排除大部分无效解，而往优先队列里扩展。

3. iddfs
> 也可以，但是可能会 T ,每次规定搜索深度可以有效避免搜索进搜索树无限的无解分支，但是可能效率也不够高。

4. DBBFS
> 可以，使用 dbbfs 可以有效减少 bfs 的时间复杂度，但是码量过大，且需要使用 hash ，不推荐。

5. idA*
> 最优解，每次规定搜索树深度，并且在搜索时规定估价函数，排除掉大部分的无效解，以达到剪枝的效果。

（下面讲解默认为 idA* )

选好之后，我们看到题目

给一个长度为 $N$ 的排列 $(1\le N\le 12)$。有 $M$ 种允许的修改方式 $(1\le M\le \frac{N\times (N-1)}{2})$，保证修改方式不重复，每种方式用 $L,$ $R$ 来表示，意为你可以将下标为 $L$ 的数与下标为 $R$ 的数交换。你可以修改该排列若干次，请给出一种修改方案，使原排列变为 $1,$ $2,$ $3,$ $\ldots,$ $N$。如果有多种方案，输出修改次数最少的方案。如果还有多种方案，输出任意一组即可。


正常的 dfs 的代码很好写

就是每次枚举操作 $i$ 判定一下 $i$ 和上一次的操作不同, 将两者交换，直到序列满足条件。

肯定会 T ，因为如果不去限制搜索树的深度，很有可能在无解的情况中耗费大量时间，期望 10 pts 。

这时我们使用 iddfs ，对搜索深度进行限制。

然后还是 T 了，如果不剪枝，仅仅靠着深度限制，很有可能被极限数据卡爆，期望得分 30 pts 。

这时我们使用 idA* ，考虑一下估价函数如何写。

我们给出一个序列

>  2 3 1

我们交换任意两个数，最多可以使得两个数到它应该的位置上。

所以我们枚举当前序列与目标序列有几个数不同，将这个数除以 2 ，加上当前交换次数，如果大于我们规定的深度，就剪枝。

这样会快很多，但是被卡了，期望得分 80 pts 。

证明我们的估价函数不够优秀。

我们再想一下，当有一个数需要交换时，如果我们能交换的数中不含它们俩，则至少需要两次才能让其回到正确的位置上。

又会快一些，但是还是 T 了，得分 90 pts 。

那这个时候怎么办？

我们看一下题目，把每一次操作抽象成两个点连接一条边，那我数字的位移，可以理解为一条从一个数到另一个数的一条路径。这个之后，可以使用 floyd 求出从一个数到另一个数的最短路，也就是最少的变换次数，然后在估价函数中求出位移到目标点的最小距离,然后将所有的距离加起来，除以 2 ，然后加上当前的变换次数，如果大于我们规定的深度就剪枝，然后就可以 AC 此题了。

不会 floyd 的看到[这里](https://blog.csdn.net/weixin_60737527/article/details/123774572)（此   floyd 博客转自 CSDN 生信小兔博主）。

```cpp
#include <bits/stdc++.h>
using namespace std;
int depth;
int a[15],n,m,b[80],c[80],d[15],ans,qian[80],dp[15][15];
bool flag;
int h(){
	int res=0;
	for(int i=1;i<=n;i++) res+=dp[i][d[i]];
	return res;
}//估价函数
bool check(){
	for(int i=1;i<=n;i++){
		if(d[i]!=i) return 0; 
	}
	return 1;
}//判断是否变换为目标状态
void idA_star(int now,int last){//idA*
	if(now*2+h()>depth*2){
		return ;
	}//不用h()/2是怕被卡精度
	if(check()){
		printf("%d\n",now);
		for(int i=0;i<now;i++){
			printf("%d\n",qian[i]);
		}
		exit(0);
	}
	for(int i=1;i<=m;i++){
		if(i==last) continue;//不判断last可能会死循环
		swap(d[b[i]],d[c[i]]);
		qian[now]=i;
		idA_star(now+1,i);
		swap(d[b[i]],d[c[i]]);
	}
}
int main(){
	scanf("%d %d",&n,&m);
	memset(dp,0x3f,sizeof(dp));
	for(int i=1;i<=n;i++){
		scanf("%d",&a[i]);
		d[i]=a[i];
		dp[i][i]=0;
	}
	for(int i=1;i<=m;i++){
		scanf("%d %d",&b[i],&c[i]);
		dp[b[i]][c[i]]=dp[c[i]][b[i]]=1;
	}
	for(int k=1;k<=n;k++)
		for(int i=1;i<=n;i++)
			for(int j=1;j<=n;j++)
				dp[i][j]=min(dp[i][j],dp[i][k]+dp[j][k]);//floyd
	while(++depth){//迭代加深
		idA_star(0,0);
		for(int i=1;i<=n;i++){
			d[i]=a[i];//复制一份a数组
		}
	}
	return 0;//结束
} 
```




