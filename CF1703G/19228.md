考虑动态规划。

设 $f_{i,j}$ 为开到第 $i$ 个箱子，已经用了 $j$ 次坏钥匙所能得到的最大金币数。设 $a_{i,j}$ 为用了 $j$ 次坏钥匙时，第 $i$ 个箱子里所拥有的金币数。

我们容易得到状态转移方程：

$f_{i,j}=\max(f_{i-1,j}+a_{i,j}-k,f_{i-1,j-1}+a_{i,j})$

其中逗号前的那一部分式子表示在之前状态的基础上使用好钥匙的情况，逗号后的那部分便表示在之前状态的基础上使用坏钥匙的情况。

如果暴力转移，那么时间复杂度就是 $\mathop{O(n^2)}$ 的。因为你需要 $\mathop{O(n)}$ 枚举开到了哪一个箱子，又要在此基础上 $\mathop{O(n)}$ 枚举使用坏钥匙的次数。时间空间会双双爆炸。

那该怎么办呢？

引入一个结论。我们发现一个数 $a_i$ 如果被除 $2$ 的次数大于等于 $\log_2{a_i}$，那么这个数就会变为 $0$。由于 $a_i$ 最大是 $10^9$，所以 $\log_2{a_i}$ 的最大值便约等于 $30$。

~~这就好办了~~，我们只要将之前的状态转移方程中 $j$ 的值域缩小到 $[0,30]$，时间复杂度和空间复杂度就会大大减小到 $\mathop{O(n\log a_i)}$ 了！

但是这道题并没有到此结束，如果你只是这样改的话会喜提 ```Wrong answer on test 4```。

问题出在哪了呢？

原来，仅仅是缩小值域的话，会让这个状态转移方程无法考虑到使用坏钥匙次数多于 $30$ 次的情况。

意识到当使用坏钥匙次数大于等于 $30$ 次时结果是相同的（因为我们用好钥匙的话收益可能为负，所以使用坏钥匙是最优的，但是此时所有盒子中的金币数均为 $0$，收益便不会改变），换句话说，对于任意的 $i$ ，当 $i$ 是一个定值，且 $j\ge30$ 时， $f_{i,j}$ 的数值是相等的。考虑将这些状态“压缩”到 $f_{i,30} (i\ge31)$ 中，让 $f_{i,30}$ 代替所有的 $f_{i,j}(j\ge31)$，问题便能迎刃而解了。

### 代码时间！
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int MAXN=1e5+5;
int T,n,k,a[MAXN][35],f[MAXN][35];
signed main()
{
	cin>>T;
	while(T--)
	{
		cin>>n>>k;
		for(int i=1;i<=n;i++)for(int j=0;j<=30;j++)f[i][j]=-1e18;
		for(int i=1;i<=n;i++)cin>>a[i][0];
		for(int i=1;i<=n;i++)
		 for(int j=1;j<=30;j++)a[i][j]=a[i][j-1]/2;
		for(int i=1;i<=n;i++)
		{
			for(int j=0;j<=min(i,30ll);j++)
			 {
				f[i][j]=max(f[i-1][j]+a[i][j]-k,f[i][j]);
				if(j-1>=0)f[i][j]=max(f[i-1][j-1]+a[i][j],f[i][j]);//注意当j-1<0时状态是不存在的，我们不能从一个不存在的状态转移！ 
			 }
			if(i>=31)f[i][30]=max(f[i-1][30]+0,f[i][30]);//这里的0其实就是a[i][j](j>=31)
		}
		int maxn=-1e18;
		for(int j=0;j<=30;j++)maxn=max(maxn,f[n][j]);
		cout<<maxn<<endl;
	}
}
```
感谢阅读！