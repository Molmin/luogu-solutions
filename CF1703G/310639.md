## 前言

看了一眼题解区，都写得挺繁琐的，我来提供一种方便一点的写法。

## 题目描述

你有 $n$ 个箱子。第 $i$ 个箱子中有 $a_i$ 个硬币。你需要按照从箱子 $1$ 号到箱子 $n$ 号的顺序打开所有 $n$ 个箱子。

你可以用以下两种钥匙之一打开一个箱子：
- 好钥匙：使用一次消耗 $k$ 个硬币。
- 坏钥匙：使用时不消耗硬币，但会使所有未打开的箱子中的硬币数减半（包括正要打开的这个箱子）。硬币减半时向下取整。比如，用坏钥匙打开箱子 $i$ 号时，$a_i=a_i/2$，$a_{i+1}=a_{i+1}/2$，$......$，$a_n=a_n/2$。

所有钥匙用过一次就会断掉（别想着买一把好钥匙开完所有箱子了），好钥匙需要重复付费，坏钥匙效果会重复计算。

也就是说，你总共需要使用 $n$ 把钥匙，每个箱子用一把。开始时，你没有硬币和钥匙，如果想用好钥匙，你就得去买。值得注意的是，在这个过程中你可以赊账买钥匙；例如，如果你只有 $1$ 个硬币，你也可以购买价值 $k=3$ 个硬币的好钥匙，你的余额会变成 $-2$ 个硬币。

你需要求出开完所有箱子之后你能获得的最大硬币数量（显然大于等于 $0$ ）。

## 分析

既然是按顺序，且有几种钥匙选择，那我们就可以尝试动态规划。第一眼想到 $f_i$ 表示前 $i$ 个的最大金币数，但是模拟一下样例就会发现是不行的。那么考虑使用二维，即 $f_{ij}$ 表示前 $i$ 个用了 $j$ 次坏钥匙之后的最大金币数。为什么是记录坏钥匙的使用次数呢？因为这样方便于计算后面的箱子里的剩余金币数。

对于每一步，一共是用好钥匙或者坏钥匙两种选择。所以我们不难列出状态转移方程式：

$ f_{i,j} = \begin{cases}
   f_{i-1,j} -k &\text{if j = 1}  \\
   \max(f_{i-1,j}+\lfloor\dfrac{a_i}{2^j}\rfloor-k,f_{i-1,j-1}+\lfloor\dfrac{a_i}{2^j}\rfloor) &\text{if } j>1
\end{cases}$

其中 $f_{i,j}$ 初始值设为 $-\infty$，不过显然使用坏钥匙的肯定不会 $<0$，所以我们其实只要对使用好钥匙的取一次 $-\infty$ 即可。

当然这样枚举肯定是会时间超限的，考虑优化第二重循环 $j$，不难发现，当 $j=31$ 时， $\lfloor\dfrac{a_i}{2^j}\rfloor$ 的值肯定为零，所以我们直接枚举 $j\le31$ 即可。

但是这样的话还是有些问题，那就是如果用了多于 $31$ 次的话，可能会无法计算到。这也不难解决，因为后边都是 $0$ 了，所以直接把当前状态计入答案即可。

不过这样空间还是太大了，我们其实可以把空间压缩到常数的。因为我们可以开滚动数组，类似于背包，因为当前状态取决于上一个，所以我们倒序遍历，就可以做到一维的效果。

## AC Code:
```
#include<bits/stdc++.h>
#define g(y) (x/(1<<y))
#define inf (long long)(-1e18)
using namespace std;
long long T,n,k,x,ans,f[32];//不开 long long 见祖宗
int main(){
	scanf("%lld",&T);
	while(T--){
		scanf("%lld%lld",&n,&k);
		ans=-1e18,memset(f,0,sizeof(f));//注意初始化
		for(int i=1;i<=n;i++){
			scanf("%lld",&x);
			for(int j=31;j>=0;j--)//倒序遍历
			 ans=max(ans,f[j]=max(f[j]+g(j)-k,(j?f[j-1]+g(j):inf)));
		}
		printf("%lld\n",ans);
	}
	return 0;
}
```
~~超短代码新鲜出炉。~~
