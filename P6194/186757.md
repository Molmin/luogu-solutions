# 开始！
老实说， 在比赛的时候，这道题把我卡了一下，具体细节我们待会再说。

这个，具体思路我直接写在以下代码的注释里吧~~~~。

```
#include<bits/stdc++.h>
using namespace std;
char a[8][8];//声明一个char数组，用来储存输入数据。
int flag[8][8];//声明一个标记数组，用于结尾的输出。
int r(int x, int y, int x2, int y2)//这个函数用于标记可以被主教一步吃掉的位置。x、y分别表示当前位置的横纵坐标，x+x2、y+y2表示下一个需要判定并标记的位置的横纵坐标。
{
    if(x==-1||y==-1||a[x][y]!='.'||x>7||y>7)//如果这个位置不在8*8的棋盘内，或者碰到了一个棋子，直接退出函数（因为棋子移动时不能越过另一个棋子）。就是“x>7||y>7”这个地方，把我卡了一下，第一次提交没考虑到。
        return 0;
    flag[x][y]=0;//标记位置。
    r(x+x2,y+y2,x2,y2);//继续判定或标记
    return 0;
}
int main()
{
    for(int i=0;i<=7;i++)//for循环输入数据并初始化flag数组。
        for(int j=0;j<=7;j++)
        {
            flag[i][j]=1;//初始化
            cin>>a[i][j];//读入数据
        }
    for(int i=0;i<=7;i++)//遍历一遍a数组
        for(int j=0;j<=7;j++)
        {
            if(a[i][j]=='.')//如果这个位置上没有棋子，直接跳过。
                continue;
            if(a[i][j]=='R')//判断这个位置上是不是战车
            {
                flag[i][j]=0;//因为有棋子的地方，不能放国王。
                for(int k=j-1;k>=0;k--)//从这里开始，就是判断和标记战车可一步到达的位置。这个循环是往左方向遍历的。
                    if(a[i][k]!='.')//如果这个位置上有棋子，就退出循环（因为棋子移动时不能越过另一个棋子）。
                        break;
                    else
                        flag[i][k]=0;//标记
                
                for(int k=j+1;k<=7;k++)//向右方向遍历
                    if(a[i][k]!='.')
                        break;
                    else
                        flag[i][k]=0;
                for(int k=i-1;k>=0;k--)//向上遍历。
                    if(a[k][j]!='.')
                        break;
                    else
                        flag[k][j]=0;
                for(int k=i+1;k<=7;k++)//向下遍历。
                    if(a[k][j]!='.')
                        break;
                    else
                        flag[k][j]=0;
            }
            else//如果这个位置上有棋子，那么它一定是战车或主教。之前判断过战车，所以这里一定是主教
            {
                flag[i][j]=0;//标记主教的位置
                r(i-1,j-1,-1,-1);//向左上遍历
                r(i-1,j+1,-1,1);//向右上遍历
                r(i+1,j-1,1,-1);//向左下遍历
                r(i+1,j+1,1,1);//向右下遍历
            }
        }
    for(int i=0;i<=7;i++)//输出flag数组
    {
        for(int j=0;j<=7;j++)
        {
            cout<<flag[i][j];
        }
        cout<<endl;//换行
    }
    return 0;
}
```

好啦，这道题目到这里就结束了
## 别走！！
我还要说一个自己在比赛时使用的小技巧。

为了排查我第一次提交时出现的错误，我在原有的程序外面套了两层for循环，表示战车的位置。

然后我运行程序，看到战车无论在棋盘上的哪个位置，程序的输出都没有问题。

然后我让这两层for循环表示成主教的位置，结果发现，主教在(0,2)上时，输出的结果就不对了，然后我就修改了上面代码的第七行，结果就AC啦！

我想告诉大家的就是这种Debug的方法。

这次真的拜拜啦！