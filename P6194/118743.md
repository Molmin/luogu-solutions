~~一边上课一边打月赛，好快活啊~~

~~一边上课一边打写题解，也好快活啊~~（非正确行为

作为萌新，就来写篇比较详细的题解吧owo

(我也就只能写红题题解了

### 思路

看到本题，棋盘？立刻想起了过河卒，梦开始的地方~~（没判边界调了一下午的搜索）~~

然而这题跟路径没关系

然后又想到八皇后，~~梦开始一会儿后的地方~~

然而这题只用放一个子……

所以，我们只需要枚举每一个战车 `R` 或主教 `B`，搜索并标记他们能走到的地方，直接输出即可。

### 分析

搜索题中，对于细节的严谨是很重要的。本题的细节不多，大致如下：

- **国王不能放在已经有棋子的地方** 
- 棋子移动时，**不能越过其他棋子** （此点写挂，30pts）

### 实现

#### Part 1 读入

用 `scanf("%c",&m[i][j]);` 实现读入，以一个一个读入字符。

需要注意的是，数据中包含不可见字符，而windows和linux环境下换行符不一样，有时会很难调。好在本题保证只会出现 `.`，`R`，`B` 三种字符，因此，我们可以这样比较方便地实现：

``` cpp
do{scanf("%c",&m[i][j]);}while(m[i][j]!='.'&&m[i][j]!='R'&&m[i][j]!='B');
```

#### Part 2 搜索&&标记

战车与主教的行动范围都是四向直线，所以我们可以在搜索时把方向作为参数传递下去。

加上判边界，判越棋子，放上代码：

```cpp
//以(i1,j1)为起点，以c为方向搜索，当前点为(a,b)。
//m[10][10]:存棋盘
//f[10][10]:存主教，战车能否到达，能到达为1

void sign1(ll a,ll b,ll c,ll i1,ll j1) //主教行动
{
	if(a<1||b<1||a>8||b>8)return; //判定边界
	f[a][b]=1;if(m[a][b]!='.'&&!(a==i1&&b==j1))return;
    //如果这里有棋子，且不是搜索起点，停止搜索，防止越过棋子
	if(c==1)sign1(a-1,b-1,1,i1,j1); //左上
	if(c==2)sign1(a-1,b+1,2,i1,j1); //右上
	if(c==3)sign1(a+1,b-1,3,i1,j1); //左下
	if(c==4)sign1(a+1,b+1,4,i1,j1); //右下
}

void sign2(ll a,ll b,ll c,ll i1,ll j1) //战车行动
{
	if(a<1||b<1||a>8||b>8)return; //判定边界
	f[a][b]=1;if(m[a][b]!='.'&&!(a==i1&&b==j1))return;
    //如果这里有棋子，且不是搜索起点，停止搜索，防止越过棋子
	if(c==1)sign2(a-1,b,1,i1,j1); //下
	if(c==2)sign2(a,b+1,2,i1,j1); //右
	if(c==3)sign2(a,b-1,3,i1,j1); //左
	if(c==4)sign2(a+1,b,4,i1,j1); //上
}
```

#### Part 3 全代码

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
#define ll long long

char m[10][10]={0};
bool f[10][10]={0};

//m[10][10]:存棋盘
//f[10][10]:存主教，战车能否到达，能到达为1

//以(i1,j1)为起点，以c为方向搜索，当前点为(a,b)。
void sign1(ll a,ll b,ll c,ll i1,ll j1) //主教行动
{
	if(a<1||b<1||a>8||b>8)return; //判定边界
	f[a][b]=1;if(m[a][b]!='.'&&!(a==i1&&b==j1))return;
    //如果这里有棋子，且不是搜索起点，停止搜索，防止越过棋子
	if(c==1)sign1(a-1,b-1,1,i1,j1); //左上
	if(c==2)sign1(a-1,b+1,2,i1,j1); //右上
	if(c==3)sign1(a+1,b-1,3,i1,j1); //左下
	if(c==4)sign1(a+1,b+1,4,i1,j1); //右下
}

void sign2(ll a,ll b,ll c,ll i1,ll j1) //战车行动
{
	if(a<1||b<1||a>8||b>8)return; //判定边界
	f[a][b]=1;if(m[a][b]!='.'&&!(a==i1&&b==j1))return;
    //如果这里有棋子，且不是搜索起点，停止搜索，防止越过棋子
	if(c==1)sign2(a-1,b,1,i1,j1); //下
	if(c==2)sign2(a,b+1,2,i1,j1); //右
	if(c==3)sign2(a,b-1,3,i1,j1); //左
	if(c==4)sign2(a+1,b,4,i1,j1); //上
}

int main()
{
	for(int i=1;i<=8;i++)
	{
		for(int j=1;j<=8;j++)
		{
			do{scanf("%c",&m[i][j]);}while(m[i][j]!='.'&&m[i][j]!='R'&&m[i][j]!='B');
			if(m[i][j]!='.')f[i][j]=1;
		}
	}
	for(int i=1;i<=8;i++)
	{
		for(int j=1;j<=8;j++)
		{
            //枚举每一个点
			if(m[i][j]=='B')
			{
				for(int k=1;k<=4;k++)sign1(i,j,k,i,j); //主教行动
			}
			if(m[i][j]=='R')
			{
				for(int k=1;k<=4;k++)sign2(i,j,k,i,j); //战车行动
			}
		}
	}
	for(int i=1;i<=8;i++)
	{
		for(int j=1;j<=8;j++)
		{
			cout<<!f[i][j]; //主教、战车能到达的，是不能放国王的，反之亦然。
		}
		cout<<endl;
	}
	return 0;
}
```

