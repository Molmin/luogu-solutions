我是用栈做的……也不是很长……


大体就是一个运算符栈f，一个数字栈a，


（完全的中缀表达式求值的思路）  （管理员麻烦帮忙删一下前一个QAQ，我写的前缀表达式）


这里我将左括号存为0，加号存为1，（自己随便定）


右括号因为一旦出现就要找到左括号匹配掉，所以不用存到栈里。


乘法是一定跟着右括号出现的，也就是一旦出现立即运算


所以也不用存到栈里。


但是我实现了很长时间，


反正如果有能力的大佬看到这里应该就不要看下去啦


自己实现的时候会发现很多有意思的细节


···
```cpp
#include<cstdio>
#define mod 12345678910LL //这个12345678910已经超过了int的范围所以要加LL
using namespace std;
int n,t,tt,f[500005],x[500005];
long long a[500005];
int main()
{
    scanf("%d",&n);
    for (int i=1;i<=n;i++)
    {
        scanf("%d",&x[i]);
        if (x[i])   //如果读入的是1，就是右括号
        {
            while (f[tt])  //要把从这里到最近的左括号都匹配干净算成一个数
                a[t-1]=(a[t-1]+a[t])%mod,t--,tt--;   //栈里面不是左括号就肯定是加号啦
            tt--;     //左括号弹掉
            if (x[i-1]) a[t]=a[t]*2%mod;  //既然是一个括号了就要把里面的值翻倍
            else a[++t]=1;            //但是如果括号里面没东西（就是左右括号连续出现）
                                                         //就再开一个数字栈的值为1
        }
        else
        {
            if (x[i-1]) f[++tt]=1;   //如果上一个读进来的是右括号，
                                                       //说明上一项和将要算的这项是相加的关系
                                                       //就压进栈里一个加号
            f[++tt]=0;                 //再把左括号压进去，不能只写tt++！！！！！因为退栈的时候没清零
        }
    }
    for (int i=2;i<=t;i++)
        a[1]=(a[1]+a[i])%mod;     //最后因为肯定各项都是相加的关系了，记得求个和
    printf("%lld",a[1]);
}
```