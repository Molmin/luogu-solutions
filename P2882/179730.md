首先对于这个题目进行一波分析，题目中给出了一排牛，让我们对其进行转向，可以看到样例所给的数据：

**0 0 1 0 1 0 0**（0表示朝向后方，1表示朝向前方）

- 可以看到我们所进行的调整一定是从左端或者右端开始的（因为从中间开始对前后造成的影响是难以控制的）

- 在我们转牛的过程中对于每一段一定是从第一个 0 开始进行转向。拿样例来看：
		
0 0 1 0 1 0 0

从第一个零开始

我们会得到 ： 1 1 0 0 1 0 0

从第二个零开始

我们会得到 ： 0 1 0 1 1 0 0

***显然若是从第二个开始我们仍需要将前面的 0 进行转向***

当然也许有人会想  从第后面的零开始调整会影响到后方的数

那么我们再看


将从第二个零开始转向的转向两次： 1 0 1 1 1 0 0

反观第一个： 1 1 1 1 0 0 0

***从第二个零开始转向的仍需要处理前面的0 ，而且这样也会破坏之前的转向成果，所以相同次数的转向显然从第一个0开始更优***

然后我们可以想到从前往后依次遍历，一遇到 0 对之后的 k 个数据进行转向

**但写完之后发现会T**

回到数据分析之后我们发现此时我们使用的算法时间为 O(n *  n  * n)对于5000的数据来说显然很危险。

我们会想到把每次将后方 k 个元素的转向的时间改为 O(1) 此时我们可以思考

**对于每一个元素是否转向不用修它的值，而是进行标记之后判断它标记的值就可以知道它面向哪里**


然后 *标记* -> *你是否想到了差分*  

应该都学过吧（~~然而我当时听的时候就没学过~~）

这样我们设置一个 tage 来记录元素被标记的个数，每次遍历到 0 的时候把后面第 i+k-1 个元素标记一下 当我们遍历到那个元素时将 tage- - （~~相信后面的事情就不用我说了~~） 

还有一件事 当序列后面的元素数目不足k-1个的时候,判定这个k不成立直接跳过去 


（~~我&#￥A^^S%*&)%$#%^$%@ 因为这个90分 找了一个多小时的错~~）



```
#include<bits/stdc++.h>
using namespace std;
const int MAXN=5008;
int n,k,a[MAXN],f[MAXN<<1],tag,op,ans=MAXN;
int ansk,sum;
inline int read()
{
    register int x=0,f=1;
    char s;
    while((s=getchar())<'0'||s>'9')
    {
        s=='-'?f=-1:f=1;
    }
    x=s-'0';
    while((s=getchar())>='0'&&s<='9')
    {
        x=x*10+s-'0';
    }
    return x*f;
}
int main()
{
	n=read();
	for(int i=1;i<=n;i++)
	{
		char s;
		cin>>s;
		if(s=='B') a[i]=0;
		if(s=='F') a[i]=1;
	}
	for(register int k=1;k<=n;k++)
	{
		sum=0;tag=0;op=0;
		memset(f,0,sizeof(f));
		for(register int i=1;i<=n;i++)
		{
			
			if((a[i]+tag)%2==0)
			{
				if(i+k-1>n)	
				{
					op=1;
					break;
				}
				++sum;
				++tag;
				f[i+k-1]=-1;
			}
			if(f[i]==-1)
			{
				--tag;
				f[i]=0;
			}
		}
		if(op) continue;
		if(sum<ans)
		{
			ans=sum;
			ansk=k;
		}
	}
	printf("%d %d",ansk,ans);
	return 0;
}
```
