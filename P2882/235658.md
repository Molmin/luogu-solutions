# P2882

## 题意简述

- 给定一个长度为 n 的 01 串。
- **选择一个 k 值**，每次一段长度为 k 区间将其中的数取反（0变成1，1变成0），最终使整个串变成 1 。
- 求出最小需要的操作次数和**在此条件下**最小的 k 。

## 题目分析

每次选择区间的长度是固定的，所以我们可以枚举 k ，将问题转化为 “每次一段长度为 k 区间取反，需要多少次操作可以将整个串变成1 。

显然对于每一个 0 我们都要对它至少操作一次，所以我们可以从左到右考虑，每次遇到 0 都将从这个 0 为左端点长度为 k 区间中的数取反，直到全变成1。**如果碰到 0 时此时到末尾的长度小于 k ，则无解**，考虑下一个 k 。

**为什么这样做是对的呢？**



假如有这样一个串 1$\color{red}\text{0}$$\color{gold}\text{10}$0…… , 我们枚举的 k = 2  ，那么要将最左边$\color{red}\text{红色的 0}$ 变成 1，应该将这个 0 和右边的$\color{gold}\text{金色的 10}$  取反而不去动它左边黑色的 1 。每一个状态下最左边的 0 我们都要去将它变成 1 （因为最终要把整个串变成 1），而因为我们是从左到右考虑的，所以它左边一定已经全部是 1 了 。

**同时，因为我们有两次枚举和一次区间修改，所以复杂度是 $O(n^3)$ 我们还要优化**

两次枚举不可避免，我们可以使用**差分**，将修改变成 $O(1)$ 。

## 代码思路

很多同学都是看懂了上面的思路但是到代码实现上就有些困难了，一个较大的问题就是差分如何实现。

我们可以维护一个 bool 变量 $"now"$ 来表示当前状态——是否翻转。易知翻转偶数次和不翻转是一样的，所以每次修改的时候只要异或上 $1$ 就可以了。而当前的的串（存在数组 a 中）的值就是 $a[i]$ 异或 $now$，每次差分时将 $now$和差分数组$cha[i+k]$修改 ,也就是现在翻转一下，到了位置 $i+k$ 的时候再改回来，等价于修改 $i$ 到 $i+k$ 的值。

## 易错点
- 每次枚举 k 的时候要将差分数组清0
- 注意先输出 k 值再输出 m 值
- 记得判断无解

## AC代码

内带详细注释帮助理解

```cpp
#include<bits/stdc++.h>
using namespace std;
void read(int &x){
	int f=1;x=0;
	char ch=getchar();
	while(ch<'0'||ch>'9') {if(ch=='-') f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9') { x=x*10+ch-'0';ch=getchar();}
	x*=f;
}
#define N 5010
int n,ansm=2100000000,ansk;
int a[N];//原串 
bool cha[N];//差分数组 
int main(){
	read(n);
	for(int i=1;i<=n;i++){
		char ch;cin>>ch;
		if(ch=='F') a[i]=1;//读入，朝前的为 1 
	}
	for(int k=1;k<=n;k++){
		memset(cha,0,sizeof(cha));//易错点 1 
		int flag=1,tot=0,now=0;//tot 记录当前需要操作几次 
		for(int i=1;i<=n;i++){
			now^=cha[i];//每次操作前异或差分数组，也许这个点就是某次差分的末尾 
			if(a[i]^now==0){//碰到 0 ，进行操作 
				if(i+k-1>n){//无解 
					flag=0;
					break;
				}
				tot++;//记录答案 
				now^=1,cha[i+k]^=1;//差分修改 
			}
		}
		if(flag){
			if(tot<ansm){//更新答案 
				ansm=tot;
				ansk=k;
			}
		}
	}
	printf("%d %d",ansk,ansm);
}

```

蒟蒻写题解不易，如果对你有帮助，点个赞呗