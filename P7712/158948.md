纯套路题，想不到就是~~nt~~套路没看够。

首先题目问的就是割点，然后这个建图一看就很线段树优化，比如考虑竖直线段的连边。

从左往右依次考虑，对于水平的线段在 $l$ 列插入在 $r+1$ 列删除。

然后一个竖直线段显然就是框 $[d,u]$ 行引内有的水平线段连边，由于是连边而不是储存信息，显然想到可持久化。

但是这样连图的点双连通性是不同的，虚点会把无向图很多不该连起来的东西直接连起来，比如水平线段之间会由于线段树的节点给直接连通。

如果考虑有向图的话对于一些连通性不影响，但是显然你求不了点双，也走不通。

自然的想到了某道线段树/k-d 树优化建边板题卡空间，正解是只构造 k-d 树的线性结构而不建边，直接在树上询问以及更新信息。

这道题是类似的，我们只构造线段树的结构而不显式的把边建出来。

回顾 Tarjan 求割点的过程，当前节点为 $x$，考虑出边 $y$：

- 如果 $y$ 没有 dfn，对 $y$ 递归进行 Tarjan 算法，并在结束后执行 $low_y\to low_x$。
- 如果 $y$ 有 dfn，执行 $dfn_y\to low_x$。

直接在线段树上找到没有更新 dfn 的点，这是简单的，跑完了用它的 low 更新一下，同时在递归执行 Tarjan 之前把这个点的 dfn 在线段树先标上标记即可。

还要询问出边的 dfn 最小值，也与线段树十分契合，我们就先把没跑 dfn 的都跑了以后就可以直接询问了，因为此时 dfn 都有值了，且 $\forall x,dfn_x\ge low_x$，所以更新 low 的地方多更新一次 dfn 也没有影响。

思路是很简单的，主要是实现，这里提几个个人觉得比较优秀的细节：

- 把线段编号对应到 $1\sim 2n$，即水平对应 $1\sim n$，竖直对应 $n+1\sim 2n$，然后叶子就直接挂线段或者是空节点。
- 改变线段树节点处信息的含义，本来一般使用变量 $mn$ 代表这个区间内的 dfn 最小值，定义改为若区间都有 dfn 则为最小值，否则为 $\infty$。

  方便查找未更新的 dfn，也方便更新，一个变量搞定。
- 其他细节：如链表存线段，求割点之类的细节大家应该都会。

总之就是很好写，特别好写。

分析一下复杂度：如果找到了一个未更新的 dfn，只有 $n$ 次更新，复杂度 $O(n\log n)$，否则一定会更新一个节点的 $mn$，由于可持久化线段树只有 $O(n\log n)$ 个点，所以也只会进行 $O(\log n)$ 次。

[代码](https://www.luogu.com.cn/paste/x65uc38a)