### 题意
有三个序列 $a,b,c$，长度分别为 $k_1,k_2,k_3$。设 $n=k_1+k_2+k_3$，将 $a,b,c$ 三个序列拼接后形成的序列是 $1 \sim n$ 的排列。你可以在 $a,b,c$ 间移动元素，使得 $a$ 排序后是 $1 \sim n$ 的前缀，$c$ 排序后是 $1 \sim n$ 的后缀，要求移动次数最少。

### 题解
我们可以把原问题转化一下：有一个只包含 $1,2,3$ 的长度为 $n$ 的序列。将这个序列划分成三段（一段可以为空），使第一段中 $1$ 的数量、第二段中 $2$ 的数量、第三段中 $3$ 的数量之和最大。$n$ 减该问题的答案就是原问题的答案。

我们不如先枚举第二段和第三段的分界点 $i$（第 $i$ 个算入第二段），显然有：
$$ans=\max_{i=0}^n [1,i]\text{中第一二段获得的最大答案}+[i+1,n]\text{中3的数量}$$

第一二段获得的最大答案要如何计算呢？不妨先只考虑序列只有两段时怎么做。还是枚举第一段和第二段的分界点 $i$：

$$ans=\max_{i=0}^n [1,i]\text{中1的数量}+[i+1,n]\text{中2的数量}$$

上面的柿子可以算出区间 $[1,n]$ 的最大答案，区间 $[1,i]$ 的最大答案:

$$\text{区间[1,n]的答案}-\text{[i+1,n]中2的数量}$$

把上面的柿子回代，这道题就做完了！实现细节见代码

### 代码
```cpp
#include<iostream>
#include<algorithm>
using namespace std;
int k1,k2,k3,x[200005],a[200005],b[200005],c[200005],f[200005],g[200005];
int main()
{
	cin>>k1>>k2>>k3;
	for(int i=1,k;i<=k1;i++)cin>>k,x[k]=1;
	for(int i=1,k;i<=k2;i++)cin>>k,x[k]=2;
	for(int i=1,k;i<=k3;i++)cin>>k,x[k]=3;
	int n=k1+k2+k3,ans1=0,ans2=0;
	// for(int i=1;i<=n;i++)cout<<x[i]<<' ';
	// cout<<endl;
	for(int i=0;i<=n;i++)
	{
		a[i]=a[i-1]+(x[i]==1);
		b[i]=b[i-1]+(x[i]==2);
		c[i]=c[i-1]+(x[i]==3);
		f[i]=a[i]+k2-b[i];
		ans1=max(ans1,f[i]);
		g[i]=ans1-(k2-b[i])+(k3-c[i]);
		ans2=max(ans2,g[i]);
	}
	cout<<n-ans2;
}
```