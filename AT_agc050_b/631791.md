## $\text{statement}$

有 $n$ 个盒子排成一列，从左到右分别编号为 $1\sim n$。

最开始，每个盒子都是空的。你可以以任何顺序进行如下两种操作任意次：
- 选择三个**连续**的空盒子，向其中分别放入一枚硬币。
- 选择三个**连续**的放有硬币的盒子，取出其中的硬币。

操作完后，假设第 $i$ 个盒子中装有硬币，你会获得 $a_i$ 分。最终分数是你从各个盒子处获得的分数的和。

请输出最终分数的最大值。

$3\le n\le 500, \ -100\le a_i \le 100$。

## $\text{solution}$

给定一系列位置 $x_i$，我们能否知道是否可以通过一系列操作使得只有这些位置的盒子内装有硬币？答案是肯定的。

首先我们发现，我们只需要关注 $x_i\bmod 3$ 的值。这是因为我们可以通过进行如下的操作使得 $x_i$ 左右平移三个位置：

`...o`  $\to$  `oooo`  $\to$  `o...`

然后有了转化后的题意：   
给定一个初始为空的串和目标串。你可以以任何顺序进行如下两种操作任意次：
- 在串的任意位置加入 `012`、`120`、`201` 中的一种。
- 在串的任意位置移除形如 `012`、`120`、`201` 的子串。

询问是否能够构造出目标串。

可以证明一定不需要移除操作。   
如果移除操作和上一次加入操作的操作范围有交集，则这两次操作互相抵消。反之我们一定可以通过不断交换移除操作和上一次加入操作的顺序，从而最终转化到前一种情况。容易证明不存在其他情况。

因此我们只需要着眼于加入子串能构造出的所有串。我们可以递归地定义可以构造出的串：
- 空串是可以构造出的。
- 设串长度为 $n$。如果存在三个位置 $x_i < x_j < x_k$，满足 $x_j\equiv x_i + 1\pmod 3$、$x_k\equiv x_j + 1\pmod 3$，且子串 $[1,i)$、$(i,j)$、$(j,k),(k,n]$ 都是可以构造出的串，则该串是可以构造出的。

这给出了一种区间 dp 的方法。总时间复杂度 $O(n^3)$。

$\text{code : }$

```cpp
#include <bits/stdc++.h>
using namespace std;
#define rep(i,s,t) for (register int i = (s), i##_ = (t) + 1; i < i##_; ++ i)
const int N = 500 + 10;
int n, a[N], sum[N], f[N][N];

signed main() {
	ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);
	cin >> n; rep(i,1,n) cin >> a[i], sum[i] = sum[i - 1] + a[i], f[i][i] = 0;
	rep(i,1,n) rep(j,i+1,n) f[i][j] = -0x3f3f3f3f;
	rep(len,2,n) {
		if (len % 3) {
			for (int l = 1, r = l + len - 1; r <= n; ++ l, ++ r) {
				rep(k,l,r - 1) f[l][r] = max(f[l][r], f[l][k] + f[k + 1][r]);
			}
		} else {
			for (int l = 1, r = l + len - 1; r <= n; ++ l, ++ r) {
				rep(k,l,r - 1) f[l][r] = max(f[l][r], f[l][k] + f[k + 1][r]);
				f[l][r] = max(f[l][r], sum[r] - sum[l - 1]);
				for (int k = l + 1; k <= r - 1; k += 3) 
					f[l][r] = max(f[l][r], f[l + 1][k - 1] + f[k + 1][r - 1] + a[l] + a[k] + a[r]);
			}
		}
	} cout << f[1][n] << '\n';
}
```