# 竞技规则
每次可以进行一个异或操作,使自己的数变得大于对方,或者是对方的数小于自己,最后比谁的数比较大.
# 最优策略
根据位运算的原则,我们首先得清楚 **当前可操作数当中位为0的位对我们的数并没有影响** ,原理很简单就是 $0\oplus 1=1$ ，$0\oplus 0=0$ , $0$ 与任何数做异或不会改变我们的数,只是在平白浪费我们的操作次数.

**那么只有位为 $1$ 的位对我们的数产生贡献**

于是贪心策略就产生了,

**我们能否通过控制操作数来控制我们当前的最高位,使自己的最高位大于对方的最高位呢?**

显然这是可以的,于是我们聪明的 _Alice_ 和 _Bob_ 都会尝试争抢最高位为 $1$ 的那些数,由于他们都是一样聪明的,所以若当前最高位为 $1$ 的数有偶数个,那么他们在当前这一位上的较量会平局,他们就只能争抢下一位了。

**一直持续到持有当前最高位的数只有奇数个了,那么战局的结果就明了了**
当持有当前最高位的数只有 $1$ 个,那么先手的 _Alice_ 就可以占得先机,赢下比赛.
但是如果持有当前最高位的数不止 $1$ 个,而是 $3$ 个, $5$ 个..等等呢?那么之前毫无贡献的0就会出手,因为我们每使用了一个 $0$ ,都等于浪费了我们先手的机会,则战局的情况就逆转了.

**所以只要还剩下奇数个 $0$ ,则Alice的先手优势就反转成为后手了,Bob赢**

**如果还剩下偶数个 $0$ ,那么战局就还没有逆转** , _Alice_ 将抓住最后的主动权夺下最后一个当前最高位为 $1$ 的数,赢下比赛

"那么,这一次,是我先下一城了!"( _Alice_ 抱拳)

# 代码部分
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[200010],n,t,cnt[22];
void count(int x)
{
	int a=0;
	while(x)
	{
		if(x&1)++cnt[a];
		x>>=1;++a;
	}
}
int main()
{
	//0对我们的大小改变是没有贡献的
	//因为0^已经是1的部分答案不变,^已经是0的地方答案也不变.
	//只有当前位为1的数才会对我们的数的大小产生贡献.
	//所以策略就为尝试让自己的数变大,或者让对方的数变小.
	//至于到底是让自己的数变大,还是让对方的数变小
	//则是贪心的取决于此次改动是否会是自己与对方的地位逆转
	//如果当前有奇数个1,则看还有多少0
	//每个0都在交换先后手,不交换,在奇数1的情况下A赢,交换则B赢,除非只有一个1了,A赢
	scanf("%d",&t);
	while(t--)
	{
		memset(cnt,0,sizeof(cnt));
		int flag=0;
		scanf("%d",&n);
		for(int i=1;i<=n;++i)
		scanf("%d",a+i),count(a[i]);
		for(int i=20;i>=0;--i)
		{
			if(!(cnt[i]&1)) continue;
			if(cnt[i]==1) {puts("1");flag=1;break;}
			if((n-cnt[i])&1) {puts("-1");flag=1;break;}	
			puts("1"),flag=1;
			break;
		}
		if(!flag) puts("0");
	}
	return 0;	
}
```
