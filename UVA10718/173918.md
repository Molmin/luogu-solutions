## 本蒟蒻又来给鲜为人知的题目发题解啦！
```
题意翻译：给你一个32位无符号整数 N
你必须找到一个数 M,使得 L <= M <= U 并且 N OR M 是最大的。
例如，如果 N = 100, L = 50, U = 60，那么 M = 59, N OR M = 127，这是最大值。
如果 M 的多个值满足相同的条件，那么必须打印 M 的最小值。

```

首先，本蒟蒻拿到此题后非常的懵。

让我们开始~~慢慢的~~分析。

首先不能用暴力枚举，输出格式的最后一句话已经提醒了你。

那么就要把 $M$ 一位一位地填上。

是从高位到低位还是从低位到高位呢？

很显然是从高位到低位。

因为把后面的所有位都填1都比不上这一位填1的效果好。

接着，如果 $N$ 这一位为1，那么尽可能的填1(注意有可能填了就大于 $u$ ,这样能保证值尽可能的大。

如果否则的话，如果填到目前还是小于 $l$ 的（即从该位前1位，到最高位都和 $l$ 相应的位相同，那么如果 $l$ 在该位为1，则 $m$ 此位也必须为1。

接下来给出怎样获取 $N$ 的某一位。

```
if((n >> i) & 1) == 0)//为0
else //为1
```

代码中用了 $long long$ 因为 $long long$ 是64位的，32位的没问题。
示例代码

```cpp
#include <bits/stdc++.h>
using namespace std;
int main() 
{
	long long n,l,u;
	while(cin>>n>>l>>u)
    {
		long long m=0;   //m首先每一位全部置0
        for (long long i=31;i>=0;i--) //从高位到低位的考虑，看哪些位能填1
        {
            //该位为0的话，尽可能的填1，实在不行才填0。这样确保值尽可能的大
            if(((n>>i)&1)==0&&(((long long)1<<i)|m)<=u) //如果n中该位为0，且m中该位能填1(<=u),则填1(能填1尽量填1)
            {
                m|=((long long)1<<i);
            }
            //该位为1的话，实在不行才填0，这样保证m尽可能的小
            else if(((l>>i)&1==1)&&(((long long)1<<i)|m)<=l)//否则的话，如果填到目前还是小于i的（即从该位前1位，到最高位都和l相应的位相同，那么如果i在该位为1，则m此位也必须为1
            {
                m|=((long long)1<<i);
            }
        }

		cout<<m<<endl;
	}
	return 0;
}
```
