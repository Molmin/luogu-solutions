[原题链接](https://www.luogu.com.cn/problem/UVA10718)

[UVA 链接](https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=19&page=show_problem&problem=1659)

题目大意：

给定三个数 $N$、$L$、$U$。我们需要找到一个数 $L\leq M\leq U$，使得 $N\operatorname{or} M$ 最大。输出满足题意的 $M$ 的最小值。本题有多组数据，读到 ```EOF``` 结束。

思路：

看一下 [PDF](https://onlinejudge.org/external/107/p10718.pdf) 给我们的提示就知道暴力肯定不行。这道题我们可以采取把 $M$ 用二进制一位一位地填上。

显然，如果 $M$ 的一位必须填 $1$，就必须把它填上，因为后面所有位的位值和都比这一位的位值小。如果 $N$ 的一位是 $0$，那么 $M$ 的这一位就是是 $1$，否则就是 $0$，因为题目让我们求出 $M$ 的最小值。

要想获取 $N$ 的第 $x+1$ 位，我们可以这样写：```N&(1<<x)```，即 $N\land 2^x$。

根据题目，$N$ 的二进制位数最大为 $31$。这样，我们从高到低枚举 $N$ 在二进制中的每一位，把 $M$ 处理好，最终输出就可以了。

但是，如何保证 $L\leq M\leq U$ 呢？如果 $N$ 的这一位是 $0$ 且 $M$ 填上 $1$ 后是小于等于 $U$ 的，那么就可以顺理成章地填上 $1$。否则，如果 $L$ 这一位也是 $1$ 且 $M$ 这一位填上 $0$ 是小于等于 $L$ 的话，那么 $M$ 这一位就只能填 $1$。

如何把 $M$ 的第 $i+1$ 位填上 $1$ 呢？我们可以思考一下：因为二进制中的第 $i+1$ 位的位值为 $2^i$，所以我们可以把 $M$ 变成 $M\operatorname{or}2^i$，就可以把 $M$ 的第 $i+1$ 位填上 $1$ 了。

我们可以写出这一部分的代码：
```cpp
if (((n >> i) & 1) == 0 && (((long long)(1) << i) | m) <= u){
    m |= (long long)(1) << i;
} else if (((l >> i) & 1) && (((long long)(1) << i) | m) <= l){
    m |= (long long)(1) << i;
}
```
最终，我们输出 $M$ 就可以了。

坑点：

1. 本题有多组数据，读到 ```EOF``` 结束！
1. 全程开 ```long long```，否则炸精度！
1. 中间算 $2^i$ 的时候，我们需要写成 ```(long long)(1) << i```，不能写成 ```(long long)(1 << i)```，以防半路炸精度！
1. 枚举位数的变量需要从 $31$ 到 $0$，不能从 $32$ 到 $1$！

完整代码贴在[这里](https://www.luogu.com.cn/paste/8pdmlihz)。