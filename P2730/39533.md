作为蒟蒻，各位大佬的解法看得很累......

对于本题来说，解法最好用宽搜而不是双向广搜（字典序）。

代码丑得出奇，但是思路很好理解，在函数中极其暴力的把情况手写出来，

但相信对爱好暴力解题的同学有一定的帮助。

ps：bfs的地方有点乱，但看完main（）里的代码就能明白。



```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
int b[40320][2][4],c[40320],bi[2][4];
int n[40320][3],l[40320];
char r[5000];
bool se[9][9][9][9][9][9][9];
int ans;
int h=-1,t=0;
int bfs(){//可以略过，只是把原始思想暴力手写出来，没有偷懒。也没什么好说的
    c[0]=0; 
    do{
        h++;
        t++;
        b[t][0][0]=b[h][1][0];b[t][0][1]=b[h][1][1];
        b[t][0][2]=b[h][1][2];b[t][0][3]=b[h][1][3];
        b[t][1][0]=b[h][0][0];b[t][1][1]=b[h][0][1];
        b[t][1][2]=b[h][0][2];b[t][1][3]=b[h][0][3];
        if(se[b[t][0][0]][b[t][0][1]][b[t][0][2]][b[t][0][3]]           [b[t][1][0]][b[t][1][1]][b[t][1][2]]){
            t--;
        }
        else{
            se[b[t][0][0]][b[t][0][1]][b[t][0][2]][b[t][0][3]]                [b[t][1][0]][b[t][1][1]][b[t][1][2]]=1;
            c[t]=c[h]+1;
            n[h][0]=t;
            l[t]=h;
            if(b[t][0][0]==bi[0][0]&&b[t][0][1]==bi[0][1]&&b[t]                [0][2]==bi[0][2]&&b[t][0][3]==bi[0][3]&&b[t][1]                    [0]==bi[1][0]&&b[t][1][1]==bi[1][1]&&b[t][1]                    [2]==bi[1][2]&&b[t][1][3]==bi[1][3]){
                return c[t];
            }
        }
        t++;
        b[t][0][0]=b[h][0][3];b[t][0][1]=b[h][0][0];
        b[t][0][2]=b[h][0][1];b[t][0][3]=b[h][0][2];
        b[t][1][0]=b[h][1][3];b[t][1][1]=b[h][1][0];
        b[t][1][2]=b[h][1][1];b[t][1][3]=b[h][1][2];
        if(se[b[t][0][0]][b[t][0][1]][b[t][0][2]][b[t][0][3]]            [b[t][1][0]][b[t][1][1]][b[t][1][2]]){
            t--;
        }
        else{
            se[b[t][0][0]][b[t][0][1]][b[t][0][2]][b[t][0][3]]                [b[t][1][0]][b[t][1][1]][b[t][1][2]]=1;
            c[t]=c[h]+1;
            n[h][1]=t;
            l[t]=h;
            if(b[t][0][0]==bi[0][0]&&b[t][0][1]==bi[0][1]&&b[t]                [0][2]==bi[0][2]&&b[t][0][3]==bi[0][3]&&b[t][1]                    [0]==bi[1][0]&&b[t][1][1]==bi[1][1]&&b[t][1]                    [2]==bi[1][2]&&b[t][1][3]==bi[1][3]){
                return c[t];
            }
        }
        t++;
        b[t][0][0]=b[h][0][0];b[t][0][1]=b[h][1][1];
        b[t][0][2]=b[h][0][1];b[t][0][3]=b[h][0][3];
        b[t][1][0]=b[h][1][0];b[t][1][1]=b[h][1][2];
        b[t][1][2]=b[h][0][2];b[t][1][3]=b[h][1][3];
        if(se[b[t][0][0]][b[t][0][1]][b[t][0][2]][b[t][0][3]]            [b[t][1][0]][b[t][1][1]][b[t][1][2]]){
            t--;
        }
        else{
            se[b[t][0][0]][b[t][0][1]][b[t][0][2]][b[t][0][3]]                [b[t][1][0]][b[t][1][1]][b[t][1][2]]=1;
            c[t]=c[h]+1;
            n[h][2]=t;
            l[t]=h;
            if(b[t][0][0]==bi[0][0]&&b[t][0][1]==bi[0][1]&&b[t]                [0][2]==bi[0][2]&&b[t][0][3]==bi[0][3]&&b[t][1]                    [0]==bi[1][0]&&b[t][1][1]==bi[1][1]&&b[t][1]                    [2]==bi[1][2]&&b[t][1][3]==bi[1][3]){
                return c[t];
            }
        }
    }while(h<t);
}
int main(){
    memset(se,0,sizeof(se));
    memset(n,0,sizeof(n));
    memset(c,0,sizeof(c));//数组清0
    b[0][0][0]=1;b[0][0][1]=2;
    b[0][0][2]=3;b[0][0][3]=4;
    b[0][1][0]=8;b[0][1][1]=7;
    b[0][1][2]=6;b[0][1][3]=5;//目标情况
    cin>>bi[0][0]>>bi[0][1]>>bi[0][2]>>bi[0][3]>>bi[1][3]>>bi[1]    [2]>>bi[1][1]>>bi[1][0];
    if(b[0][0][0]==bi[0][0]&&b[0][0][1]==bi[0][1]&&b[0][0]            [2]==bi[0][2]&&b[0][0][3]==bi[0][3]&&b[0][1][0]==bi[1]            [0]&&b[0][1][1]==bi[1][1]&&b[0][1][2]==bi[1][2]&&b[0][1]        [3]==bi[1][3]){
        cout<<"0"<<endl;//直接为目标情况
    }
    else{
        ans=bfs();
        cout<<ans<<endl;
        int e=0;
        while(1){
            for(int i=0;i<3;i++){
                if(n[l[t]][i]==t){//判断应该进行的操作
                    if(i==0) r[e]='A';
                    else if(i==1) r[e]='B';
                    else r[e]='C';
                    break;
                }
            }
            e++;
            if(t==0) break;
            t=l[t];
        }
        for(int i=e-2;i>=0;i--) cout<<r[i];//输出
        cout<<endl;
    }
    return 0;
}

```