

## $ \texttt{Introduction} $

一道思维题，但教练说如果不卡常没有紫题难度，这是为什么呢？

## $ \texttt{Solution} $

考虑到每次询问水的体积是固定的，我们就只要使温度 $ \times L$  的值最大即可。

问题转换到了这一步，还是很难做，那怎么办呢，我们注意到题目中的一个条件：每天早上都会有 $ v_i $ 单位，水温为 $ t_i $ 的水流进来，而这个条件恰恰是解题的关键，也就是水是一定要接的，只是倒水可以在接它之前倒好，也可以在接它之后倒好。

那么现在就有两种情况。

##### 之前的温度比这次水的温度小

那么显然把之前的水倒掉，因为加入水温度会变大，丧失同等体积水的情况下，温度低的水丧失的温度更小。

##### 之前的温度比这次水的温度大

也是同理，因为加入水后温度变小，那么一定加入以后倒。

到这里为止，我认为都没有什么思维难度，但是接下来，如何实现这个过程就有一些思维难度了，因为我们要满足加入这次的水之后，体积恰好为 $ L $ ,而这次之前，水的体积不一定要为 $ L $,这是个很难的问题，那怎么办呢，当然是看题解啦。

其实是维护一个单调队列，满足队列里温度递增，这样子每次只要取出队首，将他倒掉，使得满足当前的体积为 $ L-v_i $ ,看起来我们还是没有解决刚才的问题，但是如果我们考虑温度的混合公式，我们会发现，如果他乘上 $ L $ ，答案是一段一段的热量的相加，而会破坏这个秩序的只有倒水，如果我们把队首直接去掉，实际上就是在他倒入的时候直接去掉，而最后两个数不合并，就说明我们一定是在倒最后一次水之前将他倒了，这样子最后一次水就与前面几次倒水的贡献独立了，而如果合并，说明是倒了之后才倒水，因为我们把这两桶水捆绑了，而只有水是同一次倒的才能捆绑，至此，我们所要的操作全部实现。

## $ \texttt{Code} $

```c++
int main()
{
	//ios::sync_with_stdio(0);cin.tie();cout.tie();
    n=read();L=read();
    for (i=1;i<=n;i++) t[i]=read(),v[i]=read();
    //vol 现在的体积。 
    l=1;r=0;
    for (i=1;i<=n;i++)
        {
        	while ((v[i]+vol>L)&&(l<=r))
        	    {
        	    	lose=min(v[i]+vol-L,q[l].vol);
        	    	hq-=q[l].tmp*lose;
        	    	vol-=lose;q[l].vol-=lose;
        	    	if  (q[l].vol==0) l++;
				}
		    r++;q[r].tmp=t[i];q[r].vol=v[i];hq+=t[i]*v[i];vol+=v[i];
		    while ((l<r)&&(q[r-1].tmp>q[r].tmp))
		           {
		           	  q[r-1].tmp=(q[r-1].tmp*q[r-1].vol+q[r].tmp*q[r].vol)/(q[r-1].vol+q[r].vol);q[r-1].vol+=q[r].vol;r--;
				   }
			printf("%.7lf\n",hq/L);
		    
		}
    return 0;
}

```

