# 大意
给定 $k$ 和 $n$ 求出最大的 $i (i$ 为 $n$ 的因数,并且 $i\le k)$。
# 思路
## 思路推导
看到因数我们不免想到质数筛，

因为质数都是看除它与 $1$ 以外的数字有没有其他的因数。

在看到此题，就感到与质数筛没有太大的区别，都是**枚举因数**。

但是**不能用** $O(n)$ 的时间复杂度筛。

因为 $n(1\le n\le 10^9)$，再加上 $t$ 组数据那更不敢想。

所以我们要找到一个**非线性**的算法。

接下来有请一个十分重要的公式：

积数 $=$ 因数 $\times$ 因数。

这样我们就知道一个因数就可以**求出另一个因数**。

就减少了枚举另一数的时间了，道理我都懂，但要**怎么枚举**呢？

只要**枚举到** $\sqrt n$ 就可以了。

**为什么呢？**

我们可以尝试手写出一些数（不建议使用质数）的因数，然后从 $1$ 开始向后~~划~~并且~~划掉~~这个数对应的因数。

你会发现**最中间**的 $1$ 或 $2$ 个数是最后~~划掉~~的，你跟会发现这些数**近似**或**等于** $\sqrt n$。

这是又是**为什么**呢？

我现在令 $\sqrt n$ 为 $n$ 的因数，那 $n=\sqrt n\times\sqrt n$。

那 $n$ 此时就**不用向后枚举了**。

## 限定条件

因为我们是**枚举因数**，所以我们只需**枚举到** $\sqrt n$。

但**必须满足** $i\le k$ 这个限定条件。

## 答案判断

因为要令 $i$ **最大**，所以我们要取这两个**因数**中**最大**且**符合条件**的就可以了。

到此思路就结束了。

# 代码实现

```cpp
#include<iostream>
using namespace std;

int main(){
	int t;
	cin>>t;
	while(t--)
	{
		int n,k,maxx;
		cin>>n>>k;
		maxx=-1;//一定要赋值(局部变量) 0与-1一下都可以 
		for(int i=1;i*i<=n&&i<=k;i++)//i*i=n->i^2=n->i=sqrt(n)因为sqrt要开cmath所以就用i*i喽 
		{
			if(n%i==0)//如果i是因数 
			{
				maxx=(n/i<=k?max(maxx,n/i):max(maxx,i));
				/*
				三目运算符?:
				与if,else类似
				如果另一个因数(n/i)满足小于k条件
				就选另一个因数(n/i)
				否则选本来的因数(i)(i是已经小于k的故不判)
				*/
			}
		}
		cout<<n/maxx<<endl;//用此数除以最大且符合条件的因数
	}
} 
```