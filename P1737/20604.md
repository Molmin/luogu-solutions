# 前言

**litble可爱吗？**([可爱](https://blog.csdn.net/litble/article/details/80522567)/[不可爱](http://www.k-xzy.xyz/archives/5538))

皮一下我很开心，不过上面两个链接其实是我两个写blog的地方，造数据的代码和数据什么的可以去那里查看，这里就不放代码和具体数据，只讲思路咯。

# test3

可以利用一下精度的性质。

我们可以将这个a乘以一个很大很大的数，这样，如果它是0，那么S一下的结果就是0.5，如果它大于0，那么S一下就是1，如果小于0就是0.

然后脑补一下怎么把这三个结果处理成-1,0,1的形式就成了。

# test4

MAYA这是人做的点吗？Orz VFK太强啦！

考虑利用一下求导的基本手法（虽然咸鱼不会求导），得知当x的绝对值非常小时，s(x)可以近似看作$\frac{x}{4}+0.5$。

假定这个性质在这个test里面是会被用到的，人类的第六感告诉我们，负数要用这个性质的可能性更大。所以我们先尝试构造一个数$p$，使得当x为正的时候，$p$非常大（因为这个非常大一般构造为$2^{k_1}$的形式，所以我们姑且认为此时$p=2^{k_1}$）。而x为负的时候，$p=0$。

然后我们令$y=s(\frac{x}{2^{k_2}}+p)$，这样当x为正的时候，$y=1$，否则$x=0.5+\frac{x}{2^{k_2+2}}$。

这有什么好处呢？$(0.5-y)*2^{k_2+3}=-2x$，于是我们就把负数这部分搞完了。

而如果x是正数的话，这样操作以后的结果就是：$-2^{k_2+2}$，我们就要试图把这个东西搞掉。

想起有一个数在x为负数时是0而在x是正数时不是，那就是$p$，所以我们加上一个p要使得$-2^{k_2-2}=0$。

那么使得$k_1=k_2+2$即可。

至于$p$怎么构造呢，VFK给出的代码已经说了：

```cpp
In(x);
p=S((x+1e-30)<<500)<<152;//加上1e-30是为了处理0
y=S((x>>150)+p);
r=x+((-y+0.5)<<153)+p;
Out(r);
```

# test5

比较简单，直接模拟就好。注意不要进行无效操作（比如将$a_{32}$左移0位啦）

# test6
思路：每次计算一下$S((x-2^{k})*2^{500})$，就可以获得0和1。

但是每次都左移500位非常浪费节点，可以一开始将x左移500位，然后每次用高精度算出$2^{500+k}$。

这样我们每次求一位，要C一次，S一次,O一次。然后继续变形x，减去其最高位，假设这一位是t（t=0或1),那就是要左移一次t,一次t，x再加上一次-t，一共要进行6次操作。

注意到最后一位可以直接将x右移500位变回来然后输出，就可以节约一点点操作，正好190个节点。

**但是这样写了会WA**，因为如果某一次$x==2^{k}$，那么就算乘极大数最后结果也是0，$S(0)=0.5$。

所以我们要把$2^{k}$稍微弄小一点点，这样如果$x==2^{k}$算出来就是1了。

# test7
思路：首先使用上面那种方法，将两个数的二进制转化出来。由于不用输出，所以一共消耗316个节点，剩余平均每次异或可以使用9个节点。

观察什么叫做异或，发现当这两位加起来为1的时候，结果为1。加起来为2或者为0，结果都是0.设这个和为y.

那么怎么把这个2搞成0呢？显然我们是要利用2比较大这个性质，让某一个东西去减去y.

那么就是用S构造一个当输入1和2的时候输出1，否则输出0的东西。

也就是求一下$S((y-0.5)\times 2^{500}) \times 2-y$。

数一下发现正好是9次操作，由于左移0位没有意义之类的，我们还可以节约几次操作呢。

# test8
呃，根据求导的特性，当x很小的时候，拟合一种斜率，使得$\frac{S(x)-S(0)}{x}=0.1$，就可以很方便地解决该题。

那么我们把x除以一个很大的数，然后再加上一个数k，现在我们求使得$\frac{S(k)-S(0)}{k}=0.1$成立的k，就可以近似算出$0.1k+0.1 \times \frac{x}{2^{d}}$了。

如何求这个k呢？考虑利用checker三分法求解。

虽然这样理论可行，但是我太菜了愣是搞了一个小时没搞出来。

# test9

使用冒泡排序。

比较两个数a,b，使小的在前，大的在后，出题人已经构造了一种方法：

```cpp
t=a+b;
a=min(b-a,0)+a;
b=t-a;
```

然后这个`min(x,0)`的做法可以参照第4个测试点：

```cpp
p=S((x+1e-30)<<500)<<152;
y=S((x>>150)+p);
r=(((y-0.5)<<153)-p)>>1;
```

# test10
考虑用一个类似于快速幂的“快速乘”来实现。

那么首先把b转化为2进制，然后如果这一位是1，就加上$a \times 2^k$。
考虑用一个类似于test4的方法来实现这个功能。

设bk为b的第k位，先算出`y=S((bk-1)<<500)+(a>>150));`，如果bk=0，则y=0,否则$y=\frac{a}{2^{152}}+\frac{1}{2}$。

然后算`r=(y*2-bk)<<151`，这样如果bk=0就是0，否则就是a，就可以很方便地计算了。

至于取模，可以利用test3的那个函数，$a-m*2^k$大于0时等于1，否则等于0.然后等于1时减$m*2^k$，否则减0，利用以上操作实现。

# 总结

~~哈哈哈哈我没疯放开我我怎么可能做一道旷野造计算机就疯了呢哈哈哈哈~~

真爱生命，远离旷野大计算。

