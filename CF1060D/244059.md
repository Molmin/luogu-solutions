一道还不错的CF的思维题。

将大问题分解成几个子问题是惯用的解题思维。这道题也一样。

设$l[i],r[i]$分别是$i$左右的空椅子

我们思考在什么时候椅子可以公用？对于两个人$i,j$那很显然是在$l[i]=r[j],l[j]=r[i]$的时候.

此时我们只需要$l[i]+r[i]$个椅子。

我们接着思考，什么时候椅子可以重复用？根据样例三，我们可以得知，对于只有一个人时，$ans=max(l[i],r[i])+1$。

转化一下，其实在公用时的答案$l[i]+r[i]$不也正是满足这一条件吗？

这样我们就将全局的问题转化为二元组的问题了

那我们就得到柿子，也就是

$tot=\large min(\{\sum_{i=1,j=1}^nmax(l[i],r[j])\})$

换句话说，我们需要求n对二元组的和最小，其中二元组就是$max(l[i],r[j])$

这样做的复杂度是$O(n^2)$的，显然过不了。

那么我们贪心的去想：

要使满足条件的二元组的和最小，一定就是使每对二元组的$max$值尽量小。

不难想到，我们使用快速排序，然后相对应$l[i],r[i]$的最大值即满足条件。

这样二元组的问题就被解决了。

最后的答案就是$tot+n$(自己也要坐椅子的嘛！)

代码：

```cpp
signed main()
{
	int n;
	cin>>n;
	for(fint i=1;i<=n;i++)
	cin>>l[i]>>r[i];
	int bas=n;//初始至少有n把椅子
	sort(l+1,l+n+1);
	sort(r+1,r+n+1);
	int ans=0;
	for(fint i=1;i<=n;i++)
	ans+=max(l[i],r[i]);
	cout<<ans+bas;
	return 0;
}
```

