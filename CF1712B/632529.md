## 题意简述

给定正整数 $n$，求一个 $1$ 到 $n$ 的排列，使得 $\sum_{i=1}^n{\operatorname{lcm}(i,p_i)}$ 最大。

## Solution

众所周知，$\operatorname{lcm}(x,y)=\dfrac{ab}{\gcd (x,y)}$。

为了使单个 $\operatorname{lcm}$ 值最大，主要有两种方向：

- 减小 $\gcd$ 的值（极端情况则是使 $(x,y)$ 互素）
- 增大 $a \cdot b$ 的值

从前者角度思考，不难想到相邻两个数一定是互素的。

> 还是补充一下解释吧，明白的同学略过即可     
> （这里不采用严格证明，仅为了方便理解）    
> 辗转相除法的公式是 $\gcd(x,y) = \gcd(y,x \bmod y)$     
> 可得 $\gcd(x+1,x) = \gcd (1,x) = 1$

如果要构造一个第 $i$ 个数均与 $i$ 互素的排列的话，可能会想到把所有数字的位置都向后位移一个单位，比如：

```
1,2,3 -> 2,3,1
1,2,3,4 -> 4,1,2,3
```

但是这样得出的解并不是最优的，因为没有考虑 $a \cdot b$ 可以最大化。

从这种排列方式来看，最后一个数对答案的贡献仅为 $n$，而第一个数分配到了 $n$，对答案的贡献也仅为 $n$。

如果要使最大的两个数乘积最大，应该将最后两个数分别设为 $n$ 和 $n-1$。以此类推，每两个数进行交换显然最优，同时也保证了除 $1$ 以外所有元素与 $i$ 均互素。

因此，应该两两交换元素，在 $n$ 为奇数时忽略 $1$ 即可。仅从首末项考虑，在 $n$ 为奇数的情况下，将首项设为 $1$ 相比设为 $n$ 损失的贡献为 $n-1$，而从末项上多出的贡献为 $n(n-1)-n = (n-1)^2$，而其余项的贡献也没有变得更劣，显然这样做更优。

下面是 AC 代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
    int t,n;
    scanf("%d",&t);
    while(t--){
        scanf("%d",&n);
        if(n%2==1){
            //首项设为1，后面相邻项两两交换
            printf("1 ");
            for(int i=2;i<=n;i+=2){
                printf("%d %d ",i+1,i);
            }
        }
        else{
            //直接两两交换即可
            for(int i=1;i<=n;i+=2){
                printf("%d %d ",i+1,i);
            }
        }
        printf("\n");
    }
return 0;}
```