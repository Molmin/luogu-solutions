## 前言
###### 看到了一道很水的题 ，还以为很难呢，结果。。。。。
## 正解
题的意思就是向一个方向走，一直走，然后把走过的路的数加起来，看看哪条路为最大。还有它可能从这个墙穿过去到另外一个墙出来。

直接**暴力**搜索，枚举每一个点右上，右下，下，右走后能得多少分，像我这种蒟蒻，还能用啥方法呢！而且 `n` 的值那么小，不会炸的。

这样就可以了（**记得每次初始化哦**）。	
### AC代码

```cpp
#include<bits/stdc++.h>//i,j,k要从0开始，不要从1开始，不然报错 
using namespace std;
int n,m[200][200],ds,dw,s,d,mx=-1*0x3f3f;
int main()
{
	scanf("%d",&n);
	for(int i=0;i<n;i++)
	{
		for(int j=0;j<n;j++)
		{
			scanf("%d",&m[i][j]);
		}
	}
	for(int i=0;i<n;i++)//枚举位置 
	{
		for(int j=0;j<n;j++)//同上 
		{
			for(int k=0;k<n;k++)// 走k步 
			{
				s+=m[i][(j+k)%n];              //向下走，把对应的值累加
				d+=m[(i+k)%n][j];              //向右走，把对应的值累加
				ds+=m[(i+k)%n][(j+k)%n];        //向右下走，把对应的值累加
				dw+=m[(i-k+n)%n][(j+k)%n];      //向右上走，把对应的值累加
				mx=max(max(max(s,d),max(ds,dw)),mx);  //比较大小 不能放外面 
			}
			
			s=0,d=0,ds=0,dw=0; //初始化 
		}
	}
	printf("%d",mx); 
}
```
