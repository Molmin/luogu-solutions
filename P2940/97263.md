~~话说这一题这么水，怎么只有二十几人通过呢~~  
题干字很多，~~够我凑一篇英语作文了~~，内容也十分有（zhi）趣（zhang），其实大意就是**在一个矩阵中，找一个和最大的子串**，不过这个子串可以从一边到达另一边，且可以走对角线。  
思路很简单，就是枚举所有点，然后往右，下，右下，右上暴搜（题目说的很清楚1<=N<=200，不会超时），输出最大值。  
### 接下来就是各位期待的东西了：  
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[201][201],maxx=-10000000,i,j,k,w,x,y,z;  //maxx要足够小 
int main()
{
	cin>>n;
	for(i=0;i<n;i++)
	for(j=0;j<n;j++)
	cin>>a[i][j];                      //输入，不解释 
	for(i=0;i<n;i++)
	for(j=0;j<n;j++,w=0,x=0,y=0,z=0)   //枚举所有点，注意w,x,y,z要清零 
	for(k=0;k<n;k++)
	{
		w+=a[i][(j+k)%n];              //下 
		x+=a[(i+k)%n][j];              //右 
		y+=a[(i+k)%n][(j+k)%n];        //右下 
		z+=a[(i-k+n)%n][(j+k)%n];      //右上 
		maxx=max(max(max(w,x),max(y,z)),maxx);  //比较大小 
	}
	cout<<maxx;                        //输出 
}
```  
本人蒟蒻，不过代码也算易懂。如果代码有不善之处，或存在废话，~~拒绝~~欢迎各位大犇指正