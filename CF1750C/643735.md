### 序
1750，一个很好的数字捏。
## 题意
给定两个长度相同的 01 串 $a,b$。

每次操作可以选中两个下标 $l,r$，$\forall i \in[l,r],a_i=1-a_i$，同时 $\forall i\in[1,l-1]$ 或 $[r+1,n],b_i=1-b_i$。
## 思路

_像这种 $n$ 很大且又是求操作方案的题，一般都有特定的操作方法，绝对不是乱操作。_

—— 沃·兹基硕德

先来判断。

上结论：如果两个串之间的每个字符既不全部相同，又不全部相异，则无解。

考虑证明。

我们先假设最简单的一种情况：只有一组 $x,y$ 满足 $\forall i \in[x,y],a_i=b_i$，且 $1<x\leq y<n$，$x,y$ 外的 $i$ 全都满足 $a_i=1-b_i$。

那么我们选的 $l,r$ 就有三种情况：

1. 选中的 $[l,r]$ 与 $[x,y]$ 无交集

这种情况下，$[x,y]$ 外的 $a_i=b_i$，而 $[x,y]$ 内的 $a_i=1-b_i$。

2. 选中的 $[l,r]$ 与 $[x,y]$ 部分交集

这种情况下，$[l,r]$ 内与 $[x,y]$ 无交集的部分的 $a_i=b_i$，$[x,y]$ 内的 $a_i=1-b_i$。

3. 选中的 $[l,r]$ 被 $[x,y]$ 包含。

这种情况下，$[x,y]$ 内的 $a_i=1-b_i$，$[x,y]$ 外的 $a_i=b_i$。

4. 选中的 $[l,r]$ 包含 $[x,y]$。

仍会出现一些 $a_i=b_i$，另一些 $a_i=1-b_i$ 的情况，读者自证不难。

所以，无论怎么选择，总会陷入死循环。

那么结论得证。

所以我们的“特定的操作方法”是什么呢？

我们可以先不管 $b$ 串，将 $a$ 串中的 1 全部修改成 0。

模拟可知：

- 当 $a,b$ 相同且操作次数（即 $a$ 中 1 的个数）为奇数时，最后 $a=00000....$
，$b=11111....$。

- 当 $a,b$ 全部相异，且操作次数为偶数的时候，也是 $a=00000....$，$b=11111....$。

其他情况下直接就可以将 $a,b$ 置零。

那么上述情况就需要用到我~~乱搞出来~~的特定解题方法：

```cpp
1 n//a 串全部置1
1 1
2 n//奇妙乱搞
```

至此，本题解决。

## 正确代码
```cpp#include<bits/stdc++.h>
using namespace std;
int a[200001],b[200001];
int t,n,i,k,s;
bool f,g,h;
int main()
{
	scanf("%d",&t);
	while(t--)
	{
		scanf("%d",&n);k=s=f=g=h=0;
		for(i=1;i<=n;i++) scanf("%1d",&a[i]);
		for(i=1;i<=n;i++)
		{
			scanf("%1d",&b[i]);
			if(a[i]==b[i])f=1;
			else g=1;
		}
		if(f&&g)//判断
		{puts("NO");continue;
		}
		puts("YES");
		for(i=1;i<=n;i++)
			if(a[i])k++;
		s=k;
		if((f&&(k%2)) || (g&&(k%2==0)))s+=3,h=1;//此时多了3步操作，具体见上
		printf("%d\n",s);
		for(i=1;i<=n;i++)
			if(a[i])printf("%d %d\n",i,i);//先将a置零
		if(h)printf("1 %d\n1 1\n2 %d\n",n,n); 
	}
	return 0;
}
```