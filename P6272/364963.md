[传送门](https://www.luogu.com.cn/problem/P6272)

#### 前置知识：

平衡树（Treap/替罪羊树），~~应该没人会了平衡树不会线段树吧 qwq~~

#### 题意：

* 定义一种数：$0$ 是数，其他的数用 $(x_L, x_R)$ 表示，其中 $x_L,x_R$ 也是这种数。

* 定义等于：$0=0$；当 $x_L=y_L,x_R=y_R$ 时，认为 $(x_L, x_R)=(y_L, y_R)$。

* 定义小于：对于 $x \neq 0$，有 $0<x$；当 $x_L<y_L$ 时或 $x_L=y_L,x_R<y_R$ 时，认为 $(x_L, x_R)<(y_L, y_R)$。

* 现在有一个长度为 $n$，初始值均为 $0$ 的数列 $\{a_n\}$，处理 $m$ 次操作，每次操作分为两种：将 $(a_l, a_r)$ 赋值给 $a_k$；询问 $a_{l...r}$ 中最大数的编号，如果有相同的数，输出最小的编号。

* $n\le 10^5$，$m\le 5×10^5$。

~~好长的简述~~

#### 分析：

暴力想法是递归比较，但是每次更改操作可能使一个数中 $0$ 的数量增加至两倍，会 T。

注意到，每一次操作都最多只能增加一个数，所以最多只会出现约 $m$ 个不相同数；并且每次的新数都是由曾经出现过的数组成的，那么就可以通过曾经出现过的大小关系来进行新数与旧数的比较。

每两个数之间有一个大小关系，那难道我们要存储 $m^2$ 种关系？当然不用，注意到题目所提供的条件：

$$x\le y,y\le z \Rightarrow x\le z$$

（~~其实不需要题目提供~~），这意味着这种数与常规数的大小关系是类似的，因此我们可以给每个数赋上一个常规数的权值，通过比较常规数来比较这种数的关系。

如果能够方便地维护这样的权值，由于修改又是单点修改，故只需要开一棵线段树就可以处理区间最大值；因此先考虑如何维护权值。

当产生一个新数时，我们需要给其赋上一个新权值，而由于新数 $(a_l, a_r)$ 和旧数 $(x_L, x_R)$ 中的 $a_l,a_r,x_L,x_R$ 权值都已知，因此比较就可以 $O(1)$ 进行。假设这个权值序列有序，我们就可以 $O(\log n)$ 查找新数应该在哪个位置。

而维护一个序列，支持在序列中间插入元素，显然可以使用 set。

然而，如果不停地在两个数中间插入新数，就会这样：

![这里是一张图 qwq](https://z3.ax1x.com/2021/05/27/2i8MjI.png)

（这里的 al, ar 显然并不是 $a_k=(a_l, a_r)$ 的 $a_l,a_r$，而是某两个数的常规数权值）

当分割很多次后（~~尤其是五十万次~~），剩下的区间就会很小，导致精度不够的问题。

但是，我们由此联想到，这类似于一条无限下降的链：

![另一张图](https://z3.ax1x.com/2021/05/27/2i8vrt.png)

那么，我们可以通过“旋转”来降低链的高度，即提升了区间的大小；同时也保证相对大小关系不变，而我们维护的“权值”正好只考虑相对大小，十分合适。

![挺多余的图](https://z3.ax1x.com/2021/05/27/2iG4zj.png)


考虑实现。~~肯定不能用 set 了~~，可以手写平衡树，每个节点上不仅存放权值，还存放该节点权值的上下界（方便旋转），“旋转”就对应树的旋转。此时，旋转就不只是改变了节点的父亲儿子关系，也改变了节点的权值。

举个例子，假设上图中，节点 al 权值为 0，节点 ar 权值为 16，并且只考虑以 m1 为根的子树。那么旋转前：

|节点| m1 | m2 | m3 | m4 |
| :----------: | :----------: | :----------: | :----------: | :----------: |
|父亲| / | m1 | m2 | m3 |
|权值| 8 | 4 | 2 | 1 |
|上下界| (0, 16) | (0, 8) | (0, 4) | (0, 2) |


旋转后：

|节点| m1 | m2 | m3 | m4 |
| :----------: | :----------: | :----------: | :----------: | :----------: |
|父亲| m2 | / | m2 | m3 |
|权值| 12 | 8 | 4 | 2 |
|上下界| (8, 16) | (0, 16) | (0, 8) | (0, 4) |

虽然可以保证精度，但每次旋转都要更新子树所有节点的权值，若旋转次数多（如 Splay）就不能接受。考虑替罪羊树（无旋）或 Treap（期望旋转次数 $O(1)$）实现。

同时，为了方便比较，对于数 $x(x_L, x_R)$ 还应该存储 $x_L$ 和 $x_R$（~~虽然这个存在树外面也行~~）。

#### 思路：

1. Treap 维护每个数的权值，每次赋值操作对应着插入新数或者发现新数与某旧数相同。~~蒟蒻不会替罪羊~~

2. 使用线段树维护区间最值，每次赋值操作进行单点修改。（虽然整颗子树权值改变，但相对大小关系不变，故只需修改新数对应的位置。）

---

给出 Treap 部分的代码。

```cpp

double mn[mS], mx[mS];	//下界，上界 
double rk[mS];	//rk[p] 表示平衡树中节点 p 的权值，与 (mn[p]+mx[p])/2 相等 
int totn;
int son[mS][2], rd[mS], xl[mS], xr[mS];
//xl xr 即 (xL, xR)，就是这个数从哪里来 
namespace Treap {
#define lc son[p][0]
#define rc son[p][1]
	int rt;
	inline void build() {	//插入第一个节点，因为这个时候要赋值初始的上下界，所以单独写 
		rt=++totn, rd[rt]=rand(), xl[rt]=0, xr[rt]=0;	//这个数是 (0, 0) 
		mn[rt]=0, mx[rt]=inf, rk[rt]=(mn[rt]+mx[rt])/2;
	}
	inline void push_down(int p) {	//向下传递 mn 和 mx，同时用自己的上下界更新自己的权值。
		mn[lc]=mn[p], mx[lc]=mn[rc]=rk[p]=(mn[p]+mx[p])/2, mx[rc]=mx[p];
	}
	inline void update(int p) {	//更新整个子树内节点的权值 
		push_down(p);
		if(lc) update(lc); if(rc) update(rc);
	}
	inline void rotate(int &p, bool t) {
		int x=son[p][t^1];
		son[p][t^1]=son[x][t], son[x][t]=p;
		mn[x]=mn[p], mx[x]=mx[p], update(p=x);	//旋转时要把 p 的上下界赋给 x，再更新整个子树 
	}
	inline int insert(int &p, int f, int l, int r) {	//f 表示 father
		if(!p) {
			p=++totn, rd[p]=rand();
			xl[p]=l, xr[p]=r;
			push_down(f), rk[p]=(mn[p]+mx[p])/2;	//push_down f，用来得到 p 的上下界 
			return p;	//返回值是新数 (l, r) 的编号 
		}
		if(rk[l]==rk[xl[p]] && rk[r]==rk[xr[p]]) return p;
		bool t=!(rk[l]<rk[xl[p]]||rk[l]==rk[xl[p]]&&rk[r]<rk[xr[p]]);
		//括号内表示 (l, r) 比 p(xl, xr) 小，那 !(...) 就是 (l, r) 比 p 大
		//等等我为什么要这么写 
		int res=insert(son[p][t], p, l, r);
		if(rd[son[p][t]]<rd[p]) rotate(p, t^1);
		return res;
	}
#undef lc
#undef rc
}
```