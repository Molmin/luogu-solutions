## 一个不知道是什么的算法，算是维护半个并查集吧
我看到这道题是第一眼发现这不是就是主席树，然后看题解都是什么划分数，主席树，可持久化平衡树(:认真 ~~我真的翻完所有的题解，没有看到一个思路和我一样的~~)。

然后想了想感觉按照主席树的写法有点浪费空间，然后我就想用vector去模拟一下链表，存一下修改的值
```cpp
vector<int> a[maxn + 5], b[maxn + 5];
int pr[maxn + 5], f[maxn + 5];
```
先介绍一下变量的用途吧，主要的操作就是依照上面的那些东西

其实最开始我是想用pair但是不知道怎么写可以用lower_bound直接搜所以我开了两个数组a数组存的是第几代，b数组存的是a数组表示第几代的那一次的操作数

pr数组存的就是并查集的祖先，至于为什么前面我说这是维护半个并查集就是因为我不会用到合并路径的操作，也就是锁pr数组里只会存第i个版本依存的vi的版本的编号，其实感觉要是数据强的话我这样写会T掉，毕竟没有合并路径

f数组存的是当前操作是否被修改(默认0版本是没有被修改的,所以我特判了一下0，因为只有在编号为0的版本中相当于所有的数都是被修改过的)，如果没有被修改则存0，若是被修改过那f数组就存下来是这一行哪一个数被修改过了

...cpp/* 假装一个cpp格式 */

//下面仅仅包含处理工作也就是说查询操作不讲该怎么输出,输出操作我写到代码注释里面了

...

先分析一下题意，如果对于一次查询操作，那么这个数组是不会被改变的，所以说我就让
```cpp
pr[i] = vi;//i是第i个版本,vi是这一个版本依存的上一个版本
 f[i] = 0;//我在代码中没有写，因为可以不写，不过这个就代表这个版本是查询操作留下了的版本
```
然后我就可以不用管这一版本，也就是说不用为这一版本新存一下，直接留一个索引到上一个版本就行

对于修改操作如下
```cpp
pr[i] = vi;  //如上
 f[i] = loci //第i个版本中第loci个位置被修改了
 a[loci].push_back(i); 
 b[loci].push_back(vaule);//a,b两个数组存的是第i个版本中存下来vaule，只有这个位置是可以不用管和祖先的关系，如果查询到第i个版本中的f[i]为真，并且查询到第loci这个位置就可以直接返回b的值了
 ```

我来分析一下样例 数目太多我就分享一下后5次操作//本来像分析前五次操作，但是发现前五次操作没有什么好分析的
![](https://cdn.luogu.com.cn/upload/pic/59326.png)

这个是我样例弄完之后的存储状况，空白的就相当于没有

![](https://cdn.luogu.com.cn/upload/pic/59327.png)

对于第六次，第七次查询的是0版本没有什么好说的

第八次查询操作时第四个版本

所以说pr[8] = 4, f[8] = 0;

第九次和上一次一样

第十次就是对第一版本的进行第五个书修改

所以pr[10] = 1, f[10] = 5;

然后再a[5]和b[5]后面分别加入一个10和91表示第十个版本更新成91


```cpp
#include <bits/stdc++.h> 
using namespace std;

const int maxn = 1e6;
vector<int> a[maxn + 5], b[maxn + 5];
int pr[maxn + 5], f[maxn + 5];

int32_t main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(0); cout.tie(0);// 这个就不说什么意思了
    int n, m, x, vi, op, l, v; cin >> n >> m; // 读入操作
    for(int i = 1 ; i <= n ; i ++)
    {
        cin >> x;
        a[i].push_back(0);
        b[i].push_back(x);
    }//处理最初的数组值，而且最初时第0代
    for(int i = 1 ; i <= m ; i ++)
    {
        cin >> vi >> op >> l;
        pr[i] = vi; // 表示第i代版本是由第vi代版本继承而来
        if(op == 1) 
        {
             cin >> v;
             a[l].push_back(i);
             b[l].push_back(v); // 对于a和b应往最后加一个这是第i代版本(为了后面查找方便)，和这个版本第l个位置的值
             f[i]  = l; //表示第i行第l个数被修改了
        }
        else
        {
			while(true) // 神奇的while(true)
			{
				int x = vi;
				if(x == 0) // 如果这个版本的所依赖的为0就直接输出第0个元素
				{
					cout << b[l][0] << endl;
					break;
				}
				else if(f[x] == l) // 如果这个当前版本所依赖的版本时被修改过的，并且修改的是第l列就二分查找a[l]数组找到出现过的版本的位置
				{
					int y = lower_bound(a[l].begin(), a[l].end(), vi) - a[l].begin();
					if(y + a[l].begin() == a[l].end()) y -= 1; // 如果没有就减1，应该有,加不加这一行是不是过的我也不清楚
					cout << b[l][y] << endl;
					break;
				}
				else
				{
					vi = pr[vi]; // 并查集的操作，一步一步往上找，不过不能合并路径(其实可以只是这样写会麻烦一点，而且不写就可以过,所以我就没有写)
				}
			}
        }
        
    }
    return 0;
}

```

### 感觉我写的这个有点迷，不知道改怎么题现我的思路，如果对于这份题解有问题的话可以私信我