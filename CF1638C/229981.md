## CF1638C Inversion Graph

### 题意
给定 $n$ 阶排列 $p_1,p_2,...,p_n$。当 $i<j$ 且 $p_i>p_j$ 时，$p_i$ 与 $p_j$ 之间有一条无向边。求所有 $n$ 个点构成的连通块总数。$t$ 组询问。

### 限制
$\sum n\le 2\times 10^5$。

### 题解一

考虑从后往前遍历整个排列，用 $\text{std::set}$ 维护之前所有 独立的连通块的块内最小值。

考虑当前的 $p_i$，将 $set$ 中可以与 $p_i$ 合并的连通块全部拿出来，将合并之后的块的最小值扔回去。（具体一点，就是将 $set$ 中 $<p_i$ 的元素全部拿出来，与 $p_i$ 取 $min$ 之后将这个 $min$ 扔到 $set$ 中）

正确性：对于任意 $p_i$，如果能与后面的块合并，那么 $p_i$ 一定 $>$ 块内最小值，归纳可知从后往前贪心合并是对的。

时间复杂度 $O(n\log{n})$。

但是我们发现好像没必要用 $\text{std::set}$，可以用单调栈就能做到 $O(n)$。

代码：

$\text{std::set}$ 做法：[CF 提交记录](https://codeforces.com/contest/1638/submission/146471661)

单调栈做法：[CF 提交记录](https://codeforces.com/contest/1638/submission/146719876)

### 题解二

考虑连通块长什么样子。

结论：任意块一定是连续的数构成的，并且任意两个编号为 $i,j~(i<j)$ 的连通块都有 $\max\limits_{x\in i}\{x\}<\min\limits_{y\in j}\{y\}$。

证明连续：如下图，假设第 $i$ 段不连续，红色部分是穿插于 $i$ 中的一些其他元素 $x$。那么如果 $x$ 不被它前面的 $i$ 合并，说明它比前面 $i$ 中的最大值还大，那就一定会与后面的 $i$ 合并。Q.E.D.

![](https://cdn.luogu.com.cn/upload/image_hosting/6jcfwmrl.png)

证明 $\max\limits_{x\in i}\{x\}<\min\limits_{y\in j}\{y\}~(i<j)$：因为已经证明了连续，块之间肯定无交集，所以不满足这个式子的一定会合并。Q.E.D.

有了这个结论，我们可以知道块的整体高度是严格递增的，也就大概长这样：

![](https://cdn.luogu.com.cn/upload/image_hosting/96n8w0sq.png)

所以预处理前缀最大值与后缀最小值，然后从左到右遍历 $n$ 个数，一旦出现 $x$ 满足 $\max\limits_{i=1}^x\{p_i\}<\min\limits_{j=x+1}^n\{p_j\}$，就说明新的块出现了，由于第一块未统计，所以最后答案要 $+1$。

时间复杂度 $O(n)$。

代码：[CF 提交记录](https://codeforces.com/contest/1638/submission/146617046)

### 题解三

结论一：当前 $i$ 个数恰好是 $1$ ~ $i$ 的排列时，就会产生一个新的块。

证明：前 $i$ 个数是 $1$ ~ $i$ 的排列，说明前 $i$ 个数无法与后面的块合并；也不与 上一次出现同样情况的下标 $j$ 合并，因为 $j+1$ ~ $i$ 的数全部大于 $j$ 之前的数。Q.E.D.（注：“上一次出现同样情况的下标 $j$”是指，前 $j$ 个数是 $1$ ~ $j$ 的排列，且 $j$ 是满足 $j<i$ 的最大 $j$）

可以权值树状数组 $O(n\log{n})$ 做。

结论二：结论一等价于 $\max\limits_{j=1}^i\{a_j\}=i$。（或 $\min\limits_{j=i+1}^{n}\{a_j\}=i+1$）

证明：如果前 $i$ 个数中有 $>i$ 的数，显然矛盾。后面那个形式同理。Q.E.D.

所以只需要边输入边记录最大值即可时间复杂度 $O(n)$，空间复杂度 $O(1)$ 做完。

代码：[CF 提交记录](https://codeforces.com/contest/1638/submission/146720087)
