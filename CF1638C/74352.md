### 3.CF1638C Inversion Graph

#### 3.1 题目描述（[传送门](https://www.luogu.com.cn/problem/CF1638C)）

##### 3.1.1 题目大意

给定一个 $1$ 到 $n$ 的一个排列 $p_1,p_2,...,p_n$ 。

按照下列方式构建一个无向图：

- 对于所有的 $i<j$ ，如果满足 $p_i>p_j$ ，则连接一条由 $i$ 到 $j$ 的无向边。 （辅助理解：每对逆序对都连接一条无向边）

你的任务是求出该无向图有多少个连通块。

##### 3.1.2 输入格式

第一行一个整数 $t\ (\ 1\leq t\leq 10^5\ )$ ，表示测试组数。

每组第一行一个整数 $n\ (\ 1\leq n\leq 10^5)$ ，表示排列的长度。

每组第二行 $n$ 个整数 $p_1,p_2,...,p_n\ (\ 1\leq p_i\leq n\ )$ ，表示给定的一个长度为 $n$ 的排列。

可以保证 $t$ 组测试的 $n$ 的和不超过 $2·10^5$ 。

##### 3.1.3 输出格式

共 $t$ 行。

对于每组测试，输出一个整数 $k$ ，表示该排列构建的无向图的连通块数目。

##### 3.1.4 样例

###### 输入 #1

```cpp
6
3
1 2 3
5
2 1 4 3 5
6
6 1 4 2 5 3
1
1
6
3 2 1 6 5 4
5
3 1 5 2 4
```

###### 输出 #1

```cpp
3
3
1
1
2
1
```

##### 3.1.5 样例解释

每组测试的情况如下图所示。带颜色的方块表示排列中的每一项。对于一个排列，每种颜色代表一个连通块。颜色的数量就是答案。

![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF1638C/555cddc5b98ba416425dd4322ce8f820d678b370.png)

#### 3.2 解题思路

我们考虑数列中最大的元素所在的连通块：

- 该连通块包含的元素应该为最大元素及其后面所有元素。

我们再考虑次大元素所在的连通块：

- 如果次大元素在最大元素后面，则其在最大元素所在连通块。
- 否则，次大元素在最大元素前，则排列为： $X,...,X,\text{次大},Y,...,Y,\text{最大}$ 。次大元素到最大元素之间的部分为一个连通块。

一般情况： $X,...,X,\text{小元素},Y,...,Y,\text{大元素},Z,...,Z$。此一般情况含义为： $\text{大元素}>\text{小元素}>Y,\text{大元素}>Z,\text{小元素}>X$ 。即 $\text{大元素}$ 和 $Z$ 在同一连通块内， $\text{小元素}$ 和 $Y$ 在同一连通块内。

- 如果 $Z$ 中有元素比 $\text{小元素}$ 小，则将其连边，说明 $\text{大元素}$ 和 $Z$ 和 $\text{小元素}$ 和 $Y$ 在同一连通块内。
- 否则，说明 $\text{大元素}$ 和 $Z$ ， $\text{小元素}$ 和 $Y$ 二者没有连边，分属两个不同的连通块。

因此我们的步骤如下：

1. 将原数列记录下标并排序。
2. 从最大数向最小数遍历。
3. 如果小数下标小于大数下标，则可能增加连通块。具体判断为大数后是否存在比小数小的数。

判断大数后是否存在比小数小的数，如果单纯遍历的话，复杂度为 $O(n)$ ，外面套上从最大数向最小数遍历，复杂度为 $O(n^2)$ ，显然不能过此题。

因此我们预处理出比小数小的数字中最大的那一个（的下标），即可 $O(n)$ 预处理， $O(n)$ 遍历即可。总时间复杂度为 $O(n)$ 。

#### 3.3 解题代码

```cpp
#include <iostream>
#include <algorithm>
using namespace std;
int T,n;
struct node
{
    int i,x;
}b[100010];
int d[100010];
bool cmp(node x,node y)
{
    if(x.x==y.x)return x.i<y.i;
    return x.x<y.x;
}
int main()
{
    scanf("%d",&T);
    while(T--)
    {
        scanf("%d",&n);
        for(int i=1;i<=n;i++)
        {
            scanf("%d",&b[i].x);
            b[i].i=i;
        }
        sort(b+1,b+1+n,cmp);
        for(int i=1;i<=n;i++)//d[i]表示 比下标为i的数字小的数字中 下标最大的下标
            d[i]=max(d[i-1],b[i-1].i);
        int t=n+1;//t表示大数的下标，初始时要大于n
        int cntt=0;//连通块数目
        for(int i=n;i>=1;i--)
        {
            if(b[i].i<t)//如果小数下标小于大数下标
            {
                if(d[i]<t)
                    cntt++;//如果比小数小的数字的下标小于大数的下标，说明小数连通块和大数连通块不连通，总连通块个数增一
                t=b[i].i;//更新大数的位置
            }
        }
        printf("%d\n",cntt);
    }
    return 0;
}
```

#### 3.4 解题心得

考场上碰到此题：“诶？这题不是我刚才想错那个想法嘛。”做 B 题时就想过将原数列记录下标然后排序。于是直接将没有过 B 题的代码复制粘贴，修修补补，过了此题。如果没有 B 题，本题可能也没有那么快能想到解法。阴差阳错了属于是。

不过这道题还是挺考思维的，如何在 $O(n)$ 的时间内完成建边和连通块的统计需要注意。

思维题，可能有思维的局限，如果有 hack 数据欢迎补充。

本场 CF 前三题都是考数列的问题，思维题。 D 题好像是搜索，但是考场没实现。之后实现也还没过，过了再补题解吧。