### 前言

本场比赛(#771 div2) tourist 有在 [twitch](https://www.twitch.tv/the__tourist)（科学上网）直播切题 + 讲评（英语，真·俄罗斯口音 XD

回看应该在[油管](https://www.youtube.com/channel/UCkySD00cmDWYHXA31hqRYRw)会放。

### 题解

考虑有两个数字 $100,20$，中间夹了一个数 $x$：

![image-20220215133728280.png](https://s2.loli.net/2022/02/15/9AbwEL2yFPWRofJ.png)

$100\to20$ 显然有边，而满足下面两个条件中的任意一个，$x$ 都会被连到这个连通块里。

1. $x<100$
2. $x>20$

显然 $x$ 必被连到连通块里。

也就是说，对于某个数 $p_i$，对于任意在它右侧且比它小的 $p_j$，$[i,j]$ 中所有数都会是一个连通块。

对于连通块 $[l,r]$ 中最大的数 $p_i$，同理可以延申到 $p_{r'}$，则 $[l,r']$ 可以更新原来的连通块。

那么当 $r=r'$ 时就不再能更新了。

我们可以暴力模拟这个过程，首先定义 $l=r=1$，然后查询区间 $[l,r]$ 的最大值 $M$，并找到右边最后一个小于 $M$ 的位置 $r'$，令 $r\leftarrow r'$，然后不断重复，直到 $r=r'$。然后令 $l=r=r'+1,ans\leftarrow ans+1$。

此时有 $O(n\log n)$ 解法：

发现区间 $[l,r]$ 最大值 $M$ 其实就是前缀 $[1,r]$ 最大值，因为若存在某个数 $x\in[1,l-1]$ 且 $p_x>M$，那么显然会从 $[x,l-1]$ 更新到 $[x,r]$。

处理出后缀 $\min$，然后可以二分查找小于 $M$ 的位置。

可以优化。我们考虑什么时候不会更新：前缀 $\max$ 小于后缀 $\min$。

注意到给出的是一个排列，若前缀 $\max$ 小于后缀 $\min$，显然这个前缀应该是一个 $1\sim\max$ 的排列（反证法，如果不是显然可以往右拓展）。

此时可以做到 $O(n)$，处理前缀 $\max_i$，若发现其值恰好为 $i$，$ans\leftarrow ans+1$。

```cpp
for(int i = 1; i <= n; ++i) {
    mx = max(mx, a[i]);
    if(mx == i) ++ans;
}
```



~~测试时并没有想到 $O(n)$，看到 tourist 能在 5 min 内切掉并敲出这这么简洁的代码着实让我佩服~~

