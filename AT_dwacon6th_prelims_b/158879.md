$upd:$增加了一处式子的中间计算过程，使得看起来更加有规律；代码增加了3处注释。

# 说明

本题解是对唯一一篇题解（LCuter大佬）中一些模棱两可的概率推导的补充，以及一些实验验证。

# 正文

第一篇题解考虑最后结果的期望怎么求，由于该题中两个史莱姆移动到一起就相当于只有一个史莱姆了，所以我们可以看成每个史莱姆只移动了一次。而我们最后要求的期望，可以转化为每个史莱姆走的距离的期望之和（即$E(\sum a_i)=\sum E(a_i)$） 。

下面考虑怎么算某个$E(a_i)$ 。

## 理论分析

我们以考第一只史莱姆为例子进行分析。第一只史莱姆可能在移动时移动几个空呢？显然可能取值是$1$到$n-1$。我们假设$n=5$模拟一下，找找规律。

我们考虑**移动操作进行顺序的全排列**，即对$1$到$n-1$个数进行全排列（第$n$个不用管他，他只能被动合并，不能主动合并）。

要想让1号史莱姆移动1步，那么2号必须在1号之后进行移动，即$1,2$在整个$1$到$n-1$的全排列中相对顺序是$2,1$，显然其概率为$\frac{0!}{2!}=\frac{1}{2}$。

要想让1号史莱姆移动2步，则2号必须在1号之前移动，且3号必须在1号之后移动，即在123的全排列中，1必须排在中间，且2在前面，3在后面，这种概率是$\frac{1!}{3!}=\frac{1}{6}$，其中$3!$指的是$1,2,3$的全排列数。

1号想移动3步，则23必须在1号前面移动，且4号必须在1号后面移动，所以概率是$\frac{2!}{4!}=\frac{1}{12}$ ，其中$2!$指的是$2,3$ 的相对顺序（即是$2,3$还是$3,2$），$4!$为$1,2,3,4$的全排列数。

走$1,2,3$步的情况都分析清楚了，而走$4$步的情况，就是$2,3,4$全在$1$前面，因为只有$5$个数，所以相当于是在$1$到$5$的全排列中，$1$在第四个，$5$在第五个，另外三个在前三个里面随便排，所以概率为$\frac{3!}{4!}$ 。

可以验证，$n=5$时，这四个概率加起来可以归一化。且不管$n$是多少，这样分析的话，总会发现概率加起来是可以归一化的。在计算期望时，我们稍微观察一下，就能发现明显的规律：其实对于第一个史莱姆来说，其期望就是$1+\frac{1}{2}+\frac{1}{3}+…+\frac{1}{n-1}$，即调和级数求和。

## 实验验证

手动计算：考虑史莱姆个数是$2,3,4,5,6$时，1号史莱姆移动距离的期望，手算结果分别是$1,1.5,1.83,2.08,2,28$，而实验结果如下：

![](https://cdn.luogu.com.cn/upload/image_hosting/5n0javxu.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

这在一定程度上验证了刚才的理论分析。

## 实验代码

下面附上验证该理论分析的实验代码：

```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
const int T=1e4+9;
int cnt[15],a[15],now,pos,ans;
bool create[15];
bool used[15];
bool flag=false;
int main(){
	ll tmp,step;
	srand(998244353);
	for(int N=2;N<=6;N++){
		ans=0;
		for(int i=1;i<=T;i++){
			flag=false;
			now=0;
			step=1;
			for(int j=1;j<=N;j++){
				create[j]=false;
				used[j]=false;
			}
			while(!flag){
				flag=true;
				tmp=rand()%N+1;
				if(!create[tmp] && tmp!=N){
					create[tmp]=true;
					a[++now]=tmp;
				}
				for(int j=1;j<N;j++){
					if(!create[j]){
						flag=false;
						break;
					}
				}
			} //生成一个移动全排列 
			for(int j=1;j<=N;j++){ //找一下1号史莱姆是第几个被移动的
				if(a[j]==1){
					pos=j;
					break;
				}
			}
			for(int j=1;j<pos;j++){
				used[a[j]]=true; //把在1号之前移动的史莱姆进行移动 
			}
			for(int j=2;j<N;j++){//遍历看看到底1号在该次模拟中走几步
				if(used[j]){
					step++;
				} else {
					break;
				}
			}
			ans+=step;
		}
		printf("N=%d Expectation=%lf\n",N,(1.0*ans)/T);
	}
	return 0;
}
```

在明白了上面的理论分析之后，就可以放心大胆的按照第一篇题解中所说的那样去做了。