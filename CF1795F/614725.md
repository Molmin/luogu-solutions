如果刚开始考虑每个点怎么走较为麻烦，我们考虑反向考虑：已知每个点需要走多少步，贪心的考虑怎么走最优。不妨先给树确定一个根，就假设是点 $1$ 吧。

容易发现，答案是具有单调性的，因此可以二分。这样可以算出每个点需要走的步数。在对应的位置存下来，点 $i$ 存的 $step_i$ 就表示在该位置的点需要走的步数（若没有点则 $step_i=0$）。并且，所有点能往下尽量往下走一定是最优选择，这个贪心策略不难证明。

接下来就可以自下而上移动点了。首先简单树形 $dp$ 一下，设 $f_i$ 表示 $i$ 位置上的点能往下走的最大步数。用 $col$ 数组表示当前点的颜色（黑色表示走过，即 $1$）。那么 $f_i=\max\limits_{j\in son_i,col_j=0}\{f_j+1\}$。 

那么，如果需要的步数小于等于能往下的最大步数就直接下去了，不用管了。否则，我们先将它移到父节点，在回溯上去的时候继续考虑。

时间复杂度 $O(n\log n)$。洛谷 RMJ 坏了，可以看这个 CF 的提交记录。[代码](https://codeforces.com/contest/1795/submission/212219168)。