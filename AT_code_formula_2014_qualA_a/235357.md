开门见山——

**打表+二分** //ORZ打表大法好

我第一眼看到这道题是脑中就出现了一个奇妙的想法~
```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	for(int i=1;i<=100;i++) printf("%d,",i*i*i);
    //题目说最大1000000，所以打到100的立方就够了
	return 0;
} 
//辅助打表
```
于是我们就有了数据，并写出以下代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[100]={1,8,27,64,125,216,343,512,729,1000,1331,1728,2197,2744,3375,4096,4913,5832,6859,8000,9261,10648,12167,13824,15625,17576,19683,21952,24389,27000,29791,32768,35937,39304,42875,46656,50653,54872,59319,64000,68921,74088,79507,85184,91125,97336,103823,110592,117649,125000,132651,140608,148877,157464,166375,175616,185193,195112,205379,216000,226981,238328,250047,262144,274625,287496,300763,314432,328509,343000,357911,373248,389017,405224,421875,438976,456533,474552,493039,512000,531441,551368,571787,592704,614125,636056,658503,681472,704969,729000,753571,778688,804357,830584,857375,884736,912673,941192,970299,1000000};
int main(){
	int n;
	cin>>n;
	if(binary_search(a,a+100,n)) printf("YES");
    //二分快一些
	else printf("NO");
	return 0;
} 
```


------------
**正解开始——**

咳咳，本题的数据范围不大，有点水，所以很多暴力都能过

~~（貌似暴力本来就能过）~~

这里其实不用二分，但我想借此题解为~~刚入门的~~同学们科普一下OI里的神器——二分答案

先讲思想：

如果你有一个数组，想查找一下某个数在不在其中，你会怎么办？

最直接的手法就是一个个枚举看相等不相等：
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[10]={0,1,2,3,4,5,6,7,8,9};
  //为方便讲题就直接给数据
int main(){
	int x;
	cin>>x;
	for(int i=0;i<10;i++){ //暴力枚举
		if(a[i]==x){
			printf("YES");
			return 0;
		}
	}
	printf("NO");
	return 0;
}
```
在这里看不出来有什么不妥，但是我们想想：如果数组元素个数很大呢？这时候一个个暴力枚举就很耗时间，不够效率，于是有了二分：
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[10]={0,1,2,3,4,5,6,7,8,9};
  //数据不变
int main(){
	int x;
	cin>>x;
	int L=0,r=9,mid;
  //左右指针，左为下限，右为上限，mid表示中间值
	sort(a,a+10);
  //注意，二分数列必须有序
	while(L<=r){ //只要左右不交错
		mid=L+r>>1; //可以把它理解为mid=(L+r)/2;
		if(a[mid]==x){
			printf("YES");
			return 0;
		}
		if(a[mid]<x) L=mid+1;
		if(a[mid]>x) r=mid-1; 
        //调整上限和下限，慢慢逼近答案
        //每次舍弃一半答案
	}
	printf("NO");
	return 0;
}
```
若数组有n个元素，那么暴力的复杂度是O(n)，而二分的复杂度是O(logn)，在数据较大的情况下差异就很明显

所以二分很有用

那么二分答案是什么呢？其实就是用二分查找做应用题，把所有可能的解想象在一个数组里，通过二分去“试”答案，知道找到正确的解

所以有了以下代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	int n;
	cin>>n;
	int L=0,r=n,mid;
  //开始二分
	while(L<=r){
		mid=L+r>>1;
		int x=mid*mid*mid;
		if(x==n){ //找到
			printf("YES");
			return 0;
		}
		if(x>n) r=mid-1;
		if(x<n) L=mid+1; 
     //调整上限和下限
	}
	printf("NO");
	return 0; 
}
```
~~应该能过吧（没试过）~~

~~蒟蒻题解求过~~