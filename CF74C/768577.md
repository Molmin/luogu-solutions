## 题目大意
给你一个 $n\times m$ 大小的棋盘。你可以往上面放一些“象”（就是说这些棋子都是斜着走的），这些象会朝着一个方向走（方向随便），碰到边缘就转 90° ，碰到角就转 180° ，在确保任何两个棋子都不能互相到达的情况下，求最多可以放置多少个象。
### 注意
这里所说的“不能互相到达”指的是在一个棋子不动的情况下，能否到达另一个棋子。

若两棋子的移动路线有重合，但是并不代表它们能互相到达。（即路线不完全重合，只是交叉）
## 解析
### 数据类型
当时我看到这道题之后，第一反应是二维数组。但是 $2\le n,m\le1000000$ ，所以显然二维数组是存不下的。那么，到底用什么存比较合适呢？我们在下面的分析中会讲到。

让我们来看一个稍微复杂一点的例子：
![一个 7 * 10 的棋盘](https://cdn.luogu.com.cn/upload/image_hosting/yyj5e6b5.png)

这是一个 $7\times10$ 的棋盘，我们用了红、蓝、黄、绿四种颜色标记出了图中存在的四条路线。因此，这个图里最多能放置 $4$ 个棋子。

可能各位已经发现了，如果观察这幅图的最后一行（或者第一行）的话，**边上的颜色数量已经足以代表整幅图的颜色数量**。也就是说，我们只需要看一条边就行了。而**那一条边的颜色数量即为答案**。如果再仔细观察的话，我们还会发现，边上颜色的出现是按照回文顺序排列的（红，蓝，黄，绿，黄，蓝，红……），这一点后面会用到。

（关于为什么只要数边上的颜色数量就行，我这里就不证明了，各位可以自己理解一下）

也就是说，我们用一个最多 $1000000$ 位的数组去存其中一行即可。
### 思路
有了刚才的分析，现在这道题目变得容易多了。那么我们该如何知道边上的点都是什么颜色的呢？

~~（由于我是萌新，还比较菜，所以没有想到什么能一步判断出来的方法）~~
我们不妨可以**模拟棋子的移动轨迹**，如果棋子到达了我们指定的那一条边，那么我们就可以知道棋子所在的格子的颜色了。每一个棋子在回到初始位置之后，就停止模拟。在模拟结束之后，将记录颜色的那个变量加一，即可代表换了一种颜色。

大致的思路已经想好了，然后就是开始和结束条件的细节问题了。在开始的时候，我们把所有棋子都**摆放在我们指定的那一条边上**，因为这样会比放在别的地方更方便一些。结束条件就是，因为最后一行（或者第一行）的颜色成回文状，所以**当我们准备放置棋子的那一格已经有棋子了，那么就说明这一行已经都被占满了**，数一下颜色数量，输出即可。
### 算法
在这道题目中，如果我们在模拟棋子运动的时候，用两个变量代表坐标，一格一格地移动的话，很明显在数据比较大的时候会 Time Limit Exceeded 的 ~~（我第一次提交就 TLE 了）~~ 所以我们在模拟的时候，要“一步到边”，通过一次计算就让棋子的坐标移动到一个不得不改变棋子运动方向的地方。我们可以设置两个变量 $dx$ 和 $dy$，代表横（纵）坐标的移动方向。如果变量为 $1$ ，则下一步棋子在横（纵）坐标上就往右（下）方向挪动，反之，即变量为 $-1$ ，向左（上）方向移动。另外，因为我们是斜着走的，所以两个坐标变量 $x$ , $y$ 改变的数字应该是一样的，因此这个数字要取横（纵）坐标上离边缘的距离的最小值。（不然另外一个坐标可能就越界了）
```cpp
int nx,ny;//横（纵）坐标上离边缘的距离
if(dx==1)nx=m-1-x;//如果在往右走
else nx=x;//反之，在往左走
if(dy==1)ny=n-1-y;//如果在往下走
else ny=y;//反之，在往上走
```
移动步数即取 $\min(nx,ny)$ 即可。
## AC代码
如果刚才的分析有点“纸上谈兵”的感觉的话，接下来我们在代码中配合理解。
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,a[1000006],col,ans;
// n 和 m 就不多说了
//数组 a 就是选定的那条边（这里是最后一行）
// col 为 color ，即为标记的颜色
// ans 为答案
int main(){
	scanf("%d%d",&n,&m);
	for(int i=0;a[i]==0&&i<m;i++){
    //循环，直到数组被填满
		col++;//换下一个颜色
		a[i]=col;//放置棋子的初始点标记
		ans++;//答案+1,因为多了一种颜色
		int y=n-2,x=i,dy=-1,dx=1;
        //dy,dx为方向，y,x为坐标
        //因为在最后一行，只能往上走
        //所以y=n-1-1=n-2（为了离开初始位置）
		if(x==m-1)dx=-1;
        //我们假定所有棋子都往右上方走
        //因为之前定义的是 dy=-1,dx=1
        //但是如果刚好在右下角的话
        //就只能往左上方走
		x+=dx;//x也离开初始位置
		while(y!=n-1||x!=i){//如果没回到原点
			if(x==m-1||x==0)dx=-dx;
            //如果到了最左/最右边
            //反弹（左右方向交换）
			if(y==n-1||y==0){
            //如果到了最上/最下边
				dy=-dy；
            //反弹（上下方向交换）
				if(y==n-1)a[x]=col;
            //如果在最下面一行，做标记
			}
			int nx,ny;
            //横（纵）坐标上离边缘的距离
			if(dx==1)nx=m-1-x;
            //如果在往右走
			else nx=x;
            //反之，在往左走
			if(dy==1)ny=n-1-y;
            //如果在往下走
			else ny=y;
            //反之，在往上走
			x+=dx*min(nx,ny);
            //为什么是最小值见“算法”板块
            //x坐标移动
			y+=dy*min(nx,ny);
            //y坐标移动
		}
	}
	printf("%d",ans);
    //输出答案
	return 0;
}
```
代码仅供参考