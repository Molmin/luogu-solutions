## Content
现在是 $h$ 时 $m$ 分，请求出在此之后（不包含此时）的第一个回文时间。

**数据范围：$0\leqslant h\leqslant 23,0\leqslant m\leqslant 59$。**
## Solution
众所周知，回文时间每个小时段最多只有一个，我们来枚举一下：$00:00,01:10,02:20,03:30,04:40,05:50,10:01,11:11,12:21,13:31,14:41,15:51,20:02,21:12,22:22,23:32$。就只有以上这 $16$ 个时间是回文时间，因此，我们一步一步往后推时间，并判断是不是上面的这 $16$ 个时间就好了。

注意，这里输出时间只有 $1$ 位的要补足输出，所以我们可以用 $\texttt{printf}$ 的奇技淫巧—— $\texttt{\%0xd}$ 输出（其中 $x$ 代表的是输出的位数，不足这个位数的话自动向前面用 $0$ 补足，例如下面的 $\texttt{\%02d}$ 就是按照两位输出，不足两位的话自动向前面用 $0$ 补足）。
## Code
```cpp
#include <cstdio>
using namespace std;

int main() {
	int h, m;
	scanf("%d:%d", &h, &m);
	while(1) {
		m++;
		if(m > 59)	h++, m = 0;
		if(h > 23)	h = 0;
		if((h == 0 && m == 0) || (h == 1 && m == 10) || (h == 2 && m == 20) || (h == 3 && m == 30) || (h == 4 && m == 40) || (h == 5 && m == 50) || (h == 10 && m == 1) || (h == 11 && m == 11) || (h == 12 && m == 21) || (h == 13 && m == 31) || (h == 14 && m == 41) || (h == 15 && m == 51) || (h == 20 && m == 2) || (h == 21 && m == 12) || (h == 22 && m == 22) || (h == 23 && m == 32))	{
			printf("%02d:%02d", h, m);
			break;
		}
	}
	return 0;
}
```