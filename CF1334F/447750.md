提供一个 [CF 评论区指出的线性做法](https://codeforces.ml/blog/entry/75877?#comment-601296)。

考虑在 $a,b$ 的前后都添加上 $0$ 与 $n+1$，下标从 $0$ 开始。考虑把 $b_j=a_i$ 的 $a_i$ 设为 $2j$，把 $b_j<a_i<b_{j+1}$ 的 $a_i$ 设为 $2j+1$，限制就变为了保留一个由 $0$ 到 $2m$ 支撑的上升子序列，在第一个 $2i$ 之前不能出现 $2i-1$，这和原限制是等价的，因为就算在 $2i$ 之前出现了超过 $2i$ 的数，也会在之后的限制中被敲掉。

这个重新赋值的过程由于 $b$ 是有序的，可以线性完成。

当 $a_i=2j$ 时，设 $f_i$ 是在前缀 $[0,i]$ 中，仅保证值不超过 $2j$ 的数合法的最小花费，也就是 $i$ 前面允许存在没被删掉的超过 $2j$ 的数。

可以这样转移强制其作为保留的第一个 $2j$：

$$
f_i=\{f_x+\sum_{k=x+1}^{i-1}[p_k<0]p_k\}+\sum_{k=0}^{i-1}[a_k=2j\lor a_k=2j-1][p_k>0]p_k
$$

其中 $x$ 是 $i$ 前面最近的一个 $a_x=2(j-1)$ 的位置，原本是应该枚举 $x$ 取 $\min$ 的，但如果像下面一样转移了 $a_i$ 不作为第一个出现的 $2j$ 情况后，选择最近的一个 $x$ 转移就显然等价了：
$$
f_i=\{f_x+\sum_{k=x+1}^{i} [p_k<0]p_k\}
$$
同理，这里也只需要找最近的一个 $x$ 满足 $a_x=2j$ 就好了，因为最近的一个覆盖了前面的所有转移可能，对负数预处理出前缀和就可以简单实现了。另外，这里 $k$ 上界是 $i$ 的原因为，如果 $p_i<0$，且挖掉 $i$ 更优则可以挖掉，而上面的转移中强制保留作为第一个 $2j$ 则不能挖掉 $i$。

总复杂度 $O(n)$，[提交记录](https://codeforces.com/contest/1334/submission/160690507)。

