提供一种线性做法。

[题目链接](https://www.luogu.com.cn/problem/P9166)

#### 思路

下文称一座车站可达，当且仅当存在火车行驶方案可以在经过车站 $X$ 后经过这座车站。

任何火车经过车站 $X$ 前的行程都无关答案，不妨令所有火车都从 $X$ 出发。

对于所有跨过起点车站 $X$ 的轨道，其整条轨道上的所有车站都是可达的，且其轨道的两端点都是合法的终点站，可以直接将其端点加入答案。

因为火车不能转向，因此对于所有不经过车站 $X$ 的轨道，只有其远离 $X$ 一端的终点车站才有可能从 $X$ 出发通过改变轨道到达作为合法的终点站。

对于一条不经过车站 $X$ 的轨道，我们考虑其是否可以被可经过 $X$ 的火车到达：当且仅当这条轨道靠近车站 $X$ 一端的车站可达，整条轨道上的所有车站都可达。

简单证明：所有可达车站为车站序列的一个包含车站 $X$ 的连续子区间，而整条轨道靠近 $X$ 一端的车站是该轨道上距离 $X$ 最近的车站，如果 $X$ 不可达，则这条轨道上一定不存在任何可达的车站。

若一条轨道的近 $X$ 端车站可达，则整条铁路覆盖的车站都可达。

则对于不覆盖车站 $X$ 的轨道，我们只需要维护其近 $X$ 端车站是否可达，如果可达则这条轨道的所有车站也都是可达的。

#### 实现

所有可达的车站是一个连续区间，所以只需要维护当前可达区间的左右端点即可。

右端点在 $X$ 左侧的轨道不会对 $X$ 右侧的答案产生影响，左端点在 $X$ 右侧的轨道也不会对 $X$ 左侧的答案产生影响。因此对于以上两种情况分开考虑。

初始时记录了所有直接覆盖 $X$ 的轨道，此时可达区间的左/右端点分别是这些轨道左端点的最小值和右端点的最大值。

对于 $X$ 左侧的轨道，将其按照右端点从大到小排序，然后从 $X$ 开始右向左依次遍历所有车站：如果当前车站可达，则将当前车站为右端点的轨道全部可达，将这些轨道的左端点加入答案，并将可达区间的左端点与这些区间的左端点取最小值；如果当前车站不可达，则所有右端点在当前点及当前点左侧的轨道上都不存在可达车站，那么就不需要继续做下去了。

右侧与左侧同理。

由于火车站编号的值域是 $1\sim n$，所以可以对每个车站开一个 ``vector`` 或链表记录以这座车站作为靠近 $X$ 的一端的轨道编号，这样就省去了排序的时间消耗。

记录每个点是否可以作为合法的终点站，最后输出即可。

#### 代码
```cpp
#include <cstdio>
#include <vector>
const int Nx=200010;
int N,M,X,L[Nx],R[Nx],vis[Nx];
std::vector<int> id[Nx];
int main()
{
	scanf("%d%d%d",&N,&M,&X);
	int i,ll=X,rr=X;
	for(i=1;i<=M;i++)
	{
		scanf("%d%d",&L[i],&R[i]);
		if(L[i]<=X&&R[i]>=X)
		{
			vis[L[i]]=vis[R[i]]=1;
			ll=std::min(ll,L[i]),rr=std::max(rr,R[i]);
		}
		if(R[i]<X) id[R[i]].push_back(i);
		if(L[i]>X) id[L[i]].push_back(i);
	}
	for(i=X-1;i>=1;i--)
	{
		if(ll>i) break;
		for(auto ax : id[i])
			ll=std::min(ll,L[ax]),vis[L[ax]]=1;
	}
	for(i=X+1;i<=N;i++)
	{
		if(rr<i) break;
		for(auto ax : id[i])
			rr=std::max(rr,R[ax]),vis[R[ax]]=1;
	}
	for(i=1;i<=N;i++)
		printf((vis[i]&&i!=X)?"%d ":"",i);
}
```
