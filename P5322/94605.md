## 分组背包

这道题就是一道分组背包的简单变形


------------
#### 首先什么是分组背包？

分组背包就是有n组物品，每组物品中只可以选择一个物品。

每个物品都有体积和价值，求总体积不超过m的情况下的价值最大值。

很显然状态转移方程就是：$f[j] = max(f[j-v[i][k]]+w[i][k])$

分组背包核心代码：
```cpp
	for(int i=1;i<=n;i++)
	{
		for(int j=m;j>=0;j--)
		{
			for(int k = 1;k<=s[i];k++)
			{
				if(j>=v[i][k])
					f[j] = max(f[j],f[j-v[i][k]]+w[i][k]);
			}
		}
	}

```


------------
#### 这道题怎么转化成分组背包呢？

我们可以把每个城堡看做一组物品。每个人的兵看成体积，把城堡编号看成价值。

但是难点分组背包是每一个组只能选一个，这里是可以打多个对手。

其实可以发现，假设第i个对手派出的兵<第i+1个对手派出的兵，那么如果我们派出的兵可以打赢i+1个对手派出的兵，那么也肯定能打赢第i个对手。

所以，我们可以把每个城堡分别的对手派出的兵数进行排序。状态转移的时候，把分组背包的枚举哪一个物品改成从小到打枚举哪几个物品，这样就可以转化为分组背包。



------------
这题还是有一点细节的。排序的时候由于输入的城堡兵书是从上到下竖着的。我们很难直接排序。所以可以把输入的数组翻转 90° 然后用stl:sort横着排序就行了

代码：
```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
using namespace std;
const int N = 110,M=20010;
int f[M];
int a[N][N];
int main()
{
	int s,n,m;
	scanf("%d%d%d",&s,&n,&m);
	for(int j=1;j<=s;j++) //输入翻转数组
		for(int i=1;i<=n;i++)
			scanf("%d",&a[i][j]);

	for(int i=1;i<=n;i++) //排序
	{
		sort(a[i]+1,a[i]+1+s);
	}
	for(int i=1;i<=n;i++) //分组背包实现
	{
		for(int j=m;j>=0;j--)
		{
			for(int k=1;k<=s;k++)
			{
				if(j>=2*a[i][k]+1)
					f[j] = max(f[j],f[j-2*a[i][k]-1]  + k*i);
			}
		}
	}
	cout<<f[m]<<endl;
	return 0;
}
```