我终于也能做帝都省选的题了！（大雾）

这个题出的真的是非常不错呢，有很多小细节还是要注意的。

## 简明题意

每个人有$m$个士兵，可以把它们随意分配到$i$个城堡里，游戏采用逐个1V1 battle的模式，如果在一次battle中第$i$城堡里你的士兵个数$>$对方士兵个数$*2$，你就获得了$i$分。每次battle的策略必须一致，已知其余玩家的派兵情况，求总得分最大值。

## 解法

乍一看貌似没有思路的亚子，于是我们来模拟一下样例。

首先根据读题明确这样两个事实：  

- 对于玩家$a$而言，攻占第$i$个城堡，需要**至少**派出$2*a_i+1$的兵力

输入#1:  
![1](https://i.loli.net/2019/08/23/HJO3mVY4owWtPI6.png)  
在这种情况下绝对要给城堡1、2各分5个兵力，得3分。  
是不是有点眉目了？我们来看下一个。

输入#2：  
![2](https://i.loli.net/2019/08/22/YB7wfCaQuAncroT.png)  
你可以看到，对于玩家1的所得分数有点不一样，因为在攻占下玩家1后，按照相同的策略，玩家2也自然会被攻占，所以这个地方的所得分数就变成了两倍。  
我们就可以得到一个（显而易见的）事实：

- 如果攻占下一个玩家的城堡，那么出兵更弱的玩家自然也会被攻占

这个事实就非常天后了，他可以让我们忽视所打的轮数，对于每个城堡，我们只要找出攻占的一个玩家，即可得知该城堡的全部所获分数。

根据这个性质，我们可以先对每个城堡的玩家兵力排序，于是就可以简化成：有$i$个城堡，每个城堡有$s$个玩家，攻占一个玩家需要派出$2*i_s+1$的兵力，获得$i*s$的分数。求在有$m$个兵力的情况下，对于**每个城堡**要攻占**哪一个**玩家使得总分最大。

看到这个，有没有想到什么东西？分组背包啊！我们可以把每一个城堡看成一个组，每个玩家是一个组内的物品。物品的价值即为所获分数$i*s$，体积为攻打所需兵力$2*i_s+1$，而背包体积就是兵力$m$。

我们就可以轻松愉悦的写代码了。

```cpp
#include <bits/stdc++.h>
using namespace std;
int s,n,m;
int C[110][110],W[110][110];
int F[20010];

//分组背包板子,V为容量，K为组数，GMC为每组元素个数
void group_package(int V,int K,int GMC)
{
    for(int k=1;k<=K;k++)
        for(int v=V;v>0;v--)
            for(int i=1;i<=GMC;i++//循环三连
                if(v-C[k][i]>=0&&F[v-C[k][i]]+k*i>F[v])
                    F[v]=F[v-C[k][i]]+k*i;
}
int main()
{
    //读入
    cin>>s>>n>>m;
    for(int i=1;i<=s;i++)
        for(int j=1;j<=n;j++)
            cin>>C[j][i];
    //数据预处理
    for(int i=1;i<=n;++i)
    {
        sort(C[i]+1,C[i]+1+s);//先排序
        for(int j=1;j<=s;j++)//排序完把玩家兵力改为攻打兵力
            C[i][j]=C[i][j]*2+1;   
    }
    group_package(m,n,s);
    cout<<F[m]<<endl;
    return 0;
}
```