## 题意简述
给定长度为 $n$ 的数组 $a_i$，问能否将其分为 $k$ 段，使每段的和相等。如果可以，输出每一段长度。

## Solution
这种题测完样例应该一遍就能过的。

首先，如果所有数的和不是 $k$ 的倍数，一定无解（很简单，每一段的和是 $\frac{n}{k}$（记为 $m$），不是 $k$ 的倍数必然导致有一组和太大）。

如果总和是 $k$ 的倍数，也不一定有解。例如下面这组样例就是无解的。

```
输入：
5 3
3 6 2 3 1

输出：No
```

所以，我们在探究如何分的时候，也要检查是否不合法。具体地，如果有一个位置 $i$，以 $i$ 结尾的这一段和小于 $m$，但是以 $i+1$ 位为结尾就大于 $m$，证明这一段不可能分出和为 $m$ 的段。这样的数列同样是不能分的。

刚刚的判断可以使用前缀和优化，时间复杂度是 $O(n)$ 的。

最后输出所有长度即可。

## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;

const int N = 1e5 + 10;
int n, k, l, now, s[N], p[N];
//now表示上一段结尾 

int main(){
	scanf("%d%d", &n, &k);
	for(int i=1;i<=n;i++)	scanf("%d", &s[i]), s[i] += s[i - 1];
	if(s[n] % k)	return printf("No\n"), 0;//压行语法，可以加很多个逗号，返回值是最后面那个 
	int m = s[n] / k;//除法是很慢的，用变量存下来可以节省几毫秒（ 
	for(int i=1;i<=n;i++){
		if(s[i] - s[now] == m)	p[++l] = i - now, now = i;//先用数组存下来，避免输出到一半发现无解 
		else if(s[i] - s[now] > m)	return printf("No\n"), 0;//不一定能整除就有解 
	}
	printf("Yes\n");
	for(int i=1;i<=l;i++)	printf("%d ", p[i]);
	return 0;
}
```
