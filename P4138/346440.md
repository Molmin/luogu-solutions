## 简化题意

通过仔细观察题目，我们可以对题意进行**简化和归纳**：

给定 $n$ 个物品，第 $i$ 个物品体积 $v_i=1-a_i$，价值 $w_i=b_i$，求总体积**不大于** $1$ 的物品的**最大价值**。

$1\le n\le 2\times 10^3,a_i\in [0,n],b_i\in[-10^6,10^6]$

## 思路

我们发现经过化简，这道题就是一道体积、价值**可以为负**的 $01$ 背包 DP。

直接套用经典 $01$ 背包的模板是行不通的，因为总体积可能**为负**，会导致数组越界。我们应该将体积的存储地址整体右移，令**总体积为最小值**时的最大价值存入 $c_0$，这样就可以防止数组越界。

但是，假如我们这样做，体积数组的大小为  $O(n^2)$，时间复杂度就会达到恐怖的 $O(n^3)$。通过观察可以发现，总体积最大只会到达 $2\times 10^3$，这意味着只要当前体积 $v\le -2\times 10^3$，总体积**一定小于** $1$ ，再单独计算此时价值的最大值就无意义了，都归入体积为 $-2\times 10^3$(**有意义**的体积最小值)时的状态即可。

那么我们就找到了解法：令 $v=-2\times 10^3$ 时最大价值存入 $c_0$，$v=0$ 时的最大价值存入 $c_{2\times 10^3}$，$v=2\times 10^3$ （体积最大值）时的最大价值存入 $c_{4\times 10^3}$。如果实际体积小于 $-2\times 10^3$，其最大价值一并存入 $c_0$。

因为价值**可能为负**，开始前，我们先令所有状态为 $-\infty$（也表示这种状态不能到达），令 $c_{2\times 10^3}$ （即 $v=0$，不挂东西时）为 $0$。 

在求解 $01$ 背包的时候进行判断：如果 $v_i=1$，就按典型 $01$ 背包求解；如果 $v_i\le0$，就从上一层状态（前 $i-1$ 个物品能达到的最大总价值）向当前层状态（前 $i$ 个物品能达到的最大总价值）转移，如果 $v<-2\times 10^3$ 就将状态存入 $c_0$。**需要注意的是**，在转移状态的时候，如果该状态的上一层状态为 $-\infty$，说明上一层状态**并不存在**，此时就不能进行转移。

这里我们采用**滚动数组**优化空间，因此 $v_i=1$ 时**倒序**转移状态，$v_i\le 0$ 时**正序**转移状态。

最终答案为 $\max_{i=0}^{2\times10^3+1}c_i$ （体积不大于 $1$ 时的最大总价值）。

### AC code

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#define ll long long
using namespace std;
const int N=2e3+5,INF=0x3f3f3f3f;
int n,m=4005,v[N],w[N],c[4010],ans;//为了防止溢出，令m略微大一点 
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>v[i]>>w[i];
		v[i]=1-v[i];
	}
	//初始化 
	for(int j=0;j<=m;j++)c[j]=-INF;
	c[2000]=0;
	//01背包DP 
	for(int i=1;i<=n;i++){
		if(v[i]==1){//v[i]=1 <=> v[i]>0 
			for(int j=m;j;j--)
				if(c[j-1]!=-INF)
					c[j]=max(c[j],c[j-1]+w[i]);
		}
		else{
			for(int j=0;j<=m;j++)
				if(c[j]!=-INF){
					int x=max(0,j+v[i]);
					//v[i]<=0，因此x<=j一定成立，应该正序更新 
					c[x]=max(c[x],c[j]+w[i]);
				}
		}
	}
	for(int i=0;i<=2001;i++)
		if(c[i]!=-INF)
			ans=max(c[i],ans);
	cout<<ans<<endl; 
	return 0;
} 
```

### The End.

