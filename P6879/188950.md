前言：这样的环形区间 $\texttt{dp}$ 题不建议使用记忆化搜索，用循环计算反而更好调试。至少，本人初见本题时尝试了记忆化搜索，结果是失败了。

***

首先设计状态。不难想到可以用一个四元组表示：$(l,r,t,\text{pos})$。$l$ 和 $r$ 分别表示从当前位置开始向左向右各**达到**了多少个雕像的位置（注意，不是取走雕像），$t$ 表示当前已经花费的时间，$\text{pos}$ 表示当前所在的雕像位置。

不着急列转移方程，先对这个状态进行优化。$l,r,\text{pos}$ 都是 $n$ 级别的，$t$ 是 $T$ 级别的，总时间复杂度为 $O(n^3T)$，能拿到 $25$ 分。

考虑优化，很容易就能发现，状态中的 $\text{pos}$ 一维的取值范围其实不需要开到 $n$ 级别。因为当取走一个雕像（即发生状态转移）之后，位置肯定是在 $l$ 或者在 $r$。也就是说，使用 $0/1$ 就能区分开是在 $l$ 或者在 $r$ 了。于是，时间复杂度降低到 $O(2\times n^2T)$。

然而，$T \leq 10^9$，如果不把 $T$ 优化掉是很难通过本题的。可以发现，本题对时间**没有任何直接限制**，唯一的限制就是雕像的自毁时间。换句话说，受限的反而是**能取走的雕像数量**。调整一下状态的设计，用一个四元组 $(l,r,i,\text{pos})$ 来表示**在 $[l, r]$ 中取 $i$ 个雕像**所需的**最短**时间，就可以将效率瓶颈 $T$ 去除。

具体来说，我们反其道而行之。目标是最大雕像数量，我们却让状态来表示最少用时，在计算出所有的状态之后，再次遍历所有状态，取所有**有解**状态中 $i$ 的最大值即可。

以上是本题的第一个难点。第二个难点就是推导方程。设当前状态为 $(l,r,i,\text{pos})$，状态的**值**记为 $f(l,r,i,\text{pos})$：

- 当 $\text{pos}=0$ 时，可以转移到 $(l-1,r,i+\Delta,0)$，代价为 $x_{l}-x_{l-1}$、或转移到 $(l,r+1,i+\Delta,1)$，代价为 $x_{r+1}-x_{l}$；
- 当 $\text{pos}=1$ 时，可以转移到 $(l-1,r,i+\Delta,0)$，代价为 $x_{r}-x_{l-1}$、或转移到 $(l,r+1,i+\Delta,1)$，代价为 $x_{r+1}-x_{r}$；

引入了一个新的变量 $\Delta$，表示**取得雕像的变化量**，取值范围为 $0$ 或 $1$。当能取得一个新的雕像的时候，$\Delta=1$，此时：

- 当 $\text{pos}=0$ 时：

如果转移到 $(l-1,r,i+\Delta,0)$，则用时为 $t_0=f(l,r,i,0)+x_{l}-x_{l-1}$，当且仅当 $t_0 \leq t_{l-1}$ 时 $\Delta=1$；


如果转移到 $(l,r+1,i+\Delta,0)$，则用时为 $t_0=f(l,r,i,0)+x_{r+1}-x_{l}$，当且仅当 $t_0 \leq t_{r+1}$ 时 $\Delta=1$；

- 当 $\text{pos}=1$ 时：

如果转移到 $(l-1,r,i+\Delta,0)$，则用时为 $t_0=f(l,r,i,0)+x_{r}-x_{l-1}$，当且仅当 $t_0 \leq t_{l-1}$ 时 $\Delta=1$；


如果转移到 $(l,r+1,i+\Delta,0)$，则用时为 $t_0=f(l,r,i,0)+x_{r+1}-x_{r}$，当且仅当 $t_0 \leq t_{r+1}$ 时 $\Delta=1$；

转移需要取最小值，这是显然的：取得 $i$ 个雕像的用时越少，留给后面取更多雕像的用时便越多，具有决策包容性。所以 $f$ 的初始化应当是初始化到无穷大。

***

由于这是一个环形的 $\texttt{dp}$，需要破环为链。这里不需要倍长，只需要在 $n+1$ 处设置位置为 $L$ 即可（即转了一圈回到原处）。

最后，遍历所有状态空间，对于 $(l,r,i,\text{pos})$，如果 $f(l,r,i,\text{pos})$ 等于无穷大，说明该状态是不可达的；否则，说明该状态肯定可达，在可达状态中取 $i$ 的最大值即可。

***

时间复杂度变为 $O(n^3)$，通过本题是绰绰有余的了。关键代码如下：


```
signed main() {
    memset(f, 0x3f, sizeof(f)); // 初始化
    int n, length; scanf("%lld%lld", &n, &length);
    for(int i = 1; i <= n; i++) scanf("%lld", &x[i]);
    for(int i = 1; i <= n; i++) scanf("%lld", &t[i]);
    x[n + 1] = length; // 转一圈回到原处
    f[0][0][0][0] = f[0][0][0][1] = 0;

    for(int len = 0; len < n; len++) {
        for(int L = 0; L <= len; L++) {
			int R = len - L;
			for(int i = 0; i <= n; i++) { // 四种状态转移
				f[L + 1][R][i + ((f[L][R][i][0] + x[n - L + 1] - x[n - L]) <= t[n - L])][0] = min(f[L + 1][R][i + ((f[L][R][i][0] + x[n - L + 1] - x[n - L]) <= t[n - L])][0], f[L][R][i][0] + x[n - L + 1] - x[n - L]);
				f[L][R + 1][i + ((f[L][R][i][0] + length - (x[n - L + 1] - x[R + 1])) <= t[R + 1])][1] = min(f[L][R + 1][i + ((f[L][R][i][0] + length - (x[n - L + 1] - x[R + 1])) <= t[R + 1])][1], f[L][R][i][0] + length - (x[n - L + 1] - x[R + 1]));
				f[L + 1][R][i + ((f[L][R][i][1] + length - (x[n - L] - x[R])) <= t[n - L])][0] = min(f[L + 1][R][i + ((f[L][R][i][1] + length - (x[n - L] - x[R])) <= t[n - L])][0], (f[L][R][i][1] + length - (x[n - L] - x[R])));
				f[L][R + 1][i + ((f[L][R][i][1] + x[R + 1] - x[R]) <= t[R + 1])][1] = min(f[L][R + 1][i + ((f[L][R][i][1] + x[R + 1] - x[R]) <= t[R + 1])][1], f[L][R][i][1] + x[R + 1] - x[R]);
			}
		}
    }
    int ans = 0;
	for(int i = 0; i <= n; i++) {
		for(int j = 0; j <= n; j++) {
			for(int k = 0; k <= n; k++) {
				if(f[i][j][k][0] != inf || f[i][j][k][1] != inf) { // 可达
					ans = max(ans, k);
				}
		    }
		}
	}
    printf("%lld", ans);
    return 0;
}
```

本题提供了一个新的 $\texttt{dp}$ 状态设计思路：当某一维的状态空间过大不便表示时，可以试着将状态的值和状态本身调换，最后再次遍历状态空间，根据可达性取得最优解。

***

后记：在教练的指导下，本人才通过了本题。几乎没有万能的方法，各种方法都需要掌握，各种经验都需要积累，这也许就是刷题的目的所在。