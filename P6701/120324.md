看到题目之后最自然的思路就是考虑区间 $[l, r]$ 能不能被合并成某个字母 $C$.

记每个 Genotype 为 $T$，$f_{l,r,C}$ 为区间 $[l, r]$ 能否被合并成单个字母 $C$. 显然，初始值为 $f_{i,i,T_i}=1$，即单个字母本身。之后按照区间 dp 的传统思路，先枚举区间长度，再枚举分割点 $k$，最后枚举 $n$ 个分裂规则，尝试用每个规则合并左区间和右区间。

核心代码：
```cpp
for (int i = 1; i <= n; ++i) f[i][i][s[i]] = 1;
for (int len = 2; len <= n; ++len)
    for (int i = 1, j = i + len - 1; j <= n; ++i, ++j) 
        for (int k = i; k < j; ++k)
            for (int x = 1; x <= m; ++x)
                f[i][j][a[x][1]] |= f[i][k][a[x][2]] && f[k + 1][j][a[x][3]];
                // 如果 S[i,k] 能被合成 a[x][2], S[k + 1, j] 能被合成 a[x][3], 那么根据规则 x, S[i,j] 能被合成 a[x][1].
```

得到每个区间能否被合成某个字母的所有情况之后，我们可以求出 $g_i$ 表示 $T[1,i]$ 被合成**只包含大写字母 $S$ 的串**的最小长度。可以枚举所有右端点为 $i$ 的区间，$g_i = min\{g_{j}+1\}(0\leq j \lt i, f_{i,j,'S'}=1)$。

核心代码：
```cpp
f[0][0][S] = 1;
g[0] = 0;
for (int i = 1; i <= n; ++i)
    for (int j = 0; j < i; ++j)
        if (f[j + 1][i][S]) // 区间[j+1, i]能被合成 'S'
            g[i] = min(g[i], g[j] + 1);
```

完整代码见[云剪贴板](https://www.luogu.com.cn/paste/anpbfeog)。