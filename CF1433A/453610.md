

## 题目大意：
#### 给出一个（或几个）数，输出1到这个数这几个数中数的位数之和。

那么我们可以设这个数的长度为c，可以通过判断它的长度来找规律。

再根据这个数（因为这个数是由几个完全一样的数组成），继续找规律。

怎么求组成这个数的几个一样的数呢？

我想了一个很笨的方法，就是不断取模，由于题目给了，

1⩽t⩽36,1⩽x⩽9999

所以只需要根据这个数的位数，来判断这个数到底需要取几次模即可。

然后，通过~~打表~~我们可以发现规律：

因为每增大一个区间（即由1组成—>2组成的同位数），都会增加10，

所以不难发现规律：

当c=1时，答案为（x-1）*10+1；

当c=2时，答案为（x%10-1）*10+3；

剩下的以此类推。

思路很明白了吧，注意通过字符串输入，然后把字符串转数字。

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int t;
char x[1005];
int cnt;
int main(){
	cin>>t;
	while(t--){
		cin>>x;
		int c=strlen(x);
		int ans=x[0]-48;
		if(c==1){
			cnt=(ans-1)*10+1;
			cout<<cnt<<endl;
		}
		else if(c==2){
			cnt=((ans%10-1)*10+3);
			cout<<cnt<<endl;
		}
		else if(c==3){
			int s=ans%100;
			cnt=((s%10-1)*10+6);
			cout<<cnt<<endl;
		}
		else if(c==4){
			int f=ans%1000;
			int p=f%100;
			cnt=((p%10-1)*10+10);
			cout<<cnt<<endl;
		}
	}
	return 0;
}
```
