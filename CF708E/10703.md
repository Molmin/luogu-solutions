代码写的很乱，讲个大概思路：

可以发现上下连通当且仅当相邻层剩下来的区间有交，那么我们考虑自上而下 DP，状态就为当前剩下的区间：  
令 $dp(i, l, r)$ 表示考虑前 $i$ 层，第 $i$ 层的区间为 $[l, r]$ 时的概率，转移时枚举上一层的区间即可。

这个做法状态数就是 $\mathcal O (n m^2)$ 的了，不能接受。

考虑区间 $[l, r]$，和它有交的区间 $[l', r']$ 需要满足 $r' \ge l$ 且 $l' \le r$，当然还有 $l' \le r'$。  
条件比较复杂，容斥一下可以发现也等价于所有区间减去 $r' < l$ 的区间减去 $l' > r$ 的区间（前提是满足 $l' \le r'$）。

那么现在转移就方便了，等于上一层的 DP 值的总和减去上述两个限制条件。

考虑令 $f(x)$ 表示所有满足 $l > x$ 的区间的 DP 值之和，令 $g(x)$ 表示所有满足 $r < x$ 的区间的 DP 值之和。  
（由对称性容易发现 $g(x) = f(m + 1 - x)$）

这时状态数仍然是 $\mathcal O (n m^2)$ 的，考虑直接利用上一层的 $f$（或 $g$）求出这一层的 $f$（或 $g$）。

推一波式子就发现，确实是可以求的，然后按照式子进行计算就行了。  
这部分因为我摸了，所以请详见 @[热言热语](https://www.luogu.com.cn/user/37132) 的[题解](https://www.luogu.com.cn/blog/hotwords/solution-cf708e)。

计算时需要预处理形如 $\displaystyle \binom{k}{i}$ 的组合数。

时间复杂度为 $\mathcal O (nm + k)$，[评测链接](https://codeforces.com/contest/708/submission/66041767)。