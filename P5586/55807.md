这题是双倍经验[P5350](https://www.luogu.com.cn/problem/P5350)、[P5586](https://www.luogu.com.cn/problem/P5586)

~~希望题解也能是双倍经验~~

fhq的做法神鱼写了，这里写一下它的魔改版——可持久化ODT！

具体操作就是用fhq模拟ODT，然后可持久化。这样区间赋值时就能无脑压节点进行提速和减小内存，还不用打推平标记和下传，即使在加强版赋值较少的情况下也有加速效果。

这样，只需要在原来做法中的pushdown、pushup和split操作中进行改动就行了～

pushup：siz、sum算时用节点长度来算

pushdown：删掉区间赋值的标记和对应的下传操作

split：和之前一样，按子树大小分裂，如果分裂点在当前节点区间内就把节点一分为二并重新计算各项值

这里放一下代码
```cpp

        if (!now)
        {
            x = y = 0;
            return;
        }
        pushdown(now);
        if (k >= tr[tr[now].ls].siz + tr[now].len)
            //………………
        else if (k <= tr[tr[now].ls].siz)
            //………………
        else
            //………………分裂节点，记得可持久化
        return;
```

这样，再加上定期线性重构，在P5350中fhq就可以跑过ODT了（目前最优解），
在P5586中也可以-1s（赋值操作太少，还是跑不过用leefty tree的大佬）。

其实这题不够爽，可持久化平衡树就应该开1Gb才叫不卡空间（见P5055 【模板】可持久化文艺平衡树），然后不要线性重构，最后不输出序列，通过区间复制达到
1e18，才叫爽（按这个操作次数来算应该可以轻松通过时限，此题很大一部分时间化在线性重构上了）。

最后吐槽一下 **_ Wallace _** 常数好大。


**Code：**

```cpp
//相信各位都能轻松写出，我就不放了
```


这题调了好久，我还是太菜了。
