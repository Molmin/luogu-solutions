## 题解

观察数据范围发现 $0\le x<2^{32},-2^{31}\le y< 2^{31}$ 。显然，前者是 $\verb!unsigned int!$ 所能接受的数据范围之内；而后者是 $\verb!int!$ 的数据范围。

于是我们就正常读入，然后比较就行啦！

然而事实并不是这样的。有符号整型与无符号整型的比较属于**未定义行为**，因此无论编译器编译出来的结果会返回什么都是有可能的。

最简单的做法，当然就是把他们都直接当作 $\verb!long long!$ 类型读入并比较就好了。由于 $\verb!long long!$ 的范围是 $[-2^{63},2^{63})$ ，因此大可不必出现溢出之类的情况。

---

我们可以用三目运算符 $\verb!表达式?表达式1:表达式2!$ 来根据表达式的值，若为真则返回表达式 $1$，否则返回表达式 $2$ 。因此我们先判断两个数相等，若相等则返回 $1$ ；否则返回两数的大小关系（ $x$ 是否大于 $y$ ），这是一个布尔型，转成 $\verb!int!$ 就是 $0$ 和 $1$ ，乘 $2$ 后就变成了 $0$ 和 $2$ 。于是我们把小于、等于、大于分别映射到了 $0,1,2$ 。

然后我们开一个字符数组 $S=\verb!<=>!$ ，就能把 $0,1,2$ 分别映射到对应的字符上去了。用形如 `"<=>"[x]` 的格式可以将数字映射到字符数组的对应位。

## 参考代码

```cpp
#include<bits/stdc++.h>
#define up(l,r,i) for(int i=l,END##i=r;i<=END##i;++i)
#define dn(r,l,i) for(int i=r,END##i=l;i>=END##i;--i)
using namespace std;
typedef long long i64;
i64 a,b;
int main(){
    scanf("%lld%lld",&a,&b);
    putchar("<=>"[a==b?1:(a>b)*2]);
    return 0;
}
```