# AT_joi2022_yo2_b 题解

## 前言

在读这篇题解之前，建议先学习广度优先搜索，因为这一题与广度优先搜索息息相关。

## 正篇开始

### 思路

看完题过后，我们可以用广度优先搜索做这道题。如果没有学广度优先搜索，请自己百度或者看模板题题解，不在这里讲解。

这题相当于模板题，只不过变形了一点点东西。

第一个变形，普通的迷宫题都是只能走一种颜色的，在这题必须两种颜色穿插着走。这个问题很简单，将是否是同色的判断条件改成是否是不同色的判断条件就行了。

第二个变形，上面建议题目仅仅是输出是否能够到达就行了，可这题要输出最短路径的步数，所以我们要处理一下步数问题。

我对于输出步数问题处理有两种方法。

1. 将标记数组改成存步数的数组，开始赋值成负数，因为如果这一个点可以到达，就一定不是负数。如果访问这一个点的时候发现标记数组上这一个点不是负数，说明这一个点走过了。
2. 此方法比较麻烦，开一个字典存这一个点可以到达哪一个点，到最后倒退回去，倒推的时候记步数。

上面的方法我个人觉得方法一简单一些，所以在下面的代码中我选择的是方法一来做的。

只有走法和步数这两个小问题，其他的就是模板了。

### 代码

下面是我的代码，可能代码风格有些难看，请见谅。

```cpp
#include <iostream>//头文件。 
#include <vector>//头文件。 
#include <queue>//头文件。 
using namespace std;
const int dx[]={-1,0,1,0};//打表方向。 
const int dy[]={0,1,0,-1};//打表方向。 
int main(){
	int n,m;//定义迷宫的高和底。 
	cin >> n >> m;//输入。 
	vector<vector<char>> maze(n,vector<char>(m));//迷宫。 
	for (int i=0;i<n;++i){//输入迷宫。 
		for (int j=0;j<m;++j){
			cin >> maze[i][j];//输入迷宫。 
		}
	}
	queue<pair<int,int>> q;//队列。 
	q.emplace(0,0);//把起点入队。 
	vector<vector<int>> a(n,vector<int>(m,-1));//存步数。
	a[0][0]=0;//初始标记。 
	while (!q.empty()){//开始正式广度优先搜索。 
		pair<int,int> p=q.front();//取出上一步的坐标。 
		q.pop();//出队。 
		if (p.first==n-1 && p.second==m-1){//如果到终点了。 
			cout<<a[p.first][p.second]<<endl;//输出步数。 
			return 0;//直接退出程序。 
		}
		for (int i=0;i<4;++i){//遍历四个方向。 
			int tx,ty;//定义下一步走到哪里。
			tx=p.first+dx[i],ty=p.second+dy[i];//下一步走到的地方的坐标。
			if (tx>=n || tx<0 || ty>=m || ty<0 ||//这一行是判断是否越界。
				a[tx][ty]!=-1 || //这一行判断是否走过。 
				maze[tx][ty]==maze[p.first][p.second]){//这一行判断是不是符合题目约束。
				continue;//如果上面的任何一个不合法条件符合就跳过。 
			}
			q.emplace(tx,ty);//入队。
			a[tx][ty]=a[p.first][p.second]+1;//存入新的步数。 
		}
	}
	cout<<-1<<endl;//输出。
	return 0; //退出程序。
}
```