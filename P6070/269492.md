### 前置芝士：

二维前缀和 $sum[i][j]$ 定义为以 $1,1$ 为左上角，$i,j$ 为右下角的矩形的数字和。

二维前缀和的式子：$sum[i][j]=sum[i-1][j]+sum[i][j-1]-sum[i-1][j-1]$ （简单的容斥原理）

还有，前缀和就是差分的逆运算，差分数组的前缀和就是原数组哦。

### 来看这道题

这是一道类似于二维差分的模板题吧。

如果我们想将 $a[i][j]$ 的值变为 $0$，这个操作就会影响以 $i,j$ 为左上角，边长为 $k$ 的正方形。如何记录这次修改呢？这时候我们就可以用二维差分了。

跟二维前缀和类似，如果我们对 $cf[i][j]$ 加上 $1$，从 $a[i][j]$ 到 $a[n][n]$ 都会被加上 $1$，因此我们考虑分别对 $cf[i+k][j]$ 和 $cf[i][j+k]$ 都减去 $1$。但很不幸，从 $a[i+k][j+k]$ 到 $a[n][n]$ 都会被多减去一个 $1$，所以我们需要再把 $cf[i+k][j+k]$ 加 $1$。

综上，我们可以得到二维差分的式子了。
```cpp
（x是我们要给某个区间加上的数）
cf[i][j]+=x;
cf[i+k][j]-=x;
cf[i][j+k]-=x;
cf[i+k][j+k]+=x;
```
那在这道题中，如果一个数不为 $0$，且它所在的位置不能再在右下角画出一个边长为 $k$ 的正方形，那就说明我们无法使矩阵中所有数都变为 $0$ 了，别忘了输出 $-1$。

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,k,x,y,z,a[5005][5005],cf[5005][5005];
long long ans;

int main(){
	scanf("%d%d%d",&n,&m,&k);
	while(m--){
		scanf("%d%d%d",&x,&y,&z);
		a[x][y]=z;
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			cf[i][j]+=cf[i-1][j]+cf[i][j-1]-cf[i-1][j-1];
			a[i][j]+=cf[i][j];
			if(a[i][j]!=0){
				if(i+k>n+1||j+k>n+1){
					printf("-1");
					return 0;
				}
				cf[i][j]-=a[i][j];
				cf[i+k][j]+=a[i][j];
				cf[i][j+k]+=a[i][j];
				cf[i+k][j+k]-=a[i][j];
				ans+=abs(a[i][j]);//记得加绝对值
			}
		}
	}
	printf("%lld",ans);
	
	return 0;
}
```