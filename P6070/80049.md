### Preface

NOIP 考前复习二维前缀和与差分。

算是基础题。**同时也说明了动手画图很重要。**

### Solution

首先要分析如何做到最优解。观察题目的操作我们知道：

- 在同一个位置进行一加一减的操作是不合算的。

- **$(1,1)$ 位置只有唯一的矩阵可以被覆盖。**

根据第二条，我们只能进行 $|a_{1,1}|$ 次矩阵覆盖来使得这个点为 $0$。

再考虑其它的点，例如 $(1,2)$，发现如果覆盖的矩阵包括了 $(1,1)$ 的话，显然是合算的。而此时能覆盖 $(1,2)$ 的矩阵也就唯一了。

以此类推，每次操作都不能影响到前面的操作，每次的操作也就是唯一的了。我们就这样得到了最优解策略。

如果直接模拟上述过程，时间复杂度是 $O(n^2k^2)$ 的。但是区间加减操作是可以用差分进行简化的。

只会一维差分？那就先对原矩阵的行差分，再**对这个行差分矩阵**进行列差分（相当于一维中的二阶差分？）

其实仔细看图就会发现，只对行差分可以把时间优化到 $O(n^2k)$，再对列差分就可以 $O(n^2)$。

具体地如下图。为了方便，在 $n+1$ 行和 $n+1$ 列设置了 $0$。

![](https://cdn.luogu.com.cn/upload/image_hosting/2kt044q6.png)

那么我们只要根据刚才的策略，进行二维差分即可。若将上图的列差分矩阵记为 $d$，那么具体操作为：

从 $(1,1)$ 枚举到 $(n-k+1,n-k+1)$（矩阵不能出界），答案累加 $|a_{i,j}|$，然后进行二维区间覆盖：

- $a_{i,j}=a_{i,j}-a_{i,j}$
- $a_{i+k,j}=a_{i+k,j}+a_{i,j}$
- $a_{i,j+k}=a_{i,j+k}+a_{i,j}$
- $a_{i+k,j+k}=a_{i+k,j+k}-a_{i,j}$

最后判断一下 $d$ 还不存不存在不为 $0$ 的格子，存在即无解。

### Code

```cpp
void solve(void)
{
    for(int i=1;i<=n;i++)
        for(int j=1;j<=n;j++)
            d[i][j]=a[i][j]-a[i-1][j]-a[i][j-1]+a[i-1][j-1];
    for(int i=1;i<=n-k+1;i++)
        for(int j=1;j<=n-k+1;j++)
        {
            ans+=abs(d[i][j]);
            d[i+k][j]+=d[i][j];
            d[i][j+k]+=d[i][j];
            d[i+k][j+k]-=d[i][j];
            d[i][j]=0;
        }
}
int main()
{
    read(n,m,k);
    for(int i=1;i<=m;i++)
    {
        int x,y,z;read(x,y,z);
        a[x][y]=z;
    }
    solve();
    for(int i=1;i<=n;i++)
        for(int j=1;j<=n;j++)
            if(d[i][j])
            {
                puts("-1");
                return 0;
            }
    cout<<ans<<endl;
    return 0;
}
```