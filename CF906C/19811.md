个人认为题目页面的题意解释已经够详细了，这里不再解释。

## 有一个坑人的地方！
**客人们可以不经过介绍就已经互相认识**！所以开头需要特判
## 思路
将客人之间互相认识的情况状态压缩一下，作为下标存$dp$里面。$dp[s]$表示使i状态中所有客人互相认识所需要的最少步骤数。比如把数字s展开成二进制后是1011，数字"1"从左往右数依次排在第1、3、4位，则dp[s]的意思就是让1、3、4号客人从不认识变为互相认识所需的介绍次数。

所以第一小问的答案在$dp[(1<<n)-1]$里面。第一小问属于状压基础。至于第二小问，开个数组存$q$存经哪个客人介绍后达到的$i$状态，再开个数组$fa$查询$i$状态之前的状态。两个数组相结合就完事了。
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<bitset>
#include<algorithm>
using namespace std;
const int inf=0x3f3f3f3f;
int a[25];//a表示i号客人的朋友圈
int dp[(1<<22)+1000];//dp表示使i状态中所有客人互相认识所需要的最少步骤数
int q[(1<<22)+1000];//q表示经哪个客人介绍后达到的i状态
int fa[(1<<22)+1000];//查询i状态之前的状态，和q数组结合可以查询每个步骤中选择的客人编号，解决了第二小问
void fid(int x){
	if(fa[x])fid(fa[x]);
	printf("%d ",q[x]);
}
int main(){
	memset(dp,0x3f,sizeof(dp));
	int n,m;cin>>n>>m;
	for(int i=1;i<=n;i++)a[i]=1<<(i-1);//自己肯定认识自己 
	for(int i=1;i<=m;i++){
		int x,y;scanf("%d%d",&x,&y);
		a[x]+=1<<(y-1);//也可a[x]|=1<<(y-1); 
		a[y]+=1<<(x-1);//也可a[y]|=1<<(x-1); 
	}
	if(m==n*(n-1)/2){//如果给你的人际关系图中每个人身上都互相之间都认识，那就不用介绍了
		printf("0\n");
		return 0;
	}
	for(int i=1;i<=n;i++){//初始化 
		dp[a[i]]=1;//i号客人朋友圈内互相认识只需经过i一步介绍
		q[a[i]]=i;//达成i号客人朋友圈内互相认识的状态只需经过i介绍 
	}
	for(int s=0;s<(1<<n);s++){
		if(dp[s]==inf)continue;//当前状态无法达到 
		for(int i=1;i<=n;i++)
//选择i客人进行介绍的前提：1.i被人们所认识 2.让i介绍达到s|a[i]状态需要的步骤比之前的方案更优 
			if((s&(1<<(i-1)))&&dp[s|a[i]]>dp[s]+1){
				dp[s|a[i]]=dp[s]+1;//更新最优步骤 
				q[s|a[i]]=i;//达成s|a[i]状态是通过i介绍得出的 
				fa[s|a[i]]=s;//s|a[i]状态之前的状态是s 
			}
	}
	printf("%d\n",dp[(1<<n)-1]);
	fid((1<<n)-1);
	return 0;
}
```
