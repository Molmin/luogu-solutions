## 题目大意

给定两个 $01$ 字符串 $a,b$ ，保证它们的长度满足 $|a|\ge |b|$ ，可以取出 $a$ 中长度为 $|b|$ 的 $|a|-|b|+1$ 个子串，设为 $c$ 。定义差异度 $f(b,c)=\sum_{i=1}^{|b|} [b[i]\neq c[i]]$ ，即它们在对应位置上有不同的值的数量，求有多少个 $f(b,c)$ 的值是偶数。

$1\le |b|\le |a|\le 10^6$

## 解题思路

我们可以按起始位置从小到大排列这些子串，然后求相邻两个子串之间的差异，就可以得出所有子串的奇偶性。

我们固定字符串 $a$ 不动，滑动字符串 $b$ ，观察奇偶性变化的规律。

```
01100010
00110
 00110
```

若当前已经求出与 $b$ 差异度奇偶性的子串为 $a[l,r]$ ，则下一个子串为 $a[l+1,r+1]$ ，减去了下标为 $l$ 时对应的答案，加上了下标为 $r+1$ 时对应的答案。分别来看，如果其中一个对应的位置上的值不相等，则差异值的奇偶性发生变化。

观察中间的部分，如果 $b[i]=b[i+1]$ ，右移一位时这一位的答案不发生变化，如果 $b[i]\neq b[i+1]$ ，则右移一位时这一位的答案会 $+1$ 或 $-1$ ，也就是奇偶性会发生变化。可以得出，每次右移中间部分答案的奇偶性变化都是相同的。

由上面的性质，我们可以得出解法：求出 $a[1,|b|]$ 与 $b$ 的差异度的奇偶性，然后每次向右移动一位，根据两段和中间的讨论维护差异度的奇偶性，统计答案。时间复杂度 $O(n)$ 。

## 代码展示

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
const int maxn=1000010;
int l1,l2,nww,cnt,ans;
char a[maxn],b[maxn];
int main()
{
	scanf("%s%s",a+1,b+1);
	l1=strlen(a+1);l2=strlen(b+1);
	for(int i=1;i<=l2;i++)if(a[i]!=b[i])nww++;
	for(int i=1;i<l2;i++)if(b[i]!=b[i+1])cnt++;
	cnt=cnt%2;
	if(nww%2==0)ans++;
	for(int l=1,r=l2;r<l1;l++,r++)
	{
		if(a[l]!=b[1])nww++;
		if(a[r+1]!=b[l2])nww++;
		nww+=cnt;
		if(nww%2==0)ans++;
	}
	printf("%d\n",ans);
	return 0;
}
```