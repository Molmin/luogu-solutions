给定 $N,K$ 和 $b_{1\sim N}$，求有多少 $a_{1\sim N}$ 满足：

- $0\leq a_i\leq N$；
- $|MEX(a_1,a_2,\cdots,a_i)-b_i|\leq K$。

答案对 $998244353$ 取模。

$N\leq 2000$，$K\leq 50$。

一个常数和实现上都更加优秀的做法，不需要平行前缀和。

记 $[L_i,R_i]=[b_i-K,b_i+K]\cap[0,n]$。

记 $s_i=MEX(a_1,a_2,\cdots,a_i)$，那么大体思路要么对着 $a$ dp，要么对着 $s$ dp，显然后者更好。

为了构建 $s$ 和 $a$ 之间比较方便的计数方式，考虑 $s$ 序列如何生成：枚举 $j=0\to n$，如果 $j$ 出现了，那么找到其出现的第一个位置，记为 $pos_j$，那么 $P_j=\max_{k=0}^j\{pos_k\}\sim n$ 的 $s_i$ 都会增加 $1$。在此基础上，没作为 $pos_k$ 的位置 $i$ 的值 $a_i$，可以在取 $pos_v<i$ 的所有 $v$，以及 $v>s_n$ 的所有 $v$。直接设计状态 $dp_{i,j,k}$ 表示考虑了 $a_{1\sim i}$，且 $s_i=j$，并且在 $1\sim i$ 中有 $k$ 个 $>j$ 的等价类还未确定真实值。等价类的含义是若干值相等的 $a_i$。那么答案就是 $\sum_{j\in [L_n,R_n]} dp_{n,j,k}(n-j)^{\underline k}$。由于 $j$ 的取值是 $O(K)$ 的，所以总状态数 $O(N^2K)$，考虑转移。

对于 $a_i$ 的决策，首先分为新开一个等价类或是接在已有等价类上。然后在 $dp_i$ 中，还可以选择固定若干等价类的取值以增大 $j$，也就是从 $k$ 个里面选一个令其值为 $j$。注意到一个 bug 是，若 $s_i>s_{i-1}$，那么 $a_i=s_{i-1}$，且是第一次出现。也就是前缀 MEX 变化时，对 $a_i$ 还有一个额外的限制，那么把转移分为是否令 MEX 变化的两部分，第一部分 $dp_{i-1,j,k}\to dp_{i,j,k+1}$，$dp_{i-1,j,k}\times (j+k)\to dp_{i,j,k}$；第二部分在 $f=dp_{i-1}$ 的基础上允许 $f_{j,k}\times k\to f_{j+1,k-1}$ 的转移，再 $f_{j,k}\to dp_{i,j+1,k}$，即一旦 MEX 发生变化，$a_i$ 的决策就固定为新开一个值为 $j$ 的等价类。

考虑这么做的复杂度，瓶颈只在于 $f$ 内部转移里 $j$ 的范围。注意到 $s_i\ge s_{i-1}$，那么 $L_i$ 可以调整为不降的，显然 $j$ 的范围只需要在 $\min(L_{i-1},L_i)\sim \max(R_{i-1},R_i)$ 中。若 $L_{i-1}=L_i$，那么区间长度是 $O(K)$ 的，否则 $L$ 的总增量是 $O(N)$ 的，每次增加只需要多扫 $L_{i-1}\sim L_{i}$ 这一段，于是这部分的复杂度也是 $O(N^2K)$ 的。实现上需要滚动数组和清空合适的位置。[Submission](https://codeforces.com/contest/1608/submission/210210364)