这道题是一道小小的模拟。

首先骨头的位置原先是在 $1$ 的位置上，在所有交换 $x$ 和 $y$ 的操作当中，如果骨头的位置与其中一个值重合，我们就把它的位置赋成另一个值。

根据特殊规则，如果骨头掉进坑里面就不会再进行交换。我们定义一个数组，数组当中 $1$ 表示坑，而 $0$ 表示没有坑。每次准备进行操作是，我们判断一下此时骨头的位置，如果骨头的位置在数组中刚好是 $1$，就省略下面所有的操作。

代码如下：

```
#include<bits/stdc++.h>
using namespace std;
int n,m,k;
int vis[2000005];//存放是否有坑的数组
int zb;//骨头的当前坐标
int main()
{
    cin>>n>>m>>k;
    for(int i=1;i<=m;i++)
    {
        int x;
        cin>>x;
        vis[x]=1;//有坑的位置赋值
    }
    zb=1;//骨头初始坐标为1
    for(int i=1;i<=k;i++)
    {
        if(vis[zb])//省略操作
        {
            continue;
        }
        int x,y;
        cin>>x>>y;
        if(zb==x)//当其中两个坐标当中有骨头才进行操作
        {
            zb=y;
        }
        else if(zb==y)
        {
            zb=x;
        }
    }
    cout<<zb;
    return 0;
}
```