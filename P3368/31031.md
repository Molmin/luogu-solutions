这模板题名字就是树状数组..干嘛用线段树..代码还贼长..

这里介绍树状数组+差分思想，算是对下面大神的补充吧。

###何为差分

现在我们有一个从小到大的数列a[]

- a 1 3 6 8 9

然后还有一个差分数组b[]

- b 1 2 3 2 1

相信某些小伙伴已经看出端倪了..这里**b[i]=a[i]-a[i-1]**，我令a[0]=0，故b[1]=a[1]。

拥有了b数组，我们就可以很简单的求出bit[]中任意一个数，只需**bit[i]=sigma(k=1 to i) b[k]**（这个很好推吧..）

我觉得现在该有人说我zz了..何必不直接查询a[i]而是找这么麻烦一个方法..这里我们转回正题！别忘了，题目要我们进行区间修改..

我们知道，树状数组对于单点值的修改十分方便（不懂的去看树状数组1），对于区间的修改就比较尴尬..而我们又不想敲死长的线段树..怎么办呢，这时候差分就显出优势

还是上面的a[]和b[]，现在我们使区间[2,4]的所有数均+2，则a[]/b[]变为

- a 1 5 8 10 9

- b 1 4 3 2 -1

事实上，这里只有b[2]和b[5]发生了变化，因为区间内元素均增加了同一个值，所以b[3]，b[4]是不会变化的。

这里我们就有了第二个式子：对于区间[x,y]的修改（增加值为d）在b数组内引起变化的只有 **b[x]+=d，b[y+1]-=d**。（这个也很好推的..）

这样，我们就把树状数组的软肋用差分解决了。

附代码

```cpp
#include<iostream>
using namespace std;

int n,m,a[1000000],t[1000000];

int lowbit(int x) {
    return x&(-x);
}

void add(int x,int d) {
    while(x<=n) {
        t[x]+=d;
        x+=lowbit(x);
    }
}

int sum(int x) {
    int ans=0;
    while(x) {
        ans+=t[x];
        x-=lowbit(x);
    }
    return ans;
}

int main() {
    cin>>n>>m;
    for(int i=1;i<=n;i++) {
        cin>>a[i];
        add(i,a[i]-a[i-1]);   //直接将树状数组存为差分后数列 #**b[i]=a[i]-a[i-1]**#
    }
    for(int p=1,op,x,y,k;p<=m;p++) {
        cin>>op;
        if(op==1) {
            cin>>x>>y>>k;
            add(x,k); add(y+1,-k);   // #**b[x]+=d，b[y+1]-=d**#
        }
        if(op==2) {
            cin>>x;
            int ans=sum(x);   //#**bit[i]=sigma(k=1 to i) b[k]**#
            cout<<ans<<endl;
        }
    }
}
```