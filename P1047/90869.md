神奇的题，做法很多

本蒟蒻为了A掉某超恶心的加强版(n<=2e8)而写了某奇怪算法

因为n的大小，只能向m考虑,复杂度不能包括n

## 算法如下：

- 用a数组记录下每个移动区间的起点终点并按大小排序 

- 总距离加上从0到a[1]的距离和a[2*m]到l的距离

- 枚举2*m个点,记录当前还有多少个没有对应的起点

- 若当前已无没有对应的起点，加上当前a[i]到a[i-1]的距离

- 输出总距离

## 重点：

1. ### 为什么要记录当前还有多少个没有对应的起点?

	ans：因为如果当前还有没有对应的起点，则a[i]与a[i-1]之间的距离会包含在没有对应的起点所对应的移动区间内。
    
  	比如说样例：
    ```cpp
	500 3
	150 300
	100 200
	470 471
	```
    
    当枚举到150这个起点时，150~100的距离应是包含在100~200中的，所以不加。
    
2. ### 为什么这样能对?
	ans:这样子算其实是统计多个移动区间之间的树和。
    
    开头的树和结尾的树未被统计，所以先加上。而中间算a[i]~a[i-1]距离时应是（a[i].s-a[i-1].s-1）,减一是因为移动区间是闭合区间。
    
## 代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
struct data{
	int s,q;
}a[40001];
bool cmp(data u,data v){
	return u.s<v.s;
}
int main(){
	int l,m,x,y,tot=0,sum=0;
	scanf("%d%d",&l,&m);
	for(int i=1;i<=m;i++){
		scanf("%d%d",&x,&y);
		a[i*2-1].q=0;//记录是开头还是结尾
		a[i*2-1].s=x;
		a[i*2].q=1;
		a[i*2].s=y;
	}
	sort(a+1,a+m*2+1,cmp);//排序
	sum+=a[1].s+l-a[2*m].s;
	for(int i=1;i<=2*m;i++){//神奇的O(2*m)时间复杂度
		if(!tot&&i>1) sum+=a[i].s-a[i-1].s-1; 
		if(!a[i].q) tot++;
		else tot--;
	}
	printf("%d",sum);//AC~
}
```

求过审QAQ