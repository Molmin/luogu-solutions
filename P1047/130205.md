看了一圈题解下来，发现没和我思路一样的。  
思路就是把重叠区域合并、删除，然后数学计算出剩下的树的数量。
```cpp
#include <bits/stdc++.h>
#define FOR(a,b,i) for(int i=a;i<b;++i)

using namespace std;

int L, M, A[105], B[105];

int main() {
    ios::sync_with_stdio(false);
    cin >> L >> M;
    FOR(0, M, i) {
        cin >> A[i] >> B[i];
        // 因为题目没说区间端点的范围，于是在下面做了修正（实际感觉也没必要）
        if (A[i] < 0) A[i] = 0;
        else if (A[i] > L) A[i] = L;
        if (B[i] < 0) B[i] = 0;
        else if (B[i] > L) B[i] = L;
    }
    // 数据读完后，A[i]表示区域i的左端点，B[i]表示区域i的右端点
    // 下面对端点处理，合并重叠的区间
    FOR(0, M, i) {
        // 若出现端点小于0，说明该区域已经移除，直接跳过
        if (A[i] < 0 || B[i] < 0) continue;
        FOR(i + 1, M, j) {
            if (A[j] < 0 || B[j] < 0) continue;
            // 对区域i和区域j比较，可能出现的情况
            // 此步操作不能移除区域j而保留区域i，因为在之后的比较里区域i不会参与，导致不能继续类似这样处理合并
            if (A[i] <= A[j] && B[i] >= B[j]) {
                // 区域i包含区域j，将区域j的范围设置为区域i的
                A[j] = A[i];
                B[j] = B[i];
                A[i] = B[i] = -1; // 移除区域i
                break; // 因为区域i已经处理，不需要继续循环比较区域i与区域j+1
            } else if (A[i] > A[j] && B[i] < B[j]) {
                // 区域j包含区域i，说明区域i不需要考虑
                A[i] = B[i] = -1;
                break;
            } else if (A[i] <= A[j] && B[i] >= A[j]) {
                // 区域部分重叠情况，区域i的左端点比区域j的左端点更前，把区域j的左端点提前到区域i的左端点位置
                // 右端点部分一定是区域j比区域i的更后
                // 示意图(处理前)：
                // |    i    |
                //       |       j     |
                // 示意图(处理后)：
                //  (区域i不存在)
                // |             j     |
                A[j] = A[i];
                A[i] = B[i] = -1;
                break;
            } else if (A[i] <= B[j] && B[i] >= B[j]) {
                // 区域部分重叠情况，区域i的右端点比区域j的右端点更后，把区域j的右端点增加到区域i的右端点位置
                // 左端点部分一定是区域j比区域i的更前
                // 示意图(处理前)：
                //           |    i    |
                // |       j     |
                // 示意图(处理后)：
                //  (区域i不存在)
                // |       j           |
                B[j] = B[i];
                A[i] = B[i] = -1;
                break;
            }
        }
    }
    // 剩下非重叠的区域，可以直接进行计算了
    FOR(0, M, i) {
        // cout << "A[" << i << "]=" << A[i] << ",B[" << i << "]=" << B[i] << endl;
        if (A[i] < 0 || B[i] < 0) continue; // 跳过移除的区域
        L -= (B[i] - A[i] + 1); // 每次用剩余树的数量减掉区域i的树的数量
    }
    cout << L + 1; // 这里+1是因为最开始实际上有L+1棵树
    return 0;
}
```