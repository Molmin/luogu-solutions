不想写拓扑的同学可以看一看这个~~又短又快~~的搜索

**~~不要长代码,也没有龟速搜索,搜索函数只要两行,你值得拥有~~**(虽然拓扑也很短)

我们设$f[i]$表示从$i$点走到终点的所经过的路径总长度**期望**

期望简单来说就是**所有的(贡献$\times$概率)的和**,比如一张彩票有0.0001%的几率中10000000元,有99.9999%中10元,那么买一张彩票期望中的钱数就是$0.0001\%\times 10000000+99.9999\%\times10=19.99999$

所以可以得到,$f[n]=0$(自己到自己的路径长肯定为0)

所以我们考虑**反着存图**,从n开始走,原本是看如果该节点有几条出边,现在是看有几个入边

先看一张正的图

![](https://cdn.luogu.com.cn/upload/image_hosting/m6ijo4zo.png)

再看一个反着存的图

![](https://cdn.luogu.com.cn/upload/image_hosting/n6ipby4k.png)

我们来看$f[1]$怎么求,我们先不管概率,直接让蛙在点1时跳到点2,那么,**点1走到终点路径总长度的期望=点2走到终点路径总长度的期望+1到2路径长度**(这应该是比较好理解的),即$f[1]=f[2]+2$,所以跳到点$2$对$f[1]$的**贡献**为$f[2]+2$,跳到第三点也同理

如果我们考虑概率,蛙在点1时都有$0.5$的几率到2和3,根据前面期望的求法,可得$f[1]=(f[2]+2)*0.5+(f[3]+1)*0.5$,当然,按下面的做法,此时$f[2]$和$f[3]$的值是**已经确定**的

根据上面的说明,我们可以得出结论

$f[i]=\sum ( \frac{1}{rd[i]}\times(f[j]+w[j->i]))$

这里$\sum$枚举所有可以到$i$的点$j,w[j->i]$为i到j的路径长,因为是反图所以,这里是$j->i,rd[i]$为点i的**入边个数**

现在来看**怎么搜索**,看上面的结论,似乎是从i点一个个找能到它的点,但其实肯定是如果$j$能到$i$则将$f[i]+= \frac{1}{rd[i]}\times(f[j]+w[j->i])$,这样也能有同样的效果

还有一点就是我们要避免一个点i的$f[i]$值还没确定就对其他点产生贡献,我们知道一个点的**所有入边都被走过时就说明它的贡献值已经确定**,而一个点对其他点产生更新需要从这个点**走**到被贡献点,**所以我们可以这样搜:**

从一确定贡献的点A走到B,分情况讨论:

如果B还**未确定**那么,将f[B]加上A的贡献/B的入边数,并使B剩余的入边减一,结束(未确定时不走)

如果B在A走到B后**已确定**,将f[B]加上A的贡献/B的入边数,并使B剩余的入边减一,再从B开始继续走(搜索)

###### ~~其实和拓扑排序差不多~~

第一个确定贡献的点为$n$

这样搜索可以保证正确且复杂度未$O(N+M)$(大概)

具体看代码吧

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+5;
int n,m,ft[N],nx[2*N],w[2*N],to[2*N]/*存边四人组*/,rd[N],rn[N];//rd为入边的个数,rn为还未走过的入编个数
double f[N];
inline int read()//快读
{
    char c=getchar();int sum=0,f=1;
    while(!(c>='0'&&c<='9')) {if(c=='-') f=-1;c=getchar();}
    while(c>='0'&&c<='9') {sum=((sum<<1)+(sum<<3))+(c-'0');c=getchar();}
    return sum*f;
}
void dfs(int x,int fr,int way)//x为现在所在点,fr为是从点fr到点x,way为从fr到x的路径编号
{
    f[x]+=(f[fr]+w[way])/rd[x];//加贡献
    if(!(--rn[x])) for(int i=ft[x];i;i=nx[i]) dfs(to[i],x,i);//如果rn[x]减一后为0,则说明其已经确定,可以继续走
}
void add(int x,int y,int wt){nx[wt]=ft[x];ft[x]=wt;to[wt]=y;rd[y]++;rn[y]++;}//因为add函数太常规,所以它缩了起来
int main()
{
	n=read();m=read();
	for(int i=1;i<=m;i++) 
	{
	int x=read(),y=read();w[i]=read();
	add(y,x,i);//反着存,这里i为边的号数
    }
	for(int i=ft[n];i;i=nx[i]) dfs(to[i],n,i);//从n直接开始搜
	return printf("%.2lf",f[1]),0;//输出
}
```
