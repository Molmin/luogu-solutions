## 1. 解析：
    由于这n个数是互不相同的，那么把位于B数两边的数分成左右
    两部分，显然要构成B是中位数可能的数要么全部来自于左或
    右两部分，要么一部分来自于左边另一部分来自于右边，假定
    B所在的位置为k。
    
	(1) 对于全部来自于左边或右边，那必须是从B这个数位置开
    始，且大于和小于B的数的个数一定相等，我们记i位置到k大
    于B和小于B的个数差，显然全部来自某一边则必然要求这个差为0。
	(2) 对于一部分来自于左边，另一部分来自右边，如果想让B成
    为中位数，那么些时来自于左边的那些大于B和小于B的个数差
    与来自于右边那些小于B和大于B个数差要相等，即两边所有大
    于B和所有小于B的个数正好抵消！
    
	于是我们在读入的时候开始记录，从找到B的位置之后（即右边
    部分）统计每一个位置小于B和大于B的个数差，即用数组记录
    t+= (a[i] > B) - (a[i] < B)（即若a[i]>B即+1，a[i]<B
    即-1），s[t]++。
    
	但这里要注意：t有可能是负数，一种方法就是把所有的t都平移
    一个值（常用的方法），这样数组就所扩大一倍，另外考虑t
    的正负值个数不可能超过n，所以当t为负的时候就+n，正的时
    候就不变，如同把正负放在一个数组的两端，这样就不用扩大
    数组了。然后把s[0]++（因为单个B也是差为0的方案），显然
    此时的ans = s[0]。
    
    最后在从k-1位置向前（即左边部分）扫描，如同刚才的处理
    一样，当然这里只需要计算t，而不需要用数组保存了，t += 
    (a[i] < B) - (a[i] > B)（与右边部分相反记录），此时只
    要把答案 ans+=s[t]即可。注意t的负数处理也要同上。而ans
    却不需要再单独加上左边t为0的方案了，因为这边所有为0的方案已
    经与单个B组合成方案了。


------------

2. 参考代码，请自行完善（防作弊）
```cpp
for(int i = 1; i <= n; i++)
{
  cin >> a[i];
  if(k)
  { //找到B后开始记录
    t+=______;
    s[______]++;
  }
  if(a[i] == B) k = i; //记录B所在的位置
} 
  t= 0;
  long long ans = ++s[0];
  for(int i = k - 1; i > 0; i--)
  {
    t +=______;
    ans += s[______];
  }
```
