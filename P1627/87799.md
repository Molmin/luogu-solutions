输入一个数组,然后对于a[i],i是不是>,i是不是<b。求前缀和。

拿样例来说
```cpp
n,b:7 4
a:5 7 2 4 3 1  6 
>:1 2 2 2 2 2  3
<:0 0 1 1 2 3  3
-:1 2 1 1 0 -1 0
```
上图中,>表示i>b的前缀和,<表示i<b的前缀和,-表示它们的差。

前缀和的用处:可以求任意一段区间的数量。从l到r的数量就是a[r]-a[l-1]

---

然后,我们要求中位数,就是在一段区间里,比i大的跟比i小的数量一样多。

这样,我们就可以把下标为奇数和下标为偶数的差(上图的 - 数组)分别放入两个桶里,结果就是sum{桶1×桶2},因为可以选任意一个桶1的元素作为起点。桶2的任意一个元素作为终点。

为什么要放奇数和偶数呢?因为长度必须是奇数。

ac代码
```cpp
#include<iostream>
using namespace std;
int mark1[200005]={0},mark2[200005]={0},cz[100005],zyl1[100005],zyl2[100005]; //zyl1:< zyl2:> cz:-
int main(){
	int n,i,a,b,sum=0;
	cin>>n>>b;
	cin>>a;
	zyl1[0]=(a<b);
	zyl2[0]=(a>b);
	cz[0]=zyl1[0]-zyl2[0];
	for(i=1;i<n;i++){
		cin>>a;
		zyl1[i]=zyl1[i-1]+(a<b);
		zyl2[i]=zyl2[i-1]+(a>b);
		cz[i]=zyl1[i]-zyl2[i];
	}
	mark1[100000]=1;
	for(i=0;i<n;i++){
		if(i&1){ //i&1是判断i是否是奇数的一种更快的方法。
			mark1[cz[i]+100000]++; //解决桶里有负数的情况,可以加上一个数。
		}else{
			mark2[cz[i]+100000]++;
		}
	}
	for(i=0;i<=200000;i++){
		sum+=mark1[i]*mark2[i];
	}
	cout<<sum;
	return 0;
}
```