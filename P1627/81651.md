个人感觉这是一个比较快又好理解的算法。
代码还有一定的优化空间，欢迎开喷...
```cpp
#include<bits/stdc++.h>
using namespace std;
int b,n;                     //中间数和输入的数量
int s[100001];               //输入时所用的标记，用于标记是否比中间数大
int temp,mid;                //输入和中间数的位置
int p[1000001];              //总和表
int l[1000001]={0},r[1000001]={0};   //左侧的桶，右侧的桶
int ans=0;
int main()
{
    cin>>n>>b;               //输入中间数和输入的数量
    for(int i=1;i<=n;i++)    //按照题意输入并进行处理
    {
        cin>>temp;
        if(temp==b)          //如果这个数与‘中间数’的值是相等的，那么就把这个数设为中心
        {
            mid=i;           //找中间数
            s[i]=0;          //将该数的位于统计表中的位置设为0
        }
        else
        {
            s[i]=temp>b?1:-1;//大于‘中间数’的值为1，小于‘中间数’的值为-1
        }
    } 
    for(int i=mid-1;i>=1;i--)//扫左边的表
    {
        p[i]=p[i+1]+s[i];    //更新总和表中的数据
        l[p[i]+n]++;         //将该数据的桶的相应位置坐标记
    }
    for(int i=mid+1;i<=n;i++)//扫右边的表
    {
        p[i]=p[i-1]+s[i];    //更新总和表中的数据
        r[p[i]+n]++;         //将该数据的桶的相应位置坐标记
    }
    for(int i=-n;i<=n;i++)
    {
        ans+=l[i+n]*r[-i+n]; //正i与负i可构成中位b,个数相乘。 
	} 
    cout<<ans+1+l[n]+r[n];   //0单独算1个，左0和右0与中位也构成中位b，因此加入
    return 0;
}
```