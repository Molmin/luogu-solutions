# 题目大意
删掉 $s$ 的字串，让 $t$ 任然能成为 $s$ 的子序列。

求出删掉的字串的最大长度。
# 思路
我们可以预处理出 $s$ 最先出现和最后出现的 $t$（原因后面会讲）。

然后我们就开始考虑删的方法。

删除的方法有三种：

1. 从 $1$ 向前删。

2. 从 $|s|$ 向后删。

3. 从中间删。

---

考虑从 $1$ 向前删。

要保证 $t$ 能成为 $s$ 的子序列。

就只能删掉 $t$ 最后出现在 $s$ 的子序列的位置的前面。

看一组自编样例：

```
elyjcodeisnb
code
```
考虑从 $1$ 向前删。

code 在最后出现的位置分别是 $5,6,7,8$。

那我们就可以删掉 $1$ 到 $4$ 的子串。

---

考虑从 $|s|$ 向前删。

要保证 $t$ 能成为 $s$ 的子序列。

就只能删掉 $t$ 最先出现在 $s$ 的子序列的位置的后面。

还是那组样例：

```
elyjcodeisnb
code
```
考虑从 $|s|$ 向前删。

code 在最先出现的位置分别是 $5,6,7,8$。

那我们就可以删掉 $12$ 到 $9$ 的子串。

---
考虑从中间删。

我们先看自编样例：

```
ccfomadecodeisnb
code
```
考虑从 $1$ 向前删。

code 在最先出现的位置分别是 $1,4,7,8$。

code 在最后出现的位置分别是 $9,10,11,12$。

我们可以尝试不要位置 $9$ 的 c，要位置 $1$ 的 c。

那我们就可以删掉 $2$ 到 $9$ 的子串。

那这个子串的长度就变成了 $r_i-l_{i-1}-1$。

$r_i$ 为最后出现的 $t_i$ 的位置。

$l_i$ 为最先出现的 $t_i$ 的位置。

---
综上所述长度为这三种情况的最大值。
# 代码
```cpp
#include <algorithm>
#include <iostream>

using namespace std;

const int kMaxN=2e5+3;

int l[kMaxN],r[kMaxN];
int ans;
int main() {
	string s, t;
	cin>>s>>t;
	int ls=s.size(),lt=t.size();
	for(int i=0,j=0;i<ls&&j<lt;i++)
	{
		if(s[i]==t[j])
		{
			l[j++]=i;
		}
	}
	for(int i=ls-1,j=lt-1;i>=0&&j>=0;i--)
	{
		if(s[i]==t[j])
		{
			r[j--]=i;
		}
	}
	ans=r[0];//前面删掉的数量
	for(int i=1;i<lt;i++)
	{
		ans=max(ans,r[i]-l[i-1]-1);//中间删掉的数量 
	}
	ans=max(ans,ls-l[lt-1]-1);//后面删掉的数量 
	cout<<ans;
	return 0;
}
```