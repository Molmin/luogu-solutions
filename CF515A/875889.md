# 题目大意
这道题是发生在一张地图上的事。说你位于第 $0$ 行第 $0$ 列，然后会给出两个数 $a$ 和 $b$ 以及 $s$，代表你需要到达的目的地位于第 $a$ 行第 $b$ 列，并且要通过上、下、左、右四种方式使用 $s$ 步**正好**到达目的地。最后问你能否做到，能则输出 Yes，否则输出 No。


------------
# 思路
这道题的关键点就在于要正好 $s$ 步，那我们就可以运用一种思想，就是先尽快到达终点后，开始反复横跳：先往右，再往左。不停地**循环重复**下去。这样一来，最后就很有可能刚好落在目的地上。

------------
# 具体步骤
### 第一环节
既然我们要尽快到达终点，所以我们就先要求出**最少步数**。最少步数为 $\operatorname{abs}(a+b)$。但是在求出最少步数后，我们要看看最少步数是不是已经大于要求步数。

------------
### 第二环节
其次我们要看看到达目的地后反复横跳最后会落在那个地方，那我们就可以以**两步一组**，看看剩余步数能否刚好支撑完若干组。进行此步骤时，我们需求**余数**。余数为 $(s-\operatorname{abs}(a+b)) \bmod 2$。接下来，如果余数为 $0$ 则证明可以正好通过 $s$ 步走到目的地，反之不能。


------------
# 完整代码
```cpp
#include<bits/stdc++.h>
using namespace std; 
int a,b,s;
int main(){
    scanf("%d%d%d",&a,&b,&s);
    int MinStep=abs(a+b); //最少步数 
    int ResidueStep=s-MinStep; //剩余步数 
    if(ResidueStep<0){
    	cout<<"No";
    	return 0;
	} //判断最少步数是否已经大于目标步数 
    int Num=ResidueStep%2; //反复横跳结果余数 
    Num?(cout<<"No"):(cout<<"Yes");
    return 0;
}
```
