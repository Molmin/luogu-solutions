这是一篇暴力状压 dp 的题解，想必学过状压的人都做过一道叫 互不侵犯 的经典题，这题就和那题类似。话说这题好像在今年 WC 上插头 dp 的例题讲过吧，原题应该叫“蒙德里安的梦想”。

我们一般都是把较小的元素状压，首先看到 $n×m<100$ 范围，就可以发现 $n,m$ 中较小的那个肯定不超过 $10$ ，那只要判断一下再交换行列就行了。而且没有方案可以铺满的话， $n$ 和 $m$ 一定都是奇数，因为铺在棋盘上是 $1×2$ 的长方形，可以列方程证明。

设 $f[i][S]$ 为第 $i$ 行列的状态为 $S$ 的方案数，如果是行数更小那就交换 $n,m$ 。这个方案数其实就是所有竖放的方块的方案数，因为竖放的方块全部确定了，横放的就必须去填满剩下的空格，那就只管竖放的就好了，二进制位为 $1$ 表示在第 $i$ 行的这一列放了一个竖的方块。比如 $S=9_{(1001)}$ 时，就表示第 $i$ 行的方块状态是这样的：

![](https://cdn.luogu.com.cn/upload/image_hosting/2d6lit5i.png)

则最后 $ans←f[n][0]$ ，表示第 $n$ 行没有竖放的方块（不然就会有方格凸出到 $n+1$ 行），初始化 $f[0][0]←1$ 。然后可以根据上面的状态推出 $f[i][k]←f[i][k]+f[i-1][j]$ ，其中 $k$ 为 $i$ 行的状态， $j$ 为 $i-1$ 行的状态。

但显然这个东西是不能直接转移的，要保证这个转移合法，首先要确保 $i-1$ 行和 $i$ 行 都是合法的，也就是 $j\&k=0$ ，表示如果 $i-1$ 行的某列放了个竖的，那 $i$ 行的这列就不能再放个竖的；其次要使这个 $k$ 和 $j$ 两个状态放在 $i$ 和 $i-1$ 行上面之后，仍然可以通过横放把图填满，读者在这里可以自己思考或画图一下，什么情况会使之后 **没有任何横放的方法** 可以 **填满** 现在竖放完之和 **剩下的空** 。

结论很好想，其实只要某一行竖的放完了之后，这行还剩下 **奇数个连续的空**，就一定不能只靠横放 $1×2$ 的长方形把它填满。所以可以先处理出 $0...2^m-1$ 所有状态是否有连续奇数个 $0$ ，表示这一行填了若干竖方块后能否用横的去填满，因为然后再判断 $j|k$ 后的结果是否有奇数个连续的空，就可以转移了。

UOJ 的数据也不水，不仅要开 long long ，而且我发现一开始裸 dp 超时了，但是我把 $n,m$ 所有数据都跑了一遍发现只跑了 800ms ，于是就想到了记忆化已经做过的答案（其实还可以打表），最后跑了 720ms ，在最优解里排倒数。。。

代码：
```cpp
#include<bits/stdc++.h>
#define ulol unsigned long long
#define rep(x,l,r) for (register int x=l; x<=r; x++)
using namespace std;
bool b[2100]; // b 表示该状态是否合法，合法为 0 ，不合法为 1 
int n,m;
ulol f[106][2100],a[106][106]; // f 表示方案数，a 是记忆化数组 
int main(){
	ios::sync_with_stdio(0),cin.tie(0);
	memset(a,-1,sizeof(a));
	while (cin>>n>>m)
	{
		if (n<m) swap(n,m);
		if (a[n][m]!=-1){ cout<<a[n][m]<<endl; continue;}
		if ((n&1)&&(m&1)||n==0||m==0){ cout<<0<<endl; continue;}
		memset(f,0,sizeof(f)),memset(b,0,sizeof(b));
		f[0][0]=1ll;
		rep(i,0,(1<<m)-1)
		{
			int cnt=0; // cnt 统计连续的 0 的个数 
			rep(j,0,m-1)
			if (!(1<<j&i)) cnt++; // 如果 i 的第 j 位为 0
			else {if (cnt&1) b[i]=1; cnt=0;}
			if ((cnt&1)) b[i]=1;
		}
		rep(i,1,n) rep(j,0,(1<<m)-1)
		rep(k,0,(1<<m)-1)
		if (!b[j|k]&&!(j&k)) f[i][k]+=f[i-1][j];
		a[n][m]=f[n][0]; //记忆化操作 
		cout<<f[n][0]<<endl;
	}
	return 0;
}
```