对于任意一个 $a_i$，设它的第 $j$ 个因数为 $y_j$，那么以 $a_i$ 结尾的、长度为 $y_j$ 的合法子序列的个数，由在它之前的长度为 $y_j-1$ 的子序列的个数决定。

设 $f_i$ 表示长度为 $i$ 的合法子序列的个数，结合乘法原理，推出状态转移方程：

$f_{y_j}=f_{y_j}+f_{y_j-1}$

由于是按顺序 $1->n$ 遍历 $a$，所以不会出错。

线性遍历一遍数组，每次用 $\sqrt{a_i}$ 的效率求出 $a_i$ 的因数，所以复杂度是$O(n\sqrt{\max{a_i}})$？错。

对于 $2$ $|$ $j$，有 $y_j=\dfrac{a_i}{y_{j-1}}$，所以 $y$ 并不是递增的，这样会造成一个错误，就是当 $y_j-1$ $|$ $a_i$ 时，答案会多 $+1$，因为 $y_j-1$ 已经作为 $a_i$ 的因数遍历过了，此时长度为 $y_j-1$ 的合法子序列的个数中已经包括以 $a_i$ 结尾的了，如果再计算 $y_j$，就会有多个 $a_i$ 出现在子序列里，这显然是不合法的。

可能有点难理解，举个最简单的例子。数字 $2$，在计算它的第一个因数 $1$ 时，长度为 $1$ 的合法子序列个数为 $1$。计算第二个因数 $2$ 的时候，它一看，诶在我前面已经有一个长度为 $1$ 的合法子序列了，那我就接在它后面吧，所以这时它会认为长度为 $2$ 有一个，这时候 $2$ 就用了两次。

所以找完所有因数后，还要排序，**从大到小**遍历。设 $a$ 中因数最多的数的因数个数为 $x$，所以正确的复杂度应该是 $O(n \max(\sqrt{\max{a_i}},x \log x))$。

```cpp
#include<iostream>
#include<cmath>
#include<algorithm>
using namespace std;
const int mod=1e9+7;
long long n,a[1000010],f[1000010],ans,y[1000010];
int main(){
    cin>>n;
    for(int i=1;i<=n;i++)cin>>a[i];
    f[0]=1;//使单独一个数能成为合法子序列
    for(int i=1;i<=n;i++){
    	int top=0;
    	for(int j=1;j<=sqrt(a[i]);j++){
    		if(a[i]%j)continue;
			y[++top]=j;
			if(j*j!=a[i])y[++top]=a[i]/j;
		}//求因数 
		sort(y+1,y+top+1);//排序 
    	for(int j=top;j>=1;j--)
    		f[y[j]]=(f[y[j]]+f[y[j]-1])%mod;//状态转移方程 
	}
	for(int i=1;i<=n;i++)
		ans=(ans+f[i])%mod;
	cout<<ans;
    return 0;
}
```
