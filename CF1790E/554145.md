很好玩的一道题。

先解释一下**按位异或**（$\operatorname{xor}$）。引用百度百科的几句话（以下所有 $a,b$ 都是二进制下的一位数）：

>如果 $a,b$ 两个值不相同，则异或结果为 $1$。如果 $a,b$ 两个值相同，异或结果为 $0$。  
> 异或也叫**半加运算**，其运算法则相当于**不带进位的二进制加法**。

也就是说，$a\operatorname{xor}b=(a+b)\bmod2$。而 $a+b$ 的最低位也是这么算的。可以看出在没产生进位的情况下，$a+b$ 应该等于 $a\operatorname{xor}b$。所以如果 $x$ 的某一位和 $2x$ 的相同位**不同**，我们能看出**这一位更低的一位加法会产生进位，否则不会。** 原因是：我们可以想到，这个不同一定是更低一位的进位贡献来的（因为异或没有进位，加法可能有，所以可能会出现进位的不同）。当然，如果这不同的一位是最低位，那是无解的！由于 $2x$ 一定是偶数，所以如果最低位不同，$x$ **一定是奇数**。则我们看到 $x$ 为奇数时就可以直接回答无解了。

但是 $x=6$ 为什么也无解呢？$6=(110)_2,6\times2=12=(1100)_2$。最低位是 $0,0$，符合要求。但是倒数第二位不同，说明要进位。但是到了倒数第二位，我们发现没法满足它**和的最低位为 $0$，但异或是 $1$，倒数第三位又不能进位**的~~麻烦的~~要求。这里就不细说了。

放个代码：

```cpp
#include<iostream>
using namespace std;
int main()
{
    int t;
    cin>>t;
    while(t--)
    {
        int x;
        cin>>x;
        if(x%2)
        {
            cout<<-1<<endl;
            continue;
        }
        int y=2*x,cur=0,a=0,b=0;
        bool flag=1;
        while(y)
        {
            if(x%2==0)
            {
                if(x/2%2!=y/2%2)
                    a=a+(1<<cur),b=b+(1<<cur);
            }
            else
            {
                if(y%2==0)
                {
                    if(x/2%2==y/2%2)
                    {
                        flag=0;
                        break;
                    }
                }
                else if(x/2%2!=y/2%2)
                {
                    flag=0;
                    break;
                }
                a=a+(1<<cur);
            }
            x/=2,y/=2;
            cur++;
        }
        if(!flag)cout<<-1<<endl;
        else cout<<a<<" "<<b<<endl;
    }
    return 0;
}
```

这篇题解应该会有一些人看不懂吧，本蒟蒻的语文太差了，虽然很仔细地改了好几回，但还是没法说得很清楚，很难把此题的好玩之处写出来。不懂的私信我吧。