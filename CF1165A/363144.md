这个题上面那篇题解已经非常的详细了。

这里我将一个非常好用而快速的东西 —— 位运算。

这个东西的思想就是将一个 01 串压缩为一个二进制的变量，并对这个变量的每一个位进行修改，查询。速度非常快。

先来熟悉一下几个位运算的操作：

1. ```|``` ：按位或，将每一位比较，如果有一个是真，答案就是真，如果都是假，答案就是假。
2. ```&``` ：按位与，将每一位比较，如果都是真，答案就是真，否则就是假。
3. ```^``` ：按位异或，将每一位比较，如果不一样，答案就是真，如果一样，答案就是假。
4. ```<<``` ：左移，将这个串整体往右移，空出的是 0 ，相当于乘 2。
5. ```>>``` ：右移，将这个串整体左移，相当于除 2。



然后是一些高级的操作：

1. 把右数第 $k$ 位变成 1 ：```x = x | ( 1 << ( k - 1 ) )```
2. 把右数第 $k$ 位变成 0 ：```x = x & ! ( 1 << ( k - 1 ) )```
3. 取右数第 $k$ 位：```x = x >> ( k - 1 ) & 1```、

那么就可以写出代码了：

```cpp
for(int i=1;i<=n;i++){
	char k;
	cin>>k;
	int w=n-i+1;
	if(k=='1') f = f | (1 << (w - 1)); //将每一个数字存入
	if(k=='0') f = f | ! (1 << (w - 1));
}
for(int i=1;i<=x;i++){
	if(i!=y) if(f >> (i - 1) & 1) ans++; //进行判定
	if(i==y) if(!(f >> (i - 1) & 1)) ans++;
}
cout<<ans<<endl;
```
但这个方法只能使用 32 位所以在进行小数量极的运算是可以使用。

完整代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[500005];
unsigned long long f;
int main(){
	int n,x,y;
	cin>>n>>x>>y;
	y+=1;
	int ans=0;
	if(n>=32){
		for(int i=1;i<=n;i++){
			char k;
			cin>>k;
			a[n-i+1]=k-'0';
		}
		
		for(int i=1;i<=x;i++){
			if(i!=y) if(a[i]) ans++;
			if(i==y) if(!a[i]) ans++;
		}
		cout<<ans<<endl;
	}
	else{
		for(int i=1;i<=n;i++){
			char k;
			cin>>k;
			int w=n-i+1;
			if(k=='1') f = f | (1 << (w - 1));
			if(k=='0') f = f | ! (1 << (w - 1));
		}
		for(int i=1;i<=x;i++){
			if(i!=y) if(f >> (i - 1) & 1) ans++;
			if(i==y) if(!(f >> (i - 1) & 1)) ans++;
		}
		cout<<ans<<endl;
	}
	return 0;
}
```

