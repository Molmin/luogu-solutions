拿到这道题，不难想到一个 $O(n^4)$ 的做法，即枚举行的上下界，然后对列跑双指针

考虑改进这个做法，我们枚举上边界，然后不断扩展下边界，扩展时对右端点进行扫描线

发现这个做法中我们需要用一个数据结构求出某一列往前最远能够走到哪一列，发现需要用一 $O(n^2)$ 个 `std::set` 求出前驱后继，前驱用来维护当前点的信息，后继用来维护 **后继所在列** 的信息

发现这样可以在 $O(n^3\log n)$ 的时间内解决问题，但还是不够

我们发现如果从上到下枚举上边界，我们做的是删除，而删除相对于插入性质可能更差一些

考虑从下到上枚举上边界

不难发现此时我们扩展上边界时，对于每一行，其能到达的最左端点只会因为我们枚举到的这个上边界而发生变化，因此只需要判断两行之间的关系即可

而且不难发现，由于我们只维护两行的信息，我们可以不使用 `std::set` 而直接使用一个数组来处理前驱后继，而且此时我们只需要处理前驱，可以理解为枚举到某一列时，上文所述的需要的后继就是当前列，然后对应取 $\max$ 即可

由此就利用单调性达到了 $O(n^3)$ 的复杂度，可以通过本题

而且空间做到了 $O(n^2)$

只放关键代码

```cpp
const int MAXN = 4e2 + 5;
int n, m, a[MAXN][MAXN], f[MAXN * MAXN], p[MAXN][MAXN];
signed main(){ int ans = 0;
    read(n, m); rep(i, 1, n) read(a[i] + 1, a[i] + m + 1);
    per(k, n, 1) {
        rep(i, 1, m) { const int x = a[k][i]; p[k][i] = mx(p[k][i - 1], f[x]); chmax(ans, i - p[k][i]); f[x] = i; }
        rep(i, 1, m) f[a[k][i]] = 0; 
        rep(j, k + 1, n) {
            int l = 0; rep(i, 1, m) {
                const int x = a[k][i], y = a[j][i];
                chmax(p[j][i], (x == y)? i : mx(f[x], f[y], p[j - 1][i])); chmax(l, p[j][i]);
                f[x] = f[y] = i; chmax(ans, (j - k + 1) * (i - l));
            }
            rep(i, 1, m) f[a[k][i]] = f[a[j][i]] = 0;
        }
    } print(ans);

}
```