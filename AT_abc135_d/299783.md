#### 题意

给你一个数，有些位置不知道，求多少种可能能够让这个数 $\mod 13$ 结果为 $5$。

#### 思路

我们可以想象一下我们小学时是怎么求余数的。

在我们求除法时，我们会把之前的余数保留，乘 $10$ 后再加上现在位置的数，再除一次。

最后我们计算完后就顺便求出了余数。

因此，我们后面的余数是会受前面余数的限制的。

那我们就保留前面的余数。

考虑 $DP$。

假设 $dp[i][j]$ 表示在第 $j$ 位时余数为 $i$ 的可能个数，则有两种状态转移方程。

第一种，现在不是问号。我们把所有 $dp[i][j-1]$ 枚举一遍，设 $x=dp[i][j-1]*10+s[i]$（$s[i]$ 表示现在的数）。那么 $dp[x][j]+=dp[i][j-1]$。

第二种，现在是问号。只要把上面的 $s[i]$ 改成从 $1$ 到 $9$ 的枚举就好了。

注意最开头的预处理。

上代码：

```
#include<bits/stdc++.h>
const int N=1e5+7,mod=1e9+7;
using namespace std;
int dp[13][N];
int main() {
	string s;
	cin>>s;
	if(s[0]!='?')
		dp[s[0]-'0'][0]=1;
	else
		for(int i=0;i<=9;i++)
			dp[i][0]=1;
	for(int i=1;i<s.size();i++) {
		if(s[i]!='?')
			for(int j=0;j<=12;j++) {
				int x=((s[i]-'0')+j*10)%13;
				dp[x][i]+=dp[j][i-1];
				dp[x][i]%=mod;
			}
		else
			for(int k=0;k<=9;k++)
				for(int j=0;j<=12;j++){
					int x=(k+j*10)%13;
					dp[x][i]+=dp[j][i-1];
					dp[x][i]%=mod;
				}
	}
	printf("%d",dp[5][s.size()-1]);
	return 0;
}
```

完结撒花~