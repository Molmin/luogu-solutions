## 题意
给一个含 `?` 的数，`?` 可以被 $0$ 到 $9$ 替换。   
求每个可能出现的数中，有多少个数除以 $13$ 余数为 $5$。    
输出答案模 $10^9+7$。

## 思路
由于求模这一特殊性，靠前位置的 `?` 会对靠后位置的 `?` 的答案产生影响，但靠后的并不会影响前面的，因此考虑从前往后 DP。 
$dp_{i,j}$ 表示前 $j$ 位确定时，余数为 $i$ 的方案数。    
如何确定遍历至第 $i$ 位为 `?` 时，前 $i$ 位表示的数模 $13$ 的余数？回忆小学数学得知，可由前 $i-1$ 位产生的余数乘 $10$ 加上第 $i$ 位的数再模 $13$ 得出。

首先确定第一个位置。当 $s_0$ 为`?` 时，以 $i$ 枚举 $0$ 到 $9$ 进行填写，$dp_{i,0} = 1$；当 $s_0$ 为确定的数字时，$dp_{s_0,0} = 1$。   
接下来遍历后续字符串。$s_i$ 为确定的数时，以 $j$ 枚举 $0$ 到 $12$ 的余数，那么当前表示的数模 $13$ 的余数为 $(s_i + j \times 10) \bmod 13$，得出式子 $dp_{(s_i + j \times 10) \bmod 13,i} + dp_{j,i-1} $；当 $s_i$ 为 `?` 时，用 $0$ 到 $9$ 枚举替换 $s_i$ 后，重复上述操作即可。   
最后答案即为 $dp_{5,|s|-1}$。

## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const int mx=1e5+1,mod=1e9+7;
int dp[13][mx],len;
string s;
int main() 
{
	cin >> s;
	len=s.length();
	if(s[0]=='?')	for(int i=0;i<=9;i++)	dp[i][0]=1;
	else	dp[s[0]-'0'][0]=1;
	for(int i=1;i<len;i++) 
	{
		if(s[i]!='?')
			for(int j=0;j<=12;j++) 
				dp[((s[i]-'0')+j*10)%13][i]=(dp[((s[i]-'0')+j*10)%13][i]+dp[j][i-1])%mod;
		else
			for(int num=0;num<=9;num++)
				for(int j=0;j<=12;j++)
					dp[(num+j*10)%13][i]=(dp[(num+j*10)%13][i]+dp[j][i-1])%mod;
	}
	cout<<dp[5][len-1];
	return 0;
}
```
