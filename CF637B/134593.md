# 我觉得“栈+bool”会比“队”更方便↓


### 题目描述

有一个队列，初始时为空。现在依次插入n个单词，如果这个单词已经在队列中，那就把这个单词从原来位置移到队首，否则直接把这个单词放到队首。问你最后这个队列长啥样。

### 输入输出格式

#### 输入格式：

第一行，一个整数 n ( 1 ≤ n ≤ 200000 )，表示单词的数量。接下来 n 行，每行一个单词，每个单词都由小写字母构成，非空且长度均不超过 10 。

#### 输出格式：

若干行，每行一个单词，依次表示从队首到队尾的每个单词

~~——————————完美的分界线———————————~~

### 若按照题目机械式思维：
###  先queue，然后每次输入一个人名"a"，在队里扫一遍，if队列中没出现过"a"则在队首插入"a"(注意不是队尾)；if"a"已经在队伍里，则删除"a"，再在队首插入“a”。最后一次性从队首输出到队尾。【中间的判重会影响时间复杂度】

#### 1.由上可以看到，可以把过程分为：①输入，②判重&删除，③插入"a"，④输出；且是按照①②③,①②③,①②③....④,④,④..的顺序执行；

#### 2.然而①的最坏情况是从头扫到尾(O(n))。因为所有的人是从**队首**插入队伍的，而输出也是从头到尾，所以先出来的人后面不可能再出来(被判重删除了)。
#### 3.所以，这个“判重队列”可以用栈(先进先出)来实现，执行顺序为①③,①③,①③...(②:仅查看一项而非从头扫到尾)④，(②)④，(②)④...
#### 下面是代码↓

```cpp
#include<bits/stdc++.h>//万能库
using namespace std;
map<string,bool>ma;//创立一个map容器,用于string"a"的判重。
string a;
stack<string>Tony;//不用队列okk。
int n;
int main()
{
	ios_base::sync_with_stdio(0);
	cin.tie(0);
	cin>>n;
	for(int i=0;i<n;i++)
	{
		cin>>a;//-->①
		Tony.push(a);//-->③
		ma[a]=1;
	}//先不判重，全部进栈进栈。
	for(int i=0;i<n;i++)//边输出边判重
	{
		if(ma[Tony.top()]==0);//-->(②)
		else {cout<<Tony.top()<<endl;ma[Tony.top()]=0;}//-->④
		Tony.pop();
	}
	return 0;
}
```
### 实际上可连栈都不用，只不过是本蒟蒻用惯了栈而非队。
#### 还有——》学习一下容器map，判重很有用！
