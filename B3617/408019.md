## B3617 古籍翻译 題解

简单题意：给定一个八进制数字，求它的十六进制数。

那么我们首先介绍一下**进制和权重**：

### Part 1 进制

我们人类现在最经常的使用十进制。

对于 $k$ 进制：

- 如果 $k \leq 10$，采用的数字为 0 到 $k-1$。
- 如果 $k > 10$，用完 $0-9$ 后，开始用 $A,B,C,D...$。

那么，题目中的八进制和十六进制的定义就如下：

**逢 8 进 1** 的数字为 8 进制，采用 $0,1,2,3,4,5,6,7$ 这 8 个数字。

**逢 16 进 1** 的数字为 16 进制，采用 $0,1,2,3,4,5,6,7,8,9,a,b,c,d,e,f$ 这 16 个符号。

### Part 2 权重

在十进制中：

个位权重是 1，十位权重是 10，百位权重是 100...

$$ (678)_{10} = 6 \times 100 + 7 \times 10 + 8 \times 1 $$

那么如何算出 $k$ 进制数字的 10 进制数字？

我们就可以利用权重算出：

$$ (12341)_5 = 1 \times 5^4 + 2 \times 5^3 + 3 \times 5^2 + 4 \times 5 + 1 = 971 = (971)_{10} $$

看出了什么规律了吗？

***

介绍完了进制和权重后，我们就开始解题。
***

### 0x00 方法1 (cin/cout)

12 分做法：

```cpp
cin>>oct>>a;
cout<<hex<<a<<endl; 
```

C++ 提供了这种便捷的进制转换功能，但很可惜，这道题的数据范围不支持用这种方法。


***
### 0x02 方法2 (long long)

如何实在想不出正确的解法，然后想不出 0x03 的高精度解法，可以进行进制转换（使用 `long long`），可以得到 $40\%$ 的分数。


### 0x03 方法3 (高精度)

将 8 进制转换成 10 进制，然后转为 16 进制。

由于数字很大，需要使用高精度计算，比较繁琐。

### 0x04 方法4 (8-2-16）

这里是对阮行止老师解法的详细补充。

1 个 8 进制数字可以变成 3 位 2 进制数。

|0|1|2|3|4|5|6|7|
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
|000|001|010|011|100|101|110|111|

1 个 16 进制数可以变成 4 位 2 进制数。

| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 |
| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
| 0000 | 0001 | 0010 | 0011 | 0100 | 0101 | 0110 | 0111 |
| 8 | 9 | A | B | C | D | E | F |
| 1000 | 1001 | 1010 | 1011 | 1100 | 1101 | 1110 | 1111 | B & C & D & E & F 

从而 4 位 8进制数可以转为 12 位 2 进制数，从而转成 3 位 16 进制数。


$$
1125 \rightarrow 001001010101 \rightarrow 001001010101 \rightarrow 255
$$

所以从右边取出 4 位 8 进制数，就可以变成 2 位 16 进制数。

可以用 2 进制作为跳板，也可以用 10 进制作为跳板。

有很多种方法，这里使用递归的方式依次 4 位 4 位处理。

```
15 0126 1125
D   056  255
```

注意转成 3 位 16 进制数字，如果不是在开头，要补 0 至 3 位：

|$i$|0|1|2|3|4|5|6|7|8|9|10|
| -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: |
|$S_i$|1|5|0|1|2|6|1|1|2|5|  |
|  |  |  |$low<0$|$low$|-|-|-|$low$|-|-|$len$|


这里对阮行止老师的代码进行了扩充，更简单易懂。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define fore(i,x,n) for(int i=x;i<=n;i++)
const int MAXX=10005;
const int mod=1;
char b[MAXX];
inline int octtoint(int l,int r){
	int n=0;
	fore(i,l,r-1)
		n=n*8+b[i]-'0';
	return n;
}
inline char inttochar(int n){
	if(n<10) return '0'+n;
	return 'a'+n-10;
}
inline int inttohex(int n,int low){
	int a[5]={0},t=0;
	while(n){
		a[t]=n%16;
		n/=16;
		t++;
	}
	for(int i=low!=0?3-1:t-1;i>=0;i--)
		write(inttochar(a[i]));
}
inline work(int len){
	in low=max(0,len-4);
	int n=octtoint(low,len);
	if(low){
		work(low);
		inttohex(n,low);
	}
	else{
		inttohex(n,low);
	}
}
inline int read(){
	int x=0,f=1;char ch=getchar();
	while(!isdigit(ch)){if(ch=='-') f=-1;ch=getchar();}
	while(isdigit(ch)){x=x*10+ch-48;ch=getchar();}
	return x*f;
}
inline void write(int x){
    if(x<0) putchar('-'),x=-x;
    if(x>9) write(x/10);
    putchar(x%10+'0');
}
signed main(){
	cin>>b;
	work(strlen(b));
}
```

### 0x05 其他东西

将一个 `int` 类型数字以 16 进制输出可以这样：

```cpp
printf("%x",n);
```

如果不够，要补前导 0，可以这样：

```cpp
printf("%03x",n);
```




