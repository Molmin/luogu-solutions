### Description

给定 $ n $ 和一个长度为 $ n - 1 $ 的字符串 $ s $。构造一个长度为 $ n $ 的数列 $ a $，使得

1. $ a $ 中 $ 1, 2, ..., n $ 每个数恰好出现一次（$ a $ 是 $1, 2, ..., n $ 的一个排列）

2. 若 $ s_i = \texttt{'<'} $，则 $ a_i < a_{i + 1} $；若 $ s_i = \texttt{'>'} $，则 $ a_i > a_{i + 1} $

3. $ a $ 的 `LIS`（最长上升子序列）长度 **最小** or **最大**

请构造这样的两个排列。

### Solution

不难想到，如果要求 `LIS` 长度最小，我们需要整个数列总体呈下降趋势；如果要求 `LIS` 长度最大，我们需要整个序列总体呈上升趋势。

---

不妨先看 `LIS` 长度最小的情况。我们希望构造一个数列使整体呈下降趋势。

我们发现，如果有 **连续的一段 `'<'`**，则有 **连续一串数将会构成一个上升的子数列**。我们考虑把这样的子数列称之为 “块”。块的大小可以等于 $ 1 $。

不难发现，**一个块中的最后一个数要大于下一个块中的第一个数**。（`'>'`）

~~题目中的样例略弱~~，我们不妨考虑一组新的数据：

**`9 <>>><<><`**

我们考虑让一个块中的数是一些 **连续** 的数组成的上升序列。则我们构造出来的数列会像这样：

![Min](https://cdn.luogu.com.cn/upload/image_hosting/hqknvsn1.png)

（横坐标为下标，纵坐标为该位置的数，这样的坐标图可以清晰地体现大小关系）

其中蓝色的边代表这条边的两个端点在一个块中，红色的边是连接块与块的边。容易发现蓝色的边都是上斜的，这印证了 “块中的数构成了一个上升的序列”；红色的边是下斜的，印证了 “前一个块的数大于后一个块的数”。

我们的构造方式是：从前往后依次处理每一个块，维护一个 **当前未被用过的数的最大值 `now`**，对于这个块，令它的最后一个数为 `now`，前面的数依次递减，使 **块中的数构成一个连续的上升序列**。然后修改 `now` 的值。

这样就可以得到类似上图的构造方式。

### Proof of Min LIS

不难发现，`LIS` 的长度最小值一定 $ \geqslant $ 最大的块长度，因为一个块中的数必定构成 `LIS`。

在这种构造方式下，**前面的块中的任何数必定大于后面的块中的任何数**。所以 `LIS` 不可能同时包含两个块中的数，只能在同一个块中选取。证毕。

---

接下来看 `LIS` 长度最大的情况。其实基本同理。

这次我们令连续的一段 `'>'` 为一个 “块”。与上文正好相反，这次 **一个块中的数构成一个下降的子数列**。**一个块的最后一个数小于下一个块的第一个数**。

还是考虑让一个块中的数构成连续的一串数。对于上文的那组数据，我们的构造会像这样：

![Max](https://cdn.luogu.com.cn/upload/image_hosting/zpeercdv.png)

蓝边与红边的意义与上文类似，这里不再赘述。

构造方式其实也大同小异，**维护当前未被使用过的数的最小值 `now`**，对于当前块，令它的最后一个数为 `now`，前面的数依次递增，这样使得 **一个块中的数构成一个连续的下降序列**。再更改 `now` 的值即可。

### Proof of Max LIS

令数列中的块数为 $ k $（$ k $ 事实上是一个由输入字符串确定的定值，如果有疑惑，请参看上文 “块” 的定义）。因为一个块中的数递减，所以 **`LIS` 中不可能有两个数位于同一个块中**，`LIS` 长度最大值 $ \leqslant k $。

在这种构造方式下，**前面的块的任何数必定小于后面的块的任何数**。所以一定可以在每个块中取出一个数构成 `LIS`。证毕。

两种情况的时间复杂度都是 $ O(n) $。

---

虽然这是 Div. 2 的 D 题，但其实并没有那么复杂~~与玄学~~。其实上文的构造方式也是一个比较好理解的想法，只是笔者水平有限，语言描述略微有些冗余。所以可以通过看上面的两张图来帮助理解。

最小值和最大值的构造几乎是完全对称的，许多性质也惊人的相似。也许，这就是 OI 中的对称之美吧。OIer 们平时在切题的时候，也可以用到许多对称的性质，方便做题。

---

### Code

代码实现中，是在直接枚举每一个下标的过程中顺便找块的。中间的在块中填数运用了一次函数的性质（点斜式 233）。

```cpp
#include <bits/stdc++.h>
using namespace std;
int main()
{
	int t;
	scanf("%d", &t);
	while(t--)
	{
		int n;
		scanf("%d", &n);
		string s;
		cin >> s;
		s = " " + s;
		int now = n, p = 1;
		while(p <= n)
		{
			int tmp = p;
			while(s[p] == '<' && p < n)
				p++;
			for(int i = tmp; i <= p; i++)
				printf("%d ", i - (p - now));
			now = tmp - (p - now) - 1;
			p++;
		}
		putchar('\n');
		now = 1;
		p = 1;
		while(p <= n)
		{
			int tmp = p;
			while(s[p] == '>' && p < n)
				p++;
			for(int i = tmp; i <= p; i++)
				printf("%d ", p + now - i);
			now = p + now - tmp + 1;
			p++;
		}
		putchar('\n');
	}
	return 0;
}
```