[更好的阅读体验](https://reclouds.github.io/post/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91P5319%20BJOI2019%20%E5%A5%A5%E6%9C%AF%E7%A5%9E%E6%9D%96%20%E9%A2%98%E8%A7%A3.html)

### 题意

给定一个长为 $n$ 的字符串 $S$，其每一位为数字 $0\sim 9$ 或一个 $.$ 符号，后者表示该位可以为任何数字。

再给定 $m$ 个字符串 $T_i$，每个字符串有其对应的权值 $V_i$。

初始时有变量 $\mathcal{Magic} = 1, \mathcal{Count} = 0$。

每当 $T_i$ 在 $S$ 中出现一次（即不同位置出现算作多次），我们就将 $\mathcal{Magic}$ 乘上 $V_i$ ，将 $\mathcal{Count}$ 加 $1$。

最终的答案为 $\mathcal{Answer} = \sqrt[\mathcal{Count}]{\mathcal{Magic}}$。

要求找到一种填充字符串 $.$ 位置的方案，使得 $\mathcal{Answer}$ 最大，输出任意一种最终字符串即可。

$\mathcal{Data~Range}: 1 \le n, m \le 1501, 1 \le V_i \le 10^9, 1 \le \displaystyle{\sum_{i = 1}^m} |T_i| \le 1501$

------

### 题解

~~（你真的会高精度开任意次方根吗？）~~

所以这题显然不能直接做。

和乘积有关的题目，一个好的思路是化乘为加。所以我们把每个 $V_i$ 求 $\ln$，就可以把 $\mathcal{Magic}$ 由求积转化为求和了，并且这样的转化并不会影响答案之间的大小关系。

而 $\mathcal{Count}$ 次方根这个部分，可以发现它直接变成了 $\displaystyle \frac{1}{\mathcal{Count}}$，所以原式就化为了 $\displaystyle \frac{\mathcal{Magic}}{\mathcal{Count}}$。

我们再重新审视一遍 $\mathcal{Magic}$ 和 $\mathcal{Count}$：每次当前者加上一个 $V_i$ 时，后者就会伴随着加上一个 $1$，而又因为两者的贡献是呈分数形式的，所以算法的大致轮廓大致就出来了 —— $0/1$ 分数规划。

我们知道，$0/1$ 分数规划关于 “解的存在性” 具有单调性。所以，我们可以考虑二分一个答案 $mid$，那么有：
$$
\begin{matrix}
\dfrac{\displaystyle{\sum_{i = 1}^{\mathcal{Count}} V_i}}{\mathcal{Count}} > mid
\\
\displaystyle{\sum_{i = 1}^{\mathcal{Count}}} V_i > {\mathcal{Count}} * mid
\\
\displaystyle{\sum_{i = 1}^{\mathcal{Count}}} (V_i - mid) > 0
\end{matrix}
$$

（注意到大于号 $>$ 了吗？这里并非大于等于号 $\ge$，因为当贡献最大值为 $0$ 时，二分到的 $mid$ 并非一个可行答案。当然，也会存在 $\mathcal{Answer}$ 为 $0$ 的情况，此时任意一个合法的字符串均为答案。）

推导到这里，可以发现，只要给每一个权值减去一个 $mid$，那么这个式子的值和 $\mathcal{Count}$ 的具体值已经没有关系了。

剩下的部分，就是求出左侧式子的最大值，然后和 $0$ 比较了。

而我们要如何求这个最大值呢？可以发现它和普通的 $0/1$ 分数规划不太一样：每个位置是 $0$ 还是 $1$ 并不能自由决定。

我们再重新审视一遍这个问题：填充 $S$ 的所有 $.$ 字符，使得出现的所有 $T_i$ 的权值和最大。

这个问题显然涉及到了字符串的多模匹配问题，因此我们考虑用 $\operatorname{AC}$ 自动机来解决这个问题。

我们可以设状态 $f_{i, j}$，表示走到自动机的 $i$ 号节点，同时 $S$ 串已经填完第 $j$ 个字符的最大权值。

转移很简单，由于自动机具有优美的结构，因此我们仅需每次枚举下一个字符进行转移即可。

（注意由于我们需要输出最终字符串，因此转移时需要记录前驱状态和转移时枚举的字符。）

最后一个问题来了：如何处理自动机上每个点的贡献？

显然，对于一个点，如果它对应了一个 $T_i$，那么在 $\mathcal{Fail}$ 树中以它为根的子树都需要加上他的权值（因为都会匹配到这个串）。所以，对于每一个 $mid$，我们利用树上差分重构一遍自动机上每个点的贡献即可。
