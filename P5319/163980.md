拿到这个题，不难有一个在$AC$自动机上做$dp$的思路。

本题$n,m,|S|$同阶，故讨论复杂度时都用$n$代替。

$dp[i][j][k]$代表dp进行到自动机上i这个点，做了$j$个字符的$dp$，其中有$k$个咒语的$Magic$最大值，复杂度O($n ^ 3$)。

不过这个做法，最大的问题就是$Magic$是一个高精度数，你要是用高精度来做的话，还得多一个$FFT$的复杂度，O($n ^ 4logn$)，沦为与爆搜同分。

我们考虑一下平常这种dp为什么不会有这个问题。

这个题需要高精度的原因，就在于我们以前遇见的是加，这个是乘，那如何把乘法转化成加法呢？

这个时候不难想到需要用到取$\log$，我们依旧刚才的思路，还是那么$dp$，此时估计能获得$80$分。但实际上因为还有字符集的$10$倍的常数，需要卡常能力。对于这种$dp$题，优秀的循环展开不难卡个几倍的常数。

对于正解，我们不难发现，其实我们刚才求的问题就是选几个数，使得他们的平均数最大。

对于求平均数的问题，我们可以直接二分这个平均数，以此转化成一个判定性问题。

具体的实现你把所有咒语的权值取$\log$后都减去这个$mid$，然后做一遍$dp$，看是否答案$>0$，然后过程中记录一下转移过程，最后输出转移路径即可。

过程需要用$double$，复杂度是O($n ^ 2logn$)，实际上估计会跑得比较慢，需要一定的卡常，比如一些点不用跑就不跑，循环展开一下。

开始的时候，我一直感觉这个优化思路和某种我学过的算法有相似之处，看到粉兔的题解才想到是$01$分数规划，$orz$一波。