# SP237 SUMITR - Sums in a Triangle 题解

#### 重点：$dp$，递推
------------
**如果你在看到这篇题解时发现还没有翻译，请点击**[这里](https://hgjgb.blog.luogu.org/sp237-fan-yi)

**本人翻译的，保证正确**

**现在已经在审核了**

------------
了解题意后请往下看：

一道经典的 dp 题——数字金字塔。

这里我们可以先将整个大问题**分**成一些小问题，这也就是 dp 的思想：**分**

现在我们只考虑整个路程中的最后一步：**向左还是向右？**

- 向左：
	
    把最后到达的位置设为 $dp[\;i\;][\;j\;]$
   
   那么前一步就是 $dp[\;i-1\;][\;j\;]$。
- 向右：
	
    把最后到达的位置设为 $dp[\;i\;][\;j\;]$
   
   那么前一步就是 $dp[\;i-1\;][\;j-1\;]$。
  
  
由此可见，点 $dp_{i\;j}$ $=$ 点 $dp_{i-1\;j}$ $-$ 点 $dp_{i-1\;j-1}$。 

所以我们可以列出递推方程式：

$dp[\;i\;][\;j\;]=max(dp[\;i-1\;][\;j \;] , dp[ \;i-1\; ][ \;j-1\; ])+a[\;i\;][\;j\;]$

找到了方程式，这道题做起来就很容易了。

以下是递推的代码部分。
```cpp
dp[1][1]=a[1][1];
for(int i=2;i<=n;i++){
	for(int j=1;j<=i;j++){
		dp[i][j]=max(dp[i-1][j-1],dp[i-1][j])+a[i][j];
	}
}
```

最后我们可以在这个三角形的底部搜一圈，哪个最大，答案就是哪个。

```cpp
int ans=0;
for(int i=1;i<=n;i++){
	ans=max(ans,dp[n][i]);
}
printf("%d",ans);
```
其实代码总体来说很简单，完整代码就不给了。