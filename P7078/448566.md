思路：
```cpp
对于只有3条蛇，不难相等，最大蛇吃了最小蛇后，要么还是最大，要么是最小；如果是最大，肯定继续吃，答案为1；如果是最小，肯定不吃，因为吃了肯定被吃，所以答案是3。 这个结论，推广到n，就是最大蛇吃了最小蛇后，如果不是最小，肯定吃，因为下一次“次大蛇”吃“次小蛇”，还是a-b，只是a变小、b变大，最终肯定更小，需要考虑吃不吃的是下一条蛇，而不是自己。如果是最小，那么看一下下一条蛇吃完是不是最小，如果不是，自己肯定被吃，所以自己变最小肯定不吃！如果一直都是最小，那么一直执行下去，直到2条蛇为止，规模足够小，可以下结论！ 对于一直吃下去的情况，第1条蛇出现最小、第2条蛇吃完还是最小、第3条蛇吃完还是最小……第k条蛇是最小，第k+1条蛇终于不是最小，此时k发现自己不能吃，那么k-1发现自己可以吃，k-2发现自己不能吃……也就是k是偶数的时候，偶数都不吃，奇数都吃，第一条蛇会吃，即在最初情况下多吃1条蛇。最初情况，即当前蛇的数量加上连续多少条蛇吃完成为最小。 暴力做法：插入排序维护蛇的单调性，可以用二分、内存操作优化一下，有可能骗到70分； 堆做法：可以是两个对，每次取出最小和最大蛇，log可过几十万的数据。 对于100万的数据，必须用单调队列优化：容易看出，每次吃完，总数比上一次吃完的蛇小，所以新增一个队列，依次存储新蛇。如果新蛇是最小的，有可能破坏单调性，但此时已出结论，不需要再维护了。

```
# 代码
![](http://www.oier.cc/wp-content/uploads/2020/11/P7078%E8%B4%AA%E5%90%83%E8%9B%87%E6%9A%B4%E5%8A%9B.png)