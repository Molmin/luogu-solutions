显然，这道题可以用 DP 来解决。我们设计状态 $f(i,j)$ 表示对于前 $i$ 个人分成 $j$ 段能产生的最大总人数值。

显然，我们应该先将整个区间排序。接下来考虑如何进行状态转移，对于每一个点 $i$，我们考虑它能否入选队伍，如果不能入选，那么 $f(i,j)=f(i-1,j)$；如果能入选队伍，我们用一个变量来找到这队的第一个人，在寻找队首的过程中判断是否满足题目要求，即实力最大值与最小值的差即极差小于等于 $5$。如果能入选，假设找到的队首为 $p$，那么对最终结果产生的贡献为 $i-p$，于是乎我们就可以列出状态转移方程：$f(i.j)=\max(f(i-1,j),f(p,j-1)+(i-p))$，初始化 $f(1,1)=1$。

统计答案时不断更新最大值即可。整道题的时间复杂度为 $O(nk)$。

核心代码如下：

```cpp
  sort(a+1,a+n+1);
  f[1][1]=1;
  for(int i=1;i<=n;i++)
  {
      int p=i;
      while(p>=1&&a[i]-a[p]<=5) p--;
      for(int j=1;j<=k;j++) f[i][j]=max(f[i-1][j],f[p][j-1]+i-p);
  }
  int ans=-0x7f;
  for(int i=1;i<=n;i++) ans=max(ans,f[i][k]);
```