# 题意简述：

给定一个长度为 $N$ 的数字，Raze只能选择奇数位上的数标记， Breach只能选择偶数位上的数标记，这样依次轮流标记，Raze先开始，最后剩下的数是奇数，Raze获胜，反之亦然，两人都按照最优策略进行游戏，问哪一方会获胜。

# Solution：

两人都按照最优策略，所以两人一定会减少自己所能标记的，对自己不利的数的个数。

Raze一定会先标记奇数位的偶数。Breath一定会先标记偶数位的奇数。

在这个策略下，统计数字串中奇数位上的奇数个数 $s1$ 和偶数位上的偶数个数 $s2$ ，判断即可。

如果 $N$ 为奇数，则最后剩下的一定是奇数位上的某个数，判断奇数位上是否存在奇数，即 $s1$ 是否大于等于 $1$ 即可，如果存在，那么Raze必胜。

如果 $N$ 为偶数，则最后剩下的一定是偶数位上的某个数，判断偶数位上是否存在偶数，即 $s2$ 是否大于等于 $1$ 即可，如果存在，那么Breath必胜。

时间复杂度 $O(TN)$。

下面是我的代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
char a[2005];
int n,t,s1,s2; 
int main()
{
    scanf("%d",&t);
    while(t--)
    {
    	scanf("%d",&n);
    	scanf("%s",a+1);
    	s1=0;
    	s2=0;
    	for(int i=1;i<=n;i++)
    	{
    		if(i%2==1)
    		{
    			if(int(a[i]-'0')%2==1) s1++;
			}
			else
			{
				if(int(a[i]-'0')%2==0) s2++;
			}
		}
		if(n%2==0)
		{
			if(s2>=1) printf("2\n");
			else printf("1\n");
		}
		else
		{
			if(s1>=1) printf("1\n");
			else printf("2\n");
		}
	}
    return 0;
} 
```


