这道题在比赛时算是简单的一种题了，坑也不多，思路也非常好想。

题意就先不说了，翻译已经很清楚了。

这道题的重点就是如何避免暴力枚举，因为对于这道题来说数据范围虽说不是很大，但如果每次查询第 $k$ 大的值也是肯定 TLE 无疑的。

但由于题目条件很特殊，所以根本不用去一个一个排序。

为什么呢？首先，序列里非 $0$ 即 $1$，并且操作只有两个：分别是修改和查询第 $k$ 个最大值

修改很简单，时间复杂度 $O(1)$，但如何将查询的时间复杂度也降到 $O(1)$ 呢？

又有只有 $0$ 和 $1$,所以第 $k$ 个最大值肯定也是 $1$ 或 $0$。

所以只要随时统计与更新目前 $0$ 和 $1$ 的个数就行了。

也就是当 $1$ 的个数大于等于 $k$ 时，就输出 $1$, 否则就输出 $0$。

### 赛时代码（本人AC）

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
int c0, c1, a[100005];
int main(){
 
    int n, k;
    cin >> n >> k;
    for(int i = 1; i <= n; i++) {
    	cin >> a[i];
    	if(a[i] == 1) c1++;
    	else c0++; //统计01个数 
	}
	while(k--){
		int t, x;
		cin >> t >> x;
		if(t == 1){ //如果为1，那么将0变1,1变0，相应的计数器也更新 
			if(a[x] == 1) c1--, c0++, a[x] = 0; 
			else c1++, c0--, a[x] = 1;
		} 
		else{ //如果为2,1计数器大于等于k（我变量名写的x） 的话就输出1，否则输出0 
			if(c1 >= x) cout << 1 << endl;
			else cout << 0 << endl;
		}
	}
	return 0;
}
//在昨天的CF比赛上亲测AC 
```
