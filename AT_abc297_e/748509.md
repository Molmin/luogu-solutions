## 题目描述

有 $N$ 种物品，第 $i$ 种物品的价格为 $A_i$，每种物品有无限个。

现在要选择一些物品，每种物品可以不选或选若干个。问如果这样选择总价格第 $K$ 小是多少。

## 样例输入输出

```input1
4 6
20 25 30 100
```

```output1
50
```

前 $6$ 小的价格分别是 $20,\ 25,\ 30,\ 40,\ 45,\ 50$。

## 数据范围

$1 \le N \le 10,\ 1 \le K \le 2 \times 10^5,\ 1 \le A_i \le 10^9$

## 分析

从样例入手。

最开始每种物品的价格分别是 $20\ 25\ 30\ 100$。

加下来我们会在这个序列中每次取出最小值删掉，并在数列中加上这个最小值与所有原价格的搭配。那么取得第 $K$ 次就是最终答案。

首先取出最小值 $20$，再在数列中加入 $20+20\ ,25+20,\ 30+20\ ,100+20$，那么此时这个数列就变成：$25,\ 30,\ 100,\ 40,\ 45,\ 50,\ 120$。

继续操作，再次取出最小值 $25$，并在数列中加入 $20+25,\ 25+25,\ 30+25,\ 100+25$，那么此时这个数列就变成：$30,\ 100,\ 40,\ 45,\ 50,\ 120,\ 45,\ 50,\ 55,\ 125$。由于题目要求重复只计算一次，所以要把重复元素去掉。即 $30,\ 100,\ 40,\ 45,\ 50,\ 120,\ 55,\ 125$

这样重复 $K$ 次，第 $K$ 次取出的元素就是答案。

推广到一般情况，这个问题该如何实现呢？

由于上述操作中存在 `取最小值` 和 `去重` 的操作，那么我们可以直接定义集合 `set` 存储数据，每次取出集合最小值并依次插入，根据上述操作执行即可。

## 代码

```cpp
#include <iostream>
#include <set>

using namespace std;

typedef long long LL;

int n, k, a[12];
LL t;			// t 表示当前集合中的最小值 
set<LL> s;		// 存储价格的集合 

int main()
{
	// 读入 
	cin >> n >> k;
	
	for (int i = 1; i <= n; i ++ )
	{
		cin >> a[i];
		s.insert(a[i]);		// 初始化集合，将所有价格加入 
	}
	
	while (k -- )		// k 次操作，第 k 次得到的最小值就是最终答案 
	{
		t = *s.begin();		// 取当前最小值 
		s.erase(t);			// 删除 
		// 插入 t 与所有原价格的搭配
		for (int i = 1; i <= n; i ++ )
		{
			s.insert(t + a[i]);
		}
	}
	
	cout << t;		// 输出答案 
	
	return 0;
}
```