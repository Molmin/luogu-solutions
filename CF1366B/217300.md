### 思路

我们先举一个简单的例子：

$\{a_n\}=\{1,0,0,0,0,0\},l=2,r=4$

对于这次交换，交换后只有 $a_1$ 可能是 $1$ 。

$\{a_n\}=\{?,?,?,0,0,0\},l=4,r=6$( $?$ 表示可能是 $1$ )

对于这次交换，交换后只有 $a_1,a_2,a_3$ 可能是 $1$ 

由这一类例子可以推导出的是：**对于任意的 $l,r$，当 $[ l , r ]$ 之间交换之前没有可能是 $1$ 的数的时候，这个区间里面交换之后也没有可能有是 $1$ 的数。**

------------

我们再举一个简单的例子：

$\{a_n\}=\{1,0,0,0,0,0\},l=1,r=4$ 。

对于这次交换，交换后 $a_1$ 到 $a_4$ 都可能是 $1$ 。

$\{a_n\}=\{0,0,0,?,?,?\},l=1,r=4$ 。

对于这次交换，交换后 $a_1$ 到 $a_6$ 都可能是 $1$ 。

由这一类例子可以推导出的是：**对于任意的 $l,r$，当 $[ l , r ]$ 之间交换之前有可能是 $1$ 的数的时候，这个区间里面交换之后全部的数都可能为 $1$ 。**

----------

综上所述:**对于任意的 $l,r$，当且仅当在交换之前$[l,r]$之间有可能是 $1$ 的数时，这个区间里的所有数在交换后有可能为 $1$ 。**

我们的第一版代码就这么出来了。用$\Theta(r-l+1)$扫一遍判断是否可能有 $1$ ,如果有，就把这个区间全部赋成 $1$ 。

我们一看数据大小：$1\le n \le 10^9$,极端情况总时间复杂度$\Theta(nmt)$，直接炸裂！

那么有没有更快的办法呢？

一看，**开始只有 ${a_x=1}$** ,换言之，所有的可能为 $1$ 的数字都在一个连续的区间中，并且这个区间是由$[x,x]$扩展而来的！

只需要扩展区间，问题就解决了。

### 代码

```cpp
#include<iostream>
#include<algorithm>
#include<stdio.h>
using namespace std;
int t,n,x,m,xi,yi,fr,to;//前四个如题,xi->l,yi->r,fr->区间左端,to->区间右端。
int main(){
    scanf("%d",&t);//有多组数据
    while(t--){
        scanf("%d%d%d",&n,&x,&m),fr=to=x;//输入，初始区间为[x,x]。
        for(int i=1;i<=m;i++){//对于每一次扩展。
            scanf("%d%d",&xi,&yi);//输入。
            if((not(xi>to) and (not(yi<fr))))如果这次输入的区间与可能有1的区间有重合部分。
                fr=min(fr,xi),to=max(to,yi);那么这次输入的区间里面的数字都可能是1。
        }
        printf("%d\n",to-fr+1);//区间大小就是元素个数
    }
}
```