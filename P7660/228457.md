## 1. 编程思路。

设从矩阵的最底行向最顶行的行号为 $1$ 至 $n$，则贪吃蛇在奇数行时，面向右，只能从左端走到右端；在偶数行时，面向左，只能从右端走向左端。因此，贪吃蛇从矩阵的最左下角（行号为 $1$，列号也为 $1$）开始，按如下的行走路线肯定可以吃光矩阵中的所有苹果：

在奇数行从最左端（行号为 $1$）用操作 A 一直走到最右端（行号为 $m$），之后用操作 B 向上到达偶数行；

在偶数行从最右端（行号为 $m$）用操作 A 一直走到最左端（行号为 $1$），之后再用操作 B 向上到达奇数行；

交替执行上面的过程，直到上面的行中不再有苹果。

为了使贪吃蛇吃掉所有苹果的操作数最少，显然在每行使用操作 B 进行向上转向的时机就非常重要了。

设 $S_{i,0}$ 表示第 $i$ 行最左端苹果出现的列号，$S_{i,1}$ 表示第 $i$ 行最右端苹果出现的列号。

显然，如果 $i$ 是奇数，贪吃蛇从 $S_{i,0}$ 列走到 $S_{i,1}$ 就可以吃完第 $i$ 行的所有苹果，吃完后设它停在 $S_{i,1}$  列，将这个停止位不妨记为 $pos$；同样的，如果 $i$ 是偶数，贪吃蛇从 $S_{i,1}$ 列走到 $S_{i,0}$ 就可以吃完第 $i$ 行的所有苹果，吃完后设它停在 $S_{i,0}$  列。这样，贪吃蛇用操作 A 吃完每行的苹果的次数肯定是最少的。

但执行操作 B 向上时，跳到下一行的列位置是前一行的停止位置 $pos$，如果这个 $pos$ 位置在 $S_{i,0}$ 列到 $S_{i,1}$ 列之间，则贪吃蛇是无法吃完下一行的所有苹果的，因为它处于中间，只能吃一端的苹果，无法吃另一端的苹果。因此需要在上一行对停止的位置进行最小限度的校正，以达到可以吃完下一行所有苹果的目的。校正的方法如下：

如果贪吃蛇上一行是停在奇数行 $i-1$ 的 $pos$ 列，下一行是偶数行 $i$，若 $pos\ge S_{i,1}$，则无需校正，若 $pos<S_{i,1}$，则上一行多走 $S_{i,1}-pos$ 步，使得上一行的停止位在 $S_{i,1}$ 处，这样用操作 B 向上后正好可以吃完下一偶数行的所有苹果；

如果贪吃蛇上一行是停在偶数行 $i-1$ 的 $pos$ 列，下一行是奇数行 $i$，若 $pos\le S_{i,0}$，则无需校正，若 $pos>S_{i,0}$，则上一行多走 $pos-S_{i,1}$ 步，使得上一行的停止位在 $S_{i,0}$ 处，这样用操作 B 向上后正好可以吃完下一奇数行的所有苹果。

为此，在输入矩阵信息时进行预处理，将每行最左端苹果的列号和最右端苹果的列号保存到二维数组 $S$ 中，数组元素 $S[i][0]$ 保存第 $i$ 行最左端苹果的列号，$S[i][1]$ 保存第 $i$ 行最右端苹果的列号。若某行中没有苹果，则数组元素 $S[i][0]$ 和 $S[i][1]$ 的值均为 $0$。

## 2. 源程序。

```c
#include <stdio.h>
#include <string.h>
int main()
{
    int n,m;
	scanf("%d%d",&n,&m);
	int i,j;
	int maxl=0;     // 从上往下看，第1次有苹果出现的行号maxl
    int s[1005][2]={0};
	for (i=n;i>=1;i--)
    {
		char str[1005];
        scanf("%s",str+1);
		for (j=1;j<=m;j++)
		{
			if (str[j]=='J' || str[j]=='Z')
            {
                if (maxl==0)  maxl=i;
                if (s[i][0]==0) s[i][0]=j;   // 每行最左端苹果的位置
                if (s[i][1]<j)  s[i][1]=j;   // 每行最右端苹果的位置
            }
		}
    }
    int ans=-1,pos=1;
    for (i=1;i<=maxl;i++)   // 从最底行向上逐行处理到最上面有苹果出现的一行
    {
        ans++;      // 2操作，从下一行到本行
        if (s[i][1]==0)   // 本行没有苹果，默认不处理
            continue;
        if (i%2)    // 奇数行面向右，从最左端s[i][0]走向最右端s[i][1]
        {
            if (pos>s[i][0])       // 上一行最后停的位置没有达到最左端
            {
                ans+=pos-s[i][0];  // 上一行补走到本行最左端的对齐位置
                pos=s[i][0];
            }
            ans+=s[i][1]-pos;
            pos=s[i][1];          // 本行的停止位置在最右端
        }
        else        // 偶数行面向左，从最右端s[i][1]走向最左端s[i][0]
        {
            if (pos<s[i][1])       // 上一行最后停的位置没有达到最右端
            {
                ans+=s[i][1]-pos;  // 上一行补走到本行最右端的对齐位置
                pos=s[i][1];
            }
            ans+=pos-s[i][0];
            pos=s[i][0];          // 本行的停止位置在最左端
        }
    }
    printf("%d\n",ans);
	return 0;
}

```






