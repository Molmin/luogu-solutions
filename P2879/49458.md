首先，题目条件里面很麻烦的一点是它要求(a,b)里面b>=a，而目前的种种模型里面对此并没有合适的建模。

但是，仔细思考就会发现，这个条件并不会影响答案。

如果b<a的话，说明一定有一个数c，使得b<c<=a，否则由于题目要求最大，可以将b调整到b=a而不影响题意。

然后我们对c的位置进行分类讨论

1. c在(a,b)上
2. c在ab外，离b较近
3. c在ab外，离a较近

可以看出，第一种情况肯定不成立，因为要求(a,b)中每一个数x都满足x<a<=b，因此必有x<b。

第二种情况，如果c与ab无关，那么就可以将b调整到b=a，所以必然存在一个关系使得b<c。同时要满足c<=a，由于不存在区间交错的情况（证明略），只能是因为存在一个关系(c,x)，其中x位于(a,b)中或a上。

这里就会有x>=b，然而b>=a>=x，所以唯一可能的关系只有a=b=x。

第三种情况，证明略。

因此，b>=a条件并不会影响答案，可以开心愉快地套模板了。

## 方案1：线段树建边+拓扑排序

由于这里给的是偏序关系，因此可以考虑拓扑排序（拓扑排序=差分约束系统+单边权图中BFS求最短路）

然而，直接建边是$\Theta(RN)$的，肯定会炸，这时候就要考虑线段树建边。

具体不阐述，代码没有，时间复杂度$\Theta((R+N)logN)$

## 方案2：朴素暴力算法

我们每次考虑一个关系。

对于一个数组A和一个关系(a,b)，如果A满足在其之前的所有关系R'，可以通过操作使A满足(a,b)同时不破坏R'

稍微想想就能知道，如果要插入一个新关系，那么只需要将(a,b)中间的数都-1，且最小-1。

证明略。

再考虑到我们需要R次区间减，所以可以直接上差分数组，$\Theta(R+N)$解决问题。再加上map判重，$\Theta(RlogR+N)$

代码：

```cpp
#include <map>
#include <cstdio>
#include <algorithm>
using namespace std;

int loi[10005];

map<int,map<int,bool> > mmp;

int main()
{
	int n,i,h,r;
	scanf("%d%d%d%d",&n,&i,&h,&r);
	for(int i=1; i<=r; ++i)
	{
		int a,b;
		scanf("%d%d",&a,&b);
		if(a>b)
		{
			swap(a,b);
		}

		if(!mmp[a][b])
		{
			mmp[a][b] = 1;
			--loi[a+1];
			++loi[b];
		}
	}

	int cur = 0;
	for(int i=1; i<=n; ++i)
	{
		cur += loi[i];
		printf("%d\n",h+cur);
	}
}
```