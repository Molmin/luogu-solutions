# [[ABC270D] Stones](https://www.luogu.com.cn/problem/AT_abc270_d) 题解

## 前言

作者原先在做这道题时，一直不理解**贪心**为什么错，且别的题解里没有详细说明。本篇题解主要对这一部分作一个补充。

## 题目大意

- 有 $N(1 \leq N \leq 10 ^ 4)$ 块石子，每次可以从中取 $ A_i (1 = A_1 < A_2 < \dots < A_K \leq N) $ 块石子。
- 有两个人以**最优策略**（最大化自己取的石子数量）取石子，求先手取走的石子数量。

## 解题思路

容易想到 $\text{DP}$。

设 $dp_i$ 表示当前石子数量为 $i$ 时，先手最多可以取的石子数量。

转移时类似**背包**的思想，枚举所有可取的石子数量 $a_k$，则前一次取时的先手最多取 $dp_{i - a_k}$ 块石子，易得 $dp_i = \max \{i - dp_{i - a_k}\}$。

**AC Code**

```cpp
#include <bits/stdc++.h>
using namespace std;
int n, k, a[10010], dp[10010];
signed main() {
	cin >> n >> k;
	for (int i = 1; i <= k; ++ i) cin >> a[i];
	for (int i = 1; i <= n; ++ i)
		for (int j = 1; j <= k; ++ j) {
			if (i < a[j]) break;
			dp[i] = max(dp[i], i - dp[i - a[j]]);
		}
	printf("%d\n", dp[n]);
	return 0;
}
```

再来说下**贪心**为什么不行。

我们可以把这个问题想成为什么**背包**不能用**贪心**实现。

比如在**完全背包**中，有读入样例如（数据格式与题目相同）：

```
12 4
1 3 4 5
```

**贪心**求得答案为 $5 + 5 + 1 = 11$，而**背包**答案可以是 $4 + 4 + 4 = 12$（不唯一）。**贪心**就错在取完后有剩余。

在本题中，这个样例用**贪心**答案为 $5 + 1 = 6$，即先手先取 $5$，后手取 $5$，先手再取 $1$。

但实际上，先手可以先取 $4$，后手取 $5$，先手再取 $3$。此时，答案为 $4 + 3 = 7$。而 $7 > 6$。

因此，此题无法用**贪心**实现。