**吐槽**

看这个题提交率较少，于是写`AC`后看了眼题解，发现题解的 @[柳逸君](https://www.luogu.com.cn/user/105124) 的代码是一个 $O\left(n^2\right)$，但是明显可以优化。

好了，下面步入正轨。

--------

## 第一步 读题

简化一下，就是：

> 给定 $n$ 天火星元的市值（可以认为是买股票），然后你有 $b$ 元的火星元，你可以在某一天买进（股票）并在某一天卖出，此操作只能进行一次，请问你最后最多有多少火星元。

## 第二步，思路

思路一：即@[柳逸君](https://www.luogu.com.cn/user/105124)的思路，直接简单地枚举购进时间和卖出时间。时间复杂度 $O(n^2)$。

思路二：即本蒟蒻的思路。我们发现要使得最后收益最大就是使得卖出与买进的价钱差距尽可能大，但是如果差距相等的时候就需要特判。**所以我们可以考虑前后缀和的思路。用一个数组的第 $i$ 个位置来保存 $1-i$ 的最小值，即期望的卖出最小值。用另一个数组的第 $i$ 个位置保存 $i-n$ 的最大值。**最后来一个一个地判断。如果没看明白请看代码。

## 第三步 代码

思路一的代码我就不贴了，请直接参考@[柳逸君](https://www.luogu.com.cn/user/105124)的代码。

思路二的代码（加注释）在这里：
```
#include<bits/stdc++.h>//万能头文件，洛谷不让加太多预编译指令
using namespace std;
inline int read(){//读入优化，初级快速读入
	int ans=0,flag=1;//ans保存最后的结果，flag保存正负，1为正，0为负。由于此题没有负数，所以可以省略此步骤。
	char ch=getchar();
	while((ch>'9'||ch<'0')&&ch!='-') ch=getchar();
	if(ch=='-') flag=-1,ch=getchar();
	while(ch>='0'&&ch<='9'){
		ans=(ans<<1)+(ans<<3)+(ch^'0');//ans<<1=ans*2，ans<<3=ans*8，ans<<k=ans*2^k，即增加这一位。ch^'0'可以理解为ch-'0'。
		ch=getchar();
	}
	return ans*flag;//负号特判
}
int n,b,q[2005],h[2005],p[2005],maxn,ans;//n,b，p为读入数据，q存储前缀最小值（即购买时间），h存储后缀最大值（即卖出时间）
int main(){
	n=read(),b=read();//读入不解释
	for(int i=1;i<=n;i++) p[i]=read();
	for(int i=0;i<=n;i++) q[i]=2005;//只要初始一个比2000大的数就可以了，因为加钱上线是2000。注意：要从0开始，否则你要特判
	for(int i=1;i<=n;i++) q[i]=min(p[i],q[i-1]);//前缀最小值，不会的同学可以去百度前缀和
	for(int i=n;i>=1;i--) h[i]=max(p[i],h[i+1]);//后缀最大值，会了前缀和应该就会后缀和吧......
	for(int i=1;i<=n;i++) ans=max((b/q[i])*h[i]+b%q[i],ans);//int类型自动取整， (b/q[i])*h[i]+b%q[i]的意思是：可以买b/p[i]次，然后乘上卖出时间，最后加上剩余的钱
	printf("%d\n",ans);//输出23333
	return 0;//Good Bye!
}

```

## 第四步 宣传

如果有帮助，请点个赞，谢谢！（撰文不易，dalao勿喷！）如果发现我的讲解有bug，请及时指出！

[我的主页](https://www.luogu.com.cn/user/172370)和[博客](https://www.luogu.com.cn/blog/fzj2007/)，欢迎关注！