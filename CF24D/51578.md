（此题中高斯消元是作为工具使用的，非常好）

这道题经过一定分析后可以发现：  
一个点不会走到之前的行中，这就满足了行的无后效性（dp）

设 $f[i][j]$ 表示机器人从 $(i,j)$ 走到最后一行，所需移动次数的期望。

考虑从最后一行向上递推，列出状态转移方程：

1. $j=1$，$f[i,j]=\frac{1}{3}(f[i,1]+f[i,2]+f[i+1,1])+1$
2. $j=m$，$f[i,M]=\frac{1}{3}(f[i,M]+f[i,M-1]+f[i+1,M])+1$
3. $j$ 是其他的，$f[i,j]=\frac{1}{4}(f[i,j]+f[i,j-1]+f[i,j+1]+f[i+1,j])+1$

初值：$f[N,j]=0$

观察这个状态转移，我们假设 $f[i+1,j]$ 是已知的，考虑怎样计算出 $f[i,j]$ 。

可以将这个状态转移方程改变一下：
$$f[i,j]=\frac{1}{4}(f[i,j]+f[i,j-1]+f[i,j+1]+f[i+1,j])+1$$
$$\frac{1}{4}f[i,j-1]-\frac{3}{4}f[i,j]+\frac{1}{4}f[i,j+1]=-\frac{1}{4}f[i+1,M]-1$$

定睛一看，这不就是高斯消元的形式吗？~~秒了~~

不过，问题还没有解决，这个方程怎么在 $\Theta(M)$ 时间内解出来呢？

现在的矩阵是这个样子（ $x$ 只是占位，无实际意义）：
$$
\begin{bmatrix}
x&x&0&0&0\\
x&x&x&0&0\\
0&x&x&x&0\\
0&0&x&x&x\\
0&0&0&x&x\\
\end{bmatrix}
$$

从上至下消一个未知数：

$$
\begin{bmatrix}
x&x&0&0&0\\
0&x&x&0&0\\
0&0&x&x&0\\
0&0&0&x&x\\
0&0&0&0&x\\
\end{bmatrix}
$$

再从下至上解出方程：

$$
\begin{bmatrix}
x&0&0&0&0\\
0&x&0&0&0\\
0&0&x&0&0\\
0&0&0&x&0\\
0&0&0&0&x\\
\end{bmatrix}
$$

差不多就是这个样子的。


------------

实在不行就看代码吧，有注释。

代码中的 $x$ 数组就是 $f$ ，为了表示方便，压成一维了。

代码：
```
#include<bits/stdc++.h>
#define ll long long
using namespace std;
int n,m,r,c;
double a[1005][1005],x[1005];
int main()
{
	scanf("%d%d%d%d",&n,&m,&r,&c);
	if(m==1)//特判
	{
		printf("%d\n",(n-r)*2);
		return 0;
	}
    //初始x数组都是0，因为最后一行到最后一行步数是0
	for(int i=n-1;i>=r;i--)//算到第r行
	{
    	//现在有第i+1行的答案x数组
		for(int j=1;j<=m;j++)//给矩阵赋初值
		{
			if(j==1)
			{
				a[1][1]=-2.0/3;
				a[1][2]=1.0/3;
				a[1][m+1]=-1-1.0/3*x[1];//根据上面的转移方程不难推出
			}
			else if(j==m)
			{
				a[j][m-1]=1.0/3;
				a[j][m]=-2.0/3;
				a[j][m+1]=-1-1.0/3*x[m];
			}
			else
			{
				a[j][j-1]=a[j][j+1]=1.0/4;
				a[j][j]=-3.0/4;
				a[j][m+1]=-1-1.0/4*x[j];
			}
		}
		for(int j=1;j<=m;j++)//第一次消元
		{
			double r=a[j+1][j]/a[j][j];
			a[j+1][j]=0;
			a[j+1][j+1]-=r*a[j][j+1];
			a[j+1][m+1]-=r*a[j][m+1];
		}
		for(int j=m;j>=1;j--)//第二次消元
		{
			double r=a[j-1][j]/a[j][j];
			a[j-1][j]=0;
			a[j-1][m+1]-=r*a[j][m+1];
			x[j]=a[j][m+1]/a[j][j];//更新答案
		}
	}
	printf("%.4lf\n",x[c]);//输出第c列
	return 0;
}
```