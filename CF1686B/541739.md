**前言。**

题意：[题目传送门](https://www.luogu.com.cn/problem/CF1686B)

题意描述的似乎不太明白。  
其实就是有 $t$ 组数据，每次输入一个长度为 $n$ 的序列，将这个序列分成连续的序列——使得在这些序列中逆序对的数量为奇数的序列最多，输出其中逆序对为**奇数**的数量。

**分析。**
- 第一步：

首先要知道：
>You are given a permutation $[p_1, p_2, \ldots, p_n]$ of integers from $1$ to $n$ (each of them appears exactly once in the permutation).

翻译：给你的 $p$ 序列中**每个数的取值范围为从 $1$ 到 $n$ 且从 $1$ 到 $n$ 每个数只出现一次**。

- 第二步：

按照题目要求，为了分成较多的序列段，我们先将序列 $p$ 中的每个数都单独分成一个序列段，即 $[ p_1 ] \ [ p_2 ] \ [ p_3 ] \dots\ [ p_n]$ 的一个个序列段，这样显然序列段数最多，这样可以减少我们的思维跳跃度。

- 第三步：

考虑贪心。  
根据第一步可以知道，这个序列中最小值为 $1$ 而且它是一个奇数，所以显然当 $p_{i+1}<p_i$ 时，将 $p_{i+1}$ 与 $p_i$ 两个数组合成为一个序列时可以增加奇数序列数的数量，同时序列数剩下的将会较多，使得奇数的序列数可以保证较多。  
由上可得：当 $b_i > b_{i+1}$ 时，将这两个数组合成一个序列时，会形成局部最优解，贪心证明完毕。
- 第四步：

根据上述过程写代码，详细过程见代码。

代码如下，仅供参考：
```cpp
#include<iostream>
using namespace std;
int t,n,a[100005],ans[100005],tot,sum;//定义
int main(){
	cin>>t;//输入数据组数
	while(t--){
		cin>>n;//输入序列中的数的个数
		sum=0;//记录形成的奇数的序列个数
		for(int i=1;i<=n;i++){
			cin>>a[i];//输入数组
			if(a[i]<a[i-1]){//见第三步
				sum++;//出现了一个，记录
				if(i<n){
				    cin>>a[i+1];//输入下一个数
				}
				i++;//进入下一层循环
			}
		}
		tot++;//记录答案顺序
		ans[tot]=sum;//记录答案
	}
	for (int i=1;i<=tot;i++){
		cout<<ans[i]<<"\n";//输出，别忘了换行
	}
	return 0;
}
```
**后记。**

大家如有疑问，可以在评论区提出，我会尽力解答的。