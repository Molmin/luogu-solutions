## 题目大意

给你 $ t $ 组数据，每组数据中给你一个长度为 $ n $ 的序列 $ b $ ，你可以将 $ b $ 分成一些连续的序列（或一个），从而使得在这些序列中逆序对数为奇数的序列最多，输出其中逆序对对数为奇数对数。

## 解题思路

首先，题目讲了要找到尽可能多的逆序对数为奇数的段，为了分成尽可能多的段，我们先将序列 $ b $ 中的每个数都单独分成一段  $ [ b_1 ] \ [ b_2 ] \ [ b_3 ] \ ... \ [ b_n ] $ ，这样显然序列数最多。

接下来考虑如何将这些序列组合起来时的出现逆序对数为奇数的段，由于 $ 1 $ 是奇数，所以显然当 $ b_i > b_{i+1} $ 时，将这两个数组合成一个序列可以增加逆序对数为奇数序列数的数量，同时剩下的序列数会尽可能的多，使得逆序对数为奇数的序列数可以保证尽可能多。

所以我们考虑贪心，当 $ b_i > b_{i+1} $ 时，将这两个数组合成一个序列，答案加一。结束。

## 代码 

```cpp
#include <iostream>
#include <stdio.h>
#include <algorithm>
#include <cstring>

using namespace std;
const int N=1e5+10;
int t;
int n;
int a[N];

int main(){
	scanf("%d",&t);
	while(t--){
		int ans=0;
		scanf("%d",&n);
		for(int i=1;i<=n;i++){
			scanf("%d",&a[i]);
			if(a[i]<a[i-1]){
				ans+=1;
				if(i<n)scanf("%d",&a[i+1]);
				i+=1;
			}
		}
		printf("%d\n",ans);
	}
}
```