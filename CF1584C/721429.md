# 题目描述

有 $2$ 个大小为 $n$ 数组 $A,B$。

定义一次操作如下：

- 在 $A$ 数组里选择 $k$ 个数，并把它们加 $1$。

- 随意打乱 $A$ 数组。

问：能否在做完 正好一次 操作后，把 $A$ 数组变为 $B$。

其中要输入 $n$、数组 $A$ 和数组 $B$，而并不需要输入 $k$，我就是这样被坑了一次！！！

# 思路

题目说明了可以随意打乱 $A$ 数组，那我们只要让 $A$ 数组有序即可，因为这样能让我们更好的判断是否要 $+1$。而 $B$ 数组我们也可以给它排个序，这样 $A$、$B$ 数组的元素就可以一一对应起来，方便我们比较，然后做出判断。

# 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
	//定义变量
	 
	int t,n,i,j,a[10001],b[10001],f;
	// t 表示组数、n 表示 a、b 数组大小， f 表示是否可以让 A 数组变成 B 数组，也是输出的关键 
	
	//输入
	 
	cin>>t;
	
	//处理 
	
	while(t--)
	{
		f = 1;//我们假设一开始 a 数组可以变成 b 数组 
		cin>>n;
		
		for(i=1;i<=n;i++)
			cin>>a[i];
		for(i=1;i<=n;i++)
			cin>>b[i];
			
		sort(a+1,a+1+n);//把 a 数组排序 
		sort(b+1,b+1+n);//把 b 数组排序 
		
		for(i=1;i<=n;i++)
		{
			if(a[i]<b[i])//如果 a[i] < b[i] 
				a[i]++;  //就让 a[i] +1
		}
		
		for(i=1;i<=n;i++)
		{
			if(a[i]==b[i])//判断两个数组的元素是否全部相同 
				continue; //相同的话，继续比较下一个元素 
			else
			{
				f = 0;//发现不相同的元素， f 变成 0 
				break;//我们就不用浪费时间继续找下去了，直接 break 
			}
		}
		
		printf("%s\n",f?"YES":"NO");//巧妙地运用三目运算符，不会使用的同学可以看下面，记得输出换行 
		/*
		if(f)
			printf("YES");
		else
			printf("NO");
		printf("\n");
		*/ 
	}
	return 0;
}
```

