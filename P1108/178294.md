这道题很有意思，也有点难，很考查选手 dp 能力，写篇题解总结一下。

## 题意简述

- 给你一个长为 $n$ 的序列。
- 你需要求出这个序列的最长下降子序列的长度和方案数。
- 两个子序列选的数不同但值相同算作一种方案。

## 最长下降子序列的长度

第一问有复杂度 $O(n\log n)$ 的算法，但是因为 $O(n^2)$ 能过，而且第二问是 $O(n^2)$ 的，所以采用更简单的 $O(n^2)$ 算法。

设 $f_i$ 表示最长的以第 $i$ 个数结尾的下降子序列的长度。

$$\large f_i=\max_{j=1}^nf_j+1\qquad\qquad(a_j>a_i)$$

解释：枚举每一个可以作为倒数第二个数的数 $j$，用 $f_j$ 更新 $f_i$。

注意 $f_i$ 的初值应该为 $1$。

## 最长下降子序列的方案数

去重比较麻烦，先不考虑。

### 不去重

设 $g_i$ 表示以第 $i$ 个数结尾的最长下降子序列的数量。

$$\large g_i=\sum_{j=1}^ng_j\qquad\qquad(a_j>a_i)$$

挺好理解的，就是将累加每一个符合条件的 $g_j$。

但是“符合条件”只有这一个条件吗？不是。

试想如果 $f_j$ 过小，则以 $a_j$ 为倒数第二个数的序列并不是最长子序列，不应统计进来，所以还要添加一个条件：

$$\large g_i=\sum_{j=1}^ng_j\qquad\qquad(a_j>a_i)\quad(f_j=f_i-1)$$

注意如果 $g_i$ 为 $0$，说明这个数是目前最大的，应该赋为 $1$。

### 去重

容易想到每次转移时判断 $a_j$ 是否重复，但是这样并不好办。

换个角度想，如果已知两个数 $a_i,a_j(j<i)$ 相等，那后面的数转移时只能从 $a_i$ 转移，因为以 $a_j$ 结尾的序列一定可以在以 $a_i$ 结尾的序列中找到。

总结一下，如果两个数 $a_i,a_j(j<i)$ 相等，那在区间 $(j,i)$ 的数只能从 $a_j$ 转移，$>i$ 的数只能从 $a_i$ 转移。

所以在上述不去重的算法基础上，做如下改动：如果 $a_i=a_j$，就应该将 $a_j$ 无效掉，比如将 $g_j$ 归零。

## 代码

代码中边读入边计算 $f_i$ 和 $g_i$，最后统计所有 $f_i=\max$ 的 $g$。

```cpp
#include<iostream>
#include<algorithm>
#include<memory.h>
using namespace std;
unsigned int n,mx,a[5010],f[5010],g[5010];
//n,a,f,g意义同上，mx代表最长的长度。
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
		f[i]=1;//先赋初值
		for(int j=1;j<i;j++)
			if(a[i]<a[j])
				f[i]=max(f[i],f[j]+1);
		mx=max(mx,f[i]);//更新mx
		for(int j=1;j<i;j++){
			if(f[i]==f[j]+1&&a[i]<a[j])//如果符合条件就更新
				g[i]+=g[j];
			if(a[i]==a[j])//如果相同就无效掉j
				g[j]=0;
		}
		if(!g[i])g[i]=1;//如果没有就说明自己就是最长子序列。
	}
	unsigned int ans=0;
	for(int i=1;i<=n;i++)
		if(f[i]==mx)ans+=g[i];
	cout<<mx<<' '<<ans<<endl;
	return 0;
}
```