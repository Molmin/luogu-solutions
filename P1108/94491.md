今天又来写题解了！  
## 剑气纵横三万里，一剑光寒十九洲！

------------
## 开门见山！  
最近一直在写DP，于是碰到了这道蓝蓝的题：  
#### [P1108 低价购买 ](https://www.luogu.com.cn/problem/P1108)！  
乍一看，这是道很简单的求最长下降子序列的题，但事实上并非如此！  
##### 他还要求你，输出能达到最大长度的不同方案数  
其实好像思想很简单，就是顺着退回去就好了，然后记录不同的方案数，但事实上，我试了一下，反正我是放弃了，因为他TLE了。。  
然后看了题解的写法，好像都是边Dp边记录（好吧其实我没看懂）  
所以我想了想，用了一个比较蠢的方法：  
##### 1.正常Dp
##### 2.对所有的DP结果按大小分类即DP长度分类
##### 那么，某一个数的dp结果是3，那么转移到他的方案书，就是，在他之前的，数值比他大的，dp结果为2的数方案数总和  
##### dp结果为n的数，就是序号在他之前，数值比他大，dp结果比他小1的各个数的方案数总和。  
##### 3.那么怎么去重呢？这个时候，我就用到了set的特性，相同的数值不会出现，这样就不会有重复的方案了。  
##### 那么显然，set里放的是某一位对应的数值，为了访问方便，可以再用vector维护每一个set，set的某一位的值，相对应着这个值对应的位，放在vector里。  
##### 如果将一个位置的数值放进相应的set时，set的长度不增加，说明方案重了，则对应的vector不将这个位置放入。
##### 那么每次dp结束后，就找到比这一位dp值小1的vector数组，将数组遍历一遍，将vector里每一位对应的位置上的方案数相加，就是这一位的方案数总和了。  
##### 最后将对应dp值最大的vector访问一遍，将对应位置上的方案数加起来，就是总方案数啦。  
##### 4.最后一个小点：当有这样一个点的时候 69 68 70 68 65  
##### 显然，第一个68放进去set【2】时，set【1】里有一个69，所以vector【2】里放入2，那么，set【2】中68对应的位置的方案书应该是2，因为69 68和70 68有两种方案，但是set放进68后，对应的值是1，因为下一个68不会被放进来，那么70 68这个点就没被统计到。  
##### 所以为了解决这个问题，当我们放入一个数值时，set长度不增加，我们就将vector访问一遍，看是哪个位置的值与当前值相等，将那位置对应的方案数变成当前位置的方案数，因为当前位置肯定在vector中记录位置的后面，因此可以保证大于等于，是正确的。  
    
    
#####  那么这就是全部过程了，好像挺繁琐的（确实挺繁琐的）。
##### 代码如下：  （时间复杂度算蒙了有没有大佬帮忙算一下）
```
#include<bits/stdc++.h>
using namespace std;
int n,a[5050];
long long maxn,ans,dp[5050],dpa[5050],l[5050];
vector< int >  v[5050];//v[i]对应的就是dp值为i的各个不同的数的位置
set< int > s[5050];//set[i]对应的就是dp值为i的各个不同的数的位置对应的数
int main(){
  cin>>n;

  
  dp[0]=0;
  a[0]=2147483647;
  v[0].push_back(0);
  dpa[0]=1;
  for(int i=1;i<=n;i++){
    cin>>a[i];
  }


  
  for(int i=1;i<=n;i++){
    for(int j=0;j<i;j++){
      if(a[i]<a[j]){
	dp[i]=max(dp[j]+1,dp[i]);//正常转移
      }
    }
    for(int j=0;j<v[dp[i]-1].size();j++){
      if(a[i]<a[v[dp[i]-1][j]])
      dpa[i]+=dpa[v[dp[i]-1][j]];//dp结果为n的数，就是序号在他之前，数值比他大，dp结果比他小1的各个数的方案数总和
    }
    
    s[dp[i]].insert(a[i]);
    if(s[dp[i]].size()>l[dp[i]]){
      v[dp[i]].push_back(i);
      l[dp[i]]++;
    }//set里放的是某一位对应的数值，再用vector维护每一个set，set的某一位的值，相对应着这个值对应的位，放在vector里
    else{
      for(int j=0;j<v[dp[i]].size();j++){
	if(a[v[dp[i]][j]]==a[i]){
	  dpa[v[dp[i]][j]]=dpa[i];
	}
      }
    }//当我们放入一个数值时，set长度不增加，我们就将vector访问一遍，看是哪个位置的值与当前值相等，将那位置对应的方案数变成当前位置的方案数，因为当前位置肯定在vector中记录位置的后面，因此可以保证大于等于，是正确的
  }


  
  for(int i=1;i<=n;i++){
    maxn=max(dp[i],maxn);
  }
  for(int i=0;i<v[maxn].size();i++){
      ans+=dpa[v[maxn][i]];
  }//最后将对应dp值最大的vector访问一遍，将对应位置上的方案数加起来，就是总方案数
  cout<<maxn<<" "<<ans<<endl;
  return 0;
}
```

------------
感谢阅读！
  
  by 龙尊

