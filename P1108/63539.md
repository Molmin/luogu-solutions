这不是一道简单的求最长下降子序列的问题。

### ——因为这个题要输出不同种的方案数

题目要求是“它们构成的价格队列不一样”，那么我准备拿一个数组存下这个最长下降子序列，但是这不现实，检查是否匹配是在最坏的情况下可能达到$Θ(N^3)$。

于是有了现在的解法，让我来**简单**~~证明~~**说明**一下

在$dp$过程中，$f$数组存的是最长下降子序列的长度，$f$数组的下标$i$是以$i$结尾的意思，所以最长下降子序列（除了最后一位外）的数据已经丢失，**因此不能**在方案数相加时**再**判断是否能加。

我们从头来看，
1. 如果一个数列的第一个数与另一个数列的第一个数相同，那么现在可以判断它们相等，即可以**把其中一个删掉**（在代码中的处理是$t[i]=0$）。当不同的数接在它的后面时，又可以将它们判断为两个数列，这是不互相影响的。因为两个数列都可以由这个相等的数列转移而来
1. 如果一个数列的第一个数与另一个数列的第一个数不同，那么它们不等，且无论后面添加什么，都不相等，即**不删去**，则按照普通的判断继续做。

由上面的两点，我们已经把重复的删掉，这样可以**防止重复计数**。

$tip$：本题如果出现在考试中，请不要冒险定义int，因为maxint是$2^{31}-1$，会爆int，这个题暂不做深究

Code：
---------

```cpp
#include<cstdio>
#include<cstring>
int max(int x,int y){return x>y?x:y;}
int a[5001],f[5001],t[5001];
//a[i]存的是第i天股票的价格
//f[i]存的是第i天最长下降子序列的长度
//t[i]存的是以i结尾的最长下降子序列的种类（方案）
int main()
{
    memset(f,0,sizeof(f));//初始化长度
    memset(t,0,sizeof(t));//初始化方案
    int n,maxx=0;
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
        scanf("%d",&a[i]);
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<i;j++)
            if(a[i]<a[j])//延长已经存在的最长下降子序列
                f[i]=max(f[i],f[j]+1);
        if(f[i]==0)
            f[i]++;//如果当前的数是目前为止最大的，则最长下降子序列是自己
        if(f[i]>maxx)
            maxx=f[i];//在f数组更新完毕后，存下最长下降子序列的长度
        for(int j=1;j<i;j++)
            if(f[i]==f[j]&&a[i]==a[j])
                t[j]=0;//如果与前面的数列相同，则舍去前面的数列，防止重复计数
            else if(f[i]==f[j]+1&&a[i]<a[j])
                t[i]+=t[j];//如果可以接上前面的数列，则继承其方案数
        if(!t[i])//如果当前的数是目前为止最大的，则是初始方案
            t[i]=1;
    }
    int sum=0;//sum计数，用于存最长下降子序列（方案）的个数
    for(int i=1;i<=n;i++)
        if(f[i]==maxx)
            sum+=t[i];
    printf("%d %d",maxx,sum);
    return 0;
}

```