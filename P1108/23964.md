##算法分析

先探索一下样例，最大购买次数为4次，共有2中方案，分别是69 68 64 62、69 68 67 62。

我们发现，这道题实际上是在一个数列中选出一个序列，使得这个序列是下降序列（即序列中的任意一个数必须大于它后面的任何一个数），且要使这个序列的长度最长。但是这道题要输出总的方案数，这就需要对原有的求解过程做一些变动。求方案总数最主要的是要剔除重复方案。当第2行N个数其中有两个以上价格相同时，可能就会产生重复方案。产生重复方案时，显然后面价格的要比前面的更优，因为以后面的价格结尾的最长下降序列的总数肯定不会比前一个少，而且其方案必定囊括了前面这个价格的所有方案。因此，在解题过程中，我们就可以只考虑相同价格中后面的那个。推广开来，如果当前状态之前存在重复的状态，我们只要考虑离当前状态位置最近的那一个即可。

设f[i]表示到第i天，能够买的最大次数，显然有：f[1]=1；f[i]=max{f[j]+1}(1<=j<=i-1，且ok[j]=1)，ok[j]=1表示相同价格时，该位置更优。

##参考程序

```cpp 
#include<stdio.h>
#include<string.h>
bool ok[50010];
int a[5010],b[5010],f[5010];
int n,i,j,k,max,num;
int main()
{
    scanf("%d",&n);
    for(i=1;i<=n;i++)
        scanf("%d",&a[i]);
    b[1]=1;
    f[1]=1;
    for(i=2;i<=n+1;i++)
    {
        max=0;
        f[i]=1;
        for(j=i-1;j>=1;j--)
            if(a[i]<a[j])
                if(b[j]>max)//b[j]表示以第j天结尾的最大购买次数 
                {
                    max=b[j];
                    memset(ok,1,sizeof(ok));
                    ok[a[j]]=0;
                    f[i]=f[j];
                }
                else
                    if(b[j]==max && ok[a[j]])
                    {
                        ok[a[j]]=0;
                        f[i]+=f[j];
                    }
        b[i]=max+1;
    }
    printf("%d %d",b[n+1]-1,f[n+1]);
}
```