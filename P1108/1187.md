【问一】最长下降子串

状态的划分len[i]表示以a[i]为开头共的最长不下降子串的长度，则

Len[i]:=max{len[j]}+1   (1<=i<j<=n,a[i]>a[j])

也就是说由len[i]选择它的后一个序列，储存也是以len[j]为开头，这个状态一定是最大的。因为len[i]与len[j]只有大小和顺序关系，在子串上由于开头不一，存在独立，它满足最优子结构。算法n(n^2/2).

【问二】输出方案

这是本题最难的一点，难在一个误区，如果a[i]>a[j]  len[i]=len[j+1]则f[i]:=f[i]+f[j]。这样算法很完美了吗？我们不难举出反例：3，2，2因为“当二种方案“看起来一样”时（就是说它们构成的价格队列一样的时候）,这2种方案被认为是相同的”比如“第一个和第二个”与“第一个与第三个”是一样的。如果这样还要枚举与记录重复的数据，上述方程式矛盾的。有以下两种方法：

（1）    采用列表记录下每一个方案最后在去重相乘，这个方法是对的，但是列表是一种高级的数据结构操作麻烦，不论是竞赛时间还是调试程序都不推荐使用。

（2）    J从i-1往1循环，如果碰到a[i]=a[j]则跳出循环，因为f[i]作用于循环中的f[j]，如果两个价格相等的话则f[j]>=f[i]，前面的元素已经加过一个这个价格的方案了，而且方案数可能还比这个大，就不必再加了。
