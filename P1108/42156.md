首先我们来分析一下这道题说的到底是什么，然后便可以发现这是一个最长下降子序列的题。

第一文是求最长下降子序列的长度，自然用普通的dp算法。关键是第二问，求**不同的**最长下降子序列的个数。

我们仍然考虑递推求解。设$t[i]$表示以第i个元素结尾的**最长的下降子序列**的个数。在开始的时候，因为我们还不知道最长下降子序列的长度，所以我们把所有的$t[i]$都置为1。

在按照普通的dp方法求解最长下降子序列的时候，我们在中间统计：如果$f[i]<f[j]+1$，按照dp思想，我们就会用$f[j]+1$更新$f[i]$。这时，现在以$a[i]$结尾的最长的下降子序列的长度就只跟以$a[j]$结尾的最长的下降子序列的长度有关了。所以$t[i]$直接赋值为$t[j]$。如果$f[i]=f[j]+1$，那么我们在构造以$a[i]$结尾的最长下降子序列的长度的时候，既可以用原来算出$f[i]$值的那一个子序列来构造，也可以把第i个元素接在以第j个元素结尾的最长下降子序列后面，所以$t[i]+=t[j]$。最后统计，如果$f[x]$等于最长下降子序列的长度，便把$t[x]$计入答案总数中。

去重就比较简单了。在前一个元素和后一个元素相同的时候，我们只保留后一个元素的f值和t值就好了。
```
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cmath>
using namespace std;
int a[5005],f[5005],t[5005];
int main(){
    int n,ans=1,ans2=0;
    cin>>n;
    for(int i=1;i<=n;i++){
    	cin>>a[i];
    	f[i]=t[i]=1;
    }
    for(int i=2;i<=n;i++){
        for(int j=1;j<i;j++){
            if(a[j]>a[i]){
                if(f[i]<f[j]+1)f[i]=f[j]+1,t[i]=t[j];
                else if(f[i]==f[j]+1)t[i]+=t[j];
            }
            if(a[j]==a[i])f[j]=t[j]=0;
        }
        ans=max(ans,f[i]);
    }
    cout<<ans;
    for(int i=1;i<=n;i++)if(f[i]==ans)ans2+=t[i];
    cout<<" "<<ans2;
    return 0;
}
```