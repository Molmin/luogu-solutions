题目说要我们输入一个数列（这里假设是a[n]），然后找到一个数（这里假设是M），使得这个数除以数列
里的每一个数的余数相加起来最大，最后输出这个和

其实这个涉及到余数的数学知识，既然余数要大，那么这个M就要比数列里的数小并且尽可能接近。

## **推理过程如下：**

我们知道：A÷B=C······D，D尽可能大，但是不可能超过除数B，最大也只能是B-1。放到这道题里去看，余数要尽量大，所以得出：

M mod a[n]=a[n]-1
 
移项不难发现：M+1是a[n]的若干倍，所以M=a[n]*k-1（k为正整数）
 
接下来要用到余数的数学知识了：由于a[n]各不相同，所以只能取所有a[n]的乘积，即M=a[1]*a[2]*a[3] *…… *a[n]-1就好了

带入进去，最终输出的数ans就是(a[1]​+a[2]​+...+a[n]​)−N ，没有比这个更大的了

------------
## 代码如下
```
#include<bits/stdc++.h>
using namespace std;
int main()
{
	int n,ans=0;//ans用来储存最后的数组所有数之和
	cin>>n;
	int a[n];
	for(int i=1;i<=n;i++)//输入数组
                               
	{
        cin>>a[i];
	}
	for(int j=1;j<=n;j++)//计算和
    {
        ans=ans+a[j];
    }
    cout<<ans-n;//输出
	return 0;
}
```