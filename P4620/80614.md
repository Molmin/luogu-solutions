想不到吧，这是 SDOI2018 二轮省选中最简单，最可做的题了。

不过这题确实简单，而且我除了粘了题面中所给的 gen 和自己的缺省源以外，就写了不到 $550\text B$。

之前一直觉得战略游戏最简单，但现在一看，不仅有点难写，还容易写挂（qdez 老传统。更重要的是，当年圆方树还是新科技，所以放在四年前，我肯定不会（确信。

首先，你看到除二除二的限制，会想到完全二叉树，这个大家肯定都能想到。

在这里设这棵完全二叉树的根的 $dep=1$。

然后就转化成了在一棵完全二叉树上定最小权值（每个权值都有下限）是的每条长度为 $k+1$ 的向祖先延伸的链权值之和 $\bmod m=0$。

接下来就是搞笑时刻，想出这一个性质用了半小时时间（（（

这个性质就是一个节点的权值一定与它的 $(k+1)$ 级祖先在 $\bmod m$ 意义下同余。

证明的话你考虑把一条链沿着这个节点移一格即可。

然后就能引申出来另外一个显然性质，对于 $dep$ 相同且 $>k$ 点对若它们的 $\text{LCA}$ 的 $dep\ge k$，那么它们的权值在 $\bmod m$ 意义下同余。

证明同样显然，你考虑两个节点 $u,v$，若它们的 $dep=k+1$，那么假设有一条链尾是 $u$，那么可以只把链尾修改到 $v$，这样 $u$ 和 $v$ 的权值必须同余。

以此类推，你就可以得出这个性质。

更搞笑的是，我很快的想出了后者却栽在了前者上/oh。

然后你会发现，所有节点都只依赖于 $[1,2^{k+1})$ 的其中一个节点了。

那就随便做了啊，你就把所有节点都算出它的归属，然后把它加进这个节点里，最后对于每个在 $[1,2^{k+1})$ 的节点都算出 $\bmod m=i$ 时需要花费多少代价，然后随便树形 dp 一下即可。

显然，对于每个节点预处理代价和树形 dp 都需要花费 $O(m^2)$ 的时间。

时间复杂度：$O\left(T\left(2^{k+1}m^2+\dfrac{n\log n}{k+1}+n\right)\right)$

# AC code：
```cpp
ll val[2048][205],f[2048][205],tmp[205];
inline int lmod(int x){return x+(x>>31&m);}
void dfs(int u){
	if(u>>k) return ; 
	dfs(u<<1),dfs(u<<1|1);int i,j;
	for(i=0;i<m;i++){tmp[i]=inf;for(j=0;j<m;j++) tmp[i]=min(tmp[i],f[u][lmod(i-j)]+f[u<<1][j]+f[u<<1|1][j]);}
	memmove(f[u],tmp,m<<3);
}
void solve(){
	gen();int i,j,l;ms(f,0),ms(val,0);
	for(i=1;i<=n;i++){int now=i;while(now>>k+1) now>>=k+1;val[now][a[i]%m]+=b[i];}
	for(i=1;i<1<<k+1;i++) for(j=0;j<m;j++) for(l=0;l<m;l++) f[i][j]+=val[i][l]*lmod(j-l);
	dfs(1),pr(f[1][0]),en;
}
```