（之前一篇题解有些部分有点多余，并且讲的不是特别清楚，因此我来发一篇简洁明了的。）

读题发现显然是01背包。金钱就是背包容量，入场费就是物品质量，乐趣值就是物品价钱。

我们使用$a$表示总共有多少钱，$w_i$表示第$i$个派对的金钱，$v_i$表示第$i$个派对的乐趣值，$dp_i$表示用$i$块钱最多能多大的乐趣。因为金钱量很小，因此直接外层循环枚举派对，内层从大到小枚举金钱。

如果$j>w_i$，表示花费$j$钱能够参加派对$i$，因此此时有另一种方法：**在$dp_{j-w_i}$的基础上参加派对$i$**。然后$dp_i$在此取更大值即可。

转移方程为

$$
dp_i=\max\limits_{j=a}^1\left(dp_{j-w_i}+v_i\right)
$$

此时还有个问题，如何回答第一问。

分析我们的$dp$数组，发现$dp$数组中最后一个和$dp_a$不相等的$i$的后一个位置，表示花费最少金钱能达到$dp_a$的金钱，因此输出这个即可。

然后就好了。

```cpp
int a,n,w[1005],v[1005],dp[1005];
int main(){ 
	while(1){
		cin>>a;
		if(!a)return 0;
		cin>>n;
		memset(dp,0,sizeof(dp));//清空数组
		for(int i=1;i<=n;i++)cin>>w[i]>>v[i];
		for(int i=1;i<=n;i++) 
			for(int j=a;j>=0;j--) 
				if(j>=w[i])
					dp[j]=max(dp[j-w[i]]+v[i],dp[j]);//转移方程：如果能放下，是否更新为在j-w[i]的基础上放这个物品
		for(int i=a;i>0;i--)
			if(dp[i]!=dp[a]){cout<<i+1<<" ";break;}
		cout<<dp[a]<<endl;
	}
	return 0;
}
```

推荐难度：橙

~~一小时前写了一篇斜率优化+wqs二分的题解，感觉这题好简单~~