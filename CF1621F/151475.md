分讨题。

假设相邻的 $0$ 有 $x_0$ 对，相邻的 $1$ 有 $x_1$ 对。考虑一个贪心的事实：我们肯定交替进行 $1,2$ 操作，直到 $x_0$ 或 $x_1$ 有一个降到了 $0$。接下来如果 $c<b$，我们可以用一次 $3$ 操作的代价换取一次 $2$ 操作。但是你会感觉这个东西的量谁多谁少好像很多情况，那就讨论一下。

- $x_0=x_1$

这种情况最后一定会形成一个 $01$ 交替的序列（或空序列）。假设 $0$ 有 $x$ 个，$1$ 有 $y$ 个。如果 $c\ge b$，就啥也不干了；否则当 $y>0$ 时，可以进行 $y-1$ 次 $3,2$ 的交替操作。这样显然是最优的。

- $x_0>x_1$

最后的序列是有一些单独的 $1$ 分割开的 $0$ 段，形如 $00..0100..0100..0100..0$。不过这个最终序列的形态不是唯一的，只要满足 $01$ 段数不变，$0$ 的位置可以任意挪动。

如果 $c\ge b$，就再删一组 $00$ 就可以了；否则我们应该反复执行 $3,2$ 操作，最后再删一组 $00$。但是 $3$ 操作要求存在一个不在两端的 $0$ 连续段只有一个元素，假设有 $s$ 个这样的段，那么就可以进行 $s$ 次 $3,2$ 操作。为了最大化 $s$，我们在第一步删 $00$ 的时候就要先选 $0$ 少的段删就行了。这里需要一个排序。

- $x_0<x_1$

最后的序列是有一些单独的 $0$ 分割开的 $1$ 段，形如 $11..1011..1011..1011..1$。

我们无论怎样都要先删一组 $11$，因为这样一定不劣，还可以把交替操作给到删 $0$。如果 $c\ge b$，就啥也不用干了；否则我们应该反复执行 $3,2$ 操作。可以算一下最多还能进行几组 $3,2$ 操作：假设还有 $x$ 个 $1$ 和 $y$ 个 $0$，那么考虑显然的上界是 $\min(\max(x-1,0),y)$，因为每次 $3$ 操作要消耗一个 $0$，$2$ 操作在有至少两个 $1$ 的时候要消耗一个 $1$。这个上界也是容易取到的。如果某次消耗完 $0$ 但找不到 $11$，那么一定存在 $101$，那么上一次可以消耗这个 $0$。

```cpp
void work()
{
	cin >> n >> a >> b >> c;
	int s0=0,s1=0;
	for (int i=1;i<=n;i++)
	{
		char x;
		cin >> x;
		s[i]=x-'0';
		if (s[i]==1) s1++;
		else s0++;
	}
	int x1=0,x0=0;
	for (int i=2;i<=n;i++)
	{
		if (s[i]==s[i-1])
		{
			if (s[i]==1) x1++;
			else x0++;
		}
	}
	if (x1==x0)
	{
		ll x=s0-x0,y=s1-x1;
		ll ans=(a+b)*x0;
		if (c>=b)
		{
			cout << ans << endl;
			return;
		}
		ll g=b-c;
		ans+=max(y-1,0ll)*g;
		cout << ans << endl;
		return;
	}
	else if (x0>x1)
	{
		ll ans=(a+b)*x1;
		if (c>=b)
		{
			cout << ans+a << endl;
			return;
		}
		cnt=0;
		ll lst=-n-1;
		for (int i=1;i<=n;i++)
		{
			if (s[i]==0) lst++;
			else 
			{
				if (lst>0) d[++cnt]=lst;
				lst=0;
			}
		}
		sort(d+1,d+cnt+1);
		ll sum=x1,tot=0;
		for (int i=1;i<=cnt;i++)
		{
			if (d[i]-1<=sum)
			{
				sum-=(d[i]-1);
				tot++;
			}
			else break;
		}
		ll g=b-c;
		ans+=tot*g+a;
		cout << ans << endl;
		return;
	}
	else
	{
		ll ans=(a+b)*x0;
		if (c>=b)
		{
			cout << ans+b << endl;
			return;
		}
		s0-=x0,s1-=x0+1;
		ll tot=min(max(s1-1,0),s0);
		ll g=b-c;
		ans+=tot*g;
		cout << ans+b << endl;
	}
}
```

因为是赛时，代码有点冗长。但是应该是可以阅读的。

这道题可能不是一道很 OI 的题，也没那么有趣。不过我们也需要这样的讨论题来训练，减少讨论的错漏和粗心程度。在保证正确性的情况下加快思考速度和代码速度。
