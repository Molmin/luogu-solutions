##### D. Blue-Red Permutation

题目大意：

对于多组数据 $(1 \leq t \leq 10^4)$ 给定一个长度为 $n(1 \le n \le 2 \times 10^5)$ 的数组 $a(-10^9 \le a_i \le 10^9)$，并给 $\forall a[i]$ 指定了红蓝色，接下来可以做无限次操作：如果涂了红色每次可以 $+1$，如果涂了蓝色每次可以 $-1$。问是否有办法将 $a$ 变成一个 $1 \sim n$ 的排列。

------

思路：

由于可以做无限次操作，我们可以直接认为涂了红色的数字 $i$ 可以变成 $[i,+∞)$（下文我们称作用域为它），否则可以变成 $(-∞,i]$。进一步地，由于我们只需要考虑变成 $1 \sim n$ 的情况，那么红色 $i$ 的作用域为 $[i,n]$，蓝色 $i$ 的作用域为 $[1,i]$。（如果不存在这个区间自然是 `NO` 了）

于是，题目就转化成了每一个数字在自己的作用域下选择一个位置，最终要求选中的是 $1 \sim n$ 中的每一个数字。接下来发现一个重要的结论：**如果有 $j$ 个数字的作用域中只包含 $j-1$ 及以下个数字，那么无法实现题意。**为什么呢？因为如果按照题目要求，这 $j$ 个数字需要各自找一个位置，并且两两不同。而这 $j$ 个数字的作用域总共都没有 $j$ 个数，如何做到这一点？所以不能。另外，如果对于任意 $j$ 个数字都有其作用域包含的数字不少于 $j$ 个，并且不存在没有作用域的数字，那么可以实现题意。

------

实现：

那么我们按照这个结论往下想（这提供了一个思路，但并没有充足的时间来实现枚举）。由于我们的数组有红有蓝，作用域有的靠左有的靠右没有那么容易考虑，所以分开来考虑。把红色的数字递增排列，蓝色的数字**递减**排列。这把所有的作用域分为靠左和靠右两部分，为接下来的操作提供极大便利。

遍历红色的数字，如果第 $j(0-indexed)$ 个数字小于等于 $j$，那么证明这 $j$ 个数字的作用域中只包含**前** $j-1$ 及以下个数字。遍历蓝色的数字（是倒着排的），如果第 $j$ 个数字大于 $n-j$，那么证明这 $j$ 个数字的作用域中只包含**后** $j-1$ 及以下个数字，举个例子：

如果红色的数字前几个分别为 $[1,2,2]$，那么由于第三个 $2$ 小于等于其 $index=2$，这三个数的作用域只包含前 $2$ 个数字。$[1,3,3]$ 则可以。

如果蓝色的数字前几个分别为 $[5,4,4]$，$n=5$，那么由于第三个 $4$ 大于 $n - index=3$，这三个数的作用域只包含后 $2$ 个数字。$[5,4,2]$ 则可以。

走一遍之后还是可以的话，那么就成立了（因为在这个过程中如果有的数字没有作用域，那么已经被排除了）这样我们得到了一个时间复杂度 $O(n \log n)$ 的算法。

```c++
#include <bits/stdc++.h>
using namespace std;
int main() {
	int t;
	cin >> t;
	for (int i = 0; i < t; i++) {
		int n;
		cin >> n;
		vector<int> a(n);
		for (int j = 0; j < n; j++) {
			cin >> a[j];
		}
		string s;
		cin >> s;
		vector<int> b, r;
		for (int j = 0; j < n; j++) {
			if (s[j] == 'B') {
				b.push_back(a[j]);
			}
			if (s[j] == 'R') {
				r.push_back(a[j]);
			}
		}
		int B = b.size();
		int R = r.size();
		bool ok = true;
		sort(b.begin(), b.end());
		for (int j = 0; j < B; j++) {
			if (b[j] <= j) {
				ok = false;
			}
		}
		sort(r.begin(), r.end(), greater<int>());
		for (int j = 0; j < R; j++) {
			if (r[j] > n - j) {
				ok = false;
			}
		}
		if (ok) {
			cout << "YES" << endl;
		} else {
			cout << "NO" << endl;
		}
	}
}
```

