### 这道题比较简单，贪心就可以解决
# 题目翻译：
给一个长度为 $n$ 的整数 $a$ 数组。数组的元素可以不同，也可以相同。

数组的每个元素都是蓝色或红色的。共有两种操作：

- 选择一个蓝色元素并将其值减少 $1$。

- 选择一个红色元素并将其值增加 $1$。

问是否存在一种步骤，使最后的数组有且仅有 $1$ 到 $n$ 的数字？

### 输入格式：

有多组测试数据。

第一行输入一个 $t(1\le t \le 10^4)$ 表示共有 $t$ 组数据

对于每一组数据，共有 $3$ 行。

第一行一个整数 $n$ 表示数组的长度。

第二行共有 $a$ 个数，表示数组的每一个数。

第三行一个字符串，表示 $a$ 数组中每一个数的颜色（ $R$ 表示红色， $B$ 表示蓝色）。

### 输出格式：

共 $t$ 行，每行输出一个字符串 “YES” 或 “NO”，表示是否能组成满足题意的数组。

# 简单易懂的思路：
维护两个数组 $red$ 和 $blue$ 分别表示红色和蓝色的元素。

因为我需要求得一个只有 $1$ 到 $n$ 数字的数组，所以显然可以想到：

把 $red$ 从大到小排列、$blue$ 从小到大排列；如果满足题意，必定存在：

- $red$ 的第 $i$ 项满足 $\le n-i+1$。
- $blue$ 的第 $i$ 项满足 $\ge i$。

这里简单说明一下原因：

举个例子：假如数组 $blue$ 排序后是 $2,3,3,3$。

我们可以把第一项 $2$ 减到 $1$ ，第二项 $3$ 减到 $2$，第三项不变。

此时第四项 $3\gt 4$ 不满足上面的结论，因为 $3$ 无法减到 $4$ ，所以这个序列无法达到要求。红色同理。

# Code：

```cpp
#include<iostream>
#include<algorithm>
using namespace std;
int q,n,a[200005],red[200005],blue[200005];
char b[200005];
int main(){
	cin>>q;
	while(q--){
		cin>>n;
		for(int i=1;i<=n;i++){
			cin>>a[i];
		}
		cin>>b+1;
		int rl=0,bl=0;
		for(int i=1;i<=n;i++){//将每一个元素按颜色分开 
			if(b[i]=='R'){
				rl++;
				red[rl]=a[i];
			}else{
				bl++;
				blue[bl]=a[i];
			}
		}
		sort(red+1,red+rl+1); 
		sort(blue+1,blue+bl+1);
		bool o=true;
		for(int i=1;i<=bl;i++){
			if(blue[i]<i)o=false;
		}
		for(int i=rl;i>=1;i--){
			if(red[i]>n-(rl-i))o=false;//n-(rl-i)相当于降序排列 
		}
		if(o)cout<<"YES"<<endl;
		else cout<<"NO"<<endl;
	}
}
```
