简单题，水评$\texttt\color{blueviolet}\colorbox{white}{紫}$。

方法和楼上 $dalao$ 差不多，本文重在思路。

------------

### 样例手玩：

我们分别以 $A$、$B$ 两人的主视角来尝试想出思路，用的是第3组样例：

```
3
3 1 3 2
3 5 4 6
2 8 7
```

我们首先清楚，倘若一张牌在牌堆中的位置是靠 $A$ 这一边的，我们可以断定 $A$ 在拿这张牌时**更有优势**。

对于 $A$ 来说，他在**拿牌方面**比较占优势的有：堆1中的点数为1的牌（以下以 $(1,1)$ 形式表示）， $(2,5)$ ， $(3,8)$ 。

对于 $B$ 来说，他在**拿牌方面**比较占优势的有：$(1,2)$ ， $(2,6)$ ，$(3,7)$ 。

而之于 $(1,3)$ 和 $(2,4)$ ，则两边的优势相等，互不吃亏。

-------

### 策略模拟：

现在我们从 $A$ 开始。$A$ 认为，拿一张对方有优势的卡要付出的**步数的代价**必然很大，对方如果看出了这一意图，必能以**较少的步数**采取保卫措施。所以 $A$ 决定拿自己**掌握优势**的牌。他先拿了一张 $(3,8)$ 。

回合轮到 $B$ ，他也认为拿自己掌握优势的牌更为划算，所以他拿了一张 $(3,7)$ 。

两人你来我往了几个回合。自己最初有优势的牌都已经被拿完了。

**注意**：”拿完有优势的牌“这一情况必然在**相邻**的两回合发生，且这一情况结束后**必为 $A$ 的回合**，因为两人最开始的优势牌数是**相等**的。

现在场上剩下两张牌，$(1,3)$ 和 $(2,4)$ ，如果 $A$ 睡眠充足，他不用想也知道该拿最大的那张。

为什么他**可以拿到**最大的那张？

因为优势均等的牌，在每一堆中都最多只有**一个**（倘若有两个就必然分靠两方），故最后剩下的这些牌，相互之间必然没有条件关系。那他取哪张都是合法的。

最后两个人轮流取完当时情况下点数最大的牌，游戏结束了。

------

### 实现有关：

我们回想这一过程，前面的你来我往实则可以归结为一句话：**两个人都把自己有优势的牌给拿完了**。

对于每个人，有优势的牌是必然确定的，就是每一堆中**靠上的一半**和**靠下的一半**。

此外，倘若牌堆中牌的数量是奇数，则最中间的那张被定为**优势均等的牌**。

我们先把优势牌的点数加到 $A$ 、 $B$ 的得分上去。

对于优势均等的牌，我们每次都取点数最大的，可以用**优先队列**来维护这一最大值。

直到优先队列为空，游戏即可结束。

------------

### 代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAX = 107;
int N;
int card[MAX][MAX], num[MAX];
int A, B;
priority_queue<int> q;
int main()
{
	cin >> N;
    
	for (int i = 1; i <= N; i++)
	{
		cin >> num[i];
        
        /*输入数据*/
		for (int j = 1; j <= num[i]; j++)
		{
			cin >> card[i][j];
		}
        
        /*拿优势牌*/
		for (int j = 1; j <= num[i] / 2; j++)
		{
			A += card[i][j];
			B += card[i][num[i] - j + 1];
		}
        
        /*优势均势牌入优先队列*/
		if (num[i] % 2)
		{
			q.push(card[i][num[i] / 2 + 1]);
		}
        
	}
	int turn = 1;
    
    /*拿当前最大牌*/
	while (!q.empty())
	{
		if (turn)
		{
			A += q.top();
		}
		else
		{
			B += q.top();
		}
		q.pop();
		turn = 1 - turn;
	}
	cout << A << ' ' << B << endl;
}
```
