# Mishka and trip 题解

**先感慨一句，这是我做过最难的橙题，感觉这道题难度设定虚低了。**

[题目传送门](https://www.luogu.com.cn/problem/CF703B)

## 寒暄部分

先简单讲一下题目的大意，所有城市按顺序连成一个环，相邻两个城市有直接边连接，并且省会城市会和其它所有城市有一条边连接，去除重叠边后求所有边权值之和。一条边的权值等于这条边两个端点的权值相乘。

那么，这道题用一个暴力加图模拟，作为一道橙题，允许 $n^2$ 的复杂度不过分吧——

不幸的是，这道题要求 $n$ 的时间和空间复杂度。

这篇题解会用一个很简单的分类让你不用判重，不用建图就做出这道题目。

## 讲解部分

首先，我们将最后的图分为三个部分，第一个部分是所有省会城市的集合，因为省会城市和所有城市都有连线，所以省会城市之间一定是完全图的关系，换句话说，每两个省会城市之间必有一条连线，下面就是乘积求和的部分了，请看推导：

设所有省会城市权值集合为 $a$，$a_i$ 为第 $i$ 个省会城市的权值，则第一个省会城市的权值一定要被其它所有省会城市的权值乘一遍，第二个省会城市的权值要被后面（第三个到最后一个）所有的省会权值乘一遍（第一个和第二个在第一个中已经乘过了），也就是第一部分的答案和为

$$\sum_{i=1}^{k-1}(\sum_{j=i+1}^{k} a_j \times a_i)$$

其中 $k$ 为省会城市数量。

可能有人会问，这不是 $n^2$ 复杂度吗？但是有没有可能，权值之和我们已经求好了，而每当 $i$ 变化时，我们只要减去 $a_i$ 就能得到 $\sum\limits_{j=i+1}^{k}a_j$ 呢？

显然，只需要输入时求出省会权值之和即可，第一部分计算完毕。

第二部分，是把省会和普通城市连接，并求所有由一个省会和一个普通城市连接的边的权值。这部分更加简单，因为省会权值之和我们已经算出，根据乘法分配律，所有省会城市分别乘普通城市就等于省会城市之和乘普通城市，这时，只需枚举所有节点，用不是省会的城市乘省会城市权值之和，请看推导：

设所有省会城市权值集合为 $a$，非省会城市权值集合为 $b$，则第二部分答案和为

$$(\sum a) \times (\sum b)$$

因为集合 $b$ 题目没有给出，所以使用 $O(n)$ 的复杂度枚举所有不是省会的城市，即可得到集合 $b$。

第三部分，是圆环部分，需要注意，只有两个端点都不是省会时，才能够加入答案中，因为所有带有省会的边都已经做完，虽然也属于判重，但逻辑相比其它办法更加易于理解。

这样，我们就把图分为了三个部分，更加方便答案求解。

## 代码部分

**首先是变量定义部分**

```cpp
int sum1,sum2;//sum1和sum2都是省会权值之和，复制一份方便第一部分的递减操作
int ans;//ans表示最终答案
int n,k;//与题目表述一致
int a[100001];//该节点权值
int b[100001];//省会城市的下标
bool c[100001];//true表示该节点是省会，false表示普通城市
```

**第一部分**

```cpp
for(int i=1;i<=k;i++)
	cin>>b[i],c[b[i]]=true,sum1+=a[b[i]];//sum1就是省会权值之和
sum2=sum1;//复制一份
if(k>1)
	for(int i=2;i<=k;i++)
		sum2-=a[b[i-1]],ans+=a[b[i-1]]*sum2;//先减去前一个省会权值，再用后面的省会权值之和乘前一个省会权值
```

**第二部分**

```cpp
for(int i=1;i<=n;i++)
	if(!c[i])//不是省会的城市
		ans+=sum1*a[i];//用省会权值之和乘普通城市权值
```

**第三部分**

```cpp
for(int i=1;i<n;i++)//防止越界
	if((!c[i])&&(!c[i+1]))//如果当前城市和下一个都不是省会，那么将乘积加入答案
		ans+=a[i]*a[i+1];
if((!c[n])&&(!c[1]))//判定最后一个和第一个（头尾）
	ans+=a[n]*a[1];
```

**将它们结合起来即可得到最终代码**

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int sum1,sum2;
int ans;
int n,k;
int a[100001];
int b[100001];
bool c[100001];
signed main()
{
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin>>n>>k;
	//输入
	for(int i=1;i<=n;i++)
		cin>>a[i];
	//第一部分
	for(int i=1;i<=k;i++)
		cin>>b[i],c[b[i]]=true,sum1+=a[b[i]];
	sum2=sum1;
	if(k>1)
		for(int i=2;i<=k;i++)
			sum2-=a[b[i-1]],ans+=a[b[i-1]]*sum2;
	//第二部分
	for(int i=1;i<=n;i++)
		if(!c[i])
			ans+=sum1*a[i];
	//第三部分
	for(int i=1;i<n;i++)
		if((!c[i])&&(!c[i+1]))
			ans+=a[i]*a[i+1];
	if((!c[n])&&(!c[1]))
		ans+=a[n]*a[1];
	cout<<ans;
	return 0;
}
```

## 总结

这道题是一道思维含量较高的橙题，这个做法应该是最好理解的，当然码量有点高。题解写得有点啰嗦，希望各位见谅。

再见了，祝各位好运！