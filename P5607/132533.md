历时三天，还是没有完全做出来。    

可能有略多篇幅来写思路。

死因：不会操作 $1$ 。     

拿到这道题的第一刻，有亿点懵，感觉特别像之前偶然学习到的拆位线段树，不过仔细想了发现完全不会维护，毕竟我们维护的是随机选数的最大值，而拆位线段树比较擅长于维护异或和，所以果断放弃。     

接着就考虑了一下此题的操作，对于操作 $1$ ，我们可以线段树、分块维护，而对于操作 $2$ , 我马上就想到了两个东西： $01Trie$ 和 线性基 。    

思考一番，感觉 $01Trie$ 是询问当前这个区间里面的一个数和 $v$ 异或起来的最大值，就算可持久化一波也只能查一个连续区间的最大值，放弃。     

那么只剩下我们的线性基了，按图索骥，直接考虑线段树加线性基。     

这时操作 $2$ 就很显然了。我们在线段树时，合并线性基，最后把合好的线性基拿出来跑就行了。合并一次是 $O(log_v^2)$ ，线段树区间查的时间复杂度是 $O(log_n)$ ，合起来的时间复杂度就是 $O(log_v^2log_n)$，~~逐渐树套树化~~。    

接着我们就发现我们不会操作 $1$ 了，首先这玩意儿肯定不能像线段树这种打 $tag$ 传下来改，然后我们就发现这玩意儿如果做个单点修的话完全是可做的，所以我们就考虑把区间修转化成单点修。     

一说到区间修变单点修，就想到了差分。如果我们记 $c_i = a_i \bigoplus a_{i - 1}$ 。然后我们就可以把操作 $1$ 变成两个单点修改，即修改 $c_l$ 和 $c_{r + 1}$ (这里记得判越界) ， 然而我们此时又发现操作 $2$ 又不能做了。   

想到了这一步，我们就得发挥~~猜结论~~精神，我们先把差分数组的线性基给求出来，和原序列的线性基比一下，看一下有什么相似处。     

经过一番思索后，发现我们原序列可以表示出来的一些数是无法用差分数组的线性基表示出来的，所以我们不妨先看看有没有什么方法可以用差分数组的线性基来表示原序列的所有数。如果可以的话，那我们就可以证明这两个线性基是等价的。    
到这里，想必诸位思路都很清晰了，我们只要在 $c_{l + 1} \sim c_{r}$ 的线性基中插入 $a_l$ 即可等价于 $a_{l} \sim a_r$ 的线性基。    

因为这样的话我们就可以先不重复地选数表示出 $a_l \sim a_r$ 的所有数，接着根据异或的性质，如果一个数在一连串异或中出现多次是可以抵消的，所以最后落实到原序列 $a$ 可以表示的每个数上，当前这个线性基里面的数也都呈选或不选两种情况。     

不得不承认这道题刷新了我对线性基的认识，事实证明数据结构不仅套数据结构很难，套一些很多和数据结构有较好的相容性的东西的话也挺难的……        
