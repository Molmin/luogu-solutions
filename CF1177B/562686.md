## 题意
输出序列 $123456789101112131415161718192021222324252627282930313233343536...$ 的第 $k$ 项。
## 思路
观察这个序列，发现这是由 $1$，$2$，$3$，$4$，$5$，$6$，$7$，$8$，$9$，$10$，$11$……一直连接起来得到的。

$k$ 的范围是 $10^{12}$，不能直接一位一位求出答案，需要利用找规律加快速度。

序列中所占位数：

一位数：$9\times1=9$ 位，

两位数：$90\times2=180$ 位，

三位数：$900\times3=2700$ 位，

……

我们可以利用此规律减去位数，加速程序。

```cpp
	x=9;y=1;
	while(k-x*y>0)k-=x*y,x*=10,y++,s+=x;//减去位数
	//y是位数，x表示有几个y位数
```

然后利用余数求出对应的 $y$ 位数要取的位数 $g$，并求出答案。

```cpp
	k%y==0?g=y:g=k%y;//取g位数 
	return cout<<(int)(pow(10,y-1)+(k-1)/y)/(int)pow(10,y-g)%10,0;//求出答案
```
## 代码
完整的~~高清可抄~~程序：
```cpp
#include<bits/stdc++.h>
#define int long long//不开long long见祖宗
using namespace std;
int k,x,y,s,g;
signed main(){
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	cin>>k;
	x=9;y=1;
	while(k-x*y>0)k-=x*y,x*=10,y++,s+=x;//减去位数
	//y是位数，x表示有几个y位数
	k%y==0?g=y:g=k%y;//取g位数 
	return cout<<(int)(pow(10,y-1)+(k-1)/y)/(int)pow(10,y-g)%10,0;//求出答案 
}
```
