  本题居然与2014年的某个比赛的第6题一样

  **~~真令我怀疑人生~~**

  本蒟蒻把攻破这道 **~~难~~** 题的算法一一列出来了，请各位自行查看。

  算法：枚举+暴力、模拟、连续一段

  本蒟蒻用的方法是：枚举 
    
    #include<iostream>
    #include<cstdio>
    #include<algorithm>
    #include<cmath>//本蒟蒻不想打万能文件头。 
    using namespace std;
    int n,h,maxx=-2100000000,xx,k;//定义变量。 
    int a[1000000+10];//定义数组。 
    int main()
    {
        scanf("%d",&n);//让我们知道此路有多长。 
        for(int i=1; i<=n; i++)
        {
            scanf("%d",&a[i]);//再让我们知道每个点的海拔。 
        }
        for(int i=1;i<=n;i++)
        {
            xx=i;//xx是下标，每一次循环定成i。 
            k=1;//k是宽。 
            while(a[xx]<=a[xx+1]&&xx+1<=n)//用while来循环，如果此点的海拔小于下一个点的海拔，下标+1小于n...... 
            {
                xx++;//下标++。 
                k++;//宽度++。 
            }
            //刚刚统计了上升的，现在再统计下降的。 
            while(a[xx]>=a[xx+1]&&xx+1<=n)//还是用while来循环，如果此点的海拔大于下一个点的海拔，下标+1小于n...... 
            {
                xx++;//下标++。 
                k++;//宽度++。 
            }
            maxx=max(maxx,k);//将得到的宽度与最大值比较，如果大于就替换（打擂台）。 
            k=1;//宽度重新赋1，因为要将此点也统计。 
        }
        cout<<maxx;//输出最大值。 

        return 0;//统计“山的宽度”，结束。 
    }