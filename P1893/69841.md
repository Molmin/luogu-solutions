将每个点作为山峰拓展的话代码很简洁

但是显然会有很多时间用到了错误答案的排除上


这道题正常来看都是从头到尾的检索

如果是根据数据的升降来判断“山”

**“每个点的检索可以只和其之前的有关”**

这样的话在输入的同时就可以进行判断当前是上升还是在下降

**每一组上升与下降都视为一座“山”**

**n[0]的值为0，这样即使从n[1]开始下降也无所谓**

**加入状态变量state判断当前是上升还是下降**

**相邻重复的高度要统计数量，这样与下一座山的重叠问题就解决了**

以下是代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int n[10010],N,ans=-1;
int main()
{
	scanf("%d",&N);
	int state=0;//状态：0为上升，1为下降
	int we=0;//单座山峰宽度的临时存储 
	int re=0;//重叠部分的计数 
	n[0]=0;//有些多余的初始化，主要是强调此时n[0]处为零 
	for(int i=1;i<=N;i++){
		scanf("%d",&n[i]);
		if(!state){			//当前状态为上升 
			if(n[i]>n[i-1]){we++;re=0;}
			if(n[i]==n[i-1]){we++;re++;}
			if(n[i]<n[i-1]){we++;re=0;state=1;continue;}}
		if(state){			//当前状态为下降 
			if(n[i]<n[i-1]){we++;re=0;}
			if(n[i]==n[i-1]){we++;re++;}
			if(n[i]>n[i-1]){ans=max(ans,we);we=re+2;re=0;state=0;}}}
	ans=max(ans,we);//还要判断最后一座山的宽度 
	printf("%d\n",ans);
	return 0;
}
```

100个随机数的话

时间是最开始山峰拓展方法的1/4（经对比一次后的结果）

（不过这道题时间绝对够用，要不要这1/4都一样囧）
