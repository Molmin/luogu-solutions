**前置知识**：欧拉回路（路径），并查集

------------

### 题目大意

给定 $m$ 个数对 $(l,r)$，现在需要构造出一个序列，使 $a_{i}=l,a_{i+1}=r$，问这个序列最短为多少？

### 解题思路

我们考虑，如果要使序列最短，就要使每个数对在序列中尽可能有重复的数字，即首尾相连。

提到首尾相连，我们会轻易的想到一个构建一个有向图（因为 $(l,r)$ 和 $(r,l)$ 不是一个东西，所以是有向图）。

因为我们要使每个数对都出现在序列当中，所以抽象到图中即为若干个不连通的连通块，我们可以很轻松的联想到多个不连通的欧拉路径（回路），求用最少的欧拉路径画满整个图与所经过的边数相加。

我们先考虑所经过的边数为多少。显然，即为整个图中的边数。

然后再考虑要用多少笔画完，再欧拉回路和欧拉路径两方面分别考虑。

- 因为在欧拉路径当中，只有一个终点和一个源点，它们至今不出或只出不进，所以出度入度和为奇数。那么每条欧拉路径中有两个奇数点，$n$ 条欧拉路径中就有 $2n$ 个奇数点，整个图中，欧拉路径的个数就是奇数点的个数除以 $2$ 吗？

	显然不是。我们考虑，如果有多条欧拉路径的源点与终点相同，那么源点或终点就应该再算一次，就不应该是奇数点的个数，就应该是入度出度之差的和除以 $2$。

- 在欧拉回路当中，有出必有回，所以出度入度之和为偶数。

	那这时，我们就可以用到并查集来维护欧拉回路。
   
   我们把每条相连的边并到一个集合当中，即为一个欧拉回路（路径）。遍历这个图中所有的点，如果它是这个集合中的祖先，也就遍历到了一个新集合，且这个集合在之前计算欧拉路径时没有被记录过，那么就代表它所在的集合为一个欧拉回路。直接计入答案。
   
综上所述，答案即为边的数目加奇数点入度出度之差的和除以 $2$ 加不同集合的个数（不包含欧拉回路）。

注：题目中可能会有重边，需要用 $\text{map}$ 去一下重。

```cpp
#include<bits/stdc++.h>
using namespace std;
int f[100001];
int din[100001],dout[100001];
bool vis[100001],is[100001];
map<pair<int,int>,int>mp;
int n,m,sum,ans,rep;
int find(int x)
{
	if(f[x]==x) return x;
	return f[x]=find(f[x]);
}
void merge(int x,int y)
{
	int p=find(x),q=find(y);
	if(p!=q) f[q]=p;
}
int main()
{
    for(int i=1;i<=1000;i++) f[i]=i;
	scanf("%d",&m);
	for(int i=1;i<=m;i++)
	{
		int x,y;
		scanf("%d %d",&x,&y);
		if(!mp.count({x,y}))
		{
			n=max(n,max(x,y));
			merge(x,y);
            is[x]=is[y]=1;
			din[y]++;dout[x]++;
		}
        else rep++;
	}
	for(int i=1;i<=n;i++)
		if((din[i]-dout[i])!=0) 
            vis[find(i)]=1,sum+=abs(din[i]-dout[i]);
	for(int i=1;i<=n;i++)
		if(!vis[i]&&f[i]==i&&is[i]) 
            ans++;
	printf("%d",m+(sum>>1)+ans-rep);
	return 0;
}
```
