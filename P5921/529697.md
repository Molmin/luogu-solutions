## 题目分析

感觉题解里上来就告诉你等价于某种欧拉路径问题有点抽象，我们不妨换个角度考虑这道题。

首先还是把每个限制抽象成一条有向边 $(a_i,a_i+1)$，那么整个序列就是一条路径，题意也就是可以随便加边，让你求一条最短的路径使得覆盖了所有给出的有向边。

然后注意到任两条路径都能通过在中间加一条边的方式合并起来。所以我们贪心地想，发现题意等价于求最小的路径条数使得能够走完图中所有边。这与一笔画（欧拉路径）问题类似，而事实上欧拉路径的结论确实可以拓展，即变成：一个 $\sum |in_i-out_i|=2k$ 的弱联通有向图可以用 $k$ 条有向路径覆盖所有边，并且至少用 $k$ 条路径才能覆盖所有边。证明如下。

1. 必要性：考虑从空图开始加路径的过程，每加入一条路径只会对两端点的 $|in_i-out_i|$ 产生至多 $1$ 的影响，故必要性得证。

2. 充分性：考虑归纳，我们在图上任选选一个 $in_i>out_i$ 的点 $i$ 和一个 $in_i<out_i$ 的点 $j$ 连边，新图上归纳假设存在 $k-1$ 条路径的覆盖方式，那么其中一条路径在这条边上断开后就形成了原图上 $k$ 条路径的覆盖方式。而 $k=1$ 时是欧拉路径问题，结论成立，故充分性得证。

故我们只需先把原图分成弱联通的子图，然后对于每个连通块分别求出答案，时间复杂度线性。

## 代码

数据实际上并没有重边，所以我没写判重。

```cpp
#include <bits/stdc++.h>
using namespace std;

int n,u,v,in[1005],out[1005],fa[1005],vis[1005],cs[1005],cntd,ans;
int getfa(int x) {return fa[x]==x?x:fa[x]=getfa(fa[x]);}

signed main()
{
	cin>>n; for(int i=1;i<=1000;i++) fa[i]=i;
	for(int i=1;i<=n;i++)
	{
		cin>>u>>v;
		int xx=getfa(u),yy=getfa(v); fa[xx]=yy;
		in[v]++; out[u]++; vis[u]=vis[v]=1;
	}
	for(int i=1;i<=1000;i++) if(vis[i]) cs[getfa(i)]+=abs(in[i]-out[i]);
	for(int i=1;i<=1000;i++)
	{
		if(getfa(i)==i&&vis[i]) ans+=max(1,cs[i]/2);
	}
	cout<<ans+n<<endl;
}
```
