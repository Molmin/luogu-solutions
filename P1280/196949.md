~~大家都说这是道dp水题，就我一个人不觉得吗 $\ \ \ \ \ \  $~~$QWQ$

~~众所周知~~，我们在这个题目里难以从前往后进行动态规划，那么在这种线性的区间题目里，我们不妨先去尝试下从后往前来解题，这可以说是一种经验，也可以说是一种套路。既可以是在线上从后往前，也可以是排序时的从大到小，这题就是按照时间线从后往前。

先来解释 为什么 。如果我们从前往后 dp 的话，我们在考虑到当前时间点的时候，我们要依次考虑选取的区间对答案的影响，这是一个非常庞大而且复杂的问题，最优的区间并没有任何特点，难以找出。但是如果我们如果从后往前 dp 的话，呵呵呵~


------------

如果当前时间点并没有任务的话，可以直接是前一个时间点的最大空闲时间+1。

如果当前时间点有任务的话，挨个遍历这些任务找，$f[i]$为$max(f[$这个时间点第1个任务的持续时间$+$当前时间点]，······)，就是考虑选取这个任务后，最大空闲时间为这些任务的结束时间上的最大空闲时间中的最大值。

伪代码如下：

```cpp
伪代码风格可能比较雷人，凑合着看 QAQ
	if(当前时间点没有任务)
		f[i]=f[i+1]+1;
	else//当前时间点有任务
		for(遍历一下这些任务)
		{
			f[i]=max(f[i],f[i+t[].持续时间]);
		}
```


------------

那么接下来就是一波代码了：
```cpp
#include<algorithm>
#include<iostream>
#include<cstdio>
using namespace std;
struct node//利用结构体
{
	int begin;
	int end;
}t[10010];
bool cmp(node a,node b)//按照时间开始点从大到小排序
{
	return a.begin>b.begin;
}
int sum[10010],f[10010],s=1;
//sum为各个时间点的任务数 s为当前正在考虑第几个任务
int main()
{
	int n,k;
	scanf("%d%d",&n,&k);
	for(int i=1;i<=k;i++)
	{
		scanf("%d%d",&t[i].begin,&t[i].end);
        //这里的end并不是结束时间 而是持续时间
		sum[t[i].begin]++;
        //当前时间点的任务数+1
	}
	sort(t+1,t+k+1,cmp);//排序
	for(int i=n;i>=1;i--)//从后往前
	{
		if(!sum[i])//当前没有任务
			f[i]=f[i+1]+1;
		else//当前有任务
		{
			for(int j=1;j<=sum[i];j++)//遍历所有任务
			{
				f[i]=max(f[i],f[i+t[s].end]);//找最大的
                s++;
			}
			
		}
	}
	printf("%d",f[1]);//输出时间点为1时的最大空暇时间
	return 0;
}
```
