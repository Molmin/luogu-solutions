好多逆推题解用到了排序，我这个蒟蒻根本看不懂啊QAQ

这是**不用排序、不用存每个任务**的逆推做法：~~（其实还是存了）~~

转移还是一样的，简单再说一下

`f[i]`表示从后往前推到时刻i的最大空闲时间。

首先，如果时刻i没有任务开始，我们就让`f[i] = f[i+1] + 1`。可能会有人怀疑i之前的时刻会不会也把i占用了，但是这个式子是没问题的，因为如果之前的任务会占用i，那么它转移的时候也用不着`f[i]`。

其次，如果时刻i有任务开始，我们肯定要选一个**任务结束之后空闲时间最大**的任务来做。我们读入的时候直接存储**在时刻i开始的任务是哪些**，转移的时候枚举，取最大值即可。存储这些任务，vector能很好地胜任。（在程序中为了节省空间省掉了存任务的数组，vector直接存了结束时间。实际上也只会用到结束时间，编号没有用）

Code:

```cpp
#include<bits/stdc++.h>
#define maxn 10008
using namespace std;
int n, k, p, t, f[maxn]; //p t只是用来输入的
vector <int> b[maxn]; //b[i]存储第i时刻开始的任务的结束时间 

int main(){
	cin>>n>>k;
	for(int i=1 ; i<=k ; i++){
		cin>>p>>t;
		b[p].push_back(t);
	}
	for(int i=n ; i>=1 ; i--){ //从后往前枚举时刻 
		if(b[i].empty()) f[i] = f[i+1] + 1; //i时刻没有任务开始
		else{
			for(int j=0 ; j<b[i].size() ; j++) //这一时刻有任务，枚举这些任务（的结束时间）
				f[i] = max(f[i], f[i + b[i][j]]); 
		}
	}
	cerr<<f[1]<<endl;
	return 0;
}
```