【设】f[i]表示1到i个时间最大空闲值。

【分析】本题是一道资源分配类动态规划。我们可以划分阶段的标准是时间和任务。如果尼克在一个时间点上没有接到任务，我们就让他延续他原来的空闲时段，现在空闲时间=上一个空闲点的空闲时间+1；如果这时有这个时间点开始的任务，我们就将其插入，有多个这样的任务供我们选择最优的。因为这个时间点尼克只有两个选择要么完成一个任务要么什么都不干，以开始时间来选择每一次都可以找到一个最优的。但是本题好在开始时间和完成时间都有一个严格的限定，所以我们可以不用考虑一个任务插入在哪个时间结束，只要根据开始时间和结束时间进行插入控制就行了。

【最优子结构】

本题的最优子结构可以建立在开始时间上，也可以建立在结束时间上。先说结束时间：

```delphi

j:=1;
for i:=1 to n do
   if p[j]+t[j]-1<>i then f[i]:=f[i-1]+1
   else
      while p[j]+t[j]-1=i do
         begin
         if f[i]<f[p[j]-1]
            then f[i]:=f[p[j]-1];
         inc(j);
         end;

```
上述程序看似完美，我们不难举出反例，如三个任务（1，6）（2，3）（1，4），我们看到因为输入数据只能保证开始时间严格排序，而不是结束时间，所以当j等于1的时候f[i]只会考虑情况一，因为在while循环中开始永远是因为玩不成而跳出，j值加不了1.

针对此问题只能在开始在对结束进行一个排序，时间上不够。

但是我们可以考虑用开始时间由大到小进行逆推求解，因为开始时间是互不干涉的，而且输入时就有顺序，具备无后效性。下面我们照此方法写方程。

【方程】

f[i]=f[i+1]+1     如果i<>p[j]

f[i]=max{f[i+t[j]]}如果p[j]=i
