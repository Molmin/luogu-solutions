类似等差数列求和的办法，考虑把整个直线倒过来，显然不改变答案，然后把每个线段的贡献依次加起来，不难发现每条线段都对此时的答案贡献了期望经过次数的 $2d_1+(2n-1)x$ 倍，于是我们算出 $d_1=1$，$x=0$ 时的答案，然后再乘上 $\dfrac{2d_1+(2n-1)x}2$ 就可以得到答案了。

然后考虑第一次推球之后，有 $\dfrac 1n$ 的概率会减少一段开头或结尾的线段，有 $\dfrac {n-1}n$ 的概率会等概率选取两条线段合并，只有当后者选中的线段恰好为第 $i$ 条线段时才会对第 $i$ 条线段产生影响，于是可以列出式子，新的第 $i$ 条线段长度的期望值为：
$$
d_1'=d_1+\frac {n-1}{n}\cdot \frac 1{n-1}\cdot 2d_1 = \frac {n+1}n\cdot d_1
$$
由于 $\dfrac{n+1}n$ 是确定的常数，所以若记 $e_i$ 表示第 $i$ 次推球后每条线段长度的期望，我们也可以得到：
$$
e_i = \dfrac {n-i}{n-i+1}\cdot e_{i-1},\ e_0 = d_1=1\implies e_i = \dfrac {n+1}{n-i+1}
$$
而第 $i$ 次推球移动的期望距离显然为 $e_{i-1}$，于是就有答案为：
$$
\dfrac{2d_1+(2n-1)x}2\sum_{i=2}^{n+1}\dfrac {n+1}{i}
$$
暴力计算即可，时间复杂度 $\mathcal O(n)$。

```cpp
typedef double ff;

int n, x, d;

int main() {
	scanf("%d%d%d", &n, &d, &x);
	ff ans = 0;
	for(int i = 1; i <= n; ++i) 
		ans += (ff)1 / (i + 1);
	ans *= (ff)(2 * d + (2 * n - 1) * x) / 2 * (n + 1);
	printf("%.12lf\n", ans);
	return 0;
}
```