在这道题里，我们可以将该序列中的任何一个数放到后面或前面，而我们要这个操作次数最少，那么我们就要使保持不动的点最多，而如果任意两个点（数）不动，**那么就不能将任何原本不在该两个数中间的数插入这两个数中间**。

因此，我们就要求出一个连续的最长子序列。

何为连续？

就是说该序列必须是最后的结果序列的**子串**

即，如果该数的前一个不同的数（pre）和后一个不同的数（next）都在之中，那么这个数必须全部都在pre和next中间。

所以我们可以一个数一个数考虑，并将可以存在的数放在单调队列中

条件1：该队列中的数在保证不减的同时保证原序号递增

条件2：同时如果该序列中将要放入b这个数，而a小于b，若大小等于a的数并没有全部在队列里，那么小于a的数都不能在队列里

代码中的注释应该可以有助理解

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,a[1000010],ans;
deque<int> q;//双端队列模拟单调队列
vector<int> b[1000010];
int main(){
    scanf("%d",&n);
    for(int i=1;i<=n;i++){
        scanf("%d",&a[i]);
        b[a[i]].push_back(i);//将同一个大小的数的id记录下来
        //（因为从前向后读入所以保持单调）
        m=max(m,a[i]);//最大的数是多少
    }
    for(int i=1;i<=m;i++){//从小到大将数加入单调队列
        int lt=b[i].size();
        for(int j=lt-1;j>=0;j--){
            int k=b[i][j];//拿出大小为i，id在i中大小为第j大及以后的数中最靠前的数的id
            //只要该数能放入队列中，序号比该数大，大小与它相同的都能放入
            while(!q.empty()&&q.back()>k){//把队列处理成能将k放入的状态
                while(q.size()>=1&&a[q.front()]<a[q.back()]) q.pop_front();
                //这个while保证条件二
                q.pop_back();
                //因为条件一，所以序号越大的数越在队列的后面
            }
            int lm=q.size();
            ans=max(ans,lm+lt-j);//更新答案
        }
        for(int j=0;j<lt;j++) q.push_back(b[i][j]);//将该数加入队列
    }
    printf("%d",n-ans);//答案是总长减去最长序列的长度
}
```

注意，队列的长度（即q.size()与int不是同一类型的变量，不能放max里比）~~（别问我为什么，我也不知道）~~

还有，STL的deque比手动模拟要慢，但加O2优化会比手动模拟要快