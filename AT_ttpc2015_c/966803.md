## 更新

1. 修改前置知识的问题。

1. 再次修复前置知识的问题，在此对浪费了管理宝贵时间做出道歉。

1. 前置知识的标题有误。

## 题意简化

给定一个字符串 $S$ 并对其进行一系列操作输出。

## 需要注意的地方

1. 日本题目要在输出加换行（我忘记加上，愣是浪费了一小时调这个问题）。

## 解法分析

这是一道很恶心的模拟。如果放在以前可以干掉大部分选手，还好 c++ 有 `string` 这个数据类型，要不然能调上几个小时。

我们依次来分析每个操作。

**步骤一与步骤二**

查找每个好的字符串，然后执行步骤三与步骤四。

这里有一个坑点：好的字符串的定义是在 `ookayama` 之前有若干个字符 `o` 的字符串为好的字符串，但仔细观察样例，它在处理最长好的字符串 $T$ 时，它处理的那部分其实是之前的若干个字符 `o` 再加上 `ookayama` 的前两个字符 `oo`，不仔细看还发不现。

代码其实还有一个可以优化的地方，就是步骤二中选择最长好的字符串可以不做。为什么？首先，字符串中好的字符串都要被处理，其次，一个好的字符串被处理后，它**一定不再是**好的字符串，并且**不会与之前的部分形成第二个好的**字符串。因此我们可以顺序（从左到右）修改好的字符串，选择最长的步骤可以去掉，如果加上去还可能会 TLE 两个点（亲身经验）。反正它不是强制让你输出每步结果。

我们就有了大体的解题思路：一直找好的字符串，剥离出要处理的部分，剩下的交给步骤三与步骤四。

代码就长成这样：

```cpp
//s是输入字符串 
int r=s.find("kayama",0);//找好的字符串右端点 
while(r!=-1){//当查找成功 
	int i=r;//下标 
    int cnt=0;//计数 
	while(i>0 && (s[i-1]=='o' || s[i-1]=='O')){//把好的字符串左端点与右端点剥离出 
     	cnt++;
      	i--;
	}
    string t=s.substr(i,cnt);//抓取好的字符串 
    if(t.length()>=3){//>=3的原因：好的部分是为ookayama前的两个oo和再前面的若干个o，但好的字符串
	                  //是在ookayama前面加若干个o，只有ookayama前的两个oo不能被作为好的字符串处理 
      	//步骤3与步骤4 
    }
    s.replace(i,cnt,t);//已经处理好的t还回去 
    r-=cnt;
    r+=4;
	//更新新的寻找好的字符串开始左端点 
    r=s.find("kayama",r);//从这个新左端点开始继续找好的字符串 
}
```
这里有三个关于 `string` 的函数，讲解一下。

### 前置知识：字符串的三个函数（可直接跳过）

- `find(x,y)`

表示从下标 $y$ 开始查找字符串 $x$ 的第一次出现位置，如果找到了返回它的左下标，否则返回 $-1$ 这么一个数。

- `substr(x,y)`

求出字符串中从下标 $x$ 到下标 $y-1$ 的子串。

- `replace(x,y,z)`

表示把下标 $x$ 到下标 $y-1$ 的字符替换成字符串 $z$。

### 知识讲解完毕

于是，步骤一和步骤二就做完了。

**步骤三与步骤四**

这个就相对简单一点了，按题意模拟就可以了。可能相对绕了点，但有前面两个字符串函数就简单多了。

中间部分就是这个样子：

```cpp
//t是剥离出来的好的字符串 
while(1){
    int p=t.find("oo",0);//查找oo 
    if(p==-1) break;//没有oo，跳出循环 
    t.replace(p,2,"O");//替换成O 
    p=t.find("OO",0);//查找最左边的OO 
    if(p!=-1) t.replace(p,2,"o");//有就换成o 
}
```

于是，这道题就做完了，的确很恶心吧，但好在有 `string` 的帮助，这道题最终过了。

等等！有个很重要的点：日本题目要换行（我忘记加上，愣是浪费了一小时调这个问题）！

最后说一句，我比较推荐万能头文件，这样可以省去很多不必要的麻烦。

## 完整代码

```cpp
//已通过 
#include<bits/stdc++.h>
//万能头文件 
using namespace std;
string s;
int main(){
	cin>>s;
	//s是输入字符串 
	int r=s.find("kayama",0);//找好的字符串右端点 
	while(r!=-1){//当查找成功 
		int i=r;//下标 
	    int cnt=0;//计数 
		while(i>0 && (s[i-1]=='o' || s[i-1]=='O')){//把好的字符串左端点与右端点剥离出 
	     	cnt++;
	      	i--;
		}
	    string t=s.substr(i,cnt);//抓取好的字符串 
	    if(t.length()>=3){//>=3的原因：好的部分是为ookayama前的两个oo和再前面的若干个o，但好的字符串
		                  //是在ookayama前面加若干个o，只有ookayama前的两个oo不能被作为好的字符串处理 
			//t是剥离出来的好的字符串 
			while(1){
			    int p=t.find("oo",0);//查找oo 
			    if(p==-1) break;//没有oo，跳出循环 
			    t.replace(p,2,"O");//替换成O 
			    p=t.find("OO",0);//查找最左边的OO 
			    if(p!=-1) t.replace(p,2,"o");//有就换成o 
			}
	    }
	    s.replace(i,cnt,t);//已经处理好的t还回去 
	    r-=cnt;
	    r+=4;
		//更新新的寻找好的字符串开始左端点 
	    r=s.find("kayama",r);//从这个新左端点开始继续找好的字符串 
	}
  	cout<<s<<endl;//换行！！！ 
	return 0;
}
```