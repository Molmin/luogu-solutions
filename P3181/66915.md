真是好题……。

关于单调栈的比较有技巧性的做法 

~~如果大佬认为没有技巧性就自动掠过~~：


我们要求的实际上就是：

$\sum_{Sa_i<n+1<Sa_j}min_{i\leq k\leq j }\ ht_k + \sum_{Sa_j<n+1<Sa_i}min_{j\leq k\leq i }\ ht_k$


从前往后维护一个单调递增的单调栈，为什么楼下大佬已经讲得很清楚了。

每个位置记$val$和$ht$，就是当前这个节点有的总数和的$ht$

这里按排名从后往前做。（为什么最后会讲）

先只考虑$S1$串插入，$S2$串查询。

我们每遇到一个串，就要判断是在$S1$还是在$S2$，如果在$S1$，就直接加上前面所有的答案之和。

然后弹栈，注意这个时候不是真正的弹，而是和之前的东西**合并**，因为现在的栈顶的最大元素已经不会取到了，所以可以将它与栈的第二个元素合并，也就是$val_{top-1}+=val_{top}$

也就是说本质上还不是单调栈，是维护一个最小值。

如果是在$S2$，$val_{top}$加一，也就是有一个新的元素入栈。

然后更新将加入答案的$now$。

至于为什么要从后往前做？因为$height$数组的定义是当前排名和上一排名的$lcp$。

也就是说如果从前往后做，那么对于排名$i$而言，查询$i-1$产生的贡献，将会是$i-2$和$i-1$的$lcp$，这样就不对了。

但是如果我们是从后往前，那么对于排名$i$而言，查询$i+1$产生的贡献，将会是$i$和$i+1$的$lcp$，这样就对了。

贴单调栈部分的代码：

```
ll sol(R b){
    ll res=0,now=0,rec=0;
    while(top)STK[top]=val[top]=0,top--;
    for(R i=n-1;i>=1;--i){
        rec=0;
        if((sa[i]>len1+1)^b)res+=now;
        while(STK[top]>=ht[i]&&top)
            now-=1ll*STK[top]*val[top],rec+=val[top--];
        STK[++top]=ht[i],val[top]=rec;
        if((sa[i]<=len1)^b)val[top]++;
        now+=1ll*val[top]*STK[top];
    }
    return res;
}
```

$b$表示的含义是：$S1$查询$S2$修改 或者 $S2$查询$S1$修改

最后的答案是$sol(0)+sol(1)$