首先考虑题目中章节与章节之间的关系。

假设要看懂第 $i$ 章，要先看懂 $a_1,a_2,a_3,...,a_k$ 章的内容。那么可以考虑把每个章节看作一个点，将 $a_1,a_2,a_3,...,a_k$ 章所代表的点向第 $i$ 章所代表的点连有向边。**于是整本书的章节关系就变成了一张有向图。**

再考虑看书的过程。

显然，看书时要先从没有前置章节的章节开始理解，然后再理解有前置章节的章节。转换到图上，就是从入度为零的点开始，逐一删掉这些点的连边，然后产生新的入度为零的点，再删边......于是，看书的过程被转换为了 **在一个有向图上拓扑排序的过程。**

接下来进一步考虑如何拓扑排序。

可以发现，题目要我们输出的是**至少看几遍书才能理解整本书的内容**。而看书的时候，**不能跳着看章节，而是要一章一章的往下看**。因此，不能直接使用朴素的拓补排序，应当加以修改。

首先可以想到一种很暴力的算法，就是模拟每次看书的过程并拓补排序。具体来说，就是循环遍历书的 $n$ 章，遇到一个新的可以理解的章节时就删边。很不幸的是，这个暴力算法在第四个测试点超时了。

考虑优化这一暴力算法。

注意到这个算法消耗时间最多的部分在于模拟看书的过程。如果最终答案与 $n$ 的乘积太大，超时是不可避免的。而实际上，**已经理解的章节不需要再被遍历到**。因此我们要考虑如何让每个章节只被遍历一次。

如果要求每个章节仅被遍历一次，我们需要回归到朴素的拓扑排序。但是朴素的拓扑排序存在一个显然的问题：**如何在排序中确定看书的先后顺序。**

我们再重新考虑看书的整个过程。可以发现，**看书时总是从编号小的章节看到编号大的章节**。因此，我们可以用小根堆，每次取出编号最小的章节观看。这样就保证了看书的章节顺序。

但这里又存在一个新的问题：假设看书看到第 $4$ 章时，第 $3$ 章和第 $5$ 章的前置章节都看完了。这时程序把 $3$ 和 $5$ 一起放进小根堆。那么看下一章时，程序从堆中取出的章节是 $3$，但是我们看书已经看到第 $4$ 章了，不能跳回去看第 $3$ 章，于是我们的答案就出错了。

从另一方面想，既然看到第 $4$ 章时，我们发现可以理解第 $3$ 章了，**为什么不把第 $3$ 章放进下一轮看书的安排中呢**？于是我们开两个小根堆，一个存储当前在看的章节，一个存储下一次能看的章节。当删完边出现新的能理解的章节时，可以把比当前章节序号大的章节加到正在用于排序的堆中，把比当前章节序号小的章节加到另一个堆中。然后在排序过程中轮流使用这两个堆，就得到答案了。

最后考虑如何判定无解。可以在排序过程中统计看的章节数量。如果统计结果最后没有 $n$ 章，即可判定为无解。

至此，此题得解，下面是代码：

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<queue>
#define ll long long
#define rgt register int
using namespace std;

const int mxn = 2e5+5;
int tot,n,cnt,ans;
int nxt[mxn],lst[mxn],to[mxn],kn[mxn];
priority_queue < int , vector<int> , greater<int> > que[2];

inline void add(int a,int b){
	tot++;
	to[tot]=b;
	nxt[tot]=lst[a];
	lst[a]=tot;
}   //连边

int main(){
	int test,chp,q=0;
	scanf("%d",&test);
	while(test--){
		
		scanf("%d",&n);
		memset(kn,0,sizeof(kn));
		memset(lst,0,sizeof(lst));
		for(rgt di,i=1;i<=n;i++){
			scanf("%d",&di);
			for(rgt d,j=1;j<=di;j++){
				scanf("%d",&d);
				kn[i]++;
				add(d,i);
			}
		}  //数据读入与连边建图
		
		for(rgt i=1;i<=n;i++){
			if(!kn[i]){
				que[q].push(i);
			}
		}  //把不需要前置章节的章节先放进堆里面
		
		ans=cnt=0;　　//cnt统计理解的章节数量，ans统计看书次数
		while(!que[0].empty()||!que[1].empty()){
			ans++;
			while(!que[q].empty()){
				chp=que[q].top();
				que[q].pop();
				cnt++;
				for(rgt i=lst[chp];i;i=nxt[i]){
					kn[to[i]]--;
					if(!kn[to[i]]){
						if(to[i]>chp)  
							que[q].push(to[i]);  //把编号大的章节加入当前堆中
						else
							que[q^1].push(to[i]);  //把编号小的章节加入另一个堆中
					}
				}
			}
			q^=1;  //转换，使用另一个堆
		}
		
		if(cnt!=n)  //判定是否无解并输出答案
			printf("-1\n");
		else
			printf("%d\n",ans);
	}
	return 0;
}
```
