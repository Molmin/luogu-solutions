# 题目大意

你有一本书，它共有 $n$ 章，某些章节有**前置章节**，即若第 $u$ 章是第 $v$ 章的前置章节，而你当前又没有看懂第 $u$ 章，那么，你当前一定看不懂第 $v$ 章，显然，没有前置章节的章节一遍就能看懂。（一个章节的前置章节可能不止一个）

你可以一遍一遍从前往后的看这本书，问：你最少要读几遍这本书，才能将它的所有章节全部看懂。若你永远不能看懂所有的章节，那么输出 $-1$.

数据范围：

$1 \le T \le 2 \cdot 10^4$, $1 \le n \le 2 \cdot 10 ^ 5$, $\sum{k_i} \le 2\cdot 10^5$.



# 思路

首先，我们对每个章节的前置章节向该章节建单向边，然后判环，如果有环，输出 $-1$ 即可。（想一想，为什么？）

显然，若第 $u$ 章是第 $v$ 章的前置章节，而第 $v$ 章又是第 $u$ 章的前置章节，那你一定看不懂这两章。

进一步思考，发现如果建出来的图中有环，那么一定存在：第 $u$ 章是第 $v$ 章的前置章节的前置章节的前置章节······，而第 $v$ 章又是第 $u$ 章的前置章节，这样的关系。那你也一定看不懂这些章。

建出图后，我们使用时间复杂度为 $\Theta(n + m)$ 的拓扑排序算法来判环。（不会拓扑排序请出门右转 OI Wiki）

然后，我们开始思考如何求答案。

这里使用**动态规划**来解决这个问题。

定义状态 $f(i)$ 表示看懂第 $i$ 章最少需要读多少遍书。

状态转移方程：
$$
f(v)=\max(f(u)+(u>v))
$$
（ $u$ 为 $v$ 的前置章节 ）

想一想，为什么？

因为如果 $u < v$, 那么我们可以在一遍中把第 $u$ 章和第 $v$ 章都看懂；否则就需要再看一遍了。

答案显然是 $\max\limits^{n}_{i=1}f(i)$.

那这个动态规划如何实现呢？观察发现，这个动态规划的状态转移方程像极了最短路（这里是最长路）的松弛操作。

所以我们跑个最长路就行了。

但有几个问题需要解决：

1. 这并不是单源最短路，每一个入度为 $0$ 的结点都是源点。
2. 大部分最短路算法时间复杂度都是 $\Theta(n \log n)$ 的，但是，从数据范围可以看出来，时间复杂最好是 $\Theta(n)$.


解决方法有两个：

1. 把所有入度为 $0$ 的点入队，并且将边权乘 $-1$，跑 $0$,$-1$ **最短路** 即可。具体的实现是使用双端队列：如果边权为 $-1$，将扩展的结点从队首入队；如果边权为 $0$，则将扩展出来的结点从队尾入队。最后再将答案乘 $-1$。这样可以达到优先队列的效果，时间复杂度线性。
2. 其实我们可以在跑拓扑排序的同时跑最长路。在删除结点时与其连接的结点做松弛操作即可。


法二证明：

显然，连接一个结点的所有结点（即前置章节）一定比它更早删除。所以，它的所有前置章节都会来更新它一次，与状态转移方程符合，证毕。

# 实现

这里用的是法二~~因为好写~~。

不建议看代码，最好自己写。

$code:$

```cpp
#include <bits/stdc++.h>
 
#define max(a, b) (a > b) ? a : b
 
const int Maxn = 2e5 + 10; 
 
int T;
int n;
 
struct edge {
	int to, nxt; 
} e[Maxn];
int head[Maxn], tot;
 
int cnt[Maxn];
int f[Maxn]; 
 
void init() { // 初始化别忘
	memset(head, 0, sizeof(head)); tot = 0;
	memset(cnt, 0, sizeof(cnt));
	memset(f, 0, sizeof(f));
}
 
void add_edge(int x, int y) {
	tot++;
	e[tot].to = y;
	e[tot].nxt = head[x];
	head[x] = tot; 
}
 
std::queue<int> q; 
int top_sort() {
	int i;
	for (i = 1; i <= n; i++) {
		if (cnt[i] == 0) {
			q.push(i);
			f[i] = 1; // 所有入度为 0 的点都可以一遍看懂
		}
	}
	while (!q.empty()) {
		int x = q.front(); q.pop(); 
		for (i = head[x]; i; i = e[i].nxt) {
			int y = e[i].to;
			f[y] = max(f[y], f[x] + (x > y)); // 松弛操作
			cnt[y]--;
			if (cnt[y] == 0) {
				q.push(y);
			}
		}
	}
	int ans = 0; 
	for (i = 1; i <= n; i++) {
		if (cnt[i] != 0) return -1; // 如果没删干净，就是有环
		ans = max(ans, f[i]); // 统计答案
	}
	return ans; 
}
 
int main() {
	int i, j;
	scanf("%d", &T);
	while (T--) {
		init(); 
		scanf("%d", &n);
		for (i = 1; i <= n; i++) {
			int k;
			scanf("%d", &k);
			for (j = 1; j <= k; j++) {
				int x;
				scanf("%d", &x);
				add_edge(x, i); // 建反向边
				cnt[i]++; 
			}
		}
		printf("%d\n", top_sort()); 
	}
	return 0; 
}
```

最慢的一个点 $1.3s$, 轻松通过。

**update:**

- 2021-10-6: 完善了法一并修改了一些细节。