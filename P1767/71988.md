在本题中，相邻状态指的是搜索某个家族的所有成员时，与当前成员相邻
的成员的位置，每个状态要记录的信息包括所处的行列值，这里需要注意
的是广度搜索只是完成了同一个家族成员的搜索，我们要求解的是家族数，
因此我们需要遍历所有的元素。

基本思路是：
对于每一个元素，如果该元素为小写字母，代表是一个姓氏，如果该位
置没有被搜索过，则家族数加一，然后使用广度优先搜索算法标记该家族
的所有成员为已访问。
```cpp
#include <iostream>
#include <string>
#include <queue>
using namespace std;

/************************************************************
广度优先搜索算法的基本思想：
1、对于初始状态入队，设置初始状态为已访问
2、如果队列不为空时，出队队头元素，否则跳到第5步
3、检查出队的元素是否为最终解，如果是则跳到第5步。
4、对于出队的元素，检查所有相邻状态，如果有效并且未访问，则将
   所有有效的相邻状态进行入队，并且设置这些状态为已访问，然后
   跳到第2步重复执行
5、检查最后出队的元素是否为最终解，如果是输出结果，否则说明无解

广度优先搜索是借助于队列这种数据结构进行搜索的，队列的特点是先
进先出（FIFO），通过包含queue这个队列模板头文件，就可以利用c++
的队列模板定义自己的队列了，队列的操作非常简单，主要有以下几个：
q.push() 入队操作
q.front() 取队头元素
q.pop() 队头元素出队
q.size() 获取队列的元素个数
q.empty() 判断队列是否为空，为空返回true，不为空返回false

广度优先搜索算法的关键是要搞清楚求解过程中每一步的相邻状态有哪些，
每个状态需要记录什么信息，在搜索过程中如何标记这些状态为已访问。
*************************************************************/

//定义队列元素的类型，QElement为结构类型，使用typedef可以定义一个新的类型名称，在程序中QElement就像int、float一样，作为一个数据类型的名称使用
typedef struct {
	int row;  //当前搜索的家族成员所处的行
	int col;  //当前搜索的家族成员所处的列
} QElement;

queue<QElement> q; //定义元素类型为QElement的队列q
string s[100];  //数组s用于记录输入数据
int visited[100][200]={0};  //visited用于记录每个元素是否访问过
int n,ans;  //ans用于记录发现的家族数
int movex[]={ 1, 0,-1, 0};  //数组movex表示与当前元素相邻的元素的行差值
int movey[]={ 0, 1, 0,-1};  //数组movex表示与当前元素相邻的元素的列差值

//函数bfs用于搜索包含某个元素（row行，col列）的所有家族成员，并且搜索过程中将所有家族成员标志为已访问
void bfs(int row,int col)
{
	int i,j,k;
	QElement e1,e2;
	
	e1.row=row;
	e1.col=col;
	q.push(e1);  //初始状态入队
	visited[row][col]=1;  //设置当前状态为已访问
	while (!q.empty())  //当队列不为空时，继续宽度优先搜索
	{
		e2=q.front();   //获取队头元素
		q.pop();  //队头元素出队（注意：c++的队列模板类中，获取队头元素并不会将该元素从队列中删除，需要使用pop函数删除该元素）
		for (k=0; k<4; k++)  //对于当前元素，检查上下左右四个方向的元素
		{
			i=e2.row+movex[k];
			j=e2.col+movey[k];
			//第i行第j列元素有效，并且该元素为小写字母，并且未访问过，则入队并且标记为已访问
			if (i>=0 && j>=0 && i<n && j<s[i].length() && s[i][j]>='a' && s[i][j]<='z' && visited[i][j]==0)
			{
				e1.row=i;
				e1.col=j;
				q.push(e1);
				visited[i][j]=1;
			}
		}
	}
}

int main()
{
	string s1,s2;
	int i,j,k;
	
	cin >> n;
	getline(cin,s1);  //先输入一行数据
	i=0;
	if (s1!="") s[i++]=s1; //检查第一行输入数据是否有效，如果有效，则接下来的循环从第二行开始输入（i=1），否则接下来从第一行开始输入（i=0）
	for (; i<n; i++)
	{
		getline(cin,s[i]);
	}
	
	ans=0;
	for (i=0; i<n; i++)
	{
		k=s[i].length();
		for (j=0; j<k; j++)
		{
			//遍历所有元素，如果某个元素为小写字母，并且未访问过，说明发现一个新的家族
			if (s[i][j]>='a' && s[i][j]<='z' && visited[i][j]==0)
			{
				ans++;  //家族数加一
				bfs(i,j);  //遍历该家族的所有成员并且将所有成员标记为已访问，以防止重复计算家族数
			}
		}
	}
	cout << ans;
}
```
