先将每一个 $a_i$ 二进制拆分。

因为每一位的 $\text{xor}$ 运算是互不影响的，于是可以考虑每一位。

从高位到低位考虑，因为 $a_i \le 2^{30}-1$，所以二进制状态下的 $a_i$ 的长度是 $\le 29$ 的。

假设在考虑 $bit$ 位，则有 $2$ 种情况：

1. 当前考虑的所有数的第 $bit$ 位都是 $0$ 或 $1$。

1. 当前考虑的所有数的第 $bit$ 位 $0$ 和 $1$ 都有。

第 $1$ 种情况显然可以使最后答案第 $bit$ 位变为 $0$。

第 $2$ 种情况：数组 $c$ 存储第 $bit$ 位为 $0$ 的数，数组 $d$ 存储第 $bit$ 位为 $1$ 的数。

此时最后答案的第 $bit$ 位肯定为 $1$。

但是如果 $x$ 的第 $bit$ 位为 $0$，便只需考虑 $d$ 数组了。同理，若 $x$ 的第 $bit$ 位为 $1$，便只需考虑 $c$ 数组了。

分别搜索 $x$ 的 $bit$ 位为 $1$ 和 $0$ 即可。

直接搜索的话，参数需要传递数组，跑得很慢。
可以先排序，传递的参数变为下标。

时间复杂度：$\mathcal{O}(2^{\log_2n}+n\log n)=\mathcal{O}(n\log n)$

双倍经验：ABC281F

[评测记录](https://www.luogu.com.cn/record/97514702)