比较简单的一道模拟题。
分析题目，我们可以知道:

**第三天和第四天所拿到的同一本笔记本的两位同学必定是朋友关系。**


举个栗子：

设当前一共有 $4$ 位同学，每位同学的朋友关系如下：
- $1$ 与 $2$；
- $2$ 与 $3$；
- $3$ 与 $4$；
- $4$ 与 $1$。

(注意一个人可能有很多的朋友，但最好的朋友只有一个，而且如果 A 的最好的朋友是 B ,但是 B 的最好的朋友未必是 A。)

于是我们就有了一张类似于并查集的表 $f$:

$f[1] = 2,f[2] = 3,f[3] = 4,f[4] = 1;$

好，现在我们来模拟一下这个过程：

第一天第 $i$ 个笔记本分别对应的同学序列 $a_i$ 为：$ 1, 2, 3, 4 $ 。(因为是第一天，所有人的笔记本都在自己手上。)

第二天:
- $1$ 的**手上的**笔记本交换到了 $2$ 的手上；
- $2$ 的**手上的**笔记本交换到了 $3$ 的手上；
- $3$ 的**手上的**笔记本交换到了 $4$ 的手上；
- $4$ 的**手上的**笔记本交换到了 $1$ 的手上。

形成的序列是 $4, 1, 2, 3$ 。

**第三天**（输入的数据来了）:\
~~(还是一样)~~
- $1$ 的**手上的**笔记本交换到了 $2$ 的手上；
- $2$ 的**手上的**笔记本交换到了 $3$ 的手上；
- $3$ 的**手上的**笔记本交换到了 $4$ 的手上；
- $4$ 的**手上的**笔记本交换到了 $1$ 的手上。

但是~~~~~~~~~~

------------
由于同学们只会把自己**手上的**笔记本交给自己的朋友，他们却不知道手上的是不是他们自己的 (~~话说这是不是侵犯版权~~)。所以形成的序列是：

$3,4,1,2$

再接下去就是 

$2,3,4,1$

那我们从过程里可以看出：原本在 $1$ 手上的 $3$ 号笔记本到了 $2$ 手上，于是我们就能发现 $f[1] = 2$。以此类推,第四次的序列为:

$2,3,4,1$

与 $f$ 恰恰相同。

剩下的容大家自己推吧，上代码：
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int read(){
	int sum=0,f=1;
	char ch=getchar();
	for(;!isdigit(ch);ch=getchar()) if(ch=='-') f=-1;
	for(;isdigit(ch);ch=getchar()) sum=(sum<<3)+(sum<<1)+(ch^48);
	return sum*f;
}
void write(int x){
	if(x<0) putchar('-'),x=-x;
	if(x>9) write(x/10);
	putchar('0'+x%10);
	return;
}
const int inf=1e10;
const int N=1e7+10;
int a[N], b[N], s[N];
signed main(){
	int n = read ();
	for (int i = 1; i <= n; ++ i) a[i] = read ();
	for (int i = 1; i <= n; ++ i) b[i] = read ();
	for (int i = 1; i <= n; ++ i) s[a[i]] = b[i];
	for (int i = 1; i <= n; ++ i) write (s[i]), putchar (' '); 
	return 0;
}
```
$Thank$ $you$ $for$ $reading$~~