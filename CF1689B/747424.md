## 题意
给你一个长度为 $n$ 的排列，让你用这 $n$ 个数组成一个新的的数列，使得这两个排列之间的任意一个相同位置的元素都不相同，且满足这个排列的字典序最小。如果无法构造出这样的序列则输出 $-1$。
## 思路
我们在构造数组时，必须让每个位置上的元素不同，当 $n$ 等于 $1$ 时，两个数列肯定相同，所以先在代码中进行判断。
```cpp
if(n==1){
    cout<<"-1\n";
    continue;
}
```
我们需要定义三个数组，数组 $a$ 存放第一个数列，数组 $s$ 存放答案，也就是第二个数列，数组 $b$ 是标记数组，记录这个数有没有用过。

由于要求字典序最小，所以双层循环从头枚举每一个 $j$ 和 $a_i$ 是否相等并且判断这个数之前用没有过，如果既不相等，也没用过，它就是答案，把它存进 $s$ 数组，并把这个数标记为用过，跳出循环。

最后再进行一次特判，如果第一个数列第 $n$ 个数是 $n$，并且第二个数列其它数都用了，不得不放 $n$ 时，把 $s_n$ 和 $s_{n-1}$ 交换，这个问题就解决了。
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[1010],s[1010],b[1010],_;
int main(){
	cin>>_;
	while(_--){
		cin>>n;
		for(int i=1;i<=n;i++)cin>>a[i];
		if(n==1){
            cout<<"-1\n";
            continue;
        }
		memset(b,0,sizeof(b));
        s[n]=0;
		for(int i=1;i<=n;i++){
			for(int j=1;j<=n;j++){
				if(j!=a[i]&&!b[j]){
					s[i]=j;
                    b[j]=true;
                    break;
				}
			}
		}
		if(!s[n])s[n]=s[n-1],s[n-1]=a[n];
		for(int i=1;i<=n;i++)cout<<s[i]<<" ";
		cout<<endl;
	}
	return 0;
}
```
