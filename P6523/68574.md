蒟蒻第一次写题解，如有不清楚的地方请指出qwq

------------

题目描述：

对于每一组给出 $n-1$ 个数，输出 $n$ 个数，使得第 $i$ 个数乘第 $i+1$ 个数等于原本的第 $i$ 个数。


------------

本题一眼看上去非常难 ~~（至少在我看来是这样）~~ ，因为 $a_i$ 和 $m$ 最大能够达到 $10^{18}$ 这样一个量级。如果我们直接暴力枚举每个数的因数并判断是否为质数的话是绝对会TLE的，所以我们要考虑其他的解决办法。

首先从题目描述中可以看出 $b_{i-1} \times b_i=a_{i-1}$ ，$b_i \times b_{i+1}=a_i$ 。因为 $b_{i-1}$ 和 $b_{i+1}$ 均为质数，所以 $b_i$ 为 $a_{i-1}$ 和 $a_i$ 的最大公约数。

通过观察题目（若不考虑 $b_i$ 在 $\left [1,M \right ]$  范围内的条件，必然有至少一组合法解），我们可以发现，只要确定某两个数（设为 $a_{i-1}$ 和 $a_i$ ）之间的最大公约数（设为 $b_i$ ），就一定能推出来所有数两两之间的最大公约数（  $b$  ），且必定是质数。因为如果 $b_i$ 不为质数，则不可能有合法的解，与题目给出的条件相冲突，因此可得出 $b_i$ 必定为质数。

那么如何从 $b_i$ 推导到其他的数呢？因为 $b_i$ 是 $a_{i-1}$ 的因数之一，所以可以通过 $b_{i-1} \times b_i=a_{i-1}$ 的变形 $b_{i-1}=\dfrac{a_{i-1}}{b_i}$ 得到 $b_{i-1}$ 。同理可根据 $b_{i+1}=\dfrac{a_i}{b_{i+1}}$ 得到 $b_{i+1}$ 。以此类推就可以得到完整的 $b$ 数组了。

但是有一点很关键，就是 $a_{i-1}$ 和 $a_i$ 不能随便选取，因为相邻的两个数可能相同。如果 $a_{i-1}=a_i$ ，那么得出的 $b_i$ 就会是两者自身（也就是一个因数），与题目要求相违背。那么我们该如何选取 $a_{i-1}$ 和 $a_i$ 呢？ 

再仔细观察一下（ $\exists a_i$ ， $a_j$， $a_i$ != $a_j$ ），我们可以得出一个结论，一定有两个相邻的数不同（请读者自证）。因此必定有两个相邻的数具有既不为 $1$ 也不为两者自身的公约数，即上一段中所提到的 $a_{i-1}$ 及 $a_i$ ，而这两个数的最大公约数就是我们最初需要确定的 $b_i$ 。所以只要判断得出的结果 $b$ 是否比 $m$ 大即可。

已加入防抄袭措施，马蜂略丑轻喷qwq

```cpp
#include<bits/stdc++.h>
#define ll long long
#define INF 0x7f7f7f7f
#define rei register int
#define il inline
#define max(x,y) ((x)>(y)?(x):(y))
#define min(x,y) ((x)<(y)?(x):(y))

using namespace std;

int T;//组数
int n,m;
ll a[100005],b[100005];//开两个数组，b数组用来记录两数之间的最大公约数
int tag;//记录两个相邻的不同的数的位置
bool f;//记录是否有公约数比m大

ll gcd(ll x,ll y)//求两个数之间的最大公约数（递归版）
{
	if (x==y)
		return x;
	if (x<y)
		swap(x,y);
	if (x%y==0)
		return y;
	return gcd(y,x%y);
}

signed main()
{

	read(T);
	while (T--)
	{
		read(n,m);
		f=0;//每输入一组数据标记一定要归0！
		for (ri i=1;i<n;i++)//记住a的数量为n-1而不是n
		{
			read(a[i]);
			if (i>1&&a[i]!=a[i-1])//如果相邻的两个数不同
				tag=i;//记录位置
		}
		b[tag]=gcd(a[tag-1],a[tag]);//算出a[tag-1]和a[tag]的最大公约数
		if (b[tag]>m)//如果a[tag-1]和a[tag]的最大公约数比m大
			f=1;
		for (ri i=tag-1;i>=1&&!f;i--)//从tag-1到1进行计算
		{
			b[i]=a[i]/b[i+1];//因为是求因数，所以只需进行除法便可计算出另一个因数
			if (b[i]>m)//如果另一个因数比m大
				f=1;
		}
		for (ri i=tag+1;i<=n&&!f;i++)//从tag+1到n进行运算
		{
			b[i]=a[i-1]/b[i-1];//由于i最后到n，所以要-1
			if (b[i]>m||!Miller_Rabin(b[i])||b[i]*b[i-1]!=a[i-1])//同上
				f=1;
		}
		if (f)//如果有标记（即不符合条件）
			print(-1,'\n');
		else
		{
			for (ri i=1;i<n;i++)
				print(b[i],' ');
			print(b[n],'\n');
		}
	}
	return 0;
}
```
如果有不懂的地方随时欢迎在留言板下留言