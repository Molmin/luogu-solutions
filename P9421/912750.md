## [P9421 [蓝桥杯 2023 国 B] 班级活动](https://www.luogu.com.cn/problem/P9421)

抢第一波题解。

## 题目大意

给定长度为 $n$ 的序列 $a$，目标状态是

> $\forall i \in a$，都**有**且**仅有**另一个 $a$ 的元素与其相等。

求要更改几个元素才能变成目标状态。

## 代码分析

我们可以先建立一个 `map` 来存储每一个值在 $a$ 中出现的次数。

```cpp
int n, a;
map<int, int> mp;
```

```cpp
cin >> n;
while (n--) cin >> a, mp[a]++;
```

这个时候我们可以把更改的操作分为 $2$ 类：

1. 补充：$a_i$ 出现次数为 $1$ 时，需要另找一个 $a_j \gets a_i$。
2. 删除：$a_i$ 出现次数 $> 2$ 时，需要删除到只剩 $2$ 个。

于是我们可以记录一下操作「补充」和操作「删除」分别所用的次数。

```cpp
int cnt1 = 0, cnt2 = 0;
   ^- 补充 -^ ^- 删除 ^-
```

```cpp
for (auto [_, i] : mp) // C++17 特性，自行 BDFS
    if (i == 1) cnt1++;
    else cnt2 += i - 2; 
    ^- 由于 i = 2 时要更改的次数为 0，而 2 - 2 也等于 0，无需特判。
```

接下来就到了**最关键**的部分。由于「补充」「删除」都要操作别的数，如果**单纯相加**肯定会出现「供不应求」的情况。

万事先举栗。首先我们举个栗子：

```plain
1 2 2 2
```

发现可以在「补充」的情况下**同时「删除」**。只要 $a_4 \gets a_1$ 即可。

多造几组数据就可以发现，当 $cnt_1 \leq cnt_2$，「补充」操作就可以融入「删除」中并为 $1$ 次操作，而没法融入的还要单独「删除」。总共只需 $cnt_2$ 步。

而如果 $cnt_1 > cnt_2$ 呢？再举个栗子：

```plain
1 2 3 4 4 4
```

这个时候 $cnt_1 = 3, cnt_2 = 1$。首先可以按照之前那样，抵消掉 $cnt_2$：

```plain
4 2 3 4 4 4
```

此时操作了 $cnt_2$ 步。

剩下的 $2, 3$，只要把其中一个改为另外一个即可。因为 $cnt_1 + cnt_2$ 是 $n$ 减去一些 $2$ 的结果，是偶数，则 $cnt_1 \equiv cnt_2 \pmod 2$，所以剩下的必是偶数个。

此时又要操作 $\dfrac{cnt_1 - cnt_2} 2$ 步，合计 $\left(cnt_2 + \dfrac{cnt_1 - cnt_2} 2\right)$ 步。

## 完整代码

代码有手就行。

```cpp
#include <bits/stdc++.h>
using namespace std;

int n, a, cnt1, cnt2;
map<int, int> mp;

int main() {
    cin >> n;
    while (n--) cin >> a, mp[a]++;
    for (auto [_, i] : mp)
        if (i == 1) cnt1++;
        else cnt2 += i - 2;
    cout << (cnt1 <= cnt2 ? cnt2 : cnt2 + (cnt1 - cnt2) / 2);
}
```