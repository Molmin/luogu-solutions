[题目传送门](https://www.luogu.com.cn/problem/P9421)

# $1.$ 题意
给定一个数列，求最少变化多少个数可以使每个数有且只有一个数和他相等。
# $2.$ 思路
由题目可以想到，我们可以将数列中的数大致分为三种：
### $1.$ 刚好有两个学号相同
这种情况不做改变即可符合题意。
### $2.$ 有大于两个学号相同
这种情况需要将多的改变为其他学号。
### $3.$ 只有一个学号
这种情况需要有多的学号转化成该学号或把该学号转化成另一个只有一个的学号。


------------

那么，他们对答案的贡献分别是：

情况 $1$：无。

情况 $2$：$ ans \leftarrow$ 数量 $ - 2$。

情况 $3$：若有多的学号转化成该学号，那么无，否则 $ ans \leftarrow ans+1$。

根据以上情况，设情况 $2$ 有 $d$ 种，情况 $3$ 有 $ss$ 种，那么如果 $ss>d$，则结果为 $(ss-d)/2+d$，否则结果为 $(d-ss)+ss$。
# $3.$ 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long//好习惯防见祖宗
int n,s,t[100001],ans=0,d=0,ss=0;
signed main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>s;
		t[s]++;//桶来储存每个学号出现情况
	}
	for(int i=1;i<=n;i++){
		if(t[i]>2){
			d+=t[i]-2;//情况2
		}
		if(t[i]!=0&&t[i]<2){
			ss+=2-t[i];//情况3
		}
	}
	if(d>=ss){//情况2、3抵消（就是2多的转到3少的）
		ans+=ss;
		d-=ss;
		ss=0;
	}
	else{
		ans+=d;
		ss-=d;
		d=0;
	}
	cout<<ans+d+ss/2;//加上剩余，ss/2的原因是两个差1的只需要变一次即可
	return 0;
} 
```