显然 ，把第一个或者第二个序列翻转，剩下的任务就可以看做是公共子序列的个数.

反转后，设$f[i][j]$表示长序列里前i个，短序列里前j个得到的方案数。

```
ACACAAG
ACG
```

比如求$f[7][3]$，此时$A[7]=B[3]$，都为字母G。所以7以前所有的$AC$都可以接上这个$G$，而之前6个字母已经组成的$ACG$也算在内，即$f[7][3]+=f[6][2]+f[6][3]$

所以$f[i][j]=f[i-1][j-1]+f[i-1][j],A[i] == B[j]$，否则$f[i][j]=f[i-1][j]$。

由于$f[i][]$只会由$f[i-1][]$得到，$f[][j]$只会由$f[][j]$和$f[][j-1]$得到，所以倒序枚举可以省去第一维。

边界： 没有任何字符的方案数应设为1（$f[0]=1$）。否则加来加去都是0。

**另外：这道题答案超过了__int128的范围，需要用到高精。**

```cpp
int N,M;
char A[2005],B[2005];

int main()
{
    scanf("%d%d\n",&N,&M);
    scanf("%s\n%s",A+1,B+1);
    for (register int i=1; i<=M; i++)
	{
		if (B[i] == 'A') B[i] = 'T';
		else if (B[i] == 'T') B[i] = 'A';
		else if (B[i] == 'C') B[i] = 'G';
		else if (B[i] == 'G') B[i] = 'C';
	}
    f[0].d[0] = f[0].size = 1;
    for (register int i=1; i<=N; i++)
        for (register int j=M; j>=1; j--)
            if (A[i] == B[j]) f[j]+=f[j-1];
    f[M].output();
} 
```

