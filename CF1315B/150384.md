# 题目大意
Petya 手上有 p 块钱，他开完了派对，想回家。

回家的路上有 n 个路口，每个路口都有一个公交车站（用‘A’表示）或一个电车站（用‘B’表示）。Petya 的家就在

他每次都可以花 a 块钱从一个路口坐到另一个路口，并且这两个路口之间的车站要都是公交车站（包括起点但不包括终点）。

同样地，他每次都可以花 b 块钱从一个路口坐到另一个路口，并且这两个路口之间的车站要都是电车站（包括起点但不包括终点）。

但是 Petya 的钱可能不够，所以他要走一段路。但是他一但坐了车就不想走路了。问他最少要走多少站。
# 题目分析
首先通过样例可以得出一个显然的结论：最优的做法是直接从一个上一个路口是电车站的公交车站坐到下一个电车站或者从一个上一个路口是公交车站电站坐到下一个公交车站。

这样我们就可以 $O(n)$ 判断一个方案是否合法了。从当前枚举的答案开始，每经过一对不同的车站就把当前记录的钱数増加，如果超过了 p 则答案不正确，如果到家了则答案正确。

~~可以感性理解其正确性。~~

所以我们就可以二分答案了，总复杂度 $O(n \log n)$，**也许**可以通过本题数据（我没试过）。

~~此题完结。~~
# 算法优化
有没有复杂度更优的算法呢？

注意到坐车的区间左端点是没有确定的，而右区间端点是确定的，所以我们可以倒过来考虑。

判断过程差不多，从右边往左边扫，每次遇到上一个路口与这一个路口类型不一样就说明要多花钱了。如果到此站钱就花完了那么本站就是答案。如果到头钱还没花完，那么答案就是 1。
# 完整代码
~~终于有我放完整代码的题解了。~~
```cpp
#include<bits/stdc++.h>
using namespace std;
int t,a,b,p,n,l;
char s[100011];
int main()
{
	scanf("%d",&t);
	while(t--)
	{
		scanf("%d%d%d%s",&a,&b,&p,s);
		n=strlen(s);
		s[n-1]='C';
		l=1;
		for(int i=n-1;i>=1&&l;--i)
		{
			if(s[i-1]!=s[i]&&s[i-1]=='A'&&(p-=a)<0)
			{
				printf("%d\n",i+1);
				l=0;
				break;
			}
			else if(s[i-1]!=s[i]&&s[i-1]=='B'&&(p-=b)<0)
			{
				printf("%d\n",i+1);
				l=0;
				break;
			}
		}
		if(l)
			printf("1\n");
	}
	return 0;
}
```
其中 l 记录是否在中途就出解了。

要注意到家就一定要下车，所以要把 $s_{i-1}$ 赋为‘C’。

好像有的算法会爆 int？所以你要是不确定你的代码是否会爆 int 的话就开 longlong 吧。

完结撒花\\(^o^)/