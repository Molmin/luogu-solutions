## 题意理解

给出一个正整数 $n$，再给出一个 $2$ 行 $n$ 列的数字阵，```1``` 表示有三角形，需要围起来，如果三角形相邻可以省去围栏，求围栏总长。

## 思路阐述

遍历每一个位置，如果有三角形就将答案加上周长，再判断左右上下相邻，如果相邻就将答案减一（因为同一条重合的边会被找到两次，所以不需要一下子减去二）。

**注意上下相邻的情况：只有三角形处于列号为奇数时才共边**。

## 代码呈现

```cpp
#include <bits/stdc++.h>
using namespace std;

int n;
bool mp[3][200005];//数组
int x;//当前数字
int cnt;//答案计算

signed main(){
    
    scanf("%d",&n);
    for (int i=1;i<=n;i++){
        scanf("%d",&x);
        if (x) mp[1][i]=1;//x是1，标记为1
    }
    for (int i=1;i<=n;i++){
        scanf("%d",&x);
        if (x) mp[2][i]=1;
    }//分行输入
    for (int i=1;i<=n;i++){
        if (mp[1][i]){//这里有三角形
            cnt+=3;//答案加上周长
            if (mp[1][i-1]) cnt--;//左边相邻
            if (mp[1][i+1]) cnt--;//右边相邻
            if (mp[2][i] && i&1) cnt--;//下边相邻，是奇数列
        }
    }
    for (int i=1;i<=n;i++){//第二行同理
        if (mp[2][i]){
            cnt+=3;
            if (mp[2][i-1]) cnt--;
            if (mp[2][i+1]) cnt--;
            if (mp[1][i] && i&1) cnt--;//上边相邻，是奇数列
        }
    }
    printf("%d",cnt);//输出
    return 0;
    
}

```

希望可以帮到各位大佬。