#### 初步分析

这是一道类似于博弈论的题目，需要对修改后可行的初始局面进行计数。因此分析问题的过程大概可以从判定单个局面出发，拓展到需要恰好添加 $k$ 个石子时的判定方法，最后再根据判定的过程进行 dp 计数，问题整体会大概是一个 dp 套 dp 的结构。

#### Part 1. 单个局面的判定

直接从正面去考虑构造性的判定解法是比较困难的，而且不太具有可拓展性，因此可以从反面出发，也就是找到无解的情况。不难想到的是序列中必须存在 $1$ 才有可能无解，否则用操作一可以全部消除；同时假设没有 $0$ 的情况下，序列中还需要存在 $2$ 才有可能无解，否则可以先用操作一全部消到 $1$，再用一次操作二全部消除。这启发我们开始讨论 $1$ 和 $2$ 的位置关系。

最先想到的无解情况是 $\{1, 2, 1\}, \{1, 2, 1, 1\}, \{1, 2, 1, 1, 1\}$，这种情况下 $2$ 必须要分到两段之中，但是左边一段的 $1$ 数量不够，无法单独进行一次操作二。此时大概可以发现，有解的情况下，一定会把 $2$ 分配到相邻两段之中。

但上述的讨论过程显然是局限的，我们并不能通过直接把大于 $2$ 的数全部减到 $2$ 以内来解决问题，例如 $\{1, 2, 3, 2, 1\}$，这种情况显然有解，同时无法对 $3$ 进行操作一。然而 $\{1, 2, 3, 4, 3, 2, 1\}$ 就与此有些不同，我们可以通过将 $4$ 消到 $2$，然后对 $[1, 3], [2, 5], [3, 6], [5, 7]$ 进行操作二全部消除。此处的构造由考场时写的暴力给出，之后的构造同理。在这个过程中可以直观感受到，同一个位置的数不会被分配到太多区间内，打表可以发现最多分配给 $3$ 个区间。这个性质也可以简单理解为，如果一个位置被分配到了太多段，那么这些段的长度都会比较长，一定可以通过分裂区间来舍弃一部分。

在上述工作之后可以开始考虑 dp 判定，首先需要注意到的是我们只关心能不能消除当前数，因此较长的区间只需要保留前面两位即可。这启发我们记录前两位的状态进行 dp：设 $f_{i, j, k}$ 表示 $a_{i - 1} = j, a_{i} = k$ 是否可能被达到，这里的 $a_{i - 1}, a_i$ 代表的是对 $[1, i]$ 进行消除之后剩下的数。根据一个位置只会分配到 $3$ 个区间的结论，$j, k$ 的取值范围即为 $[0, 3]$。同时需要注意的是，由于此时在 $[1, i]$ 已经消除完了，因此消除 $j$ 必须要用 $k$ 以及 $i + 1$ 及之后的位置消除，因此需要保证 $j \le k$。此时有效的状态数已经被压缩到了 $10$，通过简单的观察可以发现 $j=0,k=3$ 的状态是无效的，因此有效的状态数仅为 $9$。

转移的过程需要稍微讨论一下，消除的过程并不能很方便地理解。还是以 $\{1, 2, 3, 2, 1\}$ 为例，进行操作二的区间分别为 $[1, 3], [2, 4], [3, 5]$，在到达位置 $1$ 时保留的数为 $\{0, 1\}$，在到达位置 $2$ 时保留的数为 $\{1, 2\}$，在到达位置 $3$ 时保留的数仍然为 $\{1, 2\}$，因为 $\{2, 3\}$ 已经与 $1$ 一起被消除了一次，后面的过程同理。

仔细分析上述过程，考虑从 $f_{i - 1, j, k}$ 转移到 $f_{i}$，假设当前位置的数为 $w$，那么需要对 $\{j, k, w\}$ 进行消除。$w$ 本身是很大的，但实际上只会用到 $0 \sim 3$，因此可以枚举 $0 \sim 3$，判断 $w$ 能不能作为这个数使用再考虑转移。消除的过程并不只是简单的同时减，首先需要保证 $j$ 能够消到 $0$，其次由于存在一段较长的操作二，而我们只需要保留其中最后两位，所以会出现只消除了第一/二个的情况。假设三个位置消的分别为 $\{j, x, y\}$，只需要保证 $j \ge x \ge y$，且 $k - x \le w - y$ 即可。由此我们可以在 $O(n)$ 时间内完成对某个局面的判定。

#### Part 2. 恰好添加 $k$ 个石子时的判定

这一部分相比来说较为简单，注意到绝大多数情况下，如果 $k$ 可行，那么 $k+1$ 也大概率可行，可以通过在操作一的基础上额外增加或者操作二的基础上向两侧拓展得到。简单讨论可以得出，除了初始序列为 $\{0, 0, \dots, 0\}$ 与 $\{1, 1, 1\}$ 的情况，都存在一个分界点 $k_0$，使得 $k \ge k_0$ 时有解，否则无解。两种特殊情况不难讨论得出。

此时可以解决 $l_i = r_i$ 的部分，得到 $40$ 分。

#### Part 3. 对初始局面的计数

首先处理 $k=0$ 的情况，这种情况下只需要考虑上述第一部分中的 $9$ 种状态能否达到，因此可以设 $f_{i, S}$ 表示前 $i$ 个位置可达的状态集合为 $S$ 的方案数。预处理出 $g_{S, w}$ 表示在集合 $S$ 之后加入一个 $w$ 能转移到的状态集合即可枚举 $w$ 快速转移，需要注意 $r_i$ 的范围虽然是 $10^9$，但只需要讨论 $w=0\sim 4$ 的情况。此时可以获得 $55$ 分。

考虑 $k>0$ 的情况，根据 Part 2 中的结论，我们只需要记录到达每种状态所需要的最小的 $k_0$ 即可。直观感受上到达不同状态的 $k_0$ 相差不会太大，爆搜可以发现不同的状态数只有 $8601$ 种，因此可以直接 dp：设 $f_{i, j}$ 表示前 $i$ 个位置到达了状态 $j$ 的方案数，转移与 $k=0$ 时完全一致。

#### Part 4. 参考实现

```cpp
#include <bits/stdc++.h>
const int mod = 1000000007;
const int maxm = 1 << 14;
int n, m, L[1010], R[1010], r, c[4][4], tot, trans[maxm][5], f[2][maxm], ans; bool tr[10][10][5];
std::map<std::vector<int>, int> id; std::vector<int> vec[maxm];
inline void add (int &x, int y) {x += y; x -= x >= mod ? mod : 0;}
inline void dfs (std::vector<int> g)
{
	if (id.count(g)) return;
	vec[id[g] = ++tot] = g;
	for (int w = 0; w < 5; w++)
	{
		std::vector<int> nxt; nxt.resize(r);
		for (int i = 0; i < r; i++) nxt[i] = m + 1;
		for (int i = 0; i < r; i++) for (int j = 0; j < r; j++) for (int c = 0; w + c < 5; c++) if (tr[i][j][w + c]) nxt[j] = std::min(nxt[j], g[i] + c);
		dfs(nxt); trans[id[g]][w] = id[nxt];
	}
}
signed main ()
{
	for (int i = 0; i < 4; i++) for (int j = i; j < 4; j++) if (i != 0 or j != 3) c[i][j] = r++;
	for (int j = 0; j < 4; j++) for (int k = j; k < 4; k++) if (j != 0 or k != 3)
		for (int z = k; z < 4; z++) for (int w = 0; w < 5; w++) if (w == z or w >= z + 2)
			for (int x = 0; x <= k and x <= j and x <= z; x++)
				for (int y = 0; y <= z and y <= x; y++) if (k - x <= z - y) if (k - x != 0 or z - y != 3) tr[c[j][k]][c[k - x][z - y]][w] = true;
	int T;
	for (assert(scanf("%d", &T) == 1); T--; )
	{
		assert(scanf("%d%d", &n, &m) == 2); id.clear(); tot = 0;
		dfs({0, m + 1, m + 1, m + 1, m + 1, m + 1, m + 1, m + 1, m + 1});
		for (int i = 1; i <= n; i++) assert(scanf("%d%d", &L[i], &R[i]) == 2);
		for (int i = 1; i <= tot; i++) f[0][i] = 0;
		f[0][1] = 1; ans = 0;
		for (int i = 1, o = 1; i <= n; i++, o ^= 1)
		{
			for (int j = 1; j <= tot; j++) f[o][j] = 0;
			for (int j = 1; j <= tot; j++)
			{
				for (int w = L[i]; w <= R[i] and w < 4; w++) add(f[o][trans[j][w]], f[o ^ 1][j]);
				if (R[i] >= 4) add(f[o][trans[j][4]], 1LL * f[o ^ 1][j] * (R[i] - std::max(L[i], 4) + 1) % mod);
			}
		}
		for (int i = 1; i <= tot; i++) if (vec[i][0] <= m) add(ans, f[n & 1][i]);
		bool f0 = true, f1 = true;
		for (int i = 1; i <= n; i++) f0 &= L[i] <= 0 and 0 <= R[i], f1 &= L[i] <= 1 and 1 <= R[i];
		if (m == 1 and f0) add(ans, mod - 1);
		if (m == 1 and f1 and n == 3) add(ans, mod - 1);
		printf("%d\n", ans);
	}
	return 0;
}
```