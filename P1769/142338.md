>这道题大意就是经过某些~~玄学的~~概率运算，然后在所有选手中找一个最有可能胜出的，一开始我想太简单了，因此就有了这个50分的错误做法：

>直接模拟一遍，就是一开始一号对二号，三号对四号...然后在这两两配对中选一个胜率概率较大的进入下一局（概率相同则选择编号较小者），然后再重复上述步骤，直到最后只剩下一个人为止，那这个人就是最有可能胜出的。

>但是很明显这个思路是有问题的，假设题目给出的矩阵是

$$\begin{matrix}0 & 51 & 50 & 50\\49 & 0 & 100 & 100\\50 & 0 & 0 & 50\\50 & 0 & 50 & 0\end{matrix}$$

>按照我们的程序，一号赢二号的概率是51%，所以它会选择一号进入下一局对战三四号中的赢家。然而一号对战三四号的胜率是50，但是如果让二号上那就必胜。所以一号得冠的概率其实没有二号高，那就不应该选择一号进入下一局，所以上述方法是不可行的。

>那么如何按照正常的思路，将每个选手的胜率都算出来呢？DP时间到！根据简单的概率学我们可以得出：**i号选手进入第j轮比赛的概率=∑(i号选手活到第j-1轮的概率×对手k号选手活到第j-i轮的概率×i号选手打败k号选手的概率)**。如果DP方程描述，f[i][j]表示i号选手进入第j轮比赛的概率，那么：

$$f[i][j]=\sum_{\text{可能的对手}k}f[i][j-1]\times f[k][j-1]\times p[i][k]$$

>可是我们怎么知道i号选手可能的对手k是那些人呢？我们从最开始的情况看起：

>如果此时是第一轮比赛（还没有任何人被淘汰掉），那么如果i是奇数，那它的对手就是i+1号选手；如果i是偶数，那么它的对手就是i-1号选手。这个都挺好理解的吧。

>那么此时到了第二轮比赛，i可能的对手又是那些人呢？我们注意到第二轮比赛后就只剩下原来1/4的人，也就是说要在每四个人中选一个人进入第三轮比赛。因此我们可以把一开始的选手每四个分一组，第i个选手可能的对手就是它们组里的人。可是，因为在第一轮中，相邻的两个人必有一人淘汰，所以一名选手不可能与另一个选手比两场赛。例如第二轮中，1、2、3、4号为一组，那么一号选手的对手只能是3或4，而不能是2，因为他们俩已经打过一场了。下面是$\quad\LaTeX$演示：

$$\fbox{1\quad2}\fbox{3\quad4}\quad\fbox{5\quad6}\fbox{7\quad8}\quad\fbox{9\quad10}\fbox{11\quad12}\quad\cdots$$

>我们找一找规律，比如：可以看到7号位于第2组，它的对手是从5号与6号；12号位于第3组，它的对手是从⑨号到10号...看出规律来了吗？第i号选手可能的对手都在第$\lceil\frac{i}{4}\rceil$组，如果$(i-1)\bmod4\ge2$，那么它的对手就是$4\lceil\frac{i}{4}\rceil-3\sim4\lceil\frac{i}{4}\rceil-2$号。否则就是$4\lceil\frac{i}{4}\rceil-1\sim4\lceil\frac{i}{4}\rceil$号。

>以上就是第二轮比赛的情况，那么推广到第j轮比赛呢？那就是每$2^j$人一组啦。也就是：

>**对于第j轮比赛，第i号选手可能的对手是$2^j\lceil\frac{i}{2^j}\rceil-2^j+1$到$2^j\lceil\frac{i}{2^j}\rceil$号。**

>**1.如果$(i-1)\bmod2^j\ge2^{j-1}$，那么他的对手就是$2^j\lceil\frac{i}{2^j}\rceil-2^j+1$号到$2^j\lceil\frac{i}{2^j}\rceil-2^{j-1}$号**

>**1.如果$(i-1)\bmod2^j<2^{j-1}$，那么他的对手就是$2^j\lceil\frac{i}{2^j}\rceil-2^{j-1}+1$到$2^j\lceil\frac{i}{2^j}\rceil$号**

>~~（这公式推死我了）~~ 然后我们根据是哪种情况，设l为枚举序号的左边界，r为右边界，那么可能的对手就在l号到r号间。也就是说$l\le k\le r$，然后带入上述式子就有：

$$f[i][j]=\sum_{k=l}^{r}f[i][j-1]\times f[k][j-1]\times p[i][k]$$

>然后我们只要根据这个公式算就好啦！最后输出使得f[i][n]最大的i值就完事儿了。（对了还有一个特别坑的点，要注意百分数的转换，存矩阵p的时候不用转，算f[i][j]的时候再转成小数形式）

>萌新刚学$\LaTeX$,再加上第一次写题解，公式丑请见谅。

```cpp
#include<bits/stdc++.h>
using namespace std;

double p[1030][1030], f[1030][12];

int main(){
	int i, j, k, n, N, ans;
	double MAX = -1;
	cin >> n;
	N = 1 << n;
	for(i = 1; i <= N; i++){
		for(j = 1; j <= N; j++){
			scanf("%lf", &p[i][j]);
			p[i][j] /= 100; //注意百分数的转换 
		}
	}
	for(i = 1; i <= N; i++){
		f[i][0] = 1; //比赛还没开始大家都不会被淘汰，因此胜率是1 
	}
	for(j = 1; j <= n; j++){
		int t = (1 << j), l, r;
		for(i = 1; i <= N; i++){
			if((i - 1) % t >= t / 2){ //根据i的情况确定左右边界 
				l = t * ceil((double)i / t) - t + 1;
				r = t * ceil((double)i / t) - t / 2;
			}
			if((i - 1) % t < t / 2){
				l = t * ceil((double)i / t) - t / 2 + 1;
				r = t * ceil((double)i / t);
			}
			for(k = l; k <= r; k++){
				f[i][j] += f[i][j - 1] * f[k][j - 1] * p[i][k]; 
			}
		}
	}
	for(i = 1; i <= N; i++){
		if(f[i][n] > MAX){
			MAX = f[i][n];
			ans = i;
		}
	}
	cout << ans;
	return 0;
}
```
