对于样例，我们可以手工模拟一下：

1号选手通过第1轮（进入决赛）的概率为90%，即击败2号选手的概率。同理，2号选手通过第1轮的概率为10%，3号，4号选手都是50%。

对于3号选手通过第2轮（通过第n轮夺冠）的概率，我们可以分情况讨论。假设3号选手已经通过第1轮。如果1号选手通过第1轮（90%的可能性），则3号选手通过第2轮的概率为50%，即击败1号选手的概率，所以3号选手击败1号选手通过第2轮的概率为90%\*50%=45%；如果2号选手通过第1轮（10%的可能性），则3号选手通过第2轮的概率为90%，即击败2号选手的概率，所以3号选手击败2号选手通过第2轮的概率为10%\*90%=9%。所以3号选手击败对手通过第2轮的概率为45%+9%=54%，而这是在3号选手已经通过第1轮的基础上的概率，自然，3号选手最初时通过第2轮的概率只有50%\*54%=27%。

同理，4号选手最初时通过第2轮的概率为27%，1号选手通过第2轮的概率为45%，2号选手为1%，45%>27%>27%>1%，所以答案输出1。

通过手工模拟样例，我们可以得到这道题运用的是递推（也可以说是动态规划）的算法，设每一位选手通过这一轮的概率为这一位选手通过上一轮的概率乘上这一位选手击败这一轮遇到的每一个对手的概率之和，具体见程序注释。



```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cstdlib>
#include<cmath>
#include<algorithm>
using namespace std;
const double Esp=0.000001;
int p[1100][1100];
double f[12][1100];
int main(){
    //freopen("p1769.in","r",stdin);
    //freopen("p1769.out","w",stdout);
    int n,m,ans;
    scanf("%d",&n);
    m=1<<n; //m为总人数 
    for(int i=1;i<=m;i++)
        for(int j=1;j<=m;j++)
            scanf("%d",&p[i][j]);
    for(int j=0;j<=m;j++)
        f[0][j]=1.0; //每一位选手通过第0轮的概率为1，因为还没有比赛，自然不会被淘汰 
    for(int i=1;i<=n;i++){
        int x=1<<i-1;
```
/\*
x表示每一组人数，如n=5,m=32,i=3，此时x=4表示每4个人中有1个人到达第3轮

当然1~4号选手中有1个人能到达第1轮，将1~4号选手看做第1组，同理，将5~8号选手看做第2组，将29~32号选手看做第8组

\*/
```cpp
        for(int j=1;j<=m;j++){
            int num1,num2;
            num1=(j+x-1)/x;
            //num1表示j号选手第i轮所在的分组，如n=5,m=32,i=3,j=25，num1=7表示25号选手第3轮在第7组（25~28号选手在第7组） 
            if(num1&1) num2=num1+1;
            else num2=num1-1;
            //num2表示j号选手第i轮所有可能的对手所在的分组，如n=5,m=32,i=3,j=25，num2=8表示25号选手第3轮可能的对手在第8组，即29~32号选手 
            double pro=0.0; //pro表示在j号选手已经通过前i-1轮的情况下，通过第i轮的概率 
            for(int k=x*(num2-1)+1;k<=x*num2;k++){ //k即为j在第i轮可能遇到的选手编号，此时为29~32 
                pro+=f[i-1][k]*p[j][k]/100;
```
/\*
f[i-1][k]表示第k个选手通过前i-1轮进入第i轮的概率

f[i-1][k]\*p[j][k]/100表示第j个选手通过击败第k个选手晋级下一轮的概率

\*/
```cpp
            }
            f[i][j]=f[i-1][j]*pro; //状态转移方程 
        }
    }
```
/\*
```cpp
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++)
            printf("%.2lf ",f[i][j]);
        printf("\n");
    }
```
检测有无bug
输入样例时输出为

0.90 0.10 0.50 0.50

0.45 0.01 0.27 0.27

\*/
```cpp
    ans=1;
    for(int j=2;j<=m;j++)
        if(f[n][j]>f[n][ans]+Esp) //Esp保证相同概率选择编号最小的 
            ans=j;
    printf("%d\n",ans);
    return 0;
}
其实这道题也可以用递归（分治），更好理解，只是时间复杂度略高，大家有兴趣可以自己写。
```