##### 其实就是一个 ~~大水题~~ **无脑看样例找规律**的题。（注意两个 2 并不能形成回文）   

先看一组样例（自己造的）   
**输入：**    
```
7 5 3    
2 1 2 0 0 1 2
```
**操作过程：**  
因为是要求回文，所以我们每次将当前的数和他对应的数进行比对   

$\color{Black}\colorbox{Yellow}{2}$ 1 2 0 0 1 $\color{Black}\colorbox{Yellow}{2}$ $ \qquad  $ $ \qquad  $ $  \qquad  $ $ \qquad  $ $ \, $ $ \, $因为两个 2 并不能形成回文，所以这里   
$\uparrow$ $ \, $ $ \, $ $ \, $ $ \, $ $ \, $ $ \, $ $ \, $ $ \, $ $ \, $ $ \, $ $ \, $ $ \, $ $\uparrow$ $ \qquad  $ $ \qquad  $ $ \, $ $ \, $ $ \, $ $ \, $ $ \, $ $ \, $  $ \, $ $ \, $ $ \, $ $ \, $ $ \, $ $ \, $ $ \, $ $ \, $ 两个 2 要取 0 和 1 中代价最小的 。   

$\color{Black}\colorbox{Yellow}{1}$ 2 0 0 $\color{Black}\colorbox{Yellow}{1}$  $ \qquad  $  $ \qquad  $ $  \qquad  $ $ \qquad  $ $ \, $ $ \, $ $ \, $ $ \, $ $ \, $ $ \, $因为两个 1 可以直接形成回文，所以这里     
$\uparrow$ $ \, $ $ \, $ $ \, $ $ \, $ $ \, $ $ \, $ $ \, $ $ \, $ $\uparrow$ $ \qquad  $ $ \qquad  $ $ \, $ $ \, $ $ \, $ $ \, $ $ \, $ $ \, $  $ \, $ $ \, $ $ \, $ $ \, $ $ \, $ $ \, $ $ \, $ $ \, $ $ \, $ $ \, $ $ \, $ $ \, $ 不需要任何代价，同理两个 0 也不要代价 。

$\color{Black}\colorbox{Yellow}{2}$ 0 $\color{Black}\colorbox{Yellow}{0}$  $ \qquad  $  $ \qquad  $ $  \qquad  $ $ \qquad  $ $ \, $ $ \, $ $ \, $ $ \, $ $ \, $ $ \, $ $ \, $ $ \, $ $ \, $一个 0 和一个 2 ，花 0 的代价吧 2 变成 0。      
$\uparrow$ $ \, $ $ \, $ $ \, $ $ \, $ $ \, $ $\uparrow$ $ \qquad  $ $ \qquad  $ $ \, $ $ \, $ $ \, $ $ \, $ $ \, $ $ \, $  $ \, $ $ \, $ $ \, $ $ \, $ $ \, $ $ \, $ $ \, $ $ \, $ $ \, $ $ \, $ $ \, $ $ \, $ $ \, $ $ \, $ $ \, $  同理一个 1 和一个 2 ，只用花 1 的代价。

$\color{Black}\colorbox{Yellow}{0}$ $ \qquad  $ $\qquad  $ $ \qquad  $ $  \qquad  $ $ \qquad  $ $ \, $ $ \, $ $ \, $ $ \, $ $ \, $ $ \, $ $ \, $ $ \, $ $ \, $最中间的数不用判断也能形成回文，     
$\uparrow$ $ \, $ $ \, $ $ \, $ $ \, $ $ \, $ $\qquad  $ $ \qquad  $ $ \, $ $ \, $ $ \, $ $ \, $ $ \, $ $ \, $  $ \, $ $ \, $ $ \, $ $ \, $ $ \, $ $ \, $ $ \, $ $ \, $ $ \, $ $ \, $ $ \, $ $ \, $ $ \, $ $ \, $ $ \, $ $ \, $ $ \, $  但如果是 2 要取 0 和 1 中代价最小的。

**输出：**
```
11
```
##### 了解了几种操作情况代码就挺简单了
```
#include<bits/stdc++.h>
using namespace std;
int n,need[3],a[25],ans;
int main()
{
	cin>>n>>need[0]>>need[1];//need[0/1]表示变成 0 和 1 的代价 
	need[2]=min(need[1],need[0]);//先处理 0 和 1 中代价最小的，可能会多次调用 
	for(int i=1;i<=n;i++)
		cin>>a[i];
	for(int i=1;i<=n/2;i++)
	{
		int x=a[i],y=a[n-i+1];//x,y是当前搜到对应的两个数 
		if(x!=2&&y!=2&&x!=y){//两个都非 2 且不一样的数，无法形成回文 
			cout<<-1;return 0;}
		else if(x==2&&y!=2)//x 为 2 但 y 不为 2 
			ans+=need[y];//取 y 的代价 
		else if(x!=2&&y==2)//y 为 2 但 x 不为 2 
			ans+=need[x];//取 x 的代价 
		else if(x==2&&y==2)//两个都为 2 
			ans+=2*need[2];// 取最小的代价 
		//省略了 x 和 y 相等的情况 
	}
	if(n%2==1&&a[n/2+1]==2)//是奇回文且中间的数是 2  
		ans+=need[2];// 取最小的代价
	cout<<ans;
	return 0;
}

```
	
