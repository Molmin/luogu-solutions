
//先说一下题意：给定若干个长度小于等于1000000的字符串，询问每个字符串最多由多少个相同的子串重复连接而成，如ababab，由3个ab重复连接而成

//其实看到 “子串”，“相同的”“重复连接”这些关键词，很容易就能想到KMP算法（不会KMP可以跳p3375或自行百度）

//那么KMP算法怎么在这道题实际应用呢？其实我们想到KMP的核心是在求next数组，我们不妨就利用next数组来解这道题，大家可以先想一想，如果一个字符串是由n个相同的字符串重复连接，那么它的next数组会有什么特点呢？

abcdabcdabcd    aaaaaaaaa   ababababab

000012345678    012345678   0012345678

//写几个字符串并把它的next数组写出来，我们会发现这种字符串其实除了前面有几个0以外后面是每次加1的，那么这里面就有规律供我们解题了

//我们假定这个字符串长度为n，那么n-next[n]（n减去第n个字符的next值）这个位置一定是重复的那个最长子串最后一个字符所在的位置

//那么我们进一步思考，如果这整个字符串真的是由好几个相同字符串重复连接，那么n一定能整除n-next[n]，并且n/(n-next[n])就是最后的答案

//思路构建完成√，开始代码实现
```
#include<cstdio>
#include<cstring>
using namespace std;
char s[1000010];
int next[1000010];
int k,ans;//k的初始值为0 
int main()
{
	scanf("%s",s);//输入字符 
	while(s[0]!='.')//循环条件：只要字符不是‘. ’输入和询问就没有结束 
	{
		int len=strlen(s);//计算字符串长度 
		for(int i=1;i<len;i++)//kmp标准模板 
		{
			while(k&&s[i]!=s[k])k=next[k];
			next[i+1]=s[i]==s[k]?++k:0;
		}
		ans=len%(len-next[len])?1:len/(len-next[len]);//看看是否能被整除，如果能被整除，那么子串个数就是冒号后面那一坨，否则就是1 
		printf("%d\n",ans);//输出答案 
		k=0;//一定要将k重置为0！！！很重要！！没有这步操作会使整个程序瘫痪 
		scanf("%s",s);//再输字符串，从而通过循环条件的判断决定是否退出 
	}
	return 0; 
}
```