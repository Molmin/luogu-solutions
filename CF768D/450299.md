一个比较套路的概率 dp。

首先根据题意设计状态，设 $f_{i,j}$ 表示在 $i$ 天里选过了 $j$ 种物品的概率，因此得出边界条件 $f_{0,0}=1$

考虑转移，发现会有两种状况，即可能摸到的是 $j$ 种里面的物品，也可能是一个新的物品，需分情况讨论。

- 摸到的是 $j$ 种里面的物品

因为摸到的种类并没有增加，所以此时要从 $f_{i-1,j}$ 中转移过来，而摸到 $j$ 种之一的概率为 $\dfrac{j}{n}$，因此此时的转移方程为：

$$f_{i,j}=f_{i-1,j} \times \dfrac{j}{n}$$

- 摸到的是新的物品

增加了一个种类，从 $f_{i-1,j-1}$ 中转移过来，以前已经摸到了 $j-1$ 种物品，所以摸到新物品的概率是 $\dfrac{n-j+1}{n}$，此时方程为：

$$f_{i,j}=f_{i-1,j-1} \times \dfrac{n-j+1}{n}$$

算总方案数只需要把两个相加起来。

对于每一个询问把数组扫一遍统计答案就好。

```cpp
#include <bits/stdc++.h>
using namespace std;
int n, q; double f[10005][1005], p;//数组范围可以跑极限数据测一下
int main () {
	scanf ("%d%d", &n, &q);
	f[0][0] = 1;
	for (int i = 1; i <= 10000; ++ i) 
		for (int j = 1; j <= n; ++ j) {
			f[i][j] += (double)j / n * f[i - 1][j];
			f[i][j] += (double) (n - j + 1) / n * f[i - 1][j - 1];
		}
	while (q --> 0) {
		scanf ("%lf", &p); p /= 2000;
		for (int i = 1; i <= 10000; ++ i) 
			if (f[i][n] >= p) {printf ("%d\n", i); break;}
	}
}
```