## [CF379C New Year Ratings Change](https://www.luogu.com.cn/problem/CF379C)

# 题目描述：

有 $n$ 个用户，每个用户希望得到一个评分值，记为 $a_i$。评分值需要是正整数，且该用户想要的评分值不能低于 $a_i$。现要对这 $n$ 个用户分别发放一个评分值，使得这 $n$ 个评分值之和最小，并且所有 $n$ 个评分值都是不同的。

# 算法思路：

为了使得评分值之和最小，我们可以让得到评分值较小的用户的评分值尽量小。

如果有多个用户想获得同样的评分值，我们可以按顺序给这些用户分配评分值，从小到大依次分配。为了保证每个用户都得到评分值，我们需要将已分配的最大的评分值加一为下一个可分配的评分值。

# 算法实现：
 
我们可以使用 map 来实现评分值的分配。我们维护一个 map，map 的键是已分配的评分值，值是该评分值的下一个可分配的评分值。

在分配评分值时，如果该用户要求的评分值在 map 的键中不存在，我们会将该值和其自身加一的值全部加入到 map 中，然后分配其中的这个较小的值。

如果该值已经存在于 map 之中，我们会将该键的值设为它下一个可用的键值，并将这个新的键值分配给当前的用户即可。最后，我们输出所有用户分配的评分值即可。

# 代码实现：

```cpp
#include <bits/stdc++.h>  // 引入万能头文件
using namespace std;

int n, rating;  // n: 用户数，rating: 用户期望评分值
map<int, int> mp;  // mp: 评分值的下一个可分配的评分值

// 使用map查找评分为x的下一个可分配的评分值
int find(int x) {
    if (!mp.count(x)) {  // 如果x还没有被分配，则将该值和其自身加一的值全部加入到mp中
        mp[x] = x + 1;  // 将x的下一个可分配的评分值设为x+1
        return x;  // 返回x
    }
    // 否则，递归查找x的下一个可分配的评分值
    return mp[x] = find(mp[x]);  // 并将x的下一个可分配的评分值设为find(mp[x])的返回值
}

int main() {
    scanf("%d", &n);  // 读入用户数
    for (int i = 1; i <= n; i++) {  // 遍历每个用户
        scanf("%d", &rating);  // 读入该用户期望的评分值
        printf("%d ", find(rating));  // 输出该用户得到的评分值，并将评分值加入到并查集中
    }
    return 0;
}
```

## 算法复杂度：

时间复杂度：$O(n\log n)$，因为 map 的查询和修改的时间复杂度均为 $O(\log n)$。

空间复杂度：$O(n)$，我们需要使用 map 来存储每个评分值的下一个可分配的评分值。