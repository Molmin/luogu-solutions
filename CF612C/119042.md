**题意：**

当一个只包含字符 ```<>, {}, [], ()``` 的字符串满足以下条件**之一**时，则该字符串被称为 RBS 。

- 该字符串是空串。
- 形如 ```<s1>s2```，且 ```s1,s2``` 是RBS。
- 形如 ```(s1)s2```，且 ```s1,s2``` 是RBS。
- 形如 ```{s1}s2```，且 ```s1,s2``` 是RBS。
- 形如 ```[s1]s2```，且 ```s1,s2``` 是RBS。

现在给定一个只包含字符 ```<>, {}, [], ()``` 的字符串 $s$ ，其中 ```<,(,[,{``` 可以互相替换（即左括号可以互相替换），```>,),],}``` 也可以互相替换（即右括号可以互相替换），问至少替换多少次可以使得 $s$ 成为 RBS 。

如果不可能通过替换使得 $s$ 成为 RBS ，则输出 ```Impossible``` 。

**数据范围：** $1\le|s|\le 10^6$ 。

**做法：**

我们先定义括号 ```<>,(),[],{}``` 是匹配的。维护一个括号栈，每次看**当前括号**是否为**右括号**，若是，则检查与**栈顶括号**是否为**左括号**，若是，则检查是否匹配，若匹配，则**弹出栈顶括号**，若不匹配，则计数器加 $1$ 。

其他情况直接把当前括号 $\operatorname{push}$ 到栈顶即可。

若最后栈非空，则输出 ```Impossible``` ,否则直接输出计数器的值即可。

**时间复杂度：** $O(|s|)$ 。

$Code:$

```cpp
#include <bits/stdc++.h>

using namespace std;

void solve()
{
    string s;
    cin>>s;
    int n=s.length();
    s=' '+s;

    stack<char> st;
    int ans=0;
    for(int i=1;i<=n;i++)
    {
        if(st.empty() || s[i]=='{' || s[i]=='(' || s[i]=='[' || s[i]=='<')
        {
            st.push(s[i]);
            continue;
        }
        else
        {
            char ch=st.top();
            if(ch=='{' || ch=='(' || ch=='[' || ch=='<')
            {
                if((ch=='{' && s[i]=='}') || (ch=='(' && s[i]==')') || (ch=='[' && s[i]==']') || (ch=='<' && s[i]=='>')) ;
                else ans++;
                st.pop();
            }
            else st.push(s[i]);   
        }
    }
    if(!st.empty())
    {
        puts("Impossible");
        return ;
    }
    printf("%d",ans);
}

int main()
{
    solve();
    return 0;
}