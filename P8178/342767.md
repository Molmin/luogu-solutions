~~咕咕咕~~

大家好，由于我是暴力选手，我就用了 $O(Tk^2\log 10^9)$ 的时间复杂度过了这道题。

前置知识：同余方程组。

首先看到这道题，一般都会想起递推数列，但是一般递推数列根据题目可以改成 $f_n=af_{n-1}+b$ 的形式，但是这道题每一项对应的不一样，放弃这种想法。

那么我们发现，既然 $k$ 的范围这么小，那么我们就把每一项都枚举出来。

可是？可是我们第一项 是 个 未 知 数，所以~~也放弃这种想法~~我们思考怎么把第一项的系数和常数，放到最终的方程中。

这步操作怎么做呢？一般来讲，我会先想一重循环，类似递推怎么做。

结果？结果我看到了数据范围：$10^9$。

这个数据范围，系数的临界最大值是 $(10^9)^{1000}=10^{9000}$，当然你写个高精也是没问题的，只不过常数的干扰会使得程序减慢，很大程度上会超时。

所以？所以我们要使用~~像这三段一样的对仗~~$k^2$ 算法，对每一个数都算一遍。

我们发现最终是这样这样的倍数，所以我们直接对每一个取模就行了。

然后？然后递推式就出来了，这里的 $u,v$ 表示 $f_i=uf_0+v$：

$u=u\times a_i$

$v=v\times a_i+b_i$

这部分代码：

```cpp
	for(int i=1;i<=n;i++)
        {
            int u=1,v=0;
            for(int j=1;j<=i;j++)
            {
                u=u*a[j]%p[i];
                v=(v*a[j]%p[i]+b[j])%p[i];
            }
            x[i]=u,y[i]=(p[i]-v)%p[i];//x=u,y=v
        }
```

注意取模，我们发现后面的任务等价于判断一个线性同余方程组是否有解。

所以怎么判断？我学同余方程组时会学一个比较奇怪的结论，现在，我找到了[它](http://www.doc88.com/p-5901282494757.html)。

根据这个文章里的方法，我们需要判断单个同余方程有没有解，再判断两两之间的关系。

于是，我们的这部分代码就能写出来了。

```cpp
	for(int i=1;i<=n;i++)
                for(int j=1;j<i;j++)
                        if((y[i]*x[j]-y[j]*x[i])%gcd(p[i]*x[j],p[j]*x[i])!=0)
                        {
                            flag=true;
                            break;
                        }
```

大家肯定发现，我没有写判断单个有没有解的代码，因为经过我的测试，这段代码删了也没有影响，优化常数把它删了。

经过这样的调整，你成功得出了一个~~AC~~ $50$ 分代码。

```cpp
#include<bits/stdc++.h>
#define int long long//开 long long
using namespace std;
int t,n,a[1005],b[1005],p[1005],x[1005],y[1005];
signed main()
{
	cin>>t;
    while(t--)
    {
        cin>>n;//这里表示 k
        for(int i=1;i<=n;i++)
            cin>>a[i];
        for(int i=1;i<=n;i++)
            cin>>b[i];
        for(int i=1;i<=n;i++)
            cin>>p[i];
        for(int i=1;i<=n;i++)
        {
            int u=1,v=0;
            for(int j=1;j<=i;j++)
            {
                u=u*a[j]%p[i];
                v=(v*a[j]%p[i]+b[j])%p[i];
            }
            x[i]=u,y[i]=(p[i]-v)%p[i];
        }
        bool flag=false;
        for(int i=1;i<=n;i++)
            if(y[i]%__gcd(x[i],p[i])!=0||(x[i]==0&&y[i]!=0))//这里是特判，后来删了
            {
                flag=true;
                break;
            }
        if(flag)
        {
            cout<<"No"<<endl;
            continue;
        }
        for(int i=1;i<=n;i++)
        {
            if(x[i]!=0)//否则会 re，gcd(0,0)=0
            {
                for(int j=1;j<=n;j++)
                {
                    if(x[j]!=0)
                    {
                        if((y[i]*x[j]-y[j]*x[i])%__gcd(p[i]*x[j],p[j]*x[i])!=0)
                        {
                            flag=true;
                            break;
                        }
                    }
                }
            }
        }
        if(flag)
            cout<<"No"<<endl;
        else
            cout<<"Yes"<<endl;
    }
	return 0;
}
```

然后你就需要调整一点点细节：

首先，不要 `#define int long long`，用 `1ll*` 代替。

然后是细节的卡常：

1. `ios::sync_with_stdio(false);cin.tie(0);` 也是很有用的。
2. 全加上 `register`，玄学优化，在 `C++` 语言里好用。
3. 运行 `C++20`。
4. `x[i]==0&&y[i]!=0` 的特判不用单独加，单个方程特判可以省略。
5. `44` 行处应该改成 `j<i`，常数 `/2`。
6. 没 啦

最后，你得到了一个最高点运行时间在 `953ms`，春色满园关不住，没有红杏出墙来的代码，而且时间 $O(Tk^2\log)$。

我不清楚有没有这样写的（（（

upd：已经交了。