考虑简单的模拟合并过程。

合并终点处于星号的区间内答案都是等价的。

简单显然一下就是，$4$ 到 $7$ 的一段区间，$4$ 到 $7$ 之间的所有数到两头的距离都是一样的，都为 $3$，如果在区间外，到 $4$ 和 $7$ 的距离一定大于 $3$。

我们考虑从最右端开始，一路合并到最左端。

先 $O(n)$ 预处理出行 $1$ 和行 $2$ 的最左和最右的星号位置，
分别记为 $le1$，$ri1$，$le2$，$ri2$。

因为存在一个同时平移的性质，肯定是从最边界的点一路合并最优，假设终点固定，最后边界一定要到终点，它会经过整段区间，所以在边界之前去合并中间的点显然更劣，浪费次数。

如果 $ri1 \le le2$ 或者 $ri2 \le le1$ 这种情况直接把两行从各自边界位置的一个星号，一路平移到中间 $ri1$ 到 $le2$ 的位置显然是最优的，最终答案再加上 $1$ 次上下平移即可，同时处理一下零的情况。

如果上下两行的区间有交叉，会在上下平移这里出现优劣问题。我们用 $1$ 代替星号。

比如：

$$0100$$

$$1100$$

如果我们要将下面两个星号移动到第一行第二列，两者先在第二行合并再上移步数是 $2$，各自单独移动上去再合并步数是 $3$。

但是对于这种情况：

$$1100$$

$$1100$$

下面两个星号先合并还是先各自上移对于最终答案就没有区别了。

还有这种情况：

$$10000001$$

$$01111110$$

合并点在下面左右合并再上去显然是比把下面的都单独移动上去更优秀。

所以我们就可以有一种 $O(n)$ 的贪心策略。

先对 $le1$，$le2$ 取较大值作为左边界，$ri1$，$ri2$ 取较小值作为右边界。

处于边界之外的点不会涉及上下优劣的情况，直接把它们移动到边界即可。

开一个 $pos$ 变量记录当前合并点处于哪一行。

初始左右边界都是上下都有点的(因为我们移动过来了)。

所以初始 $pos=0$ 意味处于不定态，即对于合并点处于的列来说，它到第一行和第二行步数是一样的的，具体处在哪一行根据下一列来判断在哪一行更优。


**如果上一列是不定态**

下一列如果上下都有星号，那么 $ans$ 加 $2$，依旧处于不定态。

下一列如果只有一个星号，那么 $ans$ 加 $1$，$pos$ 根据下一列的位置对应更新。

下一列是两个点号，直接 $ans$ 加 $1$，不做处理。

**如果上一列 $pos$ 是 $1$**（与 $pos$ 是 $2$ 同理）

下一列如果是上下都有星号，那么 $ans$ 加 $2$，更新成为不定态。

下一列如果是在第一行有星号，那么 $ans$ 加 $1$，位置不变。

下一列如果是在第二行有星号，那么 $ans$ 加 $2$，同时 $pos$ 更新为不定态。
因为此刻上一列到下一列要达成全收集，必须走两步，这两步可以先右再下到第二行，也可以先右，再让下面的上来还是第一行。

下一列是两个点号，直接 $ans$ 加 $1$，不做处理。



可能说起来挺麻烦，其实代码并不复杂，一些细节就看代码吧。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int mx=2e5+1000;
int T,n;
char s[3][mx];                        
void MYH(){
    scanf("%d",&T);
    while(T--){
        scanf("%d",&n);
        for(int i=1;i<=2;++i){
            scanf("%s",s[i]+1);
        }
        int po1=0,po2=0,mid=1e9,cn1=0,cn2=0,ans=0;
        for(int i=1;i<=n;++i){
            if(s[1][i]=='*'){if(po1==0)po1=i;cn1=i;}
            if(s[2][i]=='*'){if(po2==0)po2=i;cn2=i;}
        }
        if(cn2<=po1){
            if(cn2==0)ans=cn1-po1;
            else ans=ans+po1-po2+cn1-po1+1;
            printf("%d\n",ans);
            continue;
        }
        else if(cn1<=po2){
            if(cn1==0)ans=cn2-po2;
            else ans=ans+po2-po1+cn2-po2+1;
            printf("%d\n",ans);
            continue;
        }
        ans=ans+abs(cn1-cn2);
        ans=ans+abs(po1-po2);
        int cnt=min(cn1,cn2);int po=max(po1,po2);
        int up=0;ans++;
        s[1][cnt]='*';s[2][cnt]='*';s[1][po]='*';s[2][po]='*';
        for(int i=cnt-1;i>=po;--i){
            if(s[1][i]=='*' && s[2][i]=='*')ans=ans+2;up=0;
            if(s[1][i]=='*' && s[2][i]=='.'){
                if(up==1)ans++;
                else if(up==0)ans++;up=1;
                else ans=ans+2;up=0;
            }
            if(s[1][i]=='.' && s[2][i]=='*'){
                if(up==2)ans++;
                else if(up==0)ans++;up=2;
                else ans=ans+2;up=0;
            }
            if(s[1][i]=='.' && s[2][i]=='.')ans++;
        }
        printf("%d\n",ans);
    }
}
int main(){
  //  freopen("1.in","r",stdin);
  //  freopen("1.out","w",stdout);
    MYH();
    return 0;
}
```

祝您，武运昌隆

