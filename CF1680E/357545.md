## CF1680E Moving Chips

### 算法

这题里吃的路径其实是可逆的，比如说 A 吃了 B，C 再吃了 B 和 A 吃了 B 然后继续吃了 C 是一样的。所以我们的目标是找出代价最少的一条吃人路径，并且可以钦定任意一个星号作为最终状态。假如设最后留下来的是最右边的某个星号，那就是「从左吃到右」的过程，可以尝试用 DP 来最优化方案。

设 $f(i,0/1)$ 为把第 $1$ 到第 $i-1$ 列全部吃掉，且星号仅在 $(i,0/1)$ 时的最小步数。在对这一列进行 DP 的过程中，我们要考虑的问题是**怎么把上一列的星号全部转移到这一列的目标位置中去**。假如本列有两个星号，**合并一定更优**（否则同时移两个就是浪费），所以也要考虑合并。

- 若全部转移到 $(i,0)$：
    - 从 $(i-1,0)$ 转移：代价为 $1$，但如果 $(i,1)$ 有星号，还需要再加一。
    - 从 $(i-1,1)$ 转移：可以顺便吃了 $(i,1)$，无论如何代价始终为 $2$。
- 若全部转移到 $(i,1)$：
    - 从 $(i-1,1)$ 转移：代价为 $1$，但如果 $(i,0)$ 有星号，还需要再加一。
    - 从 $(i-1,0)$ 转移：代价始终为 $2$。

可以轻松写出状态转移方程。

### 实现

```cpp
int T, n;
int g[200001][2], f[200001][2];

int main() {
    std::cin >> T;
    while (T--) {
        std::cin >> n;
        for (int i = 1; i <= n; ++i)
            f[i][0] = f[i][1] = 0;
        for (int i = 0; i < 2; ++i) {
            for (int j = 1; j <= n; ++j) {
                char c; std::cin >> c;
                g[j][i] = (c == '*');
            }
        }
        int l = 1, r = n;
        while (!g[l][0] && !g[l][1]) ++l;
        while (!g[r][0] && !g[r][1]) --r;
        for (int i = l; i <= r; ++i) {
            f[i][0] = std::min(f[i - 1][0] + g[i][1] + 1, f[i - 1][1] + 2);
            f[i][1] = std::min(f[i - 1][1] + g[i][0] + 1, f[i - 1][0] + 2);
        }
        std::cout << std::min(f[r][0], f[r][1]) - 1 << std::endl;
        // 之前没有特地算 f[l][0/1] 的初始值，循环直接从 l 开始，但是 l-1 -> l 算了 1 步，所以这里减去一。
    }
    return 0;
}
```