[题目链接](https://www.luogu.com.cn/problem/CF940C)
## 题意解释：
给定一个长度为 $n$ 的字符串 $s$，需要使用 $s$ 中出现过的字母组成一个长度为 $k$ 的新字符串 $T$，要求 $T$ 是所有字典序大于 $s$ 且长度为 $k$ 的字符串中字典序最小的字符串。
## 思路 & 方法：贪心
这道题的突破口在于 $n$ 和 $k$ 的大小关系，于是我们先将 $s$ 中的字母从大到小排序，将其存入数组 $t$ 中，然后对于 $n$ 和 $k$ 的三种情况进行分类讨论：
### ① $n < k$ :
这貌似是最简单的一种情况，要使 $T > s$ ,使其字典序最小的方式便是先原封不动地输出 $s$ （这样就保证了 $T$ 一定大于 $s$ ），而后面 $n - k$ 个字符肯定是越小越好，于是就全部输出 $s$ 中最小的字母（即 $t_n$）就可以了。**(详见样例4)**  
**以下是该部分的代码（ $t$ 已是 $s$ 从大到小排序后的字符串）：**  
```
for (i = 1; i <= n; i++)
	printf("%c", s[i]); //原封不动输出s
for (i = n + 1; i <= k; i++)
	printf("%c", t[n]); //剩下的字符输出s中最小的字符，即t[n]。
```
### ② $n > k$ :
因为字符串的大小是从左至右依次比较的，所以最好的贪心策略则是从 $k$ 开始从右至左依次考虑每一位是否可以替换为比它大一点点的字符，这时会遇到两种情况：  
1. 当前字符是 $s$ 串中最大的字符，即没有比它大的字符可以替换，这时就需要考虑前一位，依次遍历，直到找到可替换的字符就退出。
2. 当前字符不是 $s$ 串中最大的字符，于是就在 $t$ 串中找第一个比它大的字符来替换（贪心），随后同①，剩下的字符全部用 $t_n$ 替换。  

**举个例子：**  
$n = 5, k = 4, s = abdda$ ，此时 $t$ 应为 $"ddbaa"$ ，从第 $k$ 位开始找：
- $i = 4$ ，此时 $s_4 = 'd'$ 为 $s$ 中最大的字符，所以往下遍历；
- $i = 3$ ，此时 $s_3 = 'd'$ 依然为 $s$ 中最大的字符，继续往下遍历；
- $i = 2$ ，此时 $s_2 = 'b'$ 不是最大的字符，可以找到 $t$ 中第一个比 'b' 大的字符 'd'，所以 $s_2 = 'd'$ ，跳出循环；
- 先输出 $i$ 位字符，即 $"ad"$ ，然后剩下 $k - i$ 位字符全部输出 $t_n$ ，即 $'a'$ ，所以最终答案为 $"adaa"$ 。

**以下是该部分的代码（ $t$ 已是 $s$ 从大到小排序后的字符串）：**  
```
for (i = k; i >= 1; i--) { //从第k位开始遍历
	for (j = 1; j <= n; j++) //找到第一个大于s[i]的字符 
		if (t[j] <= s[i])
			break;
	if (j != 1) { //说明当前字符不是最大字符，于是替换，退出
		s[i] = t[j - 1]; //注意第j位是第一个小于等于s[i]的字符，第j-1位才是第一个大于s[i]的字符
		break;
	} //否则就继续往下遍历
}
for (j = 1; j <= i; j++)
	printf("%c", s[j]); //输出前i位
for (j = i + 1; j <= k; j++)
	printf("%c", t[n]); //剩下的全部输出t[n]（贪心）
```
### ③ $n = k$ ：
这种情况和 $n > k$ 的情况差不多，思路和②几乎相同 **（详见样例1、样例3）**，这里就不再赘述，上代码：
```
for (i = k; i >= 1; i--) {
	for (j = 1; j <= n; j++) 
		if (t[j] <= s[i])
			break;
	if (j != 1) { 
		s[i] = t[j - 1]; 
		break;
	}
}
for (j = 1; j <= i; j++)
	printf("%c", s[j]); 
for (j = i + 1; j <= n; j++)
	printf("%c", t[n]); 
```
大家可以发现，②和③的代码几乎一致，只是倒数第2行的循环终止条件不同，但实际上它们是完全相同的，因为在③中， $n$ 本身就是等于 $k$ 的，所以可以把这两种情况合并。

------------
### Code：
```
#include <iostream>
#include <cstdio>
#include <cstring>
#include <string>
#include <algorithm>
#define N 110000
using namespace std;
int n, k, i, j;
char s[N], t[N];
bool cmp(char e, char f) { //从大到小排序
	return e > f;
}
int main() {
	scanf("%d%d%s", &n, &k, s + 1); //s + 1 可以让字符数组下标从1开始
	for (i = 1; i <= n; i++)
		t[i] = s[i]; //先复制字符数组s中的字符到t
	sort(t + 1, t + 1 + n, cmp); //将t从大到小排序
	if (n < k) { //第①种情况
		for (i = 1; i <= n; i++)
			printf("%c", s[i]); //原封不动输出s
		for (i = n + 1; i <= k; i++)
			printf("%c", t[n]); //剩下的字符输出s中最小的字符，即t[n]。
	}
	else { //第②③种情况
		for (i = k; i >= 1; i--) { //从第k位开始遍历
			for (j = 1; j <= n; j++) //找到第一个大于s[i]的字符
				if (t[j] <= s[i])
					break;
			if (j != 1) { //说明当前字符不是最大字符，于是替换，退出
				s[i] = t[j - 1]; //注意第j位是第一个小于等于s[i]的字符，第j-1位才是第一个大于s[i]的字符
				break;
			} //否则就继续往下遍历
		}
		for (j = 1; j <= i; j++)
			printf("%c", s[j]); //输出前i位
		for (j = i + 1; j <= k; j++)
			printf("%c", t[n]); //剩下的全部输出t[n]（贪心）
	}
	return 0;
}
```
### 结束~Over~