p1549   
### 题面   
在N×N的棋盘上(1≤N≤10)(1≤N≤10)，填入1,2,…,N^2-1,N^2
 共N^2
 个数，使得任意两个相邻的数之和为素数。

例如：当N=2时，有：   
1 2  
4 3

其相邻数的和为素数的有：

1+2,1+4,4+3,2+3,1+2,1+4,4+3,2+3
当N=4时，一种可以填写的方案如下：  
1      2       11      12  
16     15      8       5  
13     4       9       14  
6      7       10      3

在这里我们约定：左上角的格子里必须填数字1。

如有多种解，则输出第一行、第一列之和为最小的排列方案；若无解，则输出“NO”。

、、、解题：    
带有技巧的搜索     
我们知道1是固定的，所拥有的数也是有限的，首先最简单的思路直接深搜一个个放数试，放一个数计算是否和相邻的数相加为素数        
但是有多种方案，并要求第一行第一列的和最小   
于是用一个贪心的思想优化搜索     
怎样使第一行第一列最小？       
我们现在拥有的数是从1~n * n        
那么贪心一下，在第一行第一列的时候尽可能拿小的        
###### 那么顺着拿不就好了吗？         
再反过来，放里面的数时，在满足相邻的数和为素数的条件下，数的大小和位置是没有影响的。我们为了给第一行第一列留下小的，便尽可能把大的数往内放
###### 那么倒着放不就好了吗？
假设第一行第一列构成一个整体，其他构成一个整体         
这样一来就形成了在深搜满足相邻数和为素数的条件下，内部最大外部最小的问题

对于搜索过程：（4，4）
首先我们从（1,1）开始，向（1,2）搜索     
将2放入，发现2+1=3是素数满足条件，再到（1,3）发现3可以…………    
到第二行（2,2）时，我们开始倒放   
放入16，发现2+16=18不合题意，再试15 ，5+15=20不合题意，……然后我们居然发现   
###### 死局       
 我们观察一下这里，可以发现就算没有上限随便放数，这里也不会存在一个解         
 ###### 观察样例
 1      2       11      12  
16     15      8       5  
13     4       9       14  
6      7       10      3     
我们发现  
##### 一个奇数的上下左右都是偶数
##### 一个偶数的上下左右都是奇数     
这是偶然吗？？？？？      
我们回忆数学知识奇偶性
#### 奇+奇=偶
#### 偶+偶=偶
#### 奇+偶=奇
### 又因为~~~~尘归尘土归土~~~~
### 比2大得偶数 一定是合数      
那么有用的就是   奇+偶    了

看回我们的    
1   2    3    4       
5   x      
这时，x不管填什么，都会出现奇+奇，偶+偶其中一种，一定无解          
所以我们搜索放数的时候和检验等时候可以加一个大剪枝---》奇找偶，偶找奇     
code：        
```cpp
#include<bits/stdc++.h>
#define fu(i,q,w)  for(register int i=q;i<=w;i++)
#define fd(i,q,w)  for(register int i=q;i>=w;i--)
using namespace std;
typedef long long ll;
inline int read(){
    int ret=0,f=1;char c;
    while((c=getchar())<'0'||c>'9')if(c=='-')f=-1;
    while(c>='0'&&c<='9')ret=ret*10+(c-'0'),c=getchar();
    return ret*f;
}
int n;
int mp[11][11];
int vis[111];
int prime[333];
int ewe[333];
inline bool check(int x,int y,int z){
	if(mp[x-1][y]%2!=z%2||mp[x-1][y]==0){
		if(mp[x][y-1]%2!=z%2||mp[x][y-1]==0){
			if(mp[x+1][y]%2!=z%2||mp[x+1][y]==0){
				if(mp[x][y+1]%2!=z%2||mp[x][y+1]==0){
					return true;//其实好像只判减1就行…… 
				}
			}
		}
	}
	else return false;
}
inline void dfs(int x,int y){
	  if(x>n){
        for(int i=1;i<=n;i++){
            for(int j=1;j<=n;j++)
            printf("%d ",mp[i][j]);
            printf("\n");
        }
        exit(0) ;
    }
	//都成功放过一遍了就退出 
		if(x==1||y==1)//如果是第一排或第一列就正着找数
			fu(i,2,n*n){ 
				if(vis[i])continue;
				if(

  ( x==1&&y!=1 && !prime[i+mp[x][y-1]]  && check(x,y,i) )||
  ( x!=1&&y==1 && !prime[i+mp[x-1][y]]  && check(x,y,i) )
				   
				   ){//加起来是不是素数,奇偶性 
				   	mp[x][y]=i;//可以赋值啦 
				   	vis[i]=1;//访问标记 
				   	if(y==n)dfs(x+1,1);//递归求解 
				   	else dfs(x,y+1);
				   	mp[x][y]=0;// 回溯 
				   	vis[i]=0;
				    }
			}
		else{//如果不是就反着找数
			fd(i,n*n,2){
				if(vis[i])continue;
				if(check(x,y,i)&&!prime[i+mp[x-1][y]]&&!prime[i+mp[x][y-1]]){
				mp[x][y]=i;
				 vis[i]=1;
				 if(y==n)dfs(x+1,1);
				 else dfs(x,y+1);
				 mp[x][y]=0;
				 vis[i]=0;
			} 
		
		}
    }
}
int main(){
	n=read();
	if(n==1){printf("NO");	return 0;	}
	int t;
	fu(i,2,n*n*2)//先把素数线性筛出来 
	{
		if(!prime[i]){
			ewe[++t]=i;
		}
		fu(j,1,t){
			if(i*ewe[j]>200)break;
			prime[i*ewe[j]]=true;
			if(i%ewe[j]==0)break;
		}
	 } 
	 mp[1][1]=1;vis[1]=1;
	 ·dfs(1,2);

	 printf("NO")*;
	 return 0。;
	 
}
		
```

 
 