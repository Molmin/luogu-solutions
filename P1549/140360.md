## 一点说明
很抱歉，题解通过后交了一下加强版，就过不了了，如果只是 TLE 还可以理解，然而还 WA 了几个点，经检查发现我的算法存在问题，这里进行修正，给出了虽然大数据会超时，但是算法思想是没有问题的解法！（当然是可以通过此题的）


## 题目链接

[P1549 [NOIP1997 提高组] 棋盘问题](https://www.luogu.com.cn/problem/P1549)


------------

## 解决问题

明显是深搜题。搜索时参数 $x,y$，表示当前要填充 $(x,y)$ 位置。对于一个位置，枚举所有可能的数，如果这个数没有被使用过，且填充之后和 $(x-1,y)$、$(x,y-1)$ 上的数之和均为素数，那么就把这个数填上（边界情况要特殊处理，防止越界）。

如有多种解，则输出第一行、第一列之和为最小的排列方案，好几篇题解以及我之前的思路是填第一行或第一列的数时要从小到大枚举，其余的数从大到小枚举，这样我们搜到的第一组解便是最终的正确答案。然而能过小数据只是巧合，这个贪心策略存在问题，因为如果比较靠前的位置舍弃一个较小值，后面的数可能反而填的比较理想。而如果这样贪心，前面的数比较小，却很有可能导致虽然是第一组解，但是后面在第一行和第一列却搜出了不少大数。

由于此题数据较小，这里采取的方法是尝试所有情况，如果一个数处于第一行或第一列，那么就把它的值累加到 $tot$ 变量中，当搜完一种情况，去和当前所有情况的 $tot$ 中最小值比较，如果更优秀则把当前搜出的矩阵更新为最优解。搜索过程中一旦 $tot$ 超过了当前所有情况中 $tot$ 的最小值，果断返回。

对于素数的判断，为了节省时间，这里的做法是先自己写一个筛素数，做成表，如果 $i$ 为素数，那么 $p_i$ 标记为 $1$，否则为 $0$。

题目要求 $(1,1)$ 固定为 $1$，那么我们从 $(1,2)$ 开始搜（为了使 $N=1$ 时不越界，把这时的情况加一个特判输出即可）。

当然有诸多优化，但这个题数据很小，完全用不上，比如优化搜索顺序、预处理可能的数字等等。

## 上代码（有注释）
```
#include<bits/stdc++.h>
using namespace std;
bool p[200]={0,0,1,1,0,1,0,1,0,0,0,1,0,1,0,0,0,1,0,1,0,0,0,1,0,0,0,0,0,1,0,1,0,0,0,0,0,1,0,0,
			0,1,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,1,0,1,0,0,0,0,0,1,0,0,0,1,0,1,0,0,0,0,0,1,
			0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,1,0,1,0,0,0,1,0,1,0,0,0,1,0,0,0,0,0,0,
			0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,1,0,0,
			0,0,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,1,0,1};//素数桶 
int n;
int cnt=0;
bool vis[110];
int a[15][15];
int tag=0;
int tot=0;
int minn=99999999;
int Q[15][15];
void dfs(int x,int y){
	if(tot>=minn)//tot大于当前最小值，return 
		return;
	if(x==n+1){//搜到n+1行，证明找到一组解了 
		if(tot>=minn)//如果这组解不是最优，就不去记录了 
			return ;
		minn=tot;//更新最小值 
		tag=1;//打上标记证明有解 
		for(int i=1;i<=n;i++)
			for(int j=1;j<=n;j++)
				Q[i][j]=a[i][j];//更新最终答案的矩阵 
	}
	/*下面正式开始搜了，很好理解，就是边界情况要稍作处理*/
	if(x==1){
		for(int i=2;i<=n*n;i++){
			if(!vis[i]&&p[i+a[1][y-1]]){
				vis[i]=1;
				a[x][y]=i;
				tot+=i;
				if(y==n)
					dfs(x+1,1);
				else
					dfs(x,y+1);
				tot-=i;
				vis[i]=0;
			}
		}
	}
	if(y==1){
		for(int i=2;i<=n*n;i++){
			if(!vis[i]&&p[i+a[x-1][1]]){
				vis[i]=1;
				a[x][y]=i;
				tot+=i;
				dfs(x,y+1);
				vis[i]=0;
				tot-=i;
			}
		}
	}
	if(x!=1&&y!=1){
		for(int i=2;i<=n*n;i++){
			if(!vis[i]&&p[i+a[x][y-1]]&&p[i+a[x-1][y]]){
				vis[i]=1;
				a[x][y]=i;
				if(y==n)
					dfs(x+1,1);
				else
					dfs(x,y+1);
				vis[i]=0;
			}
		}
	}
}
int main(){
	cin>>n;
	if(n==1){
		cout<<"NO";
		return 0;
	}
	a[1][1]=1;
	memset(vis,0,sizeof(vis));
	dfs(1,2);
	if(tag==0){//判断无解情况
		cout<<"NO";
		return 0;
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			cout<<Q[i][j]<<' ';
		}
		cout<<endl;
	}
	return 0;
}
```
