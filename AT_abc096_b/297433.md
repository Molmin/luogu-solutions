### 位运算这么好用，为什么没人用呢？我永远爱位运算

这可以算是一个贪心题，选最大的数乘$2^k$即可。正确性证明如下：

总共$3$个数，选$1$个数乘$2$，相当于加上他自己，那加上谁使总和最大呢？自然是最大的数了，而最大的数乘$2$后，仍是最大的，那么仍然要将他乘$2$，所以最终乘了$k$个$2$，所以乘了$2^k$，证明完毕。

由于在计算机中数是以二进制储存的，将一个数的二进制左移$1$位，并在最低位补$0$，相当于将这个数$\times2$（十进制的末尾补$0$就相当于$\times10$），所以我们将这个数乘$2^k$，就相当于把这个数乘上$1$的二进制左移了$k$位的结果。如何实现呢？1<<k即可。

代码如下：

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int main()
{
    int a,b,c,k;//输入
    scanf("%d%d%d%d",&a,&b,&c,&k);
    if  (b>a)   swap(a,b);
    if  (c>a)   swap(a,c);//以上2行保证了a里的数是最大值，比较方便操作
    a*=1<<k;//将a乘2^k，原因见说明
    printf("%d\n",a+b+c);//直接输出答案，注意换行
    return 0;
}
```

我们最后估计一下会不会爆int，当 $a=b=c=50,k=10$ 时，结果 $=50\times2^{10}+50+50=51300$，不会爆int。