## 如果这篇题解通过了，那它就是本蒟蒻的第一篇题解了

不要问我为什么突然想写题解，~~可能是因为上课的时候突然脑抽？或者突然手闲？（bu）~~ 
大概是因为想挑战一下最短代码叭……~~方法不重要~~

~~**其实也没指望着能被通过，Zoe在线作死**~~

### 咳咳，以下正文：

因为做这道题前刚做过最长上升子序列，所以很快就想出来dp怎么做了——把判断条件改一下就好啦。

那么判断条件怎么写呢？此处我用到的是string自带的函数substr。举例如下：

```cpp
string s="123456";
string t=s.substr(0,3); //从s的0号位置截取连续的长度为3的子串
cout <<t; 
```

所以上面程序输出的是123。

那么我们的dp怎么写呢？作为一只初学dp的蒟蒻，老师告诉我需要考虑四点问题：

1. 状态：$f_i$ 表示以第$i$号位置结尾最多可以取的单词数

2. 答案：$f_n$

3. 转移：$f_i = max(f_j+1,f_i)$

4. 初值：$f_i = 1$

那接下来的事情就很简单了，按照上述思路写代码就好啦，AC代码奉上：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n, f[2010], ans;
string s[2010];
int main()
{
	scanf ("%d", &n);
	for (int i=1; i<=n; i++)
		cin >>s[i];
	
	for (int i=1; i<=n; i++)
	{
		f[i] = 1;
		for (int j=1; j<i; j++)
			if (s[j]==s[i].substr(0,s[j].size())) //从s[i]的0号位置截取s[j]长度的子串，判断是否与s[j]相等。
				f[i] = max(f[j]+1, f[i]);
		ans = max(f[i], ans);
	}
	printf ("%d", ans);
	return 0;
}

```
