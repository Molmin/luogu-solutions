
题目分析：

考虑贪心。

结论是当出现仅有一个星号处于一个二阶矩阵的一个角时，将其改成点。

也就是：

	.*	*.	..	..
    ..	..	*.	.*
这四种情况中的任意一个。

------------
为什么这样是对的。

首先是充分性。发现如果这样的小矩形一定是最小的一种构不成矩形的情况，而且一定不存在避开这种情况的且无法构成矩形的方案。

然后是必要性。同样是因为这样的矩形是最小的可能的无法构成矩形情况，将所有的小矩形更改完后一定是合法情况，所以再进行额外更改一定是不优的。

感性理解。

------------
代码:

```cpp
#include<cstdio>
using namespace std;
char m[2005][2005];
int n,mm,dx[8]={0,0,1,-1,1,1,-1,-1},dy[8]={1,-1,0,0,-1,1,1,-1};
void dfs(int x,int y){
	if(m[x][y]=='.'||x>n||x<=0||y>mm||y<=0)return;
	if(	(m[x+1][y]=='.'&&m[x][y+1]=='.'&&m[x+1][y+1]=='.')||
		(m[x+1][y]=='.'&&m[x][y-1]=='.'&&m[x+1][y-1]=='.')||
		(m[x-1][y]=='.'&&m[x][y+1]=='.'&&m[x-1][y+1]=='.')||
		(m[x-1][y]=='.'&&m[x][y-1]=='.'&&m[x-1][y-1]=='.')){
		m[x][y]='.';
		for(int i=0;i<=7;i++)
		dfs(x+dx[i],y+dy[i]);
	}
}
int main(){
	scanf("%d%d",&n,&mm);
	for(int i=1;i<=n;i++){
		for(int j=1;j<=mm;j++){
			scanf("%c",&m[i][j]);
			if(m[i][j]=='\n')
			scanf("%c",&m[i][j]);
		}
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=mm;j++){
			if(m[i][j]=='*')
			dfs(i,j);
		}
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=mm;j++){
			printf("%c",m[i][j]);
		}
		printf("\n");
	}
	return 0;
}
```
