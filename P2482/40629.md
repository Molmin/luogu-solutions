### 简述
~~简述个鬼~~
[思维导图版本](https://mubu.com/doc/PLHEif1xo)

### Solution

我写之前学习了[loj这位大佬的提交](https://loj.ac/submission/606249)(我不会说是我写到一半发现无懈可击不怎么会写),然后后来就把其他部分改得跟他一致了(他写得太精简了，下面会说明),希望为他起一个注解的作用

这是一个类似(~~抄袭~~)三国杀的游戏

我们一句一句的来看一只猪有那些信息:

>主猪（MP）：自己存活的情况下消灭所有的反猪。
忠猪（ZP）：不惜一切保护主猪，胜利条件与主猪相同。
反猪（AP）：杀死主猪。

这是类型

>游戏开始时候，每个玩家手里都会有4张牌，且体力上限和初始体力都是4。

这是体力，和牌

>1.如果没有猪哥连弩，每个出牌阶段只能使用一次“杀”来攻击；
2.任何牌被使用后被弃置（武器是装备上）；

牌分为手牌(消耗品),武装(永久品):只有猪哥连弩

>◎献殷勤：使用无懈可击挡下南猪入侵、万箭齐发、决斗；使用无懈可击抵消表敌意；
◎表敌意：对某个角色使用杀、决斗；使用无懈可击抵消献殷勤；
◎跳忠：即通过行动表示自己是忠猪。跳忠行动就是对主猪或对某只已经跳忠的猪献殷勤，或者对某只已经跳反的猪表敌意；
◎跳反：即通过行动表示自己是反猪。跳反行动就是对主猪或对某只已经跳忠的猪表敌意，或者对某只已经跳反的猪献殷勤；
忠猪不会跳反，反猪也不会跳忠；不管是忠猪还是反猪，能够跳必然跳；

除了主猪外只有通过跳身份的办法来显示身份

所以我们定义一只猪
```cpp
struct Pig{
	char type,card[M],weapon,show;//类型,卡,武器有无,我表示(不表示0)我是什么身份(1忠/主猪,2反猪,3类反猪)
	int heal,cardnum;//血量,卡数 
}a[N];
```

他的行为有抽牌，用牌，找牌(并用掉)

```cpp
struct Pig{
	char type,card[M],weapon,show;//类型,卡,武器有无,我表示(不表示0)我是什么身份 
	int heal,cardnum;//血量,卡数 
	inline void Delete(re int&x){re int i;--cardnum;for(i=x;i<=cardnum;++i)card[i]=card[i+1];--x;}//丢掉第x张牌
	inline char Find(re char a){re int i;for(i=1;i<=cardnum;++i)if(card[i]==a)return Delete(i),1;return 0;}//检查手牌有没有a
	inline void Get(re int x){while(x--){card[++cardnum]=st[++top];if(top==m)--top;}}//牌堆摸x张 
}a[N];
```

另外我们用一个双向链表来维护猪之间位置关系，这样删除很方便

接下来看手牌

>◎基本牌：
『桃(P)』：在自己的回合内，如果自己的体力值不等于体力上限，那么使用一个桃可以为自己补充一点体力，否则不能使用桃；桃只能对自己使用；在自己的回合外，如果自己的血变为0或者更低，那么也可以使用；
『杀(K)』：在自己的回合内，对攻击范围内除自己以外的一名角色使用。如果没有被『闪』抵消，则造成1点伤害。无论有无武器，杀的攻击范围都是1；
『闪(D)』：当你受到杀的攻击时，可以弃置一张闪来抵消杀的效果；
◎锦囊牌：
『决斗(F)』：出牌阶段，对除自己以外任意一名角色使用，由目标角色先开始，自己和目标角色轮流弃置一张杀，首先没有杀可弃的一方受到1点伤害，另一方视为此伤害的来源；
『南猪入侵(N)』：出牌阶段，对除你以外所有角色使用，按逆时针顺序从使用者下家开始依次结算，除非弃置一张杀，否则受到1点伤害；
『万箭齐发(W)』：和南猪入侵类似，不过要弃置的不是杀而是闪；
『无懈可击(J)』：在目标锦囊生效前抵消其效果。每次有一张锦囊即将生效时，从使用这张锦囊的猪开始，按照逆时针顺序，依次得到使用无懈可击的机会；
效果：用于决斗时，决斗无效并弃置；用于南猪入侵或万箭齐发时，当结算到某个角色时才能使用，当前角色不需弃置牌并且不会受到伤害（仅对一个角色产生效果）；用于无懈可击时，成为目标的无懈可击被无效。

我们会发现『杀(K)』『南猪入侵(N)』『万箭齐发(W)』攻击力都是1,新建一个功能$Defend(x,y)$表示$x$成功伤害$y$,注意到这一次可能触发

>如果自己的血变为0或者更低，那么也可以使用桃

还可能杀死它猪

```cpp
inline void Defend(re int x,re int y){//x砍y一点血 
	if(!--a[y].heal)a[y].heal+=a[y].Find('P');//能用桃就用 
	if(!a[y].heal)Kill(x,y);//杀死了
}
```

对于$x$杀死$y$，先看胜利条件
>主猪（MP）：自己存活的情况下消灭所有的反猪。
忠猪（ZP）：不惜一切保护主猪，胜利条件与主猪相同。
反猪（AP）：杀死主猪。

再判一下几种情况

>◎玩家死亡：如果该玩家的体力降到0或者更低，并且自己手中没有足够的桃使得自己的体力值回到1，那么就死亡了，死亡后所有的牌（装备区，手牌区）被弃置；
◎奖励与惩罚：反猪死亡时，最后一个伤害来源处（即使是反猪）立即摸三张牌。忠猪死亡时，如果最后一个伤害来源是主猪，那么主猪所有装备牌、手牌被弃置；
◎注意，一旦达成胜利条件，游戏立刻结束，因此即使会摸3张牌或者还有牌可以用也不用执行了。

```cpp
inline void Kill(re int x,re int y){//x把y杀了的结果 
	if(a[y].type=='M')Print();//忠猪被杀 
	if(a[y].type=='F'){
		if(!(--enemynum))Print();//敌人杀完 
		a[x].Get(3);//没结束要摸牌
	}
	else if(a[x].type=='M'&&a[y].type=='Z')a[x].cardnum=a[x].weapon=0;//我杀我忠猪
	r[l[y]]=r[y],l[r[y]]=l[y];//去掉y
}
```

最困难的判定是无懈可击，我们要看$x$可不可以攻击$y$,首先看$y$可不可以被队友(这地方就涉及到显示的身份)无效，然后再看这个无效可不可以被**成功**无效(成功无效就代表之后再没有一个无效)

我们会发现这是一个递归的过程，重点是理解无效本身是一种会被无效的行为

```cpp
inline char WXKJ(re int x,re int y){
	re int i;re char first; 
	for(i=x,first=1;(first||(i^x));i=r[i],first=0)
		if((!y?CanDefend(i,x):MyPig(i,y))&&a[i].Find('J')){//有y是看友军可不可以无效别人攻击保护你，没y是看敌人可不可以无效你的无效,递归次数%2表示到底实在阻止这场攻击发生 
			a[i].show=(a[i].type=='F'?2:1);
			return !WXKJ(i,0);//你不能无效我才发动行为(包括无效)成功
		}
	return 0;
}
```

在这里判定别人是什么猪就要用到别人显示的身份(而不是真实身份)

```cpp
inline char CanDefend(re int x,re int y){
	return ((a[x].type=='M'&&(a[y].show==2||a[y].show==3))||(a[x].type=='Z'&&a[y].show==2)||(a[x].type=='F'&&a[y].show==1));
}
inline char MyPig(re int x,re int y){
	return (((a[x].type=='M'||a[x].type=='Z')&&a[y].show==1)||(a[x].type=='F'&&a[y].show==2));
}
```

然后具体写每个手牌的操作就可以了

### Code
[这里](https://paste.ubuntu.com/p/NBqMWgmdDt/)