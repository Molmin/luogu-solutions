题目的一个小BUG：牌堆可能为空，这时不断复制最后一张牌即可，否则会五彩缤纷（其实只有4种颜色）

这题是超级“简单”的模拟题，坑点很“少”

奋战了7个小时，终于写出来了，554行（我写过的最长代码）

这题是目前为止我编程用时第二的题（第一是逛公园 9h）

~~按题意模拟即可~~

这种大模拟(基本)不用考虑性能，应该尽量降低编程复杂度和调试难度

考虑清楚后再编程

------------

我写的很面向对象，~~然后有一个类包含8个类函数~~，另外用了大量指针

根据题意，实际可以不考虑献殷勤和表敌意本身

直接考虑跳忠和跳反即可

可以认为主公也是试图跳忠，绝不跳反

建立玩家和手牌类

需要考虑如何记录足够的信息，并设计一些类函数

这是我考虑的，可以参考一下

玩家：变量有：手牌，体力值，是否有弩，身份，暴露的身份； 操作有：摸牌，出牌，清空牌堆，对其他玩家出的牌作出反应，受到伤害，死亡

记录手牌时我给每种牌开了一个链表

牌：类型，使用

然后我又写了一个游戏类

变量有：玩家列表，玩家数，剩余反贼数

操作有：使用南蛮入侵\万箭齐发，请求出无懈可击

写空函数可以不用考虑排列顺序，缺啥就实现啥，用不到的可以只写空函数，不实现，也不会CE

写好后逐个实现函数即可，发现需要其它函数就直接加上一个，然后实现

显示牌的过程我直接把牌扔进一个数组，然后sort后输出


------------

小心细节

杀：只能当下一个玩家暴露身份后才能用，别忘了判断是否可以一回合使用多次，只能攻击下一个玩家

决斗：注意反贼只会对主公使用决斗，忠臣不会在与主公决斗时出杀，一旦出了杀，就不会被无懈掉

如果把自己干掉，就不能继续出牌

南蛮&万箭：会产生类反猪，但并未暴露身份

这两个很相似，应该注意区分，改的时候通常要一起改

无懈可击：从使用锦囊的玩家开始决定是否出，使用无懈可击后从出无懈可击的人开始决定是否出，而不是出第一个锦囊的人先决定

如果按我这个思路，根据回应执行操作时不要调用两次回应函数，否则会死得很惨

小心不要重复执行操作

不要把回应动作弄混，最好定义常量，然后判相等

可以把常量弄得各不相同，这样如果混用会容易发现

清空主公的牌时要把弩卸掉

实在不行找篇题解“对拍”查错

------------

不建议写一堆数组记录，这样很难调试

面向对象和模块化的程序很容易找出错误的地方

递归也是个好东西

最后上代码，有注释，应该能看懂

DEBUG变量为true时会输出出完每张牌后的局面

~~比赛时千万别忘了去掉调试信息~~

[代码](https://www.luogu.org/paste/qsxjc217)（防止~~引人注目~~占版面）