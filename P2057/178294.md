[题目](/problem/P2057)

这算是一个经典（？）的网络流建模题了吧。

写这篇题解主要是想记录一下建模的套路。

下面默认你已经会最大流了。

### 分析

题目求“最小的冲突数”，怎么求？

最大流似乎是用来求最大的，怎么求最小？

根据**最大流最小割定理**，如果残量网络已经没有增广路（即残量网络已经不连通了），那当前流就是最大流，同时也是最小割。

所以考虑建一个图，当这个图被分成至少两部分不连通时，得到最小割，即最小的冲突数。

于是想到，当这个图不连通时，和源点在同一连通子图中的结点，选择睡午觉，其余结点选择不睡午觉。

那可以考虑**给每个自己意愿是睡午觉的结点，连一条边到源点；给自己意愿是不睡午觉的结点，连一条边到汇点。**

这样，如果连向源点的边断了，说明选择不睡午觉，违背了本来的意愿；如果这条边没断，说明选择睡午觉。一次断边对应一次冲突。

那“好朋友”怎么体现呢？

如果一对好朋友，同时选择睡午觉，应该并不会断开一条边；如果一个选择睡午觉，一个选择不睡午觉，就应该断开一条边。

意思是：如果一对“好朋友结点”都和源点连通，应该不会断开一条边；如果这对点一个和源点连通，一个不连通，就应该断开一条边。

建模方法不就出来了吗：**给每对“好朋友结点”连一条边**。如果这对点都和源点连通，这条边就不会断；如果这对点一个连通一个不连通，那这条边肯定会断。

然而这个图也有可能断成三部分、四部分或者更多。

不过根据割的定义，只要**将图的点分成两个集合，源点和汇点分别属于两个集合，且两个集合直接不连通**就行了，并没有要求集合内部是连通的。

比如 $S$ 集合定义为和源点连通的结点，那么其余的结点虽然不一定和汇点连通，但都在 $T$ 集合里，所以不用考虑 $T$ 集合内部断边造成的问题。（$T$ 集合内部断开的边不算进割中）

### 核心代码

（去掉最大流板子）

```cpp
int main(){
	cin>>n>>m; S=n+1; T=n+2;
	//S 表示源点，T 表示汇点
	for(int i=1;i<=n;i++){
		int t; cin>>t;
		if(t) add(S,i,1);//如果本来意愿是睡午觉，就连到源点
		//add(u,v,w) 表示连一条 (u,v) 的边，流量限制是 w
		else add(i,T,1);//如果本来意愿是不睡午觉，就连到汇点
	}
	for(int i=1;i<=m;i++){
		int u,v; cin>>u>>v;
		add(u,v,1); add(v,u,1);//给每对好朋友结点连一条双向边
	}
	n+=2;//将源点和汇点算到 n 里
	//运行最大流
	cout<<ans<<endl;
	return 0;
}
```