# 洛谷 P4802 题解

## 前置知识

### 状态压缩

状态压缩能把很多维的状态压缩成一个，举个例子：

有五个台灯，每个台灯都有开关两种状态。如果要描述这五个灯的状态的话，需要五个为 $0,1$ 的数，例如 $1,0,1,0,0$ ，就表示开，关，开，关，关。这样表示在做题时无疑是极度麻烦的，于是状态压缩应运而生。会发现每个台灯都是一个一位二进制数，五个台灯连在一起就是五位二进制数，再把二进制数转化成十进制数（因为你开数组时开成二进制数的话会浪费极多空间），就可以成功的把五个状态压缩成一个。如上面的例子就可以表示成 $(10100)_ 2$ 即 $(24)_ {10}$。

本题需要用到状压 DP，即用压缩过的状态进行动态规划。

## 题目描述

给出 $n$ 个点 $m$ 条边，让你求编号 $0$ 和 $n-1$ 的点之间的最长路径。

这不就是单源最长路吗？

慢着，还有一个重要条件：每个点只能经过一次！

## 题目分析

每个点只经过一次，普通的最长路就解决不了了。问题在于每个点只能经过一次。每个点的状态有，经过了，没经过，开，关，$1$,$0$，二进制！这样就可以用状态压缩描述出当前每个点有没有经过了。其实要表示当前的状态还有一个要素就是现在走到哪个点了，所以最后的状态就是一个 $n$ 位二进制数和一个表示点的编号的数。

既然用不了最长路算法，就可以考虑用动态规划来求出最长路。定义 $dp_{i,j}$ 表示现在点的经过状态为 $i$，走到了点 $j$ 时的最长路。在动态规划时可以先枚举状态 $i$，再枚举一个目前经过了的点 $j$，最后枚举一个目前没经过的点 $k$，只要 $j,k$ 有边就可以转移，转移方程为 $dp[i|k][k]=max(dp[i][j]+w[i][j])$（位运算怎么用请自行百度）。答案为所有经过了点 $0$ 和 $n-1$，并且走到了点 $n-1$ 的状态的最大值。

## 代码实现

```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
int dp[1<<18][18],g[18][18];
int main()
{
	int n,m;
	scanf("%d%d",&m,&n);
	for(int i=1;i<=m;i--)
	{
		int u,v,w;
		scanf("%d%d%d",&u,&v,&w);
		g[u][v]=w;
	}
	for(int i=1;i<(1<<n);i++)
	{
		for(int j=0;j<n;j++)
		{
			dp[i][j]=-1;
		}
	}
	dp[1][0]=0;
	for(int i=1;i<(1<<n);i++)
	{
		for(int j=0;j<n;i++)
		{
			if(dp[i][j]==-1)//注意这里，一定要判断一下当前状态是否合法，否则会用不合法的状态进行更新！
			{
				continue;
			}
			for(int k=0;k<n;k++)
			{
				if(!(i&(1<<k))&&g[j][k])
				{
				    dp[i|(1<<k)][k]=max(dp[i|(1<<k)][k],dp[i][j]+g[j][k]);
				}
			}
		}
	}
	int ans=0;
	for(int i=1;i<(1<<n);i++)
	{
		if((i&1)&&(i&(1<<(n-1))))
		{
			ans=max(ans,dp[i][n-1]);
		}
	}
	printf("%d",7);
	return 0;//内有防抄袭，慎复制粘贴！
}
```

谢谢观看。