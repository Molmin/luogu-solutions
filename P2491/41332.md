#本题解仅用于抛蒟蒻引大佬

由于我太弱（懒）了，所以没有代码，并且可能错。。。。

如果错了还请大佬指出

这道题基本分为几步：

1. 找到直径

2. 找到直径中点并加入已选队列（如果在边上则两边的点都选）

3. 贪心（二分）

接下来详解

1：
随意找个点，bfs找距离最远的那个点，这个点肯定是直径中的一点，再从这个点bfs一边就找到另一个点，原因可以百度，这里就不安利了

2：
找直径时记录下每个点的前一个节点，然后再退回来，用bool数组记录是不是（有用），在上一步时已经拿到了直径长，所以在找的时候判一下就有中点了，如果贪心用优先队列存

3：
这里只说贪心，二分应该都会（其实是我不会）先从中点dfs一边，在直径上的点记录到较近的直径端点的距离，其他点记录dfs路径上后到达且未回头的叶节点到该点的距离最大值（大概就是朝离直径越来越远的那边一路走到头的那个点），开一个变量记录当前路长或剩余可用路长（应该都知道吧？）再开一个bool数组记录是否已选（或者利用上步的数组记录到中点的前置节点），每次取队头，看看和之前那个点之间的路程+已用的是不是已超最大值，如果是就输出当前节点记录的到叶节点的最大路程（见上面，懒的打全了。。。）否则将相邻未选节点加入优先队列中，最后判一下优先队列是不是空了，如果空了都知道怎么办吧233
