由于动态规划要满足无后效性和最优化原理，所以我们来分析此题是否满足以上两点。首先确定状态，商品不超过5种，而每种采购的数量又不超过5，那么可以用一个5维数组来表示第i种商品买Ai的最小费用:   
```
	F[A1][A2][A3][A4][A5]
```  
考虑这个状态的由来，当然，我们不用优惠商品也可以买，显然这样不是最优。于是如果我们能够使用第i条商品组合Si的话，状态就变为了
```
	F[A1-Si1][A2-Si2][A3-Si3][A4-Si4][A5-Si5]（但是要注意边界）
```  
这样的话，状态1的费用为状态2的费用加上Si的费用，而状态2的费用必须最低（很显然，用反证法可证明），同时我们也不管状态2是如何来的（因为每一个优惠商品的组合的使用是没有限制的），所以本题既满足无后效性，又符合最优化原理，同时还有大量重叠子问题产生，动态规划解决此题再好不过了。   
由于0<=b<=5,1<=k<=5,故可用5x5x5x5x5的DP，又因为每种买0到5个，故可以用6进制表示，5维DP即可    
设 F[b1][b2][b3][b4][b5] 为买b1件物品1......b5件物品5时，需要的最少价格。    
则状态转移方程为
```
	f[b1][b2][b3][b4][b5]=min(f[b1][b2][b3][b4][b5],f[b1-p[i][1]][b2-p[i][2]][b3-p[i][3]][b4-p[i][4]][b5-p[i][5]]+P[i][0]),其中i=1,...,(s+b)且ak-p[i][k]>=0
```
边界条件f[0][0][0][0][0]=0;
代码如下
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
struct lol{
	int c,m;
}s[11];
long long f[11][11][11][11][11];//防止溢出
int sum[110][1010];
int ans,t;

int main(){
	int i,j,k,n,a1,a2,a3,a4,a5,b1,b2,b3,b4,b5;
	cin>>ans;
	for (i=1; i<=ans; i++){
		cin>>n;
		for (j=1; j<=n; j++){
			cin>>k;
			cin>>sum[i][k];
		}
		cin>>sum[i][1001];
	}
	cin>>t;
	for (i=1; i<=t; i++){
		cin>>s[i].c>>s[i].m>>sum[++ans][1001];
		sum[ans][s[i].c]=1;
	}
	memset(f,1,sizeof(f));
	f[0][0][0][0][0]=0;
	for (i=1; i<=ans; i++){
		a1=sum[i][s[1].c];
		a2=sum[i][s[2].c];
		a3=sum[i][s[3].c];
		a4=sum[i][s[4].c];
		a5=sum[i][s[5].c];//赋初值
		for (b1=a1; b1<=s[1].m; b1++){
			for (b2=a2; b2<=s[2].m; b2++){
				for (b3=a3; b3<=s[3].m; b3++){
					for (b4=a4; b4<=s[4].m; b4++){
						for (b5=a5; b5<=s[5].m; b5++){
							f[b1][b2][b3][b4][b5]=min(f[b1][b2][b3][b4][b5],f[b1-a1][b2-a2][b3-a3][b4-a4][b5-a5]+sum[i][1001]);
						}
					}
				}
			}
		}
	}
	
	cout<<f[s[1].m][s[2].m][s[3].m][s[4].m][s[5].m];
	
	return 0;
}
```
码字不易，求过......
