这道题虽然题目描述中反复提到栈，但实际上和栈没啥关系。我们维护数组 $tp_i$ 表示第 $i$ 个栈的栈顶。为什么是栈顶？因为我们发现，某个栈能不能放集装箱，只和它的**栈顶**有关，所以不需要记录其他元素。那么我们这里可以发现，栈顶的元素序列从前往后一定是**单调递增**的。考虑反证法。如果整个序列不是单调递增，就一定存在一个位置 $i$，使得 $tp_{i-1}>tp_i$，那么这里 $tp_i$ 这个元素显然可以放到 $i-1$ 这个栈里，而且能让 $i$ 这个栈存下更多集装箱，比放到 $i$ 这个栈里**更优**。所以这个序列一定单调递增。至此，我们的做法显而易见，从左往右枚举读入的序列 $s$，建一个字符数组 $tp$ 记录栈顶元素，$cnt$ 记录当前有几个栈。

- 当 $s_i>tp_{cnt}$，说明当前最大的栈的栈顶也比 $s_i$ 要小，那么我们就必须新建一个栈。

- 其他情况，我们就从头开始枚举，判断当前栈顶是否不小于 $s_i$，如果是，那后面几个栈的栈顶一定比当前栈顶大，把 $s_i$ 放在这个位置显然最优。

最后输出 $cnt$ 即可。

下面是 AC 代码。
```cpp
#include<bits/stdc++.h>
using namespace std;

int main(){
	string s;
	int cnt, now = 0;
	char tp[1005];
	while(cin >> s && s[0] != 'e'){
		now++;
		cnt = 0;
		tp[++cnt] = s[0];
		int len = s.length();
		for(int i = 1;i < len;i++){
			if(s[i] > tp[cnt]){
				tp[++cnt] = s[i];
			}else{
				char minn = 'z' + 1;
				int id;
				for(int j = 1;j <= cnt;j++){
					if(tp[j] >= s[i]){
						tp[j] = s[i];
						break;
					}
				}
				tp[id] = tp[i];
			}
		}
		cout << "Case " << now << ": " << cnt << "\n";
	}
	return 0;
}
```
