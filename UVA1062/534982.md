 - ## 题意
   在码头建栈，栈可以放集装箱，但是要求建最少的栈，并且每个栈上的集装箱要按照字典序排放（就是小的字典序在前，大的在后）。
   注意，有多组数据，直到输入 `end` 结束。
 - ## 如何做
   已知要按照字典序排放，那么我们可以用一个 `char` 数组当作栈，一个一个把集装箱放入栈中，需注意当现在这个栈不能放下集装箱时就需要再开一个栈，为什么不要找遍整个栈呢？应为当现在的这个栈能把集装箱时，我们从第一个栈开始寻找能放下的栈，然后就使栈越前第一个越小的情况。
 - ## 策略
   ### 贪心
   为什么会对：因为按照字典序依次来船，符合船的字母的集装箱要放在最上方，下方的集装箱要比上方的大，并且栈的数量要小，并且我们把小的往前放，所以会出现这种情况。   
   ![](https://cdn.luogu.com.cn/upload/image_hosting/vdl5zxc9.png?x-oss-process=image/resize,m_lfit,h_170,w_225)  
   那么当 `A` 船来时就会在第一个栈取走所有的 `A` 集装箱,然后 `B` 船来在一二栈中取走所有的 `B` 集装箱，最后 `C` 船来再取走，结束。
## Code
	```cpp
	#include<bits/stdc++.h>
	using namespace std;
	char a[1010],b[26]; 
	int main(){
		for(int t=1;;t++){
			gets(a);  //因为用了gets所以C++98有问题 
			if(a[0]>'a') break; //因为end的字典序大于大写字母和a,所以可以用来判断结束 
			b[0]=a[0]; //第一个栈直接存 
			int s=1;  //s表示栈的个数 
			for(int i=1;a[i]>='A';i++){  //一个一个存进去 
				if(a[i]>b[s-1]){  //判断是否能不用新建栈就能存放 
					b[s++]=a[i]; //因为s从1开始，而b数组从0开始 
				}
				else{
					for(int j=0;j<s;j++){ //如果能放就找最好的栈放 
						if(a[i]<=b[j]){
							b[j]=a[i];
							break;
						}
					}
				}
			}
			cout<<"Case "<<t<<": "<<s<<endl;  //正常输出 
		}
		return 0;
	}
	//祝贺你看完了代码，加油！ 
	```
