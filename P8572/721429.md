# 前言

不得不说，这道题作为备用还蛮好的，给我这种蒟蒻有了上大分的机会，难度也非常合适，好评好评！

# 思路

一种暴力思想。

题目中有这样一句话：求出所有序列中区间 $[l,r]$ 的和的最大值。

看到区间，你想到了什么？没错，就是前缀和！

前缀和是什么呢？从数组中第 $1$ 个位置加到第 $i$ 个位置的元素之和。定义一个数组 $s$，$s_i$ 代表 $a_1+a_2+...+a_i$，等同于 $s_{i-1}+a_i$ ，那么此时 $s_i$ 就代表 $a$ 数组前 $i$ 个位置元素之和。

把输入的 $k$ 个序列看成一个 $k \times n$ 的二维数组，此时就可以进行前缀和操作了。一维数组前缀和的递推公式是 $s_i = s_{i-1}+a_i$，二位公式就是在一维的基础上，再加一个纵坐标 $j$，即 $s_{i,j} = s_{i,j-1}+a_{i,j}$，有了前缀和，是 $[1,n]$ 的元素之和，那么 $[l,r]$ 的元素之和怎么求呢？是 $s_r-s_{l-1}$，大家可以自己推导一下。

现在就可以模拟求出答案了。

```cpp
for(i=1;i<=k;i++)
{
	sum = s[i][r]-s[i][l-1];
	MAX = max(MAX,s);
}
```

很显然的，一道绿题不可能就这样水过去了，我们需要优化。

可以按照记忆化搜索的思考方式，我们为什么不能用一个 $b$ 数组来存放上述代码中的最大值呢？这样当 $l$ 和 $r$ 重复时，直接调用 $b$ 数组中的值，就不用再从头循环了，剩下了大笔的时间，虽然空间会消耗许多吧（但是良心出题人没有卡！），不过可以通过此题就满足我们的需求了。

本人的语文非常差，可能只是说了一下大体的思路，没有说明白，下面就给大家放代码，在代码中讲解会容易理解的多。

# 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;//不开 long long 见祖宗！ 
ll a[5001][5001];
ll b[5001][5001];
int main()
{
	int n,k,q,l,r,i,j,x;
	ll ma;
	cin>>n>>k>>q;
	for(i=1;i<=k;i++)
	{
		for(j=1;j<=n;j++)
		{
			cin>>x;
			a[i][j] = a[i][j-1]+x;//先处理前缀和 
		}
	}
	while(q--)
	{
		cin>>l>>r;
		if(b[l][r])//记忆化来咯，当 l 和 r 出现过了，直接输出里面的值，剩下了大笔的时间。 
		{
			cout<<b[l][r]<<endl;
			continue;
		}
		MAX = INT_MIN;//找出最大值。 
		for(i=1;i<=k;i++)
		{
			ll s = a[i][r]-a[i][l-1];//每一个序列中 l 到 r 元素之和。 
			MAX = max(MAX,s);//找出最大的。 
		}
		b[l][r] = ma;//储存 
		cout<<MAX<<endl;//输出 
	}
    return 0;
}
}
```
