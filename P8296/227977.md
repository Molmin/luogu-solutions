题目中：
```
使得水平与垂直均出现这几个单词
```
意思为六个单词在这个方格中都出现过。

因为数据小，很快就能想到枚举，既然要保证单词全部出现，那就先枚举 $3$ 个单词放入 $3$ 行或 $3$ 列中，再判断其它 $3$ 个单词是否在 $3$ 行或 $3$ 列中全出现（如果枚举行，就判断列，反之亦然）。题目保证输入单词按字典序排好，那么只要按题目顺序枚举，所得的第一个合法方案就是字典序最小的方案。

具体讲一下代码实现：首先开两个二维数组 ```a``` 和 ```s```，```a``` 为输入数据，```s``` 为生成的方案。枚举很简单，记住别枚举重复就好了，我选择枚举行。对于判断 ```s``` 是否合法，需要另开一个 ```bool``` 型数组 ```b```，标记单词是否出现过，初始值全为 $0$，枚举的 $3$ 个单词直接标记为 $1$，然后判断三个列是否包含剩下的 $3$ 个单词，可以开三重 ```for``` 循环，第一层是枚举 ```s``` 的列，第二层枚举单词，如果这个单词没被标记过，进入第三层，看这一列是否为这个单词，如果是，那么把这个单词标为 $1$，最后看是不是所有单词都被标为 $1$ 就好了，具体看代码。

### AC code：
```cpp
#include<bits/stdc++.h>
using namespace std;
char a[7][4],s[4][4];
bool check(int x,int y,int z){
	bool b[7]={};
	b[x]=1;
	b[y]=1;
	b[z]=1;
	for(int i=1;i<=3;i++){
		for(int j=1;j<=6;j++){
			if(b[j]){
				continue;
			}
			bool flag2=0; 
			for(int k=1;k<=3;k++){ 
				if(s[k][i]!=a[j][k]){
					flag2=1;
					break;
				}
			}
			if(!flag2){
				b[j]=1;
				break;
			}
		}
	}
	if(b[1] && b[2] && b[3] && b[4] && b[5] && b[6]){
		return 1;
	}
	return 0;
}
int main(){
	for(int i=1;i<=6;i++){
		for(int j=1;j<=3;j++){
			cin>>a[i][j];
		}
	}
	for(int i=1;i<=6;i++){
		for(int j=1;j<=6;j++){
			for(int k=1;k<=6;k++){
				if(i!=j && j!=k && i!=k){
					for(int l=1;l<=3;l++){
						s[1][l]=a[i][l];
						s[2][l]=a[j][l];
						s[3][l]=a[k][l];
					}
					if(check(i,j,k)){
						for(int m=1;m<=3;m++){
							cout<<s[m][1]<<s[m][2]<<s[m][3]<<endl;
						}
						return 0;
					}
				}
			}
		}
	}
	cout<<0;
}

```
