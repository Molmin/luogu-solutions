看到这道题，首先会想到暴搜。考虑到会有高精度对单精度取模，运用同余定理，有以下代码：
```cpp
for(int j=0;j<=i;j++)
	r=(r*10+n[j])%a;
```
其中$r$存储余数，$n$数组存储高精度数，$i$为高精度数位数，$a$为单精度数。

完整代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
char S[100001];
int a,b,r,n[100000]={1};
int main()
{
	cin>>a>>b>>S;
	for(int i=0;i<b;i++)//逐位处理
	{
		for(;n[i]<10;n[i]++)//从小到大枚举，n[0]即最高位从1开始，其余位从0开始
		{
			r=0;
			for(int j=0;j<=i;j++)//高精度对单精度取模
				r=(r*10+n[j])%a;
			if(bool(S[i]-'0')^bool(r)==true)//即：S[i]=0时，若余数非0则满足条件；S[i]=1时，若余数为0则满足条件
				break;
		}
		if(n[i]==10)//如果0~9（或1~9）都不满足条件则输出-1，退出程序
		{
			printf("-1");
			return 0;
		}
	}
	for(int i=0;i<b;i++)
		printf("%d",n[i]);
	return 0;
}
```

很明显，时间复杂度为$O(n^2)$,T了Subtask5。

怎么办呢？

~~然后我就枚举1~10，枚举了一个小时发现#16是a=7~~

我们想到：可以用$r$存储余数，每处理完一位令$r=(r*10+n[i])\%a$（$n[i]$为当前处理的那一位）即可。

还能发现，当且仅当$a=10$且$S[0]='1'$时不存在所求数，特判一下即可。

此外，由于最高位不为零，要对$n[0]$进行预处理（具体看代码）。

上代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
char S[100001];
int a,b,r,n[100000];
int main()
{
	cin>>a>>b>>S;
	if(a==10 && S[0]=='1')//特判-1的情况
	{
		cout<<-1;
		return 0;
	}
	n[0]=(S[0]=='1')?a:1;//预处理n[0]，否则S[0]='1'时，n[0]会等于零
	r=(S[0]=='1')?0:1;
	for(int i=1;i<b;i++)//逐位处理
	{
		if(S[i]=='0')//S[i]='0'时，如果前面的数位能被整除则此位为1，不能被整除则为0
			n[i]=bool(r*10%a)?0:1;
		else//否则计算最小的满足条件的值
			n[i]=(a-r*10%a)%a;
		r=(r*10+n[i])%a;//处理余数
	}
	for(int i=0;i<b;i++)
		printf("%d",n[i]);
	return 0;
}
```