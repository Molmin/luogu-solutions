先把物品从大到小排序，假设第 $i$ 个物品有 $cnt_i$ 个洞能进去，显然对于 $i<j$ ，第 $i$ 个物品能进的洞第 $j$ 个一定可以，所以直接按这个顺序依次给物品选洞

那么先不考虑修改操作，每个物品能放进去当且仅当 $cnt_i\ge i$ 。

最初的 $cnt_i$ 是好求的，遍历一下树，每个洞的贡献都是一段后缀，相当于区间加，差分或者数据结构维护即可。

考虑找到最靠前的不合法的物品，即最小的 $i$ 满足 $cnt_i<i$ ，那么它满足 $s_i$ 最大。

那么问题转化成选一个洞，把这个洞变成 $s_i$ 。原因是如果变成其他不合法物品的 $s_j$ ，那无论怎么样也无法满足第 $i$ 个物品。

一种想法是暴力枚举每个 $<s_i$ 的物品，然后它只会影响它的子树，那么扫一遍子树看看子树对 $cnt_i$ 的影响。显然这是一个区间加的效果，我们在线段树上存 $c_i-i$ 的最小值，然后扫完后判断一小最小值是否 $\ge 0$ 即可。

这样的复杂度看似是 $O(n^2\log k)$ 的，但是对于一个物品满足 $<s_i$ ，那么它的子树里的点就不用再枚举了，因为这个物品不去改它，子树再怎么改也没用。

这样每个点只会被扫一次去计算对线段树的影响，所以总的复杂度为 $O(n\log k)$ 。

https://codeforces.ml/contest/533/submission/156921476