非常恶心的 dp。其他题解的数组定义比较？？？~~我来发一篇正常一点的。~~

设$U=\{1,2,...,n\},S_i=\{x|x\ \text{在}i\text{的子树内}\}$

#### 注意，无特殊声明子集不考虑空集。

首先，$k$ 这么小，排除插值的可能，我们考虑第二类斯特林数

$$\sum_{S\subseteq U}f(S)^k=\sum_{S\subseteq U}\sum_{i=0}^ki!S_k^iC_{f(S)}^i$$

$$=\sum_{i=0}^ki!S_k^i\sum_{S\subseteq U}C_{f(S)}^i$$

发现不会算后面的东西了怎么办？不会算就设啊！

考虑 dp ，设 $f_{i,j}$ 表示$S_i$所有子集 构成的连通树中选择 $j$ 条边的方案 的和，发现 $f_{1,j}$ 就是要求的东西。如果是一个背包转移的话可以做到 $O(nk)$，

事实上这个东西没法转移。（我搞了$1$个小时才明白！）为什么呢？

首先我们转移的时候肯定计算子树之间的子集合并的结果。这样会出现很多特殊情况，比如

![](https://cdn.luogu.com.cn/upload/image_hosting/jr3cocke.png)

这种情况（以红点为根，再选择两个蓝点）在计算的时候蓝点到红点的边选择情况就没办法考虑到了。这种关键的“相同点”信息无法设计到这个状态里。

那怎么办？换状态！

我们怎么设计新的状态？现在的问题就是在合并子树信息的时候没法得到一些节点到当前根路径上的边选择情况。考虑下面这种情况：

![](https://cdn.luogu.com.cn/upload/image_hosting/183clzls.png)

选择两个红点，不选灰点，这样也有更多的边供选择。

发现在灰点中有至少两棵子树有点在集合内（或根节点在子集中）的情况下，子树内最浅的点到根节点的边都可以选择。而我们要考虑的就是合并两棵子树子集的贡献。

所以我们考虑这样一个 dp ：

$f_{i,j}$ 表示 $S_i$ 的所有子集与 $fa_i$ 构成的连通块中选择$j$条边的方案 的和。

怎么想到的？~~自己 yy + 题解~~

因为合并一定是拿 $i$ 的儿子合并，合并两个块的时候自然会是这种情况。既然一定要合并为什么不直接设出来呢？$\color{white}\text{分析性质}$

我们发现，合并的时候上图所示的情况不会有问题了！因为我们强制选择了 $fa_i$ ，这样构成的连通块在合并的时候正好，达到了要求。最终答案不再是 $f_{1,j}$ 了，而需要一边合并一边转移...

直接用背包转移即可。注意这时候得到的 f 数组不包括父亲，还不是设出来的 $f$ 数组，再用一次组合数转移即可。

看起来和别的题解不一样，事实上他们写的就是这个东西（网上好多题解连自己写的啥都不清楚吧）

核心 dp 部分：（$f$是答案数组）

```
void dfs(int u,int faa){
	sz[u]=dp[u][0]=1;
	for (int i=head[u];i;i=g[i].nxt){
		int v=g[i].to;
		if (v==faa) continue;
		dfs(v,u);
		for (int j=min(K,sz[u]);j>=0;j--){
			for (int k=min(K-j,sz[v]);k>=0;k--){
				ll tmp=1ll*dp[u][j]*dp[v][k]%ljc;
				add(dp[u][j+k],tmp),add(f[j+k],tmp);
			}
		}
		for (int j=0;j<=min(K,sz[v]);j++) add(dp[u][j],dp[v][j]);
		sz[u]+=sz[v];
	}
	for (int i=min(K,sz[u]);i>=0;i--) add(dp[u][i+1],dp[u][i]);//这时候dp数组没有考虑父亲，转移变成真实的dp数组
}

```

我感觉这种思路没什么细节啊（

混了一个最短解就跑