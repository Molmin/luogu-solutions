## CF1721B 题解

### 题意简述

$t$ 组数据。

你需要从 $(1,1)$ 走到 $(n,m)$，途中与 $(sx,sy)$ 相离 $d$ 个单位长度的格子不能走。如果能走到 $(n,m)$，输出最少步数；如果不能走到 $(n,m)$，输出 $-1$。

注：矩阵上相离单位的计算公式为： $|x_1-x_2|+|y_1-y_2|$，其中两个点分别为 $(x_1,y_1)$ 和 $(x_2,y_2)$。

### 解题过程

乍一看是一个宽度优先搜索问题，跑一边整个图即可。然而分析一下时间复杂度：$O(t\times n\times m)$，会炸。

考虑挖掘题目特殊性质，发现只有五种情况会输出 $-1$，否则输出图上最短路，即 $n+m-2$。

五种情况分别为：

1. 不能走的区域覆盖 $(n,m)$。

2. 不能走的区域覆盖 $(1,1)$。

3. 不能走的区域覆盖完整的，且在第 $n$ 行前的某一行。

4. 不能走的区域覆盖完整的，且在第 $m$ 列前的某一列。

5. 不能走的区域覆盖完整地图。

按照以上步骤判断即可。

### 完整代码

```
#include<bits/stdc++.h>
using namespace std;
int t;
int cal(int x1,int y1,int x2,int y2)
{
	return abs(x1-x2)+abs(y1-y2);
}
int main()
{
	scanf("%d",&t);
	while(t--)
	{
		int n,m,sx,sy,d;
		scanf("%d%d%d%d%d",&n,&m,&sx,&sy,&d);
		if
		(
			cal(sx,sy,n,m)<=d ||
			(sx-d<=1 && sx+d>=n) ||
			(sy-d<=1 && sy+d>=m) ||
			(sx-d<=1 && sy-d<=1) ||
			(sx+d>=n && sy+d>=m)
		)
			printf("-1\n");
		else printf("%d\n",n+m-2);
	}
	return 0;
}
```
