#### 题目: [P1865 A%B problem](https://www.luogu.org/problemnew/show/P1865)

~~我翻了一遍题解貌似没有和我用一样的方法的..~~

~~在看到**题目描述**之前,我还真没看懂这道题的意思...~~ 没想到是查询区间素数的个数.

然后看到了$l,$ $ r$的范围...开了个$longlong$.. ~~恢复了一下心态~~

没想到后面查询的范围只和$m$有关。 ~~我开心的拍起了肚皮~~


## 正文开始

### **理解题意:**

看完题目会发现,其实小于了$1$的 $l$会直接判出界,大于了$m$的 $r$也会直接判定出界

因此本题的思路则转化为:**求区间$[1, m]$中任意一段区间的素数个数**

### **思路:**

首先想到的是在线筛法 (输入每一组数据都重新数一遍) 

结果->[戳这里](https://www.luogu.org/recordnew/show/15821012)。 $T$了$4$个嗷!!!

然后突然想到可以把查询拎出来啊 (就是离线筛啦)...判断$[1, m]$的素数，用$flag[i]$数组打一个标记，$0$为初始状态，$1$则是代表有约数的整数 (即合数)，打一个~~烙印~~ 标记为合数。

//$\color{#FF5151}\text{关于i }\mathrm{}$ $i$代表区间$[1, m]$中的每一个数,程序内只需要查询$i$是否为合数,是则打个标记 $(flag[i] = 1)$

每输入一个需要查询的区间$[l, r]$,就数一数其中$flag[i]=0$的个数即可.

### **优化:**

一个很小很小很小的优化:大于 $2$ 的偶数可以直接在筛之前就全部打标记，这样只要查询奇数是否为合数。(就只需要判断一半的整数了 $very$ $nice$)

**解释:**所有大于 $2$的偶数都2整除了啊. ~~这有什么好解释的$qwq$~~

**$bug$点:**但是$2$属于质数啊.所以加一个判断。

$i$从$2$开始,走完一遍之后$i--;$ $i+=2$ 然后 $i$ 就成功转变成了$3$ $5$ $7$ ……

~~我不管我就不让ans = 1;~~

### **理解:**

在这里解释一下为什么求合数的约数是要开根号的.

每个数都能拆成 $:$ $N=a*b$ ($N$为正整数)的形式,不同的是 $a$ $b$ 的值.

除开约数是本身和$1$来说，每个合数的最大约数就是本身开根号。

否则是一个数大于$\sqrt{N}$一个数小于$\sqrt{N}$

$N=\sqrt{N}*\sqrt{N}$ $←$ 很明显只有这种情况下$N$的约数是最大的.可自行举例验证

因此$j$只要 $<=$ $\sqrt{i}$ 也就是 $j*j<=i$ (两边平方)

~~这样可以省去一个头文件省去一个sqrt了~~
 

### **代码实现:**

//吸个氧就$AC$啦~~ ~~(不吸氧会[$T$一个点](https://www.luogu.org/recordnew/show/15890333)..我也不知道咋办qwq~~
```cpp
#include <iostream>
#include <cstdio>
using namespace std;

//定义变量, 次数n, 范围m,   l, r表示区间.  flag数组用来判断是不是素数
int n, m, ans, flag[1000000+6];
long long l, r;

//简单的加法. 
int pd(int l ,int r)
{
	ans = 0; //初始化计数
	for (int i = l; i <= r; i++) //查询区间素数个数
		if (flag[i] == 0) ans++; //如果没有打标记的 则为素数,计数++
	return ans;//把计数丢回去输出
}

int main()
{
	scanf ("%d %d", &n, &m);
	for (int i = 4; i <= m; i+=2)//把 > 2的偶数打标记
		flag[i]=1;
	for (int i = 2; i <= m; i+=2)//i相当于要求的素数 
	{
		for (int j = 2; j * j <= i; j++)//j是合数的约数 
			if (flag[i] != 1)
				if (i % j == 0)
				{
					flag[i] = 1;//如果是合数,定为1
					break;//只要找到它有一个非本身和1的约数,就可以直接判断下一个数i了~~
				}
		if(i == 2) i--; //让循环从奇数3开始
	}
	for (int i = 1; i <= n; i++)
	{
		scanf ("%ll %ll", &l, &r);//cin >> l >> r;
		//越界的情况 
		if(r > m || l < 1) {printf ("Crossing the line\n"); continue;}
		if (r < 2) {printf("0\n"); continue;}//这个也是越界 
		else if (l < 2) l = 2;//其实貌似这步可以不用? 
		printf ("%d\n", pd(l, r));//输出 
	}
	return 0;
}
//完结撒花~~ 
```

求过阿qwq.

#### //有不对之处还望$dalao$们指出.谢谢~