假设左端点是最小值，右端点是最大值，然后反转再做一遍。

直观上感觉不能在线段树上维护答案，所以尝试把询问离线扫描线。朴素地，令指针 $u$ 从左往右扫，同时对于每个 $i\leq u$ 维护 $f_i$ 表示以 $i$ 为左端点，右端点不超过 $u$ 的最大长度，则 $u=R$ 时回答询问 $[L,R]$ 的答案为 $\max_{i=L}^R\{f_i\}$。考虑 $u$ 向右移动一格时对 $f$ 的影响，预处理出 $l_i$ 表示 $i$ 左边第一个比 $a_i$ 大的位置，$r_i$ 表示 $i$ 右边第一个比 $a_i$ 小的位置，则 $u$ 能影响到 $f_i$ 当且仅当 $l_u\leq i$ 且 $r_i\ge u$。如果当前的 $u>r_i$，则之后的 $u$ 一定不能更新 $f_i$，相当于维护了一个单调栈，只有在栈中的元素 $i$ 的 $f_i$ 才可能更新，被弹出之后就不可能再更新了。对于 $u$ 的加入，找到栈顶的若干元素满足其大于 $l_u$，则这些 $f_i$ 都应该被更新为以 $u$ 为右端点的，不妨分析一下，栈中元素当前对应的右端点是分段的，且每个 $u$ 会添加至多一段，则暴力向前一段一段更新的次数均摊也是 $O(n)$。

于是思路就清晰了：预处理出 $l_i$。扫描线过程中维护一个不减的单调栈 $s_1$，其中的元素 $i$ 表示 $[i,u]$ 还没有出现 $<a_i$ 的，$f_i$ 还有可能更新，用一棵线段树 $T_1$ 来维护这些 $i$ 的 dp 值。$u$ 移动时更新栈顶所有 $>l_u$ 的 $i$ 的 dp 值，同段的更新是区间加相同的数。当一个 $i$ 从 $s_1$ 被弹出时，其 $f_i$ 不应该接受之后的更新，在 $T_1$ 上将 $f_i$ 设为 $-\inf$，并将其挪到另一棵线段树 $T_2$ 上。对于一个询问 $[L,R]$，在 $u=R$ 时查询 $T_1,T_2$ 上 $[L,R]$ 内的最大值。对段的维护另开一个栈 $s_2$ 即可。

复杂度 $O(n\log n)$，常数略大。