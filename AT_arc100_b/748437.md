## 分析

首先先放一个朴素的 $O(n^3)$ 的暴力，思路是用 ```i,j,k``` 把序列分成 $4$ 份（还是要用到基本的前缀和）。

```cpp
int minn=9e18;
for(int i=1;i<n;i++)
	for(int j=i+1;j<n;j++)
		for(int k=j+1;k<n;k++){
			int a1=sum[i]-sum[0];
			int b1=sum[j]-sum[i];
			int c1=sum[k]-sum[j];
			int d1=sum[n]-sum[k];
			int maxx=max(max(a1,b1),max(c1,d1));
			int minx=min(min(a1,b1),min(c1,d1));
			minn=min(minn,(maxx-minx));
		}
cout<<minn;

```

显然会 T 的很惨，考虑优化。


- 观察发现，当我们确定中间的 ```j``` 时， ```i,k``` 就能够确定最优解。

- 注意到题中 $n$ 中的范围，很容易想到二分查找。

- 所以，分别找前一半平分的位置，和后一半平分的位置即可。

- 因为大概率数据不能正好平分，所以要分为前大于后，后大于前两种，排列组合可知，共 $4$ 种。

这样我们的时间复杂度就降低到 $O(n \log n)$ 了，可以通过本题。

此外，当 ```j``` 递增时，```i,k``` 也是单调递增的，所以可以用类似于双指针的方法优化到 $O(n)$ 同样可以通过，其他大佬讲的很多了，不再详细说了。

~~AC 代码就先不放了。~~