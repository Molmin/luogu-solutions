本文同步发布于我的[博客园](https://www.cnblogs.com/5ab-juruo)。

题意：给定一个数 $p$，$p$ 由若干次拼接操作构成，每次拼接操作要求前面的数要大于等于后面的数，求原先最多有多少数，这些数都不允许存在前导零。

这个拼接时的大小要求十分让人讨厌，我们可以令拼接操作从左往右进行，这样左边的数尽可能大，而右边尽可能小。

同时，数是不允许存在前导零的，所以我们每次遍历，都往后一直到没有后继零为止，这个数与前面已经拼接完成的数进行大小比较。有两种情况：

1. 后面的数比前面小或相等，就拼接起来；
2. 后面的数比前面的数大：如 `23`，此时我们要将前面的数和后面的数合为一个整体，注意到这时这个数就不是拼接而来的。比如 `19992000` 就是一个数，不是由 `1999` 和 `2000` 构成的。

这种做法显然正确，证明如下：

设当前这一段为 $x$，前面已经完成的拼接段为 $p_1$，后面未合并的 $p_2$。

$p_1$ 已经无法与 $x$ 拼接，如果 $x$ 不和 $p_1$ 合成一个整体，则：

后面 $x$ 一定与 $p_2$ 拼接，否则一定没有合成整体优，但这样产生一个新数 $x^\prime>x$，更加无法和 $p_1$ 拼接。也没有直接合成优。

这样就可以了。

注意到有一个小 trick，在判整数大小时，不用傻乎乎地去写高精度，只需要判长度和首位即可，读者自证不难。

Code：

```cpp
#include <cstdio>
using namespace std;

const int max_n = 100000;
char a[max_n+1];

int main()
{
	int n, lp = 114514, ptr, cnt = 0; // 初始需要一个长度无限大的数

	scanf("%s", a);
	for (n = 0; a[n]; )
	{
		ptr = n + 1;
		while (a[ptr] && a[ptr] == '0') // 去除后继零
			ptr++;
		
		if (lp > ptr - lp || (lp == ptr - lp && a[0] >= a[lp]))
		{
			n = lp = ptr; // 可以拼接
			cnt++; // 记上数量
		}
		else // 否则直接合成
		{
			n = lp = ptr;
			cnt = 1; // 只能算一个
		}
	}

	printf("%d\n", cnt);

	return 0;
}
```