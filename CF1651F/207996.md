## 题目大意

- 数轴上有 $n$ 个塔，第 $i$ 个塔能量上限 $c_i$，每秒回复 $r_i$ 点能量，初始所有塔能量全是满的。
- 同时有 $m$ 个怪，第 $i$ 个会在 $t_i$ 秒刷出，血量 $h_i$。第 $i$ 个怪会在第 $t_i+j-1$ 秒被第 $j$ 个塔攻击。攻击时，塔的能量和怪的血量同时减去两者中的较小值。
- 输出所有怪全都走过一遍后所有怪血量之和。

## 简要做法

- 我们发现这个 $a_i \gets \min (a_i + T b_i,c_i)$ 的形式和 CF453E 有点像啊？

考虑对塔分块。我们发现一个怪经过一块内的塔只有两种情况：

1. 块内所有塔把怪打一遍后怪还有血，这时相当于块内塔的能量被清零了。
2. 怪被其中一个塔打成血量为零，此时这个怪就不会对后面的块造成贡献了。处理后面的块的时候直接把这个怪 continue 掉即可。

可以发现，由于一个怪最多只会被打成空血一次，所以第二种情况最多只会出现 $O(m)$ 次。

考虑对于每一块维护一个推平 tag 和这个块上次被操作的时间戳。预处理出每个块被清零后 $k$ 秒来了一个怪时能对怪打出多少伤害。对于每个怪依次处理每个块：

- 若这个怪能被块内的塔打成空血，直接暴力做，然后撤销块内的推平标记。
- 否则，若块内没有推平标记，同样暴力做，然后打上一个推平标记。
- 否则，直接把怪的血量减去预处理出来的值，推平标记保持不变。

预处理的方法可以参考我的[这篇题解](/blog/yzy1/solution-cf453e)。

但是我们发现，这道题的 $n \le 2\times 10^5$，而我们的空间复杂度是 $O(n\sqrt n)$，我们根本开不下这么大的数组！

考虑把所有询问离线，然后一块一块的做，每块统一处理所有的怪，这样的话就只需要保存当前的块的预处理值和标记即可。空间复杂度下降为 $O(n)$。

至此，我们以 $O(n\sqrt n)$ 的时间复杂度，$O(n)$ 的空间复杂度解决了此题。

[代码参考](https://codeforces.com/contest/1651/submission/149206879)