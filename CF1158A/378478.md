### 题意
有 $n$ 个男孩，$m$ 个女孩，每个男孩给每个女孩一堆糖果。$b$ 数组表示每个男孩给出的最少糖果数，$g$ 数组表示每个女孩子收到的最大糖果数。求所有男孩给出的最小糖果总数。

### 题解

先对 $b$ 数组和 $g$ 数组从小到大排序。

#### 第一种情况：
如果给出最多的男孩比收到最少的女孩的还多，即 $b[n-1] >g[0]$，则不成立，直接输出 -1。

#### 第二种情况：
一共有 $n \times m$ 堆糖果，显然 $g$ 数组的糖果数只能出现一次 $($ 女孩收到的最大堆糖果只有一次，其他都是很小堆，能多小就多小 $)$，直接让最后一个男孩发每个女孩的最大堆糖果。

（1）当如果 $b[n-1] < g[0]$ 时：

比如：

```
3 2 

1 2 8

9 100
```
第三个男孩需要给出一堆 8 个的，再去满足所有 $g$ 数组，但是加上本来的一堆 8 个，第三个男孩一共给出 2 堆，取一堆 8 个的，只能再分配一个 $g$ 数组元素，则剩下一个 $g$ 数组元素需要其他男孩分配,就让第二个男孩来提供。最终是，第一个男孩给了 1，1 两堆，第二个男孩给了 2，9 两堆，第三个男孩给了 8，100 两堆。

所以有 $1+1+2+9+8+100=121$。

又如果 $g[0]$ 让第一个男孩给出，则第一个男孩给了 1，9 两堆，第二个男孩给了 2，2 两堆，第三个男孩给了 8，100 两堆。

所以有 $1+9+2+2+8+100=122$。

用贪心策略不难推出是倒数第二个男孩满足第一个女孩的最大堆。

（2）当如果 $b[n-1]=g[0]$ 时：

比如：

```
3 2 

1 2 8

8 100
```
第三个男孩在给出一堆 8 个的情况下 顺便满足了第一个女孩，那么他可以满足所有的女孩的最大堆。则第一个男孩给了 1 , 1 两堆，第二个男孩给了 2，2 两堆，第三个男孩给了 8，100 两堆。

所以有 $1+1+2+2+8+100=114$。

### 代码

```cpp
#include<bits/stdc++.h>
#define inf 0x3f3f3f3f
#define ll long long
using namespace std;
ll n,m;
ll b[100086];
ll g[100086];
int main(){
    while(scanf("%lld %lld",&n,&m)!=EOF){
        for(ll i=0;i<n;i++) scanf("%lld",&b[i]);
        for(ll i=0;i<m;i++) scanf("%lld",&g[i]);
        sort(b,b+n);
        sort(g,g+m);
        if(b[n-1]>g[0]) printf("-1\n");
        else{
            ll sum=0;
            if(b[n-1]==g[0]){
                for(ll i=0;i<n-1;i++) sum+=b[i]*m;
                for(ll i=0;i<m;i++) sum+=g[i];
            }
            else{
                for(ll i=0;i<n-1;i++) sum+=b[i]*m;
                sum=sum-b[n-2]+g[0]+b[n-1];
                for(ll i=1;i<m;i++) sum+=g[i];
            }
            printf("%lld\n",sum);
        }
    }
}
```
