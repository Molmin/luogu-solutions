**算法一**

暴力全图计算 $f$，期望得分 $20$ 分。

**算法二**

为了方便讨论，令 $v_i(1\leq i\leq n)=f_{i,0}$，即输入的数值。

先只考虑单个询问：在第 $a$ 天时 $f_1$ 是多少。

显然可以知道：最后的 $f_1$ 是若干个 $v$ 异或若干次的结果。那么是哪些数呢？

对于每个城市 $i$，我们假想数字 $v_i$ 一开始站在 $i$ 上，每天向相邻的城市走一步。那么每次它走到 $1$ 时，就向 $f_1$ 贡献一次。换言之，**$v_i$ 对 $f_1$ 的贡献次数等于 $i$ 到 $1$ 的长度为 $a$ 的路径的条数。**而异或两次等于没有异或，我们只需要求出这个路径条数对 $2$ 取余的结果即可。

观察到 $a_i$ 很大而 $n$ 很小，考虑矩阵乘法。这个想法事实上是相当自然的。具体来说，用矩阵快速幂算出路径条数的奇偶性，把奇数的位置异或起来即可。

令 $W=\max \{a_i\}$，时间复杂度 $O(qn^3\log W)$。期望得分 $60$ 分。

**算法三**

（接下来的内容较为玄学，可能并非正解，请谨慎使用。）

观察到上面算法的瓶颈是：单次询问要计算 $O(\log n)$ 次矩阵乘法。

考虑通过预处理来进一步优化。观察到 $\sqrt{W}$ 在一个可接受的范围内，考虑根号分治。

我们预处理出所有 $\sqrt{W}$ 内和 $\sqrt{W}$ 的倍数的矩阵。两种矩阵都只有 $\sqrt{W}$ 个，总时间复杂度是 $O(n^3\sqrt W)$ 的。接下来每次询问的时候拆成两个矩阵相乘即可。

然而发现上面并不太平衡，预处理复杂度过高。考虑更高次数的根号分治：选定一个正整数 $k\geq 2$，令 $p=\sqrt[k]{W}$，对于每个 $i\in [0,k]$，预处理出 $0\times p^i,1\times p^i,...,(p-1)\times p^i$ 的矩阵。这样一共处理了 $O(k\sqrt[k]{W})$ 个矩阵，而一次询问只需要用到 $k$ 个矩阵相乘。

另外可以用 bitset 优化。总时间复杂度为 $O(\dfrac{kqn^3+k\sqrt[k]{W}n^3}{w})$，总空间复杂度为 $O(\dfrac{k\sqrt[k]Wn^2}{w})$，取 $k=4,5$ 即可通过此题。