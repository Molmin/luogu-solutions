### 题目大意：

有一个画了 $n$ 个山峰的图片，
由不闭合折线表示，
共有 $2n$ 个段。
对于任何偶数 $i$ （$2≤i≤2n$），
以下条件成立：$y_i-1 <y_i$ 和$ y_i> y_i + 1$
（ $y_i$ 表示第 $i$ 个点的y坐标）
Little Bolek 对图片做了恶作剧，
他选择了其中的 $k$ 个山峰，
并将这 $k$ 个山峰的高度增加 $1$ ，
即将这 $k$ 个点的y坐标加 $1$ 。
给你恶作剧后的图片
（输入这 $2n+1$ 个点的y坐标），
请你还原。
若有多种可能，
输出任意一种。

---------------

从头到尾遍历每一个编号位偶数的点，
若它的高度减1（即若这个点还原后的高度）
比它上一个点的高度高，
也比它下一个点的高度高，
就还原这个点，
即使它的高度减1。

判断高度是因为，
如果当前点高度减1后，
不比它上一个点的高度高，
或不比它下一个点的高度高，
就不满足 $y_i-1 <y_i$ 和$ y_i> y_i + 1$ 。

最后：数组需要开到 $2n+1$ 

------------

### 代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,k,a[202],ans[202];
int main()
{
	scanf("%d%d",&n,&k);
	for(int i=1;i<=n*2+1;i++)
	{
		scanf("%d",a+i);
	}
	for(int i=1;i<=n*2+1;i++)
	{
		if(i%2==0&&a[i-1]<(a[i]-1)&&a[i+1]<(a[i]-1)&&k>0)//判断高度条件 
		{
			k--;//用k来计数 
			ans[i]=a[i]-1;//还原 
		}
		else
		{
			ans[i]=a[i];
		}
	}
	for(int i=1;i<=n*2;i++)
	{
		printf("%d ",ans[i]);
	}
	printf("%d\n",ans[n*2+1]);
	return 0;
}
```
~~别试样例了，输出不一样（有Special Judge）~~