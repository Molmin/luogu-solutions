[题目链接](https://www.luogu.com.cn/problem/SP2138)

前言：想起自己许久之前看到过这个题，可惜并不会做，就一直搁置了。最近回看了一下，突然就有想法了。这题也没用到什么高深的知识，就很神奇。

****
题解：

这题有一个关键性质：计算过程中所有用到的 $f(n)$，$n$ 都可以表示为 $x-y\pi$ 的形式（其中 $x,y$ 均为自然数）。根据这个性质，很容易得到一个 $\Theta(n^2)$ 复杂度（不考虑高精度计算的用时）的算法：

$$g_{i,j}=\begin{cases} g_{i-1,j}+g_{i,j+1} \ ,\ (i-j\pi \geq 4 ) \\ 1 \ , \ \text{otherwise} \end{cases}$$
递归计算 $g_{n,0}$ 即可。

想要优化复杂度，我们考虑模拟一下递归的过程：现在有一个点在 $(n,0)$ 位置，每过一轮都会分裂为两个点，分别在它的左侧和上侧一个单位长度。如果一个点落在了 $x-y\pi <4$ 的区域就会立刻消失，我们统计的答案就是最终消失了多少个点。

再来把这个迭代的过程抽象一点：有一个多项式 $f(x)$，初始为 $f(x)=1$。每次乘上 $(1+x)$，再根据一些条件判断，来删掉最高次的一些项，并统计被删掉的项之和。

由于 $f(x)$ 的度数变化必然是单峰的，当在第 $n$ 轮迭代后的 $x^m$ 项被删掉时：

- 若其为 $f(x)$ 不是最高次项，则其等于 $\binom nm$；
- 否则其为 $\binom{n-1}{m-1}$。

这是因为从 $f(x)$ 的项被删除开始，**低于**最高次的项必然未受到删除的影响，这部分和 $(1+x)^n$ 的系数是一致的；而最高次项必然由上一轮**删除后的**最高次项得到，由于开始删除后，每一轮都至少有一项被删除，**删除后的**最高次原本不是最高的，也就可以利用第一种情况计算。

这样一来，问题就变成了计算 $\Theta(n)$ 个二项式系数之和，而且它们在杨辉三角上都是相邻的，也就容易递推计算，这是便于处理高精度处理的。

总时间复杂度 $\mathcal O(n^2)$，不过常数很小。主体代码如下：

```cpp
void solve(int n){
    if(n<4){
        puts("1");
        return;
    }
    if(n==4){
        puts("2");
        return;
    }
    int cnt = 1,x,y,a,b,la = -1,lb; 
    bigint ans = 0,cur = 1;
    for(int i=1;;++i,++cnt){ 
        for(int j=0;cnt>0;++j){
            y = cnt-1,x = n-i+cnt;
            if(x-y*pi>=4) break;
            if(j==0) a = i-2,b = cnt-2;
            else a = i-1,b = cnt-1;
            if(la!=-1){
                if(la<a) cur = cur*a/(a-b); // 只用计算高精 乘/除 低精
                if(lb>b) cur = cur*(b+1)/(a-b);
            }
            ans += cur;
            la = a,lb = b;
            --cnt;
        }
        if(cnt==0) break;
    }
    print(ans);
}

```
ps：如果这题取模，如何做到比 $\Theta(n)$ 更快呢？