这题牛了 虽然在卡的题单的多点求值板块里面，但是 std 根本没有用到多点求值

首先容易把题目转化为求一组 $(r,p)$ 满足 $p|F(r)$，且 $p\ge m$，其中 $F(r)$ 是一个 $n-1$ 次的多项式。

考虑对随机的 $r$，把 $F(r)$ 也视为 $[0,p-1]$ 上的随机数，那么我们就可以粗略估计此时无解的概率大约是 $(1-1/p)^p=1/e\sim 1/3$，所以期望试 $3$ 次，套上一个任意模数多点求值就可以在 $O(3n\log^2n)$ 的时间内解决。

但是我不想写任意模数多点求值，所以换个方法。

考虑把尝试的数量降低。取 $d|p-1$，如果我们找到一个 $r_0$，使得 $r_0^{\frac{p-1}{d}}\not\equiv 1\pmod p$，那么就可以知道 $\delta_p(r_0)|d$ 且 $\delta_p(r_0)>1$。取 $d$ 为质数，那么就有 $\delta_p(r_0)=d$。

那么我们只代 $r_0$ 的幂（一共 $d$ 个），注意到此时 $x^{d+t}\equiv x^t\pmod p$，所以此时可以把多项式的幂降到 $d$，这样一来我们多点求值的复杂度就降到了 $d^2$。

但是与此同时，我们单次不成功的概率提升到了 $(1-1/p)^d$，粗略估计 $p=2d+1$ 大概是 $1/\sqrt e$，大概要多算几次。为了进一步优化复杂度，我们可以把枚举 $p$ 改为枚举 $d$，注意 $d$ 从 $2$ 开始枚举的时候找 $r_0$ 会快一点。

复杂度已经是我算不了的境界了，但是官方 Tutorial 说这期望跑 $O(\log p)$ 轮，，反正我不会

扔个极简主义代码
```cpp
void solve(ll d){
	rep(i,0,d-1)a[i]=0;
	rep(i,0,n-1)a[i%d]+=c[i];
	for(ll p=m/d*d+d+1;p<maxn;p+=d)if(!vst[p])for(ll r,r0;;){
		r0=rnd(2,p-2);
		if((r=qpow(r0,(p-1)/d,p))==1)continue;
		r0=r;
		rep(_,1,d){
			ll res=0;
			Rep(i,d-1,0)res=(res*r%p+a[i])%p;
			if(res==0)cout<<p<<" "<<r<<endl,exit(0);
			r=r*r0%p;
		}
		break;
	}
}
int main(){
	cin>>n>>m>>s>>t;
	rep(i,0,n-1)c[i]=s[i]-t[i];
	prep(1e6);
	rep(i,2,tot)solve(pr[i]);
	return 0;
}
```