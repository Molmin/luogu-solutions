首先我们不难发现这个序列在一定程度上肯定是有单调性的，因为本身这个生成的方式就是一个单调的过程。

我们发现对于一个块 $\{a,b,c\}$，如果 $a>b$，那 $b$ 一定是紧跟在 $a$ 后面的。而如果 $a<b$，那么我们不难发现这个快可以分裂成两个，也就是 $\{a\},\{b,c\}$，因为 $b$ 肯定在 $a$ 之后选。

那么也就是说，我们现在的情况是，有一些长度为 $1,2,3$ 的块，每个块都是的开头都是最大的。这给我们了一个提示，因为这样的东西给了我们一个将构造方法和序列连结起来的桥梁。因为这个东西与序列一一对应，这个只要将首字母排序一下就可以了。那么我们现在就只要考虑把划分后的块和划分前的块一一对应就可以了。

也就是说我们需要找到其充要条件。我们发现，其实长度为 $3$ 的块再多也不要紧，因为本来的块就是长度 $3$ 的，我们考虑划分后的块。不难发现每次划分要么就是去掉一个长度为 $3$ 的块，加上一个长度为 $2$ 的块和一个 $1$ 的块，要么就是将一个 $2$ 的块划分成两个 $1$ 的块。我们考虑这件事情，就不难发现这个条件了：$2$ 的块数小于等于 $1$ 的块数。

现在我们只要将划分完的块拼起来就可以了。也就是说，一个序列合法的充要条件是：存在一种划分方案，使得划分后每个块大小小于等于 $3$，而且每个块的开头是块中最大的，且比其之前的数都要大。经过之前的推导，我们也知道了这种划分方案是唯一的。

我们思考这东西怎么计算，我们先考虑如果划分方案已经给出，数字随便填，这样有几种方案。

我们发现，一些限制就是：$a_i$ 在 $[1,r]$ 中是最大的。如果长度为 $n$，那么答案就是 $\frac{n!}{\prod r}$。于是我们用这个性质就可以 `dp` 了。

我们令 $f_{i,j}$ 表示如果排列的长度为 $i$（只能填前 $i$ 个数），长度为 $1$ 的块的个数减去长度为 $2$ 的块的个数为 $j$ 的方案数。其实就是考虑右面加一个什么样的块。根据上面的式子，我们不难得到：

![](https://i.loli.net/2020/04/01/aDJZ48j2oH1U3kY.png)

（由于本人不是很会 $\LaTeX$，所以上面的公式好像不是很会打，如果想要更舒服的体验可以直接看[我的博客](https://pufanyi.github.io/agc043_d/)）

然后就可以愉快地转移啦！