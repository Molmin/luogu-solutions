一道挺有意思的数数题。

首先碰到这样的问题我们肯定要考虑什么样的排列符合要求。我们考虑 $n$ 的位置——显然只有在迫不得已，即另外 $n-1$ 个指针都已经被摧毁的时候才会将 $n$ 加入序列，因此在 $n$ 后面的元素肯定跟 $n$ 是在一组的，我们完全可以把这些元素**捆在一起**，显然如果 $n$ 后面元素个数 $\ge 4$ 就直接不合法了，否则我们考虑删除这些元素，接着考虑序列中最大的元素，依次类推下去即可。因此对于一个排列 $p$，它可以成为合法的排列的**必要条件**是：如果我们每次找出序列最大的元素并将其后面的元素全部删除，那么每次删除的元素个数 $\le 3$。为什么说是“必要条件”呢？因为考虑排列 $p=(2,1,4,3,6,5)$，虽然它每次删除的数的个数都 $\le 3$（$=2$），但就是无法找到某个排列 $p'$ 使得 $p'$ 能够生成 $p$。因为我们不仅要将这些元素捆在一起，还要将它们**组成若干个三元组**，而三个 $2$ 无法通过组合变成两个 $3$，因此不可行。所以我们还要使拆出的数能够构成若干个三元组，$3$ 自然可以单独成一组，我们 duck 不必管它，$2$ 显然只能和 $1$ 配对，如果 $2$ 的个数严格多于 $1$ 的个数那就会存在多余的 $2$，也就不合法了，因此我们还要让拆出来的 $2$ 的个数 $\le 1$ 的个数。

到这里此题排列 $p$ 的性质都已经分析完了，我们先考虑如何暴力地求答案，以 $n=2$ 为例，我们枚举拆出的每段按顺序的值分别是多少，显然共有 $1,1,1,1,1,1$、$1,1,1,1,2$、$1,1,1,2,1$、$1,1,2,1,1$、$1,2,1,1,1$、$2,1,1,1,1$、$1,1,1,3$、$1,1,3,1$、$1,3,1,1$、$3,1,1,1$，$1,1,2,2$、$1,2,1,2$、$1,2,2,1$、$2,1,1,2$、$2,1,2,1$、$2,2,1,1$、$1,2,3$、$1,3,2$、$2,1,3$、$2,3,1$、$3,1,2$、$3,2,1$、$3,3$ 这些种可能，考虑怎样计算每一种可能的答案，以 $1,3,2$ 为例，显然由于最后一组为 $2$，因此 $6$ 必须填第 $5$ 个位置，这样一来最后一个元素就有 $5$ 种可能，确定最后一个元素后，剩余 $4$ 个元素中最大值的位置就定下来了，剩下来 $a_3,a_4$ 还有 $A_{3}^2=6$ 种可能，第一个元素也就只有 $1$ 种选择了，所以这种情况的贡献为 $30$，建议读者手算一下 $n=2$ 的情况，看看是不是 $261$，虽然有点烦但对正解有很强的启发性作用。

相信通过上面手算的过程我们可以看出，假设从左到右每一段长度分别为 $a_1,a_2,\cdots,a_k$，那么方案数就是 $\dfrac{n!}{a_1(a_1+a_2)(a_1+a_2+a_3)\cdots(a_1+a_2+\cdots+a_k)}$，这样就可以 $dp$ 了，$dp_{i,j}$ 表示考虑到第 $i$ 个元素，$1$ 的个数减去 $2$ 的个数等于 $j$ 的方案数，转移显然可以 $\mathcal O(1)$，总复杂度 $n^2$。

```cpp
const int MAXN=6000;
const int DELTA=6002;
int n,mod,ans=0;
int dp[MAXN+5][MAXN*2+5];
void add(int &x,int v){((x+=v)>=mod)&&(x-=mod);}
int main(){
	scanf("%d%d",&n,&mod);n*=3;dp[0][DELTA]=1;
	for(int i=0;i<n;i++) for(int j=DELTA-n;j<=DELTA+n;j++) if(dp[i][j]){
		add(dp[i+1][j+1],dp[i][j]);
		if(i+2<=n) add(dp[i+2][j-1],1ll*dp[i][j]*(i+1)%mod);
		if(i+3<=n) add(dp[i+3][j],1ll*dp[i][j]*(i+1)%mod*(i+2)%mod);
	} for(int i=DELTA;i<=DELTA+n;i++) add(ans,dp[n][i]);
	printf("%d\n",ans);
	return 0;
}
```

当然 lxr 总有比我更 nb 的做法，我们不考虑什么 DP，直接枚举 $2,3$ 的个数计算方案数，假设 $1,2,3$ 个数分别为 $c_1,c_2,c_3$，那么显然对于每个块我们给它们填上数的方案数是一个多重组合数的形式，即 $\dbinom{n}{1,1,\cdots,1,2,2,\cdots,2,3,3,\cdots,3}$，其中下面 $1,2,3$ 分别是 $c_1,c_2,c_3$ 个，套用多重组合数公式算一下是 $\dfrac{n!}{2^{c_2}6^{c_3}}$，那么显然我们给这些块填好数后，我们肯定会按照最大数的大小从小到大将这些块排成一列，当然所有 $1,2,3$ 都视作相同元素，因此还需除以 $\dfrac{1}{c_1!c_2!c_3!}$。对于长度为 $3$ 的块还有 $3,1,2$ 和 $3,2,1$ 两种填数的方法，因此还要乘上 $2^{c_3}$，故对于某对 $c_1,c_2,c_3$，填数的方案数就是 $\dfrac{n!}{c_1!c_2!c_3!2^{c_2}3^{c_3}}$，这个随便算算就行了。

~~不过似乎这个做法依赖于 $m$ 是质数？~~

~~代码？sorry，暂（yong）时（jiu）没有代码，不过代码难度这么低的题为什么还要参考别人的代码呢？~~