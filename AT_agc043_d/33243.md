## $\mathrm{Problem}$

- 给定如下构造生成长度为 $3N$ 的排列 $P$ 的方法：
  - 先生成一个长度为 $3N$ 的排列 $A$。然后将 $\forall k \in [0, N-1]$，$A_{3k+1},A_{3k+2},A_{3k+3}$ 分成一块。
  - 有 $N$ 个指针，初始指向每个块的第一个数。
  - 每次选择所有指针指向的数中最小的数删除，然后放到 $P$ 的末尾。之后指向被删除的数后移一个位置。若移出块了，则删除这个指针。
- 请你求出，一共能生成长度为 $3N$ 的排列共多少种。答案可能很大，请求出对 $M$ 取模的结果。
- $1 \leq N \leq 2 \times 10^3$，$10^8\leq M \leq 10^9+7$。

---

## $\mathrm{Solution}$
这道题我们的题意，我们可以转化为：
- 将长度为 $3n$ 的序列 $3$ 个一组分成 $n$ 组。
- 类似于归并排序，每一次加入序列的数字为每一组开头数字中最小的数。

这道题的题目很奇怪，我们需要去发掘题目中的性质。

观察到如果生成序列中出现了连续的三个数$a_i,a_j,a_k(i<j<k)$满足$a_i>a_j,a_i>a_k$，那么我们就可以确定这三个数字在原序列中是同一组的三个数字。~~这种奇怪的性质根本想不到啊~~ 

因为当$a_i$出现在序列中时，就说明了$a_i$是每一组开头元素中最小的。因而剩下每一组开头的元素都比它大，所以比它小唯一的可能性就是$a_i$的后面$a_j$，$a_k$同理。

据此，我们同时也能发现，不可能存在连续的四个数$a_1,a_2,a_3,a_4$满足$a_1>a_k(k∈[1,3])$。因为根据上面的分析，我们发现在取完$a_2,a_3$以后，比$a_1$小的数字已经取完了，因此在$a_1>a_2/a_3$的情况下必然有$a_1<a_4$。

因此序列中连续下降序列不超过3，若令$b_i=\max\{a_i\}$，我们会发现$b_i$相同的段数不会超过$3$段，即我们可以分成若干段长度为$1,2,3$的段，使得每一段的$b_i$都相同。
- 对于长度为 $3$ 的段，我们可以用这三个数字在原序列中形成一个分组，故没有影响。
- 对于长度为 $2$ 的段，我们无法形成一个分组，但这两个数又要在同一个组，因此我们需要长度为 $1$ 的段来填补剩下一个位置的空缺。而且这样是一定能构造出合法方案的。

因此我们可以得到这道题的终极结论：**$b_i$中长度为 $2$ 的段数不能小于长度为 $1$ 的段数。**

则我们可以设$f[i][j]$表示 $1$ 到 $i$ 的排列中，长度为 $1$ 的段数$-$长度为 $2$ 的段数 $=j$ 的方案数。

因此就有：
$$f[i][j]=f[i-1][j-1]+f[i-2][j+1]\times (i-1)+f[i-3][j]\times (i-1)(i-2)$$

然后代码就贼好写了...

---
## $\mathrm{Code}$

```cpp
#include <bits/stdc++.h>
#define f(i, j) f[i][j+3000]
#define int long long 

using namespace std;
const int N = 6100;

int n, P;
int f[N][N+3000];

signed main(void)
{
	cin >> n >> P;
	f(0, 0) = 1;
	for (int i = 0; i < n * 3; ++ i)
		for (int j = -n; j <= 3 * n; ++ j) {
			f(i+1, j+1) = (f(i+1, j+1) + f(i, j)) % P;
			f(i+2, j-1) = (f(i+2, j-1) + f(i, j) * (i + 1) % P) % P;
			f(i+3, j) = (f(i+3, j) + f(i, j) * (i + 1) % P * (i + 2) % P) % P; 
		}
	int res = 0;
	for (int i = 0; i <= n; ++ i) res = (res + f(n*3, i*3)) % P;
	cout << res << endl;
	return 0;
}
```
