本蒟蒻第三次发题解 ~~(第一次和第二次没通过)~~，恳请大家多多关照。

[题目传送门](https://www.luogu.com.cn/problem/AT_abc147_e)

# 题目大意
帮助高桥君走一个 $H$ 行 $W$ 列的棋盘，每次只能向右或向下走 $1$ 格，每个格子里面有两个数字，一个染成红色，一个染成蓝色，是两种颜色数字之和差最小。

# 题目思路
这是一道很明显的升维动规题，原因是我们需要三个维度来记录横坐标、纵坐标和最小差。我们可以用一个布尔型数组 $dp$ 来进行动态规划。

### $\mathit{dp}_{i,j,k}$ 用来表示从 $(1,1)$ 走到 $(i,j)$ 使最小差为 $k$ 是否有可能。

注意在这里 $k$ 表示的是红色的数字之和 $-$ 蓝色的数字之和，因此我们可以用一个变量 $t$ 存储第一个数字 $-$ 第二个的数字之差。

如果我们选择把第一个数字染红，第二个数字染蓝，相当于在上一步的基础上 $+t$，而上一步又有两种可能：
 - 从左边转移。
 - 从上边转移。

可推出如下状态转移方程：
```cpp
dp[i][j][k]|=(dp[i-1][j][k+t]||dp[i][j-1][k+t]);
```
同理，如果我们选择把第一个数字染蓝，第二个数字染红，相当于在上一步的基础上 $-t$，而上一步还是有两种可能：
 - 从左边转移。
 - 从上边转移。

可推出如下状态转移方程：
```cpp
dp[i][j][k]|=(dp[i-1][j][k-t]||dp[i][j-1][k-t]);
```

总状态转移方程如下：
```cpp
int t=a[i][j]-b[i][j];
dp[i][j][k]|=(dp[i-1][j][k-t]||dp[i][j-1][k-t]);
dp[i][j][k]|=(dp[i-1][j][k+t]||dp[i][j-1][k+t]);
```

但是我们会发现一个问题：如果数组越界怎么办？

# 数组越界问题
为防止数组越界，我们可以给状态转移方程加上两个特判：
 - 若下标小于 $0$，不要转移。
 - 若下标大于 $12720$（题目中所给上界），不要转移。
 
 代码如下：
 ```cpp
int t=a[i][j]-b[i][j];
if(k-t>=0) dp[i][j][k]|=(dp[i-1][j][k-t]||dp[i][j-1][k-t]);
if(k+t<=12720) dp[i][j][k]|=(dp[i-1][j][k+t]||dp[i][j-1][k+t]);
```
但同时我们面临着另一个问题：两种颜色的差不一定是正数，数组下标无法表示负数，怎么办呢？

### 数组下标偏移

简言之，就是用 $\mathit{dp}_{i,j,12720}$ 表示 $\mathit{dp}_{i,j,0}$，最后判断答案时 $-12720$ 就行了。

 ```cpp
int t=a[i][j]-b[i][j];
if(k-t>=12720) dp[i][j][k]|=(dp[i-1][j][k-t]||dp[i][j-1][k-t]);
if(k+t<=25440) dp[i][j][k]|=(dp[i-1][j][k+t]||dp[i][j-1][k+t]);
```
 
# 满分代码

 ```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
using namespace std;

const int P=12720;
int h,w,a[85][85],b[85][85];
bool dp[85][85][25445];

int main()
{
	cin>>h>>w;//输入 
	for(int i=1;i<=h;i++)
		for(int j=1;j<=w;j++)
			cin>>a[i][j];
	for(int i=1;i<=h;i++)
		for(int j=1;j<=w;j++)
			cin>>b[i][j];
			
	dp[0][1][12720]=dp[1][0][12720]=true;//差距为零肯定为真 
	
	for(int i=1;i<=h;i++)
		for(int j=1;j<=w;j++)
			for(int k=0;k<=25440;k++)
			{
				int t=a[i][j]-b[i][j];//开始状态转移 
				if(k-t>=12720) dp[i][j][k]|=(dp[i-1][j][k-t]||dp[i][j-1][k-t]);
				if(k+t<=25440) dp[i][j][k]|=(dp[i-1][j][k+t]||dp[i][j-1][k+t]);
			}
	
	for(int i=0;i<=12720;i++)//寻找最小差距并输出 
		if(dp[h][w][12720-i]||dp[h][w][12720+i])
		{
			cout<<i<<endl;
			break;
		}

	return 0;
}
```

