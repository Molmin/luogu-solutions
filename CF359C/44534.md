一些记号：记$M=\prod x^{a_i}$（也就是最终分数中的$t$），$S=\sum a_i$（也就是$\log _x t$

------
考虑原式中的第$i$个分数：它原本是$\frac{1}{x^{a_i}}$，通分后变为$\frac{M/x^{a_i}}{M}$。

直接这么一坨除法乘方不好看，因为底数都是相同的（$x$），所以将其化为$\frac{x^{S-a_i}}{x^S}$。这个时候，原问题转化为求$\gcd(\sum x^{S-a_i},x^S)$。

这个式子看起来还是很棘手，所以，举例。  
如果$x=2$，那么原式相当于求$\gcd(\sum 2^{S-a_i},2^S)$。   
考虑这两个数的二进制表达法，后者相当于`1000...000`，前者则是许多`100...000`相加，其中可以有进位。更重要的一点，此时求二者的$\gcd$，并不需要真正去求出两个数再进行辗转相除。  
记二者二进制表达中末尾连续`0`的个数分别为$c_1,c_2$，那么二者的$\gcd=2^{\min(c_1,c_2)}$。因为此时将二者同时向右位移$\min(c_1,c_2)$位，要么是左边的末尾出现`1`，而右边等于$2$的某次方；要么是左边末尾是`0`，而右边等于$1$。显然此时二者的$\gcd=1$，所以上面提到的$\gcd$的计算方法是正确的。

现在将其从$x=2$推广，考虑两个数的$x$进制表达法，可以发现上面的计算方法仍然成立，我们只需要找到两个数末尾`0`的个数。

$a_i$达到了$10^9$级别，所以使用`std::map`（或`std::unordered_map(c++11限定)`）来维护左边的$x$进制表达。同样，我们也不能一位一位枚举其$x$进制中的每一位，所以用`std::set`存下左边开始时哪些位上不是`0`来维护其表达。

时间复杂度：$O(n\log n)$

[code](https://www.luogu.org/paste/y045u199)