luogu P3830 


已知叶节点的总数，求（1）叶节点平均深度的数学期望（2）树的深度的平均期望

###### 子问题1

 1.1设F（i）表示叶节点个数为i是的平均深度的期望。
 
（一个事实：展开一次，多出两个深度相同的结点，多出一个叶节点）。
 事实上在计算时可以直接看成在深度为F（i-1） 的一个叶节点上展开//期望->平均。
    
于是展开的两个结点之后深度增加了 $2（F（i-1）+1）-F（i-1）$
从而得出方程        
$$ F（i）=F（i-1）+\dfrac{2}{i} $$
当叶节点只有1个时，显然 $F（1）=0 $。



------------

1.2$ F(i）= \dfrac{F(i-1)*(i-1)+F(i-1)+2}{i}$

------------
###### 子问题2

 2.1 f[i][j]表示对于一颗随机的有i个叶子的树，树的深度>=j的概率。
 
 显然树的深度==max（左子树，右子树）+1
 
 故对于一颗有i个叶子结点，左子树的叶子结点个数为k个的树（右子树结点个数为i-K)
 
 深度>=j的概率P为
       $ P=f[k][j-1]+f[i-k][j-1]-f[k][j-1]*f[i-k][j-1]$//期望的线性性
   (在计算$f[k][j-1]$与$f[i-k][j-1]$的时候事实上已经包含了另一颗子树深度>=j-1的情况，算了两次，所以应当减去)
       
 代码中的f[i][j]计算的是概率，但是最后要求的答案是期望，E(x)=$\sum_1^n$p(i)*x(i)  。在这个算法中，对于一个dp[i][j]，答案在dp[i][1]~dp[i][j]中都出现过，就相当于已经乘了一个x（i）=j，最后得到的就是期望
 ```cpp
#include<bits/stdc++.h>
using namespace std;
const int N =105;
int q,n;
double F[N];
double f[N][N];
int main(){
	cin>>q>>n;
	if(q==1){
		F[1]=0;
		for(int i=2;i<=n;++i)
			F[i]=F[i-1]+2.0/i;
		printf("%.6f\n",F[n]);
	}
	else {
		for(int i=1;i<=n;++i)
			f[i][0]=1;
		for(int i=2;i<=n;++i){
			for(int j=1;j<i;++j){
				for(int k=1;k<i;++k)
					f[i][j]+=f[k][j-1]+f[i-k][j-1]-f[k][j-1]*f[i-k][j-1];
				f[i][j]/=(i-1);
			}
		}
		double ans=0;
		for(int i=1;i<n;++i)
			ans+=f[n][i];
		printf("%.6f\n",ans);
	}
}
```
###### 对于代码中除以i-1的解释：
设想一下，如果让这颗树回到上一个状态（取消展开），上一个状态到当前状态的概率就是 
 $\dfrac{1}{i-1}$
 
 ~~自己yy出来的，不知道是不是这样解释~~

 ~~可能是最近推的最认真的一道题了~~