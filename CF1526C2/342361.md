### 一.题意
给你一串数，求从这串数中最多取出多少个数（按顺序但不一定连续），可以使得取出来的数按取出顺序构成的数列的所有前缀和都大于等于 `0` 。

### 二.分析
首先这道题一看到题就很容易想到一个 $n^2$ 的暴力，就是可以从头到尾每个都试着取一遍，如果发现取这个数使得取出来的数的前缀和小于 `0` 了，那么就从这一位往前枚举到最开始，去掉最小的数，不取这个最小的数。因为取越大的数就越有可能使取出来的数的前缀和大于等于 `0` 的情况下取出的数更多。但是很显然 $n\le2*10^5$ 的数据范围并不允许我们这样做，所以我们必须思考出一种 $n \log n$ 或者更低时间复杂度的算法。

那么我们继续顺着这个暴力想，因为枚举一遍取出来的数是一定不可以省去的，而且扔掉一个数也不可能在 $O(1)$ 的时间复杂度中完成，所以可以初步确定这个算法的时间复杂度是 $O(n \log n)$ 的。我们继续看从前面所有的数中找到最小的数扔掉这个操作，既然要在 $ \log n$ 的复杂度下完成，那么肯定是一个数据结构。什么数据结构可以在 $\log n$ 的复杂度内完成找到之前最小的数呢？很显然就是小顶堆。至此，思路已经清晰，那么代码也就可以打了。

### 三.代码
```cpp
# include <bits/stdc++.h>
# define int long long     //不开long long见祖宗，就这个卡了我半个小时QWQ
using namespace std;
int a[2000005];
priority_queue <int> q;       //优先队列（默认是大顶堆）
signed main()
{
    int n;
    cin >> n;
    for (int i = 1; i <= n; i++)
    {
        cin >> a[i];
        a[i] = -a[i];      //注意这里，我们把a[i]取相反数，因为相反数越大的数就越小，所以这里是为了将大顶堆变成小顶堆
    }
    int sm = 0;     //当前的数值
    int ans = 0;     //记录取的个数
    for (int i = 1; i <= n; i++)
    {
        q.push(a[i]);      //入队
        sm += -a[i];       //加上相反数的相反数，就是加上原来的数
        ans++;    //加上了一个数 
        if (sm < 0)    //如果发现了问题
        {
            sm += q.top();      //加上堆顶的数的相反数，就是减去这个数，说明不要取这个最小的数
            q.pop();         //把这个数pop掉
            ans--;           //取的数个数--
        }
    }
    cout << ans << endl;
    return 0;
}
```

### 四.关于这道题的启发
这道题教会了我们做题不要不屑去打暴力，可能正解就隐含在暴力当中。我们要积极地去打暴力，不仅考场上可以拿一点分数，而且还有可能可以通过 `STL` 优化拿到满分。当然我们也多学多用 `STL`，虽然它看起来并没有 `dp` 之类的算法思想重要，但是在关键时刻能够帮助你优化暴力，帮你拿到满分。

### 五.关于这题的一个小变式
学习信息要有举一反三的能力，那么我们来思考如果这题不仅要我们输出最多取多少个，而且也要输出取那几个数怎么办？

其实我们发现在这个算法中，那个小顶堆每次不行就弹出最小的数，这说明这个堆存的数是所有数里面最大的数，这就说明这个优先队列模拟的就是取出来的数构成的数组，所以这个问题的代码是：
```cpp
# include <bits/stdc++.h>
# define int long long 
using namespace std;
int a[2000005];
priority_queue <int> q;  
signed main()
{
    int n;
    cin >> n;
    for (int i = 1; i <= n; i++)
    {
        cin >> a[i];
        a[i] = -a[i]; 
    }
    int sm = 0;    
    int ans = 0;    
    for (int i = 1; i <= n; i++)
    {
        q.push(a[i]);     
        sm += -a[i];    
        ans++; 
        if (sm < 0)
        {
            sm += q.top(); 
            q.pop();        
            ans--;          
        }
    }
    cout << ans << endl;
    while (!q.empty())
    {
        cout << -q.top() << " ";
        q.pop();
    }
    return 0;
}
```


------------

谢谢观赏