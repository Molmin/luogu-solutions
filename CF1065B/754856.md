## 题意
给你 $n$ 个点和 $m$ 个边。让你输出最多和最少有哪些点没有其他边相连。
## 思路
我们先考虑最小的情况，我们用一种贪心策略，既然要我们被孤立的点最小，那么每一次我们优先连接两个还没有建立边的点即可，这样我们被孤立的点最少就为 $max(0,n-(m \times 2))$ 。接着我们考虑最大，我们只需要在不重边的情况下浪费每一条边即可，所以我们尽可能构造点多的一个**完全图**即可，这里我们可以用枚举或二分来算出他的顶点的数量。这里顺便讲一下完全图，就是每个点相互之间都有一条边相连，有 $n$ 个顶点，有 $n\times(n+1)/2$ 条边。
#### 二分的正确性
这里讲一下为什么二分是正确的，因为我们假设把 $ n \times (n+1)/2$ 这个式子看成一个函数，那么无疑，他是单调上升的，所以我们可以通过二分来枚举顶点数量。
## 坑点
注意 $n \leq 10^5$ 还有特判 $m=0$ 的时候(~~让我调了半个小时~~)。
## ACCode
```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,m; 
int main(){
	scanf("%lld%lld",&n,&m);
	cout<<max(n-m*2,0ll)<<" ";
	for(long long i=1;i<=n;i++){
		if(i*(i+1)/2>=m){//枚举我们至少要用多少点
			cout<<n-i-1;
			break;
		}
	} 
	return 0;
}
```
