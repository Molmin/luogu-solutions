### 题目大意

给定一个排列，每次可以选一个子段，随意调整子段内元素的顺序，求最少几次操作可以排序。子段不能是全部数组。

### 主要思路

1. 显然，如果这个排列是有序的，那么无须排序，直接输出$0$

1. 然后我们可以发现，要使得操作数最少， 就要让排序的范围尽量大。但题目规定，不能一次排序全部的，所以就只能排序前 $n-1$ 个或者后 $n-1$ 个。

1. 可是还有一个数没有被排序，这个数可以分 $3$ 种情况讨论

> ##### 1. 这个数就在它应该待的位置，无须继续排序，输出$1$
> 
> ##### 2.第一个数在第$n$位且第$n$个数在第一位，我们就需要先将后$n-1$个数排序(前$n-1$个也行),再第一个数排序到中间，然后再排序到最后一位。(以下是例子)
>```
> 4 2 3 1
> 4 1 2 3 (将后3个数排序)
> 1 2 4 3 (对前3个数排序，将最大值排序到中间)
> 1 2 3 4 (对后3个数排序，将最大值移动到后面)
> ```
> ##### 3.这个数应该待在中间，只需再将这个数排序到中间即可

### Code

```cpp
#include <bits/stdc++.h>

using namespace std;

const int MAXN = 50 + 5;

int a[MAXN];
int n;

int main() {
  int t;
  cin >> t;
  while (t--) {
    bool f = 1;
    cin >> n;
    for (int i = 0; i < n; i++) {
      cin >> a[i];
      if (a[i] != i + 1) {
        f = 0;
      }
    }
    if (f) {  //无须排序
      cout << 0 << endl;
    } else if (a[0] == 1 || a[n - 1] == n) {  //剩下的数在应该待的位置上
      cout << 1 << endl;
    } else if (a[0] == n && a[n - 1] == 1) {  //第一个数在第n位且第n个数在第一位
      cout << 3 << endl;
    } else {
      cout << 2 << endl;
    }
  }
  return 0;
}

```