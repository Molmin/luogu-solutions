## 放在前面的废话

你谷机子太快了，$O(K+T^2)$ 暴力什么优化不加一秒过（

这份题解的做法是暴力分块打表，想要复杂度更优的做法可以移步其他题解。

## 正题

首先，样例的那个点明显啥用没有，所以后文中提到的 $T$ 实际均为 $T-1$。

我们记剩 $i$ 次机会时的期望得分为 $f_i$，则交完一次之后要不要继续的策略很明显：如果当前得分大于继续交的期望，就停止；否则，就继续交。这样我们可以~~很方便地~~写出转移方程：
$$f_i = \sum\limits_{j=\lceil f_{i-1}\rceil}^{T}\frac{j\times\dbinom{T}{j}}{2^T}+f_{i-1}\times \sum\limits_{j=0}^{\lfloor f_{i-1}\rfloor}\frac{\dbinom{T}{j}}{2^T}$$

不要被一堆组合数和求和符吓着了，这个公式的意思很简单：左半部分，就是本次得分**高于继续交的期望**的情况下**期望的得分**；右半部分，就是本次得分不如继续交的概率乘上继续交的期望得分。

于是一种 $O(K+T^2)$ 的暴力做法就很显然了：预处理出组合数，之后从 $1$ 到 $K$ 按照公式推一遍 $f$ 数组。由于 $f$ 单调递增，所以求和符里面的东西也可以边做边推，而不用每次去算。

代码中 `rate` 就是本次得分高于继续交的期望的概率，`sum` 就是本次得分高于继续交的期望的情况下的期望得分。由于组合数最终要除个 $2^T$，所以干脆预处理时就除了。

```cpp
#include <cstdio>

const int maxn = 1009;

double C[maxn][maxn],dp,sum,rate;
int n,m,mid;

void Init(){
    C[1][1] = C[1][0] = 0.5;
    for(int i=2; i<=n; i++){
        C[i][0] = C[i-1][0]/2;
        for(int j=1; j<=i; j++){
            C[i][j] = (C[i-1][j]+C[i-1][j-1])/2;
        }
    }
    dp = n*0.5;
    mid = (n+1)>>1;
    rate=sum=0;
    for(int i=mid; i<=n; i++){
        rate += C[n][i];
        sum += C[n][i]*i;
    }
}

int main(){
    scanf("%d%d",&n,&m); n--;
    Init();
    for(int i=2; i<=m; i++){
        dp = sum+(1.0-rate)*dp;
        while(dp >= mid) {
            rate -= C[n][mid];
            sum -= C[n][mid]*mid;
            mid++;
        }
    }
    printf("%.9lf",dp+1);
    return 0;
}
```

这份代码可以在洛谷上通过这道题，但我们不妨继续看看怎么优化。观察到 $f_i$ 只与 $f_{i-1}$ 有关，所以我们可以分块打表。对于每个 $T$，我们隔 $B$ 个数存一个 $f$，这样复杂度就变成了 $O(B+T^2)$。

由于洛谷的代码长度限制，我取了 $B=3.3\times 10^8$，相当于把问题规模缩小了三倍。这样处理后，这份代码能够在 $\frac13$ 秒以内通过所有测试点。代码就不放了，和上面大同小异。