提供一个不一样的 dp 做法。

## dp

我们可以先不管全都相同的限制，要求把所有奶牛都喂饱。

我们发现，$1$ 号奶牛一定要和  $2$ 号奶牛一起被喂。所以要求 $h_1\le h_2$，然后同时投喂 $h_1$ 给个玉米，此时 $2$ 号奶牛还需要吃 $h_2-h_1$。

此时 $1$ 号奶牛被喂饱，要喂 $2$ 号奶牛，就只能和 $3$ 号奶牛一起喂，所以要求 $h_2-h_1\le h_3$，然后同是投喂 $h_2-h_1$，$3$ 号奶牛还需要吃 $h_3-h_2+h_1$。

$\dots$

最后如果喂完第 $n-1$ 只奶牛都合法，并且此时刚好吧第 $n$ 只奶牛也喂饱了，这个方案就合法。

形式化地，如果 `FJ` 能把所有奶牛喂饱，需要满足一下条件：

- $\forall i\in (1,n],h_i\ge\sum_{j=1}^{i-1}(-1)^{i-j+1}h_i$

- $\sum_{j=1}^n(-1)^{n-j+1}h_i=0$

我们设 $s_i$ 表示 `FJ` 需要投喂 $(i,i+1)$ 这对奶牛多少次。

则有 $s_0=0,s_i=h_i-s_{i-1}$。

判断条件也可以用 $s$ 来表示。

- $\forall i\in [1,n],s_i\ge 0$

- $s_n=0$

发现一个如果规定一个数组 $s$，我们可以唯一确定一个数组 $h$，

所以我们考虑把 $h$ 加到 $s$ 的判断条件里。

- $\forall i\in [1,n]s_i+s_{i-1}=h_i$

表示每只奶牛需要被投喂多少次。

我们发现这个条件非常好判断，可以很愉快的 `dp`。

设 $f_{i,j}$ 表示前 $i$ 个 $s$，其中 $s_i=j$ 的合法方案数。

转移显然：

$$
f_{i,j}=\sum_{k=0}^{\min(h_{i-1},h_i-j)}f_{i-1,k}
$$

答案就是 $f_{n,0}$。

显然可以前缀和优化，做到 $O(nh)$。

```cpp
int dp(){
	f[0][0]=s[0][0]=1;
	for(int i=1;i<=n;i++){
		up[i]=min(h[i],h[i+1]);
		for(int j=0;j<=up[i];j++){
			f[i][j]=s[i-1][min(up[i-1],h[i]-j)];
			s[i][j]=(s[i][j-1]+f[i][j])%p;
		}
	}
	return f[n][0];
}
```

回到题目，题目只要保持所有奶牛剩余投喂量相同就行了，

如果有偶数只奶牛，我们可以把着拆成两两投喂，只需要统计全部喂完的情况，不重不漏。

如果有奇数只奶牛，我们发现所有奶牛的 $h_i$ 相同时，不存在合法投喂方案，这些情况中时不会有重复的，我们只要枚举每一种保留投喂的数量，暴力算出所对应的 $f_{n,0}$，全部加起来即可。

## code

~~代码里的输出答案被隔壁家小孩偷走了。~~

```cpp
#include<bits/stdc++.h>//odd: O(n^2h)  even: O(nh)
#define int long long
using namespace std;
const int N=110,M=1010,p=1e9+7;
int n,h[N],up[N],f[N][M],s[N][M];
int dp(){
	f[0][0]=s[0][0]=1;
	for(int i=1;i<=n;i++){
		up[i]=min(h[i],h[i+1]);
		for(int j=0;j<=up[i];j++){
			f[i][j]=s[i-1][min(up[i-1],h[i]-j)];
			s[i][j]=(s[i][j-1]+f[i][j])%p;
		}
	}
	return f[n][0];
}
signed main(){
	scanf("%lld",&n);
	for(int i=1;i<=n;i++)scanf("%lld",&h[i]);
	int ans=dp();
	if(n&1){
		int mn=h[1];
		for(int i=2;i<=n;i++)mn=min(mn,h[i]);
		for(;mn--;){
			for(int i=1;i<=n;i++)--h[i];
			ans=(ans+dp())%p;
		}
	}
}
```