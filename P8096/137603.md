> 给出一个长为 $n$ 的序列 $h$，求出有多少个长为 $a$ 的序列满足以下条件：
> - $0\le a_i\le h_i$。
> - 能通过每次选择一个 $i(1\le i<n)$，把 $a_i,a_{i+1}$ 同时减去 $1$，进行若干次来使整个序列变成同一个非负整数。
> 
> 答案对 $10^9+7$ 取模。($1\le n\le100,1\le h_i\le10^3$)

这种题一看不像什么推式子的题，就可以考虑计数 $\rm dp$ 了。考虑设 $f_{i,j,k}(j\ge k)$ 表示对于前 $i$ 个数，第 $i$ 个数最后会变为 $j$，其他的数最后会变为 $k$ 的方案数。则注意到我们在转移时动 $k$ 并不是一个明智的选择，毕竟这牵扯到的数太多了，所以如果要从 $f_{i,j,k}$ 转移到 $f_{i+1,x,k}$，我们的目标应该是把第 $i$ 个数从 $j$ 变为 $k$。即要对 $i$ 操作恰好 $j-k$ 次，这样的话，第 $i+1$ 个数最初的值应该是 $x+j-k$，由于有条件 $1$ 的限制，所以我们有转移时 $x$ 的取值范围：
$$k\le x\le h_{i+1}-j+k$$
所以把 $\rm dp$ 方程写出来就是：
$$f_{i,j,k}=\sum_{l=0}^{h_i-j}f_{i-1,k+l,k},f_{1,j,k}=[j\le h_1]$$
随便做个前缀和就可以做到 $\mathcal{O}(nh_i^2)$ 的转移了。

接下来就是答案统计的问题了，显然最后我们要所有的数都一样，看起来答案应该是：
$$\sum_{k=0}^{\min \{h_i\}}f_{n,k,k}$$
在 $n$ 是奇数的时候，这样统计确实没错。但当 $n$ 是偶数的时候，我们是能够通过题目中所给的操作给全部的数减去某个非负整数的，所以本质上所有 $f_{n,k,k}$ 都被 $f_{n,0,0}$ 包含，此时答案即为 $f_{n,0,0}$。

这样直接实现可能有点麻烦，这里参考了 USACO 官方的实现方法。考虑我们刚刚关心的只是 $j,k$ 的差，所以我们新设一个状态 $f_{i,l}$ 表示前 $i$ 个，$j-k=l$ 的方案数。这样把第一维滚动掉后，实现就非常简洁了。我们需要对每个 $k$ 都做一次，注意 $0\le k\le \min\{h_i\}$，每次做的时候只需要令 $h_i$ 为 $h_i-k$ 就可以方便实现边界赋值和转移条件。时间复杂度依然是 $\mathcal{O}(nh_i^2)$，但空间省掉不少。
```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
const int N = 110, M = 1100, mod = 1e9 + 7; int f[M], pre[M], h[N];
int main()
{
	int n, mn = M, ans = 0; scanf("%d", &n);
	for (int i = 1; i <= n; ++i) scanf("%d", &h[i]), mn = std::min(mn, h[i]);
	do
	{
		for (int i = 0; i <= h[1]; ++i) pre[i] = i + 1;
		for (int i = h[1] + 1; i <= 1000; ++i) pre[i] = h[1] + 1;
		for (int i = 2; i <= n; ++i)
		{
			memset(f, 0, sizeof (f));
			for (int j = 0; j <= h[i]; ++j) f[j] = pre[h[i] - j];
			pre[0] = f[0];
			for (int j = 1; j <= 1000; ++j) pre[j] = (pre[j - 1] + f[j]) % mod;
		}
		(ans += pre[0]) %= mod;
		for (int i = 1; i <= n; ++i) --h[i];
	}while ((n & 1) && mn--);
	printf("%d\n", ans); return 0;
}
```