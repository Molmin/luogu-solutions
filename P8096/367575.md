### [传送门](https://www.luogu.com.cn/problem/P8096)

### 题意
对于 $n$ 头牛，给予每头牛的最大值 $H_i$，问一共有多少种方法可以满足下面的要求。

每次将两个相邻的值 -1，   
使最后的值全部相同。

### 分析 
首先分析我们在如何情况下可以满足我们的要求，     
显然我们可以从左边开始，将当前位与其右边的位一起下降，      
直至当前位的值与我们最终的值相同，倘若出现负数则不可行，倘若最后一位无法清 0，不可行。

可以解决前 4 个点。
### 优化
我们先枚举最终的值，然后我们发现最终的方案数只与我们前一位所遗留下来的数有关，显然我们可以用 dp 解决此题。     
转移：
~~~cpp
for(int j=3; j<=n; ++j) {
	for(int k=0; k<=a[j-1]; ++k) {
		for(int q=k; q<=a[j]; ++q) {
			f[j][q-k]+=f[j-1][k];
			f[j][q-k]%=MOD;
		}
	}
}
~~~
对于每一个最终值，
时间复杂度 $O(n\times H^2)$。      
但是此时我们可以发现，我们枚举每一个终值并不能愉快的拿到我们的部分分，甚过不了样例。

可以发现，当我们的数字数量为偶数时，我们相同的一种排列，最终可以到达好多种最终值，因此我们在偶数时只用判断 0。

### 正解 
就是简单化一下式子可以得到，$f_{j,k}=\sum_{q=0}^{a[j]-k} f_{j-1,q}$。     

很明显，我们可以用前缀和解决该问题。

[Code](https://www.luogu.com.cn/paste/3oq0xupr)。