## 解析

设 $\texttt{cur}(i)=f(i)-g(i)$，其中 $f(i)$ 表示前缀 $[0, i]$ 中 “$1$” 的个数，$g(i)$ 表示前缀 $[0, i]$ 中 “$0$” 的个数

对于 $\texttt{cur}(i)$ 和 $\texttt{cur}(i+1)$，我们连一条**有向边** $(\texttt{cur}(i), \texttt{cur}(i+1))$；于是这样根据原字符串能得到一张图。若想要从图再得到原字符串，只需按一定顺序遍历这张图的所有边即可（方案一定存在；但对于每个结点，其出边的遍历顺序是规定的）

接着再重新考虑操作的含义。由于操作选定的子串中 “$0$”, “$1$” 数量相等，因此其就相当于在图中 “选中” 一条回路；接着能发现这次操作等价于**将这条回路的所有边的方向取反**，得到的新回路的遍历优先级和之前相同（不难发现操作前这条回路的边的遍历时间戳一定是相邻的）

我们将所有有向边均视为无向边，可以发现 原问题 和 在这张图中寻找一条 “权” 最小的欧拉路 是等价的；其中 “权” 的定义为，将欧拉路径的边序列，按 “边方向是从编号 $x$ 连向编号 $x+1$ 即为 ‘$1$’，否则为 ‘$0$’” 的规则，转化得到的字符串的字典序大小

（叙述可能有点繁长别介意qaq）

至于如何寻找这条路径，可以考虑贪心

首先这条路径应当从结点 $0$ 出发。接着不难发现对于图中的每个结点 $x$，仅可能有向 $x-1$ 或 $x+1$ 连的边

为了方便说明，下面我们每遍历一条边就默认将这条边从图中 “删除”

设当前在结点 $u$（$u$ 初始应为 $0$），$d(x, y)$ 表示剩余的边 $(x, y)$ 的数量。于是有：

1. 如果 $d(u, u-1)$ 为偶数，$d(u, u+1)$ 为偶数，显然贪心地先走 $u-1$
2. 如果 $d(u, u-1)$ 为偶数，$d(u, u+1)$ 为奇数，也贪心地先走 $u-1$
3. 如果 $d(u, u-1)$ 为奇数，$d(u, u+1)$ 为偶数，若 $d(u, u-1)=1$ 且 $d(u, u+1)>0$ 的话，就必须走 $u+1$；否则 $u+1$ 处的边之后就无法遍历了
1. 如果 $d(u, u-1)$ 为奇数，$d(u, u+1)$ 为奇数，这种情况不合法（会导致图不存在欧拉路）

然后就做完了

## CODE

```cpp
#include <cstdio>
#include <vector>
using std::vector;

const int MAXN =5e5+20;

/*------------------------------IO------------------------------*/

int read(){
	int x =0; char c =getchar(); bool f =0;
	while(c < '0' || c > '9') (c == '-') ? f =1, c =getchar() : c =getchar();
	while(c >= '0' && c <= '9') x =(x<<1)+(x<<3)+(48^c), c =getchar();
	return (f) ? -x : x;
}

int read_string(char *s){
	char ch =getchar();
	while(ch < '0' && ch > '9')
		ch =getchar();
	int tot =0;
	while(ch >= '0' && ch <= '9')
		s[tot++] =ch, ch =getchar();
	return tot;
}

/*------------------------------Main------------------------------*/

int main(){
	char s[MAXN];
	for(int t =0, T =read(); t < T; ++t){
		int n =read_string(s);
		
		vector<int> e[2];/* 0: to cur-1 ; 1: to cur+1 */
		e[0].resize(n*2+1, 0), e[1].resize(n*2+1, 0);
		const int DELTA =n;
		for(int i =0, cur =0; i < n; ++i){
			if(s[i] == '0'){
				++e[0][DELTA+cur];
				++e[1][DELTA+(cur-1)];
				--cur;
			}
			else{
				++e[1][DELTA+cur];
				++e[0][DELTA+(cur+1)];
				++cur;
			}
		}
		
		for(int u =DELTA+0; ;){
			if(e[0][u] >= 2 || (e[0][u] == 1 && e[1][u] == 0)){
				--e[0][u];
				--e[1][u-1];
				putchar('0');
				u =u-1;
			}
			else if(e[1][u] >= 1){
				--e[1][u];
				--e[0][u+1];
				putchar('1');
				u =u+1;
			}
			else
				break;
		}
		putchar('\n');
	}
}
```