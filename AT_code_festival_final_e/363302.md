警示一下读者，本题翻译有误，正确翻译是求删去一些点后最大的波浪形序列长度。

那么，既然所有点都要满足它与它左右的元素大小关系不同，这里就可以用一重循环解决。

我们维护上一个我们挑选出的数的位置，与我们现在枚举到的数和它的下一个数相比较，如果其大小关系不同，我们就可以确定它们组成了一个“波浪”。

注意，我们要从第 $2$ 个数枚举到第 $n-1$ 个（防止数组越界），因为由我们的构造方法，原数列首尾的数一定在最终数列中。

注意，根据题目定义，相邻元素是不能相等的，否则会 WA on #15。

剩下的细节见代码注释。

```cpp
# include <iostream>
using namespace std;
long long a[3001];
//下文的偷懒方法可能会爆 int
//不开 long long 可能 WA on #5

int main(){
    int n;
    cin >> n;
    for (int i=1; i <= n; i++)
        cin >> a[i];
    int ans=n, cur=1;
    //因为第一个元素肯定在序列中，cur 的初始值为 1
    for (int i = 2; i < n; i++){
        if ((a[i] - a[cur]) * (a[i+1] - a[i]) >= 0){
            //偷懒，如果大小关系相同则结果大于 0，反之则小于 0。
            ans--;
        }
        else {
            //cur 更新为波浪序列中新加入的的元素
            cur = i;
        }
    }
    if (ans <= 2){
        //根据题目定义，波浪序列长度不小于 3
        ans = 0;
    }
    cout << ans << endl;
    return 0;
}
```
