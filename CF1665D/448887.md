[翻译](https://www.luogu.com.cn/paste/tsxthg2u)

首先看到 $30$ 次询问确定一个 $10^9$ 的数，我们考虑依次确定每一位。

为了在确定高位的时候消除对低位的影响，我们从低位向高位依次确定。

现在我们考虑如何确定最低位。

考虑 $\gcd(x+2,x+4)$，容易发现，$+2$ 和 $+4$ 对 $x$ 的最低位都没有影响，所以如果 $\gcd(x+2,x+4)$ 的最低位是 $0$，那么就意味着 $x$ 的最低位是 $0$。

然后我们考虑倒数第 $i$ 位，设我们已经求出了 $x$ 的低 $i-1$ 位组成的数 $y$，那么我们同样考虑 $\gcd\left(x-y+2^{i+1},x-y+2^{i+2}\right)$，如果该数的第 $i$ 位是 $1$，那么就说明 $x$ 的第 $i$ 位是 $1$，反之亦然。

然后我们就可以写出这样的代码：

```cpp
void solve() {
	ll y = 0;
	for (ll i = 0; i < 30; i++) {
		ask((1ll << (i + 1)) - y, (1ll << (i + 2)) - y);
		y |= (((get() >> i) & 1) << i);
	}
	printf("! %lld\n", y);
	fflush(stdout);
}
```

然后我们发现，最后一次询问有可能是：`? 1073741823 2147483647`（这是 $x=1$ 的情况），就成功地炸掉了 $2\times10^9$

但是我们发现 $2\times10^9$ 可以承受住 $2^{29}+2^{28}$ 这个数，因此我们考虑 $\gcd\left(x-y+2^{29},x-y+2^{29}+2^{30}\right)$，通过分类讨论我们可以发现这个数的效果和 $\gcd\left(x-y+2^{30}+2^{31}\right)$ 是一样的，因此我们可以这样写：

```cpp
void solve() {
	ll y = 0;
	for (ll i = 0; i < 29; i++) {
		ask((1ll << (i + 1)) - y, (1ll << (i + 2)) - y);
		y |= (((get() >> i) & 1) << i);
	}
	ask((1ll << 29) - y, (1ll << 30) + (1ll << 29) - y);
	if (get() == 1 << 30) {
		y |= (1ll << 29);
	}
	printf("! %lld\n", y);
	fflush(stdout);
}
```

这样就做完了。