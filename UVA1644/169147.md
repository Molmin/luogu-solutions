## ~~本题大水！~~


 本题先用欧拉质数筛法，而且只把这个数是否是质数的数据筛出（不用数组把质数存起来！循环到sqrt(n)就可以把后面的合数全部找出来并标记，所以循环到i*i<=1299709就够了，没有必要打整个质数表）。之后首先判定这个数是不是质数，不是的话直接输出0看下一组数据，否则从输入的这个数据开始往两边找质数，后输出。~~（时间复杂度0ms）~~
 
 不多说，上代码，大神勿喷：
 ```cpp
#include<bits/stdc++.h>//万能头
using namespace std;
int n,b,s;//n为输入的这个数，b和s分别为后面的质数与前面的质数
bool a[1299710];//存是否为质数的数组a
void find_prime(){//寻找质数
    for(int i=2;i*i<=1299709;i++）//因为循环到sqrt(n)就可以把后面的合数全部找出来，所以循环到i*i<=1299709就够了（这个还是要自己理解）
        if(a[i]==false){//找到了一个质数
            for(int j=i;j*i<=1299709;j++){//标记不是质数的（第一个数为i*i,欧拉质数筛法，只标记一次，时间复杂度低）
                a[i*j]=true;//标记合数
            }
        }
    }
}
int main(){
    find_prime();
    while(scanf("%d",&n),n!=0){//判断输入的是否为0
        if(a[n]==false){//如果是质数
            printf("0\n");//直接输出0
            continue;//返回读入下一组数据
        }
        for(int j=n;j>=2;j--){//找前面的质数
            if(a[j]==false){//找到了
                s=j;//记录
                break;//跳出循环
            }
        }
        for(int j=n;;j++){//找后面的质数
            if(a[j]==false){//找到了
                b=j;//记录
                break;//跳出循环
            }
        }
        printf("%d\n",b-s);//输出两数之差
    }
    return 0;//读入到0后漂亮地结束！
}
```
