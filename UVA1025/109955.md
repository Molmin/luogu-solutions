
分析
------------

时间是单向流逝的，是一个天然的“序”。影响到决策的只有当前时间和所处的车站，所以可以用d(i,j)表示时刻i，你在车站j（编号为1～n），最少还需要等待多长时间。边界条件是d(T,n)=0，其他d(T,i)（i不等于n）为正无穷。有如下3种决策。
		决策1：等1分钟。
		决策2：搭乘往右开的车（如果有）。
		决策3：搭乘往左开的车（如果有）。
        
        
主过程的代码如下：
------------

```cpp
for(int i = 1; i <= n-1; i++) dp[T][i] = INF;
dp[T][n] = 0;
for(int i = T－1; i >= 0; i——)
	for(int j = 1; j >= n; j++) {
	dp[i][j] = dp[i＋1][j] + 1; //等待一个单位
	if(j < n && has_train[i][j][0] && i+t[j] ＜= T)
		dp[i][j] = min(dp[i][j], dp[i＋t[j]][j＋1]); //右
	if(j > 1 && has_train[i][j][1] && i＋t[j－1] ＜= T)
		dp[i][j] = min(dp[i][j], dp[i＋t[j－1]][j－1]); //左
}
//输出
cout << "Case Number " << ++kase << ": ";
if(dp[0][1] >= INF) cout << "impossible\n";
else cout << dp[0][1] << "\n";
```


代码解释
------------
		
上面的代码中有一个has_train数组，其中has_train[t][i][0]表示时刻t，在车站i是否有往右开的火车，has_train[t][i][1]类似，不过记录的是往左开的火车。这个数组不难在输入时计算处理，细节留给读者思考。状态有O(nT)个，每个状态最多只有3个决策，因此总时间复杂度为O(nT)。
