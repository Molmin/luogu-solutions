首先稍微~~吐槽~~说一下：一次函数是形如 y=kx+b (k≠0) 的函数，而 y=b 只是函数，不是一次函数， x=b 连函数都不是……

### 所以题目就是求两个 "x" 所连成直线的解析式。

所以我们就要求两个点的坐标。但求这两个点的坐标，就要找出原点的坐标。所以本题的第一个坎，就是：

### 1.找到原点
确定原点，就要找到x轴和y轴。

所以我的思路很直观：

只要在同一行找到两个（或以上）“1”，那这个就是x轴；同样，只要在同一列找到两个（或以上）“1”，那这个就是y轴。

如这个样例：
```
3
01x
x10
111
```
x轴就是第三行，y轴就是第二列

它的原点坐标就是(3,2)

（我的数组下标从1开始，即 $a_{1,1}$）

但是这两个个样例给了我一个暴击：

```
3
x11
x00
100
```
```
3
0x0
111
0x0
```

这样根本就求不出原点的横坐标！（因为原点那列只有1个1，甚至没有！）

所以我又加了一个判断：如果横坐标为0（一开始横坐标赋值为0，如果还是0，说明横坐标没变过。），那么就每列搜过去，如果不是在原点纵坐标那一行有一个1或 'x'（或1个以上），那么它就是y轴。若纵坐标为0，同理。

接下来就是第二道坎了：
### 2.求出解析式
可以分为三类：

1. x=b (x1=x2，输出x1)
2. y=b (y1=y2，输出y1)
3. y=kx+b (k≠0)

那如果是第三个怎么求解析式呢？

此处我们设解析式为y=kx+b (k≠0)，

那么把 A(x1,y1) , B(x2,y2) 代入，得：

$\begin{cases}y_1=kx_1+b\\y_2=kx_2+b\end{cases}$

解得

$\begin{cases}k=\dfrac{y_1-y_2}{x_1-x_2}\\b=y_1-\dfrac{y_1-y_2}{x_1-x_2}x_1\end{cases}$

当然，这里已经排除了 $x_1=x_2$ 这种情况（它已经在分类1里面了）。
### 3.输出

一切都是那么的顺利美好。然而我并没有注意到这句话：
#### 常数始终保留四位小数

此为何意？？

原本我以为当 k=1 时要输出 y=x ,结果只有90分。。

当然，那个样例是**y=1.0000x**。。。

那么 k=-1 应该也是同理。

还要注意b=0时不用输出0.0000，并且注意k和b都是四位小数。

下面放上代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
	int n,i,j,l,ox=0,oy=0,x1,y1,x2,y2,p=0;
	char a[17][17];
	double k,b;
	cin>>n;
	for(i=1;i<=n;i++)
	{
		for(j=1;j<=n;j++)
		{
			cin>>a[i][j];
			if(a[i][j]=='x'&&p)
			{
				x2=j;
				y2=i;
			}
			if(a[i][j]=='x'&&!p)
			{
				x1=j;
				y1=i;
				p=1;
			}
		}
	}
	//找原点
	for(i=1;i<=n;i++)
	{
		for(j=1;j<=n;j++)
		{
			if(a[i][j]=='1')
			{
				if(!ox)
				{
					for(l=1;l<=n;l++)
					{
						if(l!=i&&a[l][j]=='1')//竖着搜1
						{
							ox=j;
							break;
						}
					}
				}
				if(!oy)
				{
					for(l=1;l<=n;l++)
					{
						if(l!=j&&a[i][l]=='1')//横着搜1
						{
							oy=i;
							break;
						}
					}
				}
			}
		}
	}
	if(!ox)
	{
		for(j=1;j<=n;j++)
		{
			for(i=1;i<=n;i++)
			{
				if(i!=oy&&(a[i][j]=='1'||a[i][j]=='x'))
				{
					ox=j;
				}
			}
		}
	}
	if(!oy)
	{
		for(i=1;i<=n;i++)
		{
			for(j=1;j<=n;j++)
			{
				if(j!=ox&&(a[i][j]=='1'||a[i][j]=='x'))
				{
					oy=i;
				}
			}
		}
	}
	x1=x1-ox;x2=x2-ox;
	y1=oy-y1;y2=oy-y2;
//	printf("O(%d,%d)\n",ox,oy);
//	printf("A(%d,%d)\n",x1,y1);
//	printf("B(%d,%d)\n",x2,y2);
	if(x1==x2)
	  printf("x=%.4lf",(double)x1);
	else
	{
		if(y1==y2)
		  printf("y=%.4lf",(double)y1);
		else
		{
			k=(y1-y2)*1.0/(x1-x2);
			b=y1-k*x1;
			printf("y=%.4lfx",k);
			if(b!=0)
			{
				if(b>0)
				  printf("+");
				printf("%.4lf",b);
			}
		}
	}
	return 0;
}
```
（如果有讲错或讲得不好得地方请大家指出，谢谢。）