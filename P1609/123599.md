### 算法：数论

------------

- 思路和其他人基本相同，我这里稍微说的清楚一点。
- 先说一下将使用的数组：$s[i]$表示输入的$n$（因为$n<10^{100}$），$ans[i]$表示输出的$p$，$s[i]$与$ans[i]$下标都从$0$开始。
- 解决此题，我的方法是分为三步：
#### $1.$ 关于进位的问题
- 我们发现，只有$n$是形如$999...999$的数，输出的答案才会进位，我们不妨特判一下，若$n$是形如$999...999$的数，则将其加$1$，也就是变为$1000...000$，这样就不需要考虑进位的问题啦。
#### $2.$ 将$n$先变成一个回文数，至于是大是小等会考虑
- 从$i=0$枚举到$i\leqslant l-i+1$，使得$ans[i]=ans[l-i+1]=s[i]$，这样，$ans$目前就是一个回文数了。但这个回文数不一定会比$n$大，比如说$n=1999$，变化后$ans=1991$。
#### $3.$ 从中间开始向左搜，找到第一个不是$9$的数，再将中间的$9$全变为$0$，如此变换多次，直到$ans>s$
- 从$i=(l+1)/2-1$开始，向左找第一个不是$9$的数，假设这个位置是$j$，则使$ans[j]$与$ans[l-j+1]$都加$1$。
- 再从$i=j+1$开始枚举到$i\leqslant l-i+1$，使得$ans[i]=ans[l-i+1]=0$。
- 举个例子吧，若第二步后$ans=1991$,则经过第三步一次变化后$ans=2002$。
- 由于不想定义太多变量，以上的$i,j$在代码中均用一个变量$p$表示。
- 且慢，我还没说怎么比较大小呢，这里要用到一个函数$strcmp(char\;s1[],char\;s2[])$，若$s1<s2$，返回的值为$-1$；若$s1=s2$，返回的值为$0$；若$s1>s2$，返回的值为$1$。

------------

- 说完了上面一大堆废话（~~表示我自己都绕晕了~~），但是代码比较短，见下：
```cpp
#include <cstdio>
#include <cstring>
using namespace std;
char s[105],ans[105];//含义见上文
int main()
{
        scanf ("%s",s);//读入
        int l=strlen(s);//保存长度
        //特判（步骤1），注意l++
        for (int i=0;i<l&&(s[i]=='9');i++)
            if (i==l-1){s[0]='1';l++;for (int i=1;i<l;i++)s[i]='0';}
        //步骤2：先变成一个回文数
        for (int i=0;i<=l-i-1;i++)ans[i]=ans[l-i-1]=s[i];
        //步骤3
        while (strcmp(ans,s)<=0){
            int p=(l+1)/2-1;while (ans[p--]=='9');p++;
            //找第一个不是9的数
            ans[p]=ans[l-p-1]=ans[p]+1;
            for (p<=l-p-1;p++)ans[p]=ans[l-p-1]='0';
            //将中间的9变为0
        }
        printf ("%s",ans);//输出
        return 0;
}
```
-----------

### 广告
- 推荐一下两位同学的博客（因yzc本人要求，已将巨佬改为蒟蒻）：
- $1. $[azy巨佬的博客](https://www.luogu.com.cn/blog/3355406081azy/)
- $2. $[yzc蒟蒻的博客](https://www.luogu.com.cn/blog/ytxnqwl/)