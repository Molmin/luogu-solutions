# P8033 Prozor 题解
### 题目描述
给定一个 $R$ $×$ $S$ 的 $01$ 矩阵，求其中一个 $K$ $×$ $K$ 的子矩阵，使其包含 $1$ 最多（不含边界）。

$3$ $≤$ $K$ $≤$ $R,S$ $≤$ $100$

### 思路
注意到数据范围，直接考虑 $O(RS)$ 枚举所有 $K$ $×$ $K$ 矩阵，求最大值。而朴素地统计每个 $K$ $×$ $K$ 矩阵中 $1$ 的个数，复杂度是 $O(K^2)$ 的。那么合起来，这整个程序的复杂度就成了 $O(RSK^2)$，稍加优化（当矩阵“越界”时直接剪枝）后可以变成 $O((R-K+1)(S-K+1)K^2)$，其实已经可以通过本题了。

但 ~~作为一道黄题绝不会这么水~~ 我们发现，当数据范围扩大到 $1000$ 时，上述做法的复杂度就不可接受。能不能考虑继续优化呢？优化过的程序能不能跑过 $1000$，甚至 $2000$ 呢？

答案是可以的——**二维前缀和**。

与一维前缀和类似，二维前缀和同样需要预处理，查询时的复杂度同样是 $O(1)$，但预处理的复杂度变成了 $O(n^2)$，在本题中即 $O(RS)$。

首先来讲预处理，设 $f_{i,j}$ 为矩阵内以 $(1,1)$ 点为左上角，$(i,j)$ 点为右下角的子矩阵中所有权值的和，设 $a_{i,j}$ 为矩阵内 $(i,j)$ 点的权值，结合下图则不难得出递推式 $f_{i,j}=f_{i-1,j}+f_{i,j-1}-f_{i-1,j-1}+a_{i,j}$

![二维前缀和图解(预处理)](https://s4.ax1x.com/2022/01/16/7tQl4g.png)

其中，$f_{1,1}$ ~ $f_{i-1,j-1}$ 被重复计算了两次，所以要减去一次。

接下来 $O(1)$ 查询的式子也不难得出：
![二维前缀和图解(查询)](https://s4.ax1x.com/2022/01/16/7tl7YF.png)

设 $sum_{(i_1,j_1),(i,j)}$ 为矩阵内以 $(i_1,j_1)$ 点为左上角，$(i,j)$ 点为右下角的子矩阵中所有权值的和，则 $sum_{(i_1,j_1),(i,j)}=f_{i,j}-f_{i,j_1}-f_{i_1,j}+f_{i_1,j_1}$。推导过程较为简单，此处不放出。

是不是明白了？这道题使用二维前缀和优化后，查询每个 $K$ $×$ $K$ 矩阵中 $1$ 的个数时，复杂度可以降到 $O(1)$，但总复杂度需要加上一个 $O(RS)$。所以，这种做法的时间复杂度就是 $O(RS+(R-K+1)(S-K+1))$，甚至可以跑过 $R=S=5000$。

最后讲一下怎么输出框选后的矩阵。按题意模拟即可。先考虑特判矩阵的四个角，坐标分别是 $(x,y)$，$(x,y-k+1)$，$(x-k+1,y)$，$(x-k+1,y-k+1)$。再来特判矩阵的横边，即当某个点坐标为 $(x,?)$ 或 $(x-k+1,?)$ 且当 $y-k+1<?<y$ 时，输出横边，同理特判竖边，当某点均不满足以上条件时，输出原矩阵中的该点即可。

贴一份丑陋的代码

```cpp
#include<bits/stdc++.h>
using namespace std;

int f[105][105],r,s,k;
char ch[105][105];

struct node{
	int x,y,su;
}ans;
void read(){
	scanf("%d%d%d",&r,&s,&k);
	for(int i=1;i<=r;i++){
		for(int j=1;j<=s;j++){
			cin>>ch[i][j];
			if(ch[i][j]=='*'){
				f[i][j]=1;
			}
		}
	}
	for(int i=1;i<=r;i++){
		for(int j=1;j<=s;j++){
			f[i][j]=f[i][j-1]+f[i-1][j]-f[i-1][j-1]+f[i][j];
		}
	}
}

bool check(int x,int y){
	return x>0&&x<=r&&y>0&&y<=s;
}

void solve(){
	for(int i=k;i<=r;i++){
		for(int j=k;j<=s;j++){
			if(f[i-1][j-1]-f[i-1][j-k+1]-f[i-k+1][j-1]+f[i-k+1][j-k+1]>ans.su){
				ans.su=f[i-1][j-1]-f[i-1][j-k+1]-f[i-k+1][j-1]+f[i-k+1][j-k+1];
				ans.x=i,ans.y=j;
			}
		}
	}
}

void write(){
	printf("%d\n",ans.su);
	for(int i=1;i<=r;i++){
		for(int j=1;j<=s;j++){
			if((i==ans.x&&(j==ans.y||j==ans.y-k+1))||i==ans.x-k+1&&(j==ans.y||j==ans.y-k+1)){
					printf("+");
			}
			else if((i==ans.x||i==ans.x-k+1)&&j<ans.y&&j>ans.y-k+1){
				printf("-");
			}
			else if((j==ans.y||j==ans.y-k+1)&&i<ans.x&&i>ans.x-k+1){
				printf("|");
			}
			else{
				printf("%c",ch[i][j]);
			}
		}
		printf("\n");
	}	
}

int main(){
	read();
	solve();
	write();
	return 0;
}

```
