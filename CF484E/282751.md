整体二分的主流做法是求最长的连续的 1 的区间，但是我们可以有另一个鬼畜的做法。

首先这题的静态版本比较经典。单调栈维护每个点前驱后继 $l_i,r_i$，那么 覆盖 $[l_i,r_i]$ 的最大高度即是这个点的高度。

这个整体二分很好想到，首先把 $a$ 按高度排序，我们考虑整体二分到询问 $[ql,qr]$，答案 在 a 数组下标 $[vl,vr]$ 之间，那么就是要看 $[mid+1,vr]$ 这些墙的覆盖范围是否能满足要求，可以把每个 $[l_i,r_i]$ 转化为一条线段，原问题变为对每个询问快速查询是否有一个线段和它的交大于 $z$。这里可以分类讨论：

1°有一个线段完全包含它

一定合法，因为 $z<y-x+1$。

2°它完全包含一个线段

考虑双指针解决这个问题，把 $[ql,qr]$ 的询问按 $z$ 降序排序，线段按长度降序排序。这样当我们扫到一个询问的时候可以保证之前的线段长度一定是大于要求的，所以只需要看是否完全包含即可，考虑维护一棵线段树，每个点表示以它为左端点的线段中，右端点最近的是哪个。每次 $O(\log)$ 更新，询问就是查询 $[x,y]$ 最小值是否小于 $y$。

3° 一个线段在它左边

在这种情况下，可以看成把线段左端点和 $x$ 强制取 $\max$（我们并不用考虑右端点超过 $y$ ，因为这是情况 1），考虑把线段按 $l$ 排序，对于每个询问二分找到小于 $x$ 的前缀，查询前缀 $r$ 最大值是否大于 $x+z-1$。

4° 一个线段在它右边

维护方式和情况 3 相同。

于是就可以 $O(n \log n^2)$ 解决这个问题，事实上，除了情况 2 都可以做到单 $\log$（双指针），但是情况 2 并没有想到优化成单 $\log$ 的方法。