## 题目大意：
定义函数$ f(a) $为 $$ f(a)=\max_{0<b<a}\gcd(a\oplus b,a\ \&\ b) $$
给出 $q$  个询问，每个询问为一个整数$ a_i $。你需要对于每个询问，求出 $ f(a_i)$ 的值。

## 思路
看到这道题，我的第一反应是打表，不管打不打得下表，都得先打暴力，于是有了以下这个暴力的程序：
```cpp
//Sooke & LJC00118 bless me
//memset0 & lijian3256 ddjxd
//iWApD3 & Spfa tql
//LJB00125 & LJB00127 吊打 LJB00126
//wangyujia will help me
#include<bits/stdc++.h>
using namespace std;
int a[1005];
int gcd(int a, int b){ return a == 0 ? b : gcd(b % a, a);}
//忽略这个gcd函数ovo，本来打算用的，结果想想还是__gcd()好用QwQ
int main()
{
	int q;
	scanf("%d",&q);
	for(int i = 1; i <= q; i++)
	{
		scanf("%d",&a[i]);
		int ans = 0;
		for(int b = 1; b < a[i]; b++)
		{
			int x = a[i] | b, y = a[i] & b;
			int u = __gcd(x,y);
			ans = max(ans,u);
		}
		printf("%d\n",ans);
	}
	return 0;
}
```
还抱着试试看的心理交了一下，没想到：  
`00:55:03  Time limit exceeded on pretest 2 [pretests] → 49582424`  
数据居然这么强？！  
好吧，乖乖打表。。。   
打表的程序跑啊跑，我去看D。  
结果D看完了，不会，再看E，写完，交上去，WA。  
打表的程序还没跑完……   
等不及了，关掉它，打开生成的txt。  
一看。What!怎么这么多一样的？   
### 表1：  
0,3,1,7,7,7,1,15,15,15,15,15,15,15,5,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,1,63,63,63,63,63,63,63,63,63,63,63,63,63,63,63,63,63,63,63,63,63,63,63,63,63,63,63,63,63,63,63,21,127,127,127,127,127,127,127,127,127,127,127,127,127,127,127,127,127,127,127,127,127,127,127,127,127,127,127,127,127,127,127,127,127,127,127,127,127,127,127,127,127,127,127,127,127,127,127,127,127,127,127,127,127,127,127,127,127,127,127,127,127,127,127,1,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255……  
肯定有规律，写了个程序，打出更加高级的表：  
### 表2： 
```
[开始的编号-结束的编号](重复的次数) 该数字
[1-1](1) 0
[2-2](1) 3
[3-3](1) 1
[4-6](3) 7
[7-7](1) 1
[8-14](7) 15//重复的次数为前一个非重复数字的编号，且前一个非重复数字出现且仅出现一次
[15-15](1) 5
[16-30](15) 31//重复的次数为前一个非重复数字的编号，且前一个非重复数字出现且仅出现一次
[31-31](1) 1
[32-62](31) 63//重复的次数为前一个非重复数字的编号，且前一个非重复数字出现且仅出现一次
[63-63](1) 21
[64-126](63) 127//重复的次数为前一个非重复数字的编号，且前一个非重复数字出现且仅出现一次
[127-127](1) 1
[128-254](127) 255//重复的次数为前一个非重复数字的编号，且前一个非重复数字出现且仅出现一次
[255-255](1) 85
[256-510](255) 511//重复的次数为前一个非重复数字的编号，且前一个非重复数字出现且仅出现一次
[511-511](1) 73
[512-1022](511) 1023//重复的次数为前一个非重复数字的编号，且前一个非重复数字出现且仅出现一次
[1023-1023](1) 341
[1024-2046](1023) 2047//重复的次数为前一个非重复数字的编号，且前一个非重复数字出现且仅出现一次
[2047-2047](1) 89
[2048-4094](2047) 4095//重复的次数为前一个非重复数字的编号，且前一个非重复数字出现且仅出现一次
[4095-4095](1) 1365
[4096-8190](4095) 8191//重复的次数为前一个非重复数字的编号，且前一个非重复数字出现且仅出现一次
[8191-8191](1) 1
……
```
哇！好像找到规律了~（见表里的注释）  
## ~~这道题的本质——复读机~~   
于是简单轻松快乐地打出了这样一个程序~~~   
```cpp
//Sooke & LJC00118 bless me
//memset0 & lijian3256 ddjxd
//iWApD3 & Spfa tql
//LJB00125 & LJB00127 吊打 LJB00126
//wangyujia will help me
#include<bits/stdc++.h>
using namespace std;
int wyj[25] = {3,7,15,31,63,127,255,511,1023,2047,4095,8191,16383,32767,65535,131071,262143,524287,1048575,2097151,4194303,8388607,16777215,33554431,67108863};
bool check[67108869];
int ans(int x)
{
	if(x == 1)	return 0;
	if(x == 2)	return 3;
	if(check[x])
	{
		int a = x, out = 0;
		for(int b = 1; b < a; b++)
		{
			int x = a | b, y = a & b;
			int u = __gcd(x,y);
			out = max(out,u);
		}
		return out;
	}
	else
		for(int i = 0; i < 25; i++)
			if(x <= wyj[i])
				return wyj[i];
	return -1;
}
int main()
{
	for(int i = 0; i < 25 ; i++)
		check[wyj[i]] = 1;
	int q, tby;
	scanf("%d",&q);
	for(int i = 1; i <= q; i++)
	{
		scanf("%d",&tby);
		printf("%d\n",ans(tby));
	}
	return 0;
}
```
结果得到了`01:52:10  Time limit exceeded on pretest 3 [pretests] → 49595216`   
这数据也太TMD强了o(╥﹏╥)o  
好吧，我投降。算出每个转折点的$ans$单独记录进数组里，然后特判。  
最后`01:56:13  Accepted [main tests] → 49596255`的代码：
```cpp
//Sooke & LJC00118 bless me
//memset0 & lijian3256 ddjxd
//iWApD3 & Spfa tql
//LJB00125 & LJB00127 吊打 LJB00126
//wangyujia will help me
#include<bits/stdc++.h>
using namespace std;
int wyj[25] = {3,7,15,31,63,127,255,511,1023,2047,4095,8191,16383,32767,65535,131071,262143,524287,1048575,2097151,4194303,8388607,16777215,33554431,67108863};
int qwq[25] = {1,1,5,1,21,1,85,73,341,89,1365,1,5461,4681,21845,1,87381,1,349525,299593,1398101,178481,5592405,1082401,22369621};
bool check[67108869];
int ans(int x)
{
	if(x == 1)	return 0;
	if(x == 2)	return 3;
	if(check[x])
	{
		for(int i = 0; i < 25; i++)
			if(wyj[i] == x)
				return qwq[i]; 
	}
	else
		for(int i = 0; i < 25; i++)
			if(x <= wyj[i])
				return wyj[i];
	return -1;
}
int main()
{
	for(int i = 0; i < 25 ; i++)
		check[wyj[i]] = 1;
	int q, tby;
	scanf("%d",&q);
	for(int i = 1; i <= q; i++)
	{
		scanf("%d",&tby);
		printf("%d",ans(tby));
	}
	return 0;
}
```
### ~~嗯，这真是一道打表的好题啊！！！~~  
（挖了个小小的坑，代码被我拿掉了两个字符qwq）