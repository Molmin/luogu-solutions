考虑在本题构造一个最长上升子序列：

例如数组 [3,1,4,1,5,9]：

复制 $1$ 次得到 [3,**1**,4,1,5,9]，从中选出 1；

再复制一次得到 [3,**1**,4,1,5,9,**3**,1,4,1,5,9]，选出 3；

再复制一次得到 [3,**1**,4,1,5,9,**3**,1,4,1,5,9,3,1,**4**,1,5,9]，选出 4；

以此类推，复制第 $k$ 次时，从中选出大于第 $k-1$ 次选出的数的最小数，当然第一次选择原数组最小的数。

如果原数组没有重复的数，那一定能选出 $n$ 个数（即 $a$ 数组元素数量）。如果有，那么重复的数只计算 $1$ 次，选不到 $n$ 个数。

问题转变为「求出数组中有多少个不重复的数字」。

注意数据范围， $1 \le n \le 10^5$，$ 1 \le a_i \le 10^9$，可以直接排序。

排序和去重的代码：

```cpp
	sort(a+1, a+n+1, cmp);	//STL
	int ans=0;
	for(int i=1; i<=n; i++)
            if(a[i]>a[i-1])
                ans++;	//去重，因为数组有序（从小到大排），直接看右数是否大于左数
        cout << ans << endl;
```

没想到，`sort` 被卡了，某个点 TLE。

又写了一个归并排序，因为~~蒻~~不熟悉，调了半天。

```cpp
bool cmp(int x, int y){
    return x<y;
}
void msort(int le, int ri){
    if(le==ri)
        return;
    int mid = (le+ri)/2;
    int p1=le, p2=mid+1, p3=le;
    msort(le, mid);
    msort(mid+1, ri);
    for(int i=le; i<=ri; i++)
        b[i] = a[i];
    while(p1<=mid||p2<=ri){
        if(p2>ri||(!(p1>mid)&&cmp(b[p1],b[p2])))
        {
            a[p3++] = b[p1++];
        }
        else
        {
            a[p3++] = b[p2++];
        }
    }
    return;
}
```

不愉快地通过。

