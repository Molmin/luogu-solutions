这道题可以使用单调栈解决。

首先，我们整理一下思路，对于队伍中的一个人来说，他可能看到自己前面的人，也可能看到自己后面的人，但是如果把前后两种情况都考虑的话，寻找一遍下来一定有很多重复，所以我们决定只考虑每个人的前或后一侧的情况，这里我们对每个人的前面的人讨论

如果一个人身后存在一个比他高的人，那么他将不会再被看见，因此，可以可根据身高维护一个单调栈，从左向右依次扫描，扫描到 A 时，我们希望栈里保存的是 A 之前，能够和 A 相互看到的人。具体实现时，栈中的元素是自下而上递减的，这就要求我们再加元素时保证栈顶元素大于等于加进的那个元素，可以用二分法求出栈中第一个大于等于输入的元素的值，并把这个元素以上的元素全部弹出，把输入的元素放进栈中。

写代码时一定要注意：

1.第一个元素单独输入，道理很显然

2.由于第一个元素是单独输入的，所以栈中是有一个元素的，初始时把top设为1

3.根据题意，身高相同的人并不会互相遮挡

```cpp
#include<iostream>
using namespace std;
long long st[10000000],n,top=1,ans,m;
int main()
{
    cin>>n;
    int a;
    cin>>st[1];//输入
    for(int i=2;i<=n;i++)
    {
        cin>>a;
        if(st[top]>a)
        {
            top++,ans++,st[top]=a;
        }
        else
        {
            int l=1,r=top;
            while(l<r)
            {
                m=(l+r)>>1;
                if(r==l+1)m=r;
                if(a>=st[m])r=m-1;
                else l=m;
            }
            ans+=top-l+1;
            while(top>0&&st[top]<a)top--;
            st[++top]=a;
        }
    }
    cout<<ans;//输出
}
```