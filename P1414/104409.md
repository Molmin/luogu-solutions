LZN大佬牛b！！！！（破音）

这一题要我们求有K个数时的最大公约数，我们很容易想到最大公约数也就是这K个数的公因数中最大的那一个。我们一开始便会想到先定义一个数组储存每个数作为因数出现的次数，然后便拿着一个个数去除于读入的每一个数。

如果你能想到这一步，那么10分还是能拿到的，但这题可是有21个点的。

这里我们要注意样例的最大数是1e6,假如我们头铁地拿所有的数去除是绝对要TLE的，毕竟可能会出现读入的所有数都是1e6的情况。

那我们转换一下策略，不列举从1到一个读入数据的所有整数，而是取一个特殊的数为界。易知这一个数由读入数据开方所得。

这里可能有人会有疑问（至少我一开始有），那些大于这个数的因数怎么办呢？别着急，我们来看下面这个代码
```
for (int i=1;i<=n;i++)
	{
		cin>>x;
		t=max(t,x);
		int m=sqrt(x);
		for (int i=1;i<=m;i++)
		{
			if (x%i==0)
			{
				c[i]++;
				if (x!=i*i) c[x/i]++;
			}
		}
	}
```

注意那个特殊判断的点。由于一个数等于他的一个因数除于另一个特定的因数，也就是说我们可以在得出一个因数的同时，得出另一个因数。在满足上述条件下，一个因数增大另一个因数也将随之减小，而到两因数相等时我们便能求出这个数所有的因数的数量了。

至于如何输出题目所需答案，我们只需记录下读入数据的最大数，然后逆序搜索C数组即可。（因为越大的数成为因数的次数绝对不可能大于小于他的数）

最后是期待已久的CODE 

```
#include<iostream>
#include<cstring>
#include<algorithm>
#include<cmath>
using namespace std;
int t=-1,n,c[1000010];
int main()
{
	int x;
	cin>>n;
	for (int i=1;i<=n;i++)
	{
		cin>>x;
		t=max(t,x);
		int m=sqrt(x);
		for (int i=1;i<=m;i++)
		{
			if (x%i==0)
			{
				c[i]++;
				if (x!=i*i) c[x/i]++;
			}
		}
	}
	for (int i=1;i<=n;i++)
	{
		while(c[t]<i) t--;
		cout<<t;
		if (i!=n) cout<<endl;
	}
	return 0;
}

```
