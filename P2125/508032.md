# 前言
当你刷到这一题的时候，你就应该意识到：

[本题贼多倍经验。](https://www.luogu.com.cn/discuss/475739)

# Solution

刚看到这道题的时候，我的想法是：第 $i$ 个书架给了上个书架 $a_i$ 本书（这个数值可以为负数）。

然后我寻思着：这里一共只有 $n$ 个未知数，$n$ 个方程，应该直接就解出来了呀。

原来，其中有一个方程是会跟前面的方程是等价的。

所以这是一个有 $n$ 个未知数，$n-1$ 个方程的不定方程组。

我们所需要求出的就是 $\sum\limits_{i=1}^n|a_i|$ 的最小值。

## 具体做法

首先我们先随便给 $a_1$ 代入一个值，并且用这个值把其他的 $a_i$ 求出来。

具体求法见代码。

容易发现这些数当且仅当同时加或者减相同的值时候，方程仍成立。

那我们如何让结果 $\sum\limits_{i=1}^n|a_i|$ 最小化呢？

同样容易发现，当 $a_i$ 大多数是正数的时候，对所有的数减 $1$ 之后，结果变得更小。（因为大多数的绝对值减了 $1$，少部分绝对值加了 $1$。）反之，当 $a_i$ 大多数是负数的时候，对所有的数减 $1$ 之后，结果变得更大。

那么最小值就出来了：当 $a$ 数组中正数和负数一样多的时候，结果达到了最小。

（因为此时不管是增加或者减少，都只能让结果变得更大。）

同时，因为所有数只能同加同减相同的值，所以说这些数的大小顺序其实是固定的。

那么什么时候正数和负数一样多呢？

~~C位出道的~~中位数闪亮登场！

没错，**当中位数正好被调整为0的时候，数组内正数和负数一样多，答案达到最小。**

所以我们只需要模拟一下以上的调整过程，时间复杂度 $O(n)$，就可以了。

这其中我们需要求中位数。~~方法一是使用 STL，~~ 方法二是先排一遍序，再找到中位数，时间复杂度 $O(n\text{log}n)$，方法三是使用快速排序的二分思想，平均时间复杂度 $O(n)$。

~~但是以本题的数据大小方法二就已经够用了，不需要再写一大串代码。~~

于是这道题就做出来了。

记得去补上上面的多倍经验！

**温馨提示：对于学习 OI 来说多倍经验不是最重要的，学到知识才重要。**

# AC code
~~（注：加上快读可以获得一个本题最优解）~~
```cpp
#include<bits/stdc++.h>
using namespace std;
namespace IO{
	char ibuf[(1<<20)+1],*iS,*iT;
	#if ONLINE_JUDGE
	#define gh() (iS==iT?iT=(iS=ibuf)+fread(ibuf,1,(1<<20)+1,stdin),(iS==iT?EOF:*iS++):*iS++)
 	#else
	#define gh() getchar()
	#endif
	#define reg register
	inline long long read(){
		reg char ch=gh();
		reg long long x=0;
		reg char t=0;
		while(ch<'0'||ch>'9')   t|=ch=='-',ch=gh();
		while(ch>='0'&&ch<='9') x=x*10+(ch^48),ch=gh();
		return t?-x:x;
	}
}
using IO::read;
long long n,i,j,b[5555555],p[5555555],q[5555555],av,an,ans;
int main()
{
	n=read();
	for(i=1;i<=n;i++)
	{
		b[i]=read();
		av+=b[i];
	}
	av/=n;
	p[1]=1;//此处便是上文所说的“随便代一个值”。
	for(i=2;i<=n;i++)
	{
		q[i]=p[i]=av-(b[i-1]-p[i-1]);//就是这里
	}
	sort(q+1,q+n+1);
	an=q[(n+1)/2];
	for(i=1;i<=n;i++)
	{
		p[i]-=an;
		ans+=abs(p[i]);
	}
	cout<<ans<<endl;
	p[n+1]=p[1];
	for(i=1;i<=n;i++)
	{
		printf("%lld %lld\n",p[i],-p[i+1]);
	}
	return 0;
}
```
