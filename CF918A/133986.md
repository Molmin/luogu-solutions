# 近似于指针的解法
首先这是斐波那契数列，那么我们可以马上得到公式：
![](https://cdn.luogu.com.cn/upload/pic/53227.png)
而且这道题不用考虑n==0的情况，所以我想到了一种方法：

我们都知道，**斐波那契数列由前两个斐波那契数相加而成**，那么我们可以**保存两个斐波那契数**，一旦查找到一个斐波那契数，输出O且替换，不是则输出o。

重点是：**这个代码可以边判断边输出，时间复杂度挺低的！！！**

所以我们可以把它理解成下面的数组和指针：
| 1 | 2 | 3 | 4 | 5 |6  | 7 | 8 | 9 | 10 |
| -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: |
| 1 | 1 | ？ |？  | ？ |？  |？  |？  |？  | ？ |
| a | b |  |  |  |  |  |  |  |  |

当循环数组运行到3时,根据算法可以变成:
| 1 |  2| 3 |4  | 5 |6  | 7 |  8|9  | 10 |
| -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: |
| 1 | 1 |1  | ？ |？  |？  |？  |？  |？  |？  |
|  | b |a  |  |  |  |  |  |  |  |
**所以此处a和b可以理解成指针！！！**


那么就有了代码：
```cpp
#include <iostream>
using namespace std;
int main(){
	int i,j,k,n;
	int a=1,b=2;//此处我保留1和2，因为n>=2以后就可以按照规律，且比较指针数越小越好
	cin>>n;
	for(i=1;i<=n;i++){
		if(i==1||i==2)cout<<"O";//1，2可以跳过判断
		else{
			if(a+b==i){//如果是斐波那契数
				cout<<"O";
				if(a<b)a=i;
				else b=i;//判断谁小一点，小的变大的
			}
			else cout<<"o";//不是斐波那契数，输出
		}
	}
	return 0;//程序结束
}
```
