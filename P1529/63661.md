竟然没有人用Floyd，本蒟蒻赶紧来水一发。

这题的数据看上去很大，但实际上完全没有什么用，因为题目已经说了，只有 2*26-1=51个牧场和一个谷仓，总共就52个点，同时有要求找所有点到谷仓的最短距离，很自然就会想到Floyd了。（当然也可以以谷仓为原点，找离谷仓最近的点，但Floyd好写不是吗）

主要思路：用点的ASCII码来代替他们的下标，这样就可以用一个二维数组表示点到点的距离，因为'Z'到'a'之间有一些乱字符，但并不碍事，把初始值附好就可以了，这样最多也就是70个以下了。

具体实现：见代码
```_ 
#include<iostream>
using namespace std;
char a,b;
int w[101][101],m,i,j,k,x,p,minn=1e7,q,n=70;//打惯了从一到n，懒得改
int main(){
	cin>>p;
	for (i=1; i<=100; i++)
	  for (j=1; j<=100; j++) w[i][j]=1e7;
	for (i=1; i<=p; i++){
		cin>>a>>b>>x;
		w[b-'A'+1][a-'A'+1]=w[a-'A'+1][b-'A'+1]=min(w[a-'A'+1][b-'A'+1],x);//直接用字符表示下表就好了，懒得再开一个变量
	}
	for (k=1; k<=n; k++)//弗洛伊德算法主题，肯定轮不到我来讲
	  for (i=1; i<=n; i++)
	    for (j=1; j<=n; j++)
	      w[i][j]=min(w[i][j],w[i][k]+w[k][j]);
	for (i=1; i<=25; i++)//注意一定只能到25
	    if (w[i][26]<minn){minn=w[i][26]; q=i;}
	cout<<(char)(q+'A'-1)<<' '<<w[q][26];
	return 0;
}```