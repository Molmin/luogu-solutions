这里是出题人官方题解。

### 超级大暴力

我们先考虑暴力咋做，首先我们可以把 $b$ 序列重编个号，设 $dp(i)$ 代表以下标 $i$ 结尾的最长优美序列长度。则有个很显然的 dp：

$$
dp(i)=\max_{j=1}^{i-1}dp(j)+1\ (a_i=a_j+1).
$$

直接 $O(qn^2)$ 搞就行。

### 大暴力

这东西显然满足单调性，我们记录 $lst(i)$ 代表最后一次出现值 $i$ 的下标：

$$
dp(i)=dp(lst(a_i))+1\\
lst(a_i)=i.
$$

即可优化为 $O(qn)$。

### 暴力

我们发现，假如你当前处理的区间是 $[l,r]$，询问的区间是 $[l,r+1]$，我们可以根据当前的 $dp$ 值和 $lst$ 值很方便地转移到询问区间。但是如果询问的区间是 $[l+1,r]$，处理起来就有点麻烦了。你发现这玩意就是回滚莫队的套路，直接拿回滚莫队做就行，复杂度 $O(n \sqrt n)$。

### 正解

我们可以用类似莫队的思想，写一个支持在线的算法。

考虑分块，我们把序列分成 $\sqrt n$ 个块。预处理出询问第 $l$ 个整块到第 $r$ 个整块的答案 $preans(l,r)$，询问后 $r$ 个整块的 dp 数组 $pref(r,i)$。

同时，我们把那个 dp 反过来，设 $dp'(i)$ 为以下标 $i$ 开头的最长优美序列长度，转移式就会变成这样：
$$
dp'(i)=\max_{j=i+1}^n dp(j)+1\ (a_i=a_j-1).
$$
同样优化一下，用这个反过来的 dp 预处理出询问前 $l$ 个块的反向 dp 数组 $preg(l,i)$。

询问的时候分两种情况，当询问区间长度 $\le 2\sqrt n$ 时直接暴力做。否则我们采用一个最接近的整块 $[bl_l,bl_r]$ 作为初始区间，然后先向右，再向左扩展区间。

向右扩展时，我们发现贡献来自两处：

- 整块到右散块的贡献；
- 右散块中一个元素到另一个元素的贡献。

对于第一种，我们直接用预处理出来的 $pref(bl_l,i)$ 来查询即可。对于第二种，直接在向右扩展时顺便记录一下即可。

向左扩展时，我们发现贡献来自三处：

- 左散块到整块的贡献；
- 左散块中一个元素到另一个元素的贡献。
- 左散块到右散块的贡献。

对于前两种，处理起来和右散块基本一致，麻烦就在于最后一种，这里有一个很方便的解决方法：在移动左右端点的同时，维护一个数组 $f(i)$ 代表以**值** $i$ 开头的最长优美序列长度，则移动右端点至 $i$ 时，有如下转移：
$$
f(a_i-pref(bl_l,i)+1) = \max\{f(a_i-pref(bl_l,i)+1),pref(bl_l,i)\}.
$$
移动左端点至 $i$ 时，有如下转移：
$$
f(a_i)=\max\{f(a_i),preg(bl_r,i),f(a_i+1)+1\}.
$$
这个式子很好理解，大括号里的三个元素分别对应三处不同的贡献位置。

需要强调的一点是，输出答案后，不要用 `memset` 清空 $f$ 数组，要手动记录用过的下标清零。

至此，我们以时间 $O((n+q)\sqrt n)$，空间 $O(n\sqrt n)$ 的复杂度，解决了这个问题。