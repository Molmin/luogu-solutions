# CF777C 题解

可以看出，本题可以用各种 STL 容器做，但蒟蒻的我选择了数组。。。

### 本题的数据可以用三个数组来存储，不需要二维数组。其中具体分析如下：
1.从上到下非递减，即上面的数不大于下面的数。
为了适应第2点的说法，可以转换为“非递增”。

2.用二维数组大概率会爆掉，所以用一维数组  _**$a$**_  来存储**每一行的数**
，从后往前推，用一维数组  **_$b$_**  来存储每一列的数能到达的最前面的一行，在用  _**$c$**_  来存储每一行的数能到达的最前面的一行

3.最后只需要**比较 $ c[i] $ 与 $ l $ 的大小**即可。

值得注意的是，可以通过把二维数组的“ _超大空间_ ”和“ _超大时间复杂度_ ”转换成一位数组，来 A 这道题（**千万不要忘记初始化**）。其实大致的思路类似于前缀和等的预处理，以减小时间复杂度

不知道还有没有其它 $ nm $ 的算法可以过，希望各位大佬指出，并指正本人的算法。
以下是我的代码：
```cpp
//注释中的"到达"，都是指:最长的非递增的位置 
#include<iostream>
using namespace std;
const int N=1e5+5; 
int a[N],b[N],c[N]; //a存数据,用一维做不会爆
//b存每一列数到的最远的一行 
//c存每一行数到的最远的一行,即max 
int main(){
    int n,m,x;
    scanf("%d%d",&n,&m);
    for(int i=1;i<=m;i++)//能到的最远的一行是第一行。
        b[i]=1;
    for(int i=1;i<=n;i++){
        c[i]=i;    //每个数都能到达所在的行(init)。
        for(int j=1;j<=m;j++){
            scanf("%d",&x);
            if(x<a[j])//如果x上面的数比x大，则不是非递增的，所以x不能到达上一行。
                b[j]=i;
                
            a[j]=x; //save
            if(b[j]<c[i])
            	c[i]=b[j]; //找每一列能到达的最前面的行。
        }
    }
    int k,l,r;
    scanf("%d",&k);
    while(k--){
        scanf("%d%d",&l,&r);
        if(c[r]<=l)	printf("Yes\n");
        else	printf("No\n");
    }
    return 0;
}
```
