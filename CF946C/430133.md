### CF946 题解

#### 思路分析

简单字符串题。

首先，我们要变成一个包含从 a 到 z 的所有字母的字符串。而且变换方式是”位移“。

那么显然，我们从前往后一定要依次包含能通过”位移“变成从 a 到 z 的字符。什么字符可以满足呢？根据题意，只要不超过目标字符的字母表位序（其实就是 ASCII 码）的字母都可以满足。于是我们逐个目标的待变换字符确定即可。

现在实现有个难点：怎么才能“依次”‘？我们每次找到一个变换字符后，将确定范围缩小至该字符之后就可以。注意一个细节：每次应查找位置靠前的变换字符，这样才能把更多的机会留给后面的待变换字符。进而保证：如果按此方式找不到，那么就无解。

实现方式较多，题解区已经有大佬讲过按字符串位置逐位枚举的方法了，我就选用按目标字符来枚举的方法。

#### 关键代码

```cpp
for(char i = 'a';i <= 'z';i++) //按目标字符来枚举
{
	bool yes = false; //有无解
	int cur = 0; //变换下标，便于缩小范围。
	for(int j = p;j < s.size();j++)
	{
		if(s[j] <= i) //只要不超过目标字符的字母表位序（其实就是 ASCII 码）的字母都可以满足。
		{
			cur = j; //记录变换位置，便于缩小范围。
			s[cur] = i; //变换字符。
			yes = true; //记录有解。
			break; //找到一个立即 break，保证最小。
		}
	}
	if(!yes) //无解
	{
		cout << -1;
		return 0;
	}
	p = cur + 1; //缩小范围至该字符之后。
}
```

