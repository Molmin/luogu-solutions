## 理论分析：

>第 $i$ 回合中取走的石子数量 $s_i$ 必须整除 $s_{i+1}$。

即 $s_{i+1}$ 是 $s_i$ 的倍数。

枚举 $s_1$，假设每次都只取 $s_1$ 个石子，则第 $i$ 堆需要取 $\lfloor \frac{a_i}{s_1}\rfloor$ 次。

这是一道博弈论的题，所以我们先要考虑满足何种性质是后手必胜态，这样就可以将问题转化为：

>给定原始序列，求进行一次操作后使序列转化为后手必胜态的方案数

不难发现，如果序列中，每种数字都出现了偶数次，一定后手必胜。

因为后手只需要在先手操作完后对数目相同的另一个数做同样的操作，就一定能保证到最后是后手取走最后一颗石子。这样我们就有了初步的后手必胜态。

但我们很容易找出一组数据不满足上述性质，同时也能使后手必胜：$s_1=2,A=\{2,3,4,4,6,6\}$。

对于 ‘4’和‘6’，我们采取刚刚的后手必胜态。

对于‘2’和‘3’，当先手取‘2’时，后手取‘3’，此时‘3’变为‘1’，因为‘1’是取不到的，所以后手胜。反之先手取‘3’也是一样的道理。因此后手必胜。

为什么‘2’和‘3’可以组成一对呢？这是因为他们的可取次数（$\lfloor \frac{a_i}{s_1}\rfloor$）相同，我们用一个集合来表示每个数的可取次数：$cnt=\{1,1,2,2,3,3\}$。

显然，可取次数相同的可以组成一对，所以我们的后手必胜态就可以更新为：

>每种可取次数均出现偶数次

我们定义一个数组 $X$。

$X_i$ 表示可取次数为 $i$ 的堆数。

当满足

$$\sum_{i=1}^{tot} X_i \% 2=0 \text{（tot表示最大的可取次数）}$$

时，后手必胜。

成功找出后手必胜态后，我们考虑如何进行一次操作，使序列转化为后手必胜态。

第一回合操作，意味着在集合 $cnt$ 中选择一个元素 $p$，使 $p$ 变为 $p-1$。同时 `X[p]++,X[p-1]--`。

也就是说，第一回合的操作只对相邻两个 $X$ 产生影响，那么当有三种及以上可取次数出现奇数次时，我们一定无法保证一次操作后 $\sum_{i=1}^{tot} X_i \% 2=0$。

当有一种可取次数 $X_i$ 出现奇数次时：

- 如果 $X_i>1$ 

  - 对 $X_i$ 操作会使 $X_{i-1}$ 出现奇数次，先手必败。
  - 对除 $X_i$ 以外的数 $X_j$ 操作会使 $X_j$ 出现奇数次，先手必败。
- 如果 $X_i=1$。对 $X_i$ 操作满足条件，先手必胜方案数为 $X_1$。

当有两种可取次数 $X_i$ 出现奇数次时，当且仅当两种可取次数相邻时有解，若 $X_{p} \% 2=1$，且 $X_{p-1} \% 2=1$，则方案数是 $X_p$。

理论有了，如何实现？

## 实现方法

对于每一个 $s_1$ 显然我们不能枚举出它的 $cnt$ 集合，那样的时间复杂度是无法通过本题的。

我们考虑如何快速求出 $X$ 。

当一堆石子的个数 $a_i \in [q \cdot s_1,(q+1) \cdot s_1 )$ 时，这堆石子的可取次数一定为 $q$。

有了这个结论，我们就可以用前缀和的方法预处理出石子数小于等于 $i$ 的堆数。

这样，我们就有`x[j]=sum[min((j+1)*i-1,m)]-sum[j*i-1];`

至此，我们就能写出解决此题的完整代码啦。

### Code

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
int n,a[100010];
ll sum[1000010],x[1000010],ans;
//a原始序列 
//sum[i] 表示石子数小于等于i的堆数 
//x[i] 表示可取次数为i的堆数 
int m=0;//最大一堆的石子个数 
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
		sum[a[i]]++;
		m=max(m,a[i]);
	}
	for(int i=1;i<=m;i++) sum[i]+=sum[i-1];
		
	for(int i=1;i<=m;i++){
		int tot=m/i;//当 s1=i 时，最大的所需操作次数 
		ll cnt=0;
		
		for(int j=1;j<=tot;j++){
			x[j]=sum[min((j+1)*i-1,m)]-sum[j*i-1];
		}
		for(int j=1;j<=tot;j++) cnt+=x[j]%2;
		
		if(cnt>2||cnt==0) continue;
		if(cnt==1) {
			if(x[1]%2) ans+=x[1];
		} else if(cnt==2) {
			for(int j=2;j<=tot;j++)
				if((x[j]%2)&&(x[j-1]%2)) ans+=x[j];
		}
	}
	cout<<ans;
} 
```