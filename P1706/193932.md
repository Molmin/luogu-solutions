**本文将会用for循环、递归讲解如何生成全排列**

刚看到全排列的时候可能会有一种不知道怎么生成的感觉，我们先观察下[1 2 3] 的全排列：
```cpp
    1    2    3
    1    3    2
    2    1    3
    2    3    1
    3    1    2
    3    2    1
```

首先一个很明显的规律，**递增**，我们很容易的就能想到枚举每一位的数字，最后就可以判断一下是否有重复了，我们先写一个[1,2,3]的实现，

```cpp
#include<stdio.h>
int main() {
//用for循环模拟显然是递增的
  for(int i = 1; i <= 3; i++) {
    for(int j = 1; j <= 3; j++) {
      for(int k = 1; k <= 3; k++) {
        if(i != j && i != k && j != k) {//判断出现的数字是否相同，不相同则输出
          printf("%d %d %d\n", i, j, k);
        }
      }
    }
  }
}
```
然后这题就做完了！
等等，题目要求是求任意的长度的全排列呀，难道每种长度我都要写一个吗？？？
其实动动脑筋的话可以把枚举改变一下，观察上面的for循环。如果把i，j，k当成百位，十位，个位来看的话：111,112,113,121,122......
不就是自然数的增加嘛，只不过把一些不可能的数字去掉了，那我们换一种枚举方式吧！枚举自然数，再把每一位取出来比较是否是恰好是[1-n]
对于一个n，它的下界是 $10^n$ 上界是$10^{n+1} -1$,这里可以用到pow函数，取它的每一位的话可以用一个数组来保存，最后判断是否满足条件的话可以使用一个技巧，用一个数组来记录它出现的次数，如果数字i出现了，则b[i]++，最后只需要检查一下b数组里面是否都是1就可以了。
但是，上午测试的时候TLE了很多次。要加一些剪枝才可以，首先l = 123..n， r = n..321
然后遇到0的话我们就直接跳过一大段。（还得开O2优化）看代码吧

```cpp
#include<stdio.h>
int b[11], c[11], a[11]; //a数组用于剪枝， b数组用于记录数字出现的次数，c数组用于存各个位的数字 
int main() {
  a[0] = 1;
  int l = 0, r = 0, n;//上界与下界
  scanf("%d", &n);
  for(int i = 1; i <= n; i++) l = l * 10 + i, r = r * 10 + (n - i + 1), a[i] = a[i-1] * 10;
  for(register int i = l, j, flag, cnt; i <= r; i++) { 
    j = i, flag = 1, cnt = 0;
    while(j) { 
      if(j % 10 > n) break;//某位大于n则直接退出 
      if(j % 10 == 0) j++, i += a[cnt];//某位为0则直接跳过一大段例如 200000，直接改为211111，主要剪枝 
      b[j%10]++;
      c[cnt++] = j % 10;
      j /= 10;      
    } 
    //判断每位数字是否只出现了一次，顺便刷新b数组 
    for(j = 1; j <= n; j++) { 
      if(b[j] != 1) { 
        flag = 0;
      } 
      b[j] = 0;
    } 
    if(flag) {  //打印输出，记住是逆序 
      for(int j = n-1; j >= 0; j--) printf("%5d", c[j]);
      puts("");
    }  
  } 
} 
```

上面的为两个for循环的做法。第一种算法要针对不同的n来写判断条件。所以特别的长。。.那么能换一种写法吗，之所以我们要针对不同的n来写，不正是因为我们无法动态的添加for循环吗？那么我们可以通过函数的递归来实现这种动态的添加for循环吧，稍微思考一下。首先我们要怎么知道各层函数是哪个for循环呢？简单，用个参数来控制；

```cpp
void dfs(int num);//num代表我是第几次调用这个函数，也就是当前在第几个for循环中；
```
然后里面要写什么呢？递归一定要有的两部分：自身调用，终止条件。啥时候终止呢？不就是当层数为n+1的时候吗？（因为前面的n个函数都是在枚举）那我们来完善一下

```cpp
int n, a[10];//n代表层数，a数组用于存各层的枚举的数
void dfs(int num) {
  if(num == n + 1) {
    for(int i = 1; i <= n; i++) {//判断是否有相等的数，若有则直接退出，反之则输出；
      for(int j = i + 1; j <= n; j++) {
        if(a[i] == a[j]) return ;
      } 
    }
    for(int i = 1; i <= n; i++) 
      printf("%5d", a[i]);
    printf("\n");
    return ;
  }
  for(int i = 1; i <= n; i++) {
    a[num] = i;
    dfs(num+1);
  }
}

```
~~经过第二种for循环写法的洗礼我们应该自然的想到优化优化代码。。~~ 一个很显然的优化，如果我们发现这个数前面几层已经用过，那么我们能不能直接跳过呢？怎么实现呢？？思考一下我们前面所用的判断方法

> 用一个数组来记录它出现的次数，如果数字i出现了，则b[i]++，最后只需要检查一下b数组里面是否都是1就可以了。

我们可以稍微改一下，如果当前的枚举的是 i，它的 b[i] 已经为1了那我们就直接跳过吧，如果不为1我们就去标记一下。具体实现：

```cpp
void dfs(int num) {
  if(num == n + 1) {
    for(int i = 1; i <= n; i++) 
      printf("%5d", a[i]);
    printf("\n");
    return ;
  }
  for(int i = 1; i <= n; i++) {
    if(b[i]) continue;//如果出现过则直接跳过
    b[i] = 1;//没有使用过那就标记一下吧。
    a[num] = i;
    dfs(num+1);
    b[i] = 0;//使用完之后清空哦
  }
}
```
那么全排列问题到这里就结束了。c++ STL库里也有全排列函数 next_permutation() 具体咋用大家就翻翻别的题解吧0.0 ~~虽然我也是用STL过的~~ 

若有问题希望各位dalao能指出


