```cpp
#include<iostream>
#include<cstdio>//由于后面要用到printf来保留5个常宽，所以用这个头文件
using namespace std;
int a[10],book[10],n;//a[10]用来存放数值；book[10]有很重要的作用，用来标记哪些数已经用过
void dfs(int step)//不用返回值，用void类型
{
    int i;
    if(step==n+1)//如果已经搜索到n+1,那么已经搜索完毕，打印全排列
    {
        for(i=1;i<=n;i++)
        printf("%5d",a[i]);//用循环读入数据，其中注意题目要求保留5个常宽，这个功能用cout语句难以做到
        cout<<endl;//每输出一种全排列，按题目要求，注意换行
        return;//返回原来dfs的那一步，再次开始（深搜标准格式）
    }
    for(i=1;i<=n;i++)//注意这两个循环不同，这个用来搜索（尝试每一种可能）
    {
        if(book[i]==0)//book数组用来标记，如果未被标记，证明这个数还没用
        {
            a[step]=i;//将这个数存入数组
            book[i]=1;//标记这个数已用过
            dfs(step+1);//用递归，再次进入函数（注意不是循环），进入下一次的全排列判断；如果排列完毕（也就是到达边界），那么就会执行上面的输出
            book[i]=0;//注意此处一定要清零，然后进入下一次的函数，如果不清零，那么下一次输出全排列时，所有的数都被标记过，将无法输出
        }
    }
    return;//深搜最后一定要退出函数，否则会永无止境的执行函数，导致程序爆炸
}
int main()
{
    cin>>n;
    dfs(1);//使用dfs函数，从1开始
    return 0;
}
```
/\*附上深搜一般格式：
void dfs(int n)

  {
判断边界，如果已经到边界，返回，退出函数（有时需要打印数据）

尝试每一种可能 for(i=1;i<=n;i++)

    {
函数体；

继续下一步  dfs(n+1)

    }
返回 return;

  }
\*/