
# 算法解析

### DFS，对楼上的回溯+剪枝进行详解。

我们以N=3为例，构造一棵搜索树（或说是状态树）来进行搜索。

同时构造出三个格子，用来存放搜索树中的结果。

现在，我们从第一格开始搜索。第一格填1的搜索树如下：

所以N=3的情况下，第一格填1的排列情况共有两种123,132.

第一格填2的搜索树如下：

所以N=3的情况下，第一格填2的排列情况共有两种 213,231.

如果你看懂了，请你自己画画第一格填3的搜索树。

程序实现

我们总结一下在上一部分中的思路在程序中如何实现。

先定义两个数组，一个是用来存放解的，一个是用来标记该数是否用过。

我们可以先写一个用于打印的函数print()，每当深搜时找到一个符合条件的解时，则print()一下，输出这个解（注意题目输出要求）。

接下来就是写深搜的函数了。主要思路：先判断格子是否填满了，如果填满，则print()一下。

如果没有填满，则开始循环，在循环中先判断当前填的数是否用过，如果没有，则填入，搜索下一格。

程序实现如下：```

```

