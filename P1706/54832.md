
这是一道DFS的基础题
比较直端的想法是将当前用了几个数，每个数是都已经被使用作为状态进行搜索。
因为要求字典徐从小到大，所以在搜索的每一层中，我们都从小到大枚举当前选择哪个数
时间复杂度为O（n！）   n！为n的阶乘

代码如下，有注释！



**请不要抄**
```cpp


#include<bits/stdc++.h> 
using namespace std;
int n;
int ans[15];//保存当前的方案
int use[15];//表示每个数是否被用过
void dfs(int x){//X表示当前搜索到那个数
	if(x>n){//如果N位都搜索完了，就输出方案并返回
		for(int i=1;i<=n;i++)
			printf("% 5d",ans[i]);//输出方案 
		puts("");
		return;
	}
	for(int i=1;i<=n;i++)//从小到大枚举
	if(!use[i]){//判断这个数是否用过
		ans[x]=i;//保存到方案中
		use[i]=1;//标记这个数被使用了
		dfs(x+1);//进行下一步搜索
		use[i]=0;//撤销标记
	}
}
int main()
{
	
	scanf("%d",&n);//输入
	dfs(1);//从第一个数开始搜索；
}

```

如有错误，希望大佬们多多指教