/\*
P1706 题解

深度优先搜索

\*/
/\*
再给出代码之前，我们可以先看一看3的全排列：

1    2    3

1    3    2

2    1    3

2    3    1

3    1    2

3    2    1

我们可以观察一下，第一个数先是1，再是2，最后才是3，你会发现，后面也是这样的，思想：

我们可以先看一看第一位还有那些数字没有用过，我们就将这个数放到这一位上（即a[x]=i，x表示当前要选一个数放在第x位上），并标记一下b[i]为1（即表示i这个数字已经用过了），然后继续去下一位搜索，然后再将b[i]标记为0即可，然后，如果这个x刚好等于n+1，那么就表示已经做完了整个过程了，可以输出答案了。

再提供一下2和4的全排列（注意观察）：

2的全排列：

1    2
2    1
4的全排列：

1    2    3    4

1    2    4    3

1    3    2    4

1    3    4    2

1    4    2    3

1    4    3    2

2    1    3    4

2    1    4    3

2    3    1    4

2    3    4    1

2    4    1    3

2    4    3    1

3    1    2    4

3    1    4    2

3    2    1    4

3    2    4    1

3    4    1    2

3    4    2    1

4    1    2    3

4    1    3    2

4    2    1    3

4    2    3    1

4    3    1    2

4    3    2    1

以下就是代码部分了：

\*/
```cpp
#include <cstdio>//头文件
int a[10001],b[10001];//定义数组，a数组是用来存数的，b数组是用来表示这个数有没有被用过的
int n=0;//定义变量，n表示的是要求的是从1到n的全排列
void dfs(int x)//深度优先搜索（x表示的是当前要存储的是第x个数，即a[x]）
{
    if(x==n+1)//如果全部都做完了（请想一下为什么要写成x==n+1，而不是x==n）
    {
        for(int i=1;i<=n;i++)//输出这n个数
        {
            printf("%5d",a[i]);//输出第i个数（即a[i]）
        }
        printf("\n");//输出换行
        return ;//结束该函数
    }
    for(int i=1;i<=n;i++)//从1~n进行循环选数
    {
        if(b[i]==0)//如果这个数没有用过
        {
            a[x]=i;//存一下数
            b[i]=1;//标记一下这个数i已经用过了
            dfs(x+1);//继续去下一个位置搜索
            a[x]=0;//清零（也可以不写这句话）
            b[i]=0;//标记一下这个数i还没有用过
        }
    }
}
int main()//主函数
{
    scanf("%d",&n);//输入n（表示接下来要求的是从1到n的全排列）
    dfs(1);//从第一个位置开始搜索（即从第一个位置开始选数）
    return 0;//结束程序
}
```