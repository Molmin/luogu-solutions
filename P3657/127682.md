一开始没想明白这道题，所以力求让大家看明白这篇题解。

如果暴力的 $dp$ 转移，相信大家都早已会求， 设 $dp[i][j]$ 为 $i$ 和 $j$ 是最后一组相连的情况下，最多的牛行道条数。

但我们为什么要这么设，为什么不能设  $dp[i][j]$ 为左边到 $i$ 为止，右边到 $j$ 为止，最多的牛行道条数呢？

我们都知道，一般状态有两种设法：以 $i$ 为止和必选 $i$。一般必选 $i$ 中后面的转移都要需要上一个的状态。比如最长上升子序列转移的时候每个数都要比前面大，想要知道上个数是什么，就以必选 $i$ 为状态设计。而如背包问题等，选不选当前的并不需要上一个物品状态，就设以什么为止。

但以 $i$ 为止虽然可以做这道题，但无法再优化下去了，因为我们只能从相邻状态 $i-1$ 或 $j-1$ 转移来。复杂度会爆炸。

所以设 $dp[i][j]$ 为 $i$ 和 $j$ 是最后一组相连的情况下，最多的牛行道条数。则 $dp[i][j] = max(dp[x][y]+1)(x < i, y < j) $ 并且 $i,j$ 的编号相差不过 $4$ 。

这时候我们要快速求出所有 $(x < i, y < j)$ 中 $dp[x][y]$ 的最大值。可以用树状数组的维护。我们用 $getmax(j-1)$ 这个前缀最大来维护所有 $y < j$ 的最大 $dp[i][j]$ 值。对于每一个新求出来的 $dp[i][j]$ 值，只需要 $modify(j,dp[i][j])$ ， 将 $j$ 这个位置的值更新一遍取个大即可。

那如何保证 $x < i$ 呢？很简单：我们第一层循环按 $i$ 来枚举，那我们已经 $modify$ 过的 $dp$ 值就只有可能是小于当前 $i$ 值的。所以直接按上面一段操作即可。