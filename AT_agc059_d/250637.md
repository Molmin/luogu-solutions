对于题目所述的序列 $A$，按如下方法构造序列 $L$ 和 $R$，长度均与 $A$ 相同：当 $A_{[\max\{i-k,0\}+1,i-1]}$ 中有与 $A_i$ 相同的数时候 $L_i=1$，否则 $L_i=0$；$R_i$ 同理，但区间是 $A_{[i+1,\min\{i,n\}+k-1]}$。

现在我们对 $L$ 与 $R$ 序列作出一些论断：

+ 对于 $1\le i\lt n$，考虑 $A_{[i+1,i+k-1]}$ 中不同数的个数，分别向这个区间的左边和右边延展一位然后回撤贡献，得到 $B_i-(1-R_i)=B_{i+1}-(1-L_{i+k})$。将这个式子变形一下，得到 $L_{i+k}-R_i=B_i-B_{i+1}$。

+ 考察每个数对 $B_1$ 的贡献，得到 $\sum_{i=1}^k(1-L_i)$。简单变形得到 $B_1=k-\sum_{i=1}^kL_i$。同理 $B_n=k-\sum_{i=1}^kR_{n+i-1}$。

但这些性质显然是不够的，我们考虑改变 $L$ 的刻画：一个数与它从左到右上一次出现的位置之差小于 $k$。如此，我们考虑对于给定的数，把它所有出现位置排成一列（避免边界情况可以假设列之起始有一个 $-\infty$），可以发现当且仅当位置列中相邻两个数的差小于 $k$ 的时候，相邻位置中靠右的那一个的 $L$ 值会被赋为一。同理我们考虑 $R$，会发现和 $L$ 的赋一几乎完全一致，除了赋的是相邻位置中靠左的那一个。这样我们可以推出一点更多的性质：

+ 把所有 $R_i=1$ 的 $i$ 从左到右排成一列，记为 $X_1,X_2,\cdots,X_t$；把所有 $L_i=1$ 的 $i$ 从左到右排成一列，记为 $Y_1,X_2,\cdots,Y_t$（注意到 $L$ 和 $R$ 出现一的次数是相等的，上一段足以说明这一点）。那么有 $1\le Y_i-X_i\lt k$。

这个性质其实包含了两个不等式： $Y_i\gt X_i$ 和 $Y_i\lt X_i+k$。前者是因为每个 $Y$ 都对应有一个更小的 $X$，若 $Y_i\le X_i$ 那么一定有 $i$ 个 $X_j$ 小于 $X_i$ 导出矛盾。后者是类似的，考虑 $X_i+k$ 去对应 $Y$ 即可。

现在，对于给定的 $B$，如果我们能在上面几条约束下找到合法的 $L,R$ 两个序列，那么事实上构造 $A$ 将是相当容易的。从左到右扫一遍，如果 $L_i=0$ 那就随便甩一个没用过的权值上去，否则 $i=Y_j$ 一定对某个 $j$ 成立，赋 $A_i$ 为 $A_{X_j}$ 即可。注意我们这里强制规定了 $L_i$ 和 $R_i$ 对应，这是无伤大雅的，因为我们可以证明这样的 $A$ 重算 $L,R$ 序列一定是我们用来构造 $A$ 的这一组，进而通过前两条约束一定可以反推出正确的 $B$。

我们考虑如何在 $B$ 的约数下构造出符合条件的 $L$ 和 $R$。注意 $L_{i+k}-R_i=B_i-B_{i+1}$ 这一性质，如果 $B_i\not=B_{i+1}$ 那么我们一定可以唯一确定 $L_{i+k}$ 和 $R_i$（考虑到这俩值域是 $\{0,1\}$ 而且我们知道它们的差非零）。否则，如果 $B_i=B_{i+1}=k$，那我们会意识到 $A_{[i+1,i+k-1]}$ 中不同数至多 $k-1$ 个，进而 $L_{i+k}=R_{i}=0$。否则我们就会面临一个选择：把这俩都赋值为零或者都赋值为一。但实际上，我们接下来可以证明：遇到这种情况，只要全部选赋一，一定是更加可行的。

为了证明这一点，我们现在可以不妨假设已经构造出了一组合法的 $L$ 和 $R$，并且有 $i$ 满足 $B_i\not=k$ 且 $L_{i+k}=R_i=0$。我们把 $L_{i+k}$ 与 $R_i$ 均重赋值为一。考虑到 $B_i\not=k$，我们得知 $L_{[i+1,i+k-1]}$ 中一定有一，而 $R_{[i+1,i+k-1]}$ 中一定也有一，而且它们是配对的。我们将 $i$ 插入 $X$ 序列并将 $i+k$ 插入 $Y$ 序列。我们注意到，$i$ 将匹配的值在 $[i+1,i+k-1]$ 之间且 $i+k$ 将匹配的值在 $[i+1,i+k-1]$ 之间。至于中间的 $X$ 和 $Y$，每个 $Y$ 将匹配更前的 $X$ 而每个 $X$ 将匹配更后的 $Y$，那么 $Y\gt X$ 依然成立；$i+1\le X,Y\le i+k-1$，那么 $Y-X\lt k$ 也依然成立。于是我们新得到的 $L,R$ 依然是合法的。

这时候我们发现这些约束对 $L$ 最开头的 $k$ 个元素没有效力。但我们观察到还有一条性质 $B_1=k-\sum_{i=1}^kL_i$，这其实告诉了我们 $L_{[1,k]}$ 中需要多少个一。为了更好地完成匹配，实际上我们只需要把所有一尽量往后塞就可以了。这样，$Y_i\gt X_i$ 能更好地完成，而 $Y_i\lt X_i+k$ 由于 $Y_i\le k$ 也一定依然成立。$R$ 同理，最后 $k$ 个元素的所有一尽量往前塞就好了。

由以上所述，我们已经可以构造出一个尽量合法的 $L$ 和 $R$。但是很遗憾，我们并不能完美证明它是合法的，所以我们需要再检查一下 $X$ 和 $Y$ 的合法性，如果没问题的话，就可以构造 $A$ 了。

代码比较好写。

```cpp
#include <bits/stdc++.h>
using namespace std;
constexpr int N = 2e5 + 9;
int t, n, k, a[N], b[N];
bool l[N << 1], r[N << 1];
bool calc() {
  memset(l + 1, false, b[1]);
  memset(l + b[1] + 1, true, k - b[1]);
  memset(r + n, true, k - b[n]);
  memset(r + n + k - b[n], false, b[n]);
  for (int i = 1; i < n; ++i) {
    int d = b[i] - b[i + 1];
    if (d == 1)
      l[i + k] = true, r[i] = false;
    else if (d == -1)
      l[i + k] = false, r[i] = true;
    else if (!d)
      l[i + k] = r[i] = b[i] < k;
    else
      return false;
  }
  vector<int> x, y;
  for (int i = 1; i < n + k; ++i) {
    if (r[i]) x.push_back(i);
    if (l[i]) y.push_back(i);
  }
  int t = x.size();
  if ((int)y.size() != t) return false;
  for (int i = 0; i < t; ++i)
    if (y[i] <= x[i] || y[i] >= x[i] + k) return false;
  int tot = 0;
  for (int i = 1, j = 0; i < n + k; ++i)
    if (!l[i])
      a[i] = ++tot;
    else
      a[i] = a[x[j++]];
  return true;
}
signed main() {
  cin.tie(nullptr)->sync_with_stdio(false);
  for (cin >> t; t; --t) {
    cin >> n >> k;
    for (int i = 1; i <= n; ++i) cin >> b[i];
    if (!calc())
      cout << "NO";
    else {
      cout << "YES" << '\n';
      copy_n(a + 1, n + k - 1, ostream_iterator<int>{cout, " "});
    }
    cout << '\n';
  }
  return cout << flush, 0;
}
```