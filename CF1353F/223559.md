### $\text{Difficulty : 2200}$
---
### 解题思路：


如果直接按照题目中给出的方式计算路径的代价会非常不方便，对其进行转化。

具体地考虑某一条路径，发现每一次的要求值都是在前一个的基础上增加 $1$ 形成的，由此可以考虑对于这条路径上第 $i$ 个走到的位置的权值减少 $i$，注意到题目只和相对值有关，在这一步中加入任何常数都是没有意义的。那么问题也就转化成了在更改之后的路径上选择一个数，使得差的绝对值最小且要求路径上的每一个点都不比这个值小。很明显这个值表示起点的修改之后的位置，且应当是修改后序列中最小的一个值。换言之，这个值一定出现在序列中。

由此拓展到矩阵，可以发现，每一个位置被经过时的位置是固定的，可以直接在矩阵上进行操作。而且，由于数据范围较小，可以直接枚举取定的初始值，并在接下来的过程中用 $\text{DP}$ 解决问题。

更具体的，设当前取出的初始值为 $x$，再设 $f_{i,j}$ 表示从 $(1,1)$ 到达 $(i,j)$ 的最小代价。每一个位置能且仅能从 $f_{i-1,j}$ 或者 $f_{i,j-1}$ 转移，每一次转移的代价即为 $a_{i,j}-i-j-x$，注意能够进行的操作只有减少，如果此值小于 $0$ 无法进行操作使其变成需要的值，需要跳过。

总复杂度为 $O(n^4)$，对于 $100$ 的数据范围而言可以接受。

---
### 代码：

```cpp
#include<cstdio>
#include<algorithm>
#define int long long
using namespace std;
int T,n,m,a[105][105],f[105][105],ans;
void work(int x){
	for(int i=0;i<=n;i++) 
	for(int j=0;j<=m;j++)
	f[i][j]=923372036854775808;
	f[0][1]=0;
	for(int i=1;i<=n;i++)
	for(int j=1;j<=m;j++){
		if(a[i][j]<x)continue;
		f[i][j]=min(f[i-1][j],f[i][j-1])+a[i][j]-x;
	}
	ans=min(ans,f[n][m]);
}
signed main(){
	scanf("%lld",&T);
	while(T--){
		ans=9223372036854775807;
		scanf("%lld%lld",&n,&m);
		for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++){
			scanf("%lld",&a[i][j]);
			a[i][j]-=i+j;
		}
		for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
		work(a[i][j]);
		printf("%lld\n",ans);
	}
	return 0;
}
```
