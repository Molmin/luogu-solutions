
好像所有题解都没有说明为什么可以把法术和跑步分开算，实际上是这样的，先用一个dp预处理出仅使用法术/休息的情况

#### f(i)=f(i-1)+60 (m>=10) 在这种情况下 m -= 10
#### f(i)=f(i-1) (m<10) 在这种情况下 m += 4


------------


### 接着重新定义f[n]的含义，表示到第n秒可能达到的最大距离，我们有两种情况

1.在1~n秒的过程中，没有跑过步，那么就是预处理的f(n)

2.在1~n秒的过程中，至少有1秒跑过步，那么选出跑步的这1秒（设为第i秒），把这1秒的跑步调整到第n秒进行，i+1到n秒的选择往前平移1个单位，结果不变，那么有第n秒在跑步，于是取前(n-1)秒能达到的最大距离f(n-1)，并与之求和，即f(n-1)+17


------------


通过以上的处理，去除了m的影响，使得满足了动态规划的无后效性条件和最优子结构的性质

```cpp
#include <bits/stdc++.h>
using namespace std;

const int T = 300000;

int m,s,t;
int f[T+10];

int main()
{
	cin >> m >> s >> t;
	for(int i = 1; i <= t; i++)
	{
		if(m >= 10)
		{
			f[i] = f[i-1] + 60;
			m -= 10;
		}else{
			m += 4;
			f[i] = f[i-1];
		}
	}
	
	for(int i = 1; i <= t; i++)
	{
		f[i] = max(f[i],f[i-1]+17);//纯闪耀or等价性最后一步走 
		if(f[i] >= s){
			cout << "Yes" << endl << i << endl;
			return 0;
		}
	}
	
	cout << "No" << endl << f[t] << endl;
	return 0;
}
```
