### 简化的DP
首先算一下速度，发现闪现在时间足够的时候比跑步快。有两种走法：原地攒魔法放法术，或者直接跑步。

不妨用两个变量分别模拟闪现的距离（fla）和跑步的距离（run），并用fla维护run，使跑步的距离最优。在每一时刻判断fla和run的最大值有无满足条件的，输出即可。

什么意思呢，如果在某一时刻，闪现的距离大于了跑步的距离，就将跑步的距离更新成此时闪现的距离，在此基础上继续跑。因为如果时间够，就可以在闪现的基础上跑步，闪现是比跑步快的。

模拟一下，以第2个样例为例：

| 最大距离 | 60 | 120 | 180 | 197 | 240 | 255 |
| -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: |
| 闪现 | 60 | 120 | 180 | 180 | 240 | 240 |
| 跑步 | 17 | 77 | 137 | 197 | 214 | 255 |
可以看出，跑步是在上一步闪现与跑步的最大值的基础上跑的。

上代码，与普通DP相比用变量代替了数组
```cpp
#include<bits/stdc++.h>
using namespace std;
int m,s,t,fla,run;//分别代表闪现距离，跑步距离
int main(){
	cin>>m>>s>>t;//读入; 
	for(int i=1;i<=t;i++){//时间; 
		
		if(m>=10)m-=10,fla+=60,run+=17;//蓝够了就闪,另一边跑步;
		else{if(fla>run)run=fla;//在最优的基础上跑; 
			m+=4,run+=17;}//回蓝,另一边跑步; 

		if(max(fla,run)>=s){
			printf("Yes\n%d\n",i);return 0;} //出去了 
	}
	cout<<"No"<<endl<<max(fla,run)<<endl;//没出去 
	return 0;
}
```
