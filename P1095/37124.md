## 这里用了暴力，个人觉得比DP好理解，运行也不慢QWQ（只有我一个人这样写吗QAQ）

大体思路（假设你不会DP也不会什么高级的东东）：明确一点　魔力值足够的时候能闪则闪　如果只会暴力，怎么办？枚举啊　
### 枚举什么呢？重点来了：
枚举跑的时间？那么你不能确定到底什么时候闪，什么时候回魔（恢复魔力）否决

枚举闪的次数？这个似乎听起来比较靠谱　但是仔细想一想　你的魔力可能不够　就需要回魔　什么时候回魔？没有魔力的时候回魔　可是你还要兼顾回魔和跑　会很麻烦

### 现在你应该发现了　以上两个方法都有一个麻烦的地方：回魔多久？什么时候回魔？那到底应该枚举什么呢？既然回魔时间难以确定　那当然就枚举回魔的时间长度啦QWQ
~~有点草率~~
看代码

```cpp
int m,s,t,temp=0,k;
cin>>m>>s>>t;//输入
int i,j,maxv=-1,minv=2147483647,ti,mi;
bool f=0;//标记变量
for (i=t;i>=0;i--)//穷举回魔（原地等待）的时间
{
    mi=m+i*4;//魔力值替身变量回升
    ti=mi/10;//时间替身变量的计算
    if (ti>t) ti=t;
    if (t-ti-i<0)//如果回魔时间大于时间限制 do nothing
        ;
    else
    {
        temp=ti*60+(t-ti-i)*17;//路程
        if (temp>=s)
        {
            f=1;
            k=t-ti-i;
            while (k>0 && temp-17>s)//把多跑的“拉”回来
            {
                k--;
                temp-=17;
            }
            if (ti+i+k<minv) minv=ti+i+k;//如果跑出去 存最短时间
        }
        if (temp>maxv) maxv=temp;//跑不出去 存最长距离
    }
}
if (f)
{
    cout<<"Yes"<<endl;
    cout<<minv;
}
else
{
  　cout<<"No"<<endl;
    cout<<maxv;
}

```
如果本篇题解对你有帮助　请点赞　毕竟打那么多字也不容易啊QWQ