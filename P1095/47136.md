表示为了做这道题，浪费了好多提交次数。。

前面自己想的一种方法一直没对（还有几次No和Yes打错。。。）就根据某个题解改了一下过了。

刚刚把自己原本的方法改对了，来分享一下。

大致思路是这样的（大约是模拟）：

在距离较远时，一直用闪烁和回魔肯定是更划得来的。但是近了以后就不一定。

所以每进行一次闪烁或回魔之前，都计算一次后面全部跑步可以跑的距离，如果超出s了，就计算一下时间，如果更短，就更新ans

如果没有超出，就检测有没有比之前存下的最大距离大，如果大，就更新最大距离

最后一次更新在出循环后，看全部闪烁得到的结果是不是更优，是就更新

原理：不管是按这样的顺序【跑步-闪烁-回魔-闪烁-跑步】还是【回魔-闪烁-闪烁-跑步-跑步】或者是其他搭配，只要每种操作分配的时间是一样的，那么从结果上来看，就是一样的，所以将闪烁和回魔放在一起，跑步全部放在最后，方便计算和比较。

```cpp
#include<bits/stdc++.h>
using namespace std;
int m,s,t,T,now,run,ans=99999999,k,maxn;//ans定为极大值，存最小时间，maxn存最大距离
int main()
{
    int i;
    scanf("%d%d%d",&m,&s,&t);
    while(now<s)
    {
        run=now+(t-T)*17;//计算之后全跑步能跑到哪
        if(T>=t) break;
        if(run<s&&run>maxn) maxn=run;//如果跑不出去，就看能不能更新maxn
        if(run>=s)//如果跑到了
        {
            if((s-now)%17) k=(s-now)/17+1;//计算还需要多久
            else k=(s-now)/17;//同上，之前就是一直忘了加这句，，，交了七八次Ծ‸Ծ  o(╥﹏╥)o
            run=T+k;//计算总时间
            if(run<ans) ans=run;//如果更优就更新
        }
        if(m>=10)m-=10,now+=60,T+=1;//now是前T秒全闪烁与回魔的距离
        else  T+=1,m+=4;
        if(T<=t&&now>maxn) maxn=now;
    }
    if(T<=t&&now>=s&&T<ans) ans=T; 
    if(ans==99999999) printf("No\n%d",maxn);//如果到不了就输出最大距离
    else printf("Yes\n%d",ans);//反之输出时间
    return 0;
}
```