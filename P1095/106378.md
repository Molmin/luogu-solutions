本人很菜用的是**动规**，当然也用到**贪心**的思路。

1)用法术可以移动60m，显然尽可能用法术是最快的，但如果魔法值不够，则只能呆在原地恢复

2)先只考虑用法术的情况，根据魔法值判断是移动60m，还是原地不动

3）再重新循环判断，相同的时间内，跑步是否能得到更好的解，要注意的是，当不能用法术时，跑步并不一定比原地休息更好，所以两次循环不要写成一个

4）样例2，每一秒所得到的最远距离依次为：60，120，180，197，240，257。

    前三秒用的法术，此时魔法值还余6，第4秒跑步为197，

    第5秒的240意味着第4秒并没有跑，而是在原地休息，这样魔法值又变为10，可以再用一次法术，因此得到240，这时魔法值为0

    最后一秒跑步，距离就已经够了，所以最短时间是6秒

5）注意197之后不能直接到257，因为如果第5秒跑步的话，是197，但那样一来，就没法恢复魔法值，下一秒是不能用法术的

上超菜的**代码**

```cpp
#include<bits/stdc++.h>
using namespace std;
int m,s,t,f[300005];
int main(){
	cin>>m>>s>>t;
	for(int i=1;i<=t;i++)//算第i秒时用法术移动的距离f[i]
	  if(m>=10){
		f[i]=f[i-1]+60;
		m-=10;
	  }
	  else{
		f[i]=f[i-1];//魔法值不够em
		m+=4;//恢复4点魔法值
	  }
	for(int i=1;i<=t;i++){//计算相同时间内，跑步是否更优 
		f[i]=max(f[i],f[i-1]+17);//如果跑步可以更远，则跑步，注意和上面的循环并不在一起，所以并不会影响到后面的值
		if(f[i]>=s){
		  cout<<"Yes\n"<<i<<endl;
		  return 0;
		}
	}
	cout<<"No\n"<<f[t]<<endl;
	return 0;
}
```
