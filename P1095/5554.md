考虑动态规划，问题一个个列出，一个个解决。我们不考虑最优解法，只考虑怎么简单A掉这道题。

**首先，用什么表示状态？**中间一维肯定是剩余魔力。另一维是用距离还是时间？显然，无论从空间复杂度还是时间复杂度上面，另一维用时间更好。因此我们便想到了状态。

状态：$dp[i][j]$为前i秒，还剩j点魔力能到达的最大距离。

**第二，转移方程？**转移方程其实不难。题意中，每一秒有三种决策：跑/闪烁/回复魔力。很容易能想到：

$dp[i][j]=max{dp[i-1][j-4],dp[i-1][j]+17,dp[i-1][j+10]+60};$

然后考虑初始状态和边界条件。

显然题意已经限制了时间T和初始魔力M，因此一开始我们只能从$dp[0][M]$转移过来。由此，我们令$dp[0][i]=-INF (i!=M)$，来表示该状态无法转移。显然，以上的转移方程如果三个状态都无法转移过来，那么$dp[i][j]=-INF$。

这个方程的i的顺序是单调的，所以我们可以通过一个循环来求解这个动规，就不用使用记忆化搜索了。

边界条件，当我们发现了第一个$dp[i][j]>=S$，直接输出$i$。$i<=t$，如果到最后也没有$dp[i][j]>=S$，则输出$max(dp[i][j])$。

**第三，空间复杂度？**我们看到题目的范围，T最大可以为300000,M最大可以为1000，如果直接开绝对炸。

我们可以使用一个滚动数组。因为状态转移方程中j的顺序并非单调，所以这个滚动数组得弄个两维的，两个维交替用。

也就是定一个$dp[2][M]$的数组，第一次用$dp[0][...]$，状态从$dp[1][...]$调取，第二次用$dp[1][...]$，状态从$dp[0][...]$调取，也就是从上一个旧的维度调取。这个应该好理解。

**第四，时间复杂度？**然而我们发现时间复杂度仍然是$O(TM)$，会炸。我们考虑一个简单的贪心——如果你有足够的魔力来进行瞬移，岛马上就要沉没了，你会采取先在原地休息一会儿的决策吗？肯定不会，我们会先耗尽这个魔力来尽力进行瞬移。只有当魔力将近不足的时候，我们才会采取其它措施。

由此得到优化策略：等待K轮魔力耗尽之后，想要得到最优解，魔力的最大值会被限定在一定的范围内（因为魔力一旦再次充足就会被立马消耗）。K的最大值显然就是100左右（每轮消耗10点魔力），为了避免丢失最优解我们把K定为110，然后将这个被限定的范围定为50.

那么等待第K轮之后，最劣情况就会减少很多了：$O((300000-110)*50+110*1000)$,能够在规定的时间内求出正解。

以上，这道题就没用什么数学思想地解决了....

代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int T=2,INF=0x7fffffff;
int M=1110;

int dp[T][1110];
inline int mmax(int a,int b){return a>b?a:b;}

int main(){
    int m,s,t;
    scanf("%d%d%d",&m,&s,&t);
    int at=0,ans=0;
    for(int i=0;i<=t;i++){
    for(int j=0;j<M;j++){
        if(i==0&&j!=m)dp[at][j]=-INF;
        else if(i>0){
        dp[at][j]=-INF;
        if(j-4>=0)dp[at][j]=mmax(dp[at][j],dp[at^1][j-4]);
        if(j+10<M)dp[at][j]=mmax(dp[at][j],dp[at^1][j+10]+60);
        dp[at][j]=mmax(dp[at][j],dp[at^1][j]+17);
        if(dp[at][j]<0)dp[at][j]=-INF;
        if(i>110)M=50;
        }
        if(dp[at][j]>=s){printf("Yes\n%d\n",i),exit(0);}
        ans=mmax(ans,dp[at][j]);
        //if(dp[at][j]>=0)printf("second:%d remain:%d cango:%d\n",at,j,dp[at][j]);
    }
    at^=1;
    }
    printf("No\n%d\n",ans);
    return 0;
}
```