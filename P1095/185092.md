**分析**：根据题意，守望者要在最短时间走最多的路程，而每秒有三种方法，休息（魔法恢复4），跑步（移动17m），闪烁法术（花费10魔法，移动60m），可以得到如下信息：

1. 休息和闪烁法术是有关联的（要不然还不如不休息）。

2. 有魔法的情况下，尽量用闪烁法术（因为闪烁法术移动最远）。

3. 在魔法不够的情况下，对休息（等待魔法恢复使用闪烁法术）还是跑步进行选择。

为了理清信息，不妨将跑步和使用闪烁法术分开处理。

设想：如果守望者不会跑步，即第i秒的能到达最大距离为f[i]。则：
$$f[i] =\begin{cases} f[i-1]+60(m\geq10)m-=10 \\ \\f[i]  (m<10)m=m+4\end{cases}$$
通过这样一个预处理，了解了闪烁法术的使用。

把跑步的情况加入，则：

f[i]=Max｛f[i]，f[i-1]+17｝（注意：令f[0]=0）

如此，得到的解决问题的递推是当f[t]（t为限定的时间）<S时,输出“No”及f[t]值，否则，输出“Yes”, 及最快的离岛时间i。

综合上述分析，具体实现步骤如下：

1. 读入数据M，S，T。

2. 计算只使用闪烁法术时的每秒最大距离。

3. 计算加入跑步选择时的每秒最大距离，如果在某时刻刚好离岛，则输出离岛时间，结束。

4. 如果不能离岛，输出最远距离，结束。
## 程序如下：
```cpp
#include<bits/stdc++.h>
#define N 300005
using namespace std;
int main(){
    int m,s,t;
    int f[N];
    cin>>m>>s>>t;//读入数据
    for(int i=1;i<=t;i++){//计算只用闪烁法术时的每秒最大距离
        if(m>9){
            f[i]=f[i-1]+60;
            m-=10;
        }
        else{
            f[i]=f[i-1];
            m+=4;
        }
    }
    for(int i=1;i<=t;i++){//计算加入跑步选择时的每秒最大距离
        if(f[i]<f[i-1]+17)f[i]=f[i-1]+17;
        if(f[i]>=s){//刚好离岛，输出
            cout<<"Yes"<<endl;
            cout<<i;
            return 0;
        }
    }
    cout<<"No"<<endl<<f[t];//不能离岛，输出
    return 0;
}
```
**说明**：本题有多种解决问题的方法，然而，在上述分析中很巧妙的运用了分而治之的思想，把原来跑步、魔法、休息交错在一起的问题条件分离开，考虑在只有魔法情况下每秒最远距离，此时，很容易用上问题的贪心条件，能用魔法尽量用上魔法，求只有魔法情况下每秒最远距离的递推式写起来也很简单，接着考虑跑步的情况，当前秒的跑步距离由上一秒加17递推得到，每秒最远距离为跑步距离和魔法距离中的最大值。这是一道很好的题，建议大家用不同方法解决之，然后从中体会分析问题的方法和技巧。