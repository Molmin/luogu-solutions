# **~~蒟蒻第一篇题解~~**



------------
**纯正的DP，没有一点贪心，只有DP，超好理解**

设**dp[i] [j] [1/0]** 在第i秒时，魔法值为j，0代表是由前一秒恢复得到的j，1代表不是恢复得到的j

则dp[i] [j] [0/1] 代表在第i秒时，魔法值为j，是否是由恢复得到的j 所能跑到的最远距离

然后我们可以推出状态转移方程


先假设使用跳跃技能
**dp[i] [j] [1]=max(dp[i-1] [j+10] [1]+60,dp[i-1] [j+10] [0]+60);第i秒时魔法为j并且不是恢复的来的j（那么只能是由上一次消耗得来） 所以为第i-1秒法力值为j+10秒时候0/1两个状态得来，并且此种情况的条件为j+10<=m+1  为什么是m+1可以好好想一想**

****然后就是假设不用跳跃技能的最大值
**dp[i] [j] [1]=max(dp[i] [j]  [1],dp[i-1] [j][1]+17);
            dp[i] [j] [1]=max(dp[i] [j] [1],dp[i-1][j] [0] +17);**


然后就是0的情况，是由恢复法力得来的j
那么状态转移方程式为**if(j>=4) dp[i] [j] [0]=max(dp[i-1][j-4] [1],dp[i-1] [j-4] [0]);**

但是由于空间相当的大，我们要换成滚动数组

~~但是不开o2还是会T两个点~~

献上代码

```cpp
// luogu-judger-enable-o2
#include<bits/stdc++.h>
using namespace std;
int M,S,T,MAXN;
int t;
//dp[i][j][1/0] 在第i秒 ，魔法值为j  0代表是否是恢复得到的j，1代表不是恢复得到的j  是否跑的最远距离 
int dp[2][1010][2]; 

int main(){
    cin>>M>>S>>T;  //输入 
    for(int i=1;i<=T;i++){      
        for(int j=M;j>=1;j--){
            if(j+10<=M+1) dp[i%2][j][1]=max(dp[(i-1)%2][j+10][1]+60,dp[(i-1)%2][j+10][0]+60); 
            dp[i%2][j][1]=max(dp[i%2][j][1],dp[(i-1)%2][j][1]+17);
            dp[i%2][j][1]=max(dp[i%2][j][1],dp[(i-1)%2][j][0]+17);
            if(j>=4) dp[i%2][j][0]=max(dp[(i-1)%2][j-4][1],dp[(i-1)%2][j-4][0]);
            MAXN=max(MAXN,dp[i%2][j][1]);
            MAXN=max(MAXN,dp[i%2][j][0]);
            if(MAXN>=S&&t==0) t=i; 
        }
    }
    
    if(MAXN<S){
        cout<<"No"<<endl<<MAXN;
    }
    else{
        cout<<"Yes"<<endl;
        cout<<t;
    }
}





