这个守望者跑步啊，仔细想一想，有以下几种"奔跑礼包"可供选择:

① $-1s$  $+60m$ ($M≥10$)

② $-2s$  $+60m$ ($M≥6$)

③ $-3s$  $+60m$ ($M≥2$)

④ $-4s$ $+60m$ (无要求)

⑤ $-7s$ $+120m$ ($T≥7$ && $S≥120$)

⑥ $-1s$ $+17m$ (无要求)

也许还有其他选择礼包，不过都是由这六种礼包拼出来的，不然就无法达到最优。

很显然，礼包①②③血赚不亏，只要能用就一定最优，所以有魔力值的时候先用魔力值进行移动。
但是魔力值总归会有耗光的那一天，当魔力值严格小于2的时候我们就不能用前三种礼包了，这就要求我们从下面三个礼包中选择来进行移动。

不管用两次④礼包，还是用七次⑥礼包，在③礼包满足条件的情况下，他们都没有⑤礼包收益高，因此当⑤礼包满足条件的时候，我们优先选取⑤礼包。

这时候，魔力值应该只可能是$0,1,2$三种可能，时间也只可能剩下$1-6s$这六种可能，因为**没有时间**或者**已经到达出口**这两种情况都已经退出循环可以直接输出结果了。现在我们依然寻求在最后这几秒到达更远的距离($PLUS ALTRA$)(x)

现在要么用④礼包，要么用⑥礼包，很显然，⑥礼包明显更优。贪心完了，写出程序跑一下，发现第一个样例就$WA$了(....。

原因在哪里呢？原因在于之前②③并不是血赚不亏的。我们来想象这样两种情况，如果时间只剩$1s$，蓝还有$9$，我难道还选择补蓝然后来一个②礼包吗？如果距离只剩下$15m$，蓝还有$9$，我难道还选择补蓝然后来一个②礼包吗？显然不是，我不用瞬移，跑两步就完事了。

因此，我们改变一下策略。如果蓝足够，选①一定没错，然后时刻关注剩余时间和剩余距离，如果⑥礼包更优，那就选⑥礼包。

①礼包将魔力值消耗到$10$以下，如果⑥礼包不是最优，考虑选购②③礼包，魔力值不断加$4$接着对$10$取余，总会有魔力值不到$2$的那一次，因此②③礼包也有不能用的时候，这时候就狂用⑤礼包，用到没魔力$(0-2)$也没时间$(1-6)$或没距离的时候$(1-119)$，这时候一定是⑥礼包最优。

$AC$代码
```cpp
#pragma GCC optimize("Ofast")
#include <bits/stdc++.h>
#define maxn 13003
#define _for(i,a,b) for(int i = (a);i < b;i ++)
typedef long long ll;
using namespace std;

inline ll read()
{
    ll ans = 0;
    char ch = getchar(), last = ' ';
    while(!isdigit(ch)) last = ch, ch = getchar();
    while(isdigit(ch)) ans = (ans << 1) + (ans << 3) + ch - '0', ch = getchar();
    if(last == '-') ans = -ans;
    return ans;
}
inline void write(ll x)
{
    if(x < 0) x = -x, putchar('-');
    if(x >= 10) write(x / 10);
    putchar(x % 10 + '0');
}
int M,S,T;
int SS,TT;
int main()
{
    M = read(),S = read(),T = read();
    SS = S;TT = T;
    int i;
    for(i = 0;i < T;i ++)
    {
		if(S <= 0) break;
		if(M >= 10)
		{
			M -= 10;
			S -= 60;
		}
		else if(((T-i<=1||S<=17)&&M<10) || ((T-i<=2||S<=34)&&M<6)
		 || ((T-i<=3||S<=51)&&M<2) || ((T-i<=4||S<=68)&&M<2)
		 || ((T-i<=5||S<=85)&&M<2) || ((T-i<=6||S<=102)&&M<2)
		 || (S<=119&&M<2))
			S -= 17;
		else if(M >= 2)
			M += 4;
		else if(S >= 120 && T-i >= 7)
		{
			while(S >= 120 && T-i >= 7)
			{
				i += 7;
				S -= 120;
			}
			i --;
		}
	}
	if(S <= 0)
		printf("Yes\n%d\n",i);
	else
		printf("No\n%d\n",SS-S);
    return 0;
}
```
