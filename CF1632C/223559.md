### 解题思路：

由于按位或的操作只能由 $a$ 完成，所以当 $a>b$ 时，只能将 $b$ 不停地加到 $a$ 为止。

否则将 $a$ 或 $b$ 一直增加到相等或着 $a$ 按位或后相等，由于数值范围很小，直接暴力枚举就行了。

---
第二段的证明想了好久，差点没整出来。

当 $a>b$ 的时候，由于 $a|b\ge a$，而且没有让 $a$ 变小的方法，所以只能让 $b$ 增加，那么不取或而直接将 $b$ 增加是最好的选择。

问题就在于 $a<b$ 的时候。先排除在取或后再增加 $a$，由于 $a|b\ge b$，此时如果再将 $a$ 增加毫无意义。

所以只有在取或后增加 $b$ 的可能性，可以分每一个二进制位考虑，这里将操作二抽象为增加任意一个数 $x$，同时消耗 $x$ 的代价。由于首要要求是相等而非代价最小，当 $a$ 的某一位为 $0$，同时 $b$ 的相应为 $0$ 时，取或后依然相等，不需要花任何代价，同理有 $1$ 和 $1$，$0$ 和 $1$。

唯一需要讨论的是 $a$ 为 $1$ 而 $b$ 为 $0$，此时取完或还是不变的，需要消耗一定的代价使得 $b$ 增大到和 $a$ 相等，具体消耗的代价视二进制位的位置和后面的数而定。

此时~~不容易~~发现，如果在取或后增加，在考虑玩之后位的所有这种同样的情况之后发现这样的代价直接是这个二进制位的本身的权值，但是如果不先取或直接增加的话，后面的位置上如果存在  $a$ 为 $0$，而 $b$ 为 $1$ 的情况的话就能相应地减少代价。

结合抽象化的操作可知这样的操作并不会影响到其它的任何位，也就是独立的。

---
### 代码：

```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
int a,b,T,x,y,ans,cnt;
int main(){
	scanf("%d",&T);
	while(T--){
		scanf("%d%d",&a,&b);
		if(a>=b){
			printf("%d",a-b);
			continue;
		}
		ans=2147483647;
		cnt=0;
		x=a;y=b;
		while((x|y)!=y){
			x++;
			cnt++;
		}
		if(x!=y)cnt++;
		ans=min(ans,cnt);
		
		cnt=0;
		x=a;y=b;
		while((x|y)!=y){
			y++;
			cnt++;
		}
		if(x!=y)cnt++;
		ans=min(ans,cnt);
		
		printf("%d\n",ans);
	}
	return 0;
}
```
