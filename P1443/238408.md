### **BFS大法好！**
### **STL大法好！**
### **printf大法好！**



------------
通过填涂颜色，我们了解了BFS的最基础用法：遍历

而这道题紧承填涂颜色，又使我们了解了BFS的另一个用法：

**求步数**

这也是十分重要的用法，建议大家在AC后多多温习。


------------
要想弄清楚一个算法的用途，首先要明确其原理。

我们知道BFS是**逐层推进**的，每一层都包含上一层的点所能到达的位置。

特别地，第一层的点只有一个，即起点。


------------


诶？好像有什么发现！

要想到达第$n$层的点，必须先到达第$n-1$层的点。

而从第$n-1$层“跳”到第$n$层的操作不就是一次移动吗？

这样一直推下去，我们可以得到一个很重要的结论：

**从第1层到达第$n$层需要移动$n-1$次**。

也就是**从起点到达任意一个点，移动的次数为$k-1$次**。

其中$k$为该点所在的层数。

而**移动的次数就是**我们**所求的步数**啊！


------------
因此，用BFS求步数的思路就确定好了，即：

先开一个二维数组，全部**初始化为-1**，用来记录步数。

然后，从起点开始进行BFS。

对于所搜索到的每一个点，找到它在二维数组中对应的元素。

把元素的值修改为**层数-1**。

最后按行输出二维数组即可

------------
怎样记录层数呢？

由于BFS是按照每一层的点来进行下一步的搜索的，

那我们每搜到一个点，它**所需的步数就是上一个点所需步数+1**

因此我们只需要**把起点标记为0**就可以用**类似递推的方法**实现了

------------

这里再介绍一下两个好用的函数：
* 1.$memset$ 这个函数相信大家都不陌生。在这道题中我们将用它把ans数组的元素全部赋-1值，这样就不需要再使用标记数组，直接在ans数组里操作即可


------------

* 2.$printf$ printf是C语言的输出，而它在C++中依然具有不容小觑的作用。printf有两个好处：

		一是速度比cout快，尤其是当数据量超过1e5时将会cout几条街 
	    二是操作非常简单。
		    比如保留小数点后n位，cout不仅得引用头文件   
            iomanip（习惯用万能头的选手当我没说），还
            要写一串控制符。而printf就没那么多麻烦：直
            接在控制符中加一个.n就行了。很方便有木有？
		    场宽和左对齐也是特别直接：printf("%-5d",a[i][j]);
            对比一下那又长又繁琐有慢吞吞的cout，是不是好处多多？

## （printf大法好！）


------------

OK，了解完这些，把BFS的STL板子贴上再改一改就行了

## （STL大法好！）
------------

**代码来了~**：
```
#include<iostream> 
#include<cstdio>//欲用printf，先引stdio库
#include<queue>//STL大法好！
using namespace std;
int dx[]={ 1, 1,-1,-1, 2, 2,-2,-2};//马所能到达的位置
int dy[]={-2, 2,-2, 2,-1, 1,-1, 1};
int a[405][405];//ans数组，存储步数
int main(){
	queue<int> x;//x存储点所在的行
	queue<int> y;//y存储点所在的列
	int n,m,x1,y1,xx,yy;
	cin>>n>>m>>x1>>y1;
	memset(a,-1,sizeof(a));//全部赋值-1
	x.push(x1);//压入起始点的横坐标
	y.push(y1);//压入起始点的纵坐标
	a[x1][y1]=0;//特殊处理
	while(!x.empty()){
		xx=x.front();//当前马所在的位置
		yy=y.front();
		for(int i=0;i<8;++i){
			int tx=xx+dx[i];//马能跳到的位置
			int ty=yy+dy[i];
			if(tx>0&&tx<=n&&ty>0&&ty<=m&&a[tx][ty]==-1){//判断是否越界、是否跳到过
				x.push(tx);//压入新点
				y.push(ty);
				a[tx][ty]=a[xx][yy]+1;//更改跳到的点
			}
		}
		x.pop();//弹出
		y.pop();
	}
	for(int i=1;i<=n;++i){
		for(int j=1;j<=m;++j){
			printf("%-5d",a[i][j]);//printf大法好！
		}
		cout<<endl;
	}
	return 0;
}
```