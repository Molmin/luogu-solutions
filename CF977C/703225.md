## 题目大意

给定一个长度为 $n$ 的整数序列和整数 $k$，你需要找到一个在 $[1, 10^9]$ 范围内的整数 $x$，使得给定序列中有正好 $k$ 个数小于等于 $x$，序列中可能含有相等的元素，如果没有这样的 $x$，输出 `-1`。

## 题目解法

我们只需要把数据从小到大排一下序（用`sort`快排就可以），然后特判一下某些是无解的情况，如果不是就直接输出数组中的第 $k$ 个数就可以了。

那什么时候是无解的呢？

我们把这个序列定义成 $a$ 数组，看一下数据的范围，发现 $0 \le k \le n$ ，

当 $k=0$ 时，意思是序列中没有数比 $x$ 的值小。

此时，如果 $a[1]=1$（$a[1]$ 就是序列中最小的数），那么 $x$ 的值就应该比 $1$ 小，但是我们看数据范围就会发现 $ 1 \le x \le 10^9 $。因此，此时是无解的。

那么如果 $a[1]>1$，我们输出 $a[1]-1$ 即可（也可以输出 $1$,这道题应该是有spj的）。

我们再注意一下题目，就会发现`序列中可能含有相等的元素`，这时候还有一个特殊的情况，如果第 $a[k]=a[k+1]$ 这时候 $x$ 的值就无法确定了，因此无解。

### 参考代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[1000001];
int main()
{
	int n,k;
	cin>>n>>k;
	for(int i=1;i<=n;i++) cin>>a[i];
	sort(a+1,a+n+1);
	if(k==0) 
	{
		if(a[1]==1){
			cout<<-1;
			return 0;
		}
		else {
			cout<<a[1]-1;//也可以输出1 
			return 0;
		}
	}
	if(a[k]==a[k+1]){
		cout<<-1;
		return 0;
	}
	cout<<a[k];
}
```
