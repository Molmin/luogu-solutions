怎么最近两场月赛的 A 都不够水了啊（

转化题意就是问最终字符串中段数的最小值。

显然有贪心策略：每次把所有串开头能取的同种字符取完放在最终字符串中成一段一定最优。比如：

$11000$ 和 $01100$，就先把它们最前面的所有 $0$ 都取出来，最终字符串中放入 $1$ 个 $0$，或者把它们最前面的所有 $1$ 都取出来，最终字符串中放入 $2$ 个 $1$。然后依此方式继续操作。

然后在这样的策略下，我们会发现一件事情：首先我们定下来我们的最终字符串第一段是 $0$ 还是 $1$，然后最终的段数就是照此规则对每个字符串分段后段数的最大值。比如：

以 $0$ 为第一段，$11000$ 和 $01100$ 都分成 $3$ 段，最终字符串 $0111100000$ 也分成 $3$ 段。

以 $1$ 为第一段，$11000$ 分成 $2$ 段，$01100$ 分成 $4$ 段，最终字符串 $1101100000$ 分成 $4$ 段。

于是我们只要分别计算一遍以 $0$ 和 $1$ 为第一段的段再取最小者即可。

Code:
```cpp
#include<cstdio>
#define rg register
int n,ans,t0,t1,tt0,tt1;
int main(){
	n=read();while(n--){
		char c=gc(),l0='0',l1='1';t0=t1=1;
		while(!isdigit(c))c=gc();while(isdigit(c)){
			(c!=l0)&&(l0=c,++t0),(c!=l1)&&(l1=c,++t1),c=gc(),++ans;
		}(t0>tt0)&&(tt0=t0),(t1>tt1)&&(tt1=t1);
	}return 0&printf("%d\n",ans-((tt0<tt1)?tt0:tt1));
}
```