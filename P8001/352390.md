

------------
[题面](https://www.luogu.com.cn/problem/P8001)


------------
通过题目可知，我们取字符时是可以连续取的，因此如果**取的字符**与**后一位字符**相等，则连续取最优。

因为这个策略，我们可以在读入中把相同的字符个数用一个二维数组来存，$j$ 为当前的字符，而 $i$，则是用来存取字符时的次序。

为什么会这样存呢？因为已经压缩过 $01$ 串，所以如果要取就是全取完，且在同一次中是可以任意调换取 $n$ 个 $01$ 串的顺序的，而 $01$ 串只有 $0$ 或 $1$ 这两种字符，自然是把它们各自凑在一起最优。

而读入后，便是枚举第一次取的是 $0$ 还是 $1$。

至于其余的解释，我会在代码注释中提起。


------------
**AC code**
```cpp
#include<bits/stdc++.h>
using namespace std;
int bj,s1,s2,sum,n,i,len,j,f[1000001][2],t,ma;
char a[1000001];//存01串
int main(){
	scanf("%d",&n);
	for(i=1;i<=n;i++){
		scanf("%s",a+1);
		len=strlen(a+1);
		t=0;//把取的次数清0
		for(j=1;j<=len;j++)
			if(a[j]!=a[j-1])f[++t][a[j]-'0']++;//char数组第0位默认为空格，++把自己也算上
			else f[t][a[j]-'0']++;//如果相等就当前次数的字符数量++
		ma=max(ma,t);//求每一个01串要做的次数的最大
	}
	//枚举先取1的情况的答案 
	bj=0;//没取的字符(变为int型) 
	s1=f[1][1]-1;//当前的对数 
	sum=f[1][0];//没取的字符个数，因为没取的就可以和后面的凑成一条长队 
	for(i=2;i<=ma;i++){
		s1+=sum+f[i][bj]-1;//sum+f[i][bj]-1为之前没取的和后面连起来的对数 
		bj=!bj;//换另一个字符不取 
		sum=f[i][bj];//更新没取字符的个数 
	}
	s1+=max(sum-1,0);//判断最后还有没有没取的个数，如果有答案再加，没有则加0
	//枚举先取0的情况的答案(注释同上) 
	bj=1;
	s2=f[1][0]-1;
	sum=f[1][1];
	for(i=2;i<=ma;i++){
		s2+=sum+f[i][bj]-1;
		bj=!bj;
		sum=f[i][bj];
	}
	s2+=max(sum-1,0);
	printf("%d\n",max(s1,s2));//输出两个答案中的最大对数 
}
```


------------
# The End.