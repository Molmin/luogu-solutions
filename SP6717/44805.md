### P.S.
这是笔者的第40道黑题，当然要纪念了啊  
我果然还是太菜了，一道神必分类讨论要调 1.5 h  
### Summary Of Solution.
我们需要维护的 dp 信息有。  
1. 它走向它任意一个后代的最长距离。
2. 它走向它任意一个后代的次长距离。
3. 它走向它任意一个后代的第三长距离。
4. 以它为根强制选它走向它父亲这条边后最长距离。
5. 它的父亲

接下来分类讨论的大概框架（是不是不想写这题了？
1. 在一个节点的子树内它的直径。
	1. 最长路径经过根。
	2. 最长路径不经过根。
2. 在整棵树去掉一个子树后它的直径。
	1. 最长路径不经过根。
	2. 最长路径经过根。
		1. 最长路径经过它父亲。
			1. 它被删掉的子树是以它父亲为根的子树的最大链
			2. Otherwise.
		2. 最长路径不经过它父亲。
			1. 它被删掉的子树是以它父亲为根的子树的最大链，即它父亲的最大值是由它转移过来的。
			2. 它被删掉的子树是以它父亲为根的子树的次大链，即它父亲的最大值是由它转移过来的。
			3. Otherwise.

### Problem.
求选出两条不相交树链的长度的最大乘积  
### Solution.
首先，有一个很显然的思路，$O(n)$ 扫过每条边。  
然后处理出这条边左右的最长链大小，并乘起来取最大。  
然后最关键的就是如何求出断掉一条边之后左右两边的最大链。  
这个东西讲起来很简单，但是代码实现起来很麻烦。  

首先，树上的每一条边显然都是连接一对父亲和儿子的。  
那么，树断裂后树会变成两部分，一部分是儿子的子树，另一部分是剩下的。  
那么我们现在需要统计这样的信息。  
1. 在一个节点的子树内它的直径。
2. 在整棵树去掉一个子树后它的直径。

#### 1询问
对于儿子这边的子树，我们又可以**分类讨论**。  
1. 最长路径经过根。
2. 最长路径不经过根。

2 很好做，我们可以从每个儿子的最长链信息转移过来。  
1 也可作，我们维护每个节点到它每个儿子的最长链和次长链，然后直接相加即可。  
然后这个询问就做完了。  

#### 2询问
对于整棵树去掉一个子树的情况，我们脑补一下这颗树。  
直接**分类讨论**！（下面统称这个子树的节点是根  
1. 最长路径不经过根。
2. 最长路径经过根。

1 很好做，直接从它父亲和它剩下的儿子转移过来就行了。  
2 看上去也很好做，但是是真的神必，继续**分类讨论**  
1. 最长路径经过它父亲（设为 x
2. 最长路径不经过它父亲（设为

然后对于 1 ，我们最后地**分类讨论**：
1. 它被删掉的子树是以它父亲为根的子树的最大链，即它父亲的最大值是由它转移过来的。
2. Otherwise.

对于上面那种情况，我们直接取 x->fa[x] 上面的最长链和 x 子树内的次长链之和。  
对于下面这种情况，我们直接取 x->fa[x] 上面的最长链和 x 子树内的最长链之和。  

然后对于 2 ，我们继续**分类讨论**：  
1. 它被删掉的子树是以它父亲为根的子树的最大链，即它父亲的最大值是由它转移过来的。
2. 它被删掉的子树是以它父亲为根的子树的次大链，即它父亲的最大值是由它转移过来的。
3. Otherwise.

如果情况是 1 ：我们取 x 子树内次长链和第三长链之和。  
如果情况是 2 ：我们取 x 子树内最长链和第三长链之和。  
如果情况是 3 ：我们取 x 子树内最长链和次长链之和。  

然后终于分类讨论讨论完了！完结撒花。
### Coding.
提供一下 dp 的过程，统计答案就按照上面这样分类讨论就好了
```cpp
//愿你有一天能和你重要的人重逢。
//大切な人といつかまた巡り会えますように
inline void ins(int *a,int w);
inline void dfs1(int x,int fa)
{
	dp[x][0]=dp[x][1]=dp[x][2]=-1,pa[x]=fa;
	for(int i=head[x];i;i=e[i].nxt) if(e[i].to!=fa) dfs1(e[i].to,x),ins(dp[x],dp[e[i].to][0]+1);
	for(int i=head[x];i;i=e[i].nxt) if(e[i].to!=fa) de[x]=max(de[x],de[e[i].to]);
	if(e[head[x]].to==fa&&!e[head[x]].nxt) dp[x][0]=0;else de[x]=max(de[x],dison(x));
}
inline void dfs2(int x,int fa)
{
	if(dp[x][0]+1==dp[fa][0]) ds[x]=max(ds[fa],dp[fa][1])+1;else ds[x]=max(ds[fa],dp[fa][0])+1;
	for(int i=head[x];i;i=e[i].nxt) if(e[i].to!=fa) dfs2(e[i].to,x);
}
```