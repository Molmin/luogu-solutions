两个输入难道不像数学题吗······

数学题怎么办？

颓柿子！

不会颓怎么办？

打表！

打表思路楼下dalao已经曰的很清楚了，不再赘述。

然后，找规律！

对于每一个答案，计算能使答案是它的最小$\text{n}$

然后每一项减去它的前一项得到一个新数列。

如下：

```
1 1
2 1
3 1
4 1
5 1
6 1
7 1
8 1
9 1
10 1
11 1
12 1
13 1
14 1
15 2
16 3
17 3
18 3
19 4
20 4
21 4
22 4
23 5
24 5
25 5
26 8
27 9
28 12
29 12
30 16
31 16
32 16
33 16
34 20
35 20
36 25
37 27
38 36
39 48
40 48
41 64
42 64
43 64
44 64
45 80
46 80
47 100
48 108
49 144
50 192
51 192
52 256
53 256
54 256
55 256
56 320
57 320
58 400
```
谔，这个有什么规律吗？

乍一看没有。

但如果这么写呢？

```
1 1
2 1
3 1
4 1
5 1
6 1
7 1
8 1
9 1
10 1
11 1
12 1
13 1
14 1
15 2
16 3
17 3
18 3
19 4
20 4
21 4
22 4
23 5
24 5
25 5
26 8
=========
27 9
28 12
29 12
30 16
31 16
32 16
33 16
34 20
35 20
36 25
37 27
=========
38 36
39 48
40 48
41 64
42 64
43 64
44 64
45 80
46 80
47 100
48 108
=========
49 144
50 192
51 192
52 256
53 256
54 256
55 256
56 320
57 320
58 400
```
1到26依然杂乱无章（不管了老老实实打表输出），但27以后出现了规律！

把两个“=========”称为一段。

一段之间的有点乱，但相邻两段对比，每一项都乘以了4而已！

然后就可以$\operatorname{O}(1)$递推计算这个数列的每一项了！

然后就一个个枚举累加就好了。

至此这题就没了。

复杂度：$\operatorname{O}(\operatorname{lg}n)$（口胡）

应该是除直接打表外复杂度最低的了。

上代码：
```
#include<bits/stdc++.h>
using namespace std;
const int ret[]={0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,14,15,15,15,16,16,16,17,17,17,18,18,18,18,19,19,19,19,20,20,20,20,21,21,21,21,22,22,22,22,22,23,23,23,23,23,24,24,24,24,24,25,25,25,25,25,25,25,25,26};
int mv[]={9,12,12,16,16,16,16,20,20,25,27};
int n;
int main(){
	cin>>n;
	if(n<=64)return cout<<ret[n]<<endl,0;
	int beg=64;
	int start=3,grp=26;
	while(1){
		for(int i=0;i<11;++i){
			beg+=mv[i];mv[i]*=4;
			if(beg>n)return cout<<grp<<endl,0;
			++grp;
		}
	}
	return 0;
}
```
话说：其实还可以通过二分+位运算进一步优化到$\operatorname{O}(\operatorname{lg}\operatorname{lg}n)$

但这题已经不需要了。