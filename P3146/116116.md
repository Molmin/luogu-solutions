一开始看到合并，基本上都是想到区间DP。

但是OI里面不能总是用套路。

大家都听说过或者玩过2048吧？

这题就是一维版本的2048（2048里是显示2的几次方，这里就直接显示几次方了）

------------

假如我们在玩2048，现在只有一行的数，如果我们要把最右边的数凑到最大，那么一直往右划就好了。

如果我们要把最左边的数凑到最大，那么一直往左边划就好了。

我们很容易想到这题枚举中间点，把它左边合并过来，右边合并过来，最大是多少。

不过这样每次合并到底是**先合并左边还是先合并右边**？

先别急。

这题中，我们可以只选择合并某两个数。

这样，往左划就跟往右划是一样的了。

哈哈，玩游戏有助于提升思维！

于是我们根据游戏推出了这题 $O(n^2)$ 算法。

------------

实现方法：
1. 枚举右端点
2. 从右端点往左扫，通过栈来存扫过的数
3. 如果栈顶的两个数相等，把这两个数都弄出来，把它们加一弄进去（重复）

简洁的代码：
```cpp
#include<cstdio>
const int MAXN=250;
int n;
int a[MAXN];
int top,stk[MAXN];
int ans;
int main(){
    scanf("%d",&n);
    for(int i=1;i<=n;i++){
        scanf("%d",a+i);
        stk[top=1]=a[i];
        for(int j=i-1;j>0;j--){
            if(a[j]>stk[top]) break;	//接着划已经没用了
            stk[++top]=a[j];	//压栈
            while(top>1&&stk[top]==stk[top-1])
                stk[--top]++;	//合并两个数
        }
        if(ans<stk[1]) ans=stk[1];	//栈底为当前右端点合并后的最大值
    }
    printf("%d\n",ans);
    return 0;
}
```
