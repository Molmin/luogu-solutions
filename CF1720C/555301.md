### 思路
题目中说到的L型共有 $4$ 种，为了方便，我们把它们编号。以下从左到右为 $1$ 到 $4$ 号。

```
**  **  *    *
*    *  **  **
```

只需考虑第一次覆盖后消除的 $1$ 的个数即可，之后的覆盖都能做到只消除 $1$ 个 $1$。

考虑原图中含有 $1$ 的数量最小的 $2\times 2$ 的网格，把覆盖L型后 $1$ 的最小消除数量记为 $k$，分以下 $4$ 种情况讨论。

```
00
00
```

这个图为第一种情况，$k=0$。

```
10 & 11 & 10
00 & 00 & 01
```

这四个图为第二种情况，$k=1$。

```
11
10
```

这个图为第三种情况，$k=2$。

```
11
11
```

这个图为第四种情况，$k=3$。

设整个图中 $1$ 的数量为 $p$，则答案为：

$ans=\begin{cases}p&k\le1\\p-k+1&k>1\end{cases}$

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int t,n,m,k,p;
char a[1001][1001];
int main()
{
	scanf("%d",&t);
	while(t--)
	{
		scanf("%d%d",&n,&m);
		p=0;
		k=3;
		for(int i=1;i<=n;i++)
			for(int j=1;j<=m;j++)
			{
				cin>>a[i][j];
				if(a[i][j]=='1')
					p++;	//统计1的数量
			}
		for(int i=1;i<n;i++)
			for(int j=1;j<m;j++)
			{
				int a1,a2,a3,a4;
				a1=a2=a3=a4=0;	//统计2*2网格中1的最小数量，ai代表第i个L型
				if(a[i][j]=='1')
				{
					a1++;
					a2++;
					a3++;
				}
				if(a[i+1][j]=='1')
				{
					a1++;
					a3++;
					a4++;
				}
				if(a[i][j+1]=='1')
				{
					a1++;
					a2++;
					a4++;
				}
				if(a[i+1][j+1]=='1')
				{
					a2++;
					a3++;
					a4++;
				}
				k=min(k,min(min(a1,a2),min(a3,a4)));
			}
		if(k<=1)
			cout<<p<<'\n';
		else
			cout<<p-k+1<<'\n';
	}
	return 0;
}
```