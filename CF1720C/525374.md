### 题目大意
- 定义：一个 $2\times 2$ 的矩阵，减去任意一个角，剩下的 $3$ 个组成的图形称作 $L$ 形。
- 给定一个 $n\times m$ 的矩阵，所有元素都是 $0$ 或 $1$，每一次操作你可以选择一个含有至少一个 $1$ 的 $L$ 形，将里面的所有 $1$ 变成 $0$。
- 问把矩阵中所有的元素都改成 $0$，**最多**可以花费几次操作。

### 解题思路
由于让我们求的是最多，所以我们容易想到让每一次都只删除一个 $1$。思考：怎样的情况可以满足每次只删除一个 $1$？

对于一个 $2\times 2$ 的矩阵，要想最大化删除次数：

1. 若其中不含有 ```1```，则不能删除任何元素，理由略。
2. 若其中只含有一个 ```1```，则只能删除 $1$ 次，理由略。
3. 若其中含有两个 ```1```：则只能删除 $2$ 次，理由如下：

第一种情况如下图（可以翻转）：
```
1 1
0 0
```
对于这种情况我们可以先选择左上角，左下角，右下角的 $3$ 个数，修改成 ```0```。然后再修改掉右上角这个 ```1```。所以最多可以删除 $2$ 次。第二种情况如下图(可以翻转)：
```
0 1
1 0
```
对于这种情况我们也可以先选择左上角，左下角，右下角的 $3$ 个数，修改成 ```0```。然后再修改掉右上角这个 ```1```。所以最多可以删除 $2$ 次。

4. 若其中含有三个 ```1```，则最多可以删除 $2$ 次，理由如下：

如下图（可以翻转）：
```
1 1
1 0
```

第一次就必须删除 $2$ 个 ```1```，如选择左上角，左下角和右下角。然后再删除剩下的一个 ```1```。

5. 若其中含有四个 ```1```，则最多可以删除 $2$ 次，理由略。

根据上面的分类讨论，我们就得出了解题思路：
- 特殊情况：如果全图都是 ```0```，则输出 $0$。
- 如果全图都是 ```1```，则所有的 $2\times 2$ 的方格都是上面第五种情况，因此选择任意一个删除 $2$ 次，再以删除了的那个为根据地，慢慢向外扩张，每次删除 $1$ 个 ```1```。因此输出 $1$ 的个数减去 $2$。
- 如果找得到一个 $2\times 2$ 的方格含有三个以下（不含）的 ```1```，则这个方格最多删除 $2$ 次，再以删除了的那个为根据地，慢慢向外扩张，每次删除 $1$ 个 ```1```。因此输出 $1$ 的个数。
- 其余情况，就是所有的 $2\times 2$ 的方格都是第四种情况，则选择任意一个 $2\times 2$ 的方格，最多删除 $2$ 次，再以删除了的那个为根据地，慢慢向外扩张，每次删除 $1$ 个 ```1```。因此输出 $1$ 的个数减去 $1$。

### 参考代码
```cpp
#include<bits/stdc++.h>
using namespace std;
long long t,n,m,sum,num;
char ch[510][510];
bool p; 
int main(){
	cin>>t;
	while(t--){
		cin>>n>>m;
		sum=0;
		p=0;
		for(int i=1;i<=n;i++)
			for(int j=1;j<=m;j++){
				cin>>ch[i][j];
				if(ch[i][j]=='1')sum++;
			}
		if(sum==0){
			cout<<0<<endl;
			continue;
		}
		if(sum==n*m){
			cout<<sum-2<<endl;
			continue; 
		}
		if(sum==1){
			cout<<1<<endl;
			continue;
		}
		for(int i=1;i<=n-1;i++)
			for(int j=1;j<=m-1;j++){
				num=0;
				if(ch[i][j]=='1')num++;
				if(ch[i+1][j]=='1')num++;
				if(ch[i+1][j+1]=='1')num++;
				if(ch[i][j+1]=='1')num++;
				if(num==1||num==2){//一个区块里面只含有
				//1 或 2 个1，那么就可以以这个为落脚点，进行
				//每次删除一个 1。 
					p=1;
					break;
				}
			}
		if(p==1)cout<<sum<<endl;
		else cout<<sum-1<<endl;
	}
	return 0;
}
```