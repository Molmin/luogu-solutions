# 思路

给大家分享一个超级简单的方法。

发现每次删除最多 $0$ 的次数的 $L$ 形最优，那我们只要保证每次删除的 $0$ 次数最大即可。

对于 $L$ 形的四种删法：

```
1:
ox
oo
2:
xo
oo
3:
oo
ox
4:
oo
xo
```

其中 $o$ 表示 $L$ 形，$x$ 表示其他元素。

发现每次消除均在一个 $2\times2$ 的空间里进行，其中保证 $0$ 的次数最多的只有如下几种：
```
1:
00
2:
0
0
3:
0
x0
```
可以定义以上三种情况为“多 $0$ 区”。

分别为横着连续两个 $0$，竖着连续两个 $0$，还有一种为对角线上有两个 $0$。如果消除的 $L$ 形内 $0$ 的分布是多 $0$ 区，就可以直接消掉剩下的其中一个 $1$。除非二位数组内不存在多 $0$ 区或者都为 $0$，我们都可以每次只消掉一个 $1$，保证收益最大。

那如果一开始并没有多 $0$ 区怎么办？

很显然可以发现，只要进行一次操作后，二维数组必定出现若干个多 $0$ 区，就像一开始给大家出示的 $L$ 形删法，删除一次后立刻就会在 $2\times2$ 的空间里出现 $3$ 个 $0$，即 $1$ 个 $1$，满足了我们对多 $0$ 区的条件。

说了这么多，我们就用一句话来概括以上全部内容：

- 如果没有出现多 $0$ 区，直接让总操作方案数 $-1$，来构造除一个多 $0$ 区，否则方案数为二维数组内出现 $1$ 的个数。

那么接下来还有一个判断，如果二维数组里面全是 $1$ 呢？例如

```
111
111
111
```
发现方案数为 $7$，$7 = 9-2$，为什么会少一个 $2$ 呢？我们的多 $0$ 区所包含的 $1$ 的个数只为 $1$，但是第一次消除，不管如何选择，$1$ 的个数始终为 $2$，所以我们需要减去 $2$。

# 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
	//定义
	
	 
	int t,n,m,i,j,cnt;
	bool f;
	char s[501][501];
	
	//输入
	 
	cin>>t;
	
	//处理 
	while(t--)
	{
		cin>>n>>m;
		getchar();//为了能让大家感受的更直观，我这里的二维字符数组行和列 都是从 1 开始的，而下面所用的 scanf("%c") 的效果等价于 getchar()，都会读入空格和换行这一类字符，所以我们要吞掉输入 n 和 m 后面的哪一个换行。 
		for(i=1;i<=n;i++)
		{
			for(j=1;j<=m;j++)
				scanf("%c",&s[i][j]);
			getchar();//吞掉末尾的换行 
		}
		cnt = 0;//cnt 表示字符 '1' 的个数 
		f = 0;//f 表示是否出现多 0 区，初值为不出现。 
		for(i=1;i<n;i++)//注意超出边界的处理，我们循环只需要到 n-1 即可。 
			for(j=1;j<m;j++)//同上 
				if(s[i][j]+s[i+1][j+1]+s[i+1][j]+s[i][j+1]-(4*'0')<=2)//找出 (i,j) 所在的 2*2 空间是否为多 0 区。 
					f = 1;//是，让 f 变为 1。 
		for(i=1;i<=n;i++)
			for(j=1;j<=m;j++)
				if(s[i][j]=='1')//查找 '1' 的个数。 
					cnt++;
		if(cnt==n*m)//特判 1，效果前文已讲。 
			cnt--;
		if(!f)//特判 2，即没有出现多 0 区。 
			cnt--;
		cout<<cnt<<endl;//输出 
	}
	return 0;
}
```
