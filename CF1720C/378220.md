## 题目大意

给你一个 $n \times m$ 的 $01$ 矩阵，每次取一个 $3$ 个字符组成的 L 形，并且至少包含一个 $1$，求最多可以取几次。

## 思路
不难想到，要让次数最多，最好情况是每次只取 $1$ 个 $1$。然而现实大多数时候往往达不到。

再考虑一下 L 形到底有什么好处。

所谓的 L 形可以看为是一个 $1 \times 2$ 的矩阵加上一个 $1 \times 1$ 的矩阵。这也就决定了只要我们的大矩阵里面有连续的两个 $0$，就可以每次只取一个 $1$。每次如果去掉了一个 $1$，就必然会有新的连续的两个 $0$ 出现。也就可以继续每次只取一个 $1$ 了。总共取的次数刚好等于这张图里面 $1$ 的个数。

推广一下，是不是只要在这张图里面任何 $2 \times 2$ 的子矩阵里面，有大于等于 $2$ 个 $0$，也可以做到每次只取 $1$ 个 $1$？

刚刚提到有两个 $0$ 的情况，但是如果没有呢？很简单，浪费 $1$ 个或 $2$ 个 $1$，将问题转化为上面的思路。如果整张图里面有 $0$，那么我们可以取包含这个 $0$ 的三个字符，最多浪费一个 $1$ 就可以用上面的做法做了。如果很不幸，整张图上全是 $1$，那么第一次怎么取都会取 $3$ 个，也就是浪费两个，这种情况最后加一个特判就可以了。

## 代码

```cpp

#include <iostream>
#include <cstring>
using namespace std;
typedef long long l;
const l maxn=505;
l arr[maxn][maxn];
int main(){
    l tt;
    cin>>tt;
    for(l u=0;u<tt;u++) {
        memset(arr,0,sizeof(arr));
        l n, m;
        cin >> n >> m;
        for (l i = 1; i <= n; i++) {
            for (l j = 1; j <= m; j++) {
                char c;
                cin >> c;//输入
                arr[i][j] = c - 48;
            }
        }
        bool flag = false;
        for (l i = 1; i < n; i++) {
            for (l j = 1; j < m; j++) {
                l cnt = (arr[i][j] == 0) + (arr[i + 1][j] == 0) + (arr[i][j + 1] == 0) + (arr[i + 1][j + 1] == 0);
                //统计每一个子矩阵是否有超过两个0。
                if (cnt >= 2) {
                    flag = true;
                }
            }
        }
        l tmp = 0;
        l ze = 0;
        for (l i = 1; i <= n; i++) {
            for (l j = 1; j <= m; j++) {
                tmp += (arr[i][j] == 1);//计算1的个数。
                ze += (arr[i][j] == 0);//计算是否有0。
            }
        }
        if (flag) {//如果子矩阵有大于等于2个0，输出1的个数。
            cout << tmp << endl;
        } else {//否则特判，这里压行了，写两个if也可以。
            cout << tmp + (ze != 0) - 2 << endl;
        }
    }
    return 0;
}
```

完结撒花。