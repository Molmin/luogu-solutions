看大家好像都是模拟的，我这里来一波数学计算的，时间复杂度大约只有O(1)。

思路，下面的各位大神已经说得很清楚了，下面再跟大家稍微解释一下。

若使n=a^2-b^2，则n=(a+b)(a-b)。

①n%4==0，则设n=4k，有a=k+1，b=k-1时等式成立；

②n%4==1，则设n=4k+1，有a=2k+1，b=2k时等式成立；

③n%4==2，则(a+b)与(a-b)中一个为奇数，一个为2的奇数倍。又因为(a+b)，(a-b)同奇偶性，所以与结论矛盾，即不成立。

④n%4==0，则设n=4k+3，有a=2k+2，b=2k+1时等式成立；

综上：n%4!=2时，均可符合n=a^2-b^2；反之亦然。

所以只需要找出n1至n2之间mod4余2的数，然后用总数减去它就行了。

然而不用枚举（要是数据再大点，就炸了），直接数学方法算就行了。

这里只详细解析n1、n2大于0的情况，其他情况由此情况均可以推得——

设mod4余2这样的数为N数，则：

n1至n2间的N数数量=n2至1的N数数量-(n1-1)至1的N数数量。可得x至1间的N数数量为：[(x+2)/4]（分类讨论即可）。所以有n1至n2间的N数数量=(n2+2)/4-(n1+1)/4（C++版公式）。

对于其他情况，比如一正一负或两负，只需要转化成上述情况，就可以算出来了。

另有解析，请看代码：

    
```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#include<string>
#include<cmath>
#include<algorithm>
#include<queue>
using namespace std;
int main()
{
    long long gs,ygs;
    long long n1,n2;
    scanf("%lld%lld",&n1,&n2);
    ygs=n2-n1+1;//求总个数
    int h1,h2;
    if(n1<=0&&n2>=0)//一正一负
    {
        h1=(n2+2)/4;
        h2=((-n1)+2)/4;//将它分成正负两段分别统计
        gs=h1+h2;//求和即可
    }
    else
    {
        if(n1>0)//均为正数
        gs=(n2+2)/4-(n1+1)/4;//同上文解析
        else//均为负数
        gs=(-n1+2)/4-(-n2+1)/4;//取相反数，然后同均为正数情况
    }
    printf("%lld",ygs-gs);//相减即是答案
    return 0;
}
```