看不懂大佬的题解 于是来一个
简单的

刚拿到这个题时，我一看难度“普及-”

于是就想直接阶乘

交了才发现 天真的我TLE了


------------
后来机房一c性大佬走了过来：

“其实算阶乘和可以用一个简单的方法，将公式变形：


>$$S=1*(1+2*(1+3*(1+4*(......1+(n-1)*(1+n)))$$


------------
于是一切就好办了

~~神犇们不要在意~~

------------

这个代码避免了高精加 只有一个高精乘和一个加1进位

~~（其实可以用递归 但我太懒没用）~~

一开始我没用倒序就WA了

但用了倒序之后就可AC

~~每个点也就3ms~~

~~（没有用优化）~~

------------
# 代码见下


------------


 ```cpp
 #include <bits/stdc++.h>
using namespace std;
int a[10000],k=1,n;
int main()
{
    cin>>n;
    for(int i=n;i>=1;i--)
    {
            a[1]++;
            for(int j=1;j<=a[0];j++)
            {
                a[j+1]+=a[j]/10;
                a[j]%=10;
            }
            if(a[a[0]+1]>0)
            {
                a[0]++;
            }
            for(int j=1;j<=a[0];j++)
            {
                a[j]*=i;
            }
            for(int j=1;j<=a[0];j++)
            {
                a[j+1]+=a[j]/10;
                a[j]%=10;
            }
            int x=a[0]+1;
            if(a[x]>0)
            {
                while(a[x]>10)
                {
                    a[x+1]=a[x]/10;
                    a[x]%=10;
                    x++;
                }
                a[0]=x;
            }
        }
        for(int i=a[0];i>=1;i--)
        {
            cout<<a[i];
        }

 }

```
