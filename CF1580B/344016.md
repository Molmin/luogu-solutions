### 题意

- 我们定义一个排列中的数字 $x$ 是好的，当且仅当包含它的子串的最大值的个数为 $m$

- 现在 Cirno 想问你，有多少长度为 $n$ 的排列满足好的数字有恰好 $k$ 个。

### 题解


出题人逆大天，$\mathcal{O}(n^5)$ 过 100，真是牛逼嗷

首先我们考虑给你一个排列，怎么确定里面的数字是好的。

假设这个数的位置是 $x$，那么子串最大值的个数就是 $[1\ldots x]$ 中的后缀最大值个数加上 $[x\ldots n]$ 的前缀最大值个数。正确性很显然。

根据笛卡尔树的经典结论，这个东西就是笛卡尔树上 $x$ 的层数。具体证明大概就是，只有 $[1\ldots x]$ 中的后缀最大值能成为 $x$ 的祖先，如果一个点 $y$ 它后面有数字大于它的话，那么这个数字会在构造笛卡尔树的过程中，把 $y$ 放到左儿子，$x$ 放到右儿子，这样点 $y$ 就不可能成为 $x$ 的祖先。反之，后缀最大值都能成为 $x$ 的祖先。而 $[x\ldots n]$ 的证明则同理。

于是问题转化成，有多少形态不同的笛卡尔树满足其层数为 $m$ 的节点数等于 $k$。

这个显然可以 dp，设 $f_{i,j,k}$ 为大小为 $i$ 的子树中，有多少点层数为 $m$，且这个子树的根离根节点的距离为 $j$


转移有 
$$
f_{i,j,k}=\sum_a\sum_b {i-1 \choose a} \times f_{a,j+1,b} \times f_{i-1-a,j+1,k-b-[j==m]}
$$

但是这样是过不去的，因为出题人会卡你常数，你需要加个剪枝，比如说我们发现一个大小为 $i$ 的子树中同一层的节点个数最多为 $\dfrac{i+1}{2}$，我们可以根据这个剪枝，于是就能常数除以 4。

我写题解的原因就是为了这个卡常（

具体看[代码](https://codeforces.com/contest/1580/submission/130537073)

