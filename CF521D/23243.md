先来考虑 1 操作，即赋值操作，发现一定是在操作序列的最前面，且每个数只能进行一次，否则会使之前的操作失效。  
其次，3 操作，即乘操作一定放在最后面，这样才能使 2 操作，即加操作的贡献最大化。  
接下来考虑怎么计算贡献，最简单的无非是 3 乘操作，因此考虑把另外两个也表现成 乘 的形式。那么对于操作 $(\text{opt},i,\text{val})$，若 $\text{opt}=3$，那么对应的贡献 $+\text{val}$；若 $\text{opt}=2$，那么对应的贡献 $+\frac{a_i+\text{sum}+\text{val}}{a_i+\text{sum}}$，其中 $\text{sum}$ 为先前进行的所有 2 操作的 $\text{val}$ 之和；若 $\text{opt}=1$，则选取其中 $\text{val}$ 最大的一个，将其转换为 2 操作，再进行操作（这一步可以在预处理时完成）。最终答案序列以 $1\to 2\to 3$ 的方式输出，保证取值最大。  
代码挂了，咕了。