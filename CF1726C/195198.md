提供一种简洁易懂的做法。

容易发现，如果形如 `((()))` 这种形态，每多一层连通块数量就加一。但是有一种特殊情况，即 `()()` 这种，理论上会产生两个连通块但是实际上只有一个。

那么我们不妨考虑在每一个左括号加入的时候，都加上 $1$ 的贡献，而在出现右括号的时候，减去那些多余的贡献。

因此我们只需要维护：

>对于每一个右括号，在直到不合法之前，匹配的左括号数量。即，对于 `()()()()` 的最后一个右括号，应该算出来 $4$。

那么我们每次就把答案减去 这个值减一 即可。

然后考虑怎么维护这个值。显然，我们可以模拟栈的操作，每次进入一个左括号就深度加一，否则深度减一。

容易发现，每次左括号压栈的时候，这一深度的贡献会加一；而每次右括号弹到一个深度的时候，所有大于它的深度的贡献将会归零。

于是直接模拟即可，代码还是非常好写的。

复杂度 $O(n)$。

## 代码

```cpp
#include <bits/stdc++.h>

// 省略巨长的缺省源。

using namespace std;

const int MAXN=200005;

char s[MAXN];
int pre[MAXN],cur[MAXN];

void solve(){
	int n; cin>>n>>(s+1);
	
	for(int i=1;i<=(n<<1);i++) pre[i]=0; // 清空数组
	
	int j=0,ans=0;
	for(int i=1;i<=(n<<1);i++){
		if(s[i]=='(') pre[++j]++,ans++; // 如果是左括号就加贡献
		else ans=ans-pre[j],pre[j]=0; // 否则减贡献
	}
	cout<<ans+1<<endl; // 输出
}

int main(){

	int T; cin>>T;
	while(T--) solve();

	return flush(),0;
}

```