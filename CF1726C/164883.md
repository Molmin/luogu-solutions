推荐[博客](https://blog.csdn.net/YunYuanWang/article/details/126758112?spm=1001.2014.3001.5501)内食用哦

# 题面

> ### 题目大意
> 
> 对于一个长度为 $2n$ 的**合法**的括号串 $s$，按照如下方法构造一张无向图：
> 
> - 括号序列的所有位置都是无向图中的一个点。
> 
> - 对于该序列的任意位置 $l$，它能向另一个位置 $r$ 连边当且仅当满足子串 $s[l, \; \dots , \; r]$ 也是一个**合法**括号串。
> 
> 求这张无向图的连通块个数。
> 
> ### 输入格式
> 
> 第一行包含一个整数 $T \; (1 \leqslant T \leqslant 10^5)$  表示测试样例组数。
> 
> 对于每组测试样例，第一行包含一个整数 $n \; (1 \leqslant n \leqslant 10^5)$ 表示序列长度为 $2n$。
> 
> 接下来的一行包含一个长度为 $2n$ 的合法括号串。
> 
> ### 输出格式
> 
> 对于每组测试样例，包含一个整数表示该串构造的无向图的连通块数。
> 
> $Translated \; by \; Zigh$

# 分析
一看到括号序列，我们第一反应一定是用栈来维护，那么这和这道题有什么关系呢？

首先我们观察下面这个括号串：
![在这里插入图片描述](https://img-blog.csdnimg.cn/db2abac3c75e4ea5ac703298726cfd58.png)
所有的 $top = k$ 的左括号只会向 $top = k - 1$ 的右括号连边，并且他们之间不能存在任何一个 $top < k - 1$ 的右括号，否则他们会被隔断， 如下图：
![在这里插入图片描述](https://img-blog.csdnimg.cn/a0ac4884d079492e96d13db5f83a96c7.png)
上图中的那条蓝色边就不应该存在，因为他们之间有一个 $0$ 阻隔。

也就是说，我们把右括号的 $top$ 单独拎出来看，我们会发现**连续**的一段**相等**的会形成一个连通块 ( 形如 AAAAAA )，或者一段连续相等的中间夹着一些比他大的会形成一个连通块 ( 形如 AAABBBAA 其中 A < B)。通过观察我们可以发现，接下来将会形成一个新的连通块有且仅当 $top_i > top_{i + 1}$。那我们只需要数出这样的对数即可，最后别忘了加上最外面一层的 $1$。

![在这里插入图片描述](https://img-blog.csdnimg.cn/680ed7dc8019466d99505f91062fb56e.png)
# 代码
```cpp
//省略快读和头文件
int T;
int n;
char str[MAXN];
int a[MAXN], cnt = 0;
int tp = 0;
int ans = 0;

int main()
{
	T = inpt();
//	scanf("%d", &T);
	while(T--) {
		ans = 0;
		tp = 0;
		cnt = 0;
		
		n = inpt();
		scanf("%s", str + 1);
		for(int i = 1; i <= 2 * n; i++) {
			if(str[i] == '(') {
				tp++;
			}else {
				tp--;
				a[++cnt] = tp;
			}
		}
		for(int i = 1; i < cnt; i++) {
			if(a[i] > a[i + 1])
				ans++;
		}
		
		printf("%d\n", ans + 1);
	}

 	return 0;
}
```
# 提醒

最后一点提醒，文件名不要直接粘贴题目名字哦，不然调试两行泪哦~

猜猜，那个题面里的 $Zigh$ 是谁呢Qwq