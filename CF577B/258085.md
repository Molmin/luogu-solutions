### 主要思路：抽屉原理+01背包

看到子序列的和我们马上想到 01背包，可是这么大的 $n$ 使我们无从下手。

这道题要求子序列之和能否为 $m$ 的倍数，也就是 $\bmod m$ 后为 $0$。

因为若干数之和再取模相当于把每个数取模后求和再取模，所以我们可以把每一个数先模 $m$。

子数组是子序列的特殊形式...然后子数组是前后两个前缀和之差...前缀和共有n个...！

当前缀和对于 $m$ 取模后的值只可能在 $[0,m)$ 之间，也就是 $m$ 种可能值。

这时候就要运用到小学二年级就学过的 ~~(雾)~~ 抽屉原理了！

这里我们要用到它的一条原理：

>把多于n个的物体放到n个抽屉里，则至少有一个抽屉里的东西不少于两件。

那我们把 $n$ 个前缀和的值放到 $m$ 个可能值里，如果 $n>m$ ，则必有相同值！

当两个相同值作差，结果为 $0$，也就是说，它们中间的这一个区间之和必是 $m$ 的倍数！

好了，$n>m$ 的情况解决完了，剩下就只有 $n\le m$ 的情况了。

整合一下此时的数据范围：

$1\le n \le m \le 10^3$

$n$ 大大缩小，可以使用 01背包 求解了。

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int n,m,a[1005];
bool f[1005][1005],yn;
int main(){
	scanf("%d%d",&n,&m);
	if(n>m){
		puts("YES");
		return 0;
	}
	for(int i=1;i<=n;i++) scanf("%d",&a[i]),a[i]%=m;
	for(int i=1;i<=n&&!yn;i++){
		f[i][a[i]]=1;
		for(int j=1;j<=m;j++){
			f[i][j]|=f[i-1][j];
			f[i][(j+a[i])%m]|=f[i-1][j];
		}
		yn|=f[i][0];
	}
	if(yn) puts("YES");
	else puts("NO");
	return 0;
}
```