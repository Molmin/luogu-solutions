### 首先，蒟蒻的我要先膜一下机房的诸位dalao
前情提要：下午dyx dalao讲数论，然而我太弱了只听懂这一道

------------
### 此题考点为抽屉原理+背包 
#### 首先是抽屉原理
抽屉原理定义为：
##### 把多于n+1个的物体放到n个抽屉里，则至少有一个抽屉里的东西不少于两件。
代入本题中我们可以发现，当得到这个序列的n个前缀和%m时，一定会出现两个相同的数，这两个前缀和相减得到的序列和一定可以被m整除。因此，当n>m时我们可以特判为序列和一定可以被m整除，从而将n的范围从1e6缩小到1e3。
#### 其次是背包
特判后，n和m的数据范围都是1e3，n方可过，直接用简单的背包dp即可求解。
```
#include<cstdio>
using namespace std;
int n,m,a[1000010],f[1010][1010],ch;
//a数组完全可以开1e3的，但是我太弱了&&太懒所以先输入后特判的……
//刚开始还没看出来结果数组开小了re了三次……
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++) scanf("%d",&a[i]);
	if(n>m) 
	{
		printf("YES\n");
		return 0;
	}
	for(int i=1;i<=n&&!ch;i++)
	{
		a[i]%=m;
		f[i][a[i]]=1; //序列中必须有数，因此不能从0状态转移
		for(int j=1;j<=m&&!ch;j++)
		{
			f[i][j]|=f[i-1][j];//不取这个数
			f[i][(j+a[i])%m]|=f[i-1][j];//取这个数
			if(f[i][0]) ch=1;
		}
	}
	if(ch) printf("YES\n"); //好像输出Yes也能过？
	else printf("NO\n");
	return 0;
}
```