**~~没人做是太偏了吗~~**

找一找其实是有规律的，因为最后要取模，所以就将日历每个数膜♂一下，取着取着发现除了前两行，后面每12行就会循环。如下：

1 2 3 4 5 6 7

8 9 10 0 1 2 3

4 5 6 7 8 9 10

0 1 2 3 4 5 6

7 8 9 10 0 1 2

3 4 5 6 7 8 9

10 0 1 2 3 4 5

6 7 8 9 10 0 1

2 3 4 5 6 7 8

9 10 0 1 2 3 4

5 6 7 8 9 10 0

1 2 3 4 5 6 7

8 9 10 0 1 2 3

4 5 6 7 8 9 10

然后将3*3矩阵加起来再取模就可以得到这个：
	
 下面代码的二维数组

*****~~言简意赅~~

上代码
   ```
#include <bits/stdc++.h> 
using namespace std;
int n,k,ans,p;
int GuiLv[12][6]= {
	{4,2,0,9,7},
	{1,10,8,6,4},
	{9,7,5,3,1},
	{6,4,2,0,9},
	{3,1,10,8,6},
	{0,9,7,5,3},
	{8,6,4,2,0},
	{5,3,1,10,8},
	{2,0,9,7,5},
	{10,8,6,4,2},
	{7,5,3,1,10}
};//找出来的规律 ，7列14行的3*3矩阵相加得出来的一个二维答案数组 
int main() {
	scanf("%d%d",&n,&k);
	ans=((n-2)/11)*5;
	if(n<=2)//因为前两行是单独的 
		for(int i=0; i<p; i++)
			for(int j=0; j<5; j++) {
				if(GuiLv[i][j]==k)
					ans++;
			}//相等就++ 
	else//而后几行是是每12行就有规律的 
		for(int i=0; i<(n-2)%11; i++)//可能会很大得取模 
			for(int j=0; j<5; j++)
				if(GuiLv[i][j]==k)
					ans++;//相等就++ 
	printf("%d\n",ans);//输出答案 
	return 0;//功德圆满 
}
```
