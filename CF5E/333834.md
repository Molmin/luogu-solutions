题目传送门：[CF5E](https://www.luogu.com.cn/problem/CF5E)。

[更好的阅读体验？](https://www.luogu.com.cn/blog/likexin/solution-cf5e)

## 题目大意：

> 有 $n$ 座围成一个环的山，每座山上都有一个看守员。两个看守员能够相互看到当且仅当连接他们所在的山的两条弧中任意一条上没有比他们更高的山，问有多少对看守员能够相互看到。

说了这么多，其实是把 [P1823](https://www.luogu.com.cn/problem/P1823) 里的队列变成了首尾相接的一个圆，其他没有任何变化。

建议先去做一下 P1823。

## 思路：

根据我们的经验，遇到环就一定要 **拆环为链** 。

但是拆环有很多方式，怎么拆才是重点。

分析一下样例，我们很快发现：对于最高峰而言，它左右两侧比他低的山是不能跨过他互相看到的。

也就是说，两两相连的山中，连线是不会跨过最高峰的。

那么我们在拆的时候就把最高峰作为第一座山，后面的山按顺序依次位移。

但是如果有多个最高峰，我们就取第一个（取最后一个也应该没问题）作为第一座山（因为最高峰之间也可以相互看到）。

剩下的就是单调栈的板了，把拆出来的链当做普通队列来处理，用单调栈处理山之间是否可以相互看到，这部分直接用 P1823 的代码即可。

但是当然没有完，考虑以下样例：

```txt
4
1 1 2 2
```

如果单纯地按照以上思路去做，那么得到的答案就会是 $4$，然而正确答案是 $6$。

为什么呢？

因为把它拆成链是这样的（把第一个最高峰当做第一座山）：

$2$ $2$ $1$ $1$

手推一下步骤后发现第一座山和第三、四座山都看不到，可是如果在环上，是可以通过另一条弧看到的。

发现这个问题只会出现在第一座山和其他山之间，那么再特判一下这种情况即可。

最后注意答案会爆 int，ans 要开 long long 的。

## 代码：

```cpp
#include<iostream>
using namespace std;
int a[1000001];
int aa[1000001];
int s[1000001];
int w[1000001];
bool pc[1000001];
int top=0;
int main(){
	//读入。
	int n;
	cin>>n;
	int maxx=-100001;
	int wz=0;
	for(int i=1;i<=n;i++){
		cin>>aa[i];
		if(aa[i]>maxx){//找到第一个最高峰。
			maxx=aa[i];
			wz=i;
		}
	}
   	//按顺序位移到 a 数组里。
	int now=0;
	for(int i=wz;i<=n;i++){
		a[++now]=aa[i];
	}
	for(int i=1;i<=wz;i++){
		a[++now]=aa[i];
	}
	long long ans=0;
	for(int i=1;i<=n;i++){//单调栈处理，搭配 P1823 食用。
		w[i]=1;
		while(top>0&&a[s[top]]<=a[i]){
			ans+=w[s[top]];
			if(a[s[top]]==a[i]){
				w[i]+=w[s[top]];
			}
			top--;
		}
		if(top){
			ans+=1;
			if(s[top]==1){ //这个位置和第一座山匹配过了，方便后面的特判。
				pc[i]=1;
			} 
		}
		s[++top]=i;
	}
	int m=0;
	for(int i=n;i>1;i--){//从后往前处理，发现算漏了就给 ans + 1。
		if(pc[i]==0&&a[i]!=a[1]&&a[i]>=m){ 
			ans++;
		}
		m=max(a[i],m);
	}
	cout<<ans;//输出。
	return 0;
}

```

[ AC 记录](https://www.luogu.com.cn/record/81020550)。