好像是第一次写AtCoder的题解。

## 这题很简单

理解题目理解了以后丝毫没有难度。



------------



有好多大神在题解里面说，这是一道 **DP题** 。

~~为什么要用 DP 呢~~。

**暴力+模拟**它不香吗……

### 首先分析一下。

	题目给了三个数，在它们之间做加法和乘法运算。
    当然，对于这三个数，不同的运算方法得到的答案是不同的。
    题目就让我们求出最大的那一个。
    
但有一点需要注意一下：

这题不考虑计算的优先顺序。

	電卓は順番に演算を行うため、演算子の優先順位は無視して左から計算します。
    因为计算器按顺序运算，所以忽略运算符的优先顺序，从左边开始计算。
    
其实这也就是加几个括号的事。



------------



运算方法分为四种：

	a + b + c
    a × b × c
    ( a × b ) + c
    ( a + b ) × c

我的做法是将这四个数塞在一个数组里，用 sort 排序，输出最大的一个。

当然**行尾要换行**。

否则~~死都不知道怎么死的~~。【滑稽】



------------



#### 有必要说一下，我不是很认同[这位 dalao 的题解](https://www.luogu.com.cn/blog/Konnyaku1/solution-at1124)

其实他考虑多了。

	题目中没有提到三个数可以互换位置。
    所以 ( a × c ) + b 这种情况其实无需考虑。
    
~~虽然写了也一样~~。



------------



### Code：

~~~C++
#include<bits/stdc++.h>
using namespace std;
int main(){
    int a,b,c;
    cin >> a >> b >> c;
    int ans[5];
    memset( ans , 0 , sizeof( ans ) );
    //这部清零好像无关紧要
    ans[1] = a + b + c;
    ans[2] = a * b * c;
    ans[3] = ( a + b ) * c;
    ans[4] = a * b + c;
    //按照暴力思路运算
    sort( ans + 1 , ans + 5 );
    //排序
    cout << ans[4] << endl;
    return 0;
}
~~~