一道巧妙的构造题。

对于题目中的 WonderTeam，因为要求是胜利场数最多的队，所以当 $n=2$ 时输出 $1$，当 $n=3$ 时，也输出 $1$，因为不能让别的球队胜利场数超过 WonderTeam，这两种情况下的最低排名都是 $1$。

当 $n>3$ 时，我们开始考虑如何让 WonderTeam 排名最低：

假设我们让 WonderTeam 赢 $1$ 局，其他比赛全部战平，那么显然别的队伍不能赶上由于 WonderTeam 的一场胜利带来的多出的 $2$ 分。

再考虑让 WonderTeam 赢两局，剩下的场次全输（即让每一个队都赢它一次），然后再让剩下的场次都平局。那么 WonderTeam 的得分为 $n+3$（$n-3$ 的平分，$6$ 分的胜利分）；被 WonderTeam 打败过的两支队伍得分为 $2n-1$ 分，剩下的队伍得分为 $2n$。考虑 $2n-1$ 和 $n+3$ 的大小关系可知，$n=4$ 时 WonderTeam 是第二，$n>4$ 时 WonderTeam 是倒数第一。
(注意这里每个队要打两场）

可以用一个表格直观地展示一下此时 WonderTeam（$a$）、WonderTeam 赢的两支队伍（$b$）、其他队伍（$c$）的胜负情况：

|  | 胜 | 败 | 平 | 得分 |
| :-----------: | :-----------: | :-----------: | :-----------: | :-----------: |
| $a$ | $2$ | $n-1$ | $n-3$ | $n+3$ |
| $b$ | $1$ | $1$ | $2n-4$ | $2n-1$ |
| $c$ | $1$ | $0$ | $2n-3$ | $2n$ |

代码如下：

```cpp
#include <bits/stdc++.h>
using namespace std;

int main()
{
	int n;
	while(cin>>n&&n)
	{
		if(n==1||n==2||n==3) cout<<1<<endl;
		else if(n==4) cout<<2<<endl;
		else cout<<n<<endl;
	}
	return 0;
}
```