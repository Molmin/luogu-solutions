本题是一个贪心

这是第一篇带 ACcode 的题解！

我调了半天呢

题面传送门：[P4995](https://www.luogu.com.cn/problem/P4995)


## 解决方案：

不难看出，本题是一个贪心的题目，我们理解一下，设 $h_0<h_1<h_2<……<h_n$，那么第一次肯定跳向 $h_n$ 而非其他地方，然后 $h_n$ 跳向 $h_0$，又跳向 $h_{n-1}$，相当于回到原来，所以只要证明第一次跳向最高的然后再跳向最矮的就命题得证。

假设第一次不是跳向 $h_n$，而是跳向了 $h_x$，此时若终点在 $h_n$ 显然跳向 $h_n$ 然后反过来跳会消耗更多体力，若终点不在 $h_n$，那么设 $h_n$ 跳了 $h_y$，那么第一步跳 $h_n$，然后从 $h_x$ 到 $h_n$ 的跳跃路径改成从 $h_n$ 原路跳到  $h_x$ 消耗显然也更大。 

所以，必然是第一步跳向最高的。

其他思路都在代码里，数据范围在 $n \le 300$。

## AC code：

```cpp
#include <bits/stdc++.h>
using namespace std;
long long n,h[500],ans,point=1;
//开数组，不解释
int main(){
   cin >> n;
   for(int i=1;i<=n;i++)cin >> h[i];
   sort(h,h+n+1);//排升序
   int l=0,r=n;//初始化两个游标
   while(r>l){ //如果游标相等或者左边的游标更小那就退出
       ans+=pow(h[r]-h[l],2);//计算跳一次后增加消耗的体力值
       l++;
       ans+=pow(h[l]-h[r],2);
       r--;//循环一次之后发现，回到了原来的样子，不过问题规模缩小了，要考虑的n少了两个
   }
   cout << ans;
   return 0;
}
```

不要抄袭！！！