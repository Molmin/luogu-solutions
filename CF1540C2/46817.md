

经过观察不难发现一些最终序列的特征：

- $a_i - a_{i - 1} \ge b_{i - 1}$

而每一次有效操作显然会同时更改两个位置的值， 注意到它们的和不变，那么本质上就是把他们差变为 $b_i$。



考虑一种简单的初始情况：

$\forall i, a_i - a_{i - 1}<b_{i - 1}$

由于无限次操作会不断地均摊这些东西，显然最终任意两个的差都是对应的 $b$，容易列方程求得每一个位置的值

然而如果初始状态存在 $\forall i, a_i - a_{i - 1}\le b_{i - 1}$，需要另当别论。因为按这种地方划分后相邻两块东西可能拼在一起也可能不会。

自闭了，于是我又看眼题目，只考虑 $a_1$ 的值？那好办了

可以通过以下方法检查一个序列：考察每个前缀拼起来后 $a_1$ 是否合法。无论它们是否真的拼起来，我们都默认它们拼起来。因为就算不是不会影响结果。

因此对于固定的询问，问题转化为每个前缀和都有一个下界，背包即可，可以前缀和优化。时间复杂度 $O(n^3)$

至此可以通过C1

当询问变多了，发现 $x$ 的值域和询问数差不多，因此可以预处理每一个询问的答案。

不难注意到大部分的询问很特别：如果 $x$ 很大，可能出现每个前缀和下界极大，即答案为0；如果 $x$  很小，可能出现没个前缀和下界极小，即答案为 $\prod c_i + 1$。我们称除了上述两种情况之外的询问为“有意义的”。

结论是“有意义的”的只有 $O(100)$ 个，也很显然，单独看每一个前缀，在它的意义下“有意义的”大概是 $O(100)$ 个连续的，而我们要对每一个前缀的“有意义的”区间右端点取min，因此最多只有 $O(100)$ 个。总时间复杂度 $O(n^4)$

至此可以通过C2


---

vp的时候B调了一年于是没时间做C呜呜呜。C1还是好过的，C2或许是一个常用的套路？