这道题如果直接说结论是很显然的，但想到比较不容易。

现在我们假设我们有一个字符在最终的字符串中存在，那么一定有被替换的字符串的该字符出现次数 $+$ 最终字符串中该字符出现的次数 $=$ 替换被替换的字符串的该字符出现次数 $+$ 原来字符串中出现的该字符次数。

举个例子，假如原来字符串是 `a`，将 `a` 替换为 `aa`，则显然有 $1+2=2+1$。

那么我们找到了一个判定方法：只要看对于一个字符，是否有上述特性就可以了。

但问题是现在 $t$ 被打乱了，如何判定呢？

我们对上面那个式子两边 $+$ $($替换被替换的字符串的该字符出现次数 $+$ 原来字符串中出现的该字符次数$)$:

被替换的字符串的该字符出现次数 $+$ 最终字符串中该字符出现的次数 $+$ 替换被替换的字符串的该字符出现次数 $+$ 原来字符串中出现的该字符次数 $=$ 替换被替换的字符串的该字符出现次数 $+$ 原来字符串中出现的该字符次数 $\times 2$。

因为替换被替换的字符串的该字符出现次数和原来字符串中出现的该字符次数一定为非负整数，所以等式右边一定是偶数，等式左边就是偶数。

又因为原来字符串的长度为 $1$，所以如果被替换的字符串的该字符出现次数 $+$ 最终字符串中该字符出现的次数 $+$ 替换被替换的字符串的该字符出现次数为奇数，则原来的字符串一定是该字符。

代码：
```cpp
#include<iostream>
#include<cstdio>
using namespace std;
void cf(){
	int n;
	scanf("%d",&n);
	int ans[27];
	for(int i=1;i<=26;i++)
		ans[i]=0;
	for(int i=1;i<=n;i++){
		string t1,t2;
		cin>>t1>>t2;
		for(int j=0;j<t1.size();j++)
			ans[t1[j]-'a'+1]++;
		for(int j=0;j<t2.size();j++)
			ans[t2[j]-'a'+1]++;
	}
	string t;
	cin>>t;
	for(int i=0;i<t.size();i++)
		ans[t[i]-'a'+1]++;
	for(int i=1;i<=26;i++)
		if(ans[i]%2){
			printf("%c\n",char('a'+i-1));
			return;
		}
}
int main(){
	int t;
	scanf("%d",&t);
	for(int i=1;i<=t;i++)
		cf();
	return 0;
}
```