### 题目大意：

有一个初始长度为 $1$ 字符串 $s_0$ 未知，接下来有 $n$ 次操作，每次可以将一个字符串 $s_1$ 替换为另一个字符串 $s_2$ 。

现在给出乱序的 $s_1$ ， $s_2$ 和最终字符串 $S$ ，求 $s_0$ 。

### 解题思路：

本题侧重于思维难度。

由于初始字符串长度为 $1$ ，本题可以考虑从每个字符单独处理。

我们对每一个字符进行分类讨论：

1.	该字符属于某个 $s_2$ ，但是后来在某个 $s_1$ 修改:

则此字符在 $s_1$ 与 $s_2$ 中各出现一次。

2.	该字符属于某个 $s_2$ ，但是后来没有被修改:

则此字符在 $s_1$ 与 $S$ 中各出现一次。

3.	该字符属于某个 $s_1$ ，修改了某个 $s_2$ 中的字符:

同情况 $1$ ，此字符在 $s_1$ 与 $s_2$ 中各出现一次。

4.	该字符属于某个 $s_1$ ，修改了 $s_0$ 中的字符:

其实此字符在 $s_0$ 和 $s_1$ 中各出现了一次，但是因为 $s_0$ 没有给出，所以此字符无法匹配！

**综上所述，所有字符串中出现奇数次的字符即为 $s_0$ 。**

### AC 代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int t,n,cnt[26];
string s;
int main()
{
	scanf("%d",&t);
	while(t--)
	{
		scanf("%d",&n);
		memset(cnt,0,sizeof(cnt));
		for(int i = 1;i <= (n<<1)+1;i++)
		{
			cin>>s;
			for(int j = 0;j < s.size();j++)
				cnt[s[j]-'a']++;
		}
		for(int i = 0;i < 26;i++)
			if(cnt[i]&1)
				printf("%c\n",i+'a');
	}
}
 
```
