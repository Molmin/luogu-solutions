看到这题，本蒟蒻发现，输入只有1个数，输出也只有1个数，于是就想打表，然后一看数据范围：$n\leqslant2000000000$，立刻就放弃了，打表肯定会$MLE$啊$qwq$。

本题要求求的是一个最小的大于等于$n$位数字的$x^x$。首先，最小的$n$位数字是$10^{n-1}$，这个比较容易证明。然后我们可以发现，当$x>n$的时候，$x^x$大于$10^{n-1}$，而$x$一定不能小于1，而所求的答案：最小的大于等于$10^{n-1}$的$x$一定在1和n之间——想到了什么？二分答案！当然直接暴力二分还是会$TLE$，不过我们可以对$x^x$和$10^{n-1}$各自取一个$\lg$，因为$\log_xa^b=b\log_xa$，所以$\lg x^x=x\lg x$，而$\lg 10^{n-1}=n-1$！这样我们就成功的降低了二分的上下限。正确性显然，但是这样我们就不会TLE了。

对于如何求$\lg$的问题，C++提供了log10函数，可以直接求$\lg$，在cmath库里。

**最后说一下，二分的时候，其实可以在区间长度大于5的时候二分，小于5的时候直接暴力枚举，可以降低一些思考难度（不用考虑一些细节问题），~~愉快的代码偷懒~~（其实这是阮行止大佬讲的），这个技巧目前没人使用。**

贴一下代码：

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>//包含log10
using namespace std;
int n;
bool f(int x)//我习惯写一个检验函数
{
	return x*log10(x)>=n-1;//对x^x和10^(n-1)分别求lg
}
int main()
{
	scanf("%d",&n);
	int l=1,r=n,mid;//最终答案x一定在1和n之间
	while (r-l>=5)
	{
		mid=l+r>>1;//比mid=(l+r)/2稍快
		if	(f(mid))	r=mid;//如果大于就在左区间寻找
		else	l=mid+1;//否则在右区间寻找
	}
	for (;!f(l);l++);//区间长度小于5，暴力枚举
	printf("%d",l);输出答案
	return 0;
}
```
然后就愉快的[AC](https://www.luogu.com.cn/record/32418038)了。