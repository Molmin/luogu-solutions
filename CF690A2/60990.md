### 题意

给定一个整数 $n$，问当 $n$ 个海盗分金子的时候第一个海盗最少需要多少金子才能不被杀死。

$\texttt{Data Range:}1\leq n\leq 10^9$

### 题解

这题好神啊……

考虑从已知金子的数量 $m$ 反推有多少海盗的时候第一个海盗不会被杀死。

当 $n\leq 2m$ 的时候是显然可以的，因为 $1$ 号只需要给除了自己以外并且编号为奇数的那些海盗每人一个金子即可。这样下来所有编号为奇数的海盗都会赞同，显然过半，因此第一个海盗会存活下来。

然而这不是全部情况。假设现在第一个海盗一个金子都没有，考虑当人数为多少的时候能存活下来。

当 $n=1,2$ 的时候，显然能够活下来。当 $n=3$ 的时候，由于 $1$ 号没有办法去贿赂剩下的海盗投赞成票，同时如果自己死了 $2$ 号仍然能存活下来，所以必死无疑。当 $n=4$ 的时候，由于 $1$ 号死了必然导致 $2$ 号死，所以 $2$ 号投赞成票，$1$ 号得以保全性命。

当 $n=5$ 的时候，除了自己没有人会投赞成票，所以必死；$n=6$ 时只有前两个人会投赞成票，还是必死；$n=7$ 的时候只有前三个人会投赞成票，仍然是必死；直到 $n=8$，由于 $5,6,7$ 号都想活下来，都会给 $8$ 号投赞成票，再加上自己的一个就可以活下来了。

接下来证明，如果没有金子的时候只有当 $n=2^k$ 时 $1$ 号才能保全，这个可以采用数学归纳法。

假设结论在 $n=2^k$ 时成立（这里假设 $k>3$，因为 $k\leq 3$ 的情况上，无法存活；$n=2^k+2$ 时只有 $1,2$ 号赞成，无法存活；以此类推，到 $n=2^k+2^k-1$ 时 $1,\cdots 2^k-1$ 号都会赞成，但是赞成的数量还是没有过半，所以还是必死。当 $n=2^{k+1}$ 时，$1\cdots 2^k$ 号都会赞成，于是能够活下来，所以结论也会在 $n=2^{k+1}$ 时成立。

最终证明了这个结论的正确性。现在当有 $m$ 个金子的时候，$1$ 号会先在前 $2m$ 个人中用手头上的金子贿赂 $m$ 个人，接下来变成没有金子的问题。所以当 $n=2^k+2m$ 的时候第一个人会活下来。

于是分析了这么多之后，$1$ 号能活下来当且仅当 $1\leq n\leq 2m$ 或者 $n=2^k+2m$，贪心即可找到当 $n$ 固定时候最小的 $m$。

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef int ll;
typedef long long int li;
const ll MAXN=2e5+51;
ll n;
inline ll read()
{
    register ll num=0,neg=1;
    register char ch=getchar();
    while(!isdigit(ch)&&ch!='-')
    {
        ch=getchar();
    }
    if(ch=='-')
    {
        neg=-1;
        ch=getchar();
    }
    while(isdigit(ch))
    {
        num=(num<<3)+(num<<1)+(ch-'0');
        ch=getchar();
    }
    return num*neg;
}
int main()
{
	n=read();
	printf("%d\n",n&1?n/2:(n-(1<<(ll)(log2(n))))/2);	
}
```