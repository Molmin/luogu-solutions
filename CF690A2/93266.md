[题目传送门](https://www.luogu.com.cn/problem/CF690A2)

这题跟 CF690A1 的唯一区别是编号为 $1$ 的海盗可以不给自己分金币。那么显然他在任何情况下永远不会给自己金币，即海盗 $1$ 获得的金币数永远为 $0$。

那么 $n$ 为奇数的情况就十分简单了，就是 CF690A1 的结论再减去 $1$ 即可，那么答案就是 $\left\lfloor\dfrac{n}{2}\right\rfloor$。

但是 $n$ 为偶数的情况会变得相当复杂。由于没有了金币数至少为 $1$ 的限制，之前的结论就不成立了。我们考虑什么情况下金币数可以为 $0$。

$n=2$ 就不用说了，考虑 $n=4$ 的情况，此时金币数可以为 $0$。因为如果海盗 $1$ 死了，那么海盗 $2$ 必然也会死，因此海盗 $2$ 无条件支持海盗 $1$ 的决策，这样海盗 $1$ 即使一个金币都不分，他也能得到两票支持，这样他就不会死，因此 $n=4$ 时答案为 $0$。

但是 $n=6$ 时，不拿出金币是不可能的，因为海盗 $3,4,5,6$ 都会投反对票，他们必然会选择票死海盗 $1$ 和海盗 $2$，然后退化成 $n=4$ 的情况，这样大家都能活下来。

因此海盗 $1$ 必须花 $1$ 个金币收买之前投反对票的一个海盗，这样他自己，海盗 $2$（海盗 $2$ 无论如何都必须支持他）和被收买的海盗都支持他，这样就有三票支持，海盗 $1$ 就能活下来，因此 $n=6$ 时答案为 $1$。

$n=8$ 时，答案可以为 $0$，因为显然海盗 $1,2,3,4$ 都会无条件投赞成票，不然他们都会死。

可以发现，当 $n=2^k$ 时，前 $2^{k-1}$ 个海盗都会投赞成票，因此答案均为 $0$。这个证明十分容易，因为显然 $n=2^k$ 的情况等价于 $n=2^{k-1}$ 的情况，依次向下退化最终必然退化成 $n=4$ 的情况。

接下来考虑 $n≠2^k$ 的情况。我们发现，$1$ 个金币就可以获得 $1$ 个海盗的支持，那么问题变成需要获得几个海盗支持。

不妨令 $n=2^k+m$（$m$ 为偶数），因为前 $2^k$ 个人不需要考虑，那么只考虑后 $m$ 个人即可，于是显然只需要收买 $\dfrac{m}{2}$ 个人。因此答案必然为 $\dfrac{m}{2}$。

然后暴力找一下最大的 $k$ 即可。

时间复杂度 $O(logn)$。

代码：

```cpp
#include<bits/stdc++.h>
#define ll long long
#define back return
#define ri register int
#define ull unsigned ll
using namespace std;
int read()
{
	int x=0,f=1;
	char ch=getchar();
	while(ch<'0'||ch>'9')
	{
		if(ch=='-')
			f=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9')
	{
		x=x*10+ch-'0';
		ch=getchar();
	}
	back x*f;
}
ll t,n,s;
int main()
{
	n=read();
	if(n%2==0)
	{
		for(ri i=1;i<=50;i++)
			if(pow(2,i)<=n&&pow(2,i+1)>n)
			{
				n-=pow(2,i);
				break;
			}
		cout<<n/2<<"\n";
	}
	else
		cout<<(n-1)/2<<"\n";
	back 0;
}
```

