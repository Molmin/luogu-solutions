# CF631B Print Check

[link](https://www.luogu.com.cn/problem/CF631B)

吐槽一下翻译：人家题面是染色，翻译后成兵马俑了…


## Sol


看见题解区里没有我这种比较暴力的做法，来一发。

### 最基础的算法——暴力


大体思路就是按照题目要求一次一次操作地做，但是，这种复杂度应该是 $\mathcal O(nmk)$ 的，显然会 T，所以我们要优化。


### 进阶——优化暴力


我们回头看一下以前做过的题：[P1003](https://www.luogu.com.cn/problem/P1003)


那道题思路是什么？不就是倒着枚举然后找到最上面的地毯吗？因此，我们这道题也可以运用相同思路，将操作存在 $x_i,y_i,z_i$ 三个数组中，统一离线处理。

思考一下，最后染的颜色一定是那个格子最后的颜色（毫无疑问）。我们将枚举方向反一下，就能瞬间求出一个格子最终的颜色。


### 终极——暴力正解



上面这种方法应该（我没试过）也过不了这道题。但是，当我们看到 $n\times m\le10^5$ 这个条件时，就发现前面那个 $n,m\le5000$ 实际上是假的。再进行一次深入思考，并再次读题，可以得出一个结论：既然它的操作都是操作行列的，那么我们可以再反着跑时记录每行每列是否被整体染过色，如果是，那么直接进入下一层循环，因为前面怎么染都会被后面的颜色覆盖掉。


实现：用 $mpc_i,mpr_i$ 来记录每列，行是否被整体染色。


当然，注意一个小细节：当枚举的格子**没被染色**时，才能赋成当前颜色。

为了减小复杂度，可以就枚举这一行或列的格子，没必要整个矩阵全部枚举，然后判断。


代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,i,j,k,x[100009],y[100009],z[100009];
unordered_map<int,int> mpr,mpc;//懒得开数组了，用map
int a[5009][5009];
signed main()
{
	int f;
	cin>>n>>m>>f;
	for(i=1;i<=f;i++) cin>>z[i]>>x[i]>>y[i];//存储，离线操作
	for(k=f;k>=1;k--)
	{
		if(z[k]==1)
		{
			if(mpr[x[k]]) continue;//如果这一行已经被整体染色，continue。
			mpr[x[k]]=1;//否则标记
			for(i=1;i<=m;i++) if(!a[x[k]][i]) a[x[k]][i]=y[k];//时间的一个优化
		}
		else//列同理
		{
			if(mpc[x[k]]) continue;
			mpc[x[k]]=1;
			for(i=1;i<=n;i++) if(!a[i][x[k]]) a[i][x[k]]=y[k];
		}
	}
	for(i=1;i<=n;i++)
	{
		for(j=1;j<=m;j++) cout<<a[i][j]<<" ";
		cout<<endl;
	}
	return 0;
}
```