- **题意简述**

给定一棵以 1 为根的有根树，对于所有正整数 $k\in[1,n]$，请求出长度为 $k$ 的反链条数。

反链的定义：对于反链中的任意一对点，不存在祖先关系。$n\le 2\times 10^5$。

- **暴力做法**

设 $f_{i,j}$ 为 $i$ 子树中有 $j$ 个点被选择的方案数。初始时 $f_{i,0}=1$ 表示不选点。每次合并一个儿子 $y$，则有如下转移：$f_{i,p+q}\gets f_{i,p}\times f_{j,q}$。最后考虑整棵子树只选根结点的方案数，$f_{i,1}\gets f_{i,1}+1$。

这是一个类似于树上背包的 DP，时间复杂度 $O(n^2)$。

- **生成函数**

可以发现合并父亲与儿子时的状态转移方程类似于卷积。考虑结点 $i$ 上转移数组的生成函数 $F_i(x)=\sum_{j=0}f_{i,j}x^j$。那么就有 $F_i(x)=x+\prod_{j\in son(i)}F_j(x)$。特殊地，对于叶子结点，$F_i(x)=x+1$。

多项式乘法中合并两个信息 $(x,y)$ 的时间复杂度为 $(|x|+|y|)\log(|x|+|y|)$。对于链或者菊花图的数据，可以轻易的卡到 $O(n^2)$。

- **树链剖分**

显然我们希望让需要合并的两个信息的大小尽量小。对原树进行树链剖分，设 $s_i$ 表示 $i$ 的重儿子。尝试分离轻儿子和重儿子的贡献，再设 $G_i(x)$ 为 $i$ 的轻儿子造成的贡献，则有：

$$
\begin{cases}
G_i(x)&=\prod_{j\in son(i), j\not=s_i}F_j(x)\\
F_i(x)&=G_i(x)\times F_{s_i}(x)+x
\end{cases}
$$

$G_i(x)$ 是许多个多项式的连乘积，可以分治计算，每次计算左右各一半，然后最后拼起来。

$F_i(x)$ 是个不好算的东西，但对于一条重链，我们可以统一考虑。设 $p_{1\dots k}$ 为一条重链从上到下构成的结点序列。

接下来，我们以 $i$ 代指 $p_i$。

由于只有 $F_1(x)$ 是我们关心的（只有它会参与其它转移），所以暴力代入 $F_1(x)$：
$$
\begin{aligned}
F_1(x) &= G_1(x)\times F_2(x)+x\\
&= G_1(x)\times (G_2(x)\times F_3(x)+x)+x\\
&\ \ \vdots\\
&= G_1(x)(G_2(x)(\cdots(G_k(x)+x)\cdots)+x)+x
\end{aligned}
$$
根据秦久韶算法，答案等于
$$
x(1+\sum_{i=1}^{k-1}\prod_{j=1}^iG_j(x))+\prod_{i=1}^kG_i(x)
$$
利用分治维护 $G_i(x)$ 的积，$G_i(x)$ 的前缀积之和即可。

还有另外一种理解方法：考虑 DP 的意义，每一条重链至多选择一个点。如果没有选点，那么所有轻子树的方案都能被算到。如果选了点，那么它前面的轻子树都能够被选，后面的都不能选，方案数就是前缀积。

- **时空复杂度分析**

对于任意一个叶子信息，显然它转移到根的过程中，至多跨越 $\log_n$ 条轻边。每次跳轻边的分治过程中，至多分治 $\log n$ 层，每层合并均摊 $\log n$；对于重链，至多经过 $\log n$ 条重链，根据刚才的分析方法，时间复杂度相同。综上所述，时间复杂度 $O(n\log ^3 n)$。

存储 $G_i$ 的空间复杂度为 $\sum_{i=1}^nsiz_i-siz_{s_i}=O(n\log n)$。使用动态数组 vector 存储重链信息，用完即删，空间复杂度相同。

这个算法的常数很小，可以轻松通过本题。

**[Code](https://www.luogu.com.cn/paste/ps2tgf2y)**