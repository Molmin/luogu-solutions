## 简要题意
给你一个 $n$，要求构造一个 $n\times n$ 的矩阵，使得从左上到右下所有长度为 $2n-1$ 的路径上的点权和互不相同。

并且要求对于若干组询问输出对应的路径。

## 解法
首先由于我们要构造出的每一条路径权值和不同，因此显然要构造出一个整数的集合，里面每一个数与一条路径一一对应。

只有这样给你这个数你才可以唯一确定这条路径。

那么我们考虑什么可以和一条路径一一对应，一个常见的转化是一个长度为 $2n-2$ 的序列，里面每一个元素取 “向下走” 或者 “向右走”。显然所有包含恰好 $n-1$ 个向下和恰好 $n-1$ 个向右的这种序列与一条路径一一对应。

注意到这个序列每一位只有两种取值，因此考虑压位，发现 $2^{50-2}=2^{48}<10^{16}$ 因此开得下。

那么现在的问题是：考虑如何构造一个矩阵使得 **所有路径的和的二进制表示可以唯一确定一个序列。** 

考虑归纳，假设我们对于一个长度为 $x$ 的 **二进制下的** 前缀已经可以确定当前位置，那么我们只需要对于 $x+1$ 这一位确定我们应该是往右还是往下。

我们可以考虑对于矩阵上的每一个位置维护出它向右是对应的二进制位取 $1$ 还是向下取 $1$，因此只需要每一位向右向下一个取 $1$ 一个取 $0$ 即可。由于我们 $x=0$ 时显然知道当前位置在 $(1, 1)$，因此后面都可以递推的构造出一条路径。

因此可以构造一个矩阵，其中偶数行都是 $0$，奇数行则考虑一个位置 $(i,j)$ 可以取 $2^{i+j-2}$，这样每一条对角线取值全部相同，而且不难发现一定对应一个新的二进制位。

最后找路径顺推即可。

```cpp
#include <cstdio>

typedef long long LL;
int n;

inline LL value(int x, int y) { return (x & 1) * (1ll << (x + y - 1)); }

int main() {
    scanf("%d", &n);
    for (int i = 0;i < n;++ i) {
        for (int j = 0;j < n;++ j) printf("%lld ", value(i, j));
        printf("\n");
    }
    fflush(stdout);

    int q; scanf("%d", &q);
    while(q --) {
        LL x; scanf("%lld", &x);
        int i = 0, j = 0;
        while(i < n - 1 && j < n - 1){
            printf("%d %d\n", i + 1, j + 1);
            const LL t = 1ll << (i + j);
            if(value(i + 1, j) == (t & x)) ++ i;
            else ++ j;
        }
        while(i < n - 1) {
            printf("%d %d\n", i + 1, j + 1);
            ++ i;
        }
        while(j < n - 1) {
            printf("%d %d\n", i + 1, j + 1);
            ++ j;
        }
        printf("%d %d\n", i + 1, j + 1);
        fflush(stdout);
    }
}

```