## 题目大意

给定 $T$ 组 $n,k$，对于每组数据，求有多少个区间在 $[2,n]$ 内且刚好包括 $k$ 个质数。

## 思路

看到要求素数个数且 $1\le n\le 100000$，考虑筛出素数之后用前缀和数组维护 $2$ 到 $n$ 之间的素数个数。这样我们就可以 $O(1)$ 求出区间素数的个数。

我们考虑从 $2$ 到 $n$ 枚举每个数，固定左端点看右端点。由于一个区间内的素数个数在固定左端点的情况下不会减少，所以我们求出恰好有 $k$ 个质数的区间的右端点时，更靠后的所有右端点肯定都是符合要求的。具体来讲，假如固定左端点 $l$ 之后求出的第一个符合要求的右端点为 $r$，符合条件的右端点个数就是：$n-r+1$。

同时，注意到我们求出的前缀和数组具有单调性，所以在求右端点时用二分查找降低复杂度。这里我用的是 `lower_bound`。注意：调用的数组下标应该减去 $1$，因为当 $i$ 本身是一个质数时也算数。我们对每个左端点统计答案并累计，每组数据的时间复杂度为 $O(n\log n)$，能过。

另外，题目中 $k$ 可以为 $0$，此时我们直接输出 $2$ 到 $n$ 中所有区间的个数，即 $\dfrac{n\times(n-1)}{2}$。如果这种情况下仍然二分查找，我们找到的右端点可能小于左端点，是错误的。

注意到在 $n=100000$ 时上面的数已经超出 `int` 范围，要开 `long long`。代码如下：

```cpp
signed main(){
	for(int i=2;i<=MAXX;i++){
		if(!isp[i]) p[++hop]=i;
		for(int j=1;j<=hop&&i*p[j]<=MAXX;j++){
			isp[i*p[j]]=true;
			if(i%p[j]==0) break;
		}
	}//这个范围其实埃氏筛也可以
	for(int i=2;i<=MAXX;i++) sump[i]=sump[i-1]+(!isp[i]);//前缀和
	t=read();while(t--){
		int n=read(),k=read(),ans=0;
		if(!k){printf("%lld\n",n*(n-1)/2);continue;}//特判
		for(int i=2;i<=n;i++)
			ans+=n-(lower_bound(sump+1,sump+n+1,sump[i-1]+k)-sump)+1;//统计个数
		printf("%lld\n",ans);
	}
	return 0;
}
```