# 思路

可以发现，第 $i$ 和 $j$ 个人必须间隔椅子把数为它们需求中最大值，否则一定有一个人不满足。

既然这样，无论当前所需间隔最大的人身边做什么人，那个人所需间隔还是最大的间隔。因为题目中说的是最小需求，于是就将当前需求最大的人放在一起，这样就不用再去考虑第二大的人了。接下来再放剩下的，重复执行直至安排完所有人。

------------

# update-证明

~~话说怎么已经交上去的题解还能被撤~~~

给出**思路**的证明：

设共有 $n$ 人，需求间隔为 $a_1 , a_2 , ... , a_{n - 1} , a_{n}$，按从小到大的顺序排列。排好序后的为 $b_1 , b_2 , ... , b_{n-1} , b_{n}$ 。所求即为 $\sum_{i = 1}^n \left\{
\begin{array}{rcl}
\max(b_i , b_{i+1})& &i ≠ n\\
\max(b_1 , b_n)& &i = n\\
\end{array} \right.
$

设 $dis_i=\left\{
\begin{array}{rcl}
|b_{i+1} - b_i|& &i ≠ n\\
|b_n - b_1|& &i = n\\
\end{array} \right.$ 

显然就是求 $\sum_{i = 1}^n dis_i$ 最小值

则最小值为 $a_n - a_1$ 等号当且仅当 $b_1 ≤ b_2 ≤ ... ≤ b_{n-1} ≤ b_n$

得证！(〃￣︶￣)人(￣︶￣〃)

------------

# 代码

```cpp
#include<bits/stdc++.h>
//我最喜欢的万能头
using namespace std;
long long t,n,m,a[200010];
//定义，数组尽量用全局变量
int main(){
    cin>>t;
    while(t--){
        cin>>n>>m;
        for(long long i=1;i<=n;i++) cin>>a[i];
        sort(a+1,a+n+1);
        //排序
        long long num=n;
        //别忘了座的人自己
        for(long long i=1;i<=n;i++)
            num+=(i==1?a[n]:a[i]);
            //第1个人和第n个人排在一起
        cout<<(num<=m?"Yes":"No")<<endl;
    }
    return 0;
    //要养成好习惯哦
}
```

## 粘代码前请三思而后行，做题是为了学习，而不是为了显摆

这是本蒟蒻递交的第一篇题解，希望管理员通过

千山万水总是情，给个点赞行不行~