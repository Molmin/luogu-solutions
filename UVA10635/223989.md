## 一、前言

本题是一道非常有意思的题目，难点主要在于**思路的转换**，算法还是比较简单的，比较锻炼思维能力。

## 二、题意

有两个序列，它们的**第一个元素都为 $1$**，除此之外**每个序列中元素都互不相同**，求两个序列的**最长公共子序列长度**。

### 小知识：子串和子序列的区别

子串是序列中**连续**的一段，子序列**不一定连续**。

## 三、思路

最长公共子序列长度（**下文以 LCS 代替**）？这个我熟！动态规划就行了。可是本题中两个序列长度范围为 $p,q \leq 62500$，而动态规划求解 LCS 时间复杂度为 $O(pq)$ 显然无法通过本题。

那么该怎么做呢？当发现**普通的做法无法通过**时，我们要看**题目是否有特殊的限定**，是否能用**特殊的方法**通过。题目多加的限制为：**每个序列中的元素互不相同**。显然，这就是我们解题的突破口。

由于**元素不会重复**，我们通过对第一个序列进行**映射**（将数值转化为**递增顺序**，类似于**离散化**），然后对第二个序列**等价映射**，就将求 LCS 变成求**最长上升子序列长度（LIS）**。

上面可能有点抽象，我们举个例子加以说明：
样例中第一个序列为

$$\{ 1,7,5,4,8,3,9\}$$

我们按照他们的顺序进行映射，重新赋值为一个新的数列

$$\{ 1,2,3,4,5,6,7 \}$$

第二个序列为

$$\{ 1 , 4 , 3 , 5 ,6 ,2 ,8 ,9
 \}$$
在将第二个序列进行等价映射，比如第二个序列中的数字 $3$ 在第一个序列位置为 $6$ ，也就是重新赋值后为 $6$，那么就把 $3$ 赋值为 $6$,得到一个新序列

$$\{ 1,4,6,4,5,7 \}$$

对于序列一中未出现的数字直接忽略，因为它们**肯定不会在 LCS 中出现**。那么新序列的 LIS 为 $4$，也就是两个序列的 LCS。

为什么这样是对的呢？因为**每个序列中元素互不相等**，那么每个数字一定与其**位置**对应。将第一个序列按**位置**重新映射后，因为位置肯定是**从小到大**的，第二个序列与其的 LCS 一定是第二各序列重新映射后的 LIS。

至于 LIS 可以用**二分贪心**求，时间复杂度为 $O(n \ log \ n)$。

## 四、代码

```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;

const int N=2e5+7;
int T,n,p,q,a[N],b[N],c[N];

int num[N],cnt,tot;
void change()//将第二个序列重新映射成新序列 
{
	memset(num,0,sizeof(num));
	cnt=tot=0;
	
	for(int i=1;i<=p;i++)
		num[a[i]]=++cnt;
	
	for(int i=1;i<=q;i++)
		if(num[b[i]])
			c[++tot]=num[b[i]];
}

int ans,up[N];

void LIS()//二分贪心求 LIS 
{
	ans=1,up[1]=c[1];
	for(int i=2;i<=tot;i++)
	{
		if(c[i]>up[ans])
			up[++ans]=c[i];
		else 
		{
			int pos=lower_bound(up+1,up+1+ans,c[i])-up;
			up[pos]=c[i];
		}
	}
}

int main()
{
	scanf("%d",&T);
	for(int t=1;t<=T;t++)
	{
		scanf("%d%d%d",&n,&p,&q);
		
		p++,q++;
		
		for(int i=1;i<=p;i++)
			scanf("%d",&a[i]);
		for(int i=1;i<=q;i++)
			scanf("%d",&b[i]);
		
		change();
		
		LIS();
		
		printf("Case %d: %d\n",t,ans);
	}
	return 0;
}
```


