## 分析题意

这道题取了一个如此销魂的题目，又有如此~~宏大的~~背景，逼逼了这么多，说到底就是这样：

在1~n这n个数中，选出k个，使得这k个数的最大公约数最大（也就是题目中说的“默契值”，下文我们称其为x）。~~我提炼得是不是很牛逼？~~

## 思路解析

这道题，我原先是这么想的：

枚举！暴力枚举所有的k个数！

这当然是不行的。（你让电脑连续运行k个循环来枚举每个数，电脑同意，题目的时间限制也不同意啊QWQ）

------------

**正确思路：**

首先我们要明确一点：**确定了x和k，就能肯定所有数的最小值（额，有点拗口，看实例）比如——x=3，则a1=3,a2=6,a3=9……直到ak=3k。**

其中k是手动输入，我们不用管他，就当它是确定的好了。

那么，我们何必再去枚举那k个数呢？——直接枚举x不就行了？~~哈哈，我真是个天才~~

明确了这点，我们再来想一想，x是多大都行吗？当然不是了！我们首先要满足k*x <= n，那么这时候的x才符合题目中的条件。换句话说，x的最大值就等于——

划重点！划重点！

```cpp
x=floor(n/k);
```

理解了这个，怎么做就不用我多说了吧？
## AC代码

```cpp
#include<bits/stdc++.h>//万能库
using namespace std;
int k,n;
int main(){
  cin>>n>>k;
  cout<<n/k<<endl;//输出的时候，系统会自动向下取整。
  return 0;
}
```

~~cgz出品，必是精品。~~