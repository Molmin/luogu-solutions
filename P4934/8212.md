# Gift Solution

标签（空格分隔）： 题解

---

一句话题解：偏序集最小反链覆盖等于最长链，优化建图。

## 20pt做法

注意到前四个测试点中，$n, k$都很小。那么只要暴力枚举每个点的编号就好了，复杂度$O(n^n)$。

## 40pt做法

前八个测试点都满足$n\le 17$，很容易考虑到状态压缩的动态规划。首先暴力枚举所有礼物的每个子集，判断是否存在两个元素违反条件，求出所有可行的子集，这一步的复杂度是$O(2^n\times n^2)$的。然后考虑dp，设$dp[S]$表示集合$S$所需的最少盒子，则有：

$$dp[S] = \min_{U\in S, U\ is\ good} dp[S-U]+1$$

这一步的复杂度是$O(3^n)$，总复杂度是$O(3^n+2^n\times n^2)$，可以通过前八个测试点。

## 60pt做法(1)

考虑式子的意义：$A\& B \ge min(A, B)$，稍有经验的选手可以一眼看出，如果将$A,B$看作集合，这个式子的意义是两个集合的交要不小于其中一个集合。那么这意味这其中一个集合是另一个集合的子集。对于一个箱子，事实上就是要求代表的集合两两互不包含。

考虑集合包含关系是一个偏序关系。不妨当$A\subseteq B$的时候从$A$向$B$连边，构成一个有向无环图。由于同一个箱子内的集合两两不能包含，不妨考虑这个DAG上最长的链。设其长度为$L$。那么这个链上的元素必然都被放到不同的箱子里，因此答案$Ans\ge L$。

对DAG最简单的算法就是拓扑排序，考虑拓扑排序的过程——每次将没有入度的点删掉。显然，所有没有入度的点之间两两互不包含。那么我们只要每次取出所有没有入度的点放进一个箱子，经过$L$次就可以将整个图取完。因此答案$Ans=L$。

那么我们用$O(n^2)$的复杂度暴力的建出这个图，然后跑一个拓扑排序。与经典的拓扑排序不同的是，每次应当将队列中所有的点都取出作为一个子集。由于拓扑排序的复杂度是线性的，时间复杂度是$O(n^2)$。

用这个做法容易证明，答案至多是$k+1$。因为最长链所代表的集合每次至少增加一个元素。

## 60pt做法(2)

这是一个在验题的时候偶然发现的做法：将所有元素从小到大排序，每次新增一个集合，暴力判断每个未被分配的元素能否加入当前集合。容易发现，这个做法和上面的做法本质上是相同的。事实上，这个做法的复杂度是$O(kn^2)$，也可以通过60分的部分。

## 80pt做法(1)

考虑60pt做法(1)，容易发现这个建图实在太暴力了。由于元素两两不同，事实上，对于每个礼物魔力值所代表的集合枚举子集，也可以建出图。这样做的复杂度是$O(3^k)$的，可以得到$80-85$分。

## 80pt做法(2)

考虑60pt做法(2)，这个做法仍然可以用枚举子集的技巧优化，复杂度是$O(k3^k)$

## 不知道多少分做法

考虑上面的80pt做法(2)，这个题对应的情景和$CTSC2018\ Gift$对应的情景很像。如果用那个题的分块技巧，可能可以得到更高的分数。

## 满分做法

考虑进一步优化建图：这次我们将边的数量限制在$O(nk)$。考虑从每一个魔力值对应的集合，只连向多一个元素到达的集合，例如从$0000$连向$1000, 0100, 0010, 0001$四个位置。这样图的结构仍然是对的。但很多节点都是无用的了。那么只需要在原来的算法上做一些改动——对于有用点，仍然像以前一样每次将所有的点取出作为一个子集；对于无用点，直接扔进另一个队列，并不断的将这个队列清空即可。这样做最后的复杂度就是$O(nk)$的了，这个问题得到了完美的解决。

## 关于spj

出题人能想到最好的spj复杂度是$O(nk^2)$的...如果有更好的想法欢迎来找出题人讨论2333