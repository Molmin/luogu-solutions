## 思路

首先显然这道题一眼就是类似树形背包的一个 dp。

对于一个点，考虑它剩下多少个点不删，记 $dp_{i,j}$ 表示第 $i$ 个点子树内，去掉包含 $i$ 的某一个联通块之后，剩下 $j$ 条边需要单独删掉的时候的最小值。

每次的转移就是枚举它的儿子，$dp_{i,j}$ 从最小的 $dp_{i,k}+dp_{v,j-k}$ 转移过来。

最后发现还有一种情况就是残暴的把 $i$ 直接删了。令 $S_i$ 为 $i$ 子树大小，则显然删除的时候的答案，是首先通过一遍 $dp$ 得到剩下 $j$ 个的时候的答案，然后我们枚举剩下多少个，显然子树大小减去剩下多少个就是我们这一次删除的数量。

显然最后的答案就是直接删 $1$ 的时候的答案，因为 $1$ 的子节点必须通过 $1$ 删掉~~而不能自己刀了自己~~。

复杂度 $O(n^2)$。注意到实现中有一些小细节：

- 建议刷表而不是查表，因为查表太难赋初始值了。

- 注意转移的顺序，避免后效性。（也可以新开一个临时数组或者转移之后赋一个 `INF` 之类的）

- 最好不要无脑从 $0$ 开始枚举背包维，应该算一下上下界，否则这道题的初始值会让你头疼不已。

- 复杂度的话为什么看起来是三维循环但是只有 $n^2$ 呢，是因为第三维和第二维的复杂度乘起来实质是 $O(\sum S_v)=S_u$，由于 $S_u$ 是 $O(n)$ 量级的，所以本质上是 $O(n^2)$ 的。其他的赋初始值等不要 `memset`，否则复杂度退化成 $O(\dfrac{2}{3}n^3)$。

其他的还有很多，我就不再赘述了。