与题目中不同的是，代价数组用 $a$ 而不是 $f$ 来表示。

#### Solution 1

直接爆搜，每一次枚举一个可以删除的节点删除它的子树。

时间复杂度 $O(n \times n!)$，期望通过数据点 $1 \sim 2$。

#### Solution 2

我们枚举所有节点是否被操作。这里操作指在某个时刻删除它的子树。

注意一个节点操作的时候它子树中的节点都已经完成了操作或者永远也不会再操作，我们就能确定删除它的时候究竟删除了几个节点，进而计算出最后的答案。

时间复杂度 $O(n2^n)$ 或者 $O(n^22^n)$，期望通过数据点 $1\sim 6$。

#### Solution 3

如果树是一个菊花，答案只能是 $a_n$。

如果树是一条链，那么令 $f_i$ 为 $i$ 被操作过，并且删掉 $i$ 的子树内的点需要的最小代价。

类似普通的背包，我们有转移 $f_i=\min\limits_{j>i}(f_j+a_{j-i+1})$，直接实现就能达到 $O(n^2)$ 的复杂度。

期望通过数据点 $7\sim 9$。

#### Solution 4

我们试图扩展链的情况的 dp。我们还是用相同的状态定义，但是转移显得没有那么简单，因为转移式变成的如下形式：（其中 $S$ 遍历 $i$ 为根的子树中所有包含 $i$ 的连通块；$L(s)$ 表示 $S$ 的叶子集合）

$f_i=\min \limits_S (\sum\limits_{t \in L(s)}f_t+a_{|S|})$

枚举 $S$ 的复杂度显得不可接受，回忆一般的树形 dp，我们希望所有信息能直接通过儿子来转移。

为此，我们修改状态如下：令 $f_{i,t}$ 为以 $i$ 为根的子树中，去掉一个包含 $i$ 的连通块并且剩下的部分恰好需要删除 $t$ 条边的最小代价。（为什么会这么设计会在后面的转移式中发现）最终要求的答案便是 $f_{1,n-1}$。

这个状态的好处是我们可以类似背包的转移。具体地，设点 $i$ 的儿子依次为 $v_1,v_2,\cdots,v_k$，那么我们有以下转移：（这里 $sz(i)$ 表示以 $i$ 为根的子树中的边数，很容易 $O(n)$ dfs 预处理）

$f_{i,j}=\min\limits_{u_1+u_2+\cdots +u_k=j}(f_{v_1,u_1}+f_{v_2,u_2}+\cdots+f_{v_k,u_k})$

$f_{i,sz(i)}=\min\limits_{j}f_{i,j}+a_{sz(i)-j}$

这里，第一个式子是 $i$ 没有被操作的情况，第二个式子则是 $i$ 被操作的情况。

第一个式子的转移虽然不能暴力枚举，但是这是一个背包问题，我们可以单独处理。

具体地，令 $g_{i,l,j}$ 为 $\min\limits_{u_1+u_2+\cdots +u_l=j}(f_{v_1,u_1}+f_{v_2,u_2}+\cdots+f_{v_l,u_l})$，那么要求的就是 $g_{i,k,j}$，并且类似背包有如下转移：

$g_{i,l+1,j}=\min \limits_{0 \le t\le j} g_{i,l,t}+f_{v_{l+1},j-t}$

复杂度乍一看是 $O(n^3)$ 的，但实际上是 $O(n^2)$ 的，证明同树形背包。期望通过所有数据点。

#### 实现细节

要达到 $O(n^2)$ 必须要把 $f,g$ 处理到合适的长度（$g$ 的 $i,k$ 这两维其实都可以不用记录的），这里说明一下上面的转移式中并没有体现具体的范围。由于 $f_i$ 只用处理 $sz(i)$ 位，$g_{i,l}$ 也只用处理 $i$ 的前 $l$ 个子树的大小和的位数。这时的复杂度证明才和树形背包类似。 如果实现不当，退化成 $O(n^3)$ 的做法只能通过数据点 $1\sim 12$，有可能通过数据点 $13\sim 14$。

