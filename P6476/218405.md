看到题解里似乎没有我这种~~瞎草的~~方法，于是来水一发

我们要充分发挥OI精神 ~~大胆猜想 不用证明~~

~~首先这题原题来自CF1260C，但是~~出题人改了题

# K可以等于$1$

不要小看这个条件，在洛谷的数据中如果没有特判的话，只有20pts

~~我jio得官方数据不会这么草~~

下面进入正题，首先我们忽略掉没有用的格子。

显然，如果一个格子有用，那么它要么是$p1$的倍数要么是$p2$的倍数。

题目则是在求**最少有多少个格子的颜色是连续的**

我们假设$p1<p2$，他们的最小公倍数为$q$，那么显然有

- 无论左侧还是右侧距离$q$最近的格子，都只能是$p1$的倍数。

- 为保证连续的颜色相同的格子尽可能少，$q$的颜色应该与$p2$相同

并且我们简单举例就可以知道

- $p1$和$p2$除以他们的最大公约数，可以简化运算，且对答案没有影响

并且我们还可以显然得出

- 我们只需要考虑$(0,q)$这一部分的格子，因为每到$nq$的时候就相当于是重新开始了一个循环。又因为$q$的颜色与$p2$相同，所以我们也不需要考虑$q$这个格子。

因为$p1$和$p2$是在互相插空，我们感性理解可以想到答案应该与$p2%p1$和$p2/p1$有关~~关于这一点手玩几个样例就能想到~~

最后在注意一下余数为$1$时候的特判，~~就能轻松拿到$20pts$啦~~

特判$k==1$才可以$100pts$

```cpp
#include <bits/stdc++.h>
using namespace std;

int gcd(int a,int b){
	return (b==0)?a:gcd(b,a%b);
}
int main(){
	freopen("color.in","r",stdin);
	freopen("color.out","w",stdout);
	int T;
	scanf("%d",&T);
	while(T--){
		int p1,p2,k;
		scanf("%d%d%d",&p1,&p2,&k);
		if(p1>p2) swap(p1,p2);
		int u=gcd(p1,p2);
		p1/=u;
		p2/=u;
		int ans=p2%p1,res;
		if(ans==0) res=p2/p1 - 1;
		else if(ans==1) res=p2/p1;
		else res=p2/p1 + 1;
		if(k==1) printf("NO\n");   //这一行，80pts
		else if(k>res) printf("YES\n");
		else printf("NO\n");
	}
	return 0;
}
```
完结，撒花！

求过QAQ
