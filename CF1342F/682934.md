这是一个 $\mathcal{O}(3^nn)$ 的做法。

先转化一下题意：假设我们确定了不删的元素集合 $A$，我们需要把删掉的数的值加到 $A$ 中的数上使得 $A$ 构成一个递增序列。

一个简单的想法是设 $f_{w,j,S}$ 表示目前 $A$ 的最后一个元素为 $j$，值为 $w$，已经用掉了 $S$ 中的数的最大答案。这个做法是不能接受的，因为 $w$ 达到了约 $10^7$ 级别。

注意到 $f_{w,j,S}\in [1,n]$，所以考虑交换值域和一维 DP 状态。重新定义 DP 数组的含义：$f_{i,j,S}$ 表示答案为 $i$，$A$ 中最后一个元素为 $j$，已经用掉了 $S$ 中的数，最后一个元素的值最小是多少。

暴力的转移即：枚举所有状态，枚举 $S$ 的补集的子集 $T$，满足 $s(T)>f_{i,j,S}$（$s(T)$ 表示 $T$ 中所有元素的和）。令 $t=\min\limits_{x\in T,x>j}x$，执行转移 $f_{i+1,t,S\cup T}\gets s(T)$，这样转移是 $\mathcal{O}(3^nn^2)$ 的，一脸不能过的样子~~虽然它过了~~。

考虑优化，发现转移的值和 $f_{i,j,S}$ 无关，于是可以考虑先枚举 $S$，并将 $\{a_{i,j}\}=f_{i,j,S}$ 和 $\{s(T)|T\cap S=\varnothing\}$ 放在一起排序，得到一个新的序列。我们从前往后遍历新的序列，并同时维护数组 $mx_i$：若当前遍历到的元素为 $f_{i,j,S}$，我们对 $k\geq j$ 执行 $mx_k\gets \max(mx_k,i)$，即表示在 $k$ 之前的最大的答案。若当前遍历到的元素为 $s(T)$，则可以枚举 $t\in T$ 并执行转移 $f_{mx_t+1,t,S\cup T}\gets s(T)$。

分析复杂度，排序的复杂度不超过 $\mathcal{O}((2^nn^2+3^n)\log(2^nn^2+3^n))=\mathcal{O}(3^nn)$，转移时两部分的复杂度分别为 $\mathcal{O}(2^nn^3)$ 和 $\mathcal{O}(3^nn)$。综上，总时间复杂度为 $\mathcal{O}(3^nn)$。 

[code](https://codeforces.com/problemset/submission/1342/210191870)