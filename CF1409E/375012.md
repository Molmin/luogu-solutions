# 分析

这是一道简单的线性 DP。

首先通过观察，可知点的纵坐标 $y$ 是不起作用的（我们可以将平台放置于纵坐标负无穷的位置）。通过对剩下的横坐标 $x$ 进行排序，我们在 $x$ 轴上得到了一系列有序的点，这些有序的点就是线性 DP 的处理线索。

让我们先将问题简化，只使用一个平台，求所能接住的点的最大数量。此时，可作为状态的信息有：`x 轴上有序的点`、`平台所能接住的点的数量`；而后者为题目所求，故状态设置呼之欲出——

$f(i)$ 表示处理到第 $i$ 个点时，平台所能接住的点的最大数量。

如何进行状态转移呢？想象一个平台在 $x$ 轴上从左往右滑动，总是试图接住第 $i$ 个点。让我们设这个已接住了第 $i$ 个点的平台此时一共接住了 `cnt` 个点，那么我们可以得到状态转移方程：

$f(i)=\max\{f(i-1),cnt\}$

现在我们需要放置两个平台，于是可以作为状态的信息增加了一个`已放置平台的个数`，于是本题的状态设置为——

$f(i,j)$ 表示处理到第 $i$ 个点，已放置了 $j$ 个平台时，所能接住的点的最大数量。（当然，$j$ 可以取 $0$ 和 $1$ 来分别代表放置了 $1$ 和 $2$ 个平台）

让我们设这个已接住了第 $i$ 个点的平台此时一共接住了 `cnt` 个点，接住的第一个点是 $x$ 轴上从左往右的第 `k` 个点，那么我们可以得到状态转移方程：

$\begin{cases}f(i,0)=\max\{f(i-1,0),cnt\}\\f(i,1)=\max\{f(i-1,1),f(k-1,0)+cnt\}\end{cases}$

如何求得 `cnt` 与 `k` 呢？可以参考滑动窗口的处理方式，从第一个点开始作为平台的左端点，由于长度确定，此时平台右端点也被确定，平台所能接住点的范围也就确定了。每加入一个点 $i$ ，如果在平台所能接住点的范围内，`cnt` 就加一；如果在范围外，就右移平台（左端点更改为下一个点），每右移一次 `cnt` 便减去一，直到点 $i$ 能够被平台接住。`k` 就是平台左端点。

# AC代码

```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAXN = 2e5 + 10;

int t, n, k, x[MAXN], f[MAXN][2];

int main()
{
    scanf("%d", &t);
    while (t--)
    {
        scanf("%d%d", &n, &k);
        for (int i = 1; i <= n; i++)
            scanf("%d", &x[i]);
        for (int i = 1; i <= n; i++)
            scanf("%*d");
        sort(x + 1, x + 1 + n);
        for (int i = 1, j = 1, cnt = 1; i <= n; i++)
        {
            while (x[j] + k < x[i])
                ++j, --cnt;
            f[i][0] = max(f[i - 1][0], cnt);
            f[i][1] = max(f[i - 1][1], f[j - 1][0] + cnt);
            ++cnt;
        }
        printf("%d\n", f[n][1]);
    }
    return 0;
}
```