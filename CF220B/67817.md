#### 前言

表示这道题目，大家都没有利用好那256MB的空间 ~~(只是我的做法比较辣鸡，需要很多空间)~~

#### 思路

这道题未必需要什么**莫队**,**树状数组**,**线段树**,**分块**。

(用今天比赛的时候YY出来的题目的性质过的，貌似跟Kewth是一个思路欸，多了些解释，求过)

直接观察题目性质并且利用好256MB空间，然后用前缀和用 O($(q+n)\sqrt{2 * n}$)的时间 莽过去就行了。

这道题目有一个优秀的性质：

虽然给定的数的大小可能为 $10 ^ 9$。但是，并非所有数都是有用的，更加确切的说，实际上有用的数不超过 $\sqrt{2 * n}$  种。

此话怎讲（看起来我在搞玄学）？听我细细道来。

首先，如果一种数，（在整个区间中）其出现次数小于等于自己的大小，那么这个数铁定“没用”了，其无论如何也无法在答案中做出贡献，这样子的数，是肯定可以删掉的。

什么情况下被留下来的数最多？ 不难发现，当每个数的大小尽量小的时候才能留下来的数最多，倘若想留下尽可能多的数，其中的最优情况就是留下了$1$ ， $2$ ， $3$ , ... , $k$ ，根据等差数列求和公式，那么 $\frac{k*(k + 1)}{2} <= n$

这样子，留下来的 $k$ 个数最大就只能是 $\sqrt{2 * n}$  种了。这也是本人用的算法的最坏情况。

仔细计算，发现 $\sqrt{2 * n}$ 最大不会超过 $450$ ， 然后 $450$ * $10 ^ 5$ 的空间消耗大概是 $170MB$ 。 于是我浪得飞起，直接开上 $500 * 10^5$ 的前缀和数组。对于每一次查询，只需要枚举有多少种数被包含在这个区间内的数量**恰好**等于其大小即可。

于是我们就用空间复杂度: O($n\sqrt{2 * n}$) 时间复杂度: O($(q+n)\sqrt{2 * n}$) 的 ~~优秀~~ 乱搞做法过了这一题。

人菜话多，写得很长。就啰嗦到这里了。

### Code

```cpp
#include <bits/stdc++.h>
using namespace std;
int sum[505][100005];//暴力开数组
const int MAXN = 100005;
int n,q;
int a[MAXN];
map <int ,int > book,vis;//这里是记录信息用的两个map
int New[MAXN],tot = 0;

inline int read()//这里是快读
{
    int x = 0 , flag = 1;
    char ch = getchar();
    for( ; ch > '9' || ch < '0' ; ch = getchar());
    for( ; ch >= '0' && ch <= '9' ; ch = getchar()) x = (x << 3) + (x << 1) + ch - '0';
    return x * flag;
}

signed main()
{
    n = read(), q = read();
    for(int i = 1 ; i <= n;  i ++) 
    a[i] = read(),book[a[i]] ++,vis[a[i]] = 1;//这里是在统计信息
    
    for(int i = 1 ; i <= n ; i ++)
        if(book[a[i]] < a[i])
        vis[a[i]] = 0,a[i] = 0;//这里是在删去无用的数
 
    for(int i = 1 ; i <= n ; i ++)
        if(vis[a[i]] == 1) 
        tot ++ , New[tot] = a[i] , vis[a[i]] ++;//这里是在统计有用的数
        
    for(int i = 1 ; i <= n ; i ++)
        for(int j = 1 ; j <= tot ; j ++){
            sum[j][i] = sum[j][i - 1] ;
            if(New[j] == a[i])sum[j][i] ++;//统计前缀和
        }

    for(int i = 1 ; i <= q ; i ++){
        int l = read() , r = read();
        int Ans = 0;
        for(int j = 1 ; j <= tot ; j ++)
            if(sum[j][r] - sum[j][l - 1] == New[j])Ans ++;//暴力统计答案
        printf("%d\n",Ans);
    }
    return 0;
}
```

### 后话

我得承认我的做法比较劣(过不了今天的比赛题，比赛的时候还是老老实实写了莫队)，但是貌似这个题目是可以观察性质简单的过掉的，代码比较短。

还有一个性质，不知道怎么用。对于一个区间的询问，其答案小于等于$\sqrt{2 * len}$的，这个东西我不大知道怎么用，但是相信聪明的你某天路过看到的时候，说不定就能用上这个性质了。

(代码修正了一下，求管理通过)