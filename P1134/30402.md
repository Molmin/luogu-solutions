/\*
基本思路：纯模拟，算0前的最后1位。

末尾0就是多个10相乘得来的 ，我们只需要在相乘算个位数时将末尾0的个数的2,5提前约去即可

计算末尾0的个数，只需要计算1~n中有多少个因数5，因为因数2的个数肯定比5多 ，每一组2,5凑成10.

计算出来后，在从1~n相乘时，约去对应个数的2，5，再取 个位，结尾肯定没有0，膜10得来的数就是答案。

具体代码见下

\*/



```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
    int n,s=1,k1=0,k2=0;//s计算结果，k1,k2分别计算2,5需要除去的个数 
    scanf("%d",&n);
    for(int i=2;i<=n;i++)
    {
        int m=i;//i是不能随便除的，我们把它的值赋给m 
        while(!(m%5))
            {
                m/=5;
                k2++;//只用计算因数5的个数 
            }
    }
    k1=k2;//2也只需要除这么多 
    for(int i=2;i<=n;i++)
        {
            int p=i;//i不能随便除 
            while(!(p%2)&&k1)//整除，并且次数够 
            {
                p/=2;
                k1--;
            }
            while(!(p%5)&&k2)//同理 
            {
                p/=5;
                k2--;
            }
            s*=p%10;
            s%=10;//只用计算个位 
        }
    printf("%d",s);
    return 0;
}
```