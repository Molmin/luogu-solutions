希望管理员能撤销部分题解，那些题解并没有严格证明其做法的正确性，反而像是试出来的答案。

发现高赞题解都是通过直接$\%1000000$来做的？

但是简单想想，进位是可能一直进位到最高位的，所以直接取末尾的方案我是理解不了也证明不了正确性的。

但是，我们可以用质因数拆解来做这题，我们知道，末尾的$0$都来自于质因数$2$和$5$相乘，其他的质因数都无法乘出末尾为$0$简单证明下：

1.没有末尾为$0$的质数，不然就会存在10的因子，所以不可能有。

2.任何一个两个数相乘，最末尾的值一定是两个数的个位数相乘得到的数的个位数。

两个数的个位数相乘后的数字的个位数字是$0$的，要么某个的个位数本来就是$0$，要么就是偶数和$5$，由$(1)$已经知道末尾不是$0$，并且是质数的只有$2$和$5$了。

在$[1,n]$区间里$2$的质因数个数一定是多于$5$的。

所以我们只需要求出$5$的质因数个数，假设是$k$个，我们就在阶乘中约去$k$个$2$和$k$个$5$。

那么会不会超时呢？明确不会，$k$和$n$是同一数量级的，我们在阶乘过程中是均摊的$k$,所以总复杂度还是$O(n)$。

```
#include <bits/stdc++.h>
using namespace std;

int n;
long long ans=1;
long long last=10;
int main()
{
    scanf("%d",&n);
    int maxn=5;
    int k=0,p;
    while(1)
    {
        k+=n/maxn;
        maxn*=5;
        if(maxn>n)break;
    }
    p=k;
    for(int i=1;i<=n;i++)
    {
        int lins=i;
        while(lins%2==0&&p)
        {
            lins/=2;
            p--;
        }
        while(lins%5==0&&k)
        {
            lins/=5;
            k--;
        }
        ans=(ans*lins)%last;
    }
    printf("%lld\n",ans);
    return 0;
}

```
