这道题首先也是想到模拟，也用了楼下几楼的题解中的模拟方法，但最后一个点一直TLE（P党伤不起）。

看到了大神的算法，感觉楼下的思路描述太过简洁，思考n久终于顿悟，思路如下：

N！的末位0是来自于所有乘数的因数5和2相乘，有多少个因数5就有多少个末位0（因数2个数远大于因数5个数）

（1）先将所有含有因数5的乘数（5,10,15,20，....）跳过不乘，先算所有不含因数5的数的乘积最后一位，

发现除了初始1以外有规律可循：

1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 ...

1 2 6 4 X 4 8 4 6  X  6   2   6   4   X   4   8   4   6   X

每10项为一个循环

（2）再来计算乘5,10,15,20..... （共n div 5个）

我们将所有因数5提取出来，就有5^(n div 5)\*1\*2\*3\*4\*...\*n div 5

先来解决5^(n div 5)，乘以一个5，就会有一个2和它组合成0，所以乘以5相当于除以2

2的尾数为 2,4,8,6,2,4,8,6....4个数一个循环，除以2就前移一位，也就相当于乘以8（后移3位）

所以乘以5的尾数和乘以8的尾数是一样的，4个一循环

再来解决1\*2\*3....\*n div 5，显然可以递归解决！

再来看代码：


```cpp
var i,j,n,ans:longint;
    ba:array[0..3] of longint=(6,8,4,2);
    a:array[0..9] of longint=(1,6,2,6,4,4,4,8,4,6);//第5个数应该是相等于第4个
begin
   readln(n);
   if n=1 then begin writeln(1);halt;end;//1特判
   ans:=1;
   while n>0 do
   begin
     ans:=ans*a[n mod 10];//10个一组有规律
     n := n div 5;//n缩小规模
     ans := ans*ba[n mod 4] mod 10;//n个5相乘，4个一组有规律
   end;
   writeln(ans);
end.

```