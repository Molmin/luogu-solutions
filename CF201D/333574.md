## Tags:DP，优化
[原题](https://codeforces.com/contest/201/problem/D)
#### 题目大意
有 $n$ 个按顺序排列的单词，$m$ 句话，每句话由 $k$ 个单词组成。定义一句话的“差异度” $x$ 为这句话中是给出单词排列的子序列与原单词排列的最小交换次数。找到最小的 $x$，定义相似度 $p=\frac{n(n-1)}{2}-x+1$ ，输出最小 $x$ 所在话的编号，然后输出`[:`，`|`重复 $p$ 次和 `:]`。如果没有匹配的话，输出`Brand new problem!`。

这里，“交换次数”的定义如下：

假设原来的序列是`1 2 3 4`，现在的序列是`1 4 2 3`，则交换次数为 $2$。更通俗地说，将原序列中的单词按 $1,\dots,n$ 编号，则交换次数就是新序列对应后的逆序对数量。

数据范围：

$1 \leq n \leq 15,1 \leq m \leq 10,1 \leq \sum k \leq 5 \times 10^5$

保证 $n$ 个单词两两不同，每句话中单词可以重复。

#### 分析
为简化题意，我们可以用 map 给单词编号，然后取每句话中有编号的单词形成一个由 $1,\dots,n$ 构成的序列。问题转化为：

求一个包含 $1,\dots,n$ 的序列中是 $1,\dots,n$ 排列的子序列中最小的逆序对数。

注意到 $1 \leq n \leq 15$，可以很容易地想到一个状压 dp：

定义 $dp_{i,j}$ 表示考虑前 $i$ 个数，选数状态为 $j$ 时最小的逆序对数。

对于每个 $i$ 有选或不选两种情况，从 $i-1$ 转移即可。这里不再赘述。

可以知道上述方法尽管可以用滚动数组将空间优化到 $O(n)$，但时间复杂度不可避免地是 $O(k2^n)$，无法优化。

考虑交换上述方法中的 dp 定义和值，得到一个新的 dp：

定义 $dp_{i,j}$ 表示**最小**的 $k$，使在新序列中前 $k$ 个数满足选数状态为 $i$，且相似度 $p$ 为 $j$。

考虑从当前状态向后转移，需要知道之后第一个出现某数的位置。

我们记 $next_{i,j}$ 表示满足 $k>i$ 且 $sequence_k=j$ 的**最小**的 $k$。

每次从后往前扫，可以在 $O(nk)$ 的时间复杂度下完成 $next$ 数组的统计如下：

```cpp
for(int i=1;i<=n;i++)nxt[cnt][i]=cnt+1;
for(int i=cnt-1;i>=0;i--)
{
	for(int j=1;j<=n;j++)
        	nxt[i][j]=nxt[i+1][j];
	if(seq[i+1])nxt[i][seq[i+1]]=i+1;
}
```
（$cnt$ 是序列的长度）

那么有转移方程如下：

```cpp
for(int c=0;c<(1<<n);c++)
{
	for(int i=0;i<=n*(n-1)/2;i++)
	{
		if(dp[c][i]<cnt)
		{
			int ord=0;//顺序对（相似度增量） 
			for(int j=1;j<=n;j++)
			{
				if((c&(1<<j-1))==0&&nxt[dp[c][i]][j]<=cnt)
				{
					dp[c^(1<<j-1)][i+ord]=min(dp[c^(1<<j-1)][i+ord],nxt[dp[c][i]][j]);
				}
				else if(c&(1<<j-1))ord++;
			}
		}
	}
}
```

总共时间复杂度为 $O(m(nk+n^32^n))$，约为 $2 \times 10^8$。本题时间限制为 $5$ 秒，可以通过。

（代码关键部分上文已给出，不再给出全代码）