为什么不用用神奇的 `bitset` 呢？

-----

此类题目的一个经典 trick 是横纵无关，即横向移动与纵向移动相互独立。这很好理解，因为你一开始横着（向右），旋转一次以后不管往左还是往右，转完都只能纵向移动，再旋转一次以后又变成只能横向移动，……并且在旋转之前只能朝着上次决定的方向走，所以连续的若干个前进指令可以被压缩为一个“前进若干步”的指令。我们发现，除了一开始被题目强制指定的朝着 $x$ 轴正方向以外，接下来到底是转向正方向还是反方向都是我们可以决定的。

然后就可以把横向和纵向分别处理，问题转化为经典的动态规划：在一个坐标轴上有若干条指定距离的指令，第 $i$ 条指令的距离为 $d_i$ ，求是否可通过改变指令方向来到达某个点。

设 $f_{i,j} ∈ {0,1}$ 表示考虑到第 $i$ 个指令时，是否可以到达点 $j$ 。 则有 $f_{i,j}=f_{i-1,j-a_i}\  \operatorname{or}\  f_{i-1,j+a_i}$ 。复杂度 $O(n^2)$，是对的，但是我们的坐标轴长度差不多有 $8000$ 的样子，跑起来有点虚。

于是我们用滚动数组和 `bitset` 优化一手，顺便节省下码量。这样一来直接令 `f[i]=(f[i-1]<<a[i]) | (f[i-1]>>a[i])` 即可。时间复杂度 $O(\frac{n^2} {w} )$，跑得嗷嗷快。

```cpp
const ll maxn=8e3+5;
char c[maxn];//读入指令
bitset<16005>f[2];
ll a[2][maxn],cnt[2];//0为横向，1为纵向
ll s;
void solve(){
	cin>>(c+1);
	ll n=strlen(c+1)+1;
	c[n]='T';//设置不存在的最后一位为转向，便于统计
	ll x=R,y=R;
	ll p=1;
	while(c[p]!='T')p++;//预处理出固定方向的第一个指令。这个的方向不受我们控制，所以要特判。（其实后面的操作取个反就行了，影响不大）
	s=p-1;
	bool cur=0;
	ll tmp=0;
	for(ll i=p;i<=n;i++){
		if(c[i]=='T'){
			a[cur][++cnt[cur]]=tmp;
			tmp=0;
			cur^=1;//改变方向
		}
		else tmp++;
	}
	f[0][s+(ll)8e3]=1;//注意是从预处理出的起点开始而不是原点
    //加上8e3是为了处理负数坐标，做一个水平平移
	for(ll i=1;i<=cnt[0];i++){
		f[1].reset();//清空当前
		f[1]=(f[0]<<a[0][i])|(f[0]>>a[0][i]);//转移
		f[0]=f[1];//滚动
	}
	if(!f[0][x+(ll)8e3]){
		puts("No");//横向已经挂掉了就已经不可能了
		return ;
	}
	f[0].reset();//清空，接着做纵向
	f[0][(ll)8e3]=1;//纵向就是从原点开始了
	for(ll i=1;i<=cnt[1];i++){
		f[1].reset();
		f[1]=(f[0]<<a[1][i])|(f[0]>>a[1][i]);
		f[0]=f[1];
	}//同上
	if(!f[0][y+(ll)8e3]){
		puts("No");
		return ;
	}
	puts("Yes");
	return ;
}
```

