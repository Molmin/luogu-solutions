不到 400b 而且可读的代码。

### 一、做法

一开始的思路是针对每一个 `T` 左转还是右转来搜索，但是这样时间复杂度爆炸。

然后就是正解。假设在现在操作到的位置之前有 $c$ 个 `T`，分类讨论。

1. $c=0$，机器人的方向一定是 $x$ 轴正方向。
2. $c=1,3,5,7,9,…$，机器人的方向一定可以是并且只能是 $y$ 轴的正方向或者负方向。
3. $c=2,4,6,8,10,…$，机器人的方向一定可以是并且只能是 $x$ 轴的正方向或者负方向。

这一性质可以用数学归纳法证明。

所以我们可以在去掉 $c=0$ 的所有字符影响后，以 $c$ 的奇偶性将机器人的横纵坐标分开来考虑。这个可以用动态规划做。

以横坐标为例，我们把一段段的 `F` 的长度记录下来。假设已经遍历完了的最近一段 `F` 长度为 $w$。我们用一个 `bool` 值 $x_{i-1,j}$ 代表这次操作前能否达到第 $j$ 位，那么这一次操作可以是减少横坐标，也可以是增加横坐标。所以我们就有 $x_{i,j}=x_{i-1,j+w}\operatorname{or}x_{i-1,j-w}$，其中 $\operatorname{or}$ 是逻辑或运算。然后这个东西就是一堆逻辑或运算，所以我们可以用滚动数组优化和 `bitset` 优化，直接将一次转移写成 `x=x<<w|x>>w`。

最后就是判断所有操作后能否同时达到最终的横纵坐标。

时间复杂度 $O(\frac{n^2}{\omega})$，可以通过此题。

注意途中横纵坐标在不断减的时候很可能变为负数，所以要加上一个值保证下标恒为正。

### 二、代码

最后就是这个不到 400b 的代码了。末尾加上一个 `T` 是为了处理最后可能出现的一段 `F`。

```cpp
#include<bits/stdc++.h>
#define z 16005
using namespace std;
int n,X,Y,p,c,w;
string s;
bitset<z*2>x,y;
int main(){
	x[z]=y[z]=1;
	cin>>s>>X>>Y;s+="T";n=s.size();
	for(int i=0;i<n;i++)
		if(s[i]=='T'){
			if(!c)X-=i;
			else if(w=i-1-p){
				if(c&1)y=y<<w|y>>w;
				else x=x<<w|x>>w;
			}
			p=i;c++;
		}
	if(x[z+X]&&y[z+Y])cout<<"Yes\n";
	else cout<<"No\n";
	return 0;
}
```