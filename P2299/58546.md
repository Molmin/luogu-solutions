具体思路是迭代。

每次优化两个站点之间的路。一直迭代直到不能再优化了，最后输出。

------------
我们拿
```
3 3
1 2 5
2 3 3
1 3 7
```
做例子（是不是有点太简单了
![](https://cdn.luogu.com.cn/upload/pic/60721.png)

照着代码来讲

我们只看$a$数组的前三个，现在目前是$\{0,\infty,\infty\}$

扫一遍，发现$1$到$2$之间可以优化，把$ok$置零，并且更新数组：$\{0,5,\infty\}$

然后$2$到$3$之间也有路，数组变成$\{0,5,8\}$，注意目前是$8$，因为$1$到$3$之间没有路，只能通过$1-2-3$的路线，所以就是$5+3=8$。

接下来看到$1$可以去$3$，时间是$7$，看一下$a$数组的第$3$个是$8$，所以$1$到$3$优化一下$\{0,5,7\}$

再扫一次，看一下有没有可以优化的，发现没有，最后输出$a[3]$，所以就是$7$。

------------

代码：
```cpp
#include<bits/stdc++.h>
int m,n,f[1000001],t[1000001],a[5005],y[1000001],ok;
//f是来自的停站点，t是到达的停站点，y是时间，a[i]代表1号站点到i号站点最短的路。
int main(){
    scanf("%d%d",&n,&m);
    for(int i=2;i<=5000;i++)a[i]=1e7;//初始化1到每个停站点间需要无穷大的时间（站点之间没有路）
    a[1]=0;//注意1可以去到本身不用时间
    for(int i=0;i<m;i++)scanf("%d%d%d",&f[i],&t[i],&y[i]);
    while(!ok){//一直迭代直到不能再优化
        ok=true;//假装不能再优化了
        for(int i=0;i<m;i++){//循环把所有站点扫一遍
            if(a[t[i]]>a[f[i]]+y[i]){a[t[i]]=a[f[i]]+y[i];ok=false;}//如果到最后的点还有更短的路就把ok置为0并且更新数组
            if(a[f[i]]>a[t[i]]+y[i]){a[f[i]]=a[t[i]]+y[i];ok=false;}//因为是无向的，所以返回来的路也得优化
        }
    }
    printf("%d",a[n]);//输出最短的时间
}
```