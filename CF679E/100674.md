[噜啦噜啦咧噜啦噜啦咧的阅读体验！！！](https://www.cnblogs.com/dysyn1314/p/14139849.html)



# CF679E Bear and Bad Powers of 42

[题目链接](https://codeforces.com/problemset/problem/679/E)

## 本题题解

> 根据笔者的习惯，我们称要维护的序列为 $a_{1\dots n}$，即原题面里的 $t$。

设经过任何操作后，序列里的最大数值为 $\text{maxValue}$。则 $\text{maxValue}\leq 10^9 + q\times 10^9\times \log_{42}(\text{maxValue})$。容易发现 $\text{maxValue}$ 不会超过 $\texttt{long long}$ 范围（这只是一个粗略的估计，实际上更小）。

因此，可能出现的 $42$ 的幂数量非常少，不超过 $\log_{42}(\text{maxValue})\leq 13$ 个。

---

先不考虑操作 $2$（区间赋值）。

用线段树维护序列，支持区间加。考虑在进行操作 $3$（区间加）时，写一个暴力的 $\texttt{while}$ 循环：只要区间里出现了 $42$ 的幂，就再加一次。因为每个数最多只会出现 $\log_{42}(\text{maxValue})$ 次等于 $42$ 的幂的情况，因此总的操作次数是 $\mathcal{O}(n\times \log_{42}(\text{maxValue}))$ 的。

于是问题转化为，如何快速判断，区间里是否存在 $42$ 的幂。

对于序列里的每个数 $a_i$，记第一个大于等于它的、$42$ 的幂为 $b_i$，即 $b_i = 42^{\lceil\log_{42}(a_i)\rceil}$。考虑 $b_i - a_i$ 这个序列，一次“区间加 $x$”，相当于令这个序列上每个位置减 $x$。当出现某个位置上数值 $b_i - a_i < 0$ 时，说明该位置的 $b_i$ 需要更新了，我们暴力更新（根据前面的分析，总更新次数是 $\mathcal{O}(n\times \log_{42}(\text{maxValue}))$ 的）。更新完后，如果出现某个位置上 $b_i - a_i = 0$，就说明原序列（$a$）里存在 $42$ 的幂，我们继续执行区间加。

也就是说，现在我们维护 $b_i - a_i$ 这个序列，支持区间加、单点修改（暴力更新 $b_i$）、求区间最小值。可以用线段树实现，这样单次修改时间复杂度是 $\mathcal{O}(\log_2(n))$ 的。总时间复杂度 $\mathcal{O}((n + q)\times \log_{42}(\text{maxValue})\times \log_2(n))$。

---

再考虑有操作 $2$ 的情况。如果我们直接在线段树上执行区间赋值，就可能会影响前面的复杂度分析：因为此时无法保证 $a$ 序列每个位置上数值都随时间单调变大，也就无法保证总更新次数只有 $\mathcal{O}(n\times \log_{42}(\text{maxValue}))$ 了。

设一次操作 $2$ 的区间为 $[l,r]$，考虑只修改 $r$，然后把区间 $[l,r - 1]$ 设为一个“懒惰状态”。形式化地，懒惰状态满足：

- 在区间加（操作 $3$）检查更新 $b_i$ 时，不会被更新到。
- $a_n$ 不会处于懒惰状态（因为每次只把 $[l,r - 1]$ 设为懒惰状态，显然 $r -1 < n$）。
- 如果 $a_i$ 处于懒惰状态，则 $a_i$ 的实际数值，等于它后面第一个非懒惰状态的值（根据上一条，这样的值一定存在）。

例如，在实现时，我们令 $b_i$ 不变，把 $a_i$ 变成 $-\infty$，这样 $b_i - a_i$ 就永远 $> 0$，区间加检查更新时永远不会被更新到。 

初始时，所有值都处于非懒惰状态。在执行操作 $2$ 时，把区间 $[l,r - 1]$ 里所有值暴力设置为懒惰状态（线段树单点修改）。在执行操作 $2$ 或操作 $3$ 前，检查 $l - 1$, $r$ 这两个位置，如果是懒惰状态，则将它们更新：找出它后面第一个非懒惰状态的值，把被更新的位置赋为这个值。

实现时，可以用一个 $\texttt{std::set}$ 来维护所有非懒惰状态的位置。更新时，用 $\texttt{std::set}$ 的 $\texttt{lower_bound}$ 进行查找。

分析这样做的时间复杂度。在每次操作中，只会增加 $\mathcal{O}(1)$ 个非懒惰状态（$l - 1$ 和 $r$），因此整个过程中，出现的非懒惰状态总数是 $\mathcal{O}(n + q)$ 的，这样插入和暴力删除的总时间复杂度都是 $\mathcal{O}((n + q)\times \log_2(n))$ 的。同时，在线段树中，我们只进行了 $\mathcal{O}(n + q)$ 次“把某个位置的值重置”的操作，而其它情况下值都是随时间单调变大的，于是可以套用之前的复杂度分析。

综上，我们在 $\mathcal{O}((n + q)\times \log_{42}(\text{maxValue})\times \log_2(n))$ 的时间复杂度内解决了本题。

## 参考代码


[勇敢向前进，前进有奖品！！！](https://www.cnblogs.com/dysyn1314/p/14139849.html)
