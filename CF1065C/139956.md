#### 闲聊
> 暴力碾标算，$n^2$ 过百万。

这句话在这题里还真有点灵验了。

---
#### 思路

我们看到题目中 $n\le2e5$ 的数据，肯定首选 $O(n\log n)$ 的算法(或许还有更牛的？)。

但是这里介绍一种复杂度大约为 $O(h+n)$，其中 $h$ 为序列中的最大数，下同。这样的一种**暴力**。虽然常数可能较大，但是足以 AC。

---
前置芝士：
1. 语言基础
1. 差分

---
先来讲讲 $O(h)$ 的预处理。

我们要统计出 $tong_{1\cdots n}$，其中 $tong_i$ 表示在序列中有几个大于 $i$ 的数。

我们可以在读入的时候，每输入序列的一个数，就把 $tong_1$ 到 $tong_{a_i}$ 全部加一。

显然暴力去做是 $O(nh)$，最大可达到 $4\times10^{10}$，原地起飞。

~~我不灰心！我不气馁！~~

考虑用神奇的差分来优化。

每输入一个数，只需把 $tong_1$ 加一，把 $tong_{a_i+1}$ 减一就可以了。原理这里不详细介绍了，想了解的同学可以自行百度。

于是时间直接被拉到 $O(2n)$，轻松卡进时限。

献上代码：
```cpp
for(register int i=1;i<=n;i++){
	scanf("%d",&x);//读入
	mx=mx>x+1?mx:x+1;
	mn=mn<x?mn:x;//预处理出最大值和最小值
	tong[1]++;
	tong[x+1]--;//差分
}
for(register int i=1;i<=mx;i++){
	tong[i]+=tong[i-1];
}//做完差分，它只是一个半成品，要把它前缀和。
```

---
接着是主(da)程(bao)序(li)：

有了预处理，这一部分就简单的直接掉橙。

看完题目，可以得出一条很简单的结论：最优解总是使序列中的每个数都等于原来的最小数。

我们可以用贪心的思想，从最大的数开始，如果把 $H$ 设在这个数 $x$ 可以，那就设在 $x$ 上；否则就设在 $x+1$ 上，同时 $ans+1$。如果现在已经是最小值了，那就直接输出，结束程序。

具体看代码吧：

```cpp
now=mx-1;//这里因为我上面求得的是 mx+1，所以这里要减一
while(now>mn){//如果还要继续操作
	int sum=0;//累计变化量
	while(sum+tong[now]<=k&&now>mn){//如果 H 还能往下走
		sum+=tong[now];
		now--;//就尽量往下走，统计更新变化量
	}
	ans++;//操作次数更新
}
```
---
总时间复杂度大概是 $O(2n+2h)$，比较快。

- 如果你不信，你可以[戳我](https://www.luogu.com.cn/record/32214211)

- 如果你还不信，你可以在最优解第 $42$ 名找到我。不要嫌名次低，这只是个**暴力**啊。

---
#### 番外

不知道写什么，那就[谢谢大家观看！](https://moon-snow.blog.luogu.org)