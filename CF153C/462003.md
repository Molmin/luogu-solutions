先提供一下题目翻译：

给定义一个长度不大于 $10$，不小于 $1$ 的字符串（所有字符均为大写英文字母）和密钥 $k$，求出加密后的字符串。（加密规则：所有字母均向后移动 $k$ 位，当当前字母大于 Z 时，回到字母表的开头 A 继续移动。）

hh，那不是太简单了？直接加 $k$ 不就得了？

是不是认为这就做完了？No！

当一个字母移动 $k$ 位后，结果可能会大于 Z（也就是不在字母表内），那我们可以用当前字母移动 $k$ 位后的结果 $-26$，就是`a[i] = char(a[i] + k - 26)`。

万一按你这么做后，结果不是字母表中的字母怎么办？

证明：

你看看题目，输入的字符只为大写字母，且 $1 \leq k \leq 25$，我们假设一个字母最大为 Z，$k$ 最大为 $25$，因为 Z 的 ASCII 码为 $90$，$90 + 25 - 26 = 90 - 1 = 89$，转成字符类型就是字母 Y，所以它是不会因此 WA 掉的。

代码展示：
```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
using namespace std;
char a[1005];
int k;
int main()
{
	cin.getline(a,1005);
    scanf("%d",&k);
	int len = strlen(a);
	for(int i = 0;i < len;i ++)
	{
        a[i] = char(a[i] + k);//向后移动k位。
        if (a[i] > 'Z')//如果字符超出26字母表，则需要对该字符进行特殊处理
        {
        	a[i] = char(a[i] - 26);//超了就从字母表从头开始
        }
        printf("%c",a[i]);
	}
	return 0;
}
```
