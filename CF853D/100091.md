# CF853D 题解

看到其他题解用的都是贪心，那我就来一发DP。

我们注意到，题目中的 $1000,2000$ 元是假的，实际上我们可以将所有钱数除以 $100$ ，因为题中最多也就出现了 $\frac{1}{10}$ 的积分，故将所有数除以 $100$ 也不会出现小数的情况。

那么接下来，我们考虑一个暴力的DP，即：

记 $dp_{i,j}$ 代表考虑充前 $i$ 次电，积分卡中剩余 $j$ 元的最小花费。那么转移方程就是：

$dp_{i,j}=max(dp(i-1,j-\frac{a_i}{10})+a_i)$

以及：

$dp_{i,j}=max(dp(i-1,j+k)+a_i-k)$

两个方程分别表示不使用积分卡中的钱，和使用积分卡中的钱，两种情况。

看似这样的复杂度是 $O(NV^2)$ 的，但实际上，每一次积分卡里不可能出现大于 $40$ 元的钱，不然我们在这一次就用掉一部分钱，一定不会更劣。故实际上的时间复杂度是 $O(NV'^2)$ ， $V'=40$ ，空间复杂度则是 $O(NV')$ 。

实际上，该题的空间复杂度还可以用滚动数组优化到 $O(V')$ ，但其实在这个题里 $O(NV')$ 的空间复杂度完全开的下，甚至绰绰有余，所以没必要再优化了。

**code:**

```

const int V(40);
const int N(3e5+10);

int n,dp[N][V+5];

signed main(){
	
	n=read();
	
	rep(i,0,n)rep(j,0,V)dp[i][j]=1e9;
	dp[0][0]=0;
	
	rep(i,1,n){
		
		int x=read()/100,t=x/10;
		
		rep(j,t,V)ckmin(dp[i][j],dp[i-1][j-t]+x);
		// 不使用积分卡中的钱 
		
		rep(j,0,V)rep(k,0,x)if(j+k<V)
		ckmin(dp[i][j],dp[i-1][j+k]+x-k);
		// 使用了k元的积分卡中的钱
		
	} int ans=1e9;
	
	rep(i,0,V)ckmin(ans,dp[n][i]);
	
	return cout<<ans*100,0;
}

```