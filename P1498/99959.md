
大家可能已经发现了此题的~~奥妙~~   ~~机密~~  规律了吧

首先呢， 当n=1时， 图形是什么样呢？ 大家可以使用word等来画一画。

 n=1时

```

 /\
/__\

```

那n=2，3，4···时，图形又是什么样呢？

n=2时

```
   /\
  /__\
 /\  /\
/__\/__\ 

```

n=3时

```
       /\
      /__\
     /\  /\
    /__\/__\
   /\      /\
  /__\    /__\
 /\  /\  /\  /\
/__\/__\/__\/__\                                                   

```

n=4时

```
               /\
              /__\
             /\  /\
            /__\/__\
           /\      /\
          /__\    /__\
         /\  /\  /\  /\
        /__\/__\/__\/__\
       /\              /\
      /__\            /__\
     /\  /\          /\  /\
    /__\/__\        /__\/__\
   /\      /\      /\      /\
  /__\    /__\    /__\    /__\
 /\  /\  /\  /\  /\  /\  /\  /\
/__\/__\/__\/__\/__\/__\/__\/__\  

```
很漂亮是吧！

n=1时的图形相当于祖先（要是没有这个基础图形，后面的图形都不会产生） 那这个祖先是怎么孕育后代的呢？

为方便叙述 敝人把n=1时的图形记作a[1]

n=2时记作a[2]   

···

以此类推

a[2] 相当于 a[1]向左平移复制一次， 再向上平移复制一次
 
a[3] 相当于 a[2]向左平移复制一次， 再向上平移复制一次， 也就是说， 总共复制了2次 （a[1]为起点）

a[4]呢， 敝人知道你们肯定也发现了， 也就是a[3]向左平移复制一次，再向上平移复制一次， 总共复制了3次

···

 而a[n]，想必很easy啦，就是a[n-1]向左平移复制一次，再向上平移复制一次，总共复制了n-1次

而再定睛一看 ，n=1时有2排，4列 ，n=2时有4排，8列  n=3时有8排，16列 是不是觉得很熟悉。

# 没错！排数=2^n, 也就是1<<n
# 列数=2^(n+1)，也就是1<<(n+1)

总规律我们找出来了，但进一步就可以发现，最左下角的那个a[0]都是基本图形，我们可以初始化一下（预处理？）

                     
```cpp
	mp[1<<n][1]='/';//最后一排的第一个 
	mp[1<<n][2]='_';//最后一排的第二个 
	mp[1<<n][3]='_';//最后一排的第三个 
	mp[1<<n][4]='\\';//最后一排的最后一个 
	mp[(1<<n)-1][2]='/';//倒数第二排（最后一排的上面一排）的第二个，因为第一个是' '（空格） 
	mp[(1<<n)-1][3]='\\';//倒数第二排的第三个，也就是最后一个 
```


当然各位可能也发现了，我用的是平移复制，而不是单纯的复制，所以说咱们再数数 向左平移 和 向上平移的数
                                         
复制1次时  向左平移了3（=4-1）个（此处平移指mp [i][j+3],不止此处，之后同此)，~~向上平移了~~，准确说，是向斜上方向，向左平移了2个，同时向上平移了2个
                   
复制2次时  向左平移了7（=8-1）个，斜向上平移：向左平移了4个，同时向上平移了4个
                   
复制3次时  向左平移了15（=16-1）个，斜向上平移：向左平移了8个，同时向上平移了8个  
                   
那么各位，复制k次呢？ 想必聪明的各位立马反应过来了，向左平移了2^(k+1)-1 ,也就是(1<<(k+1))-1个， 斜向上平移：向左平移了2^k(1<<k)个，同时向上平移了2^k(1<<k)个 
                                                                                                    
                                                                                                    接下来，便是各位喜爱的AC代码上场！！
                                                                                                    
```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int n;
char mp[1<<10][1<<10];
int main()
{
	int i,j,k,l;
	scanf("%d",&n);
	for(i=0;i<=(1<<n);i++)
		for(j=0;j<=(1<<n);j++)
			mp[i][j]=' ';//预处理 未填上的图形都是空格 
	if(n==1)//特判 
	{
		cout<<" /\\"<<endl;
		cout<<"/__\\"<<endl;
		return 0;
	}
	mp[1<<n][1]='/';//最后一排的第一个 
	mp[1<<n][2]='_';//最后一排的第二个 
	mp[1<<n][3]='_';//最后一排的第三个 
	mp[1<<n][4]='\\';//最后一排的最后一个 
	mp[(1<<n)-1][2]='/';//倒数第二排（最后一排的上面一排）的第二个，因为第一个是' '（空格） 
	mp[(1<<n)-1][3]='\\';//倒数第二排的第三个，也就是最后一个 
	k=1;//复制次数 
	l=4;//最后一排的符号个数  刚开始时最后一排有4个，以后随着k增加l变为原来的2倍 
	while(k<n)
	{
		for(i=(1<<n);i>((1<<n)-(1<<k));i--)
			for(j=1;j<=l;j++)
			//第k次复制，应把((1<<n)-(1<<k))+1到(1<<n)排和第1列到第l列看做一个基础图形
			//若不是很理解 可亲自数一数 (空格无所谓反正平移过去都还是空格） 
			{
				mp[i][j+(1<<(k+1))]=mp[i][j];
				mp[i-(1<<k)][j+(1<<k)]=mp[i][j];//规律 
			}
		k++;
		l=l*2;
	}
	for(i=1;i<=(1<<n);i++)
	{
		for(j=1;j<=(1<<(n+1));j++)
			cout<<mp[i][j];
		printf("\n");
	}//输出 
	return 0;
}
```
                                                                                                   