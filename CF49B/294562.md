 刚好看到一个帖子在问这道题，点进来就随便做做AC了。同时发现题解只有一篇且十分不清晰所以这里来~~水~~补上一篇题解。

---------------

#### 思路其实很简单，分为几个步骤：

1. 算出对于题目给出的$a$,$b$最小的有意义的进制数$n$。

1. 我们在$n$进制下算出$a + b$（得数为$n$进制数），该得数有几位便为答案。

但这里就有一个~~无聊到极致~~的问题：**为什么可以直接按最小进制数来呢？**

A：**易知，10进制下的一个数，在1-9进制下就会变“大”一点（其实值是不变的，但是把它当作10进制数看会变大，例如10进制下的2，在二进制下就为“10”），所以直接算最小的即为答案，不必再往上枚举。**

-----------------

思路分享到此为止，下面是几个**小坑**：

1. 我们算出两个数最小的数码要加一开始枚举。

1. **前导多余的0必须删除。**

1. **由于是从0开始循环，我们必须在最后将答案加一。**

--------------
上代码（有注释，可以配套食用）

```cpp
#include<bits/stdc++.h>//养成好习惯

using namespace std;

string aa,bb;
int a[10000],b[10000],c[100000];//a + b = c
int x,maxx = -21000,maxx1 = -21000,maxx2 = -21000,len;//x为进位小尾巴，maxx是最大的数码，len是答案

int main(){
	cin>>aa>>bb;
	//这里开始判断最大的数是多少
	for(int i = 0;i <= aa.length() - 1;i ++){//注意从0开始循环
		maxx1 = max(maxx1,aa[i] - 48);
		a[aa.length() - 1 - i] = aa[i] - 48;//注意string转int要减去48
	}
	for(int i = 0;i <= bb.length() - 1;i ++){
		maxx2 = max(maxx2,bb[i] - 48);
		b[bb.length() - 1 - i] = bb[i] - 48;
	}
	maxx = max(maxx1,maxx2) + 1;//加1开始枚举
	//这里开始高精度加法
	while(len <= max(aa.length(),bb.length())){
		c[len] = a[len] + b[len] + x;//x为进位小尾巴
		x = c[len] / 10;
		c[len ++] %= 10;//满maxx进一
	}
	while(1){//去掉前导可恶的0
		if(c[len] != 0)break;
		if(c[len] == 0)len --;
	}
	len ++;//最后加一因为从0开始循环
	cout<<len;
	return 0;//养成好习惯
}
```

###### 别看了结束了都散了吧