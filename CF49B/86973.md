话说这个题目是蓝题就比较离谱

首先说结论，对于两个数 $x, y$ 相加，最终数字的长度最多为原来的两个数中位数较多的那个数的位数加一，这个是显然的就不细说了。

而我们在考虑的时候，其实只需要考虑一个进制，即 $x, y$ 各个位置上最大的那个数加一的这个进制。什么意思呢，打个比方

>设$x, y$ 分别为 76617 和 32219

那我们就考虑 10 进制，即 $y$ 中最大的那个数加一

为什么这样是对的呢？首先我们能够对答案作出贡献一定是因为进位，而我们得到的是在不同进制意义下相同的一个加法，所以我们考虑如何才会更容易进位，显然是基数越小越好，所以我们直接取到最小，即如果基数再小就会使式子没有意义的时候，如果连他都不能够进位，那么显然是不能对答案造成贡献的，反之答案则为 $x, y$ 中较大的那个数的位数加一。

那么怎么检查是否有解？很简单，就是 ｋ 进制高精度加法即可，最后判断是否进位

下为代码，如果有任何错误或疑问欢迎私信或是评论

```cpp
#include <bits/stdc++.h>
using namespace std;
#define R register int
const int MAXN = 1e3 + 10;
int a[MAXN], b[MAXN], c[MAXN];
int main() {
    int x, y; scanf("%d%d", &x, &y);
    int cnt = 0, tot = 0, p = -1;
    while (x) {
        a[++ cnt] = x % 10;
        x /= 10; p = max(p, a[cnt]);
    }
    while(y) {
        b[++ tot] = y % 10;
        y /= 10; p = max(p, b[tot]);
    }
    int ans = max(tot, cnt);
    for(R i = 1; i <= ans; i ++) {
        c[i] += a[i] + b[i];
        if(c[i] > p) c[i + 1] ++;
    }
    if(c[ans + 1]) ans ++;
    printf("%d\n", ans);
    return 0;
}
```