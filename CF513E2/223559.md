### $\text{Difficulty : 2700}$
---
### 解题思路：

朴素的思路是 $f_{i,j,k}$ 表示考虑到第 $i$ 个，上一个转移点在 $j$，转移了 $k$ 次，优化的难点在于需要确定当前转移给予的权值是正还是负。

那不妨就从权值正负入手，将所有的绝对值符号拆开，发现除了第一个和最后一个位置的权值绝对值为 $1$ 外，其它所有位置的权值绝对值都是 $2$ 或者 $0$。

于是就想到用当前的权值作为状态，$f_{i,j,k}$ 表示考虑到第 $i$ 个位置，已经转移了 $j$ 次，状态为 $k$。

具体的状态讨论比较麻烦：

-  $k=0$ 表示当前权值为 $2$，特殊地，当此时是第一个转移点或者到达最后一个转移点的时候，这个地方代表权值为 $1$。

- $k=1$ 表示当前权值为 $-2$，特殊地，当此时是第一个转移点或者到达最后一个转移点的时候，这个地方代表权值为 $-1$。

- $k=2$ 表示接下来的权值为 $0$ 或者不取，往前的最后一个取了的非 $0$ 权值为负。

- $k=3$ 表示接下来的权值为 $0$ 或者不取，往前的最后一个取了的非 $0$ 权值为正。

---
转移细节也非常麻烦，主要在于对于中途，开头和结尾三个地方放弃部分数值的处理。

具体地，将 $j=1$，$j=k$ 和其它情况分开处理。

对于 $j=1$ 时，任意的 $f_{i,j,0}$ 和 $f_{i,j,1}$ 都可以从之前的 $f_{i-1,j,0}$ 和 $f_{i-1,j,1}$ 转移，表示再取一个，也可以放弃之前所有的，直接从当前位置开始重新取。

对于 $j=n$ 和其它情况，$f_{i,j,0}$ 和 $f_{i,j,1}$ 可以在之前的基础上再取一个数，也就是从 $f_{i-1,j,0}$ 和 $f_{i-1,j,1}$ 转移，也可以从开始新的一段，从 $f_{i-1,j-1,2}$ 和 $f_{i-1,j-1,3}$ 转移。

对于 $k=2$ 或 $k=3$ 的情况，除了 $j=1$ 或者 $j=k$ 的时候不能从 $f_{i-1,j-1,2}$ 和 $f_{i-1,j-1,3}$ 转移以外，所有的位置都能够从 $f_{i-1,j-1,2/3}$，表示开启新的一段并选择当前数的权值为 $0$，$f_{i-1,j,2/3}$，表示延续之前的段，以及  $f_{i,j,1/0}$ 表示从当前位置开始新的一段，接下来一段舍弃。对于 $j=1$ 不能用 $f_{i-1,j-1,2}$ 和 $f_{i-1,j-1,3}$ 转移是因为没有这样的位置，而对于 $j=k$ 不能用 $f_{i-1,j-1,2}$ 和 $f_{i-1,j-1,3}$ 是为了最后一段禁止取 $0$，保证只有不取数一个选择，也就使得最终的答案是 $f_{n,k,2/3}$，而不用从后往前找出最大位置。

较为特殊的，由于让权值为 $0$ 和不取带来的贡献都是 $0$，所以在一定存在一种情况使得取 $0$ 的位置连续的结论的保证下可以将不取和取 $0$ 混作一个状态，同时这样也就保证了段与段之间少取部分数的情况被考虑。

---
有一个不影响做法问题也是值得思考的，就是在进行转移的其实并没有进行大小比较，但是最后的结果却没有出现赋予错误的系数情况。

实际上在转移过程中这种错误是有可能出现的。但是可以证明如果出现了这种情况则一定不是一个优解，具体证明的时候局限于刚才给出的方程会比较麻烦，但是可以转向证明一个固定的划分情况赋予权值，得出只有正确划分才能得到最大的权值，然后用所有的划分情况被考虑回归到原命题上。或者简单一点，用 $\text{\_rqy}$ 大佬的话讲就是“显然绝对值改成 $\max$”，但反正我是看不出来哪里显然了。

扯开说一句，顺着这个结论思考就会发现这个 $\text{DP}$ 思路完全做不了最小值。

---
### 代码：

```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
#define int long long
const int MAXN=30005;
int n,k,a[MAXN],f[MAXN][205][5],ans;
signed main(){
	scanf("%lld%lld",&n,&k);
	for(int i=1;i<=n;i++)scanf("%lld",&a[i]);
	for(int i=0;i<=n+1;i++)
	for(int j=0;j<=k+1;j++)
	for(int k=0;k<=4;k++)
	f[i][j][k]=-1e13;
	f[0][1][1]=f[0][1][0]=0;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=min(i,k);j++){
			if(j==1){
				f[i][j][0]=max(f[i-1][j][0],0ll)+a[i];
				f[i][j][1]=max(f[i-1][j][1],0ll)-a[i];
				f[i][j][2]=max(f[i-1][j][2],f[i][j][1]);
				f[i][j][3]=max(f[i-1][j][3],f[i][j][0]);
			}else
			if(j==k){
				f[i][j][0]=max(f[i-1][j][0],f[i-1][j-1][2])+a[i];
				f[i][j][1]=max(f[i-1][j][1],f[i-1][j-1][3])-a[i];
				f[i][j][2]=max(f[i-1][j][2],f[i][j][1]);
				f[i][j][3]=max(f[i-1][j][3],f[i][j][0]);
			}else{
				f[i][j][0]=max(f[i-1][j][0],f[i-1][j-1][2])+2*a[i];
				f[i][j][1]=max(f[i-1][j][1],f[i-1][j-1][3])-2*a[i];
				f[i][j][2]=max(f[i-1][j][2],max(f[i][j][1],f[i-1][j-1][2]));
				f[i][j][3]=max(f[i-1][j][3],max(f[i][j][0],f[i-1][j-1][3]));
			}
		}
	}
	printf("%lld",max(f[n][k][2],f[n][k][3]));
	return 0;
}
```
