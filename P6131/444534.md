## 题意
给定一个由空白和斑点组成的字符矩阵，斑点刚好组成三个四方向的连通块，求最少将多少个格子变成斑点，可以将三个连通块合并。
## 思路
思考合并连通块的方式，可以发现有两种合并的方法：

1. 两个连通块分别连接到另一个连通块上。
2. 选择一个汇合点，三个连通块分别连接到汇合点上。

如果合并时连接的路径有重叠，只会让答案变大会影响最优答案的求解，而最优答案必然为上述两种方法之一。

因此，我们可以先找到三个连通块，然后分别从三个连通块开始用宽度优先遍历扩张，计算出每个格子分别到三个连通块的距离，进一步就可以计算出连通块之间的距离，最后枚举进行求解即可。
## CODE
```cpp
#include <bits/stdc++.h>
using namespace std;
const int kMaxN = 51, kD[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};
int a[kMaxN][kMaxN], d[kMaxN][kMaxN][3], l[3][3], q[kMaxN * kMaxN][2];
int n, m, o, h, t, ans = 1e9;
char c;
void R(int i, int x, int y, int l) {                                              // 扩展位置(x, y)的位置，类型i，距离l
  if (x < 1 || x > n || y < 1 || y > m || d[x][y][o] || !(i || a[x][y] == -1)) {  // 越界、重复或者字符不匹配
    return;
  }
  d[x][y][o] = l;  // 记录距离
  if (!i) {        // 是扩展斑点
    a[x][y] = o;   // 标记斑点
  }
  ++t, q[t][0] = x, q[t][1] = y;  // 将位置加入队列
}

void W(int x, int y) {                                  // 从(x, y)所在斑点开始遍历矩阵
  h = 0, t = -1;                                        // 初始化队列
  R(0, x, y, 1);                                        // 加入初始位置
  for (int i = 0; i <= t; i++) {                        // 按顺序处理位置
    for (int j = 0; j < 4; j++) {                       // 枚举方向
      R(0, q[i][0] + kD[j][0], q[i][1] + kD[j][1], 1);  // 扩展斑点
    }
  }
  for (; h <= t; h++) {                                                          // 按顺序处理位置
    for (int i = 0; i < 4; i++) {                                                // 枚举方向
      R(1, q[h][0] + kD[i][0], q[h][1] + kD[i][1], d[q[h][0]][q[h][1]][o] + 1);  // 扩展其他位置
    }
  }
}

int main() {
  cin >> n >> m;
  for (int i = 1; i <= n; i++) {
    for (int j = 1; j <= m; j++) {
      cin >> c;
      a[i][j] = (c == 'X') - 2;  // 字符转数字，空白-2、斑点-1
    }
  }
  for (int i = 1; i <= n; i++) {
    for (int j = 1; j <= m; j++) {  // 枚举网格
      if (a[i][j] == -1) {          // 找到未处理的斑点
        W(i, j), o++;               // 从当前斑点进行宽度优先遍历，增加斑点数量
      }
    }
  }
  fill(l[0], l[0] + 9, 1e9);  // 初始化斑点之间的距离
  for (int i = 1; i <= n; i++) {
    for (int j = 1; j <= m; j++) {                               // 枚举格子
      ans = min(ans, d[i][j][0] + d[i][j][1] + d[i][j][2] - 5);  // 三个斑点连接到该点，更新答案
      if (a[i][j] >= 0) {                                        // 当前格子是斑点
        for (int k = 0; k <= 2; k++) {                           // 枚举斑点
          l[a[i][j]][k] = min(l[a[i][j]][k], d[i][j][k] - 1);    // 更新斑点之间的距离
        }
      }
    }
  }
  for (int i = 0; i <= 2; i++) {                      // 枚举斑点
    ans = min(ans, l[i][0] + l[i][1] + l[i][2] - 2);  // 连接到该斑点，更新答案
  }
  cout << ans;
  return 0;
}

```