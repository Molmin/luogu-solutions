## 题目大意

Polycarp 有一个包含 $n$ 个整数的数组 $a$；

他想在这个数组上玩一个游戏，游戏包含了若干次操作。第一次操作他会选择任意一个元素，并删除它；接下来每次操作中他选取并删除的元素需要满足一个限制：本次操作与上次操作中数字的奇偶性不同。当无法删除元素时，游戏停止。

Polycarp 的目标是最小化游戏停止时数组中还未被删除的数字之和。如果所有元素都被删掉，数字之和为 $0$。

## 思路

第一次选的数的奇偶性取决了答案，所以选的第一个数有两种选择：
1. 选奇数

2. 选偶数

那么该怎么选择呢？

很简单，只用看数组里偶数多还是奇数多。

如果奇数多的话，那么偶数全部都会选完，剩下的只能是奇数；那么会剩下多少奇数呢？

我们已经知道，奇数偶数是轮流选的，所以可以看成是选一次奇数，一次偶数为一组，但最后还可以多选一次，所以还要减去 $1$。

所以可以将数组分为两个数组，一个是长度为 $x$ 的奇数数组 $a$，一个数长度为 $y$ 的偶数数组 $b$；

那么答案就为：

$\sum_{i = 1} ^ {n - y - 1} a_i$

当然，偶数多就为:

$\sum_{i = 1} ^ {n - x - 1} b_i$

## 代码

```cpp
#include<bits/stdc++.h>

using namespace std;

#define int long long

const int N = 2005;

int n, a[N], lsum, rsum, l[N], r[N];

signed main(){
    cin >> n;
    for(int i = 1; i <= n; i++){
        cin >> a[i];
        if(a[i] % 2 == 0){
            l[++lsum] = a[i]; // 分为两个小数组
        } else {
            r[++rsum] = a[i];
        }
    }
    sort(l + 1, l + 1 + lsum); // 贪心思想，先把大的拿了，剩下的之和就为最小和
    sort(r + 1, r + 1 + rsum); 
    int ans = 0;
    if(lsum > rsum){
        for(int i = 1; i <= lsum - rsum - 1; i++){ // 直接套公式
            ans += l[i];
        }
    } else {
        for(int i = 1; i <= rsum - lsum - 1; i++){
            ans += r[i];
        }
    }
    cout << ans;
    return 0;
}
```