## dp
首先，这题让我们在n本书中选k本。

状态中肯定有:$dp[i][j]$表示前i本书中选j本。

那么，后面状态该怎么设计呢？

看一波数据范围，发现每本书的高度$h_i \in [25,32]$，显然，这是让我们状压书的高度。

可是，该如何状压呢？

不难发现，取走一本书后，它可以任意放在一个地方，那么我们可以先取k本，最后再一起放进去。

于是第三维压得就是**取出去书的高度**。

最后统计答案时再看看序列中有没有同种高度的。

等等，**怎么判断有没有同种高度的？** 我们并不知道取出来了几本啊。

你可能开始怀疑的，没错，第三维压取出去书的高度**是无法完成统计的**。

* * *

诶，既然压取出去的不管用，为何不压**未被取出去书的高度呢**？

接着，考虑转移：

1.若把第i个取出来，那么就判断一下第i个之前有没有出现过，没有的话，就把答案+1

2.若不把第i个取出来，那么就判断一下跟前面一个是不是一样的，若不一样，就把答案+1

仔细看看第二条转移，万一前面一本书也被取了呢？

那就再前面一个把。。

万一再前面一个也被取了呢？

。。。

从中你可以发现，**开三维是无法完成转移的**，因此考虑$dp[i][j][k][o]$表示前i本书，取了j本，剩下未被取走的高度集合为k，i前面一本未被取的书高度为o，里面存的是最小的混乱值。

这就终于可以转移了。。。

注意：
1.由于有些状态**前面是没有书的**，所以要取一个特殊的o来表示此状态

2.直接开这么多状态会MLE，需要滚动

```c++
for(int i=1; i<=n; i++) {
        int now=i&1,la=!now;
        memset(dp[now],63,sizeof(dp[now]));
        for(int j=0; j<=K; j++) {
            for(int k=0; k<=255; k++) {
                for(int o=0; o<=8; o++) {
                    if(o==8){//o=8表示前面是没有书的
                        dp[now][j][k|(1<<A[i])][A[i]]=min(dp[now][j][k|(1<<A[i])][A[i]],dp[la][j][k][o]+(A[i]!=o));//不取第i本
                        if(j>=1)dp[now][j][k][o]=min(dp[now][j][k][o],dp[la][j-1][k][o]+(((1<<A[i])&k)?0:1));//把第i本取出来 
                        continue;
                    }
                    if(((1<<o)&k)){
                        dp[now][j][k|(1<<A[i])][A[i]]=min(dp[now][j][k|(1<<A[i])][A[i]],dp[la][j][k][o]+(A[i]!=o));//不取第i本
                        if(j>=1)dp[now][j][k][o]=min(dp[now][j][k][o],dp[la][j-1][k][o]+(((1<<A[i])&k)?0:1));//把第i本取出来  
                    }
                }
            }
        }
    }
```
然鹅你会发现，这样写的话只有20分。

仔细观察一下，你会发现里面有这样一个判断：

```c++
(((1<<A[i])&k)?0:1)
```

这表示第i个是否出现在k中，如果出现了，则不+1，反之则把答案+1.

但是，如果第i个没有出现在k中，**但它在后面出现过**，那我们可以直接跟后面的塞在一起。这种情况，就不需要+1。

也许你会问：如果与它塞在一起的书也被取走了，那也不会多出1吗？

我们注意到题面，取出来的书是可以放在**任意位置**的，同时与它塞在一起的书肯定得放在一个位置，那么我们决策第i本书时，完全就可以想成**一开始就把它放在与它塞在一起的书所要呆的最终位置**。

最终代码:
```c++
#include<bits/stdc++.h>
using namespace std;
int dp[2][110][260][11],n,K,A[1010],ans=2e9+7;
bool is[1010][10];//is[i][j]表示第i本书后面是否出现过高度为j的书
int main() {
	memset(dp,63,sizeof(dp));
	int oo=dp[0][0][0][0];
	scanf("%d %d",&n,&K);
	for(int i=1; i<=n; i++)scanf("%d",&A[i]),A[i]-=25;
	for(int i=1;i<=n;i++){
		for(int j=i+1;j<=n;j++)is[i][A[j]]=true;
	}
	dp[0][0][0][8]=0;
	for(int i=1; i<=n; i++) {
		int now=i&1,la=!now;
		memset(dp[now],63,sizeof(dp[now]));
		for(int j=0; j<=K; j++) {
			for(int k=0; k<=255; k++) {
				for(int o=0; o<=8; o++) {
					if(o==8){
						if(dp[la][j][k][o]!=oo)dp[now][j][k|(1<<A[i])][A[i]]=min(dp[now][j][k|(1<<A[i])][A[i]],dp[la][j][k][o]+(A[i]!=o));
						if(j>=1&&dp[la][j-1][k][o]!=oo)dp[now][j][k][o]=min(dp[now][j][k][o],dp[la][j-1][k][o]+((((1<<A[i])&k)||is[i][A[i]])?0:1));
						continue;
					}
					if(((1<<o)&k)){
						if(dp[la][j][k][o]!=oo)dp[now][j][k|(1<<A[i])][A[i]]=min(dp[now][j][k|(1<<A[i])][A[i]],dp[la][j][k][o]+(A[i]!=o));
						if(j>=1&&dp[la][j-1][k][o]!=oo)dp[now][j][k][o]=min(dp[now][j][k][o],dp[la][j-1][k][o]+((((1<<A[i])&k)||is[i][A[i]])?0:1));
					}
				}
			}
		}
	}
	for(int i=0;i<=K;i++){
		for(int k=0;k<=255;k++){
			for(int o=0;o<=8;o++){
				if(o==8){
					ans=min(ans,dp[n&1][i][k][o]);
					continue;
				}
				if(((1<<o)&k)){
					ans=min(ans,dp[n&1][i][k][o]);
				}
			}
		}
	}
	cout<<ans;
	return 0;
}
```
