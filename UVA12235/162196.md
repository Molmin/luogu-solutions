第一次写黑题题解~~。

本题解主要参考了 @Awdrgysxc 的题解以及我们教练讲解题目时的做法。自己对其进行了完善与思考，写成这篇题解。

我们思考去取出一种数总共有哪几种情况。

1. 取出一个数，放在相同的数的旁边。

举个例子： 
``` 
1 2 2 2 1
```

明显，我们可以将最左边的 1 移到最右边，使段数减去 1。

2. 取出一个数，放在不同数的旁边。

```
2 2 1 2 2
```

在这个例子中，我们可以把 1 挪到最右边，让答案减去 1。

并且中间不管有多少个 1，如果要把 1 移完的话，把他们搞成一坨放在最右边一定是最优解。

那么请问大家，看了那么多，有没有发现什么规律呢？

规律就是，如果说一个数并不是被完全移动，那么这个数一定会移到还没有移动的相同的数的旁边（这样的话答案才不会另外再增加），如果全部被移完，那么就搞成一坨放最右边，答案另外要加 1。

那么我们要如何判断一个数有没有完全被移动呢？

分析到这里，应该很容易想到状压 DP 了吧。

我们令 $f_{i, j, k, las}$ 表示前 $i$ 个数，拿出了 $j$ 个，没有全部拿的数的集合为 $k$，$las$ 为最后一个数，的最小杂乱值。明显有状态转移方程（用代码表示）

```cpp
f[i][j][k | 1 << a[i]][a[i]] = min(f[i][j][k | 1 << a[i]][a[i]], f[i - 1][j][k][las] + (las != a[i]));
f[i][j + 1][k][las] = min(f[i][j + 1][k][las], f[i - 1][j][k][las]);
                        
```

DP 还有一个很重要的部分就是初值的定义。因为我们这个转移肯定是从小到大，
我们可以直接令 $i \in [1,n]$，$f_{i,i-1,2^{a_i},a_i} = 0$

从这个状态向后推，一定可以推出所有状态的值。

写的时候还要使用一下滚动数组优化。代码部分参考了一下上面提到那位大佬的。有些具体细节如果还不明白，建议看代码。

```cpp
#include <bits/stdc++.h>
using namespace std;
int n, m, f[2][105][1 << 8][8], a[105];
int main() {
	int num = 0;
	while (~scanf("%d%d", &n, &m)) {
		if (!n && !m) break;
		//f[i][j][k][las] 表示前 i 个数，去掉了 j 个，保留数的状态为 k，最后一个没有去掉的数为 las 的最小混乱程度。
		//这里的保留是指没有完全保留也算
		memset(f, 0x3f, sizeof f);
		for (int i = 1; i <= n; ++i) scanf("%d", a + i), a[i] -= 25;
		int all = 0;
		for (int i = 1; i <= n; ++i) {
			all |= 1 << a[i];
			memset(f[i & 1], 0x3f, sizeof f[i & 1]);
			f[i & 1][i - 1][1 << a[i]][a[i]] = 1;
			for (int j = 0; j <= m; ++j)
				for (int k = all; k; k = (k - 1) & all)
					for (int las = 0; las < 8; ++las) {
						f[i & 1][j][k | 1 << a[i]][a[i]] = min(f[i & 1][j][k | 1 << a[i]][a[i]], f[i - 1 & 1][j][k][las] + (las != a[i]));
						f[i & 1][j + 1][k][las] = min(f[i & 1][j + 1][k][las], f[i - 1 & 1][j][k][las]);
					}
		}
		int ans = 0x3f3f3f3f;
		for (int i = 0; i <= m; ++i)
			for (int s = all; s; s = (s - 1) & all) {
				for (int las = 0; las < 8; ++las) {
					if (f[n & 1][i][s][las] == 0x3f3f3f3f) continue;
					int sum = __builtin_popcount(all ^ s);
					ans = min(ans, f[n & 1][i][s][las] + sum);
				}
			}
		printf("Case %d: %d\n\n", ++num, ans);
	}
}
```

注意，以上代码中，我们必须要枚举子集（否则答案可能会错，或者说效率变低）