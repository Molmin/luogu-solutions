# 一、题意

Alexey 有 $n$ 个电子邮件，电子邮件分为已读和未读，已读的电子邮件标为 $0$，未读的标为 $1$。现在他有以下三种操作：

1. 读完邮件后回到邮件列表
2. 回到列表后选取任意一个未读邮件读
3. 读完一个邮件之后读这个邮件的下一个或者上一个邮件

问他最少多少次操作能读完所有邮件

# 二、分析

我们看一下题意就可以知道其实看邮件不是操作，转换邮件才是操作。操作1和2可以从一个邮件跳到任何一个邮件，但是需要两次操作。操作3可以观看下一个或者上一个操作，显然这个操作在未读邮件连续的时候才好用（如果两个未读邮件中隔着 $x$ 个已读邮件，那么需要 $p=x+1$ 次操作才能看到下一个未读邮件，由于 $p\geq2$，这样情况下用操作1和2会更划算一些）。

在操作3中，显然从左边右边观看邮件是一样的，只要保证不折回来再看就行了。

所以我们就从左到右扫一遍，找出所有 $1$ 的连通块（所有未读邮件连在一起的地方）。$x$ 个连通块之间转换需要 $2(x-1)$ 次操作；长度为 $len$ 的连通块内部需要 $len-1$ 次操作转换。

# 三、代码

```cpp
#include <bits/stdc++.h>
using namespace std;
int n, rep, group, ans; //group代表连通块个数，rep代表一个连通块长度
inline int read() { //快读
	int x = 0;
	char ch = getchar();
	while (ch < '0' || ch > '9') ch = getchar();
	while (ch >= '0' && ch <= '9') {
		x = (x << 1) + (x << 3) + (ch ^ 48);
		ch = getchar();
	}
	return x;
}
int main() {
	n = read();
	int x;
	for (int i = 1; i <= n; ++i) {
		x = read();
		if (x) rep++; //连通块长度+1
		else { //如果遇到0，说明连通块已经到头了
			if (rep) { 
				group++;
				ans += rep - 1;
			}
			rep = 0;
		}
	}
	if (rep) { //别忘了连通块有可能在最后
		group++;
		ans += rep - 1;
	}
	if (!group) putchar('0'); //没有连通块
	else printf("%d", ans + ((group - 1) << 1) + 1) ;
}
```
