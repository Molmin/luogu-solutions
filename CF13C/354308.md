题目要求很明确。

先给个样例。

单调处理前：
```
7
1 4 4 7 9 7 15
```
单调处理后：
```
7
1 3 2 4 5 3 9
```
我们按递推顺序想想，

下标为 $1$ 时，符合条件，不做处理。序列为：$\{1\}$。

下标为 $2$ 时，符合条件，不做处理。序列为：$\{1,3\}$。

下标为 $3$ 时，不符合，将前面的 $3$ 改为 $2$。序列为：$\{1,2,2\}$。

下标为 $4$ 时，符合条件，不做处理。序列为：$\{1,2,2,4\}$。

下标为 $5$ 时，符合条件，不做处理。序列为：$\{1,2,2,4,5\}$。

下标为 $6$ 时，不符合，将前面的 $5$ 改为 $3$。序列为：$\{1,2,2,4,3,3\}$。

下标为 $7$ 时，符合条件，不做处理。序列为：$\{1,2,2,4,3,3,9\}$。

为什么第六步可行呢？我们在做处理时肯定是将前面最大数变为这个数（即最适配情况）（$5,3$ 变 $3,3$），而这个的操作数，与将前面最大数与这个数折中变化的操作数相同（$5,3$ 变 $4,4$），所以这里的 $\{3,3\}$ 等效于  $\{4,4\}$， $\{5,5\}$。

而我们每次只找前面最大值，把我们更改的数值当作动态平衡（可小可大），这种动态平衡与单调不减是等效的（这里要好好理解），因为这并不影响我们找到的前面最大值与操作数。

当当前的数小于前面最大值，且这个最大值原本处于动态平衡，则这个数的值就定下来了，每次将前面最大数变为这个数。

当当前的数大于或等于前面最大值，符合条件，不更改值。

所以我们只需维护前面的更改数值后的值的最大值就行了。

附上代码：

```cpp
#include<bits/stdc++.h>
#define ll long long
#define mxm 200002
#define mxn 100002
using namespace std;
ll n,mx;
priority_queue<ll>qmx;
inline void rd(ll &x){x=0;short f=1;char c=getchar();while((c<'0'||c>'9')&&c!='-') c=getchar();if(c=='-') f=-1,c=getchar();while(c>='0'&&c<='9') x=x*10+c-'0',c=getchar();x*=f;}
inline void pt(ll x){if(x<0) putchar('-'),x=-x;if(x>9) pt(x/10);putchar(x%10+'0');}
int main(){
	rd(n);
	for(ll i=1,x;i<=n;i++){
		rd(x);
		qmx.push(x);//将x放入优先队列
		mx+=qmx.top()-x;//记录操作次数
		qmx.pop();//将最大值弹出
		qmx.push(x);//改为x
	}//想想当x大于或等于时，是否没改值
	pt(mx);//输出操作次数
}
```