吐槽：又是恶评题，估计很快掉红）

[原题传送门](https://www.luogu.com.cn/problem/CF1194A)。[在窝的博客中食用更佳](https://www.luogu.com.cn/blog/MZY666/solution-cf1194a)。

### 【 题意概括 】

先输入一个正整数 $t$，表示有 $t$ 组数据。

接下来 $t$ 行，每行两个正整数 $n$，$x$ 。

其中，$n$ 表示你有一个从 $1$ 到 $n$ 的序列，请你输出每一个序列进行下述操作后第 $x$ 项的大小。

操作：从第一次操作开始，对于第 $i$ 个操作，你将会删除这个序列中还未被删除的第 $i$ 项；

随后进行下一次操作，直到无法删除为止。

### 【 思路 】

很明显，用不着用暴力，可以找规律的。

结论：留下来的都是偶数（即双数），证明见下：（为了证明方便，以下证明中第 $i$ 项 就是 $i$）

第 $1$ 次操作会去掉第 $1$ 项，也就是 $1$。

第 $2$ 次操作会去掉第 $(2+1=3)$ 项，也就是 $3$。

第 $3$ 次操作会去掉第 $(3+2=5)$ 项，也就是 $5$。

第 $4$ 次操作会去掉第 $(4+3=7)$ 项，也就是 $7$。

再想想，这个 $(2+1)$，$(3+2)$，$(4+3)$，...，$(n,n-1)$ 其实就是第 $n$ 项加上之前被删过的 $n-1$ 项。

所以，第 $i_{max}$ 次操作会去掉第 $(i_{max}+i_{max}-1=2\times i_{max}-1)$ 项，也就是 $2\times i_{max}-1$。

也就是说，在 $1\sim n$ 中所有可以表示成 $2\times i_{max}-1$ 的数都被删掉了，其它数则都保留。

仔细一看，这不就是把奇数删掉了嘛！

因此，剩下的都是偶数啦。而第 $x$ 项的值，自然就是 $2\times x$ 了。

### 【 代码实现 + 注释 】

```cpp
#include<bits/stdc++.h>//万能头文件可好 
using namespace std;
#define ll long long//个人习惯
int main(){
	int t;
	ll n,x;
	scanf("%d",&t);//输入
	while(t--){
		scanf("%lld%lld",&n,&x);//输入
		printf("%lld\n",x*2);//输出答案，证明见上
	}
	return 0;//over
}
```

最后，由于作者自愿禁言了，如果有建议请私信。否则将**无法**回复您哦！

完结撒花~（疯狂暗示 AOA