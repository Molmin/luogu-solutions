[CF1547E](https://www.luogu.com.cn/problem/CF1547E)

这题做法老多了，深搜、广搜、奇怪 DP、线段树……


搜索及其容易超时，错误的 DP 常数大了会被叉（这场老多叉人都是叉 E 的大常数），线段树大炮轰蚊子又码亮大，显然在 div3 不可取。

如果您用的是上述做法，那您可能看了下面这个做法，就会赞叹于它的短小精悍。

------------

先考虑暴力，无非就是对于每个格子，枚举所有空调，取答案最小值。

显然时间复杂度不可接受，尝试直接在此基础上优化。

注意到每个格子最终答案只可能是所有空调的某一个决定的。那我们记 $f_i$ 表示第 $i$ 个位置上的答案，有比较好想的初始化：一开始有空调的位置 $f$ 值等于空调温度，否则为正无穷。

然后考虑 DP 转移。考虑 $f_i$ 一定被其左面某个空调或右面某个空调更新（如果原来 $i$ 有空调的话可能不被更新，但无妨我们下面的操作）。那不妨如下：假设我们已经求出 $f_{i-1}$ 和 $f_{i+1}$，那么 $f_i=\min{(f_i,f_{i-1},f_{i+1})}$。

但是显然不可能在更新 $f_i$ 同时知道 $f_{i-1}$ 和 $f_{i+1}$，这不满足无后效性。

但是注意到如果 $f_{i-1}$ 某一次更新不了 $f_i$，那无论之后 $f_{i-1}$ 怎么变，它也更新不了 $f_{i}$。$f_{i+1}$ 同理。

或者您可以理解为 $f_{i}$ 不会被自己更新的数更新。

这也就表明我们可以把 $f_{i-1}$ 的更新和 $f_{i+1}$ 的更新分开算，它们之间互不影响，即：

$$f_i=\min(f_i,f_{i-1}+1),i:1 \to n$$

$$f_i=\min(f_i,f_{i+1}+1),i:n \to 1$$

结束！

------------

CODE:

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cmath>
using namespace std;

long long t,n,m,f[300010],id[300010],w[300010];

int main(){
	long long i,j,u,v;
	cin>>t;
	while(t--){
		cin>>n>>m;
		for(i=1;i<=n;i++) f[i]=10000000000000000;
		for(i=1;i<=m;i++) cin>>id[i];
		for(i=1;i<=m;i++) cin>>w[i];
		for(i=1;i<=m;i++){
			u=id[i];v=w[i];
			f[u]=v;
		}
		for(i=2;i<=n;i++) f[i]=min(f[i],f[i-1]+1);
		for(i=n-1;i>=1;i--) f[i]=min(f[i],f[i+1]+1);
		for(i=1;i<=n;i++) cout<<f[i]<<" ";
		cout<<endl;
	}
	return 0;
}
```

------------

然后就是注意一下这题最大值不是 $10^9$，而是 $10^9+maxN$。原因的话看一下题目样例的第 4 组就明白了。