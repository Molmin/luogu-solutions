这道题的要求不少方法都能实现，但是用 DP 来做是最优的。

### 分析

既然是 DP，我们就要考虑「状态」与「转移」。

略微读题可知，状态就是格子的温度。

我们发现，一个格子温度只会被它左右的温度所刷新，也有可能不会被刷新。

知道了这一点，就能明白转移即是当前格子与前后两个格子温度的最小值。

### 实现：

开一个 DP 数组用来存储每个格子的温度。

有空调的格子温度暂时是当前格子上空调的温度，没有空调的格子温度暂时未知，所以设为无穷大。这算是初始化。

从前后分别扫一遍，得出结果。

为什么需要扫两遍？

众所周知，一个格子的温度不可能同一个空调更改多次。

第一遍从左到右扫，可以处理所有空调右侧的温度；
第二遍从右到左扫，可以处理所有空调左侧的温度。

同一个空调对于一个格子的温度是固定的，而我们要做的是从这些空调的温度中选择最小的。

也就是说，只有确定了所有空调对于每一个格子的温度，才可以保证每一个格子的温度都是最小的。

这里的思路和暴力有点像，但是需要用到 DP 来实现。

### 代码：

```c
#include<iostream>
#include<cmath>
using namespace std;
int q;//数据数 
int n,k;//格子数和空调数 
int a[300005];//空调的位置 
int t[300005];//空调的温度 
int dp[300005];//格子的温度，用于DP 
int main(){
	cin>>q;
	while(q--){
		cin>>n;
		cin>>k;
		for(int i=0;i<=n+1;i++){//初始化所有格子温度无穷大 
			dp[i]=0x3fffffff;
		}
		for(int i=1;i<=k;i++){//读入空调的位置 
			cin>>a[i];
		}
		for(int i=1;i<=k;i++){//读入空调的温度 并对应到格子里 
			cin>>t[i];
			dp[a[i]]=t[i];
		}
		for(int i=1;i<=n;i++){//从左到右扫一遍 
			dp[i]=min(dp[i],dp[i-1]+1);
			dp[i]=min(dp[i],dp[i+1]+1);
		}
		for(int i=n;i>=1;i--){//从右到左扫一遍 
			dp[i]=min(dp[i],dp[i-1]+1);
			dp[i]=min(dp[i],dp[i+1]+1);
		}
		for(int i=1;i<=n;i++){//输出答案 
			cout<<dp[i]<<" ";
		}
	}
	return 0;
}
```


