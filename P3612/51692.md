## 梳理题意

给定一个字符串，每次将其最后一个字符移到最前方，形成的新串接到原串后作为下一次操作的字符串

现询问第 $N$ 个位置的字符

## 简要分析

看一眼数据范围， $N<10^{18}$ ，显然不能模拟，所以我们从每一次操作入手

很明显，每一次操作过后，串的长度就会成为原先的两倍，所以可以想到以下这个算法。

------------

#### **分治**

分治，即为分而治之，顾名思义，就是把一个问题分成若干个子问题，然后对每个子问题分别处理，最后再将每个子问题的结果合并起来。

如果想对分治算法了解更多的同学，可以移步[此处](https://oi-wiki.org/basic/divide-and-conquer/#_5)

------------

#### 那么这道题目该如何分治呢

首先，为了找到第 $N$ 个字符，我们可以用一个 $t$ 变量记录在什么时候字符串长度超过 $N$ ，代码如下

```cpp
while (t < n) t <<= 1;	//位运算更快
```

通过题意可得，当第 $N$ 个字符在长度为 $t$ 的字符串的后半段时，前半段字符串中的第 $N-1-t/2$ 个字符肯定与第 $N$ 个字符相同，因为第 $N$ 个字符在前一次操作时就是有第 $N-1-t/2$ 个字符转换过来的，所以我们可以由此写出以下代码

```cpp
while (t != l) t >>= 1, n -= 1 + t;
```
但是上面这段代码离正确代码虽然接近，却又相差甚远

在原操作中，我们是将字符串的最后一个字符移到第一个后接到原串后的。倒推可得，在长度为 $t$ 的字符串中，当 $N$ 等于 $t/2+1$ 时，即第 $N$ 个字符为后半段字符串的第一个时，与之必定相同的字符位置应为 $t/2$ 或 $N-1$，因此加入这个特判后的代码如下

```cpp
while (t != l) {
	t >>= 1;
	if (t + 1 == n) n = t;
	else n -= 1 + t;
}
```

使用三目运算符也可以简写成以下代码

```cpp
while (t != l) t >>= 1, n = (t + 1 != n) ? n - 1 - t : t;
```

以上所有代码都是建立在第 $N$ 个字符在长度为 $t$ 的字符串的后半段时，当第 $N$ 个字符在长度为 $t$ 的字符串的前半段时，我们就不需要做任何操作，直接将 $t/2$ 就行了，代码如下

```cpp
while (t != l) {
	t >>= 1;
	if (n <= t) continue;
	if (t + 1 == n) n = t;
	else n -= 1 + t;
}
```

## 完整代码

```cpp
#include <bits/stdc++.h>
using namespace std;
long long l, n, t;
char s[55];
int main() {
	scanf("%s%lld", s + 1, &n), l = t = strlen(s + 1);
	while (t < n) t <<= 1;
	while (t != l) t >>= 1, n = n > t ? ((t + 1 != n) ? n - 1 - t : t) : n;
	putchar(s[n]);
	return 0;
}
```

------------

最后，这里再推荐两道分治好题——>[平面最近点对（加强版）](https://www.luogu.org/problem/P1429)和[地毯填补问题](https://www.luogu.org/problem/P1228)
