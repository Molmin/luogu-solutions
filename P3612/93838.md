[题目链接](https://www.luogu.org/problem/P3612)

（拿到题目的众多第一件事之一就是看数据范围

1e18 如此大的数就连平时比较好看的线性算法都跑不过去

那我们就必须用一些 玄学 优秀的方法搞一个O(log n)或者$O(\sqrt n)$的复杂度


我们先考虑一下正向思维

如果光看题目样例模拟一遍还是lou得住的
但是如果数据大那么一丢丢，比如CGYAKIOI的第6666666位

如果正着去思考的话，就不一定可以lou得住了

因为如果正向思考的话我们需要搞出每一个位置的字符，$O(n)$过1e18，想想都不可能


但其实在正向思考的时候，我们跑了很多毫不相干的点，但是由于不确定目标位置是从谁那里推过去的，因此我们不可避免地要把每个位置都求出来，剪掉那些无用点也就成为我们的复杂度瓶颈。

------------

在毫无头绪的情况下，我们不妨再重新审视一遍样例。

我们思考：

第八个位置上的C是通过第五个位置上的C搞过来的，而第五个C又是从第一个C那里搞过来的

那么我们就可以反过来想，第八个位置是从第五个位置搞过来的，而第五个位置又是从第一个位置搞过来的，而第一个位置我知道，那玩意儿是C，所以第八位是C

想到这里，我们就可以发现其实反着想比正着想要好得多，因为反着想只需要考虑目标位置上的字母，那么那些一点血缘关系都木有的位置就可以鸟都不鸟了

而目标位置的形成最多也是log级别的，这样子跑一遍就可以lou住了


因此我们可以想象到要从第n个位置往前推，如果可以找到那么一种规律使其可以快速从后一个位置推到前面的位置，那么这道题也就可以迎刃而解了



------------


不妨设原序列长度为k，那么对于第n个位置，我们不难发现它的前一个位置只有两种可能：

1、当n-1等于k*2^x(x为非负整数)，那么n的上一个位置必然是n-1

2、当n-1不满足上述情况，那么n的上一个位置是n-2^x(x为使n-k*2^x>=0的最大负整数)

如果用代码实现就是这个样子：
```cpp
if(n==length*m[help]+1) n-=1;	//如果是在头头的情况就减减 
else n-=length*m[help]+1;		//否则就把它往左边搞 
```

每次求x也是一个很让人 ~~dt~~ 困惑的地方

我们先假设当前位置刚好不在2^n*k次方这种刁钻的地方

那么必然会有 k*2^x < n < k*2^x+1

如果两边同除一个k就会有2^x<n/k<x^x+1

这个玩意儿应该不难求吧

用代码实现就是：
```cpp
unsigned long long k=n/length;
unsigned long long help=0;
while(k){
	help++;
   k>>=1;
}
```
那么对于当前位置就是那么刁钻的情况，我们经过样例模拟可以发现这个 dt 令人烦躁的东西恰好等于按照上面那种情况求出的答案再减一



------------


于是实现起来也就很方便了
```cpp
#include<cstdio>
#include<cstring>
using namespace std;
char s[45],ch;
int length;	//原来字符串的长度 
unsigned long long n;
unsigned long long m[65]={0,1};
int main(){
    for(register int i=2;i<=64;i++) m[i]=m[i-1]<<1;	//此处可以事先把2的n次幂储存起来，方便后面使用 
    ch=getchar();
    while(ch>='A' && ch<='Z'){	//不停读入字母 
        s[++length]=ch;
        ch=getchar();
    }
    scanf("%llu",&n);
    if(length==1){	//如果字符串长度只有一，那就可以不加思考地输出唯一的字母 
        printf("%c",s[1]);
        return 0;
    }
    while(n>length){//当推到当前状态的位置n还不在原字符串的长度之内，那就继续推下去吧 
        unsigned long long k=n/length;
        unsigned long long help=0;
        while(k){
            help++;
            k>>=1;
        }								//这一坨都是用来求help使得2^help<=n/k && 2^help+1>n/k 
        if(n==m[help]*length) help-=1;	//如果刚好在边界的话，那就help--
        if(n==length*m[help]+1) n-=1;	//如果是在头头的情况就减减 
        else n-=length*m[help]+1;		//否则就把它往左边搞 
    }
    printf("%c",s[n]);					//输出 
    return 0;
}
```
其实如果一开始就可以敏锐地感觉到要倒着推的话，这道题是可以秒切的（当然我功力不足，秒切什么的还是不可能的

所以还是推荐大家平时一定要多刷一些题目，越毒瘤的就题目越要搞懂，而且一定要写做题记录，这样可以在以后的比赛中轻松提取模型+轻松切题

Finally，谢谢观看