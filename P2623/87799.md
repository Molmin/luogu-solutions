## 前言

前置算法:01背包。

其他题解都是$O(n×m²)$,分享一个$O(n×sum\{log_2(c÷b)\})$(也就是$O(n×m×log_2(m÷b))$)的做法。(算了一下$nm²$,有$4×10^{8}$,以为过不了)

请看50pts后再看100pts,否则你会看不懂。

不理解的可以结合代码来理解。

## 50pts

> 对于50%的数据，只有乙和丙两类物品；

现在只有乙和丙,那么就是混合完全背包和部分背包。但是没必要用混合背包。直接把完全背包看成有m÷b个的部分背包。

[可能有点不好理解,可以看举例]然后部分背包可以采用二进制拆分(有点像倍增思想)。假设重量为$x$,把它拆成$(log_2(x)+1)$个背包,分别为$2^i(0<=i<log_2(x))$和剩余重量。

比如有$19$个物品。就把它拆成$6$个物品:$1+2+4+8+16+3$,这样就可以表示19了。(证明:$16$以内可以用二进制表示,剩余的$17~19$可以用$14~16$加上$3$),然后就转化为了01背包。

简单讲解01背包。

01背包:设$f[i][j]$为容量为$j$时前$i$个物品的最大值。$a[i]$为体积,$b[i]$为价值。

$f[i][j]=max(f[i-1][j],f[i-1][j-a[i]]+b[i]);$

## 100pts

此时加入了一个甲,我们发现只需要选取$1$个甲。因为$2$个甲物品一定比$1$个更差。因为$x^{2}$一定比$a^{2}+(x-a)^2$要更优。

那么我们就枚举选多少的甲容量。

根据上面的推论,甲的价值为所有价值中的最大值。

由于乙丙容量$f$已求出,所以总容量就是$O(n²)$循环枚举了。具体见代码↓。
## AC代码。
```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int a[1000005],b[1000005],c[1000005],d[1000005],tot0=0,tot1=0; //a,b表示01背包体积价值。c,d表示甲物品。
int f[5005][2005]; 
int main(){
	int tot=0,n,m,i,j,opt,A,B,C,Max=0,ans=0,t=0;
	cin>>n>>m;
	for(i=0;i<n;i++){
		scanf("%d",&opt);
		if(opt==1){
			tot1++;
			scanf("%d %d",c+tot1,d+tot1);
			continue;
		}
		scanf("%d %d",&A,&B);
		if(opt==3){
			C=m/B; //完全背包->部分背包。
		}else{
			scanf("%d",&C);
			C=min(m/B,C); //优化。
		}
		for(j=1;(j<<1)<=C;j<<=1){ //部分背包->01背包(拆分)。
			a[tot0]=B*j;
			b[tot0]=A*j;
			tot0++;
		}
		a[tot0]=B*(C-j+1);
		b[tot0]=A*(C-j+1);
		tot0++;
	}
	for(i=0;i<=m;i++){ //01背包初始化。
		if(a[0]<=i){
			f[0][i]=b[0];
		}else{
			f[0][i]=0;
		}
	}
	for(i=1;i<tot0;i++){ //01背包。
		for(j=0;j<=m;j++){
			if(j<a[i]){
				f[i][j]=f[i-1][j];
			}else{
				f[i][j]=max(f[i-1][j],f[i-1][j-a[i]]+b[i]);
			}
		}
	}
	for(i=0;i<=m;i++){
		Max=0;
		t=m-i; //t表示剩下多少给甲的容量。
		for(j=1;j<=tot1;j++){
			Max=max(Max,c[j]*t*t-d[j]*t); //计算该容量下甲物品的最大值。
		}
		ans=max(ans,f[tot0-1][i]+max(0,Max)); //与0取max是因为如果价值小于0那么不如不选取甲。
	}
	cout<<ans;
	return 0;
}
```
//39ms 7.62MB  _**~~是不是很神奇?~~**_