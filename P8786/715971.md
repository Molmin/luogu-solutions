五花马，千金裘，呼儿将出换美酒，与尔同销万古愁！

——李白《将进酒》

# 题目传送门
[P8786 李白打酒加强版](https://www.luogu.com.cn/problem/P8786)
# 题意
初始的计数值（即酒的斗数）为2。

共有$ (n+m) $个节点，其中$n$个点让计数值翻倍（店），其余$m$个点让计数值减去1（花）。李白必须经过所有 $(n+m)$ 个节点，其中，他最后一个经过的节点一定是使计数值减去1的节点。

现在需求出有多少种可能，李白在经过所有节点后的计数值为0。

# 思路

## 前置思路
已知最后一个节点一定为花，则李白在经过 $(n+m-1)$ 个节点后得到的计数值一定为1。

通过模拟思想，可知：

1. 如果李白此次遇见的是花，则上次留下酒的斗数一定大于等于1。

1. 如果李白此次遇到的是店，则此次酒的斗数一定是偶数。即：如果显中有k斗酒，则：$0 = k \bmod 2$。
## 程序思路
使用动态规划算法。

设```f[i][j][k]```表示李白在第```i```个节点，已经遇到```j```次花，显里有```k```斗酒的状态。

根据加法原理，推出状态转移方程为：

```cpp
if(k%2==0){
	f[i][j][k]+=f[i-1][j][k/2];
}
if(j>=1){
	f[i][j][k]+=f[i-1][j-1][k+1];
}
```

注意：如果这次选择的是店，要保证 $k \bmod 2 =0$。如果这次选择的是花，要保证 $j≤(m-1)$。

# 代码

```cpp
#include<bits/stdc++.h>//万能头文件 
using namespace std;
long long n,m;//n:店，m:花 
const long long mod=1e9+7;//1e9+7=1000000007
long long f[514][114][191];//f[i][j][k]代表：在第i个时刻，遇到了j次花，此时显中有k斗酒 
//因为最多有100次遇花，所以酒的数量一定不大于100
long long ans;//ans=f[n+m-1][m-1][1];
int main(){
	scanf("%lld%lld",&n,&m);//输入 
	f[0][0][2]=1;//在第0时刻 
	for(long long i=1;i<=n+m-1;i++){
		for(long long j=0;j<=min(i,m-1);j++){
			for(long long k=0;k<=m+1;k++){
				if(k%2==0){//如果这一次遇到的是店（满足条件：这一次的斗数为偶数，即mod2=0。 
					f[i][j][k]+=f[i-1][j][k/2];
				}
				f[i][j][k]%=mod;//取模 
				if(j>=1){//如果遇到花 （满足条件：在遇到过花后至少统计了一次遇花） 
					f[i][j][k]+=f[i-1][j-1][k+1];
				}
				f[i][j][k]%=mod;//取模 
			}
		}
	}
	ans=f[n+m-1][m-1][1];//因为最后一次一定遇花，则ans=f[位置数-1][遇花次数-1][0+1]; 
	printf("%lld",ans);//输出 
	return 0;
}
```
求审核通过QWQ。
