### 解题思路

这道题看起来是 dfs，于是我用了 dfs（分治）来解决。由于题目给的是一颗无根树，那么我们不妨就设根节点为 $1$ 号节点。

#### Part 1：方案

![](https://s1.ax1x.com/2022/12/18/zqS0BT.png)

我们可以从叶子结点入手，如果多于平均值就运到父节点多的部分，如果少于平均值就从父节点运缺的部分给它。

如上图，我们考虑五角星节点，它应该运向它的父节点 $3$ 个干草捆。

于是我们可以用基于 dfs 的分治算法，先递归处理某节点的所有子树，把信息汇总到该节点上，再根据情况向父节点调整。

#### Part 2：顺序

运输的过程中，难免会遇到这样一个问题：**在某时刻某个节点的干草捆数量为一个负数**！于是我们想要优化运输顺序。

由于“给”的一般比“借”的来得更优，于是我们考虑先“给”后“借”。

具体地，我们考虑任意一个节点，先考虑把有多余的子树的多余的部分“拿”过来，再将又缺少的子节点“补”过去。最后此节点如果有多余，就把多余的部分上传到父节点上。总之，就是先“上传”后“下传”。

#### Part 3：具体流程：

1. 若一个节点代表的子树有多余，那么首先处理多余的子节点代表的子树，然后接收上传，再下传给缺少的子节点代表的子树，再处理它们，最后上传给父节点。

2. 若一个节点代表的子树有缺少，那么首先接收来自父节点的下传，然后处理多余的子节点代表的子树，再接收上传，再下传给缺少的子节点代表的子树，最后处理它们。

#### Part 4：证明

先证最优性。当某条边的两边子树有多有少时，这条边一定会被拿来运输；否则这条边一定不会被拿来运输（两边子树自己调整）。而这种思路刚好满足这一点。

再证合法性。按照上面的流程，某个节点的干草捆一定是先加后减的（可能先接收父节点的下传，再接收多余子树的上传，然后下传给不足子树，最后上传给父节点），而刚开始为正数且最后一定为平均值（正数），说明中间过程中一定大于等于平均值即正数，不可能出现负数。

#### AC Code

```c++
#include <cstdio>
#define N 200005
using namespace std;

int n, x, y, tot, ans, head[N], nxt[N << 1], ver[N << 1];
long long ave, a[N], f[N];

void insert (int x, int y) // 构建邻接表
{
	ver[++ tot] = y, nxt[tot] = head[x], head[x] = tot;
	return ;
}

void dfs (int x, int fa) // 处理多余/缺少，顺便统计答案
{
	for (int i = head[x], y; i; i = nxt[i]) // 遍历当前节点所有边
	{
		if ((y = ver[i]) == fa) // 指向父节点的边，跳过
		{
			continue;
		}
		dfs (y, x);
	}
	f[x] = a[x] - ave, a[fa] += f[x], ans += (bool) f[x];
    // f[x]：多余出来多少干草捆，缺少则是负数
    // 把多余或缺少的累计到父节点上，统计答案
	return ;
}

void sol (int x, int fa) // 解决顺序问题，输出具体命令
{
	// 第一遍 for 先扫那些多余干草捆（或刚好）的子节点
	for (int i = head[x], y; i; i = nxt[i])
	{
		if ((y = ver[i]) == fa || f[y] < 0)
		{
			continue;
		}
		sol (y, x);
	}
    // 第二遍 for 再扫那些缺少干草捆的子节点
	for (int i = head[x], y; i; i = nxt[i])
	{
		if ((y = ver[i]) == fa || f[y] >= 0)
		{
			continue;
		}
		printf ("%d %d %lld\n", x, y, -f[y]), sol (y, x);
	}
	if (f[x] > 0) // 上传给父节点干草捆
	{
		printf ("%d %d %lld\n", x, fa, f[x]);
	}
	return ;
}

int main ()
{
	scanf ("%d", &n);
	for (int i = 1; i <= n; i ++)
	{
		scanf ("%d", &a[i]), ave += a[i];
	}
	ave /= n; // 先求平均值
	for (int i = 1; i < n; i ++)
	{
		scanf ("%d%d", &x, &y), insert (x, y), insert (y, x);
	}
	dfs (1, 0), printf ("%d\n", ans), sol (1, 0);
	return 0;
}
```