这道题的算法为贪心，我们只要先考虑组成 256 的情况，再考虑组成 32 的情况就能得到最优解。

考虑 256 的情况代码：
```cpp
ans=min(k2,min(k5,k6));//ans 表示能组成几个 256 ，k2,k5,k6 分别为 2 的个数，5 的个数，6 的个数
```
考虑 32 的情况的代码：
```cpp
sum=min(k3,K2);//sum 表示能组成几个 32，k3 表示 3 的个数，K2 表示除去组成 256 的 2 后还剩下的 2 的个数
```
我们把这两段代码合并一下，得到一个不完整的 $\Theta(1)$ 的 $\color{green}\texttt{AC}$ 代码：
```cpp
ans=min(k2,min(k5,k6))*256+min(k2-min(k2,min(k5,k6)),k3)*32;
```
完整 $\color{green}\texttt{AC}$ 代码只要加上读入、输出、定义什么的就行了，所以在这里不放了。