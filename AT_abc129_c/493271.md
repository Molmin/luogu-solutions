[题目传送门](https://www.luogu.com.cn/problem/AT4787)

[更好的阅读体验？](https://www.luogu.com.cn/blog/493271/solution-at4787)

# Thinking

首先说一下其他题解，比如[这篇题解](https://www.luogu.com.cn/blog/taozhilin/solution-at4787)：

ps:这篇题解后来在我的热心提醒下改了过来 qwq，艹还发帖举报我。

## 动态规划

动态规划是一种通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法，应用于子问题重叠的情况。要去刻画最优解的结构特征，尝试递归地定义最优解的值（就是我们常说的考虑从 $ i-1 $ 转移到 $ i $），计算最优解，利用计算出的信息构造一个最优解。

## 递推

通过已知条件，利用相邻的数据项间的关系（即：递推关系），得出中间推论，直至得到结果的算法。

而本题不需要求最优解，没有最优子结构，只是普通的计数问题，只能称为递推，称为动态规划是不规范的，而题解必须严谨！

回归正题。

定义一个数组 $ a $,$ a_i $ 表示从第 $ 0 $ 级台阶出发走到第 $ i $ 级的方案数，而第 $ i $ 级是怎么走到的呢？是从第 $ i-1 $ 级或第 $ i-2 $ 级走到的，所以 $ a_i $ 的值也就由 $ a_{i-1} $ 和 $ a_{i-2} $ 得到。

对于初始化，从第 $ 0 $ 级台阶出发，所以走到第 $ 0 $ 级台阶的方案数为 $ 1 $。

还有需要注意的事，有 $ m $ 级台阶不能走，所以我们在输入时预处理是哪些台阶不能走，在递推遍历到不能走的台阶时，将走到该台阶的方案数设置为 $ 0 $ 即可。

# Coding

```
  #include<bits/stdc++.h>
  using namespace std;
  const int N=1e5+5,mod=1e9+7;
  int n,m,x,a[N],f[N];
  signed main(){
      a[0]=1;
      cin>>n>>m;
      while(m--){
          cin>>x;
          f[x]=1;
      } 
      for(int i=1;i<=n;i++){
          if(f[i]){
              continue;
          }
          a[i]=a[i-1]+a[i-2];
          a[i]%=mod;
      }
      cout<<a[n];
      return 0;
  }
```