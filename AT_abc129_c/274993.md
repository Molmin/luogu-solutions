看到题解中好像没有人提到，这其实是一个变形的 **斐波那契数列**。

考虑一下斐波那契数列的定义，是 $f _ 0 = 1, f _ 1 = 1, \forall i \geq 2, f _ i = f _ {i - 1} + f _ {i - 2}$。

我们考虑一下这个楼梯，首先先不考虑损坏的部分。

那么对于第 $i$ 级楼梯，它**可以从 $i - 1$ 级或者 $i - 2$ 级上来**。

也就是说，上到第 $i$ 级楼梯的方案数，就是**上到第 $i - 1$ 级楼梯的方案数和第 $i - 2$ 级楼梯的方案数之和**。

如果我们用 $f _ i$ 来表示上到第 $i$ 级楼梯的方案数，那么就是 $f _ i = f _ {i - 1} + f _ {i - 2}$。

如果我们令 $f _ 0 = 0$，那么这就是斐波那契数列。

---

接下来考虑一下楼梯损坏的部分，如果第 $i$ 级楼梯损坏，那么是不是可以认为，$f _ i = 0$？

也就是说，上到第 $i$ 级楼梯的方案数，是 $0$。

所以我们在计算的时候，只需要判断一下当前楼梯是不是损坏的，如果是，那么就把当前楼梯的方案书清零，然后接着往下计算就可以了。

### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;

#define lint long long
#define rep(_, __, ___) for (int _ = __; _ <= ___; ++_)

int n, m;
int a[100005];
lint f[100005];

const int modint = 1e9 + 7;

int main()
{
	scanf("%d%d", &n, &m);
	rep(i, 1, m)
		scanf("%d", a + i);
	int ptr = 1;
	f[0] = f[1] = 1;
	if (a[ptr] == 1)
		f[a[ptr]] = 0, ++ptr;
	rep(i, 2, n)
	{
		f[i] = (f[i - 1] + f[i - 2]) % modint;
		if (i == a[ptr])
			++ptr, f[i] = 0;
	}
	printf("%lld\n", f[n]);
	return 0;
}
```

这里有一个小 Trick 是，由于它的损坏的楼梯是按从小到大给出的，所以我们只需要用一个指针 `ptr` 来记录一下当前已经计算到第几个损坏的楼梯，当当前 `ptr` 所指楼梯被计算完后，只需要让 `ptr + 1` 即可。