本人表示并不知道树上LIS问题。。。

我也只能连猜带蒙地口胡，讲出一个仿佛是正解的东西，正确性未知

题目叫我们在一棵树中选出尽可能多个点，使得每一个点的点权小于其祖先的点权

想到离散化，考试时在想，我们能不能将它转化成一个联通块，通过树dp解决呢？

对于40分的做法：设k为i的一个子节点

因为对于每个点i，k仅有一个权值，对于i来说，k可选可不选

于是我们想到修改权值，强行把k的权值进行修改，

使得满足每一个点的点权小于其祖先的点权（这一步需要点灵感）

设dpi,j为在以i为子树的点集里，当i的权值（离散化后）被修改成j时，

选出最多子集的点数（也就等同于没有被修改过的点的数量）

初始化条件为dpi,wi=1

依次地合并子树，因为dpi,j能与dpk,l合并时仅当j<=l，于是树dp方程为：

dpi,j+=Maxnl=jdpk,l​，想到后缀最大值数组，优化到O(n2)

于是考试时就卡这了

对于100分的做法：

其实，我们把我们所做的几件事列一列：

1.初始化dpi,wi=1

2.依次对每个子节点累加最大值

3.计算后缀最大值数组

void dfs(R int u) {
        f[u][w[u]] = 1;//1
        for(R Edge *i = la[u]; i; i = i->ne) {
            R int to = i->v; dfs(to);
            for(R int j = 1; j <= P; ++j) f[u][j] += g[to][j];//2
        }
        for(R int i = P; i >= 1; --i) g[u][i] = Max(g[u][i + 1], f[u][i]);//3
 }

考虑一直迭代搜索到叶节点，观察修改dp数组的只有1操作

一开始数组是这样的：

0 0 0 ..... 0 0 0

经过1操作:0 0 0 0.....1 0 0 ..... 0 0 0

经过3操作:0 0 0 0.....1 1 1 ..... 1 1 1 //忽略了2

在逐渐取最大值是，发现g一定是递增的（并不严格）

于是想到差分数组，就等同于在w[i]这个位置插入一个1，其他仍是0

由于差分数组的性质，答案就等同于全部位置之和相加

再模拟取最大值的过程，原来的g数组是0 0 0 .... 0 1 1 1 1

再插入一个变成0 0 0 ... 1 1 1... 1 1 1 ，

实际上这个操作的本质的问题，就是把i到i前的数直接的0变成1

在差分数组上的操作就是++t[i];--t[pre[i]];

但如果i之前没有数的话，就不用--t[pre[i]]了

于是我们考虑用一个multiset维护序列，每次插入值，

合并的过程中运用启发式，取最大值时找到他的前驱把它删掉，

最后答案即为还留在multiset中剩余的数的数量

完了