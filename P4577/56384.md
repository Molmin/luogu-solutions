怎么各位julao都写的线段树合并啊……

然而启发式合并跑的飞起，$O(nlog^2n)$甚至跑的比一些常数大的$O(nlogn)$的线段树合并还快……
__________________

## 本题题解

首先翻译一下并不是很好理解的题意

给你一棵有根树，让你从这棵树当中选取一个点集，使得对于在这个点集中的每一个点，它的点权都大于它的每一个被选中的祖先。

为了方便起见我们将点权离散化……

然后我们发现这个问题有点像树上的最长上升子序列问题……，但是我们并不会做子序列的问题，因为在我们点集中的点在树上不一定相邻，但是我们的树形dp是要求一定是孩子和父亲进行转移才可以进行列dp定义和推dp方程的，所以我们考虑转化一下这个问题，使得它变成一个可爱的树上的联通块问题……

假设我们选取了树上的一个点集，那么我们可以通过适当的向点集中添加一些额外的点来将这个点集变成一个联通块，那么问题来了，这个被我们强行构造出的联通块可能不符合任意一个点集中的点都大于它的每一个被选中的祖先这个条件……

但是显然原来就在点集中的点是符合的这个条件的，我们破坏了这个约束是因为我们新加入的点破坏了原来的点权关系，因此我们就将这些点的点权强行赋成一个合适的值，使得重新赋值之后这个联通块满足点权的约束关系(可以证明这样的转化方式一定存在)

现在就是我们坠喜欢的联通块问题了！

因此我们可以列出这样的一个dp式子$dp_{i,j}$表示联通块中最高点为i，且i取为j的点权时，联通块中未被篡改点权点数的最大值

那么根据树形dp的一般套路我们考虑孩子和父亲之间的转移问题，考虑我们现在决策到了第v棵子树，现在要把这颗子树加到它的父亲u的联通块中的情况

那么我们发现$(u,j)$和$(v,k)$这两个点之间能放在同一个联通块当中当且仅当$j<=k$

那么我们可以推出这样的状态转移方程

## $Dp_{u,j}+=Max_{k=j}^{n}Dp_{v,k}$

意义是我们枚举所有合法的连边情况在所有的连边方案当中取max

初始条件每个点的$Dp_{i,w_{i}}=1$其他dp项全部为0

直接暴力转移复杂度是$O(n^3)$通过预处理这个数组的后缀max数组的方式我们可以将复杂度降到$O(n^2)$但是问题来了我们的数据范围是$10^5$因此这点优化完全没用

发现复杂度在转移上，所以我们考虑一下如何优化这个东西

我们发现转移一整个数组的过程相当于于把每个u孩子v的dp数组的后缀max数组按位相加之后最后把u的原始dp数组和这个数组按位相加。

如果你足够熟练的话数组按位相加这个操作应该难不住你，但是你会面临一个十分辣手的操作——求后缀max数组

假如你是一名即将ak的julao，闲来无事打印出了这个dp数组的差分数组

那么我们考虑把这个数组进行后向差分，那么原数组按位相加相当于差分数组按位相加

下面我们考虑求后缀max数组的操作，发现一个有趣的性质，对于一个后向差分全部非负的数组，它的后缀max数组和原数组一样……，而且后缀max数组一定是差分全正的……

因此我们得出这样一个结论，【各个孩子的】【后缀max数组的】和数组【的差分】一定也是全正的

那么我们发现一件很有意思的事情，只有加入了u的数组之后这个数组才有可能出现负差分的现象，此时我们求后缀max数组才有意义，如果同时出现了多个负点我们将会非常难受，但是问题来了，这个差分数组最多有几个负点呢？

显然负点只能来自和u的数组按位相加这个操作

但是注意到我们变换了转移顺序，先加完了所有儿子，最后考虑u，因此我们的u数组还是边界条件状态……

也就是说一堆0里有一个1

换句话说它的差分数组就是一个1紧贴着一个-1

所以u数组做完按位相加之后这个东西里面最多有一个负点

考虑插入这个-1的时候会发生什么

如果加到了一个正的差分上加完之后差分数组非负所以不用管

很不幸的加到了0点上我们可能需要考虑一下如何处理这个-1差分

显然会让插入之后的数组"下沉"一个单位，此时我们取后缀max导致了这个下沉的部分会有一部分被这个-1前面的位置“填平”

那么由于下沉的高度只有1，因此被填平的区间就是这个-1的位置到这个-1前面的第一个非零差分的位置，然后由于这个位置被填平了1，因此这个前驱需要-1，然后剩余的差分并不改变

如果前驱不存在的话那么所有点都将被填平，所以这个-1白插了

那么我们看一看现在我们需要兹瓷什么操作……

数组按位相加，找数组里某一个位置之前第一个非0位置

找前驱map即可

什么？你说按位相加？暴力启发式合并，把小的map中的元素一个一个加入到大的map当中复杂度$O(nlog^2n)$

所以我们就用一个map愉快的做完了这道题

(其实找前驱和按位相加可以使用权值线段树合并做到更优秀的复杂度，但是我懒得写了QAQ)

代码很好写~

上代码~

```C
#include<cstdio>
#include<algorithm>
#include<map>
using namespace std;const int N=2*1e5+10;int n;int tot;
map <int,int> dp[N];int res;
int v[N];int x[N];int al[N];int ct;int w[N];int lsh[N];int rk[N];
inline void add(int u,int V){v[++ct]=V;x[ct]=al[u];al[u]=ct;}
inline bool cmp(int a,int b){return w[a]<w[b];}
inline void merge(int p1,int p2)//暴力启发式合并 
{	
	if(dp[p1].size()<dp[p2].size())swap(dp[p1],dp[p2]);
	map <int,int>::iterator it;
	for(it=dp[p2].begin();it!=dp[p2].end();++it){dp[p1][it->first]+=it->second;}
}
inline void dfs(int u) 
{
	for(int i=al[u];i;i=x[i]){dfs(v[i]);merge(u,v[i]);}//加一下所有孩子 
	int fk=rk[u]-1;if(dp[u].begin()->first>fk)return;//找前驱 ,lower_bound之后--迭代器即可 
	map <int,int>::iterator it=dp[u].lower_bound(fk);if(it->first!=fk)--it;
	if(it->second==1){dp[u].erase(it);}else it->second--;//记得判一下如果是1的话减法改成erase 
}
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)scanf("%d",&w[i]);
	for(int i=2,f;i<=n;i++){scanf("%d",&f);add(f,i);}
	for(int i=1;i<=n;i++)lsh[i]=i;sort(lsh+1,lsh+n+1,cmp);//离散化 
	rk[lsh[1]]=1;for(int i=2;i<=n;i++)rk[lsh[i]]=(w[lsh[i]]==w[lsh[i-1]])?rk[lsh[i-1]]:i;
	for(int i=1;i<=n;i++)dp[i][rk[i]]++;dfs(1);map <int,int>::iterator it;
	for(it=dp[1].begin();it!=dp[1].end();++it){res+=it->second;}//加上所有的差分就可以还原原数组的最大值 
	printf("%d",res);return 0;//拜拜程序~ 
}
```