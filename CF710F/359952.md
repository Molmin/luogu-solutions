首先这个操作很难不想到 AC 自动寄，直接建出来两个 AC 自动寄，1 操作的和 2 操作的，然后相减寄可。

接下来转化为每次加入一个串，维护 AC 自动寄。

但是发现我们每次都要加一个串到 AC 自动寄里面去非常麻烦，复杂度直接爆炸。

首先要知道的是合并两个 AC 自动寄的时间是两个自动寄的大小之和，我们实际上是把一个 $k-1$ 的自动寄和 $1$ 的自动寄合并了起来，非常的亏啊。

于是我们能联想到分治 FFT，就是把它分成一半再合并，这个可以达到复杂度最小化。

但是问题又来了，这个要动态加入，怎么办呢。

我们有一个聪明的办法，叫做二进制分组，可以每 $2^k$ 维护一个自动寄。

就比如说现在 是第 $(1011)_2+1$ 次加入，我们的自动寄就是 $1$ 到 $2^3$ 一组，$2^3+1$ 到 $2^3+2^1 $ 一组，$2^3+2^1+1$ 到 $2^3+2^1+2^0$ 一组（这个还挺难想）。

那怎么加入呢，我们想到二进制加法，你底下加 1 怎么办，是不是一个一个进位上去知道这位是 0 进不了位对吧，于是我们模拟这个操作。

接下来我们考虑为什么复杂度对了，我们不算每一次加入的复杂度，而是考虑一个点会被合并几次，其实只会从下到上 $\log n$ 次就行了。

而在查询的时候只会有 $\log n $ 个 AC 自动寄，所以复杂度为 $\mathcal{O}(m\log n)$。

