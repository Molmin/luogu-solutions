$\text{update 2022.9.8}$：经 @wuxikui 指正，更改了复杂度。

看到位运算先按位考虑，因为每一位相互独立。

对于两个数 $x,y$，我们计算 $x+y$ 是否在二进制下对第 $k$ 位有贡献，实际上是考虑 $x+y$ 在模 $2^{k+1}$ 意义下对第 $k$ 位是否有贡献，因为第 $k$ 位之后的那些位我们是不用考虑的。


那么对于在模 $2^{k+1}$ 意义下 $x+y$ 的和 $z$，我们分情况进行讨论。

对于 $x+y$ 不进位的情况。如果 $z\in [2^k,2^{k+1}-1]$，那么说明第 $k$ 位是 `1`，因为 $z$ 的最高位不可能为 $0$。

对于 $x+y$ 进位的情况，最多也只可能进一位，也就是说需要满足 $z$ 的第 $k$ 位，和第 $\left(k+1\right)$ 位都为 `1`。

$z$ 最大为 `11111...`，这个东西可以表示成 $2^{k+2}-1$，最小为 `11000...`，这个可以理解成 $2^k$ 左移了一位，然后又加上了 $2^k$，即 $2^k\times 2+2^k$。

所以得到 $z\in [2^k+2^{k+1},2^{k+2}-1]$。

根据异或的性质，第 $k$ 位只有有奇数对儿 $(x,y)$ 使得它们的和 $z$ 在模 $2^{k+1}$ 意义下恰好是在上述任意一区间内，那么第 $k$ 位才有贡献。

如何算这个对数就很简单了，我们把每个数在模 $2^{k+1}$ 下的结果排一个序，双指针维护即可。

复杂度 $\Theta\left(n\log V\log n\right)$。

细节问题代码中都有注释：

```cpp
inline bool solve(int k)
{
	rep(i,1,n) b[i]=a[i]%(1<<(k+1));
	int l1=1<<k,r1=(1<<(k+1))-1;
	int l2=(1<<k)+(1<<(k+1)),r2=(1<<(k+2))-1;//合法的两个区间 
	sort(b+1,b+1+n);
	int j1(1),j2(1);
	ll sum=0;
	rev(i,n,1)
	{
		while(j1<=n&&b[i]+b[j1]<l1) ++j1;//一直找直到找到 b[i]+b[j1]>=l1 
		while(j2<=n&&b[i]+b[j2]<=r1) ++j2;//一直找直到找到 b[i]+b[j2]>r1
		//合法的区间为 [l1,r1-1] 
		sum+=j2-j1;
		if(j1<=i&&i<j2) --sum;//i 自己不能和自己匹配。 
	}
	j1=1,j2=1;
	rev(i,n,1)
	{
		while(j1<=n&&b[i]+b[j1]<l2) ++j1;
		while(j2<=n&&b[i]+b[j2]<=r2) ++j2;
		sum+=j2-j1;
		if(j1<=i&&i<j2) --sum; 
	}
	sum>>=1;
	return sum&1;
}

int main()
{
//	freopen("read2 .txt","r",stdin);
	n=read();
	rep(i,1,n) a[i]=read();
	int ans(0);
	rep(i,0,26) ans|=(solve(i)<<i);
	printf("%d\n",ans);
	return 0;
}
```