又是一个阳光明媚的早上

又是一道写着图的遍历标签的题目

这道题目题意是，有一个由n个结点构成的有m条边的图，我没需要在某几个点上放置河蟹，河蟹会占领该点上的所有边，相邻的河蟹之间会发生冲突，我们需要让河蟹占领整个图

既然是图的题，当然是要画图啦~\(≧▽≦)/~

下面是两个随便画的图

![乱画的图1](https://t1.picb.cc/uploads/2018/10/30/JbouSs.png)

![乱画的图2](https://t1.picb.cc/uploads/2018/10/30/Jbocy7.png)

经过观察我们可以发现，1图可以实现河蟹占领全图的目标而2图不行

那么我们如何实现这一目标呢，2图又为什么不行呢？？？

我们可以把a图分层

![图1分层](https://t1.picb.cc/uploads/2018/10/30/Jbomm6.png)

我们可以发现，图1的每一条边都是建立在不同的层上的，即不会出现同一层之间互相连接的边。我给这种图起一个名字叫做分层图(乱说的)。

而图2分层后存在同一层之间的边。

题目中说了，河蟹直接不能相邻，那么我们只要让河蟹占据奇数层或者偶数层的所有点，问题就解决了(^ω^)

那么我们如何给一个图分层呢？？？

并查集！！！

并查集这个算法代码复杂度很低，而且时间复杂度是很低的，如果你没学过这个算法也没有关系，在下面的代码我有详细说明。

并查集的作用是使某些点具有相同的祖宗结点，那么他们直接就属于一个集合，同样的思想可以用在这一道题上，我们可以让奇数层的点属于同一集合，再让偶数层的点属于同一集合，这就是我们解决这个问题的plan a和plan b。每个plan所需要的河蟹个数就是奇数或偶数层中点的个数的和了QWQ

代码如下

```cpp
//bzoi男小鸟
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
using namespace std;
int n,m,fa[44000];//fa函数记录各结点的父亲结点
//路径压缩后父亲结点和祖宗结点是一个意思哦(AωA)
bool bj[44000];
int find(int now)
{
	if(fa[now]==now) return now;//初始化时把每个点都设为根结点，他们的祖宗结点都是自己。 
	int fn=find(fa[now]);
	//并查集寻找祖先函数的路径压缩最好这样写，做带权并查集题目都是在回溯后更新权值的
	//如果要写权值更新语句就写在该注释的位置就好了(>^ω^<)
	return fa[now]=fn;
}
void unity(int a,int b)
{
	int r1=find(a),r2=find(b);//分别找到a和b的祖宗结点
	fa[r1]=r2;//要将以r1结点为祖宗的所有结点的祖宗结点设为r2，只需要把r1的祖宗结点设为r2就好了
	//在下一次find后路径压缩会把并查集恢复父亲就是祖宗的状态 
}
int main()
{
	//一下plan a，plan b分别指在所有奇数层点上放河蟹以及在所有偶数点上放河蟹 
	scanf("%d%d",&n,&m);
	for(int i=1; i<=n*2; i++) fa[i]=i;
	//为什么要给(1,2*n)的结点都初始化呢，因为我们要对结点进行黑白染色处理
	//在该数组中与i异色的点我们用i+n存储，接下来会有详细说明
	int x[110000],y[110000],ass1=0,ass2=0;
	//x1为plan a中的一点，ass1存储plan a所需河蟹数
	//y1为plan b中的一点，ass2存储plan b所需河蟹数 
	for(int i=1; i<=m; i++)
	{
		cin>>x[i]>>y[i];//a、b间有一条边，那么选择了a就不能选择b了
		int r1=find(x[i]),r2=find(y[i]); //分别找到x和y的祖先
		if(r1==r2)
		{
			cout<<"Impossible";//如果两个点同属于一层却存在一条边
			exit(0);//那么他们各点上的河蟹一定会发生冲突 
		}
		else
		{
			unity(x[i]+n,y[i]);//x的不同层的点和y同层 
			unity(x[i],y[i]+n);//y的不同层数点和x同层
		}
	}
	//分别找到两个方案的祖宗结点
	/*
	o o
	| |
	o o-o
	可能会出现如上图的情况，图的本身可能由很多个分层图构成，那么将要求的就是每一个 分层图中的最佳解决方案 
	*/
	memset(bj,true,sizeof(bj)); //用于记录以i为根节点的图是否放置过河蟹 
	int ass=0;
	for(int i=1; i<=m; i++)
	{
		int r1=find(x[i]),r2=find(y[i]);
		if(bj[r1] && bj[r2]) //该边所在的分层图没有计算过最佳解决方案 
		{
			bj[r1]=false;
			bj[r2]=false;//标记该分层图进行过运算 
			ass1=0;
			ass2=0;
			for(int i=1; i<=n; i++)//求出该边所在的分层图中最佳解决方案 
			{
				if(find(i)==r1) ass1++;//该点属于plan a 
				else
				if(find(i)==r2) ass2++;//该店属于plan b 
			}
			ass+=min(ass1,ass2);//存储答案 
		}	
	}
	cout<<ass;
	//完结撒花，感谢陪伴ヽ(°▽°)ノ 
}
```