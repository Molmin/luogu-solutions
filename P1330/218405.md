### 这是一道萌新练习dfs的不二习题
 这道题可以抽象成用dfs求无向图的连通块的同时进行染色，逻辑能力的要求~~对萌新来说较高~~


------------
OI题目通常都很~~繁琐~~，合理合法地抽象题意是一个重要的能力。
题目中提到河蟹封锁了相邻的两个点就不好使，所以我们可以把有河蟹的顶点抽象成一种颜色，无河蟹的顶点抽象成另一种颜色。

题目大意：**在一个无向图中有序地遍历，保证每两个连通的顶点颜色不同，输出两种颜色中染色次数较少的那个；如果遍历的过程中任何一处出现矛盾（即相邻的两个点被染成一种颜色），遍历停止，输出Impossible。
------------**

PS：这里为萌新们普及一下“染色”：
~~首先肯定不是拿着刷子刷啦~~
染色是处理一些有关图的问题的常用方法，一种颜色可以代表一种状态，而颜色可以用1，2，3这样的数字来表示，也可以使用true，false这样的布尔型变量表示，等等。最终目的只有一个：把图上的顶点分类处理，从而达到解决问题的效果。

------------
下面就是代码实现的过程啦
首先当然是把图存进来，存图的方法有多种，最萌新的方法是开一个二维数组G[i][j],表示顶点i、j之前是否有连通，不过这种方法空间复杂度非常高，很多空间是浪费掉的，因此数据一大起来就可能MLE，所以，这里我们选择另一种更主流的存图方法：不定长数组
```cpp
vector <int> G[N];
```
G[i]用来表示点i，**G[i][j]表示点i与点G[i][j]之间是否有道路连接，需要注意的是，这里的j的值并没有实际意义，j只是起到用来表示数组长度的作用。**
下面是存图的代码：
```cpp
for(int i=1;i<=m;++i)
{
	int a,b;
	scanf("%d%d",&a,&b);
	G[a].push_back(b);
	G[b].push_back(a);
}
```
到这里还不可以遍历，因为我们还要预处理一些事儿
我们需要开一个数组V[n+1],V[i]表示点是否被染色及染成了什么色，我们约定-1为未染色，0和1分别为两种颜色。现在，没有点被染色，所以需要初始化数组V
```cpp
memset(V,-1,sizeof(V));
```
我们还需要开一个数组color[2]，表示0色和1色分别染了多少次。

下面，我们就可以愉快地dfs啦
首先，我们以循环的方式枚举图上每个点，当枚举到点i时进行判定，如果点i已染色，那么就continue；如果点i未被染色，那就随便染个色（为叙述方便，我们染成0色），这意味着我们要开始以点i为根去搜索了，我们需要把color数组清零（清零的具体原因后续介绍）
```cpp
for(int i=1;i<=n;++i)
	{
		if(V[i]!=-1)
		{
			continue;
		}
		V[i]=0;
		color[1]=color[0]=0;
		dfs(i);
		ans+=min(color[0],color[1]); //这行的作用后面说
	}
```
下面就是dfs函数，dfs(x)表示对点x进行搜索，首先，我们需要获得点x被染成了什么色，同时其对应的color数组变量++，接下来，我们需要依次枚举所有与点x连通的点G[x][k]，如果点G[x][k]已被染色，就continue；否则， 就染成与点x不同的色，再搜索这个点
……
一直下去，直到无路可走回溯
```cpp
void dfs(int x)
{
	if(!V[x]) ++color[0];
	if(V[x]) ++color[1];
	for(int k=0;k<G[x].size();++k)
	{
		int v=G[x][k];
		if(V[v]!=-1)
		{
			if(V[v]==V[x])     //这里需要注意，此处表示点v和点x均已被染色，并且由于前面的某处操作，使得这两个连通的点被染成了同一种颜色，出现了矛盾，所以直接中断程序的运行即可。
			{
				printf("Impossible\n");
				exit(0);
			}
			continue;
		}
		V[v]=!V[x];
		dfs(v);
	}
}
```
到这里，我们已经遍历完成了一个连通块，我们需要汇总答案，为下一次遍历做准备。我们注意到，此时已经完成了一个连通连通块，下次遍历一定不会和本次出现同一个点，也就是说，下次遍历与本次没有半毛钱关系。因此，我们只需找出两种颜色中染色次数较少的那个颜色作为这次遍历的最终答案即可。
```cpp
ans+=min(color[0],color[1]); 
```
最后，我们只需把ans的值输出就AC啦！

#### 下面是完整代码
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=10000+10;
int n,m;
int V[N];
vector <int> G[N];
int color[2];
int ans;
void dfs(int x)
{
	if(!V[x]) ++color[0];
	if(V[x]) ++color[1];
	for(int k=0;k<G[x].size();++k)
	{
		int v=G[x][k];
		if(V[v]!=-1)
		{
			if(V[v]==V[x])
			{
				printf("Impossible\n");
				exit(0);
			}
			continue;
		}
		V[v]=!V[x];
		dfs(v);
	}
}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=m;++i)
	{
		int a,b;
		scanf("%d%d",&a,&b);
		G[a].push_back(b);
		G[b].push_back(a);
	}
	memset(V,-1,sizeof(V));
	for(int i=1;i<=n;++i)
	{
		if(V[i]!=-1)
		{
			continue;
		}
		V[i]=0;
		color[1]=color[0]=0;
		dfs(i);
		ans+=min(color[0],color[1]); 
	}
	printf("%d\n",ans);
	return 0;
}
```
完结，撒花！！！