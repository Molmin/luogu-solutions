原置顶的那个题解已经说的很详尽了。这里我想对那个题解中部分代码进行一下说明:
Q1: 为什么dfs结尾处没有回溯操作？ (used[u]=false)
A1: 这道题不用回溯。只有在那些需要求出所有可能路径的题目中才需要回溯操作。为什么呢？其实回溯操作类似于一个“遗忘操作”;使得在寻找第二条路径时可以找到这个相同的结点。而这道题并不需要求出所以可能路径。不明白的同学可以拿起纸和笔模拟一下:从根结点开始，依次往下，颜色分别为黑、白、黑……直到最后一个结点。可见这个过程只是把图中所有的结点都走一遍，dfs return的时候也是如此，只是为了把所有的结点都走一遍，并不是要求出所有可能路径。因此并不需要回溯。
Q2: 如果不需要求出所有路径，那怎么保证答案一定是最小的那个呢？
A2: 其实如果拿起纸和笔模拟一下你会发现其实这个过程求出的答案是唯一的，也一定是最小的。不过注意一点，有一行很重要:ans+=min(sum[white],sum[black]). 这句话说明了应该加的是黑和白中更小答案的那个。至于为什么很好理解:你应该在染黑色的结点们和染白色的结点们中更小的放河蟹，因为两种方法都满足题目要求。
Q3: 为什么main中还需要再把所有结点都dfs一遍？
A3: 因为图不一定是全联通的。至于会不会超时/重复计算，你不需要担心。此前说明过了，不需要回溯操作;因此main中再dfs时会检查该结点是否被访问过了，如果访问过了就直接跳过，即if(used[i]) continue;.