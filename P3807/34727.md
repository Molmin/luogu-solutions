在ac这道题之前，首先让我们一起来看两个定理


----------------------------写题解专用的分割线(●'◡'●)ﾉ♥  ------------------------


##卢卡斯定理##


A、B是非负整数，p是质数。AB写成p进制：A=a[n]a[n-1]...a[0]，B=b[n]b[n-1]...b[0]。则组合数C(A,B)与C(a[n],b[n])\*C(a[n-1],b[n-1])\*...\*C(a[0],b[0])  modp同余。即：

**Lucas(n,m,p)=c(n%p,m%p)\*Lucas(n/p,m/p,p)**

简言之，Lucas定理是用来求 c(n,m) mod p，p为素数的值。


至于证明：以求解n! % p为例，把n分成每一个p一段，每一段求的结果是一样的。不过我们需要单独处理每一段的末尾p, 2p, ...，然后把p提取出来，就会发现剩下的数正好又是(n / p)!，有没有觉得很熟悉？没错！这相当于划归成了一个子问题，于是我们就可以用递归求解啦！而C(n,m)就是n!/(m!\*(n-m)!)，每一个阶乘都套用Lucas定理，就可以解出来了。注意这儿的p是素数是有必要的。\_(┐「ε:)\_

【以上部分文献参考自于小悟空——《Lucas定理与大组合数的取模的求法总结》，个人觉得是所有讲卢卡斯算法中比较详细的了 (´・ω・)ﾉ】


##逆元##


**如果ax≡1 (mod p),且gcd(a,p)=1（a与p互质），则称a关于模p的乘法逆元为x**

其实在实际中最常见的一个逆元的例子就是a和1/a，而这道题就是利用了这种思想。为什么嘞，你看啊，我们要求1/(n!\*m!)，而1/n!与n!就是互为逆元啊！~~是不是很神奇！~~


因为本题的目的不在于逆元，所以这里就不作深究了 (。-`ω´-)。我们来讲讲怎么求逆元，求逆元可以用扩欧，辗转相除emmmmm，这里我来讲一个线性求逆元。（其实本蒟蒻不清楚这几种是不是本质上是一种算法  \_(:3 」∠)\_ ，讲这个线性求法是因为~~我只会这一种啊~~这个简单易懂易上手啊）。

方程为 **a[i]=(p-p/i)\*a[p%i]**

【因为这边打不出一些符号。。。具体证明过程大家可以参考下面这个博客——lethalboy的《线性求逆元算法》】

[Luogu](http://blog.csdn.net/qq\_34564984/article/details/52292502)

然后剩下的大家就看代码吧(´・ω・)ﾉ


----------------------------贴代码专用的分割线(●'◡'●)ﾉ♥  ------------------------

```cpp
#include<iostream>
#include<algorithm>
#include<cstdio>
#define ed 100005
using namespace std;
int k,n,m,p;
long long a[ed],b[ed];
long long lucas(int x,int y)
{
    if(x<y) return 0;
    else if(x<p) return b[x]*a[y]*a[x-y]%p;
    else return lucas(x/p,y/p)*lucas(x%p,y%p)%p;
}
int main()
{
    scanf("%d",&k);
    while(k)
    {
        scanf("%d%d%d",&n,&m,&p);
        a[0]=a[1]=b[0]=b[1]=1;
        for(int i=2;i<=n+m;i++) b[i]=b[i-1]*i%p;
        for(int i=2;i<=n+m;i++) a[i]=(p-p/i)*a[p%i]%p;
        for(int i=2;i<=n+m;i++) a[i]=a[i-1]*a[i]%p;
        printf("%lld\n",lucas(n+m,m));
        k--;
    }
    
    return 0;
}
```