非常简单的一道题，只需要观察性质即可。     
题意大概是给定一个 $2 \times 2$ 的矩阵，一次 $(i,j)$ 上的操作可以清除其所在行和所在列上的草，求最大所需操作次数。      
显然，一次操作最多清除 $3$ 个格子上的草。可以分情况讨论：  
        
### 共 0 个格子上有草   
此时显然输出 $0$ 即可。     
      
### 共 1 个格子上有草     
对于唯一有草的格子，只需在当前格子操作一次即可。输出 $1$ 即可。       
        
### 共 2 个格子上有草        
这两个格子有两种排布方式：同行/列或呈对角线。      
```txt
同行/列：
1 1  
0 0 
呈对角线：
1 0
0 1
```
对于前者来说，只需在有草的任意一个格子上操作一次即可。     
对于后者来说，只需在空白的任意一个格子上操作一次即可，另两个 $1$ 必与其同行/列，会被清除。     

### 共 3 个格子上有草     
此时只有一个格子上没有草：     
```txt
1 1
1 0
```
显然，对于有草的格子来说，必有两格子呈对角线，剩下一个与空白的那个格子呈对角线，显然在后者这个格子上操作一次即可。      

### 所有格子上都有草    
此时显然输出 $2$，因为一次操作必定不能清除所有的草。     
     
综上，设一共读入了 $cnt$ 个格子上有草，则 $ans=\begin{cases}0 \ (cnt=0) \\ 1 \ (cnt=1,2,3)\\2 \ (cnt=4) \end{cases}$    
       
下面是 AC 代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int t;
int main(){
    cin>>t;
    while(t--){
        int rd,cnt=0;
        for(int i=1;i<=4;i++){
            cin>>rd;
            cnt+=rd;//读入的数只有1与0两种情况，所以读入的数可以直接加到计数器里
        }
        if(cnt==0)cout<<0<<'\n';
        else if(cnt==4)cout<<2<<'\n';
        else cout<<1<<'\n';
    }
return 0;}
```