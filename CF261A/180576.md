### 题目大意：
商店进行促销活动，
有 $m$ 种促销方式，
其中第 $i$ 种方式是
买满 $q_i$ 种商品后可以任意选择 $0$~$2$ 种商品作为赠品
~~（话说除非超市被抢空了，谁会傻到选1种或不选）~~ ，
但是要求选择的所有物品种价格最大的商品的价格
都不能大于购买的这 $q_i$ 种商品中价格最小的商品的价格。
每种促销可以无限次数地参加，
给你 $n$ 个商品的价格，
问买这 $n$ 个商品最少需要花多少钱。

花絮：做题时直接从CF复制题目到Google Translate翻译，
结果翻译出来 $1 \leq n \leq 105$ ，
窝就觉得不对劲，
结果 RE 之后发现（别找提交记录了，在CF上交的）， 
正确的范围是 $1 \leq n \leq 10^5$ ……

友情提示：别太相信翻译，能看懂的尽量自己看吧……

### 方法：贪心
既然每种优惠可以无数次参与，
并且奖励方式相同
那当然选要求最低的参加啦！
这样赠品的数量就可以得到最大值了。
于是可以发现，这道题得数据中有许多的
~~坑~~ 无用条件。

既然赠品有价格的要求，
而要使节约的钱最多，
赠品的价格当然越大越好。

既然所有东西都得买，
那从最贵得开始卖就会更划算，
因为买的贵，送的东西也贵啊！
都得买，肯定得让赠品得价值最大化。

按照以上买法，
一定可以用最少的前，
买到最大价值的东西。

### 代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define min(a,b) (((a)<(b))?(a):(b))//手写min函数提速（好像并没啥用） 
int m,n,minq=0x7fffffff,tmp,a[100001];
int main()
{
	scanf("%d",&m);
	for(register int i=1;i<=m;++i)
	{
		scanf("%d",&tmp);//无用条件就不用存储了 
		minq=min(minq,tmp); //留下最小值作为有用条件 
	}
	scanf("%d",&n);
	for(register int i=1;i<=n;++i)
	{
		scanf("%d",a+i);
	}
	sort(a+1,a+n+1);//把商品价格从小到大排序 
	int nowa=n,nownum=0,ans=0;//从尾到头遍历，就是从大到小遍历 
	while(nowa>0)
	{
		ans+=a[nowa];//统计答案 
		++nownum;//统计当前未参与促销的商品数量 
		--nowa; 
		if(nownum==minq)//满足条件，立即享受优惠 
		{
			nownum=0;//清空数量 
			nowa-=2;//将这两个商品视为赠品 
		}
	}//特别注意，if不能放在while前面，因为在去除赠品后，nowa有可能为负数。 
	printf("%d\n",ans);
	return 0;
}
```
