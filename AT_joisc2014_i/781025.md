偏序问题，很自然想到 cdq 分治。  
先按 $y$ 排序，将点分为两部分，再按 $x$ 进行排序。  
如图将其分为上下两部分。  
![](https://cdn.luogu.com.cn/upload/image_hosting/szmilm2x.png?x-oss-process=image/resize,m_lfit,h_170,w_225)  
跟一般的偏序问题一样，我们按 $x$ 大小从左往右扫。考虑上面做右上角，下面做左下角。下半部分对上半部分的贡献。  
首先，我们暂且不考虑上半部分带来的影响，只看下半部分的。  
那么下半部分能产生贡献的点一定是按 $x$ 单调递增 $y$ 单调递减的。    

如图：  
![](https://cdn.luogu.com.cn/upload/image_hosting/zqpbhud1.png?x-oss-process=image/resize,m_lfit,h_170,w_225)  
若扫到红色点，则计算后面的贡献时几个绿色点就不能算上了，因为若黄点与绿点配对则比包含红点。所以 $y$ 大于红点 $y$ 的点及图示绿点都需排除。我们可以用单调栈来实现。记为 $st_1$。  
  
考虑到这一步还没完，可能会有上半部分的点阻碍。  
如图中加了个蓝点（我是不会承认是因为一开始画图没注意才不得不后来加的）：  

![](https://cdn.luogu.com.cn/upload/image_hosting/jft1djf8.png?x-oss-process=image/resize,m_lfit,h_170,w_225)  
很明显，原本红点跟黄点是可以配对的，但现在蓝点在他们之间。所以不能贡献了。  
怎么办呢？我们可以在统计答案时删去 $st_1$ 中不合法的点。那么这些不合法的点都是存在一个点 $k$ 使得 $x_j < x_k < x_i$ 且 $y_k < y_i$。  
感性理解一下就是 $x_j$ 小于上面所有满足 $y_k < y_i$ 中最大的 $x_k$。  
我们同样地可以用单调栈来维护满足条件的 $x_k$。  
同时，注意到 $st_1$ 中的点是按 $x$ 递增的，于是我们直接在单调栈内二分查找最后一个小于 $x_k$ 的点即可。 