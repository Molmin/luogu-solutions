## 首先两个数都是要用字符串读入的，不然就要写复杂的高精度（大雾）...

### 总共有两种变换方式（搬题）：

1. 在字符串 $ a $ 中选择一个位置 $ p $ ，将 $ a[p] $ 位置上的数从 $ 0 $ 变成 $ 1 $ 或者从 $ 1 $ 变成 $ 0 $ 。

2. 在字符串 $ a $ 中选择两个位置 $ p,q $ ，将 $ a[p] $ 和 $ a[q] $ 互换，代价为 $ | $ $ p-q $ $ | $ 。

都用第一种方法改变字符串 $ a $ ，那么代价稳定为字符串 $ a $ 和字符串 $ b $ 不一样的数量。

### 但如果使用第二种方法，我们就会发现它其实有优劣性之分：

1. 如果这两个数的位置相邻，那样交换的代价为 $ 1 $ ，比使用第一种方法处理这两个字符要节省 $ 1 $ 步，所以在这时第一种方法就会被舍去。

2. 如果这两个数的位置间隔一位，那样代价为 $ 2 $ ，也就是说这样是和第一种方法处理这两个字符代价一样，就不做任何事情。

3. 如果这两个数的位置相隔两个及以上，那样代价大于 $ 2 $ ，也就是说这时使用第二种方法处理这两个字符比第一种方法更劣，肯定会被舍去。

所以我们只要找一遍两个字符串中不同的位数个数，记录到答案变量 $ ans $ 中。

再一个循环，每次找到一个相邻出现的需要更改的字符就 $ sum $ 减一。

但要注意，可能每次答案减一都要把 $ a $ 中相邻字符的后一个变成相应的 $ b $ 中的字符，防止重复计算，导致答案偏小。

最后得到的 $ sum $ 就是正确的答案。

**（我的表达能力不怎么好，如果一时哪些地方有问题，欢迎在旁边讨论提出）**

### 下面贴上我的AC代码：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
string a,b;
signed main(){
	int n;cin>>n;
	cin>>a>>b;
  //以字符串形式读入
	int len=a.length(),ans=0;
  //记录字符串长度和答案初始化
	if (a[0]!=b[0]) ans++;
	for (int i=1;i<len;i++) if (a[i]!=b[i]) ans++;
   //首先先全部当做做第一种方法来变换
	for (int i=1;i<len;i++)
	 if (a[i]!=b[i] && a[i-1]!=b[i-1] && a[i]==b[i-1]) ans--,a[i]=b[i];
  //如果相邻数位出现都需要变换的情况，就把变换方法换为第二种方法，答案减一。
  //a[i]的值改为b[i]，防止重复减去。
	printf("%lld\n",ans);
  //输出最后的答案
	return 0;
  //完美结束整个程序
}
```

[我的AC记录](https://www.luogu.org/recordnew/show/18116068)
