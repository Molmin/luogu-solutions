## 序
为方便，此篇题解**所有编号从 $0$ 开始。二进制位是从右往左数的。** 所有 $log_2(n)$ 都是向上取整。

前置基础:请确保学完了基础语言(if,for,二维数组)，建议先学习分治(这样更看得懂一些)。最好学过基本位运算(可以不学，但实现起来会麻烦一些)。

这道题非常有趣 ~~(毒瘤)~~，其实没有什么算法难度，但确实思维难度高。考虑**简化**题目。从简单情况入手，从暴力开始，逐步推出正解。

附基础位运算:

查询 $a$ 的第 $b$ 个二进制位的值:```(a>>b)&1```。

将 $a$ 的第 $b$ 二进制位修改为 $c$ ($a$ 初始第 $b$ 位为 $0$): ```a|=(c<<b);```
## 简化题目:立即得到结果，无变异鼠

假设可以询问一次就立刻得到答案。并且没有变异鼠。

这就可以利用分治解决。**先把这 $n$ 瓶水均分成两部分。并且让一只老鼠喝掉其中的一部分。如果这个老鼠中毒了，那么就说明这一部分有毒，否则说明另一部分有毒。**

注:为避免出现一段区间大小为奇数。先将 $n$ 变为**最小**但**大于等于** $n$ 的 $2^{k} (k为整数)$。

确定了有毒的一部分后，另一部分就可以丢开了。这样问题的规模就缩小了一半。

举个例子。现在有 $13$ 瓶水，编号为 $0～15$。

先将其均分成两截，分别为 $[0,7]$ 与 $[8,15]$ 。

让一只老鼠把 $[0,7]$ 都喝一遍，假设它中毒了，那么毒水一定在 $[0,7]$ ，否则在 $[8,15]$。

假设没中毒，那么再将 $[8,15]$ 分成两截 $[8,11]$ 与 $[12,15]$。再让一只老鼠喝 $[8,11]$。每次范围都可以缩小一半，所以可以在 $log_2(n)上取整$ 的询问次数内求出毒水。

## 简化题目:无变异鼠
这一部分感觉自己讲得不好，可以结合其它题解或自己画图理解。

现在不能立刻得到实验结果。那么应该怎么办呢?

假设还是区间 $[0,15]$，分成了 $[0,7]$ 和 $[8,15]$。

由于不知道毒水在哪一边，所以每一部分是毒水的情况都得试一次。即让一只老鼠既喝下 $[0,3]$，又喝下 $[8,11]$。假设毒水经判断在 $[0,8]$，那么 $[8,11]$ 部分对结果不会产生影响。那么可以相当于这只老鼠只喝了 $[0,3]$ 这部分。也就是与之前一样地判断了。然后再让一只老鼠喝 $0,1,4,5,8,9,12,13$。最后让一只老鼠喝 $0,2,4,6,8,10,12,14$。

换一个理解方式，就是**不断确定第 $i$ 位的二进制。首先枚举每一位，喝下满足 编号 在该位 二进制位 $0$ 的所有水。若中毒则毒水在此位二进制为 $0$。否则毒水在此位二进制为 $1$。** 这样实现起来会比之前的递归会方便很多。

该部分的核心代码是:
```cpp
int main(){
	for(i=0;i<logn;i++){ //从右往左数第i位。
		sum=0;
		for(j=0;j<n;j++){ //第j瓶水。
			if(!((j>>i)&1)){ //算出要询问多少只老鼠。(j>>i)&1表示查询j从右往左数第i个二进制位的值。
				sum++;
			}
		}
		cout<<"1 "<<sum<<" ";
		for(j=0;j<n;j++){
			if(!((j>>i)&1)){
				cout<<j+1<<" "; //注意要加一，因为题目从1开始编号。
			}
		}
		cout<<endl;
	}
	for(i=0;i<m;i++){
		scanf("%d",live+i);
	}
	for(i=0;i<logn;i++){ 
		ans|=(live[i]<<i); //第i此询问的是毒水编号的第i位。
	}
	cout<<ans+1;
}
```
## 暴力 $(2log_2(n)+1)$ 次询问 ($21$ 次)
现在有变异鼠了，又怎么对付?由于只有1只变异鼠，所以简单的办法是**重复**实验~~避免偶然性~~。即每个二进制位用 $2$ 只老鼠来检验。

那么最多要重复几次呢?只需要 $2$ 次就够了。因为只有 $1$ 只变异鼠，不可能 $2$ 次询问的结果都错了。但是如果 $2$ 次查询的结果不一样，那么说明有一只老鼠是错的。于是就要额外 $1$ 只。

但是如果最后一次询问是变异鼠，那么最坏会把你卡到 $21$ 次询问。

## 正解 $(log_2(n)+log_2^2(n)+1)$ 次询问($15$ 次)

上一个算法每次询问都需要重新用一个来寻找。现在可以考虑继续分治。

也就是说，是不是可以考虑每次逐步按照之前的方法确定变异鼠编号所在的二进制位。

比如，假设用了 $4$ 只老鼠，先检测第 $0,2$ 只是否有变异鼠。再检测 $0,1$ 只是否有变异鼠。

但是有个问题，如何确定许多只老鼠里是否有变异鼠?

可以仿照之前的暴力算法，**让每瓶水都喝偶数次。**

称之前第一次询问的老鼠为询问鼠，现在用于检测的老鼠为检测鼠。

要检测许多只老鼠中是否有变异鼠，就新用一个检测鼠，再枚举每一瓶水，**若这瓶水被这些老鼠喝了奇数次，就让检测鼠喝下**。保证每瓶水都被喝偶数次。

这样有什么好处呢?每瓶水都出现了偶数次，那说明**如果其中不存在变异鼠，则这里面一定有偶数只老鼠死亡**，因为毒水会被偶数只老鼠喝下。而**如果存在变异鼠，那么一定有奇数只死亡**，因为只有一次询问的结果会因变异鼠错误。

但是还要考虑一个问题，检测鼠中也可能有变异鼠，所以还需要新开一只老鼠来检测所有检测鼠中是否有变异鼠。但是只需要一只，因为我们的目标不需要找出变异鼠。**若发现此次询问有奇数只老鼠死亡**，变异鼠在检测鼠或这只老鼠中，那么询问鼠全部正常，**直接用询问鼠的结果**。**若有偶数只死亡**，说明检测鼠全部正常。那么**直接用检测鼠的结果，反转找出变异的询问鼠的结果，再得出答案**。

## 代码
(初学者可能看不懂这份代码)

题解实现保证喝偶数次的操作可以用异或实现。中为异或方便用了bitset。这样会方便一些。
```cpp
#include<iostream>
#include<bitset>
using namespace std;
bitset<1025> zyl[25],zero=0,one=1,tkr,zxr;
int size[2017];
bool live[2017];
int main(){
	int n=1000,m,i,j,logn,log2n,cuo=0,ans=0,sum=0; //cuo:变异鼠。
	bool ykb=0; 
	cin>>n>>i;
	for(logn=1;(2<<logn)<n;logn++){}
	logn++;
	for(log2n=1;(2<<log2n)<logn;log2n++){}
	log2n++;
	m=logn+log2n+1;
	for(i=0;i<logn;i++){ //询问鼠
		sum=0;
		for(j=0;j<n;j++){
			if(!((j>>i)&1)){
				sum++;
			}
		}
		cout<<"1 "<<sum<<" ";
		for(j=0;j<n;j++){
			if(!((j>>i)&1)){
				cout<<j+1<<" ";
				zyl[i]|=(one<<j); //记录下喝了哪些水。
			}
		}
		cout<<endl;
	}
	for(i=0;i<log2n;i++){ //检测鼠。
		tkr=0;
		for(j=0;j<logn;j++){
			if(!((j>>i)&1)){
				tkr^=zyl[j]; //异或可以保证奇数为1,偶数为0。就可以知道哪些水喝了奇数次。
			}
		}
		sum=0;
		cout<<"1 "<<tkr.count()<<" ";
		for(j=0;j<n;j++){
			if((tkr&(one<<j))!=zero){
				cout<<j+1<<" ";
				zyl[logn+i]|=(one<<j);
			}
		}
		cout<<endl;
		zxr^=tkr;
	}
	cout<<"1 "<<zxr.count()<<" "; //检测 检测鼠 的老鼠
	sum=0;
	for(j=0;j<n;j++){
		if((zxr&(one<<j))!=zero){
			cout<<j+1<<" ";
		}
	}
	cout<<endl<<"2"<<endl;
	for(i=0;i<m;i++){
		scanf("%d",live+i);
	}
	for(i=logn;i<m;i++){
		ykb^=!live[i];
	}
	if(!(ykb&1)){ //如果变异鼠不存在于检测鼠中。
		for(i=0;i<log2n;i++){
			ykb=!live[i+logn]; //如果这只老鼠死了，那么ykb初始就为1。因为当前检测鼠也要算进去。
			for(j=0;j<logn;j++){
				if(!((j>>i)&1)){
					ykb^=!live[j];
				}
			}
			if(!(ykb&1)){ //如果没检测出来，说明这个二进制位是1。检测出来了不需要操作，因为初始值就是0。
				cuo|=(1<<i);
			}
		}
		live[cuo]=!live[cuo]; //反转错误的答案。
	}
	for(i=0;i<logn;i++){ 
		ans|=(live[i]<<i);
	}
	cout<<ans+1;
	return 0;
}
```
然后就可以得到 $99$ 分了。

原来是需要特判 $n=1$ 的情况。因为 $n=1$ 时按这种方法需要 $1$ 次询问。

特判相信大家都会，所以就不给代码了。

这题是一道非常好的题。这次比赛整体质量也特别高。