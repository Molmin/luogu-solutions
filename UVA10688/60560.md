题意我简单讲一下：

有n个苹果，第i个苹果的重量为k+i。其中只有第i个苹果是甜的，如果一个苹果是苦的，那他的重量就比甜的要小；如果一个苹果是酸的，那么它的重量就比甜的大。巨人想要找到甜苹果，需要通过吃掉某个苹果然后再判断甜苹果的位置，吃苹果的时候必须全部吃掉（~~不浪费习惯真好~~）。问在找到甜苹果的过程中的所有情况吃掉苹果重量的最小值（就是甜苹果是1至n的所有情况）。


------------

举一个例子 n=4,k=0. 

巨人先吃第2个。

如果第2个是甜的，那么甜苹果是2；

如果第2个酸，那么甜苹果是1；

如果第2个苦，再吃第3个就可以判断甜苹果是哪个。

这样，

如果1苹果是甜的，他要吃的重量为2；

如果2苹果是甜的，他要吃的重量为2；

如果3苹果是甜的，他要吃的重量为2+3=5；

如果4苹果是甜的，他要吃的重量为2+3=5；

总重量即为14。


------------


思路 区间DP 

如果没学过区间dp

我推荐一篇别的大佬写的教程

其实这[一篇](https://blog.csdn.net/qq_40772692/article/details/80183248)可海星

$dp[i][j]$代表巨人在i到j区间找出最甜苹果所需吃掉的最少重量

那我们就可以~~轻松~~得出转移方程：

$dp[i][j] = min(dp[i][j],dp[i][t-1] + dp[t+1][j] + (t+k)*(j-i+1))$

方程什么意思呢？

如果甜苹果出现在i到j的区间内，情况就会有有$(j-i+1)$种，如果先吃t苹果，那么t苹果的重量要出现在的所有情况中，所以要加上$(t+k)*(j-i+1)$。如果t是苦的，甜苹果在t+1到j内，故加 $dp[t+1][j]$ ；反之，如果t是酸的，同理，要加$dp[i][t-1]$

那闲话不多讲 直接开始贴上代码

还是一样的 ~~要抄~~得先理解qwq

```cpp
#include<bits/stdc++.h>
#define INF 2147483647
using namespace std;
const int maxn=510;
int n,w,t,cases=0;
int dp[maxn][maxn];//dp意义同上述
int main(){
    scanf("%d",&t);//t组询问
    while(t--){
        memset(dp,0,sizeof(dp)),cases++;//cases表示 询问第几次
        scanf("%d%d",&n,&w);// w是k的意思 为了变量名不重复
        //标准区间dp
        for(int i=n;i>=1;i--)
            for(int j=i;j<=n;j++){
                dp[i][j]=INF;
                if(i==j){dp[i][j]=0;continue;}
                for(int k=i;k<=j;k++) dp[i][j]=min(dp[i][j],(j-i+1)*(w+k)+dp[i][k-1]+dp[k+1][j]);
            }
        //输出答案 注意格式
        printf("Case %d: %d\n",cases,dp[1][n]);
    }
    return 0;
}
```