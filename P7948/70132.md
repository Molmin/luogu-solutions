# 前方之风
## 题意  
给出一个序列 $\{a_n\}$，和 $q$ 个 $k_i$。  
你需要对于每个 $k_i$，在这 $n$ 个数中重复以下步骤：  
- 求出剩下的数的平均数 $\textit{avg}$。  
- 将剩下的数中 $<\textit{avg}-k_i$ 的数删去。  
- 重复以上两个步骤直到所有数都不会被删去。  

对于每个 $k_i$，输出这样会剩下几个数。  
**注意：询问之间是独立的，也就是说，不会真的删去那些数。**  


## 题解  

如果对于某个 $k$，经过若干次操作后剩下的 $a$ 序列无法再用上述规则删数，我们称其为“**稳定**”。


### 假算  
我会二分！ 

毛估估一下，好像可以二分删去了几个数，然后 chk 可不可行。 

**hack：**  
```plain
1
5 1
20 0 0 0 0
5
```

实际上最开始 $5$ 个数就是稳定的了，但是如果你二分到了前 $3$ 个数，它是不稳定的，然后你会认为答案 $<3$，最终输出 $1$，实际上答案是 $5$。

### 算法一  
我会模拟！  

直接按照题意模拟，每次扫一遍求和，扫一遍标记一下哪些数被删掉了。  

时间复杂度 $O(qn^2)$。  

期望得分：20。  

思考：怎样构造数据让开除学生的轮数为 $O(n)$ 级别？

### 算法二  
我会排序和后缀和！  

注意到小的数一定比大的数更早删掉。  

从小到大排序，这样每次删掉的数一定是一个前缀！  

然后用后缀和可以快速求出剩下的数的和，从而快速计算 $\mathit(avg)$，然后移动一个指针表示这个位置及以后的数没有被删掉。  

时间复杂度 $O(qn)$。  

期望得分：50。  

### 算法三  
我会离线和观察性质！ 

假设我们已经把 $\{a_n\}$ 从小到大排序了。  

我们定义 $A_p$ 为序列 $a_p,a_{p+1},\cdots ,a_n$。

**性质 1：如果对于某个 $k$，如果 $A_{x}$ 不稳定，并且通过一次删除之后变成了 $A_{y}$，那么 $\forall p \in[x,y)$，$A_p$ 都不稳定。**  

> 证明：
> 考虑 $a_p<\operatorname{avg}(A_x)-k$，考虑到 $\operatorname{avg}(A_p)\ge \operatorname{avg}(A_x)$，那么必然有 $a_p< \operatorname{avg}(A_p)-k$


**性质 2：答案随 $k$ 的增加而单调不降**。  

> 证明：
> 考虑一个 $k_2 > k_1$，并且 $\{a_n\}$ 已经排好序。  
> 假设位置 $x$ 是最小的位置使得对于 $k_1$，$A_{x}$ 稳定。  
> 考虑对于 $k_2$ 我们目前处理到 $y<x$，并且将要删数。  
> 显然有 $\operatorname{avg}(A_x)>\operatorname{avg}(A_y)$。  
> 由于 $k_2>k_1$，有 $\operatorname{avg}(A_y)-k_2 < \operatorname{avg}(A_x)-k_1 \le a_x$，因此绝对不可能删到 $x$。
> 于是就证明了这个结论。


有了性质 1，我们就可以把删数的过程想象成一个一个删去，然后 check 行不行，直到稳定为止。   

加上这个性质 2，我们可以对 $k$ 排序然后双指针维护，判断行不行。  

复杂度 $O(q \log q + n\log n)$，瓶颈在排序。 

期望得分：100。 

实际上也可以预处理出可以使答案改变的那些 $k$，然后再在线二分，但是和离线差别不大且不必要。

