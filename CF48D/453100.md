# 思考历程
我曾经听人说过做题一定要仔细分析理解样例，然后我看了样例之后更懵了，就想着边写边想吧，于是就写了一个结构体，又写了一个  $ \ sort \ $ 排序，这显然不对啊，原来数组的顺序都没了，我便陷入了沉思。这个故事告诉我们要先想好了再去写题。

经过一番沉思之后，我想到了一种办法，既然正着思考怎样可以成立很难，为什么不去反着思考怎样不成立呢？（正难则反思想）

这样一想，很显然可以发现较大的数字受较小的数字的限制，而最小的便是1，如果较大的数字的数量超过较小的数字的数量，显然是不成立的；如果是成立的，那么序列数即是1的数量。

那么如何确定每个数字属于第几个排列呢？制定一个计数器，每个数字从第一组开始，进入之后这个数字所在的组数应加1。

补充：我又想排序又想保留原来的顺序，那就桶排啊！
# AC代码
```c
#include<bits/stdc++.h>
using namespace std;
int n,a[100001],num[100001],maxn,zu[100001];//a数组存数，num数组存每个数出现的次数，zu存每个数字出现的组数 
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>a[i];
		num[a[i]]++;//桶排 
		maxn=max(maxn,a[i]);
	}
	for(int i=2;i<=maxn;i++)
	{
		if(num[i]>num[i-1])
		{
			cout<<"-1";
			return 0;
		}
	}
	cout<<num[1]<<endl;
	for(int i=1;i<=n;i++)
	{
		zu[a[i]]++;//更新新的组 
		cout<<zu[a[i]]<<" ";
	}
	return 0;
}
```
完结撒花!