### 前言

因为是抱着必死的心态去做的这场比赛，所以看第一题的描述这么麻烦，就直接跳了。

吃饭的时候，突（jing）然（ren）发（ti）现（xing）最多只会切三刀，所以应该只是一道分类讨论题。然后我跑回机房，花了5分钟切掉了蛋糕。

***

### 正文部分

* 为什么最多只需要切三刀？

给一个人切**最多只需要两刀**。那么给三个人切就要 $ 2 \times 3 = 6 $ 刀。而在这六刀里，有三刀是**必定**可以重合的。

其中，给第二个人切的时候，两刀中的第一刀可以**和第一个人共用**。而第三个人其实根本不需要切，因为前两个人拿走他们需要的蛋糕后，剩下的就是第三个人的。

随机的大多数情况下，都是三刀。但数据是人出的，所以我们需要考虑什么时候可以将两刀合为一刀。

* 什么时候可以（需要）合二为一？

对于第一个人：

如果他正好吃了一半，那么两刀之间的夹角就等于 $ 180 \degree $ ，两刀重合，刀数 $ + 1 $ 。

如果他吃了整个蛋糕或者什么都没吃，那就直接不用切了，刀数 $ + 0 $。

如果前两种情况都没出现，那就切两刀，刀数 $ + 2 $

***

对于第二个人：

我们先假设目前的情况是这样的：

![](https://cdn.luogu.com.cn/upload/image_hosting/5p64t1fd.png)

假设第一个人拿了 $ A $ 。如果第二个人要拿的和 $ B , C , D $ 中的任何一块一样，那他就不需要再切，刀数 $ + 0 $ ；否则需要切，刀数 $ + 1 $。

假设第一个人拿了 $ A , B , C $ 三块蛋糕。如果第二个人要拿的和 $ D $ 一样，那就不需要再切，刀数 $ + 0 $；否则需要切，刀数 $ + 1 $。

简单来讲，如果第二个人和第一个人吃的加起来正好是一半，那就不需要再切；否则需要切。

然后考虑这种情况

![](https://cdn.luogu.com.cn/upload/image_hosting/4ly8vifo.png)

第一个人拿了 $ A $ 。如果第二个人要拿的和 $ B $ 一样，不需要再切，刀数 $ + 0 $ ；否则需要切，刀数 $ + 1 $ 。

***

第三个人不需要考虑，直接跳过。

***

### 代码部分

我清楚你们都看不懂我上面讲的内容，所以，直接上代码吧（

```cpp
#include<bits/stdc++.h>
int main() {
	int T,a[3];
	scanf("%d",&T);
	while(T--) {
		scanf("%d%d%d",a,a+1,a+2),std::sort(a,a+3);
		printf("%d\n",(a[0]==0?(a[1]==0?0:(a[1]==a[2]?1:2)):(a[0]+a[1]==a[2]||a[0]==a[1]||a[1]==a[2]?2:3)));
	}
}
```

说不定有人看不懂计算答案的那一句呢？

```cpp
sort(a,a+3); //先排序一遍，方便后面判断
if(a[0]==0) {
	if(a[1]==0) {
		ans=0; //一个人吃了整个蛋糕
	} else {
		if(a[1]==a[2]) ans=1; //第二个人拿了"B"
		else ans=2; //第二个人再切了一刀
	}
} else {
	if(a[0]+a[1]==a[2]||a[0]==a[1]||a[1]==a[2]) ans=2; //第二个人拿了"B"
	else ans=3; //第二个人再切了一刀
}
printf("%d\n",ans);
```

这样总不会有人看不懂了吧？

什么你们说我写的和我讲的不一样？那我不管（光速闪