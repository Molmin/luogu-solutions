前言：AC之后看看楼下的思路真的自愧不如~~但是我比他少用两个for~~，本文的一些讲解用了python语法（python表示区间真的好方便啊），小补一下即可

另外，个别单行注释较长，博客阅读更佳。
## 题目分析

有字符串$s$，知道s'=s(去掉a)，$t=s+s'$（加号表示串接），现在知道$t$，让我们求$s$。

我们根据题目，得到如下**规律**：

1.**s'** 中不含字符a（由题目可知）

2.**t**的后面那截一定是没有a的（由1可知）

那我们看样例：
```cpp
ababacacbbcc
```
他的输出是
**ababacac**，这是怎么来的呢？

我们根据规律2，**假定t后半截不含a的就是s'**，从字符串末往前找，得到$s'=\text{cbbcc}$。

此刻，我们知道，t中除s'外的就是s，**可得到$s=\text{ababaca}$**，去掉其中的a后得到的$s'=\text{bbc}$（下文称这一个s'为s''）

“这跟我们假定的s'不太一样啊！”

发现了吗？

我们**所假定的s'比样例中的$s'=bbcc$多了一个c！！！而我们求出的s''恰好比真正的s'少了一个c！**

我们需要加上一个判断，**扫描到$s'==s''$时输出！！！**，**否则就输出 :( ！！！**

## 程序流程
上述流程总结得到：
$$ \text{输入t} $$
$$↓$$
$$ \text{从后往前扫描，直到s'==s''}$$
$$↓$$
$$ \text{输出}$$
为了方便处理，我们需要统计有几个a之类的，所以完整流程如下
$$ \text{输入t} $$
$$↓$$
$$ \text{求出一个不含a的t（方便比较）} $$
$$↓$$
$$ \text{统计有几个a（方便算区间进行比较，可和上面的同时执行）}$$
$$↓$$
$$ \text{从后往前扫描，直到s'==s''}$$
$$↓$$
$$ \text{输出}$$
## AC代码
```cpp
#include <bits/stdc++.h>

using namespace std;

int main()
{
	string s,st;//s是t，st是不含a的t
	cin>>s;
	int an=0;//a的数量
	//统计有几个a
	for(int i=0; i<s.size(); i++) {
		if(s[i]=='a') an++;//统计有几个a
		else st+=s[i];//弄出一个没a的样本方便比较
	}
	//从后往前扫，扫到s'==s''，大家可以把下面的size实现存起来，这样运行会更快
	for(int i=s.size(); i>0; i--) {
		if(s[i]=='a') break;//如果扫到a了肯定不成立（s'中不含a）
		if(i-an==s.size()-i) {//先判断长度是否一样，以免大量substr太慢
        /*
        下面的substr有点复杂，这里讲一下
        等号左边的是s''，我们当前处理到的元素从后往前数是第（len(s)-i）个，所以相应的s''按照python中的写法就是st[0：len(st)-(len(s)-i）]，即st中第0个到倒数第（len(s)-i）个字符构成的字符串，举例来说，若i=5（表示现在处理到倒数第五个），s.size()=10（总长10），st="hahahaha"（总长8），那么s''就是st[0:8-(10-5)]=st[0:3]="hah"（即st中i之前字串，有点绕，自己模拟几遍就会了）
        等号右边的则好理解地多，i至末尾就是s'，譬如上面hahahaha的例子中s'是t[-5:10]
        */
			if(st.substr(0,(st.size()-s.size()+i))==s.substr(i,s.size())) {
            //长度一样且s'==s''
				cout<<s.substr(0,i);//输出，除s'（t[i,len(t)]）外的就是s（t[0,i]）
				return 0;
			} else break;//一定不成立
		}
	}
	cout<<":(";
	return 0;
}
```
~~后记：范例好良心啊~~