这道题确实和合并果子很像，

都是每次把最小的两堆（个）东西进行加（求平均值）操作，

直到只剩下一堆（个）东西为止，

因为没有第二堆（个）东西和它进行操作了。

```plain
Q:那一共要进行多少次操作呢？
A:一共 (n - 1) 次操作。
Q:为什么？
A:因为每一次都会有 2 个数被操作成 1 个数，减少了 1 个数，所以一共要操作 (n - 1)/ 1 次，也就是 (n - 1) 次操作。
```

但是这两题有一个区别：

+ 合并果子数据范围： $1 ≤ n ≤ 10000$ ;

+ 本题数据范围： $2 ≤ n ≤ 50$ ;

合并果子可以使用小根堆，这道题肯定也可以。

合并果子的数据范围很大，暴力过不了；

可是这题的数据范围很小，暴力可以过！（great!）

时间复杂度：

+ 小根堆时间复杂度： $O(n\log(n))$ ；

+ 暴力时间复杂度： $O(n^2\log(n))$ ；

小根堆的代码已经有人发了，我就直接发暴力的了。

代码如下：

```cpp
#include <bits/stdc++.h>
using namespace std;
double a[51]; // 因为在求平均值时可能出现小数，所以要用double类型
int main(){
	int n;
	scanf("%d", &n); // 输入
	for(int i = 1;i <= n;i++){
		scanf("%lf", &a[i]);
	}
	for(int i = 1;i < n;i++){ // 总共会有 (n - 1) 次操作
		sort(a + i, a + n + 1); // 排序
		a[i + 1] = (a[i] + a[i + 1])/ 2.0; // 每次操作：取出数列里最小的两个数进行平均
	}
	printf("%lf\n", a[n]);
	return 0;
}
```

最终测试结果详情如下：

```plain
编程语言：c++11 | 代码长度：311B | 用时：31ms | 内存：3.72MB
```

用时情况也没有那么慢……