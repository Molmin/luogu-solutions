这里提供一个部分分做法。

假设 $a_i=0$，我们进行费用流建图，这是一个二分图，源点和左部点之间的连边带有费用，左部点和右部点的连边均为 $+\infty$ 没有费用，右部点和汇点之间的连边没有费用。直接跑费用流即可。

当 $a_i\not=0$，费用变成了一个二次函数。但是好在这还是凸的，启发我们模仿费用流算法。观察一下性质：

1. 一条增广路的费用完全由源点到左部点之间连的这条边确定。
2. 一个左部点失去作用（当源点到它的边流满或者它流向汇点的所有路都被堵死了）后，它永远都失去作用了，不可能恢复。

所以我们从所有还未失去作用的左部点中，选择一个 $\frac {d\ cost}{d\ flow}$ 最小的进行增广（也就是选择 $2a_i\cdot x_i+b_i)$ 最小的）。

但是注意到一些问题：导数随着流的增加而增加，很可能流着流着它就不是最优的了；或者有可能存在多个最优的，我们不知道选哪个去流。

分类讨论一下：

1. 当前导数最小的左部点中存在 $a_i=0$ 的：直接试图将其流满，然后删掉它。
2. 否则，让这些左部点同时流一个流量 $x$，其中 $x$ 是一个合理的步长。

但是这个第 2 类情况非常的难缠，因为它要满足流了这个流量后这些点的导数不超过其它左部点的导数的最小值，且要满足这个流量是能流的，且它们之间具体每个流多少很难知道……所以我们需要一个能够比较好的降低问题复杂性的方法。

类似 NOI 骑行川藏的做法，我们二分导数，表示最优左部点流了一个流量后它们的导数为 $mid$，`check` 时就判断这个导数是否超过了其它左部点的导数，以及是否存在一个合法的流的方案，直接在残量网络上跑 `dinic` 即可。

由于输出分数的问题，我们改在 `Stern Brocot Tree` 上二分，由于其经典性质，所以可以做到 $O(\log^2(U)$ 的二分，总的复杂度便是 $O(\log^2(U)\cdot nm\cdot n)$（因为凸壳大小是 $O(n)$ 的）。

过不去是因为中间表示膨胀的问题，开 `__int128` 都撑不住，估计写高精也没用（）