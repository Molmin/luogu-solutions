# P8356 Solution
滚动数组与动态规划入门题

首先看到如果 $x=y$，那么如果符合条件（满足任意 $i\in[1,n]$ 都**不**满足 $p | xi$），直接输出 $1$（显然，有且仅有一种方案）

显然根据题意，每一个 $a_i$ 都可以表示成若干个 $x$ 与若干个 $y$ 的和。不妨让 $a_i=xk_1+yk_2$，$k_1,k_2$ 是 $x$ 和 $y$ 的个数，那么显然地，$i=k_1+k_2$

所以推得 $a_{k_1+k_2}=xk_1+yk_2$，都有这个递推式了，去想动态规划。由于它问的是方案数，所以不妨设计状态为：$f_{i+j}=xi+yj$ 的方案数。那么状态转移方程即：$f_{i,j}=f_{i-1,j}+f_{i,j-1}$，代码过程注意取模。注意到题目中的任意一个数都不整除 $p$，所以对于不符合要求的 $f_{i,j}$ （即 $xi+yj\equiv0 \mod p$）需要赋值成 $0$。

**动态规划一定要注意边界条件：特别且显然地，$f_{0,0}=0$**

数据范围 $10^4$，时空复杂度都是 $O(n^2)$，符合时间复杂度，但是空间就爆了。**解决方案：滚动数组**，小小的科普一下滚动数组：**核心思想就是把没用的内存给滚掉**，在本题的状态转移中，显然，内存中只需要保留前一组。比如你的状态转移代码原来是这样的：
```cpp
f[i][j]=f[i-1][j]+f[i][j-1];
```
而显然 $f_{a,b}(a\le i-2,b\le i-2)$ 的内存就是没用的了，不妨全部按奇数和偶数来保存（利用位运算（按位与） ```i&1``` 表示奇偶，若这个值等于 $1$，它就是奇数，若这个值等于 $0$，它就是偶数），代码就变成这样了：
```cpp
f[i&1][j]=f[(i-1)&1][j]+f[i&1][j-1];
```
这样数组的大小就变成了：```f[2][10005]```

代码实现注意一下取模即可。