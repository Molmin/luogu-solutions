
这道题目挖水的方法类似于二分查找，只不过每一次查找都有不同的花费，所以很容易想到用 Dp 来解决。
我们可以设计一个二维的状态，用 $f_{i,j}$ 表示在 $i-j$ 这一段的前缀有水，在最坏情况下要查出位置所需最少时间有转移：
```cpp
f[i][j] = min(max(f[i][k – 1],f[k+1][j]) + t[k])  (i <= k <= j)
```

我们发现这个状态已经不好再优化了，考虑能否优化转移
我们发现状态是具有单调性的，在表达式
```cpp
f[i][j] = min(max(f[i][k-1],f[k+1][j]) + t[k])

```
我们发现 $f_{i,k-1}$ 递增，$f_{k+1,j}$ 递减，则我们只要找到一个 $mid$ 使得 $i \le k \le mid$ 时
 ```cpp
f[i][k – 1] <= f[k + 1][j]

f[i][j] = min(f[i][k – 1] + t[k],f[l + 1][j] + t[l]), (i <=l <= mid)
```
，$mid \le k \le j$ 二分得到 $mid$，然后用线段树维护快速求解即可


接着我们发现 $mid$ 在 $i,j$ 某一维固定时是单调的，考虑将两种转移分开，分别求两种转移的最小值第一种转移 $j$ 固定，我们发现 $i$ 逐渐减小时，$mid$ 逐渐减小，我们要求 $min(f_{k + 1,j} + t_{j})$ ，也就是说可行 $k$ 的右端点逐渐减小，只要在 $j$ 处维护单调队列，当 $i$ 减少时，在队首加入 $f_{i + 1,j} + t_i$ 这个元素，然后相应地在队尾去掉不合法元素。总复杂度：时间空间都是 $O(n^2)$。
