考察知识：map，动态规划

算法难度：XXX+ 实现难度：XXX

这道题**有些贪心并不是完美解法**，但是数据为随机生成的，所以得分概率非常大。

Hack数据：

4 2  
1 1  
2 3  
3 6  
4 8  
1 2 3 4

标程输出：22 贪心输出：21

---

分析：

首先，我们要解决操作2，如果暴力枚举时间复杂度为$O(n^2)$。

其实吧，我们直接用map优化就可以了，时间复杂度$O(nlogn)$：

```cpp
    for(int i=1;i<=n;i++) P[i]=max(P[i-1],p[i]);//求最大值
    for(int i=1;i<=n;i++){
    	mp[k[i]]+=p[i];//在这里求和
        P[i]=max(mp[x[i]],P[i]);
    }
```

在处理了伏地魔在$[1,n]$每一步可以获得的最大魔法能量之后（记为$P[i]$，记$\sum P_i$为SUM），我们就可以采取动态规划了：

定义$f(i,j)$：表示在$[1,i]$ 秒中在$i$秒使用了魔法，且有$j$ 个时间段使用了魔法，可以得到的最大能量值

边界：$f(i,1)=SUM-P[i]+P[i+1]$

状态转移：$f(i,j)=max\left \{ f(k,j-1)-P[i]+P[i+1] \right \}\,\,\,\, 0<k<i-1$

状态转移方程的实现还是要稍微处理一下，直接实现会超时：
```cpp
    for(int i=1;i<=n;i++)//处理边界
        f[i][1]=SUM-P[i]+P[i+1],
        ans=max(ans,f[i][1]);
    for(int j=2;j<=m;j++){
        for(int k=1;k<=n;k++) T[k]=max(T[k-1],f[k][j-1]);//预处理
        for(int i=2*j-1;i<=n;i++)
            f[i][j]=T[i-2]-P[i]+P[i+1],
            ans=max(ans,f[i][j]);
    }
```
好了，这道题我们就做出来了，理论时间复杂度：，但是时间效率不是很高，面对最大数据需要近900ms。

---

原文：[【洛谷】NOIP2018原创模拟赛DAY2题解](https://blog.csdn.net/Hi_KER/article/details/82820861 )