[传送门~](https://www.luogu.com.cn/problem/P3400)

# 题意
给定一个 $n * m$ 的矩阵，由 $ 0 1 $ 构成，代表该点是否可用，求出该矩阵的子矩阵数量。

## 分析
首先我们明确求子矩阵数量的策略，枚举点 $(i,j)$ 作为子矩阵的右下角，只需要求出当前点出发可以得到多少矩阵，最后加和即可得出答案。

## 算法实现
考虑如下的矩阵：

 0 0 1 1 0 0 1
 
 1 0 1 0 2 1 0
 
 0 1 0 2 0 0 1
 
 1 0 0 2 p 0 0
 
 对于点 $ p $ 显然只有标记为 $2$ 的点（假设大于$0$代表被破坏）对他能构成的子矩阵有影响，其余的不能走的点无法影响他，所以每次我们只需要记录这些点就可以了。
 
 对于这些点的记录，我们维护一个单调栈（不会的可以看注释，很好理解），记录每一列的最高点，这样扫到当前点就可以直接得到所以对他有影响的点。
 
 再考虑如何优化，我们记录一个 $sum$ 数组代表前面的点子矩阵个数，这样每次只需要加入当前新增的一个矩形，再加上 $sum$ 就能得到这个点的子矩阵个数，对于这个子矩阵，单调栈存储的是高度，也就是 $i$ ，再记录一个 $w$ 数组记录所在的列，通过 $w$ 得到宽，栈得到高，矩形就求出来了。
 
 
 ```cpp
#include<cstdio>
#include<algorithm>
#include<cstring>
using namespace std;
int n,m,a[3005][3005],f[3005],w[3005],sum[3005],top;//f是单调栈 
long long ans;//不开long long见祖宗 
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;++i)
		for(int j=1;j<=m;++j)
			scanf("%d",&a[i][j]);
	for(int i=1;i<=n;++i,top=0){//每一行都要清空栈重新维护 
		for(int j=1;j<=m;++j){
			if(!a[i][j])f[j] = i;//如果被破坏了，那么高度就是自己的高度 
			while(top && f[w[top]] < f[j])top--;//去除栈中比当前列高度高的，也就是得到“2”的那个点 
			w[++top] = j;/*记录列*/						//注意 i 小的反而高 
			sum[top] = sum[top-1] + (i-f[w[top]]) * (w[top] - w[top-1]);//该点子矩阵个数=前一个点子矩阵数 + 高 * 宽 ； 
			ans+=sum[top]; //累加答案 
		}
	}
	printf("%llu",ans);
}

```
管理大大求过 qwq