目前是洛咕rk1，830ms  

~~不会单调栈的人看这里！~~   

其实差不多就是把[我在P5300题解](https://www.luogu.org/blog/iwantac/solution-p5300)又复制一遍，加了个详细说明，求过qwq

---
考虑反色后的矩阵，只要一个子矩阵中有一个 $ 1 $ ，那么这个子矩阵就是无效的，要从总个数中扣掉。  


枚举每一个位置作为右下角，记 $ s_i $ 为到当前行为止，为 $ 1 $ 的数最后出现时的所在行。  

这个位置作为右下角的贡献就是以当前列作为右端点作后缀 $ Max $ ，再把后缀 $ Max $ 加起来的和。   

解释一下这一段，考虑这样一个东西：  

1 1 1 1  
0 1 0 1  
0 0 0 1  
0 0 a b  

那a这个位置作为右下角的可行左上角是被包在一个轮廓线里面的，大概长这样：  

1 1 1c 1    
0 1c 0  1  
cccc  
0 0 0 1  
0 0 a b  

b这个位置同理，大概长这样：  

1 1 1 1  
0 1 0 1  
0 0 0 1  
cccccc  
0 0 a b  

可以看出轮廓线内的面积是一个后缀最大值和。所以我们考虑维护的方式。

因为后缀 $ Max $ 是单调的，而且每次修改只有一种操作：把某个位置（此位为 $ 1 $）改成最大值（当前行号）。  

那么对于每个位置记 $ Pre_i $ ，表示在他之前最后一个比他大的，可以发现每个位置后缀最大值和可以用这个 $ Pre $ 求出。考虑一次修改的影响，我们只要扫一遍，记下最后一个改成最大值的位置，再和当前位的 $ Pre $ 取最大就可以了。  

时间效率 $ O(n^2) $  


```cpp
#include<cstdio>
#include<string>
const int N=3002;
int n,m,r[N],v[N],s[N];
long long c;
#define _(d) while(d(isdigit(c=getchar())))
int R(){
    int x;char c;_(!);x=c^48;
    _()x=(x<<3)+(x<<1)+(c^48);return x;
}
int main() {
    n=R(),m=R();
    for(int i=1;i<=n;i++)
        for(int j=1,w=0;j<=m;j++) {
			if(!R()) s[j]=i,r[w=j]=0;
            else if(w>r[j]) r[j]=w;
            v[j]=v[r[j]]+1ll*s[j]*(j-r[j]);
            c+=1ll*i*j-v[j];
        }
return printf("%lld\n",c),0;}
```
