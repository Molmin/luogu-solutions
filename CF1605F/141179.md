[CF1605F PalindORme](https://www.luogu.com.cn/problem/CF1605F)

一道 div2 赛时没人过的题，评分竟然只有 `2900`，小编也很惊讶，可是事实就是如此。

考虑已知一个序列如何判断他是好的：容易发现第一个和最后一个一定得相同，然后这些有 $1$ 的位数可以不管，然后需要再找到不管这些位数的情况下相同的两个数。实际上这个过程等价于每次找两个能匹配的放两边。

那么考虑一个坏的序列：那么的话必然是一直操作下去，直到剩下的数中没有相同的为止。如果有 $0$ 的话就再把这个 $0$ 加进去避免算重，这样就可以让一个坏的序列对应为一个长度为 $k$ 的好的序列。

考虑一个 dp，一个朴素的想法是 $dp_{i,j}$ 表示长度为 $i$ 的序列，每个数在 $[0,2^j)$ 之间的坏的序列的个数，但是这样子实际上是难以转移的，经过尝试之后，容易注意到，第二维可以设置成所有数的或的 $\text{popcount}$。那么转移的话，枚举这个坏的序列所对应的好的序列的长度和这个序列的或的 $\text{popcount}$，然后转移的方程为 $\displaystyle  dp_{i,j}=\sum_{w1,w2} (all_{w1,w2}-dp_{w1,w2})\times \dbinom{i}{w1} \times \dbinom{j}{w2} \times 2^{(i-w1)\times w2} \times f_{i-w1,j-w2}$，其中 $f(i,j)$ 表示 $i$ 个 $[1,2^j)$ 中的数，每个数最多出现一次，而且所有数的或为 $2^j-1$ 的方案数，$all_{i,j}$ 表示 $i$ 个 $[0,2^j)$ 的数组成的序列，所有的或为 $2^j-1$ 的方案数，这两个都可以容斥后预处理。时间复杂度 $\mathcal{O}(n^2k^2)$。[code](https://www.luogu.com.cn/record/63915933)。

