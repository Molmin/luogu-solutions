> 称一个长度为 $n$ 的序列 $a$ 是 $\text{PalindORme}$ 的，当且仅当对于任意 $1 \le i \le n$，满足 $a_1 | a_2 | \dots | a_i = a_n | a_{n-1} | \dots |a_{n-i+1}$，其中 `|` 表示按位或运算。
>
> 称一个长度为 $n$ 的序列 $b$ 是 $\text{good}$ 的，当且仅当它可以重排成一个 $\text{PalindORme}$ 的序列。
>
> 给你 $n,k,m$，求长度为 $n$，每个元素值域为 $[0,2^k)$ 的序列中有多少个是 $\text{good}$ 的，对 $m$ 取模。
>
> $n,k\le 80$

神仙题。

考虑如何判断一个序列是否好，可以采用以下方法：

> 找到序列中两个相等的数放在最左边、最右边，并删掉其它的数中这两个数有的位，重复操作直到序列长度 $\le 1$。

然而这个操作无法直接变成 dp，因为一种操作顺序对应了一个序列，而非一个可以重排的可重集。

下一步是类似 数联通无向图个数 的容斥了，对每个 bad 序列，他一定存在**唯一**一个**最长**的 good 子序列，满足以下条件：

> 除开这个 good 子序列有的位，剩下的数其它位都互不相同。

如果最长 good 子序列是长度偶数，那它就是满足条件的。否则，如果这个子序列里面放在中间那一个数是包含在两边的数的 or 和内的，它也是满足条件的。否则，中间的数引入了新的位数，会导致这个子序列不唯一，难以计数。

比较显然，但确实很震撼。

称满足条件的 good 序列为合法 good 序列。所以可以这样算**合法** good 序列的数量：设 $f(n,m)$ 表示长度为 $n$，恰好有 $m$ 个位的**合法** good 序列的数量，答案是 $\sum \binom mi f(n,i)$。
$$
f(n,m)=all(n,m)-
$$

$$
\sum_{i<n}\sum_{j<m} \binom ni\binom mj f(i,j)2^{j(n-i)}g(n-i,m-j)
$$
枚举这个最长合法 good 子序列的长度及包含位数，$2^{j(n-i)}$ 表示包含在这些位里面的随便选，$g(n-i,m-j)$ 表示在 $0\sim 2^{m-j}-1$ 中选 $n-i$ 个两两不同的数且包含了所有 $m-j$ 位的方案数。$all,g$ 都可以容斥算。

这个 dp 不能算到前面说的 good 但不合法的情况，需要在 $n-1\to n$ 的时候特殊算一下这种情况的贡献。若视 $n=k$，复杂度 $O(n^4)$。