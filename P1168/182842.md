#### 题目链接——[中位数](https://www.luogu.org/problemnew/show/P1168)
——对于这道题，我们可以在每次输入奇数个整数时用sort函数进行一次快排。然后输出中间的数。

——于是 代码如下
```
#include<bits/stdc++.h>
using namespace std;
int n,a[100001];
int main(){
	scanf("%d",&n);//输入n；
	for(int i=1;i<=n;i++){
		cin>>a[i];//输入非负整数Ai
		if(i==1)printf("%d\n",a[i]);//第1个数直接输出
		if(i!=1&&i%2==1){
			sort(a+1,a+i+1);快排
			printf("%d\n",a[(1+i)/2]);//输出中位数
		}
	}return 0;//结束
}
```

——~~这样这道题就完美的结束了~~。

——开个玩笑，这样写只能过40%的数据。而对于100%的数据，我们肯定是要进行优化的。

——而对于这道题我们可以用**对顶堆**来实现。

——**对顶堆，顾名思义，就是建立一个大根堆和一个小根堆**。

——形象的解释![坟头对撞](https://i.loli.net/2019/06/25/5d11f067496d176042.jpg)

——这道题主要做法就是先来一个**大根堆**和一个**小根堆**，而对于一个序列，我们把**大数**放在**小根堆里**，**小数**放在**大根堆**里，并且维护一个状态：
```
当序列的长度为奇数时，
——保证小根堆的深度等于大根堆的深度加一。
当序列的长度为偶数时，
——保证小根堆的深度等于大根堆的深度。
```
——这样我们发现对于一个序列，小根堆里的是比其堆顶大的一部分数，大根堆里的是比小根堆的堆顶小的一部分数。
——我们很容易发现，当序列的长度为奇数时，小根堆的堆顶就是序列的中位数

——说完了思想，接下来是代码实现

——首先是**建堆**，这里我们可以用C++自带的STL库中的**poriority_queue**来实现，当然手打堆也是可以的不过我懒得打了。

——建堆
```
priority_queue<int> x;//小根堆
priority_queue<int> d;//大根堆
```
——值得注意的是，**priority_queue**只能维护一个大根堆，要实现小根堆，就需要再放入堆中时乘以个负一，将其变为负数，取出时再乘回来，这样就能
实现一个小根堆

——~~其实是因为我不会重载运算符之类的实现小根堆的方法，所以只能这样做~~

——接下来是代码实现

—— 首先，对于i为偶数时，由于i-1为奇数，所以对于长度为i-1的序列 **lx==ln+1**，因此我们需要将一个数放入大根堆内来保证此时 **lx==ln**

```
——若此时Ai比小根堆的堆顶要小，说明Ai比小根堆内所有元素都要小，这时我们便可以直接将Ai放入大根堆内：

——而如果Ai比小根堆的堆顶要大的话，我们要将小根堆的堆顶取出放入大根堆内，Ai放入小根堆内才能保证小根堆内所有元素都比大根堆内的所有元素大
```
——i为奇数时同理。

——下面才是代码实现

```
#include<bits/stdc++.h>//万能的头文件
using namespace std;
priority_queue<int> x;//小根堆
priority_queue<int> d;//大根堆
int p,k,m,a,z[10001];
int main(){
    scanf("%d",&m);
    for(int i=1;i<=m;i++){
            cin>>a;
            if(i==1){
            x.push(-1*a);//将第一个数放入小根堆
            cout<<-1*x.top()<<endl;//输出
            }
            if(i>1&&i%2==0)//如果i为偶数
            {
            int c=x.top();
                if(a<=-1*c)//Ai比小根堆堆顶小
                d.push(a);//直接插入大根堆
                else//Ai比小根堆堆顶大
                {
                x.pop();x.push(-1*a);d.push(-1*c);//小根堆堆顶放入大根堆，Ai放入小根堆
                }
            }if(i>1&&i%2==1)//如果i为奇数
            {
            int c=d.top();
                if(a>=c)//Ai比大根堆的堆顶大
                x.push(-1*a);//直接插入小根堆
                else//Ai比大根堆的堆顶小
                {
                d.pop();d.push(a);x.push(-1*c);//大根堆的堆顶放入小根堆，Ai放入大根堆
                }
                printf("%d\n",-1*x.top());//i为奇数时输出中位数
            }
    }
    return 0;//结束
}
```