# CF1626E Solution

## 题意:
给你一棵树（不是无根树，这题翻译有问题），每一个节点要不然是黑色的，要不然是白色的，且黑色的节点至少有两个。先要求你选择**每一个**节点（无论黑白），每次可以向任意一个黑色节点移动一条边（但不能连续两次向同一个黑色移动），问最终能否走到一个黑点（任意一个都可）。注意：当步数超过 $10^{500}$ 的时候，视为无法走到一个黑点。

## 解析:

首先明确一点，~~通过感性分析和实际验证我们发现~~走不到就是走不到，如果走得到早就在 $10^{500}$ 步以前走到了（实际上最坏情况是一条链，最多需要在不冤枉的情况下走 $n-1$ 次就可以），所以我们只需要判断能都走到就行了（感性分析过程：计算无法在给定时间内模拟出这么多次移动，且 $n$ 的最大值 $3 \times 10^5$ 的数量级远小于 $10^{500}$）。

接着我们来模拟一下样例，发现如果一颗子树里只含有一个黑点，那我们永远无法达到这棵子树更深的地方以到达黑点（因为向这个唯一的黑点移动了一条边以后无法再次向这个黑点移动），除非我们移动的下一步就是黑点。于是我们一遍Dfs求出以任意一个节点为根的子树里有多少个黑点（当然用黑点的总数减去它就得到了以这条边为分割线的另一颗树的黑点个数），如果个数不小于2，那么说明至少从这个节点的父亲节点走到这个节点**可能**可行，如果下一步就是黑点，那么**一定**可行。那么怎么进一步处理呢？

我们新建一个图，保留所有原先的节点，但一开始没有边。我们对可能可行和一定可行的走法连一条边（例如从 $u$ 节点走到 $v$ 节点可能可行，我们就从 $u$ 向 $v$ 连一条有向边），如果一个节点是可以走到一个黑色节点的，那么它通过几条可能可行的的边一定会走到一条一定可行的边（并且在原图上的路径就和新图的路径是一样的），反之，就算其一开始有可能可行的边，最后也无法走到一定可行的边。画两个个图大家就明白了：

![走得到](https://cdn.luogu.com.cn/upload/image_hosting/fr5otmi6.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

0号节点可以最终可以走到3号节点。

![走不到](https://cdn.luogu.com.cn/upload/image_hosting/lfangqo0.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

0号节点一开始有可能可行的边但最终走不到黑色节点。

于是最后判断从每一个节点出发能否达到一个黑色节点即可。

问题来了，这样的时间复杂度将会达到无法令人接收的 $n^2$ 级别（实际可能远远达不到，但出题人可以卡你）。考虑优化：对于每一条边，我们反向建边，然后从每一个黑色节点出发，看能到达的点有哪些。因为反向建边了，黑色节点能达到的点在不反向建边的情况下一定能够走到黑色节点。再利用一个标记桶（如果以前已经走到过就不再继续搜索了），这样判断可达性的时间复杂度就直接降次了。

最后来分析一下时间复杂度：输入的 $O(n)$，加上求每一棵子树里含有黑色节点的个数的Dfs的 $O(n)$ 和反向建边以及判断可达性的 $O(n)$，最终的渐进时间复杂度：$O(n)$。（这个的常数极大，那要不然为什 $3 \times 10^5$ 的数据跑了 $243ms$）

Code：（为了各位读者我格式化了一下毒瘤码风）
```cpp
#include<bits/stdc++.h>
#define Add1(x,y) e1[idx1]=y,ne1[idx1]=h1[x],h1[x]=idx1++;
#define Add2(x,y) e2[idx2]=y,ne2[idx2]=h2[x],h2[x]=idx2++;
using namespace std;
const long long N=3e5,M=N-1,C=1;
int n,m,t,x,y,s[N+5]/*存储所有黑色节点的编号以便后面判断可达性*/,top,bla[N+5]/*以每一个节点为根的子树里面的黑色节点数量*/,fat[N+5];
int h1[N+5],ne1[2*M+5],e1[2*M+5],idx1;//原始图
int h2[N+5],ne2[2*M+5],e2[2*M+5],idx2;//新建的反向建边的图
bool c[N+5]/*color,是1表示黑,否则是白*/,bjt[N+5]/*判断可达性的标记桶*/;
void Dfs1(const int &x,const int &fa) { //确定父子关系以及每一颗子树里面的黑色节点数量
	for(int i=h1[x]; ~i; i=ne1[i]) {
		int cur=e1[i];
		if(cur==fa) continue;
		Dfs1(cur,x);
		fat[cur]=x;
		bla[x]+=bla[cur];
	}
}
void Dfs2(const int &x) { //判断可达性
	for(int i=h2[x]; ~i; i=ne2[i]) {
		int cur=e2[i];
		if(bjt[cur]) continue;
		bjt[cur]=1;
		Dfs2(cur);
	}
}
int main() {
	scanf("%d",&n);
	fill(h1+1,h1+n+1,-1);
	fill(h2+1,h2+n+1,-1);
	m=n-1;
	for(int i=1; i<=n; i++) {
		scanf("%d",&t);
		if(t) {
			c[i]=1;
			bla[i]=1;
			s[++top]=i;
		} else c[i]=0;
	}
	for(int i=1; i<=m; i++) {
		scanf("%d%d",&x,&y);
		Add1(x,y);
		Add1(y,x);
	}
	Dfs1(1,0);
	for(int i=1; i<=n; i++)
		for(int j=h1[i]; ~j; j=ne1[j]) {
			int cur=e1[j];
			if(fat[i]==cur) continue;
			if(bla[cur]>1/*可能可行*/||c[cur]/*一定可行*/) Add2(cur,i);
			if(top-bla[cur]>1/*可能可行*/||c[i]/*一定可行*/) Add2(i,cur);
		}
	for(int i=1; i<=top; i++) {
		bjt[s[i]]=1;
		Dfs2(s[i]);
	}
	for(int i=1; i<=n; i++) {
		if(bjt[i]) printf("%d ",1);
		else printf("%d ",0);
	}
	return 0;
}
```
[AC记录](https://codeforces.com/contest/1626/submission/146055667)

注：个人认为此方法非常容易理解，思维难度其实也挺小的（可能就是时间复杂度劣了一点）。