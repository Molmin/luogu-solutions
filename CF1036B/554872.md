# 0.前言
~~擅长写分支结构的我又来了~~。
考试的时候犯迷糊了，后来静下心来还是AC了。
这题我看大佬用的其他方法，那本蒟蒻来发一篇分支结构的题解！

# 1.思路
首先用一个 $flag$ 记录是否输出过（输出过是 $1$，没输出是 $0$ ）

**无解情况：** 
然后就是一个 $n \times m$ 的坐标系，最少应该走 $\max(n,m)$ 步，下面我来证明一下：
当 $n>m$ 时：
‪![](https://t1.picb.cc/uploads/2021/08/19/wWwtpv.png)
其中路径为粗的蓝色的线，长边为 $n$ ，短边为 $m$。最少步数为 $n$ 步。同样道理，当 $m>n$ 时，最少步数为 $m$ 步。以无论怎样，最少步数一定是 $\max(n,m)$，作者觉得到这还是很好理解的。

言归正传，所以当给出的步数 $k$ 小于最小步数 $\max(n,m)$ 时，无解，输出 $-1$。（输出完后 $flag=1$）

**其余情况：** 
当 $\max(n,m)-\min(n,m)$ 为 $2$ 的倍数时，简单试一下就会发现最多可以斜着走 $k-1$ 步。再用上图来看就应该是，小长方形的宽的举例若为 $2$ 的倍数，就需要不走斜着的路，需要绕路走两步，故要减 $1$。

当 $\min(n,m)-k$ 为 $2$ 的倍数时，trytry就发现可以斜着走 $k-2$ 步，不为则走 $k$ 步。这也可以结合上图，找到大长方形的宽，和刚才解释一样，即绕路或不绕路。

AC代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
long long t,n,m,k;
int main(){
    scanf("%lld",&t);
    while(t--){
    	bool flag=0;
        scanf("%lld%lld%lld",&n,&m,&k);
        if(k<max(n,m)&&flag==0){
        	cout<<"-1\n";
        	flag=1;
        }
        if((max(n,m)-min(n,m))%2&&flag==0){
        	cout<<k-1<<"\n";
        	flag=1;
        }
        else if(flag==0){
            if((min(n,m)-k)%2) cout<<k-2<<"\n";
            else cout<<k<<"\n";
			flag=1;
        }
    }
}
```
