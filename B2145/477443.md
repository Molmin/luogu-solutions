在[博客](https://yjh965.github.io/post/digit-han-shu-ti-jie/)食用更佳。

# 思路
这个题目很简单，函数内只需要这样一串代码：`return n / int(pow(10, k - 1)) % 10;`

为什么呢？

我们先看看，`n / int(pow(10, k - 1))` 是什么意思。

在 c++ 中，如果除号的两边都是整数，则这个除号就是整除。否则，就是正常的除法。例如，`3 / 4`、`3 / 4.0`、`3.0 / 4`、`3.0 / 4.0` 的结果分别是 `0`、`0.75`、`0.75`、`0.75`。

`pow(a, b)` 是一个求 $a^b$ 的函数。

在代码中，`n` 和 `int(pow(10, k - 1))` 的类型都是 `int`，所以这是一个整除运算。

$pow(10,k-1)$ 的值绝对是 $10$，$100$，$1000$ 这样的数。

你们不妨可以试验多几次，结果会发现，**`n / int(pow(10, k - 1))` 就是把 `n` 的后 `k - 1` 位砍掉！**

结果，`n` 的末位变成了原来的第 `k` 位！

`%` 这个符号，就是取一个数除以另外一个数的余数。例如，`233 % 2`、`234 % 5`、`235 % 3` 的结果分别是 `1`，`4`，`1`。

你又会发现，**取这个数除以 $10$ 的余数，不就是取这个数的末位吗？**

而在第一个环节里，末位就已经变成了第 `k` 位！

于是，我们成功的用 $O(1)$ 的时间复杂度在 `int` 的基础上求出了 `n` 的第 `k` 位！
# 代码
```cpp
#include <iostream>
#include <cmath>

using namespace std;

int digit(int n, int k){ // 其实，大可以不用写函数。
    return n / int(pow(10, k - 1)) % 10;
}
int n, k;
int main(){
    cin >> n >> k;
    cout << digit(n, k);
}
```
