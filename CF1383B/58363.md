我们先不考虑博弈论经典的Sg函数~~（毒瘤）~~

我们观察，我们要让最终的异或和最大，

设A为先手最终取完的值，B为后手最终取完的值

比如分别是24和23，拆分成二进制来看看

11000（8）

10111（7）

显然前面会有一段A，B相同（可能没有），前面都一样

然后突然B没有了，A仍然有，因为无论后面如何，这一位已经决定了A比B大了

### 所以问题就是抢最高位！！

好了，我们开始分析了

### Case.1假如最高位为偶数
此时，显然不影响最后结果

因为我们可以把偶数分解成奇数+奇数或偶数+偶数

如果是奇数+奇数，两个都有，不影响

如果是偶数+偶数，两个没有，不影响

所以我们再考虑次高位。

### Case.2当前的最高位为奇数
此时，又有两种情况，

 Case.2.1如果为4n+1个的话，那么肯定是分解成奇数+偶数，然后第一个人要抢奇数个，然后你们只能轮流抢，然后先手显然会比后手抢的多，所以先手会为奇数（好好想一下）

 Case.2.2如果为4n+3个的话，那么要分成两堆，含最高位的和不含最高位的，我们要保证自己不抢到偶数个，那么我们会变成有奇数+奇数+1个，然后我们要不抢到最后一个，那么我们会从没有最高位的垃圾堆里选，然后谁没得从垃圾堆里选，谁就输了，所以垃圾堆有奇数个，先手赢，有偶数个，后手赢。

### Case.3全是偶数，没有最高位为奇数

显然平局

代码实现：
这里选择先异或好，然后如果异或完为0就是Draw，不然分别考虑，先只保留最高位的1，然后判断有哪些有这个最高位的1，然后如果是4n+1,先手必胜，否则判断剩下的是奇数或偶数
```
#include<bits/stdc++.h>

using namespace std;
int t;
int n;
long long a[100005];
long long sum,g;
int lowbit(int u){
	return u&(-u);
}
int main(){ 
	scanf("%d",&t);
	while(t--){
		scanf("%d",&n);
		sum=0;g=0;
		for(int i=1;i<=n;i++)
			scanf("%lld",&a[i]),sum=sum xor a[i];
		if(sum==0){
			puts("DRAW");
			continue;
		}
		while(sum-lowbit(sum)!=0)sum-=lowbit(sum);
		for(int i=1;i<=n;i++)
			if(a[i]&sum)g++;
		if(g%4==1){
			puts("WIN");
		}
		else{
			if(n%2==1)puts("LOSE");
			else puts("WIN");
		}
	}
	return 0;
}
```
