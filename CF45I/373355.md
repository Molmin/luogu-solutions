[题目传送门](https://www.luogu.com.cn/problem/CF45I)

这道题要非常细心才能做出来，注意特判 （这道题应该是普及 -               吧）
# 思路与特判条件：

既然要求已知数中的最大积且至少要有一个数，那么：
1. 遇到正数直接输出（因为它不会使最后的积变小，类似于贪心）
2. 遇到负数时统计数量并记录它的数值，最后从小到大排序（因为负负得正，越小的两个负数相乘的值会越大，如果有奇数个负数则只能输出奇数 $-1$ 个）
3. 遇到 $0$ 时统计个数，如果 $0$ 的个数刚好为 $n$ 或者为 $n-1$ 且其余的那一个数为负数，则输出 $0$（特判条件）
4. 只有一个数且那个数是负数时，输出那个数（因为不能不选）

知道了思路与特判条件，就来贴代码吧

# AC CODE：
```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	int n,x,cntb=0,cntc=0,b[105]={0};//n 为 题目的数量；x 为输入的数；cntb ，cntc 分别存储负数与 0 的个数 ，b[]数组存储负数的数值 
	cin>>n;//输入 
	for(int i=1;i<=n;i++){//循环输入 
		cin>>x;//输入 
		if(x>0){//如果它是正数 
			cout<<x<<" ";//直接输出 
		}
		else if(x<0){//如果它是负数 
			cntb++;//负数计数器 +1 
			b[cntb]=x;//记录当前值 
		}else{//如果它是 0 
			cntc++;//0 的计数器 +1 
		}
	}
	if(n==1&&cntb==1){//只有一个数且这个数是负数 
		cout<<b[1]<<endl;//输出这个数 
		return 0;//结束程序 
	}
	if(cntc==n-1&&cntb==1||cntc==n){//一个负数其余都是 0 或全部都是 0 的情况 
		cout<<0<<endl;//输出 0 
		return 0;//结束程序 
	}
	sort(b+1,b+cntb+1);//将负数排序（默认从小到大） 
	if(cntb%2==1)cntb--;//当只有奇数个负数，则只能选奇数 -1 个 
	for(int i=1;i<=cntb;i++)cout<<b[i]<<" ";//输出最小的 cntb 个 
	return 0;//结束程序 
}
```

