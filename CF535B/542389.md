看到各位大佬都是用广度优先搜索写的 ，我只能默默地用起了我的深度优先搜索 。       
这里简单说一下题目意思 ，题目告诉我们存在一种幸运数字 ，而这种幸运数字是在十进制下只包含 $4$ 或 $7$ 的数 ，要我们求出 $1-n$ 之间有多少个这样的幸运数字 。  
由于这里的深搜是搜索数位 ，而这里 $n$ 的范围是 $n\leq10^9$，所以用深度优先搜索不会超时 。  
这里的 dfs 函数只需要一个参数 $sum$，$sum$ 表示当前枚举的数 ，这个枚举的数呢一定是幸运数字 ，所以要在每次递归的时候计数器加一 。在计数器加一前 ，要判断 $sum$ 是否大于 $n$，如果大于 $n$ 就要返回上一层递归 。dfs 里面需要分两种情况去搜索 ，一种是下一位是 $4$，一种是下一位是 $7$ ，dfs 的参数就是 $sum*10+7$ 或 $sum*10+4$。  
什么 ？就这么简单 ？当然不是 。这里出了些小问题 。
1. 这个数据很大 ，得开 long long；
2. 这个计数器的初始值得为 $-1$，因为 dfs 的第一次递归中 ，参数是 $0$，而计数器却加了一 ，导致答案出错了 。  
好了好了 ，说了这么久 ，该放代码了 ，代码如下 。
```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,ans=-1;
void dfs(ll sum){
	if(sum>n)//边界
	return;
	ans++;
	dfs(sum*10+4);//两种情况
	dfs(sum*10+7);
}
int main(){
	cin>>n;
	dfs(0);
	cout<<ans;
	return 0;
}
```
感谢您的观看 ，谢谢 ！