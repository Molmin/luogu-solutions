[题目链接](https://www.luogu.com.cn/problem/P3126) [双倍经验](https://www.luogu.com.cn/problem/CF570E)

这题其实叫回文路径……

---

### **题意：**

有个人分别从左上往右下走，问有多少条路经是回文的。

---
### **分析**

这种题是多进程动规题。（[同类题](https://www.luogu.com.cn/paste/9zlg23m6)）

多进程动规，顾名思义，就是有多个同时进行的动规。

像这题，可以理解成有两个人同时从左上和右下开始，向中间集合，问有多少种走法，两人所经过的路径构成的字符串，有多少种走法是一样的。

---

### **动规分析：**

**1级算法**

数组： $f_{s,x1,y1,x2,y2}$ 表示走了s步，从左上和右上来的人的坐标分别为 $x1,y1$ 和 $x2,y2$ 。

转移方程： 
$$f_{s,x1,y1,x2,y2}=f_{s-1,x1-1,y1,x2+1,y2}+f_{s-1,x1,y1-1,x2,y2+1}+f_{s-1,x1-1,y1,x2,y2-1}+f_{s-1,x1,y1-1,x2+1,y2}$$

循环：枚举 $s,x1,x2,y1,y2$ 。

复杂度：时间 $O(n^5)$ ，空间 $O(n^5)$ ，明显时、空双爆。

---
**2级算法**

数组： $f_{s,x1,x2}$ 表示走了s步，从左上和右上来的人的行坐标分别为 $x1$ 和 $x2$ 。

转移方程： 
$$f_{s,x1,x2}=f_{s-1,x1-1,x2+1}+f_{s-1,x1-1,x2}+f_{s-1,x1,x2+1}+f_{s,x1,x2}$$

循环：枚举 $s,x1,x2$ 。

优化来源：可以根据 $s,x1,x2$ 推出 $y1$ 和 $y2$ 。

复杂度：时间 $O(n^3)$ ，空间 $O(n^3)$ ，时间勉强过，空间会爆。

---

**3级算法**

数组： $f_{x1,x2}$ 表示从左上和右上来的人的行坐标分别为 $x1$ 和 $x2$ 。

转移方程： 
$$f_{x1,x2}=f_{x1-1,x2+1}+f_{x1-1,x2}+f_{x1,x2+1}+f_{x1-1,x2+1}$$

循环：枚举 $s,x1$ （逆序） $,x2$ 。

优化来源：可以根据转移方程把 $s$ 这维压了。

复杂度：时间 $O(n^3)$ ，空间 $O(n^2)$ ，时、空双过。

---

**细节见代码↓**

```cpp
#include <bits/stdc++.h>
using namespace std;
const int mod=1e9+7;
char a[555][555];
int n,f[555][555],ans;
int main()
{
    cin>>n;
    for(int i=1;i<=n;i++)
    	for(int o=1;o<=n;o++)
    		cin>>a[i][o];//输入字符矩阵
    if(a[1][1]==a[n][n])//小优化，头尾不一样直接输出0
    {
        f[1][n]=1;//初始化，在起点时有1条方案
        for(int i=1;i<=n-1;i++)//枚举走了多少步
            for(int o=i+1;o>=1;o--)//左上角来的行坐标
                for(int u=n-i;u<=n;u++)//右下角来的行坐标
                    if (a[o][i+2-o]==a[u][n*2-i-u])//两边的字符一样
                        f[o][u]=(1ll*f[o][u]+f[o-1][u]+f[o][u+1]+f[o-1][u+1])%mod;//转移方程和定义见上文解释，1ll是防爆的，还有别忘了取模
                    else
                        f[o][u]=0;//不一样直接取0
        for(int i=1;i<=n;i++)//结束后要走在一起
            ans=(ans+f[i][i])%mod;
    }
    cout<<ans<<endl;
    return 0;
}
```
