标签：博弈论，猜结论。

毒瘤结论题。现在此题已经超越 CF1605F 成为我心目中最难的 div2F。

> 性质 1：如果树的直径 $\ge 3$，那么 Alice 必胜。

首先如果 $p$ 中存在三个位置满足 $p_x\ne x$，那么 Alice 必然可以选择两个将它们交换使得它们不包含标记所在的点。最后必然可以调整到最多只有两个 $p_x\ne x$ 的状态。记它们分别为 $x,y$，如果此时标记既不在 $x$ 上也不在 $y$ 上。那么显然 Alice 再进行一次操作即可胜利。此时不妨假设标记在 $x$ 上。考虑后面 Alice 怎么操作：

> 性质 1.1：如果此时 $x,y$ 不相邻，先把 $y$ 移到某个与 $x$ 相邻的点上

假设 $x$ 有个邻居叫 $z$，那么我们先换 $y,z$，此时 Bob 要么把标记移到 $z$，要么移到一个不同于 $z$ 的 $x$ 邻居，不管怎么样我们此时都交换 $x,y$，此时两个 $p_i\ne i$ 的点就相邻了。

> 性质 1.2：对于 $x,y$ 相邻的情况，Alice 可以任选 $x$ 一个邻居 $z$ 并将 $y$ 变到 $z$ 的位置，标记保持不变

我们交换 $y,z$，此时 $y,x,z$ 上的数分别是 $z,y,x$，此时 Bob 有两种选择，要么移到 $y$，要么移到 $z$。不管我们发现，如果移到 $y$，那么 Alice 交换 $x,z$，此时三个数 $y,x,z$ 上的数变成了 $z,x,y$，而 Bob 的标记在 $y$，再走一步不能阻挡 Alice 交换 $x,z$ 的举动，因此 Bob 只能将标记移到 $z$，此时 Alice 交换 $x,y$，Bob 将标记移回 $x$ 就形成了这个局面。

> 性质 1.3：对于 $x,y$ 相邻的情况，Alice 可以任选 $y$ 一个邻居 $z$ 并将两个 $p_i\ne i$ 的点移到 $y,z$，并且标记在 $z$ 上 

证明和 1.2 的证明差不多。

> 性质 1.4：Alice 可以通过进行性质 1.2 和 1.3 将 $x,y$ 移到直径的某个端点上

证明：显然。

> 性质 1.5：当 $x,y$ 移到直径的某个端点时，Alice 可以在 $O(1)$ 步内获胜

假设 $x$ 为直径的端点，$y$ 与 $x$ 相邻，那么分两种情况考虑：

- 如果标记在 $x$ 上，假设 $y$ 存在一个非叶节点的邻居 $z$（由于直径 $\ge 3$，一定可以找到），$z$ 的某个邻居 $w$，那么我们先通过 1.3 将标记移到 $z$ 上，使得两个 $p_i\ne i$ 的点为 $y,z$，再进行 1.2 将两个点变为 $w,z$，可以转化为标记在 $y$ 上的情况。
- 如果标记在 $y$ 上，那么我们先进行 1.2 将两个 $p_i\ne i$ 的点变为 $y,z$，此时标记在 $y$ 上，交换 $w,z$，此时 Bob 只能将标记移到 $z$，此时 $w,z,y,x$ 上的数分别是 $y,w,z,x$，我们再交换 $y,x$，此时 $w,z,y,x$ 上的数分别是 $y,w,x,z$，Alice 可以先交换 $x,z$，后交换 $w,y$，再交换 $x,y$ 取胜，并且 Bob 不论每一步移到哪个点，都不能在规定步数内到达待交换的两个点。这样 Alice 就赢了。

至此，我们成功证明了性质 $1$。

这样我们只用考虑菊花图的情况。设菊花的中心为 $R$

> 性质 2：如果 $p_R\ne R$，且标记一开始在 $R$ 上，那么 Bob 获胜。

证明大概就 Bob 每两个回合一个循环，在循环的第一个回合将标记移到 $R$ 所在位置，第二回合移回 $R$，这样第二回合末依然有 $p_R\ne R$，这样游戏就可以一直进行下去。

我们先特判掉 Alice 可以在 $\le 1$ 个回合之内赢的情况。先考虑一种特殊情况：初始状态下只有两个满足 $p_i\ne i$ 的点，这样只有六种本质不同的情况：

- $p_R=R$，标记位于 $R$
- $p_R=R$，$p_x=x$。
- $p_R=R$，$p_x\ne x$。
- $p_R\ne R$，标记位于 $R$
- $p_R\ne R$，$p_x=x$。
- $p_R\ne R$，$p_x\ne x$。

对于第四种情况，根据上面的讨论，答案为 Bob。

对于第二种情况和第五种情况，我们可以发现，除了初始局面之外，后续局面中不可能出现这样的局面。因为 Bob 不会这么傻，如果出现了这个局面，那么在上一个步中，Bob 必然会将标记移到某个 $p_x\ne x$ 的叶子更优。由于我们特判掉了一步获胜的情况，因此这两种情况我们仿照其他三种讨论即可。

那么剩余三种情况怎么处理呢？

> 性质 3.1：对于任意一个局面，其 $[x\text{是叶子节点}]+\sum\text{置换环大小}-1$ 是定值。

证明大概，每次 Alice 进行一次交换后 $\sum\text{置换环大小}-1$ 恰好改变 $1$，Bob 进行一次交换后 $[x\text{是叶子节点}]$ 也恰好改变 $1$，合着就是奇偶性不变。

> 性质 3.2：对于第一种情况，Alice 必胜当且仅当 $[x\text{是叶子节点}]+\sum\text{置换环大小}-1$ 为奇数

证明：手玩极端情况即可。可以证明对于任意一个 $[x\text{是叶子节点}]+\sum\text{置换环大小}-1$ 的情况都可以通过变换变成只有两个 $p_i\ne i$ 且标记在 $R$ 且 $p_R\ne R$ 的情况，证明留给读者自己思考。

这样第一种情况我们只检查 $[x\text{是叶子节点}]+\sum\text{置换环大小}-1$ 的奇偶性即可。对于第三种情况也是同理的。

对于第六种情况，我们首先肯定要使得 $p_R=R$，否则下一步 Bob 把标记移到 $R$ 后 Alice 就 GG 了。此时我们需要先交换 $R$ 和 $pos_R$，然后转化为第一种情况。如果一开始标记刚好在 $pos_R$ 就直接输出 Bob 即可。

至此我们解决了这道大毒瘤题。

```cpp
const int MAXN = 2e5;
int n, x, p[MAXN + 5], deg[MAXN + 5], vis[MAXN + 5];
void solve() {
	scanf("%d%d", &n, &x); for (int i = 1; i <= n; i++) deg[i] = 0;
	for (int i = 1, u, v; i < n; i++) scanf("%d%d", &u, &v), deg[u]++, deg[v]++;
	for (int i = 1; i <= n; i++) scanf("%d", &p[i]);
	int R = -1; for (int i = 1; i <= n; i++) if (deg[i] == n - 1) R = i;
	if (R == -1) puts("Alice");
	else {
		bool flg = 1;
		for (int i = 1; i <= n; i++) flg &= (p[i] == i);
		if (flg) return puts("Alice"), void();
		if (x == R && p[x] != x) puts("Bob");
		else {
			if (p[R] != R && x == p[R]) puts("Bob");
			else {
				int sum = 0;
				for (int i = 1; i <= n; i++) vis[i] = 0;
				for (int i = 1; i <= n; i++) if (!vis[i]) {
					int sz = 0;
					for (int j = i; !vis[j]; j = p[j]) vis[j] = 1, ++sz;
					sum += sz - 1;
				}
				if (sum == 1) {
					for (int i = 1; i <= n; i++) if (p[i] != i && i != x && p[i] != x)
						return puts("Alice"), void();
				}
				sum += (x != R);
				printf("%s\n", (sum & 1) ? "Alice" : "Bob");
			}
		}
	}
}
int main() {
#ifdef LOCAL
	freopen("in.txt", "r", stdin);
	freopen("out.txt", "w", stdout);
#endif
	int qu; scanf("%d", &qu);
	while (qu--) solve();
	return 0;
}
```