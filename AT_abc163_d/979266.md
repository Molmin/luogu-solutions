### 思路：

我们很容易发现一个规律：

样例来说，把 $10$ 的 $100$ 次方看成 $0$，那么就变成 $0,1,2,3$。

区间长度为 $2$ 的区间和的范围是：$0+1=1,2+3=5$，也就是 $[1,5]$。

区间长度为 $3$ 的区间和的范围是：$0+1+2=3,1+2+3=6$，也就是 $[3,6]$。

区间长度为 $4$ 的区间和的范围是：$[6,6]$。

所有范围内的数加起来就是 $10$ 个。

所以对于每一个区间长度，都求出来范围的下界和上界即可。

注意中间求和的过程中要用上界减去下界，此时要先减再 $p$（$p$ 为我们要取余的值）。

说下我自己容易出错的地方（大佬自动跳过）：

- 当题目要求结果 $\bmod$ 上一个数时，通常计算过程中要处处取模，否则会有隐患，但是如果计算中间出现了两个大数相减，比如算出来两个大数 $a,b(a<b)$。如果用 $b \bmod p - a \bmod p$，数据大一点就 ``WA`` 了。正确的应该先减，$(b-a+p) \bmod p$。

### 完整代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
const int mod=1e9+7;
typedef long long ll;
int main()
{
    ll n,k;
    cin >>n>>k;
    ll ans=0;
    while(k<=n)
    {
        ll res=(k*(n-k+1+n)/2-k*(k-1)/2+1+mod)%mod;
        ans=(ans+res)%mod;
        k++;
    }
    ans++;
    cout <<ans%mod<<endl;
}
```
