### 导入
根据题意可以想到一个非常暴力的方法：枚举当前能选多少个数 $i(k \le i \le n+1)$，在对于依次搜索出选了的数的和，把它记在 `unordered_map` 中，依次累加答案。

由于这个做法太暴力了，就不放代码了。

### 分析、思路
刚才的做法时间复杂度最高的是搜索这一部分，我们不妨思考一下：实际上题目要我们求的并不是选择的方案数，而是和的数量，通过搜索去求太浪费了，因此需要考虑新的更优的做法。

设当前可以选择 $i$ 个数，那么我们就可以求出来和的上限 $r$ 和下限 $l$，分别是：

$$\sum_{j=n-i+1}^{n}{j}$$
$$\sum_{j=0}^{i-1}{j}$$

可以发现，由于序列是连续递增的，并且公差为 $1$，因此从上限到下限都是连续且合法的，那么对于能选择 $i$ 的情况来说，和的数量就是 $r-l+1$。

但是，这时候就会延伸出一个问题了：不同的 $i$ 和可能一样吗？答案是不可能。因为题目中加了一个前缀 $10^{100}$，这就确保了选择数量不同，和一定不相同，因此结论是对的。

但是如果直接求和依然会超时，因此呢我们就可以用公式求：[详细资料](https://baike.baidu.com/item/%E6%95%B0%E5%88%97%E6%B1%82%E5%92%8C/7318680)

$$\sum_{x=a}^{b}{x} = (a + b) \times (b-a+1)/2$$

#### 代码：
```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int mod = 1e9 + 7;
int n, k, ans;
int sum(int b, int e) {
  return (b + e) * (e - b + 1) / 2 % mod;
}
signed main() {
  ios::sync_with_stdio(0);
  cin >> n >> k;
  for (int i = k; i <= n + 1; i++) {
    ans = (ans + sum(n - i + 1, n) - sum(0, i - 1) + 1 + mod) % mod;
  }
  cout << ans;
  return 0;
}
```