## 1. 分析：

做这题，很快就可以发现：本题与每个数具体是什么无关，只和每个数在 $0$ 到 $9$ 中出现了哪些有关，所以我们很快想到表示这个数在 $0$ 到 $9$ 中出现了哪些的方法，那就是**二进制**，如果出现了数字 $0$，则这个数就会加上 $2^{10}  \times 1$；如果出现了数字 $2$，则这个数就会加上 $2^8 \times 1$，以此类推。

譬如：数 $25313$。它出现了数字 $1,2,3,5$。那么变为二进制就是：

$$2^{10} \times 0+2^9 \times 1+2^8 \times 1+2^7 \times 1+2^6 \times 0+2^5 \times 1+2^4 \times 0+ … +2^0 \times 0=928$$

很明显任何数都在 $[0,1023]$ 之间。枚举任意两种情况的复杂度就降到了 $O(1024^2)$。

-----------------
我们用 $a$ 数组表示每种数（二进制相同的叫做一种数）的数量。

对于任意的一种数 $i$，显然可以在内部任意组合，方案数是 $\dfrac{a_i(a_i-1)}{2}$。

对于任意的两种数 $i$ 和 $j$，由于表示成了二进制，所以只要满足 $a_i\land a_j \not= 0$，则它们至少有一位数相等。只要符合条件，那么方案数就有 $a_i \times a_j$。

-------------------
## 2. AC 代码：

```cpp#include<bits/stdc++.h>
#define ll long long
using namespace std;
ll n,a[1030],ans;
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		ll x;
		scanf("%lld",&x);
		int num[10]={0};//记录每个数字在x中是否出现
		while(x){
			num[x%10]=1;//数位分解
			x/=10;
		}
		for(int i=0;i<10;i++){
			x=x*2+num[i];//变成二进制
		}
		a[x]++;//这种数又多了一个
	}
	for(int i=0;i<1024;i++){
		for(int j=i;j<=1024;j++){//从i枚举，防止重复
			if(i==j){//一种数内部选
				ans+=a[i]*(a[i]-1)/2;
			}
			else if(i&j){//两种数选
				ans+=a[i]*a[j];
			}
		}
	}
	cout<<ans;
	return 0;
}
```