### 题意

现在你有 $n$ 个砖和一个宽度为 $C$ 的场地。你可以想象成这个场地是一个高度无限，宽度为 $C$ 的矩形。

每个砖占据一个位置，这个位置记作'B'，没有砖块的地方记作 '.'

问最后可以摆出多少种不同的形状（'.'和'B'只要排列的不同就算不同方案），方案数 $\mod 1e6+3$

### 题解

设 $C(n,m),(n>m)$ 表示从 $n$ 个不同物品中取出 $m$ 个物品的组合数，比如 $C(4,2)=2$

如果把这个矩形分解成 $C$ 列，我们可以发现问题被转换成了：

有 $C$ 个自然数 $a_1,a_2,a_3,...,a_C$ ，对于任意的 $a_i$，$0\le a_i\le n$，你可以自由安排它们的值，但要求所有数的和恰好等于 $n$，问有多少种情况来安排这些数的值。

是不是有那味儿了？

按照这个转换后的题意继续转换：

有 $C$ 个盒子，$n$ 个球，你现在需要把所有球装进盒子里，允许盒子为空，盒子容积无限。问有多少种装球的方案。

这个问题可以用排列组合来解决

把所有球排成一排，用插板法需要插 $C$ 个板，允许板相邻。但这个方法有一个问题就是你无法确定这些板会有几个板撞在一起，以及板会在哪里相邻。如果这样说就可以用组合数直接计数了:

把球和板看成一个东西，排成一排，显然有 $n+C$ 个东西。你现在要选出 $C$ 个东西把它变成板，剩下的都变成球，问有多少种选法

这样不就简单了，直接 $C(n+C,C)$ 就是答案了

注意 $C(n,m)=\frac{n!}{m!\times(n-m)!}$，由于有除法，所以取模时需要用到逆元，这个用费马小定理+快速幂就能解决啦

### 代码

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const ll mod=1e6+3;
ll qpow(ll base,ll p)
{
	ll res=1;
	while(p>0)
	{
		if(p&1) res=(res*base)%mod;
		base=(base*base)%mod;
		p>>=1;
	}
	return res;
}
ll C(ll n,ll m)
{
	m=min(m,n-m);
	ll a=1,b=1,i;
	for(i=1;i<=m;i++)
	{
		a=a*i%mod;
		b=b*(n+1-i)%mod;
	}
	a=qpow(a,mod-2);
	return (a*b)%mod;
}
int main()
{
	ll n,m;
	scanf("%lld %lld",&n,&m);
	printf("%lld",(C(n+m,m)+mod-1)%mod);
	return 0;
}
```
