# CF172A Phone Code  第五篇题解
## 先看题：
有$n(2≤n≤30000)$个长度在$1$~$20$个字符的电话号码，求最大的$k$,使得$N$个电话号码的前$k$位完全相同。
#### 看了一下，前面的大佬们好像都没讲清楚题意&思路，我来讲一下吧
### 题意：
简单来说，就是现在有$n$个字符串$s_1,s_2,s_3……s_n$，要寻找这$n$个字符串最长的公共前缀。

$for$ $example:$ $00209,00219,00999,00909$这四个字符串的最长公共前缀为$00$,长度为$2$。而$00209,00219$这两个字符串的最长公共前缀为$002$,长度为$3$。

输入格式：输入共有$n+1$行

第$1$行输入一个数$n(2≤n≤30000)$,表示一共有$n$字符串

第$2$行至第$n+1$行每行输入一个字符串$s_i$

输出格式：一行一个整数，这$n$个字符串最长的公共前缀长度。
### 思路：
我看到有三位神犇写的$C++$题解开字符串的方式都不同，一位写的是$string$ $s[n+1];$ 一位写的是$char$ $d[30001][21];$ 还有一位写的是$char$ $a[30005][25];$ 
#### 但其实没必要开这么大的数组
我们只需要一个“核对串”$($我选的是第一个字符串$)$与其他字符串一一进行对比，得到$n-1$个最长公共前缀长度，取这$n-1$个长度中最小的即为答案。

### 正确性证明：(重要部分！)
用反证法：

假设这$n-1$个长度中最小的长度为$x$,而答案为$y(x>y)$

说明有一个字符串$s_i$与另一个字符串$s_j$的公共前缀长度为$y$

#### 即$s_i$的第$y+1$个字母与$s_j$的第$y+1$个字母不同.

但因为$s_1$与其他$n-1$个字符串对比出的$n-1$个长度中最小的长度为$x$且$x>y$。

说明$s_1$的第$y+1$个字母与$s_i$的第$y+1$个字母相同且$s_1$的第$y+1$个字母与$s_j$的第$y+1$个字母相同。

#### 即$s_i$的第$y+1$个字母与$s_j$的第$y+1$个字母相同.

推出矛盾

说明$x≤y$。又因为$x$不可能比$y$小$(y$是__公共__前缀长度啊$)$，所以x=y。说明这个思路是正确的。

于是我们就愉快的开始敲代码啦
### 还有一点：不用万能头！
之前三篇$C++$题解都用万能头，太不友善了。

代码在这：
```cpp
#include<cstdio>
#include<cstring>
using namespace std;
int i,n,j,ans;
char s1[21],s[21];//s1为“核对串”，即第一个字符串
//s为后面的字符串
int main(){
	scanf("%d%s",&n,s1);
    //读入n和“核对串”，即第一个字符串
    ans=strlen(s1);
    //ans的初始值取第一个字符串的长度
    //毕竟前缀再长也不可能长过原字符串对吧
	for(i=1;i<n;i++){
		scanf("%s",s);//读入后面的字符串
		for(j=0;j<ans;j++) if(s1[j]!=s[j]) break;
        //比较的过程(注意是<ans不是<=ans)
        //写成后者会导致j出循环时有可能等于ans+1
        //还有可能导致s1[j]或是s[j]无意义
		ans=j;//更新答案
	}
	printf("%d",ans);//输出答案
    return 0;
}
```