问有多少个子串（不包括空串）是单调上升的

注意：类似于[1] [8848] [233] 这样一个数字的也属于单调上升的
___
$N<=3000$ 我觉得会超时所以我有个优化的思路，从左往右找，然后分成几份，分的案例：

比如1 2 3 2 1

我会把它分成：$[1,2,3];[2];[1]$

这样每一份他的全部子串（不包括空串）均满足单调上升

第一个的全部子串有：$[1],[1,2],[1,2,3],[2],[2,3],[3]$

第二个的全部子串有：$[2]$

第三个的全部子串有：$[1]$

#### 我发现了若你有$x$个元素那么，你有$x*(x+1)/2$个子串

### 代码：
```
#include<bits/stdc++.h>
using namespace std;
long long a,b[100005],c,d,e,ans,now=1;
int main()
{
    cin>>a;
    b[a]=-100;
    for(int s=0;s<a;s++)cin>>b[s];//输入
    for(int s=0;s<a;)
    {
    	for(int v=s+1;v<=a;v++)
    	{
    		if(b[v]<=b[v-1])//优化！
    		{
    			ans=ans+((now+1)*(now)/2);
    			s=v;//改变s
    			now=1;
    			break;
			}
			else
			now++;
		}
	}
	cout<<ans<<endl;
}
```