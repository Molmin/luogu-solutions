### solution

题目要求：求数组中有多少个单调上升的子串。

（其实严谨点来说应该是**严格单调**上升子串，样例3可以证明这一点）
***

首先观察数据范围，$n\le10^5$，$O(n^2)$的算法肯定是过不了的。

由于**子串是连续的**，通过观察我们不难想到：

对于数组中的某个数 $a_i$ ，如果 $a_{i-1}<a_i$ ，那么：从 $1$ 到 $i$ 的所求子串个数 $=$ 从 $1$ 到 $i-1$ 的子串个数 $+1$.

否则，从 $1$ 到 $i$ 的所求子串个数就只能$=1$.

故而，此题可以使用 $O(n)$ 的递推算法来解决。
***

在这里有个点要注意一下：```dp[1]```是几呢？当然是1啦qwq
### code:
```cpp
#include <cstdio>
int a[10001],dp[10001];
int n,ans;
int main()
{
	int i;
	scanf("%d",&n);
	for (i=1;i<=n;i++)
		scanf("%d",&a[i]);
	dp[1]=1;
	for (i=2;i<=n;i++)
	{
		if (a[i]>a[i-1])
			dp[i]=dp[i-1]+1;
		else
			dp[i]=1;
	}
	for (i=1;i<=n;i++)
		ans+=dp[i];
	printf("%d\n",ans);	//别忘记换行
	return 0;
}
```
