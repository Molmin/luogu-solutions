本题解主要正对状压dp的优化谈起
------------

如果还不懂如何状压dp请见其他题解。

其他大多数题解都只是将dp公式列出而后上代码，我打了很久的状压dp，从暴力成功上升到了80，多了10分~~（要是在考场上估计心态都崩了）~~，4个TLE，然后~~怒开O2A了它~~。

当然noip是没有O2的，CCF也不是用的**神威太湖之光**，所以我们考虑怎么把复杂度降下来。

这是我最初的dp方法：
~~~cpp
	for(当前状态）
    	for(深度）
        	dfs()//枚举子集
            {
            	找到当前状态有而子集没有的节点，找从子集连向该点的最短距离；
            }
  ~~~
  
  计算一下复杂度： 状态个数：$2^n$ 、 深度：n、 子集：$2^n$、找最短边：n
  
  综上 O= $2^n*2^n*n^2$
  
  最坏：2415919104==$10^9$级别
  
  优化方法1：
------------
将dfs()放到for(当前状态）下面，即

  ~~~cpp
	for(当前状态）
    	dfs()//枚举子集
        {	
            for(深度）
            	找到当前状态有而子集没有的，从子集连向该点的最短距离；
        }    
  ~~~
  
  这样对于一个状态，只会生成一次子集，虽然理论复杂度没变
~~（所以还是T了）~~，但是还是加快了速度。
  
  
优化方法2：
------------
  考虑不同状态可能会有相同子集，所以说某个点到一个子集的最短路会被算很多次，比如：
 
 11111和11011 都有子集 10011， 并且都会求4号（01000）节点到10011子集的最短距离，那么何必重复计算呢？于是开一个dis[ver][son], 表示ver节点到son这个子集的最短路径，初始化为-1，来记忆化搜索。
 
 于是复杂度被降为： O $2^n*(2^n*n+n)$	
 
 **乘进去后的**$2^n*n$表示每个节点到子集的距离情况
 
 最坏==201326592（$10^8$级别，但考虑不是每个状态都有$2^n$个子集，况且指数级的增长率巨大，其平均值应远远低于$2^n/2$，~~（于是被强行嘴炮到$10^7$级别）~~基本上可以过去。）
 
 于是就A了。
 
 
 另外：
------------
这道题给我最深的感受是，**即使证明出了算法错误，也要注意数据是否有特殊点，因为这些错误的方法对于特殊数据可能正确。**在特殊数据之外再暴搜。

比如说不难证明出prim最短路的错误，如图，假设从1出发：


![](https://cdn.luogu.com.cn/upload/pic/34692.png )
  
 红是最小生成树，蓝是正确路径，但是一看数据有40%边权一样，很明显，如果按照先入prim的已连接集合为更新的起点，此时的距离恰好反映了经过的节点数目（由于边权相同，同深度的点是一起被更新的（只在小于时更新），相当于bfs（貌似可以写bfs而不用prim）），对于这40%可以用最小生成树、最短路或者bfs。
 
如果边权不等，用dfs枚举，类似prim但是枚举起点和终点的连边，而不找最短边，即可获得70分。

如果你脑洞足够大，在点数大于8是再用prim（或bfs），即可获得75，这已经相当可观了！！！
  
  
  