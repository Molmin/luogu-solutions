这其实是线性基的裸题。

分析一下原题，开关就相当于异或操作（显而易见）。

那么题目难在哪里呢，就是可能会出现重复的现象。出现重复的现象就是相当于由于不同的操作会出现相同的状态。

建模就是存在一些数，这些数异或起来是0（等价于没有操作）。那么需要求一个集合，满足集合中元素相互异或不会出现0.

线性基派上用场了。

首先有一个性质需要知道：a和b两个数可以有0,a,b,a xor b这四个数，而把b换成a xor b还是这四个数，那么这就可以用线性基了。

线性基就是把原有的集合用一个新的集合替代之，新的集合里面数相互异或可以得出原有集合的数相互异或的答案。

利用上面的性质就可以写出如下的代码。

从高位向低位做，如果P[j]没有被赋值，那么就赋值为A[i],否则把A[i]异或上p[j]，这样A[i]的j位就不会再成为1。

这样就可以保证线性基中没有相同位置的1，这样求出来的线性基就是一个互不影响的开关。那么2^r就是答案。

```cpp
#include<bits/stdc++.h>
using namespace std;
long long A[100],P[100]; 
char s[100];
int sz,r,n;
void solve()
{
    for (int i=1;i<=sz;i++)
    {
        for (int j=62;j>=0;j--)
        {
            if ((A[i]>>j)&1)
            {
                if (!P[j]) {P[j]=A[i]; break;}
                else A[i]^=P[j];
            }
        }
    }
    for (int j=0;j<=62;j++) if (P[j]) r++;
}
int main()
{
    scanf("%d%d",&n,&sz);
    for(int i=1;i<=sz;++i)
    {
        scanf("%s",s);
        for(int j=0;j<n;++j)
        if(s[j]=='O')
        A[i]^=(1ll<<j);
    }
    solve();
    printf("%lld",(1ll<<r)%2008);
}
```