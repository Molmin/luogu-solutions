提供一个和其他题解不一样的做法。

在打比赛的时候没想出来，一直想的是说用$f[0][i]$与$f[1][i]$做转移——$f[1][i]$表示奇数步到$i$遍历城市数，$f[0][i]$表示偶数步到$i$遍历城市数，结果记搜崩了，并且被ABC题拖累导致没有时间做这个题……当然这题也可以DP，其他题解有提到。

其实这个题可以用**图论**的想法去做。

注意到，每走一次路就会全部反向。那么第一：整个连接状态就两种，要么全正着要么全反着；第二，走两次图就恢复了；第三，来的时候怎么走过去接下来一步就可以怎么走回去：

假设现在有一条边从2单向指向3，从2出发可以走到3，然后由于走过了一步，所有道路反向，那么现在这个路是从3指向2的，3又可以走回到2。因而，如果$i$能到$j$，那么$j$就一定能回到$i$。

基于这几个性质，我们就可以发现：**走的顺序不会影响连通性**。从一个点出发，无论是先走左边再遍历右边，还是中间穿插左右横跳式游览，**能到的城市总是能到**。那么我们就可以考虑直接研究这个图而非每个节点了。

那么这个图应该怎么抽象出来呢？

我们注意到：**走的步数不同的时候一个点所能到达的点的状态不同**。例如一个节点如果给的是$\tt LR$，那么第奇数步的时候图是正图，两边都能去；而如果是第偶数步到达这个点，那么就两边都不能去，因为连接状态变成了$\tt RL$。因而，我们应该考虑**分层图**——用连接状态做分层依据。结合上面的分析，我们就得到了建图方法：

**如果是$\tt L$，则第一层$i-1$向第二层$i$连双向边；如果是$\tt R$，则是第一层$i$连向第二层的$i-1$，连双向边;第一层$i$与第二层$i$不相连。**

最后答案直接统计每个点所属的连通块和每个连通块的大小即可。因为是无向图，同一连通块内可以互相到达，因而一个连通块内答案相同；由于同一节点不同层不能到达，因而不会出现一个节点两层同时出现在一个连通块中，因而连通块大小就是到达城市数，其中在第二层的节点为偶数步到达的，第一层节点是奇数步到达的。

代码也比较简单，只给出核心部分代码。

```cpp
for (int i = 1; i <= n;i++)//建边。字符串中从1开始编号
	if(a[i]=='R')//如果是R的情况，黑体字分析了。
	{
		add(i - 1, i + n + 1);
		add(i + n + 1, i - 1);
	}
	else//L的情况
	{
		add(i, i + n);
		add(i + n, i);
	}
for (int i = 0; i <= 2 * n + 1; i++)//一个朴素的计算连通块数目和连通块大小的代码
	if (!col[i])
		bfs(i, ++tot);//图的遍历，遍历这个连通块，tot为染色专用
```
