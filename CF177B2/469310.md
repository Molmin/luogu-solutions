先看一看题。

大意为让我们模拟一个取石子的过程，要求每次 **留下当前石子数任意因数个石子** ，再将留下的石子计入答案，将此过程再次重复一遍，直到只剩下一颗石子。

先来解释一下什么是  _“留下当前石子数任意因数个石子”_  。

题目的要求是取走 $a-1$ 排的石子，那么就相当于留下了 $1 \times b$ ，也就是 $b$ 颗石子，那么由于 $a$ 和 $b$ 都是 $n$ 的因数，所以我们可以视为留下当前 **石子数的任意因数** 个石子。

举个例子，假如你现在有十颗石子。

十的因数有 `1,10,2,5` ，那么你可以选择留下`1` 或  `2` 或 `5` 颗石子。

你会问为什么不能留下 `10` 颗？

因为你看题里有说要求 $a > 1$ ，在这个条件约束下你是不能够摆成一排的（但是在当前剩余石子数量为质数时可以摆成一列）。

又假如说，你现在有 `8` 颗石子。

那么可以留下 `1` 或 `2` 或 `4` 颗石子。

我们会发现一个数的两个因子中，一个因子越大，另一个因子就越小，而我们 **需要留下除这个数本身外最大的因子** （这样答案才会更优） ，所以我们只需要从小到大枚举因子即可，因为最大的因子总是与最小的因子相对，所以找到了最小的因子，最大的因子就找到了。

大概如下。

$n$ 的最小与最大因子分别为 $a$ , $b$ ,我们留下较大的因子 $b$ 并将其作为下一轮的 $n$ 。

注意最后余下一的时候，一要算入答案，所以输出时要加上一。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long

ll n,ans=0;

int main()
{
	scanf("%lld",&n),ans+=n;

	while(true){//n=1,剩下唯一一颗石头
		bool flag=0;//取过与否
		for(int i=2;i<=sqrt(n);i++)//优化，取到sqrt(n)就足够了
			//因为跨过了sqrt(n)后所有的因数都在之前被作为另一半枚举过了
			if(n%i==0){//能整除
				//因为从小枚举，所以第一个找到的一定是最小的
				//而它对应的对应的一定是最大的，我们就留下它(指大的那一部分
				ans+=(n/=i/*另一半大的被留下*/);//留下的计入答案
				flag=true ;//做过操作了
				break ;
			}
		if(!flag) break ;//退出是因为没有操作
		//没有操作就是n=1
	}

	printf("%I64d\n",ans+1);//余下的一块也计入答案

	return 0;
}
```
