**P5073**题解。

感觉难点在于卡常和卡空间。

首先一个很有病的地方在于，我卡常甚至基因对照到要卡到 getchar，没想到吧，空间时间稍微大一点就过不去了，所以脑瘫。

我们都知道朴素的区间最大子段和可以通过维护四元 tuple $(sum,lmax,rmax,mx)$ 即区间和，区间最大前缀，区间最大后缀，区间最大子段和，合并两个区间的伪代码如下：

```cpp
struct tuple
{
	long long sum,lmax,rmax,mx;
	tuple(){sum = lmax = rmax = mx = 0;}
	tuple(long long SUM,long long LMAX,long long RMAX,long long MX){sum = SUM , lmax = LMAX , rmax = RMAX , mx = MX;}
	tuple operator + (const tuple &R) const
	{
		tuple z;
		z.sum = (sum + R.sum);
		z.lmax = max(lmax , sum + R.lmax);
		z.rmax = max(R.rmax , R.sum + rmax);
		z.mx = max(mx , R.mx , rmax + R.lmax);
		return z;
	}
};
```
考虑到全局加，我们可以考虑对于一个区间的贡献仅用数的数量，区间和两个量来刻画，投影到平面直角坐标系分别记作第一维和第二维，则一个区间对应一个点。

区间最大和朴素做，对于区间最大前缀，区间最大后缀，区间最大子段和我们都是相当于给定一个数 $k$，从一个点集里面选一个点 $(x,y)$ 出来问最大的 $kx + y$。

把点换成直线系数的定义，发现本质就是凸壳的相关形式，我们只需要维护这三个信息下掌管的点集对应的凸壳就好了。

对于前缀信息和后缀信息，本质就是两个凸包直接合并，在有序的情况下直接合并就好了。

对于区间最大子段和信息，发现中间有一个```rmax + R.lmax```，所有点都需要贡献一个和另一个凸包的点相加得到的新的点，这个东西本质就是闵可夫斯基和，也可以直接合并。

这里给出一道个人当成模板题写的闵可夫斯基和的[题目](https://www.luogu.com.cn/problem/P4557)。

然后就是最困难的卡常……

对于合并凸包的时间复杂度，由于一直保证合出来的凸包有序，所以每次合并都是 $O(|V|)$，总的时间复杂度就是 $O(n \log n)$。

对于查询的时间复杂度，离线下来挂到每个线段树节点上，做双指针就又省了二分的时间复杂度，总的时间复杂第就是 $O(q \log n)$。

对于凸包空间复杂度，我们得按深度从下至上处理询问，每次回答完一个节点的询问就扔了，空间复杂度就是 $O(n)$ 了。实现建议写成函数返回凸包，比较方便。

对于询问空间复杂度，首先得用到一个性质就是我们维护的东西具有结合律不具有交换律，所以我们对于每个询问开两个数组，存储左半信息和右半信息，最后把两部分答案算在一起就是总答案，这么做的原理是我们总能对任意询问 $(l,r)$ 在线段树上找到一个节点 $(L,R,mid)$ 满足 $l \leq mid$ 且 $r > mid$，然后从这个节点下去的左子树里，被询问完全覆盖的线段树节点的深度从左到右称递减；从这个节点下去的右子树里，被询问完全覆盖的线段树节点的深度从右到左呈递减。这样就保证了这个做法的正确性。

比较简单的实现是用一个单链表，该分的时候分开下放到子树的链表系里面去，每次递归处理子树过后把询问从子树的链表系里面拿出来向上合并然后再查就好了。

最后总的时间复杂度 $O((n + q) \log n)$，空间复杂度线性。

很卡常，很卡常，很卡常。很卡空间，很卡空间，很卡空间。建议调不出来就基因对照吧，摆。