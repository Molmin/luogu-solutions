## 1. 编程思路。

一个二进制数 $X$ 与二进制数 $Y$ 对应位的值不相同的位数越多，它们之间的哈明距离越大。

$X$ 与 $Y$ 不相同的二进制数位越多，意味着 $X$ 与 $Z$ 不相同的二进制位数越少，相同的二进制数位数越多，$Z$ 是 $Y$ 的各位变反所对应的二进制数。也就是说，若  $X$ 与 $Y$ 的哈明距离越大，则 $X$ 与 $Z$ 的哈明距离越小。

设给定的 $n$ 个非负整数构成了一个集合 $A$，我们定义 $dest_i$ 表示非负整数 $i$ 与集合 $A$ 的全体元素之间的最小哈明距离。

显然，若 $i$ 在集合 $A$ 中，则 $dist_i=0$，因为它跟集合中的整数 $i$ 相同，这样二进制数的各位也相同，不同的位数为 $0$，哈明距离也为 $0$。

若 $i$ 不在集合 $A$ 中，则置 $dest_i$ 的初始值为一个最大的整数。

之后，通过改变 $m$ 位中的每一位的方式，求出各个 $dist_i $ 的值（$0\le i \le 2^m-1$）。

以题目给定的样例 #$2$ 进行说明。

集合 $A$ 中有四个整数 $3,5,7,9$，因此 $dist_3=dist_5=dist_7=dist_9=0$。

$3,5,7,9$ 对应的 $4(m=4)$ 位二进制数分别为 $0011,0101,0111,1001$。

先改变最低位的数字，则有 $0010,0100,0110,1000$，由此可得 

$dist_2=dist_3+1=1$，$dist_4=dist_5+1=1$，
$dist_6=dist_7+1=1$，$dist_8=dist_9+1=1$。

再改变次低位的数字，$3,5,7,9$ 对应的二进制数更改次低位分别可得 $0001,0111,0101,1011$。为此可得，
$dist_1=dist_3+1=1$；$dist_7$ 的现值比 $dist_5+1$ 还小，不修改；同样，$dist_5$ 也不修改；$dist_{11}=dist_9+1=1$。

$2,4,6,8$ 对应的二进制数更改次低位分别可得 $0000,0110,0100,1010$，其中，$dist_0=dist_2+1=2$，$dist_{10}=dist_8+1=2$，$dist_4$ 和 $dist_6$ 不修改。

之后，修改次高位，可得 $dist_{13}=dist_9+1=1$，$dist_{12}=dist_8+1=2$，$dist_{15}=dist_{11}+1=2$。

最后修改最高位可得，$dist_{14}=dist_6+1=2$。

求得了所有的 $dist_i $ 的值后（$0\le i \le 2^m-1$），某个数 $a_i$ 与数组中其他元素之间的最大哈明距离就很方便求出了，设 $a_i$ 对应的 $m$ 位二进制数各位变反后对应的整数为 $x$，则所求的最大哈明距离为 $m-dist_x$。

## 2. 源程序。

```c
#include <stdio.h>
#include <string.h>
int a[1 << 20];
int dist[1 << 20];
int min(int a,int b)
{
    return a<b?a:b;
}
int main()
{
    int  n,m;
    scanf("%d%d",&n,&m);
    int i,j;
    for (i = 0; i < n; ++i)
    {
        scanf("%d",&a[i]);
    }
    memset(dist,0x3f,sizeof(dist));
    for (i=0;i<n;i++)
        dist[a[i]]=0;
    for (j=0;j<m;j++)
        for (i=0;i<(1<<m);i++)
            dist[i ^ (1 << j)] = min(dist[i ^ (1 << j)], dist[i] + 1);
    for (i = 0; i < n; i++)
    {
        j = ((1 << m) - 1) ^ a[i];
        printf("%d ",m - dist[j]);
    }
    printf("\n");
    return 0;
}
```


