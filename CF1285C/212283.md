## 题意

给定一个 $x$，存在一些二元组 $(a,b)$，使得 $\text{lcm}(a,b)=x$。

要求找出这些二元组中，使得 $\max(a,b)$ 最小的那个二元组。

## 解法

假设存在一个不互质的二元组 $(a,b)$，满足题目条件，不妨设 $a\le b$，那么：

$\left(a,\dfrac{b}{\gcd(a,b)}\right)$ 依然是一组满足条件的二元组，并且使得 $\max(a,b)$ 更小了。

对于新的这一个二元组，我们可以继续进行这个操作，直到两个数互质，那么，我们可以得出结论：**题目所求的二元组，一定满足 $a$ 与 $b$ 互质**，或者说是 $\gcd(a,b)=1$。

那么我们可以考虑枚举 $i$，枚举范围从 $1$ 到 $\sqrt{x}$，如果 $i$ 不是 $x$ 的因数，那么这个 $i$ 对于我们解题是没有帮助的，对于每一个剩下的 $i$，令：

$$a=i\qquad b=\dfrac{x}{i}$$

这时候注意几个显然的特性：

- $a\le b$，因为我们从小到大枚举。
- $a,b$ 一定是 $x$ 的因数。

此时，如果能够满足 $\text{lcm}(a,b)=x$，就取 $\min(res,b)$ 即可。

为什么是 $b$ 呢？因为 $b\ge a$ 啊。但是另一个问题是，为什么这么枚举呢——为什么不存在其他的解法呢？首先 $a,b\le x$ 是显然的，同时，我们已经证明了这两个数必然互质，那么这么枚举就是正确的。

我们只需要初始化存储 $b_{\min}$ 的变量即可，因为只有它决定了答案的大小，我们的 $a_{\min}$ 跟着它更新就行了。

## 代码实现

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int x,res1=9223372036854775807,res2;
signed main(void){
	cin>>x;
	for(int i=1;i*i<=x;++i){
		if(x%i)continue;//如果不是因数就跳过
		int a=i,b=x/i;//分配二元组
		if(a*b/__gcd(a,b)==x){//如果 lcm(a,b)=x
			res1=min(res1,b);//那么取最小值
			if(res1==b)res2=a;
            //如果取得了最小值，就更新另一个值
		}
	}cout<<res2<<" "<<res1;//输出
	return 0;
}
```