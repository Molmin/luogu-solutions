非常有趣的通信题。

再次叙述题意：你需要实现两个函数 ``void Anna(int N,long long X,int K,int P[])`` 和 ``long long Bruno(int N,int A[])``，实现以下功能：``Anna`` 将得到一个长为 $n=150$ 的空白序列和一个不大于 $10^{18}$ 的数字 $x$，这个函数需要为每一位赋予一个 $0$ 或 $1$ 的值来保存 $x$，其中序列中有 $k$ 个位置是损坏的：无论设置为 $0$ 还是 $1$，这些位置的值都恒为 $0$，$p$ 数组保存着这些位置的下标；``Bruno`` 将得到 ``Anna`` 操作后的序列，这个函数需要依靠这个序列来还原 ``Anna`` 得到的数字 $x$。

#### 思路

直接二进制存储肯定是不可行的，因为损坏的位置不能保存任何信息。

序列长度是 $150$，而需要保存的信息有 $60$ 位。考虑以两位为单位保存信息。将序列分成 $75$ 段，对于每一段，如果两个格子中有一个损坏了，就将这两个格子都设置为 $0$，不保存任何信息；否则使用两个二进制位的 $01/10/11$ 分别表示一个三进制位 $0/1/2$，使用三进制来存储 $x$。计算一下，$x_{\max}=3^{\frac{150}{2}-40}=3^{35}\approx 5\times 10^{16}$，所能保存的最大值小于本题要求，但这个做法可以在本题获得 $85$ 分的好成绩。

以上做法每个损坏位最多都会使一个正常位不保存任何信息，这些位置被浪费了。

考虑更高效的存储方式。以三位为单位保存信息，将序列分成 $50$ 份。这样对于每一段，只要损坏的位数小于两个，就都还能保存一些信息。对于损坏了两位或三位的段，我们还是直接全部设置为 $0$，只使用损坏了一位和全部完好的段存储信息。

共有 $50$ 段，那么最坏情况会有 $20$ 个不保存任何信息的段或有 $40$ 个损坏了一位的段。如果损坏了一位的段可以保存一位二进制信息而没有损坏的段可以保存两位二进制信息，那么在任何情况下这个序列都可以保存 $60$ 位二进制信息，恰能将 $x$ 存下。

考虑构造这样一种方案。

若三位中有至少两位损坏，则将三位全部设置为 $0$，表示这三位不记录任何信息。

然后将 $001/010/011/100/101/110/111$ 分别赋予保存的内容：

$$011/100 \rightarrow 1$$

$011/100$ 用来表示一位二进制 $1$，当前段有一个损坏时，使用这两种总能表示出来，存储了一位信息。

$$001 \rightarrow 00$$

$$110 \rightarrow 01$$

$$101 \rightarrow 10$$

$$111 \rightarrow 11$$

以上四种情况分别对应 $00/01/10/11$，当前段没有损坏时，可以存储两位二进制信息。

$$010 \rightarrow 0$$

$010$ 用来表示一位二进制 $0$。这样有一个问题：能保存信息的三位二进制数只有 $7$ 种，需要的对应关系却有 $8$ 种。当前段的中间点损坏时就不能表示了。

那么考虑复用前面的对应关系 $001 \rightarrow 00$ 和 $101 \rightarrow 10$。若当前段的中间点损坏了，那就让当前段也保存两位信息，恰好前面构造的方案中存下 $00$ 和 $10$ 的方案中间位都是 $0$，因此可以在这一段同时保存上一位的信息。

这样我们就达成了前面的目标，可以获得 $100$ 分的成绩。

#### 本题通信相关

本题在 AtCoder 的评测和计分方式异乎传统题。只要成功完成通信即可获得 $0$ 分的 AC。洛谷爬回的提交记录只会显示是否 AC 而不会显示分数。

本题要求所有点的值都恰好被设置一次，即使是损坏的格子也必须设置一个值。

#### 代码

```
#include "Broken_device_lib.h"
void Anna(int N,long long X,int K,int P[])
{
	int i,j,w,b[3],ax;
	long long now=X;
	for(i=0;i<N/3;i++)
	{
		w=0;b[0]=b[1]=b[2]=0;
		for(j=0;j<K;j++)
		{
			if(P[j]==3*i) b[0]=1,w++;
			else if(P[j]==3*i+1) b[1]=1,w++;
			else if(P[j]==3*i+2) b[2]=1,w++;
		}
		if(w>=2)
		{
			Set(3*i,0),Set(3*i+1,0),Set(3*i+2,0);
			continue;
		}
		if(w==1)
		{
			ax=now%2;
			if(ax==0)
			{
				if(b[1]!=1)
				{
					Set(3*i+1,1),Set(3*i,0),Set(3*i+2,0);
					now>>=1;
				}
				else
				{
					ax=now%4;
					if(ax==0) Set(3*i+2,1),Set(3*i,0),Set(3*i+1,0);
					else if(ax==2) Set(3*i,1),Set(3*i+2,1),Set(3*i+1,0);
					now>>=2;
				}
			}
			else if(ax==1)
			{
				if(b[0]!=1) Set(3*i,1),Set(3*i+1,0),Set(3*i+2,0);
				else Set(3*i+1,1),Set(3*i+2,1),Set(3*i,0);
				now>>=1;
			}
		}
		if(w==0)
		{
			ax=now%4;
			if(ax==0) Set(3*i+2,1),Set(3*i,0),Set(3*i+1,0);
			else if(ax==1) Set(3*i,1),Set(3*i+1,1),Set(3*i+2,0);
			else if(ax==2) Set(3*i,1),Set(3*i+2,1),Set(3*i+1,0);
			else if(ax==3) Set(3*i,1),Set(3*i+1,1),Set(3*i+2,1);
			now>>=2;
		}
	}
}
long long Bruno(int N,int A[])
{
	int i,j,w,b[3],ax;
	long long ret=0;
	for(i=N/3-1;i>=0;i--)
	{
		ax=(A[i*3+2]<<2)+(A[i*3+1]<<1)+A[i*3];
		if(ax==0) continue;
		else if(ax==1) ret<<=1,ret|=1;
		else if(ax==2) ret<<=1;
		else if(ax==3) ret<<=2,ret|=1;
		else if(ax==4) ret<<=2;
		else if(ax==5) ret<<=2,ret|=2;
		else if(ax==6) ret<<=1,ret|=1;
		else if(ax==7) ret<<=2,ret|=3;
	}
	return ret;
}
```
