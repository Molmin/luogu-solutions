#### $\textrm{Subtask1}$
由于不能操作，直接给出一个 $n\sim 1$ 的排列即可。

#### $\textrm{Subtask2}$
可以发现此时一定能通过 $n-1$ 次交换得到任意排列，故任意排列都可以成为答案。

#### 性质分析

先考虑这个问题，给定一个排列，如何求出其交换不超过 $k$ 次得到的字典序最小的排列？

##### 解法
令排列为 $p$，每次操作找到最小的 $p_k\neq k$ 的最小的 $k$，若不存在，则已经成为字典序最小的排列，否则，将数字 $k$ 换到位置 $k$，可以发现这样一定是最优的。 

也就是说，交换之后可以保证前 $k$ 个数一定是 $1\sim k$，但完全无法保证后面数的顺序，可以尝试构造一个排列使得最后交换只能得到 $1,2,\dots k-1,k,n,n-1,\dots k+2,k+1$。

#### $\textrm{Solution}$

先特判 $m\geq n-1$ 的情况。

令一个排列 $p$ 初始为 $1,2,\dots m-1,m,n,n-1,\dots m+2,m+1$。

从 $m$ 至 $1$ 依次执行交换 $p_i,p_{i+1}$ ，可以发现若要还原排列一定会得到， $1,2,\dots m-1,m,n,n-1,\dots m+2,m+1$。