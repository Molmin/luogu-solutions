## 题意

给定 $n$ 种颜色的球，每个球有 $k$ 个，把这 $n\times k$ 个球排成一排，把每一种颜色的最左边出现的球涂成白色(初始球不包含白色)，求有多少种不同的颜色序列，答案对 $10^9+7$ 取模。

## 分析

看了好几份题解发现有一些步骤一笔带过，看起来有一点吃力，这里想写一篇相对详细的题解。其他题解中的一些基于状态设计的表述容易让初学者引起“这道题居然能放白球吗”的误解，这一点私以为可以注意一下。

--------

从任何一个角度来看，难点都主要在于设计状态。

我们定义 $f(i,j)$ 表示当前序列中有 $i$ 个白球、$j$ 种其他颜色的情况。不难发现一定存在 $i\ge j$，为什么？因为每一种白球都代表着一种颜色的最左端，如果白球个数少于其他颜色的个数，那么就一定存在某种颜色没有对应的白球，这是不妥当的。

为什么可能存在白球个数大于其他颜色个数呢？因为到目前为止可能会存在某些颜色只出现了一次，而这单独的一次会被染色成白色，因此就不能计算在“其它颜色的种类”这一变量之中。

我们接下来考虑这种状态应该从哪一种状态之中来。首先如果到达这个状态是放了一个白球，那么显然就是放了一个白球而已，因此我们可以从 $f(i-1,j)$ 进行转移。这时候只有单纯的选择方案，但是如果要选择新的一种颜色，事情就不太一样了。

因为我们选择颜色一定要从剩下的颜色之中选，所以要在剩下的 $n-j+1$ 种颜色填入（一共有 $n$ 种颜色已经用了 $j-1$ 种，接下来要用第 $j$ 种），与此同时 $nk-i-1-(j-1)\times(k-1)$ 个位置中选择 $k-2$ 个填入下一种颜色，也就是：

$$\large\text{C}_{nk-i-1-(j-1)\times (k-1)}^{k-2}$$

那么这样的状态转移就容易写出来了。

其中组合数的计算可以考虑一下 $m!\cdot inv_n\cdot inv_{n-m}$，最后要记得对 $10^9+7$ 取模。对于逆元，可以用线性复杂度的方法递推一下，其中要注意，我们求的逆元实际上是前缀积的逆元。


## 代码

代码实现不难。

```cpp
#include<bits/stdc++.h>
#define int long long
#define mod 1000000007
#define N 2005
using namespace std;
int n,k,inv[N*N],fac[N*N],f[N][N];
int C(int n,int m){
   return fac[n]*inv[m]%mod*inv[n-m]%mod;
}void Inv(){
	inv[0]=inv[1]=1;
	for(int i=2;i<=n*k;i++)inv[i]=inv[mod%i]*(mod-mod/i)%mod;
	for(int i=2;i<=n*k;++i)inv[i]=inv[i-1]*inv[i]%mod;
}void Fac(){
	fac[0]=fac[1]=1;
	for(int i=2;i<=n*k;++i)fac[i]=fac[i-1]*i%mod;
}signed main(){
	scanf("%lld%lld",&n,&k);
	Inv();Fac();
	if(k==1){
		puts("1");
		return 0;
	}for(int i=0;i<=n;++i)f[i][0]=1;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=i;j++){
			f[i][j]=(f[i-1][j]+
					f[i][j-1]*(n-j+1)%mod
					*C(n*k-i-1-(j-1)*(k-1),k-2)%mod)%mod;
//			cout<<"("<<i<<','<<j<<") ";
//			cout<<f[i][j]<<"\t";
		}//puts("");
	}cout<<f[n][n]<<endl;
	return 0;
}
```

不才拙笔，至此章卒。