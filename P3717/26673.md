这道题只需要**完全暴力**即可，主要思路是：

1.先定义一个模拟方格图的二位数组变量，为了储存方格图上的一点有没有查找过，注意要**大一点**，不然A不了……（具体原因不明）

2.每输入一个探测器的点，就双重循环查看能不能找到可以探测的地方，另外为了减小时间复杂度，建议不要全图探测，在以探测器为重心边长为 2 \* r 的矩形内查找就行了（因为在这个矩形内画最大的圆恰好是探测器的探测范围）。

3.避免探测器探测同一个地方，查找过的点赋值**真**，此外把能探测的点加一，否则默认就是假。

4.最后输出答案就行了

具体代码如下：

```cpp
#include <iostream>
using namespace std;
int main()
{
    bool map[201][201];
    //定义模拟方格图
    int a,b,n,m,r,s=0;
    cin >> n >> m >> r;
    for(int i=1;i <= m;i++)
    {
        cin >> a >> b;
        for(int x=a-r;x <= a+r;x++)
        for(int y=b-r;y <= b+r;y++)
        if(x >= 1 && x <= n && y >= 1 && y <= n)
        if(map[x][y] == false && (a-x)*(a-x)+(b-y)*(b-y) <= r*r)
        map[x][y]=true,s++;
        //程序核心部分，上面解释过了
    }
    cout << s;
    return 0;
} 
```