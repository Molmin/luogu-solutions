蒟蒻的第三篇题解……不知道能不能通过题解……


下面进入正题：

1<=m,n<=100,也就是数据规模其实是非常小的，可以读入以后暴力将整个n×n的矩阵扫一遍，每个点对应利用勾股定理求出与每一个检测的东东的距离（不要开平方直接判断r×r因为可能导致精度???其实不一定的因为这道题的数据大概不会因为这个而wa），如果距离在半径以内就进行判断，如果这个点没有扫过就ans++，然后把这个点标记为1，最后输出答案就可以了。

ps：输入的每一个点都要记得标记为1且ans++，这里的输入数据可能会重复要记得判重……不然就80了，惨痛的回忆……

ps：附上勾股定理——a^2 + b^2 = c^2，虽然不知道有什么用

下面附上代码，不要直接复制可能会爆0哟～


```cpp
//大大的防伪标志
#include<bits/stdc++.h>//万能头文件没毛病
using namespace std;
struct p{ // 我是用自定义变量数组存放读入的检测器的坐标
    int x, y;
}b[101];
int a[101][101] = {0},ans; // 数据规模要注意
double l ;
int main(){
    int n , m , r;
    scanf("%d %d %d",&n,&m,&r);
    for(int i = 1;i<=m;i++){
        scanf("%d %d",&b[i].x,&b[i].y);
        if(a[b[i].x][b[i].y] == 0){
            a[b[i].x][b[i].y] = 1; // 打标记～
        ans ++;} // 读入要判重不然会80分
        }        
    for(int i = 1;i<=n;i++)
        for(int j = 1;j<=n;j++)
            for(int k = 1;k<=m;k++){
                l = (i - b[k].y)*(i-b[k].y) + (j - b[k].y)*(j - b[k].y); // 勾股定理 ，此行有坑小心谨慎
                if(r*r >= l)  //判断这个点是否在扫描范围之内
                    if(a[i][j] == 0){ // 判断这个点有没有扫过
                        a[i][j] = 1; // 标记
                        ans ++; 
                    }
            }
    printf("%d",ans);//大功告成输出吧～
    return 0;
}
```