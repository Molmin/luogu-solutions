## 题意

有 $\rm{N+M}$ 个人在排队买票，票价为 $5$ 块钱，其中 $\rm{N}$ 个人有 $10$ 块钱，$\rm{M}$ 个人有 $5$ 块钱。

问能正常售票(**即不出现买家用 $10$ 块钱买单，但没有 $5$ 块钱去找钱**)的几率是多少。

**PS:几率指$\frac{能正常售票的情况}{\rm{N+M}}$。**

## 分析

**简化问题：** 求一个由 $10$ 和 $5$ 组成的序列 $\rm{S}$ 中，$\rm{S_i}$的前缀中 $10$ 的数目比 $5$ 的多的几率是多少。

**分类讨论：**
> 1.当 $\rm{N>M}$ 时，由于 $10$ 块钱的人比有 $5$ 块钱的人要多，无论如何排列，最后一定会有一次是无法找钱的。

> 2.当 $\rm{N>M}$ 时，假设当$\rm{N = K}$的时候有$res =\frac{M + K - 1}{M+1}$，
>
>则当 $N = K + 1$ 时，我们将第 $K+1$ 个人放到已经能够正常工作的队列中时，每个 $10$ 元的都能和前面一个 $5$ 元的相互抵消，那么
>
>$res = \frac{M-K+1}{M+1}\times \frac{M-(K+1)+1}{M-K+1}= \frac{M -(K+1)+1}{M+1}$
>
>整理后得到： $res = \frac {M - N + 1}{M + 1}$。

>3.当 $\rm{N==M}$ 时，答案即为$\frac{1}{m+1}。$ (证明过程同上)

## Code
```cpp
#include <bits/stdc++.h>
using namespace std;

int main()
{
	int n,m;
	while(1)
	{
		cin>>n>>m;

		if(n==0 && m==0) break;

		if(n>m) printf("%.6f\n", 0.0);
		else if(n==m) printf("%.6f\n",1/(m+1.0));
		else printf("%.6f\n", (float)(m-n+1)/(m+1));
	

	return 0;
}
```