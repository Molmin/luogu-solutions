新人代码]

这道题我用了计算的方式去避免圆圈出界判断

大体意思是用循环队列的计算方法{head = (head + 1) % n}

将头与尾连接在一起）这个让定位指针p（下标）逆时针时不会出界

但是顺时针旋转时我就想不到解决办法了233

于是我硬是将顺时针改为逆时针旋转（强行不溢出）

------------

这个计算我是这么想的：

首先，人物朝向(dir)与 指令方向(a)的搭配有四种，但实际情况有两种。

1.dir = 0,a = 0  || dir = 1,a = 1

这两个是一种情况，都是顺时针

2.dir = 1,a = 0  || dir = 0,a = 1

这两个又是一种情况，都是逆时针

OK 那么此时，顺时针旋转s下就相当于逆时针旋转 | (n - s) | 下，此时n = 7

而逆时针旋转对应的是它本身,就是 s - n且 n = 0。这也可以写成 | (n - s) |

那么顺时针与逆时针怎么判断呢？显然，当|dir - a| = 0时，是顺时针旋转；
当|dir - a| = 1时，是逆时针旋转

但是，我这个代码并不想要if语句，因此if (abs(dir - a) == 1)是不符合代码要求的

那么我们就可以将|dir - a|代入|(n - s)|里，就变成 |||dir - a| - 1| * n - s|

至于为什么|dir - a|要再 -1,是因为如果这是顺时针旋转，那么|dir - a|就是 0，但

是如果用 |dir - a| * n - s,那么此时|(n - s)|就变成了|(0 - s)|,这显然是逆时针的计

算，因此用 ||dir - a| - 1| (绝对值是为了保证正数)

但是另一个问题又出现了，要是s > n怎么办？

这很简单，将s 变为 s % n即可(先抽象地让它转几圈变成s < n)

那么|||dir - a| - 1| * n - s % n|就算出了p指针应逆时针旋转几个小人。

接下来，将p += |||dir - a| - 1| * n - s % n|就。。。。

不对，要是这样算,要是又出现 p >= n （数组下标从0开始）又怎么办？

p % n即可。

------------

下面是代码(都能AC)




```cpp
#include <iostream>
#include <string>
#include <cmath>	//abs

using namespace std;

struct Toyman
{
	string name;
	int dir;	//0  内,1 外 
}
toys[100005];

int n,m;
int a,s;

int main()
{
	cin>>n>>m;
	for (int i = 0;i < n;i++) {
		cin>>toys[i].dir>>toys[i].name;
	}
	int p = 0;
	for (int i = 0;i < m;i++) {
		//a = 0 左	1 右 
		cin>>a>>s;
        	//计算p值
      		//p = (p + |||dir - a| - 1| * n - s % n|) % n
		p = (p + abs(abs(abs(toys[p].dir - a) - 1) * n - s % n)) % n;
	}
	cout<<toys[p].name;
	return 0;
}
```
