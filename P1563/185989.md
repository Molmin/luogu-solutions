# 重点：用 “%”让数组“转起来”
设数组长度为n,起点为start,偏移量为x,终点为end。
1. 若是按照              0 -> 1 -> 2 ->...-> n-1 -> 0 ->... 这个顺序来“转”，那么计算公式为：
```
end = (start +　ｘ)　％　ｎ
```
这个公式很简单推导，我就不细讲了，不明白的同学，举几个例子验证一下就明白了。

2. 若是按照0 -> n-1 -> n-2 ->...-> 0 ->...这个顺序来“转”，好像是有点绕，但我们可以把它转化成第一种情况啊！仔细想想，这种情况与第一种情况恰好是相反的,列个表康康：

| 第一种情况|  0|  1| 2| ... | n-1 |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| 第二种情况 | n-1 | n-2 | n-3 | ... | 0 |
|  两者之和| n-1 | n-1 |  n-1| ... | n-1 |
用n-1一减不就反过来了！！公式如下：

```
end = n - 1 - [(n - 1 - start + x) % n]
```
好啦，让数组转起来之后，做这题就易如反掌了O(∩_∩)O~


------------
```c
#include <stdio.h>

int main()
{
    int n, m;
    scanf("%d%d", &n, &m);

    char name[100000][12];
    int deriction[100000];

    for(int i = 0; i < n; i ++)
    {
        scanf("%d", &deriction[i]);
        scanf("%s", name[i]);
    }

    int p_der, num, locate = 0;
    for(int i = 0; i < m; i ++)//一边接受数据一边处理
    {
        scanf("%d%d", &p_der, &num);
            if(deriction[locate] != p_der)//逆时针
            {
                locate = (locate + num) % n;
            }
            else//顺时针
            {
                locate = n - 1 - ((n - 1 - locate + num) % n);
            }
    }
    printf("%s", name[locate]);
    return 0;
}

```



