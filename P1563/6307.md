#题解：蓝名小蒟蒻，求dalao指正

说到提高组这道题，那还是去年的事，当时的我比现在更蒟蒻，简直普及小渣渣一个。

当时还是个初中生吧。。。第一次参加提高组，看到这题当时就 模拟 过，没有任何的优化，结果全部超时，30分抱回家 。后来痛定思过重新写，才被启发出了这种思路。当时是有个同学要我写结构体队列（循环队列），我写完就脑子一热想试试重载[]符，让队列像数组一样使用，用的还是模拟，结果每次都循环，慢死。然后发现了规律：几乎不需要时间。

**我们用T来存储当前小人在数组中的下标

(事先int len\_a=strlen(a))

开始想了好久 其实吧 拿样例说，一共7人，不管哪个方向数，第7个始终是自己，每7个一环 。这样实际上只要往此方向数 (n%len\_a) 个人。（n是指旁边第几个人）**


-------------------------------


一、先来往右边数

那么T的右边一个数的下标就是T+1,T的右边n个数的下标就是T+n啦!

我在访问队列的时候，要循环n次 每次T+=1 然后判断如果T>=len\_a 则T-= len\_a;

后来发现懒得写if，索性改成：

循环n次 每次T+=1 然后T%=len\_a;//这么写，T始终是在[0,len\_a-1]区间内

后来发现最快的：

然后使用公式right(T)=(T+n)%len\_a;

直接就找到了T右边第n个数的下标。

二、 然后往左边数了

同样的，那么第T个数的左边n个数的下标是：T-n

但是这样可能为负数。之前说过了，最多往左边数len\_a-1人，再多数一个就回到原点。

则：T-(n%len\_a) 有可能为负数 但是T-(n%len\_a)+len\_a绝对非负因为 (n%len\_a) < len\_a ,然后再mod上一个len\_a防止超出即可。但是这样的话当 T = len\_a 且 n=0 时 会出错

所以改成事先判断n是否为0就不会。

公式： left(T)=(T-(n%len\_a)+len\_a)%len\_a

三、判断向哪一边数人

这个很简单。观察可知当代表方向的bool值与代表小人朝向的bool值不相等，则为顺时针（往左边），相等则为逆时针（往右边）


----------------------------------------------

**这样的话只需要对下标T进行操作，赋值语句轻松解决。

附上代码，很短: **

```cpp
#include<iostream>
#include<vector>
using namespace std;
int n,m;
vector<string> name;
vector<bool> w;
int main()
{
    cin>>n>>m;
    for(int i=0;i<n;i++)
    {
        bool a;string b;
        cin>>a>>b;//读人 
        w.push_back(a);
        name.push_back(b);
    }
    int point=0;//下标从0开始数 
    while(m--)//循环m次的简写
    {
        bool f;
        int num;
        cin>>f>>num;//读人指令 
        if(num!=0)
        {
            if(w[point]^f)//异或符^，不等时为1否则为0。
                point=(point+num)%n;//这里如果f和W不等，则顺时针 
            else
                point=(point-num%n+n)%n;//否则逆时针 
        }
        
    } 
    cout<<name[point];//输出 
    return 0;
}
```