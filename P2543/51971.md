## 模板：最长公共子序列

#### **其它题解都没有解释很清楚最长公共子序列怎么求（或许是我太蒟了），故我来发一篇补充解释一下**

这篇题解是写给像我这样原本连最长公共子序列都不会求的人看的。。。

~~**我是安徽人，我深深地爱着我省的省选题**~~

于是先来解释一下如何用dp求最长公共子序列

我们用$s$和$t$来表示题目中所给出的两个字符串，用$f[i][j]$来表示$s[0] \sim s[i-1]$这个子串和$t[0] \sim t[j-1]$这个子串的最长公共子序列的长度，然后分类讨论：

$1.$若$s[i-1]$不在此时的最长公共子序列中，则我们完全可以忽略$s[i-1]$这个字符，因为它并不影响此时的最长公共子序列的长度，那么此时$f[i][j]=f[i-1][j]$（忽略字符$s[i]$直接转移）  
$2.$若$t[j-1]$不在此时的最长公共子序列中，$f[i][j]=f[i][j-1]$，分析同上  
$3.$若$s[i-1]==t[j-1]$，那么他们两个可以组成最长公共子序列中新的一个元素，此时$f[i][j]=f[i-1][j-1]+1$，即为去掉它们两个时最长公共子序列的长度加上它们两个所组成的长度（也就是$1$啦）

综上所述，$f[i][j]$为以上三种情况中的最大值，其中第三种情况有先决要求

答案为$f[s.size()][t.size()]$（也就是两个整串的最长公共子序列的长度）

特别的，无论如何，我们都可以采取前两种情况，因为它与当前的$i,j$没有任何关系

code:
```
#include<iostream>
#include<string>
#include<algorithm>
using namespace std;
int f[10002][10002];
int main()
{
    ios::sync_with_stdio(false);//关闭同步加速
    string s,t;
    cin>>s>>t;
    int len1=s.size(),len2=t.size();
    for(int i=1;i<=len1;i++)
    {
        for(int j=1;j<=len2;j++)//循环枚举每一个f
        {
            f[i][j]=max(f[i-1][j],f[i][j-1]);//设为(1)和(2)中的大值
            if(s[i-1]==t[j-1])//满足(3)的条件
                f[i][j]=max(f[i][j],f[i-1][j-1]+1);//加入考虑(3)
        }
    }
    cout<<f[len1][len2]<<endl;//输出长度
    return 0;
}
```

求过，~~毕竟其它题解都没解释的清楚嘛~~

## ~~劳烦各位管理员造福蒟蒻~~，也希望各位大佬来指正哦！