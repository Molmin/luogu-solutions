看了这个题不如看下[这个题](https://www.luogu.com.cn/problem/P7246)？

题意比较清楚，就不讲了。

首先有个简单结论是，如果有多组 $(s_i,t)$ 的关系，我们只需要保留 $s_i$ 深度最小的关系 $(s_i,t)$ 即可。

然后是因为所有的 $(s_i,t_i)$ 都是祖孙关系，因此如果我们选择了一条路径使得它的端点在一个点的两个子树内，可以拆成两条路径且仍然保证合法。

记两个端点是祖孙关系的路径为一类路径，在一个点的两个不同子树内的路径为二类路径。借用上面那个题的思路，我们维护子树内的二类路径个数，并记下当前可以往上延申的一类路径个数（可能会有已经伸上去的，我们在那里打标记就好），然后记录当前一类路径伸到的最浅的深度。

本来根据 Intro 题目的结论可以知道向上的一类路径是越多越好的，但是因为在这里二类路径可以随时转成一类路径并且次数也比较小，那这里变成了子树内的二类路径越多越好。

继续沿用上面那个题的做法，从下往上考虑。先考虑一个结点合并两个子树。先处理掉一类路径往上到的最浅深度，然后记 $p$ 子树 $u$ 内一类路径有 $u_1$ 条，子树 $v$ 内一类路径有 $v_1$ 条，$u_2,v_2,p_1,p_2$ 同理。那么合并到当前点 $p$，按下面的流程处理：

- 先匹配两个子树内的一类路径，记 $c=\min(u_1,v_1)$，则 $p_2 \gets^+ c, u_1 \gets^- c,v_1 \gets^- c$（容易发现此时每匹配一个答案就小 $1$）；    
- 现在 $u_1,v_1$ 中一定有一个是 $0$，假设 $v_1$ 为 $0$，则考虑拆开 $v_2$ 中的路径与 $u_1$ 的两条匹配，匹配越多越好（每拆开一对并完全匹配答案小 $1$）；    
- 然后整不了花活，往上传。

接下来，如果当前一类路径延申不到 $p$ 结点需要的最浅深度 $d_p$，我们需要拉长路径或者拆开路径。采用这样的策略：

- 如果子树内最浅的一类路径比当前结点浅：直接把这条路径拉长到 $d_p$；   
- 否则，我们需要用之前的路径：
  - 如果有一类路径：拉长到 $d_p$；   
  - 如果没有一类路径，有二类路径：拆开，选择一条拉长到 $d_p$；     
  - 都没有：直接造一条拉到 $d_p$ 的路径。

局部正确性显然啊。

然后考虑拉到 $d$ 的路径怎么实现，在这个子树内留下一个标记数组表示有一条上端点在深度 $d$ 的个数就好，处理的时候只需要在满足 $d_p = d$ 的 $p$ 合并子树的时候加到 $p$ 上面。

接下来是直觉与丢失的证明，直觉有了就好了，基本是经验之谈。

剩下的事情就是模拟了。

```cpp
int f[200005],g[200005];
int spr[200005];
/*
 * f[u]: 向上（子树内）
 * g[u]: 横叉（子树内） // 这里口胡了，但是意思大概都懂啊。
 * spare[u]: 有一些必须被引到 up，这时候直到 up 才可以使用。 // 即标记数组
 */
void merge(int u,int v)
{
	f[v]+=spr[dep[u]],spr[dep[u]]=0;
	/*
	 * 挂到 dep[u] 的直向上的路径。
	 * 这么写的原因也比较清楚，这里要强调只在一个子树内。
	 */
	if(f[u]<f[v])	swap(f[u],f[v]),swap(g[u],g[v]);
	g[u]+=f[v],f[u]-=f[v];
	// 先把两个直向上的合起来吧。
	int c=min(f[u]>>1,g[v])<<1;
	f[u]-=c,g[u]+=g[v]+(c>>1);
	/*
	 * 然后要处理子树内的横叉。这个有点 hard 啊！
	 * 我可以把横叉拆成俩，然后往上传和向上的合并起来。
	 * 因为路径不会横叉所以可以拆 =.=。
	 */
	fup[u]=min(fup[u],fup[v]);
	// 最后记录向上到哪里。
}
void dfs2(int u,int p)
{
	for(auto v:G[u])
	{
		if(v==p)	continue;
		dfs2(v,u);
		merge(u,v);
	}
	if(fup[u]>up[u])
	{
		if(fup[u]>=dep[u])
		{
			if(f[u])	--f[u]; // 拉长一条向上的路径。
			else if(g[u])	++f[u],--g[u]; // 拆掉一条横叉。
			// 否则的话我们直接打个标记就好了，上面那些东西只是暂时离开，它们要到更浅的地方去。
		}
		else	--spr[fup[u]]; // 把之前打在 fup 的标记去掉，也就是把当前的深度 fup 拉到 up。
		fup[u]=up[u],++spr[up[u]];
	}
}
```

~~这个题是不是比雨兔的题简单多了~~，反正我这么觉得。[完整代码](https://www.luogu.com.cn/paste/lqalg9jx)。