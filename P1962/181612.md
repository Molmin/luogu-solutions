## 善用class

大家都知道是矩阵快速幂了，那么，算法的具体实现我就不说了。我是想借此说一下C++中的类是如何使用的。

类的一个重要功能就是运算符重载，这是一个非常方便的语法糖，让代码变得简洁易懂。我是一个“码不简洁死不休”的人，看到一大堆mult mult mult简直想吐，所以嘛，干脆来个class多省事。

### 一、矩阵类的代码

```cpp
class matrix
{
private:
    long long mmm[2][2];
    static const long long MOD = 1000000007LL;

public:
    explicit matrix(long long a = 1, long long b = 0, long long c = 0, long long d = 1)
    { // 构造函数，默认参数对应一个单位矩阵
        mmm[0][0] = a;
        mmm[0][1] = b;
        mmm[1][0] = c;
        mmm[1][1] = d;
    }

    inline long long get0_1() const
    { // 返回第0行1列的数，这正是斐波那契数列对应的项
        return mmm[0][1];
    }

    matrix& operator=(const matrix& m)
    { // 注意，二维数组不能直接赋值，所以要重载赋值运算符
        mmm[0][0] = m.mmm[0][0];
        mmm[0][1] = m.mmm[0][1];
        mmm[1][0] = m.mmm[1][0];
        mmm[1][1] = m.mmm[1][1];
        return *this;
    }

    matrix operator*(const matrix& m) const
    { // 这是最核心的部分，矩阵乘法
        matrix tmp;
        tmp.mmm[0][0] = (mmm[0][0] * m.mmm[0][0] + mmm[0][1] * m.mmm[1][0]) % MOD;
        tmp.mmm[0][1] = (mmm[0][0] * m.mmm[0][1] + mmm[0][1] * m.mmm[1][1]) % MOD;
        tmp.mmm[1][0] = (mmm[1][0] * m.mmm[0][0] + mmm[1][1] * m.mmm[1][0]) % MOD;
        tmp.mmm[1][1] = (mmm[1][0] * m.mmm[0][1] + mmm[1][1] * m.mmm[1][1]) % MOD;
        return tmp;
    }
};
```

### 二、详解

#### 1、构造函数matrix()

构造函数是用来创建一个对象的。它不是手动调用的，而是创建对象时自动调用的。它可以指定参数和操作。比如，我们上面的构造函数用四个参数来指定矩阵的四个元素。另外，它还有默认参数，也就是当不指定参数时，取默认值，比如创建一个矩阵matrix()，将返回一个单位矩阵。

#### 2、重载赋值运算符=

如果不重载赋值运算符，则赋值运算符将逐个复制类的非const成员。但是，我们这里类的成员是二维数组，不能直接赋值，所以必须重载赋值运算符，将二维数组的元素逐个复制。

#### 3、重载乘号运算符*

这是我们的重中之重。如果不重载，则编译器不认为matrix类可以做乘法运算。所以，这个重载是为了创建一种新运算使得编译器认识这个用法。

#### 4、返回值和参数的类型

首先来看传参。C++中传参有按值传递和按引用传递两种形式。按值传递，相当于用赋值运算符把实际参数的值赋值给形式参数，所以要隐式调用赋值运算符。如果这个类很大，则赋值运算符需要占用非常多的时间。而按引用传递则不同，是把原变量本身直接捆绑到形式参数上，不需要调用赋值运算符。因此，我们推荐，class类型的参数用引用传递，如果不需要修改参数的值，则用const引用。比如我们的赋值运算符和乘号重载都是用const引用传参。

再来看返回值类型。如果是需要返回一个新的对象，比如乘号，则需要返回类本身的类型，并且一定要返回一个新创建的对象，而不能返回参数对应的东西。因为参数是个引用，如果直接返回参数，则返回值和参数对应的变量是同一个，这会引发不可预知的问题。

如果是需要返回原变量的引用，比如赋值运算符，则直接返回引用，而不需要创建新对象。这样避免了新创建对象调用构造函数。赋值运算符是对变量本身的操作，不需要创建新对象。

另外，从C++11开始，还有所谓“复制构造函数”“移动构造函数”和“移动赋值运算符”的概念，但如果细讲，需要用一本书的内容，这里就从略了。如果想深入了解类设计时参数和返回值的类型选择，参考《C++ primer plus 第6版》第13章。

从这点看，因为要和C兼容，C++的类设计远比Java要繁琐。但Java不提供运算符重载也是不能忍啊！各有千秋，个人感觉如果是做面向对象设计，Java更合适。

#### 5、函数之后的const的作用

const有一种用法是指定变量不可更改，成为常量。另外，还可以追加在函数头之后，比如我们上面的乘号运算。这种用法，是告诉编译器，这个函数将不会修改类对象的任何内容。这样做的目的就是，使得类的const对象也可以调用这个函数。

如果不加const，则常量（类的const对象）不可调用这个函数。所以，像加减乘除，还有getter这类不对原变量进行修改的函数，一律在函数头的尾部添加const。但如果是需要修改原变量的，比如赋值运算符，则一律不能加const。

#### 6、快速幂函数的写法

有了重载运算符之后，我们就可以很简洁地写出power函数了：

```cpp
matrix power(const matrix& m, long long t)
{
    if (t <= 0) return matrix();
    if (t == 1) return m;
    matrix tmp = power(m, t >> 1);
    if (t & 1) return tmp * tmp * m;
    else return tmp * tmp;
}
```

主函数：

```cpp
int main()
{
    long long n;
    scanf("%lld", &n);
    printf("%lld", power(matrix(1, 1, 1, 0), n).get0_1());
    return 0;
}
```

非常简洁！