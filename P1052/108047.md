看了一下全部的题解，基本上为压缩路径和单调队列，花了一个上午的时间，终于想出了一种全题解都没的方法

首先**最暴力**的**DP**相信大家应该都没问题，记录一下走到每个点至少要踩几个石头，即：
```
f[i]=min(f[j]) {j|S=<i-j<=T}  (初中生不会集合啊，可能格式有问题）

```
而看到 { j | S <= i - j <= T } 这样一个区间，自然而然（~~千辛万苦~~）就会想到**单调队列**，但我们今天讲的并不是他，毕竟有很多题解详细的介绍了，我们今天来讲点不一样的

暴力为什么不行呢？先往下翻，看看数据规模，**L<=1e9** ，所以暴力不仅超时，而且连数组都开不了

再往下（~~也好像是上~~）翻就能感受到出题人的**友好**了

1 ≤ S ≤ T ≤ 10，1 ≤ M ≤ 100

这不明摆着让你对**石头进行DP**？

我们先来看一个结论：**如果青蛙跳到了X的位置，对于位置小于X的每一个石头，这块石头的位置为a[i],那么青蛙至少在a[i]、a[i+1]、a[i+2]、a[i+3]、......、a[i+T-1]的位置跳过一次。**

为什么呢？

因为青蛙一次只能跳**S~T之间的距离，那么在一段S~T之间的区间，青蛙不可能直接越过，肯定要在这区间中跳一次**

懂了吗？没懂自己拿笔画画就清楚了。

### 转移方程

那么知道这个性质后，而且S和T又那么小，我们就可以定义f数组了

**f[i][j]表示跳到了第i个石头后j个位置最少踩几个石头**

定义了f数组后，接下来就是解转移方程了

说实话，这转移方程有点繁琐，调试了一上午才A的

对于f[i][j]，肯定要从f[k][x]中转移过来，其中，**a[k]+x和a[i]+j之间的距离不能超过T，也同样不能少于S**，即：
```
f[i][j]=min(f[k][x]) (S<=a[i]+j-a[k]+x<=T)
```
同学们想想，这样做有什么漏洞（思考）？

是的，如果在前i-1个石头中找不到符合要求的k、i，f[i][j]就无法更新，就成了INF。换句话说，也就是如果第i个石头离前面的石头太远，**都大于T了**，也就无法更新了

再想想，如果两个石头间隔太远，那么也就意味着中间都是没有石头的（~~这不废话吗~~），**那么管它中间怎么走，都不会影响答案，而又因为青蛙是一定会跳到a[i]、a[i-1]、a[i-2]、...、a[i+T-1]之中的一个点，所以只要对a[i-1][j1]的每个状态判断能否跳到a[i][j2]，如果能，那么f[i][j2]=f[i-1][j1]**

听到这里你应该绕晕了吧？所以又怎么判断两个点间是否能走到呢？

一开始我的想法是背包，然后突然一想数据范围L<=1e9，写背包还不T飞。

遇到了困难，所以我就（~~放弃~~）询问了一下洛谷的大佬们%%%（~~虽然他们说的我都没用~~）

然后我就想到了小凯的数字，好像很可行，然后...

就想到了O（1）的

**设M为两点之间的距离，X=[M/R] * R ([ ]表示向上取整）**

**如果X-M<=[M/R] * (T-S)，就是可以到达的，否则不行**

为什么呢？

我们先假设我们都走最远的距离，看看要跳多少次，然后再把跳的次数 * （T-S）减掉，可以形象的理解为退步，**先跳T，再倒退T-S，也就是跳了S，T-(T-S)=S**,（这个都看不懂的话可以去小学二年级**回炉重造了**），那么**减去前和减去后的区间**，就是青蛙可以到达的区间，再看看**M是否在区间里**就好了（可以揣摩一下）

### 给初值

这个想通了，初值的问题就很轻松了

如果f[i][j] ，S<=a[i]+j<=T，那么f[i][j]=0

这样就好了吗？不不不

如果每一个石头都离起点非常非常远（~~其实只要大于10就好了~~），那么所有的值就都为INF了，转移方程怎么转都不会出结果的

那怎么做？

**因为青蛙是肯定会跳过a[i]、a[i-1]、a[i-2]、...、a[i+T-2]之中的一个点，所有我们只要给f[1][0]、f[1][1]、f[1][2]、...、f[1][T-2]赋初值就OK了**

所以怎么赋呢？

别急

因为**如果能从起点跳若干次而不踩任何石子跳到a[1]+j，那么f[1][j]就为0。而因为青蛙最少跳S，所以a[1]~a[1]+S-1都是从非石子的地方跳过来的，所以对于f[1][0]~f[1][S-1]的值，只要判断能否从起点跳过来，能就为0，不能就为INF，f[1][0]要特判，因为本身位子上有一个石子，所以要+1**。而怎么判断是否跳的到，刚刚不是讲过了吗？

### 统计答案

统计答案很简单，即：
```
if (a[i]+j>a[n]) Ans=min(Ans,f[i][j])
```
你可能会有一个疑问，为什么统计时是判断是否大于**a[n]**，而不是**L**呢？

有个显然的结论，**如果青蛙跳过了最后一颗石子，那么他再也不可能踩到石子了**，傻蛙才会倒着跳去踩石子，不过我们这只蛙是聪明的

所以只要**位置大于最后一颗石子a[n]**，不管他怎么跳都不会再影响答案了，即可以直接计算答案了

**假**完结撒花

### 注意事项

可能（**一定**）是我太**菜**了，调试上出了很多问题，每个点都花式WA过，这里给大家一一列出来方便查错

1. **排序、排序、排序**

题目没明说石子位置是否有序（也可能是我眼瞎），不过样例是升序，所以以为石子给出是呈升序的，但是数据给出却不然，所以**读进位置后果断sort一遍**

2. **计算重复的位置**

f[i][j]和f[k][x]看似互相独立，其实很容易有交集，所以在更新其中一个时，也要同时更新另一个，怎么更新呢？用**二分查找**，这里就不细说了

3. **Ans给初值**

调了半天才发现是**Ans没给初值**的悲伤相信你也不想有

4. **其他**

其他的错误相信只有我这个蒟蒻会犯，各位大佬不可能会犯的，就不说了（~~懒得打字~~）

最后贴上我无比丑陋的代码（因为边写边改，早已经面目全非了，可观性为0）

代码：
```
#include<bits/stdc++.h>
#define maxn 105
using namespace std;
int f[maxn][15],n,L,S,T,Ans,a[maxn],X,M;
inline int read(){
	int ret=0;char ch=getchar();
	while (ch<'0'||ch>'9') ch=getchar();
	while (ch<='9'&&ch>='0') ret=ret*10+ch-'0',ch=getchar();
	return ret;
}
inline int check(int id,int x){
	int L=id+1,R=n,mid;
	while (L<=R){
		mid=L+R>>1;
		if (x>=a[mid]){
			if (x==a[mid]) return mid;
			L=mid+1;
		}
		else R=mid-1;
	}
	return 0;
}
inline int dv(int a,int b){
	if (a%b) return a/b+1;
	return a/b;
}
int main(){
	L=read();
	S=read(),T=read(),n=read();
	for (int i=1;i<=n;i++) a[i]=read();
	sort(a+1,a+n+1);
    memset(f,63,sizeof f);int inf=f[0][0];
    for (int i=1;i<=n;i++)
    for (int j=0;j<T;j++){
    	if (a[i]+j>T) break;
    	if (a[i]+j>=S){
		    X=check(0,a[1]+j);
		    if (X) f[1][j]=1,f[a[1]+j][0]=1;
		    else f[1][j]=0;
		}
	}
	for (int j=0;j<S;j++)
	  if (a[1]+j>=S){
	  	M=a[1]+j;X=dv(M,T)*T;
		if (M>=X-dv(M,T)*(T-S)){
		    X=check(0,a[1]+j);
		    if (X) f[1][j]=1,f[X][0]=1;
		    else f[1][j]=0;
		}
      }
    for (int i=S;i<T;i++){
    	if (a[1]+i-S>=S){
    		for (int j=S;j<=T&&a[1]+i-j>=S;j++){
    			if (j==i) continue;
    			M=a[1]+i-j;X=dv(M,T)*T;
    			if (M>=X-dv(M,T)*(T-S)){f[1][i]=0,f[check(1,a[1]+i)][0]=0;break;}
			}
		}
	}
	Ans=inf;
	for (int i=1;i<=n;i++)
   	for (int j=0;j<T;j++){
      	if (a[i]+j>=S&&f[i][j]==inf){
      		for (int k=0;k<j&&j-k>=S;k++) if (j-k<=T) f[i][j]=min(f[i][j],f[i][k]);
            for (int k=i-1;k;k--)
            for (int x=T-1;x>=0&&a[k]+x+T>=a[i]+j;x--) if (a[i]+j-a[k]-x>=S) f[i][j]=min(f[i][j],f[k][x]);
            if (i>1) for (int k=0;k<T&&a[i-1]+k<=a[i]+j;k++){
              	M=a[i]+j-a[i-1]-k;X=dv(M,T)*T;
				if (M>=X-dv(M,T)*(T-S)) f[i][j]=min(f[i][j],f[i-1][k]);
			}
            if (check(i-1,a[i]+j)) f[i][j]++;
		}
	}
	for (int i=1;i<=n;i++)
	for (int j=0;j<T;j++) if (a[i]+j+T>a[n]) Ans=min(Ans,f[i][j]);
	printf("%d",Ans);
	return 0;
}
```

**真**完结撒花 ~