原文：[blog](http://zory.cf/2018-04/过河.html)

## Analysis
在题目讨论中，有人提到：10000 8 9 2 2528 5049 应该输出0，但一些题解是1
那么应该怎么解决呢？其实问题很简单：
%完之后，若果在步幅之内，加上2520即可。

好了面对没看过别的题解的同学，我重新讲讲这道题吧。

首先动态规划是显而易见的，但如果直接对庞大的DP，会T飞的，而对石头DP则难以实现。

那怎么办呢？虽然说s和t都是不固定的，但它们的范围都非常小，一种方案是状压，但代码复杂度较高，而且对新手不友好，按下不表。

其实，既然步数只有可能是1到10，那么由于题目根本不关心具体是怎么走过去的，甚至总步数都不关心，那么对于一段很长的距离，怎么走几乎是随便的。那么其实，无论s和t的取值是什么，对于1到10的最小公倍数2520（有的人会问怎么计算？把所有数字列出来，然后诸如4和8，就只取8，剩下7、8、9、10，那么因为10里面有2,8变成4，于是它们的乘积即2520了）
然后根据位置差，排序后压缩路径，用bool数组对点记录即可


## Code
```cpp
const int INF=0x3f3f3f3f;
int a[110],b[110],c[110];
int f[610000];
bool v[610000];
//****************主函数****************
int main()
{
	int l,s,t,m;scanf("%d%d%d%d",&l,&s,&t,&m);
	for(int i=1;i<=m;i++) scanf("%d",&a[i]);
	sort(a+1,a+1+m);
	for(int i=1;i<=m;i++)
	{
		b[i]=a[i]-a[i-1];
		int tmp=b[i]%2520;
		if(b[i]>=2520 and tmp<=t) tmp+=2520;//确保正确性
		c[i]=c[i-1]+tmp;
		v[ c[i] ]=1;
	}
	
	memset(f,63,sizeof(f));f[0]=0;
	
	int tmp=(l-a[m])%2520;
	if((l-a[m])>=2520 and tmp<=t) tmp+=2520;//确保正确性
	l=c[m]+tmp;
	
	int ans=INF;
	for(int i=1;i<=l+t-1;i++)
	{
		for(int p=s;p<=t;p++)
			if(i-p>=0) f[i]=min(f[i],f[i-p]+v[i]);
		if(i>=l) ans=min(ans,f[i]);
	}
	printf("%d",ans);
}
```

如果还有任何疑问，可前往我的网站评论区询问，希望对你有所帮助