
### 题意

定义对于一个括号串 $s$ 的值，为通过最小次数以下操作使 $s$ 平衡的操作次数。

- 选择一个子串，循环右移一位。
- 在任意一个位置插入一个任意括号。

求一个括号串的所有非空子串的值的和。

### 题解

一个串怎么做。

设这个串长度为 $l$，下标从 $0$ 开始。

我们的目标是平衡，把左括号看做 $-1$，把右括号看做 $1$，转化为：使和为 $0$，前缀和最小值 $\ge0$。

令 $s$ 表示括号串对应的 $1/-1$ 串。

为了减少讨论：如果前缀和最小值 $\ge 0$，只要在最后补上所需右括号即可。

首先，这个循环右移一格很奇怪，考虑它有什么用。

不难发现，中间不会变，只有最右边的一个括号会移到最左边。

-----------------------------------------------------

- 引理 $1$：若要进行循环右移操作，一定是选择 $[0,i](0<i<l,s_i=1)$，$i$ 为满足条件的最大编号。

	证明：

	这一操作过程中和保持不变，所以不造成影响。

	设操作区间为 $[l,r](r>l)$，前缀和数组 $p$ 发生的变化是：将 $[l,r-1]$ 这一段的值后移一位，并加上 $s_r$，并把 $p_l$ 赋值为 $p_{l-1}+s_r$。

	如果 $s_r=-1$：

	- 如果前缀和最小值在 $[l,r-1]$ 中，因为这一段的数都会减小，所以不能把最小值变大。
	- 如果最小值在右端点上，因为新数组的右端点的值不会发生改变，所以也不能把最小值变大。

	所以 $s_r=1$。
    
    而在这时：最小值不可能在右端点上，因为对于最小值位置 $g$，$s_g=-1$，否则定有 $p_{g-1}<p_g=p_{g-1}+s_g=p_{g-1}+1$。
    
    贪心考虑，为了使最小值尽量大，要让 $r-l$ 尽量大，而 $l$ 一定可以取到 $0$，$r$ 最大能取到 $s_r=1$ 的编号最大的点。
    
    
- 引理 $2$：加入一个左括号一定加在位置 $0$ 之前。

	证明：加入左括号可以看做后缀 $+1$，为了使最小值变大，加最左侧最优（变为全局加）。

定义有效循环右移操作为：操作区间包含全局前缀和最小值的位置的循环右移操作。

在左括号个数 $\ge$ 右括号个数时：
- 加入左括号（全局 $+1$），操作代价为 $2$（因为还要插入右括号使其平衡），并使最小值 $+1$。
  
- 有效循环右移，操作代价为 $1$，并使最小值 $+1$。
  
- 引理 $3$：左括号个数 $\ge$ 右括号个数时，可以通过循环右移操作使最小值 $=0$。
  
  证明：根据引理 $1$，操作右端点为最大的 $s_r=1$ 的位置，若最小值在其后，那么一定是最后一个（其后都是 $-1$），而这意味着左括号个数 $<$ 右括号个数时。

令 $\text{Min}$ 为前缀和最小值，$S_u(u\in\{1,-1\})$ 表示 $u$ 的出现次数 ，操作次数为 $-\text{Min}+S_{1}-S_{-1}$。

在左括号个数 $<$ 右括号个数时：
  
可以通过先在左侧加入左括号来转换为上一种情况。

加入后最小值一定 $\le0$，因为最后一位一定 $=0$。

操作次数为 $S_{-1}-S_{1}-(\text{Min}+S_{-1}-S_1)=-\text{Min}$。

-----------------------------------------------------


综上，操作次数为 $-\min(\text{Min},0)+\max(S_{1}-S_{-1},0)$。

暴力枚举所有区间，我们可以得到 $O(n^2)$ 代码：

```cpp
#define For(i_,l_,r_) for(int i_=(l_);i_<=(r_);i_++)
int ans=0;//ans表示答案.
For(i,1,n){
	int s=0,gg=0;
	For(j,i,n){
		gg+=(tt[j]=='('?1:-1);//tt 是读入的字符串。
		s=min(s,gg);
		ans+=-s+max(gg,0ll);
	}
}
```

考虑把答案分成两部分计算：

称 $S_{l,r}$ 表示 $\sum_{i=l}^rs_i$。

1. $-\min(\text{Min},0)$。

	下称一个区间 $[l,r]$ 的答案 $ans_{l,r}$ 为，这个区间 $-\min(\text{Min},0)$ 的值。
	
    枚举一个子串左端点 $i$ 统计答案。
    
    不难发现，对于 $j(i\le j\le n)$，$ans_{i,j}$ 一定是单调不升的。
    
    并且 $ans_{i,j}>ans_{i,j+1}(i\le j<n)$，当且仅当 $S_{i,j+1}<\min\{S_{i,k}|(i\le k\le j)\}$。
    
    所以可以通过单调栈来维护这一不升序列。
    
    不过有对 $0$ 取 $\min$ 这一操作，但也不难。
    
    我们可以对原串进行单调栈，在每一个位置，二分出第一个 $S_{1,j}-S_{1,i-1}<0 \to S_{1,j}<S_{1,i-1}$ 的位置 $j$，此时只需统计 $j$ 及其后面的部分。
    
    代码：
    
    ```cpp
    #define Rep(i_,l_,r_) for(int i_=(l_);i_>=(r_);i_--)
    Rep(i,n,1){
        while(tp&&p[i]<p[st[tp]])--tp;
        // val[i] 表示 ans 相等的所有区间的 ans 之和。
        if(!tp)val[i]=(n-i+1)*p[i];
        else val[i]=(st[tp]-i)*p[i];
        st[++tp]=i;Now[tp]=Now[tp-1]+val[i];ttt[tp]=p[i];
        int pl=lower_bound(ttt+1,ttt+1+tp,p[i-1])-ttt-1;
        ff[i]=-Now[pl]+p[i-1]*(n-(st[pl]?st[pl]-1:n));
        // ff[i] 表示当前位答案。
    }
    ```
    
2. $\max(S_{1}-S_{-1},0)$

	下称一个区间 $[l,r]$ 的答案 $ans_{l,r}$ 为，这个区间 $\max(S_{1}-S_{-1},0)$ 的值。
    
    不难发现，$ans_{l,r}=\max(S_{l,r},0)$。
    
    我们从大到小枚举 $I(-n\le I\le n)$，计算 $S_{1,i}=-I$ 的左端点 $i+1$ 的答案。
    
    因为枚举了 $I$，每次 $I\leftarrow I-1$ 只要维护当前恰好等于 $0$ 的点。
    
    具体的，我们先把 $S_{1,i}(1\le i\le n)$ 都 $+\text{Min}$，然后把每次等于 $0$ 的扔到 `std::vector` 里。
    
    讲的不是很清楚，可以看代码：
    
    ```cpp
    #define For(i_,l_,r_) for(int i_=(l_);i_<=(r_);i_++)
    #define Rep(i_,l_,r_) for(int i_=(l_);i_>=(r_);i_--)
    GG[n].push_back(0);
    For(i,1,n)p[i]=p[i-1]+(tt[i]=='('?1:-1),GG[p[i]+n].push_back(i);
    int ri=min_(p+1,p+1+n);// 区间取 min。
    int res=0,C=0;
    For(i,1,n)res+=p[i]+max(-ri,0ll),t.add(i,p[i]+max(-ri,0ll));
    Rep(i,max(-ri,0ll),-n){
        for(int U:GG[-i+n])f[U+1]=t.Q(U+1,n)-(C*(n-U-t2.Q(U+1,n))+t1.Q(U+1,n));
        for(int U:GG[-i+n])if(U)t1.add(U,C),t2.add(U,1);
        ++C;
    }
    ```
    
    
