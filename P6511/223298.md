泥萌的柿子为什么辣么长辣么麻烦。

让我来带你大力找规律。

观察一下给出的式子，我们很快能想到一个 $\mathcal{O}(N)$做法，每当一个 $i$ 出现时，保证第一个式子成立，则 $j=n-i$，关于 $n$ 的式子比关于 $m$ 的式子简单，所以我们开始打关于 $n$ 的表。也就是打出对于每一个符合 $i+j=n$ 的 $i,j$，它的第二个式子的值是多少。最后对出现的值的数量进行统计即可。

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
using namespace std;
int n,vis[100010],ans,j;
int main()
{
    freopen("out.txt","w",stdout);
    scanf("%d",&n);
    puts("ans");
    for(int i=1;i<n;i++) //i=0或j=0都会使第二个式子出错
    {
        j=n-i; 
        ans=i/j+j/i+( j%i==0 ? 0 : 1);
        printf("%d=%d\n",i,ans);//算出对应的m 
        vis[ans]++;
    }
    puts("vis");
    for(int i=1;i<=n;i++)
        printf("%d: %d\n",i,vis[i]);//记录出每一个值出现的次数 
    fclose(stdout);
    return 0;
}
```
当你输入一个小 $N$ 观察无果时，你决定输入一个比较大的 $N$ ，想了想，输入了一个 $1000$。

你把 out.txt 使劲往下拉，发现在 $vis$ 后半部分全是 $0$。这是为什么呢？

你从后往前找，发现 $vis_{1000},vis_{999}$ 为 $1$ ，再往前就是 $vis_{500}=vis_{499}=1$，再往前是 $vis_{250}=vis_{249}=1$。诶等等，你心里默念着，$1000,500,250....$，这些不都是 $N=1000$ 的因子吗。如果一个数 $x$ 会被 $N$ 整除，那么 $x$ 以及 $x-1$ 都会加 $1$。

可是你刚才发现，$vis_{333}=2$，这是为什么呢。重新把刚才找到的数画在纸上，$1000/1000=1,1000/500=2.1000/250=4$，等等，中间有个 $3$ 在哪里？你回过头看 $333$，发现一个 $\lfloor\frac{1000}{3}\rfloor$ 恰好为 $333$,虽然 $333$ 不是 $1000$ 的因子，但是因为 $1000$ 整除一个数恰好为 $333$，所以 $vis_{333}=2$。

结合之前找到的，你想到了这样一个规律：对于一个 $x$，若 $N$ 能整除 $x$ ，则 $vis_{N/x}$ 和 $vis_{N/x-1}$ 都 $+1$。否则 $vis_{N/x}+2$。

向上翻你找到了 $vis_{27}=4$，你想了想发现，对于 $x=36,37$，都会使得 $vis_{27}+2$。继续向上到 $1$ ，你的规律对于 $vis$ 数组完全够用。

可是我们总不能枚举所有的 $x$ 求出全部的 $m$ 对应的答案啊。题目中已经给出了 $m$ ，我们可以反过来通过 $m$ 推出有多少个 $x$ 满足上面的规律。

显然对于 $m$ ，最小的 $x$ 为 $N/m$。我们同样知道对于 $m+1$，最小的 $x$ 为 $N/(m+1)$，则 $m+1$ 的最小的 $x$ 再往前一个就是对于 $m$ 最大的 $x$ 了。

我们可以求出推出对于 $m$ 所对应的所有符合条件的 $x$。最小的 $x1=N/m$，最大的 $x2=N/(m+1)$，$x1$ 和 $x2$ 中间的所有 $x$ 一定会给答案贡献 $2$。再特判 $N \bmod m,N \bmod (m+1)$，看最小/大的 $x$ 对答案的贡献是 $1$ 还是 $2$ 即可。

## $\mathcal{Code} :$

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
using namespace std;
int T,n,m,ans;
int main()
{
	scanf("%d",&T);
	while(T--)
	{
		scanf("%d%d",&n,&m);
		if(m==1||m>n) puts("0");
		else {
			int x1,x2,ans=0;
			x1=n/m;
			if(n%m==0) {
				ans++;
				x1--;
			}
			x2=n/(m+1);
			if(n%(m+1)==0)
				ans++;
			ans+=(x1-x2)*2;
			printf("%d\n",ans);
		}
	}
}
```
