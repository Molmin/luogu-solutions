### 题意
在数轴上原点的右边有 $n$ 块石头（从小到大给出），每块石头上有一个动点。  

它们需要执行如下操作 $m$ 次：

- 移动到距离该点第 $k$ 近的石头，如果有多个，选择那个更小的。

你需要求出最后每个点在第几块石头。
### 思路
先进行预处理，预处理从每块石头上的点操作后的位置。

显然这是个尺取法模型。相邻的两点距离前 $k$ 小的点集很接近，所以可以用双指针维护每个点距离前 $k$ 小的连续区间，并求出所有点距离第 $k$ 小点。

由于 $k$ 固定，可以使用一个类似滑动窗口的单调队列实现，因为离远点距离单调不减所以可以维护一个长为 $k+1$ 的单调队列。

然后用倍增处理每个点进行 $m$ 次操作之后达到的点。

考虑将 $m$ 二进制分解来跳，用倍增得到从一个点跳 $1<<i$ 次到的点实现。因为倍增过程顺序枚举 $i$ 所以只有相邻两个倍增数组有用，所以可以开滚动数组解决空间问题。
### 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
int n,k,m,l,r,a[100001],f[100001],ff[100001],ans[100001];
signed main(){
	cin>>n>>k>>m;
	for (int i=1;i<=n;i++) cin>>a[i];
	f[1]=k+1,l=1,r=k+1;
	for (int i=2;i<=n;i++){
		while (r+1<=n&&a[i]-a[l]>a[r+1]-a[i]) l++,r++;
		a[i]-a[l]>=a[r]-a[i]?f[i]=l:f[i]=r;
	}
	for (int i=1;i<=n;i++) ans[i]=i;
	while (m){
		if (m%2==1) for (int i=1;i<=n;i++) ans[i]=f[ans[i]];
		m/=2;
		for (int i=1;i<=n;i++) ff[i]=f[i];
		for (int i=1;i<=n;i++) f[i]=ff[ff[i]];
	}
	for (int i=1;i<=n;i++) cout<<ans[i]<<' ';
	return 0;
}
```
