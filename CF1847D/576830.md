给一种不同于官解的做法。

题目要求字典序最大，那么 $t(s)$ 最前面的 1 应尽可能多。考虑给每个数一个排名，排名越靠前代表我们把它变为 1 的优先级越大。记录当前字符串 $s$ 中 1 的个数 $k$，那么只要将排名在 $1-k$ 之间的数全部变为 1，最终的字符串字典序就一定是最大的。

可以暴力地用 set 维护当前还没有排名的节点，对于每个区间，我们不断地在集合中二分出最小的 $\ge l_i$ 的点，如果它越过了右端点说明所有区间内的节点已经有排名了，进行下一个区间的操作；否则将计数器加一，给它赋上排名并将它从集合中删除。

这样就将所有操作挂到了排名中连续的一段上。然后不难发现求将前缀变为 1 的最小步数等于这个前缀中 0 的个数，那么随便用个数据结构维护一下就做完了。

时间复杂度：$O((n+q)\log n)$，比官解慢一点，但是思路应该比较一眼。

[代码](https://codeforces.com/contest/1847/submission/212414858)