## 题目描述
由题可知，有三种情况，分别如下：
- 选择一个区间 $[l, r]$，将下标在这个区间里的所有数都减 $1$。

- 选择一个区间 $[l, r]$，将下标在这个区间里且下标为奇数的所有数都减 $1$。

- 选择一个区间 $[l, r]$，将下标在这个区间里且下标为偶数的所有数都减 $1$。

我们可以认为第一种情况是一类情况，属于对区间内连续的数减 $1$ ；第二三种情况是另一类情况，两种情况都是对间隔一个单位的数减 $1$ 。

后面的讲述中，我们用“**连续线**”表示对第一种情况的称呼；“**间隔线**”表示对第二种情况的称呼。


------------

## 题目分析

### 第一部分（局部解）

首先假设题目只有“连续线”的情况。那么这道题就是一道广为人知的题目。

[P5019铺设道路](https://www.luogu.com.cn/problem/P5019)

上面的题就是这篇题解所讲的题的只有“连续线”的解法。

这种情况下我们的解如下：

$$
ans=\sum_{i=2 \wedge a_i > a_{i - 1}}^{n}{(a_i - a_{i - 1})}
$$

证明如下（可能有瑕疵，欢迎指正）：

先确立一个原则，当我们选择一个区间 $[l, r]$ 进行操作时，如果 $a_{l-1}$ 或 $a_{r+1}$ 大于零，那么我们这次操作会把 $a_{l-1}$ 或 $a_{r+1}$ 也选上。我们最后所得到的目标是序列中所有数为零，之所以选上的方案肯定优于不选的方案，是因为我们选上会更接近于目标（贪心原则）。

换种方式说，我们之前做过一些操作，可以向**相邻**的数转移，以此得到更优解。一定要注意**只能**转移给相邻的数！

**转移**的解释：我们在处理某个元素 $a_i$ 时，用了一条“连续线”，而这条连续线，可能会对后面的元素处理有所帮助，这就是**转移**的意思，可以理解为前人给后人留下的遗产，根据贪心原则，后人能够继承遗产，那就一定全部继承。

一、假设序列 $a_n$ 中只有两个元素，即 $n=2$ 。
1. 若 $a_1<a_2$ ，那么答案必定是 $a_1+(a_2-a_1)=a_2$ ，表示我们先对区间 $[1,2 ]$ 进行 $a_1$ 次操作，再对剩下的 $a_2$ 进行 $a_2-a_1$ 次操作。
2. 若 $a_1>a_2$ ，那么答案必定是 $a_2+(a_1-a_2)=a_1$ ，表示我们先对区间 $[1, 2]$ 进行 $a_2$ 次操作，再对剩下的 $a_1$ 进行 $a_1-a_2$ 次操作。

二、假设序列 $a_n$中元素个数大于 $2$ ，但是序列具有非严格单调性（这是对上面两种情况的拓展）。
1. 若序列单调递增，那么答案显然是最大的元素 $a_n$。答案改变了。
2. 若序列单调递减，那么答案显然是最大的元素 $a_1$。答案未改变。

如果我们再单调递增的序列后面加一个元素比 $a_n$ 小，影响了序列单调性。

如果我们再单调递减的序列后面加一个元素比 $a_n$ 大，影响了序列单调性。

那我们得到下两张图：

![](https://cdn.luogu.com.cn/upload/image_hosting/6ss66fvn.png)

红色表示我们已经用“连续线”覆盖的部分，图一根据我们的贪心原则，所以单调递增序列后添加的元素可以被先前的操作覆盖，也就是继承先人的遗产。

而我们图二由于 $a_n<a_{n+1}$ ，先前的操作只有 $a_n$ 条“连续线”可以向后转移。所以我们还需要再添加 $a_{n+1}-a_n$ 条“连续线”以用来完全覆盖 $a_{n+1}$。

综上：只有序列中存在 $a_{i-1}<a_i$ ，$i\in[1, n]$ ，默认 $a_0=0$ ，答案才会有所增加，其增加量为 $a_i-a_{i-1}$ ，得到了最开始的解的公式。


------------
### 第二部分（正解）
第一部分我们只考虑了“连续线”，但是题目中还有“间隔线”的存在，于是就会让这个问题发生很大的变化。

“连续线”和第一部分一样，满足贪心原则，“间隔线”由于具体分为两种类型，奇偶性有差异，由于“间隔线”的存在，我们的转移情况也不仅仅是单一的只能向相邻数转移了，还有间隔转移情况。

在第一部分中，之所以序列中存在 $a_{i-1}<a_i$ ，$i\in[1, n]$ ,答案才会有所增加，是因为我们前面处理 $a_{i-1}$ 时，已经花费了 $a_{i-1}$ 条“连续线”为代价，而根据我们的贪心原则， $a_{i-1}$ 条“连续线”可以转移，如果 $a_{i-1}<a_i$ 则需要再花费一些“连续线”，否则将不用花费。

**重点**：很显然，当序列单独考虑某两个相邻元素时，我们的处理方式是和第一部分有类似操作，即在我们要先用两个元素的较小值个“连续线”，再考虑使用两元素差值个“连续线”还是“跳跃线”。

所以我们用相似的思路，来记录“连续线”和“间隔线”能够转移的情况。


------------

我们令 $S_n$ 表示前面为 $a_{n+1}$ 留下的“连续线”遗产，令 $J_n$ 表示前面为 $a_{n+1}$ 留下的“间隔线”遗产。

以下我们都会遵循贪心原则，将 $S_n,J_n$ 能够向后转移，后人继承所有遗产。

首先我们还没处理任何元素时，很明显 $S_1=0,J_1=0$ 因为我们没有做出任何的操作，固然就没有任何能够转移的“连续线”或“间隔线”遗产（也可以理解为 $a_0=0$ 或 没有 $a_0$ 这个元素）。

假设我们当前正在处理到 $a_i$ ，得到了 $a_{i-1}$ 为 $a_{i+1}$ 留下的遗产 $S_i,J_i$，其中 $[1,i-1]$ 的数都继承了遗产并且都变为了 $0$ ， $a_i$ 继承了遗产但不一定变成了 $0$ ，分如下情况讨论：

**注意**：以上处理和变为 $0$ 是两种不同的意思，处理表达的是，$a_i$ 这个数已经继承了前面所有的遗产，至于这个遗产是多了还是少了，我们暂且不关心。处理的目的是使 $a_i$ 变成 $0$ 。这时 $a_i$ 与 $a_{i+1}$ 的大小并不会影响 $a_{i+1}$ 遗产继承情况，$S_i$ 都能转移到 $a_{i+1}$ ，即遗产能全部被继承。接下来讨论遗产继承情况：

令 $R=S_i+J_i-a_{i+1}$ ，分情况如下:

1. $R<0$ ，即表示之前留下的遗产不够我们使用，我们将 $a_{i+1}$ 减去 $(S_i+J_i)$ ，表示 $a_{i+1}$ 继承了所有遗产，但是这时一定满足 $a_{i+1}>0$ ，由于 $a_i$ 已经继承过遗产，现在 $a_{i+1}$ 也继承了。为了后面我们遗产能够传递一下去，答案问题转换为了求当前 $a_i,a_{i+1}$ 会对 $S_{i+1},J_{i+1},ans$ 等变量的影响。

- 首先，考虑**答案**变化，答案必然要加上 $a_i$ 因为我们的目的是将 $a_i$ 变成 $0$ ，无论如何都要使用这么多条线。

- 其次，考虑**两个线**“连续线”，“间隔线”变化，注意在第二部分开始标“重点”的地方， $S_{i+1}$ 一定要加上两元素最小值。再强调我们的目的是将 $a_i$ 变成 $0$ ，所以我们元素 $a_i$ 如果是较小值，那么 $J_{i+1}=0$ ,否则， $J_{i+1}=a_{i+1}-a_i$，简化表达就是 $J_{i+1}=a_i-\min(a_i,a_i+1)$ ，这样子我们就是将所有需要为 $a_i$ 使用的线都用“间隔线”。这样做的原因是，只有 $a_i<a_{i+1}$ 时会再用线条，而这时我们用“连续线”实际上无法为后面留下任何遗产，所以我们考虑使用间隔线，这样才有希望留下遗产。

2. $R>0$ ，即表示之前留下的遗产过多了，我们用完后还有剩余，这个情况实际上时属于特殊情况，我们处理方式也和第一种情况一样，只不过我们需要特殊处理：只需要先将“连续线”和“间隔线”一共减少 $R$ 条，如何减少，不会对后面结果造成影响，因为当前 $S_i,J_i$ 都是为 $a_{i+1}$ 特别准备的遗产，也就是说遗产只属于它，只要总数不变，不会对整个结果造成任何影响。但是我们减少的线条，如何分配？这个问题也很简单，我们再进行完一系列操作之后，把这个减少的条数 $R$ ，再加回 $a_{i+1}$ 就可以了，用来为我们后续的操作备用，而且我们还需要把答案减去这个减少的条数 $R$ ，因为我们实际上是多进行了这么多次条数，但实际上我们不需要做这些操作，所以减去 $R$ 。

------------
## 代码公示
```cpp
#include<bits/stdc++.h>
#define ll long long 
#define inf 1e9
#define rep(i,l,r) for(register int i=l;i<=r;++i)
#define per(i,r,l) for(register int i=r;i>=l;--i)
using namespace std;
const int N=1e5+10;

int n;
ll a[N];
ll ans;
inline void solve(){
	ans=0;
	scanf("%d",&n);
	rep(i,1,n)scanf("%lld",&a[i]);
	a[n+1]=0;
	ll LinS=0,LinJ=0,NxtJ=0,LinM=0;//连续线 间隔线 下一个间隔线 多余的遗产 
	rep(i,1,n){
		ll LinR=LinS+LinJ-a[i+1];//多余的遗产 
		if(LinR>0){//如果有多余遗产，考虑存储并改变连续线 间隔线 数量 
			if(LinS<LinR)LinJ=LinJ+LinS-LinR,LinR=LinS;
			if(LinJ<LinR)LinS=LinS+LinJ-LinR,LinR=LinJ;
			LinS-=LinR,LinJ-=LinR,a[i+1]-=LinR,LinM=LinR;
			//为了方便连续线和间隔线一共减少2R个，a[i+1]减去R就可以了，本质上一样 
		}
		a[i+1]-=LinS+LinJ;//吸收遗产 
		ans+=a[i];//将a[i]变成0的代价 
		ll LinN=min(a[i],a[i+1]);//较小值 
		LinS+=LinN;//连续线数目加上较小值 
		a[i]-=LinN,a[i+1]-=LinN;//吸收最后的代价 
		NxtJ+=a[i];//将a[i]变成0 为后代留下a[i]条间隔线遗产 
		a[i+1]+=LinM,ans-=LinM,LinM=0;//如果存在多余的遗产的操作 
		swap(LinJ,NxtJ);//交换两种性质的间隔线类型，为后面分配遗产做准备 
	}
	printf("%lld\n",ans);
}
int main(){
	int T;
	scanf("%d",&T);
	while (T--)solve();
	return 0;
}
```
