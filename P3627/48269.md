【参考资料】

liusu201601的博客 - bzoj1179: [Apio2009]Atm（强联通+最短路）： https://blog.csdn.net/liusu201601/article/details/79234724

百度百科 - 强连通分量： https://baike.baidu.com/item/%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F/7448759?fr=aladdin

【题目描述】

Siruseri 城中的道路都是单向的。不同的道路由路口连接。按照法律的规定， 在每个路口都设立了一个 Siruseri 银行的 ATM 取款机。令人奇怪的是，Siruseri 的酒吧也都设在路口，虽然并不是每个路口都设有酒吧。

Banditji 计划实施 Siruseri 有史以来最惊天动地的 ATM 抢劫。他将从市中心 出发，沿着单向道路行驶，抢劫所有他途径的 ATM 机，最终他将在一个酒吧庆 祝他的胜利。

使用高超的黑客技术，他获知了每个 ATM 机中可以掠取的现金数额。他希 望你帮助他计算从市中心出发最后到达某个酒吧时最多能抢劫的现金总数。他可 以经过同一路口或道路任意多次。但只要他抢劫过某个 ATM 机后，该 ATM 机 里面就不会再有钱了。 例如，假设该城中有 6 个路口，道路的连接情况如下图所示：

![](https://cdn.luogu.com.cn/upload/pic/4396.png)

市中心在路口 1，由一个入口符号→来标识，那些有酒吧的路口用双圈来表

示。每个 ATM 机中可取的钱数标在了路口的上方。在这个例子中，Banditji 能抢 劫的现金总数为 47，实施的抢劫路线是：1-2-4-1-2-3-5。

【输入输出格式】

- 输入格式

第一行包含两个整数 $N$、$M$。$N$ 表示路口的个数，$M$ 表示道路条数。接下来 $M$ 行，每行两个整数，这两个整数都在 $1$ 到 $N$ 之间，第 $i+1$ 行的两个整数表示第 $i$ 条道路的起点和终点的路口编号。接下来 $N$ 行，每行一个整数，按顺序表示每 个路口处的 ATM 机中的钱数。接下来一行包含两个整数 $S$、$P$，$S$ 表示市中心的 编号，也就是出发的路口。$P$ 表示酒吧数目。接下来的一行中有 $P$ 个整数，表示 $P$ 个有酒吧的路口的编号。

- 输出格式

输出一个整数，表示 Banditji 从市中心开始到某个酒吧结束所能抢劫的最多 的现金总数。

【输入输出样例】

- 输入样例
```
6 7 
1 2 
2 3 
3 5 
2 4 
4 1 
2 6 
6 5 
10 
12 
8 
16 
1 
5 
1 4 
4 3 5 6
```
- 输出样例
```
47
```

【数据范围】

$50\%$的输入保证 $N, M \leq 3000$。

所有的输入保证 $N, M \leq 500000$。每个 ATM 机中可取的钱数为一个非负整数且不超过 $4000$。

输入数据保证你可以从市中心 沿着 Siruseri 的单向的道路到达其中的至少一个酒吧。

这是一道强连通的题目，什么是强连通？不妨看一下下面的教程。

现在我们有一张$n$个点$m$条边的**有向图**，如下。

![](https://cdn.luogu.com.cn/upload/pic/16684.png)

上图中，有三个强联通分量。分别是[1]、[5]以及[2,3,4,6]。

什么是强连通分量？不妨看一下下面的这段话。

- **强连通图的定义**

> 有向图强连通分量：在有向图$G$中，如果两个顶点$v_i,v_j$间（$v_i>v_j$）有一条从$v_i$到$v_j$的有向路径，同时还有一条从$v_j$到$v_i$的有向路径，则称两个顶点强连通(strongly connected)。如果有向图$G$的每两个顶点都强连通，称$G$是一个强连通图。有向图的极大强连通子图，称为强连通分量(strongly connected components)。

那么怎么找到这张图中有多少个强连通分量呢？下面我将模拟一次强连通的过程，不会的同学可以认真地看一下整个过程。

我们定义每个点有$2$个参数，一个是时间戳，我用字母 $i$（很多题解用$dfn$），一个是自己团的老大，我用字母$d$（很多题解用$low$）。接下来图中每个点的周围会有两个数字，分别代表$i$和$d$。还有我们用一个栈来存储新加入的点，当这个点搜完了所有和它与之相邻的点的话就将其出栈。我们先从$1$号点开始询问一直直到$n$号点，每次询问问$i$号点是否有时间戳。若没有的话就从第$i$号点开始搜（$i \in [1,n]$）。现在我们先访问$1$号点，并给出$1$号点一个时间戳和他的老大（一开始的时候他的老大是它自己），如下图。

![](https://cdn.luogu.com.cn/upload/pic/16689.png)

现在$1$号点已经入栈了，接着，我们从$1$号点开始进行深搜，我在这里省略了一些中间的过程，大家如果对此感兴趣的话可以自己模拟一下，结果如下图，注意，搜的顺序是按边的输入顺序来定义的，例如有``1 2``、``1 3``、``3 2``这三条边，若我们从$1$号点开始进行深搜的话，那么优先搜$3$号点。同理，如果我们从$3$号点开始进行深搜的话，那么优先搜索的就是$2$号点，学过最短路的同学应该都有所了解，搜索几次之后的结果如下图。

![](https://cdn.luogu.com.cn/upload/pic/16690.png)

现在栈的情况为[1,2,3,4,5]。现在搜到了$5$号点，由于$5$号点现在没得搜索了，所以将$5$号点弹出栈，并且由于$5$号点的时间戳等于它的老大，那么它就是这个团体中的老大，也即：

- **如果一个点在回溯时它的时间戳等于它的老大，那么它就是这个团体中的老大，并将团体中的所有点出栈。**

现在栈的情况为[1,2,3,4]。现在，$4$号点搜索到了$6$号点，发现$6$号点还没有时间戳和老大。于是我们更新$6$号点的老大以及时间戳，同时我们还要将$6$号点加入栈内，如下图。

![](https://cdn.luogu.com.cn/upload/pic/16692.png)

现在栈内的情况为[1,2,3,6]。

现在我们从$6$号点开始扩展它周围的点啦~

现在我们搜到了$2$号点。由于$2$号点现在在栈内，那么$2$号点的时间戳小于$6$号点的老大，那么$2$号点可能就是$6$号点的最终的老大，也即：

- **若当前所在的点为$x$号点，当前扩展到的点为$y$号点，那么如果$a[y].i<a[x].d$，那么就用$a[y].i$来更新$a[x].d$。**

更新后如下图。

![](https://cdn.luogu.com.cn/upload/pic/16697.png)

现在从$6$号点回溯到了$4$号点，发现$6$号点的老大小于$4$号点的老大所以将$4$号点的老大改为$2$，也即：

- **如果$y$点已经搜完了它周围的点，回溯到了$x$号点时，发现$y$号点的老大比$x$号点的老大要小，就用$y$号点的老大来更新$x$号点的老大。**

修改后的结果如下图。

![](https://cdn.luogu.com.cn/upload/pic/16718.png)

现在，$4$号点已经完成了任务，回溯到了$3$号点。因为$4$号点的老大比$3$号点的老大要小，所以便用$4$号点的老大来更新$3$号点的老大，修改后的结果如下图。

![](https://cdn.luogu.com.cn/upload/pic/16719.png)

现在，$2$号点也搜索完了周围的点，准备回溯，但是由于$2$号点的时间戳等于他的老大，那么就表明$2$号点是现在这个强连通分量（团队）中的老大，也即：

- **如有$x$号点的时间戳等于他的老大，那么就表明$x$号点是现在这个强连通分量（团队）中的老大。**

从$2$号点回溯到$1$号点后，因为$1$号点的时间戳等于他的老大，所以$1$号点是现在这个强连通分量（团队）中的老大。

模拟完毕~

【题目大意】

在有向图里，可以绕圈的情况下，取尽可能大的值。然后要求在有酒吧的点里尽可能大。

【题解】

通过题目我们可以想到强联通，我们可以算出每个强联通分量（联通块）内可以获得的最优解，并由此可以想到用**最长路**来解决这个问题，注意，是最长路哦。由于在一个强联通分量的点都可以互相到达，所以我们可以先**缩点**（也即将一个强联通分量视为一个点）再跑一次最长路，最后再扫一次有酒吧的点即可，因为我在代码里的点和边的结构体都有重复应用，所以要记得先清零，还有一点要注意的是是将团体连边，不是让点于点之间连边哦~

下面上AC代码~
```
#include <cstdio>
int f[2000001],chu[2000001],bb[2000001],l[2000001];
struct nodea{ int h,i,b,v,d; } a[5000001];
struct nodeb{ int x,y,gg; } b[5000001];
int len=0,tou=0,lx=0,lb=0,n=0,m=0,st=0,p=0;
void ins(int x,int y)
{
	len++;
	b[len].x=x;
	b[len].y=y;
	b[len].gg=a[x].h;
	a[x].h=len;
}
void dfs(int x)
{
	l[++tou]=x;
	a[x].i=++lx;
	a[x].d=lx;
	a[x].v=1;
	for(int i=a[x].h;i>0;i=b[i].gg)
	{
		int y=b[i].y;
		if(a[y].i==0)
		{
			dfs(y);
			if(a[y].d<a[x].d)
			{
				a[x].d=a[y].d;
			}
		}
		else if(a[y].v==1)
		{
			if(a[y].i<a[x].d)
			{
				a[x].d=a[y].i;
			}
		}
	}
	if(a[x].i==a[x].d)
	{
		lb++;
		while(true)
		{
			int k=l[tou--];
			a[k].v=0;
			a[k].b=lb;
			if(k==x)
			{
				break;
			}
		}
	}
}
void spfa()
{
	int tou=1,wei=2;
	f[1]=st;
	a[st].v=1;
	a[st].d=bb[st];
	while(tou!=wei)
	{
		int x=f[tou];
		for(int i=a[x].h;i>0;i=b[i].gg)
		{
			int y=b[i].y;
			if(a[y].d<a[x].d+bb[y])
			{
				a[y].d=a[x].d+bb[y];
				if(a[y].v==0)
				{
					a[y].v=1;
					f[wei]=y;
					wei++;
					if(wei>lb)
					{
						wei=1;
					}
				}
			}
		}
		a[x].v=0;
		tou++;
		if(tou>lb)
		{
			tou=1;
		}
	}
}
int main()
{
	scanf("%d %d",&n,&m);
	for(int i=1;i<=m;i++)
	{
		int x=0,y=0;
		scanf("%d %d",&x,&y);
		ins(x,y);
	}
	for(int i=1;i<=n;i++)
	{
		if(a[i].i==0)
		{
			dfs(i);
		}
	}
	int td=0;
	for(int i=1;i<=n;i++)
	{
		a[i].h=0;
		a[i].v=0;
		a[i].d=0;
		scanf("%d",&td);
		bb[a[i].b]+=td;
	}
	scanf("%d %d",&st,&p);
	int now=len;
	len=0;
	for(int i=1;i<=now;i++)
	{
		int x=b[i].x;
		int y=b[i].y;
		if(a[x].b!=a[y].b)
		{
			ins(a[x].b,a[y].b);
		}
	}
	st=a[st].b;
	spfa();
	int ans=0;
	int tx=0;
	for(int i=1;i<=p;i++)
	{
		scanf("%d",&tx);
		if(ans<a[a[tx].b].d)
		{
			ans=a[a[tx].b].d;
		}
	}
	printf("%d",ans);
	return 0;
}
```