这种给一个序列的题目,可以先设法用**dp(或递归)**,于是我们设$h[i]$表示每堆牌的数量(当然,$h[0]=0$),设$f[i]$表示前$i$张牌最少几次打完;

我们先看一个例子

$13$

$5~4~3~ 2~ 1~ 1~ 0~ 9~ 5~ 8~ 7~ 6~ 4$



然后手算一下得:

$f[1]=5,f[2]=5,f[3]=5,f[4]=5,f[5]=5,f[6]=5,f[7]=5$

$f[8]=14,f[9]=14$

$f[10]=17,f[11]=17,f[12]=17,f[13]=17$

**所以答案就是$17$**,我们发现所有$f[i]$的取值分成了三种:$5,14,17$,再观察发现只有当$h[i]>[i-1]$时,$f[i]$的值相较$f[i-1]$会增加,而且增加的值恰好就是$h[i]-h[i-1]$,所以我们可以先猜测当$h[i]>[i-1]$时,$f[i]=f[i-1]+(h[i]-h[i-1])$,否则,$f[i]=f[i-1]$

证明:

我们发现对于一个不上升的序列(就是后一个数一定**小于等于**前一个数),如:$5~ 4~ 3~ 2~ 1~ 1~ 0$,其实打完所要的次数就是第一个数(从尾到头慢慢都化为0,比如先从第一张到第六张,再第一张到第五张,等等),所以$f[i]=f[i-1]$(值从子序列头到尾都一样是5),刚好这里都满足$h[i]>h[i-1]$,所以**猜测成立了一半**

再看像:$9~5~8$这样一个数列,显然这个数列有两个**最大不上升子序列**,$<9,5>$和$<8>$我们发现在使第一个不上升子序列的$5$消为$0$时,$5$顺便还可以拖$8$一把,使$8$变为$3$,于是$f[3]=f[2]+3=12$

刚好对应前面当$h[i]>[i-1]$时,$f[i]=f[i-1]+(h[i]-h[i-1])$

但是如果一个像$9~ 5~ 8~ 7~ 6$,这样的数列还成立吗,显然这个数列有两个最大不上升子序列,$<9,5>$和$<8,7,6>$,所以,$5$在托$8$一把时,还可以拖$7$和$6$一把,这样后面还是一个不上升子序列$<3,2,1>$,整个答案并没有被影响(原本应该是$f[5]=f[4]=f[3]=12$,现在还是一样)

~~这种方法勤俭节约不浪费,所以是最优的~~

### 上代码

标准版

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+5;
#define ll long long
ll h[N],n,f[N];
int main()
{
	scanf("%lld",&n);
	for(int i=1;i<=n;i++)
	{
		scanf("%lld",&h[i]);
	}
	for(int i=1;i<=n;i++)
	{
		if(h[i]>h[i-1]) f[i]=f[i-1]+(h[i]-h[i-1]);
		else f[i]=f[i-1];
	}
	cout<<f[n];
	return 0;
}
```

精简版

```cpp
#include<bits/stdc++.h>
long long n,h[2],f,z;
int main()
{
	scanf("%lld",&n);
	for(int i=1;i<=n;i++) scanf("%lld",&h[1]),f+=std::max(z,h[1]-h[0]),h[0]=h[1];
	return printf("%lld",f),0;
}
```

