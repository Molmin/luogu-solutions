《挑战程序设计竞赛》P124 中提到了有可以 $O(\sqrt n)$ 判定一个数是否为 Carmichael Number，或者 $O(n)$ 预处理，$O(1)$ 查询一个数是否为 Carmichael Number 的方法，但是我查了很多地方都没有。直到看到了《数论概论》P80：

> 设 $n$ 是合数，则 $n$ 是卡米歇尔数当且仅当它是奇数，且整除 $n$ 的每个素数 $p$ 满足下述两个条件：
> 1. $p ^ 2$ 不整除 $n$；
> 2. $p - 1$ 整除 $n - 1$。

利用这两个性质可以高效求出或者筛出 Carmichael Numbers，但是貌似网上并没有具体做法。这里简单讲一下：

$O(\sqrt n)$ 的方法即对于每个 $n$ 的质因数 $p(p \le \sqrt n, n \equiv 0 \pmod{p})$，判断上述两个条件是否满足。

我们先考虑 $O(n \log \log n)$ 的埃氏筛方法：对于每个数 $i$，我们都可以通过埃氏筛枚举到它的所有质因数。对于每个 $i$ 的质因数判断是否满足条件即可。

但是 $O(n)$ 筛法看起来难想一些，因为不能再对每个数都判断其所有质因数了（根据埃氏筛的时间复杂度证明方法，$1 \sim n$ 内所有数的质因数个数之和为 $O(n \log \log n)$）。我们想到可以维护一个布尔数组，先跑一遍欧拉筛求出 $n$ 以内的质数和每个数的最小质因数，并把所有偶数和质数删掉，再用性质 1 把所有质数的平方的倍数筛掉。由于性质 2 不好处理，所以我们对于剩余的每个数都直接暴力枚举质因数判断。这个方法的效率实际上已经非常高了，因为在暴力枚举剩余数之前的所有数的集合已经很小了，并且使用性质 2 判断时，很多数往往会在使用前几个比较小的质因数判断时就出现矛盾，不用继续判断。但是想要严格证明这种方法的时间复杂度还是比较难。

我们可以考虑使用 Carmichael Numbers 的另一个性质：很多的 Carmichael Numbers 的质因数个数实际上很少，第一个有 9 个质因数的 Carmichael Number 为 9746347772161。而在本题 $n \le 65000$ 的数据范围内，任何一个 Carmichael Number 的质因数个数最多只有 4 个。因此，我们暴力枚举每个数的质因数时，可以根据 $n$ 的范围设置质因数上界，对于质因数个数超过一定数量的数不再判断。此时算法的时间复杂度可以近似看成 $O(n)$。

当然也有可能是我没有想到足够巧妙的 $O(n)$ 算法。如果你想到了的话，希望你能单独写题解，或者直接在评论区提出思路。

更多有关 Carmichael Numbers 的性质可以参考[OEIS](http://oeis.org/A002997)或者[维基百科](https://zh.jinzhao.wiki/wiki/%E5%8D%A1%E9%82%81%E5%85%8B%E7%88%BE%E6%95%B8)。

~~代码就不放了吧~~
