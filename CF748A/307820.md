#### 题目解析：
这题其实就是一个二维矩阵，给你一个编号，让你输出这个编号所在的位置
#### 使用算法：
这题的范围：$ n,m,k.( 1<=n,m<=10000 , 1<=k<=2 * n* m ) $

所以这道题不能用二维数组直接来模拟，我自己在做的时候又想到了STL中的```vector```，然后，大大滴WA！

~~***放弃思考***~~

所以就想了一个简便一点的方法：不模拟出一个二维矩阵，直接查找编号

其核心就是三重循环

#### 代码实现：
```cpp
for(int i=1;i<=n;i++)	//模拟行数
{
    for(int j=1;j<=m;j++)	//模拟列数
    {
        for(int t=1;t<=2;t++)	//一列有两排
        {
            cnt++;	//用来记录当前编号
            if(cnt==k)
            {
                cout<<i<<" "<<j<<" ";   //输出横坐标和纵坐标
                if(t==1) cout<<'L';  //输出是左还是右
                else cout<<'R';
                putchar('\n');  //换行
                return 0;   //结束，return 0
            }
        }
    }
}
```
用三重循环的方式从行、列、每列的两排中查找



接着就是整段代码了
#### 代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
int main()
{
    int n,m,k;
    cin>>n>>m>>k;
    int cnt=0;  //一个计数器
    for(int i=1;i<=n;i++)      //第一重循环，模拟行
    {
        for(int j=1;j<=m;j++)   //第二重，模拟列
        {
            for(int t=1;t<=2;t++)   //第三重，模拟出每列的左右两边
            {
                cnt++;	//用来记录当前编号
                if(cnt==k)  //如果计数器的编号等于要找的编号，输出
                {
                    cout<<i<<" "<<j<<" ";   //输出横坐标和纵坐标
                    if(t==1) cout<<'L';  //输出是左还是右
                    else cout<<'R';
                    putchar('\n');  //换行
                    return 0;   //结束，return 0
                }
            }
        }
    }
    return 0;
}
```