# 题解

题意即给定一个可能很大的$n$，求$(1^{n}+2^{n}+3^{n}+4^{n}+5^{n})\ mod\ 5$。

我们对于不同的数字（$1,2,3,4,5$）进行单独处理：

-  $1^{n}$，这种情况很简单，因为我们小学时就知道了~~一个举世闻名的定理~~：

 - $1$的任意次方都等于$1$
 
 所以只要在最后加上$1$再$mod\ 5$就可以了

- $2^{n}$，通过找规律发现$2$的$n$次方膜$5$的规律：

 > ```2 4 3 1 , 2 4 3 1...```
 
 发现每四个一循环，到时候计算$n\ mod\ 4$即可
 
 其实对于不同的$n$，有：
 
 - $n=4k+1(k\in{N^{+}})$，则
 
  > $2^{4k+1}\equiv{2\times{(2^{4})^{k}}}\equiv{2\times{16^{k}}}\equiv{2\times{1^{k}}}\equiv{2}\ (mod\ 5)$
 
 - $n=4k+2(k\in{N^{+}})$，则
 
  > $2^{4k+2}\equiv{2^{2}\times{(2^{4})^{k}}}\equiv{4\times{16^{k}}}\equiv{4\times{1^{k}}}\equiv{4}\ (mod\ 5)$
 
 - $n=4k+3(k\in{N^{+}})$，则
 
  > $2^{4k+3}\equiv{2^{3}\times{(2^{4})^{k}}}\equiv{8\times{16^{k}}}\equiv{3\times{1^{k}}}\equiv{3}\ (mod\ 5)$
 
 - $n=4k(k\in{N^{+}})$，则
 
  > $2^{4k}\equiv{(2^{4})^{k}}\equiv{16^{k}}\equiv{1^{k}}\equiv{1}\ (mod\ 5)$

- $3^{n}$，通过找规律发现$3$的$n$次方膜$5$的规律：

 > ```3 4 2 1 , 3 4 2 1...```
 
 发现每四个一循环，到时候计算$n\ mod\ 4$即可
 
 其实$3^{n}\equiv{(-2)^{n}}\ (mod\ 5)$
 
 所以当：
 
 1. $n$为奇数时，$(2^{n}+3^{n})\ mod\ 5 =0$
 
 2. $n$为偶数时，$(2^{n}+3^{n})\ mod\ 5 =2^{n+1}\ mod\ 5$

- $4^{n}$，通过找规律发现$4$的$n$次方膜$5$的规律：

 > ```4 1 , 4 1 , 4 1...```
 
 发现每两个一循环，到时候计算$n\ mod\ 2$即可
 
 其实$4^{n}\equiv{(-1)^{n}}\ (mod\ 5)$
 
 所以当：
 
 1. $n$为奇数时，$(1^{n}+4^{n})\ mod\ 5 =0$
 
 2. $n$为偶数时，$(1^{n}+4^{n})\ mod\ 5 =2$
 


- $5^{n}$，简单说：

  > $5^{n}\equiv{0^{n}}\equiv{0}\ (mod\ 5)$

  所以$5^{n}\ mod\ 5$其实就等于$0$
  
注意到最大的循环周期也只有$4$，因为$n$可能会非常大，所以可以运用快读边读入边```%100```，因为:

> 假设$x=100k+a(k\in{N^{+}},a=[0,99])$，则：

 > $x\equiv{100k+a}\equiv{0k+a}\equiv{a}\ (mod\ 5)$
 
 所以其实对于任何一个正整数$n$，```n%4```的值等于$n$的后两位数字```%4```，所以只要在快读的时候边读入边```%100```
 
 最后将以上$5$个结果一一特判累加再```%5```即可（我太菜了）
 
---

# 代码

```cpp
#include<stdio.h>
#include<ctype.h>
int n,res;
void qread(int &x) //快读
{
	x=0;
	char c=getchar();
	for(;!isdigit(c);c=getchar());
	for(;isdigit(c);c=getchar()) x=(x*10+c-48)%100; //注意这里多了一个括号和%100
	return ;
}
void Add2() //特判第二种情况
{
	if((n&3)==1) res+=2; //这里用的是位运算，不会的大佬们请见后面
	else if((n&3)==2) res+=4;
	else if((n&3)==3) res+=3;
	else res+=1;
	return ;
}
void Add3() //特判第三种情况
{
	if((n&3)==1) res+=3; //这里用也的是位运算，不会的大佬们请见后面
	else if((n&3)==2) res+=4;
	else if((n&3)==3) res+=2;
	else res+=1;
	return ;
}
void Add4() //特判第四种情况
{
	if((n&1)) res+=4; //这里用也的是位运算，不会的大佬们请见后面
	else res+=1;
	return ;
}
int main()
{
	qread(n);
	Add2(); //第一种情况
	Add3(); //第二种情况
	Add4(); //第三种情况
	printf("%d\n",(res+1)%5); //记得加上第一种情况的1，第五种情况因为是0所以就可以不加了
	return 0;
}
```

---

## 说明

关于本篇涉及到的位运算的讲解

#### ```x&1```的返回值只有两种

1. 当$x$为奇数时，返回$1$

2. 否则返回$0$

此处就等于$x\%2$（或$x\%2==1$）

同理```x&3```也是

其实任何$x\%2^{i}$都可以转化为$x\&(2^{i}-1)$