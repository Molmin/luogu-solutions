首先声明，题目翻译有误：

求和时没有 $5^n$ ，

但这一漏洞只在 $n=0$ 是有所体现

（想想为什么

### 废话不说，开始找规律

| $n^m \bmod 5$ | 0 | 1 | 2 | 3 | 4|5|6|7|8
| -----------: | -----------: | -----------: | -----------: | -----------: |-----------: |-----------: |-----------: |-----------: |-----------: |-----------: |
| 1 |1  | 1 | 1 | 1 |1  | 1 | 1 | 1 |1
| 2 | 1 | 2 | 4 | 3 |1 | 2 | 4 | 3 |1
|  3| 1 | 3 | 4 | 2 |1 | 3 | 4 | 2 |1
| 4 | 1 | 4 | 1 | 4 |1 | 4 | 1 | 4 |1
|  1+2+3+4|4|0|0|0|4|0|0|0|4

我们可以发现，无论是单独的项还是求和，

数字都会每 $4$ 位一循环，

观察可得，当 $m \bmod 4 = 0 $ 时，

答案为 $4$，否则为 $0$。

于是我们就将问题转化成了

判断一个高精度数是否为 $4$ 的倍数的问题。

判断也很简单：

并不需要进行高精度 $\div$ 的运算，

因为所有以 $2$ 个 $0$ 结尾的数，

都能被拆解为 $n \times 25 \times 4$ 的形式，

故我们只需判断 $n$ 的末尾 $2$ 位是否能被 $4$ 整除。

代码如下：
```
#include<bits/stdc++.h>
using namespace std;
int main(){
    string a; cin>>a;
    if(a.size()==1) cout<<((a[0]-'0')%4==0?4:0);//特判
    else cout<<(((a[a.size()-2]-'0')*10+a[a.size()-1]-'0')%4==0?4:0);
    /*三目运算符
    写成：（判断语句?a:b），
    意为：若条件为真，返回 a，否则返回 b
    */
    return 0;
}

```