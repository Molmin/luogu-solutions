话说现在连$pj$都考这么变态的数学题了吗……
#### 回归正题
看到这道题目，相信大家就一定想到了一个初赛中经常遇到的模型：

有 $ n $ 个完全相同的盒子和 $ n $个完全相同的小球，允许盒子为空，求有多少种不同的放法？

其实这道题本质上和上面的问题是完全相同的。

初赛的时候数据小手推就可以了，但是现在$1≤n≤10 
^5$
 ，$1 \leq p < 2^{30}$，显然~~dabiao~~是不现实的。
 
 那么应该如何解呢？
 
###  大家要注意的是！这是一场Online测试。
### 所以，我们要充分地利用网络。
我们可以先尝试着推前几个.

$n=1,ans=1$//(1)

$n=2,ans=2$//(2,0),(1,1)

$n=3,ans=3$//(3,0,0),(2,1,0),(1,1,1)

$n=4,ans=5$//(4,0,0,0),(3,1,0,0)(2,2,0,0)(2,1,1,0)(1,1,1,1)

$n=5,ans=7$//太长了，请dalao们自己去推算吧

~~众所周知，~~，有一个非常神奇的网站叫做[OEIS](http://oeis.org/)。

将我们刚才找到的规律1,2,3,5,7输入，很快得到一个数列[A000041](http://oeis.org/search?q=1%2C2%2C3%2C5%2C7&sort=&language=english&go=Search)。

阿嘞！全是英文，想我这种初二的蒟蒻如何看得懂？

但是，当你仔细地观察后，就会发现长长的解释中有一段名为PROG的版块，其中有一个~~在本蒟蒻眼里~~看着是伪代码的东西。
```cpp
def A000041(n):
    if n == 0: return 1
    S = 0; J = n-1; k = 2
    while 0 <= J:
        T = A000041(J)
        S = S+T if is_odd(k//2) else S-T
        J -= k if is_odd(k) else k//2
        k += 1
    return S
```
接下来的工作就相当容易了。我们把代码翻译成c++，然后把取模啊，记忆化搜索等等全部加上去就可以了。
## $Code$
```cpp
ll sol(int x){
	if (x==0) return 1;
	if (dp[x]>0) return dp[x];//记忆化
	ll s=0,j=x-1,k=2;
	while(0<=j){
		ll t=sol(j);
		if ((k/2)&1) s=(s+t)%p;
		else s=(s-t+p)%p;
		if (k&1) j-=k;
		else j-=(k/2);
		k++;
	}
	dp[x]=s;//记忆化
	return s;//也没有什么好解释了，纯翻译……
}
```


### 然而！

我却惊奇的发现第三个样例竟然过不了……

万分无奈的，本蒟蒻有将上面的代码修改成了dp。

## $AC$ $Code$

```cpp
#include <bits/stdc++.h>
using namespace std;

typedef long long ll;
ll n,p,dp[100010];

int main()
{
	scanf("%lld%lld",&n,&p);
	dp[0]=1;
	for(int i=1;i<=n;i++){
		ll j=i-1,k=2;
		while(0<=j){
			if ((k/2)&1) dp[i]=(dp[i]+dp[j])%p;
			else dp[i]=(dp[i]-dp[j]+p)%p;
			if (k&1) j-=k;
			else j-=(k/2);
			k++;
		}//其实除了把x,s,t这些乱七八糟的换了一下，几乎没有什么区别…
	}
	printf("%lld\n",dp[n]);
	return 0;
}
```

### 总结：
+ ~~要充分利用网络~~
+ 本题解纯粹供$pj$选手娱乐，请各位大佬们自行跳过！
+ 来自蒟蒻的忠告：希望大家在日常做题中不要过多利用此方法
~~（否则可能被kkk禁掉）~~……

最后，感谢~~xjd~~大佬提供的神奇思路