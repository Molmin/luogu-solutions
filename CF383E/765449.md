# CF383E Vowels 题解

### 题目大意

- 给出 $n$ 个长度为 $3$ 的单词（每个字母都为 $a$ 到 $x$ 中的任意一个），我们说该单词是正确的，当且仅当该单词中含有至少一个元音。元音可以是范围内的任意字母。

- 对于所有 $ 2 ^ {24}$ 种元音集合，求出所有情况下正确单词个数的平方的异或和。

- $1 \le n \le 10 ^{4}$。

### 题意分析

- 因为字母的数量很少，只有 $24$ 个，所有我们考虑把单词压缩成状态，用类似**状压 dp** 的方法做出这道题。

- 我们知道，每一个元音集合都对应着一个正确单词的集合。但这个正确单词的集合我们似乎不太好求。

- 数学中有一种思想叫做**正难则反**，这里我们可以借鉴该思想，把问题转化成求出每个元音集合对应的不正确的单词集合，最后用单词总个数 $n$ 减去不正确的单词个数，也能得到我们想要的答案。

- 接下来我们考虑如何求出不正确的单词集合。

	我们首先要知道，一个单词不正确，即一个单词中不含任何元音。
    
   我们用符号来表示一下：
   
   设当前枚举到的元音集合为 $A_{i}$，某一个单词中包含的字母集合为 $B_{j}$，则容易得到关系 $A_{i} \cap B_{j} = \varnothing$，由此我们可以得到以下关系式：
   
   设元音集合状态压缩之后的二进制状态为 $a_{i}$，单词状态压缩之后的二进制状态为 $b_{j}$，则有：$ a_{i} \& b_{j} = 0$。
   
   于是我们可以接着往下推。不难想到，对 $a_{i}$ 取反，得到的数一定满足上述关系式。然后我们不难发现，取反之后的数在二进制表示下，任何一位或几位的 $1$ 变成 $0$，所得出的数仍满足上述关系式。
    
    举个例子：
    
    一个数 $a$ 为 $(010010101) _ {2}$，该数取反后变为 $(101101010) _ {2}$，我们设其为 $b$，易证得 $a \& b = 0$。同样地，易证出 $(101101000) _ {2}$，$(001101010) _ {2}$，$(100001010) _ {2}$ 等数都满足 $\& a = 0$（可以在草稿纸上写写）。
    
- 这样我们实际上就找到了每个元音集合所对应的所有不正确的单词集合了。

	怎样求出该集合的元素个数呢？
    
    这里我们要用到**高维前缀和**来维护。
    
    不太明白高维前缀和的同学[戳这里](https://www.luogu.com.cn/blog/wwwjy4612code/gao-wei-qian-zhui-hu)。
    
    这玩意这么写：
    
    ```cpp
	for(int i = 0; i < 24; ++ i)
		for(int j = 0; j < M; ++ j)
			if(j & (1 << i) ) f[j] += f[j ^ (1 << i)];//高维前缀和
	```
    
    于是对于每个元音集合的二进制状态 $a_{i}$，其取反后得到的数 $b_{i}$ 所对应的 $f_{b_{i}}$ 的值就是该状态下不正确的单词数目。
    
- 接下来就简单了，该平方平方，该异或异或，按题目输出即可。

- 时间复杂度为 $O(n + 24 \cdot 2 ^ {24})$。

下面是 AC 代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int M = 1 << 24;
int f[M + 10], n, ans;
char s[5];
int main()
{
	scanf("%d", &n);
	for(int i = 1; i <= n; ++ i)
	{
			scanf("%s", s);
			int sta = 0;
			for(int j = 0; j < 3; ++ j)
			sta |= (1 << (s[j] - 'a') );
			++ f[sta];
	}
	for(int i = 0; i < 24; ++ i)
		for(int j = 0; j < M; ++ j)
			if(j & (1 << i) ) f[j] += f[j ^ (1 << i)];//高维前缀和
	for(int i = 0; i < M; ++ i)
		ans ^= (n - f[i]) * (n - f[i]);
        //这里的 f[i] 其实是每个 i 取反之后的那个状态对应的元音集合所对应的不正确的单词个数。因为每种情况都会被枚举到，因此不用取反也是可以的。
	printf("%d\n", ans);
	return 0;//高维前缀和
}
```

