## 题解：
每步有两种方案：\
天数+1```or```月份+1。

先到达目标日期者为赢。如果到达2001.11.4之后的人就输了。规律是不看年份，每次操作必定会使日期和月份的和的奇偶性发生变化 。\
目标11.4（11+4=15）是奇数。 天数或月份+1都会导致其和的奇偶性发生改变。
除了9.30和11.30两天，注意两个特殊的日期 。9月30日(日+1为10.1，月+1为
10.30)和11月30日（日+1为12.1，月+1为12.30），奇偶性可能是保持不变的，但
是因为足够聪明，所以，是可以通过加月份来避开这一天的，\

**所以因为目标是奇数，所以加入一开始是偶数或者是这两天则先者赢，否则后者
赢。**

## Code:
~~~
#include<cstdio>
using namespace std;
int a,b,c,n,stop=0;
/*
我们设2001.11.4必败，推上去，即2001.10.4和2001.11.3必胜（此时m+d=偶数）
再推上去是11.2，10.3，9.3，都是必败（此时m+d=奇数），以此类推……

为什么9.30和11.30例外呢？
因为9.30和11.30月份+1，即10.30和12.30，都是必败局面
这种情况只有在8月与以后出现，为什么大家应该清楚

2.29为奇数，必败

没有2.29，剩2.28和3.1衔接也没问题，都是必胜

12.31必败，1.1必胜（以上情况自己考虑）

所以本题和年份完全没关系 
*/
int main() {//Code:
	scanf("%d",&n);
	for(register int i=1;i<=n;++i) {
		scanf("%d%d%d",&a,&b,&c);
		(b==9&&c==30)||(b==1&&c==30)||((b+c)%2==0)?printf("YES\n"):printf("NO\n");
        	//9.30和11.30月份+1，必败局面！！
	}
	return 0;
}
~~~