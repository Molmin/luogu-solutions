## 题意：

多组数据，每组数据都会给定一个合法的日期，有两种操作方案，一种是天数加 $1$，另一种是月份加 $1$, 当有人操作后的日期为不合法的时候游戏结束，此时这人输了。

## 思路：

正常思路的话应该是记忆化搜索，但标签里带着数论，那就用数学方法来做。

首先想想什么时候操作下一步会输，首先年份对其没有影响，只有月份和日期会对答案产生影响，那就只考虑月份和日期，题目规定是 `Adam` 先手操作，当天数和日期加起来时为偶数，此时必胜，奇数必败，$9$ 月 $30$ 和 $11$ 月 $30$号都是必胜的。

## 证明：

首先先来证明为什么天数和日期加起来为偶数时必胜。

因为 $2001.11.4$ 是必败的，因为已经到了最后一天，无法操作了，所以说当他操作到 $2001.11.3$ 时是必胜的，那 $2001.11.2$ 就是必败的，以此类推……

因为前面说到了年份并没有影响，所以只考虑月份和日期。

|  必胜 | 必败  |
| :----------: | :----------: |
|  11.3 |  11.4 |
|  11.1 |  11.2 |
|  10.30|  10.31|
|  10.28|  10.29|
|  10.26|  10.27|

### 由此可以推出：

当月份加日期和为偶数时必胜，月份加日期和为奇数时必败。

于是交上去会发现只有 $50$ 分，因为只有两个测试点，也就是说有特殊情况没有考虑到。

当 $9.30$ 和 $11.30$ 时，日期加 $1$ 是 $10.1$ 和 $12.1$, 月份加 $1$ 是
$10.30$ 和 $12.30$,此时可以通过月份加 $1$ 来避开这两天，所以只需要多打个特判就可以了。

## Code：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn = 1e7 + 10;
const int MAXN = 1e3 + 32;

int read() {
	int s = 0, w = 1;
	char ch = getchar();
	while(ch  < '0' || ch > '9') {if(ch == '-') w = -1;ch = getchar();}
	while(ch >= '0' && ch <= '9') s = s * 10 + ch - '0', ch = getchar();
	return s * w;
}
int stc[maxn], sc = 0;
int main() { 
	int n = read();
	for(int i = 1; i <= n; i++) {
		int a = read(), b = read(), c = read();
		if(b == 9 && c == 30 || b == 11 && c == 30 || (b + c) % 2 == 0) stc[++sc] = 1;
		else stc[++sc] = 0;
}
	for(int i = 1; i <= sc; i++) {
		if(stc[i] == 1)	{
			cout << "YES\n";
		}
		else cout <<"NO\n";
	}
return 0;
}
```
