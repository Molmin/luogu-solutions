这是一道非常好玩的题目。  
闲话少说，切入正题——

---
第一眼看上去：诶这不是博弈论吗？   
完了博弈论我不会（准备继续找题）。  
看看标签：模拟？搜索？数论？记搜？  
（吓得我吃了一惊.jpg）  
作为一个菜菜的 OIer，我决定找找规律。

---

所以说这道题我们应该认真的分析一下。  
首先，显然 2006/11/4 是必败的，因为怎么动也动不了。  
那么，2006/11/3 就是必胜。  
2006/11/2 就是必败。  
然后就以此类推不拉不拉不拉  

在我们这样近似于找规律的方法中，我们会发现，当 $(m+d)\mod 2=0$ 时（$m$ 为月份，$d$ 为天），必胜；$(m+d)\mod 2=1$ 时，必败。这是因为在我们找规律的时候，开始 $(m+d)\mod 2=1$，而且没倒推一次情况发生改变。那么就可以得出以上结论。  

然后你就可以愉快的写代码啦~  

---
But！我们还要手动模拟一些极端情况来验证啊。  
这里的极端情况显然是月末天数 $+1$。  
通过手动验算，我们会发现两个特例独行的日期，那就是 **9/30** 和 **11/30**。  

为什么呢？因为在八月份的时候，就很不规矩的变成了和七月份一样的 31 天，规律被打破，本来的 $+1$ 天规律的月份就被取反，这个时候，月份加 1 可以变成必胜。  
（感性理解）

---
好啦，我们梳理一下：  
1. 特判 $m=9,d=30$，此时为必胜。
2. 特判 $m=11,d=30$，此时为必胜。
3. 判断 $(m+d)\mod 2=0$ 此时为必胜

```cpp
#include<cstdio>
int main()
{
	int n,x,y,z;
	scanf("%d",&n);
	while(n--)
	{
		scanf("%d%d%d",&x,&y,&z);
		if((y==9&&z==30)||(y==11&&z==30)||((y+z)%2==0))puts("YES");
		else puts("NO");
	}
}
```