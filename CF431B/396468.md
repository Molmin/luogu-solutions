### 题目简述：

有 5 名同学排队去洗澡。在淋浴开始前，如果 $i$ 和 $j$ 交谈，$i$ 的幸福值增加 $g[$ $i$ $][$ $j$ $]$ ,$j$ 的幸福值增加 $g[$ $j$ $][$ $i$ $]$,即总幸福值增加 $g[$ $i$ $][$ $j$ $]$ $+$ $g[$ $j$ $][$ $i$ $]$，而淋浴一打开，队里第一个人就从队里进入淋浴,正在洗澡或洗完澡的同学将不再进行交流，问这 5 名同学获得的总幸福值最大是多少。

### 算法分析：

这是一道全排列问题。题目中限定了人数只能是 5 个，这是重点，因为   $5!=120$，所以可以直接暴力枚举。

我们用数组 $id$ 存储 5 名同学的顺序，模拟这 5 名同学排队洗澡的过程。而这 5 名同学的顺序，我们可以用  next _ permutation  函数对这 5 名同学进行全排列，共有 120 种排列方案。

对于  next _ permutation  函数，我在这里大概的讲一下：

- 这是一个求一个排序的下一个排列的函数，可以遍历全排列，要用头文件 #include<algorithm>  。

- 原理：若下一个排列存在，则返回真，如果不存在，则返回假。

- 使用方法： next _ permutation (数组头地址，数组尾地址);

### 代码参考：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=10;  //稍微开大一点，防止数组溢出 
int g[N][N];
int id[N]={0,1,2,3,4};
int ans;
int main() {
    for(int i=0; i<5; i++) 
        for(int j=0; j<5; j++) 
            scanf("%d",&g[i][j]);
	do{ans=max(ans,g[id[0]][id[1]]+g[id[1]][id[0]]+g[id[1]][id[2]]+g[id[2]][id[1]]+(g[id[2]][id[3]]+g[id[3]][id[2]]+g[id[3]][id[4]]+g[id[4]][id[3]])*2);}while(next_permutation(id,id+5));
    printf("%d",ans); 
    return 0;
}
```
~~求通过~~