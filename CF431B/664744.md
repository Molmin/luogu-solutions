交这篇题解之前看到题解区都在用一个非常厉害的函数，本蒟蒻表示用只会用循环求解，这里提供一种手搓做法，顺便还能练练码力。

# solution
- 刚看到这题还以为是贪心，结果拿纸算了一下没什么思路，于是看到只有 $ 5 $ 个人，于是——全排列。


- 先用五重循环暴力枚举每种可能的情况，在每种情况下用一个小数组记录每个数，剩下的两重循环是用来枚举当前队列剩下的人数和当前已有的幸福值，在最后一重循环中每次都 $j+2$，因为题目要求两两聊天所产生的的幸福值，所以每次加 $ 2$，还要判断一下每次队列的最后一个人是否还有搭档来交谈，否则可能会加上最后一个人的幸福值造成答案错误，最后每次更新幸福值即可。

- 剩下的分析详见代码。

# code
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,i,j,ans,a,b,c,d,e,maxn;
int mp[10][10],s[10];
int main(){
	for(i=1;i<=5;i++){
		for(j=1;j<=5;j++) scanf("%d",&mp[i][j]);
	}
	for(a=1;a<=5;a++){
		for(b=1;b<=5;b++){
			if(b==a) continue;
			for(c=1;c<=5;c++){
				if(c==a || c==b) continue;
				for(d=1;d<=5;d++){
					if(d==a || d==b || d==c) continue;
					for(e=1;e<=5;e++){
						if(e==a || e==b || e==c || e==d) continue;
						ans=0;
						s[1]=a,s[2]=b,s[3]=c,s[4]=d,s[5]=e;//存下当下情况的排列
						for(i=1;i<=5;i++){//可以理解为队列还剩5-i个人
							for(j=i;j<=5;j+=2){//计算5-i个人两两谈话的幸福值
								if(j+1>5) break;//判断最后一个还能不能配对
								ans+=(mp[s[j]][s[j+1]]+mp[s[j+1]][s[j]]);		 
							}
						}
						maxn=max(ans,maxn);
					} 
				}
			}
		}
	}
	printf("%d",maxn);
	return 0;
}
```
虽然代码有些冗长，但是可以锻炼一下码力，而且挺通俗易懂的，也算是一个别样的方法。