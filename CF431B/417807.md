由于 $n=5$ 所以直接暴力即可。

需要的只是计算全排列。当然你可以从 [P1706 全排列问题](https://www.luogu.com.cn/problem/P1706) 中直接复制过来你的 DFS 代码。但是有更简便的方法，那就是使用泛型算法中的 `next_permutation` 函数。

其用法为：
对于函数 `next_permutation(a,a+n)`，若原序列为最大排列，则将序列重排为最小序列，并返回 false；否则，将序列重排为字典序中下一个排列，并返回 true。

那么对于每一种全排列，若设 $a[i]$ 对应的为一种全排列中第 $i$ 个元素所对应的值，即编号，则它的情况计算方法为：

- 第一轮，第 $1$ 个人 与 第 $2$ 个人交谈，第 $3$ 个人 与 第 $4$ 个人交谈，第 $5$ 个人轮空，则幸福感增加 $g[a[1]][a[2]] + g[a[2]][a[1]] + g[a[3]][a[4]] + g[a[4]][a[3]]$。
- 第二轮，第 $2$ 个人 与 第 $3$ 个人交谈，第 $4$ 个人 与 第 $5$ 个人交谈，则幸福感增加 $g[a[2]][a[3]] + g[a[3]][a[2]] + g[a[4]][a[5]] + g[a[5]][a[4]]$。
- 第三轮，第 $3$ 个人 与 第 $4$ 个人交谈，第 $5$ 个人轮空，则幸福感增加 $g[a[3]][a[4]] + g[a[4]][a[3]]$。
- 第四轮，第 $4$ 个人 与 第 $5$ 个人交谈，则幸福感增加 $g[a[4]][a[5]] + g[a[5]][a[4]]$。

综上，每一种全排列的幸福感为：
`sum=g[a[1]][a[2]]+g[a[2]][a[1]]+g[a[2]][a[3]]+g[a[3]][a[2]]+2*g[a[3]][a[4]]+2*g[a[4]][a[3]]+2*g[a[4]][a[5]]+2*g[a[5]][a[4]]`

CODE:
```cpp
#include<bits/stdc++.h>

using namespace std;

const int INF=0x3f3f3f3f,N=1e5+5;
int i,j,n=5,g[6][6],a[6]={0,1,2,3,4,5},ans,sum;
int main()
{
	for(i=1;i<=n;i++)
	{
		for(j=1;j<=n;j++)cin>>g[i][j];
	}
	do
	{
		sum=g[a[1]][a[2]]+g[a[2]][a[1]]+g[a[2]][a[3]]+g[a[3]][a[2]]+2*g[a[3]][a[4]]+2*g[a[4]][a[3]]+2*g[a[4]][a[5]]+2*g[a[5]][a[4]];
		ans=max(ans,sum);
	}while(next_permutation(a+1,a+n+1));
	cout<<ans;
	return 0;
}
```
