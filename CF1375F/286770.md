又是一道构造题……

读完题目看样例，似乎发现了什么不得了的东西。

思考为什么样例里最后先手赢了：
* 最后一步，石子数变为 $5,2,8$，先手给了 $3$ 颗石子，因为 $8-5=5-2=3$，所以后手只要放在第一堆或第二堆上都必输。
* 另外上一步中 $8$ 被操作过了，所以可怜的 Anton 不能继续在第三堆石子上继续放石子，只能认输。

这给了我们启示：**当这三个数构成等差数列，且最大数不能操作时，后手必败**。

于是我们充当先手，通过构造方案击败后手。我们的目标是，通过添加石子，让三个数构成等差数列并且操作的数是等差数列中最大的那个。

设三个数分别为 $a,b,c$，且满足 $a < b < c$。分类讨论：

设给后手的数为 $x$，
1. 若后手将数添加在了 $a$ 上，那么由题意得，$a+x+b=2c$，解得 $x=2c-a-b$；
2. 若后手将数添加在了 $b$ 上，那么由题意得，$b+x+a=2c$，解得 $x=2c-a-b$；
3. 若后手将数添加在了 $c$ 上……很遗憾，我们不一定能满足条件。

对策略进行调整：如果后手将石子添加在了较小的两堆上，那么先手必胜。

既然这样，为什么我们不再加一步操作，使后手无法操作最大的那一堆呢？

于是我们可以添加一个很大的数，比如 $10^{11}$，这样不管哪一堆添加过后都会成为最大数。

注意这个数不要太大，不然会超出 $y \le 10^{12}$ 的限制。

之后我们再给后手一个等差数列的公差，后手必败。

于是……这道题变成了顺序结构的程序题？！
```cpp
#include<cstdio>
typedef long long ll; 

void write(ll x)
{
	if(x == 0)
		return;
	write(x / 10);
	putchar(x % 10 + 48);
	return;
}

signed main()
{
	ll a[4];
	scanf("%lld%lld%lld", a + 1, a + 2, a + 3);
	puts("First");
	fflush(stdout);
	//加上一个特别大的数，使最大的一堆无法操作
	write(1e11);
	putchar('\n');
	fflush(stdout);

	int pile;
	scanf("%d", &pile);
	int mxp = pile;
	a[mxp] += 1e11;
	//使三个数成为等差数列并且让操作的一堆最大
	write(3 * a[mxp] - a[1] - a[2] - a[3]);
	putchar('\n');
	fflush(stdout);	

	scanf("%d", &pile);
	int x = pile;
	//加上公差，后手必败
	write(a[mxp] - a[6 - x - mxp]);
	putchar('\n');
	fflush(stdout);
	
	scanf("%d", &pile);
	//胜利的曙光
	return 0;
}
```