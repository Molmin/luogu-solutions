## 看到大佬们纷纷用线段树切掉了这个题，那我就来写一个用树状数组搞的题解吧（代码只有30多行哦）
首先，我们发现这个题目让我进行两个操作：一个是把x到y（包括x,y）中的亮的灯变灭，灭的灯变亮。另一个操作是查询x到y中（包括x,y）有多少盏灯是亮的。

对于第一个操作，我们发现，因为一开始所有的灯都是灭的，所以当某个灯被点了奇数次时，这个灯是亮的，被点了偶数次时，这个灯是灭的。让x到y被点时，只需要让x这个位置加1,y+1这个位置加1就好了。那么如果第i盏灯的前缀和为奇数的话,说明它是亮的,否则它就是灭的（即用前缀和表示操作次数）。

 ？？？ 为啥这样可以判断某盏灯是不是亮的了呢

 这其实是用到了一点差分的思想，当然不会也没关系。

 我们发现，当x这个位置的值加1，y+1这个位置加1，那么，i（i属于x到y）的前缀和一定会增加1，而小于x的数前缀和不变（相当于没操作），大于等于y+1的数的前缀和都变大了2（点了两次相当于没点，所以也是没操作）。这样我们就可以通过求前缀和的方式来判断对于某盏灯的操作次数了。而前缀和用树状数组维护和求值的话时间复杂度是logN的，所以这个题就可以用树状数组踩过去啦。

 至于第二个操作,就直接枚举x到y的每盏灯i,求i的前缀和是奇是偶然后统计答案就ok了。
 
 下面附上比~~线段树短几十行的~~代码
 ```
#include <iostream>
#include <cstdio>
using namespace std;
int n,m;
int a[102000];
void add(int x,int k){//修改树状数组 
	for(int i=x;i<=n;i+=i&(-i))
		a[i]+=k;
}
int query(int x){//用树状数组查询前缀和 
	int ans=0;
	for(int i=x;i>0;i-=i&(-i))
		ans+=a[i];
	return ans;
}
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=m;i++){//操作一 
		int chk;
		scanf("%d",&chk);
		if(chk==0){
			int x,y;
			scanf("%d%d",&x,&y);
			add(x,1);add(y+1,1);
		}
		if(chk==1){//操作二 
			int x,y;
			scanf("%d%d",&x,&y);
			int s=0;
			for(int i=x;i<=y;i++)
				if(query(i)&1==1)//前缀和为奇数 
					s++;//答案++ 
			printf("%d\n",s);	
		}
	}
	return 0;
}
```