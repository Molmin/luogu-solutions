## 背景
美化了题目中的式子之后：

$$
A_i=
\begin{cases}
 0 & i=1\\
 1 & i=2\\
 A_{i-1}^2+A_{i-2}^2 & i \geq 3
\end{cases}
$$

求 $A_n(1 \le n \le 2^{31})$。

本人学艺不精，一看式子和数据范围：这不就是[矩阵加速数列](https://www.luogu.com.cn/problem/P1939)吗，把矩阵构造出来就能轻松 AC 了，但是没见到过带平方的矩阵怎么推，然后便去找大佬问：

![](https://cdn.luogu.com.cn/upload/image_hosting/outzjeq3.png)

得到的回复是：

![](https://cdn.luogu.com.cn/upload/image_hosting/2tzgdlfo.png)

蒟蒻的希望破灭...


---------------------------------

回归正题，这道题的数据范围肯定是不允许我们去递推得到 $A_n$ 的（~~无论是时间上还是空间上都不允许~~），而且题目的柿子不能使用矩阵加速，所以我们考虑**分块打表+暴力**思想。

## 分块打表

因为 $n \le 2^{31}$，单纯的打表一定会爆空间和“代码过长，提交失败”，所以可以考虑每隔 $10^7$ 打出 $A_{(i \cdot 10^7)+1},A_{(i \cdot 10^7)+2}(0 \le i \le \frac{2^{31}}{10^7})$。

对于剩下的没有在表里的数据，可以根据第一个比 $n$ 小的 $i \cdot 10^7$ 进行递推，最后得到的 $A_{b}(b = n \bmod 10^7)$ 即是答案。

但是你以为这就结束了吗？让我们观察题目的内存限制：

62.50MB！

这意味着数组不能开到 $10^7$ 的大小，怎么办呢？

其实很容易解决，只需要循环利用 $A_1,A_2,A_3$ 数组即可。每次计算出 $A_3$ 时合理把 $A_1,A_2,A_3$ swap两下即可，注意最后输出不要输出错了就行。

另外注意处理一下 $n \equiv 0 \pmod{10^7}$ 的情况，因为我们打的是 $10^7+1,10^7+2$ 的表，所以在对 $n$ 取模得 $0$ 时进行处理，将得到的数加上 $10^7$，再把得到的块编号减一（向前挪一位）即可。

用于打表的辅助程序（注意题目中有**两个模数**，所以要打两个表）：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m;
long long f[10000003];
long long mod=1e9+7;//记得换成1999再打一个
int main(){
int cnt=1;
f[1]=0;f[2]=1;
while(cnt<=214){cnt++;
	for(int i=3;i<=10000003;i++){
		f[i]=(f[i-1]*f[i-1]+f[i-2]*f[i-2])%mod;
	}
	cout<<f[10000001]<<','<<f[10000002]<<','<<endl;
	f[1]=f[10000001],f[2]=f[10000002];
}
return 0;
}
```
AC 程序：[link](https://www.luogu.com.cn/paste/6bnw4ico)（因为表很长，这里就不放出来了）。

同时 AT 上古题，记得输出结尾加换行。