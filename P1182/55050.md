[题目传送门](https://www.luogu.org/problemnew/show/P1182)

这道题我用的方法是二分答案，（但我太弱了，还是做了很久）
首先我来介绍一下二分答案吧，（因为我太弱了，所以我用了一年的时间才弄懂）。

比如我们要从一本英汉词典上查一个单词，如果你从头到尾一页一页的翻着找（并仔细一点），这样找可以保证一定能找到，但是最坏情况你要把整本词典都翻一遍，那就麻烦了（而且很累）。

有什么改进的方法吗？当然有。

我们考虑把这个词典从中间分开，看一下中间那一页的主要单词都是啥，然后去判断我要找的单词应该在左半部分还是右半部分，再去那一部分考虑怎么找就好了。同样的，在另一部分也是要进行划分并且判断的操作。这样一直进行下去，便能很快的找到答案，而且根本不需要翻过整个词典来。

可以证明，如果一页一页的找，最多要找 $n$ 次，但是用这个方法，最多找$floor(log2n)$次。

我们把这个方法叫做“二分答案”。顾名思义，它用二分的方法枚举答案，并且枚举时判断这个答案是否可行。但是，二分并不是在所有情况下都是可用的，使用二分需要满足两个条件:

1.有上下界

2.区间有单调性


二分答案应该是在一个单调闭区间上进行的。也就是说，二分答案最后得到的答案应该是一个确定值，而不是像搜索那样会出现多解。二分一般用来解决最优解问题。刚才我们说单调性，那么这个单调性应该体现在哪里呢？

可以这样想，在一个区间上，有很多数，这些数可能是我们这些问题的解，换句话说，这里有很多不合法的解，也有很多合法的解。我们只考虑合法解，并称之为可行解。考虑所有可行解，我们肯定是要从这些可行解中找到一个最好的作为我们的答案， 这个答案我们称之为最优解。

最优解一定可行，但可行解不一定最优。我们假设整个序列具有单调性，且一个数x为可行解，那么一般的，所有的 $x'(x'<x)$ 都是可行解。并且，如果有一个数y是非法解，那么一般的，所有的 $y'(y'>y)$ 都是非法解。

那么什么时候适用二分答案呢？注意到题面：使得选手们在比赛过程中的最短跳跃距离尽可能长。如果题目规定了有“最大值最小”或者“最小值最大”的东西，那么这个东西应该就满足二分答案的有界性（显然）和单调性（能看出来）。

(以上内容感谢一位dalao的帮助)

好，下面来切入正题：

首先，我们来确定一下上下界，

我们定义$l$ ,$r$为区间的两端点，由于要求每段的最大值的最小值，所以 $l $应该取所有数中最大的那个（想想这是为什么），而 $r$ 是不是只能是区间和了。

那么我们的judge函数该怎么写呢？

我写的这个judge函数我刚开始也没怎么理解。。。（我太弱了） 这里的judge函数其实意思就是：在a数组内，能否满足每组的和比x小。如果是，返回0；否，返回1。

于是献上代码。

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<queue>
#include<cctype>
#include<cstdlib>
using namespace std;
typedef long long ll;
template<typename T>inline void read(T &x){//模板输入输出优化
    x=0;T f=1;char c=getchar();
    for(;c<'0'||c>'9';c=getchar())if(c=='-')f=-1;
    for(;c>='0'&&c<='9';c=getchar())x=x*10+c-'0';
    x*=f;
}
template<typename T>inline void write(T x){
    if(x<0)putchar('-'),x*=-1;
    if(x>=10)write(x/10);
    putchar(x%10+'0');
}
const int maxa = 1e5+10;
int n,m,tot,now,a[maxa],l=0,r=0,mid;
inline bool judge(int x){//据某位叫x的dalao的观点，内联函数要快一点
	for(int i=1;i<=n;++i){//这里大家应该看得出，
                          //这个操作是在用贪心来看一看这个最大值是否能为x
		if(tot+a[i]<=x)tot+=a[i];
		else tot=a[i],now++;
	}
	if(now>=m)return true;
	else return false;
}
int main(){
	read(n);read(m);
	for(int i=1;i<=n;++i){
		read(a[i]);
		l=max(a[i],l);//l为区间最大数
		r+=a[i];//累加求r
	}
	while(l<=r){//二分模板
		mid=(l+r)>>1;
		tot=0,now=0;
		if(judge(mid))l=mid+1;
		else r=mid-1;
	}
	write(l);
	return 0;//完成！！！
}
```

欢迎dalao纠错。
谢谢观看，请记住，我太弱了。