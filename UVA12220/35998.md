### 竟然没有题解？自己来一发
这道题貌似没有翻译，先解释下题意吧  
给出一个序列$n$个数，$(1\leq$数的范围$\leq10^6)$，请计算有多少个连续子段和$mod$ $d=0?$  
这道题不是要统计连续子段和么，所以可以很自然的想到用**前缀和统计**  
于是有一种很暴力的做法就是**枚举起点和终点**，暴力前缀和计算，时间复杂度$O(n^2)$  
但这其实是一道数学题（雾  
我先随便给出十个数，看看他们的前缀和再%$10$下的余数  
$5$ $8$ $9$ $6$ $2$ $3$ $2$ $3$ $7$ $4$  
前$i$为和%10的余数分别为,记为$s$数组  
$5$ $3$ $2$ $8$ $0$ $3$ $5$ $8$ $5$ $9$  
如果有一段数$i$~$j$和为$10$的倍数,则$(s[j]-s[i-1])$%$10=0$  
因为$s$都已经对$10$取过余数了,所以$s[j],s[j-1]<10$  
所以条件可化为$s[j]=s[i-1]$  
所以题目就变成了找出所有的$s[j]=s[i-1]$**有多少组**。  
例如上序列中$5$有$3$个，分别在第$1$，$7$，$9$位上  
那么我们可以**选区其中两个数作为起点和终点**，例如$2-7,2-9,8-9$共$C_3^2=3$种  
于是我们**遍历前缀和所有的余数**  
如果当前余数有$k$个，$C_k^2$就是以这个余数为序列的序列个数,**求出所有的和记为答案**  
这题要注意下,所有的余数为$0$的数都可以以$1$为开头。所以数字$0$**出现的次数要**$+1$
## 还有，一定要开long long
被$long$ $long$卡了$1$个小时$QAQ$  
由于怕爆内存，我用了$map$映射,用法和数组差不多
```
#include <bits/stdc++.h>
#define ll long long
using namespace std;
ll n,m,a[50005],b[50005],ans,tim[50005],t,T;
int main()
{
	cin>>T;
	while(T--)
	{
		map<ll,ll> s;//记录每个前缀和，出现多少次
		ll i,j;
		t=0;ans=0;//t表示余数个数，ans统计答案
		memset(a,0,sizeof(a));
		memset(b,0,sizeof(b));
		memset(tim,0,sizeof(tim));//初始化
		cin>>m>>n;
		for(i=1;i<=n;i++)
		{
			cin>>a[i];
			a[i]%=m;
		}
		for(i=1;i<=n;i++)
		{
			b[i]=(b[i-1]+a[i])%m;
		}//统计前缀和
		s[0]=1;//0的个数+1
		t=1;tim[t]=0;//tim记录余数集合，t记录集合大小
		for(i=1;i<=n;i++)
		{
			s[b[i]]=s[b[i]]+1;//b[i]的个数+1
			if(s[b[i]]==1) 
            	tim[++t]=b[i];//如果是第一次出现，那么把他加进余数集合中
		}
		for(i=1;i<=t;i++)
		{
			ans+=s[tim[i]]*(s[tim[i]]-1)/2;//统计C(k)(2)
		}
		cout<<ans<<endl;
	}
	return 0;
} 

```


