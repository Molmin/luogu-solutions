E1 + E2 > G，这个题就很牛逼了。

我们发现，如果连续询问两次同一个集合 $S$，如果这两次回答相同，那么回答一定是真的，可据此减小候选集合。但如果不相同，则浪费了两次询问。所以这样做是不可取的，但它可以给我们一些启发。

E1 和 E2 都有一个非常关键的思想：**对于全集 $U$ 和询问集合 $S$，直接推断出 $C_S = U\backslash S$ 的回答**。这个思想看起来很 simple，但对解题有非常大的帮助。

不要从 $x$ 是否在询问集合 $S$ 的角度评估每次询问的回答，虽然这样做从逻辑上推理也行得通，和接下来的思考方法本质相同，但不是很直观。换种角度，每次询问 $S$ 告诉我们 $x$ 可能在某个集合里面：若回答为 `YES`，则交互库告诉我们 $x$ 在 $S$ 里面，否则交互库告诉我们 $x$ 在 $C_S$ 里面。

因此，对于连续的两次询问 $S, T$，我们可以认为交互库告诉我们 $x$ 在 $S'$ 和 $T'$ 里面。因为这两次询问不可能都为假，所以 $x$ 必然在 $S'\cup T'$ 里面。也就是说，我们将全集缩小至 $S'$ 和 $T'$ 的并。根据询问结果，$S'$ 可能为 $S$，也可能为 $C_S$。同理，$T'$ 可能为 $T$，也可能为 $C_T$。我们的目标是选择合适的 $S, T$，使得无论在何种情况下都能一定程度上缩小全集。

进一步描述上述目标，我们希望最大化以下四个集合的大小的最小值：$S\cap T$，$C_S \cap T$，$S\cap C_T$，$C_S\cap C_T$。容易发现这四个集合两两不交，这启发我们将 $U$ 分成 $U_1, U_2, U_3, U_4$，分别代表上述四个集合，可知 $S = U_1 \cup U_2$，$T = U_1\cup U_3$。

两次询问将 $U$ 减小 $\dfrac 1 4$，最后还要特判 $n = 3$ 的情况，询问次数约为 $2\log_{\frac 4 3} n$，只能通过 E1。$n = 3$ 的做法：询问两次 $a$，若回答相同则简化至 $n = 1$ 或 $n = 2$，若回答不同，询问 $b$，根据回答总可以删去一个数简化至 $n = 2$。也可以直接用这个方法做 E1，询问次数约为 $3\log_{\frac 3 2} n$。

回顾上述做法，我们发现这样做比较劣的原因在于没有利用好所有相邻的两个询问。上一轮的 $T$ 和这一轮的 $S$ 之间也有至少一个真回答的限制，但我们没有利用到。因此，我们希望利用到每两个相邻的询问。

假设当前全集为 $U$，上一次询问交互库告诉我们 $x$ 在 $T$ 里面。我们会在 $T$ 和 $F = C_T$ 中挑选一些数进行询问。设从 $T$ 中挑选 $c$ 个数 $T_0$，从 $F$ 中挑选 $d$ 个数 $F_0$，询问它们的并集 $T_0\cup F_0$，$T_1 = T\backslash T_0$，$F_1 = F\backslash F_0$。若回答为 `YES`，则 $S$ 变成 $T_0\cup F_0$，$U$ 变成 $U\backslash F_1$，$F$ 变成 $T_1$，因为 $x$ 不可能在 $F_1$ 里面。同理，若回答为 `NO`，则 $T$ 变成 $T_1 \cup F_1$，$U$ 变成 $U\backslash F_0$，$F$ 变成 $T_0$。

容易发现 $U, T, F$ 和询问集合具体形态是不重要的，我们只关心这些集合的大小，因此设 $f_{i, j}$ 表示 $|T| = i$，$|F| = j$ 的最小询问次数，则
$$
f_{i, j} = 1 + \min\limits_{0\leq c\leq i, 0\leq d\leq j} \max(f_{c + d, i - c}, f_{i + j - c - d, c})
$$
其中当 $i + j\leq 2$ 时 $f_{i, j} = 0$。

从 $i + j$ 相等但 $j$ 更小的状态转移过来是不优的，因为我们希望 $|F|$ 尽可能大，这样从全集中删去的 $F_0$ 或 $F_1$ 的大小就会更大。因此按照 $i + j$ 为第一关键字从小到大，$j$ 为第二关键字从大到小枚举 $i, j$ 并转移。

直接爆算肯定不行，但我们发现当 $i + j$ 较大的时候，均分 $T$ 和 $F$ 是优的，因为这样 $c + d$ 和 $i + j - c - d$ 差不多，$i - x$ 和 $x$ 也差不多，比较平衡。具体多大呢？赛场上肯定是在时间允许的限制下尽可能大，$100$ 可以通过。因为本题 $53$ 次询问的限制卡得很紧，所以界不能太小。经测试，设为 $i + j < 10$ 再精确计算无法通过，设置 $i + j < 20$ 再精确计算可以通过。[代码](https://codeforces.com/contest/1746/submission/176434282)。