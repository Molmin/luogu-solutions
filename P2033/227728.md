[原题传送门](https://www.luogu.com.cn/problem/P2033)

蒟蒻第二道蓝题，居然一次过的qwq

题意：

- 有一个 $8 \times 8$ 矩阵，有些地方有物品，有一个地方是你

- 你所在位置用 `^` 、`<` 、`>` 、`v` 四个字母中一个表示，你最开始面向的方向就是箭头的朝向

- 有许多条命令，整个输入一一行一个 `#` 结束

- 命令1： `move n` ,表示你要往前(你面向的方向)走 $n$ 步，如果走到矩阵边缘就不走了

- 命令2： `turn XX` 其中 XX 可能是 `right`,`left`,`back`，分别表示向右，向左，向后转

- 重点：你向前走时，如果你前面有物品，则你要推着物品一起走，如果物品前面还有物品，则要一起往前推 $……$

思路：

- 首先，输入时确定好你的方向和位置

- 输入命令时先输入第一个词，然后判断是往前走还是转弯

- 往前走的话就执行 $n$ 次往前走一步

- 转弯的话就把方向 $+$ $m$

可能你不太懂，那就看代码吧，都在注释里了：

```cpp
#include <bits/stdc++.h>//懒人神器
using namespace std;
char q[8][8],vs[4] = {'<','^','>','v'};//q是棋盘，vs是最后输出时纠正方向用的
int fx[4] = {0,-1,0,1},fy[4] = {-1,0,1,0};//炒鸡好用的移动数组
int qx,qy,f;//qx和qy是你的位置，f是方向
string pd;
void d(int x,int y)
{
    int lx = x + fx[f];//预览x
    int ly = y + fy[f];//预览y
    if(lx < 0 || lx > 7 || ly < 0 || ly > 7)//如果越界了
    {
        return;//结束，返回到上一层
    }
    if(q[lx][ly] != '.')//如果当前方向前面有棋子
    {
        d(lx,ly);//以那个棋子递归
    }
    q[lx][ly] = q[x][y];//将棋子往前移动一格
    q[x][y] = '.';//自己走了之后就变为空
    qx = lx;//这里注意，因为只要运行到了这里那最后lx和ly就是你往前走后的位置
    qy = ly;//所以将你的位置设置成lx和ly
}
int main()
{
    for(int i = 0;i < 8;i++)//直接输入
    {
        for(int j = 0;j < 8;j++)//输入
        {
            cin >> q[i][j];
            if(q[i][j] == '<')//方向为左
            {
                f = 0;//设置方向
                qx = i;//设置位置
                qy = j;//设置位置
            }
            if(q[i][j] == '^')//同上
            {
                f = 1;
                qx = i;
                qy = j;
            }
            if(q[i][j] == '>')//同上
            {
                f = 2;
                qx = i;
                qy = j;
            }
            if(q[i][j] == 'v')//同上
            {
                f = 3;
                qx = i;
                qy = j;
            }
        }
    }
    cin >> pd;//先输入
    int a;//move命令所用的
    while(pd != "#")//结束之前
    {
        if(pd == "move")//往前走的命令
        {
            cin >> a;//走多少步
            for(int i = 0;i < a;i++)//简化过程
            {
                d(qx,qy);//参考第7行d函数
            }
        }
        if(pd == "turn")//转向命令
        {
            cin >> pd;
            if(pd == "left")
            {
                f--;//往左
            }
            if(pd == "right")
            {
                f++;//往右
            }
            if(pd == "back")
            {
                f += 2;//往后
            }
            if(f >= 4)//超出了
            {
                f -= 4;//转回去
            }
            if(f < 0)//成了负数
            {
                f += 4;//转回去
            }
        }
        cin >> pd;//再次输入命令
    }
    q[qx][qy] = vs[f];//将你设成当前方向的状态
    for(int i = 0;i < 8;i++)//输出
    {
        for(int j = 0;j < 8;j++)//输出
        {
            cout << q[i][j];//输出，不加空格
        }
        cout << endl;//记得换行
    }
    return 0;//结束
}
```
