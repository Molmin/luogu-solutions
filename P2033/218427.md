# 技巧：
### 方法一
输入中有可能会向四个方向移动，但是把每个方向写一遍会让代码变长，所以我们可以记住四个方向，写一个包含四个方向的函数，通过这个函数，完成移动。**这个函数可以通过递归实现**，如果前面那个点是空的，那么把这个棋子移到前面那个点之后就结束了；如果那个点有棋子，横坐标轴和纵坐标轴都按照方向变化，因为会把前面的棋子推走，而且被推走的棋子可能会有多个，所以递归处理，变化后，从变化过的点开始继续递归，这里也就是核心的代码了，可以大大减少代码量。
```cpp
void yidong(int xx,int yy)//递归的坐标
{
	int nx=xx+fx[z],ny=yy+fy[z];//按方向走后会到哪
	if(nx<1||nx>8||ny<1||ny>8)//如果走出棋盘
		return;//结束了
	if(s[nx][ny]!='.')//如果下一个点不是空
		yidong(nx,ny);//递归
	s[nx][ny]=s[xx][yy];//这个点的棋子到了下一个点
}
```
### 方法二
这个方向是数组唯一可以变化的值，转弯后这个会在"^,>,v,<"四个值中变化，如果每次变化后都要一个一个判断就会让代码变长，我们可以**通过一个数组把这四个方向记录下来**，**还有一个变量来记住现在的方向** ($1$~$3$)，可以通过这个**直接找到对应的字符**。下面是相关的操作。

$1.$刚开始输入
```cpp
for(int k=0;k<=3;k++)//寻找四个方向代表的字符有没有和当前字符相同的
{
	if(f[k]==s[i][j])//如果有
	{
		x=i;//开始的x坐标是i
		y=j;//开始的y坐标是j
		z=k;//开始的方向是k
	}
}
```
$2.$转向
```cpp
cin>>str;//输入方向
if(str=="left")//如果是左边
	z=(z+3)%4;//加上3再对4取模，防止超过3
else if(str=="right")//如果是右边
	z=(z+1)%4;//加上1再对4取模
else //如果都不是，就一定是转到后面
	z=(z+2)%4;//加上2对4取模
s[x][y]=f[z];//现在是新的符号了
```
### 方法三
有四个方向，可以先记录在数组里面，**记住要按顺序，否则会乱**，比如可以这样记录：
```cpp
int fx[4]={-1,0,1,0};
int fy[4]={0,1,0,-1};
```
分别代表↑，→，↓，←。
# 代码：
~~因为我的代码是目前最短的，我就尝试发题解了~~
```cpp
#include <bits/stdc++.h>//头文件
using namespace std;
char s[10][10],f[4]={'^','>','v','<'};//四个方向代表的字符
int fx[4]={-1,0,1,0};//横坐标方向
int fy[4]={0,1,0,-1};//纵坐标方向
int x,y,z,a;//x代表横坐标，y代表纵坐标，z代表方向
void yidong(int xx,int yy)//递归的坐标
{
	int nx=xx+fx[z],ny=yy+fy[z];//按方向走后会到哪
	if(nx<1||nx>8||ny<1||ny>8)//如果走出棋盘
		return;//结束了
	if(s[nx][ny]!='.')//如果下一个点不是空
		yidong(nx,ny);//递归
	s[nx][ny]=s[xx][yy];//这个点的棋子到了下一个点
}
int main()//主函数
{
	string str;//读入的命令
	for(int i=1;i<=8;i++)//有八行
	{
		for(int j=1;j<=8;j++)//有八列
		{
			cin>>s[i][j];//输入棋盘第i行第j列状态
			for(int k=0;k<=3;k++)//四种方向
			{
				if(f[k]==s[i][j])//如果是其中一种
				{
					x=i;//开始在第i行
					y=j;//开始在第j列
					z=k;//第k种
				}
			}
		}
	}
	while(cin>>str)//当能输入
	{
		if(str[0]=='#')//如果结束了
			break;//跳出循环
		if(str[0]=='t')//当命令是旋转时
		{
			cin>>str;//输入字符串
			if(str=="left")//如果是向左
				z=(z+3)%4;//加三个，如减一，可能成为负数
			else if(str=="right")//如果向右
				z=(z+1)%4;//加一
			else //如果都不是
				z=(z+2)%4;//加二再对四取模
			s[x][y]=f[z];//这个地图这个点改变了
		}
		else//如果是移动
		{
			cin>>a;//输入一个数
			for(int i=1;i<=a;i++)//循环a次，每次只处理一次移动，更加简单
			{
				yidong(x,y);//在这个点进行移动
				int nx=x+fx[z],ny=y+fy[z];//计算移动后的横坐标和纵坐标
				if(nx>0&&nx<9&&ny>0&&ny<9)//如果不出棋盘
				{
					s[x][y]='.';//这个点空了
					x=nx;//下一个点的行坐标更新
					y=ny;//下一个点的纵坐标更新
				}
			}
		}
	}
	for(int i=1;i<=8;i++)//从第一行到最后一行
	{
		for(int j=1;j<=8;j++)//从第一列到最后一列
		{
			cout<<s[i][j];//输出最后答案
		}
		puts("");//空一行
	}
	return 0;//别忘了
}
```
# 感谢：
### 感谢管理审核，感谢大家观赏
