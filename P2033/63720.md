作者使用了**位域**完成了这题。

引入：
> 有些信息在存储时，并不需要占用一个完整的字节， 而只需占几个或一个二进制位。例如在存放一个开关量时，只有0和1 两种状态， 用一位二进位即可。为了节省存储空间，并使处理简便，Ｃ语言又提供了一种数据结构，称为“位域”或“位段”。所谓“位域”是把一个字节中的二进位划分为几 个不同的区域，并说明每个区域的位数。每个域有一个域名，允许在程序中按域名进行操作。 这样就可以把几个不同的对象用一个字节的二进制位域来表示。  
> ——摘自 csdn博客 sty124578

[右转了解位域 in luogu blog](https://www.luogu.com.cn/blog/hkxa/introduction-BitField)

这里处理转向，使用位域将会非常方便。  
首先定义移动用数组
```cpp
const int xx[] = {1, 0, -1, 0}, yy[] = {0, -1, 0, 1};
```
注意到如果这样写，
- $(xx[0],yy[0])$就对应向下
- $(xx[1],yy[1])$就对应向左
- $(xx[2],yy[2])$就对应向上
- $(xx[3],yy[3])$就对应向右

然后考虑到 4 种情况，方向值 ``dir`` 是在 $\bmod\ 2^2$ 意义下的。
所以定义
```cpp
struct pos {
    int x, y;
    uint8 dir : 2;
    void turn(char ch)
    {
        switch (ch) {
            case 'l' : dir--; break; // left
            case 'r' : dir++; break; // right
            case 'b' : dir ^= 2; break; // back
        }
    }
};
```
注意到 ``turn`` 函数里，我没有使用模运算，而是直接加，减。（对于 ``turn back`` 操作，``+2/-2`` 在 $\bmod\ 2^2$ 意义下只需要改变第 2 个 bit 的值即可，所以对于 ``dir ^= 2`` 请感性理解）

[AC Code](/paste/dxt4tpng)