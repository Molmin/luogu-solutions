[传送门](https://www.luogu.com.cn/problem/UVA1189)

先贴个三倍经验：[UVA1189](https://www.luogu.com.cn/problem/UVA1189)，[P2841](https://www.luogu.com.cn/problem/P2841)，[P1988](https://www.luogu.com.cn/problem/P1988)。

这一题明显搜索。可以考虑用深搜，但深搜过不了 P2841，所以我还是推荐广搜。

这一题的搜法是每次将当前的值的最末尾添上一个 $0$ 或 $1$，然后往下搜。若当前的值为 $n$ 的倍数时就退出。其实就是两种不同情况：$x\times 10$ 和 $x\times 10+1$，其中 $x$ 为当前的值。

写到这应该就可以过这道题了。但是当你将这份代码稍微改动后去交 P2841 时就会发现，你会喜提 MLE。其实 MLE 的原因很简单，无非就是队列开的空间太大了呗，此时我们枚举 $n$ 为 $1$ 到 $9$ 时的答案会发现，当 $n$ 为 $9$ 时，答案的位数有 $9$ 位，比 $1$ 到 $8$ 的都多了许多，这就说明是因为与 $9$ 具有相同倍数特征的这类数字使我们获得了 MLE。

那么我们该怎么办，当然是特判了。

$9$ 的倍数特征是啥，是每一位上的数相加为 $9$ 的倍数。在这题中，我们能组成的数每一位只能是 $0$ 或 $1$。我们又要让这个 $9$ 的倍数小，就要使其位数少，那么答案就只能是 $111111111$。像与 $9$ 的倍数特征有联系的数 $99$，$999$，$9999$ 这几个数的答案分别为 $111111111111111111$，$111111111111111111111111111$，$111111111111111111111111111111111111$。证明过程很简单。因为你要位数少，所以你就不能在其中含有 $0$，因为 $0$ 对这个数的各个位数之和没有贡献，只能占位，所以就只能全是 $1$。并且 $99$ 的倍数特征是每两位数数字之和为 $99$ 的倍数，所以 $99$ 在本题中的最小倍数就是含有 $9$ 个 $11$ 的数，$999$ 和 $9999$ 的证明也都一样。当然的，在本题中，你可以不用输出最小倍数，但在 P2841 和 P1988 需要。

这里我就只贴本题的代码。注：P2841 需要开 int128。

# CODE:
```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
inline __int128 read()
{
	__int128 x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-') f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9') x=x*10+(ch-'0'),ch=getchar();
	return x*f;
}
inline void write(__int128 x)
{
	if(x>9) write(x/10);
	putchar(x%10+'0');
}
inline void bfs()
{
	queue<__int128> q;
	q.push(1);
	while(!q.empty())
	{
		__int128 x=q.front();
		q.pop();
		if(x%n==0)
		{
			write(x);
			printf("\n");
			return;
		}
		q.push(x*10),q.push(x*10+1);
	}
}
int main()
{
	while(1)
	{
		scanf("%d",&n);
		if(n==0) return 0;
		if(n==9)
		{
			printf("111111111\n");
			continue;
		}
		if(n==99)
		{
			printf("111111111111111111\n");
			continue;
		}
		bfs();
	}
	return 0;
}
```