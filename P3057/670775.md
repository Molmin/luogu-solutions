一眼图论题。

由于此题数据较小，并且可以朝四个方向走，所以考虑建图跑最短路，如果此题只能朝右下两个方向走，就考虑动态规划，因为动态规划是通过最优子结构性质得到答案的，而本题一个点可能会被重复更新。

对于每一个点，朝与它相邻的四个点建边，介于此题的数据范围，Floyd 算法无法通过，所以我们采用堆优化的 Dijkstra 算法，时间复杂度为 $O(nm\log m)$，其中 $m$ 为边数。

但由于此题数据较水，所以 Floyd 算法也能通过，但我们接下来重点讲的是对 Floyd 算法的优化。

以下是正常的 Floyd 算法代码：
```cpp
for(int k=1;k<=n;k++) for(int i=1;i<=n;i++) for(int j=1;j<=n;j++) a[i][j]=min(a[i][j],a[i][k]+a[k][j]);
```
以下是优化的 Floyd 算法代码：
```cpp
for(int k=1;k<=n;k++) for(int i=1;i<=n;i++) {
	if(a[i][k]==1e9) continue;
	for(int j=1;j<=n;j++) a[i][j]=min(a[i][j],a[i][k]+a[k][j]);
}
```
非常好理解，如果这一条边无法对任何边进行松弛，则这条边无用。

优化后的 Floyd 算法时间复杂度上界为 $O(n^3)$，下界为 $O(n^2)$。

这是我两份代码的时间差距，[这一篇代码](https://www.luogu.com.cn/record/102893135)没有加优化，而[另一篇代码](https://www.luogu.com.cn/record/102890804)有。

可以看到，两份代码的时间差距还是非常大的，差了将近两倍。