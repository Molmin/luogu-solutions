省流：分治、可撤销+扩展域并查集。

---

首先“前缀+后缀”的这个形态有点烦。转化需要技巧：把数组复制一份粘贴在后面，后缀加前缀就是一个连续区间了。

我们定义 $f$ 数组，$f_i$ 是满足 $[i,f_i]$ 有奇环的最小值。看区间 $[L,R]$ 是否有奇环就可以看 $f_L$ 是否 $\ge R$。

然后考虑怎么求出 $f_i$。我们知道 $f_i\ge i$ 且是单调不降的。

这个时候自然的想到双指针，双指针的过程中需要数据结构维护，数据结构需要做加边、删边、查奇环。支持加边和查奇环？trick 我没见过也不会，就被初见杀了。

解法可以使用连反边的扩展域并查集。如果每条边加入时我们都连上反边，如果一条边加入时两个点已经在一个集合而非相反的两个集合，说明产生了奇环（后者是偶环情况）。

但是并查集无法删除任意的一条边。而且当计算的位置 $p\gets p+1$ 时，要被删掉的边 $p$ 是最先加入的边。这下不会了。

然后考虑设计结合值域，设计分治函数来计算。

定义函数 `sol(l,r,vl,vr)`，作用是计算 $f_l,\cdots,f_r$，限制是 $f_l\le\cdots\le f_r$ 在值域区间 $[v_l,v_r]$ 中。

因为不好从值域上入手来计算，所以分治就直接找编号中点 $p=\dfrac{l+r}2$，然后计算其答案，这个答案还是要用数据结构。

因为分治算法，我们认为复杂度必须基于 $l\cdots r$ 和 $v_l\cdots v_r$，因此需要在数据结构里

+ 事先加 $r\cdots v_l$ 的边（如果在分治函数里加就复杂度不对了）。
+ 然后加 $p\cdots r$ 的边。
+ 最后从 $v_l$ 开始一条一条加，加到出现奇环的时候就是答案。

思路是清晰。用什么数据结构维护呢？这个问题不同于上面的双指针。要删除的是最后加的边（$p\cdots r$ 和 $v_l\cdots f_p$），这样与其说是“删除”，不如说是“撤销”。

刚刚说加边和查奇环要用并查集但并查集不能删除。这里是撤销。而并查集可以通过以下来做到可撤销。

+ 去掉路径压缩。这时因为保证不了复杂度，所以加上启发式合并。
+ 每一次合并（`fa[x]=y,siz[y]+=siz[x]`），记录下此时的 $x,y$。
+ 撤销（$\tt undo$）就 `fa[x]=x,siz[y]-=siz[x]` 就行了。

---

事实上分治部分细节不少。

+ 对于 $\mathtt{sol}(l,r,v_l,v_r)$
+ 找到中点 $p=\dfrac{l+r}2$，加入 $p\cdots r$ 的边
+ 从 $v_l$ 开始一条一条加，加到出现奇环时记录为 $f_p$。
+ 撤销上两步操作。
+ 分治：计算 $\mathtt{sol}(l,p-1,v_l,f_p)$
+ 算之前记得把 $[p,v_l)$ 的边加入到并查集，算之后再撤销。
+ 分治：计算 $\mathtt{sol}(p+1,r,f_p,v_r)$
+ 算之前记得把 $(r,f_p)$ 的边加入到并查集，算之后再撤销。
+ 上两步的复杂度你可能疑惑（这不是涉及到了 $r\cdots v_l$ 吗）其实这里面有一部分是已经加了的（$[p,v_l)\cap(r,v_l)$ 和 $(r,f_p)\cap(r,v_l)$），只要加没有加过的部分复杂度就是对的。

