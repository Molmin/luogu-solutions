不难发现一条路径合法当且仅当其单峰或单调，且恰好有两种操作方式。

Ember 所选择的树一定不会让 Storm 有赢的机会，则对于每一棵 Storm 不可能赢的树，都有 $2n(n - 1)$ 种操作方式。

于是我们只需要统计有多少棵 $n$ 个点、度数 $\leq d$ 的树满足**每条路径要么单峰，要么单调**。

考虑抓出一个特殊点，使得以它为根时到所有点的路径**均单调**。下面来证明这个点为啥一定存在：

- 考虑反证法，不存在时显然存在至少一条单峰路径，设其峰为 $u$。
- 此时一定存在一个叶子 $v$，使得 $u \to v$ 的路径是单峰的。
- 若 $u$ 还有其他儿子，则一定不合法；否则，将 $u$ 移到 $v$ 处，此时 $v$ 的儿子数量 $\geq 2$，则可以同上讨论。

现在考虑哪些点可能作为特殊点。从一个已有的特殊点 $u$ 出发，若 $u$ 的儿子中有恰好一个 $v_0$ 使得 $[v_0 < u]$ 与其他儿子 $v_1$ 的 $[v_1 < u]$ 都不同，则 $v_1$ 也可以为特殊点。

于是我们可以感性理解出**所有特殊点一定在一条链上**。

现在考虑 dp。设 $dp_{i, j}$ 表示以某个特殊点为根的子树大小为 $i$，儿子个数为 $j$ 的方案数。

初值：$dp_{1, 0} = 1$。

转移如下：

- 考虑在特殊点组成的单调路径上从小到大讨论。
- 这里我们只关心相对大小，则钦定子树内值域为 $[1, i]$，根为 $1$。
- 考虑每次添加一个根为 $2$ 的子树（即钦定顺序），则 $dp_{i, j} = \displaystyle\sum_{k = 1}^{i - 1} C_{i - 2}^{k - 1} dp_{i - k, j - 1} \sum_{l = 0}^{\min(k, d) - 1} dp_{k, l}$。

答案如下：

- 考虑合并以最上面的关键点为根向下延伸的单调递减和递增的路径，则答案**看上去**为 $\displaystyle\sum_{i = 1}^n \sum_{j = 0}^d \sum_{k = 0}^{d - j} dp_{i, j} dp_{n - i + 1, k}$。
- 但你发现这样答案会偏大，因为关键点个数不为 $1$ 时我们会在每个关键点的位置各算一遍。
- 根据单调性注意到一个特殊点不在特殊点组成的链的底端时当且仅当 $k = 1$，于是我们钦定 $k \neq 1$ 统计答案即可。

前缀和优化 dp 即可。时间复杂度为 $O(n^2 d)$。

代码：
```cpp
#include <stdio.h>

typedef long long ll;

ll c[207][207], dp[207][207], sum[207];

inline void init(int n, int mod){
	c[0][0] = 1;
	for (int i = 1; i <= n; i++){
		c[i][0] = 1;
		for (int j = 1; j <= i; j++){
			c[i][j] = ((ll)c[i - 1][j] + c[i - 1][j - 1]) % mod;
		}
	}
}

inline int min(int a, int b){
	return a < b ? a : b;
}

int main(){
	int n, d, p;
	ll ans = 0;
	scanf("%d %d %d", &n, &d, &p);
	init(n, p);
	dp[1][0] = sum[1] = 1;
	for (int i = 2; i <= n; i++){
		int up = min(i - 1, d);
		for (int j = 1; j <= up; j++){
			for (int k = 1; k < i; k++){
				dp[i][j] = (dp[i][j] + c[i - 2][k - 1] * dp[i - k][j - 1] % p * sum[k] % p) % p;
			}
			if (j < d) sum[i] = (sum[i] + dp[i][j]) % p;
		}
	}
	for (int i = 1; i <= n; i++){
		int oppo = n - i + 1;
		for (int j = 0; j <= d; j++){
			for (int k = 0; j + k <= d; k++){
				if (k != 1) ans = (ans + dp[i][j] * dp[oppo][k] % p) % p;
			}
		}
	}
	printf("%lld", ans * (2 * n * (n - 1)) % p);
	return 0;
}
```