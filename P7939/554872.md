# 1.前言
因为用 $1$ 代表石头，$2$ 代表剪刀，$3$ 代表布。所以我们可以得到 "1>2,2>3,3>1"。

每一组的样例输入应该是这样的：
```
n
a[1] a[2] ... a[n]
b[1] b[2] ... b[n]
```
我们的目标是让 a 数组得分尽量高。
# 2.解析
- 样例第一行：分数的计算

因为我们每一组都能改变 $n$ 次，那我们相当于 a 数组和 b 数组一共能改 $2n$ 次，即使 b 数组每次都是胜利的，那我们可以通过 $n$ 次改变 a 数组使得分数 $+n$，通过 b 数组的 $n$ 次，让 b 输，使得分数 $+n$。

如果 a 本来就赢了一些分，那就可以省一些次数，还能保证分数是 $2n$。

- 输出结果

现在我们已经算出分数，只要构造一种结果：
显然全部让 a 数组大于 b 数组或者将 b 数组全部输给 a 数组都是不能满足“每一组改变 $n$ 次”的，那么我们如何保证每一组都改变 $n$ 次以内呢？

接下来我称改变一个数使得 a 赢为一次操作。

我们用一个 f 来记录是偶数次还是奇数次操作，初始的时候 $f=true$。如果是奇数次，我们改变 a 数组的数，然后让 $f=false$；到了偶数次的时候 $f=false$，改变 b 数组的数再让 $f=true$...这样一来，操作一次 a 数组，操作一次 b 数组，使得最后，每个数组的操作次数都小于等于 $n$，符合题意。

由 "1>2,2>3,3>1" 得到以下代码：
```cpp
	if(a[i]==1&&b[i]==3){
		if(f==1) a[i]=2,f=0;
		else b[i]=2,f=1;
	}//1<3，调整根据f调整a或b
	if(a[i]==2&&b[i]==1){
		if(f==1) a[i]=3,f=0;
		else b[i]=3,f=1;
	}//2<1，调整根据f调整a或b
	if(a[i]==3&&b[i]==2){
		if(f==1) a[i]=1,f=0;
		else b[i]=1,f=1;
	}//3<2，调整根据f调整a或b
```
重点来处理一下相等：

同样的，当 $f=true$。我们将 a 数组的数 $-1$，例如原来都是 $2$，a 数组 $-1$ 之后变成 $1$，因为 "1>2" 所以 a 得分；特别地，当 a 与 b 的数都是 $1$ 时，a 要变成 $3$，而不是 $0$，因为 "3>1"，而不是 "0>1"。然后让 $f=false$；偶数的时候 b 数组的数要 $+1$，特别地，当 a 与 b 都是 $3$ 的时候，b 要变成 $1$，而不是 $4$。

于是可以得到以下代码：
```cpp
	if(a[i]==b[i]){
		if(f==1){
			a[i]-=1;//a-1
			if(a[i]==0) a[i]=3;//1-1=0→3
			f=0;
		}
		else{
			b[i]+=1;//b+1
			if(b[i]==4) b[i]=1;//3+1=4→1
			f=1;
		}
	}
```
所以操作就完成了。
# 3.code
```cpp
#include<bits/stdc++.h>
using namespace std;
int q,n,a[1000010],b[1000010];
signed main(){
	scanf("%d",&q);
	while(q--){
		bool f=1;
		scanf("%d",&n);
		n*=2;//注意这里
		for(int i=1;i<=n;i++) scanf("%d ",&a[i]);
		for(int i=1;i<=n;i++) scanf("%d ",&b[i]);
		for(int i=1;i<=n;i++){
			if(a[i]==1&&b[i]==3){
				if(f==1) a[i]=2,f=0;
				else b[i]=2,f=1;
				continue;
			}
			if(a[i]==2&&b[i]==1){
				if(f==1) a[i]=3,f=0;
				else b[i]=3,f=1;
				continue;
			}
			if(a[i]==3&&b[i]==2){
				if(f==1) a[i]=1,f=0;
				else b[i]=1,f=1;
				continue;
			}
			if(a[i]==b[i]){
				if(f==1){
					a[i]-=1;
					if(a[i]==0) a[i]=3;
					f=0;
				}
				else{
					b[i]+=1;
					if(b[i]==4) b[i]=1;
					f=1;
				}
				continue;
			}
		}
		printf("%d\n",n);//结果是2n，输出n的原因是上面n*2
		for(int i=1;i<=n;i++) printf("%d ",a[i]);
		printf("\n");
		for(int i=1;i<=n;i++) printf("%d ",b[i]);
		printf("\n");
	}
}
```
虽然是 $n$ 次，但是有 $2n$ 个人比赛，所以将 $n$ 扩大 2 倍。为了提升速度，操作完成一次之后，不需要继续判断（此时 a 已经赢了），要加 continue。

求赞qwq