这种求合法方案数的题，先考虑如何判定一个数列合法。

维护一个栈，使得栈中有一个分界线，满足分界线下的数都为$1$，线上的数都为$0$。

从左往右依次将数列中每一个数加入栈中，有几种情况：

如果加入的数是 $1$ ：

1. 若栈顶为 $0$ ，则加入的 $1$ 可以与 $0$ 抵消掉。因为这两个数与下一个数的中位数取决于下一个数是 $0$ 还是 $1$ 。

2. 若栈顶为 $1$ ，则如果栈内有两个 $1$ ，不入栈，因为两个及以上个 $1$ 的中位数一定为 $1$ 。反之直接入栈。

如果加入的数是 $0$ ：

1. 若栈顶是 $0$ ，则如果栈内有两个 $0$ ，则可以抵消成一个 $0$。反之直接入栈。

2. 若栈顶是 $1$ ，直接入栈。

最后如果栈内 $1$ 的个数不小于 $0$ 的个数，那么整个数列操作后的数为 $1$ 。

---

发现栈中 $0,1$ 的个数都不超过2，于是可以将栈的形态作为状态进行dp。设 $f_{i,a,b}$ 表示当前将要加入的数的下标为 $i$ ，当前栈中有 $a$ 个 $1$ , $b$ 个 $0$ 。

如果当前数是 $?$ ，两种情况都转移即可。

---

Code:

```cpp
#include <iostream>
#include <cstring>
#include <cstdio>
#include <algorithm>
#define maxn 300005
#define R register
#define INF 0x3f3f3f3f
#define lxl long long
#define mod 1000000007
using namespace std;

inline lxl read()
{
	lxl x=0,f=1;char ch=getchar();
	while(ch<'0'||ch>'9') {if(ch=='-') f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9') {x=(x<<1)+(x<<3)+ch-'0';ch=getchar();}
	return x*f;
}

char s[maxn];
lxl n,a[maxn],f[maxn][3][3];

int main()
{
	//freopen("AT3950.in","r",stdin);
	scanf("%s",s);
	n=strlen(s);
	for(R int i=0;i<n;++i)
		a[i+1]=s[i]=='?'?-1:s[i]-'0';
	f[1][0][0]=1;
	for(R int i=1;i<=n;++i)// 刷表法
	{
		if(a[i]==1)
		{
			f[i+1][0][0]+=f[i][0][1];
			f[i+1][0][1]+=f[i][0][2];
			f[i+1][1][0]+=f[i][0][0]+f[i][1][1];
			f[i+1][1][1]+=f[i][1][2];
			f[i+1][2][0]+=f[i][1][0]+f[i][2][1]+f[i][2][0];
			f[i+1][2][1]+=f[i][2][2];
		}
		else if(a[i]==0)
		{
			f[i+1][0][1]+=f[i][0][0]+f[i][0][2];
			f[i+1][0][2]+=f[i][0][1];
			f[i+1][1][1]+=f[i][1][0]+f[i][1][2];
			f[i+1][1][2]+=f[i][1][1];
			f[i+1][2][1]+=f[i][2][0]+f[i][2][2];
			f[i+1][2][2]+=f[i][2][1];
		}
		else
		{
			f[i+1][0][0]+=f[i][0][1];
			f[i+1][0][1]+=f[i][0][2];
			f[i+1][1][0]+=f[i][0][0]+f[i][1][1];
			f[i+1][1][1]+=f[i][1][2];
			f[i+1][2][0]+=f[i][1][0]+f[i][2][1]+f[i][2][0];
			f[i+1][2][1]+=f[i][2][2];
			f[i+1][0][1]+=f[i][0][0]+f[i][0][2];
			f[i+1][0][2]+=f[i][0][1];
			f[i+1][1][1]+=f[i][1][0]+f[i][1][2];
			f[i+1][1][2]+=f[i][1][1];
			f[i+1][2][1]+=f[i][2][0]+f[i][2][2];
			f[i+1][2][2]+=f[i][2][1];
		}
		for(R int a=0;a<3;++a)
			for(R int b=0;b<3;++b)
				f[i+1][a][b]%=mod;
	}
	lxl ans=(((f[n+1][0][0]+f[n+1][1][0])%mod+f[n+1][2][0])%mod+f[n+1][2][1])%mod+f[n+1][2][2];
	printf("%lld\n",ans%mod);
	return 0;
}
```
