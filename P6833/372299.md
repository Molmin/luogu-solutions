这道题和 P6832 一样，都很新颖。

首先讲一下赛时很多人骗到 $10$ 分的方法：首先把 $b,c$ 按从小到大排序。由于点权全部为 $1$，可以采用 bfs 的思路，走直线最近。注意对最后一行的额外水平距离的处理（也就是判断雷雨和两个终点的位置关系））

接下来讲正解。观察样例解释中的图片。明显可以看出图中有一个交点，连接了三条路线。

![](https://cdn.luogu.com.cn/upload/image_hosting/mwxooqp0.png)

这给我们两个思路：
1. 暴力思路——枚举交点；
2. 类双向 bfs 思路——从三个源点搜最短路，再枚举交点。

显然，暴力思路有很多的浪费。因此我们选择第二种才能 AC。**注意，SPFA 已经死了 我们不能使用 SPFA** ~~其实是因为SPFA不能跑网格图~~。

至于本题的代码，这里就不贴了。只是提几个注意事项：
1. Dijkstra 搞成扩展点权；
2. 源点到自己的距离是自己的点权
3. 要跑三遍 Dij，注意卡常。
4. **枚举交点时交点会被算三次，注意减掉两次**。

这里简单讲下 Dij 的实现：

利用结构体 `vertex` 记录节点的**坐标和 dis**；Dijkstra 的优先队列每次推入结构体（而非点编号），然后贪心地维护一个 `dis[3][maxn][maxn]` （第一维是 $3$ 代表 $3$ 次 Dijkstra）即可！可以参考 `bfs` 广搜中常用的 `dx,dy` 数组标记移动方向。别忘了用 `vis` 标记数组剪枝~

## 那么这篇题解究竟有什么特别的地方呢？
答案是 `bitset`。

`bitset` 是 C++ STL 中的一种专门存储**真正的**布尔型变量的容器。其头文件是 `bitset.h`，当然你也可以用万能头。`bitset` 最大的优点是每一个变量真的**只占用 1bit**。[这里](https://www.luogu.com.cn/paste/87bpo37x)是 `bitset` 的一些操作。


这样我们就可以使用 `bitset` 这种紧凑的数据结构存储 `bool` 数组啦！

例如，`vis` 数组的下面两种写法等价：
```cpp
bool vis[maxn][maxn];
bitset<maxn>vis[maxn];
```

## 完结撒花~求赞求互关QAQ