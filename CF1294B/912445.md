题目传送门：[CF1294B Collecting Packages](https://www.luogu.com.cn/problem/CF1294B)

# 题意

在一个平面上，有 $n$ 个点，现在有一只机器人在坐标 $(0,0)$，每次只能朝上或者朝右走。

现在请你输出一种收集所有点的方法，使得其代价最小，如果有多种方案则输出字典序最小的一种。代价为机器人走的步数。

# 思路

题目要求输出一种收集点的方法，使得其代价最小，同时还要按字典序排序。因为机器人只能向上或向右走，所以肯定是将所有点按照横纵坐标的和来排序，这样除了第一个点 $(0,0)$ 以外，其余每一个点的横纵坐标的和都大于前一个点，使得机器人肯定能从前一个点到达这个点。

如果我们将点按照横纵坐标的和进行排序，那么对于这个点 $(x_i,y_i)$：

- 如果 $x_i>x_{i-1}$，那么肯定是机器人先向右再向上，直到到达 $(x_i,y_i)$；
- 如果 $y_i>y_{i-1}$，那么肯定是机器人先向上再向右，直到到达 $(x_i,y_i)$。

那么只需要按照横纵坐标之和递增的顺序选择每个点，判断它能否按照上述规则到达即可。注意，如果存在一个点不满足，那么就无解。

最后，如果成功收集所有的点，就输出对应方案。

时间复杂度：$O(n\log n)$。

# 注意事项

- 为了满足字典序最小的要求，我们可以选择尽量先向右走，后向上走。
- 单组数据输出完毕后要换行，否则会被认为是输出不正确。

# 代码：
```cpp
#include<bits/stdc++.h>
using namespace std;

// 定义一个结构体存储每个点的横纵坐标
struct Node {
    int x, y;
} a[MAXN];

// 排序函数，按照横纵坐标之和递增的顺序排序
bool cmp(Node x, Node y) {
    return x.x + x.y < y.x + y.y;
}

int main() {
    // 输入数据组数
    int t;
    cin >> t;
    while (t--) {
        // 定义一个字符串用于存储结果
        string ans = "";
        // 输入点的个数
        int n;
        scanf("%d", &n);
        // 输入每个点的横纵坐标
        for (int i = 0; i < n; ++i) {
            cin >> a[i].x >> a[i].y;
        }
        // 按照排序函数排序
        sort(a, a + n, cmp);
        // 初始化机器人当前的位置为 (0,0)
        int x = 0, y = 0;
        // 遍历所有点
        for (int i = 0; i < n; ++i) {
            // 如果从上一个点能够直接垂直走到当前点
            if (x <= a[i].x && y <= a[i].y) {
                // 先向右走一段距离，距离为当前点的横坐标减去机器人的横坐标
                ans += string(a[i].x - x, 'R');
                // 再向上走一段距离，距离为当前点的纵坐标减去机器人的纵坐标
                ans += string(a[i].y - y, 'U');
                // 更新机器人的位置为当前点
                x = a[i].x;
                y = a[i].y;
            } else {
                // 如果从上一个点无法到达当前点，则直接退出循环，输出 "NO" 
                ans = "NO";
                break;
            }
        }
        // 输出结果
        cout << (ans != "NO" ? "YES\n" + ans + "\n" : "NO\n");
    }
    return 0;
}
```

