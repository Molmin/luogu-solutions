## 最简解法

这道题不需要模拟！不需要贪心！只要想通了小学生都能写！请大佬们回避。

根据题意，我们发现，最默认的解法就是把牌从一头一次次挪到另一头，每次都使被挪完的牌堆满足平均值，即每次完成一个牌堆，完成倒数第二个的时候最后一个也完成了，即次数 times = n - 1。

进一步分析，为什么答案并非绝对是n - 1？我们发现若中间某一次挪完以后刚好使得下一个牌堆也满足平均值时，此时可以少挪一次。此时，这一组牌堆恰好每个都满足平均值，这一组排堆的内部平均值便是等于平均值，即组内和 = 组内元素数 * 平均值。

于是我们发现，只需要找到有多少组连续的牌堆满足其内部平均值等于总平均值这个条件即可，与挪牌方向无关。所以不需要每一次去模拟运算牌堆的移动。于是此时次数 = n - 组数（组数 >= 1)。

到这里已经很显然了，用一次遍历就能解决。

（看了一下别人的代码，发现可以加一次预处理，把每个数据减去平均值，求和时只需检验是否等于0。总之就是不用算什么乘法了，又优化一点。）

第一次写题解……

```cpp
#include <cstdio>
using namespace std;

int main(){
    int n;
    scanf("%d", &n);
    
    int val[n];
    long sum = 0, average;
    for (int i = 0; i < n; i++){
        scanf("%d", &val[i]);
        sum += val[i];
    }
    average = sum / n;
    sum = 0;
    
    int times = n;
    for (int i = 0; i < n; i++){
        sum += val[i];
        sum -= average;
        if (sum == 0) times--;
    }
    
    printf("%d", times);
    return 0;
}
```
