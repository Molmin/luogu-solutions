# P1031 均分纸牌

下面给出线性算法(O(n))和分治算法(O(n^2))，其中分治算法的正确性显见，而线性算法的正确性可由分治算法得出

## 线性算法

* 关键点：当前堆数量可为负数

* 步骤

  从左到右遍历数组

  1. 若大于目标值，则将多余数量转移给下一元素，移动次数(最终结果)+1
  2. 若小于目标值，则从下一元素支取所差数量(透支不影响结果)，移动次数+1
  3. 若等于目标值，跳过

* 复杂度

  显然O(n)

## 分治算法

* 算法

  对于区间[lo,hi)

  1. 若区间内元素小于2个，返回0
  2. 找到区间内元素最大值
  3. 若最大值为目标值，返回0
  4. 遍历最大值左边元素，找到还差多少，记为left；遍历最大值右边元素，找到还差多少，记为right
  5. 将最大值元素值置为目标值，记当前移动次数total=0
  6. 若left不为0，则最大值元素的左边第一个元素值加上left.，total++；若right不为0，则最大值元素的右边第一个元素值加上right，total++
  7. 分别对最大值元素左边区间和右边区间递归执行该算法，total加上它们返回的值，作为当前区间执行算法的返回值

* 正确性

  该算法实际上就是实际寻找的过程，正确性显然

* 复杂度

  该算法与快排很类似，都为找到轴点(这里是最大值)，进行二分，因此可类似快排构造最坏情况

  因此算法复杂度为O(n^2)

  但平均性能应该也为O(log n)，类似快排，若每次最大值都在中间，则有递归式T(n) = 2T(n/2) + O(n)，因此主定理解得O(log n)

## 线性算法正确性证明

* 算法正确性证明

  考虑分治算法得到的一个最优解，证明线性算法得到的解与其等价(最少移动次数相同)　

  记初始数组为A

  每次移动都可以用一个三元组(u,v,w)来刻画，表示从A[u]取w转移到A[v]，满足|u-v|=1,w>0

  由此由分治算法得到的解应该是一个操作序列，其中集合元素为上述三元组，满足每一次的操作都是合法的(不会出现透支)，集合元素个数最少

  再将这个操作集合用图来建模，图的节点代表堆，(u,v,w)代表从u指向v的一条权重为w的有向边，称上述最优解对应的图为最优图

  下面证明(注意下面所说的最优操作序列都是由分治算法得到)

  1. 最优图不存在重边，即若最优操作序列中存在(u,v,w)，则不存在(u,v,w1)或者(v,u,w2)

     考虑分治算法的操作流程，每次迭代都找到一个最大值，并对最大值两边的区间(都不包含最大值)，进行相同处理，而每次迭代最多进行2次移动操作，即最大值分别向左右两边移动一定数值，而之后的迭代将不再与该最大值相关(因为后面的区间都不包含它)，所以不会出现重边

  2. 最优图的边去掉方向后，每个连通分量对应的子图都为一条欧拉路径

     由(u,v,w)满足|u-v|=1和不存在重边立即得到

     注意该图不一定连通，这对应着分治算法中最大值为目标值的情况，此时将不会存在移动，即该节点不会有边与其相连

  3. 改变最优图边的生成方式，即等价于线性算法

     对最优图进行改变，对于每条边(u,v,w)，若u<v，则不变;若u>v，则去掉该边，加上一条(v,u,-w)，权重为负数

     此时节点序号从小到大遍历，对于节点i和节点i+1，若不存在边(i,i+1,w)，则继续遍历下一节点;若存在，w>0则从当前节点i对应堆移动w到下一节点，w<0则节点i+1对应堆向节点i对应堆移动-w，w=0，则继续遍历下一节点

     经过上述操作，每个节点值都将成为目标值，满足要求，同时由其步骤，显然就是线性算法的运行步骤，而最优图是由分治算法得到的，因此由分治算法正确性即可得到线性算法的正确性

[欢迎关注我的github的算法练习~](https://github.com/monellz/algo)