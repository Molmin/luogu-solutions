## NOIP系列题解第一弹-均分纸牌:P

### 均分纸牌是一个古老的游戏
规则：童鞋们有n堆牌，经过有限次移动之后使得每堆纸牌的数量相等。

来看下题目：

有NN堆纸牌，编号分别为 1,2,…,N1,2,…,N。每堆上有若干张，但纸牌总数必为NN的倍数。可以在任一堆上取若干张纸牌，然后移动。

移牌规则为：在编号为11堆上取的纸牌，只能移到编号为22的堆上；在编号为NN的堆上取的纸牌，只能移到编号为N-1N−1的堆上；其他堆上取的纸牌，可以移到相邻左边或右边的堆上。

现在要求找出一种移动方法，用最少的移动次数使每堆上纸牌数都一样多。

例如N=4N=4，44堆纸牌数分别为：

第1堆.9

第2堆.8

第3堆.17

第4堆.6

移动3次可达到目的：

从 ③ 取4张牌放到 ④ （9,8,13,10）-> 从 ③ 取3张牌放到 ②（9,11,10,10）-> 从 ② 取1张牌放到①（10,10,10,10）。

好了就是酱紫，来看下思路吧：

先求出每堆纸牌平均分完后的数量，之后重新计算每一个数

```cpp
for(i=0;i<n;i++)
{
   cin>>a[i];
	sum+=a[i];
} 
sum/=n;
for(i=0;i<n;i++) 
{
	a[i]-=sum;
}
```

最后就可以模拟分纸牌的过程了

```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
	int n;
	int a[101];
	int i,j;
	int ans=0;
	int sum=0;
	cin>>n;
	for(i=0;i<n;i++)
	{
		cin>>a[i];
		sum+=a[i];
	} 
	sum/=n;
	for(i=0;i<n;i++) 
	{
		a[i]-=sum;
	}
	for(i=0;i<n;i++)
	{
		if(a[i]<0)
		{
			a[i+1]=a[i]+a[i+1];
			ans++;
		}
		if(a[i]>0)
		{
			a[i+1]=a[i]+a[i+1];
			ans++;
		}
	}
	cout<<ans<<endl;
	return 0;
}
```
## 杜绝作弊，请勿抄袭