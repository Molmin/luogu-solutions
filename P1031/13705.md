一开始看到的时候瞎想了很多，后来确定了一个满打满算21行的代码，其实还可以写的更短，总体来说简短可行，而且看到大家的题解在遍历的时候都修改了数组，这其实完全没必要，顺便还在证明这个贪心的科学性上在解释rest变量的意义之后又写了一写注释，也算是让自己对这道题了然于胸，代码如下：

```cpp
#include<algorithm>
#include<iostream>
using namespace std;
int main(){
    int ave=0,rest=0,ans=0,n; cin>>n;                        //ave是平均数，rest是之后遍历时记录的参数，作用在下面遍历时会解释
    int a[n]; 
        for(int i=0;i<n;i++) {  cin>>a[i]; ave+=a[i];    }
    ave/=n;
    for(int i=0;i<n;i++){
        rest=rest+a[i]-ave;
        if(rest) ans++;                                        
```
/\*rest可以为负数，正负也就是向左和向右取纸牌的区别，并不影响求解。如果不在意其中的模拟思路的话可以直接理解是常规做法中改动数组的方式的简化；
想要证明这种解法得出的是最优解并不困难：因为让每一堆纸牌都平均，则要让多余的纸牌（以下简称rest）流过每个堆至少一次；而最优解中可不可能有某个堆经历了两次纸牌的流动呢？

倘若将我们这段代码理解为模拟则显而易见，每个不”平均“的堆都只需一次rest的流过（rest>0时向右，<0时向左，=0时则不需要流过纸牌）；

从另一个角度证明，由于纸牌只能向相邻的堆”流“，所以这堆纸牌在所有纸牌中的位置是固定的（是边界的位置，想象一条数轴某堆纸牌包含了从a到b的长度，那么a，b与平均之后的边界的距离就是向那个方向流动的纸牌数，rest相当于在描述这堆纸牌相对于最后的平均位置的偏差），可为什么只需要rest流过一次呢，还是那条数轴，可知rest的流动即纸牌的重新分配，也就是纸牌数轴上不同堆纸牌边界的重新分割，当rest从一头流向另一头时，每经过一堆纸牌就会在数轴上重写这一段的右边界（第一堆的左边界是无法也不需要重写的，其余的左边界就是前一堆的右边界，那么我们发现本代码中i只需循环到n-1即可（因为最后一堆得右边界也是无法也无需改动的）我懒得试了，如果有人用n-1通过了麻烦告诉我一声，这也就证明了每堆纸牌只需要rest流过一次）

\*/
    }
    cout<<ans;

    return 0;

}