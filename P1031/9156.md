本题是2002年提高组原题。作为当年的第一题，难度确实不高，但是其中含有一个重要的贪心思想。首先，本题中贪心算法是成立的，而并不用使用动态规划，因为显然题中描述“每一堆牌只能移动若干张牌到相邻的牌堆上”，确定了局部最优解必定能推导出全局最优解。

下面我们开始建立贪心思想：所谓贪心，就是永远以一种方式进行操作。一堆牌可以往左或往右移动到相邻的牌堆上，因此我们可以规定每一堆牌只能向右移动，而不能向左移动。所以，对于n堆牌，我们最多只需进行n-1次操作即可，不会产生重复的操作，这样必能得到最优解。

下面上100分AC代码，勿抄！

```cpp
#include<iostream>
using namespace std;
int n,a[105],sum=0,ave,ans=0;
int main()
{
  cin>>n;
  for(int i=1; i<=n; i++) { cin>>a[i]; sum+=a[i]; } //读入数据，计算总和
  ave=sum/n; //计算平均值
  for(int i=1; i<=n-1; i++)
  {
    if(a[i]==ave) continue; //如果已经等于平均值，就跳过不处理。
    ans++; //否则需要处理，答案+1
    if(a[i]>ave) //大于平均值
    {
      a[i+1]=a[i+1]+(a[i]-ave); //将多余牌放到第i+1堆上
      a[i]=ave; //当前牌堆数变为平均值
    }
    if(a[i]<ave) //小于平均值
    {
      a[i+1]=a[i+1]-(ave-a[i]); //这里不解释了，同上
      a[i]=ave;
    }
  }
  cout<<ans<<endl; //最后输出最少移动次数
  return 0;
} //结束
```