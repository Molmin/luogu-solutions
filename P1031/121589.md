其实还是蛮简单的一道题

思考一下就知道最优的方案中，两叠牌之间的移动次数k,0<=k<=1

由于第一叠牌只能向第二叠拿，所以我们就从第一堆开始，依次向右拿，比如说：1拿2 , 2拿3………… n-1拿n

那么有些人要问：那有时候拿了下一叠的时候，下一叠不是就成负数了吗？

没有关系，因为在程序中并不是很需要完全正确的具体公式，因为这些被取后是负数的排堆可以通过调换拿牌顺序来实现不是负数（不然为啥还要叫做算法呢）

所以我们就去从第一堆开始，依次遍历整个队列，如果和平均值有差别，多的话就给下一堆，少的话就先偷几张走，完美！

```cpp
#include<bits/stdc++.h>
using namespace std; 
int n,num[103],sum,ans;
//堆数，每堆量，纸牌点数总和，答案 
int main()
{
    cin>>n;
    for(int i=0;i<n;i+=1)//格式纯属个人习惯 
        cin>>num[i],sum+=num[i];//顺便求点数和 
    sum/=n;//平均值 
    for(int i=0;i<n;i+=1)
        if(num[i]!=sum)// 一定要是不等于，才从下一堆那里偷几张（或给） 
        {
            ans+=1;	// 更新答案 
            num[i+1]-=(sum-num[i]);	//这样就不用写两次判断了	
        }
    cout<<ans<<endl;//耶，拜拜 
    return 0;
}

```
第一次题解，求过