原题如下：
有 $N$ 堆纸牌，编号分别为 $1,2,…,N$ 。每堆上有若干张，但纸牌总数必为 $N$ 的倍数。可以在任一堆上取若干张纸牌，然后移动。

移牌规则为：在编号为 $1$ 堆上取的纸牌，只能移到编号为 $2$ 的堆上；在编号为 NN 的堆上取的纸牌，只能移到编号为 $N-1$ 的堆上；其他堆上取的纸牌，可以移到相邻左边或右边的堆上。

现在要求找出一种移动方法，用最少的移动次数使每堆上纸牌数都一样多。

例如 $N=4$ ， $4$ 堆纸牌数分别为：

①$9$ ②$8$ ③$17$ ④$6$

移动 3 次可达到目的：

从 ③ 取 $4$ 张牌放到 ④ （$9,8,13,10$）-> 从 ③ 取 $3$ 张牌放到 ②（$9,11,10,10$）-> 从 ② 取 $1$ 张牌放到①（ $10,10,10,10$）。

此题的思路还是很好想的：想要使没堆牌的牌数都等于平均值，必须要依次遍历牌堆，查找不等于平均值的牌堆，并且修改。我们从0号开始，一堆堆往后遍历，如果发现纸牌数不等于平均值，就从后面一堆“借来”或“借出”一些纸牌，并且继续查找，遇到符合条件的牌堆就跳过，直到最后一堆牌。

考虑到不管当前牌是否大于或小于平均值，下一张牌都会增加当前牌数-平均数（如果小于平均值，则该值为负数，相当于从下一堆借来纸牌），所以不需要多余的条件判断。由于当前牌堆的修改与上一堆无关，所以可以除去将当前牌数修改为平均数这个不必要的操作，以加快运行速度。

代码奉上：
```cpp
#include <bits/stdc++.h>
using namespace std;
int a[110],n,s,avg,m;
inline void work(){
	ios::sync_with_stdio(0),cin.tie(0);
	cin>>n;
	for(int i=0;i<n;++i)cin>>a[i],s+=a[i];
	avg=s/n;
	for(int i=0;i<n-1;++i)
		if(a[i]!=avg)a[i+1]+=a[i]-avg,++m;
	cout<<m;
}
int main(){
	work();
	return 0;
}

```