~~这道题也太简单了吧~~

看到这题的第一想法就是先找出小于等于N的所有质数，用个数组存起来，然后从4开始枚举偶数到N，对于每个枚举到的偶数，我们用这个偶数分别减去质数表里的质数（从小到大），再判断减完后剩下的差是否为质数，是就按格式输出，不是就继续枚举......

嗯......又要筛质数，又要存质数，又要判断某个数是否为质数......刚学完数论初步的本蒟蒻立刻想到了，传说中的、很久很久以前的、鼎鼎大名的、~~极其变态的~~......欧拉......创造的欧拉筛法！

简单说一下欧拉筛法的思路：

 欧拉筛法和埃氏筛法思路大致相同，都是找到质数后将该质数的倍数筛去。但是！欧拉筛法不会重复筛一个数，所以欧拉筛法的时间复杂度是O(n),而埃氏筛法时间复杂度是O(n*lglgn)，在大数据时欧拉筛法完胜埃氏筛法。
 
 那欧拉筛法哪里比埃氏筛法快呢？
 
 请看下方
 ```cpp
if(!i%p[j])break;
```
其中i是筛到的数（不一定为质数），p[j]表示质数表中从小到大排列的第j个数。

这一步保证了每个合数只被它最小的质因数筛去，所以欧拉筛法不会重复筛一个数。这就是欧拉筛法快的原因。

废话不多说~~虽然我已经说了一大篇废话了~~，上代码：
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
int np[10010],p[5000];//np[i]=0表示i为质数，=1则表示i不为质数，p记录找到的质数 
int n,x,cnt;//n如题所指，x表示正在验证的偶数，cnt为欧拉筛中存质数的下标 
void Eulerprime(){//传说中的欧拉筛！！！ 
	for(int i=2;i<=n;i++){
		if(!np[i])p[cnt++]=i;
		for(int j=0;i*p[j]<=n&&j<cnt;j++){
			np[i*p[j]]=1;
			if(!i%p[j])break;//这一步是欧拉筛的精髓 
		}
	}
}
int main(void){
	scanf("%d",&n);
	Eulerprime();
	for(x=4;x<=n;x+=2){
		for(int i=0;i<cnt;i++){
			if(!np[x-p[i]]){//判断x减去质数表中第i个质数后是否为质数 
				printf("%d=%d+%d\n",x,p[i],x-p[i]);//输出 
				break;//跳出循环，查找下一个偶数 
			}
		}
	}
	return 0;
}
```
