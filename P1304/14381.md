这道题比较简单，主要是你得知道啥是哥德巴赫猜想……

哥德巴赫的猜想就是：一个大于2的偶数一定可以由2个质数组成，例如34=17+17。但是这一题它是要求出第一个数最小的解，所以34=3+31。

这题应该是普及吧……作为入门有点繁琐了。

核心思路：

一个数一个数地判断。例如8：先从2开始往后数，先是2+6（6是8-2），然后两个数判断是不是质数：6不是质数，所以再加；3+5？很好就是你了。所以8=3+5。

不过为了优化，第一个数只要到这个数的一半就行了。比如说14，数到7+7就不用再算8+6了，因为之前有算过6+8。这就是优化。

上吧代码。

```cpp
-#include <iostream>-
-#include <cmath>---重要的头文件，abs、sqrt（开方）都在这里
-using namespace std;-
-int x,y,s;-
-int zs(int a)---质数判断
-{-
-    int l=1;---l代表是不是质数，1代表是。判断的时候如果发现不是质数就改成0
-    for(int i=2;i<=sqrt(a);i++)if(a%i==0){l=0;break;}---判断质数，从2数到这个数的开方，如果能整除其中一个数那么它就是合数。至于为什么要开方……自己举例子想想吧
-    return l; ---返回值：是不是质数
-}-
-int main()-
-{-
-    int j;-
-    cin>>s;---读入数
-    for(int k=4;k<=s;k+=2)---从4到s
-    {-
-        for(int i=2;i<=k/2;i++)---从2到k/2，之前有说过为什么要/2。
-        {-
-            j=k-i;---求出第二个数
-            if(zs(i)==0||zs(j)==0)continue;---判断两个数是不是都是质数，如果不是，就换下一组。
-            if(i+j==k){cout<<k<<'='<<i<<'+'<<j<<endl;break;}---如果两个质数相加刚好是k，那么输出后就可以换下一个k了。
-        }-
-    }-
-    return 0;-
-}-
```