对于特定的状态与 $A_j=x$，考虑操作会对状态产生哪些影响。

先考虑向左出边界，向右出边界显然是对称的。

首先不难发现，会存在一段前缀，使得操作过后全是红色，而分界点之后的部分的状态不会改变。同时球在左右移动的过程中，必然满足向左与向右的移动步数之差为 $x$，而球仅在一段前缀上运动，结果使得前缀的所有蓝色变为红色。将蓝色变为红色显然对步数之差的贡献为 $1$，因此，每次操作会使前 $x$ 个蓝色光带变为红色。

当蓝色光带不足 $x$ 时，显然球会向右边移动，对状态的改变同理。

考虑第 $5$ 个子任务，即前缀为一段红色，剩余部分为蓝色。

在该种情况下，每一次操作只会改变红蓝分隔点的位置，因为每次操作只会把前缀的蓝色变为红色，或后缀的红色变为蓝色。因此，我们只需记录当前状态下的红色光带个数 $y$。

- $x \le y$ 时，此时球在红色光带上
  - $x < N - y$ 时，向右出边界，$y\gets y-(N + 1 -x)$
  - $x \ge N - y$ 时，向左出边界，$y\gets y+x$
- $x > y$ 时，此时球在蓝色光带上，会额外多出一条红色光带
  - $x < N - y$ 时，向右出边界，$y\gets y-(N+1-x)+1$
  - $x \ge N - y$ 时，向左出边界，$y\gets y+x+1$

综上
$$
\begin{cases}
y\gets (x + y)\bmod (N + 1) & x \le y\\
y\gets (x + y + 1)\bmod (N + 1) & x > y
\end{cases}
$$

至此，对于每个 $A_i$ 而言，我们可以处理出 $y$ 在某一个区间中会增加的值。这个东西显然是可以合并的，用线段树维护可以做到 $\mathcal O(M\log^2 M)$。

> 证明：
>
> 不失一般性，设 $M = 2^m$，此时线段树有 $m + 1$ 层，自上向下的节点数依次为 $2^0, 2^1, \cdots, 2^m$。
>
> 对于第 $m$ 层的节点，其分段函数的段数为 $2$（即每个 $A_i$ 的状态），向上归纳不难得到：对于第 $i$ 层的节点，其分段函数的段数不超过 $2^{m - i + 1}$。则整棵线段树的总段数不超过
$$
\sum_{i=0}^m 2^i\times 2^{m - i + 1}=\sum_{i = 0}^m2^{m + 1}=m2^{m  + 1}=\mathcal O(M \log M)
$$
> 在节点合并的过程中，我们需要二分查找分隔点，故此处的时间复杂度为 $\mathcal O(M \log^2 M)$。

对于一般的情况，不难发现在做一些操作之后，状态会转变为子任务 $5$ 的形态，因此只需处理红蓝没有相遇的情况，设前缀开始的红色长度为 $a$，末尾开始的蓝色长度为 $b$，同时设前缀有 $L$ 个蓝色变为了红色，后缀有 $R$ 个红色变为了蓝色。对于一次操作，会存在 $3$ 种情况

- $x \le a\implies L\gets L+x$
- $x \ge N - b + 1\implies R \gets R+(N-x)$
- $ a < x < N - b + 1$，此时必然有 $a'\ge 2a$ 或 $b'\ge 2b$，即这种情况不超过 $\log N$ 次。

对于前两种情况，我们可以令 $a'=\text{highbit}(a), b'=\text{highbit}(a)$，在此基础上求出满足条件的前缀和，查询时二分查找是否红蓝相遇；对于第三种情况，可以直接 $\mathcal O(1)$ 更新状态。

可以做到在线，时间复杂度 $\mathcal O\left(M\left(\log^2 M + \log^2 N\right)+Q \log N\left(\log N+\log M\right)\right)$。
