~~orz这题实在是太神辣……我把网上的所有题解都翻遍了都没搞明白……~~

首先这题需要我们认真阅读这句话和这个式子：

### **1.如果有多个xi，yi满足要求，你需要选择yi最小的，当yi相同时选择xi最小的。**

### **2.**$\large{pos_i=}(c_i+y_i+d*x_i)\%n$

这里要说一句我做这题得出的教训，长成这样的式子在OI中差不多都是用来生成随机数的，因此我做这题的时候就以为这只是个没啥卵用的式子就没去深入研究它……所以做题千万不要想当然……

那么这式子究竟有啥特点呢？我们发现$d$是个定值，假设$y_i$固定的话，我们让$x_i$不断增大，那么就相当于在模$n$剩余系下给一个数不断地加$d$，容易想到这个会出环，我们想当$x_i$加到$n$的时候这个模$n$剩余系下的数就相当于回到了原位置，所以这个过程中必定会产生环。

然后来解释下第一句话的意思，就是相当于我们从小到大枚举$y_i$，再从小到大枚举$x_i$，只要找到第一个二元组$(y_i,x_i)$能够使得$pos_i$这个数没在前面出现过，就结束枚举。所以我们需要先求出$pos[]$，再去在这个$pos$数组的基础上找一个最小方案，这两者之间是独立的（~~突然发现我好像在解释题意~~不过话说回来这题题面是真的绕……）。

那么我们就“按题意模拟”（对你没有看错就是模拟）对每个$i$从$0$开始枚举$y_i$，我们结合一下上面的式子想一下这是在干嘛？这不就是枚举起点吗？换句话说我们在枚举到了哪个环毕竟一个起点确定一个环，然后我们要让$x_i$最小对吧，也就是说我们要从$c_i+y_i$出发不断地$d$步$d$步的跳，直到跳到一个没有被用过的点为止，这个是啥？这个是并查集能够加速的（当然链表似乎也可以）。

这玩意实现起来其实想想也是能想出来的，我们对$0$~$n-1$的数用并查集维护这个数下一步能够到达的可用的位置，另外再开个数组记一下这个点有没有被删除，原因就是如果一个点指向的位置被删除了那么这个点所在环就全都不可用了，我们就得接着枚举$y_i$直到找到一个能用的环为止。一个点$p$删除了就让他指向$(p+d)\%n$即可。

这里有个细节，就是空位最后是必须在$s$的，那么我们不妨把空位也看成一个能搬的箱子，并且他最后必须搬到$s$也就是说我们强制让$pos_0=s$。

这玩意复杂度为$O(\text{玄学})$，反正这样暴力枚举能过……~~不要问我为啥~~

然后我们来解决本题的后半部分：在$pos[]$的基础上求最小移动次数。

开始的时候我由于太naive然后以为把$pos[]$求出来然后我们每次把空位对应的物品放到空位上不就行了吗……显然这样不对，我们求出来的$pos[]$实质上是一个置换，而置换是能够被分解为多个环的，我刚才的想法只能把空位局限在一个环里。所以我们考虑两种环（显然自环就不用考虑了）：

1.空位一开始就在这个环里，换句话说就是0与$s$都在这个环里（别忘了我们已经让0指向$s$了），那么就可以在这**一个环里**用我的那种想法了，这个移动的次序也正是这个环倒过来啊（不明白的可以画一下），所以步数为环长-1。

2.空位本来并不在这个环里，但是我们不借助空位就不能进行环内的移动，所以我们必须先把一个位置搬到空位上，把空位引进来，然后转化为上面那种情况，最后把那个东西搬回来即可。显然跟上面相比多移动了两次就是环长+1。

然后就做完了……

上代码~（代码其实相当的短……）

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#define ll long long
using namespace std;
namespace ywy{
	int ints[100001],pos[100001];
	unsigned char bv[100001];
	ll c[100001];
	int find(int n){//并查集 
		if(ints[n]==n)return(n);
        return(ints[n]=find(ints[n]));
	}
	void ywymain(){
		int t;cin>>t;
		while(t){
			t--;
			int n,s,q,p,m,d;
			cin>>n>>s>>q>>p>>m>>d；
			for(register int i=0;i<ni++)ints[i]=i,bv[i]=0;//初始化 
			pos[0]=s;bv[s]=1;
			ints[s]=(s+d)%n;//先把s用掉 
			for(register int i=1;i<n;i++)c[i]=(c[i-1]*q+p)%m;
			for(register int i=1;i<n;i++){
				int y=0;
				while(bv[find((y+c[i])%n)])y++;//枚举可行的y 
				pos[i]=find((y+c[i])%n);
				bv[pos[i]]=1;
				ints[pos[i]]=find((pos[i]+d)%n);
			}
			memset(bv,0,sizeof(bv));
			int ans=0；
			for(register int i=0;i<n;i++){
				if(bv[i]||pos[i]==i)continue;
				int cur=i,l=0;
				unsigned char bswitch=0;
				while(!bv[cur]){//遍历环 
					if(!cur)bswitch=1;
					bv[cur]=1;cur=pos[cur];l++;
				}
				if(bswitch)ans+=(l-1);//有0 
				else ans+=(l+1);
			}cout<<ans<<endl;
		}
	}
}
int main(){
	ywy::ywymain();return(0);//再见程序 
}
```