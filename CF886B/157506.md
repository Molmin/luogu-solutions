翻译相当不友好。。。。

我再说一遍题意：
```
给出n个数，让你输出这一堆数里面每一
种数字最后一次出现的最靠前的那个数。
```
拿样例来看
```
5
1 3 2 1 2
```
这里面出现了 $1$，$3$，$2$。

$1$ 最后一次出现是在 $4$ 号位置。

$3$ 最后一次出现是在 $2$ 号位置。

$2$ 最后一次出现是在 $5$ 号位置。

很明显，最靠前的是 $3$。

理解了题意，我们再来讲思路。

我们可以先用**排一次序**，把它们相同的都挨在一起方便查找。**一次循环**找出有哪几种数字，再顺便**找到它最后一次在哪里出现**。然后再从它们最后一次出现的位置中**找到最小的一个**。

这里也许有人会说如果排了序那下标不就打乱了吗？

我们可以创建一个结构体来记录下标。

代码如下：
```cpp
#include<bits/stdc++.h>
#define rll register long long
#define ll long long
using namespace std;
struct Node{
	ll num,id;	
}a[200005],c[200005];//c数组的作用是因为要排序，所以得把a数组存一下，否则后面没法输出了。当然也可以遍历一遍a数组。
bool vis[200005];
ll b[200005],cnt;
inline cmp(Node a,Node b){
	return a.num<b.num;
}
int main(){
	rll n,i,MAX;
	scanf("%lld",&n);
	for(i=1;i<=n;i++){
    		scanf("%lld",&a[i].num),c[i].num=a[i].num;
		a[i].id=c[i].id=i;
	}
	sort(a+1,a+1+n,cmp);//排序把每种数字分到一起。
	for(i=1;i<=n;){//这里的for循环手动模拟，所以不需要i++。
		vis[a[i].num]=1;//先把出现过的数字标记一下，这样方便识别是否开始遍历下一个数字。
		MAX=INT_MIN;
		while(vis[a[i].num]){
			MAX=max(MAX,a[i++].id);//找最靠后的下标。
		}
		b[++cnt]=MAX;//存入b数组
	}
	sort(b+1,b+1+cnt);//b数组排完序后，b[1]即为最后一次出现最早的数字的下标。
	printf("%lld",c[b[1]].num);//从原始a数组也就是c数组中输出。
	return 0;
}

```
这里再说明一下，这道题能用我这种方法做完全是因为数据规模较小。如果数据多那像我这样的两次排序两次循环是肯定会 $TLE$ 的。