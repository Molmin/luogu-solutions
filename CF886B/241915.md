## 题意简述：

吐槽一下题目的翻译：
>$给出$ $n$ $个数字,求最后一次出现最早的数字。$

像我这种语文小白完全看不懂，样例也十分不友好，有多种解读可以使样例成立，这里重点描述一下易懂版本的题意：

给定 $n$ 和 $n$ 个数，对于这 $n$ 个数中每一个不同的数，求这些数中最后一次出现最早的数是哪个。

还不懂的话拿样例而作解释：

```
6
2 1 2 2 4 1
```

这六个数中有 1、2、4 共 3 种数。

1 最后一次出现在第 6 个；2 最后一次出现在第 4 个；4最后一次出现在第 5 个。

2 的最后一次出现最早，所以输出 2。

## 做法：

知道了题意之后做法就很容易想到了，可以开个桶存每个数最后一次出现的位置，最后将整个数组扫一遍，输出最后一次出现最早的数字，由于其他题解里也讲到过这种方法，所以不再过多讲解。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[200005],ans,x,maxa,mina = 200005;
int main()
{
    cin >> n;
    for (int i = 1; i <= n; i++)
    	{
    		cin >> x;
    		a[x] = max(a[x],i),maxa = max(maxa,x);
		}
	for (int i = 0; i <= maxa; i++)//注意这里一定要从0开始扫，否则WA。
		{
			if (a[i] < mina && a[i])//要排除这个数字压根就没出现的情况。
				{
					mina = a[i],ans = i;
				}	
		}	
	cout << ans;	
	return 0;
}
```

第二种方法，就是在将整个数组输入后，从后往前遍历。

因为一个数最后一次出现从后往前看就是第一次出现，所以遍历的时候如果发现当前数没有出现过，那就可以直接更新答案。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[200005],b[200005],ans;
int main()
{
    cin >> n;
    for (int i = 1; i <= n; i++)
    	{
    		cin >> a[i];
		}
	for (int i = n; i >= 1; i--)//从后往前遍历。 
		{
			if (b[a[i]] == 0) ans = a[i];//没遇到过就更新答案。 
			b[a[i]] = 1;//记录。	
		}	
	cout << ans;	
	return 0;
}
```

祝大家早日AC此题！