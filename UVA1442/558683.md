这道题的关键是思考，一般理解了题意就能想出解法来了（如果你像我一样有lrj的紫书就更好了，不过还是要“想一想，为什么”哟~），这里只是做一个简短的介绍，如有不足之处请多多指教，谢谢！


我们观察原题的图示，可以得到一个结论：这种燃料的贮藏地的高度相等并且必须小于等于该地的最低高度，并且。换句话说，如果区间 $[i,j]$ 为燃料地贮藏地，且令 $h$ 等于该地燃料贮藏地高度，那么 $h \leqslant s_i$。

于是我们可以做两次扫描，一次从左往右，一次从右往左。

第一次扫描：设 $lev=s_1$，$dep_1=lev$（初始条件），并从 $2$ 开始扫描到 $n$，每一次做如下事情：

1. 如果 $p_i>lev$（即，燃料池被当前片段隔断了），则 $lev=p_i$。

2. 如果 $s_i<lev$（即，燃料碰到顶了），则 $lev=s_i$。

3. 记 $dep_i=lev$。这里 $dep_i$ 为当前燃料的高度。

程序如下：
```cpp
lev=s[1]; d[1]=lev; vol=0;
for(int i=2;i<=n;++i){
	if(p[i]>lev) lev=p[i];
	if(s[i]<lev) lev=s[i];
	d[i]=lev;
}
```
第二次扫描：设 $lev=s_n$，答案 $vol=dep_n-p_n$（初始条件），并从 $n-1$ 开始扫描到 $1$，每一次做如下事情：

1. 如果 $p_i>lev$（即，燃料池被当前片段隔断了），则 $lev=p_i$。

2. 如果 $s_i<lev$（即，燃料碰到顶了），则 $lev=s_i$。

3. 更新答案 $vol=min(dep_i,lev)-p_i$。这里 $dep_i$ 为当前燃料的高度。

程序如下：
```cpp
lev=s[n]; vol=d[n]-p[n];
for(int i=n-1;i>=1;--i){
	if(p[i]>lev) lev=p[i];
	if(s[i]<lev) lev=s[i];
	vol+=min(lev,d[i])-p[i];
}
```

于是，我们的大体程序部分就做完了。全部代码笔者相信读者一定能补足，这里就不予展示了。

求过qwq。