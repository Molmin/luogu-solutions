比较简单的一道分块题。

感觉和 [P3203 [HNOI2010]弹飞绵羊](https://www.luogu.com.cn/problem/P3203) 有点像。

**注：本文认为 $n, m$ 同阶。**

首先考虑一遍所有 polylog 或更低的求 LCA 的方法，发现在这道题好像都用不出来，于是考虑根号做法。

我们对序列分块。

为了使得我们能够快速查询，我们在查询 LCA 时每一步都要 **跳至少一个块**，故考虑维护每一个点 **出块** 后的第一个祖先和真实的祖先。

假设某一个块内所有点出块后的第一个祖先就是真实的祖先，由于祖先 **只减不加**，故后面所有状态这个块内的祖先 **全部出块**，因此我们维护时直接打 tag 即可，每一个块 $O(1)$ 。

并且不难发现每个块被修改至多 $\sqrt{n}$ 次之后必然会达到全部出块的状态。

因此，这 $\sqrt{n}$ 次修改允许 $O(\sqrt{n})$ 的复杂度，即重构。

重构的时候扫一遍这个块，然后每一个点向前连，用类似路径压缩的方法处理即可，十分简单。

故修改复杂度 $O(n\sqrt{n})$ 。

然后找 LCA 的话就用类似倍增的方法暴力跳。这里对于全部出块的块很好处理，但是对于没有全部出块的块可能会出现两点虽然在同一块内，但是其 LCA 不在这一块内的情况，只维护刚才的东西难以在块内判断 LCA 是否在这个块中。

不难发现我们可以在每一次重构的时候顺便维护出每一个元素 **块内最前面的祖先** ，用类似并查集的思路，判断一下这一个是否相同即可，显然这个东西只会在 **没有全部出块** 的块内被用到，而且每一次重构显然可以顺便求出，故不会改变复杂度。

最后状态显然为两个元素的 LCA 在某一个块内，这一部分暴力扫即可。

故询问复杂度 $O(n\sqrt{n})$  。

总时间复杂度 $O(n\sqrt{n})$ ，空间复杂度 $O(n)$ ，可以通过本题，完全不卡常。