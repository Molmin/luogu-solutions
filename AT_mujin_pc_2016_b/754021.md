# 1 思路

题面上已经解释的很清楚了吧……

就是求一个圆环，需要注意要精确到 10 位小数，所以 $\pi$ 要取到 ```3.14159265359``` 。

[圆环面积公式，需要自取。](https://wenku.baidu.com/view/1da1823d1db91a37f111f18583d049649a660e64.html?_wkts_=1677291877982&bdQuery=%E5%9C%86%E7%8E%AF%E7%9A%84%E9%9D%A2%E7%A7%AF%E5%85%AC%E5%BC%8F)
~~（大佬请自动忽略。）~~

那么，这题就变成了一个数学题，只需要得到大圆半径和小圆半径，问题就迎刃而解了。

---

**求 $r$ 的值：**

从样例中绘制的图可以推导出，当 $O-A$ 是最长的线段时：

$r=$ 第一条线（样例图中的 $O-A$ 线）减第二条线（样例图中的 $A-B$ 线）减第三条线（样例图中的 $B-C$ 线）。

这里有一个细节，输入的数只是三个普通的线段，不是从 $O$ $-$ $A$ 线开始输。所以，判断哪一条线是 $O$ $-$ $A$ 至关重要。
~~我是这么理解的，有不同意见的别骂。~~

为了推导哪一条作为 $O-A$ 最优，我画了一张图：

![推导の图片](https://cdn.luogu.com.cn/upload/image_hosting/7uey1ztu.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

~~画太丑了。。。~~

线段 A 是深蓝色；线段 B 是浅蓝色；线段 C 是红褐色。

从图中可以看出，任何线段作为 $O-A$ 对结果并不造成影响。为了迎合上文中我们发现的公式，我们就可以将最长的线段设为 $O-A$，那么得出 $r$ 的值也就是轻而易举的事情了。

PS ：千万别把 $r$ 减到负数去！！

---

**求 $R$ 的值：**

这个部分其实没有什么思维难度，把三个线段伸直出去绕一圈，就是外圆了。而三个线段的长度和自然也就是 $R$ 了。

# 2 代码

综上，我们可以得到如下代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[3];
double r1,r2;//r1=r r2=R
int main(){
    cin>>a[0]>>a[1]>>a[2];
    sort(a,a+3);
    r2=a[0]+a[1]+a[2];
    r1=a[2]-a[0]-a[1];
    if(r1<0) r1=0;
    printf("%.10lf\n",3.14159265359*(r2*r2-r1*r1));//精度！！！
    return 0;
}
```

[ Accepted.](https://www.luogu.com.cn/record/102694668)