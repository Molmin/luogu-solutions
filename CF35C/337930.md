**题目大意**

- 给定一个 $n\times m$ 的长方形。
- 给定 $K$ 个 **燃烧点** ，每个 **燃烧点** 每个时间单位都会向上下左右延伸,延伸出来的新的 **燃烧点** 也会获得此效果，以此类推。
- 问哪个点被烧着的时间最晚。
- 数据范围：$1 \le n, m \le 2000$，$1 \le k \le 10$。
- 初始燃烧点坐标保证在长方形范围内且不重合。
- 需要加文件读入与输出。

------------

**前提概要**

本蒟蒻第一次写题解，有何不合理的地方请指出，谢谢！

看了一下各位神犇写的题解，大多数是 BFS ，这里再向大家推荐一下曼哈顿算法 （也有一个 dalao 是用曼哈顿做的，不过程序写得比较高深~~上面有一大段我看不懂~~，本蒟蒻写了一个比较简单的版本 ）。

------------

**曼哈顿算法**

曼哈顿算法离不开绝对值。

当我们要求 $(a ,b)$ 点与 $(c, d)$ 点的最短路径且没有障碍时，最短路径一定是 $|a - c| + |b - d|$。

我们要到达目标点，必须竖向到，横向也要到。

这样这道题的难度就从省选降到了入门了。

------------

**对比**

详细的 BFS 算法可以参考其他神犇的题解，蒟蒻在此将 BFS 和曼哈顿算法进行对比。

BFS 算法可以用 queue 进行宽度优先搜索（又称广度优先搜索）一圈一圈地模拟下去，直到找到最优解，相比较曼哈顿算法，用途更为广泛，适用的题目也很多，十分适合“找最优解”。

而曼哈顿就比较局限，只有在没有限制，没有障碍的状态下才成立。但它也有自己的好处，只要可以用它，就可以做的很快，代码也会更加简洁。

综上，BFS 以及曼哈顿各有利弊，适用的范围有所不同，大家可以根据题目理性选择。

**AC 代码**

```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
   freopen("input.txt","r",stdin);
   freopen("output.txt","w",stdout);//文件读入输出
	int m,n,k,q,w;
	cin>>m>>n;//读入长方形大小
	cin>>k;//读入有几个初始燃烧点
	int a[k],c[k];
	for(int i=0;i<k;i++)
	cin>>a[i]>>c[i];//初始点坐标（AC出现，好运连连）
	int minn,maxx=-1;
	for(int i=1;i<=m;i++)
	{
		for(int j=1;j<=n;j++)//枚举所有点
		{
			minn=1e5;//对于这个点最少几个时间单位能烧到
			for(int p=0;p<k;p++)
			{
				if((abs(a[p]-i)+abs(c[p]-j))<minn)
				minn=abs(a[p]-i)+abs(c[p]-j);
			}//核心曼哈顿
			if(minn>maxx)
			{
				maxx=minn;
				q=i;
				w=j;
			}//比较之前枚举过的点，如果时间比其他点还长，就更新maxx；同时q,w记录坐标
		}
	}
	cout<<q<<' '<<w<<endl;//输出完结
	return 0;//养成好习惯
 } 
```
