对于这道题，我们要分情况讨论：

## 情况1

黑先行且有黑子紧贴白子，如：

```
B 1 3 4 6 8 9
```
这种情况，黑可以先手吃掉一个白子，剩下的白子将要面对四个黑子，即使下回合吃掉一个黑子，依然被两面包围，黑子用还剩两个棋子的那边稳步推进即可，故游戏可以结束。


## 情况2

黑先行且无黑子紧贴白子，如：

```
B 1 3 5 6 8 9
```

这种情况，黑可以左右稳步推进，不给白棋不付代价就吃自己子的机会，直到白棋夹在中间，不得不走，如：
```
W 1 2 4 4 6 7
```
这样的场面，白只能出来送死一颗，即使吃掉了那边一颗黑，但还有一颗。剩下一边的黑子稳步推进即可。

## 情况3

白先行且无黑子紧贴白子，如：
```
W 1 3 5 6 8 9
```
显然，白走一步后，要么转化到情况 1，要么转换到情况 2，都是死路一条

## 情况4

难点来了！

白先行且有黑子紧贴白子，这个时候又需要更细分：

### 情况4.1

白有一侧紧贴黑子，如：
```
W 1 3 4 6 8 9
```
这个时候，白可以先手吃掉黑，游戏无法结束。但是又有一个特例：

#### 情况4.1.1

黑在那一侧是紧贴着的两个棋子，这个时候，黑又吃掉白一颗，如：
```
W 2 3 4 6 8 9
```
这个时候，白棋如果吃黑，那么自己也会被吃，于是白子输，游戏结束。

### 情况4.2

白有两侧紧贴黑子，如：
```
W 1 3 4 5 6 7
```
这个时候，白可以先手吃掉黑，但是这个时候，黑又可以吃掉白一颗，游戏结束。如果白棋龟缩，那么黑棋可以稳扎稳打吃掉白旗，游戏还是结束。


**至此，所有情况考虑完全。**

AC 代码：

```cpp
#include<iostream>

using namespace std;

int T,arr[10];
char c;

int main() {
	cin >> T;
	while(T--) {
		cin >> c;
		for(int i=1;i<=6;++i) cin >> arr[i];
		if(c=='W' && ((arr[2]+1==arr[3] && arr[1]+1!=arr[2]) != (arr[4]+1==arr[5] && arr[5]+1!=arr[6]))) cout << "Yes" << endl;
		else cout << "No" << endl;
	}
	
	return 0;
}
```

