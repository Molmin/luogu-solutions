这道题其实挺水的，但赛时读入字符读错了挂了 85 分/kk

说明：不要看我想那么多字就觉得这道题很难，我只是把易得的部分分析了一下。

分析可得，白方一定是不可能取得胜利的（除非黑方是个傻子），所以我们只需要探究在什么情况下黑可以去的胜利就行了。

再经过进一步分析可得，黑方只要做到白吃白方一个棋子或者与白方一换一就可以取得胜利。

感性理解一下：如果黑方与白方一换一可以取得胜利，那么显然黑方白吃白方一个棋子也可以获得胜利，在黑方白吃白方一个棋子后，局面很显然是这样的：

黑 一些空 白 一些空 黑 一些空 黑

那么这个时候我们只需要保证黑方两侧只要有一侧保持与仅剩余的一个白子中间只有一个空档，就可以迫使白方不断减小自己的活动范围，最终变成 黑 一个空 白 一个空 黑 白方只要动就会被白吃的死局，黑方从而获得胜利。

由此我们延伸：如果开局双方都无法白吃对方或者一换一，黑方也可以运用上面的方法逐渐缩小白方的可移动空间，最后迫使白方被黑方白吃一个或者与黑方一换一，黑方从而获得胜利。

综上所述，我们得出一个结论：白方必须要在开局白吃一个黑子，再和黑方一换一，从而清除一边的屏障，取得平局。

这里我们再回过头看  $15\%$ 的数据，很显然当黑方先手时，白方很显然无法白吃一个黑子（如果开局白子可以吃掉黑子黑子可以抢先白吃白子或者与白子一换一）。当然，我们都推出来正解了，写什么部分分？！

按上述分析模拟即可。

code:

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int read(){
    int x=0,f=1;
    char c=getchar();
    while(c<'0'||c>'9'){
        if(c=='-') f=-1;
        c=getchar();
    }
    while(c>='0'&&c<='9'){
        x=(x<<1)+(x<<3)+c-'0';
        c=getchar();
    }
    return x*f;
}
void cf(int x){
    int a[7];
    for(int i=1;i<=6;i++)
        a[i]=0;
    char c=getchar();
    while(c!='W'&&c!='B'){
        c=getchar();
    }
    for(int i=1;i<=6;i++)
        a[i]=read();
    if(c=='W'){
        if(a[3]-a[2]==1&&a[2]-a[1]>0&&((a[2]-a[1]>1&&a[5]-a[4]>1)||a[3]==a[4])){
            printf("Yes\n");
            return;
        }
        if(a[5]-a[4]==1&&a[6]-a[5]>0&&((a[6]-a[5]>1&&a[3]-a[2]>1)||a[3]==a[4])){
            printf("Yes\n");
            return;
        }
    }
    printf("No\n");
    return;
}
int main(){
    int t=read();
    for(int i=1;i<=t;i++)
        cf(i);
    return 0;
}
```
