首先，当场面上局势是 `B W B B` 或者 `B B W B` 的时候，若 `W` 不能马上吃掉只有一个 `B` 的一边进行逃脱，白方必败。

这个很显然，就是一边的 `B` 不动，另一边的两个 `B` 轮流压上来，最终就可以用一个 `B` 换掉最后的 `W`。

这就意味着，白方绝对不敢用一个棋子换一个黑方的棋子。把这个称为基础情况。

接下来的推论，就是若黑方先手，那么白方必败。

若初始时存在异色棋子相邻，那么黑直接吃掉一个白，就可以规约到基础情况或者四黑一白的对白更加不利的情况。白方必败。

所以我们只用考虑初始不存在异色棋子相邻的情况。

考虑一种黑方的策略，我们将黑色棋子从左到右编号 $b_{1\dots 4}$：

* 若 $b_2$ 向右一步或 $b_3$ 向左一步不会被白棋攻击，那么就这么做。

* 若两个都不行，那么就将 $b_1$ 或 $b_4$ 随便移动到与中央不相干的位置以消耗步数。

* 显然白色的棋子绝对不能越出 $(b_2+1,b_3-1)$ 的范围，因为白子绝对不能移动到 $b_2$ 或者 $b_3$ 攻击的位置。这样会导致送掉一子或者对子。这都是致命的。

* 所以到最后，一定会形成“B-W*2-B”的局面。此时白方被迫对子。

所以白方必败。

白方先手呢？

有个结论：当且仅当在第一回合内，白子能白吃一个黑子时，白方的一个棋子可以逃脱。

这个结论的证明需要分类讨论。

要证明每一种第一回合内白子不能白吃一个黑子的情况均白方必败。

首先如果白子不吃黑子，那么相当于轮到黑方先手。白方必败。所以第一步必须吃黑子。

1. 两个白子均和黑色棋子相邻。

如果黑色棋子之间不相邻，那么白子吃掉一黑子后，另一白子将被另一黑子吃掉。规约到基础情况。

如果黑色棋子之间相邻，那么白子吃掉一黑子后该白子被反吃。另一白子再吃掉一枚黑子（不吃的话规约到基础情况，白方必败）。若另一白子不立刻被吃，那么现在就是两个 `B` 中间夹一个 `W` 的情况。通过类似上面两边逼近的方法，可以做到 `B-W-B` 的情况。此时如果轮到白方走，那么白子必被吃。如果轮到黑方走，那么就：`B-W--B` $\rightarrow$ `B--W-B` $\rightarrow$ `B-W-B`。这时候轮到白方走，白方必败。

2. 只有一个白子和黑子相邻。

这时候为了要满足“第一回合内白子不能白吃一个黑子”的前提，只能是 `BBW W B B`（空格表示中间隔了若干格）。

第一步只能吃一个黑子然后被反吃，那么规约到基础情况，白方必败。

3. 没有一个白子和黑子相邻。

吃不掉，白方必败。

综上所述，每一种第一回合内白子不能白吃一个黑子的情况均白方必败。

```cpp
#include<bits/stdc++.h>
#define Misaka namespace
#define Mikoto std
using Misaka Mikoto;
int read()
{
	int s=0,w=1;
	char ch=getchar();
	while(ch<'0'||ch>'9') w=ch=='-'?-1:w,ch=getchar();
	while(ch>='0'&&ch<='9') s=s*10+ch-'0',ch=getchar();
	return s*w;
}
int main()
{
	int T=read(),i,a[7];
	char s[5];
	while(T--)
	{
		scanf("%s",s);
		for(i=1;i<=6;i++)
			a[i]=read();
		puts(*s=='W'&&(a[3]-a[2]==1)+(a[5]-a[4]==1)==1&&(a[3]-a[2]==1&&a[1]+1!=a[2]||a[5]-a[4]==1&&a[5]+1!=a[6])?"Yes":"No");
	}
}
```
