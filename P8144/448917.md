仔细分析一下题意，我们可以发现：白色永远不可能赢！~~除非黑色是傻子~~

我们重新定义“赢”的概念：

黑赢：吃光所有白子

白赢：是游戏进入无限循环

那么题目问的就是白是否能赢

如果黑先，那么白必然会输（后面再解释）

那么我们在白色的角度解题：最优策略即为要么猛攻左面，要么猛攻右面。

定义一场“厮杀”为白方在一段连续时间内杀了对方至少一个子。

白色要想突围，必须在一场厮杀中杀掉黑方两个子或活下两颗子。

那我们就来考虑什么情况可以杀到两个子。

其实只有一种：其中一个白字和一个黑子相邻（当俩白子之间距离不为 $1$  时不能为两个，不然必被吃一子），白先，且被吃黑子旁边没有黑子

为什么呢？因为此时白色可以吃掉黑方一颗子，然后另一颗白子再过来与当前白子重合，此时必有一边只剩一颗黑子，那么想突围就非常的轻松了。

若黑子先，那么它必定会将距离拉近，此时白色若采用最优策略必定会虽小活动范围，最后就会被黑子围攻死。

那么思路说完了，直接上代码！

```cpp
#include <bits/stdc++.h>
using namespace std;
int a[10];
int main(){
    int t,y;
    scanf("%d",&t);
    while(t--){
        string s;
        cin>>s;
        if(s=="B"){//B先则W必输 
            for(int i=0;i<6;++i) scanf("%d",&y);//别忘读入！！！ 
            puts("No");
            continue;
        }
        else{
            for(int i=1;i<=6;++i) scanf("%d",a+i);
            if(((a[3]-a[2]==1&&a[2]-a[1]!=1)/*向左突围*/||(a[5]-a[4]==1&&a[6]-a[5]!=1)/*向右突围*/)&&((a[3]-a[2]!=a[5]-a[4]/*两边都相邻*/||a[4]-a[3]==1/*距离为1除外*/))){
                puts("Yes");
            }
            else puts("No");
            continue;
        }
    }
    return 0;
}
```
