[查看题目](https://www.luogu.com.cn/problem/AT319)

### 题意简介
 - 给你一个填满了数字的 $H$ 行 $M$ 列的矩阵，找出连续（**横着竖着皆可**）$3$ 个或以上的，由同一数字构成的长方形（这样的长方形以下简称为长方形），输出满足条件的长方形的个数。
 
 - 如有多个满足条件且均为同一数字的长方形连结在一起，仅算 $1$ 个满足条件的长方形。
 
### 题目分析
 这道题主要难点在于如何辨别出连结在一起的长方形。
 
 我们不妨思考一下，长方形连结在一起有什么特征？
 
 - 同一数字
 
 - 坐标相邻
 
 这不也是我们的普通长方形的判定标准吗？
 
 > 一切的特殊情况，都可以用简单情况的解决方法处理。
 
 我的思路是在开始的时候输入数字矩阵，并且将矩阵存入**全局**二维数组 ```a[][]```，并且设定**全局**变量 $cnt$ 和 $ans$。
 
 接着调用一个自定义函数 ```cp（int x,int y,int x1,int y1）```，这个 ``` cp()``` 的作用是先将 ```a[x][y]``` 值设为 $-1$ (这样能区别已经使用的数字)和将 ```cnt += 1```，然后比较 ```a[x][y]``` 的数字和它四周 (```a[x+1][y]```，```a[x-1][y]```，```a[x][y+1]```，```a[x][y-1]```) 中除了 ```a[x+x1][y+y1]``` 的其他三个数字是否相同。如果三个中 ```a[m][n]``` 等于 ```a[x][y]```，则继续运行 ```cp(m,n,x-m,y-m)```，否则返回。
 
 我们用这个函数做什么呢？我们在主程序里输入矩阵后，用for循环循环遍历 ```a[][]```，每次访问一个不等于 $-1$ 的数字，它的坐标是 ```a[x][y]```。这时我们写的函数就有用场了。先将 $cnt$ 的值设为 $0$ ，然后运行函数 ```cp(x,y,0,0)```，最后如果 $cnt \geq 3$，那么 $ans + 1$。运行完后继续查找矩阵中还有没有这样的数。
 
### 正解代码
 
```cpp
#include <bits/stdc++.h>
using namespace std;
int cnt,ans;
int a[101][101];

void cp(int x,int y,int x1,int y1)
{
    a[x][y] = -1;
    cnt ++;
    for(int i=-1;i<=1;i+=2)
    {
		for(int j=-1;j<=1;j+=2)
		{
			if(i!=x1 || j!=y1)
			{
				if(a[x+i][y+j] == a[x][y])
				{
					cp(x+i,y+i,0-i,0-j);
				}
			}
		}
	}
}

int main()
{
    int H,W;
    cin >> H >> W;
    for(int i=1;i<=H;i++)
    {
        for(int j=1;j<=W;j++)
        {
            cin >> a[H][W];
        }
    }
    for(int i=1;i<=H;i++)
    {
        for(int j=1;j<=W;j++)
        {
            if(a[i][j] != -1)
            {
                cnt == 0;
                cp(i,j,0,0);
                if(cnt >= 3) ans++; 
            } 
        }
    }
    return 0;
}
```