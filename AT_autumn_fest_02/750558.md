# 此题略水
题目意思：有H行W列的矩阵，每一个矩阵都有一个数字填充。我们需要找出连续的横着3个及以上或竖着3个及以上的，由同一数字构成的长方形。**连通的只算一个**

————————题目意思解释————————

~~不懂？~~ 来看下面一组数据

0123

1113

0123

按理有三个由同一数字构成的长方形。

0**1**2**3**

**1113**

0**1**2**3**

但是**连通的只算一个**

那么，答案是2：

012**3**

**1113**

012**3**

————————解题思路分析————————

了解完题目意思之后，我们来分析解题思路：

基本分为以下几步：

1、输入矩阵

2、找出可能连着的三个

3、利用dfs（深搜）排除连通过的长方形

4、最后输出答案

简单来说此题还是很水的，大家平时冷静思考，编程思路一定会更上一层楼~~我除外~~。

# AC代码：
```c
#include<bits/stdc++.h>
using namespace std;
const int MAX=101;//定义常量，用于分配
int N,M,sum,book[MAX][MAX];
char mat[MAX][MAX];
void fun(int x,int y,char z) {
	if(x<1||y<1||x>N||y>M||!(mat[x][y]==z)||book[x][y]==0)return ;//判断越界和是否用过
	else{
		book[x][y]=0;//这一步很重要，用于排除已经联通的长方形
		fun(x+1,y,z);fun(x-1,y,z);//继续深搜，找左一个和右一个
		fun(x,y+1,z);fun(x,y-1,z);;//继续深搜，找上一个和下一个
	}
}
int main() {
	cin>>N>>M;
	for(int i=1; i<=N; i++){
		for(int j=1; j<=M; j++){
			cin>>mat[i][j];//输入矩阵
		}	
	}
	
	for(int i=1; i<=N; i++){//找出连续的横着3个及以上或竖着3个及以上的，由同一数字构成的长方形
		for(int j=1; j<=M; j++){
			if(mat[i][j]==mat[i][j+1]&&mat[i][j]==mat[i][j+2]){
				book[i][j]=book[i][j+1]=book[i][j+2]=1;//标记为符合的长方形
			}
			if(mat[i][j]==mat[i+1][j]&&mat[i][j]==mat[i+2][j]){
				book[i][j]=book[i+1][j]=book[i+2][j]=1;//标记为符合的长方形
			}	
		}
	}
	for(int i=1; i<=N; i++){
		for(int j=1; j<=M; j++){
			if(book[i][j]==1){//如果是符合要求的长方形
				fun(i,j,mat[i][j]);//进行深搜
				sum++;//和加1
			}	
		}
	}
	cout<<sum<<endl;//输出和
	return 0;
}
```
如果对你有帮助，点个赞吧QAQ
