一看题目，我们知道这是一道区间修改+区间求和的题，于是自然而然地想到了线段树。

但看看数据范围：

$n\le10^9,m\le10^3$

线段树空间会炸 ~~（不会写动态开点）~~，按题目模拟时间、空间都炸。

为什么模拟的时间会炸呢？~~（不炸的话不就是红题了吗）~~

因为我们**进行过太多不必要的操作**。

---

例如样例：

```
5 5
2 1 2
1 4 4 2
1 2 4 7
1 4 5 6
2 3 4
```

最开始：
| ① | ② | ③ | ④ | ⑤ |
| :----------: | :----------: | :----------: | :----------: | :----------: |
| 0 | 0 | 0 | 0 | 0 |

接着（`1 4 4 2`）：
| ① | ② | ③ | ④ | ⑤ |
| :----------: | :----------: | :----------: | :----------: | :----------: |
| 0 | 0 | 0 | 2 | 0 |

然后（`1 2 4 7`）：
| ① | ② | ③ | ④ | ⑤ |
| :----------: | :----------: | :----------: | :----------: | :----------: |
| 0 | 7 | 7 | 9 | 0 |
$\scriptsize这里对②操作是没用的。$

最终（`1 4 5 6`）：
| ① | ② | ③ | ④ | ⑤ |
| :----------: | :----------: | :----------: | :----------: | :----------: |
| 0 | 7 | 7 | 15 | 6 |
$\scriptsize这里对②和⑤操作都是没用的。$

$③+④=7+15=22$

---

容易发现，对没有查询的人操作是没用的。

我们可以利用线段树 懒标记（lazy tag）的思想，**先把操作存下来，查询时只计算有关操作**。

记得开`long long`！

代码：
```cpp
#include <bits/stdc++.h>//万能头
using namespace std;

typedef long long LL;//减少码量
int main()
{
	vector <int> l,r;//与其他题解不同，这里使用vector存储操作
	vector <LL> k;
	int n,m;
	LL ans;
	scanf("%d%d",&n,&m);
	int op,x,y;
	LL z;
	while(m--)//等同于for(;m>0;m--)
	{
		scanf("%d",&op);
		if(op==1)
		{
			scanf("%d%d%lld",&x,&y,&z);//scanf,printf读入输出 long long 时,要用 %lld 
			l.push_back(x);//在vector后面加入元素
			r.push_back(y);
			k.push_back(z);
		}
		else if(op==2)
		{
			scanf("%d%d",&x,&y);
			ans=0;//记得清零
			for(int i=0;i<k.size();i++)//遍历之前所有操作
			{
				if(x<=r[i]&&y>=l[i])//这里后面会讲
				{
					ans+=(min(y,r[i])-max(x,l[i])+1)*k[i];
				}
			}
			printf("%lld\n",ans);
		}
	}
	return 0;
}
```

好了，我们看看要讲的部分：
```cpp
if(x<=r[i]&&y>=l[i])
{
	ans+=(min(y,r[i])-max(x,l[i])+1)*k[i];
}

```
解释：

`x<=r[i]&&y>=l[i]` ：整数区间 $\left[l_i,r_i\right]$ 和 整数区间 $\left[x,y\right]$ 有交集，即操作区间和查询区间有关系。

`(min(y,r[i])-max(x,l[i])+1)*k[i];` ：$(整数区间 \left[l_i,r_i\right] 与 整数区间\left[x,y\right] 的交集的元素个数)\times k_i$，说白了就是操作查询区间多少个数 乘 加了多少，即操作让区间总和加了多少。

$End\ Of\ File$.