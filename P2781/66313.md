# P2781【传教】
题目描述&样例输入/输出：[这里](https://www.luogu.com.cn/problem/P2781)

~~不明白这题我为什么交了10次才过~~

这题题目描述非常像线段树的模板题，但是 $n \leq 10^9$ 这个数据范围就很难受

看到题解里也有使用优化后的线段树通过了此题的dalao，但是我太菜了，所以打算换一种方法。

（顺便一说，本蒟蒻隐隐约约的感觉到本题似乎和差分有一点微妙的联系，有兴趣的同学可以想一下）

现在开始介绍正解。

观察题目，我们可以看到所有的操作可以分为以下两类：

1. 传教(需要的变量为左端点 $l$ ,右端点 $r$ ,以及操作值 $k$ )

2. 检查传教效果(需要的变量为左端点 $l$ ,右端点 $r$)

这样的话就好办了，

我们首先声明两个结构体数组:

```cpp
struct node{
	int id;//操作的序号
	int l;//左端点
	int r;//右端点
	int k;//操作值
}arr[maxn];
```
（这一个结构体负责存储“传教”这个操作）

```cpp
struct info{
	int id;//操作的序号
	int l;//左端点
	int r;//右端点
}infos[maxn];
```
（这一个结构体负责存储“检查传教效果这个操作”）

接下来我们就可以输入所有的操作了

```cpp
for(int i=1;i<=m;i++){
	int com;
	cin>>com;
	if(com==1){
		n1++;
		cin>>arr[n1].l>>arr[n1].r>>arr[n1].k;
		arr[n1].id=i;//储存当前为第几个操作，后面有用	
	}
	else{
		n2++;
		cin>>infos[n2].l>>infos[n2].r;
		infos[n2].id=i;//储存当前为第几个操作，后面有用
	}	
}
```

之后针对每一个查询的操作，我们都遍历一次“传教”操作的数组

不过！我们可以有一些“剪枝”

由于每一次的查询操作是针对所有在它之前的插入操作的，所以而且操作序号是递增的，

所以我们就可以在遍历插入数组时遇到操作序号大于当前查询操作的序号时就跳出遍历

所以我们就有了

```cpp
if(arr[j].id>infos[i].id)break;
```

我们接着来看，如果“插入”操作的区间和“查询”操作的区间完全相离，就说明他们没有一点关系，就可以跳过当前的“查询操作”

于是，我们就有了

```cpp
if(arr[j].r<infos[i].l||arr[j].l>infos[i].r)continue;
```

接下来我们来欣赏某位抽象大师的画作

![a](https://cdn.luogu.com.cn/upload/image_hosting/hl2s5pmf.png)


（图中的相同颜色的端点表示同一个区间）

发现了一个什么问题？？

无论区间端点的关系如何，我们需要的只是中间的两个端点

于是：

```cpp
int rl,rr;
rl=max(arr[j].l,infos[i].l);
rr=min(arr[j].r,infos[i].r);
```

最后我们计算就好了，（注意一点，k值可能为负，但信仰值一定不能为负~~这就是我为什么WA了那么多次的原因~~）

```cpp
long long tmp=(ll)(rr-rl+1)*arr[j].k;
if(tmp>0ll)ans+=tmp;
```
输出即可。

（你问我代码呢？全都在上面了呀）


