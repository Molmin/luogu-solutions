## 写在前面

说实话，本题的难度评蓝实在偏高，评个绿题以下应该差不多。~~但谁会拒绝一道蓝题入账呢？~~

闲言少叙，我们进入主题。

## 思路

为什么说这题简单呢？因为这题不仅是思维还是代码都很简单。

先理解一下题意吧：

- 两个人要见面；
- 第一个人（就是那只猫头鹰）在第 $[l_1, r_1]$ 分钟有空，第二个人（就是那只刺猬）在第 $[l_2, r_2]$ 分钟有空；
- 那只猫头鹰要在第 $k$ 分钟去补个妆。
- 保证 $l_1 \leq r_1$，$l_2 < r_2$。（赞美良心出题人）。

可以发现，这题的题面给的很有提示性（尤其是两个时间用的还是 $l$ 和 $r$）。于是，运用小学数学知识，我们知道算一个区间 $[l, r]$ 的长度是 $l - r + 1$。万事俱备，让我们开始写代码吧。

## 实现

这里我们需要考虑一些细节：

- 如果两个人有空的时间不重合怎么办？（表现为 $l_1 > r_2$ 或者 $l_2 > r_1$）。
- 如果那只猫头鹰需要补妆，怎么办？
- 如果那只猫头鹰在会面前（会面后）才补妆，会怎么样？

对于第一个细节，直接在一开始特判输出 $0$ 即可。

对于第二个细节，将它们能相遇的时间（答案）减 $1$ 即可。

对于第三个细节，那就不用考虑补妆的事了（毕竟对于答案没影响）。

最后，看一眼数据范围：

$1 \leq l_1,  r_11, l_2, r_2 \leq 10^{18}$。

考虑到思路中并未提到要将两个正数变量相加，所以 `long long` 撑得住。

### Code

```cpp
#include <iostream>
#include <algorithm>
#include <vector>
#include <queue>
#include <cmath>
using namespace std;

long long l1, r1, l2, r2, k;

int main()
{
	std::ios::sync_with_stdio(false);
	
	cin >> l1 >> r1 >> l2 >> r2 >> k;
	
	if (l1 > r2 || l2 > r1)
	{
		cout << 0 << endl;
		return 0;
	}
	
	long long l, r, ans = 0;
	l = max(l1, l2);
	r = min(r1, r2);
	ans = r - l + 1;
	
	if (k >= l && k <= r) ans--;
	
	cout << ans << endl;
}
```

本题实属小清新良心练手题之典范。