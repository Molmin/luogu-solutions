# CF92B Binary Number
#### [ _传送门_ ](https://www.luogu.com.cn/problem/CF92B)
## 思路
首先，这道题的输入为一个长度为$10^6$以内的二进制数（01串）。

由于这个数太大了，转成十进制处理根本存不下，我们就只能用$char\enspace[\enspace]$或者$string$存~~我才不会告诉你我用char的原因是可以scanf快速读入~~。

我们可以用一个整形存下现在操作的一位，记它为$x$,

如果$a[x]$是$\begin{cases}0&x--\\1&a[--x]++\\2&a[--x]++\end{cases}$

我们来解释一下上面的操作。

如果这一位（最后一位）是 $0$，代表它是偶数，应该除以 $2$，而在二进制中，除以 $2$就是右移一位，在字符数组里就是将最后一位省去，即$x--$。

如果它是 $1$，代表它是奇数，应该加 $1$，加一会让这一位变成 $2$，满二进一，则为前一位加 $1$，即$a[--x]++$（将$a[x]='0';a[x-1]++;$省略成一步，需要注意，这里由于省略了这一步为 $0$时，操作数要另外加 $1$）

因为这个数本身的最大值为 $1$，而上一位最多向这一位进一，所以每一位的最大值为 $2$。

当这一位为 $2$ 时，代表后面的数向这一位进了 $1$，且它本身为 $1$，接下来见 $1$ 的操作即可（需要注意，这一步并没有省略把自己设为 $0$ 一步，不需要额外加一次操作次数）。

需要注意，当这个串的长度为 $1$ 时（$x=1$时），$a[x]$ $\begin{cases}1& cout<<n; \\2&cout<<++n;\end{cases}$

最后一位为 $2$ 代表这个串为 $10$，按操作即为$n++;i--;$，所以操作数要加 $1$ 。

现在上AC代码~

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e6+10;
char a[N];
int n;
int main(){
	scanf("%s",a);
	int i=strlen(a+1);
	while(i){
		n++;
		switch(a[i]){
			case '0':{//0的操作
				i--;//直接省略后面一位
				break;
			}
			case '1':{
			    n++;//额外加操作次数
				a[--i]++;//向前进位
				break;
			}
			case '2':{
				a[--i]++;//向前进位
				break;
			}
		}
	}
	if(a[i]=='2'){
		n++;
	}
	printf("%d",n);
	return 0;
}
```
那这就再见了qwq