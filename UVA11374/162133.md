
###### 闲聊吐槽篇：
非常有意思的一个题， 整体思路比较巧妙， 思考难度不是很高， 但是考察的点很细很细（尤其是输出部分的点，锅太多了）， 此题评分紫应该就是在细节上叭。。。 （那么至此闲聊吐槽结束


题面链接：[题面](https://www.luogu.com.cn/problem/UVA11374)



## **分析算法：**

分析一个问题的算法，这也是算法竞赛中所应做的第一步。

大体题意： 我们要前往飞机场， 这其中有若干个车站， 两车站间有经济线或者是商业线。 商业线和经济线都有一定的时间通往下一个点， 商业线是更省时间的。 我们只能走**一次**商业线， 求此时从起点到终点的**最短时间间隔**。

## 如何算出最短时间

直接想从最短路中进行修改，判断走不走商业线的话，是不太好入手的。但我们要是从商业线入手，便有了突破点。**商业线只能走一次，所以可以枚举到底走哪个商业线，然后对于每个商业线，我们O（1）算出对应的时间花费，最后选取一个最优的即可。**


首先假设此时有一个商业线是 （A,B） （从A点连接到B点），如果想算出此时的答案的话，该怎么办呢？


很显然， 此时的答案Cur_ans=(** _**从起点到A点的时间+从B点到终点的时间+两点所需要花费的时间**_ **） 


我们姑且把它表示成  **Cur_ans=(dis1[A]+dis2[B]+W)**


显然，此时的dis1[ ]数组便存储的是起点到各个点的最短路径，dis2[ ]数组存的便是终点到各个点的最短路径，而W便是这个“商业线”的花费


我们拿Cur_ans和我们的ans比较（ans初值为由起点跑到终点的最短路径），如果小于当前ans，我们记录一下便可。

```cpp
	int ans=dis[e][0];
		for(int i=1;i<=k;i++)
		{
			int u,v,w;
			u=read(),v=read(),w=read();	
			if(ans>dis[u][0]+dis[v][1]+w)
			{
				ans=dis[u][0]+dis[v][1]+w;
				minu=u;//记录商业站起点
				minv=v;//记录商业站终点
			}
			if(ans>dis[v][0]+dis[u][1]+w)//注意，由于是双向边，记得比较两次，要不然会WA
			{
				ans=dis[v][0]+dis[u][1]+w;
				minu=v;//记录商业站起点
				minv=u;//记录商业站终点
			}
		}
```




## 如何统计路径

### 1.记录

我们在进行dijkstra的时候，**每次由 第 i个点推向第j个点时，那么低j个点的上一个路径点便是i**。所以，我们只需要在进行松弛操作更新下一个点的时候，记录一下即可。

非常朴素的dijkstra板子

```cpp
void dijkstra1(int s)
{
	memset(vis,0,sizeof vis);
    priority_queue<node>q;
    dis[s]=0;
    q.push((node){s,0});
    while(!q.empty())
    {
    	node m=q.top();
    	q.pop();
    	if(vis[m.id])continue;
    	vis[m.id]=1;
    	for(int i=head[m.id];i;i=e[i].next)
    	{
    		if(dis[e[i].to]>dis[m.id]+e[i].dis)
    		{
    			dis[e[i].to]=dis[m.id]+e[i].dis;
    			pre[e[i].to]=m.id;//记录节点
    			q.push((node){e[i].to,dis[e[i].to]});
			}
		}
	}
}
```

（dijkstra记得跑两次，一个是起点，一个是终点）

### 2.输出

输出的时候可以用递归。只要前驱节点不是0，那么一直递归下去即可。需要注意的就是这里的输出需要考虑第一个点不要输出空格的问题（卡了我好久）


```cpp
void print1(int x)
{
	if(x==0)return;
	print1(pre[x][0]);
	if(x==s)printf("%d",x);
	else printf(" %d",x);//输出由起点到商业线起点站的路线
}
```

```
void print2(int x)
{
	if(x==0)return;
	printf(" %d",x);
	print2(pre[x][1]);//输出商业线终点站到终点的路线，注意这里的输出格式。
}
```
# 复杂度分析：

##### 预处理：O（mlogn）
##### 枚举商业线：O（k）
##### 总复杂度：O（mlogn+k）



## **~~提醒：记得注意格式问题~~**



