这道题一开始我有多种思路。

【思路$1$：暴力穷举（推荐程度：☆☆☆）】

竞赛期间，如果没有其他思路，只能采用这种骗分的方法。

我们在$[1,∞)$区间进行查找。具体的查找方式是：不停地对该数除以$2,3,5,7$，直到无法整除为止——最后判断除完的数是否为$1$。如果满足的数量等于$n$则输出$i$并结束程序。

于是我们得到了~~48分的TLE~~代码：[（提交记录）](/record/30957721)
```cpp
#include<cstdio>
long long n,t,i;
int mark[]={2,3,5,7},j,x;
int main()
{
    scanf("%lld",&n);
    for(i=1;;i++)
    {
        t=i;
        for(j=0;j<4;j++)while(t%mark[j]==0)t/=mark[j];
        if(t==1)
        {
            if(++x==n)
            {
                printf("%lld",i);
                break;
            }
        }
    }
}
```

【思路$2$：生成法（推荐程度：★★★★）】

![](https://cdn.luogu.com.cn/upload/image_hosting/aj2dpdw3.png)

如上图，我们可以维护五个队列，分别保存$2$的倍数、$3$的倍数、$5$的倍数、$7$的倍数和H数。

该代码的核心部分为：

```cpp
for(i=2;i<=n;i++)
{
    M=q2[f[0]];
    if(q3[f[1]]<M)M=q3[f[1]];
    if(q5[f[2]]<M)M=q5[f[2]];
    if(q7[f[3]]<M)M=q7[f[3]];
    h[i]=M;
    q2[r[0]]=h[i]*2;r[0]++;
    q3[r[1]]=h[i]*3;r[1]++;
    q5[r[2]]=h[i]*5;r[2]++;
    q7[r[3]]=h[i]*7;r[3]++;
    if(q2[f[0]]==M)f[0]++;
    if(q3[f[1]]==M)f[1]++;
    if(q5[f[2]]==M)f[2]++;
    if(q7[f[3]]==M)f[3]++;
}
```
上述的$q$队列没有使用图中的$q[]$，而是直接使用$q[2],q[3],q[5],q[7]$。这样做会让代码更复杂，但更容易理解。

【思路$3$：生成法单队列（推荐程度：★★★★★）】

我们来详细地了解一下这个方法。在这个方法中，我们可以用$4$个指针+$1$个队列的方法大大优化代码。如下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/wlh15hs0.png)

因此，我们对于这个队列，只需要$4$个存放$int$类型的变量作为指针即可。一开始四个指针均等于$1$，然后每一次进行判断，每一次可以向右移动一次指针，而这四种移动的最小值将被存入$h[]$数组中。

所以我们可以得到$AC$代码[（提交记录）](/record/30958052):

```cpp
#include<cstdio>
int n,i,j,f[4]={1,1,1,1},m[]={2,3,5,7};//这四个指针分别为2、3、5、7，而一开始指针都位于1，所以要进行初始化
long long h[100001],M;//不开long long会爆掉！
int main()
{
    scanf("%d",&n);
    h[1]=1;//h[1]初始化为1
    for(i=2;i<=n;i++)
    {
        M=h[f[0]]*m[0];//默认最小值为指针f2所产生的数，然后在3、5、7所产生的数中进行判断，找出2、3、5、7所产生数的最小值（如下）
        for(j=1;j<4;j++)if(h[f[j]]*m[j]<M)M=h[f[j]]*m[j];
        h[i]=M;//这个时候把h[i]赋值为最小值，即M
        for(j=0;j<4;j++)if(M==h[f[j]]*m[j])f[j]++;//判断过后，最小值所对应的指针要向右，即加1
    }
    printf("%lld",h[n]);//最后输出h[]数组中的第n个元素即可
}
```