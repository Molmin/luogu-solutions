首先缩点把环缩掉，变成一个有向无环图，然后再看一下题目：

> 对于三座城市 $x$，$y$，$z$，若 $x\Rightarrow z$ 且 $y\Rightarrow z$，那么有 $x\Rightarrow y$ 或 $y\Rightarrow x$。

对于一个点 $x$，假设有两条与之相连的边 $(a,x)$ 和 $(b,x)$，不妨设 $b\Rightarrow a$，那么将 $(b,x)$ 删去，$b$ 也能先走向 $a$ 再走到 $x$。

因此在拓扑排序时对每个点保留最后一条与之相连的入边不会对原图连通性有影响。

此时就变成了一棵树，注意是有向图，所以能从 $u$ 到达 $v$ 的前提是 $v$ 在 $u$ 子树中。

然后考虑询问操作：

发现每次新增的边数 $k$ 很小，感觉可以暴力，考虑 bfs。

从起点开始向外扩展能走到的新增的边的端点，并记录下走过的路径。

每次扩展前先判断此时能不能到达终点，若能走到，就先将走过的路径丢入桶中，后面再求并集。

然而发现会走很多次重复的路径，所以将扩展的次数记录下来，超过一定次数就不继续扩展。

可以先树剖一遍并记录下 dfs 序，走过的路径就可以拆成一些链求并。

到这里就基本上可以过了，只不过要注意一些优化：

- 如果能走到终点，就将之前记录下的路径清空，优化后面扩展时记录路径的时间。

- 如果一条路径已经在桶中，就没必要再加一遍。

实测扩展次数等于 $4$ 时可过，小于 $4$ 无法找到所有路径，大于 $4$ 会超时。

但是下面这个优化可以直接过：

- 新增的边的起点不需要入队，只需要终点入队。

实测扩展次数等于 $4$ 时可以过，如果三个优化都加上扩展次数在 $4\sim 7$ 时都可以过。

[代码](https://www.luogu.com.cn/paste/hize4p0o)也比较好写。