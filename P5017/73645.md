# 考场上，解出这道题目，靠的就是**“无知者无畏”**的精神。

主要是因为前两题很简单，本以为今年PJ也和往常一样难度，T3简单爆搜，T4~~稍微~~难一点。看到T3不可能爆搜，就往**简单**DP想。没想到这么难。。。硬着头皮想出来了。

闲话少说，开始讲述思路（思考过程）。

下面两个地名。。。~~（CCF打广告？！）~~直接用 A地 和 B地 代替了。

首先，看完题目意思，就想到了算法——**DP**。~~别问我怎么想到的，学OI的人，这个题目是DP都看不出来吗~~

然后，咱们直奔100%的数据~~（这么有自信？！）~~。发现 $ n $ 和 $ m $ 都很小，但是 $ t_i $ 很大，如果DP复杂度中出现了 $ t_i $，那么基本只能是线性的了~~（CCF老年姬）~~。但是有位机房巨佬写了一个 $ O(tm) $ 的，听说最近CCF评测速度有所增加，说不定能过。

反正 $ n,m $ 那么小，明摆着就是让你用的。

那么如何定义状态呢？

首先，排序是必然的。

接着，最容易想到的，最简单的状态定义：

**用 $ f[i] $ 表示前 $ i $ 个人都已经到达B地（上车也可以算到达，毕竟不用等了），所需要的最少总等候时间**。

状态怎么转移？这个题我们选择**刷表**（因为填表太麻烦了，不如直接思考我这个状态到哪里去）

**枚举 $ k $，$ f[k] = f[i] + $ 第 $ (i+1) $个学生到第 $ k $ 个学生的总等车时间。**

**这个总等车时间就是 $ \sum\limits_{x=i+1}^k{ (T-t[x]) } $。$ T $ 是车重新到达A地的时间。**怎么计算呢？

有没有人想当然地把 $ T $ 直接看做 $ t[k] $？

看似是对的，但实际上，第 $ i $ 个学生到达时，车有可能还没有到达A地！但是这样的话怎么做呢？

~~我们的信奥教练LJ：~~“DP不会的东西就加一维”

我们可以把上一次车到达的时间记录下来，放到DP状态的一维里去。这样状态定义就变成了：

**用 $ f[i][j] $ 表示前 $ i $ 个人在 $ j $ 时刻都已经到达B地（同上），所需要的最少总等候时间。**

此时 $ j $ 就是前 $ i $ 个人最后全部接走时车到达的时间。

重新观察状态转移方程，其中 $ max( j + m, t[k]) $ 就是 $ T $。看似好像没有什么问题了。

但是这样一来，$ j $ 又是 $ t_i $ 这个级别的了，承受不起，怎么办呢？

注意到此时，$ j \geqslant t[i] + m $ 的情况都是无意义的，因为如果 $ j \geqslant t[i] + m $，则说明第 $ i $ 个人等了 $ \geqslant m $ 分钟。但是即使车在 $ t[i] - 1 $ 时刻开走，他也只会等上 $ m - 1 $ 分钟啊！（注意，此时我们讨论的是**车一到就把第 $ i $ 个人接走**的情况，不考虑第 $ i + 1 $ 个人以及之后的人，如有不解见状态定义）

所以~~离散化~~状态定义变成了：

**用 $ f[i][j] $ 表示在第 $ i $ 个人等了刚好 $ j $ 分钟的时刻，前 $ i $ 个人已经到达B地（同上），所需要的最少总等候时间。**

重新审视空间复杂度，没有什么问题了。

此时前 $ i $ 个人最后全部接走时车到达的时间就是 $ t[i] + j $。

所以我们可以算出状态转移方程中应该添加的那一维（$ f[k] \rightarrow f[k][?] $ 中的 $ ? $），也就是第 $ k $ 个人的等待时间是：

$ max( t[i] + j + m - t[k], 0 ) = tmp $（下文因为这个量多次出现，所以简化为 $ tmp $）

$ t[i] + j + m $ 就是车到的时间。减去 $ t[k] $ 就是等候的时间。~~这个应该很好理解吧~~

现在 $ T $ 珂以~~不用思考就~~得出：$ T = $ 第 $ k $ 个人等候的时间 $ + t[k] = tmp + t[k] $（当然可以进一步简化~~，但是格式一致，而且少打几个字符~~）

所以现在状态转移方程长这样：

**$ f[k][tmp] = f[i][j] + $ 第 $ (i+1) $个学生到第 $ k $ 个学生的总等车时间。**

**总等车时间 $ = \sum\limits_{x=i+1}^k{ (T-t[x]) } $。$ T = tmp + t[k] $。**

（为什么 $ f[k][0 $ 到 $ tmp-1] $ 不考虑？因为它们不可能达到，为 $ inf $；为什么 $ f[k][tmp+1 $ 到 $ m-1] $ 不考虑？因为它们反正不是最优的，不考虑也没事）

**$ f[k][tmp] = f[i][j] + \sum\limits_{x=i+1}^k{ (tmp+t[k]-t[x]) } $**

计算一下时间复杂度（最差）：遍历状态 $ O(nm) $，枚举转移 $ O(n) $，转移过程。。。怎么还要 $ O(n) $？！$ O(n^3m) $ 不是炸了吗qwq

仔细观察那个 $ \sum $，发现 $ (tmp + t[k]) $ 是定值，所以提出来：

**$ f[k][tmp] = f[i][j] + (tmp + t[k]) \times (k - i) - \sum\limits_{x=i+1}^k{t[x]} $**

然后那个 $ \sum $ 珂以**前缀和**优化！

**$ f[k][tmp] = f[i][j] + (tmp + t[k]) \times (k - i) - (t[k] - t[i]) $**

至此，转移复杂度 $ O(1) $。

所以代码就可以写出来啦~

注意：我写的代码里，枚举的 $ k $ 不是转移方程中的 $ k $，转移方程中的 $ k $ 在我的代码中是 $ i + k $（具体看了代码就明白了）。边界情况我直接把 $ t[0] $ 设做了 $ -inf $（假设有第0个人，上车时间是 $ -inf $，从0开始做，就可以不用更新 $ f[i][0] $ 了）。

当然还有更快的做法（比如 $ O(nm) $），但是考场上能想出~~如此优秀的~~做法就已经不错啦qwq~

**UPDATE 11.21：**

 - 听说有教练把 $ O(t_i) $ 的范围改成了 $ \leqslant 10^9 $，这似乎更加支持与坚定了我的idea~

 - 事实上，如果 $ f[i][j] == inf $，则说明要么第 $ i $ 个人不可能只等 $ j $ 分钟，要么第 $ i $ 个人等待 $ j $ 分钟的情况不可能成为最优解的一部分，故可以不转移。所以……复杂度是 $ O(nm) $ （遍历所有状态）$ \times O( $ 平均每个状态转移复杂度 $ ) $（为 $ O(0) $ 或 $ O(n) $）。所以总复杂度是 $ O(nmk) $。$ k $ 为**玄学**常数。$ 0 \leqslant k \leqslant n $。

 - 实测：$ k \approx log(m) $，也就是说实际复杂度在 $ O(nmlogm) $ 左右qwq

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int t[501],s[501],f[501][101];
const int inf=2139062143;
inline int read()
{
	int neg=1,x=0;
	char c;
	while((c=getchar())<'0'||c>'9')
		if(c=='-')
			neg=-1;
	x=c-'0';
	while((c=getchar())>='0'&&c<='9')
		x=x*10+(c-'0');
	return x*neg;
}
int main()
{
	int n=read(),m=read();
	for(int i=1;i<=n;i++)
		t[i]=read();
	sort(t+1,t+n+1);
	for(int i=1;i<=n;i++)
		s[i]=s[i-1]+t[i];
	memset(f,0x7f,sizeof(f));
	t[0]=-inf;
	f[0][0]=0;
	for(int i=0;i<=n;i++)
	{
		int MAX=min(m-1,t[i+1]-t[i]);
		for(int j=0;j<=MAX;j++)
			if(f[i][j]!=inf)
				for(int k=1;i+k<=n;k++)
				{
					int tmp=max(t[i]+j+m-t[i+k],0);
					f[i+k][tmp]=min(f[i+k][tmp],f[i][j]+(tmp+t[i+k])*k-(s[i+k]-s[i]));
				}
	}
	int ans=inf;
	for(int i=0;i<m;i++)
		ans=min(ans,f[n][i]);
	printf("%d\n",ans);
	return 0;
}
```