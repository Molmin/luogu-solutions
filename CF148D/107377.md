~~来水一波题解，这有紫？~~

#### upd:修改了markdown。

题意：袋子里有$n$只白鼠和$m$只黑鼠,$A$和$B$轮流从袋子里抓，谁先抓到白色谁就赢。$A$每次随机抓一只，$B$每次随机抓完一只之后会有另一只随机老鼠跑出来。如果两个人都没有抓到白色则$B$赢。$A$先抓，问$A$赢的概率。

题解：我们考虑我们现在有$a$个白鼠，$b$个黑鼠，那么$A$怎样才能胜利？

先考虑边界情况。

如果$a$不为$0$，$b$为$0$，那么$A$先手必定拿的是$a$，那么$A$ $\text{win}$了。

如果$a$为$0$，$b$不为$0$，那么只能抽到$b$，那么$B$ $\text{win}$了。

如果$a$为$0$，$b$为$0$，那么$B$ $\text{win}$了。

考虑完了边界情况，进而考虑正常情况下$A$赢的概率。

$A$一发入魂，直接抽到了$a$，那么$A$就赢了，其概率就是$\frac{a}{a+b}$

$A$抽到了$b$，$B$抽到了$b$，逃出去的是$a$，那么$A$赢得概率就是$\frac{b}{a+b}\frac{b-1}{a+b-1}\frac{a}{a+b-2}f(a-1,b-2)$

$A$抽到了$b$，$B$抽到了$b$，逃出去的是$b$，那么$A$赢得概率就是$\frac{b}{a+b}\frac{b-1}{a+b-1}\frac{b-2}{a+b-2} f(a,b-3)$

其他的就必然是是$B$获胜，这样我们就可以写出一个记忆化搜索的代码。

```cpp

inline double dp (int a, int b) {
    if (vis[a][b]) return f[a][b];
    if (!b && a) return 1;
    if (!a && b) return 0;
    if (!a && !b) return 0;
    vis[a][b] = 1;
    if (b >= 3) f[a][b] += (1.0 * (b * (b - 1) * (b - 2)) / (1.0 * (a + b) *  (a + b - 1) * (a + b - 2))) * dp (a, b - 3);
    if (b >= 2 && a >= 1) f[a][b] += (1.0 * (b * (b - 1) * a) / (1.0 * (a + b) * (a + b - 1) * (a + b - 2))) * dp (a - 1, b - 2);
    f[a][b] += 1.0 * a / (a + b);
    return f[a][b]; 
}

```

