## Solution:

我们看到这道题的时候，也许是毫无思路的，但这很正常，因为我也是。

考虑推规律。

我们会发现，当 $p=0$ 时，所有数都为原来的 $\frac{1}{2}$；

我们也会想到，如果没有这个0.5，这就是一道简单的求最小公倍数的题目。

那么我们对于枚举一个区间内的最小公倍数是如何枚举的？从他们的最小公倍数开始枚举，直到超过范围。

那么我们也考虑相同的想法，但是由于0.5的存在，我们这个需要自己手动推规律（不过貌似另外的题解已经给出了证明公式……），我们可以从所有的数的0.5倍的数字的最小公倍数开始枚举，每次加上原来给定的数字的最小公倍数，我们不难发现每一次得到的数字，就是题目所要求的 $X$。

#### example:

```
input:
3 50
2 6 10

```

我们来模拟一下

$2 \times 0.5=1$ ， $2\times 1.5=3$ …… $2\times12.5=45$……

$6\times0.5=3$ ，$6\times 1.5=9$……

其实枚举到这里，应该也就有人明白了，和原来的求最小公倍数相比，这道题的差距在于枚举的起点不同，后面仍然是每次加上给定的数字，也就是与求最小公倍数没有区别。

再回到上面的例子，我们会发现，他们三个数的最小公倍数是30，而他们除2得到的数字的最小公倍数为15，而他们按照题意得出的$X$，是45。

好，规律出来了，接下来我们只需要用一个简单的等差数列公式，就可以求出这个区间内的 $X$ 的个数，也就是说，我们所要求的 $X$ 就是从原数除2之后的最小公倍数开始，每次加上原数的最小公倍数的数字。

-----
考虑答案为0的情况。

我们可以发现，$X=a_{i}\times(p+0.5)$，由$a_{i}$为偶数，变换原式，得到$X=\frac{1}{2}a_{i} \times (2p+1)$ 由于 $p$ 是一个自然数，我们不难得出，$2p+1$ 必然是一个奇数，那么，一旦出现 $2p+1$ 为偶数的情况，证明此数列必然是无解的了。

## Code：
```cpp
#include<bits/stdc++.h>
using namespace std;
long long g = 1, qaq = 1;
int n, m;
int a[100010];
int gcd(int x, int y)
{
    return x % y == 0 ? y : gcd(y, x % y);
}
long long lcm(long long x, long long y)
{
    return x * y / gcd(x, y);
}
int main()
{
    scanf("%d%d", &n, &m);
    for (int i = 1;i <= n;i++)
    {
        scanf("%d", &a[i]);
        g = lcm(a[i], g);
        qaq = lcm(a[i] >> 1, qaq);
    }
    for (int i = 1;i <= n;i++)
    {
        if (qaq / (a[i] / 2) % 2 == 0)//特判p为奇数还是偶数
        {
            cout << 0;
            return 0;
        }
    }
    long long ans = (m - g / 2) / g + 1;
    printf("%lld\n", ans);
    return 0;
}
```