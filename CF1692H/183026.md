考虑枚举每次选择哪个数，可以发现每次对于选择的数对幂次带来的贡献为 $1$，否则为 $-1$，问题转化为 $1,-1$ 最大子段和，然后对于每次枚举的这个我们选择的数，我们不妨记作 $x$，显然我们不需要每个数都打标记做一次，我们只需要把原数列按 $x$ 分段，关心每段的和

![1655436194300.png](https://img-kysic-1258722770.file.myqcloud.com/b396da11c4f1843ba8414c5a7591eb98/e909f854dbfec.png)

比如这张图，红色的部分是 $x$，那我们只需要把每块红色和白色看作整体做最大子段和，这样的有效段数是 $cnt_x$ 的。

这个问题是平凡的，势能分析得复杂度线性。瓶颈在于离散化。

实现过程要精细一点，不然一不小心就炸了，比如你做最大子段和的时候全部撸了一遍标记啊之类的。

我没写代码，但是三月写了，你们参考一下也行：

[代码](https://codeforces.com/contest/1692/submission/160547718)