```
/*
一、一句话题意
一张你n，m的地图，然后跑图，看看是否有环。
什么是环？
就是走一圈能走到起点。
然后至少有四个点。
有输出Yes，没有输出No。
二、思路
思路已经非常清晰了。
我们直接把整个地图搜一遍，搜索时每次都搜相同的颜色。
如果搜到一个走过的点，那么就是一个环。 
我们可以用一个b来存储初始的颜色，防止它乱搜。 
三、代码
代码里有一些细节。
以下是AC代码： 
吐槽一下：
话说这为啥是道蓝题。
请大家不要被它吓到了。
*/
include<bits/stdc++.h>
#define itn int//防手滑大法。 
using namespace std;
const int dx[5]={-1,0,0,1};//移动数组就不说啦。 
const int dy[5]={0,1,-1,0};
int biaoji[52][52];//用作标记防止重复搜索。 
int n,m;
char b;//存上一个走的是哪个字母。 
int tot;//走的步数。 
char a[52][52];//存地图。 
void dfs(int x,int y,int qx,int qy,int sx,int sy)//现在所处位置x，y，起点位置qx，qy，上一次走的位置sx，sy。
{
	tot++;//步数++。 
	for(int i=0;i<4;i++)
	{
		int mx=x+dx[i];
		int my=y+dy[i];		
		if(sx==mx&&sy==my)//不能搜到它上一个走的位置。 
		continue;
		if(biaoji[mx][my]==1&&tot>=4&&a[mx][my]==a[qx][qy])//走的步数要大于4，而且是走了一圈再回到起点,一定注意要有第三个条件，保证走的是初始颜色。 
		{
			cout<<"Yes";//有就直接输出了，节约时间。 
			exit(0);//类似于return 0。 
		}
		if(mx<=0||my<=0||mx>n||my>m||biaoji[mx][my]==1||a[mx][my]!=a[qx][qy])//不能出界，不能走走过的位置，不能走不同颜色的位置。 
		continue;
		biaoji[mx][my]=1;//标记。 
		dfs(mx,my,qx,qy,x,y);//继续搜索。 
		tot--;//回溯。 
	}
}
int main()
{
	cin>>n>>m;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			cin>>a[i][j];
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			if(biaoji[i][j]==0)//不走走过的位置 
			{
				biaoji[i][j]=1;//标记 
				tot=0;//步数重置 
				b=a[i][j];//存储初始颜色 
				dfs(i,j,i,j,0,0);//开始搜索，上一次没有位置，故给0和0。 
			}
	cout<<"No";//如果里面没搜到，说明没有，直接不行。 
	return 0;
}
```

