**说实在的，看到这题的第一感觉是：题干长的吓人。。。**

不过，超过一半都基本上~~是废话~~；

## 来分析一下：

当bessie走到某一时刻时，共有以下两种情况;

1. 之前不欠
2. 之前已有欠钱

Bessie与这头牛的关系又分别有两种情况：

1. **之前不欠，当前奶牛欠贝西**  策略：没什么好说的，收钱，向前走
2. **之前不欠，当前贝西欠奶牛**策略：能还，还；不能换，记录下欠钱位置，向前走；
3. **之前欠，当前奶牛欠贝西**策略：收钱，如能还，回去还；如不能，向前走
4. **之前欠，当前贝西欠奶牛** 策略：欠钱数增加

好了，上代码：

```cpp
#include<iostream>
#include<cmath>//头文件
using namespace std;
int main()
{
	int n,d[1010];//数组记录
	cin>>n;
   //输入
	for(int i=1;i<=n;i++)
	{
		cin>>d[i];
	}
    //cur记录步数，i记录位置，m记录
    //已得钱数，q记录欠钱数
	int cur=0,i=1,m=0,q=0;
    //wz记录第一次欠钱位置
	int wz;
	while(i<=n)
	{
    //之前不欠，当前奶牛欠贝西
		if((q==0)&&(d[i]>=0))
		{
        //收钱，向前走
			m+=d[i];
			i++;
			cur++;
		}
        //之前欠，当前奶牛欠贝西
		else if((q!=0)&&(d[i]>=0))
		{
        //收钱
			m+=d[i];
        //能还，回到第一次欠钱位置（wz）还
			if(m>=q)
			{
				cur+=(i-wz)*2;
				m-=q;
				q=0;
				i++;
				cur++; 
			}
         //不能还，向前走
			else
			{
				i++;
				cur++;
			}
		}
     //之前不欠，当前奶牛欠贝西
		else if((q==0)&&(d[i]<0))
		{
        //能还，直接还
			if(m>=abs(d[i]))
			{
				m-=d[i];
				i++;
				cur++;
			}
        //不能还，记录位置，走
			else
			{
				q-=d[i];
				wz=i;
				i++;
				cur++;
			}
		}
     //之前欠，当前贝西欠奶牛
		else if((q!=0)&&(d[i]<0))
		{
        //增加欠钱数
			q-=d[i];
			i++;
			cur++;
		}
	}
   //输出
	cout<<cur<<endl;
	return 0;
}
```
