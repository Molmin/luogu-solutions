~~我绝对不会告诉你我交了3遍才AC~~

作为比赛的$T1$，出题人还是很良心的
# 前置芝士：

[基础排序算法](https://blog.csdn.net/u013249965/article/details/52575324)

**直接插入排序：**

基本思想：每一步将一个待排序的数据插入到前面已经排好序的有序序列中，直到插完所有元素为止。

算法概念：直接插入排序是将无序序列中的数据插入到有序的序列中，在遍历无序序列时，首先拿无序序列中的首元素去与有序序列中的每一个元素比较并插入到合适的位置，一直到无序序列中的所有元素插完为止。

让我们来结合一个栗子分析一下：对于一个无序序列{$4,6,8,5,9$}来说，我们首先先确定首元素$4$是有序的，然后在无序序列中向右遍历，$6$大于$4$则它插入到$4$的后面，再继续遍历到$8$，$8$大于$6$则插入到$6$的后面，这样继续直到得到有序序列{$4,6,8,5,9$}。
# 思路：

对于这道题目而言，用一个$bool$数组（$f$）记录屏障，然后使用插入排序，在排序过程中一旦碰到屏障就跳过屏障，从屏障后面继续排序。
# 废话不多说，上代码：

插入排序+一维数组记录屏障，代码如下（含注释）：

```cpp
#include<bits/stdc++.h>//懒人专用头文件
using namespace std;
int n,m,a[500005];//意义见题面
bool f[500005];//记录屏障的位置
int main(){
    cin>>n>>m;
    for(int i=1;i<=n;i++){
        cin>>a[i];
    }//输入
    int x;
    if(m==0){
        sort(a+1,a+n+1);
        for(int i=1;i<=n;i++){
            cout<<a[i]<<" ";
        }
        return 0;
    }//特判m=0，能省点时间，毕竟快排还是比插入排序快（去掉就会TLE）
    for(int i=1;i<=m;i++){
        cin>>x;
        f[x+1]=1;
    }//输入屏障
    int i,j;
    for(i=2;i<=n;i++){//从第2个数据开始插入
        int temp=a[i];//临时变量记录要插入的数据
        for(j=i-1;j>=0&&a[j]>temp;j--){//从后向前，找到比其小的数的位置,注意是j>=0；
            if(f[j+1]){
                break;
            }//判断有没有屏障，有屏障就跳过
            swap(a[j+1],a[j]); //向后挪动
        }
        a[j+1]=temp;//如果找到了比temp小的则将temp放在比它小的后面；如果没找到比他小的，也就是它最小这时候的j=-1，所以放在了a[j+1]数组第一个那里
    }//插入排序板子
    for(int i=1;i<=n;i++){
        cout<<a[i]<<" ";
    }//输出
    return 0;
}
```

终于$AC$了$......wtcl$

[评测记录](https://www.luogu.com.cn/record/46320973)