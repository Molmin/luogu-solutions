题目是要求是要把 $m + 1$ 个段分别排序。如下图（以**排序后的**样例2为例）：

![](https://ftp.bmp.ovh/imgs/2021/02/c72be1878246f36f.png)

我们会发现，这 $m + 1$ 个段分别是 $[1, x_1], [x_1 + 1, x_2], \cdots, [x_{m - 1} + 1, x_m], [x_m + 1, n]$。

我们可以把每个段都标上编号。例如，$[1, x_1]$ 中的每一个都标上1，$[x_1 + 1, x_2]$ 都标上2，以此类推，直到 $[x_m + 1, n]$。

我用了一个结构体来表示整个序列：
```cpp
struct elec {
	int num;//拥有的能量
	bool h;//标记，是不是位于x[i]处
	int bianhao;//编号
}a[500001];
```

接着，我们来处理如何排序的问题。

由于我们有了编号，就容易的多了。判断这些编号是否相等，即是否是一样的段（没有被“奇怪的力”隔开）。
- 如果相等，那么可以交换，就开始比较及交换。
- 否则，也就是无论如何都交换不了，那么就什么也不做。

```cpp
bool cmp (elec x, elect y) {
	if (x.num < y.num && x.bianhao == y.bianhao) {
		//编号相同但不有序
		return true;
	}
	else return false;
}
```

最后一个问题就是如何写编号了。我们可以把分割每个段的地方（就是有“奇怪的力”的地方）记录下来，比如用我结构体中的 $h$ 标记，然后设定一个值，用来设定每一段的编号。最后扫描一下数组，先把编号赋值上去，如果发现有数组中有标记，那么就说明一个段结束了，应该更改设定的值了。

```cpp
	int n, m;
	scanf ("%d%d", &n, &m);
	for (int i = 1; i <= n; i++) {
		scanf ("%d", &a[i].num);
	}
	for (int i = 1; i <= m; i++) {
		scanf ("%d", &x[i]);
		a[x[i]].h = true;//标记
	}
	int l = 1;//设定的值
	for (int i = 1; i <= n; i++) {
		a[i].bianhao = l;
		if (a[i].h) ++l;//更改设定的值
	}
```

接着，使用我们定义的 cmp 函数，sort 一下即可。