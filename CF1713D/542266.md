### - [原题传送门](https://codeforces.com/contest/1713/problem/D)

### - [洛谷传送门](https://www.luogu.com.cn/problem/CF1713D)
--------

### 题意

一道交互题。

有多组数据，给你一个数 $n$，表示有 $2^n$ 个人在比赛，一旦有人输了一场就会被淘汰。你需要向评测机询问 $x$ 和 $y$ 谁胜的场次多。

- 若返回 $1$ 表示 $x$ 胜的场次多。
- 若返回 $2$ 表示 $y$ 胜的场次多。
- 若返回 $0$ 表示 $x$ 与 $y$ 胜的场次一样多。

注意询问不得超过 $\frac{1}{3} \times 2^{n+1}$ 次，最终请你输出最后胜出了的人的编号。

### 思路

我们可以将所有人各分成 $4$ 个人一组。

假设 $4$ 个人从小到大分别是 $a$, $b$, $c$, $d$。第一次若询问 $a$ 与 $c$。

- 返回是 $0$，表明 $a$ 与 $c$ 都不是四人中最终获胜的，我们询问 $b$ 和 $d$，因为四人中胜利的人胜的场次是最多的。

- 返回是 $1$，表明 $a$ 必然胜过了 $b$ 也胜过了 $c$，之后询问 $a$ 和 $d$。

- 返回是 $2$，表明 $c$ 胜过了 $a$ 与 $d$，这之后只用询问 $b$ 和 $c$ 了。

四个人不管怎么给的回答，都能用两次找到此次在 $4$ 人中最终获胜的人。

那么此题就可以这么做了，之后，我们在最后时只剩 $1$ 个人或 $2$ 个人时，直接判断并输出。

之后，我们要把每次获胜的人记录下来，这样才能方便继续往下做。

我的做法就是在此多加入一个 $b$ 数组，作用是在询问时，把我们已经知道的获胜的人先存入 $b$ 数组，之后就更新 $n$，现在表示的是现在还有多少个在原先比赛获胜的人，将这个数组中的人反存入原先的 $a$ 数组，这样我们再调亿下细节，此题就结束了。

需要注意的在做这题时，应该根据你的代码询问的具体内容进行询问。如当你的代码在跑样例时询问：

```cpp
? 1 3
```
你就应按照样例给出的图片输入 $1$，也就是 $1$ 胜利的场次比 $3$ 多。

### 代码

```cpp
//交互题需刷新缓冲块，但是使用cin/cout的就按平常做就行了
//若使用scanf/printf的就需加上fflush(stdout)
while(T--){
	cin>>n;
	n=1<<n;//将总人数算出
	for(int i=1;i<=n;i++)//记录每个人的编号
    	a[i]=i;
	while(1){//因为不知道需做多少次，所以先死循环
		if(n==1){//只剩下一人了，输出此人所在的编号
			cout<<"!"<<" "<<a[1]<<endl;
			break;
		}
		if(n==2){//还剩两人，问一下评测机谁胜的场次多，再输出胜者
			cout<<"? "<<a[1]<<" "<<a[2]<<endl;
			cin>>op;
			if(op==1)
				cout<<"! "<<a[1]<<endl;
			else cout<<"! "<<a[2]<<endl;
			break;
		}
		else{
        	//I表示的是现在分成四人组的第一个人是谁
            //num表示有几个人进入了下一轮
			I=1;num=0;
			while(1){//还是不知道要做几轮，于是再来一个死循环
         	  	//x和y表示的是当前比的是谁和谁
				x=I;
				y=I+2;
				if(x>n)//已经超过了n人了，就退出
           			break;
				cout<<"? "<<a[x]<<" "<<a[y]<<endl;
				cin>>op;
				if(op==0){//两人平了，胜者只能是a[x+1]和a[y+1]的人了，便再次询问
					x++;
					y++;
					cout<<"? "<<a[x]<<" "<<a[y]<<endl;
					cin>>op;
					if(op==1){
             			b[num]=a[x];//在b数组存入胜者
                		num++;//人数加1
                		I+=4;//更新，表示下一个四人组的第一个人的编号
                		continue;//完成了，跳过
             		}
					else{b[num]=a[y];num++;I+=4;continue;}
				}
           	    //之后的也就和之前的相差无几了，就不再细讲了
				if(op==1){
					y++;
					cout<<"? "<<a[x]<<" "<<a[y]<<endl;
					cin>>op;
					if(op==1){b[num]=a[x];num++;I+=4;continue;}
					else{b[num]=a[y];num++;I+=4;continue;}
				}
				if(op==2){
					x++;
					cout<<"? "<<a[x]<<" "<<a[y]<<endl;
					cin>>op;
					if(op==1){b[num]=a[x];num++;I+=4;continue;}
					else{b[num]=a[y];num++;I+=4;continue;}
				}
			}
			n=num;//更新还剩下的人的总数
			for(int i=1;i<=n;i++)//把剩下所剩的胜利的人反存入a数组，让a数组继续做上面的判断
				a[i]=b[i];
		}
	}
}
```