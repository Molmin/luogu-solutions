# Solution
这里给出一个每 $4$ 个人询问一次，总询问次数为 $2^{n-1}$ 的做法。

接下来我们以 $n=8$ 的情况举例分析，首先询问 $1\ 3$，如果 $1$ 的胜利次数等于 $3$，那么说明 $1$ 和 $3$ 在该轮同时被淘汰，故 $2$ 和 $4$ 晋级。

接下来考察 $1$ 的胜利次数小于 $3$ 的情况，这种情况下显然 $3$ 必定晋级，但是无法确认 $1 \ 2$ 到底谁晋级，但是我们并不关心这一结果，直接默认 $2$ 晋级即可。理由是假设实际情况是 $1$ 在这一轮晋级，那么由 $3$ 的胜利次数大于 $1$ 可知下一轮 $1$ 必将被 $3$ 淘汰，那么本轮直接假设 $2$ 晋级便不会导致最终答案的错误。

但是在实现的过程中仍需要考虑 $1$ 在本轮晋级对于询问的影响，下面结合具体例子进行分析。$8$ 个人的胜利局数为 $[1,0,3,0,1,0,0,2]$，那么由上述的询问方法询问 $1\ 3$ 以及 $5\ 7$ 之后可知第一局之后 $2,3,5,8$ 四人晋级，但实际情况则是 $1,3,5,8$ 四人晋级，那么下一次再询问 $2\ 5$ 的胜利局数就没有任何的意义，而且也会得出 $5$ 在第二轮晋级的错误结论。由此我们得知在每四个人中，我们应该选择两个**确认晋级**的人进行询问才有意义，比如在上述例子中 在第二轮中应该选择 $3\ 5$ 进行询问而非 $2\ 5$。显然我们总能保证两个人中至少有一个能够**确认晋级**，于是总是能在 $4$ 个人中寻找到 $2$ 个询问对象。在代码实现时只需要将**确认晋级**的人打上 $vis$ 标记即可。

当然接下来考察 $1$ 的胜利次数大于 $3$ 的情况是完全一致的，就不过多赘述了。当最后只剩下 $2$ 个人时，直接询问输出即可。

最后再分析一个例子加深一下理解，$8$ 人的胜利局数为 $[0,3,1,0,2,0,1,0]$。下面粗体标出的即为**确认晋级**的人。

第一轮询问 $1\ 3$ 和 $5\ 7$，得出晋级的人为  $2,$**3**,**5**$,8$，**实际**晋级的人为 $2,3,5,7$。

第二轮询问 $3\ 5$，得出晋级的人为 ***2,5***，**实际**晋级的为 $2\ 5$ (这里 $2$ 变为了确认晋级的人，想一想为什么)。

最后一轮询问 $2\ 5$，得出最终答案为 $2$。

总询问次数为 $2^{n-2}+2^{n-2}+\cdots2^0+1=2^{n-1}$。

时间复杂度 $O(2^n)$。

## Code
```cpp
#include<bits/stdc++.h>
using namespace std;
template<typename T>void outs(const T& h) { cout << h << endl; }
template<typename T, typename...U>void outs(const T& h, const U&...t) { cout << h << " "; outs(t...); }
const int maxn = 1 << 17 | 1;
#define __cs() int T; cin >> T; while (T--)
int n, a[maxn], b[maxn], x, y, z;
bool vis[maxn], tmp[maxn];
void solve() {
    cin >> n;
    for (int i = 1; i <= (1 << n); ++i) {
        vis[i] = 1;
        a[i] = i;
    }
    for (int i = n; i >= 1; --i) {
        if (i == 1) {
            outs("?", a[1], a[2]);
            cin >> x;
            outs("!", x == 1 ? a[1] : a[2]);
        } else {
            int tot = 0;
            for (int j = 1; j <= (1 << i); j += 4) {
                x = (vis[j] ? a[j] : a[j + 1]);
                y = (vis[j + 2] ? a[j + 2] : a[j + 3]);
                outs("?", x, y);
                cin >> z;
                if (z == 0) {
                    b[++tot] = x ^ a[j] ^ a[j + 1];
                    tmp[tot] = 1;
                    b[++tot] = y ^ a[j + 2] ^ a[j + 3];
                    tmp[tot] = 1;
                } else if (z == 1) {
                    b[++tot] = x;
                    tmp[tot] = 1;
                    b[++tot] = y ^ a[j + 2] ^ a[j + 3];
                    tmp[tot] = 0;
                } else {
                    b[++tot] = x ^ a[j] ^ a[j + 1];
                    tmp[tot] = 0;
                    b[++tot] = y;
                    tmp[tot] = 1;
                }
            }
            memcpy(a, b, (tot + 1) * 4);
            memcpy(vis, tmp, tot + 1);
        }
    }
}
int main() {
    __cs()solve();
    return 0;
}
```
