## CF1713D Tournament Countdown
#### 题意简述：
首先，这是一道有趣交互题。给定 $n$ ，有 $2^n$ 个人进行淘汰赛，图中 $n=3$ 。
![](https://espresso.codeforces.com/398ffa6c381e06b463f3ef9ce10b43e9e016b24c.png)  
你可以询问 $\lceil \frac{1}{3} \cdot 2^{n+1}\rceil$ 次，在询问次数内要给出最终答案：冠军的编号。   
每次询问输出两个要询问的对象的编号 $a$ 和 $b$ 。如果 $a$ 比 $b$ 赢的场次多，返回 $1$ ；如果 $a$ 比 $b$ 赢的场次少，返回 $2$ ；如果 $a$ 和 $b$ 赢的场次一样，返回 $0$ 。  
关于交互题的格式和具体细节，请阅读[原题](https://codeforces.com/contest/1713/problem/D)，这里不做解释。
***
最先考虑的，应该是询问次数。如果读者无法通过上述式子推出询问次数，可以将值带进去。  
容易发现，对于每四个人，只能询问**两次**。而且不难看出，这道题是**递归**询问。
***
接下来该考虑如何询问两次得到答案。注意，询问结果是关于**赢的场次**。
所以，我们可以将 $4$ 个人中赢的场次的可能列出来。  
这里列出最小范围 $4$ 个人的可能场次，分别是： $2,1,0,0$ 。为了方便，记这 $4$ 个人分别为 $a,b,c,d$ ，且 $a$ 赢的场次为 $f(a)$ ，并且第一场 $a$ 对 $b$ ， $c$ 对 $d$ 。  
这样，我们就可以询问 $a$ 和 $c$ 。 
- 返回 $1$ 。则 $f(a)>f(c)$ ，那么 $f(a)=1$ 或 $2$ ，所以 $a$ 一定是赢了 $b$ ，这时只需要询问 $a$ 和 $d$ ，以确定谁赢了 $2$ 场。
- 返回 $2$ 。则 $f(a)<f(c)$ ，那么 $f(c)=1$ 或 $2$ ，同理，只需询问 $b$ 和 $c$ 。
- 返回 $0$ 。则 $f(a)=f(c)=0$ ，只需询问 $b$ 和 $d$ 。  

然后再在每 $4$ 个赢了 $2$ 场的人进行相同的操作。
***
虽然这道题是递归思想，但慎用递归实现，如果写不好很容易就挂了，笔者是使用两个队列模拟的，较麻烦。读者自行尝试两种写法。
### code：
~~~ cpp
while(T--)
{
	lans=0;
	cin>>n;
	t=pow(2,n);\\总人数
	for(i=1;i<=t;i++)
	a[i]=i;
	while(t>1)
	{
		tmp=0;\\每轮将4个人中的胜者存到b里，每轮结束后再赋回a
		if(t!=2)\\有可能最终只剩两个人
		{
			for(i=1;i<=t;i+=4)
			{
				int x,y,z,k;
				x=a[i],y=a[i+1],z=a[i+2],k=a[i+3];
				ans=ask(x,z);\\ask函数是询问
				if(ans==1)
				{
					ans=ask(x,k);
					if(ans==1) b[++tmp]=x;
					else b[++tmp]=k;
				}
				else if(ans==2)
				{
					ans=ask(z,y);
					if(ans==1) b[++tmp]=z;
					else b[++tmp]=y;
				}
				else
				{
					ans=ask(y,k);
					if(ans==1) b[++tmp]=y;
					else b[++tmp]=k;
				}
			}
			t/=4;
		}
		else
		{
			ans=ask(a[1],a[2]);
			if(ans==1) lans=a[1];
			else lans=a[2];
			t/=2;
			break;
		}
		for(i=1;i<=tmp;i++)
		a[i]=b[i];
}
~~~
