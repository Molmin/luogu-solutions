这题的主要思路是

## 广搜

- 我们知道，这个人在家中走，有两个必经之路，一个是笔记本电脑位置，一个是门，这两段路都要使得路程最短。

- 我拿到这题第一思路是，在广搜时弄一个标记，记下这段走的路程中有没有覆盖这两个必经之点，并且先覆盖的是电脑，有的话输出最短步数即可

- 可是打完后才发现这种做法白白浪费掉好多空间，而且代码实现也不是很容易，可读性也会很差

怎么办呢？
get正解：

- ### 既然两个点都是要走过的，

### 1. 设这个第一个必经之点为另外一个广搜入口，
### 2. 算两遍广搜出来的最短距离之和，不就是总路程的最短距离之和吗

这是本题的突破口，理解了这个地方，剩下的地方都套模板了

还有个坑点
### 搜第二遍时q数组一定一定要清0！！！

代码中有具体注释

Code

```cpp
#include<bits/stdc++.h>
using namespace std;
int q[2000101][5], n, m, sxx, syy, cxx, cyy, gxx, gyy;
//手打队列时，队列一定要开到2*N*N,我保险起见N开大一倍，队列也要跟着变大
int dx[5] = {0, 1, 0, -1, 0}, dy[5] = {0, 0, 1, 0, -1};
char a[1010][1011];//字符类型的a，定bool类型也可以，但是那几个字母都是真，只有#为假
bool f[1001][1010];//用来判断有没有走过的
string s;
int ans;
int bfs(int fx, int fy, int tx, int ty)
{
    memset(q, 0, sizeof(q));
    memset(f, 0, sizeof(f));//q数组一定要初始化0！！！
    q[1][1] = fx, q[1][2] = fy;//起点入队
    int fl = 0, re = 1;//头尾指针初始化
    while (fl <= re)//也可以把fl++打在后面，不挂等号
    {
        fl ++;//队头扩展一个
        if (q[fl][1] == tx && q[fl][2] == ty)
            return q[fl][3];
   //如果这个位置到达了目标点，就返回到这个点需要的步数
   //ps：一定要把这句话打在外面，不能打在下面的if里面，不然会死循环无输出（我也不知道为啥QwQ）         
        for (int i = 1; i <= 4; i ++)
        {
            int cx = q[fl][1] + dx[i];
            int cy = q[fl][2] + dy[i];
            if (a[cx][cy] != '#' && !f[cx][cy]&&cx >= 1&&cx <= n && cy >= 1 &&cy <= m)//如果这个位置不是墙，并且没有超界，还没有走过
            {
                re ++;
                q[re][1] = cx;
                q[re][2] = cy;//尾指针扩展一个
                f[cx][cy] = 1;//设成走过
                q[re][3] = q[fl][3] + 1;
                //新扩展到这个点的步数
                //等于上个点到这里的步数加一
            }
        }
    }
    return 0;//如果while循环都结束了，还没有到达目标点，就返回0
    //这里不用考虑返回-1，因为如果走到的话，步数不可能为0，所以不会冲突
}
int main()
{
    cin >> n >> m;
    for (int i = 1; i <= n; i ++)
    {
        cin >> s;
        for (int j = 0 ; j < s.size(); j ++)
        {
            if (s[j] == 'S') sxx = i, syy = j + 1, a[i][j+1] = s[j];
            else if (s[j] == '.') a[i][j+1] = s[j];
            else if (s[j] == '#') a[i][j+1] = s[j];
            else if (s[j] == 'C') cxx = i, cyy = j + 1, a[i][j+1] = s[j];
            else if (s[j] == 'G') gxx = i, gyy = j + 1, a[i][j+1] = s[j];
        }//把三个特殊点的位置记录下来，把图存下来
    }
    int z1 = bfs(sxx, syy, cxx, cyy), z2 = bfs(cxx, cyy, gxx, gyy);//z1是房间到笔记本的位置，z2是笔记本到门的位置
    if (z1 == 0 || z2 == 0)//如果这些有一个无法到达的话
    {
    	cout << -1  <<endl;//就输出-1
      //ps:AT的题目一定要换行！！！
    	return 0;//直接结束
    }
    cout << z1+z2<<endl;//否则输出最短距离和，换行
return 0;
}

```

