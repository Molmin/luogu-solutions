题意：

一颗 $n$ 个点的带权树，先手会在一个节点上放一个棋子，从先手开始，他们进行以下操作，将棋子节点的权值 $-1$，选择一个相邻的权值不为零的节点移动棋子。如果有一个人移动之前该节点权值就变成 $0$ 了，那么他就输了。

---

考虑最初始的节点 $u$ ，对于他的相邻节点 $v$ 若有 $a_v\ge a_u$ 则 $u$ 无法去到 $v$ （后手会让棋子移回来，这样就输了）。那么 $u$ 只能去到 $v$ 其中 $a_v<a_u$ ，那么在去到 $v$ 的过程中能不能去到其他的地方“蹭”一下呢？

答案是否定的，因为 $a_v<a_u$ 所以到了 $v$ 之后，后手是不会想要回到 $u$ 的，因为上述原因，所以可以看做 $a_u$ 的大小不会影响后面的操作。如果去蹭了，那么 $a_u$ 会无端减小，对于先手来说不利。这个时候就可以得到结论了：每次都只会去权值较小的节点，其他节点不会去，且不会原路返回。

这样就转换成只要套一个必胜/必败点的板子了。

---

看到别人给的代码都是 $\mathcal O(n^2)$ 的，所以就复读了一下做法然后发一份自己的 $\mathcal O(n)$ 的代码。

```cpp
int f[N],val[N];bool vis[N];
bool dfs(int u){
    if(vis[u])return f[u];
	f[u]=0;vis[u]=1;
    for(int i=head[u];i;i=e[i].nxt)
    if(val[u]>val[e[i].to])
    if(!dfs(e[i].to))f[u]=1;
    return f[u];
}
int main(){
    scanf("%d",&n);
    for(int i=1;i<=n;i++)scanf("%d",&val[i]);
    for(int u,v,i=1;i<n;i++)scanf("%d%d",&u,&v),add(u,v),add(v,u);
    for(int i=1;i<=n;i++)
    if(dfs(i))printf("%d ",i);
}
```