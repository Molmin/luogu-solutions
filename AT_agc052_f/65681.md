显然一次操作相当于翻转一个邻域里有奇数个 $1$ 的点。

操作显然可逆，所以考虑计算可以通过操作变成全 $1$ 的数量。

性质 1：操作不会影响 $1$ 连通块个数的奇偶性。

证明显然，所以合法的状态中 $1$ 连通块个数一定是奇数。

同样的合法状态中至少有一个点可以被操作。

这两个条件显然是必要的，考虑它们什么时候充分。

性质 2：当树上存在一个点度数 $\ge 3$ 且以这个点为根时至少有两个子树有至少两个点时，一个状态合法当且仅当状态中 $1$ 连通块数量为奇数且至少有一个点可以被操作。

证明：若 $1$ 连通块数量为 $1$，则显然这个状态合法。

考虑用一个点来代表一个 $1$ 连通块（可以通过操作连通块中最外面一层的点来缩成一个点）。

此时显然有任意两个 $1$ 不相邻，我们的目标状态即为把所有 $1$ 合并为一个 $1$。

考虑新建两个操作：

1. 若一个点 $u$ 为 $1$，与它相邻的点 $v$ 为 $0$，且与 $v$ 相邻的点中只有 $u$ 一个为 $1$，则可以将 $v$ 设置为 $1$，$u$ 设置为 $0$，称为「交换」。

2. 若一个点 $u$ 为 $0$，与它相邻的点中有奇数个 $1$，可以将这些 $1$ 设置为 $0$，将 $u$ 设置为 $1$，称为「合并」。

引理 1：若以 $u$ 为根的子树中有可进行的操作，且 $u$ 的父亲为 $0$，则一定可以通过若干次操作改变 $u$ 的状态。

证明：考虑归纳证明。

1. 若 $u$ 为 $0$，如果它的儿子中有奇数个 $1$，则可以通过一次合并操作改变 $u$ 的状态；否则记可以操作的点在 $v$ 的子树中，则根据归纳假设可得 $v$ 可以通过若干次操作被改变状态，改变 $v$ 之后通过一次合并操作即可改变 $u$ 的状态。

2. 若 $u$ 为 $1$，如果存在一个儿子的儿子中有偶数个 $1$，则可以通过一次合并操作改变 $u$ 的状态；否则记可以操作的点在 $v$ 儿子的 $w$ 子树中，根据归纳假设可得 $w$ 可以通过若干次操作被改变状态，改变 $w$ 之后通过一次合并操作即可改变 $u$ 的状态。

引理 2：若以 $u$ 为根的子树中无可进行的操作，且 $u$ 为 $0$，$u$ 子树中不全为 $0$，则如果可以给 $u$ 的父亲变为 $1$，则一定可以通过若干次操作使得 $u$ 子树内可以进行合并操作。

证明：考虑归纳证明。

1. 若 $u$ 的所有儿子均为 $0$，则可以通过一次交换操作把 $u$ 的父亲的 $1$ 移到 $u$ 上并递归进子树中，根据归纳假设此时一定成立。

2. 若 $u$ 的所有儿子中有偶数个 $1$，则可以在 $u$ 处进行合并操作。

3. 若 $u$ 的所有儿子中有奇数个 $1$，则与以 $u$ 为根的子树中无可进行的操作矛盾。

回到原来的性质中，考虑以一个度数 $\ge 3$，至少有两个大小 $\ge 2$ 的子树的点 $u$ 为根。

考虑构造一种操作方式使得能使 $1$ 的个数不断减少。

1. 若 $u$ 为 $1$ 则通过引理 1 把 $u$ 修改为 $0$。

2. 若 $u$ 的儿子中有奇数个 $1$ 且 $1$ 的个数 $\ge 3$，则可以通过一次合并操作减少 $1$ 的数量，操作后若 $1$ 的个数不为 $1$ 则显然还能继续操作。

3. 若 $u$ 的儿子中有偶数个 $1$ 则考虑根据引理 1 改变其中一个儿子的状态。

4. 若 $u$ 的儿子中只有一个 $1$，考虑 $u$ 的其他儿子。
   
   1. 若 $u$ 的其他儿子中有至少两个可以操作的子树，则可以根据引理 1 改变两个儿子的状态。
   
   2. 若 $u$ 的其他儿子中有一个不全为 $0$ 且不可以操作的子树，则可以把为 $1$ 的儿子和 $u$ 交换，此时这个子树符合引理 2。
   
   3. 否则 $u$ 的其他儿子中只有一个可以操作的子树，且其他子树全部为 $0$，由于 $u$ 的度数 $\ge 3$，所以可以把为 $1$ 的儿子交换到一个全 $0$ 的子树中去，此时如果满足前两种情况则按照前两种情况做，否则由于 $u$ 至少有两个大小 $\ge 2$ 的子树，所以一定可以把为 $1$ 的儿子换到一个大小 $\ge 2$ 的全 $0$ 子树中，之后操作那个可以操作的子树，使得 $u$ 获得一个新的为 $1$ 的儿子，由于之前为 $1$ 的儿子在大小 $\ge 2$ 的子树中，所以新儿子可以通过交换操作换到另一个全 $0$ 子树中，若此时还不符合前两种情况，则此时一定只有这两个 $1$，与条件矛盾。

这样我们就证完了这个性质。

于是对于一个符合这个性质的树，记 $f_{u,0/1,0/1,0/1,0/1}$ 为以 $u$ 为根的子树中，$u$ 为 $0/1$，$u$ 的儿子的异或和为 $0/1$，$1$ 连通块个数的奇偶性和是否存在一个点可以操作。

接下来只要考虑不符合性质的树怎么计数，不难发现不符合性质的树的形态一定是一条链两边接了若干条边（链+两个菊花）。

记两边的菊花各有 $l$ 和 $r$ 条边，则链上点的个数即为 $n-l-r$，记为 $len$。

1. 若链的两个端点均为 $1$，则链上所有点一定为 $1$，菊花上的点任意，方案数为 $2^{l+r}$。

2. 若链的两个端点中恰一个为 $1$，则链上一定是一段连续的 $1$ 和一段连续的 $0$，菊花上的点要保证为 $0$ 的端点一定不能被操作，所以方案数为 $2(len-1)2^{l+r-1}=(len-1)2^{l+r}$。

3. 若链的两个端点均为 $0$。
   
   1. 若链上全为 $0$，则菊花上的点要保证两个端点恰有一个点能被操作，方案数为 $2^{l+r-1}$。
   
   2. 若链上点不全为 $0$，则一定是中间连续的一段为 $1$，菊花上的点要保证两个端点都不能被操作，方案数为 $\binom{len-1}22^{l+r-2}$。

总复杂度 $\mathcal O(n)$，dp 有一个 $2^8$ 的常数。

code:
```cpp
#include<bits/stdc++.h>
#define int long long
#define MAXN 200010
#define p 998244353
using namespace std;
const int N=200000;
int n,in[MAXN],pw[MAXN];
struct Node{int to,nxt;}Edge[MAXN<<1];
int Head[MAXN],cnt_Edge;
void Add_Edge(int u,int v){
	Edge[++cnt_Edge]=(Node){v,Head[u]};
	Head[u]=cnt_Edge;
}
int f[MAXN][16],tmp[16],sz[MAXN],fl;
void dp(int u,int fa){
	sz[u]=1;int cnt=0;f[u][0]=f[u][10]=1;
	for(int i=Head[u];i;i=Edge[i].nxt){
		int v=Edge[i].to;if(v==fa)continue;
		dp(v,u);sz[u]+=sz[v];cnt+=(sz[v]>1);
		memcpy(tmp,f[u],sizeof(tmp));
		memset(f[u],0,sizeof(f[u]));
		for(int s=0;s<16;s++)
			for(int t=0;t<16;t++){
				int nxt=(s&8)|((s&4)^((t&8)>>1))|((s&2)^(t&2)^(((s&8)&(t&8))>>2))|((s&1)|(t&1)|(((s&8)>>3)^((t&4)>>2)));
				f[u][nxt]=(f[u][nxt]+tmp[s]*f[v][t])%p;
			}
	}
	cnt+=(n-sz[u]>1);
	fl|=(cnt>1&&in[u]>2);
}
signed main(){
	pw[0]=1;for(int i=1;i<=N;i++)pw[i]=pw[i-1]*2%p;
	scanf("%lld",&n);
	for(int i=1;i<n;i++){
		int u,v;scanf("%lld%lld",&u,&v);
		Add_Edge(u,v);Add_Edge(v,u);
		in[u]++;in[v]++;
	}
	dp(1,0);
	if(fl){
		int ans=0;
		for(int s=0;s<16;s++){
			if(!(s&2)||!((s&1)|((s&4)>>2)))continue;
			ans=(ans+f[1][s])%p;
		}printf("%lld",ans);
	}else{
		int l=1,r=1;
		for(int i=1;i<=n;i++)
			if(in[i]>2)r=l,l=in[i]-1;
		int len=n-l-r;
		printf("%lld",(pw[l+r]*len+pw[l+r-1]+(len-1)*(len-2)/2%p*pw[l+r-2])%p);
	}
	return 0;
}
```