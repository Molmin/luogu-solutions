## 题意
给定一棵 $N$ 个点的树，每个点上初始都是 $1$，每次可以选择一个点使得这个点的值异或上周围所有点的值。

问最多可以得到多少种不同状态。对 $998244353$ 取模。

$3\le N\le2\times10^5$。

## 题解
首先过程可逆没有任何问题。所以所有合法状态互相可达。

然后我们强制只能选择周围有奇数个 $1$ 的点翻转。

发现如果周围有 $s$ 个 $1$，那么翻转后连通块数量的变化是 $\pm(s-1)$，所以奇偶性不变。

所以我们得出两个必要条件：

- 连通块数量为奇数
- 存在一个点周围有奇数个点

接下来我们证明，在**存在一个点 $\deg\ge 3$ 且删去后存在 $\ge 2$ 个 $\ge 2$ 的连通块**的情况下，也是充分的。如果不想看dirty work可以直接跳到QED。

> **引理 $1.$** 若 $a_i=1$ 的导出子图非空且只有一个连通块，那么 $\{a_i\}$ 合法

这个每次扩展一个点就行了吧。

> **引理 $2.$** 将 $a_i=1$ 的所有连通块每个只保留一个点不影响合法性

这个也比较显然，就一个点可以用引理1的方法扩展到一个连通块。

因此我们现在只考虑 **不存在 $(x,y)\in E$，使得 $a_x=a_y=1$** 的图。我们有两种操作：

- **移动操作**：$a_x=1$ 且 $(x,y)\in E$，$y$ 周围没有其他 $1$，那么可以交换 $a_x,a_y$
- **合并操作**：$a_x=0$ 且周围有 $\ge 3$ 且为奇数个 $1$，那么可以周围全赋值为 $0$，$x$ 赋值为 $1$。

两者可以合并为 $x$ 周围有奇数个 $1$，可以把周围赋值为 $0$ 且 $x$ 赋值为 $1$。统称为**操作**。

我们希望当有 $>1$ 个 $1$ 时一定可以执行合并操作。继续证明。

> **引理 $3.$** 若一个点可以操作，若干次后可以改变 $a_{rt}$ 的状态

证明引理

1. $a_{rt}=0$
   1. 周围有奇数个 $1$，直接操作
   2. 否则递归进入可以操作的子树
2. $a_{rt}=1$，周围都是 $0$
   1. 其中一个儿子的儿子有偶数个 $1$，执行操作
   2. 否则可以操作的点在某个子树内部，归纳修改，再执行操作

> **引理 $4.$** 若一棵树不能操作，且 $a_{rt}=0$，存在至少一个 $1$，那么给 $rt$ 连一个 $1$ 的点就可以执行合并操作

证明引理

1. $rt$ 所有儿子均为 $0$，移动 $1$ 到 $rt$，归纳
2. 否则 $rt$ 有偶数个儿子为 $1$，$rt$ 现在可以合并了

接下来就可以证明最初的结论了。选择一个满足 $\deg\ge 3$ 且删去后有至少两个 $\ge 2$ 的连通块的 $rt$。如果 $a_{rt}=1$ 就用引理 $3$ 翻转 $rt$。现在 $a_{rt}=0$，有 $>1$ 个奇数个 $1$，至少有一个点可以操作，我们希望进行合并操作。先对 $rt$ 为 $1$ 的儿子分类讨论：

1. 为偶数。任选一个可以操作的子树，翻转一个儿子的值，变为奇数

2. 为奇数且 $\ge 3$，对 $rt$ 执行合并操作

3. 只有一个儿子为 $1$，继续对不为 $1$ 的儿子分类讨论：

   1. 存在两个可以操作，翻转之后合并

   2. 有一棵子树不全为 $0$ 且无法操作，把 $1$ 移动到 $rt$ 然后用引理 $4$ 合并

   3. 否则至多一个儿子可操作，其余全是 $0$。因为有 $\ge 2$ 个 $\ge 2$ 的子树，我们可以把 $1$ 移到一个 $\ge 2$ 的全 $0$ 子树。

      若满足前两点，就可以合并了。否则其它子树最多有一个可以操作并且其他全为 $0$。

      假如没有可以操作的子树，那么就只有一个 $1$ ，已经结束了。

      否则有可操作子树，通过引理 $3$ 使得子树的根为 $1$，原来的 $1$ 下移一步，新的 $1$ 移到一棵全为 $0$ 的子树，原来的 $1$ 所在的子树肯定是可以操作的，再分类讨论：

      1. 原来的 $1$ 和新的 $1$ 出来的子树都能操作，那么就是上面的情况 $1$。
      2. 新的 $1$ 出来的子树现在不全为 $0$ 且无法操作，那么就是上面的情况 $2$。
      3. 否则新的 $1$ 出来的子树也全部为 $0$，现在只有两个 $1$，和有奇数个 $1$ 矛盾。

以上，我们证明了一定可以不断合并使得变成一个 $1$，从而证明了结论的正确性。

QED.

那么对于符合这种条件的树就可以计算了。设 $f_{u,0/1,0/1,0/1,0/1}$ 表示 $u$ 的子树，$a_u$，$\oplus_{v\in son_u}a_v$，当前连通块个数的奇偶性，除了 $u$ 是否存在可以操作的点。合并手玩一下即可。复杂度 $\mathcal O(N)$。

如果不满足上面的情况，树的结构是简单的，是一条链，两个端点连出若干片叶子。不妨设链的点数为 $l$，分别连出 $x,y$ 片叶子（$x,y\ge1$）。

对于这种情况，如果 $\{a_i\}$ 可以变成全 $1$，我们可以断言存在一种方案使得不会把端点的值从 $1$ 变成 $0$。我们强制不能够两次翻转同一个点的值，这样是没有意义的。然后假如出现了端点从 $1$ 变成 $0$，找到最后一次，假设是左端点，那么最后要是 $1$，所以肯定要 $1\to0\to1$，然后直接翻转回来已经被我们 ban 掉了，所以右边的点肯定要先翻转，然后翻转回来，然后右边第二个点也是同理，最后我们得出右端点需要翻转再翻转回来，这和这是最后一次 $1\to 0$ 矛盾，所以不会存在这样的情况。

然后统计可行的情况就简单了：

1. 两个端点为 $1$，那么外面的叶子可以随意选，然后链上需要全部是 $1$，不然链上有若干个连续段，操作无法减少连续段的个数就寄了。方案数 $2^{x+y}$。
2. 两个端点只有 $1$ 个 $1$，假设是左端点，那么左端点连出的叶子是随意选，然后链上的 $1$ 不断操作要能够使得右端点翻转，所以右端点连出的叶子有偶数个 $1$，然后左端点到右端点的 $1$ 是一段连续的。所以这部分的方案数为 $2\times(l-1)\times 2^{x+y-1}$。
3. 否则两个端点都是 $0$，那么一定是中间有一段连续的 $1$，两个端点接偶数个 $1$。所以方案数为 $\binom {l-1}2\times2^{x+y-2}$。

复杂度 $\mathcal O(N)$。

## 代码
```cpp
const int N=2e5+10;
int n;vector<int>e[N];bool flag;
mint f[N][2][2][2][2],g[2][2][2][2];int sz[N];
//[u][u的状态][u儿子为奇数的个数][连通块的奇偶性][不包括u是否存在可行点]
void dfs(int u,int fa){
	sz[u]=1;f[u][0][0][0][0]=f[u][1][0][1][0]=1;int tot=0;
	for(auto v:e[u])if(v!=fa){
		dfs(v,u);memset(g,0,sizeof g);
		for(int a=0;a<2;a++)for(int b=0;b<2;b++)for(int c=0;c<2;c++)for(int d=0;d<2;d++)
			for(int aa=0;aa<2;aa++)for(int bb=0;bb<2;bb++)for(int cc=0;cc<2;cc++)for(int dd=0;dd<2;dd++)
				g[a][b^aa][c^cc^(a&aa)][d|dd|(a^bb)]+=f[u][a][b][c][d]*f[v][aa][bb][cc][dd];
		memcpy(f[u],g,sizeof g);
		sz[u]+=sz[v];tot+=sz[v]>=2;
	}
	tot+=n-sz[u]>=2;
	if(e[u].size()>=3u&&tot>=2)flag=1;
}
signed main(){
	read(n);
	for(int i=1,u,v;i<n;i++)read(u,v),e[u].pb(v),e[v].pb(u);
	dfs(1,0);
	if(flag){
		mint ans=0;
		for(int a=0;a<2;a++)for(int b=0;b<2;b++)for(int d=0;d<2;d++)if(b|d)
			ans+=f[1][a][b][1][d];
		return writeln(ans.x),0;
	}
	int x=1,y=1;
	for(int i=1;i<=n;i++)if(e[i].size()>=3u){
		if(x==1)x=e[i].size()-1;
		else y=e[i].size()-1;
	}
	int l=n-x-y;mint kk=mint(2)^(x+y-3+mod-1);
	writeln((kk*8+(l-1)*kk*8+kk*4+kk*(l-1)*(l-2)).x);
}
```