## Content
- 有一家有若干个保险柜的银行，从左往右分别标号为 $1,2,3,...$。
- 有 $n$ 张钞票，其中第 $i$ 号钞票在第 $x_i$ 号保险柜里。
- 一个小偷在 $a$ 号保险柜，他想偷走保险柜里面尽可能多的钞票。
- 有两个警察，一个警察在 $b(b<a)$ 号保险柜处，一个警察在 $c(c>a)$ 处，他们都不会动。
- 小偷可以偷走箱子里面的钞票，也可以移动到相邻的保险柜，但是他不能走到**任何一个**有警察看守的保险柜。
- 求这个小偷最多可以偷走多少张钞票。
- $1\leqslant b<a<c\leqslant 10^9,1\leqslant n\leqslant 10^5,1\leqslant x_i\leqslant 10^9$。

## Solution
如果我们略微想一下就明白这个问题的实质了：求所有在 $(b,c)$ 区间内的所有保险柜中的钞票总数。

为什么呢？

因为根据输入限制，**小偷一定会在两个警察之间**，又因为**小偷不能走到有警察的保险柜**，且**小偷一次只能走一步**，所以到 $b$ 或者到 $c$ 都不行，所以只能去偷所有在 $(b,c)$ 区间内的保险柜里面的钞票。

那么如何处理这些数据呢？用桶来存吗？

$b<a<c\leqslant10^9$ 的数据让我们一震：不能用桶来存了，会 $\texttt{MLE}$。

那该怎么存？

你想想，如果我们去偷的话只会偷 $(b,c)$ 区间里的钞票，那不就是相当于判断对于一个钞票所在的保险柜 $x_i$，是否有 $b<x_i<c$ 就好了嘛？其他在此之外的所有钞票一律忽略，这样的空间就大大减少了很多了。

因此，最后的答案就是对于 $i\in[1,n]$，满足 $b<x_i<c$ 的 $i$ 的个数。这个就非常好判断了。

## Code
```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;

int a, b, c, n, x[100007], ans;

int main() {
	scanf("%d%d%d%d", &a, &b, &c, &n);
	for(int i = 1; i <= n; ++i) {
		scanf("%d", &x[i]);
		if(x[i] > b && x[i] < c)	ans++;
	}
	printf("%d", ans);
	return 0;
}
```