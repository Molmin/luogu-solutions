### 题意简述：
有一个数列，可以对数列的值 $+1$ 或 $-1$，修改若干次，使得数列为等差数列，最小化修改次数,无解输出 $-1$。

### 思路讲解：
这道题其实所需要的算法知识并不多，更多的是对等差数列的认识。

我们知道一个等差数列由首项 $a_1$ 和公差 $d$ 所决定，而只要确定了等差数列中的两项，公差 $d$ 就确定了。

因而我们可以思考枚举等差数列前两项的可能性，来检验整个数列能否成为一个等差数列。

具体地，设公差为 $d$，如果数列 $a$ 的某两项 $a_i$ 和 $a_{i-1}$ 满足如下其中一个条件时，不能通过修改数列使其构成一个等差数列。

$$
\left\{
      \begin{array}{lr}
      a_i-a_{i-1} > d+1\\
      a_i - a_{i-1}<d-1
      \end{array}
\right.
$$
这样只需枚举等差数列前两项的可能性，再进行检验即可。
                        
由于前两项的取值仅有 $9$ 种，所以时间复杂度为 $O(9n)$，可以通过本题。
                        
### 核心代码：
```cpp
inline int judge(int d) {//检验该公差是否可行
	int res = 0;
	for(ri i = 3;i <= n;++i){
		if(b[i]-b[i-1] > d + 1 || b[i]-b[i-1] < d - 1) return -1;
 		else if(b[i]-b[i-1] == d + 1) ++res,b[i]--;
 		else if(b[i] - b[i-1] == d - 1) ++res,++b[i];
	} 
	return res;
}
```
      
