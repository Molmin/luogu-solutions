纪念第一次场切 Div 2 D。

这题思路可能讲得比较绕，所以我尽量以通俗的方式讲。

题目的意思就是给定一个序列 $a$，让你任意排列 $b$，使得 $(a_1 \oplus b_1) \text{ and }(a_2 \oplus b_2) \text{ and }... \text{ and }(a_n \oplus b_n)$ 最大。

这题和 [ARC 146 B](https://atcoder.jp/contests/arc146/tasks/arc146_b) 很像，做法是几乎一样的。

很明显的按位贪心。首先有几个引理：

- 异或：每一位相同为 $0$ 不同为 $1$。

- 按位与：若干个数按位与后，某一位结果为 $1$ 当且仅当参与运算的每个数在这一位都为 $1$。

- $2^0+2^1+2^2+...+2^{n-1}<2^n$，根据上面按位与的引理我们可以知道，当我们选择**从高位往低位贪心**时，在每一位可以选择**对于当前位而言的最优策略**。因为后面的位不管怎么选，也比不过在这一位选最优策略。这也恰好证明这题贪心是可行的。

---

首先，我们创造两个集合 $A_1$ 和 $B_1$，分别存储初始时 $a$ 中和 $b$ 中的数。

**记 $A_i$ 和 $B_i$ 为对应集合，也就是可以进行匹配的集合（即满足下标相等的集合）**

然后我们从高位往低位贪心。首先我们要找到第一个**可行位**，指的是在这一位上可以通过匹配让所有 $a_i \oplus b_i$ 按位与起来在这一位为 $1$。

根据异或的性质，两个数只有在这一位不同，它们异或起来才能在这一位为 $1$。

而集合 $A_1$ 中的数和 $B_1$ 中的数都可以分为**两种类型**：在这一位为 $1$ 和在这一位不为 $1$。于是：

- 设 $A_1$ 中有 $x_1$ 个数在这一位为 $1$，有 $y_1$ 个数在这一位为 $0$；

- 设 $B_1$ 中有 $x_2$ 个数在这一位为 $1$，有 $y_2$ 个数在这一位为 $0$。

因为我们不知道后面情况如何，只想让在这一位的结果最优。所以，我们不直接选定谁一定匹配谁，而是把在这一位可以匹配的数都放到两个对应集合中。这时这一位可以产生贡献当且仅当 $x_1=y_2,x_2=y_1$，因为要让 $a$ 中的 $1$ 和 $b$ 中的 $0$ 匹配，$a$ 中的 $0$ 和 $b$ 中的 $1$ 匹配。如果满足这个条件，我们就把原来的 $A_1$ 和 $B_1$ 集合**分裂为四个集合**：$A_2,B_2$ 和 $A_3,B_3$。其中：

- 分裂后的第一个对应集合中，$A_2$ 存储 $A_1$ 中在这一位为 $1$ 的数，$B_2$ 存储 $B_1$ 在这一位为 $0$ 的数；

- 分裂后的第二个对应集合中，$A_3$ 存储 $A_1$ 中在这一位为 $0$ 的数，$B_3$ 存储 $B_1$ 在这一位为 $1$ 的数。

同时，答案加上在这一位的贡献。

接下来的问题和上面的处理类似，**相当于上面所述的子问题**。我们不再是只分裂一个集合，而是当且仅当**当前有的所有集合都满足上述条件，再分别根据上述规则对现有的每个集合进行分裂等操作**。

下面是一开始写的形式化题解，如果感觉绕**可以跳过**，如果对于上述解释有疑问可以在评论区写出或者私信我，我会第一时间回复（~~因为这一题想起来很简单说起来挺麻烦~~

---

形式化题解：

考虑把数字划分到一些集合中，每个集合有两个关键字，分别存储 $a$ 中的一些数和 $b$ 中的一些数。设第 $i$ 个集合内原本在 $a$ 中的**某个**数为 $D_i^{(a)}$，原本在 $b$ 中的**某个**数为 $D_i^{(b)}$。考虑每个子问题，即在每一位的状态以及转移，我们从高位到低位枚举，枚举到了第 $i$ 位。对于现在有的所有集合，假设我们枚举到了第 $j$ 个集合。我们想要使得答案最优，也就是想要让这个集合某个 $D_j^{(a)}$ 和 $D_j^{(b)}$ 在第 $i$ 位不同，这样才能让它们异或起来第 $i$ 位为 $1$，对答案产生贡献。设这个集合大小为 $w$（即：这个集合有 $w$ 个 $D_j^{(a)}$，有 $w$ 个 $D_j^{(b)}$）这个集合内满足在这一位为 $1$ 的 $D_j^{(a)}$ 有 $x$ 个，满足在这一位为 $1$ 的 $D_j^{(b)}$ 有 $y$ 个。则我们称这个集合为**在第 $i$ 位合法的**当且仅当 $x+y=w$。**在第 $i$ 位合法的**，表示这个集合可以**分裂**为两个集合，其中第一个集合中原本在 $a$ 的数在这一位为 $1$，第一个集合原本在 $b$ 中的数在这一位为 $0$；第二个集合则恰恰相反。这样，我们就保证了分裂出来的两个集合中，其中任意一个集合中的任意一个原本在 $a$ 中的数，一定能在这个集合中找到一个原本在 $b$ 中的数，使得这两个数异或起来在这一位为 $1$。这么做是为了转移到下一位。如果在第 $i$ 为现有的集合中，所有集合都是**在第 $i$ 位合法的**，那么这一位就能对答案产生贡献。能对答案产生贡献，我们就要在这一位进行转移，转移的过程就是把现有的所有集合按照上述过程分裂。

可能很绕，举个例子：

假设现在有一个集合，这个集合分为 $a,b$ 两个部分，它们的 $i$ 位如下：

$D_j^{(a)}:[1,1,1,1,0,0,0]$

$D_j^{(b)}:[0,0,0,0,1,1,1]$

那么这个集合就是**在第 $i$ 位合法的**。它可以分裂成两个集合，其中每个集合的数的第 $i$ 位如下：

$\text{First }(a):[1,1,1,1]\text{ }(b):[0,0,0,0]$

$\text{Second }(a):[0,0,0]\text{ }(b):[1,1,1]$

相当于是一个分治。

最后就是初始状态：只有一个集合，并且所有数都在集合中。

---

这个做法是严格 $O(n \log a_i)$ 的，其中集合可以用 vector 实现。

注意几点：

- vector 的清空；

- 由于可以证明最终集合个数是 $\le n$ 的，而一些集合实质上并不会进行分裂，所以再进行分裂后如果分裂出的集合大小为 $0$ 要减去。（~~我才不会告诉你因为这个赛时吃了一发罚时~~

### Code：

```c++
#include <bits/stdc++.h>
using namespace std;
#define int long long
int t, n, s1, s2, siz, sizz, pd, ans, a[100010], b[100010];
vector <int> d[100010], p[100010], dd[100010], pp[100010];
signed main(){
	scanf ("%lld", &t);
	while (t --){
		for (int i=1; i<=siz; i++) d[i].clear(), p[i].clear();
		siz = 1; ans = 0;
		scanf ("%lld", &n);
		for (int i=1; i<=n; i++){
			scanf ("%lld", &a[i]);
			d[1].push_back(i);
		}
		for (int i=1; i<=n; i++){
			scanf ("%lld", &b[i]);
			p[1].push_back(i);
		}
		for (int i=30; i>=0; i--){
			pd = 1;
			for (int j=1; j<=siz; j++){
				s1 = s2 = 0;
				for (int k=0; k<d[j].size(); k++){
					int x = a[d[j][k]];
					if ((x >> i) & 1) s1 ++;
					int y = b[p[j][k]];
					if ((y >> i) & 1) s2 ++;
				}
				if (s1 + s2 != d[j].size()){
					pd = 0;
					break;
				}
			}
			if (pd){
				for (int j=1; j<=siz; j++){
					for (int k=0; k<d[j].size(); k++) dd[j].push_back(d[j][k]), pp[j].push_back(p[j][k]);
				}
				for (int j=1; j<=siz; j++) d[j].clear(), p[j].clear();
				sizz = 0;
				ans += (1 << i);
				for (int j=1; j<=siz; j++){
					sizz ++;
					for (int k=0; k<dd[j].size(); k++){
						int x = a[dd[j][k]];
						int y = b[pp[j][k]];
						if ((x >> i) & 1) d[sizz].push_back(dd[j][k]);
						if (!((y >> i) & 1)) p[sizz].push_back(pp[j][k]);
					}
					if (d[sizz].size() == 0) sizz --;
					sizz ++;
					for (int k=0; k<pp[j].size(); k++){
						int x = a[dd[j][k]];
						if (!((x >> i) & 1)) d[sizz].push_back(dd[j][k]);
						int y = b[pp[j][k]];
						if ((y >> i) & 1) p[sizz].push_back(pp[j][k]);
					}
					if (d[sizz].size() == 0) sizz --;
				}
				for (int j=1; j<=siz; j++){
					dd[j].clear(), pp[j].clear();
				}
				siz = sizz;
			}
		}
		printf ("%lld\n", ans);
	}
	return 0;
}
```