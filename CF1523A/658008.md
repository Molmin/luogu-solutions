#### [题目：](https://www.luogu.com.cn/problem/CF1523A)
- 题意：
1. 给你一个初始字符串，它会按照一定规律变化：当一个 $ 0 $ 旁边只有一个$1$时，那么这个$0$在**下一轮**变成 $ 1 $。求 ` m ` 轮之后的字符串。
- 思路
1. 直接模拟，开始先把要变化的 $ 0 $ 先设为 $ 2 $，在所有遍历完一次后再将 $ 2 $ 转为 $ 1 $。
- 问题
1. 我开始就直接将 $ 0 $ 先转为 $ 1 $，那么会错，比如 ` 1 0 0 0 0 0 `，仅仅在一轮之后就变成了 ` 1 1 1  1 1 1 `，非常的不合理，所以我们要先给将变化的 $ 0 $ 转换一个其他字符，然后再在事后转为 $ 1 $。
2. 如果你没读清题，你会把只有一个 $ 1 $ 写成有 $ 1 $ ，导致一个样例没过。
- 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int t,n,m;
string s;
int main()
{
		cin>>t;
		while(t--)
		{
			cin>>n>>m>>s;
			while(m--)
			{
				for(int i=0;i<n;i++) if((s[i+1]=='1'&&s[i-1]!='1')||(s[i+1]!='1'&&s[i-1]=='1')) s[i]='2';
				//将即将变化的0先转为2，避免后面的0被这个零变化
				for(int i=0;i<n;i++) if(s[i]=='2') s[i]='1';
				//转化回来
			}
			cout<<s<<"\n";
		}
		return 0;
}
```
- 题目名字来源：
1. 这个题目翻译过来就是：生命游戏。这个游戏是有的，和这个题有一点相似，可以体验一下这个模拟器：[Game of Life](https://playgameoflife.com/)