## [题目传送门](https://www.luogu.com.cn/problem/CF1523A)

## 一、思路
读了一遍题，没怎么读懂，但观察样例后可以发现，要把 ‘0’ 变成 ‘1’ ，只需要满足两种情况里的任意一种就可以了：

	1. '0'的左边是'1',右边不是'1'的情况。
    2. '0'的右边是'1',左边不是'1'的情况。
## 二、优化
但光这样还不行，代码实现后会超时，所以要稍微优化。我们可以看到 $n$ 的大小，也就是字符串的长度不超过 $1000$ ,而 $m$ ，也就是轮数的大小有 $10$ 的 $9$ 次方这么大，肯定用不了这么多轮，所以只需要判断一下还能否继续变成 ‘1’ ，如果不能就直接输出结果，可以节省很多时间，通过此题就很轻松啦。
## 三、代码

具体怎么用代码实现呢？让我们一起来看一看吧！
```
#include<bits/stdc++.h>
using namespace std;
string s;
int main()
{
	int t;//一共测试的组数
	int n,m;//字符串的长度和变'1'的轮数
	scanf("%d",&t);
	bool js;//优化，下面细讲
	for(int i=0;i<t;i++)
	{
		cin>>n>>m>>s;
		for(int j=0;j<m;j++)//循环轮数
		{
			js=true;//赋初值，设为最初应该结束
			for(int p=0;p<s.size();p++)
			{
				if(s[p]=='0')
				{
					if(s[p-1]!='1'&&s[p+1]=='1')//两种情况，上面讲过
					{
						js=false;//运行了，说明还可以变'1'，所以还不能结束（下同）
						s[p]='2';//先把应该变成'1'的'0'变为'2'，防止它们在同一轮继续扩散
					}
					else if(s[p-1]=='1'&&s[p+1]!='1')
					{
						js=false;
						s[p]='2';
					}
				}
			}
			if(js==true)//如果不能继续变'1'了
			{
				break;//直接跳出轮数的循环
			}
			for(int p=0;p<s.size();p++)
			{
				if(s[p]=='2')//把应该变为'1'的'0'变为'1'
				{
					s[p]='1';
				}
			}
		}
		cout<<s<<endl;//输出变完后的答案
	}
	return 0;
}
```
~~码风很丑，不喜勿喷~~
## 四、总结
我再细讲一下为什么要把 ‘1’ 先变成 ‘2’ ，由于某一轮变 ‘1’ 过程还没有结束，所以为了防止将 ‘0’ 变为 ‘1’ 以后影响后面的变化，可以先把 ‘0’ 变为其他的东西储存起来，最后再统一变。

最后如果有什么意见或建议，欢迎在下方评论出来，我会努力改进的。

感谢阅读QWQ！