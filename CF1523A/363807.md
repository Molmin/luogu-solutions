# CF1523A的题解

为什么这道题的题解只有一篇，那我来充个数。

### 题目简意：

就是给定一个长度为 $n$ 的 $01$ 串，要求进行 $m$ 次操作，将 $01$ 串中的 $0$ 在旁边只有一个 $1$ 的情况下变为 $1$ ，输出最后的 $01$ 串。

### 分析：

第一次看，这不就是一道模拟题吗？我于是就写了一篇时间复杂度为 $O(tnm)$ 的代码，具体思路是，每次操作跑一遍字符串，把能操作的 1 都给操作扩展一遍，然后自信往上一交，果然 TLE 了，为什么呢？我仔细一看数据：$1 \le t \le 10^{3}$，$2 \le n \le 10^{3}$，$1 \le m \le 10^{9}$，这数据，$O(tnm)$ 不 TLE 才怪，那就换一种思路再去做。

那么问题来了，怎么优化呢？没有关系，我们想吧，$m$ 的数据范围很大，我们可不可以把 $m$ 给优化掉呢？首先一个 $1$ 最多向一个方向拓展 $m$ 次，所以我们可以利用一个类似于前缀和的思路，把每一个 $0$ 距前一个 $1$ 的位置用一个数组 $b$ 记录下来，把距后面一个 $1$ 的位置用一个数组 $p$ 记录下来，然后再判断每一个位置的字符，分类讨论如下：

1.当字符串本位置本来就是 $1$ 时，它就是 $1$。

2.当字符串本位置是 $0$ ，但距两边 $1$ 的距离相等时，这个 $0$ 无论如何都变不成 $1$。

3.当字符串本位置是 $0$ ，且距左右两边 $1$ 的距离都小于我们的操作次数时,就输出 $1$ ，因为变 $m$ 轮，所以当小于操作次数时，就可以变为 $1$。

4.其余情况都为 $0$。

提交，可恶，还没通过。那么问题又来了，哪里出问题呢？还是没有关系，仔细一看，大概是每一个的首尾没有处理好，那我们可以把字符串的头加上一个，这样下标就没有问题了，但是数组 $b$ 和数组 $p$ 怎么处理呢？我们把 $b_{0}=-\infty$，$p_{n+1}=+\infty$，那么就有人要问了，你为啥不把 $b_{0}=+\infty$，$p_{n+1}=-\infty$ 呢？ 首先如果将 $b_{0}=+\infty$，那么求位置 $1$ 距前面的 $1$ 的距离时，也就是 $b_{1}-b_{0}$，就是一个正整数减去一个正无穷，所以是一个负无穷，也就会出错，同样 $p_{n}-p_{n+1}$ 也是同样的道理。

### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e3+5;
int t,n,m;
int b[N],p[N];
int inf=0x3f3f3f3f;
int main(){
	scanf("%d",&t);
	while(t--){
		scanf("%d%d",&n,&m);
		string a;
		cin>>a;
		b[0]=-inf;
		p[n+1]=inf;
		string x="0";
		x+=a;
		for(register int i=1;i<=n;++i){
			if(x[i]=='1') b[i]=i;
			else b[i]=b[i-1];
		}
		for(register int i=n;i>=1;--i){
			if(x[i]=='1') p[i]=i;
			else p[i]=p[i+1];
		}
		for(register int i=1;i<=n;++i){
			if(x[i]=='1') cout<<x[i];
			else{
				int l=i-b[i],r=p[i]-i;
				if(l==r) printf("%d",0);
				else if(l<=m or r<=m) printf("%d",1);
				else printf("%d",0);
			}
		}
		printf("\n");
	}
	return 0;
}
```
#### 蒟蒻第一篇题解，求大佬轻喷。