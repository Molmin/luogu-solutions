## 题意

给定一个 $n$ 个点，$m$ 条边的无向图，每次删除一条仍未被删除的边，共删除 $m$ 次。  

求每一次删除后有多少对 $(x,y)$ 不能联通。  

## 分析

容易想到用并查集来维护各个点之间的连通性，可惜并查集并不能方便的进行“删除”操作，因此可以转化一下，从最后一次删除开始向上倒推，不断建立被删除的边。  

容易想到在所有节点都被摧毁时的答案即 $\frac{n(n-1)}{2}$。  

之后每一次建立新的边，都在上一个答案的基础上减去两者连接数目的乘积。  

例如当前的 $u$ 连接了节点 $2$ 和 $4$，$v$ 连接了 $1$ 和 $3$。  

![](https://cdn.luogu.com.cn/upload/image_hosting/hi0cay4n.png)  

就会有如图四种排列方式。  

初始的，每个节点的连接数目就是 $1$，即自己。  

## 代码

基础的并查集操作，按倒序处理即可。  

主要分析下 ``merge`` 函数中的操作（~~因为自己被坑了~~）。  

```cpp
void merge(int x,int y)
{
	if(x!=y)
	{
		link[x]+=link[y];
		f[find(y)]=find(x);
	}
}
```  
其中第六行的意思是将 ``y`` 所在的集合并到 ``x`` 的集合里，所以才有上一行的相加顺序。  

完整的代码就不放了，需者可自取。  
[$Code$](https://www.luogu.com.cn/paste/arhpuggl)
