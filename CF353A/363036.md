## 题意
给定 $2n$ 个数 $x_i,y_i$，每次操作可以任意调换一个 $x_i,y_i$。问至少操作几次，使得 $\sum\limits_{i=1}^{n}x_i$ 和 $\sum\limits_{i=1}^{n}y_i$ 都为偶数。

## 做法
本题为**数学题**。

首先根据小学一年级数学知识易得以下三个式子：
1. 奇数 $+$ 奇数 $=$ 偶数。
1. 偶数 $+$ 偶数 $=$ 偶数。
1. 奇数 $+$ 偶数 $=$ 奇数。

然后可以得出结论：本题答案只有 $0,1,-1$ 三种。

为什么不可能大于 $1$ 呢？这是其他题解解释不清楚的。 
### 证明：
----------------
假设操作 $x$ 次（$x > 1$）。

首先，交换偶数是没有意义的，因为奇偶性不变（参见 $1,3$ 式）。故只讨论交换奇数。
- 如果 $x$ 是偶数，那么相当于没交换，因为交换了偶数个奇数，上下和的奇偶性还是不变。
- 如果 $x$ 是奇数，那么相当于交换 $1$ 次，因为交换了奇数个奇数，上下和的奇偶性发生改变，就相当于只交换 $1$ 个。

上述情况加上一个不可能，就只有三种情况了。命题得证。

------------
知道了这些，那如何判定答案呢？

- 因为上下和皆为偶数，根据 $2$ 式可得，它们的和必为偶数。换言之，如果和为奇数，天皇老子来了都没法符合要求，输出 $-1$。

判断完上面后，现在和必定为偶数，that is，上下和奇偶性相同。

1. 如果上下皆为偶数，大功告成，输出 $0$。
2. 如果上下皆为奇数，分两种情况讨论：
- 如果找得到一张奇偶性不同的牌，那就交换这张牌，输出 $1$；
- **如果找不到，输出 $-1$。**

我一开始就是忘记讨论都是奇数，直接输出了 $1$，第 $8$ 个点就红了。

不过，~~为了解法不重复~~我一开始思路不是这样的，而是选择了统计奇数个数的方法。所以，上面结论化简为：
- 如果上下奇数个数和为奇数，输出 $-1$。
- 如果上下奇数个数都为偶数，输出 $0$。
- 如果上下奇数个数都为奇数且找得到奇偶性不同的牌，输出 $1$。
- 如果上下奇数个数都为奇数且找不到奇偶性不同的牌，输出 $-1$。

## 代码
以下是参考代码。珍爱生命，远离抄袭。

Code：
```cpp
#include<bits/stdc++.h>
using namespace std;

const int N = 100 + 10;
int n, up[2], down[2], x[N], y[N];
bool flag;
//两个奇数的和必为偶数 

int main(){
	scanf("%d", &n);
	for(int i=1;i<=n;i++){
		scanf("%d%d", &x[i], &y[i]);
		up[x[i] % 2]++, down[y[i] % 2]++;
		//方便统计个数，不用打 if 
		if((x[i] + y[i]) % 2 == 1)	flag = true;
		//提前判断有没有奇偶性不同的牌，别的题解都是用的abs，
		//我用的是和的奇偶性判断的。可以根据上述三式得出 
	}
	//下面判断就是前面的结论了，不解释 
	if((up[1] + down[1]) % 2 == 1){
		puts("-1");
		return 0;
	}
	//这里奇偶性必定相同，判断一方即可 
	if(up[1] % 2 == 0)	puts("0");
	else if(up[1] % 2 == 1 && flag)	puts("1");
	else	puts("-1");
	return 0;
}
```