[**CF353A Domino**](https://www.luogu.com.cn/problem/CF353A)

## 分析
**题目大意：** 桌上有 $n$ 块骨牌，每块上下都有两个数字，问最少翻动几块可以使上下两排骨牌和分别为偶数。

我们可以发现，题目总共分为了以下三种情况：

- 显然如果初始情况符合上下两排骨牌和 **分别为偶数** 就输出```0```即可。


- 如果骨牌上所有数字 **总和为奇数** ，那么翻动任意一块就有“ **上奇下偶**  或  **上偶下奇** ”两种情况，改变不了整体奇偶性，无论如何也无法完成目标，输出```-1```。


- 如果输入不符合以上两种情况（例如样例#3），**上下两排和分别是奇数**的话，我们需要查找翻转后可以使上下两排同时变为偶数（**上奇下奇**到**上偶下偶**）的骨牌。显然**上下奇偶不同**的骨牌符合条件，只要翻动**一次一张**就可以使骨牌队列符合条件。如果有即输出```1```（可以完成且只用翻动一次），否则输出```-1```。

有了以上三种情况的思路，就可以很简单地实现本题。

## 解

解释在代码里
```cpp
#include<bits/stdc++.h>
using namespace std;
long long sum1,sum2,n,i,x,y;
bool flag;
bool o(int x)//判断奇偶
{
    if(x%2==0)return 1;
    else return 0;
}
int main()
{
    cin>>n;
    for(i=1;i<=n;i++)
    {
        cin>>x>>y;
        sum1+=x;
        sum2+=y;//累加
        if(!o(x+y))flag=1;//上下两数奇偶不同
    }
    if(o(sum1)&&o(sum2))cout<<0;//和均为偶数
    else if(o(sum1+sum2)&&flag)cout<<1;//两排总和为偶数且有奇偶不同的骨牌
    else cout<<-1;//否则无解
    return 0;
}
```


**拒绝抄袭题解，人人有责**