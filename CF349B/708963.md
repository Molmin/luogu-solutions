~~突然觉得自己要估值要得好过分...~~

[CF349B](https://www.luogu.com.cn/problem/CF349B)。

首先，做题的第一步是什么？读题！

 简要题面：

$1 \sim 9$ 所花费代价为 $a_i$，要求在有代价限制的条件下组成最大的数，每一个数可以使用次数不限。


然后判断算法。

因为这一道题没法直接从题目中看出使用的算法，所以要从题目描述和其他知识中仔细思考。仔细思考数的大小后得出这样的结论：

一个数的大小有关系的条件：
- 位数越多，数越大。
- 第一位越大，数越大。
- 第二位越大，数越大。
- ......

优先程度从大到小。

到这里，相信你们已经知道算法了。**贪心**+**数论**，贪心的点在于怎么选择越大的数，数论的点在于前面的条件。

其次，再思考算法的细节。

已经在上面写出了有关数的大小的条件。

那么就先使这个数的位数更多，要使这个数的位数最多的方法是什么？就是组成**全都是最小代价的数字**的数。

接下来因为可能限制还剩一些，所以我们要充分利用这些剩余的空间。我们从最高位开始，用代价允许，数更大的数来替换掉这个位数，让所有的空间充分利用。

题目简单，也不知道怎么更详细的讲，到这里就讲完了，下面是我的代码：
```
#include<bits/stdc++.h>
using namespace std;
long long v,A[1000005],n,minx=1e5,Min;
struct wbx{
	long long x,y;
}a[15];
bool cmp2(wbx x,wbx y){return x.y>y.y;}
int main()
{
	cin>>v;
	for(int i=1;i<=9;i++) 
    {
    	cin>>a[i].x,a[i].y=i;//这里我用结构体来记录。
        if(minx>a[i].x) minx=min(a[i].x,minx),Min=i;//记录最小值。
    }
	while(v>=minx) v-=minx,A[++n]=Min;//用代价最小的数组成暂时的答案。
	sort(a+1,a+10,cmp2);//为了方便用了排序，也可以不用。
	for(int i=1;i<=n;i++)
		for(int j=1;j<=9;j++)
			if(a[j].x-minx<=v){v-=(a[j].x-minx),A[i]=a[j].y;break;} //从最高位开始替换，利用空位。
	if(n==0) cout<<-1;//如果一位也没有，那么说明不可以组成任何一个数，输出-1。
	else 
    for(int i=1;i<=n;i++) cout<<A[i];//输出答案。
	return 0;
}
```