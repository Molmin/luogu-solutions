把这$n$个数字分组，每一组中所有元素是其组内最小的数的幂。

把组内按照次幂的关系连线，一个组会形成一个DAG，$x^k$会连向$x^{2k},x^{3k}....$，每选一个点，就会把这个点指向的所有点全部删掉，我们现在先来算一下只考虑一组的情况下随机选点，删除的期望。因为只考虑一组，把DAG简化一下，变成$k$会连向$2k,3k...$。

设$f(x)$为一个有$x$个元素的组，元素是$\{a^0,a^1,a^3...a^x\}$，删除次数的期望。

我们考虑递推，$f(x)$的DAG图是由$f(x-1)$的图连上$x$形成的。

连向$x$的是$x$的因子，所以如果我先选择了删除这些因子，$x$就会直接被一起删掉，对删除次数没有影响，但是如果我在选择这些因子前先选择了$x$，就会让删除次数增多一次。

那么我们设$k$为$x$的因子数量（因子包括$x$在内）。在这些点中先选到$x$的概率是$\frac{1}{k}$，其它情况下就会选到其它点在前面，导致$x$被删掉。

那么式子就列出来了：

$$f(n)=\frac{1}{k}(f(n-1)+1)+\frac{k-1}{k}f(n-1)=f(n-1)+\frac{1}{k}$$

因为一个组内最多只会有$30$个人（最大的组是$2,2^1...2^{30}$）。所以我们先预处理出$f(1)$到$f(30)$。

然后枚举有哪些组，因为期望独立可加，把每个组的$f()$相加就可以了，通过枚举组内最小元素来枚举组，只枚举到$\sqrt n$，大于这个的，组内最多只会存在一个元素，并且$f(1)=1$，加上后面的一个元素的组的$f()$就好了。

代码：

```cpp
#include <bits/stdc++.h>
using namespace std;

double f[40];

void pre()
{
    f[1]=1;
    for(int i=2; i<=32; i++){
        int v=0;
        for(int j=1;j<=i;j++)
            if(i%j==0)v++;
        f[i]=f[i-1]+1/(double)v;
    }
}

bool vis[50005];

int main()
{
    int t;
    scanf("%d",&t);
    pre();
    while(t--)
    {
        memset(vis,0,sizeof(vis));
        int n;
        scanf("%d",&n);
        if(n==0){
            printf("0.00000000\n");
            continue;
        }
        int sum=0;
        double ans=0;
        ans=1;
        for(register int i=2; i*i<=n; i++)
        {
            long long x=i;
            if(vis[x])
                continue;
            int v=0;
            while(x<=n)
            {
                if(x*x<=n)
                    vis[x]=1;
                x*=i;
                v++;
                sum++;
            }
            ans+=f[v];
        }
        ans+=(n-sum-1);
        printf("%.8f\n",ans);
    }
    return 0;
}

```

刚刚发现题解有点错误，就改了一下，麻烦审核了。