**题目大意**：给定两个二进制字符串 $a$ 和 $b$ ，通过不超过 $2n$ 次操作，将字符串 $a$ 变成字符串 $b$。每一次操作将字符串 $a$ 的前 $p$ 个字符中 $0$ 变成 $1$，$1$ 变成 $0$，并将前 $p$ 个字符反转。

做这一道题之前，建议先做一下这一道题的简单版本 [CF1381A1 Prefix Flip (Easy Version)](https://www.luogu.com.cn/problem/CF1381A1) 。

对于 CF1381A1 ，可以考虑每次使 $a$ 与 $b$ 的最后一个字符相同，这样最多操作 $2n$ 次，在操作上符合要求。

但是这样时间复杂度是 $O\left(n^2\right)$，不能通过本题，需要优化。

可以发现，如果修改的时候同时考虑两个字符串的话，是很麻烦的，所以，可以考虑**一次只修改一个字符串**。

如果每一个字符串中只有 $0$ 或只有 $1$，那么最多操作一次就可以了。

这可以给我们启发：**可以将每一个字符串变成只有一种字符的字符串**。

所以，接下来的任务就是如何将每一个字符串变成只有一个字符的字符串。

这个可以从前面开始遍历，如果这个位置与后一个位置不同，那么就对这一个位置之前的进行操作，一直到最后就可以了。

举个例子：$01010\to11010\to00010\to11110\to00000$。

而且，我们经过上面的操作之后，**每一个字符串的字符与原字符串最后一个字符相同**，所以我们就不需要在数组中修改了，这样就减少了许多时间复杂度。

最后，我们**要判断这两个字符串是否一样**，如果一个全是 $0$，另一个全是 $1$，那么就需要对整个字符串进行操作。

还有一个问题：题目中让我们输出操作字符串 $a$ 的方案，但是我们在处理的过程中操作字符串 $b$ 了，所以输出时对字符串 $b$ 的方案应该倒着输出。

对于每一个字符串，最多操作 $n-1$ 次，最后判断是否一样，最多操作 $1$ 次，这样，总共操作不超过 $2n-1$ 次，符合要求。

时间复杂度为 $O\left(n\right)$。

**代码：**
```cpp
#include<cstdio>
#include<iostream>
const int N=100000;
char a[N+1],b[N+1];
int c[N],d[N];//c和d分别记录a和b的操作
int main()
{
	register int i,j,k,n,t;//j和k分别统计a和b的方案数
	scanf("%d",&t);
	while(t--)
	{
		scanf("%d%s%s",&n,a+1,b+1);
		j=k=0;//注意清零
		for(i=1; i<n; ++i)
		{
			if(a[i]!=a[i+1])
				c[++j]=i;//将a变成只有一种字符的字符串
			if(b[i]!=b[i+1])
				d[++k]=i;//将b变成只有一种字符的字符串
		}
		if(a[n]!=b[n])//如果两个字符串不一样，那么就要对整个字符串操作一次
			c[++j]=n;
		printf("%d ",j+k);//输出方案数
		for(i=1; i<=j; ++i)
			printf("%d ",c[i]);//输出a的操作
		for(i=k; i; --i)
			printf("%d ",d[i]);//倒着输出b的操作
		putchar('\n');
	}
	return 0;
}
```