这题可以尝试暴力通过。

当然直接枚举子串的左右端是肯定过不去的，我们可以改变下枚举的东西。

如果说我们每确定一个左端点 $i$，都能找到它右边最多能延伸的最大长度 $j$，那么以 $i$ 为左端点的合法子串个数就是 $j-i+1$。

-----

再找找字符串的特征。

发现题目要求合法的串是 `01` 交替的，可以理解为相邻两个字符位置**不同**。

如果我们把 `01` 串每**奇数或偶数**下标的字符进行 `0,1` 反转，那么条件就可以变成相邻两个字符位置**相同**。

因此我们可以先利用类后缀和的方式找到**右边第一个等于 $0/1$ 的数的位置**

对于每个左端点 $i$：

- 如果 $s_i=0$，那么找右边第一个等于 $1$ 的位置 $j$，答案为 $j-i$；
- 如果 $s_i=1$，那么找右边第一个等于 $0$ 的位置即可。
- 如果 $s_i=$ `?`，我们找到右边第一个不等于 `?` 的位置 $j$，再找到 $s_j$ 右边第一个和 $s_j$ 相反且不是 `?` 的位置。
- 整合一下，$s_i=0/1$ 统计方法其实属于 $s_i=$ `?` 的情况。

提醒：以上统计中，注意到可能某个位置右边不存在 $0/1$，这时拿 $n+1$ 减去该位置即可。

时间复杂度 $O(\sum n)$。

**代码**

```cpp
#include <cstring>
#include <cstdio>
#define INF 1e9
#define eps 1e-6
typedef long long ll;

int t, n, a[200010][2];
char s[200010];
ll ans = 0;

inline int max(int a, int b){
	return a > b ? a : b;
}

int main(){

	scanf("%d", &t);
	while(t--){
		scanf("%s", s + 1), n = strlen(s + 1);
		for(int i = 1; i <= n; i += 2){			// 反转奇数位的 0/1
			if(s[i] == '0') s[i] = '1';
			else if(s[i] == '1') s[i] = '0';
		}
		a[n + 1][0] = a[n + 1][1] = n + 1, ans = 0;
		for(int i = n; i >= 1; i--){	// 每个位置右边第一个 0/1
			if(s[i] == '1') a[i][0] = a[i + 1][0], a[i][1] = i;
			if(s[i] == '0') a[i][1] = a[i + 1][1], a[i][0] = i;
			if(s[i] == '?') a[i][0] = a[i + 1][0], a[i][1] = a[i + 1][1];
		}
		for(int i = 1; i <= n; i++)
			ans += max(a[i][0], a[i][1]) - i;	// 右边第一个 0,1 中较远的位置减去 i
		printf("%lld\n", ans);
	}

	return 0;
}
```