[传送门](http://codeforces.com/contest/1194/problem/D)
## 题目大意
$n$ 个石子，一次可以取 $1,2$ 或 $k$ 个，两人轮流取，取到最后一个胜利，问谁有必胜策略。

## Solution
一眼巴什博奕。

如果没有可以取 $k$ 个这一条件，那么就是裸的博弈，那么我们来考虑可以取 $k$ 个这一条件对答案产生了什么影响。首先，我们做巴什博奕是利用了分组的思想，即以 $3$ 个为一组，如果我在一组中是后手，那么显然有必胜的策略。

那么如果取 $k$ 个，会对最后分组有什么影响呢？我们分两种情况考虑：

**Case1：$k$ 不是 $3$ 的倍数**

此时，如果我取一次 $k$ 其实相当于取了一次 $k\%3$。因为如果 $n\%3=0$，先手不可能通过取一次 $k$ 把石子取完，所以和取 $1$ 或 $2$ 没有什么区别。而如果 $n\%3\neq 0$，那么只需要先手把余数取掉，仍然必胜。

所以如果是 $k\%3\neq 0$，那么直接做巴什博奕就可以了。

**Case2：$k$ 是 $3$ 的倍数**

此时有个问题，如果取一次 $k$ 那么相当于交换了一次先后手，会对之后的决策造成极大的影响。此时不好思考，我们来考虑找找规律。

如果 $k=6$，则有如下胜负，$A$ 表示先手必胜，$B$ 表示后手必胜：

|n|0|1|2|3|4|5|6|7|8|9|10|$\cdots$|
|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|
|res|B|A|A|B|A|A|A|B|A|A|B|$\cdots$|

可以发现，结果是以 $k+1$ 为一个循环周期的。为什么会这样呢？因为在 $n=k$ 的时候，本来是后手必胜的，但现在是先手必胜，导致 $n=k+1$ 时后手必胜。同理，我们也可以列出 $k=9$ 的情况来看看：

|n|0|1|2|3|4|5|6|7|8|9|10|$\cdots$|
|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|
|res|B|A|A|B|A|A|B|A|A|A|B|$\cdots$|

果然是这个规律，我们已经找出了如何解决 $n\%3=0$ 时的情况：只需要将 $n$ 模上 $k+1$，然后判断余数是否是 $3$ 的倍数且不是 $k$，如果是，那么后手胜，否则先手胜。

## Code
```cpp
#include<bits/stdc++.h>
#define inf 1<<30
#define ll long long
#define INF 1ll<<60
using namespace std;
void solve(){
	int n,k;
	scanf("%d%d",&n,&k);
	if(k%3){
		if(n%3) puts("Alice");
		else puts("Bob");
	}else{
		int rem=n%(k+1);
		if(rem%3==0&&rem!=k) puts("Bob");
		else puts("Alice");
	}
}
int main()
{
	int T;
	for(scanf("%d",&T);T--;)
		solve();
}
```