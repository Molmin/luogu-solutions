博弈论的题 相对来讲还是要推一下的

首先 我们先明确并转化题目意思：

A和B两个人共取走n个石子，每次他们都可以取1，2，或者k个。问谁能把石子取到0。前提条件时两个人都足够聪明。

那我们简单想一想：

- 假设窝的k=3：

那么我的n为0、1、2...

|n=|0| 1 | 2 | 3 | 4 |5  |6  |7  |8  |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
|胜者 | B | A | A | A |B  |A  |A  |A  |B  |

- 再次假设我的k=4：

|n=|0| 1 | 2 | 3 | 4 |5  |6  |7  |8  |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
|胜者 | B | A | A | B |A  |A  |B  |A  |A  |

我们发现所有的B点都是必败点，当我们的任意一方踩到这个点时（从这个点开始走），他就输了。

如果m点是必败点，那么$m+1，m+2，m+k$就是必胜点，因为如果在这个点上面，我们可以通过走1，2，k步走到一个必败点，从而赢得胜利。

然后 我们会发现，当我们的 $k%3!=0$ 时，他们的必败点都是n=3k的时候。（显然，基本不用证明）

那如果k是3的倍数呢？

也很简单通俗易懂：

我们再举两个例子，k=6和k=9.（k=3在上面已经有了）

|k=6时n=  |0  |1  |2  |3  |4  |5  |6  |7  |8  |9  |10  |11  |12  |13  |
| -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: |
|胜者  |B  |A  |A  |B  |A  |A  |A  |B  |A  |A  |B  |A  |A  |A  |
|**k=9时n=**  |**0**  |**1**  |**2**  | **3** |**4**  |**5**  |**6**  |**7**  |**8**  |**9**  |**10**  |**11**  |**12**  |**13**  |
|胜者  |B  |A  |A  |B  |A  |A  |B  |A  |A  |A  |B  |A  |A  |B  |

我们会发现每k+1个形成一个循环，所以说我们把n%一个k+1

然后，n除出来的余数，如果是3的倍数且不是k，那么就是一个必败点，反之亦然。

- 代码如下，我就不做解释了：
```
#include<bits/stdc++.h>
using namespace std;
int main(){
    int t;
    cin>>t;
    for(int i=1;i<=t;i++){
        int n,x;
        cin>>n>>x;
        if(x%3!=0){
            if(n%3==0) cout<<"Bob"<<endl;
            else cout<<"Alice"<<endl;
        }
        else{
            n%=(x+1);
            if(n%3==0&&n!=x) cout<<"Bob"<<endl;
            else cout<<"Alice"<<endl;
        }
    }
    return 0;
}
```