考试就栽在这一题上了qwq

## 思路

又是一道构造题，先分情况讨论。

### $-1$

不难想到，异或是**带减法的加法**，也就是说，几个数的**异或**值一定**不大于**几个数的**和**。

于是，如果 $a>b$，那么一定输出 $-1$。

又由于异或与和的**奇偶性相同**，所以如果 $b-a$ 是奇数，一定输出 $-1$。

### $n=3$

如果不是无法构造，而且没有 "正整数" 的条件的话，任何 $a$ 和 $b$ 都可以用 $3$ 个数构造出来。

方法很简单，由于 $b≥a$ 且 $b-a$ 是偶数，那么先取 $a$，让后两个数抵消就可以了。（即 $a$, $(b-a)/2$, $(b-a)/2$）

然而，题目有 "**正整数**" 和 "**最短**" 两个条件，只好继续分情况讨论。

（后面每种情况都有样例，样例输出两行的压到了一行）

### $n=0$

样例：```0 0```，输出 ```0```

必须 $a$ 和 $b$ **都是 $0$** 才可以 $n=0$。

### $n=1$

样例：```5 5```，输出 ```1 5```

需要一个数搞定，那么必须 $a=b$，序列就是一个数 $a$。

### $n=2 -(1)$

样例：```0 6```，输出 ```2 3 3```

这种情况是 $a=0$，序列只需要两个数 $b/2$, $b/2$。

### $n=2-(2)$

样例 1：```2 4```，输出 ```2 3 1```

样例 2：```1 9```，输出 ```2 5 4```

通过~~找规律~~可以发现序列的两个数分别是 $(a+b)/2$ 和 $(b-a)/2$。

这两个数的和一定是 $b$，但是异或不一定是 $a$。

例如 ```1 3``` 就不能输出 ```2 2 1```。

于是我想到一个方法：**直接判断**。

也就是说，如果 $(a+b)/2$ $xor$ $(b-a)/2 = a$，那么 $n=2$，否则 $n=3$。

于是这道题就做完了。

## 代码

下面放 AC 代码（感觉这个代码很像骗分）——

```cpp
#include<cstdio>
#define ll long long //注意 longlong
using namespace std;
ll read(){ //快读
	ll num=0,sign=1; char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')sign=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){num=num*10+ch-'0';ch=getchar();}
	return num*sign;
}
int main(){ //主函数
	ll a=read(),b=read();
	if(a>b||(b-a)&1ll) printf("-1\n");//无解的情况
	else{ //有解
		if(a==0ll&&b==0ll) printf("0\n");//a=b=0,n=0
		else if(a==b) printf("1\n%lld\n",a);//a=b,n=1
		else if(a==0ll) printf("2\n%lld %lld\n",b/2ll,b/2ll);//a=0,n=2(1)
		else{ //n=2(2)和n=3
			if((((a+b)/2ll)^((b-a)/2ll))==a) //直接判断异或
				printf("2\n%lld %lld\n",(a+b)/2ll,(b-a)/2ll);//n=2(2)
			else //n=3
				printf("3\n%lld %lld %lld\n",a,(b-a)/2ll,(b-a)/2ll);
		}
	}
	return 0;//华丽结束
}
```
看我写了那么多分析，总得点个赞再走呀~