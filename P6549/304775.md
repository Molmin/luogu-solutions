[原题链接](https://www.luogu.com.cn/problem/P6549)

看到大佬们已经说的很详细了，那我来一发。

首先我们考虑最坏的情况，就是从上向下是按从大到小的顺序排的，此时需要调整$n$次。于是我们初始化将$ans$设为$n$。然后开始从顶部向下扫，按照这个顺序，如果碰到的书本编号恰好是已移动次数，那么这本书可以不移，$ans$减一。

下面我们来详细的讨论一下这样为什么就是正解。

我们来看一下这个例子：${4,1,2,3,5}$。此时就是我们所说的“最糟糕的情况”，需要移动五次，尽管$1,2,3$已经被排好了。所以我们仅需要把最大的元素与第二大的元素之间所有的元素都需移动，无论它们是否排的有序。

因此我们可以得出以上的解法：**从书堆上方向下扫，计算已经从大到小排好的元素，这些元素可以不动，其余至少要移动一次。**

希望我的讲解能为大家带来帮助！

上代码（有注释）：

```cpp
#include <iostream>
using namespace std;

const int N=3e5+1;//数组最大空间 
int main()
{
	int res,n,a[N];
	cin>>n;
	res=n;
	//读入书堆 
	for(int i=1;i<=n;i++)
	{
		cin>>a[i];
	}
	for(int i=n;i>=1;i--)//注意，这里要从后向前扫！ 
	{
		if(res==a[i]) //我们上面说的策略 
			res--;
	}
	cout<<res<<endl;//输出答案 
	return 0;
}
```

管理员大大求通过！


**若有错误，欢迎指出！**

