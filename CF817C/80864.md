# 这题不难
 但一点都不简单
## 1）前置芝士
*******817，不多说，再说枪毙**

## 2）思路

先看看数据，找出些规律
![](https://cdn.luogu.com.cn/upload/pic/73789.png)

 不难发现，s都为9的倍数，且在连续10个n中都相同。（严谨证明很简单，~~在这里不做解释~~）
 
  **_注意：s每次增加时，不一定只增加10（比如n=90,n=100之间）_** 
  
 再枚举一下，会发现\[s/10]必小于\[n/10];
 
 现在我们知道了s的值，个么就从这里下手；
 
 感性理解一下，s的值是不降的，所以找出起点 n' 即可。（n'为10的倍数）
 
### 来枚举 n' 吧！

易证（感性理解）， s' 必小于其对应的 n' ；故从s开始枚举。

这时，枚举的下界定了，那么上界呢？在数据范围中。n最大为1e18，所以数位和最大时，即每位都是9，即n最多比s大 18*9=162.所以，上界就为s+162。（由上性质，故可枚举时每次+=10）


hin简单，当你枚举的 n' 所对应的 s' 大于给出的 s 时，说明这个 n' 也许过大（可能刚好）了，于是要让 n'-=10 ，相应的，再算一次 s' 。

这时，s'<=s，分类讨论一下；

如果s'==s，那么起点刚好是n'；

如果s'<s，那么起点 n' 也小了，就是说n'要+10（变大）。

这里可能存在找不到数（ans=0）的情况，如上ans会为负，所以加个特判就ok。


------------

代码：

```c++
#include<bits/stdc++.h>
using namespace std;
#define ll long long
long long n,s;
long long sum;
ll ans;
void deal(ll x)
{
	sum=0;
	while(x)
	{
		sum+=x%10;
		x/=10;
	}
}

int main()
{
	cin>>n>>s;
	if(s/10>=n/10) 
	{
		printf("0\n");
		return 0;
	}
	else
	{
		ll p=s/10+1;
		p*=10;
		for(int i=0;i<=20;i++)
		{
			p+=10;
			deal(p);
			if(p-sum>s) break;
		}
		p-=10;
		deal(p);
		ans=n-p+1;
		p-=sum;
		if(s>p) ans-=10;
		printf("%lld\n",max(0LL,ans));
	}
	return 0;
}
```