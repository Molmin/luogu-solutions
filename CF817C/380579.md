我本来想写数位 DP 的，发现 DP 数组开不了那么大，放弃了。

**推论 $1$：** $\forall x\in[0,+\infty)$，$x$ 的答案等于 $x-x\%10$ 的答案。

这个证明很简单，设末位为 $k$，除末位以外数字和为 $p$：

$$
x-p-k=(x-k)-p
$$

得证。换句话说，$114514$ 的答案一定等于 $114510$ 的答案，每十个数的答案都是相同的。

**推论 $2$：** 答案**单调**。我们设 $f(x)$ 表示 $x$ 与 $x$ 的数字和的差（以下均采用这个记法）：

$\forall x_1-x_2=10,x_1\equiv 0\pmod{10}$，讨论：

1. 存在进位的情况，如 $990$ 与 $1000$。设进了 $j$ 次位，则进位后的 $x_1$，其 $sum_{x_1}=sum_{x_2}-9j+1$。而 $x_1-x_2=10$，故：

$$
f(x_1)-f(x_2)=x_1-x_2-(sum_{x_2}-9j+1)+sum_{x_2}=9+9j\geqslant 0
$$

故这种情况下必然单调。

2. 不存在进位的情况，如 $50$ 和 $60$，此时 $j=0$，上式仍然成立，这种情况也必然单调。

**推论 $3$：**$\forall s\in[1,10^{18}]$，$\exists x\leqslant 9\times 18$，使得 $[x,+\infty)$ 中所有数的数字和都大于等于 $s$。

这个很好证，由于答案单调，我们直接考虑最大的 $s$，它对应的最小 $x$ 是多少。构造得到 $s=10^{18}-1,x=17\times 9$。换句话说，这个 $x$ 取决于你能进多少个 $9$。

这条推论的意义在于，对于所有大于等于 $s+18\times 9$ 的数，其答案都大于等于 $s$。

**推论 $4$：** 所有小于 $s$ 的数，其答案必定小于 $s$。

这个很好证的，$sum(s)$ 最小都是 $1$（除了 $0$ 以外，但没啥意义。。），又因为答案单调，所以小于 $s$ 的数没有一个答案会大于等于 $s$。

嘿，有了这四条，我们就可以得出算法步骤：

- 排除掉所有 $x<s$
- 计算 $n-s-9\times 18$ 的答案
- 循环找到 $[s,s+9\times 18]$ 中所有满足条件的数。

**最后别忘了特判 $n<s$。**

代码如下：

```cpp
//CF817C
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,s,ans=0;
signed main(){
    scanf("%lld %lld",&n,&s);
    if(n<s){
        printf("0");
        return 0;
    }
    if(n-s-9*18>0){
        ans+=n-s-9*18;
        n=s+9*18;
    }
    for(register int i=s;i<=n;i++){
        int x=i,sum=0;
        while(x!=0) sum+=x%10,x/=10;
        if(i-sum>=s) ans++;
    }
    printf("%lld",ans);
}
```