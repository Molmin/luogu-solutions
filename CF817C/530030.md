## 题意分析

> 统计从 $1$ 到 $n$ 中有几个数减去其各数位之和后大于等于 $s$。

刚看到题目，我的第一反应想到的是**枚举**，但显然枚举卡不过 $10^{18}$。

于是，我分析了一下样例，试图从中找出**结论**：

```
//Input 1
12 1

//Output 1
3

//Input 2
25 20

//Output 2
0

//Input 3
10 9

//Output 3
1
```

简单分析一下，样例一中的 $3$ 个数是 $10$，$11$，$12$；样例二中由于第一个满足条件的数是 $30$，故没有答案；样例三中满足条件的只有 $10$ 一个数。

> 答案一定具有单调性！

## 单调性证明

我们设对于 $s$ 的第一个“真正大数”为 $x$（显然满足 $x\geq s$），$f(x)$ 表示 $x$ 的各数位上的数之和，则有： 

$x-f(x)\geq s$

接下来要证明的是每一个大于 $y$ 的正整数都是“真正大数”，当然，我们只要作如下证明：

对于任何一个正整数 $d$，都有 $d\geq f(d)$，等号当且仅当 $q\geq d\geq 10$ 时成立。

证明：

我们将 $d$ 写成 $p_1\times 10^n+p_2\times 10^{n-1}+\ldots+p_{n}\times10^1+p_{n+1}\times10^0$，其中 $0<p_i<10$且为整数，这样看来，我们只要**作个差**就能比较出 $d$ 与 $f(d)=p_1+p_2+\dots+p_{n}+p_{n+1}$ 的大小了，由于过程过于简单且考虑篇幅，故省略。

由此，我们可以得到这样一个推论：

> $d$ 的增长比 $f(d)$ 来得快。

这个就用小学知识来解释：$d$ 增长得过程中会遇到逢十进一得情况，这样对 $d$ 来说是好的，可以 $f(d)$ 的几个 $9$ 就会变成 $1$，是亏损的，以这个角度来看，这个问题就很好理解了。

于是，我们只需要找出第一个“真正大数”，就可以肯定大于等于这个数的所有数都满足要求。

## 实现
注意这样几个问题：

1. 不开 `longlong` 见祖宗。
2. 当第一个真正大数大于 $n$ 的时候输出 $0$.

所以就写出了这样的代码：
```cpp
#include<bits/stdc++.h> \\CF817C
#define ll long long 
using namespace std;
ll n,s;
ll check(ll x,ll y)
{
	int tot=0;
	while(y)
	{
		tot=tot+(y%10);
		y=y/10;
	}
	return (x-tot)>=s;
}
int main()
{
	scanf("%lld%lld",&n,&s);
	ll ans=s;
	while(check(ans,ans)==false) ans++;
	if(ans>n) printf("0");
	else printf("%lld",n-ans+1);
	return 0;
}
```