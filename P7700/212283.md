## 题意

从第 $P$ 个星球开始走，去到编号为 $i$ 的星球，消耗 $b_i$ 的燃料获得 $a_i$ 的燃料。

问如何在保证获得燃料最多的情况下去尽可能多的星球？

## 解析

实际上，我们很容易想到一个贪心的方案，也就是按照 $a_i-b_i$ 进行排序，按序访问收益最高的星球，这样子我们的收益应该是最大的。但是不妨设想这样的一个场景，我们现在有很少的路费，远处有一个收益极高的星球，譬如说花费 $10^5$ 的燃料可以获取 $10^8$ 的燃料，但是我们手头上只有 $500$ 路费，这应该怎么办呢？

出现这种情况是因为我们陷入了一个误区，我们太贪心了，以至于做出了实际上没有任何必要的决策。在寻找燃料的过程中，并没有限制我们所访问的星球个数，因此**只要当前星球收益为正，就应该访问**。即使在 $a_i=b_i$ 的时候也应当前往，因为题目要求尽可能多地访问星球，这样的决策是符合题意的。

但是，会不会出现收益为负数，却不得不去的情况呢？答案是否定的。因为题目**首先要求收益最大**，在保证这一大前提的情况下我们采取追求尽可能多的星球访问，因此我们应该做出如下的处理：

- 将星球按照 $b$ 从小到大排序。这一步的目的是保证我们不会因为燃料不足而错过星球，让我们循序渐进地积累燃料，这样才能为靠后的代价较高的星球铺好基础。
- 对于收益为负的星球直接跳过。因为这会影响我们求的最优解。

那么至此，我们已经简单总结出了运算逻辑，详细的实现步骤见代码。

## 代码

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int MAXN = 1e5+10;
struct node{
	int a,b;
}arr[100005];
bool cmp(node x,node y){
	return x.b<y.b;
}int n,p,now,cnt=1;
signed main(){
	cin>>n>>p;
	for(int i=1;i<=n;i++)
		cin>>arr[i].a>>arr[i].b;
	swap(arr[p],arr[1]);
	sort(arr+2,arr+1+n,cmp);
	now=arr[1].a;
	for(int i=2;i<=n;i++){
		if(arr[i].a-arr[i].b<0)continue;
		if(now>=arr[i].b){
			now=now-arr[i].b+arr[i].a;
			cnt++;
		}
	}cout<<now<<"\n"<<cnt<<"\n";
	return 0;
}
```



