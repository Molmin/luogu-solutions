## 题目意思及翻译
题目意思非常清楚，就是有 $N$ 个星球，某某小队现在在 $P$ 号星球。第 $i$ 个星球有 $a_i$ 燃料资源，但去这个星球要花费 $b_i$ 的燃料。现在要帮助他们在剩余燃料最大的前提下访问尽可能多的星球。

## 主要思路及算法
当初一眼看到这题还以为是个橙题 DP，后来方程搞了半天没弄出来，~~我就放弃了~~。后来我~~仔细~~一想：哎！这就是个**贪心**！

我一开始的思路是按照价值 $v$（**这里的价值指题目中的 $a_i - b_i$**）从大到小排序，然后分成以下三类：

- $v>0$，这类星球是一定要去的，增加一个星球的同时还让自己的剩余燃料变大，岂不妙哉！

- $v=0$，这是一个坑点。虽然剩余燃料并没有增加，但是多了一个星球呀！这类星球也是要去的。

- $v<0$，这类星球是肯定不能去的，大前提都不满足，多一个星球也得不偿失。

但是，有这样一个反例：如果有一个星球，去的时候要**花费 $2^{31}$ 的路费**，但是**收益却有 $2^{32}$（数据不会出成这样，我只是举个例子），而此时我们手中只有 $1$ 块钱**。很明显，刚刚的思路被打翻了。

正解：**按照花费 $t$（即题目中的 $b_i$）从小到大排序**（注意这里，很关键），然后按照上面的思路分析即可。

## 代码部分
以下是本蒟蒻的参考代码，珍爱生命，远离抄袭。

Code:
```cpp
#include<bits/stdc++.h>
using namespace std;

const int N = 100000 + 10;
int n, p, a, b, k, ans, cnt;
//ans是最大剩余燃料，cnt是最大星球数量 

struct star{
	int v, t;
} s[N];//定义结构体储存一个星球 

bool cmp(star x, star y){return x.t < y.t;}//手写排序规则 

int main(){
	cin >> n >> p;
	for(int i=1;i<=n;i++){
		cin >> a >> b;
		if(i == p)	 ans = a, cnt++;//输入到当前所在星球时，直接处理，不需存到数组中 
		else if(i != p && a - b >= 0)	s[++k].v = a - b, s[k].t = b;
		//只存储去的星球，a - b为负的不储存（没意义） 
	}
	sort(s + 1, s + 1 + k, cmp);//排个序~ 
	for(int i=1;i<=k;i++){
		if(ans >= s[i].t && s[i].v >= 0){//这里写多余了，只需燃料足够即可，后面的判断可省略 
			ans += s[i].v, cnt++;//燃料增加，星球数增加1 
		}
	}
	cout << ans << endl << cnt << endl;
	return 0;//完结撒花 
}
```
