没听懂标准解法（考场写了正解就没怎么听），分享一下考场思路，这里认为空树合法能且仅能仅能生成空树。

称一棵树$B$比一棵树$A$更容易被生成，当且仅当$A\rightarrow B$，那么一定有$\forall T\rightarrow A,T\rightarrow B$。

于是所有非空树比一个节点的树容易生成。

若存在无限个树不能被生成，则一定存在一个无限大的树不能被生成（这是充要条件）。

一颗非空树$A$可以生成另一颗非空树$B$当且仅当$A$的左右儿子可以分别生成$B$的左右儿子

令一颗无限大的树$T$的左子树$T_l$为无限大（右子树时同理），若右子树$T_r$大小大于$1$则将$T_r$换为一个节点的树也一定不能被生成（因为$T_r$比它容易生成）且大小无限大。

于是题目变为能否找到一个无限大的树，每个节点要么只有一个儿子，要么两个儿子中有一个子树大小为$1$。

然后可以递归搜索$check(S)$：定义集合$S$为当前需要判断的树集合（即是否有无限个树$T$，使得$T\in grow(S)$）

如果$S$中存在一个点的树，那么答案为否，如果$S$为空，那么答案为真

然后搜右子树为空的情况：若所有在$S$中，且没有右子树的树的左子树组成的集合为$T$，若$check(T)=1$，则$check(S)=1$

右子树为一个节点的同理：若所有在$S$中，且右子树大小为$1$的树的左子树组成的集合为$T$，若$check(T)=1$，则$check(S)=1$

然后对称地对左子树做一遍即可。

update: 考虑每个节点对复杂度的贡献为$O(1)$，所以总复杂度$O(\sum n)$

没带U盘去一中，于是没有代码。