本题主要考察思维，代码实现难度不大。

首先要注意，本题随时可以放棋子，但是分两个阶段：

1. **初始化**阶段。在这个阶段，棋子可以任意放置，不受格子颜色的限制；

2. **游戏阶段**。在这个阶段，棋子只能放在**红色**格子上。

本题的两个问题就可以概括成：

$\text{Q1. }$ 初始化阶段至少要放多少颗棋子；

$\text{Q2. }$ 在上一问的基础上，至少要在游戏阶段放多少颗棋子。

***

那么不难发现，放在**第** $1$ **格的棋子**的每一步一定是**落在奇数编号格上的**。

其实这就说明了本题一定有解——只要在初始化时直接在每个偶数编号格子上放置棋子即可。那么跳棋的大概路径就会是这样：

![](https://i.bmp.ovh/imgs/2021/12/64b17418fe8b04fb.png)

因此本题是一定有解的。下面我们考虑加入了红色格子的情况，假设**没有两个相邻红色格子**。如下图：

![](https://i.bmp.ovh/imgs/2021/12/7cb68c3305735814.png)

第 $1$ 格的棋子的路径既然一定是 $1 \rightarrow 3 \rightarrow 5 \rightarrow 7 \rightarrow 9$，那么**必然要在偶数号格子上放棋子**（否则跳不过去），放不放只是时间问题。

根据题意，第一问需要求的是初始化阶段放置棋子的最小数目，那么在这种情况下就很显然了：既然**偶数号**红色格子可以等到游戏阶段再放置，那么初始化阶段就可以**只在偶数号白色格子放棋子**，剩下的等到游戏阶段再补上。用图例说明：

![](https://i.bmp.ovh/imgs/2021/12/4a3b8b1d1e319728.png)

![](https://i.bmp.ovh/imgs/2021/12/7f5d3a0a74b64931.png)

第二问的答案也呼之欲出了。有多少个红色格子，就放多少个。

那么结论就是：如果**不存在相邻红色格子**，直接**统计偶数号格子中白色格子和红色格子的数量**，分别作为第一问和第二问的答案。

***

但是，会出现一个问题：如果有两个相邻格子呢？

![](https://i.bmp.ovh/imgs/2021/12/58b84795922f957d.png)

请注意，棋子**可以往左跳**。这种情况下，还有必要在初始化阶段放置棋子吗？


如果要移动 $1$ 号格子的棋子，必然要使 $2$ 号格上有一颗棋子。但是，这颗棋子的来源不一定是要我们直接放置的。如果我们在 $3$ 和 $4$ 各放一颗，然后让 $4$ 往左跳，这样就可以使得 $2$ 号格有棋子了。

![](https://i.bmp.ovh/imgs/2021/12/5c23f667de90847b.png)

不难发现，如果存在两个相邻红色格子，那么靠这两个格子当“跳板”就能到达任意格子。也就是说，在这种情况下，**第一问的答案为** $0$。

***

接下来考虑如何使得第二问的答案最小。考虑如下情况：

![](https://i.bmp.ovh/imgs/2021/12/92b65d3d12506e21.png)

那么如果要让 $4$ 号格子有棋子，至少需要多少颗棋子呢？很明显，让 $2$ 和 $3$ 而不是 $7$ 和 $8$ 两格去当“跳板”能够省下最多的棋子。所以对于每一个格子，都需要进行一次动态规划来计算。

如果要让 $5$ 号格子有棋子，那么得让 $4$ 和 $3$ 都有棋子。设 $f(x)$ 表示让 $x$ 号格子有棋子的最少数量，不难得到：
$$f(x) = \text{min(}f(x), f(x-1) + f(x-2))$$

当然，还可以往左边跳，方程的推导比较类似，这里就不过多赘述。

至于怎么对 $f$ 数组进行初始化，不难想到：如果这个格子是红色的，那么就初始化成 $1$，否则初始化成 $\text{inf}$。原因很简单：如果这个格子本身就是红色的，只要直接放就能让它上面有一颗棋子，无需通过其他格子转移得到。


所以最终的状态转移方程就是：

$$
f(x) = 
\begin{cases}
\text{min\{}f(x), f(x-1) + f(x-2),  f(x+1) + f(x+2)\} & & {color_x \neq 1}\\
1 & & {color_x = 1}\\
\end{cases}
$$

$$ans=\sum^{\lfloor\frac{n}{2}\rfloor}_{x=1}f(2x)$$


因为只需要计算偶数格上的棋子数量，所以只取下标为偶数的 $f$ 相加。

另外注意，这道题需要开 `long long`。

***

```
#include <cstdio>

#define int long long

const int maxn = 1000 + 5;
const int inf = 1e18;

int n;
int red, white;
bool a[maxn];
int f[maxn];
bool ok = false;

inline bool getbyte() {
	char c;
	while((c = getchar()) < '0' || c > '1');
	return c == '1';
} 

inline int getint() {
	char c;
	while((c = getchar()) < '0' || c > '9');
	int x = c - '0';
	while((c = getchar()) >= '0' && c <= '9') x = (x << 3) + (x << 1) + c - '0';
	return x;
}

inline int min(int a, int b) {
	return a < b ? a : b;
}

signed main() {
	n = getint();
	for(int i = 1; i <= n; i++) {
		a[i] = getbyte();
	}
	a[1] = 0;
	for(int i = 1; i <= n; i++) {
		if(i % 2 == 0) {
			if(a[i]) red++;
			else white++;
		}
		if(a[i - 1] && a[i]) { // 出现相邻红色格
			ok = true;
		}
	}
	if(!ok) { // 没有相邻的红色格子
		printf("%d\n%d", white, red);
		return 0;
	}
	for(int i = 1; i <= n; i++) {
		f[i] = a[i] ? 1 : inf; // 初始化
	}
	for(int i = 1; i <= n; i++) { // 分开计算左右的状态转移方程
		if(a[i - 1] && a[i]) {
			for(int j = i - 2; j >= 1; j--) {
				f[j] = min(f[j + 2] + f[j + 1], f[j]);
			}
			for(int j = i + 1; j <= n; j++) {
				f[j] = min(f[j - 2] + f[j - 1], f[j]);
			}
		}
	}
	
	long long ans = 0;
	for(int i = 1; i <= (n >> 1); i++) { // 只计算偶数下标的总和
		ans += f[i * 2];
	}
	putchar('0'); putchar('\n');
	printf("%lld\n", ans);
	return 0;
}
```
Remember to leave a like!

求通过~