## 题意

给定 $n$ 个数 $a_1,a_2,\dots,a_n$ 和一个整数 $m$，你需要将它们分成几个部分，使得每个部分当中，相邻两个数的和都能被 $m$ 整除。你可以将它们重新调换成你想要的顺序。求最少需要分成几个部分。

$T$ 组数据，$1 \le T \le 10^3$，$1 \le n,m \le 10^5$，$1 \le a_i \le 10^9$。

## 分析

数据约定，对于每一次查询，必是线性或更低级别的复杂度。

既然是和可以被 $m$ 整除，那两数对于 $m$ 取模之后的值也必定会被 $m$ 整除。所以我们可以在读入的时候把这个数据 $\bmod m$ ，并且存入余数数组。

我们可以考虑，对于两个数的和等于 $m$ 的情况，必定是这两个数除以 $m$ 的余数之和等于 $m$。所以考虑余数互补。

我们每一组查询，循环到 $\dfrac{m}{2}$  即可。然后判断第 $i$ 位以及互补的 $m-i$ 位满足什么条件，累加答案即可，在最开始记得清空答案即可。

代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
int t,n,m,a,mod[100005],ans;
int main(){
	scanf("%d",&t);
	while(t--){
		ans=0;
		memset(mod,0,sizeof(mod));//清空数据 
		scanf("%d%d",&n,&m);
		for(int i=1;i<=n;i++){
			scanf("%d",&a);
			mod[a%m]++;
		}
		if(mod[0]){//若余数为 0 则分出一部分
			ans++;
		}
		for(int i=1;i<=m/2;i++){
			if(mod[i]==0&&mod[m-i]==0){//如果都为 0 则退回枚举下一个 
				continue;
			}
			if(abs(mod[i]-mod[m-i])==0){//两种数个数相等 
				ans++;//分出一个部分即可 
			}
			else{//其他情况就是不相等 
				ans+=abs(mod[i]-mod[m-i]);//答案要增加它们的差值 
			}
		}
		printf("%d\n",ans);//输出 
	}
	return 0;
}
```
复杂度确实为线性，可以通过此题。