### 题意简述
给定一个 $n \times n$ 的方阵，通过 $m$ 次修改给定初始值。每次操作把一个格子上的数加一，另一个格子上的数减一，问多少次操作可以弄出一个由 $1$ 组成的矩阵并且其余格子均为 $0$。

### 思路
由于方阵初始全部为 $0$，在 $m$ 次修改中每次将一个格子加一，而每次操作中一个格子加一，一个格子减一，所以无论如何操作，方阵里数的总和均为 $m$。那么由 $1$ 组成的矩阵面积也为 $m$。这样题目就可以转换为找一个面积为 $m$ 并且 $0$ 的个数最少的矩阵，因为每次操作可以把矩阵中一个 $0$ 变成 $1$ 。要把矩阵里全部变成 $1$ 就需要矩阵中 $0$ 的个数次操作。

那么怎么求 $0$ 的个数呢？暴力计算的话复杂度是 $O(n^2 m^2)$。很明显不满足要求。这时候我们就要用到[二维前缀和](https://blog.csdn.net/qq_34261446/article/details/104010466)。$O(n^2)$ 统计出每个矩阵中 $0$ 的个数，再枚举每个矩阵的左上角坐标和矩阵的长求最小值即可，复杂度 $O(n^2 m)$。

### 代码实现
```cpp
#include <bits/stdc++.h>
using namespace std;
int n,m,s[105][105],a[105][105],ans=100000000;
int main()
{
    cin>>n>>m;
    for(int i=1;i<=m;i++)
    {
        int x,y;
        cin>>x>>y;
        a[x][y]++;
    }
    for(int i=1;i<=n;i++)
        for(int j=1;j<=n;j++)
            if(a[i][j]==0)s[i][j]++;//统计每个格子是否为0
    for(int i=1;i<=n;i++)
        for(int j=1;j<=n;j++)
            s[i][j]+=s[i-1][j]+s[i][j-1]-s[i-1][j-1];//求前缀和
    for(int i=1;i<=m;i++)//枚举矩阵的长
    {
        if(m%i!=0)continue;//保证面积为m
        int j=m/i;//求出矩阵的宽
        for(int x=1;x+i-1<=n;x++)//枚举矩阵左上角坐标
            for(int y=1;y+j-1<=n;y++)
                ans=min(ans,s[x+i-1][y+j-1]-s[x-1][y+j-1]-s[x+i-1][y-1]+s[x-1][y-1]);//求最小值
    }
    cout<<ans<<endl;//输出
    return 0;
}


```
