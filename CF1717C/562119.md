# CF1717C 题解
## 题意
有两个长为 $n(n\le 2\times 10^5)$ 的序列 $a,b$，你可以对 $a$ 进行以下操作：
- 对于 $a_i(i<n)$，如果 $a_i\le a_{i+1}$，那么可以给 $a_i$ 加一；
- 对于 $a_i(i=n)$，如果 $a_n\le a_1$，那么可以给 $a_n$ 加一。

请问是否可以通过若干次操作，使得 $a$ 变为 $b$。
## 分析
对于这种 CF 题目，一看就是贪心。

我们一般通过某些条件判断 $a_i$ 是否合法。

---
首先有一个显然的性质：

当 $a_i>b_i$ 的时候，一定非法（因为所有操作一定是只加不减）。

接着，对于所有的 $a_i$，如果 $a_i=b_i$，那就没有必要考虑了。

那么现在就只剩 $a_i<b_i$ 的情况了。

我们观察样例，注意到如果要使 $a_i$ 变为 $b_i$，那么 $a_{i+1}$ 必须 $\ge b_i-1$，此时的它可以作为一个跳板，帮助 $a_i$ 变为合法。

问题来了：但是 $a_i$ 是由 $a_{i+1}$ 确定的，而 $a_{i+1}$ 是由 $a_{i+2}$ 确定的啊！

这就成了一个循环，似乎没有什么好的办法。

但是不要忘了，我们刚刚的性质：$a_{i+1}$ 仍然是被 $b_{i+1}$ 限制着的。

那就没有问题了：如果 $b_i>b_{i+1}+1$，那么不行，因为此时如果要使得 $a_i$ 合法，$a_{i+1}$ 至少要为 $b_i-1$。但是 $a_{i+1}$ 不可以 $>b_{i+1}$，所以不合法。

结束了。
## 实现
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 2e5 + 7;
int a[N],b[N];
void solve(){
	int n;cin>>n;
	for(int i=1;i<=n;++i) cin>>a[i];
	for(int i=1;i<=n;++i) cin>>b[i];
	b[n+1] = b[1];
	for(int i=1;i<=n;++i){
		if(a[i]>b[i]||(b[i]>b[i+1]+1 && a[i]!=b[i])){
			cout<<"NO\n";
			return;
		}
	}
	cout<<"YES\n";
}
signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	int T;cin>>T;
	while(T--) solve();
	return 0;
}
```
## 总结
- 我们遇到这种一眼贪心题时，要将性质列出来，然后通过性质去判断是否合法。
- 一般来说这种题目 $a_i$ 可以独立判断是否合法，即可以找到一个 $O(1)$ 的方法（条件）判断 $a_i$ 是否合法。
- CSP 2022 rp++！
