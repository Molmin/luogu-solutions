# 0x00 思路
   发现题解里大家的思路都是将盒子固定移动唱片。那么我们不妨再想一想：能否固定唱片去找盒子？答案是可以的。我们可以用数组去存储这个唱片所放的盒子，然后就可以直接交换，操作起来也不是很难，只不过最后需要来查找盒子，从第 $0$ 个唱片开始（注意这里不是 $1$ 哦！），那么最后输出的时候我们所用的时间复杂度是 $O(n^2)$。
# code
```c
#include<bits/stdc++.h>
using namespace std;
int a[105];//唱片
int main()
{
	int n,m,i,c,now=0,j;
   	scanf("%d %d",&n,&m);
    for(i=1;i<=n;i++)//每个唱片都在自己的盒子里
        a[i]=i;
    for(i=1;i<=m;i++)//换盒子
    {
    	scanf("%d",&c);
    	a[now]=a[c];//把即将播放的唱片c的盒子给现在正在播放的唱片now。
      	a[c]=0,now=c;//现在唱片c没有盒子，且正在播放
     }
     for(i=1;i<=n;i++)
     	for(j=0;j<=n;j++)
     		if(a[j]==i)//唱片j在第i个盒子里
         		printf("%d\n",j);
    return 0;
}
 ```