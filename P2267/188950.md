对于读入的数据，因为没有给出颜色的取值范围，保险起见必须使用 $\texttt{long long}$ 保存，这是前提；之后对颜色进行离散化，映射到 $[1, n]$ 区间，不多解释。

重点放在如何计算方案上。可以发现，在任意一条合法的项链末尾添加上新的珍珠，就能够产生新的项链。很容易的想到以当前位置 $x$ 作为动态规划的阶段。设 $f(x)$ 表示当前位置为 $x$ 时，能产生的所有新项链的总和，那么状态转移不难写出：因为是**从左到右**选（不允许回头选），所以 $f(x)$ 的值应当是从 $x+1$ 开始到 $n$ 所有状态的总和，即

$$f(x)=\sum_{i=x+1}^{n}(f(i)+\Delta(i))$$

在方程中引入了一个 $\Delta(i)$ 作为修正。之所以要修正，是因为**不允许出现重复项链**。假设当前 $i=p$，设珍珠颜色为 $a_p$，如果能找到一个 $q \in [x + 1, p - 1]$ 使得 $a_q=a_p$，那么此时若再加上 $f(p)$ 就会产生重复，因为在 $p$ 之后产生的所有项链**肯定可以**在 $q$ 产生的项链中找到。

如下图：


![](http://39.106.8.172:4080/get_image?pic=b364761ef85798125f31e067687491d4)

此时在 $x$ 和 $p$ 之间存在了 $a_q=a_p$，此时，由于在 $p$ 之后的所有珍珠都肯定在 $q$ 之后，而 $q$ 会比 $q$ 先计算到，因此若在存在 $q$ 的情况下仍然计算 $p$ 就会导致重复计算。所以，我们需要在计算 $f(x)$ 时，**保存前面所遇到的所有珍珠颜色**，若产生重复则不转移，也就是说：

$$f(x)=\sum_{i=x+1}^{n}
\begin{cases}
0 && (a_i \text{ 出现过})\\
f(i) && (a_i \text{ 未出现过})\\
\end{cases}
$$

当 $x=1$ 时，说明计算到了边界，此时应当返回 $1$ 表示找到了一种合法的项链。依此，可以写出一个记忆化搜索的主程序如下：

```
int dp(int loc) {
	if(f[loc]) return f[loc];
	if(loc == n + 1) { // 边界 
		return 1;
	}
	set<int> vis; 
	int ret = 0;
	for(int i = loc + 1; i <= n + 1; i++) {
		if(!vis.count(colour[i])) { // 没有出现过 
			vis.insert(colour[i]);
			ret += dp(i) % m, ret %= m; // 往下计算 
		}
	}
	return f[loc] = ret % m;
}
```

这个程序的时间复杂度是 $O(n^2 \log n)$，会超时，因此需要对它进行优化。

思考：如果已知 $f(x-1)$，且 $x$ 的颜色在 $1$ 至 $x-1$ 中均未出现过，那么 $f(x)$ 能不能计算呢？答案是肯定的。考虑 $f(x)$ 如何从 $f(x-1)$ 计算得来：

1. 可以在所有 $x-1$ 能产生的项链之后**额外加上一颗珍珠**，所以会新产生 $f(x-1)$ 条；

2. 可以只选现在的第 $x$ 颗，这样还会新产生 $1$ 条。

综上，$f(x)=2f(x-1)+1$。

这是**没有重复的情况**，如果加入包含重复的情况呢？假设现在有 $a_x=a_p$，
对于 $1$ 到 $p-1$ 之间的**所有**项链，在后面加上一颗颜色为 $a_x$ 的珍珠都是没有必要的，因为已经加过 $p$ 了，与 $p$ 颜色相同的 $x$ **对答案没有贡献**。也就是说，$p$ 珍珠对**之前所有珍珠**的贡献此时**不应该被计入**，则多计算出的数量为 $f(p-1)$。

那么，难道每个 $f(p)$ 都要计算一次吗？其实不是的，因为 $f(p)$ 已经包含了 $p$ 之前所有和 $x$ 颜色相同的珍珠所多产生的项链数量，所以不需要作额外的扣除。我们需要的 $p$ 是**离** $x$ **最近的那个** $p$，也就是**最近一次** $a_x$ 出现的位置，这可以用一个变量保存。

做到这里，已经不需要采取记忆化搜索了，可以使用递推的方式计算。

```
#include <bits/stdc++.h>

using namespace std;
#define int long long

const int maxn = 500000 + 5;

int n, m;
int p[maxn];
int f[maxn];
int a[maxn];

void dp() {
	for(int i = 1; i <= n; i++) {
		f[i] = f[i - 1] * 2, f[i] %= m; // 先 * 2
		if(!p[a[i]]) f[i]++, f[i] %= m; // 之前没有出现过，为 * 2 + 1
		else f[i] -= f[p[a[i]] - 1] % m, f[i] %= m; // 之前出现过了，不能 +1，而且要扣除 f[p - 1]
		p[a[i]] = i;
	}
}

int t[maxn];
signed main() {
	cin >> n >> m;
	for(int i = 1; i <= n; i++) cin >> a[i], t[i] = a[i];
	sort(t + 1, t + 1 + n);
	int cnt = unique(t + 1, t + 1 + n) - t - 1;
	for(int i = 1; i <= n; i++) a[i] = lower_bound(t + 1, t + cnt + 1, a[i]) - t; // 离散化，不多解释
	dp();
	cout << (f[n] + m) % m;
	return 0;
}
```

最后需要注意的是，如果计算过程中出现了减法，那么最终答案注意要转化为正数。