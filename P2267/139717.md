# 考虑dp

### **令f [ i ]为：**
## ****以第i个颜色为结尾的方案数****


在一个完整的项链后**加上不同的珠子可以形成新的项链**

考虑以第i个珠子为结尾的项链对后面的珠子所做的贡献

容易知道，以第i个珠子为结尾的项链，会对其后面所有数字第一次出现的位置作出贡献



------------


**举个栗子：**

例如：序列为　１、２、１、２、３、２

以第２个珠子为结尾形成的项链(1、2)和(2)
会对第３、４、５个珠子造成贡献，却不会对第６个珠子造成贡献，因为２不是第一次出现


------------
```
令col[p]表示第p个珠子的颜色
```
------------


### 则动态转移方程可以写作：
```cpp
for(int j=i+1;j<=n;j++){
    if(col[j]相对第i个珠子而言第一次出现)
        f[j]+=f[i];
}
```

------------
### 反过来讲，动态转移方程也可以写作：
```cpp
for(int j=1;j<=i;j++){
    if(col[i]相对第j个珠子而言第一次出现)
        f[i]+=f[j];
}
```
------------
```
假设第i个珠子前，有最近的p,使得col[p]==col[i]，
则p之前的项链已经对p作出了贡献，就不会对i再作贡献
```
**举个栗子：**

例如：序列为　１、２、１、２、３、２

以第３个珠子及之前的珠子为结尾的项链，可以加上第４个珠子出现新的项链，但却不会对第６个珠子作出贡献

------------

### 所以，动态转移方程可以写作：
```
for(int j=上一次col[i]出现的位置＋１；j<i;j++)
    f[i]+=f[j];
```
------------
### 于是问题变成了快速找前面第一个相同颜色的珠子和区间加

### 自然的想到前向星和树状数组

------------
## 前向星：
```
令head[p]表示颜色为p的珠子最后出现的位置
令next[q]表示在第q个珠子前最近的相同颜色的珠子
扫一遍序列，有：
for(int i=1;i<=n;i++){
    next[i]=head[col[i]];
    head[col[i]]=i;
}
```
------------
## 树状数组不再赘述

当然前缀和可以更优秀的解决问题，但我更喜欢树状数组，虽然凭空加了一个log

------------
## 核心代码如下：
```
for(int i=1;i<=n;i++){
    if(nex[i]) f[i]=(sum(i-1)-sum(nex[i]-1))%m;
    else f[i]=(1+sum(i-1))%m;
    add(i,f[i]);
}
```

------------

## 温馨提示：
１、由于不知道表示颜色的数有多大，所以需要开long long

２、由于不知道表示颜色的数有多大，所以需要离散化