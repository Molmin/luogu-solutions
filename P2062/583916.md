# 思路
### [题链](https://www.luogu.com.cn/problem/P2062)
这题刚看到确实很容易想到贪心。

因为题目要求将分出的队伍数最大化,所以我们可以将所有人的要求进行降序排序。

为什么可行？

无论如何，一个需求较大的人的的要求肯定是会被满足的，而进行排序后，如果我们根据当前处理的人要求进行处理下标的跳跃（当前下标加上此人要求数），那么那些被跳跃过的人的要求就也一定会被满足，从而最优。

例：
```cpp
5
2 3 4 1 4
```
对于这组样例,降序排序后为
```cpp
5
4 4 3 2 1
```
按照上述的贪心思路，初始时下标为 $1$ ，第一个人要求为 $4$ ，则将下标调至 $5$ ，发现结果为 $2$ ，即正解。

在正常的跳跃结束后，如果剩下的人数不为 $0$ ，队数自增 $1$ ，为什么可以这样？

人数不为 $0$ ，说明还可以进行分队,所以队数自增 $1$ 。

那剩下的人数已经不足以进行跳跃了呢？

因为之前我们的分队已经最优了,所以可以将当前要求不被满足的人放到之前的队伍里去，下标超过总人数则退出。

但打完贪心后你会发现前两个点会被卡掉，于是开始排错。

在分队过程中，应将要求为 $1$ 的人自己和自己一队。

为什么可以这样？

题目中说保证数据一定有解，所以当我们将要求为一的从所有人当中去掉时，剩下的人即使无法满足要求也可以忽略不计。

将这些要求为一的人的要求修改为 $0$ ，并在我们记录剩余人数和记录退出条件（初始为总人数）的变量中减去 $1$ 。

在遍历处理中，如果发现要求为 $0$ 的人（即在输入处理前要求为 $1$ 的人），应直接结束遍历，避免后面进行了无意义的运算。

经过这一番修改，此时的贪心就完全正确了。

上正解！ヾ(≧▽≦*)o

# code
```cpp
#include<bits/stdc++.h>
#define maxn 10000005 //宏定义
using namespace std;
int n,v,person,sum,num=1;
int a[maxn];
int main () {
    cin >>n;
    person=n;
    v=n;
    memset(a,101,sizeof(a));
    //填充不为0的数
    for(int i=1;i<=n;i++){
        cin >>a[i];
        if(a[i]==1){
            sum++;
            a[i]=0;
            v--;person--;
        }
    }
    sort(a+1,a+1+n,greater<int>());
    //降序排序 用 greater<int>() 代替自定义一个 cmp 函数
    for(register int i=1;i<=n;i++){ //寄存器省时间
        if(!a[num]) break;
        person-=a[num];
        num=num+a[num];//正常跳跃
        if(person>=0) sum++;//剩下的人数>=0 
        if(num>v||!a[num]) break;
        //重点！
        while(a[num]>person) {
            num++; 
            if(num>v) break;
            person-=1;
        }//不满足要求时的跳跃
    }
    cout <<sum;//输出答案
    return 0;//蕐骊的结束
}
```
最后安利一下我的[博客](https://www.luogu.com.cn/blog/cjiajia2233/)
