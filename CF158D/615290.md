## 题目分析

原题面很长，整整有 14 行的英文，但说到底就是：圆周上有 $n$ 个点，取其中任意个点围成一个点权和最大的正多边形。

由于题目要求的是正多边形，这就意味着所选的点需等距，且点的个数是 $n$ 的因子。而圆周上的每个点等距，所以所选的点的编号等差。

由此，可以非常容易地想到直接枚举 $n$ 的因子，然后再依次枚举多边形的其中一个顶点，最后枚举多边形上的所有点并累加求最值。

除此之外，还需要注意以下两点：

- 为了减小时间复杂度，在举 $n$ 的因子时，需要成对枚举，将单层循环的复杂度由 $O(n)$ 优化到 $O(\sqrt n)$；~~（是个人都想得到）~~

- 由于不会出现正 1 边形和正 2 边形，所以 1 和 2 不能作为边数。

## 参考代码

本人的代码非常精简，欢迎借(chao)鉴(xi)。

```cpp
#include<bits/stdc++.h>
#define ll long long//祖传开ll（虽然本题可以不开）
using namespace std;
ll n,s,t,a[20005],i,j;
void work(ll x,ll y){//枚举以x为间隔，y为编号最小的点的多边形的点权和
	ll t=0,i;
	for(i=y;i<n;i+=x)t+=a[i];
	s=max(s,t);
}
int main(){
	ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
	cin>>n;
	for(i=0;i<n;i++){cin>>a[i];s+=a[i];}//读入+初始化最值
	if(n%2==0&&n!=4)work(2,0),work(2,1);//判断n能被2整除的情况
	for(i=3;i*i<=n;i++)if(n%i==0){//枚举n的因子
		for(j=0;j<i;j++)work(i,j);
		for(j=0;j<n/i;j++)work(n/i,j);
	}
	cout<<s<<"\n";
}
```