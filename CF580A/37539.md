本题要求最长不下降**子段**（要求连续）

因此可以只用一个循环，在输入同时判断，压缩时间复杂度

判断第i个数时只用关注它是否大于第i-1个数，用一个tmp存当前不下降子段长度

如果num[i]>=num[i-1]那么长度加一，否则这个子段已经结束，判断是否大于当前最长长度，再将其清零

因为只用看num[i]和num[i-1]的大小关系，判断当前不下降子段是否结束，所以用一个有两个元素的数组即可，每次把后一个数前移为前一个数，再输入新的数，压缩空间复杂度

在循环后面还要判断一次当前不下降子段长度是否大于当前最长长度，原因见样例二（即最长不下降子段位于整个数组的最后）

下面就可以上代码（很短）

```cpp
#include<bits/stdc++.h>
using namespace std;
int num[2],n;//num存上一个和当前数，n存元素数量
int maxl=0;//最长长度
int main(){
    cin>>n;
    int tmp=0;//当前长度
    //num[0]=0;可以不要因为初始值为零且数据保证每个元素都≥1
    for(int i=1;i<=n;++i){
        cin>>num[1];//输入新元素
        if(num[1]>=num[0]){//当前不下降子段未结束
            ++tmp;
        }else{
            maxl=max(tmp,maxl);//取最长长度
            tmp=1;//tmp=1因为长度要算上当前数
        }
        num[0]=num[1];//新的数前移，准备输入下一个
    }
    maxl=max(tmp,maxl);//这个必要
    cout<<maxl;
    return 0;
}
```