### 题意简述
有一列有 $n$ 节车厢组成的火车，车厢的编号由 $1$ 到 $n$ 排列。每次操作把这列火车中的一节车厢移动到这列火车的开头或结尾。求让火车车厢编号从小到大排列的最小操作次数。
### 题目分析
这道题要使用动态规划算法。

为了让移动尽可能少，我们就要让不需移动的车厢尽可能多。不难发现，不需移动的车厢数就是车厢编号的最长上升子序列的长度。

因为车厢编号都是由 $1$ 到 $n$ 排列的，所以动态规划的状态转移方程为 $f_p=f_{p-1}+1$，$f_i$ 表示以 $i$ 为结尾的最长上升子序列的长度，边界条件为 $f_1=1$。

令车厢编号的最长上升子序列的长度为 $maxn$，那么 $maxn=\max(f_i)$。最后计算出需要移动的车厢数，也就是 $n-maxn$。
### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+10;
int f[N];
int main(){
	int n;
	int maxn=0;//最长上升子序列的长度
	cin>>n;
	for(int i=1;i<=n;i++){
		int p;
		cin>>p;
		if(p==1){
			f[1]=1;//边界条件，以1为结尾的最长上升子序列的长度为1 
		}
		else{
			f[p]=f[p-1]+1;//转移方程，以p-1为结尾的最长上升子序列的长度加上1就是p的最长上升子序列的长度
		}
		maxn=max(maxn,f[p]);//更新最长上升子序列的长度
	}
	int ans=n-maxn;//求出最小操作次数 
	cout<<ans;
}
```