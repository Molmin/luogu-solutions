**题意**


一个数组的元素为1至N的整数，现在要对这个数组进行排序，在排序时只能将元素放在数组的头部或尾部，问至少需要移动多少个数字，才能完成整个排序过程？


**输入**


第1行：1个数N(2 <= N <= 50000)。

第2 - N + 1行：每行1个数，对应排列中的元素。


**输出**


输出1个数，对应所需的最少移动次数。


**算法**


我们先不管初始序列，先看结果：一个1..n的整数序列，相邻的项差为1。


再看原序列，我们发现在此之中一开始就满足以上条件的子序列不需要移动，于是可以转化为类似最长上升子序列的模型，答案即为（总长度-最长序列的长度）。


但是n^2的时间复杂度还是难以承受，我们发现每次我们只是为了找上一个自然数，却花了O(n)的时间，再观察n最大只有50000，于是想到用桶标记，然后就愉快的AC了。  (￣▽￣)~\*


以下为代码：

```cpp
#include<cstdio>
int n,a,ans,f[500001];
int main(){
    scanf("%d",&n);
    for(int i=0;i<n;i++){
        scanf("%d",&a);
        f[a]=f[a-1]+1;
        if(f[a]>ans)ans=f[a];
    }
    printf("%d",n-ans);
}
```