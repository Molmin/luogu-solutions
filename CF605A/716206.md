### 题意：

有一个长度为 $n$ 的序列是 $1$ 到 $n$ 的任意顺序 **排列**。定义一次操作可以将任意一个数移到排列最前或最后，问至少多少次操作可以使得它变成一个 **严格单调递增的$1$到$n$的排列**。

### 思路：

根据样例，可以发现每一次 **最优** 操作都是把那些插在 **最长上升子序列（此处要求元素之差正好为1）** 中的所有数都移到排列的头或尾。小就移到头，大就移到尾。所以，我们可以采用 $dp$ 思想，开一个长度为 $n$ 的桶，$dp_{i}$ 表示最后一个元素为 $i$ 的 **最长上升子序列** 的长度。每一次输入第 $i$ 元素，以它为最后一个元素的最长上升子序列的长度，就是 $dp_{i-1}+1$，表示是它前一个比它小 $1$ 的最长上升相差为 $1$ 子序列的长度加一，因为加入了 $i$ 这个元素。每一次循环同时更新答案，取最长的满足要求的子序列。最后的答案就是 $n-len$，因为中间那些连不上的元素总能前移或后移达到目的。

不懂可以回复。

### 代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
inline int read()
{
	int x=0,f=1;char c=getchar();
	while(!isdigit(c)){if(c=='-')f=-1;c=getchar();}
	while(isdigit(c)){x=x*10+c-48;c=getchar();}
	return x*f;
}
const int MAX=1e5+5;
int n,x,dp[MAX],ans=-1;
int main()
{
	n=read();
	for(int i=1;i<=n;i++) {
		x=read();
		dp[x]=dp[x-1]+1;
		ans=max(ans,dp[x]);
	}
	cout<<n-ans;
	return 0;
}
```