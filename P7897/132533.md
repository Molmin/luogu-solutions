吐了，原来被卡负数向下取整都没看出来。             

其实不是 Ynoi 里一道很难的题，不过还是有可以学习的地方。         

先考虑一下 $O(nm)$ 的暴力，就是选或不选一个子树然后 dp 转移就好了，接着考虑一下这个查询本身的性质。          

我们不妨固定 $u$ 后改变 $x$，观察到比如 $x$ 很小的时候其实答案就是这个节点本身，当 $x$ 逐渐变大时就会有节点跟着加入答案集合，并且如果 $x$ 不减小那么这个节点也不可能离开答案集合。            

考虑还是用类似 dp 的思想，记 $dp_{x,y}$ 为当全局加的值为 $y$ 时 $x$ 向下的最大路径和，不难发现若 $0 \leq dp_{x,y}$，我们的 $dp_{x,y}$ 的值就可以累加在 $dp_{fa_x,y}$ 上面并且对于任意的 $y \leq z$，$dp_{x,z}$ 都会向 $dp_{f,z}$ 贡献。           

这东西让你想到了什么？是不是~~并查集加边加边再加边~~，我们考虑用并查集去维护每个点的答案集合，枚举 $y$ 值不停合并父亲与儿子由于至多只会合并 $n - 1$ 次，所以至多有 $n-1$ 个临界点划分出了至多 $n$ 个值域段（也就是 $n$ 个合并出来的状态），将 $q$ 次询问根据其 $x$ 的值分别扔进对应值域段的合并状态里询问即可。           

优化这一过程。首先可以直接算值域的临界点，我们开一个优先队列维护存储当前仍还未合并至父亲节点的节点的 dp 值，显然一个点 $x$ 的 dp 值下一次变为大于等于 $0$ 的个数需要的 $y$ 值为 $\lceil \frac{-dp_x}{siz_x} \rceil$，这时下一个临界点的大小就应为这些节点计算出来 $y$ 值的最小值，从优先队列里面找到这个节点拿出来和父亲节点合并后再把相应的在这个值域段的查询拿出来问就好了。          

现在就只用考虑怎么在连通块里面维护答案。一个比较显然的是对于原树用 dfn 序标号后询问一个联通块内的点 dfn 标号在一个区间内的点值和与点值个数，然后直接线段树合并就可以回答了，但是这样有可能会被卡 T，所以我们换一个方法。                             

我们把区间 $[l,r]$ 的求解转化为对两个前缀 $[1,l-1]$ 和 $[1,r]$ 的求解。根据并查集的连接顺序建立 Kruscal 重构树，dfs 一遍 Kruscal 重构树后对叶子节点重新标号，这样可以保证叶子节点的标号连续。将相应的询问挂在 Kruscal 的非叶子节点上面后先把叶子节点的值清空。依次将 dfn 编号为 $1 \sim n$ 的节点重新加入就可以对应的把非叶子节点的询问转化为对一个叶子节点区间的查询，可以理解为离线两次询问吧，用树状数组维护可以得到一个常数比较优秀的时间 $O(n \log n)$ 做法。               

不过这样的做法还是有点复杂，不妨再稍挖掘一下性质。           

询问时先不考虑点 $u$ 的贡献，最后加上就好了。

我们在并查集合并的时候将深度深的点连向深度浅的点，顺便维护一下并查集里面所有节点值的和 $w$ 和节点个数。

假设节点 $x$ 和原树上的父亲 $fa_x$ 合并，找到连通块内深度最浅的点 $y$ 和父亲 $fa_y$，我们每次只用在 $dfn_{fa_x}$ 处差分加上 $w_x$，在 $dfn_{fa_y}$ 处差分减去 $w_x$ 就好了，查询时直接查点 $u$ 子树对应的 dfn 区间的和就好了，维护点数一个道理。

这么做的正确性基于分类讨论。

显然只有在点 $fa_x$ 和点 $y$ 之间链上的点执行询问时 $x$ 的 $w$ 才应该对其有贡献。      

如果点 $z$ 不在 $1 \sim fa_x$ 的链上，点 $z$ 的 dfn 区间 $[L,R]$ 肯定在区间 $[dfn_y,dfn_{fa_x}]$ 整体的左右两边亦或是中间，差分后肯定算不到。     

如果点 $z$ 在 $1 \sim fa_y$ 的链上，当前点 $z$ 的 dfn 区间 $[L,R]$ 肯定完全包含了区间 $[dfn_y,dfn_{fa_x}]$，也算不到。         

当点 $z$ 在 $y \sim fa_x$ 的链上时，点 $z$ 的 dfn 区间 $[L,R]$ 肯定包含了 $dfn_y$ 而不包含 $dfn_{fa_x}$，可以算到。           

这样差分的正确性就证明了。            

稍微有点啰嗦啊，毕竟这个题做法是很多，希望能看到 Ynoi 常数杀手能用线段树合并把这道题杀过去。             

不过开 $2$ 个 G 本身就是给线段树合并用的吧？不清楚。
 
以上做法的时间复杂度都是 $O((n+q) \log n)$，除线段树合并空间复杂度为 $O(n \log n)$ 以外空间复杂度均为 $O(n)$，本人代码写的是差分做法（毕竟好写很多）有需要者私信即可。