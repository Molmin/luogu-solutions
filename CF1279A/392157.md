## 1. 题意简述
多组询问，给定 $r$ 个字符 R，$g$ 个字符 G，$b$ 个字符 B，问是否存在一种方案，使得所有字符排列组成的字符串不存在两个相邻且相同的字符。能 输出“YES”（不输出引号），不能 输出“NO”（不输出引号）。

$1≤t≤100,1≤r,g,b≤10^9$
## 2. 题目简析
考点：数论

时间复杂度：$Θ(n)$

这道题较简单，但是要思考一会儿就可以做出来。

（分析开始）

我们先看一下能的方法：

4R 2G 2B（字符）
| R | G |R  | G | R | B | R |B|
| -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: |

4R 2G 1B（字符）
| R | G | R | G | R | B | R |
| -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: |


不能的方法：

4R 1G 1B（字符）
| R | G | R | B | R | x(不能填) |
| -----------: | -----------: | -----------: | -----------: | -----------: | -----------: |
5R 1G 1B（字符）
| R |G  |  R|  B|R  |x(不能填)  | R |
| -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: |


由此可以看出一个共性：

要分类讨论一下

总个数为奇数时：$r,g,b$中最大的$≤$剩下的两个+1 能

总个数为偶数时：$r,g,b$中最大的$≤$剩下的两个 能

（推理结束）

## 3. 主代码 和 简单讲解

```cpp
                int a[3];
                cin>>a[0]>>a[1]>>a[2];
		int zong;
		zong=a[0]+a[1]+a[2];
		sort(a,a+3);//sort排序，新手不建议选择
		if(zong%2==0){//判断奇偶
			if(a[2]<=a[1]+a[0]){//总个数为偶数时：r,g,b中最大的<=剩下的两个
				cout<<"Yes\n";//记得换行
			}
			else{
				cout<<"No\n";
			}
		}
		else{
			if(a[2]<=a[1]+a[0]+1){//总个数为奇数时：r,g,b中最大的<=剩下的两个+1
				cout<<"Yes\n";
			}
			else{
				cout<<"No\n";
			}
		}
```

## 4. 全代码
```cpp
#include <bits/stdc++.h>
using namespace std;
int main()
{
    int t,a[3];
    cin>>t;
    int i;
    for(i=1;i<=t;i++){
        cin>>a[0]>>a[1]>>a[2];
        int zong;
        zong=a[0]+a[1]+a[2];
        sort(a,a+3);
        if(zong%2==0){
            if(a[2]<=a[1]+a[0]){
                cout<<"Yes\n";
            }
            else{
                cout<<"No\n";
            }
        }
        else{
            if(a[2]<=a[1]+a[0]+1){
                cout<<"Yes\n";
            }
            else{
                cout<<"No\n";
            }
        }
    }
    return 0;
}
```

## 5. 小结

本题解使用C++，欢迎大佬指正！