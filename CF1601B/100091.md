# CF1601B 题解

看见大家貌似都用的 $O(nlogn)$ 做法，那我就来一发 $O(n)$ 且很好实现的做法吧.

题意：有两个序列 $a,b$ ，若在位置 $i$ ，则可以跳到 $x \in [i,i - a_i]$ 中的所有位置，

但每次跳到了某个位置 $j$ 后，会滑落到第 $j + b_j$ 个位置。

求初始在位置 $n$ ，目标在位置 $0$ 的最少跳跃次数，并给出方案。

做法：

我们发现，每次跳跃后滑落前可以到达的位置集合，必然是一个右端点为 $n$ 的区间。

这个结论可以用数学归纳法证明，即：

若上一次滑落前可以到达的位置集合是一个区间，我们记这个区间为 $[l,n]$。那么：

这一次跳跃后，不可能出现两个可以到达的位置 $x,y$ （不妨令 $x<y$），使得：

1. $x \notin [l,n]$
2. $y \notin [l,n]$
3. $y \neq x + 1$

口头上说就是：这次跳跃后，可以到达的且不在区间 $[l,n]$ 内的位置，必然形成一段连续区间。

而上一次滑落前可以到达的区间，这一次也都可以到达。

至于原因，是：设上一次滑落前，我们已经跳跃了 $s$ 次，

则对于 $\forall x \in [l,n]$，我们都有一种方案，使得从起点跳跃 $s$ 次后到达位置 $x$ 。

我们只需要在这个方案的开头添加一次原地跳，就可以构造出一种跳 $s+1$ 次后到达位置 $x$ 的方案。

这一定可行，因为题意保证 $b_n = 0$，我们第一次跳 $0$ 个位置，原地不动即可。

于是，我们将 $[l,n]$ 和新增区间拼在一起后，就形成了一个更大的区间，也证明了上面的结论。

所以，我们可以动态的维护上面 $[l,n]$ 里的 $l$，

具体来说，我们令 $c_i = i + b_i - a_{i + a_i}$，代表上一次滑落前到达位置 $i$ ，这次能到达的最小位置。

那么我们对序列 $c$ 做前缀最大值，同时记录最大值所在的位置，

即可求出，在某次跳跃后滑落前，可以到达的点集区间是 $[l,n]$ 时，下一次能跳到哪里。即：

设 $mx_i = max(mx_{i+1},c_i)$，$rs_i = p$，其中 $c_p = mx_i$。

于是，对于某次跳跃后滑落前，可达的点集区间 $[l,n]$，其下一次就可以到达区间 $[mx_l,n]$，

而在最优解中，当前这次跳跃所到达的位置就是 $rs_l$.

我们还可以发现，若上面的 $mx_l \geq l$ ，则我们不可能跳到顶点，因为我们就会卡在这里。

预处理是 $O(n)$ 的，而动态维护区间 $[l,n]$ 时，每一次 $l$ 必然减 $1$，直到减到 $0$，否则会输出无解，

故这样的时间复杂度是 $O(n)$ 的。

这里给出代码实现：

```
#define rep(i, a, b) for (int i = (a); i <= (b); i++)
#define per(i, a, b) for (int i = (a); i >= (b); i--)

const int N (3e5 + 10);
int n, a[N], b[N], c[N], rs[N], mn[N];
vector < int > ans;
 
int main() {
	n = read(); rep (i, 1, n) a[i] = read();
	rep (i, 1, n) b[i] = read(), c[i] = max(0, i + b[i] - a[i + b[i]]);
	rep (i, 0, n + 1) mn[i] = rs[i] = 1e9;
	per (i, n, 1) mn[i] = min (mn[i + 1], min(i, c[i])),
				  rs[i] = min (i, c[i]) < mn[i + 1] ? i : rs[i + 1];
	int hi = n;
	rep (i, 1, n) {
		ans.pb(hi = rs[hi]);
		if (hi <= mn[hi]) break;
		hi = mn[hi]; if (!hi) break;
	}
	if (hi) return cout << -1, 0;
	int sz = ans.size(); cout << sz << endl;
	rep (i, 1, sz - 1) cout << ans[i] << ' ';
	return cout << 0, 0;
}
```

