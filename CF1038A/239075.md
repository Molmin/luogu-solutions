- ###### [博客食用更佳](https://www.luogu.com.cn/blog/yx20070829/solution-cf1038a)
- 题目不难，掌握几个要点就可以了
  1. 子序列不一定连续的
      - 例如：ADBC的子序列也包括ABC
  2. 字母顺序不定
      - 例如：ABC和ACB是一样的
  3. 前k个字母数量相等
      - 例如：ACCBB就不可以当答案，而AACCBB可以
- 整体思路
  - 首先将前k个字母出现次数记下来（在k个之外的就没有意义了，所以不用记）
  - 接着用sort排序，这里要注意排序范围，**目的是让前k个字母出现次数最少的排在最前面**，这样~~就能减少代码长度~~不用遍历取min了
- 最后放一下AC代码

```cpp
#include<bits/stdc++.h>//懒人万能库
using namespace std;
int n,k,f[27];//分别为题目中的n、k，最后一个为存字母数量的数组
string s;//读入的字符串 
int main()
{
	scanf("%d%d",&n,&k);//读入
	cin>>s;//读入
	for(int i=0;i<n;i++)//统计字母数量
	{
		if(s[i]-'A'+1<=k)f[s[i]-'A'+1]++;//超过k的不统计，这里下标从1开始
	}
	sort(f+1,f+1+k);//排序，注意区间不要超过k（下标1开始）
	printf("%d",f[1]*k);//最后输出出现次数最小的字母并乘以k，不难理解
	return 0;
}
```
