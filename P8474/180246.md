## 思路
首先肯定能想到暴力，但是仔细想想就会发现，暴力绝对会超时。（废话）

那么接下来怎么才能得到正确答案呢？根据我的经验，像这种输入一个正整数，输出另一个正整数，满足一一映射关系的题目，大部分都能 **找规律** 。当我们按字典序将 $1 \sim n$ 的所有排列写出后，手动（当然也可以写个程序帮你）算出他们逆序对的个数，就能发现规律啦！  

下面简单列举几个：

| $n$ |字典序排列的逆序对个数  | 答案|
| :----------: | :----------: | :----------: |
| $1$ | **0** | $1$ |
| $2$ | **0**,$\color{red}\text{1}$ | $1+1\times2=3$ |
| $3$ | **0,1**,$\color{red}\text{1,2}$,$\color{blue}\text{2,3}$ | $3+3\times2+3\times4=21$|
| $4$ | **0,1,1,2,2,3**,$\color{red}\text{1,2,2,3,3,4}$,$\color{blue}\text{2,3,3,4,4,5}$,$\color{gold}\text{3,4,4,5,5,6}$|$21+21\times2+21\times4+21\times8 =315$
|...| ...|...|

可以看出，每个数的逆序对个数的排列符合一个规律。每个序列最前面黑色的部分就是 $n-1$ 逆序对数量的序列，之后每一个不同的颜色都是最开始的黑色序列中所有数加一，如果把它们变成 $2$ 的指数就是直接将上一个颜色序列的结果乘二。
## 代码
规律知道了，接下来就是愉快的写代码时间啦。
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
int dp[10000010];	//记录每个n的答案
signed main()
{
	int n,s=1,t=1;	//s和t是记录该乘的数字
	cin>>n;
	dp[1]=1;	//显然，当n=1，答案就为1
	for(int i=2;i<=n;i++){
		t=t*2;	//每循环一次，就会比n-1多出一个颜色，t乘二
		s=s+t;	//s累加上所有的t，就是总共要乘的数了
		dp[i]=dp[i-1]*s;
	}
	cout<<dp[n];	//最后只要输出dp[n]
	return 0;
}
```
最后别忘了取模，为了看得清楚，代码里没有取模。