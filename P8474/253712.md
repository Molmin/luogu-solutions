## 题意概述

给定正整数 $n$，设 $\sigma$ 为长度为 $n$ 的排列，$\tau(\sigma)$ 为 $\sigma$ 的逆序对数。

求：

$$\sum_{\sigma} 2^{\tau(\sigma)} \bmod (10^9+7)$$

$(1 \leq n \leq 10^7)$

---

## 思路

Tips: 
1. 本题解未使用 OEIS 等科技支援。

2. 跳过 Subtask 3 内容不会影响 Subtask 4~5 内容的阅读体验。

对于这类计数题，我们不妨先从小数据开始，手动推导答案，寻找规律。

按照字典序在草稿纸上枚举：

当 $n=3$ 时，$\tau(\sigma)$ 序列为：$\{ 0,1,1,2,2,3 \}$;

当 $n=4$ 时，$\tau(\sigma)$ 序列为：$\{ 0,1,1,2,2,3,1,2,2,3,3,4,2,3,3,4,4,5,3,4,4,5,5,6 \}$.

### Subtask 1~2

记 $n=i$ 时，$\tau(\sigma)$ 序列为 $A(i)$，$A(i)+j$ 意为 $A(i)$ 序列每个元素加上 $j$ 得到的新序列。

按照规律，应该有 $A(i)= \{ A(i-1),A(i-1)+1,\cdots,A(i-1)+i-1 \}$.

这个规律由字典序的性质得来，其实就是确定第一关键字后剩下的序列可以对应到长度减一的序列，序列元素加上多少取决于第一关键字的大小，所以它是正确的。

记 $\large f_i$ 为 $\tau(\sigma)=i$ 对应的排列个数，我们可以利用上面的规律快速求出 $n$ 较小时的 $f$ 。

当 $n=1$ 时，$f_0=1$;

当 $n=2$ 时，$f_0=1,f_1=1$;

当 $n=3$ 时，$f_0=1,f_1=2,f_2=2,f_3=1$;

当 $n=4$ 时，$f_0=1,f_1=3,f_2=5,f_3=6,f_4=5,f_5=3,f_6=1$.

它是 $\mathcal{O}(n!)$ 的，只能通过 Subtask 1~2，并且代码实现相对繁琐，更适合配合计算技巧加快人工计算，但它打出的小表以及背后的规律，对我们很有意义。

---

### Subtask 3

观察上面的 $f$ ，这种对称结构很容易让我们联想到杨辉三角，但貌似它和组合数沾不上什么边。

再想想，杨辉三角有一个特别的递推式：$\large \binom{i}{j}=\binom{i-1}{j}+\binom{i-1}{j-1}$.

这个 $f$ 有没有类似的递推式呢？

因为不同 $n$ 对应的 $f_i$ 不同，所以我们不妨把 $n$ 也作为 $f$ 的一维，观察能否递推。

设 $f_{i,j}$ 为 $n=i$ 时 $\tau(\sigma)=j$ 对应的排列个数。（注意：$i$ 的意义与前文不同，$j$ 继承前文 $i$ 的意义。）

对于第 $i$ 层，其有 $\frac{i \cdot (i-1)}{2}+1$ 个元素（那个 $+1$ 就是 $j=0$ 的情况），前 $\frac{(i-1) \cdot (i-2)}{2}$ 个元素满足 $f_{i,j}=f_{i,j-1}+f_{i-1.j}$.

那后面的元素呢？直接对折过去么？

不难发现，按照这个递推式，第 $i$ 层已递推出的元素是单调的。

而当 $i>5$ 时，已递推的元素将越过这层的中间元素，后面这部分元素，被递推与对折得到的答案是不同的，所以这个算法是错误的。

那如果，我们只递推到对应层的中间元素，然后就对折呢？

我们试着这样递推出第 $5$ 层，就会发现这些元素之和超过了 $5!$，显然有误。

这样想来，可能是我们的递推式缺少一个减去的项？

目光回到 $f$ 的第 4 层：$f_{4,3}=6,f_{4,4}=5,f_{4,5}=3,f_{4,6}=1$.

逐位做差，得到：

$f_{4,4}-f_{4,3}=1=f_{3,0}$;

$f_{4,5}-f_{4,4}=2=f_{3,1}$;

$f_{4,6}-f_{4,5}=2=f_{3,2}$.

这是巧合么？不妨试试。

$$ f_{i,j}=f_{i,j-1}+f_{i-1,j}-f_{i-1,j-i} $$

用这个式子去递推第 5 层，得到序列：$\{ 1,4,9,15,20,22,20,15,9,4,1 \}$。

如果你用前面通过字典序得到的规律推出了第 5 层，你就能确定这个序列是正确的；没有的话，将它们求和，答案恰好为 $5!$，继续递推更高层验证，依然吻合，我们可以确信这个递推式的正确性了。

按照上面的式子递推，时间复杂度为 $\mathcal{O}(n^3)$。

可以用滚动数组优化空间，但无论优化与否它都只能通过 Subtask 1~3。

---

### Subtask 4~5

对于善用数学归纳法的同学，通过 $\mathcal{O}(n!)$ 或是 $\mathcal{O}(n^3)$ 的算法，抑或是利用性质人工计算，我们都可以得出规模可观的答案了，我们不妨直接开始从答案上寻找规律。

推出未取模的答案，发现答案相差较远，但位数相差稳定在 2 到 3 位，考虑将相邻答案作商。

作商后，我们得到序列：$\{ 1,3,7,15,31,63,127,\cdots \}$，不难看出规律：下一位是上一位的二倍加一。

于是我们大胆写出递推式：

$$f_1=g_0=1$$

$$g_{i+1}=2 \cdot g_{i} \bmod (10^9+7)$$

$$f_{i+1}=f_i \cdot g_i \bmod (10^9+7)$$

比较谨慎的同学可以跟 $\mathcal{O}(n^3)$ 的算法对拍几组数据。

提交后便可喜提 AC。

为什么是正确的呢？

看看我们的 $g$ 序列，它有没有另一种表达形式呢？

有：$g_i=2^i-1=\sum_{j=1}^i 2^{j-1}$

不知道屏幕前的你是否还记得这句话：

> 这个规律由字典序的性质得来，其实就是确定第一关键字后剩下的序列可以对应到长度减一的序列，序列元素加上多少取决于第一关键字的大小，所以它是正确的。

回想 Subtask 1~2 中我们定义的 $A(i)+j$，其实我们的 $g$ 序列，就是这个 "$+j$" 在答案上的投影，就是确定的第一关键字带来的贡献。

---

## Code

```cpp
#include <cstdio>
#define int long long
#define MAXN (int)(1e7+233)
#define rep(i,l,r) for (int i=l;i<=r;i++)

const int mod=1e9+7;
int n,f[MAXN],g[MAXN];

signed main()
{
	scanf("%d",&n);
	f[1]=g[0]=1;
	rep(i,1,n-1)
		g[i]=((g[i-1]<<1)+1)%mod,
		f[i+1]=f[i]*g[i]%mod;
	printf("%lld",f[n]);
	return 0;
} 
```


---

## 后记

旧序列加上第一关键字，得到新序列，这就是最为核心的思路。DP都是如此，简练的状态划分（通常从数据范围入手，是时空复杂度的主要瓶颈），加上精巧的状态转移（为了达到精巧，这一步有时需要用倍增，数据结构，单调性等优化，也可能成为时空复杂度的瓶颈），从初始状态步步拓展，最终方能优雅地得到答案。

愿 AC 这题后，带给你的不仅有通过题目数的增长，还有对算法更深刻的认识，还有何时乍现的灵光，还有对从现在步步拓展更加坚定的信念，还有未来那个优雅得到答案的你。