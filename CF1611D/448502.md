这个题是一道**阅读理解题**，首先要读懂题目要求。

## 题目大意：

用数组 tree 来表示**树**，其中 $tree[i]$ 代表节点 i 的父节点。树的大小是 n .

给你一个大小也为 n 的全排列 p ，  $p[i]$ 顾名思义.

现在你的工作是赋予树上的每条边一个长度，使得树上所有节点**按照到根节点的长度排序**之后的结果与全排列 p 相同，做不到就输出 $-1$ .

## 思路分析：

现在我们知道，树上的点，和全排列是能够一一对应的，也就是说通过赋予每个边长度，让这棵树上所有点**按照**到根节点的距离**排序**之后的**顺序**是全排列 p 的顺序（还是那句话，阅读理解）.

那么我们不妨假设，全排列 p 中第 i 个点 $p[i]$ 到树根的距离就是 i ，以此为据，来推导出每个边应有的长度.

我们能够发现：根节点必须在全排列的第一位 $p[1]$ ，这是因为树上没有任何一个点，到根节点的距离比根节点自身到根节点的距离更小，排序完成之后根节点一定~~首当其冲~~.

所以倘若 $p[1] != root$ ，对不起，直接 $-1$，这个可以算是一个小小的特判吧，其实没有也行，但是它能够帮助我们更好地理解题意.

那么现在开始考虑普遍情况，对于排列 p 中第 $i$ 个元素，对应在树上也就是节点 $p[i]$ ，它到根节点的距离是 $i$ .

那么我们**可以肯定**的一点就是：

它的父节点 $tree[ p[i] ]$ 到根节点的距离必须得是已知的，而已知的就说明我们在 $p[i]$ 之前就求过它的距离，因为距离就等于 $i$ ，也就是说，他的**父节点到根节点的距离一定比当前节点小**，这不刚好就是树（没有负边）的性质吗！！

反过来想，如果它父节点还没被求出来，就说明它父节点一定在 $p[i]$  的后面出现，那么它的**父节点到树根的距离就一定比子节点大，这是不可能的**

所以，这是我们判断能否成功构建的依据.

如果在中途出现不满足上述约束的情况出现，就说明没办法构建.

在知到构建约束之后，构建方法会比较好想一些.

我们令 $tall[i]$ 代表节点 $i$ 到根节点的距离，用 $ans[i]$ 代表第 $i$ 个节点与其父节点之间的边的距离（即题目所求的答案）.

那么 $ans[i] = i- tall[ tree[ p[i] ] ]$ .

同时别忘了更新当前点到根节点的距离: $tall[ p[i] ]=i$ .

别嫌我罗嗦，这种思维偏重一点的题目，要讲就要讲得非常详细，因为哪怕有一点卡住，也没办法做.

## 上代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int t,n;
int tree[200005];//树上某个节点的父节点
int p[200005];//要求树按照距离树根的排列顺序
int tall[200005];//树上某个节点到根节点的距离
int ans[200005];//记录答案（边的长度）
int main()
{
    cin.sync_with_stdio(false);
    cin >> t;
    while(t--)
    {
        cin >> n;
        int root;
        for(int i=1;i<=n;i++)
        {
            cin >> tree[i];
            if(tree[i]==i) root=i;//寻找根节点
            tall[i]=-1;
        }
        for(int i=1;i<=n;i++) cin >> p[i];
        tall[root]=0;//根节点的距离是0
        ans[root]=0;
        if(p[1]!=root)//排列中的第一个点必然是root才行
        {
            cout << -1 << endl;
            continue;
        }
        bool flag=1;
        for(int i=2;i<=n;i++)//核心代码
        {
            if( tall[ tree[ p[i] ] ] <0 )//对于第i个排列来说，p[i] 的父节点必须比p[i]距离根要近，即在[1,i)中已经出现过才行，因为不可能做到父节点比子节点更远
            {
                flag=0;//出现矛盾
                break;
            }
            else
            {
                ans[ p[i] ] = i- tall[ tree[ p[i] ] ];//记录答案：假设第i个出现的点距离根节点的距离就是i，那么，这条边的长度就等于  i-父节点[ p[i] ] (即：i-tall[ tree[ p[i] ] ])
                tall[ p[i] ] =i;
            }
        }
        if(flag)
        {
            for(int i=1;i<=n;i++) cout << ans[ i ] << " ";
            cout << endl;
        }
        else
        {
            cout << -1 << endl;
        }
    }
    return 0;
}

```
