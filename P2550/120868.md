# 看到大佬们没有用STL的，在此安利一波STL吧。
一看到重复的问题，最先想到的就是set，**每一个号码互不相同，所以set是可以用的。**不难想到这个代码：
```cpp
#include <bits/stdc++.h>//万能头
using namespace std;
int pri[8],n,win[7];
//pri是每一种级别的获奖情况
//n是抽了多少号码
//win是中奖号码
set<int> num;//定义一个num集合
int main()
{
    cin>>n;
    for(int i=0;i<7;i++)
        cin>>win[i];//循环读入
    while(n--)
    //如果不需要用到这是第几轮并且以后不用到n
    //就可以不用for，直接while
    {
        num.clear();//清空set
        for(int i=0;i<7;i++)
        {
            num.insert(win[i]);
            int a;cin>>a;num.insert(a);
            //循环插入中奖号码
            //顺便把当前抽的号码也弄进去
        }
        pri[num.size()-7]++;//精华所在，一会讲
    }
    for(int i=0;i<7;i++)
        cout<<pri[i]<<" ";//循环输出
    return 0;//结束
}
```
这里面，我们用到了集合的互异性，如果真的完全互不相同，那么这些元素插入到集合中，首先是7个中奖号码，还有7个抽到的号码，一共就应该是14个数字。但是也有可能比较幸运，有相同的情况，那么，set集合的大小是多少，减去本来的7位之后，就是有多少个是一一对应不上的。有趣的是，我们可以发现有多少个一一对应不上的，就是几等奖。这样，代码就很好实现了。需要注意的是，pri的尺寸要开到8，否则遇到“七等奖”的情况会越界，当然，也可以特判七等奖。

其实，还有一个方法，就是一楼神犇的方法，不过如果每一个数字不是<33，而是<INT_MAX(2147483647)，那么空间会炸。这其实是桶计数的思想，这种桶，时间花费少，代码量也少，但是费空间，所以局限性很大。不过既然是<33，也可以这样，不得不说，这真是一个好方法。（在此膜拜神犇），另外，如果中奖号码或抽到的号码不一定互不相同，这两种方法都不可取。为什么？自己想想看吧~

好了，本篇题解到此结束，这是本蒟蒻的第三篇题解，求通过~

#### p.s.在讲神犇的方法时，我提到了<INT_MAX的问题，但是这种情况应该很少，如果真是那样，概率真的……顺便大家也可以通过此题练练古典概型，来看看，每一种奖概率分别是多少哦~