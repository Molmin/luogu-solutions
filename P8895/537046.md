[题目传送门](https://www.luogu.com.cn/problem/P8895)

## 简化题意

做题先简化一下题意。

给定 $n$ 个数，要求排序后满足该序列为先下降后上升（相邻两个不能相等），求总方案数。

## 正文部分

（表述或许不太对，请大佬指出）

首先，我们先找到最小值，显然最小值一定是转折点。由于不能相等，所以最小值只能有一个。否则答案为 $0$。

定好了最小值，然后考虑其他的数摆放的位置。例如样例 $1$，最小值为 $1$，那么我们先摆放 $1$：

$$[]\quad[]\cdots[1]\cdots[]\quad[]$$

首先 $3$ 只有一个，所以左右都能放。$2$ 有两个，只能一边放一个，否则同时放一边会使得他们相等。根据乘法原理，我们算得答案为 $2\times 1=2$。

修改了一次后，序列变成了 $1\ 2\ 4\ 3$。

这时，和我们上面的分析一样，我们知道 $2$、$3$、$4$，都只有一个，所以他们两边都可以放，那么就算得答案为 $2\times 2\times 2=8$。

仔细发现，这道题和数是多少没有关系，只和有几个相同的数有关系，所以我们考虑开一个桶来记录每个数的数量。

既然和数的数量有关系，那么数太多会有什么影响吗？

可以发现，当数量 $\ge 3$ 时，无论怎么摆放，两边都会有相同，这时答案也为 $0$。

于是，我们总结一下，可以得到一下思路：

1. 首先找到最小值的个数，如果 $>1$，则答案为 $0$。
2. 如果有相同的数超过三个，那么答案也为 $0$。
3. 当数量为 $2$ 个时，答案 $\times 1$，当数量为 $1$ 时，答案 $\times 2$。

所以我们可以发现，我们需要分别记录一共有多少个数量为 $1$、$2$ 的数，假设是 $s1$ 和 $s2$。但因为数量为 $2$ 时，答案 $\times 1$，所以 $s2$ 可以不用记。再记录数量 $\ge 3$ 的，假设为 $s3$。

如果都不满足答案为 $0$ 的情况，即上面的情况 $1$ 和情况 $2$，那么答案就为 $2^{s1-1}$，$s1-1$ 是因为这时最小值的个数也是 $1$，并且需要去掉它。

于是可以得到以下的代码：
```
#include<bits/stdc++.h>
using namespace std;
#define ll long long
const int N=5e5+5;
int n,m;ll p;
ll a[N],tong[N];
ll s1,s3;
ll QuickPow(ll a,ll b)
{
	ll res=1;
	while(b>0)
	{
		if(b&1)res=(res*a)%p;
		a=(a*a)%p;b>>=1;
	}
	return res;
}
ll calc()
{
	if(s3)return 0;
	ll Min=LONG_LONG_MAX;
	for(int i=1;i<=n;i++)Min=min(Min,a[i]);
	if(tong[Min]!=1)return 0;
	return QuickPow(2,s1-1);
}
int main(){
	scanf("%d%d%lld",&n,&m,&p);
	for(int i=1;i<=n;i++)scanf("%lld",&a[i]),tong[a[i]]++;
	for(int i=1;i<=n;i++)
	{
		if(tong[i]==1)s1++;
		if(tong[i]>=3)s3++;
	}//s1,s3的意义在上面讲到了
	printf("%lld\n",calc());
	while(m--)
	{
		int x,k;
		scanf("%d%d",&x,&k);
		//del
		if(tong[a[x]]==3)s3--;
		if(tong[a[x]]==2)s1++;
		if(tong[a[x]]==1)s1--;
		tong[a[x]]--;
		//add
		if(tong[k]==0)s1++;
		if(tong[k]==1)s1--;
		if(tong[k]==2)s3++;
		tong[k]++;
		//
		a[x]=k;
		printf("%lld\n",calc());
	}
	return 0;
}
```
时间复杂度为 $O(nm)$（然而还要算上每个询问的快速幂的时间，也可以预处理出每一个 $2^i$），显然不能通过此题。

发现这个代码的瓶颈在于每一次求 $\min$ 时，都需要 $O(n)$ 的时间复杂度。只要这里降下去，就可以了。

对于每一次求 $\min$，我们可以使用线段树维护一个单点修改和区间查询 $\min$ 即可，官方题解是用 multiset，~~但蒟蒻不会啊~~。

最后的代码就在上面的代码中添加一个线段树即可。~~就没有必要展示了吧。。。~~

于是，$O(nm)\xrightarrow{}O((n+m)\log n)$（同上，并没有考虑快速幂），完美通过此题。

## 题外话

关于我的 $s3$ 的计算时犯了一个sb错误，写了：
```cpp
if(tong[a[i]]==3)s3++;
```
竟然也过了。然后出题人就搞了一个数据Hack我了。。。为此还写在了题头。。。