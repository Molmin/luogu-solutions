# P1632 点的移动 题解
**先读题**

首先，题目告诉我们给定 $n$ 个点，求将 $k(k = 1,2...n)$ 个点移到一个位置最小的代价，$n \le 50$，所以我们可以毫不犹豫上暴力求中位数。

- 那中位数是个啥呢？

**中位数**，又称中点数，中值。中位数是按顺序排列的一组数据中居于中间位置的数，即在这组数据中，有一半的数据比他大，有一半的数据比他小（来自[百度](https://baike.baidu.com/item/%E4%B8%AD%E4%BD%8D%E6%95%B0/3087401?fr=aladdin)）


------------


- 那又如何去求呢？

**暴搜，纯纯的暴搜。**

我的思路是跑一个三重循环，第一，二重跑每一个点的横，纵坐标，第三重去枚举中间每个点到此点距离，计算需要的代价，用数组存起来，快排一下，将距离数组由小到大排好，最后再循环跑一遍对于每一个 $k$ 的最小就搞定了。

------------

虽然非常暴力，时间复杂度是 $O(n^3)$ 但是对于本题非常~~水~~小的数据，也能够 AC 了。

## 上代码
```c
#include<bits/stdc++.h>
using namespace std;
int n, x[101], y[101], co[101], dis[101] = {0};//x,y数组存坐标，co数组计算结果，dis记录枚举的距离
int main()
{
	cin >> n;
	for(int i = 1; i <= n; i++) cin >> x[i] >> y[i];
	memset(co, 0x3f, sizeof co);//将最值数组初始化一个最大值
	int i, j, k;//分别用来枚举第一个点，第二个点，每个点到此点距离
	int sum = 0;//用来存对于将i个点移到一个位置需要的代价 
	for(i = 1; i <= n; i++)
	{
		for(j = 1; j <= n; j++)
		{
			for(k = 1; k <= n; k++)
			dis[k] = abs(x[k] - x[i]) + abs(y[k] - y[j]);//计算距离
			sort(dis + 1,dis + n + 1);//sort默认从小到大排序
			for(int i = 1; i <= n; i++)//比较出对于每一个i最值的 
			sum += dis[i], co[i] = min(co[i], sum);
			sum = 0;//一定要初始化！！！
		}
	}
	for(int i = 1; i <= n; i++) 
	cout << co[i] << endl;//输出
	return 0; //圆满结束
}
```
这是本蒟蒻的第一篇题解，希望可以帮到大家，有做的不好的地方望谅解。
