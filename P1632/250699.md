话说这题看了题解半小时才明白是个啥，现在才理顺整个思路。大部分题解没有详细的说明整个题的做题思路，我做一些补充。

首先为什么答案的 $x$ 坐标一定属于给出的 $x$ 坐标之中的一个，答案的 $y$ 坐标一定属于给出的 $y$ 坐标之中的一个？

我们先考虑这个问题，假如在数轴上有一些点，现在让你找出一个点到这些点距离和最小，要怎么做呢？

显然是取中位数，这个很好证明，不再赘述。那么我们把 $x$ 坐标和 $y$ 坐标分别看，在二维平面中，找 $n$ 个点之间距离和最小的一个点就是这 $n$ 个数的 $x$ 坐标的中位数和 $y$ 坐标的中位数对应的那个点。

所以我们得出了这个结论。那么我们可以枚举了。 $O(n^2)$ 的时间复杂度枚举这个点的坐标。

我们现在只是锁定了枚举范围，但并不知道最小的值是多少，所以还要再来一层循环计算到其他点到我们当前枚举的这个答案点 $(x_i,y_i)$ 的距离。最小值肯定就是我们要求的答案了。

由于题目比较恶心，让我们分别求出i个点到同一位置的最小距离和。那么还要在最外层枚举当前是要求几个点到同一位置的最小距离和。

我们在求几个点到同一位置的最小距离和的时候可以排序之后再累加求和，$i$ 个点到同一位置的最小距离和肯定是排序之后的前 $i$ 项。

```
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
const int INF=0x3f3f3f3f;
int n,minn=INF,temp;
int x[100010],y[100010],dis[100010];
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		scanf("%d%d",&x[i],&y[i]);
    }
    for(int t=1;t<=n;t++)
    {
    	minn=INF;
    	for(int i=1;i<=n;i++) 
    	{
    		for(int j=1;j<=n;j++)
    		{
    			for(int k=1;k<=n;k++)//其他点到这个点的距离 
    			{
    				dis[k]=abs(x[k]-x[i])+abs(y[k]-y[j]);
				}
				sort(dis+1,dis+1+n);
				temp=0;
				for(int k=1;k<=t;k++)
				{
					temp+=dis[k];
				}
				minn=min(minn,temp);
			}
		}
		printf("%d\n",minn)
	}
	return 0;
}
```