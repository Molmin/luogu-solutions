### 分析

我们发现，我们实际上有三种方法：

- 只处理一段前缀

- 只处理一段后缀

- 处理一段后缀之后跳到开头处理一段前缀

而最后一种包括前两种。换而言之，整个字符串被分为三段：前缀、中部、后缀。

在前缀中，我们要经过一个数，花费是 $1$，删除一个数应当先经过它自己，花费是 $2$。在后缀中，经过和删除都是 $1$。

### 算法讨论

~~容易看出，此题应该用动态规划~~

总之，我们通过分析和推理，猜测动态规划可能用于解决这道题。

大家知道，正解的分类讨论是非常简洁漂亮的，但是我想介绍的是我这个蒟蒻的方法。__dp 预处理。__

设 $f_{i,j}$ 为把 $s$ 的前 $i$ 个字符处理成 $t$ 的前 $j$ 个字符，光标至少要行进多少次。（需要删除多少次不需要处理，因为它就是 $i-j$）

相似地，设 $g_{i,j}$ 为把 $s$ 去掉 $i$ 长前缀处理成 $t$ 去掉 $j$ 长前缀，光标至少要行进多少次。

这样，任何时候，$f_{i,j}$ 都可以通过更新值为 $i$ 从 $f_{i-1,j}$ 转移来，$g_{i,j}$ 都可以通过更新值为 $n-i$ 从 $g_{i+1,j}$ 转移来。

当 $s_i=t_j$ 时，$f_{i,j}$ 就可以等于 $f_{i-1,j-1}$，$g_{i,j}$ 就可以等于 $g_{i+1,j+1}$。

然后我们 __枚举前缀__ ，把两个字符串都分成两段，前一段以前缀解决，后一段以后缀解决。答案就是 $f_{i,j}+g_{i,j}+i-j+1$。当然不要忘了，当 $f_{i,j}=0$（也即不需要取前缀）的时候，没有回到开头的开销，答案就是 $g_{i,j}$。

 ### 内存限制

但是，当你发现这道毒瘤题 __卡内存__ 的时候，你就傻眼了，因为这玩意不能用滚动数组优化空间。

为什么呢？因为我们同一时间需要同时调用 $f_{i,j}$ 和 $g_{i,j}$ 的值，但是 $f$ 是从 __小下标推往大下标__ ，$g$ 是从 __大下标推往小下标__ ，只能预处理，不能即算即用。

这就不行了吗？不！

我们发现，$f$ 其实 __是可以通过滚动数组优化的__ ，问题只是出在 $g$ 上。

观察前面的方式，我们发现， __如果我们 dp 到实际上后缀前缀都不需涉足的地方，和直接 dp 到后缀的答案是一样的__ 。这就促使我们： __不要枚举前缀，而是枚举后缀的位置__ （也就是光标从最右边往左一直走到哪里）。而答案就是 $n-i+f_{i,j}+i-j+1$，原来的 $g_{i,j}$ 被直接转化为了 $n-i$ 处理。

但是问题又出现了。 __并非所有的后缀都是合法的__ ，我们必须保证选出的 $s$ 后缀和 $t$ 后缀有解。

那么令 $g_{i,j}$ 为设 $g_{i,j}$ 为把 $s$ 去掉$i$ 长前缀处理成 $t$ 去掉 $j$ 长前缀，是否有解。

位运算优化转移，

```cpp

g[i][j]=g[i+1][j]||(s[i]==t[j]&&g[i+1][j+1])。

````

但是问题又来了啊，这 $g$ 也不能用滚动数组啊，又得预处理，空间存不下呀！我们看似回到了最初的起点。

空间优化的方法不止一种！

除了常见滚动数组优化，还有一种方便的空间优化方法是 `bitset` 优化，通过压缩的方式，能够使数组缩小 $32$ 倍。（实际上 $256MB$ 的空间开 $5000\times5000$ 的数组也只是多了不到 $10$ 倍左右），它只能应用在 $01$ 数组上（也就是，数组里只有 $01$ 两个值），所以之前的 $f$ 和 $g$ 用不了。但是，我们新的 $g$，就是一个 $01$ 数组！

果断 `bitset` 优化。

而且，注意到 $f$ 在第二维的转移也是严格从小下标推往大下标的，因此可以只使用 __一维数组__ 进行滚动，进一步优化。~~（实际上已经没有必要了）~~

优化之后，我们就以 $3200KB$ 的空间成功切掉这题，还是比较宽裕的。

### 参考代码

```cpp

#include<bits/stdc++.h>
using namespace std;
#define rd(i,n) for(int i=0;i<n;i++)
#define rp(i,n) for(int i=1;i<=n;i++)
#define rep(i,a,b) for(int i=a;i<=b;i++)
#define per(i,a,b) for(int i=b;i>=a;i--)
#define st string
#define vt vector
#define pb push_back
#define int long long
typedef long long ll;
ll n,m;
ll f[5005];
bitset<5005>g[5005];
st s,t;
void solve(){
	cin>>n>>m>>s>>t;
	rep(i,0,n)g[i]=0;
	rep(j,0,m)f[j]=1e18;
	rep(i,0,n)g[i][m]=1;
	rp(i,n)rep(j,1,min(i,m)){
		g[n-i][m-j]=(g[n-i+1][m-j]|(s[n-i]==t[m-j]&&g[n-i+1][m-j+1]));
	}
	ll ans=1e18;
	rep(i,0,n){
		per(j,1,min(i,m)){
			if(f[j]!=1e18)f[j]=i;
			if(s[i-1]==t[j-1])f[j]=min(f[j],f[j-1]);
		}
		f[0]=i;
		rep(j,0,min(i,m))if(g[i][j]){
			ans=min(ans,f[j]+i-j+1+n-i);
			if(f[j]==0)ans=min(ans,n-i);
		}
	}
	if(ans==1e18)cout<<-1<<endl;
	else cout<<ans<<endl;
}
signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	int t;
	cin>>t;
	rd(_,t)solve();
	return 0;
}
//Accepted!

```

