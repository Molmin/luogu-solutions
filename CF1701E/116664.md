考虑这类双字符串匹配问题，通常想到动态规划。

我们可以把操作看为：从右边一端，向左，删除，跳到左边，向右，删除。

那么这一段 $n$ 数组中有哪些呢？其实分为三部分：最左边滑动与删除，最右边滑动与删除，和中间不用滑动部分。

考虑 $dp_{i,j,0/1/2}$，$i$ 表示原字符串第 $i$ 位，$j$ 表示改变到的字符串第 $j$ 位，$0/1/2$ 分别表示左边，中间，右边部分。

考虑转移，每一次如果不删除，那么直接转移即可。

如果删除，对于左边，只需要删除的 $+1$ 即可；对于中间，我们会发现这一定是从一个左边的地方转移过来的，那么考虑统一统计前几次所有向右滑的方案以及从右边跳到最左边方案，也就是 $+(i+2)$ 即可；对于右边，我们考虑如果从中间转移过来，可以直接增加滑到这里的 $+(n-i+1)$，如果从右边转移，那么不需要加任何东西。

复杂度 $\Theta(tnm)$，由于空间不行需要使用滚动数组。

重点片段代码如下：~~某些数字是比赛的时候习惯打的作为最大值使用~~

```cpp
dp[0][0][0]=0,dp[0][0][1]=0;
for(int i=1;i<=n;i++){
	int t=i&1;
	int l=t^1;
	for(int j=0;j<=m;j++) dp[t][j][0]=dp[t][j][1]=dp[t][j][2]=1145141919810;
	for(int j=0;j<=m;j++){
		if(j!=m&&s1[i]==s2[j+1]){
			dp[t][j+1][0]=min(dp[t][j+1][0],dp[l][j][0]);
			dp[t][j+1][1]=min(dp[t][j+1][1],dp[l][j][1]);
			dp[t][j+1][2]=min(dp[t][j+1][2],dp[l][j][2]);
		}
		dp[t][j][0]=min(dp[t][j][0],dp[l][j][0]+1);
		dp[t][j][1]=min(dp[t][j][1],dp[l][j][0]+2+i);
		dp[t][j][2]=min(dp[t][j][2],min(dp[l][j][2],dp[l][j][1]+(n-i+1)));
	}
} 
if(min(dp[n&1][m][1],dp[n&1][m][2])==1145141919810) cout<<-1;
else cout<<min(dp[n&1][m][1],dp[n&1][m][2]);
```