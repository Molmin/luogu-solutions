这道题因为数据比较小，所以就很好来**模拟**了

先把这个数据转换成一个**双向图**，再依次去选择起点，来选找最大值


------------
就比如4条路（1-2,90，2-4,80，3-1,20 , 4-1,50），四个景点转化成临界矩阵就是 
|  |  1|2  | 3 |  4|
| -----------: | -----------: | -----------: | -----------: | -----------: |
| 1 |0  | 90 |20  | 50 |
| 2 | 90 |0 |  | 80 |
| 3 |20  |  |  0|  |
|  4| 50 |  80|  |  0|
没有填写的则为到达不了的


------------


话不多数，看代码吧！！

------------
QAQ
```c
#include<bits/stdc++.h>
using namespace std;
int a[21][21],m,sum=0,b[21];
int n,x,y,z,k;
void dfs(int h,int ans)
{
int y=1;//y用来标记是否还有路可走
for(int i=1;i<=m;i++)
	{
	if(a[h][i]!=0&&b[i]==0)
		{
		b[i]=1;
		dfs(i,ans+a[h][i]);//继续查找
		b[i]=0;//回溯
		y=0;//改变y值
		}
	}
if(y==1)sum=ans>sum?ans:sum;//三目运算符，不要我解释吧
}
int main()
{
cin>>m>>n;
for(int i=1;i<=n;i++)
	{
	cin>>x>>y>>z;
	a[x][y]=z;
	a[y][x]=z;//记住是双向图哦
	}
for(int i=1;i<=m;i++)
	{
	k=i;
	memset(b,0,sizeof(b));//记得清空b数组
    b[k]=1;//将起点标记为走过了
	dfs(k,0);
	}
	cout<<sum;
return 0;
}

```


------------
就是这样吧，记住请勿抄袭哦
支持一下吧
------------
~~自欺欺人是没有用的~~