**这是本蒟蒻第十九次写的题解，如有错误点请好心指出！**

## 问题简述

__这道题我们可以换另一种思路去看待它，就容易理解了：__

给你一个正整数 $n$ 和长度为 $n$ 的数组 $a$，从 $a$ 数组中选取若干个元素并存入数组 $b$ 中，使得 $b[1]+b[2]+b[3]+...+b[i-1]<b[i]$，问最多能选取多少个元素。

## 解法综述

很显然要保证 $b$ 数组是上升序列，不妨定义数组 $b$ 为从小到大排列的优先队列，并将 $a$ 数组里的所有元素全部存入 $b$ 数组中。

设 $t$ 为当前所选取数组 $b$ 中元素的总值，$s$ 为当前选取数组 $b$ 中元素的个数。若 $b[i]>t$，则说明可以选取 $b[i]$，记录该次选取并更新 $t$，即 $s++$ 并 $t+=b[i]$，最后输出 $s$ 即可。

## 代码描述
```cpp
#include<queue>
#include<cstdio>
using namespace std;
priority_queue<int,vector<int>,greater<int> > b;
//定义数组b为从小到大排列的优先队列 
int n,a,t,s;
//设t为当前所选取数组b中元素的总值，s为当前选取数组b中元素的个数
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&a);
		b.push(a);//将a数组里的所有元素全部存入b数组中
	}
	while(!b.empty())//若b数组不为空
	{
		if(b.top()>t)//判断是否可以选取b[i]
		{
			t+=b.top();
			s++;
		}
		b.pop();//将b数组当前最小的元素弹出
	}
	printf("%d\n",s);//该题一定要输出换行
	return 0;
}
```