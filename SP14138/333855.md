前置芝士：线性筛，约数和公式。

设 $\sigma(x)$ 为 $x$ 的约数和。

且 $x=p_1^{a_1}\times p_2^{a_2}\times\cdot\cdot\cdot\times p_n^{a_n}$

约数和即为： $(p_1^0+p_1^1+\cdot\cdot\cdot+p_1^{a_1})(p_2^0+p_2^1+\cdot\cdot\cdot+p_2^{a_2}) \cdot\cdot\cdot (p_n^0+p_n^1+\cdot\cdot\cdot+p_n^{a_n})$ 。

我们在计算 $\sigma(x)$ 的约数和时，枚举 $1\sim\sqrt{x}$ 的质数，这些质数可以用线性筛筛出来，再对他们搞一个前缀和即可。

现在我们就有一个 $O(N\times\frac{\sqrt{N}}{\log\sqrt{N}})$ 的算法了，但是这个算法得跑 $1.6s$ ，会 TLE 。

我们可以分块打表，把 $1\sim4000$ ， $1\sim8000$ ，一直到 $1\sim10^6$ 的约数和都提前算出来，再单独用刚才的方法计算即可。

设 $M=4000$ ，为块长。

时间复杂度：$TM\times\frac{\sqrt{N}}{\log\sqrt{N}}$ ， 但常数很小。

Code：

```cpp
#include<iostream>
#include<algorithm>
using namespace std;
typedef long long ll;
ll a[1005],b[905],r,n,t,ans;
ll bs[4005]={0,5160383,20639086,46442752,82554201,128994151,185755537,252826121,330213092,417943261,515961693,624307749,742997939,871969975,1011278101,1160918207,1320845414,1491100498,1671724881,1862611497,2063796052,2275412089,2497219509,2729366539,2971923846,3224690835,3487831246,3761340380,4045073192,4339150608,4643594344,4958295214,5283341993,5618762343,5964407824,6320413536,6686779293,7063335136,7450349786,7847668433,8255200272,8673123602,9101476994,9539946065,9988771829,10448093108,10917459025,11397309427,11887564523,12387978773,12898711231,13419926858,13951308532,14492979149,15045216120,15607506656,16180176217,16763321618,17356532927,17960199054,18574218837,19198487418,19833073335,20478232995,21133275186,21798842837,22474887066,23160921905,23857572481,24564415186,25281557825,26008941850,26746895587,27494898320,28253258304,29022242498,29801250406,30590705222,31390450212,32200304907,33020695151,33851538879,34692433196,35543630613,36405572760,37277253757,38159586684,39052339142,39955049428,40868262719,41792039916,42725738421,43669791706,44624519636,45589180970,46564348871,47550019759,48545634426,49551739238,50568357875,51594816213,52631828580,53679455457,54737011314,55805003562,56883525356,57971964903,59070882224,60180433273,61299827886,62429803500,63570137451,64720593108,65881431263,67052834844,68234226333,69425997796,70628428849,71840637130,73063439808,74296715397,75539942750,76793732165,78057989476,79332252517,80616849435,81912399770,83217204889,84532828512,85859169607,87195241550,88541852822,89899064985,91266255396,92643594779,94031844431,95429922914,96838287465,98257348699,99686314576,101125889673,102575923905,104035757187,105506337006,106987222554,108478135057,109979304460,111491538626,113013120139,114545664571,116088492227,117641272882,119204700310,120778591933,122362460738,123956385229,125561398823,127176044238,128801209626,130437105494,132082753145,133738957355,135405757967,137082068649,138769349151,140467117962,142174560452,143892744728,145621560366,147359902479,149108898129,150868778095,152638151719,154418056091,156208757243,158009162893,159819986548,161641492437,163472993683,165314718242,167167450462,169029823955,170902579892,172786020369,174679219009,176583203962,178497562545,180422043729,182356524400,184302309641,186257227821,188222901976,190199415407,192185214465,194182284602,196189587121,198206694395,200234025536,202272735678,204320481450,206379031444,208448455344,210527219059,212617116858,214717357861,216826984521,218947724312,221078799978,223219805568,225371154118,227533428978,229705094163,231887446133,234080653285,236283457399,238496736440,240721039770,242954981085,245198901715,247454049862,249718807019,251994052802,254280025356,256575784237,258882062283,261199167656,263525431690,265862723919,268210731109,270568271135,272936481041,275315549516,277703819878,280102640193,282512912755,284931946006,287362260752,289802919713,292253581400,294714471206,297186210421,299667698551,302159586182,304662497316,307174655029,309697713739,312231404504,314774524851,317328456779,319893118334,322467618437};
void shai(ll n){
	a[0]=a[1]=1;
	for(ll i=2;i<=n;i++){
		if(!a[i]){
			b[++r]=i;
		}
		for(ll j=1;j<=r&&i*b[j]<=n;j++){
			a[i*b[j]]=1;
			if(i%b[j]==0){
				break;
			}
		}
	}
}
int fj(int x){
	int ans=1,fgr=1,tot=0;
	for(int i=1;b[i]*b[i]<=x&&x>1&&i<=r;i++){
		if(x%b[i]==0){
			fgr=tot=1;
			while(x%b[i]==0){
				fgr*=b[i];
				tot+=fgr;
				x/=b[i];
			}
			ans*=tot;
		}
	}
	if(x>1){
		ans*=(x+1);
	}
	return ans;
}
int main(){
	shai(1000);
	cin>>t;
	while(t--){
		cin>>n;
		ans=bs[n/4000];
		for(int i=n-n%4000+1;i<=n;i++){
			ans+=fj(i)-i;
		}
		cout<<ans<<endl;
	}
	return 0;
}
```
