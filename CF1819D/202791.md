首先有一种清零的方式是在一个 $0$ 点买 $a$ 苹果，然后在第 $x$ 个商店中有 $a$ 苹果，这样就可以在第 $x$ 个商店这个地方清零了，能卡掉很多假做法。

我们考虑最后剩的苹果一定是原序列的一个后缀 $i$，并在 $i - 1$ 这个商店清零，同时，如果有两个商店同时有 $a$ 苹果，那么这两个商店一定不能同时选择。

那么我们找到 $lstS$ 表示最靠后的有同种苹果的商店（编号靠前的那个），那么答案后缀一定在 $lstS + 1 \sim n$ （或者为空）。

那么如果我们枚举 $lstS \sim n$，找到最先能够清空的那个商店不就找到答案后缀了？

现在问题变为求能否在每个商店清空背包。

这个也很简单，只需要找到最近的和它有着至少一种相同苹果的商店 $i$（或者是 $0$ 商店），然后在它之前找到最近的一个商店 $j$ 能够清零，并且在 $j + 1 \sim$ 当前枚举到的商店之间没有两个有着同种苹果的商店就行了，`st` 表维护区间最靠后的前驱再用树状数组线段树啥的维护区间是否有能清零的商店就行了。

Code：[https://codeforces.com/problemset/submission/1819/202796663](https://codeforces.com/problemset/submission/1819/202796663)。