### PS.
在这里，我介绍一个好像其他人都没有想出来的奇怪的DP。  
绝对原创，所以即使有好多篇题解了我还是要再投一篇QAQ。

### Problem.
给定一个$[1,P]$的区间，区间上有$Q$个断点。  
切断每个断点所需要的代价是这个断点当前所在的区间中除了这个断点其他所有点的个数。  
求把所有断点切掉的最小代价。  
（后文中我们设$M=P,N=Q$）

### Solution.
把题目按照`Problem`那样概括出来就不难发现，每两个断点之间的数本质没有任何区别。  
所以我们可以用一个数值来记录每两个断点之间的数值大小。  
举个例子，比如有这样一个输入数据：
```
6 2
2 4
```
（后面我们称这个`2,4`的区间为b）  
![](https://cdn.luogu.com.cn/upload/image_hosting/wbatdmn0.png?x-oss-process=image/resize,m_lfit,h_170,w_225)  
那么我们可以把这个东西给归纳成这样一个问题（有点类似离散化  
给定一个区间`1,1,2`（后面我们设这个区间为a），要把这个区间给随便等分，其他条件和原题类似。  
然后就轻松地把这个问题的$N$从$1000$变成了$100$。  

那么我们可以考虑区间DP。  
一个区间记录的是把这个区间每一个断点都给拆分的最小代价。  
那么就可以用区间DP最基本的套路，为枚举中间断点然后再转移。  
则转移方程式为：$dp[i][j]=min\{dp[i][k]+dp[k+1][j]+f(i,j)\}$  
$f(i,j)$为把当前这个区间给断了的值，即$\sum_{k=i}^ja[k]$。  
这个东西又可以用前缀和来维护，设这个前缀和为$s$。  
则我们可以轻易地发现，$s[i]=b[i]-i,s[n]=m-n+1$。  
然后我们就可以轻而易举的求出$s[i]$，然后套用DP方程式就可以了QwQ。  

如果还不会地话可以看代码。

### Coding.
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,a[105],dp[105][105];
int main()
{
	scanf("%d%d",&m,&n),memset(dp,0x3f,sizeof(dp));
	//m和n即为上面的P与Q。
	//因为要求最小值，所以dp初值要为0。
	for(int i=1;i<=n;i++) scanf("%d",a+i),a[i]-=i,dp[i][i]=0;
	//读入所有数据，求出上面的s
	//然后单个区间不需要切分，所以代价为0
	n++,a[n]=m-n+1,dp[n][n]=0;
	//把最后一个s算出来，最后一个dp清零。
	for(int l=1;l<=n;l++)
		for(int i=1,j=i+l;j<=n;i++,j++)
			for(int k=i;k<j;k++)
				dp[i][j]=min(dp[i][j],dp[i][k]+dp[k+1][j]+a[j]-a[i-1]+j-i-1);//上面的区间dp转移方程式。
	return printf("%d\n",dp[1][n]),0;//最后输出答案并结束
}
```
~~前排无耻求赞~~