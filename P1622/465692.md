# 0x00 思路
>Caima 王国中有一个奇怪的监狱，这个监狱一共有 $P$ 个牢房，这些牢房**一字排开，第 $i$ 个紧挨着第 $i+1$ 个（最后一个除外）。现在正好牢房是满的。**

>上级下发了一个释放名单，要求每天释放名单上的一个人。这可把看守们吓得不轻，因为看守们知道，现在牢房中的 $P$ 个人，可以相互之间传话。如果某个人离开了，**那么原来和这个人能说上话的人，都会很气愤**，导致他们那天会一直大吼大叫，搞得看守很头疼。如果给这些要发火的人吃上肉，他们就会安静点。

>请你求出**最少**要给多少**人次**送肉吃。

这个“ *原来能和这个人说上话的人* ”指谁呢？

我们从样例解释可以看出是**所有与此人之间的监狱都没有空的人**。那么当我们将一个人释放后，就十分自然地将这个监狱分成了 $2$ 个部分：此人左边的人可以说上话，右边的人也可以说上话，但是**左右**的人不能说上话，因此就可以很自然地想到区间 dp。

# 0x01 定义状态
```d[i][j]```:表示释放第 $Q_i$ 个囚犯和第 $Q_j$ 个囚犯之间（包括 $Q_i$，$Q_j$）的所有需要释放的囚犯所需肉的最小值。

# 0x02 状态转移方程
注意一件事：输入的囚犯的编号。当你细细的观察它们时，你会发现第 $Q_i$ 个囚犯的编号 $Q_i$ 等于他及其前面的所有人的人数，那么这就相当于是一个前缀和，又因为我们放第 $Q_q$ 个囚犯的时候需要给最后一段人肉，所以我们可以假设在这段监狱的最后（$p+1$）还有一个需要释放的囚犯。

再假设我们此时释放囚犯 k，那么我们此时需要的肉的数量即为释放第 $Q_i$ 个囚犯到第 $Q_{k-1}$ 个囚犯与释放第 $Q_{k+1}$ 个囚犯到第 $Q_j$ 个囚犯所需的总肉数加上施放这个囚犯所需的肉的数量。由于我们先选择释放第 $Q_k$ 个囚犯，所以我们需要用 ```a[j+1]-a[i-1]-2``` 的肉（我们的假设是除了第 $Q_i$ 个囚犯到第 $Q_j$ 个囚犯未释放外其他囚犯均已释放，只不过没用肉。），由于先放哪一个囚犯最优不清楚，于是取最小值。

# code
```c
#include<bits/stdc++.h>
using namespace std;
int d[505][505],a[505];
int main()
{
	int m,n,l,i,j,k;
	scanf("%d %d",&m,&n);
	for(i=1;i<=n;i++)
		scanf("%d",&a[i]);
	sort(a+1,a+1+n);//从小到大排序使前缀和成立
   a[n+1]=m+1;//再加一个囚犯
	for(l=1;l<=n;l++)
	{
		for(i=1;i<=n;i++)
		{
			j=i+l-1;
			d[i][j]=1<<30;//赋初值
			for(k=i;k<=j;k++)
				d[i][j]=min(d[i][j],d[i][k-1]+d[k+1][j]+a[j+1]-a[i-1]-2);
		}
	}
	printf("%d",d[1][n]);
	return 0;
}
```