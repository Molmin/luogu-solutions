# P1622 释放囚犯

## 读题
先读题：一排牢房，其中一些牢房的犯人需要被**逐个释放**。两个**相邻**牢房如果**都有人**，就会互相传话：“XXX被释放了！！！”

就这样，如果有哪个牢房的犯人被释放了，这条消息就会向这个牢房的左右两边一直传递，直到遇到**空房**，消息才无法传递下去。于是，当一个犯人被释放时，**与之连通的**所有犯人都要吃到一块肉。看守希望发的肉最少，求这个**最小值**。

## 考虑区间DP
我们说一个区间连通，当且仅当这个区间内的所有牢房都有犯人。
1. 一个牢房的犯人被释放时，这个牢房的编号将成为这个区间的一个断点，区间被分裂成**两个连通的子区间**。
2. 一个牢房的犯人被释放时，只有该**连通区间内**的犯人会吃到肉。

随着犯人被不断释放，这排牢房被分割成越来越多的子连通区间。~~恍然大痦~~，这不是**区间DP**吗！然后再仔细一想，诶不对！区间DP不是由子区间**合并**成更大的区间吗？这跟正经的区间DP是反着的啊！~~所以这题无解，散了吧。~~

## 问题转化
既然跟传统的区间DP反着来，那么我们就转化一下问题！

相信大家都看过电影《信条》，~~没看过的建议先去看，然后再做这题。~~ 我们用《信条》的方式，干脆直接把题目**倒过来**：

一排牢房，除了某些牢房，剩下的全部住满了犯人。这些空牢房中要**逐个**关进新的犯人。每当一个牢房关进一个新的犯人，这个牢房就会将左右两个连通区间**合并为一个**，这个新的连通区间内**除了新的犯人自己**非常不爽以外，其它的犯人都因为新伙伴的到来而感到开心，并因此吐出一块肉。然而，吐出一块肉是非常伤身体的，看守们希望犯人们吐出肉的总和最少，求这个**最小值**。

从现在开始，忘掉原题，按照上面这个转化后的问题接着想。

现在问题就变成了，将原来几个**断断续续**的连通区间合并为**一整个**连通区间。豁然开朗，它变成了一道**非常正经的区间DP**。

## Solution
设$f[l][r]$为将区间$[l,r]$合并为一整个连通区间，至少要吐出肉的块数。需要注意的是，这里的$l,r$**并非牢房编号**，而是需要关进去的新犯人的下标。以区间长度作为**阶段**，转移时枚举断点$k$。

初值：$f[i][i]=q[i+1]-q[i-1]-2$

转移方程：$f[l][r]=min\{\ f[l][k]+f[k+2][r]\ \}+q[r+1]-q[l-1]-2$

$q[i]$为编号为$i$的新犯人的牢房编号。枚举断点，再加上新关进去犯人后这个连通区间里吐出肉的块数，**注意每个区间的边界如何处理**。

代码可能写的不是很简洁，并且变量名与题目所给略有不同，仅供参考。

```cpp

#include<bits/stdc++.h>
using namespace std;
int main(){
	int n,m; scanf("%d%d",&n,&m);
	int*q=new int[m+2]; *(q++)=0; q[m]=n+1; //方便转移
	for(int i=0;i<m;i++) scanf("%d",&q[i]);
	int**f=new int*[m];
	for(int i=0;i<m;i++) f[i]=new int[m];
	for(int i=0;i<m;i++) f[i][i]=q[i+1]-q[i-1]-2; //初值
    
    //下面不建议照搬，完全可以自己画图或者debug写出来
	for(int i=1;i<m;i++){
		for(int j=0;j<m-i;j++){
			f[j][i+j]=f[j+1][i+j];
			for(int k=j;k<i+j;k++){
				f[j][i+j]=min(f[j][k]+(k+2<=i+j?f[k+2][i+j]:0),f[j][i+j]);
			}
			f[j][i+j]+=q[i+j+1]-q[j-1]-2;
		}
	}
    
	printf("%d",f[0][m-1]);
	return 0;
}

```

如有错误，欢迎指正！