一开始看到本题感觉一脸懵逼，这什么玩意

然后，仔细一想（~~看看题解~~）哦~

反着来的石子合并嘛；

我们将所有待删除的都删除，这样一个序列就变成了一块一块的，就是石子合并中的每一堆嘛；

```cpp
for(int i=1;i<=m;i++)cin>>s[i];
	s[++m]=n+1;
	sort(s,s+m+1);
for(int i=1;i<=m;i++)num[i]=s[i]-s[i-1]-1+num[i-1];
```

要注意这里的-1（删除的数不在其中）

然后就和石子合并一样了

```cpp
for(int l=2;l<=m;l++)
for(int i=1;i<=m-l+1;i++)
{int j=l+i-1;dp[i][j]=0x3f3f3f3f;
for(int k=i;k<j;k++)
dp[i][j]=min(dp[i][j],dp[i][k]+dp[k+1][j]+num[j]-num[i-1]+j-i-1);
}
```

这里要注意的一点就是j-i-1，我们合并的同时其中删除的也会回到队列中，所以要加上这些人；

最后输出F[1][m]即可
