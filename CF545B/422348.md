## 题目

[传送门](https://www.luogu.com.cn/problem/CF545B)

此题目的翻译翻的很好~~因为是我翻的~~，题目大意就不多叙述了

## 样例分析

先来看第一组样例：

标准输入：
>0001

>1011

标准输出：
>0011

或

>1001

通过找规律，我们不难发现，两种答案的第 2 位和第 4 位没有变，只有第 1 位和第 3 位变了，样例输入中的 2 个字符串恰好也是第 2 位和第 4 位一样，只有第 1 位和第 3 位不一样，这是巧合吗？

## 题目解答

由汉明距离的定义可得：

如果字符串 $s$ 和 $t$ 在第 $i$ 位上一样，那么新字符串的第 $i$ 位不用改动就不用加距离

如果字符串 $s$ 和 $t$ 在第 $i$ 位不一样，那么新字符串的第 $i$ 位无论是 0 还是 1 都会和其中一个字符串的距离加上 1。

所以我们要在字符串 $s$ 和 $t$ 在第 $i$ 位不一样的时候才能控制距离。

当这是第 $k$ 次出现不一样时：

如果 $k$ 是奇数，那么新字符串的这一位保持和 $s$ 的这一位一样，该新字符串和 $t$ 的距离就会加 1。

如果 $k$ 是偶数，那么新字符串的这一位保持和 $t$ 的这一位一样，该新字符串和 $s$ 的距离就会加 1。

这样可以报证当 $k$ 是偶数的时候，新字符串到 $s$ 和 $t$ 的距离一样，最后输出该字符串就行了。

如果最后的时候 $k$ 是奇数，那么就输出 $impossible$。

## 代码

献上代码

```cpp
#include<bits/stdc++.h>
using namespace std;
string s,t;
int main(){
	int cnt=0;
	cin>>s>>t;
	for(int i=0;i<s.size();i++){
		if(s[i]==t[i])
			continue;
		cnt++;
		if(cnt%2!=0)
			s[i]=t[i];
	}
	if(cnt%2==0)
		cout<<s;
	else
		cout<<"impossible";
	return 0;
} 
```

既然看到这里了，就点个赞再走吧Orz




