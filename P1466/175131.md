动归。

最终可以转化成背包问题。为什么呢？

因为题目中让你把集合中元素分成两个权值相等的部分，也就是说元素和相加除以2就是背包容量，我们的状态f[i][j]就设置为第i个元素装满容量为j的背包的方案数目。

好了，现在这个题目就变成了01背包问题。

只不过是求方案罢了。

我看到大家有很多写数组压缩的，但是我~~不会~~（逃

先上代码，再强调一下细节。
```cpp
#include<cstdio>
using namespace std;
int n,t,f[40][1000];
int main()
{
    scanf("%d",&n);
    t=(n+1)*n/2;
    if(t%2)
    {
        printf("0");
        return 0;
    }
    else 
        t/=2;
    f[1][1]=1;
    for(int i=2;i<=n;i++)
        for(int j=0;j<=t;j++)
        {
            if(j>i)
                f[i][j]=f[i-1][j]+f[i-1][j-i];
            else
                f[i][j]=f[i-1][j];
        }
    printf("%d",f[n][t]);
    return 0;
}
```
首先要判断当前集合的元素和能否被2整除，不能的话还玩个头。

然后要设定初值，f[1][1]=1，我想不用多说。

PS;有人也把f[1][0]设置为0了，我本人不是很理解，事实证明删去也毫无问题。

然后开始DP，注意t要除以2。

我们在每次状态转移之前要先加判断，如果可用空间比当前元素要大的话才可以把选和不选两种可能加到一起，否则就只能不选。

选和不选的问题或者这段代码看不懂的请自行补习01背包。

然后这道题就可以AC 了。