~~为了彻底弄懂这道题,还是来水一发题解~~

题意：从 1->n 中选任意个数,使得其和为这列数总和的$1/2$.（稍稍加以变通）

**令$m=n*(n+1)/2;$**

**$m/=2;$**

那么 m 即为要求的答案


背包+dp.

### 特判：
由于是分成总和的 $1/2$ ,如果总和的  $1/2$ 不是偶数的话,那么就肯定分不出来.直接输出0.

### 设计状态：
dp[i][j]表示已经处理了1到i,其总和为j的情况总数.那么有状态转移方程：dp[i][j] += dp[i-1][j-i];

### 优化状态：
由于dp[i][j]的答案只与dp[i-1][j-i]有关,而且在循环的时候我们可以直接从小到大循环.求完 dp[i-1][...] 后就求 dp[i][...] .所以可以把第一维去掉.那么 dp[j] 就表示从1-n这些数中任取一些数使其和为 j 的方案数。

我们从小到大循环，这样确保求 dp[j] 时 dp[j-i] 是有答案的.




```cpp
for(int i=1;i<=n;i++)
    {
        for(int j=m;j>=i;j--)
        {
            dp[j]+=dp[j-i];
        }
    }
```

### dp循环详解：
第一层从 1->n 的循环：枚举第i个数 (其值正好就是i) 加入集合.
第二层从 m->i 的循环：如果第i个数加入集合，那么和最小为 i ,最大（在题意范围内）为 m .那么要使和为 j ，答案即为 dp[j-i] 的答案 +1 .


```cpp
#include<bits/stdc++.h>
using namespace std;

typedef long long ll;
ll n,m;
ll dp[10009];//dp[i]表示在n个数中去任意个数使其和为i的方案总数
int main()
{
    scanf("%lld",&n);
    m=(n+1)*n/2;
    if(m%2==1)
    {
        printf("0\n");
        return 0;
    }
    m/=2;
    dp[0]=1;
    for(int i=1;i<=n;i++)
    {
        for(int j=m;j>=i;j--)
        {
            dp[j]+=dp[j-i];
        }
    }
    printf("%lld\n",dp[m]/2);
    return 0;
}
```

