总的来说，“访问”美术馆是一道比较考察综合能力的题目。

首先，审题是关键。只有读懂了题意，才可能写出正确的程序。可以说，这一道题目的输入是一个亮点。因为它不同于平常的读入，而是用深度优先搜索的方式读入。所以，编程人需要非常熟悉深搜，才可能正确地导入数据。

就算读入了数据，许多同学还是不能把握好。因为这道题目的数据量看似不大，所以有些同学可能会陷入搜索的死胡同。其实本题的数据量还是很大的，因为每条路的走廊也需要时间。所以，会让人没有头绪。

其实，题目已经把条件给的很清楚了，**[color=red]显然，美术馆就是一颗树，而且是一颗二叉树[/color]**。那么，说到二叉树，又说到最优解，那么思路就很明显了——树形动规。


说到树形动规，相信许多同学都有思路了。[u]**只要设f[x,p]表示第x和节点，还有p秒钟时的最优解，转移方程即可**[/u]。注意边界条件。


所以，现在就给出DP的核心代码，输入不再附程序，以便锻炼自己的编写能力。

```delphi

function dp(x,p:longint):longint;  
var  
  i,r,l,s:longint;  
begin    
  if p=0 then  
    exit(0);  //时间为0，显然只能偷到一幅画
  if f[x,p]<>-1 then  
    exit(f[x,p]);  //已经求过值，不再重复。类似于记忆化搜索的思想。不过不写应该也是没事的，只是为了保险而已。
  s:=p-a[x]<<1;  //穿过后还剩下的时间，显然有去有回，时间应*2
  if c[x,1]=0 then  //走到底的情况
    begin  
      f[x,p]:=min(b[x],s div 5); //最有情况为拥有的画和能偷到的画的最小值 
      exit(f[x,p]);  
    end;  
  r:=c[x,1]; l:=c[x,2];  //左节点和有节点
  for i:=0 to s do  
    f[x,p]:=max(f[x,p],dp(r,i)+dp(l,s-i));  //方程转移
  exit(f[x,p]);  
end; 
```