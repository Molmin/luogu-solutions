这是一个初学树形dp的萌新用2个多小时勉强切掉的~~简单~~题。

通过题目得知，一个走廊走到尽头只有两种情况，一种是分成两条走廊，一种是走到头了开始拿画，这很容易让我们联想到二叉树结构，又因为题目让我们在规定时间内最多能偷多少幅画，这种求最优的问法便让我们想到树形dp。

那么怎么dp呢？因为本题读入的问题，我们要解决的首先是建树，又因为读入是按照深度优先的次序给出，而我们走树形dp时的顺序也是如此，所以我们可以边读入边dp。
再看读入的数据，分别是通过一条走廊的时间（注意我们要避免被警察抓住，所以要在警察到来之前跑走，所以进入走廊再走出走廊都需要时间）和走廊尽头画的数量。那么我们可以把一个走廊看做一个点，**但需要注意，如果这条走廊走到尽头且拿画的话，相当于走过这条走廊，拿走画，再走出这条走廊**，所以我们在边界处理时除了拿画的时间还需要加上穿过走廊的时间*2，这样我们我们在深搜的基础上不断读入每个点的属性，这个树就建好了。

然后开始dp。因为每个画室的画不一定全拿，所以我们可以发现这其实是一个分组背包。又因为每个节点只存在没有儿子和有两个儿子两种情况，没有儿子（边界）的情况我们其实在建树时已经处理了，所以我们只需要处理两个儿子的情况，那么设dp数组为f[now][i]表示以当前节点编号（now）为根的子树中拿i个画需要的最小时间为**从左子树中拿j个画+从右子树中拿i-j个画+进入和出去当前节点编号表示的走廊的时间的和的最小时间**，由此可以得到dp方程：f[now][i]=min(f[now][i],f[now<<1][j]+f[now<<1|1]+t* 2).

最后只需倒序枚举画的个数，找到第一个**小于**警察到来时间的画的个数输出即可~~可能与警察到来时间相同会在大门口撞见警察~~。

还有一些细节标注在代码里。

```cpp
#include<cmath>
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
#include<queue>
#define NN 123
using namespace std;
inline int read()
{
	int x=0,f=1;char c=getchar();
	while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}
	while(c>='0'&&c<='9')x=(x<<3)+(x<<1)+(c^48),c=getchar();
	return x*f;
}
int s,f[NN<<1][NN*20];//因为最多100展室,那么最多有100*2个节点,每个展室最多20幅画,总共最多100*20幅画 
inline int dfs(int now)
{
	int t=read(),num=read(); 
	if(num!=0)
	{
		for(int i=1;i<=num;i++){
			f[now][i]=i*5+t*2;//边界情况 
		}
		return num;//返回画数 
	}
	int x1=dfs(now<<1),x2=dfs(now<<1|1),sum=0;//x1为左子树的总画数,选为右子树的总画数 
	sum=x1+x2;
	for(int i=sum;i;i--)//背包问题的倒序枚举 
	{
		for(int j=0;j<=sum;j++)//因为有可能左子树或右子树拿的画数为0,所以从0枚举到sum 
		{
			if(i-j>=0&&j<=x1&&i-j<=x2)//当前节点的取画数大于等于左/右子树的取画数,且左右子树的取画数小于左右子树的总画数 
			{
				f[now][i]=min(f[now][i],f[now<<1][j]+f[now<<1|1][i-j]+t*2);
			} 
		}
	}
	return sum;
}
int main()
{
	memset(f,0x3f,sizeof(f));//因为求最少时间,所以初始化为极大值 
	s=read();
	for(int i=1;i<(NN<<1);i++) f[i][0]=0;//初始化为0 
	dfs(1);
	for(int i=120;i>=0;i--)//因为警察在600s内来,一幅画5s,最多120幅 
	{
		if(f[1][i]<s)//再次注意是小于 
		{
			printf("%d",i);
			return 0;
		}
	}
}
```
如果有人看的话，感谢观看。如有错误，请不吝赐教。