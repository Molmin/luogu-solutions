### 一看到这样的题我的第一反应是打个2维数组表。。。。后来看了大佬们的题解觉得自己。。。【捂脸】

##### 我也不会大佬的方法


天真的我本来想用蒟蒻的方法做。。。而且在输出时还要一个个遍历过去统计一遍。。。。5000*5000的复杂度。。【捂脸】

呜呜呜伤心的我都不想贴代码了  ~~其实是因为我太懒~~


### AC算法

被以前的方法搞的AC率疯狂下掉的我终于想出了这个方法

```
#include<bits/stdc++.h>//万能头
using namespace std;
bool can1[100000],can2[100000];//哈哈完全忽视5000的限制
long long ans1,ans2;//代表扫过的行，列数；
int main()
{
	int n,m,b,g;
	int i,j,k;
	int x,y;//我最讨厌压行了~~
	cin>>n>>m>>b>>g;
	for(i=1;i<=b;i++)//BOY
	{
		cin>>x>>y;
		for(j=x;j<=y;j++)//把每行（列）一个个nen过去（下同）
		{
			if(can1[j]==0)
			can1[j]=1,ans1++;
            //在过程中就可以统计（可以少打好多代码）
		}
	}
	for(i=1;i<=g;i++)//girl(不知道我有没有拼错)
	{
		cin>>x>>y;
		for(j=x;j<=y;j++)
		{
			if(can2[j]==0)
			can2[j]=1,ans2++;
		}
	}
    //重点来了！！
    //行的格子+列的格子-重叠部分（初一党刚学）
	cout<<ans1*m+ans2*n-ans1*ans2;
	return 0;
    //OK
}
```

大神勿喷

##### 抄袭可耻！！