### 解题思路：

挺巧妙的一个构造。

---
首先发现要求在区间中的数要比在区间外的数至少多 $k$ 个，否则一定无法构造，这是显然的。

设在区间内的数为 $x$，有 $x-k\ge n-x$，解得 $x\ge \dfrac{n+k}{2}$，由于 $x$ 为整数，需要取上整。


直接按照 $x$ 进行一个尺取即可求出最小的区间。

---
但是求出来的值是可能的最小值，考虑构造一组解以证明可行性。

这里直接按照上面求值得到方法构造，即一遇到有满足条件的区间立即划为一个区间，如果有多余的区间，直接合并到一起就行了。

---
但是直接给出这个构造并不能说明一定存在合法结果，接下来需要~~交一发看看~~证明存在性。

原问题也就是需要保证有至少 $k$ 个区间被划分出来（合并任意两个区间依然是一个合法的区间）。

转化问题，不妨将在区间中的数设为 $1$，不在的设为 $-1$，也就是要求有至少 $k$ 个区间权值和大于等于 $1$。

这里希望分出的区间尽可能多，而且任意一个权值和比 $1$ 大的区间一定能分成若干组权值和等于 $1$ 的区间，所以不妨直接将整个序列分成不少于 $k$ 个权值和等于 $1$ 的区间。

再利用前缀和的思想，在每一个权值和为 $1$ 的区间结尾处取前缀和，则前缀和一定是一个 $a_i=i$ 的至少为 $k$ 项序列，反之，如果能找到一个样的序列，则直接按照这个划分就能得到一个满足条件的序列。

最后一步就简单了，直接不断删除相邻的 $-1$ 和 $1$，最后得到至少长度为 $k$ 的全是 $1$ 的序列，记下这些数，还原即可得到所求序列。

代码实现的时候建议按照原方法构造。

---
### 代码：

```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
int T,n,k,a[200005],b[200005],ans,l,r;
int main(){
	scanf("%d",&T);
	while(T--){
		scanf("%d%d",&n,&k);
		int len=(n+k+1)/2;
		for(int i=1;i<=n;i++)scanf("%d",&a[i]),b[i]=a[i];
		
		ans=2147483647;
		sort(a+1,a+n+1);
		for(int i=len;i<=n;i++){
			if(a[i]-a[i-len+1]<ans){
				ans=a[i]-a[i-len+1];
				l=a[i-len+1];
				r=a[i];
			}
		}
		
		printf("%d %d\n",l,r);
		int cnt1=0,cnt2=0,last=1,cnt=0;
		for(int i=1;i<=n;i++){
			if(b[i]<=r&&b[i]>=l)cnt1++;
			else cnt2++;
			if(cnt1>cnt2&&cnt<k-1){
				printf("%d %d\n",last,i);
				last=i+1;cnt1=cnt2=0;cnt++;
			}
		}
		printf("%d %d\n",last,n);
	}
	return 0;
}
```
