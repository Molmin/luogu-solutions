### description :

- 多组输入。

- 每组输入一个 n，表示派对的人数，人与人之间有朋友关系，关系是相互的，关系由你自己定。

- 如果有人的朋友离开了，那么他的朋友数会减少，首先有0个朋友的人离开，然后在剩余的人中有1个朋友的人离开，以此类推，最后是剩余的人中有 $(n-1)$ 个朋友的人离开。

请你构造出一种关系网，使得最终剩余的人最多，输出最多的人数。

### solution :

首先通过理解题意，我们需要知道：**一个人假如要留下来，那么他的朋友中至少要离开一个** 。为什么，如果他的朋友一个都不离开，那么他的朋友数就不会变，不变的话就迟早会被 $0,1,2...,n-1$ 这样扫到。于是**我们需要牺牲尽量少的部分来保全剩下的** 。 并且**每一个牺牲的人的朋友数都要小于剩下的人的朋友数** ，不然剩下的人就会先离开。

如人数小于等于了2，无论怎么安排，都没法留人，直接输出0，这个自己试一下就知道了。

假如总共有 n 个人，我们牺牲一个人，为使剩下的人全部有可能留下，他需要与其他每一个人都为朋友，这样他就有 $(n-1)$ 个朋友，这样显然是不行的，因为一个人最多只有 $(n-1)$ 个朋友，其他人不可能比他再多了。

假如我们牺牲两个人，1和2。那么我们可以构造这样一种情况：1与 $3 \sim n$ 都为朋友，2与 $3 \sim n$ 也为朋友，$3 \sim n$ 之间互为朋友。

关系如下图

![](https://cdn.luogu.com.cn/upload/image_hosting/7fmb47ed.png)

这样安排有什么好处呢，对于要牺牲的1和2，他们每人都有 $(n-2)$ 个朋友，而对于 $3 \sim n$ 中的每一个都有 $(n-1)$ 个朋友，当轮到 $(n-2)$ 个朋友的人离开时，1和2离开了，那么接下来 $3 \sim n$ 中的每一个人的朋友数就变成了 $(n-3)$，于是他们就可以留下来了。

于是最少牺牲两个人就可以使得剩下的人留下，直接输出 $(n-2)$ 即可。

代码如下：

代码实现比较简单所以没写注释。


```cpp
#include<bits/stdc++.h>
using namespace std;
#define in inline
#define ll long long

in int read()
{
	int w=0,r=1;
	char ch=getchar();
	while(!isdigit(ch))
	{
		if(ch=='-')r=-1;
		ch=getchar();
	}
	while(isdigit(ch))
	{
		w=(w<<1)+(w<<3)+(ch^48);
		ch=getchar();
	}
	return w*r;
}

int T,n;

int main()
{
	T=read();
	while(T--)
	{
		n=read();
		if(n<=2)
		{
			puts("0");
		}
		else
		{
			cout<<n-2<<endl;
		}
	}
	return 0;
} 
```

构造方法可能不止一种，我这里只是给出了一种可行解。

如有错误或问题，请指出。