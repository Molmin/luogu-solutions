[书海扬帆的博客](www.ljhedp.cn)

这道题目是一道非常经典的贪心问题。由于n的位数非常多，而且删除操作改变的是每个数位，所以我们非常自然地能想到用字符串来存储n。

接下来我们来思考贪心策略， 首先我思考的是，将字符串中最大的s个数字都删去，但是我发现我是错的。比如36251314这个字符串，要删去2位的话，就不应该删6和4，而应该删6和2。综上所述，我们可以得出本题目的贪心策略：从高位到低位搜索，如果各位数字均递增，则删去最后一个数字，否则删除第一个递减区间的首字符。举个栗子，如果1234567要删除2位的话，我们必定是删除6和7，而3654321如果要删除2位的话，我们则要选择删去6和5.

重复以上过程s次，剩下的数字串便是问题的解了。

这里再谈一下0的问题，由于前导0不能输出~~（你见过有人把123写成0123或是000123嘛）~~所以我们再来一个布尔变量flag来记录每一位是否为0.但是这个时候还出现了一个问题，就是这个字符串被删除完了，只剩下一个0怎么办？比如说样例7，10删除1位之后，我们还是必须要输出0的。因此我们再建立一个cnt变量来存储输出的数字的个数。如果个数为0，那么说明整个字符串均为0，此时我们还需要输出一个0.

话说了这么多，你应该能看懂了吧，下面分享下代码。

```cpp
#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <cmath>
#include <algorithm>
#include <cstring>
#include <string>
using namespace std;
char n[500];
int s,len;
bool flag;
int main(){
    scanf("%s",&n);//读入数据
    for(int i=0;i<500;i++) if(n[i]!='\0') len++;//计算字符串长度
    cin>>s;//读入数据，我们一共要删除s个字符
    for(int i=1;i<=s;i++){
        for(int j=0;j<len-1;j++)//从字符串的第一个字符开始查找，len是字符串的长度
            if(n[j]>n[j+1]){//如果找到了递减区间
                for(int k=j;k<len-1;k++) n[k]=n[k+1];
                //那么就删除字符串n的第j个字符，后面字符往前调整。
                break;
            }    
            len--;//由于已经删除了一个元素，所以长度-1
        }
        int cnt;//记录被输出字符的个数
        for(int i=0;i<len;i++){
            if(n[i]!='0') flag=true;//如果不是0，则说明可以输出，flag=1
            if(flag) cout<<n[i],cnt++;//如果可以输出那就输出，同时个数增加1
    }
    if(cnt==0) cout<<0;//如果啥都没输出，就说明整个字符串都是0，此事我们还要输出一个0
    return 0;//愉快地结束了
    }
```
谢谢大家，再次说下我的博客，[书海扬帆的博客](www.ljhedp.cn)，网址是www.ljhedp.cn, 欢迎访问！
