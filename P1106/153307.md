思路上大体是一样的，只不过我的写法有点神奇...

思路：从前往后删，保证到这个地方为止是单调递增的，删到次数用完或数列被删完为止

比如样例：175438 4

最开始：1

然后7进来，满足单调递增，继续。

5进来，不满足了，将7删掉，此时我们还能删3次，序列为15

4进来，将5删掉，还能删2次，序列为14

3进来，4删掉，还能删一次

8进来，此时虽然满足单调递增，但是我们还能删除一次，所以不输出它

最终答案为13

详见代码

```
#include<bits/stdc++.h>
using namespace std;
char c[251];//定义一个字符数组
int main(){
	int n,len,t;
	cin>>c;
	cin>>n;//输入删除次数
	t=len=strlen(c);//得到字符串长度，因为len的值会改变，所以再多定义一个t
	for(int i=0;i<len;i++){
		if(c[i]>c[i+1]){//如果不满足单调递增
			if(len>t-n){//如果还能够进行删除，即还没有删到n次 
				for(int j=i;j<len;j++)
					c[j]=c[j+1];//全部前移，删除当前数
				--len,i-=2;//len--表示长度减少，然后i-=2就是真正神奇的地方了
			}/*首先i原本是指向被删除的那个数的，现在它被删了，你的这一次i就不能++，这是减去的其中一个1，其次有可能原本被删数前面的那个数不会被删，但是前移后，它需要被删去了。如数据：133420 3。在下面详细解释*/
			else break;//如果没有删除的机会了，结束循环
		}
	}
	int i=0;
    while(i<=len-1&&c[i]=='0') i++;//删除前导零
    if(i==len) printf("0");//针对这种数据：100 1
	for(i;i<t-n;i++) cout<<c[i];/*输出。不管len为多长，反正我们只输出前t-n位。这样就解决了到了最后虽然是单调递增但是还有删除机会的情况*/
	return 0;	
}
```

数据：133420 3

前四位1334都满足单调递增

2进来，删除4

此时因为i减了2，所以程序能够发现又不满足单调递增了，所以删掉两个3

最终答案为120。所以是需要减2的。