貌似比前面的题解简单一些

不知道有没有参加过南通2018国庆冲刺营的朋友？

当时应该是讲过这一题的（将那一课的貌似就是我们老师）

其实跟高精没有任何关系，可以自己举几个例子

可以发现**每一次删掉的数，刚好是非下降序列的最后一个**，并且是顺序的（就是直接从前往后判断）

比如193756，先删9

然后13756，删7

然后1356，删6

......

外面是1~k的循环，里面枚举字符串的每一个数，判断是不是非下降序列的最后一个，如果是就删掉，记住要立即退出循环

输出很坑

判断前导0，并且要特判最后是一位数的情况

```cpp
#include<iostream>
#include<string>
using namespace std;
string n;
int k;
int main()
{
	cin>>n>>k;
	for(int i=1;i<=k;i++)
	for(int j=0;j<n.size();j++)
	if(n[j]>n[j+1]){n.erase(j,1);break;}
	//判断，前面一个数比后一个数大。
   	//记得break写在if语句后面，而非整个j循环里面 
	int m=0;
	while(n[m]=='0')m++;
	//跳过前导0
	//如果只有最后一位数，注意特判
	if(m==n.size())cout<<0;
	else
	{
		for(int i=m;i<n.size();i++)
		cout<<n[i];//从非前导0的位开始输出
	}
	
	
	cout<<endl;//好习惯
	return 0;
}

```
