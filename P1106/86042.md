萌新放弃一次，总提交8次悟出来的贪心题解，大佬轻喷……

考完某次考试，删数题目满分，突然想起洛谷有这么一道题，喜滋滋地来刷双倍经验，结果提交四次才过……



------------


话不多说，先从样例分析：
175438，删4个数，得13

### **1.一个数要最小，高位得尽量小对吧，那么如果某位数比后一位数大，果断删去！维护一个最长不下降子序列（且字典序最小），可以保证前面的数尽量小。**

所以，分析175438：

1比7小，过。

7比5大，删7，得15438，k=3。

5比4大，删5，得1438，k=2。

4比3大，删4，得138，k=1。

3比8小，过。

8后没数了，过。

此时175438 -> 138，k -> 1。

是个最长不下降子序列，但不是我们要的。


------------


于是……

### **2.当删完数后，若k!=0，则只输出前(n-k)个数，删去后k个数**

所以，分析138：

n=3，k=1。

n-k=2。

输出13，拦截下8。

这样程序就可以过样例了，但……

提交，72分，WA两个点。

萌新WA的一声哭了出来！

现在肿么办啊QAQ……

表急，擦擦眼泪，看看测试信息

…………

…………

…………



----------------


输出的数最高位是0啊啊啊！！！

### **2.5那我保留0前面的1个数？**

改一改，72 -> 50

emmmm…………………………

重新看看测试点内容（之前没找到在哪下载测试点）……

500074897 2 -> 4897

…………

坑爹呢这是！

不是删2个数吗？

怎么删了5个？！

冷静了一下，我发现……

500074897 （删2个数5，7） -> 0004897 （忽略前导0） -> 4897！

--------------------

So……

### **3.在输出时，如果还未输出一个大于0的数而当前需输出0,则跳过0。（忽略前导0）**

再改，50 -> 84

依然不是满分……~~元芳，你怎么看？~~

最后一个测试点说我的输出太短？

下载测试点，仔细一看，10 1 -> 0。

------------

因为跳过前导0,所以我根本没有输出任何东西！

那么……

### **4.当发现什么都没有输出而程序即将return 0时，最后的抢救——输出0！**

提交，满分！

贪心思路的推导——完结撒花～

附上AC代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[510000],n,k;
void input(),work(),output();
int main()
{
	input();
	work();
	output();
	return 0;
}
void input()
{
	char c[510000];
	scanf("%s",c);
    scanf("%d",&k);
    n=strlen(c);
	for(register int i=0;i<n;++i)
		a[i+1]=c[i]-'0';
}
萌新的贪心开始辣！QAQ
void work()
{
	for(register int i=1;i<n;++i)
	{
		if(k==0) break;
		if(a[i+1]<a[i])
		{
			for(register int j=i;j>=1;--j)
			{
				if(k==0) break;
				if(a[j]==-1) continue;
				if(a[j]>a[i+1])
					a[j]=-1,k-=1;
				else
				
					break;
			}
		}
	}
	for(register int i=n;i>=1;--i)
		if(a[i]!=-1) 
			if(k==0)
				break;
			else
				a[i]=-1,k-=1;
}
萌新的贪心完成辣！QVQ
void output()
{
    int f=1,p=1;
	for(register int i=1;i<=n;++i)
    {
        if(a[i]==0&&f==1) continue;
        if(a[i]!=0&&a[i]!=-1) f=0;
        if(a[i]!=-1)
			printf("%d",a[i]),p=0;
    }
    if(p==1) printf("0");
	printf("\n");
}
```
