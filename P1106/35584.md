说实话，这道题真的做到我绝望

思想主要是，既然是删数，那不如简化一下问题，变删数为选数。

且读入字符串时，给它转换为数字

这是一个贪心思想，高位尽量选小的，但是顺序又不能改变

##所以循环时边界条件不是数的长度，而是长度-还剩的要选的个数

但是打起来，我连续犯了很多错误：

首先，最后一个数据是有误的，与题意不符，会输出0，这个输出是需要特判一下。

下面是我犯的所有错误，希望大家引以为戒

1、在暴力模拟每个数时，一失误把条件在循环内改变了，于是整个输出简直都要爆炸。

2、题意没彻底理解透，对于前导0的问题，我以为是有前导就不能选，然而不是那样，是选完再删去前导0（重点），也就是说读入10位数要求删去5位，如果里面有0，输出不一定是5位！

3、最后的输出，还是删前导0的问题，一开始我是判断只要出现前导0，i自加，然而那样输出会少一位（低级错误），所以应该是跳过：continue。

4、导致我做了将近半小时的原因是：代码乱。这个应该是所有比赛最忌讳的，因为这样及其难差错，所以，以后还是发挥一下强迫症吧= =


于是，混乱的代码：

    
    
    
    
    
     
```cpp
#include<stdio.h>
#include<string.h>
int main()
{
    char n[255];//字符串读入
    int k;
    int i,j,t=0,f=1,t2=1//t2，解决循环变量问题
    char min;
    int a[255],b[255],p;//a用来转换，b用来输出
    scanf("%s",n);
    scanf("%d",&k);
    for(i=0;i<strlen(n);i++) a[i+1]=n[i]-'0';//转换为数字好算
    p=strlen(n); int s=p-k;//s为还需选数的个数
    for(i=1;i<=p-k;i++)
    {
        min=10;
              for(j=1;j<=p-s+1;j++)//p-s+1，p-(s-1)的化简，求出可以循环的边界，避免到最后无数可选
        {
            if(a[j]<min){min=a[j]; t=j;}//求最小。可以看出t在改变，所以后面要赋值给t2
        }
        s--;
        b[i]=a[t];
        t2=t+1;
        f++;
    }
    i=1;
    int flag=0;
    for(i=1;i<=f-1;i++) 
    {
        if(f-1>1&&flag==0&&b[i]==0) continue;//去前导0，只要flag为假，就说明此时的0是前导0，不输出。f-1>1为了过最后的数据
       else
       {
           flag=1;
          printf("%d",b[i]);
         }
      }
    return 0;//泪奔，一道如此之难的贪心，模拟题
}
```