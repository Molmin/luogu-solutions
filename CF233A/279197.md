这道题是一道典型的奇偶分析加构造的题目。只要分析出构造的方法就迎刃而解了。
## 题目大意

现有一个 $1\sim n$ 的排列 $p_1,p_2,\ldots,p_n$。

$\text{Nickolas}$ 喜欢排列，他认为有一种排列是完美的。用 $p_i$ 表示排列中的第 $i$ 个元素，则完美的排列符合如下性质：
1. $p_{p_i}=i$   
2. $p_i≠i$

现在给出 $n$ 的值，请求出这个完美的排列。如果排列不存在，输出 $-1$。
## 大体思路
这道题是一道构造的题目，首先来分析 $n=1$ 的情况：显然此时 $i=1$，因此满足 $p_{p_i}=i$，则 $p_1=1$，矛盾。

接下来看 $n=2$ 的情况：此时 $i∈[1,2]$，由题意得 $p_1≠1$，$p_2≠2$，且 $p_{p_2}=2$，$p_{p_1}=1$。因此 $p_{p_2}=p_1$，$p_{p_1}=p_2$。也就是说，$p_2=1,p_1=2$。

由此可以推导到全部的情况：$∀i,j∈[1,n]$，满足 $p_i=j, p_j=i$，此时 $p_{p_i}=p_j≠i,p_{p_j}=p_i≠j$，当且仅当 $i≠j$ 成立。因此要使每一组 $i,j$ 都不相等，条件为 $n$ 是偶数，即$n≡0\pmod 2$。

构造方法为：

1. 令 $i=1,j=n$，也就是说 $p_1=n,p_n=1$，然后 $i+1,j-1$，这样构造出来的就是 $1\sim n$ 的倒序排列。

2. 令 $i=1,j=2$，$p_1=2,p_2=1$，然后 $i+2,j+2$，相当于每次交换$1\sim n$的有序排列中的元素 $(p_1,p_2),(p_3,p_4)\ldots (p_n-1,p_n)$，构造出形如 $2,1,4,3\dots (n-2),(n-3),n,(n-1)$ 的数列。

## 完整代码
第一种构造法的代码：
```cpp
#include<bits/stdc++.h>//头文件
using namespace std;
int main(){
   int n;
	cin>>n;//输入
	if(n%2==1)//一切的先决条件为n为偶数，
    //因此n为奇数直接输出-1
		cout<<-1;
	else{
      for(int i=n;i>=1;i--) 
         cout<<i<<" ";//倒序输出1~n
    }
	return 0;//完美
}
```

第二种构造法：
```cpp
#include<bits/stdc++.h>//头文件
using namespace std;
int main(){
   int n;
	cin>>n;//输入
	if(n%2==1)
		cout<<-1;//同上
        //n为奇数直接输出-1
	else{
      for(int i=1;i<=n;i+=2) //注意每次+2
          cout<<i+1<<" "<<i<<" ";
          //相当于交换相邻两数并输出。
    }
	return 0;//完美
}
```
