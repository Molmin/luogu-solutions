首先，要看透本质，由于它每次都只在环中选取长度为 $n$ 的子串，只要按照顺序，这题就有点像一道题：滑动窗口。

两题之间区别不小，但可以提取中一个整体思路：队列。

每滑动一次，队首出队，队尾进队。

此时我们便可以推出让相邻两个窗口的和相差不超过 1 的方法：让入队的元素和出队的元素相差不超过 $1$。

设出队的元素在第 $i$ 位，则入队的元素在第 $(i+n)$ 位。所以我们需要让第 $i$ 位和第 $(i+n)$ 位相差不超过 $1$。

由于两两之间相差不能超过 $1$，所以我们不能在两次滑动时连续加 $1$ 或连续减 $1$。当 $n$ 为偶数时无法满足这点，便无解。

设环拆开后形成的序列为 $A$，则可以得到：当 $i \mod 2 = 1$ 时，$A_i = 2i-1,A_{i+1} = 2i$；否则 $A_i = 2i,A_{i+1} = 2i-1$。

问题得解。

C++代码：
```cpp
#include <cstdio>
using namespace std;
void readInt(int &x){
	char c;
	while((c=getchar())<'0' || c>'9');
	x=(c^48);
	while('0'<=(c=getchar()) && c<='9'){
		x=x*10+(c^48);
	}
	return;
}
int a[200001];
int main(){
	int n;
	readInt(n);
	if(n&1){
		puts("YES");
		for(int i=1;i<=n;++i){
			if(i&1){
				a[i]=2*i-1;
				a[i+n]=2*i;
			}else{
				a[i]=2*i;
				a[i+n]=2*i-1;
			}
		}
		for(int i=1;i<=2*n;++i){
			printf("%d ",a[i]);
		}
		puts("");
	}else{
		puts("NO");
	}
	return 0;
}
```