本文同步于[CF1206总题解](https://www.luogu.org/blog/zhouzikai/cf1206round-580-div2-post)，欢迎各路神仙来踩。

## C Almost Equal
### 题意
将$1-2n$这$2n$个数按圆环排列，记每$n$个连续的数相加的和为$S_1,S_2,...,S_n$，要使得$\forall i,j\in[1,n],|S_i-S_j|\le 1$，求出一种合法的排列。
### 解法
1. 算法1

我们先考虑$|S_i-S_{i+1}|\le 1$

$S_i=a_i+a_{i+1}+...+a_{i+n-1}$

$S_{i+1}=\ \ \ \ \ a_{i+1}+a_{i+2}+...+a_{i+n}$

$|S_i-S_{i+1}|=|a_i-a_{i+n}|\le 1$

因为$1-2n$这些数互不相同，并且每$n$个数的和满足上述要求，所以在合法排列中（设为$a$），一定满足$|a_i-a_{i+n}|= 1$

我们再考虑$|S_i-S_{i+2}\le 1|$

$S_i=a_i+a_{i+1}+a_{i+2}+...+a_{i+n-1}$

$S_{i+2}=\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ a_{i+2}+a_{i+3}+...+a_{i+n+1}$

$|S_i-S_{i+2}|=|(a_i-a_{i+n})+(a_{i+1}-a_{i+n+1})|\le 1$

我们发现如果$(a_i-a_{i+n})$和$(a_{i+1}-a_{i+n+1})$都是1或者都是-1，是不满足上述不等式的。

因此$(a_i-a_{i+n})$应该是交替为1,-1。

如果$n$为偶数，（手玩几下）可以发现是无法做到1,-1交替出现，即无解。

如果$n$为奇数，那么按照这个思路去构造即可。

我们可以把$1-2n$个数字分成如下$n$对：$(1,2),(3,4)...(2n-1,2n)$，把最后的结果分成两部分(记为$A,B$)，交替地在$A$中插入每一对数字的第一个数字和第二个数字，同时在$B$中插入同一数字对的另一个数，最后直接将$B$接在$A$的后面。

上面写的比较抽象，我们举一个实例：$n=5$：

$A:1,4,5,8,9$

$B:2,3,6,7,10$

答案为$1,4,5,8,9,2,3,6,7,10$

2. 算法2（应该是实现方法2）

由观察得，上述填数过程有规律可循：还是分一半(我们还是记为$A,B$)，先在$A$中填一个1，然后到$B$中填$2,3$，然后再到$A$中填$4,5$……最后把$2n$填到$B$的最后。
### 代码实现
1. 算法1

同样，这里省略头文件，快速读入，输出，相信能看到这道题目的人应该都会这些东西。
```cpp
int A[100005],B[100005],ta,tb,n;
int main(){
	read(n);
    if(n&1){
    	puts("YES");
        for(int i=1;i<=n;i++){
        	if(i&1)A[++ta]=(i*2-1),B[++tb]=(i*2);
            else   A[++ta]=(i*2),B[++tb]=(i*2-1);
        }
        ...//输出
    }
    else{puts("NO");}
    return 0;
}

```

2. 算法2

```cpp
int A[100005],B[100005],ta,tb,n;
int main(){
	read(n);
    if(n&1){
    	puts("YES");
        A[++ta]=1;
        for(int i=1;i<n;i++){
        	if(i&1)B[++tb]=(i*2),B[++tb]=(i*2+1);
            else   A[++ta]=(i*2),A[++ta]=(i*2+1);
        }
        B[++tb]=2*n;
        ...//输出
    }
    else{puts("NO");}
    return 0;
}

```