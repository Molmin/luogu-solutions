以下内容中“字符串”和“序列”含义相同，“答案”和“子序列个数”含义相同。

### 题意

给定 $n$，构造字符串 $s$，使 $s$ 中能表示为某个串复制两份的子序列恰有 $n$ 个。$1\le n \le 10^{12}, 1\le |s| \le 200$。解必然存在。

### 思路

看到构造题，数据范围又这么神秘，直觉告诉我这和其它一些乱搞题（如 [UR #6 智商锁](https://uoj.ac/problem/75)）类似，都是先处理出什么东西再构造。于是尝试处理些东西。

然后发现，当左侧与右侧互相之间没有相同字符时，符合条件的子序列个数就是左侧的加上右侧的。于是考虑预处理一些串和它们的子序列个数，并将 $n$ 分解为这些数的和。

### Part 1 计算某个串合法子序列个数

这个还是有些必要讲的。~~听说有人不会写这题 spj？~~

考虑枚举复制后右侧的第一个字符的位置，然后设 dp 状态 $dp_{i,j}$ 表示左侧最后一个字符在 $i$ 处，右侧最后一个字符在 $j$ 处的方案数，显然可以四次方做一遍，算上枚举就是五次方。不过可以使用前缀和优化，这样做一遍就是平方的，总复杂度是串长的三次方。

注意如果方案数很大（大于 $n$ 的上界）就可以直接返回不可行。

代码（注意代码中是枚举的右侧第一个字符的左侧一位）：

```cpp
typedef long long ll;
const int N=205;
const ll INF = 1e12;
ll dp[N][N];

ll calc(const vector<int> &a) {
	ll ans = 0; 
	int n = a.size();
	for (int i = 0; i + 1 < n; i++) {
		for (int j = 0; j <= i; j++) memset(dp[j], 0, n * 8);
		for (int j = 0; j <= i; j++) if (a[i + 1] == a[j]) dp[j][i + 1] = 1;
		for (int l = 0; l <= i; l++) {
			for (int r = i + 1; r < n; r++) {
				if (a[l] == a[r] && l) {
					dp[l][r] += dp[l - 1][r - 1];
				}
				dp[l][r] += dp[l][r - 1];
				if (l) dp[l][r] += dp[l - 1][r] - dp[l - 1][r - 1];
				if (dp[l][r] > INF) return -1;
			}
		}
		ans += dp[i][n - 1];
		if (ans > INF) return -1;
	}
	return ans;
}
```

### Part 2 处理哪些序列

这个应该有很多种做法，我就稍微讲一下我的。

首先发现，全部相同的序列无法在限制内构造出 $n$。分析原因，发现是每次使 $n$ 减小时减小的不够多。因此考虑多处理些序列，让答案分布的比较近。

之后实际测试得到，仅有两种字符的串就已经很均匀了，也能发现在串长为 $53$ 左右时答案就在 $10^{12}$ 左右。因此从小到大枚举串长，每个串长随机大约 $800$ 个串并计算答案，如果答案没出现过就扔进 map 里。这样可以在 1s 左右跑完预处理。

代码：

```cpp
mt19937 rnd(20220921);
for (int n = 2; n <= 53; ++n) {
	vector <int> a(n, 0);
	int lim = 800;
	for (int r = 0; r < lim; r++) {
		for (int i = 0; i < n; i++) a[i] = rnd() & 1;
		ll k = calc(a);
		if (k == -1) continue;
		if (mp.find(k) == mp.end()) {
			mp[k]=a;
		}
	}
}
```

### Part 3 构造序列

之后对于某个 $n$，找到答案离它最近且小于它的某个序列，并加入到最终序列中。实际测试中我没有发现构造序列长于 $170$ 的 $n$，然后这题就做完了。

代码就不放了，很简单。

### 题外话

还是太菜，只会实际测试，根本不会分析错误概率。但这题既然范围这么宽，乱搞解法也是好的（）

官方题解怎么构造序列长 $80$ 就够。完了真的被吊打了。
