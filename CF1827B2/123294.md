### *[CF1827B2 Range Sorting (Hard Version)](https://www.luogu.com.cn/problem/CF1827B2)

先求一个序列的权值：将贡献拆到每个间隔 $i - 1\sim i$ 处。间隔 $i - 1\sim i$ 产生贡献当且仅当 $a_1\sim a_{i - 1}$ 的最大值大于 $a_i\sim a_n$ 的最小值，因为无论如何都要有间隔后的元素换到间隔前。

枚举间隔 $i - 1\sim i$ 和区间左端点 $j < i$。设 $v = \max a_{j\sim i - 1}$。

- 若 $v \geq a_i$，则 $i\sim n$ 作为右端点均合法。
- 若 $v < a_i$，则 $p\sim n$ 作为右端点合法，其中 $p$ 为 $i$ 之后第一个小于 $v$ 的位置，若不存在则为 $n + 1$。

暴力的时间复杂度为 $\mathcal{O}(n ^ 3)$。

两个优化：

- 维护递增单调栈（只有单调栈内的元素可能成为最大值），若栈顶 $j_1$ 满足 $a_{j_1} < a_i$ 则弹出。

  设弹出前栈顶下方的元素为 $j_2$，则 $j_2 + 1\sim j_1$ 每个位置作为左端点时，与 $i - 1$ 之间的最大值均为 $a_{j_1}$，即 $\max a_{j\in [j_2 + 1\sim j_1]\sim i - 1} = a_{j_1}$。

  不断弹出直到 $a_{j_1} > a_i$，此时答案加上 $j_1 (n - i + 1)$，因为 $i\sim i + 1$ 在左端点属于 $[1, j_1]$，右端点属于 $[i, n]$ 的区间中产生贡献。

- 将所有形如 “$i$ 之后第一个小于 $a_j$ 的位置” 的查询 $(j, i)$ 离线下来倒着扫描线。维护权值线段树 $T$ 表示值 $p$ 对应的下标，查询相当于前缀 $\min$。单点 $\min$ 前缀求 $\min$ 也可以用树状数组维护。

加任意一个优化可通过 B1，加两个优化可通过 B2。

时间复杂度 $\mathcal{O}(n\log n)$。[代码](https://codeforces.com/contest/1827/submission/205930118)。

注意到 **$i$ 是 $j$ 后第一个大于 $a_j$ 的位置**，考虑在扫描线的过程中维护一个从栈顶到栈底下标递增且值递减的单调栈。$i + 1\to i$ 时，将 $a_{i + 1}$ 加入单调栈，然后按 $j$ 从小到大的顺序（$a_j$ 递减）考虑询问 $(j, i)$。弹出单调栈栈顶直到栈顶对应权值小于 $a_j$，则栈顶即为查询答案。

若某个询问 $(j, i)$ 弹出了元素 $a_p$，则 $(j' > j, i)$ 答案显然不为 $p$。只需证明不存在 $(j', i' < i)$ 的答案为 $p$。

> 若 $i' < j$，则因为 $a_j < a_p$，所以 $p$ 一定不会是 $(j', i')$ 的答案（$j$ 可以作为答案）。
>
> 若 $i' = j$，则因为 $a_{j'} < a_{i'} = a_j < a_p$，所以 $p$ 一定不会是 $(j', i')$ 的答案。
>
> 若 $j < i' < i$，那么 $a_{i'} < a_j$，否则 $j$ 后第一个大于 $a_j$ 的位置不可能是 $i$。所以 $a_{j'} < a_{i'} < a_j < a_p$，$p$ 一定不会是 $(j', i')$ 的答案。$\square$

时间复杂度 $\mathcal{O}(n)$。[代码](https://codeforces.com/contest/1827/submission/205972579)。