考虑容斥。

然后拆贡献。考虑当 $\max(a_l, a_{l+1},...,a_{i}) \leq \min(a_{i+1}, a_{i+2},...,a_r)$ 时，那么 $i$ 和 $i+1$ 之间是不需要交换的，有 $-1$ 的贡献。

至此我们可以得出一个 $O(n^2)$ 的做法：

枚举分界点 $i$，从 $i \sim 1$ 枚举左端点 $l$，求出对于当前左端点 $l$ 在 $i$ 之后第一个满足 $ a_r < \max(a_l, a_{l+1},...,a_i)$ 的 $r$，记为 $f_l$。 那么 $i+1 \sim r-1$ 都是合法的右端点。注意到 $\max(a_l, a_{l+1}, ..., a_i)$ 单调不降，所以可以双指针解决。

考虑优化。

枚举前半段的最大值的位置 $x$，通过单调栈求出 $x$ 前第一个比 $a_x$ 大的位置 $pre_x$，$x$ 后第一个比 $a_x$ 大的位置 $suf_x$。所以前半段的左端点的范围是 $pre_x + 1 \sim x$。这时发现，当右端点取 $x+1 \sim suf_x-2$ 时，后半段对应的 $f_l=x+1$。那么此时 $x$ 是没有贡献的。所以前半段的分界点必然是 $suf_x-1$。那么右半段的右端点就应该是 $suf_x \sim f_x - 1$。所以总的贡献为 $(x - pre_x)\times (f_x - suf_x)$。

$f_x$ 可以通过线段树简单求得。

复杂度 $O(n\log n)$。