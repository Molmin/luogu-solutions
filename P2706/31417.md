# 用极大化思想解决最大子矩阵问题


**最大子矩形问题：** 在一个给定的矩形网格中有一些障碍点 ，要找出网格内部不包含任何障碍点 ，且边界与坐标轴平行的最大子矩形。

## 定义：

**极大子矩形：** 一个极大子矩形的四条边一定都不能**向外扩展** 。更进一步地说 ，一个有效子矩形是极大子矩形的充要条件是这个子矩形的每条边要么**覆盖了障碍点** ，要么**与矩形边界重合**。

**有效竖线：** 除了两个端点外 ，不覆盖任何障碍点的竖直线段。

**悬线：** 上端点覆盖了一个障碍点或达到整个矩形上端的有效竖线。 

## 解决方法：

如果把一个极大子矩形按 $x$ 坐标切割成多个（实际上是无数个）与y轴垂直的线段 ，则其中**一定存在一条悬线**。

一条悬线通过**尽可能地向左右移动**恰好能得到一个子矩形（未必是极大子矩形，但只可能向下扩展）。

因此我们可以得到一个非常重要的**定理：**

如果将一条**悬线**向左右两个方向**尽可能移动**所得到的有效子矩形称为这个悬线所对应的子矩形 ，那么所有悬线所对应的有效子矩形的集合一定包含了所有极大子矩形的集合。

因此 ，通过枚举所有的悬线 ，就可以枚举出所有的极大子矩形。

## 算法实现：

悬线的数量为 $(n-1)*m$ ，如果能做到对每条悬线的操作时间都为$O(1)$ ，那么整个算法的复杂度就是$O(NM)$

我们知道，每个极大子矩形都可以通过一条悬线左右平移得到。

所以 ，对于每个确定了底部的悬线 ，我们需要知道有关于它的三个量：**顶部、左右最多能移动到的位置**。

对于底部为 $(i,j)$ 的一条悬线，设它的高为 $h[i,j]$ , 左右最多能移动到的位置分别为   $l[i,j]$ , $r[i,j]$。

为了充分利用以前得到的信息，我们将使用**递推**的方式得到这三个参数。

**对于以点 $(i,j)$ 为底部的悬线：** 

如果点 $(i,j)$ 为障碍点，那么其高度显然为 $0$。在此我们可以假设其左右均可以移动到整个矩形的左右边界 ，因为其高度为 $0$  , 不会影响答案 ，这样的处理方便了后面的递推

```cpp
当 (i,j) 为障碍点时
h[i,j]=1
l[i,j]=0
r[i,j]=m
```


如果点 $(i,j)$ 不为障碍点，那么其高度为以点 $(i-1,j)$ 为底部的悬线的高度 $+1$ 。接着我们考虑其左右可以移动的距离 ，此时 $(i,j)$ 对应的悬线左右能移动的位置要在 $(i-1,j)$ 的基础上变化 , 即 

$l[i,j]=$ $max$ $( l[i-1,j]$ $,$ $(i-1,j)$左边第一个障碍点的位置$)$ 

$r[i,j]$ 的求法类似

综合起来，可以得到这三个参数的递推式：

```cpp
当 (i,j) 不为障碍点时
h[i,j]=h[i-1,j]+1
l[i,j]=max( l[i-1,j] , (i-1,j)左边第一个障碍点位置, 边界0也是障碍点 )
r[i,j]=min( r[i-1,j] , (i-1,j)右边第一个障碍点位置, 边界m也是障碍点 )
```


通过**递推** ，我们充分利用了以前得到的信息 ，使每条悬线的处理时间复杂度降至$O(1)$

对于以点 $(i,j)$ 为底的悬线对应的子矩形 ，它的面积为 $(r[i,j]-l[i,j]+1)*h[i,j]$

这样最后问题的解就是:

$ans=max(ans ,(r[i,j]-l[i,j]+1)*h[i,j]) $ 

这里默认求的是最大面积 ，具体题目要具体分析 ，比如此题就应该写成：

$ans=max(ans,s[i][r[j]]-s[i][l[j]-1]-s[i-h[j]][r[j]]+s[i-h[j]][l[j]-1])$ $(s$为二维前缀和$)$

至此 ， **最大子矩形问题**已被解决 ，整个算法的时间复杂度为 $O(NM)$ ，空间复杂度为 $O(NM)$ , 当然 ，我们发现二维数组中的第一维完全是多余的 ，因此空间复杂度可降为 $O(M)$

**本题AC代码：**

```cpp
#include <bits/stdc++.h>
using namespace std;
const int maxn=305;
int ans,n,m,h[maxn],l[maxn],r[maxn],la,ra,s[maxn][maxn];
bool mp[maxn][maxn];
int main(){
    scanf("%d%d",&n,&m); 
    for(int i=1;i<=n;i++)
    	for(int j=1;j<=m;j++){
    		scanf("%d",&s[i][j]);//此题数据有锅，用快读会TLE…… 
    		if(s[i][j]==0) mp[i][j]=1;//如果s[i][j]为零，则这个点是障碍点 
    		s[i][j]+=s[i-1][j]+s[i][j-1]-s[i-1][j-1];//维护前缀和 
		}
	for(int i=1;i<=m;i++) l[i]=1, r[i]=m;//预处理，假设每个点都能走到矩形的左右两端 
    for(int i=1;i<=n;i++){
        la=0, ra=m+1;//0和m+1也是障碍点 
        for(int j=1;j<=m;j++){
            if(mp[i][j]) la=j, h[j]=0, l[j]=1;
            else h[j]++, l[j]=max(l[j],la+1);
        }
        for(int j=m;j;j--){
            if(mp[i][j]) ra=j, r[j]=m;
            else r[j]=min(r[j],ra-1), 
			ans=max(ans,s[i][r[j]]-s[i][l[j]-1]-s[i-h[j]][r[j]]+s[i-h[j]][l[j]-1]);
			//利用前缀和把(r[j]-l[i]+1)*h[j]这一块矩形的值算出来 
        }
    }
    printf("%d\n",ans);
    return 0;
} 
```
