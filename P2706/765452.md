# P2706 题解

### 题目概括

有一块 $ N \times M $ 的区域，在第 $ (i , j) $ 的区域有 $ A_{i , j} $ 块巧克力，但是有一些部分被老鼠吃掉，因此需要选取一块没有被老鼠吃掉的部分，且这块区域中的巧克力数量最大。

### 题目分析

这道题目既然要求最大的部分，自然想到了最大子矩阵问题。但是接下来我将要呈现出一种全新的思路，只用两个前缀和数组即可解决。

再审视一遍题目，这道题关键就是有些部分被老鼠吃了而选取的部分不能有被吃掉的。常规思路就是挨个枚举，但是我们可以像前缀和一样用一个数组存被吃掉的部分，与前缀和的思路相同；接着再用一个数组存储巧克力。每次用二维区间和公式计算这片区域有没有被老鼠吃掉的部分，没有的话在求出巧克力数量并用一个 $ maxx $ 维护区间巧克力数量最大值。

### 代码时间

```cpp
#include<iostream>
using namespace std;
long long qzh[305][305] , yl[305][305] , xj[305][305];
//qzh：巧克力前缀和数组；yl：原来的数组；xj：被洗劫格子数量数组 
signed main()
{
	int n , m;
	cin >> n >> m;
	for(int i = 1 ; i <= n ; i++)
	{
		for(int j = 1 ; j <= m ; j++)
		{
			cin >> yl[i][j];
			if(yl[i][j] == 0) //如果值为 0，即被洗劫了 
			{
				xj[i][j] = xj[i - 1][j] + xj[i][j - 1] - xj[i - 1][j - 1] + 1;
			}
			else
			{
				xj[i][j] = xj[i - 1][j] + xj[i][j - 1] - xj[i - 1][j - 1] + 0;
				//等同于 xj[i][j] = xj[i - 1][j] + xj[i][j - 1] - xj[i - 1][j - 1]; 
			}
			qzh[i][j] = qzh[i - 1][j] + qzh[i][j - 1] - qzh[i - 1][j - 1] + yl[i][j];
			//前缀和公式 
			
		}
	}
	long long maxx = 0; 
	for(int i = 1 ; i <= n ; i++)
	{
		for(int j = 1 ; j <= m ; j++)
		{
			if(yl[i][j] == 0) //本身就被洗劫，那么这块巧克力自然不符合要求 
			{
				continue;
			}
			for(int x = i ; x <= n ; x++)
			{
				for(int y = j ; y <= m ; y++)
				{
					int xjgs = xj[x][y] - xj[i - 1][y] - xj[x][j - 1] + xj[i - 1][j - 1];
					//计算这片区域中有几块区域被洗劫 
					if(xjgs > 0) //如果有被洗劫的区域，那么这块巧克力自然不符合要求 
					{
						continue;
					}
					maxx = max(maxx , qzh[x][y] - qzh[i - 1][y] - qzh[x][j - 1] + qzh[i - 1][j - 1]);
					//更新最大巧克力数量 
				}
			}
		}
	}
	cout << maxx << endl;
   	return 0;
}
```

#### 后记：这篇题解算是一个比较新颖的做法了，代码和思路都比较简洁，所以做题也要善于发现新的方法，想出新的思路~