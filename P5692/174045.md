被卡常卡飞了/kk

不过还是先来发篇题解吧。

根据传统写题解之前先要写一堆废话对吧。

事情是这样的，我翻 Ynoi 题解的时候发现 lxl 说第四分块有分块做法，然后就想了一下。

想到某个地方卡住了，然后发现了这题，看了眼题解。

结果被那题卡常卡飞了（~~可以获得 $4$ 分的好成绩~~），所以就滚过来写这题。

------------
复述（雾）一下官方题解吧。

考虑分块。

对于答案在一个块内的情况显然可以预处理，如果不在一个块内的话，就维护每个块内每个数第一次和最后一次出现的位置，然后扫一遍，维护 $x$ 和 $y$ 各自最后一次出现的位置。然后对于散块也可以用类似的方法扫过去。

问题是你要是开一个 `f[i][j][k]` 表示第 $i$ 块内 $j$ 和 $k$ 最近的距离的话空间就是 $n^2\sqrt n$ 的。注意到每个块内只有 $\sqrt n$ 个数，所以可以使用类似于离散化的技巧，对于每个数，把它映射到一个标号，这样空间就是 $n\sqrt n$ 开得下了。

然后修改的话我们考虑类似于最初分块那个做法，对于整块的修改，如果同时含有 $x$ 和 $y$ 就重构，如果只含有 $x$ 不含有 $y$ 就打标记。这样的话对于每个块每次重构会使得块内颜色数减少一，而每次修改操作的边角暴力最多会使得 $O(1)$ 的块的颜色数增加 $O(1)$，所以说所有块的重构最多进行 $O(n)$ 次，所以是对的。

问题是如果我们直接像最初分块那样维护每个数变成了哪个数是哪个数变的的话对于 `f` 数组的处理就会很难受。想了想发现我是 sb，因为你都对于所有的数重新标号了所以实际上可以直接把 $y$ 的标号改成 $x$ 的。

但是对于 `f` 数组我们肯定不能直接重构。我在这里卡了挺久之后发现了这题然后看了下题解。其实对于每个 `j` 我们把 `f[i][j][id[i][y]]` 与 `f[i][j][id[i][x]]` 取 `min` 就可以了。

然后散块的 `f` 又不会处理了。注意到改变的 `f` 值只跟 $x$ 和 $y$ 有关，所以可以像查询那样扫一遍维护。

然后实现上的一些问题的话，首先 `f` 数组说过了，这里有个卡常技巧就是规定 $j<k$；`first` 和 `last` 数组就是第一次和最后一次出现的位置；`id` 数组代表每个数“离散化”之后变成哪个标号，然后我的写法还开了个队列或者栈类似于内存池一样地去维护没有用过的标号，标号减少时要记得 `push` 进去，不然要是一直加标号的话复杂度显然就错了。

然后有一些细节要注意一下，我调了两天。再就是比真 Ynoi 还要毒瘤的卡常。代码就不放了，一是因为太丑二是因为还没卡过去（捂脸）。要是有需要的话私信找我吧。

~~顺便吐槽一下 srz，他的题解说是去提交记录看代码，其实他根本没开代码公开。~~

然后应该就没有什么问题了。