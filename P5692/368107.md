[$\tt Link$](/problem/P5692) 与 [弱化版—第四分块](/problem/P5397)。

---

我们先来回顾一下第四分块的序列分块做法。

这个修改和 [最初分块](/problem/P4119) 一样，所以我们还是考虑从值入手维护一个**类似**于并查集的东西（并查集会让复杂度变高，所以我们和最初分块一样通过改良写法规避掉并查集）。

你想过直接维护一个块任意两个元素的最近距离，但是这时的空间是 $O(\sqrt n\times n^2)$ 的，所以要**块内离散化**，最后会维护以下几个数组。

以下的数组都是对于一个块而言的（即对于每种数组我们都要开 $\sqrt n$ 个来存每个块）

+ $id$ 数组代表 **实际值 $\to$ 离散化值**.
+ $val_i$ 代表 **离散化值 $\to$ 实际值**。
+ $pl,pr$ 代表 **一个离散化值在块内第一次/最后一次出现位置**。
+ $dis$ 代表 **两个离散化值的距离**。

修改对每个块分类讨论：

+ 有 $x$ 无 $y$：改 $val_{id_x}$ 为 $y$。
+ 有 $x$ 有 $y$：这时块内的颜色会 $-1$，而块内颜色最多减根号次就会到达 $1$，所以对于每个块这种修改的总次数是根号的，因此用 $O(\sqrt n)$ 的时间重构这个块。
+ 没有 $x$ 就跳过

查询也很好办：

+ 对于在一个块的答案，直接查表。
+ 不在一个块的答案，使用 $pl,pr$ 辅助统计。

这个写法是非常简单的，大概 $\texttt{1.9k}$（就是跑得慢）。

---

考虑这个题有哪些变化：**散块查询和散块修改**。

散块查询是很简单的，直接暴力遍历计算答案即可。散块修改就有点恶心人。

大体我们要干的事是更新 $dis$ 以及更新 $pl,pr$，更新 $pl,pr$ 的过程是平凡的取 $\min$ 或 $\max$，不说了。

更新 $dis$ 的过程可以理解为有 $\sqrt n$ 个位置 $[l,r]$，又有 $k$ 个位置 $b_{1\cdots k}$（$k\le\sqrt n$），然后你要计算出对于每个 $i\in[l,r]$，距离 $i$ 最近的 $b_j$ 的值。

这个很寻常，你直接从左到右再从右到左扫两次，计算最近的 $b_j$ 值就好了。

散块修改需要分类讨论，这里先记 $[l,r]$ 为散块，$[L,R]$ 为 **完全包含散块的那个整块**：

1. $[l,r]$ 无 $x$：跳过。
1. $[L,R]$ 无 $y$，$[L,R]$ 中除 $[l,r]$ 外无 $x$：改离散化值。
1. $[L,R]$ 有 $y$，$[L,R]$ 中除 $[l,r]$ 外无 $x$。
1. $[L,R]$ 无 $y$，$[L,R]$ 中除 $[l,r]$ 外有 $x$。
1. $[L,R]$ 有 $y$，$[L,R]$ 中除 $[l,r]$ 外有 $x$。

+ 对于 3 情况，你需要删除掉 $x$ 的离散化值。
+ 对于 4 情况，你需要给 $y$ 添加新离散化值。
+ 对于 4 情况，你需要初始化 $y$ 的 $dis$ 答案（全部设为 $\infty$）
+ 对于 3,4,5 情况，你需要更新 $y$ 的 $dis$ 答案（上述方法）
+ 对于 4,5 情况，你需要更新 $x$ 的 $dis$ 答案（上述方法）

---

关于实现，提几个注意事项。

+ 可以把 $dis$ 数组设为位置从小到大，即对于 $dis_{x,y}$ 只有当 $x\le y$ 才有用（优化常数）。
+ 可以把一些功能函数化（比如更新 $dis$，散块修改之类的）（写方便使用）。
+ $\tt WA$ 可以考虑调大/小块长，然后看看对的点有没有增多/变少，判断出是块内部分还是块间部分出问题。
+ **这题不卡常**（对非并查集写法而言），只要你没写错基本不会 $\tt TLE$。
+ **调块长没多大用**（对我而言），$\sqrt n$ 是跑的最快的，目前跑到 [$\tt\color{black}c\color{red}yffff$](/user/365127) 后的第二优解。

---

[$\tt Code$](https://www.luogu.com.cn/paste/z63atsw1)

$\texttt{3.7k}$（去快读等一些东西），可能是写过最长的分块。