本题是一道经典的贪心，用决策包容性求解，方法多样。

## 题目大意
有 $n$ 个商品，每个商品有利润 $p_i$ 和过期时间 $d_i$，每天只能卖一个商品，过期商品不能卖， 求如何安排每天卖的商品，使得利润最大。

## 大体思路
先来看一道弱化版：[UVA1316](https://www.luogu.com.cn/problem/UVA1316)。此题中 $1\le n,p_i,d_i\le 10^4$。一种显而易见的贪心策略是将利润从大到小排序，对于每个商品，在其过期之前尽可能晚地卖出。这样，该商品对其他商品具有“决策包容性”。

换句话说，对于利润为 $p$ 的商品，将其尽可能晚卖出。若其在 $d$ 时刻卖出，则 $d$ 时刻卖出其他商品利润显然小于 $p$，而该商品在 $d$ 时刻卖出对全局造成的影响最小，因此尽可能晚。

于是，我们用并查集维护时刻，起初每一天构成一个集合。对于每个商品，若其在 $d_i$ 天后过期，则查询 $r=root(d_i)$，如果 $r>0$ 则在第 $r$ 天卖出，并合并 $r$ 与 $r-1$，即令 $father(r)\leftarrow r-1$。

其本质是用并查集维护数组中位置的占用情况，时间复杂度 $O(n\log n+n\alpha(n))$，空间复杂度 $O(d)$。

__________

然而，对于本题 $p,d\le 10^9$，$O(d)$ 的空间复杂度显然不可行，因此考虑另一种贪心方法：按时间从小到大排序，并保证前 $d$ 天在不卖出过期商品的前提下卖出价值前 $d$ 大的商品。

具体地，将商品按 $d$ 从小到大排序，然后以商品价值为权值建立一个初始为空的小根堆。对于排序后第 $i$ 个商品，若 $d_i$ 比堆内元素数量大，即该商品能够在前 $d_i$ 天被售出，因此答案累加 $p_i$ 并将其入堆。否则，将 $p_i$ 与 $top$ 进行比较，若 $p_i$ 大则将 $top$ 弹出，并压入 $p_i$，更新答案。

最终，堆内商品价值之和即为答案。时间复杂度 $O(n\log n)$，空间复杂度 $O(n)$。

## 代码
```cpp
typedef pair<int, int> PII;
PII p[maxn];
int n; ll ans;
priority_queue <int, vector<int>, greater<int> > q; //小根堆
int main () {
	read(n);
	rep(i, 1, n){
		read(p[i].first);
		read(p[i].second);
	}
	sort(p + 1, p + n + 1);//输入+排序
	rep(i, 1, n) {
		int d = p[i].first, w = p[i].second;
		if(d > q.size()) q.push(w), ans += w;
        //若有空位直接入堆
		else {
			int v = q.top();//否则与堆顶比较
			if(v < w) {
				q.pop(); ans -= v;
				q.push(w); ans += w;
			}
		}
	}
	writeln(ans);
	return 0;
}
```