大佬们思路都说的非常清楚路，我来贡献一个相同思路使用 $set$ 进行实现的极简做法。（前面的题解中，有一个大佬提及了 $set$，但是思路貌似和我的有一定差异，而且他最后 $T$ 了……）

### 1. 贪心思想总结

这道题目的贪心思想很明确：

- 单位时间只能做一件工作，所以应该先考虑利润高的；
- 对于每件工作，应该尽量把它往后拖，这样剩下比较靠前的时间可以安排别的工作。

总结一下，我们只需要根据利润从高到低给工作排序，然后对于每件工作，我们尽量把它往后安排，即安排到 **最靠后** 并且 **不晚于其截止时间** 的时刻。

### 2. 实现方法

可以注意到，如果一个工作的截止时间大于 $N$，那么它 **一定可以被安排上**，所以我们只需要关心截止时间小于等于 $N$ 的工作即可。

我们可以使用一个 $set$ 存储当前所有的空闲时间，一开始，$1$ 时刻到 $N$ 时刻都是空闲的，即这个 $set$ 中存储了 $1$ 到 $N$ 中的所有数。

对于每个截止时间小于等于 $N$ 的工作，我们从这个 $set$ 中找到 **最大的** 且 **不晚于其截止时间** 的空闲时刻。如果存在，就意味着这个工作可以被安排上，我们从 $set$ 中删除这个时刻，并把这个工作的利润累加到答案中。

我们需要对所有工作排序。对每个工作，都可能涉及从 $set$ 中查找并删除元素的操作，所以这样做的时间复杂度为 $O(N \log N)$，可以轻松通过本题。

### 3. 代码实现

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <set>
using namespace std;
#define MAXN 100005
long long n;
// 工作，first为利润，second为截止时间
pair<long long, long long> k[MAXN];
long long ans;
// 用于存储空闲时刻的set
set<long long> s;
int main() {
    scanf("%lld", &n);
    for (int i = 0; i < n; i++) {
        scanf("%lld %lld", &k[i].second, &k[i].first);
    }
    // 根据利润进行排序
    sort(k, k + n);
    // 初始化set，加入1~N，因为开始时这些时刻都是空闲的
    for (long long i = 1; i <= n; i++) {
        s.insert(i);
    }
    // 按照价值从高到低考虑每件工作
    for (long long i = n - 1; i >= 0; i--) {
        // 对于截止时间小于等于n的工作，我们才需要考虑其是否能安排上
        if (k[i].second <= n) {
            // 从set中找到第一个【晚于】其截止时间的时刻
            // 这一时刻【之前】的那个时刻，就应该是我们安排这个工作的时刻
            auto it = s.upper_bound(k[i].second); 
            // 如果不存在（剩余时刻中的第一个时刻都晚于其截至时间了），就只能放弃
            if (it == s.begin()) {
                continue;
            }
            // 否则，安排上这个工作，并移除其占用的时刻
            s.erase(--it);
        }
        // 累加答案
        ans += k[i].first;
        
    }
    printf("%lld\n", ans);
    return 0;
}
```