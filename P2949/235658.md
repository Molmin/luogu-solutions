# P2949
[（可能）更好的阅读体验](https://www.luogu.com.cn/blog/llzzxx712/solution-p2949)

[传送门](https://www.luogu.com.cn/problem/P2949)
## 题目描述
- 给你N个任务，每个任务 $i$ 都有截止日期  $d_{i}$ 和报酬$p_{i}$。
- 完成每个任务时间相同，都为一个单位。
- 你需要使所得报酬最大并输出。
- $1<=p_{i},d_{i},n<=10^9$
## 题目分析
这是一道**贪心**题是肯定的，但我没有想到用标签中的单调队列怎么做，我使用了**二叉堆/优先队列**来解决。

**那具体怎么贪心呢？**

先是一个**错误的贪心思路**(注意是错的）——在每个时间点都选择当前报酬最高的任务进行完成。

这很容易举出反例，比如这里有两个工作，一个报酬为5，截止日期为3 。另一个报酬为4，截止日期为1 。按照此贪心思路我们先选第一个工作得到5点报酬然后第二个工作因截止而放弃。但很显然我们应该先选第二个工作再做第一个，这样可以获得9点报酬。

那么我们修改我们的思路——把任务按照时间排序，按照时间选择任务。

但仍可以举出反例，这里有三个任务，第一个任务截止时间为1，报酬为1，后两个任务截止时间都为2，报酬分别为8和9，按照此思路我们会先选择任务1，但很显然我们应该选择任务2、3而不选1.

这需要我们进一步改进，我们注意到每个任务完成的时间都为1，这意味着我们在一个时间可以做任意一个任务。当我们遇到一个报酬更大的任务且时间不够时，我们应该放弃前面选择的报酬最小（且比当前任务报酬小）的任务进行替换——这就是贪心中的**退流思想**。我们可以建立一个小根堆，将每次选择的任务报酬放入堆中，每次时间不够时取出堆顶，与当前任务进行比较。

## 思路总结
1. 读入每个工作并用结构体储存，按时间从小到大排序。
1. 建立小根堆与每次任务比较，保证结果最优。

## 易错点
- 结果可以很大，记得开 long long。
- 替换任务时不需要增加时间

## 代码（带注释）

```cpp
#include<iostream>
#include<algorithm>
#include<cstdio>
#include<queue>
#define N 100002
#define ll long long 
using namespace std;
void read(int &x){//快读 
	int f=1;x=0;
	char ch=getchar();
	while(ch<'0'||ch>'9') {if(ch=='-') f=-1;ch=getchar();}
	while(ch>='0'&&ch<='9') {x=x*10+ch-'0';ch=getchar();}
	x*=f;
}
struct cow{
	int g,d;//g为奶，d为截止时间 
}a[N];
int cmp(cow aa,cow bb){
	return aa.d<bb.d;//按照时间排序 
}
priority_queue < int > q;
int n,t;
ll ans;//只有结果需要开long long 
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		read(a[i].d),read(a[i].g);//读入 
	}
	sort(a+1,a+1+n,cmp);//排序 
	for(int i=1,t=1;i<=n;i++){//i表示现在扫描到第几个任务，t表示当前花费了多少时间 
		if(a[i].d<t){//时间不够了 
			int x=-q.top();//取负存入、取出（使它为小根堆） 
			if(x<a[i].g){//如果取出的任务报酬比当前小，替换 
				q.pop();q.push(-a[i].g);
				ans+=a[i].g-x; 
			}
		}
		if(a[i].d>=t){//时间充足，将当前任务放入 
			q.push(-a[i].g); 
			ans+=a[i].g;t++;
		}
	}
	cout<<ans;
}

```

**最后**：令人喜爱的双倍经验

[p3093 双倍经验](https://www.luogu.com.cn/problem/P3093)

**写题解不易，给个赞呗**