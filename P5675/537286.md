### 题外话
第一次写蓝题题解有点紧张&激动……


------------

[$\color{blue} \text{P5675 题目传送门}$](https://www.luogu.com.cn/problem/P5675)
# NIM 游戏介绍

## 介绍
NIM 游戏的规则：有 $n$ 堆石子，第 $i$ 堆石子有 $a_i$ 个，每次可以从某一堆中取走若干个，先后手轮流取，最后无石子可取的人败。

## 结论
NIM 游戏结论：将这 $n$ 堆石子的数量异或起来（即 $a_1 \ \oplus \ a_2 \ \oplus ~...~\oplus \ x_n$），假如不为 $0$，那么先手必胜，否则先手必败。

由于这东西的证明需要用到二进制，所以下面的证明都在二进制意义下讨论。

## 证明

首先要知道两个定义：

> 必胜态：双方足够聪明的情况下，在该状态时拥有操作权者必胜
> 必败态：双方足够聪明的情况下，在该状态时拥有操作权者必败

以及一些基础知识：如果一个状态能转移到任意一个必败态，那么该状态就是必胜态，如果不能，就是必败态。

**在 Nim 游戏中，异或和不为 $0$ 就是必胜态，否则是必败态。**

先考虑必胜态怎么必胜：

假设他们异或起来为 $k(k\neq 0)$，且 $k$ 的最高位为第 $p$ 位，那么至少存在一个 $a_i$，满足 $a_i$ 的第 $p$ 位是 $1$，那么我们只需要让 $a_i$ 异或上 $k$ 即可，由于 $a_i$ 的第 $p$ 位是 $1$，所以 $a_i$ 异或 $k$ 肯定是减少了。

异或完后，所有石子的异或和就变成了 $0$ ，也就是必败态，由于能转移到必败态，所以一开始的状态为必胜态。

再考虑必败态为什么必败：

这个就简单很多了,由于此时异或和为 $0$，不管怎么拿，拿完之后肯定不为 $0$，也就是说，这个状态只能转移到必胜态，那么这个状态就是必败态了。

# 题目分析
## 题目理解
$n$ 堆石子，第 $i$ 堆有 $a_i$ 个。指定一些石子堆使得先手必胜并指定一个先手第一个取的位置使得先手必败，求有多少方案数。
## 分析
- 根据 NIM 游戏，只要石子数异或和为 $0$ 则先手必败。

- 然后我们考虑枚举指定先手先去哪一堆石头，我们要选择一些石子堆使没有任何一种方法取走一些石头使得先手必败。

- 我们用 $f_{i,j}$ 表示在不包括枚举的石头堆的情况下，前 $i$ 堆石头有多少种选择方案使得其异或和为 $j$ 。然后若强制先手选择第 $k$ 堆石头那么方案数就是
 $\sum\limits_{i=a_k}^∞f_{n,i}$
## Code
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=210,XJQ=1e9+7;
int n,a[N],f[N][256],ans;
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
		scanf("%d",&a[i]);
	for(int k=1;k<=n;k++)
    {
		f[0][0]=1;
		for(int i=1;i<=n;i++)
			if(i==k)
				for(int j=0;j<256;j++)
					f[i][j]=f[i-1][j];
			else
				for(int j=0;j<256;j++)
					f[i][j]=(f[i-1][j]+f[i-1][j^a[i]])%XJQ;
		for(int i=a[k];i<256;i++)
			ans=(ans+f[n][i])%XJQ;
	}
	printf("%d",ans);
}
```

