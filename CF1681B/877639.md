[题目传送门](https://www.luogu.com.cn/blogAdmin/article/new#CF1681B)

# 详细版题意

给定一个长度为 $n$ 的数组 $a$，长度为 $m$ 的数组 $b$，执行如下操作：将前 $b_i$  个数移到 $a$ 数组的后面。操作 $m$ 次，问操作完开头的数是多少。

**注意此题多测**。

很明显，直接去将数组中的元素**直接进行操作**，肯定是**不切合实际**的，单次操作复杂度高，会超时。

#### 分析

既然我们不能将数组**整体进行改变**，那我们可不可以拿出数组中的**一个个体**进行移动，这样能大大减少时间复杂度。

再看回问题，他只让我们求打头的数，并没有让我们输出整个数组，**方法可行**！

我们可以用一个变量 $c$ 来记录数组打头数的下标，移动完输出不就完事了吗？肯定不会超时。

有了方法代码实现就很容易了，变量 $c$ 每次加 $b_i$，发现超出 $n$ 就取一次模即可。

上代码！
```cpp
#include<bits/stdc++.h>
using namespace std;
int t,n,a[200010],m,b[200010];
int main(){
	cin>>t;
	while(t--)
	{
		cin>>n;
		for(int i=1;i<=n;i++)
			cin>>a[i];
		int c=1;
		cin>>m;
		for(int i=1;i<=m;i++)
		{
			cin>>b[i];
			c+=b[i];//此时第m+c的下标的数在最前面
			c%=n;
		}
		if(c==0)c+=n;
		cout<<a[c]<<endl;//输出是有着极其吉利的寓意的（
	}
	return 0;
}
```
本题结束。提交代码，我们很快如本代码的输出一样 AC 了这道题。

[记录。](https://www.luogu.com.cn/record/113467312)

看完真是后怕。这样优化时间还是达到了 $514ms$，~~成功取得最差解~~，再次证明不优化肯定会超时。

再见！