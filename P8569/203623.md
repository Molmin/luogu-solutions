没有人写解法 2 啊（悲），甚至写解法 1 的也不多。大部分是暴力，我记得我卡了，居然还跑过去了吗，谢罪谢罪谢罪。

## 解法 1

来自 JohnVictor，时间复杂度为 $O(n\sqrt w)$，但是吊打了 std orz。

对于每一位组成的 $01$ 序列，如果能够每 $\sqrt w$ 压进一个 word，就可以 $O(n\sqrt w)$ 计算出答案。因为显然求全 $0$ 区间，维护信息 $L$ 左端极长段，$R$ 右端极长段，$f$ 该区间是否全 $0$ 和 $ans$，这部分可以 $O(2^{\sqrt w})$ 预处理。

考虑对序列分块，每块大小 $\sqrt w$。预处理出 $[0,2^{\sqrt w})$ 中每个数将数位分散到 $[0,w)$ 上。这样对于每一块，实质上是做一个 $01$ 矩阵转置。利用前面的预处理和位运算，可以很轻易地 $O(w)$ 做到。

时间复杂度 $O(n\sqrt w)$，不过跑的很快。

## 解法 2

博客第一页就有这个分治的思想，不知道有没有选手翻了我的博客（捂脸

考虑求出每一位的答案。即保留这一位后形成的 $01$ 序列有多少个区间中至少有一个 $1$。思路同上。

一个经典的思想是分治。

然而对每位都维护的话时间复杂度不可接受。$O(nw)$ 的。

我们把 $w$ 个数都拆成二进制。然后把二进制的每一位的 $w$ 个 $01$ 压到一个 word 里。称这个为计数器。

说人话，举个栗子：

$w=2$，两个二进制分别是 $11$ 和 $01$。压完之后就变成两个 word，第 $0$ 位的 word 是 $10$，第 $1$ 位的 word 是 $11$。

所以计数器维护了 $O(\log n)$ 个 word。

考虑这里合并的本质：并行计算 $w$ 个二进制加法/乘法。

考虑加法，设两计数器为 $a,b$：

从低到高枚举每一位。维护进位。

每一位是否进位可以压进一个 word 里，因为这里至多进位一次，设其为 $t$。

计算该位答案：显然为 $t \oplus a_i \oplus b_i$。

计算 $t$：即判断两次加法的过程中是否有任何一个进位了。即 $(a_i \land b_i)|((a_i \oplus b_i)\land t)$。

时间复杂度 $O(\log n)$。

考虑乘法：

暴力乘法即可。本质上是做 $O(\log n)$ 次加法。

时间复杂度 $O(\log ^2 n)$。

每次合并调用 $O(1)$ 次加法和乘法。

时间复杂度即 $T(n)=2T(\dfrac n 2)+O(\log ^2 n)$。

因为 $\log ^2 n=o(n^{eps})$，$eps<1$ 所以时间复杂度 $O(n)$。

具体实现的时候不要朴素分治，要二进制分组，这样空间复杂度能做到 $O(\log n)$。

很神奇有没有。让我们一起膜拜 hqztrue 和上琴桥。

%%%