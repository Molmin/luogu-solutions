## Description

给你一个长度为 $n$ 的序列 $\{a\}$，求其所有子区间的按位或的和。

其中，$1\le n\le 5\times 10^7$，$0\le a_i<2^{64}$。答案对 $2^{64}$ 取模。

## Analysis

第一眼：什么傻逼题。第二眼：$5\times 10^7$ 啊，没事了。

**约定：本题较卡常，故把常数带在复杂度内。**

考虑 $O(n\log V)$ 如何做。看到或，考虑按位计算贡献。我们先枚举每一位，看有多少个子区间的或这一位是 $1$。根据或运算的性质，我们发现只有这一位全 $0$ 的区间才是 $0$。于是对于每一位，将原序列转换为一个 01 序列，求出所有全 $0$ 的连续段，某一位 $i$ 的贡献就是 $2^i\times(\binom{n}{2}-\sum\binom{len_i}{2})$。$\{len\}$ 是所有全 $0$ 连续段的长度。

但是发现 $O(n\log V)$ 的复杂度是无法接受的，同时 $O(n)$ 的空间也是无法接受的。接下来的思路来自 cxy，膜拜。

考率对原序列进行分块，每个块的大小是 $B$。将原序列的答案拆成两部分：块内贡献 与 块间贡献。采取不同方式计算。

块内贡献用暴力枚举的方式计算，每个块内的复杂度 $O(B^2)$，块个数 $O(\frac{n}{B})$，于是这部分就在 $O(nB)$ 的复杂度内轻松解决。

块间的贡献较为麻烦，接下来分步解决。

首先考虑在较低复杂度内算出每一个二进制位在块内的第一个与最后一个 $1$ 的出现位置。暴力是单个块 $O(B\log V)$ 的，不够优秀。

考虑对块内的元素 $\{a\}$ 求前缀或运算和，称为序列 $\{s\}$。对于一个数 $a_i$，块内第一个出现在 $i$ 位置的二进制位就是 $s_i-s_{i-1}$ 的所有二进制为 $1$ 的位，不断取 $\text{lowbit}$ 即可。由于每一个二进制位只会在一个位置被算到，所以处理第一次出现位置的复杂度是 $O(\log V)$ 的，非常优秀。最后一个同理。因此单个块内处理该信息的复杂度是 $O(2\log V)$，即 $O(128)$，所有块复杂度 $O(\frac{128n}{B})$。下称 $i$ 二进制位在块内的第一次出现位置为 $f_i$，最后一个位置为 $g_i$。

接下来延续第一种算法的思想，枚举每一个二进制位，保存该二进制位上一个 $1$ 出现的位置，为 $lst_i$。那么这一位的跨块且或为 $0$ 的且右端点在该块内的区间个数是 $(f_i-l)\times (l-lst_i-1)$。又容易算出所有跨块的区间个数，用其减去所有不合法的区间个数就是这一位或为 $1$ 且跨块的区间个数，乘上二进制值即为这一位贡献。块内计算该信息复杂度为 $O(\log V)$ 即 $O(64)$。所有块复杂度为 $O(\frac{64n}{B})$。

因此最终时间复杂度 $O(nB+\frac{128n+64n}{B})=O(nB+\frac{192n}{B})$，取 $B=14$ 左右时复杂度较为优秀，约为 $O(14n)$。空间上只需要存当前块的 $B$ 个值与每一位的上一次出现位置，与该块内每个二进制位出现的第一个与最后一个位置，即 $O(B+\log V)$，约 $250$ 个 `long long` 变量，绰绰有余。于是解决了此题。

## Code

```cpp
int n,lst[64],f[64],g[64];
ll a[15],p[15],ban[64],vov;
ull ans;
signed main(){
  READ::init(n);
  for(int pos=1;pos<=n;pos+=14){
    int l=pos,r=min(n,pos+13),len=r-l+1;
    rep(i,l,r) a[i-l+1]=READ::read();
    rep(i,1,len){
      ll tmp=0;
      rep(j,i,len) tmp|=a[j],ans+=tmp;
    }
    rep(i,0,63) f[i]=g[i]=0;
    p[0]=0; rep(i,1,len) p[i]=p[i-1]|a[i];
    rep(i,1,len){
      ll qwq=p[i]-p[i-1];
      while(qwq) f[__lg(qwq&(-qwq))]=i+l-1,qwq-=qwq&(-qwq);
    }
    p[len+1]=0; per(i,len,1) p[i]=p[i+1]|a[i];
    rep(i,1,len){
      ll qwq=p[i]-p[i+1];
      while(qwq) g[__lg(qwq&(-qwq))]=i+l-1,qwq-=qwq&(-qwq);
    }
    rep(i,0,63){
      if(f[i]){
        ban[i]+=1ll*(f[i]-l)*(l-1-(lst[i]+1)+1);
        lst[i]=g[i];
      }else{
        ban[i]+=1ll*(r-l+1)*(l-1-(lst[i]+1)+1);
      }
    }
    vov+=1ll*(r-l+1)*(r-l+2)/2;
  }
  rep(i,0,63){
    ll tim=1ll*n*(n+1)/2-vov-ban[i];
    ans+=(ull)(1ull<<i)*tim;
  }
  cout<<ans;
}
```