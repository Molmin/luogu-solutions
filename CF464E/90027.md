最短路，但是边长是 2 的幂次。

如果硬写高精度肯定超时，又因为转移是一个二进制数只在某一位 $+1$，所以考虑用主席树的继承思想维护。

---

### 加法：

可能有进位的情况，这个时候就需要找到线段树上第一个比加的数位高且为 $0$ 的位置，可以在每个区间上维护一个是否为全 $1$ 的标记，实现 $\Theta(\log^2 n)$ 的查找。

找到位置后将当前位 $+1$，加法位到当前位之前的区间置为 $0$。

---

### 比较：

暴力逐位比较显然是 $\Theta(n)$ 的，考虑复杂度瓶颈在哪里：从高位到低位找到第一个**不相同**的位置，比较之。

如果能快速确定两个区间对应的二进制数是否完全相同，就可以用二分实现 $\Theta(\log n)$ 的比较。

于是对于线段树每个区间维护对应二进制数的哈希值（双哈希保险）。

题目询问的是长度 $\% (10^9+7)$ 的值，那其中一个 hash 参数可以选 $base = 2,mod = 10^9+7$ 的方便直接回答。

### 最短路：

dijkstra 套上数据结构即可，需要注意的是，点入队的时候需要存储当时对应的树根，因为在之后点的距离值可能被更新，树根会变，优先队列维护会出锅。

[CODE](https://www.luogu.com.cn/paste/e8zraw0k)