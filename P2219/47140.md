 ## 过了这道题，发一个题解，权当总结一些单调队列的基本写法
 此题思路：枚举所有的A * B的矩形，并求出其中和最小的C*D矩形。
 
实现上我们就用到了单调队列

下面的讲解中，S表示二位前缀和，x[i][j]表示以(i, j)为右下角，大小为C * D的矩形，u[i][j]表示(i, j-(B-D-1)+1)到(i, j）这条线段上的x的最小值，v[i][j]表示以(i, j)为右下角，大小为(A-C-1) * (B-D-1)的矩形中x的最小值。

### 问题1：为什么是A-C-1和B-D-1?

设矩形的左上角为(1, 1)，右下角为(A, B)。在其中选出一个C*D的矩形，且不与边界接触。这个矩形的左上角一定是比(2, 2)更靠右下的（或者一样），右下角一定是比(A-1, B-1)更靠坐上的（或者一样）。那么右下角的坐标范围就是(C+1, D+1)到(A-1, B-1)，这个大小就是(A-C-1)*(B-D-1)了

### 问题2：为什么要先求一维的再求二维的？

因为我太弱了不会直接写二维

### 问题3：单调队列的原理和实现？

考虑滑动窗口问题求最大值。如果点i的权值是ai，点j的权值是aj。若i<j&&ai<aj，那么在j点进入可行区间后，i点就不会再作为最优解了，所以可以直接踢出。

实现上做一个双端队列，其中从左到右下标越来越大（即越来越新），从右到左权值越来越大（即越来越优）。所以每次加入一个点前要从左边把过期的点删除，从右边把不够优的点删除。在加入新点后就可以用最左端的最优解来得出所有值了。

最好每道题都在纸上推一下各种边界条件，以免写错

### 至此，这道题解决完毕，但有一些题意理解和实现上的误区，这里澄清一下：

### 矩形A * B和C * D不能翻转

### 绿化带必须是一个闭合圈

### 此题不需要long long

### 窗口长为a时，判断的条件是>=a而非>a

## 下面是(自认为写得很丑陋的)代码
```
#include <cstdio>
#include <iostream>
#include <cstring>
#define int long long
using namespace std;
int a[1005][1005], x[1005][1005], u[1005][1005], v[1005][1005], S[1005][1005];
int q[1005], l, r;
signed main()
{
	int n, m, A, B, C, D, i, j, ans = -1;
	scanf("%lld%lld%lld%lld%lld%lld", &n, &m, &A, &B, &C, &D);
	for(i = 1; i <= n; i++)
		for(j = 1; j <= m; j++)
			scanf("%lld", &a[i][j]), S[i][j] = S[i][j - 1] + S[i - 1][j] - S[i - 1][j - 1] + a[i][j];
	for(i = C; i <= n; i++)
		for(j = D; j <= m; j++)
			x[i][j] = S[i][j] - S[i - C][j] - S[i][j - D] + S[i - C][j - D];
	for(i = 1; i <= n; i++)//点动成线 
	{
		l = 1, r = 0;
		for(j = 1; j <= m; j++)
		{
			while(l <= r && j - q[l] >= B - D - 1) l++;
			while(l <= r && x[i][q[r]] >= x[i][j]) r--;
			q[++r] = j;
			u[i][j] = x[i][q[l]];
		}
	}
	for(i = 1; i <= m; i++)//线动成面 
	{
		l = 1, r = 0;
		for(j = 1; j <= n; j++)
		{
			while(l <= r && j - q[l] >= A - C - 1) l++;
			while(l <= r && u[q[r]][i] >= u[j][i]) r--;
			q[++r] = j;
			v[j][i] = u[q[l]][i];
		}
	}
	for(i = A; i <= n; i++)
		for(j = B; j <= m; j++)
			ans = max(ans, S[i][j] - S[i - A][j] - S[i][j - B] + S[i - A][j - B] - v[i - 1][j - 1]);
	printf("%lld\n", ans);
	return 0;
}
```
