~~看了一眼题解，好像没人用我这种做法，赶紧发篇题解。~~

一道明显的贪心题。

题意：

给你 $n$ 个数，每个数可以 +1 或 -1。求最后重合的点的最大值和最小值。

1.最小值。如果要求重合的点最少，我们就尽量把点往点多的地方移动。先定义一个数组 $ans$ 标记已经移动过的点的位置，我们可以统一先把所有点往一个方向移，如果另外一个方向已经有一个点了，那么我们就往反方向移动。使他们尽量重叠。如果一个点有多个人就把它们看做一个人，一起移动。

2.最大值。。如果当前的点有一个人，那么不必移动。如果有多个人，先从前，后找一个点没有人的，（如果都有人统一向后移。）移动之后如果这个点只剩一人，就不用移动了。如果还有人，那就将多的人找同一个方向（最好是每人的。）统一移动。

详情见代码注释：

```
#include<bits/stdc++.h>

using namespace std;

int a[200005], cnt, ans[200005], x, n;

int main () {
	ios::sync_with_stdio (false), cin.tie (0), cout.tie (0);
	cin >> n;
	for (int i = 1 ; i <= n ; i++) cin >> x, a[x]++;
	for (int i = 1 ; i <= n ; i++) {
		if (a[i]) { //如果当前点有人。 
			if (ans[i]) continue; //如果当前点不止一人，那此时就是最优解，不必再移动。 
			if (ans[i - 1]) continue; //如果前面的点有人，向前移动。 
			else { //否则统一向后移动。 
				ans[i + 1] = 1;
			}
		}
	}
	int cnt = 0;
	for (int i = 0 ; i <= n + 1 ; i++) cnt += ans[i], ans[i] = 0;
	cout << cnt << " ";
	for (int i = 1 ; i <= n ; i++) {
		if (a[i]) { //如果当前点有人。 
			if (!ans[i - 1]) { //如果前面没人，向前移动。 
				a[i]--; //统计当前剩下的人数。 
				ans[i - 1] = 1;
			}
			if (a[i]) { //如果还有人。 
				if (ans[i]) ans[i + 1] = 1; //如果当前点有人，且前面已经有人了，向后移动。 
				else { //当前点没人，停留在原地即可。 
					ans[i] = 1;
					if (a[i] > 1) { //如果还是有人。 
						ans[i + 1] = 1; //统一向后移。 
					}
				}
			}
		}
	}
	cnt = 0;
	for (int i = 0 ; i <= n + 1 ; i++) cnt += ans[i];
	cout << cnt;
}
```