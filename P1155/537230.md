# 核心思路：模拟+贪心
~~我居然敢在一道已经有数十篇高质量题解的题下交题解了，真是不可理喻~~，那必然是有原因的，由于我做这道题的时候不会二分图（其实现在也不会），不太看得懂题解，就自己写了个贪心，过了 Subtask #0，但是 Subtask #1 的第二个点 WA 掉了。后来推倒重写后过了 Subtask #1，又看了一眼题解发现没有一个用的是模拟+贪心的，于是我就膨胀了。

**Update 2023.3.17 修改了变量名不统一的问题。**

**Update 2023.3.30 改了些笔误。**

### 正文
题意不多赘述。

我的思路是从前往后考虑排列中的每个元素，每放入一个元素，将能出栈的元素全部出栈。

在（只考虑两栈栈顶元素和当前考虑的元素时）只能放 $S_1$ 或者放 $S_1$ 必然更优时放 $S_1$，只能放 $S_2$ 时放 $S_2$，其余情况有些复杂，后文再讲。

由于最后要使输出序列升序排列，我们可以得到以下推论。

记当前考虑的元素为 $x$，只能放 $S_1$ 的情况有：
- $S_1$ 为空（由后文的其他决策可知此时必然 $S_2$ 也为空，放 $S_1$ 更优）。
- $S_2$ 的栈顶小于 $x$ 并且 $S_1$ 的栈顶大于 $x$。（不能放 $S_2$）

如果 $S_1$ 的栈顶小于 $x$，只能放 $S_2$ 的情况有：
- $S_2$ 为空（此时如果不放 $S_2$ 就无法继续）。
- $S_2$ 的栈顶大于 $x$（同上）。
- 如果不满足以上两种情况，且 $S_1$ 的栈顶小于 $x$，说明这个排列不是“可双栈排序排列”。

容易发现以上几种情况是没有交集的，排除以上五种情况，剩下的就是 $S_1,S_2$ 都能选的情况了。

对于剩余情况，我们先考虑可以贪心解决的部分。
- $x$ 放入后，立马可以出栈（可以记录已经出栈的最大元素 $K$，然后贪心解决），为保证字典序应该选 $S_1$。

对于其余情况，我们先思考一个问题：**当我们把整个排列（或一部分）放入栈中后，如果要让栈中的元素一次性弹出后升序排列，栈中元素应满足什么性质。**（其实我原来的代码就因为没处理这一部分被 hack 了）。

如果只有一个栈，那它只需要简单从栈底到栈顶降序排列。

对于两个栈，我们发现若将其分成多个最长的连续区间，这些区间中的元素是连续的，并且降序排列。**如果两个栈中所有这样的区间首尾相连是一个连续的降序排列，那么栈中的元素就可以完成一个升序的出栈序列。**（其实接起来就相当于只有一个栈的情况）

有点难懂？举个例子（右侧为栈顶）。

（每一个代码块代表一个上文指的“最长连续区间”）

比如这种情况就可以：
- $S_1$:`9876` `3` `1`
- $S_2$:`54` `2`

这种就不行：
- $S_1$:`9876` `3` `1`
- $S_2$:`4` `2` 

有了这个推论，我们就可以再贪心地解决两种情况：
- $S_1$ 的栈顶等于 $x+1$。
- $S_2$ 的栈顶等于 $x+1$。

排除上述情况后，剩余情况应具备以下性质（如果不知道为什么去对照上文）：
- $S_1$ 非空。
- $x$ 小于 $S_1$ 的栈顶。
- $S_2$ 为空，或 $x$ 小于 $S_2$ 的栈顶。
- 已出栈最大元素 $K$（下文也会用 $K$ 表示）必定小于 $x$。
- 必定没有考虑过任何大于 $K$ 且小于 $x$ 的元素（不然它们已经出栈，或者判定为“不可双栈排序序列”了）。

这些情况中，为保证字典序最小，我们仍贪心地考虑能选 $S_1$ 就选 $S_1$。


- 若 $S_2$ 为空，选 $S_1$（这个策略我证了巨久）。
	1. 若在 $S_1$ 栈顶元素弹出前，$x$ 之后有某个元素比 $S_1$ 的栈顶大，那么它也比 $x$ 大，我们又把 $x$ 放在了 $S_2$ 中，那么就可能会让本来有解的情况变成无解
   1. 若在 $S_1$ 栈顶元素弹出前，$x$ 之后所有元素都小于 $S_1$ 的栈顶，那么后续元素要么就可以满足前文提到的性质，要么就可以单独判错，无论怎样此时选 $S_1$ 都不会影响最终是否有解，选 $S_1$。
- 若 $S_2$ 不为空（以下情况先说处理和证明，后文讲实现）：
	- 若到 $S_1$ 栈顶弹出前存在某个数大于 $S_2$ 的栈顶，选 $S_1$。
    	- 显然，如果此时选了 $S_1$ 就有可能使某一个小于 $S_1$ 但大于 $S_2$ 栈顶的数无法入栈，可能会使有解的情况变得无解，同理应选 $S_2$。
   - 其余情况就是选 $S_1$ 不会影响可解性的，为保证字典序应选 $S_1$。

对于如何实现，我们发现 $S_1$ 的栈顶会在处理到 $K+1$ 时或者处理到 $S_1$ 栈顶减一时弹出，我们把这俩位置取个 `max`，把从 $x$ 到这里的这一段遍历一遍，用一个桶存一下，后面判断时遍历以下这个桶就好了。

每个点考虑一遍，考虑一个点最多需要计算 $n$ 次，总复杂度 $O(n^2)$，并且实际情况应该会远小于 $O(n^2)$。

最后注意一下，由于在答案序列中，相邻的`a`和`d`可以随意交换位置（ $S_1$ 何时入栈和 $S_2$ 何时出栈并不会互相影响）,`b`和`c`同理，我们可以跑一遍类似于冒泡排序的东西使它变得更优。
### code
```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<stack>
#include<string.h>
using namespace std;
const int N=1005;
int n,K=1,a[N],ka,adr[N];
//需要注意，代码里的 K 和题解里的 K 意义不完全相同。
//这里的 K 指下一个将会出栈的元素
bool vis[N];
stack<int> S1,S2;
char ans[N<<1];
bool gg(int x,int y){
	for(int i=x;i<=y;i++){
		if(!vis[i]) return false;
	}
	return true;
}
bool chk(int x){//返回 true 放 S1，返回 false 放 S2。
	if(S2.empty()) return true;//情况一
	memset(vis,0,sizeof(vis));
	for(int i=adr[x];i<=max(adr[S1.top()-1],adr[K]);i++){
		vis[a[i]]=true;
	}
	if(gg(S2.top()+1,n)) return false;//情况2
 	return true;//情况3
}
signed main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		scanf("%d",&a[i]);
		adr[a[i]]=i;
	}
	for(int i=1;i<=n;i++){
		if(S1.empty()||(!S2.empty()&&S2.top()<a[i]&&S1.top()>a[i])){//只能选 S1。
			S1.push(a[i]);
			ans[ka++]='a';
		}else if(!S1.empty()&&S1.top()<a[i]){//不能选 S1。
			if(S2.empty()){
				S2.push(a[i]);
				ans[ka++]='c';
			}else if(S2.top()>a[i]){
				S2.push(a[i]);
				ans[ka++]='c';
			}else{//都不能选
				return printf("0"),0;
			}
		}else{
			if(a[i]==K){//可以立马出栈
				S1.push(a[i]);
				ans[ka++]='a';
			}else if(a[i]==S1.top()-1){//可以接在 S1 上。
				S1.push(a[i]);
				ans[ka++]='a';
			}else if(!S2.empty()&&a[i]==S2.top()-1){//可以接在 S2 上。
				S2.push(a[i]);
				ans[ka++]='c';
			}else{// 复杂情况
				if(chk(a[i])){
					S1.push(a[i]);
					ans[ka++]='a';
				}else{
					S2.push(a[i]);
					ans[ka++]='c';
				}
			}
		}
		while((!S1.empty()&&S1.top()==K)||(!S2.empty()&&S2.top()==K)){//出栈
			if(!S1.empty()&&S1.top()==K){
				ans[ka++]='b';
				S1.pop();
				K++;
			}else if(!S2.empty()&&S2.top()==K){
				ans[ka++]='d';
				S2.pop();
				K++;
			}
		}
	}
	for(int i=0;i<(n<<1);i++){//处理顺序问题
		for(int j=0;j<(n<<1);j++){
			if(ans[j]=='d'&&ans[j+1]=='a'){
				swap(ans[j],ans[j+1]);
			}
			if(ans[j]=='c'&&ans[j+1]=='b'){
				swap(ans[j],ans[j+1]);
			}
		}
	}
	for(int i=0;i<(n<<1);i++){
		printf("%c ",ans[i]);
	}
	return 0;
}

```
