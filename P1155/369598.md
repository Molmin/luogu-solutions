这一题作为 NOIP 2008 的压轴一点也不过分（然而现在只有 T2 的难度了）,能在考场上想出来绝非易事。
废话不多说，咱们直接切入正文。


# 思维分析
两个栈的情况似乎无从下手，我们可以先考虑考虑一个栈的情况。

我们先假设有解，怎样操作会使得答案最优呢？根据字典序的定义，我们只需目光短浅一点，只要能进就一直让它进（操作 a ）。当然，在该出的时候也必须无情地出掉（操作 b ）。

那么问题来了，什么时候不得不出了呢？直接想似乎有困难，可以手玩一下样例：


```
4
1 3 2 4
```
我们很失望地发现 1 一进去就要被出掉，因为如果不出的话，后面的数加进来后，就必须先出后面的数，那么输出的第一个数就不可能是 1，我们的排序计划也就泡汤了。再看下一个加进来的数 3，根据之前分析的贪心策略，能不出就不出，而且暂时先不出似乎也没有什么问题，再仔细想想不难发现，不仅是不出没问题，出了还会有大问题。如果出了，那么第二个数就会是 3，而不是 2 了。等到 2 加进来，好像是必须要出了，不然第二个数就不是 2 了，然后，3 也应该出了，最后，把 4 加进去并直接出掉，便完成了排序。

从上面的流程中，我们总结出来一个规律：当栈顶元素为当前需要出的数时，那么栈顶就必须被出掉。不然后面的数加进来后就会很尴尬。在代码实现中，我们可以使用一个变量（代码中记为 now ）来记录当前需要出的数是几。

怎么判断无解呢？我们自己来造一组数据：
```
5
2 3 1 4 5
```
2 入栈，3 入栈，到了 1 入栈的时候就有问题了。按规矩，1 应该出掉了，但无论如何， 3 都不可能在 3 之前出栈，这种情况下，就无解了。——情况 1

下面，我们把数据做个微调：
 

```
5
3 2 1 4 5
```
这么一来，1 出栈后，2 和 3 都能够顺理成章地出栈。——情况 2

再换：
```
5
1 2 3 4 5
```
任何数之后都没有比它小的数，丝毫不用担心无解。——情况 3

感性地想一想，要是每个数后面都没有比它小的数……废话，那不就排好了！我们着重来分析一下情况 2 。
 
为什么情况 1 无解，而情况 2 就行了呢？唯一的不同就在于第一个数和第二个数换了一下位置。对于情况 2 中的 2 和 3，虽然后面有个 1，但 2 也会在 3 之前被出掉，而情况1就显得比较悲催了。

严谨地，还要补充一组数据：
```
3
1 3 2
```
看完前面的，或许会有人认为只要$a$数组中存在三个数呈“峰形”，那么就无解。但这个其实是错的。

看看上面的数据，这其实是有解的。其中的根本所在，在于1可以直接出掉，不会像情况1一样产生“ **堆积** ”。

所以，我们分析出了一个很强的性质，也是本题最核心的一个性质：

 **在一个栈的情况下无解，当且仅当存在一组 $i,j,k$ ，满足 $i<j<k$   且 $a[i]<a[j]$ 且 $a[k]<a[i]$**



# 具体思路
好不容易学会了一个栈的情况，然而本题有两个栈。

其实也简单，只要一些数在一个栈的情况下不会使之无解，那么在两个栈的情况下就可以把它们放入同一栈中。

疑？好像可以抽象为共存问题，那么显然用二分图解决。即把两个在一起会导致无解的数之间连一条边（代码中是给下标连边，本质相同）。如果得到的图不是二分图，那么返回无解。否则，输出答案。在输出答案时要注意，要求字典序最小，我们可以遵循能用第一个栈就不用第二个栈的原则，时的答案最优。

还有个问题，如何判断每个数该被分到哪个栈？简单，在染色判定时已经求出了    color 数组，我们从 1 开始染色，这么一来，颜色为 1 的点就应被分配至第一个栈，颜色为 2 的点就应被分配至第二个栈。同时也保证了能被分配到第一个栈的点绝不会被分配到第二个栈。由于我们枚举没有被染色的点时从 1 开始枚举，也保证了前面的数会优先使用第一个栈。

还需注意的是，在第二个栈中的数出栈前，如果第一个栈中有数该出栈，那么应该让其出栈。这样答案会更优。最后，别忘了把两个栈中的剩余的数输出。

于是，这么一来，就得到了最优答案。



# 细节处理


```
6
2 3 1 4 5 6
```
这一部分就是为了这组 Hack 数据而生的。

如果是当年的官方数据，下面这份代码也就过了：

```
#include<bits/stdc++.h>
using namespace std;
const int N=1005,M=1e6+5;
int ver[M],Next[M],head[M],tot;
void add(int u,int v)
{
    ver[++tot]=v,Next[tot]=head[u],head[u]=tot;
}
int a[N],k[N];
int fail,vis[N];
int st1[N],st2[N],t1,t2;
void dfs(int x,int c)
{
    vis[x]=c;
    for(int i=head[x];i;i=Next[i])
    {
        if(!vis[ver[i]])dfs(ver[i],3-c);
        else if(vis[ver[i]]==c)fail=1;
    }
}
int main()
{
    int n;
    scanf("%d",&n);
    for(int i=1;i<=n;i++)scanf("%d",&a[i]);
    int MIN=1e8;
    for(int i=n;i;i--)k[i]=MIN,MIN=min(MIN,a[i]);
    for(int i=1;i<=n;i++)
        for(int j=i+1;j<=n;j++)
            if(a[i]<a[j]&&a[i]>k[j])
                add(i,j),add(j,i);
    for(int i=1;i<=n;i++)if(!vis[i])dfs(i,1);
    if(fail){printf("%d",0);return 0;}
    int now=1;
    st1[0]=st2[0]=1e8;
    for(int i=1;i<=n;i++)
        if(vis[i]==1)
        {
            while(st1[t1]==now)
                t1--,printf("%c ",'b'),now++;
            st1[++t1]=a[i],printf("%c ",'a');
        }
        else
        {
            while(1)
                if(st1[t1]==now)
                    t1--,printf("%c ",'b'),now++;
                else if(st2[t2]==now)
                    t2--,printf("%c ",'d'),now++;
                else break;
            st2[++t2]=a[i],printf("%c ",'c');
        }
    while(1)
        if(st1[t1]==now)
            t1--,printf("%c ",'b'),now++;
        else if(st2[t2]==now)
            t2--,printf("%c ",'d'),now++;
        else break;
    return 0;
}
```
学习就要学真理，既然被卡了，就来找找问题出在哪。

先会出现如下状态：

第一个栈：2 1

第二个栈：3

我们会把 2 和 1 出栈，一时半会儿不把 3 出栈。但是 4,5,6 加进来后，会发现加进来的数一直不是该出的，是因为该出的 3 却没出！

容易想到直接这么改：

做第一个栈时，如果第二个栈中有该出的数，那么直接出掉。但仔细想想，这么一来，如果有些时候根本用不着出第二个栈中的数，那不就白白把答案变差了吗？

分析一下，只有在一定情况下，才有必要出第二个栈中的数。什么情况呢？

**如果当前可以加入第一个栈的数比当前第一个栈的栈顶的数大，那么就需要不断弹出第二个栈中该弹出的数（此时第一个栈中该出的应该已经出完了），这之后，再弹出第一个栈中该弹出的数，然后再把当前数插入第一个栈**

毕竟如果这个时候还不出，那么当前数加进来后就直接是的这个栈不合法了。如果做完这个操作之后当前数还是大于栈顶，那么只能是无解了，但我们已经判断过有解了，所以这种情况根本就不会发生。



# 最终代码


```
#include<bits/stdc++.h>
using namespace std;
const int N=1005,M=1e6+5;
int ver[M],Next[M],head[M],tot;
void add(int u,int v)
{
    ver[++tot]=v,Next[tot]=head[u],head[u]=tot;
}
int a[N],k[N];
int fail,vis[N];
int st1[N],st2[N],t1,t2;
void dfs(int x,int c)
{
    vis[x]=c;
    for(int i=head[x];i;i=Next[i])
    {
        if(!vis[ver[i]])dfs(ver[i],3-c);
        else if(vis[ver[i]]==c)fail=1;
    }
}
int main()
{
    int n;
    scanf("%d",&n);
    for(int i=1;i<=n;i++)scanf("%d",&a[i]);
    int MIN=1e8;
    for(int i=n;i;i--)k[i]=MIN,MIN=min(MIN,a[i]);
    for(int i=1;i<=n;i++)
        for(int j=i+1;j<=n;j++)
            if(a[i]<a[j]&&a[i]>k[j])
                add(i,j),add(j,i);
    for(int i=1;i<=n;i++)if(!vis[i])dfs(i,1);
    if(fail){printf("%d",0);return 0;}
    int now=1;
    st1[0]=st2[0]=1e8;
    for(int i=1;i<=n;i++)
        if(vis[i]==1)
        {
            while(st1[t1]==now)
                t1--,printf("%c ",'b'),now++;
            if(a[i]>st1[t1])while(st2[t2]==now)t2--,printf("%c ",'d'),now++;
            while(st1[t1]==now)
                t1--,printf("%c ",'b'),now++;
            st1[++t1]=a[i],printf("%c ",'a');
        }
        else
        {
            while(1)
                if(st1[t1]==now)
                    t1--,printf("%c ",'b'),now++;
                else if(st2[t2]==now)
                    t2--,printf("%c ",'d'),now++;
                else break;
            st2[++t2]=a[i],printf("%c ",'c');
        }
    while(1)
        if(st1[t1]==now)
            t1--,printf("%c ",'b'),now++;
        else if(st2[t2]==now)
            t2--,printf("%c ",'d'),now++;
        else break;
    return 0;
}
```
