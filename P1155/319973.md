# 初步分析
观察样例三，发现这里把 $2$ 和 $3$ 放在了不同的栈里，那为什么不能放在同个栈里呢？如果把它们放在同个栈里，因为 $2$ 比 $3$ 小，所以 $2$ 要先出栈，但 $3$ 把它挡住了，无法进行操作，得出结论：每个栈里的数需单调递增  

# 模拟
根据该结论直接进行模拟是错的，反例：数列 $7,2,5,1,4,6,3$ 
```cpp
直接模拟的过程：

S1| 7
S2|

S1| 7 2
S2|

S1| 7 2
S2| 5

S1| 7	//1,2弹出了
S2| 5

S1| 7 4
S2| 5

//此时6无法放入栈内
正解：

S1| 7
S1| 5 4

S1| 7 6
S2| 5 4

//6成功放入栈内
```
# 深入分析
通过该结论，可以得知在 $i<j$ 且 $a_i<a_j$ 且 $a_i$ 还在栈中的情况下，$a_j$ 必须和 $a_i$ 放在不同的栈中，那如何判断 $a_i$ 还在栈中呢？不妨加入一个数 $a_k$，当 $i<j<k$ 且 $a_k<a_i<a_j$ 时，$a_i$ 和 $a_j$ 不能放在同一个栈中  

用这种方法，可以预处理出所有冲突的数对，但需要 $O(n^3)$ 的时间来枚举 $i,j,k$ ，得优化到 $O(n^2)$  

分析式子可知，得出的关系只与 $a_i,a_j$ 有关，只需找到一个 $a_k<a_i$ 即可，很明显，可以维护一个数组表示数列的后缀 $min$ ，用 $O(1)$ 的时间取出 $a_{j+1}$ 到 $a_n$ 的最小值作为 $a_k$ ，这样就压缩到了 $O(n^2)$  

# 二分图染色
对于所有冲突的数对，可以把它们进行划分，把冲突的两个数分配在不同栈里，这里采用二分图染色来划分（如果无法把一对冲突的数对划分到不同的栈里，则无解）

问题来了，我们应从哪个点开始染色？起始点该分配到栈一还是栈二？为了满足题目要求的最小字典序，最靠前的数一定得放在栈一里，不妨选择它为起始点

注意：图不一定是完全联通的，因此要进行多次二分图染色

# 统计结果
染完色，答案就基本出来了，但对于单独的不构成冲突的点，该把它分配到哪个栈里呢？答案是栈一，因为它不会构成任何冲突，所以可以随意放，放在栈一可以满足最小字典序

坑点：数列 $2,4,1,3,5$  
按上述方法进行模拟的答案为 $acabbabdab$  
正解：$acabbabadb$  

可以发现，$a$ 和 $d$ 是两个不同栈的操作，因此它们的先后顺序无关紧要，所以对于相邻的 $d$ 和 $a$ ，直接把 $a$ 放到 $d$ 前面即可

# 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[1001],mi[1001],cl[1001],f=1,t,nw=1;
char ans[2001];
stack <int> q1,q2;
vector <int> eg[1001];
void dfs(int u,int p){//二分图染色
	cl[u]=p;
	int v;
	for(int i=0;i<eg[u].size();i++){
		v=eg[u][i];
		if(cl[v]==0)dfs(v,(p==1?2:1));
		else if(cl[v]==p)f=0;
	}
}
void Pop(){
	while(1){
		if(!q1.empty()&&q1.top()==nw){
			q1.pop();
			t++;ans[t]='b';
			nw++;
		}
		else if(!q2.empty()&&q2.top()==nw){
			q2.pop();
			t++;ans[t]='d';
			nw++;
		}
		else break;
	}
}
int main(){
	cin>>n;
	for(int i=1;i<=n;i++)cin>>a[i];
	mi[n]=a[n];
	for(int i=n-1;i>=1;i--)mi[i]=min(a[i],mi[i+1]);//前缀min
	for(int i=1;i<n-1;i++){
		for(int j=i+1;j<n;j++){
			if(a[i]<a[j]&&mi[j+1]<a[i]){
				eg[i].push_back(j);
				eg[j].push_back(i);
			}
		}
	}
	for(int i=1;i<=n;i++)if(cl[i]==0)dfs(i,1);
	if(f==0){
		cout<<0;
		return 0;
	}
	for(int i=1;i<=n;i++){
		Pop();
		if(cl[i]==1){
			q1.push(a[i]);
			t++;ans[t]='a';
		}
		else{
			q2.push(a[i]);
			t++;ans[t]='c';
		}
	}
	Pop();
	for(int k=1;k<=n;k++){
		for(int i=1;i<2*n;i++){
			if(ans[i]=='d'&&ans[i+1]=='a')swap(ans[i],ans[i+1]);//对a和d的特殊操作
		}
	}
	for(int i=1;i<=2*n;i++)cout<<ans[i]<<' ';
	return 0;
}
```
