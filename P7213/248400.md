## 题目简述

> - 一个长度为 $2n$ 的序列 $a$，满足 $1,2,\dots,n$ 每个数恰好出现 $2$ 次。现在进行 $n$ 次如下操作：
> - - 同时对于所有 $i(a_i>0)$ 满足 $∃ i<j,a_j=a_i$ 的 $a_i$ 减一。
> - 最后恰得到 $n$ 个非零位，记为 $a$ 的「支撑集」。给定 $a$ 的支撑集，求原来 $a$ 的可能数量。答案对 $10^9+7$ 取模。
> - $n\leq 600$。

## 解题思路

刚拿道题没有思路，我们尝试猜测一些结论。

> 猜测 $1$：对任意满足 $1,2,\dots,n$ 每个数恰好出现 $2$ 次的数列 $a$，经过 $n$ 次操作后必然只剩下 $n$ 个非零位。

下面我们尝试去证明「猜测 $1$」（对证明没有兴趣的同学可以跳到猜测 $2$）：

我们尝试去观察一个例子：$a=[2,3,5,5,4,2,3,4,1,1]$，变换如下：

- 第 $1$ 次操作，$a=[1,2,4,5,3,2,3,4,0,1]$；
- 第 $2$ 次操作，$a=[0,1,3,5,2,2,3,4,0,1]$；
- 第 $3$ 次操作，$a=[0,0,2,5,1,2,3,4,0,1]$；
- 第 $4$ 次操作，$a=[0,0,1,5,0,2,3,4,0,1]$；
- 第 $5$ 次操作，$a=[0,0,0,5,0,2,3,4,0,1]$。

注意观察上面的操作，不难发现：**每个非负整数至多出现 $\bm 2$ 次**。这个使用归纳证明是显然的，更进一步，不难发现在第 $i$ 次操作后 $1\sim n-i$ 每个数出现两次，$n-i+1\sim n$ 每个数出现一次。这用归纳法也是显然的。

也就是每次的两个 $1$ 总有一个会变成 $0$，证毕。

下面考虑每个合法序列的「支撑集」，通过上面的引理，不难发现每次两个数比较都是小的减一，也就是如果把数值看做成等级，那么下标大的人会把下标小的人打下去。这不难让我们猜测到「支撑集」的计算方法：

> 猜测 $2$（支撑集的计算方法）：遍历 $i$ 从 $n$ 到 $1$，把所有数值 $\geq i$ 且没有标记的数中下标最大者标记，最后所有标记的点记为原序列的「支撑集」。

证明是显然的。但是这显然不利于我们去计数。我们需要考虑另一种的表示方法。

> 猜测 $3$（支撑集的另一种表示方法）：考虑 $i$ 从 $2n$ 遍历到 $1$，维护集合 $S$。如果 $S$ 中包含 $1,2,\dots,a_i$ 那么 $i$ 不能加入支撑集，否则加入小于等于 $a_i$ 当中最大不在 $S$ 当中的数，此时 $i$ 在支撑集。

考虑证明，我们还是引用上面打擂台的表示方法。考虑 $i$ 如果在支撑集，也就是 $i$ 占领了一个等级，那么 $i$ 必然是不断往比自己等级小的地方走，直到没有人的等级就当上了这个等级的爷爷，如果等级归 $0$ 了还没当上爷爷那么它就再见了。

说了那么多实际上还是只能暴力枚举，甚至 $1$ 分都拿不到，但是我们已经可以考虑 dp 的做法了。

下面假设序列当中相同的数硬性规定不同。最终答案除以 $2^n$。假设位置 $i$（不包括）之前已经有 $c_0$ 个不在支撑集，$c_1$ 个在支撑集。

考虑 $f_{i,j}$ 表示后 $i$ 个数，等级 $1\sim j$ 已经被占领且 $j+1$ 未被占领的方案数，考虑转移 $f_{i,j}$：

- 如果规定位置 $i$ 不是支撑集，那么他可以在 $1\sim j$ 当中任意一个选取，由于支撑集用了 $j$ 个，不在支撑集用了 $c_0$ 个，所以还有 $j-c_0$ 的选择。也就是：

- $$
  f_{i,j}=(j-c_0)f_{i-1,j}
  $$

- 如果规定位置 $i$ 是支配集，那么它选择必然 $\geq j$，考虑 $f_{i-1,j'}$ 的贡献。

- - 如果 $j'=j$，那么贡献未来再计算，也就是 $f_{i,j}\leftarrow f_{i-1,j}$。
  - 如果 $j'< j$，那么我们考虑我要在前面 $c_1-j'$ 个未被选择的数当中选择 $j-j'-1$ 个，这有 $\dbinom{c_1-j'}{j-j'-1}$ 种方案，考虑第 $i$ 个数的数值有 $j-j'+1$ 种方案，最后考虑未确定的 $j-j'-1$ 个元素当中选取的方案，感觉这个不好直接计算，我们先假设他为 $g_{j-j'-1}$ 后面再搞搞。

接下来考虑 $g$ 的计算，本质上是在 $1,1,2,2,3,3,\dots,n,n$ 当中选 $n$ 个通过上面变换变成连续的方案数。同样的枚举第一个点值最终等级，假设为 $x$，那么他有 $n-x$ 种方案。在 $n-1$ 个选 $x-1$ 个一边等级 $>x$，一边 $<x$ 有 $\dbinom{x-1}{n-1}$ 种方案，然后两边独立又有 $g_{x-1}\times g_{n-x}$ 种方案。那么得到转移式子：
$$
g_n=\sum_{i=1}^n (n-x+2)\times \dbinom{x-1}{n-1}\times g_{x-1}\times g_{n-x}
$$
然后就做完了。

## 实现细节

很好写，没细节。照着上面的式子搬下来就可以了。

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define MP make_pair
const int MAXN=605;
const int MOD=1e9+7;
int n;
ll f[2*MAXN][MAXN],g[MAXN];
ll fac[MAXN],inf[MAXN];
bool mark[MAXN*2];
ll inv(ll a,int b=MOD-2){ll res=1;while(b){if(b&1)res=res*a%MOD;a=a*a%MOD,b>>=1;}return res;} 
void init(){
	fac[0]=inf[0]=1;
	for(int i=1;i<MAXN;i++)
		fac[i]=fac[i-1]*i%MOD,
		inf[i]=inv(fac[i]);
	return;
}
ll C(int x,int y){if(x>y)return 0;return fac[y]*inf[x]%MOD*inf[y-x]%MOD;} 
int main(){
	ios::sync_with_stdio(false);
	init();
	cin>>n;
	for(int i=1;i<=n;i++){
		int a;cin>>a;mark[2*n+1-a]=1;
	}
	g[0]=1;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=i;j++)
			g[i]+=C(j-1,i-1)*(j+1)%MOD*g[j-1]%MOD*g[i-j]%MOD,
			g[i]%=MOD;
	f[0][0]=1;
	int c0=0,c1=0;
	for(int i=1;i<=2*n;i++){
		if(mark[i]){
			for(int j=0;j<=n;j++){
				f[i][j]=f[i-1][j];
				for(int k=0;k<j;k++)
					f[i][j]+=f[i-1][k]*C(j-k-1,c1-k)%MOD*(j-k+1)%MOD*g[j-k-1]%MOD,
					f[i][j]%=MOD;
			} 
			c1++;
		}else{
			for(int j=c0;j<=n;j++)
				f[i][j]=f[i-1][j]*(j-c0)%MOD;
			c0++;
		}
	}
	ll x=inv(inv(2,n));
	cout<<f[2*n][n]*x%MOD;
	return 0;
}
```

