### 看其他题解都是套求根公式，本蒟蒻写了个配方法

众所周知，解一元二次方程的方法有 **求根公式法**，**配方法**，因式分解法，直接开根法。

其中只有**求根公式法**和**配方法**是万能的，任何一个一元二次方程都可以根据这两个方法来求解。

其他题解都是公式法，那我就来说一说配方法的方法。

（因为配方法需要用到开根法，所以先解释一下）

开根法其实很简单，大概是就像是  $x^2$=2  然后解出 x=$\ \sqrt{2} $ 这样的形式。


但是很显然，很多方程并不可能都像这种美好的形式（请允许我使用这个形容词）那我们就得要想办法去将题目给的方程变成我们想要的那种形式，这时候，就要请出我们的**配方法**了。

**配方法**，顾名思义，就是想办法把一个长得看起来乱七八糟的一元二次方程弄成一个好康的可以直接开根的方程的形式。


------------

### 数学方法

下面看一看数学方法怎么实现（学过一元二次方程的同学请跳过这里）

我们的数学老师曾经说过配方的口诀：在二次项系数为1的情况下，配出一次项系数的一半。

（通俗一点就是先把方程两边同除a，让二次项系数为一，好配一些，这里就不具体展现证明过程，有兴趣的可以自行百度或询问数学老师）

那么举例，随便给出一个一元二次方程为  $x^2+3x=-2$ 

  
  
 我们一般认为一元二次方程的一般形式为  $ax^2+bx+c=0$
 
 所以整理上面这个方程为  $x^2+3x+2=0$
 
 (有人说这时候就可以因式分解了，但是因为这种方法不是万能的并且用代码不好实现，所以继续选择用配方法做)
 
 这时，我们可以看下这个方程的具体形式，很明显，可以看出对一次项配方有  $x^2+3x+2.25$  可以转化为  $(x+1.5)^2$  的形式，可以开方，所以，我们把原式整理为:
 
  $x^2+3x+2.25-2.25+2=0$
   
  然后接着整理：
  
  $(x+1.5)^2=0.25$
  
  接下来，我们就可以愉快的开方辣！
  
  然后得到  $x1=-1$ , $x2=-2$ 。
  


------------


### 代码重点

这道题真正坑的是某些特殊情况！！！！

（特别是根为0可能输出为-0，调死我了）
 
 具体的情况在代码中注释了，这里就不详细讲了。
 
 下面是喜闻乐见的代码环节。
 
 
 ~~顺便再求个赞啊QAQ~~
 
```c
#include<bits/stdc++.h>
#define int long long
using namespace std;
inline int read(){
   int s=0,w=1;char ch=getchar();
   while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
   while(ch>='0'&&ch<='9') s=s*10+ch-'0',ch=getchar();
   return s*w;
}//快读
double A,B,C;
double b,c,tc,add,r,x_1,x_2;
signed main()
{
	cin>>A>>B>>C;
	
	if(A==0&&B==0&&C==0){//特判1：三个系数都为0的情况下， 输出-1
		printf("%d\n",-1);
		return 0;
	}
	else if(A==0&&B==0&&C!=0){//特判2：a=0，b=0但c不等于0，肯定是无解的，相当于只有系数，输出0 
		printf("%d\n",0);
		return 0;
	}
	else if(A==0&&B!=0){//特判3：如果a=0且b≠0，题目的一元二次方程转化为求一个一元一次方程的方程，直接移项输出答案 
		double ans=-C/B;
		if(ans==-0.0000000000) ans=0.0000000000;//这里要特判ans==-0的时候，直接-c/b有可能答案为-0，转化为0 
		printf("%d\n%.10lf\n",1,ans);
		return 0;
	}
	else if(A==0&&C==0){//特判4：方程为 bx=0  可以一眼看出答案为0，输出 
		printf("1\n0.0000000000");
		return 0;	
	}
	else if(A!=0&&B==0&&C==0){//特判5：方程为 ax^2=0  可以一眼看出答案为0，输出 
		printf("1\n0.0000000000");
		return 0;	
	}
	double derta=B*B-4*A*C;//如果不为特殊情况，则计算derta来判别有几个答案 
	if(derta>0){//derta>0时有两种 
		b=B/A;
		c=C/A;//化系数为1 
		tc=b/2;//二次项系数的一半 
		add=tc*tc;//一半的平方（套口诀 
		r=-c+add;// ( x + tc ) ^ 2 = -c + add  此时的方程可以转化为这样 
		x_1=sqrt(r)-tc;
		x_2=-sqrt(r)-tc;//开始计算两个根，开方 
		if(x_1<=x_2)
			printf("%d\n%.10lf\n%.10lf\n",2,x_1,x_2);
		else if(x_1>x_2)
			printf("%d\n%.10lf\n%.10lf\n",2,x_2,x_1);//这题要按从小到大的顺序输出 
	}
	else if(derta==0){//如果有一个根的情况，计算与两个根时的计算一模一样，输出不同而已 
		b=B/A;
		c=C/A;
		tc=b/2;
		add=tc*tc;
		r=-c+add;// ( x + tc ) ^ 2 = -c + add
		x_1=sqrt(r)-tc;
		x_2=-sqrt(r)-tc;
		if(x_1==-0.0000000000) printf("0.0000000000"); //特判-0的情况 
		else printf("%d\n%.10lf",1,x_1);
	}
	else if(derta<0) printf("%d\n",0);//如果小于0，直接无解，输出0 
	return 0;
}

```
如果有疑问，欢迎私信~

~~第一篇题解求管理给过QAQ~~
   
 
