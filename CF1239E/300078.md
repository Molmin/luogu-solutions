[CF1239E Turtle](http://codeforces.com/problemset/problem/1239/E)
> 一只乌龟从 $2 \times n$ 的矩阵 $a$ 的左上角走到右下角，只能往下或往右，得分等于经过的数字之和，它自动走最大得分的路线，给出一种重排 $a$ 的方案，使得乌龟的得分最小。



第一步还是分析性质以求转化。性质一是**上头一定从左到右逐渐增大，下面一定从左到右逐渐减小**，这样总能让乌龟更有可能接触到的是较小数字。性质二是**最小的两个数一定分居左上角和右下角**，证明可以简单反证。
接下来是重头戏。我们假设乌龟在第 $x$ 列下来，那么 $a_{1,1}+...+a_{1,x}+a_{2,x}+...+a_{2,n}=f(x)$ 为乌龟的得分，而列式知 $f(x+1)-f(x)=a_{1,x+1}-a_{2,x}=g(x)$，由于 $a_1$ 递增而 $a_2$ 递减，所以 $g(x)$ 递增，所以 $f(x)$ 是一个先减小后增大的东西（也可以只减小/增大），故唯可能在 $f(1)$ 或 $f(n)$ 处取得最大值，这是乌龟的策略。形成了转化，要最小化 $\max(a_{1,1}+\sum a_2,a_{2,n}+\sum a_1)=a_{1,1}+a_{2,n}+\max(\sum_{i=1}^{n-1}a_{2,i},\sum_{i=2}^n a_{1,i})$。
这样的好处在于前两项都已知了，后面显然就是一个简单的 01 背包。但是这样过不了，时间空间都太大，用 bitset 可以削减常数和空间，但是空间还是要小心开：`bitset<M>f[51][25],from[51][25];`
