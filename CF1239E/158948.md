\*3100

~~好好的一道题强行把代码难度写成了\*3500。~~

题解区**全是清一色的背包**，但实际上背包能过是因为用了 bitset 的压位，一点都不优雅。

事实上这道题是有~~简单的~~ mim（meet in the middle）搜状态的做法，比其他题解莫名其妙的背包 DP 优化自然又简洁。

------------

由于只能向下而不能向上走，故只有且仅有一次向下的机会，不妨设在 $p$ 位置使用了这个机会。

考虑这样走的路径和：$\sum_{i=1}^pa_{1,i}+\sum_{i=p}^na_{2,i}$，令 $p$ 处下拐的答案为 $ans_p=\sum_{i=1}^pa_{1,i}+\sum_{i=p}^na_{2,i}$。

考虑调整，观察第一行，如果有一个位置存在 $a_{1,x}>a_{1,x+1}$ 发现交换后对于每种 $p$ 的路径和都一定不劣，即分讨一下 $p\le x$ 和 $p>x$ 时发现 $ans_p$ 都不降。

同理观察第二行，如果有一个位置存在 $a_{2,x}<a_{2,x+1}$ 交换后也不劣，即 $ans_p$ 也不降。

故显然是第一行从小到大单增，第二行从大到小单减。

套路的考虑答案的差量为 $dlt_p=ans_p-ans_{p-1}=a_{1,p}-a_{2,p-1}$，由于 $a_{1,p}\le a_{1,p+1},a_{2,p-1}\ge a_{2,p}$，故 $dlt_p\le dlt_{p+1}$。

由于斜率是单调的，那么答案数组 $ans_p$ 肯定是凸的，斜率单增所以是下凸的。

那么最大值在两边取到，即乌龟取到的路径和为 $\max{(ans_1,ans_n)}$。

展开考虑，发现是 $\max{(a_{1,1}+\sum a_{2,i},a_{2,n}+\sum a_{1,i})}$。

------------

这个式子就很容易考虑了，对每个数考虑丢到第一行还是第二行。

按大小顺序丢入，如果是这一行第一次丢就给另一行额外加上 $a_{1,1}/a_{2,n}$ 的贡献，我们现在得到了一个优秀的 $O(2^{2n})$ 的做法。

考虑优化，显然折半，因为丢一半的数后的状态只有占两行的个数和两行分别的和是有用的。

分别跑前后一半数得到 $2\times 2^n$ 个状态，考虑两两进行合并。

首先两行各占 $n$ 个数，凑起来得个数恰好相等，这个限制是好解决的。

然后还要使得 $\max{(a_{1,1}+\sum a_{2,i},a_{2,n}+\sum a_{1,i})}$ 最小，令 $(a,b,t)$ 表示一个状态第一部分和为 $a$，第二部分和为 $b$，占第一行个数为 $t$ 的状态。

形式化一点表述我们要合并的是 $(a_1,b_1,t)\leftrightarrow (a_2,b_2,n-t)$，贡献为 $\max{(a_1+a_2,b_1+b_2)}$。

固定一边，对于另一边的 $(a_2,b_2,n-t)$ 考虑，首先我们可以去掉无用决策，做成一个 $a$ 单增时 $b$ 单减的最优转移决策。

显然最优决策只与 $a_1-b_1$ 的差量有关，在 $b_2-a_2$ 对应的决策波动 $\pm1$ 肯定能取到最优。

考虑快速做这个过程，我们提前对值域进行预处理，提前处理出一个差量 $d$ 二分取到的 $(a_2,b_2)$ 决策是哪个，直接 $O(1)$ 取即可。

复杂度是 $O(2^n+nW)$ 的，其中 $W=n\times V$ 是 $n$ 个数求和起来的值域范围，$V$ 是值域 $\le5\times 10^4$。

这里的 $2^n$ 是好理解的，而 $nW$ 是因为我们还有一维 $t$ 表示状态在第一行占的个数，对于每种 $t$ 我们要对其值域都进行预处理以避开 $2^n$ 的二分。

拿出计算器算一下发现上面两个东西都是 $3\times 10^7$ 级别的，相较于比背包自然许多。

实现过程需要精细，需要避开，同时也是难以实现的有两个部分：

- 枚举 $2^n$ 的状态后需要再花 $n$ 的时间遍历取出 $(a,b,t)$，$n\times 2^n$，可以通过 `dfs` 或状态继承的办法避免。

  我采用的是状态继承，就涉及到了多开数组的问题，采用递归应该可以避免，但实际上是栈空间不在考虑范围内的结果。
- 合并 $2^n$ 状态时采取二分找最优决策，$2^n\times \log$，值域预处理主要解决了这个问题。

实测 $n\times 2^n/2^n\times \log$ 大概等价于 $2^n$ 多一倍的常数，我在有一半做到 $2^n$ 就可以在 ![](https://cdn.luogu.com.cn/upload/image_hosting/i4xcx9zd.png)的时间内通过。（另一半是 $n\times 2^n$）

我全做到 $2^n$ 还快了一倍，注意空间有点卡，我利用值域是 $2^{21}$ 范围的将 6 个 `int` 卡成了 2 个 `LL` 导致常数大了许多多多多多多，但总归是卡进去了。

代码风格混乱邪恶，有需要的自己上 CF 翻一下吧（

附：确实有更简单的 MIM 做法，思路是一样的，就是在我避开的地方进行卡常。

而且卡常能过去（CF 神机），这个算法提供给不想卡常而想使用复杂度优势碾过去的人，于是只好卡实现了。