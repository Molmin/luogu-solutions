这题我大意了啊，看到树状数组的标签满脑子想的都是树状数组……那我就来一篇 **树状数组 × 二分** 的题解吧。

### 1. 求解区间内有多少种不同元素

这等价于求解在这个区间内 **有多少个元素的后面没有与之相同的元素**，这样正好可以做到每种元素恰好计算一次。

显然，如果在这个区间内，某个元素的后面有一个与之相同的元素，那么前面的这个元素就可以“作废”了。如果我们能够求出区间内所有被“作废”的元素个数，再用区间长度减去这一数量，即为答案。

对于区间 $[L, R]$ 的询问，我们扫描 $1$ 到 $R$ 之间的所有元素。对于每个元素，我们将 **与其相同的上一个元素（这个元素即“作废”）的位置** 插入到一个负责存储作废元素位置的树状数组中，然后询问这个树状数组中有多少元素的值在 $[L, R]$ 范围内，即可求出 $[L, R]$ 内有多少个元素“作废”了。

更多详情请看 [P1972 \[SDOI2009\]HH的项链 题解](https://www.luogu.com.cn/problem/solution/P1972)。

### 2. 本题思路

显然，答案序列一定会以某头奶牛结尾，并且 **选择该头奶牛的血统（踢出其他血统的奶牛）**。

那么我们枚举每头奶牛：

1. 先求出以 **该奶牛作为结尾的，最长的，血统种数不超过 $K+1$** 的奶牛区间；
2. 再求出 **这个区间内，与该奶牛血统相同的奶牛的数量**，并更新答案；

即可完成本题。

对于第一步，可以观察到，对于以某头奶牛为结尾的区间，随着长度不断变长，**奶牛血统种数单调不减**。所以，使用二分法即可求解出 **以该奶牛为结尾的，最长的，血统种数不超过 $K+1$** 的奶牛区间。

在二分的过程中，我们需要求解某个区间内奶牛血统种数。可以用题解中第一部分描述的方法进行求解。

得到最长区间后，我们要求出 **该区间内，与最后一头奶牛血统相同的奶牛的数量**。我们可以分别记录每种血统的奶牛出现的所有位置，再使用二分法求出该区间内有多少头对应血统的奶牛即可。

当然，由于奶牛血统取值范围太广，我们需要首先进行离散化。

由于要枚举每头奶牛，又要二分求解以其为结尾的最长区间，每次二分判断的时候还要涉及到树状数组操作，故整体时间复杂度为 $O(N\log ^2 N)$。慢的一批，但是由于数据规模和常数都比较小，因此可以轻松通过本题。

### 3. 代码实现

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <vector>
using namespace std;
#define MAXN 100005
int N, K, B[MAXN];
pair<int, int> A[MAXN];
// 每种奶牛最后一次出现的位置
int prv[MAXN];
// 树状数组
int tn[MAXN];
// 存储每种血统的奶牛出现的位置
vector<int> cnt[MAXN];
int tot = 0;
// 树状数组操作
inline void add(int i, int x) {
    if (!i) {
        return;
    }
    while (i <= N) {
        tn[i] += x;
        i += i & (-i);
    }
}
inline int get(int i) {
    int res = 0;
    while (i) {
        res += tn[i];
        i -= i & (-i);
    }
    return res;
}
int ans = 0;
// 枚举第i头奶牛以为结尾
void get_ans(int i) {
    int l = 1, r = i;
    // 二分法求出最长的，血统种类数不超过K+1的区间
    while (l < r) {
        int m = l + (r - l) / 2;
        // i-(m-1)为区间长度，get(i)-get(m-1)为这个区间内“作废”的奶牛数量
        // 两者相减即为区间内奶牛血统种类总数
        if (i - (m - 1) - (get(i) - get(m - 1)) - 1 <= K) {
            r = m;
        } else {
            l = m + 1;
        }
    }
    int x = l;
    // 求解区间内有多少头奶牛的血统和第i头奶牛一致
    l = 0, r = cnt[B[i]].size();
    while (l < r) {
        int m = l + (r - l) / 2;
        if (cnt[B[i]][m] < x) {
            l = m + 1;
        } else {
            r = m;
        }
    }
    if (ans < cnt[B[i]].size() - l) {
        ans = cnt[B[i]].size() - l;
    }
}
int main() {
    cin >> N >> K;
    for (int i = 1; i <= N; i++) {
        cin >> A[i].first;
        A[i].second = i;
    }
    // 离散化
    sort(A + 1, A + N + 1);
    for (int i = 1; i <= N; i++) {
        B[A[i].second] = A[i].first == A[i - 1].first ? tot : ++tot;
    }
    // 枚举每头奶牛
    for (int i = 1; i <= N; i++) {
        // 将相同血统的上一头奶牛的位置加入树状数组中，即将其“作废”
        add(prv[B[i]], 1);
        prv[B[i]] = i;
        // 记录自己出现的位置
        cnt[B[i]].push_back(i);
        // 求解并更新答案
        get_ans(i);
    }
    cout << ans << endl;
	return 0;
}
```