## 题解 P3069 【[USACO13JAN]Cow Lineup G】

### 题意

+ $n$ 头牛排成一队，每头牛有一个编号；
+ 最多选 $k$ 个数，把编号在这些数里的牛删掉；
+ 求删掉后，编号相同的连续段的最大长度；
+ $n\le100000$，编号 $\le10^9$。

### 解法

把编号相同的牛看成是同一种类的牛。

可以把题目看成是：在每个只有 $k+1$ 种牛的区间中，求数量最多的种类的牛的数量。（有点像绕口令，但我的语文能力有限，我尽力了>_<）

这点不难证明，只有 $k+1$ 种牛的区间，删掉 $k$ 种，一定是编号相同的、连续的区间。

--------

现在的难点是，如何求数量最多的种类的牛的数量。

这点其他题解讲的不是很清楚，我看题解的时候想了好久才想明白，所以我会重点讲一下这部分。

#### 朴素算法

1. 求出每个区间的总复杂度是 $O\left(n\right)$;
1. 朴素地每次比较所有种类的牛的数量，因为比较的个数永远是 $k$，所以复杂度为 $O\left(k\right)$
1. 编号 $\le10^9$，所以肯定要用 map，也就是要有 $O\left(\log n\right)$ 的查询复杂度；

综上，朴素算法的复杂度为 $O\left(nk\log n\right)$

我没找到 $k$ 的范围，翻译没有，我英语又不好，~~谷歌生草机还是阴间翻译~~。

但我们知道 $k$ 一定不会比 $n$，所以上述复杂度不可过。

#### 贪心

也许可以想到一种贪心：以每头牛结尾的区间，用该头牛的种类的数量更新答案。

证明：

设在区间 $\left[l,r\right]$ 中，编号为 $x$ 的数量是最优解，区间中最后一个编号为 $x$ 的牛的位置为 $i$。

那么在扫到以 $i$ 结尾的区间时，$x$ 的数量一定不小于 $\left[l,r\right]$ 中 $x$ 的数量（自己思考一下)。

综上所述，贪心正确。

### 代码

终于讲完了，好累啊。

```cpp
# include <iostream>
# include <map>

using namespace std ;

const int N = 100005 ;

int arr [ N ] ;

int main ( )
{
    int n , k ;
    cin >> n >> k ;
    
    for ( int i = 1 ; i <= n ; ++ i )
    {
        cin >> arr [ i ] ;
    }
    
    map < int , int > ma ; // 编号 -> 数量
    
    int ans = 0 ;
    
    int first = 1 ; // 区间左端点
    
    for ( int i = 1 ; i <= n ; ++ i )
    {
        ++ ma [ arr [ i ] ] ; // 加入区间
        
        while ( ma . size ( ) > k + 1 ) // 大于区间最大数量就把 first 前移
        {
            -- ma [ arr [ first ] ] ;
            
            if ( ma [ arr [ first ] ] == 0 )
            {
                ma . erase ( arr [ first ] ) ;
            }
            
            ++ first ;
        }
        
        ans = max ( ans , ma [ arr [ i ] ] ) ; // 应用贪心，更新答案
    }
    
    cout << ans ;
}
```