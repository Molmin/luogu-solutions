看到了很多用一维数组题解

我发现用二维数组其实也是可以解决的~ 而且感觉比较容易理解一些

首先本题会爆的原因是因为如果开二维数组，由于背包大小M和物品个数N过大，会MLE。

只要用**滚动数组**就可以了 因此我在这里补充一下二维数组的做法~

**已经清楚题意的朋友可以跳过题意理解部分~**

--------------题意理解以及递推式部分---------------

根据题意，我们设当前为第i个物品，背包容量为j，我们设的二维表实际上第i行第j个的意思就是：

在背包容量为j的时候，

前i个物品所能获取的最大价值为:V[i][j]

因此我们可以想到，在第i个物品，背包容量j时，这个最大价值V的可能性可以被划分为两种：
  
条件Ⅰ：在背包足够装第i个物品的的情况下：

①拿第i个物品，放入背包，有价值W[i]

此时我们就知道，此时容量为：

j减去这个物品的重量，
为j-C[i]

那么剩下容量能装的最大价值为：

没拿这个物品时(i-1时)，

剩下背包容量(j-C[i])能装的最大价值:
V[i-1][j-C[i]]

故在条件Ⅰ下：第i个物品，背包容量j时的最大价值V为：

V[i][j]=max(V[i-1][j],V[i-1][j-C[i]]+W[i])


条件Ⅱ：不够装第i个物品，那么这个最大价值为：

V[i][j]=V[i-1][j]

--------------滚动数组部分---------------

但是如果只是上述写法，由于物品数N最大会有3,402个，背包容量最大为12,880，那么数组大小为N*M=43,817,76个元素...

并不能满足要求(MLE)

因此我们需要对内存进行优化：

我们发现递推式V[i][j]=max(V[i-1][j],V[i-1][j-C[i]]+W[i])
只用到了上一行的数据，因此我们并不需要开N个物品的空间~，只需要开2行就可以了~

然后在算到第3行(N=3)的时候，把第一行覆盖掉，这样循环使用~就可以达到我们想要的效果

递推式就变为：

V[i%2][j]=max(V[(i-1)%2][j],V[(i-1)%2][j-C[i]]+W[i]);


```cpp
    for(int i=1;i<=N;i++){
        for(int j=M;j>=1;j--){
            if(j>=C[i])
                V[i%2][j]=max(V[(i-1)%2][j],V[(i-1)%2][j-C[i]]+W[i]);
            //j-C[i]为：拿2之后剩余的重量，然后除此之外的最大值
            else
                V[i%2][j]=V[(i-1)%2][j]
        }
    }

    cout<<V[N%2][M];
```



