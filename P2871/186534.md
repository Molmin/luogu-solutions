# 01背包的裸题（裸的不能再裸了，除非有std）
#### 先来普及一下01背包~~~
01背包是在M件物品取出若干件放在空间为W的背包里，每件物品的体积为W1，W2至Wn，与之相对应的价值为P1,P2至Pn。01背包是背包问题中最简单的问题。01背包的约束条件是给定几种物品，每种物品有且只有一个，并且有权值和体积两个属性。在01背包问题中，因为每种物品只有一个，对于每个物品只需要考虑选与不选两种情况。如果不选择将其放入背包中，则不需要处理。如果选择将其放入背包中，由于不清楚之前放入的物品占据了多大的空间，需要枚举将这个物品放入背包后可能占据背包空间的所有情况。

### 其状态转移方程为：
```cpp
f[i][v]=max{f[i-1][v],f[i-1][v-c[i]]+w[i]}
```
但是可以优化空间，因为二维的会爆空间。
### 优化后的状态转移方程为：
```cpp
f[v]=max{f[v-w[i]]+c[i]};
```
所以代码就出来了。
## code：
```cpp
#include<cstdio>
#include<iostream>
#include<queue>
#include<cmath>
using namespace std;
int n,m,c[3500],w[3500],f[12884];//c存储价值，w存重量 
int main()
{
	scanf("%d%d",&n,&m);//表示数量，大小
	for(int i=1;i<=n;i++)
	scanf("%d%d",&w[i],&c[i]);//输入重量与价值 
	for(int i=1;i<=n;i++)
		for(int v=m;v>=w[i];v--)//枚举
			if(f[v]<f[v-w[i]]+c[i])//找最大值 
				f[v]=f[v-w[i]]+c[i];
	printf("%d",f[m]);//输出最大值 
	return 0;
}
```