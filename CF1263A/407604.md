一道相对简单的题。

我们可以想到把三个数读进一个数组中，然后从小到大排序。我们设排序好后的三个数分别是 $a[0]$ , $a[1]$ 和 $a[2]$ 。

下面要分情况讨论：

当 $a[0]+a[1]≤a[2]$ 时，这时 $a[2]$ 无论怎么样也填不完（等于时刚好吃完），直接输出  $a[0]+a[1]$ 就好了。
     
当 $a[0]+a[1]<a[2]$ 时，我们先把 $a[2]$ 减到和 $a[1]$ 相同大小，然后 $a[0]$ 中的每颗糖，依次和 $a[1]$ 与 $a[2]$ 中的糖配对，直到 $a[0]$ 中不再有糖为止。此时 $a[1]$ 中剩下的糖可以与 $a[2]$ 中剩余的糖配对。中间我们用 $ans$ 来记录 $a[0]$ 用掉的糖。 但 $a[2]$ 有可能会剩下一颗（因为我们先减 $a[1]$ ），所以我们最后的结果是 $ans+a[1]$ （因为 $a[1]$ 不管怎么样肯定是第二小的）。

一些（可能没什么用的）优化：这样子的话， $a[0]$ 肯定会被用掉，那么我们先存一下 $a[0]$ 的初值，最后的结果不就是原来的 $a[0] $ 加上处理后的 $a[2]$ 吗？而且中间干嘛要一个一个来啊，直接求出 $a[0]$ 的一半就可以愉快的减啦~（但其实都可以过）

那么我们来看看代码☆

（无优化版）
```cpp
#include <bits/stdc++.h>
using namespace std;
int main(){
	int t;
	cin>>t;
	while(t--){
		int a[3],ans=0;
		cin>>a[0]>>a[1]>>a[2];
		sort(a,a+3);
		int delta=a[2]-a[1];						//差值 
		if(a[0]+a[1]<=a[2])cout<<a[1]+a[0]<<endl;	//特判a[0]+a[1]≤a[2]	
		else {
			a[2]=a[1];	
			a[0]-=delta;							//先把 a[2] 减到和 a[1] 相同大小 
			ans+=delta;
			while(a[0]>1){							//用a[0] 中的每颗糖，依次和 a[1] 与 a[2] 中的糖配对
				--a[2];
				--a[1];
				ans+=2;
				a[0]-=2;
			}
			if(a[0]==1)a[1]--,ans++;				//当 a[1] 是奇数时，把那颗糖与 a[1] 中的糖配对 
			cout<<ans+a[1]<<endl;					//输出结果 
		}
	}
	return 0;
}
```

（有优化版）
```cpp
#include <bits/stdc++.h>
using namespace std;
int main(){
	int t;
	cin>>t;
	while(t--){
		int a[3];
		cin>>a[0]>>a[1]>>a[2];
		sort(a,a+3);
		int delta=a[2]-a[1];						//差值 
		if(a[0]+a[1]<=a[2])cout<<a[1]+a[0]<<endl;	//特判a[0]+a[1]≤a[2]	
		else {
			int k=a[0];								//存储原来的 a[0] 
			a[2]=a[1];								//先把 a[2] 减到和 a[1] 相同大小 
			a[0]-=delta;
			if(a[0]%2==1)a[1]--;					//当 a[1] 是奇数时，把多出来的那颗糖与 a[1] 中的糖配对 
			int d=a[0]/2;
			a[1]-=d,a[2]-=d;						//用a[0] 中的每颗糖，依次和 a[1] 与 a[2] 中的糖配对
			cout<<k+a[1]<<endl;						//输出结果 
		}
	}
	return 0;
}
```
        