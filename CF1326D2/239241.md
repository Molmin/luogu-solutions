本题解内容可能超出本题范围，建议浏览其他题解明确基本思路后再观看本题解，可作为kmp算法的知识扩充。

以下题解是从本人博客关于kmp多角度理解的博客中截取的**静态角度**例题分析，如需完整分析建议访问[多角度kmp详解](https://www.luogu.com.cn/blog/SingerCoder/post-zi-fu-chuan-kmp-jing-tai-jiao-du-kmp-yang-xie#)。

虽然如此，我也会尽量用最简短的语言，让大家不必看完原博客就能理解静态角度的**最长前后缀匹配**。

由于相关理论可能并不新颖，而且仅为初学kmp的作者自己总结，如和已有观点重合，还请海涵，并务必向我告知，在此感激不尽。

# kmp与最长前后缀匹配（静态角度分析）

最基础的kmp，及其静态动态两种角度的理解，本人博客中已有叙述。这道题是对kmp的**最长前后缀匹配**的应用。（注意静态动态并不冲突，而是不同层面上**相互补充**的关系）

+ 动态角度理解：

  定义i为文本串a的匹配指针，j为模式串b的匹配指针。

  j=nxt[j]相当于模式串整体向右移动j-nxt[j]
  
  如此，简洁明了。
  
+ 静态角度理解：

  具体定义i为文本串**下次将要**匹配的位置，定义j为模式串**已经匹配**了的位置（我们称其为**已匹配串**）。（因此进一步的匹配应该是匹配a[i]与b[j+1]）

  这种理解角度中最大的特点在于将**模式串的移动**（即向右移动j-nxt[j]），理解为**已匹配串的缩短**(即j缩短为nxt[j])。本质相同，只是理解方式有区别，但静态角度更方便理解如何求解**最长前后缀匹配**。

+ 定义**最长前后缀匹配**：指求出一个串的前缀与另一个串的后缀的最长匹配，在kmp算法中体现为文本串某子串的后缀与模式串前缀的最长匹配，这也是kmp算法的核心。

+ 关于kmp求**最长前后缀匹配**，就是在已知转移数组，匹配文本串和模式串的过程中，我们根据静态角度理解可知：“在kmp算法每次循环结束后，j始终保存的是文本串第i位的最长匹配。”（这句是静态角度的核心，建议反复阅读理解）细究一下存的这个匹配究竟是什么，不难发现，这个最长匹配指的是 **文本串以i结尾的后缀** 和 **模式串以j结尾的前缀** 的最长匹配，也就是我们提到的**最长前后缀匹配**。

```cpp
//本人的kmp模板，直接放出防止读者理解有偏差
for(int i=2,j=0;i<=m;++i)
{
    while(j && b[i]!=b[j+1])j=nxt[j];
    if(b[i]==b[j+1])++j;
    nxt[i]=j;
}
for(int i=1,j=0;i<=n;++i)
{
    while(j && a[i]!=b[j+1])j=nxt[j];
    if(a[i]==b[j+1])++j;
    if(j==m)
    {
        printf("%d\n",i-j+1); 
        j=nxt[j];
    }
}
```

# 题目解析

回到这道题，给定一个总串s，定义t=某个前缀+某个后缀（不重叠），使得它们组成的串回文。求出最长的回文串。

1. 不难想到最基本的贪心：先求出等长的前后缀，使得组成的串回文（我们称其为初始串）。则由贪心，初始串应该越长越好。

2. 然后得到去掉初始串后的剩余串（称为剩余子串），则我们需要分别求出剩余子串的一个前缀和一个后缀，要求这个前缀和后缀各自回文且最长，在二者中选择最长的，与初始串一同组成最终的t。

   那么问题来了，如何求出剩余子串的最大回文子串？manacher（~~本人不会~~）？注意观察性质，这里我们要求的最大回文子串必须是剩余子串的前缀或后缀，这种定下一个端点的限制给了我们可操作的空间：设a=正向剩余子串，b=反向剩余子串，并设计函数kmp(char $ * $a,char $ * $b），返回值为a串（文本串）后缀与b串（模式串）前缀的最长匹配（不理解可以见上kmp与**最长前后缀匹配**，或看下方代码）。则：

   正向（左侧）最长回文长度len1=kmp(b,a);（反向后缀和正向前缀的最大匹配）
  
   反向（右侧）最长回文长度len2=kmp(a,b);（正向后缀和反向前缀的最大匹配）
  
   由此得到剩余子串两侧各自的最大回文子串。
  
   Talk is cheap,show me the code（其实cf上给的正解，是直接把我在此理解的最长前后缀的匹配，变成了求组合出的新串的nxt数组。窃以为这样虽巧妙，却不能体现kmp求最长前后缀匹配的实质）
  
```cpp
#include<cstdio>
#include<cstring>
using namespace std;
const int MAXN=1000010;
int n,len,len1,len2;//初始长度，子串长度，正向回文长度，反向回文长度 
char s[MAXN],a[MAXN],b[MAXN];//初始字符串，正向子串，反向子串 

int nxt[MAXN];
int kmp(char *a,char *b)//求a的后缀和b的前缀的最长匹配 
{
	for(int i=2,j=0;i<=len;++i)
	{
		while(j && b[i]!=b[j+1])j=nxt[j];
		if(b[i]==b[j+1])++j;
		nxt[i]=j;
	}
	for(int i=1,j=0;i<=len;++i)
	{
		while(j && a[i]!=b[j+1])j=nxt[j];
		if(a[i]==b[j+1])++j;
		if(i==len)return j;//直接返回文本串第i位的最长前后缀匹配长度
	}
}
void solve()
{
	scanf("%s",s+1);
	n=strlen(s+1);
	//初始化回文
	int p1=0,p2=n+1;
	while(p1+1<p2-1 && s[p1+1]==s[p2-1]){++p1;--p2;}//前后初始串不能重叠 
	//收集正反向子串 
	len=p2-p1-1;
	for(int i=1;i<=len;++i){a[i]=s[p1+i];b[i]=s[p2-i];}
	//双向求子串的最大回文
	len1=kmp(b,a);//正向最大回文 
	len2=kmp(a,b);//反向最大回文 
	//输出最终字符串 
	for(int i=1;i<=p1;++i)putchar(s[i]);//前初始串 
	if(len1>len2)for(int i=1;i<=len1;++i)putchar(s[p1+i]);//正反向回文中最大的 
	else for(int i=len2;i>=1;--i)putchar(s[p2-i]);
	for(int i=p2;i<=n;++i)putchar(s[i]);//后初始串 
	printf("\n");
}
int main()
{
//	freopen("in.txt","r",stdin);
	int t;
	scanf("%d",&t);
	for(int i=1;i<=t;++i)solve();
	return 0;
}
```

仅为个人理解，并非新理论，欢迎交流。