[题目传送门](https://codeforces.com/contest/1835/problem/C)

看到数据范围有 $2^{k+1}$ 个数，然后我们的值域是 $4^k$。

我们首先容易想到进行一个前缀异或，即为 $a$ 数组。

然后可以知道每个数都有 $2k$ 位，不足的用前导 $0$ 补。

我们把 $a$ 数组中每个数分成前 $k$ 位，和后 $k$ 位。

然后我们分两步做，先用一个数组，存储上一个前 $k$ 位，和当前前 $k$ 位相同的，记为 $l$ ，然后把 $(l+1,i)$ 视作一个二元组，表示我们所选的区间，也就是说我们这个区间里的数异或起来只有后 $k$ 位是有值的。然后我们在前面所选的二元组里面，找到一个异或值与当前数相同的，就可以得到我们的答案。

说简单一点就是，当前 $k$ 位有相同的数，那么就能贡献一个二元组。

对于两个二元组如果是答案，记为 $(x_1,y_1)(x_2,y_2)$。

分三种情况。

- $y_1<x_2$ 输出 $(x_1,y_1)(x_2,y_2)$

- $x_1\le x_2\le y_1$，输出 $(x_1,x_2-1),(y_1+1,y_2)$

- $x_2<x_1$ 输出 $(x_2,x_1-1),(y_1+1,y_2)$

这个比较简单，不需要解释，但为什么我们上面找答案的过程就是对的呢。

首先我们有 $2^{k+1}+1$ 个前缀异或（包括了第 $0$ 位的 $0$）。

然后画个图，方便理解

![](https://cdn.luogu.com.cn/upload/image_hosting/xhr69z11.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

这个图中 $a_3=a_4=a_6$ 那么我们就可以得到两个二元组。

$a_2=a_5$ 可以得到一个二元组。

但这时又有一个同学要问 $a_3=a_4=a_6$ 不是可以得到三个二元组吗，但实际上我们不需要三个，因为两个就足以求出答案。

这种解法的巧妙之处在于通过时间允许范围内的枚举次数保证求出答案，这就是这题构造算法的精髓。

如何证明呢：

$2^{k+1}+1=2^k+(2^k+1)$

首先最坏情况，前 $k$ 位所有可能的都出现过，有 $2^k$ 种情况，都是没有贡献的。

然后我们也至少还会有 $2^k+1$ 是有贡献的，因为前面的都已经出现过了，所以后面无论怎么选都有贡献。

而我们后 $k$ 为又只有 $2^k$ 中情况，根据鸽巢原理，可以知道一定会出现一个异或起来等于 $0$ 的情况。于是这题就做完了。

时间复杂度 $O(2^{k+1})$

[code here](https://codeforces.com/contest/1835/submission/211780586)

总结：

人类智慧题。

1、构造题不一定所有情况都要枚举，可以考虑枚举时间范围内允许得枚举次数来保证获得解，那么就可以直接暴力。