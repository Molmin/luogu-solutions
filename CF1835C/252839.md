[Link](https://codeforces.com/contest/1835/problem/C)

题解做法感觉很巧妙，是一道比较好的构造数论题。

首先推性质，看见题目那个 $-1$ 了吗，没错，是欺骗你的。

至于如何证明呢，我们先做一个前缀异或差分，然后一个区间就可以用形如 $(s_x,s_y)$ 的二元组表示（这很套路）。然后考虑我们一共有 $2^{k+1}$ 个数，于是就有 $2^{2k+1}=4^k\times 2$ 个二元组，二元组的取值一共有 $4^k\times2-1$，根据鸽巢原理，一定会有两个二元组相等。

接下来就是抽象的东西，我们考虑对于 $s$ 的二进制前 $k$ 位进行分类，然后对 $s$ 的后 $k$ 位进行匹配。即我们要找形如 $s_x \oplus s_y = s_a\oplus s_b$ 的东西，我们让 $s_a$ 和 $s_b$ 的 前 $k$ 位相等，$s_x$ 和 $s_y$ 的后 $k$ 位相等，然后匹配两两的后 $k$ 位。

至于这样的正确性，与 $-1$ 类似，我们一共有 $2^{k+1}+1=2^k+(2^k+1)$（算上空前缀）个前缀，前 $k$ 位一共有 $2^k$ 种可能性，所以至少会有 $2^k+1$ 个后 $k$ 位的贡献，但是后 $k$ 位最多又只有 $2^k$ 种可能，所以根据鸽巢原理，一定会有重复的。

所以对于每一个前缀（记为 $y$），我们记录上一次与他前 $k$ 位相同的前缀的位置（记为 $x$，然后将 $s_x\oplus s_y$（相当于将后 $k$ 位取出）放到 map 里看一下前面有没有相同的，有就是找到了，然后每次更新 map。

还有个理解性的问题，就是为什么只需要记录上一个，而不是记录前面所有出现过的。因为记一个已经够了，已经可以保证找到 $2^k+1$ 对相同的前 $k$ 位，不需要记更多。

于是这题就做完了...

[Code](https://codeforces.com/contest/1835/submission/211780952)

总结：

构造题还是要多推性质，数学还是得学好，然后枚举讲究策略。