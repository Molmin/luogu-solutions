# **分享解法，巧妙大法师**
## **看到树状，作为树形dp并不拿手的蒟蒻，乖乖的把爪子伸向搜索**
### 虽然是搜索，但是本质上和动态规划还是有着点联系
#### 显然的女仆店数量不可能直接满足n/2
#### 树形结构的图，从根节点开始搜索各个分叉的最小树（分支全为叶子节点），所能生成的最大女仆数值，来向上回溯
以样例为参考，所得的最小树为3—4，能生成最多一个女仆，回溯至2，能生成的还单纯只有1个吗？自然不是，因为2—5 还能生成一个女仆（千万注意2—5并不能算是子树）

所以我们发现，非最小子树也可以包含叶子节点，那么它通过最小树来进行更新的同时自己也可以再加上部分来自根节点和叶子节点（这并不算个子树）所能生成的最多女仆
## **那么我们**
- 在dfs的过程中首先判断这下一个连着的树枝走没走过（f【】，因为是无向图，~~有向图也要其实~~）
- 判断下个点是不是叶子节点，如果是，不走！因为我们只走子树，顺便进行叶子节点数量的统计
- 判断这是不是最小子树，特征就是支路上全是叶子节点（flag）
- 如果是最小子树我们并不会遍历到他的任何节点，但是数量是已知的 G[u].size（）（减掉一条回路再加上一个根节点）
- 并在回溯的过程中再判断自己的值能否更大并再跟新前驱的值
### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+1;
int n,V[N]={0};
bool f[N];
vector<int> G[N];
  
void input()
{
	scanf("%d",&n);
	for(int i=1;i<n;i++)
	{
		int u,v;
		scanf("%d%d",&u,&v);
		G[u].push_back(v);
		G[v].push_back(u);
	}
}
                         
void dfs(int hd,int u) 
{//以1位树根，遍历每个分支的子树分支的子树…… 
	f[u]=1; 
	
	int Kd=0;//记录叶子节点的个数 
	bool flag=0; //判断是否是最小子树 
	for(int i=0;i<G[u].size();i++)
	{//u —>v 
		int v=G[u][i];
		
		if(f[v]) continue;//因为是无向图防止走回头路
	 
		if(G[v].size()==1) 
		{//如果是叶子节点则不走 
			Kd++;
			continue; 
		}
		
		flag=1;//非该支路上的最小子树 
		dfs(u,v);//go on 
	}
	
	if(flag==0) //该支路为最小子树 
		V[u]=G[u].size()/2;//最多能放的女仆
	//实际上是该最小子树上的所有叶子加根，也可以理解为（Kd+1）/2 
		 
	else V[u]+=(1+Kd)/2;//如果非最小子树但也接了叶子 
	//就加上已dfs形成的值的基础上，再加上(根与叶子)/2 
    
	if(u!=1) V[hd]+=V[u];//防止ans*2	
}
  
int main()
{
	input();
	dfs(1,1);
	cout<<V[1];
}
```


## 管理员大大，求过！！！