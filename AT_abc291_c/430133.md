### AT_abc291_c 题解

#### 思路分析

一道挺不错的模拟题。

题目要求从 $(0,0)$ 出发，根据指令走，问有没有走到过相同的点。于是这道题就被分为了两个小问题：

1. “跟着指令走”如何模拟？
2. 如何记录是否走到过相同的点？

首先是第一个问题。这个问题很简单，依次读入指令字符，每次操作后按照要求更新当前坐标即可。

其次是第二个问题。由于数据范围太大，我们不可能开一个数组记录每个点是否访问过，于是考虑使用 STL 数据结构 map，这就需要找到一个特征，使得相同点特征相同，不同点特征不同。我们平常表示一个点，一般使用 $(x,y)$ 的形式，如果我们把它抽象成一个字符串，这就是一个满足要求的特征。接着依据特征使用 map 进行标注就可以了。

最后注意可以使用 to_string 函数将一个整数转化成字符串和标记起点为已经访问，接着按照上述步骤实现即可。

#### 代码

```cpp
//友情提示：该代码仅可在 C++11 及以上的版本编译通过，因为 to_string 为 C++11 及以上的版本的特有函数。
#include <iostream>
#include <string>
#include <map> 
using namespace std;

map <string, bool> mp; //用于标记的数据结构，表示某一个点字符串是否访问过。 

string constr(int x, int y) //用于根据坐标构造点字符串。 
{
	//根据形式 (x,y) 进行拼接生成。
	return "(" + to_string(x) + "," + to_string(y) + ")";	
} 

int main()
{
	int n;
	cin >> n;
	int x = 0, y = 0; //初始坐标（原点）。 
	mp[constr(x, y)] = true; //标记起点访问。 
	for(int i = 1;i <= n;i++)
	{
		char c;
		cin >> c; 
		//根据指令移动。 
		if(c == 'R') //向右。 
		{
			x++;
		}
		else if(c == 'L') //向左。 
		{
			x--;
		}
		else if(c == 'U') //向上。 
		{
			y++;
		}
		else if(c == 'D') //向下。 
		{
			y--;
		}
		if(mp[constr(x, y)]) //如果该点访问过。 
		{
			cout << "Yes" << endl;	
			return 0;
		} 
		mp[constr(x, y)] = true; //标记该点已经访问。 
	}
	cout << "No" << endl; //指令结束后仍然不重复，即没有。 
	return 0;
}
```

