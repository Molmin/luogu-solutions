一道比较妙的数据结构题。

前置知识：可持久化 Trie 树、启发式合并、单调栈。

首先思考如何解决 $\max$。对于每个 $i$ 求 $l_i$ 和 $r_i$，使得  $\max(a_{l_i},a_{{l_i}+1},..., a_i,...,a_{{r_i}-1},a_{r_i})=a_i(i \in [l_i,r_i])$。$l_i$ 和 $r_i$ 可以用单调栈求出。

我们可以直接枚举 $i$，然后算出当 $a_i$ 为此时区间最大值时，$\max(a_{l},a_{{l}+1},...,a_{{r}-1},a_{r}) \oplus (a_{l}\oplus a_{{l}+1}\oplus ...\oplus a_{{r}-1}\oplus a_{r})$ 的最大值，再对所有 $i$ 算出的值取最大值即为答案。

对于每个 $i$，其左端点和右端点分别在 $[l_i,i]$ 和 $[i,r_i]$ 之间，思考如何在小于 $O(\sqrt n)$ 的时间复杂度内找到使得上述式子最大的左端点和右端点。

先设 $sum$ 数组为 $a$ 数组的异或前缀和数组，那么原问题转化为求 $\max_{i\in [1,n],j \in [l_i-1,i-1],k \in [i,r_i]}(a_i\oplus sum_j \oplus sum_k)$，$a_i$ 已知。

我们知道 Trie 树可以解决 XOR Largest Pair 问题，但是此时想要得到一个只包含特定区间内的全部数的 Trie 树来找 $sum_j$ 和 $sum_k$，可以使用可持久化 Trie 树。

但是现在有两个区间，需要取两个数，无法求 XOR Largest Pair。

考虑启发式合并，每次枚举两个区间中较小的区间，那么我们可以直接在较大的区间里求 $a_i \oplus sum_j$（这里的 $j$ 在较小的区间中）的 XOR Largest Pair，每次操作相当于是合并 $[l_i-1,i-1]$ 和 $[i,r_i]$，最多合并 $\log n$ 次。

所以时间复杂度为 $O(n \log n \log V)$。

这里注意 $a_i$ 有可能相同，我们以下标为第二关键字比大小，那么就不会出现相同的情况。至于为什么不会有错解，读者可以造一个 $a_i$ 全部一样的数据自行思考。

[Code](https://codeforces.com/contest/1777/submission/190730078)。 