关于这道题，我有一个**神奇**的做法，这种做法也不是很流行。 _实现难度也比较大，但希望各位能从其中能有所得。_ 

**首先**：建立一个栈记录可行解，一个数组储存原来数据。

**然后**：将R和G分别处理成为0,1并逐步放到栈内：

①如果遇到01或者10，将01(或者10)合成2,替换原来的01(10)，这样就用贪心把靠前的一组可行解合并了；

②如果遇到021(或者120)将这3个合成4，041也可以这样合成6，以此类推；

③如果遇到22、24、42、46这样的数据合并它们。

这个栈中储存了(num,poi)：

num是处理后的数据，num只有两种情况：

①2,4,6这样的大于0的偶数，表示合并了num个宝石的可行解。

②情况就是“散宝石”，0表示单独的R，1表示单独的G，poi是可行解最左边宝石在源数据中的下标。

例如(4,0)表示可行解大小为4,可行解在源数据最左边的边界是0，后面需要用到这个可行解的位置。

如此合并出的可行解是贪心的结果，可行解的左边右边都是“散宝石”。

**最后**：我们可以让可行解的范围向右滚动，如果范围内最左边的宝石和右边相邻的宝石一致，抛弃范围内最左边的宝石，加上右边相邻的宝石，合成新的可行解，直到这个可行解“撞”到另一个可行解上，或者无法滚动。

依次记录最大值。这个最大值就是解。
```cpp
(这是我人肉打出来的数据)
源数据：RRGGGGRGGGRGGGRRRGRGGRGRGRG
处理  ：0011 1 10 1 1 1011100010 1 101010 1
得到  ：4    1 2  1 1 10         1 6      1
(其中：1是G，0是R，其余偶数表示已合成的可行解)
数据栈：(4,0)  (1,4)  (2,5)  (1,7)  (1,8)  (10,9)  (1,19)  (6,20)  (1,26)
最大解：让1011100010向右滚动变成0111000101此时发现这个可行解“撞”上了另一组可行解，记录两个可行解的和,该解是最大值。
```
附上代码：
```cpp
#include<cstdio>
#define max(a,b) (a>b?a:b)
bool x[1000010]; //源数据 
struct Node{int num,poi;}y[1000010];//合成栈 
int main()
{
	int headx=0,heady=0,a;
	register int i,j;
	char c;
	while((c=getchar())!=-1)
	{
		if(c=='G')a=1; //将R转化成0，G转化成1压入栈中 
		else a=0;
		y[heady].num=a,y[heady].poi=headx,heady++;
		x[headx++]=a;
		if(heady>=2) //把栈顶01(10)这样的数据合成 
			if(y[heady-2].num+y[heady-1].num==1)
				y[heady-2].num=2,heady--;
		if(heady>=3) //把栈顶021(120)这样的数据合成 
			if(y[heady-2].num>=2 && y[heady-3].num+y[heady-1].num==1)
				y[heady-3].num=y[heady-2].num+2,heady-=2;
		if(heady>=2) //把栈顶22、24、62这样的数据合成 
			if(y[heady-1].num>=2 && y[heady-2].num>=2)
				y[heady-2].num+=y[heady-1].num,heady--;
	} //此时栈中的数据中包含着散宝石和合成了的可行解，且交错出现 
	int max0=0;
	for(i=j=0;i<heady;i++) //这里将散宝石剔除出去，留下可行解 
		if(y[i].num>=2) //i表示扫描位置，j表示新栈的栈顶 
		{
			y[j].num=y[i].num;
			y[j].poi=y[i].poi;
			j++;
		} //处理完不必管栈顶之外的非0元素 
	heady=j; //还要更改栈顶的位置 
	for(i=0;i<heady-1;i++)//定义l为可行解最左面的宝石的位置 
	{					  //定义r为可行解右面相邻的宝石的位置 
		int sum,l=y[i].poi,r=y[i].poi+y[i].num; 
		while(x[r]==x[l]&&r!=y[i+1].poi) //滚动 
			l++,r++;
		if(r==y[i+1].poi) //检测是否撞到另一个可行解 
			sum=y[i].num+y[i+1].num;//把两个可行解加在一块 
		else
			sum=y[i].num;
		max0=max(max0,sum);
	}
	max0=max(max0,y[heady-1].num);//还要考虑排在最后的可行解 
	printf("%d",max0);
}
```