对于这种每次操作随机的题目，要考虑一个元素被删除的时候的情况

例如说，一个元素i被删除，那么假设i左边是a，右边是b，ans就+=min(a,b);

而删除的那个数是不会被统计到答案里面的，那么如果这个删除的数很小是不划算的，因为a<=i的时候，删i能获得a的贡献，但是删a能获得i的贡献，显然删a更优秀。

所以对于相邻的三个元素a,i,b,假如i比a，b都小，那么立即删除i，因为你现在不删，删除a的时候还要考虑i的情况，那么要么答案加上i，要么加上比i还小的数值，得不偿失。现在就删除i，加上的是a,b中的最小值，比i要大

在经过这样一遍扫之后，其实整个数列就会是一个单调数列

例如1，2，3，4，5

因为如果不单调，那么就说明会有一个阻碍的

例如1 2 3 2 5

然而这类情况不会出现，因为第一遍扫的时候已经把第二个2删除了

扫完之后，从小到大的前n-2个就是答案，原因说一下

1 2 3 4 5 ←对于这个数列，首先5是不会被统计到的，删除5也是不可能的（删除5只能获得0的贡献，不如删除4还有3的贡献）。删除4获得3的贡献，删除3获得2的贡献，删除2获得1的贡献。

当然题目中要求删除干净，那就删除1，5（反正没贡献）

总结：对于n次操作，每次都在n个元素中随机位置操作的题目，考虑一个元素被操作的时候满足的情况。并且比较连续元素ai,ai+1,ai+2,ai+3,ai+4,ai+5中，ai+2被删除和ai+3被删除什么时候更好

代码不给了