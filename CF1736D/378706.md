自认为比其它题解说的更详细 qwq

### 题意

给你 $N(1 \le N \le 10^5)$，给你一个长度为 $2N$ 的只包含字符 `0` 和 `1` 的字符串。你要把它分成 $2$ 个相等的子序列。

我们称 $S$ 两个子序列（不一定连续） $a,b$ 是相等的，当且仅当：

- $|a|=|b|$；

- $S$ 的每个元素，要么在 $a$ 出现 $1$ 次，要么在 $b$ 出现 $1$ 次；

- 对于每个 $1 \le i \le N$，满足 $a_i=b_i$。

除此以外，你可以对字符串 $S$ 进行 $1$ 次操作：

选取 $S$ 的一个不一定连续的下标序列 $b_{1,2,\cdots ,M}$，让 $S_{b_1} \leftarrow  S_{b_M},S_{b_2} \leftarrow  S_{b_1},\cdots S_{b_M} \leftarrow  S_{b_M-1}$。也就是让这个子序列的所有元素旋转一位。

现在，对于给你的 $S$，如果它可以通过一次或零次操作得到两个相等的子序列，那么输出操作序列和最后两个相等的子序列中的一个的下标。如果不能，输出 `-1`。

### 分析

首先，显然 $S$ 中 `0` 和 `1` 的个数应为偶数，否则输出 `-1`。

之后我们发现，如果 $S$ 中 `0` 和 `1` 的个数为偶数，那么如果我们能够把 $S$ 变成这样的形式：

`1100111100000011......`（也就是说两个 `1` 挨着，两个 `0` 挨着）

那么由所有奇数下标构成的子序列显然等于所有偶数下标构成的子序列。

在上面的那个例子中就是：

`Odd:10110001......`

`Even:10110001......`

所以现在我们需要做的就是把 $S$ 字符串变成一个**让它的每一个奇数位等于这个奇数位的下一位**的字符串。这就用到旋转操作了。

我们以 `100111001010` 举例：

我们首先把字符串以 $2$ 为单位分隔开：`10|01|11|00|10|10`

其中第 $3$ 个单位和第 $4$ 个单位我们其实就不用处理了。

我们把第 $1,2,5,6$ 个单位拿出来：`10|01|10|10`

现在，我们想让每个单位内的字符相同。我们不妨强制让第一个单位只想要 `0`，那么里面有一个 `1` 被“排斥”了出来。我们强制第二个单位只想要 `1`，有一个 `0` 被排斥出来；强制第五个单位只想要 `0`，有一个 `1` 被排斥；这样一直循环下去。我们把所有被排斥出来的元素组成一个字符串：

`1010`

可以轻而易举的证明这是一个 `1` `0` 交替出现且长度为偶数的串。现在我们对这个串进行一次旋转操作，这个串就变成了

`0101`

现在我们把这个排斥串重新安到原来的串里，原来的串就变成了：

`00|11|00|11`

成为了一个满足奇数位和下一位相等条件的字符串。

也就是 **受到操作的下标子序列 $=$ 被“排斥”的元素的下标序列，最后的两个相同子序列中的一个的下标 $=$ $\{1,3,5,7,\cdots , 2N-1\}$**。

**AC CODE**

```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAXN=2e5+5;
int T,N;
int a[MAXN];
int main()
{
	scanf("%d",&T);
	while(T--)
	{
		scanf("%d",&N);
		int cnt0=0,cnt1=0;
		for(int i=1;i<=N*2;i++) 
		{
			scanf("%1d",&a[i]);
			if(a[i]) cnt1++;
			else cnt0++;
		}
		if(cnt1%2||cnt0%2)//如果无解
		{
			puts("-1");
			continue;
		}
		int select=1;
		int tot=0;
		int f[MAXN];
		for(int i=1;i<=N*2;i+=2)//每2个是一个单位
		{
			if(a[i]==a[i+1]) continue;//如果这个单位已经满足要求跳过
			if(a[i]==select) f[++tot]=i;
			else f[++tot]=i+1;
			select=1-select;//各个单位交替排斥0和1
		}
		printf("%d ",tot);
		for(int i=1;i<=tot;i++) printf("%d ",f[i]);//排斥序列==操作序列
		puts("");
		for(int i=1;i<=N*2;i+=2) printf("%d ",i);
		puts("");
	}
	return 0;
}
```


