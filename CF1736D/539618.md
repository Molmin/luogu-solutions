# CF1736D 题解



## 思路分析

显然：`0` 和 `1` 出现的次数如果是奇数那么一定无解。

对于剩下的情况，注意到如下的观察：

> 观察：
>
> 我们定义第 $2i-1$ 位和第 $2i$ 位的字符构成一个“字符组”（$i\in[1,n]$），那么通过一次轮转操作，我们一定能使得原串中只含有字符组 `00` 和 `11`，下述操作方法：
>
> 以字符串 `000110111001` 为例：我们可以将其每两位进行划分得到 $6$ 个字符组：`00 | 01 | 10 | 11 | 10 | 01`。
>
> 显然对于字符组 `00` 和 `11` 没有操作的必要，而对于字符组 `10` 和字符组 `01`，我们对于每个字符组取出其中一个字符，并且满足我们取出的字符串是 `0` 和 `1` 交替的，由于需要取出字符的字符组中同时包含 `0` 和 `1`，所以一定存在这样的取出方案。
>
> 对于上面举的例子，我们对第 $2$ 个字符组取出第 $3$ 位 `0`，对第 $3$ 个字符组取出第 $5$ 位 `1`，对第 $5$ 个字符组取出第 $10$ 位 `0`，对第 $6$ 个字符组取出第 $12$ 位 `1`，最终得到取出的子序列 `0101`。
>
> 对取出的子序列右移一位，由于 `0` 和 `1` 出现的次数都是偶数，所以字符组 `01` 和字符组 `10` 的数量总和应该也为偶数，因此得到的子序列长度也是偶数，右移一位后恰好得到原序列取反，如例子中右移得到子序列 。`1010`
>
> 把取出的子序列放回去，那么被取出 `0` 的字符组有一个 `1` 没被操作，又获得了一个 `1`，那么我们就得到了字符组 `11`，同理，被取出 `1` 的字符组会变成字符组 `00`，如例子中得到了序列 `00 | 11 | 00 | 11 | 11 | 00 `。

根据观察中的构造方法，我们可以对于每个字符串通过右移使字符串仅由字符组 `00` 和 `11` 构成的，那么对于每个字符组，给 $S^p$ 和 $S^q$ 各一个字符即可。

时间复杂度 $\Theta(n)$。

## 代码呈现

```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAXN=2e5+1;
char str[MAXN];
inline void solve() {
	int n;
	scanf("%d%s",&n,str+1);
	vector <int> res;
	for(int i=1,op=0;i<=2*n;i+=2) {
		if(str[i]==str[i+1]) continue;
		op^=1;
		if(str[i]=='0'+op) res.push_back(i);
		else res.push_back(i+1);
	}
	if((int)res.size()%2==1) {
		puts("-1");
		return ;
	}
	printf("%d ",(int)res.size());
	for(int u:res) printf("%d ",u);
	puts("");
	for(int i=1;i<2*n;i+=2) printf("%d ",i);
	puts("");
}
signed main() {
	int T;
	scanf("%d",&T);
	while(T--) solve();
	return 0;
}
```

