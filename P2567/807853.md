前置芝士：容斥原理。

### 预处理

容易发现， $[1,10^{10}]$ 之间的幸运数字的总数只有 $2046$，我们可以直接使用 dfs 把他们预处理出来，接着从小到大排序。

程序如下：

```
void p_dfs(ll p)
{
	if(p>r) //如果 p 大于右边界就退出
	{
		return;
	}
	lucky[++cnt]=p; //将幸运数字 p 保存到数组中 
	p_dfs(p*10+6); //下一位是 6
	p_dfs(p*10+8); //下一位是 8
}
```
### 核心部分

已经计算出了幸运数字，现在考虑近似幸运数字的个数。

在 $[l,r]$ 这个区间中，幸运数字 $x$ 的出现次数为 $\lfloor \frac{r}{x} \rfloor-\lfloor\frac{l-1}{x}\rfloor$。但是两个幸运数字的倍数，即近似幸运号码可能有交集，所以需要容斥，

就是这个： 选 $1$ 个幸运数字 $-$ $[l,r]$ 之间数值为 $2$ 个幸运数字的 lcm 的个数 $+$ $[l,r]$ 之间数值为 $3$ 个幸运数字的 lcm 的个数......

然后拥有了这个代码（此代码看词来复杂度极高，但是多个幸运数字的 lcm 很大，很容易超过 $r$，所以复杂度其实挺小的）：

```
ll calc(ll x) //求 [l,r] 之间 x 出现了几次
{
	return r/x-(l-1)/x; 
}
ll _lcm(ll a,ll b) //求 a,b 的 lcm
{
	return a*b/__gcd(a,b);
}
ll dfs(ll last,ll lcm,ll opt)
//last 是上一个幸运数字的位置
//lcm 是前几个幸运数字的 lcm
//opt 是当前要加要减（在容斥中的符号有变化）
{
	ll ans=0;
	for(int i=last;i<2047;i++) //枚举每一个幸运数字
	{
		ll tmp1=_lcm(lcm,lucky[i]); //加上这个数字的 lcm
		if(tmp1<=r && tmp1>0) //不超过上界，并且要 >0（小余 0 就溢出了）
		{
			ans+=opt*calc(tmp1); //累加答案
			ans+=dfs(i+1,tmp1,-opt); //记得变符号
		}
	}
	return ans;
}
```

~~然后就 T 了……~~

[TLE 记录](https://www.luogu.com.cn/record/101737951)

### 剪枝

发现一点：如果有两个幸运数字 $x,y$ 并且 $x \bmod y=0$，那么 $y$ 根本没有用，因为是 $y$ 倍数的近似幸运数字一定是 $x$ 的倍数。

所以我们可以在预处理时将 $y$ 给去除，这样子剩下的幸运数字会少很多，大概 $1000$ 左右吧，此时就可以通过了。

