一看到这道题果断想到贪心，理由：

费用和能力（能砍掉头大小）相等，意味着砍掉一个大小a的头花费至少为a

由于最后的花费要最小，所以骑士的费用要尽可能接近头的大小（差距尽量要小）

综上所述，这道题的正解（不知道有没有之一）就是贪心

具体思路如下：

**排序：对头大小和骑士能力/费用分别做排序**

原理：“小头小费用”原则，保证花费最小

**模拟：两个指针，一个指向头，一个指向骑士**
**看当前骑士能否解决当前的头，能的话均右移一位，同时计入费用；不能的话骑士指针右移一位**

原理：排序后保证从小到大，能解决必然是最优方案（费用最小）；不能解决就换更高级的骑士解决（有序保证越后的骑士能力越高）

**结算：所有骑士均被扫过而还有怪物的头剩余，无解**

原理：怪物的头太大，骑士砍不了（mmp的村长只能认命）
****
附上代码：
```
#include<iostream>
#include<algorithm>
using namespace std;
int n,m,tot,p1,p2;
long long x[20000+10],a[20000+10],sum;
int main()
{
	p1=p2=1; //p1头指针，p2骑士指针
	cin>>n>>m;
	if(m<n) //特判
	{
		cout<<"you died!"<<endl;
		return 0;
	}
	tot=n; //tot怪物头数量（没用）
	for(int i=1;i<=n;i++) cin>>x[i];
	for(int i=1;i<=m;i++) cin>>a[i];
	sort(x+1,x+n+1);
	sort(a+1,a+m+1);
	while(p1<=n&&p2<=m)
	{
		if(!tot) break; //没头可以撤了
		if(a[p2]>=x[p1]) 
		{
			tot--;
			sum+=a[p2];
			p1++;
		}//打得过
		p2++;//无论打得打不过都得换（1骑士只能砍1个头）
	}
	if(tot) cout<<"you died!"<<endl; //砍不完的头
	else cout<<sum<<endl;
	return 0;
 } 
 ```

PS.解题小插曲：

**1.一开始我用for循环70分，发现骑士不管能否解决头指针都会右移，果断改while循环AC**

**2.一开始m小于n就直接gg了（注意一个骑士只能砍一个头），至于!tot和后面p2<=m效果一样，不过也懒得改了**

这就是本蒟蒻的解法（dalao勿喷，逃）




