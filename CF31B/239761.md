

刚看到这个题的时候，感觉是一道~~究极大水题~~，然后做题的时候发现要注意的细节很多，导致我3遍才AC，~~还是菜啊~~。


   
好，重点来了，这一道模拟题，我们如何去防坑？


$first$，需要把题目看懂。这道题概括来说，就是输入一个字符串，然后分成一些$A@B$形式的子串，如果无法做到，输出$No$ $solution$，如果能做到，输出任意一种即可。



$second$，找关键。这道题的关键在于这个字符：$@$.我们来梳理一下这个字符的用处。

我们可以定义一个集合，这个集合分为2部分，第一部分为不含$@$的字符串，第二部分为含$@$的字符串，可以选择分类讨论。

①，如果整个字符串没有这个字符，也就是说无法构成任意一个$A@B$形式的子串，那肯定要输出$No$ $solution$了。

②，如果这个字符串有这个字符，我们依旧需要去判断能不能做到把这个字符串分成一些$A@B$形式的子串，但是就比较easy了，几乎不用特判。

可以在纸上画一个图，我们考虑一下，如果有$@C@$或者$@@$这种情况,一定是不对的,所以输出$No$ $solution$.

然后,给出一个判断的code

```cpp
bool pd()
{
	for(i=2;i<=n-1;++i)
	{
		if(s[i]=='@'&&s[i+1]=='@')
		return 0;
	}
	for(i=2;i<=n-2;++i)
	{
		if(s[i]=='@'&&s[i+2]=='@')
		return 0;
	}
	return 1;
}
```

但是,这是不对的,因为我们少判了一种情况,如果是$s[1]$或者
$s[n]$=$@$,也是不对的,所以,可以加一句判断。

```
if(s[1]=='@'||s[n]=='@')
return 0;
```
判断的完整$code$就是这样的（第一种情况在输入中特判）:

```cpp
bool pd()
{
	if(s[1]=='@'||s[n]=='@')
	return 0;
	for(i=2;i<=n-1;++i)
	{
		if(s[i]=='@'&&s[i+1]=='@')
		return 0;
	}
	for(i=2;i<=n-2;++i)
	{
		if(s[i]=='@'&&s[i+2]=='@')
		return 0;
	}
	return 1;
}
```

接下来$third$,我们要关注输出部分的细节。一个程序，如果输出有问题，即使方法写的再好，也依旧是全WA，所以输出是重点！！！

题目要求输出任意一种可行的办法，我们可以这样想，假设一个字符串为$kkk@sc@03$，要求任意一种办法，可以把子串的倒数第二个字符做成$@$，这样就一定能保证方法可行。

如果不理解意思，请看下面

```
kkk@sc@03
    .
    .
.   .   .
  . . .
    .
kkk@s,c@03

Fz@zzzz@zzzz@zz@zzz
    .
    .
.   .   .
  . . .
    .
Fz@z,zzz@z,zzz@z,z@zzz
```
这里上code

```
void out()
{
        for(i=1;i<=n;++i)
	{
		if(s[i-2]=='@')
		printf(",");
		printf("%c",s[i]);
	}
}
```
然后发现还是错了。forth，自己出样例，找问题。于是，我就找到了这样一个样例

$kkk@sc@03$ 

我们预想它变成$kkk@s,c@03$

可是，它却变成了$kkk@s,c@0,3$ 

发现问题，最后一个被单独分开了。所以怎么办？我们可以在输入的地方去预处理，找到最后一个$@$的下标$last$，然后在判断$@$的那一句加上$last!=i-2$，这样我们正好可以在判断的地方写上:
```
if(last==-1)
return 0;//last初始值为-1
```
所以正确的判断code：

```cpp
bool pd()
{
	if(s[1]=='@'||s[n]=='@'||last==-1)
	return 0;
	for(i=2;i<=n-1;++i)
	{
		if(s[i]=='@'&&s[i+1]=='@')
		return 0;
	}
	for(i=2;i<=n-2;++i)
	{
		if(s[i]=='@'&&s[i+2]=='@')
		return 0;
	}
	return 1;
}
```


在输出的函数中，既然存在$i-2$，所以i从3开始就行了，$i<3$无意义。

正确的输出code：

```
void out()
{
	for(i=1;i<=n;++i)
	{
		if(s[i-2]=='@'&&i-2!=last)
		printf(",");
		printf("%c",s[i]);
	}
}
```


万事俱备，只差AC！上code：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define N 201
char s[N];
int i,n,last=-1;
void in()
{
	scanf("%s",s);
	n=strlen(s);
	for(i=n;i>=1;--i)
	{
		s[i]=s[i-1];
		if(s[i]=='@'&&last==-1)
		last=i;
	}
	s[0]=48;
}
bool pd()
{
	if(s[1]=='@'||s[n]=='@'||last==-1)
	return 0;
	for(i=2;i<=n-1;++i)
	{
		if(s[i]=='@'&&s[i+1]=='@')
		return 0;
	}
	for(i=2;i<=n-2;++i)
	{
		if(s[i]=='@'&&s[i+2]=='@')
		return 0;
	}
	return 1;
}
void out()
{
	for(i=1;i<=n;++i)
	{
		if(s[i-2]=='@'&&i-2!=last)
		printf(",");
		printf("%c",s[i]);
	}
}
int main()
{
	in();
	if(pd()==0)
	{
		printf("No solution");
		return 0;
	}
	out();
	return 0;
}
```

最后，请dalao们点个赞再走吧。
