### 这题普及+？？？

其实就是考一个字符串成员函数的运用。

看了别的 dalao 的题解，一个用循环查找，一个用队列……

**成员函数**难道不香吗……



------------


## 开始正经的思路分析：

~~原题不解释了~~。

	题目给了一个字符串，要求编写一个程序，在里面提取邮箱地址。
    邮箱地址的格式是 A @ B ，其中 A 和 B 均为字符串。
    
看到这里，第一反应就是查找字符串中“@”的位置。

由于有不合法的情况，所以在分割之前要做判定。

不合法的情况共有三种：

- 在字符串首尾出现 @ 字符。

- 在两个 @ 字符中只有一个小写字母。

- 整个字符串不包含 @ 字符。

笔者在做这道题的时候前前后后交了五次，很大程度上就是因为第三种~~没考虑~~。

再看题目：

	答案可能不唯一，随意输出一个就好。
    
为了方便，我们需要采用统一的分割方法。

我采用的方法是在 @ 后保留一个字母，随后割开。
    
    比如 a@aaaa@aaa@a 就应该分割为 a@a,aaa@a,aa@a 。
    


------------


    
## 筛出不合法情况的方法：

	先判断在字符串首尾是否出现 @ 字符和整个字符串是否包含 @ 字符。

	然后如果仍然合法，就继续做。
    
    查找第一个 @ 字符，在它的周围判断字符串的合法性。
    
    这样一直做，直到检查完最后一个 @ 字符。
    
这里需要运用 STL 库中的成员函数，就~~不细讲了~~。

贴上这一部分的代码：

~~~
bool Inspect( string s ){
	if ( s.find( '@' ) == string::npos )  //第一步筛查
	{
		return false;
	}
	int l = s.size();
	if ( s[0] == '@' || s[l-1] == '@' )  //第二部筛查
	{
		return false;
	}
	int k = 0,Sk = 0;
    // k 是当前筛到的 @ 字符的位置，Sk 是上一个 @ 字符的位置
	while ( s.find( '@' , k + 1 ) != string::npos )  //如果后面还有
	{
		k = s.find( '@' , k + 1 );
		if ( Sk == 0 )  //表明是第一个 @ 字符
		{
			Sk = k;
			continue;  //不用继续判断
		}
		if ( ( k - Sk <= 2 ) || ( s.find( '@' , k + 1 ) - k <= 2 ) )  //第三部筛查
		{
			return false;
		}
	}
	return true;
}
~~~



------------



## 字符串分割的方法：

由于笔者 substr 用不好，所以~~偷懒~~没用。

有纯粹的 STL 做法，但这里讲一种比较朴素的算法。

	从字符串开始用 for 查找。
    
    找到 @ 字符以后，记录下它的位置。
    
    然后从上一个记录的 @ 位置（或开头）一直输出到当前 @ 位置的后一位，然后继续找。
    
但需要注意的是，如果从当前查找位置后没有 @ 字符了（换句话说，这是最后一个 @ 字符），就要全部输出。

然后我又优化了一下：

	查找 @ 字符的后一位，而不是查找 @ 字符的位置。
    
    这样可以避免是 +1 还是 +2 的困惑。

部分代码：

~~~
void Work( string s ){
	int l = s.size();
	int k = 0;
    // k 这里指这个邮箱地址的起始位置
	for ( int i = 0 ; i < l ; i++ )
	{
		if ( s[i-1] == '@' )  //上一位是 @ 字符
		{
			if ( s.find( '@' , i ) == string::npos )  //已经是最后一个 @ 字符了
			{
				for ( int j = k ; j < l ; j++ )  //直接输到最后
				{
					cout << s[j];
				}
				cout << endl;
				return;
			}
			else  //普通输出
			{
				for ( int j = k ; j <= i ; j++ )
				{
					cout << s[j];
				}
				cout << ",";  //不要忘了逗号
				k = i + 1;  //标记下一个邮箱地址的起始位置
			}
		}
	}
}
~~~

主程序代码~~太水了~~，就不贴出来了。



------------



## 做后心得：

本题有多种做法，可以按照自己的能力来选择。

代码能力要求较低，掌握了 C++ 自带的 string 或想到了用循环的朴素算法后基本上不会写不出。

思维量中等，需要考虑清楚不合法的情况有几种。

总之，个人认为这是一道很好的字符串练手题，可以练一练 find 等成员函数的运用。