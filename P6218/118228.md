# 思路

**为方便表述，定义函数 $f(l,r)$ 为区间 $[l,r]$ 中“圆数”的个数。**

显然，$f(l,r)=f(1,r)-f(1,l-1)$。

那么，如何快速求出 $f(1,x)$?

以 $14$ 为例。其二进制表示为 $(1110)_2$。$f(1,(1110)_2)$ 又可以拆分为两部分：

$$f((1)_2,(1)_2)+f((10)_2,(11)_2)+f((100)_2,(111)_2)$$

以及：

$$f((1000)_2,(1001)_2)+f((1010)_2,(1011)_2)+f((1100)_2,(1100)_2)$$

这些有什么共同点吗？我们发现，**在每个函数表示的区间中，每一个整数的二进制表示位数相同，且最高几位相同。**

也许我们可以预处理出一些东西？

# 预处理

由于最高几位相同，我们只需要关注余下的几位——这几位组成了一个 $01$ 串。

**用 $c(l,k)$ 表示长度为 $l$ 的，含有 $k$ 个 $0$ 的 $01$ 串的数目。即 $C_l^k$。**

最大数据的二进制表示不超过 $31$ 位。只需预处理 $1\le l<32$ 的情况即可。

简单的递推。参考代码：

```
void inti(){
	for(int i=1;i<32;++i){
		c[i-1][0]=1;
		for(int j=1;j<=i;++j){
			c[i][j]=c[i-1][j-1]+c[i-1][j];
		}
	}
	return;
}
```

# 计算

前面提到了，**在每个函数表示的区间中，每一个整数的二进制表示位数相同，且最高几位相同。**

假设在相同的最高几位中，$1$ 的个数比 $0$ 多 $k$。若一个数在这个区间中，且它是一个“圆数”，那么在其余下的几位中，$0$ 的个数应该比 $1$ **至少**多 $k$。

**我们用一个函数 $sum(l,k)$ 表示长度为 $l$ 的，$0$ 的个数比 $1$ 至少多 $k$ 的 $01$ 串的数目。**

$sum$ 的定义与 $c$ 相似，用已经预处理好的 $c$ 来求是理所当然的。参考代码：

```
int sum(int l,int k){
	int ans=0;
	for(int i=l;(i<<1)>=l+k;--i){
		ans+=c[l][i];
	}
	return ans;
}
```

回到之前由 $f(1,(1110)_2)$ 拆分出的两部分函数。

## 第一部分

$$f((1)_2,(1)_2)+f((10)_2,(11)_2)+f((100)_2,(111)_2)$$

这一部分的函数都是 $f(2^i,2^{i+1}-1)$ 形式的。第 $i$ 个函数的值即 $sum(i-1,1)$。

怎么理解？若一个数为“圆数”，则其二进制表示去掉最高位的 $1$ 后，剩下的部分应为**长度为 $i-1$ 的，$0$ 的个数比 $1$ 至少多 $1$ 的 $01$ 串**。

## 第二部分

$$f((1000)_2,(1011)_2)+f((1100)_2,(1101)_2)+f((1110)_2,(1110)_2)$$

我们发现，区间 $[(1000)_2,(1001)_2]$ 内的所有整数，二进制表示的**最高三位**都相同。且这三位中，$1$ 的个数比 $0$ 少 $1$。

类似的，$f((1000)_2,(1001)_2)=sum(1,-1)$。**$sum$ 的两个参数即为余下的位数，和相同部分中 $1$ 的个数与 $0$ 的个数之差。**

**枚举一个数二进制表示的次高位到末位，记当前位数之前 $1$ 的个数与 $0$ 的个数之差为 $k$。若第 $i$ 位为 $1$，$ans$ 加上 $sum(i-1,k-1)$。**

等等，为什么 $sum$ 的第二个参数是 $k-1$？

举个例子。$(1110)_2$ 的次高位为 $1$，我们需要计算 $f((1000)_2,(1011)_2)$。这一区间内整数的二进制表示的次高位应该是 $0$。可以类比 $21$ 世纪实际是指 $2000$ 年到 $2099$ 年。因此，第二个参数应为 $k-1$。

不过，这样是不会计算 $f((1110)_2,(1110)_2)$ 的。我们需要对这个数自身特判。可以直接利用枚举完毕后的 $k$。

这一部分应该是这道题最难理解的地方了。大家可以自己“拆”几个数字试试。

------------

参考代码：

```
int solve(int x){	//即 f(1,x)。
	int ans=0,t=0;
	bool p[32];
	while(x!=0){
		p[++t]=((x&1)==1);
		x>>=1;
	}
	//先将 x 转为二进制。
	for(int i=1;i<t;++i){
		ans+=sum(i-1,1);
	}
	//计算第一部分。
	int tot=1;
	//tot 即文中的 k。由于最高位一定是 1，因此 k 的初值为 1。
	for(int i=t-1;i>=1;--i){
		if(p[i]){
			ans+=sum(i-1,tot-1);
			++tot;
		}
		else{
			--tot;
		}
	}
	//计算第二部分。
	if(tot<=0){
		++ans;
	}
	//特判 x 是否为“圆数”。
	return ans;
}
```