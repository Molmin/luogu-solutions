看见离线先上个扫描线，考虑怎么维护答案。

记 $a_i$ 上一次出现的位置为 $pre_i$，下一次出现的位置为 $nxt_i$。设 $c_i$ 为最小的位置满足 $[i,c_i]$ 包括了 $[i,r]$ 间出现的数。考虑新加入一个 $a_r$ 对 $c$ 数组的影响。对于 $(pre_r,r]$ 中的数来说，如果要涵盖 $[i,r]$ 的所有数他们不得不将区间扩展到 $r$，而加入 $a_r$ 对 $pre_r$ 及以前无影响。所以我们只需要执行一次区间推平。

考虑如何回答询问。我们设 $pos$ 为一个最靠后的位置满足 $[pos,r]$ 包括了 $[l,r]$ 的所有数。如果我们求得了 $pos$，那么我们只需要查询 $[l,pos]$ 间的 $c_i-i$ 的最小值即可。现在考虑如何求出 $pos$。显然对于这个 $pos$ 一定要满足 $i\in [l,pos-1],nxt_i\le r$。我们可以二分这个位置，只需要 $O(n\log n)$ 次求一个区间中 $nxt$ 的最大值。这个我们用 st 表即可。总复杂度 $O((n+q)\log n)$。

交了发 T 掉了，死活卡不进去，嘿嘿嘿哈。

看了眼题解区发现有很高妙的并查集做法，大概就是说定义并查集中 $x$ 的根 $y$ 为最靠后的位置，且满足 $[y,r]$ 包含了 $[x,r]$ 出现的数。考虑新加入一个 $r$，那么对于根为 $pre_r$ 的位置来说，$pre_r$ 已不再是瓶颈，我们可以继续往后推这个位置。那我们直接将 $pre_r$ 并到 $pre_r+1$ 即可。解释下这么做为什么正确：设 $pre_r+1$ 在并查集中的根为 $x$，那么 $[x,r-1]$ 一定包含了 $[pre_r+1,r-1]$ 中出现的数。而 $pre_r$ 已经被 $r$ 补了，所以加入 $r$ 后  $[x,r]$ 必然包含了 $[pre_r,r]$ 中出现的数，那么 $pre_r$ 的区间就可以推到 $x$。所以直接合并是正确的。你发现好实现常数还小，于是你就过了，复杂度不变，还是 $O((n+q)\log n)$。

代码不给，需要私信。