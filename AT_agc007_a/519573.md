## 题目大意
有一个纵 $H$ 行，横 $W$ 列的格子状棋盘。开始时，棋盘左上角的格子有一个马（不是象棋意义的马）。Shik 将会操纵它上下左右移动，从而到达右下角的格子。此时，马能够经过同一个格子多次（含左上角和右下角的格子）。

给出 $H$ 行字符串，如果第 $i$ 行第 $j$ 列的字符为 ' # ' ，则表示马在移动过程中至少通过了此格一次（左上角和右下角的格子一定会通过至少一次）。当 $a_{i,j}$
  为 ' . ' 时，表示马在移动过程中并没有经过此格。

请判断：马是否可能每次移动都向下或向右。

### 解题思路
 通过推样例，不难发现，‘ # ’的个数为 $H + W - 1$ 。意思就是说，矩阵合法移动顺序为：右，下，右，下，右，下，右. . . 依次往下推。最后就会发现，矩阵非无终点和起点。一定是 **严格** 从左上角移动到右下角。
 
### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int H, W, num;
string s;
int main(){
	cin >> H >> W;
	int cnt = H + W - 1;
	int num = H * W;
	for(int i = 1;i <= H;i++){	
		cin >> s;
		for(int j = 0;j <= s.size();j++){
			if(s[j] == '.'){
				num--;
			}
		}
	}
	if(num == cnt){
		cout << "Possible"; 
	}
	else{
		cout << "Impossible";
	}
	while(1);//杜绝抄袭 
	return 0;
}
```
注：部分思路可能与大佬 Yu_343 的思路有些相似，但大部分还是我自己想出来的。这里，先给大家声明一下，有任何疑问，可以来私信我哟！！