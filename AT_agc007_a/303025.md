### AT2168 [AGC007A] Shik and Stone题解
pascal。


------------
#### 解题思路
第一眼：这不就爆搜？

突然发现，一个点可以走无数遍，我谔谔，爆搜的想法顿时消失。

根据数学思路推断，路径长度为 $H+W-1$ 。证明：

|# | # | . |
| :----------: | :----------: | :----------: |
| . |#  |  .|
| . |#  | # |
这是一个随便举的例子。很显然，他可以到达。

现在，我们把他变一下：

| #| . | . |
| :----------: | :----------: | :----------: |
| #| . | . |
| #|# |# |

井号个数不变，但是我们可以算一下，表中有一整列是满的，有一整行是满的，但是有一个井号重复了。所以路径长度为 $H+W-1$ 。

但是，我们马上可以举出一个反例：

| .|  #| . |
| :----------: | :----------: | :----------: |
| # |#  |#  |
|  .|  #| . |

通过整理，我们也可以得出结果：


| #| . | . |
| :----------: | :----------: | :----------: |
| #| . | . |
| #|# |# |

但是，这个表显然不能到达。

这种情况，又让我想起了爆搜……

可是爆搜做不了……

~~这什么毒瘤题我不做了！！！~~

我只好打开了题解。发现大佬 @Yu_343 的题解：

说输入数据保证合法，即一定是从左上角移动到右下角。

这就可以求出井号的数量，如果不等于 $H+W-1$ ，则输出 $Impossible$ ,否则输出 $Possible$ 。


------------
#### 代码
```pascal
var
n,m,i,j,s:longint;
x:char;//定义
 begin
  readln(n,m);//输入
  for i:=1 to n do
   begin
    for j:=1 to m do
     begin
      read(x);
      if x='#'then inc(s);//累加#号的数量
     end;
    readln;//注意！！！输入要换行
   end;
  if s=n+m-1 then writeln('Possible')
  else writeln('Impossible');//输出
 end.
```