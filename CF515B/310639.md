## 前言

这题本身也不是很难，但本蒟蒻用的是并查集的做法，个人认为比较简便，可以供大家理解。

## 题目大意

Drazil 有许多朋友，有一些人是乐观的，而其他人则不然（未必就是悲观的），她决定帮助她的朋友们。她的朋友，有 $n$ 个男生和 $m$ 个女生，编号分别是 $0$ ~ $n-1$ 和 $0$ ~ $m-1$。Drazil 决定第 $i$ 天邀请第 （$i \bmod n$） 号男生和第 $j$（$=i \mod m$） 号女生共进晚餐，（$i=0,1,……$）。

Drazil 觉得，乐观是可以传染的，即她认为如果有人是乐观的，那么与他（她）共进晚餐的另一个人也会变得乐观（当然，如果两个人都是乐观的或者都不是乐观的，则保持原样），而且这种状态也会保持下去。现在的问题是，Drazil 想知道，这种办法能否在若干天后使得她的所有朋友都会变得乐观。

## 分析

首先，看到“乐观是可以传染的”以及后面的话时，应该就很容易想到将可以相互“传染”的人放在同一连通块里。而再仔细一想，这不就是并查集吗？

那么，怎么样的男女生之间可以相互“传染”呢？显然，题目中已经告诉我们了，当他们的编号 $x$，$y$ 间存在一个  $i$（即文中的 $i$）使得  $x=i \bmod n$，$y=j\bmod m$。

可以很容易发现，$i$ 存在周期，这个周期就是 $\text{lcm}(n,m)$， 那我们不妨把它看作 $n\times m$。

于是，寻找这一对可以相互“传染”的男女生就很简单了。我们只要枚举 $i\in(1,n\times m)$，从而寻找合适的 $x$，$y$ 进行并查集的合并操作即可。

不过，题目问我们的是，能否通过几个乐观的人将乐观传染给所有人，那我们也很简单，只要将记录每个连通块是否有乐观的人即可，可以用一个数组 ```hap``` 记录。

当然，这时还有最后一个问题要解决，那就是男女生的编号，我们知道并查集的 ```father``` 数组只能开一维，所以我们不妨把男生就设为 $0$ ~ $n-1$，将女生往后放，即设为 $n$ ~ $n+m-1$。

最后并查集不要忘记将 ```father``` 初始化为自己哦，祝你AC愉快~

## Code

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=12900001;
int n,m,p,fa[maxn];//变量名与题中类似，fa即并查集父亲数组
bool hap[maxn];//记录是否乐观
int find(int x){//并查集
	return fa[x]==x?x:fa[x]=find(fa[x]);
}
signed main(){
	scanf("%d%d%d",&n,&m,&p);
	while(p--){//p为男生乐观人数
		int x;
		scanf("%d",&x);
		hap[x]=1;//将他标记为乐观的
	}
	scanf("%d",&p);
	while(p--){//此时的p为女生乐观人数
		int x;
		scanf("%d",&x);
		hap[n+x]=1;//注意女生要+n，下同
	}
	for(int i=0;i<n+m;i++) fa[i]=i;//初始化，注意要枚举n+m，下同
	for(int i=0;i<n*m;i++)
	 fa[find(i%n)]=find(n+i%m);//题目精髓，合并对应男女生
	for(int i=0;i<n+m;i++)
	 if(hap[find(i)]) continue;
	 else if(hap[i]) hap[find(i)]=1;//如果他自己是乐观的，那么将祖先标记为乐观，相当于以他所在的连通块全部可以变为乐观
	for(int i=0;i<n+m;i++)
	 if(!hap[find(i)]){//只要有一个连通块不成立，就永远无法使乐观传染至所有人
	 	printf("No");
	 	return 0;
	 }
	printf("Yes\n");//注意还要输出Yes
	return 0;
}
```

### 后记

据说乐观是可以传染的捏，你们的点赞就是把你们的乐观传染到我身上最好的方式呀！