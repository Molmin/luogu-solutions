### 题意
现有一个长度为 $n$ 的 $a$ 数组，按照如下顺序进行操作后，得到一个 $b$ 数组，给定 $t$ 个 $b$ 数组，请输出其对应的 $a$ 数组的一个情况，若没有，输出 $-1$。

- $a_{n+1} = \sum\limits_{i=1}^{n} a_i$;
- $a_{n+2}$ 为一个随机整数 $x$;
- 打乱 $a$ 数组。

### 思路

仔细分析这道题，不难想到，如果合法，**排序后的数组**只有两种情况：
  
- $b_{n+1}$ 是和，$b_{n+2}$ 是随机数;
- $b_{n+2}$ 是和，$b_1\sim b_{n+1}$ 中的某一个是随机数。

当然，在答案存在时，有可能会有和与答案相等但在 $b_{n+1}$ 之前。

因此，我们换一种更加严谨的说法，两种情况分别是：
- 等于 $b_{n+1}$ 的是和，$b_{n+2}$ 是随机数；
- 等于 $b_{n+2}$ 的是和，$b_1 \sim b_{n+1}$ 中的某一个是随机数。

在其他情况下，**一定**会出现**有值大于和**的情况，因此不用考虑。  

接下来的实现比较轻松。

定义 $s1$ 表示 $\sum\limits_{i=1}^{n} b_i$；
$s2$ 表示 $\sum\limits_{i=1}^{n+1} b_i$，即 $s1+b_{n+1}$。  
先考虑第一种情况：  
$s1 = b_{n+1}$ 直接输出 $b_1,b_2,\cdots,b_n$。  

否则考虑第二种情况：  

定义函数 $f(k)$，将返回 $b_1\sim b_{n+1}$ 中 $k$ 的下标，若不存在，返回 $-1$。  

由于 $b_{n+2}$ 为和，因此 $s2 - b_{n+2}$ 的值即为随机数的值。  

如果这个值存在，则输出 $b_1\sim b_{n+1}$ 中，除了随机数以外的数。即使这个差值是负数，**因为它不存在**于数组中，因此同样会返回 $-1$ 而不输出。  

如果返回了 $-1$，则输出 $-1$。  

注意几个要开 $\texttt{long long}$ 的地方：  
$s1$， $s2$，$k$。
这个 $k$ 是指前面传入函数的值。  
~~为什么要开也很好算吧。~~

[AC code记录](https://www.luogu.com.cn/record/50588440)

解释一下，代码里面的 $a$ 数组 $\Leftrightarrow$ 上述中的 $b$ 数组。

```cpp
#include <bits/stdc++.h>
#define ll long long // 偷懒行为
using namespace std;
int t, n, a[200010];
int f(ll aim) // 返回 aim 的下标，不存在则返回 -1
{
	for (int i = 1; i <= n+1; ++i)
		if (a[i] == aim) return i;
	return -1;
}

int main()
{
	scanf("%d", &t);
	while (t--)
	{
		scanf("%d", &n);
		for (int i = 1; i <= n+2; ++i) scanf("%d", a+i);
		sort(a+1, a+3+n); // 一定要排序
		ll s1 = 0, s2 = 0;
		for (int i = 1; i <= n; ++i) s1 += a[i];
		if (s1 == a[n+1])
		{
			for (int i = 1; i <= n; ++i) printf("%d ", a[i]);
			puts(""); continue; 
		}
		s2 = s1 + a[n+1];
		int x = f(s2 - a[n+2]);
		if (!~x) // 等价于 x == -1
		{
			puts("-1"); continue;
		}
		for (int i = 1; i <= n+1; ++i)
			if (x^i) printf("%d ", a[i]); //等价于 x ！= i
		puts("");
	}
	return 0;
}
```

写代码的时候一定要养成该开 $\texttt{long long}$ 的一定算好，不用开的就不开的习惯。


给一个**高级**的 hack 数据：  
```
1
55
70000000 80000000 80000000 80000000 80000000 80000000 80000000 80000000 80000000 80000000 80000000 80000000 80000000 80000000 80000000 80000000 80000000 80000000 80000000 80000000 80000000 80000000 80000000 80000000 80000000 80000000 80000000 80000000 80000000 80000000 80000000 80000000 80000000 80000000 80000000 80000000 80000000 80000000 80000000 80000000 80000000 80000000 80000000 80000000 80000000 80000000 80000000 80000000 80000000 80000000 80000000 80000000 80000000 80000000 80000000 95032704 95032704   
这是CF的第14个测试数据。
```

这个数据的 95032704 看起来很~~没用~~奇怪，其实是运用了计算机存储的知识，如果我的 $f$ 函数中的 $k$ 不开 $\texttt{long long}$，会被卡掉，卡掉的原因是 $s2 - b_{n+2}$ 会被函数找到。实际上是没有的，大家可以算算。

这个样例是怎么得到的嘛。。。 

![](https://cdn.luogu.com.cn/upload/image_hosting/wygxpf53.png)  

大家都知道，CF 里面虽然会给数据，然而省略号很烦。当时对于这个样例，我是这样处理的：

观察发现，每个数后面的 $0$ 很多，那我就判断一下，当输入为 $t$ 为 $1$，$n$ 为 $55$ 时，输出数组内数的值除以 $100000$。

然后有一点推理：得到了两个 $950$，但是能找到省略号之前的 $95032704$，因此把这两个 $950$ 改成 $95032704$，其它数乘 $100000$ 就得到了完整的测试数据。