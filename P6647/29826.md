先不考虑 $t$ 的限制，设 $f_i$ 表示刚看完第 $i$ 个景点的答案，记 $g(l,r)=\max\limits_{l\le i \le r}a_i$，那么 dp 方程显然为 $f_i=\max\limits_{i-m\le j<i}\{f_j+g(j+1,i)\}$。

考虑到有 $t$ 的限制，要求最小化天数，即最小化转移次数，那么把方程改写为 $f_i=\max\limits_{i-m\le j<i}\{f_j+g(j+1,i)\}-\inf$ 就可以了。

接下来处理这个麻烦的 $g(j+1,i)$。先不管 $m$ 的限制，考虑维护一个单调递减栈。

举个例子，对于某 $a$ 序列 $7,4,5,6$，当 $i=3$ 时，单调栈内**序列下标**为 $1,3$。可以注意到，单调栈内的**序列下标**恰好把序列划分成了若干个区间，对于指定区间内的 $j$，$g(j+1,i)$ 的值是相等的。具体地，设单调栈内的**序列下标**序列为 $\{s\}$，那么 $\forall j\in[s_k,s_{k+1}),g(j+1,k)=a_{s_{k+1}}$。

![](https://cdn.luogu.com.cn/upload/image_hosting/0bgtvcbu.png)

如上图，三个黑色矩形的长表示对应的下标区间，宽表示对应的 $g$ 值。那么我们可以考虑对每个 $j$ 动态维护 $f_j+g(j+1,i)$，需要维护的操作是加一个新元素。

当单调栈需要弹栈时（如红色矩形进入）时，相当于是把黑色矩形补齐成和红色矩形同宽，即增加了一个绿色矩形，对应 $f_j+g(j+1,i)$ 的区间加，用线段树维护即可。那么我们就实现了动态维护。

接下来再考虑 $m$ 的限制，那么只需要做区间求最大值就可以了。总复杂度 $O(n\log n)$。

```cpp
int main()
{
	read(n,m,a,n);l[1]=0;r[1]=n;build(1);
	for (i=1;i<=n;i++)
	{
		while (tp&&a[st[tp]]<=a[i])
		{
			if (a[st[tp]]==a[i]) {--tp;continue;}
			z=st[tp-1];y=st[tp]-1;dt=a[i]-a[st[tp]];
			mdf(1);--tp;
		}
		st[++tp]=i;
		z=y=i-1;dt=f[i-1]+a[i];mdf(1);
		dt=-9e18;z=max(i-m,0);y=i-1;ask(1);
		f[i]=dt+inf;
	}
	enter(f[n]-(ll)(n-1+m)/m*inf);
}
```