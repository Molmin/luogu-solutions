开始正题

首先，看到`杀老师解决完最后一个同学的问题最少需要花费多少精力。`很容易就能想到 dp，于是我们可以推出来这样的柿子：

$$dp_i=\min(dp_j+(i-j-1)\cdot d+k+a_i)$$

上式中 $(i-x\le j<i)$，所有变量和题目中给的都是一样的；

然后我们再来考虑一下初始的条件，

显然杀老师再辛苦第一位学员是必须辅导的

那么这里的：$dp_1=a_1$

结束条件是所有学生都辅导了，即：$dp_n$

可是交上去发现只有 20 分，因此，考虑优化。

我们先来分析这个柿子的时间复杂度，

在执行循环的时候，$i$ 从 $1$ 到 $n$ 跑了一遍，$j$ 也从 $1$ 到 $n$ 跑了一遍，那么时间复杂度应是：$O(n^2)$

时间复杂度太高了，因此考虑减掉一个**不必要的循环**，

我们来模拟一下这个式子中杀老师讲课的过程吧：

每一次杀老师辅导选择同学的时候都是选择在**一个区间里**的某一个人，然后每一次往后的更新，其实都是往后挪一个范围，

能直接想到[滑动窗口](https://www.luogu.com.cn/problem/P1886)，于是即可想到单调队列优化

那么，如何确定那些数要被排除掉呢，我们需要一个较为明确的条件。

但是和普通的数不同的是，这是一个 dp 式

所以我们只能考虑提取一下这个柿子里面的常数：

下式中，均满足 $(i-x\le j<i)$，

$$dp_i=\min{dp_j+(i-j-1)\cdot d+k+a_i}$$

$$dp_i=(i-1)\cdot da_i+k+\min dp_j-j\cdot d$$

我们知道，决定每一个 $dp_i$ 的大小的只和 $\min$ 里面的函数有关，那么这个呢，只和 $j$ 有关系。

所以简化后我们只需要处理的就是 $j$ 的大小

因此，选用单调队列来维护 $dp_j-j\cdot d$ 的最小值，然后更新 $dp_j$ 就可以了。

核心代码：
```cpp
    deque<int> Q;
    for (int i = 2; i <= n; ++i)
    {
        while (!Q.empty() && i - Q.front() > x) 
        {
            Q.pop_front();
        }
        dp[i] = dp[Q.front()] + a[i] + k + d * (i - Q.front() - 1);
        while (!Q.empty() && dp[i] - i * d <= dp[Q.front()] - Q.back() * d)//单调队列中的退役 
        {
            Q.pop_back();
        }
        Q.push_back(i); // 新生入队
    }
```

这个里面所有的变量名都不改变，

然后呢，其实就是在单调队列的模板上套了转移方程，

淘汰“毕业”的，就是`for`里第一个`while`是不变的；

第二个是被“单调队列”的。

这就是核心代码解读+我所选用的思路

希望对您有帮助。