这题是不是有点熟悉？在洛谷上搜一下[“砍树”](https://www.luogu.com.cn/problem/solution/P1873)，你会发现连样例都一样……

言归正传，开始今天的讲解！

------------
# 思路：
首先，我们要发现：这道题存在**潜在的单调性**和**最大值最小**这两个关键信息。
1. 单调性：
答案每次增加，砍掉的数量会相应减少。反之亦然。
2. 最大值最小：
>请你帮 Mirko 找到 $H$ 的**最大值**，使 Mirko **至少**能砍掉 $M$ 米的木材。

有了这两个信息，就可以轻松看出本题的思路：**_二分_**！

至于二分的具体内容，大家可以阅读双倍经验[“砍树”](https://www.luogu.com.cn/problem/solution/P1873)的题解。

不过既然来了，还是讲一下吧！

>对于区间 $[a,b]$ 上连续不断且 $f(a) \times f(b)<0$ 的函数 $y=f(x)$ ，通过不断地把函数 $f(x)$ 的零点所在的区间一分为二，使区间的两个端点逐步逼近零点，进而得到零点近似值的方法叫二分法。

这是[百度](https://baike.baidu.com/item/%E4%BA%8C%E5%88%86%E6%B3%95/1364267?fr=aladdin)上的定义，有点难懂。那就让我给大家分析一下吧！

二分，顾名思义，就是将一段内容分成两份来分别处理或使左右区间逐渐逼近。

比如按照本题要求，我们可以先找到答案的范围（ $0 - max_h$ 这一区间）。我们就可以先尝试设 $left$ 代表左边界， $right$ 代表右边界， $mid=(left+right)/2$ 代表答案进行尝试。

可以清楚的看出， $mid$ 的结果有三种可能：正确、过大和过小。

- 正确：可以直接输出。但在有些题中要求最小的正确值，所以有可能还要继续让 $r=mid-1$ 缩小二分的范围。
- 过大：让 $r=mid-1$ 缩小二分的范围。
- 过小：让 $l=mid+1$ 缩小二分的范围。
- 若 $l=r$ ：结束。

可以看出，重复执行上述算法，时间复杂度为 $O(\log n)$ ，比暴力的 $O(n)$ 快了许多。

如果这样，是不是所有的暴力都可以用二分替代呢？当然不是。二分需要满足**单调性**。

- 注：二分分为二分过程和二分答案，比如本题就是二分答案。至于二分过程，有机会再给给大家讲吧！


# 代码：
```#include<bits/stdc++.h>
using namespace std;
long long l,r,mid,ans,n,m,dat[1000009];
long long read(){
   long long s=0,f=1;
   char ch=getchar();
   while(ch<'0'||ch>'9'){if(ch=='-')f=-f;ch=getchar();}
   while(ch>='0'&&ch<='9') s=s*10+ch-'0',ch=getchar();
   return s*f;
}//快读，和cin/scanf作用相同，但速度更快
int main(){
	n=read();
	m=read();
	for(int i=0;i<n;i++)dat[i]=read(),r=max(r,dat[i]);
	sort(dat,dat+n);//加速，可以让下方第二层循化变快一点点。但可以忽略，改法见砍树题解
	for(l=0,mid=(l+r)>>1;l<=r;mid=(l+r)>>1){//二分
		ans=0;//记得清零
		for(int i=n-1;i>=0&&dat[i]>mid;i--)//因为sort默认升序，所以要倒着搜索。也可以重新编写比较函数
			ans+=dat[i]-mid;
		if(ans<m)r=mid-1;
		else l=mid+1;
	}
	cout<<mid;//输出答案
}
```


------------
感谢大家阅读。这篇题解比较基础，着重讲了二分的判断及实现。适合零基础的同学。

这篇题解的内容可能过于具体，大家可以借助介绍中插入的具体代码来思考。