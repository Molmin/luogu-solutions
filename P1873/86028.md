~~（我们考试时就用了这题）~~
##### 开始拿到这题很蒙，所以决定豁出去写一个枚举，但在写的过程中，发现虽然m很大，但n很小，所以模拟+优化应该能过（当然，luogu的评测机强大无比，luogu的1s程序，我们那的计算机要跑8s，所以luogu不优化也可以过~~？~~）。

>1. 将树的高度读入后，我们将树排序，因为树的位置的变化是无所谓的。

>2. 然后从最高点往下搜,直到木材总量大于m即可

>3. 第二步可以进一步优化：

>    将第二步拆开：因为每一个树距离上一棵树的距离已知，我们可以直接用枚举刚好不砍某棵树时得到的木材

>    然后在砍树超过m时跳出。

>    再不断抬高锯子，直到看不到长m的木材，此时再将锯子降低一个单位就是答案。

```cpp
#include <bits/stdc++.h>
using namespace std;
int n,m,high,Now,o,Nowm=0;
int h[1000005],high_for[1000005];
int main(){
    cin>>n>>m;
    for(register int i=1;i<=n;++i) cin>>h[i];
    sort(h+1,h+n+1);                 //Step.1
    for(register int i=2;i<=n;++i) high_for[i]=h[i]-h[i-1];                              //距离上一棵树高度的差，此步可直接在下一步中实现
    for(o=n;o>=1;--o){
        Now=h[o];
        Nowm+=high_for[o+1]*(n-o);
        if(Nowm>=m) break;
    }
    while(Nowm>=m) Nowm-=(n-o),Now++;   //缺点所在处
    cout<<Now-1<<endl;
    return 0;
}
```
## 此算法的缺点
#### 虽然说貌似是优化了，但是此算法仍存在一个缺点。
当答案H距离它下面的树的h很远时（也就是专坑此算法的毒瘤数据），所谓的优化反而会耗去跟多时间，如果能对距离进行一次判断，从下端处理或从上端处理，会更好。

例如：
![](https://cdn.luogu.com.cn/upload/pic/49074.png)
这种情况时，h距下端远，距上端近，从上端处理会大大缩短时间（虽说理论上时间复杂度没变）

### 当然，可能还会有一些其他的方法？