这道题的标准解法应该是 **最大流**，即将人与衣服均视为节点，然后人与自己能穿的衣服之间有流量为 $1$ 的边，最后建立超源和超汇，如果超汇的最大流等于 $M$ 则具有可行解，反之则没有。当然，**二分图匹配** 也可以，只需求出最大匹配数是否等于 $M$ 即可。

然而这道题还可以用 **状压动规** 乱搞出来，而且个人认为状压动规的思路更加直观，更加好想。那我就来一篇状压动规的题解吧。

### 1. 状态与状态转移

考虑第 $i$ 个人是否能找到合适的衣服穿。显然，这取决于前 $i-1$ 个人剩下了多少件衣服。所以自然而然想到用 **当前剩余衣服的情况** 作为状态。

设 $f[i][j]$ 为前 $i$ 个人，剩余衣服情况为 $j$ 的时候，每个人是否都能有合适的衣服穿，则 $f[i][j]=1$ 当且仅当在 $f[i-1][j]=1$的情况下， $f[i-1][j$ 减去一件 $i$ 能穿的第一种尺寸的衣服$]=1$ 或 $f[i-1][j$ 减去一件 $i$ 能穿的第二种尺寸的衣服$]=1$。初始条件即为：对于所有合法情况 $j$，$f[0][j]=1$。

问题的答案即为 $f[M][$ 每种尺寸的衣服都有 $N/6$ 件的情况 $]$ 。这实际上等价于求解是否存在合法情况 $j$，使得 $f[M][j]=1$。

### 2. 状态表示

由于最多有 $6$ 种衣服，每种衣服都有 $6$ 种尺寸，考虑用 $3$ 位二进制位来表示某一种尺寸剩余衣服的件数。

比如二进制数 $100\ 001\ 110\ 011\ 000\ 010$ 可以用来表示：

- 尺寸为 $XXL$ 的衣服还有 $100=4$ 件；
- 尺寸为 $XL$ 的衣服还有 $001=1$ 件；
- 尺寸为 $L$ 的衣服还有 $110=6$ 件；
- 尺寸为 $M$ 的衣服还有 $011=3$ 件；
- 尺寸为 $S$ 的衣服还有 $000=0$ 件；
- 尺寸为 $XS$ 的衣服还有 $010=2$ 件；

这种情况。

### 3. 时间复杂度

对于一个样例，本做法状态总数为 $M \times 2^{3 \times 6}$，状态转移为 $O(1)$ ，故总体时间复杂度为 $O(M \times 2^{18})$。很丑陋，但是对于这道题目而言够用了。

### 4. 代码实现

```c++
#include <iostream>
#include <cstdio>
#include <cstring>
using namespace std;
#define MAXN (1<<18)
#define MAXM 32
const char TSHIRT[MAXM][10] = {
    "XS",
    "S",
    "M",
    "L",
    "XL",
    "XXL"
};
int T;
int N, M;
char buf[10];
// 每个人能穿的尺寸
int tshirt[MAXM][2];
// 状态
bool f[MAXM][MAXN];
bool ans;
int main()
{
    int T;
    cin >> T;
    while (T--)
    {
        ans = false;
        cin >> N >> M;
        N /= 6;
        // 输入每个人能够穿的衣服尺寸
        for (int i = 1; i <= M; i++)
        {
            for (int j = 0; j < 2; j++)
            {
                cin >> buf;
                // 将尺寸转化为编号存储，XS=0，XXL=5
                for (int k = 0; k < 6; k++)
                    if (!strcmp(buf, TSHIRT[k]))
                        tshirt[i][j] = k;
            }
        }
        memset(f, 0, sizeof(f));
        // 设置初始状态
        for (int i = 0; i < MAXN; i++)
        {
            f[0][i] = true;
            for (int j = 0; f[0][i] && j < 6; j++)
                if (((i >> j * 3) & 7) > N)
                    f[0][i] = false;
        }
        // 求解所有f[i][j]
        for (int i = 1; i <= M; i++)
        {
            for (int j = 0; j < MAXN; j++)
            {
                // f[i][j]=1的前提是f[i-1][j]=1
                if (!f[i - 1][j])
                    continue;
                for (int k = 0; k < 2; k++)
                {
                    // 状态转移
                    // (j >> tshirt[i][k] * 3) & 7 即i能穿的第k种尺寸的衣服剩余的件数
                    // 这里需要充分利用位运算的技巧
                    // (j & ~(7 << tshirt[i][k] * 3)) | ((((j >> tshirt[i][k] * 3) & 7) - 1) << tshirt[i][k] * 3)
                    // 的含义即为：令i能穿的第k种尺寸的衣服件数-1
                    if (((j >> tshirt[i][k] * 3) & 7) && f[i - 1][(j & ~(7 << tshirt[i][k] * 3)) | ((((j >> tshirt[i][k] * 3) & 7) - 1) << tshirt[i][k] * 3)])
                    {
                        f[i][j] = true;
                        break;
                    }
                }
                // 如果i=M，可以顺便求解答案
                if (i == M && f[i][j])
                {
                    ans = true;
                    break;
                }
            }
        }
        cout << (ans ? "YES" : "NO") << endl;
    }
	return 0;
}
```