#### 题意

给到一个序列$A$，求一个序列$B$，满足对于任意一个下标$i$， 将所有是$i$的倍数的下标中储存的值相加，其和$mod2$的结果为$ai$，输出$B$序列中所有值为$1$的下标。

#### 思路

因为后面的数会将前面求得的答案影响，所以我们从后往前遍历。

对于$B[i]$的值，首先我们把除了$i$本身之外，所有下标是$i$的倍数储存的值相加并$mod2$。如果和$a[i]$相等，$B[i]$则等于$0$，否则等于$1$。

接下来我们证明这个算法。

当相等时，因为已经满足了这个题目要求，那么为了不影响，我们就将$B[i]$变成$0$。

即$B[i]=0$。

当不相等时，因为$A[i]$和我们的结果只有$0$和$1$两种情况，相当于，对于$mod$后的结果，我们要把$0$变成$1$，把$1$变成$0$。

那么，我们只要多加一个$1$，就能把$0$变成$1$；而$1$加$1$后等于$2$，由于我们的答案是$mod2$的。所以就会变成$0$。

即$B[i]=1$。

上代码：
```
#include<bits/stdc++.h>
using namespace std;
int a[200001],b[200001],flag[200001],num,n,sum; 
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
		scanf("%d",&a[i]);
	for(int i=n;i>=1;i--)
	{
		sum=0;
		for(int j=i*2;j<=n;j+=i)
			sum+=b[j];
		sum%=2;
		if(sum!=a[i])
		{
			num++;
			b[i]=1;
			flag[num]=i;
		}
	}
	printf("%d\n",num);
	for(int i=1;i<=num;i++)
		printf("%d ",flag[i]);
	printf("\n");
	return 0;
}
```

完结撒花~