# P7076 题解
~~考场上居然没有看出来可以优化？！？！~~

## 题意
对于每一个动物 $i$ ，如果它的二进制第 $p_j$ 位为 $1$ ，则必须买第 $q_j$ 种饲料，否则不必。

问在不改变饲料购买的情况下，还能够饲养多少种其他的动物。

## 解题
首先，饲养一个动物需要购买更多饲料，一定是这个动物的编号 $a$ 二进制满足某一个 $p_j$ 位为 $1$ 且其他的动物编号的二进制的 $p_j$ 位不为 $1$ 。

所以我们发现：
- 如果所给出的动物已经必须要购买所有的饲料，那么无论哪一个动物都可以被饲养。

- 如果有任意一个 $p_j$ 位没有被用到，则这个 $p_j$ 不能再被用。

根据第一点，我们可以写出骗很多分的一行代码：
```cpp
if (set_cq.size() == m)
    return cout << ((1 << k) - n) << endl, 0;
```

然后根据第二点，我们可以基本打出一个暴力：
```cpp
void solve1(){
	for(ll i=0;i<(1<<k);i++){
		if(hv[i])continue;
		bool canhave=1;
		for(ll j=1;j<=m;j++)
			if(can[q[j]]==0&&gbit(i,p[j])==1)canhave=0;
		ans+=canhave;
//		if(canhave)cout<<i<<endl;
	}
	cout<<ans<<endl;
}
```

当然，对于 $k=64$ 的数据范围，这显然不行。

## 优化
暴力的方法，有很多复杂度都用在判断这个数可不可以，于是我们考虑到一开始就把用到的二进制位统计出来。

```cpp
for(ll i=1;i<=n;i++){
	readll(a[i]);
	for(ll j=0;j<k;j++)
		if(gbit(a[i],j))use[j]=1;
}
```

接下来，我们对于每一位都看它是不是已经被用过了，或者在之前统计的时候是不是就已经被用到了，这些都是符合标准的动物编号，我们把这些位数存下来，记作 $t$ 。

考虑到因为这些位都是没有限制的，所以 $1$ 和 $0$ 都是可以的，于是这些满足要求的数一共有 $2^t$ 个。

最后，之前还有 $n$ 个已经要了的动物，我们拿 $2^t-n$ 就是最终的答案了。

因为是按位考虑的，所以复杂度是 $\Theta(64)$ 。

最后注意的是 $k=64$ 的情况，因为 unsigned long long 类型是到 $2^{64}-1$ 的，要打一小部分的表，其实你会发现打 $k=64,n=0,m=0$ 的就够了，其他的都存的下。当然你偏要用高精度也没问题。

## Code
给一部分代码吧，理解了都挺好写的。
```cpp
for(ll i=1;i<=m;i++){
x=read(),y=read();
t[x]=1;
}
for(ll i=0;i<k;i++)
if(!t[i]||use[i])cnt_ok++;
ull ans=(1ll<<cnt_ok)-n;
cout<<ans;
```

## 后记
AFO 预定。