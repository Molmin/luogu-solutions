------------
- ### 题解By——攻略组Setsugesuka

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;水题没人写题解？那我就厚脸皮的水下咕值了。

ps:本题解大量图片来自[插头DP入门选讲](http://www.cnblogs.com/LadyLex/p/7326874.html)等各大神仙的博客（流下了不会画图的泪水）

------------
- ### 题目大意

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;阅读题面，发现题面全部都是废话，我们提取有关信息，得到以下内容。

>给定一张$n$ $×$ $m$的网格图，求经过所有点的曼哈顿回路个数。

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;插头$DP$裸题？难道省选会这么简单吗？仔细看题，发现题面缺少了一样现在$OI$题都会有的内容，“答案对$xxx$取模”，没错，这道题为了恶心人，需要我们手写高精。

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;于是，我们只需要用高精度记录答案，做一遍插头$DP$即可。为了帮助萌新们快速地学会解决这类入门难度题，我们从插头$DP$开始讲起。

------------
- ### 什么是插头

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;什么是插头$DP$，是在插头上做$DP$嘛？然而并不是，插头$DP$只是一种用于解决基于联通性的状态压缩动态规划问题的方法而已。（∵插头$DP$ $∈$ $DP$，又∵$DP$ $∈$ $NOIP$考纲，∴插头$DP$ $∈$ $NOIP$考纲）

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;我们首先来了解一下什么是插头。

>在插头DP中，插头表示一种联通的状态。

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;？？？联通的状态又是什么，我怎么什么都听不懂？？？

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;别急，我们先来看这样一道例题。

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;给出一张$n×m$有障碍的棋盘，要求用任意条回路遍历整个棋盘，不能经过障碍格子，要求统计不同的行走方案数。
![题目图片](https://cdn.luogu.com.cn/upload/pic/46771.png)

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;假设我们当前已经推到了第三行，障碍在$(1,1)$与$(1,2)$。
![当前推到了哪里](https://cdn.luogu.com.cn/upload/pic/46772.png)

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;插头，就是在蓝色轮廓线上面的那些箭头，准确地来说，每个格子都有一定数量的插头，但由于我们在插头$DP$中一般采用逐格递推的方法，很多格子的插头是不会对下个状态产生贡献的，于是我们只记录轮廓线上的插头。在前面我们讲过，插头表示一种联通的状态，什么是联通的状态呢？很简单，我们看第一张图的$(2,2)$与$(2,3)$这两格。它们的都是竖直的，且没有构成回路，如果他要构成回路，只有下面的格子才能更新他的状态，因为他的上左都是已经确定了的，因此，他的插头方向向下。

>一个格子有一个向某方向的插头，就意味着这个格子在这个方向可以与外面相连（与插头那边的格子联通）。

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;值得注意的是，插头表示的是一个格子一定确定了的现实状态，而不是一个格子要怎么画线的虚拟状态。也就是说，如果有一个插头指向某个格子，那么这个格子已经和插头来源联通了，我们接下来要考虑的是从这个插头往哪里走。

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;一般来说，我们从上往下，从左往右地去递推我们的棋盘。

------------
- ### 列间转移

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;我们考虑第$i$行的某一个格子：走向它的方案，可能由上一行的下插头转移而来，也可能是本行的右插头转移而来。

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;因此我们需要记录这些地方有没有插头，也就是利用状压的思想。我们记录的这个“有没有插头”的东西，就被我们称为轮廓线。字面意思，轮廓线就是记录了棋盘这一行与上一行交界的轮廓中插头的情况。轮廓线上方是已经决策完的格子，下方是未决策的。显然，对于本题的轮廓线，与它直接相连的格子有$m$个，插头有$m+1$个，我个人的习惯是给插头编号$0$~$m$。

![某个状态](https://cdn.luogu.com.cn/upload/pic/46773.png)

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;举个栗子，对于以上状态，我们发现，对于我们要推的这一鸽，它的左边有一个右插头，它的上边有一个下插头，因此，这个格子只能变成左上插头。

------------
- ### 行间转移

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;我们先考虑两行之间的转移：显然，第$i$行的下插头决定了第$i+1$行的格子有没有上插头，因此我们应该把这个信息传递到下一行。当一行已经全部推完时，轮廓线将会是一个直线，它的第$m$位是一个空格子的左插头位置，是不需要更新的。因此，在转移的时候，只有当前行插头$0$到插头$m-1$可能会给下一行带来贡献，而第$m$个插头一定为$0$，我们只需要恰当的左移即可。

------------
- ### DP更新

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;不难发现，对于这个模板题，有以下三种情况。
![三种情况](https://cdn.luogu.com.cn/upload/pic/46777.png)

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;对于情况$1$，这个格子上方没有一个下插头，左边也没有一个右插头，因为题目要求我们要遍历整张图，而且这个格子不在任何一个边缘上，所以我们建立一个右下插头。

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;对于情况$2$，这个格子上方有一个下插头，左边也有一个右插头，因此，我们只需要建立一个左上插头即可。

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;对于情况$3$，这个格子只有上方的一个下插头，因此它既可以建立一个上下插头，也可以建立一个右上插头。

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;综上，这个板子很容易就能写出来了。

------------
- ### 考虑题目的不同

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;我们来考虑要解决的这道题，众所周知，邮递员并不会使用替身攻击，因此他无法分身去送快递，即。

![情况](https://cdn.luogu.com.cn/upload/pic/46778.png)

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;对于这种情况，在模板题中是可行的，在这道题中是不可行的，于是，我们来思考一下怎么定义我们的插头状态，首先我们有以下很显然的结论。

>因为题目要求每个格子都在回路中，那么最后全部的格子一定会通过插头形成一个联通快。

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;不难想到我们可以利用最小表示法来维护联通性，但是，我们通过模板可知，在递推过程中，很多方块是不会对得出下一个格子作出贡献的，如果直接用最小表示法，我们会浪费很多的内存。因此，我们转换优化的角度，用最小表示法来表示插头的联通性：如果这个插头存在，那么就标记这个插头对应的格子的连通标号，如果这个插头不存在，那么标记为$0$，仔细思考后，我们还可以得到以下一个结论。

>如果每个格子都在回路中的话，我们还可以得到，每个格子应该恰好有且仅有2个插头。

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;这同样也是很显然的。在得到这两个结论之后，我们来思考一下如何定义我们的插头状态。

![括号序列](https://cdn.luogu.com.cn/upload/pic/46783.png)

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;观察这张图片，我们发现，对于一条路径，它的左右端点分别对应了轮廓线上的两个插头。很容易看出，对于这类题目，一定满足任何时候轮廓线上每一个连通分量恰好有$2$个插头。

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;这说明了什么呢！我也不知道，但是有神仙提出这和括号序列很像，然后大家仔细看了一下，真的和括号序列很像，于是我们可以使用一种新的定义方式：$3$进制表示——$0$表示无插头，$1$表示左括号插头，$2$表示右括号插头,记录下所有的轮廓线信息。那么，我们来考虑一下这道题的状态转移。

------------
- ### 状态转移方法

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;我们设该格左边的插头为$p1$，右边的插头为$p2$。

1. ```cpp
(p1==0&&p2==0)
```
我们新建一个路径，下插头设为左括号插头，右插头设为右括号插头。

2. ```cpp
(p1==0&&p2!=0)
```
我们对直走和转弯进行分类讨论。

3. ```cpp
(p1!=0&&p2==0)
```
同$2$。

4. ```cpp
(p1==1&&p2==1)
```
把$2$个左括号插头相连，将右边那个左括号插头（$p2$）对应的右括号插头$q2$修改成左括号插头。
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;![情况4](https://cdn.luogu.com.cn/upload/pic/46784.png)

5.  ```cpp
(p1==1&&p2==2)
```
众所周知，因为只有一条回路，所以路径是两两不相交的，对于这种情况，显然是形成了回路。不难发现，只有在(x==n&&y==m)时，这种状态才是合法的，我们可以用它更新答案。

6.  ```cpp
(p1==2&&p2==1)
```
如图，这种情况并不会形成回路，而只需要把两个括号连起来即可。![情况5，6](https://cdn.luogu.com.cn/upload/pic/46786.png)

7.  ```cpp
(p1==2&&p2==2)
```
与情况$4$同理。&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;![情况7](https://cdn.luogu.com.cn/upload/pic/46788.png)


&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;在得出了状态转移的方法后，代码也就很容易写出来了，值得注意的是，如果你想让你的插头$DP$跑的更快，用的空间更小，请手动学习哈希表的写法。

------------
- ### 完整代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int databit=1e9;
const int MOD=2601;

int n,m;

struct data
{
	int bit[6];
	
	inline void clear()
	{
		memset(bit,0,sizeof(bit));
	}
	
	inline void set(int x)
	{
		clear();
		while(x)
		{
			bit[++bit[0]]=x%databit;
			x/=databit;
		}
	}
	
	inline int &operator [](int x)
	{
		return bit[x];
	}
	
	inline data operator +(data b)
	{
		data c;
		c.clear();
		c[0]=max(bit[0],b[0])+1;
		for(int i=1;i<=c[0];i++)
			c[i]+=bit[i]+b[i],c[i+1]+=c[i]/databit,c[i]%=databit;
		while(!c[c[0]]) c[0]--;
		return c;
	}
	
	inline void operator +=(data b)
	{
		*this=*this+b;
	}
	
	inline void operator =(int x)
	{
		set(x);
	}
	
	inline void print()
	{
		printf("%d",bit[bit[0]]);
		for(int i=bit[0]-1;i>=1;i--)
		{
			printf("%09d",bit[i]);
		}
		puts("");
	}
	
	data()
	{
		clear();
	}
};

data ans;

struct hashmp
{
	data val[MOD];	
	int key[MOD],sz,hash[MOD];
	
	inline void init()
	{
		memset(val,0,sizeof(val));
		memset(key,-1,sizeof(key));
		sz=0;
		memset(hash,0,sizeof(hash));
	}
	
	inline void newhash(int id,int v)
	{
		hash[id]=++sz;
		key[sz]=v;
	}
	
	inline data &operator[](int state)
	{
		for(int i=state%MOD;;i=(i+1==MOD)?0:i+1)
		{
			if(!hash[i])
				newhash(i,state);
			if(key[hash[i]]==state)
				return val[hash[i]];
		}
	}
};

hashmp dp[2];

inline int find(int state,int id)
{
	return (state>>((id-1)<<1))&3;
} 

inline void dpset(int &state,int bit,int val)
{
	bit=(bit-1)<<1;
	state|=3<<bit;
	state^=3<<bit;
	state|=val<<bit;
}

inline int link(int state,int pos)
{
	int cnt=0,delta=(find(state,pos)==1)?1:-1;
	for(int i=pos;i&&i<=m+1;i+=delta)
	{
		int p=find(state,i);
		if(p==1)
			cnt++;
		else if(p==2)
			cnt--;
		if(cnt==0)
			return i;
	}
	return -1;
} 

inline void run(int x,int y)
{
	int now=((x-1)*m+y)&1,last=now^1,tot=dp[last].sz;
	dp[now].init();
	for(int i=1;i<=tot;i++)
	{
		int state=dp[last].key[i];
		data val=dp[last].val[i];
		int p1=find(state,y),p2=find(state,y+1);
		if(link(state,y)==-1||link(state,y+1)==-1)
			continue;
		if(!p1&&!p2&&x!=n&&y!=m)
		{
			dpset(state,y,1);
			dpset(state,y+1,2);
			dp[now][state]+=val;
		}
		else if(p1&&!p2)
		{
			if(x!=n)
				dp[now][state]+=val;
			if(y!=m)
			{
				dpset(state,y,0);
				dpset(state,y+1,p1);
				dp[now][state]+=val;
			}
		}
		else if(!p1&&p2)
		{
			if(y!=m)
				dp[now][state]+=val;
			if(x!=n)
			{
				dpset(state,y,p2);
				dpset(state,y+1,0);
				dp[now][state]+=val;
			}
		}
		else if(p1==1&&p2==1)
		{
			dpset(state,link(state,y+1),1);
			dpset(state,y,0);
			dpset(state,y+1,0);
			dp[now][state]+=val;
		}
		else if(p1==1&&p2==2)
		{
			if(x==n&&y==m)
				ans+=val;
		}
		else if(p1==2&&p2==1)
		{
			dpset(state,y,0);
			dpset(state,y+1,0);
			dp[now][state]+=val;
		}
		else if(p1==2&&p2==2)
		{
			dpset(state,link(state,y),2);
			dpset(state,y,0);
			dpset(state,y+1,0);
			dp[now][state]+=val;
		}
	}
}

int main()
{
	scanf("%d%d",&n,&m);
	if(n==1||m==1)
	{
		puts("1");
		return 0;
	}
	if(m>n) 
		swap(n,m);
//	cout<<"QAQ"<<endl;
	dp[0].init();
//	cout<<"fuck you all"<<endl;
	dp[0][0]=1;
//	cout<<"fuck you"<<endl;
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
			run(i,j);
		if(i!=n)
		{
			int now=(i*m)&1,tot=dp[now].sz;
			for(int j=1;j<=tot;j++)
				dp[now].key[j]<<=2;
		}
	}
	ans+=ans;
	ans.print();
	return 0;
}
```