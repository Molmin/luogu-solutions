退役选手玩玩构造。  

首先我们要确定答案是多少，因为叉数所能达到的最小子树和是随着叉数大小而递增的，所以枚举叉数 $k$，填一个完全 $k$ 叉树看看答案是否小于 $s$，找到第一个小于 $s$ 的即可。  
因为完全 $k$ 叉树深度只有 $\log$ 级别，所以这部分时间复杂度是 $\mathcal O(n \log n)$ 的。因为从完全 $k$ 叉数开始，任意时刻（除了成为一条链）存在一种方案使得叉数不增加且一个挪动到下一层，所以对于 $k$ 叉树一定有解。

考虑如何构造出这个解，可以把树上问题转换成序列上问题，即求序列 $a$ 满足 $\sum a = n$ 且 $\max_{i = 2}^r \frac{a_i - a_{i - 1}}{a_{i - 1}} \le k$ 且 $\sum_{i = 1}^r i \cdot a_i = s$。  
同样可以从满的情况开始移动。手玩一下 $k = 2$ 的情况可以发现，如果确保一个后面的都是这一个的 $\frac{1}{k}$ 及以下，那么就可以随便往后移动，容易证明，这对于 $k > 2$ 同样适用。  
所以就有了这样一个做法，搞俩指针 $l, r$，每次从 $r$ 遍历到 $l$，若 $a_r = k^{l-1}$ 则 $r$ 右移一个，如果当前的大于 $k^{l - 1}$ 则需要移动，如果当前塞到 $a_r$ 去不会使答案超出 $s$ 那么移动到最右边，否则移动到合适的位置终止构造。  
每次最多遍历树的所有结点，$l$ 最多移动 $\log$ 次，所以复杂度是 $\mathcal O(n \log n)$ 的。

Codeforces 提交记录：[#158536993](https://codeforces.com/contest/1098/submission/158536993)。