## 前言

大家都说这是一道笛卡尔树的模板题，但是我们简单观察一下数据范围：$1\leqslant n,k\leqslant 500$，发现 $n^2$ 的暴力建堆对于本题的代码速度不会有较大的影响。于是我们不需要笛卡尔树，暴力建堆即可。

**这是题解区唯一一篇不需要笛卡尔树的题解**，除此之外，本题是一道极好的动态规划题。

## 思路

1. 我们先想简化版本：表格是一个完全的 $n\times m$ 矩形，那么易知答案为 $\dfrac{n!m!}{(n-k)!(m-k)!k!}$，其实就是 $n$ 行里面选 $k$ 行的方案数量乘 $m$ 行里面选 $k$ 行的方案再去重（去重即除以 $k$ 的排列）。

2. 观察图形，显然低位比高位更加难处理。于是想到动态规划：先将独立的每一列作为初始状态，然后不停**从高往低**合并。

   如下图，我们可以先处理出绿色部分和蓝色部分，再与红色部分合并。这样就完成了从高往低的合并。
   
   ![](https://cdn.luogu.com.cn/upload/image_hosting/chqhqjf0.png)

   其它情况也是类似的，对于一个区间，先找出其中最小  $h$  的位置，处理出其左侧和其右侧的图形方案数，再与下面这块公共的红色合并。

3. 设计状态：对于一个区间，我们只需要记录此区间中放 $i$ 个数的方案数即可，于是记其为 $p_i$。

4. 考虑转移，设左边（图中绿色部分）的状态为 $l$，右边（图中红色部分）的状态为 $r$，我们可以枚举左边放的数数量 $i$，右边放的数数量 $j$，下面（图中红色部分）放的数数量 $s$，则每次枚举 $p[i+j+s]=p[i+j+s]+l.p[i]\times r.p[j]\times\text{count}(L-i-j,H,s)$。其中 $L$ 为区间长度，$H$ 为下面区域的高度，$\text{count}(n,m,k)$ 即指 1. 中的问题方案数。

5. 现在合并的代码时间复杂度为区间数量乘以枚举时间复杂度即 $O(k^3n)$，能拿到大约 40 分。于是我们考虑优化。最大的问题出在状态合并处。我们是否可以将 $k^3$ 合并优化至 $k^2$ 合并？

   答案是可以的，我们先假设 $k=0$，枚举 $i,j$，设这样得到的状态为 $q$。然后考虑加上 $s$，于是我们视上面为一个整体 $(q)$，下面为一个整体。可以分别枚举两边取得数量，这样就是 $k^2$ 的转移了。

现在纵观整个动态规划，先是找到区间最低点，然后分左右处理，个人认为这像是一个区间 $\text{DP}$。

但是如果我们将每个区间看作一个节点，那么每次合并想做一个二叉树中左子树（区间最低点左侧）和右子树（区间最低点右侧）与根的合并，这又像是一道树形 $\text{DP}$。

在写的时候，我分了三类来讨论，二叉树中此节点为叶子节点为 1 类，此节点只有一个叶子为 2 类，此节点有两个叶子为 3 类，个人认为这是比较方便理解的。

![](https://cdn.luogu.com.cn/upload/image_hosting/weugqlf8.png)

综上，由于区间数不超过 $k$，本题时间复杂度为 $O(k^3n+n^2)$。由于二叉树每个节点的最小值其实呈现了一个**小根堆**的性质（如图，$\text{minh}$ 即呈现此性质），可以用笛卡尔树建树优化，省掉一个 $n^2$，别的题解将的比较详细，在此不做赘述。

## 代码 / 注意点

[代码及注释](https://www.luogu.com.cn/paste/rp8h0b55)

其实本题细节还是比较多的，特别是 $\text{DP}$ 的过程中，一定要注意边界情况。

## 后记

这么说来，这道动态规划是不是还是比较简单的？点个赞再走呗~

其实这么写的确比笛卡尔树的写法慢一些，有能力还是建议写一下笛卡尔树。