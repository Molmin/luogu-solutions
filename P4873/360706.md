### [题目传送门](https://www.luogu.com.cn/problem/P4873)
## 算法：栈

先观察题目，可以发现每一个奶牛的初始位置为升序排列。

那么这样的话，先假设只有两个人，
如果第二个人最后位置比第一个人最后的位置大，那么他们就不会相交，
那么就是只用一条跑道。

如果比那个小，那么就必须要两条跑道。
再进来第三个，和刚刚一样，只是比较的对象从一个人变为这一条跑道上最小的终点。

在此同时，我们把这个跑道终点做一个上升的序列，
每次加人，就判断是不是终点比之前的远，
如果是的话就加一条跑道，不是的话就找到终点比他小且离他最近的点，维护单调性。

我们可以通过 upper_bound 来实现，但它找的是第一个    $\geq$ 它的那个数，而我们是要 $\leq$ ，所以就加一个负号，这样就可以实现了。

具体看代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,t,p,s,c;
vector<long long> a;//比数组更好的数组，用数组模拟栈
int main()
{
 cin>>n>>t;
 for(int i=1;i<=n;i++)
 {
  cin>>p>>s;
  c=-(p+s*t);//加负号以做到相反的需求
  if(a.empty()||c>=a.back())
  {
   a.push_back(c);//没一条跑道加的了它，就新加一条
  }
  else *upper_bound(a.begin(),a.end(),c)=c;
  //第一个 >= 它的那个数
 }
 cout<<a.size();//跑道数
}
 

```
