## 前置知识
### Dilworth 定理

这个定理大概意思就是：

>一个序列中一种链的个数 = 这个序列中最长反链的长度

导弹拦截是一道经典的 Dilworth 定理的题目拿导弹拦截的第二问样例做个示范
>389 207 155 300 299 170 158 65

第二问要求有多少个最长不上升子序列。根据 dilworth 对偶定理，最长不上升子序列的个数=最长上升子序列的长度。

这个序列中最长上升子序列的长度是 2，所以第二问的答案是 2.

## 题目大意

有 $n$ 头奶牛，现在知道他们的起始位置，跑的速度，现在开始跑步，跑的时间为 $t$。~~其实就是告诉你结束的位置了~~现在已知起点是升序排列的。求要安排几根跑道才能使奶牛不会发生“超车现象”。

## 分析
首先在没思路的情况下，先把样例拿过来看看能怎么动动。

>0 1

>1 2

>2 3

>3 2

>6 1

现在 $t = 3$

| 序号 | 起点 | 速度 | 终点   | 安排的跑道号 |
| -----------: | -----------:   | -----------: | -----------: | -----------: |
| 1 | 0 | 1 | 3 | 1 |
| 2 | 1 | 2 | 7 | 1 |
| 3 | 2 | 3 | 11 | 1 |
| 4 | 3 | 2 | 9 | 2 |
| 5 | 6 | 1 | 9 | 2 |

通过对比，我们不难得出结论，这不就是求以终点为序列的最长上升子序列的个数吗？

其实是的，因为起点在你前面的结束之后如果还在你前面，那么你俩可以放在一个跑道里，如果结束后在你后面，那么你们在过程中肯定发生了“超车现象”。而起点正好是以升序排列的。所以就只用求求以终点为序列的最长上升子序列的个数，就是答案了。

## 代码

好了，根据 Dilworth 定理,现在需要求的就是终点这个序列中最长不上升子序列的长度。
直接 $O(n\log n)$ 时间复杂度搞定。
代码肯定30行以内。

~~代码还需要吗？~~

```cpp
#include<bits/stdc++.h>
using namespace std;

long long g_n,g_t;
long long g_a[100010];
long long g_b[100010];
long long k,a,b,ans;

int main(){
	cin>>g_n>>g_t;
	memset(g_a,0x3f,sizeof(g_a));
	g_a[0]=0;
	for(int i=1;i<=g_n;i++){
		cin>>a>>b;
		k=a+g_t*b;
		g_b[i]=k;
	}
	for(int i=g_n;i>=1;i--){		
		if(!ans||g_b[i]>=g_a[ans])
			g_a[++ans]=g_b[i];
		else{
			int p=upper_bound(g_a+1,g_a+g_n+1,g_b[i])-g_a;
			g_a[p]=g_b[i];
		}
	}
	cout<<ans;
	return 0;
}
```
望通过，谢谢

