#### Solution 1（纯暴力）

直接当做一般的背包问题做（也就是令 $dp_{i,j}$ 表示前 $i$ 个数和为 $j$ 的方案数），时间复杂度 $O(kw^2)$，其中 $k$ 为不超过 $w$ 的 $a_i$ 个数，$w$ 为询问中 $x$ 的最大值。期望通过测试点 $1 \sim 5$。

#### Solution 2（数位 dp+推导）

 一般的这种范围的背包问题是不可做的，对于这个问题我们需要一些观察。

之后我们记 $1 \le i \le m$ 的 $a_i$ 是小的，其它是大的。

测试点 $6 \sim 8$ 中答案不超过 $1$，我们只用判断是否能取到就行。

对于小的 $a_i$，也就是 $1 \le i \le m$，我们能背包出它们能取到什么数。

只用考虑大的 $a_i$ 表示出一个数的方案数。

我们考虑将每一种方案对应成一个 $0-1$ 数组，第 $i$ 位是 $1$ 当且仅当 $a_i$ 被选择。这里 $i \ge m+1$。

注意到我们可以对方案进行这样的操作而不改变最后的和：对于连续 $m$ 个 $1$，如果之后一位是 $0$，那么可以把这些 $1$ 都变成 $0$ 并且把之后的 $0$ 变成 $1$。

我们不断进行这样的操作，它肯定会停止（我们考虑直接看成二进制数在变大，但是很后面的位显然不能是 $1$）。

停止的时候不会有连续的 $m$ 个 $1$，否则取其中最前的一组还可以继续操作。我们称这样操作到不能再操作的表示为最简表示。

现在，我们有如下结论：**最简表示是唯一的**。

考虑反证法。如果有两种不同的最简表示，去掉相同的位之后还是最简表示。那么我们可以假设这两个表示没有相同的位。不妨假设第一个表示有某个 $a_n$，而第二个表示用的都是更小的数。

注意到第二个表示在 $a_{n-1},a_{n-2},\cdots a_{n-m}$ 中必定有一个不选；$a_{n-m-1},\cdots,a_{n-2m}$ 中也是如此。这样它的和最多是 $a_{n-1}+\cdots+a_{n-m+1}+a_{n-m-1}+\cdots +a_{n-2m+1}+\cdots<a_n$。最后的小于号对 $n$ 归纳，将左边的前 $m-1$ 项移到右边并且利用通项公式，那么就变成了 $n-m$ 的情况。

当然证明上述结论的过程显然也表明了直接从上往下的贪心（从最大的 $a_i$ 开始，如果当前 $x$ 大于现在考虑的 $a_i$ 就将 $x$ 减去 $a_i$，然后再考虑下一个，一直这样下去）确实能求出唯一的最小表示。

最后计数方案数：对于每一种最小表示，考虑变回普通表示的话，只能是 $(11\cdots 1011 \cdots 10\cdots 11\cdots 0)\to (00\cdots 01)$，其中左边那个第一段是 $m$ 个 $1$，后面的段是 $m-1$ 个 $1$。

注意这样退回去的过程中不同的 $1$ 最终变回的部分和原来的 $1$ 顺序相同，并且可能到达的范围也很好求出。现在令 $dp_{i,0/1}$ 为到第 $i$ 位，前面一个最简表示中的 $1$ 要不要变回到这一位的方案数即可。（其中 $i$ 的取值范围是最简表示的 $1$ 的位置）

时间复杂度：背包的复杂度为 $O(m\max a_i)$，之后数位 dp 的复杂度为 $O(\log x)$，总复杂度 $O(mq \max a_i\log x)$。

bonus：仔细思考一下几个细节，例如为什么从上往下直接贪心并不能通过测试点 $6-8$，但是在什么样的 $a_i$ 下这个贪心算法又是正确的；更具体地，想清楚为什么我们只考虑大的 $a_i$ 就可以贪心，而带上小的 $a_i$ 又不行。 

#### Solution 3(爆搜)

直接开始爆搜，用 `Search(x,y)` 表示用前 $y$ 个数凑出 $x$ 的方案数，具体的式子和直接背包类似。我们将所有搜到的状态记忆化，这样就不弱于直接背包。如果想要通过，我们需要两个优化：如果当前的 $x$ 大于剩下的所有剩下的数之和，那么答案显然是 $0$；对于较小的 $x$ 用背包预处理答案，搜索到这些 $x$ 时直接返回。

可以证明以上爆搜的复杂度是正确的。实际上，可以发现上述表示中如果最大的是第 $t$ 位的话，那么 $t,t-1$ 位至少选一位，否则会被剪枝掉。这样两次搜索就能让 $y$ 减小 $1$。更加合适的想法是 Proof by AC 或者注意到最大的两个必须选一个，从而想到状态数应该不多。期望通过所有测试点。

如果忽略了一些细节或者没有想到什么优化也有很大概率通过测试点 $7\sim 11$。