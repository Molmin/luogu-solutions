~~[蒟蒻安利一发博客](https://www.luogu.com.cn/blog/807774/)~~

~~什么？能水题解？这不得水一发~~

题目都告诉我们了这题是离散化。

针对初学 离散化 算法的初学者，~~应该算详细了吧。~~

### 什么是离散化？

离散化，将一个疏散数列变得稠密，使得数之间的 **大小关系** 不变。

比如，```8 6 114 3 514 6``` 这组数列经过离散化后会变成 ```3 2 4 1 5 2```。容易发现它们之间相对的大小关系没变。

更多地看一眼，发现两个数组间的对应关系为 **当前这个数在数组中从大到小是第几个，它离散化后就是几**。

实现方法见后文。

### 为什么要用离散化？

假如我们有这样一个问题：

```有一群小朋友排队，问题只会涉及到小朋友的位置关系，而不会涉及到小朋友的具体距离。并且假如我们要用数组存下来。```

普通的存法很容易爆空间。但是既然只涉及位置关系，就可以离散化后储存，**节省空间**。

### 如何进行离散化？

- 首先，将所有的元素复制在一个新数组（不妨叫它 lsh）中。

- 其次，对这个数组进行排序。

这时，我们的 lsh 数组中存储了 **有序的** 原数组。

- 将 lsh 数组去重。

介绍一个神奇的函数 ```unique()```

```unique()``` 函数将 **排好序** 的数组进行去重，并返回新数组 **末位位置的下一个位置**。

- 去重过后，lsh 数组变成了 **有序且每个数只有一个** 的数组。将它与原数组中的数一一对应即可。具体做法是二分（```lower_bound``` 函数），默认已经学过。

### 详见本题代码

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=1e5+10;

int T,n,a[N],lsh[N];

inline void disc(){
	for(int i=1;i<=n;i++)lsh[i]=a[i];//复制
	sort(lsh+1,lsh+n+1);//排序
	int cnt=unique(lsh+1,lsh+n+1)-lsh-1;//unique 函数用法如此，如果习惯下标以 0 开头就不需要最后的减一
	for(int i=1;i<=n;i++)a[i]=lower_bound(lsh+1,lsh+cnt+1,a[i])-lsh;//二分找到对应的离散化值
}

signed main(){
	ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);//输入输出流优化，优化常数，加了好习惯
	cin>>T;
	while(T--){//多组数据用这个
		cin>>n;
		for(int i=1;i<=n;i++)cin>>a[i];
		disc();//进行离散化
		for(int i=1;i<=n;i++)cout<<a[i]<<' ';//此时 a 数组已经经过离散化
		cout<<'\n';
	}
	return 0;
}
```

离散化的大多数用处在于节省空间，让数据能在数组中储存下来。

通过代码可以发现，离散化的时间复杂度是 $O(n \log n)$ 级别的。

~~希望这篇题解能对初学者提供友好的帮助 QWQ~~