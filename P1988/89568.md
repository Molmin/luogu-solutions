题意：
任意给定一个正整数N求一个最小的正整数M

使得N * M的十进制表示形式里只含有1和0。

我们不妨转化为：找一个用１和０组成的能整除Ｎ的最小数Ｒ，输出Ｒ／Ｎ

于是我们要做的就是从小到大穷举十进制数Ｒ再判断能否整除

既然求最小值则类似于宽搜，对于一个数Ｒ，如果Ｒ能整除Ｎ则直接输出，否则拓展为Ｒ＊１０和Ｒ＊１０＋１，得到井然有序的序列

举例：１－＞１０　１１－＞１００　１０１　１１０　１１１　以此类推


------------


一共需要穷举多少个呢？　ｌｏｎｇ　ｌｏｎｇ　范围够大了，到２０位数字

每一位取０或１　一共能得到２^２０个数字　

为了避免卡常　可以设置到２＾２０｜３　

如果超过这个范围还没搜到，就输出无解　~~本题数据很水都有解，可安心食用~~


------------

```c
#include<bits/stdc++.h>
using namespace std;
int n,f,r;
long long q[(1<<20)|3]; 
int main()
{	cin>>n;
	q[0]=1;／／第一个数是１
	while(f<=((1<<20)|3)){
		if(q[f]%n==0){
			cout<<q[f]/n;／／能整除则直接输出
			return 0;
		}
		q[++r]=q[f]*10;
		q[++r]=q[f++]*10+1;／／拓展
	}
	cout<<"No Solution";／／无解
    return 0;
}  
```
