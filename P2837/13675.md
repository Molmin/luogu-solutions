### [无耻宣传博客](https://www.luogu.org/blog/user13675/)

蒟蒻第一次写橙题的题解QAQ
这道题我见有的dalao写DP，蒟蒻瑟瑟发抖
其实这道题只用o(n)算法就可以啦QWQ 

**因为我们的最终目标是将整个奶牛队列排序，使其变成所有1牌奶牛在前，2牌奶牛在后**

**所以我们可以假设整个队列全是2牌奶牛，然后在其中模拟分割线**  

**统计1牌的奶牛数量就是为了维持队列全部为2** 

**分割线以前的都是1，以后的都是2，我们的i就是分割线，当前统计的改变次数就是最小代价** 

##### 1.首先将1牌奶牛数量统计好，当作当前最小改变

##### 2.然后从第一头奶牛开始查找，如果找到一个2牌奶牛，那么将改变次数加1

##### 3.我们的i是把1~i的奶牛变为1，看看是否比整队变2优，所以是2改变变量加1，维持i以上是1，如果是1，那么改变变量减1，因为前面我们把队列改2了，不用改。 

##### 4.如果找到一头1牌奶牛，那么就不用改变，改变次数减1

##### 5.如果在寻找中途，改变次数<最小改变，那么就记录答案 
上代码QAQ： 

```cpp
#include<iostream>
using namespace std;
int i,n,a[10000000],gb,mi=21484736;
int main()
{
    cin>>n;
    for(int i=1; i<=n; i++) {cin>>a[i];  if(a[i]==1) gb++;}//输入，统计把队列全部变成2的代价 
    if(gb<mi) mi=gb;//把它当成最小代价 
    for(int i=1; i<=n; i++)
    {
        if(a[i]==2) gb++; else gb--;//维持分割线前面的一牌奶牛 
        if(gb<mi) mi=gb;//如果当前代价<最小代价，就更新最小代价 
    }
    cout<<mi;//输出
	//求通过QAQ 
    return 0;
}
```
