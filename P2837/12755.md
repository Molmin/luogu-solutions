这道题是可以用两种算法。

# 讲得有点复杂，请多见谅
-----------------------------
# DP方法中的注释：
# 这里的一个1指一头标明用餐批次为1的奶牛。
# 同理，一个2指一头标明用餐批次为2的奶牛。

## DP 或 枚举（貌似是贪心？？？）

------------------------------------------

------------------------------------------
### 1、DP

这道题目我们可以很明显看出，改一头奶牛的卡片编号

是对后面的最优解是

### 有影响的！！！

###### 为什么呢？
###### 因为当你将一个1改为2时，他的后面可能会是的连续一段的1，实际不改还好过改。
###### 同样，因为当你将一个2改为1时，他的后面可能会是的连续一段的2，也是不改还好过改。
	
这也就是所谓贪心的
    
### 后效性！！！

### （这对一道题目来说是能不能用贪心的决定性依据）
	
由此可见，我们要使用DP。（因为DP是没有后效性的）
    
那我们要怎样使用DP呢？
    
（读到这里请思考一会儿再读下去）

-----------------------------------------

我们对于每一个序列，我们给它定义。

状态1：全由标明用餐批次为1的奶牛组成的队列。

状态2：前面由标明用餐批次为1的奶牛组成，后面由标明用餐批次为2的奶牛组成的队列。
    
对于每一个1来说，前面可能是状态1，又可能是状态2。

前面是状态1：
他可以选择不改，那么现在他以及他前面的依然是状态1。

他可以选择改，那么现在他以及他前面的是状态2。

前面是状态2：
他只能改，那么现在他以及他前面的是状态2。

那么我们可以知道转移方程：

第i个是一个1且改或不改后为状态1的最小更改次数：
```cpp
f[i][1]=f[i-1][1];
```
    
第i个是一个1且改或不改后为状态2的最小更改次数：
```cpp
f[i][2]=min(f[i-1][2]+1,f[i-1][1]+1);
```

-----------------------------------------

同样，对于每一个2来说，前面可能是状态1，又可能是状态2。

前面是状态1：
他可以选择改，那么现在他以及他前面的依然是状态1。

他可以选择不改，那么现在他以及他前面的是状态2。

前面是状态2：
他只能不改，那么现在他以及他前面的是状态2。

那么我们可以知道转移方程：

第i个是一个1且改或不改后为状态1的最小更改次数：
```cpp
f[i][1]=f[i-1][1];
```
    
第i个是一个1且改或不改后为状态2的最小更改次数：
```cpp
f[i][2]=min(f[i-1][2]+1,f[i-1][1]+1);
```

-------------------------------------
最后，我们只要输出第n头奶牛以及他前面的状态1或状态2下的最优解，即：
```cpp
cout<<min(f[n][1],f[n][2])<<endl;
```

# 讲得有点复杂，请多见谅*2

Pass Code:
```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int n,s[30000+5],f[30000+5][5+5];
void read_data()//读入数据
{
	scanf("%d",&n);
	for (int i=1;i<=n;i++)
	scanf("%d",&s[i]);
}
void work()
{
	for (int i=1;i<=n;i++)
		if (s[i]==2)//对于每一个2
		{
			f[i][2]=min(f[i-1][1],f[i-1][2]);//不改的最优解
			f[i][1]=f[i-1][1]+1;//改的最优解
		}
		else//对于每一个1
		{
			f[i][2]=min(f[i-1][2]+1,f[i-1][1]+1);//改的最优解
			f[i][1]=f[i-1][1];//不改的最优解
		}
}
void put_ans()
{
	cout<<min(f[n][1],f[n][2])<<endl;//输出答案
}
int main()
{
	read_data();
	work();
	put_ans();
}
```
------------------------------------------

------------------------------------------
### 2、枚举
相信有一些蒟蒻听不懂DP，

~~毕竟每两个OIer之间都可能有水平差距。~~

那么我们要怎么做呢？

（读到这里请思考一会儿再读下去）

--------------------------------------------


你可能会想到枚举前面全改为1与后面全改为2的断点。（注意：第i头牛的断点指他与他后面的牛之间）

### （这个有点难想，毕竟我也是听了某同学的意见才知道的）

但是，我们如果用双重循环，一个枚举断点，一个计算答案，算算时间复杂度：
### O（N*N）

### 30000*30000=900000000

很明显，用上面的方法做会TLE。  

那么怎么优化呢？

（读到这里还请大家思考一会儿再读下去）

-----------------------------------------

我们可以增加两个数组。

一个（下面Pass Code的bj1），记录该断点前标明用餐批次为1的奶牛的个数和标明用餐批次为2的奶牛的个数

另一个（下面Pass Code的bj2），记录该断点后标明用餐批次为1的奶牛的个数和标明用餐批次为2的奶牛的个数

首先，我们在读入时将用餐批次为1的奶牛前的个数和标明用餐批次为2的奶牛的个数求出来。

然后，进行改为全1和改为全2的特殊判断，即（mi为现在暂时的答案）：
```cpp
mi=min(bj2[1],bj2[2]);
```

接着，我们可以开始枚举断点（注意：第i头牛的断点指他与他后面的牛之间）

然后，我们每一次将该奶牛在bj2的个数减一，在bj1的个数加一。

###### 为什么呢？
###### 因为我们要将该奶牛一开始变成的2变回现在的1

### （这里讲得不是很好，欢迎大家提意见）

我们只要把前面变为1的序列中2的个数与前面变为2的序列中1的个数加起来，就变成这个为断点的解，找出他们的最优解，存入现在暂时的答案。最后输出他就行了。

Pass Code：
```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int n,s[30000+5],bj2[30000+5],bj1[30000+5],mi=2147483647;
void read_data()
{
	scanf("%d",&n);
	for (int i=1;i<=n;i++)
	{
		scanf("%d",&s[i]);
		bj2[s[i]]++;//预处理
	}
	mi=min(bj2[1],bj2[2]);//特殊判断
}
void work()
{
	for (int i=1;i<=n;i++)//枚举断点
	{
		bj1[s[i]]++;
		bj2[s[i]]--;
		mi=min(bj1[2]+bj2[1],mi);
	}
}
void put_ans()
{
	cout<<mi<<endl;//输出答案
}
int main()
{
	read_data();
	work();
	put_ans();
}
```