## P2362 【围栏木桩】

虽然标签写的是dp，但是：
> __~~搜就完事了！~~__

分析题目：
>某农场有一个由按编号排列的n根木桩构成的首尾不相连的围栏。现要在这个围栏中选取一些木桩，按照原有的编号次序排列之后，这些木桩高度成一个升序序列。试编写程序从这个围栏中选取合适的木桩使得选出的木桩个数t最大，并求出选取出t根木桩的方案总数c。

其实完全可以简化成：
>给你n个数，求最长上升序列，并找出有多少种方式可以达到最长上升序列。

这样就简明易懂了。看完输入输出发现没什么坑点。再来看看数据：
>$m≤5,n≤20,h{_i}≤150$

~~好家伙，这不写dfs都对不起这个数据。~~

那我们该如何实现这个dfs呢？

仔细分析，我们只需要找出最长上升序列的长度和达到的方式数。

所以我们的函数完全只需要两个值：
- 当前我们搜到了第几个数。
- 当前上升序列的长度。
```cpp
void qing_s( int noww , int sum )
//忽略我的函数名，noww是当前搜到的数，sum是当前长度。
```
那我们在函数内应该怎么实现查找上升序列呢？

很显然，因为我们最后要找出的序列顺序是源自于输入的顺序，所以我们只需要挨个遍历就可以了。

```cpp
for( int i = noww + 1 ; i <= n ; i++ )
		if( num[i] >= num[noww] )
			qing_s( i , sum + 1 ) ;
```
注意： 我们要求的序列是后面的数 __不小于__ 前面的数。所以要用 ≥ ，~~我一次就是卡在这里了。~~

那我们函数的结束条件是什么呢？

根据我们需找出的东西（最长上升序列的长度和达到方式数），我们就可以很简单的知道结束条件，分为两种情况：
1. 当当前序列长度优于已知最长序列长度，更新，并把达到方式数变为一（只发现当前一种）。
1. 当当前序列长度等于已知最长序列长度，不更新，达到方式数加一。

那我们就可以写出代码，如下：
```cpp
if( sum == ans )//如果等于。
		fs++ ;//方式数+1。
	if( sum > ans ){//不等于。
		ans = sum ;
		fs = 1 ;//更新长度，方式数变为1。
	}
```

再稍微处理一下输入输出：
```cpp
cin >> m ;
	while( m-- ){
		cin >> n ;
		for( int i = 1 ; i <= n ; i++ )
			cin >> num[i] ;
		for( int i = 1 ; i <= n ; i++ )
			qing_s( i , 1 ) ;//从第一个数开始遍历。
		cout << ans << " " << fs << endl ;//换行输出。
		ans = fs = 0 ;//注意重置ans和fs的值。
	}
```

就可以很顺利的AC了！

#### 结语：
其实很多dp的题目都可以使用记忆化搜索骗分（废话，在考场中我们不一定是要打出正解，只需要让我们的分数和到达我们所能到达的最大值。

就好比你在考场中推了一个状态转移方程但是你不能证明它的正确性，此时应该在暴力算法和你所打出的代码中正确取舍。