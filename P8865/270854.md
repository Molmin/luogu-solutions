## 题意分析

求出分别种出 ```C``` 和 ```F``` 型图案花的方案数。

首先明确怎样的 ```C``` 和 ```F``` 型图案是合法的。

仔细阅读题意和样例及其说明可知，对于每一个个合法的 ```C``` 型图案，有如下限制要求。

- ```C``` 的最上面一横和下面一横的长度不小于 $2$。
- ```C``` 左侧一竖的长度的长度不小于 $3$。

题目中已经指出：```C``` 的两横可以不一样长。

根据以上要求，不难推断出样例 #1的说明中给出的第一种 ```C``` 的构造是所有符合题意中的，种花总数最小的构造方式。

```
**
*
**
```

也就是说，对于其他的合法的 ```C``` 的构造，**至少**满足以下条件的其中之一。

- 上面一横的长度大于 $2$。
- 下面一横的长度大于 $2$。
- 左侧一竖的长度大于 $3$。

分析完合法的 ```C``` 的构造后，不难看出对于每一种合法的 ```F``` 的构造，都是在某一种合法的 ```C``` 的构造其中 ```C``` 的左侧一竖下添加若干的花构造而成的。

## 解法思路
以下用 $0$ 点代指位置上对应字符是 $0$ 的点，用 $1$ 点代指位置上对应字符是 $1$ 的点。


对于每个 $0$ 点，统计出在这个点的右边和下面还有多少个 $0$ 点。得到这些信息之后，枚举每一个 $0$ 点，计算出以这个点作为左上角的点，可以构造出的 ```C``` 和 ```F``` 的方案数即可。

直接对于每个点暴力计算的话，时间复杂度最坏情况下会来到 $\mathcal{O} \left(n^3 \right)$。加上前缀和优化后，时间复杂度变为 $\mathcal{O} \left(n^2 \right)$。

尤其要注意的是，本题的每个测试点含有**多组数据**，考虑 $0$ 点的同时，一定要把 $1$ 点统计如上两种信息的数组全部清零，否则就会因为这个原因取得个位数分数的好成绩。并且，本题的三个样例均给出 $T=1$，有的同学可能过了三个样例，并且时间复杂度正确，就会认为自己可以通过此题了。事实上，这里隐藏着本题的最大陷阱。把三个样例组合成一个 $T=3$ 的大样例再进行测试是一个不错的选择。

以上说的同学就是我自己。

## 实现步骤

对于每个 $0$ 点统计的这个点的右边和下面还有多少个 $0$ 点，可以直接枚举，并用递推的方法直接统计得出。考场上时，我把这个统计理解成这个点右边和下面第一个 $1$ 的位置，也就是第一个比 $0$ 点大的数的位置。如此，成了一个裸的只有两种数的弱化版**单调栈**的板子。

首先是前文提到的初始化。默认对于 $0$ 点的统计信息设置为边界情况，更重要的是对于 $1$ 点的统计信息**清零**。

```cpp
	for (int i = 1; i <= n; i++)
	{
		for (int j = 1; j <= m; j++)
		{
			 std::cin >> ch[i][j];
			 if(ch[i][j] == '0')
			 {
			 	r[i][j] = m - j + 1;
				d[i][j] = n - i + 1;
			}
			else
			{
			 	r[i][j] = 0;
				d[i][j] = 0;
			}
		}
	}
```

接下来是用单调栈统计出我们需要的信息。将 $0$ 点的位置入栈，遇到 $1$ 点时更新栈内 $0$ 点的统计信息，用两者的位置差即可得出 $0$ 点的统计信息。

```cpp
	std::stack<int> s;
	for (int i = 1; i <= n; i++)
	{
		s = std::stack<int> ();
		for (int j = 1; j <= m; j++)
		{
		    if(ch[i][j] == '1')
		    	while (!s.empty())
		    		r[i][s.top()] = j - s.top(), s.pop();
		    if(ch[i][j] == '0')
		        s.push(j);
		}
	}

	for (int i = 1; i <= m; i++)
	{
		s = std::stack<int> ();
		for (int j = 1; j <= n; j++)
		{
		    if (ch[j][i] == '1')
		    	while (!s.empty())
		    		d[s.top()][i] = j - s.top(), s.pop();
		    if (ch[j][i] == '0')
		        s.push(j);
		}
	}
```

~~面向数据可以忽略地~~，计算出 $0$ 点的统计信息及其前缀和。对于 ```C``` 的构造方案，实际上是对于相同长度的左侧一竖的长度时，上面一横的长度从 $2$ 取到最长，下面一横的长度从 $2$ 取到最长。再将左侧一竖的长度从 $3$ 取到最长。对于 ```F``` 的构造方案，是在以上枚举左侧一竖的长度时基础上再乘以左侧多出的数的长度。

形象地说，与上面给出的代码一致，记每个 $0$ 点向左延伸的横的长度和向下延伸的数的长度分别记为 $r_{i,j}$ 和 $d_{i,j}$，枚举左侧一竖的长度为 $k$。记以点 $\left(i,j \right)$ 为左上角，左侧一竖的长度为 $k$ 时 ```C``` 的构造方案数为 $C_{i,j,k}$。有如下表达式。

$$C_{i,j,k}=\left(r_{i,j} - 1\right) \times \left(r_{k,j} - 1\right) $$

若对于点 $\left(i,j \right)$，符合条件的 $k$ 满足 $k \in \left[L,R \right]$。

$$\sum\limits_{k=L}^{R}C_{i,j,k}=\left(r_{i,j} - 1\right) \times \sum\limits_{k=L}^{R}r_{k,j}$$

很显然，这里的 $\sum\limits_{k=L}^{R}r_{k,j}$ 可以使用前缀和计算得出。

省略对于 ```F``` 的构造方案计算，基本同理，详见代码。

```cpp
	for(int i = 1; i <= n; i++)
            for(int j = 1; j <= m; j++)
            {
                sum[i][j] = sum[i - 1][j] + r[i][j] - 1;
                sum2[i][j] = (sum2[i - 1][j] + (r[i][j] - 1) * (d[i][j] - 1) % MOD) % MOD;
            }
            
	for(int i = 1; i <= n; i++)
		for(int j = 1; j <= m; j++)
			if(r[i][j] >= 2 && d[i][j] >=3)
				{
                	C = (C + (r[i][j] - 1) * (sum[i + d[i][j] -1][j] - sum[i + 2 - 1][j])) % MOD;
                	F = (F + (r[i][j] - 1) * (sum2[i + d[i][j] - 1][j] - sum2[i + 2 - 1][j])) % MOD;
					//for(int k = i + 2; k <= i + d[i][j] - 1; k++)
					//	if(r[k][j] >= 2)
					//	{
					//		long long ans = (r[i][j] - 1) * (r[k][j] - 1) % MOD;
					//		C = (C + ans) % MOD;
					//		//printf("C ans:ch[%d][%d] = %lld\n", i, j, ans);
					//		if(d[k][j] >= 2)
					//		{
					//			F = (F + (ans * (d[k][j] - 1) % MOD)) % MOD; 
					//			//printf("F ans:ch[%d][%d] = %lld\n", i, j, ans);
					//		}
					//	}
				}
```

这部分代码中被注释掉的部分是不使用前缀和时的暴力计算方法，可以加深对前面计算公式的理解。

[完整代码](https://www.luogu.com.cn/paste/3wbsoyj3)，祝各位 $\rm{NOIP}\ \rm{RP++}$。