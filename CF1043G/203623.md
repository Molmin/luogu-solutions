考虑到 kkksx 大致方向讲的很清楚，我只简述一下本题的 polylog 解法。

### 判断区间是否存在循环节（非本身）

显然，若一个长度不行，那么其因数也不行。

那么枚举 $p$ 为区间长度 $len$ 的质因子，我们只需要判断 $\dfrac {len} p$ 是否可行即可。

即 $[s[l,r-\dfrac {len} p]=[l+\dfrac {len} p,r]]$。

hash 或 SA 之类均可。$O(\log n)$ 单次。

### 判断区间是否存在不重叠的相等前后缀

即判断区间是否存在起点 $\in [\lceil \dfrac {l+r+1} 2\rceil,r] $ 的 border。

可以套用区间 border 的做法。

设 border 的起点为 $i$，那么 $r-i+1\le lcp(l,i)$。

建出反串的 SAM，设点 $i$ 在 SAM 上的位置为 $rk_i$，显然 $r-i+1\le len_{lca(rk_l,rk_i)}$。

扫描线，扫到 $\lceil \dfrac {l+r+1} 2\rceil$ 时加入询问，扫到 $r+1$ 时删除该询问。

那么对于每个 $i$，我们取出所有的满足这个 $i$ 是询问区间 border 的询问即可。

对 parent tree 轻重链剖分，一条到根的路径就被拆成了 $O(\log n)$ 条重链的前缀。

从 $rk_i$ 向上跳重链（优化枚举祖先），假设现在跳到了点 $u$，链顶为 $top_u$，父亲为 $fa_u$，考虑该重链前缀的贡献。

1. $lca(rk_l,rk_i)=u$

显然这类 $rk_l$ 几乎在点 $u$ 的子树内。

断言这个“几乎”是没有影响的，因为这类点之前算过了。这个显然没有影响。

现在 $i,lca$ 是确定的，那么移项得 $r\le len_{lca(rk_l,rk_i)}+i-1$。

那么每次取出子树中的最小值判断即可。

2. $lca(rk_l,rk_i)=v$，$v$ 为 $fa_u \to top_u$ 上的点。

这类 $rk_l$ 在 $v$ 的轻子树内或 $rk_l=v$。

因为 $rk_l$ 显然不在 $v$ 的重子树内，否则之前就算过了。

那么有 $r-len_{lca(rk_l,rk_i)}+1\le i$。

在插入询问的时候枚举包含其的轻子树，显然是 $O(\log n)$ 个。

同理，每次取出链中的最小值判断即可。

那么上面的两类引导我们设计这样一个数据结构，维护序列（上面的用 dfn 拍平），支持在一个位置插入（相当于每个位置是个可重集？），求区间最小元组，删除一个位置的最小值。

小孩都会，每个位置维护个堆，用线段树维护区间最小值即可。

这个的时间复杂度为 $O(n\log^2 n)$。

[CF 评测记录](https://codeforces.com/contest/1043/submission/149364916)