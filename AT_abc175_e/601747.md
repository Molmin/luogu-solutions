[题目传送门](https://www.luogu.com.cn/problem/AT_abc175_e)

# 题目大意
高桥君从格子 $(1,1)$ 出发走到格子 $(R,C)$。高桥君在格子 $(i,j)$ 时，可以走到格子 $(i+1,j)$ 或格子 $(i,j+1)$。高桥君可以取路过的格子内的物品，但是一行最多只能取 $3$ 个，求高桥君拾取的物品总价值的最大值。

# 题目思路

### 升维型动规

在这道题中，我们需要用一个 $dp$ 数组表示高桥君当前的横坐标、纵坐标、在该行拾取物品的个数，因此最初可以先把数组设定为 $3$ 个维度。

### $dp_{i,j,k}$ 表示高桥君从 $(1,1)$ 走到 $(i,j)$ 且在当前行拾取了 $k$ 个物品所能达到的最大价值。

# 状态转移
这道题的状态转移方程总共有 $2$ 种情况。

 - 拾取当前物品。

如果想要拾取当前物品，我们可以反推上一步，共有从上面走来和从左面走来两种情况，因此得到状态转移方程：
```cpp
dp[i][j][k]=max(dp[i-1][j][3],dp[i][j-1][k-1])+a[i][j];
```
 - 不拾取当前物品。

如果不想拾取当前物品，我们也可以反推上一步：共有从上面走来和从左面走来两种情况。但是如果不想拾取当前物品，完全没有必要从这一列走下来，因此不可能从上面走来。得到状态转移方程：
```cpp
dp[i][j][k]=max(dp[i][j][k],dp[i][j-1][k-1]);
```

# 一些问题

 - 由于 $v_i\leq10^9$，因此要记得开 long long。 
 - 由于 $R,C\leq3000$，因此我们的数组要开到 `dp[3005][3005][4]`，为了优化空间，我们可以进行压维。三个维度中表示高桥君横坐标的第一个维度我们可以用滚动数组的方法强行压掉，原因是高桥君只能向右和向下走，我们可以把一行的数据覆盖到上一行。优化后的状态转移方程如下：
 ```cpp
dp[j][k]=max(dp[j][k],dp[j][3]+a[i][j]);
dp[j][k]=max(dp[j][k],dp[j-1][k-1]+a[i][j]);
dp[j][k]=max(dp[j][k],dp[j-1][k]);
```
# 满分代码(内含一坑)
```cpp
#include<bits/stdc++.h>
using namespace std;
long long r,c,m,a[3005][3005],dp[3005][4];//记得要开long long! 
int main(){
	cin>>r>>c>>m;
	for(long long i=1;i<=m;i++)
	{
		long long x,y,z;
		cin>>x>>y>>z;
		a[x][y]=z;
	}//输入部分结束!
	for(long long i=1;i<=r;i++)
	{
		for(long long j=1;j<=c;j++)
		{
			for(long long k=1;k<=3;k++)
			{
				dp[j][k]=max(dp[j][k],dp[j][3]);
				dp[j][k]=max(dp[j][k],dp[j-1][k-1]+a[i][j]);
				dp[j][k]=max(dp[j][k],dp[j-1][k]);
			}
		}
	}//状态转移部分结束! 
	cout<<dp[c][3]<<endl;
	return 0;
}

```
代码不要直接抄袭哦，内有一坑，小心变棕 QWQ。
