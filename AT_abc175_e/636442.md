### 题目大意

给一个 $R$ 行 $C$ 列的地图，每次只能向下或向右移动，可以拾取地上的物品，价值为 $v_i$，且每行最多只能捡 $3$ 个物品。

### 难点

>每行最多只能捡 $3$ 个物品。

如果去掉这句话，就变成了一道简单 DP 题。

而本题的核心就是，如何处理这个条件？

答案非常直接：升维！

### DP 四大重点

#### 状态表示

```
long long dp[3005][3005][4];
```
我们设 $dp_{ijk}$ 表示在第 $i$ 行 $j$ 列，这一行已经捡了 $k$ 个物品，此时高桥君可获得的的最大价值。

其中，$i$ 和 $j$ 作为地图边长，最大值取 $3000$，而 $k$ 作为记录这一行已经捡了的物品物品数量，最大取 $3$。

**小坑**：$k$ 在定义数组时要取 $4$！

**小坑**：因为数据范围比较大，所以请开`long long`谢谢。

#### 状态初始化

```
memset(dp,0,sieof(dp));
```

因为 $dp$ 数组是用来存最大价值的，所以初值为 $0$，也可以直接定义为全局变量自动清零。

#### 状态转移

应该有三种转移方式，不是四种！！！

有很多人可能纳闷了，为什么不是四种？

首先，我们来看看四种是怎么来的：

|  | 从上来 | 从左来 |
| :----------: | :----------: | :----------: |
| 捡东西 | 从上来捡东西 | 从左来捡东西 |
| 不捡东西 | 从上来捡不东西 | 从左来捡不东西 |

到底那个不对呢？

这是一个不辣么难的逻辑问题，请自行思考再往下翻。

答案是 $3$ 不对。

为什么？因为你从上来，所以这是你遇到的第一个格子（如果这个格子没有物品，请脑补一个价值为零的物品）。

而这样的话，你的每行最多只能捡 $3$ 个物品的限制没有了，那你为什么不去捡呢？

所以我们来看三种情况的状态转移方程：

1. 从上来捡东西

`dp[i][j][k] = dp[i-1][j][3]`

你从上来，所以横坐标减一，你上面一行捡了 $3$ 个物品的价值肯定比没捡到 $3$ 个物品要大。

2. 从左来捡东西

`dp[i][j][k] = dp[i][j-1][k-1]+a[i][j]`

你从左来，所以纵坐标减一，你这一行现在捡的是第 $k$ 个物品，所以前一个捡了 $k-1$ 个物品。

**小坑**：别忘了加上这个物品的价值。

3. 从左来捡不东西

`dp[i][j][k] = dp[i][j-1][k]`

你从左来，所以纵坐标减一，你不捡东西，所以就只改变了坐标。

以上三种取最大即可。

```
dp[i][j][k] = max(dp[i-1][j][3]+a[i][j],max(dp[i][j-1][k],dp[i][j-1][k-1]+a[i][j]));
```

### 结果

当高桥君走到 $R$ 行 $C$ 列时，他肯定要拿走尽量多的物品，所以他应该在这一行拿走 $3$ 个物品时最好，也就是$dp_{RC3}$。

```
printf("%lld",dp[r][c][3]);
```

### 代码（请勿抄袭）：
```cpp
#include<cstdio>
#include<algorithm>
using namespace std;

int r,c,num,a[3005][3005];
long long dp[3005][3005][4];

int main()
{
	scanf("%d %d %d",&r,&c,&num);
	for(int i=1;i<=num;i++)
	{
		int x,y,v;
		scanf("%d %d %d",&x,&y,&v);
		a[x][y] = v;
	}
	
	for(int i=1;i<=r;i++)
		for(int j=1;j<=c;j++)
			for(int k=1;k<=3;k++)
			{
				//从上或左来，捡不捡东西
				dp[i][j][k] = max(dp[i-1][j][3]+a[i][j],max(dp[i][j-1][k],dp[i][j-1][k-1]+a[i][j]));
			}
	printf("%lld",dp[r][c][3]);
	return 0;
}
```

### 优化

请注意：上面不是正解！

为啥捏，因为有一句名言：

>代码可以受委屈，但你不能踩我的内存上线！

空间爆了。

为啥捏，因为 $dp$ 数组的大小是 $3000 \times 3000 \times 3 = 27000000$，超越内存上线（但数据好像有点水，这都能过）。

所以我们要尝试压缩维度。

我们可以发现，在棋盘动规中，大部分情况只和左边和上边有关，可以直接滚动数组优化掉第一维。

这题直接强行把所有的 $i$ 维度删去，保留 $j$ 和 $k$ 两个维度即可。

### 正解：
```cpp
#include<cstdio>
#include<algorithm>
using namespace std;

int r,c,num,a[3005][3005];
long long dp[3005][4];

int main()
{
	scanf("%d %d %d",&r,&c,&num);
	for(int i=1;i<=num;i++)
	{
		int x,y,v;
		scanf("%d %d %d",&x,&y,&v);
		a[x][y] = v;
	}
	
	for(int i=1;i<=r;i++)
		for(int j=1;j<=c;j++)
			for(int k=1;k<=3;k++)
			{
				//从上或左来，捡不捡东西
				dp[j][k] = max(dp[j][3]+a[i][j],max(dp[j-1][k],dp[j-1][k-1]+a[i][j]));
			}
	printf("%lld",dp[c][3]);
	return 0;
}
```

##### 点个赞再走呗
##### 管理员求过！