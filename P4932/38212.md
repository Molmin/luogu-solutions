对于两个二进制数的某一位，

若这两个数都是零，则它们异或后的数是零

若这两个数都是一，则它们异或后的数是零

若这两个数中有一个一，则它们异或后的数是一

#### 所以，当两个二进制数的某个数位都是1的时候，它们的异或值会同时消掉这两个1，变成0.

#### 可以推得，

若某两个二进制数，这两个二进制数的数位 含'1'的个数 都是偶数或者都是奇数，则它们异或之后的值得二进制数位中含‘1’的个数也是偶数

若某两个二进制数，其中一个二进制数的数位中含‘1’的个数是偶数，另一个含‘1’的个数是奇数，则它们异或后含‘1’的个数是奇数

### 所以，对于两个二进制数来讲， 它们含‘1‘的数量之和的奇偶性 与 它们异或结果含’1‘的数量奇偶性 是一样的。

因此，若我们统计出统计出来这$n$个数中，含’1‘数量为奇数的数有$x1$个，含’1’数量为偶数的有$x2$个，则$x1*x2$就是答案。

接下来的问题是，对于一个数t来讲，如何快速统计出t在二进制下含有几个'1'数位？

log t的做法是显然的（逐个二进制位统计），但更好的统计方法是NOIP2018初赛中考过的方法：

```cpp
while(x)
{
    if(x%2)
    	sum++;
    f[i]=(f[i]&(f[i]-1));
}
```

所以最终的时间效率是$O(n*logv)$，但不是满的，可以过掉1500ms。

```
#include <iostream>
#include <cstdio>

#define int long long

using namespace std;

const int maxn=1e7+3;

int f[maxn];
int n,a,b,c,d,x0;
int ansj,anso; //ansj: 含有奇数个'1'的数的个数
			   //anso: 含有偶数个'1'的数的个数

signed main()
{
    cin>>n>>a>>b>>c>>d>>x0;
    f[0]=x0;
    for(int i=1;i<=n;i++) 
    {
        f[i]=(((long long)(f[i-1]))*f[i-1]%d*a%d+((long long)(f[i-1]))*b+c)%d;
    }
    for(int i=1;i<=n;i++)
    {
    	int sum=0;
    	while(f[i])
    	{
    		if(f[i]%2)
    			sum++;
    		f[i]=(f[i]&(f[i]-1));
        }
        if(sum%2) ansj++;
        else anso++;
    }
    cout<<ansj*anso<<endl;
    return 0;
}
```
记得开long long，我就是因为没开long long比赛的时候被卡成65分QwQ