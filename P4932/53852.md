## 凭良心说 这道题算是这次月赛中很简单的一道题了~~(我也不知道这道题为什么是蓝题...)~~

### 首先我们先看题面你发现是x[u] xor x[v] 在二进制下有多少个1 

那么我们想想异或有什么特征

它相当于是一个**二进制下不进位的加法**.

那么它在二进制下有什么特征呢,接下来我带你来看看.

例如x[u] =15 x[v]=21的情况

15、21在二进制下表示为

15: 0 0 1 1 1 1   有4个1

21: 0 1 0 1 0 1   有3个1

异或后得

26: 0 1 1 0 1 0   有3个1

### 然后你发现

(1). 若某一位上有两个1,则这两个1变为0 两个数字二进制下1的个数的和减去2

(2). 若某一位上一1个一个0,则什么都不会发生

(3). 若某一位上有两个0,则什么都不会发生

#### 然后两个数字二进制下1的个数的和好像奇偶是不会变的.

#### 而这就跟异或出来的数字二进制下1的个数一样

所以呢就将x[u]与x[v]二进制下的1的个数加起来算它的奇偶性就行了.

那么思路有了,可现在怎么实现呢?

这个很简单.

因为小学时学过**奇数+奇数=偶数**  . **偶数+偶数=偶数**  .  **奇数+偶数=奇数** 

所以只有当一个二进制下的1的个数为奇数另一个为二进制下的1的个数为偶数时就行了.

这样就可以用两个数 来存**二进制下的1的个数为奇数与二进制下的1的个数为偶数的数**

最后再把两个数相乘就好啦.

```
#include<bits/stdc++.h>
using namespace std;
long long x,a,b,c,d,n,tmp;
inline int getnum(int zz)
{
    tmp = 0;
    while(zz)
    {
      ++tmp;
      zz ^= (zz & (-zz));//这里大家都懂吧zz & (-zz)是为了求出末尾的1					  
                         //再用异或将这个1去掉.
    }
	return tmp;
}
long long sum1,sum2,tot[2];
int main()
{
	cin>>n>>a>>b>>c>>d>>x;//输入
	a%=d,b%=d,c%=d,x%=d;  //先%一遍害怕爆炸
	long long y;
	for(int i=1;i<=n;i++)
	{
		++tot[getnum(x = ((a * x % d ) * x % d +b * x % d + c) % d) & 1];
       //这里意思是讲当前1的个数求出在&1判断奇偶,在加到tot里面就行了
	}
	printf("%lld",tot[0]*tot[1]);
	return 0;
}
```

## 正文内容讲解结束以下是瞎扯淡环节

### 然后就是对于关于一个数1的个数有很多种求法

#### 就如同今年noip提高初赛10题的求法
```cpp
long long p=y;
 while (p)
{
    cnt++;
	p&=(p-1);//这个意思是去掉最后一位1.
}
```

#### 也有比较暴力的
```cpp
long long cnt=0;
for(int i=34;i>=;i--)
{
	if(d&(1<<i)) //判断二进制下的i为是否为1
	{
		cnt++;
	}
}
```

#### 但这样子的话常数比较大,所以不建议使用.

#### 最近看到一种神奇的函数是__builtin开头的函数,其中有一个就可以直接求解此问题
```cpp
int n = 15;//二进制为1111
int m = 7;//111
cout<<__builtin_parity(n)<<endl;//偶数个，输出0
cout<<__builtin_parity(m)<<endl;//奇数个，输出1
```
#### 但是noip好像不能用__开头的函数所以大家还是别冒险去试

##  写在最后

### 位运算真是个神奇的东西,希望大家可以多多探究一下其中的奥秘,很有意思的(逃).

## 最后抛一道类题就跑

### 【问题描述】 

#### X3 星球的外星人名字都是一个正整数，而且他们都互相认识。

#### 任意两个外星人的友谊度 都是他们名字的异或值。整个星球的友好值等于所有友谊度之和。

#### 求这个星球的友好值是多少

#### 1<=人数<=1e6

#### 提示一下,也是用异或的性质来做哦.

#### 有什么问题欢迎指出