关于此题总结一些求**二进制下1的数量的奇偶性**的方法

1. 暴力求解 $O(\log n)$

	```cpp
    while(x)
    {
        cnt += x&1;
        x >>= 1;
    }
    ```
    由于数据的随机性导致算法难达到上界,所以能水过
    
    ---
    
2. 利用 $bitset$
	
    count函数返回1的位数

	```cpp
    bitset<32> tmp(x);
    sum[tmp.count()&1]++;
    ```
    效率应该和以下几种相同
    
    > *摘自洛谷日报* [二进制与位运算](https://www.luogu.org/blog/chengni5673/er-jin-zhi-yu-wei-yun-suan)
    
    > **bitset 的复杂度**：因为bitset是用 uint/long long 类型来实现每次同时操作 32/64 个 01 变量的东西，所以他的很多操作都是 O(1) 或 O(n/32) / O(n/64) 的。至于是 32 还是 64 ，一般看机器是32位还是64位
    
    ---
    
3. 神奇的函数

	```cpp
    __builtin_parity(x)
    ```
    返回一个数二进制下1的数量的奇偶性
    
    ```cpp
    __builtin_popcount(x)
    ```
    返回一个数二进制下1的数量
    
    ---
   
4. 打包位统计$O(1)$

	*参考李博杰的《骗分导论》 P21*
    
    因为__开头的函数在NOIP不好用
    
    ```cpp
    inline int popcount(unsigned x)
    {
        x ^= x>>1; x ^= x>>2;
        x ^= x>>4; x ^= x>>8;
        x ^= x>>16;
        return x&1;
    }
    ```
    
    神奇的位运算处理后 运算结果的第 i 位表示在原始数据中从第 i 位到最高位 true 数目的奇偶性
    
    原理是这样的
    
    首先我们知道 **异或^** 的性质
    
    在二进制的世界里(只有0,1),任何数异或1取反,任何数异或0不变
    
    所以我们把x的二进制的每一位异或起来,结果是0说明x二进制有偶数个1,结果是1说明x二进制有奇数个1
    
    那么再看算法 我们把x(假设是unsigned)看成二进制数 x[32],在来一个a[32]表示位运算后的结果
    
    ```cpp
    第一步:x^=x>>1,此时有
    a[32] = x[32]^x[33] // 32-33位的奇偶性,x[33]是0,不影响
    a[31] = x[31]^x[32] // 31-32位的奇偶性
    ...
    a[1] = x[1]^x[2]    // 1-2位的奇偶性
    
    第二步:x^=x>>2,此时有
    a[31] = (x[31]^x[32])^a[33]
          = (x[31]^x[32])^(x[33]^x[34]) // 31-34位的奇偶性
    a[30] = (x[30]^x[31])^a[32]
          = (x[30]^x[31])^(x[32]^x[33]) // 30-33位的奇偶性
    ...
    懒得打了
    ```
    
    总之,能看懂吧...
    
    所以最后 运算结果的第 i 位表示在原始数据中从第 i 位到最高位 true 数目的奇偶性
    
    得知原理之后我自行编写了一个模板
    
    ```cpp
    template <typename T> inline unsigned popcount(T x)
    {
    	// 用sizeof求出该类型占用的字节数,每个字节是8bit
        for(unsigned i = 1; i < sizeof(T)*8; i <<= 1)
            x ^= x>>i;
        return x&1;
    }
    ```
    当然稍加变形,可以还求出二进制下某段区间的奇偶性
    
    ---
    
    再来个 统计1的数目
    
    ```cpp
    int count(unsigned int x)
    {
        x=(x&0x55555555)+(x>>1&0x55555555);
        x=(x&0x33333333)+(x>>2&0x33333333);
        x=(x&0x0F0F0F0F)+(x>>4&0x0F0F0F0F);
        x=(x&0x00FF00FF)+(x>>8&0x00FF00FF);
        x=(x&0x0000FFFF)+(x>>16&0x0000FFFF);
        return x;
    }
	```
    
    ---
    
### 总结

方法1最简单,而且也能过,效率最慢

方法2,3,4效率相同,应该都是O(1)

(本人O2下实测差距在20ms之内https://www.luogu.org/recordnew/lists?uid=53116&pid=P4932)

方法3在竞赛中可能行不通,而且要不是题解里许多大佬指出,我压根不知道有这玩意儿

方法4...你若理解,那便安好

所以方法2是妥妥的最合适蒟蒻我的啦