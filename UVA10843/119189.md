题目大意：给定一个n个节点的完全图，求生成树的个数。



结论题，知道prufer序列1分钟内AC，不知道几个星期都A不掉。

prufer序列：
将一颗n个节点的树压缩成一个n-2长度的序列，这个序列包含了每个节点的度数的信息。

由前人们的经验可以知道，prufer序列与无根树一一对应，互相映射。

**1.树转prufer**

找到所有树上编号最小的**叶子**节点，将其父亲加入prufer序列，一共进行n-2次如上操作，标准复杂度$O(n^{2})$；

如果我们使用堆，可以做到$O(nlogn)$;

如果我们动点脑子，可以做到$O(n)$；
大体来说：指针指向编号最小的叶节点。每次删掉它之后，如果产生了新的叶节点（如果产生一定是原叶子节点的父亲）且编号比指针指向的更小，则直接继续删掉，否则自增找到下一个编号最小的叶节点。易证正确。

**2.prufer转树：**

取出prufer序列中最前面的元素x，然后寻找一个在点集（一开始是全集{1,2,...,n}）中，但不在prufer序列中的编号最小的一个点y，把y从点集中删除，并连接点x和点y，重复以上行为n-1次，这棵树我们就跟他说拜拜了~，标准复杂度$O(n^2)$

如果我们使用堆，可以做到$O(nlogn)$;

如果我们动点脑子，可以做到$O(n)$；

大体来说：指针指向编号最小的不在prufer序列（这代表着这个点的度数为1，不懂的一会看下面）中的点。每次删掉它之后，如果他的父亲节点的度数也是1且编号比指针指向的更小，则直接继续删掉，否则自增找到下一个编号最小的度数为1的节点。易证正确。


由此，prufer序列的特性呼之欲出：

**1.prufer序列与无根树一一对应；(由每次找最小的编号的点得到这个性质)**

**2.prufer序列中某个编号出现的次数就等于这个编号的节点在无根树中的度数-1 (由树转prufer的过程得知)**

**3.n个点的完全图所构成的生成树的计数,就是n^(n-2)；**

(证明：一个n个节点的树，它的prufer序列的长度是n-2，每个位置有n种选择)

```cpp
#include <bits/stdc++.h>
using namespace std;
#define p 2000000011
long long KSM(long long a,long long b){
	long long res=1;
	while(b){
		if(b&1) res=res*a%p;
		a=a*a%p;
		b/=2;
	}
	return res%p;
}
int main(){
	int n; cin>>n;
	for(int i=1;i<=n;i++){
		int x; scanf("%d",&x);
		printf("Case #%d: %lld\n",i,KSM(x,x-2));
	}
}
```



综上所述，prufer可以优美的解决大部分有关树度数计数问题。