# 思路
  其实将题意翻译一下就是，给你一列数，找出里面符合2倍关系的个数。
           
      比如1 3 4 7 9 2 18，那么答案便为3.很显然是（1与2）（2与4）（9与18）。。
 我们粗略地看一眼数据：每个数的绝对值小于等于10000！那貌似可以用桶做吧，将每个数当做下标存入数组，当判断时只需要判断以某数2倍为下标的数组是否存在即可。(f[2*a[i]]==1)
   
   最后还需要注意一点，就是负数的情况，因为肯定大于-10000嘛~，所以同时加上10001即可，不会影响最后的结果。
   
------------

# 代码
 ```cpp
#include<bits/stdc++.h>//万能头
using namespace std;
int f[20010],a[2000],n,i,m,ans;
int main() 
{
    scanf("%d", &n);//读入数据
    for(int j=1;j<=n;j++)
    {
        ans=0;
        scanf("%d",&m);
        for(i=1;i<=m;i++)
        {
            scanf("%d",&a[i]);
            f[a[i]+10001]=1;
        }//用下标统计每一个数字
        for(i=1;i<=m;i++)
        {
            if(a[i]>5000 || a[i]<-5000) continue; 
            if(f[2*a[i]+10001]) ans++; //判断它的两倍是否存在，存在即+1
        } 
        memset(f,0,sizeof(f));//数组清零
        printf("%d\n", ans);//输出
    }
    return 0;//本人亲测可过quq
}//偶然的瞬间，你会意识到某些东西早已不像以前。在与他人接触的时候，总会无意地在心底思考，默默地质问自己“这样做是对的吗？”
```
