这道题是lrj讲kmp算法时候的例题, 所以用kmp是必须的了. 但是他在正确性这一块讲得很模糊, 好像才两三行就略过了(当然也可能是我太菜无法理解). 所以我想来尝试较为严谨地证明一下这个做法的正确性.



先做几个约定: 以下的大写英文字母均表示字符串, 本篇中字符串下标均从 0 开始.令 $i > 0$ . $S + i - 1$ 表示字符串S的前缀 $S_0$ 到 $S_{i - 1}$ , 容易看出这个前缀长度为 $i$ .若有一个长度不超过 $i$ 的字符串的集合, 使这个集合中的每一个元素既是 $S + i - 1$ 的前缀, 又是它的后缀, 记这个集合为 $Ω$ , 那么这个集合中长度最长的元素即为 $S + f_i - 1$ , 长度为 $f_i$ . 我们称 $f_i$ 为这个子串 $S + i - 1$ 的前缀数组(学过kmp算法的应该能理解这个定义). 显而易见 $f_i ≥ 0$ . 另设最大循环次数为 $k$ . 定义 $n * X$ 表示 $X$ 字符串重复了 $n$ 次, $X + Y$ 表示在串 $X$ 后接上串 $Y$ , $X.length()$ 表示 $X$ 的长度.



引理1: 对于一个前缀 $S + i - 1$ , 若 $f_i = 0$ , 则不存在 $k > 1$ 的循环元.

证明: 反证法. 若存在一个循环元 $A$ , 使得 $k >  1$ , 那么一定存在一个 $f'_i = A.length()$ , 使得 $S + f'_i - 1 \in Ω$ , 矛盾, 所以原命题成立.



引理2: 对于一个前缀 $S + i - 1$ , 若存在最短循环元 $A$ , 则 $A.length() ≥ i - f_i$ 

证明: 反证法. 若原命题不成立, 则 $A.length() < i - f_i$ , 即 $i - A.length() > f_i$ . 由于 $A$ 是循环元, 那么一定存在一个 $f'_i = i - A.length()$ , 使得 $S + f'_i - 1 \in Ω$ . 又 $f'_i > f_i$ , 矛盾, 所以原命题成立.



根据引理1, $f_i = 0$ 时无解, 所以接下来我们讨论 $f_i ≠ 0$ 的两种情况.



我们首先证明: 对于一个前缀 $S + i - 1$ , 若有 $i \ \text{mod}\ (i - f_i) = 0$ , 那么存在一个最小的长度为 $i - f_i$ 的最小循环元 $S + i - f_i - 1$ , 我们把它记作 $A$ .

证明分两部分, 先证明在上述条件下 $A$ 是一个循环元.

我们令 $j = \frac{i}{i - f_i}$ , 那么可以将 $S$ 划分成 $j$ 个部分, 记这 $j$ 个部分依次为 $D_0, D_1, D_2, ..., D_{j - 1}$ , 其中 $D_0 = A$ . 由于 $S + f_i - 1 \in Ω$ , 那么 $D_0 = D_1 = D_2 = ... = D_{j - 1} = A$ , 所以 $A$ 是一个循环元.

再证明 $A$ 为长度最短的循环元. 由引理2, 因为 $A.length() = i - f_i$ , 所以 $A$ 为长度最短的循环元.



接着我们看到第二种情况, 对于一个前缀 $S + i - 1$ , 若 $i \ \text{mod}\ (i - f_i) ≠ 0$ , 可以证明不存在 $k > 1$ 的循环元.

若这样的最短循环元 $A$ 存在, 由引理2可得 $A.length() >= i - f_i$ . 再由于 $i \ \text{mod}\ (i - f_i) ≠ 0$ , 因此 $A.length() ≠ i - f_i$ . 所以 $A.length() > i - f_i$ .

令串 $S + i  - f_i- 1 = B$ , 并令 $A = B + C$ , 由上述证明可得 $C$ 必存在且非空. 那么由于 $S = k * A$ , 则 $S = k * (B + C) = B + (k - 1) * (C + B) + C$ . 又由于 $S + i  - f_i- 1 = B$ , 取该表达式的后缀, 可得 $S = (k - 1) * (C + B) + C + X$ , 其中 $X.length() = B.length()$ . 因为 $(B + C).length() = (C + B).length()$ , 所以 $B + C = C + B$ 且 $B + C = C + X$ , 于是可得 $C + B = C + X$ , 因此 $B = X$ . 即 $S = k * (B + C) = k * (C + B)$ . 取前一表达式的后缀与后一表达式的前缀, 由于 $S + f_i - 1 \in Ω$ , 可得 $S + f_i - 1 = (k - 1) * (C + B) + C = (k - 1) * (B + C) + B$ , 又因为 $C +  B = B + C$ , 可以得出 $B = C$ .

因此一定可以找到比 $A$ 更短的循环元 $B$ , 与假设 $A$ 最短矛盾, 所以不存在最短循环元, 即不存在循环元.



综上所述, 当且仅当 $ f_i > 0 \ \&\&\  i \ \text{mod}\ (i - f_i) = 0$ 时存在循环元, 且最短循环元长度为 $i - f_i$ , 循环次数 $k = \frac{i}{i - f_i}$ .



在这个证明中我大量使用了反证法, 并且定义了一些符号, 可能需要仔细看. 中间有一些推导过程需要对kmp性质较为熟悉, 然后就会发现还是比较明显的. 第一次写这样的证明过程, 好激动啊! 当然我没经过什么专业训练, 要是有啥问题就请指出哈.

以下是代码, 其实就是结论 + kmp前缀数组的模板.

```cpp
#include<iostream>
using namespace std;

int f[1000007];
int main(){
    ios::sync_with_stdio(false);
    int t, n;
    string s;
    cin >> t;
    for(int h = 1; h <= t; ++h){
        cout << "Test case #" << h << "\n";
        cin >> n >> s;
        f[0] = f[1] = 0;
        for(register int i = 1; i < n; ++i){
            int j = f[i];
            while(j && s[j] != s[i])
                j = f[j];
            f[i + 1] = s[i] == s[j] ? j + 1 : 0;
        }
        for(int i = 2; i <= n; ++i){
            if(f[i] && i % (i - f[i]) == 0){
                cout << i << " " << i / (i - f[i]) << "\n";
            }
        }
        cout << "\n";
    }
    return 0;
}
```

