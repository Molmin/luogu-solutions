kmp算法的简单题。

这道题没有什么难点，唯一需要注意的是输出的格式问题（上午在学校做的时候错了好久qwq）

如果不知道什么是KMP算法，大概总结一下就是：用来查找一个主串 $A$ 里模式串 $B$ 出现了几次。虽说它也是从左往右遍历，但 $i$ 的值不用回退，只需改变 $j$ 的值就好了。

~~还是听不懂咋办~~

说简单点，查找永远只会向前查找，不会后退。

再来看这道题。

~~原谅蒟蒻不会证明~~，对于第 $i$ 次循环，首先需要满足条件 $i\mod i-next_{i}$，如果满足，循环节长度为 $i-next_{i}$，循环次数即为 $\frac{i}{t-next_{i}}$。

注意：循环节的循环次数必须大于2。

所以这道题只需要在kmp算法的模板上稍加修改。

核心代码如下：
```cpp
    scanf("%lld",&n);
    scanf("%s",s+1);
    printf("Test case #%lld\n",++tot);
    next[1]=0;//初始化
    for(i=2;i<=n;i++){
        while(s[i]!=s[j+1]&&j) j=next[j];
        if(s[i]==s[j+1]) j++;
        next[i]=j;//模板
        if(next[i]&&i%(i-next[i])==0) 
            printf("%lld %lld\n",i,i/(i-next[i]));//刚刚所说的结论
    }
    printf("\n");
```
