昨天植树节但是是周日，今天补上。

由于这个加点实在是太弱了，所以首先以 $B$ 为块长划分成若干簇，然后可以划出来顶多 $2\frac nB$ 个界点，每次加点的时候如果当前簇大小超过 $2B$ 那么就把当前簇的重心再划成一个界点，然后再加一个界点来保证分开的东西是个簇，然后把当前簇内的信息分到各个新簇中，这样簇大小总小于等于 $B$，界点个数最多为 $2\frac nB+2\frac mB$，暴力划分次数至多为 $B$。

然后看看要维护什么东西，链加链排名强制在线值域乱飞，这个放到序列上也是一个十分重量级的玩意，所以复杂度做到类 $O(m\sqrt{n\log n})$ 即可。

（听说可以分散层叠？不会那个东西。）

由于每个簇两端最多两个界点，所以把每个簇内维护的点分成两种，界点之间路径上的点和其他点，查询的时候两端的簇直接暴力查询，中间的簇只会涉及到前面那种点，在按权值排好序的数组上二分，可以做到 $O(mB+m\frac nB\log B+m\frac mB\log B)$。

每次修改两端的簇直接重构，内部的簇只会改前面那种，然后界点总共才那么多所以涉及到的簇顶多 $O(\frac nB+\frac mB)$ 个，打标记即可，复杂度 $O(mB+m\frac nB+m\frac mB)$，当然重构的时候要写由乃打扑克的那个把数组分开再归并的优化。

加点要插入，但是一个插入只会影响一个簇，直接插入维护的数组就行，复杂度 $O(mB)$。

然后簇分裂，就是上面的第一句话里的簇重构，这个由于会有原先不在界点中的点变成界点中的点，意味着还要在之前维护一个每个簇中不在界点中的点的排名数组，当然你可以直接排序不会影响到最后的那个根号，复杂度 $O(B^2)$。

注意一下界点也是点，而且不在任何簇内，但是它们暴力维护就行。

初始化的时候至少要排个序，复杂度 $O(n\log n)$。

具体实现时可以始终维护原树形态，由于两个界点的 `lca` 仍是一个界点（要求根节点为界点），所以每个界点只用存它在收缩树上的父亲，不用维护整棵收缩树的形态。

但是这样的话询问时要知道每个界点的深度，如果上面没有维护整棵收缩树的形态的话这个是不能在重构时直接求的，不过可以记忆化搜索，每次求完深度的时候把结果记下来，顺便记一下当前界点个数，这样重构时就不需要直接改这个记忆化数组了。

对于每个点记录一下在哪个簇里以及它是否在两个界点间，对于界点记录它父亲在哪个簇里，特殊地给根的父亲找个虚簇方便讨论，每个簇还要存它下面的界点（也可以没有）和上面维护的两个数组。

复杂度 $O(B^2+n\log n+mB+m\frac nB\log B+m\frac mB\log B)$，让后面那个 $m\frac mB\log B$ 假装被 $m\frac nB\log B$ 吞了，$B=\sqrt{n\log n}$ 可以做到 $(n\log n+m\sqrt{n\log n})$。

（但是事实上 $B$ 取 $\sqrt n$ 跑得飞快，取 $B=\sqrt{n\log n}$ 会 `T` 成狗，谔谔）

（可能是两边常数过于不均衡导致的。）

（此题目前是我历史码量榜一，直接怒码四百五十行共 `11.25KB`。）

[代码。](https://www.luogu.com.cn/paste/orbyiqm2)
