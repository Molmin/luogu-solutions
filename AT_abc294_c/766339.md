**题意**

给你两个长度分别为 $n,m$ 的严格上升数列 $a,b$，保证无任何两元素相等，请你将它们混合起来从小到大排序，并按输入顺序输出它们排序后的位置。

**分析**

这题有一个关键的突破口，可以使代码复杂度降到 $O(n+m)$，那就是「严格上升数列」，这说明对于 $a,b$，我们并不需要排序，只需要对每个 $a_i,b_j(1\le i\le n,1\le j\le m)$ 比大小，然后我们又知道 $a_i<a_{i+1},b_j<b_{j+1}(1\le i< n,1\le j< m)$，所以如果有 $a_i<b_j$，那么有 $a_i<b_{j+1}$；同理如果有 $a_i>b_j$，那么有 $a_{i+1}>b_j$。至此代码整体思路就完成了，接下来讨论实现问题。

从思路中“对 $a_i,b_j$ 比大小”一段，不难想到指针。因此我们可以把题意变成标记每个数的位置，定义变量 $k$，表示当前标记到第 $k$ 个大小。接下来定义两个指针 $pa,pb$，分别指向 $a,b$ 中的元素，也就是当前比较目标。对于每一次比较，我们只需要让对应数组的指针推后一位，然后 `k++` 即可，总复杂度 $O(n+m)$，对 $1\le n,m\le 10^5$ 的数据范围绰绰有余。

**AC Code**
```
#include <iostream>
using namespace std;
int a[int(1e5+10)][3],b[int(1e5+10)][3];//a[i][1]与b[i][1]表示对应数据，a[i][2]与b[i][2]表示该数据排序后的位置
int main()
{
	for(int i=1;i<=int(1e5+1);i++)
	{
		a[i][1]=1e9+1;
		b[i][1]=1e9+1;
	}//记得赋无穷大值，否则一旦pa,pb越界就死循环了
	int k=1,pa=1,pb=1,n,m;
	cin>>n>>m;
	for(int i=1;i<=n;i++) cin>>a[i][1];
	for(int i=1;i<=m;i++) cin>>b[i][1];
	while(k<=n+m)
	{
		if(a[pa][1]<b[pb][1])
		{
			a[pa][2]=k;
			pa++;
			k++;
		}
		else
		{
			b[pb][2]=k;
			pb++;
			k++;
		} 
	}//标记部分
	for(int i=1;i<=n;i++) cout<<a[i][2]<<' ';
	cout<<endl;
	for(int i=1;i<=m;i++) cout<<b[i][2]<<' ';
	return 0;
}
```
