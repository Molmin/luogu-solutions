小朋友可以向任意一边传递糖果，不好模拟，于是我们规定，他们仅能向右边传递。

定义 **n** 为小朋友人数，**p** 为平分所用的代价，**c[i]** 为每个小朋友现有的糖果数目，**t** 为目标数目，**s[i]** 为每个小朋友需要传递的数目，故得：


    	s[i] = c[i]+s[i-1]-t
    	 特殊地，s[0] = c[0]+s[n-1]-t
  	 	传递到i-1时传递必然结束，此时可以看作在i与i-1之间切开，形成一条线。
 		 p为所有|s[i]|之和。

如果从k左端断开，此时p为**从k开始传递糖果的代价**，特别地，s[k] = c[k]-t。因为这是环，所以每一个人都可能为k，所以我们要求的，就是k个p中最小的一个p。

令k=i，此时s[i]=c[i]-t，s[i+1]=c[i+1]+s[i]-t，s[i+2]=c[i+2]+s[i+1]-t;
令k=i+1，此时s[i+1]=c[i+1]-t，s[i+2]=c[i+2]+s[i+1]-t;

### 我们可以看到，对k取不同的值，得到的s[i]之差等于s[k]。所以，最终p为所有|s[i]-s[k]|之和的最小值。

我们可以把所有s[i]标在一条数轴上，就变成了在数轴上的点中找一个点，使它到其他点的距离之和最小。（|a-b|的几何意义是a到b的距离）

当这个点在最中间两个点中间时（或一个点），距离最小，且为两边对应的点距离之和

以下是代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,p,t,mid,c[1000005],s[1000005]; 
int main(){
	scanf("%lld",&n);
	for(int i = 0;i < n;i++){
		scanf("%lld",&c[i]);
		t += c[i];
	}
	t /= n;
	s[0] = c[0]-t;
	for(int i = 1;i < n;i++)
		s[i] = c[i]+s[i-1]-t;
	sort(s,s+n);
	for(int i = 0;i < n/2;i++)
		p += s[n-1-i]-s[i];
	printf("%lld",p);
	return 0;
}
```

