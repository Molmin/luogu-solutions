现说点别的(雾  
与本题解法有关
# 仓库选址
>描述  
在一条数轴上有N家商店，它们的坐标分别为 A[1]-A[N]。现在需要在数轴上建立一家货仓，每天清晨，从货仓到每家商店都要运送一车商品。为了提高效率，求把货仓建在何处，可以使得货仓到每家商店的距离之和最小。  
输入格式  
第一行一个整数N，第二行N个整数A[1]-A[N]。  
输出格式  
一个整数，表示距离之和的最小值。  
样例输入  
4  
6 2 9 1  
样例输出  
12  
数据范围与约定  
对于100%的数据: N<=100000, A[i]<=1000000
 
这道题的答案其实就是所有点距离的中位数  
我们来证明一下  
假设我们所有点中距离中位数的点是k  
那么答案就是$\sum_{i=1}^n(a[i]-a[k])$  
假设有另外一个点比它更优，这个点为q  
那么我们一定可以通过平移点k来得到点q  
假如我们平移U点，U点左边有left个点，右边有right个点,那么右移后新的答案会加left乘平移距离，减right乘平移距离，左移后新的答案会加right乘平移距离，减left乘平移距离
若需将k左移则必定有left>right那么必定k点比q点更优，右移同理    
综上，答案就是所有点距离的中位数   

# 本题其实就是环形均分纸牌
>题目描述
有n个小朋友坐成一圈，每人有ai个糖果。每人只能给左右两人传递糖果。每人每次传递一个糖果代价为1。  
输入格式  
小朋友个数n 下面n行 ai  
输出格式  
求使所有人获得均等糖果的最小代价。  
输入输出样例  
输入  
4  
1  
2  
5  
4  
输出  
4    

我们考虑环形均分纸牌可以进行破环成链，那么一个环就有环上点个数种情况(可以从任意点断开)  
用a表示减去平均数之后的纸牌数量，s表示对a的前缀和  
假设从k处断开，那么这个环就断成了一条链  
…………………………  
a[k+1] s[k+1]-s[k]   
a[k+2] s[k+2]-s[k]  
…………………………  
a[n]  s[n]-s[k]  
a[1]  s[1]+s[n]-s[k]  
…………………………  
a[k]  s[k]+s[n]-s[k]  
因为此处a数组已经减去平均数了，所以s[n]=0  
也就是说，答案是$\sum_{i=1}^n(s[i]-s[k])$  
此时我们只要找到最小的k就可以了，我们发现现在的情况和前面提到的货仓选址问题一模一样  
所以k就是s数组的中位数  
```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;
#define ll long long
ll n;
ll a[5000050],s[5000050];
ll abss(ll x)
{
    if(x>0)return x;
    else return -x;
}
int main()
{
    scanf("%d",&n);
    ll pjs=0;
    for(int i=1;i<=n;i++)scanf("%lld",&a[i]),pjs+=a[i];
    pjs/=n;
    for(int i=1;i<=n;i++)s[i]=s[i-1]+a[i]-pjs;
    sort(s+1,s+n+1);
    int k=n/2;
    ll answer=0;
    for(int i=1;i<=n;i++)answer+=abss(s[i]-s[k]);
    printf("%lld",answer);
    return 0;
}
```