# 思路

## 过程$1$

根据题意可得，当硬币左右两端都是$0$时，这一轮的玩家必输。再扩展一下，可以得出下图。

![](https://cdn.luogu.com.cn/upload/pic/24240.png)

图中红色代表此轮玩家必输，绿色代表此轮玩家必胜。

∴我们可以得出**结论$1$**：**到$0$边的距离为$1$的点的此时的玩家必胜。**

## 过程$2$

下面是先手在一般情况下的游戏方式。（一般情况指两边的值都是正整数）

![](https://cdn.luogu.com.cn/upload/pic/24246.png)

显然，当先手走完以后，后手不可以返回原来的位置，因为先手已经将到初始位置的边清零，所以后手只能遵循先手的方向继续前进，不能反向移动。

∴我们得出了**结论$2$**：**在整局游戏中，硬币移动的方向恒定不变且取决于先手的选择。**

## 过程$3$

**结合结论$1$和结论$2$，我们可以得出一个最终结论**，下面是结论的图示，其中未标出边的数值均大于$0$，**两条$0$边连在一起形成环**，红色代表此轮玩家必输，绿色代表此轮玩家必胜。

![](https://cdn.luogu.com.cn/upload/pic/24252.png)

经过归纳，我们得出了**最后的结论**：

**当且仅当环中有$0$边时，若先手距离$0$边的距离为奇数，则先手必胜，否则必输。**

# 代码

根据上面写出的最后结论，我们写出了代码，如下：

```cpp
#include<stdio.h>//头文件

bool flag;//先手是否必胜
int n,l[32],sum;//sum为先手到0边的距离

int main(void){
	
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
		scanf("%d",&l[i]);
    //读入部分如上
    
	for(int i=n;i>=1;i--)//i从n到1，统计逆时针到0边的距离
		if(l[i]!=0)
			sum++;
		else
			break;
	if(sum&1)
		flag=true;//如果sum为奇数，先手必胜
    
	sum=0;//将sum清零
	for(int i=1;i<=n;i++)//i从1到n，统计顺时针到0边的距离
		if(l[i]!=0)
			sum++;
		else
			break;
	if(sum&1)
		flag=true;//如果sum为奇数，先手必胜
    
	if(flag)//先手胜
		puts("YES");
	else
		puts("NO");
	return 0;
}
```