本菜鸡第一次看错题目没看到至少有一个0，所以试着做了这道题的升级版。本题解讨论重点就变成**没有**“至少有一个0”约束下题目的解答，如有错误请大家批评指正。
## 有“至少有一个0”约束
当某位玩家行动时发现硬币的旁边有一条0边，那他只能将他唯一可走的那条边变成0然后继续（如果不变成0的话对面往回走把这条边变成0那就一定输了）。

对于“至少有一个0”约束下的情况，先手方有两个方向走到最近的0边，而如果其中有一条路间隔的边数为奇数的话，先手一定必胜（先手玩家只要往间隔边数为奇数的方向走，把走过的边变成0就能赢，因为最后一定是自己拿完非0的一条边）。如果两条路的间隔都为偶数，那无论先手方怎么走，后手方都会有方向与最近的0边间隔边数变为奇数，此时先手必败。

## 当所有边都可以不为0时
如果总边数N为奇数，先手只需要第一步走出0即可胜利，因为此时后手两个方向与0边的距离为$(0, N-1)$，均为偶数，后手必败。

如果总边数N为偶数，情况就变得有些复杂了，我们先来看一个比较简单的情况。
```
Input：
4
2 1 1 1

Output:
YES

```
先手方将第一个2改成1就赢了。我们可以猜测此时决定胜负的变成了两个方向与最小边的距离的奇偶性，在上面的例子中，最小的边值为1，先手方两个方向与最小边的距离为$(1, 0)$，存在一个奇数1，因此先手胜利。

下面的是该猜想正确性的证明，之后假设有两个玩家A，B，玩家的状态会用$(x, y)$表示，代表两个方向与最小边的距离。

在A的状态已经为$(x, y)$（x, y均为偶数）的情况下，他能怎么做呢？

1. 下一步产生唯一的最小边。此时B为$(0, N-1)$，N-1为奇数，B只需要走相同方向的相同步即可，下一步A仍为$(0, N-2)$，A的状态无法改变。如：A把3 3 3 3走成3 3 3 1，B只需继续走成1 3 3 1即可。
2. 下一步产生最小边，与已存在的最小边值相等。此时B为$(0, y-1)$或者$(x-1, 0)$，存在一个奇数。B仍然只需要走相同方向的相同步即可，下一步A会变成$(0, y-2)$，$(x-2, 0)$，均为偶数，A的状态无法改变，或者遇到已存在的最小边而不得不产生唯一的最小边从而变为情况1，A必败。
3. 下一步不产生最小边。此时B为$(x-1, y+1)$或者$(x+1, y-1)$，均为奇数。B可以在下一步产生最小边，与已存在的最小边值相等。此时A的情况为$(0, y+2)$，$(x, 0)$，$(x+2, 0)$，$(0, y)$，均为偶数，A的状态无法改变。

所以只要B走的没错，A将一直保持$(\text{even}, \text{even})$状态，而$(\text{even}, \text{even})$状态的最终情况就是$(0, 0)$且最小边为0，此时A无路可走。得出结论：

**与最小边两个方向距离均为偶数是必败态**

## AC代码
```cpp
#include <iostream>
#include <fstream>
#include <string>
#include <vector>
#include <iterator>
#include <algorithm>
#include <numeric>
#include <map>
#include <set>
#include <cstring>

using namespace std;

int N;
vector<int> v;

int main()
{
    cin >> N;
    int k;
    for (int i = 0; i < N; ++i)
    {
        cin >> k;
        v.push_back(k);
    }
    k = *(min_element(v.begin(), v.end()));
    auto first_itr = find(v.begin(), v.end(), k);
    auto last_itr = find(v.rbegin(), v.rend(), k);
    int first_dis = first_itr - v.begin();
    int last_dis = last_itr - v.rbegin();
    if (k != 0 && N % 2 == 1)
    {
        cout << "YES" << endl;
        return 0;
    }
    if (first_dis % 2 == 0 && last_dis % 2 == 0)
        cout << "NO" << endl;
    else
        cout << "YES" << endl;
    return 0;
}
```
