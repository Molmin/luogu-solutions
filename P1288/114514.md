对于博弈论的题目来说，大部分的题目都需要思维。

往往思维想到了，写起来就很容易，今天，我们就拿这道题为例找到一些博弈论中的规律。

对于一个新的规则，我们怎么分析呢？

首先我们当然要了解题目的意思。

![](https://cdn.luogu.com.cn/upload/pic/93.png)

如图所示，这就是题干中的图片。有四个操作
#### 1.把黑点移到右上角，经过的路径为0（先手）
#### 2.把黑点移到右下角，经过的路径为1（后手）
#### 3.把黑点重新移到右上角，经过的路径为0（先手）
#### 此时后手无法继续移动，先手胜利。

那肯定有人问：那第二步后手把经过的路标记为0不行吗？
#### 会发现，这样先手仍然能取得胜利、
如果第三步先手将黑点移到左下角，把路径改成0，先手也赢。

#### 我们会初步感觉，只要走过某条路后将路径赋值为0，下一步肯定只能将路径赋值成0。
 分析一下，加入下一步不赋值成0，就会被对方跳回去。对方就赢了！

#### 接着我们发现第二个规律。这个游戏永远不可能跳过0。也就是说从当前的位置，最远只能跳到左右两边最近的0的前一个位置（理解一下，可以多读几遍）
理由很简单，因为跳不过去呀。。。。

我们在这就可以把向左和向右的最近的0的长度处理出来

#### 接着我们又发现了一个小规律！！
#### 每次跳跃最优的方案都是将边值改为0
仔细想一下，为什么呢？

别急，我们来证明一下，假设对于初始情况的黑点（这里讨论的是两边都不为0的情况，因为若有一边为0就只有一种选择）

现在黑点有两种选择：1.向左跳。2.向右跳,实际上向左向右都一样，我们以向右跳为例子。

那么向右跳又有两种情况：
#### 1.将边赋值成0
#### 2.将边赋值成大于0的数
如果赋值成0，那么相当于后手只有唯一的移动方法。可以看做断了后手的一条退路。

而如果赋值成一个大于0的数。
那么此时对于后手来说，它如果向右跳，就和方案一一样。但后手此时比方案一多一种情况，它可以向左跳！

后手向左跳又有两种选择
#### 1.将边改为0（断了先手的退路，先手此时处于被动局面）
#### 2.将边改为大于0的数（相当于游戏又重来了）
对比可以发现，将边改为0要比将边改为1好。

那事情就变得很容易了。
#### 对于第一步，有两种操作向左或向右。且操作完双方都会按照规则一直向前走一直走到0。（这样我们就能用奇数偶数的方法判断出谁先没有路可走）。
如果两边有一边先手可以胜利，那么先手就一直往那边走即可。

### 这样，一个游戏就美好地得到了解决。
代码实现起来也不难！
```cpp
#include<cmath>
#include<iostream>
#include<cstring>
#include<cstdio>
#include<iostream>
using namespace std;
int a[105];
int main()
{
	int n;
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&a[i]);
	}
	int wns1=0;
	int wns2=0;
	for(int i=1;i<=n;i++)
	{
		if(a[i]!=0)
    	   	wns1++;
		else
    		break;
	}
	for(int i=n;i>=1;i--)
	{
		if(a[i]!=0)
    		wns2++;
		else
    		break;
	}
	if(wns1%2==1 || wns2%2==1)
	{
		printf("YES\n");
	}
	else
    	printf("NO\n");
	return 0;
}
```
 \\(^o^)/~

