### 思路：

初看本题，稍微有点难理解，但是不难发现三进制时，每一位上可能有一下三种数：

1. 该位为 $ 0 $，即该位上负正均不选，只有一种情况。

2. 该位为 $ 1 $，即该位上正负中只能选一个，有两种情况。

3. 该位为 $ 2 $，即该位上正负均选，也只有一种情况。

于是我们可以得出最后的方案数只与三进制下 $ 1 $ 的个数有关，且方案数为 $ 2 ^ k $ （其中 $ k $ 为三进制下 $ 1 $ 的个数）。

但还有几种特殊情况：

1. 输入的十进制数 $ x $ 为 $ 0 $ 或 $ 1 $，此时答案为 $ 1 $。

2. 输入的十进制数 $ x $ 满足 $ x \bmod 3 = 1 $，此时因为第一位的 $ 1 $ 不能影响方案数，所以方案数为 $ 2 ^ { k -  1 } $ （其中 $ k $ 为三进制下 $ 1 $ 的个数）。

3. 输入的十进制数 $ x $ 满足 $ x \bmod 3 = 2 $，此时因为第一位只有正，没有负，所以不可能有任何一种方案满足条件，应输出 $ 0 $。

### 代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
inline long long R(){//快读。 
    long long x=0,f=1;
    char c=getchar();
    while(c<'0'||c>'9'){
        if(c=='-')
            f=-1;
        c=getchar();
    }
    while(c>='0'&&c<='9'){
        x=(x<<1)+(x<<3)+(c^48);
        c=getchar();
    }
    return x*f;
}
int main(){
	long long t;
	t=R(); 
	while(t--){
		long long cnt=0;//用于记录三进制下x中1的个数。 
		long long x;
		x=R();
		if(x%3==2){ 
			puts("0");
			continue;
		}
		if(x==0||x==1){
			puts("1");
			continue;
		}
		if(x%3==1){
			cnt--;
		}
		while(x){//将十进制转化成三进制，同时1的统计数量。 
			if(x%3==1){
				cnt++;
			}
			x/=3;
		}
		printf("%lld",(1ull<<cnt));
		puts("");
	}
	return 0;
}
```
