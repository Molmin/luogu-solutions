## 正文：

刚开始不知道怎么想的，以为重复环数就是答案，错了好几次。

后来还是使用了偏暴力的做法。做法的思路就是找与原字符串相等字符串用了多久。看了好多大佬是用带入证明的，我认为不必，举个例子：```qwqwqw```不妨把后面的四位字母成为“循环节”，这个字符串称作“原字符串”，则：

第一次调换字符串：```wqwqwq```

第二次调换字符串：```qwqwqw```

既然都已经和原来的字符串完全相等了，那么接下来的变换不是**还是变为第一次调换的情形**吗？

对于两次调换是如此，对于三次调换也可以此类推，由此可推广到$N$次调换。

我们知道，每个样例至少有一个这样的调换（题目里明确说明字符串位数大于一），所以这个方法也可适用于这道题。

关于代码，应该比较简单了，由于题目范围较小，使用```string```库的```find```函数即可。~~但是由于我太蒻了，连```find```都不会用~~，所以我就打了个类似于深搜的程序，代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
string s,a;
int len;
int work(int k){
	
	int t=a[len-1];
	for(int i=len-1;i>0;i--){
		a[i]=a[i-1];
	}
	a[0]=t;
	//改变字符串 
	if(a==s)return k;
	else work(++k);
	//判断 
}
int main(){
	cin>>s;
	len=s.length();
	a=s;//a为操作字符串，s为原字符串 
	printf("%d\n",work(0)+1);//加一是为了算上自己本身 
	return 0;
}
```

