> $\text{UPD 2022.07.03}$：更正引标。


[P1020 导弹拦截 の 题目传送门。](https://www.luogu.com.cn/problem/P1020)
# 题目简化
> 给定一个数列 $b$，问：  
> 1. 它的最长不上升子序列长度；  
> 1. 最少能被划分成多少个不上升子序列。

# 思路讲解
- 一、为什么要求 **最长不上升子序列**：
> 但是这种导弹拦截系统有一个缺陷：虽然它的第一发炮弹能够到达任意的高度，但是以后每一发炮弹都不能高于前一发的高度。

rt，因为每一个系统的第 $i$ 发都不能高于 $i-1$ 发，所以是逐个下降，而且是“不能高于”，所以是不上升子序列。

- 二、为什么要求 **最长上升子序列**：
### [**Dilworth 定理**](https://baike.baidu.com/item/狄尔沃斯定理/18900593)
> 对偏序集 $\langle A, \le \rangle$，设 $A$ 中最长链的长度是 $n$，则将 $A$ 中元素分成不相交的反链，反链个数至少是 $n$。

偏序 是配备了部分排序关系的集合，部分排序关系即某个导弹系统不上升的关系。  
链 是偏序集 $\langle A, \le \rangle$ 的全序子集（所谓全序是指任意两个元素都可以比较）。  
反链 是指偏序集 $\langle A, \le \rangle$ 的每两个元素都是无关的子集。
不相交的反链即是不上升子序列。

综上可简化为：**最少的不上升子序列的个数就是最长上升子序列的长度。**

偏序集 $\langle A, \le \rangle$ 是指数列 $b$。  
由 一 可知：不上升子序列就是一套系统要打的导弹。  
所以这在本题中就是：

**导弹系统最少套数就是一个最长上升子序列的长度**

---
---
# 代码实现

### 一、求  最长不上升子序列：
用普通的方法是不可以的，那个的时间复杂度是 $O(n^2)$。  
**所以掌声欢迎主角登场：`lower_bound` 与 `upper_bound！`**  
对这个不熟悉的同学可以看 [oiwiki](https://oi-wiki.org/lang/csl/algorithm/)。

首先我们需要一个数组 $b$，存储从第 $1$ 个到第 $n$ 个导弹的高度，  
然后再来一个数组 $l$，存储 最长不上升子序列（伪），  
还有一个变量 $r1$ 代表 $l$ 的结尾位置。  

把 $b$ 中的每个元素挨个放到 $l$ 里：

- 如果 $b_i \ge l_{r1}$，说明 $b_i$ 可以接在 $l$ 后面（而整个 $l$ 数组还是有序的），那就直接将 $l_{r1}$ 赋值为 $b_i$：
```cpp
l[++r1] = b[i];
```

- 如果 $b_i \le l_{r1}$，说明 $b_i$ 接不上，所以我们要找办法把 $b_i$ 放进去：  
怎么放呢？在 $l$ 中找到第一个小于 $b_i$ 的数，用 $b_i$ 代替它。  
那首先要找到它。  
怎么找呢？很明显，我们需要使用 `lower_bound` 和 `upper_bound` 来找  
考虑使用什么：因为是**不上升**序列，所以不替相等的，小于等于就可以，应该使用 `upper_bound`（记得改一下比较器）。
```cpp
int p = upper_bound(b+1, b+r1+1, l[i], greater<int>()) - d;
l[p] = b[i];
```

这样就成功把 $b_i$ 放了进去。  
一次 `upper_bound` 是 $O(\log n)$，运行 $n$ 次就是 $O(n\log n)$，可以通过。

---
### 证明：
- 如果 $l_p$ 在末尾，由于 $l_p < b_i$，所以 $l_p$ 后面能接的没有 $b_i$ 多，$l_p$ 让位给 $b_i$ 可以让序列更长。

- 如果 $l_p$ 不在末尾，那 $l_p$ 以后都不会再被用到了，直接换了 $l_p$ 就行。$^{[1]}$

注意到 `upper_bound` 只能在有序序列中使用，此时 $l$ 还有序吗？  
当然有序。

设 $l_p$ 前面是 $p_1$，$l_p$ 后面是 $p_2$，则有
$$p_1 \le l_p \le p_2$$
因为 $l_p$ 是第一个小于 $b_i$ 的，所以有
$$b_i \le p_2$$
又因为
$$p_1 \le l_p \le b_i$$
所以
$$p_1 \le b_i \le p_2$$
综上，$b_i$ 可以完美代替 $l_p$。

实际上，$l_p$ 的含义是：最大不上升子序列长度为 $p$ 时，最优的结尾元素。  
最后 $r1$ 就是要求的最大不上升子序列长度。

${[1]}$：所以要注意的是，$l$ 中存储的并**不**是最大不上升子序列)
###  _CODE_：
```cpp
……

int n, r1;
int b[man], l[man];
int main () {
    ……
    r1 = 1;
    for(int i = 2; i <= n; ++ i) {
        if (l[r1] >= b[i]) l[++r1] = b[i];
        else *upper_bound(l+1, l+r1+1, b[i], greater<int>()) = b[i];
    	// 众所周知 *和指针连在一起 就是那个变量
    }
    ……
}
```

---
### 二、求最长上升子序列长度

这里和 一 的区别是：一个为上升，一个为不上升  
所以不用改比较器，而且因为是上升序列，所以等于也不行，得用 `lower_bound`。

于是推导可得：  
### _CODE_：
```cpp
……

int n, r2;
int b[man], h[man];
int main () {
    ……
    r2 = 1;
    for(int i = 2; i <= n; ++ i) {
        if (h[r2] < b[i]) h[++r2] = b[i];
        else *lower_bound(h+1, h+r2+1, b[i]) = b[i];
    }
    ……
}
```
## 扩展：Dilworth 定理的证明
施归纳于 $n$。

- 当 $n = 1$ 时：  
命题显然成立。
 
- 假设对于 $n = k$ 结论成立，考虑 $n = k+1$ 的情况：  
当 $A$ 中最长链的长度为 $k+1$ 时，令 $M$ 为 $A$ 中极大元的集合，显然 $M$ 是一条反链。而且 $A-M$ 中最长链的长度为 $k$。

由归纳假设，可以把 $A-M$ 分成至少 $k$ 个不相交的反链，加上反链 $M$，则 $A$ 可分成至少 $k+1$ 条反链。  
因为 $A$ 不可能分解成 $n-1$ 条反链。假若只有 $n-1$ 条反链，那么最长链的 $n$ 个元素中必有 $2$ 个元素被分到同一个反链，显然这与反链的定义矛盾。


### 本篇题解大力感谢 @[w1049344862](https://www.luogu.com.cn/user/149392)，有很多向其借鉴之处。