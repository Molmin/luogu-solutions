### 扫了一遍题解区，发现各位大佬都写的挺长的，其实本不用那么麻烦。

### 大家都是把兵营的位置枚举一遍，其实是可以直接算出来的。

### 我们假设已算出两边兵营的气势分别为sum1，sum2，（计算气势的过程就不加赘述了，楼上的众位巨佬都已经讲的很明白了）且sum1<sum2,自然要将工兵放在sum1一边，那么我们需保证sum1+工兵的数量*工兵距m号的距离与sum2的差距最小，不妨先假设两式相等。

### 等式中除工兵距m号的距离（其实也就是答案）未知，其余都是已知量，便可以将此量用其他量表示出来，化简可得：工兵距m号的距离=（sum2-sum1）/工兵的数量。

### 由于用此等式算出的距离可能是浮点数，所以我们只需要进行四舍五入，算出离这个值最近的整数，便是答案。

### 还有就是边界值的处理，这个整数必然是在1~n的范围内，只要最后进行一个特判就行了。

### 如果还有什么疑惑就看代码吧，各个步骤都写的很清楚了。

### 史上最短代码献上：
```
#include<bits/stdc++.h>
using namespace std;
long long n,a[1000000],m,p,s,k,sum,ans;
int main(){
	scanf("%lld",&n);
	for(int i=1;i<=n;i++) scanf("%lld",&a[i]);
	scanf("%lld%lld%lld%lld",&m,&p,&s,&k);
	for(int i=1;i<=n;i++) sum+=a[i]*(m-i);
	sum+=s*(m-p);
	ans=m+int(sum*1.0/k+0.5*(sum>0?1:-1)); //这里需注意，如果sum是个负数，四舍五入是要反着加的。
	if(ans>n) ans=n;
	if(ans<1) ans=1;
	printf("%lld",ans);
	return 0;
}
```
## 如此优秀的做法，为什么不点个赞再走呢(ﾉ´▽｀)ﾉ♪