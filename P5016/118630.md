本蒟蒻第一次发题解，不喜勿喷，求管理员通过！
# 本题最大的坑点：所有变量都要开LONG LONG！注意是所有变量！所有变量！！所有变量！！！（难道数组就不应该么？！！！）

## ####### #  ###############好的我们言归正传，简单的看看这题的基本思路。
首先我看有些人用for循环暴力枚举一遍，用打擂台的方式最终打出来一个最优解。我没试过这种方法，不过单看算法好像并没什么太大问题。毕竟n的数据还是比较小的。

我的思路大概是这样的：

1.设龙方的总士气为sum1（天降神兵的操作可单独处理，下同），设虎方的总士气为sum2（同上）。处理完天降神兵的环节后，初始化貌似就差不多了。。。

2.对于特殊情况加以处理。特殊情况有以下几种：


------------
一.双方士气相同

二.双方士气差值已经最小，如果你对某一方的兵力做了增加，无论你加在哪里都只能使士气差值更大



------------
对于以上两种情况，你需要作如下处理：把所有的兵全部调到M兵营去！（当然我写的代码里对于情况二是在第三步时才进行处理的，可根据个人喜好来搞，反正这不是重点）

3.好了下面我们可以继续求解了。在这里我用的是分类讨论。情况分两类：加在龙阵营和加在虎阵营。至于怎么放置，我们可以用最基（fan）本（ren）的计算的~~土方法~~，设两个变量：fang1,fang2~~（博大精深的汉语文化，看了变量你居然就知道这是什么意思了）~~，来作为两个候选的阵营（因为无法确定有没有特殊情况。反正~~多写比少写要好~~）。然后单独比较这两个候选阵营的优劣即可，耗时肯定比暴力枚举所有阵营少了不少。

4.输出后万事大吉

好的上代码

```
#include<bits/stdc++.h>
using namespace std;
long long a[100005];
long long n,m,s1,s2,jia,j,k,sum1=0,sum2=0,p;
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&a[i]);
	}
	scanf("%d%d%d%d",&m,&p,&s1,&s2);
	a[p]+=s1;//阵营P增加了S1的兵力 
	for(int i=1;i<m;i++)sum1+=a[i]*(m-i);//算出龙方的总士气SUM1 
	for(int i=m+1;i<=n;i++)sum2+=a[i]*-(m-i);//算出虎方的总士气SUM2 
    if(sum2==sum1)printf("%lld",m);//处理特殊情况1 
    if(sum2>sum1)//分类讨论1：如果虎方士气大于龙方，那么支援应该放在龙方 
    {
    	long long cha;//两方士气的差距 
    	cha=sum2-sum1;
    	if(cha<s2)printf("%lld",m);//如果差距已经小于了援兵的数量，那么即使是放在m-1的兵营，差距也反而被拉大了 ，不必要 
    	else
    	{
    		long long fang1,fang2,nsum1,nsum2,cha1,cha2;
    		fang1=m-cha/s2;//候选的兵营1 
    		fang2=fang1-1;//候选的兵营2（计算表明，如果fang1的除法有余数，那么实际的结果只会比fang1的增加要大。以防万一，我们设置一个fang2，避免fang1不是最优解 
            if(fang2<=0)// 注意一点：上面的计算并没有考虑到得数越界的情况。所以如果双方士气相差过大， 得数有可能是负数（也就是这个分支的条件）。这时我们就可以判定必须尽可能使士气最大化的增加。即将所有援兵都放在军营1。
			{
    			printf("1");
    			return 0;
			}
    		nsum1=sum1+s2*(m-fang1);//如果我们将援兵放在兵营fang1，龙方的新士气就是nsum1 
    		nsum2=sum1+s2*(m-fang2);//如果我们将援兵放在兵营fang2，龙方的新士气就是nsum2 
    		cha1=sum2-nsum1;//士气的差距 
    		cha2=sum2-nsum2;//士气的差距 
    		if(abs(cha1)<abs(cha2))//比较两种方法的优劣 
			{
    			printf("%lld",fang1);
    			return 0;
			}
    		else
    		{
    			printf("%lld",fang2);
    			return 0;
			}
		}
	}
	
	if(sum2<sum1)//分类讨论2：如果虎方士气小于龙方，那么支援应该放在虎方
    {
    	long long cha;
    	cha=sum1-sum2;
    	if(cha<s2)printf("%lld",m);//参考第21行 
    	else
    	{
    		long long fang1,fang2,nsum1,nsum2,cha1,cha2;
    		fang1=m+cha/s2;//
    		fang2=fang1+1; //各参照25行，26行 
			if(fang2>=n)//参照27行 
			{
    			printf("%lld",n);
    			return 0;
			}
    		nsum1=sum2+s2*(fang1-m);// 
    		nsum2=sum2+s2*(fang2-m);//各参照32，33行 
    		cha1=sum1-nsum1;//
    		cha2=sum1-nsum2;//各参照34,35行 
    		if(abs(cha1)<abs(cha2))//参照36行 
			{
    			printf("%lld",fang1);
    			return 0;
			}
    		else
    		{
    			printf("%lld",fang2);
    			return 0;
			}
		}
	}
}
```

### 在最后，作为~~过来人~~的我再重申一遍：千万别忘了开LONG LONG，任何一个变量都不要忘记开！因为有的变量如果用INT ，一开始可能还在范围内，但算着算着大小就爆了！请各位想AC而不想    得80分并且百思不得其解算法有什么错   的同学们务必注意！此规则不仅变量适用，配合数组食用更佳！千万注意！！！