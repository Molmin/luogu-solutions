~~思路比较简单~~，分别把龙的和虎的总气势求出来，

然后通过求差值决定p2即可。

然鹅，这道题的重点在于判断

if龙大,p2在m右边;if虎大，p2在m左边;

还有如果算出来的p2不是整数,要判断取[p2]还是[p2]+1;

好复杂啊，晕死人了有木有！

这时候就想：为什么不能就
### 直接按龙方气势大来算

呢？如果真实情况为虎方气势大的话，求出来的与m的距离差不就是负数了吗？实际上效果不是一样了吗！

还有处理p2小数的情况，既然出现了小数位置，为什么不能
### 假设就有这么一个小数序号的兵营
呢？把兵营的编号延伸到有理数级别，然后
### 按四舍五不入取最靠近的整数号兵营
，不就是我们所需要的吗？

四舍五入直接+0.5用int的取整就行，

但由于题目的意思似乎是四舍五不入，（优先取序号小的），

考虑加上0.499999取整（~~应该没有数据刻意卡这个吧~~）
~~好像这道题的数据+0.5也可以过~~

于是我们得到了一个极度浓缩的式子：

    p2=(1.0*(long-hu)/s2+0.499999)+m;

#### ~~免去了大段的分类讨论和重复代码，简洁明了，你值得拥有~~

下面贴上代码（是不是很短？）
~~~cpp
#include<cstdio>
#include<cstdlib>
#define N 100001
using namespace std;
int d[N],n;
long long l,h,p2;//l是龙方,h是虎方
int m,p1,s1,s2;
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
        scanf("%d",&d[i]);
    scanf("%d %d %d %d",&m,&p1,&s1,&s2);
    d[p1]+=s1;//天降神兵可以看作本来就在这里
    for(int i=1;i<m;i++)
        l+=d[i]*1ll*(m-i);
    for(int i=m+1;i<=n;i++)
        h+=d[i]*1ll*(i-m);
    if(!s2)//特判，不然会除以0，RE
    {
        printf("1");
        return 0;
    }
    p2=(1.0*(l-h)/s2+0.499999)+m;//忘打这个1.0就在除以s2的时候直接取整了，WA五遍没找出来，血的教训 
    p2=1>p2?1:p2;
    p2=n<p2?n:p2;
    printf("%lld",p2);//至于p2开long long 是怕在计算l-h的时候爆掉
    return 0;
}