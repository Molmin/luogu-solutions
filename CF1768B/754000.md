## 解题思路
我们只能做一个操作：选定最多 $k$ 个数，将它们扔到最后排个序。如果你扔了一个小的数到大的数后面，很明显是不行的，因为会多两次无关的操作。也就是说，我们只能把大的数扔到小的数后面去。先举个例子：
```
5 2
3 4 1 5 2
```
操作如下：
```
1.将 3 和 4 扔到后面，排序，原数组变为 1 5 2 3 4。
2.将 5 扔到后面，排序，原数组变为 1 2 3 4 5。
结束，共两次操作。
```
我们发现：按 **顺序** 排列的 $1\ 2\ 3 \cdots$ 且必须从 $1$ 开始的数组是不用改变位置的，其他的都要扔一遍。（如上面的例子按顺序排列的只有 $1\ 2$。）为什么呢？因为原数组 $p$ 是一个排列，除了这些数以外，其他的数后面肯定有比它小的，自然要扔一遍。

贪心发现：我们一次能扔 $k$ 个数就扔 $k$ 个数，若还需要扔的个数小于 $k$，没办法，只好单独扔一次。也就是说，我们只需要统计一下要扔的数字的个数，这道题就迎刃而解了。而我的代码中为了方便，记的是不要扔的个数，最后减一下也都一样。
## AC 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
int t;
int n,k;
int a[100010];
main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	cin>>t;
	while(t--){
		cin>>n>>k;
		for(int i=1;i<=n;i++){
			cin>>a[i];
		}
		int c=1,z=0;//z 记录不要扔的个数，c 记录现在这个排列应该到几了
		for(int i=1;i<=n;i++){
			if(a[i]==c){//属于这个顺序的排列就不要扔
				z++;
				c++;
			}
		}
		int x=n-z;
		cout<<x/k+(x%k!=0)<<"\n";//计算要扔的次数
	}
	return 0;
}
 
```