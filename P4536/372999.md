# 思路
显然，末尾是 $4$ 的三角形在图中都是倒立的，它们只会靠在和自己前缀相同且末尾数字为 $1, 2, 3$ 的三角形上。

剩下的三角形，最多只会靠在它**左、右、下**方各一个大于等于它的三角形上（可能某一侧没有三角形，因此数量 $\leq 3$）。

以题目中的 $T_{12}$ 为例，我们思考一下：

因为 $T_{12}$ 在 $T_1$ 的**左下角**，我们能得到两条信息：

1. $T_{12}$ 左靠和下靠的三角形就是 $T_1$ 左靠和下靠的三角形。
2. $T_{12}$ 包含在 $T_1$ 里，所以 $T_{12}$ 右靠的三角形只能是比 $T_1$ 小、和 $T_{12}$ 同一等级的、位于 $T_1$ 中央的 $T_{14}$。

发现了吗？一个三角形可以由比它高一级的三角形（即编号少了它的最后一位的三角形）获得，用三角形的编号来说，就是

$$T_{abc} = T_{ab} + T_{ab4}$$

递归代码也就呼之欲出啦！

### Tips. 一个小优化
如果一个三角形一直在某个大三角形的左下角的左下角的左下角...... 那么，只需要由最大的那个三角形获得即可，也就是把末尾连续的相同编号都省略。

# 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
string str,ans[3];  int len;
void find(string s,int l){
	if(!ans[3+'0'-s[l]].length()) //只有未被更新过的才更新
		ans[3+'0'-s[l]] = s.substr(0,l)+"4"; //这里是由编号1、2、3->答案下标（左0、右1、下2）
	int t = l;
	while(s[t] == s[l]) t--;
	if(t == 0){  //边界
		sort(ans,ans+3);
		for(int i = 0;i < 3;i++){
			if(ans[i].length()) cout << ans[i] << '\n';
		}
		exit(0);
	}
	find(s.substr(0,t+1),t); 
}
int main(){
	cin >> str;  len = str.length()-1;
	if(str[len] == '4'){
		for(int i = 1;i <= 3;i++){
			cout << str.substr(0,len) << i << '\n';
		}
		return 0;
	}
	find(str,len);
	return 0;
}
```
