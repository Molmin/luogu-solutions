今天考试的T4，手玩了快一个小时才推出来，觉得很有意思

首先，手玩几个数据，有一个显而易见的结论，对于每一个三角形，如果这个三角形的末尾字符是$4$,那么与它相邻的三角形一定满足$s[1]$ ~ $s[n-1]$与这个三角形相等，末尾字符为$1,2,3$。而如果末尾字符不是$4$，那么，与它相邻的三角形末尾定是$4$,且前缀$s[1]~s[n-1]$与这个三角形相等

因此，对于末尾字符为$4$的三角形，我们可以直接特判，$\dfrac{1}{4}$的分就拿到手了

现在我们考虑其他三种情况，末尾字符为$1,2,3$的三角形。因为这三个三角形性质一样，所以我们只要考虑其中一个就行

![](https://cdn.luogu.com.cn/upload/pic/18501.png)

PS：直接盗图

以末尾是$2$的为例，易得，$T21,T22,T23$与$T24$相邻，同样的，$T11,T12,T13$也与$T14$相邻，$T31,T32,T33$也与$T34$相邻，即$TXXX1$，$TXXX2$ , $TXXX3$与$TXXX4$相邻

继续以末尾是$2$的为例，易得，$T21,T23$与$T4$相邻，而$T22$不与$T4$相邻。

为什么呢？

抽象的理解一下，如果是$2$，就等于向左下方向走了一步，所以距离是$1$，也就是相邻，而如果再走一步，那么距离就变成了$2$，那么就不是相邻的了。也就是说如果目前位置，之后序列同一个数出现了大于一次，就是与这个三角形不相邻的

思维题，很妙，详见代码：
```
#include<bits/stdc++.h>
#define maxn 105
using namespace std;
char s[maxn];
int n,a[maxn];
int main(){
	scanf("%s",s+1);
	n=strlen(s+1);
	if (s[n]=='4'){
		for (int i=1;i<n;i++) printf("%c",s[i]);printf("1\n");
		for (int i=1;i<n;i++) printf("%c",s[i]);printf("2\n");
		for (int i=1;i<n;i++) printf("%c",s[i]);printf("3\n");
		return 0;
	}
	for (int i=1;i<n;i++) printf("%c",s[i]);printf("4\n");
	a[s[n]-'0']++,a[s[n-1]-'0']++;
	for (int i=n-2;i;i--){
		if (a[s[i+1]-'0']<=1){for (int j=1;j<=i;j++) printf("%c",s[j]);printf("4\n");}
		if (i>1) a[s[i]-'0']++;
	}
	return 0;
}
```
