简单树剖题。

题意经过简单转换：

给一棵树，初始所有点颜色均为 $0$。

给定两种操作。

第 $i$ 次操作为

1. 将 $u$ 到 $v$ 的路径上的点颜色设为 $i$。
2. 询问 $u$ 到 $v$ 的路径有多少条边连接的两个点颜色相同（不能是 $0$）。

很明显要树剖。。但是具体怎么搞呢？

维护两个线段树，第一个维护每个点的颜色。

第二个要维护轻重边，

但是这东西比较奇怪。我们先来研究一下这个奇怪的问题。

一个很 naive 的想法是把这条链用树剖维护好，再把连在链上的边变成轻的。

但是这随便都能卡掉。

假如说我在棕色重链上选一场段，那么有大量的地方要修改答案。

这玩意在维护的时候很难处理。

所以就不处理！

我们发现 

![](https://cdn.luogu.com.cn/upload/image_hosting/rk4550sq.png)

当我覆盖一条链的时候，有这么几个地方要变成轻的：

![](https://cdn.luogu.com.cn/upload/image_hosting/svtrcx92.png)

（红色为变轻的）

ABC 都可以在修改对应链的时候修改，但是 D 很难处理，因为 D 这样的修改可能有很多。

所以我们不管 D 类边，只在查询的时候特判掉。

具体来说就是每次跳分两部分贡献，链内的和链间的（也就是 D 类边）就可以解决了。

[Code here](https://paste.ubuntu.com/p/N7tXhpw5P3/)