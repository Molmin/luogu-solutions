## 这题可以考虑双指针来解决

双指针主要适合单调区间的求和等问题。

我们先来了解一下一个简化版双指针问题：

### 对于一个长度为n数列，输出所有长度为m的子序列，其中所有元素的和。

例如$5,9,1,4,2$这个序列，求出长度为m的子序列的元素的和。

就分别是

5+9+1=15,

9+1+4=14,

1+4+2=7;

如果是暴力求和，那么$O(n*m)$的效率，在大多数题里面是不会过的，那么怎么优化呢？

我们会发现，在起始点相邻的两个区间中，只有黄色的部分修改了，其余的部分没有变化。
![](https://cdn.luogu.com.cn/upload/image_hosting/r8yo7jc3.png)
那么我们就可以在$O(1)$的时间内求出下一个区间的和，第一个区间用$O(m)$的时间初始化即可。

### 回归正题

这道题有些地方的t值已经是1，那么先把没有使用变化的和先求出来，再用刚才的思想更新每次又多出来多少即可。

具体请看代码：
```cpp
#include <iostream>//基本输入输出流
using namespace std;
int n,k;//题目中的n,k
int sum;//每次的总和
int a[100005],t[100005];//题目中的两个数组
int ans;//答案的最大值
int main()
{
	cin>>n>>k;
	for(int i=1;i<=n;i++)cin>>a[i];
	for(int i=1;i<=n;i++)cin>>t[i];//输入
	int r=k;//第一个区间的右端点为k
	for(int i=1;i<=k;i++)
	{
		sum+=a[i];
	}//初始化第一个区间，将t[1]到t[k]变为1
	for(int i=k+1;i<=n;i++)sum+=a[i]*t[i];//后面的数没有变化，直接算
   	//到此初始化完成
	for(int l=1;l<=n-k+1;l++)//枚举左端点
	{
		ans=max(ans,sum);//更新最大值
		if(!t[l])sum-=a[l];//如果要删掉的左端点本来没有值，但是因为t[l]变成了1，有了值，所以要减回去
		if(!t[r+1])sum+=a[r+1];//新加入的右端点如果t为零，那么更新后就把数加上，否则无需变化
		r++;//更新右端点
	}
	cout<<ans<<endl;//输出最大值
	return 0;//养成好习惯
}
```
谢谢大家
