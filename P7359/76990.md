这里提供一个理论复杂度和实际复杂度都更优的做法吧...

## Part0 prework

前置部分是设计本题的二维O1转移的dp,其他的题解都写的很好这里就不再赘述了

## Part1 可行的solution

可以根据dp转移我们不难设计出转移矩阵,并且使用$+\min$卷积实现矩阵乘法

接下来就相当于需要实现一个快速get$u->v$有向的路径转移矩阵积的东西,基本想法是树剖或者全局平衡二叉树维护区间矩阵乘法,然后通过合并区间来实现$O(poly\log*k^3)$的复杂度回答询问,k是矩阵的长

或者直接使用倍增,每个点维护向上跳$2^i$步的转移矩阵,然后对于询问可以$O(\log n)$次矩阵乘法进行回答,复杂度还是$O(nploy\log*k^3)$

因为回答询问可以使用一列向量去乘其余转移矩阵,每次的复杂度都是$O(k^2\log n),q\log nk^2$不是复杂度瓶颈,我们考虑怎么优化预处理的复杂度

## Part2 优化预处理

那么可以类似树状数组,我们维护每个点向上跳$2^0,2^1,....,2^{lowbit(dep(x))}$的转移矩阵,然后再回答询问的时候,只需要先不断的跳$lowbit(x)$步,直到x和LCA的深度差小于$lowbit(x)$,我们再从高位到低位和倍增一样的跳剩下的步数

但是这么做仍然可以卡到$O(k^3logn)$,构造一颗有很多$2^x$深度的点即可

但是**深度**这种东西我们是可以钦定的,也就是说所有树上节点深度其实只是关于根节点的相对深度

那么我们考虑把所有节点的$lowbit(x)$拿出来,然后我们从低到高考虑每一位,对于$lowbit$第i位为0节点数多于第i位为1的节点数的位,**我们就在根节点的这一位加上$2^i$**,从而相当于翻转整颗树这一位的0/1,使得这一位为1的更多

这样实现最劣情况下是$O(\frac{n}{2}*1+\frac{n}{4}*2+\frac{n}{8}*4....\leq 2n)=O(n)$的,因此我们只需要n次矩阵乘法

至此我们有了一个$O(nk^3+q\log k^2)$的做法

代码确实实现了也跑的快了一点,放出部分查询的关键代码吧

```cpp

int p = x;
while(dep[p] - dep[anc] >= lowbit(dep[p])) {
	ans = ans * st2[p][trs[lowbit(dep[p])]];
	p = fa[p][trs[lowbit(dep[p])]];
}//先跳lowbit
for(int i = logn; i >= 0; --i) {
	if((dep[p] - dep[anc]) >> i & 1) {
		ans = ans * st2[p][i];
		p = fa[p][i];
	}
}//再去倍增跳

```


要不要给给过审啊....这个做法还是挺妙的吧