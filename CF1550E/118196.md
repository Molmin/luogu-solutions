> 给定一个字符串，其中可能包含 $k$ 种字母或者 `?`，您可以用这 $k$ 种字母中的任意一种替代所有的 `?`，最大化所有种类字母在字符串中连续出现次数最大值的最小值。

题意翻译的可能有点绕。

要求使得最小值最大，可以考虑二分一个限制指 $len$，要求这 $k$ 种字符连续出现的最大次数都大于 $len$，然后判断这个限制值是否合法。

可以考虑然把这 $k$ 个长度为 $len$ 的连续段放入字符串的一个前缀，因为当没有别的限制的时候，我们肯定会选择贪心地加入，使得已经加入的前缀尽可能短，可以证明这样的构造方案一定不会更劣。

但是现在有确定字符的限制，而且不同种类字母的限制不同（被除了当前种类字字母在内的所有其他字母限制）。看到 $k \le 17$，考虑状压。

设 $f(S)$ 表示已经加入的字母种类集合为 $S$ 时所占前缀的最小长度。通过枚举往集合中新加入的字符刷表转移。最后判断 $len$ 是否合法即可转化为判断 $f(\{1,2,\cdots,k\}) \le n$ 是否成立，考虑如何优雅地实现这个转移。

做一个预处理，设 $next(i,j)$ 表示从第 $i$ 个位置，放长度为 $len$ 的第 $j$ 种字母的连续段，可以放到的最小右端点位置。倒序枚举 $i$，如果后面 $len$ 长度内出现了除了 `?` 和第 $j$ 种字母之内的其他字符（通过维护已经扫过去的每一种字符最靠左的位置实现即可），那就把 $next(i, j)$ 赋值为 $next(i + 1, j)$，如果没有出现，那就是 $i + len$。这样处理一遍的复杂度为 $O(nk)$。

完成这个预处理，我们就可以实现这个转移了。

$$\large f(S) = \min_{T\subsetneqq S\land T\cap\{i\} = S}\left\{next(f(T), i)\right\}$$

枚举状态和字符转移即可，复杂度为 $O(k2^k)$。

总的复杂度为 $O((nk + k2^k)\log n)$。