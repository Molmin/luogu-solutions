## [E - Tak and Hotels](https://atcoder.jp/contests/arc060/tasks/arc060_c)

倍增好题。

## Part1 询问祖先问题

类似于二分，倍增是一种利用二进制进行优化查找的方法。

比如，在多次询问一个点向上的第 $x$ 个祖先是多少的时候，我们就可以考虑倍增。

设 $\text{F}_{i,j}$ 表示从第 $j$ 个点向上的第 $2^i$ 个祖先是谁。

我们把 $x$ 看成二进制，比如 $100111$ 。

看下表。

| $i$ 的值 | $1$ | $2$ | $3$ | $4$ | $5$ | $6$ |
| :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :----: |
| 二进制第 $i$ 位（从低到高） | $1$ | $1$ | $1$ | $0$ | $0$ |$1$ |
| 是否向上跳 $2^i$ 个 | 是 | 是 | 是 | 否 | 否 |是 |

利用 $F$ 数组，按照这样的表格来跳，很快能找到答案。这样，我们就可以在 $\log_2n$ 的时间复杂度内完成查找！

然后是初始化。 $\text{F}_{0,i}$ 是 $i$ 的父亲，$F_{i,j}=F_{i-1,F_{i-1,j}}$ （根据二进制的关系）

## Part2 引入本题

倍增的题，往往进入一个状态，下一个状态一定确定。

当高桥君走到第 $i$ 个旅店，为了快点走，他一定会走到离自己最远的、距离在范围内的旅店，所以下一个状态是确定的。

就像上一个问题一样，把从 $i$ 开始，当天能走到的最远的旅店视为 $i$ 节点的父亲，然后和上面的问题一样处理。

注意，此时我们不知道要跳多少次，但知道目的地。我们考虑倒序枚举 $i$：

如果从现在的位置走 $2^i$ 天还没有到达目的地，那么就走 $2^i$ 天；
否则看下一个 $i$。

最后，如果没有到达目的地，我们还需要将天数加 $1$。

$\large \text{Code:}$

```cpp
#include<iostream>
using namespace std;
int n,L,q,a[200010],jump[21][200010];
int main(){
	cin>>n;
	for(int i=1;i<=n;i++) cin>>a[i];
	cin>>L>>q;
	for(int i=1;i<=n;i++){
		if(a[i]+L>a[n]){
			jump[0][i]=n+1;
			continue;
		}//如果超出了 a[n] ，走这一步不优，那么视为到达 n+1
		int l=i+1,r=n,mid,ans=i+1;
		while(l<=r){
			mid=l+r>>1;
			if(a[mid]-a[i]<=L){
				ans=mid;
				l=mid+1;
			}else r=mid-1;
		}
		jump[0][i]=ans;
	}// 二分预处理出每一个结点的父亲
	for(int i=0;i<=20;i++) jump[i][n+1]=n+1;
    
    //特判 n+1 
	for(int i=1;i<=20;i++)
		for(int j=1;j<=n;j++){
			jump[i][j]=jump[i-1][jump[i-1][j]];
		}// 初始化倍增
	while(q--){
		int x,y;
		cin>>x>>y;
		if(x>y){
			int t=x; x=y; y=t;
		}
		int nowx=x,tot=0;
		for(int i=20;i>=0;i--){
			if(jump[i][nowx]<=y){
				nowx=jump[i][nowx];
				tot+=(1<<i);
			}// 如果没有到达 y 那么跳
		}
		if(nowx<y) tot++;//还没到达加 1
		cout<<tot<<endl;
	}
	return 0;
}
```