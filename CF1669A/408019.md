## CF1669A Division? 題解

这是一篇正常的题解。

**方法1：使用数组。**

我们可以定义一个 $a$ 数组，来存储每个人的分数。

举个样例的例子：

|$i$|$1$|$2$|$3$|$4$|$5$|$6$|$7$|
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
|$a_i$|$-789$|$1299$|$1300$|$1399$|$1400$|$1679$|$2300$|

我们想要调用其中的值，只需要使用 $a_i$ 就可以调用数据中的第 $i$ 位了。

- 先读入总人数 $t$，随后使用 for 循环，从 $a_1$ 读入 $a_n$：

```cpp
cin>>t;
for(int i=1;i<=t;i++) cin>>a[i];
```

当然，也可以使用 `scanf` 读入数据，速度更快：

```cpp
scanf("%d",&t);
for(int i=1;i<=n;i++) scanf("%d",&a[i]);
```

`scanf` 中的 `%d` 适用于 `int` 类型的数字，如果使用 `long long` 则需要 `%lld`。

- 然后从 $a_1$ 开始，对每一个数据进行判断：
	- 如果 $a_i$ 大于 $1900$，则为等级 1；
    - 如果 $a_i$ 大于 $1600$ 并且小于 $1899$，则为等级 2；
    - 如果 $a_i$ 大于 $1400$ 并且小于 $1599$，则为等级 3；
    - 否则为等级 4。
    
```cpp
for(int i=1;i<=t;i++){
	if(a[i]>=1900) puts("Division 1");
	else if(a[i]>=1600&&a[i]<=1899) puts("Division 2");
	else if(a[i]>=1400&&a[i]<=1599) puts("Division 3");
	else if(a[i]<=1399) puts("Division 4");
```

这里用到的 `puts` 是用于输出一个字符串。

当然，我们可以优化以下常数：读入一个比较一个。

**方法2：非数组。**

使用方法 1 中的优化方案：读入一个比较一个。

所以我们不需要用数组存储，直接定义一个变量用来读入，处理完后舍去：

```cpp
for(int i=1;i<=t;i++){
	cin>>a;
	if(a>=1900) puts("Division 1");
	else if(a>=1600&&a<=1899) puts("Division 2");
	else if(a>=1400&&a<=1599) puts("Division 3");
	else if(a<=1399) puts("Division 4");
```

**方法3：队列。**

众所周知，队列是一个先进先出的数据结构。

STL 提供了队列，头文件是 `#include<queue>`。

在本题中，我们需要用到：

- `queue<int> q`：建立 int 类型的队列 q;
- `q.push(a)`：将 a 放入队列末尾；
- `q.pop()`：将队首删除；
- `q.front()`：查询 q 的队首；

- 定义队列 $q$，并把 $a$ 压入队列：

```cpp
queue<int> q;
for(int i=1;i<=t;i++) q.push(a);
```

- 使用 `front()` 获取队首，然后判断，判断完后将队首弹出：

```cpp
for(int i=1;i<=t;i++){
	int s=q.front();
	if(s>=1900) puts("Division 1");
	else if(s>=1600&&s<=1899) puts("Division 2");
	else if(s>=1400&&s<=1599) puts("Division 3");
	else if(s<=1399) puts("Division 4");
	q.pop();
}
```

**方法4：打表。**

我们可以把所有等级的分数全部枚举出来，我们需要写一个打表生成器，这是一个格式：

```cpp
for(int i=等级的最低分;i<=等级最高分;i++){
	printf("a==%d||",i);
}
```

因为我们所需要的值可以是 $[l,r]$ 之间的任意值，所以要使用或，而不是和。

等级 1 的打表生成器：

```cpp
for(int i=1900;i<=5000;i++){
	printf("a==%d||",i);
}
```

等级 2 的打表生成器：

```cpp
for(int i=1600;i<=1899;i++){
	printf("a==%d||",i);
}
```

等级 3 的打表生成器：

```cpp
for(int i=1400;i<=1599;i++){
	printf("a==%d||",i);
}
````

等级 4 的打表生成器：

```cpp
for(int i=-5000;i<=1399;i++){
	printf("a==%d||",i);
}
````

**方法5：字符串比较。**

我们可以通过比较他们的字符来判断等级：

- 如果字符的第一位是符号或者位数小于 4 时，必然为等级 4：

```cpp
if(len<4||a[0]=='-') puts("Division 4");
```

- 如果首位不是 1，那么必然是等级 1，因为这个数一定大于 $1999$：

```cpp
else if(a[1]!='1') puts("Division 1");
```

- 如果第二位是 4 或 5 时，一定是三级，因为这个数一定在 $1400$ 到 $1599$ 之间：

```cpp
else if(a[1]=='4'||a[1]==5) puts("Division 3");
```

- 如果第二位是 6 或 7 或 8 时，一定是二级：

```cpp
else if(a[1]=='6'||a[1]=='7'||a[1]=='8') puts("Division 2");
```

- 如果第二位是 1 或 2 或 3 时，一定是四级：

```cpp
else if(a[1]=='1'||a[1]=='2'||a[1]=='3') puts("Division 4");
```

- 筛除后，剩下的一定是级别一：

```cpp
else puts("Division 1");
```

**方法6：递归。**

如果只让你在读入部分使用 for 循环，你还会做了吗？

- 我们可以写一个递归函数 dfs，定义 $\text{pos}$ 从 1 开始 到 $t$：

```cpp
inline void dfs(int pos){
	if(pos==t+1) return;
	if(a[pos]>=1900) puts("Division 1");
	if(a[pos]>=1600&&a[pos]<=1899) puts("Division 2");
	if(a[pos]>=1400&&a[pos]<=1599) puts("Devision 3");
	if(a[pos]<=1399) puts("Devision 4");
	dfs(pos+1);
}
```

- 其中 `dfs(pos+1)` 表示处理 $a_{\text{pos}+1}$ 位。

- 最后，在主函数中直接调用即可啦：

```cpp
cin>>t;
for(int i=1;i<=t;i++) cin>>a[i];
dfs(1);
```

- 注意主函数中的 `dfs(pos)` 中 $\text{pos}$ 一定要为 1，因为是从第一个数字开始判断的。

***

### 总结

本题可以使用数组、非数组、队列、打表、字符串和递归完成。




