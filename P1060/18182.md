做完看看题解,全是dp,就没有一个dfs的

我醉啦...dp学得不好

但我的(Minecraft)dfs天下无敌

递归三大省时间宝典:

剪枝!记忆化!递归递推并行!

这里只用了剪枝

对是的剪枝(是即拿):如果放不下,不要了,剪枝!

对否的剪枝:如果剩下的全放得进去,你还丢掉几个?剪枝!而且直接跳到叶子结点!

最惨时间复杂度2^(n+1)-1(即O(2^n))

最爽时间复杂度2(即O(1),当根节点直接跳到叶子结点时即可)

PS:2^26=67108864,不会超时

废话不多说,上程序(明明已经说了好多废话了)

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int v[25+10],p[25+10],f[25+10];//v,p不解释,f是vp乘积
int sum;//计数器
void dp(int x,int m,int s,int k,int n){//其实应该打dfs,兴头起打了dp,就是递归与回溯嘛......
    if(x==m){//如果是叶子结点
        if(k+v[x]<=n)//这个东西还能硬塞进来
            s+=f[x];
        if(s>sum)//计数
            sum=s;
        return;
    }
    else{
        int i,vt=0,ft=0;//i循环变量,vt和ft是计数器
        for(i=x;i<=m;i++){//计数
            vt+=v[i];
            ft+=f[i];
        }
        if(vt+k<=n)//剪枝开始,如果剩下的全装得下,直接全是到叶子结点
            dp(m,m,s+ft-f[m],k+vt-v[x],n);//递归至叶子结点
        else{
            if(k+v[x]<=n)//如果装得下
                dp(x+1,m,s+f[x],k+v[x],n);//是,递归下一层
            dp(x+1,m,s,k,n);//否,递归下一层
        }
        return;
    }
}
int main( ){
    int n,m,i;//n,m读入不解释,i循环变量
    scanf("%d%d",&n,&m);//读入
    for(i=1;i<=m;i++){//循环控制读入
        scanf("%d%d",&v[i],&p[i]);//读入
        f[i]=v[i]*p[i];//计算乘积
    }
    dp(1,m,0,0,n);//调用函数,递归开始,1为搜索第1件物品是否需要,m是物品上限(即层数),0是价值和,再下一个0是代表占用内存(作者荒谬的比喻),n是总内存(作者你又搞笑了)
    printf("%d",sum);//输出
    return 0;//终于结束了,心好累,作者一定有病(作者:你当我听不见啊?!过来,赏你20下金箍棒!)
}
```