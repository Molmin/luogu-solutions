基本背包型DP题解

一维的

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int n,m,b[30000+5],i,j,v,p;
int main(){
    scanf("%d %d",&n,&m);
    for(i=1;i<=m;i++){
        scanf("%d %d",&v,&p);
        for(j=n;j>=v;j--)//j表示耗钱量，b[j]表示在j耗钱量下，当前最大的获益是多少，注意这是从上往下的，若从下往上的话，下部分数据更改会影响上部分数据的
            if(b[j-v]+v*p>b[j])b[j]=b[j-v]+v*p;//从这里可以看出，数据的更改依赖此数据v个单位下的数据
    }
    printf("%d",b[n]); //直接输出在最大耗钱量n下，的最大获益就行了
} 
```
二维的时间复杂度要比一维高（Θ(一维)<Θ(二维)=n\*m），我一维通过时间4ms，二维44ms，但二维练一练总是没错的，万一哪道题只能用二维不能用一维呢？
```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int n,m,b[25+1][30000+5]={0},i,j,v[25+1],p[25+1];
int main(){
    scanf("%d %d",&n,&m);
    for(i=1;i<=m;i++){
        scanf("%d %d",&v[i],&p[i]);//实际上这里不用数组存也没问题，和一维一样不断用新的替换旧的也行
        for(j=n;j>=1;j--){//不得不说，数据真的有点水，我这里贪图省事，一维改二维的时候，没把j>=v[i]改成j>=1，结果有一个数据点没过，讲道理，这里应该算致命错误的
            b[i][j]=b[i-1][j];//二维不同于一维，二维需要把上一方法的数组复制下来，从这里可以看出，这就是上面为什么j>=1不能改为j>=v[i]的原因，也是二维时间复杂度高于一维的原因
            if(j>=v[i]&&b[i-1][j-v[i]]+v[i]*p[i]>b[i][j])b[i][j]=b[i-1][j-v[i]]+v[i]*p[i];
        }    
    }
    printf("%d",b[m][n]); 
} 

感觉话语很不专业，解释可能有点啰嗦还不够清晰，见谅
```