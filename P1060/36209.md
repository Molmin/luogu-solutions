```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long 
int n,m,v[26],w[26];
ll f[2333];
int main(){
    scanf("%d%d",&n,&m);
    for(int i=1;i<=m;i++) {
        scanf("%d%d",&v[i],&w[i]);v[i]*=w[i];
    }
    for(int i=1;i<=m;i++) 
        for(int j=n;j>=v[i];j--){
            f[j]=max(f[j],f[j-v[j]]+v[i]);
        printf("%lld",&f[n]);}
return 0;
}
```
*****************************************************************************************************************************************************
na本题是一道很简单的\_01背包\_（略有带动），基本上可以套模（mu）板作答。

背包问题作为很重要的一类动态规划问题，一定要打好基础。既然是动态规划类问题，重点之一就在于找到状态转移方程。

在最基础（即最原始）01背包问题中，存在这样的状态转移方程（伪代码）：

dp[i][j]=max{dp[i-1][j],dp[i-1][j-v[i]]+w[i]}// dp表示获得的总价值（某些地方称之为质量），i表示背包所装的物品的序号，j表示背包容积，v[i]表示物体的花费（或者所占体积），w表示单个物体的价值。

进而有：

```cpp
for(int i=1;i<=n;i++)
    for(int j=0;j<=zongrongji;j++){
         dp[i][j]=(i==1?0:f[i-1][j]);
         if(j>=v) dp[i][j]=max(dp[i][j],dp[i-1][j-v]+w) ;
}
```
本题背景下，主要是要注意与重要程度的乘积。其余就没什么了

  