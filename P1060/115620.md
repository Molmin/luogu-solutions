分析：所问：在不超过总钱数的情况下总和最大，典型的01背包问题。解题思路：该题是一个非常典型的01背包问题：有m件物品和一个容量为n的背包。第i件物品的费用（即体积，下同）是v[i]，价值是w[i]。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。 基本思路：每种物品仅有一件，可以选择放或不放。用子问题定义状态：即f[i][j]表示前i件物品(部分或全部)放入一个容量为j的背包可以获得的最大价值。则其动态转移方程为f[i][j]=max{f[i-1][j],f[i-1][j-v[i]]+w[i]}。

代码献上：：：：


```cpp
#include<iostream> 
#include<cstdio>
using namespace std;
int f[27][30002],v[27],w[27];		//f表示最大价值，v表示价格，w表示价值 
int max(int x,int y){return x>y?x:y;}//自定义x与y最大值max函数 
int main()
{
	freopen("happy.in","r",stdin);
	freopen("happy.out","w",stdout);
	int n,m,i,j;						//定义变量 
	cin>>n>>m;							//输入总钱数和总个数 
	for(i=1;i<=m;i++)					//输入每件物品的信息 
		{cin>>v[i]>>w[i];				//输入物品的价格和重要程度 
		w[i]*=v[i];					//本题特点，价值=价格*重要程度 
		}
	for(i=1;i<=m;i++)					//i从1到m,枚举放不放第i件物品 
		for(j=0;j<=n;j++)				//j表示当前背包总大小 
			if(j>=v[i])				//如果当前的背包可以放第i件物品。
				f[i][j]=max(f[i-1][j],f[i-1][j-v[i]]+w[i]);
//放第i件物品有没有好处，是所有背包问题的核心原始代码，
			else f[i][j]=f[i-1][j];	//当前的背包放不下第i件物品 
	cout<<f[m][n];//前m件物品(部分)放入一个容量为n的背包可以获得的最优价值 
} 
//上面的代码是01背包未优化的状态，下面是重要优化代码，二维数组变一维数组，牢记！
// for(i=1;i<=m;i++)	//i从1到m,枚举放不放第i件物品 //下行只能倒叙，要保证
//	 for(j=n;j>=0;j--) //推f[v]时f[v-w[i]]保存的是状态f[i-1][v-w[i]]的值。
//	   if(j>=v[i])					//如果当前的背包可以放第i件物品。
//	 	 f[j]=max(f[j],f[j-v[i]]+w[i]);// 取最大值
//	cout<<f[n];	//输出放入一个容量为n的背包可以获得的最优价值
 

```
