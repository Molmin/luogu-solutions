## 第一次发题解，而且是刚刚理解背包01算法的小白，现在理解了之后感觉之前看到的解释都还是有点欠缺，没有道出本质。而且感觉用c的有点少，找个题解来拯救一下都没有，所以就开通了博客。
### 用c小伙伴看过来！
```c
#include<stdlib.h>
#include<stdio.h>
int main()
{
	int i,j,N,m;
	int a[26],b[26],dp[30000]={0};
	scanf("%d %d",&N,&m);
	for(i=1;i<=m;i++)  //一边读入一边计算应该能省时间
	{
		scanf("%d %d",&a[i],&b[i]);
		for(j=N;j>=a[i];j--)
		{
			if(j>=a[i])     //判断是否还有足够多的钱，如果钱还够买第i件商品，则计算购买后的乘积大小 
			{
				if(dp[j]<=dp[j-a[i]]+a[i]*b[i])  //判断加入第i给商品后的商品价格乘重要度大小和上一状态大小 
				{
					dp[j]=dp[j-a[i]]+a[i]*b[i];  //如果加入后乘积更大，则选择该商品 
				}	
			}
		}
	}
	printf("%d",dp[N]);
 }
```
### 和我一样小白的完代码是不是一脸懵逼。级别不够，不想做过多的解释，我就说两点：
### 一.思路：是如果钱只有十块，那么在几样价格小于十且大于五块的商品中，你要选哪一样（注意选两样就超过10快了，因为要商品的数量要从一样开始算，所以才定这样的数据而已，不要多想），使得价钱和重要度的乘积最大；现在钱加到11快，你要选哪一样或是哪两样（选两样还是不够钱，所以钱的额度是11快的时候选取的还是10块时的方案）使得乘积最大；再加到12快（现在有选两样的可能性了），那么选那两样可以使得乘积最大。。。这样一直加钱，在每次钱的限度里找最优解，直到钱的限额到达题目的要求，就可以找到最优解了。
这个思路也可以倒过来想，比如前面n给商品已经是最优解了，现在还剩余一定的钱来继续买最后一件，那么买哪一件可以使乘积最大，买了之后往回推，剩余的钱可以买两件，那么又是哪两件
### 二.小白的我表示不知道怎么在c里用max公式，所以直接用判断语句，不然会出现没有语法错误但是无法编译运行的头秃情况。