[欢迎来看看呀](https://www.cnblogs.com/dzice)

题目大意：给你一串长度为n的字符串,你可以给每个位置上染上一种不大于n的颜色,对于相邻的两个位置，如果他们的颜色不同则可以交换他们的位置,现在需要交换若干次后按照字典序排序,你需要找到最少满足条件的颜色数并输出方案

可以想到，只有一个字符要与另一个字符交换，才要染成不同颜色，从前往后来考虑，我们只用考虑一个字符与在它前面的字符交换就行了，因为枚举到后面需要与其交换的字符，自然会考虑到它

只有比它大的字符才会跟它交换，所以我们只需要让它与比它大的字符不同颜色即可

然后要想到这样的一个结论，这一些字符的颜色必然在$[1,x]$这样的一个区间里，而且包含着$[1,x]$中的每一种颜色，所以我们对于枚举到的字符，找到对应的$x$,然后把枚举到的字符的颜色设为$x+1$即可

我一开始还想写权值线段树，结果一想只有26个字符，暴力就完事了，复杂度$O(26*n)$

代码很简单，如果有不理解的我相信看一看代码你就懂了

```
#include<bits/stdc++.h>
using namespace std;
int n,a[200003],maxx[200],maxxx=0,ans[200003],col;
char c;
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
		cin>>c;
		a[i]=c-'a'+1,maxxx=0;
		for(int j=a[i]+1;j<=26;j++)
			maxxx=max(maxxx,maxx[j]);
		ans[i]=maxxx+1,col=max(col,ans[i]);
		maxx[a[i]]=max(maxx[a[i]],maxxx+1);
	}
	cout<<col<<endl;
	for(int i=1;i<=n;i++)
		cout<<ans[i]<<" ";
	return 0;
}
```