首先观察题面：发现题目要求的是在一棵树上染色，相邻节点颜色要求不同，求某种颜色最多能染几个节点。

树上求最大染色，数据范围还是 $5e5$ 的，显然就是一道树形 $dp$ 。  

然后思考如何具体处理，这道题仅按 $dfs$ 序给出了一个字符串，因为是按 $dfs$ 序给出的，所以并不用先建树再跑，直接按照字符串顺序往下跑就行。  

具体实现细节上可以利用这样一个小技巧：记录下每棵子树的 $size$ 大小。对于一个节点 $x$ 。若它仅有一个儿子直接跑到  $x$ 的编号 $+ 1$ （编号即节点在字符串中的位置）的位置即可。若 $x$ 有两个子节点，遍历第一棵子树结束后，另一个儿子的编号显然就是当前 $x$ 的编号 + 第一棵子树大小 + 1。  

这样就可以不用建树直接跑 $dfs$ 了，再继续考虑如何 $dp$ ，只要会树形 $dp$ 应该就很容易想到用 $f[i][j]$ 表示第 $i$ 个节点染成第 $j$ 种颜色其子树内（包括它自己）所含的绿色节点个数，进而进行转移。本题中有三种颜色，所以很多人第二维存了分别染成三种颜色的状态。但其实并不需要，第二维存当前节点是绿色或不是绿色两种状态即可。  

正确性？因为在本题中我们仅关心绿色节点个数，所以在一个染色方案中红色蓝色的节点互换（蓝变红，红变蓝）并不影响结果，利用这个红蓝可以互换的性质可以显然证出第二维并不需要存三种颜色。  

最后就是转移方程（注意如果当前节点有两个儿子，则这三个点中有且仅有一个为绿色）：  
对于 $x$ 仅有一个子节点的情况：  
$f[x][0] = max(f[y][0], f[y][1])$  
$f[x][1] = f[y][0]$  
对于 $x$ 有两个子节点的情况：  
$f[x][0] = max(f[y1][0] + f[y2][1] , f[y1][1] + f[y2][0])$  
$f[x][1] = f[y1][0] + f[y2][0]$  
$0$ 表示不是绿色 , $1$ 表示是绿色 , $x$ 为当前节点 , $y$ 为子节点  
以上为记录最大值的转移方程，最小值的情况只要将 $max$ 换成 $min$ 即可。

以下是代码部分：  

```cpp
#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <cmath>
using namespace std;

const int N = 500010;

char t[N];
int f[N][2], g[N][2], size[N];
// f存最大值情况，g存最小值情况

inline void dfs(int x) {
	f[x][0] = 0; f[x][1] = 1;
	g[x][0] = 0; g[x][1] = 1;
	// 初始化，选则为1
	size[x] = 0;
	int to[3] = {0};
	// to中存子节点编号
	for (int i = 1; i <= t[x] - '0'; i++) {
		int y = x + size[x] + 1;
		// 按上文叙述方法遍历子节点
		to[i] = y;
		dfs(y);
		size[x] += size[y];
	}
	size[x] += 1;
	if (t[x] == '0') return;
	if (t[x] == '1') {
		f[x][0] += max(f[to[1]][0], f[to[1]][1]);
		f[x][1] += f[to[1]][0];
		g[x][0] += min(g[to[1]][0], g[to[1]][1]);
		g[x][1] += g[to[1]][0];
	}
	if (t[x] == '2') {
		f[x][0] += max(f[to[1]][0] + f[to[2]][1], f[to[1]][1] + f[to[2]][0]);
		f[x][1] += f[to[1]][0] + f[to[2]][0];
		g[x][0] += min(g[to[1]][0] + g[to[2]][1], g[to[1]][1] + g[to[2]][0]);
		g[x][1] += g[to[1]][0] + g[to[2]][0];
	}
	// 转移
}

int main() {
	cin >> t;
	dfs(0);
	cout << max(f[0][0], f[0][1]) << " " << min(g[0][0], g[0][1]) << endl;
	// 最后输出记得还要取max/min
	return 0;
}
```
