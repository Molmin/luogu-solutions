[噜啦噜啦咧 噜啦噜啦咧 的阅读体验 ！！！！](https://www.cnblogs.com/dysyn1314/p/14146557.html)


# CF955D Scissors

## 题目大意

[题目链接](https://codeforces.com/problemset/problem/955/D)

给定一个长度为 $n$ 的串 $s$ 和一个长度为 $m$ 的串 $t$。给定一个正整数 $k$。

请找出 $s$ 的两个互不重叠的、长度为 $k$ 的子串，满足：将它们按原有顺序拼接后，得到的串中包含 $t$（$t$ 是一个子串）。

数据范围：$2\leq m\leq 2\cdot k\leq n\leq 5\times 10^5$。

## 本题题解

考虑 $s$ 里，被选出的两个长度为 $k$ 的子串，称为关键子串 1、关键子串 2。

分两种情况：

1. $t$ 被完整地包含在某个关键子串中；
2. $t$ 在两个关键子串的拼接处。

对于情况 1，做一遍普通的 KMP 即可判断。因此以下只讨论情况 2。

枚举关键子串 1 的结尾位置 $i$，用 KMP 可以求出一个最大的 $f_i$，满足 $s[i - f_i + 1, i] = t[1,f_i]$。同理，枚举关键子串 2 的开头位置 $j$，可以求出一个最大的 $g_j$，满足 $s[j,j + g_j - 1] = t[m - g_j + 1, m]$。

如果存在一对 $k\leq i < j\leq n - k + 1$，满足 $f_i + g_j = m$，那么我们已经找出了答案。

然而，如果没找到这样的 $i,j$，并不一定代表无解。事实上，上述做法的误区是，数值大的 $f_i$, $g_j$，并不一定最优。具体来说，当 $k\leq i < 2k$ 时，可能存在 $s[i - f_i +i]$ 的一个 border，由它作为 $t$ 的前缀，去和后面拼接，能得到答案。对于 $g$ 也是类似的。

如果枚举 $i$，再暴力枚举 border，由于 border 的数量最大有 $\mathcal{O}(\text{串长})$ 个（例如串 $\texttt{aaa...a}$），这样时间复杂度最坏为 $\mathcal{O}(km)$，无法通过本题。

考虑优化这个“暴力跳 border”的过程。设 $t[1,x]$ 的 border 长度为 $\text{fail}(x)$（与 KMP 算法里的定义是一样的），对于所有 $1\leq x\leq m$ 如果 $\text{fail}(x)\neq 0$，我们从 $\text{fail}(x)$ 向 $x$ 连一条边，发现可以得到一个有根树森林。“暴力跳 border”，就相当于在枚举一个节点 $x$ 的所有祖先。因此可以用树链剖分优化。更具体地，由于一前一后各做一次 KMP，实际上需要建出两个森林。

考虑从小到大枚举 $j$，每次 $i = j - 1$ 会成为一个新出现的、可能的 $i$，我们把 $f_i$ 在树上的所有祖先打上标记。然后要对 $g_j$ 的所有祖先进行查询。通过树链剖分和 dfs 序，把树上问题转化为序列问题后，问题可以形式化地描述为：

有两个排列 $p_{1\dots m}, q_{1\dots m}$（也就是两棵树的 dfs 序序列），需要支持若干次操作。操作分为如下两种：

1. 给定区间 $[l,r]$，把 $p_{l\dots r}$ 里所有**数值**打上标记。
2. 给定区间 $[l,r]$，查询 $q_{l\dots r}$ 里是否存在被标记过的数值。

这个问题并不难。考虑离线，预处理出每个**数值**第一次被标记的时间，这可以通过倒序遍历操作，转化为区间覆盖问题。然后查询就变成了区间最小值查询，可以用 ST 表实现。

如果用线段树做区间覆盖，因为外层还要跳 $\mathcal{O}(\log n)$ 条重链，总时间复杂度是 $\mathcal{O}(n\log^2 n)$（$n,m,k$ 同阶）。可以通过本题，但不够优秀。进一步观察发现，区间覆盖操作是静态的（所有修改发生在询问之前），因此可以用并查集维护。总时间复杂度优化为 $\mathcal{O}(n\log n)$。

## 参考代码

[勇敢向前进，前进有奖品！！！！！](https://www.cnblogs.com/dysyn1314/p/14146557.html)