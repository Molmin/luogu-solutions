这道题需要一个数学知识：唯一分解定理

对于任意的正整数 $N$ 一定有：

$N=a_1^{p_1}×a_2^{p_2}×……×a_n^{p_n}$（$a_i$为质数）

（以下 $N$ 和上面的 $N$ 无关）

通过阅读题意，大致意思是 $N=lcm(m,n)$ 问 （$m,n$）有多少对？（可以互换位置）

分析如下：

首先，我们设 $N=a^p×b^q×……$ （$a$ 和 $b$ 均为质数）

假设 $m$ 的一个因数是 $a^k(0<=k<=p)$，那么当且仅当 $n$ 的一个因数是 $a^p$ 时，才可能有 $lcm(m,n)=N$，也就是说对于 $n$ 若有一个因数是 $a^p$ 则 $m$ 对应可以有因数 $a^k(0<=k<=p)$，所有对于 $N$ 的一个质因数 $a$ 来说，有 $2×p+1$ 种，说明如下：

当 $0<=k<p$ 时，有 $2×p$ 种（$m,n$ 位置可以互换），当 $k=p$ 时，有且仅有一种情况（$m,n$ 互换是一种情况）

那么，同理可得：对于之后的质因数，每一个质因数有 $2×$ 指数位 $+1$ 种情况，由分步计数原理，最好结果只需将这些相乘起来即可。

最后，$Ans=(2×p+1)×(2×q+1)×……$

端上一波代码：

```cpp
void scr(ll k)//欧筛，快一些
{
    for(ll i=2;i<=k;i++)//这里只需从2筛到1e7即可
    {
        if(!unp[i])
        {
            prim[++cnt]=i;
            isp[prim[cnt]]=1;
        }
        for(int j=1;j<=cnt&&i*prim[j]<=sqrt(k);j++)
        {
            unp[i*prim[j]]=1;
            if(!(i%prim[j]))
            {
                break;
            }
        }
    } 
}
```
个人感觉，欧筛会比埃筛更快一些，$isp$ 数组用来之后判断是不是质数。

```cpp
void divi(ll k)//分解质因数
{
    for(ll i=2;i*i<=k;i++)//只需分解到√k即可
    {
        if(k%i==0&&isp[i])
        {
            pr[++tot]=i;
            while(k%i==0)//把所有因数i都除掉，并记录个数
            {
                k/=i;
                prc[tot]++;
            }
        }
    }
    if(k>1)//最后剩余的数要是大于1，则其一定是还未分解到，记录下来
    {
        pr[++tot]=k;
        prc[tot]=1;
    }
}
```
分解质因数这里最重要的事最后那个 $n>1$ 的判断，因为分解出的质因数只到 $\sqrt{k}$ 无法排除之外是否还有其他质因数，要加一个判断。

```cpp
int main()//愉快的主函数
{
    scanf("%lld",&num);
    scr(Maxn);
    divi(num);
    for(int i=1;i<=tot;i++)
    {
        ans*=(2*prc[i]+1);
    }
    printf("%lld\n",ans);
    return 0;
}
```