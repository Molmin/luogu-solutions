# 题目大意

- 在一个 $n \times n$ 的棋盘上，一次放下 m 个车，每个车的摆放位置为 $(x_i,y_i)$。问摆第 i 个车时，棋盘上还有几个位子不受到攻击。

# 题解

- 做这题之前，要知道车的攻击范围。即为第 $x_i$ 行的所有格和第 $y_i$ 行的所有格。

- 首先想到用二维数组标记，但是对于 $1\leq n\leq 100000$ 的数据是明显会 MLE 的。

- 那么，我们就可以只考虑每行每列，无需每个格子考虑。

- 于是，我们可以开两个数组，表示第 i 行和第 i 列的格子有没有受到攻击。 因为是放车之前统计，那么如果放下前，第 i 行和第 i 列没有受到攻击，那么受到攻击的行列数量分别加 1。

- 如果看不懂，那么我就画一下图：

初始棋盘：
```
0 0 0
0 0 0
0 0 0
```
第一个车的位置为 $1,1$：

```
1 1 1
1 0 0
1 0 0
```
那么受到攻击的行列数量为 1 和 1，那么剩下的格子数量为 $(3-1)\times(3-1)$。

以此类推。

- 综上，我们可以得到剩下格子数的公式（cnt1 为被攻击行的数量，cnt2 为被攻击列的数量）：$(n-cnt1)\times(n-cnt2)$。

# 代码

```cpp
#include <bits/stdc++.h>

using namespace std;

long long n, m, x, y, cnt1, cnt2;
bool visited1[1000005], visited2[1000005];

int main()
{
	cin >> n >> m;
	for (int i = 1 ; i <= m ; i ++)
	{
		cin >> x >> y;
		if (!visited1[x])
		{
			cnt1 ++;
		}
		if (!visited2[y])
		{
			cnt2 ++;
		}
		visited1[x] = 1;
		visited2[y] = 1;
		cout << (n - cnt1) * (n - cnt2) << " ";
	}
	return 0;
}
```
