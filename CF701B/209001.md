因为一辆车会对它所在列和所在行都造成伤害，只需要定义两个变量x和y，分别统计有几列和几行是有车的了。

同一行或者同一列上的车是对相同的一行或一列造成伤害，所以再用两个bool类型的一维数组分别记录下已经放了车的行号和列号（每放下一辆车就把数组中它的横纵坐标对应的值分别改成true），输入时判定一次，如果是false就把x或y加一。

最后用棋盘行数和列数与统计的已占用的行数和列数减出剩余的总行数和剩余的总列数，再将它们相乘就能得到答案。

```cpp
#include <bits/stdc++.h>
using namespace std;

bool x[100010],y[100010];	//存放当前行号和列号是否已经有过车 

int main()
{
	long long m,n,a,b,sx=0,sy=0;	//sx，sy用来存储已经存在车的行数和列数 ，数据比较大，要开long long 
	cin>>m>>n;
	
	for(int i=0;i<n;i++)
	{
		cin>>a>>b;		//输入车的坐标 
		
		if(!x[a]) sx++;		 
		if(!y[b]) sy++;		//如果该行/该列已还没有放过车，sx/sy加一 
		
		x[a]=true;
		y[b]=true;		//把这行/这列的值改成true，表示已经放过了车 
		
		cout<<((m-sx)*(m-sy))<<" ";		//剩余没有放过车的行数和列数相乘就是答案 
	}
	
	return 0;
 } 
```
