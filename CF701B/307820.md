# CF701B 题解
#### 题目分析：
这题是给出一个大小为n\*n的棋盘，然后在上面放上m个“车”，每个“车”的坐标为Xi和Yi，要你分别算出**各个棋子**放上去后棋盘上还有多少个**安全位置**

#### 使用算法：
本人一开始看到这篇水题也以为是一道二维模拟题，但看清题目要求后，发现n的范围很大，不能开二维数组，就想到了STL中的set

1：set是自动分配大小的，所以不用考虑n的大小

2：set用于计算一列的大小很简便

#### 做题思路：
这道题算不上很难，我们只要稍加思考就能想出来，接下来讲一下我的方法：

0 0 0 0 0

0 0 0 0 0

0 0 0 0 0

0 0 0 0 0

0 0 0 0 0

我们模拟出一个5\*5的棋盘

接着在（1,1）的地方放置一个“车”

h里插入1，v里插入1（详情见代码）

而“车”能吃到的地方就是下图

1 1 1 1 1

1 0 0 0 0

1 0 0 0 0

1 0 0 0 0

1 0 0 0 0

所以计算后我们发现，目前的安全位置就是（5-1）\*（5-1）=16
再向（3,1）放置“车”

1 1 1 1 1

1 0 0 0 0

1 1 1 1 1

1 0 0 0 0

1 0 0 0 0

目前的安全位置就是（5-2）\*（5-1）=12

而减去的2就是目前纵轴上插入的2枚，减去的1就是横轴上插入的1枚

1 1 1 1 1  <-（第一行）

1 0 0 0 0

1 1 1 1 1  <-（第二行）

1 0 0 0 0

1 0 0 0 0

^（一列）

代码实现：
```cpp
now=(n-h.size())*(n-v.size());  //计算安全位置的数量
```
#### 代码部分：
~~我知道你们就想看这个~~
```cpp
#include <cstdio>
#include <set>
using namespace std;
set <long long> h;  //横方向
set <long long> v;  //纵方向
long long n,m,now;  //n表示棋盘大小，m表示放置“车”的数量，now表示现在还剩的安全位置
int main()
{
    scanf("%lld%lld",&n,&m);    //这里要注意，使用scanf和printf时输入输出long long类型的数要用%lld
    for(int i=1;i<=m;i++)
    {
        long long x,y;
        scanf("%lld%lld",&x,&y);    //这里要注意，使用scanf和printf时输入输出long long类型的数要用%lld
        h.insert(x);    //插入元素x
        v.insert(y);    //插入元素y
        now=(n-h.size())*(n-v.size());  //计算安全位置的数量
        printf("%lld ",now);    //这里要注意，使用scanf和printf时输入输出long long类型的数要用%lld
    }
    printf("\n");   //换行
    return 0;   
}
```
这是本xxs的第一篇题解，希望可以通过审核，谢谢