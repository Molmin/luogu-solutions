我们简化一下题目，就是用最少的相邻移动次数把一个数组变成另一个数组。

和许多大佬的思路相似，首先我们定义一个栈数组记录答案，对于 $a$ 数组的每一个数，我们可以从下标开始往后循环查找 $b$ 数组的数，如果两者相同，就把这一段循环的所有数字进行交换。但是一定要记得及时终止循环。

记录答案的时候，可以记录 $k$ ，也可以记录 $k-1$ 。

有些人可能不明白，为什么这样的交替一定是答案呢？

说实话这个问题还是比较弱的，为了和冒泡排序扯上关系，也没有什么更简单的方法。对于这个数字，找到了它的归宿之后，途中所有的数都必须交换，以此把这个数字推到它的归宿上面。

也就是这样的：

	1 2 3 4 5
  	5 4 3 2 1

对于第一个序列中的 $1$ ，我们要把它移到第 $5$ 个数上。

	2 1 3 4 5
  	2 3 1 4 5
  	2 3 4 1 5
  	2 3 4 5 1
    
这不就是把途中的数字给交换了吗？所以我们根据冒泡一定可以找到正确的答案。

代码如下：
```
#include<bits/stdc++.h>
using namespace std;
int a[305],b[305];
int stk[1000005];//栈数组
int T;
int main()
{
    int n;
    cin>>n;
    for(int i=1;i<=n;i++)
    {
        cin>>a[i];
    }
    for(int i=1;i<=n;i++)
    {
        cin>>b[i];
    }
    for(int i=1;i<=n;i++)
    {
        for(int j=i;j<=n;j++)//从这里往后查找相同的数
        {
            if(b[j]==a[i])//找到了归宿
            {
                for(int k=j;k>i;k--)//途中的数要交换
                {
                    swap(b[k],b[k-1]);
                    stk[++T]=k-1;//记录答案
                }
                break;//一定要及时跳出循环
            }
        }
    }
    cout<<T<<endl;
    for(int i=1;i<=T;i++)
    {
        cout<<stk[i]<<" "<<stk[i]+1<<endl;
        //代表此答案下标和下一个数字交换
    }
    return 0;
}
```