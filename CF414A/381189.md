题外话：隔壁大佬的题解好像有点问题，就是他输出的 `a * 2 + i` 是有可能大于题目限制 $10^9$ 的。（讲错勿喷。）

回到题目，这道题很明显，就是一道模拟。我们先从有解和无解入手。那么什么情况无解呢？

1.很明显，不管 $k$ 有多大，只需用两个数字便可填满。所以要使他无解，要使 $k$ 尽量小，就算 $n$ 个数两两互质，也会超过 $k$。

2.我们刚刚考虑了 $k$ 很小的状况，那么当 $n$ 很小，连两个数都没有，但是 $k$ 不为 0 的情况，也是无解的。

由此得出无解判断语句：`if ((n >> 1) > k  || (n < 2 && k)) cout << -1, exit (0);`

那么我们来判断有解的情况。有解依然有两种情况。

1.当 $n/2$ 刚好为 $k$ 时，这个时候，只要所有的数都互质，即可凑出 $k$，所以我们只用从 1 输到 $n$。

2.这种情况有些麻烦。我们可以先求出 $n/2$ 比 $k$ 大了多少，先将多出来的输出，后面的数只要同 1 一样，互质即可。但是要注意，输出的数不能重复。所以要用个 while 去搜索。

详情见注释。

```
#include <bits/stdc++.h>
#define int long long

using namespace std;

int n, k;

signed main() {
	ios::sync_with_stdio (false), cin.tie (0), cout.tie (0);
	cin >> n >> k;
	if ((n >> 1) > k  || (n < 2 && k)) cout << -1, exit (0); //特判无解的情况。 
	int cnt = k - (n >> 1); //求出 k 比 n/2 大了多少。 
	if (cnt == 0) { //如果相等，直接输出 1~n 即可。 
		for (int i = 1 ; i <= n ; i++) cout << i << ' ';
	} else {
		cnt++; //算出 n 比 k/2 大了多少，因为当时算的是 k - (n << 1)，所以当时算的时候这个数本为为 1，所以这位数要输出的是 n >> 1 比 k 多的数 +1。 
		cout << cnt << ' ' << (cnt << 1) << ' '; //x 和 (x * 2) 的最大公因数依然为 x。 
		int sum = (n >> 1) - 1, i = 1; //算出还要输出多少位数，这里减一是因为前面 cnt 输出过了一次。 
		while (sum) {
			if (i != cnt && i + 1 != (cnt << 1) && i != (cnt << 1) && i + 1 != cnt) { //如果这些数没有重复。 
				cout << i << ' ' << i + 1 << ' ';
				sum--;
			}
			i += 2;
		}
		if (n & 1) { //如果 n 为奇数，因为前面的 (n >> 1) 是向下取整的，可能会少取一位。 
			while (i + 1 == (cnt << 1) || i + 1 == cnt) i++;
			cout << i + 1; 
		}
	}
	return 0;
}	
```