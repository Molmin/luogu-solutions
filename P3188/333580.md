# P3188 梦幻岛宝珠
## [Link](https://www.luogu.com.cn/problem/P3188)

## 总体评价：

其实是一个非常好的（~~板子题~~），主要考察对于 01 背包的理解和对于二进制的应用以及状压 DP 的理解，综合性非常强，**值得一做**。

## 题目大意：

就是裸的 01 背包，但是它的体积和价值都很大，而且每一个 $w[i]$ 都保证能写成 $a * 2^b (a,b \in N)$ 的形式,并且 $ a \leq10, b \leq 30$。

## 题目分析：

这不是板子题吗？？？然后敲了一个板子上去（~~内心充满期待~~），然而，紫题怎么会这么容易啊喂，结果 TLE 和 RE 击碎了我（~~水~~）好好打题的欲望。

当然，每一个题都有一个突破点，而这个题的突破点就是数据范围，看到 $w$ 的数据范围的时候，其实我内心是有一丝窃喜的，因为这个题不会像之前一样没有思路了。

当然，这个 $a * 2^b$ 其实并没有什么大的用处，因为把一个数转换成二进制之后，它一定可以表示成这样的形式。所以我们接着分析题目，$a \leq 10$ 才是最重要的条件，我们看到这么小的数据，在结合一点二进制的知识，我们可以想到就是 **提示你要拆位，并且按照b来分组**，$ a $ 就是相当于是体积了。（**重点**）

我们已经有了这么一个性质，接着我们就可以设状态了，（~~显然~~）我们对于每一位进行考虑，设  $ g[i][j]$ 为在 $ b = i$ 的这一组中所选取体积为 $j$ 的最大值，根据 01 背包的dp转移，我们可以得到：
$$
g[i][p] = \max(g[i][p], g[i][p - k[i][j]] + val[i][j])
$$
简单解释一下我 ~~奇怪~~ 的变量名：

$\bullet$ 其中 $g$ 数组是上面我所说的。

$\bullet$ $i$ 是我所枚举的 $b$。（即二进制下拆位的哪一位）

$\bullet$ $p$ 是我所枚举的在 $i$ 这一位的体积。

$\bullet$ $k$ 是我所预处理后的各个宝珠，$val$ 同理。

这时候我们很高兴，可以把这题切了！！

但是，我们好像忘了什么条件，我们的 $W$ 好像并不满足那个（可爱）的性质。。。（~~陷入沉思~~）

既然一个 dp 数组不能解决这个题，那么我们可不可以设两个数组呢？？？是可以的。

我们设 $f[i][j]$ 为在 $0 \thicksim  i$  组一共选取了 $j * 2^i$ 的最大价值。

然后我们开始思考怎么转移，我们从 $i - 1$ 状态转移到 $i$ 的状态的时候，枚举 $p$ 为当前 $i$ 这一组选取的体积，我们在 $i$ 的时候选取 $j - p$ 的体积的话，根据二进制下的表示，其实相当于在 $i - 1$ 的这一位选取 $(j - p) * 2$ 的体积，当然，我们转移的时候，还需要考虑对于 $W$ 进行考虑，那么我们就要对于每一个转移考虑一下 $W$ 就可以了。

于是乎，我们就可以得出一个十分可爱（~~难看~~）的 dp 转移的式子：
$$
f[i][j] = \max(f[i][j], f[i - 1][(j - p) * 2 + W_{i-1})] + g[i][p])
$$
$\bullet$ 其中 $i$，$j$ 是我所枚举的组数和总的体积。

$\bullet$ $p$ 是我当前的组数内所需要的体积，$(j - p) * 2$ 是上一位的状态对这一位造成的影响。

$\bullet$ $W_{i-1}$ 是我对应的上一位的 $W$ 所对应的体积，即二进制下第 $i - 1$ 位，$g[i][p]$ 就是我这一位选 $p$ 的价值了。

呼~，我们终于做完了，答案当然就是 $f[s - 1][1]$ 了，$s$ 是 $W$ 所对应的二进制位数，如果选上 $s$ 位，我们的答案很明显就不对了，根据 $f$ 数组的定义，这样的话我们相当于多选了几乎一倍的体积，而 $s - 1$ 就可以保证它的正确性。

**说一下这个题的一些坑**

我做这个题的时候真的是很困难，（~~因为我很菜~~），其中有非常多的细节需要处理。

$\bullet$ 需要开 **long long**。 

$\bullet$ 其次，数组不要开小了，考虑问题的时候要考虑全面。我就是挂在这好长时间，一开始我以为只要开 30 就够了，但是事实告诉我不是，（~~深思熟虑之后~~），发现其实是我在更新过程中很可能涉及到我较大的体积来转移，所以就会 WA 。

细节标注在代码里，所以考虑问题考虑全面，以防出现我这发现不了的错误。

```c++
/*
所以，走过的坑大家不要再犯
*/
#include<bits/stdc++.h>
#define il inline
#define int long long //不开ll见祖宗 

using namespace std;
const int N = 1e6 + 10;

vector<int> val[N], k[N];

il int re()
{
	int x = 0, p = 1;
	char ch = getchar();
	while(ch < '0' || ch > '9') {if(ch == '-') p = -1; ch = getchar();}
	while(ch <= '9' && ch >= '0') {x = (x << 3) + (x << 1) + (ch ^ 48); ch = getchar();}
	return x * p;
}

int n, W, s;
int f[50][5000], g[50][5000];//注意这里不要开太小！！！ 

void init()//多组数据 
{
	s = 0;
	memset(f, 0, sizeof(f));
	memset(g, 0, sizeof(g));
	for(int i = 0; i <= 50; ++i) val[i].clear(), k[i].clear();
}

signed main()
{
	while(1)
	{
		n = re(), W = re();
		if(n == -1) break;
		init();
		for(int i = 1; i <= n; ++i)//读入
		{
			int x = re(), y = re(), t = 0;
			while(((x >> t) & 1) == 0) t++;//记录每一个物品的二进制的表示 
			val[t].push_back(y);
			k[t].push_back((x >> t));
		}
		while((W >> s)) s++;//总的体积的位数 
		for(int i = 0; i <= s; ++i)
		{
			if(k[i].size() == 0) continue;
			for(int j = 0; j <= k[i].size() - 1; ++j)
				for(int p = 500; p >= k[i][j]; --p)//这里枚举为什么要从500枚举？？？？一会你就知道了 
					g[i][p] = max(g[i][p], g[i][p - k[i][j]] + val[i][j]);//g数组更新答案 
		}	
		for(int i = 0; i <= s; ++i)
			for(int j = 500; j >= 0; --j)
				for(int p = 0; p <= j; ++p)
					f[i][j] = max(f[i][j], f[i - 1][(j - p) * 2 + ((W >> (i - 1)) & 1)] + g[i][p]);
                    //f数组，这就是为什么要开大一点的原因，我们要的数组在更新过程中极有可能出界，
                    //但是我们还要保证正确性，所以我们要保证在我们所更新的范围内答案是正确的. 
		printf("%lld\n", f[s - 1][1]);
	}
}
```

完结撒花✿✿ヽ(°▽°)ノ✿
