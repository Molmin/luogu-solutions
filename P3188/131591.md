题目链接：https://www.luogu.com.cn/problem/P3188

 
 
解题思路：这道题是一个普通的 $0/1$ 背包模型，但是体积和价值都非常大，无法用常规方法处理，怎么办呢？

注意到数据范围保证了每个物品的体积都可以表示为 $w=a*2^b$ 的形式，且 $a$ 不大于 $10$ ，这提示我们可以先不要考虑进位问题，在每一位上运行 $0/1$ 背包模板，再对结果进行合并。（以下可表示为 $a*2^b$ 的物品简称为 $b$ 类物品）

具体来说，开一个数组 $g_{i,j}$ 表示对于第i类物品，给它 $j*2^i$ 的体积，这类物品中能选到的最大价值，这样的话类与类之间是完全没有关系的，在 $a$ 不大于 $10$ 的限制下，每一类物品的最大背包体积至多枚举到 $10*n$ 即可。有人可能会说，应该是 $10*cnt_i$ ，但我们为了合并起来方便，就直接做到 $10*n$ ，这样正确性是不会有问题的，而时限又宽松，我们肯定要选择保险，方便的dp方式。

接下来的难点就在于合并的问题。我觉得这道题能评紫色的原因就在这里，状态并不好想！在 $NOIP$ $2021$ 数列 的启发下（~~时间轴错乱~~），我们发现对于位权（即 $2^x$ 中的那个 $x$ ，或者就是某个物品的类）较大的物品来说，如果我们已经考虑好了位权小的物品的选取方式，那么这个较大的物品，不管是否选取，是不会影响到已选体积在较低位的数值的。于是，我们从小到大考虑，这样的话一般第一时间想到的思路是：设 $f_{i,j}$ 表示对于前 $i$ 类物品，给它们 $j*2^i$ 的体积，这些类物品中能选到的最大价值。看上去随便转移一下就做完了是不是？

你好，假了！原因在于，虽然物品的价值有 $a$ 不大于 $10$ 的保证，但是背包大小 $W$ 可没有！然后，你就会惊喜地发现，前功尽弃啦！只有暴力分！怎么解决？

一个关键的贪心思想就是：当可选物品集合一定时，背包体积变大一定不会使结果更劣。其实如果 $0/1$ 背包学的好的话，尽管没有直接体现，但在转移的过程中也隐含了这一思想（建议读到这里仔细想一想）。而我们之前的“如果我们已经考虑好了位权小的物品的选取方式，那么这个较大的物品，不管是否选取，是不会影响到已选体积在较低位的数值的”这个思路是完全正确的，更进一步地，既然较低位体积不再会受到以后的物品的选取的影响，那么我们为什么不能把这一部分体积开到最大呢？！这样的话，对于第 $i$ 位体积的考虑，即第 $i$ 类物品的选取，我们只需要记录它往前进位的贡献，而在它后面的那 $i-1$ 位，直接假定和 $W$ 的最后 $i-1$ 位相同就可以了。

设 $f_{i,j}$ 表示对于前 $i$ 类物品，给 它们 $j*2^i+(W\operatorname{and}((1<<j)-1))$  的体积，这些类物品中能选到的最大价值。初始化  $f_{0,0}=g_{0,0},f_{0,i}=max(f_{0,i-1},g_{0,i}),i \in N^*$ ；

对于任意正整数 $i$ 和非负整数 $j$ ，枚举不大于 $j$ 的非负整数 $k$ ，表示在第 $i$ 位体积上，往低位物品让了 $k*2^i$ 的体积。则有状态转移方程：
 $f_{i,j}=max(f_{i,j},f_{i-1,min(10*n,2*k+(W>>(i-1))\operatorname{and} 1)}+g_{i,j-k})$  

 $AC$ 代码如下所示：

```cpp
#include <bits/stdc++.h>
using namespace std;
long long n,W,w[105],v[105];
long long g[55][1005],f[55][1005];
long long th[35][105],cnt[35];
long long dp[35][1005];
int main(){
	while(scanf("%lld%lld",&n,&W)!=EOF){
		if(n==-1&&W==-1) break;
		memset(cnt,0,sizeof cnt);
		memset(g,0,sizeof g),memset(f,0,sizeof f);
		for(long long i=1;i<=n;++i) scanf("%lld%lld",&w[i],&v[i]);
		for(long long i=1;i<=n;++i){
			long long nw=0;
			while((!(w[i]&1))&&nw<30) ++nw,w[i]>>=1;
			th[nw][++cnt[nw]]=i;
		}
		for(long long i=0;i<=31;++i){
			memset(dp,0,sizeof dp);
			for(long long j=1;j<=cnt[i];++j)
				for(long long k=1;k<=n*10;++k)
					if(k>=w[th[i][j]]) 
						dp[j][k]=max(dp[j-1][k],
						dp[j-1][k-w[th[i][j]]]+v[th[i][j]]);
					else dp[j][k]=dp[j-1][k];
			for(long long j=0;j<=n*10;++j)
				g[i][j]=dp[cnt[i]][j];
		}
		f[0][0]=g[0][0];
		for(long long j=1;j<=1000;++j) f[0][j]=max(f[0][j-1],g[0][j]);
		for(long long i=1;i<=31;++i)
			for(long long j=0;j<=10*n;++j)
				for(long long k=0;k<=j;++k)
					f[i][j]=max(f[i][j],g[i][j-k]+f[i-1][min(10*n,2*k+((W>>(i-1))&1))]);
		long long now=0;
		while((1<<now)<=W) ++now;--now;
		cout<<f[now][1]<<endl;
	} 
	return 0;
}
```

 