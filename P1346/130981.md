~~这道题的重点是理解题目在让你干什么~~
## 思路
### 题意
从起点走到终点，求最小总路程。其中对于每个点，如果走到的点是这个点连出的第一条边，总路程不加；如果是其它边，就加一。

所以，在建边前，所有边都初始化为正无穷；建边时，如果是第一条边，就把这条边的值赋为$0$，否则赋为$1$。

### 求法
看一下数据范围：$n≤100$。哈哈，直接$Floyd$不就求出来了吗！（~~不要告诉我你不知道什么是Floyd~~）

没什么好说的，就是一个三层暴力，打出来就结束了。不过……

## 细节
这道题关于$Floyd$的细节还比较多，说一下。

1. 上面提到过的，所有边**初始化为正无穷**。

2. $d[i][j]$和$d[j][i]$可是**不一样**的，千万不能搞反。比如核心代码中，应该为
```cpp
//d[i][j]表示i到j的距离，k为枚举的中转节点
d[i][j]=min(d[i][j],d[i][k]+d[k][j]);
```
而不是
```cpp
d[i][j]=min(d[i][j],d[i][k]+d[j][k]);
```
也就是说$d[i][j]≠d[j][i]$。

3. 如果不能到达，**输出**$-1$。

## 代码
~~相信没有多少人喜欢上面的一通分析吧~~，那么，你们喜欢的代码来了——

不加注释长度$26$行（~~有一些我很习惯的压行~~），最大测试点时间$10ms$（~~比较快~~）
```cpp
#include<cstdio>
#include<algorithm>
#include<cstring>//用到memset
using namespace std;
const int MAXN=110;
int d[MAXN][MAXN];//d[i][j]表示i到j的距离
int main(){
	memset(d,0x3f,sizeof(d));//初始化为正无穷
	int n,m,s,t,v;//s是起点，t是终点
	scanf("%d%d%d",&n,&s,&t);
	for(int i=1;i<=n;i++){//读入边
		scanf("%d",&m);
		for(int j=1;j<=m;j++){
			scanf("%d",&v);
			d[i][v]=(j==1)?0:1;//建边，判断是否是第一条边
            //这里用到三目运算符，等同于if(j==1) d[i][v]=0; else d[i][v]=1;
		}
	}
    //floyd
	for(int k=1;k<=n;k++)//遍历中转节点
		for(int i=1;i<=n;i++)//遍历节点
			for(int j=1;j<=n;j++){
				if(i==j||i==k||j==k) continue;//判断是否有重
				d[i][j]=min(d[i][j],d[i][k]+d[k][j]);//公式
			}
	printf("%d",(d[s][t]==0x3f3f3f3f)?-1:d[s][t]);//输出，注意无法到达要输出-1
	return 0;//华丽结束
}
```
看我这么辛苦，总得点个赞再走呀~