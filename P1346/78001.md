刚看到这道题的时候其实是有点懵的，但仔细一想，只要把边的权值处理好了，这就是一道最短路的模板题

那么怎样去建图呢？题目给的条件提到
```
每个开关都有一个默认的状态，每辆电车行驶到路口之后，只能从开关所指向的轨道出去，如果电车司机想走另一个轨道，他就必须下车切换开关的状态
```
那么可以这样来看，如果司机走该路口与一开始开关所指向的路口的这条边，是不用切换开关的，那么就把这条边的权值赋为零，否则就把边的权值赋为1，这样就把问题转换成了裸的最短路

看到数据范围2<=$n$<=100（~~这么小的数据~~）,n三方过掉绰绰有余，不禁想到了用Floyed，代码简单而且好写

```
#include<bits/stdc++.h>
using namespace std;
int n,a,b,k,x,f[103][103];
int main()
{
	cin>>n>>a>>b;
	for(int i=1; i<=n; i++)
		for(int j=1; j<=n; j++)
			f[i][j]=1e9;  //给每一条边先初始化成最大值 
	for(int i=1; i<=n; i++)
	{
		cin>>k;
		for(int j=0; j<k; j++)
		{
			cin>>x;
			if(j==0)
				f[i][x]=0;  //第一条边权值为0 
			else
				f[i][x]=1;  //另外的边权值为1 
		}  //还有注意这是单向边 
	}
	for(int l=1; l<=n; l++)
		for(int i=1; i<=n; i++)
			for(int j=1; j<=n; j++)
				f[i][j]=min(f[i][l]+f[l][j],f[i][j]);  //Floyed跑一遍最短路 
	if(f[a][b]==1e9)  //如果无解就输出-1 
		cout<<-1;
	else
		cout<<f[a][b]; 
	return 0;
}
```
