# 题意描述：
有N个人自西往东站成一排，给定长为N的字符串S表示每个人的方向，L表示面朝西，R表示面朝东。如果一个人前面有人并且朝向跟他一样，那么他会开心。
你现在可以最多进行K次操作，每次可以选择连续的一段l到r并翻转这些人的站位以及朝向，求最多有多少人可以开心。

# 输入格式
人数$n$, 操作次数$k$ 以及一串字符（朝向）

## 解题思路：（大佬勿喷）
首先我们可以对题目稍加简化:

给你一个01串，要求你在反转k个区间及其值后，有多少个$i$,$j$满足 $a_i$ = $a_j$ 且abs($i$ - $j$) = 1

然后我们明确本题做法：

# ~~贪心~~  简单模拟
~~虽然我也不知道算不算~~
	


------------

好，既然明确了做法我们就来谈谈具体的实现思路：~~（应该是对的）~~

首先我们可以发现，位置这个属性对结果其实没有什么影响   ~~（反正我没考虑）~~， 所以，我们只要尽可能多的将序列的值变得相同就行了。

然后代码就很好写了，每次遇到与之前不同的值就取反（注意此处指的是整个值不同的区间），然后$k-1$


# 再然后这题就结束了，

~~轻松加愉快~~



------------


上代码：


```cpp
#include <iostream>

using namespace std;

const int kMaxN = 1e5 + 1;

int n, k, ans;
char str[kMaxN];
bool a[kMaxN];

int main() {
  cin >> n >> k;
  for (int i = 1; i <= n; i++) {
    cin >> str[i];
    if (str[i] == 'L') {
      a[i] = 0;//01串简化
    } else {
      a[i] = 1;
    }
  }
  for (int i = 1; i <= n && k > 0; i++) {
    if (a[i + 1] != a[i]) {//与之前的值不同
      k--;
      i++;
      a[i] = !a[i];
      while (str[i] == str[i + 1]) {//整个区间取反
        i++;
        a[i] = !a[i];
      }
    }
  }
  for (int i = 2; i <= n; i++) {
    if (a[i] == a[i - 1]) {//统计变形后序列中开心人数
      ans++;
    }
  }
  cout << ans;
  return 0;
}
