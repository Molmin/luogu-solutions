# 分析
首先最大最小值看得出来要贪心，而它的值就要能大就大，能小就小。
### 最大
从后往前，每次找空位多的坐，可以先从座位的数量入手找到最大的数，将所有等于这个数的减少，并记录答案，然后将最大值减少，直到每个人都有座位就停止。
### 最小
从前往后，每次将座位最少飞机坐满，就会得到最小的答案，也是到每个人都有座位时停止。
# 代码
```
#include<bits/stdc++.h>
using namespace std;
int n,m,a[10001],mn,mx;//rt
int main(){
	cin>>m>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
	} 
	sort(a+1,a+n+1);//排序，至关重要的一步
	int s=0;//记录有位置的人的数量
	bool flag=0;
	for(int i=1;i<=n;i++){
		int p=a[i];
		while(s!=m&&p){//将每个飞机坐满，并要防止每个人都有位置了
			mn+=p;//记录答案
			p--;//减少座位数
			s++;//有一个人有位置了
		}
		if(s==m) break;//如果每个人都有位置了，就不要算了
	}
	int p=a[n];//记录最大值
	s=0;//记录有位置的人的数量
	for(int i=p;i>=1;i--){
		for(int j=n;j>=1;j--){//从前往后找
			while(a[j]>=i&&s!=m){//不能多于最大值
				s++;
				mx+=a[j];
				a[j]--;//同上
			}
			if(s==m) break;//同上
		}
		if(s==m) break;//同上
	}
	cout<<mx<<" "<<mn; 
	return 0;
} 
```