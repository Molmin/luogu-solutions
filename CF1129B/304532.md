# [CF1129B](https://www.luogu.com.cn/problem/CF1129B) $~~$ Wrong Answer

原问题要求一个序列某个字串使 长度 $\times$​​​​​ 元素和 最大，观察 Alice 的程序，它一旦发现当前字串和为负，便会直接截断，也就是它只更新了每个前缀和都非负字串的答案，形如序列 $a=\{0,0,0,-1,11\}$​，正确答案为 $5 \times 10 =50$​，而 Alice 求得  $1 \times 11=11$​​​​。

不难想到利用 一长串 $0$ $+$ 一个负数 $+$ 正数 的结构来构造，因为要求 $n \le 2000$ ，方便起见，我们直接令 $n=2000$ ，不影响可行性。

如果最后只有一个正数 $a_{2000}$​​​​​​​ ，那么我们令 $a_0=a_1=\cdots=a_{1998}=0,a_{1999}=-x,a_{2000}=y$​​​​​​​，此时正确答案为 $2000*(y-x)$​​​​​，而 Alice 求得 $y$​​​​。

所以有 $1999y-2000x=k$​​​​，即 $1999 \times (y-x) -x=k$​​​。

显然，一组特解为 $x=1999-k\bmod1999,y=\frac{k+x}{1999}+x$​​​​​​​​，其中 $0 \le x<1999,0\le y \le\frac{10^9+1999}{1999}+1999<10^6$​​​​​​​，满足题意。

所以我们仅需构造长度为 $2000$​​​​ 的序列 $a=\{0,0,0,\cdots,0,-(1999-(k\bmod1999)),\lfloor \frac{k}{1999} \rfloor+1+(1999-(k\bmod1999)) \}$​​​​​ 即可。

​                                                                                                                                                                                                                               
## Code

```cpp
#include<bits/stdc++.h>
using namespace std;

int k;

int main(){
	scanf("%d",&k);
	puts("2000");
	for(int i=1;i<=1998;i++) printf("0 ");
	printf("%d %d\n",-(1999-k%1999),k/1999+1+1999-k%1999);
	return 0;
}
```
