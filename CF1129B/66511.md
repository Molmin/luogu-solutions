构造好题，写篇题解纪念一下。

主要是解释另一篇题解没解释的思路。

## 【思路】
首先确定我们的目标是构造一组数据，使得正确答案与错误答案之差为 $k$ 。

先观察样例。

发现 Alice 最大的问题在于用类似最大子段和的思想进行了 **错误的贪心**，忽略了 **子段长度的贡献** 。

比如样例中， $6 - 8 = -2 < 0$ ，但事实上它会对后面的 $7$ 进行加倍。

这也同时告诉我们， $Alice$ 的程序遇到负数会自动忽略负数。

那我们就要想办法利用这个特点。

于是我们有了第一种构造方法：一个序列有两个数，第一个是负数 $x_1$，第二个是正数 $x_2$，那我们就能成功限制 Alice 的答案为 $x_2$ ，而正确答案为 $max(x_2,(x_1+x_2) * 2)$ 。

此时如果 $x_1$ 的绝对值足够小，那么 Alice 的答案就错了，并且与正确答案的差距是我们可以控制的。

然而这道题 $k$ 有 $1e9$ ，而 $x_i$ 最多 $1e6$ ，因此我们考虑扩展上述解法。

不难发现，$x_i\le 0$ 对 Alice 的答案是没有影响的，它只会在 **正解** 中为长度增加贡献。

因此我们考虑把上文中的 $2$ 直接变为 $n_{max}=2000$ ，然后$x_1,x_2$ 变为 $x_{n-1},x_n$ 即可。

那么现在只需要构造一组数据，使得 $k=(x_{n-1}+x_{n})*2000-x_{n}$ 即可。

下面设 $x_{n-1}=val,x_n=x$

得
$$
k=2000val+2000x-x
$$
$$
val=\frac{k-1999x}{2000}
$$
$$
-val=x-\frac{x+k}{2000}
$$

由于$val\le 0, -val\ge 0$，所以现在我们只需要使得 $x-\frac{x+k}{2000} \ge 0$ 且为整数即可。

那么我们让 $x+k=0(mod~2000)$ 且 $x$ 尽可能大。

那么有 $x=2000-k(mod~2000)$ ，取 $x=1000000-(k \% 2000)$ 即可满足题意。

并且此时 $x > 998000$ ，而 $\frac{x+k}{2000}$ 大约是 $500000$ 级别的，满足题意。

所以构造一组这样的数据即可：

$$n=2000$$

$$a_1=a_2=\dots=a_{1998}=0$$

$$a_{2000}=1000000-(k \% 2000)$$

$$a_{1999}=-(a_{2000}-\frac{a_{2000}+k}{2000})$$

## 【代码】
实现过于简单。
```cpp
#include <bits/stdc++.h>
using namespace std;
int k;
int main(){
    scanf("%d", &k);
    int num = k % 2000;
    int x = 1000000 - num;
    printf("2000\n");
    for (register int i = 1;i <= 1998;i ++) printf("0 ");
    printf("%d %d\n", -(x - ((x + k) / 2000)), x);
}
```