# 题目大意
给你两个数 $n$ 和 $m$ 以及长度为 $n$ 的一个数组，现在请你求出这个数组中**连续一段**不超过 $m$ 但最大的总和。


------------
# 分析
这道题一看到“连续一段”这个字眼，我们就可以想出**尺取**这个方法：不停地缩窄或扩大范围，直到满足条件时，刷新答案。而我一般遇到这种题，更喜欢使用**递归**这种简洁易懂的方式来编写。具体怎么递归呢？首先，我们把初始范围设成左端点为 $1$，右端点也为 $1$，那么总和就是数组中的第 $1$ 个数值，接着，不停地递归以下过程：如果总和符合要求——小于等于 $m$，那么就刷新最大值，而且要是右指针还能继续向右伸展，那么就递归**右指针向右移一位后**的情况，否则如果左指针能向左收缩，那么也要递归**左指针向左移一位**的情况。


------------
# 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,ans;
int a[1000010];
void DG(int L,int R,int sum){ //L为当前区间的左端点，R为右端点，sum为总和 
	if(sum<=m){
		ans=max(ans,sum); //如果当前总和不大于m的话，那么刷新最大值 
		
		if(R<n) //判断右指针是否还能继续向右伸展 
			DG(L,R+1,sum+a[R+1]);
	}
	else if(L<R) //判断左指针能否向右移 
		DG(L+1,R,sum-a[L]);
}
int main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++)
		scanf("%d",&a[i]);
	DG(1,1,a[1]); //当前为位置1到位置1这一段，总和为a[1] 
	cout<<ans;
	return 0;
} 
```
