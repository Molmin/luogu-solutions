[P4155 [SCOI2015]国旗计划](https://www.luogu.com.cn/problem/P4155)


题目大意是一个大小为 $M$ 的环，有 $N$ 个区间，问在必选区间 $i$ 的情况下（$N \leq 2 × 10^5$），至少要选多少个区间能满足完全覆盖。输出一行共 $N$ 个整数。

首先，题目的基础模型类似于[线段覆盖](https://www.luogu.com.cn/problem/P1803)，然而题目的背景是环，不能直接操作，所以要“断环成链”，具体做法是将所有区间复制一份，左右端点统一加上 $M$ ，如果右端点小于左端点，即在环上走了超过半圈的区间，则先给右端点加上 $M$ 再复制。再在这 $2 * N$ 个区间中做贪心。根据线段覆盖的贪心策略，需要先以右端点为关键字排序，复制后无需再排序，因为复制出来的仍然保持有序。

那么如果只用做一次我们就会了，只要选出来的区间总长度达到 $M$ 即可，因为无论是怎样的一个区间，在原本的环上都是以某个点为起点覆盖了整个环。

但是题目的要求要做 $N$ 次，这样做时间复杂度 $O(N^2)$ ，显然不行。做每次 $O(1)$ 显然不现实，所以猜测每次操作要降到 $O(logN)$ 。

回顾算法过程，本质是一个一个选区间使总长度达到 $M$ ,就像是在凑一个数。而我们在凑一个数的时候经常用不大于它最大的二的次幂，减去之后再重复这个过程，这样这个数的值会减小得非常快，一共只需要减 $\:{log(num)}$ 次就可以凑出。把这个思想应用到这个题目上来，即从 $logN$ 枚举到零，且令此时的次数为 $x$ 。如果从当前的区间选 $2 ^ x$ 个区间的右端点减当前区间左端点 
$< M$，就将考虑的区间跳到后 $2 ^ x$ 个。根据枚举特性，区间长度一直在向 $M$ 逼近，退出循环后区间总长必然为 $M - 1$ ，因此将当前答案加一即可。

现在面对的问题是如何知道某个区间后选的第 $2 ^ x$ 个区间究竟是哪个，这需要预处理。如果定义 $f[\,i\,][\,j\,]$ 表示根据贪心策略，第 $i$ 个区间后的第 $2 ^ j$ 个区间，那么可以得到一个递推关系：
$f[\,i\,][\,j\,] = f[f[\,i\,][\,j - 1\,]][\,j - 1\,]$

现在，我们只要有全部的 $f[\,i\,][\,0\,]$ ，就可以求出全部的 $f[\,i\,][\,j\,]$。$f[\,i\,][\,0\,]$ 即每个区间后选的第一个区间。肯定不能两重循环，那时间复杂度就再次变为 $O(N ^ 2)$ ，这个时候就可以再次利用题目中提到的一个性质：
### “每名边防战士的奔袭区间都不会被其他边防战士的奔袭区间所包含。”

那么，每个区间（令为 $i$）后选的第一个区间(令为 $j$ )，即贪心策略中的最优解，必然是满足 $l_j \leq r_i$ 的最后一个区间。则对于单调递增的 $i$ ，$j$ 也单调递增，可以使用双指针扫描的策略。时间复杂度降为 $O(N)$。

最后，可以在存区间时在结构体里放一个初始编号，把每次算出的答案放进 $ans[\,id_i\,]$ 即可。

可以总结一下倍增使用的场合：

1.同一件事完成多次。

2.当“一次做一件事”可以优化为“一次做多件事”。

双指针扫描的应用：

两个指针代表的内容均只增不减。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 2e5 + 10;
int n,m,a,b,cnt,f[2 * N][25],ans[N];
struct line
{
	int id,l,r;
	bool operator < (const line &k) const {
	    return r < k.r;
	}
}L[2 * N];
void pre()
{
	int p2 = 1;
	for(int p1 = 1; p1 <= 2 * n; p1++)
	{
		while(p2 <= 2 * n)
		{
			if(L[p2].l > L[p1].r) break;
			p2++;
		}
		p2--;
		f[p1][0] = p2;
	}
	for(int j = 1; (1 << j) <= 2 * n; j++)
    {
    	for(int i = 1; i <= 2 * n; i++)
    		if(f[i][j - 1]) f[i][j] = f[f[i][j - 1]][j - 1];
	}
}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i = 1; i <= n; i++)
	{
		scanf("%d%d",&a,&b);
		if(b < a) b += m;
		L[i].id = i;
		L[i].l = a;
		L[i].r = b;
	}
	sort(L + 1,L + n + 1);
	for(int i = 1; i <= n; i++)
	{
		L[i + n].id = 0;
		L[i + n].l = L[i].l + m;
		L[i + n].r = L[i].r + m;
	}
	pre();
	for(int k = 1; k <= n; k++)
	{
		int tp = k,cnt = 1;
		for(int i = 20; i >= 0; i--)
		{
			if(f[tp][i] > 0 && L[f[tp][i]].r - L[k].l < m) 
			{
				tp = f[tp][i];
				cnt += (1 << i);
			}
		}
		ans[L[k].id] = cnt + 1;
	}
	for(int i = 1; i <= n; i++)
	    printf("%d ",ans[i]);
	return 0;
}
```
