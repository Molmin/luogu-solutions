~~UVA水紫~~

## 题意：
Stan 和 Ollie 正在玩一种数字游戏，这个游戏是他们的祖先欧几里得发明的。给定两个正整数 $M$ 和 $N$ ，从 Stan 开始，取其中较大的一个数，减去较小的数的正整数倍，当然，得到的数 $K$ 不能小于 $0$ 。然后是 Ollie 对刚才得到的数 $K$ 和 $M$ ， $N$ 中较小的那个数，再进行同样的操作……直到一个人得到了 $0$ ，他就取得了胜利。
 
 现在假设他们进行“完美”的操作，谁会取得胜利呢？

## 算法分析  $($ 博弈与数论 $)$ ：
显然当玩到 $M\%N=0$ 的状态时游戏即可结束，例如 $6$ 和 $3$ 的下一步即 $3$ 和  $0$ 。
设 $M > N$ ，可以看出，如果 $ M / N > 1 $ ，例如 $25$ 和 $7$ ，先拿到的人有多种选择，例如 $18$ 和 $7$ ，  $11$ 和 $7$ ， $4$ 和 $7$ 均可，而正确的选择应该是形成新状态 $M\%N+N$  ， $N$ ，即 $11$ 和 $7$ ，这样对手只有一种选择  $M\%N$ ，  $N$ ，即 $7$ 和 $4$ 。而先拿的人又可以根据情况做出多种选择。所以先取者必胜。

若每一局都是 $M/N=1$ ，例如 $24$ 和 $15$ ，因为两个人每一局均只有一种选择，所以要看玩到 $M\%N=0$ 的次数是偶数还是奇数，如果偶数，则先取者必胜，否则后取者必胜，例如初始值 $24$ 和 $15$ ，依次取值的状态为 $15$ 和 $9$ ，$9$ 和 $6$ ， $6$ 和 $3$ ，此时 $6\%3=0$ ，最终状态为 $3$ 和 $0$ ，共 $4$ 次，为偶数，所以先取者胜。

## 参考代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
int m,n;
int main() {
  while(cin>>m>>n&&(m&&n)) {
    if (m<n) swap(m,n);
    int f=0;
    while (m/n==1 && m%n!=0) {
      int t=m%n;
      m=n,n=t,f++;
    } puts(f%2==0?"Stan wins":"Ollie wins");
  }  return 0;
}

```
