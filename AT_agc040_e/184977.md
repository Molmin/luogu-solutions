为什么标题是这串数字，懂的都懂啊！

很巧妙的题目。

首先这两个操作如果只有一个，怎么办？

假设我们有的是第一个操作。我们可以先选一堆前缀 $0$，然后再设置一个不下降序列。这样相当于区间减去一个不下降序列。

然后如果只有这样一个操作怎么办。容易发现我们可以把整个序列看成若干个极长不下降子段，并且最优情况下一次操作一定不能消去两个不同的不下降子段。因此只有一个操作的时候就等于整个序列的不下降子段个数。

显然对于另外一个操作也是成立的。这里出现了分开处理的动机。

自然我们想到对每一个 $i$ 分成两个序列 $a_i=p_i+q_i$，且令答案为 $p$ 的不下降极长子段个数和 $q$ 的不上升极长子段个数。这样就可以 DP 了。

记 $dp_{i,j}$ 表示我们在第 $i$ 个数令了 $q_i=j$。容易发现 DP 转移：

$$
dp_{i,j} = \min_{k=0}^{a_{i-1}} \{dp_{i-1,k}+[k<j]+[a_{i-1}-k>a_i-j]\}
$$

其实类似于两个条件 $p_{i-1}>p_i,q_{i-1}<q_i$ 每满足一个就会让值加一。注意到第一个非下降极长子段和最后一个非上升极长子段，我们还没有处理，所以答案应该取 $\min dp_{n+1}$。

分析条件的特殊性，发现在只考虑前 $i$ 个数的子问题，即 $dp_i$，在 $j<k$ 的情况下一定满足 $dp_{i,j} < dp_{i,k}$。因为 $q_i$ 越小 $p_i$ 越大，而两个条件为 $p_{i-1}>p_i,q_{i-1}<q_i$，所以 $q_i$ 越小一定最优。

同时我们可以发现 $dp_{i,0} + 2 \geq dp_{i,a_i}$。原因也很显然：因为最多只有两个条件同时满足，这样就算从同一个状态转移差值最多也只有 $2$。

那么有一个想法就是维护 $f_{0,i},f_{1,i}$ 表示 $dp_i$ 取值不同的三段（不维护 $f_{2,i}$ 的原因是它显然等于 $a_i$），同时维护取值最小的 $dp_i$。剩下的代码细节在代码里面。

```cpp
int n,a[200005];
int main(){
	n=read();
	for(int i=1;i<=n;++i)	a[i]=read();
	int f0=0,f1=0,dp=0; // f2=a[i]。dp 表示 dp[i][0]，取值为 dp[i][0] 的区间为 [0, f0]，取值为 dp[i][1] 的区间为 [f0+1, f1]
	for(int i=1;i<=n;++i)
	{
		int v=a[i],lst=a[i-1];
		if(v>=lst)	f1=max(f1,f0+v-lst);
		/*
		在这里 f0 显然不能移动，因为向右移动了会导致 q[i]>q[i-1] 导致取值变化，并且不动显然不会变化。
		然后 f1 的取值由两个方向决定。一个是不动保证了 q 没有贡献，一个是平移保证 p 没有贡献。两者取最大值。
		*/
		else
		{
			f1=max(f0,f1-lst+v);
			f0-=lst-v;
			/*
			这里的原因是，f1 可能只能选择让 p 贡献然后继承 f0 的位置，或者是平移让 p 没有贡献。
			f0 只能平移选择让 p 没有贡献。
			*/
			if(f0<0)	++dp,f0=f1,f1=v;
			/*
			f0 的取值已经不合法了，这个时候更新取值范围就好了。
			*/
		}
		f0=min(f0,v),f1=min(f1,v);
	}
	write(dp+int(f0<a[n])); // 点值算到 n+1
	return 0;
}
```

非常精妙的题目。