# 前言

这道题十分的有趣味，也很坑，但只要缕清思路，肯定就会 $\verb!AC!$。

# 思路

我一开始的思路是，遍历每个点 $(i,j)$，先从这个点扫到 $(i,j+k)$，再从 $(i,j)$ 扫到 $(i+k,j)$，写一个函数来判断是否满足朋友和自己全部入座，可以的话累加器 $+1$，最后输出一下累加器就行了。

给出代码：[代码](https://www.luogu.com.cn/paste/z6fpkkhe)

但这种做法能 $\verb!AC!$ 吗？当然不行了。如果 $n = 2000,m = 2000,k = 2000$，我们判断的次数就是 $2000$ $\times$ $2000$ $\times$ $(1000+2000)$ $\times$ $2000$，不用算都知道是一个巨大无比的数，肯定会超时，我们必须要考虑优化。

怎么优化呢？根据题面所说的同一行或同一列中找到 $k$ 个连续的空席位，我们能想到什么？那就是判断连续出现的字符！我们只需要判断每一行连续出现的字符是否 $\ge k$，如果 $\ge k$，那么统计的方案数 $s$ 就 $+1$，当然的，判断完行后，我们还需要判断每一列，最后输出一下答案就行啦！

# 代码

```cpp
#include<bits/stdc++.h> 
using namespace std;
//把大数组定义在函数外面，节省空间。 
char a[2001][2001];
int main()
{
	//定义
	 
	int n,m,i,j,k,s,cnt;//本人习惯用 i 和 n 表示循环行的变量与行数，用 j 和 m 表示循环列的变量与列数。 
	
	//输入 
	cin>>n>>m>>k;
	for(i=1;i<=n;i++)
		for(j=1;j<=m;j++)
			cin>>a[i][j];
	
	//变量赋值
	 
	s = 0;
	
	//操作
	 
	for(i=1;i<=n;i++)//先扫完每一列 
	{
		cnt = 0;//在统计连续出现的字符前，统计变量 cnt 先要清空。 
		for(j=1;j<=m;j++)
		{
			if(a[i][j]=='.')//如果满足了连续座位都空的情况 
				cnt++;//cnt++，连续出现的字符数量 +1。 
			else
				cnt = 0;//否则就是出现了有人的座位，没有必要统计下去了，cnt直接清空。 
			if(cnt>=k)//只要 cnt >= k，说明满足条件了，总方案变量 s++。
				s++;
		}
	}
	
	for(j=1;j<=m;j++)//与行相似，这里实现列。注意变量 j 的终止条件。 
	{
		cnt = 0;
		for(i=1;i<=n;i++)
		{
			if(a[i][j]=='.')
				cnt++;
			else
				cnt = 0;
			if(cnt>=k)
				s++;
		}
	}
	cout<<s/(k==1?2:1)<<endl;//这里用了一个小妙招，就是处理 k = 1 的情况。
	/*
	比如输入 
	1 1 1
	.
	
	这时我们发现，如果直接输出 s 就会输出 2，而不是正确答案 1，这是因为我们算行和列的时候算重复了，也就是行和列重合了
	所以我们需要 s / 2，把多余的消掉，这样就不用担心重复的问题了。 
	*/
	return 0;
}
```
