**这道题虽然用dfs，bfs等可以过，但对于一些初学者来说并不是很容易，于是就有了这篇~~奇葩~~题解。虽然代码很长，复杂度很高，但很好理解**

首先声明一下，这种思路是由这道题产生的：[流感传染](http://ybt.ssoier.cn:8088/problem_show.php?pid=1191)，
这种思想和广度优先搜索一样，可代码却完全不同

把思路阐述一下

**我们可以定义一个“首领”w数组，w[0][i][j]表示x坐标是i，y坐标是j的“W”的首领的x坐标；w[1][i][j]表示x坐标是i，y坐标是j的“W”的首领的y坐标。这里首领是什么意思呢？是当你枚举到一个“W”是，就可以把它定义为这个湖的首领，及自己的首领是自己，这样当枚举到其他和这个湖相连的“W”时就可以把它的首领定义为这个湖的首领，就不会把这个“W”算到其它的湖里去了。**

1.枚举所有点

2.找到一个“W”后，标记此湖已经找过了，并存下坐标，把湖的数量 + 1

3.while循环直到没有找到其他和第2步上面枚举的首领相连的“W”。至于怎么while循环呢，看下面的代码

```cpp
while(true)//循环直到没有可连的"W" 
{
	bool ff = false;//定义一个ff，判断是否找到了任何一个可以连的"W" 
	for(int ii = 1; ii <= m; ii++)
	{
		for(int jj = 1; jj <= n; jj++)
		{
			if(w[0][ii][jj] == i && w[1][ii][jj] == j)//如果一个"W"的首领是上面枚举到的首领，就可以判断有没有和这个"W"相连的"W"了 
			{
				for(int k = 0; k < 8; k++)//八个方向 
				{
					if(q[ii + u[0][k]][jj + u[1][k]] == 'W' && !f[ii + u[0][k]][jj + u[1][k]])//如果是个"W"，且没有被连过 
					{
						f[ii + u[0][k]][jj + u[1][k]] = true;//改为连过了 
						w[0][ii + u[0][k]][jj + u[1][k]] = i;//把首领定义为上面枚举到的首领 
						w[1][ii + u[0][k]][jj + u[1][k]] = j;
						ff = true;//标记为这次循环连过"W"了(表示还有可连的"W")
					}
				}
			}
		}
	}
	if(!ff)//如果没有"W"可连了 
	{
		break;//退出 
	}
}
```


完整的代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
int u[2][8] = {{1, -1, 1, -1, 0, 0, 1, -1}, {1, -1, -1, 1, 1, -1, 0, 0}};//八个方向(按顺序)--->：↘，↖，↙，↗，→，←，↓，↑  
int n, m, k, w[2][111][111], ans;
char q[111][111];
bool f[111][111];
int main()
{
	scanf("%d %d", &m, &n);
	for(int i = 1; i <= m; i++)
	{
		for(int j = 1; j <= n; j++)
		{
			cin >> q[i][j];//输入 
		}
	}
	for(int i = 1; i <= m; i++)
	{
		for(int j = 1; j <= n; j++)
		{
			if(q[i][j] == 'W' && !f[i][j])//如果发现了一个湖，且没有被连过 
			{
				f[i][j] = true;//改为连过了 
				w[0][i][j] = i;//自己是首领 
				w[1][i][j] = j;
				ans++;//湖的数量 + 1 
				while(true)//循环直到没有可连的"W" 
				{
					bool ff = false;//定义一个ff，判断是否找到了任何一个可以连的"W" 
					for(int ii = 1; ii <= m; ii++)
					{
						for(int jj = 1; jj <= n; jj++)
						{
							if(w[0][ii][jj] == i && w[1][ii][jj] == j)//如果一个"W"的首领是上面枚举到的首领，就可以判断有没有和这个"W"相连的"W"了 
							{
								for(int k = 0; k < 8; k++)//八个方向 
								{
									if(q[ii + u[0][k]][jj + u[1][k]] == 'W' && !f[ii + u[0][k]][jj + u[1][k]])//如果是个"W"，且没有被连过 
									{
										f[ii + u[0][k]][jj + u[1][k]] = true;//改为连过了 
										w[0][ii + u[0][k]][jj + u[1][k]] = i;//把首领定义为上面枚举到的首领 
										w[1][ii + u[0][k]][jj + u[1][k]] = j;
										ff = true;//标记为这次循环连过"W"了(表示还有可连的"W")
									}
								}
							}
						}
					}
					if(!ff)//如果没有"W"可连了 
					{
						break;//退出 
					}
				}
			}
		}
	}
	printf("%d", ans);//输出 
	return 0;
} 
```

PS：迷宫问题也可以这么做