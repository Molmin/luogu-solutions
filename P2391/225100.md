总结一下这道题的做法
- 暴力模拟
- 并查集
- 双向链表+缩点
- 线段树
- 挂链+堆

以上都是目前的题解区里的题解。

在第一种算法中，题解区出现两篇，但是都极为简短，没有分析。

简化题意，$n$ 个数，$m$ 次操作，每次操作把第把第（$i*p+q$）%$N+1$ 个数到第（$i*q+p$）% $N+1$个数之间的所有数更新为$i$。

先进行最直接的暴力模拟，循环赋值覆盖。
```cpp
	for(i=1;i<=m;i++)
	{
		int a=(i*p+q)%n+1,b=(i*q+p)%n+1;
		int c=min(a,b),d=max(a,b);
		for(j=c;j<=d;j++)
		{
			s[j]=i;
		}
	}
	
```
时间复杂度$O(NM)$，期望得分20分，实际得分28分。

1、因为是后面的操作覆盖前面的操作，所以可以从后往前操作，如果目标区域被覆盖过了，就无需再覆盖。

2、因为操作是一个区域性的，所以一定是连续的，所以从左开始，一旦找到一个已经覆盖过的数，就可以break了，再从右开始，找到第一个已经覆盖过的数，break。

$Code$
```cpp
	for(i=m;i>=1;i--)
	{
		a=(i*p+q)%n+1,b=(i*q+p)%n+1;
		c=min(a,b),d=max(a,b);
		for(j=c;j<=d;j++)
		{
			if(st[j]) break;
			else {
				st[j]=1;
				s[j]=i;
			}
		}
		for(j=d;j>=c;j--)
		{
			if(st[j]) break;
			else {
				st[j]=1;
				s[j]=i;
			}
		}
	}
```
时间复杂度：$O(N)$，期望得分100分，实际得分100分

$Tips$：因为只有n个点需要覆盖，然后每个点只覆盖一次，所以总的时间是$O(N)$