VP div.3 首次过 E，撰题解以祭之。

- 更新日志：

  - 2022.7.14：代码链接挂了，于是还是把代码贴进了题解里（悲）

- 题意：

  在一个长度为 $n$，仅含小写拉丁字母的字符串 $s$ 中，你可以进行最多 $k$ 次如下操作：
  
  - 在 $s$ 中选一个字符，把 $s$ 中所有该字符 ASCII 码 $-1$（特别地，若选定 `a`，则变为 `z`）。
  
  问最后能得到的字典序最小的字符串。
  
- 解法：

  首先，容易发现的贪心思路是：
  
  - 不选定字符 `a`（否则白白浪费了一次操作还变大了字典序）
  - 优先考虑 $s$ 中前面的字符（要使字典序最小）
  
  于是考虑从头到尾处理 $s$：看当前字符需要减多少次才能变成 `a`，并把 $k$ 减去需要的次数，直到 $k$ 不够为止。
  
  但这会导致一些问题。比如如下数据：
  
  ```
  4 2
  abcc
  ```
  
  我们的程序是这样处理的：
  
  - 第一个字符 `a`，字典序已经最小。
  - 第二个字符 `b`，操作 $1$ 次后变为 `a`，$k$ 还剩 $1$。
  - 第三个字符 `c`，操作 $2$ 次后可以变为 `a`，但 $k$ 只剩 $1$ 了，因此只能操作 $1$ 次变成 `b`。
  
  输出为：`aabc`。
  
  但实际上可以直接把所有 `c` 变成 `b`，再把所有 `b` 变成 `a`，形成 `aaaa`。
  
  问题有两个：
  
  - 没有考虑前面已经完成的操作。
  
    则可以记录一个值 $\text{last}$，表示之前选中过的字典序最大的字母。那么只要这次选中的字符 $c$ 能在 $k$ 次内删到 $\text{last}$，就能变成 `a`——因为之前最大也是从 $\text{last}$ 减到 `a`，既然又能从 $c$ 减到 $\text{last}$，那么还不如直接从 $c$ 减到 `a` 呢。
  - 没有把所有选择的字符 ASCII 都 $-1$。
  
    同样使用上面的 $\text{last}$。如果当前字符字典序比 $\text{last}$ 小，那么就已经被换成了 `a`。
    
    当 $k$ 不够把当前字符 $c$ 删到 `a` 时，就把 $s$ 中 ASCII 在 $(c-k,c]$ 内的字符全部变为 $c-k$——在最后的 $k$ 次里，$c$ 变为 $c-1$，$c-1$ 变为 $c-2$，$\dots$，$c-k+1$ 变为 $c-k$，所以上述区间内的字符都可以如此变化。  
    当然，在这个过程中也可以顺便把其它字典序比 $\text{last}$ 小的字符替换成 `a`。最后输出即可。
    
  于是就没有问题了。
  
  ```cpp
  namespace{
  	int T;
  	const int lim=2e5+3;
  	int n,k;
  	char a[lim],last;
  	void solve(){
  		n=read();k=read();
  		F(i,1,<=n) a[i]=readc();
  		last='a';
  		F(i,1,<=n){
  			if(a[i]<=last) a[i]='a';
  			else if(a[i]-last>=k){
  				F(j,1,<=n){
  					if(i!=j&&a[j]>a[i]-k&&a[j]<=a[i]){
  						a[j]=a[i]-k;
  					}
  					if(a[j]<=last){
  						a[j]='a';
  					}
  				}
  				a[i]-=k;
  				if(a[i]<=last) a[i]='a';
  				break;
  			}else{
  				k-=a[i]-last;
  				last=a[i];
  				a[i]='a';
  			}
  		}
  		F(i,1,<=n) putchar(a[i]);
  		endl;
  	}
  	void work(){
  		T=read();
  		while(T--) solve();
  	}
  }
  ```