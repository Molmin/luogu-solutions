# 这是C++题解

显然，这道奶牛题的实质是通过题目要求的算式形式读入，以此要我们计算多个乘法乘积的和。

由于 _“不会出现如下几种形式：(1)23+++15-2、+23++(2)15-(1)2、23+++15-2+(0)100、23-(-3)15-2。”_ 所以在处理时可以就分为两种情况讨论：

1.没括号：统计加号（或减号）个数，和后面的数相乘，加（或减）到最终的答案中；

2.有括号：把括号内的数当做运算符的个数，然后和1同样操作。

显然，有如此长的算式的模拟题，没有字符串是难以操作的，所以直接把算式当做string读入是必要的。

由此可以得出以下代码
```cpp
#include<iostream>
#include<string>
#include<cmath>
using namespace std;
int i;//尽管不好，但由于很多操作较为繁琐，需要写成函数,而字符串的扫描大循环是计算的基础，不放在外面不好操作 
string s;//读入的算式 
void get(int &a)//得到被加（减）的数，需要带回去
{
	a=0;//不加会因为叠加问题而错误 
	for(;s[i]>='0'&&s[i]<='9';i++)//在下一个运算前所有的数字都是一个数，前面高位后面低位，先读高位，不断*10，把高位向高处挪，空出的高位留给小位
		a*=10,a=a+s[i]-'0';//直接加字符0会错得很惨 
}
int main(){
	int /*算式长度*/n,/*最终答案*/ans=0,/*符号个数*/t=0,/*运算数*/num=0,/*符号，如果是减号就就等于-1，如果是正数就是1*/nowf;
	cin>>s;
	n=s.length();
	if(s[0]>='0'&&s[0]<='9')s="+"+s;//最前面没有符号就相当于一个加号，可以加上，方便运算 
	for(i=0;i<n;i++)
	{
		if(s[i]=='+'||s[i]=='-')//数前面的运算符 
		{
			t++;
			if(s[i]=='+')nowf=1;
			if(s[i]=='-')nowf=-1;
		}
		else//如果前面的运算符数完了可以分情况讨论了 
		{
			if(s[i]>='0'&&s[i]<='9')//后面是运算数，第一种情况 
			{	
				get(num);//得到运算数 
				i--;//get函数会到第一个后面的运算符时返回，要减掉，不然后面会少数一个运算符 
				ans+=num*t*nowf;//加到答案里 
				num=t=0;//快乐置零 
			}
			if(s[i]=='(')//后面时括号，第二种情况 
			{
				i++;//从括号后的数开始数 
				get(t);
				i++;//跳过右括号才能搞运算数 
				get(num);
				i--; 
				ans+=t*num*nowf;
				num=t=0;
			}
		}
	}
	cout<<ans;//输出答案 
	return 0;
}
```

各种测试没有错误后提交，发现只有40分，第二个点错了，和后面的5个点也错了看底下的说明与提示：

### “算式长度不超过2000”

仔细想一想，发现如果是就减一个1999位的数那不要高精度不挂就怪了而且可能有高精负数，这会是一个浩大的工程。~~对于我这样的蒟蒻，不调个大半年肯定是出不来的，而对于大佬，高精？不是秒秒钟写出来的简单算法吗。~~

高精的写法在此不做过多阐述，只是说明要用哪些：

1.带负数高精度加(减)法:每次乘积加入答案；

2.带负数高精度乘法：运算符个数乘运算数；

3.高精度加单精度（高精度数加一）：上方所述第一种情况的运算符个数

以下是本蒟蒻的代码
```cpp
#include<iostream>
#include<string>
#include<cmath>
using namespace std;
//我是分割线------------------------------------------------------------------------------------------------------------------------------------------------------
string s;
int i;
//不解释 
//我是分割线------------------------------------------------------------------------------------------------------------------------------------------------------
void add(int a[],int b[])//高精加法 
{
	int j,jw=0/*进位*/,c[2001]/*答案数组*/;
	for(j=0;j<=2000;j++)c[j]=0;
	c[0]=max(a[0],b[0]);
	for(j=1;j<=c[0];j++)
	{
		c[j]=a[j]+b[j]+jw;
		jw=c[j]/10;
		c[j]%=10;
	}
	if(jw>0)c[++c[0]]=jw;
	for(j=0;j<=c[0];j++)b[j]=c[j];
}
//我是分割线------------------------------------------------------------------------------------------------------------------------------------------------------
void add1(int a[],int x)//高精加单精 
{
    int j,jw=0;
    a[1]+=x;
    for(j=1;j<=a[0];j++)
    {
        a[j]+=jw;
        jw=a[j]/10;
        a[j]%=10;
    }
    if(jw>0)a[++a[0]]=jw;
}
//我是分割线------------------------------------------------------------------------------------------------------------------------------------------------------
void cheng(int a[],int b[],int c[])//乘法 
{
	int j,k;
	long long jw=0;
	for(j=0;j<=2000;j++)c[j]=0;
	c[0]=a[0]+b[0]-1;
	for(j=1;j<=a[0];j++)
		for(k=1;k<=b[0];k++)
			c[j+k-1]+=a[j]*b[k];
	for(j=1;j<=c[0];j++)
	{
		c[j]+=jw;
		jw=c[j]/10;
		c[j]%=10;
	}
	if(jw>0)
		while(jw>0)
		{
			c[++c[0]]=jw%10;
			jw/=10;
		}
}
//我是分割线------------------------------------------------------------------------------------------------------------------------------------------------------
void jian(int a[],int b[],int c[])//高精减法 
{
	int j,jw=0;
	for(j=0;j<=2000;j++)c[j]=0;	
	c[0]=max(a[0],b[0]);
	for(j=1;j<=c[0];j++)
	{
		c[j]=a[j]-b[j]-jw;
		jw=0;
		if(c[j]<0){jw=1; c[j]+=10;}
	}
	for(j=c[0];j>1&&c[j]==0;j--)c[0]--;	
}
//我是分割线------------------------------------------------------------------------------------------------------------------------------------------------------
void get(int a[])//不解释 
{
    int j;
    string number="";
    char c;
	//a=0;
	for(;s[i]>='0'&&s[i]<='9';i++)
	{
		c=s[i];
	    number=c+number;
	}
	a[0]=number.length();
	for(j=1;j<=a[0];j++)a[j]=number[j-1]-'0';
	//	a*=10,a=a+s[i]-'0';
}
//我是分割线---------------------------------------------------------------------------------------------------------------------------------------------
bool big(int a[],int b[])//为了解决负数和正数加减后是正是负的问题 
{
	int j;
	if(a[0]!=b[0])
		if(a[0]>b[0])return true;
			else return false;
	for(j=a[0];j>=1;j--)
	{
		if(a[j]>b[j])return true;
		if(a[j]<b[j])return false;
	}
	return true;
}
//我是分割线------------------------------------------------------------------------------------------------------------------------------------------------------
int main(){
//	int n,ans=0,t=0,num=0,nowf;
    int n,nowf,zheng[2001],fu[2001],t[2001],num[2001],ans[2001],j,tt[2001];
    for(i=1;i<=2000;i++)num[i]=ans[i]=zheng[i]=fu[i]=t[i]=0;
    tt[0]=num[0]=ans[0]=zheng[0]=fu[0]=t[0]=1;
    tt[1]=num[1]=ans[1]=zheng[1]=fu[1]=t[1]=0;
	cin>>s;
	if(s[0]>='0'&&s[0]<='9')s="+"+s;
	n=s.length();
	for(i=0;i<n;i++)
	{
		if(s[i]=='+'||s[i]=='-')
		{
			add1(t,1);
			if(s[i]=='+')nowf=1;
			if(s[i]=='-')nowf=-1;
		}
		else
		{
			if(s[i]>='0'&&s[i]<='9')
			{	
				get(num);
				i--;
				cheng(t,num,tt);//	ans+=num*t*nowf;
				if(nowf==-1)add(tt,fu);
				if(nowf==1)add(tt,zheng);
				for(j=1;j<=2000;j++)
					tt[j]=t[j]=num[j]=0;
				tt[0]=t[0]=num[0]=1;//	t=0; num=0;
			}
			if(s[i]=='(')
			{
				i++;
				get(t);
				i++;
				get(num);
				i--;
				cheng(t,num,tt);
				//	ans+=t*num*nowf;
				if(nowf==-1)add(tt,fu);
				if(nowf==1)add(tt,zheng);
				for(j=1;j<=2000;j++)
					tt[j]=t[j]=num[j]=0;
				tt[0]=t[0]=num[0]=1;//	t=0; num=0;
			}
		}
	}
	if(big(zheng,fu))jian(zheng,fu,ans);
	else
	{
		cout<<'-';
		jian(fu,zheng,ans);
	}
	for(i=ans[0];i>=1;i--)cout<<ans[i];
//	cout<<ans;
	return 0;
}
```
### 以上便是本蒟蒻的题解的全部，请不要复制代码，多打这类长的模拟题可以提高任何人的代码能力。