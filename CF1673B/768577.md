# 题目
[CF1673B题目传送门](https://www.luogu.com.cn/problem/CF1673B)
# 分析
这题思维部分个人觉得挺巧妙的。

首先，我们对题目中的三元组的定义进行转换：其实就是**对于每一个子串，出现次数最多的字符比出现次数最少的字符的出现次数之差不多于 $1$ 。**接下来，我们就可以更深入地分析了。

我们设 $k$ 为字符串中出现的字符种类的数量，设 $s$ 为原字符串，下标从 1 开始。现在，我们看从 $s_1$ 到 $s_{k+1}$ 这个区间。分析可得区间内至少有 1 个字符出现次数超过 1 次（抽屉原理）。为了让它满足要求，显然不能有任意一个在 $s$ 中出现过的字符没有出现在这个区间中，那就说明只有 1 个字符出现了 2 次，其余都出现 1 次。同时这个出现了两次的字符必须是 $s_1$ 和 $s_{k+1}$ （不然以这两个字符为首尾的区间中，就会存在有字符出现 0 次了）。于是可得： $s_1 = s_{k+1}$ 。 同理，我们可以推出**对于所有的 $i \in [1,n-k]$ ，都有 $s_i = s_{i+k}$ 。**

有了这个结论之后，显然就非常好做了：**看看字符串是否符合刚才上面的那个结论，符合即为 YES ，否则为 NO 。**

这时候可能有人会问：那一开始从 $s_1$ 到 $s_k$ 的子串中，万一本来就没凑齐 $k$ 种不同的字符怎么办？没有关系，因为那些出现在了 $s$ 中但不在这个子串中的字符，必然会在后面某个地方冒出来，也必然会和前面的某个字符产生冲突，让答案变成 NO 。
# 代码
看完上面的分析，特别是加粗的部分之后，应该就是一道可以简单地用**贪心**解决的问题，时间复杂度 $O(nt)$ 。以下是代码，附注释。特别地短，是吧？
```cpp
#include<bits/stdc++.h>
using namespace std;
int t, n;
char cr[200005];
void solve(){
	scanf("%s", cr); // 输入 
	n = strlen(cr); // 计算长度 
	int cnt[26] = {}, k = 0; // cnt 统计每种字符出现数量，k 即共有多少种字符 
	for(int i = 0; i < n; i++)
	if(0 == cnt[cr[i] - 'a']++) k++; // 如果是新的一种字符，k++ 
	for(int i = k; i < n; i++) // 对于每一组下标相差 k 的两个字符 
	if(cr[i] != cr[i - k]){ // 判断是否相同（满足上述推论） 
		printf("NO\n"); // 不相同，答案为 NO 
		return ;
	}
	printf("YES\n"); // 没有问题，答案为 YES 
}
int main(){
	scanf("%d", &t);
	while(t--)
	solve(); // 多组测试数据 
	return 0; // 华丽地结束！ 
}
```
## 代码仅供参考