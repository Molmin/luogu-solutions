[传送门](https://www.luogu.com.cn/problem/P9228)


赛时因为这个挂了 $84$ 分，痛失 $300$ 的机会。


贪心。


因为每个攻击都是最终都可以取，所以我们要想他这个“额外价值”最大。

一种假的贪心是贪心取当前造成伤害的最大值，但是可能两个点初始相对差很大，但是较小另一个点的额外伤害多，我们应该是取那个额外伤害多的。

比如说 $k=10$ 时 $a$ 为 $9$，$b$ 为 $1$，应该是取 $b$ 而不是 $a$，取 $b$ 造成多 $10$ 点的额外伤害，而 $a$ 只有 $9$ 点。

（尽管当前看起来是 $18>11$ 但是如果我剩下的都不触发技能的话是 $18+1>11+9$ 的，原因是他们原本的“底数” $1+9$ 不变，而选 $b$ 的增加的比选 $a$ 多，所以选 $b$ 优于 $a$）


我们考虑先进行排序。

- 对于一个 $a_i$，取他加上一个蓝色技能，就多出来 $a_i$ 的贡献。

- 对于一个 $b_i$，取他加上一个红色技能，就多出来 $k$ 的贡献。

所以，我们考虑从后往前。

如果当前 $a_i$ 产生出来的贡献 $a_i$ 的大于 $b_i$ 的贡献 $k$，那么我们就先取 $a_i$。带上最小的 $b_i$ （其实带那个都无所谓，因为 $b_i$ 造成的额外贡献相同。）由于造成额外贡献是有次数限制的，每次都要拿上相对的一个技能，所以我们贪心地去拿最大的。

同理，如果 $b_i$ 产生的贡献 $k$ 大于 $a_i$ 的贡献，那我们就拿 $b_i$，同时应该带上最小的 $a_i$，因为越大的 $a_i$，造成的额外贡献就越多，所以我们应该保存更大的 $a_i$，将来让他造成更多的贡献。

找到当前最小，最大的 $a_i$，$b_i$，用双指针维护即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N =1e6+10;
#define int long long
int a[N],b[N];
signed main()
{
    int n,m,k;
    cin>>n>>m>>k;
    for(int i=1;i<=n;i++)   cin>>a[i];
    for(int i=1;i<=m;i++)   cin>>b[i];
    sort(a+1,a+n+1),sort(b+1,b+m+1);
    int l1=1,r1=n,l2=1,r2=m,ans=0;
    while(1){
        if(l1>r1){
            for(int i=l2;i<=r2;i++) ans+=b[i];
            break;
        }
        if(l2>r2){
            for(int i=l1;i<=r1;i++) ans+=a[i];
            break;
        }
        if(a[r1]>k) ans+=(a[r1]*2+b[l2]),r1--,l2++;
        else if(a[r1]<k)    ans+=(a[l1]+b[r2]+k),l1++,r2--;
        else{
            if(a[l1]>=b[l2])    ans+=(a[r1]*2+b[l2]),r1--,l2++;
            else    ans+=(a[l1]+b[r2]+k),l1++,r2--;
        }
    }
    cout<<ans<<endl;
    return 0;
}
```
