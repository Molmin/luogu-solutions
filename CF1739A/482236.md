还是比较水的一道入门题，方法很多，这里列出两种思路。

1. 一般思路，考虑具有不能移动的格子的棋盘大小。假设棋盘大小为 $n\times m$（$n$ 行 $m$ 列）。不妨 $n\ge m$，分几种情况讨论：
> - 如果 $m=1$，那么一定存在，取任意一格（参考样例）。
> - 如果 $m=2$，那么在 $n\le3$ 时存在，取第 $2$ 行任意一格。
> - 如果 $m=3$，那么在 $n=3$ 时存在，取第 $2$ 行第 $2$ 列。

由此，可以归纳成 $3$ 种情况（这里不假设 $n\ge m$）：
- 当 $n=1$ 或 $m=1$ 时，存在，取任意一格，比如 `1 1`。
- 当 $2\le n\le3$ 且 $2\le m\le 3$ 时，存在，取 `2 2`。
- 当 $n\ge4$ 或 $m\ge4$ 时，不存在，取任意一格。

最简单的写法为第三种情况取 `2 2`，代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
int t,n,m;
int main() {
	cin>>t;
    for (int i=1;i<=t;i++) {
    	cin>>n>>m;
        if (n==1||m==1) cout<<"1 1\n";
        else cout<<"2 2\n";
    }
    return 0;
}
```

2. 提供另一种思路。在棋盘中的一格中，若从它开始不可移动，那么即相当于在它把棋盘划分成的四个区域中没用足够移动的空间。（如图，图中点即为棋盘上的格子）

![图片](https://cdn.luogu.com.cn/upload/image_hosting/00935ap8.png)

图中以紫色线段为分界，$4\times5$ 的棋盘被划分成了四个区域。只用考虑黄色部分，其余区域在两个维度均不超过黄色区域。而蓝色点在黄色区域中可以到达两个其他点，因此蓝色点不是不可移动的。

考虑将蓝色点上升一个方格，若如此做，则右上角区域依然是最大的，但它在两个维度均不超过原来区域。因此，如果一个图中存在不可移动的格子，那么最靠近中心的格子必定不可移动。

如果不存在，输出最靠近中心的格子也没有问题。贴上代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
int t,n,m;
int main() {
	cin>>t;
	for (int i=1;i<=t;i++) {
		cin>>n>>m;
		cout<<(n+1)/2<<' '<<(m+1)/2<<endl;
	}
    return 0;
}
```