[传送门](https://www.luogu.com.cn/problem/AT4299)

#### 题意：

* 有 $n$ 个开关，每个开关都只可能是“开”或“关”中的一种。

* 有 $m$ 个灯泡，第 $i$ 灯泡连接着若干个开关，当这些开关中“开”的数量模 $2$ 余 $p_i$ 时，可以电亮这个灯泡。

* 问有多少种“开”“关”的组合可以点亮所有灯泡。

* $1 \le n,m \le 10$

#### 分析：

注意到 $n \le 10$，可以考虑枚举。不妨设“开”状态为 $1$，“关”为 $0$，那么我们可以开一个数组 $a$ 来存每个开关的状态。

检查一个状态是否可行时，可以考虑枚举所有灯泡，每一个灯泡求出对应开关中“开”着的数量之和，再直接判断模 $2$ 的值。复杂度是 $\Theta(2^nmn)$，~~惊人地~~可行。

#### 思路：

1. 枚举开关状态。

2. 对于每一个状态，枚举每个灯泡，判断是否亮着。如果所有灯泡都亮着，答案加一。

---

具体实现参考代码。

---

```cpp
#include <bits/stdc++.h>
using namespace std;
int n, m, ans, a[12];
int p[12];
int k[12], s[12][12];
void dfs(int x) {	//定义了一个行为 dfs，表示选择第 x 个灯泡的状态。 
	if(x>n) {	//如果 x 大于 n，那么说明已经选完了。 
		for(int i=1; i<=m; i++) {	//枚举灯泡 
			int sum=0;
			for(int j=1; j<=k[i]; j++) {
				if(a[s[i][j]]==1) sum++;	//如果开关开着，那么 sum++ 
			}
			if(sum%2!=p[i]) return;	//这表示有灯泡没亮，所以对答案没有贡献，直接返回上一层 
		}
		ans++;	//所有灯泡都开亮着，ans++ 
		return;
	}
	a[x]=0, dfs(x+1);	//枚举 x 的状态，并开始选下一个开关。 
	a[x]=1, dfs(x+1);
}
int main() {
	cin>>n>>m;	//输入部分。k,s,p 数组的意义如题。 
	for(int i=1; i<=m; i++) {
		cin>>k[i];
		for(int j=1; j<=k[i]; j++) {
			cin>>s[i][j];
		}
	}
	for(int i=1; i<=m; i++) cin>>p[i];
	dfs(1);	//选择第一个开关的状态。 
	cout<<ans<<endl;
	return 0;
}
```

抄代码可耻 qwq

---

##### update: 

5.27 修改了几处笔误。