**题意**  
其实题解里已经有大佬讲明白了，我就再复述一遍吧。  
- 有 $n$ 个开关， $m$ 盏灯，每盏灯有若干个开关控制。  
- 对于第 $i$ 只有当控制它的开关开的数量模 $2$ 余 $p_i$ 时，这盏灯才会被打开。
- 求有多少种开关“开”、“关”的方案，使得所有的灯都被打开。

**分析**  
开关只有“开”和“关”两种状态，那么我们就会~~很自然~~地想到每个数位只有 $0$ 和 $1$ 两种状态的二进制数了。

对于每一个不超过 $10$ 位的二进制数，第 $i$ 位代表着第 $i+1$ 个开关的“开”和“关”的情况。若该位为 $0$ 则代表该开关为“关”的状态，若该位为 $1$ ，则代表该开关为“关”的状态。

因为 $1\ \leq\ N,\ M\ \leq\ 10 $ ,所以我们可以直接暴力枚举。

**代码**
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,p[20],a[20][20],num[20],ans;
bool check(int x){//判断该二进制数所代表的开关状态能否打开所有灯
                                    //能就返回true,不能返回false
    for(int i=1;i<=m;i++){
        int s=0;
        for(int j=1;j<=num[i];j++){
            if(x&(1<<a[i][j])){//判断控制第i盏灯的第j个开关的“开”或“关”的情况
                s++;
            }
        }
        if(s%2!=p[i])return false;
    }
    return true;
}
int main(){
    cin>>n>>m;
    for(int i=1;i<=m;i++){
        cin>>num[i];
        for(int j=1;j<=num[i];j++){
            cin>>a[i][j];
            a[i][j]--;//将开关编号指向对应的二进制数位
        }
    }
    for(int i=1;i<=m;i++){
        cin>>p[i];
    }
    for(int i=0;i<1<<n;i++){//暴力枚举并判断
              //因为最多只会有2^n种情况，所以我们从0枚举到2^n-1就行了
        if(check(i)){
            ans++;
        }
    }
    cout<<ans<<endl;
    return 0;
}
```

完结撒花