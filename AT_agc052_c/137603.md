> [AGC052C] Nondivisible Prefix Sums
>
> 对于质数 $p$，定义一个长为 $n$，值域为 $[1,p-1]$ 中整数的序列 $a$ 是好的，当且仅当存在一个 $1$ 到 $n$ 的排列 $\mathcal{P}$ 满足：
> - 对于所有的 $1\le i\le n$，都有 $\sum\limits_{j=1}^i a_{\mathcal{P}_j}$ 不是 $p$ 的倍数。
>
> 给出 $n,p$，求有多少好的序列。($1\le n\le 5\times 10^3,1\le p\le 10^8$)

注意到这个任意重排的限制很松，所以我们来考虑什么样的序列即使在这么松的限制下都不是好的。

显然，如果 $a$ 的序列和是 $p$ 的倍数，那就寄了，接下来我们不考虑这种情况。然后我们考虑把任意重排的过程视为不断从其中选择一个元素，则我们考虑坏的情况一定是我们被强制选择一个刚好使得当前序列模 $p$ 余 $0$。而能使得序列非法的数只有一个，也就是说，只有在剩下的数全部相同时才会出现这种情况。

这启发我们，坏的序列一定是存在某个数出现了太多次。不妨设这个数为 $1$。（这样比较好分析，对于其他数 $x$ 的情况，我们只需要乘一个 $x$ 的逆元就能转化到这里了，显然序列的好坏不变）不妨设剩下 $>1$ 数形成的序列为 $b$。

注意到手里剩下太多相同的数会出问题，所以我们优先打出 $1$。这里可以打出 $p-1$ 个。然后我们打出 $b_1$，之后又能打出 $p-b_1$ 个 $1$。以此类推，我们最多能消耗掉 $p-1+\sum\limits_i p-b_i$ 个 $1$。我们考虑如果 $1$ 不到这个数会不会出问题。考虑 $1$ 用完的时刻，此时由于 $1$ 是原来的众数，所以剩下所有数的出现次数都不超过这个值，这样变成了一个类似的子问题，且限制更松。所以可以发现，$1$ 的个数不超过上述上界是好序列的必要条件。

既然发现一个必要条件，我们来考虑这个条件是否充分。注意到事实上我们需要跳过 $kp,k\in \mathbb{N}_+$ 这些地方，而每次跳过都需要一个 $>1$ 的数，而由于 $1$ 的个数超过上述上界，所以整个序列的和至少是 $(|b|+1)p+1$，即我们需要跳过至少 $|b|+1$ 次 $p$ 的整数倍，而只有 $|b|$ 个数给我们用，显然无解。

所以 $1$ 的个数不超过 $p-1+\sum\limits_i p-b_i$ 且 $1$ 是众数是序列是好的的充要条件。

我们考虑怎么对这个东西计数。$1$ 是众数的条件非常难受，且注意到假设我们直接设朴素状态 $f_{i,j}$ 表示长为 $i$ 的序列，$\sum p-x$ 为 $j$ 的方案数，统计答案的时候需要统计 $n-i\le j+p-1$，这东西 $j$ 可以很大，无法统计。

事实上，就像我们刚刚说的，好的序列看起来就很多。所以我们不妨反过来统计坏的序列。此时首先 $n-i>j+p-1$ 的话，$j$ 就有一个显然的很小的上界。不仅如此，注意到一旦 $1$ 的个数大于上界，显然 $1$ 一定是绝对众数。所以我们的统计就变得简单多了。

按照上述 $\rm dp$ 朴素转移，每次选择的数值域是 $[1,p-2]\cap \mathbb{Z}$，前缀和优化转移即可。得到完整的 $f_{i,j}$ 后，如果 $n-i\ge j+p$ 且 $n-i\not\equiv j\pmod{p}$，就把 $f_{i,j}\binom{n}{i}$ 统计入坏序列个数。然后我们对这一部分的序列，需要乘上 $p-1$。注意到此时如果是坏序列，绝对众数是唯一的，所以不会算重。

接下来的问题变为了如何求出和为 $p$ 的倍数的序列。我们考虑一项一项填，只要前 $i-1$ 项之和不是 $p$ 的倍数，第 $i$ 项就有唯一的填的方案。通过递推可得长度为 $n$ 的序列方案为：
$$\sum_{i=1}^{n-1}(p-1)^i(-1)^{n-1-i}$$
等比数列求和可得方案数为：
$$\dfrac{(p-1)^n+(-1)^n(p-1)}{p}$$
所以坏的序列个数我们就求完了，减一下即可。

时间复杂度 $\mathcal{O}(n^2)$。
```cpp
#include <cstdio>
#include <algorithm>
const int N = 5e3 + 10, mod = 998244353; int f[N][N], C[N][N], pre[N];
inline int sum(int l, int r) { return (pre[r] + mod - (!l ? 0 : pre[l - 1])) % mod; } 
inline void mo(int& x) { x >= mod ? x -= mod : x; }
inline int ksm(int a, int b)
{
	int ret = 1;
	while (b)
	{
		if (b & 1) ret = 1ll * ret * a % mod;
		a = 1ll * a * a % mod; b >>= 1;
	}
	return ret;
}
int main()
{
	int n, p; scanf("%d%d", &n, &p);
	f[0][0] = C[0][0] = 1;
	for (int i = 1; i <= n; ++i)
	{
		C[i][0] = 1;
		for (int j = 1; j <= i; ++j)
			C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % mod;
	}
	for (int i = 0; i <= n; ++i) pre[i] = 1;
	for (int i = 1; i <= n; ++i)
	{
		for (int j = 1; j <= n; ++j)
			f[i][j] = sum(std::max(0, j - p + 2), j - 1);
		pre[0] = 0;
		for (int j = 1; j <= n; ++j)
			pre[j] = (pre[j - 1] + f[i][j]) % mod;
	}
	int tot = 0;
	for (int i = 0; i <= n; ++i)
		for (int j = 0; j <= n; ++j)
			if (n - i >= j + p && (n - i) % p != j % p) 
				mo(tot += 1ll * f[i][j] * C[n][i] % mod);
	tot = 1ll * tot * (p - 1) % mod;
	mo(tot += 1ll * ksm(p, mod - 2) * (ksm(p - 1, n) + ((n & 1) ? (mod - p + 1) : (p - 1))) % mod);
	int ans = (ksm(p - 1, n) + mod - tot) % mod;
	printf("%d\n", ans); return 0;
}
```