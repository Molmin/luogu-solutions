# 前言

本篇题解大多数内容来自 [CF 官方题解](https://codeforces.com/blog/entry/92951)，并添加了个人理解。（其实不加也没有关系，挺详细的）

# 正文

## 定义

我们让 $l_1 ..... l_n$ 表示 $n$ 行，$l_{n+1}......l_{2n}$ 表示 $n$ 列， $l_{2n+1}$ 和 $l_{2n+2}$ 表示两条对角线。我们统称他们为直线。

另外，我们令 $P(A)$ 表示直线 $A$ 被选择的概率，即直线 $A$ 所表示的行（假定为行）上的数全为 $1$ 的概率，令 $P(\overline{A})$ 表示 $A$ 的补集，即直线 $A$ 所表示的行上的数不全为 $1$ 的概率（也就是至少有一个 $0$）。一个显然的性质为：$P(A)+P(\overline A) = 1$。（集合 $+$ 他的补集 $=$ 全集）

## 题解

对于直接求至少有一行（/列/对角线）全为 $1$ 的概率的话挺好求的——直接运用容斥原理即可。但是这种思路很难优化——不能用 dp 来降低复杂度（原因看完后再思考）。所以我们考虑求他的补集，即求全部的行（/列/对角线）都至少存在一个 $0$ 的概率。化为公式即为：

$$
P(\overline{l_1} \cap \overline{l_2} \cap......\cap \overline{l_{2n+1}})
$$

我们发现这个东西很难办（暂时不考虑行与列之间的关系），我们想要把他转化的简单一些，即通过一些计算把 $\overline {l_1}$ 去掉。

首先，我们能知道以下几条公式：

**1.**

$$
P(A \cap B) = P(A|B)P(B)
$$

这条公式基于[条件概率](https://baike.baidu.com/item/%E6%9D%A1%E4%BB%B6%E6%A6%82%E7%8E%87/4475278?fr=aladdin)可得这是对的，即 $A$ 与 $B$ 同时发生的概率等同于 $A$ 在条件 $B$ 下发生的概率乘以 $B$ 发生的概率。（其中 $P(AB)$ 与 $P(A \cap B)$ 表示的意思等同）

**2.**

$$
P( \overline A \cap B) + P(A \cap B) = P(B)
$$

因为$P(\overline A \cap B)=P(\overline A|B)P(B)$，$P(A \cap B)=P(A|B)P(B)$，所以：

$$
P( \overline A \cap B) + P(A \cap B)= P(A|B)P(B)+P(\overline A|B)P(B)=P(B)
$$

依据[全概率公式](https://baike.baidu.com/item/%E5%85%A8%E6%A6%82%E7%8E%87%E5%85%AC%E5%BC%8F/9980676?fr=aladdin)可得这是对的。

然后根据上面的公式我们可以推出来下面的式子：

$$
P(l_1 \cap \overline {l_2} ..... \cap \overline {l_{2n+1}}) + P(\overline{l_1} \cap \overline{l_2} \cap......\cap \overline{l_{2n+1}}) = P(\overline {l_2} ..... \cap \overline {l_{2n+1}})
$$

$$
P(l_1 \cap \overline{l_2} ..... \cap \overline{l_{2n+1}})=P(\overline{l_2} ..... \cap \overline{l_{2n+1}}|l_1)P(L_1)
$$

然后根据上面两个式子结合可以得到下式：

$$
P(\overline{l_1} \cap \overline{l_2} \cap......\cap \overline{l_{2n+1}})=P(\overline l_2 \cap ...... \overline {l_{2n+1}})-P(\overline{l_2} \cap......\cap \overline{l_{2n+1}}|l_1)P(l_1)
$$

也就是说明我们求 $l_1......l_n$ 都满足条件（至少有一个为 $0$）转化为求 $l_2....l_n$ 都满足条件。

同理，上面的式子也可以用容斥原理来解释:

* 求 $l_1......l_{2n+1}$ 都满足条件的话，可以转化为 $l_2......l_{2n+1}$ 都满足条件的情况下 $l_1$ 满足条件的概率。直接算 $l_1$ 满足条件的概率的话不好算，我们转化为在全集（在 $l_2......l_{2n+1}$ 的情况下）减去不合法的情况（$l_1$ 不满足条件，即全为 $1$）。

（这样就没有那么绕了。）

为了求解上述问题，我们定义 $f(i,S)$ 表示 $P(\overline {l_i}......\overline {l_{2n+1}} |l_{s_1} \cap ...... l_{s_k})$，其中 $S= \{s_1,s_2......s_k\},S \in \{1,2,3......i-1\}$。也就是我们指定 $k$ 条直线满足全选 $1$ 的情况下从第 $i$ 条直线开始满足条件（至少有一个为 $0$）的概率。我们模仿上面的式子，有：

$$
f(i,S)=f(i+1,S) - f(i+1,S \cup \{i\})P(l_i|l_1 \cap ...... \cap l_k)
$$

这里特别说明一下 $P(l_i|l_1 \cap ...... \cap l_k)$ 怎么求。因为此时 $l_1 ...... l_k$ 都已存在（全为 $1$）。我们把 $l_i$ 这条直线上已经存在（也就是和 $l_1......l_k$ 相交的格子）去掉，剩下的所有格子（在 $l_1$ 上）的乘积。

考虑边界的情况，也就是 $f(2n+3,S)$，他的初值为 $1$。（因为他转移时充当的作用是全集，因为赋为 $1$）。

那么答案就是 $1-f(1,\{\})$。（全集就是随便选，概率为 $1$）。

但是，由于我们有 $2n+3$ 条直线，时间复杂度为 $\mathcal O(n2^{2n+3})$，时间复杂度严重超纲。

首先，因为我们是根据条件概率进行转化，我们可以用容斥原理代替其中一部分 dp。具体的，因为直线分成三类：行，列和对角线。而行与行之间互相不干扰，也就是说用行做条件是不能对另一些行产生影响的。因此，我们可以把他们分开考虑。（先不考虑对角线）

即我们暴力枚举行的情况，然后用 dp 计算固定的行所产生的列的影响，因为此时列加不加入条件都不会对后面的列造成影响，所以上面的式子：

$$
f(i,S)=f(i+1,S) - f(i+1,S \cup \{i\})P(l_i|l_1 \cap ...... \cap l_k)
$$

可以简化为：

$$
f(i,S)=f(i+1,S) - f(i+1,S)P(l_i|l_1 \cap ...... \cap l_k)
$$

然后列就可以做到 $\mathcal O(n)$ dp 了。

（注：此时上面的 dp 没有计算固定行全为 $1$ 的概率，但我们假装他算了）

然后我们再考虑行的贡献。因为此时 $f(n+2,S)$ 表示选择哪些行全为 $1$，其他行不考虑，列满足条件（不全为 $0$） 的概率。我们发现这个东西好像套不进上面的 dp 里。

但你会发现上面 $f$ 的定义和容斥原理的定义很像，因此可以用容斥原理计算。（全集 $-$ 至少有一行全为 $1$ $+$ 至少有两行全为 $1$ ......）

虽然上面的容斥看起来不是很对的样子（虽然和前面的 dp 差不多），加个括号就明显很多了：全集 $-$ （至少有一列全为 $1$ $-$ 至少有两列全为 $1$ $+$ 至少有三列全为 $1$ 的概率......）。

容易发现，括号里算的是至少有一条直线全为 $1$ 的数量，全集减去他恰好就是全部直线都满足条件（至少有一个为 $0$）的数量。所以说绕了一圈又绕回来了。

再来考虑对角线怎么计算，因为对角线只有两条，所以我们可以把对角线视为行来暴力做（虽然他对行也产生干扰，但这个干扰可以用容斥消去，那么只剩他对列的干扰，此时就无所谓了）。复杂度为 $\mathcal O(n^22^{n+2})$。

因为其中的一个 $\mathcal O(n)$ 的时间复杂度为枚举 $P(l_i|l_1 \cap ...... \cap l_k)$，大佬们可以用各种神仙方法优化（这里用预处理优化）成 $\mathcal O(1)$。


## 实现

上面式子：

$$
f(i,S)=f(i+1,S) - f(i,S)P(l_i|l_1 \cap ...... \cap l_k)
$$

优化后是这样：

$$
f(i,S)= (f(i+1,S) - f(i+1,S) \times mul[i][U \oplus S])\times mul[i][S]
$$

上面的 $mul[i][s]$ 表示第 $i$ 列，此时行选择的情况（全为 $1$ 的情况）为 $S$，这些行与第 $i$ 列的相交的格子的乘积。$U$ 表示全集，即 $U =\{1,2,3......n\}$，$\oplus$ 表示异或。

（注：此时上面的 dp 顺带计算固定行全为 $1$ 的概率，也就是那个 $mul[i][S]$）

然后代码中简写为 

$$
f(S)= ( 1- mul[i][U \oplus S])\times mul[i][S] \times f(S)
$$

代码~~贴贴~~：

```cpp
#include<bits/stdc++.h>
#define lowbit(x) (x&(-x))
using namespace std;
const int N=22,mod=31607;

int n,ans;
int lg[1<<N];
int f[1<<N];
int a[N][N];
int mul[N][1<<N];
int inv100=3973; 
//10000 的逆元
signed main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
        for(int j=1;j<=n;j++)
            {scanf("%d",&a[i][j]);a[i][j]=1ll*a[i][j]*inv100%mod;}
    lg[1]=1;
    for(int i=2;i<=(1<<n);i++)lg[i]=lg[i>>1]+1;
    //lg[i] 表示二进制数为 i 的最高位为 1 的位是第几位
    for(int i=1;i<=n;i++)
    {
        mul[i][0]=1;
        for(int S=1;S<(1<<n);S++)
        {
            int j=lowbit(S);
            mul[i][S]=1ll*mul[i][S^j]*a[lg[j]][i]%mod;
            //预处理，从上一个与他只差一个 1 的位置继承
        }
    }
    for(int T=0;T<4;T++)
    {
        for(int S=0;S<(1<<n);S++)
            if((__builtin_popcount(S)+__builtin_popcount(T))&1)f[S]=1;else f[S]=-1;
            //预处理容斥系数，__builtin_popcount(S) 是用来计算 S 转化成二进制后 1 的数量
        for(int i=1;i<=n;i++)
            for(int S=0;S<1<<n;S++)
            {
                int s=S;
                if(T&1)s|=1<<(i-1);
                if(T&2)s|=1<<(n-i);
                //考虑将此时的对角线视为行加上贡献
                f[S]=1ll*f[S]*mul[i][s]%mod*(1-mul[i][((1<<n)-1)^s]+mod)%mod;
            }
        for(int S=0;S<(1<<n);S++)ans=(ans+f[S])%mod;
    }
    printf("%d\n",(ans+1)%mod);
    // 全集 - 补集
    return 0;
}
```

# 后记

我总算知道了为什么不直接算了，因为他那个 dp 要考虑集合和补集的关系，直接算你想不到的（应该吧，小声 bb）。
