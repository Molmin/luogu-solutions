似乎在大家眼里是比较基础的容斥题诶（似乎确实是这样，但为什么我调了这么久……）

言归正传，我的做法好像跟题解区不是太一样，（大同小异），是这样的。

- 考虑两种情况：有一行全为 1，和没有任何一行全为 1。
- 对于第一种情况：暴力枚举全 1 行的 mask，并计算所有选定格子的概率乘积。
- 对于第二种情况：将对角线视为列；所以有 $n+2$ 列。Dfs 所有全 1 列的 mask，那么就有一些格子已经确定是 1 了；因此对于每一行 $i$ 我们能够计算那些未确定的 $(i,j)$ 的 $p_{i,j}$ 的乘积 $P_i$；计算 $(1-P_i)$ 的乘积应该是“当前 mask 的列集合全为 1，没有行全为 1”的可能性。形式化地说，当前 mask 的答案就是 $\prod_{i=1}^n(1-P_i)$。
- 接着第二种情况说，我们求的其实是保证“当前 mask 的列集合全为 1，至少有这些列全为 1，没有行全为 1”，所以其实重复了一些情况，因此需要容斥。这个就是普通的容斥了，没有什么要注意的。
- 由于我们是用 dfs 在枚举，而枚举过程中可以顺带维护各行的未确定的 $\prod p_{i,j}$，因此每次枚举 mask 结束后，只需要枚举行来计算，即复杂度 $O(2^n+2^{n+2}n)$。

[submission](https://codeforces.ml/problemset/submission/1530/145701213)