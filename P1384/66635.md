# 非常玄学的一道题目

   开始的时候和机房里一位~~蒟蒻~~神犇讨论这道题目，就过乱搞乱搞发现了一个规律，还以为自己创造了一个定理，激动了好一会。
   
   结果了解了一下才知道这个规律就是逆康托展开，看了一下定义，和旁边神犇讲的一模一样，~~不过那也非常厉害了....~~
   
   ## 康托展开：
   - 给你一个式子：$X=a_n*(n-1)!+a_{n-1}*(n-2)!+...+a_i*(i-1)!+...+a_1*0! $其中, $a_i$为整数，并且$0<=a_i<=i,0<=i <n$, 表示当前未出现的的元素中排第几个，这就是康 托展开。例如有3个数（1，2，3），则其排列组合及其相应的康托展开值如下：
   
   
  |排列组合	  | 名次 | 康托展开 |
| :----------: | :----------: | :----------: |
| 123 | 1 | 0 \*2! + 0 \* 1! + 0 \* 0! |
| 132 | 2 | 0 \* 2! + 1 \* 1! + 0 \* 0! |
| 213 | 3 | 1 \* 2! + 0 \* 1! + 0 \* 0! |
| 231 | 4 | 1 \* 2! + 1 \* 1! + 0 \* 0! |
| 312 | 5 | 2 \* 2! + 0 \* 1! + 0 \* 0! |
| 321 | 6 | 2 \* 2! + 1 \* 1! + 0 \* 0! |

再举一个例子：在$(1,2,3,4,5)5$个数的排列组合中，计算$34152$的康托展开值。

- 首位是$3$，则小于$3$的数有两个，为$1$,$2$，$a_5=2$,则首位小于$3$的所有排列组合为$a_0*(5-1)!$。
- 第二位是$4$，则小于$4$的数有两个,为$1$和$2$,注意这里的$3$并不能算，因为$3$已经在第一位,所以其实计算的是在第二位之后小于$4$的个数。因此$a_4=2$
- 以此类推，根据公式：$X=2*4!+2*3!+0*2!+1*1!+0*0!=2*24+2*6+1=61$所以比$34152$小的组合有$61$个,即$34152$是排第$62$。

## 逆康托展开：

- 其实逆康托展开就是按照上边的步骤,逆过来,根据排名,求原序列,~~感觉就不用再多讲了~~

## 数位$DP$：

- 顾名思义,数位$DP$就是一个数,一位一位的$DP$,也是比较简单,如果不会的话，可以看这个,[点我点我！！](https://blog.csdn.net/wust_zzwh/article/details/52100392)还是讲的比较详细的。


------------ 

------------


## 好了,开始说这道题目吧

- 看着这个数据非常大$10^9$,好像怎么都过不了,而且复杂度应该是$O(n!)$,所以不太好像,其实可以模拟一下试试,在模拟的时候,可以发现,前边很多数都是不变的,只有后面的几位在变化,而且只需要$x!=k$中$O(x)$的时间复杂度了，发现$13!$已经到了$6*10^9$,所以只需要看后面$13$位，就可以完美的解决问题了。


------------

------------

### 上代码(~~感觉已经讲的够清楚了,~~代码里就不多加注释了)：
~~~cpp
#include<cstdio>
#include<vector>
#include<cstring>
#include<algorithm>
using namespace std;
int jc[14]={1,1,2,6,24,120,720,5040,40320,362880,3628800,39916800,479001600,6227020800};
int dp[11],a[11],n,k,x;
inline int dfs(int pos,int lim,int zero)
{
	if(pos==-1)
		return 1;
	if(!lim&&!zero&&dp[pos]!=-1)
		return dp[pos];
	int up=lim?a[pos]:9,num=0;
	for(int i=0;i<=up;i++)
	{
		if(i!=4&&i!=7&&!(zero&&i==0))
			continue;
		num+=dfs(pos-1,lim&&i==up,zero&&i==0);
	}
	if(!zero&&!lim)
		dp[pos]=num;
	return num;
}
bool ok(int x)
{
	bool flag=1;
	while(x)
	{
		flag&=((x%10==4)||(x%10==7));
		x/=10;
	}
	return flag;
}
int solve1(int x)
{
	int k=0;
	while(x)
	{
		a[k++]=x%10;
		x/=10;
	}
	return dfs(k-1,1,1);
}
int solve2(int n,int x,int k)
{
	vector<int>v,a;
	for(int i=n-x+1;i<=n;i++)
		v.push_back(i);
	for(int i=x;i>=1;i--)
	{
		int r=k%jc[i-1];
		int t=k/jc[i-1];
		k=r;
		sort(v.begin(),v.end());
		a.push_back(v[t]);
		v.erase(v.begin()+t);
	}
	int j=n-x+1,res=0;
	for(int i:a)
	{
		if(ok(j)&&ok(i))
			res++;
		j++;
	}
	return res;
}
int main()
{
	scanf("%d%d",&n,&k);
	if(n<=12&&1LL*k>jc[n])
		return 0*printf("-1\n");
	memset(dp,-1,sizeof(dp));
	while(k>jc[x])
		x++;
	int ans=solve1(n-x)-1;
	ans+=solve2(n,x,k-1);
	printf("%d",ans);
	return 0;
}

~~~