难得在主题库找到一道能交题解的绿题$\dots\dots$

#### 题目描述

定义幸运数是仅由 $4$ 和 $7$ 构成的正整数。

求在 $1$ 到 $n$ 的第 $k$ 个全排列中，有多少个数满足：

- 自身是幸运数。

- 在排列中的编号也是幸运数。

如果排列不存在输出 $-1$。

---

举个例子，$1$ 到 $7$ 的第 $24$ 个全排列是 $1,2,3,7,6,5,4$。

其中的 $7$ 是幸运数，且位于排列中的第 $4$ 个位置。

$4$ 也是幸运数，且位于排列中的第 $7$ 个位置。

所以答案为 $2$。

---

#### 分析

首先观察数据范围，$1 \le n \le 10^{9}$。

显然当 $n=10^{9}$ 的时候，理论上 $k$ 可以达到 $n!$，高精也会炸。

题目说 $1 \le k \le 10^{9}$，解不等式 $n! \le 10^{9}$ 可以发现 $n <  13$。

所以说 $k$ 最多只会对排列的最后 $14$ 位产生影响。（以防万一多存一位）

那么题目可以分为两部分：先求排名 $k$ 对应的全排列后 $14$ 位（逆康托展开），再求其中满足要求数的个数。

---

#### 康托展开和逆康托展开

先看一眼康托展开，给排列求式子。详见 [P5367](https://www.luogu.com.cn/problem/P5367)，直接给结论。

$$ans=1+\sum_{i=1}^nA[i]\times(n-i)!$$

其中 $A[i]$ 表示第 $i$ 个元素，$ans$ 表示排名。

接下来是逆康托展开，就是给排名求排列。举个例子：求 $1$ 到 $5$ 的第 $100$ 个全排列。

首先 $100-1=99$，$99 \div 4! = 4 \dots\dots 3$。有 $4$ 个数比它小的数是 $5$，所以第一位是 $5$。

用 $3$ 去除 $3!$ 得到 $0$ 余 $3$。有 $0$ 个数比它小的数是 $1$，所以第二位是 $1$。

用 $3$ 去除 $2!$ 得到 $1$ 余 $1$。有 $1$ 个数比它小的数是 $2$，但是由于比 $2$ 小的 $1$ 已经出现过了，不能算在里面，所以第三位是 $3$。

用 $1$ 去除 $1!$ 得到 $1$ 余 $0$。有 $1$ 个数比它小的数是 $2$，但是比 $2$ 小的 $1$ 已经出现过了，所以 $2+1=3$，$3$ 也出现过了，所以第四位应该是 $4$。

最后一个数是 $2$。

所以这个排列是 $51342$。

总结一下：每次用当前排列编号除以阶乘，得到的商就是比自身小的数字个数，去重统计后排列编号改为除以阶乘之后的余数。重复上述过程直到求出排列。

在本题中求出后 $14$ 位逆康托展开即可。

---

#### 答案统计

难度不大。首先可以预处理出比 $n$ 小的所有幸运数。可以运用类似于宽搜的思路，每次在幸运数后面加上 $4$ 或 $7$，然后扔队列里面。

接下来可以比较简洁地分类：

当 $n \le 14$ 时，将全排列一位一位检查是否符合条件即可。

当 $n>14$ 时，检查所有比 $n-14$ 小的幸运数（含），设它们是第 $p$ 小的幸运数，若 $p$ 也是幸运数则答案 $+1$。再判断最后 $14$ 位即可。

---

#### 代码

~~太丑了凑合一下~~

关于逆康托展开：（以下代码可以生成从 $1$ 到 $a$ 的第 $b$ 个排列的后$14$ 位）
```cpp
void make_sequence(long long a,long long b){
	b--;
	int p=a;
	if(p>14)p=14;
	for(int i=p;i>=1;i--){
		c[p-i+1]=b/jc[i-1]+1;
		int cnt=0,r=c[p-i+1];
		for(int j=1;j<=c[p-i+1];j++){
			if(!vis[j])cnt++;
			if(j==c[p-i+1]&&cnt<r)c[p-i+1]++;
		}
		vis[c[p-i+1]]=1;
		b%=jc[i-1];
	}
}
```
关于初始化：
```cpp
void init(){
	q.push(4);
	q.push(7);
	while(!q.empty()){
		if(q.front()>1e15)break;
		q.push(q.front()*10+4);
		q.push(q.front()*10+7);
		ln[++cur]=q.front();//幸运数存储。ln 建议开 8e4 左右
		q.pop();
	}
	jc[0]=1;//阶乘初始化
	for(int i=1;i<=14;i++)
		jc[i]=jc[i-1]*i;//前缀积
}
```
统计答案：（如果排列不存在要输出 $-1$）
```
int main(){
	cin>>n>>k;
	init();
	if(n<=14&&jc[n]<k){//报告无解
		cout<<-1<<endl;
		return 0;
	}
	make_sequence(n,k);//逆康托展开
	long long ans=0;
	if(n<=14){
		for(int i=1;i<=n;i++)
			if(check(i)&&check(c[i]))//check检查幸运数
				ans++;
		cout<<ans<<endl;
	}
	else{
		for(int i=1;i<=cur;i++){
			if(ln[i]>n-14)break;
			else ans++;
		}
		for(int i=n-13;i<=n;i++){
			c[14-n+i]+=n-13;
			if(check(i)&&check(c[14-n+i]))
				ans++;
		}
		cout<<ans<<endl;
	}
	return 0;
}
```
数组定义和检查幸运数的函数很简单的，自己写。