这题没有蓝题的难度吧？撑死了也就黄题？

---
### 题意简述：

给你 $n$ 首歌，每首歌有一个时间，要求在不超过 $t$ 时间的条件下，唱尽量多的歌。最后再唱一首 $(11\times 60 + 18=678)$ 时间的《劲歌金曲》，求出最后总共唱的歌的总数和总时间$($**算上劲歌金曲**$)$。

---
### 思路分析：

来聊一聊本人的做题过程。

拿到题目乍一看：

这是个啥？？？~~欺负我这个五音不全的？~~

然后直接看标签：**动态规划，背包**

再看题目，原来就是道 01背包 的板子题。~~$($真不知道我当时怎么想的想成了贪心$)$~~

题目就是让我们在这些歌里选出一些歌，使他们在数量最大的同时时间和最大$($当然不能超过给定的 $t)$

---
### 代码详解：
然而，这是一道不像板子的板子题。

它有一个要求：歌曲数量尽可能多。

所以我们的状态也要自然发生一些变化：

$dp_i$ 表示剩余 $i$ 时间时，能唱的 **最多歌曲数量**。

---
初始化：
```cpp
memset(dp,-1,sizeof(dp));//-1 表示目前不能唱歌
dp[0]=0;
```
---
然后就直接上板子
```cpp
//song 表示歌曲个数，rest 表示剩余的时间。sec[i]表示第 i 首歌的时长。
for(int i=0;i<song;i++){
	for(int j=rest-1;j>=sec[i];j--){
		dp[j]=max(dp[j],dp[j-sec[i]]+1);//表示不取(0)和取(1)。
	}
}
```
---
最后别忘了判断最多歌曲数量。
```cpp
muchtime=0;//muchtime 表示能唱的最长时间
for(int j=rest-1;j>=0;j--){//倒序枚举，为了找最大更方便
	if(dp[j]>dp[muchtime]){//如果歌曲数量更多
		muchtime=j;//更新 muchtime。
	}
}
```
---
然后？然后就没有然后了。

对了，别忘了 UVA 的~~专用坑人手段之~~**多组数据**和**输出格式**。

---
[完结撒花！](https://moon-snow.blog.luogu.org/)