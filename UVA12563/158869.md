## 很典型的O1背包问题
01背包就是在n种物品中选取物品，在物品可选且仅可选一次的情况下求利益的最大值；

f[i][j]表示选了i个物品在j的~~体积~~下最大的价值；

所以状态转移方程便是

```
f[i][j]=max(f[i-1][j],f[i-1][j-v[i]]+w[i]);

```
那么很明显f[i-1][j]是不选上一种物品的情况，而f[i-1][j-v[i]]+w[i]是选择上一种物品的情况；

所以我们需要枚举所有的物品与空间；

在本题的背景下，跑一遍01背包的时间复杂度是O(N*t)的然后T组数据的话总时间就是O（T*N*t）的，~~所以很明显TLE了？？？~~

每首歌的长度(保证不超过3分钟)，输入保证所有n+1首曲子的总长度严格大于t。所以本题的第一个坑点就来了！！！其实t没用那么大。

~~其实通过简单的计算~~，t的最大值为9677≈10000，所以总时间大概就是
1e2*5e1*1e4=5e7的量级，所以还是可以过的。

那么时间复杂度合乎要求了，空间复杂度呢？？
很明显f[i][j]是一个N*t（5e5）的量级，那么也是可以的，不过有没有什么更加优秀的方式呢？？

通过观察我们发现f[i][j]只与上一行的f[i-1][j]与f[i-1][j-v[i]]有关，而且是仅取一个值，所以我们是不是可以仅开一个一维数组f[maxj]去跑01背包呢！

很明显是可以的，~~不然我也不会写~~。

我们可以将上一行的状态直接继承下来，即f[i-1][j]->f[i][j];

用一维数组去表示就是f[j]=f[j]，很明显这是不用操作的。

然后对于f[i-1][j-v[i]]+w[i]—>f[i][j]；

我们用一维数组去实现的话取它和f[i][j]的最大值就好了。

代码实现就是f[j]=min(f[j],f[j-v[i]]+w[i]);

所以就有了一行完美的代码

```
for(int j=1;j<=t;++j)
	if(j>=v[i])
		f[j]=max(f[j],f[j-v[i]]+w[i]);
                     
```
然后就WA了。

不过恭喜的是你学会了完全背包（就是不限次数拿物品的01背包），
那么原因是什么呢？？

很明显的是体积是从前向后进行递推的，我们假设某物品v=1;w=inf；
```
f[2]=f[1]+inf,f[3]=f[2]+inf,f[4]=f[3]+inf;
```
~~很明显的是~~这一个物品使用的许多次，然后这就不是01背包了，这就是完全背包了。

所以我们向前递推就好了（这样我们就可以保证一种物品在，最终结果下只使用一次）

```
for(int j=t;j>=v[i];--j)
	f[j]=min(f[j],f[j-v[i]]+w[i]);
```

这种方法就是**滚动数组**。

简记：后01，前完全（反正别混了就行）

所以空间复杂度就降为O（t）了；

------------
然后我们继续说这个题：

首先我们需要知道究竟唱了几首歌，~~很明显~~，v就是歌曲的时间，然后w就是1（ 一 首歌的数目，那么你觉得一首歌还能是几首歌呢？？）；

然后跑下01背包就好了。

那么恭喜，听取WA声一片。

在时间结束之前再唱一个《劲歌金曲》，使得唱的总曲目尽量多（包含《劲歌金曲》）

那么：

1：时间结束之前意味着，背包只能使用t-1；不然最后一首《劲歌金曲》就没办法放了。

2：包含《劲歌金曲》意味着，其实唱了f[__]+1首歌；

3：《劲歌金曲》长达11分18秒~~简单计算~~就是678（600+60+18或者663+15）秒，这个时间也要计算。

最后实现的话，从后向前扫f[]数组找出最大能表示数就好了。

那么本题的坑点就说完了（别忘了输出格式）。

------------
然后我回答一下前面的一些题解的提问吧，

对于memset(f,0x8f,sizeof(f));这个问题

首先我们要知道memset是给字节赋值的即给每个字节赋值0x8f

~~众所周知~~ int是4个字节吧 所以赋值结束后是 0x8f8f8f8f

0x是指16进制所以16进制的2位可以表示2进制的8位，

8则对应1000，f则对应1111；所以每个字节的值就是10001111；

~~众所周知~~ int的最高位即32位是表示正负的，第32位为1则为负数，反之为整数，

~~很明显~~10001111100011111000111110001111这个数是个大负数
(-1886417009)。

有不懂的地方可以直接提问，有写的不好或者不对的地方欢迎您指出。

------------
### 最后代码就不放了，思路和解法甚至背包模型都放了。
### 您要这代码有何用？？


------------
## 最后祝大家CSP 2019 RP++