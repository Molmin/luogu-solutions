大部分题解对于何时必胜何时必败讲得已经很清楚了，这里讲讲取火柴的方案是如何找的

其实用异或结合律就很好懂了

**一、还是啰嗦的上个定理：**

以三堆为例，

如果$a_1\,xor\,a_2\,xor\,a_3\,=\,0 $，则先手必败

如果$a_1\,xor\,a_2\,xor\,a_3\,≠\,0 $，则先手必胜

~~证明见其他题解~~ ~~其实我是感性理解~~

**二、如果先手必胜应该怎么取火柴**

先手必胜，即先手可以拿走一些火柴，使得**后手必败**，而必败态是火柴堆的异或和为零；那么我们求的，就是先手拿走一些火柴后，新的火柴堆异或和为零的方案。设原异或和为$X$，易知

$$a_1\,xor\,a_2\,xor\,a_3\,=\,X$$

$$a_1\,xor\,a_2\,xor\,a_3\,xor\,X\,=\,0$$

运用异或结合律（这里以结合第二个为例）

$$a_1\,xor(a_2\,xor\,X)xor\,a_3\,\,=\,0$$

那么，我们可以把$(a_2\,xor\,X)$视为新的一堆火柴，当$a_2$变为$(a_2\,xor\,X)$时异或和为零，后手便必败。当然，由于这是**取**火柴游戏，所以$(a_2\,xor\,X)$必须小于$a_2$才行。

异或写在后面一定要加括号！ Orz

Code:

```cpp
#include<bits/stdc++.h>
using namespace std;
int n, a[500008], X; // n : k

int main(){
    cin>>n;
    for(int i=1 ; i<=n ; i++){
        cin>>a[i];
        X ^= a[i]; //求异或和
    }

    if(!X){
        cout<<"lose\n";
        return 0;
    }

    for(int i=1 ; i<=n ; i++){
        if((a[i]^X) < a[i]){ //合法
            cout<<a[i] - (a[i]^X)<<' '<<i<<endl; //ai变为ai^X, 则拿走了ai - ai^X
            a[i] = a[i]^X;
            break; //先找到的肯定是字典序最小的，立即退出
        }
    }
    for(int i=1 ; i<=n ; i++) cout<<a[i]<<' ';
    return 0;
}
```