## 题解 AT3854 【[ABC085D] Katana Thrower】

### 题目分析
每一把刀有两种造成伤害的方式，投掷或者劈砍，刀可以无数次劈砍，但只能投掷一次，求最少需要多少次攻击击杀怪物。

很显然我们需要将每一次的伤害最大化。

### 思路分析

#### 错误思路

首先，一把刀只能投掷一次，却能劈砍无数次，因此较高的劈砍伤害进行无数次劈砍显然更为有利。但可能投掷伤害大于劈砍伤害，因此我们需要进行贪心。

我一开始的思路为：找到劈砍伤害最高的刀，（在怪物没死的情况下）将其余刀按伤害从大到小投掷出去，然后用剩下的一把刀劈砍直到能投掷为止，这样也不用考虑刀是否已经投掷的问题。

这个方法显然有误：投掷伤害不一定全部大于劈砍伤害，例如当数据的情况如下的时候：
```
4 100
3 1
1 4
1 3
1 1
```

按照排序，我们造成的伤害图表如下（红色部分为投掷，蓝色部分为劈砍）：

![](https://s3.ax1x.com/2021/02/05/yGG4QP.png)

显然更优解应当如下：

![](https://s3.ax1x.com/2021/02/05/yGG2id.png)



#### 正解

因此，我们的思路应当是将刀的劈砍伤害与投掷伤害分开，再从大到小排序。这样我们造成的伤害就如上图最优解一样，先缓慢下降，接着维持不变（开始利用劈砍造成伤害）。

但还有一个问题：投掷过的刀就无法进行劈砍。按上文排序，假如劈砍伤害最高的刀为 A，但 A 的投掷伤害比劈砍伤害高，计算的时候就会先投掷 A 再劈砍 A，似乎不符合题意。

例如如下数据：
```
2 100
10 50
1 1
```
按照题意先劈砍后投掷的伤害图表如下：

![](https://s3.ax1x.com/2021/02/05/yGJhtJ.png)

但如果按照排序先投掷后劈砍：

![](https://s3.ax1x.com/2021/02/05/yGYS1I.png)

可以看出实际上先投掷对结果则并没有影响，只是将原来作为最后一击，提早结束战斗的投掷挪到第一击罢了。同时这样也不用判断是否只剩下一把刀而能否投掷的问题。

### 代码实现

我们利用结构体数组存储刀的信息。结构体中包括刀的伤害和种类（投掷还是劈砍）。

输入数据之后，从大到小排序，在怪物存活的情况下不断投掷，如果找到了类型为劈砍的刀，则劈砍直至怪物死亡即可。

#### 代码

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;

struct knife
{
	int m;//刀的伤害
	bool t;//刀的种类（劈砍 0 或投掷 1）
}k[233333];

bool cmp(knife x,knife y)
{
	return x.m > y.m;//cmp函数，利用sort按刀的伤害从大到小排序
}

int main() 
{
	int n,h;
	cin >> n >> h;//输入数据
	int c=0;//因为拆分了两把刀所以不能用 i，添加一个 c 掌管数组位置。
	for(int i = 1;i <= n;i++)
	{
		cin >> k[++c].m;
		cin >> k[++c].m;
		k[c].t = 1;//将刀的类型设定为投掷
	}
	sort(k+1,k+c+1,cmp);//排序
	int i = 1,ans = 0;
	while(h > 0)//怪物还活着
	{
		if(k[i].t == 1)//如果刀的类型属于投掷
		{
			h -= k[i].m;//丢出去，怪物掉血（如果这里怪物直接去世了，那么h <= 0会自动结束循环）
			ans++;//攻击次数 + 1
		}
		else//刀的类型属于劈砍
		{
			if(h % k[i].m == 0)//特判一下防止除法少 1
			{
				ans += h / k[i].m;//算出来不断劈砍到怪物死亡要多少次
			}
			else
			{
				ans += h / k[i].m + 1;//和上面一样，这里是特判补上 1
			}
			h = 0;//怪物当场去世，自动结束结束循环
		}
		i++;//计算下一把刀
	}
	cout << ans;
    return 0;
}
```
------
第一篇题解，还是比较紧张的（

希望能过（