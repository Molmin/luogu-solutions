这道题可以用尺取法来做，因为翻开的照片是连续的，所以可以用两个变量表示左右两个端点。因为第 $1$ 张左边是第 $n$ 张，第 $n$ 张右边是第 $1$ 张， $n$ 张照片围成了一圈，所以可以把 $n$ 张复制一份，接在原来的 $n$ 张后面，这样长度就变成了 $2n$ 。

下面来说左右两个端点的调整，设左端点为 $l$ ，右端点为 $r$ 。

$l$一开始是 $1$ ， $r$ 一开始是 $n$ 。每次调整首先将 $r$ 增加 $1$ ，然后增加 $l$ ，直到 $l-r$ 区间的和 $\le$ $t$ ，还有一种特殊情况，就是 $t$ $\lt$ 翻开 $n$ 张照片的总时间，这时 $r$ $-$ $l$ $>$ $n$，显然是不成立的，也要继续增加 $l$ ，每次调整后放入长度就是 $r-l$ ，取一个最大值就可以了。
```cpp
#include <bits/stdc++.h>
using namespace std;
int q[1000005];
char c[500005];
int main(){
    int n, a, b, t, ans = 0, s = 0; //ans表示最多可以看的照片张数，s表示翻开l-r区间的时间
    cin >> n >> a >> b >> t >> c; //输入
    for(int i = 0; i < n; i++){ //q[i]表示看第i张的时间
        if(c[i] == 'w') q[i] = q[i+n] = b + 1;
        else q[i] = q[i+n] = 1;
        if(i != 0) //第一张本来就是翻开的
        	s += q[i]; //加上第i张的时间
    }
    int l = 1, r = n; //l表示左端点，r表示右端点
    while(l <= n && r < 2 * n){ //边界条件
        s += q[r]; //加上第r张的时间
        r++; //调整r
        while(r - l > n || s + (r - l - 1 + min(r - n - 1, n - l)) * a > t){ //不成立时或l-r区间的和>t时调整l
            s -= q[l]; //减去第i张的时间
            l++; //调整l
        }
        ans = max(ans, r - l); //取最大值
    }
    cout << ans << endl; //输出
    return 0;
}
```
。

