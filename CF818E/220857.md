题意：

给定序列, 求多少个区间积被 $k$ 整除。

---

给出一种和已有的一篇题解不同的，实现更加简洁，复杂度优秀的解法。

首先，我们可以找到从 $l$ 开始前缀积被 $k$ 整除的区间 $ [\ l,i\ ]$ ，然后找到其最短能被 $k$ 整除的后缀 $ [\ j,i\ ] $ ，这就是一个极短的有效区间。

可以发现，任意包含 $[\ j,i\ ]$ 的区间都是合法区间，我们直接计算合法区间数，找到一个 $[\j ,i\ ]$ 后，可以把 $l$ 设为 $j+1$ 避免计算重复。

实现细节可以看代码，下面证明其复杂度。

我看到其他网上的题解把其复杂度误解为 $O(n)$ ，其实是不对的。

若所有值都是 $2$ ，然后 $k$ 是 $2$ 的倍数，那么显然复杂度是 $O(n \times \log k)$ 的。

但有些数可能是 $1$ 这样的复杂度又如何呢？

我们可以把枚举 $i$ 使得前缀积被 $k $ 整除的过程当成是用每个 $a_i$ 去消掉 $k$ 的部分因数的过程。

我们每个当前无法消掉 $k$的因数的 $a_i$ 都当成 $1$ 算，那么显然有效区间的非 $1$ 长度不会超过 $\log$ 级别，同样的每一个 $1$ 不会被超过 $\log $ 和区间包含，所以每个 $1$ 自然最多被枚举到 $\log $ 次。


以上，总的时间复杂度是 $O(n \times \log k )$ 的。

---

代码：

```cpp
#define int long long 
const int Maxn=1e5+5;
inline int R()
{
    char c;int res,sign=1;
    while((c=getchar())>'9'||c<'0') if(c=='-') sign=-1;res=c-'0';
    while((c=getchar())>='0'&&c<='9') res=res*10+c-'0';
    return res*sign;
}
int a[Maxn],n,k;
signed main(){
    n=R();k=R();
    int ans=0,now=1,j,l=1;
    for(int i=1;i<=n;++i){
    	a[i]=R();
        now=now*a[i]%k;
        if(!now){
            now=1;
			for(j=i;now*a[j]%k;j--)
			now=now*a[j]%k;
            ans+=(n-i+1)*(j-l+1);
            l=j+1;
        }
    }
    printf("%lld\n",ans);
}
```