**前言。**

一道很好的**贪心**题。

**分析。**

什么是贪心？

即不从整体最优解的地方入手，得到的是**当前的最优方案**，在一定程度是局部最优解。

那怎么实现本题的贪心策略呢？

自然，但看题面是得不出什么规律的，但是，本题的样例给了我们不小的帮助，通过样例，我们不难得出以下规律：

规律 $1$ ：样例一与样例三。

首先，我们将 $n$ 个数相加，正好与输出答案相符，即 $ans$ 加上数组中的每个相对于前一个最大值还大的数，或最大值的数，（通俗一点，就是加上最大值和比初始化的最大值大的数）如果 $ans$ 大于最大值，那么 $ans$ 就再加上最大值。

但是，我并不能将其中道理阐述清楚，如想明白其中奥秘，请移步至其它题解。

规律 $2$ ：样例二。

我们发现，那 $n$ 个数中的最大值乘 $2$ 可得到答案。做法与规律 $1$ 相似。

原理是在最大值中，可以连续给其它值讲课，也就是说，在特定的情况下，即 $ans$ 不大于 $maxx$ 时，在相同的讲课时间与顺序下，一个老师讲课时间是最大值，两个老师则是最大值乘二。

代码如下，仅供参考：
```
#include<iostream>
#include<algorithm>
using namespace std;
int n,a[300005];
int maxx;
long long ans;
int main(){
    ios::sync_with_stdio(false);
    cin>>n;
    for (int i=1;i<=n;i++){
        cin>>a[i];
        if(a[i]>maxx){
            ans+=maxx;
            maxx=a[i];
        }
        else ans+=a[i];
    }
    if(ans>maxx){
        ans+=maxx;
    }
    else ans=maxx*2;
    cout<<ans<<endl;
    return 0;
}
```
**后记。**

 $ans$ 要开 ```long long```。