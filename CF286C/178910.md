### 解题思路

首先看题目关于幸运数列的定义，如果你**把正数看成左括号**，**把负数看成右括号**，你会发现这就是合法括号序列的定义。

所以题意就可以转化为：

给你一个括号序列，有一些括号一定是右括号，其他的括号你可以认为是左括号，也可以认为是右括号，问是否能构造出一个合法括号序列。

由于题目规定了一些括号是右括号，那么我们应该去找右括号，在它前面设法用左括号与之配对，所以要**倒序遍历序列**来得知当前还有多少个右括号没有配对，这显然可以用栈来维护。

因此我们得到了一个贪心做法：

从右往左倒序遍历序列，对于每个括号：

1. 如果是右括号，则直接加入栈中。

2. 否则如果栈非空，且当前括号若为左括号，能与栈顶的右括号配对的话，那么就把当前括号认为是左括号，并把它们都弹出栈。

3. 否则就只能把当前括号认为是右括号加入栈中（因为该做法是倒序遍历，如果把当前括号认为是左括号的话，那就没有与之配对的了）。

最后如果栈空了，就说明所有的右括号都与其左括号配对了，也就是说可以构造出一个合法括号序列；反之则不能。

### 正确性证明

这个贪心做法一定是正确的吗？

目前的其他三篇题解里面都没有关于贪心做法的正确性证明，所以我来补充一下。

假设贪心做法是错误的，从右往左看第一个出错的地方是位置 $i$，贪心做法的输出为 $print_i$，而正确的输出应为 $ans_i$。

因为输出的数要么是正数要么是负数，所以出错则 $ans_i$ 与 $print_i$ 互为相反数，即 $ans_i = -print_i$。

因此我们可以分为以下两种情况来讨论：

1. $ans_i>0$，$print_i<0$

如果 $ans_i>0$，则位置 $i$ 为左括号，且位置 $i$ 后面一定有能与之配对的右括号。

根据贪心做法的第 2 条和第 3 条可以发现，贪心做法是先考虑当前括号是否能为左括号，所以 $print_i>0$。

因此这种情况不存在。

2. $ans_i<0$，$print_i>0$

如果 $ans_i<0$，则正确的输出中位置 $i$ 前面必定有一个位置 $j$ 满足 $j<i$ 且 $ans_j>0$，即位置 $i$ 的右括号与位置 $j$ 的左括号配对了。

那么我们可以把 $ans_i$ 和 $ans_j$ 都变号，即在正确的输出中让位置 $j$ 的左括号变为右括号，并与它前面的左括号配对；让位置 $i$ 的右括号变为左括号，并与它后面的右括号配对。

可以发现，这样仍然能构造出一个合法的括号序列，且与贪心做法的输出相同。这也就说明了当 $ans_i<0$，$print_i>0$ 时，贪心做法是正确的。

可能有点难懂，这里举个例子，若输入为：

```
6
1 1 1 1 2 2
2 4 6
```

正确做法的输出为：

```
YES
1 1 -1 -1 2 -2
```

贪心做法的输出为：

```
YES
1 -1 1 -1 2 -2
```

在这个例子中，从右往左数第一个出错的地方是位置 3，正确做法是将位置 3 的右括号与位置 2 的左括号搭配。

我们可以将位置 2 的左括号变为右括号并与位置 1 的左括号搭配，将位置 3 的右括号变为左括号并与位置 4 的右括号搭配。

可以发现，这样输出仍然是合法的，并且与贪心做法的输出相同。

综上所述，这个贪心做法是正确的。

### 代码

```cpp
#include <iostream>
#include <cstdio>
using namespace std;

void read(int &s)
{
	s = 0; bool pd = false; char c = getchar();
	while (c < '0' || c > '9')
	{
		if (c == '-') pd = true;
		c = getchar();
	}
	while (c >= '0' && c <= '9')
	{
		s = (s << 3) + (s << 1) + (c ^ 48);
		c = getchar();
	}
	if (pd) s = -s;
	return;
}

const int N = 1e6 + 10;
int n, t, top, a[N], sta[N], ans[N];

int main()
{
	read(n);
	for (int i = 1; i <= n; i++)
		read(a[i]);
	read(t);
	for (int x, i = 1; i <= t; i++)
		read(x), a[x] = -a[x];
	for (int i = n; i; i--)
	{
		if (a[i] < 0) ans[i] = sta[++top] = a[i];
		else if (a[i] == -sta[top]) ans[i] = a[i], top--;
		else ans[i] = sta[++top] = -a[i];
	}
	if (top) puts("NO");
	else
	{
		puts("YES");
		for (int i = 1; i <= n; i++)
			printf("%d ", ans[i]);	
	}
	return 0;
}
```