大概的题意，随便看看啦:

定义一个三元组$(a, b, c)(a<=b<=c)$的权值为$(a-b)^2$。
给定$n(n<=5000)$个数，要求选出$k$个三元组，使得三元组权值和最小。

PS:输入数据是单调递增的。

下面正式开始吧。

首先，可以得到一个很直观的结论，在其中的一个三元组当中，较小的两个数一定是相邻的，至于第三个数，先放到一边不管，先记录下来，之后再补上。

即可有初步的状态表示：$f[i][j][k]$,$i$表示前$i$个数，在其中选出$j$个三元组，需要补充$k$个第三个数。

但是状态数为$O(n^3)$，不符题意，所以我们需要改变。

我们可以注意到在三元组当中，最大的数对于当前三元组的权值没有任何影响，所以我们只需要考虑那两个较小数该怎么选出，并使得存在一种可能性可以选出所有三元组的最大数。

通过新的思想，可以得到状态转移方程：

$f[i][j]$表示从大到小前$i$个数，选出$j$个三元组。

（注意到在这里变成了从大到小的顺序，之所以这样倒着遍历可以节省一维的复杂度，是因为在从小到大的顺序当中，对于三元组当中的最大的数已经超出了当前讨论$i$个数之外了，所以需要单独拿出来记录。
反观从大到小，在讨论三元组中两较小数的时候，已经将最大数考虑到范围之内，所以只用考虑当前安排是否满足合法即可，不用再记录额外的信息，所以有的时候，转变一个顺序，也许就会使我们豁然开朗。）

每次枚举三元组中最小的数，可以得到：

$f[i][j]=+\infty(j*3<i)$（方案不合法，权值为无穷大）

$f[i][j]=f[i-2][j-1]+(a[i]-a[i-1])^2(j*3=i)$（即最小的两个数必须放进三元组当中）

$f[i][j]=min(f[i-2][j-1]+(a[i]-a[i-1])^2,f[i-1][j])(j*3>i)$（最小数不一定要放进三元组当中）

下面是代码:
```
#include<bits/stdc++.h>
using namespace std;
int n,k,t;
int a[5050];
int f[5050][1050];
inline void read(int &x){
	int f=0;x=0;char ch=getchar();
	while(!isdigit(ch)){if(ch=='-')f=-1;ch=getchar();}
	while(isdigit(ch)){x=(x<<3)+(x<<1)+(ch^48);ch=getchar();}
}
void clear(){
	for(int i=0;i<=n;i++){
		for(int j=0;j<=k;j++){
			f[i][j]=0;
		}
	}
}
int po(int x){
	return x*x;
}
int main(){
	read(t);
	while(t--){
		read(k);
		read(n);
		k+=8;
		for(int i=n;i>=1;i--)read(a[i]);
		clear();
		for(int i=1;i<=n;i++){
			for(int j=1;j<=k;j++){
				if(j*3>i)f[i][j]=0x7fffffff;
				else if(j*3==i)f[i][j]=f[i-2][j-1]+po(a[i]-a[i-1]);
				else if(j*3<i)f[i][j]=min(f[i-2][j-1]+po(a[i]-a[i-1]),f[i-1][j]);
			}
		}
		printf("%d\n",f[n][k]);
	}
	return 0;
}

```
