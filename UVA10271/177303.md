本人蒟蒻一名，如有不当请指出。

动归dp不解释。这里是选三根筷子，不是选两根。其实这题是选两个筷子的改版。试想一下，要差的平方最小，必须是相邻筷子，差最小，差的平方也最小，所以筷子必须是排列好的，那就有升序和降序了，这里是三根筷子，而且长度依次递增，首先想到的是升序对吧，但是这里如果用升序不好实现选三根，两根好实现，但是你第三根怎么选呢，所以反过来想一下降序是不是好实现呢，这里的权值又和最长的那一根筷子没关系，所以直接降序，看后面两根筷子的差的平方（具体看代码）。

状态方程无非就是选和不选 如果当前筷子不选

dp[i][j]=dp[i-1][j];

如果选当前筷子，和前面一支筷子算权值

dp[i][j]=dp[i-2][j-1]+(a[i-1]-a[i])*(a[i-1]-a[i]);

比较两者的大小，然后取小

dp[i][j]=min(dp[i-1][j],dp[i-2][j-1]+(a[i-1]-a[i])*(a[i-1]-a[i]))


下面贴代码
```c
#include<bits/stdc++.h>
using namespace std;
int a[5001],dp[5001][1001];//前i根筷子取j组的最小权值和 
int main()
{
	int t,n,k;
	cin>>t;
	while(t--)
	{
		cin>>k>>n;
	    k+=8;
		for(int i=n;i>=1;i--)
		 cin>>a[i];//降序读入 
		memset(dp,0x3f3f3f3f,sizeof(dp));//初始化dp 
		for(int i=0;i<=n;i++) dp[i][0]=0;
		for(int i=3;i<=n;i++)
		 for(int j=1;j<=k;j++)
		  if(i>=3*j) dp[i][j]=min(dp[i-1][j],dp[i-2][j-1]+(a[i-1]-a[i])*(a[i-1]-a[i]));//必须注意i>=3*j 
		cout<<dp[n][k]<<endl;
	}
	return 0; 
}


```