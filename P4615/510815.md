## 题目描述如下

每个人都会做一次任务,做完任务就会离开。

做任务的人会得到一个硬币。上司得到两个，上司的上司得到三个，以此类推直到上司就是自己的人结束。

最后求的就是每个人的硬币总和。

## 解题思路
**因为做一次任务，上司得到的钱比下属多一个硬币，所以总结到了一下三点。**

- 每个人的硬币数量等于所有下属的钱的和加上能够得到钱的份数的数量。

- 每个人钱的份数的数量等于所有下属的钱的份数的数量的和加一。

- 做任务的人可以得到一份钱。

**最后解题方法就是用深搜求下属钱的份数和下属总共得的钱**

## 注意事项

-  记得不要忘了加一的。

-  此题用并查集的注意不要合并每个点。

-  如果公司成一字链，那么最多的钱就得用 ```long long```  才可以存下。

## 奉上代码
```
#include<bits/stdc++.h>
#define LL long long
using namespace std;
LL ans[200100],gs[200100];//ans存每个人的钱 gs存每个人能得到的钱的份数
int N,per[200100],SS;//per存每个人的上司
int main() {
    scanf("%d",&N);
    for(int i=1; i<=N; i++) per[i]=i;
    for(int i=2; i<=N; i++) {
        scanf("%d",&SS);
        per[i]=SS;
    }
    for(int i=N; i>1; i--) {  //题目中说ai<i，所以大胆从后往前枚举
        ans[i]=1;
        gs[i]++;              //每个人都会做一次任务，所以至少有一份钱
        gs[per[i]]+=gs[i];    //上司钱的份数等于每个下属的份数之和加一
    }
    for(int i=N; i>1; i--) {  //算出每个人的钱数
        ans[i]=ans[i]+gs[i]-1;
        ans[per[i]]+=ans[i];
    }
    ans[1]=ans[1]+gs[1]+1;
    for(int i=1; i<=N; i++)
        printf("%lld ",ans[i]);
    return 0;
}
```