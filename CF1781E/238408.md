很独特的一道题目。不难看出最优的面积就是这些矩形的面积并，现在就变成了在并集不变的前提下调整矩形使得它们互不相交。可行的方案与思路有很多，但是并不是所有的思路都能导向简洁的做法。以下称占据上下两行的矩形为大矩形，只占据了一行的矩形为线段。

首先这东西可以离散化，因为收缩后有意义的边界只有 $l_i-1,l_i,r_i,r_i+1$。

### 解法一（赛时思路）

从左往右考虑。找到最靠左的非空格子，分两种情况考虑：

* 如果这一格子上有一个大矩形 $[l,r]$，直接选定这个矩形，将涉及到的其他矩形的左边界向右收缩至 $r+1$（当然，会有一些矩形因此而消失）。然后递归进子问题。
* 否则，找出以这个格子为起点且长度最长的线段，看看它的右端点是否被大矩形盖住了。如果是的话就把右边界收缩至最近的没有被大矩形覆盖的位置。然后选定这条线段，把涉及到的线段的左边界收缩，而对于涉及到的大矩形，让它们收缩成一条线段。由于特殊处理了右端点被大矩形覆盖的情况，这样不会把任何矩形切成不合法的形状。于是递归进子问题。

在这个过程中，最靠左的非空格子是单调递增的。于是可以从左往右扫，用线段树维护所需要的操作。选定矩形会让其他矩形收缩，这不太好维护，但是我们可以先确定选定矩形的顺序，然后倒序加入矩形依次覆盖。至于 把右边界收缩至最近的没有被大矩形覆盖的位置，这是连通性相关的结构，可以用并查集维护线段之间的连通块然后预处理出来。总复杂度大概是 $O(n\log n)$，但是特别难写。还有很多古怪的细节。

[code](https://codeforces.com/problemset/submission/1781/189716583)。注意这里偷工减料了一下，把右边界收缩至最近的没有被大矩形覆盖的位置 是暴力搞的，同时也没离散化，但是数据没卡。

### 解法二（赛后想到的）

两行的比较复杂，而如果只有一行就很容易调整成互不相交的状态。这启发我们将两行的问题降维变成一行的问题考虑。

大矩形优先级看起来比较高，先把它们调整成互不相交的形态。然后对于每个大矩形，分别去看它的上半部分和下半部分是否能被线段完全覆盖：

* 如果均能被线段完全覆盖，则抹除这个大矩形。
* 如果有且仅有一行的部分被线段完全覆盖，则把它调整成另一行上的线段。
* 如果两部分均不能被线段完全覆盖，则钦定这个大矩形不收缩，为此会对两行上的线段产生一些影响。这种影响可以直接写成前缀 $r$ 取 $\min$ 和后缀 $l$ 取 $\max$ 的形式，由于大矩形互不相交，这一影响可以在讨论结束后统一处理出来。

这一过程结束后，上下两行变为独立的两行，分别调整即可。复杂度瓶颈在于离散化。如果使用基数排序则复杂度为线性。

[code](https://codeforces.com/problemset/submission/1781/189794598)。

