## 一些表示

+ $S$：作为题目输入的矩形集合。
+ $\operatorname{area}(x)$：一个函数，接收一个矩形集合 $x$ 作为参数，返回值是 $x$ 中所有矩形的并集组成的图形。

## 本题解特点

+ 分类情况相对较少。
+ 实现上用了三个数组来表示和存储不重叠图形。在没搞什么特别优化的情况下，执行时间在当前数据集能排到前 2%，空间花费目测也是比较优秀的。
+ 代码有详细注释，不过要求一定的 C++ 语法知识。

## 题目分析

1. 猜测 $S$ 中所有矩形的并集的面积是能取到的。证明就是算法本身，类似数学归纳法。
2. $S$ 是无序的，不妨进行排序，可有效减少分类讨论的种类。在这题中，可按矩形所处列的最小值排，也可按矩形所处列的最大值排，后者简单心想了下发现要考虑的情况更多。
3. 不断往 $S$ 中添加新的矩形，然后在原先放置方法基础上，构造新的放置方法。
4. 模拟的具体写法。

## 构造放置方法

一开始创建一个空集合 $s$。

对 $S$ 排序后遍历矩形，假设当前遍历到矩形 $e$，$e$ 之前遍历过的矩形均已加入到 $s$ 中，未遍历的矩形则未加入 $s$ 中。

再引入一个能帮助分类讨论的循环不变式：若 $e$ 中包含 $\operatorname{area}(s)$ 中的点，则 $e$ 中位于该点正左侧（同一行，列数严格小于）的点均在 $\operatorname{area}(s)$ 中。不难发现它在我下面将要描述的算法过程中一直成立。

$e$ 加入 $s$ 具体有以下3种情况，不加入的情况不列出来（看代码实现，有的实现方式默认不加进去）：

1. 若 $e$ 的宽度为 1：
	+ 把 $e$ 缩小成未被 $\operatorname{area}(s)$ 覆盖的部分，加入 $s$ 中。
2. 若 $e$ 的宽度为 2：
	1. 若 $e$ 未被 $\operatorname{area}(s)$ 覆盖的部分只有一行：
		+ 把 $e$ 缩小成该未被覆盖的部分，加入 $\operatorname{area}(s)$ 中。
	2. 若 $e$ 未被 $\operatorname{area}(s)$ 覆盖的部分两行都有：
        + 则计划把 $e$ 完整的加入 $s$，为防止重叠，应该：
            + 被 $e$ 完全包含的矩形，直接删除；
            + 与 $e$ 部分重叠的矩形，只需要改变它们的右边界，使得它们不与 $e$ 重叠。
        + 然后再把 $e$ 加入 $s$。


## 模拟的具体实现

把题目要求的输出（若干矩形位置信息）分成三部分：用两个数组表示只占据一行的矩形，用一个数组表示占据两行的矩形，每个数组中矩形均从左至右排好序。

通过上面提及的循环不变式可知，只需要找到数组的最后一个元素就能找出 $e$ 未被覆盖的部分。

代码见 [CF](https://codeforces.com/contest/1782/submission/192044827)。

注意事项：计算矩形面积的时候，`rect(0,0,0,0)` 这种矩形面积应为 0。

## 时间复杂度

$O(n\log{n})$ 瓶颈在排序。