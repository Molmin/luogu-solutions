[English editorial](https://discuss.codechef.com/t/dre3hgf-editorial/84967)

# C2：【Dream and the Multiverse REMATCH】

~~C2 是原版本的题，然后铃给出了一个对 n=1e5 的更优秀做法，所以题给裂了。~~

首先考虑莫队二次离线，需要快速维护 $[1,i]$ 有多少节点可以到达 $x$ 和 $x$ 可以到达 $[1,i]$ 里多少节点。我们分开处理，第一部分叫 Prefix-to-Node，第二部分叫 Node-to-Prefix。

## Prefix-to-Node

考虑树的 dfs 序。在一个树上一个节点所能到达的节点可以被恰好一个 dfs 序的值域区间表示。推广到 DAG 上，用底层树的 dfs 序。这样，某个节点所能到达的节点由 $O(m)$ 个 dfs 序的值域区间表示。证明很简单：每一条额外边仅会最多多贡献一个区间对一个节点。有很多方法来高效对所有节点计算这些 $O(m)$ 个区间是什么。可以模仿树的 dfs 序区间，直接合并一个节点相邻的节点的所有区间并且用扫描线简化。

这些区间实际上应该看做子树，但是为了常数略微小一点看做区间也没问题。

## Node-to-Prefix

现在一个节点在 DAG 上的祖先仍然可以用 $O(m)$ 个区间表示，但是这些区间就不是 dfs 序上的区间，而是树上的一个路径。这个路径有特点：一个端点是另一个端点的祖先。对于一棵树这个路径就是当前点到根的路径。和 Prefix-to-Node 同样的扩展到 DAG 上，可以得到一个节点的祖先对应 $O(m)$ 个这样的路径的并，其中一个路径是这个节点到根的路径。从一个父亲到孩子节点只会增加对应进入孩子节点的额外边。于是孩子的集合可以先复制父亲的集合，然后再暴力添加进入这个节点的额外边的贡献。这里“暴力”指的从额外边的开头一直往上爬，一直爬到进入了一个被原来的路径已经包含的节点。这样复杂度为什么对？一个节点对复杂度产生的贡献就是它被暴力爬过几次，也就最多是从它开始能到达几个额外边。这最多是 $O(m)$，于是总共初始化复杂度是 $O(nm)$。

---

好了这个部分搞完了。于是我们现在需要快速实现：

1. 将某个节点染色。
2. 访问某个节点能到达多少被染色的节点，**或者** 访问多少被染色的节点能到达某个节点。

其中我们以上已经引入了将某个节点染色等价于对 $O(m)$ 个子树里的所有节点权值加 1 和对 $O(m)$ 条特殊路径里的所有节点权值加 1。（这两种权值独立。）

由于莫队二次离线的自然性质，第一个操作需要进行 $O(n)$ 次，第二操作要进行 $O(n\sqrt n)$ 次，其中这里默认 $q=O(n)$。我们以上已经定了子树加等价于对 dfs 序区间加。对一条从深往浅链的权值全加 1 可以看做链头加 -1，链尾加 1，单点询问变成子树询问。对链的部分再次转换一下，发现等价于对【链头的 dfs 序编号+1，链尾的 dfs 序编号】全部加 1，单点询问可以从对应子树 dfs 序区间搞出来答案。

问题将转换成做 $O(nm)$ 次区间加，做 $O(n\sqrt n)$ 次单点询问。直接分块是 $O(nm\sqrt n)$；直接线段树是 $O(n(m+\sqrt n)\log n)$。能做更好么？考虑更佳平衡 $O(nm)$ 和 $O(n\sqrt n)$。我们开 $B$ 层分块；这样修改的时间复杂度为 $O(Bn^{1/B})$，询问的复杂度为 $O(B)$。仔细分析最佳 $B$ 得到最终复杂度：

$$O(\frac{n\log n\sqrt n}{W(\sqrt n/m)})$$

实际上取 $B=3$ 挺优秀。