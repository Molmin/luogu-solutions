~~看到发这道题题解的都是各路红紫名dalao我一蒟蒻瑟瑟发抖~~

简述一下题意：

每一轮从任意一个蹦床$i$开始，向后跳到第$i+s_i$个蹦床，并令$s_i$的值减$1$，直到跳出所有蹦床，开始下一轮，直到所有$s_i=1$

> 对于这种题，要么从往前看算来源，要么从往后看算贡献

这道题，我们选择后者

对于这道题，~~不难~~想到贪心的思想

1. 每次从**第一个**$s_i=1$的蹦床开始跳一定是最优的

   **说明**：因为$s_i$一定只能由蹦床$j(j\le i)$来更新，所以对于**第一个**$s_i\not=1$的蹦床$i$，如果起点选到它后面，就永远更新不到他了~~（寂寞）~~。而如果起点选到它前面，因为有$s_j=1(j\lt i)$，所以它每次只能往后跳一步，并且途中不会做任何更新，等跳到蹦床$i$时就又回到了从蹦床$i$出发的局面（这不是跟从蹦床$i$起跳一样吗），所以为了优化循环我们干脆直接从蹦床$i$起跳（从$1$起跳也可以）

2. 用$t_i$表示**到目前**，**当前**蹦床$i$**需要被跳过多少次**才能使$t_i$前面的所有蹦床的弹力都变成$1$，考虑每次经过蹦床$i$时的$t_i$对应的情况

   **说明**：
   - 如果$t_i\gt s_i-1$，说明$s_i$已经变成$1$了，$t_i=s_i-1$之后（不算它）的那部分$s_i$都为$1$，所以**都会跳到蹦床**$i+1$**上去**。如果**不满足**这个情况，说明此时$s_i$还未变成$1$，所以还需要$s_i-t_i-1$轮
   - 而对于普遍情况（即$t_i\le s_i-1$的那一部分），它最少往前跳$2$个，最多跳$s_i$个（如果有这么多蹦床的话），所以它会**分别跳到**$[i+2,min(i+s_i, n)]$一床一次，所以给这个区间每个$t_i$加$1$，楼上题解也说了，可以用**差分**和**树状数组**的方法

最后附上**AC代码**：

```C++
#include<iostream>
#include<cstring>
#define N 5010
using namespace std;
typedef long long ll;

int n, s[N], d[N];
int main() {
    int t; cin >> t;
    while(t--) {
    	cin >> n; ll cnt = 0, t = 0;
        // 多组数据一定记得数组清零 坑死我了
        memset(d, 0, sizeof(d));
        for(int i=0; i<n; i++)
			cin >> s[i];
        for(int i=0; i<n; i++){
            // 当前的t就是t_i
            t += d[i]; // d是t_i的差分
            // 两个if对应题解里面分析的两种情况
            if (t > s[i] - 1)
                d[i+1] += t - s[i] + 1, d[i+2] -= t - s[i] + 1;
            else cnt += s[i] - t - 1;
            if (i+2 <= min(s[i]+i, n))
                d[i+2]++, d[min(s[i]+i, n)+1]--;
        }
        cout << cnt << endl;
    }
    return 0;
}
```
