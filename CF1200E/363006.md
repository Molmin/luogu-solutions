## 题意

给你 $n$ 个字符串，要求把他们拼接在一起，相同的部分可以互相重合。

## 思路

看到字符串和相同的部分，想到 $\text{KMP}$ 匹配算法，由于相同的部分肯定是最长的相同的部分，所以想到 $\text{KMP}$ 的 $\text{next}$ 数组。

假如我们要把 $s_1$ 和 $s_2$ 这两个字符串合并，那么如何求出它们最长可以重叠的部分呢？我们可以将 $s_2$ 和 $s_1$ 完完全全拼接起来，注意，$s_2$ 在前面。这样的话最长的重叠部分的长度就是这个新的字符串的最长公共前后缀了！

我们来分析一下这个算法的复杂度：

由于要合并 $n$ 个串，一共有 $10^5$ 个串，总长度为 $10^6$，所以复杂度大概就是 $O(n|s|) = O(10^5 \times 10^6) = O(10^{11})$，kls 来了都要叹气。

我们想，假设之前那个串满足条件 $|s_1| > |s_2|$，那么显然 $s_2 + s_1$ 这个字符串的最长公共前后缀最长也就只有 $|s_2|$ 这么长，所以我们可以截取 $s_1$ 的后 $|s_2|$ 位为 $s_3$，这样我们只用求 $s_3 + s_2$ 的最长公共前后缀就可以了。

我们发现，这样做的复杂度最多是 $O(2|s|)$ 的，而 $|s|$ 是 $10^6$ 级别的，**在时间复杂度上是可以过的。**

但是，我们写完代码，发现提交到 Codeforces 上奇妙的 WA 了，这并不是你代码写错了，而是上面算法的正确性有问题，本题解的精髓就来了。

为了方便表示，我们令上述算法 $s_3 + s_2$ 为字符串 $s_4$。我们可以发现，当 $s_4$ 的最长公共前后缀的长度 $> |s_3|$ 时（由于 $|s_2| = |s_3|$，所以描述了 $s_4 > s_3$ 后，$s_4 > s_2$ 就是必然的），我们会发现错误，因为最长公共前后缀的长度都大于了 $s_3$，还讲什么重叠不重叠呢？

可能有人听不懂，放个样例来看看：

```
2
010 101
```

显然此时的 $s_4$ 为 $101010$，我们发现最长公共前后缀长度为 $4$，但是合并出来的结果是 $010101$，这时因为 $4 > |010|$，这个最长重叠的串在 $010$ 与 $101$ 中都没有出现过。

这下听懂了吧！我们可以将 $s_4$ 设为 $s_3 + c + s_2$，其中 $c$ 是什么，待会再讲。

现在来解释这个神奇的 $c$，**理论来讲**，$c$ 可以为任意一个字符。本人曾经耗费精力证明 $c$ 为一个字符是假的，但事实证明是本人假了。

**下面内容想深究的可以看，不然可以直接看代码。**

我们可以简单构造一组数据：

```
3
1 1 1
```

本来希望程序输出个错误结果，没想到输出了 $1$。

我们思考为什么会输出 $1$，我们拼接的 $s_4$ 为 $101$，而 $0$ 为 $c$，此时我们发现，哦！由于 $\text{next}$ 数组的定义是所有前缀的最长公共**真**前后缀，所以其实 $101$ 的最长公共前缀为 $1$，可以证明所有这种情况以及其他情况都会得出正确结果。

那为什么有的题解 $c$ 为一个字符串过了呢？下面解释：

我们设 $c$ 为 `IAKIOI!!!`

那么下面这组样例即可卡掉：

```
2
IAKIOI!!! IAKIOI!!!IAKIOI!!!
```

此时我们在中间加上 `IAKIOI!!!` 就会变成这样：

```
IAKIOI!!!IAKIOI!!!IAKIOI!!!IAKIOI!!!
```

此时显然最长公共前后缀为 $3$ 个 `IAKIOI!!!`，而这个长度要比输入的两个字符串都要长，所以会错。

我们得出结论，对于任意的 $c$，我们总是可以出以下这组数据卡掉：

```
2
c cc
```

其中 $c$ 代表的是一个字符串。

但是字符串组合这么多，所以没有出全，所以才会有 $c$ 为一个长度 $> 1$ 的字符串时 AC 了。

上面的 hack 仅适用于第一种暴力算法，并且没有考虑 $|s_1| < |s_2|$，更多的 $\text{hack}$，可以在 Codeforces 上找。

最后注意，这种情况只适用于 $|s_1| > |s_2|$ 的情况，至于 $|s_1| < |s_2|$ 的情况，跟上面的差不多，这里就不多说了。

## 代码

代码就好理解了：

```cpp
#include<bits/stdc++.h>

using namespace std;

const int N = 1e6 + 5;

int n;
int nxt[N];
string s[N], ans;

int getnxt(string t){ //求 next 数组
	int i = 0, j = -1;
	nxt[0] = -1;
	for(; i < t.size(); ){
		if(j == -1 || t[i] == t[j]){
			nxt[++i] = ++j;
		}
		else{
			j = nxt[j];
		}
	}
	return j;   //这里的 j 表示最长公共前后缀的长度，也可以用 nxt[n] 表示
}

int main(){
	ios::sync_with_stdio(false);
	cin.tie();
	cout.tie();
	cin >> n;
	for(int i = 1; i <= n; ++i){
		cin >> s[i];
	}
	ans = s[1];
	for(int i = 2; i <= n; ++i){
		int len = min(ans.size(), s[i].size()), res = 0;  //这里要考虑 s1 < s2 的情况
		int start = ans.size() - len;  //开始的位置
		string tmp = s[i] + "w" + ans.substr(start);  //中间加字符
		res = getnxt(tmp);
		res = min(res, len);   //要考虑 < 的情况
		ans += s[i].substr(res);
	}
	cout << ans;
	return 0;
}
```