## S Digit Sum

设 $f[i][j][0/1]$ 为选到第 $i$ 位时余数为 $j$ 且该数是否达到最大上限的方案数 (0为无限制,1为限制), $a[i]$ 为 $K$ 从最高位到最低位中第 $i$ 位的数字。

我们可以以 **1285** 作为例子。

对于 $f[i][j][1]$ , 由于当前是需要限制的情况,所以我们只能从限制的情况来 , 比如前两位我们已经选好了 **12** ,第三位只有选 **8** 才能作为贡献,如果前面两位为 **11** 即从无限制的状态转移,则不可能会出现当前数位被限制的可能。因为在 **12** 的前缀下我们被限制了,只能选 **0~8** 的数,可若前缀为 **11** ，我们可以选 **0~9** 的数,所以限制的情况只会从上一位限制的情况转移，有

$$f[i][j][1]=f[i-1][((j-a[i])\%D+D)\%D][1]$$

然后我们考虑 $f[i][j][0]$ 。对于当前无限制的状态 ，我们既可以从无限制的状态转移过来 ，也可以从有限制的状态转移过来。但是当我们从有限制的状态中选中 $a[i]$ 时,可以发现此时我们也是按照有限制的条件来选的,所以我们不能将 $a[i]$ 选入,好比你想让第三位选择无限制, 那么你只能选 **120~127** ,因为如果你选择了 **128** ,则你就变成了限制状态了 , 下一位就不能选 **6** 了 ,而 **1206,1216...1276** 却可以选择。所以有

$$f[i][j][0]=\sum_{k=0}^{9}f[i-1][((j-k)\%D+D)\%D][0]+\sum_{k=0}^{a[i]-1}f[i-1][((j-k)\%D+D)\%D][1]$$

初始化为 $f[0][0][0]=f[0][0][1]=1$

答案为 $f[n][0][0]+f[n][0][1]-1$ 因为答案需要求 1~K,即把数字为 0 的情况删除。


代码如下
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
ll read(){
	ll x=0,f=1;char ch=getchar();
	while(!isdigit(ch)){if(ch=='-')f=-1;ch=getchar();}
	while(isdigit(ch))x=x*10+(ch^48),ch=getchar();
	return x*f;
}
const ll N=1e4+50,P=1e9+7;
ll f[N][105][3],a[N],D,n;
char S[N];
int main()
{
	scanf("%s",S+1);D=read();
	n=strlen(S+1);
	for(ll i=1;i<=n;++i)a[i]=S[i]-'0';
	f[0][0][1]=1;
	for(ll i=1;i<=n;++i)
	{
		for(ll j=0;j<D;++j)
		{
			for(ll k=0;k<=9;++k)
			{
				ll J=((j-k)%D+D)%D;
				(f[i][j][0]+=f[i-1][J][0])%=P;
				if(k<a[i])(f[i][j][0]+=f[i-1][J][1])%=P;
			}
			f[i][j][1]=f[i-1][((j-a[i])%D+D)%D][1];
		}
	}
	printf("%lld\n",((f[n][0][1]+f[n][0][0]-1)%P+P)%P);
    return 0;
}

```