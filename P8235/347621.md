###### 题目：
给你一棵 $ n $ 个节点的树，其中一号点填了一个左括号，你需要给其余每个点填上``` ( ``` 或 ``` ) ``` ，使得树上合法括号路径数量最多，保证答案唯一。
###### 分析：
对于每一条链，想要使链上合法的括号最多，那么最容易想到的就是左右括号交替出现，这样可使括号数最多。
再看题目，可以把这棵树拆成若干条树链，每一条树链都填上 ``` ()()()()…… ``` 。这样就可以使每一条树链上的括号最尽可能地多，那么整棵树也是最优的。而如果用别的填法，不但会降低这条链上的括号数。而且不能保证子树的最优，可能会破坏子树的最优性。所以，只要把每个节点填上与它的父节点相反的括号就行了。     
数据范围 $ 1 \le n \le 10^5 $，考虑搜索，可以 dfs 或 bfs ，时间复杂度 $ O(n) $，我这里用的是 dfs 。
###### 代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,s,x,y;
vector<int> a[300000];    //用邻接矩阵显然超空间，因此使用vector
char ans[300000];
bool f[300000];
char op(char c)        //取反
{
	if(c=='(') return ')';
	return '(';
}
void dfs(int k,char c)
{
	ans[k]=c;
	for(int i=0;i<a[k].size();i++)   //遍历所有与k相连的节点
	    if(!f[a[k][i]])         //判断是否取过
	    {
	    	f[a[k][i]]=1;
	    	dfs(a[k][i],op(c));     //继续遍历子节点
		}
}
int main()
{
	scanf("%d",&n);
	for(int i=1;i<n;i++)
	{
		scanf("%d%d",&x,&y);
		a[x].push_back(y);
		a[y].push_back(x);   //无向图，两次存边
	}
	dfs(1,'(');
	for(int i=1;i<=n;i++) cout<<ans[i];
	return 0;
}
```
