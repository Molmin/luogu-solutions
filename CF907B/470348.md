转了一圈，没有打表的题解，那我来发一篇罢。

## Analysis

这题主要有四个难点：输入、检查大格是否填满、从小格映射到大格、输出。

先看输入：考虑用类似快读的方式，遇到无意义字符（空格、回车）就读入下一个字符直到读入可见字符为止。

可以这么写：

```cpp
char ch, s[10][11];
for(int i = 1; i <= 9; i++)
    for(int j = 1; j <= 9; j++) {
        while((ch = getchar()) && (ch == ' ' || ch == '\n')); // 过滤掉空格和回车
        s[i][j] = ch;
    }
```

再看怎样检查大格是否填满：容易发现，每个大格也是一个矩阵，所以我们可以打个表，记录每个大格的行起点、行终点、列起点、列终点。（当然也可以利用取模打一个更简单的表~~，可惜这里地方太小写不下了~~）

```cpp
struct node {
    int a, // 行起点
        b, // 行终点
        c, // 列起点
        d; // 列终点
};

const node f[] = {
    {0, 0, 0, 0}, // 占位
    {1, 3, 1, 3},
    {1, 3, 4, 6},
    {1, 3, 7, 9},
    {4, 6, 1, 3},
    {4, 6, 4, 6},
    {4, 6, 7, 9},
    {7, 9, 1, 3},
    {7, 9, 4, 6},
    {7, 9, 7, 9}
};
```

再看怎样映射：再打一个表，令 $g_{i,j}$ 代表第 $i$ 行第 $j$ 列的小格将要映射到的大格的位置，则有：

```cpp
const int g[10][10] = {
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, // 占位，每个子数组的第一个元素也用来占位
    {0, 1, 2, 3, 1, 2, 3, 1, 2, 3},
    {0, 4, 5, 6, 4, 5, 6, 4, 5, 6},
    {0, 7, 8, 9, 7, 8, 9, 7, 8, 9},
    {0, 1, 2, 3, 1, 2, 3, 1, 2, 3},
    {0, 4, 5, 6, 4, 5, 6, 4, 5, 6},
    {0, 7, 8, 9, 7, 8, 9, 7, 8, 9},
    {0, 1, 2, 3, 1, 2, 3, 1, 2, 3},
    {0, 4, 5, 6, 4, 5, 6, 4, 5, 6},
    {0, 7, 8, 9, 7, 8, 9, 7, 8, 9}
};
```

我们要检查大格是否填满，然后根据它是否填满决定下一步是只能下在一个大格还是整个棋盘（根据 `check` 函数的返回值，决定调用 `f1` 还是 `f2`）：

```cpp
int p;

bool check() { // 检查大格是否填满
    p = g[x][y];
    for(int i = f[p].a; i <= f[p].b; i++)
        for(int j = f[p].c; j <= f[p].d; j++)
            if(s[i][j] == '.') return true; // 至少有一个格还有空位置
    return false;
}

void f1() {    // 还没填满就只能下在此大格
    for(int i = f[p].a; i <= f[p].b; i++)
        for(int j = f[p].c; j <= f[p].d; j++)
            if(s[i][j] == '.') s[i][j] = '!';
}

void f2() {    // 已经填满了就可以下在整个棋盘
    for(int i = 1; i <= 9; i++)
        for(int j = 1; j <= 9; j++)
            if(s[i][j] == '.') s[i][j] = '!';
}
```

最后看如何输出：如果行数能被 $3$ 整除，要多输出一个空行；如果列数能被 $3$ 整除，要输出一个空格：

```cpp
for(int i = 1; i <= 9; i++) {
    for(int j = 1; j <= 9; j++) {
        putchar(s[i][j]);
        if(!(j % 3)) putchar(' ');
    }
    putchar('\n');
    if(!(i % 3)) putchar('\n');
}
```