## 题意

有 $3\times3$ 个大格，每个大格又包含 $3\times3$ 个小格。

第一个人下在了 $(x, y)$，第二个人可以下在哪儿。

规则：第二个人可以下在第一个人下的 **小格在大格方位** 所对应的 **大格** 在中，如果大格被填满，那么可以任意下。

举个例子。

例如第一个人下在了 第 $2$ 行，第 $2$ 列的大格的左下角，第二个人就可以下在 左下角 的大格中，也就是 第 $3$ 行，第 $1$ 列的大格。

## 解法

按题意模拟即可，本人打了一个表，代表 这个小格在大格方位所对应的大格。

**Tips： 注意输出格式**

## Code
```cpp
#include<bits/stdc++.h>
#define LL long long
#define Fcin\
	ios :: sync_with_stdio(0);\
	cin.tie(0); cout.tie(0)
using namespace std;
char mp[10][10];
LL type[10][10] = {
{0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
{0, 1, 2, 3, 1, 2, 3, 1, 2, 3},
{0, 4, 5, 6, 4, 5, 6, 4, 5, 6},
{0, 7, 8, 9, 7, 8, 9, 7, 8, 9},
{0, 1, 2, 3, 1, 2, 3, 1, 2, 3},
{0, 4, 5, 6, 4, 5, 6, 4, 5, 6},
{0, 7, 8, 9, 7, 8, 9, 7, 8, 9},
{0, 1, 2, 3, 1, 2, 3, 1, 2, 3},
{0, 4, 5, 6, 4, 5, 6, 4, 5, 6},
{0, 7, 8, 9, 7, 8, 9, 7, 8, 9}
}, X, Y;

int main(){
    Fcin;
    for (LL i = 1; i <= 9; i ++){
    	for (LL j = 1; j <= 9; j ++){
    		cin >> mp[i][j];
		}
	}
	
	cin >> X >> Y;
	
	LL t = type[X][Y];
	
	// 目标大格的行列起始位置
	LL lx = ((t - 1) / 3) * 3 + 1, rx = ((t - 1) / 3 + 1) * 3; 
	LL ly = ((t % 3 == 0 ? 3 : t % 3) - 1) * 3 + 1, ry = ((t % 3 == 0 ? 3 : t % 3)) * 3; 
	
	
	bool flag = true;
	for (LL i = lx; i <= rx; i ++){
		for (LL j = ly; j <= ry; j ++){
			if (mp[i][j] == '.')
				flag = false;
		}
	}
	// 如果这个大格全被填满
	if (flag){
		for (LL i = 1; i <= 9; i ++){
			for (LL j = 1; j <= 9; j ++){
				if (mp[i][j] == '.')
					mp[i][j] = '!';
			}
		}
	}
	// 否则
	else{
		for (LL i = lx; i <= rx; i ++){
			for (LL j = ly; j <= ry; j ++){
				if (mp[i][j] == '.')
					mp[i][j] = '!';
			}
		}
	}
	
	for (LL i = 1; i <= 9; i ++){
		for (LL j = 1; j <= 9; j ++){
			cout << mp[i][j];
			if (j % 3 == 0)
				cout << " ";
		}
		cout << "\n";
		if (i % 3 == 0)
			cout << "\n";
	}
    
    
	return 0;
}

```
