因为 dp 需要满足无后效性，但这里$r[i]$有后效性。所以我们**倒着选**，（可以想象成倒着选了 $j$ 个数之后再反过来）。现在在 $i$ 位置选择 $j$ 号物品的收益就是：$w[j]-(i-1) \times r[j]$。


我们要让这个收益最大。像不像一个**01背包**？但是这里对选择顺序是有要求的（改变顺序会让结果改变）。所以**先用贪心确定最优顺序**：假设现在已经选出来了 $k$ 个数，怎么排才能让收益最大呢？当然是 $r[i]$ 大的排前面。所以一个物品只能排在 $r$ 比它大的物品的后面。所以先以 $r[i]$ 降序排列。

然后就是一个01背包板子了。

AC代码（部分）：
```cpp
sort(a+1,a+n+1,cmp);
for(int i=1;i<=n;i++){
	for(int j=1;j<=n;j++){
		dp[i][j]=max(dp[i-1][j],dp[i-1][j-1]+a[i].w-a[i].r*(j-1));
	}
}
for(int i=1;i<=n;i++)ans=max(ans,dp[n][i]);
cout<<ans;
```

