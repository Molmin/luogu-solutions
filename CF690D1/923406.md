### 前言
题目传送门：[The Wall (easy)](https://www.luogu.com.cn/problem/CF690D1)

### 思路

题目要求求有多少个连通块。

我们在某一个连通块中选取任意一个代表，都可以由它搜索到同一个连通块内的元素。

利用这一特性，我们可以采取以下方法：

遍历一遍二维数组，每当找到一个实区域，就从它开始搜索；显见，连通块内的所有元素都将被搜索到。

删除这个连通块，并把连通块数量加上一。具体删除方法是在遍历到连通块内的元素时将其赋值为空区域。这种方法可以避免重复遍历到同一连通块中的元素。

重复上列操作，直到数组遍历结束，显见所有的连通块都会被记录且删除。

输出记录的连通块数量。

因为数据范围很小，所以深搜的办法是可行的。

看代码。

### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
int C, R, MAP[105][105], nxt[4][2]={{1,0},{-1,0},{0,1},{0,-1}}, sum=0;
void dfs(int x, int y) {
	if(x<1 || x>C || y<1 || y>R || MAP[x][y]==0) {
		return;
	}
	MAP[x][y]=0;//删除连通块内的实区域元素
	for(int i=0;i<4;i++) {
		dfs(x+nxt[i][0],y+nxt[i][1]);//搜索连通块内的其他元素
	}
}
int main () {
	cin>>C>>R;
	for(int i=1;i<=C;i++) {
		for(int j=1;j<=R;j++) {
			char x;
			cin>>x;
			if(x=='.') {//个人癖好，把字符处理转为数字处理
				MAP[i][j]=0;
			} else {
				MAP[i][j]=1;
			}
		}
	}
	for(int i=1;i<=C;i++) {
		for(int j=1;j<=R;j++) {
			if(MAP[i][j]==1) {//检测到实区域
				sum++;//增加连通块数量
			}
			dfs(i, j);//从代表为起点搜索兼删除当下连通块
		}
	}
	cout<<sum;
	return 0;
}
```

### 后记
简单看了看题解区里的其他大佬，都打的二维并查集。

我太蒻了，看了数据范围就随手写了个深搜，竟然过了。

补充一句：感觉这个普通并查集也能做，思路大概就是先对每个元素一维编号然后 combine。这个思路纯口胡，不保证过。

最后：有问题欢迎指出。

谢谢收看。
