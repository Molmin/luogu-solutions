这道题乍一看是一个计数排序对吧

但是刚看到这道题的人可能会被数字范围吓到：1500000000，明显数组是开不下的。

那么计数排序就是行不通的

这时候，我们就可以想到一个东西：
# map
map内部是一棵红黑树，由于这题是一道普及-水题，所以就不细讲了
~~(其实是我不会)~~

不懂的同学可以先把map当作一个下标可以开很大的数组使用

这样就可以实现计数排序的思路了

----------------------------------------------------------浮夸的分界线---------------------------------------------------------

本题还有一个问题：统计出现过的数字

这个问题也可以用一个很妙的数据结构解决：

# set

set可以理解为一个排好序的数列(升序),它有insert,erase等操作

set中的每个数都只会出现一次

那么set的这一性质就可以被很好地利用

只需遍历这个set就可以输出出现过的数字

还有一些具体内容代码里解释

```cpp
#include<cstdio>
#include<map>
#include<set>
std::set <int> num;
std::set <int> :: iterator I;//set支持迭代器
std::map <int,int> statistics;
//尖括号中左侧的数据类型是键值的类型，右侧的是映射的类型
//支持int,double,char,string等类型
//就像这样：statistics["ONE"]=1;
//那么字符串"ONE"对应的映射值就是1
//要是还是不明白的话就去看看那些打表题
int n,in;
int main(void){
	scanf("%d",&n);
	for(int i=0;i<n;i++){
		scanf("%d",&in);
		statistics[in]++;//当成数组理解
		num.insert(in);//在set中插入一个元素
	}
	for(I=num.begin();I!=num.end();I++)
		printf("%d %d\n",*I,statistics[*I]);
           //输入中存在这一数字就输出并输出个数，*I指的是迭代器I指向的值
	return 0;
}
```
