# 简单来说，这题用桶排就崩了。

#### 楼下dalao们的代码，我实在看不懂。刚学的桶排又实现不了。这就迫使我用另一种思路来解决这道题。

 ~~清奇的脑回路~~如下：

我们可以参考[openjudge最长平台](http://noi.openjudge.cn/ch0109/12/)的方法来解这道题。只要用sort排一下序，相同的元素紧挨着放。这时，问题就转化成了“求相邻且相等元素的个数”。

### 举个栗子：

样例排好序后，效果是

### 2，2，2，4，4，5，100，100

统计：2出现三次，4出现两次，5出现一次，100出现两次。若下个元素与当前元素不同，则输出当前元素的值和出现次数（可以用累加器实现），然后重新判断（从下个元素开始查找，累加器清零）。

### 最后奉上代码：

```cpp
#include<iostream>
#include<algorithm>
using namespace std;
int a[200001];
int main()
{
	int n;cin>>n;
	for(int i=1;i<=n;i++)
	cin>>a[i];
	sort(a+1,a+1+n);
	int sum=1;
	for(int i=1;i<=n;i++)
	{
		if(a[i]==a[i+1])sum++;
		else
		{
			cout<<a[i]<<" "<<sum<<endl;
			sum=1;
		}
	}
	return 0;
}
```
~~相当的清晰啊有木有？算了当我没说。~~

## 萌新的第一篇题解，希望对大家有所帮助，也欢迎各位大犇提建议。谢谢！