我的算法没有题解，我就发一个。

分析：此题我用到单调队列，先快速排序，从头到尾累加每一个数，用t作为累加的数字，遇到相同的数字，就用c累加t数字的出现次数，遇到不同的数字，就输出t的个数c，再把第i个数赋值给t，c变为1个。

但要注意：单调队列计算不到最后一个数，所以要在后面加一个不可能出现的数，我用了-9999。

C++代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,i,a[200005],t,c;
int main()
{
    scanf("%d",&n);  //读入自然数个数
    for (i=1; i<=n; i++) scanf("%d",&a[i]); //读入每一个自然数
    sort(a+1,a+n+1); //快排
    c=1; //第一个数开始只有1个
    t=a[1]; //第一个数
    a[n+1]=-9999; //在最后面赋值-9999
    for (i=2; i<=n+1; i++)
    {
        if (a[i]!=a[i-1]) //遇到不同的数字
        {
            printf("%d %d\n",t,c);//就输出t的个数c
            t=a[i];//把第i个数赋值给t
            c=1;//c变为1个。
        } else c++;//遇到相同的数字，就用c累加t数字的出现次数
    }
}
```