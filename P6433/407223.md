### 思路

看到题背包dp没说了，但是这道题有两个特殊的操作——删题和翻倍。

跟大部分题相似地，把这两种操作塞进dp的第三维和第四维。那么 $dp_{i,j,k,l}$ 表示前 $i$ 道题中选若干题，时间限制为 $j$，翻倍了 $k$ 道题，删了 $l$ 道题的情况下最大的毒瘤值。（这样开是卡得过内存限制的，可能确实是数据太弱，建议可以滚动）

那么枚举 $i,j,k$（不枚举 $l$ 的原因是只有两种情况，手打就行了），暴力转移。

**还有一个值得注意的细节**，就是 $dp_{0,j,k,1}$ 的情况是不存在的（你还没有题怎么删，不就忽悠过去了吗），应当赋值为极小值。

### 代码

```cpp
#include<bits/stdc++.h>
#define N 105
#define M 1005
using namespace std;
int n,m,s,d[N],t[N],dp[N][M][N][2];//s为原题目k 
int main() {
    scanf("%d %d %d",&n,&m,&s);
    for (int i=1;i<=n;i++) {
        scanf("%d %d",&d[i],&t[i]);
    }
    for (int i=0;i<=m;i++) {
        for (int j=0;j<=s;j++) {
            dp[0][i][j][1]=-1e8;
            //将不存在的情况赋为极小值。
        }
    }
    for (int i=1;i<=n;i++) {
        for (int j=0;j<=m;j++) {
            for (int k=0;k<=s;k++) {
                if (j>=t[i]) {
                    if (k) {
                        dp[i][j][k][0]=max(dp[i-1][j][k][0],max(dp[i-1][j-t[i]][k][0]+d[i],dp[i-1][j-t[i]][k-1][0]+2*d[i]));
                        //三种选择：不选此题，选此题但不翻倍，选此题且翻倍。
                        dp[i][j][k][1]=max(dp[i-1][j][k][0],max(dp[i-1][j-t[i]][k][1]+d[i],dp[i-1][j-t[i]][k-1][1]+2*d[i]));
                        //三种选择：不选此题（相当于删掉此题），选此题但不翻倍，选此题且翻倍。
                    } else {
                        dp[i][j][k][0]=max(dp[i-1][j][k][0],dp[i-1][j-t[i]][k][0]+d[i]);
                        //无法翻倍的情况。
                        dp[i][j][k][1]=max(dp[i-1][j][k][0],dp[i-1][j-t[i]][k][1]+d[i]);
                        //无法翻倍的情况。
                    }
                } else {
                    dp[i][j][k][0]=dp[i-1][j][k][0];
                    //无法选择此题。
                    dp[i][j][k][1]=dp[i-1][j][k][0];
                    //无法选择此题（相当于删除此题）。
                }
            }
        }
    }
    printf("%d",dp[n][m][s][1]);
    return 0;
}
```