差分前缀和！十分无脑的做法！

首先显然有 $X+Y>Z$,考虑枚举 $Z$，那么就需要算出符合的 $X+Y$ 的值，暴力的话要 $n^2$，考虑优化他！

我们可以枚举 $X+Y$ 的长度，差分前缀和搞一下就可以算出每一个长度若可能为 $X+Y$，他会有几种组成情况，然后再反着前缀和一下就可以算出 $X+Y$ 大于当前长度的种数有多少！我直接遍历所有长度了，应该可以优化！

那么我们就可以在枚举 $Z$ 时 $O(1)$ 查询符合的种类数目啦，然后统计一下就好了。

下面是 $AC$ 代码！
```cpp
	ios::sync_with_stdio(0);
	int a,b,c,d;
	cin >> a >> b >> c >> d;
	rep(i,a,b)
	{
		sum[i+b]++;
		sum[i+c+1]--;//差分
	}
	rep(i,1,maxn)
		sum[i] += sum[i-1];//前缀和
	per(i,maxn-1,0)
		sum[i] += sum[i+1];//反着前缀和
	int ans = 0;
	rep(i,c,d)
		ans += sum[i+1];//统计答案
	cout << ans;
	return 0;
```
