打完CF又来写题解啦~求兹磁qwq（第一次AC div2的D题）

[CF题面传送门](https://codeforces.com/contest/1355/problem/C) [洛谷题面传送门](https://www.luogu.com.cn/problem/CF1355C) [博客食用更佳](https://www.luogu.com.cn/blog/b6e0/tijie-CF1355C)

首先补充一个小学三四年级就学过的知识：三角形三边的关系。

对于三角形的三条边$a,b,c$($a\le b\le c$)，一定满足$a+b>c$（必须大于$c$）。这个就不证了，比较简单。

---
推式子。

首先看到数据范围是$5\times10^5$，我们就可以枚举一维再计算。我首先想到的是枚举$z$，可是$a$和$b$不好计算组数。为了可以使$x,y,z$都能知道组数，我想到枚举$a+b$的和为$i$。下面我们分别看$z$和$x,y$怎么求组数。

$z$应该很好求：$z$有两个取值范围，$[c,i-1]$和$[c,d]$，两个取方案数小的那一个。

$x,y$稍微有点麻烦，我赛时调了很久。

1. $x$和$y$的最小取值是$a$和$b$，我们就可以将$i$比$a+b$多的部分往$a$和$b$上面加。设$i-a-b=j$，则有这几种方法：$a,b+j$,$a+1,b+j-1$,$a+2,b+j-2$......$a+j-1,b+1$,$a+j,b$一共$j+1$种。但是，如果$a+j>b$或者$b+j>c$，就没有这么多了。

2. 还有一种考虑方法：$x$和$y$的最大取值是$b$和$c$，我们就可以将$i$比$b+c$少的部分往$b$和$c$上面减。设$b+c-i=k$，则有这几种方法：$b,c-k$,$b-1,c-k+1$,$b-2,c-k+2$......$b-k+1,c-1$,$b-k,c$一共$k+1$种。但是，如果$b-k<a$或者$c-k<b$，就没有这么多了。

其实当$a+j>b$或者$b+j>c$时，第二种计算方法一定是正确的。当$b-k<a$或者$c-k<b$时，第一种计算方法一定是正确的。但是，有反例（这是我对拍出来的）：
```
1 3 3 3
```
上面两种方法输出的是$4$，其实答案是$3$。所以，我们就要考虑第三种计算方法。

3. 当不考虑$i$的情况时，有$\min(b-a+1,c-b+1)$种。

将这$3$种情况取$\min$，就能得出最终$x,y$的方案数。

由于调试的原因，代码比较长：
```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
	long long a,b,c,d,i,ans=0;//建议开long long
	cin>>a>>b>>c>>d;
	for(i=a+b;i<=b+c;i++)//枚举
		ans+=min(max(0ll,i-c),d-c+1)*min(i-a-b+1,min(c+b-i+1,min(c-b+1,b-a+1)));//式子
	cout<<ans;
	return 0;
}
```
时间复杂度是$O(c-a+1)$。

---
上面是我赛时想出来的。赛后我想出来了一种更简洁的方法。

首先枚举的时候可以做一个小优化：左端点优化为$\max(c+1,a+b)$。

按照这种枚举方法，$x$确定了，$y$就能确定。$y$确定了，$x$就能确定。所以我们只需要考虑$x$。$x$有两种取值范围：$[a,b]$（考虑$x$）和$[i-b,i-c]$（考虑$y$再减）。于是，更短的代码出现了：
```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
	long long a,b,c,d,i,s=0;
	cin>>a>>b>>c>>d;
	for(i=max(c+1,a+b);i<=b+c;++i)//循环做了一个小优化
		s+=(min(d+1,i)-c)*(min(i-b,b)-max(i-c,a)+1);//新式子
	cout<<s;
	return 0;
}
```
时间复杂度是$O(\min(b,c-a+1))$。