>*原文见[这里](https://www.cnblogs.com/Arextre/p/15168461.html)*

找出原树的 $\rm dfs$ 树，显然叶子之间不存在横叉变，那么叶子构成独立集，判断该独立集大小是否大于等于 $\udiv{n}{3}$，如果是，那么显然找到答案了，如果否，将叶子按照 $\rm dfs$ 序排序，并**在最后放入一个根**，假设叶子有 $m$ 个，那么现在我们得到一个大小 $m+1$ 的集合，如果 $2\nmid (m+1)$ 不能整除，则再放入一个根；

设我们最终得到集合大小为 $M(2\mid M)$，对于这个集合，将第 $i$ 个元素与 $i+\frac{M}{2}$ 个元素匹配构成一条树上路径，这样显然可以将所有节点覆盖到，证明如下：

>对于叶子在每个点的分布情况进行讨论：
>
>- 当叶子全部分布在这个点的某个叶子的时候，这个点势必会被某个叶子与根的路径覆盖，所以该方案，无论根是不是叶子，加入一个根节点是必要的；
>- 当叶子分布在至少两个儿子中时，由于是 $i$ 与 $i+mid$ 匹配，那么不论叶子是如何分布，这种匹配方式一定会存在某它子树中的个叶子和它的匹配节点连成的路径跨出该叶子所在子树，这时该节点亦被覆盖；
>
>类似地，可以用这种方法说明除此构造方案以外，其他的方案都有反例（在某些情况下一些错误的构造方案或许可以使用 $\tt random\_shuffle()$ 卡过去？）

由于构造输出是 $\mathcal O(n^2)$ 的，故复杂度就是 $\mathcal O(n^2)$ 的咯......

然鹅并没有代码QAQ