构造好题。

## 【前言】
今天乱找找到的一道题，瞎搞了半个多小时不会做，打开题解一看发现一点说明都没有，网上题解也都只提供了构造方法，这里给出详细思路和正确性说明。

## 【思路】
首先看到数据范围是 $1e5$ ，并且发现他只给了我们 $52$ 个可用字符，到这里应该容易想到要用 $log$ 级别的构造方法。

考虑递归分治。

首先不难发现对于两个字符串 $A$ 和 $B$ ，若 $B$ 在 $A$ 中作为子序列出现过的次数为 $x$ ，那么字符串 $B+c$ 在 $A+c+c$ 中出现过的次数一定恰好为 $2x$ （其中 $c$ 为未在 $A$ 、 $B$ 中出现过的字符）。

这个结论其实挺显然的，对于原 $A$ 中的每一个子序列 $B$ ，都有恰好出现了两个 $c$ 使得子序列变为 $B+c$ ，因此子序列数一定是 $\times 2$ 的。

于是我们大概有了一个把算法变为 $log_2$ 级别的大体思路，并且基本可以解决 $n=2^k(k\in Z)$ 的问题了。

然后我们发现，我们解决不了的是 $n$ 为奇数的所有子问题。

由于奇数可以表示为 $2k+1(k\in Z)$ 的形式，考虑怎么给他加上一个 $1$ 。

~~然后我就想了好久再然后就he题解去了~~

最初的的想法是这样的：

对于 $A,B,c$ （具体定义见上文）：

考虑这样构造使得原先的 $x$ 变为 $2x+1$：

$$
B->B+c,A->B+A+c+c
$$

很显然这个构造是错的，比如构造
$$
ABB ~~~~ AB ~~~~ C ~~~~~~~~~ x=2
$$
时，会出现这样的字符串（这里举出反例是为了下面的说明）：
$$
ABCABBCC~ABC
$$
（这里 $x=11$ ，是不是有些什么意思了？）

但给了一个很好的思路：在 $A$ 前面加上一个 $B$。

发现这个构造错误的原因在于前面加上的这个 $B$ 与后面的 $c$ 产生了关联，因此我们考虑如何消除这种关联。

我们发现上面的构造中 $A$ 这个**字符**出现了两次，并且每一次都造成了 $BBCC$ 权值为 $4$ 的贡献，然后 $B$ 也多出现了一次，导致最终的 $x$ 变为了 $4 + 4 +1+2$ 。

接下来我们只需要想出如何消除这种影响就 $AC$ 此题了。

我们知道，这种影响是新增的 $A$ 、 $B$ 造成了重复的贡献造成的，考虑消除这种重复贡献，由于新增的 $1$ 必不可少，考虑从源头上消除，即删去**后面的** $AB$ ，变为：

$$
ABCBCC~ABC
$$

发现正好是 $x=5$，岂不美哉？

因此考虑这么构造，先按原方法构造，只改变边界状态（发现此时边界为 $x=1$ 或 $x=2$ ），然后在 $A$ 前加上一个 $B$ 即可完成统一加 $1$ 的操作。

但是，我们又发现这时偶数出现了问题，因为我们统一加上了 $1$ ，但是此时我们只需再 $+1$ 即可，而且经过我们对于构造方法的改造，这次 $+1$ 简单许多，即这样变化：

$$
A=c+A+c+c~(A~mod~2=0)
$$

$$
A=A+c+c~(A~mod~2=1)
$$

最终答案为：
$$
A=B+A
$$

由于我们的边界条件删去了最初的 $A$ **字符** ，也就是说，全场只有一个 $A$ **字符**对后面产生贡献，那么每一次 $A$ **串**前的新字符恰好产生 $1$，的贡献。串后的新字符产生$2x$的贡献。

总结下来，就是在分治的大思路下，对于奇数的子问题， $2x$ 由经典的**加两个**$c$，产生贡献，剩下的 $1$ 由最后在 $A$ 串前加的 $B$ 串产生贡献（每个数都会受到贡献哦，具体的不好说明，留给读者自行思考）；然后对于偶数的子问题，在奇数的基础上再 $+1$ 即可。

## 【正确性】
首先这个算法是 $log$ 级的，最终用到的字符个数也是 $log$ 级的，甚至用不上小写字母。

对于另一个限制条件 $200$ ，根据我们的构造方法，每一次最多增加3个字符，增加 $log$ 级次，最后连 $100$ 个字符也不会超过（实测 $n=1e5$ 时 $A$ 字符串长度为 $53$ ）。

所以这个方法是可行的。

## 【代码】
```cpp
#include <bits/stdc++.h>
using namespace std;
int n;
string a, b;
char c;
void work(int x){
    if(x == 1){
        c = 'A';a = "";b = c;
        return ;
    }
    if(x == 2){
        c = 'B';a = "B";b = "AB";
        return ;
    }
    if(x & 1){
        work(x >> 1);
        c ++;
        a = a + c + c;
        b = b + c;
    }
    else{
        work((x >> 1) - 1);
        c ++;
        a = c + a + c + c;
        b = b + c;
    }
}

int main(){
    scanf("%d", &n);
    work(n);
    cout << b + a << ' ' << b;
    return 0;
}
```