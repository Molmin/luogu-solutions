终于来了一道蓝题$qwq$

最近正在重学期望，就来了这么一道期望加DFS练练手

首先先给出期望的计算公式：期望=概率$*$代价

本题中概率即 **父节点的概率/当前节点所能到达的点数（注意根节点所能到达的点数即为它的边数，而其他除叶节点之外的节点所能达到的点数为它的边数$ - 1$，因为它的边有一条是通向父节点的，而父节点马已经去过了，显然是不能回去的）**；而代价呢，就是**节点深度**。

我们猛然发现，这两个东西都可以由DFS得到啊

然后继续观察题目可知，一共$n$个点，$n - 1$条边，显然这是一棵树

$so$，我们从根节点开始搜索，枚举它的每一条边，然后继续搜子节点，概率变为父节点概率（根节点即为$1$）$/$节点边数，把代价（深度）$+ 1$。

搜索到第二个节点，继续枚举每一条边，搜索子节点，概率变为父节点概率（即由根节点计算得到的概率）$/$（节点边数 $- 1$）（至于为什么要$- 1$，上面已经解释清楚了），把代价$+ 1$。

搜索到叶节点，没有可以只有一条边与其父节点相连，又不能走回去，所以就可以计算答案了。答案就是概率$*$代价，即前面计算得到的概率 $*$  前面计算得到的深度。然后返回就可以了。

具体怎么实施代码里面的注释应该已经写得很清楚了，希望$dalao$包容小萌新。

一些小细节：

1、关于如何让马不往回走，即如何让搜索不往回搜。可以$bool$一个$flag$数组，初始化用$memset$全部弄成$false$，如果访问过了就变成$true$。每次遍历边的时候判断一下就好了。

2、关于存图。一共两种存图方式，可能各位前向星用的比较多，但$vector$好写好想好遍历本蒟蒻就用$vector$啦$qwq$。

3、如何判断到了叶节点。大概两个条件，首先这个节点的边数为$1$，其次它不是根节点。

奉上AC代码
```cpp
#include<iostream>
#include<stdio.h>
#include<string.h>
#include<math.h>
#include<algorithm>
#include<vector>
#define maxn 100005
using namespace std;
int n;//总的城市数 
double ans = 0;//记录答案，记得要使用double类型 
bool fl[maxn];//判定此点是否被访问过 
vector<int> q[maxn];//存图用的 

int dfs( int x, double qw, int len ) {//利用DFS进行期望计算 
	if( q[x].size() == 1 && x != 1 ) {//q.size为1并且此时不在根节点，即已经到了叶节点 
		ans += qw * len;//计算答案，期望计算方法为代价*概率，qw为概率，len（即深度）就是代价 
		return 0;
	}
	for( int i = 0; i < q[x].size(); i ++ ) {//遍历 
		int k = q[x][i];
		if( fl[k] == false ) {//没访问过才访问（不然就可能顺着根回去了） 
			fl[k] = true;
			if( x == 1 ) {
				dfs( k, qw * 1 / q[x].size(), len + 1 );
			}
			else dfs( k, qw * 1 / ( q[x].size() - 1 ), len + 1 ); 
		}
	}
}

int main() {
	scanf("%d",&n);
	for( int i = 1; i < n; i ++ ) {
		int x, y;
		scanf( "%d %d", &x, &y );
		q[x].push_back( y );
		q[y].push_back( x );//Vector存图，没必要前向星，怎么简单怎么来 
	}
	memset( fl, false, sizeof( fl ) );
	fl[1] = true;
	dfs( 1, 1, 0 );
	printf( "%.15lf", ans );
}
```

感觉自己还有很多地方写得不到位，希望各位理解啦$qwq$