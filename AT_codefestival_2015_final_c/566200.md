### 题目分析：

题意：有 $n$ 个寿司，有一个饭和一片菜组成，要用这些寿司筑成寿司塔（字符串 $s$），寿司可以直接放，翻转和拆开，问你最少拆开几个，才能做出说给的寿司塔。

这题是道水题，把思路缕清晰了就行了，首先，我们要尽可能地少拆开寿司，我们就可以算这个寿司塔，有几个可以不拆开，然后在用总数减去能不拆开的寿司的数量，就是我们想要的答案了。

这么讲可能有点太概括了点，如果听不懂，我们看一下样例 $1$：

```cpp
3
101100
```

有三个寿司，要弄成 $101100$ 这样的寿司塔，我们就从头开始循环枚举字符，如果这个字符与它后面的字符是 $10$，或 $01$，这两个显然就不需要拆开，为什么 $01$ 也可以呢？因为寿司是可以翻转的，$01$ 不就是翻转 $10$ 翻转一下？所以，枚举完一遍以后，我们再把总数减去不用翻转的数量，就结束了。

**蒟蒻的代码：**

```cpp
#include<bits/stdc++.h>
using namespace std ;
int ans , n ; 
string s ;
int main(){
	cin >> n ; 
	cin >> s ;
	for(int i = 0 ; i < s.length() ; i++){
		if((s[i] == '1' && s[i + 1] == '0') || (s[i] == '0' && s[i + 1] == '1')){ //判断条件
			i++ ; //i++是因为这边加1，循环结束了也加1，就等于加了2，这样做就不会算到重复的黏到一起的寿司了
			ans++ ; 
		}
	}
	cout << n - ans << endl ; //总数减不用拆的寿司
	return 0 ; 
}
```

Tips：这篇题解看了一下，和一楼挺像的，我的话感觉......感觉！能更通俗易懂一点，求过qwq