[题面](https://www.luogu.com.cn/problem/CF1430D)

思路：

首先把01串划分为若干数字相等的连续段。

然后发现每一次最靠前的连续段肯定被消掉。如果最前面的一段长度超过了2，那么第一步肯定选最前面一段的，因为不会影响后面，答案不会变劣。

如果最前面的一段长度等于1，那么如果第一步还选前面1段的话，那么有可能第二步会删除很长的一段，答案可能变劣。那么考虑删后面的。如果删长度等于1的，那么会导致两侧的两段融合为1段，答案变劣。

所以当最前面一段长度等于1的时候应该从后面长度大于2的地方删。

如果在后面找不到这样的段那么答案显然再加上剩余段数除以2上取整。

重点就是如果后面有很多段长度大于1，那么找哪一段？

**找尽量靠前的段。**

下面简单证明一下，如果有不严谨的地方还感谢各位神犇指出。

![B0KZHs.png](https://s1.ax1x.com/2020/11/01/B0KZHs.png)

如图，前面有$c$个长为1的连续段，后面有两个长为$a$和$b$的连续段。

当$a=b$时：

若$c<a-1$，先消去哪段都一样。

当$a-1 \leq c < a+b-2$的时候，如果先消$a$，那么$a$,$b$变为$1$,$b$，但如果先消$b$，那么变为$a$,$1$，到了要消去$a$这一段的时候一定是消掉$a$这一段，留下$b$这一段。先消去$a$则留下的$b$的长度更大，答案肯定更优。

当$c \geq a+b-2$的时候，先消去哪段都一样。

当$a<b$时：

当$c<a-1$时，先消去哪段都一样。

当$a-1 \leq c < a+b-2$时，如果先消$a$，那么$a$,$b$变为$1$,$b-(c-a+1)$，如果先消$b$，那么$a$,$b$变为$a$,$b-c$，无论如何$b$那一段长度都大于等于1，那么怎么选都一样。

当$c \geq a+b-2$的时候，先消去哪段都一样。

当$a>b$时：

当$c<b-1$时，先消去哪段都一样。

当$b-1 \leq c < a+b-2$时，如果先消$a$，那么$a$,$b$变为$a-c$,$b$，如果先消$b$，那么$a$,$b$变为$a-(c-b+1)$,$1$,先消$a$则$b$那一段长度大于1，答案更优

当$c \geq a+b-2$的时候，先消去哪段都一样。

为什么所有情况下让$b$段留下的尽量长更优？因为$a$段要么长度大于2，不借助$b$消掉，要么借助$b$消掉，消完$a$之后$b$一定会留下。留下$b$之后如果$b$的长度大于等于2，那么消掉他对后面没有影响，答案更优。

综上所述，先消$a$更优。推广到更多段长度大于等于2的情况也可以类似地证明。

---

时间复杂度$O(nt)$

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int t,n,siz[300005],tot,sum;
char s[300005];
int main(){
	cin>>t;
	while(t--){
		cin>>n;
		memset(siz,0,sizeof(siz));
		tot=0,sum=0;
		int temp=1;
		scanf("%s",s+1);
		for(int i=2;i<=n;i++){
			if(s[i]!=s[i-1]){
				siz[++tot]=temp;
				temp=1;
			}
			else temp++;
		}
		siz[++tot]=temp;
		int pos=1,flag=0;
		for(int i=1;i<=tot;i++){
			while(pos<=tot&&siz[pos]==1) pos++;
			siz[pos]--;
			if(pos>tot){
				int ans=i-1+(tot-i+2)/2;
				printf("%d\n",ans);
				flag=1;
				break;
			}
			if(pos<=i) pos=i+1;
		}
		if(!flag) printf("%d\n",tot);
	}
	return 0;
}
```