### 简化题意

- 给你 $n$ 个数，第 $i$ 个数是 $a _ i$。
- 你要从中选出若干个数，使得这些数的因子中包含 $1 \sim m$。
- 若可以选出这些数，则输出这些数极差（最大值减最小值）的最小值；否则输出 $-1$。
- 本题有 $t$ 组输入数据。$1 \le t \le 10 ^ 4, 1 \le n, m \le 10 ^ 5, 1 \le a _ i \le 10 ^ 5, \sum n \le 10 ^ 5, \sum m \le 10 ^ 5$

### 解题思路

首先可以将这些数从小到大排好序。容易发现，我们选的这些数一定是连续的（或者说不连续的一定不比连续的更优）。

既然这些数是连续的，可以看作一个区间。我们可以枚举区间的左端点 $l$，再来计算右端点 $r$。

观察到对于 $l ^ \prime > l$，$r ^ \prime$ 也一定 $\ge r$。根据这个性质，我们可以采取双指针算法求解。

首先可以预处理 $1 \sim m$ 的因子。预处理时可以不用 $\text O (m \sqrt m)$ 枚举所有数的因数，而是 $\text O (n \log n)$ 枚举每个因数的倍数，具体见代码。

我们可以用一个数组 $vis$ 来记录某个因子在这些数中出现的次数，$vis _ i$ 表示因子 $i$ 出现了几次；再用一个变量 $cnt$ 记录 $1 \sim m$ 中不同因子的个数。

首先在 $r < n$ 且 $cnt < m$ 的情况下不断增加右端点 $r$，$cnt < m$ 意味着 $1 \sim m$ 的因子还没有全部被包含。在增加右端点 $r$ 的时候，我们把 $a _ r$ 加入了这些数中，就要遍历 $a _ r$ 的所有因数，让这些因数的出现次数加 $1$。

具体地，对于某个因数 $t$，若 $t \le m$，我们让 $vis _ t$ 加 $1$，并在此之前，若 $vis _ t = 0$，则说明因子 $t$ 之前没有而现在有，将 $cnt$ 加 $1$。

更新完右端点 $r$ 后，若 $cnt = m$，则说明 $1 \sim m$ 已经都被包含了，更新答案，令 $ans = \min \{ans, a _ r - a _ l\}$。

然后为左端点 $l$ 增加 $1$ 做调整，我们遍历 $a _ l$ 的所有因数，让这些因数的出现次数减 $1$。

具体地，对于某个因数 $t$，若 $t \le m$，我们让 $vis _ t$ 减 $1$，并在此之后，若 $vis _ t = 0$，则说明因子 $t$ 之前有而现在没有，将 $cnt$ 减 $1$。

最后若答案被更新过，直接输出答案即可；否则输出 $-1$。

### AC Code

```cpp
#include <cstdio>
#include <algorithm>
#include <vector>
#define maxm 100000
#define N 100005
using namespace std;

int T, n, m, t, cnt, ans, a[N], vis[N];
vector <int> v[N]; // 数组 v[i] 存的是 i 的所有因数

int main ()
{
    scanf ("%d", &T);
    for (int i = 1; i <= maxm; i ++) // 枚举因数，时间复杂度 O (n + n/2 + n/3 + ... + n/n) ≈ O (n ln n)
    {
        for (int j = i; j <= maxm; j += i) // 遍历这个因数的倍数
        {
            v[j].push_back (i); // 预处理因数
        }
    }
    while (T --)
    {
        scanf ("%d%d", &n, &m), ans = maxm;
        for (int i = 1; i <= n; i ++)
        {
            scanf ("%d", &a[i]);
        }
        sort (a + 1, a + n + 1); // 先排序
        for (int l = 1, r = 0; l <= n; l ++) // 双指针算法
        {
            while (r < n && cnt < m) // 调整右端点 r
            {
                r ++;
                for (int i = 0; i < v[a[r]].size (); i ++) // 遍历 a[r] 的所有因数
                {
                    t = v[a[r]][i];
                    cnt += t <= m && !(vis[t] ++);
                    // 这个语句其实是个缩写，相当于下面语句：
                    // if (t <= m) // 如果因子 t 在 1~m 范围内
                    // {
                    //     if (!vis[t]) // 如果之前没有因子 t 而现在有了
                    //     {
                    //         cnt ++; // 不同的因子个数加 1
                    //     }
                    //     vis[t] ++; // 多了一个因子 t
                    // }
                }
            }
            if (cnt == m) // 如果不同的因子个数等于 m，即 1~m 全部有了
            {
                ans = min (ans, a[r] - a[l]); // 更新答案 ans，用极差 a[r] - a[l] 和 ans 取 min
            }
            for (int i = 0; i < v[a[l]].size (); i ++) // 遍历 a[l] 的所有因数
            {
                t = v[a[l]][i];
                cnt -= t <= m && !(-- vis[t]);
                // 这个语句其实是个缩写，相当于下面语句：
                // if (t <= m) // 如果因子 t 在 1~m 范围内
                // {
                //     vis[t] --; // 少了一个因子 t
                //     if (!vis[t]) // 如果之前有因子 t 而现在没有了
                //     {
                //         cnt --; // 不同的因子个数减 1
                //     }
                // }
            }
        }
        printf ("%d\n", ans < maxm ? ans : -1); // 输出答案（如果 ans < m 即又被更新过则输出 ans，否则输出 -1）
    }
    return 0;
}
```