/\*
综合性很强，思维量较大的好题。

dp+优化+滚动

一、70分：简单O(n\*m^3)暴力的dp。

f[i][j][k] 母串i之前位置，匹配到字串的j位置，k部分方案数。

f[i][j][k]=f[i-1][j][k]+f[i-l][j-l][k-1](l为刚好不能相匹配的那一位置)

二、90分：优化dp时间，O(n\*m^2)。

由于状态复杂度已经为O(n\*m^2)，显然均为有用的状态，考虑在状态转移上优化为常数。

仔细观察：(设刚好不能匹配的原串与字串的位置为l1,l2)

f[i][j][k]=f[i-1][j][k]+(f[i-1][j-1][k-1]+..+f[l1][l2][k-1])

f[i-1][j-1][k]=f[i-2][j-1][k]+(f[i-2][j-2][k-1]+..+f[l1][l2][k-1])

发现与之前某一状态产生了重叠。

欣喜之余，得到f[i][j][k]=(f[i-1][j-1][k]-f[i-2][j-1][k]+f[i-1][j-1][k-1])+f[i-1][j][k]

但是也许l1=i-1,l2=j-1，即此为累加的第一个数。只需讨论一下即可。

转移的时间因此降为常数阶。

至此算法性能已有巨大飞跃。

三、100分：优化dp空间，上滚动数组，空间O(m^2)。

理论上直接滚动即可，但是方程中出现了跨度为2的状态。

考虑能否让j倒着循环，以防止i-2的状态与新状态相冲突。

乍一看没问题，但是结合方程，发现这样做次序错了，方程就错了。

因此得想其它的方法，考虑到新开一个数组临时存放，注意f[]的初始化。

注意细节：

1.边dp边取模，不能忘记。dp前观察数据范围，2\*mo不会超int,这样才可以放心地开int。

2.状态转移存在减法需注意。

3.开滚动时注意状态的冲突。

4.注意匹配0个的边界，由于初始化过，之后不理睬即可。

\*/
```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#include<cstdlib>
#define mo 1000000007
using namespace std;
int f[2][201][201],g[201][201];
char a[1001],b[201];
int i,j,k,l,n,m,p,len;
int main()
{
    memset(f,0,sizeof(f));
    scanf("%d%d%d",&n,&m,&p); gets(a);
    a[0]=b[0]=1;
    gets(a+1); gets(b+1);
    f[1][0][0]=1; f[0][0][0]=1;
    for (i=1; i<=n; i++) {
        int t1=i&1, t2=(i-1)&1;
        if (i>1)
            for (j=1; j<=m; j++)
                for (k=1; k<=p; k++) {
                    g[j][k]=f[t1][j][k];
                    f[t1][j][k]=0; //init
                }
        for (j=1; j<=min(i,m); j++)
        {
            if (a[i]==b[j]) {
                for (k=1; k<=p; k++)
                    if (j==1) f[t1][j][k]=f[t2][j-1][k-1];
                    else {
                        f[t1][j][k]=(f[t2][j-1][k]-g[j-1][k]+f[t2][j-1][k-1])%mo;
                        if (f[t1][j][k]<0) f[t1][j][k]+=mo;
                    }
            }
            for (k=1; k<=p; k++) 
                f[t1][j][k]=(f[t1][j][k]+f[t2][j][k])%mo;
        }
    }
    printf("%d",f[n&1][m][p]);
    return 0;
} //f[i][j][k] 母串i位置位置，匹配到字串的j位置，k部分方案数。

```