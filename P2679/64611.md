一道本来挺正常的DP，硬生生让我毒瘤了半天。。。

题意：在$A$串里拿出$k$个子串，令之与$B$串相等，求方案数。

看起来好像没法下手啊？就算去暴力，这个暴力怎么打也是个问题。

~~但是又好像一看就是$DP$。~~

不过，这个$DP$怎么写？~~我快被搞疯了（大概是因为这类$DP$练的太少）~~

### 我们想暴力一点，~~暴力$DP$了解一下。~~

状态设为：$f[i][j][k]$表示$A$串前$i$个，匹配了$B$串前$j$个，选了$k$个子串的方案数，**而且当前的$i$和$j$匹配**。

然后每次转移也暴力一点，不是说$A$串前$i$个嘛，那我们就去枚举一下上一次最后一个是哪个和$j-1$匹配的。这些都需要统计到$f[i][j][k]$里面，所以$f[i][j][k]$就需要加上$f[1][j-1][k-1]$(由于当前的$i$和$j$是第$k$个,那么显然上一次匹配是第$k-1$个子串）$+f[2][j-1][k-1]+f[3][j-1][k-1]+...+f[i-1][j-1][k-1]$。而如果当前的$i$与$j$匹配和前面的可以连在一起，那也是一种情况，而此时子串数量和上一次匹配相等，即还要加上$f[i-1][j-1][k]$。

综上：$f[i][j][k]=f[1][j-1][k-1]+...f[i-1][j-1][k-1]+f[i-1][j-1][k]$我们发现如果真的去枚举这个$1$到$i-1$未免有些太笨了，不如在算的过程中用另一个数组$g[i][j][k]$维护一下前缀和，令$g[i][j][k]$==
$\sum\limits_{p=1}^if[p][j][k]$，则原状态转移方程变为：$f[i][j][k]=g[i-1][j-1][k-1]+f[i-1][j-1][k]$.

这样写一个$DP$出来就能得$70pts$了（注意空间限制），代码如下：

### $Code:$
```
#include<bits/stdc++.h>
using namespace std;
char a[1010],b[210];
int f[501][101][101];//a串前i个，b串前j个，选k个子串的方案数。 
int g[501][101][101];
int main(){
    int n,m,k;
    cin>>n>>m>>k;
    scanf("%s%s",a+1,b+1);
    g[0][0][0]=1;
    for(int i=1;i<=n;i++){
    	g[i][0][0]=1;
        for(int j=1;j<=m;j++){
            for(int k1=1;k1<=k;k1++){
                if(a[i]==b[j]) f[i][j][k1]=(f[i-1][j-1][k1]+g[i-1][j-1][k1-1])%1000000007;
                else f[i][j][k1]=0;//目前可以省略，但滚动时必须有
                g[i][j][k1]=(g[i-1][j][k1]+f[i][j][k1])%1000000007;
            }
        }
    } 
    printf("%d",g[n][m][k]);//很显然答案需要把f[1...n][m][k]全部算上，即为g[n][m][k];
    return 0;
} 
```
空间不够怎么办呢，我们注意到每次的$f[i][j][k]$和$g[i][j][k]$只与上一次的$i-1$有关，那么我们就可以压掉$i$这一维。而且直接采用就地滚动就好了，不用开成$[0/1]$。

### $Code:$
```
#include<bits/stdc++.h>
using namespace std;
char a[1010],b[210];
int f[201][201];//a串前i个，b串前j个，选k个子串的方案数。 
int g[201][201];
int main(){
    int n,m,k;
    cin>>n>>m>>k;
    scanf("%s%s",a+1,b+1);
    g[0][0]=1;
    for(int i=1;i<=n;i++){
        for(int j=m;j>=1;j--){//倒序枚举就地滚动，原理同01背包
            for(int k1=1;k1<=k;k1++){//前一维在滚动时不变，故这一维会跟着保存下来，这一维就不用倒序了
                if(a[i]==b[j]) f[j][k1]=(f[j-1][k1]+g[j-1][k1-1])%1000000007;
                else f[j][k1]=0;
                g[j][k1]=(g[j][k1]+f[j][k1])%1000000007;
            }
        }
    } 
    printf("%d",g[m][k]);
    return 0;
} 
```
$100pts$到手。