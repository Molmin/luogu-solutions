一个能耗我好几个小时的普通dp。我感觉我在做这题时，一开始大部分时间做的都是无用功，选择一种合适的方法入手才相当于真正开始做这题，当然找对了切入点这题就一点不难。

对于线性结构上的dp，发现自己复杂度超了，要么是方程不合理，要么是可以优化转移。而这题关键就是优化转移。

#### 题意

给定2个字符串$A$,$B$，求有多少种方案，将$B$分成$k$段，使得这些段在$A$中依次出现。

#### 70pts

首先暴力肯定是不行的，求方案数显然需要dp

有点经验的应该能立即想出dp数组：$f[i][j][p]$表示$A$到$i$，$B$用完了前$j$个，分成了$p$段，并且$A_i$是最后一个匹配的字符。（$p$不与题目中的$k$重复）

如果这时就用最大数据开数组，就会发现空间显然不够。但对于70pts做法，不需要管，只用开前7个点够用的数组。

可以不必一上来就考虑标算的做法，因为比如这题就是靠转移优化来实现标算复杂度的。

然后我们考虑dp方程和转移。根据数组表示，$f[i][j][p]$不为0，当且仅当$A_i=B_j$。如果满足这个条件，那么就能枚举断点进行转移了（可以一次性匹配$B$中连续多个字符）。假设已经成功从$A_{i-L+1}$和$B_{j-L+1}$开始匹配，那么上一次在$A$中取串的最后位置可以在$[1,i-L]$任取。

需要用数组$g[i][j][p]$表示关于$i$的前缀和，方程为：$f[i][j][p]=\sum_Lg[i-L][j-L][p-1]$，其中$L$为$A$的前$i$项、$B$的前$j$项的公共后缀长度（不一定最长，只要当$A_i=B_j$时循环下去就行了）。想不出前缀和我也没办法。应该只要想到枚举断点的方法，转移方程就能出来了。

最坏复杂度为$O(nm^2k)$

可见出题人很良心，送了我们这么多分。

```cpp
	for (int i=1;i<=n;i++) {
        g[i-1][0][0]=1;
        for (int j=1;j<=m && j<=i;j++) {
            for (int p=1;p<=k && p<=j;p++) { //段数
                for (int l=0;l<i && l<j && a[i-l]==b[j-l];l++) { //枚举断点
                    (f[i][j][p]+=g[i-l-1][j-l-1][p-1])%=MOD;
                }
                g[i][j][p]=(g[i-1][j][p]+f[i][j][p])%MOD;
            }
        }
    }
```

#### 100pts

显然为了优化复杂度，得去掉枚举$L$的过程。对$g$数组求前缀和？应该可以这样做，但并不需要。排除掉$A_i≠B_j$的情况，我们发现求和的展开式中，$f[i][j][p]$的恰好比$f[i-1][j-1][p]$的多了一项$g[i-1][j-1][p-1]$（因为最长公共后缀长度增加了1），那么可以直接这样转移：

$$f[i][j][p]=\begin{cases}  0 & A_i≠B_j\\f[i-1][j-1][p]+g[i-1][j-1][p-1] & A_i=B_j\end{cases}$$

复杂度为$O(nmk)$

到这里已经基本上解决问题了，只需要考虑优化空间，即使用滚动数组。$n$,$m$,$k$基本上同级，且转移只涉及相邻项，根据方程，应该随便滚哪个都行。这里我选择滚掉$i$这维。滚动有3种方法，第1种是根据转移顺序覆盖掉之前的数据（比较危险但很优美），第2种是用2个指针交替定位，第3种是对下标$i$取模（推荐，只不过看上去有点**）。

这里我用像01背包那样倒着循环的方法，理论上$j$,$p$都需要倒着，但实测$j$倒着就行了。

难得的代码特别短的题。不知为何评测排名进入第2页。

```cpp
#include <cstdio>
#define MAXN 1010
#define MAXM 210
using namespace std;
const int MOD=1e9+7;
int n,m,k;
char a[MAXN],b[MAXM];
int f[MAXM][MAXM]; //a到n, b到m, 取了k串
int g[MAXM][MAXM]; //f的前缀和
inline int min(int a,int b) { return a<b ? a : b; }
int main() {
    scanf("%d%d%d",&n,&m,&k);
    scanf("%s%s",a+1,b+1);
    g[0][0]=1;
    for (int i=1;i<=n;i++) {
        for (int j=min(m,i);j>=1;j--) {
            for (int p=min(k,j);p>=1;p--) {
                f[j][p]=a[i]==b[j] ? (f[j-1][p]+g[j-1][p-1])%MOD : 0;
                g[j][p]=(g[j][p]+f[j][p])%MOD;
            }
        }
    }
    printf("%d\n",g[m][k]);
    return 0;
}
```
