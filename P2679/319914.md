这道题的状态表示非常简单，直接使用自然状态，$f[i][j][k]$ 表示从字符串 $A$ 中前 $i$ 个字母组成的字符串中选出 $k$ 个互不重叠的子串，并且按照出现顺序连接，组成字符串 $B$ 中前 $j$ 个字符表示的字符串有多少种方法。

计算这个值有个~~非常naive的~~方法，直接枚举最后一段即可。分类讨论：

+ 如果 $A$ 第 $i$ 个字符与 $B$ 的第 $j$  个字符并不相同，那么显然 $f[i][j]][k]=f[i-1][j][k]$
+ 如果 $A_i=B_j, A_{i-1} \neq B_{j-1}$，那么 $f[i][j][k] = f[i-1][j][k]+f[i-1][j-1][k-1]$
+ 依次类推，如果 $A_i=B_i\cdots A_{i-t}=B_{j-t},A_{i-t-1}\neq B_{j-t-1}$，那么 $f[i][j][k]=f[i-1][j][k]+f[i-1][j-1][k-1]\cdots +f[i-t][j-t][k-t]$。

这样我们得到了一个 **最坏情况** $\mathcal O(NM^2K)$ 的做法，但是这题数据显然过水，[可以通过卡常卡进时限](https://www.luogu.com.cn/record/34041604)。

注意到 $f[i][j][k]$ 的计算方法中有一部分在计算 $f[i][j-1][k]$ 的时候也用到了，将 $f[i][j][k]$ 的转移方程拆成自己的部分与 $f[i][j-1][k]$ 中的一部分。
$$
f[i][j][k]=\color{blue}{f[i-1][j][k]+f[i-1][j-1][k]}+\color{red}{f[i-1][j-1][k-1]\cdots +f[i-t][j-t][k-t]}
$$

那么在 dp 时**额外记录红色部分。**那么可以 $O(1)$ 转移，这样就可以通过本题。

注意到本题卡了空间。因为 $ f[i] $ 转移只依赖 $f[i-1]$，因此直接把第一维度使用**滚动数组**进行优化即可卡过。

~~最后提醒大家：如果碰到 DP 题目不会做，可以先膜拜 UM 神仙以增加 RP。~~

[Code](https://www.luogu.com.cn/record/34052070)