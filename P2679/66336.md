大体思路，三维数组存的i,j,k,分别是A串选取到哪个字符，B串选取到哪个字符，以及选取的字符串的个数。

```
#include<bits/stdc++.h>
#define ll long long 
using namespace std;
int n,m,k;
 f[2][201][201],s[2][201][201];//由于三维不可能开那么大，所以只开到f[0]和f[1]，继续往下。
char a[10001],b[1001];
const int mod=1000000007;
int main()
{
	scanf("%d%d%d",&n,&m,&k);
	scanf("%s",a+1);
	scanf("%s",b+1);//读入。
	int now=1,last=0;//此处用到的是滚动数组，最后会放个图帮助下理解，然，度娘是最爱你的。
	f[0][0][0]=1;//初始。
	for(int i=1;i<=n;i++)
	{
		f[now][0][0]=1;
		for(int j=1;j<=m;j++)
			for(int kk=1;kk<=k;kk++)
			{
				if(a[i]==b[j])
				{
					s[now][j][kk]=(s[last][j-1][kk]+f[last][j-1][kk-1])%mod;
/*讲一下三次转移。这是第一次，三个字符分别表示的意义已经给出，
对于A串和B串中匹配到相同的字符，处理：
            1. 延续这个子串，即kk不是从上一个过来的，所以不用-;

			2. 新开一个子串,即kk是新的一个字符串，上次的要-；
*/
				}
				else
				{
					s[now][j][kk]=0;
				}
				f[now][j][kk]=(f[last][j][kk]+s[now][j][kk])%mod;
                /*用于计算f数组，f[i][j][kk]表示在A串的前i个字符中选
                kk个子串匹配B串的前j个字符的方案数.求方案数可以采用加
                法原理，考虑A串的第i个字符,那么这个字符的决策只有取或
                不取，加法原理，把不取的方案数和取的方案数加起来就可
                以。
                */
			}
			swap(now,last);
            /*滚动数组别忘记交换，
            否则[0]和[1]不变的情况下永远都是和自己交换。
            当然，大佬也可以写成&1和形式，
            因为每个i值都是从上一个递推里面出来的，
            相当于二进制下取最后一位，每个相邻的数都是不一样的。
            还不理解的话瞅瞅最后面那个东西，毕竟我也是Ju~，我也爱度娘。
            */
	}
	printf("%lld\n",f[last][m][k]);
	return 0;
}
```
![](https://cdn.luogu.com.cn/upload/pic/40583.png)