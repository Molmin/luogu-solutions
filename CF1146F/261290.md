## CF1146F Leaf Partition


------

为了备课写了几道树形 dp，这道就是其中之一，思路比较简单，代码也只有 30 行，但是容斥死活搞不清楚，半天没过第四个点，拍的小数据也不给力，debug 一年后口胡一组数据卡掉了，改完就过了。打完看了看和题解的思路不太一样，就水篇题解。


------

## 题意分析

题目总结一下就是求把一棵树的叶子划分为几个连通块的方案数，要求划分的连通块不相交，并包含所有叶子。


------

## 解法

简单构思就会想到在树上 dfs 处理，对每个节点处理出子树的划分方案数，再向上合并。

记录两种状态：

&emsp;&emsp;1.$dp_{x,0}$ 表示 $x$ 未被划进任何连通块内，即不存在两个不同儿子所在子树的任何叶子被划进同一连通块（否则 $x$ 也必须划进这个连通块）的包含子树中所有叶子的划分数。

&emsp;&emsp;2.$dp_{x,1}$ 表示 $x$ 被划进一个连通块内的包含子树中所有叶子的划分数。

考虑转移：

设当前考虑的节点为 $x$，当前考虑的儿子为 $y$。

（1）

&emsp;&emsp;$dp_{x,1}$ 必须保证有两个 lca 为 $x$ 的点被划进了一个连通块，换种说法就是有至少两个儿子向上延伸在 $x$ 处会合。

&emsp;&emsp;考虑把儿子遍历一遍，用一个 $tot$ 变量记录前面遍历过的儿子向上蔓延和不向上蔓延的总方案数（前缀积），再用一个 $tot2$ 变量记录前面遍历过的儿子都不向上蔓延的方案数，很明显，$tot-tot2$ 就是前面有至少一个儿子向上延伸了的方案数，乘上这个儿子向上延伸的方案数就是这个儿子对 $dp_{x,1}$ 的贡献。

&emsp;&emsp;为了保证方案不重不漏加上一个简单的容斥（ISYRHH 管什么都叫容斥），记录方案时只在后面更新前面的延伸，并保证后面的都不会延伸（通过在遍历下一个儿子时对 $dp_{x,1}$ 乘上下个儿子不向上延伸的方案数实现。

（2）

&emsp;&emsp;$dp_{x,0}$ 要保证没有一个儿子向上延伸（不可能只有一个儿子向上延伸）在遍历完所有儿子后把 $tot2$ 赋给 $dp_{x,0}$ 即可。

开始我把儿子的 $dp_{y,1}$（向上蔓延），$dp_{y,0}$（向上蔓延），$dp_{y,1}$（不向上蔓延），$dp_{y,0}$（不向上蔓延）和的前缀积作为 $tot$，儿子的 $dp_{y,1}$（不向上蔓延），$dp_{y,0}$（不向上蔓延）和的前缀积作为 $tot2$，交上代码后发现在第四个点挂了（而且答案相差很小，我怀疑了半天取模的问题）。

再仔细研究一下题面会发现，对于一个 $dp_{y,1}$ 的向上蔓延没有问题，但是对于一个 $dp_{y,0}$ 的向上蔓延，可能有不止一种的方案，还需要考虑每种方案子树有几个节点可以向上延伸。

于是还需要再引入一个 $dp_{x,2}$ 记录对于 $x$ 没有被包含的方案中，有多少个节点是可以向上蔓延的。

$dp_{x,2}$ 同样必须保证没有一个儿子向上延伸，然后对每个儿子分别考虑使该儿子子树中的节点向上延伸的方案数。

不包含该儿子的方案的贡献即为该儿子的 $dp_{y,2}$。

若包含该儿子，则只有一种方式向上延伸，这部分的贡献为 $dp_{y,1}$。

同样需要乘上 $tot2$，并对于在遍历到每个儿子时将 $dp_{x,2}$ 乘上这个儿子不向上延伸的方案数。

这样就得到了 $dp_{x,2}$ 的转移。

重新把儿子的 $dp_{y,1}$（向上蔓延），$dp_{y,2}$（向上蔓延），$dp_{y,1}$（不向上蔓延），$dp_{y,0}$（不向上蔓延）和的前缀积作为 tot，儿子的 $dp_{y,1}$（不向上蔓延），$dp_{y,0}$（不向上蔓延）和的前缀积作为 $tot2$，按照前面的方式计算出 $dp_{x,0}$ 和 $dp_{x,1}$。

最后的答案就是 $dp_{1,0}+dp_{1,1}$。

（记得开 long long，记得取模……）


------------

## 代码

```cpp
#include<cstdio>
#include<vector>
#define mo 998244353
using namespace std;
long long n,m,in,fa[200001],dp[200001][3];
vector<long long>ed[200001];//《因为太懒就直接邻接表存图了》
void dfs(long long x)
{
    if(ed[x].empty()){dp[x][1]=1;return;}//若为叶子节点直接返回
    long long tot=1,tt=1;//分别记录所有情况的前缀积和不向上延伸的前缀积
    for(vector<long long>::iterator ite=ed[x].begin();ite!=ed[x].end();ite++)
    {
        fa[*ite]=x;dfs(*ite);
        dp[x][1]=(dp[x][1]*((dp[*ite][0]+dp[*ite][1])%mo)%mo+(dp[*ite][1]+dp[*ite][2])%mo*(tot-tt)%mo)%mo;
        dp[x][2]=dp[x][2]*((dp[*ite][0]%mo+dp[*ite][1]%mo)%mo)%mo;dp[x][2]=((dp[*ite][2]+dp[*ite][1])%mo*tt%mo+dp[x][2])%mo;//简单的dp转移
        tot=tot*((dp[*ite][1]%mo+dp[*ite][1]%mo+dp[*ite][0]%mo+dp[*ite][2])%mo)%mo;tt=tt*((dp[*ite][0]%mo+dp[*ite][1]%mo)%mo)%mo;//简单的前缀积转移
    }
    dp[x][0]=(dp[x][0]%mo+tt%mo)%mo;//处理dp[x][0]
}
int main()
{
    scanf("%lld",&n);
    for(long long i=2;i<=n;i++)
    {
        scanf("%lld",&in);
        ed[in].push_back(i);
    }
    dfs(1);
    printf("%lld",((dp[1][0]%mo+dp[1][1]%mo)%mo+mo)%mo);
    return 0;
}
//I can't happy anymore（本来想水点题快乐，就把程序名定成了happy，结果debug过于痛苦……）
```

------------


## **end**