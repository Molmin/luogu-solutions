[orz](https://www.luogu.com.cn/problem/CF1146F)

题意：给叶子结点划分若干个集合，使得每个结点集合的最小连通子图互补相交，有多少种划分方案。

#### 这里给出一种更简便的DP方法

类似于样例的图解，考虑根结点是否染上颜色。

如果不染上，说明根不属于任何一个集合的最小连通子图，根的儿子子树各自划分为相同的子问题。

如果染上，说明**根的儿子中，至少有$2$个子树包含的叶子在同一集合**。比如根是 $1$，他的儿子是 $2,3$，$\operatorname{subtree}(2)$ 中的一些叶子和 $\operatorname{subtree}(3)$ 中的一些叶子在同一集合，结点 $1$ 才能被染色。

考虑 $1$ 的儿子，假设是 $2$，考虑子树 $2$ 的答案。

如果 $1$ 不染色，那么子树 $2$ 的计算与 $1$ 相同。

如果 $1$ 染色，那么**子树 $2$ 至少有一个颜色“抬”到了结点 $2$**。

设树有 $5$ 个点，边为 $1-2,1-3,2-4,2-5$。

如果 $4$ 和 $5$ 在同一集合，那么 $1$ 就要染色。如果 $1$ 染色，那么 $2$ 也要染色。正是 $2$ 和 $3$ 分别至少有一个颜色“抬”到了 $2,3$ 自己本身，这两个颜色才能在 $1$ 合并（即：$4,5$ 合并在同一集合），此时 $1$ 才能染色。

所以，我们不难设状态：

$f_{u,0}$ 表示只考虑子树 $u$ 的答案。

$f_{u,1}$ 表示至少有一个颜色“抬”到了 $u$（为了给父亲合并）。

不妨设 $a$ 表示没有颜色在 $u$ 合并的计数，$b$ 表示只有 $1$ 个颜色到达 $u$ 的计数，$c$ 表示至少 $2$ 个颜色在 $u$ 合并的计数。

显然，$f_{u,0}=a+c,f_{u,1}=b+c$。

而 $a,b,c$ 的计算也很简单。

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const ll maxn=4e5+10,mod=998244353;
ll n,p,f[maxn][2];
vector<ll>vec[maxn];
void dfs(ll u)
{
	if(vec[u].empty())
	{
		f[u][0]=f[u][1]=1;
		return;
	}
	ll a=1,b=0,c=0;
	for(ll i=0;i<vec[u].size();i++)
	{
		ll v=vec[u][i];
		dfs(v);
		c=(c*(f[v][0]+f[v][1])+b*f[v][1])%mod;
		b=(b*f[v][0]+a*f[v][1])%mod;
		a=a*f[v][0]%mod;
	}
	f[u][0]=(a+c)%mod;
	f[u][1]=(b+c)%mod;
}
int main()
{
	scanf("%lld",&n);
	for(ll i=2;i<=n;i++)
	{
		scanf("%lld",&p);
		vec[p].push_back(i);
	}
	dfs(1);
	printf("%lld",f[1][0]);
	return 0;
}
```