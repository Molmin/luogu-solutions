感觉不错的一道树 dp，状态设计的细节很多

## 解析

可以知道题中要求的 “最小连通子图” 一定是叶子两两间最短路径（到 lca 然后再下来）的并

定义连接两个同组结点的边为 “染色边”；同样地，如果一个结点被划分到某个连通子图内，就称它为 “染色的”（叶子一定染色）

&nbsp;

我们设 $dp(u, 0/1/2)$ 表示 $u$ 向儿子连接了 $0/1/\geq2$ 条染色边的方案数，这里要求 $u$ 不能为叶子（原因后面讲）

可以发现，连了 $0/\geq2$ 条染色边的结点，都是可以确定最后不是/是被染色的；而只连了 $1$ 条染色边的结点，我们必须接着向上连直到 “合并”（否则就不是最小连通子图了）

于是连了 $0$ 条染色边的结点不能再向上连染色边；连了 $1$ 条染色边的结点一定要向上连染色边；连了 $\geq2$ 条染色边的结点可以向上连染色边，也可以不连

通过对儿子染色状态的推断，我们就可得出（加入新儿子时的）转移方程：

$dp'(u, 0)=dp(u, 0)\cdot(dp(v, 0)+dp(v, 2))$

$dp'(u, 1)=dp(u, 0)\cdot(dp(v, 1)+dp(v, 2))+dp(u, 1)\cdot(dp(v, 0)+dp(v, 2))$

$dp'(u, 2)=dp(u, 1)\cdot(dp(v, 1)+dp(v, 2))+dp(u, 2)\cdot(dp(v, 0)+dp(v, 1)+2dp(v, 2))$

其中 $v$ 是新加入的儿子子树根；相乘可以理解为每种方案一一 “配对”（感觉这还是挺好理解的）

注意第三行中的 $2dp(v, 2)$，这是因为 “连了 $\geq2$ 条染色边的结点可以向上连染色边，也可以不连”

而 dp 的初值可以根据定义得出，应为 $dp(u, 0) =1, dp(u, 1) =0, dp(u, 2) =0$

&nbsp;

最后我们再考虑叶子的状态设计

由于我们在转移时，实际上是考虑儿子的染色情况；于是即使叶子不会向下连染色边，我们由在父亲处的转移要求可以推断出，叶子的 dp 初值应为 $dp(u, 0) =0, dp(u, 1) =0, dp(u, 2) =2$（叶子一定被染色）

（如果觉得这种方式不严谨的话，其实也可以考虑在转移时专门处理叶子的贡献；不过简化后代码应该和这种方式是相同的）

## CODE

代码中的变量命名和题解可能有出入，具体见注释

```cpp
#include <cstdio>
#include <vector>
#define ll long long
using std::vector;

const int MAXN =2e5+50;
const int M =998244353;

/*------------------------------Map------------------------------*/

vector<int> E[MAXN];

/*------------------------------Dfs------------------------------*/

/*u 现在相连的染色儿子数为 0, >= 2, 1 ( 也可以定义为 ( 最终 ) 染色什么，但都有瑕疵 )*/
int f[MAXN], g[MAXN], h[MAXN];
int f2, g2, h2;
void dfs(int u){
	/*这里对叶子的状态缺省值设定，是由在父亲处的合并要求推断出的 : 只有 >= 2 才能确定被染色，叶子确定被染色*/
	/*可能还是不严谨，或可对叶子特殊定义状态*/
	if((int)E[u].size() == 0)
		g[u] =1;
	else
		f[u] =1;
	for(int v:E[u]){
		dfs(v);
		f2 =f[u], g2 =g[u], h2 =h[u];
		f[u] =1ll*f2*((ll)f[v]+g[v])%M;
		g[u] =(1ll*g2*((ll)f[v]+h[v]+2ll*g[v]/*因为既可以连也可不连*/)%M+1ll*h2*((ll)g[v]+h[v])%M)%M;
		h[u] =(1ll*f2*((ll)h[v]+g[v])%M+1ll*h2*((ll)f[v]+g[v])%M)%M;
	}
}

/*------------------------------Main------------------------------*/

inline int read(){
	int x =0; char c =getchar();
	while(c < '0' || c > '9') c =getchar();
	while(c >= '0' && c <= '9') x = (x<<3) + (x<<1) + (48^c), c =getchar();
	return x;
}

int main(){
	int n =read();
	for(int i =2; i <= n; ++i){
		int pi =read();
		E[pi].push_back(i);
	}
	dfs(1);
	printf("%d", (f[1]+g[1])%M);
}
```