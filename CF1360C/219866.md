## CF1360C Similar Pairs 题解
题目大意：给你 $n$ 个整数（$n$ 为偶数），问是否可以将这 $n$ 个数分为若干对数，使得每对数的奇偶性相同或差值为 $1$？

可以分成两个步骤判断：

设数列中偶数的个数为 $m$，当 $m$ 为偶数时，所有的偶数因为奇偶性相同，可以被分为 $m/2$ 对。由于总个数为偶数，奇数的个数也为偶数，因此所有的奇数也可以被分为偶数对。所以，当数列中偶数的个数为偶时，直接输出 YES 。

当数列中偶数的个数不为偶时，就要把数列排序，看看有没有两个数的差值为 $1$。只要有两个数差值为 $1$，就输出 YES 。否则输出 NO 。

简单证明一下：由于此时数列中偶数的个数不为偶，可得数列里奇数和偶数的个数都为奇。只要有两个数差值为 $1$，就可以先把这组提出。而剩下的数里就会少掉一个偶数和一个奇数，于是就只剩下了偶数个偶数和偶数个奇数，就可以利用奇偶性相同分完剩余的数。

思路应该还是比较清晰的。
### Code
```cpp
#include<bits/stdc++.h>
#define For(i,a,b) for(register int i=(a);i<=(b);++i)
#define Rep(i,a,b) for(register int i=(a);i>=(b);--i)
using namespace std;
int T,n,a[55];
int main()
{
    cin>>T;
    while(T--)
	{
		cin>>n;
		int m=0,cnt=0; //m用来统计数列中偶数的个数
		For(i,1,n)
		{
			cin>>a[i];
			if(a[i]%2==0) m++;
		}
		if(m%2==0) puts("YES");
		else
		{
			sort(a+1,a+n+1); //升序排序
			For(i,2,n)
				if(a[i]-a[i-1]==1)
					cnt++; //统计差值为1的数对的个数
			puts(cnt>=1?"YES":"NO"); //有一对数差值为一就输出YES，否则输出NO
		}
	}
    return 0;
}
```