（本题中 $d$ 是公差的意思，$a_{i}$ 是数组元素的意思）

数列题。

对于唯一 A 掉的紫题是数列题的我来说，这题的思路很好找。

很显然，先将此数列去重，排序，然后看它的长度。

由于数据范围很小，所以开布尔数组去重以减小码量。

当只剩下一个数时，很明显所有其他数都相同（或本来只有这一个数）。

存储公差为 $0$。

当剩下两个数时，如果 $d$ 为偶数，那么可以将原数组插入一个数，大小为 $a_{0}$ $+$ $\frac{d}{2}$。

于是到了三个数的情况。三个数时，根据等差中项可知：

$$2 \times a_{1}=a_{0}+a_{2}$$

只有在此情况时，才能得到答案为 $d$。

不满足的都无解。

易证，将原长度为二的数组扩项后的数组都满足条件，公差为 $\frac{d}{2}$。

但是，公差只能为整数，所以原公差为奇数的长度为二的数列不满足条件。

所以需要特判。

另外，由于只能操作一次，所以长度大于三的数列都无解。

代码如下。

```cpp
#include<iostream>
using namespace std;
bool l[150];
int q[3]={0,0,0};
int main(){
	int n,t,s=0;
	scanf("%d",&n);
	for(int i=0;i<n;i++){
		scanf("%d",&t);
		l[t]=1;
	}
	for(int i=0;i<=100;i++){
		if(l[i]&&s<3){
			q[s]=i;
			s++;
		}else if(l[i]&&s==3){
			printf("-1");
			return 0;
		}
	}
	t=q[2]-q[1];//没什么用的省空间算法
	s=q[1]-q[0];//同上
	if(q[1]==0){
		n=0;
	}else if(q[2]==0){
		n=(s%2?s:s/2);
	}else{
		n=(t==s?s:-1);
	}
	printf("%d",n);	
    return 0;
}
```


