# 题目大意：
给定一个长度为 $n$ 的序列，问能否将序列中的所有数要么加上 $D$，要么减去 $D$，要么不做改变，使得修改后的序列所有元素都相等。求出最小的 $D$。若无解，输出 -1。

# 分析：
我们观察题面发现，数据范围十分的小。所以我们直接暴力枚举 $D$ 即可，由题意可知，要求平均值，一个数要不然就是可以被序列最大数减 $D$ 或减 $2D$ 得到，要不然它自己就是最大数，但是如果都不满足，说明现在的 $D$ 是不可行的。所以对于序列中的每一个数，判断它能否由序列最大数与枚举的 $D$ 运算得到，如果不能，就枚举下一个 $D$。如果整个序列都能被得到，那么就说明找到了最小的 $D$， 直接输出即可。但是如果枚举完了也没有找到，说明无解，就输出 -1。

# Code：
```cpp
#include <bits/stdc++.h>
#define int long long 
using namespace std;
int n, a[1000005], zd = -2147483647;
signed main() {
	cin >> n;
	for (int i = 1; i <= n; i++) {
		cin >> a[i];
		zd = max (zd, a[i]);  // 找出序列中的最大数
	}
	int j;
	for (int i = 0; i < 200; i++) {  //数据很小，直接枚举 D
		for (j = 1; j <= n; j++) if (a[j] != zd - i && a[j] + i != zd - i && a[j] - i != zd - i) break;  
        //如果都不能得到，就枚举下一个 D
		if (j > n) {  //如果全部数都满足，直接输出现在枚举的 D
			cout << i << '\n';
			return 0;
		}
	}
	cout << -1 << '\n'; //如果无解，输出 -1
	return 0;
}
```

