发现题解区都没有写部分分的，但考场上部分分很重要，所以发一篇题解来总结一下。

### 题意

找到一段区间，使得区间的最小值乘上区间的长度的值最大。

### 步骤

我们来一步步分析部分分。

$Subtask1$ $20pts$: 

考虑用循环枚举区间，同时用线段树优化寻找区间最小值，时间复杂度 $O(N^2logN)$。

$Subtask2$ $60pts$: 

观察数据范围，可以发现，这个部分分应该是带有 $logN$ 的做法。考虑如下性质：

1. 对于一个最小值，我们要想使得答案最大，肯定是要求该最小值生效的区间最长。

1. 对于一个区间，如果我们删掉其最小值，然后缩短其区间长度，答案**可能**变大。

从以上两条性质，我们考虑递归求解。从区间 $[1,n]$ 开始，我们每次用线段树查询当前区间的最小值，并计算答案。
如果最小值的 $pos$ 处于区间中间，考虑向两边递归，尝试去掉最小值。处于区间边界时特判，直接左移一位或者右移一位即可。

小 $trick$: 线段树查询时可以利用结构体同时查询最小值和 $pos$，同时重载运算符来缩短 $pushup$ 函数的长度。

具体实现题解区的 $amstar$ 大佬好像已经写了，不再赘述。时间复杂度~~应该~~是 $O(Nlog^2N)$

$Subtask3$ $100pts$: 

考虑如何将算法优化至 $O(N)$ 的。上面的两个算法有一些不足之处：

1. 枚举区间

1. 每次都要 $O(logN)$ 的时间来查询最小值。

对于第二条，我们不妨先假设当前的值作为最小值，这是 $O(N)$ 的。然后，考虑什么样的情况下这个数作为最小值时答案最大。

从上文我们可以知道，答案的区间应该尽量长。答案最长区间的端点，贪心地想，就是当前最小值**更新换代**的地方。在哪里更新换代？自然就是分别向左和向右第一个比当前值小的那里啦！

那么我们的正解也就出来了：找到每个数的向左和向右第一个比它小的位置，那么就有当前答案： $a_i * (r_i - 1 - (l_i + 1) + 1)$。

单调栈预处理 + 线性枚举，时间复杂度 $O(N)$。


附 $100pts$ 代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define N 2000010
#define ll long long

template <class T>
inline void read(T& a){
	T x = 0, s = 1;
	char c = getchar();
	while(!isdigit(c)){ if(c == '-') s = -1; c = getchar(); }
	while(isdigit(c)){ x = x * 10 + (c ^ '0'); c = getchar(); }
	a = x * s;
	return ;
}

int stac[N], top = 0;
int a[N]; 
int l[N], r[N]; 
int n;

int main(){
	read(n);
	for(int i = 1; i <= n; i++){
		read(a[i]);
		l[i] = 0, r[i] = n + 1;     // 记得设置边界 
	}
	for(int i = 1; i <= n; i++){  // 单调栈 
		while(top && a[stac[top]] >= a[i]) r[stac[top--]] = i;  
		l[i] = stac[top];
		stac[++top] = i; 
	}
	ll ans = 0;       // 不开 long long 见祖宗 
	for(int i = 1; i <= n; i++)
		ans = max(ans, (ll)(r[i] - 1 - (l[i] + 1) + 1) * a[i]); 
	cout << ans << endl; 
	return 0;
}


```
