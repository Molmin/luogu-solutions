~~题解区朴素 dp 算法者仅二，而其言多模糊。余屡读而不解其转移方程，气急，用自己的方法一遍 A，喟然叹曰，还是我的方法好。~~

排列计数 dp 通常考虑插入 dp。如，最终序列中 $[1,X,X,3,X,5,X]$，如果我们当前只考虑了 $1,3,5$，那么眼前的排列长这样：$[1,3,5]$，而插入一个 $X$ 就是扒开一个夹缝（也可能是首尾）插进去：$[1,X,3,5]$。

----

第一个观察是两数之和为平方，这是一个让人乍一看难以处理的说法。考虑换说法。手推小数据或分析。得知等价于两数各自消去平方因子后相等。

---

接下来便可以 dp 了。我们面对的问题是，现在有 $n$ 个带有颜色的球，所有球视作各不相同，不能使相邻球颜色相同（下文称为一对冲突），求排列方案数。设 $f(i,j,k)$ 表示考虑了 $i$ 个球，$j$ 个冲突，$k$ 个**会产生冲突的夹缝**（**针对于当前颜色而言**）。  
注释：（1）夹缝：两数之间或首或尾。（2）针对于当前颜色而言：插入一个当前颜色（第 $i$ 个球的颜色）的球会和相邻的球产生冲突。

**由于 $k$ 是相对于颜色的，因此如果 $i-1$ 与 $i$ 不是同一种颜色的，那就压根不在同一个频率上考虑问题，很不好。所以我们考虑把同色的球放在一起考虑，在两色交接的地方（此时 $k$ 会归零）继承一下之前的 dp 数据。**

----

这一部分来解决粗体字谈到的问题。  
$$
f(i-1,j,0)\gets \sum_k f(i-1,j,k)
$$
这里 $i-1$ 跟 $i$ 的颜色是不同的，所以现在我们从相对 $i-1$ 的颜色而言转变为相对 $i$ 的颜色而言，而不论之前的 $k$ 如何，我们现在（还没有放入任何 $i$ 的颜色的求时）的 $k$ 一定是 $0$。  
这里是在为马上到来的颜色段的 dp 做准备，还没有真正开始 dp。

---

现在我们可以正式开始这一颜色段的 dp 了。现在我们的 $i-1$ 的 dp 数组也是相对于我们的颜色而言了，所以可以无所顾忌地分类讨论转移了。

有能力的同学看完状态就知道怎么转移了。这里只提一下要点：
- 放了 $i-1$ 个球的时候，总共有 $i$ 个夹缝。
- 有 $j$ 个夹缝是两侧颜色相等的。
- 如果记 $x$ 为考虑到 $i-1$ 时有多少个当前颜色的球，那么有 $2x-k'$ 对当前颜色的冲突。$k'$ 是 $i-1$ 的 dp 数组的第三维。
- 所有夹缝只有 $3$ 类：被 $k$ 算的、两侧相同且不是当前颜色的、两侧不同且都不是当前颜色的。

1° 产生冲突  
$$
f(i,j,k)\gets f(i-1,j-1,k-1)\cdot (k-1)
$$
2° 化解冲突
$$
f(i,j,k)\gets f(i-1,j+1,k-2)\cdot (j-2x+k-1)
$$
3° 无关
$$
f(i,j,k)\gets f(i-1,j,k-2)\cdot (i-j+2x-2k+4)
$$

![](https://cdn.luogu.com.cn/upload/image_hosting/4x26d7pl.png)

---

现在我们可以开始写代码了。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=305,mod=1e9+7;
inline void add(int &x,int y){(x+=y)>=mod&&(x-=mod);}
int n,a[N],f[N][N][N];
int main(){
	ios::sync_with_stdio(0);
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
		for(int j=sqrt(a[i])+0.1;j>1;j--)if(a[i]%(j*j)==0){a[i]/=j*j;break;}
	}
	sort(a+1,a+n+1);
	f[0][0][0]=1;
	for(int i=1,x=0;i<=n;i++){
		if(i>1&&a[i]!=a[i-1]){
			for(int j=0;j<=n;j++)for(int k=1;k<=n;k++)
				add(f[i-1][j][0],f[i-1][j][k]),f[i-1][j][k]=0;
			x=0;
		}
		for(int j=0;j<=n;j++)
			for(int k=1;k<=n;k++){
				if(j)add(f[i][j][k],f[i-1][j-1][k-1]*(k-1ll)%mod);
				if(k>=2){
					if(j-2*x+k-1>=0)add(f[i][j][k],f[i-1][j+1][k-2]*(j-2*x+k-1ll)%mod);
					if(i-j+2*x-2*k+4>=0)add(f[i][j][k],f[i-1][j][k-2]*(i-j+2*x-2*k+4ll)%mod);
				}
			}
		x++;
	}
	int ans=0;
	for(int k=0;k<=n;k++)add(ans,f[n][0][k]);
	cout<<ans;
}
```

----

现在我们可以提交了。  
通过了。