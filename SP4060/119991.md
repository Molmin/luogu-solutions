### [推荐点这里观看](https://www.cnblogs.com/linzhuohang/p/13387745.html)


# 题目
Alice和Bob在玩一个游戏。有n个石子在这里，Alice和Bob轮流投掷硬币，如果正面朝上，则从n个石子中取出一个石子，否则不做任何事。取到最后一颗石子的人胜利。Alice在投掷硬币时有p的概率投掷出他想投的一面，同样，Bob有q的概率投掷出他相投的一面。

现在Alice先手投掷硬币，假设他们都想赢得游戏，问你Alice胜利的概率为多少。

# 题解
玄学概率dp

虽然网上已有不少题解，但有很多关键的地方没讲到，本题解加入了很多我自己的对一些问题的一些解答，更完整，详细，严谨，觉得没有完全懂，还有疑惑的可以来参考一下

## 设计状态

**$dp[i][0/1]$表示当前状态为【在投硬币前还剩i个石头，且现在是Alice/Bob投硬币】投完硬币之后的胜率**

初始状态为$dp[0][1]=1$,即当前没有石头，且是bob投硬币（即Alice是最后一个取石子的人，即赢家），此时胜率为1（已经赢了）

然后我们就从这里一直倒推到$dp[n][0]$,即答案

## 转移方程

题目有这样一句话

Alice在投掷硬币时有p的概率投掷出他想投的一面，同样，Bob有q的概率投掷出他相投的一面

所以我们要分类讨论当前玩家会希望取走石头，还是维持原样（至于最后选哪个，我们待会再讲）

另请注意，玩家并不知道自己的p和q，所以不会出现Alice为了有更大的概率得到想要的结果而故意想相反的结果之类的问题

#### 1.当前局面下，取走更好

$dp[i][0]=p*dp[i-1][1]+(1-p)*dp[i][1] $

$dp[i][1]=q*dp[i-1][0]+(1-q)*dp[i][0]$

以$dp[i][0]$的计算为例，前半部分是第一步Alice拿了，然后局面就变成了有$i-1$个石头并且是后手，所以乘的是$dp[i-1][1]$

后半部分就是第一步Alice没有拿，那就变成了有$i$个石头并且是后手，所以是乘上$dp[i][1]$

但是这个转移方程有交叉引用，但不用担心，可以按如下方法处理（以dp[i][0]为例）

带入$dp[i][1]$

$dp[i][0]=p*dp[i-1][1]+(1-p)*(q*dp[i-1][0]+(1-q)*dp[i][0]) $


拆括号，并将$(1-q)*dp[i][0]$移到左边

$dp[i][0]-(1-p)*(1-q)*dp[i][0]=p*dp[i-1][1]+(1-p)*q*dp[i-1][0]$

将系数除过去

$dp[i][0]=(p*dp[i-1][1]+(1-p)*q*dp[i-1][0])/(1-(1-p)*(1-q))$

dp[i][1]同理

$dp[i][1]=(dp[i-1][0]*q+dp[i-1][1]*(1-q)*p)/(1-(1-p)*(1-q))$

#### 2.当前局面下，不取更好

$dp[i][0]=(dp[i-1][1]*(1-p)+dp[i-1][0]*p)*(1-q))/(1-p*q)$

$dp[i][1]=(dp[i-1][0]*(1-q)+dp[i-1][1]*q)*(1-p))/(1-p*q)$

#### 3.如何选择
在当前剩下i个石头的情况下，要到i-1颗石头的状态，无非就是Alice取了，或是Bob取了

若Alice取了，那么接下来的胜率就是$dp[i-1][1]$,否则就是$dp[i-1][0]$

也就是说，我们只要比较这两个胜率的大小，就可以决定Alice希望选哪个（这里指的是希望选哪个）

那bob呢？

注意到若Bob取了，那么接下来的胜率就是$dp[i-1][0]$,否则就是$dp[i-1][1]$

若alice 决定取，则$dp[i-1][1]>dp[i-1][0]$,那么Bob肯定不取

也就是说，Alice和Bob的决策是相反的，那么我们只要关注Alice选哪个即可

观察1和2的公式，变化就是p和(1-p);q和(1-q)的位置互换了

我们可以用下面的代码来完成这个过程
```cpp
double p1=p,q1=q;
if(dp[now][1]<dp[now][0]) p1=1-p,q1=1-q;
```
另外，通过打表可以发现，n到1000之后dp值基本没有变过，即，我们只要算到1000就可以停了。

# 代码
我是用滚动数组来实现的（虽然没有必要）

代码很短

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
double dp[2][2];
int main()
{
	int t;
	cin>>t;
	while(t--)
	{
		int n,now=0;
		double p,q;
		cin>>n>>p>>q;
		dp[0][1]=1,dp[0][0]=0;
		n=min(n,1000);
		for(int i=1;i<=n;i++,now^=1)
		{
			double p1=p,q1=q;
			if(dp[now][1]<dp[now][0]) p1=1-p,q1=1-q;
			dp[now^1][0]=(dp[now][1]*p1+dp[now][0]*(1-p1)*q1)/(1-(1-p1)*(1-q1));
			dp[now^1][1]=(dp[now][0]*q1+dp[now][1]*(1-q1)*p1)/(1-(1-p1)*(1-q1));
			//cout<<dp[now][0]<<" "<<dp[now][1]<<endl;
		}
		printf("%.6f\n",dp[now][0]);
	}
}
```
