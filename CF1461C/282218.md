### 题意：

​	先给你一个$[1,n]$的排列，然后再给你$m$次操作，每次操作有两个参数$r_i$和$p_i$，代表着这次操作有$p_i$的概率将**前**$r_i$个元素按顺序排列，求$m$次操作后排列按升序排列的概率。

### 思路：

​	我们考虑如下一个排列：$[4,3,2,1]$，如果**单纯地**对其前$1/2/3$项排序的话是**没有任何意义的**（因为元素"$4$”永远无法到达最后一个位置），所以说我们必须**从后往前找到第一个不在它顺序位置上的元素的位置**（比如$[4,2,1,3,5]$，我们从后往前看，5在第五个，没问题；3在第四个，但第四个位置对应的元素是4，无法匹配；所以说我们的排序位置从**第四个及以后**便开始有意义了）。题目要求是求**按升序排序**的概率，也就是$1-$不按升序排序的概率，而不按升序排律的概率就是对($1-$**有意义的排序的概率**)进行累乘（代表着每次都没有进行排序）。特别的，如果给出的排列本来就有序，就可以直接输出$1.000000$。

### 代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
const int inf=1e9+7;
const int maxn=1e5+100;
int a[maxn];
 
int main(){
    int t;
    cin>>t;
    while(t--){
        memset(a,0,sizeof(a));
        int n,m;
        cin>>n>>m;
        for(int i=1;i<=n;i++){
            cin>>a[i];
        }
        int last=n+1;
        for(int i=n;i>0;i--){
            if(a[i]==i){last=i;}					//找到“有意义的排列”的最前端
            else break;
        }
        double ans=1;
        for(int i=0;i<m;i++){
            int r;double p;
            cin>>r>>p;
            if(r>=last-1){
                ans*=(1-p);							//累乘
            }
        }
        if(last==1){printf("1.000000\n");}			//特判
        else{printf("%.6lf\n",1-ans);}
    }
```