本题解中的所有```^```为**异或**,不为幂次方。

算法:**轮廓线dp。**
## 前置算法

请按顺序学习以下算法。

0.多维数组。

1.递推。

2.动态规划。

3.位运算,状态压缩。

4.轮廓线。
## 位运算
补充本题状态转移涉及到的位运算。

将 $S$ 的第 $j$ 位(从右往左)取反的结果:$S$^$(1<<j-1)$。

判断 $S$ 的第 $j$ 位(从右往左)是否为 $1$:$S$&$(1<<j-1)$。

求$2^{i}$:$1<<i$。

($A$ 为一个条件)当 $A$ 为真时,结果为 $b$,否则结果为 $0$:$A\times b$
## 思路
设 $f[i][j][S]$ 表示选到第 $i$ 个数第 $j$ 位,轮廓线上的状态为 $S$ 的方案数。

若上一个数的状态为 $0$,则此位可以为**‎ $0$ 或 $1$**。

若上一个数的状态为 $1$,则此位**必须**为**‎ $0$‎**。

所以得出结论:**如果异于此位一定可行,而等于此位需 $0$**。

初始状态:将第$-1$行全部**看作 $0$‎** 即可。

统计答案:枚举最后一行最后一个数为 $0,1$,然后枚举状态。

状态转移,初始状态,统计答案的式子见代码。

单组数据的时间复杂度为:$O(n\times m\times2^{m})$。虽然时间被其它算法吊打,但还是能过。
```cpp
#include<iostream>
using namespace std;
long long f[53][17][50005],c[1005];
#define mod 1000000000
void Main(){
	int n,m,i,j,k,ykb;
	long long sum=0;
	cin>>n>>m;
	ykb=1<<m;
	for(i=0;i<n;i++){
		scanf("%lld",c+i);
	}
	for(i=0;i<m;i++){
		for(j=0;j<(1<<i);j++){ //初始化:i位前可以位任意数,而i位之后必须位0。
			f[0][i][j]=1;
		}
	}
	for(i=1;i<n;i++){ //dp过程。状态转移。
		for(j=0;j<ykb;j++){
			f[i][0][j]=(bool)(j%c[i-1])*(f[i-1][m-1][j^(1<<m-1)]+f[i-1][m-1][j]*!(j&(1<<m-1)))%mod;
		}
		for(j=1;j<m;j++){
			for(k=0;k<ykb;k++){
				f[i][j][k]=(f[i][j-1][k^(1<<j-1)]+!(k&(1<<j-1))*f[i][j-1][k])%mod;
			}
		}
	}
	for(i=0;i<ykb;i++){ //统计答案。
		sum=(sum+(f[n-1][m-1][i^(1<<m-1)]+f[n-1][m-1][i]*!(i&(1<<m-1)))*(bool)(i%c[n-1]))%mod;
	}
	cout<<sum<<endl;
}
int main(){
	int t,i;
	cin>>t;
	for(i=0;i<t;i++){
		Main(); 
	}
	return 0;
}
```
Happy new year!