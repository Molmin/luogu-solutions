# 题目思路：

首先，我们要了解一个很基础的算法：dfs，它对于这题很合适，但是因为 dfs 的时间复杂度一般不会太低，所以我们需要加上一些优化。

先写出 TLE 即 $20$ 分 dfs：

```cpp
int dfs(int n){
	if(n==0) return 0;
	int mn=-1;
	for(int i=n;i>=1;i--){
		int x=(h[n]-h[i])*b+2*a+dfs(i-1);
		if(mn==-1||mn>x)
			mn=x;
	}
	return mn;
}
```
然后，我们就需要一些优化了。

先举个例子：`dfs(10)`，计算它需要调用 $9+8+7+6+5+……+1$ 次 `dfs(1)`。

`dfs(1)`被调用的次数非常可观，所以，我们要加上一个优化，那就是记忆化搜索。

什么是记忆化搜索呢？顾名思义，就是把每一次搜索的结果存下来，第二次使用的时候就不用再次调用了。

我们定义一个计数器 $f$，$f_i$ 表示 `dfs(i)` 的结果，如果 dfs 的传参的 $i$ 已经被计算过了，就直接返回 $f_i$ 的值，否则就正常计算，把这个结果存下来。

代码：太丑，不放了。