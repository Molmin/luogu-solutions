    
    
    
    
        
    
    
    

 
```cpp
#include <stdio.h>
#include <string.h>
int i=1;
char ch[100005];
int work()
{
    int len=0,t;
    while(1)
    { i++;
    if(ch[i]==')') {return len;}//右括号必须写在前面
    if(ch[i]=='a') len++;
    if(ch[i]=='(') len+=work();
    if(ch[i]=='|') {t=work();return (len>t)?len:t;}    //这个地方必须加return 
     }
    }
int main()
{
    scanf("%s",ch+1);
    int len,num,sum=0,max=0;
    len=strlen(ch+1);
    while(i<=len)
    {
        if(ch[i]=='a') sum++,i++;
        else if(ch[i]=='(') {num=work();sum=sum+num;}
                else if(ch[i]=='|') if(sum>max) max=sum,sum=0,i++;
                                       else sum=0,i++;
                        else if(ch[i]==')') i++;
        }
         printf("%d",(sum>max)?sum:max);
    return 0;
    }
```
主思路：
先考虑没有括号的情况：aaa|aaaa，这个比较简单，设计一个len和max，len是当前状态的长度，max是碰到|符号后，存放最大值长度。
其次考虑有括号的情况：

（aa）    有括号

（aa（aa））括号中有括号  （aa（aa）a）

（aa|a）括号有分隔符号

（aa（aa|a）a）括号中有括号也有分隔符号

那么可以想简单点，例如有这样一组数据：

aaaaaa(.................................)|aaaaaa(............)我们可以算出这个括号里的长度，直接参与计算，括号里怎么计算我再想办法。前一个括号里算出来长度是6那么分隔符左边的长度就是12，后一个括号里的算出来长度是2，那么分隔符右边的长度就是8，那么比较下，总长度就是12。

下面讨论下有趣的括号：

我的第一次解法是利用栈的原理来写的，先进后出，work函数里的bir数组是临时数组，当栈来用，遇到a进栈直到碰到')'，开始退栈，退栈时计算a的个数并比较大小，找出最大的长度，直到top指向栈底，也是我程序的if(j==1) return max; j值就是top，当top指向栈底的时候表面栈里所有的元素都是空，这个时候返回栈里最大长度max。arr数组是记录过滤掉括号后的数组，这个数组就是我们前面讨论的（aaa|aaaa，这个比较简单）情况了，这个就比较好处理了。

但是放到落谷里测试就过了2个测试点，我的天好郁闷！发现超时的现象过多，还有2个测试点是错误。思路这个时候要转变了，说明不能开这么大的数组来做这个题目（范围是10个6次方）。不能开数组意味着只能不断的计算这个长度，max不断在被更替。

那么在括号里的算法就也要改进。首先考虑最简单的情况，a（aa（aa）），i是字符数组的下标，这个字符的长度是9。i=1时，字符是a，我只要记录长度，i=2时是个括号，那么我要计算这个括号的长度，就调用函数work（work的含义就是计算括号内长度的函数），在函数work里i=3时，字符是a，在函数内记录长度，i=4是，字符是a，照旧。关键来了，i=5是，字符是'('，这个时候我们又要计算"这个"括号的长度了，是不是又要使用work()这个函数了，这就实现了递归。把上述的意思翻译成代码，应该这样写：

    if(ch[i]=='a') len++;

    if(ch[i]=='(') len+=work();

下面我们接着处理，程序现在在执行红色这个work()，就是我们测试数据a（aa（aa））红色部分，这个时候i=6，len++，i=7，len++   len=2；i=8问题又来了，是')'字符，怎么处理？按照我们的本意理解，这组红色的括号计算完了，要退出，所以代码是这样的：

if(ch[i]==')') {return len;}// 右括号必须写在前面

因为没有'|'字符，所以我们的测试数据可以测试了，出来的结果是正确的。



右括号写前面的道理：

 

(aa(aa)a)

下面我们要在测试数据中加入'|'字符，a（aa|a），我们先不做复杂的，先搞好最简单的。

'|'字符的意思就是比较红色的a和蓝色的a的长度，红色部分a的长度显而易见在变量len中，那么蓝色部分的a在哪里呢？怎么来解决这个问题，我们能不能写一个函数来专门计算蓝色部分a的长度，这个函数的写法如下：

```cpp
     int solve()   
     {  
       int  len=0
       if(ch[i]=='a') len++;
       if(ch[i]==')') {return len;}
           }
```
这个时候发现这个solve函数和谁长的一样，和work函数一样啊。那么蓝色部分的长度就是再一次调用work()函数，work的返回值就是蓝色部分的长度。比较红色和蓝色的长度，较大的给len，具体的写法如下：
if(ch[i]=='|') {t=work();return (len>t)?len:t;}    //这个地方必须加return

（aa|a）整个括号里的长度算出来要返回给我们，所以这个地方要加个return。

如果这里不加return，我们调试程序的时候会发现，i的值会一直往右跑，超出这个字符数组的范围。

所以整个递归的写法如下：

```cpp
    int work()
{    int len=0,t;
    while(1)
    { i++;
    if(ch[i]==')') {return len;}//右括号必须写在前面
    if(ch[i]=='a') len++;
    if(ch[i]=='(') len+=work();
    if(ch[i]=='|') {t=work();return (len>t)?len:t;}    //这个地方必须加return 
         }
    }

```