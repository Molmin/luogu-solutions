## 前言

前几天看的 ducati 大佬的题解不知道为什么突然没掉了。本着人人为我，我为人人（让其他人更好的 he 题），特意写篇题解。

## 题解
首先注意到题目中不能取的长度的权值为 $-1$，为了方便考虑，我们把“不能取”这个条件转化为"取了一定最劣"，即把权值赋为 $- \inf$。

对于这种带区间删除的题目，一般用区间 dp 来考虑。套路的，我们设 $f[l][r]$ 表示区间 $[l,r]$ 内操作的最大贡献。

对于转移，我们考虑这个区间取的最后一个回文串。注意两个字符必须满足他们之间的字符全部被删掉才能选入同一个回文串中。即我们选出的回文串满足以下性质：取回文串中序号最小 $mn$ 和最大的位置 $mx$，满足删掉这个回文串后，区间 $[mn,mx]$ 内的字符全部被删除。

这启示我们再考虑设两个数组辅助转移： $h[l][r]$ 表示删掉区间 $[l,r]$ 的最大贡献，$g[i][j][k]$ 表示在区间 $[l,r]$ 中，已经选出了长度为 $k$ 的回文串，回文串的两端在 $i,j$ 的最大贡献。

注意 $g[i][j][k]$ 的转移大体过程：

* 对于一个回文串，从两边向中间转移。

由于起始条件与枚举的区间 $[l,r]$ 有关，注意到光是每次计算 $f$ 时都须清空 $g$ 数组，复杂度就至少为 $O(n^5)$。

既然如此，那么考虑反其道而行之：对于一个回文串，我们从中间向两边转移。微调一下 $g$ 数组的定义：$g[l][r][k]$ 表示在区间 $[l,r]$ 中，选出长度为 $k$ 的回文串，满足回文串的两个端点在 $l,r$ 的最大贡献。

考虑转移，枚举下面两个相同的字符：

* $g[l][r][k]= \max_{i<j,i,j \in (l,r)}(g[i][j][k]+h[l][i-1]+h[j+1][r])$

但是这个转移是 $n^5$ 的，原因在于一次性同时枚举了两个字符。一个比较 naive 的优化想法是记录当前回文串的未匹配字符在 $l/r$ 上，然后枚举另一个匹配字符。

这里给出一个更简单的方法：观察到我们求的是最大贡献，因此若枚举到的不合法状态的贡献小于等于最大贡献，转移依然是正确的。

我们注意到 $h[l][r]\ge \max_{i\in (l,r]}(h[l][i]+h[i+1][r])$。即对于回文串的相邻两个字符（位置设为 $i,j$），我们把 $h[i][j]$ 拆成 $h[i][k]+h[k+1][j]$ 。因此我们考虑新的状态中可以在原来的回文串的基础上往外删除一些字符。

我们设 $g[l][r][k]$ 表示在区间 $[l,r]$ 中，选出长度为 $k$ 的回文串，满足在 $[l,r]$ 内，除了回文串以外的其他字符都被删除的最大贡献。

那么有：

* $g[l][r][k]=[s[l]=s[r]]\times g[l+1][r-1][k-2]$
* $g[l][r][k]=\max_{i\in [l,r)}(g[l][i][k]+g[i+1][r][0],g[l][i][0]+g[i+1][r][k])$

* $g[l][r][0]=\max_{k>0}(g[l][r][k]+a[k])$

注意到在计算回文串的相邻两个字符的区间贡献时，上面的转移体现为：对于这个区间，枚举划分方案的最大贡献。这与 $h[l][r]$($g[l][r][0]$) 的转移等价，因此是对的。

最后注意到答案是若干个被删除的区间的组合，因此 $f$ 的计算可以搬到最后来进行。且只用计算 $f[1][n]$ 即可。

## 代码

* 实现的时候用 $f$ 表示上文中的 $g$ 数组。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=155,inf=0x3f3f3f3f;
int n,ans;
int a[N];
char s[N];
int f[N][N][N],dp[N];
signed main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
        scanf("%d",&a[i]),a[i]=a[i]<0?-inf:a[i];
    memset(f,0xcf,sizeof(f));
    scanf("%s",s+1);
    for(int len=1;len<=n;len++)
        for(int l=1,r=l+len-1;r<=n;l++,r++)
        {
            if(len==1)
            {
                f[l][r][0]=a[1];f[l][r][1]=0;
                f[l+1][l][0]=0;
                continue;
            }
            if(s[l]==s[r])
                for(int k=2;k<=len;k++)
                    f[l][r][k]=max(f[l][r][k],f[l+1][r-1][k-2]);
            for(int k=0;k<=len;k++)
                for(int i=l;i<r;i++)
                    f[l][r][k]=max({f[l][r][k],f[l][i][k]+f[i+1][r][0],f[l][i][0]+f[i+1][r][k]});
            for(int k=1;k<=len;k++)
                f[l][r][0]=max(f[l][r][0],f[l][r][k]+a[k]);
        }
    for(int i=1;i<=n;i++)
    {
        dp[i]=max(dp[i],dp[i-1]);
        for(int j=0;j<i;j++)
            dp[i]=max(dp[i],dp[j]+f[j+1][i][0]);
    }
    printf("%d\n",dp[n]);
    return 0;
}
```