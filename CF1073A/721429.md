# 前言

看了其他大佬的代码，只能用复杂来形容了，小蒟蒻却有一个还算清晰简单的思路，代码也比较易懂，下面就来给大佬们献丑。

# 题目概括

一个长度为 $n$ 的字符串，找出任意一段连续的序列，需满足以下条件：

- 子序列中的任何字母出现次数严格小于子序列长度的一半。

- 子序列是原字符串中连续的一部分。

如果能找到，输出两行，第一行为 $\verb!YES!$，第二行为这个子串。 

否则输出 $\verb!NO!$。

# 思路

首先不要被样例迷惑了！！！

我们不用样例的想法看，题目既然说任意一段，那我们可以找的越短越好，因为子串越短，就越容易判断是否满足条件，那么长度定在几比较容易判断呢？我们可以挨个试一试。

## 长度为1

例如字符串为 $\verb!abcdef!$，我们只能选择单个字符，例如 $a$、$b$等。

### 如果子串为 $a$

长度为 $1$ ，字母出现次数也为 $1$，显然不符合第一个要求，所以长度为1的子串，我们可以舍去。

## 长度为2

例如字符串为 $\verb!aabbccddee!$，这次可以选择 $\verb!aa!$、$\verb!ab!$、$\verb!bb!$ 等子串，选择的数量大大增加，我们可以挨个判断一下是否满足条件。

### 如果子串为 $\verb!aa!$

长度为 $2$，字母 $a$ 出现的次数也为 $2$，显然不符合第一个条件。

### 如果子串为 $\verb!ab!$

长度为 $2$，字母 $a$ 和字母 $b$ 出现次数都为 $1$，两个条件都满足，所以我们可以得出以下结论：

- 子串长度为 $2$。

- 两个字符互不相同

找出满足上述规则的两个连续字符，即可完成输出。

# 代码


```cpp
#include <bits/stdc++.h>
using namespace std;
int main()
{
	//定义变量
	 
	int n,i;
	char s[1001];
	
	//输入 
	scanf("%d %s",&n,s);
	
	//处理
	 
	for (i=1;i<n;i++)//循环变量 i 从 1 开始遍历，因为如果从 0 开始，第17行的代码 s[i-1] 就会超出边界，从而 WA
	{				//于是可以从 1 开始遍历，不用担心会超出边界。
		if (s[i] != s[i-1])//判断两个字符是否不同且相邻 
		{
			printf("YES\n");//满足条件，输出 YES 
			printf("%c%c\n",s[i-1], s[i]);//以及这两个字符，注意顺序 
			return 0;//找到满足条件的子串，程序就可以结束 
		}
	}
	printf("NO\n");//否则输出 NO 
	return 0;
}
```
