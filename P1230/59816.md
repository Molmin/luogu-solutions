## pair做法  

---
看了题解，貌似没有用pair做的（~~pair方便快捷~~），我就顺手发一篇……  
~~这是本蒟蒻第一次发题解，可能有些毒瘤，请见谅~~   

---
我们先审题，题目说***想要赢取更多的钱***，很显然，这是一道典型的**贪心**题目……  

首先，我们要知道贪心的**对象**和**方向**，在本题中，贪心的对象就是**扣款数**，我们要让它**尽可能地小**……

然后，我们还要知道贪心的**限度**，在本题中就是**时间**，我们不能超出时间来贪心……  

所以，我们要把**扣款数大的放在前面完成**，也就是说，尽可能在有限的时间内，完成扣款多的任务……  

接着，我们考虑完不成的任务，如果有一个不可能在有限时间内完成的任务，**就把它放到最大的空时间段**……简单地说，就是，反正也完不成，就不要浪费做别的任务的时间  

---
~~理解了这些，代码实现就不是问题~~  
以下是本蒟蒻的ac代码  

---
```cpp
#include<bits/stdc++.h>  
using namespace std;  
const int M=6e6+6;  
int m,n;  
int WA=0;//记录扣款数  
bool bol[M];//标记时间是否被用过  
bool k=false;//记录是否需要罚款  
pair<int,int> a[M];//开一个pair数组  
int main(){  
	cin>>m>>n;  
	for(int i=1;i<=n;i++){  
		cin>>a[i].second;//规定完成的期限  
	}  
	for(int i=1;i<=n;i++){  
		cin>>a[i].first;//扣款数（放在first便于排序） 
	}  
	sort(a+1,a+n+1);//sort自动对 a[i].first 排序
	//sort从小到大排序 我们要把扣款数大的放在前面 所以倒着来  
	for(int i=n;i>=1;i--){  
    	k=true;//假设需要罚款  
    	for(int j=a[i].second;j>=1;j--){  
            if(!bol[j]){//如果时间没被用过  
                k=false;//不需要罚款  
                bol[j]=true;//标记这一时间被使用过  
                break;//结束循环  
            }  
        }  
        if(k){//如果需要扣款（上面的循环不成立）  
            for(int g=n;g>=1;g--){  
			//把罚款最多的一个任务（完成期限是g）放在小于等于g的最靠后的时间段  
                if(bol[g]==false){  
                    bol[g]=true;  
                    break;  
                }  
            }  
            WA+=a[i].first;//累加扣款  
        }  
    }  
    cout<<m-WA;  
	return 0;  
}  

```