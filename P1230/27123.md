看大神们都用了排序，我就贴一个非排序用二维数组来做的题解。

先讲思路：

10000
7
4 2 4 3 1 4 6

70 60 50 40 30 20 10

我们可以转换一下：

时间    做的事

1:        70 60 50 40 30 20 10

2:        70 60 50 40 20 10

3:        70 50 40 20 10

4:        70 50 20 10

5:        10

6:        10

7:
第一个时间段：

1:        70 60 50 30 20 10

2:        70 60 50 20 10

3:        70 50 20 10

4:        70 50 20 10

5:        10

6:        10

7:
第二个时间段：

1:        70 50 30 20 10

2:        70 50 20 10

3:        70 50 20 10

4:        70 50 20 10

5:        10

6:        10

7:
第三个时间段：

1:        70 30 20 10

2:        70 20 10

3:        70 20 10

4:        70 20 10

5:        10

6:        10

7:
第四个时间段：

1:        30 20 10

2:        20 10

3:        20 10

4:        20 10

5:        10

6:        10

7:
第五个时间段：

1:        30 20

2:        20

3:        20

4:        20

5:
6:
7:
后面都不可以做任何事了，虽然图上还剩4个20和1个30，但是20是可以在1到4的时间段才能做的，30是在1的时间段才能做的，所以就只有1个30和1个20，那么10000减去30减去20就可以得出9950了。

但是从正面的角度上是没有规律的，但是我们可以到过来看一看，就可以发现了每个时间段可以做当时可以做的分值最大的小游戏，然后就知道最后剩下的就是不能做的了。

附源程序：

```cpp
var n,m,i,max,j,k:longint;
    s:array[-100..1000,-100..1000] of longint;   //定义一个二维数组。
    x,z,w:array[-100..100000] of longint;
begin
  readln(n);
  readln(m);
  for i:=1 to m do
    read(x[i]);
  for i:=1 to m do    //读入。
    read(z[i]);
  for i:=1 to m do
  begin
    for j:=1 to x[i] do
    begin
      inc(w[j]);
      s[j,w[j]]:=z[i];    //存在那个时间段。
    end;
  end;
  for i:=m downto 1 do
  begin
    max:=0;
    for j:=1 to w[i] do
      if(max<s[i,j]) then  max:=s[i,j];  //判断是不是分值最大的小游戏。
    if(max>0) then
    begin
      for j:=1 to m do
        if(z[j]=max) then  begin z[j]:=0; break; end;    //找出来并可以完成。
      for j:=1 to i do
        for k:=1 to w[j] do
          if(s[j,k]=max) then begin s[j,k]:=-1; break; end;   //模拟。
    end;
  end;
  for i:=1 to m do
    if(z[i]>0) then n:=n-z[i];    //如果没有标记的话就是做不了的，所以就可以减掉他。
  write(n);  //输出。
end.
这一题就是考我们模拟。（对我来说是主要的）
```