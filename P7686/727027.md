

------------------
### [原题链接](https://www.luogu.com.cn/problem/P7686)


## ~~一道十分考验人类阅读能力的题。~~


------------


## 题目大意

第一部分：求出有多少种数字；

第二部分：求出每一种数字最后一次出现的地方（顺序）。

- 对于第一部分，可以使用桶排，将每一种数字存储下来。

- 对于第二部分，使用倒序枚举，若这个数没有出现过，就存进数组中；若已经出现过，就跳过。

## 算法实现

首先用一个数组 $b$ 存储数字，并且对于每一种数字都用计数器 $ans$ 记录下来；

其次，再用数组 $l$ 存储每一种数字最后一次出现的顺序，再用数组 $b$ 标记下来。

## 注意：$b$ 数组要清零，~~别问我怎么知道的。~~



------------


### 下面附上代码

```cpp
#include <bits/stdc++.h>

using namespace std;

const int N = 1e6 + 10;

int c, n, a[N], b[N], ans, l[N], cnt;//cnt控制下标

int main() {
    ios::sync_with_stdio(0);
    cin.tie(0); cout.tie(0);//读入优化
    cin >> c >> n;
    for(int i = 1; i <= n; ++ i) {
        cin >> a[i];
        b[a[i]] ++;//数字加1
    }
    for(int i = 1; i <= 1000000; ++ i) {//循环枚举
        if(b[i] != 0) ans++;//若在里面存了数，则数的种类加1
    }
    cout << ans << "\n";
    memset(b, 0, sizeof b);//清零
    for(int i = n; i >= 1; -- i) {//倒序枚举
        if(!b[a[i]]) {//若此时里面未存储数，就说明这是第一个出现的数
            l[++cnt] = a[i];//存储进去
            b[a[i]] = 1;//标记一下
        }
        else {//若已经有了
            continue;//就返回
        }
    }
    for(int i = cnt; i >= 1; -- i) {//倒序输出
        cout << l[i] << " ";
    }
    return 0;
}
```
