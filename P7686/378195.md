可能是空间最小的题解，只开了一个大小为 $10^6$ 的 `bool` 数组，最终占用空间为 $4.1$ MB，因为后来用到了栈导致空间依没那么小。
# 题意
这题最难的是读题，这题题面真是比较阴间。翻译成人类的语言是这样的。

给你一个长度为 $n$ 的数组，你需要求出这个**数组里有多少个不同的数**，并且**按照每个数字最晚出现的位置的顺序输出每一个数**。

题目里还有个 $c$，代表着数组里只会出现 $1$ 到 $c$ 的数，不过对我们做题没用。

如果你还没看懂（~~那可能是我说的比较绕~~），那么结合样例看一下。

```
4 6
1 2 1 2 3 3

    1 2   3
    最最   最
    后后   后
    的的   的
    位位   位
    置置   置
```
首先肯定要先输出 $3$，因为这个数组里只出现了 $1,2,3$ 三个数。
接下来，我在下面标注了每个数最后出现的位置。从第一个数出现的最后位置（这里是 $1$），一直输出到最后一个（也就是 $3$）就行了。

# 实现
对于第一小问，用一个变量 `ans` 记录答案。读入的时候用一个布尔数组记录一下有没有出现，如果**读入了一个没有出现的数**的话，就标记一下，然后 `ans++`。

对于第二小问，首先每个数读入到一个栈。因为我选择从**后往前扫**，这样**扫到的第一个数就是这个数最后一次出现的位置**。用栈先入后出的特性正好合适。因为从后往前扫，所以要逆序输出。这样把每次扫到第一次出现的数存到一个栈，还是用先入后出的特性就可以输出了。

# 代码
说了那么多，代码其实很简单，觉得前面看不太懂得看注释就行了。
```cpp
#include <iostream>
#include <stack>// 栈
#include <cstring>// memset
using namespace std;
bool a[1000005];

int main(){
    int c,n,ans=0;
    cin >> c >> n;
    int k;
    stack<int> s;
    for (int i=0;i<n;i++){
        scanf("%d",&k);
        if (!a[k]) ans++; // 新的数，ans++
        s.push(k);
        a[k]=true;
    }
    cout<<ans<<endl;
    memset(a,false,sizeof(a)); // 节约空间，重置一下，用来记录接下来是不是第一次
    int countt=0;// 
    stack<int> s2;
    while (countt!=ans){ // 如果数全部扫完了
        if (!a[s.top()]) s2.push(s.top()),a[s.top()]=true,countt++; // 第一次出现就压进s2
        s.pop();
    }
    while (!s2.empty()) printf("%d ",s2.top()),s2.pop(); // 输出
}

```