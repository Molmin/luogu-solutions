本题是一道略有思维难度的新手好题，总体实现不难，但思想有些复杂。

我们来看题面：

>有一个长度为 `N` 的序列，其中的每个元素有 `C` 个关键字，我们将依次进行多次 __稳定__ 的单关键字排序，找到最短的一个等效排序方法。

我们来分析这样一个性质：

>当你进行了一次排序时，之前的一切相同排序都没有意义。

显而易见， __稳定__ 排序具有 __幂等性__ （即重复操作不影响结果，具体可以去看ST表相关知识），因此本性质是正确的。

那么这道题目的思路也就出来了：

>对于每一种排序，我们只保留最后一次。

本题解完。

---

附：最优解、最短解代码。

```cpp
#include<cstdio>
using namespace std;
int lst[1000006];
int num[3000006];
int main(){
    int c,n;
    scanf("%d%d",&c,&n);
    int ans=0;
    for(int i=1;i<=n;++i){
        scanf("%d",&num[i]);
        if(lst[num[i]]==0)++ans;
        lst[num[i]]=i;
    }
    printf("%d\n",ans);
    for(int i=1;i<=n;++i)if(lst[num[i]]==i)printf("%d ",num[i]);
    return 0;
}
```

`lst` 数组：这个值对应的最后一次出现位置。

`ans`：不同的值个数（显然，每个值保留一个，那么最短的操作长度就是不同类型排序的种类数），也就是最短操作长度。

思路：输入时判断是否第一次出现并处理 `ans`，输出时判断是不是最后一个并输出。

__完__
