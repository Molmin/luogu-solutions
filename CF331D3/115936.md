*3000 独立做出。

显然从一个点出发，肯定是一开始一直直线走，直到碰到一个箭头后面的路径就固定了。

考虑对每个箭头预处理它的路径。

首先是每个箭头走出去碰到的第一个其他的箭头。

一种暴力的想法是直接上主席树，然后每次二分一下去扫，复杂度 $O(n\log^2n)$ 。

还有一种想法是，比如处理 x 坐标从小到大的箭头，跑一遍扫描线，按照 x 坐标从大王小枚举，然后线段树维护每个 y 坐标上一个出现的箭头是哪个，复杂度 $O(n\log n)$ 。

因为我写了第二种都跑了 2.7s ，所以第一种理论上无法通过此题。

注意每个查询也要求第一个箭头的位置，离线下来一起扫描线即可。

那么就可以求出这个路径了，暴力的话就每次跳下一个箭头。

注意到 $t\le 10^{15}$ ，考虑优化。

这种暴力跳的东西通常可以考虑倍增。

一种想法是直接倍增每个箭头的末端走 $2^i$ 到的地方，但是这个东西不好转移因为会涉及到不在箭头的结点。

考虑预处理每个箭头末端往后走 $2^i$ 个箭头后，到哪个箭头，以及路程总长，然后暴力跳就好了。

总码长 8.28k ，可能是我写丑了。

https://codeforces.ml/contest/331/submission/157524171