### 首先分析题面

这道题的意思就是说，要找到每个人朋友的朋友的数量。

### 思路：

怎么做呢？其实只要记录下来每个人的朋友（单层关系，不深入），然后再找这些朋友他们对应的朋友就行了。

### 注意：

- 在计算的过程中，有可能会重复计算，所以要用$bool$数组去重；

- 如果$a$是$b$的朋友，$b$是$c$的朋友，而c有是$a$的朋友，那么a和c只是朋友，并不算朋友的朋友，所以我们还得用$bool$数组判断这种情况。

上代码：（代码中有详细注释）
```
#include <bits/stdc++.h>
using namespace std;
int a[11][101],b[11];//a[i][j]表示第i个人的第j个朋友是谁,b[i]表示第i个人有几个朋友; 
bool k[11];//k[i]记录第i个人是否已被算入朋友的朋友当中，或者是自己，或者是朋友（单层关系）; 
int find(int h)//寻找h的所有朋友(单层关系) 
{
  int num=0;
  for(int i=0; i<b[h]; i++)
  {
    if(!k[a[h][i]])
      num++,k[a[h][i]]=1;
  }
  return num;
}
int main()
{
  int n,m,x,y;
  cin>>n>>m;
  for(int i=0; i<m; i++)
  {
    cin>>x>>y;
    a[x][b[x]]=y;//这里赋值两次，是因为朋友关系是无向的，x是y的朋友，y也是x的朋友; 
    a[y][b[y]]=x;
    b[x]++;//朋友数++； 
    b[y]++;
  }
  int sum=0;
  for(int i=1; i<=n; i++)
  {
    k[i]=1;
    sum=0;
    for(int j=0; j<b[i]; j++)
    {
      k[a[i][j]]=1;//这里是为了处理提示中的第二点，所以要先把所有i的朋友标记，以防后面记入朋友的朋友当中； 
    }
    for(int j=0; j<b[i]; j++)
    {
      sum+=find(a[i][j]);//加上i的第j个朋友的所有朋友； 
    }
    cout<<sum<<endl;//输出 
    for(int i=1;i<=n;i++)
    k[i]=0;//清零 
  }
  return 0;
}

```
写题解不易，觉得好的，留个赞再走呗~