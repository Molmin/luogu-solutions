# 这是一个很用心的教学代码

因为我自己是先学了DFS和BFS 

对于这种用DP的思路并不理解. 

本次教学, 是一种统计的思路. 

## 从新手的角度去思考这个问题


先看一种输入 , 最大体积10 , 4个数据

```
10
4
5
4
4
8
```

输出如下

```
 第 0 体积 5
                现有组合: { 5 }
 第 1 体积 4
        组合 9 = 5 + 4
                现有组合: { 4 , 5 , 9 }
 第 2 体积 4
        重复 9
        组合 8 = 4 + 4
                现有组合: { 4 , 5 , 8 , 9 }
 第 3 体积 8
                现有组合: { 4 , 5 , 8 , 9 }
所有组合 :
        4 , 5 , 8 , 9
最小剩余:
                1

```

这个例子, 一共有4个数据
[0]=5
[1]=4
[2]=4
[3]=8

当我们选择区间  
[ 0 - 0 ] 的时候, 只有 5 一个数字,   
组合为 { 5 }

当区间增长为  
[ 0 - 1 ] 的时候, 有 5 和 4   
组合为 { 5, 4 , 9 } , 其中 9 是 5+4 得到的

当区间增长为   
[ 0 - 2 ] 的时候, 有 5 , 4 , 4  
组合为 { 5 , 4 , 4 , 9 , 8 , 13 } 其中 8 和 12 是新发现的

**13 = 5+4+4  或 5+8 , 由此可见, 集合里某个元素, 可能是多个方案构成的.  但我们不记录是什么方案, 只关心有没有这种情况.**



------------



### 那么问题来了 , 如何记录所有的组合 ?? 

所以我们设计一个bool数组 :  
bool varr[200001];

用来记录所有的组合 (然而大于V的组合无意义, 可以不记录了)

我们需要在每一次拿到箱子大小boxv的时候, 就要把所有组合统计出来. 

那么在下一次拿到新的boxv(新)的时候, 把上次的所有组合, 和当前boxv, 又做一次新的合并便可. 

所以 由 [ 0 - 1 ] 得到的是 { 5 , 4 , 9 } 这些都存到 varr[200001] 里了

到了 [2] 的时候, 我们干的事情是 : 

{5,4,9} 组合 4 =>  {5,4,9,5+4,4+4,9+4} => {5,4,9,9,8,13} => {5,4,9,8}

### 下面的代码详细地说明了这个过程


```cpp


#include <cmath>
#include <algorithm>
#include <iostream>
using namespace std;

//教学专用代码

int V, N, boxv;

//注意, 是bool类型, 我们只储存 是 或者 否
bool varr[20001];	//题目说最大20000, 所以留 [0,20000] , 其中0是用不到的, 大多数都用不到

void printarr()
{
	int outcount = 0;
	for (int exist_v = 1; exist_v <= V; exist_v++)
	{
		if (!varr[exist_v])	//没有这种组合
			continue;
		if (outcount++ != 0)
			cout << " , ";
		cout << exist_v;
	}
}

void program()
{

	cin >> V >> N;

	for (int __i = 0; __i < N; __i++)	//注意, 实际上这个 __i 后面是用不上的
	{

		int boxv;
		cin >> boxv;

#ifdef _DEBUG
		cout << " 第 " << __i << " 体积 " << boxv << endl;
#endif

		if (boxv > V)continue;//物品会比箱子大吗? 未确定, 先排除这个情况以免导致溢出.


		if (__i == 0)	//第一个箱子 , 为了做教学用途
		{
			//看看我们对第一个箱子做什么事情
			//注意, 数组索引使用的是 [boxv] , 
			//这表示, 经过这一个箱子, 我们发现了 1 种组合 , 所以我们要记下来 varr[boxv] 这种情况是存在的
			varr[boxv] = true;
		}
		else
		{
			//优化策略, 如果好运气, 刚好找到装满的组合, 那么就可以输出结果了
			//if(varr[V-boxv]){.....}

			//前面已经说过, 第一个箱子 varr[boxv] 已经放了进去了
			//如果是正在处理第二个箱子, 那么循环20000次, 也只有1种可能
			//如果处理第三个箱子, 循环20000次, 则有3种可能
			//如果处理第四个呢? 最大6种可能 也有可能重合, 所以可能数少一点. 
			//注意, 使用的是 V - boxv , 防止 varr 溢出.   如果 exist_v 从 V 开始, 那么 varr[exist_v+boxv] 就越界了
			for (int exist_v = V - boxv; exist_v > 0; exist_v--)	//没错, 如果V是20000, 则这里循环20000次
			{
				if (!varr[exist_v])	//这句话的意思, 是如果前面没有出现过这种组合, 那么就跳过. 大部分情况都会跳过的.
					continue;

				//现在命中了之前出现过的 1 次组合 (3次组合, <6次组合等等) 中的其中一项

				int new_v = exist_v + boxv;	//这个加起来, 就是找到了新的组合

				if (varr[new_v])	//纯粹教学用途
				{
					//教学专用 , 有一个小概率, 这个组合是以前增加过的了.  
					//例如连续3个箱子 , [0]=2 , [0]=2 , [0]=2 , 那么[0]和[1]已经组合成4 , 那么[0]和[2]组合就重复了, [1]和[2]也重复
#ifdef _DEBUG
					cout << "	重复 " << new_v << endl;
#endif
				}
				else
				{
					varr[new_v] = 1;	//这次找到了新的组合, 那么我们记录下来吧.
#ifdef _DEBUG
					cout << "	组合 " << new_v << " = " << exist_v << " + " << boxv << endl;
#endif
				}

			}

			//最后, 把当前箱子的可能标记上
			varr[boxv] = true;

		}


#ifdef _DEBUG
		//打印现有组合:
		cout << "		现有组合: { ";
		printarr();
		cout << " } " << endl;
#endif


	}

#ifdef _DEBUG
	//OK , 经过多次组合, 现在我们看看结果:
	cout << "所有组合 :\n	";
	printarr();
	cout << endl;
	cout << "最小剩余:\n		";
#endif

	//那么我们只需要找到这个组合的最大值便可
	//注意, 从大找到小, 然后停止.  不可能找不到的啦, 除非毒瘤数据N==0, 
	for (int exist_v = V; exist_v > 0; exist_v--)
	{
		if (varr[exist_v])
		{
			//注意, 找到的是占用空间的最大值
			//需要计算出剩余空间
			int restspace = V - exist_v;

			cout << restspace << endl;

			return;
		}
	}
}

int main()
{
	program();

	return 0;
}


```

