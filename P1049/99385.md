首先我们会发现这是一道很典型的dp题目。

# 但是我是不会用dp的！！！

我们先来看下这道题。对于每一个质量，我们用一个1或0来表示能否装到这个质量。

然后利用每一个箱子的质量，对于指定的i进行更新。

例如我有一个 a[i] = 1;  然后已知有一个箱子质量为 b， 那么我们便可以得到 a[i + b] = 1；

# 于是我们会发现，这不就是位运算里的左移吗。

现在我们将所有的a[i] 输出，构成一个01串。那么每一次的操作就是将这个01串左移b位以后和原来的数并下。

可能还是举个栗子比较好

    现在我们有一个长度为24的01串
    第一步
    b = 6
    000000……000100000
    在第6位上有一个1，说明我们可以取到质量为6的情况
    
    
    第二步
    b = 8
    00000……0010000000（1后面7个零）
    首先初始化这么一个值
    为什么呢，因为我们考虑到在用dp的时候有一个a[0] = 1
    相应的，我们要初始化这么一个值
    然后将第一步的值左移8位，得到
    00000……0010000000000000（1后面11个零）
    最后，将这三个值取个交集，就是我们第二步后得到的值
    
    第三步
    通过以上的地推，求出最终的01串，取出它最高位的1。
    关于怎么取……用lowbit就好了。
    虽然lowbit只能取最低位的一，但是我们只要不断lowbit，就会取出最高的一位1。
    
    第四步
    输出 v - k；
    k 为我们最终得到的结果
    
如果你实在看不懂，建议还是放弃这篇题解。

然后问题来了。

（由于本人懒得用<bitset>这个头文件，所以我写了份高精。）

  众所周知，二进制的位运算可以用来进行状态压缩，所以大家很喜欢用来运算。
  
  但是我们知道，加法还是减法抑或乘除，只能在限定范围内运算一旦超出就会爆零。
  
  那么同理，位运算也有自己的上限。
  
  经作者亲测
  
    int -> 支持8位，最大值是11111111
    long lnog -> 支持16位
    unsigned long long -> 支持32位
  
  然后我们就可以进行这么一个考虑，由于这是一个容量为20000的背包，所以就需要一个长度为两万的01串。
  
  但是由于我们的定义无法支持两万位，所以我们必须用数组来存储。
  
    第一种考虑，用一个bool型（int型也行）来表示一位数字。
    即a[i] = 0 (or) 1
    不过你会发现这样子和dp没啥两样。
  
    第二种考虑，用一个unsigned long long 来存储32位01字串
    这样子我们就要考虑用多少个来存储了。

  
因为体积为v，所以考虑最大要用的数组量为 v / 32 + 1;
  
  不过问题又来了， 当v为32的倍数的时候。我们会发现似乎多算了一个数组量。
  
  
  ![](https://cdn.luogu.com.cn/upload/pic/56601.png)
  
  那个，上面的图打错了，能取到的是23.
  
  
  
  这个问题要怎么解决呢，其实很简单，既然32这个YYJH想去第二个数组量，我们就不要特判它的位置了，给它就是了。
  
  32出去了，还少一个空格，给谁顶上呢？自然是零。
  
  于是就成了这样
  
  ![](https://cdn.luogu.com.cn/upload/pic/56602.png)
  
  这样子还有很多好处，这里不细谈，留给大家自行推理。
  
  但是，我后来经过一系列的深思熟虑，决定改用int型，即一个数存储8位。
  
  因为我发现位运算（就是指 &、 |  这些）不支持32位……哭。。。
  
  定义代码（每一个01串用 槽 来简称）
 
    cin>>v>>n;
	for(int i = 1;i <= n;i++) cin>>a[i];
	sum = v / 8 + 1;//表示占用的槽的数量
	did = (1 << (v % 8 + 1)) - 1;//最后一个占用的槽所要的位数 
  
    //计算可确认 v = sum * 8 + did
    //值得注意的一点是， 左右移的优先级比加减还要低，所以最好能用括号就用括号，以防止误差
  大家可以自行拿v来代入，都不会有问题的。
  
  然后初始化一下（或许可以直接并入for循环中）
  	
    sort(a + 1, a + n + 1, mmp);
	if(a[1] > v)
	{
		cout<<v;
		return 0;
	}
	num[a[1] / 8 + 1] = 1 << (a[1] % 8);
  
  接下来是核心代码。
  
  对于每一个左移a[i] ，如果它左移的位数大于8，那么我们是可以将它看成先将所有的数左移 a[i] / 8 个槽，再将槽中的数左移 a[i] % 8 位。
  
    for(int i = 2;i <= n;i++)
	{
		int j = 0;
		memset(tmp, 0, sizeof(tmp));//对于每一次左移，我们用tmp数组来存储左移后的值
		tmp[a[i] / 8 + 1] = 1 << (a[i] % 8);//考虑到装箱问题能装出a[i]这个值，我们需要进行初始化
		int k = a[i] / 8;//表示左移的槽数
		int l = a[i] % 8;//表示左移的位数
    }//为了下面输入方便，我这里先将下括号括号回来
           
                                     
                                     
接下来的讲解或许用图能更方便
                             ![](https://cdn.luogu.com.cn/upload/pic/56604.png) 
![](https://cdn.luogu.com.cn/upload/pic/56605.png)
                                     
                                     
  那么据此类推，每一个都执行这么一次操作，用一个for循环，就能完成我们的高精左移
                                     
   代码：
                                     
    while(true)
	{
		j++;//因为我们存储是用了多个数组进行，所以每个数组都要执行一次操作
		tmp[j + k + 1] |= num[j] >> (8 - l);
		tmp[j + k] |= (num[j] & (lz)) << l;//移动几个槽，就往后多数几个tmp，方便
		if(j + k + 1 > sum) break;//sum表示我们如果用v的背包，最多需要几个槽。
            //如果我们执行的时候超出这个数量，说明后面的都会被扔掉，没必要做了
		
  }
  
 最后重新赋值回去
  
   	for(int i = 1;i < sum;i++)
	{
		num[i] |= tmp[i];
	}
	num[sum] = (num[sum] | tmp[sum]) & did;

                             
                              
再利用上面的for循环，将所有都跑一遍，就能得到我么想要的最终值。                          

至于最终的取结果，也很是简单
                              
    for(int i = sum;i >= 1;i--)
	{
		if(num[i] != 0)
		{
			ans = num[i];//我们只要找到最高位的那个一所在的数组
			pop = i - 1;//标记我们剩下的数组数，后面 *8 即可 
			break;
		}
	}
	while(ans)
	{
		out = ans & (-ans);//用lowbit取出最后一个一
		ans -= out;//删去。
        //当最后一次删去时，我们取出的一定是最高位的一
	}
	int in = 0;
	while(out)//接下来只要求出它的位数
	{
		in++;
		out /= 2;
	}
	pop = pop * 8 + in - 1;//我们想要的值
	cout<<v - pop;//输出
  
  下附完整代码
  
    #include<bits/stdc++.h>
    using namespace std;
    int n, v;
    int a[32];
    int num[3000], tmp[3000];
    int sum;
	int did;
	int ans, out;
	int pop;


	bool mmp(int a, int b)
	{
		return a < b;
	}

	int main()
	{
	//	freopen("1.in", "r", stdin);
	//	freopen("1.out", "w", stdout);
	cin>>v>>n;
	for(int i = 1;i <= n;i++) cin>>a[i];
	sum = v / 8 + 1;//表示占用的槽的数量
	did = (1 << (v % 8 + 1)) - 1;//最后一个占用的槽所要的位数 
	sort(a + 1, a + n + 1, mmp);
	if(a[1] > v)
	{
		cout<<v;
		return 0;
	}
	num[a[1] / 8 + 1] = 1 << (a[1] % 8);
	for(int i = 2;i <= n;i++)
	{
		int j = 0;
		memset(tmp, 0, sizeof(tmp));
		tmp[a[i] / 8 + 1] = 1 << (a[i] % 8);
		int k = a[i] / 8;
		int l = a[i] % 8;
		int lz = (1 << (8 - l)) - 1;
		while(true)
		{
			j++;
		//	cout<<lz<<endl;
			tmp[j + k + 1] |= num[j] >> (8 - l);
			tmp[j + k] |= (num[j] & (lz)) << l;
			
			if(j + k + 1 > sum) break;
		}
		for(int i = 1;i < sum;i++)
		{
			num[i] |= tmp[i];
		}
		num[sum] = (num[sum] | tmp[sum]) & did;
	}
	for(int i = sum;i >= 1;i--)
	{
		if(num[i] != 0)
		{
			ans = num[i];
			pop = i - 1; 
			break;
		}
	}
	while(ans)
	{
		out = ans & (-ans);
		ans -= out;
	}
	int in = 0;
	while(out)
	{
		in++;
		out /= 2;
	}
	pop = pop * 8 + in - 1;
	cout<<v - pop;
	return 0;
}




                                     
                                     
                                     
                                     
                                     
                                     
           
  
  
