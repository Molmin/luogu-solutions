这道题就是一道经典的01背包问题。
可以把箱子看成一个背包。
题目让我们使箱子的剩余空间最小，可以看成是让我们使箱子放的物品的体积最大。
一个物品可以分为放或不放两种选择，所以状态转移方程为：
f[j]=max(f[j],f[j-w[i]]+w[i])
上代码：
```c
#include<cstdio>
using namespace std;
int n,v,i,j,f[20005],w[20005];  //v为箱子总空间，n为有多少物品
int main()
{
	scanf("%d%d",&v,&n);
	for(i=1;i<=n;i++)
	    scanf("%d",&w[i]);  //输入
	for(i=1;i<=n;i++)  //从第一个开始
	    for(j=v;j>=w[i];j--)  //因为一个物体只能装一次，所以要从v到w[i]
	        f[j]=max(f[j],f[j-w[i]]+w[i]);  //状态转移方程
	printf("%d",v-f[v]);  //输出，注意是剩余空间
	return 0;
}
```
这是一道经典的动归01背包，最重要的就是状态转移方程：
f[j]=max(f[j],f[j-w[i]]+w[i])
还要注意的是每个物品只有一个。