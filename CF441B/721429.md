# 前言

和月赛撞题了。。。。

# 思路

把每一次太阳日的时间放到时间轴上面，进行模拟操作。

设排序后最后一天的时间为 $t$，那么我们需要模拟到 $a+1$ 天（毕竟最后一天还可以在击毁一次），判断每一天是否可以击毁，其中判断条件为如果第 $i$ 天正好对应第 $d_i$ 天或第 $d_i+1$ 天，也就是判断这一天可不可以击毁陨石。转换成编程语言就是 `i-d[i]<=1`。

如果满足条件，那么再来判断一下还可不可以再击毁陨石，即 `k>m[i]`,满足条件，就让累加器 $s$ 加上 `m[i]`，并且消耗了当天可以击毁的陨石数量，将 $k$ 减去 `m[i]`。如果这一天只能击毁一半，就先把今天要击毁的陨石击毁一部分，即 `d[i] -= k`，同时把击毁的陨石计入累加器，`s += k`。

分析的还算透彻吧，接下来给大家放代码。

# 代码

```cpp
struct node//用结构体封装代码更有条理性。 
{
	int d,m;//d,m 意义与题意相符。 
}a[300001];
bool cmp(node a,node b)
{
	return a.d<b.d;
}
signed main()
{
	int n,k,ma=INT_MIN,s=0;
	int i,j;
	cin>>n>>k;
	for(i=1;i<=n;i++)
	{
		cin>>a[i].d>>a[i].m;
		ma = max(a[i].d,ma);
	}
	sort(a+1,a+1+n,cmp);
	for(i=1;i<=ma+1;i++)//枚举到 max + 1 天
	{
		int t = k;//注意到文章讲解的只是针对一天的情况，多天时需要用 t 来储存 k 变量。 
		for(j=1;j<=n;j++)
		{
			if(i-a[j].d==0||i-a[j].d==1)//这一天可以击毁陨石 
			{
				if(t<a[j].m)//一天击毁不了全部 
				{
					a[j].m -= t;
					s += t;
					break;
				}
				else//可以击毁全部 
				{
					t -= a[j].m;
					s += a[j].m;
					a[j].m = 0;//击毁完了 
				}
			}
		}
	}
	cout<<s<<endl;//输出 
    return 0;//结束 
}
```
