建议评黑，翻译[见此](https://www.luogu.com.cn/blog/Gbn2drxNZY/arc146f-shen-mi-fan-yi)，不管能不能过审我都按这个讲（

每天获得一个诅咒的过程实在是有些抽象，我们可以定义一个新的排列 $P'$，意义是第 $i$ 种诅咒在第 $P'_i$ 天获得，因为净化一个诅咒的条件是“所有编号小于某个诅咒的诅咒都被 $\mathsf{linyue}$ 获得过”，所以第 $i$ 个诅咒被净化的时间就是 $ \max\limits_{j<=i} P'_j$，这样我们就只需要考虑 $P'$ 的前缀最大值了！

![](https://cdn.luogu.com.cn/upload/image_hosting/qrgprhvk.png)

比如上面这个例子，若 $P$ 为如图所示的排列，模拟可知仪式的贡献是 $576$，也就是**所有红色框的长度之积**！并且白色的数字的具体取值其实不重要，只要不成为前缀最大值就不会影响贡献。经过计算得出白色数字有 $96$ 种取值不会影响前缀最大值，简单推理可以知道这就是**所有紫色线的长度之积**！

于是我们就可以把前缀最大值集合完全相同的排列归为同类，对于每一类计算两者之积，这样就抛开了排列，只要对于黑色区域的边框这一格路状物计算答案即可。这里有一个 $O(nm)$ 的暴力 dp：

```cpp
#include<cstdio>
#include<cstring>
#define int long long
#define mod 998244353
using namespace std;
int n,m,dp[2][205416];
signed main(){
	scanf("%lld%lld",&n,&m);
	dp[0][2]=1;
	for(int i=1;i<n;i++){
		for(int j=1;j<=m;j++){
			dp[i&1][j]=dp[~i&1][j]*(j-1)%mod;
		}
		for(int j=m-1;j>=1;j--){
			dp[i&1][j]+=dp[i&1][j+1];dp[i&1][j]%=mod;
		}
		for(int j=m;j>1;j--){
			dp[i&1][j]+=dp[~i&1][j-1]*(j-1)%mod*(j-2);dp[i&1][j]%=mod;
		}
	}
	printf("%lld\n",dp[~n&1][1]);
}
```

（不要交它，注意这题时限十秒……）

考虑优化，我们把所有红色框的长度加上 $1$ 然后转化为一个长为 $n-1$ 的数列 $K$，它要满足：

-  $2<= K_i <= M$

-  $K_i \le K_{i+1}+1$

-  $K_1 =2$

上图的 $K$ 就是 $\{2,3,3,4,5,4,5\}$，而我们要计算的答案就是:

$$\dfrac{\prod K_i(K_i-1)}{\prod K_i^{[K_i < K_{i+1}]}}$$

这个式子上面是每一位的紫色线和红色框的长度积，下面除去了为了保证前缀最大值确实符合数列 $K$ 而消失了的紫色线。

我们观察序列 $K$，注意到它可以被分成多个上升块，并且每一个上升块的开头都不能比上一个上升块的末尾大。这个大小限制很难办，所以我们可以容斥掉它，钦定一些上升块的开头比上一个上升块末尾大，然后把它们合并起来成一个上升块，这样的上升块的容斥系数是 $(-1)^{\text{内部段数-1}}$。我们求出每一个长度的上升块答案乘上容斥系数的和，就可以用一个 $\mathrm{SEQ}$ 变换来求出整体的答案了！（神奇的是，这里的 $\mathrm{SEQ}$ 变换完美地退化成了求逆）

假如说我们没有段数的限制和要求每段的一个要求消失的紫色线，我们可以直接考虑每一个这个上升段内是否有 $i$，最后是一些一次函数相乘的形式，可以分治乘解决。可是有这两个要求，我们好像只能从 $2$ 开始 dp，考虑状态里面要记上一个数是否被选。但是我们注意到哪怕这样，每一次的转移也可以理解成给两个对应上一个数是否被选的多项式乘上不同的一次函数再合并，而这个是可以用矩阵刻画的！所以这个问题成了一些 $2*2$  的元素为一次函数的矩阵相乘的形式，分治乘的复杂度也是对的！

当然别忘了 $K$ 是有 $K_1 =2$ 的限制的，这需要一点额外的处理。

$Code$：

```cpp
//此处省略EI的多项式板子，参见《另一个欧拉数问题》（
int n,m; 
struct mat{
	poly p[2][2];
	friend mat operator*(mat m1,mat m2){
		mat m3;
		for(int i=0;i<=1;i++){
			for(int j=0;j<=1;j++){
				for(int h=0;h<=1;h++){
					m3.p[i][j]=m3.p[i][j]+m1.p[i][h]*m2.p[h][j];
				}
			}
		}
		return m3;
	}
}sis[205416];
mat divmut(int l,int r){
	if(l==r)return sis[l];
	int mid=(l+r)>>1;
	return divmut(l,mid)*divmut(mid+1,r);
}
int main(){
	cin>>n>>m;
	for(int i=2;i<=m;i++){
		mat curm;
		curm.p[0][0][0]=1;curm.p[0][0][1]=1-i;
		curm.p[0][1][1]=mi(i)*(i-1);
		curm.p[1][0][1]=1-i;
		curm.p[1][1][1]=mi(i)*(i-1);
		sis[i]=curm;
	}
	poly trap2=divmut(2,m).p[0][0];
	sis[2].p[0][0][0]=0;
	poly trap3=divmut(2,m).p[0][0];
	poly trap4=poly(n);
	trap4[1]=1;
	for(int i=2;i<n;i++)trap4[i]=trap4[i-1]*i*i;
	trap2.set_shrink(n);trap3.set_shrink(n);
	trap2=ginv(trap2);
	cout<<(trap2*-trap3)[n-1];
}
```

闲话：

这个题真的是很好很毒瘤的题，只不过我什么都没有想出来……但是这个题的包装似乎还不够完美。我当时没把排列转为紫色线，而是把红色框转为排列，于是就有了一个完美的包装（简洁起见，省略了 $m$ 的限制）：

>请对所有满足下列条件的长为 $2n-1$ 的排列计数：

>- $P_i+i \equiv 0 \pmod{ 2 } $

>- 前缀最大值均为奇数

然后这个题就离我越来越远了（