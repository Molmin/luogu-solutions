### $\text{Difficulty : 2300}$
---
### 解题思路：

其实没有必要给出一个完整的构造方法，直接让程序生成一下就可以了。代码可能更长一点，但是不用动脑子。

首先做一些基本的转化，问题实质上就是用一些类似于十字去掉中间的一个格子的图形覆盖整个矩形。直接用这些个原始的东西不太好做，考虑将两个图形放到一起，形成一个单元，也就是两个相邻的格子以及旁边的所有格子，去覆盖整个矩形。

将第一排特别考虑，显然是尽可能地放置从而使得第一排全都放满。其他的位置从横排考虑只会出现两种情况，连续有两个空白和只有一个空白，两个的话就在这个格子下面和右下放一个，只有一个的话就在这个格子下面和下面的下面放就行了。

如果没有写错的话，最后一排上再处理之前的内容的时候就已经被放满了，不需要特殊考虑。

复杂度 $O(nm)$。

---
### 代码：
```cpp
#include<cstdio>
using namespace std;
int T,n,a[1005][1005],b[1005][1005],ans;
int main(){
	scanf("%d",&T);
	while(T--){
		scanf("%d",&n);
		for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++){
			scanf("%d",&a[i][j]);
			b[i][j]=0;
		}
		ans=0;
		for(int j=1;j<=n;j++){
			int i=1;
			if(b[i][j]==0){
				if(b[i][j+1]==0&&j+1<=n){
					if(j>=2)if(b[i][j-1]==1)continue;
					ans^=a[i][j];
					ans^=a[i][j+1];
					b[i][j]++;b[i][j+1]++;b[i][j-1]++;b[i][j+2]++;
					b[i+1][j]++;b[i+1][j+1]++;
				}
				else{
					ans^=a[i+1][j];
					ans^=a[i+2][j];
					b[i][j]++;b[i+1][j]++;b[i+2][j]++;b[i+3][j]++;
					b[i+1][j+1]++;b[i+1][j-1]++;b[i+2][j-1]++;b[i+2][j+1]++;
				}
			}
		}
		for(int i=2;i<=n;i++)
		for(int j=1;j<=n;j++){
			if(b[i][j]==0){
				if(b[i][j+1]==0&&j+1<=n){
					ans^=a[i+1][j];
					ans^=a[i+1][j+1];
					b[i][j]++;b[i+1][j]++;b[i][j+1]++;b[i+1][j-1]++;
					b[i+1][j+1]++;b[i+1][j+2]++;b[i+2][j]++;b[i+2][j+1]++;
				}
				else{
					ans^=a[i+1][j];
					ans^=a[i+2][j];
					b[i][j]++;b[i+1][j]++;b[i+2][j]++;b[i+3][j]++;
					b[i+1][j+1]++;b[i+1][j-1]++;b[i+2][j-1]++;b[i+2][j+1]++;
				}
			}
		}
//		for(int i=1;i<=n;i++){
//			for(int j=1;j<=n;j++)
//			printf("%d",b[i][j]);
//			printf("\n");
//		}
		printf("%d\n",ans);
		
	}
	return 0;
}
```
