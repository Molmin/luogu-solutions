### 题意

给定一个 $3\times n$ 的方格图，求仅用题面第一张图的 $22$ 种图案（不能旋转、翻转）不重叠地恰好铺满方格图的方案数。

多组询问，$0<n<2001$，答案对 $10^{12}$ 取模。

### 思路

考虑从左开始一列一列依次铺满，设计 DP 状态。

因为每种图案横向宽度不超过 $3$，所以当它铺满某一列时，后面最多有两列可能有多余的被填上的方格。

反之，如果存在连续 $3$ 列没有全部铺满，则不再存在将它们铺满的方案。

设 $f_{i,j}$ 表示把前 $i$ 列全部铺满，接下来 $3\times 2$ 的方格的状态为 $j$（状压，$0$ 表示没填，$1$ 表示填了）的方案数。

每种图案只能和特定的轮廓吻合，形成另一种特定的轮廓。也就是说，每种图案相当于从某种状态往另一种状态转移。

也许这 $22$ 种图案有什么规律，但是我是直接把 $22$ 种转移都写上，的确写起来比较繁琐（也许是因为我没什么脑子）。

### 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 2000;
const long long mod = 1e12;
long long f[N + 10][70];
/*
这是第二维每个相对位置对应的数：
1 8
2 16
4 32
*/

int main() {
	f[0][0] = 1;
	for (int i = 0; i < N; i++) { //预处理出 f 数组
		(f[i + 1][0] += f[i][0]) %= mod; //图案 1
		(f[i + 1][2] += f[i][0]) %= mod; //图案 2
		(f[i + 2][0] += f[i][2]) %= mod; //图案 3
		(f[i + 2][0] += f[i][1]) %= mod; //图案 4
		(f[i + 2][2] += f[i][5]) %= mod; //图案 5
		(f[i + 1][5] += f[i][0]) %= mod; //图案 6
		(f[i + 2][0] += f[i][5]) %= mod; //图案 7
		(f[i + 2][3] += f[i][11]) %= mod; //图案 8
		(f[i + 2][6] += f[i][38]) %= mod; //图案 9
		(f[i + 1][3] += f[i][1]) %= mod; //图案 10
		(f[i + 1][6] += f[i][4]) %= mod; //图案 11
		(f[i + 1][3] += f[i][0]) %= mod; //图案 12
		(f[i + 2][0] += f[i][4]) %= mod; //图案 13
		(f[i + 1][1] += f[i][0]) %= mod; //图案 14
		(f[i + 2][0] += f[i][6]) %= mod; //图案 15
		(f[i + 1][11] += f[i][1]) %= mod; //图案 16
		(f[i + 1][38] += f[i][4]) %= mod; //图案 17
		(f[i + 1][4] += f[i][0]) %= mod; //图案 18
		(f[i + 2][0] += f[i][3]) %= mod; //图案 19
		(f[i + 2][1] += f[i][6]) %= mod; //图案 20
		(f[i + 2][4] += f[i][3]) %= mod; //图案 21
		(f[i + 1][6] += f[i][0]) %= mod; //图案 22
	}
	int cnt = 0, n;
	while (1) {
		scanf("%d", &n);
		if (n == 0) break;
		printf("Case %d: %lld\n", ++cnt, f[n][0]);
	}
	return 0;
}
```
