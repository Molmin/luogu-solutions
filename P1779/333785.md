算法：背包 $dp$

## 指导思想：

考虑到按照不同顺序攻击结果不会改变，不妨
**先用集体攻击将怪打残，再用个体攻击补刀。**

## 具体思路：

考虑 $dp$ 数组 $f$ , $f_i$ 表示**使用群体攻击造成伤害为 $i$（不多不少）耗费的最少魔力。**

考虑 $dp$ 数组 $g$ , $g_i$ 表示**使用个体攻击造成伤害至少为 $i$（可多不可少）耗费的最少魔力。**（这两个数组均由完全背包求解）

将**群体攻击**的伤害从 $1$ ~ $200000$ 依次枚举，加上**所需最小花费**，再依次看每只怪兽有无血量剩余，若有，则释放一个造成同等血量伤害的**单体攻击**，再加上该单体攻击**最小花费** 。

以上，为此题的具体思路。

## 注意事项：

- 坑点1，若有两个伤害为 $99999$ 的群体攻击， 相加后伤害会大于 $100000$ , 这种情况是会对答案产生影响的，故数组大小要设到 $200005$ 。

- 坑点2，伤害非零且耗费魔力为零，直接输出 $0$ , 退出程序。

- 坑点3， $g_i$ 表示的是伤害**至少**为 $i$ 时的最小花费。故后面还要进行一次**倒序**转移最小值一遍。

## 代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
int n, m, a[105], b[105], c[105];
long long res, ans = (long long)1 << 50, f[2000005], g[2000005];
bool u[105];// 群体攻击还是个体攻击 
string s, t;
int main()
{
	scanf("%d", &n);
	for(int i = 1; i <= n; i++)
		scanf("%d", &a[i]);// 怪的血量 
	scanf("%d", &m);
	for(int i = 1; i <= m; i++)
	{
		cin >> s >> b[i] >> t >> c[i];
		if(t == "All")// 标记为群体攻击 
			u[i] = 1;
		if(!b[i] && c[i]) // 免费的午餐 
		{
			printf("0\n");
			return 0;
		}
		c[i] = min(c[i], 200000);// 稍微削减伤害 
	}
	for(int i = 1; i <= 200000; i++)
		f[i] = g[i] = (long long)1 << 50;// 初始化 
	for(int i = 1; i <= m; i++)// 群体攻击 
	{
		if(u[i])
		{
			for(int j = c[i]; j <= 200000; j++)
				f[j] = min(f[j], f[j - c[i]] + b[i]);
		}
	}
	for(int i = 1; i <= m; i++)// 个体攻击 
	{
		if(!u[i])
		{
			for(int j = c[i]; j <= 200000; j++)
			{
				g[j] = min(g[j], g[j - c[i]] + b[i]);
			}
		}
	}
	for(int i = 199999; i >= 0; i--)// 逆序转移 
	{
		if(g[i] > g[i + 1])
			g[i] = g[i + 1];
	}
	for(int i = 0; i <= 200000; i++)// 枚举群体攻击伤害 
	{
		res = f[i];
		for(int j = 1; j <= n; j++)
		{
			if(a[j] - i > 0)// 个体攻击补刀 
				res += g[a[j] - i];
		}
		ans = min(ans, res);
	}
	printf("%lld\n", ans);// 愉快输出 
    return 0;
}
// hjz AK IOI 
```
