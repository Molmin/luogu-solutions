# 本蒟蒻第二篇题解，如有漏洞，请多指教
这道题既然是输入了一行只有0,1的字符，那我们可以自然地想到——
```cpp
#include <cstring>
```
这个神奇的头文件下有许多极其方便的字符串处理函数，我作为一位被字符串整得死去活来的蒟蒻，在此普及一下如何用这些函数
##### 简洁地
水过这道水题——


---------------------------------------------------------华丽丽的分割线----------------------------------------------------------
## 1
首先我们看到题目要求：

若s串全为0——————A

若s串全为1——————B

否则 C+将s串分成二等分分别处理

### 赤裸裸的递归呀

思路√

## 2
首先，如何判断目前s串全为1或全为0呢？
#### s.find大法好啊！
首先，了解一下find函数的性质——1.如果找到参数字符串，返回找到的第一个字母的位置；2.否则返回-1；

如果要判断全为0，检查find("1")是否==-1；
反之，检查find("0")是否==-1；
```cpp
if(s.find('1')==-1) {printf("A");return ;}
if(s.find('0')==-1) {printf("B");return ;}
```


如果以上皆不成立，分成同样的两部分递归处理：
```cpp
int t=s.size();
printf("C");
dg(s.substr(0,t/2));
dg(&s[t/2]);
```
注：s.substr：指定起点与终点，取s从起点到终点之前的子串；

&s[t/2]：&，取址符；字符串一种极其诡异的性质：取某一个字符的地址，便会自动遍历至字符串末尾……这正好帮了我们，直接&s[t/2]就可以取后半部分了……
## 3 完整代码
```cpp
#include <iostream>
#include <cstring>
using namespace std;
string ss;
void dg(string s) {
	if(s.find('1')==-1) {printf("A");return ;}
	if(s.find('0')==-1) {printf("B");return ;}
	int t=s.size();
	printf("C");
	dg(s.substr(0,t/2));
	dg(&s[t/2]);
}
int main() {
	cin >> ss;
	dg(ss);
	return 0;//编码完成祭
}
```
17行，还不错……