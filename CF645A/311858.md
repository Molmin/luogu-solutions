[原题传送门](https://www.luogu.com.cn/problem/CF645A)。
[在窝的博客中食用更佳](https://www.luogu.com.cn/blog/MZY666/solution-cf645a)。

### 【 题意翻译 + 概括 】

（目前还没有翻译）

输入两组数据，每一组数据有两行，每行两个字符。

每组数据中的字符只可能是 $A$，$B$，$C$，$X$。其中 $X$ 表示为空。

求能否通过移动第一组数据中的 $A$，$B$，$C$ 使得与第二组数据相同。

能则输出 `YES`，否则输出 `NO` 。

移动规则：每次移动只能把 $A$，$B$，$C$ 移动到相邻且为空的格子上。

### 【 思路 】

用一个外层循环多循环几次，每次循环都按**同一种**方法去改变第一组数据。

每次改变后都判断能否和第二组数据完全相同。若相同则输出 `YES` 并终止程序。随后在循环外输出 `NO` 即可。

其它细节见代码吧。

### 【 代码实现 + 注释 】

```cpp
#include<bits/stdc++.h>//万能头文件好
using namespace std;
#define ll long long//个人习惯
char a[5],b[5];//数组最好放外面
bool s(){//移动第一组数据+判断的bool类型函数
	bool flag;//定义返回值
	int x,i;//x用于记录空的那一位的数组下标，i为循环变量
	if(a[1]==b[1]&&a[2]==b[2]&&a[3]==b[3]&&a[4]==b[4])
		flag=true;
	//如果和第二组数据完全相同，则返回值为真，但还得移动，不能立刻退出
	else flag=false;//否则返回值为假
	for(x=1;x<=4;x++){
		if(a[x]=='X')break;//找到空的那一位
	}
	if(x==1){
		a[1]=a[2];//移动
		a[2]='X';//移动
	}
	if(x==2){
		a[2]=a[4];//移动
		a[4]='X';//移动
	}
	if(x==3){
		a[3]=a[1];//移动
		a[1]='X';//移动
	}
	if(x==4){
		a[4]=a[3];//移动
		a[3]='X';//移动
	}
	return flag;//返回此函数值
}
int main(){//主函数
	char sp;//过滤空格
	scanf("%c%c%c%c%c%c%c%c%c%c%c",&a[1],&a[2],&sp,&a[3],&a[4],&sp,&b[1],&b[2],&sp,&b[3],&b[4]);
	//输入（懒得用循环）
	for(int i=1;i<=16;i++){//开始循环移动第一组数据+判断
		if(s()){//如果函数返回值为真
			printf("YES\n");//输出YES，换行是个好习惯
			return 0;//提前结束程序
		}
	}
	printf("NO\n");//如果做不到则输出NO
	return 0;//over~
}
```

另：作者已自愿禁言一年，因此有建议请私信，否则**无法**回复您哦！

完结撒花~（疯狂暗示๑乛◡乛๑