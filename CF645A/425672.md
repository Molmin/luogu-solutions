这道题我们或许会首先想到列举出每一种情况，但这样太麻烦。这道题还是**有规律可循**。

自己列举几种情况后可以发现，无论初始状态是什么样，无论怎么挪动，在不算 $\mathtt{X}$ 时，顺时针方向上 **$\mathtt{A,B,C}$ 的顺序恒定**。

因此使用数组储存初始顺序，再将其与给出的结果顺序比较，若不一样则输出 $\mathtt{NO}$，否则输出 $\mathtt{YES}$。

这道题还有很多代码实现的细节，将在代码中给出讲解。

View code:
```cpp
#include<bits/stdc++.h>
using namespace std;

#define ri register int

char b[2][2],f[2][2],s[4],s2[4];

signed main(){
	for(ri i=0;i<=1;i++)
		for(ri j=0;j<=1;j++){
			cin>>b[i][j];
			if(b[i][j]<'A'||b[i][j]>'Z')//在使用scanf时会把回车也算上，因此要避免
				cin>>b[i][j];
		}
	
	for(ri i=0;i<=1;i++)
		for(ri j=0;j<=1;j++){
			cin>>f[i][j];
			if(f[i][j]<'A'||f[i][j]>'Z')
				cin>>f[i][j];
		}
	if(b[0][0]=='X')
		s[0]=b[0][1],s[1]=b[1][1],s[2]=b[1][0];
	if(b[1][0]=='X')
		s[0]=b[0][0],s[1]=b[0][1],s[2]=b[1][1];
	if(b[1][1]=='X')
		s[0]=b[1][0],s[1]=b[0][0],s[2]=b[0][1];
	if(b[0][1]=='X')
		s[0]=b[1][1],s[1]=b[1][0],s[2]=b[0][0];
	if(f[0][0]=='X')
		s2[0]=f[0][1],s2[1]=f[1][1],s2[2]=f[1][0];
	if(f[1][0]=='X')
		s2[0]=f[0][0],s2[1]=f[0][1],s2[2]=f[1][1];
	if(f[1][1]=='X')
		s2[0]=f[1][0],s2[1]=f[0][0],s2[2]=f[0][1];
	if(f[0][1]=='X')
		s2[0]=f[1][1],s2[1]=f[1][0],s2[2]=f[0][0];
	s[3]=s[0],s2[3]=s2[0];//数组存储时，最后一位字母的后一位应该存为第一位的字母，构成环
	for(ri i=0;i<=2;i++)
		for(ri j=0;j<=2;j++)
			if(s[i]==s2[j]&&s[i+1]!=s2[j+1]){
				printf("NO");
				return 0;
			}
	printf("YES");
	return 0;
}
```