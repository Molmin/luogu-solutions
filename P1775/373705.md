## 思路

原题传送门：[Link](https://www.luogu.com.cn/problem/P1775) 。

本题是 [P5569 [SDOI2008] 石子合并](https://www.luogu.com.cn/problem/P5569) 和  [P1880 [NOI1995] 石子合并](https://www.luogu.com.cn/problem/P1880) 的弱化版本，适合 dp 初学者做练习，如果您已经切爆了本题，不妨点开上面两个链接练习标准版和强化版。

题目要求求出石子合并后的最小代价，我们很容易想要贪心的思路，但是题目要求每次只能合并相邻两堆石子，因此本题应使用 DP 求解。

不难发现，最后得到的最大的石子堆是由两个相邻的石子堆合并形成的，而这两个石子堆又分别是由更小的两个相邻石子堆合并而来。因此我们可以得出，一个较大是石子堆一定是由两个较小的相邻石子堆合并形成。

接下来是重点：

我们定义一个状态 dp[i][j] ， 它代表从将最开始的第 i 堆石子到第 j 堆石子合并成一个大堆所消耗的最小代价。考虑边界情况，当只有一堆石子时，不需要耗费任何代价，即 dp[i][i] = 0 。

其次，考虑如何转移状态，上面已经提到，一个大的石子堆一定是由两个小的相邻石子堆合并而成。因此我们可以将大的堆拆成两个小的石子堆，枚举中间的点，每次计算合成这两小堆已用代价加上这次合并的代价（这次合并的代价即整个区间的和），找到最小值，即 dp[i][j] = min( dp[i][j] , dp[i][k] + dp[k+1][j] + a[i] + a[i+1] + ··· + a[j] )  i ≤ k ≤ j 。

为了降低时间复杂度，可以使用前缀和优化，以便我们在 $O(1)$  的时间内求出区间和。

再回到上文提到的大石子堆由小石子堆合成，我们应先求出合成小石子堆用的总代价，再去求合成大石子堆所用的总代价。

将思路串起来，使用三重循环，最外层枚举区间长度有小到大（对应上文小石子堆合成大石子堆），第二层枚举区间起点，最后一层枚举中间点，按照状态转移方程求解，最后的答案即 dp[1][n] 。

总体时间复杂度 $O(n^3)$ 。

讲的可能不是非常清晰，请多多包涵。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int INF=0x7fffffff;
int dp[305][305],a[305],sum[305],n;
int l,r;
inline int read()//快读
{
	int x=0,f=1;
	char ch=getchar();
	while(ch<'0' || ch>'9')
	{
		if(ch=='-') f=-1;
		ch=getchar();
	}
	while('0'<=ch && ch<='9')
	{
		x=(x<<3)+(x<<1)+ch-'0';
		ch=getchar(); 
	}
	return x*f;
}
int main()
{
	n=read();
	for(int i=1;i<=n;i++) a[i]=read();
	for(int i=1;i<=n;i++) sum[i]=a[i]+sum[i-1];
	for(int len=2;len<=n;len++)
	    for(int j=1;j<=n-len+1;j++)
	    {
	    	l=j;
	    	r=j+len-1;
			dp[l][r]=INF;
	    	for(int k=l;k<r;k++) dp[l][r]=min(dp[l][r],dp[l][k]+dp[k+1][r]+sum[r]-sum[l-1]);
		}
	cout<<dp[1][n]<<'\n';
	return 0;
}
```
