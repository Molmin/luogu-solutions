附：[原题](https://atcoder.jp/contests/arc115/tasks/arc115_c) 链接。

首先，我们需要注意，题意中说的是，若 $ i $ 为 $ j $ 的因数，$ A_i \neq A_j $，而非其所有因数都两两不相同。

那么最朴素的想法就是，假设 $ i $ 有 $ t $ 个因数，那么它就是 $ t-1 $，但稍微算算就知道，这个数列的最大值实在是**太大了**。

比如：从 $ 1 $ 到 $ 7 $，如果按这样算，最大就是 $ 4 $：

> $ 1,2,2,3,2,4,2 $

但实际上最大 $ 3 $ 即可。

所以怎么办呢？

我们发现，对于 $ 6 $，其实它并不需要是 $ 4 $，因为有重复的 $ 2 $，$ 3 $ 即可。

因此，对于部分较小的因数，可以想办法将他们对应的数值构造成一样的，从而减小大下标下的数值。

我们考虑将他们按如下的方法分组：

$ \{1\} $

$ \{2,3\} $

$ \{4,5,6,7\} $

$ \{8,9,10,11,12,13,14,15\} $

等等。

这样可以保证每组里面没有任何一个数是另一个数的因数或者倍数，因此每组中的数值可以相等而不违反题意。

每组有一个数值，比如第 $ 1 $ 组中的下标对应数值 $ 1 $，第 $ 2 $ 组中的下标对应数值 $ 2 $ 等等。

稍加观察（~~傻子都知道~~）可得，按以上方法得到的数值，对于下标 $ i $ 有：

$$ A_i=\log(i)+1 $$

那么就是代码了：

温馨提示：如果用的不是 `printf("%d ",log2(i)+1)`，别忘了强制转换类型为 `int`。

```cpp
//ARC115C 22.11.20
#include <bits/stdc++.h>
using namespace std;
int n;

int main()
{
    ios::sync_with_stdio(0);
    cin.tie(0); cout.tie(0);
    cin>>n;
    for (int i=1;i<=n;i++) cout<<(int)log2(i)+1<<" ";
    exit(0);
}
```
