写个嘴巴 sol。如果哥哥们发现有问题麻烦和我说一下。

场上写了 450 行没有写完，也没有意愿接着调了。

首先我们观察题面性质。每个位置给了高达 100 bit 的空间。

于是对于所有 $2n+1 \le 10$，我们可以直接把整张图状压下来然后去算答案。这个是平凡的且能获得 14 分。

同时我们发现我们容易在前几轮状压下每个位置及其右下 $9 \times 9$ 的状态。然后通过一些**小小**的讨论把他们放到最左上角，在最后一次询问中得到至多 $27 \times 27$ 的区域。可以获得 44 分。

然后你把他再稍事讨论可以压 $10\times 10 $ 获得 54 分。

接下来说正解。不妨假设 $n=20$。

发现压整张图不靠谱，我们来压边界情况。


![](https://cdn.luogu.com.cn/upload/image_hosting/c5dmfej0.png)

在最后只剩 $5\times 5$ 的时候，我将格子分为以下 2 类：

- 图中标了 O(1) 的格子。则表示其为至少一边长为 $2\times n-39$，此处即 1 的长方形。

- 其余格子。为 $10\times 10$。

那么我希望在第二类区域中压下如下信息:

- 该区域的红边上的 01 情况。40bits。

- 该区域的红边上 1 的连通性。因为我们记录了 01 情况，而且连续的 1 一定在一起，我们直接给每个 01 assign 一个 id 就好了。至多是 20 个连通块（两两差一个），很可惜每个需要 5 位。一共是 100 bits。

- 该区域的**除去边缘**的答案，需要 8bits。


这样在最后一轮我们就可以用并查集求出答案。可是问题在于位数不够了！

让我们理性分析。发现第一类点只要至多 $10$ bits 便可压下来，在混。显然我们是不能让他们划水的，否则肯定没有前途。 

于是，我们将蓝边 01 压进 1，棕边 01 压给 2，以此类推。

5 可以存一些第一类格子的信息。

那么我们只要在每个剩余格子中存下对应区域的 2 3 类信息。一共需要 108 bits。怎么办呢？

我们钦点第一个连通块编号是 0，随后一直填 0 直到第一个和其不连通的首个 1 的位置填一个 1。至少两个本应 5bit 的数分别用 1bit 表示，刚好节约了 8bit 腾给答案！

感觉还是很精妙的。


![](https://cdn.luogu.com.cn/upload/image_hosting/wadb2vcn.png)
