- ## 前言

	这是一个模拟题,难度不亚于杀蚂蚁
	
	因为与杀蚂蚁相比更需要清晰的结构

	所以很考验代码底力..底力与写代码的时间成正比
    
    同时也考研对于语言的理解

---
- ## 题解
	我们先一点一点考虑
    
    从底层往上层来考虑
    
    下文都是以c++为语言
    
    ---
    变量最多只有26个
    
    我们可以开个数组来保存每个变量的值
    
    --- 
    
   让人头痛的是表达式的处理
        
   首先是表达式的存储，我们可以用一个二元组OBJ=  
   $<Type(int),Data(int)>$
    
   来存储一个单位，其中Type表示类型，Data表示数据
        
   类型可以是整数，代数和运算符
        
   而数据就如字面意思
        
   那样我们存储一个表达式就可以用vector<OBJ>实现，设其为EXP
  
  中缀表达式很难处理，我们可以将其转换为后缀表达式
  
  如何转换可以见百度
  
  ---
  
  设数据结构ASSIGN为二元组类型$<Vala(char),Valb(EXP)>$,表示将表达式Valb计算出并赋值给变量Vala
  
  然后我们建立一个通用的可以表示所有语句数据结构STATE
  
  可以理解为二元组$<Type(int),Data(void*)>$Type表示类型，Data表示有关数据
  
  对于Type表示continue，break,start，end语句时，Data不用管
  
  对于Type表示loop，write语句时，Data表示其后的表达式参数，所以此时Data就是一个指向EXP的指针
  
  对于Type表示赋值语句时，Data表示整个赋值语句参数，所以此时Data就是一个指向ASSIGN的指针
  
  ---
  
  然后我们就能把所有的语句都存下来，存到一个数组里
  
  对于loop end和start end我们处理出每个loop和start所对应的end的位置，用下标来存储
  
  对于运作我们可以写一个RUNA函数来执行一个语句，当然它只会处理赋值语句和write语句，其他都会忽略
  
  我们再写一个RUN函数来执行[F,T]这段语句，它的返回值表示是否因为break而退出的
  
  RUN实现就是对于每个语句先RUNA一遍，然后在讨论是什么语句
  
  		
        	如果是continue就直接返回0
        
       	 如果是break就直接返回1
        
       	 如果是loop就处理出表达式的值k，然后多次递归处理loop所表示的语句区间，(这段区间不包括这个loop和end);在处理到达k次或者递归返回1时结束对这个loop和end的处理，并把当前位置跳到end后
        
        	如果都不是就把当前位置+1
            
   这样最后一个RUN(2,L-1)就能完成了，假设语句存储从1开始且语句个数为L
   
   [代码](https://paste.ubuntu.com/p/xJjf5t9wKr/)
  
  
  
  
        
        