# ~~好一道水的DP~~
## 很显然这就是一道01背包求方案数（假当就是这样好了）~~反正差不多~~
我们**设一个数组f[x][y]来表示前x个物品选y个的值**，因为每一个只能选一次，所以，是一个**01背包**

我们可以得到下面的动态转移方程
```cpp
f[i][j]=(f[i-1][j]+f[i-1][j-1]*a[i])%mod;
```
然而空间给你炸爆，所以我们有两种选择

1. 滚动数组
2. 直接压缩掉一维~~降维攻击~~

于是我愉快的选择了第二种

**AC代码（01背包板子）**

```cpp
#include<bits/stdc++.h>
using namespace std;
long long f[100010],a[100010],n,k;
int main() {
	cin>>n>>k;
	for(int i=1;i<=n;i++) scanf("%d",&a[i]);
	f[0]=1;//这一点很重要，不要忘了
	for(int i=1;i<=n;i++) {
		for(int j=k;j>=0;j--) {
			f[j]=(f[j]+f[j-1]*a[i])%1000000007;
		}
	}
	cout<<f[k];
	return 0;
}
```
如果各位感觉给你了一些帮助，~~能否给我一个赞呢~~

**END**