## Part I 前言
此题其实有**一定难度**， $n\le10^5$ 会把人吓到，容易**想复杂化**。仔细想一想，其实**没那么复杂**。  
我写题解之前看了看其它几篇题解，都是用拓扑排序的框架（或者说思想）做的，代码量大且容易出错。  
本蒟蒻提供一种新的思路，代码只有 18 行，但请仔细看，理解代码的每一句话。
## Part II 思路
任何一种算法都要知道它大概是怎么想出来的，比如最短路中的动态规划解法。  
首先要**简化题意**。题面有一个地方会让人想复杂。题中说让排序，但仔细想想，真的要排序吗？  
答案是**不需要排序**。你想想，删了数以后只要每个数的数量相等，排了序以后肯定是一样的啊！就和全等三角形一个道理，只要三条边一样，面积肯定也一样。  
**综上所述，只要删除不需要的就行了**。  
或许你会说：“我枚举每列数删不删，在检查一下，会怎样？”  
很遗憾，这是指数级的算法，有可能没有分，但勇气可嘉。  
既然要让剩下的数的数量相等，而第一个序列每个数有且仅有一个，那就在第一个序列中看看这个元素在第二、三个序列中是否存在，只要不存在就把这一列删去。这样操作若干次即可。考虑到 $n\le10^5$ ，再循环 100 次比较合适。
## Part III 注意事项
因为要记录每个数的数量，有些人习惯性用了 map 映射。这道题数都在 $n$ 以内，可以直接上数组，避免 $logn$ 带来的超时。  
一定要对之前所述的操作执行至少 100 次，少了有可能没找全。
## Part IV 代码
说了那么多，上代码！
```cpp
#include<iostream>
#include<cstdio>
#define _for(i,a,b) for(int i=a;i<(int)(b);i++)//不知道自行搜索，注意左闭右开
using namespace std;
int n,a[5][100002],d[100002],now,cnt,ans,c[5][100002];
int main(){
	scanf("%d",&n);
	_for(i,1,4)
		_for(j,1,n+1)scanf("%d",&a[i][j]),c[i][a[i][j]]++;
	_for(T,1,101)//执行若干次
		_for(i,1,n+1)//遍历序列
			if(a[1][i]!=-1)//没有被删除
				if(c[2][a[1][i]]==0||c[3][a[1][i]]==0){//在第二个或第三个中没有第一个
					c[1][a[1][i]]--;c[2][a[2][i]]--;c[3][a[3][i]]--;a[1][i]=-1;//更新并标记为删除
				}
	_for(i,1,n+1)ans+=(a[1][i]==-1);//被删了就累加
	return printf("%d\n",ans),0;//完结撒花
}
```
