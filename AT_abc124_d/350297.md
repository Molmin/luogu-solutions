注：下文称连续的若干个 $1$ 为 $1$ 串，连续的若干个 $0$ 为 $0$ 串。

---

因为要求的是最长的连续 $1$，所以只用考虑反转至多 $k$ 个 $0$ 串的最大收益，其实和求固定长度的最大子串和也差不多。

一个滑动的窗口，一直加入元素。若需要加入一个 $0$ 串时，发现已经有了 $k$ 个 $0$ 串，就移除最后添加的 $0$ 串以及它再之前的 $1$ 串（已经连不上的）。

先预处理用成若干个 $0$ 串和 $1$ 串将原字符串表示出来，我用的是 $0$ 串记为正数，$1$ 串记为负数。比如样例的 `11101010110011` 就处理成 `-3 1 -1 1 -1 1 -2 2 -2`。然后用滑动窗口处理即可。

假设现在加入的 $i$ 号串为 $0$ 串，且现在（加入前）已有 $k$ 个 $0$ 串，则要删除 $0$ 串 $i-2k$ 和 $1$ 串 $i-2k-1$的贡献。

为什么是 $i-2k$ 呢？因为很显然，处理后的序列必然是 $01$ 相间的，那么 $i$ 前的第 $1$ 个 $0$ 串即是 $i-2$，第 $k$ 个即是 $i-2k$。而 $i-2k-1$ 是在删除 $i-2k$ 后已经无法联通的，所以也要去除。

复杂度 $O(n)$。

```cpp
#include<algorithm>
#include<iostream>
#include<cstring>
#include<cstdio>
#include<cmath>
using namespace std;

const int MAXN=1e5+5;
int n,k,tot,a[MAXN],t[MAXN]; 

void read(){
    for(int i=1;i<=n;i++) scanf("%1d",&t[i]);
    if(t[1]==0) a[tot=1]=1;     // 预处理 0/1 串 
    else a[tot=1]=-1;
    for(int i=2;i<=n;i++)
        if(t[i]==t[i-1]){
            if(t[i]==0) a[tot]++;
            else a[tot]--;
        }
        else{
            if(t[i]==0) a[++tot]=1;
            else a[++tot]=-1;
        }
    n=tot;
} 
int main(){
    scanf("%d%d",&n,&k);
    read();
    int maxn=0,now=0,val=0;     // now 表示当前 0 串的个数，val 是当前的子串和。 
    for(int i=1;i<=n;i++){ 
        if(a[i]>0){				// 如果当前加入的是 0 串 
            if(now==k) val-=a[i-2*k]-a[i-2*k-1];    // 去除过期元素，注意因为 a[i-2*k-1] 是 1 串，用的是负数记录，要用减法，等价于 +(-a[i-2*k-1]) 
            else now++;
        }
        val+=abs(a[i]);         // 加入当前元素（注意是绝对值） 
        maxn=max(maxn,val);     // 在所以状态中取最大 
    }
    printf("%d\n",maxn);
    return 0;
}
```

Q：你这样写不就没法计算到后缀的贡献了吗？

A：因为每个元素的贡献都是正的，所以后缀中最优的就是在合法情况下的极长后缀，而这个在加入最后一个元素的时候是计算了的，故后面的算不算都无所谓。

同样的道理其实前缀也是没有必要的，但这样写可以规避掉 $k$ 大到能让整个序列全部变成 $1$ 的情况。还是同样的道理选取非前缀非后缀的中间子串也是选极长子串。