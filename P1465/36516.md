只有我不是暴力做的嘛……

纯自创的递推解法，也可以说是

##数位dp

时间复杂度O(十进制的位数×给定的罗马字母数）

觉得还是很难理解的

但是写出来对数位dp的水平提升很有帮助啊

首要依据就是：

#罗马表示法中的个位、十位、百位……都具有独立性

就是说不管是3456还是4456还是5456后面的456表示都是一样的

下面的f数组，f[i][j]表示在0~10^i-1里面第j位罗马字母的出现次数

a数组是预处理啦，a[i][j]表示个位数字i的表示里第j个罗马字母的次数

由于0~9的罗马表示里面只有I,V,X，所以只开了三个单位

```cpp
#include<cstdio>
using namespace std;
int f[4][9],ans[9],n;
int a[10][3]={{0,0,0},{1,0,0},{2,0,0},{3,0,0},{1,1,0},{0,1,0},{1,1,0},{2,1,0},{3,1,0},{1,0,1}};
char c[10]={"0IVXLCDM"}; //前面那个0是占位用的
int pw(int k)//实际上是10^(k-1)
{
        int ans=1;
    for (int i=1;i<k;i++)
        ans*=10;
    return ans;
}
int main()
{
    for (int i=1;i<=3;i++)//预处理出f
    {//比如0~99可以拆成在个位0~9各十个和在十位的0~9各一个
        for (int k=1;k<=7;k++)//“在个位0~9各十个”，而个位0~9各一个的和是上一次算的f[i-1]
            f[i][k]=10*f[i-1][k];
        for (int j=0;j<=9;j++)//“在十位的0~9各一个”
            for (int k=i*2-1,w=0;w<3;k++,w++)//k为什么是2*i-1呢……？能想通就好，想不通就待定系数法解吧^.^
                f[i][k]+=a[j][w]*pw(i);
    }
    scanf("%d",&n);
    for (int i=3,j=1000;i>=1;i--,j/=10)//因为n最大3000多没有上万，所以最大单位为千
        if (n>=j)
        {
            int sa=n/j,sb=n%j;//十进制里第i位是sa，剩下的余数是sb（不要吐槽这个名字……）
         /*还是举例子比如n=2451吧，一共有sa=2次完整的0~999的循环（这句话中忽略千位）和剩下的451*/
            for (int k=1;k<=7;k++)//sa=2次完整的0~999的循环
                ans[k]+=f[i][k]*sa;//每个罗马字母都要计数（不可以写什么2*i+1啥的！每一位都要记！）
            for (int e=1;e<sa;e++)//0~999的循环时之前忽略的千位每位要加1000遍；e应该从0开始但是因为0啥也没有就扔了
                for (int k=i*2+1,w=0;w<3;w++,k++)
                    ans[k]+=a[e][w]*j;
            for (int k=i*2+1,w=0;w<3;w++,k++)//剩下的451前面的千位数是sa
                ans[k]+=a[sa][w]*(sb+1);//sb要加一是因为0~sb有sb+1个数，每个数都有千位数sa
            n=sb;//n的千位都搞定了就可以扔掉啦
        }
    for (int i=1;i<=n;i++)//到这里的时候n应该已经<10了
        for (int j=1;j<=3;j++)//完全用a数组枚举就可以
            ans[j]+=a[i][j-1];
    for (int i=1;i<=7;i++)
        if (ans[i])
            printf("%c %d\n",c[i],ans[i]);
}
```
（这里的+1-1都特别混乱……想不通就用待定系数法解吧，代两个值解二元一次组就好……)

（（如果待定系数不太明白再私信叭(-^〇^-)））
