看到大佬们都是用的同一种思路，本~~(～￣(OO)￣)ブ~~蒟蒻颤抖着来献上自己的解法。![](https://img.shields.io/badge/蒟蒻是我-珂怕-blue.svg)

-------------我--------------是--------------分--------------割--------------线-------------

这题的题意也可以这样解释：

你是一个蒟蒻，正在参加AK模拟赛，你第一次提交，得到了一个分数20分，你心平气和的接受了这个成绩，内心毫无波澜︿(￣︶￣)︿。然后你改了代码，又提交了一次，历史最低~~爆0了~~让你十分惊讶(ΩДΩ)，心想：~~我怎么可以这么菜呢~~，于是发愤图强，得了历史最高60分，这也会让你惊讶(～￣▽￣)～，心想：~~我是大佬~~，请统计，认为自己很菜或是大佬的时候出现了几次？

能够让你失去信心或是信心百倍的分数有什么特性呢？如果将这次成绩同之前成绩放在一个数组里排序后（不是第一次）一定是以下两种情况之一：

1.排在整个数组第一个，且与第二个数字不同；

2.排在整个数组最后一个，且与倒数第二个数字不同。

所以只要满足两个条件之一，ans（计数器）+1。

拿样例1演示一下（橙色满足条件，黑色不满足，大家自行了解）：

![](https://cdn.luogu.com.cn/upload/pic/21217.png)

综上所述，代码很简单了，但是在这里要对大家说（滑稽）：

# sort大法好！！！

上代码喽(｡◕ˇ∀ˇ◕)（注释部分为调试代码，请忽视）

```cpp
#include<iostream>
#include<algorithm>//一个神奇的库
using namespace std;
int n,k,a[1001],ans;
int main()
{
    cin>>n;
    for(int i=0;i<n;i++)
    {
        cin>>k;//输入副本，以备比较
        a[i]=k;//保存
        sort(a,a+i+1);//排序
        //for(int j=0;j<=i;j++)
			//cout<<a[j]<<" "; 
        if(((a[0]==k&&a[1]!=k)||(a[i]==k&&a[i-1]!=k))&&i!=0)//判断条件
            ans++;//符合就+1
        //cout<<endl;
    }
    cout<<ans<<endl;//输出
    return 0;
}
```

~~**蒟蒻已经逃跑了，没法和大家说再见**~~