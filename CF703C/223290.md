这个题目嘛，主流做法是凸包DP，~~但是我如果用的是凸包就不会来发题解了。~~

看了一下网上大佬的博客，有了启发：

考虑凸包上是否存在一个点，其到达y轴的时间比人经过那点的时间还短，如果存在，那么人不可能在凸包运动到y轴之前顺利到达对岸。

再考虑凸包上是否存在一个点，其到达y轴的时间比人经过的时间还长，如果存在，那么人不可能在凸包运动到y轴之后顺利到达对岸。

**如果同时存在着两个点，人必定会撞到凸包。**

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,bo1,bo2;
double w,v,u,mx,x[100010],y[100010];
int main()
{
    cin>>n>>w>>v>>u;
    for(int i=1;i<=n;i++)
    {
        scanf("%lf%lf",&x[i],&y[i]);
    }
    for(int i=1;i<=n;i++)
    {
        if(x[i]/(v*1.0)<y[i]/(u*1.0)) 
	{
		bo1=1;
	}//凸包上是否存在一个点，其到达y轴的时间比人经过那点的时间还短，如果存在，那么人不可能在凸包运动到y轴之前顺利到达对岸。
        if(x[i]/(v*1.0)>y[i]/(u*1.0)) 
	{
		bo2=1;
	}//凸包上是否存在一个点，其到达y轴的时间比人经过的时间还长，如果存在，那么人不可能在凸包运动到y轴之后顺利到达对岸。
    }
    for(int i=1;i<=n;i++)
    {
        mx=max(x[i]/(v*1.0)+(w-y[i])/(u*1.0),mx);
    }
    if(bo1==1&&bo2==1)
    {
        printf("%.10lf",mx);
    }//如果同时存在着两个点，人必定会撞到凸包。
    else
    {
        printf("%.10lf",w/(u*1.0));
    }
    return 0;
}
```


[大佬原文链接（咕掉了记得告诉我一声）](https://blog.csdn.net/mengwuyaaa/java/article/details/799219)