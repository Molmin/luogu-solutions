### 让我们来一种数学化的做法。
我们从$DP$入手。$DP$的做法相当简单粗暴，把左右两个人上一次传到的方案数加起来，最后得到一个解的矩阵（当然可以优化成一行），找到最下方的$1$号位就是问题的解。即：
```cpp
x=2..m-1, y=2..n-1;
{
	f[1][1]=1, f[1][y]=0;
	f[x][1]=f[x-1][n]+f[x-1][2];
	f[x][n]=f[x-1][n-1]+f[x-1][1];
	f[x][y]=f[x-1][y-1]+f[x-1][y+1];
}
ans=f[m][1];
```
## 数学化：
当我们看到左右叠加时，我们就应该想到一个图形：**杨辉三角**。

摒弃环形结构，我们假设这是一条无穷长的队伍，中间有一个起始点小蛮，那么样例的图形就会画成这样：
```cpp
      1      //小蛮
    1 0 1
  1 0 2 0 1
1 0 3 0 3 0 1
```
显然是个杨辉三角了。
# 下面我们来找小蛮。
我们只需要考虑结果，因此我们只取最下面一行：
```
1030301
```
取中间点：
```
1030301
   ^
```
左右扩展：
```
1030301
^  ^  ^
```
累加这几个位置上的数，得到结果$ans$。
## 寻找符合要求的点：
中间点比较好找，第$m+1$个点，但是其它点呢？

我们可以把这个队伍划成多个$n$个人的队伍，而小蛮在其中的位置是不变的。

我们顺其自然地想到取余：如果这两个点的编号关于$n$同余，那么就是小蛮。所以我们只需要知道任何一个是小蛮的点，就可以判断任何一个点是不是小蛮。而这个确定点我们已经知道了，第$m+1$个。

在下面给出的代码中，为了编程方便，是将$[0]$号位判别为第$1$个点的。
```cpp
#include<bits/stdc++.h>//换成#include<stdio.h>可以提高编译速度
using namespace std;
int read()
{
	int re=0;
	char c=getchar();
	while((c>'9'||c<'0')&&c!='-')c=getchar();
	if(c=='-')
	{
		c=getchar();
		while(c>='0'&&c<='9')
		{
			re=(re<<1)+(re<<3)-'0'+c;
			c=getchar();
		}
		return -re;
	}
	else
	{
		while(c>='0'&&c<='9')
		{
			re=(re<<1)+(re<<3)-'0'+c;
			c=getchar();
		}
		return re;
	}
}
int m,n,ans;
int yhsj[30];
//杨辉三角压缩成一维前是70分，唯一区别在于生成顺序，求大佬评论解疑。
int main()
{
	n=read();
	m=read();
	yhsj[0]=1;
	for(int i=1;i<=m;++i)
		for(int j=i;j>0;--j)
			yhsj[j]=yhsj[j]+yhsj[j-1];
	for(int i=0;i<=m;++i)
		if((i<<1)%n==m%n)ans+=yhsj[i];//自动补0
//x和y关于m同余也可以写成|(x-y)|%n=0的形式并相应代码实现。
	printf("%d\n",ans);
	return 0;
}//结束，AC
```

杨辉三角已经被我按照写题解的习惯[降维打击](https://www.luogu.org/blog/by-StarCross/xiang-wei-da-ji)了，不懂的可以戳进去看。