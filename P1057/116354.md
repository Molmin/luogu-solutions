小蒟蒻第一次写题解，若有不当之处请大佬们帮忙指出，谢谢！

# 这是我人生中A的第一道动规题啊！！！


------------
OK，我们就废话不多说， 直接~~给大家解说一场赛马比赛~~来说说我的思路

首先，妥妥的，这是一道DP题

所以我们可以以第i次传球来划分阶段，那么我们先来建个模：

f[i][j] i表示此时进行了i次传球，j表示第j个人，f[i][j]表示第i次传球到第j个人手里的方案数。

那么接下来，我们可以看看，小蛮可以把球传给左右两边的人；

那么同理可得，一个人要得到球的话必须满足左右两边的任意一个人有球。

但是既然是求方案数，那么就直接累加了。

#### 那么状态转移方程如下：


 _f[i][j] = f[i - 1][j - 1] + f[i - 1][j + 1] _ 


------------

    
这时候，有一个很~~difficult~~ easy的问题出现了

### 这T滑稽是个环啊！

但实际上，我们做个判断不就好了（滑稽*3）

当j - 1为0时，自动转化为n;
当j + 1为大于n时，自动转化为1.

这样问题就愉快地解决啦！！


------------


还有最后说说初始化的问题

因为最开始球是在小蛮自己手上的，所以f[0][1]的值就是1了


------------


贴上AC代码
```cpp
#include <bits/stdc++.h>
#define MAXN 39
using namespace std;
int n, m, f[MAXN][MAXN];
int main()
{
	cin >> n >> m;
	f[0][1] = 1;
	for (int i = 1; i <= m; i++){
		for (int j = 1; j <= n; j++){
			int x = j + 1, y = j - 1;
			if (x > n) x = 1;
			if (y == 0) y = n;
			f[i][j] = f[i-1][x] + f[i-1][y];
		}
	}
	cout << f[m][1];
	return 0;
}
```
