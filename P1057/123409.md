**~~我又要来安利python辣！~~**

------------

[传送门](https://www.luogu.org/problem/P1057)


------------
本人一看n,m**数据范围**这么小！！！

本人再一看这题不是**矩阵快速幂**裸题吗？？？

本人仔细一看这题好像不要快速幂！！！

于是：本人用  **python3**  8行切了……


------------
## 正文：

### 1.矩阵的定义


>在数学中，矩阵（Matrix）是一个按照**长方阵列排列**的复数或实数集合，最早来自于方程组的系数及常数所构成的**方阵**。这一概念由19世纪英国数学家凯利首先提出。

个人理解，矩阵是**将相同长度的向量**进行**有序组合**而得到的数据结构。

一般来说，信息学中，与路径有关的矩阵，大多为方阵，即**行数=列数**的矩阵。


------------


### 2.矩阵的运算

n = 3时：


定义**方阵** $A_3$ =

$$
\left(
 \begin{matrix}
   3&7&1\\
   1&2&0 \\
   3&4&1
  \end{matrix} 
\right)
$$

**方阵** $B_3$ =

$$
\left(
 \begin{matrix}
   5&5&4\\
   0&1&0 \\
   2&7&2
  \end{matrix} 
\right)
$$

**方阵**$C$ = $A$ + $B$ = 

$$
\left(
 \begin{matrix}
   8&12&5\\
   1&3&0 \\
   5&11&3
  \end{matrix} 
\right)
$$


$C_ {i,j}$ = $A_ {i,j}$ + $B_ {i,j}$   



**方阵**$C$ = $A$ $\times$ $B$ （这里只讨论行列相同的矩阵）

$$
\left(
 \begin{matrix}
   17&29&14\\
   5&7&4 \\
   17&26&14
  \end{matrix} 
\right)
$$


$C_{i,j}$ = $\sum_{k=1}^n$ ( $A_{i,k}$ $\times$ $B_{k,j}$ )

即：C的第i行，第j列 = A中的第i行向量  $ \bullet $  B中的第j列向量


**方阵**幂运算 同实数的幂运算


------------

### 3.矩阵幂运算在路径问题中的作用

定义 **方阵**$A$ 为**邻接矩阵**：

$A_{i,j}$ 为 点$i$ 到 点$j$ 的 **路径边权**

有：$A_{i,j} $$^m$ 为从 点$i$ 走到 点$j$ 的 **权值和**$m$ 为的所有**路径总数**（并不是简单路径哦）


So，就有了 $\rightarrow$ 



```python

from numpy import *
n,m=map(int,input().split())
a=mat(zeros((n,n)))
for i in range(0,n-1):
  a[i,i+1]=a[i+1,i]=1
a[0,n-1]=a[n-1,0]=1
a=a**m
print(int(a[0,0]))
```





**逐行解释一下：**

导入numpy库（好像洛谷的**pypy3**没有这个库，**python3**有的）

输入以空格分隔的n,m

定义行列均为n的空矩阵

将 $[ i , n )$ 中的路径计入数组

加入n与1号点的路径

计算矩阵m次幂（**python3** 真**强）

输出始点到自身的路径数



------------
### 4.矩阵幂运算在路径问题中的原理

很简单啦，其实是个dp（记忆化搜索）；

邻接矩阵**自乘一次**，就是**做了一遍搜索**，遍历n个点，再从每个点遍历所有点（包括自己，因为有可能有自己连向自己的边），将结果存储下来。

由于这种dp**有交换律、结合律**，因此不需递推，可以使用快速幂这种算法进行优化。



------------

就写这么多吧，有不会的可以在评论里问呐。


















