##  传球游戏
传球游戏是一道标准的动态规划题目。动态规划这个东西嘛，初学都会感觉比较难（至少我这么认为）。看了一些别人的想法后，在尝试自己去列一些状态转移方程，会发现动态规划题目也是有章可循的。

接下来我们来分析这道题：

### 题目描述:
上体育课的时候，小蛮的老师经常带着同学们一起做游戏。这次，老师带着同学们一起做传球游戏。

游戏规则是这样的：n个同学站成一个圆圈，其中的一个同学手里拿着一个球，当老师吹哨子时开始传球，每个同学可以把球传给自己左右的两个同学中的一个（左右任意），当老师再次吹哨子时，传球停止，此时，拿着球没有传出去的那个同学就是败者，要给大家表演一个节目。

聪明的小蛮提出一个有趣的问题：有多少种不同的传球方法可以使得从小蛮手里开始传的球，传了m次以后，又回到小蛮手里。两种传球方法被视作不同的方法，当且仅当这两种方法中，接到球的同学按接球顺序组成的序列是不同的。比如有三个同学1号、2号、3号，并假设小蛮为1号，球传了3次回到小蛮手里的方式有1->2->3->1和1->3->2->1，共2种。

仔细分析，我们发现，对于每一位同学，他可能是由他的前一个同学以及他的后一位同学转移给他的。因此我们可以得到一个这样的状态转移方程：

我们设dp[i][j]表示传了i次传到第j个人的方案数为多少？我们让第一个人的编号为0（方便以后的处理环的问题）。那么最后的答案是传了n次后又回到0的方案数，即dp[n][0]。
#### 初始状态就是传了0次球，就在编号为0那里。dp[0][0]=1;
### 状态转移方程：
### dp[i][j]=dp[i-1][j-1]+dp[i-1][j+1];
当然上面这个式子是无环情况的，如果有环，我们只需要模上一个n就行了。
#### 转移方程如下：
### dp[i][j]=dp[i-1][(j+n-1)%n]+dp[i-1][(j+1)%n];
然后我们只需要for两边循环就能通过这道题啦！

代码非常之短：

AC代码如下：
```cpp
#include<cstdio>
#include<iostream>
using namespace std;
int dp[50][50];//dp[i][j]表示传了i次传到第j个人的方案数为多少？ 
int main()
{
	int n,m;
	cin>>n>>m;
	dp[0][0]=1;
	for(int i=1;i<=m;i++)
		for(int j=0;j<n;j++)
			dp[i][j]=dp[i-1][(j+n-1)%n]+dp[i-1][(j+1)%n];	
	cout<<dp[m][0]<<endl;
	return 0;
}
```
