解法：

分析整道题：

本题所求的是有多少种不同的传球方法可以使得从小蛮手里开始传的球，传了 m 次以后，又回到小蛮手里。

并且我们可以获得题面中的隐含条件：两种传球方法被视作不同的方法，当且仅当这两种方法中，接到球的同学按接球顺序组成的序列是不同的。

显然，这道题可以用DP来解决。

设一个二维数组f[x][y]代表传了y次后到达了x个人的方案数。设f[i][j]为当前的状态，那么上一个状态可以认为是f[i-1][j-1]或者是f[i+1][j-1]
为什么？

因为y代表次数，从上一个状态转移到这个状态代表次数+1，而这个球可以从左边或者右边的同学传过来，所以i-1代表一个方向，而i+1代表另一个方向
所有的状态转移方程为f[i][j]=f[i-1][j-1]+f[i+1][j-1];

但是这个题还没有结束。

先考虑第一个人，可以从第n个人转移过来，也可以从第二个人转移过来。f[1][i]是初始状态，代表第一个人传多少次的方案数，所以可得f[1][j]=f[2][j-1]+f[n][j-1];

再考虑一下第n个人。

同理，n可以从第一个人或者第n-1个人转移过来，那么代表f[n][j](传了i次到达第n个人的方案数)=f[n-1][j-1]+f[1][j-1];

本题就解完了！

外层变量为j，内层变量为i，因为有f[1]和f[n]需要特判。

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<cstring>
#include<string>
#include<map>
#include<set>
#include<queue>
#define INF 0x3f3f3f3f
#define inf 0x3f
#define ll long long
using namespace std;
int f[31][31],n,m;
int main(){//P1057重构代码
    cin>>n>>m;
    f[1][0]=1;
    for(int j=1;j<=m;j++){
        for(int i=2;i<=n-1;i++){
            f[i][j]=f[i-1][j-1]+f[i+1][j-1];
            f[1][j]=f[n][j-1]+f[2][j-1];
            f[n][j]=f[1][j-1]+f[n-1][j-1];
        }
    }
    cout<<f[1][m];
    return 0;
}
```