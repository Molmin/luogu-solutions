~~我偏不用DP!!!~~  
随机跳题居然是黄题被巨佬嘲笑, 我决定在此报复...  
回归正题, 首先, 回忆一下背得滚瓜烂熟的二项式定理, 在$n$次二项式中:
$$
T_{k+1}={n\choose k}
$$
$T_{k+1}$表示第$k+1$项的系数. $n\choose k$, 也记作$C_n^k$, 其定义为**在n件相互等价的物品中选出$k$件的方法种数**.  
我们把题目抽象化, 假设球向右传$k$次, 则其向左传$m-k$次, 球传回小蛮手中的方案数, 即是使得$[k-(m-k)]|n$的方案数. 怎么求呢? 我们引入[**母函数**](https://baike.baidu.com/item/%E6%AF%8D%E5%87%BD%E6%95%B0/4836270?fr=aladdin), 令:
$$
G(x)=(x+x^{-1})^n
$$
不要紧张哦, 接下来我们看看为何要如此定义:
$$
G(x)=(x+x^{-1})^n=(x+x^{-1})(x+x^{-1})...(x+x^{-1})
$$
把第$k$项因式$(x+x^{-1})$理解为传第$k$次球时的选择, 以$x$为向右传, $x^{-1}$为向左传. 这样的定义体现了**向左的$k$传球会与向右的$k$次传球抵消**. 即$x^kx^{-k}=1$. 接下来为方便表述, 定义一个取系数的函数$coe(f(x),x^k)$, 表示在函数$f(x)$的展开式中$x^k$的系数. 则本题的答案为:
$$
Ans=\sum_{|k|\le m,n|k}coe(G(x),x^k)
$$
这并不难理解, 式子所表达的是**左右传球抵消后, 球向左或右传了$|k|$次, 且$k$是$n$的整倍数的所有满足条件的$k$产生的方案总数**. $G(x)$是一个二项式, 这就回到二项式定理上啦! 我们展开$coe$函数, 得到:
$$
Ans=\sum_{|k|\le m,n|k}{m\choose \frac{m-k}2}[k\equiv m\,(mod\,2)]
$$
其实手玩一下就出来了~~不过大家都很懒~~. 跟着一个条件$k\equiv m\,(mod\,2)$是因为只有当此条件成立, $G(x)$中才有$x^k$项. ~~为什么? 手玩!~~  
由于$m$比较小, 先预处理杨辉三角, 再$O(m)$求答案就行了.
```cpp
#include <cstdio>

#define Int register int

int n, m;
long long C[35][35] = {};

inline void Prepare () { // 预处理杨辉三角.
	C[0][0] = 1;
	for ( Int i = 1; i <= 30; ++ i ) {
		C[i][0] = 1;
	}
	for ( Int i = 1; i <= 30; ++ i ) {
		for ( Int j = 1; j <= i; ++ j ) {
			C[i][j] = C[i - 1][j - 1] + C[i - 1][j];
		}
	}
}

inline void Work () { 
	Prepare ();
	scanf ( "%d %d", &n, &m );
	long long Ans = 0; // 记得long long.
	for ( Int i = 0; i <= m; ++ i ) { // 利用二项式系数的对称性(C(n,k)=C(n,n-k)), 只需要枚举k>0的情况
		if ( ! ( i % n ) && ( m & 1 ) == ( i & 1 ) ) {
			Ans += C[m][m - i >> 1];
		}
	}
	printf ( "%lld\n", ( Ans << 1 ) - ! ( m & 1 ) * C[m][m >> 1] ); // k=0会被重复算一次, 减去
}

int main () {
	Work ();
	return 0;
}
```
普及组干嘛那么友善, 如果答案模$p$, $m\le3\times10^5$, $O(m\log_2p)$照样$AC$.~~滑稽保命~~.  
众题解里似乎还没有这种~~优秀的~~算法呢! ( 说白了想放上层点儿.~~再次滑稽~~. )  
话说好像很多公式前台渲染不出来, 如果文中出现神奇的$markdown$语法就请@一下楼主吧!