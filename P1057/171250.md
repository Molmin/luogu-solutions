这道题的算法标签是动态规划和递推，然而我这个蒟蒻想到了一个新奇的数学方法，连函数都没用居然也能做出来，我自己都不敢相信，所以写了这篇题解。

**首先，我假设1传给2……N传给1的操作为1，反之为-1，则样例中的2种方法可表示为{1,1,1}、{-1，-1，-1}。由此，我们发现：（重点来了）**

## 一、将M次操作都设为1，将其中的i次操作改为-1（i为0到N的整数），全部操作的总和为M-2i；（废话）

## 二、如果操作的总和为N的整数倍，球就能回到小蛮手里。
（~~也不知道作者和小蛮什么关系，这么想捉弄小蛮~~）

**那么只要M、N、i满足|m-2i| mod N =0，球就能回到小蛮手里，与-1所在的位置无关。在M次操作中选择i次，共有(m(m-1)*……（m-i+1）/i!)种可能（根据组合公式），将所有可能累加起来就是最终答案。**

 _代码如下：_ 

------------

```cpp
#include<bits/stdc++.h>
using namespace std;
long long a,b,t=0,c,m,n;//之前没开longlong我WA了一半
int main()
{cin>>n>>m;
 for(int i=0;i<=m;i++)
   if(abs((m-2*i))%n==0) //判断方法是否正确
     {a=1;
	  b=1;//将a、b初始化，a储存i!，b储存m*(m-1)*…（m-i+1）
      for(int j=1;j<=i;j++) 
	    {c=__gcd(a,b);//为防止数据太大而进行约分（gcd是计算最大公因数的函数）
		 a=(a*j)/c;//计算i!
		 b=(b*(m-j+1))/c;//计算m*(m-1)*……（m-i+1）
        } 
      t+=b/a;//累加可能性（组合公式Cmi请自行脑补，我打不出来）
     }
 cout<<t;//输出
 return 0;
}
```