## 简单的底层优化(针对二维数组dp)
其他大佬已经把空间优化，矩阵方法解析得差不多了，这里我提出一个关于这道题最基本的二维数组dp的底层优化
```c++
//基本二维数组dp
num[0][0] = 1;
for (int j = 1;j <= m; ++j) {
    for (int i = 0;i <= n; ++i) {
        num[i][j] = num[(i + 1) % n][j - 1] + num[(i - 1 + n) % n][j - 1];
    }
}
//num[0][m]即为结果
```
由于内存的缓存机制，在访问二维数组时采用先列后行(即实际一维数组顺序访问)会使得Cache缺失发生的次数更少，从而避免更多的跳转到不同的Cache层的访问操作，使得效率更高

因此考虑转换循环下标顺序即可

```c++
//底层优化
num[0][0] = 1;
for (int j = 1;j <= m; ++j) {
    for (int i = 0;i <= n; ++i) {
        num[j][i] = num[j - 1][(i + 1) % n] + num[j - 1][(i - 1 + n) % n];
    }
}
//num[m][0] 即为结果
```

下面对simple dp和底层优化后的程序进行时间效率比较，如下表

| n规模(二维数组大小为n * n) | Simple Dp    | 底层优化  |
| -------------------------| ----------- | ---------- |
|                       1000 | 25.9 ms     | 11.682 ms  |
|                       2000 | 85.478 ms   | 27.753 ms  |
|                       5000 | 454.793 ms  | 164.317 ms |
|                      10000 | 1579.595 ms | 599.644 ms |

由此表可以看到，这种优化确实是有效的(并且随着规模增大而效果更好)