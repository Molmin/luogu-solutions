# 记忆化搜索
思路一：爆搜

	DFS函数内有两个参数
    一个是当前走到的地方
    另一个是当前的步数
    每一次层层升入就将地方+1或-1
    步数加一
    搜到步数上限检查是否回到小蛮的位置
    是就返回1，否则返回0
爆搜代码如下：
```cpp
#include <iostream>
using namespace std;
int n,m;
int dfs(int s/*位置*/,int c/*步数*/){
	if(c==m) return s==1?1:0;//当步数达到上限，在小蛮的坐标就返回1，否则返回0
	return dfs(s%n+1,c+1)+dfs(s!=1?s-1:n,c+1);//向左边和右边的搜
}
int main(){
	cin>>n>>m;
	cout<<dfs(1,0)<<endl;//起始在小蛮的位置，步数为0
	return 0;
}
```
提交后你会发现40分，TLE了六个点

我们需要考虑一下优化

	我们会发现当位置相同，步数相同的时候解都会一样
    每一步我们都把它当做一个临时的“起点”
    当起点相同，剩下步数一致就会得到同样的解
我们可以开一个二维数组f，一维记录位置，另一维记录步数

因此就得到了记忆化搜索的满分代码：
```cpp
#include <iostream>
#include <cstring>//memset库
using namespace std;
int f[31][31],n,m;
void dfs(int s/*位置*/,int c/*步数*/){
	f[s][c]=0;//记忆数组清零
	if(c==m&&s==1) f[s][c]=1;//搜到步数上限并且在小蛮的位置就让这个状况下的记忆数组置一，有一个解
	if(c!=m)//没搜到上限，可能会继续进行递归
	{
		if(f[s%n+1][c+1]==-1) dfs(s%n+1,c+1);//如果右边没有记忆，搜右边
		if(f[s!=1?s-1:n][c+1]==-1) dfs(s!=1?s-1:n,c+1);//如果左边没有记忆，搜左边
		f[s][c]=f[s%n+1][c+1]+f[s!=1?s-1:n][c+1];//将左右两边的解加起来就可以得到这里的解
	}
}
int main(){
	memset(f,-1,sizeof(f));//将f数组标记为-1，-1的意思是没有被记录
	cin>>n>>m;
	dfs(1,0);//起始在小蛮的位置，步数为0
	cout<<f[1][0]<<endl;//输出起始在小蛮的位置，步数为0的解数
	return 0;
}
```
	在考场上，如果一时找不出dp的动态转移方程
    请使用思维难度简单的记忆化搜索
    dp和记忆化搜索原理是差不多的，时空也差不多，只是代码量可能会略微多一些
    
    真开心呀，我一个PJ刷水题的蒟蒻ranking竟然达到了全咕第96名（2018-11-13）
    今天很开心，发了篇题解，希望能给过
    一个小目标：在luogu4的时候依然能保持高咕值，然后就有些权限了（