### 解题思路  
m 和 n 的范围都很小，主要的难点还是如何计算出最终的结果。每一次传球都是在上一次传球的位置上产生的，最终的结果是要计算出回到原点的方案数，所以 我们要建立 dp 数组，那么根据计算的目标，dp 数组中要保存的是某一次传球时，传到某个下标的位置上的方案数。求出递推公式还是比较容易的，由于传球只能向左或者向右传递，反之，球传到当前位置也只能是从左边传来或者从右边传来，同时球不能停在原地，所以递推公式如下：  
球传到当前位置的方案数 = 上一次球传到左侧位置的方案数 + 上一次球传到右侧位置的方案数  
传球游戏中涉及到两个维度，一个是传球的次数，一个是小朋友的位置，最容易想到的是创建一个二维数组： dp[33][33] ，第一维表示传球的次数，第二维表示位置。dp[i][j] 存储的是第 i 次传球后，球在第 j 个小朋友手中的方案数。用数组表示的递推公式如下：  
dp[i][j] = dp[i-1][j-1] + dp[i-1][j+1]  
题目中的小朋友是围成一圈的，也就是说数据存在环，环的处理并没有那么可怕，我们只需要对数组的头和尾做特殊处理即可。当 j 为 n 时，将 j+1 指向 1，当 j 为 1 时，j - 1 指向 n，此时我们可以封装一个函数，用来自动处理下标：  
```cpp  
int count(int i) {
    if(i == 0) return n;
    else if(i == n+1) return 1;
    else return i;
}  
```  
然后就结合函数写出完整代码：  
```cpp  
#include <bits/stdc++.h>
using namespace std;
int n,m,dp[33][33];
int count(int i) {
    if(i == 0) return n;
    else if(i == n+1) return 1;
    else return i;
}
int main()
{
    cin>>n>>m;
    //小蛮在位置 1，第一次传球传给左右两边的人。
    dp[1][n] =1,dp[1][2]=1;
    for(int i = 2;i<=m;i++) 
        for(int j = 1;j<=n;j++) 
            dp[i][j] = dp[i-1][count(j+1)]+dp[i-1][count(j-1)]; 
    cout<< dp[m][1];
    return 0;
}  
```  
这个代码已经很简单了，100 分到手。下面来讲讲如何压缩空间，通过观察递推公式，每一次传球都需要用到上一次传球的结果，所以空间至少可以压缩到 dp[2][n] ，保留上一次的完整结果，同时预留保存这一次传球结果的空间。我们再来看看能不能进一步压缩空间，由于递推公式包含左右两边的值，如果只用一个数组，计算 dp[i] 之后，原始的值已经被覆盖了，无法再继续计算 dp[i+1] 的值，不满足无后效性。使用 dp [2][n] 的压缩后的数组，解法如下：  
```cpp  
#include <bits/stdc++.h>
using namespace std;

int n,m,dp[2][33];

int count(int i) {
    if(i == 0) return n;
    else if(i == n+1) return 1;
    else return i;
}

int main()
{
    cin>>n>>m;
    dp[1][n] =1,dp[1][2]=1;
    for(int i = 2;i<=m;i++) {
        for(int j = 1;j<=n;j++) 
            dp[i%2][j] = dp[(i+1)%2][count(j+1)]+dp[(i+1)%2][count(j-1)];
    }
    cout<<dp[m%2][1];

    return 0;
}  
```  
这个题的解法是参与计算的两个数组，这一次通过 A 计算 B，下一次就用 B 计算 A，计算完之后输出最后一次计算的结果。