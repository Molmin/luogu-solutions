## 思路
求最小翻动次数，明显可以用贪心写法（其实模拟、dp 和其他很多算法也可以）。通过观察可得知，所有不同段长度的总和（第一个开始不同的硬币和第二个不同的硬币即为不同段）。

证明：很明显，一个硬币最多被翻转两次，再翻转多了翻转就必定无意义。不同段是一定要从开始不同时翻转，这会导致下一个位置的硬币也会翻转，但不同段中间的硬币是相同的，所以需要翻回来，然后重复之前的情况，到不同段最后一枚硬币才会停止。

虽然题目说了没有无解情况，但还是提一句，如果不同硬币的数量奇偶性不同，则无解。
## CODE
```cpp
#include<bits/stdc++.h>
using namespace std;
string a, b;
int ans, bg = -1, n;
int main(){
	cin >> a >> b;
	n = a.length();
	for(int i = 0; i < n; i++){
		if(a[i] != b[i]){
			if(bg == -1){//找第一个不同的硬币
				bg = i;
			}else{ 
				ans += (i - bg);//找到第二个不同的硬币
				bg = -1;//接着找下一个不同段 
			}
		}
	}
	cout << ans;
	return 0; 
}
```