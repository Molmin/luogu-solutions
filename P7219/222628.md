首先“所有矩形”这种条件应该想到笛卡尔树。

建出来后就 DP 吧。后效性在于放的点太高，可能让后面放不了点，因此设 $f_{x,i}$ 表示 $x$ 这一列放的点最高为 $i$ 的时候的答案，$i=n+1$ 时表示不放。

为了方便改一些定义：$a_i$ 表示黑色区域的大小；计算能保留最大价值的点。

转移：

1. 第 $x$ 列要放：记 $ml=\max_{i=a_x+1}^{n+1}f_{ls,i}$，$mr$ 同理，则有：
   $$
   \begin{aligned}f_{x,y}\gets\max(f_{x,y},ml+mr+c)\end{aligned}
   $$

2. 第 $x$ 列不放：
   $$
   \begin{aligned}f_{x,i}\gets\max(f_{x,i},f_{ls,i}+\max_{j=\max(i,a_x+1)}^{n+1}f_{rs,j},f_{rs,i}+\max_{j=\max(i,a_x+1)}^{n+1}f_{ls,j})\end{aligned}
   $$

第一个转移方程执行次数不超过 $m$，直接做就好，关键是第二个方程。

分析一下可以知道转移方程可以直接修改成：
$$
\begin{aligned}f_{x,i}\gets\max(f_{x,i},f_{ls,i}+mr,f_{rs,i}+ml)\end{aligned}
$$
这样的话就可以线段树合并优化了，操作是全局加，单点取 $\max$，询问区间 $\max$，合并。

另一种思路是直接考虑一个点的影响范围（就是选了这个点之后哪些列不能选点）。在前一种方法中我们把这一部分压到了状态里面。

不难发现一个点的影响范围是一条祖先后代链，这样的话，我们反过来，把点挂在对应链的顶端，这样就只需要一维状态了，转移方程更简单了，优化也更简单。