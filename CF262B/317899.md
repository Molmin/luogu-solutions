[这道题是我下午做的，你在源代码里的 Time 就会发现。是的，没错，不过晚上我还要打一场虚拟。](https://oi-master.github.io/post/codeforces-contest-262-b-ti-jie/)

貌似这道题洛谷没人写题解呀，我就把这个坑填上吧。

## 题面
### 英文题面
请去 [Codeforces](https://codeforces.com/contest/262/problem/B) 官网上看吧，我这里不做介绍
### 中文题面
一个人要统计他所在公司的总收入并且他想使总收入达到最大，收入写在一条清单上，总收入是清单上所有数之和。

他有 $m$ 次操作的机会，每次操作可以将某个数一个数变成其相反数，例如 $1$ 变成 $-1$ （注意，他必须严格执行 $m$ 次）问总收入最大是多少？（作弊啊，同志
## 思路
简单水题，瞬间秒杀！

这道题的确很水的好不好，可是弱弱的我就因为一个小错误 WA 了 $3$ 次，唉。

这道题由于是到简单题，所以我决定从微观开始讲。

首先是板子
```cpp
/* Generated by powerful Codeforces Tool
 * You can download the binary file in here https://github.com/xalanq/cf-tool
 * Author: OI_Master
 * Time: 2020-04-06 16:45:57
**/
#include<bits/stdc++.h>
using namespace std;
#define int long long
signed main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
```
呵呵呵，板子有点长，接下来是简单得不能再简单的输入。
```cpp
int n,m;
cin>>n>>m;
int a[n];
for(int i=0;i<n;++i)
	cin>>a[i];
```
这种题目，显然要排序。
```cpp
sort(a,a+n);
```
然后呢，我们就要详细地讲一下这一段。
```cpp
int j=0;
while(a[j]<0&&m>0){
	a[j]*=-1;
	--m;
	++j; 
}
if(a[j]==0)
	m=0;
```
怎么解释？我们先看 $j$ ，大家应该都知道 $j$ 是什么意思吧，就是说现在看到第几个了。你可能会问，为什么不用 $i$ ，因为我习惯把 $i$ 作为 `for` 循环的变量，如果定义 $i$ 的话，将会编译错误。当你看到完整代码的时候，你就会知道为什么要用 $j$ 而不用 $i$ 。

然后我们先不扯 $i$ 和 $j$ 的问题，就看中间这一段。如果你不会做这道题的话，我觉得对于这一段的问题还是挺大的。

我们大概能通过字面意思了解到，这一段话的作用就是把所有 $\leq 0$ 的数字中前 $k$ 小的挑出来（当然如果没有 $k$ 这么多就是全挑出来），乘上一个 $-1$ ，相当于负的变成正的。如果有多的，那么后面在应用于正数上。

那么后面的 `if` 语句又是怎么回事？其实，我们发现， $0$ 是一个神奇的数字，当我们搞到 $0$ 的时候，我们可以搞任意多次，把 $m$ 耗光，就不用搞到正数上面了，搞到正数上面可能还会起到副作用。

好，那么接下来，我们就要处理一下当 $m$ 还没用完的情况了。

还是上代码。
```cpp
sort(a,a+n);
if(m&1)
	a[0]*=-1;
```

首先，先排序。

然后，我们发现，当 $m$ 是偶数的时候，我们可以把 $m$ 用在一个数字上，会抵消，所以没用。

如果是奇数的话，我们又会发现，操作在最小的数字上最划算，而且操作完后相当于动一下（因为偶数就抵消了），所以就可以直接放心地把 $a_0$ 乘上 $-1$。
```cpp
    int sum=0;
    for(int i=0;i<n;++i)
	    sum+=a[i];
    cout<<sum<<endl;
    return 0;
}
```
~~这些有什么好看的~~
## 代码
我已经把所有的代码都展示出来了，大家自己拼吧（逃