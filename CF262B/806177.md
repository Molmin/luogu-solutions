# 题目大意：
题目链接：[洛谷链接](https://www.luogu.com.cn/problem/CF262B) && [CF链接](https://codeforces.com/problemset/problem/262/B)

本题意思很好理解：

一共有 $ n $ 个数，你一共有 $ k $ 次机会可以将这 $ n $ 个数中的一个数，改成它的相反数（也就是取反），求经过 $ k $ 次操作（必须经过 $ k $ 次操作）之后 $ n $ 个数的总和最大值是多少？
# 本题思路：
本题翻译中的数据范围写错了，应为：$ n \le 10^5 $。

当然，这不影响我们直接**模拟**。

首先，想要让这些数的总和最大化，取反时优先将那些负数取反。所以，在输入时，我们就进行判断，因为输入是按升序排列的，所以先就不用排序了。

若输入 $ a_i $ 为一个负数，就将它取反，并将 $ k $ 减一，把改变后的 $ a_i $ 的值记录在答案中。若做完 $ k $ 次操作后，就不用改了。

因为题目要求，必须经过 $ k $ 次操作，所以在输入判断完后，将数组排序，找到当前数组的最小值。接着判断剩下的 $ k $ 的奇偶性，若剩下的 $ k $ 为偶数，那答案就不用改变。若为奇数，那将当前答案减去当前数组最小值的两倍即可。

将答案输出就行了，详细解释请见代码。

~~这道题太水了！~~
# 代码来咯~
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,k,a[100005];
long long ans=0;
int main(){
	cin>>n>>k;
	for(int i=1;i<=n;i++){
		cin>>a[i];
		if(a[i]<0  &&  k>0)  a[i]=0-a[i],k--;//判断，取反
		ans+=a[i];//累加答案
	}
	sort(a+1,a+n+1);//排序
	if(k%2==0)  cout<<ans;
	else  cout<<ans-2*a[1];//判断奇偶性，输出
	return 0;
}
```