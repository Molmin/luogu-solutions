# 一道比较麻烦的模拟题

###### ~~一开始把"不一定互不相交"看成了"一定互不相交"害我之后的一些判断一直错误,害我改半天~~

#### 这一题$1≤n≤10,000,|x,y,S|≤1000,000,000$就是唬人的,最坏$O(n^2)$的算法都可以$90ms~~AC$,还有如果用long double转long long会变得非常诡异,用double就可以了

### 思路

- 确定每条线段(轨道可以看作线段)所在直线的方程(就是一次函数的图像),表示为$y=kx+b$并求出$k,b$值

- 确定第一滴水落到的线段

- 确定在线段上的水落到的下一个线段

- 如果没有下一个线段了,输出答案

### 做法

#### 一.得出每条线段所在直线的方程(其实就是要得出$y=kx+b$中$k,b$的值)

因为每一条线段都会给出两个点$x1,x2,y1,y2$,所以设它们所在的直线方程为$y=kx+b$

代入得

$
y1=k*x1+b ~~~~~  
$①

$
y2=k*x2+b ~~~~~$②

方程①-方程②得 $y1-y2=k*x1-k*x2$

所以 $y1-y2=k*(x1-x2)$

两边同时除以 $(x1-x2)$得

$k=\frac{y1-y2}{x1-x2}$

将$k$代入方程①得: $ y1=\frac{y1-y2}{x1-x2}*x1+b$

移项得 $ b=y1-\frac{y1-y2}{x1-x2}*x1$

所以只要存$k,b$ 的值每条线段所在的直线方程就都可以知道啦

#### 二.确定第一滴水滴到的线段与确定在线段上的水落到的下一个线段

题目说了"在轨道中不受任何影响"所以在线段上的水滴一定在线段的下端点下落,所以就知道了下落时的横纵坐标

确定上下方端点(用$x1,y1$存上方端点,$x2,y2$存下方端点)如果端点1($m1,n1$)与端点2($m2,n2$)中$n2>n1$那么端点2为上端点,小于就反过来

所以$x1=m2,y1=n2,x2=m1,y2=n1$,

为什么这两个放在一起讲呢,是因为他们其实都是已知横坐标$x1$求出将$x1$代入所以线段的直线方程得出纵坐标的最大值并记录线段号数(就是最先滴到的线段,但不能超过下落时的纵坐标,注意第一滴水没有下落的纵坐标,所以不需要判断这一点)

求纵坐标其实就是在$y=kx+b$中将$x1$代入$x$,所以纵坐标的值就是$k*x1+b$($k,b$已经求出来了)

#### 注意,因为是线段所以求出来的纵坐标不能超过线段上方端点的纵坐标也不能小于线段下方端点的纵坐标

#### 三.如果求出来的纵坐标都是不可以的说明没有下一个线段了,输出答案

代码

[代码开头define的用法](https://blog.csdn.net/u012611878/article/details/52534622)

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ld double
#define ll long long
#define y1 yy//下面三个如果的变量名是关键字不能用,所以define来代替一下
#define next nest 
#define search seas
struct xd//存储线段的信息
{
	ld x1,y1,x2,y2;//x1,y1上端点,x2,y2下端点,ld,ll型都可以
	ll next=-1;//在这条线段的水滴会滴到的下一条线段,初始化为-1
	ld b,xl;//xl为上文的k
}k[10001];
ll n,s,mc;//mc为第一滴谁会滴到的线段的号数
ld llp,mm=-1000000001;//mm为第一滴水滴落到的最大纵坐标,初始化为最小横坐标(表示还没有)
ld yc(int a,int b)//水滴从线段p的下端点滴到线段i线段的纵坐标
{
	ld l=(k[a].xl*(k[b].x2*1.0)+k[a].b);//计算纵坐标
	if(l>=k[a].y1||l<=k[a].y2||l>k[b].y2) return -1000000001;//不可以,返回一个很小
	return l;//返回
}
void search(ll p)
{
     ll h=-1000000000;//表示在线段p上的水滴滴落到的最大纵坐标,初始化为最小横坐标(表示还没有)
	for(int i=1;i<=n;i++)
		{
			ld l=yc(i,p);//水滴从线段p的下端点滴到线段i线段时的纵坐标,如果为-1000000001表示没滴到一定小于h
			if(l<=k[p].y2/*滴到的纵坐标一定要小于滴落的纵坐标,不然就是向上滴了*/&&l>h/*更优,因为大于h所以一定是滴到的*/&&i!=p/*不是滴到同一条线段*/)
			{
				k[p].next=i;//更新会滴到的下一条线段
				h=l;//更新最大纵坐标
			}
		}
		if(k[p].next==-1)//如果还是初始化的值表示还有下一个滴到的
		{
			cout<<k[p].x2;//所在线段的下端点横坐标就是最后的横坐标,输出
			exit(0);//结束整个程序
		}
		search(k[p].next);//如果有就到那一条线段
}
int main()
{
	cin>>n>>s;//输入
	for(int p=1;p<=n;p++)
	{
		ld x,xx,y,yy;//ld,ll型都可以
		cin>>x>>y>>xx>>yy;//输入端点坐标
		if(y<yy)//先默认第一对输入的端点坐标为上端点,如果不是(即第二对输入的是)就交换两对端点坐标
		{
			swap(x,xx);//swap为交换的函数,数组中也可以用它
			swap(y,yy);
		}
		k[p].x1=x;//上端点横坐标
		k[p].x2=xx;//下端点横坐标
		k[p].y1=y;//上端点纵坐标
		k[p].y2=yy;//下端点纵坐标
		ld xa,xb;//等一下在算式中用
		xa=y-yy;
		xb=x-xx;
		k[p].xl=xa/xb;//得出k
		k[p].b=y-x*k[p].xl*1.0;//得出b
	}
	for(int p=1;p<=n;p++)//确定第一滴水落到的线段
	{
		llp=k[p].xl*(s*1.0)+k[p].b;//滴到这条线段的纵坐标
	    if(llp>=k[p].y1||llp<=k[p].y2)/*可以加上continue*/;//因为是滴到线段上所以不能超过
	    else//因为第一滴 水没有下落纵坐标,不用判断其它的了
	    {
	    	if(llp>mm)//更优
	    	{
	    		mm=llp;//更新最大纵坐标
	    		mc=p;//记录最先滴到的线段号数
	    	}
	    }
	}
	search(mc);//从这条线段开始
	return 0;
}
```








