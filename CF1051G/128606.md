小清新数据结构题。

假设操作后的 $a$ 序列变为 $a^\prime$ 序列，则等价于要最小化 $\sum (a_i^\prime-a_i)\times b_i=\sum a^\prime_ib_i-\sum a_ib_i$。

第二项是定值，记 $S=\sum a^\prime_ib_i$，我们就要最小化 $S$。

关注到对于一个关于 $a$ 的值域连续段，我们可以任意重排其中的元素顺序，并且这个值域段最终对应区间 $[\min\{a\},\min\{a\}+cnt-1]$。

这样做一次可能会再合并若干值域连续段，我们认为一直做到无法再合并后，在同一段内的 $a$ 是值域连续的。

对应区间是显然的，重排顺序的话，考虑两个元素 $x$ 和 $x+1$，顺次用操作 $2$、操作 $1$ 即可将其交换。

因此要尽量让 $b_i$ 大的分配在靠前的位置。换而言之，对于一个 $(a_i,b_i)$，其最后的 $a^\prime_i$ 为 $w+rank_{b_i}-1$。$w$ 为其对应值域段的最小值，$rank_{b_i}$ 表示 $b_i$ 在这个段内是第几大的。

稍微展开一下式子：$\sum (w+rk_{b_i}-1)b_i=(w-1)\sum b+\sum b_i\times rk_{b_i}$。

$w$ 与 $\sum b$ 是好维护的，边插入边更新即可。接下来处理 $rk$ 的问题。

考虑每插入一个数时，会发生三种情况。

1. 新建一个颜色段。
2. 并入某个颜色段。
3. 合并两个颜色段。

对于第一类，直接新建颜色段更新 $S$ 即可。

对于第二类，考虑其所在的颜色段，我们将其的 $a$ 变为该段最大值 $+1$，转化为第一类加第三类。

然后是第三类。

关注到 $n$ 只有 $2\times 10^5$，所以我们可以回收掉数较少的那侧的线段树，然后将那些数暴力插入另一段。

实际上就是把启发式合并搬到了序列上，复杂度 $O(n\log^2n)$ 可过。

考虑优雅一些的线段树合并。

首先还是把新加入的数随便并到两侧颜色段之一，然后专心搞合并。

一种做法是类似分治的思想统计新增贡献，合并中走到两棵树的同一位置节点 $x,y$ 时，统计 $rs_x$ 对 $ls_y$、$rs_y$ 对 $ls_x$ 的贡献。

以 $p=rs_x,q=ls_y$ 为例，$p$ 中每个元素都会使得 $q$ 中的所有元素排名加一，因此 $p$ 对 $q$ 的贡献就是 $cnt_p\times sum_q$。

而子树元素个数、元素和都是权值线段树里维护的东西，直接处理即可。

另一种是先完成底层合并，然后 `pushup` 一路更新答案。本质上还是统计右子树对左子树的贡献。与上一种情况类似，就不展开了。

然后判断第二、三类是否发生，只需要判断 $a_i$ 和插入后 $a_i$ 所在位置相邻两点的状态，并查集维护即可。

复杂度 $O(n\log n)$。[record](https://codeforces.com/contest/1051/submission/206084428)。
