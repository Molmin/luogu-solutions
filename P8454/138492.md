标题其实是这样的，但是太长了写不下：  
>零★点☆讨★论　离☆线★问☆询  
哈☆希★离☆散　数★组☆重★排  
后★缀☆修★改　区☆间★最☆值  
细☆节★塞☆爆　耐★力☆考★验  
３★Ｋ☆代★码　邀☆您★来☆爽

[题目描述](https://www.luogu.com.cn/problem/P8454)[ ](https://vdse.bdstatic.com//192d9a98d782d9c74c96f09db9378d93.mp4)[link ](https://www.luogu.com.cn/problem/P8454)

我们先不管毒瘤的收益计算和全局修改，出一道简化版的题：
>给定一个长为 $n$ 的整数序列，$q$ 次询问合法的最大子段和。  
合法的定义是`喜欢的题`至少选一道并且`不喜欢的题`一道都不选。  
数据范围：$\max{\{n,q\}}\le10^5$，每次询问的`喜欢的题`和`不喜欢的题`加起来最多 $5$ 道。

显然喜欢的题目互不干扰，可以一道一道处理。

对于每个喜欢的题目 $p$，包含它的一个子段一定能表示成 “$1\sim p$ 的一个后缀 $\cup$ $p+1\sim n$ 的一个前缀”的形式；而由于合法子段不能包含不喜欢的题，这个后缀和前缀的边界其实是离此题最接近的不喜欢的题的编号。

于是我们现在的问题是动态问询区间前 / 后缀最大和。一个简单的发现是区间和可以表示成前缀和的差；而由于左 / 右端点固定，我们要求的是另一端点的区间最值。可以使用线段树、ST 表等数据结构维护。

我们引入单点修改，则依然可以使用带标记线段树轻松解决。

现在的问题是序列的全局修改难以处理。我们来观察一下原题的收益计算方式：$\text{\color{white}{这段方程是用 exlg 贺来的，fx 白丝 lg /qiang}}$

$$
\begin{cases}
inc&|x_i-w|\leq b_1\\
0&b_1<|x_i-w|\leq b_2\\
dec&|x_i-w|>b_2\\
\end{cases}
$$

显然每个元素的收益最多只有 $3$ 种取值；事实上，在固定 $x_i$ 的情况下，可以将所有 $w$ 的取值划分成 $5$ 个连续区间，使得每个区间内最终的收益计算值相同。

对于每个 $x_i$ 都画出这 $5$ 个区间可以得到下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/naj7ehum.png)

于是我们有一个美好的幻想：如果 $w$ 的修改是单调的，我们可以直接将区间分界点排序双游标修改，最终最多 $4n$ 次单点修改！这事 ao 的！！1

不难发现本题没有强制在线，于是可以将问询与前驱修改绑定然后按 $w$ 赠序处理。美梦成真！

>目前思维难度：下位绿  
实际代码难度：上位蓝  
分析结果：没有恶评 :/

是的，实现的时候还有很多细节要考虑。（注意不是易错点，而是一些“我大概知道这里要干啥，但是好难写啊”的地方）

1. 如何把问询和修改绑定？  
你可以开一个结构体代表，然后向邻接表里插入，这样w也顺便桶排好了。但这样会带来第二个问题：
2. 值域太大了 vector 开不下怎么办？  
~~摆烂拿部分分~~ 离散化就行。
3. 离散化要先全部存下来，代码好长……  
你可以一边读入一边把没出现过的插入哈希表，然后再按照实际值构造置换。

还有就是易错点比如：
- 用于维护前缀和的线段树忘记开 0 的下标位置，以及初始化值写错。
- 忘 pushdown/up，最大最小值写错等线段树板子错误。
- 区间分界点没考虑开闭乱写导致修改位置错误。
- 不知道 `dec` 是 ambiguous 的，开了全局变量，被编译器坑惨。（CE\*114514）

[３★Ｋ☆代★码](https://www.luogu.com.cn/paste/vvdcgti4)[ ](https://vdse.bdstatic.com//192d9a98d782d9c74c96f09db9378d93.mp4)[link](https://www.luogu.com.cn/paste/vvdcgti4)

[剪贴板](https://www.luogu.com.cn/paste/p5ln1eir)[ ](https://vdse.bdstatic.com//192d9a98d782d9c74c96f09db9378d93.mp4)[备份](https://www.luogu.com.cn/paste/p5ln1eir)