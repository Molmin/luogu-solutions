# 模拟退火

## \>1.1

先不提模拟退火，我们来理解爬山算法，已经知晓的可以调至1.2

如果我们有一个函数$ f(x) $，已知其在定义域上有且仅有一个单调递增和单调递减区间，为了求$ f(x) $的近似极值，我们可以采用爬山算法。感性理解，你有如下的函数：

![Figure 1](https://s2.ax1x.com/2020/01/19/1Cdqwn.png)

肉眼可见，$ f(x) $的极值在区间6~8中。为了求得大致的极值，显而易见，我们可以二分。不过我们在此处讲的是爬山，因此先将二分撂一边去

爬山算法在(比如说)4这个位置出发，向x轴负半轴方向和x轴正半轴方向试探，发现正半轴要小一些，又因为单调区间仅有1个，因此，我们选择向右半轴方向走。(具体走多少需要求导以确定大致，这里大概感觉一下)越陡，一次就走的越多。

###### ~~小声bb~~:其实对机器学习有所了解的话，可以发现这就是梯度下降。当然，是更简单的梯度下降。

这样就算大致的理解了爬山算法，实现并不困难，不做额外阐释。

## \>1.2
模拟退火可以说做特殊的爬山，针对于$ f(x) $的单调区间很多的时候。但有时候也得不到正确答案，~~毕竟过于玄学~~。

举个例子：

![Figure 2](https://s2.ax1x.com/2020/01/19/1CdzSU.png)

很明显，一般的爬山算法很容易卡在**局部最优解**上。举个例子，它在0附近找到了一个“最值”，向左、右走都发现要更大一点，最后就停在了这里。但很明显，我们肉眼可见，0附近不是最值的所在位置。

因此我们会需要一个算法，它在移动时不仅仅因为这种“倾斜关系”(想不出更好的词了，请模糊理解一下)来决定怎么移动，还根据一些其他关系。

什么是“其他关系”呢？也就是加入随机的因素。

实际上，在正常使用时随机化的表现效果并不是很好。为了解决这一点，我们引入“温度”这种说法，也是“退火”的来源。

>引用自百度百科：(实际上感觉说的不是很好，不想看这个引用的话就pass好了)

>模拟退火的原理也和金属退火的原理近似：将热力学的理论套用到统计学上，将搜寻空间内每一点想像成空气内的分子；分子的能量，就是它本身的动能；而搜寻空间内的每一点，也像空气分子一样带有“能量”，以表示该点对命题的合适程度。演算法先以搜寻空间内一个任意点作起始：每一步先选择一个“邻居”，然后再计算从现有位置到达“邻居”的概率。


为了帮助你更好理解，现在想象你正在打铁，铁的温度正逐步下降。这块铁中的某一分子正从活跃变为稳定，我们把该分子的稳定过程映射为一条在x轴上移动的点，随着温度逐渐降低，点的移动由剧烈趋向平缓，最终停下来。在该点移动的过程中，做出一条垂直于x轴且经过该点的直线，该直线与 $y = f(x)$ 交于一点，对应着我们的y值。

现在，模拟退火结合上爬山以及退火两个操作，成功(有时也不成功)地达到我们的目标：极值。

## \>1.3

在你理解了这两个操作后，看到右侧的图，这是刚才Figure 2在-1~1上的图像。现在感受一下模拟退火的过程，从-0.5出发，向任意两侧走…到(甚至还没到)局部最优解上，然后突然一跳，跳到了另一侧…最后近似的求得了极值。

![Figure 3](https://s2.ax1x.com/2020/01/19/1CwmlD.png)

现在，给出模拟退火的代码。

```cpp
void SA(){//即模拟退火
	register int ans, ……;//ans是当前解
	while (T *= delta_T, T >= …){//T是温度，delta_T是降温速率
		if (……)…rand()…//通常我们会rand一次做一个“假设操作”
		……//这里是一些附加内容，通常简单的模拟退火不需要
		if (ans = work(), ans < otp)otp = ans;
/*SA一般搭配一个work函数使用，可以感性认为是求出当前的y值；otp是当前最优解，也就是运行完毕后被输出的解*/
		else if (exp((long double)ans - otp)/T > (long double)rand()/0x7fff)……
		/*先说这一步的作用，充当随机化操作。其中，
exp是 ⅇ^x(e^x)；0x7fff是rand的上界。
按照我的习惯，该步一般表示以一定概率不接受本次操作，即上面的 if (……)…rand()… */
	}
}
```

## \>1.4
大致就是这样，现在对本题做简短的思路讲解。

考虑最初随机生成一串序列表示将要建城堡的城市，用$Dijkstra$跑个最短路来作为$work$函数的主要部分，以最大距离表示y值。$if (……)…rand()…$步骤随机交换两个城市(一个建了的和没建的，因此 附加内容 部分要判定是否为一个有一个无以及已经有城堡不能不建造的。实际上实现时前两个都无需注意，对答案影响不大，只须注意最后一个即可)，一个建造城堡，另一个取消建造城堡。

```cpp
void SA(){
	register int ans, x, y;//选出城堡x、y
//	DEBUG//调试步骤
	while (T *= delta_T, T >= 1e-9){
		if (x = rand()%n, y = rand()%n, castle[x] == castle[y] || SP_sign[x] || SP_sign[y])x = rand()%n, y = rand()%n;//特判第一次，x不能和y相同，且不能是已有城堡的城市
		if (castle[x] == castle[y] || SP_sign[x] || SP_sign[y])continue;
//如果上述特判后的新x、y仍不满足，则直接降温
		swap(castle[x], castle[y]);
		if (ans = work(), ans < otp)otp = ans;//ans优于otp，更新otp
		else if (__builtin_exp((long double)ans - otp)/T > (long double)rand()/0x7fff)swap(castle[x], castle[y]);
		//不接受此次调换
//		var_DEBUG(ans, otp);//调试步骤
	}
}
```

讲解完毕。