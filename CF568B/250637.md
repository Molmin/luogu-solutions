我觉得生成函数+poly不优美=.=

---

首先我们观察这个所谓“关系”的形式，看到对称性和传递性，我们立马可以想到这玩意等价于把 $n$ 个数（**选取一部分**）划分成若干集合，然后这个所谓“关系”就等价于两个数在同一个集合里……其实挺憨的。

那个不具备自反性相当于是说，不能所有数都被选取出来划分掉了，必须剩一部分（称之为“剩余集合”）。我们不难想到，这剩的一部分和其他集合区别不大，但隐约（这里我说不清楚，但可以感知到把它当成一个正常集合是做不了的，比如说把它和另外一个集合交换一下得到的最终方案不同）还是需要考虑的。其他的集合就完全一致了。

接下来显然就可以动态规划了。

我们定义 $cnt_{i,j}$ 表示对于 $i$ 个数，有**至多** $j$ 个属于“剩余集合”。显然，只需要考虑 $j\le i$ 的情况。答案就是 $cnt_{n,n}-cnt_{n,0}$。

然后开始考虑转移。

对于 $j>0$，把贡献分为两类：属于“剩余集合”的数恰好 $j$ 个，和至多 $j-1$ 个。后者就是 $cnt_{i,j-1}$。前者的话，给 $i$ 个数中标号（对就是题目里那个标号，但具体是多少实际上没有影响）最小的属于“剩余集合”的数给提出来扔掉，会发现它的贡献就是 $cnt_{i-1,j-1}$。这个一一对应是显然的，因为当知道 $i$ 个数的标号和扔掉之后 $i-1$ 个数的标号后能唯一确定被扔掉的数是几。

所以有方程 $cnt_{i,j}=cnt_{i,j-1}+cnt_{i-1,j-1}$。

对于 $j=0$，如果 $i=0$ 那么答案就是 $1$，很显然。如果 $i\ge1$，我们会发现上面枚举出一个“剩余集合”中的数那一套就失效了，必须另辟蹊径。我们不妨“枚举”最后一个数所在集合（实际上不用真的“枚举”），从这个集合中把最后一个数删掉。我们此时惊奇地发现，由于最后需要多加入一个数，**此时这个集合的地位已经和其他集合不对等了**。更棒的是，此时**它的地位和“剩余集合”对等了，而真正的“剩余集合”，由于在这 $i$ 个数中大小为 $0$，可以先不用考虑了。换而言之，我们可以直接在 $cnt_{i-1,i-1}$ 的所有方案中，直接把“剩余集合”换掉，把它降成一个普通集合，然后往里面插入最后一个数，“剩余集合”自己却空了。**（整个一一对应可以严谨说明）。

所以有方程 $cnt_{i,j}=cnt_{i-1,i-1}$。

根据以上两个方程和 $cnt_{0,0}=1$ 的初始条件，就可以很方便地动态规划了。代码就不管了，随便写写。

---

以下为番外。

当然，我们会观察到我们对这个动态规划数组可以滚掉一维，然后在转移对这个一维的数组只用干三件事：

1. 循环位移；

2. 累前缀和；

3. 取模。

于是我们就可以写出一个画风极其诡异的玩意……

```cpp
#include <bits/stdc++.h>
#pragma GCC optimize(2)
#define int long long
using namespace std;
constexpr int mod = 1e9 + 7, N = 4009;
int n, cnt[N];
signed main() {
  cin >> n, cnt[0] = 1;
  for (int i = 1, tmp; i <= n; ++i) {
    tmp = cnt[i - 1], memmove(cnt + 1, cnt, i * sizeof(int));
    cnt[0] = tmp, partial_sum(cnt, cnt + i + 1, cnt);
    transform(cnt, cnt + i + 1, cnt, bind2nd(modulus<int>(), mod));
  }
  cout << (cnt[n] - cnt[0] + mod) % mod << endl;
  return 0;
}
```

目前是在谷上最优解第一位，估计很快就要被踢下去了。

以上。
