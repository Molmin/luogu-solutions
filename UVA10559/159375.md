[消除方块 传送门](https://www.luogu.com.cn/problem/UVA10559 "消除方块 传送门")

~~看了看题解区好像没有这样的解法？~~
## 分析



------------

### 状态（重点）

这是一种比较懒癌的解法。(也比较详细

首先来说说看状态， $f_{i,j,k} $ 表示 $[i, j]$ 范围消除完之后，剩余k个颜色为 $color_{i}$ 的最大分数。

~~（大佬看到这应该已经懂了， 这题主要是设状态，后面可以跳过直接代码~~
 
比如 $f_{i,j,0}$ 表示把 $[i, j]$ 完全消除（啥都不剩）的最大分数。


------------

### 转移分析
那么问题来了我们为什么要怎么设呢？

想想看对于每一个块我们只有两种操作， 

一种单独消掉。

一种是和其他块组合起来消掉：比如 $12221$ , 我们可以把 $222$ 消掉，然后让11组合起来。

对，也就是说，当我们要把两个块组合起来时， 一定要把他们之间的所有块先消除， 例如把i, k组合起来，要先把$[i+1, k-1]$这个区间消除掉， 得到分数是 $f_{l+1, k-1, 0}$ 

当我们计算 $f_{i, j, k}$ 时， 假设i是新放进去的块（$[i+1, j]$ 已经计算好了）。

直接消掉i显然为 $1+f_{i+1, j, 0}$ , 进一步考虑组合：

我们枚举 $[i+1, j]$ 中每一个为 $color_{i}$ 的块 $k$，

我们考虑在 $[k, j]$ 中选择若干个块与i合并  分数为 $f_{k,j,x}$ (剩余 $x$ 个用来合并)$[i+1, k-1]$ 直接消掉 $f_{i+1, k-1, 0}$
枚举这个 $x$，ok
（这个地方需要仔细思考）

复杂度 $O(n^4)$


------------


实在不行看看代码？

## 代码
```cpp
for(int i=1; i<=n; i++){
	f[i][i][1] = 0;//直接把这个块保留，不需要消除，所以分数为0 
	f[i][i][0] = 1;//直接消除这一个块, 分数1 
}
for(int j=2; j<=n; j++){
	for(int i=1; i+j-1<=n; i++){
		int l=i, r=i+j-1;
		f[l][r][0] = f[l+1][r][0] + 1;//直接消除i 
		f[l][r][1] = f[l+1][r][0];//直接保留i 

		for(int st=l+1; st<=r; st++){
			if(color[st] != color[l]) continue;//枚举上面的“x” 
			for(int k=1; k<n; k++){//注意边界 
				f[l][r][k+1] = max(f[l][r][k+1], f[l+1][st-1][0] + f[st][r][k]);
				//从st-r中取k个与i合并， 一共k+1个 
				f[l][r][0] = max(f[l][r][0], f[l][r][k+1] + (k+1)*(k+1));
				//考虑把k+1个直接消除， 更新最大分数 
			} 
		}
	}
}
```
