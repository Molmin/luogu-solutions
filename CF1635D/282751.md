提供一种自己折腾自己的做法。过于折腾以至于赛时没有写对，下大分了。

首先 $2^p$ 很明显提示了要向二进制考虑，不难发现 $2x+1$ 就是在二进制末尾添加一个 $1$，$4y$ 是在末尾添加两个 $0$。问题就是问二进制位数小于 $p$ 有多少个数字。

这里都还挺正常，接下来就很神必了。

首先有个很蠢的 DP，设 $dp_i$ 表示集合中二进制位数为 $i$ 的数的数量。

不考虑加多的情况转移方程就是 $dp_i=dp_{i-1}+dp_{i-2}+cnt_i$，$cnt_i$ 表示 $a_i$ 中二进制位数为 $i$ 的数的数量。

但是这样会算重。 因为有一些 $a_i$ 可以通过末尾添加表示出其它 $a_i$。这个东西就会重。

怎么判断 $a_i$ 能否通过其它 $a_i$ 表示？首先一定是 $a_i$ 的一个前缀，然后剩下的部分还得能用 $00$ 和 $1$ 表示出来。不难想到预处理每个 $a_i$ 的每个后缀是否可以表示出来，这个很简单，然后 trie 树上查前缀。算出可以表示 $a_i$ 的数量 $d_i$ ，那么 $dp_i=dp_{i-1}+dp_{i-2}+cnt_i-d_i$ 即可。真的是这样吗？

又算少了！因为每个 $dp_i$ 都是去过重的，但是加的是没去重的 $d_i$（赛时栽在这里）。每个 $a_i$ 至多被多算两次（$dp_{i-1}$ 和 $dp_{i-2}$），所以只需要知道 $a_i>>1$ 和 $a_i>>2$ 是否能被表示出来（还是用前面的方法）以及后一位和后两位是否可以表示出来就可以算了，最终答案就是 $\sum\limits_{i=1}^{p-1} dp_i$ 。

[代码](https://codeforces.com/contest/1635/submission/147148555)见 CF 提交。
