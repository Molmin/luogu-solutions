## 题目解读
从字符串 $S$ 中按顺序挑出一些字符组成字符串，并且要使得该字符串为 $T$ 的前缀。
## 算法分析
我们可以从前往后扫描字符串 $S$ 与字符串 $T$。  
如果当前两个扫描位置的字符相同，则代表字符串 $T$ 当前位置的字符被 $S$ 包含，将长度增加 $1$，将两个字符串的扫描位置都向后移动一位。  
如果对应位置的字符不相同，那么继续扫描 $S$ 后面是否包含 $T$ 当前位置的字符，即将 $S$ 的扫描位置向后移动一位。    

在实现的时候，我们可以使用两个指针 $i$ 与 $j$，分别对应当前扫描到的 $S$ 的位置与 $T$ 的位置。  
如果 $s_i=t_j$，那么将答案 $+1$，并且 $i$ 与 $j$ 都 $+1$。  
如果 $s_i \ne t_j$，则将 $i+1$，向后继续匹配。  
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
string s,t;
int lens,lent,ans;//lens为字符串s的长度，lent为字符串t的长度。
int main(){
	cin>>s>>t;
	int i=0,j=0;
	lens=s.size();
	lent=t.size();
	while(i<lens&&j<lent){
		if(s[i]==t[j]){//当前位置字符相等
			i++,j++,ans++;//两个扫描位置向后推移一位并且将答案+1
		}
		else{
			i++;//将s的扫描位置向后推移一位
		}
	}
	cout<<ans<<endl;
	return 0;
} 
```