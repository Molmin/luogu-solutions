> 给定一棵树，$q$ 次询问，每次给出 $L_i,R_i$，求：
> $$\sum_{j=1}^n\min(d(j,L_i),d(j,R_i))$$
> $1\leq n,q\leq 2\times10^5$

对于一次询问，每个数的贡献都是到 $L_i$ 或到 $R_i$ 的距离，可以通过 $L_i\to R_i$ 路径上的中点将 $1\sim n$ 分成两个集合，分别是离 $L$ 较近和离 $R$ 较近的，这样就将 $\min$ 转换掉了。

记 $F(x,y)$ 表示 $x$ 子树内的所有点到 $y$ 的距离和。然后分讨，假设 $L$ 离 $\text{LCA}(L_i,R_i)$ 远，$p$ 表示中点。

> $p$ 的计算方式是 $L$ 的 $\lfloor\frac{dis(L,R)-1}{2}\rfloor$ 级祖先，这里 $-1$ 是因为避免中点为 $\text{LCA}$ 导致的特殊情况。也就是说，我们可以保证 $p$ 不在 $R$ 子树内，$L$ 在 $p$ 子树内。

则有 $ans_i=F(p,L_i)+F(1,R_i)-F(p,R_i)$，离线下来，考虑如何求多组 $F(x,y)$。

- $y$ 在子树 $x$ 外：记 $f_x$ 表示子树 $x$ 内每个点到 $x$ 的距离之和，答案即为 $dis(x,y)\times siz_x+f_x$。

- $y$ 在子树 $x$ 内：一开始想复杂了，在 dfs 回溯过程中用线段树维护子树加等等，码了一百五六十行。其实有简单方法的，记 $g_x$ 表示整棵树每个点到 $x$ 的距离之和，$f_x,g_x$ 可以两遍 dfs 换根 dp 求出，然后加加减减就好了。

  具体的，$g_y=g_{x}+n-2siz_y$，答案为 $g_y-(g_x-f_x)-dis(x,y)\times(n-siz_x)$.

想对了思路的话，[代码](https://atcoder.jp/contests/abc298/submissions/40808171)写起来还是比较舒适的。