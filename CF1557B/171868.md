# CF1557B Moamen and k-subarrays

## 题面

给你一个长度为 $n (1≤n≤10^5)$  的整数序列 $a (0≤|a_i|≤10^9)$ ，现在你要讲这个序列分为 $k(1≤k≤10^5)$ 个非空子阵列，然后对这 $k$ 个非空子阵列从小到大进行排序，排序后进行合并，得到一个新的整数序列，并使这个新的整数序列成为非降序的有序序列。

现在询问是否有一种方法是否有一种方法可以使用上面写的操作按非降序对数组进行排序，有方法输出 **Yes** ,没有输出 **No**。

T 组数据 $(1≤t≤10^3)$ 。

## 分析

显然，使这个新的整数序列成为非降序的有序序列就是把 $a$ 序列从小到大排序，而排序后仍然挨在一起并前后顺序不变 $(a_{i-1}\leq a_i-1)$ 的数就是在一个子数组。

例如：$[1,5,4,2,3]$ 排序后是 $[1,2,3,4,5]$ 。$[2,3]$ 满足条件我们就把序列划分为 $ \{ [1],[5],[4],[2,3] \}$

而当划分块数 $≤k$ 时是 Yes，$>k$ 时是 No 。

那我们如何知道划分块数呢，我们只需在建一个数组 $b$ ，令 $b_i=i$ ，然后用数组 $a$ 对数组 $b$ 进行排序，最后 $O(n)$ 扫一遍数组 $b$ 如果 $b_{i-1}+1≠b_i$ 划分块数就 $+1$。

## 代码

```
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+5;
int a[N],b[N];
int T,n,k;
bool cmp(int x,int y){
	return a[x]<a[y];
}
int main(){
	cin>>T;
	while(T--){
		int ans=1;//初始化要为1
		cin>>n>>k;
		for(int i=1;i<=n;i++){
			cin>>a[i];
			b[i]=i;
		}
		sort(b+1,b+n+1,cmp);
		for(int i=2;i<=n;i++)
			if(b[i-1]+1!=b[i])
				ans++;
		if(ans<=k)
			cout<<"Yes\n";
		else
			cout<<"No\n";
	}
	
	return 0;
}
```

