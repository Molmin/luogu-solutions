“组合意义天地灭”。

看见大家求还上删点写的都是动态规划，那我就来天地灭一下。我觉得这一题组合做法比较巧妙，码量也大幅度降低。

做法学习于[这篇题解](https://www.cnblogs.com/ak-dream/p/AK_Dream123.html)。

我们可以尝试求一下对于 $k={1,2,…,n}$，我们只看 $k$ 个条件，都没被满足的残存排列 $r'$ 的个数 $f_{k}$（注意 $r'$ 是指 $n$ 中选出 $k$ 个不同的数后进行排列）。并且我们在将一个 $r'$ 对应成 $r$ 时，假设 $r'$ 对于条件 $i_1,i_2,…,i_k$ 不满足，那么 $r'$ 就对应着 $r_{i_1},r_{i_2},…,r_{i_k}$。由于剩下的 $n-k$ 个数有 $(n-k)!$ 种排法，由容斥原理，最后的答案就是

$$\sum\limits_{k=0}\limits^n (-1)^kf_k(n-k)!$$

然后我们发现，只要求出 $f_k$ 就可以啦。

那么怎么求这个 $f_k$ 呢？

我们只要考虑 $k$ 个数就行了，先指定 $k$ 个不满足的条件是 $i_1,i_2,…,i_k$。我们凭空变出 $n$ 个标号为 $1,2,…,n$ 的点，将所有 $p_{i_j}$ 与 $q_{i_j}$ 相连，得到一个由 $n$ 个点，$k$ 条边组成的图。容易知道，这个图的度数最大为 $2$。所以它一定由链、环（自环）组成。

对于这样的一张图，对 $f_k$ 的贡献是多少呢？我们将连接 $p_{i_j}$ 和 $q_{i_j}$ 的边作为 $r_{i_j}$，也就是 $r'_j$。然后由于 $r'$ 必须不满足这 $k$ 个条件，所以 $r'_j$ 必须等于 $p_{i_j}$ 和 $q_{i_j}$ 二者之一。

所以总贡献就是任选 $i_1,i_2,…,i_k$ 对应的边，然后在这 $k$ 条边上标上端点上的数之一，并且所有标的数都不一样的方法数。

现在换一个思路。我们令 $k=n$，将所有 $p_i$ 和 $q_i$ 相连。此时，图上所有点的度数都是 $2$，所以整个图是由一个一个的环（自环）组成的。

我们假设已经处理了若干个环，这些环一共有 $s$ 个点，然后又出现一个新的环，这个环上有 $c$ 个点。

假设我们处理完 $s$ 个点之后的是 $f$，处理完 $s+c$ 个点之后的数组是 $g$，然后直接滚动数组。

如果 $c=1$，也就是这是一个自环，那么对于 $s+c$ 个点的那些环，可以不选这个自环，也就是 $f_j$，也可以选这一个自环上的唯一一条边，并且无论之前怎么选，能且只能标上这个自环上唯一一个点的编号，也就是 $f_{j-1}$。所以转移方程是（刷表法）

$$g_j=f_j+f_{j-1}$$

如果 $c>1$，也就是这是一个货真价实的环，那么我们枚举，在原本 $s$ 条边中选 $j$ 条边，在新的 $c$ 条边中选 $k$ 条边并且按照规则标上数的方案数。由于原本的 $s$ 条边和新的 $c$ 条边在不同的环上，所以这两玩意互不干扰，可以将选边并标号的方法数相乘。原本的 $s$ 条边中选出 $j$ 条边并标号的方法数是 $f_j$，那么问题就转换成了要在一个 $c$ 条边的环上选择 $k$ 条边并进行标号。

针对这个组合问题，我们先将一条边 $(u,v)$ 拆成两条边 $(u,w)$ 和 $(w,v)$。

在原问题中，选择了边 $(u,v)$ 并且标上 $u$，就对应在新的环中选择边 $(u,w)$；选择了边 $(u,v)$ 并且标上 $v$，就对应在新的环中选择边 $(w,v)$。

那么问题就转换成给你一个有 $2c$ 条边的环中选择两两不相邻的 $k$ 条边。

可以分类讨论。在环上编号最小的点设为 $a$，其逆时针的第一个点是 $b$。

①不选择 $(a,b)$，那么我们要在剩下的 $2c$ 个点，$2c-1$ 条边的链中选出 $k$ 条不相邻的边。那么我们可以看做是先从 $2c-k$ 个点中选出 $k$ 个右端点，再将 $k$ 个左端点按顺序插在它们前面。所以是 $C_{2c-k}^k$。

②选择 $(a,b)$，那么与它相邻的两条边都不能选，那么我们要在剩下的 $2c-2$ 个点，$2c-3$ 条边的链中选出 $k-1$ 条不相邻的边。所以是 $C_{2c-2-(k-1)}^{k-1}=C_{2c-k-1}^{k-1}$。

所以转移方程就是（填表法）

$$g_{j+k}=g_{j+k}+f_j\times \big(C_{2c-k}^k+C_{2c-k-1}^{k-1}\big)$$

那么这道题就做完了，时间复杂度是 $O(\sum c^2)$，最坏情况下是 $O(n^2)$。

代码不长，轻度压行。

```cpp
#include<bits/stdc++.h>
#define D(x,y) for(ll x=y;~x;x--)
#define U(x,y) for(ll x=1;x<=y;x++)
using namespace std;
typedef long long ll;
const ll M=1000000007,_=6010;
ll n,m,p[_],q[_],r[_],f[_],g[_],v[_],c,s,A;
inline ll C(ll x,ll y){return x<0||y<0||x<y?0:p[x]*q[x-y]%M*q[y]%M;}
int main(){
	cin>>n;m=n*2+1;p[0]=q[m]=f[0]=1;
	U(i,n)cin>>p[i];
	U(i,n)cin>>r[p[i]];
	U(i,m)p[i]=p[i-1]*i%M;
	for(ll i=M-2,j=p[m];i;i>>=1,j=j*j%M)
		if(i&1)q[m]=q[m]*j%M;
	D(i,m-1)q[i]=q[i+1]*(i+1)%M; 
	U(i,n)if(!v[i]){
		for(ll j=i;!v[j];j=r[j])c++,v[j]=1;
		if(c==1)for(ll j=s+1;j;j--)f[j]=(f[j]+f[j-1])%M;
		else{
			memset(g,0,_*4);
			D(j,s)D(k,c)g[j+k]=(g[j+k]+f[j]*(C(2*c-k,k)+C(2*c-k-1,k-1)))%M;
			memcpy(f,g,_*4);
		}
		s+=c;c=0;
	}
	D(i,n)A=i&1?(A-p[n-i]*f[i]%M+M)%M:(A+p[n-i]*f[i])%M;
	cout<<A<<'\n';
	return 0;
}
```
