## 前置芝士

**反悔贪心**是一种十分有用的算法，适合于在处理一些贪心处理问题时，若无法得到贪心的正确性，那么反悔贪心是一个不错的选择。

反悔贪心的核心就是在贪心时加入一些特定的值，使得你在贪心处理下一个点时可以直接使用处理普通点的方法处理这个特殊的点使得可以得到更优的答案。

具体的方法因题而异，具体方案在题目中会讲。

## 思路分享

我们首先可以考虑，我们可以贪心地对于每一天 $i$，如果我们可以卖出，那么贪心的选择之前的价格最小的一天 $j$，然后若 $p_j<p_i$，则就可以在 $j$ 天买入一股，然后在第 $i$ 天卖出，这时候就仅需要一个 $priority\_queue$ 就可以了。

但是还有一个问题，如何考虑下面这组数据呢？

`1 2 3`

可以发现，若贪心处理，则仅会在第 $1$ 天买入一股，并在第 $2$ 天卖出，赚到了 $1$ 元。但是若将第 $1$ 天的股票在第 $3$ 天卖出，则可以获得高达 $2$ 元的利润，~~是原答案的足足两倍！~~

所以这时候我们就可以请出我们的主角：反悔贪心。

可以考虑，对于 $i,j,k \in \left[ 1,n \right],i<j<k$ 且 $p_i<p_j<p_k$，这个贪心就会认为 $i$ 买 $j$ 卖，对答案的贡献为 $\boxed{p_j-p_i}$ 。而正确答案却是 $i$ 买 $k$ 卖，对答案贡献为 $\boxed{p_k-p_i}$ 。那么我们可以考虑，若我们在已经考虑完 $i$ 买 $j$ 卖，再来考虑 $i$ 买 $k$ 卖，在考虑答案时，贡献就为 $\boxed{p_k-p_i-p_j+p_i=p_k-p_j}$，即可以看作先 $i$ 买 $j$ 卖，再 $j$ 买 $k$ 卖，就可以处理了。

但是还有一个点需要注意，就是当我们反悔完一次之后，我们还需要加入一次当前的数，因为这个数转完一次之后是还可以买卖的，因为事实上这一天是没有进行过任何一次买卖的，所以需要多加入一次我们的堆。

题目到这里就没有别的问题了。

## 代码展示

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
const ll maxn=300100;
ll n,ans;
priority_queue<ll,vector<int>,greater<int> >q;//一个堆
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		ll x;
		scanf("%lld",&x);
		if(!q.empty()&&x>q.top()){
			ans+=x-q.top();
			q.pop();
			q.push(x);
            //需要多加入一次。
		}
		q.push(x);
	}
	printf("%lld",ans);
	return 0;
}

```
