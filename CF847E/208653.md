提供一种实现和思路都比较简洁的想法。

考虑对于答案，思考是否具有单调性，如果有单调性可以考虑进行二分答案。

~~我是从 dp 专题那里骗来的，如果有神仙有 nb dp 做法还请告诉我一声。~~

试想一下，如果我们确定了这个答案，我们是不是已经把一个人给限制住了。

可以比较贪心的去思考，对于每一个人，他肯定是先把左边的吃掉，然后再去吃右边的。

这个想法挺显然吧，因为考虑后面一个人，它吃右边的肯定会更优秀一些，吃左边则会多出一些不必要的贡献。

那我们贪心策略就非常明显了，就是一个人左边如果有东西就去吃左边的，然后再折回来吃右边的。

可是，现实真的是这样最优么？

然而并不全是，试想一下，如果一个包装在左边，离这个人非常非常非常远，而右边的则非常近，那我们还是先吃左边的么？

答案是否定的，我们肯定先把右边的给吃掉。

所以得出一种结论，虽然他一定要把左边的给吃掉，但是**他并不一定要先吃左边的**。

严格证明我还是不太明白，所以大致给各位简单的不严格证明一下。

这部分吃右边可以吃到哪里用二分来维护是两只 $\log$，用双指针来维护是一只 $\log$。

哦对，开头和各位说代码是非常简洁明了的。

放代码：

```cpp
int solve(int x,int y,int z) {
	return min(y-x+z-x,z-y+z-x);
}
// x<y<z 并且 y 是人的情况，分类取最小。
// 即先走到 x 和先走到 z 的区别。
bool check(int xx) {
	L=1;
	for (int i=1;i<=n;i++) {
		if (s1[i]!='P') continue;
		if (L>a[0]) return true;// 当前已经吃完了。
		if (i-a[L]>xx) return false;// 当前吃不到左边的，那右边的也吃不到。
		int la=a[L];
		if (i<la) {// 如果左边的没有东西可以吃。
			while (L<=a[0] && a[L]-i<=xx) L++;
			continue;
		}
		while (L<=a[0] && a[L]<=i) L++;// 把到的了的左边全都算进贡献里面。
		while (L<=a[0] && solve(la,i,a[L])<=xx) L++;
		
    }
	return L>a[0];
}
signed main()
{
	ios::sync_with_stdio(false);
	cin>>n>>s1;s1=" "+s1;
	for (int i=1;i<=n;i++) 
		if (s1[i]=='*') a[++a[0]]=i;
	int l=0,r=1e9,ans=-1;// 答案的上界是 2*n，可能不到，开 1e9 保险。
	while (l<=r) {
		int Mid=(l+r)>>1;
		if (check(Mid)) r=(ans=Mid)-1;
		else l=Mid+1;
	}
	cout<<ans<<"\n";
	return 0;
}
```

感谢阅读。