设 $c_i$ 为第 $i$ 次操作的实际代价，$t_i$ 为第 $i$ 次操作后数据结构的势，我们有

$$c_i+(t_i-t_{i-1})=k_i$$

$(t_i-t_{i-1})$ 为该次操作后势变化的量，$k_i$ 应为一个恒定的容易计算的值。

所以

$$\sum_{i=1}^n (c_i+(t_i-t_{i-1}))=\sum_{i=1}^nk_i$$

得

$$\sum_{i=1}^n c_i=\sum_{i=1}^nk_i-t_n+t_0$$

---

斜堆（skew heap）是一种简易的可并堆。

对于小根堆，合并时，比较两堆的根，将权值小的根作为新堆的根，将另一个堆与新堆的右子树合并，然后交换新堆的左右子树。

定义：

若一个节点的右子树大小不小于以该节点为根的子树大小的一半，则称这个节点为重节点，否则为轻节点。定义斜堆的势为该斜堆中重节点的个数。

容易发现，合并两个斜堆相当于把两个堆从根到最右节点的路径合并后作为新堆的从根到最左节点的路径。那么时间复杂度为两个堆极右路径的和。

设 $h_1,l_1,h_2,l_2$ 分别为第一个堆的极右路径上重节点的个数，第一个堆的极右路径上轻节点的个数，第二个堆的极右路径上重节点的个数，第二个堆的极右路径上轻节点的个数。$c=h_1+l_1+h_2+l_2$。

发现，一个重节点合并后必然变成轻节点。因为我们要分析最坏情况下的摊还时间复杂度，所以我们令势的变化最大，即所有轻节点变为重节点，也即 $t_i-t_{i-1}=-h_1+l_1-h_2+l_2$，那么 $k_i=c+(t_i-t_{i-1})=2(l_1+l_2)$。

我们将证明 $l_1+l_2=O(\log n)$。显然有每个轻节点的右子树小于以该节点为根的子树大小的一半，所以每次子树规模至少缩减一半，故而为 $O(\log n)$。

代入势能分析的式子可得

$$\sum_{i=1}^n c_i=n\log n-t_n+t_0$$

根据定义，我们知道 $t_n=O(n)$，$t_0=0$，所以总时间摊还复杂度为 $O(n\log n)$。

[封装模板](https://www.luogu.com.cn/paste/ve4sq3mb)（可以通过 P2713）

以上。