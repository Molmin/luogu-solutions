今天挺好的，不用日自己。
自己推导做了一题。

题目如下（p2424）：
题目描述

对于一个数X，函数f(X)表示X所有约数的和。例如：f(6)=1+2+3+6=12。对于一个X，Smart可以很快的算出f(X)。现在的问题是，给定两个正整数X,Y(X<Y)，Smart希望尽快地算出f(X)+f(X+1)+……+f(Y)的值，你能帮助Smart算出这个值吗？
输入输出格式
输入格式：

输入文件仅一行，两个正整数X和Y（X<Y），表示需要计算f(X)+f(X+1)+……+f(Y)。

输出格式：

输出只有一行，为f(X)+f(X+1)+……+f(Y)的值。


------------

乍看麻烦，实际上我们解这题的代码量很少，只是需要深刻理解其中的推导过程。

对于单个数求约数和的方法如下：

最易想到的方法就是我们只需挨个模（模为零就加上）。
在此基础上可以做优化：在这个数开方的范围里模，模为零就除一下，商和除数都加上，这样时间复杂度也可以开方。

这是在计算机能大量计算的基础上我们可以不怕麻烦的做法。
那么我们是否可以用数学语言表达约数和？

这里引入定理：算数基本定理（也叫唯一分解定理）。

算术基本定理可表述为：任何一个大于1的自然数 N,如果N不为质数，那么N可以唯一分解成有限个质数的乘积N=P1^a1\*P2^a2\*P3^a3\*......Pn^an，这里P1<P2<P3......<Pn均为质数，其中指数ai是正整数。
那么对于一个数的约数和，是否可以用该定理的表达方式表达？

可以由**数学归纳法**得到这个数的约数和：
S=(1+P1^1+P1^2+...+P1^a1)\*(1+P2^1+P2^2+...+P2^a2)\*...(1+Pn^1+Pn^2+...+Pn^an)

该式中从每个括号中提出一项相乘即为该数的一个约数。



------------
~~但是知道这个好像也没有什么卵用~~

------------

~~没关系，涨知识了。~~

本题的切入点在于"X,X+1,X+2...Y"这个区间的数的约数和怎么求。
这个区间能让我联想到前缀和的模板,即用\[1,Y]区间减去\[1,X-1]区间即可
而事实上,直接求\[1,n]区间的所有数的约数和的和也更容易---

我们又回到了最开始的方法,但只不过这回是逐个除去约数(设为k)(即\[1,n]包含了多少个k的倍数那么就有多少次k出现)然后将商和约数相乘加到和里即可.

如何优化?

当然和之前也很相似.

举个例子: 对于n=1000


| 除数 | 1 | 2 | 3 | ... | 32（=>sqrt(1000）+1） |
| -----------: | -----------: | -----------: | -----------: | -----------: | -----------: |
|商  | 1000 | 500 | 333 | ... ...| 31 |
| 除以区间中的整数 |-----| \(500,1000] |(333,500]  | ... ...| (31,32] |
| 商 |-----| 1 | 2 | ... ...| 31 |

于是我们只需要把计算次数降至logn次了.

但是究竟最后一个除数该是多少呢? sqrt(n)?sqrt(n)+1?

如果按照我的表格的计算方式,我们需要在sqrt(n)\*(sqrt(n)+1)<n 时加上最后一项,除到前者就够了.

如下代码

------------


```cpp
//约数和
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<cstring>
#include<cmath>
using namespace std;
long long x,y;
long long f(long long n)
{
	long long k=(long long)sqrt(n),ans=0;
	long long j=0;		
	long long d=0;
	
	for(long long i=1;i<=k;i++)
	{
		d=n/i;
		ans+=(d*i);
		ans+=(i-1)*((j-d)*(j+d+1))/2;
		j=d;
	}
	if(k*(k+1)<n) ans+=(k+1)*(n/(k+1));
	return ans;							//-(k+1)*d;
}
int main ()
{
	scanf("%lld%lld",&x,&y);
	printf("%lld",f(y)-f(x-1));
}

// 123				321
// 12  11  10		18	17 	16
// 10  11  12		17  18  20 
```
