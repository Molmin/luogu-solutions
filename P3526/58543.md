作为一个  kmp  构造黑题，代码虽然很短，但它的证明却是特别复杂，先膜  Itst 

**请注意任何一个border对应一个周期**

这里先列举有关  border  的定理：

 Weak Periodicity Lemma ：如果有一个字符串 $ s $ ，有周期： $ p $ 和 $ q $ ，且 $ p+q \leq |s| $ ，那么 $ gcd(p,q) $ 也是它的周期，（周期的定义是：对于一个周期 $p$ ，字符串的所有的字符 $s(i)$ 满足： $s(i)=s(i+p)$ ）

___
**证明：**

不妨让 $ p>q $ 

对于任意一个字符 $s(i)(i \in [0,|s|-1]) $ ，因为$p+q \leq |s|$,所以 $i-p \geq 0$ 和 $i+q<|s|$ 必有一个满足

如果 $i-p \geq 0,s(i-p)=s(i-p+q)$

同理，也证明出 $i+q<|s|$ 的情况。 

所以 $p-q$ 也是字符串 $s$ 的周期。 

不断更损相减，求出 $gcd(p,q)$ 也是字符串的一个周期。 

___
假设 $ Solve(x) $ 代表，构造一个 $ 01 $ 串满足字典序最小，且满足前 $ x $ 个字符的周期与该 $ 01 $ 串的周期一样。 

不妨分类讨论：

* 如果这个字符串没有border，那么如果长度为一，构造一个 $ [0] $ 串，否则构造一个 $ [0,0,0,...,1] $ 串即可

* ②这个字符串有最长 $ border:len $ ，且 $ 2len>|x| $ 

* ③这个字符串有最长 $ border:len $ ，且 $ 2len \leq |x| $ 
___
对于②，我们可以把图画出来：

![](https://cdn.luogu.com.cn/upload/image_hosting/pjgkf3lc.png)

看得出来 $ AB $ 与 $ CD $ 相等， $ B=C $ ，这个时候不妨先 $ Solve(|AB|) $ 

求出 $ AB $ 的最小情况，这个时候就可以转移了， $ D $ 串等于 $ AB $ 串的后面 $ |D| $ 个就可以了，这样子，肯定满足了 $ border $ 相等，但是，这一定是字典序最小的吗？

想一想还真是，首先根据定义， $ AB $ 是字典序最小的，你要是说 $ D $ 可以更小，但此时 $ D $ 串小了， $ AB=CD $ ，所以 $ |AB| $ 最后面长 $ |D| $ 的字符串还能更小，这和 $ AB $ 是字典序最小的有矛盾。 
___
这个时候就要开始讨论伟大③情况了： 

首先这个情况一定是 $ s=tat $ 的一种形式， $ |t| $ 为最大 $ border $ 。 

我们会想到字典序最小，说明 $ a $ 最好是一个 $ [0,0,0...,0] $ 串，但是这可能会导致一个更大的 $ border:l $ 产生，与我们此时 $ |t| $ 是最大的 $ border $ 矛盾。 

这个时候我们分类讨论 $ l $ 的情况，然后把 $ a $ 进行调整，避免更大的 $ border:l $ 产生：

 $ 1. $  如果 $ l \leq |t|+|a| $ 

![](https://cdn.luogu.com.cn/upload/image_hosting/3z9v7ilh.png)

所以捏，只要把 $ a[0,0,0...0] $ 变成 $ [0,0,0,...,0,0,1] $ 就可以扼杀这个可恶的 $ l $ 了。 

 $ 2. $  如果 $ l>|t|+|a| $ 

假设这个 $ l $ 是最大的 $ border $ ，但又不是整个字符串，那么这个字符串的最短周期是 $ 2|t|+|a|-l $ ，而 $ |t|+|a| $ 也是字符串的一个周期，那么 $ |t|+|a| $ 整除 $ 2|t|+a-l $ 。 

如果 $ 2|t|+|a|-l \leq |a| $ ，那么说明这个字符串是全 $ 0 $ 串；而在 $ 2|t|+|a|-l>|a| $ 的情况，因为 $ |t|+|a| $ 整除 $ 2|t|+a-l $ ，所以我们就有：

![](https://cdn.luogu.com.cn/upload/image_hosting/qxgwpjqo.png)

蓝色是 $ t $ 串，红色是 $ a $ 串( $ tat $ 嘛！)，不如把图中最后一个周期的 $ a $ 的的剩余部分称为 $ b $ ，而每个周期都是 $ ba $ 的形式，所以 $ t $ 串可以表示为一个 $ baba...babab $ 的形式，易知这个 $ b $ 串不是全 $ 0 $ 的。 

不如把 $ tat $ 中间的 $ a[0,0,0...0] $ 变成 $ a'[0,0,0,...,0,0,1] $ 。 

最终 $ tat $ 是一个 $ baba...bab\ a'\ baba...bab $ 串，这个时候我们觉得应该没有更长的 $ border:l'(l'>|t|) $ 了吧，我们不知道，所以用反证法，假设这个时候存在一个 $ border:l'(l'>|t|) $ 。 

 $ 2.1 $  如果 $ l'<|t|+|a'| $ ，我们再用一次 $ 1. $ 中的循环等于： 

![](https://cdn.luogu.com.cn/upload/image_hosting/0s9iapuu.png)

上面的字符串就是 $ tat $ 

这样子不断类推得到左边的那个 $ l' $ 是全 $ 0 $ 串。 

但是你发现了吗？右边的 $ l' $ 不是全0串。 

- “所以呐，不成立。”  myj  摇摇手指说道。 

 $ 2.2 $  如果 $ l' \geq |t|+|a'| $ ，上图： 
 
![](https://cdn.luogu.com.cn/upload/image_hosting/8npw0qlx.png)

右边的 $ l' $ 中的 $ a' $ 应该会在左边 $ l' $ 的长度为 $ |a'| $ 的字符串对应，而这个对应的肯定不是左边 $ l' $ 的 $ a' $ ，而且 $ a' $ 最后一个字母不在 $ a $ 和 $ a' $ 里面。

同时我们应该知道这个 $ a' $ 是在 $ ta't $ 中前面的 $ t $ 中对应。 

  myj  摇摇手指说：“这个时候我们最爱的分类讨论来了。”

所以我们知道 $ a' $ 最后一个字母在左边对应的地方在一个 $ b $ 里，设是 $ b $ 的第 $ i $ 个字母。 

 $ 2.2.1 $  如果 $ i<|a'| $ 

那么说 $ a' $ 有一段前缀会在 $ a $ 里面对应，而且我们发现这个 $ a' $ 后面是 $ babab..bab $ ，也就是说 $ a' $ 最后一个字母对应了 $ b_i $ ，而这个以 $ b_{i+1} $ 字母的后缀会和 $ b $ 的前缀匹配，是不是很像 $ border $ 的定义，是的，就是。 

所以 $ b $ 有一个 $ border $ ，长度为 $ |b|-i $ 。 

而这个 $ border $ 就是 $ 000..01 $ 。 

之前那个[ $ b $ 的前缀]的最后的 $ i $ 个字母会和 $ a $ 对应，而b最后这个数字就是 $ 1 $ 。 

图片：
 
![](https://cdn.luogu.com.cn/upload/image_hosting/hwmx1gai.png)

（最下面的 $ ...a'b... $ 代表的是右边的 $ l' $ ）

可以看到 $ b $ 最后一个字母 $ 1 $ 会在 $ a $ 中，这不可能。 

 $ 2.2.2 $  如果 $ i=|a'| $ 

和 $ 2.2.1 $ 基本类似，但是如果：
 
![](https://cdn.luogu.com.cn/upload/image_hosting/8npw0qlx.png)

这个右边的 $ l' $ 是以 $ a' $ 开头。 

![](https://cdn.luogu.com.cn/upload/image_hosting/7yqny645.png)

我们还是这样对应，看到，又矛盾了。 

 $ 2.2.3 $  如果 $ i>|a'| $ 

![](https://cdn.luogu.com.cn/upload/image_hosting/tly9dcy8.png)

（下面的是右边的 $ l' $ ）

不妨假设对应 $ a' $ 的 $ b $ 前面还有 $ a $ （没有 $ a $ 的情况类似）。 

假设 $ b_1 $ 到 $ a' $ 前端这一段为 $ c $ ，可以看得出来 $ ca' $ 是 $ b $ 的一个周期。 

![](https://cdn.luogu.com.cn/upload/image_hosting/zxgcyh5a.png)

设 $ d $ 是 $ b $ 的后 $ i $ 个字母组成的串，可以看到 $ d $ 应该是把前面的 $ ca' $ 前面一段，搬到 $ a' $ 右边的蓝色段。 

![](https://cdn.luogu.com.cn/upload/image_hosting/w6p83piz.png)

然后把a'前 $ i $ 个字符组成的字符串称为 $ d' $ ，可以看出 $ d' $ 是b的后缀，且d'是恰好等于 $ ac $ 的（长度为 $ i $ ）。 

你看： $ ac $ 是 $ b $ 的后缀， $ ca' $ 也是 $ b $ 的后缀，然而 $ ac $ 中的 $ 1 $ 的个数和 $ ca' $ 中的1的个数不一样啊。 

所以这个情况不可能。 

___

所以我们要是 $[0,0,0...,0]$ 没有问题就把 $a$ 变成它。 

否则变成 $ [0,0,0...,0,0,1]$ 就不会创造新的 border 。 

结论简单，但是证明很难啊！
