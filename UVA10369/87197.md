#### 题面：
北极的某区域共有 n 座村庄，每座村庄的坐标用一对整数 (x,y) 表示。为了加强联系，决定在村庄之间建立通讯网络。通讯工具可以是无线电收发机，也可以是卫星设备。所有的村庄都可以拥有一部无线电收发机， 且所有的无线电收发机型号相同。但卫星设备数量有限，只能给一部分村庄配备卫星设备。

不同型号的无线电收发机有一个不同的参数 d，两座村庄之间的距离如果不超过 d 就可以用该型号的无线电收发机直接通讯，d 值越大的型号价格越贵。拥有卫星设备的两座村庄无论相距多远都可以直接通讯。

现在有 k 台卫星设备，请你编一个程序，计算出应该如何分配这 k 台卫星设备，才能使所拥有的无线电收发机的 d 值最小，并保证每两座村庄之间都可以直接或间接地通讯。

例如，对于下面三座村庄：

![](https://cdn.luogu.com.cn/upload/pic/65088.png)

其中 |AB|=10,|BC|=20,|AC|=10√5≈22.36
如果没有任何卫星设备或只有 1 台卫星设备 (k=0 或 k=1)，则满足条件的最小的 d=20，因为 A 和 B，B 和 C 可以用无线电直接通讯；而 A 和 C 可以用 B 中转实现间接通讯 (即消息从 A 传到 B，再从 B 传到 C)；

如果有 2 台卫星设备 (k=2)，则可以把这两台设备分别分配给 B 和 C ，这样最小的 d 可取 10，因为 A 和 B 之间可以用无线电直接通讯；B 和 C 之间可以用卫星直接通讯；A 和 C 可以用 B 中转实现间接通讯。

如果有 3 台卫星设备，则 A,B,C 两两之间都可以直接用卫星通讯，最小的 d 可取 0。

~~上面来自某爆零一本通~~

### 其实这么一大堆题面只是告诉我们：求一张图，求这张图的最小生成树，去掉K条最长边，剩下的第K+1长的边. 
  
 #### 做法：
当正向思考受阻时，逆向思维可能有奇效。本题就是这样。知道卫星设备的数量，求最小的收发距离，可能比较困难；

但如果知道距离求数量，就很简单了。把所有可以互相通讯的村庄连接起来，构成一个图。卫星设备的台数就是图的连通支的个数。

   问题转化为：找到一个最小的d，使得把所有权值大于d的边去掉之后，连通支的个数小于等于k。

   先看一个定理。定理2：如果去掉所有权值大于d的边后，最小生成树被分割成为k个连通支，图也被分割成为k个连通支。

####    证明：

用反证法。假设原图被分割成k’ (k'≠k)个连通支，显然不可能k’>k，所以k’<k。因此在某一图的连通支中，最小生成树被分成了至少两部分，不妨设其为T1,T2。因为T1和T2同属于一个连通支，所以一定存在x∈T1，y∈T2，w(x,y)≤d。又因为在整个最小生成树中，所以x到y的路径中一定存在一条权值大于d的边(u,v)（否则x和y就不会分属于T1和T2了），w(x,y)≤d<w(u,v)，所以把(x,y)加入，把(u,v)去掉，将得到一棵总权值比最小生成树还小的生成树。这显然是不可能的。所以，原命题成立。（证毕）

   有了这个定理，很容易得到一个构造算法：最小生成树的第k长边就是问题的解。

   首先，d取最小生成树中第k长的边是可行的。如果d取第k长的边，我们将去掉最小生成树中前k-1长的边，最小生成树将被分割成为k部分。由定理2，原图也将分割成为k部分。（可行性）

   其次，如果d比最小生成树中第k长的边小的话，最小生成树至少被分割成为k+1部分，原图也至少被分割成为k+1部分。与题意不符。（最优性）

   综上所述，最小生成树中第k长的边是使得连通支个数≤k的最小的d，即问题的解
   
   
 下面不哆嗦了，贴代码（我相信各位大佬都不需要代码）：
 
 ```
#include<iostream>
#include<cmath>
#include<algorithm>
#include<cstdio>

using namespace std;

int n,T,k,m,f[505],cnt;
double x[505],y[505],ans[505*505];
struct node
{
	int x,y; 
	double d;	
}p[505*505];

double dist(double x1,double y1,double x2,double y2)
{
	return sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2));
}

bool cmp(node a,node b)
{
	return a.d<b.d;
}

int getf(int x)
{
	return x==f[x]?x:f[x]=getf(f[x]);
}

int main()
{
	scanf("%d",&T);
	while(T--)
	{
		scanf("%d%d",&k,&n);
		if(k>=n) 
		{
			printf("0.00\n");
			continue;
		} 
		for(int i=1;i<=n;i++)
		{
			scanf("%lf%lf",&x[i],&y[i]);
			f[i]=i;
		}
		
		m=0;
		for(int i=1;i<=n;i++)
		  for(int j=i+1;j<=n;j++)
		    p[++m]=(node){i,j,dist(x[i],y[i],x[j],y[j])};
		    
		sort(p+1,p+m+1,cmp);
		
		cnt=0;
		for(int i=1;i<=m;i++)
		{
			int fa=getf(p[i].x),fb=getf(p[i].y);
			double d=p[i].d;
			if(fa!=fb)
			{
				f[fa]=fb;
				ans[++cnt]=d;
			}
		}
		
		printf("%.2lf\n",ans[cnt-k+1]);
	}
	return 0;
}
```
