## 蒟蒻第四篇题解，写得不好，巨佬勿喷
### 样例的修改
原题的样例还可以这样子输出：

$2$

$3$ $4$

$2$ $3$

$1$ $3$

### 基础的贪心
因为题目要求每一次$/2$的结果要向上取整，所以说我们可以每一次选择相加为偶数的两个数（于是原本的样例就出现了）

伪代码：
```cpp
while(!check()){
    for(int i = n - 1; i >= 0; i--){
        if(vis[a[i]] && vis[n - a[i]]) choose(); //vis是标记存不存在此数字的bool数组
    }
}
```
$choose$函数的写法显而易见：将每一次得到的结果存入一个数组，并且更新$vis$数组，数字个数$n-1$。

那么，$check$函数该如何写呢？

最简单的写法（伪代码）:
```cpp
for(int i = 0; i < n; i++) if(vis[i]) num++;
return num == 1;
```
### 进一步的解法
我们可以发现每一次更新都会变动数组当中的两个数，所以我们只需要在每一次操作后都把新的数进行冒泡，这样的时间复杂度虽然也是$O(n)$，但是常数上更优。

部分代码如下：
```cpp
void srt(){ //每一次冒泡
    for(int i = n - 2; i >= 0; i--){
        if(a[i] < a[i - 1]) swap(a[i], a[i - 1]);
    }
}
```

然后这样$check$函数就只需要检查$a[1]$是否为$0$就好了！

**先不要兴高采烈，我们先看一下数据范围。**

$2≤n≤2*10^5 ,∑n≤2*10^5$

这样的数据范围，显然我们一开始的做法是肯定会爆空间的！ 那么如何解决？

### 更进一步的解法
当我们实验几组数据时，我们会发现结果都是$2$。

于是，我们可以做一个大胆的猜想：每一次的结果都为$2$！

由于我们每一次的操作结束后都会排序数组，所以最后一次操作前数组里肯定会留下最小的$2$个数——即$1$和$2$，那么结果肯定为$2$。

于是，我们就可以快乐地先输出二，然后边处理边输出了。

部分代码如下：
```cpp
void choose(int a, int b){
    n--;
    cout << a << ' ' << b << endl; //输出
    vis[a] = false, vis[b] = false;
    vis[up(a + b)] = true; //up为将正整数/2向上取整的自定义函数
    srt(up(a + b));
}

......

cout << "2\n";
while(!check()){
    for(int i = n - 1; i >= 0; i--){
        if(vis[a[i]] && vis[n - a[i]]) choose(a[i], (n - a[i])); 
    }
}
```

那现在是不是就完美了呢？并不是的，结果**肯定是[这样子](https://www.luogu.com.cn/record/40274877)的**（如果没有加强数据的话）

我们可以发现——其实我们爆的不仅仅是空间，还有时间。

那么AC之路，远在何方？

### 最后的解法

我们可以发现，因为每一次最后肯定要剩下$1$和$2$才能够有最优解，所以我们只需要让结果剩下$1$和$2$就可以了。

那么，我们可以想到——如果每一次都选最大的两个数，会发生什么？

因为一开始的序列为连续的正整数，所以我们每一次挑最大的两个数一定会产生最优解——因为每一次处理后的序列都已经排好序了。

这样我们就能够直接把$O(n^3)$的时间复杂度提升到$O(n)$了！

### Code:
```cpp
#include<iostream>

using namespace std;

int t, n;
int a[200005];

int up(int x){ //返回x/2向上取整的值
	if(x % 2) return (x + 1) / 2;
	else return x / 2;
}

int main(){
    ios::sync_with_stdio(false);
    cin.tie(0);

	cin >> t;
	
	while(t--){
		cout << 2 << endl;
		
		cin >> n;
		
		for(int i = 1; i <= n; i++) a[i] = i; //产生序列
		
		int pos = n; //当前处理的下标
		
		while(pos > 1){
			cout << a[pos - 1] << ' ' << a[pos] << endl; //输出最大的两个数
			
			a[pos - 1] = up(a[pos] + a[pos - 1]); //当前最大数为新数
			
			pos--;
		}
	}
	
	return 0;
}
```

**最终结果：[AC](https://www.luogu.com.cn/record/40274982)**