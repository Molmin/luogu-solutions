## 题意

有$n$个边长为$a_i$的正方形，题目规定：如果某点位于某个正方形**内部**或其**边界**上，就称这个点属于这个正方形。

现规定一个$k$，判断是否能找到一个点$(x,y)$，恰好属于$k$个正方形。

如果找到，则输出一组可行解$(x,y)$即可，两数用空格隔开；如果无解，输出$-1$。

## 思路

1. 我们先把数组$a$**从大到小**排序一遍，以方便接下来的操作。

2. 在输出答案之前，我们再判断$k$是否**大于**$n$，如果大于，输出$-1$；因为要求正方形数量$k$**不可能大于**总数量$n$。 

3. 最后，我们在输出数组$a$中第$k$个正方形的右上角顶点坐标（重复两次它的边长即可）

4. 其实说白了，这道题就是寻找数组$a$中的**第$k$大**的数输出**两遍**。

## 代码

```cpp
#include<stdio.h>
using namespace std;
const int MAXN=60; //数组最大范围
void swap(int &a,int &b) //swap函数：交换两个整型变量的数值 
{
	int temp=a;
	a=b;
	b=temp;
} 
int main()
{
	int n,k,a[MAXN]={0}; //定义变量
	scanf("%d%d",&n,&k); //输入n,k
	for(int i=0;i<n;i++)
	{
		scanf("%d",&a[i]); //输入数组a的第i个元素
		for(int j=i;j>0;j--) //从大到小排序 
		{
			if(a[j]>a[j-1]) //判断后面的数值是否大于前面的数值 
			{
				swap(a[j],a[j-1]); //是则交换两数数值 
			}
		} 
	}
	if(k>n) //如果要求正方形数量大于总数量 
	{
		printf("-1"); //无解
		return 0; 
	} 
	printf("%d %d",a[k-1],a[k-1]); //输出第k-1个正方形（从大到小）右上角顶点坐标 
	return 0; 
} 
```
