好写的单 log 做法！

记 $z^{R}$ 表示字符串 $z$ 的翻转，$+$ 表示字符串的拼接。如果我们折几次纸，可以发现，形如 $z+z^{R}+z$ 的结构是我们需要考虑的。形象地称这种串为 $Z$ 串。

**性质1**：如果在某个串中，两个回文串中心不重叠，且均覆盖了对方的中心，那么存在一个 $Z$ 串。

只需要提取两个中心之间的字符串作为 $z^R$ 就可以找到这个 $Z$ 串。

**性质2**：如果一个 $Z$ 串没有一个子串作为 $Z$ 串，称其为本原 $Z$ 串。一个本原 $Z$ 串的唯一偶回文后缀为 $z^R+z$，唯一偶回文前缀为 $z+z^R$。

不妨假设其有另一个偶回文后缀。首先这个回文后缀的半径要小于 $\frac{|z|}{2}$，否则和 $z^R+z$ 的回文中心相互覆盖产生更小的 $Z$ 串。当其小于 $\frac{|z|}{2}$ 时，$z$ 可以被表示成 $s+t+t^{R}$，那么 $z+z^R=s+t+t^R+t+t^R+s$，显然出现了更小的 $Z$ 串，矛盾。前缀同理。

**性质 3**：记 $w(a)$ 表示 $a$ 的最小折叠次数。如果一个串中存在一个本原 $Z$ 串，那么先把这个串折掉是最优的。也即如果一个串能表示成 $s+z+z^R+z+t$，则 $w(s+z+z^R+z+t)=w(s+z+t)+2$。

 $w(s+z+z^R+z+t)\geq w(s+z+t)+2$ 是显然的。而要证明 $w(s+z+z^R+z+t)-2\leq w(s+z+t)$，只需要观察 $z+z^R+z$ 在最优解中的折叠次数，这肯定不超过 $2$，展开后消去是 $s+z+t$ 的一种合法折叠，所以两边都被证明，可以取等。

在有了这个结论之后，对于一个串我们肯定先把所有本原 $Z$ 串折叠掉，然后处理没有本原 $Z$ 串的结构。而折叠 $Z$ 串的过程随着在尾部添加字符是不需要撤销的，因此只需要考虑每次增加字符以后如何找到本原 $Z$ 串。

根据性质 $2$，一个本原 $Z$ 串只有一个偶回文前后缀，也即，如果插入一个字符之后存在本原 $Z$ 串，那么 $|z|$ 的长度一定等于最小的偶回文后缀的半径。设其为 $l$，只需要检查往前 $l$ 个位置是否有一个回文后缀半径为 $l$ 。

找最小的回文后缀和是否存在半径为 $l$ 的回文后缀当然有回文数据结构的做法。但是由于这道题目的特殊性，每个位置结尾的回文后缀是 $O(\log n)$ 的。对于一个不含本原 $Z$ 子串的串，每个位置结尾的回文后缀相互之间至少是 $1:2$ 的关系，否则会因为相互覆盖产生 $Z$ 子串，所以我们可以在 $O(n\log n)$ 时间内暴力维护回文后缀，求出消完 $Z$ 子串之后的序列。

然后我们面对的是一个不含 $Z$ 子串的序列，假设每一段没有拐弯的序列长度记作 $q_1,q_2,\dots q_k$，因为没有 $Z$ 子串，所以不可能存在 $q_i>q_{i+1}<q_{i+2}$ 的情况。因为这相当于 $q_{i+1}$ 和 $q_i$ 的一段后缀和 $q_{i+2}$ 的前缀匹配了，这构成了一个 $Z$ 子串。因此这个序列是单峰的。既然是单峰的，那每次从前缀和后缀中挑出最小的回文前/后缀折叠就对后面没有影响了。

另外我们发现，前缀折叠和后缀折叠几乎是不可能相交的，因为相交意味着两个回文串互相覆盖中心，产生 $Z$ 子串。说几乎是因为性质 1 的条件之一是 中心不重叠。如果形如 1 2 3 3 2 1 的结构，那么会被前后缀分别折叠一次，但是实际上只会折叠一次。这也是好处理的。重叠的部分实际上只有前缀的最后一次折叠和后缀的最后一次折叠，因此可以对于前缀后缀分别记录 $f_i,p_i$ 表示从 $i$ 开始的前/后缀能折叠多少次，最后一次折叠中心在哪里。如果折叠中心重合了那么需要减去 $1$。

对于上述算法在可以很方便地计算出每个前缀的折叠次数，所以就可以以 $O(n\log n)$ 的时间复杂度解决。~~代码全是暴力还能难写？~~

[submission](https://www.luogu.com.cn/record/112721430)