鉴于为什么解法是求最长不下降子序列，其他题解已经论述比较透彻了，那么这里仅提供一个基本的$LIS$问题$O(n\times logn)$复杂度的思路(不是做法，而是如何想到）  
$O(n^2)$的时间复杂度显然不够优秀，那么我们该如何优化这种算法呢。  
在我们每处理数列中的一位时，我们都要遍历数组找到值小于当前数中的f值的最大值，再用其加一作为现数字的值。  
那么，如果我们维护一个取值集合，储存可能的最优解，
就可以优化算法的时间复杂度。  
将一个数放入取值集合的条件是什么？如果两个数a、b
，f值相同，但$a<b$,那么a对于后来的数来说，显然比b优。（运用了优先队列的思想）  
那么我们储存下对每一个f值来说的最小原数字值，在处理完新数字后将新数字与与其f值相同的数字比较大小，若小于则更新。  
我们又观察到，若设$f[i]$为f值为$i$的最小原数字值，则$f$数组显然是单调增的。  
因此可以用二分查找快速找到最大的小于当前数的、在取值集合中的数，当前数即为其f值+1。然后将其与大于其的、在取值集合中的
第一个数取$\min$，更新该位上的数。  
设置一个指针p（其实就是变量）指向f数组尾，若当前数
大于p指向的数，则`p++`，集合扩展。  
答案就是p的值。
下面附上AC代码
```cpp
#include<bits/stdc++.h>
using namespace std;
struct pt{
	int l,r;
}; 
pt a[(int)2e5+5];
int n,f[(int)2e5+5],p=0;//f[i]=长度为i的IS最小最后一个数 

bool cmp(pt x,pt y) {
	return x.l<y.l;
}

int main() {
	cin>>n;
	for(int i=1; i<=n; i++) scanf("%d%d", &a[i].l, &a[i].r);
	sort(a+1,a+1+n,cmp);	
	for(int i=1; i<=n; i++) {
		if(a[i].r > f[p]) p++,f[p]=a[i].r;
		else f[lower_bound(f+1,f+p+1,a[i].r)-f]=a[i].r;
	}
	cout<<p<<endl;
	return 0;
}
```