#### 这道题也算是个模板题吧（nlognLIS）
对于初学DP的还是比较重要，它诠释了LIS究竟怎末用。


------------
先说下这道题的做法吧
先以一岸为参照排下序，然后再以另一岸为参照做下LIS就好了。
其正确性易证，
点到为止。


------------
见一大佬题解引用《西江月》，我也分享下。

即得易见平凡，仿照上例显然。

留作习题答案略，读者自证不难。

反之亦然同理，推论自然成立。

略去过程QED，由上可知证毕。


------------
 作为一篇优秀的题解，绝不能这么迷迷糊糊的水了
 下面还是放一下我的代码吧
 ```cpp
#include<iostream>
#include<algorithm>//sort和lower_bound
#define __Q__ 0
#define __X__ 1
#define __A__ 200200
#define mian main//OIer日常的mian函数
#define int long long //分享一下快速改类型的方法
using namespace std;
struct __o__{
	int __,___;
}______[__A__];
int __;
bool ___________(__o__ _O_,__o__ _o_){
	return _O_.__<_o_.__;
}
signed mian(){
	ios::sync_with_stdio(false);//玄学加速，与据说与编译器的emmm成正版
	cin>>__;
	for(int _=__X__;_<=__;_++){
		cin>>______[_].__>>______[_].___; 
	}
	sort(______+__X__,______+__+__X__,___________);
	int ____[__A__],_____=__Q__;
	for(int _=__X__;_<=__;_++){
		if(!_____||____[_____]<______[_].___)____[++_____]=______[_].___;
		else *lower_bound(____,____+_____,______[_].___)=______[_].___; 
	}
	cout<<_____;
	return __Q__;
}
```


------------
# **滑稽保命，溜了**