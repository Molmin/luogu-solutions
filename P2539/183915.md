矿藏编码题解
                               ——by _一只蒟蒻帆_

题目描述
![](https://s2.ax1x.com/2019/12/16/Q5KhSP.jpg)
 依次对每份进行编码，得S1，S2，S3，S4。该矿藏区的编码S为2S1S2S3S4。 例如上图中，矿藏区的编码为：2021010210001。 小联希望你能根据给定的编码统计出这片矿藏区一共有多少格子区域是平地。 
输入
第一行有一个整数K，表示有矿藏区的规模为 （1 < K < 50）。第二行有一串编码，有0、1组成，长度不超过200，表示该矿藏区的编码。
输出
单行输出一个整数，表示矿藏区中一共有多少格子是平地。
样例输入
2
2021010210001
样例输出
9

看到题目，哎呀，这不模拟吗？！可是，最坏情况答案会达到2k *2k，所以答案要用double才能卡过，况且不可能开2k *2k的数组啊！

于是，又仔细看题目：它要求我们求的是平地数量，而且它的矿藏编码公式是2S1S2S3S4，不难看出每出现一个2他所对的那块矿藏区域就存在不是全是平地（0）或山峰（1），需要再次分解成四块，直到那块矿藏区域满足全是平地或山峰。所以，我们又得出一个结论：经过多次分解，每个0所对应的平地数量也就不同。而且，每个0所对的平地数取决于它被分割了几次，而每分割n次，这个0所对应的空地数量就是2*（k-n）个啊！所以，我们不妨设p=k，每次出现2就p--，对应的ans就+=pow（2，p+p）。这不就好起来了吗！

而且，回到被分割前的那一块区域只要满足分割后（2出现后）存在四个数（0或1）。所以不妨设一个a[maxn],里面存2之后累计出现了几个0或1，如果达到4的话，先把a[p]清零，再把p加个1回去，不就AC了吗？

最后，代码实现：

```cpp
#include <bits/stdc++.h>

#define maxn 100010

using namespace std;

int k,p,a[maxn];

double ans;

char c;

int main(){

scanf("%d\n",&k);

p=k;

while (~(c=getchar())){

if (c=='2') p--;

else if (c=='1') a[p]++;

else if (c=='0') a[p]++,ans+=pow(2,p+p);

while (a[p]==4) a[p]=0,p++,a[p]++;

}

printf("%.0lf",ans);

return 0;

}
```


——THE END.——