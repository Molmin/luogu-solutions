# 阅读初感
乍一看，这就是一道正常的暴力模拟，无愧于黄题标签，注意细节就行了（说得简单）

首先，先输入一个n，但这个n并不是矿藏区的边长，边长应该为pow（2，n），所以可以把边长记录下来，然后算出4块中每一块的面积，在赋值给n，就像这样：n=pow(2,(int)2*n-2);（有过简化，可以拆开来理解）。
    
其次，便是处理接下来的一串编码了。乍一看比较没头绪，但仔细理一理应该没什么问题。以样例为例：2021010210001，仔细分析一下，就是先输入一个2，然后再输入四个数字分别表示四块区域的状态，分别表示左上，右上，左下，又下四个角的四个方块，如果全黑就为1，就可以记录下方块总数，全白就为0，有黑又白就输入2，然后再输入4个数字表示这一大块中四个小块的状态。如果输入的还有2，那么就再输入4个数字。看着看着，就想到可以用递归来模拟这个过程，那么统计黑块的个数就可以在线做。

那么怎么统计黑块个数呢？可以开一个变量k，如果出现了1的状态，那么答案ans就可以加上k，那如果再出现2呢，那么这时候每一个数字表示的面积变小了4倍，所以要k/4。所以一遍走下来即可。
# 代码实现
```cpp
#include<bits/stdc++.h>
using namespace std;
double n,ans;
void in(double k)	//在线输入并计算
{
    char js1;
    for(int i=1;i<=4;++i)
    {
        scanf("%c",&js1);
        if(js1=='0')
        ans+=k;
        else if(js1=='2')
        in(k/4);	//在进行一边循环，k不要忘了/4
    }
}
int main()
{
    //freopen("1.in","r",stdin);
    scanf("%lf\n",&n);
    n=pow(2,(int)2*n-2);	//设置n为每一块的面积
    scanf("2");
    in(n);
    printf("%.0lf",ans);
    return 0;
}

```
完成收工