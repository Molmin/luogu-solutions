# 洛谷 P7263 题解

有理数取模就不费赘述了，还没学的[点我](https://www.luogu.com.cn/problem/P2613)。

## 题目分析

### step 1

~~题目给的程序好像有不少人怀疑会错~~

差不多就是从左到右找到第一个不合法的位置，比如下面这个括号序列：

```
( ( ) ) ) ) ( ( ( ) ( )
        ^
        |
      不合法
```

之后找到这个位置后面第一个合法的：

```
( ( ) ) ) ) ( ( ( ) ( )
        ^     ^
        |     |
      不合法 合法
```

最后把这一段翻转：

```
( ( ) ) ( ( ) ) ( ) ( )
        ^     ^
        |     |
      不合法 合法
```

至于翻转后为什么一定正确，可以发现合法其实就是要使当前位置 $sum>0$，因为我们找出的是第一个 $sum\ge 0$, 的位置，所以这个位置之前的 $sum$ 一定一直小于 $0$，而翻转就是取相反数，$sum$ 就必定一直大于 $0$，括号序列就一定是合法的。

### step 2

（目标括号序列指输入给出的，初始序列指程序最初随机生成的）

首先，我们知道 $\texttt{概率}=\frac{\texttt{合法方案数}}{\texttt{总方案数}}$，最初随机生成的括号序列总共有 $C^n_{2n}$ 种可能（就是在 $2n$ 个位置中选 $n$ 个作为左括号）。现在只需要求出能够被程序转化成目标括号序列的随机括号序列有多少种。

我们可以给目标括号序列分个段：（每个极大的括号组分一段）

```
( ( ) )|( ( ) )|( )|( )
```

可以发现每个括号组在初始括号序列中只有两种可能：

1. 被翻转过

2. 没有被翻转

所以就有 $2^4=16$ 中初始括号序列能够被转化为上面那个目标括号序列。

设目标括号序列能够分 $k$ 段，所以对于一种目标括号序列，它的初始括号序列就有 $\frac{2^k}{C^n_{2n}}$ 种可能。

这就是答案。

组合数暴力求解即可，复杂度（别忘了还有有理数取模）是 $O(n\log 998244353)$。

## 代码

```cpp
#include<cstdio>
using namespace std;
const int mod=998244353;
char s[1000002];
long long ksm(long long k,long long b)//有理数取模
{
    long long s=1;
    while(b)
	{
        if(b&1)s=s*k%mod;
        b>>=1;
        k=k*k%mod;
    }
    return s;
}
int main()
{
	int n,sum=0;
	scanf("%d%s",&n,s+1);
	long long ans=1;
	for(int i=1;i<=2*n;i++)
	{
		if(s[i]=='(') sum++;
		else sum--;
		if(sum==0)//新的一段
		{
			ans=ans*2%mod;
		}
	}
	long long num=1;//组合数
	for(int i=n+1;i<=2*n;i++)
	{
		num=num*i%mod;
	}
	for(int i=1;i<=n;i++)
	{
	    num=num*ksm(i,mod-2)%mod;
	}
	printf("%lld",ans*ksm(num,mod-2)%mod);
    return 0;
}
```

谢谢观看！

~~点个赞再走呗~~