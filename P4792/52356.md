## 注：本题解为官方题解，用语可能和题面有些差异。
### 子任务1
定义$s=s_1s_2...s_N$为 DNA 字符串。给你一个子串$t=s_is_{i+1}...s_j$，检查$t$中是否含有所有要求的字符的时间复杂度为$O(N \cdot R)$。这种方法非常暴力，只需要循环并且计算出在子串中每个要求的字符数量是否符合即可。那么，可以通过暴力枚举找出最优的子串(有$C_2^	{N+1}=O(N^2)$个)。总时间复杂度为$O(N^3R)$

### 子任务2

可以做一些预处理，这样检查字子串是否合法的时间复杂度就降到了$O(R)$。可以用前缀和的思想解决（即计算$s$中每个元素出现了多少次）。这样时间复杂度就是$O(R)$。

总时间复杂度是$O(N^2R)$

### 子任务3

其实，当$N=100000$左右时，根本不用检查所有子串。找出$i \in \{1,...,N\}$中，包含足够多的要求字符的字串$s_i...s_j$，并使得$j$最小即可。用二分以及前缀和解决。复杂度就是$O(NR \log\, N)$
### 子任务4
想用O(N)的时间复杂度解决问题，我们可以用 _双指针_ 的思想解决。记录一个子串$s_l...s_r$，如果它不合法那就是太小了，这时可以$r$++。如果合法，那么这个子串有可能太大，那么，$l$++。这样只用检查$O(N)$个子串。

每次加减$l,r$，子串的变化并不太大。所以可以记录：
1. 在子串中的字符有每种有多少个（定义为$ch[$元素种类$][$位置$]$）
2. 在子串中出现的要求的字符（但未满足要求）每种有多少个。

$l$++时，我们令$ch[s_l][l]$--，如果要求的字符变少，我们就增加要求的字符个数。

$r$的操作同理。

这样时间复杂度就降到了线性。