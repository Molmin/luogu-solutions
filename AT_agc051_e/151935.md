首先考虑弱化的情况：在一维坐标轴上有若干个点，做题目中取中点的操作。

经过暴力打表的验证，能取到的点是：取 $D$ 表示所有点之间两两距离的 $\gcd$，设 $d=\dfrac{D}{2^{\text{lowbit}(D)}}$，要满足：

1. 在最左和最右的点之间。
2. 与最左的点距离为 $d$ 的整数倍。

为什么这个结论是正确的？考虑一下这个结论的本质。

有趣的地方正在于 $\gcd$。把最左的点到其他的点看做若干个向量 $(x,0)$。可以看做可以从最左的点开始，任意加减这些向量，能够得到的所有点，并且要在最左和最右的点之间。

对应到二维平面上来猜测结论，假设固定一个点 $A$，把从 $A$ 到其他点的向量集合称作 $\{(x,y)\}$，能得到的点就是从 $A$ 开始，任意加减这些向量，能够得到的所有点，并且要在所有点的凸包内。

最终结论是，能得到的点要满足

1. 要在所有点的凸包之内。
2. 在凸包边上的点，结论与一维的相同。由于没有三点共线，每条边上数量就是 $2$ 的若干次方。
3. 在凸包内的点，能得到的条件是它到某个点 $A$ 的距离是一堆向量的线性组合。

我们知道在二维平面上也是可以求向量的 $\gcd$ 的：

首先，向量 $A,B$ 和向量 $A+kB,B$ 能线性组合表出的向量集是相同的，那向量就可以做辗转相除。

假设手中已经有两个向量 $(a,b),(0,c)$，现在多加一个 $(x,y)$，首先可以把 $(a,b)$ 和 $(x,y)$ 辗转相除成 $(t_1,t_2),(0,t_3)$，然后让 $(0,c)\to (0,\gcd(c,t_3))$。

写成代码就是这样：

```cpp
struct P{
	int x,y;
};

void work(P&a,P&b){
	while(b.x){
		int t=a.x/b.x;
		a.x-=t*b.x,a.y-=t*b.y;
		swap(a,b);
	}
}

P a=p[1],b=p[2];
work(a,b);
For(i,3,n-1){
	P c=p[i];
	work(a,c),b.y=__gcd(b.y,c.y);
}
```

那能被表出的点变成了 $A+k_1\times(a,b)+k_2\times(0,c)$，然后以得到的两个向量 $(a,b),(0,c)$ 为基，变换一下坐标系，然后数凸包内整点数。

但这样还是数漏了，因为可以加中点。在一维问题里做的变换是 $d\to \dfrac{d}{2^{\text{lowbit}(d)}}$，在二维里同样可以做变换：

先把 $c\to \dfrac{c}{2^{\text{lowbit}(c)}}$，这样 $c$ 变成奇数。

然后把 $a,b$ 不断同除以二。如果 $a$ 变成奇数，那就无法再化简。如果 $a$ 是偶数 $b$ 是奇数，那就把 $b$ 加上 $c$ 变成偶数，继续除以二。容易发现这样能得到最简。

之后变换坐标系就变成了数凸包内整点个数，可以用 Pick 定理解决。

[代码](https://atcoder.jp/contests/agc051/submissions/39218379)，注意开 `__int128`。

当然上面只是用猜结论的方式解决本题，证明结论可以去看官方题解。