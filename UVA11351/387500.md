## UVA11351 Last Man Standing
[原题链接](https://www.luogu.com.cn/problem/UVA11351)
首篇题解。
## 题意
有 $n$ 个人围成一圈报数。从第一个人开始，数到 $k$ 的人出圈。再由下一个人重新从 $1$ 开始报数，数到 $k$ 的人再出圈，直到只剩下最后一个人。给出 $n$ 和 $k$，找出站在圆圈里的最后一个人的号码。

输入首行为数据组数，每组数据为两个整数 $n$ 和 $k$。输出每组数据站在圆圈里的最后一个人的号码。

## 分析
经典约瑟夫问题，唯一不同点是输出最后一个出圈的人，数据加强且多组数据。刚看到这道题，果断打了一遍模拟，用 STL 中的队列模拟出圈过程，当队列中只剩一人时输出结果。有了以下代码：

```cpp
#include<iostream>
#include<cstdio>
#include<queue>
using namespace std;
int t,n,k,num;
queue<int>a;
int main(){
	int t;cin>>t;
	for(int o=1;o<=t;o++){
		cin>>n>>k;
		num=1;
		for(int i=1;i<=n;i++) a.push(i);
		while(!a.empty()){ 
			if(num==k){
				if(a.size()==1){
					cout<<"Case "<<o<<": "<<a.front()<<endl;
				} 
				a.pop();
				num=1;
			}
			if(num!=k){
				num++;
				a.push(a.front());
				a.pop();
			}
		}
	}
	return 0;
}
```
这份代码无法通过评测，你会得到 TLE 的结果。再看看数据范围：$(0<n\le 10^{6})$，$(0<k\le 10^{9})$，模拟每个人出圈肯定会超时了。

## 思路
递归。设 $n=5$，$k=3$。编号依次为 $(0,1,2,3,4)$。

- 第一次报数，编号 $(3-1)\%5=2$ 的人出圈。

剩下的人编号依次是 $(0,1,3,4)$。现在该从编号为 $3$ 的人开始报数，第一次报数从 $0$ 开始，我们不妨让第二次报数仍从 $0$ 开始，在减少一人的情况下和第一次步骤相同，这样便用到了递归调用自身的思想。将数列元素全部减 $3$ 得到 $(-3,-2,0,1)$，由于是一个从 $0$ 开始的环，数列可以表示为 $(2,3,0,1)$.

- 第二次报数，目前编号 $(3-1)\%4=2$ 的人出圈。

这时报数为 $2$ 的人编号是什么？由上可知为 $0$，正是 $(2+3)\%5$ 的结果。剩下的人编号依次是 $(3,0,1)$，表示为 $(0,1,2)$。

- 第三次报数，目前编号 $(3-1)\%3=2$ 的人出圈。

这时报数为 $2$ 的人对应到第二次报数是 $(2+3)\%4=1$，编号为 $(1+3)\%5=4$。

得出递归公式：```(f(x-1,y)+y)%x;```

## Code
```cpp
#include<iostream>
using namespace std;
int f(int x,int y){
    if(x==1) return 0; //只剩最后一个人 
    else return (f(x-1,y)+y)%x; //上文递归公式 
}
int main(){
	int a,b,t;cin>>t;
	for(int i=1;i<=t;i++){
		cin>>a>>b; 
    		cout<<"Case "<<i<<": "<<f(a,b)+1<<endl;
	}
    return 0;
}

```
