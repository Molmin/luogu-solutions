[P3847 调整队形](https://www.luogu.org/problem/P3847)

比较典型的区间dp，我们设$a[i]$表示原数组中i位置的颜色，$f[i][j]$表示i到j区间变成回文串的最小改变次数.

我们可以发现，题目中的操作“在队伍中任两个人中间插入一个人”是不需要另外处理的，这种处理一定包含在之前的状态中，体现为之前状态“在队伍左或右边加一个人”的情况，所以当前我们只需要进行“在队伍左或右边加一个人”的操作就行了.

同理剔除在队伍中间某个人也不需要处理. 那么我们需要进行的就是区间两端的操作，而且可以发现，实际上剔除两端的某一个人和在两端增加一个人是等价的. 比如说如果当前我们已经算出了i到j-1的最小转换数，要求i到j的最小转换数，则我们既可以进行在i左边加一个$a[j]$的操作，也可以把$a[j]$删去.

综上所述，插入或删除的状态转移方程是：

>$f[i][j]=min(min(f[i][j-1]+1,f[i+1][j]+1),f[i][j])$

再考虑转换颜色的情况. 如果我们已求i+1到j-1的最小转换次数且$a[i]=[j]$，那么显然$f[i][j]=f[i+1][j-1]$；如果$a[i]!=a[j]$，只要把$a[i]$或者$a[j]$换成另一个即可.

状态转移方程为：

>$f[i][j]=min(f[i+1][j-1]+1,f[i][j])$

初始化记得给f赋极大值，再加上初始化即可ac.

```cpp
#include<bits/stdc++.h>
#define maxn 4010
using namespace std;
int n,a[maxn],f[maxn][maxn];
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		scanf("%d",&a[i]);
	}
	memset(f,0x3f3f3f3f,sizeof f);
	for(int i=1;i<=n;i++){
		for(int j=i;j;j--){
			if(i==j){f[j][i]=0;continue;}//初始化1
			if(a[i]==a[j]&&j+1<=i-1){f[j][i]=f[j+1][i-1];continue;}
			else if(a[i]==a[j]&&j+1>i-1){f[j][i]=0;continue;}//初始化2
			f[j][i]=min(f[j][i],f[j+1][i]+1);
			f[j][i]=min(f[j][i],f[j][i-1]+1);//以上两种为在两端删去或加上某个人 
			f[j][i]=min(f[j][i],f[j+1][i-1]+1);//让某一个人换衣服 
		}
	}
	printf("%d\n",f[1][n]);
	return 0;
} 
```


这道题和P4170 涂色 都是区间dp的好题，推荐去做一做.