### 一个披着~~好看~~外衣的dp题

------------
让我们来揭开表面看真相吧

_"题目描述_
 
_1、在队伍左或右边加一个人（衣服颜色依要求而定）；_
 
_2、在队伍中任两个人中间插入一个人（衣服颜色依要求而定）；_
 
_3、剔掉一个人；_

_4、让一个人换衣服颜色；"_


------------
对于题目要求的操作，其实都是相同的

插入一个人=删去一个人=换衣服（至于为什么自己看完剩下就知道）

我们用一个$dp[i][j]$数组来表示将这个数从第$i$个数字到第$j$个数字变为回文数的最小代价

状态转移方程献上

```cpp
if(a[i]==a[j])
{
	dp[i][j]=dp[i+1][j-1];//如果两个数字相同就可以不更改，即代价不改变，是减去头尾二数的区间的最小代价
}
else
{
	dp[i][j]=min(dp[i+1][j],min(dp[i][j-1],dp[i+1][j-1]))+1;//否则取减去头一个数，或尾一个数，抑或去掉头尾区间的最小代价+1，因为题目中的操作保证可以一次将一个回文数+一个数由一次改变变为回文数
}
```

之前min里写了3个数结果报错了

最后其实输出$dp[1][n]$即可，表示从$1$到$n$变为回文数的最小代价，即将输入的这个数变为回文数的最小步骤

最后代码献上，在此不坑大家啦，自觉

```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
	int n,kkk;
	cin>>n;
	int a[n+1]={};
	for(int i=1;i<=n;i++)cin>>a[i];
	int dp[n+1][n+1]={};
	for(int chang=2;chang<=n;chang++)
	{
		for(int i=1;i<=n-chang+1;i++)
		{
			kkk=i+chang-1;
			if(a[i]==a[kkk])
			{
				dp[i][kkk]=dp[i+1][kkk-1];
			}
			else
			{
				dp[i][kkk]=min(dp[i+1][kkk],min(dp[i][kkk-1],dp[i+1][kkk-1]))+1;
			}
		}
	}
	cout<<dp[1][n];
 } 
```

嘿嘿，蛮简单的嘛，没有注释你们也能看懂吧，题目数据很善良，直接一个一个输入

#### 拒绝抄袭，从你我做起

#### ——惨遭禁言的MCL