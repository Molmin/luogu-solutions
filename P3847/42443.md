这道题是道很明显的区间动态规划的题目啊。

大体思路如下:
1. 先定义两个数组，a与f，a数组存的是每个同学衣服颜色的编号，f是二维的，f[i][j]则表示第i个同学到第j个同学至少需要调整几次。

1. 读入合唱队的总人数n以及每个同学衣服的颜色（用a数组存）。

1. 确定边界。首先把f数组的每个值赋值为INF，然后从1到n循环，令f[i][i]=0; 如果第i个同学衣服的颜色与第i-1个同学衣服颜色相等，那么f[i-1][i]=0,否则f[i-1][i]=1。

1. 开始推状态转移方程。首先用循环变量l枚举每个区间的长度大小，接着用变量i枚举每个区间的起始位置，再定义变量j表示区间的终点，j=i+l;(自己可以想想为什么不枚举j，而枚举区间的长度l)，枚举好了区间，就开始写状态转移方程。先判断a[i]是否等于a[j],如果相等，那么 f[i][j]=max(f[i][j],f[i+1][j-1]); 如果不相等 f[i][j]=max(f[i][j],f[i+1][j-1]+1); 接下来，我们再考虑两种情况，如果让第i个人左边加一个与第j个人衣服颜色相同的人或者是把第j个人剔除掉，那么f[i][j]=min(f[i][j],f[i][j-1]+1); 如果让第j个人右边加一个与第i个人衣服颜色相同的人或者是把第i个人剔除掉，那么:f[i][j]=min(f[i][j],f[i+1][j]+1);

1. 最后输出f[1][n]即可。

时间复杂度为O(n²)。

下面贴代码：

### 注意：减少代码复制，共创美好洛谷！

```cpp
#include <iostream> //头文件不解释
#include <cstring>
using namespace std;
int a[3010];
int f[3010][3010];
int main()
{
    memset(f,0x7f,sizeof(f));//初始化一个较大的数
    int n;
    cin>>n;//读入n
    for(int i=1; i<=n; i++)
    {
        f[i][i]=0;//确定边界
        cin>>a[i];//读入第i个同学衣服颜色编号
        if(i!=1)
        {
            if(a[i]==a[i-1])
            {
                f[i-1][i]=0;
            }
            else
            {
                f[i-1][i]=1;
            }//同样是确定边界
        }	
    }
    for(int l=2; l<=n; l++)//l要不为1，因为l为1的区间都算过了
    {
        for(int i=1; i<=n; i++)
        {
            int j=l+i;
            if(j>n) continue;//如果j>n就继续
            if(a[i]==a[j]) f[i][j]=min(f[i][j],f[i+1][j-1]);
            f[i][j]=min(f[i][j],f[i+1][j-1]+1);
            f[i][j]=min(f[i][j],f[i][j-1]+1);
            f[i][j]=min(f[i][j],f[i+1][j]+1);//状态转移方程
        }
    }
    cout<<f[1][n];//输出
    return 0;
}
```

p.s 本人蒟蒻一枚，如果此题解有地方说的不好或是说错了，请在评论区告诉错误原因，谢谢！