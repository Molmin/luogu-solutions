# CF1249D1

## 题目描述

用 $n$ 条线段覆盖一个数轴。要求删除最少的线段，使得数轴上每个点都被覆盖不超过 $k$ 次。

## Solution

多一句嘴：贪心题不给证明的题解都是流氓题解。

拿到题先看数据范围，因为这可以告诉你你的算法大概的时间复杂度。这题的数据范围只有 200 ，那就说明 $O(n^3)$ 以下是稳过的。

先找出哪些点是“坏点”，然后考虑对覆盖这些点的线段进行删除。

从极端情况开始考虑。最坏情况下，每次删除一个线段，只能让一个“坏点”的被覆盖次数减少一次，设这个最坏删除次数为 $a$ 。

那么什么情况能导致 $a$ 变小呢？如果一个线段覆盖了 $b$ 个“坏点”，删除这个线段就让 $b$ 个“坏点”的覆盖次数减少一次，那么答案上界就变成了 $a-b$ 。所以我们在选择时，应该尽可能选择那些 $b$ 更大的线段。

从最原始状态开始考虑。假设我们还没有进行过删除操作，扫描数轴，找到**第一个**“坏点”，记为 $P$ 点（ $P$ 点之前的点一定不是“坏点”）。

如果 $P$ 点被覆盖了 $m$ 次，那么我们至少要删除 $m-k$ 条线段，才能让 $P$ 点合法。

假设覆盖 $P$ 的线段为 $S_1[l_1,r_1]...S_m[l_m,r_m]$ ，一共 $m$ 条。那么这些线段都可以分为两段：$[l_i,P_x-1]$ 和 $[P_x,r_i]$ 。

因为 $P$ 之前的点都不是“坏点”，那么线段 $[l_i,P_x-1]$ 覆盖了 0 个“坏点”（$b=0$），也就是删除这些线段对 $a$ 没有影响。

$P$ 右侧的点中，有可能有“坏点”，那么 $[P_x,r_i]$ 的 $b\geq 0$ 。如果我们把这些线段按照 $b$ 从大到小排序，一定删除 $b$ 最大的 $m-k$ 条线段更优。

假设一个“坏点”的坐标为 $y$ ，那么它对线段 $S_i$ 的 $b$ 有贡献，当且仅当 $y\in S_i$ 。设两条线段 $S_1([P_x,r_1]),S_2([P_x,r_2])$ ，其中 $r_1<r_2$ 。那么有 $S_1\subseteq S_2$ ，此时一定存在至少一个坐标 $y$ ,使得 $y\in S_2$ 且 $y\notin S_1$ 。如果坐标 $y$ 对应的点 $Q$ 恰好是“坏点”，那么 $S_1$ 的 $b$ 一定小于 $S_2$ 的 $b$ 。

综上，当一些线段左对齐时，有 $r_i<r_j\rightarrow b_i\leq b_j$ 。

那么显然，如果要使 $P$ 不是“坏点”，最优的方案是删除在 $P$ 右侧长度最长的 $m-k$ 条线段。

继续推广，假设我们完成了第一次删除，把 $P$ 变得合法了。此时继续向后扫描，如果又找到一个“坏点”，是不是相当于“之前没有进行过删除操作”（这个“坏点”前面的点都合法）？那么归纳法，可以把这个新找到的“坏点”看成 $P$ ，上面的结论依然成立。

综上所述，我们的做法应该是：

* 从头扫描数轴上所有点

* 找到一个“坏点”之后，扫描覆盖了这个“坏点”的所有线段。

* 不断删除在这个“坏点”右侧长度最长的线段，直到这个“坏点”合法。

当扫描到数轴结尾时，得到答案。

## $\text{Talk is easy,show me the code.}$

```cpp
//因为我整了个缺省源，头文件比较长，这里省略了，只给出核心代码。
struct Node{
  int l,r,org;
};

struct Node segments[maxn];
inline bool operator < (const Node a,const Node b){
  return a.r<b.r;
}//为了方便，按右端点递增排个序

inline bool inrange(const int i,const int x){
  return (segments[i].l<=x)&&(x<=segments[i].r);
}//判断一个点是不是被第i条线段覆盖

signed main(){
  read(n),read(k);
  for(int i=1,l,r;i<=n;++i){
    read(segments[i].l),read(segments[i].r),segments[i].org=i;
    for(int j=segments[i].l;j<=segments[i].r;++j)
      ++A[j];
  }
  std::sort(segments+1,segments+1+n);
  for(int i=1;i<=200;++i){//枚举每一个点
    while(A[i]>k){//如果是坏点
      for(int j=n;j>0;--j)//从结尾开始枚举线段j(排序之后右端点递减，找到的第一个就是在坏点右侧最长的线段)
        if(inrange(j,i) && !vis[j]){//线段j覆盖了这个坏点，并且还没有被删除
          for(int q=segments[j].l;q<=segments[j].r;++q)//删掉这个线段
            A[q]--;
          vis[j]=1;//标记已删除
          ++ans;
          break;
        }
    }
  }
  write(ans);
  putchar('\n');
  for(int i=1;i<=n;++i)
    if(vis[i]) write(segments[i].org),putchar(' ');
  return 0;
}

```