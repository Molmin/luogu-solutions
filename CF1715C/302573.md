## 题意

- 给定一个长度为 $n$ 的序列 $a$。
- $g(l,r)$ 为序列中区间 $[l,r]$ 能被分成的段数，如序列 $[1,1,2,2,2,1,1,3]$ 就能被分成 $[1,1],[2,2,2],[1,1],[3]$ 四段。
- $m$ 次询问，每次修改 $1$ 个值，并求此时的 $\sum\limits_{l=1}^{n}\sum\limits_{r=l}^{n}g(l,r)$。

## 思路

这题并不需要用什么数据结构维护，我们应当立足求出于每次修改产生的贡献。

换一种思路，可以发现每一个序列分成若干段后都会出现一些“断点”，如如序列  $[1,1,2,2,2,1,1,3]$ 的断点就是第 $2,3$ 个元素之间，第 $5,6$ 个之间，以及第 $7,8$ 个之间共三个。

那么对于每一个序列的答案就是**跨过每一个断点的区间数量之和，加上区间的总数**，还是上面的区间，答案就是 $2 \times (8-2) + 5 \times (8-5) + 7 \times (8-7) + 8 \times 9 \div 2 = 70$，区间总数一定，所以可以先放在一边。

求出原序列的答案后，接下来考虑单点修改对答案的影响，假设此时我们令 $a_i=x$，我们首先减去这个点原先的贡献，然后加上修改之后的贡献就可以完成一次修改了。

贡献可以通过判断此时 $a_i$ 与它两边的 $a_{i-1},a_{i+1}$ 的关系得到：如果发现此时 $a_{i-1}≠a_i$，那就说明 $i-1,i$ 之间是断点，产生跨过这个断点的区间数量的贡献，即 $(i-1) \times (n - i + 1)$，判断 $a_{i+1}$ 也是同理的。

## 代码

```cpp
#include <bits/stdc++.h>
using namespace std;

#define int long long
const int N = 1e5 + 10;
int n, m;
int a[N];
int ans;

signed main()
{
	cin >> n >> m;
	for(int i = 1; i <= n; i++)
		cin >> a[i];
	for(int i = 1; i <= n; i++)
		ans += (a[i] != a[i + 1]) * i * (n - (i + 1) + 1); 
	while(m--)
	{
		int i, x;
		cin >> i >> x;
		ans -= (a[i - 1] != a[i]) * (i - 1) * (n - i + 1);
		ans -= (a[i] != a[i + 1]) * i * (n - (i + 1) + 1);
		a[i] = x;
		ans += (a[i - 1] != a[i]) * (i - 1) * (n - i + 1);
		ans += (a[i] != a[i + 1]) * i * (n - (i + 1) + 1);
		cout << ans + n * (n + 1) / 2 << endl;
	}
	return 0;
}
```
