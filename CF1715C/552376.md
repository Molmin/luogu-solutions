由于是子区间问题，很容易想到计算每一块的贡献。

计算子区间贡献问题分为两步：计算初始贡献 & 考虑修改后答案的转移。下面分步来讲。

**计算初始贡献**

枚举子区间显然会超时，考虑枚举每一个数字相同的连续块。对于一个连续的块，记其开始位置为 $l$，结束位置为 $r$。它对哪些子区间有贡献呢？记子区间为 $[L,R]$，第一种是 $R>r$ 且 $L \le r$ 的子区间，第二种是 $R \in [l,r]$ 且 $L \le R$ 的子区间。对于第一种子区间，贡献就是 $r(n-r)$；对于第二种子区间，贡献就是 $l+(l+1)+...+r$，循环时统计或者用等差数列公式算即可。

**修改后答案的转移**

不难发现单点修改 $x$，答案的变化只会和 $x,x-1,x+1$ 有关。令修改后 $x$ 位置对应的值为 $a_x'$，则有四种情况会对答案产生影响：

- $a_x \ne a_{x-1},a_x'=a_{x-1}$

- $a_x =a_{x-1},a_x'\ne a_{x-1}$

- $a_x \ne a_{x+1},a_x'=a_{x+1}$

- $a_x=a_{x+1},a_x' \ne a_{x+1}$

贡献的变化计算类似，令子区间为 $[L,R]$，下面以第一种为例：

假设 $[3,5,6]$ 变化为了 $[3,3,6]$，对于 $[L,R] \text{ s.t. }R \ge x,L \le x-1$ 的 $[L,R]$ 答案全部 $-1$，因为原本它包含了 $[3,5]$，而现在只有 $[3,3]$ 了，也就是说它的块数 $-1$。

其它三种计算方法类似。需要注意的是，这种方法对于类似 $[3,5,5]$ 变化为 $[3,3,5]$ 的修改也做到了不重不漏。

### Code：

```c++
#include <bits/stdc++.h>
using namespace std;
#define int long long
int n, m, s, x, y, r, tmp, a[100010];
signed main(){
	scanf ("%lld%lld", &n, &m);
	for (int i=1; i<=n; i++){
		scanf ("%lld", &a[i]);
	}
	for (int i=1; i<=n+1; i++){
		if (a[i] != a[i-1]){
			r = i - 1;
			s += (n - r) * r + tmp;
			tmp = 0;
		}
		tmp += i;
	}
	for (int i=1; i<=m; i++){
		scanf ("%lld%lld", &x, &y);
		if (a[x-1] != a[x] && a[x-1] == y) s -= (x-1) * (n-x+1);
		if (a[x-1] == a[x] && a[x-1] != y) s += (x-1) * (n-x+1);
		if (a[x+1] != a[x] && a[x+1] == y) s -= x * (n-x);
		if (a[x+1] == a[x] && a[x+1] != y) s += x * (n-x);
		a[x] = y;
		printf ("%lld\n", s);
	}
	return 0;
}

```