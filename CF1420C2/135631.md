先看一下如果没有 $q$，也就是 C1 如何做。

两种方法：

### 第一种

设 $f_{i,0/1}$ 为 $i$ 可选可不选，前 $i$ 个能达到的最大值。

其中 $i$ 若选，则 $0$ 代表答案中 $a_i$ 系数为负，$1$ 代表答案中 $a_i$ 系数为正。

若 $i$ 不选，则 $0$ 代表距离 $i$ 最近的一个已选的元素 $a_j$ 在答案中系数为负，$1$ 代表距离 $i$ 最近的一个已选的元素 $a_j$ 在答案中系数为正。

那么就有转移 $f_{i,0}=\max\{f_{i-1,1}-a_i,f_{i-1,0}\}$ 和 $f_{i,1}=\max\{f_{i-1,0}+a_i,f_{i-1,1}\}$。

由于 $a_i$ 一定为正，所以系数为正的数字个数一定比系数为负的数字个数多 $1$，那么答案就是 $f_{n,1}$。

转移只用到了 $i-1$ 的状态，所以可以把第一维去掉。

记得开`long long`。

### 第二种

先给结论：定义 $a_0=a_{n+1}=0$，对于波峰 $i$ 有 $a_i\gt a_{i-1}$ 且 $a_i\gt a_{i+1}$，对于波谷 $i$ 有 $a_i\lt a_{i-1}$ 且 $a_i\gt a_{i+1}$。所有波峰、波谷都要选，波峰系数为正，波谷系数为负。

感性证明：可以考虑一加一减的一个二元组 $(a_i,a_j)$，其中 $i\lt j$。若是选一个波峰和一个波谷一定是局部最优的。若 $a_i$ 不是波峰，对答案贡献会减小，若 $a_j$ 不是波谷，对答案贡献也会减小。所以把所有二元组都统计上一定是最优的。

所以沿途判断是波峰就加、是波谷就减就好。

---

第一种没法继承了，时间复杂度会变成 $\mathcal{O}(n^2)$。

所以考虑怎么把第二种加上修改操作。

每一个 $a_i$ 是否被计入答案、系数是否为正只和 $a_{i-1}$ 与 $a_{i+1}$ 有关，所以修改 $x$ 这个位置所影响的只有 $[x-1,x+1]$ 这个区间的每一个 $a$。所以去掉这些地方的贡献，然后交换一下，再把这些地方贡献统计上就行。

最好用函数封装一下加上贡献和去掉贡献的过程，不然那个代码长的要死。

时间复杂度 $\mathcal{O}(t\cdot(n+q))$，常数巨大（把里面的最长为 $12$ 的循环当做常数），但完全能跑过。

```cpp
typedef long long ll;
const int N = 3e5 + 10;

int n, q, t, a[N];
ll ans;
inline void del(int x) { // 去掉贡献
  if (a[x] > a[x - 1] && a[x] > a[x + 1]) {
    ans -= a[x];
  } else if (a[x] < a[x - 1] && a[x] < a[x + 1]) {
    ans += a[x];
  }
}
inline void add(int x) { // 加上贡献
  if (a[x] > a[x - 1] && a[x] > a[x + 1]) {
    ans += a[x];
  } else if (a[x] < a[x - 1] && a[x] < a[x + 1]) {
    ans -= a[x];
  }
}
inline void main() {
  for (read(t); t--;) {
    read(n), read(q);
    for (int i = 1; i <= n; ++i) { read(a[i]); }
    a[n + 1] = ans = 0; // 多组数据，所以a[n+1]一定要设为0！
    for (int i = 1; i <= n; ++i) { add(i); }
    write(ans), putchar('\n');
    for (int i = 1, l, r; i <= q; ++i) {
      read(l), read(r);
      /* 边界的设定：首先不能超过[1,n]，其次两个循环修改区间不能重合 */
      for (int j = max(1, l - 1); j <= l + 1; ++j) del(j);
      for (int j = max(l + 2, r - 1); j <= min(n, r + 1); ++j) del(j);
      swap(a[l], a[r]);
      for (int j = max(1, l - 1); j <= l + 1; ++j) add(j);
      for (int j = max(l + 2, r - 1); j <= min(n, r + 1); ++j) add(j);
      write(ans), putchar('\n');
    }
  }
}
```
