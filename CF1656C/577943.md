## 题意简述

------------
- 给定 $T$ 组数据，每组数据包括 $n$ 和 $n$ 个非负整数。

- 每次操作可将数列中每个数对一个任意的整数 $x$ 取模。

- 询问是否可以通过一次或多次操作使数列中的每个数相同。

- $x \ge 2$，$1 \leq T \leq 10^4$，$1 \leq n \leq 10^5$，$1 \leq a_i \leq 10^4$。

## 题目分析

------------
本题只要求询问是与否，不要求输出 $x$，所以应该是一道数论题。

### 思路

------------
如果使 $x$ 为最大的那个数，那么最大的那个数会变成 $0$，其它数不变。
每次这样操作就可以使所有大于等于 $2$ 的数变为 $0$。那么，剩下的就是解决剩下的 $0$ 和 $1$ 的问题了。我们可以分类讨论：

第一种情况，所有数都大于等于 $2$ 或等于 $0$，肯定可以使所有数变为 $0$。

第二种情况，同时有 $0$ 和 $1$，因为不能通过操作影响小于 $2$ 的数，所以肯定不能成功。

第三种情况，只有 $1$ 存在，这种情况会比较复杂。我们可以让每个数都对该数减去 $1$ 取模使它变为 $1$。然而如果存在某两个数差值为 $1$ 则必然使小的那个数变为 $0$，不能成功。反之就能是每个数都变成 $0$ 了，成功！

### 细节

------------
对于第三种情况，我们可以对数列从大到小排序，来检查是否存在相差为 $1$ 的数。另外，我们可以可以用两个布尔型变量 $fg$ 和 $fg1$ 来标记是否存在 $1$ 和 $0$，从而进行判断。

**记得清空数组和标记！**

## 代码

------------
```
#include<bits/stdc++.h>
#define mx 200010
using namespace std;
int t,n,a[mx];
bool fg,fg1;
int main(){
	cin>>t;
	while(t--){
		cin>>n;
		memset(a,0,sizeof(a));
		fg=fg1=0;//清空标记 
		for(int i=1;i<=n;i++){
			cin>>a[i];
			if(a[i]==0){//如果有0 
				fg=1;
			}
			if(a[i]==1){//有1 
				fg1=1;
			}
		}
		if(fg==1&&fg1==1){//情况2
			puts("NO");
			continue;
		}
		if(fg1==0){//情况1
			puts("YES");
			continue;
		}
		fg=0;
		sort(a+1,a+1+n);//排序 
		for(int i=2;i<=n;i++){
			if(a[i]-a[i-1]==1){//存在两个数之间差1 
				fg=1;
				break;
			}
		}
		if(fg==1){
			puts("NO");
		}else{
			puts("YES");
		}
	}
	return 0;
}
```
