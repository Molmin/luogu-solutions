### 题意：

有一个长度为 $n$ 的数列 $\{a_i\}$，每次可以把数列所有的数模一个不小于 $2$ 的数，求能否通过若干次操作让整个数列值相等。

### 解法：

分两种情况：

- 最后的数全为 $0$
   
  除了 $1$ 外（题目要求模数不能为 $1$），所有的数都可以通过模它自己来变成 $0$。
  
  于是只要没有出现 $1$，我们就从大到小一个一个模自己（因为当 $x<y$ 时，$x\mod y=x$，不会影响原数），最后达到全为 $0$ 的效果。
  
  举个例子，样例中的 $\{2,5,6,8\}$。
  
  - 整个数列模去 $8$，原数列变为 $\{2,5,6,0\}$。
  - 整个数列模去 $6$，原数列变为 $\{2,5,0,0\}$。
  - 整个数列模去 $5$，原数列变为 $\{2,0,0,0\}$。
  - 整个数列模去 $2$，原数列变为 $\{0,0,0,0\}$。
  
  逐个击破，达到效果。
  
  因此在这种情况下，总能达到题目要求。
  
但是如果出现了 $1$？$1$ 麻烦在它模去任何不小于 $2$ 的数还是 $1$，也就是说如果数列里有 $1$，那么我们只能尽力做到——

- 最后的数全为 $1$

  考虑也从大到小逐个击破。对于数列中的一个数 $x$，我们找一个数 $k$ 使 $x\mod k=1$ 且不会对其它数造成影响。
  
  因为 $k$ 越小，越可能使某个数 $\mod k=0$，因而我们应该取最大的 $k$。
  
  显然，我们要找的 $k$ 就是 $x-1$。如果原数列中存在 $x-1$，那么它模去 $k$ 就会等于 $0$，这样我们就无能为力了，无解。
  
  无解的例子：数列 $\{1,1,4,5,1,4\}$。
  
  - 尝试将整个数列模去 $4$ 使 $5$ 能变为 $1$，但数列中存在 $4$，如果模去 $4$ 数列变为 $\{1,1,0,1,1,0\}$，于是无解。
  
  有解的例子：数列 $\{1,1,45,14\}$。
  
  - 尝试将整个数列模去 $44$ 使 $45$ 能变为 $1$，正好数列中不存在 $44$，于是数列变为 $\{1,1,1,14\}$。
  
  - 尝试将整个数列模去 $13$ 使 $14$ 能变为 $1$，正好数列中不存在 $13$，于是数列变为 $\{1,1,1,1\}$。
  
  这里我们可以通过排序原数组来判断是否有两个数相邻。详见代码。
  
整合两种情况，就能得到代码。

```cpp
namespace{
	const int lim=1e5+2;
	int T;
	int n,a[lim];
	bool tag;
	void solve(){
		n=read();
		F(i,1,<=n) a[i]=read();
		tag=0;
		F(i,1,<=n){
			if(a[i]==1){
				tag=1;//有 1
				break;
			}
		}
		if(tag){
			sort(a+1,a+n+1);
			F(i,1,<n){
				if(a[i]==a[i+1]-1){//如果有两个数相邻，排序后这两个数值一定会在相邻位置出现
					puts("NO");
					return;
				}
			}
		}
		puts("YES");
	}
	void work(){
		T=read();
		while(T--) solve();
	}
}
```

#### 教训：

CF 的操作题做法往往和样例解释有很大差别。本人就因为看了样例解释被出题人限制了思维，卡了一个小时/kk