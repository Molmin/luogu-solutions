## 前言
这题大佬们都讲得很详细了，但这作为我第一道自己想出来的蓝题（早于注册账号），还是要写篇题解纪念一下。

~~PS：本人懒得制作图片，因此用表格代替了，这里向大家道歉~~
## 解析
与多数大佬的**从小往大**推导不同，我们是从**大往小推**，怎么个推法呢？
我们看下面这个例子（P表示公主）
```cpp
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 P 0
0 0 0 0 0 0 0 0
```
我们手头里只有
```cpp
0 1  1 0  1 1 1 1
1 1  1 1  0 1 1 0
```
共4种地毯，我们该怎么铺呢？

首先我们知道**在2×2的格子**中，公主在左上角、右上角......右下角时要分别用1、2......4种毯子，那么在上面的例子中，我们可以将其**分成4份**如下

```cpp
1 1 1 1 2 2 2 2
1 1 1 1 2 2 2 2
1 1 1 1 2 2 2 2
1 1 1 1 2 2 2 2
3 3 3 3 4 4 4 4
3 3 3 3 4 4 4 4
3 3 3 3 4 4 P 4
3 3 3 3 4 4 4 4
```
这下可不就清晰明了了，公主在格子的右下角，咱用一个**大小（指单个格子边长，下同）为4**的4号地毯不就可以**填满剩下三个角**了？

“你是在逗我啊，哪来的这么大的毯子啊”

别着急，咱在草稿纸上动几笔，不难发现规律，下面这个大小为2的毯子，可以这么铺
```cpp
0 0 2 2
0 0 1 2 
2 1 1 3 
2 2 3 3 
```

是不是很有意思？大小为2的巨毯子可以用4个毯子拼得，以此类推，大小为8的巨毯子可由4个大小为2的毯子拼得......

可以知道：**大小为$2^n$的巨毯子可由4个大小为$2^{n-1}$的毯子拼得**，这是个明显的**递归过程**。

“你现在只拼了3个角，剩下**这么大个角**当我眼瞎啊？”

这个咱别着急，我们拼完三个角后，不**就只剩下一个角**了吗？这个角我们按照之前的处理方式（**四等分并填满3个角**）进行可不就行了？

## 程序流程

根据上面的推导，我们得到了下面的程序流程：
$$\text {判断公主在哪个角}$$
$$↓$$
$$\text {算出需要哪种巨毯子，并获取巨毯子大小}$$
$$↓$$
$$\text {递归填补巨毯子，毯子大小为1时输出}$$
$$↓$$
$$\text {回过头来用剩下的角作为参数重新执行程序}$$

这样就是本题的解法了，由于这种方法递归方式特殊（需要**两个递归函数，1个填毯子，1个四等分**），得到的答案顺序会和样例的顺序不同（其实改一下递归函数调用的顺序就好了），但本题是**Special Judge**，结果顺序不影响AC，故请大家放心。
## AC代码

```cpp
#include <bits/stdc++.h>

using namespace std;
//以编译器的痛苦来满足自己快乐的行为（但是方便调试）
#define ul dfs(zx+l-1,zy+l-1,zx,zy,l);//递归做左上角
#define ur dfs(zx+l-1,zy+l,zx,zy+l,l);//递归做右上角
#define dl dfs(zx+l,zy+l-1,zx+l,zy,l);//递归做左下角
#define dr dfs(zx+l,zy+l,zx+l,zy+l,l);//递归做右下角

void dfs(int x,int y,int zx,int zy,int l){
    if(l==1) return;
    l>>=1;
    //左上角 
    if(x-zx<l&&y-zy<l){
        //输出 
        printf("%d %d 1\n",zx+l,zy+l);
        dfs(x,y,zx,zy,l);//继续把有人的区块填满
        //按定理处理大方块
        ur
        dl
        dr 

    }
    //右上角
    if(x-zx<l&&y-zy>=l){
        //输出 
        printf("%d %d 2\n",zx+l,zy+l-1);
        dfs(x,y,zx,zy+l,l);//继续把有人的区块填满
        //按定理处理大方块
        ul
        dl
        dr 
    }
    //左下角
    if(x-zx>=l&&y-zy<l){
        //输出 
        printf("%d %d 3\n",zx+l-1,zy+l);
        dfs(x,y,zx+l,zy,l);//继续把有人的区块填满
        //按定理处理大方块
        ul
        ur
        dr 
    }
    //右下角 
    if(x-zx>=l&&y-zy>=l){
        //输出 
        printf("%d %d 4\n",zx+l-1,zy+l-1);
        dfs(x,y,zx+l,zy+l,l);//继续把有人的区块填满
        //按定理处理大方块
        ul
        ur
        dl
    }
}

int main()
{
    int k,x,y;
    scanf("%d%d%d",&k,&x,&y);
    dfs(x,y,1,1,1<<k);
    return 0;
}
```


## 完结