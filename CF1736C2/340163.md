提出一个时间空间为线性的做法。

首先延承 C1 的做法。让所有 $a_i \gets a_i-i$，判断一个子区间 $[l,r]$ 是否合法，就相当于 $\displaystyle \min_{i=l}^r a_i \geq (1-l)$。

注意到如果子区间 $[l,r]$ 合法，那么 $[l+1,r]$ 一定合法，于是可以使用双指针，在静态的问题中 $O(n)$ 求解。具体的做法是，对于一个 $i$ 求出其极长的合法子区间 $[i,p_i]$，那么答案就是 $\displaystyle \sum_{i=1}^n p_i-i+1$。注意到里面有一些只跟 $i$ 和常数有关的东西可以提出来做其他的计算，对于这部分简单处理不再赘述。

现在问题带上了修改，我们还是直接考虑维护 $p_i$ 的值，分类讨论：

- 如果 $a_x$ 修改之后变小了：之前有一些位置能越过 $x$，但是在修改之后只能停在 $x-1$；   
- 否则：之前有一些位置被卡在了 $x-1$，现在能越过 $x$ 了，被卡在更前面的位置不可能越过 $x$。

先来解决第一个问题。我们需要先找到第一个能越过 $x$ 的位置 $u$，并且找到修改后最远的**可能可以**越过 $x$ 的位置 $d$（这个意思是说，比如当前 $a_i$ 被修改成了 $-1$，那么这个最远的位置就是 $2$，因为 $1-2 = -1$）。那么现在 $\max(d,u)$ 就是实际能越过 $x$ 的位置，它们的 $p$ 值是不会变的。剩下的位置，也就是 $[u,d-1]$（可能是空区间）就只能到 $x-1$ 了。发现我们需要维护 $p$ 值的前后缀和，中间 $[u,d-1]$ 的 $p$ 值都是 $x-1$，这样就能直接算了。

再来看第二个问题。先找到被卡在 $x-1$ 的所有位置，再找到修改后最远的**可能可以**越过 $x$ 的位置 $d$（意义同上嘛）。注意到 $p$ 单调，被卡在 $x-1$ 的所有位置一定构成一个连续的区间 $[l,r]$。当然因为要可以越过 $x$，所以需要让 $l \gets \max(l,d), r \gets \max(r,d)$。然后 $[l,r]$ 里面的所有 $p$ 会发生相同的变化，具体的，$p_l'$ 为 $l$ 之后，从左往右第二个 $i$ 满足 $a_i < 1-l$。注意到这个仍然满足单调性，于是求出 $p$ 之后可以再一次双指针求出 $p'$。对 $p'$ 做一个前缀和，就可以回答查询。

现在留下来的不能线性做出的问题有找到第一个能越过 $x$ 的位置 $u$ 和找到被卡在 $x-1$ 的所有位置。注意到 $x$ 的值域只有 $O(n)$，于是可以 $O(n)$ 预处理这些信息。

时间与空间复杂度均为 $O(n)$。具体实现可以看[提交记录](https://codeforces.com/problemset/submission/1736/175849599)。

Wonderhoy!