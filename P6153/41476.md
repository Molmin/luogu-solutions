对于 $20\%$ 的数据

随便你怎么搞都可以。时间复杂度 $O(?)$

对于 $40\%$ 的数据

不优化的并查集。时间复杂度 $O(n^2)$

对于 $60\%$ 的数据

路径压缩的并查集。时间复杂度 $O(n\log n)$

对于 $80\%$ 的数据

离散化+路径压缩并查集。时间复杂度 $O(m\log m)$

对于 $100\%$ 的数据

如果你看到了这一步，你可以当之前的话都是废话。

初始的答案为 $n$ (即如果 $m=0$ 就有 $n$ 种物品是不同的)

因为每个条件都保证无法由之前的条件推出，那么每次将两种不相等的东西变为相等，所以答案就少了 $1$。也就是说，每个条件都会使答案 $-1$。所以输出 $n-m$ 即可。时间复杂度 $O(1)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	long long n,m;
	cin>>n>>m;
	cout<<n-m;
}
```
