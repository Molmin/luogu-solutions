### 题意
给出一个$n\times m$的矩阵$a$,可将矩阵中若干个元素加一使得矩阵里没有相邻两个数字相同，输出修改后的矩阵。

------------

### 思路
+ 1.奇数不等于偶数(废话)
+ 2.一个奇数一定可以通过加1变成偶数(还是废话)
+ 3.一个偶数一定可以通过加1变成奇数(仍然是废话)

虽然是三条废话，但合起来就是这道题的正解，根据第一条废话，可以知道假如修改后的矩阵是奇数旁边全是偶数，偶数旁边全是奇数，是可以的。根据第二条和第三条废话，可以知道，一定可以通过修改将矩阵中的任何一个数的奇偶性变成想要的。就可以变成奇数旁边全是偶数，偶数旁边全是奇数。
### 代码
```cpp
#include<bits/stdc++.h>//头文件
using namespace std;
int t,n,m,a[105][105];//t组数据，n行，m列，a是原矩阵
int main(){
	cin>>t;
	while(t--){//相当于for(int i=1;i<=t;i++)
		cin>>n>>m;//n行，m列
		for(int i=1;i<=n;i++)
			for(int j=1;j<=m;j++)
				cin>>a[i][j];//输入矩阵
		for(int i=1;i<=n;i++){
			for(int j=1;j<=m;j++){//循环每个点
				if(a[i][j]%2!=(i+j)%2)//每个点的行列坐标之和的奇偶性一定和它相邻的点不同，所以只要输出的数与行列坐标之和的奇偶性相同，就一定与它相邻的点不同
					cout<<a[i][j]+1<<" ";
				else
					cout<<a[i][j]<<" ";
			}				
			cout<<endl;
		}			
	}
}
```
