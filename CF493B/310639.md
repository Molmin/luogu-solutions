## 前言
看到楼上大佬的一堆``if else``，蒟蒻不禁瑟瑟发抖。

这题其实~~是个淼题~~思维含量比较低，~~有手就行~~但比较考验代码能力。、

本蒟蒻的代码可能比较精简~~就24行~~，可能比较容易理解

## 题目大意
[题目传送门](https://www.luogu.com.cn/problem/CF493B)

题目翻译中已经给了大致题意，但是要重新申明的一点是，这里的“字典序”指的是将两人的每一次操作分别按输入顺序存起来，然后比较字典序。

## 分析
这题很显然要维护两个数组对应两个人，将每次操作存入数组中，累加每个人的和与操作长度，接下来就是判断了。

1. 首先，比较总和，我用的是 ```s``` 数组。
2. 其次，如果总和一样，将操作数组 ```a``` 逐位比较，一旦不同，直接返回（比较字典序）。
3. 再次，如果还未返回，那么比较操作长度（比较字典序）。
4. 最后，如果依旧一样，那么返回最后一次操作对应的人。

本蒟蒻用了函数的方式进行比较，具体的到代码里理解吧。

## AC_Code
~~~
#include<bits/stdc++.h>
#define int long long//累加数组会炸int
using namespace std;
const int maxn=12900001;
int n,x,l[29],s[29],a[maxn][2];//l为操作长度，s为操作和，a记录每一次操作
bool judge(){
	if(s[0]!=s[1]) return s[0]<s[1];//比较总和
	for(int i=1;i<=min(l[0],l[1]);i++)//逐位比较操作，注意长度取min
	 if(a[i][0]!=a[i][1])
     return a[i][0]<a[i][1];
	if(l[0]==l[1]) return x<0;//长度一样看最后一次操作，注意x要是全局变量
	else return l[0]<l[1];//否则比较长度
}
signed main(){
	scanf("%lld",&n);
	for(int i=1;i<=n;i++){
		scanf("%lld",&x);
		a[++l[(x<0)]][(x<0)]=abs(x);//第二坐标0表示第一个人，1表示第二个
		s[x<0]+=abs(x);//这里用了一个小技巧，用bool的方式返回坐标可以节省if
	}
	if(judge()) printf("second\n");//1表示第二个人
	else printf("first\n");//否则就是第一个
	return 0;
}
~~~
代码里多次用到了bool,不理解的可以枚举大于、小于两种情况，~~或者点赞关注我~~。