## **~~C++党与Pascal党的福音~~**

## C++解法其一:
为了弄清楚这条题目的本质，我们需要以下几点:

1. int型最多存储31位整形[即正负数都有，范围在$-2^{31}$~$2^{31}-1$]，而unsigned int也是31位，但是存储的是正整数[范围是1~$2^{32}-1$]。
2. C++运算中，若出现溢出，则**自动取模**。举个例子：在unsigned int型当中，计算$2^{32}$+233时，实际的运算是($2^{32}$+233)%$2^{32}$，结果就是233.
3. C++运算中，整数除法都是对零取整的。当然，这题都是非负整数，也没有0什么事了。
	#### ## 综合以上几点，能不能发现什么呢？
    问题让我们求的其实是2进制下交换前后16位，不就是向左移16位，加上左移16位吗？
    
    题目给的样例是**1314520 **
    
    **[0000 0000 0001 0100 0000 1110 1101 1000]**
    
    我们将它左移16位[注:已根据条件2进行取模]:
    
    **[0000 1110 1101 1000 0000 0000 0000 0000]**
    
    以及右移16位:
    
    **[0000 0000 0000 0000 0000 0000 0001 0100]**
    
    结合条件2与条件3，相加两式，得到的即是最终结果:
    
    **[0000 1110 1101 1000 0000 0000 0001 0100]**
    
    因此，代码就很简单了。

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	unsigned int n;
	cin>>n;
	cout<<(n>>16)+(n<<16);
	return 0;
} 
```

## C++解法其二:
观察本题，我们发现，该题需要将原数拆分成两段。这时候我们的位运算&就登场啦
    仍然是那个例子。
    
  **[0000 0000 0001 0100 0000 1110 1101 1000]** 
  
  &0xffff0000: **[0000 0000 0001 0100 0000 0000 0000 0000]** 
 
  &0x0000ffff: **[0000 0000 0000 0000 0000 1110 1101 1000]**  
    
  如何取出某一段呢？很简单，对那一段**做一个&运算**。这里提一个小技巧：C++编译器支持直接书写16进制，方法是0x十六进制数[比如0x00000001就是十进制下的1]。2进制，就是0bXXXX...。
    
   取出前16位，就是&0xffff0000，取后16位，就是&0x0000ffff。位移即可。
    
```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	unsigned int n;
	cin>>n;
	cout<<((n&0xffff0000)>>16)+((n&0x0000ffff)<<16);
	return 0;
} 
```
//注：本解法其实与解法1类似，个人认为解法1更巧妙.
##### 对于Pascal党...
上面的题解应该讲的很清楚了，谜一般的swap函数...
#### 本题尽管是条挺简单的位运算题，但是牵扯到的位运算知识较多，还是比较值的学习与思考的
    