[原题链接](https://www.luogu.com.cn/problem/P2193)

这道题可以算一道 $ \text{DP} $ 的典型题，我们来看一看。

这道题显然是以这个数字序列的长度为基础进行 $\text{DP}$ 的， 但是这还不够。因为如果我们单纯的开一维记录长度的话，我们就无法实现这个要求。

> 第一个数外，所有的数都能被前一个数整除（即是前一个数的倍数）

所以此时我们需要进行升维 $\text{DP}$ 。我们多开一维记录序列中最后一个数，又因为最后一个数一定不会超过 $n$ ，所以空间不会爆。

此时再想一下，我们对于每一个长度的序列，我们必定只能从前一位转移，因为咱们需要每次添加一个数。为了满足题设条件，我们每枚举到一个状态，不对其前面状态进行操作，而是把它能够转移到的状态加上。

我们设 $f(i,j)$ 表示序列长度为 $i$ ，且最后一个数是 $j$ 的方法种数。则我们从后往前加，得
$$f(i,j \times k)+=f(i-1,j)$$

其中 $j \times k \leq n$。

这里就是说，如果最后一个数是 $j \times k$ 的话，那我们可以在长度为 $i-1$ 最后一个数为 $j$ 的序列，后面加上一个 $j \times k$ ，这样的话方法种数就应当加上 $f(i-1,j)$ 。

枚举顺序很自然，第一层枚举位数 $i$ ，第二层枚举上一位数字 $j$ ，第三层枚举 $k$ 。

初始值： $f(1,1-n)=1$

结果： $\sum_{i=1}^{n}f(p,i)$

**温馨提示：别忘了取模！**

话不多说，上代码（有注释）：

```cpp
#include <iostream>
#include <cstring>
using namespace std;
const int PR=1e9+7;//模数
const int NR=2005;
int n,p,f[NR][NR];//f[i][j]表示有i个数的序列中最后一个数为j的种数 
int main()
{
	cin>>n>>p;
	for(int i=1;i<=n;i++) f[1][i]=1;//初始化
	for(int i=1;i<=p;i++)//最外层枚举位数
		for(int j=1;j<=n;j++)//枚举上一位数
			for(int k=1;j*k<=n;k++) 
			{
				f[i][j*k]=(f[i][j*k]+f[i-1][j])%PR;//转移+取模
			}
	int ans=0;
	for(int i=1;i<=n;i++)//求和
		ans=(ans+f[p][i])%PR;//时刻记住要取模
	cout<<ans;
	return 0; 
} 
```

**若有错误，欢迎指出！**

