这题看上去非常的奇怪，连“收敛（converging）”都来了，似乎是道很高大上的题目，完全不可做，但仔细想想似乎比 Div.2 D 还要简单。

别被“收敛”吓到，先研究一下这个操作到底在干什么，会对 $a_i$ 和 $a_{i+1}$ 产生什么样的影响。对比 $a_i$ 和 $a_{i+1}$ 的操作，发现不同只在于一个 $\min, \max$ 的区别和平均数加减 $\frac{b_i}{2}$ 的区别。后面这个区别引起了我们的注意，因为如果取后者，它们的差将变为 $b_i$, 而前一个是 $\min$ 后一个是 $\max$ 意味着它们的差也会取到最大。而且前面是平均数决定了这两个 $\min$ 和 $\max$ 里面的东西要么同时取到更新要么同时取到不更新。

那么这个操作就非常明白了：不断变化两数直到它们的差大于等于 $b_i$。所以如果 $a$ 中两个数原来的差不超过 $b_i$ 那么就会成为 $b_i$，如果一开始就超过了，就不会有任何变化。

然后继续往下看，题目给了我们 $a_i$ 的上界，让我们求可能的个数，那么只要求出下界就好了。

而那个变化已经决定了下界，设第一个数为 $f_1$, 那么第二个最小只能是 $f_1+b_1$, 再下个最小是 $f_1 + b_1 + b_2$, 然后是 $f_1 + b1 + b_2 + b_3$，以此类推。

那么题目就等价于给定了每一个开始的数，和每次要加上的范围，求最后一个数落在给定范围里的方案数。直接背包即可。

代码。

```cpp
#include <cstdio>
#include <algorithm>
const int N = 105, P = 1000000007;
int n, c[N], b[N], m, f1, f[N][N*N], l, r, ans;
int main() {
    scanf("%d", &n);
    for (int i = 1; i <= n; i++) scanf("%d", &c[i]);
    for (int i = 2; i <= n; i++) scanf("%d", &b[i]), b[i] += b[i-1];
    scanf("%d", &m), scanf("%d", &f1);
    f[0][0] = 1;
    for (int i = 1; i <= n; i++) {
        l += b[i] + f1, r += c[i];
        for (int j = std::max(l, 0); j <= r; j++)
            for (int k = 0; k <= c[i]; k++)
                f[i][j] = (f[i][j] + f[i-1][j-k]) % P;
    }
    for (int i = std::max(l, 0); i <= r; i++) ans = (ans + f[n][i]) % P;
    printf("%d", ans);
    return 0;
}
```