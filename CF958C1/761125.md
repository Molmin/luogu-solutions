## CF958C1 题解

### 题目大意
 
有一个包含 $n$ 个正整数的数列，将这个数列分成 $2$ 个非空段，每段的价值为这段的所有数总和 $\bmod$ $p$，你需要使 $2$ 段价值总和最大，请求出这个最大值。

### 需要算法（本题解）：

- 前缀和

### 题目思路

拿到这道题，看到“总和“两个字，我这个蒟蒻一下子就想到了大名鼎鼎的前缀和。那么就简单了，首先是一个简单的前缀和：

```cpp
for(int i=1;i<=n;++i){
    cin>>a[i];
    f[i]=f[i-1]+a[i];//累加前缀和
}
```
然后就是计算最大的总和了，容易发现，在选定第一个段的情况下，剩下一个段一定是唯一的，而选定第一个段的方法一共有 $n$ 种，所以我们可以枚举第一段的最后一个元素，那么这种情况下，第一段的和就是 `f[i]`，而第二段的和就是序列总和减去第一段的和，即为 `f[n]-f[i]`。定义一个变量，取最大值即可。

### AC代码

```cpp
#include<iostream>
#define int long long//一定要开long long啊！
using namespace std;
int n,p,a[100005],f[100005],ans;
signed main(){
	cin>>n>>p;
	for(int i=1;i<=n;++i){
		cin>>a[i];
		f[i]=f[i-1]+a[i];//累加前缀和
	}
	for(int i=1;i<=n;++i){
		ans=max(ans,f[i]%p+(f[n]-f[i])%p);//计算最大值（上面有具体讲解）
	}
	cout<<ans<<endl;//输出
	return 0;
} 
```
