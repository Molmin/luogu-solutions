就是一个在环上的dp。

我们可以考虑把这个环拆一条边，变成链，在链上进行线性dp，这样简单得多。

方便起见，我们把从 $1$ 到 $n$ 的这条链删除，使这张图变成一条链。

我们设 $F[i,j,1]$ 表示前 $i$ 个小时休息了 $j$ 个小时，并且第 $i$ 个小时正在休息，累计恢复体力的最大值。$F[i,j,0]$ 表示前 $i$ 个小时休息了 $j$ 个小时，并且第 $i$ 个小时没有休息，累计恢复体力的最大值。

此时我们需要分类讨论：

- 如果第一个时间段不睡觉或者刚开始睡觉（处于“入睡”状态），也就是常规的dp，不难推出以下结论：

	边界：$F[1,0,0]=0,F[1,1,1]=0$，其余为 `-inf`

   目标：$\max(F[n,b,0],F[n,b,1])$
   
	方程：

$$F[i,j,0]=\max(F[i-1,j,0],F[i-1,j,1])$$

$$F[i,j,1]=\max(F[i-1,j-1,0],F[i-1,j-1,1]+U_i)$$

- 如果第一个时间段在睡觉且不处于“入睡”状态（即睡觉时段和被断开的那个点连在了一起），可以推出以下结论：

	边界：$F[1,1,1]=U_1$ ，其余为 `-inf`

   目标：$F[n,b,1]$
   
	方程：

$$F[i,j,0]=\max(F[i-1,j,0],F[i-1,j,1])$$

$$F[i,j,1]=\max(F[i-1,j-1,0],F[i-1,j-1,1]+U_i)$$

两个结果中最优者就是答案。

讲到这里就可以做 [P6064 [USACO05JAN]Naptime G](https://www.luogu.com.cn/problem/P6064) 这道题了，题意完全相同。

但是本题还需要进行一些空间优化。

由于这个递归只与 $i-1$ 这一行有关，我们不妨进行滚动数组，将上面公式中 $i$ 改成 $i\&1$ 即可。

参考代码：

```cpp
#include<iostream>
#include<cstring>
using namespace std;
#define MAXN 3830
int t,n,b,a[MAXN],f[2][MAXN][2],ans;
int main(){
    cin>>t;
    while(t--){
        cin>>n>>b;
        for(int i=1;i<=n;i++) cin>>a[i];
        memset(f,-0x3f,sizeof(f));
        f[1&1][0][0]=f[1&1][1][1]=0;
        for(int i=2;i<=n;i++){
            for(int j=0;j<=b;j++){
                f[i&1][j][0]=max(f[(i-1)&1][j][0],f[(i-1)&1][j][1]);
                if(j>=1) f[i&1][j][1]=max(f[(i-1)&1][j-1][0],f[(i-1)&1][j-1][1]+a[i]);
            }
        }
        ans=max(f[n&1][b][1],f[n&1][b][0]);
        memset(f,-0x3f,sizeof(f));
        f[1][1][1]=a[1];
        for(int i=2;i<=n;i++){
            for(int j=0;j<=b;j++){
                f[i&1][j][0]=max(f[(i-1)&1][j][0],f[(i-1)&1][j][1]);
                if(j>=1) f[i&1][j][1]=max(f[(i-1)&1][j-1][0],f[(i-1)&1][j-1][1]+a[i]);
            }
        }
        ans=max(ans,f[n&1][b][1]);
        cout<<ans<<endl;
    }
    return 0;
}
```
