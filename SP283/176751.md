~~为了写这道题，注册了SPOJ好久....~~

[双倍经验](https://www.luogu.com.cn/problem/P6064)

[本题题目传送门](https://www.luogu.com.cn/problem/SP283)

## 题目大意：

从一天的 $n$ 段时间中选取 $b$ 段，每个时间段都有其效用值，第 $n$ 个小时与第 1 个小时相连，问能得到的最大效用值。

## 方法：

读题，这是一个环形结构，一般环形结构处理方式是通过枚举断点使环变成线性结构再来计算，最后通过每一次的结果求出答案。

但此题环形结构对于答案的影响仅有是否选取阶段 $n - 1$，所以可以从这里入手，进行两次计算：选取阶段 $n - 1$ 与不选取此阶段。

由于每个阶段是否选取得到的最大值由上一阶段影响，我们使用 DP 求解。

#### 当不选取阶段 $n - 1$ 时

我们用 $f_{i,j,1}$ 表示前 $i$ 个阶段一共选取了 $j$ 个阶段，并且第 $i$ 个阶段被选取。而由于“**每一段睡眠的第一个时间阶段都是“入睡”阶段，而旦不记入效用值**。”所以只有当前一个阶段被选取，才能加上当前阶段的效应值；若前一个阶段没有被选取，则不能加上当前阶段的效应值；从这两种情况中选出最大值：

$f_{i,j,1}=\max(f_{i-1,j-1,0},f_{i-1,j-1,1}+u_i)$

用 $f_{i,j,1}$ 表示前 $i$ 个阶段一共选取了 $j$ 个阶段，并且第 $i$ 个阶段没有被选取。那就不用顾忌什么，直接从上一阶段是否选取这两种情况中得到最大值即可：

$f_{i,j,0}=\max(f_{i-1,j,0},f_{i-1,j,1})$

由于不选取阶段 $n - 1$,故第一个小时不管有没有休息一定是在入睡状态，不会得到效应值。所以：

初始状态：$f_{1,0,0}=f_{1,1,1}=0$,其余皆设为负无穷。

目标是：$\max(f_{n,b,0},f_{n,b,1})$

#### 当选取阶段 $n - 1$ 时

此时我们应强制选取阶段 $n - 1$ 所以在 $n$ 阶段处于入睡状态，1阶段就睡熟了，所以初始状态和目标状态应修改为：

$f_{1,1,1}=u_1$,其余设为负无穷。

目标是 $f_{n,b,1}$。

## 代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int t,n,b;
int dp[3905][3905][2],u[3904];//之前存了两个dp数组，会爆空间，一个数组需要反复初始化 
int main(){
	cin>>t;
	while(t--){
		int ans=0;
		cin>>n>>b;
		for(int i=1;i<=n;i++){
			cin>>u[i];
		}//读入 
		memset(dp,128,sizeof(dp)); 
		dp[1][0][0]=0;
		dp[1][1][1]=0;//第一次初始化，不选n-1的情况 
		for(int i=2;i<=n;i++){
			dp[i][0][0]=dp[i-1][0][0];
			for(int j=1;j<=min(i,b);j++){
				dp[i][j][0]=max(dp[i-1][j][1],dp[i-1][j][0]);
			    dp[i][j][1]=max(dp[i-1][j-1][0],dp[i-1][j-1][1]+u[i]);
			}
		}
		ans=max(dp[n][b][0],dp[n][b][1]);
		memset(dp,128,sizeof(dp));
		dp[1][1][1]=u[1];
		dp[1][0][0]=0;//选n-1的情况 
		for(int i=2;i<=n;i++){
			dp[i][0][0]=dp[i-1][0][0];
			for(int j=1;j<=min(i,b);j++){
				dp[i][j][0]=max(dp[i-1][j][1],dp[i-1][j][0]);
				dp[i][j][1]=max(dp[i-1][j-1][0],dp[i-1][j-1][1]+u[i]);
			}
		}
		ans=max(ans,dp[n][b][1]); 
		printf("%d\n",ans);
	}
	return 0;
} 
```

