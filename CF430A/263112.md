## 题意
- 给定 $n$ 个点和 $m$ 条线段，对每个点染上红色或蓝色。
- 求一种染色方案，使得每条线段包含的红色点和蓝色点个数之差不超过 $1$。
- $1\le n,m\le100$

## 分析
注意到一条线段包含的是一段区间，可以给每个点排个序，

把线段转化为排序后序列上的一段区间，这样问题就变成了：

给你一个长度为 $n$ 的序列和 $m$ 个区间，求一个染色方案，使得每个区间包含的红点和蓝点个数之差不超过 $1$。

直接枚举染色方案时间复杂度是 $O(2^n)$，肯定不行。考虑直接构造合法方案。

当区间长度为 $1$ 时，显然随便染色就可以。

当区间长度为 $2$ 时，把两个点染成不同颜色即可。

当区间长度为 $3$ 时，因为颜色交换不影响答案，所以可以染成 $\text{bbr}$，$\text{rbb}$，$\text{brb}$ 这三种。

哪个更好呢？可以发现对于 $\text{bbr}$，若有另一个区间包含前两个点，就不合法了；$\text{rbb}$ 同理；

而 $\text{brb}$，被它包含的区间都是合法的。

当区间长度为 $4$ 时，我们发现 $\text{brbr}$ 也满足**被它包含的区间都合法**这一性质。

以此类推，只要把序列染成 $\text{brbrbrbr...}$ 这样的，无论区间怎样取，都是合法的。

于是方案就是，把点按照 $x$ 坐标排序，然后交替染色就可以了。

时间复杂度 $O(n\log n)$。

## 代码
```cpp
#include <bits/stdc++.h>
#define N 105
using namespace std;
int n,m;
struct node {
	int x,u;//u存序号
	bool operator <(node a) const {
		return x<a.x;
	}
} a[N];
void init() {
	for(int i=1;i<=n;++i) {
		scanf("%d",&a[i].x);
		a[i].u=i;
	}
	//甚至不需要输入线段
}
int ans[N];
int main() {
	scanf("%d%d",&n,&m);
	init();
	sort(a+1,a+1+n);
	for(int i=1;i<=n;++i) {
		ans[a[i].u]=i&1;//按照奇偶性就是交替染色
	}
	for(int i=1;i<=n;++i) {
		printf("%d ",ans[i]);
	}
	return 0;
}
```