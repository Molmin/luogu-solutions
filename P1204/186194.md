## 差分的崛起！！！

这个题是我在找线段树的时候偶然找到，想出思路：

```
对于每一段挤奶的时间，我们就在该段的时间轴上均加一，这样只要有挤奶的时间段就一定不是0（要么是1，要么是2......），由此，在找最大的无人挤奶的时间就是找时间轴上连续为0的最长长度，至少一人挤奶的时间就是找时间轴上连续不为0的最长长度
```

------------

（咦，差分好像更容易<小声bb>）

------------
于是花了半个小时调出了以下代码：

```
看代码之前要强调一下几个坑点：

1、文中说的区间是左闭右开（理解为左开右闭也可以）所以我在差分数组中直接把y[b+1]++变成了y[b]++；

2、注意边界的判断（这个题主要体现在对差分求完前缀和之后的第一个0的元素要统计上~）
```
### 话不多说，上代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int lon1=1,lon=1,start=1000000,end=-1,a,b,y[1000000],n,m,ans1=-1,ans2=-1; 
bool flag;
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
		scanf("%d%d",&a,&b);
		start=min(start,a);
		end=max(end,b);
		y[a]+=1;
		y[b]-=1;//这里是左闭右开区间 
	}
	for(int i=1;i<=end;i++)
	{
		y[i]=y[i-1]+y[i]; 
		if(y[i]==0&&y[i-1]==0&&i>=start+1)
		//如果条件符合，就说明了第一个元素也是0，直接lon初始值赋为1即可 
		{
			lon++;
			ans2=max(ans2,lon);
		}
		else
		{
			lon=1;//初始值是1，为了判断加上第一个0 
		}
		if(y[i]>=1&&y[i-1]>=1&&i>=start+1)//同上 
		{
			lon1++;
			ans1=max(ans1,lon1);
		}
		else
		{
			lon1=1;
		}
	}
	if(ans1==-1)//输出稍微一判即可 
	{
		printf("0 %d",ans2);
		return 0;
	}
	if(ans2==-1)
	{
		printf("%d 0",ans1);
		return 0;
	}
	printf("%d %d\n",ans1,ans2);
	return 0;//完结撒花 
}
```
管理大大求过，也辛苦大家看蒟蒻的题解了