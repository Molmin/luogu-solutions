按照开始时间升序排序，然后从左到右扫一遍，复杂度是O(nlogn+n)的（排序+扫一遍，用快速排序）。

所谓从左到右扫一遍，就是记录一个当前区间， 如果下一个区间是当前区间的子区间，跳过。 如果下一个区间和当前区间相交，就合并两个区间放入当前区间， 否则就检查当前区间的最小边界（min）与最大边界（max）的距离（max - min)是不是比连续有人工作的时间（work)要大，将新区间作为当前区间，并且检查新区间与上一区间的间隔（data[point].start - max)是否大于没有人工作的时间的当前最大值（nowork)，然后继续往右扫。

不贴代码啦~~
