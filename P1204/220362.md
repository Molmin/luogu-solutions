~~这就是个水题，一旦知道方法就很容易~~

however，坑还是有的

目录

1.方法

2.错误记录

3.坑点

4.代码

1.方法

这题用差分和一维前缀和做

会的神犇，请跳过这里

如果不会，请看一下举例

假设此时你在做一道数学题

说给出10个数都是0，然后呢，第一个数到第三个数加6，第

二个数到第八个数加9，最后把第一个数到第十个数加10086

请写出现在第一个数到第十个数（注意每次加包括首尾）

我们一般人就是正常的加法，对吧？

第一次加完：6 6 6 0 0 0 0 0 0 0

第二次加完：6 15 15 9 9 9 9 9 9 0

第三次加完：10092 10101 10101 10095 10095 10095 10095 10095 10095 10086

就这些了

但是呢，我们现在可以这么做，算差。

我们聚焦到第一次

是不是第一个数和第二个数之间的差不变（因为同加一个数，差不变，数学）

第二个和第三个，同理

但是第三个和第四个则差有变化，减少了6（此时差可能负数，均为，第n个-第n-1个）

还有第一个和第零个，增多了6

而此时把差加起来

神奇的事情发生了

竟然和原结果一样

那是不是所有的都可以1这么加呢

是的，可以

而刚刚的求差就是差分，求和就是前缀和

然后就读完

最后就更新最大值就行了，但是记得当变换状态时要初始化

2.错误记录

1）8个TLE

原因：用的初始方法

2）8个WA

原因：没有认真读题

3）AC

终于对了

3.坑（就一个，但很多人都忽视了）

1）就是每次加的时候是开始时间到结束时间-1都加上一而不是结束时间也要加一

4.这里是大家期待已久的代码

```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
using namespace std;
int n;
int a[5005],b[5005];
int people[1000005];
int mintime=10000005;
int maxtime=-1;
int time1=0;
int time2=0;
int time3=0;
int time4=0;
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i]>>b[i];
		people[a[i]]+=1;
		people[b[i]]-=1;
		mintime=min(mintime,a[i]);
		maxtime=max(maxtime,b[i]);
	}
	for(int i=mintime;i<=maxtime;i++){
		people[i]+=people[i-1];
		if(people[i]>0){
			time4=max(time2,time4);
			time2=0;
			time1+=1;
		}else{
			time3=max(time1,time3);
			time1=0;
			time2+=1;
		}
	}
	cout<<time3<<" "<<time4;
	return 0;
}
```

~~莫抄袭，没了AC记录，空悲切~~