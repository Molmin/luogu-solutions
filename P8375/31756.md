做法来自 [水军带你飞](https://www.luogu.com.cn/user/50558)，不太清楚怎么想到的（可能是比大小转 01？），这里只描述做法。

注意到关键点是一条链，拓扑序已知，所以可以对于非关键点，设 $s_u$ 表示可达 $u$ 的最大标号关键点，$t_u$ 表示 $u$ 可达的最小标号关键点。每次暴力 DFS 维护 $s, t$，一旦存在 $s_u \ge t_u$ （称 $u$ 不合法）说明出现环。

维护 $s, t$ 的过程难以直接优化，考虑对于值域建分治树，根节点是 $[-1, k]$，每个节点均分成两个子节点。将 $[s_u, t_u]$ 视为区间，并记录包含 $[s_u, t_u]$ 的极小节点 $p_u$。我们只维护 $p_u$ 的变化，这样若 $p_u$ 为叶子说明出现不合法情况。

注意到区间有性质：（$u, v$ 可达指 $u$ 可达 $v$ 或 $v$ 可达 $u$）

- 若有边 $u \to v$，则 $s_u \le s_v, t_u \le t_v$。

如果 $u, v$ 的区间不交，则 $u, v$ 的区间缩小不会互相影响，否则 $u, v$ 一定有祖先-后代关系。

1. 如果 $p_u = p_v$，则若 $p_u$ 不变，则 $p_v$ 一定不变。
2. 否则不妨假设 $v$ 可达 $u$，且 $u$ 不可达 $v$，$v$ 在 $u$ 的左子树中：若 $u$ 会更新 $v$，则 $t_u$ 必定小于等于分治区间的中点 $mid$，（因为 $t_v \le mid$），因此 $p_u$ 变化是 $u$ 更新 $v$ 的必要条件。其他情况是类似的。

因此我们只需在 $p_u$ 变化时暴力扫描 $u$ 的邻边更新，并递归地处理其他点 $p$ 被更新的情况即可。

我们没有处理同层点之间的更新，但如果 $u$ 的层数变化（假设是因为 $t_u$ 变化），则可能影响 $s_u$ 的点 $v$ 层数也会变化（因为必有 $p_u = p_v$，否则与上述第二条矛盾），从而也会遍历邻边，则此时 $s_u$ 同样可以被正确更新。

因为每个点 $p_u$ 只会变化 $\log k$ 次，而每次会遍历 $u$ 的邻边，所以时间复杂度 $\mathcal O(m \log k)$。