### 题目描述
- 给定一个长度为 $n$ 的二进制串 $a$。
- 对于每一次操作，可以选定含有连续的 1 的块进行左移或右移。
- 求最少的操作次数使得所有的 1 相邻。

### 题目分析

我们可以将题目转化。转化为：

> 求最少的操作次数使得给定的第一个 1（下标为 $l$）和最后一个 1（下标为 $r$）中没有 0。

这样，**就可以把原来的移动块变成消去 0**。

因此，最少的结果应该为在 $a_l,a_r$ 中的 0 的个数。

时间复杂度：$\mathcal O(t\cdot n)$。

### 部分代码

```cpp
while (a[l] == 0)
	l++;
r = n - 1;
while (a[r] == 0)
	r--;
for (int i = l; i <= r; i++)
	if (a[i] == 0)
		ans++;
        
```