# 分析
这 一 道 题 比 较 简 单 ，  通 过 思 考 就 可 以 发 现 ， 无论 怎 么 转， 对 立 面 的 关 系 都 是 不 会 变 的，也 就 是 说 每 一 个 相  对 的 面 无 论 怎 么 转 他 们 两 个 还 是 相 对 的。根 据 这  个 定 理，我 们 通 过 桶 排 的 思 想 ，使 用 $\ b\ $ 数 组，把 第 一 个 输 入 的 骰 子 的 对 立  面 加 到 相 符 的 $\ b_{i,j} \ $去 ，再 把 第 二 个 输 入 的 骰 子 的 对 立 面与 相 符 的   $\ b_{i,j}\ $减 去， 再 判 断 每 个 $ \ b_{i,j} \ $是 否 为 0，   最 后 输 出 就 可 以 了.

# Code

```cpp
#include<bits/stdc++.h>
using namespace std;
bool ans=false;//定义标记变量，最后好输出
int main(){
	string a;
	int b[130][130];
	while(cin >> a){//输入字符串
		ans=false;
		memset(b,0,sizeof b);
		b[a[0]][a[5]]++,b[a[1]][a[4]]++,b[a[2]][a[3]]++;//把每个对立面加或减去，得到有没有一个对立面没有减完
		b[a[5]][a[0]]++,b[a[4]][a[1]]++,b[a[3]][a[2]]++;
		b[a[6]][a[11]]--,b[a[7]][a[10]]--,b[a[8]][a[9]]--;
		b[a[11]][a[6]]--,b[a[10]][a[7]]--,b[a[9]][a[8]]--;
		for(int i=0;i<=128;++i){//把每一个字符循环一遍，枚举出有没有不是一样的，也就是有没有b[i][j]不为0的。
			for(int j=0;j<=128;++j){
				if(b[i][j]!=0){
					ans=true;
					break;
				}
			}
		}
		if(ans==false){//分类输出
			cout << "TRUE" << endl;//如果是一样的
		}else{
			cout << "FALSE" << endl;//如果不一样
		}
		memset(b,0,sizeof(b));
	}
	return 0;
}
```