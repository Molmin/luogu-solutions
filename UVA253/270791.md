### 题目分析
第一眼看到，思路：打表！

打出所有能通过旋转`123456`得到的数列，再比较两端字符串即可。

那么一共有多少种情况呢？

三个方向，每个方向可能转0~3次，因此一共有 $4^3=64$ 种。对于打表来说，这个数未免稍微大了一点（毕竟你得花精力算出每一个数列）。

因此我们可以采用部分打表：将每一个方向的三个数列打出来，那么只要经过一些简易的计算就可以达到原先的效果了。这属于 **用时间换空间** 的一种方式（事实上你省下的不仅有空间还有码量）。

### 代码
首先简单介绍一下表的计算方法。（这种东西肯定是手算更快）

这是一个普通的色子:

![](https://s3.ax1x.com/2021/01/08/suI8v6.png)

我们把它向前转 $90\degree$:

![](https://s3.ax1x.com/2021/01/08/suIUVe.png)

然后根据位置可以知道这个色子用`513462`来表示。

将9种情况全部写出来：

```cpp
const int f[5][5][10]=
{
	{{},{0,5,1,3,4,6,2},{0,2,6,3,4,1,5},{0,6,5,3,4,2,1}},
	{{},{0,1,4,2,5,3,6},{0,1,3,5,2,4,6},{0,1,5,4,3,2,6}},
	{{},{0,4,2,1,6,5,3},{0,3,2,6,1,5,4},{0,6,2,4,3,5,1}}
};
```
我们可以发现，同一行三个数列的顺序是无关紧要的，行的顺序也是无挂紧要的，因为每一个组合都会枚举到。

把初始情况也写出来：
```cpp
const int t[10]={0,1,2,3,4,5,6};
```

于是表就生成好了。

输入的时候先读进一个字符串，再将后六个字符分给另一个：
```cpp
for(int i=1;i<=6;++i) s2[i]=s1[i+6];
```

计算的时候我们用一个序列 $seq$ 来表示当前枚举到哪一种转法，序列生成完成后逐一对比即可：
```cpp
for(int i=1;i<=6;++i) 
	if(s1[i]!=s2[a[i]]){flag=false;break;}
if(flag) return true;
```

旋转的时候先把 $a$ 设置成初始序列，然后对 $seq$ 里的三个量逐一操作（如果是0就跳过），注意需要开辟临时空间，否则 $a$ 数组将在计算完成之前被修改，结果会出错（就像归并排序一样）。

```cpp
for(int j=1;j<=6;++j)
	tmp[j]=f[i][seq[i]][a[j]];
memcpy(a,tmp,sizeof(a));
```
注意不要把 $i$ 和 $seq[i]$ 以及 $i$ 和 $j$ 弄混了。全部代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
const int t[10]={0,1,2,3,4,5,6};
const int f[5][5][10]=
{
	{{},{0,5,1,3,4,6,2},{0,2,6,3,4,1,5},{0,6,5,3,4,2,1}},
	{{},{0,1,4,2,5,3,6},{0,1,3,5,2,4,6},{0,1,5,4,3,2,6}},
	{{},{0,4,2,1,6,5,3},{0,3,2,6,1,5,4},{0,6,2,4,3,5,1}}
};
int a[10],tmp[10],seq[3]; 
char s1[20],s2[20];
bool flag;
void rotate(int* S)
{
	memcpy(a,t,sizeof(a));
	for(int i=0;i<3;++i) if(seq[i])
	{
		for(int j=1;j<=6;++j)
			tmp[j]=f[i][seq[i]][a[j]];
		memcpy(a,tmp,sizeof(a));
	}
}
bool solve()
{
	for(seq[0]=0;seq[0]<=3;++seq[0]) 
		for(seq[1]=0;seq[1]<=3;++seq[1]) 
			for(seq[2]=0;seq[2]<=3;++seq[2])
			{
				rotate(seq); flag=true;
				for(int i=1;i<=6;++i) 
					if(s1[i]!=s2[a[i]]){flag=false;break;}
				if(flag) return true;
			}
	return false;
}
int main()
{
	while(~scanf("%s",s1+1))
	{
		for(int i=1;i<=6;++i) s2[i]=s1[i+6];
		if(solve()) printf("TRUE\n");
		else printf("FALSE\n");
	}
	return 0;
}
```
此题的解法多种多样，全部打表也不是不可以（紫书的标程似乎就是全部打表），但部分打表相对来说更省码量。不论使用什么方法，基本的空间想象力或者三维绘图能力都是必须的。

$$\texttt{The End.}$$