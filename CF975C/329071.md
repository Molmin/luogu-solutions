[点我看题](https://www.luogu.com.cn/problem/CF975C)

题目大意：

```
有n个武士站成一列，每个武士有自己的血量。

一个人射箭攻击他们，每箭造成一点伤害。武士按照给定的顺序承受伤害。

如果血量被消耗完了，那么武士就会死掉，而下一次伤害会落到下一个武士身上。

如果一轮攻击之后，所有的武士都死了，那么他们会立即复活。

给出若干个询问，问每轮攻击之后还剩多少武士活着。
```

看到dalao们都用 $STL$ 的 $upper$__$bound$ 来二分，像我这种蒟蒻表示虽然很厉害，但还是自己手写一下二分更有助于理解与锻炼。于是，就有了这篇二分题解。

思路：二分最后一个被打倒的武士位置，维护一个前缀和，判断目前的伤害能否使当前这个武士死亡，然后继续进行二分。

方法（以一次询问为例）：

- $1.$ 输入射出的箭数；

- $2.$ 二分查找能使哪一个武士最后死亡；

- $3.$ 判断是否可行；

- $4.$ 根据上一步结果更新答案并修改范围，同时记录修改起点；

- $5.$ 继续二分。

代码：

```cpp
#include<bits/stdc++.h>
#define LL long long//个人习惯 
using namespace std;
LL n,q,a,k,h,s[200005];//n、q、a和k如题意，h是总伤害，s是前缀和 
LL fid(LL x)//fid函数是用来寻找最后一个被打倒的武士位置的 
{
	LL l=1,r=n,mid;//l，r和mid分别是二分的左右区间和当前枚举的位置
	while(l<=r)//二分板子 
	{
		mid=l+((r-l)>>1);//防止爆掉（等价于（l+r）/2） 
		if(s[mid]<=x)l=mid+1;//如果可行，扩大上界    
		else r=mid-1;//如果不可行，缩小下界
	}
	return l;//返回结果 
}
int main()
{
	scanf("%lld%lld",&n,&q);//输入 
	for(LL i=1;i<=n;i++)scanf("%lld",&a),s[i]=s[i-1]+a;//输入的同时计算前缀和	
	for(LL i=1;i<=q;i++)//q次询问 
	{
		scanf("%lld",&k);
		h+=k;//总伤害加上这次的伤害 
		LL p=fid(h)-1;//p是找到的一个被打倒的武士位置 
		if(p>=n)p=0,h=0;//如果全杀光了，就会全部复活 
		printf("%lld\n",n-p);//输出剩余武士数 
	}
	return 0;//结束程序 
}
```