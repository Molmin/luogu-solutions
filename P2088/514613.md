### ~~蒟蒻~~的题解。

------------
话不多说，开始上正菜。
对于这道题，只需要用**模拟+贪心**就行了。
初读题目，可能~~特别~~懵逼，但理解清楚后就感觉茅塞顿开。本题有两个难点，**一是考虑时间成本，二是考虑洗哪一台榨汁机。**如果想通了这两个问题，那么这道题也就解出来了。

------------
所以，这道题不能只统计出现了多少种果汁，还要用时间来**模拟**。

举个栗子。比如数据为
3 10
1
2
3
5
4
3
2
1
3
1

 1 用一台， 2 用一台， 3 用一台，在 5 那里应该考虑洗哪有台榨汁机。

从 3 2 1 那里看出 1 是后榨，所以就洗 1 。

同理，应该在 4 那里洗 5 ，因为 5 在后面没有了。

接着， 3 榨过， 2 榨过，到 1 时应该洗 4 ，原理前面讲过。

------------
想通了这些，这道题迎刃而解。话不多说，我们直接上完整代码。
```cpp
#include <bits/stdc++.h>
using namespace std;
bool px(int a,int b)
{
	return a>b;
}
int a[105],b[15],ans;
int main()
{
	int k,n,i,j=1,l,q,max=-1;
	cin>>k>>n;
	for(i=1; i<=n; i++)
		cin>>a[i];//读入
	for(i=1; i<=n; i++)
	{
		int x=0;
		for(l=1; l<=j; l++)
		{
			if(a[i]==b[l]){x=1; break;}
		}//如果打过种果汁，就不用洗榨汁机了
		if(x==1) continue;//如果打过种果汁，退出这次循环
		else
		{
			if(j<=k)
			{
				b[j]=a[i];
				j++;
			}//如果榨汁机还够，直接用1台榨汁机
			else
			{
				max=0;
				int c[j+5]={0};
				x=0;
				for(q=1; q<=j-1; q++)
				{
					for(l=i+1; l<=n; l++)
					{
						if(b[q]==a[l]){c[q]=l; break;}
					}//如果榨汁机不够，且打过种果汁，就不用洗榨汁机了
					if(c[q]==0){b[q]=a[i]; ans++; x=1; break;}如果没有打过种果汁，就洗1次榨汁机
					else
					{
						if(max<c[q])max=c[q];
					}//迭代最大值
				}
				if(x==0)
				{
					for(q=1; q<=j-1; q++)
					{
						if(b[q]==a[max]){b[q]=a[i]; ans++; x=1;}
					}//如果这种果汁打过，就找越在后面大的果汁
					if(x==0)
					{
						b[j-1]=a[i];
						ans++;
					}//如果后面没有这种果汁了，就把这台榨汁机洗了
				}
			}
		}
	}
	cout<<ans<<endl;
	return 0;
}
```
**记得点赞！**