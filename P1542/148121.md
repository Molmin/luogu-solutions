这是一道二分答案题(标签上明明白白的写着呢)

简单介绍一下二分: ~~(大佬请自行跳过)~~

所谓二分答案, 就是一种暴力枚举的升级版(个人见解), 

每次寻找可能的所有答案中最中间的那个并和标准答案满足的条件进行比较, 

由不同的比较结果推出最终答案.

比如说大家应该都玩过的猜数字游戏, 

每次都是猜范围两个端点的平均数以筛掉一半的错解, 

使总体复杂度(猜的次数)最优$(logn)$.

.

那么我们自然就可以想到将车的速度从$0$到$1e7$进行二分, 

(因为距离最大$1e7$, 而且保证初始时间$x[i]$递增且为整数, 那么总时间最低为1, 所以速度最大就是$1e7$啦)

并且如果发现这个速度使得在某段路中其到达时间$t$大于结束时间$y[i]$, 那么就说明这个速度过慢, 

继续在比这个速度快那一半区间查找, 否则速度过慢, 

当左右边界值差小于一个设定的数值$opt$时, 终止循环即可

## 坑点注意:
- 这道题说"若到达某一个地方的时间早于可以签收的时间段，则必须在这个地方停留至可以签收", 所以如果到达时$t<x[i]$, 那么必须等到$x[i]$才能继续出发

- 这道题说保留两位小数, 但是我在上文中说的$opt$却不可以设置成$1e-2$或$1e-3$, 至少要$1e-5$, 否则会被**卡精度**

- 就算注意到了以上两点, 这道题也只有90分, 最后一个点玄学WA是因为double精度不够, **要开long double**, 并且使用对应的输入输出函数!

献上码风奇特的代码(含注释)
```cpp
#include <bits/stdc++.h>
using namespace std;
int n,x[200005],y[200005],s[200005]; //变量描述如题
long double opt=1e-8;  //这里我开了1e-8反正不会TLE
int main() {
	cin>>n;
	for(int i=1;i<=n;i++)scanf("%d%d%d",&x[i],&y[i],&s[i]);
	long double l=0,r=1e7,ans=0;  //准备二分
	while(r-l>opt){ //这里如果设成r>l容易进入类似死循环的过程
		long double mid=(long double)(l+r)/2.0,t=0;  
		bool ck=1;
		for(int i=1;i<=n;i++){ //对于当前"答案"mid进行判断
			t+=(long double)s[i]*1.0/mid; //模拟运送包裹的过程
			if(t<x[i])t=x[i]; //见坑点1
			if(t>y[i]){
				ck=0;break; //速度太慢,加速
			}
		}
		if(ck)r=mid-opt; //速度可以再慢一些
		else ans=max(ans,mid),l=mid+opt; //要加速
	}
	printf("%.2LF",ans); //long double 输出
	return 0;
}
```