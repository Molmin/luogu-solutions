显然是一道背包问题。根据样例可以判断是01背包。

# 因此这是一道水dp。

水题的好处在于可以任性地发挥，~~例如当年的A+B Problem。~~

根据题意，选与不选都有价值。这就很奇怪。根据平时做的题目来看，不选价值为0，选择价值为正。

### 那么进入正题

我们是否可以把输掉得到的经验看作一个基础值，在这之上加上一个加成时，就变成了胜利获得的经验呢？

## 这样一来，本题就变成了纯粹的01背包。

将基础值存放在$sum$变量里，最后加上得到的最优解，乘5，得到答案。

下面是$cpp$代码。（本来想用$c$实现，但是$c$没有$long$ $long$，会炸）

```cpp
#include<bits/stdc++.h>
using namespace std;
int read()//快读
{
	int re=0;
	char c=getchar();
	while(c>'9'||c<'0'&&c!='-')c=getchar();
	if(c=='-')
	{
		c=getchar();
		while(c<='9'&&c>='0')
		{
			re=(re<<1)+(re<<3)-'0'+c;
			c=getchar();
		}
		return -re;
	}
	while(c<='9'&&c>='0')
	{
		re=(re<<1)+(re<<3)-'0'+c;
		c=getchar();
	}
	return re;
}
long long n,v,lc,wc,w,opt[1001],sum;//其实opt[]开long long就可以了
int main()
{
	n=read();
	v=read();
	while(n--)
	{
		sum+=lc=read();//sum加上基础值
		wc=read()-lc;//加成值
		w=read();
		for(register int j=v;j>=w;--j)if(opt[j]<opt[j-w]+wc)opt[j]=opt[j-w]+wc;//经典01背包状态转移
	}
	sum+=opt[v];
	printf("%lld\n",(sum<<2)+sum);//位运算版*5
	return 0;//结束，AC
}
```

细心的同学会发现……

# 数组竟然只有$opt[]$一个？？？

没错，下面的才是重点。

在比赛过程中，我们有时为了满足空间要求，必须对数组进行**降维打击**（《三体3》乱入）。例如01背包的基本实现中，$opt[]$本身是$opt[][]$，为了避免空间冗余，才将其压缩至一维。 $P1002$过河卒 的滚动数组题解正是这个道理。

我们在做背包时，往往会用数组读入，但是我们有没有想过，ci和wi在程序中出现了几次？

## 输入一次，状态转移一次。

那么，既然我们已经把背包容量另先读入了，我们就可以一边读入c和w一边进行状态转移，不仅减少了O(n)的空间复杂度，还使编程复杂度大大降低，不失为一种有效的优化方式。

# 最后，资瓷洛谷！希望洛谷的小伙伴们能在比赛中取得佳绩！