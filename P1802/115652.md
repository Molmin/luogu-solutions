蒟蒻的dp一直不好，可能有的不好理解不够详细甚至会出错，~~还请大家关爱我这样的蒟蒻。~~

首先，打这个人输掉的情况，属性药是一定不用的（感觉有点贪心的思想） ，如果用了会构成浪费，影响赢掉的比赛场数。

dp的过程也并不难想，既然有两种情况可以选择，那么就要转移两次，鉴于两次转移赢掉的需要"嗑药"，而输的比赛根据上面所说的是不用"嗑药"的，
因此两者的转移的范围也是不同的，要分开写。

写这道题时我没有用滚动数组，原因是一开始没有考虑到滚动数组的合理性，总觉得既然每个人都要用，就必须确定是从上一个人转移过来，我想先说说这个
思路。

既然每个人都要用，所以写max(f[i][j],f[i-1][j-w[i]]+c2[i])（i代表第几个对手，j是用的药物的数量），关于理解这句代码可以考虑第一次来到这里比较时，因为起初
f[i][j]为0，这样写能保证第一次比较一定会存下 f[i-1][j-w[i]]+c2[i]的值，这也就意味着i这个对手一定会参与最后的解的构成（这句话可能说的不那么好理解，还请大家仔细思考，~~蒟蒻语文水平欠佳~~）。

至于滚动数组，既然失败的情况中不用消耗药，那么这种情况对于滚动数组来说是"没有消耗而加上价值"，这种情况没有比较（max函数），因此一定加到数组所表达的情况中，这便保证了每个对手一定会被至少"对战"一次。蒟蒻自己感觉滚动数组的写法还是不太好理解的，如果有像我一样的蒟蒻，建议还是要先理解透彻非滚动数组的写法。

最后一个点好像要开long long处理，大家注意下。 

滚动数组的代码因为不是很懂就没有再写，大家可以参考其他大佬的题解进一步学习。

```cpp
#include<iostream>
using namespace std;
long long c1[10000]={0},c2[10000]={0},w[10000]={0},f[1010][1010]={0};
int main()
{
	int n,m;
	cin>>n>>m;
	for(int i=1;i<=n;i++)
	{
		cin>>c1[i]>>c2[i]>>w[i];
	}
	for(int i=1;i<=n;i++)
	{
		for(int j=m;j>=w[i];j--)
		{
			f[i][j]=max(f[i][j],f[i-1][j-w[i]]+c2[i]);
		}
		for(int j=m;j>=0;j--)
		{
			f[i][j]=max(f[i][j],f[i-1][j]+c1[i]);
		}
	}
	cout<<f[n][m]*5;
	return 0;
} 
 
```
