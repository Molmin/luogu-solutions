我们单独对每个目标 $i$ 考虑它是否能被射击到，然后求和即可得到答案。

考虑一个射击到目标 $i$ 的顺序，它的最后一发子弹会击中目标，而之前的子弹都是在清理障碍。

设最后一发子弹是从射击点 $j$ 射向目标 $i$ 的，把路径上的障碍一一列出。

则枚举一个障碍 $x$，使用另一个射击点 $y$ 把这个障碍击中。

则我们称从 $y$ 射击击中障碍的“目的”是为了给 $j \to i$ “清障”，然后连一条从 $y$ 到 $j$ 的有向边。

从 $y$ 射向 $x$ 的路径上可能还有障碍，这样下去把所有的“目的”链连出来。

容易发现“目的”关系连成了一棵 DAG（这是因为某一次“清障”可能会让两个或更多的未来的射击受益）。

但是如果我们为目标排个序，优先考虑优先级更大的目标，则这个 DAG 可以看成一棵有序树。

也就是说同一个节点下的子树，排在前面的子树可以影响排在后面的（前面的“清障”会对未来产生影响）。

那么我们枚举这棵树的 DFS 序，然后每次令 DFS 序的第一个数击中要求目标，然后递归考虑障碍即可。

递归层数最多为 $k$ 层，所以时间复杂度为 $\mathcal O (n \cdot k! \cdot k)$。

要注意的是障碍的判断，如果用极角序排序的话要注意精度，我使用 `double` 和 `atan2` 被出题人卡精度了。

时间复杂度为 $\mathcal O (n \cdot k! \cdot k)$，[评测链接](https://codeforces.com/contest/698/submission/72421569)。