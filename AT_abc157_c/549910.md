首先，还是那句话：如果一道红题，有一个人反反复复，耗时8小时，交了15遍才过，请不要怀疑这道题的难度。因为那个蒟蒻 $\cdots$

是我。

不谈这些事情了，我们先看一眼题目。

## 题目大意

我们要找出最小的 $n$ 位数，使得对于第 $s_i$ 位上的数字是 $c_i$。如果不满足以上条件，则输出 $-1$。

## 解题思路

首先，要保证第 $s_i$ 位上的数是 $c_i$，用整型变量很明显不太合适。我们维持一个数组 $a$，$a_i$ 表示这个数的第 $i$ 位，这样就方便修改一个单独的位了。

而如果，第 $x$ 位上既是 $y$，也是 $z$，当 $y$ 与 $z$ 不等时，整个数也就不可能满足要求，这时候直接输出 $-1$ 即可。

到这里，似乎整道题还很简单嘛！那有什么值得某人连错 14 遍呢？

## 坑

不难注意到，当 $n$ 是 $1$，且不进行任何操作的时候，明显应该输出 $0$，而不像其他多位数一样，首位没有值的时候强行把它赋值为$1$。那么，整道题就做完啦。

献上AC代码！

## AC code

```cpp
#include<bits/stdc++.h>

using namespace std;

int a[100010];

bool flag[100010];//判断每一位是否被改动过

int main()
{
    int n, m;
    cin >> n >> m;
    if (n == 1 && !m) //特判，当n是1且m是0的时候，输出0而不是1
    {
        cout << 0 << endl;
        return 0;
    }
    while (m--)
    {
        int x, y;
        cin >> x >> y;
        if (!x || x > n || (flag[x] && a[x] != y) || (x == 1 && y == 0 && n >= 2) || y < 0 || y > 9)
        {
            cout << -1 << endl;
            return 0;
        }//判断是否可行
        else 
        {
            a[x] = y;
            flag[x] = true;
        }
    }
    
    if (a[1] || n == 1) cout << a[1];//特判，当首位有值或者n是1的时候直接输出首位，其余的要输出1
    else cout << 1;

    for (int i = 2; i <= n; i++)
        cout << a[i];
    return 0;
}
```

完结撒花！望管理员审过！