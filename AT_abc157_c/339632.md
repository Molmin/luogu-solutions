这题细节十分的多。我来给大家总结一下这题的细节与做题时的心得。

读题很重要，我们一行行来读。

这里我建议大家有能力的话阅读英语题面，因为中文题面可能存在翻译有遗漏或不准确的情况。

> We assume $0$ to be a $1$ -digit integer. For other integers, leading zeros are not allowed.

$0$ 是一位数。

这个条件十分重要，说明 $0$ 是一个符合要求的数。但是在其他位数的数中，首位不能为 $0$，即最少是 $1$。

接下来我们来理思路。

1. 如何记录所有限制？

由于 $n \leq 3$，直接开一个 `a[4]` 的数组记录即可。对于每一组输入的 $s,c$，进行操作 `a[s]=c`。

2. 如何判断不存在这样的数（即输出 `-1`）？

- 很容易想到，如果出现对于一组 $i,j \leq m$ 且 $i \not =j$，$s_i=s_j$ 且 $c_i \not =c_j$，就不成立；
- 如果对于 $n \geq 2$，有 $s=1,c=0$，由高位不能为 $0$ 的限制可得不存在。

3. 如何使输出的数最小？

容易想到：

- 对于所有 $i \geq 2$，如果 `a[i]` 还没有被赋值，那么将其赋值为 $0$；
- 对于 $i=1$，如果 `a[i]` 还没有被赋值，那么将其赋值为 $1$。

这样就结束了吗？

我们提到过，$0$ 是一个符合要求的一位数。所以，当 $n=1$ 时，如果第 $1$ 位没有被赋值，那么我们应该直接输出 $0$，而非赋值为 $1$。

最后一位一位输出即可。

我们来看代码的实现。

```cpp
#include <iostream>
using namespace std;
int n,m,s,c,a[4]={0,-1,-1,-1}; // 开数组记录每一位，先赋值为 -1 表示没有被赋值过
int main()
{
    cin>>n>>m;
    if (n==1 && m==0) // 特判
    {
        cout<<0;
        return 0;
    }
    while (m--) // m 组限制
    {
        cin>>s>>c;
        if (s==1 && c==0) // 第一位为 0
        {
            if (n==1)
            {
                a[1]=0; // 是一位数，没问题
                continue;
            }
            cout<<-1; // 不是一位数，不成立
            return 0;
        }
        if (a[s]==-1 || a[s]==c) a[s]=c; // 未被复值过或是原来就是这个值，那么赋值
        else // 被赋值过且原来不是这个值，矛盾
        {
            cout<<-1;
            return 0;
        }
    }
    if (a[1]==-1) a[1]=1; // 未被赋值，设为 1
    for (int i=2; i<=n; i++)
    {
        if (a[i]==-1) a[i]=0; // 未被赋值，设为 0
    }
    for (int i=1; i<=n; i++) cout<<a[i]; // 一位一位输出
    return 0;
}
```

这篇题解就到这里啦，感谢大家的阅读！