**我们开始找规律，慢慢进行构造。以$n = 3$为例，首先是$(0,0,0)->(0,0,1)->(0,1,1)->(1,1,1)$,这便是一种可能。   那么如何做到以下的路径没有重复呢？以上经过的两个点肯定是不能再经过了，那么还剩下$(0,1,0),(1,0,0),(1,0,1),(1,1,0)$。经过构造后发现还有2组可能：$(0,0,0)->(0,1,0)->(1,1,0)->(1,1,1)$和$(0,0,0)->(1,0,0)->(1,0,1)->(1,1,1)$。**

**由特殊推广到一般，对于一个$n$维的数组，第$k$步会有$k$个$1$出现，且第$n-1$步时会有$C_n^{n - 1}$种可能，我们将其化简得$\frac{1*2*…*(n-1)*n}{1*2*…*(n-1)}$,同时除以$1*2*…*(n-1)$，得原式等于$n$（其实$C_n^{n - 1} = C_n^1 = n$）因此对于一个$n$维的数组，最多将会有$n$条路径。**

------------

那么如何进行二进制压位呢？我们进行一个预处理就行了。先尝试算出$2^{1…n}$
```
a[1] = 1;
for(int i = 2;i <= n;i++) a[i] = a[i - 1] * 2;//预处理 
```
然后对于每条路径第$k$个点，将会有$k$个$1$，因此有：
```
for(int j = 1;j <= n;j++)
{
	k += a[j];//表示第j个点（有j个1） ，二进制对应位相加
	cout<<k;
	if(j != n) cout<<" ";//不要多输出空格！ 
}
```
最后使得每条路径不同，我们只要把这个预处理的数组进行轮即可
```
long long now = a[1];
for(int l = 1;l < n;l++) a[l] = a[l + 1];//类似循环队列 把1,2,4-->2,4,1-->4,1,2…… 
a[n] = now;
cout<<endl;
```

------------

**最后记得：不开$long$ $long$~~你懂的~~**
```
#include <iostream>
using namespace std;
long long a[65];
int main()
{
	a[1] = 1;
	int n;
	cin>>n;
	cout<<n<<endl;
	for(int i = 2;i <= n;i++) a[i] = a[i - 1] * 2;//预处理 
	for(int i = 1;i <= n;i++)
	{
		cout<<0<<" ";//起点 
		long long k = 0;
		for(int j = 1;j <= n;j++)
		{
			k += a[j];//表示第j个点（有j个1） 
			cout<<k;
			if(j != n) cout<<" ";//不要多输出空格！ 
		}
		long long now = a[1];
		for(int l = 1;l < n;l++) a[l] = a[l + 1];//类似循环队列 把1,2,4-->2,4,1-->4,1,2…… 
		a[n] = now;
		cout<<endl;
	}
	return 0;
}
```

