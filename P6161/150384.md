蒟蒻第一次写构造题，发篇题解纪念一下。
# 题目分析
其实别联想 n 维的蚂蚁是怎么爬的，我们是三维生物想不出的。~~联想三维以下的情况的当我没说。~~

那怎么办呢？我们最好用 01 串说话。

考虑一个 01 串，它表示一个坐标。而蚂蚁的移动，就可以看成是 01 串中选一个数字取反，要么是 0 到 1，要么是 1 到 0。

当然，我们从贪心的角度考虑，我们希望所有的数字都是从 0 到 1 的。所以，蚂蚁的移动从 S 到 T 的移动，就变成了把 01 串中的 0 按照一定顺序改为 1。

再考虑具体方案。从 S 出发，只有 n 个方向可以走，所以方案数最多为 n。

那方案数是否就是 n 呢？~~样例和数据证明~~没错。我们可以构造一种解法使方案数为 n：枚举第一次填 1 的位置，然后每次往后填 1，填到尾则继续填头，直到填完为止。

用 $n=4$ 来说明：
- 第 1 种：0000 1000 1100 1110 1111

- 第 2 种：0000 0100 0110 0111 1111

- 第 3 种：0000 0010 0011 1011 1111

- 第 4 种：0000 0001 1001 1101 1111

~~通过观察法可以得出~~这种选法是不会走重点的。因为在这种选法中，每个 1 都可以看成一段区间，而区间的左端点在每种走法中都不一样，而区间的右端点又在各自走法中的每一步中不同，所以最终走过的坐标都不相同。

（当然这个“区间”是个抽象的概念，你可以理解成循环队列的头尾指针。）

然而第一次填 1 的位置有 n 种选择，所以最终构造出来的走法会有 n 个。

在实际代码中由于题目要求 $n\le60$，所以要开 longlong，且要进行一定的位运算。

（当然，开 ull 更保险。）

最后注意，由于 spj 缺陷，**行末一定不能有空格**，否则都不知道怎么 WA 的。

（好吧其实题面有讲，出题人不喜勿喷。）
# 参考代码
很短，仅 17 行。
```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
unsigned long long p;
int main()
{
	scanf("%d",&n);
	printf("%d\n",n);
	for(int i=0;i<n;++i)
	{
		printf("%llu",p=0);
		for(int j=0;j<n;++j)
			printf(" %llu",p|=1ull<<(i+j)%n);
		printf("\n");
	}
	return 0;
}
```