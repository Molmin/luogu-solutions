## 法一（朴素）

按题目要求模拟。首先循环 $2\times n$
 次，读入袜子并记录后，桌子上多一只袜子。**与此同时**（但总有得有个先后）进行配对，如果配对成功放入衣柜，桌子上又少了两只袜子。上两步相当于同时，所以执行完后再统一更新答案。相当于有两种情况：
 
 1. 配对不成，桌子上多一只袜子
 2. 配对成功，桌子上多一只袜子**同时**又少掉两只
 
 至于标记袜子号码，我们发现 $x_i$ 的取值范围不会大于十万，我们就可以开一个数组 `a[100005]`，每种袜子对应一个下标。
 
**AC code:**

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[100005],cnt,ans;
int main()
{
	cin>>n;
	for(int i=1;i<=2*n;i++)	//别忘了乘以2，因为n双有2*n只
	{
		int x;
		cin>>x;
		a[x]++;		//发现一只袜子，桌上就多一只相应种类的袜子
		cnt++;		//桌子上总袜子数增加（第一种）
		if(a[x]==2)	//同种袜子凑够两只，放入衣柜（第二种）
			cnt-=2;	//桌子上少掉两只
		ans=max(ans,cnt);//更新答案，取最多的
	}
	cout<<ans;
	return 0;
}

```

## 法二（简化）

法二 _貌似_ 简化了一些，把前面分析的第二种情况**多一只又少两只**改为了**少一只**，代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[100005],cnt,ans;
int main()
{
	cin>>n;
	for(int i=1;i<=2*n;i++)	//别忘了乘以2，因为n双有2*n只
	{
		int x;
		cin>>x;
		a[x]++;		//发现一只袜子，桌上就多一只相应种类的袜子
		if(a[x]==2)	//第二种
			cnt--;	//桌子上共少一只
		else
			cnt++;	//第一种
		ans=max(ans,cnt);//更新答案，取最多的
	}
	cout<<ans;
	return 0;
}

```