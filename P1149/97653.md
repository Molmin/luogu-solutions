直接进入主题

题意是输出一共有的火柴根数,输出将这些火柴**所有用完**可以有多少拼法

根据题目意思

0要用6根火柴   1要用2根火柴 

2要用5根火柴   3要用5根火柴 

4要用4根火柴   5要用5根火柴 

6要用6根火柴   7要用3根火柴 

8要用7根火柴   9要用6根火柴 

# 注意: '+' 和 '=' 也分别需要2根火柴

如:1+1=2 一共用了2(第一个1)+2(加号)+2(第二个1)+2(等号)+5(结果2)=13根火柴

代码如下:
```pascal
var
  s,t,i,j,k,n,x:longint;
  a:array[0..10] of integer;
  p:boolean;
begin
  readln(n);
  a[0]:=6;//直接把0~9这10个数字组成的火柴根数定好,方便等一下计算
  a[1]:=2;
  a[2]:=5;
  a[3]:=5;
  a[4]:=4;
  a[5]:=5;
  a[6]:=6;
  a[7]:=3;
  a[8]:=7;
  a[9]:=6;
  for i:=0 to 1000 do//从0开始穷举,一定要是0,不然就少了一种0+0=0这个算式了
    for j:=0 to 1000 do
    begin
      p:=true;//反证法,刚开始认为结果小于1000(不用很大,很浪费时间,不优化可能会TLE,没试验过,根据是总循环次数大约是1001*1001*3*3*3(为什么*3等一下讲))
      if (i+j>1000) then p:=false;//如果大于1000(这个随便定,别太小也别太大),直接将p定义为false
      s:=0;//一定要清零,不然用的火柴根数会一直累加
      k:=i;//刚开始累加第一个加数i用的根数
      x:=1;//这个是用来记录位数的,因为有时算式是0+0=0的话这些单个0会无法累加,如果将后面条件改成 k>-1 ,就会死循环,而不改个位数0不会累加
      while ((k>0) and (p)) or ((k=0) and (x=1)) do//两种情况要去做循环 1.目前k>0和p是true 2.k是0,但是他是第一位数
      begin
        inc(x);//这个必要累加,不然最后就跳不出循环了
        s:=s+a[k mod 10];//累加第x位数需要的火柴
        k:=k div 10;//去掉最后一位数
      end;//刚刚说*3是因为如果i是3位数就要做3次循环,而三位数大约有900个吧
      k:=j;//做j
      x:=1;//继续定义成1
      while ((k>0) and (p)) or ((k=0) and (x=1)) do//和刚刚条件一样
      begin
        inc(x);
        s:=s+a[k mod 10];
        k:=k div 10;
      end;
      k:=i+j;//最后是累加i+j的结果需要的火柴根数
      x:=1;//不变
      while ((k>0) and (p)) or ((k=0) and (x=1)) do//依旧不变
      begin
        inc(x);
        s:=s+a[k mod 10];
        k:=k div 10;
      end;
      s:=s+4;//直接将'+'和'='的根数加起来
      if s=n then inc(t);//如果总根数是规定的根数 累加t
    end;
  writeln(t);//一共的方案数
end.
```

我的方法应该是最烦的了吧

望通过