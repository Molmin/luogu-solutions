这道题虽然看起来没法做，但仔细想想就发现这只是一个分类讨论。

对于这个数偶数数位的数量及位置进行讨论。

设这个数有 $n$ 个偶数数位：

当 $n = 0$ 时，全是奇数数字，不可能让原数变为偶数，输出 $-1$。

当 这个数的末尾是偶数数字 时，本来就是偶数，不需要操作，输出 $0$。

当 这个数的首位是偶数数字 时，直接翻转全部就变为偶数，输出 $1$。

当 这个数的偶数数字在中间 时，需要先让这个偶数翻到首位，再整体翻转一次，输出 $2$。

代码就很容易实现了！

```cpp
#include<bits/stdc++.h>
using namespace std;
bool y(char c){
	return (c - '0') % 2;//将这个数位转换为对2取模 
}
int main(){
	int t;
	cin >> t;
	while(t--){
		string str;//用字符串处理方便一些 
		cin >> str; 
		int len = str.size();//长度 
		int cnt = 0;//记录多少个偶数数位 
		for(int i = 0; i < len; i++){
			if(y(str[i]) == 0) cnt++;
			//如果对2取模为0就cnt+1 
		}
		if(cnt == 0) puts("-1");//全是奇数，输出-1 
		else{
			if(y(str[len - 1]) == 0) puts("0");//本来就是偶数，输出0 
			else if(y(str[0]) == 0) puts("1");//首位是偶数，输出1 
			else puts("2");//否则中间就输出2 
		}
	}
	return !0;
} 
```

