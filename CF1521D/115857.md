[link](http://codeforces.com/contest/1521/problem/D)

### 题目大意：

- 给出一棵 $n$ 节点的树，每次操作可以拆一条边并且移动到规定位置。

- 求最少的操作数量，使得这棵树变为一条链。

- $1\le n\le 2\times 10^5$。

### 思路：

#### 初步思路

最后是一条链，不难想到，最后每一个节点，都只有一个儿子。

对于多余的儿子，肯定要想千方百计把他干掉。

![](https://cdn.luogu.com.cn/upload/image_hosting/qucui1to.png)

这里的 10 号节点和 23 号节点，同样其和子树均为一条链，但他们的链不一样， 23 号节点的链不跨过 23 号节点，但是 10 号节点的链要跨过 10 号节点。

这两种链，处理方法也不一样。不跨过的（称为 1 号链），其加上父亲节点还是链。跨过的（成为 2 号链），其加上父亲节点就不是链了。

#### 链的合并方式

对于一个节点，下面可能有许多 1 号链和 2 号链。

期望：有两个一号链（形成 2 号链），有一个一号链（形成 1 号链。）

其中二号链肯定是要杀干净的。

我们举 17 号节点为例子，其中有一个 1 号链和一个 2 号链。

这个二号链怎么杀干净呢？其**本质为一条链**，那么只要将其全部拖到 13 那里，就完成了杀链。

也就是 $5-8-20-10-7$ 作为整体拖过去，把 $10-17$ 断开，这样就杀掉了一个二号链。这样是最简单的杀二号链的方法。

再比如说到了 $15$ 号的时候，两个为二号链（已经处理好了），一个为一号链，那么就把两个二号链杀掉，将 $11-12-9$ 和 $2-4-23-19-3$ 拖到 $21$ 下面，形成一个一号链。

对于一号链，就比较容易了，直接牵到一号链末端上。

比如说 $19$，那么就把 $23-4$ 拖到 $3$ 后面，断掉 $19-23$。

比如说 $14$，$18$ 号节点处理完了是一个一号链，$16$ 号也是一号链，直接把 $16$ 接到 $18$ 这条链后面即可。

还没懂的话就拿这个图模拟一下。

#### 链的合并贪心

对于两个一号链，能留着就留着，毕竟升为二号链说不定还能一次卷走，如果合并为一号链的话，这里就多一个操作，肯定不值得。

如果要合并的全都是二号链，那也没办法，毕竟要加上父亲为链，那只能将左链和右链合并在一起形成一个一号链。

为啥这样子是对的呢？

因为我们保证了每一个搜索到的点，其形成链的次数最少。

纵观全局，二号链的处理是**本质**的优化。每一次二号链的出现都减少一次操作次数。（本来要合并后再在 father 合并，现在不需合并之一次卷走。）

有没有更优的方法？没有的，因为三号链不为链，要先处理成为为二号链才能继续。其要花一的代价形成二号链再减少一的代价。而在哪里形成二号链都是一样的，其本身移动一个要一的代价，二号链减少一的代价。**你不可能移到其他点硬生生把一号链变成二号链**，移动的代价为 1，二号链的代价为 1，原来的话一号链代价为 1，显然这个更优，所以原地形成二号链是最优选择。

所有大于二号的链，就算现在不处理至二号链，之后也是一样的处理，且代价等大，消除二号链是唯一的优化。至于一号链，一次把两个一号链串起来也是最高效的操作，所以是最优的。

#### 代码要处理的：

- 一个二号链的起点和终点，一号链的起点和终点。

- （这里申明一下定义，一个二号链的起点和终点需要左右分明，同时记录其左右儿子，这样在二号链合并为一号链的时候，可以分清楚链的左右节点。一号链的起点为其本身，终点为深度最大的点。）

- 一号节点/二号节点，图，记录答案的栈（输出长度）

就是在链的合并时候，注意一下细节，不要搞错就行了。

### Code:

干干净净的 O(n)，虽然时间限制为 $3s$，只跑了 $0.15s$。

```cpp

// 无防作弊
#include<bits/stdc++.h>
#define I inline
#define RI register int
#define rep(i,a,b) for(RI i=a;i<=b;++i)
#define dow(i,a,b) for(RI i=a;i>=b;--i)
#define edg(i,u,v) for(RI i=head[u],v;v=e[i].to,i;i=e[i].next)
using namespace std;
const int N=2e5+5;
struct node {
	int a,b,c,d;
	node() {}
	node(int aa,int bb,int cc,int dd) {
		a=aa,b=bb,c=cc,d=dd;
	}
} a[N]; // 记录答案的栈 
struct edge {
	int to,next;
} e[N<<1]; 
int T,n,x,y,cnt,top,mi[N],mj[N],dp[N],son[N][2],head[N<<1];
// mi,mj : 分别为起点和终点
// dp: 表示这个点是 1/2 号链
// son: 表示二号链的左右儿子 
I void add(int from,int to) {
	e[++cnt]=(edge) { to,head[from] };
	head[from]=cnt;
}
I void dfs(int u,int f) {
	dp[u]=1;
	mi[u]=mj[u]=u; // 每个节点一开始都为一号链，那么其起点终点都为其本身。 
	RI sum=0,res=0;
	edg(i,u,v) if(v^f) {
		dfs(v,u); // 先对儿子进行处理 
		res++; // 这里是儿子个数 
		sum+=dp[v]==1; // 这里记录一号链的个数 
	}
	if(sum>=2) { 
		// 如果有两个以上一号链，那么这两个一号链保留，其他接到他们两个身上，新城形成二号链。 
		RI x=0,y=0; // 分别记录两个一号链 
		dp[u]=2; // 二号链 
		edg(i,u,v) if(v^f&&dp[v]==1) {
			if(!x) x=v;
			else {
				y=x,x=v;
				break;
			}
		}
		son[u][0]=x,son[u][1]=y; // 记录子节点（其实这里是写反的，但是不想改了，不影响答案） 
		mi[u]=mj[y],mj[u]=mj[x]; // 目前这个二号链起点/终点为一号链的终点（一号链起点为本身） 
		edg(i,u,v) if(v^f&&v^x&&v^y) { // 如果都不是这三者，那么需要链转移
			a[++top]=node(v,u,mj[v],mj[u]); // 记录答案 
			mj[u]=mi[v]; // 接在了 mj[u]（终点）后面，那么终点更新为链的另一头（是另一头！） 
		}
	} else if(sum==1) {
		RI x=0; // 如果只有一个一号链
		edg(i,u,v) if(v^f&&dp[v]==1) x=v; 
		mj[u]=mj[x]; //先认定当前节点终点为这个一号链的终点 
		edg(i,u,v) if(v^f&&v^x) { // 果都不是这两者，那么需要链转移
			a[++top]=node(v,u,mi[v],mj[u]); // 记录答案 
			mj[u]=mj[v];// mi[v] 接在了 mj[u]（终点）后面，那么终点更新为链的另一头 mj[v]（是另一头！） 
		}
	} else if(res) { // 也要看，必须要有二号链才能合并 
		RI x=0;
		edg(i,u,v) if(v^f) x=v; // 认定一个二号链，其他的链都放在这个上面 
		edg(i,u,v) if(v^f&&v^x) {
			a[++top]=node(v,u,mi[v],mi[x]); // 直接卷走 
			mi[x]=mj[v]; // 解释如上 
		}
		a[++top]=node(son[x][1],x,mi[x],mj[x]); 
		//左右合并，这里 son 数组起作用，son[x][1]其实就是 mi[x] 的起点，其与x断掉，左右链低端合并 
		mj[u]=son[x][1];
		// 右边的 son[x][1] 开始的链，由于是下面练过来，那么链末就是 son[x][1] 了（你也可以换着来） 
	}
}
int main() {
	scanf("%d",&T);
	while(T--) {
		scanf("%d",&n);
		rep(i,2,n) scanf("%d%d",&x,&y),add(x,y),add(y,x);
		top=0,dfs(1,0);
		printf("%d\n",top);
		rep(i,1,top) printf("%d %d %d %d\n",a[i].a,a[i].b,a[i].c,a[i].d);
		rep(i,1,n) head[i]=mi[i]=mj[i]=dp[i]=son[i][0]=son[i][1]=0;  
		cnt=0;
	}
	return 0;
}
```

too_late 永远可爱！

完结散花！感谢观看！qwqqqqqqqqqqqqq

如果文章帮到你的话，如果你觉得博主非常之良心细致的话，就点点赞呗QwQ。