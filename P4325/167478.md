貌似还没有用STL set的题解...咱来发一波（代码在后面，set的在最后面...）
## 题目分析
“给出10个整数，问这些整数%42后有多少个不同的余数。 其中%代表取余运算”
我们先来看一组数据：
```cpp
39
40
41
42
43
44
82
83
84
85
```
这组数据的答案是6，让人百思不得其解，于是我们手动算出上述数据的值分别如下
```cpp
39%42=39
40%42=40
41%42=41
42%42=0
43%42=1
44%42=2
82%42=40
83%42=41
84%42=0
85%42=1
```
那么都有哪些数字出现过呢？

39、40、41、0、1、2

这些数字的数量不正好是6么？

啊，现在我们懂了，这个**程序的流程**就是：

1、**计算余数**

2、**判断有多少个不一样的余数（去重）**
## 程序实现
计算余数各位都知道（不知道的掉头去做[P1001 A+B Problem](https://www.luogu.org/problem/P1001)）
那么下面的问题就是去除重复数据了，这问题可就大了，咋办？

本人第一次碰到去重题目时那个发慌啊，在经过思想斗争后，想到的**方法如下**：

1、**根据数据范围开一个数组**，全部设成0；

2、如果发现某个值，我们就**把下标为这个值的元素设为1**（如值为v，数组为a，那么该操作为：a[v]=1）；

3、处理完全部数据后，遍历上述数组，如果**下标为i的元素内容为1则输出i**（数组为a，下标为i则：if(a[i]==1) cout<<i），至此程序完结。

按照这个思路我们能得到**AC代码1**，一些细节见代码注释。

但我们想想，这个**数组到底该开多大呢**？如果数据在几亿至个位数不等呢？针对这个问题，本蒟蒻多方研究，发现我们上述用的方法已经很接近于一种叫做[基数排序](https://baike.baidu.com/item/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/7875498?fr=aladdin)（俗称“桶排序”）的排序方法，既然上述问题来自**桶排序的先天劣势**（某些情况下是巨大的优势，甚至能成为最省空间的排序法，篇幅过长，此处不再赘述），我们何不尝试换用别的排序方法呢？

之前给出的那组数据排序过后的结果是0、0、1、1、2、39、40、40、41、41，我们惊讶地发现：**重复的数据都是相连的！**于是我们就此得到了**AC代码2**，具体细节见代码注释。

“咱可是新手啊，怎么会比桶排更复杂的排序法呢？”

“写个程序都得打一遍排序，多烦啊！”

“办法总比困难多”，众所周知C++有各种各样~~花里胡哨~~的头文件，这不，咱就在一个叫**algorithm**的文件中发现了一个叫**sort**的玩意，皆大欢喜！

说道翻文件，我们还能翻到两个玩意儿：**set**和**bits/stdc++.h**，这里的**set**其实就是C++事先编写好的一种数据类型（类似**string**），简单来说就是一个**特殊的数组**，可以增加元素上限（大小理论上无限），并且第一个元素一定是最小的，最后一个元素一定是最大的，**并且内容不重复**，也就是说我往一个**set**里塞10^233个3**最后里面也只存着1个3**;

而**bits/stdc++.h**则是**gcc（g++）**编译器特有的头文件，其中**包含了标准c++的几乎所有头文件**，也就是说做一般的题只需要这一个头文件就行了，这样我们就有了**AC代码3**，具体细节见注释。
## AC代码
### AC代码1
```cpp
#include<iostream>

using namespace std;

//下面出场的是：答案、去重数组和用于输入的变量，掌声欢迎！
int ans,a[42],x;//这里a开到42是有讲究的，由余数定义可知，余数一定小于除数（42），但由于C++的神奇特性——数组最后一个元素就没正常过，于是我们只用到42个元素却得开到43个

int main()
{
    for (int i=1;i<=10;i++){
    	  //循环（十个数）十次，除非特殊需要，咱更推荐这种从1开始的循环，能避免很多不必要的麻烦
        cin>>x;//输入
        a[x%42]=1;//记录，x%42一定小于42，故不用担心越界
    }
    for (int i=0;i<42;i++){
    	//统计，由前面的数据可知，0也要算在内
    	if (a[i]) ans++; //计数器+1
    }
    cout<<ans;//输出结果
    return 0;
}
```
### AC代码2
```cpp
#include <algorithm>//sort来源于此
#include <iostream>

using namespace std;

int ans,a[11],x;//OI界“陋习”：变量一律全局，开到11，原因同上

int main(){
    for (int i=1;i<=10;i++){
        cin>>x;
        a[i]=x%42;//特别注意这里的a和之前的a有啥区别
    }
    /*这里是对sort的重点讲解
    sort共有3个参数，分别是要排序的区间起点、区间终点（终点不会取到）、和排序方法
    对于OI来说，更多是排序整个数组，所以起点终点选整个数组就好了
    至于排序方法，除非我们自己定义了结构或类，否则是可以缺省的，
    该参数传递的是一个函数指针*/
    sort(a+1,a+11);//咱从1开始，所以参数特殊一些
    //题目只要求去重后元素的数量，所以咱不需要真正去重，只需要统计
    x=a[1];//这里x用于储存前一个数据
    ans++;
    for(int i=2;i<=10;i++){
        if(a[i]!=x){//如果当前数据不等于前一个数据（不连续），说明这是不重复的元素
            x=a[i];//将当前值设为新的“上一个数据”
            ans++;//统计
        }
    }
    cout<<ans;//输出
}
```
### AC代码3
```cpp
#include <bits/stdc++.h>//万能头文件，爽

using namespace std;

int main(){
    set<int> s;//简单来说set就是一个有序的去重链表
    int t;
    for(int i=0;i<10;i++){
        cin>>t;
        s.insert(t%42);//set支持STL线性容器的大部分操作，如插入是insert，删除是erase
    }
    cout<<s.size();//由于set内容不重复，其元素的数量就是结果
    return 0;//养成好习惯
}
```


关于set的详细信息看[这](https://baike.baidu.com/item/STLset%E5%AE%B9%E5%99%A8/2061832?fr=aladdin)

### 希望这篇题解能给大家不一样的感受