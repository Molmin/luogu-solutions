## 设计状态

假定当前 $[i, j]$ 范围内的石子已经确定，第 $i$ 堆的石子数量为 $a_i$。

设 $l_{i, j}$ 表示在 $[i, j]$ 左边放一堆石子，且先手必败时在左边放的石子数，$r_{i, j}$ 表示在 $[i, j]$ 右边放一堆式子，且先手必败时在右边的先手数量。

由于 $l_{i, j}$ 与 $r_{i, j}$ 是完全**对称**的，因此仅说明 $l_{i, j}$ 的求法，$r_{i, j}$ 对称过去即可。

**结论 1**：$l_{i, j}$ 必然存在且唯一。

证明：假设左边有两个取值 $x_1, x_2, x_1 > x_2$ 使得先手必败，那么我们先手从左边拿 $x_1 - x_2$ 个石子，留给后手的就是必败态，那么当前就不是必败态。

最后判断答案时，仅需判断 $l_{2, n}$ 是否等于 $a_1$ 即可。

## 转移

定义 $L = l_{i , j - 1}, R = r_{i, j - 1}$，$X = a_j$，要求 $l_{i, j}$。

- **情况 1**（$R = X$）：不算 $L$ 时已经是必败态，令 $l_{i, j} = 0$ 即可。

- **情况 2**（$X < \min(L, R)$）：令 $l_{i, j} = X$ 即可。无论先手怎么取，我们都在另一边跟先手去等量的石子数。必然存在当先手取到 $0$ 时，我们还剩 $y$ 个石子。由 $0 < y \le x < \min(L, R)$ 及结论 1 可得，留给后手的 $y$ 一定不是必败态，那么当前就是必败态。

- **情况 3** 
  - **3.1**（$R < X \le L$）：令 $l_{i, j} = X - 1$ 即可。
      - **先手取右边**：设右边取完后还剩下 $t$ 个石子。
          - $R < t \le L$，还是**情况 3.1**，我们还是在左边取到剩 $t - 1$。
          - $t = R$，那么转换为**情况 1**，我们直接取空左边即可。
          - $t < R$，那么转换为**情况 2**，仍然先手必败。
      - **先手取左边**：设左边取完后还剩下 $t$ 个石子。
          - $R \le t \le L$，还是**情况 3.1**，把右边取到剩 $t + 1$。
          - $t < R$，那么转换为**情况 2**，仍然先手必败。
  - **3.2**（$L \le X < R$）：令 $l_{i, j} = X + 1$ 即可。
      - **先手取右边**：设右边取完后还剩下 $t$ 个石子。
          - $L \le t < R$，还是**情况 3.2**，把左边取到剩 $t + 1$。
          - $t < L$，转换为**情况 2**，仍然先手必败。
      - **先手取左边**：设左边取完后还剩下 $t$ 个石子。
          - $L < t < R$，还是**情况 3.2**，把右边取到剩下 $t - 1$。
          - $t = L$，转换为**情况 1**，我们直接取空右边即可。
          - $t < L$，转换为**情况 2**，仍然先手必败。

- **情况 4**（$X > \max(L, R)$）：不妨设 $L < R$，令 $l_{i, j} = X$ 即可。设先手取完剩下 $t$ 个。
  - $t > \max(L, R)$，还是**情况 4**，我们取等量石子即可。
  - $L \le t \le R$，转换为**情况 1**或**情况 3**，仍然先手必败。
  - $t < L, t < R$，转换为**情况 2**，仍然先手必败。

大功告成！

## Code

```
#include<cstdio>
#define rep(a, b, c) for(int (a) = (b); (a) <= (c); ++ (a))
#define per(a, b, c) for(int (a) = (b); (a) >= (c); -- (a))
using namespace std;

const int N = 1010;

int n, a[N];
int l[N][N], r[N][N];

int main() {
    int T;
    scanf("%d", &T);
    while(T -- ) {
        scanf("%d", &n);
        rep(i, 1, n) scanf("%d", &a[i]);

        rep(len, 1, n) {
            rep(i, 1, n - len + 1) {
                int j = i + len - 1;
                if(len == 1) l[i][j] = r[i][j] = a[i];
                else {
                    int L = l[i][j - 1], R = r[i][j - 1], X = a[j];
                    if(R == X) l[i][j] = 0;
                    else if((X < L && X < R) || (X > L && X > R)) l[i][j] = X;
                    else if(L > R) l[i][j] = X - 1;
                    else l[i][j] = X + 1;

                    L = l[i + 1][j], R = r[i + 1][j], X = a[i];
                    if(L == X) r[i][j] = 0;
                    else if((X < L && X < R) || (X > L && X > R)) r[i][j] = X;
                    else if(R > L) r[i][j] = X - 1;
                    else r[i][j] = X + 1;
                }
            }
        }
        if(n == 1) puts("1");
        else printf("%d\n", (l[2][n] != a[1])); 
    }
    return 0;
}
```