首先题目不需要支持修改，所以我们能够对信息进行预处理。

由于询问不能暴力跳，我们希望让它们能够“搭便车”，所以对于每一个深度，我们都**随机选取**两个节点作为**关键点对**，预处理往上跳 $O(\sqrt n)$ 步的答案。

然后就可以通过了，这个算法应当是卡不掉的，目测时间复杂度为期望 $O((n+q)\sqrt n)$，空间 $O(n)$，支持 $O(\sqrt n)$ 单点修改，因为每次修改最多会对 $O(\sqrt n)$ 个关键点对造成影响。

代码太好写了，几分钟就能写完，甚至不需要调试，可以一遍过。

很遗憾，这种做法并不能支持 Link-Cut 和链或子树修改。

看到别人的做法大多是莫队或记忆化，似乎莫队在线会变慢，记忆化不能修改？

不过我为什么赛时想不到记忆化啊！虽然也是 $O((n+q)\sqrt n)$ 的。

当然强制在线并且修改以上两种做法就不适用了吧。

[赛时 AC 记录](https://codeforc.es/contest/1806/submission/197943303)。