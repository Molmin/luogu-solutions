由于新房间的随机数都小于i, 我们可以将当前的随机数仍然**看作走过来的时间点(即入边)**. 然后在计算时每个时间点最多只留**一条出边**.

所以每个房间的所有时间点可以看做一条**链**. 

所以就有:

## 题意简化

	给出一棵树, 输入每个点的父亲, 求树最少被分割成多少条链.

如果还是没搞懂题意简化的话, 可以看图. (样例二图解, 分割方式为样例二解释中的例子)

![](https://cdn.luogu.com.cn/upload/pic/70198.png)

做过这种原题的人可以直接跳过了.

## 思路

~~既然是树上的链, 我们可以想到树链剖分.~~ 正当我在想树链剖分怎么做这题时, 同学说:

	"不是统计一下有多少个叶子节点就可以了吗?"

...

诶对对对, 统计一下叶子结点. 我先证明一下:

由于链是不能拐弯的(链上节点深度均不同), 所以一条链不可能出现两个叶子节点, 最多出现一个, 而且作为链的下端点. 则**链的下端点个数大于等于叶子节点个数**.

而除了叶子节点外, 每个节点都至少有一个儿子, 则这些节点都能从任意一个儿子连上链, 所以不必作为链的下端点(即一条链中深度最深的点). 则**链的下端点个数不大于叶子节点个数**.

所以**叶子节点个数等于链的下端点个数**, 易知链的下端点个数即为链的个数, 则**求出叶子节点个数即求出链的个数**.

所以标记一遍有儿子的点(比如i时输入a, 则BJ[a]=true), 最后扫一遍无儿子节点个数就好了.

## 代码(这个输入也很良心啊):

```cpp
#include<cstdio>
using namespace std;
const int N=2e5+5;
int n,a,ans,A[N];
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;++i){
		scanf("%d",&a);
		++A[a];
	}
	for(int i=1;i<=n;++i)
		if(!A[i])++ans;
	printf("%d\n",ans);
}
```
