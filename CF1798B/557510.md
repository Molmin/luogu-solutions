这道题算是一道比较简单的构造题，首先看一下题目:  
一共有 $m$ 天，每天有 $n_i$ 人买了彩票，分别为 $a_{i,1}\cdots a_{i,{n_i}}$。现在请你安排每天的一位中奖的人，满足他在之后的天里都没有买彩票。如果可以，给出方案，否则输出 $-1$ ;     
     
我们可以看出，对于一个人，除了最后一次买彩票外，他什么时候买彩票都对答案没有任何的影响，所以我们只需要知道一个人他最后一次买彩票是什么时候，其余的全部不记录，于是在一次询问输入结束后，我们就得到了每个人最后一次买彩票是哪一天，现在这个问题就变得非常简单了，因为你需要让每一天都有一个中奖的人，所以你只需要判断这 $m$ 天里是否每一天都有至少一个人最后一次买彩票，如果有那么就存在答案，如果没有就没有方案则输出 $-1$ 。    

这道题就这么结束了，等等。   

这道题还没结束，看到题目所给的数据范围，我们发现 $1\le t \le 50000$ ，$1\le m \le 50000$ ，以及 $n$ 的总和不超过 $50000$ 。时限给了两秒，我们发现像我这样从来懒得写快读的就 T 飞了，所以还要加上快读，于是这道题就过了   

放一下代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int t,n,m,a[50010],vis[50010];
//a 数组记录每个人最后一次买彩票的时间
//vis 数组记录每一天是否有人最后一次买彩票 
inline int read()//快读 (不加会 TLE 别问我怎么知道的 
{
	int x=0,f=1;char ch=getchar();
	while (ch<'0'||ch>'9'){if (ch=='-') f=-1;ch=getchar();}
	while (ch>='0'&&ch<='9'){x=x*10+ch-48;ch=getchar();}
	return x*f;
}
int main()
{
	t=read();
	for(int k=1;k<=t;k++)
	{
		memset(a,0,sizeof(a));
		memset(vis,0,sizeof(vis));
		m=read();
		for(int i=1;i<=m;i++)
		{
			n=read();
			for(int j=1;j<=n;j++)
			{
				int x;
				x=read();
				a[x]=i;//记录买当前最后一次买彩票的时间 
			}
		}
		for(int j=1;j<=50000;j++)
		{
			if(a[j])
			{
				vis[a[j]]=j;//记录每一天是否有人最后一次买彩票 
			}
		}
		bool flag=0;
		for(int j=1;j<=m;j++)
		{
			if(!vis[j])
			{
				flag=1;
				break;
			}
		}
		if(flag)
		{
			cout<<-1<<endl;
		}
		else
		{
			for(int j=1;j<=m;j++)
			{
				printf("%d ",vis[j]);//输出一种可能的构造 
			}
			printf("\n");
		}
	}
	return 0;
}
```
**初次写题解，望多多包容，不喜勿喷**