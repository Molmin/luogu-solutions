看到别的题解没有用字符串做的，就来写一篇。

## 大致题意

给你 $n$ 个四位数 $y_{1\dots n}$。需要更改其中一些数的任意**一位**数字，使序列不下降且 $\forall i\in [1\dots n],1000\le y_i\le 2011$ 。

其中 $1\le n\le 1000,1000\le y_i\le 9999$。

## 题目分析

若从前往后枚举，由于每个 $y_i$ 所能取的值都与 $y_{i-1}$ 的取值有关，所以前面的 $y_i$ 越小越好，这样才能使后面的数取值范围更大。（即贪心）

对于每个 $y_i$ ，在确定了前面的 $y_{i-1}$ 的状态下，暴力枚举所有可能的更改后的值，取满足 $y_i\ge y_{i-1}$ 的所有 $y_i$ 中的最小值即可。

因为 $y_1$ 有且仅有 $y_1\ge 1000$ 这一个限制，我们可以假定 $y_0=1000$ ，再用一般情况的处理方法做。~~（什么？你问我这有什么用？当然是减少代码量喽！）~~

而代码中需要修改数字的数位，如果用 $\texttt{int}$ 存储数据，代码会比较繁琐。考虑到题目和代码中涉及到的数都是四位数，数字位数相同，因此可以用 $\texttt{string}$ 来存储数据，这样修改数位和比较大小都很方便。

## 参考代码

代码仅供参考。

~~请不要在意我独特的码风。。。~~

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
ll n,i,j,g;string a[1005],k,t;
int main(){
	ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
	cin>>n;a[0]="1000";
	for(i=1;i<=n;i++){
		cin>>a[i];k="2012";
		for(j=0;j<4;j++)for(g=0;g<=9;g++){//暴力枚举
			t=a[i];t[j]=g+48;//修改数位
			if(t>=a[i-1])k=min(k,t);//判断+取最小
		}
		if(k>"2011"){cout<<"No solution\n";return 0;}//判断是否超过2011
		a[i]=k;
	}
	for(i=1;i<=n;i++)cout<<a[i]<<"\n";
}
```