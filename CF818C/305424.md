## 题意
给定沙发数量 $d$，和一个长宽分别为 $n,m$ 的长方形场地，每个沙发占两格。接下来 $d$ 行给出 $x1,y1,x2,y2$，表示每个沙发的所在位置。最后给定$cnt_l,cnt_r,cnt_t,cnt_b$，让你求出一个沙发使得在它左边的沙发有 $cnt_l$ 个，在它右边的沙发有 $cnt_r$ 个，在它上面的沙发有 $cnt_t$ 个，在它下面的沙发有 $cnt_b$ 个。如果没有满足条件的沙发，输出 $-1$。

一个沙发 $a$ 在另一个沙发 $b$ 左边是指沙发 $a$ 的某一个 $x_i$ 与沙发 $b$ 的某一个 $x_j$ 满足 $x_i<x_j$。

同样的，一个沙发 $a$ 在另一个沙发 $b$ 右边是指沙发 $a$ 的某一个 $x_i$ 与沙发 $b$ 的某一个 $x_j$ 满足 $x_i>x_j$。

一个沙发 $a$ 在另一个沙发 $b$ 上面是指沙发 $a$ 的某一个 $y_i$ 与沙发 $b$ 的某一个 $y_j$ 满足 $y_i<y_j$。

同样的，一个沙发 $a$ 在另一个沙发 $b$ 下面是指沙发 $a$ 的某一个 $y_i$ 与沙发 $b$ 的某一个 $y_j$ 满足 $y_i>y_j$。

因此，我们需要注意，一个沙发 $a$ 可能既在另一个沙发 $b$ 的左边又在它的右边。

同样的，一个沙发 $a$ 也可能既在另一个沙发 $b$ 的上面又在它的下面。

## 思路

我们只需要枚举每个沙发，分别以 $O(1)$ 的时间复杂度求出在它左边，右边，上面，下面的有几个沙发。

怎么求呢，我们要预处理前缀和或后缀和（数组多开一点，小心越界）。

当我们找某一沙发左边沙发的个数时，总是看其余沙发的最左边的一点进行比较，因此定义数组 $l$，用于求每个沙发左边沙发的个数时使用，对于每个沙发，令 $l[min(x1,x2)]$ 加一。然后前缀和处理。

同样的，当我们找某一沙发右边沙发的个数时，总是看其余沙发的最右边的一点进行比较，因此定义数组 $r$，用于求每个沙发右边沙发的个数时使用，对于每个沙发，令 $r[max(x1,x2)]$ 加一。然后后缀和处理。

当我们找某一沙发上面沙发的个数时，总是看其余沙发的最上边的一点进行比较，因此定义数组 $t$，用于求每个沙发上面沙发的个数时使用，对于每个沙发，令 $t[min(y1,y2)]$ 加一。然后前缀和处理。

同样的，当我们找某一沙发下面沙发的个数时，总是看其余沙发的最下边的一点进行比较，因此定义数组 $b$，用于求每个沙发下面沙发的个数时使用，对于每个沙发，令 $b[max(y1,y2)]$ 加一。然后后缀和处理。

预处理过后，循环枚举每一个沙发，注意题意中是小于或大于，不带等号！注意自己是否被算了进去！然后与 $cnt_l,cnt_r,cnt_t,cnt_b$ 比较输出。

不要忘记如果循环中没有输出，最后输出 $-1$ 哟！

## 代码

下面给出我的代码，完全根据分析写出来的，大家可以对照着看，是比较简单易懂的。

```cpp
#include<bits/stdc++.h>
using namespace std;
int d,n,m,cntl,cntr,cntt,cntb;
int s[5][100005],l[100005],r[100005],t[100005],b[100005];
int main(){
    ios::sync_with_stdio(0);
    cin.tie(0);
    cin>>d>>n>>m;
    for(int i=1;i<=d;i++)cin>>s[1][i]>>s[2][i]>>s[3][i]>>s[4][i];
    cin>>cntl>>cntr>>cntt>>cntb;
    for(int i=1;i<=d;i++){
	l[min(s[1][i],s[3][i])]++;
	r[max(s[1][i],s[3][i])]++;
	t[min(s[2][i],s[4][i])]++;
	b[max(s[2][i],s[4][i])]++;
    }
    for(int i=1;i<=n;i++)l[i]+=l[i-1];
    for(int i=n;i>=1;i--)r[i]+=r[i+1];
    for(int i=1;i<=m;i++)t[i]+=t[i-1];
    for(int i=m;i>=1;i--)b[i]+=b[i+1];
    for(int i=1;i<=d;i++){
	int ansl=0,ansr=0,anst=0,ansb=0;
	ansl=l[max(s[1][i],s[3][i])-1];
	if(min(s[1][i],s[3][i])==max(s[1][i],s[3][i])-1)ansl--;
	ansr=r[min(s[1][i],s[3][i])+1];
	if(max(s[1][i],s[3][i])==min(s[1][i],s[3][i])+1)ansr--;
	anst=t[max(s[2][i],s[4][i])-1];
	if(min(s[2][i],s[4][i])==max(s[2][i],s[4][i])-1)anst--;
	ansb=b[min(s[2][i],s[4][i])+1];
	if(max(s[2][i],s[4][i])==min(s[2][i],s[4][i])+1)ansb--;
	if(ansl==cntl&&ansr==cntr&&anst==cntt&&ansb==cntb){
	    cout<<i<<endl;
            return 0;
	}
    }
    cout<<-1<<endl;
    return 0;
}
```
