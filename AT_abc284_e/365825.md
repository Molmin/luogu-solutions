[洛谷传送门](https://www.luogu.com.cn/problem/AT_abc284_e) && [AT 传送门](https://atcoder.jp/contests/abc284/tasks/abc284_e)

此篇题解存在~~乱搞~~优化成分，仅供参考。（但是其实在赛场或考场上这样是会很有用的）

## 思路

讲讲赛时是怎么搞出来的吧。

首先这个菜鸡看了一眼题，果断认错这是一棵树。于是第一步想法诞生了。我们可以手动模拟一下，从根节点开始，每一次跨出一个节点，就是多了一条路径；缩回去跨到另外一个节点，也是多了一条路径。这是候我们就能明白了，可以进行 dfs 遍历，每一次遍历到一个点，答案就 $+1$。

写出了最简单的 dfs 之后，我们~~又~~意识到这里头可能有环（例如样例二）。于是我们可以想到需要打标记和回溯，因为不能在一个环上转圈圈，路径的计算会重复。

这时候代码大概就出来了，但是，这道题毕竟是 E 题，我们可能还得多想一步。因为这道题中可能会有环，每个节点可能会重复走，好像……走太多会超时？（事实证明真的会超时，菜鸡就因为没有多想一步吃了罚时）我们需要一个小优化。题目中说了，最后输出的答案 $K=\min(K,10^6)$，所以，如果答案超过了 $10^6$，就可以输出 $10^6$ 然后结束程序了。

## 代码

这个菜鸡仅仅因为这是 AT 而用了 `vector` 存图，在正式的比赛或考试中不建议用 `vector` 存图，因为怕被出题人卡掉。

```cpp
#include <bits/stdc++.h>
using namespace std;
int n, m, ans;
bool fl[200010];
vector < int > tr[200010];
void dfs(int x, int fa) {
	if (x == fa) return;
	for (auto v : tr[x]) {
		if (v == fa) continue;
		if (fl[v]) continue;  // 一个环里不重复走
		ans ++;               // 累计答案
		fl[v] = 1;            // 打标记
		if (ans >= 1e6) {     // 小优化
			puts("1000000");
			exit(0);
		}
		dfs(v, x);
		fl[v] = 0;           // 回溯
	}
}
int main() {
	scanf("%d %d", &n, &m);
	for (int i = 1; i <= m; ++i) {
		int u, v;
		scanf("%d %d", &u, &v);
		tr[u].push_back(v);
		tr[v].push_back(u);
	}
	fl[1] = 1;
	dfs(1, 0);
	printf("%d", min(ans + 1, 1000000));
	return 0;
}
```


## 小小的总结

+ 题目要看全，样例最好都手动模拟，避免看错题目要求或限制。

+ 题目看错别怕，也许是正解的第一步。

+ 考虑一下是否需要回溯。

+ 是否需要多想一步呢？代码是不是完全 OK 没有任何差错了捏？是不是还得加上一点点什么东西例如小优化？

+ 最好不要用 `vector` 存图。当且仅当打 AT 的时候可以稍稍偷一下懒，其他比赛最好不要用。

可能会有小小的用处 qwq。