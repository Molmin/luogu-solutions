## 图上 dfs 遍历

这是一道图论题，要求统计图中从 $1$ 号顶点出发的**简单路径**的条数。其中，简单路径指的是没有多次经过某一顶点的路径。

这道题的关键是答案的处理方式：若符合要求的路径条数为 $K$，则输出 $A=\min(K,10^6)$。

这个处理方式很重要——因为 $K$ 有可能很大，也不容易在时间限制内用 dp 等方式求出（毕竟点数 $n\le 2\times10^5$ 呢）。而我们知道，直接 dfs 遍历图上的所有简单路径，时间复杂度是 $O(K)$ 的。因为每次找到一条路径，操作是 $O(1)$ 的（遍历路径的方法在下面会说明），而程序需遍历完 $K$ 条路径。

加上限制 $A=\min(K,10^6)$ 之后，在 $K>10^6$ 时，不需要遍历完 $K$ 条路径，只需要在找到 $10^6$ 条路径后，停止遍历并输出 $A=10^6$ 即可。因为就算 $K$ 再大，答案 $A$ 也最多到 $10^6$。所以就不用找出更多的路径了。这样，程序的时间复杂度就是 $O(A)$，且 $A\le10^6$，能够通过。

下面说明 dfs 遍历的方法：从 $1$ 号节点出发，遍历到节点 $u$ 时，每次找到一个与 $u$ 相连的、没有经过的节点 $v$，**在路径上加入一条以 $v$ 结束的新的路径**，并把 $v$ 作为上面提到的 $u$ 继续遍历（类似 dfs 的做法）。直到所有与 $u$ 相连的、没有经过的节点 $v$ 都遍历过之后，返回 $u$ 的上一层节点 $f$（之前从 $f$ 走到的 $u$，就称 $f$ 是 $u$ 的上一层节点）。

注意：在节点 $u$ 时，以其结尾的路径若不同，则以其为经过点的路径也不同。例如 $1\to 2\to 4$ 和 $1\to 3\to 4$ 是两条不同的路径，所以 $1\to 2\to 4\to 5\to 6$ 和 $1\to 3\to 4\to 5\to 6$ 也是两条不同的路径。这也就说明了——先遍历到的节点有不同，后遍历到的节点无论是否相同，都是两条不同的路径。这也就解释了为什么 dfs 遍历时，不会出现相同的路径——每次更改至少有一层上的某个节点与原先的所有路径不同。

按上面的方法，遍历 $u\to v$ 时，需要保证 $v$ 是一个没有经过的节点。所以用一个 $vis$ 数组记录当前路径 $1\to\cdots\to u$ 中经过的节点。如果发现 $vis_v=1$，也就是 $v$ 节点在 $1\to\cdots\to u$ 中，就不能再走 $v$。反之则可以走 $v$，这时需要把 $vis_v$ 设成 $1$，表示 $v$ 现在已经在走过的路径里面了。当 $v$ 遍历结束，返回到 $u$ 时，要把 $vis_v$ 设成 $0$，表示 $v$ 现在不在走过的路径里了。（注意：要求不能走**前面的路径中经过的节点**，而不是“曾经遍历到的节点（可能不在现在的路径里面）”，所以要有这一步 $vis_v\leftarrow 0$ 的回溯操作）。

注意：记得把 $vis_1$ 设成 $1$，因为 $1$ 号节点永远在路径里面（起始节点）。

代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll mx=1e6;
ll n,m,ans;
bool vis[200020];
vector<ll> e[200020];
void dfs(ll u)
{
	if(ans==mx) return;// 超过10^6条路径，不搜了
	ans++;
	for(ll i=0;i<e[u].size();i++)
	{
		ll v=e[u][i];
		if(vis[v]) continue;// 走过就不搜
		vis[v]=1;// 记录走过
		dfs(v);// 往下搜
		vis[v]=0;// 回溯
	}
}
int main()
{
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	cin>>n>>m;
	for(ll i=1;i<=m;i++)
	{
		ll t1,t2;
		cin>>t1>>t2;
		e[t1].push_back(t2);
		e[t2].push_back(t1);
	}
	vis[1]=1;
	dfs(1);
	cout<<ans;
	return 0;
}
```
