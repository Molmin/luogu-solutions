# [ARC119C] ARC Wrecker 2

## 题面整理

给出一个长度为 $n$ $(2\le n\le 3\times 10^5)$ 的正整数序列 $A_i$ $(1\le A_i\le 10^9)$，进行以下两种操作：

- 操作 $1$：将 $A_x,A_{x+1}$ 各 $+1$。$(l\le x<r)$

- 操作 $2$：将 $A_x,A_{x+1}$ 各 $-1$。$(l\le x<r)$

**需要保证任意时刻 $A_i$ 非负**。求问有多少个数对 $(l,r)$ 满足可以通过任意次操作使得 $A_l,A_{l+1}\ \dots\ A_r$ 均为零？（注意我们不记录子区间，即在操作后 $(l,r)$ 是满足的，但要将其作为答案，要满足 $A_{l-1}≠0,A_{r+1}≠0$）

## 思路

乍一看时间复杂度，直接枚举区间肯定是不行的，况且即使枚举了区间，我们又应该怎么判断呢？所以当务之急，我们需要找到符合条件的区间都有怎么样的共性。

**先给结论**

若一个区间偶数位上的数之和和奇数位上的数之和相同时，此区间满足要求。

接下来我们来证明这个结论：

**推理法**

我们先看特殊情况：

1. 当区间长度为 $2$ 时，当且仅当 $a_1=a_2$ 时区间成立。
 
2. 当区间长度为 $3$ 时，当且仅当 $a_1+a_3=a_2$ 时区间成立。

接下来我们通过归纳法来推。

- 长度为 $4$：

设区间为 $a_1,a_2,a_3,a_4$。

我们先将两边减成 $ 0$→$0,a_2-a_1,a_3-a_4,0$，这时 根据上方的特殊情况，得知当且仅当 $a_2-a_1=a_3-a_4 $ 时区间成立，交换一下就是 $ a_1+a_3=a_2+a_4$——即偶数位和奇数位和相等。

- 长度为 $5$：

同理看步骤：

$a_1,a_2,a_3,a_4,a_5$ 

$\Rightarrow 0,a_2-a_1,a_3,a_4-a_5,0$

当 $a_2-a_1+a_4-a_5=a_3$，即 $a_2+a_4=a_1+a_3+a_5$ 成立时，区间成立。

- 长度为 $2\times n$：

同理看步骤：

$a_1,a_2,a_3,\dots\ ,a_{2n}$

$\Rightarrow 0,a_2-a_1,a_3,\dots\ ,a_{2n-2},a_{2n-1}-a_{2n},0 $

$\Rightarrow 0,0,a_3-a_2+a_1,\dots\ ,a_{2n-2}-a_{2n-1}+a_{2n},0,0 $

$\Rightarrow 0,\dots\ ,0,a_n-a_{n-1}+a_{n-2}-\dots-a_{2}+a_1,a_{n+1}-a_{n+2}+a_{n+3}-\dots-a_{2n-1}+a_{2n},0,\dots\ ,0 $

整理一下，得到充分必要条件：$a_n-a_{n-1}+a_{n-2}-\dots-a_{2}+a_1,a_{n+1}-a_{n+2}+a_{n+3}-\dots-a_{2n-1}+a_{2n}$

即：

$a_{1}+a_3+\dots+a_{2n-1}=a_2+a_4+\dots+a_{2n}$

- 长度为 $2\times n+1$

这里就不再说明了。

这样就得到了最初的结论。

**代码实现**

那么如何统计答案？实际上只需要用前缀和的方式，但是需要**奇加偶减（或者奇减偶加）**，再统计之前出现过这个前缀和的次数（即区间和为 $0$），这个统计过程由于值域较大需要离散化。


我们记录前缀和数组为 $qzh$，当 $qzh_i=qzh_j(i<j)$ 时，$[i+1,j]$ 是一个满足条件的区间。特别的，因为 $qzh_0$ 不会被扫描到，所以一开始就要在离散化数组 $mp$ 中初始化 $mp_0=1$。

## Code

```C++
#include<bits/stdc++.h>
#define int long long
#define db double
#define rtn return
#define i1n int i=1;i<=n;i++
#define in1 int i=n;i>=1;i--
using namespace std;

const int N=3e5+5;
const int M=1e5;
const int Mod=1e5;
const int INF=1e5;

int n,k,a[N],cny,cnt,ans, qzh[N];//qzh是前缀和
map<int,int> mp;

signed main(){
    cin>>n;
    mp[0] = 1;//初始化,当前面某个前缀和值为i,第二次扫描到某个前缀和值为i时,产生一个答案.当
    for(int i = 1 ; i <= n ; ++ i)
    {
        cin>>a[i];
        if(i&1) qzh[i] += qzh[i - 1] + a[i]; //奇加偶减,i&1等效于i%2
        else qzh[i] += qzh[i - 1] - a[i];
        ans+=mp[qzh[i]];
		mp[qzh[i]]++;
    }
    cout<<ans<<endl;
    return 0;
}
```


