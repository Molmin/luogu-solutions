设dp[i] 表示第i个城市到根节点的最小花费

dp[i]=min{ (dis[i]-dis[j])*P[i]+Q[i]+dp[j] } 

这是O（n^2）的

这个式子可以斜率优化

dp[i]+dis[j]*P[i]=dis[i]*P[i]+Q[i]+dp[j]

就是一条斜率为P[i]的直线，截（dis[j],dp[j]）的最小截距

在根往下走的过程中，斜率单调递增

这就体现了 为什么题目中说“i号城市是j号城市的某个祖先，那么一定存在Pi<=Pj”

我们按dfs序dp

现在唯一的问题就是如何得到 一个点到根节点路径上的单调队列

只需要考虑如何去除兄弟节点的子树对单调队列的影响

即在一个节点退出dfs时，将单调队列恢复为这个节点开始dfs的情况

头指针只是不断的+1，没有涉及到单调队列中元素的修改，所以记录下头指针在哪个位置即可

尾指针涉及到元素的替换，但是它只会替换一个元素，所以记录下尾指针的位置，以及被当前点替换的元素是谁

当节点退出dfs时，恢复记录的这三个值即可

这样的话，一个节点多次出队入队，时间复杂度就不是O（n）了

所以二分出队位置，时间复杂度为O（nlogn）

代码链接：
[http://www.cnblogs.com/TheRoadToTheGold/p/8468557.html](http://www.cnblogs.com/TheRoadToTheGold/p/8468557.html)
n^2 暴力dp代码、斜率优化+暴力出队代码、斜率优化+二分出队代码