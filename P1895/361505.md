[题目传送门](https://www.luogu.com.cn/problem/P1895)

# 题意

简单明了：求 $112123123412345......$ 的第 $n$ 个数字。


# 思路

思路其实并不难想，我们把这个数拆成若干个首尾相连的数：

$1$ $12$ $123$ $1234$ $12345$ $123456$ $1234567......$


这样我们就可以很方便的统计每个数的位数了。由于打表太长了，所以我们只能预处理，把这些数存在 $a$ 数组里。。

我们先计算出第 $n$ 位在第几个数里。然后我们再进行一次处理，计算出 $n$ 是这个数里面的第几位。

我们可以举个例子：

如果 $n = 13$,那么先算出 $13$ 在第五个数里。然后我们通过预处理算出的数组再进行一次处理，因为显然后面的数都包含前面的数，所以我们可以直接通过之前算出的数组进行处理。

然后，根据以上方法，我们可以求出第 $13$ 位是 $3$。

当然，我们还可以进行优化。例如通过二分答案进行优化。

# 代码

```cpp
#include<iostream>
#include<cmath>
using namespace std;

int t,n,a[1000005];
void PRE(){
    	for(int i = 1;i < 10;i++) a[i] = a[i - 1] + 1;
	for(int i = 10;i < 100;i++) a[i] = a[i - 1] + 2;
	for(int i = 100;i < 1000;i++) a[i] = a[i - 1] + 3;
	for(int i = 1000;i < 10000;i++) a[i] = a[i - 1] + 4;
	for(int i = 10000;i < 100000;i++) a[i] = a[i - 1] + 5;
}

int main(){
    PRE();
	cin>>t;
	for (int i = 1;i <= t;i++){
		cin>>n;
		int sum = 0,cnt1 = 0,cnt2 = 0;
		while(true){
			sum += a[++cnt1];
			if(sum >= n) break;
		}
		n -= (sum - a[cnt1]);
		while(true) if(a[++cnt2] >= n) break;
		cout<<(int)(cnt2 / pow(10,a[cnt2] - n)) % 10<<endl ;
	}
	return 0;
}
```
# 优化

优化方法中，我们最容易想到的就是二分查找。即查找第一个大于 $n$ 的数位和。

二分查找的条件：

---
- 答案在一个固定区间内；

- 可能查找一个符合条件的值不是很容易，但是要求能比较容易地判断某个值是否是符合条件的；

- 可行解对于区间满足一定的单调性。换言之，如果 $x$ 是符合条件的，那么有 $x$ 或者 $x$ 也符合条件。（这样下来就满足了上面提到的单调性）

---

来自 Wiki。

显然，这道题满足所有的条件。

为了二分查找，我们先打一个前缀和，查找第一个大于 $n$ 的前缀和，然后减去上一位。

然后再用预处理的存储数位的数组，再进行一次二分查找，查找第一位大于 $n$ 的数位和。

代码太丑了，就不放了。

