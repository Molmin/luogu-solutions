感觉官方题解和 @x义x 的题解写的都不是很清楚（也可能是我太菜了），所以稍微补充一下。

我们要让小于 $x$ 的数最少，即让大于等于 $x$ 的数最多。

那么我们可以对于每个大于等于 $x$ 的 $a_i$，将能覆盖到它的左端点的区间加上 $1$，这样子查询 $[l,r]$ 中的最大值就可以得到答案了。

仍然用上面的思路，但是我们考虑用分块维护这个区间加 $1$ 区间求最大值。

这个很好分块维护：对于整块，我们直接打标记即可；对于散块，我们暴力加并更新块内最大值即可。

然而我们不可能把每次区间加完后的序列都存下来，所以考虑对修改分块，只存下每块内第一次修改前的序列。这样子我们就还需要进行 $\mathcal{O}(\sqrt{n})$ 次区间加 $1$，每次要求 $\mathcal{O}(1)$。然而存 $\sqrt{n}$ 个长度为 $n$ 的序列还是存不下。

假设已经执行了所有 $\geq x$ 的修改，那么考虑修改后的差分数组，可以发现它会在 $a_{i+m}\geq x\land a_i<x$ 的位置加上 $1$，在 $a_{i+m}<x\land a_i\geq x$ 的位置减去 $1$。所以我们只需要存下每块的第一个元素就可以还原出整个序列了。

然后考虑怎么 $\mathcal{O}(1)$ 实现修改。对于整块，我们可以对标记差分；对于散块，在预处理时记下每个修改执行完后它左右端点所在块的最大值，然后覆盖掉当前的即可。

代码和 @x义x 的差不多，就不贴了。