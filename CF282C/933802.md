这一题……说白了就是个思维题，分类讨论就行了。

------------


举个例子：

我们现在有一个字符串 $0001$。

字符串从右往左数第一位和第二位异或，可以得到 $0011$ 这个字符串，再将第二位和第三位异或，以此类推……就可以得到一个全是 $1$ 的字符串。

那如果我们需要 $0$ 怎么办？

还是之前那个字符串，现在它已经是 $1111$ 了。比如说我们需要 $1011$，那么只需要将从左往右数第一位和第二位异或就行了。当我们需要有一个位置为 $0$ 时，只需要将这一位和后一位异或一下就行了。

由此我们得到一个结论：**当一个字符串内有 $1$ 的时候，可以构成除了形如 $0000$ 这样的全零字符串之外的所有的字符串长度的二进制数（这里的二进制数可以加上前导零）。**

至于为什么一个有字符 $1$ 的字符串不能构成全零字符串稍微想一想应该就知道了，作者就不多说了。


------------
那么分类讨论就很简单了！

如果两个字符串长度相等且都拥有 $1$ 或者都全部是 $0$，那么肯定可以构成相同字符串，输出 YES，否则输出 NO。


------------
代码：

```
#include<bits/stdc++.h>
#define int long long
using namespace std;
signed main(){
	string a,b;
	cin>>a>>b;
	if(a.length()!=b.length()){
		cout<<"NO";
		return 0;
	}
	int flaga0=1,flagb0=1;
	for(int i=0;i<a.length();i++){
		if(a[i]=='1'){
			flaga0=0;
			break;
		}
	}
	for(int i=0;i<b.length();i++){
		if(b[i]=='1'){
			flagb0=0;
			break;
		}
	}
	if(flaga0!=flagb0){
		cout<<"NO";
		return 0;
	}
	cout<<"YES";
	return 0;
}

```


