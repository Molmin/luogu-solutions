## 题解 SP264 【CORNET - Corporative Network】

题目传送门:

https://www.luogu.org/problemnew/show/SP264

这题挺好的，可以来练习**并查集**

但其实还是有一点**小变化**的，即**带权（加权）并查集**

~~（这近乎是一道带权并查集板子题）~~（逃~~~

===================================================================

先来看看**算法构建**：

对于本题，有两个操作：

	1.将x的父亲设为y，其中规定x与y之间的距离为abs(x-y)%1000
    
    2.询问点x到其根节点的距离

emmm，冷静思索。。。~~貌似**暴力**可以做~~？？？

#### 思路一：暴力

我们可以每次对于一个I操作，都使得x与y之间连一条边，权值为w=abs(x-y)%1000

如果询问的话直接跑一遍dfs就行了

但是对于n=20000的图，如果每一次都来一下dfs查询答案，那么时间的消耗是不可想象的！

试想最坏情况，一个有20000个节点的链，每次如果查询都是最尾端的节点，都暴力的跑，那么每次查询的时间复杂度将会是O(n^2)，妥妥的TLE了

那么我们不妨换一下思路，是否有一种东西，**支持随时随地查询自己与父节点之间的距离**，而**不会耗费太多时间，同时能更新父子关系**呢？

那么很自然而然的想到---- _**并查集**_ 

因为并查集能很好的维护父子之间的关系，能够在均摊意义下接近常数级别的时间里找出一个节点的父亲

那么我们为了**维护一个节点与自己的根节点之间的距离**，对于并查集的改进算法也应运而生

它就是----**带权（加权）并查集，属于并查集的变种**

有的时候，我们不仅需要像普通并查集一样记录一些元素之间有无关系，还需要记录它们之间有怎样的关系，这时候就需要引入**加权并查集**。

通常情况下，我们使用一个数组d来记录这些关系，d[i]表示元素i与父结点的关系。至于是什么关系，还要根据具体要求来看。

个人还是喜欢叫它**带权并查集**，毕竟它**通常会维护一些距离之类的值**，而距离通常都是有权的（即边权）

#### 思路二：带权并查集

对于本题，就是要维护一个点与它的根节点之间的距离，这正好派上用场

我们可以在**每一次询问操作E时，使用普通并查集中的find函数更新一下父亲，同时维护一下它到自己根节点的距离就行了**。

由于**在find的时候会用到路径压缩**（普通并查集的常规优化方法），我们要**先记录原本的父节点，避免因路径压缩造成的父节点更新，导致维护的信息出错**

这其实就是**带权并查集与普通并查集之间的区别**

代码实现如下：（dis[x]即为x点到自己的根节点之间的距离）

```cpp
inline int find(int x)//带权并查集的find函数 
{
	if(fa[x]==x)return x;
	int old_fa=fa[x];//先记下原本的父节点 
	fa[x]=find(fa[x]);//更新父亲 
	dis[x]+=dis[old_fa];//更新距离（维护值）
	return fa[x];
}
```
这样在使用并查集的时候，我们就能很好的维护一个点到它的根节点之间的距离了

那么对于题目中的I操作，也很好做了

我们每次直接将x点的父亲置为y，同时将abs(x-y)%1000累加到x点的dis值中即可

还有就是。。。注意多组数据，记得清空

大概就没什么了，下面放代码吧

PS：代码里也有解释哦

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<cstring>
using namespace std;
inline int read()//读入优化:快读
{
    int p=0,f=1;char c=getchar();
    while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}
    while(c>='0'&&c<='9'){p=(p<<3)+(p<<1)+c-'0';c=getchar();}
    return f*p;}
const int maxn=20003;
int n,dis[maxn],fa[maxn];
inline void pre()//初始化 
{
	memset(dis,0,sizeof(dis));
	for(int i=1;i<=n;i++)//并查集初始化
		fa[i]=i;
}
inline int find(int x)//带权并查集的find函数 
{
	if(fa[x]==x)return x;
	int old_fa=fa[x];//先记下原本的父节点 
	fa[x]=find(fa[x]);//更新父亲 
	dis[x]+=dis[old_fa];//更新距离 
	return fa[x];
}
int main()
{
	int T=read();
	while(T--)//多组数据
		{
			n=read();
			pre();
			char s[3];
			while(scanf("%s",s)&&s[0]!='O')//注意读入
				{
					if(s[0]=='I')//合并x到y,x为y儿子 
						{
							int x=read(),y=read();
							fa[x]=y;
							dis[x]+=abs(x-y)%1000;
						}
					else if(s[0]=='E')//询问距离 
						{
							int x=read();
							find(x);//先递归下去更新
							printf("%d\n",dis[x]);
						}
				}
		}
	return 0;
}
```
好了，到这里就没什么了。。。

如果有什么问题，可以在评论区留言或者私信我，我会一一回答的

好啦，感谢您的阅读

最后推一波我的blog：

https://www.luogu.org/blog/new2zy/

拜拜~~~




