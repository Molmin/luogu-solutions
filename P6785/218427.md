### 思路：
首先看题目：

- 这个序列至少有两个数，分别为： $x_1,x_2,⋯x_p$。

- $y_i=x_{i+1}-x_i$，如果把  $y_i$ 到  $y_p$ 按照  $y_1,y_2,⋯y_p$ 的顺序排成一圈每两个相邻的数互为相反数且绝对值都为 $k$。

我们通过第二条可以得出： 
$$x_{i+1}-x_i+x_{i+2}-x_{i+1}=0$$

$$x_{i+1}-x_i+x_i-x_{i-1}=0$$
化简后得到：
$$x_i=x_{i+2}$$

$$x_{i+1}=x_{i-1}$$
以此类推：
$$x_i=x_{i+2}=x_{i+4}=x_{i+6}=x_{i+8}...$$

$$x_{i+1}=x_{i-1}=x_{i-3}=x_{i-5}=x_{i-7}...$$
如果我们按照题目要求一直算下去的话就会知道这个序列可能有  $2$ 种数或者  $1$ 种数，因为当  $k=0$　时就必须需要：
$$x_1=x_2=x_3=x_4$$

接着我们看到  $a_i\le10^6$，提示我们：我们可以暴力枚举  $a_i$，因为它们构成一个圈，所以数量必须相等，每次枚举，拿它们个数中较少的乘以它们的和更新最大值，如果当中任意一种数的个数为  $0$ 那么这个方案就不成立。
### 注意：
我们特殊判断  $k=0$ 如果且  $b_i=1$ 的话也无法构成两个数的序列。

如果一个序列全部都是  $0$ 时，这也算是一种方案。

我们发现  $1\le n,a_i,b_i\le10^6$， $k=0$ 时，假设三者都等于  $10^6$ 答案就会达到  $10^{18}$ 所以还请大家选择合适的变量类型。

题目不保证  $a_i$ 互不相同，若有  $a_i$ 相同则累加其个数计算。
### 代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
long long n,s[2000001],k,ans=-1,a,b,f;
int main()
{
	cin>>n>>k;
	for(int i=1;i<=n;i++)
	{
		cin>>a>>b;
		s[a]+=b;//第a个数的个数加上b
	}
	for(int i=0;i<=1000000;i++)
	{
		f=min(s[i],s[i+k]);//算它们之间的最小值，因为两种数的个数必须相等
		if(f<1+(k==0))//如果k=0的话这种数至少要两个，否则至少要一个
			continue;
		ans=max(ans,f*i+f*(i+k)*(k!=0));//更新最大值，如果k=0就只能和自己算了
	}
	if(ans>-1)//全部为0也算合法
		cout<<ans;
	else 
		puts("NO");
	return 0;
}
```
最后再提醒大家一下这种做法数组要开两倍大小。因为在最后一个计算可能会用到  $10^6+k$，可能会超过数组大小。