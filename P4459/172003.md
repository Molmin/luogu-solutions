[题目链接](https://www.luogu.com.cn/problem/P4459)

题意简述：

有两个绝顶聪明的人 $\text{Alice}$ 和 $\text{Bob}$ 玩游戏，

主持人偷偷想两个整数 $n,m$，

告诉他们 $s$ 表示 $s\le n\le m$（即要猜的数的下界），

然后告诉 $\text{Alice}$ $n\times m$，告诉 $\text{Bob}$ $n+m$。

接着，由他们两个轮流说自己知不知道这两个数是什么，

一堆不知道不知道不知道之后两个人就突然知道了，

现在告诉你 $s$ 和谁先说，要你构造一组 $n$ 和 $m$ 使得两人恰好说了 $t$ 次不知道之后两人都知道了。

$1\le s\le200$，$2 \le t\le15$，输入数据保证有解。

~~瑟瑟发抖的我想起了被小学奥数支配的恐惧。~~

首先，我们肯定要理解一下样例。

$n=6$，$m=10$，主持人告诉这两个人下界是 $5$，告诉 $\text{Alice}$ $60$，告诉 $\text{Bob}$ $16$。

$\text{Alice}$ 列出了她认为可能的 $(n,m)$：$(5,12)$，$(6,10)$

$\text{Bob}$ 列出了他认为可能的 $(n,m)$：$(5,11)$，$(6,10)$，$(7,9)$，$(8,8)$

第一轮：$\text{Bob}$ 说：不知道

此时 $\text{Alice}$ 看看她的两组解，当 $(n,m)=(5,12)$ 时，$\text{Bob}$ 得到 $17$，无法确定任何一组解，第一轮会说出不知道；当 $(n,m)=(6,10)$ 亦然。

第二轮：$\text{Alice}$ 说：不知道

此时 $\text{Bob}$ 看看她的四组解，当 $(n,m)=(5,11)$ 时，$\text{Alice}$ 获得 $55$，$\text{Alice}$ 会认为在 $5\le n\le m$ 时只有 $(5,11)$ 一组解而知道，但她刚刚说不知道，所以 $(5,11)$ 排除；同理，$(7,9)$、$(8,8)$ 排除，只剩下 $(6,10)$ 一组解。

第三轮：$\text{Bob}$ 说：知道

此时 $\text{Alice}$ 看看她的两组解，当 $(n,m)=(5,12)$ 时，$\text{Bob}$ 得到 $17$，可以得出 $(5,12)$，$(6,11)$，$(7,10)$，$(8,9)$ 四种情况，那么他在她第二轮说不知道后应该排除 $(6,11)$，剩下 $3$ 组解，不会在第三轮说知道，所以 $(5,12)$ 排除，只剩下 $(6,10)$ 一组解。

第四轮：$\text{Alice}$ 说：知道

~~话音刚落，全场观众掌声雷鸣，喜极而泣，深深折服于 $\text{Alice}$ 和 $\text{Bob}$ 的深邃而充满智慧的大脑。~~

所以，我们知道了这个游戏的玩法。然后，我们明确两点：

- 对于相同的 $n,m,s$，游戏的进程将一模一样。~~（废话~~

- 一个人要是知道了，另一个人如果不能立马知道，他就永远不会知道了，因为接下来知道的人会一直说知道。~~（还是废话~~

所以先知道的那个人是怎么知道的？

看看他是怎么想的：

>当 $(n,m)=(5,11)$ 时，$\text{Alice}$ 获得 $55$，$\text{Alice}$ 会认为在 $5\le n\le m$ 时只有 $(5,11)$ 一组解而知道，但她刚刚说不知道，所以 $(5,11)$ 排除；同理，$(7,9)$、$(8,8)$ 排除，只剩下 $(6,10)$ 一组解。

来，我们抽象化一下：

>当 $(n,m)=(\operatorname{xx},\operatorname{xx})$ 时，他会 $\operatorname{xxxx}$，从而在第 $\operatorname{xx}$ 轮就知道，但他刚刚说不知道，所以 $(\operatorname{xx},\operatorname{xx})$ 排除，同理 $(\operatorname{xx},\operatorname{xx})$、$(\operatorname{xx},\operatorname{xx})$ 排除，只剩下 $(\operatorname{xx},\operatorname{xx})$ 一组解。

所以，排除一组解的依据是

>如果是这组解的话，那么他早该知道了

顺着这个想，很容易想到 $\text{DP}$，于是设 $f_{i,j,k}$ 表示如果解是 $(j,k)$ 的话，第 $i$ 轮那个人作为先知道的那个人在第 $i$ 轮知不知道。

首先，如果这个人在上一次他说话时就知道了，那么这一次他肯定也知道，即如果 $f_{i-2,j,k}$ 为真，那么 $f_{i,j,k}$ 为真；

然后，如果在当前这个人看来的所有可行解中，只有 $(j,k)$ 是上一个人在上一轮无法确定的，如果是其他解那么上一个人在上一轮就知道了。

而由于我们的假设（这个人是先知道的那个人），上一个人会在上一轮说不知道，所以这个人就会把上一个人在上一轮就知道的解排除，只剩下 $(j,k)$，而变得知道。

假设当前是 $\text{Alice}$ 说话，那么如果 $f_{i-1,j,k}$ 为假，且对于任意 $x\ge s,y\ge s,x\times y=j\times k,(x,y)\neq(j,k)$ 的 $(x,y)$ 都有 $f_{i-1,x,y}$ 为真，就有 $f_{i,j,k}$ 为真；

假设当前是 $\text{Bob}$ 说话，那么如果 $f_{i-1,j,k}$ 为假，且对于任意 $x\ge s,y\ge s,x+y=j+k,(x,y)\neq(j,k)$ 的 $(x,y)$ 都有 $f_{i-1,x,y}$ 为真，就有 $f_{i,j,k}$ 为真；


然后，就可以愉快的 $\text{DP}$ 了。。。吗？

别忘了，我们假设这个人是先知道的那个人，如果他是后知道的那个人呢？

如果他是后知道的那个人，那么他应该要在先知道的那个人后立马知道，即在他看来的所有可行解中，只有 $(j,k)$ 是先知道者在上一轮才知道的，其他解先知道者要么早知道了，要么直到上一轮都不知道，所以可以立马判定是 $(j,k)$。

所以，我们还要额外多做一遍不同的 $\text{DP}$，否则：

>$\text{Alice}$ 一脸懵逼的看着主持人，表示你坑我呢，我咋知道是哪种？

代码：

```cpp
#include <bits/stdc++.h>
#define MAXN 500 // 怕万一所以把答案的上界设成了 500
using namespace std;
namespace QYB {
    int s, t; bool f[25][MAXN + 5][MAXN + 5]; string name;
    int main() {
        cin >> s >> name >> t; int cur = (name == "Alice");
        // f 就是 DP 数组，cur 表示当前是哪个人，1 为 Alice，0 为 Bob
        for (int i = 0; i <= t; i++, cur = 1 - cur) {
            for (int j = s; j <= MAXN; j++) {
                for (int k = j; k <= MAXN; k++) {
                    if (i >= 2 && f[i - 2][j][k]) {
                        f[i][j][k] = true; continue; // 如果上一次说话（也就是两轮前）就知道了
                    } bool ok = !i || !f[i - 1][j][k];
                    if (cur) for (int x = s; ok && x * x <= j * k; x++) {
                        ok &= j * k % x != 0 || x == j || i && f[i - 1][x][j * k / x];
                        // 枚举 Alice 看来的可行解，判断是否只有 (j, k) 是上一个人在上一轮无法确定的
                    } else for (int x = s; ok && x + x <= j + k; x++) {
                        ok &= x == j || i && f[i - 1][x][j + k - x];
                        // 枚举 Bob 看来的可行解，判断是否只有 (j, k) 是上一个人在上一轮无法确定的
                    } f[i][j][k] = ok;
                }
            }
        } for (int sum = 2 * s; sum <= 2 * MAXN; sum++) {
            for (int m = s, n = sum - s; m <= n; m++, n--) {
                if (f[t][m][n] && !f[t - 1][m][n] && !f[t - 2][m][n]) {
                    // 判断是否确实是第 t 轮才知道的，而不是两个人像个 SB 一样说知道说了半天 （/doge
                    bool ok = true;
                    if (cur) for (int x = s; ok && x * x <= m * n; x++) {
                        ok &= m * n % x != 0 || x == m || !f[t][x][m * n / x] || f[t - 2][x][m * n / x];
                        // !f[t][x][m * n / x] 即为最后一轮先知道者仍然不知道
                        // f[t - 2][x][m * n / x] 即为最后一轮前先知道者就已经知道了
                        // 如果有不同于 (m, n) 的 (x, y) 不满足上述两个条件
                        // 那么后知道者会无法区分 (m, n) 和 (x, y)，故不合法
                    } else for (int x = s; ok && x + x <= m + n; x++) {
                        ok &= x == m || !f[t][x][m + n - x] || f[t - 2][x][m + n - x]; // 同上
                    } if (ok) return !printf("%d %d\n", m, n);
                }
            }
        } return !printf("Orz, I cannot find a solution!\n"); // 显然不可能执行到这里
    }
} int main() {
    return QYB::main();
}
```