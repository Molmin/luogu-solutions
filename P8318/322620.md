我们可以这样解释样例：

| 初始 | $1$ | $1$ | $2$ | $1$ | $1$ |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| 第 1 次 | $1$ | $1$ | $3$ | $1$ | $1$ |
| 第 2 次 | $1$ | $1$ | $3$ | $4$ | $1$ |
| 第 3 次 | $1$ | $1$ | $12$ | $4$ | $1$ |
| 第 4 次 | $1$ | $1$ | $12$ | $4$ | $2$ |
| 第 5 次 | $12$ | $1$ | $12$ | $4$ | $2$ |

那么我们反着考虑，从 $m$ 至 $1$，如果遍历的这次操作为 $\texttt{1 x y}$，那么将第 $x$ 个元素减去第 $y$ 个元素；如果这次操作为 $\texttt{2 x y}$，那么将第 $x$ 个元素除以第 $y$ 个元素。

由于是反着考虑，所以第 $y$ 个元素显然是进行过后面遍历的操作，而前面的操作由于已经减去（除去）了，所以显然正确。

例如样例的第二次，因为是反着操作，所以 $4$ 并没有变成 $1$，$12$ 仍然是会变成 $12 \div 4$，也就是 $3$ 的。

此外，需要特判的就是 $x = y$ 的情况，这个题目中也说了，那么如果是加法的话，那么既然变成 $2x$，那么推回去就是 $x \div 2$，乘法则是变成 $\sqrt{x}$。

Code:
```cpp
#include <bits/stdc++.h>
using namespace std;
long long b[100001];
int t[100001], x[100001], y[100001];
int main() {
    int n, m;
    scanf ("%d%d", &n, &m);
    for (int i = 1; i <= n; ++i) scanf ("%lld", &b[i]);
    for (int i = 1; i <= m; ++i) scanf ("%d%d%d", &t[i], &x[i], &y[i]);
    for (int i = m; i >= 1; --i) {
        if (t[i] == 1) {
            if (x[i] != y[i]) b[x[i]] -= b[y[i]];
            else b[x[i]] /= 2ll;
        } else {
            if (x[i] != y[i]) b[x[i]] /= b[y[i]];
            else b[x[i]]= (long long)sqrt(b[x[i]]);
        }
    }
    for (int i = 1; i <= n; ++i) printf ("%lld ", b[i]);
    //最后因为都是在 b 数组修改，所以只需要输出 b 数组即可
}
```