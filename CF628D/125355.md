# 题目

[传送门](https://www.luogu.com.cn/problem/CF95D)

# 题解

典型数位 $DP$ 题。

记 $f(x)$ 为 $[0,x]$ 中有多少满足条件的数，那么答案即为 $f(r)-f(l-1)$，但是由于我们的 $l\le 10^{1000}$，计算 $l-1$ 是肯定不理想的。

所以我们可以模仿 [这道题](https://www.luogu.com.cn/problem/CF628D) 的思路，先计算 $f(r)-f(l)$，再特判 $l$ 是否合法。

现在问题变成如何计算 $f(x)$.

考虑设计函数 `dfs()`，首先，根据数位 $DP$，一定有的参数是当前的位置 `pos`，其次是是否抵达最大值 `rl`，但是这道题与前一幸运数字有关，那么我们需要设计一维记录前一幸运数字的距离 `d`，但是我们还需知道当前的状态是否已经合法了，即是否已经有两幸运数字距离不超过 $k$ 了，所以我们还需增加一维 `ok` 记录当前状态合法情况。

汇总一下，我们设计函数 `dfs(pos,d,ok,rl)` 表示当前位置为 $pos$，前一幸运数字与下一幸运数字最多还可以差的距离，为 $0$ 不合法，以及 `ok` 表示当前状态是否合法，`rl` 表示是否触及上界。

函数的转移，如果当前的位置要填幸运数字，那么下一状态为 `dfs(pos-1,k,ok||d>0,rl&(i==up))`

如果不填幸运数字，那么下一状态为 `dfs(pos-1,Max(d,0),ok,rl&&(i==up))`

其中 $d$ 与 $0$ 取最大值的原因是我们需要用另外一维记录 $d$，如果 $d$ 为负数很难处理，同时，对于所有 $d<0$ 的情况，其实都是一样的——即上一幸运数字已经无法对状态合法性产生影响，故可以全部合并为一个状态，即距离已经超过，表现为 $d=0$.

# 代码

```cpp
https://www.cnblogs.com/Arextre/p/13485413.html
```

