这道题的意思就是说输入一个字符串，出现 $N$ 为向北走，   $S$ 为向南走，$W$ 为往西走，$E$ 为往东走。最后让你判断是否能走到原点。

这个题目你一看肯定就会觉得很水，但这题一定比你想象的还要水沝淼。

空口无凭，接下来让我们分析一下这道题：

首先，题目中并没有说要走的步数，所以出现一堆跟出现一个是一样的。

其次，方向也只可能出现 $NSWE$，也就只有两组相反的方向：$(NS)(WE)$。

又因没有走的步数之分，所以要想回到原点，所以只要向南走后再向北走就相当于没有走。

最后一句话总结：只要 $N$ 跟 $S$ 同时出现或不出现，以及 $W$ 跟 $E$ 同时出现或不出现，都跟没走一样，所以只要 $N$ 是否出现 $=S$ 是否出现并且 $W$ 是否出现 $=E$ 是否出现就输出 `Yes`，否则就输出 `No`。

也就是：

```cpp
if(N == S && W == E) puts("Yes");
else puts("No")
```
接下来，就该上代码了。

我本来是觉得这题写个代码没有啥挑战性，所以我要：


## 压  行!（代码已AC）

```cpp
#include<bits/stdc++.h>
std::map <char, bool> m;char c;
int main(){
    while(std::cin >> c) m[c] = true;	return ((m['N'] == m['S'] && m['W'] == m['E']) ? puts("Yes") : puts("No")), 0;
}

```
这个代码这么短的原因是利用了 map 映射。

本人亲测 AC。

### ---end---

