## Solution

问题转换后可以得到 : 求一个序列中所有子序列的最大公约数的种类 . 

可以可以发现 , 一个序列的最大公约数不大于其最大值 . 那么答案至多有 $10^6$ 种 .

下面介绍一个小 trick :

> 当遇到最大公约数时 , 枚举最大公约数 .

> 因为这样就可以快速 ( 平均总时间复杂度为 $\text{log}$ 值域 ) 找到可能产生这个最大公约数的所有数 , 然后就可以对它们进行判断 , 不会重复出现很多最大公约数相同的情况 .

那么枚举最大公约数 . 

一个数能被表示 , 相当于它的倍数除以这个数产生的新序列中 , 有两个数互质 .

化归出的新问题也很好解决 : 只要整个序列的最大公约数为 1 , 那么必有两个数互质 ; 反之亦然 .

那么开桶维护值域即可 . 

时间复杂度 : $\text{O(V log V)}$ .

```cpp
n=read();
for(int i=1;i<=n;i++) a[i]=read(),f[a[i]]=a[i];
for(int i=1;i<=1000000;i++) {
	int flg=0,gcd=0;
	for(int j=i;j<=1000000;j+=i) if(f[j]) {
		if(!flg) flg=1,gcd=j;
		else gcd=__gcd(gcd,j);
	}
	if(flg&&gcd==i) ans++;
}
printf("%d",ans-n);
```