~~蒟蒻来水题解啦~~

## 注意：本篇题解适合新手阅读，比较巨的OIer们请自行转到代码实现篇

这道题是个新手的练习题，~~标签竟然不是入门~~。

## 题意

给原来与现在长度为 $n$ 字符串的序列（$ 2 \le n \le 2500 $）

求有几对字符串相对位置与原来相对位置相同。

## 前置芝士map

map 是一个非常有用的数据结构，并且它是STL封装好的，这种数据结构就相当于一种数组，但它有键 key 以及对应的值 value 键值是一一对应的。如果你想要使用 map 需要以下这个头文件（万能头也行）。

```
#include<map>

```

定义一个 map 的方法为：

```cpp
map< , >mp;//逗号前是键的数据类型，逗号后的则是值的数据类型
map<string,int>mp2//示例：32位整形变量经过映射变为字符串类型变量
```

每一个 key 就对应了一个 value。

map 支持赋值，加减乘除操作，例如:

```cpp
mp['shili']=2;
mp['shili']++;
```

map 的常见操作（此处列举比较有用的三个）:

```cpp
mp.clear();//清空
bool a=mp.count('shili');//键值出现次数（1或0）
bool b=mp.empty();//是否为空
```

map 的优点：能够像数组一样赋值，但键可以为任何类型.

## 回归正题：如何解决

1.答案要求用 $a/b$ 的格式，其中 $a$ 为要求的相对位置正确的对数， $b$ 为总对数。题目中已经给出了 $b$ 的求法:

$$b=\frac{n \times(n+1)}{2}$$

2.接着，我们可以计算 $a$ 了.首先，我们可以使用map记录每个字符串对应的序号。我们可以暂定为 $1$ 到 $n$，即：

```cpp
mp[s[i]]=i;
```

然后我们可以在现在的序列中通过 map 来获得一个数列r

| 1 | 2 | 3 | 4 | $\ldots$ | n |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| $r_1$ | $r_2$ | $r_3$ | $r_4$ | $\ldots$ | $r_n$ |

然后枚举 $i$ 和 $j$ ，如果 $i<j$ 且 $r_i<r_j$ ，那么加一分

复杂度为 $\operatorname{O}(n^2)$

## 代码部分

```cpp
#include<bits/stdc++.h>//万能头
using namespace std;
int n;
string ans[2505],rep[2505];
int r[2505],cnt=0;
map<string,int>m2;//反抄袭
int main(){
	cin>>n;
	int ttt=n*(n-1)/2;
	for(int i=1;i<=n;i++){
		cin>>ans[i];
		m1[ans[i]]=i;//自定义序号
	}
	for(int i=1;i<=n;i++){
		cin>>rep[i];
		r[i]=m1[rep[i]];
	}
	for(int i=1;i<n;i++)//核心
		for(int j=i+1;j<=n;j++)
			if(r[i]<r[j])
				cnt++;
	printf("%d/%d",cnt,ttt);
	return 0;//完美收官
}
```

## 最后

千万不要抄代码！！！

码字不易，希望管理员大大能高抬贵手。