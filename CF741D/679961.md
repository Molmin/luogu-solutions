[洛谷题目传送门](https://www.luogu.com.cn/problem/CF741D)

[CF题目传送门](https://codeforces.com/problemset/problem/741/D)

这是一道很好的模板题。

你先要学会 DSU on Tree，[这是 CodeForces 上一篇讲 DSU on Tree 的博文](https://codeforces.com/blog/entry/44351)。

大家都知道 DSU on Tree 可以用来处理子树信息，可是有时候它也可以用来处理链上信息。

IOI 2011里有一道名叫 Race 的著名的点分治模板题，要求统计链信息，也可以用 DSU on Tree 来做，题目链接：[$Link$](https://www.luogu.com.cn/problem/P4149)。

基本思路和点分治是一样的，对于每个点 $u$，我们统计出所有经过 $u$ 的路径的信息。

于是我们有了一个非常好的思路：统计每个点 $u$ 的时候，我们记录下 $u$ 的所有子孙节点到 $u$ 的信息，放在一个数组里存储。

以这道题为例，我们把每个字符串压缩为一个二进制串，然后就可以记录 $u$ 的每个后继节点到 $u$ 的路径所形成的字符串。

但问题来了，我们要保留重儿子的信息，但是节点 $u$ 和它的重儿子之间有一个字母，我们要把这个字母加到重儿子的所有后继节点上，这就退化成了暴力了。

对于 [IOI 2011 Race](https://www.luogu.com.cn/problem/P4149) 这样的题，我们可以选择用数据结构维护，于是复杂度多了一个 $log$。

当然还有更简单的解法，对于本题和 [IOI 2011 Race](https://www.luogu.com.cn/problem/P4149) 这样的题，链上的信息是可减的，于是我们可以不保存“后继节点到点 $u$ ”的信息，而是保存“后继节点到根”的信息，然后在统计的时候再减去“ $u$ 到根的信息”。

每个节点到根的信息是不会变的，就不需要维护了，又因为路径信息可减，所以处理起来也很方便。当然，对于不可减的路径信息，可以选择用数据结构维护，维护不了的话还是写点分治吧。

[**AC代码**](https://www.luogu.com.cn/paste/q960lmrn)