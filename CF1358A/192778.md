昨天晚上的第一道题，很水。

不用dfs之类的算法。对于每组数据，都能$O(1)$解开。

### 思路：

要想让用的灯尽量的少，就需要让每个格子被重复照射的次数少，最好为1。

**两种照射方法：**

$a$：每一行中，每隔两个格的边界上放一个灯笼，这样就能保证目前没有被重复照射的格子，共需$(m/2)*n$个灯笼。如果最右边还剩下一列，那就还需要$ceil(m*1.0/2)$个灯笼（两个格子需要一个灯笼）

$b$ 同理（可以不看）：

每一列中，每隔两个格的边界上放一个灯笼，这样就能保证目前没有被重复照射的格子，共需$(m/2)*n$个灯笼。如果最下边还剩下一行，那就还需要$ceil(n*1.0/2)$个灯笼（两个格子需要一个灯笼）

**最优解：**  $min(a,b)$

代码如下：

```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
int t;
int main(){
	scanf("%d",&t);//t组数据
	for(int i=1;i<=t;i++)
	{
		int n,m;
		scanf("%d%d",&n,&m);//输入行、列数
		int ans1=0,ans2=0;//两种方法需要的灯笼
		ans2+=((n/2)*m);
		if(n%2==1)//还剩一行
		{
			ans2+=m/2;
			if(m%2==1) ans2++;
		}
		ans1+=((m/2)*n);
		if(m%2==1)//还剩一列
		{
			ans1+=n/2;
			if(n%2==1) ans1++;
		}
		printf("%d\n",min(ans1,ans2));//输出最优解
	}
	return 0;//结束程序
} 
```

自己AC吧~