## CF1714C 题解

### 题目翻译

对于每组数据，给你一个数字 $s$，要求你求出最小的数并且满足的各个数字之和刚好是 $s$

例如数 $389$，所对应的 $s$ 就是 $3 + 8 + 9 = 20$

同时每一个数内各个数字不能相同

### 思路

数据范围仅仅只是 $1 \le s \le 45$

~~那么打表不就行了~~

确实，很多人都会用 ~~简短~~ 时间敲出如下这个表：

``` cpp
long long ans[50] = {
    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 19, 29, 39, 49, 59, 69, 79, 89, 189, 289, 389, 489, 589, 689, 789, 1789, 2789, 3789, 4789, 5789, 6789, 16789, 26789, 36789, 46789, 56789, 156789, 256789, 356789, 456789, 1456789, 2456789, 3456789, 13456789, 23456789, 123456789
};
```

~~然后直接查表是吧~~

可是我们怎么能够苟且于简单的打表呢！这里提供一下深搜的思路 ~~并且也是我的表生成器~~

我们可以很快得到一个结论：一个数内的数字是单调递增的。可以很简单地证明：若存在此数内各个数字不单调递增，那一定可以通过重新排列各个数字得到一个更小、同时对应的 $s$ 不变的数。

然后设计一下深搜状态 $(d, p, s)$，其中 $d$ 是上一个选择的数字，$p$ 是当前处理出来的数，$s$ 为各个数字之和。

对此我们可以灰常快得得到深搜代码：

``` cpp
void dfs(int d, int p, int s) {
  ans[s] = min(ans[s], p);
  for (int i = d + 1; i <= 9; i++) { dfs(i, p * 10 + i, s + i); }
}
```

完美收官。

``` cpp
#include <bits/stdc++.h>

using namespace std;

const int kMaxN = 1000;

int t;
int ans[kMaxN];

void dfs(int d, int p, int s) {
  ans[s] = min(ans[s], p);
  for (int i = d + 1; i <= 9; i++) { dfs(i, p * 10 + i, s + i); }
}

void solve() {
  int n;
  cin >> n;
  cout << ans[n] << endl;
}

int main() {
  ios::sync_with_stdio(false);
  cin.tie(0), cout.tie(0);
  memset(ans, 0x3f, sizeof(ans));
  dfs(0, 0, 0);
  cin >> t;
  while (t--) { solve(); }
  return (0 - 0);
}
```
