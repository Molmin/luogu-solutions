~~想不到吧这道题可以用前缀和~~

~~但是挺麻烦的~~

思路：

1. 把字符输进来，如果是障碍则把它变成 1，否则为 0。
2. 对这个矩阵进行横向的一维前缀和（其实二维也可以，只用做一次，但是这道题没必要）
3. 从**第 0 个**开始枚举所有横着放的船（这里坑了我好久，因为 $a[i][j+k]-a[i][j]$ 的差应该为 $x[i][j+1]$ 到 $x[i][j+k]$ 的和。如果从 1 开始，那么就会从第 2 个开始计算，第二个点就会 WA），如果可以放就把 ans 数组里同样位置的数 +1。
4. 竖向操作同理。
5. 找寻最大坐标，输出。结束。

整体思路还是比较简单，如果这道题不是 $1×k$ 的话可能要用二维前缀和，但是如果是 $1×k$ 的话那就用用一维吧！（实际上只是我懒而已）

当然，如果 $n＜k$ 的话那么即使全是空的也放不下。所以就随便输出一个坐标就好了.（但是这个坐标必须在矩阵里所以输出两个 1 是最好的）

CODE：

```
#include<bits/stdc++.h>
using namespace std;
int x[114][514];//这里以及下面两行都是恶臭数组，不要看了
int a[114][514];
int ans[114][514];
int main(){
	int n,k,i,j;
	scanf("%d%d",&n,&k);
	if(n<k)//这里是特判
	{
		printf("1 1");
		return 0;
	}
	for(i=1;i<=n;i++)
	for(j=1;j<=n;j++)
	{
		char w;
		cin>>w;//由于scanf好像会把回车一起输进去所以我用了 cin
		if(w=='#')x[i][j]=1;//为前缀和做好准备
	}
	
    
    
    
	for(i=1;i<=n;i++)
	for(j=1;j<=n;j++)
	a[i][j]=a[i][j-1]+x[i][j];//横向一维前缀和
	
	for(i=1;i<=n;i++)
	for(j=0;j<=n-k;j++)//防止越界 以及 从 0 开始
	{
		if(a[i][j]==a[i][j+k])//如果相等，代表他们
		for(int l=j+1;l<=j+k;l++)ans[i][l]++;//标记
	}
    
    
    

	for(i=1;i<=n;i++)
	for(j=1;j<=n;j++)
	a[i][j]=a[i-1][j]+x[i][j];/同理，这次求竖向前缀和
	
	for(i=0;i<=n-k;i++)//因为是竖向所以竖向的应该为 0
	for(j=1;j<=n;j++)
	{
		if(a[i][j]==a[i+k][j])
		{
			for(int l=i+1;l<=i+k;l++)ans[l][j]++;
		}
	}
	int dx=1,dy=1;//先预设坐标
	for(i=1;i<=n;i++)
	for(j=1;j<=n;j++)
	{
		if(ans[dx][dy]<ans[i][j])//如果小于它就赋值成新的
		{
			dx=i,dy=j;
		}
	}
	
	
	
	printf("%d %d",dx,dy);
	
	
	return 0;
}
```