#### 这是本蒟蒻的第二篇题解，若不够详细请见谅，可欣赏上面或下面的神犇的题解
~~第一篇挂了，感谢同机房[神犇](https://www.luogu.com.cn/user/486675)的指导~~。

首先，我们读完题后大意是：给定一个 $n\times n$ 的矩阵，$m$ 次操作，并给定珂朵莉初始坐标 $(x,y)$，然后给定一个长为 $m$ 由 $\text{N,S,W,E}$ 组成的字符串，表示珂朵莉会向上、下、左、右移动。

珂朵莉未经过的地区的奶油厚度将会随着时间的增加呈现等差数列式的增加。而经过的地区，通过对样例解释的分析，我们可以发现：当前时间的奶油厚度不变，且要将时间归零后重新以等差数列式的增加。

然后我们去看看数据范围 $1\le n\leq 50,1\leq m\le 1000$。

如果暴力扫描的话时间是 $\mathcal O(mn^2)\leq250000$，也就是大约 $25ms<1s$，妥妥的能过。

所以我们可以用一个结构体储存总数与时间，在每次移动后对其进行更新。

然后我们需要去关注一下巨坑的输入与输出格式，首先比赛中表述的是先输入 $y$ 轴坐标，在输入 $x$ 轴坐标，而现在题目中的表述为 本题中的上和右分别表示 $y$ 轴正方向和 $x$ 轴正方向，其实这两句话是等效的。所以我们不妨理解成第一种，这样就不必在思考时将印象中的平面直角坐标系旋转 $90\degree$。

再来说输出，题目要求第 $i$ 行的第 $j$ 个数表示坐标 $(j,n-i+1)$ 上的灰的数量，在前面已经将 $x$ 与 $y$ 对调的条件下，输出也要对调（但更符合我们一般打代码的习惯），其次，我们也只需要在输出时处理 $n-i+1$ 这样可以简化代码。

而核心代码其实不长，只长这样：
```cpp
while(m--&&m>0)//因为最后一个点不影响，所以不读入
{
	cin>>c;
	if(c=='N') x+=1;
	if(c=='S') x-=1;
	if(c=='E') y+=1;
	if(c=='W') y-=1;
	f(i,1,n)//此处是用宏定义简化的for循环
   	{
		f(j,1,n)
		{	
			a[i][j].day+=1;
			a[i][j].sum+=a[i][j].day;
		}
   	}//将图上每个点的时间与奶油厚度更新
	a[x][y].sum-=a[x][y].day;
	a[x][y].day=0;//去掉途经点多加的奶油，并将时间归零
}
```
初始化代码与上面的类似，同时如果是在最后输出时用高斯求和更新总数，在此之前只对途经点更新总数的话可以减小常数，但天数还要更新。

总体代码详见[这里](https://www.luogu.com.cn/paste/x93mycme)。

[题目传送门](https://www.luogu.com.cn/problem/P8462)

求过！