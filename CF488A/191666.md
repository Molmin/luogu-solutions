这是一道水题，不算很难，我的做法和楼上大佬的思路不太一样，主要思路是枚举

看看我的思路吧

首先把正整数和负数分开

我们把那个数用a代替
- 如果是正整数，就从1到10(1)这十个数加上a枚举有没有数字是8，是8的话，因为要求最小，所以直接return

(1)为什么是一到十呢，让我们来模拟一下

假如那个数是15，加上3，就有数字是8

如果是11，加上7，就有数字是8

如果是28，就要加上10，变成38，就有数字是8（因为题目说要加上一个正整数，所以不能直接加零）

经过枚举，我们发现，加上的数最多是10

- 再来讲是负数的情况，虽然比正整数难，但也很简单（~~只让我郁闷了2个小时而已~~）

是负数的话，一开始我一点头绪也没有，后面想了想，唉，不管了，先把负数变成正整数再说

就比如a是 -14，看一眼就知道答案是6，如果没有-号还好办，有减号就麻烦点了

把它变成整数后（变成正整数的过程到时候再说）14要加4，就有数字是8，可是-14+4=-10，根本没有数字是8，可我突然发现，14只要-6就有数字是8，而-14+6也有数字是8，多试了几个样例后，发现都是这样，也是从1到10，只是变成减的了，但是如果是-1的话，就不是这样了1-比一大的数又变成了负数，那同理，-1~-9都是这样，我们发现-1~-8的有共同点，都是一个比一个大一，只要把9单独拿出来就行了。

下面献上代码

```
#include<bits/stdc++.h>
using namespace std;
long long a;
char s[20];
bool check(int x){
	while(x>0){
		int y=x%10;
		x/=10;
		if(y==8)return true;
	}
	return false;
}
//检查有没有数是8的
int main(){
	cin>>s;
    	//输入一串字符
	if(s[0]=='-'){
    	    //如果有减号，就不管减号
	    int cnt=1;
	    for(int i=strlen(s)-1;i>0;i--){
        	//i>0零减号就没有被计算了
	        int c=s[i]-'0';
		a+=c*cnt;
		cnt*=10;	
        	//把a变成整数
	    }
	    if(a<=8){
		int x=a;
		printf("%d",8+x);
        	//我们发现规律，x+8就是1到8的答案
		return 0;
        	//直接结束
	    }
	    if(x==9){
		printf("%d",1);
		return 0;
	    }
            //就拿出来独自判断
       	    for(int i=1;i<=10;i++){
		if(check(x-i)){
		    printf("%d",i);
		    return 0;
		}
        	//看看有没有符合条件的数
	    }
	}
    	//这里已经是判断正整数的了
	int cnt=1;
	for(int i=strlen(s)-1;i>=0;i--){
	    int c=s[i]-'0';
	    a+=c*cnt;
	    cnt*=10;	
	}
    	//把字符串变成一个数
	for(int i=1;i<=10;i++){
	    if(check(a+i)){
		printf("%d",i);
		return 0;
	    }
            //查找符合条件的数
	}
	
	return 0;
}
```
## ~~求过求赞~~

