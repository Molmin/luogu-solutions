暴力枚举每个数的话，肯定会超，而且这只是枚举，还没算每个所枚举

的数拆分时的循环次数。不过，由这个方法可以找到一些规律，就是所

有符合条件的数，都是以1，2，3开头的，由此我们就可以得到十个区

间，它们分别是：1-3，10-32，100-320，1000-3200，10000-32000

，100000-320000，1000000-3200000，10000000-32000000，

100000000-320000000，1000000000-1000000000，而且这十个区间

每个区间都有固定的符合条件的数的数量，那么，我们就可以利用这十

个区间来分别来对我们的L-R的区间来进行判断，即判断L-R和这十个区

间是子集关系还是交集关系，若是子集关系则可直接得到当前这个区间

所符合条件的数的数量，若是交集关系则可通过循环来得到符合条件的

数的数量，注意，这里的循环要比普通的暴力要快的多，因为没有枚举

所有数，只是枚举部分数。

以上简单点来说就是，通过判断交集和子集的关系来达到区间跳跃的效

果，也就可以省去很多不必要的尝试。（虽然还是很慢QWQ）


------------


```c
#include <stdio.h>

typedef long long ll;
int s(ll x);

int main(){
	int book[] = {3,9,24,63,153,362,819,1810,3872,1}; //每个区间所出现的兔子数的数量
	int index = 0; 
	int count = 0;
    ll L,R;
    ll i,j,a,b;
    
    scanf("%lld %lld", &L,&R);
    if(L == R){ 
		a = s(L*L);
		b = s(L);
		if(a == b*b){
			count++;
		}
	}
	else{
		for(i = 1; i <= R; i*=10){
			if(i == 1){
				if((L==1) && (R>=3)){ //[1,3]是[L,R]的子集
					count += book[index];
				}
				if((L==1&&R==2) || (L==2&&R==3)){ //[L,R]是[1,3]的子集 
					count += 2;
				}
				if((L==2) && (R>3)){ //[1,3]与[L,R]有公共部分,也就是交集 
					count += 2;
				}
				if((L==3) && (R>3)){ //[1,3]与[L,R]有公共部分,也就是交集 
					count += 1;
				}
			}
			else{
				if((i>=L&&i<R) && (32*i/10<=R)){ //[i,32*i/10]是[L,R]的子集
					count += book[index];
				}
				if((L>=i&&L<32*i/10) && (R<=32*i/10)){ //[L,R]是[i,32*i/10]的子集
					for(j = L; j <= R; j++){
						a = s(j*j);
						b = s(j);
						if(a == b*b){
							count++;
						}
					}
				}
				if((L<i) && (R>=i&&R<32*i/10)){ //[i,32*i/10]与[L,R]有公共部分,也就是交集 
					for(j = i; j <= R; j++){
						a = s(j*j);
						b = s(j);
						if(a == b*b){
							count++;
						}
					}
				}
				if((L>i&&L<=32*i/10) && (R>32*i/10)){ //[i,32*i/10]与[L,R]有公共部分,也就是交集 
					for(j = L; j < 32*i/10; j++){
						a = s(j*j);
						b = s(j);
						if(a == b*b){
							count++;
						}
					}
				}	
			}
			index++;
		}	
	}
	printf("%d", count);
    return 0;
}

int s(ll x){
    int sum = 0;
    
    while(x){
        sum += x%10;
        x /= 10;
    }
    return sum;
}
```
