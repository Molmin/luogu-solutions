题意：求区间最小值 * 区间和的最大值。

首先我们~~打个暴力~~观察一下“区间最小值”，明显发现，有许多区间的区间最小值是一样的。并且区间最小值只有 $ n $ 种可能。

那么我们显然可以枚举这个区间最小值。设这个区间最小值为 $ a_i $，那么这个区间一定是包含 $ i $（位置）的。因为所有的数都是正数，所以要想使区间和最大，就要让区间左端点尽量靠左，右端点尽量靠右，也就是让 $ i $ 往左和往右延伸出去越多。但是延伸不是无条件的，区间里的数都不能小于 $ a_i $（不然最小值就变了）

所以我们可以依次选择每个数为最小值，每次 $ O(n) $ 扫描区间范围。这样的复杂度是 $ O(n^2) $，考虑怎么优化后一个 $ O(n) $。

~~经过漫长的思考~~我们发现，如果按数字大小从大到小选择每个数为最小值，那么可以选择的数字只会变多，不会变少，而且每次会增加一个可选数。

所以可选的数字组成了若干个区间。每次我们需要合并一些区间，然后查询一个区间的大小（里面所有数的总和）。我们发现，这个事情可以用并查集来解决，总和就是维护size大小，将所有集合的初始size设为这个数字的值就可以了（当然还有别的做法，~~但是懒得写了直接并查集不就OK了吗233~~）

代码细节上面，$ vis $ 数组用来记录一个数字可不可以被选择。具体实现是当一个数字可以被选入区间时，将它变成一个独立的集合，然后和旁边（左右）的集合进行合并。（记得先离散化）

Code：
```
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;;
int a[100001],x[100001],fa[100002],sz[100001];
bool cmp(int a,int b)
{
	return x[a]>x[b];
}
int Root(int x)
{
	return fa[x]==x?x:fa[x]=Root(fa[x]);
}
bool vis[100001];
int main()
{
	int n;
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&x[i]);
		a[i]=i;
	}
	sort(a+1,a+n+1,cmp);
	for(int i=1;i<=n;i++)
	{
		fa[i]=i;
		sz[i]=x[i];
	}
	ll ans=0;
	for(int i=1;i<=n;i++)
	{
		vis[a[i]]=true;
		if(vis[a[i]-1])
		{
			int r=Root(a[i]-1);
			fa[r]=a[i];
			sz[a[i]]+=sz[r];
		}
		if(vis[a[i]+1])
		{
			int r=Root(a[i]+1);
			fa[r]=a[i];
			sz[a[i]]+=sz[r];
		}
		ans=max(ans,ll(x[a[i]])*sz[a[i]]);
	}
	printf("%lld\n",ans);
	return 0;
}
```