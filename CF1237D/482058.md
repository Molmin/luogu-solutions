这是我们考试题，考试打了个不知道是什么玩意儿的线段树然后爆零了……

正解是单调队列，时间复杂度 $\Theta(n)$。

我们先把数组复制 $3$ 遍。等等，为什么不是两遍呢？

因为最大值有变化，某首歌是否满足条件的数据在变化，所以可能出现第一次可以播放，但第二次不行的情况。平时我们是复制两遍，所以这里要多复制一遍。

然后从第一首歌开始，一次遍历被复制了三遍的数组，维护一个单调递减的队列。当然，里面存的是数组下标，下标当然不是单调递减的，但是代表的喜爱值是递减的。

我们以样例举例：

`3 2 5 3`

```
i =   1  2  3  4  5  6  7  8  9  10 11 12
a =   3  2  5  3  3  2  5  3  3  2  5  3
ans = 0  0  0  0  0  0  0  0  0  0  0  0
```

每次遍历到一个数，依次进行如下操作：

1. 判断队首元素是否符合标准，当前遍历到的元素 $i$ 是否满足要求，即是否有 $a_i<\dfrac{a_{q.\text{front()}}}{2}$。如果是，那么计算队首元素的答案（从它开始最多可以放多少首歌，**即为当前遍历到的歌曲编号减去队首元素的编号**）并把队首元素弹出。

	**注意队首可能不止一个元素不满足要求，需要连续弹出。**

   比如我们遍历到了 $6$ 号，然后单调队列现在长这样：
   
   `front {3, 4, 5} back` 也就是 `front {5, 3, 3} back`
   
  	本来没什么问题，但是注意到 $2<\frac{5}{2}$，所以如果播放了 $3$ 号歌曲，就不能播放 $6$ 号歌曲了。那么，从 $3$ 号歌曲开始播放最多能播放 $6-3=3$ 首歌，也就是 $3,4,5$ 这三首。
   ```
                         v i遍历到这儿了
	i =   1  2  3  4  5  6  7  8  9  10 11 12
	a =   3  2  5  3  3  2  5  3  3  2  5  3
	ans = 0  0  3  0  0  0  0  0  0  0  0  0
		        ^答案被更新
	```

2. 把遍历到的元素放进单调队列。当然，为了保持单调，也许需要弹出队尾的一些元素。

	**其实这也是为什么不能用队列长度来更新答案的原因。有些数可能会被弹掉，此时直接用队列长度判断答案可能会遗漏。**
    
遍历完数组之后就可以输出答案了，但是有个问题：

比如样例遍历完之后 `ans` 数组长这样：

`0 0 3 0 0 0 3 0 0 0 3 0`

那 $1,2,4$ 号怎么办呢？

其实这个很简单，你想一下，就以 $2$ 号歌曲举例，你先听一首到 $3$ 号歌曲，然后再按照 $3$ 号的答案计算不就行了吗？所以这里我们再倒序遍历一遍数组，如果某个下标的答案没被更新，就把答案更新为 `在它后面的最近的一个本来就有答案的值 + 当前遍历到的下标和那个数的下标之差`。

给出代码：

```cpp
#include <cstdio>
#include <deque>
#define rep(i, j, k) for(int i = j; i <= k; ++i)
#define dep(i, j, k) for(int i = j; i >= k; --i)

const int maxn = (int)3e5 + 5;

int n, N, a[maxn], ans[maxn];
std::deque<int> q;

inline void file() {
	freopen("playlist.in", "r", stdin);
	freopen("playlist.out", "w", stdout);
	return;
}

int main() {
	file();
	scanf("%d", &n);
	rep(i, 1, n) {
		scanf("%d", &a[i]);
		a[i + n] = a[i + (n << 1)] = a[i];
	}
	N = 3 * n;
	rep(i, 1, N) {
		while(!q.empty()/*防止 RE*/ && (a[i] << 1) < a[q.front()]) {
			ans[q.front()] = i - q.front();
			q.pop_front();
		}
		while(!q.empty() && a[q.back()] < a[i])
			q.pop_back();
		q.push_back(i);
	}
	int tot = 0, lst = N + 1;
	dep(i, N, 1) {
		if(ans[i]) {
			tot = 0;
			lst = i;
		} else
			ans[i] = ans[lst] + tot;
		++tot;
	}
	rep(i, 1, n)
		printf("%d ", (ans[i] < n << 1) ? ans[i] : -1);
	return 0;
}
```