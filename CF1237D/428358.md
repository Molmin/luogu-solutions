[题面](https://www.luogu.com.cn/problem/CF1237D)

先来分析一下样例。

- 样例1

```
4
11 5 2 7
```
第 1 首歌，听到第 2 首时 $5<\frac{11}{2}$ 只有 1 首。

第 2 首歌，听到第 3 首时 $2<\frac{5}{2}$ 只有 1 首。

第 3 首歌，听到第 2 首时 $5<\frac{11}{2}$ 只有 3 首。

第 4 首歌，听到第 2 首时 $5<\frac{11}{2}$ 只有 2 首。

所以输出是 `1 1 3 2`。

- 样例2

```
4
3 2 5 3
```
第 1 首歌，听完一圈再到第 2 首时 $2<\frac{5}{2}$ 只有 5 首。

第 2 首歌，听完一圈再到第 2 首时 $2<\frac{5}{2}$ 只有 4 首。

第 3 首歌，听到第 2 首时 $2<\frac{5}{2}$ 只有 3 首。

第 4 首歌，听完两圈再到第 2 首时 $2<\frac{5}{2}$ 只有 6 首。

所以输出是 `5 4 3 6`。

- 样例3

```
3
4 3 6
```
每一首歌都会无限播放下去，所以输出是`-1 -1 -1`。

然后，我们发现，本题其实只需要一个[单调队列](https://oi-wiki.org/ds/monotonous-queue/)。我们维护一个单调递减队列，如果队首大于了现在要插入元素的二倍，就弹出它，并更新他的答案。最后，因为有可能有的答案不会被更新，所以我们还要加一个处理，具体细节在代码中讲述。

代码
```cpp
  #include<bits/stdc++.h>
  using namespace std;
  int n,a[300005],ans[300005];//a存储元素的值，因为可能会超过2倍的范围，所以开3倍（具体参考样例2），ans存储答案
  deque<int>q;//单调队列用双端队列实现
  int main()
  {
      scanf("%d",&n);
      for(int i=1;i<=n;i++)scanf("%d",&a[i]),a[i+n]=a[i+2*n]=a[i];//复制2次
      for(int i=1;i<=3*n;i++){
          while(!q.empty()&&a[q.front()]>a[i]*2){//考虑队列前端是否大于了二倍a[i]
              ans[q.front()]=i-q.front();
              q.pop_front();
          }
          while(!q.empty()&&a[q.back()]<a[i])q.pop_back();//维护单调
          q.push_back(i);
      }
      for(int i=n*3;i>=1;i--){
          if(ans[i]==0&&ans[i+1]!=0)ans[i]=ans[i+1]+1;//如果它没被更新过，那它一定是被维护单调时弹出了，找到它后面第1个有值的元素，再加上距离即可（证明在后），这里用从后往前遍历来累加，也可以达到同样的效果
      }
      for(int i=1;i<=n;i++)printf("%d ",(ans[i]==0?-1:ans[i]));//如果还是0，那就是因为可以无限播放，输出-1
      return 0;
  }
```

## 证明

在**不存在**无限播放的情况下，对于一个因为维护单调被弹出的元素，将它弹出的那个元素也可能也会被其他元素因为维护单调而弹出。但一定会有一个元素 $i$ 是因为作为队首而大于队尾的二倍而被弹出（否则就会存在无限播放）。那么，在 $i$ 之前的那一段连续的没有答案更新的元素一定是也是在从 $i$ 开始播放停止的地方停止（因为 $i$ 是这一段中最大的）。那对于每一个在这一段中的元素，它的答案就是它到 $i$ 的距离加上 $i$ 的答案。