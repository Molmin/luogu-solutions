# 题目大意：

一句话：给你一个字符串，求出有几个形如 $"a"$ 或 $"aba \ldots aba"$ 的子序列。

# 思路：

定义 $ans$ 为从字符串开始到当前位置能构造出的子序列总数。

可以想到，只有当前你枚举到字符串里的字符为 $"a"$ 时，才能构造出需要的子序列。

分情况讨论当前 $"a"$ 能构造出的子序列：

1. 形如 $"a"$ 的子序列。

这个简单，直接将 $ans$ + $1$ 。

2. 形如 $"aba \ldots aba"$ 的子序列。

为了形成这样的子序列，我们需要找到离当前 $"a"$ 最近的一个 $"b"$ 。在这个 $"b"$ 之前能得到的所有答案都可以与当前的 $"a"$ 构成需要的子序列。

这样的话，$ans$ += 最近的 $"b"$ 之前能得到的所有答案。

### 所以：

当我们遇到一个 $"a"$ 时，$ans$ += $1$ + 最近的 $"b"$ 之前能得到的所有答案。

---

可能有人会问，最近的 $"b"$ 之前能得到的所有答案怎么求呢？

你可以拿一个变量 $x$ 把它记录下来嘛，每次遇到一个 $"b"$ 时，让 $x$ = 当时的 $ans$ 就好啦。

遇到 $"a"$ 时就让 $ans$ += $x$ + $1$ ，多么明了啊。

---

**注意取模哦！别忘了这一点。**

---

# Code：
```cpp
#include<bits/stdc++.h>
using namespace std;
string a;
int ans,x;
int main(){
	cin>>a;
	for(int i=0;i<a.size();i++){
		if(a[i]=='a')ans=(ans+x+1)%1000000007;
		if(a[i]=='b')x=ans;
	}cout<<ans;
	return 0;
}
```