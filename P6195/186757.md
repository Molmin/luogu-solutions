# 开始！！


蒟蒻的第一篇月赛题解，求过……

在敲代码之前，我们应该尝试把这个看似复杂的问题化简，找出它的本质。

先从手里的n个1开始分析——编号在1~n之间的人都可以迫害。

然后再从手里的m个自定义数字开始分析——

因为第n+1个人不能被小Z用这n个1进行迫害，所以我们把第一张个自定义数字定为n+1。

接下来，我们会发现编号在n+1~2n+1之间的人也可以迫害了。因为这些数可以表示为：(n+1),(n+1)+1,(n+1)+2,(n+1)+3,……,(n+1)+n，而1~n之间的数都是可以用1组成的, n+1是我们之前自定义的数字，所以编号在n+1~2n+1之间的人也可以迫害了。

再之后，我们把第二张个自定义数字定为2n+2。这样，编号在2n+2~4n+3之间的人又可以迫害了。

以此类推，编号在1~2^m*n+2^m-1之间的人可以迫害.

化简一下，范围就变成了1~2^m*(n+1)-1.

所以，这就变成了一道快速幂题。

哦，对了，再求2的m次幂的时候要记得%1000000007.

好啦，AC代码如下：

```
#include<bits/stdc++.h>
using namespace std;
long long mod=1000000007;
long long n, m, ans, two[100], k[100], cnt=1, sum=1;
int main()
{
    cin>>n>>m;
    if(m==1)//一个特判
    {
        cout<<(n+1)*2%mod-1;
        return 0;
    }
  	//接下来就是快速幂，这个常识……算了我还是注释下吧(应该不只有我一个人是这样写快速幂的吧……)。
 	 two[0]=2;//2^1=2
    k[0]=1;//k数组表示的是two数组中对应的数组是2的几次幂。
    n++;//这里，为待会答案的输出做准备
    for(int i=1;;i++)//从1开始无限循环，因为是数组下标的原因，只能从1开始，所以我在上面加了个特判。
    {
        k[i]=k[i-1]*2;//记录这是2的几次幂。
        two[i]=two[i-1]*two[i-1]%mod;//计算2的k[i]次幂。
        if(k[i]>=m)//如果k[i]>m，就退出循环，这代表着我们所求出的幂已经够我们使用了
            break;
        cnt++;//计数器++
    }
    for(int i=cnt;i>=0;i--)//从大到小遍历two数组
        if(m>=k[i])//如果m>k[i],我们就让sum=two[i]*sum,记得%1000000007
        {
            sum=(sum*two[i]%mod)%mod;    
            m-=k[i];//让m减去k[i]。
        }
    cout<<n*sum%mod-1;//根据之前分析出来的范围输出答案
  	//实话说，快速幂应该是基本功
    return 0;
}
```
## 再见啦！