难度为 CSP-J T2，思维难度不大的结论题。

-------

### 解题思路

**前置知识：** 快速幂。

很遗憾，笔者想不到部分分的做法（暴力？），这里直接讲正解。

其实**样例**已经暗示正解了。

给定了 $n$ 个 $1$，那么我们必然可以得到 $1\sim n$ 这 $n$ 个数。

那么接下来，为了保证接下来能得到 $n+1$，我们只能选择加入一个 $n+1$ 或者 $1$。

显然前者更优，因为加入 $1$ 最多也只能凑到 $n+1$；

而如果加入 $n+1$，前面连续的 $n$ 个数每个都能与其搭配得到新的数，且一定会得到新的连续的 $n$ 个数，加上 $n+1$ 本身也就是产生了新的 $n+1$ 个数。

此时总数为 $n+n+1=2n+1$。

按照这种思路继续往下：

加入 $2n+2$，总数为 $2n+1+2n+2=4n+3$。

加入 $4n+4$，总数为 $4n+3+4n+4=8n+7$。

加入 $m(n+1)$，总数为 $2^{m}(n+1)-1$。

至此，找规律答案就出来了。

$$\text{Ans}=2^m(n+1)-1$$

记得取模。

由于 $m\le 10^9$，且使用 `std::pow()` 不能取模，中间会乘爆`long long`，因此我们只能使用快速幂。

时间复杂度 $O(\log m)$。

事实上，观察每次加入的 $m(n+1)$，我们发现这是一个首项为 $n+1$，公比为 $2$ 的等比数列。

代入等比数列的求和公式，再加上 $n$，就是答案。虽然看上去不同，但是化简后都是一样的。

$$\text{Ans}=(2^m-1)(n+1)+n$$

### 参考代码

本题无坑点，放心打。~~不开`long long`我无话可说~~

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;

typedef long long ll;
const ll MOD=1000000007;
ll n,m,ans;

ll fpow(ll b,ll p)//快速幂
{
	ll ans=1;
	while(p)
	{
		if(p&1)
		 ans=ans*b%MOD;
		b=b*b%MOD;
		p>>=1;
	}
	return ans;
}

int main()
{
	cin>>n>>m;
	ans=fpow(2,m)*(n+1)%MOD-1;//套式子
	cout<<ans%MOD<<endl;
	return 0;
}
```