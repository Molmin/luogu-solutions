- 希望自主思考。
- 希望全力以赴。
- 希望不留遗憾。

**题意**
- [题意](https://www.luogu.com.cn/problem/P7476)。
- 维护 $n$ 个可重集 $A_1,A_2,\cdots A_n$。
- 支持三个操作：
- 给下标在 $[l,r]$ 间的集合加入元素 $k$。
- 查询下标属于 $[l,r]$ 间任何一个集合的最大值。
- 删除下标属于 $[l,r]$ 间任何一个集合的最大值（一个集合最多只删除一个）。

**分析**
- 感觉好像用线段树套堆可以搞，但是问题是我们要维护哪些信息，而且怎么样让聚合复杂度和空间过得去。
- 这是好想的，只要我们把一次区间加变成最多 $O(\log n)$ 次堆中的元素加入，这可以通过线段树本身的结构来实现，然后我们需要：
- $O(\log n)$ 左右的复杂度找到区间的最大值。（所有堆的最大值）
- 快速精确有效地删除部分堆中的元素并更新信息。（这部分的复杂度显然是由插入操作保证的，如果你让插入的元素不多那么删除的元素肯定也不多）
- 想到这里感觉自信满满啊！吼啊！这肯定是正确思路导向的对吧！那么我们赶快想怎么实现吧。

**实现**
- 我们开一棵线段树，上面的每个节点维护一个堆表示堆在该区间插入的数，整个区间内部（不考虑跨过这个大区间）的最大值。
- 如果是区间加，那么暴力加，复杂度是 $O(\log^2n)$ 的，因为要对 $O(\log n)$ 个区间进行操作。
- 如果是区间查询，那么暴力查询，复杂度是 $O(\log n)$ 的，注意标记不下传的影响。
- 最后是最麻烦的区间删除操作，我们先查询这个区间的最大值，然后暴力遍历区间直到出现以下两种情况的一种：
- 该区间的最大值小于我们要删除的值，这样直接不管它就好了。
- 该区间节点（注意不是整个区间）的最大值大于等于我们要删除的值：这个时候可能会出现两种情况，一种是该区间节点恰好被查询区间完整覆盖（这个直接暴力删除就好了），另一种是该区间节点不被查询区间完整覆盖，这个时候我们仍然选择暴力删除，但是需要在没有覆盖的区间上搞一个区间加操作。
- 这一部分看似很暴力，但正如我们之前所说的 _如果你让插入的元素不多那么删除的元素肯定也不多_ 。实际上你真的可以分析一下，假设操作删除 $k$ 个元素，那么复杂度是 $O(k\log^2 n)$ 级别，但是算上插入操作每次带来的 $O(\log n)$ 个元素，和删除操作每次带来的 $O(\log n)$ 个新元素（因为每次删除带来的只有 $O(\log n)$ 个段），所以总的段数是 $O((n+q)\log n)$，这个操作的复杂度显然不超过 $O((n+q)\log^2n)$。
- 所以所有操作总的复杂度是 $O((n+q)\log^2n)$，当然，不难看出常数挺大的，[代码实现](https://www.luogu.com.cn/paste/g3ealgcp)。