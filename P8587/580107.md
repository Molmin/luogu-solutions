# P8587 新的家乡



吐槽一下比赛题目的难度分配，似乎这场比赛后两道题更简单（或者我适合做的题是有针对性的）。

## step 1：读题

刚看到题面的我内心一寒，还以为是遇到了[小木棍](https://www.luogu.com.cn/problem/P1120)的翻版。

但仔细一看，这题是跟小木棍有区别的，主要是下面这几条。

- 而每根柱子都需要由**恰好**两根锰钛矿石顺次连接组成。
- 每根锰钛矿石**显然至多被使用一次**。

这两条限制了组合的方式，与小木棍一题产生了很大的不同。


------------
## step 2：解题

我们根据一组样例来展开解题。

#### 样例输入    
```
5
3 2 1 5 4
```
#### 样例部分
```
2 3
```
遇题不决，暴力美学（我是向来打暴力打到癫狂的那种人）。

对于本题，我想出了两种暴力的解法。

### 解法一：

用一个数组 $sum[k]$ 存放柱子长度为 $k$ 时能够组成的柱子个数，将每根锰钛矿石分别与其他的矿石组合在一起，并把对应的柱子长度即 $sum[ h_i+h_j ]$ 加 $1$，最后统计出柱子数最多的方案个数，按题目输出即可。

这个暴力方案是枚举每一个锰钛矿石所能组成的柱子的长度，时间复杂度 $O(n^2)$ ，显然是会超时。

![](https://cdn.luogu.com.cn/upload/image_hosting/jvgib07m.png?x-oss-process=image/resize,m_lfit,h_340,w_450)

- 样例解析

一号矿石分别和二号到五号矿石可以组成长为 5、4、8、7 的柱子。

二号矿石分别和三号到五号矿石可以组成长为 3、7、6 的柱子。

三号矿石分别和四号到五号矿石可以组成长为 6、5 的柱子。

四号矿石可以和五号矿石组成长为 9 的柱子。

### 解法二：

枚举在柱子长度一定的情况下，能够组成多少根柱子。表面上看与解法一并没有什么两样，但我们改变一下存储的方式。

从题目中可以看出，锰钛矿石高度的范围很小，直接就可以用纯的标记数组将其存下，于是便有了以下的算法。

我们将 $vis[k]$ 表示为高度为 $k$ 的锰钛矿石的个数。当我们枚举柱子长度为 $i$ 的时候，如果一个高度为 $j$ 的锰钛矿石能够组成一个长度为 $i$ 的柱子，就必须要有一个高度为 $i-j$ 的锰钛矿石与之对应。**即如果 $ vis[ j ] $不为 $0$ 且 $vis[ i-j ] $ 也不为 $0$时 ，那就一定可以组成柱子**。

注意 $vis$ 数组中存放的是锰钛矿石的个数，所以在满足上述条件后，柱子的个数需要增加的是 $min(vis[ j ],vis[ i-j ])$ 。也有特殊情况，比如 $j=i-j$ 时，需要特判。还要注意 $i$ 和 $j$ 的取值范围，当 $j$ 枚举到 $i$ 的一半时就可以不用继续枚举了，因为再往后所出现的情况会与之前的相重复，没有必要再进行运算。

这个暴力方案是枚举在柱子长度一定的情况下，能够组成多少根柱子，时间复杂度约为 $O(max(h_i)^2)$ ，在最极端的状况下时间复杂度也不会超过 $10^7$ ，不会超时。

![](https://cdn.luogu.com.cn/upload/image_hosting/tzmzkvum.png?x-oss-process=image/resize,m_lfit,h_340,w_450)

- 样例解析

当柱子长度为 3、4、8、9 时，都只能组成一根柱子。

当柱子长度为 5、6、7 时，能够组成两根柱子。

------------
## step 3：代码

蒟蒻的代码，采用的为上文所提到的解法二，不喜勿喷。
```cpp
#include <iostream>
using namespace std;
const int MAXN = 1e6;
int vis[MAXN],n,gin=2147483647;
//vis[i]表示高度为i的锰钛矿石的个数
//gin存放所有锰钛矿石中高度最小的一个，减少不必要的循环
int ans,res=-1,now_res;
//now_res存放每一次枚举当前柱子长度时所能被构成的柱子个数
//res存放最大的柱子个数
//ans存放能构成最大的柱子个数的方案数 
int main(){
	cin>>n;
	int x;
	for(int i=0;i<n;i++){
		cin>>x;
		vis[x]++;
		gin=min(gin,x);
	}//输入部分
	for(int i=gin;i<=6000;i++){//枚举柱子长度
		now_res=0;
		for(int j=0;j+j<=i;j++){
			if(j+j==i&&vis[j]){//特判，两根长度相等的锰钛矿石 
				now_res+=(vis[j]/2);
				continue;
			}
			if(vis[j]&&vis[i-j]){//即上文中所提到的计算方法
				now_res+=min(vis[j],vis[i-j]);
			}
		}
		if(now_res==res) ans++;
		//若当前柱子个数等于之前的最大柱子个数，则方案数加 1 
		if(now_res>res){
			res=now_res;
			ans=1;
		}//若当前柱子个数大于之前的最大柱子个数，则更新 
	}
	cout<<res<<' '<<ans;
	return 0;
}
```
