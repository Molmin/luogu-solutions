这道题看起来花里胡哨，我们看看样例发现其实就是有几段不同，如果开始为1就时间加个1就OK。

### 怎么证明呢？？

我们推一推：

如果当前在面前的是1比如：11000011

那么我们等1秒，变成00111100.

花一秒走过去，11000011，此时我们面前还是0

再走过这串零，前面的1又变成了0.....

所以我们在中间是不要等待的。答案也就是段数。

### 具体方法

不开long long见祖宗，还是开一个好。

数组开大1个方便加上最后一段。

#### 第0个赋0,很巧妙，如果第一个是0则不加秒数，不是0则加一秒。

加上的最后一个赋为不同于原来的最后的值，也就可以把最后一段加上。

不说了，看代码：


```
#include <bits/stdc++.h>
using namespace std；
bool p[1000002];//监控开启状态
long long n,i,ans;
int main(){
cin>>n;
for(i=1;i<=n;i++) cin>>p[i];  //输入
p[0]=0;   //第0个赋0
p[n+1]=1-p[n];  //加上一个赋为1-最后一个
for(i=1;i<=n+1;i++) if(p[i]!=p[i-1]) ans++;  //求中间的段数
cout<<ans; //输出
return 0;
}
```

珍爱账号，请勿抄袭（抄袭有惊~~吓~~喜哦~）
