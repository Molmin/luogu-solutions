### 题目背景

由于$Y$校最近进行了对学校食堂的全面改革与对小卖部的全面整治(乱搞)，导致学校小卖部卖的零食被禁售了；学校食堂的炸鸡窗口也消失了；

并且学校的学生处$Q$主任严禁学生点外卖，日夜监察。

都说民以食为天，由于整天挨饿，全校同学处于水深火热之中。

### 题目描述

$zhouwc$的朋友（朋友就是自己系列）小$Z$由于饥饿难忍，不得不铤而走险点外卖。

但是学校的$Q$主任为了能够抓住点外卖的学生布置了天罗地网——监控

但是由于学校给$Q$主任的经费有限，所以这些监控不能持续工作，工作一秒之后便要暂停休息一秒，即开启一秒后关闭一秒再开启一秒...以此类推。

还是由于$Q$主任的经费有限，这些监控被排成了一条直线，这条直线便在学生通往学生外卖驻点——二号门（没有门卫）的必经之路上。

因为小$Z$修习了疾跑技能，所以小$Z$通过任意个数关闭的监控的时间均为1（即一次行动可以经过若干个未开的监控）。

由于小$Z$想吃外卖又不想受到正在监控室看着监控的$Q$主任的处分，请你告诉他至少要多少时间才能安全到达外卖驻点。

------------
### 解法：
用一个变量储存所有的读入的值，一个变量记录前一个值，如果当前与前一个不相等，$ans$++。

时间复杂度$O(n)$,空间复杂度$O(1)$
### 完整代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,dq=1,ans,ls;
inline long long read(){//读入优化
	long long f=1,out=0;char c=getchar();
	while(c>'9'||c<'0'){
		if(c=='-')f=-1;
		c=getchar();
	}
	while(c<='9'&&c>='0'){
		out*=10;out+=c-'0';
		c=getchar();
	}
	return f*out;
}
int main(){
	n=read();
	for(long long i=1;i<=n;i++){
		ls=read();//读入
		if(ls!=dq){//不相等ans++
			ans++;
			dq=ls;
		}
	}
	cout<<ans;
	return 0;
} 
```