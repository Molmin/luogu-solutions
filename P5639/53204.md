>这些监控不能持续工作，工作一秒之后便要暂停休息一秒，即开启一秒后关闭一秒再开启一秒...以此类推

>一次行动可以经过若干个未开的监控

>保证第一个监控一定是关闭的

注意这几点结论就很显然了，由于一次能经过的长度是无限的，所以限制的只有监控的是否开关了，对于一次疾跑，他所经过的最长距离即为连续的相同 $\text{0/1}$ 序列的长度。

所以这道题就变成了：给你一个 $\text{0/1}$ 序列，求有多少个不同的连续 $\text{0/1}$ 子序列。

基于上述结论，就可以愉快的秒切这题啦。~~虽然机房大佬在开赛3分钟内就切了1-2了~~

```cpp
#include <bits/stdc++.h>

using namespace std;

int main () {
	int n;
	int last = 1;//第一个监控必定关闭，所以初值设为1.
	int ans = 0;

	cin >> n;

	for(int i = 1; i <= n; i ++) {//边读边做，遇到不同的ans就++.
		int input;

		cin >> input;
		
		if(input != last) {
			last ^= 1;//0切换为1 | 1切换为0.
			ans ++;
		}
	}
	cout << ans;
	return 0;
}

```