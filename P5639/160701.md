来自一个第一题只拿了$92pts$的蒟蒻  

这道题我们通过读题就可以发现，**连续的所有当前状态相同监控摄像头都可以在遇见时用$1s$直接跑过去。**

举个简单的栗子（z代表小z）
```
Z  0   1   0   0   1
```
首先我们用$1s$跑过第一个关闭的摄像头，此时总用时$=1s$
情况如下:
```
1 Z 0   1   1   0
```
然后第二个摄像头已经关闭,我们也可以用$1s$跑过去，总用时$2s$  
```
0   1 Z 0   0   1
```
接下来两个摄像头都是关闭的,直接跑过去，总用时$3s$  
```
1   0   1   1 Z 0
```
接下来直接跑过去，就有可口的外卖了，总用时$4s$  

所以很容易发现ans=初始情况下连续为0或1的子段个数  

由于题目保证**第一个监控一定是关闭的**
所以我们不用花时间来等第一个摄像头关闭，可以直接跑过去 
（其实要的话也只需要加一个特判然后ans+1就可以）  

又是喜闻乐见的代码时间  
```cpp
#include <cstdio>
int a[1000005];
int main() {
	int n,tot=0;
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&a[i]);
		if(i>1)
		{
			if(a[i]!=a[i-1]) tot++;
		}
	}
	printf("%d",tot+1);
   	//由于最后一段在第n个的时候会被结束无法统计，所以需要手动+1
   	//此外，也可以在a数组最后设置一个-1（非0或1即可）帮助统计
	return 0;
}
```
就这样了，蒟蒻去回肝$T1$和$T3$了，债见。
