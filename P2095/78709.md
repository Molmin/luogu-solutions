## 水一篇题解

评测机崩了还没来得急测
~~代码如果有问题求原谅~~（5.11）
![机你太美](https://cdn.luogu.com.cn/upload/pic/58446.png )



------------
这道题长得我需要一个语文班，信息全塞进了一堆里面（~~班主任蛋皮：费tm的话多~~）

呼唤我的~~亲爱的~~语文老师dcm（~~蓝色妖姬~~）中


------------
- 二狗：dls还没上课呢
- dls：我来了就是上课了

- dls：拿出你们的luogu翻到第2095页营养膳食，先一起读一遍
- classmates：哇啦哇啦哇啦哇啦
- dls：张嘴，一个个懒样风气要死不活的，我给你们听哈子今天早上二班的早读（拿出华为p7青春版）
- ......


------------
言归正传，这道题目可以归纳一下

### 题目分析
1. 阿月希望吃到更多的脂肪。

1. 然而也不能只吃高脂肪食品。

1. 阿月想要在营养膳食的情况下吃到更多的脂肪。

4. 阿月的食量也是有限的。

1. 阿月每顿饭最多可以吃m份食品。

1. 有n种食品供阿月选择。

1. 这n种食品分为k类。

1. 表示可以吃1到k类食品的最大份数。

接下来n行每行包括2个正整数，分别表示
该食品的脂肪指数ai和所属的类别bi。

输出阿月可以吃到的最大脂肪

【样例分析】
- 6(道菜) 6(份) 3(类)
- 3 3 2（每种最多能吃的数量）
- （脂肪）（种类）
- 15 1 （第1道菜）
- 15 2
- 10 2
- 15 2
- 10 2
- 5 3  （第6道菜）


------------
## 思路
为了方便打代码，加了个宏定义#define FOR(i,a,b) for(int i=a;i<=b;i++)

直接把所有蔡的脂肪和种类放在一个数组里，后面直接暴力循环求ans就行了

因为阿月希望吃到更多的脂肪，所以先排序（~~懒得打结构体~~用数组存的，所以使用冒泡排序
```cpp
FOR(i,1,n)
{
    FOR(j,i,n)
    {
		if(zf[i]<zf[j])
		{
			swap(zf[i],zf[j]);
			swap(kind[i],kind[j]);
		}
	}
}
```
然后while循环，看到题解里面有个for循环，m满了后还会继续运行

tj代码
```cpp
for(int i=1; i<=m; i++) {
    if(d[c[i]]<b[c[i]]&&eat<m) //如果这个食物还没吃到上限，总量也未到上限 （//循环内判断总量是否到达上限，如果到上限了还会运行）
    {
        ate+=a[i];
        d[c[i]]++;
        eat++;
    }

}
```
下面我的代码
```cpp
while(eat!=m)//while循环判断总量是否到达上限，如果到上限了停止运行
	{
		k++;
		if(best[kind[k]]!=0)
		{
			ans+=zf[k];
			best[kind[k]]--;
			eat++;
		}
	}
```
可以少循环总蔡-m满时次

当然也可以加一个
```cpp
if（eat>m）
break；
```


------------

### 上代码
```cpp
#include<iostream>
#include<cstdio>
#include<string>
using namespace std;
#define FOR(i,a,b) for(int i=a;i<=b;i++)
int n,m,k;
int best[205]/*每种蔡最多吃多少*/,zf[105]/*蔡的脂肪*/,kind[105]/*蔡的种类*/;
int eat/*已经吃的蔡总量*/;
int ans;
int main()
{
	//freopen("diet.in","r",stdin);
	//freopen("diet.out","w",stdout);
	scanf("%d%d%d",&n,&m,&k);
	FOR(i,1,k)
	{
		scanf("%d",&best[i]);
	}
	FOR(i,1,n)
	{
		scanf("%d%d",&zf[i],&kind[i] );
	}
	FOR(i,1,n)//冒泡排序不解释
	{
		FOR(j,i,n)
		{
			if(zf[i]<zf[j])
			{
				swap(zf[i],zf[j]);//记得两个都swap
				swap(kind[i],kind[j]);//讨论区有个大佬就是因为只swap了一个炸了
			}
		}
	}
	int k=0/*循环计数*/; 
	while(eat!=m)
	{
		k++;
		if(best[kind[k]]!=0)//如果那种蔡还能吃
		{
			ans+=zf[k];//加脂肪
			best[kind[k]]--;//我直接在输入的每种蔡最多吃多少里减
            //破坏了每种蔡最多吃多少，反正后面也不会用了
            //让best数组的意义变成每种蔡还能吃多少
			eat++;
		}
	}
	printf("%d",ans);
    //瑞特恩零
}
```
这个代码只能得60分，因为数据好像比给的数据范围大

把数组开大就行了


------------
更新(5.14)

发现了一个bug，在特殊情况下，当所有菜都循环完了没有可以吃的，但m没有满，就会一直循环下去！！！for循环不会出现这种问题，但是while会越界！！！

比如

- 总共可以吃m=10
- 有1 2 3三种蔡
- 1种蔡最多吃kind[1]=4;
- 2种蔡最多吃kind[2]=2;
- 3种蔡最多吃kind[3]=6;

然而数据是这样的 

| 脂肪|  种类|
| -----------: | -----------: |
|10|1|
|10|1|
|8|1|
|8|1|
|8| 2 |
| 8 |2  |
|  8|2  |
| 8 | 2 |
|  7| 2 |
| 7 | 2 |
|  7|  2|
|  7|  2|
| 7 |  2|
| 6 |  3|

或者更直接一点，连总蔡数都小于m

| 脂肪|  种类|
| -----------: | -----------: |
|10|1|
|10|1|
|8|1|
|8|2|
|8| 3 |

就会循环不出去

所以要加一个特判
```cpp
if(k>=n)
break;
```


------------


微博 [@这里是源菌鸭](https://weibo.com/u/6621413460?nick=%E8%BF%99%E9%87%8C%E6%98%AF%E6%BA%90%E8%8F%8C%E9%B8%AD)

知乎 [大源菌](https://www.zhihu.com/people/da-yuan-jun-29/activities)