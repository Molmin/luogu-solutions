### 题外话

这题是课上层次遍历例题，一看感觉输入很毒瘤，其实上手了就没那么难。

### 输入

首先我们看这题最大的特色：输入。

有些人会认为这输入非常毒瘤，但其实我们甚至可以叫它天堂输入。

看输入给了我们什么信息：

首先，是这个节点的深度，比如一个形如$(a,s)$的节点的深度就是字符串$s$的长度。因为它每次选择方向都里根节点远一层。

其次，我们可以通过字符串$s$知道它的祖先，譬如它的父节点的$s_1$就应该是去掉最后一位的$s$，同理，它的所有祖先我们都可以知道。

$LRLR$

如上的一个节点的父节点对应的就是$LRL$，这个节点的父节点的父节点就是$LR$,然后是$L$，最后到达根节点。

这是个神仙输入格式啊！

### 输出

同层很简单，因为往左的总是先输出，所以把所有同层的节点对应的$s_i$排序一边输出即可。

层的顺序就按字符串$s_i$的长度输出就行。

但这题还有个重要条件：输入可能不合法，你需要判断是否合法。这也是这题一个难点。

### 无解情况

出题人友好地告诉我们几种误解情况。

重复给节点，或者说是节点重合为不合法输入。

这个比较简单，我们用$n$方算出有没有重复的就行，数据只有可怜的两百五十六。

节点连不上，就是无法与根节点连接这个需要想一想。

首先这个节点想要接触根节点就必须有父亲节点（可以为根节点），然后这个父亲节点也要有它的父亲节点，以此类推。

具体做法就是把$s_i$的所有前缀都判断一边是否存在，不存在就是不合法的，就是无法连接根节点。

### $SOLUTION$

首先输入，我们用结构体实现。

```cpp
struct node{
	int value;
	string operation;
}
```

然后又要开一个$map$来记录是否存在：

```
void init(){
	map < string , int > m;
  	m.clear();
}
```

然后我们按上述模拟就行。代码就不放出来了。

### 题外话2

这题其实还有另一种做法，那就是根据输入建树，用指针配合结构体存储节点。

输出方法大致一样。

### $END$

有关树的遍历的练习题：（先序，后序遍历）

[下落的树叶](https://www.luogu.com.cn/problem/UVA699)

[树](https://www.luogu.com.cn/problem/UVA548)

[天平](https://www.luogu.com.cn/problem/UVA839)

因为都是$UVA$，所以有可能提交不上去，但质量过关。

$wtrl$~~这篇题解好像认真写了~~希望以后题解质量能提高。