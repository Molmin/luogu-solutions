# 瞎搞+单调栈

看这题在CF真是什么标签都有。。。

### [题面](https://codeforces.com/problemset/problem/1408/D)

### Solution：

- 首先明确一点：

	对于一个确定的向上和向右步数，不管怎么排列走的方案，都是等价的，所以只需要令终态合法即可

- **先O(nm)扫出每个海盗对每个能找到他的探照灯需要向右多少步和向上多少步（当做这个海盗的两个限制）**

	一个合法的策略即满足：
    
    对于每一个海盗，他的两个限制至少满足一个
    
- 考虑将这个问题变得更直观一点：将两个限制分别作为横纵坐标，将每个海盗表示为坐标系中的一个点

	于是有了以下一个图：
    
```
|
|   ·1
|
|    ·2
|
|     ·4  ·5        ·6
| ·3           ·7      ·8
|________________________
```

问题转化为：在坐标系中找到一个点，满足：这个点右边（横坐标严格大于）的点都不比他高

- 最符合我们第一反应的，显然是如果一个点横纵坐标都小于等于一个点，那这个点是没用的

	如：3的横纵坐标都小于2，所以这个点没用，具体而言：如果2符合了条件，3一定符合，那我们就把3删去
    
    **实现上，在之前找出所有点的时候，用一个桶，只记录每个涉及到的横坐标处最高的点，然后扫描横坐标的值域（1~1000000），用单调栈维护一个数值递减的纵坐标**
    
    删完之后，我们得到这个图：
    
```
|
|   ·1
|
|    ·2
|
|                   ·6
|                      ·8
|________________________
```

形状上类似凸包，但实际上不是，可以看到6，可以说是相对2->8“凹”进去了，但在本题中，他仍有贡献

- 最后一步了，**因为不是凸包，所以我们要得到最终的这个点只能暴力扫描一遍（实际上复杂度一点也不高）**

	**如何扫描？对一个点，他的贡献即为“他左边一个点的横坐标加上他的纵坐标”和“他右边一个点的纵坐标加上他的横坐标”**
    
    ~~笔者在写到这里的时候秃然发现似乎重复了？但反正不会让答案错误 /kk~~
    
    为什么价值是这个？
    
    看图：
    
```
|
|   ·1
|   
|----·2
|    |
|    |               ·6
|    |                  ·8
|____|__________________
```

当一个点的纵坐标确定为2的纵坐标之后，显然对于2及后面的点已经满足了，而对于2前面的点，需要满足他们的横坐标，2的上一个点的横坐标是最好的选择

另一边同理

- #### 致歉：一些因为笔者菜才出现的东西：

	1. 最明显的：笔者不会往题解里放图，用的符号，带来诸多不便
    
    2. 笔者在CF爆了几次，就把一些数组和循环开到了远远不需要的大小（读者可自行修改，不必在评论指出）
    
    3. 笔者还将minn赋了一个初值，它的含义为：如果选第一个点，只需满足纵坐标，横坐标大可为0，如果选择最后一个点，同理

### 实现：

有关代码的，都已经在上文加粗标注出来了，读者应该可以得到一个比较完整且清晰的代码流程，具体的话没什么细节，也都是板子

### Code：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,a[2020],b[2020],c[2020],d[2020];
int tot,bin[2000010],stk[2000010],top;
signed main(){
	cin>>n>>m;
	for(int i=1;i<=n;++i)cin>>a[i]>>b[i];
	for(int i=1;i<=m;++i)cin>>c[i]>>d[i];
	for(int i=1;i<=n;++i)
		for(int j=1;j<=m;++j)
			if(c[j]-a[i]>=0&&d[j]-b[i]>=0)
				bin[c[j]-a[i]+1]=max(bin[c[j]-a[i]+1],d[j]-b[i]+1);
	for(int i=0;i<=2000001;++i){
		if(!bin[i])continue;
		while(bin[i]>=bin[stk[top]]&&top)--top;
		stk[++top]=i;
	}
	if(!top)return puts("0");
	int minn=min(stk[top],bin[stk[1]]);
	for(int i=1;i<=top;++i)
		if(bin[stk[i]])minn=min(minn,min(bin[stk[i]]+stk[i-1],bin[stk[i+1]]+stk[i]));
	cout<<minn;
	return 0;
}
```
