## **Tip：要理解题意，请看原PDF，要搞清输出格式，还是得看原PDF！**

先说我的解题思路
------------
**1. 开辟两个数组，一个输入谜面，一个用来记录起始格位置**

因为谜面最大为10X10不是很大,我们可以直接把字符数组设置为12X12大小，这样做的好处是可以避免输出结果时下标越界访问

```
char a[12][12];

int b[11][11] = { 0 };
```

我们把字符数组全填上星号，由于字符数组是12X12的，相当于用星号为谜面设置了四周的边界，这样可以在输出解时直接通过当前字符是不是星号判断循环是否到达了边界处，而不用讨论是否会越界


```
for (int i = 0; i < 12; ++i)
            for (int j = 0; j < 12; ++j)
                a[i][j] = '*';
```



**2. 根据题目意思模拟**

如果当前白格左与上方无白格（即为星号），就确定为起始格，把起始格序数存到b中，待用


```
int cnt = 0;
        for (int i = 1; i <= r; ++i)
            for (int j = 1; j <= c; ++j)
            {
                std::cin >> a[i][j];
                if (a[i][j] != '*' && (a[i][j - 1] == '*' || a[i - 1][j] == '*'))
                {
                    ++cnt; b[i][j] = cnt;
                }
            }
```


**3. 输出结果**

- **对Across**

横行输出时，当前白格左无星号就输出b中对应的起始格序号（序号右对齐且宽度为3！由于是横向遍历，起始格序号是有序的），当前白格右边有星号就换行

```
printf("puzzle #%d:\nAcross\n", ++n);
        for (int i = 1; i <= r; ++i)
            for (int j = 1; j <= c; ++j)
            {
                if (a[i][j] != '*')
                {   
                    if (a[i][j - 1] == '*')
                        printf("%3d.", b[i][j]);
                    printf("%c", a[i][j]);
                    if (a[i][j + 1] == '*')
                        printf("\n");
                }
            }
```

- **对Down**

由于直接和套用和Across一样的方式来竖向遍历会导致顺序混乱，所以这次通过b来判断：在b中除起始格序号外的位置都为零，所以我们找到不为零的位置，然后输出该序号及a中对应的字符

对于每次不中断输出经历的所有起始格，我们把b中对应的位置为0，以避免重复输出，同时，这样做也清空了b，之后就不用再单独清空了

```
printf("Down\n");
        for (int i = 1; i <= r; ++i)
            for (int j = 1; j <= c; ++j)
            {
                if (b[i][j] != 0)
                {
                    printf("%3d.", b[i][j]);
                    int i1 = i;
                    while (a[i1][j] != '*')
                    {
                        printf("%c", a[i1][j]);
                        b[i1][j] = 0;
                        ++i1;
                    }
                    printf("\n");
                }
            }
```

关于输出格式
------------

- **相邻的两个解之间要用空行隔开，但最后一个解后面只有换行无空行**


- **输出起始格序号时，序号是右对齐的，且注意宽度为3！**


- **如果全是黑格此时Across和Down也要有，且此时二者之间不存在空行**


- **洛谷WA了可能实际是PE，记得检查Uva的邮件确认**

如果检查邮件发现是PE，请按照以上几点认真检查并进行修改

关于此题的格式问题已经有题解进行了分析，但是作为影响此题AC的重要因素，我觉得还是有必要强调说明一下如何避免PE，毕竟本人数次修改代码，但一直PE，心态爆炸有没有QAQ
![](https://s3.ax1x.com/2020/11/14/D9bnmD.png)


下面是完整代码
------------
```
#include <iostream>
#include <cstdio>
int main() {
    int n = 0, b[11][11] = { 0 };	//b在每次循环后都被清空，所以只需要初始化一次
    while (1)
    {
        int r, c;
        std::cin >> r;
        if (r == 0) return 0;
        std::cin >> c;
        char a[12][12];
        for (int i = 0; i < 12; ++i)
            for (int j = 0; j < 12; ++j)
                a[i][j] = '*';
        int cnt = 0;
        for (int i = 1; i <= r; ++i)
            for (int j = 1; j <= c; ++j)
            {
                std::cin >> a[i][j];
                if (a[i][j] != '*' && (a[i][j - 1] == '*' || a[i - 1][j] == '*'))
                {
                    ++cnt; b[i][j] = cnt;
                }
            }
        if (n)printf("\n");		//用于判断是否在解前面输出空行，第一个解前面不输出
        printf("puzzle #%d:\nAcross\n", ++n);
        for (int i = 1; i <= r; ++i)
            for (int j = 1; j <= c; ++j)
            {
                if (a[i][j] != '*')
                {   
                    if (a[i][j - 1] == '*')
                        printf("%3d.", b[i][j]);
                    printf("%c", a[i][j]);
                    if (a[i][j + 1] == '*')
                        printf("\n");
                }
            }
        printf("Down\n");
        for (int i = 1; i <= r; ++i)
            for (int j = 1; j <= c; ++j)
            {
                if (b[i][j] != 0)
                {
                    printf("%3d.", b[i][j]);
                    int i1 = i;
                    while (a[i1][j] != '*')
                    {
                        printf("%c", a[i1][j]);
                        b[i1][j] = 0;
                        ++i1;
                    }
                    printf("\n");
                }
            }
    }
    return 0;
}
```