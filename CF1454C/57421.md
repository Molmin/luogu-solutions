### 题意简述：

你有一个长度为 $n$ 的整数序列 $a$ 。

你想要把序列 $a$ 的所有数字变成**相同**的。

你可以选择一个**至少在序列 $a$ 中出现一次**的数字 $x$ ,然后执行如下操作：选择一段**不包含**数字 $x$ 的区间 $[l,r]$ 并删除区间里面的所有数字。

注意，一旦你选择了一个数字 $x$ ，你在之后的操作中**不能更改** $x$。

现在要求让序列中所有数字变成相同的**最小**操作次数。

----

### 解题思路：

有一个显然的结论：**当你选择了一个确定的 $x$ ，完成所有删除操作后，剩下的数字一定都是 $x$ 。** 这个结论是显然的。因为在删除数字时，由于题目要求，选择的区间中都不包含 $x$ ，则 $x$ 一定会在最后被保留。

其次，因为是要最小化操作次数，所以**每次选择删的区间显然越长越好**。比如，设 $x$ 在序列 $a$ 中一次出现的位置为 $i$ ,在位置 $i$ 之后下一次 $x$ 出现的位置为 $j$ ，那么直接删除区间 $[i,j]$ 当中的所有数字显然是最优的。

有了上述结论，我们重新整理一下题意：

- 有一个长度为 $n$ 的整数序列 $a$ 。
- 选择一个**至少在序列 $a$ 中出现一次**的数字 $x$ ，使序列 $a$ 中每段连续的 $x$ 把序列 $a$ 分成的段数最少。

有人可能就会问了：为什么是最小化序列 $a$ 中每段连续的 $x$ 把序列 $a$ 分成的段数？

因为对于序列 $a$ 中每段连续的 $x$ 之间的数字，都是要全部删除的。而为了最小化操作次数，则这些在 $x$ 的连续段之间的数字会被一次删掉。最后显然有**序列 $a$ 中每段连续的 $x$ 把序列 $a$ 分成的段数 $=$ 最小的删除操作次数**。

那么接下来考虑如何实现代码。

------

首先，我们发现序列 $a$ 中各个相同数字的连续段由于长度不定，不太容易处理，所以考虑压缩各个相同数字的连续段。**把每个相同数字连续段压缩成一个数字**，得到一个新的序列 $a'$。

其次，在开始统计之前，考虑特殊情况。（ _下面用 $a_i$ 表示其它数字_ ）

- 情况①：$x_1,a_1,a_2,x_2,a_3,a_4,x_3$ 【样例中的第四组测试数据】
- 情况②：$a_1,a_2,a_3,a_4,x_1,a_5,a_6,a_7,x_2,a_8,a_9$ 【样例中的第五组测试数据】

这些情况说明了当 $x$ 出现在开头和结尾时要特判。**当 $x$ 第一次出现时，特判是否出现在开头，如果不是则说明 $x$ 左侧有其它数字，划分段数增加。对于除了出现在结尾的 $x$ 之外 ，它们的右侧都分别有一段其它的数字，划分段数增加。**

统计完成后，为了更快速的统计答案，可以把重复的数字去除。这样对于每种数字只可能更新答案一次，提高了程序运行效率。

---------

### 解题代码：

```cpp
#include<iostream>
#include<cstdio>
#include<cstring> 
#define ll long long
#define rgt register int
#define qmn(a,b) a<b?a:b
using namespace std;
const int mxn = 2e5+5;
int cnt[mxn],ap[mxn],a[mxn],xa[mxn];
int len,lxa,n,ans;
int main(){
	int test;
	scanf("%d",&test);
	while(test--){
		memset(cnt,0,sizeof(cnt));
		len=lxa=0;  //重置，初始化
        
		scanf("%d",&n);
		for(rgt i=1;i<=n;i++){
			scanf("%d",&a[i]);  //读入序列a
			if(a[i]!=a[i-1]){  //压缩序列段，得到序列xa
				lxa++;
				xa[lxa]=a[i];
			}
		}
        
		for(rgt i=1;i<=lxa;i++){  //按上述规则统计
			if(!cnt[xa[i]]){    //特判第一次出现
				if(i>1)  //不在开头，左侧有数组，划分段数++
					cnt[xa[i]]++;
				len++;   //加入最终的答案筛选数组
				ap[len]=xa[i];
			}
			if(i<lxa)  //不在结尾，划分段数++
				cnt[xa[i]]++;
		}
        
		ans=cnt[ap[1]];
		for(rgt i=2;i<=len;i++){
			ans=qmn(ans,cnt[ap[i]]);  //取最小值，得到答案
		}
		printf("%d\n",ans);
	}
	return 0;
}
```
