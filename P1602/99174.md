本蒟蒻的第一篇题解...

如有不足或错误，请在评论中指出或私信告诉我 ~~能憋着最好憋~~着 

## 话不多说，进入正题


---------------------------------------------*我是分割线*---------------------------------------------

### 方法一： _DFS_  

一看到这道题，相信许多人和我一样，第一想法都是**暴力**。通过深搜枚举每一位上可能的数，如果找到答案就输出，否则就向下一位搜索。

这种方法十分容易理解且代码不长 ~~然而我仍然打了40分钟~~ 。但缺点也显而易见——因为深搜时每一位上都要枚举k个数，所以时间代价是非常高的。 _ 只能过八到九个点_。

这时，我们就需要 ~~特判~~ **更好的做法**。

-------------------------------------------*我又是分割线*-------------------------------------------

### 方法二—1： _BFS_

(为了下文叙述方便，我将满足**每一数位上的数都在0~k-1的数**定义为**S数**）

显而易见，在正整数范围内，S数是无穷无尽的。在搜索时，对于每一坨除以m同余的S数中，我们只需要考虑最小的那个 ( 另一篇题解有详细证明过程，这里就不再赘述 ~~才不是因为懒呢，哼QWQ~~ ) 。那么如何找最小的S数呢？

由于在枚举数位时是从小到大枚举，又根据广搜的特性，对于取余m一个相同的模数mod，越小的S数一定是越早搜到的（实在不知道为啥的可以手动模拟一下 ），据此，**我们只需考虑第一次广搜到的除以m余M的S数，以后再搜到的除以m余M的数都可跳过不处理，_与DFS相比，大大减少时间代价_**.

另外，由于答案可能会非常大，所以需要**将答案的每一数位存储下来**，最后再输出

贴代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int k,m;
bool b[10010];
struct syzs{
    int mod,val,fro;//a[i].mod表示编号为i的S数除以m的余数，a[i].val表示编号为i的S数的个位数，a[i].fro表示上一个数的编号，存储fro和val方便递归输出结果
}a[10010];
inline void out(int x){//递归输出答案：不断找到上一个编号，输出其存储的值 
    if(!x) return;
    out(a[x].fro);
    if(a[x].fro)/*防止输出时出现首位0*/ printf("%d",a[x].val);
}
int main(){
    scanf("%d%d",&k,&m);
    int r=1;
    int h=1;
    while(r<=h){
        for(int i=0;i<k;i++) if(!b[((a[r].mod*10)%m+i)%m]/*判断之前又没有搜过相同的余数*/&&(r!=1||h!=1||i)/*判断是不是首位，如果是，则跳过0*/){
            int now=((a[r].mod*10)%m+i)%m;
            h++;
            a[h].mod=now;
            b[now]=1;
            a[h].val=i;
            a[h].fro=r;//更新，将新节点加入队列 
            if(!(a[h].mod%m)){
                out(h);//输出 
                return 0;//找到答案即结束 
            }
        }
		r++;
    }
}
```

此方法是可以AC的，那么，有没有**别的写法呢？**

** 当然有！**

-------------------------------------------*我还是分割线*-------------------------------------------

### 方法二—2：用queue（容器适配器）实现广搜！
   众所周知，广搜的本质是队列，而STL库中给出的queue正好可以实现队列中的功能。所以我们可以**用queue实现广搜**。
   
   事实上，方法二-1与方法二-2的区别并不大，只是由于queue的特性，在-2**需要维护的东西**就跟-1**有所差距**，**本质上两者是相同的**
   ```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,an[100002];
struct mmtz{
    int mod,val;//与上一篇代码不同，a[i].mod表示除以m余i的S数的上一个S数除以m的余数，a[i].val表示除以m余i的S数的个位数 
} a[1002];
queue<mmtz> syzs;
void out(){
    mmtz x;  
    x.mod=0;
    int op=0;
    while(a[x.mod].val!=-1){
    op++;
    an[op]=a[x.mod].val;//存储答案(也可以用递归) 
    x.mod=a[x.mod].mod;//寻找上一个 
    if(!x.mod) break;//判断首位&&防止死循环 
    }
    for(int i=op;i>0;i--) printf("%d",an[i]);//因为是倒着存储的，所以输出时也要倒着输出 
}
int main(){
    scanf("%d%d",&m,&n);
    memset(a,-1,sizeof(a));//初始化，方便判断由于个位有可能是0，所以不能初始化为0,通过此种初始化手段可以少开一个数组 
    syzs.push((mmtz){0,0});//初始化压入队列 
    while(!syzs.empty()){
        mmtz fir=syzs.front();
        syzs.pop();
        for(int k=0;k<m;k++)if(a[(fir.mod*10+k)%n].val==-1&&(k||fir.mod||fir.val)){//与上一篇意义相同
            mmtz d;
            d.mod=(fir.mod*10+k)%n;
            a[d.mod].mod=fir.mod;
            a[d.mod].val=k;//更新节点 
            syzs.push((mmtz) d);
            if(!d.mod){
            	out();
            	return 0;
            }
        }
    }
} 
```

-----------------------------------------*我仍然是分割线*-----------------------------------------

 * 关于优先队列优化广搜，个人认为对于这题是画蛇添足的做法，因为本身在BFS中，我们只需要考虑最小的那个，由于最先搜索到的就是最小的，所以我们不需要将其排序。
 
 就这样吧......


