题目链接：https://www.luogu.org/problemnew/show/P1683  

---

## 题目分析
题为“入门”，真的就是一道搜索入门题呢qwq.

$dfs$与$bfs$均可以采用，这里提供$dfs$的详解。  
~~内心：还不是你不会bfs？！~~  

咳咳  

这道题的坑有两个：  
$1.$ **长和宽是反过来输入的！！！**  
输入$w$和$h$，但下面是一个 **$h$行$w$列的** 的字符矩阵！  
我也是被坑惨了，以前在别的网站上刷题时就遇到过QAQ.  
~~屡教不改~~  

$2.$答案是算第一块砖的，即计数的变量要初始化为$1$。  
在这里栽的人就比较少了，毕竟题目提醒了。  

剩下就是纯粹的$dfs$了qwq.  
这里不再累述。

---

## 代码实现
照例略去头文件、宏定义、uns.
```cpp
int n,m,ans,x[5]={0,-1,1,0,0},y[5]={0,0,0,-1,1};
//本蒟蒻喜欢用n和m
//x和y记录朝四个方向走时横、纵两个方向上坐标的变化（从1开始）
char h[N][N];//字符矩阵
bool f[N][N];//记录是否走过
void dfs(int a,int b)
{
	int i,c,d;
	for(i=1;i<=4;i++)//四个方向
	{
	  c=a+x[i]; d=b+y[i];
	  if(c>0&&c<=n&&d>0&&d<=m&&h[c][d]=='.'&&!f[c][d])
      //若这个点在矩阵范围内且这个点可以走、之前没被走过，走到这个点上去
	  {
	  	ans++;//更新答案
	  	f[c][d]=1;//标记为走过
	  	h[c][d]='#';
	  	dfs(c,d);//从这里继续搜
	  }
	}
}
int main()
{
	int i,j,a,b;
	cin>>m>>n;//n和m要反过来！！！再提醒一遍
	for(i=1;i<=n;i++)
	  for(j=1;j<=m;j++)
	  {
	    cin>>h[i][j];
	    if(h[i][j]=='@'){a=i; b=j;}//记录起点位置
	  }
	ans=1;//初始化为1
    f[a][b]=1;//标记为走过
	dfs(a,b);
	cout<<ans<<endl;
	return 0;
}
```