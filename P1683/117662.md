# 题意简述：
给你一个图，一个起点，找与起点相连的地板数量

------------
其实这是一道很简单的搜索题，这里给出深搜的做法（~~绝对不是因为不会广搜~~）


------------
首先，我们可以把它转化为数字来处理，走过的和不能走的标记为-1，而没走的可以标记为0，然后就需要把起点找出来，因为起点也算，所以ans的初始值应该为1。

### 本题坑点：
- 输入的方阵长宽是反的（~~想不到吧~~）
- 走一个标记一个，而且不用回溯，因为朝四个方向走，没个路口都能走完
- 自己的那块砖也算！！！ans初始值为1！！！

接下来就是蒟蒻的代码了：
```cpp
#include <bits/stdc++.h>
using namespace std;
int sx , sy , ans = 1/*赋值为1！！！*/ , n , m; 
char st; //输入的字符 
int a[23][33] = {0}; //2333
int dx[] = {0 , 1 , 0 , -1} , dy[] = {1 , 0 , -1 , 0}; 
/*
方向初始化，四个方向时一个不为零时，对应的另一个就要为零； 
而向马这样的，一个为±2，另一个就不为零了； 
八个方向以此类推 
*/
//开搜啦(*^▽^*) 
void g(int x , int y){
	for(int v = 0; v <= 3; v++){ //四个方向依次来 
		int xx = x + dx[v] , yy = y + dy[v]; //开走 
		if(a[xx][yy] == 0 && xx <= n && xx >= 1 && yy <= m && yy >= 1){ //既能走，又不越界 
			a[xx][yy] = -1; //走过了 
			ans++; 
			g(xx , yy); //搜下一步 
		}
	}
}
int main(){
	cin >> m >> n;
	for(int i = 1; i <= n; i++)
		for(int j = 1; j <= m; j++){
			cin >> st;
			if(st == '.') a[i][j] = 0;
			if(st == '#') a[i][j] = -1;
			if(st == '@'){
				sx = i;
				sy = j;
			}
		}
	a[sx][sy] = -1; //起点是走过的 
	g(sx , sy);
	cout << ans;
	return 0;
} 
```
希望对刚学深搜的同学有帮助鸭！ ~~开溜~~
