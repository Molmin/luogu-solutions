做题背景：

赛时没做掉，当时是直接看到题面和数据范围，发现是非 DP 状物但题面又很像，就弃了。

后面发现了辗转相减判状态重复，然后受到了场切爷 @[天南星魔芋 ](https://www.luogu.com.cn/user/399239) 的指点 ~~外加一通魔法调试~~，总算做掉了这道思维题。感觉扔 CF 上应该是 div2 E/F 的样子？



------------
## 思路

首先，题目相当于是给定了一个起始状态和目标状态，需要通过相减 / 相加的操作来转移到目标状态，并给定了状态限制。

那么我们当然不能考虑一直相加并通过相减调整，因为直观上，这样始终不会碰到限制，且连续相加后的相减无异于重复之前的状态，是无用的。这里的证明在下面的 UPD 中给出。

考虑相减。让起始状态和目标状态一起相减，若二者在这个过程中出现的状态集合有交集，且转移过程中没有碰到限制，则有解。因为一个状态直接对应了完整的所有转移，所以若状态集合有交，说明这个状态可以通过初始状态相减得到，并让这个状态相加得到目标状态。

UPD：因为没有证明往大加不行题解被下力，赶紧补上证明。

考虑相加时，新得到的 $x'=x+y,y'=x'+y=2x+y$，而初始的 $x,y$ 是由 $x+y,2x+y$ 转移来的，此时的状态相当于回到两次相减之前，出现了重复状态，故对答案无影响。


而相减由于状态是唯一的，且对应唯一的转移结果，所以相减是可行的。

对于需要初始状态相加的情况，可以转化为目标状态相减，上面的结论同样适用。

至于所谓“一起往大跑”的情况，同样可以由上面的证明得到，这样获得的状态交集也可以由辗转相减构造，在答案上无影响。

而辗转相减的过程中更便于考虑 $k$ 的限制，且辗转相减受限于初始 / 目标状态的大小，当转移到最小合法状态后即可停下，相加没有明确的上限，难以讨论限制，故应考虑相减的情况。

结论得证。

考虑怎么判断是否有交集。

一个朴素的实现是模拟，开两个 set 维护状态集合，每次转移时判断一下是否有交和状态是否满足限制。



我们发现，假如两个集合内出现了第一个相同状态，那么这个相同的状态相减之后的状态也会在这个交集里。同样的，再继续相减下去也是一样，一直到最小的合法状态。所以我们只需要**判断这个最小合法状态是否相同**即可。

如何获得这个最小的合法状态呢？

> 我会辗转相减模拟！

让两个元素一直辗转相减，直到即将碰到限制时即为最小的合法状态。

然而这样最多会做 $2×10^9$ 次辗转相减，妥妥超时。

但是这个暴力居然有50分，而且只会 T 两个点，如果月赛换成没有 subtask 这个暴力将绝杀，可惜换不得。

> 我会辗转相除！

直接用辗转相除加速，然后判断最后的结果是否相同且合法。这个结果等价于 $x'=x÷gcd(x,y) ,y'=y÷gcd(x,y)$，可以快速实现。

然而这样的加速无法保证最后的结果是最小合法状态，只能保证是最小状态，直接判断是否合法将因为跳过了合法状态而当场 WA 掉。

但是这么做可以在 $k=1$ 的测试点得到满分。 

> 我会二进制分解！

在相减时使用类似于倍增的二进制分解加速，依次让 $x$ 在合法的前提下尝试减去 $2^{26}y,2^{25}y,2^{24}y…2y,y$。然后基于这个操作辗转相减。

这样由于每次在操作前都保证了合法，所以最终得到的结果一定是最小合法状态。

在实现的时候要注意状态中 $x,y$ 的相对位置。

------------
## 代码

```cpp
#include<bits/stdc++.h>
#define ll long long
#define db double
#define R read()
#define file(a) freopen(#a".in","r",stdin),freopen(#a".out","w",stdout)
using namespace std;
inline ll read() {
	ll s=0,f=1;
	char ch=getchar();
	while(ch<'0'||ch>'9') {
		if(ch=='-')f*=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9') {
		s=s*10+ch-'0';
		ch=getchar();
	}
	return s*f;
}
inline void write(ll x) {
	if(x<0) putchar('-'),x=-x;
	if(x>9) write(x/10),x%=10;
	putchar('0'+x);
}//Don't use it for CF.
inline void wk(ll x){write(x);putchar(' ');}
inline void we(ll x){write(x);putchar('\n');}
ll T;
ll k;
ll t[5];
void ex_mod(ll &x,ll &y){//辗转相减
    if(abs(x-y)<k)return ;
    bool tp=0;
    if(x>y){
        for(ll i=26;i>=0;i--){//二进制分解加速
            if(x-(1<<i)*y>=k){//判断是否合法
                x-=(1<<i)*y;
                if(i==0)tp=1;
            }
        }
        if(tp)swap(x,y);
        ex_mod(x,y);
    }
    else{
        swap(x,y);
        for(ll i=26;i>=0;i--){
            if(x-(1<<i)*y>=k){
                x-=(1<<i)*y;
                if(i==0)tp=1;
            }
        }
        if(!tp)swap(x,y);
        ex_mod(x,y);
    }
}
signed main(){
    T=R;
    while(T--){
        for(ll i=1;i<=4;i++){
            t[i]=R;
        }
        k=R;
        if(t[1]<k||t[2]<k||t[3]<k||t[4]<k){//不合法提前判断
            cout<<"no"<<endl;
            continue;
        }
        if(t[1]==t[3]&&t[2]==t[4]){
            cout<<"yes"<<endl;
            continue;
        }
        ex_mod(t[1],t[2]);
        ex_mod(t[3],t[4]);
        if((t[1]==t[3])&&(t[2]==t[4]))cout<<"yes"<<endl;
        else cout<<"no"<<endl;

    }
	return 0;
}
```