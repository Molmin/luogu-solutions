看到大家都用线段树，这里写一个优先队列的做法~

首先我们对所有牛以$a_{i}$第一关键字排序，然后再贪心处理怎样才能使答案达到最优。

具体怎么贪呢？

我们从$1->n$扫一遍，假设我们扫到$i$，在这一个空间上已经容纳了$j$头牛，我们把所有$a_{k}=i$的牛先扔进这一个空间，我们假设这个空间可以无限大，那么我们的队列里就存了可能超出空间的牛。

接着我们在考虑容量问题，这个时候我们队列里已经有$r$头牛了，如果$r\leq c_{i}$那么我们可以很和谐的往后跑，如果不是，那我们就要考虑把一部分牛宰掉$qaq$。

##### 注意到我们枚举到$i$点时，队列里的每一头牛都有一个$b_{i}$，表示$b_{i}$之后这头牛就不占空间了，而它们的$a_{i}$已经对答案没有影响了，我们只希望后面对答案的贡献尽可能大，即后面的空间尽可能大，因此如果超出了空间，我们肯定要宰掉队列中$b_{i}$较后的牛。

既然如此，我们的贪心思路已经很明确了，具体分为三步：

1. 我们从$1->n$扫一遍，对于每个$i$，我们把所有$a_{i}$进入队列，从这里开始占用空间。

2. 然后我们开始考虑队列容量不够的问题，我们如果我们超出了容量，我们把所有$b_{i}$大的宰掉

3. 接着释放空间，我们把队列中所有$b_{i}=i$，即不占用空间了的请下去，统计答案。

显然，第二个步骤可以用大根堆实现。

那么第三个步骤呢？我们发现大根堆没法获取最小值。

##### 那么我们就让他放在队列中，我们开一个数组$sum_{i}$表示队列中有多少头牛满足$b_{k}=i$，显然是可以做到同步的，然后统计答案的时候我们就可以知道有多少头牛的空间是已经被释放了的。

具体代码实现很简单：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,s[110000],t,sum[110000],ans = 0;
pair <int,int> a[110000];
priority_queue<int> q;
int main()
{
	scanf("%d%d", &n, &m);
	for(int i = 1;i <= n;i ++) scanf("%d", &s[i]);
	for(int i = 1;i <= m;i ++) scanf("%d%d", &a[i].first, &a[i].second);
	sort(a + 1,a + m + 1);
	a[m + 1].first = n + 1;//这一步是为了防止死循环 
	for(int i = 1;i <= n;i ++)
	{
		//分三步： 
		while(a[t + 1].first <= i) q.push(a[++ t].second),sum[a[t].second] ++;//进队 
		while(q.size() > s[i] + ans) sum[q.top()] --,q.pop();//宰牛 
		ans += sum[i];//统计答案，这一个答案也代表队列中有多少头牛是已经被释放了的 
	} 
	printf("%d\n", ans);
 } 
```