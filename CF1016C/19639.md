（注：以下$a_{i}$表示第1行第i列，$b_{i}$表示第2行第i列）
### 思路
由于每个格子必须遍历一遍，
假设你现在在第1行第k列（k为奇数），不难发现你一共只有3种选择：
1. 从$a_{k}$走到$a_{n}$，再从$b_{n}$走回$b_{k}$。
1. 从$b_{k}$走到$b_{n}$，再从$a_{n}$走回$a_{k}$。
1. 沿着$a_{k}$->$b_{k}$->$b_{k+1}$->$a_{k+1}$->$a_{k+2}$走,进而跳转到下一个状态（你在第1行第k+2列），此时你又可以选择1、2、3中的任一方式继续走下去

如果你选择方案1、2中的任一一种，那就等于直接走完了整个方阵，大功告成，也就不存在之后的状态了，此时你可以直接计算方案1和方案2所得到蘑菇贡献值的最大值，和之前已经获得的贡献值相加得到答案，更新最终答案即可。只有当你选择方案3时，才可能出现下一个状态。因此，对于每个状态，它之前的所有状态做出的选择一定都是第3种，即走了若干个U形。从每个状态到下一个状态多走了4个方格，即$a_{k}$->$b_{k}$->$b_{k+1}$->$a_{k+1}$，把它们的权值（即蘑菇增长速度）乘以抵达的时间相加即可得到转移方程。

### 计算

我们用s[k]表示$\sum_{i=k}^{n}(a_{i}+b_{i}),$用ret1[k]表示当前在第1行第k列，采用方案1获得的权值，ret2[k]表示当前在第1行第k列，采用方案2获得的权值。在计算的过程中，由于从第1行第k列出发的时刻和从第1行第k-2列出发的时刻不同，不利于计算，我们可以先假设出发的时刻都是0，计算出权值和，再加上(2×k-2)×s[k]。（说明：对于从第1行第k列出发的这个状态，$a_{1}$~$a_{k-1}$、$b_{1}$~$b_{k-1}$一定都已经走过了，所以出发的时刻是2×k-2，并且每晚开始走1秒，没走的格子的权值都要增加一倍，所以乘以s[k]）

根据题意我们不难列出各数组之间的递推公式，详见代码：
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<queue>
#include<set>
#include<map>
#include<vector>
#include<stack>
#include<cmath>
#include<string>
#include<algorithm>
#include<iomanip>
typedef long long int ll;
using namespace std;
ll n;
ll a[300005];
ll b[300005];
ll s[300005],ret1[300005],ret2[300005];
ll dw[300005];
//dw[k]表示当前在第1行第k列，在该状态前一直选择方案3得到的权值和
ll ans=0;
int main()
{
	scanf("%lld",&n);
	for(ll j=1;j<=n;j++)
	{
		scanf("%lld",&a[j]);
		s[1]+=a[j];
		ret1[1]+=(j-1)*a[j];
		if(j!=1)ret2[1]+=(2*n-j+1)*a[j];
	}
	for(ll j=1;j<=n;j++)
	{
		scanf("%lld",&b[j]);
		s[1]+=b[j];
		ret1[1]+=(2*n-j)*b[j];
		ret2[1]+=j*b[j];
	}
	for(ll i=3;i<=n;i+=2)
	{
		s[i]=s[i-2]-a[i-2]-a[i-1]-b[i-2]-b[i-1];
		ret1[i]=ret1[i-2]-a[i-1]-2*s[i]-(2*n-2*i+4)*b[i-1]-(2*n-2*i+5)*b[i-2];
		ret2[i]=ret2[i-2]-b[i-2]-2*s[i]-(2*n-2*i+5)*a[i-1]-(2*n-2*i+2)*a[i]-2*b[i-1];
		dw[i]=dw[i-2]+(2*i-6)*a[i-2]+(2*i-5)*b[i-2]+(2*i-4)*b[i-1]+(2*i-3)*a[i-1];
	}
	for(ll i=1;i<=n;i+=2)
	{
		ans=max(ans,dw[i]+max(ret1[i],ret2[i])+(2*i-2)*s[i]);
	}
	printf("%lld\n",ans);
	return 0;
}
```
注：各数组的计算可以有多种递推方法，上述代码采取的是顺推，逆推也是正确的做法。