$\text{DP}$。这道题的迷惑性很强，第一眼看上去像计算几何，仔细观察后可以想出**最短路**的做法，但是计算几何的本质还在，在连边时需要判断中间是否有墙阻挡，不是很好写，但 $\text{DP}$ 则不难想到，且非常好写。

我们设置 $f[i][j]$ 表示 **当前为第 $i$ 堵墙，垂直位置为 $j$ 时的最短路径长度**。显然，垂直位置是一个实数，所以我们将它 $\times100$（由于保留两位小数，所以只保留两位即可），就可以表示了。

在每次转移时，我们从当前这面墙的两个空缺上扫过去，然后从上一面墙的两个空缺上转移过来即可。

为了更方便的转移，我们设开始墙为 $0$ ，结束墙为 $n+1$，空缺为 $(5,5)\ (5,5)$。

伪代码如下。

```cpp
	for i=1 to n+1
        for j=i_a1 to i_b1
            for k=i-1_a1 to i-1_b1
                f[i][j*100]=min(f[i][j*100],f[i-1][k*100]+dist(i_x,j,i-1_x,k))
            for k=i-1_a2 to i-1_b2
                f[i][j*100]=min(f[i][j*100],f[i-1][k*100]+dist(i_x,j,i-1_x,k))
        for j=i_a2 to i_b2
            for k=i-1_a1 to i-1_b1
                f[i][j*100]=min(f[i][j*100],f[i-1][k*100]+dist(i_x,j,i-1_x,k))
            for k=i-1_a2 to i-1_b2
                f[i][j*100]=min(f[i][j*100],f[i-1][k*100]+dist(i_x,j,i-1_x,k))
```

$\text{TIP : }$ $j$ 和 $k$ 都是实数类型。$i$ 为整型。

初值为全部设为 $\infty$ ，然后把 $f[0]$ 这一维设成 $0$。答案在 $f[n+1][500]$ 的位置。