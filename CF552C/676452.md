思维题

首先先转化一下问题，问题可以转化为，是否可以用所谓的砝码，凑成两个数字 $a,b$，满足 $a+m=b$。

观察可以发现，如果把 $a,b$ 写成一个 $w$ 进制数，它们必须满足的两个要求是：

1. 变为 $w$ 进制后的每一个数位，要么是 $0$，要么是 $1$，不可以有其他数字。
1. 它们 $w$ 进制位为 $1$ 的位，不能有重复。


------------


可以用 $m$ 作为基准，尝试利用一个 $a$，将 $a+m$ 凑成 $b$。

首先把 $m$ 变为一个 $w$ 进制数，从低位到高位遍历 $m$ 的每一位。

如果发现某一位是 $w-1$，在该位上 $+1$，并进行进位。

这就相当于是把 $a$ 的对应位设成了 $1$。

（注意进位以后下一位就算什么都不加可能也需要进）


------------



另外，如果某一位是 $0$ 或者 $1$，那么也是合法的，不需要处理。

但如果某一位是大于 $1$ 且小于 $w-1$ 的某个数，那就是不合法的，直接输出 NO，而正常遍历完所有位的话就输出 YES。

可以发现，全部处理完后剩下的数字刚好是 $b$。

之所以遍历完所有位直接输出即可，是因为 $w$ 就算取最小的 $2$，$2^{100}$ 也远远大于 $m$ 的最大值 $10^9$。

因此，砝码种数看成是无限的就行了。


------------
```cpp
#include <bits/stdc++.h>

using namespace std;

typedef long long ll;
typedef unsigned long long ull;

ll n, m;

int main(void)
{
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    cin >> n >> m;

    vector<ll> v;

    while (m)
    {
        v.push_back(m % n); // 把m拆成n进制数，每一位存到v里
        m /= n;
    }

    v.push_back(0); // 最高位补上一个0，处理进位的时候就不用判断边界了

    for (int i = 0; i < v.size() - 1; i++) // 遍历每一位
    {
        if (v[i] == n - 1 || v[i] == n) // 发现 n-1 或者 n 就进行进位
        {
            v[i] = 0;
            v[i + 1] += 1;
        }
        else if (v[i] > 1) // 否则只能是0或1，否则就输出NO
        {
            cout << "NO";
            return 0;
        }
    }

    cout << "YES";

    return 0;
}
```
