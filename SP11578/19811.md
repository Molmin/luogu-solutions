# 题意
一张相片上有很多高楼,单个高楼呈现为单个矩形，高楼可能会有互相重叠。求最少有多少个建筑。
# 题解
要建筑物的数量最小，那么我们可以认为每一种高度只有一个建筑物。则最少建筑物数量就等于高度的种数。

若两个高度相等的矩形之间的所有建筑物的高度都大于等于这两个矩形的高度，我们就可以把这两个矩形视为同一建筑物。若两个矩形之间的建筑物中出现了更矮的矩形，则这两个矩形就不能连成同一建筑。

所以建筑的数量可以按以下方式计算：

1、若一个建筑群高度小到大的顺序，则最少建筑物数量就等于高度的种数。

2、若两个矩形之间的建筑物中出现了更矮的矩形，则这两个矩形就不能连成同一建筑。那么这两个矩形之间的建筑数量就等于它们之间更高矩形的高度种类。

所以我们可以开一个栈$stack$，维护这个序列保持严格递增。当出现更高矩形直接入栈，而出现了更矮的矩形就不停出栈到栈的第$i$位，直到这个矩形可以放进栈。而出栈的次数就是这个矩形和$stack$的第$i$位所存的矩形之间的建筑数量。当遇到矩形高度相等的情况不对$stack$进行任何操作。而数据读完后再对$stack$中剩下的矩形进行一次清算。

特殊的：高度为$0$的矩形不清算。因为它们根本就不是建筑。
# 代码
```cpp
/*         _    _____         _
           \`,""   ,'7"r-..__/ \
          ,'\/`, ,',','    _/   \
         /   \/ 7 / /     (   \ |
        J     \/ j  L______\  / |
        L   __JF"""/""\"\_,    /
        L,-"| O|  | O |  L_  _/
        F   \_ /  \__/   `-  /|
            .-'    `"""    ,' |          _..====.._
            \__/         r"_  A        ,' _..---.._`,
             `-.______,,-L// / \  ___,' ,'_..:::.. `,`,
                      /   / / / 7"    `-<""=:'  '':. \ \
                     |   <,' /  F  . i , \   `,    :T W I
                     |    \,'  /    >X<  |     \   :| |  L
                     \     `._/    ' ! ` |      I  :| |  G
                      \           \     /       |  :H T  |
                     __>-.__   __,-\   |        |  :S P  |
                    /     /|   | \  \  \_       | 'A R   |
                   /   __/ |   |  \  \   \      K./ /   L
                  /   |    |   |  |  |   |     E/ /   ,'
                 |    \    |   |  |  |   |    // / _,'
        _________|     |   |   |  |  |   |   //_/-'
        \   __   |    /    |   | /   |   |  /="
        \\  \_\  \__,' \  /    |/   /    |
        \\\_____________\/     F___/     F
         \\| 计算机编程 |_____/   (_____/
          \/从入门到入土/
*/
#include<iostream>
#include<cstdio>
#include<cstring>
#include<bitset>
#include<algorithm>
using namespace std;
int a[101000],q[101000];
int main(){
	int n,case_num=0;
	while(scanf("%d",&n)==1){
		int top=0,ans=0;case_num++;
		for(int i=1;i<=n;i++){
			scanf("%d",&a[i]);
			while(top&&a[i]<a[q[top]]){//出现了更矮的矩形就不停出栈，直到这个矩形可以放进栈。
				top--;
				ans++;//出栈的次数就是这个矩形和栈的第top位所存的矩形之间的建筑数量
			}
			while(top&&a[i]==a[q[top]])top--;//保持栈中连续的相同矩形不存在，免得结尾清算时重复加入相同建筑 
			if(a[i])q[++top]=i;//不把高度为0的矩形清算,因为它们根本就不是建筑
		}
		ans+=top;//结尾清算 
		printf("Case %d: %d\n",case_num,ans);
	}
	return 0;
}
```
