一开始使用题解的思路。写了一遍T了。。（其实Windows下大随机数据Pascal跑得还比C++略快一点的说）

我知道用C++重写一遍就能A，我知道我写的Treap有2倍常数。。但是我们不妨以提交次数为代价水一下此题。。。

正解部分：

●我们对每一个候选人开平衡树，这样我们就能询问[L,R]的选民选择该候选人的数量。比如[1,R]-[1,L-1]这样。

●开线段树维护区间众数。复杂度O(nlognlogn)。

好吧，以上我直接模拟地写一遍只有30分，其余全T。

乱搞卡常部分：

①一个区间，如果存在一个数>区间的一半，则随机选数正确的概率为1/2。选择K次出错的概率就低到1/2^K了。这个测试次数K不一定要选2^K>=αM这种，实际上，选15左右就能对绝大多数数据了（毕竟很可能本来就没有大于一半的数，这样多询问就很浪费）。这样复杂度是O(nlognK)

②一个候选人，他可能出现的总次数本来就极少，已经少于询问区间的一半了，我们这时就不需要花费logn的代价去询问，直接返回false。

③出题人最擅长构造的数据莫过于【数U出现了x次，数V出现了(x+1)次】这种极端，这时数U可能都会被问到多次，用时间戳判掉对同一个选民的重复询问即可。

④啊你发现以上的做法还是过不了，可以得90分，特别是第7个点我不知道出题人是怎么构造的而Luogu又没法下载。那么，你也不要轻易放弃信仰去用c++。你可以对区间小的数，测试次数K设置的小一些；区间大的数，测试次数K设置的大一些。。。这个时候，你的分数会在70~90分徘徊，但是当你欧气好的时候，可以抵达100分。


代码比较丑不贴了。。
