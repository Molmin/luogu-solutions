~~这么有意思的题怎么没人写题解。~~  
本题需要一定的贪心。  
首先我们考虑，如果我们将两次操作合并为一次操作，那么就相当于有两位我们只取反了一次，而剩下几位均取反了两次。**这与直接选择两位取反是等价的。**  
因此我们将题意转化为：你可以花费 $2$ 的代价取反任意两位。  
+ 对于 $k$ 是偶数的情况，显然这个问题跟每次取反一次是等价的，因此我们直接贪心，从左往右扫，将 $0$ 转化成 $1$ 即可。（多出来的操作全部放在最后一位，这样对字典序影响最小）。
+ 对于 $k$ 是奇数的情况，我们可以考虑先将多出来的一次操作处理掉，在转化为 $k$ 是偶数的情况。  
这种情况需要贪心考虑：我们从左往右找到第一个出现的 $1$，并对这一位进行取反。  
这样子我们通过一次操作使得从最高位开始连续的 $1$ 数量最多，不难想到这是字典序最大的方案。  
最后直接按 $k$ 是偶数的情况考虑即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
string s;
int ans[200005];
int main()
{
	int t;
	cin>>t;
	while(t--)
	{
		int n,k;
		cin>>n>>k>>s;
		if(k&1) //对于奇数情况的特殊预处理
		{
			int fi=-1;
			for(int i=0;i<n;i++)
			{
				if(s[i]=='1')
				{
					fi=i;
					ans[i]++;
					k--; 
					break;
				}
			}
			if(fi==-1)
			{
				ans[n-1]++;
				fi=n-1;
				k--;
			}
			for(int i=0;i<n;i++)
			{
				if(i!=fi) s[i]=s[i]=='0'?'1':'0';
			}
		}
		for(int i=0;i<n&&k>0;i++) //贪心将非0位取反
		{
			if(s[i]=='0')
			{
				ans[i]++; 
				k--;
				s[i]='1';
			}
		}
		ans[n-1]+=k; //处理最后1位
		if(k&1)
		{
			s[n-1]=s[n-1]=='0'?'1':'0';
		}
		cout<<s<<"\n";
		for(int i=0;i<n;i++)
		{
			cout<<ans[i]<<" ";
			ans[i]=0;
		}
		puts("");
	}
}
```