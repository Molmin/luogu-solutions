[$\large \textsf{UVA10162 Last Digit}$](https://www.luogu.com.cn/problem/UVA10162)

### $\text{Description}$

求 $\sum \limits_{i=1}^ni^i \bmod 10$。

### $\text{Solution}$

根据我们学习的关于同余的知识，可以得出 $(x \bmod 10)^x \equiv x^x \pmod{10}$，这是显然的。

但是这样做还是不好做，指数太大了，我们考虑把指数也变小。可以计算 $10$ 的欧拉函数，把指数对 $4$ 取模（不懂得同学百度扩展欧拉定理）。

另外，还有一种方法可以得到指数对 $4$ 取模是对的：求 $0\sim 9$ 的幂的个位循环节。发现循环节长度均为 $1$，$2$ 或 $4$，都是 $4$ 的因子。这里就不列举了。

好了，现在我们已经得到了 $(x \bmod 10)^{(x \bmod 4)}\equiv x^x \pmod{10}$，因为 $\operatorname{lcm}(10,4)=20$，得到了底数和指数的循环节长度是 $20$，$x^x \bmod 10$ 的循环节长度也是 $20$。

我们可以把循环节内 $20$ 个数的**个位的前缀和**给计算出来，见下表。


$$\{0,1,5,2,8,3,9,2,8,7,7,8,4,7,3,8,4,1,5,4\}$$

可以发现每个循环节的个位之和是 $4$，所以答案是 $4\times \lfloor \dfrac{x}{20} \rfloor+c$ 的个位，其中 $c$ 是上表中的第 $n \bmod 20$ 项（即超出循环节的部分）。

~~不行，我才不愿意做高精度呢。~~ 考虑怎么写比较方便。

1. 先把这个数除以 $20$ 的余数算出来，在原数中减掉。因为一个数除以 $20$ 的余数就是它末两位除以 $20$ 的余数，所以计算很方便，顺便要把超出循环节的部分算掉。
2. 剩下的数是 $20$ 的倍数了，答案是当前的数除以 $20$ 再乘 $4$，因为不用考虑余数了，直接除以 $5$ 即可。除以 $5$ 怎么做？因为我们只要算个位，我们直接去掉末尾的 $0$，再把当前的数的末尾乘 $2$ 再取个位，就相当于做了一个除以 $5$ 的操作。

### $\text{Code}$

非常简单！

```cpp
#include<cstdio>
#include<cstring>
using namespace std;

int pre[20]={0,1,5,2,8,3,9,2,8,7,7,8,4,7,3,8,4,1,5,4};
char str[510];
int main(){
	while(scanf("%s",str+1)!=EOF){
		int len=strlen(str+1);
		if(len==1 && str[1]=='0') break;
		else if(len==1){
			printf("%d\n",pre[str[1]-'0']);
		}else{
			int last=(str[len-1]-'0')*10+(str[len]-'0'); // 取末两位
			int added=pre[last%20]; last-=last%20; // 计算超出循环节的部分
			printf("%d\n",(added+(last/10)*2)%10); // 先除以 10（抹掉 0）再乘 2，方便多了
		}
	}
}
```