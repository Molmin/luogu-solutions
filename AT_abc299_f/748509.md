## 题目描述

给定一个由小写英文字母组成的字符串 $S$。计算满足以下条件的非空字符串 $T$ 的数量，答案对 $998244353$ 取模。

> 将 $T$ 复制一倍形成 $TT$，则 $TT$ 是 $S$ 的子序列（不一定连续）。

## 数据范围

$1 \le \left| S \right| \le 100$

## 分析

考虑 `DP`。

设状态 $f_{i, j}$ 表示 $T_1$ 在 $[S_1, S_i]$ 中，$T_2$ 在 $[S_{i+1}, S_j]$ 中，那么可以枚举所有小于 $i$ 的 $k$ 和小于 $j$ 的 $l$，并在满足 $S_k = S_l$ 的情况下，$f_{i, j} = f_{i, j} + f_{k, l}$。即：
$$
f_{i, j} = \sum_{k=1}^{i-1}\sum_{l=1,S_k = S_l}^{j-1} f_{k, l}
$$
这样就结束了吗？如果这样写代码样例都不过。原因是我们没有考虑重复对答案的影响。

如果存在多个 $S_k = S_l = C$，其中 $C$ 是一个字符，那么我们应该只计算最前面的 $k$ 和 $l$。

因此，我们还需要预处理出一个 $nxt_{i, j}$，表示第 $i$ 个字符后第一次出现 $j$ 的位置，其中 $j$ 是字符的映射，那么我们就可以在转移时只转移一次，避免重复计算了。

## 代码

预处理：

```cpp
for (int i = 0; i <= n; i ++ )		// 枚举每一个 a[i]，注意不要忘了 i = 0 的情况，接下来可能会用用到 
	for (int j = 0; j < 26; j ++ )		// 枚举每一个字母 a ~ z 
		for (int k = i + 1; k <= n; k ++ )		// 枚举所有 a[i] 后面的元素 
			if (a[k] == j + 'a')	// 如果找到了，更新 nxt[i][j] 的值并退出循环 
			{
				nxt[i][j] = k;
				break;
			}
```

转移：

```cpp
for (int k = 1; k < n; k ++ )		// 枚举所有的 a[k] 
{
	memset(f, 0, sizeof f);		// 清空 
	
	for (int i = 0; i < 26; i ++ )		// 初始值 
		if (nxt[0][i] <= k && nxt[k][i] <= n) f[nxt[0][i]][nxt[k][i]] ++ ;
	
	for (int i = 1; i <= k; i ++ )		// 枚举第一个字符 
		for (int j = k + 1; j <= n; j ++ )		// 枚举第二个字符 
			if (a[i] == a[j])		// 如果它们不相等，不做处理 
				for (int c = 0; c < 26; c ++ )		// 枚举每一个字母 
					if (nxt[i][c] <= k && nxt[j][c]<= n)		// 转移 
			 			f[nxt[i][c]][nxt[j][c]] = add(f[nxt[i][c]][nxt[j][c]], f[i][j]);
	
	for (int i = k + 1; i <= n; i ++ ) res = add(res, f[k][i]);		// 更新答案 
}
```

完整的：

[Code](https://atcoder.jp/contests/abc299/submissions/40999013)