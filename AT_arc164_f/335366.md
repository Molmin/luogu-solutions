[前往博客园阅读](https://www.cnblogs.com/0htoAi/p/17545975.html)

先进行一些转化。

每个点被翻转的次数固定，为其深度。（这里规定根节点的深度为 $0$）

所以每个人放颜色可以看做放什么得什么，而不需要考虑翻转。

先手选偶数层和后手选奇数层都会使得先手得分，反之不得分。所以先手和后手其实是一样的策略：尽可能选偶数层，而不选奇数层。

对于能够放颜色的点，一定是叶子，所以考虑维护当前的叶子集合。

对于初始为叶子的点，如果是偶数层的，直接依次选，否则开始维护。对于选了偶数层的叶子而新增的叶子也要维护。

考虑选一个奇数层的叶子，而且选了不会使得多出来一个偶数层的叶子：无意义节点，依次选。

如果要多出来一个偶数层叶子，则先选奇数层叶子的那个人非常亏：自己没赚到还让对面赚了。所以都不想当偶数层叶子暴露出来，所以会先把无关紧要的奇数层叶子选完。此时剩下全是选一个就会把其父亲也选的了奇数层叶子。

这时先选肯定是亏的，为了尽量亏少，计算每一坨的价值。一坨的意思就是只要选了这一坨的其中一个，就能把这一坨选完且跟这一坨的根节点的父亲选不了且先后手会改变且选这一坨的后手能得到这一坨的点的所有贡献（先手一无所获）。每一坨是独立的，但是每个人都不想当第一个选大坨的人，因为这样就得不到贡献。所以都会先从小坨选，其实这样会发现贡献是固定的，因为每次当前先手都会选择当前能选的坨的最小的一坨，来保证失去的贡献尽可能少。

突然发现，对于初始为奇数层的点，其实就是大小为 $1$ 的坨。每次选完一坨后大小改变。对于这个点是最后一个其父亲的儿子，这时它就不是单独的一坨了，要把它父亲带上合并到其父亲的父亲身上去。

每次选择最小的一坨取，然后先后手更改（最开始先把偶数层的叶子取完的时候也要算先后手情况）。取偶数层的时候是如果当前是先手则对答案产生贡献，取坨的时候是当前为后手则对答案造成这一坨的大小的贡献。

如果最小的一坨需要合并到其父亲的父亲上去，则不计入答案，而是把贡献存储在其父亲的父亲上。如果其父亲的父亲下面的点的贡献都存储到它身上了，就把它当做一坨来看待，加入堆。

如果说当前最小的一坨是最后一坨，当且仅当这一坨的根的父亲为 $1$，此时的先手能得到这一坨的大小 $+1$ 的贡献，并且此时所有点都被取完了。答案即为当前先手为 Alice 时得到的坨的贡献之和和最开始 Alice 选的偶数层叶子数量。
