## 题解 CF1459A 【Red-Blue Shuffle】

首先，这道题要我们对两个序列捆绑在一起 `random_shuffle` ，然后组成两个十进制数比大小。大的胜，则谁胜的机会更大。

我们可以发现，对于一个牌，它在无论哪个位置，它都是会在比较十进制数大小的过程中贡献一个 `if (a > b)` ，在这里我们默认 $a$ 是这张牌红色的数字， $b$ 是这张牌蓝色的数字。

所以我们单看比较大小，是不用管每个数字到底是什么的，我们只需要 **关注每张牌到底在哪里**

可以发现，一张牌在 `random_shuffle` 中到达一个位置的概率都是一样的。

这启发我们整体考虑整个比较过程，只要有出现一张牌的 $a$ 大于 $b$ ，那么就会有贡献，不需要真正考虑它这一位前面到底发生了什么，它就是有一个贡献在那里。

所以现在只需要 **关注每张牌的贡献**

---

可能前面这个 转化 还需要举个例子 ~~?~~

比如就考虑这个十进制数字的第一位吧，这里说第一位是最高位。

所有的牌被放到这个位置的机会都是一样的，所以比较获胜的机会只需看它们的贡献，那就是每张牌的 $a$ 与 $b$ 的大小关系了。

于是现在只需要 **统计所有牌中，有多少张满足 红 > 蓝，有多少张满足 蓝 > 红，平手的不用管**

最后的获胜的机会就是 **谁大的多就是谁胜的机会大**。

代码非常简单

code

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 1200;
int T, n;
int a[N], b[N];
int main () {
	scanf ("%d", &T);
	while (T --) {
		scanf ("%d", &n); int A = 0, B = 0;
		for (int i=1;i<=n;i++) {
			scanf ("%1d", &a[i]);
		}
		for (int i=1;i<=n;i++) {
			scanf ("%1d", &b[i]);
		}
		for (int i=1;i<=n;i++) {
			if (a[i] > b[i]) A ++;
			else if (a[i] < b[i]) B ++;
		}
		if (A > B) puts ("RED");
		else if (A < B) puts ("BLUE");
		else puts ("EQUAL");
	}
}
```

这个思维和码量：

> 真 Codeforces A 题

~~这场的 B OEIS？~~