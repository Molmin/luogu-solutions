## 思路

首先容易得到合法区间开头为 $1$。

接下来思考如何判断一个区间是合法区间，那么我们可以考虑将区间一段一段取走。

考虑这个区间中最右侧的 $1$，以及其后的一串连续数字，如果我们将这一串数字删去后，新的区间合法，则原区间一定合法，这个应该容易理解。反之如果我们将这一串数字删去后，新的区间不合法，则原区间一定不合法。这个证明我们可以这样思考，如果不删原来那一整串数，那一定是删这串数的一个前缀，而剩下的数，只能由前面其他的 $1$ 来领。而那些 $1$ 如果能领，那一定是作为其后缀，也有可能前面的 $1$ 根本带不掉这些数。因此这个 $1$ 直接带掉整串数是最优的，如果这都不行，那原区间一定不合法。

综上所述，要判断一个区间是否合法，只需要每次找到最右侧的 $1$，将其领的一串连续数字全部删掉，如果最后删完了则合法，否则不合法。

再考虑另一个性质：如果区间 $[l,r]$ 合法，那么区间 $[l,r0](l\le r0\le r)$ 也一定合法。这是易证的，因为我们去掉的只是原区间里一些 $1$ 领的后缀。

最后我们来看答案如何求。我们只需要对于每个 $l$，求出最大的 $r$ 使得区间 $[l,r]$ 合法，则对答案的贡献为 $r-l+1$。根据判断是否合法的方法，我们可以把整个数字串倒过来做，用栈来维护数字，每次遇到 $1$ 就取出连续的串，由栈中剩下数字的个数即可得到 $r_{max}$，具体实现见代码。

## 代码

时间复杂度 $O(n)$。

```cpp
ll n,a[500005],ans;
int main(){
	cin>>n;
	for(int i=1;i<=n;i++)cin>>a[i];
	vector<int>num;
	for(int i=n;i>=1;i--){
		num.push_back(i);
		ll now=1;
		while(!num.empty()&&a[num.back()]==now){
			num.pop_back();
			now++;
		}
		ll l=i,r=(num.empty()?n+1:num.back());
		ans+=r-l;
	}
	over(ans)
}
```
