### 前言

最近在学字典树，交发题解巩固一下，顺便记录我第一次 A 的紫题。~~（虽然很水最多是道蓝题）~~

### 字典树
都写到紫题了字典树是什么应该都会了，所以只是稍微讲一下，不会的看[模板](https://www.luogu.com.cn/problem/P8306)，里面题解讲的很清楚。学完后打几道 [板](https://www.luogu.com.cn/problem/P2580)[子](https://www.luogu.com.cn/problem/P2922) 题，然后再来看这道题。

字典树，对于储存一些字符串或者要处理的类似于字符串的数串，每一次在树中寻找它的前缀，如果没有就新建节点来储存这个数，如字符串  ```arm``` 和字符串 ```art``` 拥有相同的节点 ```ar```，那么它们会在树中拥有相同的前缀 ```ar```。

很多时候字典树能够有效地加快时间并优化空间，虽然局限性比较大，但是还是一个值得去学的东西。 ~~（毕竟在树形结构中字典树真的很简单，我二叉树都没学会就会写字典树了）~~

这里也不是字典树的裸题了，就不多讲述。

### 思路简述

看到字典这种东西再稍微看题就能知道这是字典树储存单词。建立树的过程很简单，但是多加一个数组判断是否有单词以这个编号结尾。

编辑距离可以理解为最多进行一次更改，如果没有进行更改就找到了输出 $-1$ 完事。

然后发现 $T$ 值很小，考虑暴力深搜：

- 首先定义深搜变量：$p$ 表示当前是第几个编号，$len$ 表示处理的这个字符串的长度，$change$ 定义布尔值，表示是否进行过操作。

- 对于删除操作，将其理解为不对这个字符做考虑，直接跳进下一个字符来判断。

- 对于添加操作，将其理解为字符串的长度加 $1$，因为如果进行更改一定会进行最优的，不用考虑更改造成的更多影响。

- 对于修改操作，和删除操作差不多，有一个剪枝：如果我更改的值是我被更改的字符本身，这次更改没有用，不用进行更改操作。

这里还有另一件事，一个字符串可能可以通过不同的方式被搜到两次，需要判重。

一个剪枝（可以算剪枝吗）：如果已经找到它是存储过的单词了，就不会需要进行更多的搜索了。并且在这里，我之前没想到 $ans$ 等于 $0$ 不等于它是存储过的单词，直接傻乎乎判 $ans$ 了……

这道题思路比较活，重点是将题目的一些条件进行简单的转化。

### 详见代码（有注释有些地方自己看，自己多思考）：
```cpp
#include <bits/stdc++.h>
using namespace std;

int n,m,trie[200200][30],id=0,ans;
bool en[200200],found[200200],isword;
string req;

void insert(){
	string s;
	cin>>s;
	int p=0,c;
	for(int i=0;i<s.size();i++){
		c=int(s[i]-'a');
		if(trie[p][c]==0)trie[p][c]=++id;
		p=trie[p][c];
	}
	en[p]=true;//记录末尾 
}//建树，最简单基础的操作了 

void dfs(int p,int len,bool change,string s){
	if(!isword){//已经判定为是单词了就不用更多地搜了 
		if(len==s.size()&&en[p]&&!change){//这里和下面只有 change 不同，也就是有没有被修改过 -> 是存过的单词 
			ans=0;
			isword=true;//记录 
			return;
		}
		if(len==s.size()&&en[p]&&change){//被修改过并且是单词 -> 找到了 
			if(!found[p]){
				found[p]=true;//判重避免重复找 
				ans++;
			}
			return;
		}
		int c=int(s[len]-'a');
		if(!change){//没有被修改过才能继续改 
			if(len<s.size())dfs(p,len+1,true,s);//删除操作 
			for(int i=0;i<26;i++){//暴力枚举 26 个字母 
				if(trie[p][i]!=0){
					dfs(trie[p][i],len,true,s);//添加操作 
					if(i!=c)dfs(trie[p][i],len+1,true,s);//更改操作 + 小剪枝 
				}
			}
		}
		if(len>=s.size())return;//已经比要求字符串大了，并且搜索结束，没有必要找下去 
		if(trie[p][c]!=0)dfs(trie[p][c],len+1,change,s);//不做更改直接搜 
	}
}

int main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++)insert();
	while(m--){
		ans=0;
		isword=false;//初始化
		cin>>req;
		dfs(0,0,false,req);
		if(isword)cout<<"-1\n";
		else cout<<ans<<endl;
		memset(found,false,sizeof(found));//把判重数组清空 
	}
	return 0; 
} 
```
### 难点 len 变量

$len$ 存的是当前匹配的字符串长度。

每在下一次递归时，$len$ 应该加上 $1$，但我们可以知道，删除操作会使长度减前去一，两两相抵，于是不需要更改。对于添加，$len$ 的长度上限也是增加 $1$，也可以抵消。而对于修改，长度还是一样，于是需要修改 $len$ 的值。

~~第一次写紫题题解，肯定有写得不好的地方，见谅。~~
