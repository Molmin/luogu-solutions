调了三天才调出来的一道题，写篇题解纪念一下吧。


其实就是一道单调队列模板题，但是不知道为什么用数组模拟总是WA，有大佬看到后欢迎来评论区里指教。

[数组模拟源码（有问题）](https://www.luogu.com.cn/paste/5q5wb75j)

话不多说，我们来看一看。

# 1、题目大意及注意事项

给你一个数组，求出每连续$k$个数中的最大值。

## 最朴素算法

我们把每个长度为$k$的连续区间枚举，求出每个区间的最大值。

复杂度为$O(k \times n)$，一看数据，$1 \leq n \leq 10^6$,$1 \leq k \leq 10^5$，这不TLE就怪了。

## 单调队列

于是我们开始想把复杂度简化到线性，不禁想起了单调队列。

我们来看一看什么是单调队列。

# 2、算法：单调队列

## 性质

1、队列中的元素其对应在原来的列表中的顺序（也就是下标）必须是单调递增的。

2、队列中元素的大小必须是单调递增（或递减）的。

3、**单调队列既可以从队首出队，也可以从队尾出队。**

## 处理过程

1、当插入元素时（从队尾入队），先将在它前面比他小的所有元素从队尾弹出（以维护单调性）。

2、插入该元素。

3、依据元素下标来判断当前队列元素个数是否超出$k$，若超出则将队头元素弹出。

4、输出队头元素。

每个数处理一遍，复杂度为$O(n)$

PS：不理解就找几组数据模拟两遍就好了。

# 3、代码

代码中有注释。

```cpp
#include <iostream>
#include <deque>
using namespace std;
const int N=1000010;
int n,k;
int a[N];
struct num
{
	int index,x;//个人比较喜欢用结构体记录下标和数，用起来舒服 
};

deque <struct num> q;//可双端弹出队列 

int main()
{
	int i;
	struct num t;
	cin>>n;
	for(i=1;i<=n;i++)
		cin>>a[i];
	cin>>k;
	for(i=1;i<=n;i++)
	{
		while(!q.empty()&&q.back().x<a[i])
			q.pop_back();//从队尾弹出 
		t.index=i;
		t.x=a[i];
		q.push_back(t);//进队列 
		while(!q.empty()&&q.front().index+k<=i)
			q.pop_front();//若比要求区间大，则从队头弹出 
		if(i>=k)  cout<<q.front().x<<' ';//输出 
	}
	return 0;
}
```

管理员大大求通过！

## 若有错误，欢迎指出！