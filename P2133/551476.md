***本题十分简单***

在初步看题时感觉是 bfs ，但作为**蒟蒻**的我不会写 bfs 。

在进一步分析题时我发现数串每次都是相邻的两个数进行交换，而此时我灵机一动发现可以根据 A 串的字符转化为数字并根据 A 串
定义一个大小排序对 S 串进行排序。

并且当你找到与 A 串相同的串时上一个寻找到女生必定是与她相似，那么找到的第一个理想女生的一定是要找的那个合适度第二的。

题目中找到的女孩包含和他的同桌和她自己，那么寻找的女孩必定有三人。那么如果寻找的的人数小于等于二是是不符合题意的。为了找到下一个女生必须要再找两个人才能找到理想女生。

通过分析不难发现可以用类似冒泡排序的思想来解决问题。

但是我个人认为本题有些许问题，通过样例数据分析
不难发现无论怎样操作都需要找 4 个女生才符合条件，那么题目中合适值包括他的同桌极有可能是描述错误

如此一来就诞生的我的代码

```cpp
	#include<bits/stdc++.h>
        using namespace std;
        int a[7],b[7],c[11],ans;
        char s;
        int cui(int x)
        {
            if(x==0) return 1;
            if(b[x]==a[x]) return cui(x-1);
            else return 0;
        }
        int main()
        {
            for(int i=1;i<=6;i++)
            {
                cin>>s;
                a[i]=s-'0';//字符转数字,下同。
                c[a[i]]=i;//重新定义一个大小排序。
            }
            for(int i=1;i<=6;i++)
            {
                cin>>s;
                b[i]=s-'0';
            }
            while(cui(6)!=1)
            {
                for(int i=1;i<=6;i++) //类似冒泡进行寻找操作。
                    if(c[b[i]]>c[b[i+1]])
                    {
                        int n=b[i];
                        b[i]=b[i+1];
                        b[i+1]=n;
                        break;
                    }
                ans++;
            }
            if(ans<=2)
            {
                cout<<ans+2;
                return 0;
            }
            cout<<ans;
            return 0;
        }
```
