本题大意 : 给你一个 $3\times 3$ 的矩阵且所有格的值为 $0$ 以及对该矩阵进行操作的顺序。已知，对某一格进行一次操作时应将该格及其相邻的格子上的值减 $1$；如果格子上的值为 $0$，则变为 $9$。操作的顺序是由 $a$，$b$，$c$，$d$，$e$，$f$，$g$，$h$，$i$，$9$ 个字母组成的字符串，这 $9$ 个字母分别代表对每个字母在矩阵中对应的格子进行操作，现在要你将这个矩阵恢复成初始样子。

**注意 :** 如果输入的是空行，也要输出，我们可以用 $getline$ 输入字符串加以判断是否为空行。

因为题目要求这个矩阵的初始样子，所以每一次操作时将该格及其相邻的格子上的值减 $1$ 就变成了加 $1$。

我们可以根据题目给的图进行操作，图如下：

| $a$ | $b$ | $c$ |
| :----------: | :----------: | :----------: |
| $d$ | $e$ | $f$ |
| $g$ | $h$ | $i$ |


举例 : 当字符串 $str$ 为 `cd`，操作如下。

1. 将 $c$ 所在的格子和与 $c$ 所在格子相邻的格子上的值都加 $1$。( 与 $c$ 所在格子相邻的格子是 $b$ 所在的格子和 $f$ 所在的格子 )
2. 将 $d$ 所在的格子和与 $d$ 所在格子相邻的格子上的值都加 $1$。( 与 $d$ 所在格子相邻的格子是 $a$ 所在的格子和 $e$ 所在的格子以及 $g$ 所在的格子 )

最后得出的初始矩阵如下：

| $1$ | $1$ | $1$ |
| :----------: | :----------: | :----------: |
| $1$ | $1$ | $1$ |
| $1$ | $0$ | $0$ |

参考代码 :
```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
using namespace std;

string str;
int f[4][4];

void apr()//对a所在的格子进行操作
{
	f[1][1] += 1;
	f[1][2] += 1;
	f[2][1] += 1;
}

void bpr()//对b所在的格子进行操作
{
	f[1][1] += 1;
	f[1][2] += 1;
	f[1][3] += 1;
	f[2][2] += 1;
}

void cpr()//对c所在的格子进行操作
{
	f[1][3] += 1;
	f[1][2] += 1;
	f[2][3] += 1;
}

void dpr()//对d所在的格子进行操作
{
	f[1][1] += 1;
	f[2][2] += 1;
	f[2][1] += 1;
	f[3][1] += 1;
}

void epr()//对e所在的格子进行操作
{
	f[1][2] += 1;
	f[2][2] += 1;
	f[2][3] += 1;
	f[2][1] += 1;
	f[3][2] += 1;
}

void fpr()//对f所在的格子进行操作
{
	f[1][3] += 1;
	f[2][3] += 1;
	f[2][2] += 1;
	f[3][3] += 1;
}

void gpr()//对g所在的格子进行操作
{
	f[2][1] += 1;
	f[3][1] += 1;
	f[3][2] += 1;
}

void hpr()//对h所在的格子进行操作
{
	f[3][1] += 1;
	f[3][2] += 1;
	f[2][2] += 1;
	f[3][3] += 1;
}

void ipr()//对i所在的格子进行操作
{
	f[2][3] += 1;
	f[3][2] += 1;
	f[3][3] += 1;
}

int main()
{
    string str;
    int k = 1;
    while(1)
    {	
		memset(f, 0, sizeof(f));//每次都要将数组f初始化
    	if(getline(cin, str) != "\n")
    	{
    		for(int i = 0; i < str.size(); i ++)
    		{
                //对字符串每一个位置进行判断
	    		if(str[i] == 'a') apr();
	    		else if(str[i] == 'b') bpr();
	    		else if(str[i] == 'c') cpr();
				else if(str[i] == 'd') dpr();
	    		else if(str[i] == 'e') epr();
	    		else if(str[i] == 'f') fpr();
	    		else if(str[i] == 'g') gpr();
	    		else if(str[i] == 'h') hpr();
	    		else if(str[i] == 'i') ipr();
	    		else continue;
			}
		}
        //以下是输出部分
		printf("Case #%d:\n", k);
		k ++;
		for(int i = 1; i <= 3; i ++)
		{
			for(int j = 1; j <= 3; j ++)
			{
				printf("%d", f[i][j]);
			}
			printf("\n");
		}
	}
    
    return 0;
}
```
