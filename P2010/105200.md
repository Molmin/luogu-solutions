[原题目](https://www.luogu.org/problem/P2010)

这是一道~~很简单的水题~~，**坑非常非常的多**


# 真的超级多
先看题，“牛牛想知道：在他指定的**两个日期之间**包含这两个日期本身），有多少个**真实存在的日期**是回文的。”

根据这句话，我们可以得到合法的回文日期：

**1.必须在两日期之间**

**2.必须为真实日期**

这样，我们就把整个题目分解为了以下几个子任务


### 一、寻找回文日期

### 二、判断所找回文日期是否合法
 
————————————————————————————————

对于子任务一，我们可以按日期枚举，再判断回文，可是

#### 这个日期有点大啊（最大可有9000000+次循环）

#### 再加上判断回文、判断合法...

#### **100%Time Limit Enough**

##  _换个思路！_ 
每个年份最多只有一个回文日期，那么...

### **我们是不是可以按年份枚举得前四位然后取反呢？**

```
int deep(int x)
{
	int y=0;
	y+=((x/1)%10*1000);
	y+=((x/10)%10*100);
	y+=((x/100)%10*10);
	y+=((x/1000)%10*1);
	return y;
}
```
**输入 2001** 

**返回 1002**

由这组数据可知

年份=2001    月份日份=年份取反=1002


所以我们可以写个自定函数来判断是否是真正的月份

```
int year(int date,int ni)
{
	int d=date%100,m=(date%10000)/100;
	if(m>12)
	return 0;
	if(m==1||m==3||m==5||m==7||m==8||m==10||m==12)
	if(d<=31)
	return 1;
	if(m==4||m==6||m==9||m==11)
	if(d<=30)
	return 1;
	if(m==2)
	{
		if((ni%4==0&&ni%100!=0)||ni%400==0)
		if(d<=29)
	    return 1;
		if(d<=28)
	    return 1;
	}
	return 0;
}
```

子任务二还需要满足“必须在两日期之间”的条件通过以下语句来实现（理解理解）

```
deep(i)+i*10000>=begin&&deep(i)+i*10000<=end
```

好了这个题就分析完毕了，上代码

————————————————————————————————
```
#include<cstdio>
#include<iostream>
#include<cmath>
using namespace std;
int begin,end,ans=0,a,b;
int deep(int x)
{
	int y;
	y+=((x/1)%10*1000);
	y+=((x/10)%10*100);
	y+=((x/100)%10*10);
	y+=((x/1000)%10*1);
	return y;
}
int year(int date,int ni)
{
	int d=date%100,m=(date%10000)/100;
	if(d>12)
	return 0;
	if(m==1||m==3||m==5||m==7||m==8||m==10||m==12)
	if(d<=31)
	return 1;
	if(m==4||m==6||m==9||m==11)
	if(d<=30)
	return 1;
	if(d==2)
	{
		if((ni%4==0&&ni%100!=0)||ni%400==0)
		if(m<=29)
	    return 1;
		if(m<=28)
	    return 1;
	}
	return 0;
}
int main()
{
	scanf("%d%d",begin,end);
	a=begin/10000;
	b=end/10000;
	for(int i=a;i<=b;i++)
        if(deep(i)+i*10000>=begin&&deep(i)+i*10000<=end&&year(deep(i),i)==1)
        ans++;
	printf("%d",ans);
	return 0;//本代码多处反抄袭，见谅
} 
```
————————————————————————————————

### **~~我一说还挺简单的吧...你看我多聪慧~~**




