//这道题已经很人性化了，直接判断是否为回文数就能拿60分，第一步：输入两个int整数即可（因为只有8位），然后分离出它的前4位，中间2位及后面两位，开始结束日期便有了。第二步：开始循环，每到月末，天数归1，月份++，年末，月份与天数同时归1，只要这个日期是回文就sum++。第三步：只要枚举的日期和结束日期一样，便停止，最后输出sum即可。

```cpp
#include <bits/stdc++.h>
using namespace std;
int y1,m1,d1,y2,m2,d2,sum;
int day[13]={0,31,28,31,30,31,30,31,31,30,31,30,31};//存每个月的天数（2月是没用的）
bool check()  
{  
    return (y1<y2)||((y1==y2&&m1<m2)||(y1==y2&&m1==m2&&d1<=d2));//首先，只要现在的年份小于结束年份就一定可以继续循环；然后，如果现在的年份和结束年份相等，且月份小于结束年份也可以循环；最后，只有天数不同，就必须现在的天数小于结束天数。  
}  
int r(int x)  
{  
    return ((x%4==0&&x%100!=0)||(x%400==0))?29:28;//判断2月的天数  
}  
bool palindrome(int y,int m,int d)  
{  
    char s[8];  
    int t=y*10000+m*100+d;//将它重新组成日期  
    sprintf(s,"%d",t);//转换为字符  
    for(int i=0;i<4;i++)  
        if(s[i]!=s[8-i-1])  
            return false;  
    return true;//判断回文  
}  
int main()  
{  
    int t1,t2;  
    cin>>t1>>t2;  
    y1=t1/10000; m1=t1/100%100; d1=t1%100;//分离出年份月份和日数  
    y2=t2/10000; m2=t2/100%100; d2=t2%100;  
    while(check())//判断是否枚举完  
    {  
        bool f=1;//f用于看是否一已经进行过日期更新  
        if(palindrome(y1,m1,d1))//原谅我用这么长的单词装逼  
            sum++;  
        if((m1==2&&d1==r(y1))||(m1!=2&&d1==day[m1]))//一个月完了  
        {  
            m1++;  
            d1=1;  
            f=0;  
        }  
        if(m1==13)//一年完了  
        {  
            y1++;  
            m1=1;  
            d1=1;  
            f=0;  
        }  
        if(f)//如果月没有结束，就直接加天数即可  
            d1++;  
    }  
    cout<<sum<<endl;  
    return 0;  
}
```