题目描述：

在日常生活中，通过年、月、日这三个要素可以表示出一个唯一确定的日期。

牛牛习惯用88位数字表示一个日期，其中，前44位代表年份，接下来22位代表月 份，最后22位代表日期。显然：一个日期只有一种表示方法，而两个不同的日期的表 示方法不会相同。

牛牛认为，一个日期是回文的，当且仅当表示这个日期的8位数字是回文的。现 在，牛牛想知道：在他指定的两个日期之间包含这两个日期本身），有多少个真实存 在的日期是回文的。

一个88位数字是回文的，当且仅当对于所有的i ( 1 \le i \le 8)i(1≤i≤8)从左向右数的第i个 数字和第9-i9−i个数字（即从右向左数的第ii个数字）是相同的。

例如：

•对于2016年11月19日，用88位数字2016111920161119表示，它不是回文的。

•对于2010年1月2日，用88位数字2010010220100102表示，它是回文的。

•对于2010年10月2日，用88位数字2010100220101002表示，它不是回文的。

每一年中都有1212个月份：

其中，1,3,5,7,8,10,121,3,5,7,8,10,12月每个月有3131天；4,6,9,114,6,9,11月每个月有3030天；而对于22月，闰年时有2929天，平年时有2828天。

一个年份是闰年当且仅当它满足下列两种情况其中的一种：

1.这个年份是44的整数倍，但不是100100的整数倍；

2.这个年份是400400的整数倍。

例如：

•以下几个年份都是闰年：2000,2012,20162000,2012,2016。

•以下几个年份是平年：1900,2011,20141900,2011,2014。

输入输出格式
输入格式：
两行，每行包括一个88位数字。

第一行表示牛牛指定的起始日期。

第二行表示牛牛指定的终止日期。

保证 date\_i date_i和都是真实存在的日期，且年份部分一定为44位数字，且首位数字不为00。

保证 date 1 date1 —定不晚于 date 2 date2。

输出格式：
一个整数，表示在date1date1和date2date2之间，有多少个日期是回文的。

输入输出样例
输入样例#1： 
20110101
20111231
输出样例#1： 
1
输入样例#2： 
20000101
20101231
输出样例#2： 
2
说明
【样例说明】

对于样例1，符合条件的日期是2011110220111102。

对于样例2，符合条件的日期是2001100220011002和2010010220100102。

【子任务】

对于60\%60%的数据，满足date1 = date2date1=date2。
```cpp
//枚举后面四位（月份+日期）。枚举后四位然后求出整个日期，判断是否在范围内即可。
//2月不需要判断是否是闰年，因为0229反过来是9220，整个日期是92200229，而9220年是闰年。
#include<bits/stdc++.h> //万能头文件
using namespace std;   //使用名字空间
int n,m,i,year1,year2,mon,days,ans=0;
int main() 
{
    cin>>n>>m;
    year1=n/10000;
    year2=m/10000;//求到年数
    for(i=year1;i<=year2;i++)    //在规定的年份中进行查找！
    {
        mon=i%10*10+i/10%10;
        days=i/100%10*10+i/1000;
        if(mon==2)  //2月特判
        {
            if((i%400==0||i%4==0&&i%100!=0)&&days<=29||days<=28) ans++;    //判断闰年分类讨论
        } 
        if((mon==1||mon==3||mon==5||mon==7||mon==8||mon==10||mon==12)&&days<=31) ans++;  //天数为小于31的，ans累加
        else
        if((mon==4||mon==6||mon==9||mon==11)&&days<=30)  ans++;      //天数为小于30,ans累加
    }
    cout<<ans<<endl;  //输出答案；
    return 0;     //结束程序
}
//注：本题不需要考虑年份，则考虑月份与日期是否合理就行了！
```