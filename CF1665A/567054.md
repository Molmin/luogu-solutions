# CF1665A GCD vs LCM

算是一道数论题吧，赛时就写了这个就睡觉了(

## 题目描述：

给定正整数 $n$ ，让你求出四个正整数 $a,b,c,d$ ，使得  $a+b+c+d=n$，并且 $\gcd(a,b) = \operatorname{lcm}(c,d)$ 。

输出任意一组解即可

有个结论，最小公倍数 $\operatorname{lcm}(i,j) =\gcd(i,j)*i*j$  。

## Solution

观察数据范围，发现 $n$ 和测试组数 $t$ 都是巨大的，并且任意一组解均可。

首先我们考虑朴素方法，暴力的去找这四个数字，那么我们枚举 $a,b,c,d$ 就行了(

不难发现我们可以省去一个 $d$ 的枚举，因为显然 $d=n-a-b-c$ 

这种枚举复杂度是 $n^3$ 的(大概),至于`gcd`的实现我们可以直接用`<algorithm>`里面的`__gcd(int i,int j)`，这个内部实现就是[辗转相除法](https://baike.baidu.com/item/%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95/1647675?fromtitle=%E8%BE%97%E8%BD%AC%E7%9B%B8%E9%99%A4&fromid=10667326&fr=aladdin)。

```c++
for(int a = 1;a < n;a++){
    for(int b = 1;b + a < n;b++){
        for(int c = 1;c + b + a < n;c++){
            int d = n - a - b - c;
            if(gcd(a,b) == lcm(c,d)){
                cout<<a<<" "<<b<<" "<<c<<" "<<d<<endl;
                goto end;
                //有解立刻跳出
            }
        }
    }
}
end:{};
```

即使加上各种优化，这种暴力枚举也肯定会被 $10^9$ 的数据干爆

那么，**正难则反**，我们看到这个巨大数据范围，自然会想有没有什么 $O(1)$ 算法或者结论。

经过一些思考，我们发现**两个数的最大公约数和最小公倍数都不好确定，除非其中有一个数是固定的**。

那我们就固定一个数呗，反正只要保证四个数和为 $n$ 就行啦。

然后我们再想，一个数固定了之后还是不好确定 $gcd$ 和 $lcm$ 的，但是可以有特殊情况：

> $\gcd(1,i) = 1,i \in N*$

这个非常牛逼的数，**1 可以把 $gcd$ 确定下来**。

但是这还不够，我们还需要让 $\gcd(a,b)=\operatorname{lcm}(c,d)$ 成立。

我们既然已经确定了 $\gcd(a,b) = 1$ ，那我们直接**强制 $\operatorname{lcm}(c,d) = 1$ 不就完了**(

于是我们考虑 $\operatorname{lcm}(1,i) = i , i \in N*$ ，从而发现 $\operatorname{lcm}(1,1) = 1$ （废话）

那么结论就得出来啦，我们只需要使 $a =n-3 ,b=1,c=1,d=1$ 即可，一定是一组满足条件的解。

容易发现，$n<4$ 时无解，但是题目保证有解所以就不管啦。

代码难度入门，就不放了（逃