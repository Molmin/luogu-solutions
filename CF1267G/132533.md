讲的时候连题目都没看完就被寄掉了（               

考虑到一个比较 NB 的性质：一定是先搞二操作再搞一操作。           

一个不是完全严谨的证明：假设现在已经有 $s$ 张牌被你抽了，那么我们知道想要获得第 $(s + 1)$ 张牌的期望是 $(\frac{n}{n - s} + 1) \times \frac{x}{2}$，我们不难发现随着 $s$ 的增大那么该期望值一定会变大。      

也就是说存在一个临界点，使得之前获得所有卡牌的方式都是回旋心跳水立方抽卡，之后的所有方式都是直接买。               

那么你可以用一个很 trick ~~但是我没见过~~的套路将原题这么转化：     

有两种得卡方式，分别为：             

- 直接开抽；

- 在心中随机一张牌然后买它，并且购买任意一张牌的值会剩下的所有卡牌的价值和除上剩下卡牌的数量；

求使用以上两种方法可以获得的期望最小值。    

我们发现总的牌数很小，总的卡牌价值和很小，那么不妨定义状态 $dp_{i,j}$ 表示此时抽到 $i$ 张牌并且用了 $j$ 花费的概率。

由于现在两种操作都是概率操作，所以 $dp_{i,j}$ 可以用总方案数除上所有情况得出。

我们如果设计期望 DP 的话难度太大，所以我们不妨累加所有的 $dp_{i,j}$ 向下一个状态转移时的最小期望值以获得全局最小期望值。（这里的状态转移不是指概率 DP 的转移，可以理解成假设你有一个期望 DP 时你要从这步状态转移到下步状态时的状态转移，可以感性理解下）

之所以要转化题意是为了判断临界点。把这个转化的题意模拟一下就会发现，临界点的判断只需要在两种方法中取 $\min$ 以达到间接判断的作用（一旦选择操作 $2$ 后面也会一直选择操作 $2$，期望值形同虚设只是为了辅助正确的判断），而如果按照原题的方式直接 DP 就无法判断临界点，导致爆炸。                 

然后基本上就做完了，如果还对于 DP 转移式或如何求 $dp_{i,j}$ 比较迷惑的同学可以参考代码或者直接看一下旁边的题解，因为这一部分比较简单所以不再赘述。              

个人认为难度在于第一步转化题意（~~虽然很多人都觉得很 trick~~）以及累加转移的最小期望值以获得全局期望最小值的计算方法，别的都还是很良心的！

```cpp
#include "bits/stdc++.h"
using namespace std;
const int N = 105 , M = 10005;
int n,m,a[N],sum;
double f[N][M],fac[M],x,ans;
double C(int nn,int mm){return fac[nn] /(fac[mm] * fac[nn - mm]);}
int main()
{
	scanf("%d %lf",&n,&x);x = x / 2;fac[0] = 1;
	for(int i = 1 ; i <= n ; i ++) 
	{
		scanf("%d",&a[i]);
		sum += a[i];
		fac[i] = 1.0 * fac[i - 1] * i;
	}
	f[0][0] = 1;
	for(int i = 1 ; i <= n ; i ++)
		for(int j = n ; j >= 1 ; j --) 
			for(int k = sum ; k >= a[i] ; k --) f[j][k] += f[j - 1][k - a[i]];
	for(int i = 0 ; i < n ; i ++)
		for(int j = 0 ; j <= sum ; j ++) ans += 1.0 * f[i][j] / C(n , i) * min(1.0 * (sum - j) / (n - i) , (1.0 * n / (n - i) + 1.0) * x);
	printf("%.10lf\n",ans);
	return 0;
}
```