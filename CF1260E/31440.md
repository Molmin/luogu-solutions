这题思路真的巧妙啊..  

提供一个贪心思路 和官方题解不同  

首先最后一个人如果不是自己一定是要付钱的 因为没有人能打败他 他一定会留到最后一局  
然后在那个$-1$这个点(后面记为$x$)前面的人打了也不用付钱 所以全当作付0块钱  

这里感觉用$n$说太抽象了 举个具体的例子好了 比如有$16$个人  
如果有$\leq \dfrac{n}{2}=8$个在$x$右边的数 可以视为用左边的$0$补满$8$个数(因为价格为0无所谓了) 然后组成一个完全二叉树结构 然后那么这些人经过$(log_2 n)-1=3$轮后一定只剩下一个人 就是最右边的数   

然后让这个人**在最后一轮**和$x$比  
```cpp
0 1 2 3 4 5 6 x 8 9 A B C D E F
8 - 9 , A - B , C - D , E - F
9 - B , D - F
B - F

// 最后一轮为 x - F
```

如果不止$8$个数呢  
这样我们只给一个人付钱就不行了 先假设只需要给两个人付钱  
不过我们还是可以挑出来$8$个人 让他们只剩下最右边那一个数  

然后在剩下的人中继续做 这些人里选出来一个给钱 那么这个人在**倒数第二轮**就需要和$x$比 于是'这些人'只能比两轮 所以最多只能有$4$个人   
同样不满4个可以把左边的0拉到右边去 这一步只是方便理解 实际实现没有必要  
![](https://cdn.luogu.com.cn/upload/image_hosting/0gjdsey5.png)  
蓝圈里是$x$  
我们需要最小化两个红圈里数的和

如果给两个人付钱还不够  
于是我们需要在 同时满足 最后$8$个数中选出一个 在最后$12$个数中选出两个 在最后$8+4+2=14$个数中选出三个 ...  

可以当成选完$8$个后 去掉选的那个 然后在最后$12$个里剩下的$11$个里找个最小的 后面依次类推  
最小化花钱数 可以直接贪心 用堆实现  

我们倒序从大到小加入数 观察到加入第$i$个数后 如果$i=2^k$则取出目前还没选过的人中花钱最小的那个  
碰到$x$就可以结束了 因为再往后一定不会花钱了


代码非常短
```cpp
#include <cstdio>
#include <iostream>
#include <algorithm>
#include <cstring>
#include <queue>
using namespace std;
typedef long long LL; // 不开LL见祖宗

LL n,val[400005];
LL ans = 0;
priority_queue <LL,vector<LL>,greater<LL> > q; // 小根堆
LL pw2[400005] = {0}; // pw2[i]记录i是不是2^k

int main(){
	cin >> n;
	for(LL i = 1;i <= n;i ++) cin >> val[i];
	for(LL i = 1;i <= 18;i ++) pw2[(1 << i)] = 1;
	for(LL i = n;i >= 1;i --){
		if(val[i] == -1) break;
		q.push(val[i]);
		if(ot[i]){
			ans += q.top();
			q.pop();
		}
	}
	cout << ans << endl;
	return 0;
}
```