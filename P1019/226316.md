题目链接：https://www.luogu.org/problem/P1019

## 【题目描述】
单词接龙是一个与我们经常玩的成语接龙相类似的游戏，现在我们已知一组单词，且给定一个开头的字母，要求出以这个字母开头的最长的“龙”（每个单词都最多在“龙”中出现两次），在两个单词相连时，其重合部分合为一部分，例如 beastbeast和astonishastonish，如果接成一条龙则变为beastonishbeastonish，另外相邻的两部分不能存在包含关系，例如atat 和 atideatide 间不能相连。

## 【输入格式】
输入的第一行为一个单独的整数nn (n \le 20n≤20)表示单词数，以下nn 行每行有一个单词，输入的最后一行为一个单个字符，表示“龙”开头的字母。你可以假定以此字母开头的“龙”一定存在。

## 【输出格式】
只需输出以此字母开头的最长的“龙”的长度。

## 【解题思路】
这题之前我在vj上做过一次，当时是一知半解，没想到这次又碰上了，我还是不会（。。。。），去看了一遍我当初的AC代码，当时用了一个string里的substr函数，这次我想着用char做做试试，一做就是一小时。。。

题目意思很好理解，这题的关键其实并不在于dfs，而是在于如何查找一个后缀与另一个前缀相同的字符串并返回最小重叠长度，我们可以这样想，直接从第一个字符串的末尾开始往前遍历，指针每往前移动一次就将当前指针（指向第一个字符串末尾，以下简称指针1）所指向的字符与另一字符串的前缀指针（指针2）相比，如果相同，则使两个指针分别后移，如果指针1最后能够移动到末尾位置，即找到了最小重叠长度。

与处理好每两个字符串之间的重叠长度后（事实上，预处理好的是最大的增加长度，即字符串2的长度减去最小重叠长度），进行dfs（这里我们用一个二维数组存放预处理好的最大长度，其两个维度分别代表字符串1和字符串2的编号，其值表示将字符串2连到字符串1后的增加长度），如果数组值不为0，则使已知长度加上数组值，并与ans变量比较取最大值。

值得注意的是，与常规的dfs不同，这题说一个单词可以用两次，那么vis数组必须为int型且初始化为0。

## 【AC代码】
```cpp
#include <vector>
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;
int mark[21][21];  //记录增加长度
char s[21][100];  //存放字符串
int vis[21];   //记录单词使用次数
int len[30];   //记录下一个拼接单词的编号
int ans = 0;  //记录答案
int ll = 0;  //记录各个长串的长度
int n;
int get(int x, int y)
{
	int l = 0;  //指针2
	int flag = 1;
	int l1 = strlen(s[x]);
	int l2 = strlen(s[y]);
	for (int i = l1 - 1; i > 0; i--)  //从后往前遍历
	{
		for (int j = i; j < l1; j++)  //从指针1往后遍历并与指针2比较
		{
			if (s[x][j] != s[y][l++]) //如果指针1与指针2所指字母不同，break
			{
				flag = 0;
				break;
			}
		}
		if (flag)  //如果指针1成功遍历至末尾，返回l2-l（思考为什么）
			return l2 - l;
		l = 0;  //否则继续遍历并还原指针2
		flag = 1;
	}
	return 0; //如果遍历完了也没找到说明字符串1,2并不能连接，返回0
}
void dfs(int x)  //常规dfs
{
	for (int i = 1; i <= n; i++)
	{
		if (mark[len[x]][i] && vis[i] < 2)  //如果编号为len[x]的字符串与i的字符串能连接，且i使用次数小于2，记录下来
		{
			vis[i]++;
			len[x + 1] = i; //下一个拼接的字符串编号为i
			ll += mark[len[x]][i]; //总长度加上可增加长度
			ans = max(ans, ll);  //将总长度与上一次ans比较取最大值
			dfs(x + 1);
			ll -= mark[len[x]][i];  //回溯操作
			vis[i]--;
		}
	}
}
int main()
{
	scanf("%d", &n);
	for (int i = 1; i <= n; i++)
	{
		scanf(" %s", s[i]);
	}
	scanf(" %s", s[0]);
	for (int i = 1; i <= n; i++)  //找到能作为首个单词的字符串
	{
		if (s[i][0] == s[0][0])
		{
			mark[0][i] = strlen(s[i]);  //将0与i相连
		}
	}
	for (int i = 1; i <= n; i++)  //两两处理字符串
	{
		for (int j = 1; j <= n; j++)
		{
			mark[i][j] = get(i, j);
		}
	}
	dfs(0);
	printf("%d\n", ans);
	return 0;
}
```


