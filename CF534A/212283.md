写这篇题解的时候，由于提交的次数比较多，所以会比较详细。

**本题带有 spj，所以答案不一定和样例一样！**

首先，把题意化简为：

- 给定一个正整数 $n$，有一个序列由 $1\sim n$ 组成。

- 这个序列的任意相邻两项差都不为 $1$。

一开始想到的办法是：随机打乱，判断。

但是这种方法不仅不靠谱，而且很容易超时各种奇怪的错误，所以，我们可以考虑一种简答的方式：

- 先输出奇数。

- 再输出偶数。

这时候，就不会有问题了，在差到达一定大小的情况下，奇数和偶数会分开。

那么，我们就要考虑，哪些情况需要特判呢？

首先是 $n\le 2$ 的情况，这种情况仅有一种办法：

$$\rm Total:1\ ,\ Num\ :\ 1$$


此时仅有一种情况了

接着就是样例的情况：

$$\rm Total:2\ ,\ Num\ :1,3$$

接着我们就到了一个十分重要的地方：$4$。

乍一看似乎只有 $\rm Total:3\ ,\ Num\ :1,4,2$ 的情况，但是，请注意，**开头不一定是 $1$!**

所以，在 $4$ 的情况下，数列为 $3,1,4,2$。

此外，我们再来证明一下，对于任何大于 $4$ 的 $n$ ，都能保证奇数偶数岔开。

若 $n$ 为偶数，其最大奇数为 $n-1$。

$$\because\ n>4$$

$$\therefore\ n-1>3$$

$$\therefore\ n-1>2+1$$

所以必然岔开。

若 $n$ 为奇数，则：

$$\because\ n>4$$

$$\therefore\ n>2+1$$

故必然岔开。

据此，证毕， $\rm Q.E.D$

然后我们就可以程序实现了：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
int main(){
    cin>>n;
    if(n<=2){
        puts("1\n1");
        return 0;
    }
    if(n==3){
        puts("2\n1 3");
        return 0;
    }
    if(n==4){
        puts("4\n3 1 4 2");
        return 0;
    }
    cout<<n<<endl;
    for(int i=1;i<=n;i+=2)cout<<i<<' ';
    for(int i=2;i<=n;i+=2)cout<<i<<' ';
    return 0;
}
```

此时所有的内容均已讲解完毕，谢谢阅读，欢迎使用代码对拍/理解/查找错误。

