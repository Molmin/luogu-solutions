我们可以手动模拟几组数据，然后找规律。比如先整个 $2\times 3$：
```cpp
0111110111110111110
1	  1		1	  1
1  R  1	 R	1  R  1
1	  1		1	  1
0111110111110111110
1	  1		1	  1
1  R  1	 R	1  R  1
1	  1		1	  1
0111110111110111110//用1代表墙，R代表人
```
先让第一行的人逃出去，我们可以打通他们 $3$ 个人之间的 $2$ 堵墙，然后打通最右边上方的墙：
```cpp
			   ^
0111110111110**|**0
1	  *		*  |  1
1  R---->R---->R  1
1	  *		*	  1
0111110111110111110
1	  1		1	  1
1  R  1	 R	1  R  1
1	  1		1	  1
0111110111110111110
```
这时我们打通了 $3$ 堵墙，继续拯救第二行。我们可以打通他们 $3$ 个人的墙并与第一行连接起来：
```cpp
			   ^
0111110111110**|**0
1  	  *	    *  |  1
1  R---->R---->R  1
1     *   	*  |  1
0111110111110**|**0
1	  *		*  |  1
1  R---->R---->R  1
1	  *		*	  1
0111110111110111110
```
我们发现：拯救第二行的人也要打通 $3$ 堵墙。我们可以得出一个结论：

>拯救一行的人需要打通 _这一行的人数_ 堵墙。

继续模拟，这次加大到 $3\times 4$：
```cpp
0111110111110111110111110
1	  1		1	  1		1
1  R  1	 R	1  R  1	 R	1
1	  1		1	  1		1
0111110111110111110111110
1	  1		1	  1		1
1  R  1	 R	1  R  1	 R	1
1	  1		1	  1		1
0111110111110111110111110
1	  1		1	  1		1
1  R  1	 R	1  R  1	 R	1
1	  1		1	  1		1
0111110111110111110111110
```
第一行打通 $4$ 堵墙:
```cpp
					 ^
0111110111110111110**|**0
1	  *		*	  *  |	1
1  R---->R---->R---->R  1
1	  *   	*	  *		1
0111110111110111110111110
1	  1		1	  1		1
1  R  1	 R	1  R  1	 R	1
1	  1		1	  1		1
0111110111110111110111110
1	  1		1	  1		1
1  R  1	 R	1  R  1	 R	1
1	  1		1	  1		1
0111110111110111110111110
```
接下来每一行打通 $4$ 堵墙，一共 $2\times 4=8$ 堵墙：
```cpp
					 ^
0111110111110111110**|**0
1	  *		*	  *  |	1
1  R---->R---->R---->R  1
1	  *   	*	  *	 |  1
0111110111110111110**|**0
1	  *		*	  *  |	1
1  R---->R---->R---->R  1
1	  *   	*	  *	 |  1
0111110111110111110**|**0
1	  *		*	  *  |	1
1  R---->R---->R---->R  1
1	  *   	*	  *		1
0111110111110111110111110
```
不难发现，每一行需要打通的墙数一样，要打通的墙数是这 
$3$ 行要打通的墙数全部加起来。~~根据乘法的定义~~，我们可以得出结论：

>$n\times m$ 的监狱，需要打通 $n\times m$ 堵墙，才能让全部人逃出去。

至此，本题得解。
```cpp
#include <cstdio>
using namespace std;
int n,m;
int main(int T,char**){
    for(scanf("%d",&T);T--;puts("")){
        scanf("%d%d",&n,&m);
        printf("%d",n*m);
    }
    return 0;
}
```