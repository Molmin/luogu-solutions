# P1244 青蛙过河 题解

## 对题目的解读
这题难度其实并不大，真正的代码很短，只是需要正确的解读。

~~我翻阅了很多题解，发现各位奆佬不屑于解读题目，于是，有了这篇题解~~

假设dp[i][j]表示i片荷叶j片石墩能通过的青蛙数。

则原题中有这样几个关键点：

1. 石墩可以容纳很多青蛙，但是编号必须从小到大；荷叶只能容纳一只青蛙。换而言之，荷叶只是容纳青蛙，保证青蛙能从小到大的一个载体。荷叶的个数和青蛙的个数决定能有青蛙停留的个数，石墩是青蛙的中转站。
2. 题目中青蛙有无数只，不需要考虑青蛙是否足够。也就是说如果荷叶有k片，青蛙直接从出发点去终止点，则有*k*只青蛙可以站在荷叶上，还有一只可以站在青蛙出发的A石墩，共有*k+1*只，（即*dp[0][k]=k+1*）
3. 假设在出发点和终止点中间有一个石墩*C*（即原题中说的*h=1*，也就是dp[1][k]记录的结果）时，青蛙就可以在C点转乘，相当于求蛙从A到C的最多个数，也就是中间没有石墩，k片荷叶的情况，即*dp[0][k]*；当然，一部分青蛙还可以直接转移到终止点，也是dp[0][k]的情况。所以*dp[1][k]=dp[0][k]+dp[0][k]=2 * dp[0][k]*
4. 假设有两个石墩C,D(即原题中说的h=2，也就是dp[2][k]记录的结果)，就比只有一个C点的情况(dp[1][k])多了从C到D，从D到终止点（dp[0][k]+dp[0][k]）两种情况。也就是说dp[2][k]=dp[0][k] * 2+dp[1][k]=dp[0][k] * 2 +dp[0][k] * 2 = 2 * 2 * dp[0][k]
5. 继续探究...

从中不难发现规律：dp[h][k] = dp[0][k] * 2 ^ h = (k+1)* 2 ^ h (参考第一点)

也就是说，答案最终与dp数组无关。

不难写出如下的代码：
```cpp
#include <bits/stdc++.h>
using namespace std;

int main()
{
    int h,k;
    scanf("%d%d",&h,&k);
    long long ans=0;
    ans=(k+1)*(1<<h);
    printf("%lld\n",ans);
    return 0;
} 
```

需要关注一下的有一下几点：

1. 此题的数据比较大，答案需要long long
2. 位运算*1<<n*表示*2^n*

本蒟蒻的代码和第一篇题解的代码很相似，只是想多解释一下题目的一些细节。

---
## 祝各位好运！