## 算法分析：首先考虑没有石墩的情况，设n为石墩数，m为荷叶数，f[n][m]表示有n个石墩，m个荷叶时能跳过去得最多的青蛙数。
## 显然，f[0][0]=1,f[0][1]=2,f[0][2]=3……可以归纳出f[0][y]=y+1。
## f[n][m]是我们算出的子问题。在它的基础上，我们可以再增加一个石墩。也就是现在我们算f[n+1][m]。他就应该用到之前的子问题。我们把f[n][m]看成左岸，新增石墩看成右岸，把新增石墩看成左岸，子问题看成右岸，所以可以过的青蛙数翻倍。故有方程：f[n+1][m]=f[n][m]*2; 因为f[0][m]=m+1,所以我们就可以写成这样：
```
#include<iostream>
using namespace std;
int main()
{
	int m,n;
	cin>>n>>m;
	m++;
	for(int i=1;i<=n;i++)
	{
		m*=2;
	}
	cout<<m;
} 
```
## C++源码，详见《算法竞赛宝典》第二册妖兽特工队。