最开始没想出来，看了前面的几篇题解，感觉也没说到点子上(估计还是我太菜了

现在来写下这题的题解，自认为是**最通俗易懂**的啦，哈哈。

首先题目的意思是，问从A石墩到B石墩最多能过去的青蛙个数。在石墩上可以有无限个
青蛙，不过要求编号大的青蛙在下面。即汉诺塔的排列方式，小的重叠在大的上面。
在A石墩和B石墩之间有h个石墩和k个荷叶。A石墩和B石墩和中间的h个石墩都是一样的，都要满足小的编号重叠在大的上面。

---
**分析**：

A石墩和B石墩，中间只有k个荷叶时，那么可以有k+1个青蛙，跳过去。记为状态S，在这个状态下可以通过的青蛙数记为y，即y等于k+1.

S和y，是为了下面叙述方便。

大家在脑子里想，现在增加一个石墩，记为new。

我们把石墩new看成石墩B，那么我们可以重复上一个状态S，先把y只青蛙运到石墩new上，这时我们又回到了上一个状态S(不看石墩new)，这时又有y只青蛙可以运送到石墩B。最后我们再把石墩new上的青蛙运送到石墩B上(这时可以把石墩new，看成石墩A)。

所以增加一个石墩有，y + y 等于 2 * y个青蛙可以运送过去。y是上一个状态能运送的青蛙数。

接着我们再增加一个石墩，...其实就是重复上一个状态。

这其实就是动态规划里，这个状态由上一个状态转移过来，上一个状态由上上一个状态转移过来，...

我们可以把这种状态转移方式，叫递归或者递推，它俩本质是没有任何区别的。

---

参考代码：代码虽短，但是思考过程还是挺有意思的0..0

```cpp
#include <bits/stdc++.h>

int h, k;

int main() {
    scanf("%d %d", &h, &k);
    long long ans = k + 1;
    for(int i = 1; i <= h; ++i) {
        ans = ans * 2;
    }
    printf("%lld\n", ans);
    return 0;
}

```



