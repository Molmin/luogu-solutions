题意：

有一个长度为$n$序列，把它分成$k$组，求每组最小值，再求最大值


分析：   

我们采用贪心思想，先分类讨论：

- 当$k=1$时，只有一个区域，所以最小值就是整个序列的最小值，直接算一下就可以了。

- 当$k=2$时，有两个区域，一个带头，一个带尾，我们只需要在首尾两个元素中选最大值就可以了。为什么呢？我们举例带头的情况。
	- 当任何一个元素比它大的时候，选的是最小值，所以还是它，不用考虑比它大的数。
    - 当任何一个元素比它小的时候，就会选小的，那么就不是最大值了，所以不能选比它小的。   
    
 	结论就是，最终的最大可能就是首和尾，我们只能选首尾中大的一个，然后单独给它一个子序列，结果就是它。

- 当$k>=3$时，即有三个区域，可以把任何一个数单独分到一个组里，如果是两头，两个区间就可以，如果是中间，就用两头的两个区间把两边占满就可以了。所以要求最大值的话就十分简单了，只需要在所有的元素中选最大值就可以了，因为每个都可以选出来。

蒟蒻的辣鸡代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=100005;
int n,k,a[N];
int main(){
	cin>>n>>k;
	for(int i=0;i<n;i++) cin>>a[i];
	if(k==1) cout<<*min_element(a,a+n)<<endl;
	else if(k==2) cout<<max(a[0],a[n-1])<<endl;
	else cout<<*max_element(a,a+n)<<endl;
	return 0; 
} 
```
~~STL是个好东西~~