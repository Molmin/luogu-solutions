这计数挺妙的！

首先 $1$ 号位先把它填上，然后剩下 $(n-2)$ 个需要填上，我们枚举一个 $i$ 然后如果有个办法可以在 $O(1)$ 的时间内求出用**不超过** $i$ 次操作把它填完的方案数就好了。

这里有一个巧妙的转化，就是考虑每次往后怎么放，如果空一格，那么就是空白格少了两个，直接放，空白格就少了一个。这样就可以把问题转化为 $(n-2)$ 每次减去 $1$ 或 $2$，用 $(i-1)$ 次，最后变成 $0$ 的方案数是多少就可以了，因为不同总次数肯定不一样，相同总次数超出的不会恰好变成 $0$，不超出的因为中间一定有选择放的地方不一样，所以不重不漏。

然后发现每次反正都要减去 $1$ 的，那先给它减掉 $(i-1)$ 个 $1$，问题就变成了要么减去 $0$ 要么减去 $1$，这样在 $i-1$ 中个选出 $(n-2)-(i-1) = n-i-1$ 个就行了，那么答案就是 $i-1 \choose n-i-1 $。最后前后面都可以随便排，乘上两个阶乘即可。

```cpp
for (int i = (n+1) / 2; i < n; i++)
		f[i] = C(i-1, n-i-1) * fac[i] % P * fac[n-i-1] % P,
		ans = (ans + (f[i] - f[i-1] + P) % P * i % P) % P;
```

那么这个妙在哪儿呢？我觉得最神奇的地方就在于它没有直接考虑这个排列本身，而是用了另一个不重不漏的方式去构造了这个排列。