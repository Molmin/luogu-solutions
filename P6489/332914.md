准备NOIP入门比赛了，最近狂刷入门题目，感觉越来越~~简单~~

好吧，不说废话，这道题目不算很难，用了两次循环就AC了，86ms。

先说说题目意思吧：

有n个数，现在要求出递增子段最大数

以样例来看：

输入：

```cpp
5
1 2 1 4 6
```

输出：

```
5
```

首先第一个1比2小，递增，现在最大 = 2 - 1 = 1

然后2比1大，不递增，不作任何操作

下一步1比4小，递增，最大 =  4 - 1 = 3（前面2 - 1的结果不累加，因为是最大上升子段）

最后4比6小，递增，最大 = 3 + (6 - 4) = 5

一次我们会发现，连续一段递增的话和累加，不然和变为0

代码来：
```cpp
#include <iostream>
using namespace std;

int arr[1005];

int main()
{
    int n, max = 0, sum = 0;
    cin >> n;
    for(int i = 1; i <= n; i++)
    {
        cin >> arr[i];
    }
    for(int i = 1; i <= n - 1; i++)
    {
        if(arr[i + 1] > arr[i])
        {
            sum += arr[i + 1] - arr[i];
        }
        else
        {
            sum = 0;
        }
        max = sum > max ? sum : max;
    }
    cout << max << endl;
    return 0;
}
```

说下三目运算符

条件 ? 值 : 值;

如果条件满足，返回true，即值1，否则返回值2

如：
```cpp
int x = 1 + 2 == 3 ? 3 : 0;
```
x = 3

又如：
```cpp
int x = 1 + 2 == 3 && 1 + 1 == 1 ? 2 : -1;
```
x = -1