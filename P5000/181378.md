这道题其实难度也不大，我一次就过了，我有点不理解为什么是蓝题~~(其实我也评了蓝题难度)~~，可能是没看清$R$的最大值高达$10^5$，而不是$26$。  
### 解题思路:
1. 这道题目不仅仅考了字符串的转换，还考了高精，可能没看清楚的人就开了$long\ long$，就完美的$WA$了，开高精也不用开的特别大，最多就$1173$位，所以省空间的人可以开$294$(万进制)位。
1. 在进行字符串转换时，一定要注意r的大小，建议一开始就对$26$取模，不容易出错。
1. 这是一个高精乘低精，每一位先乘一遍，再进位就可以了，当然也可以化低精位高精。
1. 千万别忘记输出之后把这个高精数的值初始化位1，否则$WA$和$RE$等着你。
### 完整代码如下：
```cpp
  #include<bits/stdc++.h>
  using namespace std;
  struct ll{//我喜欢把高精数定义成结构体，这样好操作一点
      int a[1222];//我用了10进制，你们也可以用别的进制，如万进制
      void start()//初始化
      {
          memset(a,0,4888);//4888=1222*sizeof(int)
          a[0]=a[1]=1;//用a[0]储存数组位数，并初始化为1，同时a[1]也要为1
      }
      ll& operator *=(int x)//重载运算符，高精乘以低精
      {
          for(int i=1;i<=a[0];i++)
              a[i]*=x;//先每一位乘一遍
          for(int i=1;i<=a[0];i++)
              a[i+1]+=a[i]/10,a[i]%=10,a[0]+=(i==a[0]&&a[i+1]);//接着进位
              /*这个不需要去前导0，想一下为什么*/
          return *this;//这个不用管
      }
      void out()//输出
      {
          for(int i=a[0];i>0;i--)
              printf("%d",a[i]);
          puts("");//别忘记换行
      }
  };
  ll a;
  int n,r,len;
  char str[666];
  void work(char *s,int len,int x)//中转字符串
  {
      x%=26;//一开始就对26取模，避免溢出导致WA
      for(int i=0;i<len;i++)
          s[i]+=x,s[i]-=26*(s[i]>90);//用了假值为0，真值为1的特性，使得代码简单明了
  }
  int main()
  {
      scanf("%d%d",&n,&r);
      /*当然你也可以直接把r对26取模*/
      while(getchar()!='\n');//这个不能少，用于吃换行符，少掉后果自负
      for(int i=1;i<=n;i++)
      {
          a.start();//初始化
          scanf("%s",str);//不建议用gets，否则警告一大串
          len=strlen(str);
          work(str,len,r);
          puts(str);//puts可以用，这个不会导致警告一大串
          for(int i=0;i<len;i++)//下标要从0开始
              a*=str[i];//一位一位乘
          a.out();//输出
      }
      return 0;
  }
```
这个程序的时间复杂度也许不是最优，但是这个代码相对来说比较友好，最后希望大家支持我，我接下来会写更多的题解，谢谢！