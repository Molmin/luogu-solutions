想了半天终于A了，发现楼下神犇正解。不过接下来我们会用dp的思想讲解我们的思路。

首先我们想想方程：设f[i]表示用这些硬币组成1~i的面值的最少数量。（看上去很靠谱）

但是我们会发现一个巨大的BUG：没法转移。。。。。

原因十分简单：假如我们要计算f[666]，用一个面值为233的硬币转移，就会发现你需要转移到f[433]。然而，你并不能知道f[433]究竟有没有包含足够的233，使得它有足够的233进行转移。（栗子举的可能不太恰当，但是把233换成5问题就会更加明显。）

所以我们需要改变状态，反其道而行之：设f[i]表示用i枚硬币可以表示出的最大k使得它们可以组成1~k的所有数！【关键点来了】

然后我们的方程就很简单了：f[i]=max{f[i-1]+a[j]|a[j]≤f[i-1]+1}

解释一下：为了更新答案，我们至少要凑出f[i-1]+1。那么如果往里面丢一个a[j]，它必须小于等于这个值，否则无法更新答案。扔进去以后，因为我们本来就可以凑出k-a[j]+1,k-a[j]+2,...k，那么把这些值全部加上a[j]，就得到k+1,k+2...k+a[j]。解释完毕。

另：由于f[i]只与f[i-1]有关，这一维可以完全滚掉。

我们要找到的，就是最小的p使得f[p]≥x。

而更新f[i]，需要一个满足a[j]≤f[i-1]+1的最大a[j]。

所以……这不就是个贪心么……直接排序，逆序查找，找到第一个满足条件的a[j]即可更新答案。

代码难度不高，留给大家自己编写。

最后注意细节（又是细节！）：如果a里面压根没有1，直接输出-1。否则，dp（或者叫贪心）会进入无限循环。
