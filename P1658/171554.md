假设 ， 我们现在已经可以组合出0-m块钱的任意数值，如果我们加上一个小于等于m+1数值的硬币a[i]，那么对于之前可以凑出的任意数值我们都可以加上这枚硬币a[i],那么我们可以凑出的数值就变成了0-m+a[i]。

至于为什么是小于等于m+1，如果我们的新取硬币是大于m+1的，那么哪怕是加上最小的0，值也是大于m+1，所以我们能够凑出的连续区间仍然是1-m。

综上，因为加上一枚小于等于m+1的新硬币，那么在满足小于等于m+1这个条件的同时越大越好（因为区间会变成0-m+a[i]）。

正确性是显而易见的，因为我们做出的任意一个决策都是只会影响下一个的m，让m尽可能的大，m大会间接影响a[i]变大，而我们也希望让a[i]尽可能大，那么可以证明这个策略是正确。


```cpp
#include <cstdio>
#include <algorithm>
using namespace std;
int a[15];
int main() {
	int x , n;
	scanf("%d %d" , &x , &n);
	for (int i = 1; i <= n; ++i) scanf("%d" , &a[i]);
	sort(a + 1 , a + 1 + n);//排序，方便我们选择最优决策
	int tot = 0 , ans = 0;//tot记录上述分析的m值，初始时我们只能凑出0-0的值，ans记录答案
	while(1) {
		if(tot >= x) {//如果我们能凑出的区间大于了目标区间，就返回
			printf("%d" , ans);
			return 0;
		}
		else ans ++;//否则继续贪心
		int f = 1;
		for (int i = n; i >= 1; --i) {//从大到小查询
			if(a[i] <= tot + 1) { // 如果满足条件，那么一定是最优的（因为从小到大找）
				tot += a[i];//更新区间
				f = 0;
				break;
			}
		}
		if(f) {//如果无法满足条件则不可能使tot值再增加
			printf("-1");
			return 0;
		}
	}
	return 0;
}
```