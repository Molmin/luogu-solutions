## **不用快速幂的普通算法（加高精）**
#### 首先说一下方法当n=1时 可得出ans=1
####  n   ans
#### | 1 | 1 |
#### | 2 | 3 |
#### | 3 | 7 |
####  ......
#### 观察可得出结论 f(n)=2*f(n-1)+1;于是有了下面的代码：
```cpp
#include <bits/stdc++.h>
using namespace std;			//以上必须存在不解释
int a[2][10000];		//本来重要思想 类似滚动数组
						//a[0]、a[1]就是上面的f(n)和f(n-1)
int main()
{
	int n;cin>>n;
	if(n==0){cout<<0;return 0;}//特判0,本代码唯一缺陷 是从1开始算的
	a[0][1]=1;a[0][0]=1;//附初值n=1时的值 a[0][0]和a[1][0]代表长度
	for(int i=2;i<=n;i++)//高精度
	{
		int k=i%2,j=1-k,x=0;
        //这里j和k是代表f(n)和f(n-1)在数组中的位置
        a[k][0]+=2;	//防止出现进不了位	
		for(int z=1;z<=a[k][0];z++)
		{
			a[j][z]=2*a[k][z]+x;
			x=a[j][z]/10;a[j][z]%=10;
		}
		a[j][1]++;a[j][0]+=2;//此处执行f(n)=2*f(n-1)+1;
		while(a[j][a[j][0]]==0)a[j][0]--;//减去前导0
	}
	int k=1-n%2;//找出答案数组
	if(a[k][1]>9)//防止个位+1后出现没进位情况，但目测好像没用
	{
		int x=0;
		for(int i=1;i<=a[k][0];i++)
		{
			a[k][i]=x+a[k][i];x=a[k][i]/10;a[k][i]%=10;
		}
	}
	for(int i=a[k][0];i>=1;i--)cout<<a[k][i];//输出
	return 0;
}
```
###### 本蒟蒻第一篇代码 求过