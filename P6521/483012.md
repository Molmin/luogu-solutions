二进制+容斥思想+哈希

题目完全等价转化于“有多少对字符串满足恰好 $4 - D$ 个对应位置的字符相同”可以继续转化成 “满足$4 - D$个对应位置的组数 $-$ 非恰好的组数”由此可以使用容斥的思想来解决此题。

$f(i)$表示恰好i个对应位置字符串相同的组数 ， $g(i)$表示i个对应位置相同的组数

便有 

$f(3) = g(3)$ 由于本题满足字符串不会相等

$f(2) = g(2)-\dbinom{3}{1}\times f(3)$

$f(1) = g(1)-\dbinom{3}{2}\times f(3) -\dbinom{2}{1}\times f(2)$

$f(0) = g(0)-f(1)-f(2)-f(3)$

接下来是我重点想说的，也就是实现。感觉其他几篇题解的实现过于复杂了些。
我们可以二进制来枚举所有情况(1表示选,0表示不选) ， 然后求出满足当前二进制的字符串的哈希值，最后用map求解出$g(i)$ 就可以了。
核心代码如下所示

```cpp
	rep (i , 1 , 16) t1[i] = t1[i >> 1] + (i & 1) ;
	rep (k , 0 , 15) {
		map <u64 , int> o ;
		LL cnt = 0 ;
		rep (i , 1 , n) {
			u64 id = 0 ;
			rep (j , 1 , 4) if (k & (1 << (j - 1))) id = id * 260 + ch[i][j] ;
			cnt += o[id] , ++o[id] ;
		}
		g[t1[k]] += cnt ;
	}
	
	f[3] = g[3] , f[2] = g[2] - f[3] * 3 ;
	f[1] = g[1] - f[2] * 2 - f[3] * 3 ;
	f[0] = g[0] - f[2] - f[3] - f[1] ;
```







