说说我是怎么想这道题的吧！

首先，我们要求 $a|b\not=a'|b$，我们先从$b$入手。我们考虑任意一位 $i$，如果 $b_i=1$，那么 $a_i,a_i'$ 的值就根本不会对 $c$ 造成影响。所以我们记录会对 $c$ 造成影响的位置，设 $p_i\ (i\in\{0,1\})$ 为二进制串中会对答案造成影响的位中有几个 $i$，即 $p_i=\sum_{j\in[0,n)}[a_j=i]\times [b_j=0]$。

紧接着，我们发现，只要满足 $a_i\not=a_j$ 并且 $b_i,b_j$ 中有任意一个等于 $0$，交换 $a_i,a_j$ 后都可以对答案造成影响。

看样子，我们还需要设 $t_i$ 表示二进制串中 $i$ 的总个数。

接下来进行一个**容斥**：（由于 $i,j$ 具有轮换对称性，所以统一设 $a_i=1,a_j=0$）

| $b_i$ | $b_j$ |                             说明                             |
| :---: | :---: | :----------------------------------------------------------: |
|  $0$  | $any$ | $b_i=0$ 的 $i$ 和任意一个 $j$ 交换，对答案的贡献为 $p_1\times t_0$ |
| $any$ |  $0$  | $b_j=1$ 的 $j$ 和任意一个 $i$ 交换，对答案的贡献为 $p_0\times t_1$ |
|  $0$  |  $0$  |        前面两条重复计算，所以贡献为 $-p_0\times p_1$         |

综上所述，最终答案为 $p_1\times t_0+p_0\times t_1-p_0\times p_1$。

最后，**记得开long long**！！！被坑了半个多小时！！！

**AC代码**：

```C++
#include<iostream>
using namespace std;
typedef long long ll;

ll t[2], p[2];
int main() {
    string a, b; int n; cin >> n >> a >> b;
    for (int i=0; i<n; i++) {
        t[a[i]-'0']++;
        if (b[i] == '0')
            p[a[i]-'0']++;
    }
    cout << t[0] * p[1] + t[1] * p[0] - p[0] * p[1];
    return 0;
}
```

一共 15 行，根本不用其他题解 40 50 60 行啦！史上最短代码了解一下~