首先，由于边权非负，所以能发现一个性质：最短路径走过的点一定只有点集的点。

先假设只有 $3$ 个点，设下标为 $s$ 的为起点，下标为 $e$ 的为终点，设另外一个点为 $x$，这样走过的全路程就是 $s-2x+x-2e+2c$，简化一下就是 $s-x-2e+2c$。

不难发现，对于非起点和终点的每一个点（设为 $x$ ），都要被别的点走到，就是 $-2a_x$，还要走到下一个点，就是 $+a_x$，所以最终可以简化成 $-a_x$。

然后对于起点，不会被其他点走到，所以只有 $+a_s$，对于终点，不会走到下一个点，所以只有 $-2a_e$。

其实可以先考虑把所有点的点权想象成 $-a_x$，然后再把起点 $+2a_s$，终点 $-a_e$。

为了让总路程最短，由于点集的和是固定的，所以只用考虑起点、终点，中间经过的点无所谓。要让总路程最短，由于起点是在增加路程，所以希望它增加的尽量少，那就要选最小值，由于终点是在减少路程，那就要选最大值。

但是别忘了还有个 $c$。由于有 $n-1$ 个边，那么最后就要加上 $(n-1)\times c$。

$\texttt{Code}$：

```cpp
while(q--){
	int s,sum=0,maxa=-1,mina=1000000000000000000;
	//定义变量
	cin>>s;
	for(int i=1;i<=s;i++){
		int x;
		cin>>x;
		if(mina>a[x]){
			mina=a[x];
		}//找最小值
		if(maxa<a[x]){
			maxa=a[x];
		}//找最大值
		sum+=a[x];//统计总和
	}
	cout<<c*(s-1)-sum-maxa+2*mina<<endl;
	//先把所有都看成-1，就相当于-sum
	//再把最大值减去，就相当于-maxa
	//再把最小值加上，就相当于+2*mina
	//还别忘了c!
} 
```