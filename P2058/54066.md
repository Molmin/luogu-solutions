蒟蒻一看，啊，**大模拟**！

乍一眼看上去，我束手无策

但是我仔细的看看：

船入港的时间是**单调递增**的

而我们可以把这艘船入港的时间和他之前的86400秒看做

**一个窗口**，那么不在这个窗口里的船就会被我们忽略

而这个窗口随船的入港而**滑动**

这不就是——**滑动窗口问题**吗？

用到的数据结构——**单调队列**

不会单调队列？（~~其实也没关系的~~）

戳这里：[我写的单调队列](https://www.luogu.org/blog/ybwowen/dan-diao-dui-lie)

这里的单调队列其实只是用来判断是否超过了区间

仔细想想，其实说他是**双端队列**或许更合适

剩下来的就是一些模拟的细节了：

按照题目的意思，我本来想去保存每艘船

但仔细想想，对于每艘船上的每个人，都要去保存国籍

这样对于**每艘船**，我们都要进行船上**人的国籍的插入和删除**

而一旦**离开区间**，对船上所有人进行删除

相当于**整体地删除**，有$O(k_i)$的时间复杂度

操作起来十分麻烦

所以这里我们存**人**而不是船

对于每个人，都有他的国籍和乘的船

而为了方便我们操作，我们记录船到港的时间

```
struct Node{
    int t;//乘客所乘坐船的到岗时间
    int x;//国籍
    Node(int a,int b){//构造函数
        t=a,x=b;
    }
};
```
新乘客进来之前，如果他之前的乘客**离开**了当前船只的区

间，那么我们就把离开区间的人**出队**，之后该乘客**入队**

剩下就是对国籍的操作了

当某一名乘客进队时，如果该国籍的人在之前没有，那么

增加一个国籍，将该国籍的人数增加

当某一名乘客出队时，先把这个国籍的人数减1，如果这个

国籍没人了，那么总数减少

### 代码：

```
#include<bits/stdc++.h>
using namespace std;
int n;
int v[100005];
int ans;
struct Node{
    int t;
    int x;
    Node(int a,int b){
        t=a,x=b;
    }
};
deque<Node>q;//双端队列
int main(){
    scanf("%d",&n);
    for(int i=1;i<=n;i++){
        int t,k,x;
        scanf("%d%d",&t,&k);
        for(int j=1;j<=k;j++){
            scanf("%d",&x);
            if(!v[x]) ans++;//新增国籍
            v[x]++;//该国籍人数增加
            q.push_back(Node(t,x));//入队
        }
        while(t-q.front().t>=86400){//离开区间
            v[q.front().x]--;//该国籍人数减少
            if(!v[q.front().x]) ans--;//这个国籍没人了，总数减少
            q.pop_front();//出队
        }
        printf("%d\n",ans);
    }
    return 0;
}
```

如有不足请指正，谢谢