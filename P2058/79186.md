## <1>思路
    由于到港是按时间先后顺序的，这样我们可以用一个队列 q[]来存放进港的每个人的信息（进港时间，所属国家），同时还要用一个标记数组 flag[]来标记到当前为止的 24 小时内
	到达港口的每个国籍的人数，用 ans 来记录 24 小时内到港人中的不同国籍数。这样，每当
	一艘船到港时：
	(1) 读入当前进港的时间信息。
	(2) 不断检查队首的人到港的时间是否已经超过 24 小时，超过 24 小时则出队列，同时从标记数组中减少该国籍人数 1 名，若该国家人数变为 0，则答案（即国籍数）减少 1。 即有：
```cpp
while(队列不空 且 队头所指人到港时间超过 24 小时)
{
    该国籍人数减少 1 人;
    该国籍人数为 0，则 ans--;
    移动队首指针后移 head++;
}
```
	(3) 当前进港的每个人进队列，若该国籍人数为 0，则答案 ans++，标记数组增加该国籍人数 1 名，即有：
```cpp
while(当前还有人要进港)
{
    该国籍人数为 0，则 ans++;
    该国籍人数增加 1 人;
    该人员信息进入队列，且队尾指针后移 tail++;
}
```
	(4) 每处理完一次到港信息，则输出 ans，表示当前 24 内到港人员的国籍数。
## <2>Code

```cpp
#include <bits/stdc++.h>
using namespace std;
int q[100005];
struct Node
{
	int t,p,*p2;
} a[100005];
int main()
{
	int ans=0,n,l=0,r=0;
	cin>>n;
	for(int i=0; i<n; i++)
	{
		r=i;
		cin>>a[i].t>>a[i].p;
		a[i].p2= new int[a[i].p];
		for(int j=0; j<a[i].p; j++)
		{
			cin>>a[i].p2[j];
			q[a[i].p2[j]]++;
			if(q[a[i].p2[j]]==1)
				ans++;
		}
		if(a[r].t-a[l].t>=86400)
			while(a[r].t-a[l].t>=86400)
			{
				for(int j=0; j<a[l].p; j++)
				{
					q[a[l].p2[j]]--;
					if(q[a[l].p2[j]]==0)
						ans--;
				}
				l++;
			}
		cout<<ans<<endl;
	}
}
```
