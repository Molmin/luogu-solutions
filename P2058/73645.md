听说这题很烦，来做做

一遍AC。。。

这个题目就是CF里的 ```two-pointer```，用 $ j $ 表示当前输入&处理哪艘船（我是在线的233），$ i $ 表示满足 $ t_j - t_i < 86400 $ 的最小的 $ i $。所以就是类似队列的做法。

具体来说，用一个 $ b $ 数组，当前国籍为 $ i $ 的人人数为 $ b_i $。每读入一艘船，先把这艘船上的人数加到 $ b $ 数组里（如果有新人种 ```ans++```），然后用 ```while``` 循环把 $ i $ 更新，每次 ```i++``` 时先把第 $ i $ 艘船的人从 $ b $ 数组里减去（如果一个人种消失 ```ans--```），然后输出答案完事。

因为总人数很少，所以我把所有的人都放到 $ x $ 数组里了。代码里面的 $ f $ 和 $ e $ 就是用来记录从哪里开始删人（即第 $ i $ 艘船的人开始位置）和从哪里开始加人（即第 $ j $ 艘船的人结束位置）。

奉上代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int t[100001],k[100001],x[300001],b[100001];
int main()
{
	int n;
	scanf("%d",&n);
	int f=1,e=0,ans=0;
	for(int i=1,j=1;j<=n;j++)
	{
		scanf("%d %d",&t[j],&k[j]);
		for(int _k=1;_k<=k[j];_k++)
		{
			scanf("%d",&x[++e]);
			if(!b[x[e]])
				ans++;
			b[x[e]]++;
		}
		while(t[j]-t[i]>=86400)
		{
			for(int _k=1;_k<=k[i];_k++)
			{
				if(b[x[f]]==1)
					ans--;
				b[x[f++]]--;
			}
			i++;
		}
		printf("%d\n",ans);
	}
	return 0;
}
```