这题的关键就在于**如何用最小的操作次数摧毁所有的回文子串**。

我们可以先手玩几个例子（这里的例子都只有一个对称中心）：

- `abcdcba`

这时很容易得出，如果把其中一个 `c` 改为 `e`，那么这个字符串就不存在回文子串。

- `abccba`

这种情况也一样，把其中一个 `c` 改为 `e` 即可。

我们暂时就可以得到一个策略：
- 若回文串长度为奇数，修改对称中心位置左右的两个字符**之一**。
- 若回文串长度为偶数，修改离对称轴最近的两个字符**之一**。

这个策略容易证明是正确的，因为字符串变为 `abcdeba` 后，原字符串的任意一个回文区间都会因为 `d` 左右两个字符不同而被摧毁。偶数情况同理。

--------

不过这个策略仍不尽完善，我们仍需考虑修改的字符问题。

如 `bcbeb`，如果我们将第二个 `b` 改为 `c`，那么区间 $[2,3]$ 又构成了回文串，我们也白忙活了。

所以修改字符的时候，一定要选择一个不会生成回文串的字符才能修改。

看看我们曾经的结论：

- 若回文串长度为奇数，修改对称中心位置左右的两个字符**之一**。

这个修改的直接目的是使得**对称中心左右的两个字符不同**。

同样对于长度偶数的情况，修改的目的是使得**离对称轴最近的两个字符不同**。

因此我们在修改位置为 $i$ 的字符的时候，应该保证它修改后的字符与位置 $i\pm 1,i\pm 2$ 的字符都不相同，才可以修改下去（边界情况特殊考虑）。

代码如下：

```cpp
#include <bits/stdc++.h>
using namespace std;
 
int t, n, ans;
char s[100010];
 
int main(){
 
	cin >> t;
	while(t--){
		scanf("%s", s + 1), n = strlen(s + 1);
		ans = 0;
		s[n + 1] = s[n + 2] = 'A';		// 处理边界
		for(int i = 2; i <= n; i++){
			if(s[i] == s[i - 1] && i > 1){	// 存在长度为偶数的字符串
				for(char j = 'a'; j <= 'z'; j++)
					if(j != s[i + 1] && j != s[i - 1] && j != s[i - 2] && j != s[i + 2]){
                     			 // 保证修改不会对以后操作造成负担
						s[i] = j;
						break;
					}
				ans++;
			}
			if(s[i] == s[i - 2] && i > 2){	// 存在长度为奇数的字符串
				for(char j = 'a'; j <= 'z'; j++)
					if(j != s[i] && j != s[i - 1] && j != s[i + 1] && j != s[i + 2]){
						s[i] = j;
						break;
					}
				ans++;
			}
		}
		cout << ans << endl;
	}
 
	return 0;
}
```