
## 前言
###### 看到了一道~~很水的题~~ ，而且可以做题解，就立刻做了题解。

## 正解

首先，我们要知道，什么是回文串。

>百度解释： 
>
>“回文串”是一个正读和反读都一样的字符串，比如 `level` 或者 `noon` 等等就是回文串。

我们举个栗子：`aba` 是一个回文串，`abcdefghihgfedcba` 是一个回文串。

那么，根据题目意思，就是让一个字符串里没有回文串。比如：`abcdcba` 里有一个回文字串。我们要改的话，不能瞎改。  
就像 `ebcdcba` 这样，改了跟没改一样，他还是有回文串 `bcdcb`。改的话要这样 `abedcba`。

这样的话，我们发现一个规律，只要改动里面的长度为 2 或 3 回文串，就行了！

字符长度为 $2$ 的回文串：`aa` $\to$ `ab`。

字符长度为 $3$ 的回文串：`aba` $\to$ `cba`。

怎么实现？
枚举每一个字符，然后看后面一个或两个的字符且看这个字符是否解决，判断是否相同：

如果相同，那么修改次数加一，不相同的话，就不用理他。
代码如下
```cpp
for(int j=0;j<len-1;j++)
{ 
	if(s[j]==s[j+1]&&tmp[j]==1)//如果相邻两字符相同（回文）
	{  
		tmp[j+1]=0; //判第二个数修改（表示已解决） 
		ans++; //修改次数++ 
	}
	if(s[j]==s[j+2]&&tmp[j]==1)//如果中间隔一字符（如ABA、EYE）
	{  
		tmp[j+2]=0; //判最后的数修改
		ans++; //修改次数++ 
	}
}
```
这样就可以了（**记得每次初始化哦**）。
## AC代码




```cpp
#include<bits/stdc++.h> //不要抄题解哦 
using namespace std;
int n,ans,len;
char s[100010];
bool tmp[100010];
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		memset(s,0,sizeof s); //重置字符串 
		scanf("%s",s);
		len=strlen(s); //获取该字符串的长度 
		memset(tmp,1,sizeof tmp); //重置判重数组 
		ans=0; //重置修改次数 
		for(int j=0;j<len-1;j++)
		{ 
			if(s[j]==s[j+1]&&tmp[j]==1)//如果相邻两字符相同（回文）
			{  
				tmp[j+1]=0; //判第二个数修改（表示已解决） 
				ans++; //修改次数++ 
			}
			if(s[j]==s[j+2]&&tmp[j]==1)//如果中间隔一字符（如ABA、EYE）
			{  
				tmp[j+2]=0; //判最后的数修改
				ans++; //修改次数++ 
			}
		}
		printf("%d\n",ans); 
	}
}
```

有什么疑问评论哦，谢谢。

求求给孩子点个**赞**吧！！！！