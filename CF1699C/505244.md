[长文~~真心~~建议前往 blog 使用](https://by505244.github.io/oi_blogs/2022/07/07/CF1699C题解)

### 题意

你现在有一个序列 $a_1,a_2\ldots a_n$，每个序列的值均为 $0$ 到 $n-1$（不重不漏）。
我们要找到一共有多少个序列 $b_1,b_2\ldots b_n$ （$b$ 序列数值范围与 $a$ 一致）与 $a$ 序列相似。

相似的定义：

令 $\text{MEX}$ 为其中没有出现过的最小非负整数（如 $\text{MEX}([1,2,3,4,5]=0,\text{MEX}([0,1,2,4,5])=3)$），则对于任意一个 $l,r(1\le l\le r\le n)$ 满足：

$$\text{MEX}([{a_l,a_{l+1}\cdots,a_r}])=\text{MEX}([b_l,b_{l+1}\cdots,b_r]) $$

则称 $a$ 与 $b$ 相似。

对答案进行 $10^9+7$ 取模。

### 思路

题目说白了就是求将 $a$ 交换一定个数使得交换后与交换前的序列相似（因为数字都一样）。

设 $path_x$ 为 $x$ 在 $a_i$ 数组中的位置。

（如 $a=\{1,3,2\}$，$path_1=1,path_2=3,path_3=2$）

令 $lp=\min_{i=0}^{x-1}path_i,rp=\max_{i=0}^{x-1}path_i$ 

若
$$
1\le l\le lp\le path_2\le rp\le r\le n
$$
因为 $l$ 到 $r$ 经过 $0$ 到 $x$ （前面的定义和假设！），所以：
$$
\text{MEX}([a_l,a_{l+1}\cdots,a_r])\ge x+1
$$
~~然后就没了~~

---

特别的，若 $l>lp$ 或 $r<rp$，则因为 $l$ 到 $r$ 这条线段一定未覆盖到 $0$ 到 $x-1$ 中其中一个数 （因为 $lp,rp$ 定义摆在那），所以 $\text{MEX}([a_l,a_{l+1}\cdots a_r])\le x$，导致 $x$ 的位置可以自由移动而不影响 $\text{MEX}$ 的取值（当然是在 $l>lp$ 或 $r<rp$ 的情况下的）。所以我们重点讨论 $1\le l\le lp\le rp\le r\le n$ 的情况。即接下来 $l$ 与 $r$ 的范围无特殊说明，默认是 $1\le l\le lq\le rq\le r\le n$。

---

设 $path_x$ 移动后的所到达的位置为 $p$。（$path_x$ 为移动前的位置）

##### 当 $lp\le path_x\le rp$ 时：

~~这种应该是要放在中间讲的，但作为关键步骤提前了。~~

结合上开头的讨论。可以推导出如果 $lp\le p\le rp$，那么移动后的序列一定与移动前的序列相似。

反之，$p<lp$ 或 $p>rp$，交换后的 $\text{MEX}([a_{lp},a_{lp+1}\cdots a_{rp}])$ 一定不等于交换前的。

因为 $lp$ 到 $rp$ 覆盖到了 $0$ 到 $x-1$，$x$ 移走了一定会使得 $\text{MEX}$ 值变为 $x$，而原来开头给出的结论移走前 $\text{MEX}([a_{lp},a_{lp+1}\cdots a_{rp}])\ge x+1$ 不符。

所以对于每个在 $lp$ 到 $rp$ 之间的数一共有 $rp-lp+1-x$ 种交换方案，因为在 $lp$ 到 $rp$ 之间已经有 $x$ 个其他数了，而这些其他数也占了一个空间，所以减去。

所以答案再乘 $rp-lp+1-x$ 就结束啦！

##### 当 $path_x<lp$ 时：

任何向左向右的移动都是不被允许的，因为那样会改变 $\text{MEX}$ 的取值。

则 $\text{MEX}([path_x,path_x+1\cdots n])$ 会在 $p<path_x$ 时改变。（即左移，$x$ 左移走了最小非负整数自然也就减少了）

 $\text{MEX}([path_x+1,path_x+2\cdots n])$ 会在 $p>path_x$ 时改变。（即右移，原来里面没有 $x$，移进来了，~~就有了 x~~，再加上里面本来就有 $0$ 到 $x-1$，最小非负整数就增加了）

如表 两行分别代表左移和右移，其中 $x=2$。~~表仅作结合上文理解，由于篇幅所限（更多是懒）不再详细解释。~~

|      状态      |      |      |      |      |      |      | $\text{MEX}([path_x,path_x+1\cdots n])$ | $\text{MEX}([path_x+1,path_x+2\cdots n])$ |
| :------------: | :--: | :--: | :--: | :--: | :--: | :--: | :-------------------------------------: | :---------------------------------------: |
|      先前      | $5$  | $2$  | $3$  | $1$  | $0$  | $4$  |                   $4$                   |                    $2$                    |
| 移动后（左移） | $2$  | $5$  | $3$  | $1$  | $0$  | $4$  |                   $2$                   |                    $2$                    |
| 移动后（右移） | $5$  | $4$  | $3$  | $1$  | $0$  | $2$  |                   $4$                   |                    $4$                    |



##### 当 $path_x>rp$ 时：

类似于 $path_x<lp$，任何向左移右移都是不被允许的。~~（跟上面推导过程很像应该不用写了吧）~~

### 代码

~~简洁明了，与前面格格不入~~

```cpp
#define DEBUG puts("sto shs orz")//突然发现这挺对称（不是 
const int mod = 1e9+7;
void solve(){
	int n;
	read(n);
	for(int i=1;i<=n;i++){
		int x;
		read(x);
		past[x]=i;
	}
	ll ans=1;
	int l=0x7fffffff,r=-1;
	for(int i=0;i<n;i++){
		if(past[i]>l&past[i]<r)ans=ans*(r-l+1-i)%mod;
		l=min(l,past[i]),r=max(r,past[i]);
	}
	printf("%lld\n",ans);
}
```

$\text{finish}$