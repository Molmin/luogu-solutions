## 这一道题目我用的是一种很简单明了的方法~~（其实是因为其他大佬的看不懂）~~
### 主要是用了c++对于字符串来说十分神奇的+号来通过加0来对齐个位（方便计算），同时要用循环加上一个开关来看是否需要进行退位，还有，如果a<b，可以先输出减号然后交换a和b来计算，剩下的就比较简单了，看一下代码的注释就可以了。
奉上代码（应该都看的懂吧）
```cpp
#include<bits/stdc++.h>
using namespace std;
string a,b;//需要用字符串来储存
int l,l1,c[10005],p;//每一位的差
int main()
{
	cin>>a>>b;
	a='0'+a;
	b='0'+b;//将第0位占0
	if(a.size()<b.size()||(a.size()==b.size()&&a<b))//假如a<b
	{
		cout<<'-';//结果为负数，先输出减号
		swap(a,b);//交换两个数（例如3-5可以变为0-（5-3）），这样子方便后面计算
	}
	l=a.size();
	l1=b.size();
	while(l1<l)//因为已经确保这时b<a了，所以直接在b前面添0
	{
		b='0'+b;
		l1++;
	}//利用c++的特性让个位对齐
	for(int i=1;i<l;i++)c[i]=a[i]-b[i];//计算差
	while(1)//用来退位，因为可能要多次退位，所以用while循环
	{
	p=1;//开关，用来看是否需要退位
	for(int i=1;i<l;i++)
	{
		if(c[i]<0)//需要退位
		{
			c[i-1]--;//向前一位退位
			c[i]=10+c[i];
			p=0;//开关置零，需要重新复查
		}
	}
	if(p)break;//不需要退位了，就退出
	}
	p=1;
	for(int i=1;i<l;i++)
	{
	if(c[i]!=0)p=0;
	if(p==0)cout<<c[i];//特判前导0
	}
	if(p==1)cout<<0;//特判，可能结果本身就为0
	return 0;
}
```