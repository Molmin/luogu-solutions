题目链接：https://www.luogu.com.cn/problem/P1692

这道题涉及到了图和深度优先搜索的知识，最主要的问题在于如何储存和判断两个人之间是否存在仇敌关系，还有如何进行搜索等。



------------
**一、图的储存**

我们以5个居民为例，则可以把每一个居民当做一个结点，如果两个人之间没有仇敌关系就用线连接起来，这样就形成了一个图，于是这个问题就转化成了从图中寻找最多的结点，且这些结点之间均有连线，即不是仇敌关系。

那么我们如何储存这样一个图呢？答案是：邻接矩阵。

**邻接矩阵**

邻接矩阵（Adjacency Matrix）是表示顶点之间相邻关系的矩阵。设G=(V,E)是一个图，其中V={v1,v2,…,vn} 。G的邻接矩阵是一个具有下列性质的n阶方阵：

①对无向图而言，邻接矩阵一定是对称的，而且主对角线一定为零（在此仅讨论无向简单图），副对角线不一定为0，有向图则不一定如此。

②在无向图中，任一顶点i的度为第i列（或第i行）所有非零元素的个数，在有向图中顶点i的出度为第i行所有非零元素的个数，而入度为第i列所有非零元素的个数。

③用邻接矩阵法表示图共需要n^2个空间，由于无向图的邻接矩阵一定具有对称关系，所以扣除对角线为零外，仅需要存储上三角形或下三角形的数据即可，因此仅需要n（n-1）/2个空间。

因此在这里可以定义一个二维数组作为一个进阶矩阵：a[301][301]（请大家注意一下数据的范围），其中a[u][v]表示第u个居民和第v个居民之间的关系，用1表示他们两个之间有仇敌关系，0反之。

此时我们有了一个框架来储存这个图，那么怎样使两个结点在邻接矩阵上相连呢？很简单，因为u对v有仇敌关系，反过来，v对u也有仇敌关系，所以：

```cpp
for(int i=1;i<=m;i++)
{
	cin>>u>>v;
	a[u][v]=a[v][u]=1;
} 
```

这样就可以把这个图储存下来了。

那么如何在搜索中判断或寻找这个图呢？我们在下文中讲。

------------
**二、搜索**

整个搜索过程有点像任意的排列，在任意的排列中每一种数字只有选或不选两种状态，在此题种，每一个居民也有选或不选两种状态，因此可以开一个bool数组x[301]来储存每一个居民被选的状态。

我们规定：

```cpp
const int N=301; 
bool x[N];   ///是否将第i个节点加入团中 
bool bestx[N];   ///记录最优解 
int bestn;   ///记录最优值 
int cn;  ///当前已放入团中的节点数量 
int deep;  ///当前搜索的深度 
```
此时一五个居民为例，我们来模拟一次搜索。

（1）、deep=1

**开始搜索第一层**。扩展A结点，首先判断是否满足条件，因为之前还没有选中任何结点，所以满足条件。扩展左分支，让x[1]=1，cn++，cn=1，生成B结点。


那么这个限制条件是什么呢？

1. 这个数没有被选中过，即x[j]！=1.
2. 查看这个人和其他居民的仇敌关系（详见代码）。

```cpp
bool place(int t)  ///判断是否可以把节点t加入团中 
{
	bool ok=true;
	for(int j=1;j<t;j++)  ///节点t与t-1个节点中被选中的节点是否相连 
	{
		if(x[j] && a[t][j]==1)  ///x[j]表示j是被选中的节点，a[t][j]==1 表示t和j是有仇敌关系   
		{
			ok=false;
			break;
		} 
	} 
	return ok;
} 

```
（2）、deep=2

**扩展B结点**。判断t号结点是否符合约束条件，满足条件，扩展左分支，令x[2]=1，cn++，cn=2，生成C结点。


（3）、deep=3

**扩展C结点**。判断t号结点是否符合约束条件，满足条件，扩展左分支，令x[3]=1，cn++，cn=3，生成D结点。


（4）、deep=4

**扩展D结点**。首先判断t号结点是否和前面已选中的结点（1、2、3号）有相连边，（假设）4号和2号没有相连边，不满足约束条件，不能向左扩展分支。判断限界条件cn+fn>bestn，cn=3，fn=n-1=1，bestn=0，满足限界条件，令x[4]=0，生成E结点。


（5）、deep=5

**扩展E结点**。首先判断t号结点是否和前面已选中的结点（1、2、3号）有相连边，（假设）5号和2号没有相连边，不满足约束条件，不能向左扩展分支。判断限界条件cn+fn>bestn，cn=3，fn=n-1=0，bestn=0，满足限界条件，令x[5]=0，生成F结点。


（6）、deep=6

**扩展F结点**。t>n，找到了一个当前的最优解，用bestx[]保存当前最优解为{1,1,1,0,0}，保存当前最优值bestn=cn=3，F结点为死结点。

（8）、deep=5

**向上回溯到E结点**。E结点的左右子树都已经查看了，继续向上回溯到D结点，D结点的左右子树也均已查看，继续回溯到C结点，cn--，cn=2,。因为C结点在生成D结点时，已经执行过cn++，此时应该再减回去。


（9）、deep=3

**重新扩展C结点**。C结点的右子树还没有生成过，根据限界条件cn+fn>bestn，cn=2，fn=n-t=2，beatn=3，向右扩展子树。令x[3]=0，生成G结点。


……

以此类推，一直拓展回到A结点为死结点，不能继续再产生新的子树，搜索结束。

到此，我们成功的模拟了一次dfs的过程，那么这个程序该怎么写呢?

有上述过程不难看出：如果t>n表示已经搜索到了叶子结点，那么记录最优值和最优解，return。否则判断是否满足约束条件（要和限界条件有所区分），如果满足，则拓展左子树，此时左子树上的节点表示能够进入卫队，所以令x[deep]=1，cn++，表示此时的人数增加1,然后dfs(deep+1)继续搜索左子树。当回溯时，cn--。

判断如果满足限界条件，则拓展右子树，此时该子树上的结点不能进入卫队，所以令x[deep]=0，人数不变，dfs(deep+1)继续搜索右子树。



------------
**完整程序**

```cpp
#include<iostream>
#include<string.h>
using namespace std;
const int N=301;
int a[N][N];   ///图用邻接矩阵表示 
bool x[N];   ///是否将第i个节点加入团中 
bool bestx[N];   ///记录最优解 
int bestn;   ///记录最优值 
int cn;  ///当前已放入团中的节点数量 
int n,m;   ///n为图中节点数，m为图中边数 

bool place(int t)  ///判断是否可以把节点t加入团中 
{
	bool ok=true;
	for(int j=1;j<t;j++)  ///节点t与t-1个节点中被选中的节点是否相连 
	{
		if(x[j] && a[t][j]==1)  ///x[j]表示j是被选中的节点，a[t][j]==1 表示t和j是有仇敌关系   
		{
			ok=false;
			break;
		} 
	} 
	return ok;
} 

void dfs(int deep)
{
	if(deep>n)
	{///到达了叶子节点  
		for(int i=1;i<=n;i++)
			bestx[i]=x[i];
		bestn=cn;
		return;
	}
	if(place(deep))  ///满足条件则放入左子树，即把节点t放入团中  
	{
		x[deep]=1;
		cn++;
		dfs(deep+1);
		cn--;  ///回溯   
	} 
	if(cn+n-deep>bestn)  ///放入右子树 
	{
		x[deep]=0;
		dfs(deep+1);
	} 
}

int main()
{
	int u,v;  ///n就是节点数，m数边数  
	cin>>n>>m;
	memset(a,0,sizeof(a));///邻接矩阵里面的数据初始化为 0 
	for(int i=1;i<=m;i++)
	{
		cin>>u>>v;
		a[u][v]=a[v][u]=1;
	} 
	bestn=0;
	cn=0;
	dfs(1);
	cout<<bestn<<endl;
	for(int i=1;i<=n;i++)
		cout<<bestx[i]<<" ";
	return 0;
}
```


------------
**结语**

遇到与图紧密结合的题目是，应当在草稿纸上推演搜索过程，体会深度搜索与回溯的原因及过程，才能写出AC程序。

祝好！