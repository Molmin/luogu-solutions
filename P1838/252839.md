
当当当，看我潇洒的打表代码吧！

### 代码：

    #include<bits/stdc++.h> //万能文件头
    using namespace std;
    string st;    //定义字符串读入
    int t,x,y;    //这是用来转化行列的变量
    int a[5][5];  //棋盘
    int pd()      //最强打表判断函数
    {
        //注意：1表示此位置的棋子是小a的，2表示此位置的棋子是uim的
        if(a[1][1]==1&&a[1][2]==1&&a[1][3]==1)  //判断第一行小a是否胜
        	return 1;                           //是则返回1，代表小a胜
        if(a[1][1]==2&&a[1][2]==2&&a[1][3]==2)  //判断第一行uim是否胜
        	return 2;                           //是则返回2，代表小uim胜
        if(a[2][1]==1&&a[2][2]==1&&a[2][3]==1)  //判断第二行小a是否胜
        	return 1;                           //是则返回1，代表小a胜
        if(a[2][1]==2&&a[2][2]==2&&a[2][3]==2)  //判断第二行uim是否胜
        	return 2;                           //是则返回2，代表小uim胜
        if(a[3][1]==1&&a[3][2]==1&&a[3][3]==1)  //判断第三行小a是否胜
        	return 1;                           //是则返回1，代表小a胜
        if(a[3][1]==2&&a[3][2]==2&&a[3][3]==2)  //判断第三行uim是否胜
        	return 2;                           //是则返回2，代表小uim胜
        //判断行 
        if(a[1][1]==1&&a[2][1]==1&&a[3][1]==1)  //判断第一列小a是否胜
        	return 1;                           //是则返回1，代表小a胜
        if(a[1][1]==2&&a[2][1]==2&&a[3][1]==2)  //判断第一列uim是否胜
        	return 2;                           //是则返回2，代表uim胜
        if(a[1][2]==1&&a[2][2]==1&&a[3][2]==1)  //判断第二列小a是否胜
        	return 1;                           //是则返回1，代表小a胜
        if(a[1][2]==2&&a[2][2]==2&&a[3][2]==2)  //判断第二列uim是否胜
        	return 2;                           //是则返回2，代表uim胜
        if(a[1][3]==1&&a[2][3]==1&&a[3][3]==1)  //判断第三列小a是否胜
        	return 1;                           //是则返回1，代表小a胜
        if(a[1][3]==2&&a[2][3]==2&&a[3][3]==2)  //判断第三列uim是否胜
        	return 2;                           //是则返回2，代表uim胜
        //判断列
        if(a[1][1]==1&&a[2][2]==1&&a[3][3]==1)  //判断从左上到右下小a是否胜
        	return 1;                           //是则返回1，代表小a胜
        if(a[1][1]==2&&a[2][2]==2&&a[3][3]==2)  //判断从左上到右下uim是否胜
        	return 2;                           //是则返回2，代表uim胜
        if(a[1][3]==1&&a[2][2]==1&&a[3][1]==1)  //判断从右上到左下小a是否胜
        	return 1;                           //是则返回1，代表小a胜
        if(a[1][3]==2&&a[2][2]==2&&a[3][1]==2)  //判断从右上到左下uim是否胜
        	return 2;                           //是则返回2，代表uim胜
        //判断斜
        return 0;                               //没有则返回0，注意！！！不然会返回一个随机值，有可能是0或1，所以会WA
    }
    //打表判断函数
    int main()
    {
        cin>>st;  //输入字符串
        for(int i=0; i<st.size(); i++) //从0开始，扫描每一个放棋编号
        {
            t=int(st[i])-'0';     //转化为整型数，‘0’~'9'的ascll码为48~57，减去‘0’的ascll码48就得到了这个数字对应的整形数啦，更多ascll码值请看pascle
            x=t/3+(t%3!=0);       //这一句相当于x=t/3; if(t%3!=0)x++; 这里计算行，因为一行3个棋子，所以/3，然后还有多余的棋子也要占一行，所以+(t%3!=0)
            y=t%3;if(y==0)y=3;    //计算列，因为一行3个棋子，所以%3，但有刚好是3的倍数的编号，这时%3的值应为3而不为0，所以if(y==0)y=3;
            if(i%2==0)a[x][y]=1;  //判断如果这是i为偶数，代表这时轮到小a下，所以a[x][y]=1;代表第x行，第y列的棋是小a的
            else a[x][y]=2;       //否则代表这时轮到uim下，所以a[x][y]=2;代表第x行，第y列的棋是uim的
            if(pd()==1){cout<<"xiaoa wins.";return 0;}    //调用函数，判断小a胜，胜则输出xiaoa wins.然后终结程序
            if(pd()==2){cout<<"uim wins.";return 0;}      //调用函数，判断uim胜，胜则输出uim wins.然后终结程序
        }
        cout<<"drew.";  //如果程序能运行到现在，证明没有一个人胜，代表平局，输出drew.
        return 0;
    }
