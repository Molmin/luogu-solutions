**【分析】**
--------------
这一题数据量最多是9，可以考虑全部存下来。

建立一个二维数组维护下的棋，xiaoa的为1，uim的为2，没下过棋的都为0。

这样，只要在输入后枚举8种情况即可(横着3条，竖着3条，左斜右斜各1条)。

输入时，本蒟蒻考虑到每个数字都不超过10，也就是说最多只有1位，那我们就可以用字符变量来输入。一是可以避免int输入时会一连串直接输进来，后面不好分；二是更快。

判定时，我们通过棋盘一定有解可以知道，不可能存在两个人同时赢的情况，故此只要判定出一个人赢即可结束其他判定(if...else if...)。

那如何判定平局呢......

本蒟蒻把判定的结果用ans保存，其中ans初始化为0。

若上述8种情况中其中一种成立，则保存ans为下棋者(1为xiaoa，2为uim)。

那么，输出时只要判定ans是否为0即可判定是否平局了。

_________________

**【代码】**
--------------

本蒟蒻代码奉上

```cpp
#include<cstdio>
using namespace std;
int main(){
	int map[3][3]={0},ans=0;
	char c=getchar();
	for(int i=1;c!=EOF;i=(i==1)?2:1) map[(c-'1')/3][(c-'1')%3]=i,c=getchar();
	//当c还能输入时，将它转化为数字(c-'0')
    //假设数字为x，则应该存在map[(x-1)/3][(x-1)%3]
    //而x-1  =  c-'0'-1  =  c-('0'+1)  =  c-'1'
		 if(map[0][0]==map[0][1]&&map[0][1]==map[0][2]) ans=map[0][1];
	else if(map[1][0]==map[1][1]&&map[1][1]==map[1][2]) ans=map[1][1];
	else if(map[2][0]==map[2][1]&&map[2][1]==map[2][2]) ans=map[2][1];
	else if(map[0][0]==map[1][0]&&map[1][0]==map[2][0]) ans=map[1][0];
	else if(map[0][1]==map[1][1]&&map[1][1]==map[2][1]) ans=map[1][1];
	else if(map[0][2]==map[1][2]&&map[1][2]==map[2][2]) ans=map[1][2];
	else if(map[0][0]==map[1][1]&&map[1][1]==map[2][2]) ans=map[1][1];
	else if(map[0][2]==map[1][1]&&map[1][1]==map[2][0]) ans=map[1][1];
	printf(ans?((ans&1)?"xiaoa wins.":"uim wins."):"drew.");
	return 0;
}
```