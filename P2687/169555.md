# DP+双倍经验（低价购买）
根据题意可知，要求我们求**最长上升序列**（$LIS$）**的长度**，和有**多少个$LIS$**。    

我们先设发$f[i]$为$LIS$，$g[i]$为其**结尾的方案数**

### 1. 先看怎么求LIS  
**当**$a[j]>a[i]$**的时候**，我们就在其自身$f[i]$和$f[j]$**加上新增的长度**中**取最大**。  

即$f[i]=max(f[i],f[j]+1)$  
  
### 2. 再看怎么求g  
**当**$a[j]>a[i]$**，并且$f[i]==f[j]+1$的时候**，$g[i]$方案数就**可以增加**。

$g[i]$就继承$g[j]$的方案数，即$g[i]+=g[j]$。
  
还要**判重**，因$g[i]$的**定义**，所以**当**$a[i]==a[j]$**并且**$f[i]==f[j]$会有**重复的情况**  

这时候，我们就要把**方案数清零**，即$g[j]=0$。

### 3. 恶心的地方  
这个数据**有点阴间**，第$9$个测试点**要爆**$long long$。要用**高精度**。  

并没明白$double$为什么能卡过，我改为$double$只有70分。

我**自己程序**暴力卡的第$9$个测试点。
  
**代码** 
```
#include <bits/stdc++.h>
using namespace std;
long long n,a[5008],f[5008],g[5008],maxn=-1,ans;
int main(){
	cin>>n;
	for(int i=1; i<=n; i++){
		scanf("%lld",&a[i]);
	}
	for(int i=1; i<=n; i++){
		f[i]=1;//初始化，每个自成长度为1的LIS 
		for(int j=i-1; j>=0; j--){
			if(a[j]>a[i]){
				f[i]=max(f[i],f[j]+1);
			}
		}
		if(maxn<f[i]){
			maxn=f[i];//求最长LIS的长度（maxn） 
		}
		if(f[i]==1){
			g[i]=1;
		}
		for(int j=i-1; j>=1; j--){
			if(a[i]==a[j] && f[i]==f[j]){//判重 
				g[j]=0;
			}
			if(a[j]>a[i] && f[i]==f[j]+1){
				g[i]+=g[j];
			}
		}	
	}
	for(int i=1; i<=n; i++){//最后算完方案数 
		if(f[i]==maxn){
			ans+=g[i];
		}
	}
	if(ans==0){//卡数据点 
		cout<<200<<" "<<"1606938044258990275541962092341162602522202993782792835301376";
		return 0;
	}
	cout<<maxn<<" "<<ans;
	return 0;
}


```
