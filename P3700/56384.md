又是一道数论神题……

这种数学题，第一要耐心推结论，第二要动起手来化简式子

所以……

#### 开始愉快的推倒结论吧~

已知 f(a,b)=f(b,a) && b\*(f(a,a+b))=(a+b)\*f(a,b)

那么我们发现简单变换一下就是

**f(a,a+b)/f(a,b)=(a+b)/b**

也就是说 f(a,a+b)∝f(a,b)，我们发现可以令 b=a+b，比例式仍然成立

另外我们发现这个比值等于 a\*(a+b)/a\*b,，后边会很有用

那么我们就可以递推出来这个等式

**f(a,k\*a+b)∝f(a,b) k∈Z+**

此时我们考虑一下%运算的定义，若 a=Kx+b(k,b∈Z)，那么 a%K=b

又因为f(a,b)=f(b,a)，可以得到这个等式

**f(a,b)∝f(b,a%b)**

然后我们来看另外一个等式

**gcd(a,b)=gcd(b,a%b)**

所以这个f函数的变化情况和其实gcd函数完全一样，只是每一步都是成正比的传递，gcd是等式传递

所以我们发现这个花里胡哨的函数，其实是套了一个gcd函数在里面，刚才的推倒关键在将 k\*a+b b代换为 a%b,b的关系，从而让我们想到了gcd函数

另外，由刚才的比值定义可以得到这个东西

**f(a,b)/f(gcd(a,b),gcd(a,b))=a\*b/gcd(a,b)^2**

化简下就是(以下过程全部用(i,j)代指gcd(i,j)) 

**f(i,j)=f((i,j),(i,j))\*i\*j/(i,j)^2**

还记得我们求的是什么式子吗？

**Σ(1~k)Σ(1~k)f(i,j)**,好像是……反演？

由于猝不及防就是一口反演，我们这里会简（xiang）单（xi）的介绍一下什么是莫比乌斯反演，希望大家可以看懂

## 前置芝士：莫比乌斯反演

### 前置芝士的芝士：狄利克雷卷积X积性函数

所谓数论函数，是一类定义域在自然数上的函数,然后我们会把自然数映射到复数域去，但是OI中常用的数论函数都是**自然数**映射到**整数**上的函数

那么我们定义一种神奇的运算，称之为**Dirichlet卷积**

对于两个数论函数 f，g，我们对于每一个n,**枚举n的所有约数对**，分别计算f值和g值后**相乘再相加**，会得到一个值，记为F(n)那么通过这样的手段我们可以计算出所有的F()值，那么就称F是f和g进行狄利克雷卷积的结果，数学表达式大概是这个样子，(狄利克雷卷积的符号记做X)

**(fXg)(n)=Σ(d|n)f(d)\*g(n/d)**

下面我们来介绍另一些有趣的函数，它们被称之为**积性函数**，所谓积性函数，就是一个函数f满足下列性质

1.f(1)=1

**2.若(i,j)=1,则有f(i\*j)=f(i)\*f(j)**

下面是一些常用的积性函数

1.φ函数，φ(n)表示1~n中有多少数和i互质

2.μ函数，若n有多个相同的质因子，μ(n)=0，若n=1,μ(n)=1,若n有多个相异的质因子，μ(n)=(-1)^质因子个数

3.常函数 1(n)=1

4.id函数 id(n)=n

5.ε函数 ε(n)仅在n=1时为1，其他情况均为零，ε是X运算的单位元，也就是说，任意 fXε=f

### 下面是莫比乌斯反演
------------------------

所谓莫比乌斯反演呢，就是有这样一个公式

fX1=g<->μXg=f

但是这个公式在OI中的应用更主要体现在下面四个公式上，也就是说，如果你的反演十分的不**熟练**的话，可以用这4个公式来**替代**莫比乌斯反演公式(而且好多题基本套完就结束了，反演令人头大的地方是各种骚气的代数变换，例如交换Σ，例如偷换变量，反演难理解的主要原因就是换Σ，同时偷换变量意义)

**1.id=φX1**

**2.ε=μX1**

**3.φ=μXid**

**4.εX1=1**

好了，有了这四个公式辅以**适(sao)当(qi)**的代数变换我们就可以解决大部分的反演问题了

-------------------

### 开始推倒后边的式子吧~

题目让求的是

**Σ(1~k)Σ(1~k)f(i,j)**

套上我们之前的公式，会有

**Σ(1~k)Σ(1~k)i\*j\*f((i,j),(i,j))/(i,j)^2**

这里使用一个非常传统的技巧，叫**枚举gcd**，令gcd=d，统计有多少后边的式子对这个d值做出了贡献，那么我们发现，**令i=i/d，j=j/d**，原来的式子可以变形成这样

**Σ\[d](1~k) f(d,d)\*Σ(1~k/d)Σ(1~k/d)i\*j\*ε((i,j))**

 _(如果d是i\*d和j\*d的gcd，那么(i,j)必须等于1，否则gcd是d\*(i,j))_
 
 下面我们不要着急反演ε，为什么？因为现在就反演你就走远了，最后推出来的式子复杂度不对然后gg
 
 我们观察得到后边的式子，运算式是i\*j\*ε((i,j)),发现**交换i，j后式子的值是不变的**，因此，我们可以**只枚举一半(i,j)**，然后\*2，美中不足的是我们发现i=j的情况会被计算两次，因此我们要再减去i==j的情况，变化之后得到下面的式子，(这个是题最难想的变换，因为看到了ε之后立即反演会导致gg，所以我们要这样变换一下)
 
** Σ\[d](1~k)f(d,d)\*(2\*Σ\[i](1~k/d)Σ(1~i)i\*j\*ε((i,j))-Σ\[i](1~k/d)i^2\*ε(i))**

发现Σ(1~k/d)i^2\*ε(i)仅在i==1的时候有值，所以，可以换成1，再次小小的变换下就是

** Σ\[d](1~k)f(d,d)\*(2\*Σ\[i](1~k/d)i\*Σ(1~i)j\*ε((i,j))-1)**

此时我们反演ε，会得到

** Σ\[d](1~k)f(d,d)\*(2\*Σ\[i](1~k/d)i\*Σ(1~i)j\*Σ\[t](t|i&t|j)μ(t)-1)**

下面是另一步蛇皮操作，**交换Σ**，我们先枚举t,看有多少个j可以和μ(t)相乘发现对一个t，**令j/=t**，此时j在1~i/t里都可以满足原先枚举时的约束，所以就是变化出来这个式子

** Σ\[d](1~k)f(d,d)\*(2\*Σ\[i](1~k/d)i\*Σ\[t](t|i)μ(t)\*Σ(1~i/t)j-1)**

发现Σ(1~i/t)j是一个等差数列求和公式，可以快速求出值，让我们继续变换~

** Σ\[d](1~k)f(d,d)\*(2\*Σ\[i](1~k/d)i\*Σ\[t](t|i)μ(t)\*(i*(i/t+1))/2-1)**

我们发现i和那个/2都可以通过**乘法分配律**提出去，此时得到

** Σ\[d](1~k)f(d,d)\*(Σ\[i](1~k/d)i^2\*Σ\[t](t|i)μ(t)\*(i/t+1)-1)**

我们令i/t=id(i/t),1=1(i/t),此时得到

** Σ\[d](1~k)f(d,d)\*(Σ\[i](1~k/d)i^2\*(Σ\[t](t|i)μ(t)\*id(i/t)+Σ\[t](t|i)μ(t)\*1(i/t)))-1)**

我们发现这里好像有两个**标准狄利克雷卷积的形式**？‘

** Σ\[d](1~k)f(d,d)\*(Σ\[i](1~k/d)i^2\*((μXid)(i)+(μX1)(i))-1)**

此时自行回去看公式吧，这两个卷积都是可以化简的

** Σ\[d](1~k)f(d,d)\*(Σ\[i](1~k/d)i^2\*((φ(i)+ε(i))-1)**

发现ε(i)\*i^2仅在i=1的时候等于1，可以化简，变成一个1提出去和外面的-1消掉

** Σ\[d](1~k)f(d,d)\*Σ\[i](1~k/d)i^2\*φ(i)**

到此为止，数学竞赛生的工作完成了，现在让我们**正式回到OI**上来

----------------------

我们发现暴力的效率十分的差劲，所以我们考虑**交换Σ**，枚举k/d的值，那么我们发现，若k/d=p，那么满足条件的d是连续的，也就是说，**是一段区间**，
而我们发现，这段区间里p的值都是一样的，也就是说Σ\[i](1~k/d)i^2\*φ(i)这一坨的的值是个定值，因此我们查出f(d,d)区间和，再乘上这个值就好了

我们发现Σ\[i](1~k/d)i^2\*φ(i)，这个东西的值啊，非常的好求，算个前缀和就好了，但是我们查区间和的操作就会十分的辣手，第一我们根本不知道查那一段，这个后边会通过一些奇技淫巧解决，但是我们知道一个结论n/d的值种类是n^0.5级别的，也就是说，我们不管怎样都要查n^0.5次区间和

而修改操作，其实由最早推出的成比例结论，我们会发现，其实就是把f((a,b),(a,b))的值修改为 x/(a/(a,b))/(b/(a,b)) 这里我们千万别犯傻去求逆元，常数贼大不说，膜的还贼多，注意这是两个longlong整除，是可以除的！

此时我们需要的数据结构就十分明了了，我们发现我们需要资瓷**单点修改区间求和**，可能你会瞬间想到大家所热爱的**树状数组**，这样我们就会有logN的优秀复杂度……

## 醒醒！这个做法的复杂度是O(N+MlogN√N)!

树状数组的优秀复杂度是建立在只有M个修改/查询操作的基础上的，问题是，这道题有M个修改，却有M√N个查询……出题人把数据范围开到4\*1e6就是为了卡掉这个次优算法……

也就是说，既然操作都不平衡了，我们的复杂度也不应该平衡，一种修改为√N，查询O(1)的数据结构就可以很好的满足我们的要求

再具体来讲，我们暴力对f建一个前缀和，之后我们每次单点修改在前缀和上都相当于一个区间加，那么我们暴力的分块打标记即可。算法复杂度O(N+M√N)，但是其实还是有些吃不消的，注意卡常数吧，至于那个枚举k/d的奇技淫巧，我们还是见代码吧，对了，我们的枚举的小技巧可以也可以处理出对应的区间

上代码~(其实代码非常短)

```c
#include<cstdio>
#include<algorithm>
#include<cmath>
using namespace std;//unsigned long long 的常数较小…… 
typedef unsigned long long ll;const int N=4000010;ll mod=1e9+7;
inline ll gcd(ll a,ll b){if(a<b)swap(a,b);while(b){ll c=a%b;a=b;b=c;}return a;}
int n;int m;int bs;ll add[N];ll f[N];
inline void ih(){for(ll i=1;i<=n;i++){f[i]=(f[i-1]+(i*i)%mod)%mod;}}
inline ll fb(ll p){return (p)?p-(p-1)%bs:0;}//这里动态找出分块左端点 
inline ll sum(int l,int r){return (f[r]+add[fb(r)]+2LL*mod-f[l-1]-add[fb(l-1)])%mod;}
inline void setval(ll p,ll val)
{
    val=(val+mod-sum(p,p))%mod;
    for(;fb(p)==fb(p-1);p++){f[p]=(f[p]+val)%mod;}//先枚举左边的散点 
    for(;p+bs-1<=n;p+=bs){add[p]=(add[p]+val)%mod;}//中间的区间，枚举左端点 
    for(;p<=n;p++){f[p]=(f[p]+val)%mod;}//再枚举右边的散点 
}
bool book[N];int zhi[N];int cnt;ll phi[N];ll sump[N];
int main()
{
    scanf("%d%d",&m,&n);bs=sqrt(n);ih();phi[1]=1;
    for(int i=2;i<=n;i++)//欧拉筛phi 
    {
        if(!book[i]){zhi[++cnt]=i;phi[i]=i-1;}
        for(int j=1;j<=cnt&&i*zhi[j]<=n;j++)
        {
            book[i*zhi[j]]=true;
            if(i%zhi[j]==0){phi[i*zhi[j]]=phi[i]*zhi[j];break;}
            else {phi[i*zhi[j]]=phi[i]*phi[zhi[j]];}
        }
    }
    for(ll i=1;i<=n;i++){sump[i]=(sump[i-1]+phi[i]*((i*i)%mod))%mod;}//打表前缀和 
    for(int i=1;i<=m;i++)
    {
        ll a;ll b;ll x;int k;scanf("%lld%lld%lld%d",&a,&b,&x,&k);
        ll g=gcd(a,b);x/=(a/g)*(b/g);setval(g,x);int p=1;ll res=0;//这里就是那个枚举n/d的黑科技啦 
        for(int i=1;i<=k;i=p+1){p=k/(k/i);res=(res+sum(i,p)*sump[k/i])%mod;}
        printf("%llu\n",res); 
    }return 0;//拜拜程序~ 
}

```






















 
 














