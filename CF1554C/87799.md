注：请先学习异或相关知识。本题解若看不懂，建议看一下代码。

本题解的代码实现比其它题解更简单(未压行 $252B$)。(实际上借鉴了其它题解)

题意：求最小自然数 $ans$，对于 $0<=i<=m$ 的 $i$ 都满足 $ans≠n\kern{3pt}xor\kern{3pt}i$。(xor 为异或运算)

**将等式两边同时异或 $n$**，可以将 $ans≠n\kern{3pt}xor\kern{3pt}i$ 转换为  $ans\kern{3pt}xor\kern{3pt}n≠i$ 。

因为 $0<=i<=m$ 且所有数都是自然数，所以 $ans\kern{3pt}xor\kern{3pt}n>=m+1$。

那么现在想要找到 $ans$，需要把它们进行拆位，对于每一位，分开考虑。下表标注了当 $n$ 与 $m+1$ 在该二进制位为 $0/1$ 时 $ans$ 的取值。

|n|0|0|1|1|
| -----------: | -----------: | -----------: | -----------: | -----------: |
|$m+1$|$0$|$1$|$0$|$1$|
|$ans$|$0/1$|$1$|$0/1$|$0$|

由于想让 $ans$ 尽可能地小，所以当 $n=0,m+1=0$ 时 $ans=0$ 。

观察上表，只有当 $n=0,m+1=1$ 时，$ans=1$，其余情况下 $ans=0$。$3$ 种情况取 $0$，只有 $1$ 种情况取 $1$，使我们想到了与运算。又发现当 $n=0$，所以 $n$ 要反转。即最后的答案是 ```(~n)^(m+1)```。

但是,还有一种情况没考虑。

当 $n=1,m+1=0$ 时，由于 $n\kern{3pt}xor\kern{3pt}ans$ 在这一位已经大了，在后面无论 $ans$ 的二进制位如何都不会影响大于的性质了。所以**后面的所有位都取 0**。

这其实也简单，找到最大的一位满足上述条件。于是把 $m+1$ 取反后做与运算得到一个新数。再找这个新数的最大位即可。关于找最大位，这里直接暴力枚举。也可以直接使用 cmath 中的 ```log2``` 函数。

时间复杂度(单组数据)：$O(\log_{2}(n+m))$。
```cpp
#include<iostream>
using namespace std;
int fyr(int a){
	int ykb;
	for(ykb=1;ykb<=a;ykb<<=1){}
	return ~(ykb-1); //需要减1取反,因为是要丢弃后面的位,而不是保留,所以后面都将与上0然后被丢弃。
}
int main(){
	int t,i,n,m;
	cin>>t;
	for(i=0;i<t;i++){
		scanf("%d %d",&n,&m);
		cout<<((~n)&(m+1)&(fyr(n&~(m+1))))<<endl;
	}
	return 0;
}
```
其它优化：可以考虑用找最大位二分求解。做到单组数据复杂度  $O(\log_{2}^{2}(n+m))$。

但是这里没必要，因为 $n+m<=2\times 10^{9}$，$\log_{2}(n+m)=31$，$\log_{2}^{2}(n+m)=5$。二分查找常数大一些，其实优化作用较小，还增加了代码难度，在不需要卡常的时候完全没必要。