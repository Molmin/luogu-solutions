## 大意

给定一个字符串，可以任意改变字符顺序，花费一代价改变一个字符。在花费最少代价将字符串变成回文的前提下，使结果字典序最小。

## 思路

字符串顺序没有用，就可以使用一个桶记下来。让后分长度的奇偶性讨论：

---

### 偶数长度

因为要让代价最小，所以有偶数个的字符就不要管它了。对于有奇数个的字符，一定可以让它们（奇数次数的字符）配对，才能使得代价最小。

为了让字典序最小，应该尽量增加尽量小的字符的个数。最后答案的前半段就是字符从 `a` 到 `z` 每一种字符 `cnt[i]/2` 次，后一半就反过来。

### 奇数长度

大部分和上面同理，但是一定会剩下一种字符。这时我们希望所有这种字符比其他的字符都要大，且尽量小。我们可以让最大和最小配对，最后在中间剩下的那个就是多出来的。

答案中间要加那个字符。

---

其实两种情况在代码上就是一种情况里面特判。

## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,T,cnt[30],l=1,r=26,ccnt;
char ch[200005],ans[200005];
int main(){
	cin>>ch+1;
	n=strlen(ch+1);
	for(int i=1;i<=n;i++) cnt[ch[i]-'a'+1]++;
	while(l<r){
		while(cnt[l]%2==0&&l<26) l++;
		while(cnt[r]%2==0&&r>1) r--;
		if(l>=r) break;
		cnt[l]++;
		cnt[r]--;
	}
	char ch=' ';
	for(int i=1;i<=26;i++){
		for(int j=1;j*2<=cnt[i];j++) ans[++ccnt]=char(i+'a'-1),ans[n-ccnt+1]=char(i+'a'-1);
		if(cnt[i]&1) ans[n/2+1]=char(i+'a'-1);
	}
	cout<<ans+1;
	return 0;
}
```

听说题解里要 $ \LaTeX $ 。