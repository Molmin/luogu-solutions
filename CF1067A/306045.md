大佬们的题解都~~太深奥了，~~直接把转移方程放出来让其他大佬们感性理解，蒟蒻们很难理解，所以我就写了一篇让像我一样的蒟蒻能看懂的题解

------------
[更好的阅读体验](https://www.cnblogs.com/Keven-He/p/TJ-CF1067A.html)

[原题传送门](https://www.luogu.com.cn/problem/CF1067A)

> 动态规划三部曲：确定状态，转移方程，初始状态和答案。
> 
> ——神仙 @[akicc](https://www.luogu.com.cn/user/333773)

# 第一步 确定状态
$f_{i,j,k}(k\in\{0,1,2\})$表示第 $i$ 个数选为 $j$ 且和前一个数是小于/等于/大于（$k=0$ 是大于，$k=1$ 是等于，$k=2$ 是小于）的关系时的方案数。
# 第二步 转移方程
把三种关系分开讨论：
- $k=0$，比上一个大，它的方案数就是上一个数选的比它小的数的方案数和；
- $k=1$，由于和上一个数相同，它的方案数就是上一个数的方案数和；
- $k=2$，比上一个小，它的方案数就是上一个数选的比它大的数的方案数和，但是为了防止上一个数比相邻的数都大，我们要去掉上一个数比上上个数大的方案数。

那么我们的转移方程就是：

$f_{i,j,0}=\sum^{j-1}_{l=1}f_{i-1,l,0}+f_{i-1,l,1}+f_{i-1,l,2}$

$f_{i,j,1}=f_{i-1,j,0}+f_{i-1,j,1}+f_{i-1,j,2}$

$f_{i,j,2}=\sum^{200}_{l=j+1}f_{i-1,l,1}+f_{i-1,l,2}$

如果 $a_i=-1$ 则 $1\le j\le 200$，否则 $j=a_i$	。

直接求和会超时，我们可以使用前缀和优化。
# 第三步 初始状态和答案
如果第二个数取得比第一个数小就不符合题目要求了，而第一个数只有一种取法，所以我们让 $f_{1,j,0}=1$，就可以让 $f_{2,j,2}$ 取不到方案数了！

如果最后一个数比倒数第二个数大，也不符合题意，所以我们在取答案的时候不能取 $f_{n-1,j,0}$ 。

[可以不用滚动数组，但是空间不要开太大](https://www.luogu.com.cn/record/57151523)
# 代码
```cpp
#include <bits/stdc++.h>
#define _for(i,a,b) for(int i=a;i<=b;++i)
#define for_(i,a,b) for(int i=a;i>=b;--i)
#define ll long long
using namespace std;
const int N=1e5+10,M=998244353;
ll n,a[N],f[N][205][3],ans;
void pre(){
	if(a[1]==-1)_for(i,1,200)f[1][i][0]=1;
	else f[1][a[1]][0]=1;
}void dp(){
	_for(i,2,n){
		int s=0;
		_for(j,1,200){
			if(a[i]==-1||a[i]==j)f[i][j][0]=s%M,f[i][j][1]=(f[i-1][j][0]+f[i-1][j][1]+f[i-1][j][2])%M;
			s=(s+f[i-1][j][0]+f[i-1][j][1]+f[i-1][j][2])%M;
		}s=0;
		for_(j,200,1){
			if(a[i]==-1||a[i]==j)f[i][j][2]=s%M;
			s=(s+f[i-1][j][1]+f[i-1][j][2])%M;
		}
	}
}int main(){
	scanf("%lld",&n);
	_for(i,1,n)scanf("%lld",&a[i]);
	pre(),dp();
	_for(i,1,200)ans=(ans+f[n][i][1]+f[n][i][2])%M;
	printf("%lld",ans);
	//system("pause");
	return 0;
}
```