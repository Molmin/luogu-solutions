
感觉大佬们大多都没有讲得很清，这里提供一个较为严谨且好理解的方法。

首先阅读题面，发现是一个排列的交换问题。这是一种比较常见的题型了，看到这种题，一般都要想到：**环**！

**交换与环：** 假设当前有一个排列，排列为：$1,2,3...,n-1,n$。现在对这个环进行操作，每次选择两个数$(x,y)$，将它们交换，交换若干次后，会得到一个新的排列。对于$1$到$n$中的每个数$i$，假设最后$i$号点到达的位置是$p_i$，则从$i$到$p_i$连一条有向边。连完这些边发现，这形成了若干个环（包括自环）。

通过这些环，我们知道了，初始的点最终要到达哪个位置。

回到本题，发现本题加了一个限制，即：每个点的最多交换次数为$1$次或$2$次，还是从环入手，考虑每个点最多交换次数为$1$次或$2$次时，对于一个合法的交换操作，环需要满足的条件是什么？

为了方便讲述，这里将图中的$a_i=1$的点设为白点（球），$a_i=2$的点设为黑点（球），不交换的情况可以当成自己和自己交换，即：每个点的交换次数需使用完。

交换操作合法当且仅当**环需要满足的条件为：** 一个环中最多两个白点。

于是问题变成了：统计符合上述条件的方案数，这个方案数怎么求呢？我们还要寻找一些性质。

进一步推理可以发现：白球的交换是很受限制的，而黑球相对“自由得多”。如果一个白球$A$和一个白球$B$交换，白球$B$的最终位置就定了，不能再换到别的地方。而如果一个黑球被交换了一次，它还可以选择交换到其他的位置，再进一步，可以发现一个重要性质！

**性质：** 对于每一个黑球，最终都可以换到$n$个位置中的任意一个位置。

白球并不满足上述性质。

于是我们可以从黑球入手，先把它们最终到达的位置选完。选法方案数为：
$$
\frac{n!}{(n-cnt2)!}
$$

还记得要求什么吗？我们要求：满足一个环中最多两个白点的排列的操作方案数。

现在我们和环联系起来，黑点的去处是已知的，我们可以先把它们和它们的去处连好边，得到一个类似这样的图：

![](https://cdn.luogu.com.cn/upload/image_hosting/vbjb141w.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

得到的环无非是三种类型：

- 黑点成环
- 以白点结尾的链
- 单独的白点。

不管图长成什么样，可以确定的是：任意两个白点不在一个连通块中。我们现在要做什么呢？我们需要给每个白点分配一个去处（可以是自己，必须是含有白点的联通块），使其是一个合法的交换序列。

自己成环表示自己不与其它的点交换，两个连通块合并表示交换，对于两个给定的连通块，它们的合并有且只有一种方案，且合并后一定不会和第三个连通块合并（因为已经有两个白点了）。

这部分可以用$dp$解决。

$dp_i$表示给$i$个白点所在连通块分配去处的方案数，考虑第$i$个白点所在的连通块，有两种情况：

- 它自己成环，变成给$i-1$个白点所在连通块分配去处，$dp_i=dp_i+dp_{i-1}$
- 它找一个连通块成环，从$i-1$个含白点连通块中找一个与它匹配，再给$i-2$个白点所在连通块分配去处。$dp_i=dp_i+(i-1) \times dp_{i-2}$

这也就是其它题解中所说的那个线性递推，初始条件：$dp_0=1,dp_1=1$。

最终答案就是：$dp_{cnt1}\times \frac{n!}{(n-cnt2)!}$，问题得到完美解决！

```cpp

#include<bits/stdc++.h>
using namespace std;
#define int long long 
#define reg register
#define x1 x11
#define x2 x22
#define y1 y11
#define y2 y22
#define z1 z11
#define z2 z22
const int mod=1e9+7;
const int INF=2e16;
const int maxn=1e6+5;
const double Pi=acos(-1.0);
double Exp=1e-6;
inline int read()
{
	int x=0,f=1;
	char ch=getchar();
	while(ch<'0' || ch>'9')
	{
	    if(ch=='-')
	        f=-1;
	    ch=getchar();
	}
	while(ch>='0' && ch<='9')
	{
	    x=x*10+ch-'0';
	    ch=getchar();
	}
	return x*f;
}
int n;
int a[maxn];
int cnt1=0,cnt2=0,ans=1;
int dp[maxn];
signed main()
{
	n=read();
	for(int i=1;i<=n;i++)
	{
		a[i]=read();
		if(a[i]==1)
			cnt1++;
		else
			cnt2++;
	}
	dp[0]=1;
	dp[1]=1,dp[2]=2;
	for(int i=3;i<=n;i++)
		dp[i]=(dp[i-1]+dp[i-2]*(i-1))%mod;
	for(int i=1;i<=cnt2;i++)
		ans=ans*(n-i+1)%mod;
	ans=ans*dp[cnt1]%mod;
	printf("%lld\n",ans);
	return 0;
}

/*
8
2 0 2 0 2 2 0 0
*/
```
