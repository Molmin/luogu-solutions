# 0.前言

这道题目没有黄的难度，我觉得只算是一道红。

适合字符串练手，也不用什么奇奇怪怪的`insert`函数。

# 1.如何插入

因为要修改的位置是比较字符串后读入的，所以不能边输入边输出。

楼下的题解说：$4$ 个`insert`没问题啊？

但是把这道题加强一点：给你在原字符串里插入 $m$ 个引号，给出这些引号的位置。

$1\leq |S|\leq m\leq 10^6$，其中 $|S|$ 为输入字符串的长度。

没辙了吧。

我们考虑因为每次插入（字符串是顺序存储结构）是 $O(|S|)$ 的时间复杂度（假设都在字符串头插入一个引号），所以可以**边输出边加引号。**

每次输出一个字符时，**考虑这个字符后面是否有引号，有就给他输出。**

但是时间复杂度其实还是挺大，有 $m$ 个引号的话，这个复杂度还是 $O(|S|\times m)$ 的。

# 2.如何降低时间复杂度

上面提到了这种一个点判断一次的时间复杂度是 $O(|S|\times m)$ 的，和暴力`insert`（往后移位）的效率是一样的。

诶？突然发现插入引号的位置有个范围限制诶！

发现这 $m$ 个引号的位置**不可能**超过 $|S|$ ，因为超过 $|S|$ 就没处加了。

新建一个标记数组 $b$，$b_i$ 表示这个字符串的第 $i$ 位是否要加上引号。

于是我们一边输入引号的位置一边在这个 $b$ 数组上打标记。

然后一边输出一边判断这个上面是否有标记。

时间复杂度 $O(|S|+m)$ 。

# 3.一些细节

注意 $0$ 的情况（字符串头插入引号），然后注意标记数组的大小要**开得和字符串长度一样大**。

# 4.参考代码

```cpp

char s[110];int a,n;bool b[110];
int main()
{
	cin>>s+1;n=strlen(s)-1;
	Fu(i,1,4)cin>>a,b[a]=1;
	if(b[0]==1)putchar('\"');
	Fu(i,1,n)
	{
		putchar(s[i]);
		if(b[i])putchar('\"');
	}
	return 0;
}
//BY 线段树蒟蒻


```