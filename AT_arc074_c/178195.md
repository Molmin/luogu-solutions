题目要求方案数，很显然就是 $dp$。

都说动态规划最难的是设计状态和列方程，我建议大家还是先自己思考一下再来看解答。

红绿蓝三种颜色，我们先不管它们叫什么，姑且将它们命名为“一种颜色”“第二种颜色”“另外一种颜色”。

假设 $f[i][j][k]$ 表示的含义是：目前已经给 $i$ 号点涂色（涂了“一种颜色”），且“第二种颜色”“另外一种颜色”最后一次出现的格子编号分别为 $j,k$ 时的方案数量。

![截图20220805160133.png](https://yacs-public.oss-cn-hangzhou.aliyuncs.com/image/1659686520520.png)

为了方便表述，记 $col[i]$ 表示 $i$ 号格子的颜色。现在为了列出转移方程，想象自己站在当前的局面往后决策（可以借助上图帮助理解）：

+ 如果 $col[i+1]=col[i]$，也就是 $i+1$ 号格子与 $i$ 号格子颜色相同，那么这个时候，“第二种颜色”最后一次出现的位置就是 $j$，“另外一种颜色”最后一次出现的位置就是 $k$，所以此时的方程：$f[i+1][j][k]+=f[i][j][k]$。

+ 如果 $col[i+1]=col[j]$，那么此时“第二种颜色”最后一次出现的位置就是 $i$，“另外一种颜色”最后一次出现的位置就是 $k$，所以此时的方程：$f[i+1][i][k]+=f[i][j][k]$。

+ 如果 $col[i+1]=col[k]$，按照上面的思路，可以列出方程：$f[i+1][i][j]+=f[i][j][k]$。

推出了状态转移方程，不要忘记考虑题目里的限制 $(l,r,x)$。

当我们在决策 $i$ 号格子的时候，我们把所有右端点等于 $i$ 的区间找出来，去判断 $l,i,j,k$ 之间的大小关系，便可以知道那些状态时不合法的了，对于不合法的状态，我们就令这个状态对应的 $f$ 数组的值为 $0$，这样它对答案的贡献就为 $0$。

+ 当 $x=1$ 时，区间内只有一个颜色，$r=i$ 作为它的右端点，那么这个区间内其他所有格子的颜色都必须与 $i$ 相同，那么区间左端点 $l$ 的取值范围就是 $j<l\leq i$。

+ 当 $x=2$ 时，$r=i$ 作为它的右端点，那么这个区间内其他所有格子的颜色要么与 $i$ 相同，要么与 $j$ 相同，区间左端点 $l$ 的取值范围就是 $k<l\leq j$。

+ 当 $x=3$ 时，按照同样的逻辑，$l\leq k$。

反不满足以上条件的状态，我们就赋值为 $0$。

最后就是答案和边界。

【边界】 $f[1][0][0]=1$

【答案】
$$
3\times \sum_{j=0}^{n-1}\ \  \sum_{k=0}^{max(0,j-1)} f[n][j][k]
$$

这里容易发现两个问题：
1. 为什么最前面需要乘以 $3$？因为我们在最开始说了，不考虑颜色种类，我们只考虑了颜色的相对关系。因此，如果一个格子可以填“一种颜色”，那么它也一定可以填“第二种颜色”与“另外一种颜色”，只需要把其他的颜色修改掉就好了。所以总共有 $3$ 种可能，需要乘以 $3$。

2. 为什么 $k$ 的上界是 $max(0,j-1)$？$j-1$ 很好理解，就是因为 $k$ 必须在 $j$ 的左边。至于为什么还要和 $0$ 比较大小，是因为 $j$ 的下界是 $0$，$k$ 在它的左边，那 $k$ 只能是负数，就不对了。

至此，我们就完成了此题，下面是 AC 代码。

```cpp
#include<bits/stdc++.h>
using namespace std;

const int maxn=305;
const int mod=1000000007;

int n,m;
long long ans=0;
int f[maxn][maxn][maxn];
struct node{
	int l,x;
};
vector<node>a[maxn];

int main(){
	cin>>n>>m;
	for(int i=1;i<=m;i++){
		int l,r,x;
		cin>>l>>r>>x;
		a[r].push_back((node){l,x}); //以 r 作为一个关键字存储区间限制。 
	}
	f[1][0][0]=1;
	for(int i=1;i<=n;i++){
		for(int j=0;j<i;j++){
			for(int k=0;k<=max(0,j-1);k++){
				for(int t=0;t<a[i].size();t++){
					int l=a[i][t].l; //取出以 r 为右端点的所有区间 
					int x=a[i][t].x;
					if(x==1 && l<=j) f[i][j][k]=0;          //这里三行，就是把所有不合法的情况赋值为 0 
					if(x==2 && (l>j || l<=k)) f[i][j][k]=0;
					if(x==3 && l>k) f[i][j][k]=0;
				}
			}
		}
		for(int j=0;j<i;j++){ //计数 
			for(int k=0;k<=max(0,j-1);k++){
				f[i+1][j][k]=(f[i+1][j][k]+f[i][j][k])%mod; //col[i+1]==col[i]
				f[i+1][i][k]=(f[i+1][i][k]+f[i][j][k])%mod; //col[i+1]==col[j]
				f[i+1][i][j]=(f[i+1][i][j]+f[i][j][k])%mod; //col[i+1]==col[k]
			}
		}
	}
	for(int j=0;j<n;j++){
		for(int k=0;k<=max(0,j-1);k++){
			ans=(ans+f[n][j][k])%mod;  //累计答案。记得 ans 要开 long long。 
		}
	}
	cout<<(ans*3ll)%mod<<endl;
	return 0;
}
```
