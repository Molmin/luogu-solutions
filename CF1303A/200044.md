这一题很简单，考查的是基础的字符串操作，几分钟就可以水过去。

这题有一个显而易见的$O(n^2)$做法，对于字符串中的每一个0，向左右拓展，如果两边都有一个$1$，$ans++$即可。但如果数据稍微加强，$O(n^2)$就过不去了，只能$O(n)$求解。

仔细观察题目，首先$1$是不用删的，前导$0$和后导$0$也不用删，那么我们用字符串的长度减去$1$,前导$0$和后导$0$的个数就可以了。

注意，如果字符串只有$0$，就要标记前导$0$，这样计算后导$0$是就不会重复了。

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int T,ans;
string s;
int main() {
	cin>>T;
	while(T--) {
		cin>>s;
		ans=s.size();
		for(int i=0; i<s.size(); i++)if(s[i]=='1')ans--; //减去一的个数
		for(int i=0; i<s.size(); i++) {
			if(s[i]=='1')break; //遇到一就跳出循环 
			if(s[i]=='0'){
				ans--;//减去前导0 
				s[i]='1';//标记 
			}
		}
		for(int i=s.size()-1; i>=0; i--) {
			if(s[i]=='1')break;//遇到一就跳出循环 
			if(s[i]=='0')ans--;//减去后导0 
		}
		printf("%d\n",ans);//输出 
	}
}
```
