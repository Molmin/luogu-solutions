首先，我们来考虑一下翻转的情况：每次改变 $2$ 枚硬币的状态，所以当 $1$ 的数量是奇数的时候，是绝对不可行的。

这启发我们记录 $1$ 的数量，此处记为 $ans$。

在 $ans$ 为偶数时，注意到题目有个条件 $j-i\ge2$，这说明我们还要继续分类讨论：

在 $ans>2$ 时，我们可以这样分组：令 $t=\dfrac{ans}{2},(i,i+t)$ 为一组，这样每组的 $2$ 个之间肯定是不相邻的。

当 $ans=2$ 时，我们可以先找到 $1$ 的位置，如果这两个 $1$ 不是连续的，那么我们直接交换这两个元素；否则，我们继续分类讨论：

当 $n=2$ 时，显然不能做任意一步操作，此时答案为 `-1`；

当 $n=3$ 时，中间元素被被占用了，此时另一个元素无论怎样交换，都是和这个元素相邻的，所以答案仍然为 `-1`；

当 $n=4$ 时，如果两个中心被霸占了，那么我们把左边的交换到最右边，然后把右边的交换到最左边，这样就可以操作了，答案为 $3$；否则，我们把不在边上的哪一个交换到边上，然后就可以交换了（其实就是前面的情况操作 $1$ 步后的样子），答案为 $2$；

当 $n\ge5$ 时，此时我们可以直接把不在边上的元素交换到边上去，然后就可以交换了（其实跟 $n=4$ 的第 $2$ 种情况相类似），答案为 $2$。

这样就可以 AC 了，感觉讨论好复杂：

```cpp
#include<bits/stdc++.h>
using namespace std;
int T,len;
string s;
int main(){
	cin>>T;
	while(T--){
		cin>>len>>s;
		int ans=0;
		for(int i=0;i<len;++i)
			ans+=(s[i]=='1');
		if(ans&1)
			puts("-1");
		else if(ans==2){
			int p=0;
			for(int i=1;i<len;++i)
				if(s[i]=='1'&&s[i-1]=='1'){
					p=i;
					break;
				}
			if(p){
				if(len==2||len==3)
					puts("-1");
				else if(len==4){
					if(p==2)
						puts("3");
					else
						puts("2"); 
				} else
					puts("2");
			} else
				printf("%d\n",ans/2);
		} else
			printf("%d\n",ans/2);
	}
	return 0;
}
```