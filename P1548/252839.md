    
看到dalao们都推出了一个一个华丽的公式，我这个蒟蒻就只能写一份比较通俗易懂、比较基础的算法了。

### 思路：

先求出正方形的个数，在求出长方形的个数+正方形的个数，再减去正方形的个数，求出长方形的个数。

### 下面是我求正方形个数的方法 ：

枚举正方形的边长，对于不同边长的正方形就有（棋盘边长-枚举变长+1）条边，然后相乘变成当前边长的正方形个数，公式是（n-边长+1）*（m-边长+1），最后累加即可。

### 接下来用奥数求长方形+正方形的个数 ：

这个方法与上面有点不同，既然是包括长方形，所以边长不定。比如对于2*3的棋盘来说，那有的长方形+正方形个数为：

       1 * 1+1 * 2+1 * 3+2 * 1+2 * 2+2 * 3
	  =1*（1+2+3)+2*(1+2+3)
      =(1+2+3)*(1+2)
      =18（个）
      
你发现了什么？对的，2 * 3的纸的长方形+正方形的个数就是（1+2） * （1+2+3），也就是（1~n的和）*（1~m的和），记住，这只是求出了长方形+正方形的个数，还要-正方形的个数才=长方形的个数

所以，长方形的个数公式是：（1~n的和）*（1~m的和）-正方形的个数。这也告诉了我们：当推导公式时，可以用实数带进去计算从而得出结论。

### 下面献上代码：    
    
    #include<iostream>
    #include<cmath>    //文件头
    using namespace std;
    int n,m,sum,N,M,SUM;  //定义，小写的是求正方形个数的 ，大写的是求正方形+长方形个数的 
    int main()
    {
        cin>>n>>m;   //读入棋盘的长和宽
        //输入
        
        for(int i=1; i<=min(n,m); i++)  //枚举边长，记住min(n,m)，因为正方形只能由小的那条边作为边长，记住，这个min函数是在cmath库里调用的
        	sum+=(n-i+1)*(m-i+1);  //套公式（n-边长+1）*（m-边长+1）
        //求正方形，知识点：1.正方形只能由小的那条边作为边长  2.对于不同边长的正方形就有（棋盘边长-枚举变长+1）条边
        
        for(int i=1; i<=n; i++) 
        	N+=i;               //求一条长的和，累加1~n
        for(int i=1; i<=m; i++)
        	M+=i;               //求一条宽的和，累加1~m
        SUM=N*M-sum;        //根据（1~n的和）*（1~m的和）-正方形的个数算出长方形个数
        //求长方形，知识点：公式的推导
        
        cout<<sum<<" "<<SUM;  //输出正方形个数和长方形个数
	    //输出
        return 0;
    }
    
#### ~~最后不要脸的求个赞[滑稽]~~
