# 题目大意

给定一棵树，每个节点有相应的权值，第 $i$ 个节点权值为 $val_i$。

你的程序需要支持以下操作：

1. 格式为 `1  x`，表示在求 $x$ 的祖先节点中，最近的满足 $\gcd(val_{v},val_x)\neq1$ 的节点 $v$。

2. 格式为 `2 x v`，表示令 $val_x=v$。

# 题目分析

题目的数据非常水，可以暴力卡过。

我们把树存下来，对于每个操作：

第一个指令时，暴力在 $x$ 的祖先节点中寻找即可，$\gcd$ 使用较高效的欧几里得算法计算，找到满足条件的祖先节点，输出该节点编号即可。

第二个指令时，直接朴素 $val_x\gets v$。

给出 $\rm dfs$ 代码：

```cpp
inline int dfs(int now)
{
	for(register int i=fa[now];i;i=fa[i])
	{
		if(gcd(a[now],a[i])!=1)
		{
			return i;
		}
	}
	
	return -1;
}
```

----

考虑第一个指令，容易发现这个指令和求 $\rm LCA$ 的朴素过程非常相似，于是容易想到使用倍增法计算。

第一个指令时，按倍增的步骤跳，其他同朴素算法。

由于数据较弱，该算法实际优化作用不大，甚至会比暴力更为缓慢（当然也可能我的 $\rm LCA$ 常数巨大/kk）。

