萌新刚学习了状压dp, 发一篇题解强化一下

拿到这道题, 先看一下数据范围: 嗯, $k<=16$, 非常的状压......

众所周知, 状压大部分情况下是将一个状态转移为一个二进制数来保存

## bitset大法吼啊 ! ! !

所以复杂度肯定是 $2^n$ 系列的

既然和二进制有关, 那么为什么不用$bitset$呢? 

反正我觉得$bitset$代码虽然看着长了一些, 但比满屏的&|^更清楚

先讲一下这道题的思路

首先, 我们要状态压缩的肯定是硬币数$k$

那么我们就可以用一个$k$位二进制数来保存状态, 

每一位对应的$0$为不用这枚硬币, 1为用这枚硬币

令$dp[i]$表示使用硬币状态为$i$时顺序购买最多可以买几件商品

那么对于每一个状态, 都肯定是由比当前状态少支付一个硬币的状态转化而来的

那么用$bitset$表示就是

```
对于当前状态
for i=1~k枚举该状态每一位
	if (该位为1){
    	    原状态=现状态将该位设为0;
            现状态=max(现状态, 原状态+第i个硬币可以购买的物品数)
    	}
```

同时, 因为$n<=10^5$, 我们如果暴力的去枚举每一个物品是否可以买, 很明显会超时, 

所以我们可以用前缀和数组去维护, 利用二分查找前缀和数组以达到$logn$的复杂度

然后这题就做好啦~~~

献上码风奇特的代码(注意事项详见注释)

```cpp
#include <bits/stdc++.h>
using namespace std;
#define r register
int k,n,arr[100005],sum[100005],coin[18],dp[65550];
unsigned long stat; //bitset不能直接作为数组下标, 于是用一个无符号长整型间接表示状态
bitset<18>x; //一个18位的bitset
int main() {
	cin>>k>>n;
	for(r int i=1;i<=k;i++) scanf("%d",&coin[i]);
	for(r int i=1;i<=n;i++){
		scanf("%d",&arr[i]);
		sum[i]=sum[i-1]+arr[i]; //前缀和处理
	}
	for(r int i=0;i<(1<<k);i++){ //枚举每一个当前状态i
		x=i; //将i的值赋予这个bitset容器x
		for(r int j=1;j<=k;j++){ 
			if(x[j-1]){ //我习惯用bitset时从0开始所以要减1
				x[j-1]=0;//找到不花费这枚硬币时的原价值
				stat=x.to_ulong(); //将bitset转成unsigned long类型的函数
				dp[i]=max(dp[i]+0ll,upper_bound(sum+1,sum+n+1,coin[j]+sum[dp[stat]])-sum-1ll); 
        //状态转移, 注意二分查找的是第一个不大于总花费的, 所以要减1; 另外所查找的总花费是sum数组中原状态可以购买的物品个数对应的值加上这个硬币的价值
				x[j-1]=1; //注意转移完了需要重置状态, 不然就没法正确转移
			}
		}
	} 
	int ans=-1,res=0; //因为无解输出-1, 所以ans初始化为-1
	for(r int i=0;i<(1<<k);i++){
		x=i;
		if(dp[i]==n){ //当前状态可以购买所有物品
			res=0;
			for(r int j=1;j<=k;j++)
				if(!x[j-1])res+=coin[j]; //统计当前状态剩余钱数
			ans=max(ans,res); //答案取最大值
		}
	}
	cout<<ans;
	return 0;
}
```
P.S. 对于这道题而言$bitset$的好处可能不是那么明显, 

但是对于有些状压题, 状态转移时方程和该状态二进制中1的个数有关,

这时用$bitset$就不需要预处理, 直接使用$x.count()$函数即可