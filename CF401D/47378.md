P4163 [SCOI2007]排列 的升级版，这道题出题者的本意应该是让状压dp的,但是大多数人都用搜索水过了

不同于其他题解里的dp方式，我的dp方式是在前面加数字，数组和楼下的一样

f[ i ][ j ] 其中i表示状态：用a（十进制）下的对应位构造出的mod b == j 的数字有多少 

对于看不懂楼下代码的同学们解释一波：

楼下的状态转移：如38996923 在后面加上3

他现将38996923*10---> 389969230 膜上模数后加上3再膜模数

这种方法思路固然好，但是去除前导零的话就有点复杂

我的方法不同，在这个方程中也要算上所有前导零的情况，只有在最后在祛除一次，例如：

008676876 这在我的方程里面也是一种合法情况，应为我将在前面加上一个状态里面选择的数 比如3，则此数变成 3008676876

状态转移方程：f[i][(sd[t-1]*w[j+1]+u)%b]+=f[i^(1<<j)][u];

其中:

j是状态里所选择的加在数字前面的数

t表示这个数字（新构成的数字）一共有几位

sd[i]表示i所对应的十进制位在mod 模数的情况下需要乘的数(其实就是10^i%mod)

u是转移时循环的模数

上代码，语言表述能力不佳，有疑问欢迎私信，我一定尽全力解答

```cpp
#include<cstdio>
#include<string.h>
long long a,b,sd[20],w[20],cnt,f[262146][102],p;
bool vis[20];
int main(){
    sd[0]=1;for(int i=1;i<=18;i++) sd[i]=sd[i-1]*10;
    scanf("%lld%lld",&a,&b);
    for(int i=1;i<=18;i++) sd[i]=sd[i]%b;
    long long t=a;f[0][0]=1;
    while(t){w[++cnt]=t%10;t/=10;}
    for(int i=1;i<(1<<cnt);i++){
    	memset(vis,false,sizeof(vis));int t=0;
        for(int j=0;j<cnt;j++) if(i&(1<<j)) t++;
        for(int j=0;j<cnt;j++){
        	if(!(i&(1<<j))||vis[w[j+1]]) continue;
        	vis[w[j+1]]=true;
        	for(int u=0;u<b;u++) f[i][(sd[t-1]*w[j+1]+u)%b]+=f[i^(1<<j)][u];
        } 
    }
    for(int j=1;j<=cnt;j++) if(w[j]==0){p=j;break;}
    if(p!=0) f[(1<<cnt)-1][0]-=f[((1<<cnt)-1)^(1<<(p-1))][0];
    printf("%lld\n",f[(1<<cnt)-1][0]);
    return 0;
}
```