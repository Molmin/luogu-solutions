# CF401D Roman and Numbers

> 将 $n,n\le 10^{18}$ 的各位数字重新排列（不允许有前导零） 求 可以构造几个 $\bmod\  m$ 等于 $0$ 的数字 $(m\le 100)$

变进制状压。

为啥没人写变进制状压啊，~~比二进制状压高到不知道到哪里去了。~~

截至 2021.10.29 是 lg 最优解。

---

发现要重新排列 $n$ ，于是肯定和 $n$ 的位数有关。

$n\le10^{18}$ ，可以考虑状压。

先说一下比较常见的二进制状压。

设 $f_{S,i}$ 表示 使用了 $S$ 这个状态中的数字，并且 $\bmod \ m$ 等于 $i$ 的方案数。

每次枚举一个数字填在已经填好的数字后面进行转移。

`f[S|(1<<(i-1))][(j*10+a[i])%m]+=f[S][j];`

对于前导零，只需要在放入第一个数字的时候特判一下是不是 $0$  即可。

考虑到相同数字的排列顺序并不重要，需要去重。

去重也很简单，直接除以所有数字的出现次数的阶乘就好了。

或者标记一下使用过的数字。

[二进制状压代码](https://gitee.com/lawrencesivan/code-clipboard/blob/master/CF401D%20Roman%20and%20Numbers%EF%BC%88%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%8A%B6%E5%8E%8B%EF%BC%89)

设 $N=\log_{10}n$ 

复杂度为 $\mathcal{O(2^NNm)}$ 。

---

发现上面的状态量很大的。

考虑另外一种状态定义，从每个数字出现次数入手。

对于每一种数字，他在 $n$ 中出现的最多次数可能是 $18$ 次。

那么状态量就是 $19^1=19$  。

考虑极端情况，十种数字出现次数相同。

每个数字出现 $\dfrac{9}{5}$ 次（近似认为是 $2$ 次）。

状态量是 $3^{10}$ （每种数字有三种情况，$0$：一次都不出现，$1$:出现一次：$2$:出现两次）

远远小于刚才的 $2^N$ 。

按照上面的状态定义设计转移：

设 $f_{S,i}$ 表示已经填进去的数字的**次数**的状态为 $S$，并且填出来的数字 $\bmod \ m$ 等于 $i$  的方案数。

之后你会发现每个数字出现次数可能不一样，那么我们不能使用二进制进行状压。

考虑变进制数，以每一种数字的**可以选择的出现次数**作为进制

不熟悉可以去做做[康托展开模板题](https://www.luogu.com.cn/problem/P5367)和[火星人](https://www.luogu.com.cn/problem/P1088)。

先来看看熟悉的进制。

十进制数：$x=x_0×10^0+x_1×10^1+x_2×10^2+x_3×10^3+…$

二进制数：$x=x_0×2^0+x_1×2^1+x_2×2^2+x_3×2^3+…$

他们都可以表示为一个多项式。

每一个变量前面的系数和进制有关（可以发现，定进制数的进制就是系数的底数）。

每一个变量的去取值范围都是 $[0,进制-1]$ ，多余则进位。

一般的，我们可以类似地定义 $m$ 进制数。 

> $m$ 进制数：$x=x_0×m^0+x_1×m^1+x_2×m^2+x_3×m^3+…$

变进制数就是每一位进制不一样。

我们可以向下面这样定义变进制数：

其中每一位的进制是 $p_i$。

> $x=x_0+x_1p_0+x_2p_0p_1+x_3p_0p_1p_2+...$

其中每一位的范围依然是 $[0,进制-1]$ ，即 $[0,p_i-1]$。

发现系数 $k_i$ 就是 $k_i=\prod\limits^{i-1}_{j=0}p_j$。

于是你发现你做到了变进制数与 $10$ 进制数的转化。

$x=x_0+x_1k_1+x_2k_2+x_3k_3+...$

其实和二进制状压差的不怎么多，就是进制不太一样了，该怎么状压还怎么状压。

如何取出变进制的第 $i$ 位？

想想 $10$ 进制。

比如 $10202$ 取出第三位咋取？

是不是可以 `(10202/100)%10` ？

写成变进制形式是什么？

`x/p[i-1]%(a[i]+1)`

但是这样是有问题的。

要是让你取出第 $0$ 位呢？

会出现负下标。

我们用一种等价形式来代替：

`x%p[i+1]/p[i]`

可以用十进制帮助理解：

$10202 \rightarrow 202 \rightarrow 2$。

并且可以很方便的判断前导零，同样是填入第一个数字的时候去掉。

极限状态下复杂度 $\mathcal{O(3^{10}\times10m)}$

代码：

```cpp
read(n,m);
while(n){
    a[n%10]++;
    n/=10;
}

frac[0]=1;
for(int i=1;i<=10;i++){//按照上面说的记录一下每一位的系数    
    frac[i]=frac[i-1]*(a[i-1]+1);
}

f[0][0]=1;

for(int S=0;S<frac[10]-1;S++){//就像是你二进制状压写的是 1<<n 一样，，是全 1 状态
    for(int i=(S==0);i<10;i++){//在填入第一个数字的时候去除前导零，枚举选择哪一种数字
        if(S%frac[i+1]/frac[i]<a[i]){//填入数量限制
            for(int j=0;j<m;j++){//枚举余数
                f[S+frac[i]][(j*10+i)%m]+=f[S][j];
            }
        }
    }
}

write(f[frac[10]-1][0]),puts("");
```

