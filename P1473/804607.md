本题我用了一种新的枚举方法，这种方法是我解这道题时**独立发现**的。（我用了 $2$ 个小时写出来了）

**本题解最早的[提交记录](https://www.luogu.com.cn/record/94335448)在 C++14 (GCC 9) 的最优解中稳排倒数第一，用时约是倒数第二的 $2$ 倍，因此请小心使用此方法！**

当我们看到这个题的时候，就可以想到暴力枚举了。

然鹅普通的二进制枚举值只适用于类似 01 背包这种只有 $2$ 个状态的枚举，但是我们现在有 $3$ 个状态，怎么办呢？

此时，我们突然想到了一个注意：可以扩充 $1$ 个二进制位呀！

普通的二进制枚举用 $1$ 个二进制位表示 $1$ 个状态，但是我们的二进制枚举使用 $2$ 个二进制位表示 $1$ 个状态，这样就可以达到~~计算量翻倍~~表示复杂状态的目的了！

因为我们需要枚举 $n-1$ 个符号的状态，每个符号又需要 $2$ 个二进制位来表示其状态，所以一共需要 $2(n-1)$ 个二进制位。

那我们怎么分解这个二进制呢？

我们可以参考普通的二进制枚举时什么样的：

```cpp
for (int i=0; i<(1<<n); i++){
    base = 0;
    for (int j=1; j<=n; j++){
        a[i] = (i >> base & 1);  // 举个例子
        base++;
    }
}
```

我们看一下哪里要改一下：

1. 第一个枚举的终点应该改成 `(1 << ((n-1)<<1))`。（具体看上面的解释）

2. `base` 不能只增加 $1$，因为我们每个状态有 $2$ 个符号位，所以应该要增加 $2$。

3. 因为我们实际上有 $3$ 个状态，所以我们需要改成 `(i << base & 3)`（可能有人会问为什么是 $3$，因为 $3 = (11)_2$，任何一个数都会只保留最低的两个二进制位，相当于对 $4$ 取余）。

大家都会改了吧，那么核心代码就只有那么几行：

```cpp
for (int i=1; i<(1 << ((n-1)<<1)); i++){  // 二进制枚举 
	str = "1";  // 初始化，至少有一个1 
	base = 0;
	for (int j=2; j<=n; j++){  // 枚举2~n的数 
		str += symbol[i >> base & 3];
		str += j + '0';
		base += 2;
	}
		
	if (judge()) vis.insert(str);  // 计算是否合法 
}
```


其中 `symbol = {' ', ' ', '+', '-'}`；`judge()` 为计算函数，用于计算表达式的值是否为 $0$。

因为 `judge()` 函数不是这篇题解的重点，所以不展开讲，只给注释代码。完整代码如下：

```cpp
#include <bits/stdc++.h>
using namespace std;
const char symbol[] = {' ', ' ', '+', '-'};  // 符号 

int n, base, now, ex, oth;
stack<int> st;  // 用于计算，数值和符号用一个栈 
bool flag;

set<string> vis;  // 集合储存，因为是4进制，不仅要排序，而且还要去重 
string str;  // 获得的算式 

void count(){
	ex = st.top();  // 符号 
	st.pop();
	oth = st.top();  // 数值 
	st.pop();
	if (ex) now += oth;  // 判断符号并计算 
	else now = oth - now;
}

bool judge(){  // 判断是否为0 
	if (!st.empty()) st.pop();  // 注意要清空栈 
	
	now = 0;  // 当前数值 
	for (int i=0; i<str.size(); i++){
		if (str[i] >= '0' && str[i] <= '9'){  // 如果是数字 
			now = now*10 + (str[i]-'0');  // 计数器加上之前的 
			if (i == str.size()-1){  // 已经是最后一个了 
				if (st.empty()) return false;  // 全部空格的肯定不行 
				count();
				st.push(now);  // 把数值推进去 
			}
		}else if (str[i] == '-' || str[i] == '+'){  // 如果是符号 
			if (!st.empty()) count();  // 栈非空，表示里面有数 
			st.push(now);  // 把数加进去 
			st.push(str[i] == '+');  // 把符号加进去 
			now = 0;  // 清空计数器 
		}  // 空格不用管 
	}
	
	return st.top() == 0;  // 判断是否等于0 
}

int main(){
	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
	
	cin >> n;
	
	for (int i=1; i<(1 << ((n-1)<<1)); i++){  // 二进制枚举 
		str = "1";  // 初始化，至少有一个1 
		base = 0;
		for (int j=2; j<=n; j++){  // 枚举2~n的数 
			str += symbol[i >> base & 3];
			str += j + '0';
			base += 2;
		}
		
		if (judge()) vis.insert(str);  // 计算是否合法 
	}
	
	for (auto i: vis) cout << i << '\n';  // 输出，set是自动排序的 

	return 0;
}

```

时间复杂度为 $O(2^n) \times O(n) = O(2^nn)$，其中 $O(2^n)$ 是枚举，$O(n)$ 是判断。空间复杂度为 $O(2^n)$，因为要储存合法的情况。

这里有几个小技巧：

1. 我们枚举的时候还是需要枚举空格的，但是计算的时候我们可以直接忽略掉，什么也不判断。

2. 因为这个二进制生成的字符串可能会重复，需要去重，而且后面是要升序排序的，所以我使用 `set`，一举两得。

3. 可以把一次计算单独写成一个 `count()` 函数，这样可以节省代码量。

虽然你可能觉得它很没用，但是在某次选拔赛中，我把深搜写挂了，心急如焚的时候突然想到二进制枚举，然后只用了 $20$ 分钟通过了那道题（ACM 赛制），这让我在毒瘤的 $14$ 题中通过了 $5$ 题（第一名 $7$ 题），也让我在计算总成绩时排名 $16$（共 $120$ 人）。这说明，二进制枚举确实有点用。