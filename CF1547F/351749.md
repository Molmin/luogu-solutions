本题解没有使用任何数据结构，stl等等，但是思维难度相比其他题解较大，适合学的东西不多并且想开拓思维的萌新阅读qwq。

我们考虑最小公倍数对于质因数的影响。

比如说 $\gcd(36,60)=12$ ，

$36=2\times2\times3\times3$

$60=2\times2\times3\times5$

$12=2\times2\times3$

我们发现两个数的最小公倍数其实就是保留两个数最多公有的质因数，舍去其它后相乘起来的结果。如果我们再考虑其中一个单独的质因数，发现两个数最小公倍数中某个质因数存在的个数，就是那两个数中这个质因数分别存在的个数的最小值。

举个例子，上面的 $36$ 中有两个 $3$ ， $60$ 中有一个 $3$ ， 所以最小公倍数中有 $\min(2,1) = 1$ 个 $3$。同理，它们的最小公倍数中有 $\min(0,1) = 0$ 个 $5$ 。

对于题目中这种环状相邻取最小公倍数的操作，反映到单个质因数身上就变成了环状相邻取最小值的操作。

比如下面是原题中的取最小公倍数操作:

$16$ , $24$ , $10$ , $5$

$8$ , $2$ , $5$ , $1$

$2$ , $1$ , $1$ , $1$

$1$ , $1$ , $1$ , $1$

考虑对于 $2$ 这个质因数在各个数中存在的个数变化情况:

$4$ , $3$ , $1$ , $0$

$3$ , $1$ , $0$ , $0$

$1$ , $0$ , $0$ , $0$

$0$ , $0$ , $0$ , $0$

如果像这样环状相邻取最小值的话就好做很多了有没有qwq。

现在考虑这种环状相邻取最小值需要多少次操作使数字都相等，有一个很显然的结论就是这些数最后都会变成它们的最小值，那么我们只要考虑最小值对别的数取 $\min$ 造成的影响。可以发现每次操作所有已经是最小值的数都会把它前面的一个数同化成最小值，那么让所有数都变成这个最小值需要的操作数就是**最长的连续不是最小值的一段数字的长度**。由于这是一个环，所以将其复制一遍断环成链后扫一遍整个序列就可以了。这个问题时间复杂度是 $O(n)$ 的。

回来考虑原来的问题，如果所有数字都相等了，那么所有数字的每个质因数的个数也就都相等了。所以我们只要分开对每个质因数做一遍环状相邻取最小值，然后取所需操作次数的最大值即可。

但由于 $1\le a_i \le 10^6$ ，$2\le n \le 2 \times 10^5$ ，质因数个数可能会很多，需要考虑对一些地方进行优化。

发现如果当一个质因数 $>1000$ 时，由于 $a_i$ 的值域，每个数中拥有这个质因数个数只可能是 $0$ 或 $1$ ，并且如果拥有了这个质因数就不会再拥有别的 $>1000$ 的质因数，那么如果我们把所有 $a_i$ 去掉 $\le1000$ 的质因数，剩下的就都是 $1$ 或者它们拥有的唯一一个 $>1000$ 的质因数。这个时候我们同样复制一遍断环成链，找**最长的连续数字相同且不为 $1$ 的一段数字的长度**即可（如果这个长度 $\ge n$ 也就是数字都相等，我们不需要对其操作，这时操作数是 $0$ ），然后再把这个操作数与前面取最大值。

最终答案就是这个最大值了。

由于 $\le1000$ 的质数只有 $168$ 个，通过本题数据还是比较轻松的。

毫无参考意义的代码x

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,t,b[1001],p[1001],top,a[400001],c[400001],ans,l;
int main(){
	ios::sync_with_stdio(false);
	cin>>t;
	b[1]=1; 
	for (int i=2;i<=1000;++i) if (!b[i]) for (int j=i+i;j<=1000;j+=i) b[j]=1; 
	for (int i=2;i<=1000;++i) if (!b[i]) p[++top]=i;//埃氏筛筛质数
	while (t--){
		cin>>n;
		for (int i=1;i<=n+n;++i) c[i]=0;
		for (int i=1;i<=n;++i) cin>>a[i];
		ans=0;
		for (int i=1;i<=top;++i){//枚举质因数是什么 
			for (int j=1;j<=n;++j){
				c[j]=0;
				while (a[j]%p[i]==0){a[j]/=p[i]; ++c[j];}
			}//求出每个数中有多少个这个质因数，顺便除去这个数<=1000的质因数 
			long long mi=1e9; 
			for (int j=1;j<=n;++j) mi=min(mi,c[j]);
			for (int j=1;j<=n;++j) c[j+n]=c[j];//断环成链 
			l=0; long long sum=0;
			for (int j=1;j<=n+n;++j){
				if (c[j]>mi) ++l;
				else l=0;
				sum=max(sum,l);
			}
			ans=max(ans,sum);//求得使每个数含有这个质因数个数相同的操作数并更新答案 
		}
		l=0; long long sum=0;
		for (int i=1;i<=n;++i) a[i+n]=a[i];//断环成链 
		for (int i=1;i<=n+n;++i){
			if (a[i]==1) l=0;
			else if (a[i]!=a[i-1]) l=1;
			else ++l;
			sum=max(sum,l);
		}
		if (sum<n) ans=max(ans,sum);//要特判剩下数字都相同的情况 
		cout<<ans<<'\n';
	}
	return 0;
}
```
