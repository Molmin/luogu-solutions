##题目描述（节选）

游戏规则是这样的： 每次一个人可以对给出的数进行分割，将其割成两个非零自然数，之后

由另一个人选择留下两个数中的其中一个；之后由另一个人进行分割这个剩下的数，重复步骤……

当一个人无法对数进行分割的时候游戏结束，另一个人获胜。

现在要你求出N次游戏的胜败。

--------------------------------------------------------------------------------------------------------------

##题目分析

对于每一次分割操作，数的总数会+1。当所有数均为1时，就无法继续分割了。此时分割的人输。

可以求得数的总数在起始和结尾处变化了(m-1)。由于pb先开始，所以当(m-1)为奇数，即m为偶数

时，pb获胜。

###即：m为奇数 zs获胜   反之 pb获胜

--------------------------------------------------------------------------------------------------------------

##优化思路

1.快速读入。由于此题没有负数，所以我对快速读入的函数作了一些修改。

2.位运算。当出现类似于x%2的式子时，取模运算是算得很慢的。而由于位运算较快，所以可以

化为**x&1**

原理：按位与只有两数位置上都为1结果才为1。

例子：m=1001101101（二进制） m&1运算如下：

1001101101

0000000001

其中由于1的前面全部为0，最后一位为1，所以这个表达式共有2种情况：

当m能被2整除，即二进制下最后一位为0时，该式为0。

反之，当m不能被2整除，即二进制下最后一位为1时，该式为1。


~~其实由于这题的数据量小，n<50,所以根本不用优化，暴力就可以了……~~

--------------------------------------------------------------------------------------------------------------

代码：

```cpp
#include<stdio.h>
inline int read() {
    int x=0;
    char ch=getchar();
    while(ch<'0' || ch>'9')
        ch=getchar();
    while(ch>='0' && ch<='9') {
        x=10*x+ch-'0';
        ch=getchar();
    }
    return x;
}
int main() {
    int n,m;
    n=read();
    for(int i=1; i<=n; i++) {
        m=read();
        if(m&1)            //奇数 
            puts("zs wins");
        else
            puts("pb wins");
    }
    return 0;
}
```