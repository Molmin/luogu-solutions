## 首先了解一点：奇数后手胜，偶数先手胜。
## 然后我们来用不完全归纳法证明：
## m为奇数时后手胜，m为偶数时先手胜。
（1）当m=1,2时，上述结论显然成立（自己写个1，写个2看看就好了）

（2）假设对于m=1到k时，上述结论也成立。

       1 当k为奇数时，k+1为偶数，pb先手，
       
       一个偶数（k+1）能被拆分为两个奇数或两个偶数。而拆分后变成了zs先手。
       所以pb一定会给zs两个奇数（这两个奇数都比k小），然后无论zs
       选哪个，都要输给pb(因为假设m=1到k满足奇数后手胜)
       所以说，m=k+1（偶数）时pb胜，满足偶数先手胜（即归纳法结论）
       
       2 当k为偶数时，k+1为奇数，pb先手。
       
       一个奇数（k+1）一定是被拆分成一奇一偶（都比k小），此时zs先手，由
       由假设知在m=1到k时奇数后手胜，偶数先手胜，所以zs一定会选择其中那个
       偶数，然后获胜。
       所以说，m=k+1（奇数）时zs胜，满足奇数后手胜。
       
       
       （到这里，只要1..k满足该规律，k+1就满足，同理k+2,k+3也满足）
       综上（1）（2），该规律对于自然数成立。
       
       然后就是代码了。
```
#include<iostream>
#include<cstring>
#include<cstdio>
#include<cstdlib>
using namespace std;
int n,m;
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&m);
		if(m%2==0)printf("pb wins\n");
		else printf("zs wins\n");
	}
	return 0;
}
```

### 如果有时间，还是希望自己能学一下博弈论，毕竟用博弈论分析要比先猜再归纳快的多。
### 我在想这题为什么是入门？？？难道正解是找规律？？？