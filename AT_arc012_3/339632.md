## 对于这份代码版权问题的简述

这份代码是我的老师 @楼楼223 与我合作完成的，我**被授权**发布这篇题解。再次感谢 @楼楼223 !

这道题的小细节比较多，我会在代码前介绍主要思路，一些细节与特判在代码内完成。

好了，开始吧！

## 解题思路

#### 一、上一手棋子颜色的判断

因为黑子线下，一定有以下判断：

如果黑子数量==白子数量，可以说明刚刚下的是白子。（黑子和白子两两对应）

如果黑子数量-白子数量==1，刚刚下的是黑子。（白子下完，黑白子数量相等后又多了一手黑子）

如果这两种情况都不是，那么有问题，输出NO。

这件事情很清楚，不必详细描述了。

#### 二、是否作弊的判断方法

#### 1.作弊过程的描述

好了，来到核心部分。

如何判断这个人有没有作弊呢？

设想一个情形，这个时候两个人都没有获胜。并且**刚刚下的是黑子**。（其实白子同理，为方便起见这里先只讲黑子）

这时，一只~~邪恶的~~小手伸过来，放了一个子，使他**获胜了**。

那么这个时候，如果**比赛还在继续**，也就是**又出现了下一手**，那么就说明他作弊了。

因为获胜了，比赛就**结束了**，不可能继续了呀！

#### 2.深入分析作弊过程

 _好了，现在我们细品这个非常非常重要的过程。_ 

这个作弊者可能放了哪一个棋子呢？

**哪一个黑子都可能。**

所以，我们要**遍历刚刚下的每一个黑子**，来看看如果他刚刚下的是这个棋子，是不是属于作弊。

如果有**一种情况无法判断作弊**，那刚刚下的有可能就是这个棋子，不能说明他作弊，直接输出$YES$即可。

如果每一种情况都说明他作弊了，那他**肯定作弊了**，输出$NO$。

怎么遍历呢？我们可以反向模拟这个过程。也就是**依次**去掉每一个黑子。注意，是依次去掉，也就是去掉，判断完之后还要再**放回来**。

那么**去掉后棋子的情形便是上一步的情况**。如果这种情况下已经有人获胜，那么比赛不应继续。

如果去掉每一个黑子后都是这种情况，可以说明他一定作弊了，输出$NO$。

反之，如果有一个黑子被去掉后无人获胜，那么就**无法判断他作弊了**，因为他刚刚下的可能就是这个棋子，在这种情况下他没有作弊。因此输出$YES$。

当然，如果原来（没有去掉棋子）的情况下就无人获胜，更没有问题了。

#### 三、寻找连续棋子的方法

再来介绍寻找一个棋子周围寻找连续棋子的方法。

一个棋子周围有8个棋子，用两个数组记录他们的位置：

```cpp
const int x[] = {1,1,1,-1,-1,-1,0,0};
const int y[] = {0,1,-1,0,1,-1,1,-1};
```
其中，x数组中，1是下一行，-1是上一行，0是本行。

y数组中，1是下一列，-1是上一列，0是本列。

比如，$x[0],y[0]$对应的是本列下一行，也就是原格下方的位置。

这样这两个数组就可以描述每一个位置了，拿纵横坐标分别加减即可。

其他的小细节，代码中见~

## 完整AC代码

```cpp
#include <bits/stdc++.h>
using namespace std;
const int x[] = {1,1,1,-1,-1,-1,0,0};
const int y[] = {0,1,-1,0,1,-1,1,-1};
//8个位置的记录
queue < pair<int,int> > black,white;
//两个整数分别表示纵横坐标，方便后面取用
char board[20][20]; //记录棋盘
int o_len = 0, x_len = 0; //记录最大长度

void lf(int i, int j, char c, int len, int k)
//ij是纵横坐标，c表示是黑子还是白子，len是当前连续长度，k是数组下标，表示方位
{
    if (board[i][j]=='.') return; //没有棋子，不用判断
    if (c == 'o' && len>o_len) o_len = len; //黑子连续
    if (c == 'x' && len>x_len) x_len = len; //白子连续
    //擂台法，寻找最大
    if (board[i+x[k]][j+y[k]] == c)  
    //如果和中心棋子是一样的，即连续
    lf(i+x[k],j+y[k],c,len+1,k); //len别忘了+1，表示又找到了一颗连续的棋子
    //把中心棋子变为找到的相同颜色的棋子继续搜索，看看有没有进一步连续
 }
 
void search_max_length()
{
    for (int i = 1; i <= 19; i++)
    {
        for (int j = 1; j <= 19; j++) //遍历棋盘
        {
            //八种情况
            if (board[i][j] == 'o') //是黑子
                for (int k = 0; k<=7; k++) lf(i,j,'o',1,k);
                //8个相邻格
            if (board[i][j] == 'x') //是白子
                for (int k = 0; k<=7; k++) lf(i,j,'x',1,k);
        }
    }
}

int main()
{
    int o = 0, x = 0; //记录黑子白子总共的数量
    for (int i = 1; i <= 19; i++)
    {
        for (int j = 1; j <= 19; j++)
        {
            cin>>board[i][j]; //输入棋盘
            if (board[i][j] == 'o')  //是黑棋
            {
                black.push(make_pair(i,j)); //纵横坐标入黑队
                o++;
            }
            if (board[i][j] == 'x')  //是白棋
            {
                white.push(make_pair(i,j)); //纵横坐标入白队
                x++;
            }
        }
    }

    if (o - x >= 2 || x > o) //黑比白多了超过1个或者白比黑多
    {
        cout<<"NO"<<endl;
        return 0;
    }
    if (x == 0 && o == 0) //特判：棋盘是空的
    {
        cout<<"YES"<<endl;
        return 0;
    }
    if (o - x == 1)//上一步是黑子下的
    {   
    //去掉一颗黑子
        while (black.size()) //在子还没有被全部去掉时
        {
           int axis_x = black.front().first; 
           int axis_y = black.front().second;
           //要去掉的棋子的纵横坐标
           black.pop(); //这一颗棋子出队，表示已经去掉过
           board[axis_x][axis_y] = '.'; //标记成没有棋子
           o_len = 0;
           x_len = 0; //先归零
           search_max_length(); //搜索最大长度
           board[axis_x][axis_y] = 'o'; //标记回来
           if (o_len <= 4 && x_len <= 4) //都不长于4，无人获胜
           {
               //有可能没有作弊，输出YES
               cout<<"YES"<<endl;
               return 0;
           }
        }
        //所有情况去掉一个黑子均有大于4的连续棋子，即一定有人获胜
        cout<<"NO"<<endl;
        return 0;
    }
    if (x == o) //上一手是白子下的
    {
    //去掉一颗白子，与上方去掉黑子重复，此处不再详细解释了
        while (white.size())
        {
           int axis_x = white.front().first;
           int axis_y = white.front().second;
           white.pop();
           board[axis_x][axis_y] = '.';
           o_len = 0; 
           x_len = 0;
           search_max_length();
           board[axis_x][axis_y] = 'x';
           if (o_len <= 4 && x_len <= 4)
           {
               cout<<"YES"<<endl;
               return 0;
           }
        }
        cout<<"NO"<<endl;
        return 0;
    }
}
```
另外，这道题强调了**输出需要换行**，不要忘了！

要不然爆零~

这篇题解就到此为止了。如果大家有不理解之处，**欢迎在下方留下评论，或是私信我**。

别忘了点个赞！

~~（感觉写了一篇小论文哈哈）~~

### 修改记录

$2020/5/3$ 发布题解

$2020/5/4$ 删去代码中不必要的空行（为分隔板块的空行仍保留）
   
   修改了描述不清的注释、在不容易理解的位置添加注释
   
$2020/5/8$ 对洛谷题解区格式改变而进行部分字词的修改
   
   增加主要思路部分的序号来清晰结构