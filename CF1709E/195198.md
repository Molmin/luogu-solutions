下文中 $\oplus$ 表示二进制按位异或运算（C++ 中的 `^`）。

如果令 $d_u$ 表示从 $u$ 到根的异或值，那么 $u$ 和 $v$ 两点之间的异或值可以表示为 $d_u \oplus d_v \oplus w_{\text{lca}(u,v)}$。

显然是不能暴力枚举 $u,v$ 了，那么我们考虑枚举这个 LCA。

考虑修改一个点，由于是可以把权值修改成任意正整数，所以只要我们改的够离谱，所有经过这个点的路径就都不合法了。但是这只能处理过这一点的，没法处理这个点子树内的答案。

所以我们有一个显然的策略，把点从深到浅依次处理，这样可以保证处理经过点 $u$ 的路径的时候，以点 $u$ 子树内任意一点为 LCA 的路径已经被处理过。

具体的处理方法就很暴力了，对每个节点维护一个 set 表示它的 $d$ 数组。那么我们只需要把点 $u$ 的答案合并到它的父亲上去就好了，如果出现不符合题意的，那么就直接把 $u$ 的 set 删掉，同时答案 +1。

暴力合并是 $O(n^2 \log n)$ 的，但是直接启发式合并一下就可以做到 $O(n \log^2 n)$。

[Code & Submission](https://codeforces.com/contest/1709/submission/211827542)