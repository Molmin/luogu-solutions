## 思路分享

一道非常不错的树形 $DP$ 题。

我们思考，由于每个`客户端`必须与**恰好**一个`服务器`相邻，故我们可以考虑设 $3$ 个 $dp$。

- $dp_{x,0}$ 表示 $x$ 本身是一个`服务器`，由于没有规定两个`服务器`不能相邻，所以点 $x$ 的父亲节点与儿子节点是不是`服务器`都无所谓。

- $dp_{x,1}$ 表示 $x$ 的父亲是一个`服务器`，$x$ 是一个`客户端`，因为每个`客户端`只能**恰好**与一个`服务器`相连，所以 $x$ 的儿子节点全部不是`服务器`。

- $dp_{x,2}$ 表示 $x$ 的父亲与 $x$ 都不是`服务器`，而 $x$ 的儿子节点中恰好有一个是`服务器`。

然后我们考虑如何转移。

为了方便阐述，下文中的 $y$ 为 $x$ 的儿子节点，定义集合 $S$ 为 $x$ 的所有子节点的集合。

首先对于 $dp_{x,0}$，那么从定义本身出发，我们可以发现，$dp_{y,0}$ 和 $dp_{y,1}$ 与 $dp_{x,0}$ 是不矛盾的，而 $dp_{y,2}$ 要求了 $y$ 的父亲也就是 $x$ 不能为`服务器`，所以矛盾。所以得到如下公式：
$$
\boxed{dp_{x,0}=\sum\limits_{y\in S} \min(dp_{y,0},dp_{y,1})}
$$
然后对于 $dp_{x,1}$，要求 $x$ 与 $x$ 儿子(也就是 $y$)都不是`服务器`，所以只有 $dp_{y,2}$ 满足要求。所以得到如下公式：
$$
\boxed{dp_{x,1}=\sum\limits_{y\in S}dp_{y,2}}
$$
最后对于 $dp_{x,2}$，我们可以发现，对于节点 $y$，它需要是一个`服务器`，所以需要加上 $dp_{y,0}$，对于其他的节点 $z\in S-\{y\}$，这个点与其父亲节点（也就是 $x$）都是`客户端`，所以我们需要加上 $dp_{z,2}$。所以得到如下公式：
$$
\boxed{dp_{x,2}=\sum\limits_{y\in S}(dp_{y,0}+\sum\limits_{z\in S-y} dp_{z,2})}
$$
然后就可以了吗？不。不行，为什么呢？

因为这个 $dp_{x,2}$ 的转移是 $\Theta\left( n^2 \right)$ 的，会妥妥地 $\color{white}\colorbox{darkblue}{TLE}$ 掉。

然后我们就可以考虑如何优化。

我们可以发现，上文中的 $dp_{x,1}$ 就是 $\sum\limits_{y\in S} dp_{y,2}$，所以我们其实只需要处理以下，就可以得到如下式子：
$$
\boxed{dp_{x,2}=\sum\limits_{y\in S} dp_{x,1}-dp_{y,2}+dp_{y,0}}
$$
考虑最后的答案，由于根结点并没有父亲节点，所以答案就是 $\boxed{\min(dp_{root,0},dp_{root,2})}$。

于是我们就可以过这道题了。

## 代码展示

这里仅展示 $DFS$ 部分代码。

```cpp
void dfs(int x,int fa){
	dp[x][0]=1;dp[x][1]=0;dp[x][2]=maxn;
    //答案最大为n，所以dp[x][2]赋为maxn就可以了。
	for(int i=bg[x];i;i=ne[i]){
		int y=to[i];
		if(y==fa){
			continue;
		}
		dfs(y,x);
		dp[x][0]+=min(dp[y][0],dp[y][1]);
		dp[x][1]+=dp[y][2];//更新dp[x][0]和dp[x][1]
	}
	for(int i=bg[x];i;i=ne[i]){//由于更新dp[x][2]需要用到dp[x][1]，所以我们需要重新循环
		int y=to[i];
		if(y==fa){
			continue;
		}
		dp[x][2]=min(dp[x][2],dp[x][1]-dp[y][2]+dp[y][0]);
	}
}
```
