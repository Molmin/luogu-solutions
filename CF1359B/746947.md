看到好多大佬用的是 DP，~~可我这个蒟蒻不会~~，便写了篇模拟。

首先，我们看到它只有两种情况：

- 有 $1\times1$ 的砖块，需要 $x$ 元。
- 有 $1\times2$ 的砖块，需要 $y$ 元。（注意 $1\times2$ 的砖块要横着放）

然后因为没有竖着放的砖块，所以我们可以分行判断。

在分行判断时，还要先判断是那个跟实惠：

- 如果 $1\times1$ 的砖块的 $2$ 倍 $\le1\times2$ 的砖块，那么我们就只需判断有多少个砖块，再乘上 $x$；
- 如果上面的条件不成立，我们就判断是否有两个连起来的，如果有，将他们打上记号，并将 $ans$ 加上 $y$ 即可。

具体看代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int main() {
	int t;    //有多少组数据 
	cin >> t;
	while (t--) {
		int a, b, c, d, ans = 0;    //a为行数,b为列数,c为1*1的砖块所要的钱,d为1*2的砖块的钱,ans为总钱数。 
		cin >> a >> b >> c >> d;
		char n[b + 1];
		while (a--) {    //有几行，每行分行判断 
			for (int i = 0; i < b; i++)cin >> n[i];    //输入一行的黑白砖块 
			if (c * 2 <= d) {    //如果1*1的砖块的两倍比1*2的砖块所用的价格少，就用1*1的 
				for (int i = 0; i < b; i++) {
					if (n[i] == '.')ans += c;    //再循环里就加上 
				}
			} else {    //否则用1*2的 
				for (int i = 0; i < b; i++) {
					if (i + 1 < b) {
						if (n[i] == '.' && n[i + 1] == '.')
							n[i] = '*', n[i + 1] = '*', ans += d;    //注意打记号 
						else if (n[i] == '.')
							n[i] = '*', ans += c;
					} else {
						if (n[i] == '.')ans += c;    //最后一个砖块的特判 
					}
				}
			}
		}
		cout << ans << endl;    //输出 
	}
	return 0;
}
```
