怎么原有题解那么多，和我的做法都不一样。

首先简述一下题意，有一个三角形，一个数字掉落，它上面的两个数字都会掉落。每次查询给出掉落的数字 $n$，求最后所有掉落数字的平方的和。

原图是这样：

![](https://espresso.codeforces.com/3f72320a7f225babc9b2b244a719e59e9e8f028d.png)

挪一下，修改成这样：

```
 1
 2  3
 4  5  6
 7  8  9 10
11 12 13 14 15
......
```
这样变成了一个二维数组，剩下的没数字的地方默认为 $0$。

然后考虑递推，设 $k$ 为 $(i,j)$ 上的数字，$s_{i,j}$ 为 $k$ 上的数字掉落的答案。

注意到 $(i,j)$ 掉落之后，上面的两个数字即 $(i-1,j-1)$ 和 $(i-1,j)$ 都会掉落，那么貌似有 $s_{i,j}=k^2+s_{i-1,j-1}+s_{i-1,j}$。

然而这是错的。

分析原因：

$(i-1,j-1)$ 上面的两个数字为 $(i-2,j-2)$ 和 $(i-2,j-1)$。

$(i-1,j)$ 上面的两个数字为 $(i-2,j-1)$ 和 $(i-2,j)$。

容易发现，如果直接相加，$s_{i-2,j-1}$ 就多计算一遍，那么减去即可。

正确的递推式为：$s_{i,j}=k^2+s_{i-1,j-1}+s_{i-1,j}-s_{i-2,j-1}$。

注意点：

- 递推式中出现了 $i-2$，所以要初始化至少第 $1$ 行（第 $0$ 行全为 $0$）。

- 还有个技巧，为了方便处理，对数字到坐标建立一个映射， $(x_i,y_i)$ 为数字 $i$ 的坐标。

核心代码见下，由于是一次跑完全部数据，运行一遍即可应付所有查询：

```cpp
//注意这几个数组的大小
//maxn=1e6，n 的最大可能取值
s[1][1]=1,x[1]=y[1]=1;
	for(i=2,k=2;k<=maxn;i++)
		for(j=1;j<=i&&k<=maxn;j++,k++)
			x[k]=i,y[k]=j,s[i][j]=k*k+s[i-1][j-1]+s[i-1][j]-s[i-2][j-1];
```

全文完。