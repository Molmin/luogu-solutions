推倒 $9$ 号纸杯后，$5,6$ 号也会跟着倒下，按理来说推倒 $5,6$ 号的总分数应该和 $9$ 号有关系，但是他们俩加起来却不等于 $9$ 的值，因为 $5,6$ 号的共同父亲 $3$ 被推倒的总分数被加了两遍，所以将其减去即可。

但是要想让上面的思路变成 $O(n)$，就需要我们在每个位置存储在推倒这个位置后得到的总分数，这里我用的是二维数组模拟了这个纸杯的摆放并存储。

那么这个时候对于一个 $f_{i,j}$ 因为要模拟这些纸杯的摆放位置，所以 $j\leq i$ ，它的两个父亲就是 $f_{i-1,j-1},f_{i-1,j}$。重复加的值，即两个父亲的共同父亲就是 $f_{i-2,j-1}$。

注意 $1$ 的位置要特判，因为不特判的话这个点会访问到 $f_{-1,0}$，就会爆炸。 

DP 式：

$$
f_{i,j}=
\left\{\begin{matrix}
1 & i=1\\ 
f_{i-1,j-1}+f_{i-1,j}-f_{i-2,j-1}&i>1\\
\end{matrix}\right.
$$

代码：

```cpp
#include<iostream>
using namespace std;
long long t,n,cnt=1,a[2001][2001],b[4000001];
int main(){
    cin>>t;
    for(int i=1;i<=2000;i++){
        for(int j=1;j<=i;j++){
            a[i][j]=(i==1? 1:cnt*cnt+a[i-1][j-1]+a[i-1][j]-a[i-2][j-1]);
            b[cnt]=a[i][j];
            cnt++;
        }
    }
    while(t--){
        cin>>n;
        cout<<b[n]<<endl;
    }
}
```
