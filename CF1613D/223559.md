### 解题思路：

考虑动态规划。

设 $f_{i,j,0/1}$ 表示到第 $i$ 位为止 $MEX$（$MEX$ 同原题定义）等于 $j$ 的方案数，$0$ 表示没有比 $MEX$ 大一的数，$1$ 则表示有。

当出现了在第 $i$ 位的一个数 $j$，推出可能的可以构成的方案是 $f_{i-1,j,0}$、$f_{i-1,j+1,0}$、$f_{i-1,j+1,1}$、$f_{i-1,j-1,0}$、$f_{i-1,j-1,1}$，分别表示 $MEX$ 等于 $j$ 且不存在数 $MEX+1$ 即 $j+1$，$MEX$ 等于 $j+1$ 的有或者没有 $MEX+1$ 即 $j+2$ 两种，$MEX$ 等于 $j-1$ 的有或者没有 $MEX+1$ 即 $j$ 两种。

注意如果选择 $MEX$ 等于 $j$ 且此时存在 $MEX+1$，就会将当前 $MEX$ 直接增大到 $MEX+2$，不满足要求，故不能取。

---

然后考虑对于 $f$ 数组的转移，考虑选择了 $j$ 之后有哪些状态可能存在新的方案，首先所有的 $f_{i,j,0/1}$ 都有对应的 $f_{i-1,j,0/1}$ 种方案，也就是直接不取，$f_{i,j+1,0}$ 可以由 $f_{i-1,j-1,0}$ 和 $f_{i-1,j+1,0}$（选择了之后 $MEX$ 不变，但是确实是一种新的方案）转移，$f_{i,j+1,1}$ 可能方案数是，$f_{i,j-1,1}$ 可以由 $f_{i-1,j-1,1}$ 转移，$f_{i,j-1,1}$ 此时由于存在了 $MEX+1$，可以由 $f_{i,j-1,0}$ 和 $f_{i,j-1,1}$ 转移过来。

直接这样做不可取，注意到第一维其实可以直接压掉，那么空间就只剩下两维了，其中还有一维是常数。

初始时，$f_{0,0}$ 为 $1$，因为直接不取就是一种可行的方案。

---
注意取模。

---
### 代码：

```cpp
#include<cstdio>
#include<cstring>
using namespace std;
#define int long long
int T,n,a[500005],f[500005][2],ans;
const int MOD=998244353;
signed main(){
	scanf("%I64d",&T);
	while(T--){
		scanf("%I64d",&n);
		for(int i=1;i<=n;i++)scanf("%I64d",&a[i]);
		for(int i=0;i<=n+2;i++)f[i][0]=f[i][1]=0;
//		memset(f,0,sizeof(f));
		f[0][0]=1;ans=0;
		for(int i=1;i<=n;i++){
			ans=(ans+f[a[i]][0])%MOD;
			ans=(ans+f[a[i]+1][0]+f[a[i]+1][1])%MOD;
			if(a[i]>=1)ans=(ans+f[a[i]-1][0]+f[a[i]-1][1])%MOD;
			
			f[a[i]+1][0]=(f[a[i]+1][0]+f[a[i]][0]+f[a[i]+1][0])%MOD;
			f[a[i]+1][1]=(f[a[i]+1][1]+f[a[i]+1][1])%MOD;
			if(a[i]>=1){
				f[a[i]-1][1]=(f[a[i]-1][1]+f[a[i]-1][1]+f[a[i]-1][0])%MOD;
			}
		}
		printf("%I64d\n",ans%MOD);
	}
	return 0;
}
```
