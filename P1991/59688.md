~~我有点神志不清所有有了这篇题解~~。

这道题的大意是有点难理解的至少我直接理解错了，
以为是一个裸的最小生成树然后直接标记点的个数统计答案。

但事实上并非如此 原因是 这道题的本意是一个瓶颈生成树
瓶颈生成树是 对于这样的一棵树 其最大的边权小于<=x。

引理：

- 最小生成树一定是瓶颈生成树
- 瓶颈生成树并非最小生成树

第二条显然不需要证明，对于第一条性质 
我们可以这样想如果一个最小生成树不是瓶颈生成树那其一边一定是>x的但是对于这样一条边连在了树上那么我们完全可以更改成<=x的边连在这颗树上，构成新的最小生成树 这和最小生成树冲突 故原命题成立。

论这道题的话其实求的是还是最小生成树 题目的意思的话是让我们去掉m-1条边后最大的那条边的值。

我wa过60仔细思考是 不能模拟点被安装电话的过程 原因是

我们是在自己生成的树中安装的电话 而这样并非最优，去掉m-1条边的原因是 m个点连起来最多创造m-1条边。这时答案怎么统计其实可以克鲁斯卡尔的时候直接统计即可。

```
sort(s+1,s+1+top);
    for(int i=1;i<=top;++i)
    {
        int xx=getfather(s[i].x);
        int yy=getfather(s[i].y);
        if(xx==yy)continue;
        f[xx]=yy;++w;
        if(n-w==m){printf("%.2lf",s[i].z);break;}
     }
```
对于当前已经生成了w条边 总共要生成n-1条边 我们可以搭建的只有m-1条边 故当 n-1-w==m-1后面的边都可以被省掉。
答案也就是上一条生成的边。

~~我也不知道自己脑抽了一直证明这个过程。。~~