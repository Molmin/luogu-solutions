所以说，做题前先看看标签

**Special Judge**

再看看题目就会发现：

## 这题没有标准答案！

看有些发题解的人没讲全，那我来补一补

## 首先，为什么这题是多解题

这个事实几乎所有直接输y的同学都说了，没说的是少部分

题目描述中讲了：

	找出任何一个满足 f(x,z)=y 的字符串 z。如果找不到这样的字符串的话，请输出-1。
    
其实已经可以看出不止一个解了。

再看：

	g[i]=min(s1[i],s2[i])
    
这里s2是未知的，告诉了你g。那么，g就不可能比s1小。

这么看来，**s2的每一位可以是对应的s1的那一位到g对应的那一位之间的任意一个字母**

综上，此题没有正确答案。

## 那么，怎么做？

上面讲了：

	s2的每一位可以是对应的s1的那一位到g对应的那一位之间的任意一个字母

既然如此，我们为何不直接输出g呢？

这样既方便，又满足了成立的条件。

另外，也要保证g的任何一位都不比s1小。否则，就输出“-1”

这个思路，也就是大多数dalao的常规思路。

代码：

```
#include<bits/stdc++.h>
using namespace std;
string x,y;
int main(){
	int n;
	cin >> n;
	cin >> x;
	cin >> y;
	for ( int i = 0 ; i <= n ; i++ )  //这里就是把两个字符串比较一下大小，看有没有结果
	{
		if ( x[i] < y[i] )  //不符合条件
		{
			cout << "-1" << endl;
			return 0;
		}
	}
	cout << y;  //x的任何一位都比y大，这么y就是答案
	return 0;
}
```

但另外还有一种做法，可以说是常规思路上的简化版，更容易想到，但更烦。

基本思路就是在判断出有结果后，再生成一个答案字符串。这个答案字符串是在x和y两个字符串中提取出来的。

这个程序我也写过，但只有36分，就不贴出来了。

这个思路的具体解析可以看一下[这位大佬的博客](https://www.luogu.org/blog/wdssp0608/solution-3742)