## 前言

不算难的一个题，冷静下来思考还挺简单的，~~但是我考场上就是冷静不下来，少判断了一种情况~~，思路可能和大家的不太一样，有不严谨的地方还请多多包涵(^_^)

## 题意

有一个图，图中一些点间有边，每次操作选择一个点，将所有与此点相连的边去掉，再把原来没有和此点**直接相连**的点连边，问能否通过一个操作序列将原图变为一个每两点间都相连的图。

模拟一下样例 3 来理解一下题意。

![](https://cdn.luogu.com.cn/upload/image_hosting/pufl4av9.png)

## 思路

有两个显而易见的结论：

 - 选择点进行操作的顺序不同对答案没有影响。
 - 对于每个点，操作两次不如操作。


因此，由第二个结论，每个点我们只有操作与不操作两种选择。
 
重点在证明下一个命题。
 
 
 - 若此图能变为每两点之间都相连的图，则每个连通块内的点都两两相连。
 
 
这里我们使用反证法，若某个连通块内有两点没有两两相连（设为 $a$ 和 $b$）为了让 $a$ 和 $b$ 相连，我们必定要按下其中一个点，且只能按下一个点。假定我们按下的点为 $a$，为了使整个图符合要求，还需要按下与 $a$ 相连的所有点。
 
 
通过一系列类似于广搜的操作后，由于 $a$ 和 $b$ 在一个连通块内，一定会遍历到 $b$，所以 $a$ 和 $b$ 间的边一定会被操作两次，无法相连。
 
 
综上，每个连通块内的点都两两相连。

对于不同连通块之间，只需要将其中一个连通块全部操作一遍就可以相连。

接下来要做的事情就简单了，只需要判断每个联通块内的点是否两两相连即可。
 
## 代码

```cpp
#include<iostream>
using namespace std;

const int N = 1e3 + 10;
int edge[N][N];
int n, m;

void check( );

int main( ) {
	cin >> n >> m;
	if(m == 0) {
		cout << "NE" << endl;
		return 0;
	} 
	
	for(int i = 1; i <= n; i++) edge[i][i] = true;
	
	for(int i = 1; i <= m; i++) {
		int a, b;
		cin >> a >> b;
		edge[a][b] = edge[b][a] = true;
	}
	
	check( );
	
	return 0;
}

void check( ) {
	for(int i = 1; i <= n; i++) //枚举一个点
		for(int j = 1; j <= n; j++) //枚举另一个点
			if(edge[i][j]) //若两点相连
				for(int k = 1; k <= n; k++) // 判断两点所联通的点是否完全一样
					if(edge[i][k] ^ edge[j][k]) {
						cout << "NE" << endl;
						exit(0);
					}
	cout << "DA" << endl;
}
```
