# 本人第一篇题解，多多包涵！

~~机房蒟蒻一枚~~

废话不多说，直接开始吧。

------------

## 首先，

我们先考虑一件事情，对于任意一个城市，它是否会被进行两次操作呢？显然是不会的。我们可以把当前点 $i$ 的航线状态假想成一个二进制数 $d$（以 $n=5$ 为例），并设  $d$ 为任意状态（以 00100 为例，不考虑自身），则更改后的航线为：11011。假设经过若干其他点的更改后，$d$ 变成了 11111，再自身更改后便成为 00000。显然，这与直接在原状态 00100 上做修改所得的结果是一致的。也就是说，每个城市只有一种**更改状态**（改或不改）。

（这里说的有点啰嗦，可以直接把更改操作类比为亦或）

（这里的结论可以用作 40 分状压或暴搜的基础）

------------

## 其次，

我们再思考一个问题，对于当前城市 $i$ 的**更改状态**，若被唯一确定后，其所链接的其他所有城市的更改状态都是可以确定的吗？这是当然，因为一个城市的更改状态只与本身边的存否和对应边的另一城市的更改状态有关，所以就可以由此推出 AC 算法：随意确定一个基准城市，再搜边并作更改，最后 check 一下就可以了。

~~代码有点丑，还请谅解~~

```
#include<bits/stdc++.h>
using namespace std;
bool a[1005][1005][2];//0为本身不改，1为本身改 
int n,m,x,y;
void UpsideDown(int num, bool d)
{
	for(int i=1;i<=n;i++)
	{
		a[num][i][d]^=1;
		a[i][num][d]^=1;
	}
}
bool check()
{
	bool ans1=0,ans2=0;
	for(int i=2;i<=n;i++)
	{
		for(int j=2;j<=n;j++)
		{
			if(i==j) continue;
			if(!a[i][j][0]) ans1=1;
			if(!a[i][j][1]) ans2=1;
		}
	}
	return ans1&ans2;
}
int main()
{
	cin>>n>>m;
	while(m--)
	{
		cin>>x>>y;
		a[x][y][0]=1;a[y][x][0]=1;
		a[x][y][1]=1;a[y][x][1]=1;
	}
	//以1点为标准
	for(int i=2;i<=n;i++)
	{
		a[1][i][1]^=1;
		a[i][1][1]^=1;
		if(!a[1][i][0])
			UpsideDown(i,0);
		if(!a[1][i][1])
			UpsideDown(i,1);
	}
	if(check()) cout<<"NE";
	else cout<<"DA";
	return 0;
}

```

## 最后，

其实这就是两个完全图的构造存在性问题（~~反正也听不懂~~）

希望能过吧。。。谢谢观看！
