**题解 [CF133B 【Unary】](https://www.luogu.com.cn/problem/CF133B)**  

# Description  
就是给你一些字符，每一个字符都有它所代表的数字，代表的数字如下表：    

```	'>'  	->	1000
	'<'		->	1001
    '+'		->	1010
    '-'		->	1011
    '.'		->	1100
    ','		->	1101
    '['		->	1110
    ']'		->	1111
```


（blog里面的表格好像挂了，看题解界面上的吧）  
上述数字均为二进制数。把这些字符拼在一起，组成一个**巨大**的二进制数，求把它转换成十进制后对 $10^6+3$ 取模的值。  

# Solution  
既然要我们最后把它转成十进制，那就不妨先把字符代表的二进制数转为十进制。所以现在的难点就是拼接。  
仔细观察上面的二进制数，我们会发现它们都是四位的，于是对于之前拼接的结果设为 $ans$ ，对于每一次拼接，只需要将 $ans$ 向左移4位即可，不要忘记取模。  

# Code
```cpp
#include <bits/stdc++.h>
using namespace std;

const int mod = 1e6 + 3;

map<char,int> mp;

char ch;
int ans;

void init() {	//开一个map，把所有字符所代表的的值存到map里
	mp['>'] = 8; mp['<'] = 9;
	mp['+'] = 10; mp['-'] = 11;
	mp['.'] = 12; mp[','] = 13;
	mp['['] = 14; mp[']'] = 15;
}

int main() {
	init();
	while(scanf("%c",&ch) != EOF) {
		if(ch != '\n') ans = ((ans << 4) % mod + mp[ch]) % mod;	//注意，ans自身乘以16之后为了保险建议对这个值先进行一次取模，最后对总值进行一次取模
		else break;
	}
	printf("%d\n",(ans + mod) % mod);	//以防莫名其妙的负数出现，所以在多加一次取模，但是这题应该是不可能的
	return 0;
}
```