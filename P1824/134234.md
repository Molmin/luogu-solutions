其实这是一道二分的题。~~一开始我根本没看出来，但在我借鉴了一下题解后。~~这确实是一道二分的题
------------
 上面已经有daolao讲过区间的确定了。
 那我们就讲一下其中的一些小细节

------------
a[i]指n个瓶盖的距离，tot指丢的瓶盖数，num其实就是判断下一个瓶盖丢在哪里的一个动点
在chk函数里面
因为第一个瓶盖一定丢在1号位置上（最近的距离最大嘛）（让头最小），此时动点num在a[i]这个位置
if(a[i]-a[num]>=x) 如果某一个点到1号点的距离比x大，那我就找到了下一个瓶盖可以丢的位置，所以丢的瓶盖数++。此时动点num要移到i这个点，去找更大的间隔。

------------
最后return tot>=m;意思是我丢的瓶盖已经比总的瓶盖数还多了，这就和下面的主函数联系起来了

------------
在主函数里面一定要排序的，把间隔由低到高排序,后面会由间隔低的向高的找

------------
拍完序过后就是二分的精髓了
if(chk(mid))l=mid;     如果mid>=m 说明选的mid太小了导致丢的瓶盖数量太多了，所以我的间隔找小了，要往间隔大的找，（前面的间隔都很小嘛）那么应该把mid移到后面去，去找刚好丢够瓶盖数。而且mid这个点可能成立（因为return>=嘛） 

------------
 else r=mid-1; 如果mid小于m，说明间隔取大了，瓶盖丢少了（后面的间隔更大嘛，所以肯定不能在后面找）就该在前面找 并且mid这个点一定不成立 

------------
你以为完了吗，当然没有。
这里有个坑就是r=1000000000；我也不知道是为什么。可能是他给的样例太特殊了吧。
```
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
int n,m;
int a[100000+500];
int chk(int x){
	int tot=1;int num=1;
	for(int i=2;i<=n;i++){
		if(a[i]-a[num]>=x){
			tot++;
			num=i;
		
		}
	}return tot>=m;
   
}
int main(){
	scanf("%d%d",&n,&m);
	int l=1,r=1000000000;
	for(int i=1;i<=n;i++){
		scanf("%d",&a[i]);
	}
	sort(a+1,a+1+n);
	while(l<r){
		int mid=(l+r+1)/2;
		if(chk(mid))l=mid;
      else r=mid-1; 
	}
	printf("%d",l);
	return 0;
}