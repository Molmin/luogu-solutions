本题的**二分**很好想到

\_上下界确定\_

l=0,r=最大的距离-最小的距离+1

当然，如果r不取这么准，同样没关系，这样是为了缩短一点时间

-----------------------------------------------------------------------------------------------------------------------------------------------------------

\_单调性明显\_

显然，当距离越短时，能选的瓶盖就越多；距离越大，能选的瓶盖就越少

则当距离（用x来表示）<=某一个值时（即ans），F(x)（F是判断该距离能否选到m个瓶盖）恒等于true;

当x>ans时，F(x)恒等于false;

则本题即是在最小值中求最大值

最小值中求最大值模板

```cpp
while(l<r)
{
    mid=(l+r+1)/2;//注意！！！mid（中点）的值此时必须上取整
    if(ALICE(mid)==true)//可爱的函数名
        l=mid;
    else
        r=mid-1;//注意！！！这里是原因。mid上取整之后，mid若是实数，则r取的是mid的下取整；mid若是整数......**前后呼应**
}
```
-----------------------------------------------------------------------------------------------------------------------------------------------------------
**华丽丽的代码**




```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
int n,m,a[100002];
bool ALICE(int x)
{
    int i,j,cnt;
    for(i=1,cnt=0;i<=n;)
    {
        for(j=i;j<=n&&a[j+1]-a[i]<x;j++);//每次从前往后找离第i个瓶盖距离超过x的第一个瓶盖
        i=j+1;
        cnt++;//记录当前距离可用瓶盖数量
    }
    return cnt>=m;//注意！！！若能取多于m个瓶盖，则应调整下界，使距离变大；少于m,使距离变小；正好m个,为了距离更大,调整下界
}
int main()
{
    int i,l,r,mid;
    scanf("%d%d",&n,&m);
    for(i=1;i<=n;i++)
        scanf("%d",&a[i]);
    sort(a+1,a+1+n);
    for(l=0,r=a[n]-a[1]+1;l<r;)
    {
        mid=(l+r+1)/2;
        if(ALICE(mid)==true)
            l=mid;
        else
            r=mid-1;
    }
    printf("%d\n",l);
    return 0;
}

```