```c
#include<bits/stdc++.h>
using namespace std;
int n,b;
int a[1005*1005];
inline bool check(int x) {
	//x是下面二分出来的距离
	int len=a[1]+x;//这是check函数
	//这里的len是根据x(两点之间的距离嘛，注意是最小距离)
	//所以这里a[1]+x就相当于在预处理,具体作用看下面
	int cnt=1;//计数，拿出瓶盖
	for(int i=2; i<=n; i++) {
		if(a[i]>=len) {
			//因为x是最小距离的最大值(此处假设，毕竟还没有二分完)
			//那么那个啥最小值的最大值甭管，只需要知道它是最小值就可以了
			//那么竟然是距离最小值，所以a[i-1]+x(及len)应该<=a[i]
			cnt++;//满足条件就cnt++
			len=a[i]+x;//刷新
		}
	}
	if(cnt>=b)//看满足条件没有
		//注意，最开始我以为是cnt==b
		//但是错了，仔细想了想，题目要求只需要拿出b个瓶盖，但是如果我有
		//大于b个瓶盖可以拿出来满足条件，那是没有影响的啊，多的不拿就是了
		return 1;
	return 0;
}
int main() {
	ios::sync_with_stdio(false);
	cin>>n>>b;
	for(int i=1; i<=n; i++)
		cin>>a[i];
	sort(a+1,a+1+n);//二分的条件是，单调哟,这里要单调递增 
	int l=0,r=a[n]-a[1];//二分范围，最大距离肯定是第一个和最后一个之间的距离
	//单调递增嘛
	while(l<r) {
		int mid=(l+r+1)>>1;
		//本来写的mid=(l+r)>>1
		//于是只有40分,其他的都是TLE
		//我们来思考一下，二分TLE不正常啊？
		//很明显出现了死循环
		//比如l=2,r=3;那么mid=5>>1==2;
		//如果是check返回1的话，那么l和r将永远卡在2和3
		//所以我们取得mid要靠右，就是(l+r+1)/2;
		if(check(mid))
			l=mid;//这是一个最小值得最大化问题
			//做个形象的假设，最小值的最大化就比喻为一群男生去追校花 
			//求不能获得校花芳心的弱鸡男里面的最强男
			//此处的校花很花心，只要满足她对于男生能力要求，就可以将这个男生纳入后宫 
			//那么check为ture就说明这位兄弟不能获得校花芳心
			//那比他更弱鸡的一定不行，于是只能l~r的一群男生里继续找
			//记住l==mid哟，因为此时的这个弱鸡男也是一组解，只是不一定是最优解 
		else {
			r=mid-1;
			//check为false的话，就说明，这个男生可以获得校花芳心
			//那么比他强的男生，也一定可以获得校花芳心，成为校花的后宫
			// 所以只能去l~(mid-1)去寻找
			//很形象吧 
		}
	}
	cout<<l;//结束条件是l==r，所以输出r也是一样的，问题不大，因为没有ans记录答案 
	return 0;
}
```
