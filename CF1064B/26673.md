### 解题思路

把 $a \oplus x$ 这项移到右边，我们得到：

$$a - x = a \oplus x$$

这道题巧妙在于，不同**二进制位**对答案的贡献**互不影响**。$\oplus$ 本身就是定义于二进制的运算，尽管某个二进制位 $-$ 运算可能会产生负数，但一旦有负数产生，就不会对答案产生贡献，更别提是否影响其他位的贡献了，以上通过**归纳法**可以证明。

于是，我们只需要关心 $a,\ x \in \{0,\ 1\}$ 时解的情况。考虑使用**列表法**：

||||||
| :-: | :-: | :-: | :-: | :-: |
| $\ \ \ \ \ \ $ $a$ $\ \ \ \ \ \ $ | $\ \ \ \ \ \ $ $x$ $\ \ \ \ \ \ $ | $\ \ \ \ \ \ $ $a - x$ $\ \ \ \ \ \ $ | $\ \ \ \ \ \ $ $a \oplus x$ $\ \ \ \ \ \ $ | $\ \ \ \ \ \ $ $a - x = a \oplus x$ $\ \ \ \ \ \ $ |
| $\ \ \ \ \ \ $ $0$ $\ \ \ \ \ \ $ | $\ \ \ \ \ \ $ $0$ $\ \ \ \ \ \ $ | $\ \ \ \ \ \ $ $0$ $\ \ \ \ \ \ $ | $\ \ \ \ \ \ $ $0$ $\ \ \ \ \ \ $ | $\ \ \ \ \ \ $ 满足 $\ \ \ \ \ \ $ |
| $\ \ \ \ \ \ $ $0$ $\ \ \ \ \ \ $ | $\ \ \ \ \ \ $ $1$ $\ \ \ \ \ \ $ | $\ \ \ \ \ \ $ $-1$ $\ \ \ \ \ \ $ |  $\ \ \ \ \ \ $ $1$ $\ \ \ \ \ \ $ | $\ \ \ \ \ \ $ 不满足 $\ \ \ \ \ \ $ |
| $\ \ \ \ \ \ $ $1$ $\ \ \ \ \ \ $ | $\ \ \ \ \ \ $ $0$ $\ \ \ \ \ \ $ | $\ \ \ \ \ \ $ $1$ $\ \ \ \ \ \ $ | $\ \ \ \ \ \ $ $1$ $\ \ \ \ \ \ $  | $\ \ \ \ \ \ $ 满足 $\ \ \ \ \ \ $ |
| $\ \ \ \ \ \ $ $1$ $\ \ \ \ \ \ $ | $\ \ \ \ \ \ $ $1$ $\ \ \ \ \ \ $ | $\ \ \ \ \ \ $ $0$ $\ \ \ \ \ \ $ | $\ \ \ \ \ \ $ $0$ $\ \ \ \ \ \ $ | $\ \ \ \ \ \ $ 满足 $\ \ \ \ \ \ $ |

容易发现，当 $a = 0$ 时，$x$ 只有一个解，当 $a = 1$ 时，$x$ 有两个解。

回到一般情况，因为每个二进制位的贡献互不影响，所以将它们的贡献相乘就是答案。因此，当某个二进制位 $= 0$，它的贡献 $= 1$，相当于没贡献，当某个二进制位 $= 1$，它的贡献 $= 2$。也就是说，只要知道 $a$ 的二进制中有多少位是 $1$，答案就是其 $2$ 的幂次方。

二进制中多少位是 $1$？暴力求吗？不！$\_\_builtin\_popcount$ 函数多方便！

### 代码实现

在 $\_\_builtin\_popcount$ 和~~原力压行~~的帮助下，代码看上去非常短。

```cpp
#include <iostream>

int main() {
    int n; std::cin >> n;
    while (std::cin >> n) { std::cout << (1 << __builtin_popcount(n)) << std::endl; }
    return 0;   
}
```