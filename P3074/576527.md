[原题传送门](https://www.luogu.com.cn/problem/P3074)

这道题大部分人都是写拓补排序的，我补充一下巨佬 [dingcx](https://www.luogu.com.cn/user/130981) 的做法，可能也算是拓补排序的一种吧。

其实这种做法可以理解成一开始我们有许多棵树，我们要做的就是找到一条从根走到叶，走过的点的和最大。以下面这组样例为例：
```
10 5
1 2 3 4 5 6 7 8 9 10
1 3
2 3
3 5
4 5
5 7
```

![](https://cdn.luogu.com.cn/upload/image_hosting/9e6fcz1u.png)

我们可以把点 $1$、$2$、$4$、$6$、$8$、$9$、$10$ 当作树根，要走到其对应的叶子节点。

对于这个问题，我们可以使用深搜解决，把每个点当作根进行搜索，时间复杂度最坏为 $O(n^2)$，妥妥的 TLE，考虑剪枝。

我们发现，我们在做的时候会有很多重复的情况，以上图为例，$5$ 会被走到 $3$ 次，这就导致了许多重复的查询，我们可以采用记忆化，即记录每个点的结果，当再次访问时就不必再重做一遍，这样就可以把复杂度优化到 $O(n)$。

以下是代码的核心部分，记忆化搜索：
```cpp
int sum(int k){
	int cnt=0;
	if(b[k]) return t[k];
	for(int i=0;i<v[k].size();i++){
		cnt=max(sum(v[k][i]),cnt);
	}
	b[k]=1;
	t[k]=cnt+t[k];
	return t[k];
}
```
其中 ```b``` 数组用于记录每个点的结果是否算过，``` t ``` 数组即输入进来的数，```v``` 数组记录子节点，应开成 ```vector```，否则会 MLE。在主函数中就直接便利每个点即可，最后取最大值。