什么树形dp总结我就不讲了（太多了），这里只讲下**这道题**（~~主要是第一次接触题解我没一个看懂的~~），
### 但是
注意对于**树形dp的dfs**，其回溯时**已访问的节点**（**也就是子节点**）的dp值**总是处理好的**

---
### 定义


| f[ ][ ] |
| :----------: |



表示状态、



| w[ ]  |
| :----------: |




表示权值；

**f[i][j]** 代表**以i为根**的树选它的**j个子节点**和**自己**的**最大权值**

---
# 1. 
首先初始化时可以**发现**对于任意


| f[i][k] _{k属于正整数}_  |
| :----------: |



总有最小值



| w[i] |
| :----------: |



（其实就是当f状态有意义时总是选**i**）

---
### 于是


```cpp
for(int tmp =m/*可能取到的最大值*/; tmp >= 0; tmp--) f[i][tmp] =w[nw];
```


---
# 2.

接着列出状态转移方程


| f[i][j] =max(f[i][j], f[i][j-k-1]+f[son][k]) _{k属于正整数， son是i的子节点}_  |
| :----------: |


可以将子节点想象为**物品**，其选了多少点想象为**花费** 

（同时可能取到的k**总不超过m**，所以程序中就将k上限**设为m**）

---
### 注意



| j-k-1 |
| :----------: |



**"-1"** 是因为这里f状态的第二个下标代表的是**选它某数量的子节点**而不包括自己，同时题目的从属关系令f状态有意义时**i**（**其实就是这颗树的父亲**）必须选

-----
# 3.
到这里其实就差不多了，剩下还有就是程序中用一个不存在的节点"0"作为森林**所有树的父节点**，方便深搜处理

```cpp
#include <cstdio>
#include <string.h>
#include <algorithm>
using namespace std;

int first[301], w[301], n, m;
int next[300], to[300];
//我也不能确定<这种>通过存边的方式来存图的方法具体叫什么...总之稀疏图这么做就对了

inline void init(){
	int x;
	//first储存每个点的第一条边的"ID"，next存这条边的“下一条边”编号...理解下
	memset(first, -1, sizeof(first));
	for(int i =1; i <= n; i++){
		scanf("%d%d", &x, &w[i]);
		to[i-1] =i;
		next[i-1] =first[x];
		first[x] =i-1;
	}
}

int tp[301][301];//tp[i][j]i点选j个子节点这棵以i为根的树的最大值 

void dfs(int nw){
	int l =first[nw];
	for(int k =m; k >= 0; k--) tp[nw][k] =w[nw];//k顺序无所谓，总之把自己的值先塞进去 
	while(l != -1){
		dfs(to[l]);
		for(int j =m; j >= 0; j--)
			for(int k =0; k < j; k++)
				//如果难以理解的话试着将子节点想象为物品，其选了多少点想象为花费 
				tp[nw][j] =max(tp[nw][j], tp[nw][j-k-1]+tp[to[l]][k]);
    	//这边的技巧是分组背包的，不知道的得恶补下背包基础知识
		l =next[l];
	}
}

int main(){
	scanf("%d%d", &n, &m);
	init();
	
	dfs(0);
	printf("%d", tp[0][m]);
   //第二个下标是m是因为"0"这个节点不需要去"学"
}
```