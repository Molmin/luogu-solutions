选课这题，摆明了是一个树形的DP（因为课程之前存在从属关系），有同学就会质疑，这边数摆明不是树结构啊，但个人认为不会有环的存在，因此下面我们采用一种常用方法构建树。

构建一个虚的根节点0，把没有直接先修课的节点连上，我们最后的答案就是f[0][m+1]，指在节点0中选m+1个结点的最大学分。

f[i][j]表示在子树i中选了j门课的最大学分（包括本身）

我们在记录下每个点之前的联系关系之后，我们要开始不可缺少的一步———dfs，当然是从根节点开始，dfs（0）

在对每个儿子开始DP前，我们首先要处理完这个儿子，因此dfs(儿子)应该放在DP之前

    for (int i=head[x];i;i=next[i])
	{
		dfs(i);
		for (int j=m+1;j>=0;j--)
		for (int z=j-1;z>=0;z--)//之所以减一是因为必须要选了第x门课才能继续选
		f[x][j]=max(f[x][j],f[x][j-z]+f[i][z]);
	}
怎么样？这段代码是不是很像背包问题，那么我来解释一下状态转移方程

在第x节点中选j个点的最大学分等于在i节点（i是他的孩子）选z个点加上在x上选剩下的点的最大学分（说实话我自己也有些无法理解，但根据本蒟蒻的经验有的树形DP就是这样，具体原因我还没有细想）

那么其实就是这样了