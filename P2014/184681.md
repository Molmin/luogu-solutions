比较基础的树形dp我竟然搞了三天，不说了，过于蒟蒻。

首先我们知道所有dp其实都是爆搜的优化，那么优先想爆搜怎么办。

对于一个节点，假如必须选它，你要在这个节点的子树上选一些点， 然后让结果最大。那显然要枚举这个节点的每一个子树上要选几个节点，然后递归解决。

就比如某节点node有两个子节点，然后你可以选5个节点，除去node节点自己算一个，那么就要分配名额了，方案如下：

左0，右4

左1，右3

左2，右2

左3，右1

左4，右0

但若果节点数不止两个，那么枚举起来复杂度相当高，但是你观察发现左边选3个好像不会影响右边选1个的结果，而且每个子节点的子树最多就选4个，那就好办了，枚举每一个子节点所分配到的结果0到m-1不就好了。这样就把指数级的枚举降到了平方级。

但每个节点都有平方级别的分支，还是吃不消啊。
但是如果你写出所有分支的话，就会发现好像很多分支是重的，就比如左4会枚举自己的子节点0-3，但是左3也会枚举0-2，同理左2也计算了0-1
这样就做了大量重复运算，十分浪费。因此考虑dp

这时候你发现每一个节点的选择只有一个，且必须选一个作为最终结果，那么是不是很想分组背包？每一个节点所有的选择作为一组，每一个选择是个物品。

那好，不需要每个节点都开一大堆分分支枚举了，每个节点都做一次分组背包，复杂度n^3，一看数据量：300，妥了！

当然分组背包怎么做呢？

对于叶节点直接把它自己算上就完事了。
对于其他节点先计算每组带来的收益，最后加上自己带来的收益。
对于超级根节点0节点，没有自己，所以不做加自己的操作。

不会分组背包那就真没救了（就是我）

完事。