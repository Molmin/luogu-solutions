### 这道题其实很简单，方法却只有一种。~~至少本人是这么认为，如果说看这篇题解的大佬们，若有办法，请不要怪小生！！！~~

题目简介：就是说一个为 $x$ 的数，它的每一个数位的乘方（次数为总共的位数）之和，如果为这个 $x$ 那么就可以输出 Armstrong，否则，就输出 Not Armstrong。例如：

$x$ 为153，位数分别为1,5,3，也就是只要1的三次方（因为总位数为3）加5的三次方，再加上3的三次方等于153，就输出 Armstrong，否则就输出 Not Armstrong。

$x$ 为54748，位数分别为5,4,7,4,8,也就是只要5的五次方（因为总位数为3）加4的五次方，加上7的五次方，加上4的五次方再加上8的五次方等于54748，就必须输出 Armstrong，否则就输出 Not Armstrong。

但该怎么做呢？想必这是大家所要问的问题，大家都知道，若单单限定位数，这道题就可以迎刃而解，但它却偏偏不，确实让人火恼。不过大家知道这道题最难的是位数不限定，我们是不是求出位数就可以解决了呢？不，不，不，大家再想一下，即使我们求出位数，我们还需要保存位数，为什么呢？我想说，如果你不保存位数，那么后面的求算各个位上的数的次方，您该怎么办呢？所以我们这个程序的主要的四个环节就是：1.求位数，2.保存各个位上的数，3.求它们的次方之和，4.比较就行了。

### 那么我们按这个思路来：
#### 1.求位数
这个想必大家都知道吧，那么就不讲思路了，直接上代码（如果不懂的话，代码上也有思路）。
```cpp
	int ans=0,x;//ans保存位数，x当输入的数字。
	while(x){
		x/=10;//削位。
		ans++;
	}
```
#### 2.保存各个位上的数以及求它们的次方之和
这个也许大家很苦恼，但其实也很简单，用数组就行了,用数组来保存各个位上的数，只不过我们还需要再去位一次。这样的话求次方就简单多了，边去位，边求次方就行了。话不多说，直接上代码吧。
```cpp
	int i;long long x,sum=0;//x还是原来那个输入的数，sum求他们的次方之和。
	for(i=1;i<=ans;i++){
		sum+=pow(x%10,ans);//求次方
		x/=10;
	}
```
#### 3.最后进行比较
这个我想就不需要说了，那就直接上代码了。
```cpp
	if(sum==x) printf("Armstrong\n");
	else printf("Not Armstrong\n");
```
好了大家也应该听懂了吧，那么就开始上全代码吧！！！
```cpp
#include<bits/stdc++.h>
using namespace std;
void pd(long long k,long long ans){
	int i;long long x,sum=0;
	x=k;
	for(i=1;i<=ans;i++){
		sum+=pow(x%10,ans);
		x/=10;
	}
	if(sum==k) printf("Armstrong\n");
	else printf("Not Armstrong\n");
}
int main(){
	long long k,x,ans=0,i,n;
	scanf("%lld",&n);
	for(i=1;i<=n;i++){
		scanf("%lld",&k);
		x=k;ans=0;
		while(x){
			x/=10;
			ans++;
		}
		pd(k,ans);
	}
	return 0;
}
```
//不用说谢谢，不因客套，只因能见您的笑容，以及您电脑上的 AC，您已经回报。

//祝大家信息学越来越棒哦！