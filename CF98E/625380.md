[洛谷题面](https://www.luogu.com.cn/problem/CF98E)

[原题链接](https://codeforces.com/contest/98/problem/E)

这是一道在思想层面上十分高妙的题目，因此主要难度就在于思维层面，代码实现十分简单。

## 思路分析
对于一般的博弈问题的一般变例，诸如**Bash博弈**、**Nim博弈**等等，我们往往可以在游戏的最初，根据**初始局面**便可以推知最终的胜者，也就是可以推知初始局面是**必胜或必败局面**。

这往往是由于对于这些问题，我们可以在**博弈图**上较为便捷地找到其较为**有限**的**后继局面**，或者由于**局中人**的**策略**遵循一个很显然的逻辑，使得局面**得失**的变化非常显然。

但是对于本题来说，问题看起来就并没有那么简单，因为局中人的决策逻辑会受到其他条件的影响。

于是，为了便于分析问题，我们倾向于对一个**状态**的函数进行研究。

一般的，令 $f(n,m)$ 表示先手拥有 $n$ 张牌，后手拥有 $m$ 张牌的情况下，**先手**获胜的概率。

## 决策细节
首先需要明确的一点是，每一张牌都是**不同**的，并且牌号都在一个固定**连续**的区间之内，即 $[1,n+m+1]$。

那么，对于一方来说，自己拥有的手牌绝对不是对手的手牌，也就是说没有一张手牌同时在二者手上。

所以，如果能够知道对方所有牌的信息，很轻易就可以计算出桌面上剩下的一张牌，这就是胜利的条件。

所以根据贪心的思想，我们要减少对手尽量多的手牌。

话说回来，究竟是什么使得这个游戏的决策变得复杂呢？

可以认识到的一点是，每次都认真去猜对方的牌并不是最优的。有时最好通过说出你**手头的牌**来迷惑对手。

在这种情况下，如果对手认为你在认真猜牌，他就会意识到你猜的牌是桌上的牌，并在下一回合输掉。

这就是这个游戏的复杂之处，双方可以互相欺诈，而对方可以选择相信或不信。

一般的，我们有两种策略和两种选择：

- 策略“猜测”为**合理**地猜测对方的手牌；

- 策略“欺诈”为说出手头的牌来迷惑对手。

- 选择“相信”即认为对方本轮的策略是“猜测”；

- 选择“不信”即认为对方本轮的策略是“欺诈”。

需要注意的是，如果把**先手**胜利这一结果赋值为$1$，输赋值为$0$，那么许多情况的概率就和**先手胜利的期望**（以下简称“期望”）在数值上**大小相同**，下文会体现这一点。

## 概率证明
- 如果先手欺骗，后手相信，那么期望为$1$。

- 如果先手欺骗，后手不信，此时后手就得知了先手的一张牌，下一轮就可以减少对手一张牌。

	期望为 $1-f(m,n-1)$。（注意到在下一轮中，此轮后手变为先手）

- 如果先手猜测，猜中的概率为 $\frac{m}{m+1}$，猜错的概率为 $\frac{1}{m+1}$。

	此时的期望等于两种情况期望之和。
    
	如果后手相信，期望为 $\frac{m}{m+1}(1-f(m-1,n))$。

	如果不相信，期望为 $\frac{m}{m+1}(1-f(m-1,n))+\frac{1}{m+1}$。

	我们可以这样理解上述两个式子：不管后手相不相信，先手**总能**享有**猜中**的期望值。
   
   但是，如果先手猜错了（也就是先手猜成桌面上的牌），并且后者也相信了，下一轮时此轮的先手就输了，所以在这种情况下**猜错**这部分的期望值就是$0$了。

	反之如果后手不信，先手也就可以拥有猜错这部分的期望。

这样，我们就分析完所有情况下的期望了。

但是，问题还没有结束，我们如何才能计算出最终的获胜概率呢？也就是说，我们如何才能把上述几种情况合并呢？

我们认识到，一场博弈双方的胜率，在不考虑其他干扰因素的情况下，就取决于双方采取的策略。

对于本题来说，其中一方选择“猜测”或者“欺骗”都是有概率的，这也是策略的一部分。

一般的，在某一回合，设先手选择“猜测”策略的概率为 $p$，

后手选择相信时先手获胜的概率：

$P_1=(1-p)+\frac{m}{m+1}(1-f(m-1,n))p$

后手选择不信时先手获胜的概率：

$P_2=(1-f(m,n-1))(1-p)+(\frac{m}{m+1}(1-f(m-1,n))+\frac{1}{m+1})p$

## 答案讨论
根据前文两个概率的表达式，先手获胜的概率实际上取决于后手相信与否。

本题属于**非合作博弈**，已经证明：**纳什均衡在n人有限非合作博弈中具有普遍存在性**。

在本题中，对于先手，为了达到最优策略，先手肯定希望达到纳什均衡。

为此，需要排除后手决策对于先手最终**收益**的影响，也就是让后手相信与不信时先手获胜的概率相等，即令 $P_1=P_2$。

由此可以解得：

$p=\dfrac{(m+1)f(m,n-1)}{1+(m+1)f(m,n-1)}$

在代码实现中，为使得写法更为简易，可以上下同除以 $(m+1)f(m,n-1)$。

那么，得到 $p$ 的通式之后，我们就可以每次记忆化递归求解 $f(m,n-1)$，再带回 $P_1$ 或 $P_2$ 继续递归处理 $f(m-1,n)$。

最后答案输出 $f(n,m)$ 和 $1-f(n,m)$ 即可。
## 附上代码
```cpp
#include<bits/stdc++.h>
using namespace std;
double f[1100][1100];
int n,m;
double dp(int n,int m)
{
	if(f[n][m])return f[n][m];
	if(n==0)return f[0][m]=1.0/(1.0+m*1.0);
	if(m==0)return f[n][0]=1.0;
	double p=1.0/(1.0+1.0/((m*1.0+1.0)*dp(m,n-1)));
	return f[n][m]=1.0-p+(m*1.0/(m*1.0+1.0))*(1.0-dp(m-1,n))*p;
}
int main()
{
	int n,m;
	cin>>n>>m;
	printf("%.20lf %.20lf",dp(n,m),1.0-dp(n,m));
	return 0;
}

```
## 一些细节
递归的边界我们设置成 $f[0][m]=\frac{1}{m+1}$，因为在先手没有手牌的时候，其必须立刻去猜桌面的牌，否则后手下一轮必然胜利，而本轮先手一次猜中的概率仅为 $\frac{1}{m+1}$。

同理，$f[n][0]=1$ 因为如果后手没有手牌，先手就可以在本轮胜利了。





