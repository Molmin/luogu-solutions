这题就是求把数字n**无序**划分成k份的方案数。
### 什么意思呢？
1.想象一下，就是把n个苹果放入k个盒子里的**组合**方案数。

2.也就是这一道方程:x1+x2+x3+x4+...+xk=n (1<=x1<=x2<=...<=xk)的解数。

### 那么，如何DFS呢？
dfs的方法是依次枚举x1,x2,x3...xk的值，然后判断。如果直接搜索，效率非常低，但是本题数据规模比较小，如果有合理的剪枝方案，也是能够很快出解的。
### 说了这么多，关键的还是如何剪枝。。。
定义几个变量：dep:当前搜到哪个，从1-n枚举；b:是第几个x，从1-k枚举；sum:x1-xb的和。

首先，我们可以~~很容易~~地想到，当sum>n时，剪枝

然鹅呢？T了两个点。

再加上inline和register后，T了一个点。
#### 还有什么更好的剪枝方法？
思考了n分钟后，我突发奇想：能不能提前判定下可不可以？也就是**可行性剪枝**

因为xi>=x(i-1)，所以，到了最后sum最小就是**sum+b*(k-dep+1)**,如果还比n大，肯定不行。

解释一下，由于可以等于，那么最小就全是b,那么有多少个b?k-dep,因为第dep不算，所以要加1。

核心代码：
```cpp
inline void dfs(int dep,int b,int sum){
	if(sum+b*(k-dep+1)>n)return;
	if(dep>k){
		if(sum==n)ans++;
		return;
	}
	if(sum>n)return;
	for(register int i=b;i<=n;++i)dfs(dep+1,i,sum+i);
}
```
