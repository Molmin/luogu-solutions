这道题的解题思路显然不止一种，这儿我就讲一下最正的正解——划分型动态规划。

首先我们定义的状态是：f[i][j]表示把数字i分成j个数的不同的分法，相当于是把长为i的一段砍成j段的不同砍法。

定义完状态，然后再来分析状态的转移。想象每个数是一段区间，可以把i分为很多小段，每一次分为i-t和t，然后把t当作已经分好的一整段，所以把整个i分为i-t和t只需要1刀就可以分出来，然后用同样的方法分开长为t的那一段，这就是子问题。

所以这样我们就可以得到f[i][j]就是所有分j-1次的f的和，也就是f[i][j]=∑f[i-t][j-1]。

因为重复的只能算一次，所以t的循环放在最外面，限制了我们必须从大到小的分，这样最后就不会出现重复。

代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,k;//将整数n分成k份 
int f[205][10];//f[i][j]为把i分为j个数的分法 
int main()
{
	cin>>n>>k;
	f[0][0]=1;//初始化 
	for(int t=1;t<=n;t++)//分出来的整块的大小 
		for(int i=t;i<=n;i++)//整个一块的大小 
			for(int j=1;j<=k;j++)//分的段数 
				f[i][j]+=f[i-t][j-1];
	cout<<f[n][k];//输出将整数n分成k份的分法 
	return 0;
}
```