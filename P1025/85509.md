蒟蒻之一直在搜索。。。

这道题方法是很多的，但是我只说说一些头顶硬锤的剪枝条件（这道题特别好讲）

首先，我们可以发现，这道题的题目是很简单清晰的，所以不宜强行复杂化，否则在打代码的时候会有事倍功半的效果（看着题目不知道代码是用来干嘛的）

那么，讲一下去重的一个小关键

#  可以发现，为了不重复，所有的数列都是升序的！

~~蒟蒻也不知道为什么~~

那么就可以通过特殊处理得到特殊优化

用一个变量保存上一次搜索出的数，然后下一次搜索就强行从这个数开始循环（保证升序），方式多样，dalao们可以自己想想如何实现

但是，很明显，这样是行不通的（200的数据还是会炸掉的inginging~）

仔细观察，你会发现，最后一个数的搜索是完全可以省略掉的（可以保存前面的总数然后用n减得出最后一个数）

但是，只打一个判断到倒数第二个数是没有用的（很明显，最后一个数需要另外一个条件）

条件是什么呢？

回顾上文，看一号标题

那么可能dalao们都已经明白我的意图，因为保持升序，所以这个数需要大于等于前一个数

于是一道搜索黄题又在小蒟蒻的手下了

可能文字不大好懂，那么加上代码及注释奉给dalao们

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int n,k,ans,q;//美好的黄题只用四个变量（而且两个是题目的锅） 
void dfs(int w,int z)
{
	if (w==k&&n-z>=q)//w==k是到达倒数第二个数，n-k>=q即大于前一个数 
	{
		ans++;
		return;
	}
	else
	{
		int qd=q; //-->为了使继续的搜索的q，也就是保存前一个数的变量的正常运行，在外面保存原数，搜索完再还原 
		for (int i=q;i<=n-z;i++)//搜索时的判断操作 
		{
			if (i==0) continue;//小特判，第一个数时为零 
			q=i;
			dfs(w+1,z+i);
			q=qd;
		}
	}
}//标准可爱的dfs 
int main()
{
	scanf("%d%d",&n,&k);
	dfs(1,0);
	printf("%d",ans);
	return 0;//主程序简短而不失风采 
}
```

再三申明，没看懂的再仔细看前面的分析（如果有更好的改进希望能在下方评论，小蒟蒻期待哦！）