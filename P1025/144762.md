这道题明面上是很简单的，也就是dfs，但是我们要学习的并不只是深度优先搜索， ~~不然你怎么 AK FROM NOI,~~ 毕竟未来的道路还很长很长，所以我们要学更多的东西。

------------
~~以上只是为了通过题解而打的，谢谢审核猿**QAQ**~~

------------
好，正经话开始了：：：：

dfs很重要，暴力骗分它最吊，可我们如果想让dfs发挥出它的最大作用，那我们一定要注意至少这一点：：：：：

# **序**

                           （序是什么东西啊）————————蒟蒻
同为蒟蒻的我+_+ ————————（自己去百度）

序其实在编程中，在大多数情况下，都是指完成题设要求的行动顺序

还不能理解，那就看下面关于这道题的好吃的栗子：：

此题是要求对一个数进行划分，题目中要求
若7能划分成1，1，5和5，1，1那么这两种划分方法算作一种

诶？？？？？这种东西要是来直接HASH判重那有点麻烦，能不能直接cut掉大部分重复部分捏？？？？？其实这就要牵扯到序的应用了。何为序？乃是完成要求的顺序。那我们就尝试一下序的改进。

我们再想想，5,1,1 三个数随便排顺序都会重复，那么从小到大按顺序排会更优吗？（只想通过题解找一点思路的看到这里就可以了）

答案是显然的。如果我们从小到大排，那我们可以想到，这一排数是非单调递减的，那么如果我们的第一个数过于小，那就不可能得到解，所以我们的第一个数应小于等于n/k（向下取整，下同）。设第一个数是x，那么第二个数应小于等于（n-x）/（k-1），以此类推………………

经过上面的分析，我们已经在搜索前就已经排除掉了1,1,1这样的不可能的情况，所以搜索性能大大地优化；同时，我们也排除掉了5,1,1这样不可能的情况，搜索性能又是一个大大的优化  |_|  

好的，上代码

```cpp
#include<iostream>
using namespace std;
int ans=0;
void dfs(int i,int a,int b)
{
	if(b==1) 
	{
		ans++;return;
	}
	for(int j=i;j<=a/b;j++)
	dfs(j,a-j,b-1);
}
int main ( )
{
	int n,k;
	cin>>n>>k;
	dfs(1,n,k);
	cout<<ans;
}
```


此题解是给初学者看的，本人蒟蒻，大佬 （请）勿喷

AND  :<  拜托审核猿了 呜呜呜呜呜呜~~~~~~~~  ，这个真的和已有的不太一样（应该吧）