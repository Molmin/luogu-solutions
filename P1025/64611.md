这个题，可以说简直就是一道数学题！

用DP当然更快，可是没必要，用递归的思想可以很简单地做出来，而且好理解。

（附带记忆化搜索）

## 首先呢，数学逻辑思想：

我们先假设数的划分是可以“空”的，就是说样例就可以划分为“6,1,0”；

这样有什么好处呢？如果这样，那么现在困扰你的这个数的划分就变成了“可以空”的一个子问题：“不能空”，那么就可以很简单的解决了。

## 然后呢，分成两部分考虑（可以空的前提下）：

### 一、没有空的：

如果没有空的，那么我在每个划分的份里取出来一个，此时，这种情况还存在（虽然可能因为“减一”而有空了），但是这还是一种分法，因为我们已经规定可以空了。

因此：f(m,n)/\*m个分成n份\*/=f(m-n,n)/\*"m-n"就相当于每份取1个，共n份取1\*n个

### 二、有空的：

如果有空的，那么我就把这个空的份去掉，此时，这种情况还存在（虽然因为减少的份数而没有空了），但是这还是一种分法。

因此：f(m,n)=f(m,n-1)//去掉一个空的份（若不只空一份，在下一次操作会再去一份）

## 总：

所以，综上所述：f(m,n)在把它分成“没有空的”和“有空的”的时候分别为f（m-n,n）和f(m,n-1),则f(m,n)=f(m-n,n)+f(m,n-1);

这样就可以写出程序了。

## PS：递归的边界请读者自己想一想。


```cpp
#include<iostream> 
using namespace std;
int F[350][350];
int f(int m,int n){
    if(m<n)
    return f(m,m);
    if(!F[m][n])
    {
        if(m==0||n==1)
        F[m][n]=1;
        else 
        F[m][n]=f(m-n,n)+f(m,n-1);
    }
    return F[m][n];
}
int main(){
    int a,b;    
    cin>>a>>b;
    cout<<f(a-b,b)<<endl;
    return 0;
}
```