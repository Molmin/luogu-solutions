其实可以用动规做~~~~（没想到吧，嘻嘻嘻）；

那么简单的题目被搞得这么复杂~~（本人不喜欢搜索，搜索之类的最讨厌了，勿喷）；

思路就是拆成含1的和不含1 的

例： 10,3

含1:1 2 7

不含1：2 3 5

这样动态转移方程就出来了。。

f[i,j]:=f[i-1,j-1]+f[i-j,j]; （i,1~n.....j:1~k）;

初始值为   f[0,0]:=1；

附代码（短得让你不敢相信）

```cpp
var
n,k,i,j:longint;
f:array[-300..300,-300..300] of longint;
begin
readln(n,k);
f[0,0]:=1;
for i:=1 to n do
 for j:=1 to k do
  f[i,j]:=f[i-1,j-1]+f[i-j,j];
write(f[n,k]);
end.
```
本人只会pascal，C/C++的同志们请谅解啊！
感谢支持1111111111

