明天要和$peper$讲这道题...

第一眼直接打了放苹果，发现方案数多了之后一看不能有空盘子

1. **dp做法：**$f [ i ][ j ] = f [ i - 1 ][ j - 1 ] + f [ i - j ][ j ] $

$f [ i ][ j ]$表示$i$个数分成$j$份的方案数

第一个数为$1$时，$1$占用了$1$个位置和占用了总数中的$1$是已经确定了的

第一个数不为$1$时，可以视为先在所有的位置上都加上一个$1$再对于所有的位置用新的总数求次数，

所以确定的是占有了总数$j$个，位置仍然是$j$个，与原来相比没有变化。

```cpp
//初始化
    for(int i=1;i<=n;++i){//k<2时
        f[i][1]=1;//k==1时只有一种方案
        f[i][0]=0;//k==0时没有方案
    }
    for(int i=2;i<=n;++i){//k>=2时
        f[1][i]=0;//n==1||n==0时没有方案
        f[0][i]=0;
    }
    for(int i=2;i<=n;++i){
        for(int j=2;j<=n;++j){
            if(i<j) f[i][j]=0;//n<k时没有方案
            else f[i][j]=f[i-1][j-1]+f[i-j][j];
        }//总方案数=第一个数为1时的方案数+第一个数不为1的方案数
    }
    cout<<f[n][k]<<endl;
```
2. **递归做法**

为了确保出现过的方案不重复，可以规定在后面的分组中的数必须要大于等于前面分组中的数，

x代表上一个出现过的数，初值为1，只要让下一个数从x开始循环，便可达成上述方案。

k代表还需多少次递归，初值为k，递归k次，即分为k组后便可退出循环。

t代表到此次还剩多大的数可以分，初值定为n。

同时循环最大只能进行到t/k，

避免出现因前面的数过大而导致后面的数无法取的情况

```cpp
void dfs(int x,int k,int t){
    if(k==1){
        sum++;
        return ;
    }
    for(int i=x;i<=t/k;++i) dfs(i,k-1,t-i);
}

int main(){
    // freopen("in","r",stdin);
    cin>>n>>k;
    dfs(1,k,n);
    cout<<sum<<endl;
    return 0;
}
```