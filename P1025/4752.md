# DP

题解也有很多dp，不过我看初值似乎都赋得有点麻烦，其实F[i][j]表示把i分成j份的情况数的话，初值只需F[0][0]=1即可（可以想想为什么，对了，赋0位置是常用手段）

讲讲转移，我们知道，拆成k个数又要保证不重复只需要强制令k个数递增或递减即可，这里假设是按递减排列

举样例吧，n=7,k=3时可以有5 1 1， 4 2 1， 3 3 1， 3 2 2四种拆法，这些拆法可以分成两类，一是以1结尾，二是以大于一的数结尾。

以1结尾时，必然是把6分成2份然后最后加个1（5 1， 4 2， 3 3就是6拆成2份的所有拆法）

以大于1的数结尾时说明所有数都大于1，那么把7分成3份而又不能有1的组合有几种怎么算呢？只要先把3个位置都放上1，然后把剩下的4分成3份加上去就行了，比如 3 2 2其实就是2 1 1也就是把4分成3份的所有情况。

综上，f[i][j]=f[i-1][j-1]（最后为1）+f[i-j][j]（最后大于1）

代码如下
```cpp
#include<bits/stdc++.h>
int f[210][10];
int main()
{
    int n,k,i,j;
    scanf("%d%d",&n,&k);
    f[0][0]=1;
    for (i=1;i<=n;++i)
    for (j=1;j<=k;++j)
    {
        f[i][j]+=f[i-1][j-1];
        if (i-j>=0) f[i][j]+=f[i-j][j];
    }
    printf("%d",f[n][k]);
    return 0;
}
```
