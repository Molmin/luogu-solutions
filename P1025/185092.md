## 动态规划

#### **(dynamic programming)**

## 二维DP

正整数n拆分成最大数正好为m的若干个正整数的方案数 **=**
正整数n拆分成正好m个正整数的方案数(Ferrers图)

## n的m拆分数

思考：为什么是**二维DP**？
如何设计状态i,j？
**如何设计f[i][j]，代表什么含义？**
如何建立f[i][j]和其他状态的联系？

### 最自然的设计：仿照原问题  因为原题"拆分n,最大为m的方案数" 所以 f[i][j]代表拆分i,最大为j的方案数

f[i][j]代表i拆分成正好j份的方法有几种

f[i][j]表格：

### 第一种：
```
	j=0	j=1	j=2	j=3	j=4
i=0	0	0	0	0	0
i=1	0	1	0	0	0
i=2	0	1	1	0	0
i=3	0	1	1	1	0
i=4	0	1	2	1	1
i=5	0	1	2	2	1
i=6	0	1	3	3	2
i=7	0	1	3	4	3
i=8	0	1	4	5	5
i=9	0	1	4	7	6
```
### 第二种：
```
	j=0	j=1	j=2	j=3	j=4
i=0	0	0	0	0	0
i=1	0	1	0	0	0
i=2	0	1	1	0	0
i=3	0	1	1	1	0
i=4	0	1	2	1	1
i=5	0	1	2	2	1
i=6	0	1	3	3	2
i=7	0	0	3	4	3
i=8	0	0	0	5	5
i=9	0	0	0	0	6
```
解释：

i等于j时
边界初始化

填表顺序可以选择：

### 根据第一幅图：

从上往下，从左往右，

从左往右，从上往下

### 根据第二幅图：

**斜线**，
从上往下，
从左上往右下

当i-j>n-m时,无需再计算

代码：

### 第一种：

```
int n,m,f[N][M];
int main(){
	cin>>n>>m;
	f[1][1]=1;//第1行第1列边界初始化
	for(int i=2;i<=n;i++)
		for(int j=1;j<=min(i,m);/*j<=i会错*/j++)
			f[i][j]=f[i-1][j-1]+f[i-j][j];//易错点i-j越界
	cout<<f[n][m]<<endl;
```
### 第二种：

```
int n,m,f[N][M];
int main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++)f[i][1]=1;//第1列边界初始化
	for(int j=2;j<=m;j++)
		for(int i=j;i<=n;i++)
			f[i][j]=f[i-1][j-1]+f[i-j][j];
	cout<<f[n][m]<<endl;
```
## 第三种（推荐）：

```
int n,m,f[N][M];
int main(){
	cin>>n>>m;
	for(int j=1;j<=m;j++)f[j][j]=1;//行数i等于列数j时，边界初始化
	for(int k=1;k<=n-m;k++)//k代表行数i减列数j
		for(int j=1;j<=m;j++){//列数j扫描1到m
			int i=j+k;//定位行数为i
			f[i][j]=f[i-1][j-1]+f[i-j][j];//状态转移方程
		}
```
## 填表顺序：对角线斜向右下

# 附：

## 二维DP的查错

#### 静态查错：

写明二维数组元素f[i][j]的含义

检查数组f[i][j]的初始化和状态转移

检查数组下标准确性，包括越界可能

#### 打印日志：

检查数组f[i][j]的初始化和状态转移

检查数组下标准确性，包括越界可能

由错误的那个f[i][j]元素定位程序错误