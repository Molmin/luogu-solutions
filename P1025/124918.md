# 数位DP

### 数位DP简介：一种像DFS的DP，我们就直接当DFS做就好了

我们注意到k很小，因此我们可以用数位DP枚举每一个划分出来的数

但如果单纯枚举的话，每一个数有n=200种可能，一共要枚举k=6次，有学过乘法原理的都知道，时间复杂度是200的6次方（第一次见到这么小的指数级复杂度。。。）

显然超时了，还会重复，因此我们要有更好的枚举方法

为了去重，我们要使得后面划分出来的数要>=前面划分出来的数

例如我们举一个数tmp，要求所有带有tmp的划分方案

考虑枚举第一个数：

- 第一个数 < tmp 则tmp会出现在后面的数中

- 第一个数 = tmp 则会枚举所有以tmp开头的数

- 第一个数 > tmp 则不会枚举tmp

不止第一位数，从第二位一直到第k位都可以这样考虑，就可以枚举出所有不重复的方案了。（具体我也讲不清，可以自己上网搜）

因此我们只需在枚举第i位的时候使第i位上放的数 >= 第i-1位上放的数就可以了。

可以看到时间复杂度小了很多（虽然我自己也没看出来小了多少）

但还是不够，于是我们考虑最大能放的数。

之前我们提过：第i位上放的数 >= 第i-1位上放的数

因此从第i位开始放，使得所有数之和最小的方案就是从第i位开始，所有位置都放同一个数（满足条件的最小方案）

那我们算出放完前i-1位之后n剩余的值，再除以剩余的位置数向下取整就是最大能放的数了（每位放一样的数就是平均分也就睡除）

算出两个边界之后就能直接枚举了，注意只要枚举到第k个位置就算一种方案了，因为前面的枚举会保证第k位一定能放数。

code：
```
#include<bits/stdc++.h>
using namespace std;
int n,k,ans;
void dp(int sum,int maxn,int t) {
	if(t==k) {ans++;return ;}
	int len=k-t+1,over=n-sum;
	for(int i=maxn; i<=over/len; i++) dp(sum+i,i,t+1);
}
int main()
{
	cin>>n>>k;
	dp(0,1,1);
	cout<<ans;
	return 0;
}

```

把我顶上去！
