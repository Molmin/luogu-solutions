# 题目：P1025 数的划分 2001 提高组 T2
## 题目描述
将整数 _n_ 分成 _k_ 份，且每份不能为空，任意两个方案不相同(不考虑顺序)。  
例如:  
 _n=7_ , _k=3_ ,下面三种分法被认为是相同的。  
 _1 1 5_   
 _1 5 1_   
 _5 1 1_   
问有多少种不同的分法。
## 分析  
_1_.明显不能枚举求解，需要使用递归，递推或数学结论等方法。  
_2_.显然，当 _n=1_ 时，仅有一种分法。  
_3_.两种策略：要么选择将剩余数字分出 _1_ (即 _2_ )，要么分出其它数 _now_ ( _now > 1_)，然后分出 _1_。  
_4_.上网寻找一波数学方法。  
## 解法1：搜索（dfs）+剪枝
_1_.在dfs中模拟进一步选择的分出的_now_，直到分出_1_，再用计数器统计总方案数。  
_2_.剪枝在如下代码中呈现。
```cpp
//搜索（dfs）+剪枝
int n,k;
inline int dfs(int num,int part,int now)//分别表示剩余待分的数，分的机会数和现在要选出的数。
{
  if(part==1)return 1;//如分析2。
  int sum=0;//sum一定要开在函数中，否则会漏选(看后面的代码就懂了)
  for(int i=now;i<=num/part;i++)//剪枝：不需要枚举到num，否则既有可能重复计算，又会加大运算量(dfs你懂的)。
    sum+=dfs(num-i,part-1,i);//再搜索剩余待分数num-i，分的机会数少1，选择分出now，将所有情况统计于sum。
  return sum;
}
int main()
{
  n=read(),k=read();
  printf("%d",dfs(n,k,1));//从n,k选一种开始搜。
  return 0;
}
```
## 解法2：动态规划(不如说是递推)  
_1_.先初始化，任何当_k=1_的情况下仅有一种分法。  
_2_.然后如分析_3_组建_dp_方程，从_i_中分_j_份的方案数 (f[i,j]) , 为 _i-1_ 中分 _j-1_ 份 ( f[i-1,j-1] ,即分出_1_) 和 _i-j_ 分 _j_ 份 (f[i-j][j],因为分出1后剩下 i-j 个可分的1，j 次机会) 的方案数之和。  
_3_.同时要注意一个小小的细节(未经实测，可能不会导致WA)。
```cpp
//动态规划(不如说是递推)
int n,k,f[N][N];
int main()
{
  n=read(),k=read();
  for(int i=1;i<=n;i++)f[i][1]=1;//如上1。
  for(int i=1;i<=n;i++)
    for(int j=2;j<=k;j++)//1的情况已经处理，从2开始，否则会访问0。
        if(i>=j)f[i][j]=f[i-1][j-1]+f[i-j][j];//小细节：只有n>=k时才能有数分。
  printf("%d\n",f[n][k]);//输出从n中分出k份的方案数
  return 0;
}
```
## 解法3：母函数


------------

先声明一下此方法的参考对象 巨佬 [Hardict ](https://www.luogu.org/blog/hardictdbsd/solution-p1025)
和母函数讲解者[xuzengqiang](https://blog.csdn.net/xuzengqiang/article/details/7464337)。
如果大家想要详细了解母函数的其他高端用法，( 建议数学恐惧症的同学们赶快开溜 )请前往[百度百科：母函数](https://baike.baidu.com/item/%E6%AF%8D%E5%87%BD%E6%95%B0)  


------------

首先母函数是什么，一个数列 _a_，有_a1_，_a2~an_ ,可使用母函数将其表示为：  
$G(x)=a_0+a_1x+a_2x^2+a_3x^3+.....+a_nx^n$  
由此形式，它也叫生成函数  。
其应用于各种排列组合的数学问题中，如可以递推变通项，分配问题，_Catalan_数列等。  

基本解决方法：  
1.将模型变成母函数方程。  
2.求解母函数方程。  
3.将母函数变成幂级数形式。        

然后开始这个题的讲解:  
假设1出现的次数为记为a1,2出现的次数记为a2.........k出现的次数记为ak,那么生成函数为：

$G(x)=(1+x+x^2+x^3+x^4+...)(1+x^2+x^4+x^6+x^8+...)(1+x^3+x^6+x^9+...)...(1+x^n)$   
  
  _1_.前面的$1+x2+x4+x6+x8+...$意思是当出现一个2时为x2，当出现两个2时为$x4...$  
  为什么当出现n时，只有两项$(1+xn)$，因为是将数n划分为若干项，所以不能超过该数，且由数1到n项数依次要 $<=n/k(k=1.2,3,4...n)$。  
第i个括号内，它代表i的选取，而第j项，表示选取j个(在这认为从0开始数项数) 。   
_2_.我们的目的就是让求出$G(x)$表达式，然后得到$x^n$的系数  
基本的思想有了，但是仍有问题，就是本题的 _k_ 其实是未知的，无法直接套公式，就需要一个参量y决定&x&的次数。( Idea by 巨佬 Hardict)  
$G(x)=(1+yx+y^2x^2+y^3x^3+...)((1+yx^2 +y^2x^4 +y^3x^6++...)(1+yx^ 3 +y^2x^6+y^3x^9+...)$
```cpp
//母函数（参考Hardict）
int n,k,val[N][N],temp[N][N];//val表示对j进行分i份的个数，即G(x)的系数，temp用来保存每一次求得的结果。
int main()
{
  n=read(),k=read();
  for(int i=0;i<=k;i++)val[i][i]=1;//初始化，如分析2。
  for(int i=2;i<=n-1;i++)//务必从2开始枚举，本人就是在此WA了一小时。
  {
    for(int j=0;j<=n;j++)
      for(int K=0;K<=k;K++)//分到k停止循环。
        for(int l=0;l<=n-j;l+=i)//控制系数的变化和每个数的最大项数 。
          temp[l/i+K][l+j]+=val[K][j];
    for(int K=0;K<=k;K++)
      for(int l=0;l<=n;l++)val[K][l]=temp[K][l];//反过来赋值给val。
    memset(temp,0,sizeof(temp));//务必请零，最好用memset，可能会留存之前的状态。
  }
  printf("%d\n",val[k][n]);
  return 0;
}
```
## 总结
这就是这道题目的三种解法，说实话，前两种应该是很好理解和掌握的，也是大多数同学们早就掌握的，母函数(生成函数)的方法不好理解，也不方便使用，只是看看就好。  
最后，这是本人第一篇题解&博客，写的不好，希望大家勿喷，谢谢。