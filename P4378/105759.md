这道题归根结底是一道数论题。

首先我来阐述一下题意，有些小伙伴可能对这道题的意思有点蒙，~~不必在意~~他的这个伪代码，~~毕竟这样做要TLE~~。

先把每一个数字看做独立的，冒泡只不过一次一次的比较，而本题的目的就是想求出往前移动次数最多的数字。

题目懂得了，可是代码要怎么实现呢。

先看看数据范围（1<=n<=100,000），嗯。。不大也不小，但最多也只能O(n)了

那我们就来想想，如何在O(n)的复杂度中解决了。

_first：_ 先用结构体定义输入的数字，数字的编号，--以及排序后的编号（其实也不用，只是这样思路更清晰些）

_second：_ 将结构体进行快排（sort），排序后再将id2附上i值，做差再 +1 就可以计算出每一个数字经过冒泡排序的次数了。

这道题其实不难，只是在理解题意上要花一点小小的功夫。

## 代码秀起来(有超详细注释）

------------
```cpp
#include<bits/stdc++.h>
using namespace std;
struct nu	//结构体定义
{
	int x;		//存储每一个输入
	int id1;	//sort 排序前的编号
	int id2;	//sort 排序后的编号
}t[1100000];
int cmp(nu a,nu b)		//注意！！！
{
	if(a.x!=b.x)		//在判定时有可能有相同的数字
	return a.x<b.x;
	return a.id1<b.id1;	//既然数字相同就要判定编号的前后了（最初在这里丢了10分555~）
}
int main()
{
	int n,a,maxn=0;
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>t[i].x;
		t[i].id1=i;		//给 id1 附上编号
	}
	sort(t+1,t+n+1,cmp);		//sort 快排
	for(int i=1;i<=n;i++)
	{
		t[i].id2=i;				//将 id2 附上编号
		a=t[i].id1-t[i].id2;		//a 存储编号差值，既是移动次数
		maxn=max(maxn,a);		//比较最大的移动次数，记录
	}
	cout<<maxn+1;
	return 0;
}
```
如果dalao觉得蒟蒻写的还阔以，可否 _**点赞**_ ~~关注三连~~ _**QWQ**_ 