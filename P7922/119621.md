## $\operatorname{Subtask} 1$

暴力。

期望得分 $5$ 分。

## $\operatorname{Subtask} 2$

与正解关系不大但是有趣的做法。

先考虑 $x$ 为奇数的情况。我们取出 $w_1=p_{l+\lfloor\frac{x}{2}\rfloor},w_2=p_{l+\lfloor\frac{x}{2}\rfloor+1}$。

这个问题相当于有两个人在进行博弈，他们轮流操作，每次往左下或右下一格。

先手目标使得最终到达的位置的值**最小**，后手目标使得最终到达的位置的值**最大**。

对于后手，每次走与先手相反的方向就可以保证最后的值 $\ge\min\{w_1,w_2\}$。

对于先手，如果 $w_1<w_2$，那么第一步往左下走，否则第一步往右下走 ，然后每次走与后手相反的方向就可以保证最后的值 $\le\min\{w_1,w_2\}$。

因此答案就是 $\min\{w_1,w_2\}$。

对于 $x$ 为偶数的情况只需要手动模拟一层然后就可以转化为 $x$ 为奇数的情况。

期望得分 $10$ 分。

## $\operatorname{Subtask} 3$

先考虑 $a_1>a_i(i\in(1,m])$ 情况。

我们用单调队列模拟先做 $a_1$ 次 $\min$ 操作再做 $a_1$ 次 $\max$ 操作，得到的结果分别称为 $p_1$ 和 $p_2$。

如果 $x$ 位于 $a_1$ 之中，那么直接使用 RMQ 处理即可。

否则先考虑 $01$ 序列怎么做。

可以看出，做完 $a_1$ 操作之后，$01$ 段之间不会再发生合并的情况。

令 $s_i=\sum\limits_{j=1}^{i} a_i$。

如果 $x$ 在 $a_i$ 刚好结束的位置，那么答案就是 $p_2$ 中的第 $y+s_i-a_1$ 个元素。

如果 $x$ 在 $a_i$ 的 $\min$ 中，那么答案就是 $p_2$ 中 $[y+s_{i-1}-a_1,x+y-s_{i-1}-a_1]$ 中的最小值。

如果 $x$ 在 $a_i$ 的 $\max$ 中，那么答案就是 $p_2$ 中 $[x+y-s_i-a_1,y+s_i-a_1]$ 中的最小值。

容易发现，把 $01$ 序列变回一般序列做法也是一样的。

于是所有询问都可以用 RMQ 处理。



再考虑任意 $a$ 怎么做。

那么我们按照 $a$ 的前缀最大值分块，每一块都用上面的方法处理。

因为 $\sum a_i=\dfrac{n-1}{2}$，所以最多只有 $O(\sqrt{n})$ 个块。

时间复杂度 $O(n\sqrt{n}+q)$，期望得分 $25$ 分。

这一部分也可以做到 $O(n\log n+q\log^2n)$，请读者自行思考（

## $\operatorname{Subtask} 4$

设 $f_k=\sum\limits_{i=k}^n\min\limits_{j=i-k+1}^ia_j$，我们就是要求出所有 $f_k$。

对原序列跑单调栈，对于每一个 $i$ 维护以它为**右端点**的所有区间的 $\min$ 值。

对于每一个**左端点**，我们计算它对于答案序列的贡献，当它首次被加入单调栈的时候，我们对 $f$ 执行后缀加​。

接下来每一次它的值可能会被更新，那么我们再执行后缀减。

但我们显然不能每次都对每一个左端点暴力做，但可以发现，单调栈中的同一个区间中的当前值都是一样的，而且左端点位置都是连续的，那么我们实际上要做的就是对于一个固定的区间的每一个位置执行一个后缀减操作。可以使用二阶差分维护。

时间复杂度 $O(n+q)$。期望得分 $15$ 分。

## $\operatorname{Subtask} 5$

首先显然可以转化成求出两个前缀的答案。设 $f_{t,k}=\sum\limits_{i=k}^t\min\limits_{j=i-k+1}^ia_j$。

对于一个区间 $[l,r]$，以及 $t\in [r,n]$，这个区间可以贡献到 $f_{t,r-l+1\dots t-l+1}$。

只需要维护一个数据结构，支持：

- 对于一个 $1\times k$ 的矩形中的每个数 $+w$。
- 求一个斜边斜率为 $1$ 的直角梯形中的所有数的和。

其中所有修改均在询问前面。

可以用树状数组维护。时间复杂度 $O((n+q)\log n)$。期望得分 $30$ 分。

## $\operatorname{Subtask} 6\sim 7$

由 $\operatorname{Subtask} 4$，每个点值都已经是一个区间最大值或最小值的形式，并且同一行的点所代表的区间的左右端点都是公差为 $1$ 的等差数列。

那么我们可以直接套用 $\operatorname{Subtask} 6$ 的算法来解决这个问题。

时间复杂度 $O(n\sqrt{n}\log n+q\log n)$。$\operatorname{Subtask} 6$ 中 $m$ 比较小，可以通过，期望得分 $65$ 分。

但这样太慢了，我们有 $O(n\sqrt{n})$ 次修改和 $O(q)$ 次询问，所以可以用分块 $O(1)$ 修改，$O(\sqrt{n})$ 查询来平衡一下。

时间复杂度 $O((n+q)\sqrt{n})$。期望得分 $100$ 分。