## 前言

作者已经快半年没做过题了，并且去年 CSP 也寄了，希望这篇题解给所有读者保佑qwq。

## 思路代码混讲

我们把这道题加工一下：

对于每个点可以选择 $k$ 种权值，每种权值只能选两次，如果一条边的两个点中有一种权值相同，则把这条边的权值加到答案，问你答案的最大值。

题面很好理解，刚开始看到可以选择父亲的边，就立马着手换根（证明我菜），结果没写出来qwq。看了一眼题解，才感觉很一眼。

我们设状态 $f_{i, {0/1}}$，$f_{i, 0}$ 表示这个点与儿子节点最多只连 $k - 1$ 条边，再给父亲留一条边（选 $k - 1$ 个儿子显然最优），$f_{i, 1}$ 则表示不留给父亲边，与儿子最多连 $k$ 条边。其实上面的说法不严谨，如果儿子没有那么多个，那么就只要搞最多的就行了。

初步转移：$f_{i, 0} = f_{i, 0} + f_{son, 1}, f_{i, 1} = f_{i, 1} + f_{son, 1}$。因为我们初步考虑什么儿子都不选。

我们考虑是否所有的儿子都要选择？其实是不需要的。此时我们考虑加入一个儿子的价值 $tmp = f_{son, 0} + w + f_{son, 1}$。我们把前 $k - 1$ 大的可以加到 $f_{i, 0}$ 里，把前 $k$ 大的可以加到 $f_{i, 1}$ 里。如果儿子没那么多就没必要了，但是如果某一个 $tmp <= 0$，则不要选，因为显然不优。

这部分的代码：

```cpp
void dfs(int x, int fa){
  f[x][0] = f[x][1] = 0;
  priority_queue<int, vector<int> > q; // vector 加快，找出前 k 个
  for(int i = head[x]; i; i = edges[i].next){
    if(edges[i].to != fa){
      dfs(edges[i].to, x);
      f[x][0] += f[edges[i].to][1];
      f[x][1] += f[edges[i].to][1]; // 转移
      q.push(f[edges[i].to][0] + edges[i].w - f[edges[i].to][1]);
    }
  }
  int cnt = 0;
  while(!q.empty() && cnt < k){ //注意这里 cnt 一定小于 k，因为等于 k 时会多循环一次
    ++cnt;
    int tmp = q.top();
    q.pop();
    if(tmp <= 0){
      break;
    }
    if(cnt <= k - 1){   //加代价
      f[x][0] += tmp;
    }
    f[x][1] += tmp;
  }
}
```

最后这个的复杂度大概是 $O(n\log_2 n)$，很玄学。

注意要开 long long 哦。