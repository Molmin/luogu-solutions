## 题意简述
给定一个 $8$ 个 $1$、$8$ 个 $2$、$8$ 个 $3$ 组成的井字形矩阵，有八中操作，分别可以将每一行、列向两边循环移一位。问至少要多少步，使得中间八个格子相等，在此基础上，输出字典序最小的方案和中间八个数的值。

## 做法
使用 IDA* 解决本题。

### IDA* 算法
IDA* （启发式迭代加深搜索），是一种常用的高效搜索。它有一个估价函数 $h()$，估算当前大概还有多少步才能到达目标状态，根据这个进行剪枝。

同时，其“迭代加深”的意义是，搜索时规定一个步数 $step$，返回的是能否用 $step$ 步得出答案，如果不能，就让 $step\leftarrow step+1$。

正因如此，当我们看到数据范围较小、最大步数已知且同样较小时，可以考虑使用 IDA* ，会有不错的效果。

由上面可知，IDA* 的效率取决于估价函数的效率。$h()$ 精度越高，复杂度越低。

如果你的估价函数每次都能精准地判断接下来还有多少步，~~那你还写 IDA* 干嘛~~，这就是个 DP。

最后还有一点要注意，无论什么时候，你的 $h()$ **不能把步数更小的方案剪掉**，宁可松，不可太紧。

------------
回归本题，注意到最多只有 $48$ 次操作（~~同一个位置循环移位 $7$ 次以上没啥意义~~），故考虑使用 IDA* 算法。

本题的估价函数是唯一一个难点（虽然没多难），就是中间那八个格子至少改变几个数才能变成一样。因为我们粗略地估计，每次操作都能减少一个。

这题是一个很裸的 IDA* ，跟走迷宫差不多，但是代码的细节和实现的技巧非常多。我会重点讲讲。

- 读入不要构造矩阵，用一维数组存，每个位置就是其读入顺序的编号；
- 写一个矩阵，意思是每次循环移位会涉及到哪几个位置，注意按一定顺序写；
- 记录 $A-H$ 操作的逆操作，方便回溯时回复矩阵；
- 多用函数，善用函数。

给份代码参考，还没压行，略显冗长。

```cpp
#include<iostream>
#include<cstdio>
#include<math.h>
using namespace std;

const int N = 8 + 5;
const int oppo[] = {5, 4, 7, 6, 1, 0, 3, 2};//逆操作
const int idx[] = {0, 7, 8, 9, 12, 13, 16, 17, 18};//中间几个格子
const int mve[9][9] = {
	{1, 3, 7, 12, 16, 21, 23}, 
	{2, 4, 9, 13, 18, 22, 24}, 
	{11, 10, 9, 8, 7, 6, 5}, 
	{20, 19, 18, 17, 16, 15, 14}, 
	{24, 22, 18, 13, 9, 4, 2}, 
	{23, 21, 16, 12, 7, 3, 1}, 
	{14, 15, 16, 17, 18, 19, 20}, 
	{5, 6, 7, 8, 9, 10, 11}
};//每种操作涉及到哪几个位置
int step, g[30], ans[N];

int h(){
	int mp[4] = {0};
	for(int i=1;i<=8;i++)
		mp[g[idx[i]]]++;
	int cnt = 10;
	for(int i=1;i<=3;i++)
		cnt = min(cnt, 8 - mp[i]);
	return cnt;
}//估价函数

void calc(int op){
	int x = g[mve[op][0]];
	for(int i=0;i<6;i++)
		g[mve[op][i]] = g[mve[op][i + 1]];
	g[mve[op][6]] = x;
}//模拟循环移位操作

bool dfs(int now, int lst){
	if(h() + now > step)
		return 0;//预估的步数加上当前步数大于限制步数，不能再走了
	if(!h())
		return 1;//中间全部一致了
	for(int i=0;i<8;i++){
		if(lst == oppo[i])
			continue;//不要做上一个步骤的逆操作，这样会回到两步前
		calc(i);
		ans[now] = i;
		if(dfs(now + 1, i))
			return 1;
		calc(oppo[i]);//回溯，恢复矩阵
	}
	return 0;
}

int main(){
	while(true){
		for(int i=1;i<=24;i++){
			scanf("%d", &g[i]);
			if(!g[i])
				return 0;
		}
		if(!h()){
			printf("No moves needed\n%d\n", g[7]);
			continue;
		}
		step = 1;//初始化！初始化！初始化!
		while(!dfs(0, -1))
			step++;//IDA* 精华
		for(int i=0;i<step;i++)
			putchar('A' + ans[i]);
		printf("\n%d\n", g[7]);
	}
	return 0;
}
```

~~愣是用这几个技巧从 138 行缩到 74 行。马蜂应该海星吧。~~

