这是一个和出题人标解不太一样的做法，并且好像复杂度更优？


令$m_i=111...1$($i$位)，$|n|$是$n$的位数.此问题可以理解成：让$x=x+m_i/ x-m_i$花费$i$的代价，令$x=0$花费最小的代价。

记$dp_{y,x}$代表你加减完所有$m_i (i > y)$并且当前值为$x$的最小代价. 使用```map/unordered_map```和高精度整数来实现$dp_y$. 初始时$dp_{|n|+1,n}=0$

对每个状态$x$在$dp_{y}$中，对$dp_{y-1}$的转移只有两种选择。 不妨设$x$非负那么可能的转移只有$x-km_y$和$x-(k+1)m_y$，此处$x-km_y$非负而$x-(k+1)m_y$为负。即在做完$m_y$的加减之后必然有$|x|<m_y$，其他情况均不优，证明如下：

每个$m_y$都不应该被使用超过$10$次(实际上这个界很松，可以继续下放),否则你总是可以把$10m_y$($10y$个$1$)变成$m_{y+1}-m_1$($y+2$个$1$).如果$|x| \geq m_y$而不使用$m_y$来减少它, 考虑到$\sum_{i=1}^{y-1} 9m_i < \sum_{i=1}^{y-1}10^{i+1} = m_y$, 必然存在$m_i(i<y)$被使用超过$10$次否则你无法将$x$归零。此时必然存在更优解。


回到正题，看上去状态数最多能到$2^{50}$但实际上最多只有$O(|n|)$个，证明如下：


我断言对$dp_y$的所有状态$x$所有$x \mod m_{y}$的值恰好只落在一个长度为$O(|n|)$的区间$[a,b]$. (鉴于是模意义下，$[a,m_{y}-1] \cup [0,b]$也认为是一个区间）

初始时刻$x$只有一种可能，显然是满足的。

既然对$x\pm km_{y}$不影响$x \mod m_{y}$,那么对$dp_{y-1}$的状态$x$，所有$x \mod m_{y}$也落在$[a,b]$.

又因为如我们之前所说$dp_{y-1}$的状态$x$都是满足$|x|<m_y$, 这意味着$x$的可能取值范围只有两个区间的并：$[a-m_y,b-m_y] \cup [a,b]$. 

注意到$a-m_y=a-10m_{y-1}-1\equiv a-1 (\mod m_{y-1})$. 所以$x \mod m_{y-1}$的范围实际上就是$[a-1,b-1] \cup [a,b] =[a-1,b]$, 比$[a,b]$长度只增大了$1$.所以可以得出结论$[a,b]$的长度是$O(|n|)$的.既然如此$x$的可能取值范围$[a-m_y,b-m_y] \cup [a,b]$也只有$O(|n|)$个数。

那么我们的算法也就出来了，从$|x|+1$到$1$枚举$y$($O(|n|)$次), 枚举$dp_y$里的状态$x$并且更新$dp_{y-1}$ (最多$O(|n|)$个), 高精度运算$O(|n|)$和```map```复杂度$O(log|n|)$,总的时间复杂度是$O(|n|^3log|n|)$.


[my code](https://codeforces.com/contest/1487/submission/107625296)