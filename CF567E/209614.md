# 最短路上的边判定

### 可能在最短路上的边

分别从起点到终点以及从终点到起点两边做dijkstra算法，通过判断这条边的松弛结果是否发生改变就可以判断是否在最短路上，因为对于边权值为w的有向边e=(u,v)，如果最后结果中dis[u]+w=dis[v]成立，说明不存在一条边（或者路径）对这两个端点的松弛具有更好的结果的，也即从u到v的最短路径可能经过这条边。但是仅仅这条结论离我们的要求还是不够的，我们还需要保证存在经过点u的最短以及点v的最短路，这能才能保证点u以及点v可能出现在最短路径上，在这个条件的基础上，结合上一条判断便可以得到我们的要求。

```cpp
if (dis[0][x] + w == dis[0][y] && dis[0][x] + dis[1][x] == dis[0][t] && dis[0][y] + dis[1][y] == dis[0][t])
```

其中dis[0]表示对从s到t做dij的结果，dis[1]表示从t到s做dij的结果。

```cpp
if (dis[0][x] + w + dis[1][y] == dis[0][t])
```

容易证明这两个判断是等价的。

另外注意这里写dij的时候，访问过的点一定要contiune，否则回出现同一个点被加多次的情况。


### 必定在最短路上的边

这个问题的解法我没有想出来，搜到了一道差不多的题目然后看题解才懂的做法。

参考题目[cf_567E](https://codeforces.com/problemset/problem/567/E)

- 利用乘法原理

    我们可以维护一个从起点s到u的路径数量$d_1$和从终点t到v的路径数量$d_2$，如果要满足是必要边的条件，那么必然有从起点s到终点t的路径数量$d_3=d_1\times d_2$。因为数据比较大，需要维护取模。

- 使用割边

    将可能在最短路上的边存起来并建立双向边，可以得到一个无向图，若某条边一定是最短路上的边，说明需要一定通过这条边到达终点，说明这是一条割边。不过注意因为加入的是双向边，所以最后结果可能存的必要边的反向边。