> 给定 $n$ 次操作，每次在 $(x_i, y_i)$ 处放置 $z_i$ 个正方体后求整个图形露在外面（接触空气）的侧面积。

### 分析

注意到 $x, y$ 的范围很大而 $n$ 的范围很小，因此整个图形是稀疏的。我们不能使用普通的数组来存储（这样存储效率太低且 MLE），于是考虑使用 $\textrm{STL}$ 中的 `std::map` 来存储。 其第一关键字可以用一个 `std::pair` 来记录点的横纵坐标，而第二关键字用于记录该坐标的方格数。后面使用时当数组使用即可。

接下来来到本题的核心部分：如何实时更新答案？

为了实现方便，我们考虑容斥原理：先假设四周没有方块，答案直接加上 $4z$ ，再减去被遮挡的面的面积的 **$2$ 倍**（重合的面永远是成双的）。

而我们注意到，在每一次操作后，每一个面都无非是以下几种情况：

1. 「万丈高楼拔地起」形。该面上没有其他的方格。此时重复面面积为 $0$。
2. 「与我无关」形。每一个点上的方块可能会被放置多次，此时如果原本立柱就比相邻面上的高，也没有重复面。
3. 「望之不及」形。虽然放置了，也不如相邻面高，此时重复面积即为该次放置的立柱高度 $z$。
4. 「后来者居上」形。这是重复的面积仅为旁边立柱的高度与当前方格上原有立柱的高度之差，即 $h_{x',y'}-h_{x, y}$（ $(x', y')$ 与 $(x, y)$ 相邻）。

统计答案即可。

**注意：数据范围十分毒瘤，不开 ull 见祖宗 qwq**

### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;

typedef unsigned long long ULL;
const int N = 3e5 + 5;
const int xx[] { -1, 0, 1, 0 }, yy[] { 0, 1, 0, -1 };
map < pair < int, int > , ULL > mp;
int n;
ULL ans;

int main() {
  scanf("%llu", &n);
  for (int i = 1; i <= n; ++i) {
    int x, y; ULL z;
    scanf("%d%d%llu", &x, &y, &z);
    ULL &p = mp[make_pair(x, y)]; // 原有高度
    ans += z << 2; // 先假设四周没有重复
    for (int k = 0; k < 4; ++k) {
      int nx = x + xx[k], ny = y + yy[k]; // 枚举四个方向
      ULL t = mp[make_pair(nx, ny)]; // 旁边的高度
      if (t > p) { // 如果旁边的比自己原来的高才有新增重复面
        if (t >= p + z) ans -= z << 1; // 分析中的第三种情况
        else ans -= t - p << 1; // 分析中的第四种情况
      }
    }
    p += z; // 更新该点的高度
    printf("%llu\n", ans);
  }
  return 0;
}
```

