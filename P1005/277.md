我们可以注意到，每一行都是独立的，即我们可以把每一行都分别算完后最后将各行结果相加，有数据规模看，需要用到高精度运算。 


由样例1的解释看，固守本分的一路作下去，最大会出现1000\*2^80，需要编写高精度乘法，提高了程序的空间复杂度。因此，可以在每一层运算中先将2乘入.



F[i,j]:=max{2\*(data[i]+F[i+1,j]),2\*(data[j]+F[i,j-1])}。

F[i,j]表示从i到j这一段数据的最大值，其计算方法解释如下： 


我们需要用L(从1到m)来控制i-j段的长度，每次i都从头到尾走一遍，j=i+l-1。

当L=1，i=1时，j=1，F[1,1]=max{2\*（data[1]+F[2,1]),2\*(data[1]+F[1,0])}，由于此时F[2,1]、F[1,0]值为0，所以L=1时数据最大值就是2\*data[i]。


要注意的是，这里的data[i]将会是最后一个取走的元素。

当L=2，i＝1时，j＝2，F[1,2]=max{2\*（data[1]+F[2,2]),2\*(data[2]+F[1,1])}，


此时L=1时计算得的就要用上了；我们假设数据max都是前者，那么F[1,2]=2\*(data[1]+F[2,2])=2\*(data[1]+2\*data[2])。


在看一个，L=3，i＝1时，j＝3，同样假设，F[1,3]=2\*(data[1]+2\*(data[2]+2\*data[3]))。


如样例1第一行数据的计算：F[1,3]=2\*(1+2\*(2+2\*4））＝1\*2+2\*2^2+4\*2^3。


这样就可以逆向将长度为3的i-j段的最大值求出，最后的F[1,m]就是每行的最大值了。
