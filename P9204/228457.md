## 1. 编程思路。

火鸟在移动时有四种选择：

1）向右上移动 $1$ 格，设为操作 A，此操作将使 X 坐标加 $1$，Y 坐标也加 $1$。

2）向右下移动 $1$ 格，设为操作 B，此操作将使 X 坐标加 $1$，Y 坐标减 $1$。

3）向左下移动 $1$ 格，设为操作 C，此操作将使 X 坐标减 $1$，Y 坐标也减 $1$。

4）向左上移动 $1$ 格，设为操作 D，此操作将使 X 坐标减 $1$，Y 坐标加 $1$。

在移动过程中，奇数步只能选择操作 A 或操作 C，偶数步只能选择操作 B 或操作 D。

我们可以这样来考虑。先将 X 坐标移动到位。为了使移动步数最少，如果 $x_2>x_1$，奇数步只能选择操作 A，偶数步只能选择操作 B，每次操作均将 X 坐标加 $1$，一直从 $x_1$ 移到 $x_2$，移动次数 $dx$ 为 $x_2-x_1$。此时，Y 坐标的变化是 $+1,-1,+1,-1,...$。也就是说，若移动次数 $dx$ 是偶数，则 Y 坐标保持不变，若是奇数，则 Y 坐标加 $1$，即 $y_1+1$。

如果 $x_2<x_1$，则奇数步只能选择操作 C，偶数步只能选择操作 D，每次操作均将 X 坐标减 $1$，一直从 $x_1$ 移到 $x_2$，移动次数 $dx$ 为 $x_1-x_2$。此时，Y 坐标的变化是 $-1,+1,-1,+1,...$。也就是说，若移动次数 $dx$ 是偶数，则 Y 坐标保持不变，若是奇数，则 Y 坐标减 $1$，即  $y_1-1$。

X 坐标移动到位后，再来考虑将 Y 坐标移动到位。

如果 $y_2>y_1$，则奇数步选择操作 A，偶数步选择操作 D，每次移动均将 Y 坐标加 $1$，移动次数 $dy$ 为 $y2-y1$。

如果 $y_2<y_1$，则奇数步选择操作 C，偶数步选择操作 B，每次移动均将 Y 坐标减 $1$，移动次数 $dy$ 为 $y1-y2$。

由于在移动 Y 坐标到位的过程中，X 坐标已提前到位。因此，为保证 X 坐标不变，$dy$ 必须是偶数，否则无解。
若 $dy$ 是偶数，则可行的最少移动步数为 $dx+dy$。

## 2. 源程序。

```c
#include <stdio.h>
int main()
{
	int x1,y1,x2,y2;
	scanf("%d%d%d%d",&x1,&y1,&x2,&y2);
	int t;
	int dx=x2-x1;      // 先将x坐标走到位
	if (dx<0) { dx=-dx; t=-1;}
	else t=1;
	if (dx%2==0) t=0;  // 如果x到位过程走偶数步，y坐标是不变的
	y1=y1+t;
	int dy=y2-y1;     // 再看y坐标能否到位
	if (dy<0) dy=-dy;
    if (dy%2==0)     // 为了在y坐标到位的过程中x坐标保持不变，只能走偶数步
        printf("%d\n",dx+dy);
    else
        printf("-1\n");
	return 0;
}

```


