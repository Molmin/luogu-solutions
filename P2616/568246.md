这题乍一看以为是最短路，觉得要申黄。仔细一看才发现很水。

**大意：贪心**

1. 对于每个价格，加上他们要走的路程，也就是 $(K-X)$，那么整体的价格就为 $(K-X)+C$。

2. 排一遍序（升序），然后从前往后遍历最小值直到买完所有商品。

3. 输出答案。

需要注意的几个点：

1. 排序要是升序排列。因为题目说不能往回走，所以前面买的自然就不能比后面的大。这样也得不到最优解。

2. 函数最好调用库里面有的。不然手打最小值很容易造成错误。

3. 尽量，尽量不要使用 $STL$ 库，锻炼自己的手打能力。

代码 **杜 绝 抄 袭**（上文看不懂下面有注释）：
```cpp
#include<cstdio>
#include<iostream>
int K,E,N,X,ans;
int F[105],P[105],C;
int main()
{
    scanf("%d%d%d",&K,&E,&N);
    for(int i=1;i<=N;i++)
    {
		scanf("%d%d%d",&X,&F[i],&C);
		P[i]=(E-X)+C;//上文提到
	}
	for(int i=1;i<=N-1;i++)//对数组进行排序
		for(int j=1;j<=N-i;j++)
			if(P[j]>P[j+1])//以价格为基准进行判定
			{
				std::swap(P[j],P[j+1]);
				std::swap(F[j],F[j+1]);//F[]跟着P[]交换
			}
    for(int i=1;i<=N&&K>0;i++)//此处还要判断商品还需不需要，即K>0
    {
		ans+=std::min(K,F[i])*P[i];//当此时不需要买那么多商品时，就把剩下还需要的买空，不然就把这个商店的商品买完，当然也承担了路费
	    K-=F[i];//需要的商品数--
    }
    printf("%d",ans);
    return 0;
}
```

