这是个不同于扫描线的做法。首先将圆按半径从大到小排序为 $(c_1, \cdots, c_n)$。于是对每个圆 $c_i$，它只会被编号比 $i$ 小的那些圆包含，设其被 $k_i$ 个圆包含，则它对答案的贡献为 $(-1)^{k_i} \times S(c_i)$，其中 $S(c_i)$ 表示圆 $c_i$ 的面积。

对每个 $i$，我们希望快速地求出 $k_i$。可以发现，若圆 $c_i$ 被若干个圆包含，其中编号最大（即半径最小）的圆为 $c_j$，那么 $k_i = k_j + 1$；若 $c_i$ 不被任何圆包含，则 $k_i = 0$。于是问题转化为求包含 $c_i$ 的最小圆，或判断其是否不被任何圆包含。

我们将所有圆划分成 $\left\lceil\log_2 \max_{1 \le i \le n} r_i\right\rceil$ 类，对所有第 $i$ 类圆 $c_j$，满足 $2^{i - 1} \le 2 \times r_j \lt 2^i$，其中 $r_j$ 表示圆 $c_j$ 的半径。接着对所有 $i$，将第 $i$ 类圆放入一个坐标系，并将此坐标系划分成若干个边长为 $2^i$ 的正方形。对每个正方形，存下所有“圆面与该正方形面有交”$\,^*$的圆。注意到一个正方形内的圆关于包含关系构成一座森林，但每个连通块都是一条链（这正是分类方法的精髓），同时这座森林的连通块个数是 $O(1)$ 的。

于是解法呼之欲出：我们枚举 $i$，再枚举每个类，算出 $c_i$ 的圆心在该类中所在的正方形，并检查该正方形对应森林的每一条链，若链顶（即最大的圆）包含了 $c_i$，我们就在该链上二分出 $c_i$ 的位置，否则直接跳过这条链。总的时间复杂度是 $O(n \times (\log n + \log \max r))$。

类似的一道题：[P4631 [APIO2018] Circle selection 选圆圈](https://www.luogu.com.cn/problem/P4631)

$*$：实际上并不需要判断是否有交：每个正方形直接存圆心在周围的 9 个正方形内的那些圆，是个更方便的选择。