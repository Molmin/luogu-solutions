这道题一看数据30%一定是卡的搜索，所以对于30%的题我们可以用DFS对没个数位上的数字进行枚举，最后枚举完了然后从前往后跑一边，看是否符合题意。

期望得分30分

由于此题数据范围看上去很像DP，n^2肯定能过，所以我们不妨设置一个数组f[i][j]表示1-i中有j个<符号。

那么我们来讨论一下其与f[i-1][j-1]以及f[x-1][y]的关系。

1.与f[i-1][j-1]

在这种情况下，由于我们是从前往后去推的，所以当前加入的数一定比前面的都大。那么怎么才能使得其变为前n个有j个<呢？

仔细想一下你就会发现，你把这个数插入任何一个数后面，都必将“形成”一个小于号，但是如果我们插入到一个已经形成小于号的两数之间，则小于号数量就不会改变，因为前i-1个数都比当前的i小，所以一共有i-1个空位，但是又有j-1个空位已经形成<号，所以在这种情况下，前i个数形成的每一个有j-1个<的数列都可以形成(i-1)-(j-1)个新的前i个数中有j个<的数列，于是从f[i-1][j-1]能够推出f[i][j]的一部分为f[i-1][j-1]\*((i-1)-(j-1))。

2.与f[i-1][j]

那么刚刚是说明了你加入这个数增加了一个小于号的情况。但如果我不增加呢？

我前i-1个数已经形成了j个<。那么我加入i使其不会增加小于号要怎么做呢？

由于上文我已经说过你把这样的i插入两个之间已经是<号的数之间是不会增加<的数量的。所以这样的空位，每一个形成前i-1数有j个<的数列就有j个这样的空位。

但是你还可以放在最前面，所以其实是j+1个。

由此我们可以推出状态转移方程f[i][j]=f[i-1][j-1]\*(i-j)+f[i-1][j]\*(j+1);

说明完毕

但是我还想聊聊关于推导这样公式的一个思维。

我一开始直接是打的DFS，然后我就开始想DP，需要学会看数据范围来猜做法，这样的数据一般是公式或者DP。

那么你如果想到了DP就很容易能想出这样的状态。接下来就是推状态转移方程。

很多人说状态转移方程不好推，但我觉得那是你没利用好现有的资源。

之前我不是写了个DFS吗？

那么我就把这个DFS拿来求每层的数据，一步一步慢慢推，仔细观察状态，然后结合题目，你其实就可以推出状态转移方程了。最重要的不是说想出状态或者是什么，而是理解这个状态的含义，和去思考为什么是这样的状态，DP最重要的就是状态，仔细去推方可解题。

那我就放上我的DP代码，我就不放出我的DFS了

    

```cpp
#include<bits/stdc++.h>
using namespace std;
int k,n,ans=0;
int a[15],vis[15]={0},t,f[1005][1005];
int main()
{
    //freopen("num.in","r",stdin);
//    freopen("num.out","w",stdout);
    scanf("%d %d",&n,&k);
            for(int i=1;i<=n;i++){f[i][i-1]=1;f[i][0]=1;};
            for(int i=1;i<=n;i++)
            {
                for(int j=1;j<i-1;j++)
                {
                    f[i][j]=f[i-1][j-1]*(i-j)%2015+f[i-1][j]*(j+1)%2015;
                    f[i][j]=f[i][j]%2015;
                }
            }
            cout<<f[n][k];
        }

```