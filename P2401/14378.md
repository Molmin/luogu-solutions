对于这个奇怪的形似数论的模型，比较容易想到的就是DP了

如果以“n个格子填入1-n”的方向思考很显然由于必须记录填过的数与格子，很可能退化为搜索的思路

不妨将这题想成“将n个数从小到大插入数列”

那么对于当前插入的数，如果插入在<号两端的数中间或数列最左端，那么就会使>的数量+1

同理，如果插入在>号两端的数中间或数列最右端，那么就会使<的数量+1

f[i][j]表示前i个数中恰有j个<的方案数

f[i][j]=f[i-1][j]×(j+1)+f[i-1][j-1]×(i-j)
```cpp
#include<cstdio>
using namespace std;
int n,k,f[1010][1010];
int main()
{
	scanf("%d%d",&n,&k);
	f[1][0]=1;
	for(int i=2;i<=n;++i)
	{
		f[i][0]=1;
		for(int j=1;j<i;++j)
		{
			f[i][j]=(f[i-1][j]*(j+1)+f[i-1][j-1]*(i-j))%2015;
		}
	}
	printf("%d",f[n][k]);
	return 0;
}
```