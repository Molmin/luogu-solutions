### [P2401 不等数列](https://www.luogu.org/problemnew/show/P2401)

--------

几篇题解都很好，尤其是 Drifterming 的版本，简单易懂，也让我彻底理解了这道题的做法

然而~~他们太巨了~~，有些步骤有点省略，本蒟蒻在这里写一篇详细版的供参考。

一拿到这道题，就知道暴力深搜枚举全排列是不行的，明显会TLE。最好的做法是DP。

可是 f 数组好定义，状态转移方程却不好想。于是我在定义了f 数组的基础上，分类讨论了一番。

f [ i ] [ j ] 表示 1 ~ i 这 i 个数 , 其中j 个 " < " 有几种方法 

----------
假设我们已经把 n - 1 个数排好了，现在我们要在其中插入第 n 个数

#### n 大于这个数列中的任何数

1.	若 n 插在第一个数之前，因为它比第一个数大，则多一个 " > "

2.  若 n 插在最后一个数之后，同上，多了一个 " < "

3.	若 n 插在 " < " 之前，因为它比 " < " 之后的数大，所以 " < " 变成 " > "，而它比前面的那个数大，所以它前面添加了一个 " < " .

	综合来看，多了一个 " > ";
    
    Example:
    
    2 < 4     ---->     2 < 5 > 4
    
4.	若 n 插在 " > "，同上，多了一个 " < "  
    
--------

--------

用状态转移方程，则表示为：

1.	f [ i ] [ j ] = f [ i-1 ] [ j ]
	
    // " < " 个数没变，所以 j 不变，而插入一个数，数是比之前多 1 的

2.	f [ i ] [ j ] = f [ i - 1 ] [ j - 1 ]
	
    // 多了一个数，又多了一个 " < "
    
3.	f [ i ] [ j ] = f [ i - 1 ] [ j ] * j

	// " < " 个数没变，所以 j 不变；但是 n 可以插在这 j 个 " < "中的任意一个之前，所以方案数增多 j 个
    
4.	f [ i ] [ j ] = f [ i - 1 ] [ j - 1 ] * ( i - j -1 )

	// 与上同理，不过这次是插在 " > " 之前了，因此方案增多数等于 " > " 个数，也就是总的符号个数 ( i - 1 )，减去 " < "的个数 ( j )，也就是 ( i - j -1 )

--------


合并同类项，可得：

### f [ i ] [ j ] = ( f [ i - 1 ] [ j - 1 ] x ( i - j ) % 2015 + f [ i - 1 ] [ j ] x ( j + 1 ) % 2015 ) % 2015

~~不好意思Markdown把"*"吞掉了，我只能用x来表示乘~~


代码见下：

```cpp

#include <iostream>
using namespace std;

int n,k;
int f[1004][1004];   // f [ i ] [ j ] 表示 i个数,j个<有几种 

int main()
{
	cin >> n >> k;
	
	f[1][0] = 1;     // 一个数，没有 " < " ,只有一种
	
	for(int i=2; i<=n; i++)
	{
		f[i][0] = 1;    //没有 " < "，单调递减，只有一种 
		
		for(int j=1; j<=min(k,i-1); j++)
		{
			f[i][j] = ( f[i-1][j-1]*(i-j) % 2015 + f[i-1][j]*(j+1) % 2015 ) % 2015;
		}
	}
	
	cout << f[n][k] << endl;
	
return 0;	
}


```

写了这么多，望通过 QAQ




