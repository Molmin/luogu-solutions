## 好久没写题接了，有点没手感
### 这道题是我们考试使用的。

想要做题，一定要先理解这道题的意思。

数列，数列（sequence of number）是以正整数集（或它的有限子集）为定义域的函数，是一列有序的数。

数列中的每一个数都叫做这个数列的项。排在第一位的数称为这个数列的第1项（通常也叫做首项），排在第二位的数称为这个数列的第2项，以此类推，排在第n位的数称为这个数列的第n项，通常用an表示。

著名的数列有斐波那契数列，三角函数，卡特兰数，杨辉三角等。

三角形数

传说古希腊毕达哥拉斯（约公元前570-约公元
500年）学派的数学家经常在沙滩上研究数学问题，他们在沙滩上画点或用小石子来表示数。比如，他们研究过：
 
由于这些数可以用如右图所示的三角形点阵表示，他们就将其称为三角形数。

正方形数

类似地，  被称为正方形数，因为这些数能够表示成正方形。因此，按照一定顺序排列的一列数称为数列。
概念


函数解释

数列的函数理解：
①数列是一种特殊的函数。其特殊性主要表现在其定义域和值域上。数列可以看作一个定义域为正整数集N*或其有限子集{1，2，3，…，n}的函数，其中的{1，2，3，…，n}不能省略。

②用函数的观点认识数列是重要的思想方法，一般情况下函数有三种表示方法，数列也不例外，通常也有三种表示方法：a.列表法；b。图像法；c.解析法。其中解析法包括以通项公式给出数列和以递推公式给出数列。

③函数不一定有解析式，同样数列也并非都有通项公式。
一般形式
数列的一般形式可以写成

简记为{an}。
项

数列中的项必须是数，它可以是实数，也可以是复数。
用符号{an}表示数列，只不过是“借用”集合的符号，它们之间有本质上的区别：1.集合中的元素是互异的，而数列中的项可以是相同的。2.集合中的元素是无序的，而数列中的项必须按一定顺序排列，也就是必须是有序的。

分类编辑

（1）有穷数列和无穷数列：
项数有限的数列为“有穷数列”（finite sequence）；

项数无限的数列为“无穷数列”（infinite sequence）。

（2）对于正项数列：（数列的各项都是正数的为正项数列）
1）从第2项起，每一项都大于它的前一项的数列叫做递增数列；如：1，2，3，4，5，6，7；

2）从第2项起，每一项都小于它的前一项的数列叫做递减数列；如：8，7，6，5，4，3，2，1；

3）从第2项起，有些项大于它的前一项，有些项小于它的前一项的数列叫做摆动数列（摇摆数列）；

（3）周期数列：各项呈周期性变化的数列叫做周期数列（如三角函数）；

（4）常数数列：各项相等的数列叫做常数数列（如：2，2，2，2，2，2，2，2，2）。

公式编辑
（1）通项公式：数列的第N项an与项的序数n之间的关系可以用一个公式an=f(n)来表示，这个公式就叫做这个数列的通项公式，如  。数列通项公式的特点：1）有些数列的通项公式可以有不同形式，即不唯一；2）有些数列没有通项公式（如：素数由小到大排成一列2，3，5，7，11，...）。

（2）递推公式：如果数列{an}的第n项与它前一项或几项的关系可以用一个式子来表示，那么这个公式叫做这个数列的递推公式。数列递推公式特点：1）有些数列的递推公式可以有不同形式，即不唯一。2）有些数列没有递推公式，即有递推公式不一定有通项公式。
//出自百度百科

总之这道题的意思就是说把1-n进行排列，问有多少种排列刚好有K个小于号

先把正确的代码粘上，我们再来一句一句的看。

```cpp
#include<bits/stdc++.h>
using namespace std;
int dp[1010][1010];//dp[i][j]=dp[i-1][j]*(j+1)+dp[i-1][j-1]*(i-j);
int n,m;
unsigned long long ans;
int Read()
{
	int x=0,f=1;
	char c=getchar();
	while(c<'0'||c>'9')
	{
		if(c=='-') f=-1;
		c=getchar();
	}
	while(c>='0'&&c<='9')
	{
		x=x*10+c-'0';
		c=getchar();
	}
	return x*f;
}
int main()
{
	int i,j;
	n=Read();
	m=Read();
	dp[0][0]=1;
	for(i=1;i<=n;i++)
	{
		for(j=0;j<=m;j++)
		{
			dp[i][j]=dp[i-1][j]*(j+1)+dp[i-1][j-1]*(i-j);
			dp[i][j]%=2012;
		}
	}
	printf("%d",dp[n][m]);
	return 0;
}
```

这道题就是DP，核心在于：

```cpp
dp[i][j]=dp[i-1][j]*(j+1)+dp[i-1][j-1]*(i-j);
```
主要是由很多种可能，大于，或小于，或者在边界上。

当你理解了这句话，你就明白了！