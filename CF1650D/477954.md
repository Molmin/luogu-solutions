# 分析
**问题转换**：因为第 $i$ 轮的操作并不会影响到 $i$ 之后的数字，所以我们可以看成每次操作后往原序列末尾添加一个数。因为是从小到大添加，所以不可能在大数之间添加小数。  
**操作分析**：对于每一次操作，我们设操作完的序列为 $b$，$b$ 在经过若干次操作后将成为 $a$ 的一个不连续子序列，否则将无法完成操作。这次操作后插入一个数 $w$，为保证序列仍是 $a$ 的一个不连续子序列，设 $b$ 的最后一项在 $a$ 中位置为 $j$ ，则 $b_j$ 应为 $a_k(1 \le k \le j)$ 使得不存在 $z(k\le z \le j)$ 使得 $a_z<w$。们在这轮操作需要做的就是将当前 $b$ 中的这项移到末尾。说人话，就是将 $b$ 中的一个数，它在 $a$ 中在新加入的数的右边且是在当前 $b$ 中距离新加入的数最近，使用操作移到序列最末尾。  
**无解**：根据上面的操作，显然不可能无解。  
```cpp
scanf("%d", &t);
while (t--) {
	memset(ans, 0, sizeof(ans));
	itt = 2; //init
	scanf("%d", &n);
	for (int i = 1; i <= n; i++) {
		scanf("%d", &a[i]);
		ton[a[i]] = i; //用桶标记i的位置
	}
	for (int i = 1; i < n; i++) {
		itt = ton[i]; //当前序列的结尾，就是上次插入的
		it = ton[i + 1]; //从新插入的数往前扫，找到最近的b[j]
		while (a[it] > i) { //往前找b[j]
			it--;
			if (it == 0) it = n;
		}
		while (a[itt] != a[it]) { //在当前b中找到j
			itt--;
			if (itt == 0) itt = n;
			while (a[itt] > i) {
				itt--;
				if (itt == 0) itt = n; //指针往前移动模拟一次操作
			}
			ans[i]++; //顺便累加操作次数
		}
	}
	itt = ton[n]; //最后将序列转到正确的位置
	it = n;
	while (a[itt] != a[it]) {
		itt--;
		if (itt == 0) itt = n;
		ans[n]++;
	}
	for (int i = 1; i <= n; i++) {
		cout << ans[i] << ' '; //输出
	}
	cout << endl;
}
```
时间复杂度 $O(n^2)$

$\text{Update}$：更改了码风