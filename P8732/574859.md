## 1. 前言
本文的分析会比较通俗，自己要多去思考，麻烦一定 _仔细全部看完_，有异议、不懂或认为可以优化请私信反馈呢。  

## 2. 题目解析：
首先，这是一道比较纯的贪心题，按题目要求，我们分析一下。  
输入一个个访问时间，我们将它分为三部分:
* 发消息前 ——> 进入并且问了个问题。
* 发消息中 ——> 获得解答后开心地~~以超越时间的速度~~发了我们要求时刻的消息。
* 发消息后 ——> 走出办公室，换下一个人循环。

显而易见的，**要想让后面的尽早发，那么前面的时间越短越好**。因为越靠前的人，他的耗时影响的人越多【所以后面的人和他一起等】，和接水问题思路差不多。 

_排序思路：总时间从小到大。 最后记录时刻输出即可。_

## 3.提示要点：
* 时刻是**个体的累计，不是最后一个人**！
* 时刻**不能输入时预处理，我们那时还不知道进入顺序**。
* 排序比较函数写全面。

## 4.代码写作：
理论存在，实践开始。  

代码理有详细的注释幺~
```cpp
#include<bits/stdc++.h>
using namespace std;
long long ans,n,ke;//ke是时刻
struct aaa{
	long long s,a,e,sum;//sum是总和，其他的在题目里
}a[1005];
bool cmp(aaa a,aaa b){
	return a.sum<b.sum;//按思路排序
}
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i].s>>a[i].a>>a[i].e;
		a[i].sum=a[i].a+a[i].s+a[i].e;//预处理求总和
	}
	sort(a+1,a+n+1,cmp);
	for(int i=1;i<=n;i++){
		ke+=a[i].a+a[i].s+a[i-1].e;//累计时刻
		ans+=ke;
	}
	cout<<ans;
	return 0;
}
```

## 5.总结鸣谢：
**本题是一道考验耐心思维的贪心，难度适中。**  
**另：还有感谢管理大大的的审核帮助。**