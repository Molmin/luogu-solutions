解题思路如下：
1. 记录t中包含哪些数字字符，并统计每个数字字符的个数。
2. 考虑替换性，把5的个数统计到2的计数里面，9的计数加到6的计数里面，比如t=2521，统计结果是需要1个1，3个2，其它均为0.
3. 统计已有的冰块上有哪些数字，和上面一样，5的个数统计到2的计数里面，9的计数加到6的计数里面。
4. 这样你就得到了对于每个数字，t中包含几个，冰上有几个。例如，t=2521，已有冰上的字符122213459，则可以列出以下的表：
```cpp
数字	需求	已有
0	0	0
1	1	2
2	3	4
3	0	1
4	0	1
5	0	0
6	0	1
7	0	0
8	0	0
9	0	0
```
对于需求为0的行，不用管（注意表中数字为5和9的行，“需求”和“已有”都一定会是0，因为已经分别加到数字2和6的计数中去了）；需求大于0的行，用“已有”/“需求”就是可以拼出的个数。这里对于数字“1”，可以拼出2组，但是数字“2”，只能拼出1组，所以最后答案就是1.

以下代码中给出了必要的注释。
#### 代码
```cpp
#include<cstdio>
#include<cstring>
char t[10]; //字符串，记录喜欢的数字  
char a[210]; //字符串，记录冰块上已有的所有数字
int h[10];  //记录0~9每个数字在冰块上分别有多少个
int need[10]; //记录0~9每个数字在t中分别有多少个
int main(){
	int i,n,j,c,min;
   for (j=0;j<10;j++){
      need[j]=0;h[j]=0;	//赋初值
	}
	scanf("%s",t);
	scanf("%s",a);
   n=strlen(t); 
   for(i=0;i<n;i++)
   	   for (j=0;j<10;j++)
		   if(t[i]==j+'0') need[j]++; 
        //统计0~9每个数字在t中分别有多少个
	need[2]+=need[5];
	need[6]+=need[9];
	need[5]=0;
	need[9]=0; 
   //以上4行，把5的需求转化为对2的需求，
   //把对9的需求转化为对6的需求，方便后面求解。
   //这样以后就不需要5和9了。

	n=strlen(a); 
	for (i=0;i<n;i++)
        for (j=0;j<10;j++)
		   if(a[i]==j+'0') h[j]++;
        //统计0~9每个数字在已有冰块中分别有多少个
	h[2]+=h[5];
	h[6]+=h[9];
	h[5]=0;
	h[9]=0;	
  //以上4行，把已有的5的数目加到已有的2的数目，
  //把9的加到6的上。
                            
	//for (j=0;j<10;j++)  
	  // printf("%d %d\n",need[j],h[j]);	
  //初学者可以把上面两行去掉注释编译运行一下。
  //得到前面提到的“数字	需求	已有”的那张表。
  	
	min=210;
	c=210;
	for (j=0;j<10;j++){
	   if(need[j]!=0) c=h[j]/need[j];	
	   if (c<min) min=c;
	}
	printf("%d",min);
  
	return 0;
}
```