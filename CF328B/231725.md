~~又来水题解了~~

这题其实真的很简单，其实最重要的思想就只有处理翻转一个数字变成另一个而已。

可以先把 t 中的每个数字的出现次数存储到一个数组里，然后记录给出的每个冰块数量。

其次有两种方法，第一种就是不断地模拟此时是否能还能再拼出一个 t ，大概就是判断此时手中的冰块的各个数字数量是否足够拼一个 t 的数量，若足够那么可以将总数量加一，遇到 2,5,6,9 这四个数字不够的时候，就将可以翻转成这个数字的数字的数量减去缺少的数量。

然后就是第二种，我们可以在计数的时候直接将 5 的数量加到 2 里面，并将 5 清空，然后再把 9 的数量加到 6 里面，接着将 9 清空，最后的时候用除法计算一下每个数字可以组成几个 t 就可以啦~

相比之下，第一种方法更简单，但第二种方法代码更简洁。

方法二代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int tot[15],num[15];
string t,now;
int main(){
	cin>>t>>now;
	int len=t.size();
	for(int i=0;i<len;i++)num[t[i]-'0']++;//记录数量 
	num[2]+=num[5],num[5]=0;//转移 
	num[6]+=num[9],num[9]=0;
	len=now.size();
	for(int i=0;i<len;i++)tot[now[i]-'0']++;
	tot[2]+=tot[5],tot[5]=0;
	tot[6]+=tot[9],tot[9]=0;
	int ans=INT_MAX;//记住要取一个大一点的数 
	for(int i=0;i<=9;i++){
		if(num[i]==0)continue;//记住，遇到0的时候要跳过！不然会RE 
		ans=min(ans,tot[i]/num[i]);//求最小值 
	}
	cout<<ans;
	return 0;
}
```
~~求个赞~~