首先考虑问题本质。

问题是一双靴子能不能走到终点，这个靴子最大跨度为$d$，最大高度为 $s$ 。

如果遇到了高度为 $s$ 的雪堆，这双靴子就过不去了么？

当然不是，这双靴子最大跨度为 $d$ ，如果高度比$s$大，那么这双靴子就能跨过去。

照这么说，总不会所有雪堆都能跨过去吧？

不对，因为跨度最多为 $d$ ，如果高度比 $s$ 大的雪堆连续有 $d$ 堆，那么我的靴子就跨不过去，也就到达不了终点。

这么一分析，问题变成了**连续的高度比 $s$ 大的雪堆的数量是不是比 $d$ 小，如果比 $d$ 小，靴子就能走过去，否则就不能**

再来看一个问题：

现在有 $a$ ， $b$ 两双靴子， $s_a$ 比 $s_b$ 大，那么是靴子 $a$ 不能走的雪堆多，还是靴子 $b$ 不能走的雪堆多？

很显然，靴子 $b$ 不能走的雪堆多。

那么，显然的，我们把靴子按照 $s$ 从大到小排序，那么前面的靴子走不过的路，后面的靴子都不能走，但是这没有用，因为还是得从头开始循环。

那么，怎样才能不从头开始循环捏？

**我们还得把雪堆按照高度从大到小排序！**

但是有的人就问了：排了序我们怎么统计连续的个数呢？

我们每次加入一个数可以为他打上标记，表示他已经进来了。

而他每次进来都要检查他的两边，如果有哪个雪堆有标记，那么他们连起来变成一串大雪堆。

他们每次要合并，合并的话什么最快呢？**并查集！**

那么我们要求的是啥呢？连续的雪堆的大小。

这个我们就放在父节点去处理。

那么显然的，两个节点联合的时候，雪堆大小也是要相加的。

每次相加我们都要统计最大值，然后拿最大值与靴子的跨度$d$比较就行了

代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,b,num[100010],MAX;
bool vis[100010];
int ans[100010];
struct node{//雪堆的结构体，分别代表高度，编号
	int h,id;
}p[100005];
struct point{//靴子的结构体，分别代表高度，跨度，编号
	int h,w,id;
}q[100005];
bool cmp1(const node &a,const node &b){//雪堆的排序函数
	return a.h>b.h;
}
bool cmp2(const point &a,const point &b){//雪堆的排序函数
	return a.h>b.h;
}
int fa[100005];
int find(int x){
	if(fa[x]==x){
		return x;
	}
	return fa[x]=find(fa[x]);
}
void unionn(int x,int y){
	int fx=find(x);
	int fy=find(y);
	if(fx==fy){
		return;
	}
	fa[fx]=fy;//认fy为根节点
	num[fy]+=num[fx];//把fx的节点数量累计进根节点fy里面
	MAX=max(MAX,num[fy]);//统计节点数量最大值
	return;
}
int main(){
	scanf("%d%d",&n,&b);
	for(int i=1;i<=n;i++){
		fa[i]=i;//并查集初始化
		p[i].id=i;
		scanf("%d",&p[i].h);
	}
	for(int i=1;i<=b;i++){
		q[i].id=i;
		scanf("%d%d",&q[i].h,&q[i].w);
	}
	sort(p+2,p+n,cmp1);//按照高度从大到小排序，这里注意，首尾雪堆不需要排序！
	sort(q+1,q+1+b,cmp2);
	int j=2;//目前靴子能走过去的雪堆编号（排序之后的编号！）
	for(int i=1;i<=b;i++){//枚举靴子
		while(q[i].h<p[j].h){//判断这双靴子是不是不能走过目前的雪堆
			vis[p[j].id]=true;//打上标记，表示这个雪堆过不去了
			num[p[j].id]=1;//把大小初始为1（他自己算一个节点）
			if(vis[p[j].id-1]){//判断目前的雪堆左边1个雪堆是不是也被标记
				unionn(p[j].id-1,p[j].id);//合并目前的雪堆和左边的雪堆
			}
			if(vis[p[j].id+1]){//判断目前的雪堆右边1个雪堆是不是也被标记
				unionn(p[j].id+1,p[j].id);//合并目前的雪堆和右边的雪堆
			}
			j++;//目前雪堆靴子走不过去了，枚举下一个雪堆
			MAX=max(MAX,1);//如果暂时没有合并，MAX就是1个节点
		}
		ans[q[i].id]=(q[i].w>MAX);//将MAX与跨度比较，如果跨度比MAX大，就能跨过去，反之就跨不过去
	}
	for(int i=1;i<=b;i++){
		printf("%d\n",ans[i]);
	}	
	return 0;
}//awa
```
