速翻一下官方题解。（字母均是题面中的，优指相邻距离越大）

我们考虑将数列以连续的不超过 $p$ 的数字划分：（如 $a=5,p=23$，以下标 $0$ 开始）

```
0  5  10  15  20
2  7  12  17  22
4  9  14  19
1  6  11  16  21
3  8  13  18
```

可以发现无论哪一行这一列与前一列之间都是等差的，所以可以类比分析。还观察到两列之间的不同行总是在这两列第一行的数之间的，增加一行相当于在区间里面加不同的点，相邻点的距离也会更小。

观察最后一列，发现数值比第一行最后一列更大的数一定不会使距离更大（即上述例子 $\ge 20$ 不是最优）。你可以理解为：最后一列之后的区间是从前面几列一样的完整区间被截掉了一部分，那么情况一定被完整区间的情况包含。

又因为相对来说行越少越优，所以我们就考虑倒数第二行到倒数第一行之间的点（$[15,20]$）。根据上述的类比分析，我们可以把这两行等价转到第一行和第二行处理（$[0,5]$），但是要注意，最后一个点可能会残缺（如最后一个数取到 $13$ 则 $18$ 就会残缺），如果残缺要减去。

观察第一列，设第 $i$ 行第一列为 $b_i$，存在一个 $b_i=(b_{i-1}+\Delta)\bmod a$ 的关系，因为 $b_1=0$，所以有 $\Delta = b_2= \lceil \frac{p}{a}\rceil \cdot a - p$（考虑第二行第一列的值总是第一行最后一列的值 $+a$ 溢出得来的）。

所以我们可以把原先数列的最劣情况等价转成以 $a'=\Delta,p'=a$ 的数列，有前 $n'=\lfloor\frac{a\times n}{p}\rfloor-[最后一个不能取到]$ 项（这是因为考虑每一行都只对应一个 $p$ 的倍数，当然还要特判减去最后一个数残缺的情况）的子问题，但是发现会多出现第一行第二列的一个 $a$。考虑当 $a'\times n<p'$ 时，数列只有一行可以直接算贡献，除了基本的 $a'$ 的贡献，这个 $a$ 还可能会贡献 $a-a'\times n=p'-a'\times n$，两者取最大即可；当 $a'\times n\ge p'$ 时，此时数列有多行，$a$ 不是最优。

考虑新数列第一行最后一个数为 $x$，则第二行第一个数为 $b=x+a'-p' \Rightarrow b-a'=x-p'$，那么我们可以将 $[x,p']$ 的情况等价转到 $[b,a']$ 上，故 $a=p'$ 不是最优的。

但是有些时候 $a$ 减少的还不够多，考虑整个数列同时减去一个数，答案是不变的。所以如果 $\Delta> \frac{a}{2}$，对整个新数列同时减去一个 $p$，则得到 $a'=p-\lfloor \frac{p}{a} \rfloor \cdot a= p \bmod a$，此时就会 $\le \frac{a}{2}$。当 $a$ 很小时，很容易就能取到答案，所以复杂度为 $O(\log_2a)$。

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int a,n,p,h;
int f(int a,int n,int p){
    if(a*n<p) return max(a,p-a*n);
    int nn=a*n/p-(a*n%p<p/a*a-a);
    return f(min((p+a-1)/a*a-p,p%a),nn,a);
}
void solve(){
    cin>>a>>n>>p>>h;
    a%=p;
    if(a<=h||(a*n>p&&f(a,n,p)<=h)) cout<<"YES\n";
    else cout<<"NO\n";
}
signed main(){
    ios::sync_with_stdio(0); cin.tie(0);
    int t; cin>>t;
    while(t--) solve();
    return 0;
}
```

题外：但是 CF 上数据不加 $p \bmod a $ 也能过，单用 $\Delta = a- p\bmod a$ 跑出来貌似没有 $\lceil \frac{p}{a}\rceil \cdot a - p$ 效果好，我用后者过了原本卡 $p \bmod a$ 的点，不知道是不是有什么原理。
