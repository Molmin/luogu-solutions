题目链接[（CF](https://codeforces.com/problemset/problem/1702/C)，[洛谷）](https://www.luogu.com.cn/problem/CF1702C) | 强烈推荐[博客](https://ttzytt.com/2022/07/CF1702/)中观看。

## 题意：
给你一个长度为 $n (1\le n \le 2 \cdot 10 ^ 5)$ 的数组 $u$。代表所有的火车站。火车只能从左边的站台开到右边的站台。也就是从 $u_1$ 开始，再到 $u_2, \ u_3$，最后到 $u_n$。

现在给你 $k (1\le k \le 2 \cdot 10 ^ 5)$ 个询问，每个包含两个整数 $a_i$ 和 $b_i$，问你是否可以从 $a_i$ 这个站台开始，坐火车到 $b_i$。

比如：$u$ 数组为 $[3,7,1,5,1,4]$，有以下三个询问：
- $a_1 = 3, b_1 = 5$。
  从 $3$ 号站台坐车到 $5$ 号站台是可能的，有以下路径：$[3,7,1,5]$。
- $a_2 = 1, b_2 = 7$
  没有路径可以从 $1$ 号站坐车做到 $7$ 号站台。
- $a_3 = 3, b_3 = 10$
  没有路径可以从 $3$ 号站台坐车到 $10$ 号站台（$10$ 号根本不存在）。 

## 思路：
我们只需要知道某个站台第一次出现的位置和最后一次出现的位置就行了。假设站台 $i$ 第一次出现的位置为 $f_i$，最后一次出现的位置为 $l_i$。并且这时有询问 $a, b$。

那么只要 $f_a < l_b$ 就一定可以从站台 $a$ 坐车到站台 $b$ 了。因为我们知道第一个 $a$ 号站台在最后一个 $b$ 号站台的左边，而火车只能从左向右开，所以可以到达 $b$。

因为要形成一个站台编号到位置的映射，并且站台的编号比较大（$1e9$），站台编号的数量相对较少（$2e5$）。用平常的数组肯定不行，因为需要的空间过大 （$1e9$）。所以有两种办法，离散化（用排序离散化）和使用 `map`。

这里我开了两个 `map`，其中一个是站台编号到第一次出现位置的映射，还有一个，和前面讲的一样，是编号到最后一次出现位置的映射。

然后我们就可以得到如下代码：
## 代码：
因为使用的是 `cin` 和 `cout`，所以可能会因为输入速度比较慢造成 TLE，所以可以取消一下同步。
```cpp
// author: ttzytt (ttzytt.com)
#include <bits/stdc++.h>
using namespace std;
#define ll long long
int main() {
    int t;
    cin >> t;
    while (t--) {
        int n, k;
        cin >> n >> k;
        int a[n + 1];
        map<int, int> v2pos_frt, v2pos_bk;
        //编号->第一次出现， 编号->第二次出现
        for (int i = 1; i <= n; i++) {
            cin >> a[i];
            
            if (!v2pos_frt[a[i]]) 
                v2pos_frt[a[i]] = i;
            // 只有第一次才会赋值

            v2pos_bk[a[i]] = i;
        }
        while (k--) {
            int l, r;
            cin >> l >> r;
            int lp = v2pos_frt[l];
            int rp = v2pos_bk[r];
            if (lp <= rp && lp != 0 && rp != 0) {
                // 如果根本没有这个站台，那 lp 或 rp 就会为 0
                cout << "YES\n";
            } else {
                cout << "NO\n";
            }
        }
    }
}
```
最后，希望这篇题解对你有帮助，如果有问题可以通过评论区或者私信联系我。