#### 引言：
考试时这道题就差一步之遥就A了，写个题解来纪念一下。

#### 思路：
这道题我们可以用贪心来解决，题目让我们把全 $\verb!A!$ 字符串转换成给定字符串，我们可以转化成把给定字符串转换成全 $\verb!A!$ 字符串。所以为 $\verb!A!$ 的字符我们不用管，只用处理为 $\verb!B!$ 的字符。

但这道题有两种操作，这时候我们就要掏出分类讨论大法!

1. 当只有单独的一个 $\verb!B!$ 时，可以直接用第一种操作改变。
2. 如果有多个 $\verb!B!$ 连在一起，就要执行两次操作，因为我们要保证除了这一段连续的 $\verb!B!$ 以外，其他的字符不能改变，这里我相信大家都知道怎么操作。

当然，我们可以优化一下时间复杂度，具体方法请看代码中的注释。

#### Code：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,ans;
char s[1000005];
int main(){
	cin>>n;
	cin>>s;
	int flg=0;
	for(int i=n-1;i>=0;i--){//从最后一位开始遍历,可以省去判断首位为B的情况（因为首位为B只用执行1次2操作，因为它是从1开始的） 
		if(s[i]-'A'==flg)continue;//如果此时遍历的字符还是在最新的区块里面，跳过，不累加答案 
		if(s[i]==s[i-1]&&i>0)flg=1-flg;//如果此时来到了新的区块，变换flg的值（就是标记此时是A还是B） 
		ans++;
	}
	cout<<ans;
} 
```
