**~~虽然我似乎解释明了贪心是可行的，但是我还是有些不爽~~**

~~dp 做更直观吧~~

# Solution

入手这道题，看了看，就直接奔去写贪心。

至于如何贪心？

题目大意：对于每一个操作有两种操作选择，使终串全为 $\texttt{A}$ 。

对于这道题，贪心只考虑局部最优解，不能影响到其他位置

于是，就有两种情况要讨论：

### 单独的 B

对于单独出现的 $\texttt{B}$，

执行方法 1 需要 1 步，即直接修改（操作 1）。并且不会对字符串造成其他影响。

执行方法 2 需要 2 步，才能使字符串不会出现变化。

比如说：$\texttt{AABAA}$ 

在位置3执行操作2，$\texttt{BBAAA}$ （操作 2）

再在位置2执行操作2，$\texttt{AAAAA}$ （操作 2）

显然，当出现单独的 $\texttt{B}$ 时，**执行方法 1 改变单个字符更优。**

### 连续的一串 B

对于出现一串的 $\texttt{BBBB......}$

执行方法 1 需要执行 $|S|$ 步，$S$ 为全 $\texttt{B}$ 子串。

执行方法 2 需要执行 2 步，与 “单独的 B”中考虑一样。

由于 $|S| \ge 2$，所以，在出现连续的 $\texttt{B}$ 串时，**执行方法 2 更优于方法 1。**

**综上**，需要不影响其他步骤，从右往左扫；

单独的 $\texttt{B}$ 就直接修改；

连续的 $\texttt{b}$ 就通过方法 2 改变（其实第二次操作没必要进行，因为执行结束后会继续往前扫，自然会继续改变）。

上代码！

```cpp
#include<bits/stdc++.h>
using namespace std;

int main()
{
	int n,t=0,len=0,ans=0;string str;
	cin>>n>>str;
	for(int i=n-1;i>=0;i--)
	{
		if((str[i]+t%2=='A'||str[i]+t%2=='C'))  //方便就不写成 % 'B'
		{
			if(len!=0)
			{
				ans++;
				if(len!=1) t++;
				len=0;
			}
		}
		if(str[i]+t%2=='B') len++;
	}
	cout<<ans+(len!=0);  //结尾还剩余其他 B
	return 0;
}
```

还有更好的贪心思路要告诉我啊 qaq。