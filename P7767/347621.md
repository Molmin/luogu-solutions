题目：[P7767 [COCI 2011/2012 #5] DNA](https://www.luogu.com.cn/problem/P7767)

思路：其实这一题并没有那么复杂，只需要贪心即可解决。

我们先来考虑只有操作 $ 2 $ 的情况，很容易想到，只需从前往后遍历，当某一位上的字母与下一位上的字母不同时，将这一位到最前面为止全部翻转即可。简而言之，只要统计字符串中与下一个字母不同的字母的个数（最后一位除外）。为了方便处理，可以在字符串的末尾加上一个 A。

现在再来看加上操作 $ 1 $ 的情况。我们先看 AABAA，最少操作是翻转中间的 A。再看 BBABB，同理，最少操作是翻转中间的 B，再整体翻转。

那么我们就得出了结论：如果一个字母左右两边的字母都与它不同，那么翻转这个字母，然后再按只有操作 $ 2 $ 的情况跑一遍就行了。

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
string s;
int ans;
int main()
{
	scanf("%d",&n);
	cin>>s;
	s=s+'A';
	for(int i=1;i<n;i++)
	    if(s[i-1]!=s[i]&&s[i+1]!=s[i])    //如果一个字母左右两边的字母都与它不同
	        s[i]='A'+'B'-s[i],ans++;     //那么翻转这个字母
	for(int i=0;i<n;i++)         //如果一个字母与它的下一位不同
	    if(s[i]!=s[i+1]) ans++;     //答案加一
	printf("%d\n",ans);
	return 0;
}

```