[题目传送门](https://www.luogu.com.cn/problem/CF1131A)  
### 1.题目
在一个网格中，放入两个长方形，长分别为 $w_1 , w_2$ ，宽分别为 $h_1 , h_2$ 。围绕两个长方形的方格里有绿色的东西（？）。现在将一个长方形的上长边与另一个长方形的下长边重合，宽左对齐，求有多少个绿色的东西未被覆盖。图片见题面。
### 2.分析
因为整幅图翻转对答案没有影响，所以我们只考虑长短的长方形在上的情况。  
求未被覆盖的，我们可以反面思考，求出有多少个是被覆盖的。  
绿色东西被覆盖可以分为两类：1、被绿色东西覆盖，只保留一个；2、被**另一个长方形**覆盖，不计入答案。  
于是我们可以**分开讨论**：  
**第一种情况**：被绿色东西覆盖。如下图，因为两个长方形左对齐，所以可以肯定左边一定有两个绿色的东西重合答案 `-2`。然后考虑右边，右边可以分为右对齐或是没对齐，~~这不显然吗~~ 当他是右对齐是，情况与左对齐相同，答案  `-2` ；现在考虑没对齐，没对齐代表 $w_1 \ne w_2$ ,则它们至少相差 $1$ 。也就是说，上长方形的右宽边将会与下长方形的上长边重合，而下长方形的右宽边不会重合，则答案 `-1` 。  
![](https://cdn.luogu.com.cn/upload/image_hosting/7j7m4kg8.png)  
**第二种情况**：被另一个长方形覆盖。会受到这种情况影响的仅有上长方形的下长边和下长方形的上长边。先考虑上长方形，上长方形下长边的长度为 $w_2+2$，除去一个第一种情况覆盖，还剩下 $w_2+1$ 个可能会被覆盖。一个绿色的东西会被覆盖，仅当他与另一长方形重合，所以对于一条下边只需要在自己的边长与另一长方形的长取 $\min$ 即可，即 $\min(w1,w2+1)$ 。下长方形同理， $\min(w2,w1+1)$ 。  
![](https://cdn.luogu.com.cn/upload/image_hosting/7keinjs6.png)  
最后将两坨东西合在一起就可以了。
### 3.代码
```cpp
#include<iostream>
using namespace std;
int w1,h1,w2,h2;
int main()
{
	scanf("%d%d%d%d",&w1,&h1,&w2,&h2); //输入
	printf("%d",(w1+h1+w2+h2)*2+8/*原本绿色东西的个数*/-2-(w1==w2?2:1)/*第一种情况*/-min(w2,w1+1)-min(w1,w2+1)/*第二种情况*/); //输出
}
```
