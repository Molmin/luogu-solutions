**题目描述**

特工玛利亚被送到S市执行一个特别危险的任务。她需要利用地铁完成他的任务，S市的地铁只有一条线路运行，所以并不复杂。

玛利亚有一个任务，现在的时间为0，她要从第一个站出发，并在最后一站的间谍碰头。玛利亚知道有一个强大的组织正在追踪她，她知道如果一直呆在一个车站，她会有很大的被抓的风险，躲在运行的列车中是比较安全的。所以，她决定尽可能地呆在运行的列车中，她只能往前或往后坐车。

玛利亚为了能准时且安全的到达最后一个车站与对方碰头，需要知道在在车站最小等待时间总和的计划。你必须写一个程序，得到玛丽亚最短的等待时间。当然，到了终点站之后如果时间还没有到规定的时刻，她可以在车站里等着对方，只不过这个等待的时刻也是要算进去的。

这个城市有n个车站，编号是1-n，火车是这么移动的：从第一个车站开到最后一个车站。或者从最后一站发车然后开会来。火车在每特定两站之间行驶的时间是固定的，我们也可以忽略停车的时间，玛利亚的速度极快，所以他可以迅速上下车即使两辆车同时到站。

**输入输出格式**

输入格式：
输入文件包含多组数据，每组数据都由7行组成

第1行：一个正整数N（2<=N<=50）表示站的数量

第2行：一个正整数T（0<=T<=200）表示需要的碰头时间

第3行：1-（n-1）个正整数（0<ti<70）表示两站之间列车的通过时间

第4行：一个整数M1（1<=M1<=50）表示离开第一个车站的火车的数量

第5行：M1个正整数：d1，d2……dn，（0<=d<=250且di<di+1）表示每一列火车离开第一站的时间

第6行：一个正整数M2（1<=M2<=50）表示离开第N站的火车的数量

第7行：M2个正整数：e1,e2……eM2,(0<=e<=250且ei<ei+1)表示每一列火车离开第N站的时间

最后一行有一个整数0。

输出格式：
对于每个测试案例，打印一行“Case Number N: ”（N从1开始）和一个整数表示总等待的最短时间或者一个单词“impossible”如果玛丽亚不可能做到。按照样例的输出格式。

**输入输出样例**

输入样例:

	4
	55
	5 10 15
	4
	0 5 10 20
	4
	0 5 10 15
	4
	18
	1 2 3
	5
	0 3 6 10 12
	6
	0 3 5 7 12 15
	2
	30
	20
	1
	20
	7
	1 3 5 7 11 13 17
	0

输出样例:

	Case Number 1: 5
	Case Number 2: 0
	Case Number 3: impossible

------------
假设玛利亚现在在第j个车站，现在的时间为i，那么她有两种选择：

1、在原地等待；2、如果有车经过，可以选择上车。

那么我们显然可以用动态规划：

令dp[i][j]表示第i分钟时，玛利亚在第j个车站，所需等待的最短时间。

如果她选择停留1分钟，那么

	dp[i+1][j]=dp[i][j]+1;
    
如果有一辆从1站出发的车经过，那么玛利亚可以从j站到达j+1站，时间会变成i+t[j]，即

	dp[i+t[j]][j+1]=dp[i][j];

如果有一辆从n站出发的车经过，玛利亚选择上车，则同理：

	dp[i+t[j-1]][j-1]=dp[i][j];

那么关键来了：如何判断第i分钟某一车辆是否经过j站？

假设有一辆车从1站出发，发车时间为d，那么如果d加上从1站出发后到达j站的时间等于i，则经过。这里，我们用前缀和数组存从1站出发到达某一站所需的时间：

	int f[70];
    f[1]=0;
    for(int i=1;i<n;i++)
    	f[i+1]=f[i]+t[i];

那么如果  d+f[j]==i，则该车此时经过。

反之，如果该车从n站出发呢？这里留给读者思考~~（其实是掩饰作者懒得写）~~

上代码啦：

```cpp
#include<iostream>
#include<algorithm>
#include<cstdio>
using namespace std;
inline void re(int &x)
{
	x=0;bool flag=false;
	char c=getchar();
	while(c<'0'||c>'9'){
		flag=c=='-';
		c=getchar();
	}
	while(c>='0'&&c<='9'){
		x=(x<<1)+(x<<3)+(c^'0');
		c=getchar();
	}
	if(flag)x=-x;
	return ;
}//本蒟蒻的快读
int dp[550][70];
int n,T;
int m1,m2;
int f[70],t[70],d[70],e[70];//如题目描述，f是前缀和数组
int now;
int main()
{
	re(n);//1
	while(n)
	{
		re(T);//2
		f[1]=0;
		for(int i=1;i<n;i++)
		{
			re(t[i]);//3
			f[i+1]=f[i]+t[i];//前缀和
		}
		//1 to n
		re(m1);//4
		for(int i=1;i<=m1;i++)
			re(d[i]);//5
		//n to 1
		re(m2);//6
		for(int i=1;i<=m2;i++)
			re(e[i]);//7
		for(int i=0;i<=T;i++)
			for(int j=1;j<=n;j++)
				dp[i][j]=9999;//首先赋一个较大的值，便于判断是否能够做到
		dp[0][1]=0;
		for(int i=0;i<=T;i++)
			for(int j=1;j<=n;j++)
			{
				if(dp[i][j]==9999)continue;
				dp[i+1][j]=min(dp[i+1][j],dp[i][j]+1);//原地呆着
				for(int k=1;k<=m1;k++)//枚举车辆
					if(j<n&&f[j]+d[k]==i)//判断是否可行
                    	dp[i+t[j]][j+1]=min(dp[i+t[j]][j+1],dp[i][j]);
				for(int k=1;k<=m2;k++)
					if(j>1&&f[n]-f[j]+e[k]==i)
                    	dp[i+t[j-1]][j-1]=min(dp[i+t[j-1]][j-1],dp[i][j]);
			}
		printf("Case Number %d: ",++now);
		if(dp[T][n]<9999)printf("%d\n",dp[T][n]);
		else printf("impossible\n");
		re(n);//1
	}
	return 0;
}
```