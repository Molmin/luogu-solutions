看到题目时，我的第一反应是猎人在兔八哥周围的8个点时，（如下图）

>O O O

>O X O   兔八哥为X，猎人在O点能看到

>O O O

能看到兔八哥，其余则相反；所以我开开心心的贴上了简单的判断代码，~~心想这题一定没有普及难度~~，结果WA了，我仔细想了想，忽然发现了真相：

>T O T O T

>O T T T O

>T T X T T

>O T T T O

>T O T O T

其中，T为树，X是兔八哥，猎人在O点也能看到兔八哥！

同理,猎人还可以在更远处的8个位置看到兔八哥，所以我们需要对该问题进行转换：

>在平面直角坐标系上，两个整点之间有多少个整点？

两个整点(x1,y1)和(x2,y2)中，一共有gcd(abs(x1-x2),abs(y1-y2))-1个整点（证明有点长，百度上好像有，可以自己搜索一下）

这个问题就变成了求两个数的最大公约数（gcd），我们可以用辗转相除法实现：

>辗转相除法， 又名欧几里德算法(Euclidean algorithm)，是求两个正整数之最大公约数的算法。它是已知最古老的算法， 其可追溯至公元前300年前。

>它的具体做法是：用较小数除较大数，再用出现的余数（第一余数）去除除数，再用出现的余数（第二余数）去除第一余数，如此反复，直到最后余数是0为止。如果是求两个数的最大公约数，那么最后的除数就是这两个数的最大公约数。 

（另一种求两数的最大公约数的方法是更相减损法,如果我以后有空会写上的）

递归实现：

```cpp
int chu(int a,int b)
{
    if(b==0)
        return a;
    return (chu(b,a%b));
}
```
递归就是核心代码，剩下的就不难写出了（剩下的注释都放代码里了）：

```cpp
#include<bits/stdc++.h>
using namespace std;
int chu(int a,int b)//辗转相除求最大公约数
{
    if(b==0)
        return a;
    return (chu(b,a%b));
}
int main()
{   long long n,x1,y1,x2,y2,i;//两人（一人一兔？）的坐标
    cin>>n;
    for(i=0;i<n;i++)
    {
        cin>>x1>>y1>>x2>>y2;
        if(chu(abs(x1-x2),abs(y1-y2))==1)//证明结果，本题不用手写abs，STL里的不会炸，时间再压一下就要手写了
            puts("no"); 
        else
            puts("yes");//其实cout也可以，不过最近在写AT的题，习惯用puts
    }
    return 0;
}
```
