提供一个比较有趣的思路。

为了表述方便，下文将 `L` 称为 `0`，`R` 称为 `1`。

如果只观察其中一个 $2\times 2$ 的子矩阵，发现每次操作会更改其中的**偶数**个元素。

所以这个子矩阵能被操作成全部都相同当且仅当其中有偶数个 `1`。

推广到 $n\times n$ 的矩阵，该矩阵能通过操作变得全部都相同当且仅当所有 $2\times 2$ 的子矩阵都有偶数个 `1`。具体可以把这个 $n\times n$ 的矩阵“缩”成 $(n-1)\times(n-1)$ 的矩阵（称为“代表矩阵”）。举个例子：

```
n=4

1011
0011
0011
0011

 ||
 ||
_  _
\  /
 \/
 
100
000
000
```
其中“代表矩阵”的每一个单元格对应原矩阵一个 $2\times 2$ 的子矩阵。如果是 $1$ 说明子矩阵 $1$ 的个数是奇数个。 

可以发现一个规律：**大多数**原矩阵的位置都会被包含在 $4$ 个 $2\times 2$ 的子矩阵内，但有些是只被 $2$ 个或 $1$ 个包含。（想一想，为什么） 

在原问题中，要先反转一位，使得修改过的矩阵满足条件，考虑转换为“代表矩阵”，因为这样更容易判断是否满足条件，即全是 $0$。

如果直接枚举原矩阵修改了哪一位，然后通过“代表矩阵”进行判断的话，复杂度为 $\Theta(n^4)$，所以要研究每次修改在代表矩阵的对应情况。

对于这个原矩阵的修改 $(x,y)$，在“代表矩阵”中修改了所有包含 $(x,y)$ 的子矩阵。

因为代表矩阵的目标状态是全是 $0$，所以把代表矩阵中 $1$ 的位置拎出来，只有三种情况：
- “代表矩阵”中有 $1$ 个位置是 $1$。那么得修改这个 $1$ **且不能影响到其他 $0$**，所以这个 $1$ 只能在角上，修改这个角即可。如果不在角上就是无解。
- “代表矩阵”中有 $2$ 个位置是 $1$。同上，结论是要相邻且在边上。
- **有 $4$ 个位置是 $1$**。结论是必须是在一块的（形成一个 $2\times 2$ 的矩形）

其他情况都是无解。

[code](https://paste.ubuntu.com/p/F9w9r2Rrjd/)

---
Update on 2021/9/20: 重写了一遍，因为以前的代码被 $Hack$ 了。（悲）

Update on 2022/1/7: 有人反映剪贴板挂了，似乎是被我手残删除了/ll