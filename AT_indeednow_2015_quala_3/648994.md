~~这道题不就是个大水题吗?~~
## 注意：
就算会场容得下所有人但是分数为 $0$ 也不能进，所以最低分可以为 $0$，所以只存分数不为 $0$ 的人的分数。

首先思路：将 **不为 $0$** 的分数存到一个数组里，按分数从低到高排序。
输入每次会场容纳人数 $k$ ：
1. 如果当前 $k$ $>$ 当前分数不为 $0$ 的的人数，就直接输出最低分 $0$。
1. 如果不满足上面一条，就寻找最低分数，因为容纳 $k$ 个人，达到条件的分数就是 第 $t-k+1$ 个人的分数，那么最低分数线他前面的人（$t-k$）的分数线 $+1$。


## 上代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,a[100005],k,t,x;
int main()
{
	cin>>n;//输入人数 
	for(int i=1;i<=n;i++)
	{
		cin>>x;//输入分数
		if(x==0)  continue;
		else
		{
			a[++t]=x;//记录不为0的分数
		}
	}
	sort(a+1,a+t+1);//按分数从小到大排序
	cin>>m;
	for(int i=1;i<=m;i++)//m次输入
	{
		cin>>k;//会场容纳人数
		if(k>=t) //如果容纳人数大于分数不为0的人数 ，就输出0；
		cout<<0<<endl;
		else  
		cout<<a[t-k]+1<<endl;//达到条件的分数的人的前面的人的分数+1
	}
	return 0;//完结撒花
}
```


~~蒟蒻第一篇题解，希望管理通过。~~