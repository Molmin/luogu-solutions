> 评语：一道非常好的删数动规练习题。

初学区间 $dp$，相信大家都做过 [石子合并](https://www.luogu.com.cn/problem/P1880)。这道题与石子合并类似，也可以使用区间 $dp$。

但是，也可以想为一个线性 $dp$（其实 区间 $dp\in$ 线性 $dp$），个人认为这样更好理解。

## 状态的定义及其应用
### 1. 定义
设 $F_{i,j}$ 表示当从前 $i$ 个数中删掉 $j$ 个数时，最后剩下的数列中那些恰好在自己位置上的数的个数的最大值。为了方便讲解，设读入的数列为 $A$。

### 2. 状态转移
> 状态如何转移是 $dp$ 的关键！

很容易想到 $F_{i,j}$ 和 $F_{i-1,j}$、$F_{i-1,j-1}$ 有关。

如果前 $i$ 个数删除了 $j$ 个数，那么该数可能删除，可能不删。

- 若删除，则 $F_{i,j}=F_{i-1,j-1}$。

- 若不删，则 $A_i==i-j$，则第 $i$ 位匹配成功，$F_{i,j}=F_{i-1,j}+1$；否则即 $F_{i,j}=F_{i-1,j}$。合在一起可以写成一个转移式：$F_{i,j}=F_{i-1,j}+(A_i==i-j)$。

综上所述，$F_{i,j}$ 显然取两者最大值，状态转移方程也就出来了：

$$F_{i,j}=\max(F_{i-1,j-1},F_{i-1,j}+(A_i==i-j))$$

通过背包压维的经验，发现可以使用一维滚动数组。因此可以写出一维的转移方程：
$$F_j=\max(F_{j-1},F_j+(A_i==i-j))$$

~~小编懒得压维。~~

### 3. 最后谈初始化
显然，从前 $0$ 个数中删除 $0$ 个最大值为 $0$，即 $F_{0,0}=0$。

## CODE
```cpp
#include <stdio.h>
int n, a[1005];
int f[1005][1005], ans;
int main(void) {
    scanf("%d", &n);
    for (int i = 1; i <= n; ++i)
        scanf("%d", &a[i]);
    for (int i = 1; i <= n; ++i)
        for (int j = 0; j <= i; ++j) {
            if (j > 0) f[i][j] = f[i - 1][j - 1];
            f[i][j] = f[i - 1][j] + (a[i] == i - j) > f[i][j] ? f[i - 1][j] + (a[i] == i - j) : f[i][j];
            ans = f[i][j] > ans ? f[i][j] : ans;
        }
    printf("%d\n", ans);
    return 0;
}
```

## The end. Thanks.

~~（留个赞再走呗~~