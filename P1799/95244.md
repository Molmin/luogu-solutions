这道题很有意思。通过充分思考样例，我们很快可以发现以下性质:

1.**在原序列中删除若干数后的留下的序列**可以转化成**原序列的一个子序列**

2.**原序列的子序列中**中能对答案产生贡献的是**子序列中的上升子序
列**，而子序列中其他数都只是对上升子序列中的数的排名产生影响的。

怎么理解第二点呢？

一组数列:100 1 -1 3 -2 5 100 

在这个序列中，产生最优解的子序列很明显是：1 -1 3 -1 5.而这个子序列中的-1 -1只是为了改变1，3，5在序列中的排名，用来填位置的。所以实际上像-1，-1这样填位置的数我们不需要关心他的值，只需要关心有几个这样的数来填充。

事实上，我们只需要观察一下像1，3，5这样的上升子序列所在的子序列中的排名是否成立，就可以判断这样的子序列是否成立。

通过1、2两点性质，我们很快就将这个问题转化成了一个**求符合条件的最长上升子序列的问题**。

```cpp
#include<cstdio>
#include<cstring>
#define max(a,b) ((a)>(b)? (a):(b))
int a[1005],f[1005];
int main() {
	int n,ans=0;
	scanf("%d",&n);
	for(int i=1;i<=n;++i) scanf("%d",&a[i]);
	memset(f,-0x3f,sizeof(f));//如果是负数，肯定选不了，赋-inf
	for(int i=1;i<=n;++i) {
		if(i>=a[i]&&a[i]>0) {//如果是正数，并且当前能选
			f[i]=1;
			for(int j=1;j<i;++j) {if(a[j]<a[i]&&a[j]+i-j>=a[i]) f[i]=max(f[i],f[j]+1);}
		}
		else if(i<a[i]) f[i]=0;//如果是正数，但是当前选不了
		ans=max(ans,f[i]);
	}
	printf("%d",ans);
	return 0;
}
```
