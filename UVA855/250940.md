首先最容易想到的方法就是暴力枚举。

但是在数据最大的情况下，暴力枚举一定会 TLE。（$50000×1000×1000$ 远大于计算机一秒处理速度 $10^8$。

对于这个题有一个十分经典的结论，就是当这个人的 $x$ 和 $y$ 都等于朋友们的中位数时，路程最短。

这个可以这样证明：

1. 假设这个人初始在 $(1,1)$。
2. 让他先沿着 $y$ 方向一步一步走，走到与朋友们距离之和最小时停下。
2. 再沿着 $x$ 方向同样操作。

于是，代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
	int n,x[100009],t,y[100009],x9,y9,xx,yy;
	cin>>t;
	while(t--)
	{
		cin>>xx>>yy>>n;
		for(int i=1;i<=n;i++) cin>>x[i]>>y[i];
		sort(x+1,x+n+1);
		sort(y+1,y+n+1);
		x9=x[(n+1)/2];
		y9=y[(n+1)/2];//中位数
		printf("(Street: %d, Avenue: %d)\n",x9,y9);
	}
	return 0;
}
```