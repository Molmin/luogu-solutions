## 题意

有一个长度为 $n$ 的排列 $p$，现在生成 $n$ 个长度为 $n-1$ 的序列 $a_1,a_2,\dots, a_n$，第 $i$ 个序列 $a_i$ 表示排列 $p$ 删除元素 $p_i$ 后剩下的元素。

现在以任意顺序给出 $n$ 个序列，恢复原排列。

$1\le t\le10^4$，$3\le n\le100$，$\sum n^2\le2\times10^5$。

## 思路

说实在的只有输入的时间复杂度是 $\mathcal O(n^2)$ 的，其他部分都是 $\mathcal O(n)$。

既然每个序列都是由原来的排列扣掉一个元素后产生的，那把这个元素找回来就行了呗。

观察到 $p$ 的第一个元素会在 $n-1$ 个生成序列中排在第一个。那显然剩下的一个就是原来的排列 $p$ 除掉开头元素后剩下的了。

接下来就好办了，线性时间找出开头元素和那个单独的序列，先输出开头元素再输出那个序列就完事了。

## 代码

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<vector>
#include<algorithm>
using namespace std;
#define ll long long
#define il inline
il ll read() {
	ll x=0,f=1;char c=getchar();
	while(c<'0'||c>'9') {if(c=='-') {f=-1;} c=getchar();}
	while(c>='0'&&c<='9') {x=(x<<3)+(x<<1)+(c^48);c=getchar();}
	return x*f;
}
int t,n;
int a[105][105];
int main() {
	t=read();
	while(t--) {
		n=read();
		for(int i=1;i<=n;i++) for(int j=1;j<n;j++) a[i][j]=read();
		int k[2][3];
        /*
        我觉得这里需要解释一下k数组。
        k[0][0]表示第一列中第一个发现的元素。
        k[1][0]表示第一列中第一个发现的不同于k[0][0]的元素。
        显然k[0][0]和k[1][0]中就有一个是要找的p的开头元素，因为第一列只能有两个元素。
        k[0][1]表示第一列中k[0][0]出现的次数。
        k[1][1]表示第一列中k[1][0]出现的次数。
        显然如果k[0][1]>k[1][1]则k[0][0]是开头元素。
        反之亦然。
        k[0][2]表示最后发现的k[0][0]出现的位置（行数）。
        k[1][2]表示最后发现的k[1][0]出现的位置（行数）。
        这样就顺便把没有第一个元素的那个序列的编号记录了下来。
        那么找到第一个元素是0还是1，另一个记录的编号就是要找的序列。
        */
		k[0][0]=k[0][1]=k[0][2]=k[1][0]=k[1][1]=k[1][2]=0;
		for(int i=1;i<=n;i++) {
			if(k[0][0]==0||k[0][0]==a[i][1]) {
				k[0][0]=a[i][1];
				k[0][1]++;
				k[0][2]=i;
			}
			else {
				k[1][0]=a[i][1];
				k[1][1]++;
				k[1][2]=i;
			}
		}
		int x=0;
		if(k[0][1]>k[1][1]) x=1;
		printf("%d ",k[x^1][0]);
		for(int i=1;i<n;i++) printf("%d ",a[k[x][2]][i]);
		putchar('\n');
	}
	return 0;
}
```