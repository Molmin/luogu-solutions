**思路**

注意到，初始的排列 $p$ 中的第一个数字只在第一次书写时消失了，而在其它 $n-1$ 次书写中仍作为第一个元素。

因此，我们可以先遍历一遍所有书写的序列，找到这些序列中的第一个元素出现了 $n-1$ 次的数，这个数便是原始排列中的 $p_1$。

找到了 $p_1$ 之后，我们再从所有的序列中找到第一次书写的序列，也就是第一个元素与 $p_1$ 不同的序列。这个序列便是初始的排列中的 $p_2,p_3,\cdots,p_n$。

最后，我们把它们依次输出就行了！



------------

**代码**

```cpp
void solve() {
  ll t;
  cin >> t;
  while (t--) {
    ll n;
    cin >> n;
    ll a[110][110], buc[110]; // buc[i] 表示 i 出现的次数，用于找到 p_1
    for(int i=1;i<=100;i++) buc[i] = 0; //注意清空
    for(int i=1;i<=n;i++)  for(int j=1;j<n;j++)  cin >> a[i][j];
    ll first,
        id; // first 表示 p_1，id 表示第一次书写的序列在本次测试数据的第几行
    for(int i=1;i<=n;i++) {
      buc[a[i][1]]++;
      if (buc[a[i][1]] > 1) { //超过1次的数字便是 p_1
        first = a[i][1];
        break;
      }
    }
    for(int i=1;i<=n;i++) if (a[i][1] != first) { //找到 p_2,p_3,...,p_n
      id = i;
      break;
    }
    cout << first << " ";                    //先输出p_1
    for(int i=1;i<n;i++) cout << a[id][i] << " "; //再输出 p_2,p_3,...,p_n
    cout << "\n";
  }
}

```
