### 题目大意
让你用扑克牌摆n层金字塔,问需要多少张扑克牌

### 分析
首先乍一看好像规律不是很明显,那就列举几个来逐步分析一下

#### 一层金字塔
一层金字塔需要2张扑克牌
(楼上都有讲）


#### 2层金字塔
2层金字塔需要7张扑克牌

#### 解题思路
整体来看好像还是看不出什么规律，所以我们不妨将参与摆放的扑克牌分成两类：斜着搭和横着搭

横着搭

我们可以将扑克牌按照斜着搭和横着搭。由前面几个例子不难看出：每增加x层金字塔就增加x-1张横着搭的扑克牌。
即一共有1+2+3+······+n-2+n-1张扑克牌。利用等差公式(首项+末项）项数/2(省略乘号)。所以

(n-1+1)(n-1)/2=n(n-1)/2 横着搭的数量搞定QWQ

斜着搭

斜着搭是由2个扑克牌组成的屋顶形。可以看出：

1层金字塔有1个屋顶形组成。

2层金字塔有3个屋顶形组成。

3层金字塔有6个屋顶形组成。

4层金字塔有10个屋顶形组成。

···········

我们不难发现：

1层金字塔----有1个屋顶形

2层金字塔----有1+2个屋顶形

3层金字塔----有1+2+3个屋顶形

4层金字塔----有1+2+3+4个屋顶形

···········

所以n层金字塔就有1+2+3+4+······+n-1+n个屋顶形
也就是有（1+n）n/2个屋顶形。也就要用（1+n）n个扑克牌。

所以综上所述，n层金字塔就需要用：

n(n-1)/2+（1+n）n=n*(1+3n)/2张扑克牌。

所以代码就很容易啦~，上代码:

```cpp
#include<bits/stdc++.h>
using namespace std;

int main()
{
  int x;//定义测试数据 
  scanf("%d",&x);//scanf输入比cin快 
  while(x--)//循环 
  {
    long long n;//定义金字塔的层数 
    scanf("%lld",&n);//输入 
    printf("%lld\n",(n*(3*n+1)/2)%1000007);//套入公式输出(不要忘记要%1000007) 
  }
  return 0;//结束 
}
```
#### 不要走，我还有一种思路：

看到图片，我们可以数一下完整三角形的个数：
然后可以惊奇地发现：n层金字塔就有：

1+2+3+······+n个完整的三角形再减去n。

所以就有：3(1+n)n/2-n张扑克牌

上代码：

```cpp
#include<bits/stdc++.h>//万能头文件万岁
using namespace std;

int main()
{
  int x; //定义
  scanf("%d",&x);//输入
  while(x--)//循环x次
  {
    long long n;
    scanf("%lld",&n); //输入金字塔的层数
    printf("%lld\n",(3*(1+n)*n/2-n)%1000007);//套入公式然后输出
  }
  return 0; //结束
}
```
#### 写了那么多实属不易。。。点个赞再走呗QWQ