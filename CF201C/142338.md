这题妙在**将路线拆成向左、向右两段，分别DP后合并答案**。

设 $f[i][0/1]$ 表示**从岛 $i$ 向左走 不保证 / 保证 回到岛 $i$ 的最大分数**

设 $g[i][0/1]$ 表示**从岛 $i$ 向右走 不保证 / 保证 回到岛 $i$ 的最大分数**

这个状态可能有些麻烦。可以自行理解一下，然后对样例模拟一遍，得到：

![](https://i.loli.net/2020/12/23/E6XxApSI2UP3R5k.png)

那么答案就是：$\max\{f[i][0]+g[i][1],f[i][1]+g[i][0]\}$

可以结合下图理解：

![无标题.png](https://i.loli.net/2020/12/24/2uNHIRr4MxOq8ma.png)

分别对应这个点：

- 先往右走，回到原点再往左走
- 先往左走，回到原点再往右走 

的两种情况。
这样便可以将一个不定的路线问题，拆成两个单向路径，然后通过线性 DP 分别求解 $f,g$。

先观察一边，$f[i][1]$ 是容易求的。因为要保证回到岛 $i$，因此也必然经过岛 $i-1$，如下图：

![无标题.png](https://i.loli.net/2020/12/23/aE7e2ITmgwv8xjR.png)

经过岛 $i-1$ 时的分数为 $f[i-1][1]$。经过桥 $a[i-1]$ 时，不难发现我们可以在这座桥上反复横跳直到把它榨干，从而得到 $\left\lfloor a[i-1]/2 \right\rfloor\times2$ 的分数（例如耐久度为 $7$ 时可以走 $6$ 次回到 $i$）。因此：

$$f[i][1]=f[i-1]+\left\lfloor a[i-1]/2 \right\rfloor\times2$$

而对于不保证回到岛 $i$ 的 $f[i][0]$，可以分以下三种情况：

$$f[i][0]=
\max
\begin{cases} f[i][1] & (1)
 \\ f[i - 1][0] + a[i - 1] - [a[i - 1] \text{ is even}] & (2)
 \\ f[i - 1][1] + a[i - 1] & (3)
\end{cases}$$

- 情况 $(1)$ 相当于直接回到岛 $i$。
- 情况 $(2)$ 相当于向左走到 $i-1$ 并不保证回来。那么对于中间这座桥 $a[i-1]$，不难发现如果其次数为偶则无法走满（因为不一定回来），则需特判减一。
- 情况 $(3)$ 相当于向左走并保证回来，那么对于中间这座桥必定可以走到它断，无需特判。

至此，我们已经把 $f$ 讨论完毕。对于 $g$ 只需照葫芦画瓢，将方向反过来即可，~~读者自证不难~~。

```cpp
#include<bits/stdc++.h>
#define int long long
#define nb 200010
using namespace std;

int ans, n, a[nb], f[nb][2], g[nb][2];

main(){
	cin >> n;
	for(int i = 1; i < n; cin >> a[i++]);
	for(int i = 2; i <= n; i++){
		if(a[i - 1] > 1) f[i][1] = f[i - 1][1] + a[i - 1] / 2 * 2;
		f[i][0] = max(f[i][1], f[i - 1][0] + a[i - 1] - !(a[i - 1] & 1));
		f[i][0] = max(f[i][0], f[i - 1][1] + a[i - 1]);
	}
	for(int i = n - 1; i; i--){
		if(a[i] > 1) g[i][1] = g[i + 1][1] + a[i] / 2 * 2;
		g[i][0] = max(g[i][1], g[i + 1][0] + a[i] - !(a[i] & 1));
		g[i][0] = max(g[i][0], g[i + 1][1] + a[i]);
	}
	for(int i = 1; i <= n; i++){
		ans = max(ans, max(f[i][0] + g[i][1], f[i][1] + g[i][0]));
	}
	cout << ans;
	return 0;
}
```

