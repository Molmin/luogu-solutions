
## 分析思路
这道题最主要的其实是思路，思路有了这道题其实就是很简单。

最开始大家的想法应该是把每一个数的 ASCII 码都求出来，再进行翻转模拟出结果对吧？

这么写肯定 AC 是能 AC 的，但是这里的方法可以不用那么难。本蒟蒻在用这个方法 AC 之后点开题解区，发现一楼的 dalao 似乎用了更简便的方法，~~但是本蒟蒻理解不了这么高深的艺术，所以~~ 把他的思路整理解释出来。

因为题目要求把二进制码求出来之后再进行翻转，我们知道 **求一个数的二进制就是把这个数除以二的余数进行反转** ，那么反转之后又要反转不就是代表不用反转吗？

于是，思路进行到这里应该就很清晰了，我们再来看这道题目的数据范围，发现给出的 ASCII 码值最高只到 100，于是 **我们可以把系数设置成 128**，也就是 $2^{7}$，这样我们就可以把每一位的数在求二进制码的时候就转换好了。

很简洁易懂有木有！

**这里有一些题目中的坑需要注意：**
1. 样例中给了我们有空格，于是我们需要整行读入，可以用 `getline(cin,s)` 函数整行读入；
2. 题目中没有说 ~~（也可能是本蒟蒻没有读懂题）~~ 最后的取余怎么取，但是本蒟蒻亲测需要输出 $(last-x+256)\bmod256$ 的值。

于是，这道模拟的水题就被我们用一个极其简单的方式解决了！！！

代码如下（和一楼 dalao 的代码很相似，因为思路基本相同）：
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
string s;
int last=0,x=0,t,tmp;//last如题，x是反转之后的数，t为一开始的数，tmp为系数 2^n 
int main(){
	getline(cin,s);//样例里面都告诉我们有空格了，所以得用整行读取 
	for(int i=0;i<s.size();i++){
		t=int(s[i]);
		x=0;
		tmp=128;
		for(int j=1;j<=8;j++){
			x+=t%2*tmp;
			tmp/=2;
			t/=2;
		}
		cout<<(last-x+256)%256<<endl;//输出注意换行 
		last=x;
	}
	return 0;
}

```
