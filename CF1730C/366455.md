### 题意简述

+ 给定一个只包含 $0$ 到 $9$ 这些数字的字符串 $s$
+ 你可以执行任意次（可以 $0$ 次）下列操作：
  + 选择任意一个字符 $d$，删除它，并将 $\min(d+1,9)$ 插入到字符串任意位置（可以头、尾）。
+ 你需要求出经过操作后字典序最小的字符串。
+ 有 $t$ 组数据，$1\le{t}\le10^4,1\le{|s|}\le2\times10^5$。所有字符串长度总和不超过 $2\times10^5$。

### 题目分析

已知：同上。

求证：最终的答案字符串里的字符单调不递减。

证明：反证法。

假设原命题不成立，即存在答案中第 $i$ 位的字符为 $c$，第 $i+1$ 为的字符为 $d$，$c>d$。

那么，先删除 $c$，再把 $\min(c+1,9)$ 插入到 $d$ 后面。这样，第 $i$ 位的字符由 $c$ 变成了更小的 $d$，并且这之前的字符都没有变化，使得答案一定更优了。经过若干次这样的操作后，字符串单调不递减并且字典序更小，这与“原来的字符串是最终答案”不符合。于是假设不成立，原命题成立。

这是一个非常好的性质，会帮助我们做题。

首先我们需要先保证 $0$ 的数量最多，再保证 $1$ 的数量最多……所以，我们从小到大考虑每个字符的数量，设当前考虑到的字符为 $j$。

因为答案是单调不递减的，所以每次我们都把所有 $j$，移到除了比 $j$ 小的字符之外，剩下的字符的最前面。因为在当前要保证 $j$ 剩下的尽量多，所以当前这次操作我们所有 $j$ 都不能够删除，只能对比 $j$ 大的字符进行操作。因为每次操作都会使某个字符增大，所以我们要尽量少的操作。

于是，我们得出了一个重要结论：每次要把最后一个 $j$ 之前的比 $j$ 大的字符都移动到最后一个 $j$ 的后面某个位置。

那么这些需要操作的字符应该放到哪个位置呢？

首先，我们先把所有要进行操作的字符，从原来的字符串中移出来单独存放。然后，我们找到比 $j$ 大的最小的字符（如果有的话，这里暂时假设为 $k$），对于 $k$ 来说，我们只要保证 $k$ 字符尽量不影响比它大的字符，所以把 $k$ 都插入在最后一个 $j$ 的后面。然后再把比 $k$ 大的最小的字符插入在最后一个 $k$ 的后面……

于是我们需要动态记录每个字符的最后一个字符的位置，并且维护一个大于等于 $j$ 的当前的字符串。发现插入操作让维护变得棘手。

我们观察上面的过程，发现对于每次插入的字符，大的总会在小的后面，所以可以看成每个字符插入的位置是和它前一个字符的位置是相同的，然后相同的位置当中，小的字符牌在前面。

具体实现的时候我懒，使用了 ```priority_queue```，时间复杂度 $\operatorname O(nm\log n)$，$m$ 为字符数量。您们可以使用桶等东西优化时间复杂度至 $\operatorname O(nm)$。

### 代码

[Codeforces 链接](https://codeforces.com/contest/1730/submission/173821882)。
