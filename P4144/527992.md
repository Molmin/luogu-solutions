# 题目大意：
在一段序列中寻找一段连续子序列，使得所有数字的按位与加上按位或最大。

# 思路：
这道题其实就是一道贪心结论题。

先给出结论：
### 答案是序列中最大的数乘 $2$

接下来，顺着我的思路来证明它。

首先，设当前的答案为 $a$，接下来加上的数为 $b$，保证 $a>b$。如果原数 $a$ 还比 $a$ 和 $b$ 进行与运算以及或运算的和更大，我们便选择 $a+a$ 这一更优的方案，那么如果，全部操作中，我们都是选择这样的方案最终的答案就是最大的数乘 $2$ 了。

方案一：选择 $a+a$。

方案二：选择 $a$ 与 $b$ 进行与运算以及或运算的和。


而我们需要证明的，即是方案一永远会大于另一种方案。

我们可以运用**反证法**证明：首先我们假设这一命题不成立，即方案二会优于方案二。

由于前提是 $a > b$，为了使 $a$ 与 $b$ 加上 $a$ 或 $b$ 的和尽量大，所以 $b$ 要尽可能接近 $a$。如果 $b$ 已经很接近 $a$ 了，并且 $2a$ 方案仍然
大于另一种方案，那么 $b$ 取任何值都会如此，综上所述，假设不成立，即命题为真。

例 $1$：     
```               
a 1111
b 1101
& 1101 
| 1111 

```
如例 $1$， 第一行代表 $a$ 在二进制表示下的数，第二行同理表示 $b$ 在二进制下表示的数，第三行代表 $a$ 与 $b$ 进行与运算的结果，第四行代表的是 $a$ 与 $b$ 进行或运算的结果。 $b$ 仅仅少于 $a$ 一个二进制的位。可以发现：当 $a$ 的第 $0$ 位上的值为 $1$ 时，
与运算的结果等于 $b$，或运算的结果等于 $a$，即方案二的结果为 $a+b$，因为 $a>b$，所以 $2a$ 一定大于 $a+b$。


例 $2$：
```
a 1010
b 1001
& 1000
| 1011
```
如例 $2$，每一行同上，当 $a$ 第 $0$ 位上的值为 $0$ 时，虽然与运算结果和或运算的结果不像例 $1$，可是我们发现：将结果相加，结果仍是 $a+b$。

### 所以只要选择数列中最大数乘 $2$ 即为答案。

然后，就差不多是快速幂板子了。

```cpp
#include <bits/stdc++.h>
#define int long long 
using namespace std;
int n, b, q, zd, ans=1, a, sum;
int mi (int x, int y, int mod) {
	while (y > 0) {
		if(y%2 != 0)
		    ans = ans * x % mod;
		x = x * x % mod;
		y /= 2;
	}
	return ans;
}
signed main() {
	ios::sync_with_stdio(0);
	cin >> n >> b >> q;
	for (int i = 1; i <= n; i++) {
		cin >> a;
		zd = max (zd, a);
	}
	sum = mi (zd * 2 + 233, b, q) % q;
	cout << sum <<'\n';
	return 0;
}
```
