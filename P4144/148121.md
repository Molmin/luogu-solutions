本来我开这道题是为了强化位运算的知识的

后来发现这只是一个神奇的贪心~~结论题~~而已

### 结论: 答案是序列中最大值的两倍 (即序列中只包含最大的元素时最优)

证明方法如下: ~~其实两种证法看上去有点相似呢qwq~~

---

**1.用反证法证明**

假设存在一个序列长度为$2$, 且包含元素$a$, $b$, 其中$a$是序列中的唯一最大值,

则对于$a$, $b$的二进制表示$s1$, $s2$中, 必定存在一个数$i$, 

使得$s1$的前$i$位对应的数$≥s2$的前$i$位对应的数, 

且$s1$的第$i$位为1, $s2$的第$i$位为0, 

那么这时我们用$b$更新 $bitand$ 的值时, 第$i$位会从$1$被更新为$0$, 也就是减少了$2^m$ ($m$是从$i$到末尾的位数个数)

而假设$s1$后面的所有位数都是$0$, $s2$后面的所有位数都是$1$, 

那么 $bitor$ 的值也只是将第$i$位以后的值从$0$更新为$1$, 最多只能增加 $2^m-1$, 总的来讲还是减少了, 所以不存在更优解

----

**2.用顺推法证明**

对于任意一个数$a$, 我们分析这个数加入序列后会发生的变化

那么对于$a$的二进制表示从高到低进行讨论

- 如果是$1$: 那么 $bitand$ 的值不会变少, 而且如果原来 $bitor$ 的二进制表示在这一位上是$0$, 那么就会变成$1$

- 如果是$0$: 那么 $bitor$ 的值不会变多, 而且如果原来 $bitand$ 的二进制表示在这一位上是$1$, 那么就会变成$0$

综上所述, 我们要取的$a$应该尽可能在高位上是$1$, 所以$a$应该最大

证毕. 

### 如果有第一个点WA的自行前往[讨论区](https://www.luogu.org/discuss/show/31615)

---

献上码风奇特的代码

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
int arr[100005],n,b,p,ans;
ll ksm(ll x,ll y,ll p){ //快速幂
	ll base=x;x=1;
	while(y){
		if(y&1)x*=base;
		base*=base;
		if(base>p)base%=p;
		if(x>p)x%=p;
		y>>=1;
	}
	return x;
}
int main() {
	cin>>n>>b>>p;
	for(int i=1;i<=n;i++)scanf("%d",&arr[i]),ans=max(ans,arr[i]); //取最大值
	cout<<ksm(ans*2+233,b,p)%p; //按照题目要求处理答案
	return 0;
}

```

