蒟蒻初学$KMP$，搜到了这道题，做完感觉对$next$数组的意义理解的更深刻了，一道非常好的$KMP$练手题，值得一刷。

这题暴力就不说了，一定会$TLE$的，~~再说了，这种题暴力最多是入门~~。如果没学过$KMP$，请看 [这个](https://www.luogu.com.cn/blog/pks-LOVING/zi-fu-chuan-xue-xi-bi-ji-qian-xi-kmp-xuan-xue-di-dan-mu-shi-chuan-pi-post)，然后做一下[这道题](https://www.luogu.com.cn/problem/P3375)。

这道题先来看题意，题目说：

“构造一个字符串s，使得它的可能长度最小，要求s中存在k个位置i,可以找到k个以i为出发点的子串t。”

我们可以理解为在原有字符串中前面和后面找到两个相同的子串，然后......（~~突然忘了要说神马~~），在原有子串的基础上复制$k-1$个包含**中间部分+重复部分**的字符串，即可得到答案。

为神马呢？请看，这是一个字符串：$abccbbabc$，要构造一个字符串，里面含有k个$abccbbabc$，我们可以把这个串前后一样的部分省略掉一个，留下一个就足够了。

假设$k=3$：

如果不省略：$abccbbabcabccbbabcabccbbabc$

长度为$9k$。但是，我们再把这个字符串仔细看一看，会发现，中间有两个$abcabc$，可以把这个子串简化为$abc$，也就是说把前一个的最后和后一个的开头连起来，既然重合就一定会减少，所以这才是最优的方案，长度为$9k-3*2=9k-6$，明显比上一种要短。

这样，可以先把$1$ ~ $next[n]$这一段先打出来，然后输出$k$个残缺（~~没头~~）的字符串，或者先输出整个原始字符串，然后再输出$k-1$个残缺字符串，即可获得答案。

贴重点部分code：

```
for(i=1;i<=n;++i)
printf("%c",s[i]);
for(i=1;i<k;++i)
{
	for(j=nxt[n]+1;j<=n;++j)
	printf("%c",s[j]);
}
```

要注意，$next$是关键字符，不能当数组名，（~~看我的CE记~~~~录~~）。

求个赞