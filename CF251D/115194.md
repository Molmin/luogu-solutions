[题面传送门](https://www.luogu.com.cn/problem/CF251D)

题意：

你有一个可重集 $S=\{a_1,a_2,\dots,a_n\}$，你要把它划分成两个可重集 $S_1,S_2$ 使得 $S$ 中每个元素都恰好属于 $S_1$ 与 $S_2$ 之一。

记 $X_1$ 为 $S_1$ 中所有元素的异或和，$X_2$ 为 $S_2$ 中所有元素的异或和。

最大化 $X_1+X_2$，如果有多种分配方案，再最小化 $X_1$。

$n \in [1,10^5],a_i \in [1,10^{18}]$

暑假省选班讲过这道题，当时听得一脸懵B，还问lxr为什么线性基本质上就是高斯消元。。。。。。wtclwtcl

设 $X=a_1 \oplus a_2 \oplus a_3 \oplus\dots\oplus a_n$，那么显然有 $X_1\oplus X_2=X$。

考虑 $X$ 二进制上的每一位，如果 $X$ 的第 $i$ 位为 $1$，那么意味着它只能拆成 $0$ 和 $1$，不会对 $X_1+X_2$ 产生影响。

但如果 $X$ 的第 $i$ 位为 $0$，那么它可以拆成 $0,0$ 或者 $1,1$，我们的目标是让 $X_1+X_2$ 尽可能大，我们就要尽量选择 $1,1$，也就是要尽量让 $X_1$ 的第 $i$ 位为 $1$。

我们假设 $n$ 个未知数 $x_1,x_2,\dots,x_n$，$x_i=1$ 表示 $i$ 被分配到第一堆，$x_i=0$ 表示 $i$ 被分配到第二堆。

那么 $X_1$ 的第 $b$ 位为 $1$ 等价于一个异或方程 $t_1x_1\oplus t_2x_2\oplus\dots\oplus t_nx_n=1$，其中 $t_i$ 表示 $a_i$ 二进制下的第 $b$ 位是否为 $1$。

具体地来说，我们找到 $X$ 中最高的为 $0$ 的二进制位 $b$，根据之前的推论可以列出一个异或方程，如果该异或方程有解，那么我们肯定要在这一位上放 $1$。因为如果你在这一位上放 $1$，哪怕后面都是 $0$，那 $X_1+X_2$ 也有 $2^{b+1}$，而如果你在这一位上放 $0$，哪怕后面都放 $1$，结果也只有 $2^{b+1}-2$。

我们考虑这样的贪心做法：从高位向低位枚举每一个 $X$ 二进制下为 $0$ 的二进制位 $b$，我们尝试着在这一位上放 $1$，如果存在一种方案，它既能够满足前面的条件（在第 $b$ 位前面放 $1$ 的位都对应一个异或方程，把它们联立起来得到的异或方程组），那么我们就在这一位上放 $1$，否则就在这一位上放 $0$。

最大化 $X_1+X_2$ 之后，我们再考虑 $X_1$ 尽量小这个条件。这时候 $X$ 为 $1$ 的二进制位就要派上用场了。对于 $X$ 二进制下为 $1$ 的位，它又可以细分为第 $1$ 堆分配 $0$，第 $2$ 堆分配 $1$，以及第 $1$ 堆分配 $1$，第 $2$ 堆分配 $0$。我们肯定希望第一堆分配地尽可能少，于是我们重复一遍前面的操作，找到一个 $1$ 位就尝试填 $0$，就可以了。

于是我们有了优秀的 $n \log^3a_i$ 的做法，每次就联立出一个异或方程组，然后高斯消元判断这个异或方程组是否有解。

但其实并不用每次都重新消一遍，对于每个新的异或方程，都用前面的方程消去它的最高位（类似于线性基？）。这样是 $n\log^2a_i$ 的，再注意到每一位系数都是 $0/1$，可以用 ```bitset``` 再搞掉一个 $\log$。

代码就不放出来了，和楼下比较像，只是觉得楼下讲得不太清楚就特意写了篇题解