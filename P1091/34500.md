## 这题的思维比较巧妙。
因为动态规划只能求出一种（单调递增或递减），
所以需要都求一遍，再枚举i，把两个叠加求最大值。

看到楼下dalao的题解有很多人问怎么证明叠加后就一定可以，我来解答一下。

### 解答过程：
它的样例：
```
8
186 186 150 200 160 130 197 220
```
处理了最长上升子序列后：
```1 1 2 2 1 3 4```

处理了最长下降子序列后：
```3 3 2 3 2 1 1 1```

**叠加算法为：(最长上升子序列[i]+最长下降子序列[i])-1**

叠加后：
```3 3 2 4 3 1 3 4```

4即为答案

------------

### 代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[1005],f[1005],f2[1005],maxx;//f为最长上升子序列，f2为最长下降子序列
int main()
{
	cin >> n;
	for(int i=1;i<=n;i++)
		cin >> a[i],f[i]=f2[i]=1;//输入，全部置为1
	for(int i=2;i<=n;i++)
		for(int j=1;j<i;j++)
			if(a[i]>a[j] && f[j]>=f[i])//当发现可以改变最长上升子序列长度是
				f[i]=f[j]+1;//更改
	for(int i=n-1;i>=1;i--)
		for(int j=n;j>i;j--)
			if(a[i]>a[j] && f2[j]>=f2[i])//当发现可以改变最长下降子序列长度是
				f2[i]=f2[j]+1;
	for(int i=1;i<=n;i++)
		maxx=max(maxx,f[i]+f2[i]-1);//合并，找到最大值。
	cout << n-maxx << endl;//输出
	return 0;
}

```
