【算法分析】

我们按照由左而右和由右而左的顺序，将n个同学的身高排成数列。如何分别在这两个数列中寻求递增的、未必连续的最长子序列，就成为问题的关键。设

a 为身高序列，其中a[i]为同学i的身高；

b 为由左而右身高递增的人数序列，其中 b[i]为同学1‥同学i间（包括同学i）身高满足递增顺序的最多人数。显然b[i]=max{b[j]|同学j的身高<同学i的身高}+1；

c为由右而左身高递增的人数序列，其中c[i]为同学n‥同学i间（包括同学i）身高满足递增顺序的最多人数。显然c[i]=max{c[j]|同学j的身高<同学i的身高}+1；

由上述状态转移方程可知，计算合唱队形的问题具备了最优子结构性质(要使b[i]和c[i]最大，子问题的解b[j]和c[k]必须最大(1≤j≤i-1 ，i+1≤k≤n))和重迭子问题的性质(为求得b[i]和c[i]，必须一一查阅子问题的解b[1]‥b[i-1]和c[i+1]‥c[n])，因此可采用动态程序设计的方法求解。

显然，合唱队的人数为max{b[i]+c[i]}-1(公式中同学i被重复计算，因此减1)，n减去合唱队人数即为解。

具体算法如下：

  
```cpp
#include<cstring>
#include<iostream>
using namespace std;
int a[200],b[200],c[200];
main()
{
  int n,i,j,maxx;
  cin>>n;                                         //读学生数
  memset(b,0,sizeof(b));                //身高满足递增顺序的两个队列初始化
  memset(c,0,sizeof(c)); 
  for (i=1;i<=n;i++)                          //读每个学生的身高
   cin>>a[i];
  for (i=1;i<=n;i++)                          //按照由左而右的顺序计算b序列
   {
     b[i]=1;
     for (j=1;j<=i-1;j++)
      if ((a[i]>a[j])&&(b[j]+1>b[i]))
       b[i]=b[j]+1;
   }   
for (i=n;i>=1;i--)                           //按照由右而左的顺序计算c序列
   {
     c[i]=1;
     for (j=i+1;j<=n;j++)
      if ((a[j]<a[i])&&(c[j]+1>c[i]))
        c[i]=c[j]+1;
   } 
  maxx=0;                                 //计算合唱队的人数max（其中1人被重复计算
  for (i=1;i<=n;i++)
    if (b[i]+c[i]>maxx)
       maxx=b[i]+c[i];
  cout<<n-maxx+1<<endl;                         //输出出列人数
}
```
这个算法的时间复杂度为O(n2)，在1秒时限内可解决n≤100范围内的问题。
