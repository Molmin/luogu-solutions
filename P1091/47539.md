我发这个题解不是为了什么，我可以负责任的告诉你们我wa掉了第4个点，而此题解谨此来纪念第4个点。

附上数据：

20
130 140 150 160 170 180 190 200 210 220 221 222 223 224 225 226 227 228 229 230

我的答案：20

标答：0

显然这组数据是有问题且有争议的。

题目上的要求是：有k位同学，身高满足T1<...<Ti>Ti+1>…>TK(1<=i<=K)。

当k=i时显然Ti是不可能>Tk的，这时难道不应该全部出列吗？(即为单调的上升序列，并不满足题意)。

望题目加强说明。


代码最简洁，题解最正常(这是我每次发题解的习惯)

```cpp
#include<bits/stdc++.h>
using namespace std;
int ans,m,a[120],dp[120],b[120],pd[120];//dp[i]为求最长上升子序列的数组表示以第i个人为结尾的最长上升序列。 
int main(){                             //pd[i]为反向处理的数组效果见上，相同。 
    cin>>m;
    for(int i=1;i<=m;i++)
        cin>>a[i];
    for(int i=1;i<=m;i++){
        dp[i]=1;
        pd[i]=1;
    }                                  //dp的初始化，一开始我们认为都是存在合唱队列的。 
    for(int i=2;i<=m;i++){             //枚举终点         
        for(int j=1;j<=i;j++){         //枚举终点前的每一个数。 
           if(a[i]>a[j])               //决策是是否要将其加入上升序列，如将上升序列能变长，若，加上1，表示将自己加入到序列，否则保持原来序列。 
                dp[i]=max(dp[i],dp[j]+1);//求出最长上升子序列。 
    }
}
     for(int i=1;i<=m;i++)
        b[i]=a[m-i+1];                  //做反向处理 
     for(int i=2;i<=m;i++){             //做法见上，一样。 
        for(int j=1;j<=i;j++){
           if(b[i]>b[j])
              pd[i]=max(pd[i],pd[j]+1);//反向求出最长上升子序列。 
    }
}
     for(int i=1;i<=m;i++){
        if(dp[i]!=1 && pd[m-i+1]!=1)//wa掉第四个点的地方。当全部为下降或上升序列时直接出列所有人(当然只有一个人的时候也出列) 
           ans=max(ans,pd[m-i+1]+dp[i]-1);//那么每个点在算最长上升和反向最长上升的时候重复了一次，我们要减掉一次。 
}
     cout<<m-ans;//输出出列人数。 
        return 零;//大家都懂我这样象征一下是什么意思，我就再多说了。       
}

```