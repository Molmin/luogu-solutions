题意：
	
每个 `>` 或 `<` 字符在被选择后，就会删去这个字符**小头**那边的字符。

现在你可以随意删去字符（不可以删去整个字符串），需要保证最后留下的字符中按照以上规则删去任意个字符后的字符串只留有 **一种字符 （`<` 或 `>`）**，希望删去字符的数量越小越好。

题解：

唯一难点就是如何寻找“Good string”：

首先发现对于一个串，如果它的最左边是 > 或最右边是 <，则这个串一定可以删去其它的所有字符，是一个 `Good String`。

其次思考后发现 `Good String` 的含义为：从左边/右边一直删到不能再删为止，然后分别比较（是的，左右不能同时删）

所以直接模拟上去。

注意本题多组数据，输入输出量稍大，建议用 `scanf` 和 `printf`。

没看懂上面文字的看代码注释。 
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,t;
char s[105];
/*由于字符串整体字符没什么变数,而且长度已知,所以用了 char 类型*/
int main ()
{
	scanf("%d",&t);
	for(int g=1;g<=t;g++){
		scanf("%d",&n);
		scanf("%s",s+1);
		int i=1;
		int a1=0,a2=0;
		/*从左边删*/
		while(s[i]=='<'){
			if(i==n) break;
			a1++;
			i++;
		}
		/*从右边删*/
		while(s[n]=='>'){
			if(n==1) break;
			a2++;
			n--;
		}
		/*输出操作次数哪个最小*/
		printf("%d\n",min(a1,a2));
		/*注意换行*/
	}
	return 0;
}
```
