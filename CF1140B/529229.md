## 题意

先有一个长度为 $n$ 的字符串，由 `<` 和 `>` 组成。

对 `<` 进行操作，这个 `<` 的左边的字符就会被删掉。

对 `>` 进行操作，这个 `>` 的右边的字符就会被删掉。

如果一个字符串经过若干次操作后可以让字符串中所有的字符相等（即全是 `>` 或全是 `<`），那么它就是好串。

问对于输入的字符串，通过删除 $k$ 个字符可以使得让它变成一个好串。问 $k$ 最小是多少。

## 思路

进行分析，如果一个字符串是一个好串，那么它只有两种可能，全是 `>` 或全是 `<`，易得这两种可能都能够将字符串删到只剩一个字符。同理，只剩一个字符时也肯定是一个字符。

因此，变成好串就可以视为是要让它变得只剩一个字符。

再次分析可以发现，如果最左边是 `>`，那么就可以把自己右边的字符全部删掉，只剩下自身，那么它就是一个好串。

同理，如果最右边是 `<`，那么就可以把自己左边的字符全部删掉，它也是一个好串。

题目中要求让删去的字符数最少，就要让它变成一个字符中进行的操作数最多，让操作数最多，就需要从最两边开始删。

到这里这题的思路就很明显了，找出如果要让最左边的 `>` 成为最左端要删去几个字符；再找出如果要让最右边的 `<` 成为最右端要删去几个字符，最后找出两者的最小值即可。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int t,n,suml,sumr,zb,yb;
string st;
int main(){
	scanf("%d",&t);
	while(t--){
		scanf("%d",&n);
		cin>>st;
		yb=n-1,zb=0,suml=0,sumr=0;
		while(st[yb]=='>'&&yb>=1)
			suml++,yb--;
		while(st[zb]=='<'&&zb<n)
			sumr++,zb++;
		printf("%d\n",min(suml,sumr));
	}
	return 0;
} 
```