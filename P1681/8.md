[color=red]最终思想是动规[/color]

##刚开始的思想是扩展

就是先确定一个正方形的大小l（每次累加），扫描每个大小为l的正方形左下角的点，然后查一遍整个矩形

[color=red]呵呵,肯定超时[/color]

##接着想到一种奇葩的动归

每次累加l，然后在f数组中存放以[i,j]这个位置为正方形的左下角l为正方形长度是否能有正方形（存的是maxl），（就差一步），当f[i-1,j]>=l-1且f[i-1,j-1]>=l-1且f[i,j-1]>=l-1时f[i-1,j]=l因为左，左上，上的最大正方形长度都>=l-1，所以肯定存在（[color=red]为什么?[/color]）

最坏情况l=1500，n=m=1500,o(nml)>10亿，超！

##突然想到为什么要每次累加l

其实就是在[i-1,j],[i,j-1],[i-1,j-1],[i,j]这四个组成交错正方形时

f[i,j]=min(f[i,j-1],f[i-1,j-1],f[i-1,j])+1

因为既然是min

则三个正方形变长都>=min

所以加上[i,j]后边长一定=min+1[color=red]（很难，自己画个图好好理解）[/color]

就这样

取max(f)就行了（[color=purple]伪代码[/color]）

============================================================================

========================人造分割线（忘了分割线的ubb了）=====================

============================================================================

[color=red]下面核心代码有n个错误，小心被坑哦！[/color]

核心代码如下

```delphi

begin
{读入（我读在数组a中），预处理}
    for i:=2 to m do
      for j:=2 to n do
        if (a[i-1,j-1]=a[i,j]) or (a[i-1,j]=a[i,j]) or (a[i,j-1]=a[i,j]) then
          f[i,j]:=min(f[i-1,j-1],f[i-1,j],f[i,j-1])+1;
{然后提取max就行了}
{其实提取max可以集成在上面的for循环中，只是我懒得写begin，end（估计这么奇葩的就我一个）}
  writeln(ans);
end.

```