这是道水题....但是我想到了一个奇妙的算法，我把它叫做————层增法

大致思想就是：

		设f[i][j]表示**以（i，j）为右下角的最大正方形边长**，

		则对于每一个s[i][j],若s[i][j]==s[i-1][j-1]，

		那么（划重点）——从当前点开始，扫一遍行和列，若符合条件则:

			**f[i][j]=f[i-1][j-1]+1；**

		若中途发现不对，就取**较长边**作为当前f[i][j]的值.

这个过程就像在一个格子上层层增加，故而我称之为层增法。

其实说到底也就是动态规划思想的运用：用已知状态推出未知状态。

这个算法其实还只是个雏形，还有许多优化之法 万望各位神犇赐教～～

老板，来份天然有机绿色AC代码！

```cpp
#include<bits/stdc++.h>
using namespace std;
int s[1510][1510],f[1510][1510],ans=1;
int main(){
        int n,m;
        cin>>n>>m;
        for(int q=1;q<=n;q++)
        for(int w=1;w<=m;f[q][w]=1,w++)//每个点都可以单独作为一个正方形
                cin>>s[q][w];
        for(int q=1;q<=n;q++)
        for(int w=1;w<=m;w++)
        if(s[q][w]==s[q-1][w-1]){
             int i=s[q][w],j=s[q][w],l1=1,l2=1;//i、j作为比对的对象  l1,l2是接下来扫描终点到（i，j）的最远距离
             for(int e=w-1;e>=w-f[q-1][w-1];e--)//扫描长度为f[i-1][j-1]
                  if(s[q][e]!=i)i=s[q][e],l1++;
                  else break;
             for(int e=q-1;e>=q-f[q-1][w-1];e--)//同上
                  if(s[e][w]!=j)j=s[e][w],l2++;
                  else break;
             ans=max(ans,f[q][w]=min(l1,l2));//取最小值
        }
        cout<<ans;
}
```
至于为什么取l1,l2最小值，可以自己画个图～～

PS:感谢某hao提供表述及完善