~~思路很清奇~~

我用的方法是带有预处理的dp

先预处理出当前格向上和向左能拓展多少格（code中向上用u表示，向左用l表示），然后进行dp

注意预处理中拓展的格数包括这个格子本身（其实也可以不包括）

dp的思路是：

(1)对于颜色和左上方的格子不同颜色的格子，以它为右下角的最大黑白相间正方形边长只能为1

(2)对于颜色和左上方格子相同颜色的格子，比较以（它左上方的格子为右下角的最大黑白相间正方形边长+1），（它向上拓展的格子数），（它向左拓展的格子数），并取最小值作为以它为右下角的最大黑白相间正方形边长

即dp转移方程为：

$dp[i][j]=min(dp[i-1][j-1]+1,min(l[i][j],u[i][j]))$

------------

这里对dp转移方程给出~~难以看懂的~~证明，秒懂的神仙可跳过

对于以格子$(i,j)$为右下角的最大黑白相间正方形，假设它的边长不为1，那么它一定包含着以它左上方的格子，所以$a[i][j]$要等于$a[i-1][j-1]$

那么假设它向上和向左拓展的格子数均大于以它左上方的格子为右下角的最大黑白相间正方形的边长，那么它一定包含以它左上方的格子为右下角的最大黑白相间正方形，而且无法继续向左上方拓展，所以这时$dp[i][j]=dp[i-1][j-1]+1$

反之，如果以它左上方的格子为右下角的最大黑白相间正方形的边长大于它向上或向左拓展的格子数，那么它一定不完全包括以它左上方的格子为右下角的最大黑白相间正方形。所以此时$dp[i][j]=min(u[i][j],l[i][j])$

~~看不懂就算了吧~~

------------

$Code:$
```
#include <cstdio>
#include <iostream>
using namespace std;
int n,m,a[1501][1501],ans;
int u[1501][1501],l[1501][1501],dp[1501][1501];
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)
	for(int j=1;j<=m;j++){
		scanf("%d",&a[i][j]);
		if(a[i][j]!=a[i-1][j])
		u[i][j]=u[i-1][j]+1;
		else u[i][j]=1;
		if(a[i][j]!=a[i][j-1])
		l[i][j]=l[i][j-1]+1;
		else l[i][j]=1;
		if(a[i][j]==a[i-1][j-1]){
			dp[i][j]=min(dp[i-1][j-1]+1,min(l[i][j],u[i][j]));
		}
		else dp[i][j]=1;
		ans=max(ans,dp[i][j]);
	}
	printf("%d\n",ans);
	return 0;
}
```
