# 题目大意

- 构建一个 $n$ 个数的序列，使得这个序列中所有数的和为 $k$ 的倍数。

# 题解

- 从 $n$ 个数的序列考虑有些困难，我们可以从 $k$ 开始考虑。

- 我们读题发现，序列的和是 $k$ 的倍数，且使最大数最小，那么这个倍数肯定刚刚好超过 $n$，于是我们想到的最暴力的求法：

```cpp
int i = 1; // 记录i个k时可以超过n
while (i * k < n) 
{
	i ++;
}
int sum = i * k; // 序列总和
```

- 但是这个求法过于暴力，如果 $n$ 很大的话，会超时，那么我们换一种方法求，我们可以算出刚好超过（或等于） $n$ 的 $k$ 的倍数，然后再乘上 $k$，即为序列总和，具体实现方法十分简单，**但要注意，如果 $n \bmod k$ 大于零，倍数还要加 $1$**：

```cpp
int sum = n / k; // 几倍的k 
if (n % k != 0) // 上文说要注意的情况 
{
	sum ++;
}
sum *= k; // 序列总和
```

- 然后我们要处理最大数，仔细想想，如果最大数尽可能小，那么这个数就是这个序列的平均数，不过要注意是最大数，取模如果大于 $0$，结果还要加 $1$：

```cpp
if (sum % n == 0)
{
	cout << sum / n << endl; // 能整除，最大的数即为平均数 
}
else
{
	cout << sum / n + 1 << endl; // 如果sum无法整除n，那么最大数即为平均数加1 
}
```

# 代码

```cpp
#include <bits/stdc++.h>

using namespace std;

int T; // 数据组数 

int main()
{
	cin >> T;
	while (T --)
	{
		int n, k; // n为序列长度，k为整除的数字
		cin >> n >> k;
		int sum = n / k; // 几倍的k 
		if (n % k != 0) // 上文说要注意的情况 
		{
			sum ++;
		}
		sum *= k; // 序列总和
		if (sum % n == 0)
		{
			cout << sum / n << endl; // 能整除，最大的数即为平均数 
		}
		else
		{
			cout << sum / n + 1 << endl; // 如果sum无法整除n，那么最大数即为平均数加1 
		}
	}
}

```
