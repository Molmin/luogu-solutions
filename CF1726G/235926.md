有趣的题。

---

首先特判掉所有数字都相等的情况，这时答案显然为 $n!$ 。

观察最后会变成哪个数：我们找到全局最小值，若其 $b_i=0$，则显然无解。若其 $b_i=1$，那么无论在什么时候操作它都会变成 $a_i+n-1$，最后所有数一定也是这个值。

---

我们将所有数分成 $b_i=0$ 和 $b_i=1$ 两类处理，先考虑 $b_i=0$ 内部删除的相对顺序：

如果我们先操作 $x$，再操作 $y \space (y<x)$，那么两数的增量一定有 $\Delta_x>\Delta_y$。这样最终的 $x$ 就大于最终的 $y$，一定不合法。

所以对于所有 $b_i=0$ 的元素，我们一定按照从小到大的顺序删除。

---

然后考虑 $b_i=1$：

记 $val$ 为最终的值，所有等于 $val$ 的元素都可以在任意时刻删除，我们给答案乘上一些东西后就不再考虑这些元素。

如果我们要在其中选择一个删除，我们一定会选择最靠右的删除后变成 $val$ 的元素。因为如果没有选择最靠右的，那么删除以后最靠右的这个元素最终变成的元素就会大于 $val$，之后的改变不能使最终变成的元素减少，所以就不合法了。

---

然后考虑一起考虑这两类：

先判断能否在 $b_i=0$ 或 $b_i=1$ 中找到元素删除，如果都找不到，则显然无解。如果只找到了一个，直接删除就可以了。

如果两个都找到了，考虑判断它们值（记为 $v_0$ 和 $v_1$）的相对大小关系：若 $v_0 \leq v_1$，则为了之后操作的合法，一定只能删除 $b_i=1$ 的元素，反之只能删除 $b_i=0$ 的元素。

这样，我们发现每次只能删掉一个固定的元素，直接模拟即可。

有解时的计数也很简单，因为每个 $(a,b)$ 二元组互不区分，我们直接乘上每种二元组出现次数的阶乘就可以了。

---

实现时可以在模拟的过程中使用线段树，树状数组等数据结构快速维护，时间复杂度 $O(n\log n)$ 。