**0. 前言**  
**提醒：本题有多测**  
[这题](https://luogu.com.cn/problem/CF1690D)适合唬人，说白了就是思维题。思考加实现用了九分钟，是本场比赛我用时第三短的题目（第一 A，用了三分钟，第二 C，用了五分钟，B因为【】错误+不开 LL 用了将近二十分钟。。。）  

**1. 分析**  
如果暴力很简单，就枚举每个 $1\le i<i+k-1\le n$，的区间，然后看有多少个白色，统计最小值就完了。  
但是 $n^2$ 原地 T 飞。  
有没有更快的统计方法呢？  
我们先看 $[1,k]$ 这个区间。暴力统计一下。  
然后就该统计 $[2,k+1]$ 了。（倒序枚举也差不多）我们发现，这次还需要再循环 $k$ 次，真是太麻烦了。而 $[1,k]$ 这个区间的答案已经知道了，所以是不是可以...借来用用？  
但是我们要先把 $1$ 的位置踢了。如果是白色，那么用前面的答案减去 $1$。再把 $k+1$ 加进来，如果是白色，那么前面的答案再加上 $1$，就得到了 $[2,k+1]$ 的答案。以此类推，每一次把前面一个的左端点去掉，这一个的右端点加进来，就变成了当前区间的答案。  
~~那你可能就要问了，我太菜了容易写挂怎么办？~~  
我们可以对这个算法进行写法上的优化。  
抡出我们的利器 **前缀和**。  
令白色为 $1$，黑色为 $0$，求前缀和 $s$，满足 $s_i=\sum_{j=1}^ia_j$，对于区间 $[i,j]$，每个元素的和就是 $s_j-s_{i-1}$。直接用上面公式算一下就知道了。  

但是因为我懒得重写，同时也因为第二种方法比较好实现（借口一大堆）所以放的是第一种做法的代码。  

**2. 代码**  
```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
#define maxn 200005

using namespace std;

string s;

void solve() {
	int n, k, ans = 0x3f3f3f3f;
	scanf("%d %d", &n, &k);
	cin >> s;
	int cnt = 0;
	for(int i = 0; i < k; i++) {
		if(s[i] == 'W') cnt++; //暴力统计 [1,k]，我从0开始存储的
	}
	ans = min(ans, cnt);//别忘了这里要统计一次答案
	for(int i = k; i < n; i++) {//这里我枚举右端点
		if(s[i] == 'W') cnt++;//加上后面的
		if(s[i - k] == 'W') cnt--;//扣掉前面的
		ans = min(ans, cnt);
	}
	printf("%d\n", ans);
}

int main() {
	int t;
	scanf("%d", &t);//记得有多测
	while(t--) {
		solve();
	}
}
```