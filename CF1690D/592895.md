题意很清楚，就不提了。

Sol.
-
一开始看到题目想到 dp，但是发现题解区都是前缀和。

那么我今天用差分做这个题 ~~（虽然还是用到了前缀和）~~

设 `dp[i]` 为以 $i$ 为起点，长度为 $m$ 的子串需要修改的次数。

先假设字符串中全是 `B`，显然所有 `dp` 值均为 $0$。

考虑当字符串中出现一个 `W` 会怎么样。

显然，第 $i$ 个位置出现一个 `W` 会让 `dp[i-m+1]`~`dp[i]` 值加 $1$。

那么很容易想到差分了。

最后统计 `dp[1]`~`dp[n-m+1]` 中的最小值即可。

Q：~~为什么不用线段树/树状数组？~~

A：线段树/树状数组一般用于在线修改/查询，复杂度是 $\mathcal O(n\log n)$。

 $\ \ \ \ \,$ 而差分是离线修改/查询，复杂度是 $\mathcal O(n)$。

此题最后才询问，所以可以用差分。

注意，因为差分区间加的左端点可能是负数，所以我们要把数组集体往右平移 $2\times 10^5$ 格。
### code:

```cpp
char s[N];
int dp[N<<1];
int delta[N<<1];
bool major(){
	memset(delta,0,sizeof delta);
	int n=read(),m=read();
	scanf("%s",s+1);
	for(itn i=1;i<=n;i++)
		if(s[i]=='W')
			delta[i-m+1+N]++,delta[i+1+N]--;
	int ans=0x3f3f3f3f;
	dp[0]=0;
	for(int i=1;i<=N;i++)//负数区间前缀和，不计入答案（因为一大堆0）
		dp[i]=dp[i-1]+delta[i];
	for(int i=N+1;i<=(n-m+1)+N;i++)
		ans=min(ans,(dp[i]=dp[i-1]+delta[i]));
	return printf("%d\n",ans);
}
```
~~细心的你可能会发现上面的代码中 `dp` 数组可以直接去掉……~~

那么，感谢观看。~~也感谢管理员大大没有关上题解通道。~~