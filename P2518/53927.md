对于题目给的整数n，我们先想象这个数之前的那些数，其中一部分数的位数与n相等，而另一些则位数比n少。对于位数比n少的数，我们在它们前面加上前导0。因为位数比n少完全是由于按照题目所说的方法插入0的个数较少所致，所以**加入前导0补全后，所有数字中0~9出现的次数都和n相等了。**

这让人想到什么？全排列，但是是带重复元素的全排列。**我们要求的正是在全排列中小于n的数的个数。**

首先，带重复元素全排列计算方法为元素总个数的阶乘除以各个元素个数阶乘之积。

公式有了，接下来考虑怎么保证排列出的数字小于n。这种情况下就需要数位DP了。**设dp[i][j]表示前i-1位已经固定，在决定第i位上的数字为j的情况下，小于n的数字个数。**要保证统计到的数不重复不遗漏，且都小于n，数位DP中较常用的办法是**当前i-1位被固定下来时，这i-1位数字应当与n的前i-1位数字相同，而第i位上的数字的取值范围为[0,n[i])**,其中n[i]表示n的第i位上的数。这样，从第i+1位开始到最后一位上无论是什么数，**都一定小于n。**

在实际的计算中并不需要把dp值存在数组里，因为我们最后求的是它们的和，因此**实时计算并加入ans**里即可，代码中也是这么处理的。

因此最后的做法是当前i-1位固定时，从可以用来做全排列的元素集合中删去它们，枚举第i位是元素集合中的哪个元素，并**将剩下的元素做全排列。**

做全排列时存在阶乘的值暂时溢出了long long的可能，即使最终答案并没有溢出。可以注意到最多也就是算50的阶乘左右，循环次数很小，因此我们可以采取耗费更多的时间来防止溢出的办法。具体操作起来是将全排列公式中的分母部分，即各个元素的阶乘之积，拆开成连续的多个数相乘，再把它们装到一个类似桶排序的桶子的数组中(程序中使用了pool这一数组名)。在计算所有元素个数的阶乘时，没乘上一个数，就扫描一遍检查是否有除以桶子中某个数字的可能，能除则除。由于保证答案不溢出，所以这样做也就不会溢出。

```
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
using namespace std;
char a[100];
long long len,mem[100],cont[10],pool[1000],poi,ma=0;
//len为n的位数，pool为桶子，cont为元素集合，并记录了各个元素的个数，mem为拆位后的整数n，ma为元素最个数最多的元素有几个。
void build(long long x)
{
    poi=0;
    memset(pool,0,sizeof(pool));
    --cont[x];//由于第i+1位填了x，因此暂时将其从元素集合去除
    int i,j;
    for(i=0;i<=9;++i)
    {
        for(j=2;j<=cont[i];++j)//除以1没有意义，因此为了优化运行时间不作考虑。
        {
            ++pool[j];
        }
    }
    ++cont[x];//为了后续计算再将x加入集合
}//往桶子里装数字的过程
long long getsum(long long x)
{
    long long ans=1,i,j;
    for(i=1;i<=x;++i)
    {
        ans*=i;
        for(j=2;j<=ma;++j)
        {
            for(;;)
            {
                if(pool[j]==0||ans%j!=0)//能除则除
                {
                    break;//不能除退出循环
                }
                else
                {
                    --pool[j];
                    ans/=j;
                }
            }
        }//扫描桶子
    }
    return ans;
}
int main()
{
    long long i,j;
    long long ans=0;
    memset(cont,0,sizeof(cont));
    scanf("%s",&a[0]);
    len=strlen(a);
    for(i=0;i<len;++i)
    {
        ++cont[a[i]-'0'];
        if(cont[a[i]-'0']>ma)
        {
            ma=cont[a[i]-'0'];
        }
        mem[i+1]=a[i]-'0';
    }//拆数与构造数字元素集合
    for(i=1;i<=len;++i)
    {
        for(j=0;j<mem[i];++j)
        {
            if(cont[j]>0)
            {
                build(j);
                ans+=getsum(len-i);//计算全排列，不必保存，直接加入ans。
            }
        }//枚举第i位，取值范围[0,n[i])
        --cont[mem[i]];//确定第i位（即与n的第i位相同）后就将对应的元素从集合拿出。
    }
    printf("%lld",ans);
    return 0;
}
```