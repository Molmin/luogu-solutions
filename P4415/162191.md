找到**合适的翻译**后，理解题意并不难，因为数据范围很小（$T < 50$），是一道赤裸裸的**模拟**，直接模拟每一秒钟蚂蚁的状态

# 输入
简单分析样例后我们发现，输入时给定的向右走的蚂蚁的顺序，**并不是**我们以上帝视角看见的顺序（一整排蚂蚁从左向右的顺序），如：   
输入的数据为 
```
ABCD
EFG
```
那这一排蚂蚁**实际的顺序**是
```
DCBAEFG
```
也就是说，我们在读入第一排蚂蚁的顺序后，要先将其**调换位置**
   
我们要实现上面的想法，需要在输入时找一个替身，如下
``` cpp
cin >> s1_t >> s2; //s1_t为替身
for (int i = 0;i < n1;i ++)
  s1 += s1_t[n1 - 1 - i]; //交换顺序
s = s1 + s2; //string类可以直接使用 '+' 进行连接
```

# 模拟
## 初始化
我们如何区分每只蚂蚁走的**方向**呢？很简单，给每一个蚂蚁附一个值 $M$，$M_i = 0$ 表示蚂蚁 $i$ 向右走，$M_i = 1$ 则表示蚂蚁 $i$ 向左走，为了方便后面的操作，我们可以**直接用字符作为数组的下标**，就要用到STL中的一大利器—— $Map$，在最初输入结束后对 $M_i$ 进行赋值
``` cpp
map <char,int> m;
for (int i = 0;i < n1;i ++)
  m[s1[i]] = 0;
for (int i = 0;i < n2;i ++)
  m[s2[i]] = 1;
```

## 实现
每一次交换位置，我们可以看为**向左走的蚂蚁不动**，只有**向右走的蚂蚁动**，那么，每次判断时只用去找 $M_i = 0$ 的蚂蚁即可  
每一次（秒）自左向右查看整个字符串 $S$，那么查看字符 $S_i(0 \leqslant i < length(S))$ 时，有**以下两种**状态及结果：
 - $M_{S_i}$ 为 $0$ ，且 $M_{S_{i + 1}}$ 为 $1$，那么两者**需要交换位置**
 - $M_{S_i}$ 为 $0$ ，但 $M_{S_{i + 1}}$ 也为 $0$，那么 $S_i$ **位置不变**

得到以上分析，完整的代码就不难写出来了

# 完整代码

``` cpp
#include <iostream> //头文件
#include <cstdio>
#include <cstring>
#include <map>
using namespace std;

int n1,n2,t;
string s1_t,s1 = "",s2,s;

map <char,int> m; //M储存方向

int main(){
	scanf("%d%d",&n1,&n2);
	cin >> s1_t >> s2;
	for (int i = 0;i < n1;i ++) //注意输入方向
	  s1 += s1_t[n1 - 1 - i];
	s = s1 + s2;
	for (int i = 0;i < n1;i ++) //赋值蚂蚁的行进方向
	  m[s1[i]] = 0;
	for (int i = 0;i < n2;i ++)
	  m[s2[i]] = 1;
	cin >> t;
	string tmp = s; //替身使者
	while (t --){
		for (unsigned int i = 0;i < s.length();i ++) //遍历整排蚂蚁
		  if (!m[s[i]] && m[s[i + 1]]){ //如果两者方向相反
		  	tmp[i] = s[i + 1]; //交换位置
		  	tmp[i + 1] = s[i];
		  }
		  else if (!m[s[i]])
		    tmp[i] = s[i];
          //在这里，如果第一个条件不符合，但这只蚂蚁向右走，
          //则下一只蚂蚁一定也向右走，位置不需要改变
		s = tmp; //更新 S
	}
	cout << s;
	return 0; //完结撒花
}
```
