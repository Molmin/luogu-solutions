同学推的题，感觉不算很困难（每一步都挺自然的）

首先进行一次拓扑排序，把有可能被删掉的点给筛出来。然后你发现这些点组成的边集构成了一个森林。

里面有两类树，一类是独立的树，另一类是连在一个环上的树。

我们先考虑第二类树，设计 $dp_{i,j}$ 表示以 $i$ 为根的子树中，选 $j$ 个点的方案数。

合并 $i$ 点的子树的答案的时候就直接用树形背包的方法，再加上组合数合并。具体为 $dp_{i,j+k}=dp_{i,j}\times dp_{son,k}\times \binom {j+k}{k}$，这个式子意思就是：$i$ 节点的第 $k$ 个子树的选点方案和前 $k-1$ 个子树的选点方案是不冲突的，因此可以直接相乘再组合数合并答案。注意为了避免重复更新答案，你应该开一个临时数组把答案存进去（也可以倒序枚举），等合并完再转回来。特别的，$dp_{i,siz_i}=dp_{i,siz_i-1}$（根节点必须最后删）

对于第一类树，感觉可以钦定最后一个被删的是哪个点，但更简单的方法是直接对每个点为根跑一遍第二类树的方法，然后发现选 $i$ 个点的情况在**没被选的 $siz-i$ 个点为根的时候**会被统计，因此答案要除以 $siz-i$（如果全选是特殊情况，不需要除）

然后就是森林合并答案，就用类似合并子树的方法组合数合并就可以了。

代码太长就放[提交记录](https://codeforces.com/contest/512/submission/164023646)了。