# 一个简单的队列操作.
### 一、队列是什么
- 队列是一种可以实现“先进先出”的存储结构。

队列通常可以分为两种类型：

一、顺序队列，采用顺序存储，当长度确定时使用。

顺序队列又有两种情况：

　　①使用数组存储队列的称为静态顺序队列。
  
　　②使用动态分配的指针的称为动态顺序队列。
  
二、链式队列，采用链式存储，长度不确定时使用（由链表实现）。

由于链式队列跟链表差不多，所以在这里只针对循环(环形)队列来说明并实践。

　　①front,front指向队列的第一个元素。(front==head)
  
　　②rear,rear指向队列的最后一个有效元素的下一元素。(rear==tail)

队列的两个基本操作：出队和入队。


------------
### 二、队列的结构
![](http://dl.iteye.com/upload/picture/pic/110669/a63ecb7e-4b25-3851-b6ef-20b3b0655ffd.gif)


### 三、队列的操作
入队（尾部入队） 

　　①将值存入rear所代表的位置。
  
　　②rear = (rear+1)%数组的长度。
  
出队（头部出队） 

　　front = (front+1)%数组的长度。
队列是否为空   

　　front和rear的值相等，则该队列就一定为空。
  
队列是否已满


在循环队列中,“队满”和“队空”的条件有可能是相同的，都是front ==rear，这种情况下，无法区别是“队满”还是“队空”。

针对这个问题，有3种可能的处理方法： 【这里采用了第3种处理方法】

（1）另设一个标志以区别是“队满”还是“队空”。（即入队/出队前检查是否“队满”/“队空”）

（2）设一个计数器，此时甚至还可以省去一个指针。

（3）少用一个元素空间，即约定队头指针在队尾指针的下一位置时就作为“队满”的标志，即“队满”条件为：(pQueue->rear+1)%MAX_SIZE == pQueue->front。


------------

## 队列的运用：

定义队列如下：queue<int> q；
  
q.empty(); //如果队列空返回true ，否则返回false；
  
q.size(); //返回队列中元素的个数
  
q.pop();//删除队列首元素但不返回
  
q.front();//返回队列首元素的值且不删除
 
q.back();//返回队列尾元素的值且不删除
  
q.push();//在队尾压入新元素

------------

精彩的来了Code:
------------
```c
#include <bits/stdc++.h>
using namespace std;
int m,n,ans;
bool v[1005];
queue<int> q;
int main(){
	scanf("%d%d",&m,&n);
	int x;
	for(int i=1;i<=n;i++){
		scanf("%d",&x);
		if(v[x])continue;
		else{
			if(q.size()>=m){
				v[q.front()]=0;
				q.pop();
			}
			q.push(x);
			v[x]=1;
			ans++;
		}
	}
	printf("%d",ans);
	return 0;//功德圆满
} 
```

  