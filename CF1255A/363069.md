### 题目分析

首先先算出两数之差，然后取绝对值（因为不管是整数还是负数操作都是一样的），然后如果差大于 $5$，那么用 $5$ 逼近，直到小于 $5$。

小于 $5$ 下调的最佳方案如下：



| 差值求余 $5$ 的结果 | 次数 | 方案 |
| ---------- | ---------- | ---------- |
| $1$ | $1$ | 一个 $1$ |
| $2$ | $1$ | 一个 $2$ |
| $3$ | $2$ | 一个 $2$，一个 $1$ |
| $4$ | $2$ | 两个 $2$ |


如楼下所说，其实还有一种可能情况：即，先调到一个更高的音量然后再下调或是先调到一个更低的音量然后再上调。但其实这种方法并不会更好。

证明如下：

首先，如果我们向上跳到一个数，那么这个数一定小于 $5$，（因为多了没用），其次我们多调依次要使用一次，可最大的差距（$4$ 和 $1$），中间的方案差也只有 $1$，加上向上调使用的也不会次数更少。

其它具体见代码注释。

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
inline int read()//快读
{
    register int x=0,f=1;
    char c=getchar();
    while(c<'0'||c>'9')
    {
        if(c=='-') f=-1;
        c=getchar();
    }
    while(c>='0'&&c<='9')
    {
        x=(x<<3)+(x<<1)+(c^48); 
        c=getchar();
	}
    return x*f;
}
int main()
{
    int t;
    t=read();
    while(t--)
    {
        int a=read(),b=read();
        int ans=0;//方案数
        int gap=a-b;
        
        if(gap<0) //因为不管是a大还是b大，操作的过程是一样的，所以把负的变成正的
            gap=0-gap;
        ans=gap/5;//每次向上调5，正好c++是向下取整，gap/5就是要做加5或减5的次数
        gap%=5;//调完5之后剩的a和b的差
        //分类讨论，可手推证明
        if(gap==1) ans+=1;//一个1
        if(gap==2) ans+=1;//一个2
        if(gap==3) ans+=2;//一个2，一个1
        if(gap==4) ans+=2;//两个2
        cout<<ans<<endl;//记得换行
    }
    return 0;
}
```

完结撒花（*★,°*:.☆(￣▽￣)/$:*.°★* 。）。再见！