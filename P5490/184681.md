这题维护线段树好难啊（本人过于蒟蒻）

好了分享以下这题到底怎么建树

首先想明白几个问题：
1.线段树可以维护的信息必须具有什么性质？

2.题中哪些信息需要维护，其中哪些具有这一性质，哪些不具有这一性质？

3.对于不具有这一性质的信息，怎么维护？

答：

1.可加性

2.区间厚度，区间被覆盖长度， 前者不可加，后者可加


前两个问题非常显然。因为本题在扫描过程中需要随时修改覆盖，并随时查询被覆盖长度。那么问题就变成了如下：

有一个区间[1，mx]， 每次在[l, r]上进行区间加1 或者区间减1， 每次查询有多长的区间不是零。

那么显然有两个重要信息：

1. 区间[l，r]中， 不是是0的长度len。

2. 区间[l，r]中， 每个子区间被覆盖的厚度


第一条信息是答案，第二条信息的意义在于进行减操作时，可以知道本区间有没有被减为0。 设想不维护第二条信息的话，如果本区间实际被覆盖了2次，那么减1的时候你就不知道有没有被减为0。进而无法修改第一条信息，进而答案无从得知。

好了，到这里，显然如果我们知道了[l,mid]和[mid,r]两个区间的覆盖长度len1， len2， 那么对于区间[l,r] 的区间覆盖长度len可以直接由 len1， len2 得知，即

len = len1 + len2

不过有一个条件，[l，r] 已经不能被整体覆盖

那么如果[l，r]被整体覆盖了呢？

显然len = r-l

现在对于开头第三个问题，有没有什么想法？

对于线段树每一个节点代表的区间，维护一个信息：该区间被整体覆盖的次数，这样，该信息就不需要进行合并，换句话说，每一个节点代表的区间的被覆盖厚度，与其他节点无关。

那么继续仔细想想，如何修改？

如果当前修改为[L,R] 区间加1，那么就可以用普通区间修改的思路，把[L,R]分解为线段树上的区间， 每个区间的覆盖厚度+1， 并且改其len = r-l

如果-1， 那就先用区间加的思路-1， 检查当前区间覆盖厚度是否为0，如果为0， 那么区间覆盖长度len = len1 + len2 （len1，len2为len的子区间的覆盖长度，就是节点node的子节点对应的覆盖长度）

好了，修改完全行得通，时间复杂度logn

查询呢？

无脑查询根节点即可（逃）

至此，时间复杂度nlogn


注意：
1.本题线段树使用的是实数区间，不是整数数列！因此区间需要仔细考虑边界！

2.请使用unsigned long long 记录答案！

3. 因为是实数区间，所以线段树数组开四倍不够！本人开了四十倍.


如果需要代码，提交记录里搜本人即可


