## 【坑点】
这道题你构造出的序列中可以有重复元素，而且对于$[1, 1]$，有$3$个非空子序列——$[1],[1],[1,1]$

看到这里会做了的可以回去了，不会的请继续往下看。。。

## 【思路】
构造题，找构造方法。

这道题具体思想其实就是**让后面加上来的子序列中的数不会影响到前面的**。

这简单，加一个$d$就行了，就可以形成新的一组。（因为当前序列中最大值加$d$一定不能与先前的任意一个数出现在同一序列中）。

下面把你的子序列拆分成很多互不干扰的组，每一组的**子序列个数和显然就是总的子序列个数和。**(对于互不干扰上文已有解释）

然后通过每一组进行一个构造看看，要找出一个规律。

由于每一个有$n$个元素的组有$2^n-1$种非空子序列（由于是同一组的，一定是合法的），考虑尽可能使得这一组的合法子序列数变为$2^n$，就可以对于$x$进行**二进制拆分**做了。

到这里已经基本做完了，想挑战自己的同学可以停下了。下面介绍使得$2^n-1$变为$2^n$的解法。

很简单，在这一组中加入一个$a_{max}+d$，然后让下一组的开头由$a_{max}+d$变为$a_{max}+2d$。

还是互不干扰的，并且对于每一组**恰好加上了一个非空子序列个数为$1$的一组。**

然后就做完了，对于$x$进行二进制拆分，可以发现最多拆成$log_2x$个，反正在$30$左右。也就是按刚才的解法顶多加到$60d$的数据，不会爆炸。

## 【代码】
`想抄代码的，我劝你善良。`
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;
LL x, d, base = 1, cur = 1;
vector <LL> ans;
int main()
{
	cin >> x >> d;
	while(x)
	{
		if(x & 1)
		{
			for (register int i = 1;i <= base - 1;i ++)
			{
				ans.push_back(cur);
			}
			cur += d;
			ans.push_back(cur);
			cur += d;
		}
		x >>= 1;
		base ++;
	}
	printf("%lld\n", (LL)ans.size());
	for (register int i = 0;i < ans.size();i ++)
	{
		printf("%lld ", ans[i]);
	}
}
```