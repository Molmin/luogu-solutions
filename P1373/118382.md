# P1373

### 传送门

题目$\rightarrow$[戳我](https://www.luogu.org/problem/P1373)

blog$\rightarrow$[戳我](https://www.luogu.org/blog/oneJURUO/p1373-xiao-a-hu-uim-zhi-tai-tao-li-ti-xie)
***
### 题意

背景挺长的，这里简述一下题意:

```
在n*m的矩阵中有若干个数，求出满足以下条件的路径数：
1.从起点到终点只能向右或向下走
2.从起点开始，第奇数个碰到的数字的和与第偶数个碰到的数
  字之和在模一个数的意义下相等
```
***
### 算法

#### 算法1：

考虑直接求解，枚举起点n*m，枚举终点n*m，枚举路径$2^{\frac{m+n}{2}}$，最终统计有多少条路径满足题意

而利用DP，可以优化路径

其中奇数个碰到的数加入集合1``即sum1+=x``

偶数个碰到的数加入集合2``即sum2+=x``

最终统计在 **模(k+1)** 的意义下同余

**注意是k+1，不清楚的同学可以再看看题意**

记dp[i][j][x][y][sum1][sum2][sta]为以(i,j)为起点，走到(x,y)处时差值为t，状态为sta的方案数(其中sta=0表示最后一步是奇数步，不能作为答案；sta=1表示是偶数步，可以作为答案)

${\forall}i,j,x,y,k,sum1,sum2,sta$，有``dp[i][j][x][y][(sum1?d[x][y])%t][(sum2??d[x][y])%t][sta]=dp[i][j][x-1][y][k][sta^1]+dp[i][j][x][y-1][k][sta^1]``，而``dp[i][j][x][y][d[i][i]][0][0]``初始化为1，其中t指的是题目中的k+1，``d[i][j]``代表第i行第j列的数字的值

当sta=0时，``?``处为‘+’,``??``处不加

当sta=1时，``??``处为‘-’，``?``处不加

这时候不要忘了取模以及对负数的处理

时间复杂度$O(n^2*m^2*k^2)$，预计得分20

#### 算法2：

考虑优化算法1

由于题目中说可以从任意处开始，而我们关注的只是终点时的状态，所以可以省去起点一维

用``dp[x][y][sum1][sum2][sta]``来进行转移

除了省去了i、j，转移方程同上

时间复杂度$O(n*m*k^2)$，预计得分95

#### 算法3：

顺着2的思路，我们注意到，题目只关心sum1与sum2的差值

在统计时，记``cha=sum1-sum2``(别忘了取模，由于同余性质，是可以随便取模的！)

当sum1中加入元素x，cha+=x

当sum2中加入元素x，cha-=x

上面两个加减应该是可以互换位置的，这么做就优化掉了一维k~~尽管它很小~~

在最后我们重新整理一下DP转移方程:

```cpp
dp[x][y][(k+d[x][y])%t][0]+=dp[x-1][y][k][1]
dp[x][y][(k+d[x][y])%t][0]+=dp[x][y-1][k][1]
dp[x][y][(k-d[x][y])%t][1]+=dp[x-1][y][k][0]
dp[x][y][(k-d[x][y])%t][1]+=dp[x][y-1][k][0]
```

至于负数怎么处理，方程中没有给出，读者不妨思考一下
~~读者自证不难~~

所有``dp[x][y][d[x][y]%t][0]``初始化为1，答案为$\sum_{x=1}^n{\sum_{y=1}^m{dp[x][y][0][1]}}$

时间复杂度$O(n*m*k)$,预计得分100
***
### 代码
```cpp
#include <cstdio>
#include <cstdlib>
#include <algorithm>
#define N 801
#define MOD 1000000007
#define rnt register int
using namespace std;
int n,m,t,x,ans,f[N][N][16][2];
signed main(){
	scanf("%d%d%d",&n,&m,&t);t=-~t;
	for(rnt i=1;i<=n;i=-~i) for(rnt j=1;j<=m;j=-~j){
		scanf("%d",&x);
		f[i][j][x%t][0]=1;
		for(rnt k=0;k<t;k=-~k){
			if(i!=1){
				f[i][j][((k-x)%t+t)%t][1]+=f[i-1][j][k][0];
				f[i][j][((k-x)%t+t)%t][1]%=MOD;
				f[i][j][((k+x)%t+t)%t][0]+=f[i-1][j][k][1];
				f[i][j][((k+x)%t+t)%t][0]%=MOD;
			}
			if(j!=1){
				f[i][j][((k-x)%t+t)%t][1]+=f[i][j-1][k][0];
				f[i][j][((k-x)%t+t)%t][1]%=MOD;
				f[i][j][((k+x)%t+t)%t][0]+=f[i][j-1][k][1];
				f[i][j][((k+x)%t+t)%t][0]%=MOD;
			}
		}
		ans=(ans+f[i][j][0][1])%MOD;
	}
	return printf("%d",ans),0;
}
```

### 写在后面

你以为这就完了？

当我终于调出了正确代码时，自信提交

80分

为神马？

在这里友情提醒各位，这道题卡常，容易MLE以及TLE（为甚我会T？？？）

改正方法

1.数组开小：dp[801][801][16][2]

2.**别开long long！！！**
***
### 看完可以留个赞证明你来过