[传送门](https://www.luogu.com.cn/problem/P8674)

这一题就是从一个多源多点最短路问题。因为它求的是从 $n$ 个点到 $n$ 个点的最优策略。

它的边连的情况有两种，第一种是从点 $i$ 到点 $i+1$，第二种是从点 $i$ 到点 $i+k$，每一条边的权值都是 $1$。

但这题不管是从什么时间开始按，它的结果都是一样的。意思就是如果你从时间 $1$ 开始调，调到时间 $11$ 的最优次数，是跟从时间 $5$ 开始调，调到时间 $15$ 的最优次数一样。

最优次数一样，这很好证明。我们假设要从时间 $a$ 到时间 $b$，需要从 $a$ 往后调 $b-a$ 分钟。那么现在我们让 $a$ 和 $b$ 同时减去 $c$，就变成从时间 $a-c$ 调到时间 $b-c$，那么你就要往后调 $(b-c)-(a-c)$，也就是 $b-a$。我们会发现从时间 $a$ 到 $b$ 所需的时间跟 $a-c$ 到 $b-c$ 相等，那么所需往后调的时间相等，执行的最优策略也一定会相等。

所以我们就可以把这题的多源多点问题改为单源多点问题，也就是从 $0$ 出发的单源最短路径（其实你爱从几出发就从几出发，反正刚才我们已经证了从几点开始进行的单源最短路径最优策略都一样）。

不过这题可以不用最短路的算法，只需要用 bfs 就行了。因为这题每条边的权值都是 $1$，是相同的，所以可以使用 bfs。但如果一个图每条边权值不同，那么你就只能用最短路算法，否则你无法保证此时它是最优解。

# CODE:
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,k,dis[100010],ans=0;
inline void bfs()
{
	queue<int> q[2];
	q[0].push(0),q[1].push(0);
	while(!q[0].empty())
	{
		int x=q[0].front(),s=q[1].front();
		q[0].pop(),q[1].pop();
		if(dis[x]) continue;
		dis[x]=s;
		q[0].push((x+1)%n),q[1].push(s+1);
		q[0].push((x+k)%n),q[1].push(s+1);
	}
}
int main()
{
	scanf("%d%d",&n,&k);
	bfs();
	for(register int i=1;i<=n-1;i++) ans=max(ans,dis[i]);
	printf("%d",ans);
	return 0;
}
```