## 题解
首先可以发现题目就是在trie树上博弈，先把trie树建出来，我们就可以根据它来判断先手必胜还是必败：只要这个节点的儿子全都是先手必败，这个节点就是先手必胜，叶子节点为先手必败。

但是我们很快就会发现这样还是有问题，因为它是有多轮的，现在输了不代表最终会输，可能还有要让自己故意失败来掌控主动权的情况，所以我们还要求出先手能不能让自己故意失败（在后手干扰下），和求必胜差不多，叶子节点设为可以故意失败。

最后考虑先手在什么条件下可以保证最后胜利。由于每一局的初始条件只有先后手不同，所以我们考虑最后一局最开始的先手怎样保证胜利。

首先如果每局可以先手必胜，那么后手肯定会干扰先手获得最后一局的先手，那么此时后手会在第二局开始尝试故意失败保持主动权，最后获得先机，但是先手如果想占据先机也需要这样，所以第一种情况：如果一局先手可以决定自己的胜败，那么最后先手胜利。

如果先手只能保证自己胜利，那么如果局数为奇数先手胜利，否则后手胜利。因为彼此作为后手是都可以决定是否获得下一局主动权，所以由局数决定。

如果先手只能决定失败，后手胜利。因为后手可以让它一直失败，直到结束。

如果先手无法保证自己胜利还是失败，那么后手一定胜利。因为它完全掌握生杀大权，一直保持主动。
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+5;
int n,k,cnt,son[N][26];
bool f[N][2];
void add(string s)
{
	int now=0;
	for(int i=0;i<(int)s.size();i++)
	{
		int x=s[i]-'a';
		if(!son[now][x]) son[now][x]=++cnt;
		now=son[now][x];
	}
}
void dfs(int x)
{
	f[x][0]=0;f[x][1]=0;
	int s=0;
	for(int i=0;i<26;i++)
	{
		if(!son[x][i]) continue;
		dfs(son[x][i]);s++;
		if(f[son[x][i]][1]==0) f[x][1]=1;
		if(f[son[x][i]][0]==0) f[x][0]=1;
	}
	if(!s) f[x][0]=1;
}
int main()
{
	scanf("%d%d",&n,&k);
	for(int i=1;i<=n;i++)
	{
		string s;cin>>s;
		add(s);
	}
	dfs(0);
	if(f[0][1] && (f[0][0] || k&1)) cout<<"First"<<endl;
	else cout<<"Second"<<endl;
	return 0;
}

```
