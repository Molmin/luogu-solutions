# 题目翻译

ABC146F 双六

【题目描述】

高桥君在玩双六棋，棋盘格由用 $0$ 到 $N$ 编号的共 $N+1$ 个格子构成。每一回合，高桥君会扔一个点数 $1$ 到 $M$ 的骰子。如果高桥君当前在第 $i$ 格，骰子扔出 $k$ 点，高桥君就前进到第 $i+k$ 格。 如果此时 $i+k > N$ ，高桥君立刻输掉。另外，棋盘上还有若干个“GameOver格”，如果高桥停在这些格子，也立刻输掉游戏。

假设高桥君可以自由控制骰子的点数，那么他从 $0$ 号格子出发，到达 $N$ 号格子，最短需要多少回合？输出用最短回合到达 $N$ 格时，每回合骰子的点数组成的序列；如果无法到达 $N$ 号格子，输出-1。

【输入格式】

第1行，两个正整数 $N,M$ 

第2行，一个长为 $N+1$ 的字符串 $S$ 。 $S_i=0$ 表示第 $i$ 格是一个普通格子； $S_i=1$ 表示第 $i$ 格是一个GameOver格。

【输出格式】

输出用最短回合到达 $N$ 格时，每回合骰子的点数组成的序列，若有多种序列回合数都是最短，输出其中字典序最小的。

如果无法到达 $N$ 号格子，输出-1。

【输入样例\#1】

```
9 3
0001000100
```

【输出样例\#1】

```
1 3 2 3
```

【样例\#1说明】

按 $1,3,2,3$ 的顺序扔出骰子的点数，高桥君会经过第 $1,4,6$ 格最终到达第 $9$ 格。

无法在 $3$ 次以内到达第 $9$ 格。 $1,3,2,3$ 是所有 $4$ 次到达第 $9$ 格的点数序列中，字典序最小的。

【数据说明】

 $1 \le N \le 10^5$ 

 $1 \le M \le 10^5$ 

 $S$ 长度为 $N+1$ ，只由字符'0'和'1'组成，保证 $S_0=0$ ， $S_N=0$ 。

# 题目解析

如果 $S$ 中存在连续的'1'组成的长度大于等于 $M$ 的区间，答案显然是-1。如果不存在，那么一定有路径。

我们将移动关系看成一个图，从第 $i$ 点到第 $i+1,i+2,\cdots,i+M$ 连边。问题变成求终点 $N$ 到其他各点最短路问题。因为边很多，直接用单源最短路算法会超时。记 $f[x]$ 为“从点 $x$ 出发到点 $N$ 的最短路长度”，那么
 $$f[x]=\min\{f[x+1],f[x+2],\cdots,f[x+M]\}+1$$
利用可以求区间最小值的数据结构（比如单调队列）就可以算出所有 $f$ 。（对于Gameover点或是超过 $N$ 的点， $f$ 的值设为无穷大）

# 另解

因为随着点编号 $x$ 增加， $f[x]$ 不会增加，利用这个性质。对每个 $d$ 记录“到点 $N$ 最短路长为 $d$ 的点中，编号最小的点”。
设 $idx[d]$ 表示到点 $N$ 的最短路长为 $d$ 的点中，编号最小的点。然后我们从大到小遍历所有点去求最短路。

对每个点 $i$ ，求出它到 $N$ 的最短路方法为：在 $idx$ 数组中，找到“使得点 $i$ 能走到点 $idx[d]$ 的最小的 $d$ ”，则点 $i$ 到 $N$ 的最短路长为 $d+1$ 。然后 $idx[d+1]$ 就可以暂时赋值为 $i$ （这里说“暂时”是因为后边可能有更小的 $i$ 会覆盖掉 $idx[d+1]$ ）。因为随着 $i$ 的减小，这个最小的 $d$ 不会减小，所以可以用尺取法。

求出所有最短路后，从点 $0$ 开始，每次移动到最短路减少的点中编号最小的点，就可以得到字典序最小的序列。

# 代码
```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
#include<cmath>
#include<string>
#include<algorithm>
#include<vector>
#include<queue>
#include<map>
using namespace std;
typedef long long LL;
const int MR=1e5+10;
int n,m;
string s;
int idx[MR];
//idx[d]表示到点n的最短路长为d的点中，编号最小的点。
int main(){
    cin>>n>>m;
    cin>>s;
    memset(idx,-1,sizeof(idx));
    idx[0]=n;
    int d=0;
    for(int i=n-1;i>=0;i--){
        if(s[i]=='1') continue;
        for(;idx[d]!=-1;d++){
            //如果点i和idx[d]距离不超过m
            //到点n最短路长为d+1的点就暂定为i
            if(idx[d]-i<=m){
                idx[d+1]=i;
                break;
            }
        }
        //如果到这里发现idx[d]==-1
        //说明上面for循环里idx[d]-i<=m不成立
        //那么说明点i和后面的点距离超过m了
        if(idx[d]==-1){
            printf("-1\n");
            return 0;
        }
    }
    //最后倒着输出每步的间隔
    for(int k=d;k>=0;k--){
        printf("%d ",idx[k]-idx[k+1]);
    }
    printf("\n");

    return 0;
}

```
