很显然，这个题目是一个搜索，我们可以用i，j，k来唯一标识它的状态，i表示行，j表示列，k表示方向（自己定义即可），对于每一个状态，有5种转移方式（左转，右转，前1，前2，前3），而这5种转移是等价的（均耗费时间1），因此可以很好的用广度优先搜索来解决（广搜是基于路径相等的一种搜索，在这里它搜索的不再是点，而是加上方向共同表示的状态），由于边权均为1 ，所以先搜到的状态一定是时间最少的，它不用再入队列。而对于不等价的情况（转移时时间不都是1），或是有其他转换的更复杂的情况，搜索是无法解决的，这里主要讲一下图的构建。   

一个状态可以向左转，向右转，进1,2,3，所以把每个状态与其可转移的状态连接，边权赋为所需时间， 

每一个状态即为图中的点，为了处理简便，我们用一个单独的数代表i，j，k，这里可以用放缩，即定义 

s=x\*i+y\*j+k，做到可以唯一标识每一个状态； 特别注意，这是一个有向图，你不能倒着走 时间复杂度：50\*50\*4 共10000个状态，每个点最多5条边，边数为50000，SPFA可以承受！ 

注意初始化，不能达到的点不再处理！
