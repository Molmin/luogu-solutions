# 细节广搜！

这道广搜题是一道有关图的遍历的题，套路都懂，加个队列，然后把位置一个一个塞进去；但又有许多不同的地方：

1. 机器人的中心在格点上，且有宽度，而障碍却是在格子上；对于这个问题可以将其转化，将其右上角当成机器人的位置加入队列，只需要保证其它三个格子不是障碍即可；

2. 边界处理，因为机器人是有体积的，而我们是将其右上角当成其位置进行广搜，所以要保证(x>=1&&x<n&&y>=1&&y<m);

3. 机器人有方向，且转变方向也需要时间，而且还只能向左转和向右转，**所以转到后面需要的时间为2；** 那么我们在实现代码的时候就需要将转变方向当成一个状态加入队列中；**但记住要按时间顺序加入队列**（详细看代码）；

4. 机器人有三种前进方式，加上方向也就是有3*4=12种行走方式；


------------


- 所以可以这样初始化行走方式：
```cpp
int tx[4][3]={
	{-1,-2,-3},//北 
	{0,0,0},//西 
	{1,2,3},//南 
	{0,0,0},//东 
};
int ty[4][3]={//与上面对应；
	{0,0,0},
	{-1,-2,-3},
	{0,0,0},
	{1,2,3},
};
```


------------
-  那好，有了行走方式的初始化，接下来就需要一个数组来存储方向；与上面的数组对应，0——北；1——西；2——南；3——东；这个可以在队列数组中多加一维来实现，这样就可以通过对父对象方向的加减来实现方向的改变；这就是我设置的队列：
```cpp
int f[1000005][5];//0该队列元素是否是通过旋转得来；1记录x，2记录y，3记录方向,4记录时间；
```


------------
- 接下来就是主函数里的东西了；
```cpp
int main()
{
	cin>>n>>m;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)//读入地图； 
			cin>>map[i][j];
	char c;
	cin>>f[1][1]>>f[1][2];//起始位置 ； 
	map[f[1][1]][f[1][2]]=2;//注意：1为障碍物，2表示机器人来过； 
	cin>>fx>>fy;//终点； 
	cin>>c;
	if(f[1][1]==fx&&f[1][2]==fy){//这是一个坑点；当终点与起始位置重合的时候； 
		cout<<0;
		return 0;
	}
	if(c=='N') f[1][3]=0;//初始化方向； 
	if(c=='W') f[1][3]=1;
	if(c=='S') f[1][3]=2;
	if(c=='E') f[1][3]=3;
	bfs();		
	return 0;
}
```


------------
- 开始bfs,分为三部分：

1. 前进：
```
void bfs()
{
	int head=0,tail=1;
	while(head<tail){
		head++;
		int i=0;
		for(i=0;i<=2;i++){//3种移动情况；从前进1步开始； 
			int xx=f[head][1]+tx[f[head][3]][i];
			int yy=f[head][2]+ty[f[head][3]][i];
			if(map[xx+1][yy]==1||map[xx][yy+1]==1||map[xx+1][yy+1]==1||map[xx][yy]==1) break;//如果前进更小的步数都会遇到障碍，那大步数就不需要加入队列了；这样可以解决跳过障碍物的情况； 
			if(xx>=1&&xx<n&&yy>=1&&yy<m&&map[xx][yy]==0){//边界 
				map[xx][yy]=2;//设置为来过； 
				tail++;
				f[tail][1]=xx;
				f[tail][2]=yy;
				f[tail][3]=f[head][3];//方向不变； 
				f[tail][4]=f[head][4]+1;//时间+1； 
				if(xx==fx&&yy==fy){
					cout<<f[tail][4];//到达终点； 
					return;
				}
			}
		}

```


------------

2. 转向：
```cpp
if(f[head][0]!=2){//要遍历4个方向要旋转2次；但这样有个问题：这样每个方向都会加入队列2次，但如果不这样就需要一个3维数组来记录每个方向是否来过；因为数据比较小，所以这两种方法都可取；所以我选择了代码较简洁的一种； 
			for(int j=1;j<=3;j++){//旋转，当为1的时候向左转，为3的时候向右转； 
				if(j!=2){
					tail++;
					f[tail][1]=f[head][1];//位置不变； 
					f[tail][2]=f[head][2];
					f[tail][3]=(f[head][3]+j)%4;//改变方向； 
					f[tail][4]=f[head][4]+1;//时间+1； 
					f[tail][0]=f[head][0]+1;//标记此元素由旋转得来；当此元素是由旋转过一次的元素得来时，此元素将不再进行旋转；此时f[.][0]==2; 
			}
			}
		}
	}
```


------------

- 注:这有个我的错误示范，将另外3个方向一次性加入队列，向后的在时间上加2：
```cpp
if(!f[head][0]){
	for(int j=1;j<=3;j++){
		tail++;
		f[tail][1]=f[head][1]; 
		f[tail][2]=f[head][2];
		f[tail][3]=(f[head][3]+j)%4; 
		if(j==2) f[tail][4]=f[head][4]+2;//向后转时间加2；
		else f[tail][4]=f[head][4]+1; 
		f[tail][0]=f[head][0]+1;
	}
}
```
这样为什么不行呢.因为本题是找到时间上的最优解，所以元素加入队列时也要按照时间顺序来，这样在到达终点是时间上也会是最优的；如果按照上面这样来那可能步骤上是最优的，但时间上不一定最优；

------------

3. 最后无法到达：
```cpp
	cout<<-1;
}
```


------------
### 完整AC代码：
```cpp
#include<iostream>
using namespace std;
int tx[4][3]={
	{-1,-2,-3},//北 
	{0,0,0},//西 
	{1,2,3},//南 
	{0,0,0},//东 
};
int ty[4][3]={
	{0,0,0},
	{-1,-2,-3},
	{0,0,0},
	{1,2,3},
};
int n,m,fx,fy;
int map[55][55];
int f[1000005][5];//1记录x，2记录y，3记录方向,0指向父对象,4记录时间；
void bfs(); 
int main()
{
	cin>>n>>m;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)//读入地图； 
			cin>>map[i][j];
	char c;
	cin>>f[1][1]>>f[1][2];//起始位置 ； 
	map[f[1][1]][f[1][2]]=2;//注意：1为障碍物，2表示机器人来过； 
	cin>>fx>>fy;//终点； 
	cin>>c;
	if(f[1][1]==fx&&f[1][2]==fy){//这是一个坑点；当终点与起始位置重合的时候； 
		cout<<0;
		return 0;
	}
	if(c=='N') f[1][3]=0;//初始化方向； 
	if(c=='W') f[1][3]=1;
	if(c=='S') f[1][3]=2;
	if(c=='E') f[1][3]=3;
	bfs();		
	return 0;
}
void bfs()
{
	int head=0,tail=1;
	while(head<tail){
		head++;
		int i=0;
		for(i=0;i<=2;i++){//3种移动情况；从前进1步开始； 
			int xx=f[head][1]+tx[f[head][3]][i];
			int yy=f[head][2]+ty[f[head][3]][i];
			if(map[xx+1][yy]==1||map[xx][yy+1]==1||map[xx+1][yy+1]==1||map[xx][yy]==1) break;//如果前进更小的步数都会遇到障碍，那大步数就不需要加入队列了；这样可以解决跳过障碍物的情况； 
			if(xx>=1&&xx<n&&yy>=1&&yy<m&&map[xx][yy]==0){//边界 
				map[xx][yy]=2;//设置为来过； 
				tail++;
				f[tail][1]=xx;
				f[tail][2]=yy;
				f[tail][3]=f[head][3];//方向不变； 
				f[tail][4]=f[head][4]+1;//时间+1； 
				if(xx==fx&&yy==fy){
					cout<<f[tail][4];//到达终点； 
					return;
				}
			}
		}
		if(f[head][0]!=2){//要遍历4个方向要旋转2次；但这样有个问题：这样每个方向都会加入队列2次，但如果不这样就需要一个3维数组来记录每个方向是否来过；这两种方法都可取；所以我选择了代码较简洁的一种； 
			for(int j=1;j<=3;j++){//旋转，当为1的时候向左转，为3的时候向右转； 
				if(j!=2){
					tail++;
					f[tail][1]=f[head][1];//位置不变； 
					f[tail][2]=f[head][2];
					f[tail][3]=(f[head][3]+j)%4;//改变方向； 
					f[tail][4]=f[head][4]+1;//时间+1； 
					f[tail][0]=f[head][0]+1;//标记此元素由旋转得来；当此元素是由旋转过一次的元素得来时，此元素将不再进行旋转；此时f[.][0]==2; 
			}
			}
		}
	}
	cout<<-1;//队列为空了，无法抵达；
}
```


------------
见本题代码思路与其他题解不同，故心血来潮发个题解表达一下自己激动的内心（~~啊哈~~），顺便分享一下思路；

本蒟蒻初学编程，写的不好还请见谅；