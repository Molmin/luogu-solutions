### [P2620 虫洞](https://www.luogu.org/problem/P2620)
考试的题目偶然发现在洛谷上有，还（曾经）是一道黑题（~~纪念已死黑题~~）（~~老师真邪恶~~），在考场上只刚了这一道题，然鹅最后总分10分（机房暴零人数最多的一次考试），作为钻研了这道题目的蒟蒻，在自认为搞懂的情况下就赶快来到洛谷~~水经验~~写题解来造福大众辣233



------------
### 主要算法
 离散化+建图+最短路
#### 什么是离散化（DALAO请继续向下一层走）
通俗点来说，就是把不改变数据相对大小的前提下对数据进行相应的缩小，把无限空间的个体映射到有限空间里去（摘自百度），本题解使用了STL算法离散化(其实就是排序与去重)，想深入了解的童鞋[可以来这康康](https://baike.baidu.com/item/%E7%A6%BB%E6%95%A3%E5%8C%96/10501557)



------------
### 题目分析

~~考场上的思想是贪心+DP，然后想着这题真水，后来发现W可达到10^9，然后便试图各种优化，结果后来发现和正解没挨上边qwq~~

- W<=10^9，如此大的数据我们自然不能正常的拿数组存点，所以我们需要离散化这个好东西，因为普通的点我们其实可以不那么重视，重要的只有起点终点和虫洞的入口和出口所以我们只要考虑它们，将他们存入数组，排序后去重，这样我们就可以为建图作准备

- 注意！题目中有没说明的条件（实测得出），即没有任何一个虫洞的入口和出口会在终点后面，所以我们可以放心排序+去重

- 去完重后就是核心的存边，首先同一虫洞的起点到终点距离为0，在用有一点点贪心思想的方法存边（详细解释请见标程）

- ~~因为数据好像有点水，所以~~我们就可以愉快的floyd啦

- 代码里还有点玄学，不过都有超详细的注释
------------
### 代码实现
呜呜呜，这个辛辛苦苦理解了好久呢，可能这代码的注释是我写过代码中最多的

```cpp
#include<bits/stdc++.h>
using namespace std; 
int l[100],c;//l存边,c待用 
int x[50],y[50];//x存虫洞入口，y存出口 
int d[100][100];//冒充邻接矩阵存边233 
int w,s,p;//待用 
set<int>se;//用于存虫洞起点。作用：便于查询(然鹅我用的是map,好像还更方便) 
int F(int b,int e)//核心代码:存边 
{
	if(b==e)//若起点就是终点,自然就返回0 
		return 0;
	if(se.count(b))//若起点有虫洞,直接返回 
		return 0x3fffffff;
	int f=e;
	for(int i=0;i<p;i++)//枚举虫洞 
	{
		if(b<x[i]&&x[i]<f&&(x[i]-b)%s==0)
			f=x[i];//找如果不停按最大值(s)走的话第一个遇见的虫洞入口的位置 
	}
	while(f!=e&&se.count(f))//如果按最大值s走会有虫洞 
		f--;//委曲求全233  也就是把终点倒退至无虫洞处   这便是set的妙用 
	if(f==b)//如果f就是b,就到不了 
		return 0x3fffffff;
	return (f-b+s-1)/s+F(f,e);//正常的计算(递归),不知道是不是二分(雾)
	//有向上取整的技巧 
	//assert(0);
	//assert的作用是先计算表达式(括号里的东西)
	//若值为0(假)则终止运行  (好像是更方便调试)
}
int Q(int x)//找出虫洞的起点or终点(x)在排完序后的l的位置 
{
	return lower_bound(l,l+c,x)-l;
	//求出不降子序列中第一个>=x的数在l中的位置 
	//lower_bound的复杂度为O(logn) 
	//如果找到返回找到元素的地址,否则返回l+c的地址
}
int main()
{
	//freopen("wormhole.in","r",stdin);freopen("wormhole.out","w",stdout);
	while(scanf("%d %d %d",&w,&s,&p),w)//简写+输入 
	{
		se.clear();//清空set中的元素 
		c=0;//
		for(int i=0;i<p;i++)//输入虫洞 
		{
			scanf("%d %d",x+i,y+i),se.insert(x[i]);//指针操作,将有虫洞起点的点放入集合中 
			l[c++]=x[i],l[c++]=y[i];//”c++“会执行两次 
		}
		l[c++]=0,l[c++]=w;//确保排序后起点是0 
		sort(l,l+c);//排序下，难道不会打乱吗qwq(蒟蒻思想)     然而实际上是便于下面的unique元素去重233
		c=unique(l,l+c)-l;//更新后的的c是去重后的数组长度 
		/*unique:STL中的常用函数，功能是元素去重。
		即”删除”序列中所有相邻的重复元素(只保留一个)。		
		此处的删除，并不是真的删除，而是指重复元素的位置被不重复的元素给占领了。 
		由于它”删除”的是相邻的重复元素，所以在使用unique函数之前，一般都会将目标序列进行排序。(载录)*/
		memset(d,0x3f,sizeof d);//初始化d数组至无穷大 
		for(int i=0;i<p;i++)
			d[Q(x[i])][Q(y[i])]=0;
			//传入虫洞的起点与终点x[i],y[i]; 
			//找出虫洞的起点or终点在l中的位置后，用二维数组d标记位置(即在l中的下标) 
		for(int i=0;i<c;i++)// 
			for(int j=i+1;j<c;j++)
			//c=虫洞数目+2(起点与终点)
				d[i][j]=min(d[i][j],F(l[i],l[j]));//存边 
		for(int k=0;k<c;k++)//floyd经典最短路算法 
			for(int i=0;i<c;i++)
				for(int j=0;j<c;j++)
					d[i][j]=min(d[i][j],d[i][k]+d[k][j]);
		printf("%d\n",d[0][c-1]);
	}
	return 0;
}
```


------------

DALAO们多多关照呀QAQ