一道非常有水平的黄题。

首先，理解题意。题目的意思是要求找出数列中有多少个数不能被数列中其他数整除。对于一个数来说，他的因数一定都小于等于它，所以我们想到对数列进行排序。

接下来，对于每一个数，都将它的倍数标记一下，思路很像筛法。如果当前这个数被标记过，那么它一定不符合要求。此时它的倍数也肯定已经标记过，就没有必要再标记了。最后需要注意，如果 $a_i$ 没有被标记过，就要检查一下 $a_{i+1}$ 是否和 $a_i$ 相等，如果相等，那么 $a_i$ 就不符合要求，不计入答案。

贴上代码：

```cpp
#include<iostream>
#include<algorithm>
using namespace std;
int n,a[200010];
int vis[1000010],ans;
int main(){
	cin>>n;
	for(int i=1;i<=n;i++) cin>>a[i];
	sort(a+1,a+n+1);//排序
	for(int i=1;i<=n;i++)
		if(!vis[a[i]]){//如果没有被标记过
			if(a[i]!=a[i+1]) ans++;//符合要求，累计答案
			for(int j=1;j*a[i]<=1e6;j++) vis[j*a[i]]=1;//标记，最大到1e6就可以
		}
	cout<<ans;
}
```
若有疏漏、不详之处，恳请各位大佬指点。