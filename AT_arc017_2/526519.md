题目翻译过来很简洁明了，就是问你长度为 k 的上升子序列的个数。

一开始我想着直接暴力枚举，每一个点都开始一个一个找，但是我觉得会超时，所以有了一个把所有数都只遍历一遍的方法：把数组从第二个数开始一个一个遍历，找到每一个上升子序列的长度，能组成的符合要求的答案数就是子序列长度减去 k 的值再加一。

知道了这些代码就很好实现了。

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[1000010],n,m,ans=1,sum;//a存放每一个数的值，ans存放上升的子序列长度，sum存放答案 
int main()
{
	cin>>n>>m;
	for(int i=1;i<=n;i++)cin>>a[i];
	for(int i=2;i<=n;i++)
	{
		if(a[i]>a[i-1])ans++; //只要是上升的序列就一直累加长度 
		else
		{
		  if(ans>=m)sum+=ans-m+1;//只要符合m的长度能得到的长度为m的答案数就是ans减去m再加一
		  ans=1;//重置一下ans 
		}
	}
	if(ans>=m)sum+=ans-m+1;//最后的末尾处理 
	cout<<sum<<endl;//输出 
	return 0;//好习惯 
}
```

题目里面用的 $ k $,我用的 $ m $ 可能看起来有点别扭。