### 找规律

------------

#### 分析：
- 像 111111 这样连续的 1 是稳定的；

- 像 000000 这样连续的 0 也是稳定的；

- 因为是求 $3$ 个数的中位数，所以连续的 $2$ 个连续的 0 或 1 相互影响，它们可以构成一个稳定的子串；

- 无论进行多少次操作稳定的子串都不会改变；

- 因此只有 0 和 1 交替出现时才会使原串不稳定。

------------


#### 规律：
- 0 和 1 交替出现的子串有两种情况：长度为奇数和长度为偶数；

- 对于长度为奇数的串 1010101 （长度为 $7$ ）进行操作：
  
> 1. 1010101 → 1101011
> 2. 1101011 → 1110111
> 3. 1110111 → 1111111

- $3$ 次操作后稳定。

- 对于长度为奇数的串 010101010 （长度为 $9$ ）进行操作：

> 1. 010101010 → 001010100
> 2. 001010100 → 000101000
> 3. 000101000 → 000010000
> 4. 000010000 → 000000000

- $4$ 次操作后稳定。

- 综上可以得出，一个长度（设为 $len$ ）为奇数的串，在进行 $\lfloor len \div 2 \rfloor $ 次操作后可以稳定（其中 $\lfloor x \rfloor$ 表示对 $x$ 向下取整）。稳定后的串的每一位都与原串起始位置或结束位置（0 和 1 交替奇数构成的串首尾相等）相等。

- 对于长度为偶数的串 101010 （长度为 $6$ ）进行操作：

> 1. 101010 → 110100
> 2. 110100 → 111000

- $2$ 次操作后稳定。

- 对于长度为偶数的串 01010101 （长度为 $8$ ）进行操作：

> 1. 01010101 → 00101011
> 2. 00101011 → 00010111
> 3. 00010111 → 00001111

- $3$ 次操作后稳定

- 综上可以得出，一个长度（设为 $len$ ）为偶数的串，在进行 $len \div 2 -1$ 次操作后可以稳定。稳定后的串的前半部分的每一位都与原串起始位置相等，后半部分的每一位都与原串结束位置相等。即设起始位置下标为 $x$ ，结束位置下标为 $y$ ，则 $b_x$ 至 $b_{(x+y)\div 2}$ 中每一位都等于 $a_1$ ， $b_{(x+y)\div 2 + 1}$ 至 $b_y$ 中每一位都等于 $a_y$ 。

- 对于所有的串，都可以将它进行分组，分为稳定部分和 0 和 1 交替出现的不稳定部分。

- 如 001010000101110101101010 可以分组为 0 01010 00 0101 1 10101 101010 ，然后在对每一组分别统计长度，计算次数并记录结果。最终让它稳定下来需要的操作次数就等于所有组的操作次数中最大的一个。

- 而对于所有的串都可以进行如此的分组，所以所有的串都可以在若干次操作后稳定

------------

#### 代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,tmp,Ans;
bool a[500001],ans[500001];
int main()
{
	scanf("%d",&n);
	for(register int i=1;i<=n;i++)
	{
		scanf("%d",&tmp);
		ans[i]=a[i]=tmp==0?0:1;
	}
	for(register int i=2;i<=n;i++)
	{
		if(a[i]^a[i-1])//相同出0，相异出1 
		{
			int len=1,bg=i-1;
			while(a[i]^a[i-1]&&i<=n)
			{
				len++;
				i++;
			}
			i--;//在最后一次while时，下一位已经不符合条件，所以i被多加了1
			if(len&1)//即len为奇数 
			{
				for(register int j=bg;j<=i;j++)
				{
					ans[j]=a[bg];
				}
				Ans=max(Ans,len/2);//统计答案 
			}
			else
			{
				for(register int j=bg;j<=(bg+i)/2;j++)
				{
					ans[j]=a[bg];
				}
				for(register int j=(bg+i)/2+1;j<=i;j++)//注意j的初始值要加1 
				{
					ans[j]=a[i];
				}
				Ans=max(Ans,len/2-1);//统计答案 
			}
		}
	}
	printf("%d\n",Ans);
	for(register int i=1;i<=n;i++)
	{
		printf("%d ",ans[i]?1:0); 
	}
	fclose(stdin);
	fclose(stdout);
	return 0;
}
```
