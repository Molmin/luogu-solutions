# 前言

**来了？是不是厌倦了匈牙利和网络流？不如用一下拟阵交？带你进入一个quan新的世界!**

暂时不给出证明，你可以打表证明，只给出结论（证明其实可以参考2018~~鸡~~训队论文），如果我还没有退役，我就会补充其他内容以及证明,可能有很多错误，看不懂的地方差不多就是我错了，欢迎指出。

其实你可以浏览一下前面的定义，直接跳到拟阵交，但是不建议，因为前置知识看看总是有好处的。

# 小学生都能看懂的拟阵入门

## 定义

给出一个二元组$M$,记做$(S,I)$，可以说$M=(S,I)$,我们把第一元S叫做基础集,为一个集合，第二元$I$叫做独立集的集合，也是一个集合，但是元素是S的子集，这些元素被叫做独立集,或者说$I\subseteq 2^S$($2^S$叫S的幂集，也就是S的所有子集组成的集合)，我们称这个二元组叫做子集系统，如果$I$满足一下两条性质

1. 遗传性：如果$A\in I,B\subseteq A\Rightarrow B\in I$
1. 交换性（或者叫做扩张性）:如果$A,B\in I,|A|<|B|,|B|$中**存在**一个元素$x$，满足$A\cup \{x\}\in I$

那么我们把这样的一个二元组叫做拟阵。

## 常见拟阵

### 均匀拟阵

定义：对于拟阵$M=(S,I)$,满足$|S|=n$,$I=\{x\in 2^S:|x|\leq k\}$,我们也可以把这样的拟阵记做$U_n^k$。

证明根据定义显然，例如$S=\{1,2,3,4\}$,显然$|S|=4$,把拟阵记做$U_4^2=\{S,I\}$,对于$I=\{\{\varnothing\},\{1\},\{2\},\{3\},\{1,2\},\{1,3\},\{2,3\}\}$

### 图拟阵

定义：对于拟阵$M=(S,I)$,其中$S$是无向图$G=(V,E)$的边集，$I$中的集合要满足在边集图中无环。

容易发现其实$I$中的一个集合，对应的边，在$G$中就是一棵生成森林，这与后面的最小生成树的算法正确性有关，注意$G$为有向图不成立。

### 匹配拟阵

定义:对于拟阵$M=(S,I)$,其中$S$是图$G=(V,E)$的点集，$I$中的集合要满足图**存在**一组匹配的点集包含他。

不要狭义的认为只有二分图才有匹配，任何图都有匹配，定义一样，只是图的类型变了。

## 基和环

### 基

定义：对于拟阵$M=(S,I)$,$I$中最大的独立集，我们把她叫做基，其实就对应图拟阵的生成树，其实拟阵推出的所有性质，都可以应用于生成树问题上。

根据生成树，意会接下来的几个性质

1. 一个拟阵的所有基大小相同。
1. 任意两个不同基$A,B$,对于任意$y\in A/B$，**存在**$z\in B/A$,满足$A-\{y\}+\{z\}$还是基，这个定理是有名字的，我们把它叫做基交换定理。
1. 任意一个基，加入任何一个不属于它的元素，得到的集合不是独立集，根据定义显然。
1. 根据拟阵所有的基，就可以生成所有的独立集了，根据定义易知。

### 环

定义：对于拟阵$M=(S,I)$,S中最小的非独立集（不需要我定义吧），我们把它叫做环，其实对应图中的**简单**环，看几个性质

1. 对于环$X,Y$，如果$X\subseteq Y$,则有$X=Y$，这个显然吧。
1. 对于不同的环$X,Y$，如果**存在**$e\in X\cap Y$,那么$X\cup Y-\{e\}$也存在一个环。
1. $A$是一个基，那么如果存在$e\notin A$,就有$A\cup \{e\}$中存在一个唯一的环，其实就是基环树。
1. 不是独立集的集合一定包含一个环
1. 任何一个独立集，都存在一个基包含它
1. 如果把拟阵中独立集的元素,只保留集合大小小于等于$k$的集合，那么这还是一个拟阵。
1. 环删掉任何一个他包含的元素，都会得到一个独立集。

## 秩函数

### 定义

对于拟阵$M=(S,I)$，我们把函数r叫做秩函数,定义域为包含于$S$的集合，他满足$r(U)=U$中包含的最大独立集大小。

其实还对应一个概念，叫做拟阵的秩，其实就是拟阵的最大独立集大小，也就是拟阵基的大小。

### 性质

1. 有界性：$r(U)\in[0,|U|]$
1. 单调性：$A\subseteq B,$有$r(A)\leq r(B)$，我也把它叫做包含递增
1. 次模性：$r(A)+r(B)\geq r(A\cap B)+r(A\cup B)$,这个要靠记了

### 用途

如果对于一个子集系统$M=(S,I)$，定义域为$S$的子集的一个函数$r$,$r(U)$为在$U$中包含的最大的在$I$中的集合,这个函数满足秩函数的三条性质，那么$M$为拟阵，这样我们就成功地代数化地定义了拟阵。

## 拟阵上的最优化问题

这个是一个大家很关注的点，经典问题是求一张无向图的最小生成树，对于拟阵$M=(S,I)$,给出$S$中的元素$x$的权值$w(x)$,求出$I$中的一个独立集，满足这个集合的元素的权值之和最大，我们给出如下算法流程

1. 按照$w$的权值给集合的元素从大到小排序
2. 从权值大到小选择元素，选到元素$x$，假设我们已经确定的要选的独立集为$A$,如果$A+\{x\}\in I$，则$x$加入$I$。

这样我们可以最终得到一个独立集$I$，它有以下性质

1. 一定是个基，图拟阵中对应一棵生成树
2. 权值之和最大，这就是我们最小生成树常用的结论正确来源之一

这些的证明可以使用数列数归，不赘诉了。

## 对偶拟阵

### 定义

对于拟阵$M=(S,I),$定义她的对偶拟阵为$M^*=(S,I^*)$,因为根据一个拟阵的基就可以得知她的独立集，我们可以这样定义$I^*$,对于$M$中的一个基$A$,$S/A$为$I^*$的一个基。

### 性质

1. 对偶拟阵还是个拟阵，没有注意到需要给出证明吧。
1. 秩函数$r^*(U)=|U|-r(S)+r(S/U)$

## 拟阵变换

### 删除

定义：对于拟阵$M=(S,I)$,定义拟阵$M$关于集合$Z$的删除拟阵为$M\setminus Z=(S\setminus Z,I\setminus Z)$，其中$I\setminus Z$为$I$只保留包含在$S\setminus Z$的独立集，$S\setminus Z$就是集合运算得到的集合，我可能对于集合运算的差集运算$\setminus /$不做区分，读者可以自行推导是什么意思，而拟阵中删除的运算符号一定唯一，接下来看就明白了。

显然拟阵的删除，还是一个拟阵，就相当于缩小了这个拟阵,秩函数除了定义域，其他的没发生改变。

### 收缩

定义：对于拟阵$M=(S,I),$定义拟阵$M$关于集合$Z$的收缩拟阵为$M/Z=(M^*\setminus Z)^*$。

这是一个难点，别被卡住，它的实际含义就是在$M$中你选了一个独立集$A$，但是它强制包含$Z$中的某一个最大独立集$B$，$A$除掉$B$的部分就是$M/Z$的独立集，从它的秩函数可以看出来$r'(U)=r(Z\cup U)-r(Z)$($r$是$M$的秩函数,$r'$是$M/Z$的秩函数)

### 极小元

定义：对于一个拟阵$M$，如果她进行了若干次删除或者收缩操作的得到一个拟阵$M'$，我们把$M'$叫做极小元。

### ~~前方高能~~

## 拟阵的交

~~介绍了这么多前置知识，终于到达我们最重要的部分。~~

### 闭合算子

定义：对于一个拟阵$M=(S,I)$,$A$的闭合算子为一个集合$cl(A)\subseteq S$,满足其中任意一个元素$x$,有$r(A)=r(A\cup \{x\})$

让我们根据几个性质来加深理解

1. 对于两个集合$A,B\subseteq S$,如果有$A\subseteq B$，我们有$cl(A)\subseteq cl(B)$,你可以利用秩函数的次模性给出证明。
1. 对于集合$A\subseteq S$,如果存在一个$x\in cl(A)$，那么我们有$cl(A)=cl(A\cup \{x\})$
1. 对于集合$A\subseteq S$,我们有$cl(A)=cl(cl(A))$
1. 如果集合$A$是基，那么有$cl(A)=S$，其实这还具有充要性
1. 如果集合$A$是环，对于$A$中的任意一个元素$x$来说，我们有$x\in cl(A-\{x\}),$也就是$cl(A)=cl(A-\{x\})$

其实根据以上性质，我们不难总结出，$cl(A)$其实就是一个极大集合，满足它并上任何一个不在其中的元素，都会改变它的秩函数的值，对于一个集合$A$，他并上任何一个其闭合算子中的一个元素，都不会改变其闭合算子。

### 强基交换定理

~~与基交换定理不同，他更强了~~

定义：对于两个不同的基$A,B$,对于**任意**一个元素$x\in A/B$,都**存在**一个元素$y\in B/A$，满足$A-\{x\}+\{y\}$是基，除此之外，$B-\{y\}+\{x\}$也是基。

这个证明好像很难，我看了一个小时才看懂，而且还没有掌握，其实越往后面学，证明越难。

### 拟阵交定义

定义：对于拟阵$M_1=(S,I_1),M_2=(S,I_2)$，注意她们的基础集相同，也就是第一元相同，定义她们的拟阵交为一个独立集$I$满足$I\in I_1\cap I_2$，~~其实字面意思，不用废话。~~

### 最小最大定理

定理：对于拟阵$M_1=(S,I_1),M_2=(S,I_2)$，秩函数分别为$r_1,r_2$，我们有$\max_{I\in I_1\cap I_2}|I|\leq min_{U\subseteq S}(r_1(U)+r_2(S/U))$，式子左边即是神秘的最大拟阵交,我们就可以得到最大拟阵交的上界，一般构造题中得到上界，就一定可以构造到，其实实际情况是取到了等号，我们就可以直接用这个定理，求出最大拟阵交，但可惜的是，它是np的。

~~宁静划破，暴雨将至~~

### 最大拟阵交的算法

必不可少的定义：

对于一个拟阵$M=(S,I)$,和一个独立集$A\in I$,我们定义$M$中关于$A$的交换图为$D_M(A)$,他是一个**无向**二分图，点为集合中的元素，是这样连边的，对于$A$的一个元素$x$,和$S/A$中的一个元素$y$，他们有边，当且仅当$A-\{x\}+\{y\}$是独立集。

一些路上可能用得着的性质：

1. 令$A,B$为拟阵$M$中的不同独立集，那么对于交换图$D_M(A)$,$A/B$和$B/A$**存在**完美匹配。
1. 令$A$是拟阵$M$中的独立集，$B$是一个与$A$不同的集合，如果在交换图$D_M(A),A/B,B/A$有**唯一**的完美匹配,那么$B$是一个独立集.

进一步定义：

对于拟阵$M_1=(S,I_1),M_2=(S,I_2)$，对于一个独立集$A$，我们定义$A$关于$M_1,M_2$的交换图为$D_{M_1,M_2}(A),$他是这样一张**有向**二分图，对于任意一个元素$x\in A$，任意一个元素$y\in S/A$，如果$A-\{x\}+\{y\}\in I_1$,则连有向边$(x,y)$，如果$A-\{x\}+\{y\}\in I_2$，则连有向边$(y,x)$。

终于开始了的算法流程

1. 初始化独立集$A$为空集，找出集合$X_1=\{x:x\notin A,\{x\}+A\in I_1\}$,$X_2=\{x:x\notin A,\{x\}+A\in I_2\}$。
1. 按照定义建好$D_{M_1,M_2}(A)$，找出一条从$X_1$到$X_2$的**最短路**,点集记为$P$,那么令$A=A\triangle P$($\triangle$叫做集合的对称差，$A\triangle B=A\cup B-A\cap B$)，重复执行步骤2,如果没找到就退出程序，得到的$A$为所求。
3. 除此之外，我们还可以从最后的图中找到一个集合$U=\{x:x\notin X_1,X_2,x\text{出发可以到达}X_2\},$这就是最大最小定理，取到最小值的那个集合$U$。

时间复杂度：$O(r^2n)$($n$是集合大小，$r$是两个拟阵的秩的最大值)

### 关于二分图匹配

我们可以这样做，设拟阵$M_1=(S,I_1)$,其中$S$为二分图的边集，$I_1$中独立集要求是，这些边使得左部点度数小于等于1,同样地定义拟阵$M_2=(S,I_2)$,$I_2$满足右部点度数小于等于1,这样我们求拟阵$M_1,M_2$的交，就是我们所要的最大匹配。

话外音：当我听到这个消息的时候，我震惊加绝望了，就是我学了这么久的拟阵，结果求二分图竟然是$O(n^4)$，但是我想，这并不妨碍我们对她的研究和喜爱，~~毕竟，她还可以解决不少毒瘤题目~~,我认为OI中的时间复杂度优劣的比较，实在是有点太功利化，伤了一些优秀算法的感情，我认为我们不能以时间复杂度评判算法的好坏。

接下来给出代码实现，但是它在[uoj](http://uoj.ac/problem/78)上可以~~卡~~过,**我强烈建议luogu加弱本题数据，放拟阵交过，我们追求的不是算法的时间复杂度，而是追求算法的美丽**，~~另外别在uoj上把我hack了~~。

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#define il inline
#define ri register
#define Size 2050
using namespace std;
struct edge{
    int u,v;
}E[Size*Size];
struct point{
    int next,to;
}ar[50000000];
bool ma[Size*Size],L[Size],R[Size];
int head[Size*Size],at,X[Size*Size],xt,T[Size*Size],
    TL,TR,pre[Size*Size],dis[Size*Size],po[Size];
il void read(int&),link(int,int);
int main(){
    int n,m,e;
    read(n),read(m),read(e);
    for(int i(1);i<=e;++i)
	read(E[i].u),read(E[i].v);
    while(true){
	memset(L,0,n+1<<2),memset(R,0,n+1<<2);
	memset(dis,-1,e+1<<2),memset(pre,0,e+1<<2);
	memset(head,xt=TL=TR=at=0,e+1<<2);
	for(int i(1);i<=e;++i)
	    if(ma[i])L[E[i].u]=R[E[i].v]=1;
	for(int i(1);i<=e;++i)
	    if(!L[E[i].u]&&!R[E[i].v])
		ma[i]=L[E[i].u]=R[E[i].v]=1;
	for(int i(1);i<=e;++i){if(ma[i])continue;
	    if(!L[E[i].u])dis[T[++TR]=i]=0;
	    if(!R[E[i].v])X[++xt]=i;
	}for(int i(1),j;i<=e;++i)
	    if(ma[i]){
		L[E[i].u]=R[E[i].v]=0;
		for(j=1;j<=e;++j){
		    if(ma[j])continue;
		    if(!L[E[j].u])link(i,j);
		    if(!R[E[j].v])link(j,i);
		}L[E[i].u]=R[E[i].v]=1;
	    }
	while(TL++<TR)
	    for(int i(head[T[TL]]);i;i=ar[i].next){
		if(~dis[ar[i].to])continue;
		dis[ar[i].to]=dis[T[TL]]+1;
		pre[ar[i].to]=T[TL],T[++TR]=ar[i].to;
	    }int des(0);
	for(int i(1);i<=xt;++i)if(~dis[X[i]])if(!des||dis[X[i]]<dis[des])des=X[i];
	if(!des)break;while(des)(ma[des]^=1),des=pre[des];
    }int ans(0);for(int i(1);i<=e;++i)if(ma[i])++ans,po[E[i].u]=E[i].v;
    printf("%d\n",ans);for(int i(1);i<=n;++i)printf("%d ",po[i]);
    return 0;
}
il void link(int u,int v){
    ar[++at]={head[u],v},head[u]=at;
}
il void read(int&x){
    x^=x;ri char c;while(c=getchar(),c<'0'||c>'9');
    while(c>='0'&&c<='9')x=(x<<1)+(x<<3)+(c^48),c=getchar();
}


```

~~拟阵基本上你认识了，接下是一些扩展内容~~

夕辉洒满操场,秋千上裙摆飘飘，豆蔻年华的拟阵,与你，故事才刚刚开始。

### 带权拟阵交

~~这个证明我不会~~,定义$w(x)$为元素x的权值，我们等于求出拟阵$M_1,M_2$的交，使其包含的权值之和最大，只需要给我们求拟阵交做一些~~小小的~~修改，在二分图上设立点权$f(x)=\begin{cases}w(x)x\in A/S\\-w(x)x\in A\end{cases}$,$A$是所求拟阵交,找的路径$P$,第一关键字是路径的点权最大，然后才是长度最短。

# 尾声

~~哈哈，还是把你骗来学习拟阵了~~,其实学这个东西是会退役的，尤其是像我现在这个境遇，水平不高，时间又不多了，人生差不多到了尽头，但是又咋的了，寓形宇内复几时，遏不委心任去留?~~我没有背错吧~~？暴雨将至，更将砥砺前行，~~等着我退役的好消息吧~~。