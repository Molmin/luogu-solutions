~~看见官方题解用的是 $\text{SG}$ 函数大受震撼。~~

我用的是类似树上博弈 DP 的方法，由边界情况逐层扩展，最后得到全局结论。

先考虑边界情况（叶子节点）

当 $u$ 的儿子全部是叶子时：

1. $u$ 只有一个儿子，那么显然在以 $u$ 为根的子树内，先手必败；

2. $u$ 有两个儿子，那么先手则可以删去一个儿子选择剩下的连通块，从而转化为第一种情况。

以此类推，不难发现，当 $u$ 有奇数个儿子时，先手是必败的；而否则先手是**可胜** 。

这里的**可胜**是指**在当前以 $u$ 为根的子树内**，先手是必胜的。

因为在这种情况下，先手要获胜就必须得删儿子，而保留 $u$。而此时 $u$ 的父亲、祖先、兄弟都可能保留进了连通块，于是就给了后手反败为胜的可能。

而特别地，如果 $u$ 是整棵树的根（菊花图），那么这种**可胜**便能转化为**必胜**。

所以可以得出结论：**如果删当前的根能胜，就是必胜；否则如果删子树内的点（通过后面的情况可以发现这些点其实都是儿子）而获胜，就是可胜。**

有没有其他必胜的情况呢？

其实我们发现，只要到达某一点 $x$，其儿子中存在必败，那么 $x$ 就是必胜。

因为我们可以直接选择删掉 $x$ 而选择必败的儿子，这样后手就进入必败态，先手自然必胜，而此时我们就可以直接输出答案了。

那么可胜态如何向上转移呢？

先考虑只有一个可胜态儿子（为方便起见，我用最基本的可胜态结构来表示一个可胜态，即以下结构）。

![](https://s1.ax1x.com/2022/05/16/OhiiFO.png)

1. 只有一个可胜态儿子：

	这种情况与添加一个叶子节点无异，可胜 → 必败。

2. 有一个可胜儿子和一个叶子儿子：

	![](https://s1.ax1x.com/2022/05/16/OhiBhF.png)
    
	先手可直接删掉一个可胜儿子（$1$）而选择剩下的必败态（$\{u, v\}$），但由于删的不是 $u$ ，所以可胜 → 可胜。

	由上类比，我们可知到对于有一个可胜儿子和 $n$ 个叶子儿子时：当 $n$ 为奇数时 $u$ 可胜；否则 $u$ 必败。

3. 有两个可胜儿子：

	![](https://s1.ax1x.com/2022/05/16/OhFG4O.png)

	如果先手按照其中一个儿子的可胜策略删（比如删掉 $\text{leaf1}$），剩下的连通块中必定包含一个必败态（$\{1, \text{leaf2}\}$），不然这个儿子就不是可胜了。此时后手可以直接删掉它的父亲（$u$），留下必败态，先手必败。

	如果先手删掉可胜儿子（比如 $1$），那么留下的就是一个可胜态又接上一个叶子（$\{u, 2, \text{leaf3, leaf4}\}$），为必败态，那么先手就可获胜。可胜 → 可胜。

	如果先手删根（$u$），那么无论怎么选留给后手的都是特殊的可胜态，可转化为必胜态，先手必败。

	因此，有两个可胜儿子时，先手最优情况下为可胜。

	由上类比，我们知道对于有 $n$ 个可胜儿子时：当 $n$ 为奇数，先手必败；当 $n$ 为偶数时，先手可胜。
    
综合上述所有情况，我们可以归纳得出：

> 当一个节点有奇数个儿子时，该节点必败；

> 当一个节点有偶数个儿子时，该节点可胜；

> 当一个非根节点必败，全局必胜。

这么看来，我们可以将叶子节点定为可胜。

代码自然很简单了。

```cpp
const int N = 2e5 + 5, inf = 0x3f3f3f3f, P = 998244353;
int f[N];
int first[N], nex[N << 1], to[N << 1], num;
inline void Add(int u, int v)
{
	nex[++num] = first[u];
	first[u] = num;
	to[num] = v;
}
inline bool dfs(int u, int fa)
{
	int siz = 0;
	for (re int i = first[u]; i; i = nex[i])
	{
		int v = to[i];
		if (v == fa) continue;
		++siz;
		if (dfs(v, u)) return 1;
		if (f[v] == 0) {puts("Hifuu"); return 1;}
	}
	if (siz & 1) f[u] = 0;
	else f[u] = 1;
	return 0;
}
signed main()
{
	int T = read();
	while (T--)
	{
		int n = read();
		for (re int i = 1; i <= n; ++i) first[i] = 0;
		num = 0;
		for (re int i = 1; i < n; ++i)
		{
			int u = read(), v = read();
			Add(u, v), Add(v, u);
		}
		if (!dfs(1, 1)) puts(f[1] == 1 ? "Hifuu" : "Luna");
	}
	return 0;
}
```