~~（结论很简单可是证的我好累啊qwq）~~


------------

很显然这是一道博弈论。

我们先从简单的情况入手。

![](https://cdn.luogu.com.cn/upload/image_hosting/u07sxenz.png)

所以我们可以做出假设：

  当树上**存在**度数为偶数的点（下称偶点）时，先手必胜。

换一个说法就是：

  当树上**仅**存在奇点时，先手必败。

------------

### 下面是证明：

我们设计两个状态：状态 $A$ 表示树上全部为奇点，状态 $B$ 表示树上全部为偶点。

（ 1 ） 证明 $A$ 的后继状态**一定**为 $B$ ：

当删除一个点及与这个点相连的边后，由于该点为奇点，所以必然存在一条边与该点相连。删去边后，图中原先与之相连的点的度数 $-1$ ，由于先前所有的点都为奇点，所以在操作后，在剩余的若干连通块中，每块至少存在一个偶点。

（ 2 ） 证明 $B$ **至少存在一个**后继状态为 $A$ ：

由于偶点必然是是有限的，所以至少存在一颗以偶点为根的树，它的一棵子树中有且仅有奇点。（假设子树中仍有偶点，那么就指定这个点为根。由树的定义还可以知道，一棵树的叶子结点**不可能**为偶点。）

所以进行操作时只需要保留指定的根节点以及只有奇点的子树，此时根节点有且仅有一个儿子，也是奇点，我们又得到了状态 $A$ 。

那么为什么要将状态 $B$ 变为 $A$ 呢？

首先数据保证 $n>1$ ，所以你不可能一开始只拿到一个点然后~~然后暴毙~~。

如果对方给你了一个度数为 $0$ 的点，那么恭喜你，你赢了。

若不为 $0$ ，由于是偶点，你操作后~~只要你不傻~~保留的连通块所有点的度数仍会大于等于 $1$ ，不会失败。

故，假设成立。



------------

### Code:

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=5e5+10;
inline int read(){
	int x=0,w=1;
	char ch=getchar();
	for(;ch>'9'||ch<'0';ch=getchar()) if(ch=='-') w=-1;
	for(;ch<='9'&&ch>='0';ch=getchar()) x=(x<<1)+(x<<3)+(ch^48);
	return x*w;
} 
int t,n,cnt[N];
int main(){
	t=read();
	while(t--){
		n=read();bool flag=false;
		for(register int i=1;i<n;i++)
			cnt[read()]++,cnt[read()]++;
		for(register int i=1;i<=n;i++){
			if(!(cnt[i]&1)){
				flag=true;
				break;
			}
		}
		if(flag) puts("Hifuu");
		else puts("Luna");
		memset(cnt,0,sizeof(cnt));//记得清零！
	}
	return 0;
}
```

如有错误欢迎指正。

最后，秘封组好耶！