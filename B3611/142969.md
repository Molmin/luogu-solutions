第一眼看到这个题目时
### 传递闭包是啥？
看了一下题目，这不就是 **Floyd 弱化版**吗？


------------
## 接下来讲讲做法。

假设现在有三个点，$i$，$j$，$k$。如果我们给 $i$ 和 $k$ 连一条边，给 $k$ 和 $j$ 连一条边，显然，$i$ 和 $j$ 就**互相连通**了，我们就可以视为 $i$ 和 $j$ 之间也有一条边。这对结果没有影响。

如果再有一个 $u$ 点连 $i$ 点，我们就可以把 $i$ 点当成中转站，起到之前 $k$ 点的作用，把 $u$ 和 $j$，$u$ 和 $k$ 连接起来。**也就是说，通过一个中转点，就可以把一个点和中转点连接的所有其他点连接起来。**

## 然后是代码实现。

我们只需建立一个邻接表 $d_{i,j}$ 来存储 $i$，$j$ 是否连通，以及一个三重循环枚举中转点 $k$，以及 $i$，$j$。很容易就能得到转移方程（在这里，$d$ 存储的是 $1$（可连通），$0$（不可连通），所以 $min$ 是正确的）：

 $d_{i,j}=max(d_{i,j},min(d_{i,k},d_{k,j}))$ 

**注意，最外层循环必须枚举中转点。** 

至于为什么要先枚举 $k$，这里我就不提了，大家可以自行了解。

## 上代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int d[110][110],n;
int main(){
	cin>>n;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
			cin>>d[i][j];
	for(int k=1;k<=n;k++)
		for(int i=1;i<=n;i++)
			for(int j=1;j<=n;j++)
				d[i][j]=max(d[i][j],min(d[i][k],d[k][j]));
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++)
			cout<<d[i][j]<<" ";
		cout<<endl;
	}return 0;
}
```
