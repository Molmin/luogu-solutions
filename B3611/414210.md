## 前言

~~颓废着~~哎洛谷又有新模板题了！传送封包好高级的亚子！

（点击来一看 ？？？这不就是 `dfs` 吗
## 正文

### 做法一
对于每个点 $i$，我们从这个点开始深搜，给路径上的每个点打上标记，如果遇到已经搜过的点就退出。注意 $i$ 号的自己不能直接到达自己，必须通过别的点间接到达，一开始不能给 $i$ 自己打上标记。由于每个点最多被搜到一次，所以最坏复杂度为 $O(n^3)$（$O(nm)$,$m$ 为直接连边的条数)。

核心代码：
```cpp
void dfs(int x,int zz)
{
    ans[zz][x]=1;
    for(int i=1;i<=n;++i)
    {
        if(a[x][i]&&(!ans[zz][i]))
        dfs(i,zz);
    }
}
void get_ans()
{
    for(int i=1;i<=n;++i)
    {
        for(int j=1;j<=n;++j)
        {
            if(a[i][j])
            dfs(j,i);
        }
    }
}
```

### 做法二

我去网上搜了一下，发现还真有不同的做法。我们可以仿照 `Floyed` 最短路算法，写出以下代码：
```cpp
for(int k=1;k<=n;++k)
{
    for(int i=1;i<=n;++i)
    {
        for(int j=1;j<=n;++j)
        {
            if(a[i][k]&&a[k][j])
            a[i][j]=1;
        }
    }
}
```
这个算法的原理和 `Floyed` 最短路是一样的。复杂度稳定 $O(n^3)$。