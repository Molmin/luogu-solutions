首先，在题目中给出的每一组的两个人之间连边。设这些边为 1 类边。

其次，连上所有编号形如 $2x-1$ 和 $2x$ 的人之间的边。设这些边为 2 类边。

对新图跑二分图染色即可。

若能跑出一个结果，则结果的正确性显然。下面证明这个图一定是一个二分图。

首先，给出二分图的定义：对于一个二分图，能将点集分为两个集合，使得这两个集合内部的点没有连边。

根据这个定义，可以得到一个性质：二分图不存在长度为奇数的环。若没有这样的环，则它一定是一个二分图。

（每条边都是从一个集合走到另一个集合，只有走偶数次才可能回到同一个集合）

对于新图中的两个点，$2x-1$ 和 $2x$，假设在加上它们之间的边之前，它们之间就已经有路径了。

假设路径是从 $2x-1$ 到 $2x$ 的。

可以发现，它们都不可能再有向外的 2 类边了，所以路径的第一条边一定是 1 类边。

走到一个新点，因为一个点只可能和另一个点在同一组中，所以这个点不可能有向外的 1 类边了，所以路径的第二条边一定是 2 类边。

以此类推，这条路径中的边的类型一定形如：1 类，2 类，1 类，2 类 $\cdots$。

同时，一定是由一条 1 类边到达路径的终点 $2x$ 的。

所以，这条路径的长度为奇数，连上这条新边后形成一个长度为偶数的环。

所以，这个图中不存在长度为奇数的环，它是二分图。故问题一定有解，且这样做一定能解出一组解。

```cpp
#include<iostream>
#include<cstdio>
#include<vector>
using namespace std;
const int N=1e6+10;
int n,a[N],b[N],ans[N];
vector <int> e[N];
void dfs(int x,int y)
{
	ans[x]=y;
	for(int i=0;i<e[x].size();i++)
		if(!ans[e[x][i]]) dfs(e[x][i],1-y);
}
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
		int x,y;
		scanf("%d%d",&x,&y);
		a[i]=x,b[i]=y;
		e[x].push_back(y);
		e[y].push_back(x);
	}
	for(int i=1;i<=n*2;i+=2)
	{
		e[i].push_back(i+1);
		e[i+1].push_back(i);
	}
	for(int i=1;i<=n*2;i++)
		if(!ans[i]) dfs(i,0);
	for(int i=1;i<=n;i++)
		printf("%d %d\n",ans[a[i]]+1,ans[b[i]]+1);
	return 0;
}
```