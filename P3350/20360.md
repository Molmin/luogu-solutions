-  对于前20%的做法：直接暴力最短路(⊙o⊙)。

	复杂度 Qnmlog(nm)

- 对于中间的30%：矩形的短边不超过4，可以在长边上用线段树维护一个高为4的矩形内的最短路，询问时同时把询问矩形两边也更新进去。有点像SHOI2008 traffic。

	复杂度 Qlog(n)

- 对于100%的做法：由于这是一个矩形，根据套路，考虑分治。假设分治到当前矩形(u,d,l,r)，并且有一些询问，满足这些询问的最短路径都不会超出当前矩形的范围。我们按短边将这个矩形分成两部分（即尽量方正）。在这些询问中，要么答案是经过这条分界线的，要么不是。很显然，如果询问的两个点在分界线两侧，那一定属于前者。我们对于分界线上的每一个点，以该点为起点都做一遍关于当前矩形中的点的最短路，以它到两点的距离和更新每一个询问的答案。对于两个点都在分界线的同一侧的询问，答案的路径可能不一定经过分界线，那么就分治下去。

	由于每一个询问最多存在于log(nm)个矩形中所以关于询问的复杂度是Qlog(nm)的，分治最多log(nm)层，每层nmlog(nm),所以最终复杂度是 Qlog(nm)+nmlog2(nm)