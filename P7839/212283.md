首先简单讲一下特殊性质 Subtask 和小数据的过法：

- Subtask 1：爆搜可以过。
- 性质 A：不需要飞行点。
- 性质 B：考虑贪心策略，简单分类。

接着考虑一步步的优化。

首先每只夜雀如果要飞行，那么最优的策略一定是一次飞到高度大于 $t$ 的某颗树上，此后就无需再飞行了。而我们所需要考虑的重点在于：他们是否能够走到高度大于 $t$ 的某颗树上。

当然，在这过程中，有一些夜雀肯定是无法单凭走路到达目的地的，他们的活动范围被限制了，这个限制有什么意义呢？他们所能到达的范围内，如果有一个飞行点，那么他们就能够飞行到达目的地。

我们的目的显然是建立尽可能少的飞行点，那么如果一个飞行点能够供给给尽可能多的夜雀使用，是不是就更优呢？我们的飞行点需要供给给一类夜雀：他们既不能到达已经放置的飞行点，也不能到达符合要求的目的地。

因而具体的实现上可能还有所困难，我们已经可以开始着手准备了：预处理出每一个夜雀向左和向右可以到达的顶端。我们只要能够找到一个合理的顺序，一切就能迎刃而解，而从左往右是一个直观的解决方法。

那么我们考虑找到最靠左的一只符合上述条件的夜雀，在它往右所能到达的最远处的地方放一个飞行点。这样就可以尽可能扩展这一区间的贡献，然后将之后的夜雀进行判断——一旦找到另一只夜雀不能走到这个飞行点，就再按照同样的思想进行放置。这样的贪心策略是正确的，此处略去不证。

为体现主要过程，这里给出核心代码：

```cpp
//在读入和预处理之后：
	for(rint i=1;i<=m;++i){
		if(a[i]<=x){
			tmp=x-a[i];
			while(tmp+1<height[x+1]&&x<n)
				++tmp,++x;
			rig[i]=x;
		}else{
			tmp=0;x=a[i];
			while(tmp+1<height[x+1]&&x<n)
				++tmp,++x;
			rig[i]=x;
		}
	}
	for(rint i=m;i>0;--i){
		if(a[i]>=x){
			tmp=a[i]-x;
			while(tmp+1<height[x-1]&&x>1)
				++tmp,--x;
			lef[i]=x;
		}else{
			tmp=0;x=a[i];
			while(tmp+1<height[x-1]&&x>1)
				++tmp,--x;
			lef[i]=x;
		}
	}
	for(rint i=1;i<=m;++i)
		if(s[rig[i]]-s[lef[i]-1])
			vis[i]=1;
	int c=1;
	while(c<=m){
		if(!vis[c]){
			x=rig[c];tmp=c+1;
			while((lef[tmp]<=rig[c]||vis[tmp])&&tmp<=m)
				++tmp;
			c=tmp;++res;
		}else ++c;
	}
//之后分情况输出答案即可
```