$2020/1/30 $：

发现之前写的$ TLE $了，数据加强了？~~洛谷变慢了？~~

现在来改一下，再找几个剪枝。然后发现关键在$ endl$中，它太慢了，会刷新输入，我们用$'\n'$来代替




解释在注释上
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,a[8][8],l,b[8][8],s;
int dp[9];
void dfs(int x,int y)
{
	if(x>=2)//~~~~~~~~~~~~~~
	{
		if(dp[x-1]>s)//众所周知dp没有后效性，所以等到他之前的就没有后效性了 
		{
			return ;//新增剪枝，判断现在是不是比之前的最大值小，如果是就return 
    	}
    	else
    	{
    	    dp[x+1]=s;
		}
	}//~~~~~~~~~~~~~~~~~~
	
	int k=0;//判断是不是一个也放不了了 
	for(int i=x;i<=min(n,x+3);i++)//因为前面的都搜过一次了，所以接着后面搜。不加这个剪枝只有49分。。。 当然现在我也不知道有几分了 
	{
		//min的原因是：如果还取的话，x到min(x+3,n)行中 肯定还有取的 
		for(int o=1;o<=m;o++)
		{
			if(b[i][o]==0&&b[i-1][o]==0&&b[i-1][o-1]==0&&b[i-1][o+1]==0&&b[i][o-1]==0&&b[i][o+1]==0&&b[i+1][o-1]==0&&b[i+1][o]==0&&b[i+1][o+1]==0)//如果四周都没有被用 
			{
				k=1;//还有能搜的 
				s=s+a[i][o];//把数加上 
				b[i][o]=1;//标记 
				dfs(i,o);//接着搜 
				b[i][o]=0;//回溯 
				s=s-a[i][o];
			}
		}
	}
	if(k==0&&l<s)//取最大的 
	{
		l=s;
	}
}
int main()
{
	int t;
	cin>>t;
	while(t>0)//多组数据 
	{
		l=0;
		t--;
		cin>>n>>m;
		for(int i=1;i<=n;i++)
		{
			for(int o=1;o<=m;o++)
			{
				scanf("%d",&a[i][o]);
				b[i][o]=0;//输入+标记为没用 
			}
			dp[i]=-1;
		}
		dp[0]=-1;//初始化dp数组 
		dp[n+1]=-1;
		s=0;
		dfs(1,1);//爆搜 
		cout<<l<<"\n";//输出 
	}
}
```