### **拿到这道题，首先分析解题算法。**

如果使用贪心法，每次去最大值，那么可以发现有问题。因为每取一个数，相邻的数就不能再取，那么每次决策就会影响下次结果，从而导致贪心决策不能最优化。

动态规划也是如此，在动态规划中，每一个分步决策不能影响后续结果，所以此算法也排除。

那么再观察数据范围：

**对于100%的数据，N, M≤6,T≤20N,M≤6,T≤20。**

这是一个较小的范围，所以可以考虑暴力枚举，而对于一个图，以及一个变化的状态，**深度优先搜索（dfs）** 应该是一个比较适合的算法。



------------


### **再考虑每个数的状态。**

显然，对于一个数，有取与不取两种状态，状态改变取决于周围取数的变化。我们用 **mark[ i ][ j ]** 记录点 **( i , j )** 附近有几个数，若 **mark[ i ][ j ] ! = 0** 就代表不能取这个数。 

### **接下来上代码，具体部分具体分析**

```cpp
#include<bits/stdc++.h>//万能头文件 
using namespace std;
const int d[8][2]={1,0,-1,0,0,1,0,-1,1,1,-1,1,1,-1,-1,-1};//方向数组用来控制搜索时的方向 
int t,n,m,s[8][8],mark[8][8],ans,mx;
void dfs(int x,int y){//搜索函数，表示搜索点(x,y) 
	if(y==m+1){//当y到边界时，搜索下一行 
		dfs(x+1,1);
		return;
	}
	if(x==n+1){//当x到边界时，搜索结束，刷新最大值 
		mx=max(ans,mx);
		return;
	}
	
	dfs(x,y+1);// 不取此数的情况 
	
	if(mark[x][y]==0){ //取此数的情况（需保证此数周围没有取其他数，即mark[i][j]==0）
		ans+=s[x][y];
		for(int fx=0;fx<8;++fx){ //标记周围的数 
			++mark[x+d[fx][0]][y+d[fx][1]];
		}
		dfs(x,y+1);
		for(int fx=0;fx<8;++fx){ //回溯 
			--mark[x+d[fx][0]][y+d[fx][1]];
		}
		ans-=s[x][y];
	}
	
}
int main(){
	cin>>t; 
	while(t--){
		memset(s,0,sizeof(s));
		memset(mark,0,sizeof(mark));//在做每个数据前都要初始化数组 
		cin>>n>>m;
		for(int i=1;i<=n;++i){
			for(int j=1;j<=m;++j){
				cin>>s[i][j];
			}
		}
		mx=0;
		dfs(1,1);//从点(1,1)开始搜索 
		printf("%d\n",mx);//输出答案 
	}
	return 0;
}
```


------------


### **总结**

总体来说，这是一道比较简单的 **dfs** 题，主要需要确定算法和考虑标记状态，其他的就自然迎刃而解了。