### 解题思路
1.定义状态量:   

$dp[i][j]$,表示竖直放置的书厚度和为$(8-j)$时,也就是抽出j厚度和的书横放在上面,其余均竖直放置,考虑前$i$本书来放在上层所得到的上层书最小的长度和;成功转换成典型的01背包问题;    

2.状态转移:    
  
依次考虑每本书,有两种情况:   
  
  
第一种,这本书的厚度超过$j$,**$dp[i][j] = dp[i - 1][j]$**;  
  
  
第二种,这本书的厚度小于等于$j$,**$dp[i][j] = min(dp[i - 1][j] , dp[i - 1][j - t[i]]+w[i])$**; 
  
  
3.边界条件:$dp[i][0] = 0;dp[0][j] = max$ ; 

4.我们只需要找到:    

抽出j厚度和的书横放在上面所得到的上层书最小的长度和$dp[n][j]\leq$竖直放置的书厚度和$(8-j)$.遍历找出最小满足条件的竖直放置的书厚度和$(8-j)$即可; 
### 样例
对于第一个试例,进行测试  

| $dp[i][j]$ | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 |
| :----------- | :----------- | :----------- | :----------- | :----------- | :----------- | :----------- | :----------- | :----------- |
| 1 | 12 | max | max | max | max | max | max | max |
| 2 | 3 | 15 | max | max | max | max | max | max |
| 3 | 3 | 15 | 18 | 30 | max | max | max | max |
| 4 | 3 | 5 | 8 | 20 | 23 | 35 | max | max |
| 5 | 3 | 1 | 4 | 6 | 9 | 21 | 24 | 36 |
$dp[5][3]<5$ ,输出5;
```
#include<iostream>
#include<algorithm>
using namespace std;
int n;//书本数
int t[105],w[105];//厚度,宽度
int dp[105][205];//dp[i][j]考虑前i本书,抽出j厚度和的书放在上层
int all[105];//记录前i本书的厚度和
int main()
{
    cin>>n;
    int sum=0;//所有书的厚度和
    for(int i=1;i <= n;i++)
    {
        cin>>t[i]>>w[i];
        sum += t[i];
        all[i] = sum;
    }
    for(int i = 0;i < 105;i++)
    dp[i][0] = 0;
    for(int j = 1;j <= sum;j++)//拿出j厚度和的书放在上层
    {
        int i = 0;
        while(all[i] < j)
        {
            dp[i][j] =  1000005;//厚度和不够时,置为最大值
            i++;
        }
        for(;i <= n;i ++)
        {
            if(j < t[i])//这本书厚度超过允许的厚度和
            dp[i][j] = dp[i-1][j];
            else//没有超过 
            dp[i][j] = min(dp[i-1][j] , dp[i-1][j-t[i]]+w[i]);
        }
    }
    int i = sum;
    while(dp[n][i] > sum - i)//找到符合上层长度小于等于下层长度的条件
    {
        i--;
    }
    cout<<sum - i;
}
```