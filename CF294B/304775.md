[原题链接](https://www.luogu.com.cn/problem/CF294B)

刚做完一道背包题，来写一篇题解吧。

# 1、题目大意
给你 $n$ 本书和每本书的厚度与宽度，让你求一求书架最少要有多长。每本书有两种放的方法，立着插在那里与横着放在书的上面（如图）。

![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF294B/294454fb546e216dead52db8f9eb3345eef061e2.png)

请注意：每本书的厚度一定是 $1$ 或 $2$并且最多有 $100$ 本书。

# 2、算法理解

由于要求书架的最小长度，~~又因为算法标签上写着“背包”~~，我们可以用 [$01$ 背包](https://www.baidu.com/s?wd=01%E8%83%8C%E5%8C%85)来做（[这里](https://www.luogu.com.cn/problem/P1049)有一个减弱版），其中把每本书立着放和倒着放上面分别对应着选和不选。

显然，书架的最大长度不可能超过所有书的厚度之和（所有书都立着放），那我们就开一个变量 $sum$ 记录所有书的厚度和，把 $sum$ 当成背包的最大容量，把每一本书当成物品。这样，我们来做一次求最小的 $01$ 背包。这个 $01$ 背包的限制是上层放书的总宽度和不能大于下层书的厚度和（不然就掉下来了）。

这里有一个小方法来判断开一维还是开两维：

**1. 若物品有不选这个选项，一维好写。**

**2. 若每个物品都得被选中，但有多种选的方式，二维比一维好写。**

设 $f_j$ 表示当书架总长度为 $j$ 时上层放书的总宽度最小值，于是状态转移方程为：

$f_j=$ $\min (f_j,f_{j-v_i}+w_i)$ 

这里的 $v_i$ 和 $w_i$ 分别是书的厚度和宽度。

最后别忘了倒着扫一遍来判断答案，如果底下放书的总厚度比上面总宽度大，直接把答案输出就可以了。

# 3、代码

代码中有注释。

```cpp
#include <iostream>
#include <cstring>
using namespace std;
const int NR=105;
const int MR=205; //因为书的厚度可能是2，因此要开两倍
int f[MR],v[NR],w[NR];
int n,sum;
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>v[i]>>w[i];
		sum+=v[i];//要记录书的总厚度
	}
	memset(f,999999,sizeof(f));//初始把f设成INF
	f[0]=0;
	for(int i=1;i<=n;i++)//第一层枚举物品
		for(int j=sum;j>=v[i];j--)//第二层倒序枚举容量
			f[j]=min(f[j],f[j-v[i]]+w[i]);
	for(int i=sum;i>=0;i--)//从大到小扫一遍
		if(sum-i>=f[i])
		{
			cout<<sum-i;//可以就输出
			return 0;
		}
	return 0; 
}
```

**若有错误，欢迎指出！**