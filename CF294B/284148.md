先前的题解讲的有点跳，我作为初学者倒腾了一晚上才弄明白。我想以一个新手的视角来帮大家理一理解题的思路。  
这道题本质上是一道01背包题，但同时融合了贪心的思想。  
首先让我们明确三个前提：
- 书架的最大长度为所有书的厚度和，即全部书竖着放。
- 某本厚度为 $t$ 的书横着放后可以使全书厚度和减少 $t$。
- 书无非竖着放和横着放两种状态。
  
书架的长度只和下层竖着放的书的厚度和有关。因此，我们当然希望竖着放的书越少越好。  
现在假设我们有一个容量为 $j$ 的背包。任意选取若干本书，使其厚度和为 $j$，恰好塞满背包。之后，在我们往书架上放书的过程中，背包里的书一律横着放。显然，这样可以为我们的书架节约 $j$ 个长度。  
可以预见，往背包里塞书的方案可能不止一种。但不管怎么塞，这些书都只能为我们节省 $j$ 个长度。而题目中还要求上层横着放的书的宽度和不能大于下层竖着放的书的厚度和。贪心而言，我们当然希望背包里的书，即上层书的宽度和尽可能小。  
那么现在，问题转化成了去寻找减少 $j$ 个宽度时的最小花费 $w$。  
联系01背包，背包模版是在 $n$ 个物品中寻找满足背包容量条件下获得物品价值的最大值。在这里，**书的厚度等效于物品的重量，书的宽度等效于物品的价值，书架的长度等效于背包的容量**。只不过我们这次希望价值尽可能小。因此，得到状态转移方程：$dp[j]=min(dp[j],dp[j-v[i]]+w[i])$  
需要注意的是，$dp$ 完后的数组并不是最终答案。  
**$dp[j]$ 只表示在下层书籍厚度和不小于上层宽度和 $dp[j]$ 时可为你节省 $j$ 个长度。**  
所以最终答案还应该倒序查找。我们希望节省尽可能多的长度，但也要有足够多的下层厚度负担上层宽度。具体见代码：
```c
#include<stdio.h>
#include<stdlib.h>
int v[105]={}, w[105]={}; //厚度 宽度
int dp[205]={}; //背包的最大容量是所有书的厚度总和(n<=100 厚度<=2)
int min( int x, int y )
{
	return x>y ? y : x;
}
int main()
{
	int n, totLen=0;
	scanf("%d", &n);
	for( int i=1; i<=n; i++ ){
		scanf("%d %d", &v[i], &w[i]);
		totLen += v[i]; //总厚度
	}
	for( int i=1; i<=totLen; i++ )
		dp[i] = 10086; //初始化
	for( int i=1; i<=n; i++ ) //当前放第 i 本书
		for( int j=totLen; j>=v[i]; j-- ) // j是当前书架长度(等效于背包容量)
			dp[j] = min( dp[j], dp[ j-v[i] ]+w[i] ); //dp表示选厚度和为 j 的若干本书横着放的最小值
	for( int i=totLen; i>=0; i-- ) //倒序查找
		if( totLen-i >= dp[i] ){ //左式是下层书的厚度和 右式是上层书的宽度和
			printf("%d\n", totLen-i);
			break;
		}
	system("pause");
	return 0;
}
```

