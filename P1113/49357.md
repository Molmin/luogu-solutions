本以为我已经沦落到普及的题目都不会做了，到复赛只能水水分了，没想到，这题给我带来了信心！

这题是我专门找图论的题做的时候找到的，当然，不得不承认的是，我是按照难度由简到繁……这题貌似是很简单的那种……

我一看到这题题目，首先给我带来的是和正常图论题类似的感觉，估计好歹要百行代码左右，但是，原谅我是个蒟蒻，没有那么厉害可以码百行代码的实力。

那么，先贴上我的水题代码，然后在讲解——

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
int n,x,y,i,j,k;
int f[10001][10001];
int d[10001],dd[10001];
unsigned long long ans=0;
void dfs(int x)
{
    if(ans<d[x])ans=d[x];
    for(int i=1;i<=f[x][0];i++)
    {
        if(d[f[x][i]]<d[x]+dd[f[x][i]]&f[x][i]!=x)
        {
            d[f[x][i]]=d[x]+dd[f[x][i]];
            dfs(f[x][i]);
        }
    }
}
int main()
{
    scanf("%d",&n);
    for(i=1;i<=n;i++)
    {
        scanf("%d%d",&x,&dd[i]);
        scanf("%d",&x);
        while(x!=0) {f[x][++f[x][0]]=i;scanf("%d",&x);}
    }
    d[1]=dd[1];dfs(1);
    cout<<ans<<endl;
    return 0;
}
```
代码贴出来之后，我必须指明那么几点……
1.能水过这题估计是数据太水了，如果是一直伸下去的一棵树的话……咳咳，我很有自知之明的知道我这肯定会爆的。

2.个人编程水平很一般，数组名啥的都很随意的，不要在意dd这些数组名。

然后讲解：

原理就是，依题意得，1可以看做该子树的根节点，然后dfs走起，算出每个叶子结点（准确点说沿途的都算了个遍），然后一路都更新答案，最后输出。

水吧？我也这么觉得，虽然水但是最后看到AC了还是好开心诶~
