这是一道很坑的题目

有两个新增的数据导致许多人做不出来

一开始我是用数组的下标来做的，也就是下面一些大佬的做法

但是怎么做总会有两个测试点re

于是我开始使用队列

在使用前，我们要用sort来给那堆数排序

然后让一个个数进入队列

这个时候第一个参数就是记录看到底有多少个重复一样的用p表示

p表示的不是当前跟自己重复的是多少个，比如题目给的序列是1 1 2 3，那么看到2的时候p记录的是前面 1 有2个重复

这个时候判断2-1=1，那么答案就加2


如果是1 1 1 2 3，那么循环到第四个数字2的时候，答案就加3

如果是1 1 1 2 2 3，循环到第四个答案加3，循环到第五个数字，发现它和前面一样，也加3

然后，我们需要一个新的队列，如果当前数字和前一个一样，那么我们就每一个1都加入队列

知道遇到跟前一个不一样的，比如 1 1 1 2 3，这个时候遇到2，队列里面有三个数字 1 1 1

那么只要这个队列不为空，就从队列头看起，如果 2 - 队列头 = 1那就 p++

比如 1 1 1 4 5 5 6

循环到4，发现队列头小于3

那么把队列头一个一个弹出

弹出的时候p没有加加，然后队列就弹完了

之前那个如果是1的p加加之后还是要继续弹出队头

然后 2也得进队

也就是说我们的总体思想是，每一个元素都进队

但是如果你和前面的元素一样，就不需要执行什么判断了

如果你和前面的元素不一样，这个时候就要执行判断，看看排在你前面的队头有多少个跟你相差1

前面比你小的刚好1的判断完就全部弹出去了

或者如果前面全部没有刚好是1，那就弹到你之前没有数字

相当于队尾进一个数字，就看看要不要把前面的人推出去

这种思想去找答案

最后送上AC代码

```cpp
//P1102
#include<iostream>
#include<algorithm>
using namespace std;
long long int n,c,s=0,zs[2000010],a[2000010],front=0,reat;
int main()
{
	cin>>n>>c;
	for(int i=1;i<=n;i++)
		cin>>a[i];
	
	sort(a+1,a+n+1); 
	zs[0] = a[1];
    reat=1;
   	long long p=0;
	for(int i=2;i<=n;i++)
	{
		  if(a[i]==a[i-1])
		  {
		  	s += p;
		  	zs[reat]=a[i];
		  	reat++;
		  }  
		  else
		  {
		  	while(front<reat && zs[front]<a[i]-c)
		  	{
		  		front++;
			}
			p = 0;
			while(front<reat && zs[front]==a[i]-c)	
			{
				p++;
				front++;
			 } 
			zs[reat]=a[i];
			reat++;
			s += p;
		  }
	}
	cout<<s;
	return 0;
}
```
