写一篇稍微清楚点的，自己看的时候蒙了半天……

___

有一个显然的贪心方式：

- 每一个位置都由逆时针方向最近的有牛的位置填充。

证明：若微扰这个方案——用次近的位置填充，因为 $\forall x,y\in N^*,(x+y)^2>x^2+y^2$，所以必然导致答案增加。

这个贪心可以使用队列来实现。（用最前面的空闲的牛填这个牛棚，将这个位置上的牛留给后面的牛棚减少代价）。

现在问题变成了以哪个位置作为起点开始填充。

朴素的做法是枚举每一个位置作为起点,然后断环为链。这个 $O(n^2)$ 的屑做法只能通过 Silver 的数据。

首先断环为链，复制一份原数组在末尾，则每个方案可以表示为 i~i+n-1 这个区间的方案。

考虑删除一些无用的方案。

手画几个样例会发现，有很大一部分情况会因为前面的牛不够多而宣告不合法，我们可以由这个性质尝试跳过一部分起点。
___
设$b_i = c_i-1$,$c_i$ 表示在第i个牛棚中牛的头数。则 这个方案合法等价于**任意 b 的前缀和非负**。

**结论1** ： 若现在以 i 为起始点，走到 j 时宣告不合法，**则 i,j 之间的起点一定也不合法**。

证明：因为 i~j-1 中任意前缀和大于 0，移除前面一部分和非负的前缀后 ，后面的前缀和不会变大，必然也会在 j 或 j 之前宣告不合法。
___
**结论2** ：只要找到方案，必然是最优方案。

~~看起来好像很玄学。~~

证明：若我们已经找到了一个合法方案 st~st+n-1，整个合法方案的总前缀和必然为0，而后面的方案的生成方式是**剪切一段前缀，复制在末尾**。

只有剪切一段前缀和为 0 的前缀才可以使生成的方案合法，因为若剪切了前缀和为正的的，必定使新方案中 st+n-1 这个位置的前缀和小于0。

然而每一段前缀为0的前缀的剪切不会对答案有影响——因为前缀和为0，**内部的贡献是独立于外的**。

所以所有的合法方案答案必然相同。找到方案就是最优方案，输出即可。

___

时间复杂度 $O(n)$,每一个位置最多访问一次。

代码：

```cpp
#include <queue>
#include <cstdio>
const int maxn = 1e5+5;
int n,c[maxn<<1];
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;++i)scanf("%d",&c[i]),c[i+n] = c[i];
	for(int i=1;i<=n;++i){
		long long nowans=0;
		std :: queue <int> q;
		for(int j=i;j<i+n;++j){
			while(c[j])--c[j],q.push(j);
			if(!c[j]){
				if(q.empty()){
					nowans = -1;
					break;
				}
				int pos = q.front();
				q.pop();
				nowans = nowans + (long long)(j-pos)*(j-pos);
			}
		}
		if(nowans != -1)return printf("%lld",nowans),0;
	}
	return 0;
}
```
