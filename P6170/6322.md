update:修改了证明中不准确的部分，重新修改代码使之更加高效可读。

首先确认一点，奶牛行走的路径中不能有其他奶牛的终点，否则一定不是最优，可以从$\forall x,y \in N^*\quad x^2+y^2<(x+y)^2$ 来理解。

很容易想到一种暴力的方法，把环处理成链，枚举起始点，遇到牛就存入队列之中，遇到空位即就把队头的牛放进去，这样就能保证不会出现交叉，一旦发现奶牛数不足以填补空位，意味着必然出现交叉，此时这个起点就可以舍弃了。
这种做法的时间复杂度是$O(n^2)$的。

暴力的做法可以过简化版的题目，但是却不能过本题，那么应该怎么做呢？
猜想这样一种性质：当$i$和$j$之间在j处第一次出现奶牛数不足以填补空位时，$i$和$j$及其之间的点均不能作为起点。

证明如下：
假设$i$和$j$之间在$j$处第一次出现奶牛数不足以填补空位，也就是前缀和为负数（前缀和为$sum[i]=sum[i-1]+(a[i]-1)$，可以思考一下为什么要减一），位置多于总和，然后可以发现每次$i$前移一位，$j$不变的情况下，奶牛数$-a[i]$，位置数$-1$。

考虑两种情况，一种$a[i]>=1$，此时显然仍然是不可取的。

一种$a[i]=0$,此时总和不变，位置$-1$。在这个情况下$a[i]=0$，其实在$j=i$时已经出现了负数，所以仍然是不可取的。

综上所述，当$i$到$j$的前缀和出现在$j$处第一次出现负数时，$i$和$i,j$之间的位置均不能作为起点。

根据这个性质就可以剪掉大部分不需要的枚举了，具体使用在代码中有体现。

```
#include <cstdio>
#include <queue>
using namespace std;
int n, c[200005];
long long nowans;
int main()
{
    scanf("%d", &n);
    for (int i = 1; i <= n; i++)
        scanf("%d", &c[i]);
    for (int i = 1; i <= n; i++)
        c[i + n] = c[i];
    for (int i = 1; i <= n; i++)
    {
        nowans = 0;
        queue<int> que;
        for (int j = i; j < i + n; j++)
        {
            while (c[j] > 0)
            {
                que.push(j);
                c[j]--;
            }
            //这里是优化，不需要恢复c[j]的值
            //如果当前枚举的情况为最优解，恢复c[j]没有意义，因为后面的不会再优于当前情况
            //如果当前枚举的情况不是最优解，那么i和j及其之间都不可能是合法起点，c[j]的值也没有意义。
            if (c[j] == 0)
            {
                if (que.empty())
                {
                    nowans = -1;
                    i = j; 
                    //优化，直接跳过去
                    break;
                }
                int now = que.front();
                que.pop();
                nowans += (j - now) * (j - now);
            }
        }
        if (nowans != -1)
        {
            printf("%lld", nowans);
            return 0;
        }
    }
    return 0;
}
```