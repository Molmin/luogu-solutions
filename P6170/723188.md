本人水的第一篇题解，写的较差请谅解~


------------
这题本质上和银组的 P3137 一致，除了不能用 $O(N^2)$ 来解。

### 题意：

有 $N$ 头奶牛顺时针经过一个环，环一共 $N$ 个位置，某些为空。奶牛能量消耗为走的路程平方，要求消耗最少能量填满所有空位。

### 分析：

- 为了让总能量值最少，要尽可能保证每头奶牛走的路程最短，因为能量消耗是距离平方。

- 要拿满分必须同时带着所有当前的奶牛走，不然会超时。

- 每头 “牵着走” 的奶牛得记录位置，让最早来的最先抵达空位。

- 保证循环数组。

### 思路：

- 记录之前多余的奶牛数量（假设一个格子大于 $1$ 头奶牛数量，则把剩下的奶牛 “牵着走”）。

- 用队列储存所有当前奶牛的下标（保证最早来的牛最先走）。

- 找到某个起点，保证这个起点开始往后能够填满所有空位。这里通过反向遍历求出 $sum$，并从 $sum$ 数组中找到最大的值作为起点。

- 把原先的数组乘以 $2$（起到数组循环作用，这样也不需要取模了）。

- **进行奶牛交换：** 如果当前位置不为空且手上有 “牵着走” 的奶牛时，用手上的奶牛和当前位置上的奶牛进行交换，保证下一次奶牛的能量值 “刷新”。


------------
### 代码：

```cpp
#include<bits/stdc++.h>
#define int long long //别忘了开long long!
using namespace std;
int n,num[212345],sum[114514],c,idx,ans; //num储存2*原来的数组，idx为起点下标
signed main(){
	cin >> n;
	for(int i=0;i<n;i++)cin >> num[i];
	for(int i=n-1;i>=0;i--){//反向遍历求出sum中的值，用于求起点下标
		c+=num[i]-1;
		sum[i]=c;
	}c=0;
	for(int i=0;i<n;i++)//查询sum中的最大值下标设为起点
		if(sum[i]>c){
			idx=i;
			c=sum[i];
		}
	for(int i=n;i<n*2;i++)num[i]=num[i-n];//数组*2，保证循环
	queue<int>q;//队列存当前所有奶牛下标
	for(int i=idx;i<n+idx;i++)
		if(num[i]){
			if(!q.empty()){//如果数组不为空且手头有牵着的牛
				ans+=pow(i-q.front(),2);
				q.pop();//进行奶牛的交换，保证最小能量消耗并计算ans
				q.push(i);
			}
			for(int j=1;j<num[i];j++)q.push(i);//除了一头奶牛之外别的全部拿走
			num[i]=1;
		}else{
			ans+=pow(i-q.front(),2);//如果当前为空位，则拿出最早进队列的奶牛
			num[i]=1;
			q.pop();
		}
	cout << ans;
}

```

