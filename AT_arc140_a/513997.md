## 题意
+ 定义 $f(s)$：把字符串的第一位拿出来插到最后一位，求不停做此操作能够获得多少种字符串。
+ 你可以给你的长度为 $N$ 的字符串修改 $K$ 个字符。**可以不全部用完，甚至不用。**
+ 求修改完以后能获得的最小的 $f(s)$。

（这个题的翻译做的有一点孬）
## 做法
很明显的是，如果你的字符串是循环的，比如下面这个：`abab`，就是由 `ab` 循环而来的。易得它的 $f(s) = 2$。  
再比如，`iiyoiiyoiiyoiiyoiiyoiiyo`，是由 `iiyo` 循环而成，易得它的 $f(s) = 4$。

还不够明显吗？$f(s)$ 的大小就是循环节的长度！所以这题的核心在于：**构造循环**。而且循环节越短越好。
### 具体怎么做
首先很明显的是循环节的长度肯定是原字符串长度的因数，不然不能构成完整的循环。  
枚举了循环节长度之后，我们把每个循环节的每一位都比较一下，把出现次数最多的字母作为更改对象。

比如，`abcbscbbc` 这个字符串中，你打算以 $3$ 作为循环节长度。  
每节第一位： `a` 和 `b` 和 `b`，显然改成 `b`。  
每节第二位： `b` 和 `s` 和 `b`，显然改成 `b`。  
每节第三位： 都是 `c`，显然改成……不用改。

最后，如果修改次数不超过 `k`，我们就可以更新答案了。
## 代码
```cpp
#include <iostream>

using namespace std;

int main() {
  int n, k;
  string s;
  cin >> n >> k >> s;
  int ans = n;
  for(int l = 1; l <= n; l++) {
    if(n % l == 0) { //确定循环节长度
      int now = 0;
      for(int i = 0; i < l; i++) {
        int cnt[26] = {};
        int mx = 0;
        for(int j = i; j < n; j += l) {
          mx = max(mx, ++cnt[S[j] - 'a']); //确定出现最多的字母
        }
        now += n / l - mx; //修改的次数
      }
      if(now <= k) {
        ans = min(ans, l); //更新答案
      }
    }
  }
  cout << ans;
  return 0;
}
```
在[这里](/record/98326089)欣赏通过的记录。