## CF1674G Remove Directed Edges

### 算法

首先回顾一下「Cute Set」的定义：

> 一个顶点的集合 $S$ 被称作可爱的当且仅当任意两个顶点 $v$ 和 $u$（$v \neq u,v \in S,u \in S$），可以经过由未删除的边组成的路径由 $u$ 达到 $v$，或是从 $v$ 达到 $u$。

由于原图是一个 DAG，集合中点和未删除的边构成的也是一个 DAG。由 DAG 联想到可以进行拓扑排序。拓扑序中，任何一对相邻的顶点 $(i, i+1)$，都满足：由 $i$ 可以通过一条路径到达 $i+1$，或是由 $i+1$ 可以通过条路径到达 $i$。若是后者，则 $i+1$ 在拓扑序中，必位于 $i$ 之前，矛盾。因此拓扑序中，总可以由靠前的顶点经过一些边到达靠后的顶点。由此推出一个重要的结论：**存在一条经过一个 Cute Set 中所有顶点的路径，一条路径经过的顶点的集合也是一个 Cute Set**。

问题转化为：在 DAG 中找一条最长路，且经过的边均未删除。

转化为一个更简单直白问题后，再来看删边的条件。每个顶点要么没有入边，要么被删一条入边，出边同理。下面思考的问题是，在选择路径的时候，哪些顶点可以被加入集合中？路径对于一个顶点而言，就是一条入边和一条出边。在保留这条路径不能删的同时，它还要预留可以删除的入边、出边各一条，以满足题意。因此，第二个重要的结论是：除了路径的起点没有入度要求、路径的终点没有出度要求以外，对于路径上每一个点的要求是至少分别有两条入边和两条出边，即**对于路径上的每一条边 $u \to v$，都要满足 $out_u>1$ 且 $in_v>1$**。

对于 DAG 上最长路问题，直接在拓扑序上 DP 即可，具体方法不再赘述。

### 实现

```cpp
int n, m;
int ind[200001], oud[200001], del[200001];
std::vector<int> e[200001];
std::queue<int> q;
int f[200001];

int main() {
    n = read(), m = read();
    while (m--) {
        int u = read(), v = read();
        ++ind[v], ++del[v], ++oud[u];
        e[u].push_back(v);
    }
    for (int i = 1; i <= n; ++i) {
        f[i] = 1;
        if (!del[i]) q.push(i);
    }
    int ans = 1;
    while (!q.empty()) {
        int u = q.front();
        q.pop();
        ans = std::max(ans, f[u]);
        for (int v : e[u]) {
            if (ind[v] > 1 && oud[u] > 1)
                f[v] = std::max(f[v], f[u] + 1);
            if (!--del[v])
                q.push(v);
        }
    }
    printf("%d\n", ans);
    return 0;
}
```