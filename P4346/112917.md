暴力大法吼！

虽然码量有$4kB$，但思路应该是比较清楚的。

---

首先我们来观察一下这些字符：

```
....x.xxxxx.xxxxx.x...x.xxxxx.xxxxx.xxxxx.......xxxxx.xxxxx.xxxxx
....x.....x.....x.x...x.x.....x.........x...x...x...x.x...x.x...x
....x.....x.....x.x...x.x.....x.........x...x...x...x.x...x.x...x
....x.xxxxx.xxxxx.xxxxx.xxxxx.xxxxx.....x.xxxxx.xxxxx.xxxxx.x...x
....x.x.........x.....x.....x.x...x.....x...x...x...x.....x.x...x
....x.x.........x.....x.....x.x...x.....x...x...x...x.....x.x...x
....x.xxxxx.xxxxx.....x.xxxxx.xxxxx.....x.......xxxxx.xxxxx.xxxxx
```
然后我们把这些数分成5部分：
```
....x.xxxxx.xxxxx.x...x.xxxxx.xxxxx.xxxxx.......xxxxx.xxxxx.xxxxx	第1部分
-----------------------------------------------------------------
....x.....x.....x.x...x.x.....x.........x...x...x...x.x...x.x...x
....x.....x.....x.x...x.x.....x.........x...x...x...x.x...x.x...x	第2部分
-----------------------------------------------------------------
....x.xxxxx.xxxxx.xxxxx.xxxxx.xxxxx.....x.xxxxx.xxxxx.xxxxx.x...x	第3部分
-----------------------------------------------------------------
....x.x.........x.....x.....x.x...x.....x...x...x...x.....x.x...x
....x.x.........x.....x.....x.x...x.....x...x...x...x.....x.x...x	第4部分
-----------------------------------------------------------------
....x.xxxxx.xxxxx.....x.xxxxx.xxxxx.....x.......xxxxx.xxxxx.xxxxx	第5部分
```
然后我们便可发现这样的规律（单独放一部分讲算了QAQ）：

---

$1$：第一部分只有右边有阴影，第二部分也只有右边有阴影，第三部分还是只有右边有阴影，第四部分和第五部分同。  
$2$：第一部分所有格子都有阴影，第二部分只有右边有阴影，第三部分所有格子都有阴影，第四部分只有左边有阴影，第五部分所有格子都有阴影。  
$3$：第一部分所有格子都有阴影，第二部分只有右边有阴影，第三部分所有格子都有阴影，第四部分只有右边有阴影，第五部分所有格子都有阴影。  
$4$：第一部分只有左边和右边有阴影，第二部分只有右边有阴影，第三部分所有格子都有阴影，第四部分只有右边有阴影，第五部分只有右边有阴影。  
$5$：第一部分所有格子都有阴影，第二部分只有左边有阴影，第三部分所有格子都有阴影，第四部分只有右边有阴影，第五部分所有格子都有阴影。  
$6$：第一部分所有格子都有阴影，第二部分只有左边有阴影，第三部分所有格子都有阴影，第四部分只有左边和右边有阴影，第五部分所有格子都有阴影。  
$7$：第一部分所有格子都有阴影，第二部分只有右边有阴影，第三部分只有右边有阴影，第四部分和第五部分同。  
$8$：第一部分所有格子都有阴影，第二部分只有左边和右边有阴影，第三部分所有格子都有阴影，第四部分只有左边和右边有阴影，第五部分所有格子都有阴影。  
$9$：第一部分所有格子都有阴影，第二部分只有左边和右边有阴影，第三部分所有格子都有阴影，第四部分只有右边有阴影，第五部分所有格子都有阴影。  
$0$：第一部分所有格子都有阴影，第二部分只有左边和右边有阴影，第三部分只有左边和右边有阴影，第四部分只有左边和右边有阴影，第五部分所有格子都有阴影。  
注意还要考虑一下$+$的情况：第一部分没有阴影，第二部分只有中间有阴影，第三部分所有格子都有阴影，第四部分只有中间有阴影，第五部分没有阴影。

---

然后考虑一下加法的计算。我们先找到这样的关键字符：

设有一个$7*5$的矩阵（对于每个元素的下标$A_{i,j}$，有$i\in[1,7],j\in[1,5]$）。

则其中的关键点有：$A_{1,1},A_{2,1},A_{4.1},A_{5,1},A_{7,1},A_{4,2} ~or~A_{4,4},A_{1,5},A_{2,5},A_{4,5},A_{5,5},A_{7.5}$。如果你理解了上面的内容，这段理解应该是不难的，凡是**满足且仅满足**以下条件的都必定是对应的数：

$1$：$A_{1,5}=A_{2,5}=A_{4,5}=A_{5,5}=A_{7,5}=$'$x$'。   
$2$：$A_{1,1}=A_{4,1}=A_{5,1}=A_{7,1}=A_{4,2}=A_{4,4}=A_{1,5}=A_{2,5}=A_{4,5}=A_{7,5}=$'$x$'。  
$3$：$A_{1,1}=A_{4,1}=A_{7,1}=A_{4,2}=A_{4,4}=A_{1,5}=A_{2,5}=A_{4,5}=A_{5,5}=A_{7,5}=$'$x$'。  
$4$：$A_{1,1}=A_{2,1}=A_{4,1}=A_{4,2}=A_{4,4}=A_{1,5}=A_{2,5}=A_{4,5}=A_{5,5}=A_{7,5}=$'$x$'。  
$5$：$A_{1,1}=A_{2,1}=A_{4,1}=A_{7,1}=A_{4,2}=A_{4,4}=A_{1,5}=A_{4,5}=A_{5,5}=A_{7,5}=$'$x$'。  
$6$：$A_{1,1}=A_{2,1}=A_{4,1}=A_{5,1}=A_{7,1}=A_{4,2}=A_{4,4}=A_{1,5}=A_{4,5}=A_{5,5}=A_{7,5}=$'$x$'。  
$7$：$A_{1,1}=A_{1,5}=A_{2,5}=A_{4,5}=A_{7,5}=$'$x$'。  
$8$：$A_{1,1}=A_{2,1}=A_{4,1}=A_{5,1}=A_{7,1}=A_{4,2}=A_{4,4}=A_{1,5}=A_{2,5}=A_{4,5}=A_{5,5}=A_{7,5}=$'$x$'。
$9$：$A_{1,1}=A_{2,1}=A_{4,1}=A_{7,1}=A_{4,2}=A_{4,4}=A_{1,5}=A_{2,5}=A_{4,5}=A_{5,5}=A_{7,5}=$'$x$'。
$0$：$A_{1,1}=A_{2,1}=A_{4,1}=A_{7,1}=A_{1,5}=A_{2,5}=A_{4,5}=A_{5,5}=A_{7,5}=$'$x$'。  
$+$：$A_{4,1}=A_{4,2}=A_{4,4}=A_{4,5}=$'$x$'。

数字的存储就类似于快读的方法就行，还有，碰到加号要重新计算，再和前面所得的数做加法。

最后输出的时候按照最开始讲的规律来输出就行了，注意应处理每行，在处理每个字符，每行应该换行！

---

讲了这么多，最后贴个代码仅供参考：
```cpp
#include <cstdio>
#include <algorithm>
#include <cstring>
using namespace std;

char a[8][307];
int b[3], flag = 1, flg[11], nnn[15];

int main() {
	for(int i = 0; i < 7; ++i)
		scanf("%s", a[i]);
	int len = strlen(a[1]);
	for(int i = 0; i < len; i += 6) {
//		for(int j = 0; j < 7; ++j)
//			printf("%c\n", a[j][i]);
//		for(int j = 0; j < 7; ++j)
//			printf("%c\n", a[j][ i + 2])
//		puts("");
		memset(flg, 0, sizeof(flg));
//		printf("%c %c %c %c %c %c %c %c %c\n", a[0][i], a[1][i], a[3][i], a[4][i], a[6][i], a[1][i + 2], a[1][i + 4], a[4][i + 4], a[3][i + 1]);
		if(a[1][i + 2] == 'x') {
			flag = 2;
			continue;
		}
		if(a[0][i] == '.' && a[1][i] == '.' && a[3][i] == '.' && a[4][i] == '.' && a[6][i] == '.' && a[0][i + 4] == 'x' && a[1][i + 4] == 'x' && a[4][i + 4] == 'x' && a[6][i + 4] == 'x')
			b[flag] = b[flag] * 10 + 1;
		else if(a[0][i] == 'x' && a[1][i] == '.' && a[3][i] == 'x' && a[4][i] == 'x' && a[6][i] == 'x' && a[0][i + 4] == 'x' && a[1][i + 4] == 'x' && a[4][i + 4] == '.' && a[6][i + 4] == 'x')
			b[flag] = b[flag] * 10 + 2;
		else if(a[0][i] == 'x' && a[1][i] == '.' && a[3][i] == 'x' && a[4][i] == '.' && a[6][i] == 'x' && a[0][i + 4] == 'x' && a[1][i + 4] == 'x' && a[4][i + 4] == 'x' && a[6][i + 4] == 'x')
			b[flag] = b[flag] * 10 + 3;
		else if(a[0][i] == 'x' && a[1][i] == 'x' && a[3][i] == 'x' && a[4][i] == '.' && a[6][i] == '.' && a[0][i + 4] == 'x' && a[1][i + 4] == 'x' && a[4][i + 4] == 'x' && a[6][i + 4] == 'x')
			b[flag] = b[flag] * 10 + 4;
		else if(a[0][i] == 'x' && a[1][i] == 'x' && a[3][i] == 'x' && a[4][i] == '.' && a[6][i] == 'x' && a[0][i + 4] == 'x' && a[1][i + 4] == '.' && a[4][i + 4] == 'x' && a[6][i + 4] == 'x')
			b[flag] = b[flag] * 10 + 5;
		else if(a[0][i] == 'x' && a[1][i] == 'x' && a[3][i] == 'x' && a[4][i] == 'x' && a[6][i] == 'x' && a[0][i + 4] == 'x' && a[1][i + 4] == '.' && a[4][i + 4] == 'x' && a[6][i + 4] == 'x')
			b[flag] = b[flag] * 10 + 6;
		else if(a[0][i] == 'x' && a[1][i] == '.' && a[3][i] == '.' && a[4][i] == '.' && a[6][i] == '.' && a[0][i + 4] == 'x' && a[1][i + 4] == 'x' && a[4][i + 4] == 'x' && a[6][i + 4] == 'x')
			b[flag] = b[flag] * 10 + 7;
		else if(a[0][i] == 'x' && a[1][i] == 'x' && a[3][i + 2] == 'x' && a[3][i] == 'x' && a[4][i] == 'x' && a[6][i] == 'x' && a[0][i + 4] == 'x' && a[1][i + 4] == 'x' && a[4][i + 4] == 'x' && a[6][i + 4] == 'x')
			b[flag] = b[flag] * 10 + 8;
		else if(a[0][i] == 'x' && a[1][i] == 'x' && a[3][i] == 'x' && a[4][i] == '.' && a[6][i] == 'x' && a[0][i + 4] == 'x' && a[1][i + 4] == 'x' && a[4][i + 4] == 'x' && a[6][i + 4] == 'x')
			b[flag] = b[flag] * 10 + 9;
		else 
			b[flag] = b[flag] * 10;
		
	}
//	printf("%d ", b[1] + b[2]);
	int ans = b[1] + b[2], tmp = ans, cnt = 0;
	while(tmp) {
		nnn[++cnt] = tmp % 10;
		tmp /= 10;
	}
	for(int i = 1; i <= 7; ++i) {
		for(int j = cnt; j >= 1; --j) {
			if(j != cnt)	printf(".");
			if(i == 1) {
				switch(nnn[j]) {
					case 0: case 2: case 3: case 5: case 6: case 7: case 8: case 9: {
						printf("xxxxx");
						break;
					}
					case 1: {
						printf("....x");
						break;
					}
					case 4: {
						printf("x...x");
						break;
					}
				}
			} else if(i == 2 || i == 3) {
				switch(nnn[j]) {
					case 0: case 4: case 8: case 9: {
						printf("x...x");
						break;
					}
					case 1: case 2: case 3: case 7: {
						printf("....x");
						break;
					}
					case 5: case 6: {
						printf("x....");
						break;
					}
				}
			} else if(i == 4) {
				switch(nnn[j]) {
					case 1: case 7: {
						printf("....x");
						break;
					}
					case 2: case 3: case 4: case 5: case 6: case 8: case 9: {
						printf("xxxxx");
						break;
					}
					case 0: {
						printf("x...x");
						break;
					}
				}
			} else if(i == 5 || i == 6) {
				switch(nnn[j]) {
					case 0: case 6: case 8: {
						printf("x...x");
						break;
					}
					case 1: case 3: case 4: case 5: case 7: case 9: {
						printf("....x");
						break;
					}
					case 2: {
						printf("x....");
						break;
					}
				}
			} else {
				switch(nnn[j]) {
					case 0: case 2: case 3: case 5: case 6: case 8: case 9: {
						printf("xxxxx");
						break;
					}
					case 1: case 4: case 7:{
						printf("....x");
						break;
					}
				}
			}
		}
		puts("");
	}
	return 0;
}
//防盗水印：UID=112917
//P.s. 请忽略被注释的调试部分。
```
打本题代码和写本题题解实属不易，若有纰漏，还请大佬多指点！

记得点个赞哦！qwq

$\text{-Eason On 2019.11.9 5.20p.m. to 11.53p.m.}$