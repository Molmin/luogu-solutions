~~本蒟蒻第一次写题解，求通过。~~

我的思路与深搜有点像，几乎是纯暴力。
# 注意

### 这道题如果用4个方向写的话，那么一种站法就会算两次。
### 所以要用2个方向写，比如“下”和“右”
### 其实也可以用“上”和“左”
# 但一定不能用“上”和“下”或“左”和“右”！


-----------------------我是分割线------------------------

## 主要思路
#### 先找到一个空位，然后以空位为中心，看下“下”和“右”有没有连续k个空位，如果有，就ans++，然后就继续找空位，直到找完为止。

废话不多说，直接上代码（不懂的看注释）
```
#include<bits/stdc++.h>
using namespace std;
int main()
{
	int r,c,k,i,j,i1,j1,fx[2]={0,1},fy[2]={1,0};//r行 c列 k人
	int nx,ny,ans=0; 
	char a[101][101];//场地a 
	cin>>r>>c>>k;
	for(i=0;i<r;i++)
	{
		for(j=0;j<c;j++)
		{
			cin>>a[i][j];
		}
	}
	if(k==1)//只有一个人的时候单独处理
	{
		for(i=0;i<r;i++)
		{
			for(j=0;j<c;j++)
			{
				if(a[i][j]=='.')
					ans++;
			}
		}
		cout<<ans;
		return 0;
	}
	for(i=0;i<r;i++)
	{
		for(j=0;j<c;j++)
		{
			if(a[i][j]=='.')//如果发现一个空位，就看看旁边有没有其他空位
			{
				for(i1=0;i1<2;i1++)
				{
					nx=i+fx[i1];
					ny=j+fy[i1];
					for(j1=1;j1<k;j1++)//j1=1是因为前面已经找到了一个空位，只需要再多找k-1就好了
					{
						if(a[nx][ny]!='.')
						{
							break;
						}
						if(j1==k-1)//如果用连续k个空位，ans++
						{
							ans++;
						}
						nx=nx+fx[i1];
						ny=ny+fy[i1];
					}
				}
			}
		}
	}
	cout<<ans;
	return 0;
} 
```
