简化版题面：

给定一张无向图，求给这张图定向成$\rm DAG$之后最长路最短是多少。$n\leq 15$

### $\rm{Sol~1}$

考虑直接$dp$。$f_{s,u,v}$表示考虑了点集$s$，最长路端点是$u,v$的最小值。每次转移的时候枚举$u,v,w$，从$(u,v),(v,w)$两个状态转移到$(u,w)$。复杂度$O(3^nn^3)$ 

### $\rm Sol~2$

考虑证明一个二级定理：

>定理 $1.1$
>
>* 一张无向图定向成的$\rm DAG$，当其最长路最短时，其最长路为$\rm X-1$，其中$\rm X$表示**不连通集覆盖数**。也就是对于一张有向图图$\rm \{V,E\}$，定义一种划分$P$，使得划分出的每个集合中所有点不连通。

考虑一种证明：

* 首先一定有$\rm X-1\geq maxL$。因为其上的每个点是连通的。
* 其次我们考虑，如果每次删除全部出度为$0$点，放到一个集合里，那么一定合法，并且可以满足$\rm X=maxL+1$。

但其实这东西也可以直接用$\rm dilworth$定理的对偶定理证出来：

> 定理 $2.1$（$\rm dilworth$定理）
>
> **令$\rm (X,≤)$是一个有限偏序集，并令$m$是反链的最大的大小。则$\rm X$可以被划分成$m$个但不能再少的链。**

对偶一下：

> 定理 $2.2$:
> 令$\rm (X,≤)$是一个有限偏序集，并令$r$是其最大链的大小。则$X$可以被划分成$r$个但不能再少的反链。

然后”反链“连接的是”不可比的点“，也就是本题中”不连通的点“。

于是我们就可以快乐地状压了。

```cpp
int *g, *f ;
int main(){
	cin >> N >> M ; 
	memset(f, 63, sizeof(f)) ; 
	int u, v, i, j ; T = (1 << N) - 1 ;
	for (i = 1 ; i <= M ; ++ i)
		cin >> u >> v, -- u, -- v, E[u] |= (1 << v), E[v] |= (1 << u) ;
	f[0] = 0, g[0] = 1 ; 
	for (i = 0 ; i <= N ; ++ i) Sz[1 << i] = i ; 
	for (i = 1 ; i <= T ; ++ i){
		j = (i & (-i)) ;
		if (!g[i ^ j]) continue ; 
		if (E[Sz[j]] & (i ^ j)) continue ; 
		g[i] = 1 ; 
	}
	for (i = 1 ; i <= T ; ++ i)
		for (j = i ; j ; j = (j - 1) & i)
			if (g[j]) f[i] = min(f[i], f[i ^ j] + 1) ; 
	cout << f[T] - 1 << endl ; return 0 ;
}
```

