楼上已经说的很不错了，这里再给出我的做法。

设f[i][0]表示不考虑第二列第i个之后的数字，且第一列第i个和第i+1个都没有雷有多少种可能；f[i][1]表示不考虑第二列第i个之后的数字，且第一列第i个有雷，第i+1个没有雷有多少种可能；f[i][2]表示不考虑第二列第i个之后的数字，且第一列第i个没有雷，第i+1个有雷有多少种可能；f[i][3]表示不考虑第二列第i个之后的数字，且第一列第i个和第i+1个都有雷有多少种可能。于是，f[i]可以通过f[i-1]递归求解（知道了第一列第i-1个和第i个有没有雷，必然能通过第二列第i个求出第一列第i+1个，进而求出f[i]），具体递推公式看代码（附录里有）。

得出f[n-1]后，若第二列最后一个为0（可能出现在坑爹数据中），则答案为f[n-1][0]；若第二列最后一个为1，则答案为f[n-1][1]+f[n-1][2]；若第二列最后一个为2，则答案为f[n-1][3]；若第二列最后一个大于2（同样可能出现在坑爹数据中），则答案为f[n-1][0]。

附录——用此算法做的C++代码：

```cpp

#include<iostream>
using namespace std;
int n,i,map[10001],f[10000][4]={{1,0,1,0}}; 
int main ()
{
    cin>>n;
    for (i=1;i<=n;i++)
    cin>>map[i];
    for (i=1;i<n;i++)
    {
        switch (map[i])
        {
               case 0:
                    f[i][0]=f[i-1][0];
                    f[i][1]=0;
                    f[i][2]=0;
                    f[i][3]=0;
                    break;
               case 1:
                    f[i][0]=f[i-1][1];
                    f[i][1]=f[i-1][2];
                    f[i][2]=f[i-1][0];
                    f[i][3]=0;
                    break;
               case 2:
                    f[i][0]=0;
                    f[i][1]=f[i-1][3];
                    f[i][2]=f[i-1][1];
                    f[i][3]=f[i-1][2];
                    break;
               case 3:
                    f[i][0]=0;
                    f[i][1]=0;
                    f[i][2]=0;
                    f[i][3]=f[i-1][3];
                    break;
               default:
                       f[i][0]=0;
                       f[i][1]=0;
                       f[i][2]=0;
                       f[i][3]=0;
                       break;
        }
    }
    switch (map[n])
    {
           case 0:
                cout<<f[n-1][0];
                break;
           case 1:
                cout<<f[n-1][1]+f[n-1][2];
                break;
           case 2:
                cout<<f[n-1][3];
                break;
           default:
                   cout<<0;
                   break;
    }
    return 0;
} 

```