# 一道很奇妙的题
~~其实是我太弱~~，一看直接暴搜。

------------
## 思路
一道dfs+剪枝。直接暴搜，每搜一格判断上格可不可以，可以达到剪枝效果，时间复杂度快很多。如果不加剪枝会 _TLE_。

------------
## 时间复杂度
如果直接跑，跑到n+1时才判断，会有很多次跑到其实没有意义，会TLE九个点。

------------
## 剪枝（优化时间复杂度）
那么怎么剪枝才是重点。因为此时已经跑到x，不会影响前面所以可以跑到x时可以判断a[x-2]是否可行，注意x>=4,不然会判错。另外用加法判断和比最后用for判会快很多。

------------
```cpp
if(flag[x-3]+flag[x-2]+flag[x-1]!=a[x-2]&&x-3>=1) return;
```
------------
## 附上AC代码
```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int n,m,a[10001],flag[10001],p,k,ans;
void dfs(int x)
{
	if(flag[x-3]+flag[x-2]+flag[x-1]!=a[x-2]&&x-3>=1) return;//剪枝，跑到x时可以判断a[x-2]是否可行
	if(x==n+1)//当dfs跑完判断方案是否可行 
	{	
		if(flag[n-1]+flag[n]==a[n])	ans++;//用加法判断和的大小
		return;
	}
	if((a[x]==1&&flag[x-1]!=1)||a[x]==2||a[x]==3)//当a[x]==0和a[x]==1但x-1是雷时是不能走的
	{
		flag[x]=1;
		dfs(x+1);
		flag[x]=0;
	}
	if(a[x]==0||a[x]==1||(a[x]==2&&flag[x-1]==1))//当a[x]==2但x-1不是雷不能走
	dfs(x+1);
}
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++) cin>>a[i];
	dfs(1);
	cout<<ans;
}
```
------------
## 完结撒花
~~本蒟蒻第一次写题解，大家点个赞呗~~。