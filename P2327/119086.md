这道题总的来说还是很简单的，~~但教练在我们只会数组循环什么的时候考试是几个意思~~，考试过了几百年之后发现了这个，成功给他A掉了

思路是DP（万物皆可DP）

状态设计：f[N][2][2] i,j,k分别表示第几个，第i个有没有雷，第i+1个有没有雷

初始化：

```cpp
f[0][0][0]=f[0][0][1]=1;
	
```

转移比较好理解

a[i]==0

从f[i-1][0][0]转移到f[i][0][0]

a[i]==1

从f[i-1][1][0]到f[i][0][0]


f[i-1][0][1]到f[i][1][0]

从f[i-1][0][0]到f[i][0][1]

......(能说懒得打了吗）

```cpp
void work() {
	f[0][0][0]=f[0][0][1]=1;
	FOR(i,1,n) {
		if(a[i]==0) {
			f[i][0][0]=f[i-1][0][0];
		}
		if(a[i]==1) {
			f[i][0][0]=f[i-1][1][0];
			f[i][1][0]=f[i-1][0][1];
			f[i][0][1]=f[i-1][0][0];
		}
		if(a[i]==2) {
			f[i][1][0]=f[i-1][1][1];
			f[i][1][1]=f[i-1][0][1];
			f[i][0][1]=f[i-1][1][0];
		}
		if(a[i]==3) {
			f[i][1][1]=f[i-1][1][1];
		}
	}
	cout<<f[n][1][0]+f[n][0][0];
}

```

就是这样