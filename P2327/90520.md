思路: 
深搜的思想。
从第一个位置开始搜，用一个数组a左边那一排的某个位置表示有无雷，
再用b数组存储右边那一排的某个位置的八连通点的权值和（即输入的数据） 
搜索开始：从第一个位置，分别用a[i]等于0（即无雷）或1（即有雷）去搜。
结束条件：当把每一个位置都搜过了之后，再判断当前搜出的这种方案是否可行，然后return结束即可。 

```cpp
//程序:
#include<iostream>
using namespace std;
int a[10005],b[10005];
int n,ans;
int pd(int x)
{
	if(a[x-1]+a[x]+a[x+1]==b[x])return 1;
	//题目中说是八连通方向，由于题目边界局限性，直接把八连通点中的三个加起来判断。 
	return 0;
}
void dfs(int k)
{
	if(k==n+1){if(pd(n))ans++;return ;} 
	//搜索结束条件，如果直到最后一个判断都符合条件，说明方案是可行的故ans++； 
	a[k]=1;if(k==1||pd(k-1))dfs(k+1);
	//假设这个格子有雷，且判断无误（优化，边搜边判断），继续搜索下一个格子 
	a[k]=0;if(k==1||pd(k-1))dfs(k+1);
	//假设这个格子无雷，且判断无误（优化，边搜边判断），继续搜索下一个格子 
}
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)cin>>b[i];
	dfs(1);
	cout<<ans<<endl;
}
```