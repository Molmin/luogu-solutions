[算法分析]

按照我们平时玩扫雷的心得，我们往往可以通过某个位置周围的数字以及已经得到的雷的分布推出其是不是雷。该题同样可以这样做，如果已知第i-1格和i-2格是否有雷(i>2)，则可以通过序列中第i-1个数推出第i格是否有雷。而第2格的状态则只需要由第一格的雷和序列第一个数推出。

设A[i]表示序列中第i个元素，F[i]表示第I格的雷数,我们可以**递推**求解。

方程：

       **A[i]=A[i-1]-F[i-1]  (i=2)**

       **A[i]=A[i-1]-F[i-2]-F[i-1]  (i>2)**

但是F1的值还是未知的，由于每一格就是有雷和无雷两种状态，显然我们可以枚举第一格雷的状态，即F1的值为0或者1，这样就可以递推得到所有的F值。如果Fi（1<=i<=n）的值不为0，1的话显然是不符合要求的，而如果** A[n]<>F[n]+F[n-1]**(不判只有90分）,显然也是不符合要求的。如果不出现这种情况就得到一种可行的分布方案，所以最后答案不外乎0， 1， 2三种。

[参考代码]

```cpp
#include <iostream>
using namespace std;
int a[10100],n;
int main()
{
    cin>>n;
    for(int i=1;i<=n;i++)
      cin>>a[i];//读入操作
    int booll,boolr;
    booll=boolr=0;//判断求得的解是否合法
    int f1[10100],f2[10100];//递推数组
    for(int i=1;i<=n;i++)
    {
        f1[1]=0;//分第一个空是否有雷，进行两次计算
        if(i==2)
        {
            if(a[1]-f1[1]==1||a[1]-f1[1]==0)
              f1[2]=a[1]-f1[1];//递推公式
            else  booll=1; //记录不合法
        }
        if(i>2)
        {
            if(a[i-1]-f1[i-1]-f1[i-2]==1||a[i-1]-f1[i-1]-f1[i-2]==0)
              f1[i]=a[i-1]-f1[i-1]-f1[i-2];//递推公式
            else  booll=1;//记录不合法
        }
        f2[1]=1;
        if(i==2)
        {
            if(a[1]-f2[1]==1||a[1]-f2[1]==0)
              f2[2]=a[1]-f2[1];//递推公式
            else  boolr=1;//记录不合法
        }
        if(i>2)
        {
            if(a[i-1]-f2[i-1]-f2[i-2]==1||a[i-1]-f2[i-1]-f2[i-2]==0)
              f2[i]=a[i-1]-f2[i-1]-f2[i-2];//递推公式
            else  boolr=1;//记录不合法
        }
    }
    if(a[n]!=f1[n-1]+f1[n])
      booll=1;
    if(a[n]!=f2[n-1]+f2[n])
      boolr=1;//重要的判定，容易被忽略
    int ans;
    if(booll&&boolr)
      ans=0;
    if((!booll&&boolr)||(!boolr&&booll))
      ans=1;
    if(!booll&&!boolr)
         if(f1[n]==f2[n])
        ans=1;
      else
        ans=2;//判断answer
    cout<<ans<<endl;//输出操作
    return 0;
}
希望各位oier仔细思考每一个问题，AC并不是最重要的，最重要的是思考与解题的过程。
```