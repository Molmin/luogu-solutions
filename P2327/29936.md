今年的NOI我一点儿思路都没有，只好去刷水题了。

设f[i][0/1][0/1][0/1]表示满足前i个限制条件，第i-1, i, i+1格分别有(1)/没有(0)雷的方案数。


边界条件：f[0][0][0][0]=f[0][0][0][1]=1。


状态转移方程（a[i]为第二列第i格的数。注意坑点，a[i]有可能等于0）：

当a[i]==0时，f[i][0][0][0]=f[i-1][0][0][0]+f[i-1][1][0][0]。

当a[i]==1时，

f[i][1][0][0]=f[i-1][0][1][0]+f[i-1][1][1][0]，

f[i][0][1][0]=f[i-1][0][0][1]+f[i-1][1][0][1]，

f[i][0][0][1]=f[i-1][0][0][0]+f[i-1][1][0][0]。

当a[i]==2时，

f[i][1][1][0]=f[i-1][0][1][1]+f[i-1][1][1][1]，

f[i][1][0][1]=f[i-1][0][1][0]+f[i-1][1][1][0]，

f[i][0][1][1]=f[i-1][0][0][1]+f[i-1][1][0][1]。

当a[i]==3时，


f[i][1][1][1]=f[i-1][0][1][1]+f[i-1][1][1][1]。

当a[n]==0时，最终答案=f[n][0][0][0]。

当a[n]==1时，最终答案=f[n][1][0][0]+f[n][0][1][0]。

当a[n]==2时，最终答案=f[n][1][1][0]。

当a[n]==3时，最终答案=0。


代码：

```cpp
#include <cmath>
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
using namespace std;
inline int read() {
    int res = 0; bool bo = 0; char c;
    while (((c = getchar()) < '0' || c > '9') && c != '-');
    if (c == '-') bo = 1; else res = c - 48;
    while ((c = getchar()) >= '0' && c <= '9')
        res = (res << 3) + (res << 1) + (c - 48);
    return bo ? ~res + 1 : res;
}
const int N = 1e4 + 5;
int n, a[N], f[N][2][2][2];
int main() {
    int i; n = read();
    for (i = 1; i <= n; i++) a[i] = read();
    f[0][0][0][0] = f[0][0][0][1] = 1;
    for (i = 1; i <= n; i++) switch(a[i]) {
        case 0:
            f[i][0][0][0] = f[i - 1][0][0][0] + f[i - 1][1][0][0];
            break;
        case 1:
            f[i][1][0][0] = f[i - 1][0][1][0] + f[i - 1][1][1][0];
            f[i][0][1][0] = f[i - 1][0][0][1] + f[i - 1][1][0][1];
            f[i][0][0][1] = f[i - 1][0][0][0] + f[i - 1][1][0][0];
            break;
        case 2:
            f[i][1][1][0] = f[i - 1][0][1][1] + f[i - 1][1][1][1];
            f[i][1][0][1] = f[i - 1][0][1][0] + f[i - 1][1][1][0];
            f[i][0][1][1] = f[i - 1][0][0][1] + f[i - 1][1][0][1];
            break;
        case 3:
            f[i][1][1][1] = f[i - 1][0][1][1] + f[i - 1][1][1][1];
            break;
    }
    int res; if (a[n] == 0) res = f[n][0][0][0];
    else if (a[n] == 2) res = f[n][1][1][0];
    else if (a[n] == 1) res = f[n][1][0][0] + f[n][0][1][0];
    else res = 0; cout << res << endl;
    return 0;
}
```