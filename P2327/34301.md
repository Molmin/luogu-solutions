#在做这道题之前，首先得弄清楚这些东西:

##1、第一个雷只有两个方向，且第一个雷只有两种情况0,1,这道题的关键就在这里

##2、知道第一个雷之后，第二格雷的方法就是a[1]-b[1](a数组是输入的地雷数，b数组是要我们求的地雷数)

##3、接下来求地雷的方法就是b[j]=a[j-1]-b[j-1]-b[j-2];，但中途只要出现错误(b[j]不等于0页不等于1)，那就说明方法不可取，就不累加

##4、不要以为循环完就ok了，还需要验证最后一个雷到底对不对，因为最后一个雷的方向也是只有两个，所以验证方法就是去判断这个雷到底##符不符合输入的雷数（b[n]!=a[n]-b[n-1]），若不符合，则方法仍不可取。

那么清楚了之后，代码如下:

#=====================一条华丽的分割线=========================================================


```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
    long int i,j,n,s=0,a[10002],b[10002];
    cin>>n;
    for (i=1;i<=n;i++) scanf("%d",&a[i]);
    for (i=0;i<=1;i++){//第一个雷的两种情况
        bool f=1;//先将开关定义为正确的
        b[1]=i;b[2]=a[1]-b[1];//求第一个雷和第二个雷
        for (j=3;j<=n;j++){//循环接下来的雷
            b[j]=a[j-1]-b[j-1]-b[j-2];//求这个是不是雷
            if (b[j]!=1&&b[j]!=0) f=false;//同上，如果地雷不符合，就不可取
        }
        if (b[n]!=a[n]-b[n-1]) f=false;//同最后的判断，如果最后的一个地雷不符合雷数，不可取
        s=s+f; //加上方案数
    }
    cout<<s;//输出
    return 0;
} 
```
。。
#呵！简单易懂的方法
