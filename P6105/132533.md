自己做的时候漏了条重要性质……                   

首先我们知道，我们把 $x$ 都模上 $C$ 后得到的答案没有变化，由于只有两个数，所以两数之和肯定都在 $0 \sim 2 \times C - 2$ 之间，那么我们分类讨论一下：        

1. 两数之和大于等于 $C$ 。显然对于这种情况我们取集合里最大的两个数，随便维护；              

2. 两数之和小于 $C$ 。对于这种情况我们维护每个数在当前集合内的一个最优匹配，在这里定义一个数 $x$ 的最优匹配是集合中在 $[0 , C - x - 1]$ 中最大的数，最后我们的答案肯定是所有的数的最优匹配得到的结果取最大值。                 

我们将重点放在第二种情况上面，显然直接维护所有数的最优匹配是很不现实的，考虑缩小答案范围。                   

我们尝试运用一些题目特有的性质解决这个问题：            

1. 答案一定是一个这样形式的匹配贡献的值：$(a,b)$ 并且 $a$ 的最优匹配是 $b$ ，且 $b$ 的最优匹配是 $a$ 。                 

这里很好证明，我们运用反证法。如果答案不是一个这样的匹配贡献出来的值，那么 $(a , b)$ 中至少有一个数的最优匹配不是另一个数，所以找到这个数凑成的匹配得到的值一定比当前情况下的值更优，矛盾，结论得证。               

很多题解也没写到这步，也是我忽略的一条重要性质。（                        

有了这条性质后后面的东西就简简单单了。                   

2. 如果一个数 $x$ 的最优匹配是 $y$ ，$y$ 的最优匹配是 $z$ ，并且 $x < z$ 那我们就可以在考虑答案时只 $(y , z)$ 这个匹配。                      

这个比较显然，毕竟现在的两数之和都小于 $C$ ，$x + y < y + z$ 所以肯定只考虑 $(y , z)$ 这个匹配就好了。                

由于这个性质对所有在满足两数之和小于 $C$ 的匹配都适用，那么肯定也对性质 $1$ 的特殊匹配也适用，所以我们考虑维护所有的性质 $1$ 中提到的特殊匹配，很显然这些匹配的数量级始终控制在 $O(\frac{n}{2})$ 左右，比起最开始的 $O(n ^ 2)$ 不知 NB 了多少。

而且我们发现这么一挖掘，我们在插入和删除时只用考虑再增加减少各一个匹配就好了，所有操作的时间复杂度也得到保证，这道题就做完了。                  

总的时间复杂度为 $O(n \log n)$ ，但是由于寻找每个点的最优匹配常数比较大就有点卡了。


本来啊这东西写个平衡树啥的都好……虽然有点难码但是毕竟细节少，可是 Ynoi 还是得卡常，于是用 multiset 就细节多的一批还难调……建议实在调不动的朋友们看一下第一篇题解的实现。                
