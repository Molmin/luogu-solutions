~~萌新一个，第一次发题解，dalao勿喷~~~~

一看到这个题，我就想 bfs ，但看了看数据，发现bfs会GG。想了半天，再加上高人指点，终于发现这个金字塔比较特殊，因为**如果知道两点坐标，可以直接把他们的最短距离求出来。**

然后，我们就要把规律找出来。

### 首先，我们考虑两个坐标所代表的三角形都为顶角朝上或顶角朝下的情况（因为每一个三角形只有这两种情况）。

不妨设起点坐标为(sx, sy), 出口坐标为(dx, dy)，其中sx <= dx（因为从终点走到起点的距离与从起点走到终点相等）.

**CASE 1. 若两个三角形在同一列（这里的列是斜着的）**

就像两点之间线段最短一样，这是我们一定会直接朝着终点走过去，不难发现，此时的最短距离为 ** _2×(dx-sx)_ **。

**CASE 2. 若两个三角形在同一行**

走法同上，此时最短距离为 ** _|dy-sy|_ **。

**CASE 3. 若两个三角形不满足条件1和条件2**

我们该怎么办呢？因为走直线一定是最短的，我们来考虑平移。若是能把它们平移到同一行或同一列上，岂不美哉？

同时，因为我们假设终点在起点下方，所以不难证明，先将它们移到同一列的距离最短。

将平移操作分解，我们会发现就是先将终点处三角形平移到同一行的某一个三角形(mx, my)上，再平移到起点处。所以，我们只需要求出mx和my就可以了。

该怎么求呢？此时，我们又发现两个结论:

1.在像“/”这样的斜列上，任意两三角形的y坐标相等

2.在像“\”这样的斜列上，任意两三角形(x1, y1), (x2, y2)，其中x1 <= x2，则有 **_y2-y1 = 2×(x2-x1)_** 

然后，有上面两条性质，我们就不难求出mx和my了。由上式可得：

1.若dy < sy, 则有** _mx = dx，my = sy_ **

2.若dy > sy+2×(dx-sx)，则有** _mx = dx，my = sy+2×(dx-sx)_ **

于是中间点(mx, my)就求出来了。接着我们分别运用**CASE 2**和**CASE 1**的结论，就可以把最短距离求出来了。

### 其次，我们考虑两个三角形一个顶角朝上，一个顶角朝下的情况。

对于这种情况，我们可以将它们都翻转到一个方向。不难得出，每次翻转的代价都为k。然后我们就把它们变成同一个方向了，可以运用上面的结论求解。

**注意！**翻转上方的三角形和下方的三角形的代价是不一样的，一个为k，一个为-k（ _~~想一想，为什么~~_ ）

上代码（不会快读-__-|）

```cpp
#include <bits/stdc++.h>

using namespace std;

int n, m, k, s;

int calc(int sx, int sy, int dx, int dy) {
    int ans = 0;
    if(sx > dx) swap(sx, dx), swap(sy, dy); //调整位置
    if(!(sy & 1)) sx--, sy--, ans--;
    if(!(dy & 1)) dx--, dy--, ans++; //翻转操作
    if(dy > sy + (dx - sx << 1)) ans += dy - (sy + (dx - sx << 1)); //注意运算符优先级!
    if(dy < sy) ans += sy - dy;
    ans += dx - sx << 1;
    return ans * k + 1; //别忘记乘k后加1
}

int main() {
    int sx, sy, ans = 0x8f8f8f8f;
    scanf("%d%d%d%d", &n, &m, &k, &s);
    scanf("%d%d", &sx, &sy);
    for(int i = 1, dx, dy; i <= m; i++) {
        scanf("%d%d", &dx, &dy);
        int c = calc(sx, sy, dx, dy);
        if(c <= s) ans = max(ans, s - c);
    }
    if(ans == 0x8f8f8f8f) printf("-1");
    else printf("%d", ans);
    return 0;
}
```