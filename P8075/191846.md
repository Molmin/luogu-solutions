[原题传送门](https://www.luogu.com.cn/problem/P8075)

[My Blog](https://www.luogu.com.cn/blog/guicai-qq-1443870605/)

## 写在前面
本片题解详细地写了思考的过程，所以会有~~亿~~一点点长，建议慢慢阅读，也许会加深你对 DP 的理解，码字不易，感谢观看

## 观察和思考

观察数据，暴力的 $n^4$ 显然是不可行的，所以我们在计算时不可以单独一对一的计算，而是必须同时处理多个国王，第一想到的自然是 DP 动态规划。

根据套路我们首先敲定一个状态，设 $F[i][j]$ 为从 $ (0,0) $ 到 $ (i,j) $，所有国王和 $ (i,j) $ 距离的和。

思考不难发现，这个状态设置的并不全面，因为F状态只能计算到从左上所有国王到 $ (i,j) $ 的距离和，但是不排除会存在右上仍有国王，我们再套路性的设置一个状态 $G[i][j]$ 为从 $ (0,m) $ 到 $ (i,j) $ 中，所有棋子和 $ (i,j) $ 距离的和。

DP 的重点就是对状态进行转移,我们先思考 $F$ 的状态转移，因为想出 $F$ 之后，$G$ 也就迎刃而解了，学过 DP 的都知道，我们想要从已知状态 $A$ 转移到目标状态 $B$，那么要求 $A \subseteq B$（$B$ 包含 $A$ 的所有状态）。

根据这个条件，我们发现简单的从 $F[i-1][j]$ 或 $F[i][j-1]$ 推到 $F[i][j]$ 是不可行的，因为 $ (0,0) $ 到 $ (i-1,j-1) $ 中的点都没必要经过 $ (i-1,j) $ 或者 $ (i,j-1) $。

## 思考的发现
想到这里，是不是一切都那么的自然而然，实际上这个问题已经被我们解决了，就在上一行，你可能会感到疑惑，别急，听我慢慢讲。

我们已知 $ (0,0) $ 到 $ (i-1,j-1) $ 的所有点走到 $ (i,j) $ 的最短路线都不会经过 $ (i-1,j) $ 或者 $ (i,j-1) $，那么他们是不是会经过 $ (i-1,j-1) $ 呢？

仔细思考，你就会惊喜的发现居然确实如此！以此为依据，我们又可以发现 $ (i,j) $ 左边的点都会经过 $ (i-1,j) $，$ (i,j) $ 上面的点都会经过 $ (i,j-1) $（注意这里我们考虑的是 $F$ 状态，$G$ 需要考虑的是右方和上方）。

我们将 $L[i][j]$ 设置为 $ (i,j) $ 左侧的的国王和 $ (i,j) $ 距离的和。 
$U[i][j]$ 设置为 $ (i,j) $ 上方的的国王和 $ (i,j) $ 距离的和。于是我们就成功得出了一半的状态了。验证一下

$ F_{i-1,j-1}\cup L_{i-1,j}\cup U_{i,j-1}=F_{i,j}$

$ F_{i-1,j-1}\cap L_{i-1,j}\cap U_{i,j-1}=\emptyset$

简直完美的状态，形象的可以理解成下图。（蓝色为 $F[i-1][j-1]$,绿色为 $U[i][j-1]$,橙色为 $L[i-1][j]$ ，红色为 $ (i,j)$）。

![](https://cdn.luogu.com.cn/upload/image_hosting/71ilzdqa.png)

## 状态转移

对于 DP 理解较好的同学这时候已经可以开始推算状态转移方程了，因为满足
$$ F_{i-1,j-1}\cup L_{i-1,j}\cup U_{i,j-1}=F_{i,j}$$


$$ F_{i-1,j-1}\cap L_{i-1,j}\cap U_{i,j-1}=\emptyset$$


的状态设置只能用完美来形容。

那么怎么转移呢，显然光知道总距离是远远不够的，我们还得知道国王的数量，接下来就好办了，从 $ (i-1,j-1)(i,j-1)(i-1,j)$ 走到 $(i,j)$ 的步数都是 $1$，只要加上国王的数量即可。数量用前缀和的原理即可。
我们用小写字母表示数量，大写字母表示步数。

```cpp

l[i][j]=l[i][j-1]+a[i][j];//a[i][j]=1表示(i,j)有国王，0则没有
L[i][j]=L[i][j-1]+l[i][j-1];
u[i][j]=u[i-1][j]+a[i][j];
U[i][j]=U[i-1][j]+u[i-1][j];
f[i][j]=f[i][j-1]+f[i-1][j]-f[i-1][j-1]+a[i][j];
F[i][j]=F[i-1][j-1]+f[i-1][j-1]+L[i][j]+U[i][j];

r[i][j]=r[i][j+1]+a[i][j];
R[i][j]=R[i][j+1]+r[i][j+1];
g[i][j]=g[i][j+1]+g[i-1][j]-g[i-1][j+1]+a[i][j];
G[i][j]=G[i-1][j+1]+g[i-1][j+1]+R[i][j]+U[i][j];


```
最后求出
$$ \sum_{i=1}^{n} \sum_{j=1}^{m}[ a_{i,j}=1 ](F_{i,j}+G_{i,j}-U_{i,j}-R_{i,j}) $$
即可，（$U,R$ 会重复计算）。

注意最高答案会达到 $n^3m^2$，故要开 long long。

于是你就会快乐的 MLE 了（丧心病狂的空间限制）。

观察发现 $F$ 和 $G$ 必须分开做且完全独立，那么就可以让 $F$ 代替 $G$，$R$ 代替 $L$。然后收获蓝题 AC 一枚。

## 参考代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll long long
#define N 1005
#define fr(i,a,b)  for(register int i=(a);i<=(b);++i)
#define dfr(i,a,b) for(register int i=(a);i>=(b);--i)
ll n,m;
ll r[N][N],R[N][N],f[N][N],F[N][N],u[N][N],U[N][N];
ll a[N][N];
char s[N][N];
inline ll dp(ll n,ll m){
	ll ans=0;
	fr(i,1,n)fr(j,1,m){
		r[i][j]=r[i][j-1]+a[i][j];
		R[i][j]=R[i][j-1]+r[i][j-1];
		u[i][j]=u[i-1][j]+a[i][j];
		U[i][j]=U[i-1][j]+u[i-1][j];
		f[i][j]=f[i][j-1]+f[i-1][j]-f[i-1][j-1]+a[i][j];
		F[i][j]=F[i-1][j-1]+f[i-1][j-1]+R[i][j]+U[i][j];
		if(a[i][j])ans+=F[i][j];
	}
	fr(i,1,n)dfr(j,m,1){
		r[i][j]=r[i][j+1]+a[i][j];
		R[i][j]=R[i][j+1]+r[i][j+1];
		f[i][j]=f[i][j+1]+f[i-1][j]-f[i-1][j+1]+a[i][j];
		F[i][j]=F[i-1][j+1]+f[i-1][j+1]+R[i][j]+U[i][j];
		if(a[i][j])ans+=F[i][j]-R[i][j]-U[i][j]; 
	}
	return ans;
}
int main(){
	cin >> n >> m;
	fr(i,1,n){
		getchar();getchar();//本机测需要删一个
		fr(j,1,m)s[i][j]=getchar();
	}
	fr(i,1,n)fr(j,1,m)a[i][j]=(s[i][j]=='M');
	ll a1,a2;
	a1=dp(n,m);
	fr(i,1,n)fr(j,1,m)a[i][j]=(s[i][j]=='S');
	a2=dp(n,m);
	cout << a1 << " " << a2 << endl;
	return 0;
}
 
 

```