看了下题解里只有 $O((26\times n)^2)$  的 DP 和 $O(tn)$ 数学做法，这里给一个优化后 $O(26\times n^2)$ 的 DP。

首先分析题目中规定的操作，等价于求将给定的和划分为 $n$ 个 $1\sim 26$ 上的整数的方案数，严谨证明可以用数学归纳乱搞下。

容易想到 DP 的状态 $f_{i,j}$ 表示考虑到前 $i$ 个数，和为 $j$ 的方案数。然后枚举第 $i$ 位所填的数进行转移，可以得到柿子：$f_{i,j}=\sum\limits_{k=1}^{26}f_{i-1,j-k}$ 直接计算是 $O((26\times n)^2)$ 的。思考一下会发现对于 $f_{i,j},f_{i,j-1}...$，转移都需要计算 $f_{i-1,j-1},f_{i-1,j-2}...$ 等大量重叠部分的和，所以可以用前缀和优化掉一个 $26$。

考虑不使用前缀和的一种方法：还是因为上面所说的原因，想到能否直接从 $f_{i,j-1}$ 转移到 $f_{i,j}$。发现如果强制第 $i$ 位数属于范围 $[2,25]$，两者可以建立这样的一一映射：对于 $f_{i,j-1}$ 的每一种方案 $a_1,a_2...a_i$ 令 $a_1,a_2...a_{i-1}$ 不变、$a_i$ 变成 $a_i+1$ 就得到了 $f_{i,j}$ 的一种方案，限制范围 $[2,25]$ 是因为有 $f_{i,j}$ 中 $a_i=1$ 和 $f_{i,j-1}$ 中 $a_i=26$ 这两个特例，单独处理就能得到 $O(26\times n^2)$ 的柿子：$f_{i,j}=f_{i,j-1}+f_{i-1,j-1}-f_{i-1,j-27}$ 其中 $f_{i-1,j-27}$ 是指令 $a_i=26$ 时 $f_{i,j-1}$ 的方案数。

代码实现还是非常容易的：
```cpp
#include<cstdio>
#include<cstring>
using namespace std;
const int N=110,mod=1000000007;
long long f[N][N*27];
char ch[N];
int main(){
	for(int i=1;i<=26;i++)f[1][i]=1;
	for(int i=2;i<N;i++)
	for(int j=i;j<=i*26;j++){
		f[i][j]=f[i][j-1]+f[i-1][j-1];
		if(j>=27)f[i][j]-=f[i-1][j-27];
		f[i][j]%=mod;
	}
	int t;
	scanf("%d",&t);
	while(t--){
		scanf("%s",ch+1);
		int sum=0,n=strlen(ch+1);
		for(int i=1;i<=n;i++)sum+=ch[i]-'a'+1;
		printf("%d\n",(f[n][sum]+mod)%mod-1);
	}
}
```
