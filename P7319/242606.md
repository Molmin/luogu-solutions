
在比赛的时候，想的方法比较憨，两个队列模拟的，感兴趣的同学可以[点击这里](https://www.luogu.com.cn/paste/xaqd4ayp)。感谢大佬[@Zhukov](https://www.luogu.com.cn/user/342383)提出了优化方案，按照他的思路我又进行了优化，才有了如今的代码。



------------

- ### 核心信息：

若当前是第 $ i $ 次选数，选择的原始权值为 $ k $，

则其他所有未被选过的数的权值均加上 $ (-1)^{i + k + 1} \times k $ 

求出一种选数方案，使得选出的 $ n $ 个数最终的权值和最大。


------------

- ###  get 到的信息：

1. 这道题似乎是一道排序题。

2. 当前所选数经过计算后的权值会对后面的数“产生影响”。
    

如果当前选择的是第 $ i $ 个数字，那么他后面的 $ (n - i) $  个数字全都加上一个值，但是他更改的不是原始权值，既然他更改的不是原始权值，那么又跟后面的数字有什么关系呢？

也就是说，当前选择的数字对后面数字的选择并没有影响，我们便可以直接记录更改，而不是把这个更改传递到后面的数字中。

按照上面的推理，选择权值为 $ k $ 的数字，相当于在答案中再加上  $  (-1)^{i + k + 1} \times k  \times (n - i)  $ 。

而  $ (n - i) $  是递减的，所以我们要让 $ (-1)^{i + k + 1} \times k $ 大的数字往前放，这样可以保证答案尽可能大。

这样一来，问题成功的转化成了一个排序问题，关键是这个序该怎么排。




3. 加上的权值中有“ $ -1 $ ”


看到 $ -1 $ ，学过初中数学的同学都知道，指数肯定会影响这个值的正负。

上过小学的同学都知道，负负得正，所以我们要尽量让负数和负数配对，正数和正数配对，这样可以获得尽可能多的正数。以获得尽可能大的答案。

这里我们分类讨论：

![](https://web-files-1257015149.file.myqcloud.com/img/pic/luogu/p7841-1.png)

轮到每一个 $ i $ 的时候，只需要在剩余的 $ k $ 中，选择最适合自己的。


当 $ i $ 为奇数时，按照上面的表格，我们需要一个负的奇数，或者一个正的偶数，由于要求整体的乘积尽量大，所以我们需要选择绝对值最大的负奇数或正偶数。

当 $ i $ 为偶数时，我们需要一个正的奇数，或者一个负的偶数，同理， 我们需要选择绝对值最大的。

还有一个需要考虑的问题，如果选着选着，对于当前 $ i $ ，已经没有满意的 $ k $ 可以选择了，那么为了减少损失，我们只能从剩下的 $ k $ 中选择绝对值最小的了，可以让乘积减的最少！




思路大概就是这样，同学们可以先按照蒟蒻我的思路写。




------------


- ### 代码实现

由于需要奇数和偶数分开，这里我们考虑两个不同的队列，一个是适合奇数 $ i $ 的，一个是适合偶数 $ i $ 的。

刚开始我真的用了两个优先队列，多亏大佬提醒，修改成了更优化的方案。

为了方便表示，我们定义奇数 $ i $ 选择的负奇数和正偶数为 $  true $ ，也就是 $ i $ 对 2 取模的值，这样下面会方便表示。

同理，把偶数 $ i $ 喜欢的正奇数和负偶数表示为 $ false $ 。






```cpp
bool type(int x){
    return (x < 0 && x % 2) || (x >= 0 && !(x % 2));
}

```





然后我们用两个数组来表示两个队列，分别储存类型为 $ true $   和类型为 $ false $ 的 $ k $ 值。并且用 $ cnt [ 2 ] $ 来储存两个数组中数字的个数。

输入时，判断 $ k $ 值的类型，储存进入该类型的数组即可。

我为了方便写代码，直接定义的是 $ l [ 2 ] [ MAXN ] $ ，只要把 $ k $ 的类型带入第一维就可以，很方便。





```cpp
scanf("%d", &n);
    for(int i = 1, tmp; i <= n; i++){
        scanf("%d", &tmp);
        ans += (LL)tmp;
        l[type(tmp)][++ cnt[type(tmp)]] = abs(tmp);
    }
```







注意到我这里储存的是 $ k $ 的绝对值，这是因为对于该类型的 $ i $ 来说，访问到中意的 $ k $ 值，乘积的结果一定是正的。

下面我们需要进行排序，没什么好说的，降序排序，让绝对值更大的i放在前面。


![](https://web-files-1257015149.file.myqcloud.com/img/pic/luogu/p7841-2.png)


重点来了，开始选择，对于每一个 $ i $ ， 从自己的类型中选择最大的即可，由于是有序的数组，所以可以通过 $ i $ 计算出最满意的 $ k $ 在数组中的哪个位置，即 $ ((i + 1) / 2) $ ，可能稍微有点难以理解，举个栗子。

比如 $ i $ 为 $ 1 $ 时，适合的 $ k $ 一定在类型 $ 1 $ 的第 $ 1 $ 个位置。

比如 $ i $ 为 $ 2 $ 时，适合的 $ k $ 一定在类型 $ 0 $ 的第  $ 1 $ 个位置。

同理， $ 3 $ 对应类型 $ 1 $ 的 $ 2 $  位置， $ 4 $ 对应类型 $ 0 $ 的 $ 2 $  位置。就不多举例子了。






```cpp
for(int i = 1; i < n; i++){
    ans += (LL)(n - i) * (LL)l[i % 2][(i + 1) >> 1];
}
```





但是我们还忽略了一个重要的问题，就是如果当前的 $ i $ 已经没有满意的 $ k $ 了怎么办，就只能强制安排一个他不满意的 $ k $ 将就了，为了止损，我们需要选择另一类型中，绝对值最小的   $ k $ 。

可能有的小伙伴会问，抢了另一类型 $ i $ 适合的 $ k $ ，会不会导致另一类型的 $ i $ 不够选？这一点不用担心，因为 $ cnt_0 + cnt_1 = n $ 是一定成立的，所以一定可以人人配对。






```cpp
for(int i = 1; i < n; i++){
    if(cnt[i % 2] < ((i + 1) >> 1)){
        ans -= (LL)(n - i) * (LL)l[!(i % 2)][n - ((i + 1) >> 1) + 1];
    } else {
        ans += (LL)(n - i) * (LL)l[i % 2][(i + 1) >> 1];
    }
}
```






下面证明第三行的这个式子是怎么来的。

既然要减，减去的一定是从另一类型的数列中倒着数的，第一个要减的就选择倒数第一个，第二个要减的就选择倒数第二个，所以，第 $ x $ 要减的选择倒数第 $ x $ 个。

可以参考下面这张图片帮助思考。

![](https://web-files-1257015149.file.myqcloud.com/img/pic/luogu/p7841-3.png)



以下是全部代码：






```cpp
#include <iostream>
#include <algorithm>
#include <cstdio>
using namespace std;

#define abs(x) x >= 0 ? x : -x;

typedef long long LL;

const int MAXN = 1e5 + 10;

int n;
int l[2][MAXN], cnt[2] = {0, 0};
LL ans = 0;

bool cmp(int x, int y){
    return x > y;
}

bool type(int x){
    return (x < 0 && x % 2) || (x >= 0 && !(x % 2));
}

int main(){
    scanf("%d", &n);
    for(int i = 1, tmp; i <= n; i++){
        scanf("%d", &tmp);
        ans += (LL)tmp;
        l[type(tmp)][++ cnt[type(tmp)]] = abs(tmp);
    }
    sort(l[0] + 1, l[0] + cnt[0] + 1, cmp);
    sort(l[1] + 1, l[1] + cnt[1] + 1, cmp);
    for(int i = 1; i < n; i++){
        if(cnt[i % 2] < ((i + 1) >> 1)){
            ans -= (LL)(n - i) * (LL)l[!(i % 2)][n - ((i + 1) >> 1) + 1];
        } else {
            ans += (LL)(n - i) * (LL)l[i % 2][(i + 1) >> 1];
        }
    }
    cout << ans;
    return 0;
}
```



