## 较经典的冒泡排序题

~~看到简短的题目描述，断定这是一道水题（确实是水色的）~~

有的蒟蒻看到这题一定很高兴，然后~~很偷懒~~很自然地想到了sort，就开始敲代码

然而敲到一半会发现，**光用sort很难解决编号的问题**

于是乎，还是老老实实敲冒泡吧

不得不说，冒泡倒是确实要用，但这概率论好像和这题没啥关系吧

开一个数组存储a[i]的编号就可以解决编号的问题了

```
#include<iostream>
#include<cstdio>
using namespace std;
int a[1001],b[1001],n;
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		scanf("%d",&a[i]);
		b[i]=i;//b[i]用来存储每个a[i]的编号，也就是位置
	}
	bool p=false; //这是用来优化冒泡排序的
	for(int i=1;i<=n;i++){//优化过的冒泡排序部分（核心代码）
		for(int j=i+1;j<=n;j++)
		if(a[i]>=a[j]){//这里决定了排序是从小到大还是从大到小，我这里是从小到大
			swap(a[i],a[j]);//这里是原本的冒泡方法，很好理解
			swap(b[i],b[j]);//当两个a需要交换时，将编号也随之交换，这样就保证每个a对应的b保持不变
            p=true;
        }
        if(p==false)break;
	}
	printf("%d %d\n",b[n],a[n-1]);//输出第一大的编号和第二大的值
	return 0;
}
```
~~自我感觉比较短~~

比较易懂，而且数据再大点的话把数组开大就行了，毕竟是优化过的

这种方法可以得到每一个数的排序和对应编号，比较推荐