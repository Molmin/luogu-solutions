~~~~ 
其实，这道题是贪心的入门题，，，
	题目大意就是让奶牛吃的花尽量少，因为送一头奶牛回家就相当于你要来回跑两次，所以，后面的注意一下就好了，在这个地方提示一下，代码有一点小问题，真正懂的人一眼就能看出来。
废话不多说了，进入正题：
	考虑这个贪心的决策，首先，考虑，假设A和B两头奶牛交换位置是否会有影响，很显然，是没有的，，每一头奶牛就吃自己的，和你的其他奶牛是没有影响的，然后，就可以愉快的用结构体记录一下他们的距离和每一个单位时间吃多少花，拿一个变量记录一下所有的奶牛在1秒内能吃多少花，
强行sort排序一遍，，，，
	然后，，愉快的进行加减法，，还有乘法，，最后，，输出，，注意一下ans要开long long 数组要100010，没了，，很简单愉快。
上代码，，繁琐难看（jian jie ming liao）
 
                       华丽丽的分割线
------------------------------------------------------------
********************************************
#include<bits/stdc++.h>
using namespace std;
int n,sum;
long long ans;
struct node{
	int t,d;
}cow[100010];
bool cmp(node a,node b){
	return a.t*b.d<a.d*b.t;
}
int main(){
	scanf("%d",&n);
	for (int i=1; i<=n; i++){
		scanf("%d%d",&cow[i].t,&cow[i].d);
		sum+=cow[i].d;
	}
	sort(cow+1,cow+n+1,cmp);
	for (int i=1; i<=n; i++){
		sum-=cow[i].d;//减去你每一次送回去的奶牛每一秒吃的量
        //得到的就是你当前还剩下多少奶牛，每一秒吃的总量。
		ans+=sum*cow[i].t;//拿你的每一秒剩下的奶牛吃的量乘以你送回去的时间。
	}
	printf("%lld\n",ans);//仔细看看，，是不是有一点错？
	return 0;
}
*********************************************
~~~~