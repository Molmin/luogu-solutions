这是很好的一道平闰年的题目

（内含优化过程与拓展）

我们先来观察规律

因为五月第一个周日可以在 1号 到 7号 任何一天

那么五月第二个周日可以在 8号 到14号 任何一天（在上面基础上加7）

观察近十年的日期：

年份---------母亲节是五月( )日

*(2020)------10

2019---------12

2018---------13

2017---------14

*2016--------8

2015---------10

2014---------11

2013---------12

*2012--------13

2011---------8

2010---------9

2009---------10

......

我们发现随年份递增（上面的表格要从下往上看），母亲节的日期大致呈

14 13 12 11 10 9 8 14 13 12......

的规律循环，但个别年份变化不遵循规律，准确的说，是跳过了数列的一个项。

这些年份用 星号 标出，不难发现这些特殊年份恰好是闰年

看日历我们知道1911年母亲节在14号（从题中给的2019年母亲节在12号也可以推出，确切地说，知道任何一年都可以）

我们把上述序列 14 13 12 11 10 9 8 14 13 12......称作数列A，

那么若第i年的母亲节在五月x日，第j（j>i）年的母亲节在五月y日，其中x是A的第k项，
那么y是A的第k+（j-i）+（i到j有多少闰年）项。

要好好理解上一句话，（j-i）是普遍规律，（i到j有多少闰年）是多跳过的项数


```cpp
#include <iostream>
using namespace std;
int p[7]={14,13,12,11,10,9,8};//所有可能的日期情况
int q(int L,int R)//求L到R的闰年个数
{
	int ans; 
	for(int i=L;i<=R;i++)
	if(i%4==0)//本题数据跨度较小，不需要考虑世纪闰年的情况，
              //所以判断条件比较简单。
	ans++;
	return ans;
}
int main()
{
	int year;cin>>year;
	cout<<p[((year-1911)+q(1911,year))%7];
    //因为1911年母亲节是14号，是数组第0项，所以求得答案直接模7
	return 0;
}
```

以上代码时间复杂度是O（n），可以过本题，如果让求很多年以后则会超时。

推荐个人题目：[母亲节（历史行程加强版）](https://www.luogu.org/problemnew/show/U72805)

Q函数可以优化，求【L，R】范围内x的倍数的个数，可能会首先想到

（R-L）/x

这个式子，但是不难发现这个式子的结果有时是正确答案，有时差1；

换个角度，我们用1-R范围内x的倍数的个数减去1-L范围内x的倍数的个数，这样就会得到

R/x-L/x

这个式子，本题中x=4。（当然如果你是大佬你会直接想到这个式子）

这样的话就可以省略函数部分，直接带入,q(1911,year)就变成year/4-1911/4，即year/4-477，然后可以发现数组都免了，因为p[i]
和i就是和为14的关系，比如p[3]=11，p[6]=8等，

最后八行代码解决这道题目

AC代码：
```cpp
#include <iostream>
using namespace std;
int main()
{
    int year;cin>>year;
    cout<<14-((year-1911)+year/4-477)%7;	
    return 0;
}
```
