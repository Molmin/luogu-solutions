## P5407 [THUPC2019]历史行程
### 题意
输入1913~2019之间的一个年份，输出这一年的母亲节是5月几日。

------------
### 思路
#### ~~打表~~

不会有人没有想到打表吧，不会吧不会吧不会吧？

不过，本蒟蒻实在懒得查日历或用Excel打表，因此敲了个程序打表~~虽然感觉这个更累~~。

那么其实还是要找规律QAQ。


------------

#### 现在要输出每年的母亲节日期用来打表

- 首先要清楚，2018年的母亲节是13日，那么365天后的2019年5月13日，是母亲节吗？显然不是，因为母亲节虽然接近跨年，但是是用**星期**算的。因此母亲节的周期不是356天（或366天），而是**接近365的一个7（一星期为7天）的倍数**。那么不难试出，这个数是：**7*52=364**。也就是说，一般情况下，前后两个母亲节之间相差364天。而两个日期相差1（365-364=1）或2（366-364=2）天，如：2018年的母亲节是13日，2019年的母亲节是12日。

- 然后，要考虑特殊情况。母亲节必须是**第二个星期日**，但我们知道年周期总与母亲节周期相差1（365-364=1）或2（366-364=2）天。这就意味着，在某个母亲节的364天后的这天，由于周期的偏差，**不再是第二个星期日，而成为了第一个星期日**。这时，就需要找到第二个星期日，并且从这个星期日开始，继续364天一周期的母亲节，直到某个364天后，又变成了第一个星期日......如此循环往复，直到2019年。

- 最后要说的就是平润年的问题，前面的叙述中已经把平润两种可能都写上了。代码中只需要加个判断。它们的差别主要在于，两者周期与母亲节周期相差的天数不同，所以需要做的运算也略微不同。

那么上代码，具体的操作在其中也有解释：
```
#include<bits/stdc++.h>
using namespace std;
int main()
{
	int n=4,day=11; // 查1913的日历可知，日期差n=4天就不再是第二个周日；这年的母亲节是day=11日 
	bool b ;// 记录平or润年 
	for(int i=1914;i<=2020;i++){
		b=1; // 每次初始化为1 
		cout<<day<<","; // 先输出，所以是1914~2020的循环 
		
		if(i%100==0&&i%400==0) // 判断是否是闰年 
			b=0; // 是闰年则赋为0 
		else if(i%4==0)  // 同上 
		 	b=0; 
		 	
		if(b) // 平年 
			day--,n--; // 与母亲节周期差1天，日期与差减1 
		else // 闰年 
			day-=2,n-=2; //与母亲节周期差2天，日期与差减2
			
		if(n<=0)// 如果日期差0天就不再是第二个周日（已经变成了第一个周日）
			n+=7,day+=7;//寻找第二个周日，日期和差加一星期 
	}
	return 0;
}

```
然后把输出复制过来，打表完成！！（鼓掌掌）


------------
打表代码就不发了，别的题解都有。~~主要是本蒟蒻太懒，写完这些已经心力交瘁，停止思考。~~

这篇题解就到这里。（卑微蒟蒻求过）