## 废话

这里提供一个稍微简单一些的解法。~~我看别的题解都好长啊~~

## 题目大意

就是给出一系列在一根数轴上的点，以相邻两个点为直径向上做一个半圆，问是否存在两个半圆在数轴上方有相交的情况。

## 题目分析

要想在数轴上方相交，那么两个区间一定在数轴上是有交集的（显然）。

所以在处理的时候我们把相邻的两个点放进结构体存储，然后直接暴力枚举两个半圆，判断它们在数轴上的区间有没有相交即可。

具体在判断的时候的过程如下：

首先第一维循环$i$从$1$到$n$，接着第二位$j$也是从$1$到$n$，这两个变量$i,j$分别枚举两个半圆，也就是四个点，在判断是否相交的时候方法是：我们设$u_i(左端点),v_i(右端点)$代表的是由变量$i$枚举到的点对，$u_j,v_j$同理，既然是要相交，那么肯定某一个点对中的右端点要大于另一个点对中的左端点，**但是这样还不够，有可能一个区间整个在另一个区间的左侧或右侧或者两个区间存在包含关系**，知道了特例情况，我们就可以写出限制条件：$u_i<u_j$并且$v_i>u_j$前两个条件保证了两个区间一定有交集，但是存在包含关系还无法处理，这是再加一个条件：$u_i<v_j$这样就保证了没有包含的情况。

## 放一下我丑陋的代码，码风奇丑，大佬勿喷

```cpp
#include <bits/stdc++.h>
using namespace std;
struct node{
    int l,r;
}a[100010];
int main(){
    int n;
    while(cin>>n){
        int x,last,cnt = 0;
        cin>>x;
        if(n == 1){//特盘如果只有一个点对（半圆）则肯定没有交集
            cout<<"no"<<endl;
            continue;
        }
        last = x;
        for(int i = 2;i <= n;i++){//输入
            cin>>x;
            a[++cnt].l = min(last,x);//防止题目挖坑，保证左端点一定小于右端点
            a[cnt].r = max(x,last);
            last = x;
        }
        bool flag = 0;
        for(int i = 1;i <= cnt;i++){//枚举点对
            for(int j = 1;j <= cnt;j++){
                if(a[i].l < a[j].l && a[i].r < a[j].r && a[i].r > a[j].l){//如果枚举到两个点对有交集就直接输出
                    cout<<"yes"<<endl;
                    flag = true;
                    break;
                }
            }
            if(flag)break;
        }
        if(!flag){//如果把所有的点对都枚举完了还没有出现有交集的情况，则认定为没有交集
            cout<<"no"<<endl;
        }
    }
    return 0;
}
```

