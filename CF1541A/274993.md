提供一篇 Python 题解。

首先考虑一下这个数列，由这么两个要求：

1. 在第 $i$ 位的数字不能是 $i$。
2. 要求每个数字 $i$ 所在的位置与第 $i$ 位置的距离之和最小。

我们可以思考到：**既然距离为 $0$ 的位置不能取，那么可以取距离为 $1$ 的位置。**

所以一种最简单的方式是，直接将数列中相邻的彼此两位调换顺序。

比如数列 $[1, 2, 3, 4]$，可以换为 $[2, 1, 4, 3]$，这样**四个元素的距离都为 $1$。由于距离不能为 $0$，那么显然这个数列的距离之和最小，符合条件。**

但是这个只对有偶数个元素的数列有效，考虑奇数个元素的数列。

设这个数列的元素为 $1, 2, ..., 2k + 1$

我们不妨还是先把前 $k - 1$ 对元素按上面的方式处理，剩下 $2k-1, 2k, 2k+1$ 三个元素，只考虑这三个元素。

我们可以知道，这三个元素的位置必须全部都要更换，所以我们可以列出所有更换后的情况。

| $2k, 2k+1, 2k-1$ |
| :----------: |
| $2k+1, 2k-1, 2k$ |

然后我们惊奇的发现，这所有两种情况更换后的**位置差和相同为 $4$**。

所以我们的解法得到了：

1. 对于偶数数列，把每对元素进行交换。
2. 对于奇数数列，留出三个元素做上述变换，其余对元素进行交换。


Code:

```python
# !/usr/bin/python3.7


def main():
    t = int(input())
    for i in range(t):
        n = int(input())
        if n & 1 == 0:
            for i in range(1, n + 1, 2):
                print(i + 1, i, sep=" ", end=" ")
            print()
        else:
            for i in range(1, n - 2, 2):
                print(i + 1, i, sep=" ", end=" ")
            print(n, n - 2, n - 1, sep=" ")
       

if __name__ == "__main__":
    main()
```