### 题目大意

将 $a_i=i$ 重新排列形成排列 $p$，使得 $(\sum_{i=1}^n[p_i==a_i])=0$ 且使 $(\sum_{i=1}^n|p_i-a_i|)$ 的值最小。


### 数据范围

$1 \leq t \leq 100,2 \leq n \leq 100$。

### 做法

考虑到要让这个排列与原来完全不重合（即没有任何一个数与原来的排列在同一个位置上），我们进行分类：

若 $n$ 为偶数，那么我们可以把 $(1,2),(3,4),\cdots,(n-1,n)$ 这 $\dfrac{n}{2}$ 个组内的数交换，即变成 $(2,1),(4,3),\cdots,(n,n-1)$。这样不仅可以保证数列与原来的数完全不重合，而且每个数仅移动了一次，满足题意。

若 $n$ 为奇数，我们可以把前三个数按照 $(3,1,2)$ 的方式排列，对于剩下的 $n-3$（为偶数）个数就按照上面的方法构造即可。

至于为什么前三个数是 $(3,1,2)$ 的方式排列，这个可以从样例读取出来。

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int T;
int main(){
	cin>>T;
	while(T--){
		int n;
		cin>>n;
		if(n%2==0){
			for(int i=1;i<=n;i+=2) cout<<i+1<<" "<<i<<" ";
			cout<<endl;
		}
		else{
			cout<<"3 1 2 ";
			for(int i=4;i<=n;i+=2) cout<<i+1<<" "<<i<<" ";
			cout<<endl;
		}
	}
}
```
