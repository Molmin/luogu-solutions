[在我的博客中查看](https://158593.blog.luogu.org/solution-cf1355f)

# 题意
要求猜一个$1$到$10^9$之间的一个数$X$。

你可以询问一个数$Q$（$1\le Q\le10^{18}$），然后读取到$\gcd(X,Q)$。

在不多于$22$次猜测，得到$X$的质因数个数。

注意：设你的答案为$d$，标准答案为$ans$，只要满足$|ans-d|\le7$或$\frac12\le\frac{ans}{d}\le2$即算正确。

输入格式：

询问："? Q"；猜测："! d"。（注意每次输出后要刷新缓冲区）。

# 个人的做法
既然每次返回$\gcd$，可以利用$\gcd$来得到原来的数的因数。

根据**唯一分解定理**，可设$X=\prod_{i=1}^{n}p_i^{a_i}$，则因数个数为$\prod_{i=1}^n(a_i+1)$。

## 方法一
每次询问问$p_i^{a_i}$，且$p_i^{a_i+1}>10^9$。

e.g.
```
? 536870912			//=2^29（注意这里的"^"是乘方的意思）
? 387420489			//=3^18
? 244140625			//=5^12
```
要在$22$次以内，就只能问到$79$，不可取。

因为$Q\le10^{18}$，可以问$2^{29}\times3^{18}$，但这样也只能问到$139$，无法判别。
## 方法二
“方法一”中的大量询问都会返回$1$，考虑优化这个方法。

每次询问$\prod_{i=last+1}^k{p_i}$，其中$last$指上次询问的$k$，而且$\prod_{i=last+1}^{k+1}{p_i}>10^{18}$，例如第一次询问为

$2\times3\times5\times7\times11\times...\times47=614889782588491410$

如果答案有2这个因数，问$2^{29}$（也可以两个因数一起问），返回$2^w$，那么这个数就有$2$这个因数，且次数为$w$（令$ans$为已知的约数个数，例如知道$2^{19}$后，$ans=19+1=20$）。（这样的询问不会超过$9$次，而且越往后次数越少）

然后可以询问$53\times59\times...\times83$，按照类似的方法。（此次询问$p_i^{a_i}$最多只要$5$次，因为$53\times59\times61\times67\times71\times73>10^9$）

一些解释：

1. 当询问到一个数$X$后（例如第一次后为$47$），如果下一个质数为$p'$，那么若**剩下的数**（指$10^9$除以已知的质因数及其次数，例如已知$2^2$，那么“最大的数”即$2.5\times10^8$）$X'$满足$X'<p'^3$，即可直接输出$2~ans$，因为$X'$一定是由大于等于$p'$的两个质数相乘（**或单独一个质数，或者$X'=1$**）得到，答案为$ans$或$2~ans$或$4~ans$，输出$2~ans$即可。
2. 枚举到$631$剩下的数大于$p'^3$时，分两组情况：如果$ans=1$或$ans=2$，剩下的数最多由$3$个质数相乘，因数个数最多为$2\times8=16$，最少为$1$，输出8即可；否则就输出$2~ans$，因为当$ans>2$时，剩下的数最多为$2\times10^8$，而$631^3=‭251239591‬$，所以最多是由$2$个质数相乘的，1. 中已解释。

## Code

```cpp
#include<iostream>
#define ll long long
using namespace std;
const ll q[22]={2ll*3*5*7*11*13*17*19*23*29*31*37*41*43*47,//每次询问 
				53ll*59*61*63*67*71*73*79*83,
				89ll*97*101*103*107*109*113*127,
				131ll*137*139*149*151*157*163,
				167ll*173*179*181*191*193*197,
				199ll*211*223*227*229*233*239,
				241ll*251*257*263*269*271*277,
				281ll*283*293*307*311*313*317,
				331ll*337*347*349*353*359*367,
				373ll*379*383*389*397*401,
				409ll*419*421*431*433*439,
				443ll*449*457*461*463*467,
				479ll*487*491*499*503*509,
				521ll*523*541*547*557*563,
				569ll*571*577*587*593*599,
				601ll*607*613*617*619*631};
const ll cnt[22]={53,89,131,167,199,//每次询问最大的质数的后面一个 
				241,281,331,373,409,
				443,479,521,569,601,
				641};
const ll prime[205]={2,3,5,7,11,13,17,19,23,29,//质数表 
					31,37,41,43,47,53,59,61,67,71,
				73,79,83,89,97,101,103,107,109,113,
				127,131,137,139,149,151,157,163,167,173,
				179,181,191,193,197,199,211,223,227,229,
				233,239,241,251,257,263,269,271,277,281,
				283,293,307,311,313,317,331,337,347,349,
				353,359,367,373,379,383,389,397,401,409,
				419,421,431,433,439,443,449,457,461,463,
				467,479,487,491,499,503,509,521,523,541,
				547,557,563,569,571,577,587,593,599,601,
				607,613,617,619,631,641,643,647,653,659};
int main(){
	ll t;cin>>t;
	for(ll ans,now,mx;t;--t){
		ans=1,now=0,mx=1000000000;
		for(ll i=0,gcd;i<16;++i){
			cout<<"? "<<q[i]<<endl,cin>>gcd;//询问 
			for(ll g;prime[now]<cnt[i];++now)
				if(gcd%prime[now]==0){
					ll num=1,que=1;cerr<<prime[now]<<endl;
					while(que<mx)que*=prime[now];//计算存在的质因数的次数（e.g. 2^29） 
					cout<<"? "<<que<<endl,cin>>g,mx/=g;//此处是大于1e9的最小数 
					while(g%prime[now]==0)++num,g/=prime[now];//得到次数 
					cerr<<num<<endl;//注：cerr会输出到标准错误输出流，
					//不会被交互程序读取，但是在本地运行时可以看见 
					ans*=num;
				}
			if(mx<cnt[i]*cnt[i]*cnt[i]){//X'>p'^3 
				cout<<"! "<<ans*2<<endl;
				goto N;//跳过跳过后面的特判 
			}
		}
		if(ans==1 || ans==2)cout<<"! 8"<<endl;//绝对值之差小于等于7 
		else cout<<"! "<<ans*2<<endl;N:;//答案在标准答案的二分之一到两倍之间 
	}
}
```

**虽然你用这个代码可以AC，但请不要抄！**