这一道题其实算是一道数学题，虽然不涉及什么算法，但是还是需要仔细思考一下。  
读入数据后，我们先将它们排个序：
```cpp
int a,b,c;
scanf("%d%d%d",&a,&b,&c);
if(b > c)swap(b,c);
if(a > b)swap(a,b);
if(b > c)swap(b,c);
```
排完序后，我们可以模拟一遍这个过程： 

假设第一步先动$c$,为了能走尽可能走多的步数，我们应将其放在$a+1$或$b-1$的位置。  
重复上述这个过程(此时先动$a$还是先动$b$已经无所谓了，答案是一样的)，我们可以发现，它最终能走$b-a-1$步，因为$(a,b)$区间里每一个点都走了一遍。  

同理，假设第一步先动了$a$，我们将其放在$b+1$或$c-1$的位置，重复上述过程后，共走了$c-b-1$步，因为$(b,c)$区间里每一个点都走了一遍。  
现在我们在两个答案里取最大值即可。
```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	int a,b,c;
	scanf("%d%d%d",&a,&b,&c);
	if(b > c)swap(b,c);
	if(a > b)swap(a,b);
	if(b > c)swap(b,c);
	printf("%d\n",max(b-a-1,c-b-1));
	return 0;
}
```
回顾刚才的思考过程，我们实际上是利用了贪心的思想，尽可能走多的步数(也就是对当前情况最有利的操作)，从而取得全局的最优解。  
$the$ $end.$