~~看题解，听98k啊~~

这道题目我认为用**矩阵压缩**和**前缀和**来处理是比较~~方~~(fan)~~便~~(suo)易懂的 

首先呢，明白一个道理：怎样才叫做矩阵压缩（降维）？  
矩阵压缩呢，我举一个例子你也许就懂了  
对于这道题目的样例矩阵  
0 -2 -7 0  
 9 2 -6 2  
-4 1 -4  1   
-1 8  0 -2  
那么，对于这4*4的矩阵

我们先看第一行  
0 -2 -7 0  
用dp或者前缀和知识求出该行的最大子段和  
然后和第二行合并，把两行的值相加，得  
9 0 -13 2  
然后求出该行的最大子段和  
接着，该行与第三行合并  
然后与第四行合并  
第一行与其他行合并完后，第二行继续  
以此类推

然后每次的最大子段和的最大值即为题目所求（这个结论非常容易证明，请读者自行证明）

所以，矩阵压缩时这样打
```cpp
for(i=1;i<=n;i++)//每一行
	{
		memset(b,0,sizeof(b));//b数组用来保存每次的累加值
		for(j=i;j<=n;j++)//从当前行开始一直往下累加求值
		{
			for(k=1;k<=n;k++)
			b[k]+=a[j][k];//累加当前这一行
			maxn=max(maxn,xhr(b,n));//xhr是计算最大子段和的函数，每次的最大子段和都保存在maxn最大值中
		}
	}
```

最后输出maxn即可

程序奉上：
```cpp
#include<cstring>
#include<iostream>
using namespace std;
int n,a[121][121],b[1001],maxn=-0x7fffffff;//因为矩阵里面有负数，所以要开-0x7fffffff
int xhr(int s[],int list)//前缀和知识求最大子段和
{
	int i,ans,res,minn;
	ans=res=minn=0;//一定要初始化，不要忘了
	for(i=1;i<=list;i++)
	{
		ans+=s[i];//累加当前的元素值
		res=max(res,ans-minn);//保存最大值与最小值的最大差（所求的最大子段和）
		minn=min(minn,ans);//保存最小值
	}
	return res;//输出最大值与最小值的差
}
/*
在此插入上面用前缀和知识求最大子段和的原理
对于一个序列a，令从第1个元素到第i个元素的和为s[i]，从第1个元素到第j个元素的和为s[j]，其中j>i，那么从i到j的元素和为s[j]-s[i]
如果要使该值大
那么要s[j]大，s[i]小
所以在O(n)的时间复杂度内不断更新最大值、最小值即可求出最大子段和
*/
int main()
{
	int i,j,k;
	cin>>n;
	for(i=1;i<=n;i++)
	for(j=1;j<=n;j++)
	cin>>a[i][j];
	for(i=1;i<=n;i++)
	{
		memset(b,0,sizeof(b));//每次累加前要先初始化为零
		for(j=i;j<=n;j++)
		{
			for(k=1;k<=n;k++)
			b[k]+=a[j][k];//矩阵压缩
			maxn=max(maxn,xhr(b,n));//保存每次压缩的最大子段和
		}
	}
	cout<<maxn<<endl;//输出最大值即可
	return 0;
}
```