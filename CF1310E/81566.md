# CF1310E Strange Function

我们初看此问题时可能会毫无头绪，不知道怎么设计状态及转移。这启发我们逐步分析问题。我们应该会想到对 $k$ 进行讨论

### $k=1$

相当于我们要统计每个数在 $A$​ 集合里出现了多少次，设求出来的集合为 $B$​ 。而我们知道 $\sum_{x\in B} x=|a|$​ ，且 $B$ 内部无序，所以问题被转化为了求 $\forall_{1\leq i\leq n} i$ 的**划分数** ，简单的 dp 一下就行了。

```cpp
f[0]=1;
for(int i=1;i<=n;++i)
    for(int j=i;j<=n;++j) (f[j]+=f[j-i])%=MOD;
for(int i=1;i<=n;++i) (ans+=f[i])%=MOD;
printf("%d\n",ans);
```

### $k=2$

我们沿用 $k=1$ 时的定义，且设 $C=f(B)$ 。我们尝试着用 $C$ 去推到一个可能的 $A$ 。设 $C=\{c_1,c_2,\dots c_m\}$ ，且 $c_1\geq c_2\geq \cdots \geq c_m $ 。并设 $c_i$ 在 $B$ 中作为 $v_i$ 的出现次数，那我们只要能找到一组 $\{v_i\}$ ，使得 $\sum_{i=1}^m c_iv_i \leq n$ 成立即可。换句话说 我们要在 $C$ 已知的情况下最小化 $\sum_{i=1}^m c_iv_i$ 。根据排序不等式，有 $\sum_{i=1}^m c_iv_i \geq \sum_{i=1}^m c_ii$ 。于是问题被我们转化成了如下问题：

>  给定 $n$​​​ ，求有多少满足条件的 $\{c_i\}$​​​ ，满足 $c_1\geq c_2\geq \cdots \geq c_m $​​​ ，且 $\sum_{i=1}^m c_ii \leq n$​​​ ​

对于该问题，我们先对所有数减去 $c_m$​ ，然后对剩下的所有数减去 $c_{m-1}$ ，以此类推，问题又被我们进一步转化：

> 给定 $n$ ，求有多少满足条件的 $\{c_i\}$ ，满足  $\sum_{i=1}^m c_i\frac{i(i+1)}{2} \leq n$ 

又是简单 dp

```cpp
f[0]=1;
for(int i=1;i*(i+1)/2<=n;++i)
	for(int j=i*(i+1)/2;j<=n;++j) (f[j]+=f[j-i*(i+1)/2])%=MOD;
for(int i=1;i<=n;++i) (ans+=f[i])%=MOD;
printf("%d\n",ans);
```

### $k \geq 3$

当 $k \geq 3$ 时问题变得更复杂了（当然您可以尝试着推一下 $k=3$ 时的 dp ），但我们没有注意到的一点是：当 $n$ 一定时，$k$ 越大 答案越小。设 $k=3$ 时$f^k(A)$ 里的元素和为 $m$ ，我们尝试最小化当前的 $n$ 。对于 $k=2$ 这一层，要想令当前的和最小，那一定是填 $m$ 个 $1$ 最优，则对于 $k=1$ 就只能填 $\{1,2,\dots,m\}$ 其和为 $\frac{m(m+1)}{2}$ 也就是我们最小化的 $n$ 。将 $n=2020$ 代入，解得 $m \leq 64$ 。也就是说，当 $k\geq 3$ 后，其元素和至多为 $64$ 。$64$ 的划分数 $\mathscr{P}(64)=12308138$ ，我们暴力枚举其所有划分，看其对应的 $A$ 的最小值是否小于 $n$ 即可。

暴力代码就不放了

