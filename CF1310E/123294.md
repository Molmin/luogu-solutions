Update on 2022.11.20 重写题解，原题解见 [剪贴板](https://www.luogu.com.cn/paste/abfnhowu)。

[CF1310E Strange Function](https://www.luogu.com.cn/problem/CF1310E)

直接枚举初始集合 $S$ 并对 $f ^ k(S)$ 去重不太可行，转而考虑枚举 $T = f ^ k(S)$ 并检查是否存在 $S$ 使得 $|S| \leq n$ 且 $f ^ k(S) = T$。

考虑从 $T$ 一步步反推得到一个合法的 $S$。因为对 $S$ 的限制 **只有大小不大于 $n$**，所以我们可以尝试求出 $|S|$ 的最小值 $z$。若 $z\leq n$，则 $T$ 合法，否则 $T$ 不合法。

考虑解开一层 $f$ 的过程 $T = f(S)$，设 $T = \{t_1, t_2, \cdots, t_u\}$，则 $S$ 必须包含 $t_i$ 个 $c_i$ 且 $c_i$ 互不相同，即 $|S| = \sum t_i$。可以发现每次解开一层 $f$，$T$ 的大小就会变成它包含的元素之和。自然地，我们希望 $S$ 的元素尽量小。最优方案是将 $t_i$ 从大到小排序后令 $c_i = i$，容易证明这种方案形成的 $S = \{s_1, s_2, \cdots, s_v\}$ 比其他任何方案形成的 $S' = \{s'_1, s'_2, \cdots, s'_{v}\}$ 都要 **严格不劣**，即 $s_i\leq s'_i$，因而保证最终 $|S|$ 的最小性。

换言之，$f$ 是多对一的，我们无法找到其反函数 $f ^ {-1}$。但我们找到了一个解开 $f$ 的方案 $g$，使得最终的 $T$ 在 $k$ 次解开 $f$ 之后得到的 $S = g ^ k(T)$ 满足其为使得 $T = f ^ k(S)$ 的 $|S|$ 最小的 $S$。因此，直接枚举 $T$，若 $|g ^ k(T)| \leq n$ 则合法。

当 $k = 1$ 时，可知 $|S| = \sum t_i$，因此答案即不大于 $n$ 的数的划分数之和，$\mathcal{O}(n ^ 2)$ 计算。

当 $k = 2$ 时，可知 $|S| = \sum it_i$，直接枚举 $i$ 和 $t_i$ DP。因为 $i(i + 1) \leq 2n$ 所以时间复杂度 $\mathcal{O}(n ^ {2.5})$。另一种思路是根据 $t_i\geq t_{i + 1}$ 设 $d_i = t_i - t_{i + 1}$，这样就可以忽略 $t_i\geq t_{i + 1}$ 的要求少记录一维。考虑 $d_i$ 对 $|S|$ 产生的贡献，发现相当于为 $t_1\sim t_i$ 加上 $d_i$，贡献即 $d_ii(i + 1) / 2$。相当于有若干种物品，第 $i$ 种物品的重量为 $i(i + 1) / 2$ 且有无限个，求选择物品使得重量总和 $\leq n$ 的方案数。这是一个类似 $k=1$ 求划分数的完全背包，可以 $\mathcal{O}(n ^ {1.5})$ 带走。

当 $k = 3$ 时，推一推发现贡献和 $t$ 的后缀和有关，很不可做。但我们在做题时应当感受到 $f$ 函数坍缩很快，所以 $T$ 的方案数应该不会太多。这启发我们写个爆搜，判断是否有 $|g ^ k(T)| \leq n$。为了防止在判断过程中浪费太多时间，考虑到我们可以快速求出 $|g ^ 2(T)|$，所以不妨判 $|g ^ 2(T)|$ 而不是 $|g(T)|$。只需进行 $k - 2$ 次令 $T = g(T)$ 并判断是否有 $|g ^ 2(T)| \leq n$。对于 $n = 2020$ 的极限数据，它也能在时间范围内得到解。实际上判 $|g ^ 3(T)| \leq n$ 可以更快，因为它保证了任意时刻 $|T| = \mathcal{O}(\sqrt n)$，但 $|g ^ 3(T)|$ 的表达式较复杂。

对于 $k > 3$，限制只会比 $k = 3$ 更严格，符合条件的 $T$ 大幅减少，上述爆搜可以更快得到解。

时间复杂度上界：注意到 $|g ^ 2(T)| \geq |T|(|T| + 1) / 2$，所以当 $k = 3$ 时，$|g(T)| \leq 62$，$T$ 的方案数上界为 $1\sim 62$ 的划分数之和，在 $10 ^ 7$ 级别。很多不合法的方案都被跳过了，所以实际检查次数很少。

[代码](https://codeforces.com/contest/1310/submission/181679879)。