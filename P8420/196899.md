这个错误值看起来就很假，明显可以预处理出来每一位填 0 或者 1 的错误值贡献。

这样问题变为了你需要确定一个 01 串，每位填 0 或者 1 都有不同的代价，你需要让代价最小，同时不能是某些串。

这个是很套路的 dp：对所有不能出现的串建立 Trie 树，不能是某些串的限制就变为了不能到 Trie 的某些节点。

然后设 $f_{i,j}$ 表示长度为 $i$ 的串，匹配到 Trie 节点 $j$ 的最小代价。枚举下一位字符转移即可。

复杂度看起来是立方，实际远远跑不满，可以通过。

这个是赛时做法，赛时代码找不到了，不放了。