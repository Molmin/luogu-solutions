## 一道思维题

这道题可谓是在Div.2A里算一道很难的题了，我想了足足$10$分钟才想出正解。

### 题意：
有两个01字符串$a$和$b$，如果把每个字符串看作一个二进制数的话，都会对应一个十进制数。字符串$s$对应的十进制数记作$f(s)$。你要求出满足要求的非负整数$k$，使得$f(a)+2^k*f(b)$转化为二进制后反序的字典序尽可能小。题目包含多测。

### 思路：
首先，我们知道，乘$2$的$k$次方其实就是在二进制数后面添$k$个$0$，而如果要让反序的字典序尽可能小，那么最后一位就要尽可能小，在满足这个的前提下，倒数第二位也要尽可能小，以此类推。
我们假设$b$的后$x$位全部都是$0$，而从右往左数第$x$位为$1$。那么$k$不论取什么值，$f(a)+2^k*f(b)$的后$x$位永远不会发生改变，永远与$a$的后$x$位相同。此时，如果第$a$的第$x$位为$1$，那么我们就不用添$0$了，已经取到了最优解。而如果如果第$a$的第$x$位为$0$，那么$f(a)+2^k*f(b)$的第$x$位为$1$，不是我们想要的。此时我们就要在$b$的后面添上一个$0$，然后重复上述操作。

简单来说，假设$b$最右边一个$1$是从右往左数第$x$位，那么本题要求的答案就是$a$从右往左数第$x$位左边有多少个连续的$0$。

$Code:$
```cpp
#include <bits/stdc++.h>
using namespace std;
int T;
string s,t;
int main(){
	cin>>T;
	while(T--){
		cin>>s>>t;
		int x=-1;
		for(int i=t.size()-1,cnt=0;i>=0;i--,cnt++){//找x
			if(t[i]=='1'){
				x=cnt;
				break;
			}
		}
		if(x==-1){
			cout<<0<<endl;
			continue;
		}
		int ans=0;
		for(int i=s.size()-x-1;i>=0;i--){//找a的从右往左数第x位左边有多少个连续的0
			if(s[i]=='0')	ans++;
			else			break;
		}
		cout<<ans<<endl;
	}
	return 0;
}
```
~~我应该讲得很详细了吧，愿管理员大人不要打回来。~~