看到这题首先想到的是用二叉堆做

堆的时间复杂度为$ O(logn) $，一共$ m $次，即$ O(mlogn) $
而考虑到数据的范围$ n <= 105, m <= 7 ∗ 106 $
所以肯定会$ TLE $，但也能拿到$ 70 $分左右

那么我们注意到一件事情：

每次会切最长的蚯蚓

这说明什么？把切掉的拿走后剩下的还具有单调性

不论后切的什么时候切，它们都在同样多的时间内增长了

所以我们能推出对于对应的切后的某部分，先切的长度大于等于后切的

即设先切的时间为$x$，后切的时间为$y$
在$x$和$y$之间的时间$y−x$里它们增长了同样长的$ (y − x) ∗ q $

所以对于切后某部分，先切大于等于后切

这句结论我重复了两遍，因为它真的很重要。

以至于我们可以直接推出：所有被切蚯蚓的某部分，按时间先后呈现单调性

本来维护优先队列变成了直接是单调的队列

也就是说我们直接开普通队列就行了（这里用$ STL $的会超时，只能模拟）

那么这里我们开三个队列$q1$，$q2$，$q3$
$q1$存储最初蚯蚓的长度，每次切掉队首并从队列中移除

$q2$存储目前被切的较长的部分，新的被切的较长部分进入队尾

$q3$存储目前被切的较短的部分，新的被切的较短部分进入队尾

这样就对了吗？答案是否定的

因为还有一种情况是：当前被切的蚯蚓是之前某一次被切蚯蚓的一部分

也就是说新的最长蚯蚓也有可能在$q2$或$q3$里

所以我们每次的最长蚯蚓应该是$max(q1.front(), q2.front(), q3.front())$

每次用个小模拟就好了啊

最后别忘了注意精度的控制

伪代码
```cpp

inline int TOP()  //找最长
{
    int x1=-inf,x2=-inf,x3=-inf;
    if(h1<=t1) x1=q1[h1];
    if(h2<=t2) x2=q2[h2];
    if(h3<=t3) x3=q3[h3];
    if(x1>=x2&&x1>=x3)  
    { 
        h1++;  
        return x1; 
    }
    else if(x2>=x3)  
    { 
        h2++;  
        return x2; 
    }
    else
    {
        h3++;  
        return x3;
    }
}
int main()
{
    输入及初始化
    sort(q1+1,q1+n+1,cmp);
    for(int i=1;i<=m;i++)
    {
        top=TOP();
        模拟
    }
    输出
    return 0;
}

```