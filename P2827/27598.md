# NOIP2016蚯蚓

> ## 题目描述

[洛谷传送门](https://www.luogu.org/problem/show?pid=2827)


本题中，我们将用符号

⌊c⌋表示对c向下取整，例如：

⌊3.0⌋=⌊3.1⌋=⌊3.9⌋=3


蛐蛐国最近蚯蚓成灾了！隔壁跳蚤国的跳蚤也拿蚯蚓们没办法，蛐蛐国王只好去请神刀手来帮他们消灭蚯蚓。


蛐蛐国里现在共有n只蚯蚓（n为正整数)。每只蚯蚓拥有长度，我们设第i只蚯蚓的长度为

ai(i=1,2,...,n)，并保证所有的长度都是非负整数（即:可能存在长度为0的蚯蚓）。


每一秒，神刀手会在所有的蚯蚓中，准确地找到最长的那一只（如有多个则任选一个）将其切成两半。神刀手切开蚯蚓的位置由常数p(是满足0<p<1的有理数)决定，设这只蚯蚓长度为x，神刀手会将其切成两只长度分别为⌊px⌋和x−⌊px⌋的蚯蚓。特殊地，如果这两个数的其中一个等于0，则这个长度为0的蚯蚓也会被保留。此外，除了刚刚产生的两只新蚯蚓，其余蚯蚓的长度都会增加q(是一个非负整常数)。


蛐蛐国王知道这样不是长久之计，因为蚯蚓不仅会越来越多，还会越来越长。蛐蛐国王决定求助于一位有着洪荒之力的神秘人物，但是救兵还需要m秒才能到来......(m为非负整数）


蛐蛐国王希望知道这m秒内的战况。具体来说，他希望知道：


- m秒内，每一秒被切断的蚯蚓被切断前的长度（有m个数）

- m秒后，所有蚯蚓的长度（有n+m个数)。


蛐蛐国王当然知道怎么做啦！但是他想考考你......


> ## 输入

输入文件名为earthworm.in。


第一行包含六个整数n,m,q,u,v,t，其中：


n,m,q的意义见【问题描述】；

  
u,v,t均为正整数；

  
你需要自己计算p=u/v(保证0<u<v);

  
t是输出参数，其含义将会在【输出格式】中解释。


第二行包含n个非负整数，为

ai,a2,...,an，即初始时n只蚯蚓的长度。


同一行中相邻的两个数之间，恰好用一个空格隔开。


保证
1≤n≤10^5​​，

0<m≤7∗10^6​​，

0≤u<v≤10^9​​，

0≤q≤200，

1≤t≤71，


> ## 输出

0<ai≤10^8​​。  

输出文件名为earthworm.out。


第一行输出⌊m/t⌋个整数，按时间顺序，依次输出第t秒，第2t秒，第3t秒……被切断蚯蚓（在被切断前）的长度。


第二行输出⌊(n+m)/t⌋个整数，输出m秒后蚯蚓的长度；需要按从大到小的顺序，依次输出排名第t，第2t，第3t……的长度。


同一行中相邻的两个数之间，恰好用一个空格隔开。即使某一行没有任何数需要 输出，你也应输出一个空行。


请阅读样例来更好地理解这个格式。


> ## 样例输入

输入样例#1：

3 7 1 1 3 1

3 3 2

输入样例#2：

3 7 1 1 3 2

3 3 2

输入样例#3：

3 7 1 1 3 9

3 3 2

> ## 样例输出

输出样例#1：

3 4 4 4 5 5 6

6 6 6 5 5 4 4 3 2 2


输出样例#2：

4 4 5
6 5 4 3 2


输出样例#3：

//空行  

2

> ## 说明

【输入输出样例说明】


【样例解释1】

在神刀手到来前：3只蚯蚓的长度为3,3,2。


1秒后：一只长度为3的蚯蚓被切成了两只长度分别为1和2的蚯蚓，其余蚯蚓的长度增加了1。最终4只蚯蚓的长度分别为(1,2),4,3。括号表示这个位置刚刚有一只蚯蚓被切断


2秒后：一只长度为4的蚯蚓被切成了1和3。5只蚯蚓的长度分别为：2,3,(1,3),4。


3秒后：一只长度为4的蚯蚓被切断。6只蚯蚓的长度分别为：3,4,2,4,(1,3)。


4秒后：一只长度为4的蚯蚓被切断。7只蚯蚓的长度分别为：4,(1,3),3,5,2,4。


5秒后：一只长度为5的蚯蚓被切断。8只蚯蚓的长度分别为：5,2,4,4,(1,4),3,5。


6秒后：一只长度为5的蚯蚓被切断。9只蚯蚓的长度分别为：（1,4),3,5,5,2,5,4,6。


7秒后：一只长度为6的蚯蚓被切断。10只蚯蚓的长度分别为：2,5,4,6,6,3,6,5,(2,4)。


所以，7秒内被切断的蚯蚓的长度依次为3,4,4,4,5,5,6。


7秒后，所有蚯蚓长度从大到小排序为6,6,6,5,5,4,4,3,2,2。


【样例解释2】

这个数据中只有t=2与上个数据不同。只需在每行都改为每两个数输出一个数即可。


虽然第一行最后有一个6没有被输出，但是第二行仍然要重新从第二个数再开始输出。


【样例解释3】

这个数据中只有t=9与上个数据不同。


注意第一行没有数要输出，但也要输出一个空行。


【数据范围】



> ## 题解

![](https://i.loli.net/2017/10/04/59d48c0dadaaf.png)

- 乍一看题目，woc这一优先队列大水题啊，然后用priority\_queue来xjb搞，最后发现priority\_queue这个东西它没有迭代器……

- 最后发现正解又简单又短（就是太难想了

- 瞎扯淡结束，我们来讲题目：

1. 假设有两只蚯蚓长度分别为x，y，且x>y；那么根据题意x一定被先切，于是我们假设y在x被切后i秒被切。

2. 假设x被切成x1和x2两段，y被切成y1和y2两段；

3. 易得

![](https://i.loli.net/2017/10/04/59d498e1c76cd.png)

4. 由上可得x1>y1;x2>y2;

- 于是我们开3个队列

qs存储未被切的，(已从大到小排序

q1存储 p\*x，

q2存储 x-p\*x;

- 由前面可得每个队列都是单调的（此处即由大到小的

- 于是每次取3个堆首的最大元素模拟即可

- ps：还要保存一个时间戳表示蚯蚓增加的长度，每次取出时加上，放回时减去


> ## 代码

```cpp
#include <cstdio>
#include <queue>
#include <algorithm>
#include <cstring>

using namespace std;

const int maxn=100050;
int n,m,q,u,v,t,add,a[maxn];

queue <int> qs,q1,q2;

int cmp(int x,int y){
    return x>y;
}

int get_front(queue <int> &y){
    return y.empty()?-0x3f3f3f:y.front()+add;
}

int compare_front(){
    int a=get_front(qs),b=get_front(q1),c=get_front(q2),
        mx=max(a,max(b,c));
    if(mx==a) qs.pop();
    else if(mx==b) q1.pop();
    else if(mx==c) q2.pop();
    return mx;
}

int main(){
    scanf("%d%d%d%d%d%d",&n,&m,&q,&u,&v,&t);
    for(int i=1;i<=n;i++) scanf("%d",a+i);
    sort(a+1,a+n+1,cmp);
    for(int i=1;i<=n;i++) qs.push(a[i]);
    for(int i=1;i<=m;add+=q,i++){
        int cur=compare_front(),
            l1=(long long)cur*u/v,
            l2=cur-l1;
        q1.push(l1-add-q);q2.push(l2-add-q);
        if(i%t==0) printf("%d ",cur);
    }
    printf("\n");
    for(int i=1;i<=n+m;i++)
        i%t==0?printf("%d ",compare_front()):compare_front();
    printf("\n");
    return 0;
}
```