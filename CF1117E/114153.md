写这篇题解的初衷其实是觉得题解区的代码太难看了……

___

题目就是要让我们把作用在原字符串上的置换求出来。

很自然地我们可以有一个想法：如果我们的字符集是 $10^4$，那么直接使得询问字符串的每一位都不相同，我们就可以整个得到这个置换。

虽然本题的字符集只有 $26$，但是上面的思想还是可以沿用的——只不过有了一个问题：我们**不知道**这一次放了相同字符的位置**内部的置换关系**。

但是我们可以发现，这个过程是可以递归进行的——内部的位置关系可以通过又一次询问得到，然后分成更小的小段。因为 $26^3 = 17576 \ge 10^4$，所以我们可以保证三次之内出结果。

___

解法就到这里，接下来就是实现问题。

其实我们并不需要像上面说的一样递归地去构造询问串，有一种非常简单的想法是这样的：

我们将每个位置映射为一个 $3$ 位 $26$ 进制数，每一位分别塞进三个询问串的对应位置去。

然后我们会得到三个答案串，将每一个位置上的三个字符看做 $3$ 位 $26$ 进制数，它的值就是我们需要的东西：这个位置上现在的数原先在哪个位置。直接将 $s$ 每个字符映射到该去的地方即可。

代码：

```cpp
#include <cstdio>
#include <cstring>
const int maxn = 1e4+5,pw[] = {1,26,676,17576};
int n,qry[3][maxn];char s[maxn],t[3][maxn],ans[maxn];
int main(){
	scanf("%s",s),n = strlen(s);
	for(int _=0;_<3;++_){
		for(int j=0;j<n;++j)
			qry[_][j] = j%pw[_+1]/pw[_];
		printf("? ");
		for(int j=0;j<n;++j)putchar('a'+qry[_][j]);
		puts(""),fflush(stdout);
		scanf("%s",t[_]);
	}
	for(int i=0;i<n;++i){
		int pos = 0;
		for(int _=0;_<3;++_)
			pos += (t[_][i]-'a')*pw[_]; 
		ans[pos] = s[i];
	}
	return printf("! %s",ans),fflush(stdout),0;
}
```