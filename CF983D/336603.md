扫描线的一道绝佳练习题。

观察题目，我们会发现它和 [P1003 铺地毯](https://www.luogu.com.cn/problem/P1003) 很像，不同的是询问的对象从**点变成了线**，询问的范围从第一象限变成了全坐标系。

为了方便，我们先考虑第一象限的点。

首先我们思考，对于两个**点**，如果他们的 $y$ 坐标相同，那么什么时候答案会不一样？

很显然当他们**最上边**的颜色不一样时，答案才会不同。

那什么时候最上边的颜色会不一样？

我们从下往上遍历整个坐标系，会发现：

- 当一个矩形最下边的一条边被我们遍历到，位于 $[\text{线段左端点},\text{线段右端点}]$ 的所有点**上**所被覆盖的颜色会发生变化——多了一种颜色。但是是否会**改变答案**呢？我们暂时不知道。
- 当一个矩形最上边的一条边被我们遍历到，位于位于 $[\text{线段左端点},\text{线段右端点}]$ 的所有点**上**所被覆盖的颜色会发生变化——少了一种颜色。

具体如下图所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/8wtm111b.png)

虽然蓝色是我们第一个画出来的矩形（红色是第二个，黄色是第三个），但是当我们从下往上扫描到**第一根绿线**时，虽然这时在绿线上与在绿线上方的点多了一种被覆盖的颜色——蓝色，但是他们所被覆盖的最大的颜色还是红色（第二种颜色）。

那么我们怎么快速求出对于每一条线段，覆盖在他身上的**最大颜色**呢？

我的第一反应是：我们可以用一个变量 `mx` 来计算，每次只要看到有更大的就更新，如果遍历到最大颜色的矩形的上界，那么最大的颜色不见了，取而代之的是第二个。

那于是问题来了：如果在遍历最大颜色矩形的一半时遍历到第二大颜色矩形的上界了怎么办？

所以我们需要一个能快速查询**当前所有覆盖在线段上的颜色的最大值**的数据结构。考虑用 `set` 实现，那么当前颜色的最大值就是 `*set.rbegin()` 。

接下来就是线段树的问题了。

对于每一条横线（因为我们的扫描线会从下往上遍历 $y$ 轴，所以当他发现横线的时候才能正确处理），我们除了要记录当前在这条横线上的所有颜色，我们还要记录这条线段**还没被统计**的颜色**最大值**与**已被统计过**的颜色**最小值**。

那怎么判断一个颜色有没有被答案统计到呢？我们可以使用一个 `vis` 数组，在这个颜色被统计之后将他加入 `vis` 数组即可。

接下来还要干什么？碰到一个矩形的下界，我们需要更新的是：

- 把当前这个新的颜色加入 `set` 。
- 把当前**没被统计过**的颜色最大值和他俩儿子的最大值取 $\max$ 。
- 找出当前的颜色最大值。
- 如果他被统计了，那么将他**已被统计过**的颜色**最小值**和当前的颜色最大值取一个 $\max$ 。为什么？因为前边**已经被统计过**的颜色**最小值**已经没用了，目前最上层的颜色是 `set` 中的最大值。
- 否则的话，将**未被统计过**的颜色**最大值**和当前的颜色最大值取一个 $\max$ 。
- 如果**已被统计过**的颜色**最小值**大于**还没被统计**的颜色**最大值**，那剩下的这些都没用了，把**还没被统计**的颜色**最大值**清零即可。

碰到一个上界，我们也要更新这些，不同的是是**把颜色提出** `set` 。

特别地，遍历完每一行的所有线段，对于这一行的线段树进行一个更新。

每次将**未被遍历过的最大值**拿出来看，如果确实没被遍历过，那么就把他遍历，然后把**这个颜色所对应的边**进行一个区间的更改，以更新**还没被统计**的颜色**最大值**。在更新完之后，如果没有其他的需要拿出来的颜色，那么这里**还没被统计**的颜色**最大值**会被清零。

对整个区间都是如此。

最后再离散化一下，就把全坐标系的问题转换到第一象限了。

其他的看[代码](https://www.luogu.com.cn/paste/ehs7qpbl)。