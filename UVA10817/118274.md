### 前言：


[$ \large{}\color {#6495ED} \mathcal{MyBlog} $](https://xjx885.coding-pages.com/)

顺着LRJ蓝皮书刷到这题的...

看着题解区那么多人，本来不打算写题解的...

不过还是来了一发...

---

### 题目大意：

有s个科目，每个科目需要至少两个老师教，老师分为在职教师和应聘者，每个老师都可以教一些科目，需要的报酬也不同，其中在职教师必须选，应聘者可选可不选，求最少花多少钱....

---

### 题目分析:

观察s的范围...$s<=8$

很明显，这题可以状压...

我们先把题目简化一下，假如说一门科目只需要一名老师教就好，那么这题应该怎么做...

显然，这么一改之后，本题就成了一道模板题...

我们可以设状态f[k][i]表示选择前k名老师，科目有没有人教的状态为i...

转移在这里就略过了...

仔细分析i这一维：

i其实是一个二进制数，每一位的1/0表示某一门科目有没有人教...

我们其实也可以把它定义为：每一位的1/0表示某一门科目有没有至少一个人教...

两者是等价的...

我们会到本题，按照之前的思想，设状态f[k][i]...

i每一位的1/0表示某一门科目有没有至少两个人教...

如何转移？

显然，这样是没法转移的，因为状态表达的都不完整...

我们把没人教和有一个人教的情况混在了一起...

所以我们再加一维状态就可以了...

令状态为f[k][i][j]  ,k表示抉择到了第几个教师...

i每一位的1/0表示某一门科目是不是有且仅有一个人教...

j每一位的1/0表示某一门科目是不是至少有两个人教...

这样，状态就被我们表达清楚了...

i中位置X为的值为1,那么X科目只有一个人教

j中位置X为的值为1,那么X科目至少有两个人教

i，j中位置X为的值都为0,那么X科目没人教

状态搞定之后，转移就简单了...

其他细节见代码吧...

---

### 代码：

```cpp
#include <bits/stdc++.h>

using namespace std;

const int N = 110;
const int MAXN = (1 << 8);

int s0, n, m;

int f[N][MAXN][MAXN];//状压数组，含义见题解

int cost[N];//雇第i个职员花多少钱 
int teach[N];//第i个职员能交那些科目 

int main()
{
	while(scanf("%d %d %d", &s0, &m, &n) != EOF)
	{
		if(s0 == 0) break;

		//数据不清空，爆零两行泪 
		memset(f, 0x3f, sizeof(f));
		memset(teach , 0, sizeof(teach));

		//因为在职教师是必选的，那么可以提前把他们处理出来 
		//把他们可以教的科目作为初始状态，花费的费用作为初始消耗 
		int ori1 = 0 , ori2 = 0, mon = 0;
		//ori1与DP中的i等价，ori2与j等价，mon是代价 
		for(int k = 1; k <= m; k++)
		{
			int c;
			scanf("%d", &c);
			mon += c;

			string s;
			getline(cin, s);
			//getline读整行 

			int num = 0;
			for(int i = 0; i < (int )s.length() ; i++)
				if(s[i] >= '0' && s[i] <= '9')
					num *= 10, num += s[i] - '0';
				else if(num)
				{
					if(!(ori2 & (1 << (num - 1))))//这门课不到两个人教（两个人教与N个人教对于我们的状态来说，没有区别） 
					{
						if(ori1 & ((1 << (num - 1))))//这门课有人一个教了， 那么把这一个人教的标志取消掉，换成两个人教的标志 
							ori1 ^= ((1 << (num - 1))), ori2 |= ((1 << (num - 1)));
						else//否则，标记上这门课有一个人教 
							ori1 |= ((1 << (num - 1)));
					}

					num = 0;
				}
			if(num)//最后一位的处理 
			{
				if(!(ori2 & (1 << (num - 1))))
				{
					if(ori1 & ((1 << (num - 1))))
						ori1 ^= ((1 << (num - 1))), ori2 |= ((1 << (num - 1)));
					else
						ori1 |= ((1 << (num - 1)));
				}
			}
		}

		//初态设定 
		f[0][ori1][ori2] = mon;

		for(int k = 1; k <= n; k++)
		{
			scanf("%d", &cost[k]);

			string s;
			getline(cin, s);

			int num = 0;
			for(int i = 0; i < (int )s.length() ; i++)
				if(s[i] >= '0' && s[i] <= '9')
					num *= 10, num += s[i] - '0';
				else if(num)
					teach[k] |= (1 << (num - 1)), num = 0;
			if(num)
				teach[k] |= (1 << (num - 1));
		}
		
		//我习惯的是刷表法...可能快一点 
		for(int k = 0; k < n; k++)
			for(int i = 0; i < MAXN; i++)
				for(int j = 0; j < MAXN; j++)
					if(f[k][i][j] != 0x3f3f3f3f)
					{
						//不雇佣 
						f[k + 1][i][j] = min(f[k + 1][i][j], f[k][i][j]);
						
						int to1 = i, to2 = j;
						//处理出雇佣之后的状态 
						for(int c = 0; c < s0; c++)
						{
							//他不教这一科 
							if(!(teach[k + 1] & (1 << c)))
								continue;

							//这科有两个人教了... 
							if((j & (1 << c) ))
								continue;

							//这个处理有点类似之前读入的处理，不细讲 
							if(i & (1 << c))
								to1 ^= (1 << c), to2 |= (1 << c);
							else
								to1 |= (1 << c);
						}

						//处理完毕，选择此人 
						f[k + 1][to1][to2] = min(f[k + 1][to1][to2], f[k][i][j] + cost[k + 1]);
					}

		//末态：所有科目都有至少两个人教 
		printf("%d\n", f[n][0][(1 << s0) - 1]);
	}

	return 0;
}
```


---


### 结语：

如果本题解有BUG...

那么...那么...那么...

（随意了）还请私信作者....

---

## END