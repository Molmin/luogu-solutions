[![](https://ae01.alicdn.com/kf/HTB14d0waoH1gK0jSZSy760tlpXa5.png)](https://www.luogu.org/problemnew/show/P2800)


------------

这道题是一道**DP**题。

描述状态$f[i]$表示到达第$i$层**之上**所用的最短时间。

初始状态即为塔底，根本不需要时间。
那么 _**边界条件**_ 就很明显了：
$$f[0]=0$$

接着，题目要求的是到达塔外的时间，而塔有$n$层，所以最终要求的**解**的就是
$$f[n+1]$$

然后我们自己搞一组数据：

###  INPUT：

```
6
5 2 4 5 3 2
```
### OUTPUT:
```
5
```
我们把这组数据画下来：

![](https://ae01.alicdn.com/kf/HTB1xkFuaeT2gK0jSZFv760nFXXaJ.png)
塔底$f[0]=0$，解是$f[7]$

不难看出，这组数据的走法是：
$$0\Rightarrow 1 \stackrel{2}\rightarrow 2 \Rightarrow 4 \stackrel{3}\rightarrow 5 \Rightarrow 7$$
($\rightarrow$表示爬，$\Rightarrow$表示仙术瞬移)

接下来我们来推导


------------


### 状态转移方程

根据题意，到达第$i$楼有三种方法：

>1. **徒步爬楼（花费与下层层高相等的时间 $a[i-1]$）**
>2. **仙术瞬移1层（不花费时间 $0$）**
>3. **仙术瞬移2层（不花费时间 $0$）**

也有限制条件：

>**仙术瞬移无法连续使用**

那么也就是说，**仙术瞬移之后必须爬楼**，~~爬楼是世间万物の归宿，是不可避の物，是死亡の灯塔，是宇宙の终结~~，则**爬楼到达**第$i$楼的三种方法有所变化：

>1. **从$i-1$楼徒步爬楼.**
>
>	（ 花费时间 $a[i-1]$ $\quad|\quad$ 总花费时间 $ f[i-1]+a[i-1] $ ）
>
>2. **从$i-2$楼仙术先瞬移1层到$i-1$楼，再徒步爬楼.**
>
>	（ 花费时间 $a[i-1]$ $\quad|\quad$ 总花费时间 $ f[i-2]+a[i-1] $ ）
>
>3. **从$i-3$楼仙术先瞬移2层到$i-1$楼，再徒步爬楼.**
>	
>   （ 花费时间 $a[i-1]$ $\quad|\quad$ 总花费时间 $ f[i-3]+a[i-1] $ ）
    

如下图

![](https://ae01.alicdn.com/kf/HTB1NnpyakL0gK0jSZFA763A9pXaS.png)

这样的话，就不需要考虑仙术不能连续使用的问题了，

所以，到达第$i$层所需要的最短时间$f[i]$，就是三种方法所需要总时间中的最小值，于是我们成功推导出了状态转移方程：


------------


$$ f[i]=min\{f[i-1],f[i-2],f[i-3]\}+a[i] $$


------------

下面奉上蒟蒻的辣鸡代码，还请垂阅敝码，多多赐教

```cpp
#include<bits/stdc++.h>
using namespace std;

int n;
int a[1000005];
int f[1000005];

int main() {
	cin>>n;
	for(int i=1; i<=n; i++) {
		cin>>a[i];
		f[i]=1e9;//注意初始化
	}
	f[n+1]=1e9;
	
	for(int i=1; i<=n+1; i++) {//循环到n+1
		f[i]=min(f[i],f[i-1]);
		f[i]=min(f[i],f[i-2]);
		f[i]=min(f[i],f[i-3]);
		f[i]+=a[i];
	}
	
	cout<<f[n+1];//输出解
	return 0;//愉快的结束
}
```

文明查题解，拒绝复制粘贴

------------

『做正确，好懂，好看的题解』