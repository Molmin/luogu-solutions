## 前言
这道题是我见过的~~最水的dp~~最难的dp（因为我太弱了）

另外这道题浪费了我三次提交机会（一次忘记关文件）所以发个题解祭奠一下
## 正文
我们如何求状态呢？状态转移方程是什么？
如题所说([题面传送门](https://www.luogu.org/problem/P2800))
小A可以用仙术跳过一层或者两层（其实这道题可以更难一点）那么我们就可以知道当前的塔层的最小时间花费就等于
```
f[i]=min(f[i-1]+a[i],f[i-2]+a[i],f[i-3]+a[i]);
化简得：f[i]=min(f[i-1],f[i-2],f[i-3])+a[i];
//当i>=3是
```
那么当i=2时我们可以知道需要花费的时间就是
```
f[i]=min(f[i-1],f[i-2])+a[i];
```
当i为1时
```
f[i]=a[i];
```
又因为跳过塔也算，所以我们还可以多算一层（有可能最后一层好高）所以我们要将i从3循环到n+1即
```
f[1]=a[1],f[2]=min(f[1],f[0])+a[2];
	for(int i=3;i<=n+1;++i)
		f[i]=min(f[i-1],min(f[i-2],f[i-3]))+a[i];
```
最后输出f[n+1]就好了
## 总结
这道题的状态转移方程想出来了后就可以秒掉了，但是因为本蒟蒻实在太弱，所以才……

## CODE
```
#include<bits/stdc++.h>
using namespace std;
#define N 1000005
int a[N],f[N],n;
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;++i)
		scanf("%d",&a[i]);
	f[1]=a[1],f[2]=min(f[1],f[0])+a[2];
	for(int i=3;i<=n+1;++i)
		f[i]=min(f[i-1],min(f[i-2],f[i-3]))+a[i];
	printf("%d\n",f[n+1]);
	return 0;
}
```

