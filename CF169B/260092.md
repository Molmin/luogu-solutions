### 思路
---
本题考验 $char$ 类型知识的了解。  
因为 $s$ 可能是一个乱序，不能直接使用，我们借助 $sort$ 来排序。  
其他大佬已经写过降序了，我们写升序。  
$sort$ 默认升序我们可以不写 $cmp$ 。     
循环 $a$ ,从 $0$ 到 $n-1$ 停止。  
具体操作过程我画个图帮助理解：
![](https://cdn.luogu.com.cn/upload/image_hosting/dcj5iccd.png)
因为要让数最大，那么可替换的最大的数字应该在前，让更高位尽可能最大。   
那应该从 $s$ 的最后一个开始判断替换 。  
$s$ 的最后一个下标是 $m-1$ ，因为是从 $0$ 开始。  
$s[m]$ 与 $a[i]$ 比较，判断当前可用最大是否大于当前数字。   
如果替换后可以得到更大的数，那就替换。      
因为$s$ 中的数字只能用一次，那么 $m$ 就减减，以判断可用的最大的数字，下标减减。  
### 全代码及对应解释
---
```cpp
#include <bits/stdc++.h>
using namespace std;
char a[100001],s[100001];
int main(){	
    cin>>a>>s;
    int n=strlen(a),m=strlen(s);
    int i;
    sort(s,s+m);
    //升序排序
    m-=1;
    //数组是从0开始的，最后一个下标是m-1
    for(i=0;i<n;i++){
    //循环
        if(s[m]>a[i]){
        //判断替换后是否更大
           a[i]=s[m];
           //替换
           m--;
           //以替换不可二次使用，我们要判断可用的最大数字
           //下标减减
        }
    }
    cout<<a<<endl;
    //输出
    return 0;
}
```
