# CF1202B

关于这道抽象的又奇怪的图论题 ...

由于~~某些原因~~（还是因为太菜）在一次考试中没写出来，所以特来发一篇题解给自己点安慰 。


唔 ....


------------

计算时间复杂度是 $O(10^2\,\,(\,n\,+\,10^3)\,)$  此处的 $n$ 指字符长度 。

##### 正题：

[传送门](https://www.luogu.com.cn/problem/CF1202B)

这道题首先我们来枚举 $x$ 和 $y$ ,因为题目要求我们要求出 一个 10×10 的矩阵 由i-j计算器能得到的序列最小所需插入的数字数 。

而矩阵里则是在输入的一个串中至少需要添加几个字符 ；

所以我们就需要求出 $i$ 到 $j$ 需要加字符的最小值从而在矩阵中找到答案 。
```
for(int l = 0; l < len - 1 ; ++l)
{
	if(a[s[l] - '0'][s[l+1] - '0'] == 0x3f3f3f3f3f3f3f3f)
	{
		ans[n][m] = -1;
		break;
	}
	ans[n][m] += a[s[l] - '0'][s[l+1] - '0'] - 1;
}
```

关于这个地方的 -1 楼上没有解释，那我来解释一下 。

大家可以想一想，在这个题中，我们已经求出从一个字符到另一个字符的最少字符数，但是他题目问的睡是 _**最小所需插入的字符数**_ 是不是悟到了 ？（嘿嘿）

所以接下来就跑一遍Floyd然后查询就差不多了 ；



------------


最后一个关于初始化的问题

从i向(i+x)  $mod$  10, 连一条边权为1的单向边.

从i向(i+y)  $mod$  10, 连一条边权为1的单向边.

在题解开头我有说“抽象的奇怪的图论题” 为什么这么说呢 ？

```
memset(a, 0x3f , sizeof a);
for(int k = 0; k <= 9; ++k) // k用来枚举点初始化 
{
	//a[k][k] = 0;    
	a[k][(k+n) % 10] = 1;
	a[k][(k+m) % 10] = 1;
}
```
在这里我把  "  a[k][k] = 0; " 这句话注释掉了，原因呢就是掉了#2的点，然后在机房大佬的帮助下我悟了 。

我们来想一个问题，当有两个相同的数字相邻那这时候这两个一定不是相同的数，他们只是个位相同而已，所以我们当然就不能将它赋为 $0$ 嘛 。

欧克！ 上代码 。


------------

## code：


```
#include<bits/stdc++.h>
#define ll long long
using namespace std;
string s;
ll a[20][20] , ans[20][20];
int main()
{
	cin >> s;
	int len = s.size();
	for(int n = 0; n <= 9; ++n)
	{
		for(int m = 0; m <= 9; ++m)
		{
			memset(a, 0x3f , sizeof a);
			for(int k = 0; k <= 9; ++k) // k用来枚举点初始化 
			{
				//a[k][k] = 0;    
				a[k][(k+n) % 10] = 1; 
				a[k][(k+m) % 10] = 1;
			}
			for(int l = 0; l <= 9; ++l) // 跑一遍floyd
			{
				for(int i = 0; i <= 9; ++i)
				{
					for(int j = 0; j <= 9; ++j)
					{
						a[i][j] = min(a[i][j] , a[i][l] + a[l][j]); 
					}
				}
			}
			for(int l = 0; l < len - 1 ; ++l)
			{
				if(a[s[l] - '0'][s[l+1] - '0'] == 0x3f3f3f3f3f3f3f3f) 
				{
					ans[n][m] = -1;
					break;
				}
				ans[n][m] += a[s[l] - '0'][s[l+1] - '0'] - 1;
			}
		}
	}
	for(int i = 0; i <= 9; ++i)
	{
		for(int j = 0; j <= 9; ++j)
		{
			if(i <= j)
			cout << ans[i][j] <<' ';
			else
			cout << ans[j][i] <<' ';
		}
		cout << endl;
	}
	return 0;
}
```
最后
ps: 关于memset.

------------

```
memset(a, 0x3f , sizeof a);
```

------------
memset 本质上是以字节来赋的,

举个栗子  :

如果 a数组是 int 类型 那么它数组里面是0x3f3f3f3f（4个），
但是如果是long long 类型那就是,0x3f3f3f3f3f3f3f3f(8个)

好啦  !

完结撒花 !



