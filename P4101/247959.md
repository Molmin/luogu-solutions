## 题目描述
给你堆数和每堆最大容纳值，初始每堆一个，每次操作轮流合并任意两堆，谁最后无法操作谁就输
## 结论证明
我们知道的是，如果优先合并出满堆（就是每个大于$1$的堆都是$m$），最后剩下的就是$n%m$，然后手摸一下就知道不管先手是继续合并大堆（虽然合不出来）还是两两合并，只要后手愿意，可以保证经过这两次操作，较大堆只加了$2$

比如 先手将两个$1,1$合并，那后手就把合并出的$2$与未满$m$的最大堆合并，这样每次操作就相当于只加一个石子，我们从此考虑就可以求出操作次数

就是合并之后完的**数量为m的堆的数量 乘上m-1 加上最后剩下的石头数量-1**

为啥要减一：因为每次合并出有$x$个石头的堆，只需要$x-1$次操作

## 代码
```c++
#include<bits/stdc++.h>
using namespace std;
int main(){
	int t;
	cin>>t;
	while(t--){
		int n,m;
		cin>>n>>m;
		int num=n/m;//可以合成的堆数
		int mod=n%m; 
		long long ans=0;
		ans+=num*(m-1);//每堆需要m-1次
		ans+=mod;
		if(mod>0)
		ans--;
		if(ans%2)
		cout<<0<<endl;
		else
		cout<<1<<endl;
	}
}
```