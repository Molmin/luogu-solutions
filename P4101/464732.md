# 前言

这题对于我来说~~比较水~~是一个比较好的练手题。

代码速度 $20ms$，并列第一。

代码时空复杂度排名第三。

~~这竟然是蓝题~~

[洛谷博客食用更佳](luogu.com.cn/luqyou/solution-p4101)

[csdn博客食用更佳](https://blog.csdn.net/weixin_50193039/article/details/119726904)

# 思路

如果每个人每次都只是将一个大小为1的石子堆放到当前最大的石子堆里，那么当游戏不能玩的时候局面必定是有 $\dfrac{n}{m}$ 个大小为 $m$ 的石子堆和 $n \bmod m≠0$ 个大小为 $n \bmod m$ 的石子堆。

一共需要 $(m-1)×(\dfrac{n}{m})+[n \bmod m≠0]×(n \bmod m-1)$ 步达到最后的局面。

如果**都按照这样的策略**进行游戏，那么如果**步数是奇数就是先手胜否则是后手胜利**。但是现在还有别的决策可以执行，而且最终局面**不是唯一的**，但是可以采用一种策略使最终局面就是这样的。考虑如果按这个策略进行游戏本来是先手必胜那么当后手执行决策时有两种可能。

第一种将一个大小为 $1$ 的石子堆和最大的石子堆合并，这样先手只要继续执行策略最后就能获胜。

第二种将两个大小为 $1$ 的石子堆合并，这样先手下次只要将这个大小为 $2$ 的石子堆和最大的合并就行，和上面的第一种情况一样都是得到一个最大的石子堆和一些大小为1的石子堆。

如果不能合就直接拿一个大小为 $1$ 的石子堆和最大的合并就行，和上面第一种情况得到的局面还是一样的，都是一个大小为 $m$ 的石子堆和一个大小为 $2$ 的石子堆还有一些大小为 $1$ 的石子堆。

所以**无论是哪种决策**达到最终局面的步数不变，依然是先手必胜。如果一开始算的步数是后手必胜同理。

所以按这种决策计算的步数是**奇数就是先手胜否则就是后手胜**。

# code
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m;
int main()
{
	int t;
	cin>>t;
	while (t--)
	{
		cin>>n>>m;
		cout<<(n-(n/m)+(n%m!=0))%2==0?1:0)<<endl;
	}
	return 0;
} 
```

[然后就AC啦！](https://www.luogu.com.cn/record/59681779)

更新：
2021/10/12 更新了提交记录
