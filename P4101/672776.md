## 题目概述
两个人玩游戏，有 $n$ 堆石子，轮流合并石子，且最高的石子堆不能大于 $m$ 个石子，最后不能操作的人失败。  
先给定你多组 $n$ 和 $m$，询问你是先手必胜还是后手必胜。

## 前置知识
这道题可以转化成巴什博奕来解决。  
巴什博奕是什么，我们先来看一个有趣的视频。  
[点我查看巴什博奕的视频。](https://view.inews.qq.com/a/20220819A0AIVN00)  
巴什博奕就是：
两个人玩游戏，规则为：从 $n$ 个物品中轮流取物，至少取一个，最多取 $m$ 个，定义最后取完者获胜。    
那必胜规则就是：  
如果 $n$ 能被 $(m+1)$ 整除，则对于先手来说，就是必败局。  
如果 $n$ 不能被 $(m+1)$ 整除，则对于先手来说，就是必胜局。   
为什么可以这样呢？  
就拿视频中的例子举例，$17$ 个豆子，每人只能拿 $1 \sim 3$ 颗，取到最后一颗豆子的获胜。   
如果我们拿到 $4$ 颗，$8$ 颗，$12$ 颗，$16$ 颗的点，那我们就拿到了必胜点，对方必败，对方无论取多少颗，我们都可以补满 $4$ 颗，使其继续为 $4$ 的倍数点，从而最后自己拿到最后一颗豆子获胜。
## 解法讲解
接下来，我们具体地分析这道题。  
我们可以把每一次合并点当做一个豆子，所以题意可以模型化为：  
共有 $n-1$ 个合并点，每次只能合并一次，且每堆石子最多不能超过 $m$ 个石子，问是否先手必胜。  
我们需要先处理第二个限制条件,每连续的 $m$ 堆的右方的合并点无法使用，如下图。  
如果 $n$ 能够除尽 $m$ 的话，我们只需要减去 $\lfloor n/m \rfloor +1$ 个合并点。   
因为最后一组的右方的合并点无效，所以我们要 $+1$，如下图。  
![](https://cdn.luogu.com.cn/upload/image_hosting/zatuyost.png?x-oss-process=image/resize,m_lfit,h_170,w_225)  
如果 $n$ 不能除尽 $m$ 的话，我们需要减去 $\lfloor n/m \rfloor$ 个合并点。    
![](https://cdn.luogu.com.cn/upload/image_hosting/592wd0xi.png?x-oss-process=image/resize,m_lfit,h_170,w_225)  
根据上方的巴什博奕前置知识，减去后的合并点若为 $2$ 的倍数则先手必胜，否则后手必胜。  
所以若先手必胜，需要满足：
$$((n-1)- \lfloor n/m \rfloor +[n \bmod m=0]) \bmod 2=1$$
整理可得：
$$(n- \lfloor n/m \rfloor +[n \bmod m \ne 0]) \bmod 2=1$$
否则后手必胜。
## code
代码很简单。
```cpp
#include<bits/stdc++.h>
using namespace std;

int main()
{
	int T;
	scanf("%d",&T);
	while(T--)
	{
		int n,m;
		scanf("%d%d",&n,&m);
		if((n-n/m-(n%m!=0))%2==1)	printf("0\n");
		else printf("1\n");
	}
	return 0;
}
```