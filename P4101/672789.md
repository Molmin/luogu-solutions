[传送门](https://www.luogu.com.cn/problem/P4101)  
博弈论。

solution：  
简单分析题意可知当合并次数为奇数次的时候先手必胜，合并次数为偶数次的时候先手必败。

我们来分两种情况讨论。

当 $n \le m$ 时：  
简单的画图模拟可知无论怎么合并都只有 $n-1$ 次，所以当 $n$ 是偶数时先手必胜，$n$ 是奇数的时候先手必败。

当 $n > m $ 时：  
我们的游戏规则为：先手合并 $\to$ 后手合并 $\to$ 先手合并 $\to$ 后手合并…且合并的两堆加起来的数目不会超过 $m$。   

嘿，你发现什么没有。  

让我们先站在先手的位置上。先手很聪明，所以在合并石子的时候绝对不会让其出现最后剩下两堆石子数量都大于 $\dfrac m 2$ 以至于无法合并的情况。也就是说，我们先手的合并策略一定是小堆往大堆合并直到一堆石子的数量到达 $m$。  
当然，$n \le m$ 的时候也是这个策略只是因为没有限制所以随便合并也可以。

至于后手如何合并就显得无关紧要了，因为无论如何先手在下一步都会把它变成从小堆到大堆合并。  
故最后石子的分堆情况应该是 $\left\lceil\dfrac{n}{m}\right\rceil$ 堆，其中有一堆是不满 $m$ 的 $(n \bmod m)$。当然，如果 $n$ 是 $m$ 的倍数那就没有剩下石子。  
合并次数的计算就仿照当 $n \le m$ 时的合并，即数量为 $m$ 的合并 $m-1$ 次，不满 $m$ 的合并石子数量减一次。最后单堆石子的次数相加就行。  

计算式：```ans=(n/m)*(m-1)+((last)?(last-1):0)```，其中```last```为余下的石子。

上代码。
```cpp
#include<bits/stdc++.h>
using namespace std;
int T,n,m,ans,last;
int main()
{
	scanf("%d",&T);
	while(T--)
	{
		scanf("%d%d",&n,&m);
		last=n%m;
		ans=(n/m)*(m-1)+((last)?(last-1):0);
		if(ans%2) cout<<"0"<<"\n";
		else cout<<"1"<<"\n";
	}
	return 0;
}
```