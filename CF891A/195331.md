首先，如果序列中本来就有一个 $1$，那么最少的次数是多少？  
显然是 $n-1$：每次把与 $1$ 相邻的数变为 $1$，需要 $n-1$ 次。可以证明这样是最优的，因为每次操作都有一个数的贡献。

于是我们就有了思路：用最少的次数变出一个 $1$。  
首先，如果我们做了一次操作使 $x$ 变化了，那么下一次操作必定是 $x$ 和与他相邻的一个数的变化。否则你这次操作相当于白费了。  
这时可能有人会说：我可以先操作其他数再和 $x$ 操作呀。但是请注意：$gcd(gcd(a,b),c)=gcd(a,gcd(b,c))$，所以先做和后做是等价的。  
然后第二点：第一次操作后一定是一直往一个方向进行。原因也是 $gcd(gcd(a,b),c)=gcd(a,gcd(b,c))$，从中间向两边扩展和直接从一端扩展是等价的。  

于是我们就可以写出代码：
枚举每个区间，如果这个区间的 $gcd$ 为 $1$，那么这个区间是可行的。在可行的区间里找一个最小的即可。最后的答案加上 $n-1$（把其他的数也变成 $1$ 需要 $n-1$ 次）。  
但是这样是 $O(n^3)$ 的呀，跑步过去。  

那么我们对他优化：  

1. 枚举左端点 $l$
2. 从 $l$ 开始向右枚举右端点 $r$
3. 每次 $r+1$ 就把现在的 $r$ 和之前的结果做 $gcd$

这样就能让求值和枚举右端点公用一个循环，时间复杂度 $O(n^2)$。

注意特判一开始就有 $1$（不一定是一个）和无解（所有数一起的 $gcd$ 不等于 $1$）的情况

**code：**
```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
int n,a[2006];
int one,g,mn=1e9;
int gcd(int _a,int _b){return _b==0?_a:gcd(_b,_a%_b);}
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&a[i]);
		g=gcd(g,a[i]);
		if(a[i]==1) one++;
	}
	if(one!=0){printf("%d\n",n-one);return 0;}
	if(g!=1){puts("-1");return 0;}
    //两个特判
	for(int i=1;i<=n;i++)//枚举左端点
	{
		int b=a[i];
		for(int j=i+1;j<=n;j++)//枚举右端点并求值
		{
			b=gcd(b,a[j]);
			if(b==1){mn=min(mn,j-i);break;}
            //小优化：找到1之后再往下去搜显然是不明智的，答案不会更优
		}
	}
	printf("%d\n",mn+n-1);
	return 0;
}
```