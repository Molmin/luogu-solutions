### 题目简述

$A$、$B$、$C$ 三名同学分别有一个**正整数**，教授重复对 $A$、$B$、$C$ 三位同学按顺序进行提问，每位同学知道除自己以外另外两个人的数，直到有一位同学猜出自己的数为止。

给定两个数据 $N$、$M$，表示当教授第 $N$ 次提问时，轮到回答问题的那个人猜出了贴在自己头上的数是 $M$。

显然可以通过 $M \mod 3$ 得到猜出人所在的位置。$0$ 对应 $C$，$1$ 对应 $A$，$2$ 对应 $B$。

### 思路分析

#### 特殊情况分析

 假设有一名学生 $X$，当他看到另外两个人的数相同时，立马可以得出自己的数为两者之和，因为给定的数是正整数，不可能是两者之差。

#### 切口

对于一名学生 $X$，他所对应的数显然有两种可能，另外两者之和 $sum$ 或另外两者之差 $dif$。

根据题目给出的提示：**总是头上贴着最大的那个数的人最先猜出自己头上的数。** 原因是因为将两者之差的情况排除了。于是从排除两者之差的方面入手。

当 $X$ 假设自己头上的数为 $dif$，**若在他的假设视角中的代表他与另一个较小数的和的人应该猜出来时，却没有猜出来，那么说明此时他并不是两者之差，而是两者之和。**（根据题目提示，当 $X$ 为较小的那个数时，他假设中的那个和一定最先猜出来。）

#### 带入样例加以解释
假设 $A$、$B$、$C$ 三人对应的数分别为 $2$、$8$、$6$。

首先从 $8$ 的视角入手，$8$ 这么想到：

假如我是 $6$ 与 $2$ 的差 $4$，那么当我为 $4$  时，$6$ 一定比我先猜出来。

于是来到 $8$ 假设的 $6$ 视角（此时三个数为 $2$、$4$、$6$）：

假如我是 $4$ 与 $2$ 的差 $2$，那么当我为 $2$  时，$4$ 一定比我先猜出来。

于是来到在 $8$ 的想象下 $6$ 想象的 $4$ 的视角（此时三个数为 $2$、$4$、$2$）：

我是 $4$，此时我发现对面两个数都是 $2$，因此我在第一次询问到我时（第二次），我就能回答我的值为 $4$。

$8$ 想象下的 $6$ 视角：

但是 $4$ 没回答出来，于是在他没回答出来后第一次到我时（第三次），我就能回答出我是 $6$。

$8$ 视角：

但是 $6$ 没回答出来，于是在他回答之后第一次到我时（第五次），我就能回答出来我是 $8$。

不难看出以上过程是个递归。且当我们知道三个数时，就可以通过如上过程推出需要的次数。于是**转求解为验证**。知道和 $M$，枚举两个数，计算次数，验证是否与题目所给的 $N$ 次数一样，一样则是可行解。

### 代码

```c
#include<iostream>
#include<cstdio>
#include<cmath>
using namespace std;
int n,m,a[30005][3],cnt,ans;
int k[4][4];
int p(int x,int y){
	if(x<y) return y-x;
	else return y+3-x;
}
void dfs(int i,int j,int t1,int t2,int t3){
	if(ans>n) return;
	if(i==j) ans+=t3;
	else if(i>j) ans+=k[t1][t3],dfs(i-j,j,t3,t2,t1);
	else ans+=k[t2][t3],dfs(i,j-i,t1,t3,t2);
	return;
}
int main(){
	for(int i=1;i<=3;i++){
		for(int j=1;j<=3;j++){
			if(i==j) continue;
			k[i][j]=p(i,j);
		}
	}
	while(1){
		scanf("%d%d",&n,&m);
		if(n==-1&&m==-1) break;
		for(int i=1;i<m;i++){
			ans=0;
			if(n%3==1){
				dfs(i,m-i,2,3,1);
				if(ans==n) a[++cnt][0]=m,a[cnt][1]=i,a[cnt][2]=m-i;
			}
			if(n%3==2){
				dfs(i,m-i,1,3,2);
				if(ans==n) a[++cnt][0]=i,a[cnt][1]=m,a[cnt][2]=m-i;
			}
			if(n%3==0){
				dfs(i,m-i,1,2,3);
				if(ans==n) a[++cnt][0]=i,a[cnt][1]=m-i,a[cnt][2]=m;
			}
		} 
		printf("%d\n",cnt);
		for(int i=1;i<=cnt;i++) printf("%d %d %d\n",a[i][0],a[i][1],a[i][2]);
		cnt=0;
	}
	return 0;
}
```


