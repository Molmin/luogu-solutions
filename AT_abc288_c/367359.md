# [ABC288C] Don’t be cycle 题解

## 前置知识

并查集。

## 题意

给定一个简单无向图，要求删除最小的边数（可以不删）使得图中没有环。

## 题解

一开始可能会觉得就是 $m-n+1$，但第三个样例就否了这种做法，看样例就能明白。每增加一条边，设两个顶点为 $a$ 和 $b$，我们只需要看 $a$ 和 $b$ 是否在一个连通图中，在的话就答案 $+1$，否则将两个连通块合并。

如何判断两个点是否在一个连通块内？我们用 $f[i]$ 表示第 $i$ 个结点所在的连通块的代表的编号，每次递归查找 $f[f[f[f[f[\dots]]]]]$，直到这个顶点所在的连通块的代表是自己。每到一个点 $i$ 也要记录 $f[i]=ans$，其中 $ans$ 是递归调用的结果。最后比较递归调用 $a$ 和 $b$ 的结果即可。显然，初始化为 $f[i]=i$。

如何将两个连通块合并？设两个数 $a$ 和 $b$ 递归调用的结果是 $fnd(a)$ 和 $fnd(b)$，让 $f[fnd(a)]=fnd(b)$ 即可。这样 $a$ 里的元素递归调用后一定会先到 $fnd(a)$，然后就会到达 $fnd(b)$。

时间复杂度是多少呢？乍一看是 $O(n^2)$，因为每次递归调用好像是 $O(n)$ 的。然而，我们仔细思考，什么时候会让我们的递归次数上升？当然是合并啊！而一次合并最多让我们多搜索一次，因为搜了一次以后就直接 $O(1)$ 找到答案。更详细的可以自行上网查看，这里不在赘述。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;const int N=2e5+2;
int n,m,a,b,f[N],ans;
inline int fnd(int x){return (f[x]==x?x:f[x]=fnd(f[x]));}//fnd函数
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)f[i]=i;//初始化
	while(m--){
		scanf("%d%d",&a,&b);
		if(fnd(a)!=fnd(b))f[fnd(a)]=fnd(b);//合并
		else ans++;//发现一个环
	}
	return printf("%d\n",ans),0;
}
```