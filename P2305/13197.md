[P2305 [NOI2014]购票](https://www.luogu.com.cn/problem/P2305)  

可以简单的列出$dp$方程：  
设$f_u$为从$u$点到$1$号点的最小花费。 

$f_u=f_t+p_u*(dep[u]-dep[t])+q_u$。  

很明显是斜率优化，但是有限制$l_u$的限制。  

因为$l_u$不单调，肯定不能用单调队列。至于为什么不能直接在上面二分，其他的题解也讲得很清楚了。  

写这篇题解主要是为了说明这样一个地方：再用数据结构（线段树/树状数组）维护区间凸包的时候，不能直接暴力插入。因为每个点都可以把前面的所有点都删掉。每次插入的最高时间复杂度是$O(n)$的(可以用长链加菊花图卡掉)。    

但是这题并没有卡，所以暴力插入的也可以过，但是时间复杂度并不对。  

在代码上来说，就是不可以这样：  
下面的$t[x]$表示$x$维护区间的凸包（下标从$0$开始），$siz[x]$表示$x$凸包的实际点数。
```cpp
while(siz[x]>1 && xielv(t[x][siz[x]-2],t[x][siz[x]-1])>xielv(t[x][siz[x]-1],u))siz[x]--;
```  
要用二分或者倍增插入。  

也就是这样：  

```cpp
int l=0,r=siz[x];
while(l<r)
{
	int mid=l+r>>1;
	if(mid>0 && xielv(t[x][mid],u)<xielv(t[x][mid-1],t[x][mid]))r=mid;
	else l = mid+1;
}
```
代码太丑就不放了，想要验证自己时间复杂度的，uoj上也有hack数据。

