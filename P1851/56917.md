这个题我开始的时候想拿暴力求约数和（就是拿一堆while然后再一个一个的取模），但是TLE了，所以暴力不能出奇迹。

然后我就受到筛法的启发，想到了一个办法，就是给定一个比较大的数N（我设定的是S\*10），要确保第一对非常好友不会超过N，那么我们就要求出N以内的所有约数和，类似筛法那样**枚举2~根号N之间的整数i和i~N/i之间的整数j，然后i和j就是i\*j的两个约数，就把i\*j的约数和加上i和j**，但是根据题意1是除了1以外所有正整数的约数，而这个方法不会算上1，所以**最后使用约数和的时候要加上1**。

求出所有的约数和后，然后的事情就十分简单了，从S+1开始枚举整数P，当P的约数的约数等于P时，这便是非常好友了。

代码如下：

```cpp
#include<cstdio>
#include<cmath>
using namespace std;
int f[200000];    //存储N以内的所有整数的约数和（使用时要加上1）
int main(){
    int n;
    scanf("%d",&n);
    int rn=n*10;    //这便是N，我把它设成了S*10
    int sqr=sqrt(rn);
    for(int i=2;i<=sqr;i++){
        int loop=rn/i;
        for(int j=i;j<=loop;j++){     //要注意的是j必须从i开始，否则会造成重复的约数（比如6就得拆成2*3和3*2，这就重复了）
            f[i*j]+=(i+j);
        }
    }
    int ptr=n;
    while(1){    //枚举S+1开始的所有整数
        ptr++;
        int sum=f[ptr]+1;      //这个“筛法”求出的约数和不会算上1，所以使用的时候要加1
        if(f[sum]+1==ptr){
          if(sum!=ptr){   //题目要求忽略自己是自己的非常好友
                printf("%d %d\n",ptr,sum);
                return(0);
            }
        }
    }
    return(0);
}
```