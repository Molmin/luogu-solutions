最近做了一些数论题目。

不难发现，这就是传说中的相亲数。
```cpp
#define 相亲数 (A的因数和)的因数和==a
```
扯淡结束，回归正题。

----

既然涉及因数，我们能不能将所有数的因数和求出来？

那我们该如何快速地求因数和？

- O(n^2)算法：直接暴力，谁都会，不过，18000^2>10^8，预处理直接TLE(更何况还有一组63020 76084)。
```cpp
	for(int i=1;i<=100000;i++)
	{
		for(int j=1;j<i;j++)
		{
			if(i%j==0)
			{
				pr[i]+=j;
			}
		}
	}
```
- O(n sqrt(n))算法：考虑约数成对出现，注意完全平方数(该方法已经可以AC(76ms))。
```cpp
	int j;
	for(register int i=1;i<=100000;i++)
	{
		for(j=1;j*j<=i;j++)
		{
			if(i%j==0)
			{
				pr[i]+=j;
				pr[i]+=i/j;
			}
		}
		j--;
		if(j*j==i)pr[i]-=j;
		pr[i]-=i;
	}
```
- O(n log(log(n)))算法：筛法优化。
```cpp
	for(int i=1;i<=20000;i++)
        for(int j=i;i*j<=20000;j++)
            pr[i*j]+=i;
```
### 细节
- 在这里，一个数的约数不包括这个数本身。
- **但是，1是这个数的约数**
- 注意在这道题中，忽略那些自己是自己的“非常好友”的情况(#4 496)。
- A不小于S就可以了(---by 日常的癫狂)

----

下面我们就可以O(1)得到约数和了
```cpp
	for(int i=s;;i++)
	{
		if(pr[pr[i]]==i&&pr[i]!=i)
		{
			cout<<i<<" "<<pr[i];
			return 0;
		}
	}
```
至于完整代码，拼接一下就行。