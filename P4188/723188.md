本人的第三篇题解，写的不好请指出哦~


------------
### 题意：

一共 $N$ 个区间，每个区间的起点和终点在 $0$ 到 $10^9$ 之间。要求删除一个区间后求出整体覆盖区间最长的方案。

### 分析：

这道题其实是个贪心啦，用一个简单的结构体数组按照起点排序。排完序遍历每个区间，分类算出这个区间和上个区间重叠的部分。最后用总和去减去一个区间，查看最终最大的可能。

### 思路：

对于每个区间都和上一个区间做比较。

- 如果这个区间的终点小于上一个元素的终点，则这个区间被上个区间完全包含。因为这个区间完全被包含了，所以删了它是最值的（删了不会对原区间覆盖值有任何影响）。

- 如果当前区间的起点比上一个区间的终点小（有交集），则 $ans$ 加上当前区间多出来的值（当前终点减去上一个终点），并将这个值推进队列。当然这里同时要把重叠部分一起推进队列（上一个终点减去当前起点）。这个重叠部分是删了上一个元素后多删了的部分，也就是说假设删了上一个元素，我们要把这个重叠部分给加回来。

- 如果当前区间和上一个区间没有交集，则 $ans$ 加上这个区间的大小。

- **不存在当前起点比上一个起点更早的情况！** 按照起点排序能直接避免这个可能。

### 代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,ans,mx;
struct Node{
	int s,t;
}num[114514],p;//num存所有区间，p存上一个区间
bool cmp(Node a,Node b){
	return a.s<b.s;//按照起点从小到大排序
}
bool flag;
int main(){
	cin >> n;
	for(int i=0;i<n;i++)cin >> num[i].s >> num[i].t;
	sort(num,num+n,cmp);
	queue<Node>q;//队列储存删除每个元素对整体覆盖区间影响的值
	for(int i=0;i<n;i++){
		if(num[i].t<=p.t)flag=1;//如果中间有个值被覆盖了，则最后直接输出答案
		else{
			if(num[i].s>p.t){//如果当前区间和上个区间没有交集
				ans+=num[i].t-num[i].s;//直接加上这个区间的大小并推进队列
				q.push({num[i].t-num[i].s,0});
			}else if(num[i].s<=p.t){
				ans+=num[i].t-p.t;//如果有交集，则加上后面多余的部分
				q.push({num[i].t-p.t,p.t-num[i].s});//这里同时存入当前区间起点和上个区间终点的差值
			}
			p=num[i];
		}
	}
	if(flag){
		cout << ans;//直接输出答案并退出
		exit(0);
	}
	while(!q.empty()){
		Node t=q.front();
		q.pop();
		mx=max(mx,ans-t.s+q.front().t);//这里如果删除了某个元素，则要加上多删除的重叠部分
	}
	cout << mx;
}

```
