#### 水话
这道题一开始，我看成了是要把钱花完，后来一看，根本不需要强制把钱花完。

#### 思路&做法
首先很显然的一点，就是我们显然要先选编号小的，因为对于每一个玩具，它们对答案的贡献是一样的，但是编号小的花费就小，那为什么不买小的？

（倘若强制要求钱恰好花完，这个贪心的正确性就没了，因为不能保证有解)

我们可以很容易的证明答案显然不会超过$\sqrt{2*m}$，假设答案是最多买$k$个，因为每一个玩具只能买一次，就算按照$1,2,3,4,5,6,7,8...k - 2 , k - 1 , k$这样子买，这个式子的答案就是$\frac{k*(k-1)}{2}$，这个$k$也不会大于$\sqrt{2*10^9}$

倘若你换做更劣的购买方式，那么答案显然还会更小。

那么大于$2 * 10^5$的数我们还需要保存吗？很显然不用。因为在$2*10^5$任意取$10^5$个数，它们的和就一定可以大于$10^9$了，我何必去枚举大于$2*10^5$的数?为什么要开到$2*10^5$，是因为可能所有的一开始已经有了的玩具的编号都小于等于$2*10^5$！

所以按照这个方式扫一遍，最坏时间复杂度是O$(n + \sqrt{m})$的，这也就是为什么我能跑到运行时间$Rank1$.......。用$map$者最坏$O(nlog(n) + \sqrt{m}$ * $map$的大常数)，数据大点不怕会挂吗.......

```cpp
#include <iostream>
#include <cstdio>
using namespace std;
const int MAXN = 200005,Max = 200000;
bool book[200005];//用于标记哪一些是已经有了的。
int arr[100005],n,tail = 0,M;

inline int read()
{
	int x = 0 , flag = 1;
	char ch = getchar();
	for( ; ch > '9' || ch < '0' ; ch = getchar());
	for( ; ch >= '0' && ch <= '9' ; ch = getchar())x = (x << 3) + (x << 1) + ch - '0';
	return x * flag;
}

int main()
{
	n = read() , M = read();
	for(int i = 1 ; i <= n ; i ++)
	{
		int x = read();
		if(x <= Max)//如果x > 2e5就没必要存了
		book[x] = 1;
	}
	for(int i = 1 ; i <= Max ; i ++)
	{
		if(book[i])continue;
		M -= i;
		if(M < 0)break;//买不起了，就弹出来。
		tail ++ , arr[tail] = i;//进入答案队列
	}
	printf("%d\n",tail);
	for(int i = 1 ; i <= tail ; i ++)
		printf("%d ",arr[i]);
	return 0;
}
```

题外话：

建议这道题注明$SPJ$！一开始我差点被吓得不敢交，因为这道题貌似没有注明是$SPJ$

另外这道题作为蓝题确实数据水了点，建议$m$增大到$5*10^{13}$,$n$增大到$8*10^6$，或者可以把这道题的难度评分下调。