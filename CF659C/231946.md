### ~~水话~~

题目难度最多是个黄啊，为什么是蓝啊喂！

这个题目过于简单，下边的题解已经讲的清楚了，但是我觉得还能再优化以时间，让他跑的更快（适合于这个题的思路已经会了的童鞋），这个思路有很多场景的应用。

首先你要知道为什么这个题目用不普通的桶不行，因为太大了，十亿的话空间肯定会没，所以有的小机灵鬼就会说:"我会 map！"。对，map 可以解决空间的问题，但是 map 时间复杂度太高了，数据强的话会超时。但我们转念一想，十亿好像是钱数诶，所以如果前边的全都买的话就只买 $44721$ 个钱就不够花了，那么这样的话空间开到 $44722$ 就可以了，这个数是怎么算出来的呢？当然不是手算啊，你不是有计算机吗！

```
#include<bits/stdc++.h>
#define int long long
using namespace std;

signed main(){
	int i=1,j=0;
	for(i=1;j<=1e9;i++,j+=i);
	cout<<i;
	
}

```
自己写个简单的代码就能算出来的。但你如果空间开到这个数如果数据强一点的话也会被爆（不是指范围变大，而是再范围内数据变强），为什么呢，不是最多 $44721$ 吗？那万一之前买的物品是前十万呢，按就要买到 $109545$ 个才行，怎么算出来的呢？就是把上边的代码的 `i=1` 换成 `i=1e5` 就可以了。

剩下的就贪心就行了。

```
#include<bits/stdc++.h>
#define int long long
const int N=119540;//开大一万，安心 
using namespace std;

int n,m,x,t[N],a[44722],ans;
 
signed main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++)
	{
		scanf("%lld",&x);
		t[x]=1;
	}
	for(int i=1;i<=m;i++)
	{
			if(t[i]==0)
			a[++ans]=i,m-=i;
	}
	cout<<ans<<endl;
	for(int i=1;i<=ans;i++) printf("%lld ",a[i]);
	return 0;
}

```
