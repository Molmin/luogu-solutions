挺妙的

考虑反着做。先随意构造一个初始序列 $a$ 使 $\forall a_i < n$，随后进行 $k$ 次操作。每次操作选一个 $i$ 并使 $a_i = a_i + n$，并将其它数 $-1$。需要满足：

- 操作后 $i$ 的整个序列的最大值；
- $\forall a_i \ge 0$。

如下简称以上操作为 反操作。

若 $k$ 次反操作均符合限制条件，则最后的序列 $a$ 需要的操作次数一定 $=k$。

---------

我们发现对于一个长度为 $n$ 且形似 $\{x, x+1, \ldots , x+n-1 \}$ 的序列，对 $i$ 从 $1$ 到 $n$ 顺序做 $n$ 次操作后等价于序列整体 $+1$。

所以可以令初始序列 $a = \{ 0, 1, \ldots , n-1 \}$。

随后做 $\lfloor \dfrac{k}{n} \rfloor$ 次序列全体 $+1$，然后剩余操作次数为 $k = k \bmod n$。

然后对于 $i$ 从 $1$ 到 $k$ 顺序做 $k$ 次操作即可。显然满足反操作的限制条件。

---------

题目限制 $k \le 50 \times 10^{16}$，$0 \le a_i \le 10^{16} + 1000$，从而可能会卡满 $n=50$。对于一个 $k$，$n$ 的下限是 $\max(2, \, \lceil \dfrac{k}{10^{16}} \rceil)$。所以我们构造这个 $n$ 的答案即可。当然也可以直接构造 $n=50$ 的答案。

```cpp
int n;
ll a[55];

int main() {
	ll k; qread(k);
	n = max(2, (int)ceil(1.0 * k / 1e16));
	rep(i, 1, n) a[i] = i - 1;
	rep(i, 1, n) a[i] += k / n;
	k %= n;
	rep(i, 1, k) {
		a[i] += n;
		rep(j, 1, n) if(j != i) --a[j];
	}
	cout << n << endl;
	rep(i, 1, n) cout << a[i] << ' ';
	return 0;
}
```