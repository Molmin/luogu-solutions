# 题目

[ARC162C](https://www.luogu.com.cn/problem/AT_arc162_c)

# 思路

我们考虑 Alice 会在哪一个子树上获胜。 获胜子树必须满足以下条件：

1. 子树中的数字没有 $k$。
2. 子树中空结点的数量不少于缺少的数字的数量。
3. 在 Alice 填完所有空结点之前，Bob 不会来捣乱。

定义“可能的获胜子树”为满足 1、2 号条件的子树。

只要 Bob 在一个节点填入 $k$，从这个节点到根的所有节点都不能成为获胜子树的根节点。这样他可以同时破坏多个可能的获胜子树，我们考虑把这种情况化简。

假如 $u$ 和 $v$ 所代表的子树都是可能的获胜子树，而 $v$ 在 $u$ 的子树中。那么，只要 Bob 破坏了 $v$ 就能破坏 $u$，因此 Alice 肯定会放弃 $u$ 而保住 $v$。这样就缩小了可能的获胜子树的范围，使他们的子树互不相交。

因此，原问题被转化为了以下问题：给定若干个非负整数，Alice 可以把一个数字减一，Bob 可以删除一个数，两人轮流操作，Alice 先手，只要任何一个数变成了 $0$ 则 Alice 获胜，否则 Bob 获胜。

其中，每个“数”对应每个可能的获胜子树中空结点的个数。

可以分情况讨论：

- 若所有数中存在 $0$ 或 $1$，则 Alice 获胜。
- 若所有数中不存在 $0$ 或 $1$，只要 Alice 减小哪个数，Bob 就删除哪个数，因此 Bob 获胜。

因此，我们只需判断是否存在可能的获胜子树只有不超过一个空结点即可。因为 $N$ 只有 $10^3$，我们可以暴力枚举每个子树的信息，复杂度 $O(N^2)$。如果这题升级为 $N\le10^5$，那就可以考虑用 dsu on tree 维护，复杂度 $O(N \log N)$。

# 代码

[Code](https://atcoder.jp/contests/arc162/submissions/42837792) 

