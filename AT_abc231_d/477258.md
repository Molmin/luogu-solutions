注：以下设 $m$ 为图的边数，$n$ 为图的点数。

显然不应该把此题当成一道数组类的题目来想。考虑转化。

把数组的每一个位置抽象成每一个点，问题就会被转化成：在一张图里有一些边，问能不能再连一些边使得全图变成一条链。

显然链是树的一种，而树的边数即为顶点数减一（即，$m = n - 1$），于是当数据中出现 $m \geq n$ 的情况时，直接输出 `No`，这是一个小优化。

接下来分析链的性质：

- 一条链的任何一个点的度数最多为 $2$。

因此，在建完图后，我们可以顺序遍历一遍每个点，判断其度数；如果度数大于等于 $3$，直接输出 `No` 结束。

- 链是无环的。

原因显然。树是无环的，作为树的一种的链自然也应该无环。

判断图上是否有环的方法很多，常规的做法是并查集，或者深搜。本篇题解使用深搜。**注意不能使用拓扑排序，因为拓扑排序是针对有向图的，而读完条件后易知本题的图是无向图。**

还有几个细节：

> $1 \leq A_i < B_i \leq N$。

说明每一组 $A_i$ 和 $B_i$ 都是不同的，从而排除自环。

> 保证所有的 $( A_i , B_i )$ 都是不同的。

显然这意味着图上没有重边。

另外，注意到可能会出现 $m < n - 1$ 的情况，即该图不连通。因此，判环的深搜应该在每个点上都进行一次。

综上，此题做完了。

```cpp
#include <iostream>
#include <vector>
using namespace std;
vector<int> v[100001];//这里使用了边表来存图。
int n,m,u0,v0;
bool vis[100001];
void dfs(int u,int f){
	if(vis[u]){
		cout<<"No\n";
		exit(0);
	}
	vis[u]=1;
	for(auto v1:v[u]){
		if(v1!=f) dfs(v1,u);
	}
}//注意到这个深搜没有将vis数组重新归零。
int main(){
	cin>>n>>m;
	if(m>=n){//提前特判。
    //其实没有这个特判也行，这只是一个小优化。
		cout<<"No\n";
		return 0;
	}
	for(int i=1;i<=m;i++){
		cin>>u0>>v0;
		v[u0].push_back(v0);
		v[v0].push_back(u0);//注意是无向图。
	}
	for(int i=1;i<=n;i++){
		if(v[i].size()>2){//判断点的度数。
			cout<<"No\n";
			return 0;
		}
	}
	for(int i=1;i<=n;i++){
		if(!vis[i]) dfs(i,0);//由于深搜没有将vis数组重新归零，所以已经被遍历过的点不能再遍历一次，否则答案会出错。
        //当然，如果深搜有将vis数组重新归零的话，已遍历的点就可以重新遍历。
	}
	cout<<"Yes\n";
	return 0;
}
```
