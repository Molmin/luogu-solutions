# 蒟蒻开始写题解了······跪求各位神犇轻喷······
## 这道题主要在于利用搜索的方法，暴力通过，不过呢，当数据达到12和13时，效率就会变慢，所以，用二进制优化的算法，可以将时间复杂度再降一半。
### 本来此题应该用四个bool数组来存纵，横，正斜（左下到右上），反斜（左上到右下），不过呢，仔细审题，可以发现，这题因为一列只有一个皇后，所以可以降维，也就是说，搜索皇后即就是把列考虑进去了，因此，只需三个数组便可以。

------------

### 上述只是为了优化一下朴素搜索的数据存储，即一层循环便可做到，而我所说的二进制优化，只需一个存答案的数组即可。

------------
![](https://cdn.luogu.com.cn/upload/pic/71392.png)

------------
由于每一个黄点只决定了下一列与它相邻三个点不能存放，因此我们就可以在搜索时将它所影响的点标记掉，将每一列的（ 行 | 正斜 | 反斜 ）即可得到 一串 01数列，这个数列的意义在于每个是0的位置表示没有被占过，而有1的则是被影响到的，我们每次都要得到数列的最后一位，来进行判断，为了去最后一位，用 1 & 上述结果，再右移一位，然后递归操作。这样就可以完成搜索操作。关键代码如下：
```cpp
int s=r | z | f;//r是横，z是正斜，f是反斜，s存结果
	for(int i=1;i<=n;i++)
	{
		if(!(s & 1))
		{
			a[k]=i;
			query(k+1,r | re,(z | re)<<1,(f | re)>>1);
		}
		s=s>>1;
	}
```
递归操作的时候，re是指1向左移i-1位，用横行 | re，便是下一列这一行，斜行对应左移1位和右移一位。
##### 出口要提前设，当搜索的层数大于n+1时，就判断ans累加结果是否>3，然后输出队列即可；
###### 完整代码如下：
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cstdlib>
#include<cmath>
#include<algorithm>
#define maxn 1000
#define re 1<<(i-1)
using namespace std;
int n,m,ans,a[maxn];
void query(int k,int r,int z,int f)
{
	if(k>n)
	{
		if(++ans<=3)
		{
			for(int i=1;i<n;i++)
			  printf("%d ",a[i]);
			printf("%d\n",a[n]);
		}
		return;
	}
	int s=r | z | f;
	for(int i=1;i<=n;i++)
	{
		if(!(s & 1))
		{
			a[k]=i;
			query(k+1,r | re,(z | re)<<1,(f | re)>>1);
		}
		s=s>>1;
	}
}
int main()
{
	scanf("%d",&n);
	query(1,0,0,0);
	printf("%d\n",ans);
	return 0;
}
```
# 求大佬轻喷
