我也和各位一样，看到这题没思路，然后开始抄题解，但是由于我执意要用二维数组（大家都认为这是一个很慢的方法）来储存棋盘，导致我套一个题解的时候超时，于是我开始了独立的长时间思考，最终我发现了现在的这个方法——仅适用于二维数组而又比除了位运算题解之外最快最准确的方法（有一个题解在算14的时候不太对，有可能因为他开小了），在此希望广大和我一样的不太擅长这个的多想一想，有可能会觉得不值得，在一个题上至于下这么大功夫吗？但是只有这样你才能创造历史（虽说我没有创造过历史）。

我其实很菜，以前被貌似是管理员的人虐过。

下面是题解，所用的方法就是每次放入一个棋子，我就把他变成1，然后创造m1，m2，m3这三个数组去储存他们在分别的竖斜行的位置上有多少个棋子。而横行是不需要考虑的，因为我就是按顺序从第一行放到最后一行。

重申一下，不怕浪费时间，一定要多思考。

```cpp


#include<iostream>//斜的m2，m3需调整。 
using namespace std;
int chess[20][20]={0};//按照(第几行，第几列)的标准
int ans[20][100000]={0};
int count1=0;//解的个数
int c=0;//被放入的第几个棋子 
int n;
int a1=0;
int m1[100]={0},m2[100]={0},m3[100]={0};//m1竖行，m2左斜，m3右斜，这里一定要开大一点，因为斜行比较多。 
void dfs (int x, int y)
{
    int x1,x2;
    int i;
    c++;
    ans[c][count1]=y;
    m1[y-1]++;
    x1=(n-x+1)+y-2;
    x2=x+y-2;
    m2[x1]++;
    m3[x2]++;
    chess[x][y]=1;
    if(c==n)
    {
        //cout<<"hello"<<endl;
        if(a1<=2)
        {
            for(i=1;i<n;i++) ans[i][count1+1]=ans[i][count1];//记录第几个解，事实上只需要记录到这里，因为只要三个解 
            a1++;
        }
        chess[x][y]=0;
        count1++;
        c--;
        m1[y-1]--;
          m2[x1]--;
          m3[x2]--;
        return;
    }
    for(i=1;i<=n;i++)//计算第x+1行i列的这个子与之前的是否冲突
    {
        int e1=i-1;
        int e2=n-x+i-2;
        int e3=x+i-1;
         if((m1[e1]+m2[e2]+m3[e3])==0) 
        {
            dfs(x+1,i);
        }
    }
    ans[c][count1]=0;
    c--;
    chess[x][y]=0;
    m1[y-1]--;
    m2[x1]--;
    m3[x2]--;
    return;
}
int main ()
{
    count1=0;
    int i,j;
    scanf("%d",&n);
    for(i=1;i<=n;i++)
    {
        dfs(1,i);
    }
    for(i=0;i<count1;i++)
    {
        if(i>2) break;
        for(j=1;j<=n;j++) 
        {
            printf("%d ",ans[j][i]);
        }
        printf("\n");
    }
    printf("%d",count1);
    system("pause");
}

```
务必给我通过审核啊。
