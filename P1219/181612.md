## 船新解法：位运算

八皇后是一个经典的回溯法练习题。可以扩展到n\*n的棋盘。

常用的解法是二维数组，但是超级慢。我们可以另辟蹊径：一个棋盘的格子只有两种可能：0或1。现在要满足，每一条横行竖列对角线至多一个1，其它都为0。既然这样，我们为什么不想想整数呢？整数是32个0和1的位组成的，刚好可以表示每一个状态。

基本思路还是这样，从上往下进行，一行只放一颗棋子，然后再检查它对竖列和对角线的影响。只不过，要用位运算表达出来。比如，某一行的状态是00001000（也就是整数8），那么下一行的禁止位置（用x表示）就包括：000x0000（左对角线，整数16），0000x000（竖列，整数8），00000x00（右对角线，整数4）三个。这是基本情况。

另外，影响下一行的不只是上一行，还有上两行，三行...等等等等。那么我们看一下，00001000对下两行的禁止位置，分别是00x00000，0000x000，000000x0这三个。

所以，可以这样设计。如果已知某一行的左对角线禁止位置为l，竖列禁止位置为d，右对角线禁止位置为r，这一行放棋子的状态为s，则有下列位运算表达式：

本行禁止位置（记为forbid）为：`forbid = l | d | r`

下一行左对角线禁止位置：`(l | s) << 1`

下一行竖列禁止位置：`d | s`

下一行右对角线禁止位置：`(r | s) >> 1`

某个状态s可放棋子：`(forbid | s) != forbid`

这样，运行速度可以达到常规数组法的4-10倍。如果用数组法TLE的童鞋不妨试试这个方法。

另外，根据实际测试，这个程序能跑动的最大n就是15。所以，用32位整数是足够的。

特别需要注意的是，C语言的右移运算有“算术右移”和“逻辑右移”的区别，前者是高位补符号位，后者是高位补0。我们需要的正是后者，但不同编译器对有符号数右移的解释并不相同。所以为了避免这个bug，表示状态的整数应该为unsigned。

最后贴一下AC代码：

```cpp
#include <stdio.h>
#include <stdlib.h>

int cnt;
int arr[15];

void n_queens(int n, int k, unsigned down, unsigned left, unsigned right)
{
    unsigned forbid = down | left | right;
    if (forbid == (1 << n) - 1) return;
    unsigned m = 1 << (n - 1);
    int i;
    for (i = 1; m > 0 ; i++, m >>= 1)
    {
        if ((m | forbid) != forbid)
        {
            arr[k] = i;
            if (k >= n - 1)
            {
                cnt++;
                if (cnt <= 3)
                {
                    for (int j = 0; j < n; j++) printf("%d ", arr[j]);
                    printf("\n");
                }
            }
            else n_queens(n, k + 1, down | m, (left | m) << 1, (right | m) >> 1);
        }
    }
}

int main()
{
    int n;
    scanf("%d", &n);
    cnt = 0;
    n_queens(n, 0, 0, 0, 0);
    printf("%d", cnt);
    return 0;
}

```