这题有比较好理解的O(nm$log_2^n$)的分治做法

首先考虑暴力，O(m$n^2$),枚举哪个不取，然后暴力背包~~（事实上，本题数据很水，可以直接过）~~

题目上标的2 * 103希望管理改一下，应该是$2*10^{3}$

那么在这样的数据下，暴力是过不了的，我们考虑，我们计算的时候有很多重复计算，那么我们可以把数据分成两段,举个例子

![](https://cdn.luogu.com.cn/upload/pic/23774.png)

比如说我们要求左边的答案，那么我们就先将右边的5678更新了

详细一点，比如说求不取1：

>1.更新5678

>2.更新34

>3.更新2

>4.得到答案

然后比如继续求2

>1.移除对2的更新

>2.更新1

>3.得到答案

然后求34

>1.移除对34的更新

>2.更新12

>3.得到答案

这样可以避免计算很多冗余状态（当然这不是最优方案）

分治树总共logn层，每层需要枚举的元素总数为n,容积为m，总复杂度O(nm$log_2^n$)

看一下分治主体：
```cpp
int f[2123];
int a[2123];

int n(read());
int m(read());

void binary(int l,int r)
{
	if(l == r)
	{
		for(int i(1);i <= m;++i)putchar('0' + f[i]);
		putchar('\n');
		return;
	}//分治到某一个点，输出答案，因为先分治左边，所以答案显然是有序的 
	
	int tmpc[2123];//记录更新右区间前的数组 
	int mid((l + r) >> 1);
	
	for(int i(1);i <= m;++i)tmpc[i] = f[i];
	for(int i(mid + 1);i <= r;++i)
	{
		for(int j(m);j >= a[i];--j)
		{
			f[j] = (f[j] + f[j - a[i]]) % 10;
		}
	}//对右边做背包 
	binary(l,mid);//分治左边 
	
	for(int i(1);i <= m;++i)f[i] = tmpc[i];//取消对右边的更新 
	for(int i(l);i <= mid;++i)
	{
		for(int j(m);j >= a[i];--j)
		{
			f[j] = (f[j] + f[j - a[i]]) % 10;
		}
	}//对左边做背包 
	binary(mid + 1,r);//分治右边 
}
```
