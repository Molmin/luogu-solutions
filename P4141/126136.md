### 题解：

一. 前言

这道题是老师在 qbxt 讲的，现在想起来了，写篇题解加深记忆，同时希望能帮到和我一样的萌新.

二. 具体解法

1. 我们先考虑都可以选的情况.

   - 设 f[ x ] 表示全部物品都可用恰好装满 x 体积时的方案数，这不就是01背包吗，求出即可（别忘了第二维倒序循环）.
   
   - 这是总方案数.

2. 然后我们考虑不选某物品的情况.

   - 设 g[ x ] 为不选当前物品恰好装满 x 体积时的方案数.

	- 当x小于 w[ i ] 时， i 物品一定不会被选上 g[ i ] = f[ i ]. 

	- 当x大于等于 w[ i ] 时， i 物品可能会被选上.

	- 总方案数即 f[ x ] ，不选的方案数可以想为先不选 i 再最后把 i 选上,即 g[ x - w[ i ] ]。 

	- 所以 g[ x ] = f[ x ] - g[ x - w[ i ] ]， x 从小到大枚举计算 g 即可。

3. 时间复杂度

	- 每次都是线性复杂度，一共 n 次计算，总复杂度是 O(n * m).
    
下面上代码（我知道各位大佬也不需要代码）：

```
#include<iostream>

#define N 2019

using namespace std;

int n,m,f[N]={1},g[N]={1},v[N];//初始化 

int main()
{
	cin>>n>>m;
	for(int i=1;i<=n;i++)  
		cin>>v[i];
	
	for(int i=1;i<=n;i++)//这里先将f数组求出，和0/1背包一样 
	{
		for(int j=m;j>=v[i];j--)//别忘了0/1背包倒序枚举 
	  		f[j]=(f[j]+f[j-v[i]])%10;//选了的方案加上没选的方案 
	}
	  
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)//要正推，因为后面的g要用到前面不加这个物品的方案数 
		{
			if(j-v[i]>=0)  g[j]=(f[j]-g[j-v[i]]+10)%10;//见上方推导过程,还有,怕出现负数取模，先加一个10 
			else  g[j]=f[j]%10;//没选这个物品（体积不够） 
			cout<<g[j];
		}
		cout<<endl;//注意输出格式 
	}	
		
	return 0;//各数别忘了取模 
}
```

去掉空行后20来行，也是比较短的了.

###  _[Plus Ultra!](https://www.luogu.org/blog/OnePunchManGO/)_ 