第一个lct做法第二个spfa做法 


------------

这个基本算是lct裸题

但也学到了一点套路

如果要维护边权的话就将边看做一个点然后连接相应的两个点

至于这个点的编号？和输入的编号对应起来就好了，方便我们查找这个点对应的边的信息

这个题只需要每次将a相同的边的b权值加入树中，当前的答案就是a[i]+min(1~n路径上的最大值)

若连边连出环了怎么办？先将点x和y中最长的边cut掉再加入就好了 


------------

smg啊……一开始的想法是二分a和b……

后来又口胡了一种算法只有15分…… 

最后发现我还是too young too simple

第一次听说到SPFA动态加边（点）这种操作orz

因为边权有两个，求起来是十分麻烦的

而正解好像是LCT，然而可能很多人并不会

所以那我们就把边a排序，然后将边按a从小到大加入，再按b为权值跑SPFA

每次加一条边的时候，将边两边的端点入队再SPFA。

而且因为边是按a从小到大加入的，所以后面dis情况会包含前面的情况，dis数组就不用每次memset每次重新求了 

[代码](http://www.cnblogs.com/refun/p/8682241.html)