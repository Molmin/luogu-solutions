# 暴力求法
既然各位dalao都是用的上下除以gcd，那我就整点不一样的。。。。

#### 约分的定义：

### 约分是分式约分,把一个分数的分子、分母同时除以公因数。
 
其实这种方法在很多题中 _**不适用**_ ，但是

“对于 100% 的数据，保证 3≤n≤100，半径长度在 1∼1000 之间（含端点） 。”


瞬间眼前一亮，这么小的数据，我可以用一些特殊的办法。。。。

### 简单来说，就是将上下每次 _**都%i**_ ，同时不断将 _**%i**_ 等于0的数除以i

这样做有两个原因：

1.只要一个数a%另一个数b得0， _**则a可以整除b**_ ,如果分子分母都可以整除一个数，那么就满足定义，此时的i就是两者 _**公因数**_ ，这样不断处理就可以得出正确的结果了。

2.~~数据水~~

这题还有一点**细节**

不能从 _**前往后**_ 枚举i，举个例子：

8除以4

如果从前往后处理

只能处理成

4/2

很明显，这不是最优

为什么？

因为它们的最大共因数为4，然而当他们除以2之后，无法再除以2

简单来说

就是当这个数的最大公因数是 _**完全平方数**_ 时，就会出问题

似乎不大好办，但是如果我们 _**从后往前**_ 枚举，那么这个问题
就可以得到解决

上代码
```cpp
#include<iostream>
using namespace std;
int n,m,a,o;
int main(){
	cin>>n>>m;
	o=m;
	//记录原始m因为每次m会改变 
	for(int i=2;i<=n;i++)
	{	cin>>a;
		for(int j=1001;j>=1;j--)
		//从后往前枚举 
		if(m%j==0&&a%j==0){
			m=m/j;
			a=a/j;
		}
		//进行处理 
		cout<<m<<'/'<<a<<endl;
		m=o;
	}
	return 0;
}
```

##  谢谢观看

# THE END