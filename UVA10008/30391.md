## 题解 UVA10008 【What's Cryptanalysis?】

- 第一次发题解

## 题意分析：
给你T以及T个字符串，你要把里面的字母出现次数统计出来，并按照降序输出，如果字母出现的次数相同，字典序靠前的字母输出在前面。
- 不区分大小写，输出时按照大写输出。

---
- 例如输入 1 / Abbcd，你应该输出
```
B 2
A 1
C 1
D 1
```
这是因为B出现了2次，而A/C/D都只出现了一次，你应该就先输出“出现了2次的字母”，再输出“出现了1次的字母”

---

## 知识点：
### ASCII码
- 大写字母A的ASCII码是65。当然，如果你不记得了，你可以用'A'来代替这个数字

### getline
- 整一行读进一个字符串。
- 使用方法：getline(cin,st);
- 意思就是把整行都读入到st里面去

### 数组下标计数
- 在统计数字出现的个数中总是要用到的。

---
## 解题思路
在将T个字符串读入进来的时候使用数组下标计数，统计每个字母出现的次数。然后从最大值到最小值，从A到Z进行双重循环的扫描。

思路差不多是这样子的。

$ for\space (i=max;i>=1;i--)$
$for\space (j='A';j<='Z';j++)$

---
## AC 代码（C++）
```
#include<bits/stdc++.h>
using namespace std;
//万能头

int Counter[30],i,j,T,ma;
//Counter是统计字母出现的次数用的数组。
//i、j是循环用变量。
//T是字符串的行数。
//ma指maximum，存26个字母中，出现次数最多的那个值
string st;
//用来读入与分析的字符串
char convert(char a)
{
	if(a>='A'&&a<='Z')
		return a-'A'+1;
	if(a>='a'&&a<='z')
		return a-32-'A'+1;
	return 0;
}
//将a/A转为1，b/B转为2，c/C转为3，……（涉及到ASCII码了
//末尾+1的作用，是让A从0变成1，B从1变成2，……（习惯了，改不来）
int main()
{
	scanf("%d",&T);
    //共有T组数据
	getchar();
    //由于这里会有个空行，还要用getchar吃掉这个空行，不然下面的“getline”会执行少一次
	while(T--)
		{
			getline(cin,st);
            //从输入读一整行到st
			for(i=0;i<st.length();i++)
            //字符串只有0~len-1位。这是和Pascal不相同的地方~
				if((st[i]>='A'&&st[i]<='Z')
					||
					(st[i]>='a'&&st[i]<='z'))
				//是字母才统计
                Counter[convert(st[i])]++;
                //先将字符串的第i位转换成a/A->1，b/B->2，再使用下标计数~
		}
	for(i=1;i<=26;i++)
		ma=max(ma,Counter[i]);
    //26个字母里面找出现次数的最大值
	for(i=ma;i>=1;i--)
		for(j=1;j<=26;j++)
    	//末尾双重循环扫描。i代表的是当前扫描中的出现次数，
        //j代表的是第1~26个字母，如果当前出现次数=当前在扫描中的出现次数，就能输出。
			if(Counter[j]==i)
				printf("%c %d\n",j+'A'-1,i);
            //j+'A'-1的作用是将1->A，2->B，3->C，……
	return 0;	
}
```
---
## 总结：字符串模拟
我的文学素养有限，如果一定要讲得清清楚楚……可能做不到……这次的题解就到这里