## 一道入门难度的树形DP题  
首先我们必须要知道这样一个结论：  
```
任取一点为根结点，遍历整棵树，找到距离结点1最远的点s1。s1必为直径的一个端点。

以s1为根，找到距离s1最远的点s2，s1→s2即为直径。
```
蒟蒻的证明：(会证明的大佬自行跳过)  
假设距离结点1最远的点s1不是直径的端点，s3,s4才是直径端点 
因为s3→s4是直径  
所以易发现1→s3或1→s4必定大于1→s1。(可以自己画图试试)  
显然，s3或s4才是距离结点1最远的点，违反假设，假设不成立。原结论正确。    
证毕  
显然有了这个结论，这道题目已经不难AC了，代码：  
```cpp
#include<cstdio>
int a,b,s,n; //a:最大距离 b:记录结点
int main()
{
	scanf("%d",&n);
	for(int i=2;i<=n;i++)  //寻找距离1最远的s1
	{
		printf("? 1 %d\n",i);
		fflush(stdout);  //翻译已经说了输出格式
		scanf("%d",&s);
		if(a<s)a=s,b=i;  //记录s1和最大距离
	}
	for(int i=1;i<=n;i++)if(i!=b)  //再找距离s1最远的s2
	{
		printf("? %d %d\n",b,i);
		fflush(stdout);
		scanf("%d",&s);
		if(a<s)a=s;  //记录最大距离
	}
	printf("! %d\n",a);  //输出最大距离(换行！)
	fflush(stdout);
	return 0;
}
```
题目不是很难，大家一定要独立完成哦~