作为本题的首 A，蒟蒻非常高兴，于是特意写了一篇题解来纪念。

## 题意简述

给定一棵树，其中每条边的权值为 $1$，树上每个结点有 $0$ 或 $1$ 个宝石，求从某个结点出发拿到所有宝石再回来的最短路径。

## 题目分析

先考虑从 $x$ 到一个宝石的最短路径。众所周知，树上最短路径可以用最近公共祖先来求。在这里我们可以以 $x$ 为根预处理树上每个结点 $i$ 的深度 $deep_i$，则结点 $i$ 和 $x$ 之间的最短路径就是从 $i$ 开始向上跳到根节点的路径。

接下来再考虑从 $x$ 出发拿到所有宝石的最短路径。通过分析题目，我们可以得出如下结论：

- **从 $x$ 出发拿到所有宝石的最短路径必然都是从 $x$ 到所有宝石的最短路径的子集。**

- **为保证从 $x$ 到所有宝石的最短路径最短，树上的任意一条边的经过次数都不应该超过 $2$。**

于是我们就可以用从 $x$ 到每个宝石的最短路径的并集构造出一棵树，这棵树的边集就是从 $x$ 出发拿到所有宝石的最短路径。由于拿到所有宝石还要再回到出发点，所以最短路径的权值还要乘上 $2$。

**注意：宝石的数量可能为 $0$，此时直接输出 $0$ 即可。**

## 代码

```cpp
#include<bits/stdc++.h> 
using namespace std;
int n,x,i,s,e,h,c,d[105],f[105],b[105];//c为计数器，d存储某结点的深度，f存储某结点的父节点 
vector<int>v[105];
queue<int>q;
void dfs(int x,int y){
	d[x]=y;
	b[x]=1;
	for(int i=0;i<v[x].size();i++){
		if(!b[v[x][i]]){
			f[v[x][i]]=x;
			dfs(v[x][i],y+1);
		}
	}
}
void lca(int x,int y){
	if(d[x]<d[y])swap(x,y);
	while(d[x]>d[y]){
		x=f[x];//注意和倍增有所区别，是一步一步往上跳
		b[x]=2;
	}
}
int main(){
	ios::sync_with_stdio(false);
    	cin>>n>>x;
    	for(i=1;i<=n;i++){
    		cin>>h;
    		if(h)q.push(i);//用队列存储有宝石的结点 
	}
	if(q.empty())return puts("0"),0;//当宝石数量为0时，直接输出0 
	for(i=n;--i;){
		cin>>s>>e;
		v[s].push_back(e);
		v[e].push_back(s);
	}
	dfs(x,1);
	memset(b,0,sizeof(b));
	while(!q.empty()){
		b[x]=b[q.front()]=2;//两端点也要并入点集 
		lca(x,q.front());
		q.pop();
	}
	for(i=1;i<=n;i++)c+=b[i];
	cout<<c-2<<endl;//岛国题目要换行，否则会WA
	/*
	树上边数=树上点数-1
	答案=树上边数*2
	*/ 
}
```