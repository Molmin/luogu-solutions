模拟赛做的一道题，跟这个差不多，正好给那道题写了个题解，顺便也放到这里了。

初始思路便是用 f[i] 表示以 i 为结尾的正好满足 B 要求的方案数，但是奈何没想明白怎么去转移。

先定义几个数组。

f 数组表示i-k+1到i全部为 B 的且之前未满足该条件的方案数，g[i]表示 i 到 i+k-1 全部为W 且之后未满足该条件的方案数。

t1 数组为第 i 天及以前满足 B 要求的方案数，t2 数组表示第 i 天及以后满足 W 要求的方案数。

po 数组在第一次循环中为 1 到 i 所有可能的方案数，第二次循环表示从 i 到 n 所有可能的方案数。

sum 数组在第一次循环中是 f 数组的前缀和，第二次循环中是 g 数组的后缀和。

为了保证 f 数组中不会出现重复的情况，我们求 f 数组的式子为


```cpp
f[i]=po[i-k]-t1[i-k]-(sum[i-1]-sum[i-k]+p);
```

稍微推一下吧。g 数组的求法类似。

很明显答案为所有 f[i] x t2[i+1] 的总和。

在计算过程中需要非常小心取模。

还有就是在计算所有可行方案数的时候判断，如果这一位没有定义，那么需要乘以二。

大概就是这里。

```cpp
if(c[i]=='X') po[i]=(po[i-1]*2)%p;
else po[i]=po[i-1];
if(c[i]=='X') t1[i]=(t1[i-1]*2+f[i])%p;
else t1[i]=(t1[i-1]+f[i])%p;
```
第一个循环和第二个循环大致思想相同，只是一波逆操作。

代码看起来就是这个样子，判断这一位的字母是什么，再进行操作。

```cpp
	int n=read(),k=read();
	scanf("%s",c+1);
	po[0]=1;
	int s=0; 
	for(int i=1;i<=n;i++){
		if(c[i]=='W') s=0;
		else s++;
		if(s>=k){
			f[i]=((po[i-k]-t1[i-k]+p)%p-(sum[i-1]-sum[i-k]+p)%p+p)%p;
		}
		if(c[i]=='X') po[i]=(po[i-1]*2)%p;
		else po[i]=po[i-1];
		if(c[i]=='X') t1[i]=(t1[i-1]*2+f[i])%p;
		else t1[i]=(t1[i-1]+f[i])%p;
		sum[i]=(sum[i-1]+f[i])%p;
	}
	po[n+1]=1;s=0;
	for(int i=n;i>=1;i--){
		if(c[i]=='B') s=0;
		else s++;
		if(s>=k){
			g[i]=((po[i+k]-t2[i+k]+p)%p-(sum[i+1]-sum[i+k]+p)%p+p)%p;
		}
		if(c[i]=='X') po[i]=(po[i+1]*2)%p;
		else po[i]=po[i+1];
		if(c[i]=='X') t2[i]=(t2[i+1]*2+g[i])%p;
		else t2[i]=(t2[i+1]+g[i])%p;
		sum[i]=(sum[i+1]+g[i])%p;
	}
	ll ans=0;
	for(int i=1;i<=n;i++){
		ans=(ans+f[i]*t2[i+1])%p;
	}
	cout<<ans;
```