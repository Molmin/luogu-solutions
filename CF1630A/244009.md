需要对位运算有一定理解。

注意到 $n$ 一定是 $2$ 的幂，因此 $n-1$ 在二进制下形式如 $111\cdots1$，于是有结论：对于 $a\in[0,n)$，与其“对称”的数 $n-1-a$，有 $a\operatorname{and}\ (n-1-a)=0$。

考虑一种构造思路：先把所有数与其“对称”的数配对（两者按位与的结果为 $0$，不会对结果产生影响），再构造出一对按位与结果为 $k$ 的数对。

发现按位与运算的单位元为 $n-1$，想到把 $k$ 和 $n-1$ 配对。同时，由于原本与两者配对的为 $n-1-k$ 和 $0$，有 $(n-1-k)\operatorname{and}0=0$，故把剩下的两者配对也不会对结果产生影响。

可是这种构造方法有缺陷，若 $k=n-1$，按上述构造方法，会把 $n-1$ 与自己配对，显然不合法。于是考虑另一种构造方法：先把所有数与其“对称”的数配对，再构造出两对按位与结果和为 $k$ 的数对，最简单的情况便是让两对数对按位与的结果为 $n-2$ 和 $1$。

可以把 $n-2$ 和单位元 $n-1$ 配对，原本配对的数 $1$ 和 $0$ 配对后不对结果产生影响，如此可以使结果变为 $n-2$。于是只需再构造一对按位与结果为 $1$ 的数对即可，注意到 $n-3$ 在二进制下形式如 $111\cdots101$，与 $3$ 配对后会使结果增加 $1$，而与两者“对称”的数 $2$ 和 $n-4$ 配对后也不对结果产生影响。如此即可使最终结果为 $n-1$。

注意到上述构造方法也有限制，即 $n-4>3$（否则会导致配对冲突的情况出现），所以有前提条件 $n>7$。换而言之，当且仅当 $n\leqslant7$ 时 $k=n-1$，会出现无解的情况，否则用上述方法便可构造出解。

到此，得出了此题的思路。

```
#include <iostream>
#include <cstdio>
using namespace std;
typedef long long ll;
ll t,n,k;
int main()
{
	scanf("%lld",&t);
	while(t--)
	{
		scanf("%lld%lld",&n,&k);
		if(k==n-1)
		{
			if(n<=7) puts("-1");
			else
			{
				puts("0 1");
				printf("%lld %lld\n",n-1,n-2);//(n-1) and (n-2)=n-2
				printf("%lld 3\n",n-3);//(n-3) and 3=1
				printf("%lld 2\n",n-4);
				for(ll i=4;i<(n>>1);++i) printf("%lld %lld\n",i,n-i-1);//把剩余数与“对称”的数配对 
			}
		}
		else if(!k)//k=0时直接把所有数与“对称”的数配对
		{
			for(ll i=0;i<(n>>1);++i) printf("%lld %lld\n",i,n-i-1);
		}
		else
		{
			printf("%lld %lld\n",k,n-1);
			printf("%lld 0\n",n-k-1);
			for(ll i=1;i<(n>>1);++i)
			{
				if(i==k||i==n-k-1) continue;//避免重复配对
				printf("%lld %lld\n",i,n-i-1);
			}
		}
	}
	return 0;
}
```