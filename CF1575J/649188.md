
------------

## 题意


一开始所有小球从第一行第 $c_i$ 列落下。

位置 $(x,y)$ 里面包含一个整数 $a_{x,y}$，表示在该坐标下的小球将要到达的位置。

具体要求：

$1$：如果 $a_{x,y} = 1$，这个小球向右移动一位。

$2$：如果 $a_{x,y} = 1$，这个小球向下移动一位。

$3$：如果 $a_{x,y} = 1$，这个小球向左移动一位。

特殊：如果经过了 $(x,y)$，则 $a_{x,y}$ 变为 $2$。

求出 $k$ 个小球最后会落在哪一列。

------------

## 思路：

分析题意可得，$a_{x,y}$ 控制着小球的移动方向，但是所有经过的位置上的整数都会变成 $2$，因此我们需要修改再维护。至于时间复杂度的话，数据范围很小，所以搜索是可以通过。
可以一个一个遍历，因为他是一个一个
地扔下去的所以可以打个循环，输入之后遍历一遍，然后再遍历下一个。



------------

```cpp
for(int i=1;i<=k;i++)
{
	int u;
	cin>>u;
	dfs(1,u);//遍历每个小球
}
```


------------

## $ACcode$

```
#include<bits/stdc++.h>
using namespace std;
int n,m,k,a[1009][1009];
void dfs(int x,int y)
{
	if(x==n+1||y==m+1)	
	{
		cout<<y<<" ";//输出答案
		return ;
	}
	if(a[x][y]==1)
	{
		a[x][y]=2;//走过的变2
		dfs(x,y+1);//向右走
	}
	else if(a[x][y]==2)
	{
		a[x][y]=2;
		dfs(x+1,y);//下
	}
	else if(a[x][y]==3)
	{
		a[x][y]=2;
		dfs(x,y-1);//左
	}
}
int main()
{
	
	cin>>n>>m>>k;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
	{
		cin>>a[i][j];//输入（绝不是手懒不打scanf
	}
	for(int i=1;i<=k;i++)
	{
		int u;
		cin>>u;
		dfs(1,u);//遍历每个小球
	}
	
	return 0;
}
```

