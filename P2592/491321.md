对于这种求方案数的题目，我们很容易想到递推或动态规划。很显然，这题应该用动规来实现。

------------

我们先来定义一下状态，即 $f$ 数组表示什么：

首先，男孩和女孩各需要一维，共两维；其次，我们发现对于若干个人，要么男生比女生多，要么男生比女生多，所以再加上两维，一共四维。
 
于是我们可以用 $f[i][j][x][y]$ 表示前 $i$ 个男孩 和前 $j$ 个女孩，任意连续的若干个人，要么男孩最多比女孩多 $x$ 人，要么女孩最多比男孩多 $y$ 人时有几种方法。
 
------------
 
再看看状态转移方程：

在增加了一个女孩后，$x$ 肯定会减一，$y$ 肯定会加一，所以状态转移方程如下：

```
f[i][j+1][max(x-1,0)][y+1]=(f[i][j][x][y]+f[i][j+1][max(x-1,0)][y+1])%mod;
```
这里用 $\max$ 是为了防止越界。还有，记得求模。

同理可得增加了一个男孩后的方程：

```cpp
f[i+1][j][x+1][max(y-1,0)]=(f[i][j][x][y]+f[i+1][j][x+1][max(y-1,0)])%mod;
```

------------

最后还有一步，不要漏掉：

可以发现，只要男女数目相差小于等于 $k$ 就是一种可行的方案，所以我们需要统计每一种可能。

```cpp
for(int i=0;i<=k;++i)//男生比女生多
   for(int j=0;j<=k;++j)//女生比男生多
      ans=(f[n][m][i][j]+ans)%mod;
```


------------
AC 代码：

```cpp
#include<bits/stdc++.h>
#define mod 12345678
using namespace std;
int n,m,k,f[155][155][25][25];
long long ans;
int main(){
    cin>>n>>m>>k;
    f[0][0][0][0]=1;
    for(int i=0;i<=n;++i)
        for(int j=0;j<=m;++j)
            for(int x=0;x<=k;++x)
                for(int y=0;y<=k;++y){
                    if(f[i][j][m][n]){
                        f[i][j+1][max(x-1,0)][y+1]=(f[i][j][x][y]+f[i][j+1][max(x-1,0)][y+1])%mod;
                        f[i+1][j][m+1][max(n-1,0)]=(f[i][j][m][n]+f[i+1][j][m+1][max(n-1,0)])%mod;
                    }
                }
    for(int i=0;i<=k;++i)
        for(int j=0;j<=k;++j) ans=(f[n][m][i][j]+ans)%mod;
    cout<<ans<<endl;
    return 0;
}
```