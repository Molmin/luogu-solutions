## 分析

　　这个题想都不用想一看就是DP，但这道题的状态不是很好确定，状态怎么找呢，可以确定的是，男孩和女孩的人数一定占两个状态，因为这个是可以确定他们的方案数的，剩下的我想维护男生与女生之间的差值，但这样显然是会出问题的，假如差值为2，那么有可能男生比女生多2，有可能女生比男生多2，这是两个方案，而这么定义状态的话就会出现少算方案数的情况，所以我们必须要维护男生比女生多的人数，女生比男生多的人数，这样状态就有了，定义$dp[a][b][c][d]$为共有$a$个女孩，$b$个男孩，男孩比女孩多$c$，女孩比男孩多$d$，那么每放一个人，就有两种可能，男生或女生，转移两次即可。是不是挺玄学的。。。
  
  ```
#include<iostream>
#define g dp[i][j][c][d]
#define mod 12345678
using namespace std;
int dp[160][160][25][25];
int main(){
    int n,m,k;
    cin>>n>>m>>k;
    dp[0][0][0][0]=1;
    for(int i=0;i<=m;i++)
    for(int j=0;j<=n;j++)
    for(int c=0;c<=k;c++)
    for(int d=0;d<=k;d++){
        dp[i][j+1][c+1][max(d-1,0)]=(dp[i][j+1][c+1][max(d-1,0)]+g)%mod;
        dp[i+1][j][max(c-1,0)][d+1]=(dp[i+1][j][max(c-1,0)][d+1]+g)%mod;
    }
    int ans=0;
    for(int i=0;i<=k;i++)
        for(int j=0;j<=k;j++)
            ans=(ans+dp[m][n][i][j])%mod;
    cout<<ans<<endl;
}
  ```