2022.7.30upd: 修改了一个小错误。

# 深浅值藏的第六分块

**注：本题解如无特殊说明均默认 $n,m$ 同阶**
# 前置知识
-  线段树、分块

来做这题的人应该都会了吧。
- 不带修 / 单点修改区间最大子段和

这是个经典问题，不会的可以看一看 [SP1043 GSS1](https://www.luogu.com.cn/problem/SP1043) 或者 [P4513 小白逛公园](https://www.luogu.com.cn/problem/P4513)。
- 线段树维护分段函数

这个其实挺难的我待会稍微讲一讲。
- 基数排序

Version5 是区间加正数所以用不着，但是这题是 Version6，也就是区间加任意数，所以需要用到基数排序。

# 弱化版
先考虑全局加区间最大子段和，即 [P5073 [Ynoi2015] 世上最幸福的女孩](https://www.luogu.com.cn/problem/P5073)。

还记得不带修 / 单点修改区间最大子段和怎么做吗？

定义：

- $sum_i$ 为节点 $i$ 内部的和。
- $L_i$ 为 $i$ 节点内部的最大前缀和。
- $R_i$ 为 $i$ 节点内部的最大后缀和。
- $ans_i$ 为 $i$ 节点内部的最大子段和。

那么显然有：

- $sum_i=sum_{lson}+sum_{rson}$
- $L_i=\max(L_{lson},sum_{lson}+L_{lson})$
- $R_i=\max(R_{rson},sum_{rson}+R_{lson})$
- $ans_i=\max(ans_{lson},ans_{rson},R_{lson}+L_{rson})$

那么这里我们维护的是后三者的分段函数，令：

- $L(x)$
- $R(x)$
- $ans(x)$

分别为该节点整体加了 $x$ 后的最大前缀和，最大后缀和，最大子段和。它们的合并方式同上。

这里的分段函数是几段一次函数。在线段树上的每一个节点我们维护每一段的断点和一次函数参数。因为一次函数的段数是不同且与线段树节点所代表的区间长度有关，所以要基于 vector 实现。易证线段树节点所代表区间长度的总和为 $n\log n$ ，所以空间复杂度是 $O(n\log n)$。

修改的时候打一个全局的 lazytag ，查询的时候加上去即可。

查询的时候我们找到覆盖的 $\log$ 个节点，在每个节点内部二分查找断点，总时间复杂度 $O(n\log^2n)$ ，无法通过本题。

然后我们注意到，这题没有强制在线。

所以我们把操作离线下来，基数排序后转换为全局加正数。

在每一个节点内我们设置一个指针记录上次出现的一次函数段，初始指向最小段。这样每次查找时指针从上次的位置往右查，均摊之后时间复杂度为 $O(n\log n)$。

# 正片开始
上述算法不能支持区间加是因为 pushup 的时间复杂度是 $O(n)$，那么初始化时间复杂度为 $O(n\log n)$ ，但是如果单点 / 区间修改的话，单次操作时间复杂度将达到 $O(n+\frac{n}{2}+\frac{n}{4}+···+1)=O(n)$，显然是过不去的。

**那么我们想想，什么数据结构是不用 pushup 的呢？**

分块。

将序列分块，对于每个块我们都开一棵上面所讲的线段树。设块长为 $m$，那么：

- 整块查询

在线段树根节点上二分查找断点，时间复杂度 $O(\log m)$。

- 零散块查询

在线段树上所覆盖的 $\log m$ 个节点上二分查找断点，时间复杂度 $O(\log^2 m)$。

- 整块修改

对于线段树来说就是全局加，$O(1)$ 打懒惰标记即可。

- 零散块修改

重构，时间复杂度 $O(m\log m)$。

$m$ 取 $\sqrt{n}$ 最优，总时间复杂度 $O(n\sqrt{n}\log n)$。

# 优化
零散块修改的时候真的有必要把线段树整个重构吗？

还记得我们之前说的吗？这个线段树区间修改的时间复杂度是 $O(n)$ 的。

所以零散块我们直接区间修改即可，注意线段树上的懒惰标记别和分块的搞混。

这样零散块修改的时间复杂度成功优化到了 $O(m)$。

还有一个基本操作就是离线然后逐块处理，顺便把空间优化到 $O(n)$，不然这题 64MB 别想过了。

对于每个块都进行基数排序，这样可以把整块查询优化到 $O(1)$，零散块查询优化到 $O(\log n)$，不过零散块查询并不是复杂度瓶颈，所以你哪怕写个 $O(m)$ 的大暴力都不会对总时间复杂度有影响。

这里有个细节就是因为有零散块修改的存在所以不能直接基数排序，但是我们仔细一想，即使在零散块修改时把查询的指针移到最左段也没有关系，因为把指针移到最左端其实均摊一下相当于增加 $O(\sqrt{n})$ 的时间复杂度，但是每次修改时最多也只有 $2$ 个零散块。所以这部分的时间复杂度也是 $O(n\sqrt{n})$ 的。

取 $m=\sqrt{n}$，总时间复杂度为 $O(n\sqrt{n})$。

然后就做完了。