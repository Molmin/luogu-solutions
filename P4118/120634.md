## 参考文献

[世界上最幸福的女孩](https://www.luogu.com.cn/problem/P5073)和这道题------[shadowice1984](https://www.luogu.com.cn/user/56384)大佬的两篇题解

还有一个不记得在哪了，是lxl在某个地方发的改版前的题解

## 写在前面

我们知道“单点修区间最大子段和”用线段树维护四个值：区间和、最大前缀和、最大后缀和、最大子段和，下面分别用 $s/ls/rs/mx$ 表示

这题以前的版本是只加正数，官方解法是先分成 $\sqrt n$ 个块

然后对每个块建一颗凸包线段树，维护 $ls/rs/mx$ 的凸包 (上凸壳)（和[$P5073$](https://www.luogu.com.cn/problem/P5073)类似）

凸包的事我想[shadowice1984](https://www.luogu.com.cn/user/56384)大佬的题解很清晰，这里声明：必须要搞清楚他是怎么$O(N)$合并两个子凸包的

对于覆盖了整棵树的修改，由于加上的是正数，所以指针看情况往后拉就行，复杂度均摊$O(1)$

重点是部分修改，全部重造线段树会让你的代码T掉

这里要搞懂线段树构建的本质，这里以长方形类比，每层长$\sqrt N$，宽$log\sqrt N$

凸包从底层建起，合并信息是$O(\sqrt N)$的，这里的$\sqrt N$为整棵线段树的服务长度即块长

lxl给出的解决方案和第二篇题解一样，是按照线段树基本操作，将操作下传到 $log$ 个子节点

![](https://cdn.luogu.com.cn/upload/image_hosting/5crfaatu.png)

如图，红色部分为修改的区间，同时引起绿色部分的改变，红色部分打上标记日后处理底下的，黑色部分就不用动了

结合$O(\sqrt N)$合并子凸包的操作，我们这次修改的复杂度就是红绿色的长度和

复杂度$/$规模就是$O(k\sqrt N)$------$k$为一巨大常数

搞定了修改操作，询问就变得不堪一击，但值得一提的事，修改操作特别是对懒标记的处理十分繁琐

由于技艺不精，我的常数巨大，T到飞起，先后多次尝试此题，花费大量精力修改代码，均以失败告终

现在给出一个个人觉得方便的处理方法：

线段树只记一个 $c$，表示这一层所有点要加 $c$

下到目标节点时：
```cpp
if(l<=tr[now].l&&tr[now].r<=r){tr[now].c+=k;return ;}
```
懒标记下放时也只传个 $c$ 下去

然后上面节点引用下面的点集时
```cpp
struct point{ll x,y;point operator+(ll const&AK47)const{return point{x,y+AK47*x};}};
point jia(point a,point b){return (point){a.x+b.x,a.y+b.y};}

P=jia(A,B+tr[lc].c);
```
这样设置比较方便，但要注意运算顺序

## 正片（很短）

现在难度加大了，可以加负数了。。。唯一不变的还是两个字：分块

但有的东西你想不到就真的想不到了。。。

分块做区间加区间和做过吗？

是不是每个操作都是从左往右，小段----大段----小段，这样？

你试过按块处理问题吗？

就是对第一块扫描$n$个问题，然后再去下一个块

这里就有一个重要的思想，前提是数据可以合并，势能可以均摊(这里很抱歉用了势能，可能不太严谨)

我们知道小段共有 $n$ 个，单次操作复杂度$O(\sqrt n)$

又有大段 $n\sqrt n$ 个，单次操作复杂度$O(1)$

均摊下来每个块的复杂度是$O(n)$的，刚好有$\sqrt n$个块

所以——你懂得，这玩意用在这里真的真的真的，女少口阿

![](https://cdn.luogu.com.cn/upload/image_hosting/elzw5ge4.png)

如图，黑色为块的分界，绿色为询问，红色为修改，下面一段字的 $n$ 和 $m$ 表示规模

我们知道，有 $m$ 条红色，就可以通过分块变成 $m$ 条小块的红色，和$m\sqrt n$条整段的红色

又有 $m$ 条绿色，就可以通过分块变成 $m$ 条小块的绿色，和$m\sqrt n$条整段的绿色

其中绿色中的小块我们可以暴力解决

那么对于任意一个块中，就会出现如下情况

![](https://cdn.luogu.com.cn/upload/image_hosting/qsp9abtl.png)

不妨设为最坏情况，有最多$m$条绿色大段和最多$m$条红色大段 交错 在一个块里

那红色小段？。。。

大段的总量是红色小段总量的$\sqrt n$倍，即红色小段是极为稀疏的

然后只要把这玩意一圈

![](https://cdn.luogu.com.cn/upload/image_hosting/6ntjmiiv.png)

天哪这不就是P5073！！？

不说了。。。你们加油 $\color{white}\text{别问为什么没代码，问就是qwq}$

## 写在后面（雾

去年我看到这题就开始在机房没日没夜的尝试，尝试了好多个3天，都快憋出病了。。。如今终于敲出来了，但是细节超多，RE半天发现自己忘memset，max函数没开long long……

个人感受：lxl的一些题最妙的地方在于“总量一定”，从而达到均摊的复杂度

最后的最后，祝珂朵莉继续幸福下去。

还有，管他什么题总之lxl毒瘤数据结构天下第一！！