注意到原操作等价于把数列划分为若干段，每段的最小值组成一个新数列，求可以得到的不同的新数列的个数，显然可以动态规划。由于不同的操作序列得到相同的新数列算作一种答案，我们要想一种办法只保留一些合法的操作序列，使得每一种新数列与每一种操作一一对应，以达到不重不漏的目的。

将原序列相邻的同颜色段合并考虑，由于 $0$ 和 $1$ 取 $\operatorname{max}$ 之后就没有了，于是中间隔了 $0$ 的全 $1$ 段可以合并，我们考虑一个贪心，先去除原序列开头结尾的全 $0$ 段：这样之后显然操作后的序列前后都是 $1$，则开头结尾的全 $0$ 段对答案的贡献就是乘上其长度加 $1$。

对于每一个操作后的数列，我们尝试找到原数列最短的一个前缀来通过操作得到它，那么由极小性，显然是满足不重不漏一一对应的，思考这个贪心过程是怎么样的：对于后数列中新加入的一段连续的 $0$，我们找到原数列最靠前的长度大于其的连续的全 $0$ 段来匹配其，然后删掉从开头到这一段的结尾；对于后数列中新加入的一段连续的 $1$，我们从原数列开头开始，往后统计 $1$ 的数量，直到足够为止，然后删除。$01$ 交替地贪心，就可以得到一个极小前缀，我们称这个前缀“刚好”能够得到后数列。

考虑一个 $dp$，$f_i$ 表示“刚好”能由 $1$ 到 $i$ 得到的数列的个数，考虑在这些数列后面加上一个 $0$ 或 $1$。如果当前是 $0$，那么如果要添加 $1$，只需要跳到后面最近的 $1$ 处，如果要添加 $0$，如果下一个数还是 $0$ 那么就直接转移到下一个数，否则找到最近的一段比当前段 $0$ 长的全 $0$ 段，将本段中的 $0$ 全部搬到下一段，然后再往后跳一位；如果当前是 $1$，那么下一个 $0$ 或者下一个 $1$ 都只要找到后面最近的 $0$ 或 $1$ 转移即可。预处理出原序列每一位跳到下一个 $0$ 和 $1$ 的位置，然后 $O(n)\ dp$ 即可。

代码如下：

```cpp
#include <bits/stdc++.h>
using namespace std;
const int M = 1010000, P = 1e9 + 7;
int n, a[M], b[M], f[M], nxt[M], bl[M];
int t1[M], t0[M], stk[M], tmp[M];
bool c[M], v[M];
char s[M];
int main() {
    scanf(" %s", s), n = strlen(s);
    for (int i = 0; i < n; i++) v[i] = s[i] == '1';
    for (int i = 0; i < n; i++) {
        if (!i || s[i] != s[i - 1]) a[++a[0]]++, c[a[0]] = s[i] == '1', b[a[0]] = i;
        else a[a[0]]++;
        bl[i] = a[0];
    }
    if (a[0] == 1) return !printf("%d\n", a[1]);
    b[a[0] + 1] = n + 1;
    for (int i = a[0]; i > 0; i--) {
        if (c[i]) continue;
        while (stk[0] && a[stk[stk[0]]] <= a[i]) stk[0]--;
        if (!stk[0]) tmp[i] = -1;
        else tmp[i] = b[stk[stk[0]]];
        stk[++stk[0]] = i;
    }
    for (int i = 0; i < n; i++)
        if (v[i])
            t1[i] = (i < n - 1 && v[i] == v[i + 1]) ? i + 1 : (bl[i] + 2 <= a[0] ? b[bl[i] + 2] : -1),
            t0[i] = bl[i] + 1 <= a[0] ? b[bl[i] + 1] : -1;
        else
            t0[i] = (i < n - 1 && v[i] == v[i + 1]) ? i + 1 : (tmp[bl[i]] == -1 ? -1 : tmp[bl[i]] + a[bl[i]]),
            t1[i] = bl[i] + 1 <= a[0] ? b[bl[i] + 1] : -1;
    int st = c[1] ? b[1] : b[2], vp = !c[1] ? a[1] + 1 : 1;
    f[st] = 1;
    for (int i = st; i < n; i++) {
        if (t0[i] != -1) f[t0[i]] = (f[t0[i]] + f[i]) % P;
        if (t1[i] != -1) f[t1[i]] = (f[t1[i]] + f[i]) % P;
    }
    int ans = 0, vg = !c[a[0]] ? a[a[0]] + 1 : 1;
    for (int i = 0; i < n; i++)
        if (v[i]) ans = (ans + f[i]) % P;
    printf("%lld\n", 1ll * ans * vg % P * vp % P);
    return 0;
}
```
