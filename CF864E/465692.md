# 0x00 思路
先看题。

>某人的房子着火了,他想从大火中带走**价值总和**尽量多的物品,每次他**只能带走一个**,分别给出挽救某物品需要的时间 $t$ ,该物品开始燃烧的时间 $d$ (在 $d$ 时间**开始燃烧就不能再挽救该物品了**),该物品的价值 $p$。

由于每个物品只有一个，且只有 $2$ 种可能，带走或不带走（~~带不走就先不考虑了~~），所以这就是 01 背包。但是有一点变形的是：第 $i$ 个物品在救援时只能在前 $d_i$ 秒进行救援。因此，为了满足 dp 无后效性的要求，我们决定：给它们排序,接着就是 01 背包输出序列的模板题了~~吗~~。

# 0x01 排序
由于~~我们坚信~~，越早烧起来的就越有价值，于是我们按照它们的燃烧时间排序，就做到了只会出现 $2$ 种选择，选或不选，而且之后不能反悔（无后效性）。

# 0x02 定义状态
```d[i]```：在前 $i$ 秒内最多能带走的物品价值总和。

# 0x03 状态转移方程
同 01 背包。因为你如果要带走第 $j$ 件物品，那么需要腾出 $t_j$ 秒来拯救 Ta，剩下的就只有 $i-t_j$ 秒来拯救了。

所以状态转移是这样的:
```c
d[j]=max(d[j-a[i].t]+a[i].p,d[j]);
```

# 0x04 输出序列
这件事是不用多说的，因为相信大家都做过这种类型的题。用 pre 数组存储我救的物品,则 ```pre[i][j]``` 表示在第 $j$ 秒时我是否选择救第 $i$ 个物品。如果我选择了这个物品在此时救，那么就把值置为 $1$ （原来值为 $0$），由于要价值最大，遍历整个 d 数组（从小到大），找到最大值，从这个位置开始遍历，若值为 $1$ 则遍历上一行，否则继续遍历，若未遍历到 $1$ 同样也遍历上一行。

# 0x05 code
```c
#include<bits/stdc++.h>
using namespace std;
struct f
{
	int t,d,p,i;
}a[105];
bool cmp(f b,f c)
{
	return b.d<c.d;
}
int d[5005],p[105][5005],tot=0,n;
void print(int i,int j)
{
	if(i<=0)
	{
		printf("%d\n",tot);
		return;
	}
	if(p[i][j])
	{
		tot++;
		if(j>=a[i].t)
			print(i-1,j-a[i].t);
		printf("%d ",a[i].i);
	}
	else
		print(i-1,j);
}
int main()
{
	int m,i,j,ans=0,x=0;
	scanf("%d",&n);
	for(i=1;i<=n;i++)
		scanf("%d %d %d",&a[i].t,&a[i].d,&a[i].p),a[i].i=i;
	sort(a+1,a+1+n,cmp);
	for(i=1;i<=n;i++)
	{
		for(j=a[i].d-1;j>=a[i].t;j--)
		{
			if(d[j]<d[j-a[i].t]+a[i].p)
			{
				d[j]=d[j-a[i].t]+a[i].p;
				p[i][j]=1;
			}
			ans=max(ans,d[j]);
		}
	}
	printf("%d\n",ans);
	for(i=0;i<=a[n].d;i++)
		if(d[i]>d[x])
			x=i;
	print(n,x);
	return 0;
}
```