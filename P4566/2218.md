Upd：感谢@Zhang_RQ提供的Hack题解，果然还是太弱了我推式子又出锅了

[蕈](https://hanyu.baidu.com/zici/s?wd=%E8%95%88&query=%E8%95%88&srcid=28232&from=kg0&from=kg0)xùn不谢。
### **分析**
吹爆这道神仙题。
#### **First：判断无解**
每个极大“连续”区间不可以相交，并且$L_n=n$

必要性：

因为每个连续区间内是连续的数字，有因为是排列所以数字不会重复，所以如果相交了的话肯定可以把后面的区间扩展到前面的那个区间，极大性就不满足了啊。
#### **Second：问题转化**
既然所有区间要么包含要么不相交，那么把每个点代表的区间和往右第一个包含它的区间连边，形成了一颗树形结构。

对于每个儿子所代表的一定是一段极大连续区间，而所有儿子加上当前节点也构成了一个极大连续区间，考虑把每个儿子缩成一个点再按大小编号，就构成了一个排列，探究这个排列的性质。
既然是"极大"的，那么一定不能有两个儿子的区间可以合并成一个新的连续区间。

所以对于每个节点，假设它一共有$sz$个儿子。那么等价第构造一个$sz+1$阶排列，**满足这个排列的$L$值为$1,1,1,\cdots, sz+1$，也就是除了最后一个节点，不存在任何一个大于1的连续子区间**。我们称这个排列为**合法排列**。

我们设这个值为$f$，那么答案就是$\prod f(sz_i)$

为了方便推导，下面的$f_i$表示的将长度为$i+1$的合法排列个数。

顺便说一句，这个$sz$用单调栈扫一遍即可。

#### **Second：计数Dp**
事实上，基于$f$本身的性质就可以得到递推式
$f_i=(i-1)f_{i-1}+\sum_{j=2}^{i-2}(j-1)f_jf_{i-j}$

考虑在$1\cdots i$的基础之上插入$i+1$
##### **Step1：$1 \cdots i$是一个合法的排列**
除了$i$的两边，都可以插，一共$i-1$个位置，方案数$(i-1)f_{i-1}$。
##### **Step2：$1 \cdots i$不是合法的排列**
$i+1$的插入“打破”了原有的一个连续子区间。

首先这个子区间只能有一个。

所以我们可以把这个子区间合并成一个节点，对这个排列重新标号之后，这个排列就是合法的了。

枚举这个子区间的长度$j$，合并之后有$i-j+1$个节点，方案数是$f_{i-j}$。其中$j\in[2,i-2]$

对于每个$j$，考虑有多少种合法的值域选取。

也就是对于合并完之后$1\cdots i-j+1$的排列再把它选一个点“拆开”。

首先值为$i-j+1$的那个区间肯定不能拆，因为拆完之后值域是$[i-j+1,i]$，包括$i$的话插入$i+1$仍然是一个连续子区间。

其次这个连续子区间不在排列末尾，所以最后一个值也不能选。

又由于最后一个值一定不会是$i+j-1$（否则去掉最后一个值就是一个连续子区间不合法了），所以不管哪种情况都妥妥挖掉两个点。

所以选取的总方案是$i-j+1-2=i-j-1$

到目前为止的方案是
$(i-j-1)f_{i-j}$

考虑什么样的$j$阶排列和$i+1$是满足条件的。我们发现，插入$i+1$需要打破之前这个$j$阶排列的所有连续子区间。也就是说，插入了$i+1$之后$1\cdots j$的之前的所有连续子区间都经过$i+1$。

那么一个很自然的思路就是将$i+1$看成$j+1$，那么方案**就是一个$j+1$的排列，满足所有连续子区间经过最大值**。

不会怎么办？

算了先打个表找找规律试试。

诶诶？这个表怎么有点眼熟。

等等它好像和我之前打的$f_i$的表长得一样？

那石锤了，就这样吧。

~~假装我真的推到了这一步，打过表~~

考场中如果打了这个表这题不是赚翻了。

这样的话递推式已经出来了啊。
把之前的方案乘上$f_j$

$f_i=(i-1)f_{i-1}+\sum_{j=2}^{i-2}(i-j-1)f_jf_{i-j}=(i-1)f_{i-1}+\sum_{j=2}^{i-2}(j-1)f_jf_{i-j}$

下面考虑证明一下这个性质。

##### **Step3：巧妙的置换**
证明的思路非常神仙。

考虑原排列的逆$b_{a_i}=i$

这个排列和原排列好像关系不大。但是我们关心的东西是连续子区间。

考虑原排列的一个连续区间，假设下标为$[i,j]$，值域为$[a_l,a_r]$。
考虑逆置换之后，下标为$[a_l,a_r]$，值域为$[i,j]$
所以说，**对于原排列的连续区间和新排列之中的一一对应**。

这个时候，我们考虑原来的合法排列长啥样了？

我们原来合法的排列的连续子区间全部都是这个排列的后缀子区间，也就是说，它们都经过最后一个点。

而最后一个点被怼到哪里了我们不知道，但我们知道它的值是最大值。

所以抓这个最大值不放，**原来合法的排列在新排列中的连续子区间必定经过最大值**。

所以两者的方案是一一对应的。

事实上，如果最开始就想到了这个神仙性质，可以直接利用这个性质去推，会推出一样的式子。

但是如果正着推+打表辅助，会让这道题在神仙的同时增加一点点可做的成分，思路也变得自然很多（蒟蒻视角）。

#### **Third：Cdq分治+FFT**
剩下进入了套路时间。(蒟蒻表示仍然不会啊T-T)

$f_i=(i-1)f_{i-1}+\sum_{j=2}^{i-2}(j-1)f_jf_{i-j}$

理论上它就很$Cdq+FFT$啊。

$Cdq$是考虑$[L,mid]$去卷$[1,R-L]$，贡献给$[m+1,R]$

可是$[R-L]$没求不是凉凉吗，毕竟是我 卷 我 自 己啊。

一种思路是，每次仅仅盯住两部分的贡献$[L,m]$卷$[L,m]$

以及$[L,m]$卷$[1,min(L-1,R-L)]$，也就是$[L,m]$区间之前的部分。
这样的话会有一个问题，就是$[L,m]$卷不到$[L,m]$之后的部分。

考虑每次$[L,m]$卷之前的部分。$[1,min(L-1,R-L)]$这个区间内肯定没有卷到之后的部分，我们再卷$[L,m]$和$[1,min(L-1,R-L)]$的时候把“历史遗留问题”解决掉。

本来是得$[L,m]$和$[1,min(L-1,R-L)]$，$[1,min(L-1,R-L)]$和$[L,m]$分别卷积的。

但是注意到$(j-1)f_jf_{j-i}+(i-j-1)f_{j-i}f_j=(i-2)f_jf_{i-j}$
所以卷一次之后直接乘上$(i-2)$就好了。

复杂度$O(nlog^2+Tn)$
### **代码**
```cpp
#include<bits/stdc++.h>
const int N = 2e5 + 10, P = 998244353;
int ri() {
    char c = getchar(); int x = 0, f = 1; for(;c < '0' || c > '9'; c = getchar()) if(c == '-') f = -1;
    for(;c >= '0' && c <= '9'; c = getchar()) x = (x << 1) + (x << 3) - '0' + c; return x * f;
}
int R[N], w[N], f[N], q[N], a[N], b[N], l[N], L, InvL;
int mul(int a, int b) {return 1LL * a * b % P;}
int add(int a, int b) {return a += b, a >= P ? a - P : a;}
int fix(int x) {return (x >> 31 & P) + x;}
int Pow(int x, int k) {
    int r = 1;
    for(;k; x = mul(x, x), k >>= 1)
        if(k & 1)
            r = mul(r, x);
    return r;
}
void Pre(int m) {
    L = 1; int x = 0;
    for(;(L <<= 1) < m;) ++x;
    for(int i = 0;i < L; ++i)
        R[i] = R[i >> 1] >> 1 | (i & 1) << x;
    w[0] = 1; int wn = Pow(3, (P - 1) / L);
    for(int i = 1;i < L; ++i) 
        w[i] = mul(w[i - 1], wn);
    InvL = Pow(L, P - 2);
}
void DNT(int *F) {
    for(int i = 0;i < L; ++i)
        if(i < R[i])
            std::swap(F[i], F[R[i]]);
    for(int i = 1, d = L >> 1;i < L; i <<= 1, d >>= 1)
        for(int j = 0;j < L; j += i << 1) {
            int *l = F + j, *r = F + i + j, *p = w, tp;
            for(int k = i; k--; ++l, ++r, p += d)
                tp = mul(*r, *p), *r = fix(*l - tp), *l = add(*l, tp);
        }
}
void Mul(int *A, int *B, int n, int m) {
    Pre(n + m);
    for(int i = n;i < L; ++i) A[i] = 0;
    for(int i = m;i < L; ++i) B[i] = 0;
    DNT(A); DNT(B);
    for(int i = 0;i < L; ++i)
        B[i] = mul(A[i], B[i]);
    DNT(B);
    for(int i = 0;i < L; ++i)
        A[i] = mul(B[L - i & L - 1], InvL);
}
void Cdq(int L, int R) {
    if(L == R) {
        f[L] = add(f[L], mul(L - 1, f[L - 1]));
        return ;
    }
    int m = L + R >> 1;
    Cdq(L, m);
    for(int i = L; i <= m; ++i)
        a[i - L] = mul(f[i], i - 1), 
        b[i - L] = f[i];
    Mul(a, b, m - L + 1, m - L + 1);
    for(int i = std::max(L << 1, m + 1); i <= R; ++i)
        f[i] = add(f[i], a[i - (L << 1)]);
    if(L != 2) {
        int d = std::min(L - 1, R - L);
        for(int i = 2;i <= d; ++i)
            a[i - 2] = f[i];
        for(int i = L;i <= m; ++i)
            b[i - L] = f[i];
        Mul(a, b, d - 1, m - L + 1);
        for(int i = std::max(L + 2, m + 1); i <= R; ++i)
            f[i] = add(f[i], mul(a[i - L - 2], i - 2));
    }
    Cdq(m + 1, R);
}
int main() {
    int T = ri(), n = ri(); 
    f[0] = 1; f[1] = 2;
    if(n > 2) Cdq(2, n - 1);
    for(;T--;) {
        bool flag = true; int Ans = 1, top = 0;
        for(int i = 1;i <= n; ++i)
            l[i] = ri();
        if(l[n] != n || l[1] != 1) {puts("0"); continue;}
        for(int i = 1;i <= n; ++i) {
            int cnt = 0; flag = true;
            for(;top && i - l[i] + 1 <= q[top];) {
                if(i - l[i] + 1 > q[top] - l[q[top]] + 1) {
                    flag = false; break;
                }
                --top; ++cnt;
            }
            if(flag == false) break;
            Ans = mul(Ans, f[cnt]);
            q[++top] = i;
        }
        printf("%d\n", !flag ? 0 : Ans);
    }
    return 0;
}

```
