CF762C Two strings

注意看题！！！

删除连续的一段！！！

首先最最最暴力的一种做法：

枚举删除的区间 $[l,r]$，再用删后的字符去进行匹配，不断更新最优解。

时间复杂度 $\mathcal O(n^3)$。

~~复杂度原地螺旋起飞~~

两个优化方向：

- 优化区间 $[l,r]$ 的枚举；
- 优化字符的匹配过程。

~~一共也就这两过程，说了和没说一样~~

显然区间具有单调性，

如果删掉了区间 $[l,r]$ 之后的 $s$ 能够成为 $t$ 的子序列，

那么你把 $[l,r]$ 往外面扩，多删一点字符，依然满足 $s$ 是 $t$ 的子序列。

所以我们可以枚举左端点 $l$，同时二分右端点 $r$，

把时间复杂度优化到 $\mathcal O(n^2\log n)$。

~~然而复杂度依旧爆炸~~

我们现在的瓶颈在于如何快速判断删掉之后的 $s$ 是不是 $t$ 的子序列。

来还原一下暴力的过程：

用两个指针 $i,j$ 指向 $s$ 和 $t$ 的第一个位置，

如果 $s_i=t_j$ ，那么两者匹配，同时 $i \gets i+1,j \gets j+1$；

否则 $j \gets j+1$。

如果最后所有的 $s_i$ 都能够在 $t$ 中找到一个对应的位置，那么 $s$ 就是 $t$ 的子序列，

同样的，如果我们的指针从后面往后面扫，也能够达到同样的效果。

于是我们就想到了一个优化方法：

对于 $s$ 的每一个字符 $s_i$，维护一个 $lp_i$ 和 $rp_i$。

设 $s$ 的长度为 $len$，

那么 $lp_i$ 表示 $s$ 中 $[1,i]$ 的字符全部匹配到 $t$ 里，第 $i$ 个位置在 $t$ 中对应的位置，

同理，$rp_i$ 表示 $s$ 中 $[i,len]$ 的字符全部匹配到 $t$ 里，第 $i$ 个位置在 $t$ 中对应的位置。

其中 $lp$ 的匹配是从前到后匹配，$rp$ 的匹配时从后往前匹配。

那么，如果我们要删除一段区间 $[l,r]$，

那我们只需要判断 $lp_{l-1} < rp_{r+1}$ 是否成立即可。

时间复杂度优化为 $\mathcal O(n \log n)$。

以及一个特殊情况：$s$ 本身就是 $t$ 的子序列，此时不需要删去任何元素，需要特判一下。

