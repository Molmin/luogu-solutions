**P8264**题解。

~~因为是 ez round 所以写的巨详细，有点啰嗦也请见谅。~~

---------------------------------------------

考虑一种比较显然的做法，观察到绝对值符号可以根据数的相对关系拆开，那么拆开后就无非是加减运算，具有结合律可以直接维护。

枚举绝对值拆开是变正号还是负号，考虑分块，我们可以枚举每个位置的正负号情况来计算一个数的通过情况，设块长为 $B$，那么对于一个块总共只会有 $2 ^ B$ 种情况，并且我们发现每种合法情况对应初始值域上的一段数。

考虑直接枚举并不好计算。并且合法情况只有至多 $O(V)$ 种，考虑直接 dfs 所有合法状态，在当前状态维护对应的初始值域，此时走到了第几个数以及走过前面所有数后该段初始值域**投影的值域**，每次向后走时看需不需要分裂当前的初始值域即可，这部分代码实现如下：

```cpp
void dfs(int l,int r,int opt,int ad,int stp)
{
	if(stp == Siz) 
	{
		pr.first = opt , pr.second = ad;
		for(int i = l ; i <= r ; i ++) fr[i][now] = opt * i + ad;
		return;
	}
	int L = opt * l + ad , R = opt * r + ad;
	if(L > R) swap(L , R);
	if(a[stp + 1] <= L)//在原来基础上减去 a[stp + 1] 即可 
	{
		dfs(l , r , opt , ad - a[stp + 1] , stp + 1);
		return;
	}
	else if(R <= a[stp + 1])//在原来基础上整体反转 
	{
		dfs(l , r , -opt , a[stp + 1] - ad , stp + 1);
		return;
	}
	else//<= a_{stp + 1} 的和 > 的划开 
	{
		int mid = (a[stp + 1] - ad) * opt;
		if(opt == -1) 
		{
			dfs(l , mid + 1, opt , ad - a[stp + 1] , stp + 1);
			dfs(mid , r , -opt , a[stp + 1] - ad , stp + 1);
		}
		else
		{
			dfs(l , mid , -opt , a[stp + 1] - ad , stp + 1);
			dfs(mid + 1 , r , opt , ad - a[stp + 1] , stp + 1);
		}
		return;
	}
}
```

不难发现这个做法的预处理时间复杂度是 $O(2 ^ B \times \frac{n}{B})$，查询是 $O(q \times \frac{n}{B})$ 的，当 $B = \log n$ 时可以取到平衡复杂度 $O(\frac{(q + n)n}{\log n})$。

好像还有线段树的实现方法，不知道是怎么做到的（（（

这个做法可惜常数终究还是大了，个人不管怎么卡都只能卡到 91pts，所以我们得考虑更优秀的时间复杂度。

观察。一次分裂初始值域可以看作**让分裂中心两边中，数量更少的一边对称过去，因为对称过去的位置再之后操作时都是一起变化的所以可以看作一个整体**，注意这里一定要限制**数量更少的一边**，个人在实现时没想清楚在这个地方调了 2h，如果让数量多的一边对折可能会出现对折后的位置超过本身值域区间 $[l,r]$ 的情况，从而导致一些奇奇怪怪的错误。

通过并查集，我们让对折端的数向被对折端的数合并，举个例子：对于 $[1,6]$ 以 $3$ 为对称中心，$[1,2]$ 向 $[3,6]$ 对折，那么 $2$ 向 $4$ 合并，$1$ 向 $5$ 合并。

显然，每个数只会被至多合并一次，那么对一个块进行一次预处理操作时间复杂度就是 $O(V a(V))$ 的，维护好每个块的映射后剩下的就是整块暴力跳散块直接查。

时间复杂度 $O((q + V) \sqrt n)$，空间复杂度 $O(V \sqrt n)$，可以轻松通过本题。

不过个人也认为存在像最开始中直接对每个块合法情况维护的同时空复杂度做法，因为确实数量级就这点。

同时本题存在 polylog 做法，个人不会，摆，有空学一下。

upd 2022/3/31：学了亿下来口胡，大概是直接把分块当线段树用，对线段树上的每个节点当作一个块处理值域中每个数越过的情况。对每个节点出现过的数离散化后开平衡树，每一次模拟经过一个数时的加入情况（映射），貌似还得区间复制写可持久化的平衡树，感觉很复杂，但是确实可以做值域比较大的情况。