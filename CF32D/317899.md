[早上六点打的虚拟比赛，差点 AK ，就差一个 E 题。最后发现 E 题不论是 洛谷 还是 Codeforces 都没有题解，而看 CF 正确的源代码又看不懂，我太难了……](https://oi-master.github.io/post/codeforces-contest-32-d-ti-jie/)

好，不说别的了，我们先讲思路吧。
## 思路

$N$ 才 $300$ ？那就写个 $O(N^3)$ 算法。啪啪啪啪啪啪啪啪……咦？居然过
了？！

这道题的数据很小呢，所以发现这道题纯考你的手熟不熟，思维不难。
我们先枚举半径（ $r$ ，从小到大），然后枚举行（ $i$ ，从小到大），再枚举列（ $j$ ，还是从小到大），然后我们每次判断存不存在当中心点为 $(i, j)$，半径为 $r$ 的十字形星座。如果有，那么就把总数加上 $1$ 。如果总数到了 $K$，那么我们就打印。

如果最后啥也没打出来（也就是说，总数小于 $K$），那么就输出 $-1$。

如此简单，这上面就算是一种伪代码了（难道不是吗？
## 代码
给上 C++ 实现的代码
```cpp
/* Generated by powerful Codeforces Tool
 * Author: OI_Master
 * Time: 2020-03-31 07:20:10
**/
#include<bits/stdc++.h>
using namespace std;
#define int long long
signed main(){
    ios::sync_with_stdio(false);
    cin.tie(0);
    int n,m,k;
    cin>>n>>m>>k;
    char c[n+1][m+1];
    for(int i=1;i<=n;++i)
    	for(int j=1;j<=m;++j)
    		cin>>c[i][j];
    int num=0;
    for(int r=1;r<=min(n,m);++r)
    	for(int i=r+1;i+r<=n;++i)
    		for(int j=r+1;j+r<=m;++j)
    			if(c[i][j]=='*'&&c[i-r][j]=='*'&&c[i+r][j]=='*'&&c[i][j-r]=='*'&&c[i][j+r]=='*'){
    				if(num==k-1){
    					cout<<i<<' '<<j<<endl<<i-r<<' '<<j<<endl<<i+r<<' '<<j<<endl<<i<<' '<<j-r<<endl<<i<<' '<<j+r<<endl;
    					return 0;
    				}
    				else
    					++num;
    			}
    cout<<-1<<endl;
    return 0;
}
```
本文到此结束。