这题交了十几次（到现在还有点懵），来写份题解吧

###DP
##dp [ i ] [ j ] 表示第i位为j的最少次数，或者说前i个数最后一位为j的最少次数

枚举i，和第i-1位的j，再枚举i位的j(用k表示)

这里用a[i]表示读入的第i个数，方便起见，直接将每个数加上2

初始把整个dp数组赋为INF，把dp [ 1 ] [ a [ 1 ] ] 赋为 0

如果a[i]==k，那么dp [ i ] [ k ] = min ( dp [ i ] [ k ] , dp [ i - 1 ] [ j ] )

如果a[i] > k , 那么只有当j==-1时，dp [ i ] [ k ] 这个状态才可能存在 ， dp [ i ] [ k ] = min ( dp [ i ] [ k ] , dp [ i - 1 ] [ j ] + a [ i ] - k )

如果a[i] < k , 那么只有当j==1时，dp [ i ] [ k ] 这个状态才可能存在 ， dp [ i ] [ k ] = min ( dp [ i ] [ k ] , dp [ i - 1 ] [ j ] - a [ i ] + k )

最后对dp [ n ] [ 1~3 ] 取最大值即可

[丑陋的代码](http://blog.csdn.net/u013095699/article/details/78441238)
