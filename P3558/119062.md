很好的线性dp，有几个点：

- 无解要判

- 序列操作完只有 0,1,-1


---

设 $f_{i,j}$ 为 $1-i$ 中，填完操作完第 $i$ 位为 $j$ 时的最小步数

分类讨论：

- $a_i=-1$

$$f_{i,-1}=f_{i-1,-1}$$
$$f_{i,0}=\infty$$
$$f_{i,1}=f_{i-1,1}+2$$

填完为 $-1$，当前为了满足单调不降，答案只能是上一个。

填完为 $0$，当前绝对加了 $a_{i-1}=1$，而此时的序列必然不是单调不降的。

填完为 $1$，当前只能加两遍 $a_{i-1}=1$，操作花费 $2$。

为什么 $-1,1$ 的状态只能从前一个对应的转移过来，比如填完为 $1$ 的情况。

由于前一个填完为 $0$ 或 $-1$,答案为 $f_{i-1,0},f_{i-1,-1}$，我们当前要转移的是 $f_{i,1}$，但是我们发现虽然满足了单调不降，但是当
$a_i=-1,a_{i-1}=0 \ or -1$，当前操作多少步 $a_{i}+=a_{i-1}$ 都到不了 $1$，所以不能从别的状态转移。

- $a_i=0$

$$f_{i,-1}=f_{i-1,-1}+1$$
$$f_{i,0}=\min(f_{i-1,0},f_{i-1,1})$$
$$f_{i,1}=f_{i-1,1}+1$$

第一个和第三个类似第一种分类讨论里的转移。

第二个我们发现，此时的策略应该是不做任何操作(答案是求操作完为 $0$ 的最优答案，当前不动 $a_i$ 就是 $0$。)，为了满足单调不降，我们不能使用 $f_{i,1}$ 转移。

- $a_i=1$

$$f_{i,-1}=f_{i-1,-1}+2$$
$$f_{i,0}=f_{i-1,-1}+1$$
$$f_{i,1}=\min(f_{i-1,-1},f_{i-1,0},f_{i-1,1})$$

这些就和前两个分类讨论差不多。

---

程序部分由于 $C++$ 数组不能用负数，我们把 $f$ 第二维全部加 $1$ 即可。


```cpp

#include <iostream>
#include <cstdio>
#include <cstring>
using namespace std;
inline int read(){
	register int x=0,f=0,ch=getchar();
	while('0'>ch||ch>'9')f^=ch=='-',ch=getchar();
	while('0'<=ch&&ch<='9')x=(x<<1)+(x<<3)+(ch^'0'),ch=getchar();
	return f?-x:x;
}
const int MAX=1000010; 
int n,a[MAX],ans,f[MAX][3],INF=0x3f3f3f3f;
signed main(){
	n=read();
	for(register int i=1;i<=n;++i)a[i]=read();
	memset(f,INF,sizeof(f));
	f[1][a[1]+1]=0;
	for(register int i=2;i<=n;++i){
		if(a[i]==-1){
			f[i][0]=f[i-1][0];
			f[i][2]=f[i-1][2]+2;
		}else if(a[i]==0){
			f[i][0]=f[i-1][0]+1;
			f[i][1]=min(f[i-1][0],f[i-1][1]);
			f[i][2]=f[i-1][2]+1;
		}else {
			f[i][0]=f[i-1][0]+2;
			f[i][1]=f[i-1][0]+1;
			f[i][2]=min(f[i-1][0],min(f[i-1][1],f[i-1][2]));
		}
	}
	ans=min(f[n][0],min(f[n][1],f[n][2]));
	if(ans==INF)printf("BRAK\n");
	else printf("%d\n",ans);
	return 0;
}


```


