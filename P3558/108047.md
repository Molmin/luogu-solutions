注意题目，如果$k_1<k_2$，那么不存在先执行$a_{k_2}+=a_{k_2-1}$，再执行$a_{k_1}+=a_{k_1-1}$，所以我们只要从前往后枚举即可

因为序列只存在$-1,0,1$三种情况，同时序列又是呈单调性的，所以每一个$i$只要受到$i-1$的状态影响，即只要分$3\times 3=9$种类别讨论

不妨设：

$\large f_{i,j}:$ 前$i$个数满足单调不减，且第$i$个数变为$j-1$所需的最小操作数（由于数组不能存$-1$所以整体往右移一位）

初始状态即：$\large f_{1,a_1+1}=0$

$\LARGE 1.\;\;a_i=-1$

- $\large f_{i,0}:$因为要满足单调性，所以前一个数必须为$-1$，同时，$-1$变为$-1$也不需要再加上新的操作数，即$\large f_{i,0}=f_{i-1,0}$

- $\large f_{i,1}:$因为从$-1$变成了$0$，所以前一个数一定是$1$，但这就不满足单调性了，所以无法转移，即$\large f_{i,1}=INF$

- $\large f_{i,2}:$因为从$-1$变成了$1$，所以前一个数一定是$1$，而且从$-1$变成$1$要加两次$1$，即$\large f_{i,2}=f_{i-1,2)+2$

$\LARGE 1.\;\;a_i=0$

- $\large f_{i,0}:$因为从$0$变成了$-1$，所以前一个数一定是$-1$，而且从$0$变成了$-1$要加一次$-1$，即$\large f_{i,0}=f_{i-1,0}+1$

- $\large f_{i,1}:$因为要满足单调性，所以前一个数只能为$-1$或$0$，同时，$0$变为$0$也不需要再加上新的操作数，即$\large f_{i,1}=\min (f_{i-1,0},f_{i-1,1})$

- $\large f_{i,2}:$因为从$0$变为了$1$，所以前一个数必为$1$，而且从$0$变为$1$要加一次$1$，即$\large f_{i,2}=f_{i-1,2}+1$

$\LARGE 1.\;\;a_i=1$

- $\large f_{i,0}:$因为从$1$变成了$-1$，所以前一个数一定是$-1$，而且从$1$变成了$-1$要加两次$-1$，即$\large f_{i,0}=f_{i-1,0}+2$

- $\large f_{i,1}:$因为从$1$变成了$0$，所以前一个数一定是$-1$，而且从$1$变成了$0$要加一次$-1$，即$\large f_{i,1}=f_{i-1,0}+1$

- $\large f_{i,2}:$因为前一个数不管怎么取都满足单调性，且$1$变成$1$也不需要再加操作，即$\large f_{i,2}=\min (f_{i-1,0},f_{i-1,1},f_{i-1,2})$

答案就从$\large f_{n,0},f_{n,1},f_{n,2}$三个里挑个最小的

还有，可以发现每一个状态之和前一个状态有关，所以我们还可以滚动数组，进一步优化了空间

## code
```
#include<bits/stdc++.h>
#define maxn 1000005
using namespace std;
const int INF=1<<30;
int n,f[2][3],x,Ans;
inline int read(){
	int ret=0,f=1;char ch=getchar();
	while (ch<'0'||ch>'9'){if (ch=='-') f=-f;ch=getchar();}
	while (ch<='9'&&ch>='0') ret=ret*10+ch-'0',ch=getchar();
	return ret*f;
}
int main(){
	n=read();x=read()+1;
	for (int i=0;i<3;i++) f[1][i]=INF;f[1][x]=0;
	for (int i=2;i<=n;i++){
		x=read()+1;
		if (!x){
			f[i&1][0]=f[1-i&1][0];
			f[i&1][1]=INF;
			f[i&1][2]=f[1-i&1][2]+2;
		}
		else if (x==1){
			f[i&1][0]=f[1-i&1][0]+1;
			f[i&1][1]=min(f[1-i&1][0],f[1-i&1][1]);
			f[i&1][2]=f[1-i&1][2]+1;
		}
		else{
			f[i&1][0]=f[1-i&1][0]+2;
			f[i&1][1]=f[1-i&1][0]+1;
			f[i&1][2]=min(f[1-i&1][0],min(f[1-i&1][1],f[1-i&1][2]));
		}
	}
	Ans=INF;
	for (int i=0;i<3;i++) Ans=min(Ans,f[n&1][i]);
	if (Ans==INF) printf("BRAK");
	else printf("%d",Ans);
	return 0;
}
```



