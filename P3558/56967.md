[题面]( https://www.luogu.org/paste/35tpphqd)

看完了题，很容易想到DP，但是怎么设状态呢？我们先来看看最终的序列是怎么来的。显然值为$0$的项对后一项没有影响，那么改变数列的就是值为$1$或$-1$的项了。再回去看题，题目要求最终的序列长什么样子？单调不降，也就是说我们要通过值为$1$或$-1$的项把整个数列变成大概这个样子(出现小于$-1$或大于$1$的项显然不是最优的)
```
q[1] q[2] q[3] ...... q[n-2] q[n-1] q[n]

 -1   -1   0   ......    0     1      1
```

所以状态就好设了— —$dp[i][j]$表示到第$i$个数为止，结尾为$j+1$的最小次数，更准确地说是：**可以**使得前i个数满足单调不降，且结尾为j的最小操作次数。然后我们按数列中的数加加减减来转移......

就错了quq

为啥呢，看看设的状态：结尾为$j$。说明新状态也要参与转移，所以还有一大坨的分类讨论等着呢。

我们从$2$到$n$扫过去，按数列中的数讨论一下，分出三种情况，再进行转移

$1.nums[i]==-1$----这个数为$-1$

  $dp[i][0]=dp[i-1][0]$----试图使这个数变为$-1$：显然直接继承
   
  $dp[i][1]=(nums[i-1]==1)?min(dp[i-1][0],dp[i-1][1])+1:inf$----试图使这个数变为$0$：若前一个数为$1$，通过加$1$，可以从$dp[i-1][0]$或$dp[i-1][1]$转移过来(这样才能保证不降)，否则不能转移
            
  $dp[i][2]=(nums[i-1]==1)?min(dp[i-1][0],min(dp[i-1][1],dp[i-1][2]))+2:dp[i-1][2]+2$----试图使这个数变为1：若前一个数为$1$，通过两次加$1$，可以从$dp[i-1][0]$或$dp[i-1][1]$或$dp[i-1][2]$转移过来，否则只能从$dp[i-1][2]$转移过来
   
——————————————————————————————————————————————————
   
2.$nums[i]==0$----这个数为$0$

$dp[i][0]=dp[i-1][0]+1$----试图使这个数变为$-1$：可以由$dp[i-1][0]$进行一次减法转移过来

$dp[i][1]=min(dp[i-1][0],dp[i-1][1])$----试图使这个数变为$0$：可以直接从$dp[i-1][0]$或$dp[i-1][1]$转移过来
   
$dp[i][2]=
(nums[i-1]==1)?min(dp[i-1][0],min(dp[i-1][1],dp[i-1][2]))+1:dp[i-1][2]+1$----试图使这个数变为$1$：若前一个数为$1$，通过加$1$，可以从$dp[i-1][0]$或$dp[i-1][1]$或$dp[i-1][2]$转移过来，否则只能从$dp[i-1][2]$转移过来
  
——————————————————————————————————————————————————-  
  
3.$nums[i]==1$----这个数为$1$

$dp[i][0]=dp[i-1][0]+2$----试图使这个数变为$-1$：可以由$dp[i-1][0]$进行两次减法转移过来

$dp[i][1]=(nums[i-1]==-1)?min(dp[i-1][0],dp[i-1][1])+1:dp[i-1][0]+1$----试图使这个数变为$0$：若前一个数为$-1$，则可以从$dp[i-1][0]$或$dp[i-1][1])$通过一次减法转移，否则只能从dp[i-1][0]通过一次减法转移
   
$dp[i][2]=dp[i][2]=min(dp[i-1][0],min(dp[i-1][1],dp[i-1][2]))$----试图使这个数变为1：直接从从$dp[i-1][0]$或$dp[i-1][1]$或$dp[i-1][2]$转移过来

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
int nums[1000009],dp[1000009][3];
int inf=23333333;
int main ()
{
	int n,rd,ans;
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
		scanf("%d",&nums[i]);
	dp[1][0]=dp[1][1]=dp[1][2]=inf;
	dp[1][nums[1]+1]=0;
	for(int i=2;i<=n;i++)
		if(nums[i]==-1)
		{
			dp[i][0]=dp[i-1][0];
			dp[i][1]=(nums[i-1]==1)?min(dp[i-1][0],dp[i-1][1])+1:inf;
			dp[i][2]=(nums[i-1]==1)?min(dp[i-1][0],min(dp[i-1][1],dp[i-1][2]))+2:dp[i-1][2]+2;
		}
		else if(nums[i]==0)
		{
			dp[i][0]=dp[i-1][0]+1;
			dp[i][1]=min(dp[i-1][0],dp[i-1][1]);
			dp[i][2]=(nums[i-1]==1)?min(dp[i-1][0],min(dp[i-1][1],dp[i-1][2]))+1:dp[i-1][2]+1;
		}
		else if(nums[i]==1)
		{
			dp[i][0]=dp[i-1][0]+2;
			dp[i][1]=(nums[i-1]==-1)?min(dp[i-1][0],dp[i-1][1])+1:dp[i-1][0]+1;
			dp[i][2]=min(dp[i-1][0],min(dp[i-1][1],dp[i-1][2]));
		}
	ans=min(dp[n][0],min(dp[n][1],dp[n][2]));
	printf((ans>=inf)?"BRAK":"%d",ans);
	return 0;
}
```