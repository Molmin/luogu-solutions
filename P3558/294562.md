### 题意：

给你一个数组a，每个元素都是-1，0，1中的一个，要求你对任意一个位置的数进行任意次以下操作： $a[i] = a[i] + a[i-1]$，使得操作后的数组变为一个不下降序列，问最少的操作次数。

注意，操作后的数组一定还是只存在-1，0，1三种元素。

***

### 定义状态&初始化：

我们把 $dp[i][j]$ 定义为第i个位置，在前面的元素已经保证不下降的时候，变为j - 1的最少的操作次数。

所以很显然的初始化：

$dp[1][0] = dp[1][1] = dp[1][2] = \inf$

由于第一个元素没法进行操作（前面没有元素），所以把第一个元素变为他本身的最少操作次数置0：$dp[1][a[1] + 1] = 0$。

***

### 转移：

分三种大类，每一种大类分三种小类讨论：

#### 当$a[i] = -1$：

变为-1：由于这个位置本身就是-1，所以$dp[i][0]$只需要满足“前面的数已经是不下降序列”即可，而由于这个位置变成-1，所以前面的只可能是-1，转移方程即为：

$$dp[i][0]=dp[i-1][0]$$

变为0：显然，有且只有一种方式：-1 + 1 = 0。

如果前面一位本身就是1，我们在他没有变为其他数之前直接操作一次就可以变成0了，而他可以变为小于等于0的任意数，也就是：

$$dp[i][1] = \min(dp[i-1][0],dp[i-1][1])+1$$

如果前面一位不为1，那他肯定要变为1，才能使我们这一位变为0，但是前面变成1之后，为了保证不下降，我们这一位只能变成1，所以这是不可能的，也就是：

$$dp[i][1] = \inf$$

变为1：显然，也只有一种方式：-1 + 1 + 1 = 1。

如果前面一位本身就是1，那么可以在任意一刻操作，那前面一位操作后可以变为-1，0，1中任意一个数，也就是：

$$dp[i][2] = \min(dp[i-1][0],dp[i-1][1],dp[i-1][2])+2$$

如果前面一位不是1，那就把它变成1再操作就好了：

$$dp[i][2] = dp[i-1][2]+2$$

### 当$a[i] = 0$：

跟前面一样的思考方式，就讲简便一点了。

变为-1：0 + （-1） = -1。

前面一位必须变为-1，保证不下降，也就是：

$$dp[i][0] = dp[i-1][0]+1$$

变为0，不需要任何操作，只要保证不下降即可了：

$$dp[i][1] = \min(dp[i-1][0],dp[i-1][1])$$

变为1：与$a[i] = -1$的情况一样，不再赘述。

### 当$a[i] = 1$：

变为-1：显然要两次-1：

$$dp[i][0] = dp[i][0] + 2$$

变为0：与前面一样，如果前面已经是-1，直接计算-1，0最小值，否则把前面变为-1。

变为1：本身已经是1，只要保证不下降即可。

由于我们状态是保证前面已经不下降的最少操作次数，所以答案显然是：

$$\min(dp[n][0],dp[n][1],dp[n][2])$$

如果最终答案更新完还为INF，那很显然是无解。

***

### 代码：

```cpp
/*
  Author: EnderDeer
  Online Judge: Luogu
*/

#include<bits/stdc++.h>

#define int long long
#define mem(x) memset(x,0,sizeof(x))

using namespace std;

int read(){
   int s = 0,w = 1;
   char ch = getchar();
   while(ch < '0' || ch > '9'){if(ch == '-')w = -1;ch = getchar();}
   while(ch >= '0' && ch <= '9')s = s * 10 + ch - '0',ch = getchar();
   return s * w;
}

int n;
int a[1000010];
int dp[1000010][5];

signed main(){
	cin>>n;
	for(int i = 1;i <= n;i ++)a[i] = read();
	dp[1][0] = dp[1][1] = dp[1][2] = 2147483647;
	dp[1][a[1] + 1] = 0;
	for(int i = 2;i <= n;i ++){
		if(a[i] == -1){
			dp[i][0] = dp[i - 1][0];
			if(a[i - 1] == 1)dp[i][1] = min(dp[i - 1][0],dp[i - 1][1]) + 1;
			else dp[i][1] = 2147483647;
			if(a[i - 1] == 1)dp[i][2] = min(dp[i - 1][0],min(dp[i - 1][1],dp[i - 1][2])) + 2;
			else dp[i][2] = dp[i - 1][2] + 2;
		}
		if(a[i] == 0){
			dp[i][0] = dp[i - 1][0] + 1;
			dp[i][1] = min(dp[i - 1][0],dp[i - 1][1]);
			if(a[i - 1] == 1)dp[i][2] = min(dp[i - 1][0],min(dp[i - 1][1],dp[i - 1][2])) + 1;
			else dp[i][2] = dp[i - 1][2] + 1;
		}
		if(a[i] == 1){
			dp[i][0] = dp[i - 1][0] + 2;
			if(a[i - 1] == -1)dp[i][1] = min(dp[i - 1][0],dp[i - 1][1]) + 1;
			else dp[i][1] = dp[i - 1][0] + 1;
			dp[i][2] = min(dp[i - 1][0],min(dp[i - 1][1],dp[i - 1][2]));
		}
	}
	if(min(dp[n][0],min(dp[n][1],dp[n][2])) < 2147483647)cout<<min(dp[n][0],min(dp[n][1],dp[n][2]));
	else cout<<"BRAK";
	return 0;
}
```