无解输出 BRAK

题解写的有点麻烦啊~然后我决定写一篇~~

这是我的奇葩 dp 算法，$O(n)$的

设$f_{i,j}$表示前$i$个数,$a_i=j-1$的最小操作次数

数组初始化为$∞$，$f_{1,a_i+1}=0$

然后分三种情况讨论

### 若$a_i=1:$

$$f_{i,0}=f_{i-1,0}+2$$

$$f_{i,1}=f_{i-1,0}+1$$

$$f_{i,2}=\min(f_{i-1,0},\min(f_{i-1,1},f_{i-1,2}))$$

最后一条式子是因为$a_i=1$，这已经满足要求了，所以上一个数是$-1,0,1$都无所谓，$f_{i-1,0},f_{i-1,1},f_{i-1,2}$都可以取

### 若$a_i=0:$

$$f_{i,0}=f_{i-1,0}+1$$
			
$$f_{i,1}=\min(f_{i-1,0},f_{i-1,1})$$

$$f_{i,2}=f_{i-1,2}+1$$

第二条式子是因为$a_i=0$，所以上一个数是$-1,0$都无所谓，$f_{i-1,0},f_{i-1,1}$都可以取

### 若$a_i=-1:$

$$f_{i,0}=f_{i-1,0}$$

$$f_{i,2}=f_{i-1,2}+2$$

为什么$f_{i,1}$没有转移呢？因为$-1$只能通过$+1$来变成$0$，这必须满足$a_{i-1}=1$，但这样就不满足题目要求了$(1>0)$ $……$

那么这题就愉快的做完啦！只不过我的思维已经混乱了~

```
#include<bits/stdc++.h>
using namespace std;
int n,a[1000001],f[1000001][4];
inline int read(){
	int x=0,f=1;char ch=getchar();
	while (!isdigit(ch)){if (ch=='-') f=-1;ch=getchar();}
	while (isdigit(ch)){x=(x<<1)+(x<<3)+ch-48;ch=getchar();}
	return x*f;
}
int main(){
	n=read();
	for (int i=1;i<=n;i++){
		a[i]=read();
	}
	memset(f,0x3f,sizeof(f));
	f[1][a[1]+1]=0;
	for (int i=2;i<=n;i++){
		if (a[i]==1){
			f[i][0]=f[i-1][0]+2;
			f[i][1]=f[i-1][0]+1;
			f[i][2]=min(f[i-1][0],min(f[i-1][1],f[i-1][2]));
		}else if (a[i]==0){
			f[i][0]=f[i-1][0]+1;
			f[i][1]=min(f[i-1][0],f[i-1][1]);
			f[i][2]=f[i-1][2]+1;
		}else{
			f[i][0]=f[i-1][0];
			f[i][2]=f[i-1][2]+2;
		}
	}
	if (min(min(f[n][0],f[n][1]),f[n][2])==f[0][0]){
		printf("BRAK");
	}else{
		printf("%d",min(min(f[n][0],f[n][1]),f[n][2]));
	}
}
```