# 首先，这是一道非常好的$DP$-动态规划
## 前言

update:2019.10.16，修改部分小细节！

把话放在前面，如果无解是输出$BRAK$，本蒟蒻输出了一个$BAKE$调了半天！还是得感谢我校巨佬给出的明确提醒！手动$@$[紫薯布丁](https://www.luogu.org/space/show?uid=124591)！！

这是道比较好的线性$DP$，在看着海绵宝宝的时候，灵光一现，这题似乎可以这么写！！于是顺利由于$BAKE$调了半天。

不妨来明确一下题意：

现在手中有这样一个数组$num$，里面只存在着三种数$\ -1,0,1\ $。对于这个数组，你进行下面的操作：$a[i]+=a[i-1]$。

随后呢，你可以对于每个位置进行若干次操作，最终使得整个数组变成单调不下降的序列！如果无解，便输出和$BRAK$。

**一个很显然的问题**，这个题操作之后，一定全是 $\ -1,0,1\ $，而不会存在其他数字！！这是翻译题面中没有提到的地方！

在看海绵宝宝的时候脑子一瓦特，这题大概是一个区间$DP$，那么这样看来$\ What\ should\ we\ do?$ 

**大胆莽一波不怂直接上：**$\ $ $f[i][j]$，表示第$i$个位置，变成$j\ $的最小变化次数。

然而，数组以负数做下标，极大可能性会$CE$，所以我们应该想个办法不让$ta\ CE$!

那么，不妨用$f[i][0]$表示第$i$个位置，变成$-1$的最小变化次数。

用$f[i][1]$表示第$i$个位置，变成$0$的最小变化次数。

用$f[i][2]$表示第$i$个位置，变成$1$的最小变化次数。

**那么肯定得初始化一些东西：**

$f[1][0]=INF,f[1][1]=INF,f[1][2]=INF$。

与此同时，$f[1][num[1]+1]=0$，因为$num[1]$前面没有数，所以肯定无法通过操作来转换！！

把一切都初始化好，那就准备开始从$num[2]$的地方开始转移吧！！

## 转移

不妨假设现在处于的位置为$i$。

------------

### 若$num[i]==-1$时：

$Situation\ 1$：

假如我们想把当前位置变成$-1$，那么由于$num[i]==-1$，那么如果我们想把它变成$-1$，根据要保证数列有序，那么我们前一个一定是$-1$,又因为该点是$-1$，所以根本不用转移！即：
$$f[i][0]=f[i-1][0]$$

$Situation\ 2$：

假如我们想把当前位置变成$0$，现在的位置是$-1$，众所周知$-1+1=0$，那么如果我们前一位是$1$的话，显然我们可以在某一时刻，进行一次操作，将$-1$转换成$1$。同时，由于最终数组是有序的，所以前一位一定不大于$0$，那么转移一定可以从前一位转换成 $0,-1$来转移。即：
$$if(num[i-1]==1)\ f[i][1]=min(f[i-1][0],f[i-1][1])+1$$

如果前一位原先不是$1$呢。那么我们仔细考虑一下，是否可以在某一时刻前一位转换以后变成$1$,显然这是不可能的，因为我们要保证数组有序，那么这样来看如果上一位都转换成 $1$ 了，显然这一位必须是$1$而不是$0$,那么显然这个转移不成立，这样看来将其赋一个极大值便可以了。即：
$$if(num[i-1]!=1)\ f[i][1]=INF$$

$Situation\ 3$：

假如我们想让当前位置变成$1$，又由于当前位置为$-1$，那么我们必须通过两次$+1$的操作，使得$-1$变成$1$。

那么这个$1$哪里来呢？有两种方法：

第一种情况就是前一位在原先数组里便是$1$，那么，我们可以在某一时刻，进行两次操作，把该位置变成$1$,又由于1是整个数组里最大的数，显然在最终数组中，前面可以是$-1,0,1$任何一个。那么肯定可由前一个的任意情况转移过来，即：
$$if(num[i-1]==1)\ f[i][1]=min(f[i-1][0],f[i-1][1],f[i-1][2])+2$$

第二种情况是，这个$1$是通过某次转移后得到的，并且前一位在原先数组里便不是$1$。那么：

$$if(num[i-1]!=1)\ f[i][2]=f[i-1][2]+2$$

综上所述：当$num[i]=-1$时的转移是：

$f[i][0]=f[i-1][0]$

$f[i][1]=(num[i-1]==1)?min(f[i-1][0],f[i-1][1])+1:INF$

$f[i][2]=(num[i-1]==1)?min(f[i-1][0],f[i-1][1],f[i-1][2])+2:f[i-1][2]+2$

------------

### 若$num[i]==0$时：

既然第一种情况那么详细了，那下面的就简略一点吧！

$Situation\ 1$：

假如我们想让当前位置变为$-1$，那么一定需要前一个数为$-1$，才能转移，那么在根据$num[i]==-1$的$Situation1$，得知：

$$f[i][0]=f[i-1][0]+1$$

$Situation\ 2$:

如果我们想让当前的值变为$0$，又因为本身$num[i]=0$，那么最终数组前面可以是$0,-1$，那么显然:

$$f[i][1]=min(f[i-1][0],f[i-1][1])$$

$Situation\ 3$:

与第一大类情况的$Situation$相似，不过这样变成了操作一次，那么便是：

$$if(num[i-1]==1)\ f[i][1]=min(f[i-1][0],f[i-1][1],f[i-1][2])+1$$

$$if(num[i-1]!=1)\ f[i][2]=f[i-1][2]+1$$

综上所述，当$num[i]==0$时的转移情况为：

$f[i][0]=f[i-1][0]+1$

$f[i][1]=min(f[i-1][0],f[i-1][1])$

$f[i][2]=(num[i-1]==1)?min(f[i-1][0],f[i-1][1],f[i-1][2])+1:f[i-1][2]+1$

------------
### 若$num[i]==1$时：

$Situation\ 1$:

与前面的各种$Situation\ 1$相同：

$$f[i][0]=f[i-1][0]+2$$

$Situation\ 2$:

假如我想把它变成$0$，那么只可能是前一个数是$-1$，再继续上面的思考方法可以知道：

$$f[i][0]=(num[i-1]==-1)?min(f[i-1][0],f[i-1][1])+1:f[i-1][0]+1$$

$Situation\ 3$:

假如我想把它变成$1$，它本来就是$1$，所以一定不受影响。那么：
$$f[i][2]=min(f[i-1][0],f[i-1][1],f[i-1][2])$$

------------
### 所以最终答案为：
$$min(f[n][0],f[n][1],f[n][2])$$

------------

## 代码
```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <queue>
using namespace std;
#define maxn 1000005
const int INF=1e9+7;
int f[maxn][3],num[maxn],n;
int main()
{
	scanf("%d",&n);
	for(register int i=1;i<=n;i++) scanf("%d",&num[i]);
	f[1][0]=INF,f[1][1]=INF,f[1][2]=INF;
	f[1][num[1]+1]=0;
	for(register int i=2;i<=n;i++)
	{
		if(num[i]==-1)
		{
			f[i][0]=f[i-1][0];
			f[i][1]=(num[i-1]==1)?min(f[i-1][0],f[i-1][1])+1:INF;
			f[i][2]=(num[i-1]==1)?min(f[i-1][0],min(f[i-1][1],f[i-1][2]))+2:f[i-1][2]+2;
		}
		if(num[i]==0)
		{
			f[i][0]=f[i-1][0]+1;
			f[i][1]=min(f[i-1][0],f[i-1][1]);
			f[i][2]=(num[i-1]==1)?min(f[i-1][0],min(f[i-1][1],f[i-1][2]))+1:f[i-1][2]+1;
		}
		if(num[i]==1)
		{
			f[i][0]=f[i-1][0]+2;
			f[i][1]=(num[i-1]==-1)?min(f[i-1][0],f[i-1][1])+1:f[i-1][0]+1;
			f[i][2]=min(f[i-1][0],min(f[i-1][1],f[i-1][2]));
		}
	}
	int ans=min(f[n][0],min(f[n][1],f[n][2]));
	if(ans>=INF) printf("BRAK\n");
	else printf("%d\n",ans);
	return 0;
}
```
