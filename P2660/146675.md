## 思路

本题的要点是：种田每次只能种正方形。

为了保证消耗体力最少，每次种田就必须选择种在可种范围内最大的正方形（就是以宽为变长的正方形），这点应该好理解。

### 然后这道题就可以近似地看成：“将大长方形割成多个小正方形，怎样割使小正方形最少。”
你需要做的就只是在割的时候把周长算出来相加而已。

------------
我用的方法类似于辗转相除法，由于题目规定了xy大小关系，所以不需要比较。
###### （题目中说x是长，但是所有数据都是x为宽。所以我直接默认x宽。）

我举的3×5例子（硬核）：
|1  | 1 |1  | 3 | 3 |
| -----------: | -----------: | -----------: | -----------: |-----------: |
| 1 |1  |1  | 2 | 2 |
| 1 |1  | 1 |2  |2  |
###### （数字代表第几次种的田）

第一次，种一片3×3的田，消耗1×4×3体力，之后整一个田可以看成2×3的田。

第二次，种一片2×2的田，消耗1×4×2体力，之后整一个田可以看成1×2的田。

第三次，种两片1×1的田，消耗2×4×1体力，田种完。

总共消耗28体力。
## 代码
```cpp
#include<iostream>
using namespace std;
long long x,y,ans;//题目中注明了1<=x,y<=10^16，要用long long，我在这坑上翻车过
int main(){
	cin>>x>>y;
	while(x>0){
		ans+=4*x*(y/x);//y/x是种田的数量
		long long t=x;
		x=y%x;//种剩下的作为下一次操作的宽
		y=t;//这次的宽作为下一次的长
	}
	cout<<ans;
    return 0;
}
```
------------
这道题还可以用递归做，这值得一试。~~因为我懒得写。~~