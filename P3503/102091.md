## 题意

给定一条长为 $N$ 的正整数序列 $A[i]$ 和一个正整数 $K$ ，每次可以将序列中一个大于 $K$ 的数减去 $1$ ,再给它其中一个相邻的数加上 $1$ 。问若干次操作后，能够出现的最长区间，使得每一个数都 $\geq K$ 的长度是多少。$M$ 组询问。

$$N\leq 10^6,M\leq 50$$

## 题解

一道很好的思维题。

首先很容易想到的是，每个数都一定会将它大于 $K$ 的部分转移到相邻的数上，最后让一段区间内的数都等于 $K$，这样是最优的。

那么，经过操作之后每个数都等于 $K$ ，就直接等价于这段数的**平均值** $\geq K$ 。

因为平均值带除法，不好处理，所以我们将序列中的每个数减去 $K$ ，将问题转化为求**最大的**使得**区间和非负**的区间。

计算出处理后的序列的前缀和 $S[i]$ ，问题又进一步转化为

$$\text{最大化}(r-l),\text{使得}0 \leq l < r,S[l] \leq S[r]$$

$O(N^2)$ 枚举区间肯定是过不了这题的，我们寻找一些性质来优化算法。显然 $S[l] \leq S[r]$ 的条件限制了区间的扩大。这个问题非常简洁地体现出了答案的**合法性**和**最优化**之间的矛盾。

注意到在区间端点的选取时，若 $i < j,S[i] \leq S[j]$ ，$j$ **不可能被选作答案的左端点**。因为若 $S[j]\leq S[r]$ ，也会有 $S[i]\leq S[r]$ ，并且选取 $i$ 作为左端点区间更大。同理，$i$ 永远**不可能被选作右端点**。

于是，考虑维护一个 $S[i]$ 递减的单调栈。从 $1$ 到 $N$ ，每次只将小于栈顶的数压入栈中，这些就是所有可能的左端点。

同理，从 $N$ 到 $1$ ，每次只大于栈顶的数压入栈中，这些就是所有可能的右端点。

我们发现，可能作为答案的左端点或右端点都是单调的，这个性质非常漂亮。

我们只需要维护一个栈，另外一个端点直接枚举即可。具体操作如下

* 用单调栈维护所有可能的左端点。这些数是递减的

* 从 $N$ 到 $1$ ，每次只讨论**大于上一次讨论过的数**的数，这样可以讨论完所有可能的右端点。

* 因为每次讨论的右端点是递增的，所以 $S[l]\leq S[r]$ 的合法性也是单调的。也就是说，当 $S[r]$ 增加，原来合法的左端点仍然合法。而 $l$ 增加虽然仍然合法，但不可能使答案更优，所以在每次讨论右端点时，在保持栈顶元素合法的情况下不断弹出栈顶并更新答案，就可以计算出结果。

时间复杂度 $O(N)$ 。这道题的解法还是非常巧妙的。

## 代码

代码非常简单，价值在于挖掘题目性质的过程。

```cpp
#include <iostream>
#include <cstdio>
using namespace std;

const int MAXN= 1000005;
long long K,A[MAXN],S[MAXN];
int N,M,stac[MAXN],st,maxi,ans;

void solve(){
	ans= st= 0;
	for(int i=1;i<=N;++i) S[i]= A[i]-K;
	for(int i=1;i<=N;++i) S[i]+= S[i-1];
	for(int i=1;i<=N;++i) if(!st || S[stac[st]]>S[i]) stac[++st]= i;
	for(int i=N,j=N;i>=1;--i){
		if(S[i]>=0) ans= max(ans,i);
		if(i==N || S[i]>S[j]){
			while(st && S[i]>=S[stac[st]]){
				ans= max(ans,i-stac[st]);
				st--;
			}
			j= i;
		}
	}
	return;
}

void Input(){
	scanf("%d%d",&N,&M);
	for(int i=1;i<=N;++i)
		scanf("%lld",&A[i]);
	return;
}

int main(){
	Input();
	while(M--){
		scanf("%lld",&K);
		solve();
		printf("%d ",ans);
	}
	return 0;
}
```