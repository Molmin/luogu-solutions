应该是第一道校内模拟赛时切掉的 dp 题，为自己感到自豪。   
我们设 $f_{i,j}$ 表示长度为 $i$，最后一个数为 $j$ 的序列的数量，则     
$f_{i,j}=(\sum_{s=1}^{j-m} f_{i-1,s})+(\sum_{s=j+m}^{m} f_{i-1,s})$。   

但是这样的话时间复杂度为 $O(nm^2)$，无法通过此题。    
留意到两部分所求和的区间是连续的，我们可以使用前缀和优化。    
设 $qz_{i,j}=\sum_{s=1}^j f_{i,s}$，则
$$f_{i,j}=qz_{i-1,j-k}\times(j-k>=1)$$
$$+(qz_{i-1,m}-qz_{i-1,j+k-1})\times(j+k<=m)$$
$$-f_{i-1,j}\times(k=0).$$
式子有点长，结合上面的铺垫理解理解。此处括号内的表达式取值为 $1$ 或 $0$，具体取值取决于表达式的真假，如果是真则为 $1$，否则为 $0$。  
至于为什么 $k=0$ 的时候要减去 $f_{i-1,j}$ 是因为前面两种情况都算了一遍 $f_{i-1,j}$，多算了一次。    
在求 $f_{i,j}$ 的时候，$qz_{i,j}$ 也可以顺便更新。   
于是这道题就以 $O(nm)$ 的时间复杂度做完啦！    
提醒各位取模的时候要记得先加上 $998244353$ 再取模，为了避免负数的出现。   
代码：    
```cpp
#include<stdio.h>
int n,m,k;long long f[1005][5005],qz[1005][5005];
int main()
{
    scanf("%d%d%d",&n,&m,&k);
    for(int i=1;i<=m;i++) f[1][i]=1,qz[1][i]=qz[1][i-1]+1;//初始化
    for(int i=2;i<=n;i++) for(int j=1;j<=m;j++)
    {
        if(j-k>=1) f[i][j]=(f[i][j]+qz[i-1][j-k])%998244353;
        if(j+k<=m) f[i][j]=(f[i][j]+qz[i-1][m]-qz[i-1][j+k-1]+998244353)%998244353;
        if(k==0) f[i][j]=(f[i][j]-f[i-1][j]+998244353)%998244353;
        qz[i][j]=(qz[i][j-1]+f[i][j])%998244353;
    }
    printf("%lld",qz[n][m]%998244353);//这里一次性算出了从1~m的结果之和，因为最后的数从1~m都有可能，而长度必须是n
}
```