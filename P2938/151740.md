### 虽说2019CSP已永远离我们远去，但我们仍能得到新知识


~~写的太迟了，见谅~~。

如果你认真的读完题，我相信你会发现，这道题似曾相识。

~[见本题](https://www.luogu.com.cn/problem/P2938)

**没错，这是2019CSP入门的第3题，一模一样。**

[ Double Experience ！](https://www.luogu.com.cn/problem/P5662)

~~略有不同，在输入部分（逃~~

好，你现在应该知道这题是一道完全背包题，那为什么呢?

**首先，题目直接给出了背包容量，即小伟手上有的钱，当然在小伟不断买卖的过程中，它是会变的，并且，小伟当天能无限制的买入，卖出，这也就说明它是完全背包。**

完全背包大家应该都学过，这里不进行赘述。

阶段，就是完全背包的，即小伟手上有的钱数，那来看决策吧。

```
	for (int i = 1; i <= m; i ++)
	   	for (int j = w[i]; j <= t; j ++)
			f[j] = max(f[j], f[j - w[i]] + c[i]);
```

这是普通的完全背包的决策，

但很显然，题目没有直接给出，第i个物品的体积和价值。

**仔细读题，不难发现，当前物品的体积是上一天的价格，而其价值是两天，不一定是相邻两天的价格。**

~~没有中间商赚差价（逃~~

**说实话，动态转移方程已经明了，**

	f[j] = max(f[j], f[j - a[k][i]] + a[k + 1][i] - a[k][i]);
    
a[k][i] 数组用来表示第 k 天，第 i 件物品的价值，

但事实上，输入的却是，第 k 件物品，第 i 天的价值，

所以，这就要求我们，输入时注意一下。



------------
# 附上完整代码

```
#include<bits/stdc++.h>
using namespace std;
int const N=150;
int const M=500050;
int t, n, m;
int a[N][N];
int f[M];

int main()
{
	cin >> n >> t >> m;
	for (int i = 1;i <= n;i ++)
		for ( int j = 1;j <= t;j ++)
			cin >> a[j][i];
	for (int k = 1; k <= t;k ++)
	{
		memset(f, 0, sizeof(f));
		for (int i = 1;i <= n;i ++)
			for (int j = a[k][i];j <= m ;j ++)
				f[j] = max(f[j], f[j - a[k][i]] + a[k + 1][i] - a[k][i]);
		m = max(f[m] + m, m);
	}	
	cout << m;
	return 0;
}
```
## 注意细节：

**cin 部分，**

**memset 的意义不用过多赘述，**

**之前的叙述里已经提到过了，我们的背包容量不是一成不变的，所以，你懂得。**


~~话说一模一样的题难度是不一样的，有点小奇怪（逃~~