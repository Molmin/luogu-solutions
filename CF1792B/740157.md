## 题意

有四种操作：

1.	令 A 和 B 均增加 $1$
2.	令 A 增加 $1$，B 减少 $1$
3.	令 A 减少 $1$，B 增加 $1$
4.	令 A 和 B 均减少 $1$

若 A 或 B 的值严格小于 $0$，则结束以后的操作，当前操作保留。

有 $T$ 组数据，对于每一组数据，分别给定四种操作的个数 $a1,a2,a3,a4$，输出最大的操作次数。

### 分析

显然的，使操作次数最多，要求尽可能先进行操作一，尽可能晚进行操作四。可以发现，若第一种操作可操作的次数为零，则无论如何再进行下一次操作时必将结束后续的操作。所以可以将判断放置最前，若满足 $a1$ 值为 $0$，则输出 $1$，进行下一组数据处理。

还可以发现，操作二和操作三是完全相反的，所以可以将两个相反的操作合并为一组，但是开始操作时有一个必要条件，即进行一组操作时，A 和 B 的初始值不能为 $0$。由于有了前面的判断，所以必定可以进行 $\min(a2,a3) \times 2$ 次操作。

剩余的操作次数会将 A 和 B 的值减小，且操作完成之后两个值相等，所以可操作次数显然是 这个值 和 剩余操作次数 的最小值。但是不要忘记操作结束是 A 或 B 的值 **小于** $0$ 或者不可操作。故要将 A 或 B 的值 加上一，再进行计算输出。

代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
int t;
int a1,a2,a3,a4,ans;
int main(){
	scanf("%d",&t);
	while(t--){
		scanf("%d%d%d%d",&a1,&a2,&a3,&a4);
		if(a1==0){//不可操作 
			printf("1\n");
			continue;
		}
		ans=a1;
		ans+=min(a2,a3)*2;//2,3的相反操作 
		ans+=min(a1+1,abs(a2-a3)+a4);//在相反操作中已经进行了 min(a2,a3) 次操作，故要取大减小的差值再与 a4 的可操作数相加。 
		printf("%d\n",ans);
	}
	return 0;
}
```