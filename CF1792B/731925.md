首先显然我们肯定是要优先考虑表演第 1 类相声，最后表演第 4 类相声（前提是可以表演），接下来我们主要考虑第 2 类和第 3 类相声。

在这里不妨设 $a_2\le a_3$，否则交换他们俩情况就一样了。

我们发现，当 `Alice` 和 `Bob` 心情都不为 0 时，表演一个第 2 类相声后再表演一个第 3 类相声后，他们的心情和表演前相同，所以**当两人心情都不为零时**可以把第 2 类和第 3 类打包在一起，共有 $a_2$ 组 $2\times a_2$ 个相声。

而其余的相声会使至少一个人的心情不断减少，因为只要有一个观众离开表演就结束，所以这时剩下的第 2、3 类相声其实和第 4 类相声一样了，只需考虑他们的总数即可：剩下的第 2、3 类相声有 $a_3-a_2$ 个，第 4 类相声有 $a_4$ 个，则共有 $a_3-a_2+a_4$ 个。

这里考虑前面表演了第 1 类相声和打包的 2、3 类相声可以将两人的心情增加 $a_1$，还能表演的相声节目就是 $min(a_1,a_3-a_2+a_4)$ 个？其实这个是错的。注意题目说的：

>若演完某个节目有观众退场，这个节目也算在总数之中。

所以当有人的心情减少到 0 时，若还有节目，则还可以继续表演，所以还能表演的相声数应该是 $min(a_1+1,a_3-a_2+a_4)$ 个。

把上述合并起来，就能得到最终的结果（答案用 $ans$ 表示）：

$ans=a_1+2\times a_2+min(a_1+1,a_3-a_2+a_4)$

最后看一下这道题要注意的地方（别被坑了！）：

1.把第 2、3 类打包起来后应该是组数的 2 倍。

2.若演完某个节目有观众退场，这个节目也算在总数之中。

**3.若 $a_1=0$，则只能表演一个节目（需要特判！！）。**

### Code:
```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
    int T;
    cin>>T;
    while(T--){
        int ans;
        int a,b,c,d;//这里用a,b,c,d代替a[1],a[2],a[3],a[4]
        cin>>a>>b>>c>>d;
        if(a==0){cout<<1<<endl;continue;}
        if(b>c)swap(b,c);
        ans=a+2*b+min(a+1,c-b+d); 
        cout<<ans<<endl;
    }
    return 0;
}
```
