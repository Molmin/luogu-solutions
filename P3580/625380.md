[题目传送门](https://www.luogu.com.cn/problem/P3580)

神仙 dp 题，蒟蒻做不出来。

十分典型的单调队列优化 dp，很好展现了这类可用单调队列优化的**序列 dp** 的性质。

## 题目性质分析
考虑问题的两条性质，我们可以简化问题：

假如我们从 $A$ 处发出了若干辆车，但是在它们都到达 $B$ 处之后，只让一部分车回来，然后再让剩下的车出发，

包括先前没回来的部分，最后所有的车也一并都要**依次回来**；

考虑发出多少车，就回来多少车的方案，相比于上述方案，先发的车先回来节约的时间，与后发的车多等待消耗的时间相互抵消，并没有让总时间增加，这就说明这两种方案是**等效**的方案，

因此，我们就可以只考虑后者，这样我们的问题就得到简化，也更容易设计状态。

## 状态设计
设 $f[i]$ 表示前 $i$ 辆车，分成若干批次往返后，**最晚回来**的列车的到达 A 处所用的**最少时间**。

我们可以画图来理解这个问题：

![](https://cdn.luogu.com.cn/upload/image_hosting/uxwdg8pb.png)

如图，$A$ 和 $B$ 分别为到达两地的时间轴，$j$ 位置表示第 $j$ 辆车回到的时间戳，$i$ 位置表示第 $i$ 辆车发车的时间戳，$i^{\prime}$ 表示其回到的时间戳。

考虑 $i$ 的发车时间戳，$i$ 与 $j$ 之间**间隔**了 $i-j$ 辆车（包括 $i$ 自己），

由于 $j$ 回到后的**第 $0$ 时刻**就可以发新的车，又因为间隔一个单位时间就可以发一辆车，那么 $i$ 的理想发车时间戳就比 $j$ 的回到时间戳晚了 $i-j-1$ 个单位，

当然，每辆车都有其最早发车时间的限制，因此要和 $t[i]$ 取最大值。

再考虑 $i$ 的回到时间戳，对于任意一辆车，在 $A$ $B$ 之间往返的时间为 $2\times s$，同理，由于在 $B$ 等待发车时也要遵循间隔一个时间单位**顺序发车**的限制，因此 $i$ 的回到时间戳还要再晚 $i-j-1$ 个单位。

因此我们有状态转移方程：

$$f[i]=\min\{\max(t[i],f[j]+i-j-1)+2\times s+i-j-1\}$$

直接转移显然复杂度为 $O(N^2)$ 不可接受，接下来思考怎么优化。

## 转移优化
考虑转移方程的性质，在 `max` 函数中，$t[i]$ 和 $i$ 在当前转移的这轮是**定值**，$j$ 或 $f[j]$ 是需要我们不断维护的**变量**。

于是考虑将 `max` 函数分解，即分为 $t[i]>f[j]+i-j-1$ 和 $t[i]\leq f[j]+i-j-1$ 两种情况，

整理一下得到：

$f[i]=\begin{cases}\min\{t[i]+2\times s+i-j-1\} & t[i]-i+1>f[j]-j \\ \min\{f[j]+2\times (s+i-j-1)\} & t[i]-i+1\leq f[j]-j\end{cases}$

只保留变量化简得：

$f[i]=\begin{cases}\min\{-j\}+t[i]+2\times s+i-1 & t[i]-i+1>f[j]-j \\ \min\{f[j]-2\times j)\}+2\times (s+i-1) & t[i]-i+1\leq f[j]-j\end{cases}$

输入格式中写明了 $t[i]$ 的序列是**单调不降**的，又由于每辆车必须间隔一个单位时间发车，所以每辆车的 $t[i]$ 等效于 $max(t[i],t[i-1]+1)$。

做了这样一个转换后，就能保证 $t[i]-i$ 也是**单调不降**的，那么每轮转移枚举 $i$ 时，$t[i]-i$ 就在一个**单调的序列上增长**，

类似的，显然 $f[j]-j$ 也是**单调不降**的，所以我们要维护的是**连续**的一段**最值**，于是我们就可以使用**单调队列**。

具体而言，要应用单调队列，就要先把问题转换成**类滑动窗口**的问题，假如我们认定需要维护的 $f[j]-j$ 的“窗口”是**大于**等于 $t[i]-i+1$ 的区间，那我们**队首元素**弹出队列的条件就确定了。

根据我们化简后的转移方程，我们的单调队列要维护的值就是 $f[j]-2\times j$，并且维护的是一个**单调减**的队列。

那么第一种情况，也就是 $f[j]-j$ 更小的情况的转移要怎么完成呢？

其实我们每轮因不满足条件而弹出的**队首元素**就都是满足这种情况的元素，于是我们用**最后一个**弹出的队首元素更新这种情况下的 $f[i]$。

之所以用最后一个弹出的元素，是因为既然我们用了单调队列来维护，那么**最靠近队头**的元素肯定是转移的**最优解**，因此最后一个弹出的元素和当前的队首元素就分别是方程中两种情况转移的最优解。

需要说明的是，在第一种情况中，我们本来要维护的是 $-j$ 而不是 $f[j]-2\times j$，但是由于 $f[j]-2\times j$ 是**随着** $j$ 的单调变化而单调的，因此维护了 $f[j]-2\times j$ 的单调性就等效于维护了 $-j$ 的单调性。

应用了单调队列优化后，原先枚举 $j$ 的 $O(N)$ 复杂度均摊为 $O(1)$，于是总复杂度由 $O(N^2)$ 降为 $O(N)$。 
## 附上代码
```cpp
#include<bits/stdc++.h>
#define int long long
#define maxn 1000010
using namespace std;
int q[maxn],l=1,r,f[maxn],t[maxn];
signed main()
{
    int n,s;
    cin>>n>>s;
    for(int i=1;i<=n;++i)cin>>t[i];//输入保证t[i]单调
    memset(f,0x3f,sizeof(f));
    t[0]=-1;
    for(int i=1;i<=n;++i)t[i]=max(t[i],t[i-1]+1);//保证每辆车发车间隔一秒
    for(int i=1;i<=n;++i)
    {
        while(l<=r && f[q[l]] - q[l] < t[i] - i + 1)l++;
        while(l<=r && f[q[r]]- 2 * q[r] > f[i] - 2 * i)r--;
        f[i]=min(f[i],t[i] + 2 * s + i - q[l-1] - 1);
        f[i]=min(f[i],f[q[l]] + 2 * ( s + i - q[l] - 1));
        q[++r]=i;
    }
    cout<<f[n]<<endl;
	return 0;
}

```

## 小结
本题已经充分体现了许多可以用单调队列优化的序列问题的特点：

- 转移的对象在枚举或更新时是**单调变化**的。

- 转移的来源在单调变化的**固定长度或性质**的区间。

- 需要维护的是转移来源的**最值**。

- ......






























