## 一种不用扩展KMP的方法

~~当然KMP还是一定要用到的~~

### 预处理

根据题意，我们先做两个预处理：

设字符串长度为n

`pre[i][j]` 表示i位置及以前”有小于等于j个字符出现次数为奇数的位置”的数量

`sub[i]` 表示从i位置到n位置有多少个字符出现次数为奇数（即题中函数F）

为什么要求这两个数组？因为我们发现AB可以看做一个整体，如果确定了AB和重复次数，那么C也就确定了

相当于我们枚举如何把字符串分割为 $(AB)^i$ 和 $C$ 两部分，如果确定了C部分和AB部分的右端点，那么A的右端点就可以用 `pre` 数组得到

例如我钦定B部分的右端点为 `i`，C部分的左端点为 `j`，那么最终A可选择的位置数就是 `pre[i-1][sub[j]]`（注意还得给B至少留一个位置）

pre和sub数组的初始化方法如下：

```cpp
int odd=0,cnt=0;//odd状压记录，0为偶，1为奇，cnt记录数量
for(int i=1;i<=n;i++){
	if(odd&(1<<a[i]))cnt--;
	else cnt++;
	odd^=(1<<a[i]);
	for(int j=0;j<=26;j++)pre[i][j]=pre[i-1][j]+(j>=cnt);//每次的cnt都会对大于等于它的j有影响，见pre的定义
}odd=cnt=0;
for(int i=n;i>=1;i--){
	if(odd&(1<<a[i]))cnt--;
	else cnt++;
	sub[i]=cnt;//后缀记录
	odd^=(1<<a[i]);
}
```

### 计算每个循环节的贡献

现在我们考虑一下如何计算贡献

一个直观的想法是：我们可以把字符串每一个前缀尝试当一次 $AB$，计算这个前缀的Hash值，然后用倍增找这段最多能往后扩展多少个循环节

待会再考虑KMP优化，不妨先看看如果找到了循环节数量以后该怎么做：

假设我们枚举作为 $AB$ 的前缀为 $P=S_{1,i}$（即1到i的前缀），而且往后一共可以扩展 $sz$ 个循环节（包括P本身），如何计算贡献？

首先对于P自身，如果 $sz=1$，那么就可以直接向答案中累加 `ans+=pre[i-1][sub[i+1]]`（给B留至少一个位置所以减一，C从下一个位置开始看所以加一）

而如果 $sz=2$ ，那么显然我们不仅要算 $(AB)^1$ 的贡献 `pre[i-1][sub[i+1]]`，还要加上 $(AB)^2$ 的贡献 `pre[i-1][sub[i*2+1]]` (AB的长度没变，A能选的位置也没变，但C往后减少了一个AB循环节)

因此我们相当于需要计算：

`for(int k=1;k<=sz;k++)ans+=pre[i-1][sub[i*k+1]]`

但是在出现很多相同的数的数据里面， $sz$ 的值显然很大，我们能不能考虑另外的方法呢？

注意到在P固定而k增大的过程中，A可选的范围一直是 $[1,i-1]$，但C会不断减去 $P$，考虑一下C的sub值的变化：

首先，有以下两个结论：(F为题中函数)

- $F(P^2)=0$ 

- $F(AP^2)=F(A)$

1成立是因为两个相同字符串相接每个字符的出现次数一定都是偶数（*2了），2成立是因为奇数+偶数=奇数，偶数+偶数=偶数，不会改变奇偶性

推理到本题上就是：

$F(P^{sz}C)=F(P^{sz-2}C)$

所以不难发现：

当上面那个for循环中k为奇数时，对答案的贡献相同，都等于 `pre[i-1][sub[i+1]]`。

k为偶数时，对答案的贡献相同，都等于 `pre[i-1][sub[2*i+1]]`


经过试验，发现 $[1,sz]$ 中为偶数的数的个数为 $\lfloor \frac{sz}{2}\rfloor$ ，为奇数的数的个数为 $\lceil \frac{sz}{2}\rceil$

因此我们可以用以下式子直接计算当前前缀P对答案的贡献：

```cpp
int valodd=pre[i-1][sub[i+1]];
int valeven=sz>1?pre[i-1][sub[i*2+1]]:0;//特判一下防止下标越界
ans+=(ll)(((sz-1)>>1)+1)*valodd;//奇数情况（上取整）
ans+=(ll)(sz>>1)*valeven;//偶数情况（下取整）
```

好了，现在如果配套hash+倍增，就可以得到一个 $O(n\log n)$ 的算法，可是还是过不去qwq

因此我们有必要请出主角——KMP算法了：

### KMP 求循环节

KMP求循环节本身比较简单（请先掌握KMP算法的模板再看接下来的内容）：

由于KMP中的 `next[i]` 表示：$S_{1,next_i}=S_{i-next_i+1,i}$

因此如果 $i-next_i$ 能整除 $i$ ，那么相当于有如下的一个图：

![](https://cdn.luogu.com.cn/upload/image_hosting/vqxb82fm.png)

这里面 $i=12,next_i=9$，那么前三个数不属于相同的那段后缀，但属于前缀的前三个，那么相同的那段长度为9的后缀的前三个也和前缀的前三个相同，这样一步一步往后推，如果正好整除，说明存在一个循环节为3，重复了 $\frac{i}{i-next_i}=4$ 次

实际上由于 $next_i$ 保证是小于i的最大的，因此找到的就是最小循环节。

代码：KMP找最小循环节：

```cpp
for(int i=2,j=0;i<n;i++){
	while(j&&a[j+1]!=a[i])j=nxt[j];
	if(a[j+1]==a[i])nxt[i]=++j;
	if(nxt[i]&&i%(i-nxt[i])==0)//找到了一个循环节，do sth.
}
```

但是这道题还不太一样，这道题中我们需要找到每一个前缀是否能往后构成循环节，如何转化呢？

我们不妨记录一下每个最小循环节最多能够往后推多少次，即用一个数组 `ma[i]`，表示长度为i的前缀作为最小循环节，最多可以往后推到什么位置

那么我们用上面的代码，在do sth的位置加上一句 `ma[i-nxt[i]]=i` 即可求出（i是递增的，不用写max）

然后考虑某一个最小循环节为前缀 $P_{1,i}$ 时：（sz函数代表它可以往后复制多少次（最高幂次））

$sz(P^k)=\frac{ma_i}{i\cdot k}$

意思就是说，既然P是最小循环节，那么所有能被这个最小循环节表示的前缀（P的k次方）也一定可以往后面推几个（P的k次方的）循环节（当然也有可能只能推1次）

所以就可以直接考虑新的 $sz$，然后套用上面第二步的公式即可：

```cpp
for(int i=2,j=0;i<n;i++){//n位置要留给C，不能算
	while(j&&a[j+1]!=a[i])j=nxt[j];
	if(a[j+1]==a[i])nxt[i]=++j;
	if(nxt[i]&&i%(i-nxt[i])==0)ma[i-nxt[i]]=i;//记录ma数组
}for(int i=2;i<n;i++){
	if(ma[i]/*自身就是最小循环节*/||(nxt[i]&&i%(i-nxt[i])==0&&ma[i-nxt[i]])/*能被某个最小循环节表示*/){
		int sz=(ma[i]?ma[i]:ma[i-nxt[i]])/i,valodd=pre[i-1][sub[i+1]];//这里的sz表示当前前缀还能往后拓展多少次,valodd和valeven意义同第二步
		int valeven=sz>1?pre[i-1][sub[i*2+1]]:0;
        //第二步的公式
		ans+=(ll)(((sz-1)>>1)+1)*valodd;
		ans+=(ll)(sz>>1)*valeven;
	}else ans+=pre[i-1][sub[i+1]];//如果不能被某个最小循环节表示，那么就按照sz=1的情况来算贡献。
}
```
最终的ans就是答案了。

时间复杂度：预处理 $O(NC)$，KMP和算贡献 $O(N)$，总的时间复杂度 $O(NC)$ （C为字符集大小）
