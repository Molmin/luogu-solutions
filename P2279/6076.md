类比距离为1的题，这题应该是树形dp，但是状态可能会多一些

1、状态的设计：

f[i][0]: 表示选了自己

f[i][1]: 表示选了儿子

f[i][2]: 表示选了孙子

——上面用来表示这个点被覆盖了的状态，下面为这个点没有被覆盖的状态

f[i][3]: 表示自己不一定被覆盖，但是儿子一定全部被覆盖

f[i][4]: 表示自己和儿子都不一定被覆盖，但是孙子一定全部都被覆盖


2、状态的更新


```cpp
f[i][0] = 1+Σmin(f[j][0...4]);
f[i][1] = min( f[k][0] + Σ(j != k)min(f[j][0...3]) );
f[i][2] = min( f[k][1] + Σ(j != k)min(f[j][0...2]) );
f[i][3] = Σf[j][0...2];
f[i][4] = Σf[j][0...3];
```
3、状态的简化
上面的状态貌似已经可以搞了，但是我们发现上面有很多...，可以合并

令f[i][j] = min(f[i][0...j]) (j >= 2)

f[i][0] = 1+Σf[j][4];

f[i][1] = min( f[k][0] + Σ(j != k)f[j][3] ) 

= Σf[j][3] + min(f[k][0]-f[k][3])

          = f[i][4] + min(f[k][0]-f[k][3]);

f[i][2] = min( f[k][1] + Σ(j != k)f[j][2] ) 

= Σf[j][2] + min(f[k][1]-f[k][2])

          = f[i][3] + min(f[k][1]-f[k][2]);

f[i][3] = Σf[j][2];

f[i][4] = Σf[j][3];

最后再更新一遍，使得f[i][j] = min(f[i][0...j]) (j >= 2)

f[1][2]即为答案，O(n+m)的复杂度(貌似n为1000，邻接矩阵n^2也可通过)
