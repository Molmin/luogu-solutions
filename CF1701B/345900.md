### 题目大意

你需要找到一个排列 $p$,和一个正整数 $d$，使得排列中满足 $p_i \times d=p_{i+1}$ 的 $i$ 的个数最多。在这篇题解中，我们把 $p_i$ 和 $p_{i+1}$ 称为一个满足条件的数对。

输出此时的 $d$ 和 $p$。

### 题目总评

构造题，主要考思维，代码实现并不难。还有SPJ，好评。

### 解题方案

从简单入手。

首先假设有一个 $i$ 满足了 $p_i \times d=p_{i+1}$，还有另外一个 $j$ 并且也可以满足 $p_j\times d=p_{j+1}$。这样我们就有了2个可以满足题目要求的数对。但是我们想，能不能用这两个数对创造出更大的价值？

当 $p_{i+1}\times d=p_j$ 的时候，就会产生3个满足条件的数对！

整理一下，$p_i\times d=p_{i+1}$，$p_{i+1}\times d=p_j$，$p_j\times d=p_{j+1}$。这不就是一个等比数列吗？

此时我们易得一个有 $x$ 项的等比数列，可以产生 $x-1$ 对满足条件的数对，并且这是数字利用率最高的一种构造方法。~~一堆废话~~

当然这个等比数列的公比就是 $d$。因为我们期望这个等比数列的项数越多越好，所以要让这个 $d$ 尽量小。$d$ 为正整数，所以 $d_{min}=2$。

具体构造方法：先以 $1$ 为首项，构造公比为 $2$ 的等比数列，直到快要超过极值 $n$ 时停止。再以 $3$ 为首项($2$ 用过了)构造等比数列，同理构造到极致。再以 $5$ 为首项同理构造。再以 $7$ 为首项……切记**构造的都是公比为 $2$ 的等比数列。**

千万不要认为这里的首项就都是质数。想一下 $9$ 就明白了，在前面的构造中，$9$ 是没有用过的。所以这里的首项都是奇数，因为偶数前面都用过了。

### 代码实现

理论分析完了，看代码吧。

代码真的简单，两个循环。外层控制首项，内层算具体每一项。

**代码:**

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,t;
int main(){
	cin>>t;
	while(t--){
		cin>>n;
		cout<<2<<endl;
		for(int i=1;i<=n;i+=2)	//首项为奇数
			for(int j=i;j<=n;j*=2)	//公比为2
				cout<<j<<" ";
		cout<<endl;
	}
	return 0;
}
```

亲测能过。~~不会被Hack吧？~~