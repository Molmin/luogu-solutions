[题目传送门](https://www.luogu.com.cn/problem/CF295B)

## 题意

给出一个包含 $n$ 个点的**有向带权图**，第 $i$ 次求出图中两两相连的点的**最短路径**和，并删除点 $x_i$。

## 思路

此题推荐用 Floyd，循环 $n$ 次的 Dijkstra 和 SPFA 肯定会超时。

正向思路是按照题意每次删除点 $x_i$，但 Floyd 不支持删除点，并且这样做会很麻烦：每到一个点 $x_i$就要做一次复杂度为 $O(n^3)$ 的 Floyd，整体复杂度为 $O(n^4)$，也会超时。

所以我们逆向思考，看成每次添加一个点 $x_i$，并记录该点出现过。在计算总和时特判这些点是否出现过，记录答案。最后倒序输出。时间复杂度 $O(n^3)$。

## 代码

以下为核心代码，其余部分用注释略过。

```cpp
//输入n
//输入有向带权图
//输入数组x
for(int l=n;l>=1;l--){//循环每一个点
	int k=x[l];vis[k]=1;//标记并记录添加的点
		
	for(int i=1;i<=n;i++)//进行一次Floyd	
		for(int j=1;j<=n;j++)
			d[i][j]=min(d[i][j],d[i][k]+d[k][j]);
	   
	sum=0;
	for(int i=1;i<=n;i++)//统计最短路的和
		for(int j=1;j<=n;j++)
			if(vis[i]&&vis[j])
				sum+=d[i][j];
	ans[l]=sum;//记录答案
}
//倒序输出答案
```