# CF1625E1 - Cats on the Upgrade (easy version) 题解

## 题目大意

给定一个长度为 $n$ 的括号序列 $S$。

共有 $q$ 次询问，每次询问 $S$ 从 $l$ 到 $r$ 的字串 $T$ 的字串中中含有多少个合法括号序列，保证每个 $T$ 一定是合法的括号序列。

数据范围保证：$n,q\le3\times 10^5$。

## 思路分析

首先考虑 $S$ 本身就是一个合法括号序列的情况：

约定 $s[i]$ 是左括号时 $g[i]=0$，否则 $g[i]=1$，$ans(l,r)$ 表示查询从 $l$ 到 $r$ 的字串 $T$ 的字串中中含有多少个合法括号序列的答案。

注意到特殊性质 $T$ 一定是合法括号序列，所以只需要分析 $T$ 内部的合法括号子序列。

考虑对 $S$ 里的括号对进行分层，用 $d[i]$ 表示右括号在 $i$ 位置上的括号对嵌套了几个括号，这可以在用栈匹配的时候完成。

- $g[i]=0$ 时 $d[i]=0$。
- $g[i]=1$ 时 $d[i]=$对应左括号出栈后栈的大小。

所以我们可以把整个括号序列转成一棵树，一对括号对应一个节点，每对括号内部嵌套的就是其子节点，形成一个森林后，新建一个虚拟根节点转成树。

用 $f[i]$ 表示每个节点的兄弟节点中有多少个在其之前出现，显然这也可以在栈维护的时候顺便完成：
- $g[i]=0$ 时 $f[i]=0$。
- $g[i]=1$ 时 $f[i]=$对应左括号出栈前一位的 $f$ 值 $+1$。

以序列"（（（  ）（  ）（  ））（  ））（（  ））"为例，我们把这棵树建出来看一看（节点上的编号是右括号的位置，root是虚拟根节点）。

![](https://cdn.luogu.com.cn/upload/image_hosting/xbut7jsk.png)

此时树中的没一个节点都代表了一个合法括号序列。

然后再把对应的 $f$ 值写出来：

| i     | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   | 11   | 12   | 13   | 14   | 15   | 16   |
| ----- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| $f[i]=$ | 0    | 0    | 0    | 1    | 0    | 2    | 0    | 3    | 1    | 0    | 2    | 1    | 0    | 0    | 1    | 2    |

然后我们来看一看这和合法括号序列对数的关系，来造几组样例测试一下！
$$
\begin{cases}
ans(3,8)=6=\sum_{i=3}^8f[i]\\
ans(1,12)=10=\sum_{i=1}^{12}f[i]\\
ans(1,16)=13=\sum_{i=1}^{16}f[i]
\end{cases}
$$
好像发现了一些规律，大胆猜想一下 $ans(l,r)=\sum_{i=l}^rf[i]$

让我们来尝试证明一下这个结论：

考虑第一组样例：查询 $3\sim8$ 的答案时，考虑三个括号 $(3\sim4,5\sim6,7\sim8)$ 选还是不选，发现既不能一个都不选，也不能选分开的几个括号，所以满足条件的答案是 $\operatorname{C}_{3}^{2}+3$ 的值，相当于考虑左右端点不相同的加上左右端点相同的。

又注意到 $f[4]=1,f[6]=2,f[8]=3$

所以 $\sum_{i=3}^8f[i]=f[4]+f[6]+f[8]=1+2+3=\dfrac{2\times3}{2}+3=\operatorname{C}_{3}^{2}+3$ 并不是一个巧合。

考虑第二组样例：查询 $1\sim12$ 的答案，这好像和第一组样例没什么不同，不过是出现了括号嵌套的现象，但是同层之间的括号匹配时对更高层的括号匹配并没有关系，例如：对于合法括号序列 $2\sim9$ 和合法括号序列 $10\sim11$ 的匹配时，$2\sim9$ 内部是一定全部选上的，所以统计的 $ans(2,9)$ 对于这里并没有贡献，同理 $2\sim9$ 内部的匹配也和 $10\sim11$ 没有任何关系，所以不同层之间的合法括号序列是互不影响的（更准确的说，是某一些父节点相同的同层节点之间互不影响），所以这也是对的。

第三组样例同理，因为 root 节点没有 $f$ 值，所以没有影响，正确性同二。

所以这个结论貌似是对的！ 

然而。。。再来一组样例：

$ans(5,8)=3\ne5=\sum_{i=5}^8f[i]$

所以这个结论是错误的~~但也不完全错误~~，我们来找一下 $ans(5,8)$ 和 $ans(3,8)$ 之间的区别。

发现他们之间的区别是 $ans(3,8)$ 统计的是某一层同父亲的**所有**兄弟节点，而 $ans(5,8)$ 并不是，这个时候的答案应该是 $1+2=3$ 而不是 $2+3=5$ 所以要进行去重，$ans(5,8)$ 统计的起点应该是 $1$，而不是 $2$ 这意味着每个数都少了 $1$，所以这种情况要减去 $f[l-1]\times(f[r]-f[l-1])$。

所以我们得到了最终的答案：
$$
ans(l,r)=\sum_{i=l}^rf[i]-f[l-1]\times(f[r]-f[l-1])
$$


然后这个式子就是对的了，因为第一种情况个 $g[l-1]=0$ 也就是前面是一个左括号，$f[l-1]=0$ 对 $ans(l,r)$ 没有影响。

发现前面求和的操作可以用前缀和优化在 $\Theta(1)$ 的时间复杂度内计算。

所以总的时间复杂度是 $\Theta(n)$ 预处理，$\Theta(1)$ 回答。

然后考虑对于 $S$ 不是合法括号序列的情况，可以证明，这种情况下没有被匹配的字符一定不在 $T$ 的选择范围之内，所以直接忽略掉这些字符，正常做就可以了

## 代码呈现

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int MAXN=3e5+1;
int f[MAXN],s[MAXN];
stack <int> st; //用来匹配的括号栈 
signed main() {
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	int n,q;
	cin>>n>>q;
	for(register int i=1;i<=n;++i) {
		char ch;
		cin>>ch;
		switch(ch) {
			case '(': {
				st.push(i);
				break;
			}
			case ')': {
				if(!st.empty()) {
					f[i]=f[st.top()-1]+1;
					st.pop();
				}
				break;
			}
		}
		s[i]=s[i-1]+f[i];
	}
	while(q--) {
		int d,l,r;
		cin>>d>>l>>r;
		cout<<s[r]-s[l-1]-f[l-1]*(f[r]-f[l-1])<<'\n';
		//式子的含义题解里已经说得很清楚了 
	}
	return 0;
}
```