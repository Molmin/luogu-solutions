### 题意描述
- 有一个数列 $a$ 共 $n$ 个数，每个数为 $a_i$。
- 一开始 $c=0$，之后每次将 $c$ 加上 $a_i$，在对 $k$ 取模。如果此时 $c$ 变为了 $0$，则称在 $i$ 阶段达成了要求。
- 每一次开始时，都有一次 bomb 机会，可以跳过任意一个 $a_i$。
- 请问在给定的 $b$ 数列中，对于所有的 $b_j$ 阶段有几个达成了要求？
### 解题思路
$40$ 分做法：模拟。遍历每一个 $a_i$，将 bomb 用在该数上（当然也可以不使用 bomb）。然后暴力遍历，如果遍历到 $c=0$，则在 $b$ 数列中寻找有没有 $b_j=i$，如果有 $ans$ 就自增 $1$，最后输出 $ans$。时间复杂度 $O(n^2k)$。代码不提供。

$70$ 分做法：

方法 $1$：将 $40$ 分做法中的查找改为二分查找即可。时间复杂度变为 $O(n^2\log k)$。代码见下面参考代码的第一个代码（我考场的做法）。

方法 $2$: 由于所有的 $b_i$ 都在 $[1,n]$ 范围内，所以我们可以直接开一个数组 $p$ 表示该处是否有要求，之后就不用查找了，直接看 $p_{b_i}$ 是否为真。时间复杂度 $O(n^2)$。代码与满分代码比较相似，不提供。

满分做法：由于 $n$ 达到了 $3\times10^5$，所以考虑如何将 $O(n^2)$ 压到 $O(n)$。

观察题目可以发现：在 $i$ 处使用 bomb，只影响了 $i\in [i,n]$ 的所有的 $a_i$。

所以，我们可以先用一个前缀和 $sum$，用 $sum_i$ 表示 $a$ 数列前 $i$ 项之和。再用一个数组 $num$，用 $num_j$ 表示所有的有需求的 $sum_i$ 对 $k$ 取模后，值为 $j$ 的个数。遍历每一个 $a_i$，将 bomb 作用在该数上。

如果这是一个有需求的数，那么 $sum_i\bmod k$ 的数量就会减少 $1$。

我们用 $now$ 表示在 bomb 之前的答案贡献值。在使用炸弹后，如果此时在 bomb 之前的结果（即 $now$）加上 bomb 之后的结果大于答案，那么就把答案替换为此时的值。

接下来，如果此时 $sum_i\bmod k=0$ 且这个位置是有需求的，那么下次操作它就可以为炸弹之前做贡献，$now$ 要自增 $1$。

最后输出答案即可。

### 参考代码
$70$ 分方法 $1$：[这里自取](https://www.luogu.com.cn/record/71889996) qwq

满分代码：
```cpp
#include<bits/stdc++.h>
#define maxn 900010
using namespace std;
long long n,now,ans,m,k,b[maxn],a[maxn],sum[maxn],num[1000100];
bool p[maxn];
int main(){
	cin>>n>>m>>k;
	for(int i=1;i<=m;i++){
		cin>>b[i];
		p[b[i]]=1;
	}
	for(int i=1;i<=n;i++){
		cin>>a[i];
		sum[i]=sum[i-1]+a[i];
	}
	for(int i=1;i<=n;i++)
		if(p[i])
			num[sum[i]%k]++;
	ans=num[0];
	for(int i=1;i<=n;i++){
		if(p[i])num[sum[i]%k]--;
		if(now+num[a[i]%k]>ans)ans=now+num[a[i]%k];
		if(sum[i]%k==0&&p[i])now++;
	}
	cout<<ans<<endl;
	return 0;
}
```