一道思路比较巧妙的构造题。

思路可能和楼上大佬的方法一样，但是这里给出了蒟蒻的思考过程，希望能够帮到大家。

首先，$P$ 数组是给定的，但不一定覆盖所有的下标，所以想到针对性处理每一个 $P$ 数组的值。

我们考虑预处理部分，我们可以想到：

既然让 $a_i + b_i$ 这种合值满足题目里的大小关系的操作是上述的对 $P$ 数组每个值的针对性处理，那我们的预处理部分只需让所有和值在初期相同并使 $a$ 和 $b$ 数组满足递增 $/$ 递减的题目条件，以及使后面的操作无法影响到他们的递增 $/$ 递减关系。

很容易想到，初期两数组的值如下：


$a_i = N × i 
$

$b_i = N × (n - i + 1) 
$

其中 $N$ 为对于此题的 “无限大”。

针对性处理部分也很简单，即：每次把 $a_{p_i}$ 的值加上 $i$ 。

在这里有一个巧妙的事情，就是前面的 $P$ 值加上的下标一定小于后面 $P$ 值的下标，因为初期相同，加上的少即意味着数小，反之亦然。

在检查了一堆题目的繁琐限制之后，我们就可以愉快的开始写代码了，你会发现你轻松地过了一道蓝题。

最后贴上代码：

```
#include "bits/stdc++.h"
#define N 20010
//N 不仅是 maxn ，还是对于此题的无限大
using namespace std ;
int n , a[N] , b[N] ;
int main() {
	scanf("%d" , &n) ;//预处理
	for(int i = 1 ; i <= n ; i++) {
		a[i] = i * N ; b[i] = (n - i + 1) * N ;
	}
	for(int i = 1 ; i <= n ; i++) {
		int p ; scanf("%d" , &p) ;
		a[p] += i ;//针对处理
	}//输出
	for(int i = 1 ; i <= n ; i++) printf("%d " , a[i]) ;
	puts("") ;
	for(int i = 1 ; i <= n ; i++) printf("%d " , b[i]) ;
	return 0 ;
}
```

完结撒花~~