## 题目分析
显然，插入的数为无穷大时作用最大。同时，如果两个和为0的子区间有重叠部分，则只需要在重叠部分插入就可以使两个子区间同时满足条件。将所有和为0的子区间抽取出来单独考虑，题意即可简化为：有一些区间，如何插入最少的特殊元素，使得每个区间中都有至少一个特殊元素。

这就成了一个贪心的经典题，策略为：从左往右扫描每个区间的左端点，对于某一个暂时没有特殊元素的区间，将特殊元素插入到区间的最右端。（证明略）

但是，如果先找出这些区间再做处理，复杂度太高，考虑使用前缀和优化。从左往右扫描数组，用STL set维护左侧出现过的前缀和。对于每一个位置，如果当前位置的前缀和在set中存在，则在它们中间有一段需要处理的区间，进行计数。此时，后面的与其有重复部分的区间（即左端点在当前位置左边的区间）可以不用再考虑，于是直接将set清空。但是要注意，子区间有可能在端点处重合，这种情况不属于有重复部分，所以清空set以后还需要插入当前位置左侧一位置的前缀和。
## 代码
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
int n,ans;
ll sum,x;
set<ll> s;

int main()
{
	scanf("%d",&n); s.insert(0);
	for(int i=1;i<=n;i++)
	{
		scanf("%lld",&x); sum+=x;
		if(s.find(sum)!=s.end()) ans++,s.clear(),s.insert(sum-x);
		s.insert(sum);
	}
	printf("%d\n",ans);
	
	return 0;
}
```
前往：[Martin's Blog](https://martin-xu.com/2020/10/16/%e3%80%90%e9%a2%98%e8%a7%a3%e3%80%91cf1426d-non-zero-segments/)