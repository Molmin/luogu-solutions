这题如果思路不清晰会很混乱，我一开始就迷茫地想了十几分钟= =后来突然脑洞大开（划掉）奇思妙想（划掉）有灵感了就做了二十几分钟做出来了……调试了大半天……

核心思路：这题大体可以用t-s+1进制的思想，只不过它后面的数（个位方向）不能小于前面的数，字母序越大表示的数就越大。然后就简单多了。

/\*Jam的计数法\*/

-#include <iostream>---这个东西很难理解，没学过的人都不懂

```cpp
-#include <cstdio>-
-using namespace std;-
-int n,n1,n2,w,b[27]={0};-
-char a[27]={0},cao;-
-int main()-
-{-
-    cin>>n1>>n2>>w;-
-    for(int i=n1,o=1;i<=n2;i++,o++)a[o]=(char)(i+'a'-1);---第o位赋值为这个字母，方便之后查看
-    n=n2-n1+1;-
-    for(int i=1;i<=w;i++)---输入jam奇怪的数字
-    {-
-        cin>>cao;---输入第i位
-        for(int j=1;j<=n;j++)-
-        {-
-            if(a[j]==cao)---找这一位对应的数字
-            {-
-                b[i]=j;-
-                break;-
-            }-
-        }-
-    }-
-    for(int i=1,l=0;i<=5;i++)-
-    {-
-        b[w]++;---最后一位+1
-        l=0;-
-        if(b[1]>=n-w+1)break;---把第一位单独提出来判断，如果已经到最大了就结束
-        if(b[w]>n)---把最后一位单独提出来判断，如果满了就进位
-        {-
-            b[w-1]++;---进位
-            b[w]=b[w-1]+1;---进位后最后一位最小就是前一位+1
-            if(b[w-1]==n-1)l=w-1;---如果倒数第二位已经到顶了但不用进位，就标记，后面就别进位了
-        }-
-        for(int j=2;j<w;j++)-
-        {-
-            if(b[j]>=n-w+j&&l!=j)---原式为 n-(w-j+1)+1，这里是看哪一位需要进位了
-            {-
```
-                -
-                cout<<j<<'#';-

-                -

```cpp
-                b[j-1]++;---进位
-                for(int k=j,o=b[j-1]+1;k<=w;k++,o++)---后面的数弄成最小的
-                {-
-                    b[k]=o;-
-                }-
-                break;-
-            }-
-        }-
-        for(int j=1;j<=w;j++)cout<<a[b[j]];-
-        cout<<endl;-
-    }-
-}-
```