同是加一算法，但是有一点不同于noip2009那道“火星人”

火星人是排列，然而此题应该是组合。

先把题目变形：

从给出的s,t,w中s~t的范围内的w个不同的数，要求取出后呈升序，求出取出的前5种情况。

所以我们可以把字母看成数来操作。

输入字符串后，可以用数来代替字母。

例如a代表1，bdfij代表2 4 6 9 10.

输入转化：

for i:=1 to w do a[i]:=ord(s[i])-96;

算法：加一算法。

2 4 6 9 10

从末位开始，每次比较一下最大的位，找到一个目前不是最大的位。

例如当s=2,t=10,w=5时，最大产生的数只可能是10。

于是往前移一位，此时最大产生的只可能是9.

然后继续，最大可能是8,7，。。。2

那么这里，明显6不是，那么就把6加一，然后将后面所有的数全都按升序增加。所以第二种应该是2 4 7 8 9。

输出转化write(chr(a[i]+96));

这是第一种情况，就是有大于等于5个JAM数字的情况。但也有可能达不到，如果不判断，就会多余输出。

所以，如果没有了下一JAM数，就可以停止了。

由题意容易得到，JAM数的开头最大只能是t-w+1，此时的JAM数为：

T-W+1，T-W+2...T。是极限了。

这样就可以喽。。

参考：

输入s,t,w

t表示极限，w表示数字的长度，也就是末位。

输入第一个JAM数字；

把这个JAM数字转化为数放入a数组；

while 输出数量小于5个而且有下一个JAM数字 do

  begin

用一个变量来记录目前输出的个数；

y初始化为末位；

max初始化为极限；

找到一个非极限的位置，并在那一位+1；

 　　for i=y+1 to w do a[i]:=a[i-1]+1;//升序；

输出（字符串）

 　　writeln;

  end;
结束。

（PS：好人做到底）

找到非最大位：

（用倒推法）

max初始化为最大；

while (当前位>0)and(a[当前位]=max) do 

 begin
max减一；

找前一位；

end;