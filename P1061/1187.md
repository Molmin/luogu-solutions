本题考察排列生成的相关知识。


已知一个排列，求升序条件下这个排列的下一个排列。

为方便叙述，我们用数字代替题中的字母。

我们来看一个例子：

假设共 7 个数字，当前排列为：

12345
易得下个排列为最后一位加一，即：

12346
它的下个排列还是最后一位加一：

12347
这时，由于最后一位已经不能再加，就必须“进位”，在不考虑最后一位数字的情况下，倒数第二位加一：

1235\_
这时最后一位设为可取的最小值，即4：

12354
下一次，由于 5 不能再取，最后一位变成6：

12356
……
等到这个排列时：

12376
最后一位不能再加了，倒数第二位也不能再加了，于是忽略这两位，倒数第三位加一：

124\_\_
后面两位怎样才能最小？显然，应为可用的数中最小的两个数从小到大排列，即：

12435


至此，我们的算法已经浮出水面：

每次给排列的最后一位加一（已有的数跳过），当最后一位不能再加时，忽略最后一位，倒数第二位加一，最后一位变成可取的最小值；最后两位都不能加时，忽略倒数两位，倒数第三位加一，再将倒数两位变成最小可取两数并由小到大排列……以此类推，直到输出5个排列或整个排列无法再增加。


算法的时空复杂度均为 O(n)。
