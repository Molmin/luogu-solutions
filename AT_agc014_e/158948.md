感觉好多题解都是 $\log^2{n}$ 的算法，这里提供一种 $\log{n}$ 还特别短的小清新算法。

做法解释不多赘述，~~感觉十分显然~~，其他题解都有详细说明，这里仅简要提一下做法：

- 对于每条红边对应到蓝树上的一条路径，将其路径覆盖次数 +1。

  每次选择一条只被覆盖一次的蓝边，将覆盖它的红边的贡献消去，如果找不到这样的蓝边说明或是在消去某条红边时将其他蓝边减到 0 了则无解。
  
  这里找覆盖此蓝边的红边可以用异或简单实现。

解决这个问题有显然的树剖套线段树的 $\log^2{n}$ 做法，毒瘤且对接下来的算法没有帮助，不作考虑。

对于这种近乎裸的路径问题，可以很显然的想到 LCT，注意到除了一开始就只被覆盖了一次的蓝边，其他的蓝边都是在消去红边贡献时出现的。

设当前消去红边对应路径为 $l$，那么我们可以不断的提取出 $l$ 对应路径上覆盖次数为 1 的蓝边，将这条蓝边对应红边贡献消去后其覆盖次数就变为了 0，就可以继续在 $l$ 上提新的蓝边了。

对于每次消去红边对应路径贡献时将蓝边提完，这样就可以保证算法的正确性了。

如果这样做有亿些小细节：

- 首先是你要用 LCT 找覆盖次数为 1 的边，如果直接用最小值会找到覆盖次数 0 的边，所以要注意消去红边贡献时顺便将当前蓝边清为 inf，那么剩下的就是 LCT 板子了。

- 然后是你在消去 $l$ 这条路径后可能提出一些新的蓝边，但提一条蓝边又要消一次其红边对应路径，于是是个递归的过程，写个函数还是不难实现。

- 最后还要记得判无解。

这样已经不失为一种思路简单，代码不长(一个 LCT 板子总比树剖套线段树两个数据结构短吧)，复杂度还优秀的算法了，但我~~由于懒~~将其**进一步简化了**一下。

利用 LCT 中是 Splay 这种优秀的工具，我们一次消去红边贡献时暴力 DFS 下去找 Splay 中，也就是这条路径上的蓝边。

找到一个 Splay 一个或是找完再把它们都 Splay 上来都行，这样也就利用了 Splay 的均摊复杂度暴力地取出了所有蓝边并且时间复杂度还是正确的 $O(n\log{n})$，因为每条蓝边只会被找一次。

这样就没有什么花里胡哨的递归了，就是一个暴力 LCT(+Splay里面自带) 板子模拟最初的算法流程，这样做也就常数略大而已，但敌不过它代码简单且理论复杂度上的优势。

由于笔者毒瘤的码风代码就不放了，但这种写法是真的又短又好写。