**我感觉这题和最长公共子序列很像啊（~~大雾~~）**

这一题的状态转移方程十分好想，设序列1为s1,序列2为s2。

则直到s1的第i个，s2的第j个时，有三种方案，如下：

1.s1第i个，s2第j个均不为空，则为dp[i-1][j-1]加上第i，j个字符的相似度

2.s1第i个为空，则为dp[i][j-1]加上j字符与‘-’的相似度

3.s2第j个为空，则为dp[i-1][j]加上i字符与‘-’的相似度

## **但如果这么简单,这就是橙题了**

相似度该如何储存？

我是这么储存的，将字符写进数组中

```cpp
a['A']['A']=5,a['A']['C']=-1,a['A']['G']=-2,a['A']['T']=-1,a['A'][0]=-3;
	a['C']['A']=-1,a['C']['C']=5,a['C']['G']=-3,a['C']['T']=-2,a['C'][0]=-4;
	a['G']['A']=-2,a['G']['C']=-3,a['G']['G']=5,a['G']['T']=-2,a['G'][0]=-2;
	a['T']['A']=-1,a['T']['C']=-2,a['T']['G']=-2,a['T']['T']=5,a['T'][0]=-1;
	a[0]['A']=-3,a[0]['C']=-4,a[0]['G']=-2,a[0]['T']=-1;
```
这样的优点是查找较方便，但比较麻烦，也容易错，与楼上的储存各有优劣吧。

不多说了，献上代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
char s1[101],s2[101];
int len1,len2;
int dp[101][101];
int a[200][200];
int main()
{
	cin>>len1;
	cin>>s1;
	cin>>len2;
	cin>>s2;
	a['A']['A']=5,a['A']['C']=-1,a['A']['G']=-2,a['A']['T']=-1,a['A'][0]=-3;
	a['C']['A']=-1,a['C']['C']=5,a['C']['G']=-3,a['C']['T']=-2,a['C'][0]=-4;
	a['G']['A']=-2,a['G']['C']=-3,a['G']['G']=5,a['G']['T']=-2,a['G'][0]=-2;
	a['T']['A']=-1,a['T']['C']=-2,a['T']['G']=-2,a['T']['T']=5,a['T'][0]=-1;
	a[0]['A']=-3,a[0]['C']=-4,a[0]['G']=-2,a[0]['T']=-1;
	for(int i=1;i<=len1;i++)dp[i][0]=dp[i-1][0]+a[s1[i-1]][0];
	for(int i=1;i<=len2;i++)dp[0][i]=dp[0][i-1]+a[s2[i-1]][0];
	for(int i=1;i<=len1;i++)
		for(int j=1;j<=len2;j++)
		{
			dp[i][j]=max(max(dp[i][j-1]+a[0][s2[j-1]],dp[i-1][j]+a[s1[i-1]][0]),dp[i-1][j-1]+a[s1[i-1]][s2[j-1]]);
		}
	cout<<dp[len1][len2]<<endl;
	return 0;
}
```

## 话说这个cin和get的坑我调了一个小时才调出来

以后一定要用cin啊~


