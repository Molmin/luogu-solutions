设两人间的距离为l，相信大家都已经知道当两人分别走过l/2(或
l/2+1)时疲乏值总和最小，那我就直接拿来用了。设l=2n+1(设i为
奇数)，疲乏值总和=**(1+…n)+(1+…
n+1)=n(1+n)/2+n(1+n)/2+n+1=(n+1)^2=(l/2+1)(l/2+1)**；设i=2n(设i为偶数)，疲乏值总和=**(1+…n)+(1+…
n)=n(n+1)=(l/2)(l/2+1)**;
综上所述，我们将两式合并为:

## ((l+1)/2)*(l/2+1)
 _（注：l为偶数时(l+1)/2=l/2,l为奇数时(l+1)/2=l/2+1,故可以合并）_ 

 _以下为代码：（无敌精简版）_ 

------------

```cpp
#include<bits/stdc++.h>//万能头
using namespace std;
int main()
{int m,n;//m、n间的距离可用abs(m-n)表示
 cin>>n>>m;//读入两个人的位置
 cout<<((abs(m-n)+1)/2)*(abs(m-n)/2+1);//套用上面的公式
 //本来想用三目运算符的，为了精简就改用了abs取绝对值
 return 0;	 
}

```