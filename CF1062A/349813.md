### **读题：**  
  给你一个大小为$n$的单调上升序列，保证元素范围在$[$$1$,$10^3$$]$范围内，求最多可以删除多少个连续的元素，使得这个序列还原后唯一.   
  

------------
### **思路：**  
不就是最长上升序列吗？连数组都不用，一边读入一边处理，若这一个比前一个大，计数器加一，否则计数器清零。  


------------
### **坑点：**  
保证元素范围在$[$$1$,$10^3$$]$之间，不仅仅是数据范围，还暗含了一个条件：  
**如果 999 之后还有一个数，那么就肯定是 1000；如果 92 之前还有一个数，那么就肯定是 1**  


------------
### **解决方法：**  
 可将数列看成从$0$到$1001$,多出两位，即可。  
 

------------
### **上代码：**
```cpp
#include <bits/stdc++.h>
using namespace std;
int main()
{
    int n,x=0,y,ans=0,len=0;
    cin>>n;  
	for(int i=0;i<=n;i++)   
	{
		if(i==n)   
			y=1001;   
		else
			cin>>y;    
		if(y==x+1)     
			len++;
		else
		{
			if(len-1>ans)
				ans=len-1;
			len=0;
		}
		x=y;
	}
	if(len-1>ans)
		ans=len-1;
	cout<<ans;
    return 0;
}
```
