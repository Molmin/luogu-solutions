## 题意分析

给出n张货币和它们的面值，现在要组成金额m，问有多少种方案。

```plain
3 10
1 2 5

1+1+1+1+1+1+1+1+1+1
1+1+1+1+1+1+1+1+2
1+1+1+1+1+1+2+2
1+1+1+1+2+2+2
1+1+2+2+2+2
2+2+2+2+2
5+5
5+1+1+1+1+1
5+1+1+1+2
5+1+2+2
一共10种。
```

## 解题思路

- 由于这题每种货币有无限多张，我们很快就可以想到是“动态规划·完全背包”
- 但是近一看，这个题问的是**“多少种方案”**，跟我们平时做的“背包不超容量前提下**最大价值**”不同。
- 之前平时做的“背包不超容量前提下**最大价值**”，其$f_{i,j}$代表的是**对于前面i个物品，随便拿，不超过j背包容量所能获得的最大价值是多少。**
- 对于这个题目它要求方案数，数组元素值显然就不能存什么“最大价值”。我们可以确认f数组的元素值存的是**“方案数”**。



- 这题我们设有数组f，$f_{i,j}$代表对于前面i个物品，随便拿，**刚好达到**j背包容量的方案数为多少。

  ### 怎么弄f数组的转移方程？

  - 边界值：对于0张货币，组成金额为0的问题，方案只有1种：∅。所以$f_{0,0}=1$。
  - 怎么转移：![](https://cdn.luogu.com.cn/upload/image_hosting/5pl6ys6w.png)
  - 对于$f_{i,j}$，其转移方式有2种
    1. 第一种是“该物品不选”，则这种的方案数是$f_{i-1,j}$。
    2. 第二种是“该物品选”，则当前货币总额j应当**减去当前这张货币的面额$val_i$**；由于这里是**“每张货币有无限个”**，我们应该像图中②一样，**在$f_i$里面从下往上“叠”，这种的方案数是$f_{i,j-val_i}$，随着j从$val_i$到$m$的增加，货币也就自然完成了“从小到大”的完全背包。**
  - 所以我们两种可能列出来之后，就能列出我们的方程：
  - $f_{i,j}=f_{i-1,j}+f_{i,j-val_i}$。其中$i\in[1,n],j\in[val_i,m]$。

## 参考程序

```cpp
#include<stdio.h>
int max(int a,int b)
{
	if(a>b)
		return a;
	return b;
}
int MaxStorage,n,heavy[10005];
long long f[10005];
int main()
{
	scanf("%d%d",&n,&MaxStorage);
	for(int i=1;i<=n;i++)
		scanf("%d",&heavy[i]);
	f[0]=1; 
	for(int i=1;i<=n;i++)
		for(int j=heavy[i];j<=MaxStorage;j++)
			f[j]=f[j]+f[j-heavy[i]];
	printf("%lld",f[MaxStorage]);
	return 0;
}
```

