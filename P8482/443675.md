感觉没有这么复杂。  

## 思路

显然的，对于两个数中任意一个数，每个数位都应该从大到小排列才能使得乘积最大。  

我们根据小学二年级学过的知识，两个和一定的数，差越小积越大。  

因此，我们可以来分配每一位上应该出现的两个数，很明显，就是从大到小每次选择两个数字，至此，两数之和已经确定。  

接下来讨论一下如何分配，不妨设每一位上可选的数为 $a$ 和 $b$，答案为 $A$ 和 $B$，且有 $A>B$。  

首先，对于这一位上两者相等的情况，直接赋值即可。  
对于第一次 $a\ne b$ 的情况，因为有 $A>B$，所以大者给 $A$。  
之后的每一次 $a\ne b$ 的情况，为了 使得两者的差最小，就把大者给 $B$。  

至此，已经完成了构造。  

最后的一步处理，有一个十分暴力的做法，那就是直接输出 $1$ 和两者的乘积。  
~~然而 FFT 也救不了这样的暴力。~~  
注意到题中数据范围保证了 $1\le c_i$，那么按照上述的策略，必然会有至少一个数的末尾为 $0$，这样我们就可以直接将这个数除以 $2$，另一个乘 $2$来得到答案。  

这种方法也很好证，还是根据数据范围，$A$ 和 $B$ 的开头一定是九或者八，乘二后会多出一位，除以二后位数不变，那么多出来的一位就保证了题中的要求。  
## 代码  

基于以上思路，不难写出两种代码，一种是不断的去对每一位操作，另一种是不断的去对每种数字操作。  

前者个人亲测略卡，建议写后者（参考出题人题解）。