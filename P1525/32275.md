此题是一道很经典，而且很好的题目。思路也十分的新颖，比较的难以捉摸。而我又日常看不懂楼下大佬们的题解了……（还是我太蒟蒻了）。所以，我想在题解区中谈一谈我的思考过程，帮助大家理解一下这道好题。

首先，一看到题目，可能很多人会联想到最小生成树。但是，这一题比较的复杂，凡人之间的关系十分凌乱，不能直接用最小生成树维护。但是，虽然不能用最小生成树，但是却可以保留下一个十分重要的思想：贪心。很容易便能想到，我们要使怒气值大的一对人尽量不在同一间监狱里。也就是说，我们要优先考虑怒气值最大的两个人，然后是次大，以此类推。这一想法很容易证明，即用交换法。如果已经用此策略排好了罪犯，此时交换任意两个罪犯，都不能使状态最优。所以，只要一旦出现某两个人一定要在同一监狱时，则无需继续判断，因为它们之间的时间肯定是影响力最大的了。然后就直接跳出。

然后，我们有了这个关键的思路，便可以进一步将题目抽象画。题意用最通俗的话来说，即将一个无向图分成两个独立的点集，使两个点集中所有的边的边权的最大值的最小值是多少（然而我不会二分图染色……）。那么，基于贪心的想法，我们用什么来维护点之间的现有的关系呢？这样，自然而然就能想到并查集了。

###但是，又怎么维护呢？

因为我们维护的是两个不在一起的点的关系，我们可以用一个并查集维护一个不在一起的关系。

有人到这里便会说：这就容易了，只需要维护一个1-n的并查集，如果两数在同一个并查集，则记为他们两不在同一个集合。这样，只要两个点被判到在同一并查集，则它们必在同一个集合，即必须产生冲突，所以就直接输出了。

**但是，很多同学会发现，这样做只有60分。那为什么会错呢？我们举一个简单的栗子：**

输入：

4 4
1 2 100000

3 4 100000

1 3 2
2 4 1
显然我们可以这样安排：第一个点集：1、4；第二个点集：2、3。这样，就不会产生任何事件，输出为0（好像洛谷数据没有卡0的，但是好多题解都没有特判0……）。但是，用刚才的思路会输出1。为什么呢？让我们来模拟一下。首先，让1、2在同一并查集；然后，让3、4在同一并查集；之后，让1、3在同一并查集，此时两个并查集合并。最后，再判断2、4时，便会得到两数在同一并查集，于是就输出了1。那么，这个错误就得到一个解释了：因为2、4的距离是奇数，所以即使它们同在一个并查集集合中，它们也不一定同在一个监狱。所以，距离问题也是一个需要考虑的问题。

似乎只能暴力维护了，但是这样又很可能TLE。那怎么办呢？这时，我们就要从前一个思路所产生的错误着手了。它产生错误的原因是：不能维护两点之间的距离。那么，我们可以引入一个新的节点（或者思路）：补集。我们设置另外一个节点系统：i+n。凡是与i+n节点在同一个并查集的，都是不能与i在同一个集合里。这样，因为i+n这个节点世界上是不存在的，所以保证了每一个并查集集合中的存在的点之间的距离都是偶数。这样就保证了一旦两个点在同一个集合，则它们必须在同一个点集中。另外，注意对i+n也要压缩路径，因为有可能有两个补集节点相连，这时如果不find就会造成一大堆东西连在一起，就会MLE（具体怎么搞得我也不知道）。

然后记得数组要开2\*n，然后用一个优先队列维护一下怒气值，就搞定了。

其实代码很简单，但是思路还是很巧妙的。还有一些细节的东西（也没多少），具体请见代码：

```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#include<string>
#include<cmath>
#include<algorithm>
#include<queue>
using namespace std;
struct NODE
{
    int x,y,val;//一个状态，需要保存3个量
};
struct cmp
{
    bool operator()(const NODE& a,const NODE& b)//重载运算符
    {
        return a.val<b.val;//重载
    }
};
priority_queue<NODE,vector<NODE>,cmp>gx;//大根堆（对于val）
int bcj[100000];//并查集
int find_(int node)//并查集找根节点过程
{
    if(bcj[node]!=node)return bcj[node]=find_(bcj[node]);
    return node;
}
int main()
{
    int n,m;
    scanf("%d%d",&n,&m);
    int dr1,dr2,zhi;
    for(int i=1;i<=2*n;i++)bcj[i]=i;//初始化，记得是2*n
    while(m--)
    {
        scanf("%d%d%d",&dr1,&dr2,&zhi);
        gx.push((NODE){dr1,dr2,zhi});//加入队列
    }
    while(!gx.empty())//一直到没有冲突
    {
        if(find_(gx.top().x)==find_(gx.top().y))//如果在同一并查集内
        {
            printf("%d",gx.top().val);//直接输出
            return 0;
        }
        bcj[bcj[gx.top().x]]=bcj[find_(gx.top().y+n)];
        bcj[bcj[gx.top().y]]=bcj[find_(gx.top().x+n)];//维护新的关系，记得有两个并查集要维护
        gx.pop();
    }
    printf("%d",0);//特判0的情况
    return 0;
}
```