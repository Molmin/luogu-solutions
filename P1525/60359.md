## 题解 P1525 【关押罪犯】

题目传送门：

https://www.luogu.org/problemnew/show/P1525

附语：**真是一道好题**！！！

希望对**并查集**和**二分图匹配**想进一步了解的童鞋好好理解本题

=================================================

### 题面大意:~~（人性翻译）~~

给你m对矛盾关系,**每对关系分别涉及到x，y两人**,矛盾值为w

请你判断**分配**x和y到**两个集合**中，能否避免冲突

如**能避免**请输出0，如果**冲突不可避免**，请输出**最小的矛盾值**

以上是本人自己的“翻译”理解，接下来请看**算法分析**

=================================================

### 算法分析：

~~先来一些没用的~~~~~

本人在做本题时，注意到题目中的**两个监狱(即两个集合)**，

就很顺理成章的想到最近看到的图论问题----**二分图**，

所以本人最开始用的是**二分图判定（染色法）**A掉了本题

但是我还是太蒟了。。。在某Wang姓巨佬的指导下

("%4^89&8$^%&&*#@!$%^&~~~?')  

~~此处省去一万字大佬的话~~得知还有一种东西叫做**并查集**

（还是大佬厉害，我太蒟了= =）调试了半天，终于两种方法都过了，接下来我就讲一下这两种方法
~~（辣鸡BB结束，接下来是正题）~~



#### 1.并查集

本题，因为说了有“**边权值**”（我理解为矛盾值），所以**要求出现矛盾情况下**的**最小边权值**显然是**需要排序**的

那么问题又来了，我们要按照什么方法进行分配呢？

我们不妨这样想：两个人a，b有仇，那么把他们放在一起显然会打起来，那么我们还不如**把a与b的其他敌人放在一起**，

因为这样**可能会出现“敌人的敌人就是朋友”的情况**，**恰好a与b的其他敌人之间没有矛盾，那么他们就可以放在同一个集合中，反之b对a亦然**。

那么我们不妨这样实现：
首先需要**并查集初始化**


（1）先**把所有的矛盾关系按照矛盾值从大到小排一遍序**，

（2）接下来每次操作取出一个关系，**看矛盾的两个人x和y是否已经分配到同一个集合中**（并查集找父亲即可），那么还分如下两种情况：

如果在一起那么显然会打起来（会出现矛盾），那么**直接输出当前的边权**（矛盾值）即可（此时保证是最小矛盾值，因为已经排序了）

如果不在同一组，则**按照“敌人的敌人就是朋友”的原则**，把x与y的其他敌人分在同一组，y与x的其他敌人分在同一组

不断进行以上操作最终可以得到答案

以上是第一种dalao做法= =

#### 2.二分图判定

其实对于**二分图判定**的做法还是比较好想的，（因为我太蒻想不到并查集还要有边权）也易于实现

由于本题要求把罪犯划分到两个监狱中（我理解为划分到两个不同的集合中）那么我不禁想到图论的**二分图**

首先，抛来一个**二分图的定义**：

如果一张**无向图**的n个节点(n>=2)可以分为A,B两个集合，

且满足A ∩ B = ∅  ，而且在同一集合内的点之间都没有边相连，那么这张无向图被称为二分图，其中A和B分别叫做二分图的左部和右部

那么对于本题，我们就是要把所有人分为两个部分，其间不出现矛盾，显然很符合二分图的要求

别太高兴，问题来了：**如何判定这个“矛盾图”是不是二分图**

在这里，本人抛出一个**二分图判定定理**：


    一张无向图是二分图：
    
    当且仅当图中不存在奇环（奇环是指长度为奇数的环）


对于该定理的证明，本人就不再赘述（百度吧年轻人）

既然有了判定定理，我们就可以**使用染色法进行二分图判定**

染色法基本实现如下：

1.**大多数情况基于dfs（深度优先搜索**）
   
但本题本人用了bfs实现~~（害怕爆系统栈）~~

2.我们尝试**用黑和白两种颜色标记图中的点**，当一个节点被标记了，那么**所有与它相连的点应全部标记为相反的颜色**

如果**在标记过程中出现冲突**，那么算法结束，证明本图中存在奇环，即**本图不为二分图**；反之，如果**算法正常结束，那么证明本图是二分图**

那好啦，现在有了染色法判定二分图，那么我们还需要考虑一件事：这个**最小矛盾值**怎么求？

首先，我们考虑这样一个判定问题：是否存在一种分配方案，使得最小的矛盾值不超过mid。显然，当mid较小时可行的方案对于mid较大时依然可行。换言之，**本题的答案具有单调性**，**可以采用二分的方法求解**，**将求最小值问题转换为判定问题
**

策略如下：我们**二分答案**，设当前二分的值为mid，此时任意两个矛盾双方x和y必须被分在两个不同集合中，将罪犯们作为节点，**在矛盾值大于等于mid的罪犯之间连一条边，我们得到一张无向图**。此时我们**只需判定这张无向图是否为二分图**即可（因为要分为两部分），**如果是二分图，令二分右端点R=mid，否则令L=mid即可**

以上就是第二种思路~~~

=================================================

总结：本人做完本题之后，对比了一下两种做法，发现并查集的效率略高（也许是它有路径压缩，均摊下接近常数级别）

但二分图判定做法也毫不逊色，差不了多少，而且好实现

二者效率比较：

##### 并查集：128ms
##### 二分图判定：168ms

接下来放代码= =两个一起放了~~~

PS:代码中也有解释哦，希望能帮到大家

=================================================

做法一:并查集


    #include<iostream>
    #include<cstdio>
    #include<cmath>
    #include<algorithm>
    #include<queue>
    #include<cstring>
    using namespace std;
    typedef long long ll;
    const int inf=1e9+7;
    inline int read()
    {
        int p=0,f=1;char c=getchar();
        while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}
        while(c>='0'&&c<='9'){p=p*10+c-'0';c=getchar();}
        return f*p;}
    const int maxn=20009;
    const int maxm=200019;
    struct Edge//定义边:起点nex,终点to,边权w 
    {
	    int nex,to,w;
    }p[maxm];
    int n,m,fa[maxn],Enemy[maxn];
    //fa[i]是i的父亲(并查集),Enemy[i]是i的敌人(不能在同一组) 
    int find(int k)//并查集找父亲 
    {
	    if(fa[k]==k)return k;
	    else return fa[k]=find(fa[k]);
    }
    bool cmp(Edge x,Edge y)
    {return x.w>y.w;}
    int main()
    {
	    n=read(),m=read();
	    for(int i=1;i<=m;i++)//加边 
	        p[i].nex=read(),
		    p[i].to=read(),
		    p[i].w=read();
	    for(int i=1;i<=n;i++)
	        fa[i]=i;
	    sort(p+1,p+1+m,cmp);//按怒气值从大到小排序 
	    //接下来开始合并罪犯 
	    for(int i=1;i<=m;i++)
	        {
	    	    int t1=find(p[i].nex),t2=find(p[i].to);
	    	    if(t1==t2)//出现矛盾:直接结束 
	    	       {
			   		printf("%d",p[i].w);
			   		return 0;
			       }
			    //其余的就把敌人的敌人与自己分到一组 
	    	    if(!Enemy[p[i].nex])
	    	   	    Enemy[p[i].nex]=p[i].to;
	    	    else fa[find(Enemy[p[i].nex])]=find(p[i].to);
	    	    //同上 
			    if(!Enemy[p[i].to])
	    	   	    Enemy[p[i].to]=p[i].nex;
	    	    else fa[find(Enemy[p[i].to])]=find(p[i].nex);	   
		    }
	    printf("0");//没有矛盾
	    return 0;
    }

=================================================

做法2：二分图判定



    #include<iostream>
    #include<cstdio>
    #include<cmath>
    #include<algorithm>
    #include<queue>
    #include<cstring>
    using namespace std;
    typedef long long ll;
    const int inf=1e9+7;
    inline int read()
    {
        int p=0,f=1;char c=getchar();
        while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}
    while(c>='0'&&c<='9'){p=p*10+c-'0';c=getchar();}
        return f*p;}
    struct Edge
    {
	    int from,to,w;
    }p[200019];
    int n,m,L,R,cnt,head[200019];
    void add_edge(int x,int y,int W)
    {
	    cnt++;
	    p[cnt].from=head[x];
	    head[x]=cnt;
	    p[cnt].to=y;
	    p[cnt].w=W;
    }
    bool work(int mid)
    //判断以mid为仇恨值是否能形成二分图 
    {
	    queue <int> q;
	    int color[20009]={0};
	    //以下是染色法判断二分图 
	    for(int i=1;i<=n;i++)
	        if(!color[i]) 
	           {
	       	  q.push(i);
	       	  color[i]=1;
	             while(!q.empty())
	       		    {
	       		      int x=q.front();
	       		      q.pop();
	       		      for(int i=head[x];i;i=p[i].from)
	       		      	if(p[i].w>=mid)
							   {
	       		      	    if(!color[p[i].to])//没染过色 
	       		      	      {
	       		      	    	 q.push(p[i].to);
	       		      	    	 if(color[x]==1)
                                      color[p[i].to]=2;
	       		      	    	 else color[p[i].to]=1;
	       		      	    	 //涂上相反颜色入队 
								   }
	       		      	   else if(color[p[i].to]==color[x])
	       		      	    	   return false;
	       		      	   //如果出现矛盾直接返回(不为二分图) 
							  }
					   }
		       }
	    return true;//正常结束，证明是二分图
    }
    int main()
    {
	    n=read(),m=read();
	    for(int i=1;i<=m;i++)//加边（无向图）
	        {
	    	    int x=read(),y=read(),w=read();
	    	    R=max(R,w);//二分右端点 
	    	    add_edge(x,y,w);
	    	    add_edge(y,x,w);
		    }
	    R++;//别忘了加1（右端点R），左端点L开始为0
	    while(R>L+1)//开始二分判断二分图(答案单调) 
	          {
	      	    int mid=(L+R)>>1;
	      	    if(work(mid))
			      //染色法判断二分图如果可行就缩小范围 
	      	        R=mid;
	      	    else L=mid;
		      }
	    printf("%d",L);//最后左端点即为答案
	    return 0;
    }


好啦，到此本题就分析完了，如果有什么地方不对请各位dalao指出，或者私信我也可以

（本人代码丑，dalao们不喜勿喷）

最后推广一下我的博客：

https://www.luogu.org/blog/new2zy/

拜拜~~~感谢阅读
