[blog里食用更佳](https://www.luogu.org/blog/xzlhxc/solution-p1525)    
[题目链接（洛谷P1525）](https://www.luogu.org/problem/P1525)    
**前置芝士：[二分图（判定/染色）](https://www.luogu.org/problem/P1330)，[并查集](https://www.luogu.org/problem/P3367)**     
**觉得本题解有问题或者搞不懂的请私信或评论笔者！**

------------
```
 “听说你最近在写一篇关于P1525的题解？”管理员问我。
“是的。”我微笑道。
“这是怎样的一篇题解呢？”管理员很好奇。
“二分图判定、并查集2种做法与贪心证明。”我回答道。
“什么？几样东西混着吗？”管理员很吃惊。   
“对。”我笑了，“这是我看完题解区后作出的决定。”

--改编自《算法竞赛入门经典》前言
```

------------
## 一、题意
给你$N$个点，$M$条带权无向边，将这些点分为2个集合，使得2个集合内部边的最大边权尽可能小。如果能做到2个集合之间没有连边，输出0 。

**将点分为2个集合，答案与集合内部边有关** ------> **二分图**     
**最大边权尽可能小** ------> **二分**

我们从题目中提炼出了这2个信息，于是我们可以开始尝试：

## 二、解法
### ①二分+二分图判定
~~其实就是四分图判定（误~~    

先证明正确性：   

设$f(mid)$为当内部最大边权小于等于mid时是否有解。  
如果$f(mid)=true$，则存在一个方案使得集合内的连边都小于等于$mid$，即**集合外的连边的权值都大于$mid$**。    
当$mid_2>mid$时，集合外部的连边的权值一定大于$mid_2$，即一定大于$mid$，因此对于所有的$mid$，如果$f(mid)$满足，$f(mid_2)$一定满足。故可以二分。    

证毕。

这里给出一个二分模板
```cpp
while(L<R)
{
	bool flag=true;//是否满足条件
	mid=L+R>>1;//二分
	for(int i=1;flag&&i<=n;i++)//二分图染色
	 if(!color[i])flag=flag&&dfs(i,1);
	if(flag)R=mid;
	else L=mid+1;
	memset(color,0,sizeof(color));
}
```
**平时判断自己的二分是否会死循环，只需考虑$L=R-1$时候的情况并设置边界就可以了。**

~~完整代码？不存在的。二分图染色模板自己写……~~

### ②贪心+并查集“扩展域”
- 贪心

既然要求集合内的最大边尽可能小，那肯定要让大的边连接2个集合。   
于是就得到一个贪心策略：

**将边集按照权值从大到小排序，考虑每一条边，如果能使这条边的2个点分别在2个集合里，那么就继续，否则输出这条边的权值，结束。**     

- 证明：  

用反证法。

如果存在一个更优的方案，设贪心策略的解为$ans_1$，这个方案的解为$ans_2$。      

因为$ans_2<ans_1$所以最优解方案2个集合内部最大的权值为$ans_2$，则大于$ans_2$的边都用来连接2个集合。  

然而当贪心策略进行到$ans_1$时，已经说明不能让大于$ans_1$的边都用来连接2个集合，故最优解与题意矛盾。因此不存在更优的方案。

**证毕。**

- 实现   

那么如何判断2个点是否能在同一个集合中呢？   
其实可以参考[这道题（食物链）](https://www.luogu.org/problem/P2024)。 

用扩展域，将一个点$i$拆成$i$与$i+n$2个点，分别表示$i$在第一个集合和$i$在第二个集合。    

如果$i,j$不冲突，就合并$i,j+n$与$j,i+n$。   

如果冲突，说明如果加入这条边，**“$i$在第一个集合”与“$i$在第二个集合”这2条信息可以相互推出**，显然矛盾。所以这条边必须连在集合内部。   

因为边是从大到小排序的，当前的边如果作为答案，那么剩下的边即使全部加入同一个集合，也不会超过当前边，故答案不会改变。所以可以直接退出循环。   

如果每一条边都可以用来连接2个集合，那么就是一个二分图，集合内部可以没有边，故输出0 。   

- 注意事项
1. 并查集记得初始化，要开2倍空间（一个点拆成2个点）。 
1. 记得路径压缩（TLE警告）。

~~完整代码？不存在的。并查集模板自己写……~~

### ③贪心+带权并查集
 _带权并查集的题解真的少，这里码一发。_    
 
- 贪心 略（策略与证明同②）
- find实现   

可以参考[银河英雄传说](https://www.luogu.org/problem/P1196)    

设$g_i$表示$i$是否与父节点在同一个集合，0表示在，1表示不在。    
（由于$g_i$表示$i$与其父节点的关系，我们可以理解为它们之间的边权，故有“边带权”之说。）    

设当前节点为$x$，父节点为$fx$，祖先节点为$root$。（下面以“相同”和“不同”表示二者是否在同一个集合中）     

如果当前节点与父节点相同（$g_x=0$），那么$x$与$root$是否相同取决于$fx$与$root$是否**相同**。     
如果当前节点与父节点不同（$g_x=1$），那么$x$与$root$是否相同取决于$fx$与$root$是否**相异**。

故可以得出这样的结论：当$f_{fx}=root$时，即完成路径压缩时，有：   
$g_x=g_{x} \oplus g_{fx} $（$\oplus$表示异或操作）    

 _各位可以手动模拟一下来检验。_ 
 
所以我们可以将```int find(int x);```函数改成这样：
```cpp
int found(int x)
{
	if(f[x]==x)return x;
	int root=found(f[x]);
	g[x]^=g[f[x]];//此时g[f[x]]为fx与root的关系
	return f[x]=fa;
    //不能先赋值f[x]，再计算g[x]
    //想一想，为什么？
}
```
- merge实现   

先看图
![](https://cdn.luogu.com.cn/upload/image_hosting/607ubidg.png)    
由图可得，保证连边时$x,y$不相同，能得到$g_{ky}$的值。这样就能保证此时2个点在不同的集合内（还记得原题吗？）。

所以可以这么操作：
```cpp
bool merge(int x,int y)
{
	int kx=find(x),ky=find(y);
	if(kx==ky)return false;
    f[ky]=kx;
	g[ky]=g[x]^g[y]^1;
	return true;
}
```

至此，核心代码就写完了，接下来的判断就不难写：

如果$x$和$y$不在同一个并查集中（说明$x,y$关系尚未确定），```merge(x,y)```。    
如果$x$和$y$在同一个并查集中，且路径压缩后$g_x \ne g_y$说明$x,y$已经不在同一个集合中，不用管。     
如果$x$和$y$在同一个并查集中，且路径压缩后$g_x=g_y$说明$x,y$在同一个集合中，输出解并退出。

## 三、AC!
觉得好就点个赞呗！
