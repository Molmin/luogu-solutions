### 题意简述

给定一棵 $n$ 个节点的无根树，每条边有边权。

有 $q$ 次询问，每次询问给出 $x,y$，你需要选择 $y$ 条树上的路径，使这些路径形成一个包含 $x$ 的连通块，且连通块中包含的边权和最大。

强制在线。

- $1 \le n, q \le {10}^5$。

### 题解

可以证明：使用 $k$ 条路径就可以覆盖一棵有 $2 k$ 的叶子的树。

先以任意方式匹配叶子。如果有两条路径不相交，可以调整成相交的情况。  
不断调整就可以让任意两条路径都相交，于是显然覆盖了整棵树。  
（证明不严谨，因为没有说明调整能在有限步内结束，不过这不重要）

所以当询问 $y$ 的时候，就是要在原树中选取不超过 $2 y$ 个叶子，让这些叶子组成的极小连通块的边权和尽量大。

再考虑：每次询问中，一定存在一种方案使得直径的两端中至少有一端被选取。  
那么我们以两个直径端点为根，每次询问在两棵树中分别查询即可。

那么，现在根是一个叶子（直径端点必然是叶子），且根必选。  
也就是说，需要选其它至多 $2 y - 1$ 个叶子，打通他们到根的链，并且最大化边权和。

考虑带边权的长链剖分，发现这和选取过程是等价的，也就是贪心地选取前 $2 y - 1$ 个最长链即可。

但是选完之后不一定经过 $x$，所以需要做一下调整。

首先打通 $x$ 子树中最深的点到根的路径，然后需要去掉另一个叶子，使得减小量尽量小。

可以发现，要不然是删掉第 $2 y - 1$ 个最长链，也就是仅选取前 $2 y - 2$ 个最长链，然后把 $x$ 接上。

要不然就是在选取前 $2 y - 1$ 个最长链的基础上，先把 $x$ 接上，然后删去第一个碰到的点的其它子树。

最优解，一定符合这两种情况之一，且不会统计到错误的情况（叶子数都不超过 $2 y - 1$），所以是正确的。

时间复杂度为 $\mathcal O ((n + q) \log n)$，[评测链接](https://codeforces.com/contest/526/submission/73419392)。