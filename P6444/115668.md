无聊来刷刷**水题**。

-------------

#### 题意：
有 $n$ 组数，每组有两个数 $a_i$ 和 $b_i$ ，求最长连续的若干组数，使得这些组数中，每组数都包含着一个相同的数，输出最长连续的组数和这个相同的数。

#### 思路：

模拟就好了！！！

先看数据范围，发现 $a_i,b_i$ 很小，就 $\le 5$，于是从 $1$ 到 $5$ 枚举这个相同的数 $i$ ，每次 $O(N)$ 地寻找最长有多少组连续的数，每组数都包含 $i$ ，而题目要求 $i$ 最小，连续的组数最长，搜完一次连续的 $a_i,b_i$ 之后更新一下即可。

那如何 $O(N)$ 的寻找呢？

以样例 $2$ 为例：

输入：

```
3
3 5
4 5
1 3 
```

输出：

```
2 5
```

当我们循环到 $i=5$ 时，先从 $1$ 下标开始（这里默认初始下标为 $1$ ），找到了 $2$ 组连续而又满足条件的，分别是 $a_1=3,b_1=5$ 和 $a_2=4,b_2=5$ ，其中 $i=b_1=b_2=5$ ，这时，我们就没必要再从下标为 $2$ 的位置继续寻找，因为从 $2$ 下标找出来的答案必定小于从 $1$ 位置寻找出来的，于是就可以直接跳到 $3$ 下标了。

### 代码：
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
int n,ans1,ans2;
bool f[100005][5];
//f[i][j]表示第i组数中是否包含j，包含为true,否则为flase
int main(){
	cin>>n;
	for(int i=1,a,b;i<=n;i++){
		scanf("%d%d",&a,&b);
		f[i][a]=f[i][b]=1;//记录一下
	}
	for(int i=1;i<=5;i++){//枚举i
		for(int j=1;j<=n;j++){
			if(f[j][i]){//第i组数中包含j
				int s=0;//s统计连续的组数
				while(j<=n&&f[j][i])j++,s++;
				//开始统计，注意j<=n
				if(s>ans1)ans1=s,ans2=i;
				//这里不考虑当s最大时i最小是因为i是从小到大枚举的
			}
		}
	}
	cout<<ans1<<' '<<ans2<<endl;
	return 0;
}