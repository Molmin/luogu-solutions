
# **题意转化：**
    一条长为n的路，路上有一点m，问你在什么地方再设一点a可以使路上**任意一点**到点a的概率大于到点m的概率
    

------------


我们可以数形结合

![](https://cdn.luogu.com.cn/upload/image_hosting/uutc357u.png)


所谓概率更大，也就是说**从离点m更远的一端到点a的长度小于到点m的长度**
（因为此长度内所有的点到a的距离都小于到m的距离）

如图，在被绿色框住的范围内的点到点a的距离都小于到点m的距离，也就是所谓的**概率**，所以我们可以知道，**若被绿色盖住的范围更大，则到点a距离小于到点m距离的概率更大**

------------


## 具体做法如下

1.  因为这道题的点都是整数，所以先特判一下，当**n=1时输出1**（路的长度就为1，m<=n，所以m也只能为1，因此必不可能出现一点a使得这个端点到a的距离小于m，只能等于，此时概率为0，就愉快的输出1就好了）


1. 对于长度不是1的道路，我们做如下处理：

因为上面说了是要使**从离m更远的一端到m的距离大于到a的距离**

### 即

  我们把道路的中点mid看做一个分界点，**当m处于[0,mid]中时，a要属于(m，n]才能使端点到a的距离更小**，且当a与m的差值为1时（即**a=m+1**），才能使所谓的概率更大

同理，**当m处于[mid,n]时，a要属于[0,mid)且**a=m-1**才能使概率更大**


------------

因为长度什么的都是整数，对于除法运算有限制，所以我分奇数和偶数两种情况写（注意不要忘记考虑**m正好位于中点**的情况）

### 代码

```cpp
#include<iostream>
#include<cstdlib>
#include<cstring>
#include<cstdio>
#include<algorithm>
#define maxn 100010

using namespace std;
int n,m;
int main(){
	cin>>n>>m;
	if(n==1){cout<<1;return 0;}
	if(n%2==0&&m>n/2) cout<<m-1;
	if(n%2==0&&m<=n/2) cout<<m+1;
	if(n%2!=0&&m>=n/2+1) cout<<m-1;
	if(n%2!=0&&m<n/2+1) cout<<m+1;
	return 0;
}
```
码风丑勿喷
##### （因为排版等问题一遍审核没过，所以我准备~~写点骚话~~重新排一下版）