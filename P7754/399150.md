**观前提示：棋盘上的行、一大行都是指的 $a\cdot b\cdot c$ 的一行。一小行则是 $1\cdot c$ 的一行。**

## 思路

先初始化出 $r$ 个值表示棋盘第 $r$ 行的开头颜色，用数组 $col$ 进行存储，$col_i$ 表示棋盘第 $i$ 行的开头颜色。比如 $col_1$ 是红色，我们就存储为 $0$；比如 $col_2$ 是白色，就储存为 $1$。

然后再按照题意进行模拟即可。可以采用一次构造一小行，再循环 $a$ 次构造棋盘上的一大行，最后循环 $r$ 次构造整个棋盘。

## 代码实现

### 2.1 初始化

```
for(int i=1;i<=r;i++){
	if(i%2==1){
		col[i]=0;
	}
	else{
		col[i]=1;
	}
}
```
通过简单的找规律，我们发现第一行开头那个格子一定是红色，第二行开头那个格子一定是白色。依次类推很容易得到**如果行数 $\bmod \ 2$ 为 $1$，那么开头一定是红色。如果行数 $\bmod \ 2$ 为 $0$，那么开头一定是白色**的结论。

我们就可以按照得出的结论初始化 $col$ 数组。

### 2.2 构造棋盘

```
for(int i=1;i<=r;i++){
	for(int k=1;k<=a;k++){
		f=col[i];
		for(int j=1;j<=c*b;j++){
			if(!f){
				cout<<"X";
			}
        else{
				cout<<".";
			}
			if(j%b==0){
				f=!f;
			}
		}
		cout<<endl;
	}
}
```
用 $f$ 表示当前颜色，如果 $f=0$ 则输出`X`表示红色区域，反之若 $f=1$ 输出`.`表示白色区域。

注意在输出一小行之前要将 $f$ 初始化成 $col_i$。并且每输出完 $b$ 个字符就要将颜色反过来。

## AC Code

各部分已拆解放出。

[AC记录](https://www.luogu.com.cn/record/54646226)