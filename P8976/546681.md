**前言：** 蒟蒻第一篇题解，~~赛时调了很久终于A了，发篇题解纪念一下~~，应该思路比较与众不同吧？

**前置知识：** 

排列：一个长度为 $n$ 的排列是指在一个数列中 $1-n$ 这几个数都仅出现一次（本人语文不好，请谅解）。

举个例子，长度为 $5$ 的排列可以是：

$1\ 2\ 3\ 4\ 5$ 或 $1\ 3\ 2\ 4\ 5$ 或 $3\ 2\ 4\ 5\ 1$。

而 $1\ 2\ 4\ 2\ 5$ 就不是一个排列。

好的，相信大家对排列已经明白了（~~实际上大家肯定都明白~~）。

接下来开始分析题目：

**题目大意：**

请构造出一个排列 $p$，满足排列的前一半之和大于等于 $a$，后一半之和大于等于 $b$。

**分析：**

首先，一个长度为 $n$ 的排列，无论数字如何排列，它和一定为  $\sum\limits_{i=1}^na_i$，~~那这不是小学就学过~~它的和就是 $\frac{(1+n)\times n}{2}$ 吗？~~这不需要[解释](https://baike.baidu.com/item/%E7%AD%89%E5%B7%AE%E6%95%B0%E5%88%97%E6%B1%82%E5%92%8C%E5%85%AC%E5%BC%8F/7527418?fr=aladdin)吧~~？

那么，不就可以判断无解了吗？

即 $a+b>\sum\limits_{i=1}^na_i$，这很好理解，就是指 $a$ 与 $b$ 之和已经大于这个排列的和，那显然构造不出来，所以我们就可以愉快的输出 $-1$ 了。

但是不可以总司令！这显然是不够的,因此我们需要想想到底该如何构造。

我们不妨以这种思路来想想。

首先将 $p_i$ 就设为 $i(1\le i\le  n)$，代码如下：

```cpp
for(int i=1;i<=n;i++)p[i]=i;
```


那假如这个排列已经满足要求 (Subtask 2) 就如此，那直接输出就完事。

如果不满足要求，我们就只需要思考如何交换排列中两半中的值即可。

好的，那我们如何交换当前排列中两半左右的值呢？

我们先算出一个 $d$ 表示，在 $p_i=i$ 的情况下，排列中前一半与满足条件的 $a$ 相差多少，最开始将 $d$ 设为 $a$，然后从 $1-n/2$ 循环，每次将 $d-p_i(1\le i\le  n/2)$，代码如下：

```cpp
int d=a;
for(int i=1;i<=n/2;i++)d-=p[i];
```

- 如果 $d\le0$ 那么说明前一半本身就满足条件，只需判断后一半是否之和是否大于 $b$ 即可。

如果大于 $b$ 成功构造出一组排列，输出即可，否则输出 $-1$ 表示无解，那这里为什么不去考虑交换呢？因为当前的排列本身就是 $p_i=i(1\le i\le n/2)$ 所以前一半一定是排列中前 $n/2$ 小的数，后一半一定是排列中后 $n/2$ 大的数，所以后面的和一定是所有排列中最大的方案了，无论怎么交换，只会使得后面的和变小，因此，肯定无解。

- 如果 $d>0$ 就说明需要交换左右两边的元素，让大的变小，小的变大，直至满足要求。

那么考虑如何实现这一过程？

首先两边交换的最大值一定为 $p_n-p_1$ 对吧，第二大值一定为  $p_{n-1}-p_2$ 对吧。

那我们考虑贪心策略。每次如果 $d$ 大于 $p_{n-k+1}-p_k$，那 $d$ 就减去它，并交换 $p_{n-k+1}$ 和 $p_k$，直到 $d$ 减去 $p_{n-k+1}-p_k$ 小于 $0$ 为止，$d$ 减去 $p_{n-k+1}-p_k$ 小于 $0$ 后，我们就考虑如何交换剩下位置中左右两边差为 $d-p_{n-k+1}-p_k$ 的值，那如何快速交换呢？我们定义一个 $len$ 表示第 $k$ 次后结束，左右两个区间剩下的长度。


上面这段话的意思就如下图所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/bcplh9vh.png)

- 如果 $d \ge len \times 2$ 说明无论怎么交换都无法满足要求，输出 $-1$，无解。

- 如果 $d>len$ 那就可以交换第 $cnt$ 和 $cnt+d$ 位满足要求，因为第 $cnt$ 位和第 $cnt+d$ 位正好可以使得 $d$ 减少 $d$，使得 $d$ 正好满足要求。

- 如果 $d \le len$ 那就可以交换 $p_{n/2}$ 和 $p_{n/2+d}$，如上图中交换第 $3$ 位和第 $4$ 位可以满足要求，交换后排列就为 $6\ 2\ 4\ 3\ 5\ 1$ 满足要求，之所以这样做也是让 $d$ 减去 $d$ 正好等于 $a$ 但是因为 $d\le len$，因此第二条操作就不行了。

记得开 ```long long```！


所以，综上代码如下：

```cpp
#include <bits/stdc++.h>
#define int long long//#define int long long qwq!
using namespace std;
int T,n,p[100005],a,b;
signed main(){ //#define int long long过后主函数改成signed
	scanf("%lld",&T);  //T组测试数据 
	while(T--){
		scanf("%lld%lld%lld",&n,&a,&b); //读入 
		for(int i=1;i<=n;i++)p[i]=i; //初始化排列 
		int d=a; //将d设为a 
		for(int i=1;i<=n/2;i++)d-=p[i]; //每次将d-p[i]算出与a相差多少 
		int cnt=1; //第cnt位 
		while(d>0&&cnt<=n/2){ //贪心的每次减去当前最大值 
			if(d-(p[n-cnt+1]-p[cnt])<=0)break; //如果减去已经小于等于0就退出 
			d-=(p[n-cnt+1]-p[cnt]);
			swap(p[cnt],p[n-cnt+1]); //交换cnt位与n-cnt+1为 
			cnt++;
		}
		int len=n/2-cnt+1;
		if(len*2<=d){
			printf("-1\n");//无法满足要求 
			continue;
		}
		if(d>len)swap(p[cnt],p[cnt+d]); //交换cnt与cnt+d 
		if(d<=len&&d>0)swap(p[n/2],p[n/2+d]);//交换n/2与n/2+d
		int tmp1=0;
		for(int i=n/2+1;i<=n;i++)tmp1+=p[i];//算后一半是否满足要求 
		if(tmp1>=b)for(int i=1;i<=n;i++)printf("%lld ",p[i]);//找到合法解，输出 
		else printf("-1");//后一半无法满足要求 
		printf("\n");
	}
    return 0;
}
```


