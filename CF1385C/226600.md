咱们试试看

```data
4 3 3 8 4 5 2
```

那么删掉前面 4 个数 `4 3 3 8` 就能使后面的 `4 5 2` 成立，因为通过上面那个操作能把 `4 5 2` 变成 `2 4 5` 。

左面的是原来的序列，右面的是新产生的数列。

```
[4 5 2] / []
[4 5] / [2]
[5] / [2 4]
[] / [2 4 5]
```

`2 4 5` 就是~~什么~~Good数列。

其实可以把像 `4 5 2` 这样的数列想象成 $4<=5>=2$ 即 $a_1<=...<=a_{i-1}<=a_{i}>=a_{i+1}>=...>=a_n$

所以这题用~~模拟~~指针的方法去做比较容易。

因为这个题要从前面往后面删除数，所以应该从后面开始算。

先用一个循环去算 $a_i$ 到 $a_n$ 之间，然后再用一个循环去算 $a_i$ 到 $a_{del}$ 之间（这里的 $del$ 代指的是要删除的位置后一个位置）

所以这两个循环就是这样的

```cpp
while (n > 1 && a[n - 1] >= a[n]) -- n;
while (n > 1 && a[n - 1] <= a[n]) -- n;
```

上面说的 $del$ 其实就是现在这两个 `while` 之后算出来的 $n$ 。

Code

```cpp
#include <iostream>
#include <cstdio>
using namespace std;
int t, n, a[200005];
int main ()
{
	scanf ("%d", &t);
	while (t --)
	{
		scanf ("%d", &n);
		for (int i = 1; i <= n; i ++)
			scanf ("%d", &a[i]);
		while (n > 1 && a[n - 1] >= a[n]) -- n;
		while (n > 1 && a[n - 1] <= a[n]) -- n;
		printf ("%d\n", n - 1);
	}
	return 0;
}
```