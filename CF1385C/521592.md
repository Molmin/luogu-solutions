### 简化版题意：
>有一个数列 $A$，请求出最小的 $x$，去掉 $A$ 的前 $x$ 个元素，能每次去掉 $A$ 的首项或末项，放在一开始为空的数列 $B$ 的末尾，使 $B$ 成为不降数列。
### 分析：
既然要成为不降序列，那么一定得先去掉小的，后去掉大的。那这个 $A$ 数列的元素一定是前后小，越往中间越大（也可能没有前或后）。

突然明白过来，这不就是**双调序列**吗？又由于是去掉前面的元素，所以这个双调序列就是 $A$ 的后缀。

所以，题目就变为了：

>有一个数列 $A$，它的长度为 $l$，请求出最小的 $x$，使 $A$ 的长为 $l-x$ 的后缀是双调序列。

那么，我们只需把这个双调序列的长求出来，就可以求出 $x$ 了。

具体实现细节看代码吧。
### Code(C++):
```c++
#include <bits/stdc++.h>
using namespace std;
int a[200005]；
int main(){
	int t，n;
	scanf("%d",&t);
	a[0]=1e9;
	for(int ii=0;ii<t;ii++){
		scanf("%d",&n);
		for(int i=1;i<=n;i++)scanf("%d",a+i);
		while(a[n]!=1e9&&a[--n]>=a[n+1])；//求出双调序列的波峰
		while(a[n]!=1e9&&a[--n]<=a[n+1])；//求出双调序列的开头
		printf("%d\n",n);
	}
	return 0;
}
```
[我已成功！](https://www.luogu.com.cn/record/66921275)