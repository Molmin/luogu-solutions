## 思路:
题目要求我们求出可能的可重集个数，我们可以先将这个大小为 $k$ 的可重集转化为长度为 $k$ 的不降序
列，满足第一个数大于 0，不存在 $m$ 个相同且连续的数。这个可以暴力 $\operatorname{dp}$ 做。记 $f[i][j][k][h]$ 表示确定了可重集中的前 $i$ 个数，当前数的和为 $j$，第 $i$ 个位置的数是 $g$，$g$ 这个数已经连续出现 $h$ 次，暴力转移是 $O(n^5)$ 的。

发现上面的 $\operatorname{dp}$ 不好优化，考虑优化 $\operatorname{dp}$ 状态设计。有一个套路，对于不降序列，我们可以差分，从而将不降序列转化为任意序列。我们令原来的序列为 $A$，新序列为 $B$，且 $B_1$ 和 $A_1$相等，$B_i$ 和 $A_{i+1}-A_i$ 相等，即 $B$ 为 $A$ 的差分数组，因为差分数组和原不降序列一一对应，所以问题转化为，对于一个大小为 $k$ 的序列，计算满足 $\sum_{i = 1}^k (k-i+1)B_i=n,B_1>0$ 且不存在连续的 $m$ 个 0 的可能的序列个数。

这样也不好做，考虑将差分数组倒过来与原不降序列也是一一对应的，转化为计算满足 $\sum_{i = 1}^k iB_i=b,b_k>0$ 且不存在连续的 $m$ 个 0 的序列的个数。

这个显然比较好做了，记 $f[i][j]$ 表示确定了倒过来的差分数组中的前 $i$ 个数，前 $i$ 个数加权求和的和为 $j$ 且 $B_i>0$ 的方案数，转移的话，枚举上一个不为 0 的位置 $k$，然后枚举 $B_i$ 的值，直接转移的复杂度是 $O(n^2log(n))$ 的。
## Code:
```cpp
#include<bits/stdc++.h>
#define int long long
#define M 998244353
using namespace std;
int n,m,dp[5005][5005],sum[5005][5005];
signed main(){
	cin>>n>>m;
	dp[0][0]=sum[0][0]=1;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			for(int g=1;g<=(j/i);g++){
				dp[i][j]=(dp[i][j]+sum[i-1][j-g*i])%M;
				if(i>m) dp[i][j]=(dp[i][j]-sum[i-m-1][j-g*i]+M)%M;
			}
			sum[i][j]=(sum[i-1][j]+dp[i][j])%M;
		}
		sum[i][0]=1;
	}
	for(int i=1;i<=n;i++) cout<<dp[i][n]<<"\n";
	return 0;
}
```


