#### 要求出最高和最低奶牛之间的身高差，自然就要知道最高和最低奶牛的身高，直接的想法就是贪心暴力，直接搜一遍区间，但这样很明显就会超时，那我们就想一想如何先将每一个区间内的奶牛身高最高和最低求出来，每次询问直接调用就好，这样我们就很容易想到要用到RMQ这个神奇的东西（我觉得每个算法都好神奇、、-_-|||）。
### RMQ（Range Minimum/Maximum Query），即区间最值查询，是指这样一个问题：对于长度为n的数列A，回答若干次询问RMQ(i,j)，返回数列A中下标在区间[i,j]中的最小/大值。RMQ就要用到ST算法这个也很神奇的算法
## ST（Sparse Table）算法可以在O(nlogn)时间内进行预处理，然后在O(1)时间内回答每个查询。
这个题分为两个部分，第一部分是预处理，（重点在这哈）要用到ST算法哈
设A[i]是要求区间最值的数列，F[i, j]表示从第i个数起连续2^j个数中的最大值。
###### 例如
##### A数列为：3 2 4 5 6 8 1 2 9 7
F[1，0]表示第1个数起，长度为2^0=1的最大值，其实就是3这个数。
同理 F[1,1] = max(3,2) = 3, F[1，2]=max(3,2,4,5) = 5，F[1，3] = max(3,2,4,5,6,8,1,2) = 8;
###### 并且我们可以容易的看出F[i,0]就等于A[i]。
##### 我们把F[i，j]平均分成两段（因为F[i，j]一定是偶数个数字），从 i 到i + 2 ^ (j - 1) - 1为一段，i + 2 ^ (j - 1)到i + 2 ^ j - 1为一段(长度都为2 ^ (j - 1))。于是我们得到了状态转移方程F[i, j]=max（F[i，j-1], F[i + 2^(j-1)，j-1]）。
第二部分是查询这就很随意而简单啦一般都是根据题目自己变的。。
大致的RMQ就这样具体的自己找度娘或是个随便什么网站一查就知道了，，
下面来看看这题
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cstdlib>
#include<cmath>
#include<algorithm>
 using namespace std;
const int M=50005,N=50;
int f1[M][N],f2[M][N],x;//因为是求最大和最小值所以有两个f数组
int n,q;
int main(){
	scanf("%d%d",&n,&q);
	for(int i=1;i<=n;i++){
	    scanf("%d",&x);//我直接省掉了A数组。凑个或者看吧╮(╯▽╰)╭反正内容都一样把X当做A就好啦
	    f1[i][0]=f2[i][0]=x;//初始化，从i头奶长度为2^0的区间也就是自己。
	}
	for(int j=1;1<<j<=n;j++)//枚举2的j次方
	    for(int i=1;i+(1<<j)-1<=n;i++){//枚举起点
	        f1[i][j]=max(f1[i][j-1],f1[i+(1<<j-1)][j-1]);//从i开始长度为2^j的区间最大值。（2^j=2^(j-1)+2^(j-1)这个简单的东西就可以解释f1[i+(1<<j-1)][j-1]了。                                            
	        f2[i][j]=min(f2[i][j-1],f2[i+(1<<j-1)][j-1]);//与上面同理
	    }
	while(q--){
		int a,b,k,m1,m2;
		scanf("%d%d",&a,&b);
		k=log2(b-a+1);//求出区间内a最多加多少2次方（2^j中j的最大值）
		m1=max(f1[a][k],f1[b-(1<<k)+1][k]);//区间分为a到2^K和b-2^K+1到b两部分
		m2=min(f2[a][k],f2[b-(1<<k)+1][k]);
		printf("%d\n",m1-m2);
	}
	return 0;
}

```