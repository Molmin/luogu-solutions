~~好奇为啥标签没ST表~~

这题让我们求某个区间的最大，最小值的差值

看到数据范围，就知道用O(nlogn)复杂度的算法过
# 一看就知道用ST表写
不用想太复杂QWQ

如果你理解了ST表模板并A了，把模板改一下，加个最大值，就行了QWQ~~伪双倍经验~~

如果不知道ST表QWQ，我科普一下，如果想进一步了解，可以去做ST模板

ST表是专门用来求多个区间的最大，最小值，用的是倍增的思想，类似于动规

先用O(nlogn)和一个~~动规~~方程进行处理数组

之后在O(1)调用出每个区间的最大，最小值QWQ

在求完全不定区间的最值上，优于单调队列

是不是一个很神奇的算法，而且代码量不多，求一个最值只要写6行

# 重点是速度超快的QWQ

## 一共只用了316ms

下面上代码，只有28行，蒟蒻~~懒人~~福利QWQ
```
#include<bits/stdc++.h>
using namespace std;
int lxy[180010][22],hrb[180010][21],n,m,i,j,k,l,r;
//lxy数组用于求最大值，hrb数组用于求最小值
int ST(int l,int r)//O(1)调用QWQ
{
    int s=log2(r-l+1),x,y;
    //log2(r-l+1)是以2为底的对数，写成等式就是，2的log2(r-l+1)次方等于(r-l+1);
    x=max(lxy[l][s],lxy[r-(1<<s)+1][s]);//区间最大
    y=min(hrb[l][s],hrb[r-(1<<s)+1][s]);//区间最小
    //神奇的冻柜方程QWQ，记下来就好，反正不长
    return x-y;//返回差值
}
int main()
{
    scanf("%d%d",&n,&m);//输入
    for(i=1;i<=n;i++)
    scanf("%d",&lxy[i][0]),hrb[i][0]=lxy[i][0];//因为要用两个数组QWQ
	for(i=1;i<=21;i++)//这个循环的上界决定于数据的大小，即2的21次方大于数据，如果数据在大上界调高，logn是这个循环QWQ
	for(k=1;k+(1<<i)<=n+1;k++)//接进于n，算成n，其实没那么大
	{
		lxy[k][i]=max(lxy[k][i-1],lxy[k+(1<<(i-1))][i-1]);
		hrb[k][i]=min(hrb[k][i-1],hrb[k+(1<<(i-1))][i-1]);
        //神奇冻柜方程处理QWQ，不理解，也可以下来，只有4行
	}
	for(i=1;i<=m;i++)//O(1)调用开始
	{
		scanf("%d%d",&l,&r);
		printf("%d\n",ST(l,r));//上面的函数，直接输出返回值
	}
	return 0;//结束
}
```
是不是很神奇的算法，只要28行就可以切一道蓝题，是不是很开心

而且短，少，快。。。

实在是蒟蒻必备算法QWQ

很容易就学会了

如果想进一步了解ST表的，可以在洛谷找模板题

~~偷偷说一句其实ST表的很多题目是多倍经验QWQ~~

如果你认可我的思路话

# 请点赞，关注，~~投食，素质三连~~，谢谢支持QWQ

~~不可以拒绝的拥抱~~