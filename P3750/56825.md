
# 50分部分分入手

~~其实有80分~~

首先考虑$k=n$的部分分

- 倒着扫，遇到有$1$的位置就操作一下

正确性：

- 一个点不会被操作$2$次以上，因为$2$次操作相当于没操作

- 操作$i$不会影响到比$i$大的数
- 所以从后往前扫，若遇到$1$不操作，那么前面的操作也不会改变这个$1$，所以必须操作

# 正解

首先若最小步数小于等于$k$，直接输出$ans\cdot n!$就好了

问题在于最小步数大于$k$的情况

容易发现上面那个操作序列是固定的

用一个$01$序列表示每个点需不需要操作（例子：$101100$表示$1,3,4$需要被操作）

然后容易发现最优的操作次数即为这个序列中$1$的个数，也就是说和序列长什么样子无关，只关心有多少个$1$

所以考虑设$f[i]$表示序列中有$i$个$1$的期望操作次数

- 如果乱选选到了$0$，$1$的个数会多一个
- 如果乱选选到了$1$，$1$的个数会少一个
- 所以有：$f[i]=\frac inf[i-1]+\frac{n-i}nf[i+1]+1$

然后是玄学推式子

- 注意到$f[n]=f[n-1]+1$，我们把它作为边界条件
- $f[n-1]=\frac{n-1}n f[n-2]+\frac1n f[n]+1$
- 将第一个式子带入
- $f[n-1]=\frac{n-1}n f[n-2]+\frac1n f[n-1]+\frac{n+1}n$
- 移项后处理一下系数得到：
- $f[n-1]=f[n-2]+\frac{n+1}{n-1}$

发现这个东西长成这个样子$f[n]=f[n-1]+$常数，$f[n-1]=f[n-2]$+常数

然后大胆猜想~~不需要求证~~，加的这个常数(设为$g[i]$)可以递推出来

- $f[i-1]=\frac{i-1}n f[i-2]+\frac{n-i+1}n f[i]+1$
- 因为我们猜想$f[i]=f[i-1]+g[i]$，将它带入
- $f[i-1]=\frac{i-1}n f[i-2]+\frac{n-i+1}n f[i-1]+\frac{n-i+1}ng[i]+1$
- 移项后处理一下系数：
- $f[i-1]=f[i-2]+\frac{n-i+1}{i-1}g[i]+\frac n{i-1}$
- 所以有：$g[i-1]=\frac{(n-i+1)g[i]+n}{i-1}$
- 换个样子：$g[i]=\frac{(n-i)g[i+1]+n}i$

然后$g[i]$就可以倒着递推出来了

接着$f[i]$也可以正着递推出来
# dp式子总结


- $f[k]=k$
- $f[i]=f[i-1]+g[i]$
- $g[n]=1$
- $g[i]=\frac{(n-i)g[i+1]+n}i$
- $ans=f[min\_step]\cdot n!$（$min\_step$指的是原序列最小操作次数）

