### 首先考虑最优策略怎么做：

- 从大往小贪心显然是正确的，因为最大的数不会被小数影响，所以先消除最大的，再依次往小的消除。
- 现在的问题就在于快速枚举一个数的约数，这个可以先枚举一个数的倍数，然后加在对应数的$vector$里面，最后只要查找就可以了。
- 这个复杂度是调和级数，为$nlogn$。

### 考虑随机怎么做。
- 我们发现当前局面是什么对随机都是没有影响的，就是不管你这个局面是什么样，如果他的最优策略是$n$步，那么他就和其他$n$步的局面没有区别。
- 因为操作的策略是唯一确定的，所以我们不需要考虑局面究竟是什么样子，只需要知道这个局面的步数就行了。
- 设$f_i$表示到第$i$步，转移到$i-1$步的期望步数是多少，有:
#### $$f_i=1+\frac {n-i}{n}*(f_{i+1}+f_i)$$
- 如果操作在最优的$i$步中，就可以了，否则还要回到这一步，再走到上一步。
- 因为操作顺序是不影响答案的，所以我们认为只要在这$i$步里面，都是满足要求的步骤，否则就是不合法的步骤。
- 化简一下
#### $$f_i=(n+(n-i)*f_{i+1})*inv(i)$$
- 线性求逆元后递推即可，注意$f_n=1$。