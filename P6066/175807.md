（**不需要欧拉回路相关知识**）

[题目传送门](https://www.luogu.com.cn/problem/P6066)

#### 前置知识：

链式前向星。

生成树（只需了解定义即可）。

#### 题意：

- 给出一张 $n$ 个点 $m$ 条边的无向图，问是否可以找到一条从 $1$ 出发最后回到 $1$ 的路径，每条边经过两次，并且两次经过的方向相反。

- 保证存在至少一条这样的路径，$n\le10^4$，$m\le5\times10^4$。

#### 分析：

（不与任何边相连的点在该题中无作用，故不考虑。此时图一定连通。）

我们先考虑特殊情况，图退化成一棵树。

这种情况比较显然，只需要 dfs 一遍，按照遍历的顺序输出即可。

接下来考虑图的情况。

先求出这张图的任意一棵生成树。由于图连通，生成树一定存在。对于这棵树上的边，直接像树的情形一样遍历。

![](https://z3.ax1x.com/2021/11/10/Ia1Pqs.png)

考虑其他不在树上的边 $(u,v)$。可以在遍历 $u$ 的时候沿着 $(u,v)$ 走一次，沿着 $(v,u)$ 走回来，然后继续遍历 $u$。

这样，生成树上的边一定被经过两遍；而所有不在生成树上的边的两个节点都会被遍历到，只需在遍历到的时候按照上述方法即可经过两遍。故可以得到一条合法路径。

![](https://z3.ax1x.com/2021/11/10/Ia1Crj.png)

#### 思路：

1. 通过 dfs 来求任意一棵生成树。

2. 在 dfs 求生成树的同时对所有非生成树边进行上述操作。

---

#### 实现细节：

实际写代码时，只需要进行一次 dfs，并不需要区分树边与非树边。

由于只需要求出任意一棵生成树，所以当遍历到 $u$，枚举所有与 $u$ 相连的边 $(u,v)$ 时，只要 $v$ 未被遍历过，就将 $(u,v)$ 看做生成树边，对 $v$ 进行 dfs；反之，若 $v$ 被遍历过，就将 $(u,v)$ 看做非树边。

显然，按照上述方法遍历，所有边都会被遍历到，可以得到合法路径。

另外，上述 dfs 的深度最多是 $\mathcal O(n)$ 的，故不需要手写栈，直接递归即可。

---

```cpp
#include <bits/stdc++.h>
using namespace std;
const int mN=1e4+9, mM=5e4+9;
int n, m;
int oe=1, head[mN], nxt[mM<<1], ver[mM<<1];
bool used[mM];  //边是否被遍历过
inline void add(int x, int y) {nxt[++oe]=head[x], ver[oe]=y, head[x]=oe;}

bool vis[mN];   //点是否被遍历过
void dfs(int x) {
	printf("%d\n", x), vis[x]=1;    //第一次遍历到点 x，标记并且输出路径
	for(int t=head[x]; t; t=nxt[t]) if(!used[t>>1]) {
		used[t>>1]=1;
		if(!vis[ver[t]]) dfs(ver[t]), printf("%d\n", x);  //点未被遍历过，是树边，去 dfs 另一个点
		else printf("%d\n%d\n", ver[t], x); //点被遍历过，是非树边，去一次再回来
	}
}

int main() {
    scanf("%d%d", &n, &m);
	while(m--) {
		int u, v;
		scanf("%d%d", &u, &v);
		add(u, v), add(v, u);
	}
	dfs(1);
	return 0;
}
```