### $m=1$

首先，对于一个固定的数组，我们来分析它去掉每一个数后，前缀最大值个数的变化。

设 $k$ 为该数组原先的前缀最大值个数。那么去掉一个数后，

1.  若其原先不是前缀最大值，则前缀最大值个数不变，仍为 $k$。
2.  若其原先是前缀最大值，则前缀最大值个数先减 1，然后其后有一些本不是前缀最大值上的数将变为前缀最大值，因此还会加上一些数，因此前缀最大值个数变为 $[k-1,n]$ 的某个数。



接下来，为了解决计数问题，我们先解决构造问题——对于数组 $a$，若是否存在 $p$ 与其对应，则称这些 $a$ 为合法的。我们对于合法的 $a$，我们先构造一个 $p$。

首先，我们需要确定 $k$，但这并不方便直接求出，所以我们就假设我们已经知道 $k$ 了。可以证明一个合法数组 $a$ 唯一对应了一个 $k$，因此我们加的这一个条件不影响我们计数。

接下来，我们开始尝试构造一个 $p$ 与 $a$ 对应。我们将整个过程分为三步：

1.  考虑那些不等于 $k$ 的位置 $i$。若其小于 $k-1$ 是无解的，否则设其为 $x$，且 $x-(k-1)=y$。这就要求去掉此位置之后， 有至少 $y$ 个位置会成为新的前缀最大值。为了方便唯一对应，我们就钦定 $i$ 后面的 $y$ 个位置是备用最大值 $(\star )$。
2.  设在第一步中，我们确定了 $w$ 个位置是前缀最大值，那么还需要钦定 $k-w$ 个等于 $k$ 的位置为前缀最大值。对于这些位置，去掉他们会有 $1$ 个位置成为新的前缀最大值。也就是说，这些位置后面必须跟着一个非前缀最大值的 $k$。为了方便唯一对应，我们就从前往后扫，每次遇到两个连续的未在第一步中被钦定的数，我们就钦定前一个是前缀最大值，后一个是备用最大值。
3.  对于那些既不是前缀最大值，又不是备用最大值的数，就称为垃圾。

我们将前缀最大值染成红色，备用最大值染上绿色，垃圾染上黄色。这样，我们就将一个 $a$ 序列唯一对应到了一个颜色序列。颜色序列拥有好的性质：

1.  一个颜色序列唯一对应了一个 $a$ 序列。
2.  对于任意一个颜色序列，都存在排列 $p$ 与之对应。

前者的正确性比较自然，直接根据颜色序列算 $a$ 序列就好。对于后者，我们采取以下的插入构造法得到一个 $p$。

![](https://cdn.luogu.com.cn/upload/image_hosting/kahg2dg3.png)


稍微解释一下，绿色位置的值大于上上个红色，小于上个红色，升序排列；黄色位置的值小于上上个红色位置，或者小于上个绿色位置。这样一定是可以构造出来的。



那么现在，我们只需要对颜色序列计数就可以了。我们再来回忆一下先前的构造中隐含的要求，并非所有红黄绿组成的序列都是我们说的颜色序列。颜色序列的要求有哪些呢？

1.  绿色（备用最大值）仅应该紧跟着红色（前缀最大值），这是为了满足 $(\star )$。
2.  “红绿X”段应该尽可能靠前，其中  X 是任意一个非绿的颜色，即“红绿X”不能出现在“黄黄”之后（否则可以把后面的红绿与前面的黄黄交换位置，不满足红绿考前的要求）。“黄红绿X”也不应该出现（因为它可以换成“红绿黄X”）。
3.  第一个数一定是红色，第二个数一定不是黄色。后者是因为，去掉第一个数后，第二个数一定成为前缀最大值。

据此，我们就可以根据这三个条件，开始设计关于颜色序列计数的 dp 了。



接下来，我们开始设计状态。考察我们需要记录哪些信息：

1.  前一个是什么颜色。
2.  前面是否有“黄黄”。
3.  这一段绿色段是 0、1 还是大于等于 2。
4.  这一段绿色前面的红色是否在黄色后面。

你可以就根据这四个写，也可以参考这个压缩后的状态：

![img](https://cdn.luogu.com.cn/upload/image_hosting/rshc1xwz.png)

转移略，建议待会直接看我代码。

### $m>1$ 

只需要额外记录两个信息：

1.  当前红色的个数。
2.  是否有不接绿色的红色。

对于条件 2，我是直接跑了两遍，第二遍跑的时候强制不在红色后面跟红色和黄色。这样方便，合在一起写起来比较逆天。最后所有数大于等于 $m$ 就是要求此值大于等于 $m$：$红色的个数-[存在不接绿色的红色]$。

```cpp
#include<bits/stdc++.h>
#define int long long
const int N=3050;
using namespace std;

int n,m;
const int mod=1e9+7;
int f[N][11],G[N][11];
int res[N];

void solve(){
	int i;cin>>i;
	cout<<res[i]<<endl;
}

main(){
	ios::sync_with_stdio(false);
	cin>>n>>m;
	f[2][0]=1,f[1][1]=1;
	int res=0;
	for(int i=2;i<=n;i++){
		memcpy(G,f,sizeof(G));
		memset(f,0,sizeof(f));
		for(int j=0;j<=n;j++){
			auto g=G[j];
			f[j+1][0]=(g[0]+g[1]+g[2]+g[8]+g[10])%mod;
			f[j][1]=g[0];
			f[j][2]=(g[1]+g[2])%mod;
			f[j][3]=(g[0]+g[1]+g[2]+g[8]+g[10])%mod;
			f[j][4]=(g[3]+g[4]+g[5]+g[7])%mod;
			f[j+1][5]=(g[4]+g[5]+g[7])%mod;
			f[j][6]=g[5];
			f[j][7]=(g[6]+g[7])%mod;
			f[j+1][8]=g[3];
			f[j][9]=g[8];
			f[j][10]=(g[9]+g[10])%mod;
		}
	}
	for(int i=m+2;i<=n+1;i++)
		res+=(f[i][0]+f[i][5]+f[i][8]);
	memset(f,0,sizeof(f));
	f[1][1]=1;
	for(int i=2;i<n;i++){
		memcpy(G,f,sizeof(G));
		memset(f,0,sizeof(f));
		for(int j=0;j<=n;j++){
			auto g=G[j];
			f[j+1][0]=(g[1]+g[2]+g[10])%mod;
			f[j][1]=g[0];
			f[j][2]=(g[1]+g[2])%mod;
			f[j][3]=(g[1]+g[2]+g[10])%mod;
			f[j][4]=(g[3]+g[4]+g[7])%mod;
			f[j+1][5]=(g[4]+g[7])%mod;
			f[j][6]=g[5];
			f[j][7]=(g[6]+g[7])%mod;
			f[j+1][8]=g[3];
			f[j][9]=g[8];
			f[j][10]=(g[9]+g[10])%mod;
		}
	}
	res+=(f[m][1]+f[m][2]+f[m][3]+f[m][4]+f[m][7]+f[m][10]);
	cout<<res%mod<<endl;
}
```



