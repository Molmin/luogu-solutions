## P8554 心跳 题解
~~因为不会压缩状态只有 77pts 所以就不发题解了。~~

强大出题人多哥把时限改成了 $\tt 2s$，然后我过了，所以就发个题解吧。
### 题意
对于长为 $n$ 的数列 $p$，定义 $f(p)$：
$$f(p)=\sum_{i=1}^n\left[\max_{j=1}^i \{p_j\}=p_i\right]$$
即前缀最大值个数。对于数列 $p$，定义它的 $a$ 数组为：
$$a_i=f(\left<p_1,p_2,\cdots,p_{i-1},p_{i+1},\cdots,p_n\right>)$$
求有多少数组满足是至少一个数列的 $a$。答案对 $10^9+7$ 取模。
### 题解
这题巨大无敌神奇神秘逆天的一点就是建立双射。发现直接对 $a$ 计数巨大难，所以我们想找到一个比较简单的，便于计数的序列与 $a$ 建立双射关系。

一个神奇的思路是染色，或者说给 $a$ 中元素分类。我们先来观察一个数列：
$$[{\color{red}4},2,3,{\color{red}7},{\color{red}9},8,6,5]$$
其中标红的是前缀最大值位置，我们记它的个数为 $k$。如果去掉非红色点，显然个数不变，还是 $k$ 个。这样有：
$$a:[/,3,3,/,/,3,3,3]$$
去掉 $4$ 后，$2,3$ 会成为新的红色数，从而 $a_1=4$。类似地，有：
$$a:[{\color{red}4},3,3,{\color{red}2},{\color{red}3},3,3,3]$$ 
求的过程中，我们发现新的前缀最大值个数为 $k-1+x$，其中 $x$ 是后面新增加的红色数个数。从而可以得到红色位置 $a$ 的值域为 $[k-1,n]$。

从上面的讨论，我们可以把数分为三类，分别是：
- 红色：原来就是前缀最大值的位置。
- 绿色：删去红色点后可以成为前缀最大值的位置。
- 黄色：非红色绿色数。

注意到这个颜色序列只有 $3$ 种元素，如果颜色序列和 $a$ 之间真的有双射，那么对颜色序列计数显然要更简单。定义有 $a$ 对应的颜色序列为合法的。

双射是怎么构建起来的？$a$ 唯一对应合法颜色序列，和合法颜色序列唯一对应 $a$。最后还要证明所有合法的颜色序列对应到的 $a$ 为对应至少一个 $p$。

由合法颜色序列唯一对应 $a$ 比较好证，我们给出由合法颜色序列构造出 $a$ 的方法。首先确定 $k$，它就是红色数的个数。将所有不为红色的数的值设置为 $k$。红色点的数设置为 $k-1+x$，其中 $x$ 表示它后面连续的绿色点个数。

而 $a$ 唯一对应合法颜色序列就牵扯到我们对合法颜色序列的定义了。刚刚我们是已知 $p$ 构造的颜色序列，在未知 $p$ 的时候，我们想要定义一个规则，使得唯一对应条件满足。因为合法颜色序列唯一对应 $a$，所以我们可以假装我们知道 $k$ 是多少了（反正这个 $k$ 是唯一的，假设知道并不影响证明）。对于所有 $\ne k$ 的位置 $a_i$，我们标上红色，并把后面的 $a_i-k+1$ 个位置标为绿色。假设这样确定了 $w$ 个红色点，还差 $k-w$ 个，显然要放进去 $k-w$ 个红绿连续点对，尽量往前放即可。最后还没有颜色的位置标为黄色。

接下来是 $a$ 对应一个 $p$ 的问题。我们尝试用颜色序列构造一个 $p$。对于绿色点，它应该满足小于上一个红和大于上上一个红，对于黄色点，它应该满足小于上一个绿或上上一个红。这样一定可以根据这些条件构造出满足条件的 $p$。

接下来，就是根据上面产生合法颜色序列的方法，讨论合法颜色序列应该满足什么条件了。

- 因为红绿要尽可能往前放，所以红绿前面不能存在黄黄，否则可以交换。
- 类似地，如果存在黄红绿[非绿/结尾]，也不合法，可以换为红绿黄[非绿/结尾]。
- 绿色前面不可能是黄色，因为新产生的前缀最大值一定是紧跟红色的一段区间。
- 第一个数一定是红色，第二个数不可能是黄色。原因显然。

然后我们再看看前面的构造，似乎也没别的限制了。那就做 $\rm dp$ 吧。在做之前，我们还要考虑 $a$ 值域的限制，显然 $k-1\le \min a\le k$。当某个红色后不存在绿色时，$\min a=k-1$，否则 $\min a=k$。。

想想为了这些条件需要知道当前状态的什么信息。显然知道前三个颜色是什么和是否出现黄黄就够了。而为了统计答案我们还要记录是否存在某个红色后不存在绿色和红色的个数。这一共是 $3^3\times 2\times 2\times n=108n$ 种状态。可以再压缩，但我不太会了。转移也比较简单，只需考虑当前填这个颜色会不会破坏条件就行了，具体见代码。这里有点细节就是最后统计答案的时候也要判断一下前两个条件。

时间复杂度 $\mathcal{O}(n^2)$。~~但因为高达 108 的常数寄了。~~ 又活过来了。
```cpp
#include <cstdio>
#include <cstring>
// 填到第几个了 | 有没有黄黄 | 有没有不接绿色的红色 | 前三个的颜色 | 有多少红色 
const int N = 2e3 + 10, mod = 1e9 + 7; int f[2][2][2][27][N]; 
// x,y,z 分别为 i,i-1,i-2 的颜色，0,1,2 分别为红绿黄
inline int S(const int& x, const int& y, const int& z) { return x + y * 3 + z * 9; }
inline int S1(const int& S) { return S % 3; }
inline int S2(const int& S) { return S / 3 % 3; }
inline int S3(const int& S) { return S / 9 % 3; }
inline int add(const int& S, const int& x) { return S % 9 * 3 + x; }
int main()
{
	int n, m; scanf("%d%d", &n, &m);
	int now = 0;
	// 绿色前面不能是黄色，黄黄后不存在红绿x，也不存在黄红绿x，第一个是红，第二个不是黄
	f[0][0][1][S(0, 0, 0)][3] = f[0][0][1][S(1, 0, 0)][2] = f[0][0][1][S(2, 0, 0)][2] = 1;
	f[0][0][0][S(0, 1, 0)][2] = f[0][0][0][S(1, 1, 0)][1] = f[0][0][0][S(2, 1, 0)][1] = 1;
	for (int j = 4; j <= n; ++j)
	{
		now ^= 1; memset(f[now], 0, sizeof (f[now]));
		for (int o = 1; o < j; ++o)
			for (int p = 0; p < 2; ++p)
				for (int q = 0; q < 2; ++q)
					for (int i = 0; i < 27; ++i)
					{
						if (!f[now ^ 1][p][q][i][o]) continue;
						int t = f[now ^ 1][p][q][i][o];
						for (int l = 0; l < 3; ++l)
						{
							if (S1(i) == 2 && l == 1) continue;
							if (p && S1(i) == 1 && S2(i) == 0 && l != 1) continue;
							if (S1(i) == 1 && S2(i) == 0 && S3(i) == 2 && l != 1) continue;
							(f[now][p || (S1(i) == 2 && l == 2)][q || (S1(i) == 0 && l != 1)][add(i, l)][o + !l] += t) %= mod;
						}
					}
	}
	int ans = 0;
	for (int p = 0; p < 2; ++p)
		for (int q = 0; q < 2; ++q)
			for (int i = 0; i < 27; ++i)
				for (int j = 1; j <= n; ++j)
				{
					if (i == S(1, 0, 2) || (p && S1(i) == 1 && S2(i) == 0)) continue;
					if (j - (q || (S1(i) == 0)) < m) continue;
					(ans += f[now][p][q][i][j]) %= mod;
				}
	printf("%d\n", ans); return 0;
	return 0;
}
```