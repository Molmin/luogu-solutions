#### 前言

我的做法貌似是个“比较正确”的做法，时间复杂度是O($n$ * 玄学)

#### 做法

首先考虑$dp$，设置状态$dp[i]$表示将前$i$个数字进行分段可以得到的最多的为三的倍数的段的数量。

一开始想到的转移方法是O($n^2$)的，也就是首先预处理一个前缀和，然后转移的时候：

$dp[i] = max(dp[i],dp[j - 1]$ $+ sum[i] - sum[j]$)(是$or$不是三的倍数)

这样子得枚举一个$j$，显然不妥，过不了这一题。

但是我们想到，得到的$dp[]$数组是单调不降的，这个是很轻松可以知道的。

所以要是我们不把一段拿出来，显然直接用$dp[i]$继承$dp[i - 1]$是最优的。

然后我们想，每一次，将一段提出来，对答案的贡献显然只能加$1$或者$0$

$dp[i - 1]$又是$dp[i]$之前的所有$dp[j]$中最大的。倘若要使得$dp[j] + 1 > dp[i - 1]$($i - 1 > j$)，那么显然$dp[j]$应该是等于$dp[i - 1]$的。

因此，我们枚举的时候，实际上不需要枚举那么多，采用倒序枚举，只要枚举到的$dp[j]$已经小于$dp[i - 1]$了，就没有枚举下去的必要了，答案不可能比直接继承更优了，直接$break$

因此这样子的时间复杂度是是O($n$ * 玄学)的。

#### Code

```cpp
#include <bits/stdc++.h>
using namespace std;
char ch[200005];
int dp[200005];
int data[200005];
int sum[200005];

int pd(int x)
{
	if(x % 3 == 0)return 1;
	return 0;
}

int main()
{
	cin >> ch + 1;
	int n = strlen(ch + 1);
	for(int i = 1 ; i <= n ; i ++)
		data[i] = ch[i] - '0' , sum[i] = sum[i - 1] + data[i];
	if(data[1] % 3 == 0)dp[1] = 1;
	for(int i = 2 ; i <= n ; i ++)
	{
		int t = dp[i - 1];
		for(int j = i ; j >= 1 ; j --)
		{
			if(dp[j - 1] < t)break;
			dp[i] = max(dp[j - 1] + pd(sum[i] - sum[j - 1]),dp[i]);
		}
	}
	cout << dp[n];
	return 0;
}
```

#### 后话

同时也欢迎大家来Hack我！

（貌似想了想，这个做法的时间复杂度是可以保证比较优秀的，因为貌似很难被卡)

（可能是我太菜了不会。)
