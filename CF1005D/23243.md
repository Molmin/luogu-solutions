这题虽然是 $div3$ 的题，但难度还是不小，本来我只是打了个“暴力”试试，但没想到最终 $A$ 了，于是乎来瞎讲讲

-----
题目大意：给定一个大数，试将该数切成多段，形成多个数，并使其中 $3$ 的倍数尽可能多，试求出最多能切出多少个 $3$ 的倍数

$P.S.$ 值得注意的是，$0$ 也是 $3$ 的倍数

-----
对该题完全没有思路，于是想试一试贪心

定的贪心策略是：如果当前一位到上一次切的位置**之间**能够切出为 $3$ 的倍数的数，那么 $ans+1$ ，并使上一次切的位置为当前位置

略加思索，为了得到更优解，在当前已获得 $3$ 的倍数的情况下，没有必要再多选取一位数，因为很显然地，如果下一位数可以与当前获得的 $3$ 的倍数组成 $3$ 的倍数的话，那么下一位数必然可以自己组成一个 $3$ 的倍数

如果下一位数不能与当前获得的 $3$ 的倍数组成 $3$ 的倍数的话，那么肯定需要选取更多的数才能组成 $3$ 的倍数，而在多选取的数中没准就会包含一个 $3$ 的倍数，如果包含了，那么得到的解将不是最优解

比如 $24271$，最优的分法是 $24|27|1$，而非 $2427|1$

贪心的策略确定了，接下来要解决如何优化的问题了

很显然地，如果使用最暴力的写法，时间复杂度将到达 $O(n^2)$，对于一个位数多达达 $2*10^5$ 的数来说必然是承受不住的

那么这里可以使用字符串存数，前缀和计算是否为 $3$ 的写法，时间复杂度可以有效降低

代码见下

```cpp
#include<cstdio>
#include<string>
#include<iostream>
using namespace std;
int n,ans,sum[200005],tot;
string s;
int main()
{
	cin >> s;
	int len=s.size();
	s='%'+s;
	for(int i=1;i<=len;i++) sum[i]=sum[i-1]+s[i]-'0';//前缀和
	int lat=1;//lat记载上一个切的位置
	for(int i=1;i<=len;i++)
	{
		for(int j=lat;j<=i;j++)//计算在i处切一刀是否能形成3的倍数
		{
			int cnt=sum[i]-sum[j-1];
			if(cnt%3==0)
			{
				lat=i+1;//使上一次切的位置为当前位置
				ans++;
				break;
			}
		}
	}
	printf("%d",ans);
	return 0;
}
```

### 不懂如何验证一个数为 $3$ 的倍数的同学请自行温习小学数学