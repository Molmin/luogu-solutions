看到好多大佬用 dp 做，不过本蒟蒻觉得好像可以贪心。


## 分析

主要思路就是遍历一遍字符串，累加已遍历的数，碰到以下三种情况时：

1. 目前累加的数的个数已到 3 个。

1. 当前的数是 3 的倍数。

1. 前面已累加的数的和是 3 的倍数。

就可以分出 1 段然后将已累加的数清零，但是为什么呢？


## 证明

 _（对 3 种情况一一讨论）_ 

**第 1 种情况**

即累加个数已到达 3 个，有几种可能的情况。

- 其中出现 0，则转化为第 2 种情况（**0 也是 3 的倍数**）。

- 三个数全是 1，则三个可划为一组。

- 三个数中有两个 1，一个 2，则其中一个 1 可以和 2 划为一组。

- 三个数中有一个 1，两个 2，则其中一个 2 可以和 1 划为一组。

- 三个数全是 2，则三个可划为一组。

**第 2 种情况**

即当前数是 3 的倍数。

因为当前遍历到的数是 3 的倍数，所以这个数可以单独划为一组。

**第 3 种情况**

即前面已累加的数的和是 3 的倍数。

如果没有遇上以上两种情况，这 3 个数可以划为一组。

**综上，当目前累加的数的个数已到 3 个、当前的数是 3 的倍数、前面已累加的数的和是 3 的倍数时，可以划出一组（不一定是当前累加的所有数）。**


------------


## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
	string str;
	cin>>str;
	int len=str.size(),cnt=0,pre=0,ans=0;
	//cnt表示当前累加的数的个数，pre表示当前已累加的数的和，ans表示最终分成的组数
	for(int i=0;i<len;i++)//把字符串的长度提前算好可以节约时间
	{
		pre+=str[i]-'0';//累加 
		cnt++;//计数 
		if(cnt==3||pre%3==0||(str[i]-'0')%3==0)//解释在上面
		{
			ans++;//最终分成的组数加一 
			pre=0;
			cnt=0;//归零 
		}
	}
	cout<<ans;
	return 0;
}
```
