### 题目分析：

显然是 DP。

首先想到一种较为朴素的方法，对于每一个点，向前一直枚举到起点，前缀和一下判断是否可行，复杂度是 $O(n^2)$ 的，不能接受。

形式化地，有：$f_i$ 表示以 $i$ 为终点的一段区间最多能分成的能被三整除的段数，转移时，$f_i=f_j+1$，其中 $j$ 点是 $\sum_{k=i}^ja_i$ 能被 3 整除的一个点。 

考虑优化，发现如果向前枚举过多一定会有浪费，考虑缩小向前枚举转移点范围，~~那就随便找一个大一点的常数枚举一下赶紧把这道大水题过了得了~~。

实际上，这样的一个区间位置最多是 3，也就是每一个点最多向前枚举三个点就行了，否则即使没有找到也一定没有必要枚举下了。

考虑这样的一件事，对于任意一个长度为 $n$ 的序列中一定存在至少一个子串的和 $\bmod n=0$。因为这样的一个序列有 $n+1$ 个前缀和，根据抽屉原理，一定有两个对 $n$ 取余是相等的。这道题中 $n=3$，也就是在三个中一定有一个可以分出至少一个序列能被 3 整除。所以这里如果在往前枚举 3 的基础上再往前枚举一定是不优的。


-------
### 代码：
```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
int f[200005],a[200005],len,ans;
int check(int n){if(n%3==0)return 1;return 0;}
int main(){
	while(~scanf("%1d",&a[++len]));len--;
	for(int i=1;i<=len;i++){
		f[i]=max(f[max(0,i-1)]+check(a[i]),max(f[max(0,i-2)]+check(a[i]+a[max(0,i-1)]),f[max(0,i-3)]+check(a[i-1]+a[i]+a[max(0,i-2)])));
		ans=max(ans,f[i]);
	}
	printf("%d",ans);
}
```
