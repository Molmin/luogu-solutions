这题我从高一时候就开始看，当时暴力 WA 的很惨。将近十三个月过去了，我回看自打高一时候一直不会做的这道题，终于把它完成了。关键词：最小割。

题目意思比较简单，给一张 $n$ 个点 $m$ 条边的图，固定起点为 $0$ 号节点，在除了 $0$ 号节点的 $n-1$ 个点中有 $g$ 个关键点，现在允许进行两种操作：

1. 除去图中的一条边（对应原题中解除两个人之间的好友关系）
  
2. 将图中的一个关键点变为非关键点（对应原题中修改某个人的账号密码）
  

要使操作若干次之后 $0$ 号节点无法到达任何一个关键点，求最少的操作次数。

我们考虑给原有的边附上权，去掉一条边需要一次操作，因此给每条边都附上边权 $1$，而将一个关键点变为非关键点也需要一次操作，鉴于这种操作不会改变图上的连通关系，不妨新建一个节点 $t$，把所有的关键点都连到 $t$ 上，连边也是边权为 $1$ 的，代表将一个关键点变为非关键点需要一次操作。

现在我们在想在这样的一张图上如何计算答案，注意到图经过刚刚的转化已经变为最小割模型：我们只需要把图分成两部分，一部分和 $0$ 连通，一部分和 $t$ 连通，求最小的操作次数其实就是求最小割，根据最大流最小割定理，直接跑 Dinic 算法求最大流即可得到答案。

断边过程中把一个节点划分给 $t$ 所在的连通块并不会产生疑问。但是对于下面这种情况，有人可能会产生疑问：如果有关键点被分到和 $0$ 连通的那部分，需要做一次操作将其变为非关键点，这次操作是否计入了答案呢？这个操作其实是计入了答案的，我们的新图给每个关键点和 $t$ 连了一条边，如果一个关键点被划分到和 $0$ 连通的那部分，那么必然切断了这个节点和 $t$ 的边，这次操作即转化为了新图上的删边操作，因此新图的最小割其实已经统计了这种情况的贡献。

Dinic 的代码就不放了，这里放一个建图的主函数部分就好了：

```cpp
int main(){
  std::cin>>n>>g>>m;
  s=0,t=n+1,mx=t;
  for(int cx=0,v;cx<g;++cx){
    std::cin>>v;
    addEdge(v,t,1);
    addEdge(t,v,0);
  }
  for(int cx=0,u,v;cx<m;++cx){
    std::cin>>u>>v;
    addEdge(u,v,1);
    addEdge(v,u,1);
  }
  if(g==0) std::cout<<0<<std::endl;
  else std::cout<<Dinic()<<std::endl;
  return 0;
}
```

另附：[提交记录](https://www.luogu.com.cn/record/76489429)，想要完整代码可以找我。