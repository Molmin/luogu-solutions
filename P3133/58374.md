P3133 【[USACO16JAN]无线电联系Radio Contact】

FJ失去了他最喜欢的牛铃，而Bessie已经同意帮助他找到它！他们用不同的路径搜索农场，通过无线电保持联系。不幸的是，无线电中的电池电量不足，所以他们设法尽可能保持两者位置的距离最小，以节省电量。

FJ从位置（fx，fy）开始，并计划遵循由N步骤组成的路径，每个步骤都是“N”（北），“E”（东），“S”（南），或“W”（西）。Bessie从位置（bx，by）开始，并遵循由M步骤组成的类似路径。两个路径可以经过相同的点。在每个时间段，FJ可以保持在他现在的位置，或沿着他的道路前进一步，无论哪个方向恰好在下一个（假设他还没有到达他的路径的最后位置）。Bessie可以做出类似的选择。在每个时间步（不包括从初始位置开始的第一步），他们的无线电消耗的能量等于它们之间距离的平方。

请帮助FJ和Bessie计划行动策略，最大限度地减少消耗的能量总量。总量包括最终步骤，这时两者首先到达各自路径上的最终位置。

输入输出格式

输入格式：
第一行输入N和M（1≤N，M≤1000）。

第二行输入整数fx和fy，第三行输入bx和by（0≤fx，fy，bx，≤1000）。下一行包含一个长度为N的字符串描述FJ的路径，最后一行包含一个字符串的长度M描述Bessie的路径。

数据满足（0≤x，y≤1000）。注意，东方向为正X方向，北方向为正Y方向。

输出格式：
输出一个整数，表示最小能量。

输入输出样例

输入样例#1： 
2 7
3 0
5 0
NN
NWWWWWN
输出样例#1： 
28

一个很好的四维dp；
设f[i][j][k][[l]，两人分别走了i、j步，k、l为两人走或不走的状态；
附上代码：（详细注释）

```cpp
#include <iostream>
#include <cstring>
#define maxN 1010
using namespace std;
int N,M;
int x1[maxN],y1[maxN],x2[maxN],y2[maxN];  //先将走到每一步的坐标算出并记录； 
char A[maxN],B[maxN];  //两人走的路径； 
int f[maxN][maxN][3][3];  //如上所示； 
void pre();  //预处理； 
void comp(int i,int j);
int main()  {
	cin>>N>>M;
	cin>>x1[0]>>y1[0]>>x2[0]>>y2[0];  //起点； 
	cin>>A>>B;
	memset(f,0x7f,sizeof(f));  //初始化； 
	pre();  //预处理，计算每步坐标； 
	for(int i=0;i<=N;i++)  {  //i、j从0开始！！！！ 
		for(int j=0;j<=M;j++)  {
			if(!i && !j)  {  //初始化，； 
				f[i][j][0][1]=0;
				f[i][j][1][1]=0;
				f[i][j][1][0]=0;  //默认为0； 
				continue;
			}
			comp(i,j);  //dp; 
		}
	}
	cout<<min(f[N][M][1][1],min(f[N][M][1][0],f[N][M][0][1]));
	return 0;
}
void comp(int i,int j)  {  //dp;
	if(i!=0 && j!=0)  //别忘判断！！！！ 
	    f[i][j][1][1]=min(f[i-1][j-1][1][1],min(f[i-1][j-1][1][0],f[i-1][j-1][0][1]));
	f[i][j][1][1]+=(x1[i]-x2[j])*(x1[i]-x2[j])+(y1[i]-y2[j])*(y1[i]-y2[j]);
	if(i!=0)  //别忘判断！！！！
	    f[i][j][1][0]=min(f[i-1][j][1][1],min(f[i-1][j][1][0],f[i-1][j][0][1]));
	f[i][j][1][0]+=(x1[i]-x2[j])*(x1[i]-x2[j])+(y1[i]-y2[j])*(y1[i]-y2[j]);
	if(j!=0)  //别忘判断！！！！
	    f[i][j][0][1]=min(f[i][j-1][1][1],min(f[i][j-1][1][0],f[i][j-1][0][1]));
	f[i][j][0][1]+=(x1[i]-x2[j])*(x1[i]-x2[j])+(y1[i]-y2[j])*(y1[i]-y2[j]);
}
void pre()  {
	for(int i=0;i<N;i++)  {
		if(A[i]=='N')  {
			x1[i+1]=x1[i];
			y1[i+1]=y1[i]+1;
		}
		else if(A[i]=='E')  {
			x1[i+1]=x1[i]+1;
			y1[i+1]=y1[i];
		}
		else if(A[i]=='S')  {
			x1[i+1]=x1[i];
			y1[i+1]=y1[i]-1;
		}
		else  {
			x1[i+1]=x1[i]-1;
			y1[i+1]=y1[i];
		}
	}
	for(int i=0;i<M;i++)  {
		if(B[i]=='N')  {
			x2[i+1]=x2[i];
			y2[i+1]=y2[i]+1;
		}
		else if(B[i]=='E')  {
			x2[i+1]=x2[i]+1;
			y2[i+1]=y2[i];
		}
		else if(B[i]=='S')  {
			x2[i+1]=x2[i];
			y2[i+1]=y2[i]-1;
		}
		else  {
			x2[i+1]=x2[i]-1;
			y2[i+1]=y2[i];
		}
	}
}  
```