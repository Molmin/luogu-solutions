大家好，很高兴能为大家讲解我自己的思路，如果有什么说不太清楚的，请多多见谅，谢谢大家。
—————————————————————————————————————

好的，现在开始真正讲题，我们先读题。
# 题目大意
给你一个n*m的矩阵，让你把（r,c）当做起点去四处乱走，但是有一个规定，你可以随便往上往下走，但你往左走的次数不能超过x，往右走的次数不能超过y，也就是左走次数$\leq x$，右走次数$\leq y$。最后问你的是你最多能走多少个位置（起点也算）。

## 理解了题目大意，一切就好办了
# 思路
首先，只是一道经典宽搜题，我们可以直接从起点开始宽搜，每经过一个点，就把它标记一下，防止重复遍历，知道任何的点都不满足遍历条件或已经被遍历过以后结束宽搜，结果就是你遍历到的点的个数。
代码如下：

```cpp
#include<cstdio>
using namespace std;
int n,m,st,en,i,x,y,r,c,d[4000001][6],fx[5][3],xx,yy,ans;
char a[2001][2001];
bool bz[2001][2001];
int main()
{
    fx[1][1]=fx[3][2]=-1;fx[2][1]=fx[4][2]=1;
    scanf("%d%d",&n,&m);
    scanf("%d%d",&r,&c);
    scanf("%d%d",&x,&y);
    getchar();
    for (int i=1;i<=n;i++)
    {
        for (int j=1;j<=m;j++)
            a[i][j]=getchar();
        getchar();
    }
    st=0;
    en=1;
    bz[r][c]=true;
    d[1][1]=r;
    d[1][2]=c;
    d[1][3]=1;
    d[1][4]=x;
    d[1][5]=y;
    ans=1;
    while (st<en)
    {
        st++;
        for (int i=1;i<=4;i++)
        {
            xx=d[st][1]+fx[i][1];
            yy=d[st][2]+fx[i][2];
            if (i==3&&d[st][4]-1<0) continue;
            if (i==4&&d[st][5]-1<0) continue;
            if (xx>0&&xx<=n&&yy>0&&yy<=m&&bz[xx][yy]==false&&a[xx][yy]=='.')
            {
                d[++en][1]=xx;
                d[en][2]=yy;
                d[en][3]=d[st][3]+1;
                if (i==3) d[en][4]=d[st][4]-1;
                else d[en][4]=d[st][4];
                if (i==4) d[en][5]=d[st][5]-1;
                else d[en][5]=d[st][5];
                ans++;
                bz[xx][yy]=true;
            }
        } 
    }
    printf("%d",ans);
    return 0;
} 
```

#### 注：d[st][3]没用，我没事干打多了。
## 但是，只要你按照我这样的打法去交，你肯定会这样。
![](https://cdn.luogu.com.cn/upload/pic/57162.png)

# 为什么会这样？
别急，等我慢慢说。

其实，也许我们仔细想一想，我的程序是有漏洞的，比如说，一个点可能经过许多种路径到达，这些不同的路径的左走次数和右走次数又不同，所以就会导致我这考虑最先到达的，其实其他的到达方法也可能造成答案的不同。

所以当我们遇到同一个点被经过多次时，什么时候舍弃，什么时候继续留下这个状态呢？

我们可以记录一个点的最少左移次数和最少右移次数，当我们看见一个点被遍历多次时，就把这个路径的左移次数和右移次数与最少左移次数和右移次数比较，如果更优就更新，并继续往前遍历，如果其中有一个更优，就继续遍历，但不更新，至于都不优，那还要来干什么直接扔掉。

所以AC代码就是这样的，我认为（认为，不是肯定）我的程序应该是比其他人要短一些的，所以打起来也不会纳那么费劲。

```cpp
#include<cstdio>
using namespace std;
int i,j,en=1,ans=1,n,m,st,x,y,r,c,xx,yy,d[10000001][5]//宽搜状态，1表示第几行，2表示第几列，3表示左移次数，4表示右移次数，,bz[2001][2001]//左移次数,bz2[2001][2001];//右移次数
char a[2001][2001];
const int max=0x7FFFFFFF,fx[4][2]={-1,0,1,0,0,-1,0,1};
int main()
{
    scanf("%d%d%d%d%d%d\n",&n,&m,&r,&c,&x,&y);
    for (i=1;i<=n;i++)
    {
        for (j=1;j<=m;j++)
            a[i][j]=getchar(),bz[i][j]=max,bz2[i][j]=max;//因为是要记录最少的次数，所以一开始就要附一个极大值
        getchar();
    }
    d[1][1]=r;
    d[1][2]=c;
    bz[r][c]=0;
    bz2[r][c]=0;//初始化
    while(st<en)
    {
        st++;
        for(i=0;i<4;i++)//四个方向走一走
        {
            int xx=d[st][1]+fx[i][0],yy=d[st][2]+fx[i][1],u=0,v=0;//将要走去的地点
            if(i==2) u++;
            if(i==3) v++;//这是直接看要不要加上左移或右移的步数
            if(u+d[st][3]>x||v+d[st][4]>y||xx<=0||xx>n||yy<=0||yy>m||a[xx][yy]!='.'||(bz[xx][yy]<=d[st][3]+u&&bz2[xx][yy]<=d[st][4]+v)) continue;//判断一下是不是需要舍弃的状态
            if(bz[xx][yy]>d[st][3]+u&&bz2[xx][yy]>d[st][4]+v)//都更优就更新
            {
            	if(bz[xx][yy]==max&&bz2[xx][yy]==max) ans++;//如果这个点还没走过，就把答案+1
            	bz[xx][yy]=d[st][3]+u;
				bz2[xx][yy]=d[st][4]+v;
        	}
            d[++en][1]=xx;
            d[en][2]=yy;
            d[en][3]=d[st][3]+u;
            d[en][4]=d[st][4]+v;//如果有其中一个更优，就继续往下走。
        }
    }
	printf("%d",ans);
    return 0;
} 
```
我的题解到此结束，希望大家能听懂，把这道题快快做对！！
