题目翻译：

$t$组询问，每次给出一个长度为 $n$ 的序列 $a$，对于两个相邻的且不相同的数，你可以将他们合并起来，即将这两个数替换成它们的和。

注意到，你每次进行一次操作后，序列长度会 $−1$，现在你可以随意进行若干次操作，问最后序列长度最短是多少。

算法讲解：
1. 如果所有数字都一样那么就不能合并，输出n；
1. 如果最大数字只有一个，那么从最大的开始合并。合并完毕后，他还是最大的所以一定可以合并到1；
1. 如果最大数字不止一个，和第2种一样可以处理
1. 如果有其他数据可以H***(被和谐了）请评论或私信

代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
int T,N,a[1000039];
int main (){
	scanf("%d",&T);
	while(T--){
	    scanf("%d",&N);
	    for(int i=1;i<=N;i++)scanf("%d",&a[i]);
	    sort(a+1,a+1+N);
	    if(a[1]==a[N])printf("%d\n",N);
	    else printf("%d\n",1);
	}
	return 0;
}//14行不压行代码
```