你咕竟然没有题解，赶紧写一发。

首先有一个~~与正解没啥关系~~最 naive 的想法：对于每一个点都往后搜一遍，直接统计答案。这样是 $O(n^4)$ 的，显然过不去。

我们很容易想到按照行，列从大到小依次求答案。

接下来有一个很显然的事实：

对于某一个点，如果所有能走到它的点（包括自己）都被计算过了，那么可以直接把它改成障碍。

现在看起来这个东西没啥用，所以先想想别的。

考虑 $L_{i,j,k},R_{i,j,k}$ 表示 $(i,j)$ 在第 $k$ 行能走到的最左边的和最右边的位置。那么通过递推求这两个数组是很容易的。

但我们可以很容易地发现，直接把所有在这些范围内的非障碍格子的值加起来肯定是不对的，因为很有可能有一些被阻断了。现在需要解决如何将这些走不到的格子挖掉。

我们可以假设在这个方阵最外面有一圈障碍。这时候前面的事实就派上用场了。我们可以直接将所有这些位置变成障碍，并且从答案里面挖掉这些位置。

这样做直观上感觉挺对的，但怎么证明它的正确性呢？

如果一个点 $(x,y),y\in [L_{i,j,x},R_{i,j,x}]$ 没被挖掉，那么一定存在一个 $(p,q)$ 使得 $(p,q)$ 比 $(i,j)$ 后访问到且能走到 $(x,y)$。那么显然 $(p,q)-(x,y)$ 一定与 $(i,j)-(x,L_{i,j,x})$ 或 $(i,j)-(x,R_{i,j,x})$ 相交。而如果相交则可以交换路径。这样我们就证明了 $(i,j)$ 一定能走到 $(x,y)$。

而另一方面，被挖掉的点显然肯定不是能走到的点，所以我们就证明了这种做法的正确性。

稍微思考一下怎么实现就可以做到 $O(n^3)$。

F2 是这道题的加强版，标算据说是 $O(n^2\log n)$ 的~~可惜被这题代码草过了~~。如果有哪位大佬会的话，请麻烦指点一下本蒟蒻。