明显的恶意评分，这道题还是很简单的，实际上大概红题或橙题难度吧 ~~本来想水一道黑题，没想到变紫题了~~

这里给这题带来一个简单易懂的数学解法


------------
先定义一个函数$xjh(x,y)$（不要在意这个名字qaq）表示大于等于$x/y$的最小整数，即对$x/y$向上取整。通过小学奥数我们可以知道，把$10$个坚果放入最多能放$3$个坚果的区间，需要$xjh(10,3)=4$个箱子。（听说有一个$ceil$函数可以实现向上取整，然而这个函数并不是真正的向上取整，对于整数会直接$+1$，因此我们还是自定义一个吧）

设放下所有坚果至少需要$cnt$个区间，至少用$x$个箱子，此时用了$y$个隔板。为了判定用下所有隔板后还需不需要额外的箱子，这里再设只用下所有的隔板可以隔出$u$个区间，用了$w$个箱子。因为对于每个箱子，最多隔出$k$个区间，用$k-1$个隔板。于是有：
```cpp
cnt=xjh(a,v)=x+y//相当于把每个箱子看作一个挡板，则挡板数与区间数相等
w=xjh(b,k-1)//每个箱子最多用k-1个隔板
u=w+b=xjh(b,k-1)+b//与第一个式子原理相同
```
只要判定$u$是否比$cnt$大，就可以判定需不需要额外的箱子了。于是有以下两种情况：

1. 不需要额外的箱子

此时只要求出隔出$cnt$个区间至少需要几个箱子就可以了，有：
```cpp
x=xjh(cnt,k)
```
2. 需要额外的箱子

因为此时已经用了所有的隔板，即$y=b$，可以直接得出所需的箱子，有：
```cpp
x=cnt-y=cnt-b
```


------------
这样问题就解决了！是不是很简单。最后奉上代码：
```cpp
#include<iostream>
using namespace std;
int a,b,k,v,cnt;
int xjh(int x,int y)
{
    return x%y==0?x/y:x/y+1;
}//向上取整
int main()
{
    cin>>k>>a>>b>>v;
    cnt=xjh(a,v);
    if(xjh(b,k-1)+b>=cnt)
        cout<<xjh(cnt,k);
    else
        cout<<cnt-b;
    return 0;
}
```
~~其实还可以更短~~

希望对大家有帮助