## 分析
题目链接在[这里](https://www.luogu.com.cn/problem/CF214B)。

他给了我们 $n$ 个数，叫我们求由这些数组成的能被 2 3 5 整除的最大数。（可以不用完所有数字）

所以由题意我们可以得出最大数的末尾一定是 0——因为能被 2 整除的数末尾是二的倍数，能被 5 整除的数，末尾是五的倍数。

而三的倍数的变换规律是：各个数位上的和为三的倍数。

####  **输出 -1 的情况**
当给出的数没有 0 时，直接输出 ```-1```。其他情况就要输出最大值。

### 求最大值
这是本道题的最难之处，但是，当所有数字之和为三的倍数时，可以直接将这些数从大到小输出（0 就自动排在最后）。而不为三的倍数时，我们要删除一个数（要是最小的）使和成为三的倍数，当都没有时，只能删除两个数（只用两个即可）（要是最小的）使和成为三的倍数。

为什么只要两个呢？

假如当各个数字之和取余三之后为 1，那么只用删除一个对三取余为 1 的数，当如果没有这样的数时，可以找两个对三取余为 2 的数。（必须有 2 个，不然各个数字之和取余三之后不会为 1）。而当各个数字之和取余三之后为 2 时，同上，只不过最多找两个对三取余为 1 的数。

## Code
终于说到了代码了
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[100001],lin,sum;
int main(){
	cin>>n;
	int m=n;
	for(int i=1;i<=n;i++){
		cin>>a[i];
		if(a[i]==0) lin++;//求零的个数
		sum+=a[i];//求各个数之和
	}
	if(lin==0){//如果没有零，输出-1
		cout<<"-1";
		return 0;
	}
	sort(a+1,a+n+1);//排序，为求最大值铺垫
	if(sum%3!=0){
		int t=INT_MAX,s=0;
		for(int i=1;i<=n;i++){
			if(a[i]<t&&a[i]%3==sum%3){
				t=a[i];
				a[i]=-1; 
				m--;
				break;
			}
		}//删除一个数（最小），使全部数之和能被三整除
		if(t==INT_MAX){//如果不能删除一个数，那么删除两个数。
			for(int i=1;i<=n;i++){
				if(s==2) break;
				if(a[i]%3!=sum%3&&a[i]%3!=0){
					a[i]=-1;
					m--;
					s++;
				}
			}
		}
	}
	if(m==lin) cout<<"0";//当全部都为零时，要输出0
	else for(int i=n;i>=1;i--) if(a[i]!=-1) cout<<a[i];//要倒着输出，因为sort是从小到大排序
	return 0;
}
```

不知道为什么，我这个代码要加上许多无用的注释（没有任何字）才能过，不然一直 ```waiting```。