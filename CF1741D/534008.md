# 题目大意：

给你一串连续自然数，交换一些相邻的，长度为 $2^k$ 的区间之后可以使数列有序，求可行性和最少交换的次数。

# 思路：
第一步：假装排个序

我们可以用类似 ST 表的思想，让 $k$ 从小到大递增，比较每两个长度为 $2^k$ 的区间的最后一个数，把大的换到后面，小的放到前面，下一次检查 $2^{k+1}$ 长度的区间时，又只调查最后一个数，可以大大降低时间复杂度。

第二步：判断是否合法

观察每一段有序的连续自然数列，可以发现第 $2^k$ 和第 $2^{k+1}$ 个数差是 $2^k$ 。那么我们便可以用这么一个~~显而易见的~~奇妙的性质检查序列是否可以满足题意：当第 $2^k$ 个数加第 $2^{k+1}$ 个数不等于 $2^k$ 时（即这个数被其他非 $2^k$ 占掉了），可以宣布不合法。

为什么可以这样呢？

首先因为 $k$ 是从小到大的，每一次如果不合法会直接跳出，因此可以知道，每 $2^k$ 个数里一定是一个连续的自然数串。

其次，如果在 $1$ ~ $2^k$ 的连续自然数串里的最大的不是 $2^k$，说明这一段根本不包含这个数或者有更大的数，无论哪种情况都不合理，可以判断不合法。

这一步比较难想，大家可以多思考一下.

# 代码

```
#include <iostream>
#include <algorithm>
using namespace std;
int t, n, a[262150];
int main() {
    cin >> t; // t组数据
    while (t--) {
        bool f = 0; // 结束标记
        int cnt = 0; // 计数器，计算交换次数
        cin >> n;
        for (int i = 1; i <= n; i++) cin >> a[i]; // 输入
        for (int x = 2; x <= n; x *= 2) { // 2的n次方分组
            for (int j = x; j <= n; j += x) {
                if (a[j - x / 2] > a[j]) swap(a[j], a[j - x / 2]), cnt++; // 如果发现逆序的，换一下位子，计数器加1
                if (a[j] != a[j - x / 2] + x / 2) { // 出现不满足要求的情况
                    cout << -1 << endl;
                    f = 1;
                    break; // 下次再见
                }
            }
            if (f) break; 
        }
        if (!f) cout << cnt << endl; // 输出
    }
    return 0;
}
```

[AC记录](https://www.luogu.com.cn/record/91142461)

求过 QwQ