# 解析
我们可以用归并的方式来处理每棵子树——先处理所有的小的子树，再依次处理大的。如果有一棵子树不合法（不合法指的是无法通过将这棵子树里的一些非叶子节点的子树里的叶子节点的顺序倒过来后来使得这棵子树的叶子节点为一段连续的自然数），那么就算其他的子树都合法，也没有办法满足 Masha 的要求。

```c++
int1 gui_bing(int1 l,int1 r){
	if(l == r){
		return 0;
	}
	int1 mid = (l + r) >> 1,gl = gui_bing(l,mid),gr = gui_bing(mid + 1,r);
	if(gl != -1 && gr != -1 && abs(a[mid + 1] - a[l]) <= r - l){
		return gl + gr + (a[mid + 1] < a[l]);
	}
	return -1;
}
```

（因为个人习惯，代码中的 $a$ 数组即为题目中的 $p$ 数组。）

这代码什么意思呢？我一步步来给大家分析。

首先，叶子节点本身肯定是合法的，所以当 $l = r$ 时，直接返回 $0$（在该代码中，用非负整数表示合法，$-1$ 表示不合法）。

接下来，就是把子树分成两部分，然后分别去处理。毕竟是归并嘛，肯定要先分开处理，再一起处理了。

至于接下来这个 `if`，就需要动点脑子了。因为前两个条件还比较好想，但是最后一个条件是什么意思呢？

我们可以想一想：如果一棵子树里有两个正整数，它们的差比这棵子树里的叶子节点的个数还要大，那么这棵子树合法吗？很明显是不合法的。因为无论怎么交换，都没有办法使得符合这个条件的一对叶子节点分开，到不同的子树下，自然就不能满足 Masha 的要求了。

但是为什么只用判两个子树的叶子节点里的第一个呢？因为当 $gl$ 和 $gr$ 都不为 $-1$ 时，说明这两棵子树都是合法的，所以只需要判一下第一个节点，就知道这棵大的子树合不合法了。

至于函数 `return` 的值……自然就是最小的操作次数啦（因为如果 $a_{mid + 1} < a_l$，说明现在值较大的节点反而靠后了，所以需要一次操作把大的放到后面，小的放在前面）。所以，直接在主函数里调用 `gui_bing(1,m)` 即可。

完整代码……因为太丑了，所以我就不贴啦（光速逃）~