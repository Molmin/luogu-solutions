说实话，这道题真的~~水~~（狗头

话不多说，我们开始讲解：

------------

 首先，这是一道**纯模拟题**，相信大家也可以看出来，主要就是把数据读入，然后依靠下一层的楼梯给的关系，找到上一层的位置。
 
 经过简单的分析，相信大家都能很快地找到本题的思路：一层一层地模拟。
 
 但是，这里也有个小问题：**模拟什么？**
 
 答案是：每层的位置。根据题面中的：**从j号房间的楼梯爬到上一层到达的房间一定也是j号房间**可知，我们只需要用一个变量来储存自己的位置就行了


但是！
-
题目中有十分明显的提示：对于100%数据，有0<N≤10000 , 0<M≤100 , 0<x≤1,000,000。

看到这个x，我们立马想到，单纯的模拟是不行的，我们只需要考虑一下周期性问题，在每层模拟时用要找的数模一下当层的楼梯数，就可以解决我们的问题了！

于是便有了下面的代码：
-

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,a[10010][110],num[10010][110],key,lo;//lo:location,当前位置
int main()
{
	cin>>n>>m;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
		{
			scanf("%d%d",&a[i][j],&num[i][j]);
			if(a[i][j]) a[i][0]++;//a[i][0]储存本层有多少楼梯通往上一层 
		}
	cin>>lo;lo+=1;
	for(int i=1;i<=n;i++)
	{
		key+=num[i][lo];key%=20123;
		int x=(num[i][lo])%a[i][0]+a[i][0];//优化的关键！
		//加一个a[i][0]是为了防止模了之后为0（或本层只有一个楼梯）.  
		lo--;//配合下面情况
		while(x)
		{
			lo++;//lo要前置，不然下在一层会出现加了下一个数的情况 
			if(lo>m) lo=1;
			if(a[i][lo]) x--;
		}
	}
	cout<<key%20123;
	return 0;
}
```

完结撒花！
-
