很坑的一道模拟。。。尽管看着很水，但是总有出人意料的错误。。qwq

看题，首先在读入时累加一下有楼梯的房间个数（为了优化，在走时候取余一下）。。注意这里

这是大家都能想到的优化，但一定要考虑取余后为0的情况，这时要把取余后的数 变为这层楼的楼梯数

因为要为0的话，就直接从这楼上了，要是这楼没楼梯呢？

不加直接爆0 wawawa

其他就是纯模拟，考验代码基本功。。

附上ac c++代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,x,a[10010][101],s[10010][101],sum[10010],ans=0,i,j;
int main()
{
    cin>>n>>m;
    memset(sum,0,sizeof(sum));
    for (i=1;i<=n;i++)
        for (j=0;j<m;j++)
        {
            scanf("%d %d",&a[i][j],&s[i][j]);
            if (a[i][j]==1) sum[i]++;//sun统计1的个数
        }
    cin>>x;
    i=1;j=x;ans=s[1][x];//初始化
    while (i<n)//最后一层不要走，所以不需要到n
    {
        int p,pp=0;
        p=s[i][j]%sum[i];//优化
        if (p==0) p=sum[i];//深海巨坑要变为当前楼梯数
        while (pp+a[i][j]<p)
        {
            pp+=a[i][j];//小技巧不需要if判断
            j++;
            if (j==m) j=0; //考虑为一个环
        }
        i++;//上楼
        ans=(ans+s[i][j])%20123;//累加
    }
    cout<<ans%20123<<endl;
    return 0;
} 
//注意
本题还有更好的优化，就是把有楼梯的房间抽出来，每次走只在这里面走就行，但数据太水，也无所谓了。。。大犇可自行优化
```