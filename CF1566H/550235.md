转化问题为（我就直接抄楼下的了）（转化过程参考其他题解，此处不再展开）：

> 给定很多集合 $S(x)$，从每个集合中选出一些数，要求 $S(x)$ 中选出的数的异或和为 $h(x)$。同时还要满足所有集合中选出的数总共恰好 $n$ 个。

考虑将每个集合分为线性基中的主元和基外的自由元。

预处理自由元（以及 $h(x)$）如何用主元表示，那么钦定自由元取值后，可以将所有东西异或起来得到主元的取值，再求一下 popcount 即可得到这样钦定会选择多少数。

因此我们可以 $O(1)$ 单点修改自由元，同时维护选出数的总数。考虑某种调整法乱搞。

但我不是很会调整，于是写了模拟退火。

然后发现好像温度没什么用？纯随机很快就能随出解……很神秘……

最终核心代码长这样：

```cpp
while (n) {
	// 随一个自由元
	int id = rng() % sz, i = vec[id].se, j = vec[id].fi;
    // 计算改变量
	int tn = n + ppnt(cur[i]) - ppnt(cur[i] ^ abs(j)) - (j > 0 ? 1 : -1);
    // 直接改
	vec[id].fi = -vec[id].fi, n = tn, cur[i] ^= abs(j);
}
```

[提交记录](https://codeforces.com/contest/1566/submission/208898504)

（配合一定的运气，目前是 CF 最优解）