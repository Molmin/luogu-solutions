万万没想到普通分块就过了啊……               

发现关键点的贡献看起来很难维护，其实就等价于区间数颜色，我们扫描线一下将每个关键点的贡献分配在最后一个覆盖它的矩形上即可。          

记 $lst_i$ 表示关键点 $i$ 在扫描线时最后一个覆盖它的矩形。

关于维护，不难发现如果建立线段树式的 kdt 后我们将每个矩形对 kdt 进行矩形覆盖，覆盖到的点的 $lst$ 全都要变为当前加入的矩形 $x$ 并让整棵子树对矩形 $x$ 进行贡献，同时我们撤销之前子树内部的其他贡献。        

关于撤销，很妙的一点在于我们利用线段树 pushdown 的性质发现总共产生 $\Theta(n \sqrt n)$ 次在线段树节点上进行子树累加的操作，也只会下传 $\Theta(n \sqrt n)$ 次并且下传具有连贯性，会在当前节点从下至上的一个前缀进行下传后不再下传至下方。利用这一性质，我们在操作时维护一个 $vis_x$ 表示点 $x$ 的子树内是否有下传/标记贡献，每次要在子树上进行累加操作时直接暴力遍历子树撤销贡献直到访问一个点 $x$ 满足点 $x$ 下方没有贡献，可以证明这么做的时间复杂度是 $O(\delta n \sqrt n)$ 的，其中 $\delta$ 是一个常数。                  

然后就是维护 $\Theta(n \sqrt n)-O(q)$ 次数的单点加区间查操作，之前一直不会这里结果最近才知道 kdt 常数太大，直接分块维护这里的操作就行了~~毕竟时间复杂度瓶颈不在这里~~。             

由此我们得到了一个时间复杂度 $O((n + q) \sqrt n)$，空间复杂度 $O(n)$ 的做法。

后来翻了题解，知道原来有一种更 trick 的维护单点加区间查操作：将普通的分块视为一种树高为 $2$ 的 $\sqrt n$ 叉树，其维护单点加区间查操作的理论时间复杂度为 $O(2) - O(\sqrt n)$。          

写成一般的形式，如果是一棵 $x$ 叉树，记对于一个大小为 $n$ 的序列形成的树高为 $h(n)$，有如下递推式：           

$$ h(n)=\left\{
\begin{aligned}
h(n)=1,n \leq x\\
h(n)=h(\frac{n}{x})+1,n > x
\end{aligned}
\right.
$$

不难发现运用换底公式，$h(n) = \frac{\log n}{\log x}$，而我们每次单点修改就相当于从根走到每个点在每层对应的节点时间复杂度为 $O(h(n))$，而区间查询就是 $h(n) - 1$ 层里对应的节点下的一个长为 $x$ 的序列，所以这样做后单点修区间查的时间复杂度为 $O(h(n)) - O(xh(n))$，在这道题里面可以拿来平衡理论时间复杂度例如你把 $x$ 取成 $n ^ {\frac{1}{4}}$ 后，$h(n) = 5$，最后得出的理论时间复杂度为 $O(5n\sqrt n + 85q)$。

upd:2021/11/24

经 lxl 的提醒，在计算理论时间复杂度时应注意：kdt 的常数大只是和 kdt 有关，然而实际上落到数据结构维护上的只是修改次数，其并不伴随着 kdt 的常数，所以将分块改成多叉树虽然在理论时间复杂度上较优，但是从本质上还是改变不了 kdt 的大常数，最后跑下来个人感觉两者应该差不了太多，有兴趣的同学可以去实现一下这个多叉树写法。