## Solution

本人太菜了，以至于不看标签不知道这是状压。

定义 $f_{i,S}$ 记录到第 $i$ 个位置时，它可以填的数与下标的差值的集合的答案。

我们发现这个差值的绝对值不超过 $d$，$d \le 5$ 所以最多只有 $11$ 种，状态压缩必然可行。

现在考虑如何转移。

首先我们枚举位置 $i$ 和集合 $S$。这里的集合 $S$ 指的是上一个位置，即 $i-1$ 时填的数的集合。

然后我们枚举该位置上能填的数：考虑枚举差值：
- 因为保证 $p$ 是一个排列，所以第 $i$ 个位置选的数一定不能在集合 $S$ 中存在；
- 需要保证现在选的数时可以选到的，即要么这个位置随意填数，要么这个位置本来就是要填的数；
- 保证不能越界。

满足以上条件之后，就可以进行状态转移了。方程为：
```cpp
f[i][(j | (1<<(d+k))) >> 1] = (f[i][(j | (1<<(d+k))) >> 1]+f[i-1][j])%mod
```
解释一下:

现在我们要对第 $i$ 个阶段进行决策，它的答案取决于我们所枚举的上一个阶段与那个集合对应的状态即 $f_{i-1,S}$（代码中用`j`）。

我们刚才枚举了一些差值，从中的到了一些合法的差值，这些差值在 $i-1$ 时没用过，现在要用了，所以就位运算把那一位变成 $1$（基本的操作了）。又因为我们的集合 $S$ 是 $i-1$ 的，所以对于现在的阶段 $i$，其每一个差值都要减小 $1$，那么右移一下即可。

## AC code:

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 505,mod = 998244353;
int n,d;
int a[N],f[N][2000];
int main(){
	cin >> n >> d;
	for(int i = 1;i <= n;i ++)cin >> a[i];
	f[0][0] = 1;
	for(int i = 1;i <= n;i ++)
		for(int j = 0;j < 1<<(d+d+1);j ++){
			if(!f[i-1][j])continue;
			for(int k = -d;k <= d;k ++)
				if((j>>(d+k)&1) == 0 && (a[i] == -1 || a[i] == k+i) && k+i <= n && k+i >= 1)f[i][(j | (1<<(d+k))) >> 1] = (f[i][(j | (1<<(d+k))) >> 1]+f[i-1][j])%mod;
		}
	cout << f[n][(1<<d)-1] << endl;
	return 0;
} 
```