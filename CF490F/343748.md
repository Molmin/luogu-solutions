## 法一 

枚举每个节点当作起点，DFS下去，采用单调栈，动态维护起点到目前点的单调栈，在链上更新最长上升子序列


时间（O(n^2log(n))）
由于数据太水n<=6000 方法可行


## 法二
那能不能对其进行优化呢？

在这里我们进行启发式合并。

把一条路径u,v分别到他们的lca节点

从根开始dfs，对于每个点维护两个单调栈，一个上升子序列，一个下降子序列
在rt节点处，在每次子节点合并前，我们先用小的上升子序列在大的下降子序列中进行二分，求出经过rt的路径中的最长上升子序列（分两种情况讨论，选rt和不选rt）

然后将两个子树的单调栈启发式合并（用size小的更新size大的）

最后用rt点更新单调栈



### 复杂度分析
1）启发式合并每个点最多合并log(n)次而考虑每个点每合并一次
共合并n*log（n）次

2）每次合并需要log(n)的时间（二分）

时间复杂度：O(nlog^2(n)）而且常数极小





