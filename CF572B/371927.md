本文作者把这道题能踩的坑全都踩了一遍，所以特此来写这一篇题解，希望大家不要像我一样调那么久。

题意我认为翻译说的很明确了，我就不再阐述了。

本题是一个纯模拟题。我看到其他题解都用了结构体啊，排序啊，数据结构啊。本蒟蒻的这篇题解是纯用数组模拟出来的，所以新手可以放心看。

因为没有任何的技巧，所以有些步骤会比较繁琐，但是我都会详细解释。

首先是读入。我们可以运用桶的思想，开一个 $s$ 数组，用来存所有卖出的数量。再开一个 $b$ 数组，用来存所有买入的数量。只要在读入中把所有 $p$ 相同值加起来，合并这一步也就完成了。

注意在进行读入买入的时候，可取一下 $p$ 的最大值，方便之后从后往前枚举。也一定要统计一下每种操作后多少种不同的 $q$ 值，为了防止 $s$ 的值多于数据种数时或者没有某种操作时的输出溢出。

第二步就是输出答案了。

首先是对于 $s$ 的操作，我们要找到最小的倒序输出。我们可以正着枚举，之后把答案存到数组中，最后进行输出。

接着是对于 $s$ 的操作，我们要找到最大的倒序输出。我们这时候直接倒着枚举倒着输出即可。

输出的时候由于是数组，会溢出，我们判断一下输出的值是否溢出了，再进行输出。

细节很多，但是完结撒花！

```
#include<bits/stdc++.h>
using namespace std;
const int maxn=1e6+7;
int s[maxn],b[maxn];
int ans1[maxn],ans2[maxn];
int main(){
    int n,s1;
    cin>>n>>s1;
    int maxb=-1;
    int ss=0,bb=0;
    while(n--){//读入，并且进行统计操作
        int p,q;
        char opt;
        cin>>opt;
        cin>>p>>q;
        if(opt=='S'){
            if(s[q]==0)ss++;
            s[p]+=q;
        }
        if(opt=='B'){
            if(b[q]==0)bb++;
            maxb=max(maxb,p);
            b[p]+=q;
        }
    }
    int ls=0,lb=0;
    int i=1;
    int j=1;
    if(ss>0){//防止没有操作溢出
        int y=min(s1,ss);//防止操作数比数据种数多
        while(ls!=y){
            if(s[i]!=0){
                ans1[j]=i,ans2[j]=s[i],j++;
                ++ls;
            }
            ++i;
        }
        for(int k=j-1;k>=1;--k){
            if(ans1[k]<1000001)cout<<"S "<<ans1[k]<<" "<<ans2[k]<<endl;
        }
    }
    if(bb>0){//这里同理
        int y=min(s1,bb);
        i=maxb;
        while(lb!=y){
            if(b[i]!=0){
                if(i>=0)cout<<"B "<<i<<" "<<b[i]<<endl;
                ++lb;
            }
            --i;
        }
    }
    return 0;
}
```



