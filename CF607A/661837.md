## [题目翻译](https://www.luogu.com.cn/paste/u1ku4ioc)

凭感觉来讲，这题应该是 DP，事实上也确实如此。但看了看数据范围，发现是 $10^{6}$ 甚至 $10^{5}$ 的级别，我们需要想出一种近似 $O(n)$ 的算法才行。

可以从两个角度入手：一个基于所有的信标（$10^{5}$），一个基于所有位置（$10^{6}$），这里我选择前者。

既然是 $O(n)$ 算法，那么 DP 数组也应该是一维的。所以设 $dp_{i}$ 为以第 $i$ 个信标为最右端时所摧毁的信标总数。题目中是从右至左激活信标，那么如果也从右至左进行状态转移，就会发现左边的状态很难获得，所以为了方便，我们应当从左往右做状态转移。

首先明确初始情况：当只有一个信标或者根本没有信标时，不会有信标被摧毁，所以 $dp_{0}=dp_{1}=0$。

然后看看如何状态转移：对于第 $i$ 个信标，设其向左共能摧毁 $x$ 个信标，那么就有 $dp_{i}=dp_{i-x-1}+x$。
摧毁了 $x$ 个信标，那么左侧剩下的最右端就应该是第 $i-x-1$ 个信标，所以将第 $i-x-1$ 个信标做最右端的摧毁总数加上新摧毁的 $x$ 个，就得到了第 $i$ 个的数据。

每一个信标的 $x$ 怎么得到？提前预处理一边求出即可。为了快速处理，我使用了二分来辅助。

最后别忘了还有个东西：需要在最右端加上一个信标。题目并没有限定其位置与威力，所以其作用实际上就是摧毁最右端开始的连续若干个信标。那么在最后记录答案时，只需要求得 $\min\limits_{i=1}^{n}{(dp_i+n-i)}$ 即可。
将每个信标都作为一次最右端，右边其它的信标都视作被新信标摧毁，两者的和取最小值就是答案了。

以下为代码：

```
#include <cstdio>
#include <cstdlib>
#include <algorithm>
using namespace std;
const int N=1e5+9;
struct node //设置一个结构体是为了方便排序
{
    int a,b;
    friend bool operator < ( node u , node v )
    { return u.a<v.a; }
}d[N];
int n,a[N],b[N],x[N],dp[N];
int main()
{
    scanf("%d",&n);
    for ( int i=1 ; i<=n ; i++ )
        scanf("%d %d",&d[i].a,&d[i].b);
    sort(d+1,d+1+n); //别忘了排序，别被样例骗了
    for ( int i=1 ; i<=n ; i++ )
    {
        a[i]=d[i].a,b[i]=d[i].b; //把a，b的值换回来
        x[i]=i-(lower_bound(a+1,a+1+i,a[i]-b[i])-a); //求得x的值
        dp[i]=dp[i-x[i]-1]+x[i]; //与之后的值无关，所以一并写了
    }
    int Min=999999999;
    for ( int i=1 ; i<=n ; i++ )
        Min=min(Min,dp[i]+n-i); //求得最小值
    printf("%d\n",Min);
    return 0;
}
```

至于基于位置的写法其它题解有，这里就不介绍了。