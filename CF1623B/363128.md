# CF1623B

## 思路

提示1：考虑 Bob 选取的每个数字是在哪个 Alice 选择过的区间中被选择的。

提示2：数字 $i$ 一定是在包含数字 $i$ 的**最小区间**被选取的。

## 证明（反证法）：

* 假设在包含数字 $i$ 的最小区间为 $[l, r]$，选取的不是数字 $i$。
* 分裂出的区间包含数字 $i$，分裂前的区间 $[l, r]$ 不是最小区间，矛盾。
* 因此必须在包含数字 $i$ 的最小区间为 $[l, r]$ 选取数字 $i$。

## 算法思路

* 枚举 Bob 要选择的数字 $i$
  * 枚举 Alice 选择的所有区间
    * 找到包含数字 $i$ 的最小的区间 $[l, r]$，输出 $l, r, i$

## 代码
```
const int N = 1000;
 
int n;
int l[N], r[N];
 
void Solve() {
  cin >> n;
  for (int i = 0; i < n; i++) {
    cin >> l[i] >> r[i];
  }
  for (int i = 1; i <= n; i++) {  // 枚举 Bob 要选择的每个数字
    int len = n + 1, pos;  // len 表示最小区间长度，pos 表示最小区间下表
    for (int j = 0; j < n; j++) {  // 枚举 Alice 选择的每个区间
      if (l[j] <= i && i <= r[j] && r[j] - l[j] + 1 < len) {  // 如果区间包含数字 i并且区间更小
        len = r[j] - l[j] + 1;
        pos = j;
      }
    }
    cout << l[pos] << ' ' << r[pos] << ' ' << i << endl;
  }
}
```
