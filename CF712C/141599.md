这道题给定两个等边三角形,在每次修改边后保证三条边仍然能构成三角形,求最小修改数使得一个三角形变成另一个三角形

我们假设 $m$ $＜$ $n$,将三条边排序后,找到最小的边进行修改

这时我们可以将修改分为两种情况:

1. 其余两条边的和减去$1$大于$n$

这时我们将最小的边赋值为$n$

2. 其余两条边的和减去$1$小于或等于$n$

这时我们将最小的边赋值为其余两条边的和减$1$即可

减$1$时因为两边之和大于第三边,而不是大于或等于

这时我们可以发现已经得出了最小操作的次数

因此有如下代码:

```
#include<bits/stdc++.h>
using namespace std;
int main(){
	int n,m,a[4],b[4],ans=0,k;
	scanf("%d%d",&n,&m);
	a[1] = a[2] = a[3] = m;//m<=n
	while(!(a[1]==n && a[2]==n && a[3]==n)){
		ans++;
		sort(a+1,a+1+3);//将3条边从小到大排序
		if(a[2]+a[3]-1>n){//上述第一种情况
			a[1] = n;
		}
		else{//上述第二种情况
			a[1] = a[2]+a[3]-1;
		}
	}
	cout<<ans<<endl;
}
```
