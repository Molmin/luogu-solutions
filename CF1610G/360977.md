可以发现一个有趣的性质，就是如果一组 $()$ 最终被删去，那它中间的东西也必须全部删去，不然字典序一定不优，根据这个性质，我们便可以推断出左括号 $i$ 对应删去的右括号，一定是从 $i$ 开始往后第一个满足构成合法括号序列的位置 $nxt_i$。这样，我们便可以钦定一个删的顺序了，考虑从后往前 dp，设 $f_i$ 表示从 $i$ 开始的整个后缀能被删成的字典序最小的字符串。那么

$$f_i=\min(f_{nxt_i},s_i+f_{i+1})$$

暴力做这个 dp 是 $O(n^2)$ 的，考虑去优化。发现这个复杂度很劣的一个原因是字符串比较字典序的复杂度很劣。考虑将字符串 hash 一下，并把每个 $f_i$ 插入到 trie 树中去，同时记录每个点往上跳 $2^i$ 步组成字符串的 hash 值，可以发现，每个 $f_i$ 至多会在原本的 trie 树中增添一个字符，考虑将 $s_i$ 插入到 $f_{i+1}$ 的后面后直接拿这个位置和 $f_{nxt_i}$ 比，具体地，我们在 trie 树上根据 hash 值倍增，找到第一个不同的位置比大小即可。时空复杂度均为 $O(n \log n)$。

Tips:
1. 倍增时要注意不要跳出了字符串。
2. 字符串比较次数多，请选用较大模数或直接自然溢出。

[Code](https://codeforces.com/contest/1610/submission/211889139)