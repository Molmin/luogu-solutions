经典简单数据结构藏后面

考虑一对被删掉的$()$，在它们之间的所有字符一定也被删掉了。

因此问题可以转化成从括号串中选取若干段不交的合法子串并删除

考虑倒序dp，设 $f_i$ 表示 $i$ 到 $n$ 之间的字符作为原括号串的答案串

转移讨论是否删第 $i$ 个字符，不难发现这样定义状态可以将一次删掉合法子串的操作分解成多次，因此如果删 $i$ 必定选取 $i$ 后第一次合法的前缀删除。

后者不难用单调栈求出，设为 $nxt_i$。有 $f_i = \min(S_i+f_{i+1},f_{nxt_i})$

比较字典序大小不难想到哈希，直接上主席树维护是两只 $\log$ 的

容易发现字符串之间的关系是树形的。问题转化为维护一个 trie 树，每次添加一个叶子或者询问两个树上的字符串倒序的字典序关系

这个问题直接在祖先上倍增跳并前缀和相减求哈希值即可

时间复杂度 $O(n\log n)$