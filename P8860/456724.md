前排提醒：本题解涉及超纲（相对“提高级”而言，并且超纲超的有点过）内容，并且暂时没有进行实现，但正确性是可以保证的，大概。

简化题意：给定一张 $n$ 个点 $m$ 条边的无重边 DAG 以及 $q$ 次询问，每次询问给出仍存在于当前 DAG 的一条边，询问删掉后是否仍存在一条结点 $1$ 到结点 $n$ 的路径，是则返回 $1$ 并进行删边（永久性删除，即影响后续询问），否则仅返回 $0$，不对原 DAG 进行改动。

首先发现：图中重要的边与点只有全部构成 $1$ 到 $n$ 路径的，因此可以一次 DAG DP 求出所有点能够到达的最大结点标号，之后按照这个标号抠出来一张生成子图，满足：仅有点 $1$ 无入度，点 $n$ 无出度，其他的所有点与边都是某条 $1$ 到 $n$ 路径的一部分。这一步其实并不是必要的，只是为了方便理解与后续思考。

对这张生成子图求出任意一颗 DFS 有向生成树，这颗树维护的是原图中若干条路径，另外的一些路径通过横叉边维持，不在这颗树上维护。此时，存在路径 $x \to y$ 的充要条件变为 $x$ 是这颗树上 $y$ 的祖先。

接下来考虑删掉一条边，它要么是树边要么是横叉边，后者由于不在树上维护，直接删除即可。

重点在于删掉一条树边时对连通性的变动：设这条边为 $u \to v$，此时如果没有任何横叉边的话，子树 $v$ 中所有结点都将无法在从 $1$ 出发时到达，因此它们失去了存在于生成树上的意义（生成树上的对应点什么的，已经不存在了。因为已经没有任何相关路径，去要维护了。），删了就行。

把横叉边加上，第一点就是如果删掉的子树有横叉边，就删掉这条横叉边，但不要跑到它的终点上删子树，因为只是破坏了横叉边维护的可达关系，生成树维护的路径不一定被破坏。之后发现：如果要被删掉的子树的某个点存在未被删除的横叉入边，说明仍然有其他路径可以从 $1$ 到达这个点，而未被删除的横叉入边的起点一定是生成树上的一个点，因为按照前文提到的删除条件，横叉入边的起点如果被删了那么它一定一起被删了。

此时就好办了：删除父亲树边后停止对该点的递归删除，任选一条横叉入边变成树边，该点的父亲变为横叉入边的起点，因为原来是一颗树，以上操作相当于换了父亲，还是一棵树。如果这次删除合法，这次删除删去的其他边可以在删掉这条边之后的任意时刻被删除。

那么，这个算法维护生成树的正确性就显然了：删边时要么破坏了当前维护的路径要么破坏了其他路径，对于后者相当于删了横叉边，对于前者相当于把横叉边换成了树边继续维护可达性（路径），再被删的时候接着维护就可以了。觉得不对劲的话，如果有一条路径全是横叉边构成的，当原图只有这条路径时，这些横叉边已经全部变成了树边。时间复杂度上，每个点被删除的最大次数是其入度，显然总和为 $O(n)$ 级别）。

那么问题来了：怎么判断一条边能不能删？

当前 DFS 生成树维护的是原图的一条路径，删树边相当于直接破坏所维护的路径，结合之前提到的性质，我们可以发现：当删掉树上路径 $1\to n$ 中的一条边，设其终点为 $u$，当且仅当 DFS 生成树上路径 $u\to n$ 中存在某个点有未被删去的横叉入边时，这条边可以删去。这样就保证了所有已经进行了的删除操作的合法性，被删掉的其他边可以在这次操作之后的任意时刻被删去，因为不对当前以及以后维护的路径造成影响。

至于维护换父亲和关键路径上是否存在横叉入边，上 LCT。前者显然，后者额外开个哈希表什么的维护横叉边集合辅助在 LCT 上的修改，之后树链上维护一下就行了。话说都看到这里了，应该都发现了：这颗 DFS 生成树是对于所有路径任选一条维护，不就像 LCT 里的实链剖分吗？

注意换父亲的时候维护儿子都有谁（一般情况下单纯的 LCT 难以维护子树信息），可以拿哈希表或者动态开点线段树维护儿子集合， DFS 时对着这个儿子集合遍历即可。

总时间复杂度大概是 $\Theta((q+n)\log n)$，貌似比官方少一个 $\log$，但算法超纲，估计还更难码，如标题所言，是个令人眼前一黑的解法。

实现的话笔者因为一些意外退役了，没工夫写，就公开乞讨一份吧（bushi 等有时间了尽量去补。

另外问一下正解......是 HASH 加主席树的话，主席树不是 NOI 级算法吗（归属于可持久化数据结构，大概）。

另：感谢管理员耐心指出错误，这篇题解前后送审了有四五次大概，~~算不算骚扰管理啊~~总之太感谢了。