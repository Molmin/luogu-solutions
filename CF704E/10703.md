套路树链剖分，然后观察一条链的情况：

有一个数轴，上面会有点突然出现，然后移动，最后消失，问最早的两点重合的时间。

把所有链的时间取 $\min$ 即可得到答案。

对于一个数轴，我们把时间维也显示出来，然后画出每个点的“世界线”（物体在时空中的轨迹）。

可以发现，每个点的轨迹都是一条线段，只要算出在时间维度上的最早的交点即可。

![](https://cdn.luogu.com.cn/upload/image_hosting/86md2pd2.png)

如图，这是样例 #1 的情况，考虑的重链为 $1 - 4 - 6 - 5 - 2$ 这条，答案为 $27.3$。

我们看一下交点附近的细节：

![](https://cdn.luogu.com.cn/upload/image_hosting/ueslnvnu.png)

到底要怎么找到并确定这个交点的坐标呢？如果两两判断那必然是不行的，而且交点确实也可能有 $\mathcal O (m^2)$ 个。

从“找到**最早的**交点”出发，我们考虑按照时间从小到大做扫描线。

考虑这样的一个“第一个交点”，我们可以发现，交出它的两条线段，一定在之前的某一个时刻，是相邻的。

也就是说，不可能之前的每个时刻都有至少一条线段挡在它们之间，考虑反证法显然。

那么我们只需要动态维护在扫描线过程中的，相邻线段的交就行了。

扫描线无非就是加入一条线段，删除一条线段，也就是说只要维护加入和删除的时候的旁边两条线段就行。

那么最终只有 $\mathcal O (m)$ 对相邻线段，这是很重要的一步转化。

那么我们需要一个合适的数据结构来寻找相邻线段并能够维护加入删除线段。

令人意想不到的是，我们的 set 居然就满足条件。set 中存当前的线段，但是排序方式怎么办呢？

我们使用一个全局变量 $T$ 来控制线段在 $t$ 时刻下的横坐标位置，然后使用横坐标位置排序即可。

因为只要没有交点，线段之间的相对位置就不会改变，这是不会触发 set 的未定义行为的。

当然，如果 $T$ 已经大于等于当前求出的交点时刻，就要及时退出，不要调用 set，以免触发 UB 导致不好的结果。

要注意的是，也不要一求出交点就退出，第一个求出的交点不一定是最早的交点。

时间复杂度为 $\mathcal O (m \log m \log n)$，[评测链接](https://codeforces.com/contest/704/submission/72851525)。