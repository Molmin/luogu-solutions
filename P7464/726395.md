## 题意

本题重在理解题意。

$\mathcal{Part1}$：一个没有面是正方形的长方体意味着什么？每一个长方体都有 $12$ 条棱，而其中分成 $3$ 组每组 $4$ 条分别相等，也就是说总共有 $3$ 种棱长，而其中 $6$ 个面两两相等，有 $3$ 种不同形状，也就是说 $3$ 种形状是由 $3$ 种棱长排列组合而成，又正方形是邻边相等的长方形，所以 **$3$ 种棱长两两不等**。

$\mathcal{Part2}$：长方体体积小于一个定值意味着什么？长方体的体积等于 $3$ 种棱长的乘积，也就是说**要保证 $3$ 种棱长乘积 $\leq N$**。

#### 于是总结得到，我们要做的实际上就是枚举 $3$ 个不同的数，保证它们乘积 $\leq N$。

## 思路

楼上大佬用的 dfs，我本来用的也是，但是介绍一下~~对萌新更友好的~~纯暴力方法。其实就是 dfs 的摊开，因为选数数量确定，考虑**三重循环预处理**：

```cpp
for ( ll i = 1; i < 1000005; i++ )
	for ( ll j = i + 1; i * j < 1000005; j++ )
		for ( ll k = j + 1; i * j * k < 1000005; k++ )
			p[i * j * k]++;
```

枚举每一组边长，注意每一次从上一条边**加一**开始枚举可以保证**不重不漏**。当枚举完 $3$ 个数时放进**桶数组中计数**。

然后进行[前缀和](https://www.luogu.com.cn/blog/ztntonny/qian-zhui-hu-jian-shu)，计算小于等于下标的符合数对数量：

```cpp
for ( int i = 0; i < 1000005; i++ )	p[i] += p[i - 1];
```

然后就可以简单的输入，输出对应前缀和，代码：

```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
ll n , p[1000005] , ans , cmp , m , jug , k , num[1000005];
int main()
{
	cin >> n;
	for ( ll i = 1; i < 1000005; i++ )
		for ( ll j = i + 1; i * j < 1000005; j++ )
			for ( ll k = j + 1; i * j * k < 1000005; k++ )
				p[i * j * k]++;
	for ( int i = 0; i < 1000005; i++ )	p[i] += p[i - 1];
	for ( int i = 1; i <= n; i++ )
	{
		cin >> k;
		cout << p[k] << endl;
	}
	return 0;
}
```