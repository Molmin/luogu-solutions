## 题意简化

求一个旋转圆形环道从一个位置到另一个位置的最小时间。

## 需要注意的地方

1. 日本题目记得输出加换行 

1. 在圆形环道上必须移动，不管你顺时针和逆时针走。

## 解法分析

该说什么呢？这道题是道水黄，全都是因为翻译问题导致通过率如此惨淡（本人亦为受害者）。

纯纯的模拟，我们首先看题。这个圆形环道很烦，那就化曲为直！就像这样：

![](https://cdn.luogu.com.cn/upload/image_hosting/5zz2onhy.png)

是不是好理解多了？

根据题意也就能知道，到达指定点有两种走法：逆时针走和顺时针走。指定点与目标点也分两种：指定点坐标比目标点小和指定点坐标比目标点大。

时间公式是 $t=\dfrac{v}{s}$。

我们先考虑指定点坐标比目标点小的情况：

第一种就是顺时针走，那么速度就是步行速度加上步行道速度，距离就是 $D-S$。第二种是逆时针走，那么速度就是步行速度减上步行道速度，距离就是 $L-D+S$，也就是反着走，**前提是步行速度大于步行道速度，要不然不就被兜着走了**。

于是这部分的代码就是这个样子：

```cpp
if(S<=D){//目标点大于等于起始点 
    T=(D-S)/(X+Y);//普通顺时针走法 
    if(Y>X) T=min(T,(L-D+S)/(Y-X));//逆时针走法，前提是步行速度大于步行道速度 
}
```

---

再考虑指定点坐标比目标点大的情况：

第一种仍是顺时针走，那么速度扔是步行速度加上步行道速度，但距离是 $L-S+D$，毕竟就是先走回 $1$，接着走到 $L$，再走到 $D$。第二种是逆时针走，那么速度就是步行速度减上步行道速度，距离就是 $S-D$，毕竟是倒着走吗，**前提依旧是步行速度大于步行道速度，要不然不就被兜着走了**。

于是这部分的代码就是这个样子：

```cpp
else{//否则 
    T=(L-S+D)/(X+Y);//普通顺时针走法 
    if(Y>X) T=min(T,(S-D)/(Y-X));//逆时针走法，前提是步行速度大于步行道速度 
}
```


最后说一句，我比较推荐万能头文件，这样可以省去很多不必要的麻烦。

## 完整代码

```cpp
//已通过
#include<bits/stdc++.h>
//万能头文件
using namespace std;
double L,X,Y,S,D,T;//小数除法开double 
int main(){
    cin>>L>>X>>Y>>S>>D;
    if(S<=D){//目标点大于等于起始点
        T=(D-S)/(X+Y);//普通顺时针走法 
        if(Y>X) T=min(T,(L-D+S)/(Y-X));//逆时针走法，前提是步行速度大于步行道速度 
    }
    else{//否则 
        T=(L-S+D)/(X+Y);//普通顺时针走法 
        if(Y>X) T=min(T,(S-D)/(Y-X));//逆时针走法，前提是步行速度大于步行道速度 
    }
    cout<<setprecision(10)<<T<<endl;//保留到十位小数，记得换行 
    return 0;
}
```