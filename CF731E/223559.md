### 解题思路：

博弈 DP。

首先这是一个零和博弈，即一方的收益必然意味着另一方的损失。对于这样的问题，考虑用动态规划求解。

发现这个游戏是对称的，无论是谁先取，对于同样的一个情形双方做出的决策和最终的差值都是一样的。

设 $f_i$ 表示从 $i$ 开始到最后先手玩家和后手玩家所能拉开的最大得分差值（对于这道题，双方的具体分数显然是可以忽略的，只需要考虑双方分数差就可以了）。

然后考虑如何转移，对于每一个 $f_i$ 他都可以取任意量的数，从而从后面任意一个 $f_j$ 转移过来，若这样做最终得到的分数差值应当是 $\sum_{k=1}^{j}a_k-f_j$。

但如果单纯这样做，复杂度是 $O(n^2)$ 的，是不能通过的。

那就考虑一个小优化，由于每一次的转移只和自身有关（换言之，就是不和转移到那边去有关），那么就直接记录下当前最大的 $\sum_{k=1}^{j}a_k-f_j$ ，直接转移，再和新的可能的最大值，即 $\sum_{k=1}^{i}a_k-f_i$ 比较即可。

-------------
但其实这题并不需要真的弄一个 $f$ 数组，观察到，每一个的答案都不会比之前（数组意义上的之后）的答案更差，所以只需要一直记录下当前的最优答案就可以了。

-------------
### 代码：
```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
long long,n,a[200005],ans;
int main(){
	scanf("%lld",&n);
	for(int i=1;i<=n;i++){
		scanf("%lld",&a[i]);
		a[i]+=a[i-1];
	}
	ans=a[n];
	for(int i=n-1;i>=2;i--)
	ans=max(ans,a[i]-ans);
	printf("%lld",ans);
	return 0;
}
```

