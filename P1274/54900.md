觉得这题题目出的有点问题，样例输出没有那么少的。
这道题目的正解是**搜索(DFS)+剪枝**，可能比较难看，请见谅。。

1.普通搜索

先把该点所在的位置赋为1，从(1,1)到(4,4)不停的放，之后判断可行性，于是算法复杂度就是O(15!)（超时）。

那我们怎么优化加速呢？

**可行性剪枝**呗(这里不存在最优性剪枝)

2.搜索+剪枝

每次搜索都判断(放在代码中的check)当前所放元素是否可行，可以判断的标准有：
左上角的2*2方格，右上角的2*2方格，左下角的2*2方法，中央的2*2方格，第一行，第二行，第三行，第一列，第二列，第三列，左下角到右上角；

最后矩阵放完了可以判断(代码中的Fjdge)的标准有：
四个角落，右下角2*2方格，第四行，第四列，左上角到右下角。这些都用到了(4,4)，所以要到最后再判断。

这种方法应该是能过的。有更优的方法或题解的错误，请在讨论区留言。

提供有注释的AC代码，较短：
```cpp
#include <bits/stdc++.h>
using namespace std ;
int a[10][10],vis[20],n,m ;
int Fjdge(){ //最后的判断，Final Judge 

	if (a[1][1]+a[1][4]+a[4][1]+a[4][4]!=34) return 0 ;//四个角落 
	if (a[3][3]+a[3][4]+a[4][3]+a[4][4]!=34) return 0 ;//右下角2*2方格 
	if (a[4][1]+a[4][2]+a[4][3]+a[4][4]!=34) return 0 ;//第四行 
	if (a[1][4]+a[2][4]+a[3][4]+a[4][4]!=34) return 0 ;//第四列 
	if (a[1][1]+a[2][2]+a[3][3]+a[4][4]!=34) return 0 ;//左上角到右下角
	return 1 ; 
}
int check(int x,int y){ //剪枝 

	if (x>2 || x==2 && y>=2) if (a[1][1]+a[1][2]+a[2][1]+a[2][2]!=34) return 0;//左上角的2*2方格  
	if (x>2 || x==2 && y==4) if (a[1][3]+a[1][4]+a[2][3]+a[2][4]!=34) return 0;//右上角的2*2方格 
	if (x==4 && y>=2) if (a[3][1]+a[3][2]+a[4][1]+a[4][2]!=34) return 0 ;//左下角的2*2方法 
	if (x>3 || x==3 && y>=3) if (a[2][2]+a[2][3]+a[3][2]+a[3][3]!=34) return 0 ;//中央的2*2方格 
	if (x>1 || x==1 && y>=4) if (a[1][1]+a[1][2]+a[1][3]+a[1][4]!=34) return 0 ;//第一行 
	if (x>2 || x==2 && y>=4) if (a[2][1]+a[2][2]+a[2][3]+a[2][4]!=34) return 0 ;//第二行 
	if (x>3 || x==3 && y>=4) if (a[3][1]+a[3][2]+a[3][3]+a[3][4]!=34) return 0 ;//第三行 
	if (x==4 && y>=1) if (a[1][1]+a[2][1]+a[3][1]+a[4][1]!=34) return 0 ;//第一列 
	if (x==4 && y>=2) if (a[2][1]+a[2][2]+a[2][3]+a[2][4]!=34) return 0 ;//第二列 
	if (x==4 && y>=3) if (a[3][1]+a[3][2]+a[3][3]+a[3][4]!=34) return 0 ;//第三列 
	if (x==4 && y>=1) if (a[1][4]+a[2][3]+a[3][2]+a[4][1]!=34) return 0 ;//左下角到右上角 
	return 1 ;
} 
void dfs(int x,int y){ //表示准备放i,j 
	if (x==5 && y==1){  //搜索结束,判断没有问题的话，就可以输出了 
		if (Fjdge()==1){
			for (int i=1;i<=4;i++){ 
				for (int j=1;j<=4;j++) printf("%d ",a[i][j]) ;
				printf("\n") ;
			}
			printf("\n") ;
		}
	}
	
	if (a[x][y]!=0){  //当前节点已被固定为1 
		if (y==4) dfs(x+1,1);
		else dfs(x,y+1) ;
	}
	else {
		if (y==1){
			x--;y=4 ;
		}
		else y-- ;
		if (!check(x,y)) return ; 
		if (y==4){
			x++;y=1 ;
		}
		else y++ ;
		for (int i=2;i<=16;i++)
		if (!vis[i]) {
			vis[i]=1;a[x][y]=i ;
			if (y==4) dfs(x+1,1) ;
			else dfs(x,y+1) ;
			a[x][y]=0;vis[i]=0 ;
		}
	}
	
}
int main(){
	scanf("%d%d",&n,&m) ;
	a[n][m]=1;vis[1]=1 ; 
	if (!(n==1 && m==1)){
		for (int i=2;i<=16;i++){
			a[1][1]=i;vis[i]=1;
			dfs(1,2);//表示准备放i,j
			vis[i]=0;a[1][1]=0;
		}	
	}
	else dfs(1,2) ;
	return 0 ;
}
```