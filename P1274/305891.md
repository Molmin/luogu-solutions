# 1 题目简介
[P1274 魔术数字游戏](https://www.luogu.com.cn/problem/P1274)

**题目大纲**

有一个 $4×4$ 的方格。有以下几点要求：
- 每行每列数值之和之和必须为 $34$ 。
- 两条对角线数值之和之和必须为 $34$ 。
- 中间 $2×2$ 的正方形数值之和必须为 $34$ 。
- 边角 $2×2$ 每个正方形数值之和必须为 $34$ 。
- 四个角落上的格子数值之和必须为 $34$ 。

先要将 $1-16$ 共 $16$ 个数填进方格中。已给出 $1$ 的位置，要求按照字典序输出所有的解法。

**题目难度** 

内容（搜索->深度搜索优先）|实际难度
:-:|:-:
思路难度|丙
DFS难度|丙
剪枝难度|戊
总难度|丁
# 2 思路分析
写完这一题，看到网站里大佬们的题解与蒟蒻的题解都不一样。蒟蒻的题解是先枚举完所有可能的情况，然后再加判断指定位置上是否是 $1$ 即可。

## 2.1 思路分析

好了，废话不多说，先说思路吧。本蒟蒻的想法是全部枚举。然后在加以判断就好了。把所有共 $16×15×14×…1=20922789888000$ 种情况全部枚举出来即可。然后再来判断有木有符合要求。所以，在 $DFS$ 函数中，我们就需要用到 $3$ 个流程。第 $1$ 个，就是呢，当前节点的判断。从 $1$ 枚举到 $16$ 。这也就是 $DFS$ 的一个重要的流程。第 $2$ 个，就是判断啦。判断每行每列，四角，每个正方形方格，对角线是否都满足数值之和为 $34$ 。
提前先说一下我们递归时的顺序。
![图1](https://img-blog.csdnimg.cn/20200814092922889.png#pic_center)
## 2.2 $DFS$

**递归操作**

好吧，开始导入 $DFS$ 吧。我们从第行第列枚举到第行第列，当递归到当前节点时，就要从 $1$ 到 $16$ 每个数字递归。这个操作是为什么呢？因为每一个节点都有可能储存 $1$ 到 $16$ ，所以执行操作。其实这部操作是简单的。当正常情况下，要调到下一个节点，只需要将行 $+1$ 即可，列不用动。然后需要进行一个小剪枝，就是把当前用过的数做上标记，然后每一步就不必再重复循环递归了。

```cpp
	for(int i=1;i<=16;i++){//从1枚举到16
		if(b[i])continue;
		b[i]=true;//把当前用过的数做上标记，表示已经用过了
		a[x][y]=i;//先解释一下，a数组是用来储存每一个节点储存的数
		//这一步操作就是把当前循环的数标记在当前节点位置上
		search_dfs(x,y+1);//递归下一节点，行加上1
		b[i]=false;//回溯，这一步操作已经过去，不必再标记
	}
```

**边界处理**

这里的边界处理其实很简单。如图，当循环至第 $2$ 列第 $5$ 行时，因为第 $2$ 列第 $5$ 行不在这个 $4×4$ 的方格中，那我们应该怎么办呢？
![图2](https://img-blog.csdnimg.cn/20200814092206807.png#pic_center)
对了，跳至下一行不就行了吗？下一行列需要加 $1$ ，行就变成 $1$ 。如果，出现这种情况，又怎么办呢？就是递归至第 $5$ 行第 $1$ 列时，又该怎么办呢？很容易想出来，若递归至第 $5$ 行第 $1$ 列时，前面的 $16$ 个方格固然已经填好，所以我们只要加以判断即可。首先我们根据方格里的条件进行判断。若不满足条件， $return;$ 。然后判断已经给我们的第 $x$ 行 $y$ 列是不是 $1$ 。如果上面条件全部满足，就输出。如此的简单！
```cpp
	if(y>4){
		search_dfs(x+1,1);
		return;
	}
	if(x>4){
		int sum1,sum2;
		sum1=sum2=0;//对角线
		for(int i=1;i<=4;i++){
			sum1+=a[i][i];//左上到右下，行列的数值相等
			sum2+=a[5-i][i];//左下到右上，行+列=5
		}
		if(sum1!=34||sum2!=34)return;//不满足条件，退出
		for(int i=1;i<=3;i+=2)for(int j=1;j<=3;j+=2){//顶点的四个方格的左上角坐标
			int sum=0;
			for(int k=0;k<=1;k++){
				for(int l=0;l<=1;l++){
					sum+=a[i+k][j+l];//加上和
				}
			}
				if(sum!=34)return;//不满足条件，退出
		}
		if(a[2][2]+a[2][3]+a[3][2]+a[3][3]!=34)return;//中间的正方形
		if(a[1][1]+a[1][4]+a[4][1]+a[4][4]!=34)return;//顶点的四个方格
		if(a[h][l]!=1)return;//给定的行和列
		for(int i=1;i<=4;i++){
			for(int j=1;j<=4;j++){
				cout<<a[i][j]<<" ";//输出
			}
			cout<<endl;
		}
		cout<<endl;//别忘了每一个解空一行
		return;//结束，之后都是边界，不必再次循环
	}
```
## 2.3 剪枝
**注意 ！！！** 这种算法的时间复杂度是 $O(n^{2n^{2}})$，有超时的风险（不是有风险，是一定会超时。实测，如果删掉AC代码中的任意一种剪枝，都会超时，爆0QwQ）。所以肯定要优化啦。这种算法固然不可以最优性剪枝，那，我们就来可行性剪枝吧！

注意到原题目的“每行每列数值之和之和必须为 $34$ ”其实是，以行为例，若循环至该行的第 $4$ 个结点，只需要判断 $34$ 减去前 $3$ 个同行的数字有没有用过就可以了，所以当前节点的时间复杂度由 $O(n^{2})$ 降至 $O(1)$ 。
```cpp
	if(x==4){//行
		if(!b[34-a[1][y]-a[2][y]-a[3][y]]&&1<=34-a[1][y]-a[2][y]-a[3][y]<=16){
			if(34-a[1][y]-a[2][y]-a[3][y]>16||34-a[1][y]-a[2][y]-a[3][y]<1)return;//这个数大于16或者小于1，肯定不行
			a[x][y]=34-a[1][y]-a[2][y]-a[3][y];//算出节点数值
			b[34-a[1][y]-a[2][y]-a[3][y]]=true;//标记，已经被用过了
			search_dfs(x,y+1);//递归下一个节点
			b[34-a[1][y]-a[2][y]-a[3][y]]=false;//回溯
		}
		return;
	}
	if(y==4){//列
		if(!b[34-a[x][1]-a[x][2]-a[x][3]]&&1<=34-a[x][1]-a[x][2]-a[x][3]<=16){
			if(34-a[x][1]-a[x][2]-a[x][3]>16||34-a[x][1]-a[x][2]-a[x][3]<1)return;//这个数大于16或者小于1，肯定不行
			a[x][y]=34-a[x][1]-a[x][2]-a[x][3];//算出节点数值
			b[34-a[x][1]-a[x][2]-a[x][3]]=true;//标记，已经被用过了
			search_dfs(x,y+1);//递归下一个节点
			b[34-a[x][1]-a[x][2]-a[x][3]]=false;//回溯
		}
		return;
	}
```
我们还注意到中间的 $2×2$ 的方格，因为 第 $3$ 列第 $3$ 行是最晚确定下来的，所以他的操作也可以像行和列的操作一样。同时观察到第 $2$ 列第 $2$ 行也是左上角 $2×2$ 的方格中最晚确定的格子，所以，我们也可以同样采用行和列的操作。代码就不做多的解释了，总之与前面一样。
```cpp
	if(x==3&&y==3){
		if(!b[34-a[2][2]-a[3][2]-a[2][3]]&&1<=34-a[2][2]-a[3][2]-a[2][3]<=16){
			if(34-a[2][2]-a[3][2]-a[2][3]>16||34-a[2][2]-a[3][2]-a[2][3]<1)return;
			a[x][y]=34-a[2][2]-a[3][2]-a[2][3]; 
			b[34-a[2][2]-a[3][2]-a[2][3]]=true;
			search_dfs(x,y+1);
			b[34-a[2][2]-a[3][2]-a[2][3]]=false;
		}
		return;
	}
	if(x==2&&y==2){
		if(!b[34-a[1][1]-a[2][1]-a[1][2]]&&1<=34-a[1][1]-a[2][1]-a[1][2]<=16){
			if(34-a[1][1]-a[2][1]-a[1][2]>16||34-a[1][1]-a[2][1]-a[1][2]<1)return;
			a[x][y]=34-a[1][1]-a[2][1]-a[1][2];
			b[34-a[1][1]-a[2][1]-a[1][2]]=true;
			search_dfs(x,y+1);
			b[34-a[1][1]-a[2][1]-a[1][2]]=false;
		}
		return;
	}
```

# 3 AC代码

```cpp
#include<iostream>
using namespace std;
int a[7][7],b[20],h,l;
void search_dfs(int x,int y){
	if(y>4){
		search_dfs(x+1,1);
		return;
	}
	if(x>4){
		int sum1,sum2;
		sum1=sum2=0;
		for(int i=1;i<=4;i++){
			sum1+=a[i][i];
			sum2+=a[5-i][i];
		}
		if(sum1!=34||sum2!=34)return;
		for(int i=1;i<=3;i+=2)for(int j=1;j<=3;j+=2){
			int sum=0;
			for(int k=0;k<=1;k++){
				for(int l=0;l<=1;l++){
					sum+=a[i+k][j+l];
				}
			}
				if(sum!=34)return;
		}
		if(a[2][2]+a[2][3]+a[3][2]+a[3][3]!=34)return;
		if(a[1][1]+a[1][4]+a[4][1]+a[4][4]!=34)return;
		if(a[h][l]!=1)return;
		for(int i=1;i<=4;i++){
			for(int j=1;j<=4;j++){
				cout<<a[i][j]<<" ";
			}
			cout<<endl;
		}
		cout<<endl;
		return;
	}
	if(x==4){
		if(!b[34-a[1][y]-a[2][y]-a[3][y]]&&1<=34-a[1][y]-a[2][y]-a[3][y]<=16){
			if(34-a[1][y]-a[2][y]-a[3][y]>16||34-a[1][y]-a[2][y]-a[3][y]<1)return;
			a[x][y]=34-a[1][y]-a[2][y]-a[3][y];
			b[34-a[1][y]-a[2][y]-a[3][y]]=true;
			search_dfs(x,y+1);
			b[34-a[1][y]-a[2][y]-a[3][y]]=false;
		}
		return;
	}
	if(y==4){
		if(!b[34-a[x][1]-a[x][2]-a[x][3]]&&1<=34-a[x][1]-a[x][2]-a[x][3]<=16){
			if(34-a[x][1]-a[x][2]-a[x][3]>16||34-a[x][1]-a[x][2]-a[x][3]<1)return;
			a[x][y]=34-a[x][1]-a[x][2]-a[x][3];
			b[34-a[x][1]-a[x][2]-a[x][3]]=true;
			search_dfs(x,y+1);
			b[34-a[x][1]-a[x][2]-a[x][3]]=false;
		}
		return;
	}
	if(x==3&&y==3){
		if(!b[34-a[2][2]-a[3][2]-a[2][3]]&&1<=34-a[2][2]-a[3][2]-a[2][3]<=16){
			if(34-a[2][2]-a[3][2]-a[2][3]>16||34-a[2][2]-a[3][2]-a[2][3]<1)return;
			a[x][y]=34-a[2][2]-a[3][2]-a[2][3]; 
			b[34-a[2][2]-a[3][2]-a[2][3]]=true;
			search_dfs(x,y+1);
			b[34-a[2][2]-a[3][2]-a[2][3]]=false;
		}
		return;
	}
	if(x==2&&y==2){
		if(!b[34-a[1][1]-a[2][1]-a[1][2]]&&1<=34-a[1][1]-a[2][1]-a[1][2]<=16){
			if(34-a[1][1]-a[2][1]-a[1][2]>16||34-a[1][1]-a[2][1]-a[1][2]<1)return;
			a[x][y]=34-a[1][1]-a[2][1]-a[1][2];
			b[34-a[1][1]-a[2][1]-a[1][2]]=true;
			search_dfs(x,y+1);
			b[34-a[1][1]-a[2][1]-a[1][2]]=false;
		}
		return;
	}
	for(int i=1;i<=16;i++){
		if(b[i])continue;
		b[i]=true;
		a[x][y]=i;
		search_dfs(x,y+1);
		b[i]=false;
	}
}
int main(){
	cin>>h>>l;
	search_dfs(1,1);
	return 0;
}
```
# 4 后记
可能是因为空间太小吧，样例答案只给了两种，实际有 $216$ 种。由于篇幅原因这里就不一一枚举了。在这里还有一种思路，后续可能会上传。

选自本人[CSDN博客](https://editor.csdn.net/md?articleId=107927509)。