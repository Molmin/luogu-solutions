### Tips:

本题样例输出较多，1000 多行，所以题目没有给出完整的样例：

 [被样例困扰的小伙伴点这](https://www.luogu.com.cn/paste/rx2i4njq)

### 基本算法

首先我们读题，在题目给的表格里可以明确看出：

$A_{i,j}$ 表示第 $i$ 行第 $j$ 列位置的数。

我看题解区有很多 x,y 和 i,j 不分的大佬。

简单来看就是（图片丑陋）

![](https://cdn.luogu.com.cn/upload/image_hosting/f1b7thm6.png)

或者：
|  | 1 | 2 | 3 | 4 |
| :----------: | :----------: | :----------: | :----------: | :----------: |
| 1 | $f_{1,1}$ | $f_{1,2}$ | $f_{1,3}$ | $f_{1,4}$ | 
| 2 | $f_{2,1}$ | $f_{2,2}$ | $f_{2,3}$ | $f_{2,4}$ 
| 3 | $f_{3,1}$ | $f_{3,2}$ | $f_{3,3}$ | $f_{3,4}$ 
| 4 | $f_{4,1}$ | $f_{4,2}$ | $f_{4,3}$ | $f_{4,4}$ 


$f_{i,j}$ 即对应 `f[i][j]` 即可。

这类题除了对剪枝的操控和对搜索策略的把控，对数组下标的明确也是容易出错的地方之一，特别是这种地图或者矩阵的题目，分清哪一个变量是行，哪个是列是非常重要的。

### 搜索与剪枝
搜索策略非常显而易见，直接填写数字即可

#### 未经优化
先暴力搜索枚举出每一种矩阵中数字的填写方法，最后判断是否符合题目的若干个要求。

我们搜索的顺序是：（数字表示顺序）
```plain
0(1,0)
|
1  -> 2  -> 3  -> 4 (1,4)

5  -> 6  -> 7  -> 8 (2,4)

9  -> 10 -> 11 -> 12(3,4)

13 -> 14 -> 15 -> 16(4,4)
```

搜索树巨大，显然无法通过。

但是我们可以借此完成判断函数：
```cpp
inline bool final_check(void)
{
	//A
	if(a[1][1] + a[1][4] + a[4][1] + a[4][4] != 34)return 0;
	
	//B
	if(a[1][1] + a[1][2] + a[2][1] + a[2][2] != 34)return 0;
	if(a[1][3] + a[1][4] + a[2][3] + a[2][4] != 34)return 0;
	if(a[3][1] + a[3][2] + a[4][1] + a[4][2] != 34)return 0;
	if(a[3][3] + a[3][4] + a[4][3] + a[4][4] != 34)return 0;
	
	//C
	if(a[2][2] + a[2][3] + a[3][2] + a[3][3] != 34)return 0;
	
	//D
	if(a[4][1] + a[4][2] + a[4][3] + a[4][4] != 34)return 0;
	
	//E
	if(a[1][4] + a[2][4] + a[3][4] + a[4][4] != 34)return 0;
	
	//F
	if(a[1][1] + a[2][2] + a[3][3] + a[4][4] != 34)return 0;
	
	//G
	if(a[1][4] + a[2][3] + a[3][2] + a[4][1] != 34)return 0;
	
	return 1;
}
```
这个判断函数以后剪枝的时候还会用到，数组下标和题目中所给出的一致，方便分析行列关系。

### 剪枝
我们可以显然发现，当之前的状态是不合法的，比如左上角四个数都不合法，那么之后是不可能合法的，所以直接剪掉。

由于是在过程中判断的，所以必定有一些条件没有达到可以满足的条件。

比如说没填全这一行就不能判断这一行的和，这很好理解吧。

另外，如果之前是合法的，我们也不需要再判断之前的条件了，~~（我看题解区大佬有的重复计算了）~~。

### 条件判断
这些条件判断完全是在之前的判断函数中修改的
```cpp
inline bool during_work_check(int x,int y)
{
	//A
	//四个角最后才能取到 
//	if(a[1][1] + a[1][4] + a[4][1] + a[4][4] != 34)return 0;

	//B
	if(x == 2 && y == 2 && a[1][1] + a[1][2] + a[2][1] + a[2][2] != 34)return 0;
	if(x == 2 && y == 4 && a[1][3] + a[1][4] + a[2][3] + a[2][4] != 34)return 0;
	if(x == 4 && y == 2 && a[3][1] + a[3][2] + a[4][1] + a[4][2] != 34)return 0;
//	if((x == 4 && y == 4) && a[3][3] + a[3][4] + a[4][3] + a[4][4] != 34)return 0;
// 最后一个肯定在路程中取不到，不用了 

	//C
	if(x == 3 && y == 3 && a[2][2] + a[2][3] + a[3][2] + a[3][3] != 34)return 0;
	
	for(rint i = 1;i <= 3;i++)
	{
		//D  行 
		//可以进行判断的条件为：x 取到 i 并且取完该行  
		if(x >= i && y == 4 && a[i][1] + a[i][2] + a[i][3] + a[i][4] != 34)return 0;
		
		//E  列 
		//可以进行判断的条件为：y 取到 i 并且取完该列 
		if(y >= i && x == 4 && a[1][i] + a[2][i] + a[3][i] + a[4][i] != 34)return 0;
		
		if(x < i && y < i) break;
	}
	
	//F 
	// \ 方向对角线  
	//最后才能确定右下角，所以中途无需判断 
//	if(a[1][1] + a[2][2] + a[3][3] + a[4][4] != 34)return 0;

	//G
	//  / 方向对角线 
	//  取到最后一行第一个即可 
	if(x == 4 && y == 1 && a[1][4] + a[2][3] + a[3][2] + a[4][1] != 34)return 0;
	
	return 1;
}
```
至于之前有大佬说的判断坐标能不能取到的问题：
因为条件表达式 `&&` 是短路的，把判断能不能满足条件的写在前面更优秀，因为前面的不满足直接就 GG 了，不会判断后面的了，这就是先排除小可能性的策略，这可能只是个 if 语句但是这种思想是很好的习惯，可以大幅减小常数。

### 最后的判断
```cpp
inline bool final_check(void)
{
	//A
	//四角 
	if(a[1][1] + a[1][4] + a[4][1] + a[4][4] != 34)return 0;
	
	//B
	//只判断右下角的即可 
//	if(a[1][1] + a[1][2] + a[2][1] + a[2][2] != 34)return 0;
//	if(a[1][3] + a[1][4] + a[2][3] + a[2][4] != 34)return 0;
//	if(a[3][1] + a[3][2] + a[4][1] + a[4][2] != 34)return 0;
	if(a[3][3] + a[3][4] + a[4][3] + a[4][4] != 34)return 0;
	
	//C
	//中间格子无需判断 
//	if(a[2][2] + a[2][3] + a[3][2] + a[3][3] != 34)return 0;
	
	//D
	//第四行 
	if(a[4][1] + a[4][2] + a[4][3] + a[4][4] != 34)return 0;
	
	//E
	//第四列 
	if(a[1][4] + a[2][4] + a[3][4] + a[4][4] != 34)return 0;
	
	//F
	//左上到右下的对角线 
	if(a[1][1] + a[2][2] + a[3][3] + a[4][4] != 34)return 0;
	
	//G
	//左下到右上的对角线，早已判断过了 
//	if(a[1][4] + a[2][3] + a[3][2] + a[4][1] != 34)return 0;
	
	return 1;
}
```
把最后一个数确定才能确定的可变因素判断完即可。

### 完整代码（内附注释）
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>

using namespace std;

//快读快写
#define rint register int
#define isnum(x) ('0' <= (x) && (x) <= '9')
template<typename tint>
inline void readint(tint& x) {
	int f = 1; char ch = getchar(); x = 0;
	for(; !isnum(ch); ch = getchar()) if(ch == '-') f = -1;
	for(; isnum(ch); ch = getchar()) x = x * 10 + ch - '0';
	x *= f;
}
template<typename tint>
void write(tint x)        
{        
    if(x < 0) {        
        putchar('-');        
        x = -x;        
    }        
    if(x > 9)        
        write(x/10);        
    putchar(x % 10 + '0');        
    return;        
}        

int a[10][10];//地图
int vis[20];//数字标记
int xx,yy;

inline bool during_work_check(int x,int y)
{
	//A
	//四个角最后才能取到 
//	if(a[1][1] + a[1][4] + a[4][1] + a[4][4] != 34)return 0;

	//B
	if(x == 2 && y == 2 && a[1][1] + a[1][2] + a[2][1] + a[2][2] != 34)return 0;
	if(x == 2 && y == 4 && a[1][3] + a[1][4] + a[2][3] + a[2][4] != 34)return 0;
	if(x == 4 && y == 2 && a[3][1] + a[3][2] + a[4][1] + a[4][2] != 34)return 0;
//	if((x == 4 && y == 4) && a[3][3] + a[3][4] + a[4][3] + a[4][4] != 34)return 0;
// 最后一个肯定在路程中取不到，不用了 

	//C
	if(x == 3 && y == 3 && a[2][2] + a[2][3] + a[3][2] + a[3][3] != 34)return 0;
	
	for(rint i = 1;i <= 3;i++)
	{
		//D  行 
		//可以进行判断的条件为：x取到i 并且取完该行  
		if(x >= i && y == 4 && a[i][1] + a[i][2] + a[i][3] + a[i][4] != 34)return 0;
		
		//E  列 
		//可以进行判断的条件为：y取到i 并且取完该列 
		if(y >= i && x == 4 && a[1][i] + a[2][i] + a[3][i] + a[4][i] != 34)return 0;
		
		if(x < i && y < i) break;
	}
	
	//F 
	// \ 方向对角线  
	//最后才能确定右下角，所以中途无需判断 
//	if(a[1][1] + a[2][2] + a[3][3] + a[4][4] != 34)return 0;

	//G
	//  / 方向对角线 
	//  取到最后一行第一个即可 
	if(x == 4 && y == 1 && a[1][4] + a[2][3] + a[3][2] + a[4][1] != 34)return 0;
	
	return 1;
}

inline bool final_check(void)
{
	//A
	//四角 
	if(a[1][1] + a[1][4] + a[4][1] + a[4][4] != 34)return 0;
	
	//B
	//只判断右下角的即可 
//	if(a[1][1] + a[1][2] + a[2][1] + a[2][2] != 34)return 0;
//	if(a[1][3] + a[1][4] + a[2][3] + a[2][4] != 34)return 0;
//	if(a[3][1] + a[3][2] + a[4][1] + a[4][2] != 34)return 0;
	if(a[3][3] + a[3][4] + a[4][3] + a[4][4] != 34)return 0;
	
	//C
	//中间格子无需判断 
//	if(a[2][2] + a[2][3] + a[3][2] + a[3][3] != 34)return 0;
	
	//D
	//第四行 
	if(a[4][1] + a[4][2] + a[4][3] + a[4][4] != 34)return 0;
	
	//E
	//第四列 
	if(a[1][4] + a[2][4] + a[3][4] + a[4][4] != 34)return 0;
	
	//F
	//左上到右下的对角线 
	if(a[1][1] + a[2][2] + a[3][3] + a[4][4] != 34)return 0;
	
	//G
	//左下到右上的对角线，早已判断过了 
//	if(a[1][4] + a[2][3] + a[3][2] + a[4][1] != 34)return 0;
	
	return 1;
}

//集成化写代码有利于调试（当然也看个人喜好）
inline void print(void)
{
	for(rint i = 1;i <= 4;i++)
	{
		for(rint j = 1;j <= 4;j++)
		{
			write(a[i][j]);
			putchar(' ');
		}
		puts("");
	}
	puts("");
	return;
}

void dfs(int x,int y)
{
	if(x == 4 && y == 4)
	{
		if(final_check() == 0) return;
		
		print();
		return; 
	}
	if(during_work_check(x,y) == 0)
		return;
	
	for(rint i = 2;i <= 16;i++)
	{
		if(vis[i]) continue;//取过就不取
		rint tarx,tary;
		if(y == 4)//取到一行末尾 
		{
			tarx = x + 1;
			tary = 1;
		}
		else//行中
		{
			tarx = x;
			tary = y + 1;
		}
		if(a[tarx][tary])
		{
        //之前有数就不用确定数了，直接一次跳进下一个
			dfs(tarx,tary);
			break;
		}
		else//选个数
		{
			a[tarx][tary] = i; 
			vis[i] = 1;
		
			dfs(tarx,tary); 
			
        //回溯的时候一定把数字还原，把标记也还原
			vis[i] = 0;
			a[tarx][tary] = 0;
		}
		
	} 
}

int main()
{
	readint(xx),readint(yy);
	memset(a,0,sizeof(a));
	memset(vis,0,sizeof(vis));
	vis[1] = 1;
	a[xx][yy] = 1;
	dfs(1,0);
	return 0;
}
```