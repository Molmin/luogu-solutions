### 题目大意

某某公园有 $2^{n+1}-1$ 个正方形，每个正方形往下有 $2$ 条路分别连接着 $2$ 个正方形，公园一共有 $n$ 层（第一层层数为 $0$），正方形编号分别为 $1,2,3,\cdots,2^{n+1}-1$。也就是说，公园是一棵最大深度为 $n$ 的**满二叉树**。

为了能在夜晚看得清路，公园管理员会放置一些路灯在每一条路上，每一条路上的路灯数量可能不同。

Om Nom 在晚上会路过这个公园，他要从深度为 $0$ 的正方形走到深度为 $n$ 的正方形，也就是**从根节点走到叶子节点**。他非常怕黑，所以他想让从根节点到每一个叶子节点中遇到的路灯数量相等。公园管理员被整不会了，求助你，让你求出最少要多修几个路灯。

### 思路

题目很长，但转化过来就是：一棵深度为 $n$ 的满二叉树，每条有边权，让某些边权增加，使得根节点到叶子节点的路径边权和相等，让增加的最少。

我们发现从根节点开始**从上到下**修改边权很难决定增加几，于是我们递归，**从下到上**开始修改边权。

我们看这种情况：

```
    1
 3 / \ 4
  2   3
```

这就是一颗简单的满二叉树，我们发现要求两个路径边权和相等，就要让边权小的增加（边权小指的是相比于另一个儿子节点与父节点的边权小，比如在上述的图中，$1\to 2$ 的边算是边权小的边）。

然后再举一个例子：

```
       1
     1/ \2
     /   \
    2     3
  3/ \4 5/ \ 6
  /   \ /   \
 4    5 6    7
```

我们要用递归处理，处理节点 $2$ 和 $3$ 的子问题。

现在变成了：

```
       1
     1/ \2
     /   \
    2     3
  4/ \4 6/ \ 6
  /   \ /   \
 4    5 6    7
```

可是这个时候，我们发现不能像上次一样处理，因为现在如果统一左右儿子与父结点边权，结果仍然不对，因为节点 $2$ 与子节点的边权与节点 $3$ 与子节点的边权不相等。

那么这时我们增加节点 $1$ 到节点 $2$ 的边权即可。

而其余深度的节点处理仍是相同。

### 代码

很短。

代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
const int M = 12, N = 1 << M;
int n, m, a[N], ans;
inline int dfs(int d, int x) {
	if (d > m) return 0; //不在二叉树中
	int lson = dfs(d + 1, x << 1), rson = dfs(d + 1, x << 1 | 1);
    //左右儿子的边权和
	ans += abs((lson - rson) + (a[x << 1] - a[x << 1 | 1]));
    //更新答案
	return max(lson + a[x << 1], rson + a[x << 1 | 1]);
}
signed main(void) {
	cin >> m; ++m; n = (1 << m) - 1; //n 为节点个数
	for (int i = 2; i <= n; ++i) cin >> a[i];
	dfs(1, 1);
	cout << ans;
}
```