- 纸上得来终觉浅。
- 我曾经苦思许久，但却不如一个样例的手推来得轻松简单。

**题意**
- [链接](https://www.luogu.com.cn/problem/CF1654F)。
- 给定一个长度为 $2^n$ 的串 $a$，定义该串的“$j$ 变换”为新串 $c$ 满足 $c(i)=a(i\operatorname{xor} j)$，求该串字典序最小的“$j$ 变换”。
- $n\le 18$。

**分析**
- 我们给出原题没有给的样例解释：
$$n=3,a=\texttt{bcbaaabb}$$
$$j=1,c=\texttt{cbabaabb}$$
$$j=2,c=\texttt{babcbbaa}$$
$$\cdots$$
$$j=4,c=\texttt{aabbbcba}$$
$$\cdots$$
- 发现了什么？当 $j=2^i$ 的时候，相当于大小为 $2^i$ 的段在奇偶块交换！
- 怎么利用这个性质，考虑 $j$ 的最高位是否有 $1$，也就是将原字符串拆成两段考虑，求出一个 $j$ 优先使得前面的字典序最小，然后再求出一个 $j$ 优先使得后面的字典序最小……
- 这好吗，这不好。因为子问题相关！我们可以先求出一个最小的 $j$，然后在这个基础上让整个串最小化，但是这样复杂度会很不对劲。
- 我的天哪，这个性质是不是没用了。
- 不要慌张，这个性质还是挺好的，只不过我们的延伸太垃圾了，我们想想一般的情况，如何构造 $j$ 变换，然后我们发现是 $j$ 变换的 $2^{n-1}$ 前缀与 $j\oplus 2^{n-1}$ 变换的 $2^{n-1}$ 前缀拼接而成的，所以我们就可以用[后缀排序](https://www.luogu.com.cn/problem/P3809)的方法来倍增求，代码实现大概就是抄一遍后缀排序的模板，时间复杂度可以是 $O(n\log^2n)$ 到 $O(n\log n)$ 但并不清楚线性的后缀排序方法是否也可以应用在这里。
- 很有趣的是，这个方法可以将所有的变换在相同的复杂度内排序，就像我们找最小循环移位所发生的事情那样。
- [代码实现](https://www.luogu.com.cn/paste/37rt7bik)。