[-->传送门](https://www.luogu.com.cn/problem/P8928) 

# 这是一篇思路很奇葩的题解，但应该比较好理解

## 题意简述：

$i$ 从 $1$ 到 $n$ 遍历，$j$ 从 $1$ 到 $m$ 遍历，把所有 $i \times j \bmod p$ 的结果加在一起，并将结果对 $10^9+7$ 取模，输出。

## 20分做法（暴力）

直接遍历即可，就不贴代码了。

但是这样的做法面对 $10^{12} \times 10^{12}$ 的数据，是一定会超时的！

所以，我们就有了第二种做法——

## 100分做法（打表/模拟）

### 思路：

~~俗话说，打表出省一。~~

这里我们自己造一个数据：

我们先不考虑 $\bmod~p$。

```python
设 n = 5, m = 8
则暴力得出的矩阵为
 1  2  3  4  5  6  7  8
 2  4  6  8 10 12 14 16
 3  6  9 12 15 18 21 24
 4  8 12 16 20 24 28 32
 5 10 15 20 25 30 35 40
```

然后再把 $p$ 带进去，那么：

```python
当 p = 1 时:
 0  0  0  0  0  0  0  0
 0  0  0  0  0  0  0  0
 0  0  0  0  0  0  0  0
 0  0  0  0  0  0  0  0
 0  0  0  0  0  0  0  0

p = 2:
 1  0  1  0  1  0  1  0
 0  0  0  0  0  0  0  1
 1  0  1  0  1  0  1  0
 0  0  0  0  0  0  0  1
 1  0  1  0  1  0  1  0

p = 3:
 1  2  0  1  2  0  1  2
 2  1  0  2  1  0  2  1
 0  0  0  0  0  0  0  0
 1  2  0  1  2  0  1  2
 2  1  0  2  1  0  2  1

p = 4:
 1  2  3  0  1  2  3  0
 2  0  2  0  2  0  2  0
 3  2  1  0  3  2  1  0
 0  0  0  0  0  0  0  0
 1  2  3  0  1  2  3  0

p = 5:
 1  2  3  4  0  1  2  3
 2  4  1  3  0  2  4  1
 3  1  4  2  0  3  1  4
 4  3  2  1  0  4  3  2
 0  0  0  0  0  0  0  0
```

什么？还没看出来？那如果把所有 $0$ 都划掉呢：

```python
p = 1:
 +  +  +  +  +  +  +  +
 +  +  +  +  +  +  +  +
 +  +  +  +  +  +  +  +
 +  +  +  +  +  +  +  +
 +  +  +  +  +  +  +  +

p = 2：
 1  |  1  |  1  |  1  |
 -  +  -  +  -  +  -  +
 1  |  1  |  1  |  1  |
 -  +  -  +  -  +  -  +
 1  |  1  |  1  |  1  |

p = 3：
 1  2  |  1  2  |  1  2
 2  1  |  2  1  |  2  1
 -  -  +  -  -  +  -  -
 1  2  |  1  2  |  1  2
 2  1  |  2  1  |  2  1

p = 4：
 1  2  3  |  1  2  3  |
 2  0  2  |  2  0  2  |
 3  2  1  |  3  2  1  |
 -  -  -  +  -  -  -  +
 1  2  3  |  1  2  3  |

p = 5：
 1  2  3  4  |  1  2  3
 2  4  1  3  |  2  4  1
 3  1  4  2  |  3  1  4
 4  3  2  1  |  4  3  2
 -  -  -  -  +  -  -  -
```

没错！整个矩阵被 $0$ 分割成了若干个 $(p-1) \times (p-1)$ 的正方形矩阵，那么这样一来，复杂度就减了不少。

所以，具体要如何实现呢？

我们取其中一个矩阵来观察：

```python
 1  2  |  1  2  |  1  2
 2  1  |  2  1  |  2  1
 -  -  +  -  -  +  -  -
 1  2  |  1  2  |  1  2
 2  1  |  2  1  |  2  1
```

首先可以看出，这个大矩阵被“完美”地分割成了六个小矩阵，且小矩阵的边长是 $p-1$。

但是，他还不够完美。为什么这样说呢？因为大矩阵的宽（$n$）和长（$m$）与小矩阵的边长（$p-1$）并没有什么倍数关系。那么，假如我们将 $n$ 和 $m$ 都加 $1$，就变成了……

```python
 1  2  |  1  2  |  1  2  |
 2  1  |  2  1  |  2  1  |
 -  -  +  -  -  +  -  -  |
 1  2  |  1  2  |  1  2  |
 2  1  |  2  1  |  2  1  |
 -  -  +  -  -  +  -  -  +
```

这个时候，$n$ 就变成了 $6$， $m$ 变成了 $8$，而它们正好是 $2$（$p$ 的值）的**整数倍**！

所以，大矩阵中就含有 $[(n+1) \div p] \times [(m+1) \div p]$ 个小矩阵。

### **但是！！！！**

如果碰到这样的矩阵：

```python
 1  2  3  |  1  2  3  |
 2  0  2  |  2  0  2  |
 3  2  1  |  3  2  1  |
 -  -  -  +  -  -  -  +
 1  2  3  |  1  2  3  |
```

最下面莫名其妙多出来一行，该怎么处理呢？

可以看出来，下面多出来的长度，就是 $n \bmod p$ 的值，那么我们只需要知道小矩阵中每一行的值的总和，就可以计算下面多出来的部分了。

```python
 1  2  3  4  |  1  2  3
 2  4  1  3  |  2  4  1
 3  1  4  2  |  3  1  4
 4  3  2  1  |  4  3  2
 -  -  -  -  +  -  -  -
```

右面与下面同理，只需要知道小矩阵中每一列的值之和，就可以求出。

### 但是！！！！

如果我们造一个稍强一点的数据，就会发现：

```python
 1  2  3  4  |  1  2  3
 2  4  1  3  |  2  4  1
 3  1  4  2  |  3  1  4
 4  3  2  1  |  4  3  2
 -  -  -  -  +  -  -  -
 1  2  3  4  |  1  2  3
（注：此时 n = 6, m = 8, p = 5）
```

右下角怎么还有一块啊？！（恼

但是只要我们稍微想一下，就不难看出：

这不就是开头的暴力吗？？

最后，将所有求出的值加起来即可，别忘了取模！！

### 你们最爱的 Code

```cpp
#include <iostream>
using namespace std;
#define int long long

const int modx = 1e9 + 7;
int n, m, p;
int nn, mm; // nn：向下延伸的长度，mm：向右延伸的长度
int pn, pm;
int pnm[10005][10005]; // 存储小矩阵中 (i,j) 位置的值
int pnn[10005]; // 存储小矩阵中第 i 行的值
int pmm[10005]; // 存储小矩阵中第 i 列的值
int a; // 存储每个小方阵中所有值的和
int ans;

int add_nm(int tn, int tm)
{
    int tmp = 0;
    for(int i = 1; i <= tn; i++)
    {
        for(int j = 1; j <= tm; j++)
        {
            tmp += pnm[i][j];
        }
    }
    return tmp;
}

void make_pnm()
{
    for(int i = 1; i <= p - 1; i++)
    {
        for(int j = 1; j <= p - 1; j++)
        {
            pnm[i][j] = (i * j) % p;
            pnn[i] += pnm[i][j];
            pmm[j] += pnm[i][j];
            a += pnm[i][j];
        }
    }
    return;
}

signed main()
{
    cin >> n >> m >> p;
    make_pnm(); // 找到小方阵，并计算每行、每列和总值
    nn = (n + 1) % p;
    mm = (m + 1) % p;
    if(nn != 0)
    {
        nn--;
    }
    if(mm != 0)
    {
        mm--;
    }
    pn = ((n + 1) / p);
    pm = ((m + 1) / p);
    ans += pn; // 这里相当于 ans = pn * pm * a，但是这样会爆 long long，所以就分开乘，并每一次都取模一下
    ans %= modx;
    ans *= pm;
    ans %= modx;
    ans *= a;
    ans %= modx;
    for(int i = 1; i <= mm; i++) // 计算下面延伸部分的总和
    {
        ans += pmm[i] * pn;
    }
    ans %= modx;
    for(int i = 1; i <= nn; i++) // 计算右面延伸部分的总和
    {
        ans += pnn[i] * pm;
    }
    ans %= modx;
    ans += add_nm(nn, mm); // 计算右下部分的总和
    ans %= modx;
    cout << ans << endl;
    return 0;
}
```