## 蒟蒻第一次发题解
这道题的坑其实还是蛮多的，要不是为了~~MC~~学习我可能就不写了。
初始等级是0的问题楼下dalao都讲过了。这里主要给大家介绍一下位运算，
因为此题要用到2的乘方，如果为了这个小运算再写一个循环的话本蒟蒻觉得很累。咳咳~~

有人要说了，可以用pow函数，但那时十进制运算，需要把二进制转为十进制运算之后再转为二进制，光听着就很麻烦对吧。位运算，可以办你解决这些问题。

位运算就是针对二进制位的运算，省去了转为十进制的过程，减少了时间浪费，这里要讲的位运算主要有两种，就是将一个数1左移或右移n个二进制位。分别为1>>n(左移)和1<<n（右移）

本题主要用到的是右移，举个例子：

1的二进制是0001，对它进行右移一位运算，也就是1<<1，它的二进制变为0010，转为十进制就是2，相当于乘以2^1,就是在他后面加一个零。

以此类推1<<2就是0100，乘以2^2变成了4。

再来讲一下左移

跟右移相反，左移是删除数的后一位，对其进行除以2^n并向下取整的操作。

再举一个例子：

5的二进制是0101,5>>2就是像右移两位，变成1，因为后两位被删掉了，所以也是向下取整。

丑陋的代码：
```#include<iostream>
using namespace std;
int n,s,o,i,j,k,p;
double f=10,x;
int main(){
	cin>>n;
	for (i=1; i<=n; i++){
		cin>>x>>k;
		if (f-x<=0)  break;  //一定不能在这里输出，因为会有一个x和k都为0的数据
		k+=p;p=0;   //将多出的经验加到下一次经验中
		f-=x;  
        if (f>10) f=10;
        while ((1<<s)<=k){//  2的s次方
        	k-=(1<<s); s++;
		}
		p=k;  //多出的经验
	}
	cout<<s<<' '<<p;
	return 0;
}```
谢谢阅读