## 一、前言

本题是一道**状压 DP**，由于本人状压 DP学的不好，故写下这篇题解加深理解。本文将介绍**位运算**，**状压 DP**，以及**做题思路**。

## 二、位运算

- 位运算的一个重要作用就是**表示一个集合**，常见于**状压 DP**。

- 一个数的二进制可以看作是一个**集合**（ $0$ 表示在这个集合中，$1$ 表示不在这个集合中）。而这时的**位运算**可以看做是**对集合的操作**。

| **操作** | **集合表示** | **位运算语句** |
| :----------: | :----------: | :----------: |
| 交集 | $a \ \cap \ b$ | `a & b` |
| 并集 | $a \ \cup \ b$ | `a | b`  |
| 补集 | $\bar{a}$ | `~ a` (**全集**为**二进制都是一**)  |
| 差集 | $a$ \ $b$ | `a & (-b)` |
| 对称差 | $a \triangle b$ | `a ^ b` |

## 三、题意

有 $n$ 个长度为 $m$ 的二进制串（物品），每次你都可以询问目标二进制串（心中想的物品）第 $k$ 位的值（心中的物品是否有该特征），问**最少**询问几次能够确定目标二进制串。

## 四、思路

### （1） 审题
首先看到**二进制串**就很快能想到**状压 DP**，再一看 $m \leq 11$，十分符合状压 DP 的情况。

**适合状态压缩的情况**：

- 状态复杂，难以表达。

- 但是状态**数量**少，且决策较少（最好就只有两个，符合二进制）

### （2） 状态

由于我们在询问过一个特征值之后就不需要再询问一遍，因此我们可以设一个集合 $s$ 表示**已经询问过的特征组成的集合**。而我们又要求出一个确定的二进制串，假设这个确定的二进制串为 $F$，那么我们设 $a$ 表示**已经确定的 $F$ 的特征所组成的集合**。则可以得到状态 $f(s,a)$ 为**已经询问过集合 $s$，已经确定的 $F$ 的特征集为 $a$ 时还需要询问的最小次数。**

### （3） 转移

我们假设下一次提问的对象是特征 $k$，可得转移方程

$$f(s,a)=\min(f(s,a),\max(f(s+\{k\},a+\{k\}),f(s+\{k\},a))+1)$$

取 $\max$ 是因为我们只是猜测确定的串是否有特征 $k$，它可能有可能没有，需要我们取最大值保证**确定了 $k$ 到底是不是它的特征**。取 $\min$ 得到满足条件的最优解。

### （4） 实现

具体实现用**记忆化搜索更优**，因为这里我们难以确定递推顺序，而记忆化搜索**不需要考虑顺序**。

## 五、状压 DP

接下来我会举一些本题的代码为例子来阐述状压 DP 的具体实现。

```cpp
(s&(1<<k))==0;
```
- $1<<k$ 表示**只有 $k$ 单独一个元素的集合**，而 `a & b` 是取两者的**交集**，$s$ 和 $k$ 交集为 $0$ 表示 $s$ **集合中没有** $k$ 元素。

```cpp
s|(1<<k);
```

- `a | b` 是取两者的并集，一般表示**把两个集合相加**，在这里表示**在 $s$ 集合中加入 $k$ 元素**。

```cpp
for(int i = s; i; i = (i-1)&s)
```

- **遍历** $s$ 集合。

## 六、后记

- 参考文献：
	
 	[oi - wiki](https://oi-wiki.org/math/bit/)、
《算法竞赛入门经典》