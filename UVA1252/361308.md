楼上的题解竟然是紫书上的文字……稍微吐槽一下QWQ~~尽管我也是按照紫书的思路写的。~~

这道题明显一个状压DP，~~思路紫书或者说楼上的题解讲的很清晰了~~，这里就为没学过状压DP的跟我一样的蒟蒻们说一下。


前置芝士：位运算

这个就背住就行了：

```cpp
1&1=1;
1&0=0;
0&1=1;
0&0=0;
1|1=1;
1|0=1;
0|1=1;
0|0=0;
1^1=0;
1^0=1;
0^1=1;
0^0=0;
```

&和|运算是不是和逻辑运算符很像？int间的&和|是按照int的每个二进制位逐位进行运算的。^运算名叫“异或”(XOR），当两个值相同时为0，否则为1，同样逐位进行。

有些题目的状态非常复杂，比如说是一个或几个集合。显然这种状态放到数组里必须hash或者用unordered_map。但是对于某些特殊的复杂状态，我们可以将它压缩一下变成一个整数。怎么压缩呢？

我们用一个二进制数表示一个集合，每个二进制位表示某个元素在还是不在这个集合中。比如说表示一个1$\sim$20的集合，我们就可以用一个int来保存。

举个栗子，比如对于集合1，4，7，12，13，18，我们的二进制数就是：

00100001100001001001。

从右往左第i位表示元素i是否在这个集合中，是为1，否则为0.

集合的基本操作：

S & (1 << i)：判断元素 $i$ 是否在集合 $S$ 中，是为1 << i，否则为0。

S | (1 << i)：将元素 $i$ 加到集合 $S$ 中。

A & B：求集合A与集合B的交集。

A | B：求集合A与集合B的并集。

A ^ B：求集合A与集合B的差集。

当然集合还有很多操作，不过基本都是根据上面五种变换而来的。

这就是所谓的状态压缩，我们将一个本来需要bool数组表示的集合变成了一个int整数，而且还能方便地进行许多操作。

回到这道题，我们可以用一个集合表示一个物品的特征，因为最多只有11个特征，也就是说只需要一个11位数字，别说int，short就够了。

~~然后就可以看楼上的或者紫书的题解了~~。

我们可以使用一个集合 $S$ 表示当前询问过的特征的集合，$W$ 表示 $S$ 中心里想的物品满足的特征。

当只有一个物品满足具备 $W$ 的所有特征同时不具备集合 $S-W$ 的所有特征时我们就猜中了这个物体。

可以预处理一下，$cnt[S][W]$ 表示满足上述条件的物体数量。

时间复杂度：$O(n2^m+m3^m)$

如果思路没看懂可以参考紫书~~直接看楼上的题解也可以~~。

# $Code:$

```cpp
#include <cstdio>
#include <cstring>
#define Min(x, y) (x < y ? x : y)
#define Max(x, y) (x > y ? x : y)

int n, m, a[150], cnt[(1 << 11) + 5][(1 << 11) + 5], d[(1 << 11) + 5][(1 << 11) + 5];

int dfs(int s, int w)
{
	if (d[s][w] != -1) return d[s][w];
	if (cnt[s][w] <= 1) return d[s][w] = 0;//如果不存在满足条件的物体也可以确定了
	for (int i(0); i < m; ++ i)
	if (!(s & (1 << i)))//如果特征i不在集合s中
	d[s][w] = Min(d[s][w], Max(dfs(s | (1 << i), w | (1 << i)), dfs(s | (1 << i), w)) + 1);//题目问的是至少，所以里面要取一个max。有可能这个特征是该物体所具备的，也有可能不是，要分两种情况讨论
	return d[s][w];
}

int main()
{
	while (scanf("%d%d", &m, &n) == 2)
	{
		if (n == 0 && m == 0) return 0;
		memset(a, 0, sizeof(a));
		memset(d, -1, sizeof(d));
		memset(cnt, 0, sizeof(cnt));//清零！清零！清零！清零！清零！清零！清零！清零！清零！清零！清零！清零！
		getchar();//吃掉换行符
		for (int i(1); i <= n; ++ i)
		{
			for (int j(0); j < m; ++ j)
			a[i] |= (getchar() - 48) << j;//getchar读入容易错，但是效率高
			getchar();//吃掉换行符
		}
		for (int i(0); i < (1 << m); ++ i)
		for (int j(1); j <= n; ++ j)
		++ cnt[i][i & a[j]];//预处理
		printf("%d\n", dfs(0, 0));
	}
}
···
