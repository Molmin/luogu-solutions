# STO  _**YGP**_  orz
###  n²枚举搞定.
#### 为了方便,规定平板所占的区间为平板区间.
#### 这题可以直接枚举每一个平板是否有另一个平板可以搭，因为n<=100.
#### 那么就好办了, _为什么这么说咧_ ,因为对于每个平板,只有两种情况:
#### 1.这个平板的左端被包含在某个平板区间里且高度大于这里的某一个平板.
#### 2.这个平板的右端被包含在某个平板区间里且高度大于这里的某一个平板.
#### 有的同学要问了, _为什么没有被包含咧？_ ,因为这种情况都满足以上两种情况,因此没必要再分支一种情况来讨论.
#### 然后取高度最小值加起来就行了
#### 有的同学又要问了,为什么有的平板区间虽然满足以上条件但却并另一个平板挡住了而导致搭不上,这种情况也算搭上了呢？原因很简单,因为取的是最小值,如果被挡住了,那么证明当前平板到这个挡住它的平板的支柱长度更小,那么上面这种情况的最小值会被更新,自然也就不会搭上这块平板了.
#### Code:
~~~#include<iostream>
#include<cstdio>
#include<cmath>
#include<cstring>
#include<cstdlib>
#include<algorithm>
#include<ctime>
using namespace std;
const int N=1005;
int n,ans,x=1000000000,y2=1000000000;
struct Node{
    int y,x1,x2;
}a[N];
int main(){
    scanf("%d",&n);
    for(int i=1;i<=n;i++){
        scanf("%d%d%d",&a[i].y,&a[i].x1,&a[i].x2);//结构体:分别记录第i个平板的长度和起始坐标
    }
    for(int i=1;i<=n;i++){
        x=1000000000,y2=1000000000;//由于要取最小值,故初值设为最大
        for(int j=1;j<=n;j++){
            if(i==j){//肯定不会枚举相同平板的
                continue;
            }
            if(a[i].x1>=a[j].x1&&a[i].x1<a[j].x2&&a[i].y>a[j].y){//如果当前平板的左端在某一个平板区间中且高度大于此平板(PS:>=是因为支柱在平板内半个单位处)
                x=min(x,a[i].y-a[j].y);//那么当前平板的左端可以搭在这个平板上,注意取最小值
            }
            if(a[i].x2<=a[j].x2&&a[i].x2>a[j].x1&&a[i].y>a[j].y){//如果当前平板的右端在某一个平板区间中且高度大于此平板(PS:<=是因为支柱在平板内半个单位处)
                y2=min(y2,a[i].y-a[j].y);//那么当前平板的右端可以搭在这个平板上,注意取最小值
            }
        }
        ans+=min(x+y2,min(y2+a[i].y,min(x+a[i].y,2*a[i].y)));//ans加上所有情况中支柱长度的最小值(PS:如果当前平板左端或右端没有可搭的地方,那么就只能搭在地上,这样支柱就是x+a[i].y或y2+a[i].y,如果左端和右端都没有可搭的地方,那么只能都搭在地上,这样支柱就是2*a[i].y)
    }
    printf("%d\n",ans);//输出ans
    return  0;
}~~~
#### 不吝赐教.