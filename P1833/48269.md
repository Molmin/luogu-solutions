/\*
P1833 题解

含价值的混合三种背包问题

\*/
```cpp
#include <cstdio>//头文件
int t[10001],c[10001],p[10001],f[10001];//t数组是用来存储看第i樱花树所需要的时间的（即f[i]），c数组是用来存储第i颗樱花的美学值的（即c[i]），p数组是用来存储这颗樱花树最多可以看多少次的（即p[i]）
int maxx(int x,int y)//maxx函数是用来判断两个数到底那个数更大一些的
{
    return x>y?x:y;//如果x>y，那么就返回x，否则就返回y
}
int main()//主函数
{
    int sa=0,sb=0,ea=0,eb=0,v=0,n=0;//sa和sb是用来存储开始的时间的，ea和eb则是用来存储结束的时间的
    scanf("%d:%d %d:%d %d",&sa,&sb,&ea,&eb,&n);//读入开始的时间的结束的时间，以及有多少棵樱花树是可以用来观赏的
    v=(ea*60+eb)-(sa*60+sb);//可以用来观赏烟花的时间（即这个背包的容量）
    for(int i=1;i<=n;i++)//读入这n棵樱花树的相关数据
    {
        scanf("%d %d %d",&t[i],&c[i],&p[i]);//读入观赏第i棵樱花树所需的时间（即t[i]），以及第i棵樱花树的美学值（即c[i]）和第i棵樱花树最多可以观赏多少次（即p[i]），注意，如果p[i]等于0的话，那么就表明第i棵樱花树可以观赏无数次（即完全背包），否则就表示这棵樱花树可以观赏p[i]次（即做p[i]次01背包即可）
    }
    for(int i=1;i<=n;i++)//从第1棵樱花树循环到第n棵樱花树
    {
        if(p[i]==0)//如果第i棵樱花树可以观赏无数次
        {
            for(int j=0;j<=v-t[i];j++)//完全背包（从0做到v-t[i]，因为不能超过的所给定的时间，即可以省去v-t[i]+1~v的这一段）
            {
                f[j+t[i]]=maxx(f[j]+c[i],f[j+t[i]]);//不管当前这一层有没有东西存在这里，都更新一下最大值
            }
        }
        else if(p[i]!=0)//如果第i棵樱花树只能够观赏p[i]次
        {
            for(int j=1;j<=p[i];j++)//那么就做p[i]次完全背包
            {
                for(int k=v-t[i];k>=0;k--)//01背包（原理同上，只不过倒着循环了而已）
                {
                    f[k+t[i]]=maxx(f[k]+c[i],f[k+t[i]]);//同上
                }
            }
        }
    }
    int ans=0;//存储最大值（即答案）
    for(int i=v;i>=0;i--)//找最大值
    {
        if(f[i]>=ans)//如果找到了一个比当前的最大值还要大的数字
        {
            ans=f[i];//那么就更新它（即更新最大值）
        }
    }
    printf("%d",ans);//输出最大值
    return 0;//结束程序
}
```