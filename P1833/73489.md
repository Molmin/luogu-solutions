虽然是黄题，但是能找到这题的人一定不一般。

如果你理解的01/完全背包里降维优化的本质，你就可以发现，我们是每次读入一个新物品，然后用放他或不放来更新f数组。那么对于物品可能是有限次或无限次放置的情况，我们只需要对每一个物品分类讨论即可。

1. 使用次数无限：直接按完全背包公式（正序）更新即可。

2. 使用次数有限：如果是多重背包，也直接把该物品按完全背包的解法带入即可，01背包可以看做多重背包的特殊情况，不用再讨论。

完全背包可以使用二进制优化或单调队列优化，这里都简单说一下。注意v是重量，w是价值。

### 二进制优化
将使用次数为c的物品拆分为权值为$1, 2, 4, ...2^i,c-2^{i+1}+1$的物品。

比如$(w=2,v=3,c=13)$，可拆分为$(2,3)$，$(2*2,3*2)$，$(2*4,3*4)$，$(2*6,3*6)$，容易证明这`log(c)`个数的物品可以拼接出$[1,c]$的所有数，所以是合法的。

### 单调队列优化

容易发现，在读入$(v,w,c)$时，$f[j]$可由$f[j-v],f[j-v*2],...f[j-v*c]$推得。

而$f[j-v]$可以由$f[j-v*2],...f[j-v*c],f[j-v*(c+1)]$推得。

它们的备选区间只在左右端点有变化。

又有$f[j+p*v] = max(f[j+k*v]+(p-k)*w)(k\le c)$

将右边化简为$(f[j+k*v]-k*w)+p*w$，因此我们枚举固定的`j`作为模数（代码中为d），在p不断后移的同时，用单调队列维护在范围内的$f[j+k*v]-k*w$最大值即可。由于又要通过式子的值淘汰无用值，又要用下标淘汰过期值，我使用了两个队列。

后者思维难度略大，效率略高，两者码量差距不大，这里使用第二种。

```cpp
#include <bits/stdc++.h>
#define MAX (1000 + 7)
using namespace std;

int N, M, a0, b0, a1, b1, f[MAX], Q1[MAX], Q2[MAX];

int main()
{
	scanf("%d:%d %d:%d %d", &a0, &b0, &a1, &b1, &N);
	M = (a1 - a0) * 60 + b1 - b0;
	
	for (int i = 1, v, w, c; i <= N; i++)
	{
		scanf("%d%d%d", &v, &w, &c);
		if (!c)
		{
			for (int j = v; j <= M; j++)
				f[j] = max(f[j], f[j - v] + w);
			continue;
		}
		for (int d = 0; d < v; d++)
		{
			int L = 1, R = 0, maxp = (M - d) / v;
			for (int p = 0; p <= maxp; p++)
			{
				int &x = f[d + v*p];
				while (L<=R && x - w*p >= Q2[R]) R--;
				Q1[++R] = p, Q2[R] = x - w*p;
				while (L<=R && Q1[L] < p - c) L++;
				x = max(x, Q2[L] + w * p);
			}
		}
	}printf("%d\n", f[M]);
}
```