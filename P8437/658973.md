 [传送门](https://www.luogu.com.cn/problem/P8437?contestId=73946)
 
此篇题解是为了纪念比赛当天出去吃饭忘了参加比赛这件事。

这道题目我个人认为最大的难点在于怎么使神之子串的长度不超过 $m$，并且还要特判 $k = 2$。

### 题目描述


------------
伟大的神 TU 认为 ，一个所有出现的字符的数量相等的字符串是属于神的，他称之为神之字符串。

对于一个字符串 $S$，如果它的一个子串为神之字符串，即称这个子串为神之子串。

神 TU 认为，他喜欢的字符串只能由 l 和 r 构成，并且还要满足以下条件：

- 字符串的长度为 $n$。   
- 字符串中最长神之子串长度为 $m$。   
- 字符串中连续的相同的字符的数量不能超过 $k$。   

弱小的神小 s 找不出神 TU 喜欢的字符串，现在他找到了你，你能帮帮他吗？



------------
那么这一道题我们就可以先把题目中说的神之子串先输出出来，然后再用一个 while 循环输出其余的部分。我们可以先一直输出 l，这样子可以避免神之子串的长度增加，接下来再输出 r 来防止连续的相同的字符的数量不超过 $k$。并且我们还要特判 $k=2$ 的情况。


------------
直接上代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
	int n,m,k,i=1,j=1;
	cin>>n>>m>>k;
	if(k==2) m-=2;                   //特判 k==2,m-2 的原因是因为当你测试数据 10 6 2 时，会输出 lrlrlrllrl，
                                         //长度最大神之子串长度为 8,就是 rlrlrllr 这一段，         
                                         //要处理就得让这个字符串少一个 lr，所以要把神之子串长度 m 减 2。
	while(i<=m)
	{
		cout<<"lr";i+=2;         //先处理神之子串。
	}
	while(i<=n)
	{
		while(j<=k&&i<=n)
		{
			cout<<"l";       //疯狂输出 l 来使长度最大的神之子串不会大于 m。
			j++,i++;
		}
		j=1;
		if(i<=n) cout<<"r",i++;  //输出完 l 之后如果长度没超过 n 就输出一个 r 来使连续的相同字符 l 的数量小于等于 k，
                                         //并且只输出一个防止神之子串的长度增加。
	}
	return 0;
}
```
