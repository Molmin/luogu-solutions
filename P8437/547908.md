这是一道不算太难的构造题，我们可以从每个 Subtask 一步步分析，有特殊的情况推广到更普遍的情况

#### Subtask 1

因为 $k = 1$，显而易见的，要求的字符串只能够是 `l` 和 `r` 交替排列的。

代码如下

```cpp
for(int i = 1; i <= n; i++){
    if(i % 2) printf("l");
    else printf("r");
}
printf("\n");
```

#### Subtask 2

因为 $n = m$，所以我们只需要让整个字符串中的 $l$ 和 $r$ 相等就可以了。为了满足连续的相同的字符的数量不能超过 $k$ 的限制，我们只需要构造一个 `l` 和 `r` 交替排列的字符串就好了，这和 Sub 1 的情况是一样的。

#### Subtask 3

Sub 3 给出的特殊性质是 $k \ge 3$，这似乎并没有起到什么提示作用，我们需要自己思考。

观察到题面对要求的字符串提出了三个限制：

> - 字符串的长度为 $n$。
> - 字符串中最长的神之字串长度为 $m$。
> - 字符串中连续的相同的字符的数量不能超过 $k$。

同时要求这个字符串只能够由 `l` 和 `r` 组成，并定义神之字串为 `所有出现的字符的数量相等的字符串`。

第一个和第三个限制比较容易满足，剩下的问题在于第二个限制。

考虑先构造一个长度为 $m$ 的神之字串，目前，第二个条件就满足了。这个长度为 $m$ 的神之子串也可以用之前 Sub 1 和 Sub 2 的构造方法。

但是我们的字符串还没有满足第一点限制。于是我们考虑在构造的长度为 $m$ 的字符串之后在不断添加字符，但必须维护已经满足了的限制二。

由于需要维护限制二，我们在之后就不能出现比 $m$ 更长的神之子串。考虑这样一种做法：假设我们前面构造的神之字串的最后一个字符是 `r`，我们不断重复以下过程

> 1. 连续添上 $k$ 个 `l`。
> 2. 添上 $1$ 个 `r`。

为什么这样能够保证之后就不会出现比 $m$ 更长的神之子串呢，我们可以模拟一下：

按照上面的方式构造出来的字符串是：

`lrlrlrlrlr……lr(长度为 m)lll……l(长度为 k)rlll……(长度为 k)r……`

首先考虑 $m$ 之后的情况。由于 $k \ge 3$，所以最好的情况是 `lllrlllrlll……`。

由于 $m \ge 4$，所以至少要两个 `r` 和两个 `l`。但是我们发现，如果要截取到两个 `r`，势必会截取到三个以上的 `l`。而如果 $k$ 更大的话，截取得到的 `l` 还会更多。

同样地，考虑后面一段在接上前面的 $m$ 个字符构成神之子串。

这显然也是不合理的。如果想要构造出来，就必须要有一个紧接在 $m$ 后面的一个神之子串，同样得不到。

于是代码新鲜出炉：

```cpp
 for(int i = 1; i <= m; i++){
     if(i % 2) printf("l");
     else printf("r");
 }
for(int i = m + 1; i <= n; i++){
    for(int j = 1; j <= k && i + j <= n; j++, i++){
        printf("l");
    }
    if(i <= n); printf("r");
}
```

#### Subtask 4

注意到我们前面的感性证明用到了 Sub 3 给出的特殊条件，如果 $k < 3$ 会怎么样呢？对于 $k = 1$ 的情况我们在 Sub 1 中做过了，接下来只需要考虑 $k = 2$ 的情况。

如果依旧按照之前做法，那么我们得出的字符串就是：

`lrlrlrlrlr……lr(长度为 m)llrllr……`

虽然从第一个字符算起后面添加的字符无法衔接上，但是如果从第二个字符算起答案就不同了。

`l` `rlrlrlrlr……l` `rllr` `llr……`

我把它们分隔开来，显然的，中间一段是长度为 $m - 2$ 的 `rlrlrlrl……` 序列，而后面的 `rllr` 也是一个神之子串。我们把它们接起来，就成为了一个长度为 $m + 2$ 的神之字串。这样一来，限制二就不满足了。

如何解决呢？既然答案会变成 $m + 2$，我们就把前面的序列缩短两个字符不就好了？

代码如下：

```cpp
for(int i = 1; i <= m - 2; i++){ // 这里是 m - 2 哦
    if(i % 2) printf("l");
    else printf("r");
}
for(int i = m - 1; i <= n; i++){
    for(int j = 1; j <= k && i + j <= n; j++, i++){
        printf("l");
    }
    if(i <= n); printf("r");
}
```

