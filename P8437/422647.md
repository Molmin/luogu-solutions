[题目传送门](https://www.luogu.com.cn/problem/P8437)

## 思路

$1. ~\texttt{Subtask 1、2}$

Subtask 1 中保证 $k=1$，也就是只能出现一个连续的字符。那么只能是 $l$ 和 $r$ 字符交替排列，即 $lrlrlr......$，我们只要保证这个字符串的长度为 $n$ 即可。

Subtask 2 中保证 $n = m$，也就是说构造出长度为 $m$ 的子串后，从第 $2,3,4...m$ 个字符开始到 $n$ 的子串的长度都不可能超过开始构造的长度为 $m$ 的子串。所以按照 Subtask 1 的构造方法构造即可。

$2. ~\texttt{Subtask 3}$

现在可以换一种思路。即构造完长度为 $m$ 的最长子串后，添加一个字符后保证整个字符串不是一个满足要求的字符串，长度为 $m$ 的这个子串就一定是最长的满足要求的子串。

所以对于第 $m + 1$ 到第 $n$ 个字符，每次判断如果连续的 $l$ 超过了 $k$，那么就加一个 $r$。否则增加一个 $l$。由于我们能加一个 $l$ 就加一个 $l$，这样的构造方法一定能保证 $l$ 和 $r$ 的个数不一样。

$3. ~\texttt{Subtask 4}$

但是按照上述构造方法，你会发现你只能得 $45$ 分。

问题其实出在了 $k=2$ 上。如果 $n=10,m=4,k=2$，程序会输出 $lrlrllrllr$，但是我们发现，虽然从第 $1$ 个字符到其他大于 $m$ 个的字符都不构成神之字符串，但是形成了一个神串 $rlrllr$，它的长度是大于 $4$ 的。

并且这个神串长度一定是 $m+2$，因为它包含了前面的 $m-1$ 个字符（不包含第一个字符），还有一个 $llr$。为什么其他数据不会出现这种情况？因为我们能加 $l$ 就加 $l$，其他情况不管从哪位开始，包含进去的 $l$ 和 $r$ 的数量都不可能相等。但 $k=2$ 的情况从第二位开始，也就是 $l$ 的数量先减 $1$，然后又加 $2$（$m$ 个字符后的 $ll$），相当于加 $1$，$r$ 的个数也加 $1$ 后和 $l$ 的个数一样了。

所以，我们只要判断 $k=2$，然后 $m-2$ 即可。这时我们刚才得出的更长的子串长度也会减二。就可以满足题目条件了。

## 代码：

```cpp
#include<iostream>
using namespace std;
int n,m,k = 0;
string str;
int lnum, rnum = 0;
int main () {
    cin >> n >> m >> k;
    if(k == 1 || m == n){
        for(int i = 1; i <= n; i ++){
            if(i % 2 == 0){
                cout << "r";
            }
            else{
                cout << "l";
            }
        }
    }
    else{
    	if(k == 2){
    		m -= 2;
		}
        for(int i = 1; i <= m; i ++){
            if(i % 2 == 0){
                str += 'r';
            }
            else{
                str += 'l';
            }
        }
        int ll = 0;
        if(m < n){
            for(int i = m + 1; i <= n; i ++){
                if(ll + 1 > k){
                    str += 'r';
                    ll = 0;
                }
                else{
                    ll ++;
                    str += 'l';
                }
            }
        }
    } 
    cout << str;
    return 0;
}