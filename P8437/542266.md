### - [传送门](https://www.luogu.com.cn/problem/P8437)

------------

### 题意

首先需了解神之子串，就是在一个长度是 $n$ 并且只包含 `l` 和 `r` 的字符串里，最长的神之子串长度为 $m$，也要使这个子串中出现的 `l` 和 `r` 数量相等。还需要注意的是该字符串中连续相同的字符数量不能超过 $k$。


### 思路

- Subtask 1：当 $k=1$ 时，我们就能想到 `lrlr……` 直到第 $m$ 个，剩下的 $m-n$ 个就破坏 `l` 和 `r` 个数相同即可，输出 $m-n$ 个 `l` 就行，这样就可以过了。

	举个例子。

	```cpp
	8 6 1
	```
	输出就为 `lrlrlrll`。

   可以发现 `l` 只会在最后重复一组，就不用再去考虑 $k$ 的问题了。

- Subtask 2:这里 $n=m$，那么思路与 Subtask 1 一样，上面的特殊限制让我们知道 $n$ 和 $m$ 之差便是 $0$，所以最后输出不了剩下的 `l`，那么这也就过了。

- Subtask 3:我们先满足 $m$ 的要求，方法同上，之后我们需破坏后面的字符串，让它们无法构成神之子串，可用 `llr……` 直至这两步之和达到 $n$ 的个数。

- Subtask 4:现在是无限制，我们能从上面看出这应是 $k=2$ 的情况了。那还能用 Subtask 3 的方法吗？再举一个例子。
	```cpp
	12 8 2
	```
   我们会输出 `lrlrlrlrllrl`，但是现在神之子串的长度便不是 $m$ 的 $8$ 了，而是从第 $2$ 位到第 $11$ 位的 $10$ 了，明显不对。
   那么我们就把第 $1$ 组 `lr` 改成 `rl`，再试一下上面的例子，输出就是 `rllrlrlrllrl`，这样就可以解决了 Subtask 4 了。
   
### 代码

因为 Subtask 1 和 2 的解法相同，于是我把这两个合在了一起。我又把 3 和 4 的解法也放在了一起，是因为 3 输出的神之子串先输出 `rl` 再输出剩下的字符串是不会影响答案的。

```cpp
//tot存的是l和r单个的位数
if(k==1||n==m){
	tot=m/2;
	for(int i=1;i<=tot;i++)
		printf("lr");
	for(int i=1;i<=n-m;i++)
	  	printf("l");
}else{
	tot=m/2-1;
	//首先输出的是rl，所以位数之和要减1
	printf("rl");
	while(tot--)
   		printf("lr");
	now=n-m;
	//now表示剩下的位数
	if(now<=0)
		return 0;
	else{
		yushu=now%3;
		//yushu表示余数，因为之后需输出llr，所以要求出余数
		now=(now-yushu)/3;
		while(now--)
			printf("llr");
	   	if(yushu==1)
	    	printf("l");
		if(yushu==2)
	    	printf("ll");
	}
}
```