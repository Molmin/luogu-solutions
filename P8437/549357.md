## 思路
看到这道题后，不难想到这样一种构造方式：先将 `lr` 交替排列 $\dfrac{m}{2}$ 组，剩余 $n-m$ 个按 $k$ 个 `l`，一个 `r` 的方式排列，这样前 $m$ 个字符就构成了一个神之子串。

但是这样做有什么问题呢？不难发现当 $k=2$ 时第二个字符至第 $m+3$ 个字符构成了一个长度为 $m+2$ 的神之子串，不满足要求。

下面通过一个例子更好的理解一下：

当 $n=10,m=6,k=2$ 时，使用上述方法构造出的字符串会变成 `lrlrlrllrl`，最长的神之子串为第二个字符至第九个字符构成的长度为 $8$ 的字符串，不符合题意。这是因为当 $k=2$ 时，即使从第 $m+1$ 个字符开始交替排列的两个 `l` 比一个 `r` 多一个，但可以通过去掉字符串的第一个字符，添加字符串的从第 $m+1$ 个字符开始的三个字符，使得 `l` 和 `r` 的个数相同，从而使得最长神之子串的长度比 $m$ 多 $2$。

所以当 $k=2$ 时先将 $m$ 的值减二即可。
## $\text{AC Code}$
```cpp
#include <bits/stdc++.h>
using namespace std;
int main()
{
    ios::sync_with_stdio(0);
    cin.tie(0), cout.tie(0);
    int n, m, k;
    cin >> n >> m >> k;
    if (k == 2) m -= 2;
    for (int i = 1; i < m; i++) cout << (i % 2 == 1 ? 'l' : 'r');
    for (int i = m; i <= n; i++) cout << (i % (k + 1) == (m - 1) % (k + 1) ? 'l' : 'r');
    return 0;
}
```