### 一道有意思的思维题

拿到题目先考虑题意

1. 神之字符串 ： 指一段区间内，若  $l$ 和 $r$ 出现次数相等就可以被称为神之字符串。

2. 神之子串 ： 子串中有神之字符串就是神之子串，那最长子串也就是最长神之字符串

3. $k$ 值 ： 不能出现连续 $k+1$ 个相同字母

理解了题意，我们就开始分析，将问题拆分成最小可解单元，如何能在满足k值条件情况下 出现神之字符串 和 不出现神之字符串

观察 $lr$ 和 $rl$ 两种情况，他们自身都能满足以 $2$ 为单位成为一个神之字符串，那么只要连续出现 $m/2$ 个连续的这两个子串，就可以满足出现长度为 $m$ 的最长神之子串条件，又因为最小单元重复每个字母最多出现 $1$ 次，也就满足了 $k$ 的要求

在想如何不出现神之字符串，观察  $r\begin{matrix}k\\\overbrace{l...l}\end{matrix}$  和 $\begin{matrix}k\\\overbrace{l...l}\end{matrix}r$ 两种情况，其想成为对神之字符串有贡献，其后至少要补充 $k-1$ 个 $r$ ，我们只需要重复出现这两种单元中的一个，就能避免其对神之字符串进行贡献

思路明确之后，我们开始组合答案。首先要有一个不贡献部分，其长度为 $k+1$ ，贡献部分，其长度为 $m$ ，那么可以得到以下算式

$n = x(k+1) + m + (0/1)$

为什么会多出后面的 $(0/1)$ ，根据数学知识可以了解到$k \geqslant 1$，那么而 $ m = 2f $  ,其中 $f$ 为重复单元数，那么相当于答案肯定最后会对2取模，可能出现的常数就为 $(0/1)$ 

**但要注意一个问题，如果我们选取 $rlll$ 作为不贡献子串，而选 $lr$ 作为贡献子串，最后末尾的不贡献子串需要特殊处理，不然就不满足k的要求,因此更新算式**

$n = x(k+1) + k + m + b \Rightarrow n = (x+1)(k+1) + m -1 + b$ 

理解以上操作，我们在对 $k$ 进行细致考虑

$ k = 1$ 时，没有避免贡献结构，但题目保证一定有结果，所以最长子串一定等于 $n$

$ k \geqslant 3$ 时，不贡献组最小单元为 $rlll$ ，尾端为 $rll$ ，一定不影响贡献组贡献答案。

$ k = 2 $ 时，不贡献组最小单元为 $rll$ ，尾端为 $rl$ 变成了一个贡献组，那么就让贡献组数目减去 $1$ ，然后在末尾补上另一组不贡献组 $llr$ 防止出现错误

综上，可以得出代码的具体思路，有些地方可以简化，比如判断末尾位数，到代码里有注释。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 1e5+7;
int n,m,k;
int main()
{
	cin>>n>>m>>k;
	int lc = n - m + 1;
	int tot = lc / (k+1) - 1, y = n;
	// 完成算式 n = x(k+1) + k + m + b => n = (x+1)(k+1) + m - 1 + b
   // 因为可能有 k == 2 情况特判末尾比较繁琐 干脆直接计算剩余位数，也就是y的含义
	for(int i=1;i<=tot;i++) //补充不贡献组
	{
		cout<<"r";
		for(int i=1;i<=k;i++) cout<<"l";
		y = y - 1 - k;
	}
	if(tot >= 0) // 补充不贡献组末尾，只有存在不贡献组时，又因为tot的含义是不贡献组数目 - 1 那么当出现tot = 0说明不贡献组只有一组也是尾端组，才会有末尾组
	{
	    cout<<"r";
        for(int i=1;i<k;i++) cout<<"l";
        y = y - k;
	}
	int rc; //计算需要补充贡献组数目
	if(k == 2 && tot >= 0) rc = m/2 - 1;  //存在末尾组且k == 2时，才需要让贡献组减一
	else rc = m/2;
	for(int i=1;i<=rc;i++) 
	{
		cout<<"lr"; y = y - 2;
	}
	tot = y / (k+1); y = y % (k+1); //对剩余位数补充完整
	for(int i=1;i<=tot;i++)
	{
		for(int i=1;i<=k;i++) cout<<"l";
		cout<<"r";
	} 
	for(int i=1;i<=y;i++) cout<<"l";
	return 0;
}
```
