### Subtask 1,2

显然，当 $n = m$ 时，整个串是神之字符串；当 $k = 1$ 时，必须把所有的 'l' 和 'r' 间隔放，这样的话整个串就也是神之字符串，同时满足 $n=m$ 的情况。

所以我们把这两种情况一起讨论，放 "lrlrlr...lr" 就行了。

### 另外的情况

我们可以把神之子串间隔着放在答案字符串里，然后假如说我们使神之子串的模板为 "lrlr...lr（共 $m$ 个字符）"，则要使右侧的字符不被包含进神之子串里，那么我们只需要连续放两个一样的字符就行了。于是答案字符串的模板就变成了 "lrlr...lrll(右边再放一个神之子串)lrlrl...lrlllrlr...（以此类推）"。然而这么放并不满足 $k=2$ 的情况。

因为我现在的神之子串开头是 'l', 结尾是 'r'，如果我在我的神之子串之间放了两个 'l' 或者 'r' 那么它总会与两侧的神之子串的开头或者结尾连起来，使 $k=3$ 。所以我要使神之子串的开头和结尾是同一个字符。

这个非常好办，只要把我的神之子串的结尾加一个 'rl'，变成 "lrlr...lrrl"，这样它的首尾就统一了，而且题目说了，$4\le m\le 10^5$，也就是说我的神之子串保证能放 "lrrl"，然后右边放 "rr"，再放神之子串，以此类推，答案字符串模板就变成了 "lr..lrrlrrlr..lrrl..."。

这样写起来有点麻烦，因为第二个及以后的神之子串 "lrlr...lrrl"左边有对少个 "lr"并不重要，所以我们可以把它们简化成 "lrrl"，这样我的答案就是神之子串 "lrlr...lrrl" 加上右边无数个 "rrl"。然后这道题就非常好写了。

下面放上我的代码。
```cpp
#include<cstdio>
int n,m,k;
char ans[100005];
int i,p,q;
int main(){
	scanf("%d%d%d",&n,&m,&k);
	if(k==1||n==m){
		for(i=1; i<=n; i++)
			if(i&1) putchar('l');
			else putchar('r');
		return 0;
	}
	p=m-2;
	for(i=1; i<=p; i++)
		if(i&1) ans[i]='l';
		else ans[i]='r';
	ans[++p]='r';
	ans[++p]='l';
	q=(n-m)/3;
	for(i=1; i<=q; i++){
		ans[++p]='r';
		ans[++p]='r';
		ans[++p]='l';
	}
	ans[++p]='r';
	ans[++p]='r';
	for(i=1; i<=n; i++)
		putchar(ans[i]);
}
```
