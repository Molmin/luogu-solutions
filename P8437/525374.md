##### 写在前面
赛时写挂了，打表找规律找了一小时愣是每找出来……

## 题目大意
输入三个数 $n$，$m$，$k$，其中 $m$ 为不小于 $4$ 的偶数，$n$ 为不小于 $4$ 的整数。

试构造一个字符串，由字符 ```l``` 和 ```r``` 构成。并且需满足以下条件：

- 字符串的长度为 $n$。
- 字符串中最长的 ```l``` 和 ```r``` 数量相等的字串长度为 $m$。
- 字符串中连续的相同字符数量不能超过 $k$。

## 解题思路
考虑部分分。

### Subtask 1，$k=1$
即连续的字符数量不能超过 $1$，因此就是 ```l``` 和 ```r``` 交替出现。
### Subtask 2，$n=m$
即字符串长度与最长的数量相等的子串长度相等。和 Subtask 1 一样，让 ```l``` 和 ```r``` 交替出现即可。前两个都很好想。
### Subtask 3，$k\ge 3$
连续的字符数量的上限比 $3$ 大。我们在做前面两个 subtask 时，想到了让 $l$ 和 $r$ 交替出现。因此我们考虑让**前 $m$ 个字符交替出现**，然后**后面的 $n-m$ 个字符都以 ```lllr``` 的形式出现**。可以[证明](https://www.luogu.com.cn/record/80456010)这种构造方法是对的。

证明： 设字符串的每一位分别为 $1,2,3,4\cdots$。

**条件 $1$：** 
$m+(n-m)=n$，该构造字符串长度为 $n$。 

**条件 $2$：**
在 $[1,m]$ 和 $[2,m+1]$ 中的字符构成 ```l``` 与 ```r``` 数量相等的子串，且长度均为 $m$。

假设还存在比 $m$ 长的这样的子串，考虑贪心得知是从 $2$ 号位置开始，但是在 $m+1$ 位置以后，每经过了一个 ```lllr``` 的子串，$l$ 的数量都会比 $r$ 多 $1$ 个（具体可以自己手动模拟参考）, 因此假设不成立。所以最长的这样的子串长度为 $m$。

**条件 $3$：**
在子串 $[1,m]$ 中最长相同字符数量为 $1$，在子串 $[m+1,n]$ 中最长相同字符数量为 $3$。因为 $k\ge 3$，所以整个字符串满足最长相同字符数量比 $k$ 小。

### Subtask 4，无特殊性质。
其实本 subtask 就是考察 $k=2$ 的情况。这个时候如果我们还按照 Subtask 3 的方法来构造的话，就会出现问题。

**有问题的方法**： 前 $m$ 个字符让 ```l``` 和 ```r``` 交替出现，之后的 $n-m$ 个字符以 ```llr``` 的形式出现，因为 $k=2$ 了。

那么我们来随便举一个样例：$n=10,m=6,k=2$。 按照如上方法，我们构造出来的字符串应该是 ```lrlrlrllrl```，但是我们发现 $[2,9]$ 的子串 ```l``` 和 ```r``` 的数量也相等。所以最长的这样的子串长度应该是 $8$ 了。

考虑新的构造方法，我们可能发现没有思路了，这时我们就可以用一种朴素的方法：[打表](https://www.luogu.com.cn/paste/7ql71t3z)找规律。

输进去几个样例，我们会发现有一种这样的构造方法：就是把第 $1$ 和 第 $2$ 个字符给调换一下，变成 ```rl```，其他都一模一样。例如刚才的样例，输出 ```rllrlrllrl```

我们要用严谨的态度来解决问题，所以我们再次[证明](https://www.luogu.com.cn/record/80453481)一下这样的正确性：

证明: 设字符串的每一位分别为 $1,2,3,4\cdots$。

**条件 $1$：**
不说了。

**条件 $2$：** 
仍然考虑贪心，得知是从 $2$ 号位置开始，能够得到长度最大的这样的字符串。但是这个时候，我们发现第 $2$ 个位置变成了 $l$。 因此，经过第一次 ```llr``` ，我们发现 ```l``` 的个数会比 ```r``` 多 $2$。此后每经过一次，差增加 $1$。所以最长的这样的子串就是 $[1,m]$，长度为 $m$。

**条件 $3$：** 
不说了。

因此这种构造方法是正确的。


## 代码
其实经过整合之后，Subtask 2 和 Subtask 3 都可以合并到 Subtask 4 里，所以只需要讨论 Subtask 1 和 Subtask 4 就可以了。我这里为了方便，把所有情况都写上了。

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,m,k,now,tot;
char a[100010];
bool p; 
int main(){
	cin>>n>>m>>k;
	if(k==1){
		for(int i=1;i<=n;i++)
			if(i%2==1)cout<<"l";
			else cout<<"r";
		return 0; 
	}
	if(n==m){
		for(int i=1;i<=n;i++)
			if(i%2==1)cout<<"l";
			else cout<<"r";
		return 0; 
	}
	if(k>=3){
		for(int i=1;i<=m;i++)
		if(i%2==1)cout<<"l";
		else cout<<"r";
		tot=m+1;
		now=1;
		while(tot<=n){
			if(now==1||now==2||now==3){
				cout<<"l";
				now++; 
			}else{
				cout<<"r";
				now=1;
			}
			tot++;
		}	
		return 0;
	}
	cout<<"rl";
	for(int i=3;i<=m;i++){
		if(i%2==1)cout<<"l";
		else cout<<"r";
	}
	for(int i=1;i<=n-m;i++)
		if(i%3==1||i%3==2)cout<<"l";
		else cout<<"r";
	cout<<endl;
	return 0;
}
```

[题目传送门](https://www.luogu.com.cn/problem/P8437)。不得不说这道题挺难的。