# 分析

最初看见这道题，一般会有一些思路，但是并不完善，于是我们可以尝试去做子任务（~~骗分~~），顺便理清此题的思路。

### Subtask 1

由于 $k=1$，所以只能 ```l``` 和 ```r``` 交替出现，又因为题目保证有解，所以肯定是对的（不然就无解了）。

### Subtask 2

这个同样是 ```l``` 和 ```r``` 交替出现，因为 $n=m$，又为了连续字符不超过 $k$，这是最保险且很正确的做法。

### Subtask 3

$k\ge 3$，这时我们可以使用一种贪心算法：先 ```l``` 和 ```r``` 交替出现，知道长度达到 $m$，接下来，因为 $m$ 为偶数，所以刚刚最后输出的字符为 ```r```，那么输出 $k$ 个 ```l```，再输出一个 ```r```，再输出 $k$ 个 ```l```······循环直到总长度达到 $n$。

容易证明，因为 $k\ge 3$，所以前面的不会与后面的构成更长的神之子串，而后面的最多也就出现长度为 $2$ 的神之子串，对于 $m\ge 4$ 来说根本不会出错。

### Subtask 4

这里增加了 $k=2$ 的情况，如果按照上述做法构造，就会出错，比如看下面这组例子。

输入： ```10 4 2 ```

输出： ```lrlrllrllr```

我们发现，第 $2$ 到 $7$ 个字符构成了一个长度为 $6$ 的神之子串，而且我们还发现，是一个 ```rllr``` 的子串坏了好事，那么我们考虑特殊构造数据：循环输出 $m-4$（留 $4$ 个位置给 ```rllr```） 个 ```rl```，然后循环输出 ```rll``` 直到达到长度 $n$。

由于考试时间紧张，代码非常的丑陋与粗糙，这里只放个[链接](https://www.luogu.com.cn/paste/bma6tppr)。

下面放修缮过的代码。

#### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
int n, m, k;
signed main() {
	cin >> n >> m >> k;
	if (k == 1 || n == m) //subtask 1 & 2
		for (int i = 1; i <= n; i++)
			if (i % 2)//循环输出 l , r 
				cout << 'l';
			else
				cout << 'r';
	else if (k == 2) {
		int num = (m - 4) / 2; //计算输出多少个 rl，因为 rl 占两个字符，所以要除以 2 
		for (int i = 1; i <= num; i++)
			cout << "rl"; 
		for (int i = 1; i <= n - num * 2; i++)
			if (i % 3 == 1) //输出 rll 
				cout << 'r';
			else
				cout << 'l';
	}
	else {
		for (int i = 1; i <= m; i++)
			if (i % 2)//输出 l ，r直到到达 m 
				cout << 'l';
			else
				cout << 'r';
		for (int i = m + 1; i <= n; i++) {//输出 k 个 l，1 个 r，循环。 
			for (int j = 1; j <= k; j++) {
				if (i > n)
					break;
				cout << 'l', i++;
			}
			if (i <= n)
				cout << 'r';
		}
	}
	return 0;
}
//当然，上述代码也可以用问号表达式等方法进一步精简（不过懒得改了 
```
