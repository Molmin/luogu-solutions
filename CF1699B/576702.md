## 题意简述
多组数据，每组数据给定两个偶数 $n$ 和 $m$，要求构造一个 $n$ 行 $m$ 列的01矩阵满足对矩阵内任意的方格 $(i,j)$，都有且仅有两个相邻的方格的值与 $(i,j)$ 的值不同。
## 题目分析
很显然这是一道**构造题**，不难发现，当 $m$，$n$ 都为 $2$ 时，

$\begin{bmatrix}
 0&1 \\
  1&0
\end{bmatrix}$


显然是一种合法的方案，我们称为01矩阵A，而

$\begin{bmatrix}
 1&0 \\
  0&1
\end{bmatrix}$

则是另外一种合法的方案，我们称为01矩阵B。我们观察样例一，可以发现该样例的答案可以通过矩阵A和矩阵B拼接而成，这就给了我们一些启发。

而仔细观察样例三，如下图，样例三的另一种答案也可以通过矩阵A和矩阵B拼接而成。

$\begin{bmatrix}
  1& 0 &0 &1 \\
  0& 1 &1  &0 \\
  0& 1& 1 & 0\\
  1&0  &0  &1
\end{bmatrix}$

这时，我们想到，是否可以只使用矩阵A和矩阵B就可以拼成满足答案的矩阵？

我们从特殊到一般，先考虑只有 $n$ 等于 $2$ 的情况(只有 $m$ 等于 $2$ 的情况和这是等价的)

当 $m$ 等于 $6$ （ $m$ 等于 $4$ 的情况为样例一），我们发现：

$\begin{bmatrix}
  0&1  & 1 &0&0&1 \\
  1& 0 &0  &1&1&0
\end{bmatrix}$

是合法的一种答案，它也可以被矩阵A和矩阵B拼成。当 $m$ 继续增大，我们只需要继续往右拼接矩阵A和矩阵B就可以满足题目要求。

现在考虑 $n$， $m$ 都大于 $2$ 的情况，以 $m$ 等于 $6$， $n$ 等于 $4$ 为例，

$\begin{bmatrix}
  1&0  & 0 &1  &  1& 0\\
  0&  1&  1& 0 &  0& 1\\
  0& 1 &  1& 0 &0  & 1\\
 1 & 0 &0  &1  &1  &0
\end{bmatrix}$

为一个合法答案，显然它可以被矩阵A和矩阵B拼成，而当 $n$， $m$ 继续增加时，我们只需要继续往矩阵上拼接矩阵A和B，即可构造出对应的答案。

还有一个问题：如何修改答案矩阵的元素并输出？

我们发现：构成答案的01矩阵的顺序也是有规律的，如下图对应 $m$ 等于 $6$，$n$ 等于 $4$ 的情况：

$\begin{bmatrix}
  B&A  &B \\
  A& B &A
\end{bmatrix}$

我们可以把答案矩阵分割为一个个 $2$ $\times$ $2$ 的小矩阵，我们只需要枚举每个小矩阵的左上角坐标，并修改该小矩阵内方格的值，最后输出。

至此，本题得到完美解决。
## 代码
注：代码中快读已省略。
```cpp
#include<bits/stdc++.h>
using namespace std;
int a,b;
int matrix1[3][3];//矩阵A
int matrix2[3][3];//矩阵B
int M[51][51];//答案矩阵
int main()
{
    //---------------初始化矩阵
	matrix1[1][1]=0;
	matrix2[1][1]=1;
	matrix1[1][2]=1;
	matrix2[1][2]=0;
	matrix1[2][1]=1;
	matrix2[2][1]=0;
	matrix1[2][2]=0;
	matrix2[2][2]=1;
    //---------------
	int T;
	T=read();
	while(T--)
	{
		a=read();
		b=read();
		a/=2;
		b/=2;
		for(int r=1,x=1;r<=a;r++,x+=2)//坐标变换
		{
			for(int f=1,y=1;f<=b;f++,y+=2)
			{
				if((r+f)&1)//修改答案矩阵
				{
					M[x][y]=matrix1[1][1];
					M[x+1][y]=matrix1[2][1];
					M[x][y+1]=matrix1[1][2];
					M[x+1][y+1]=matrix1[2][2];
				}
				else
				{
					M[x][y]=matrix2[1][1];
					M[x+1][y]=matrix2[2][1];
					M[x][y+1]=matrix2[1][2];
					M[x+1][y+1]=matrix2[2][2];
				}
			}
		}
		for(int r=1;r<=a*2;r++)
		{
			for(int f=1;f<=b*2;f++)
			{
				cout<<M[r][f]<<" ";
			}
			cout<<endl;
		}
	}
	return 0;
}

```
