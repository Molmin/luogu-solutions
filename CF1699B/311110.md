# 背景

这一天是期末考试前的 2 天，趁着他们自由复习来了机房，决定先写一场之前的比赛练练手，然后就发现全是构造……

# 题目分析

本蒟蒻觉得本题最难的地方就在于读题 ~~（本蒟蒻一开始就没读懂错了两次……）~~，他是什么意思呢，意思就是让你所打印出的表格中，对于每个元素，其邻居恰有两个与其颜色不同（**注意是只有两个**）。

样例中给的输出看起来没有什么规律可循，我们可以自己想一想怎样构造出一个表格满足其要求。

对于样例，其实我们可以这样构造：

第一组：

```
 0  1  1  0
 1  0  0  1
```

第二组：
```

 0  1  1  0 
 1  0  0  1
 1  0  0  1
 0  1  1  0 
```
大家到这里或许可以发现：其实这样构造出的表格其实都是由
```
 0  1  
 1  0   
```
旋转复制而来。

由于 $n$ 和 $m$ 都是偶数，说明我们这样将小表格旋转复制成大表格的做法是正确的！

# 代码实现

可以发现其实每组解都是由
```
 0  1  1  0  0  ……
 1  0  0  1  1  ……
 1  0  0  1  1  …… 
 0  1  1  0  0  …… 
 1  0  0  1  1  …… 
 … …  … …  …  … 
 ```  
这个表格截取而来，所以我们可以先预处理出来一个大表格：

```cpp
for(int j = 1, i = 1; j <= 50; j += 4) a[i][j] = 0, a[i][j+1] = 1, a[i][j+2] = 1, a[i][j + 3] = 0; 
for(int i = 2; i <= 50; i+=2){  //n、m范围都是到50
	for(int j = 1; j <= 50; j+=4){
		if(i%4 == 0){
			a[i][j] = 0, a[i][j+1] = 1, a[i][j+2] = 1, a[i][j + 3] = 0;
			a[i+1][j] = 0, a[i+1][j+1] = 1, a[i+1][j+2] = 1, a[i+1][j + 3] = 0;
			}
		else{
			a[i][j] = 1, a[i][j+1] = 0, a[i][j+2] = 0, a[i][j + 3] = 1;
			a[i+1][j] = 1, a[i+1][j+1] = 0, a[i+1][j+2] = 0, a[i+1][j + 3] = 1;
		}
	}
}
```

然后在输入数据时截取输出就行了：

```cpp
while(T--){
	int n, m;
	cin >> n >> m;
	for(int i = 1; i <= n; i++){	//截取表格输出
		for(int j = 1; j <= m; j++){
			cout << a[i][j] << " ";
		}
		cout << endl;
	}
}
```
~~应该就不用附完整代码了吧……~~


于是，这道题就做完咯！

**完**




