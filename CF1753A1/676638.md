## 题目大意

给出一个长度为 $n$ 的序列 $\{a_n\}$，对于任意 $a_i$ 有 $a_i=1$ 或 $a_i=-1$。我们可以把整个序列分为 $k$ 个区间，这 $k$ 个区间互相无交集，但完整构成原来的序列。对于第 $i$ 个区间 $[l_i,r_i]$，有 $s_i=a_{l_i}-a_{l_i+1}+a_{l_i+2}-\dots \pm a_{r_i}$，我们需要给出一种分割方案使得 $\displaystyle\sum_{i=1}^{k}s_i=0$。

## 思路

我们先考虑什么情况下无解。

当 $n$ 为奇数时，整个序列必定只能分成 $k_1$ 个偶数个数字构成的区间及 $k_2$ 个奇数个数字构成的区间。因为 $n$ 是奇数，所以 $k_2$ 必定为奇数。

我们先考虑偶数个数字构成的区间。因为每个位置只能 $+1$ 或 $-1$，所以 $+1$ 与 $-1$ 的数量的差必定为偶数，那么最后的 $s_i$ 必定为偶数。同理，我们可以知道奇数个数字构成的区间的 $s_i$ 必定为奇数。

奇数个奇数与偶数个偶数相加必定还是奇数，不可能为 $0$。于是我们知道 $n$ 为奇数的时候无解。

------------
接下来我们考虑 $n=2$ 时如何构造。如果 $a_1=a_2$，那么割成区间 $[1,2]$，于是 $s_1=a_1-a_2=0$。如果 $a_1\ne a_2$，那么有 $a_1=-a_2$，于是把两个数分别分成两个区间 $[1,1]$ 与 $[2,2]$，有 $s_1+s_2=a_1+a_2=0$。

我们发现，$n$ 为偶数时我们可以把它分成 $\dfrac{n}{2}$ 个长度为 $2$ 的序列，用上面的方法构造。因为没有要求 $k$ 最小，所以这种做法是正确的。

代码如下：

```cpp
int t,n,a[N];
signed main(){
	t=read();for(int nowt=1;nowt<=t;nowt++){
		n=read();for(int i=1;i<=n;i++) a[i]=read();
		if(n%2==1){puts("-1");continue;}//判
		if(n==2){
			if(a[1]-a[2]==0){puts("1\n1 2");continue;}
			if(a[1]+a[2]==0){puts("2\n1 1\n2 2");continue;}
			puts("-1");continue;
		}int nowres=0;for(int i=1;i<=n;i+=2){
			if(a[i]-a[i+1]==0) nowres++;
			else nowres+=2;
		}printf("%lld\n",nowres);//先要输出 k
		for(int i=1;i<=n;i+=2){
			if(a[i]-a[i+1]==0) printf("%lld %lld\n",i,i+1);//同一个区间
			else printf("%lld %lld\n%lld %lld\n",i,i,i+1,i+1);//两个区间
		}
	}return Strelitzia_H;
}
```