大家好，我喜欢套娃。

首先时间倒流变加边+折半。

然后我不会处理折半，于是我进行一个折半的折半。

--------------

考虑对于每个时刻处理出 $dis[i](1\leq i \leq n)$ 表示当前 $1$ 到 $i$ 走 $4$ 步的最短路，不存在即为 $\inf$。

（$i$ 到 $n$ 同理，这里只讨论一半。）

然后我不会维护 $dis$，于是我进行一个**再次折半**。

设 $D[i][j][k]$ 表示从 $i$ 出发，依次走 $(i,j)$ 与 $(j,k)$ 边的距离，不存在记为 $\inf$。

可以发现当且仅当在这两条边迟**加入**（因为时间倒流所以是加边）的那一条加入的时刻，$D[i][j][k]$ 会发生改变。

于是维护 $D$ 的**总**复杂度为 $O(n^3)$。

设 $L[i][j]$ 表示从 $i$ 出发走 $2$ 步到达 $j$ 的最短路，不存在同样记为 $\inf$。

于是有 $L[i][j]=\min_{k=1}^nD[i][k][j]$。

可以发现当 $D[i][j][k]$ 被修改时，$L[i][k]$ 会被取 $\min$。因此 $L$ 总的修改次数不超过 $O(n^3)$。

接下来考虑如何用 $L$ 来维护 $dis$。

首先，当 $L[i][j]$ 被修改时，$dis[j]$ 会被修改，因为存在一条路径 $(1,?,i,?,j)$。

此时变化为 `dis[j]=min(dis[j],L[1][i]+L[i][j])`，这个过程记为 ①。

但是当 $i=1$ 的时候，由于存在 $(1,?,j,?,u)(1\leq u \leq n)$，我们要对每个 $1 \leq u \leq n$ 执行 `dis[u]=min(dis[u],L[1][j]+L[j][u])`，这个过程记为 ②。

这样看起来复杂度不是很对，达到了 $O(n^3 \times n)=O(n^4)$，但是其实不是。

执行 ① 的次数等于 $L$ 修改的次数，为 $O(n^3)$。

但是执行 ② 的次数等于 $L[1][*]$ 的修改次数，再往前导就是 $D[1][*][*]$ 的修改次数，为 $O(n^2)$。

所以 ② 的总复杂度仍为 $O(n^3)$。程序的总复杂度为 $O(n^3)$。