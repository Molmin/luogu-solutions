好像感觉我的做法和其他人都不一样，写一下。

----

每条边有个被删除的时间，那么一条路径只要考虑这个时间最小的边。

考虑 meet-in-middle，那么转化成 $k=4$，然后从 $1$ 到达任意一个点 $x$，然后最小时间为 $t$ 的答案（到 $n$ 的同理，这样刚好 $\mathcal{O}(n^3)$ 个要求的东西）。

然后再枚举一遍中间的这个点 $y$，然后变成 $1\to y,y\to x$ 并且各经过两条边的情况。这个时候 $1\to y$ 只有 $\mathcal{O}(n)$ 种方案，$y \to x$ 也只有 $\mathcal{O}(n)$ 种方案。而且我们只注意最小值，最小值也只有 $\mathcal{O}(n)$ 种，那么把这 $\mathcal{O}(n)$ 种方案全部预处理出来然后排序，双指针即可。

规避排序的 $\log$ 可以基排，或者预处理一些东西，反正都是很平凡的东西。总的时间复杂度 $\mathcal{O}(n^3)$。不过写出来常数很大。[代码实现](https://www.luogu.com.cn/paste/vqkb6n7l)。