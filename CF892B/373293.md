思路相对比较简单。（吗？）

思路：

1. 输入。
2. 死亡线的位置（即 $kl$，在这个范围内的人能被后面的人杀死）初始为 $n-a[n]$。（最后一个人够得着的地方）
3. 从后往前遍历。如果现在第 $i$ 个人在死亡线内，即 $kl≤i$ 时，默认这个人被杀死（$ans$ 不为所动）。否则代表后面没有人能杀到他，那么答案加 1。
4. 更新此时线的位置，为 $min(kl,a[i])$。（只能往前杀，所以找能杀到的i 的最小值）
5. 因为第一次判断时最后一个人会被判断为死亡（因为 $n-a[n]$ 不可能大于 $n$），所以答案初始化为 1（最后一个人后面没有人杀他）。
6. 输出。

CODE：

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[1919810];//不要介意qwq
int main(){
	int n,i,ans=1,kl;
	scanf("%d",&n);
	for(i=1;i<=n;i++)scanf("%d",&a[i]);
	kl=n-a[n];//初始化
	for(i=n;i>=1;i--)
	{
		if(kl>i)ans++;//判断
		kl=min(kl,i-a[i]);//更新死亡线位置
	}
	
	printf("%d",ans);
	return 0;
}
```