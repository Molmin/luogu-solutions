[题目链接](https://www.luogu.com.cn/problem/SP9889)

题意：

多组数据。

每组数据先给你一个初始为 $1-n$ 的排列，再给出 $Q$ 次操作，每次操作具体为：找出排列中值为 $x$ 的数，输出它之前有多少个数，接着将它移到序列首端。

$n,Q \leq 10 ^ 5$。

直接模拟肯定是不行的，看到题目风格，我们很容易想到要用某种数据结构优化。

由于 $Q \leq 10^5$ 所以我们最多把一个数移到序列首端 $10^5$ 次。

我们考虑在序列前加上一个长度为 $10^5$ 次的全 $0$ 序列，同时记录 $a_i$ 为序列第 $i$ 位之前有多少个 $0$。

那这样每次操作一个数后，他之前的数的 $a_i$ 值会全部减一，因为它占据了一个 $0$。这个操作可以用线段树维护。

那每个数之前的数即为它在序列中的位置减去它之前 $0$ 的个数。

核心代码如下，线段树的部分就不贴啦。

```cpp
signed main()
{
	int T = read();
	while (T--)
	{
	    n = read(); m = read(); int now = 100001; // now 为当前序列中第一个数的位置
	    memset(tree, 0, sizeof(tree)); memset(tag, 0, sizeof(tag));
	    for (int i = 1; i <= n; i++) b[i] = i + 100000;
	    for (int i = 1; i <= 100001; i++) a[i] = i - 1;
	    for (int i = 100002; i <= n + 100000 + 1; i++) a[i] = a[100001];
	    for (int i = n + 100000 + 2; i <= 200000; i++) a[i] = a[i - 1] + 1; 
	    build(1, 1, 200000);
	    for (int i = 1; i <= m; i++) 
	    {
	        int x = read();
	        cout << b[x] - 1 - query(b[x], b[x], 1, 1, 200000) << " ";
	        update(now, b[x], 1, 1, 200000, -1);
	        b[x] = now - 1;
	        now--;
	    }
	    puts("");
	}
    return 0;
}
```

