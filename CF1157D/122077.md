这是一道挺诡异的构造题，题目描述也需要改一下，其中要求的第三条应该为**a**到第**k**项的求和等于**n**，下面就让我们进入正题

首先让我们考虑一个数列：

**1，2，3，4，5，……，k-1，k**

这是最基本的等差数列，很明显任意一项也都满足题目中所描述的条件——证明：设这是第**i**项(**i**>=2)则需满足**i-1 < i <= 2 * (i-1)** 左边很明显成立现在只需关注右边将其左右移动一下则变为**i>=2**很明显这在(**i**>=2)的条件下恒成立

那么便考虑什么情况下构造不出来，很明显上述数列是最小的符合题意的数列，所以构造不出来的条件**之一**就是上述数列的和比**n**大，即**k*(k+1)/2>=n**

下面就来证一个引理：任意公差为1的数列相邻两项就算加1也不会不满足提议设其第**i**项为**m**(**m**>=2)， 只需证(m-1)+1<m+1<=2*[ (m - 1) +1 ]这十分好证，在此请读者们自行证明

由引理可以让我们想到一个问题，**上述数列相邻两项加任意实数是不是都仍然满足题意**，这也十分好证只需将加的数设为**l**然后根据题意列式即可

于是我们就得出对**n**操作的第一步：首先从**n**中挖出**k*(k+1)/2**来构造出上述数列然后对于剩下的**n-k*(k+1)/2**将他分成k份（每一份都是整数）将平凡的等差数列（上述数列）每一项都加上这k份中的一份由刚才的推论可以得出加上了这**k**份后的数列仍然满足题意

现在只需要考虑剩下的那被分完的n所剩下来的部分，因为**n-k*(k+1)/2**不一定被k整除所以一定会有剩余，我们设这个剩余为**nn**，很明显我们想要把**nn**也均分给完成了第一部的数列，由引理知假如相邻两项都加一则数列仍然满足题意，但是由于**nn<=k**所以必定会有一项能加一而相邻的一项不能加一，不能加的肯定在左边，因为假如第i项加了但第i+1项没加那么这两项就会相等因为这个数列公差为一
在刚才证明引理推论时可以发现到后面当第i项的值越来越大时他与第i-1项的值的俩倍的差会越来越大所以假如这个断层出现在后面我们完全不用担心，所以我们的任务是摸清楚在哪里的断层会造成影响

这很好知道，当断层出现在1，2之间时会出现问题所以我们不能把断层放在这里，而会出现这种情况的**n**必定等于**k*(k+1)/2+k-1**所以在这里需要特判一下，我们只需把那个多余的一给最后一位就行了，但是这里也还需特判，若k==3时输出的数列就会变为1，2，5这很明显是不对的所以也需要特判

我们的第二步差不多也就出来了：从后到前把每一位加上一直到**nn**耗尽，而且还需要特判

差不多也就是这么多了，有问题欢迎私信，把我的博客厚颜无耻地贴上[博客](https://www.luogu.org/blog/ailundeyugang/#)

把代码贴上

```cpp
#include <iostream>
#include <vector>
#include <queue>
#include <cstdio>
#include <map>
#include <algorithm>
#include <cstring>
using namespace std;
typedef long long ll;
const int maxn=200005;
ll a[maxn],n,k,t,l;
int main(){
	cin>>n>>k;
	if (k*(k+1)/2>n){
		cout<<"NO"<<endl;
		return 0;
	}
	if (n==k*(k+1)/2+k-1){
		if (k==1){
			cout<<"YES"<<endl;
			cout<<'1'<<endl;
			return 0;
		}
		if (k==2){
			cout<<"NO"<<endl;
			return 0;
		}
		if (k==3){
			cout<<"NO"<<endl;
			return 0;
		}
		cout<<"YES"<<endl;
		cout<<'1'<<' '<<'2'<<' ';
		for (int i=3;i<=k;i++){
			if (i==k){
				cout<<i+2<<' ';
				return 0;
			}
			cout<<i+1<<' ';
		}
		return 0;
	}
	cout<<"YES"<<endl;
	ll sum=k*(k+1)/2;
	t=(n-sum)/k,l=(n-sum)%k;
	int tp=k;
	for (int i=1;i<=l;i++){
		a[tp]++;
		tp--;
	}
	for (int i=1;i<=k;i++){
		cout<<a[i]+i+t<<' ';
	}
}
```
