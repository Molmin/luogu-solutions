## 题意：
首先，对于每组数据而言，我们会已知一个密码锁的位数，转动后的数字与会如何转动的。设字母 $D$ 为逆转，但因为是求其初始的值，所以当前数字应该加 $1$；设字母 $U$ 为顺转，但同上，当前数字应该减 $1$。
## 思想：
我们将转动过程转化为：顺转 $ans$ 次（逆转的话 $ans$ 就减一），然后将该数字加上 $ans$ 再判断答案小于 $0$ 与大于 $9$ 的越界情况。（当然，也可以像题意所示，根据所给的转动过程直接一步步修改该数字的值。）
## 代码如下：
```
#include<bits/stdc++.h>
using namespace std;
int a[10001];
int main()
{
	int t,n;
	cin>>t;//外层t组数据
	while(t--)
	{
		cin>>n;
		for(int i=1;i<=n;i++)
		cin>>a[i];//输入
		for(int i=1,ls;i<=n;i++)
		{
			string s;
 			int ans=0;
			cin>>ls>>s;//输入转动次数与每次转动的顺逆
			for(int j=0;j<s.size();j++)
			if(s[j]=='D')ans++;//是顺转，答案加一
			else ans--;//否则是逆转，答案减一
			cout<<(a[i]+ans+20)%10<<" ";
 			/*因为字符串长度不会超过10，所以可以将
			答案加上20（处理负值）再对10取余（处理
			大于9的值）的方式来处理越界的情况*/
		}
		cout<<endl;
	}
	return 0;
}
```
