### 主要思路：前缀和+dp 
------------
首先我们拿到这道题目  
发现要编程算出**最小需要XXX的数量**   
欸这不就是编程得出**最优解**嘛  
用**记忆化搜索**和**dp**都能实现  
~~我更喜欢记忆化搜索~~，所以我们来使用**dp**解决这道题 

------------
使用dp首先需要**设计状态**和**状态转移方程**  
**设计状态**：f [ i ] 表示**前i人**需要的**最少机房数** ;  
**状态转移方程**： **f [ i ] =min( f [ i ] , f [ j ] + 1)**;  
**满足条件：**  
1、**一段内**的同学只有**唯一**的崇拜者；  
2、**一段内**的同学崇拜**神犇1、2**的人数1，人数2之差**小于等于m**；  
由于是**一段内**，我很自然地想到了**前缀和**  
  
  于是我们就可以得到AC代码  


------------

### 代码如下
```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;

int n, m, a[2505], f[2505], s[3][2505];
//定义变量（由于只有1，2两种情况，所以二维数组并不需要定义[2505][2505]

int dec(int x,int y)//decide判断函数
{
    return abs((s[1][y]-s[1][x])-(s[2][y]-s[2][x]));
    //返回一段内的同学是否有唯一的崇拜者
}

int main(void)
{
    scanf("%d%d", &n, &m);
    memset(f, 0x3f, sizeof(f));//初始化数组，使数组的每一个元素无限大
    for(int i=1; i<=n; i++)//读入
    {
        scanf("%d", &a[i]);
        s[1][i]=s[1][i-1]+1;//当前神犇1的崇拜者=之前神犇1的崇拜者的数量+1
        s[2][i]=s[2][i-1]+1;//当前神犇2的崇拜者=之前神犇2的崇拜者的数量+1
        if(a[i]==1) s[2][i]--;//如果当前这位同学支持1，则2--；
        else s[1][i]--;//否则1--；（偷懒写法
    }
    
    f[0]=0;
    f[1]=1;//赋初值
    for(int i=1; i<=n; i++)
    {
        for(int j=0; j<i; j++)
        {
            if(dec(j,i)<=m || s[1][i]-s[1][j]==0 ||s[2][i]-s[2][j]==0)
            //如果一段内的同学有唯一的崇拜者或崇拜神犇1、2的人数1，人数2之差小于等于m
                f[i]=min(f[i], f[j]+1);//选取f[i]与f[j]+1中的最小值
        }
    }
    
    printf("%d\n", f[n]);//输出答案
    return 0;//完美的结束！
}
```