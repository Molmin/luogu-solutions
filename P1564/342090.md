# 一篇适合 $\text{DP}$ 初学者的题解

这道题大家的代码都大同小异，不过萌新还是来篇较为**详细**的题解吧。

**先清晰一下题意：** 有 $n$ 个数，每个数要么是 $1$ 要么是 $2$，问最少分几段，使得每一段中只有相同的数，或者两种不同数字的数量之差 $<m$。

明显是一道 $dp$ 问题，先定义状态：设 $dp_i$ 为到了第 $i$ 个同学最小分的段数。

第 $0$ 个同学他不需要分段，毕竟本身也木有同学，所以 $dp_0=0$；

第 $1$ 个同学只能自己分一段，因为只有一个同学必须分段，所以 $dp_1=1$；

而其他的状态都先加设成 $\infty$，毕竟一个求最小值的问题如果都加设成 $0$ 最后答案也可能是 $0$。

再来定义状态：

我们可以先去枚举一个 $i$，表示到了第 $i$ 个同学，再去枚举一个 $j$，表示假设让区间 $[j,i]$ 砍成一段。

根据题意，先要判断这一段可不可以砍，有以下三中情况，只要满足一种就可以砍（题目上已经说的很清晰了：

- $\mid sum(1,j,i)-sum(2,j,i)\mid\le m$，两种不同数字的数量之差 $<m$。

- $sum(1,j,i)=0$ 没有数字 $1$。

- $sum(2,j,i)=0$ 没有数字 $2$。

其中 $sum(k,l,r)$ 表示区间 $[l,r]$ 中 $k$ 的个数。

然后若这一段合法，那么第 $i$ 个数便有两种选择：

- 不砍。那么 $dp_i$ 不变，毕竟没有分段，$dp_i=dp_i$。

- 砍。那就是上一个分段的地方 $j$ 的最小分段值加 $1$，$+1$ 因又砍了一段，$dp_i=dp_j+1$

两种决策取 $\min$，便是到了第 $i$ 个同学的最优解。

~~显而易见~~

时间复杂度：$\mathcal{O}(n^3)$

其中 $\mathcal{O}(n^2)$ 是循环，另一个 $\mathcal{O}(n)$ 是区间求和。但面对 $n\le2500$ 的数据量难以通过。

但我们发现，区间求和其实可以用前缀和来维护，这样就做到了 $\mathcal{O}(1)$ 查询！

设 $sum[k][i]$ 为区间 $[1,i]$ 中 $k$ 的数量。

对于每一个输入的 $a_i$，$sum[a_i][i]=sum[a_i][i-1]+1$。

而 $sum[(!(a_i-1))+1][i]=sum[(!(a_i-1))+1][i]$。

注意到了吗，这里巧妙的将 $1,2$ 这两个数字互相转换，先将 $1$ 转换成 $0$，或者 $2$ 转换成 $1$，将结果取反然后 $+1$，就是转换的结果。

这样，就能做到 $\mathcal{O}(1)$ 的查询了。

$Code:$ （压行严重，大佬勿喷

```cpp
#include<cstdio>
#include<cmath>
#include<algorithm>
using namespace std;
const int MAXN=2510;
int n,m,sum[3][MAXN],dp[MAXN],a[MAXN];
int main()
{
	scanf("%d%d",&n,&m);
	fill(dp+1,dp+1+n+5,0x3f3f3f3f),dp[0]=0,dp[1]=1;
	for(register int i=1;i<=n;i++) scanf("%d",&a[i]),sum[a[i]][i]=sum[a[i]][i-1]+1,sum[(!(a[i]-1))+1][i]=sum[(!(a[i]-1))+1][i-1];
	for(register int i=1;i<=n;i++) for(register int j=i-1;j>=0;j--) if((abs(sum[2][i]-sum[1][i]-(sum[2][j]-sum[1][j]))<=m)||(sum[2][i]-sum[2][j]==0)||(sum[1][i]-sum[1][j]==0)) dp[i]=min(dp[i],dp[j]+1);
	printf("%d\n",dp[n]);
	return 0;
}
```

$$\texttt{The End.}$$
