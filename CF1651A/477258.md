Update：之前提交的题解有一处误导级别的错误，现已修正，请管理大大再审核一下，谢谢。

数据很水，模拟应该可以过。但是数据如果变得很大，就会卡掉模拟的做法。这里介绍一种数论做法。

第一局比赛，$1$ 和 $2$ 比赛，$3$ 和 $4$ 比赛，$\dots$，$2^n-1$ 和 $2^n$ 比赛，由于此时每一组的和都是奇数，因此较小的获胜，留下 $1$，$3$，$\dots$，$2^n-1$。

接下来若干局，由于所有选手编号均为奇数，因此编号和总为偶数，于是每一轮都是留下编号较大的选手。不难发现，最后获胜的选手必为 $2^n-1$。

因此答案即为 $2^n-1$。

注意事项：

- $n$ 的范围非常小，整形变量即可存储。

- 数据比较弱，不需要快速幂即可 AC。对快速幂感兴趣的可以上网找度娘，这里不做多余介绍。

- 但是不能直接输出，因为若直接输出，会默认使用科学计数法进行输出，会导致出现奇怪的 WA。解决方案见代码。

理解了这些，代码就好写了。

```cpp
#include <iostream>
#include <cmath>
using namespace std;
int t,n;
int main(){
	cin>>t;
	while(t--){
		cin>>n;
		int x=pow(2,n)-1;//直接利用cmath库里的pow函数进行求幂。
        /*这里就是注意事项第三点了。若直接输出，会出现1.07374e+009这种奇怪的东西，会导致WA。*/
        /*解决方法：先用变量存储结果，再输出变量。*/
		cout<<x<<endl;
	}
	return 0;
}
```
