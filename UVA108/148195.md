本蒟蒻看这道题还没有动态规划这个做法,于是就发一发动态规划的题解.

这道题有一道很类似的题目 [P3009 [USACO11JAN]Profits S](https://www.luogu.com.cn/problem/P3009) ,那道题是一维的,而这道题则变成了二维的,但做法大同小异.

首先解释一下几个变量:

```cpp
int n;
int a[101][101];
int sum[101][101];
int f[101][101][101];
```
 $n$为题目中的矩阵边长;

 $a$数组,$a[i][j]$代表第 $i$ 行第 $j$ 列的元素的值;

 $sum$数组,$sum[i][j]$代表第 $i$ 行前 $j$ 个数的和;

 $f$数组,$f[i][j][k]$代表第 $i$ 行选定从第 $j$ 个到第 $k$ 个元素为前提下前 $i$ 行的最大值,简单的就理解为当矩阵的左下角为$(i,j)$,右下角为$(i,k)$时,最优矩阵的值;

然后看看状态转移方程:

```cpp
f[i][j][k]=max(0,f[i-1][j][k])+sum[i][k]-sum[i][j-1];
```
解释一下这个方程:

如果前 $i-1$ 行从第 $j$ 列到第 $k$ 列产生最优矩阵的值小于零,则第 $i$ 行不加入前面的矩阵,自成新矩阵, 那么前 $i$ 行从第 $j$ 列到第 $k$ 列产生最优矩阵的值就是本行从 $j$ 个元素到第 $k$ 个元素的和.

反之,如果前 $i-1$ 行从第 $j$ 列到第 $k$ 列产生最优矩阵的值大于零,则第 $i$ 行要加入前面的矩阵,那么前 $i$ 行从第 $j$ 列到第 $k$ 列产生最优矩阵的值就是前面的最优矩阵的值加上本行从 $j$ 个元素到第 $k$ 个元素的和.

![](https://cdn.luogu.com.cn/upload/image_hosting/gq568n5l.png)


就例如上面这个矩阵,当枚举到$f[2][1][3]$这个状态时,容易想到它是通过$f[1][1][3]$转移过来的,但$f[1][1][3]=(-1)+2+(-2)=-1<0$,所以$f[2][1][3]$不取$f[1][1][3]$的结果,因此$f[2][1][3]=max(0,f[1][1][3])+1+2+2=5$.

下面是 $AC$ 代码:

```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
int f[101][101][101];
int a[101][101];
int sum[101][101];
signed main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			cin>>a[i][j];
			sum[i][j]=sum[i][j-1]+a[i][j];
		} 
	}
	int ans=-0x7fffffff;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			for(int l=1;l<=n-j+1;l++){
				int k=j+l-1;
				f[i][j][k]=max(0,f[i-1][j][k])+sum[i][k]-sum[i][j-1];
				ans=max(ans,f[i][j][k]);
			}
		}
	}
	cout<<ans<<endl;
	return 0;
}

```