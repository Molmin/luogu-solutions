来来介绍黑科技了

首先我们想一想这题咋做

其实很简单，假设——

```a[] = 1 2 3 2 1```

于是我们可以把他从大到小排排序（为什么是从大到小呢？是因为我们尽量选择长得厘米多的月份，这是一个贪心的思想）：

```a[] = 3 2 2 1 1```

然后我们从```a[1]```开始选月份，如果```k```大于0的话，我们就选择a[ans]，并且ans++:

```
while(k > 0) {
    ans++;
    k -= a[ans];
}
```

那么问题来了，怎么从大到小排序呢？

- 冒泡排序，桶排序，归并排序，快速排序.....懒得打

所以就用sort吧！

那么问题又来了：

- 排序函数懒得打，咋办？

~~你这么懒，咋不去shi呢~~

广告：本C++隆重推出functional头文件！内含从大到小排序函数```greater<int> ()```！！！一行代码解决了排序函数！心动不如行动，赶快来试试吧！

~~咳咳~~，没错，```greater<int> ()```的确可以充当**从大到小**的比较函数，所以我们的排序算法就变成了一行：

```sort(a + 1, a + n + 1, greater<int> ())```

所以我们的整个代码就出来了：

```
#include <iostream>
#include <functional>
#include <algorithm>
using namespace std;

int k, n = 12, a[100001], ans;//月份总数为n（一共12个月），a数组为输入数组，ans为答案

int main() {
    cin >> k;//输入k
    for (int i = 1; i <= n; i++) cin >> a[i];//输入a
    sort(a + 1, a + n + 1, greater<int> ());//排序
    while(k > 0) {//如果k > 0
        ans++;//答案++
        k -= a[ans];//求出剩余厘米数数量
    }
    cout << ans;
    return 0;
}
```