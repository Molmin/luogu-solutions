Orz @Wen_kr 讲的一道有趣的（大雾）思维题

#### 题目大意：给定一个长度为 $n$ 的很长的数，在一次操作可以在其中放若干个加号隔开它，希望使得三次操作后这个数字变成一个一位数，求任意一种操作方案

首先，虽然数据范围是$2\times 10^5$，但是对于**任意一个数**本题都是有解的。

看到这个题第一映像肯定就是：直接一位一位拆，肯定很小了，但是只要细想（~~询问一下wkr~~）就会发现是有特例的！ 例如数码和事$289$，直接拆成289，而289无论怎样想要拆成1肯定都需3步，一共四步，是错的。

换一种思路，如果直接随机处理呢？反正289这种情况是很少见的，为什么不能随机拆分，然后暴力判断一下呢？确实可以。这样可以A了这道题，但是下面只讨论正确做法。（并且懒得给~~码~~代码了~）

需要进行分类讨论：

下文假设原数是$A$，$f(A)$为$A$的数码和

### 1. 当$f(A)\leq 288$

第一重仍然是直接直接一位一位拆

通过暴力打表发现除了$f(A)\neq199$的情况直接拆炸了其他情况第二维直接拆完全没问题！并且显然当$f(A)=199$的时候可以拆成$1+99$，$1+00$

但是至于为什么是288呢？请看下面分析

### 2. 当$289\leq f(A)≤999$

令$A=a_0a_1a_2...a_n$

我们假设

$X=a_0a_1+a_2a_3+...+a_{n-1}a_n$（若$n$不为偶数情况类似，不多写了）  
$Y=a_0+a_1a_2+a_3a_4+...+a_{n-2}a_{n-1}+a_n$

也就是说$X$是$A$从头开始两位两位拆的，$Y$是$A$从第二位开始两个两个拆的，于是有

$X+Y=11f(A)-9a_n$

由于显然$f(A)>9\times 9 = 81 ≥ 9a_n$ ， 有$X+Y>10f(A)$ 

假设$X$是其中较大的一个（哪一个大本质相同），

有$X>5f(A)$（显然的放缩）

由于$f(A)>288$，$5f(A)>1000$是肯定的了

为什么我们要煞费苦心让$X>1000$呢，假设构造一个序列

$s_0=a_0+a_1+...+a_n=f(A)$

$s_1=a_0a_1+a_2+a_3+...+a_n$

$s_2=a_0a_1+a_2a_3+a_4+a_5+...+a_n$

$...$

$s_{n/2}=a_0a_1+...+a_{n-1}a_{n}=X$

（这里是我们默认了$X>Y$假设$Y>X$那么只需要更改拆分方式）

$s$ 这个序列有什么性质呢？

1. $s$ 单调递增（显然）
2. $s$ 每一次增加量不会超过$81$ （ $a_i\times 9$ 也不到81）
3. $s$ 在递增过程中**一定会产生一次进位**，因为$f(A)\leq 999$而$X>1000$

假设 $s_p<1000,s_{p+1}>1000$ 有性质2 有$s_{p+1}\leq 1080$

而显然$1000\leq x\leq 1080$的数字都是可以两次拆分结束的。

那么我们可以先计算$X,Y$然后通过提到的方法得到一种拆分方式使得可以在三次拆分后结束。

看起来这还是一种极其特殊的情况，但是考虑为什么这个方法可行，本质上就是构造出了一次**进位**，并且进位后得到的那个值一定可以被两步拆出来。那么既然三位数可行，为什么更高位数不可可以用类似思路呢？

### 3. $1000\leq f(A) $

同样的，考虑构造出形如$1000…000ab$的形式。

然而这次通过两位两位拆是没法进位了，那么考虑三位三位拆

类似的，构造

$X=a_0a_1a_2 + a_3a_4a_5 + ...a_{n-2}a_{n-1}a_n$

$Y=a_0+a_1a_2a_3 + a_4a_5a_6 + ...+a_{n-4}a_{n-3}a_{n-2} + a_{n-1}a_n$

$Z=a_0+a_1+a_2a_3a_4 + a_5a_6a_7 + ...+a_{n-3}a_{n-2}a_{n-1} + a_n$

也就是从头开始拆，从第一个开始拆，第二个开始拆

同样假设$X>Y>Z$ 那么通过放缩这次有$X>30f(A)$

没错，显然这是一定会进位的！

接下来就是类似第二种情况的思路，构造 $s$ 序列

$s_0=a_0+a_1+...+a_n=f(A)$

$s_1=a_0a_1a_2+a_3+...+a_n$

$...$

$s_{n/3}=a_0a_1a_2+a_3a_4a_5+...+a_{n-2}a_{n-1}a_n$

同样假设在$s_{p}$的时候产生了一次进位，但是这一次性质就没有前面那么优秀了，每一次的增加量会达到999，没有达到预期的$1000...80$之内

首先形式化写出$s_{p-1}$

$s_{p-1}=a_0a_1a_2+...+a_ta_{t+1}a_{t+2}+a_{t+3}+a_{t+4}+...+a_n$

那么我们可以像第二种情况对于$a_{t+4}+...+a_n$进行另一种合并方式

$s_p'=a_0a_1a_2+...+a_ta_{t+1}a_{t+2}+(a_{t+3}a_{t+4}+a_{t+5})+a_{t+6}+...+a_n$

$....$

$s_n' = a_0a_1a_2+...+a_ta_{t+1}a_{t+2}+(a_{t+3}a_{t+4}+a_{t+5})+...+(a_{n-2}a_{n-1}+a_n)$

那么在这其中肯定会发生一次进位，为什么？

假设从$s_{p-1}$开始三个三个合并，序列至少会增加$X-s_{p-1}$由于$X>30f(A)$,$s_{p-1}<10f(A)$（还没进位）所以至少增加了$20f(A)$

但是按照这个枚举方法，之多增加了原来增加的$\frac{1}{11}$（这个可以手画一下很好推），就增加了至少$\frac{20}{11}f(A)$，一定可以进位！而现在的增加量再次变成了$81$，然后就做出来了。

------

由于全文均放缩了很多+yijan很懒，直接把第二个情况没讨论放进第三个情况写的（由于自己找不出反例），在cf上跑过去了。（如果有证明可以联系菜鸡yijan）所以这个又长又难看的code只是参考啦

```cpp
#include<iostream>
#include<cstring>
#include<cstdio>
#include<algorithm>
#include<cmath>
using namespace std;
#define MAXN 200016
int A[MAXN] , n , p , f;
int tp[9];
int ni( int x ) {
    int res = 0;
    for( int i = 8 ; i > 0 ; -- i ) if( x / tp[i] )
        printf("%d+",(x/tp[i]) % 10) , res += ( x / tp[i] ) % 10;
    printf("%d\n",x%10) , res += x % 10;
    return res;
}
int main() {
    tp[0] = 1; for( int i = 1 ; i < 9 ; ++ i ) tp[i] = tp[i-1] * 10;
    cin >> n;
    for (int i = 1; i <= n; ++i) scanf("%1d", &A[i]) , f += A[i];
    if( f < 289 ) {
        for( int i = 1 ; i < n ; ++ i ) printf("%d+",A[i]);
        printf("%d\n",A[n]);
        if( f == 199 )
            puts("1+99") , puts("1+00");
        else
            ni( ni( f ) );
    } else {
        int X = 0 , Y = 0 , Z = 0 , mx;
        for( int i = 1 ; i <= n ; i += 3 )
            if( i + 2 <= n ) X += A[i] * 100 + A[i+1] * 10 + A[i+2];
            else
            { for( int t = n ; t >= i ; -- t ) X += A[t]; i = n; }
        for( int i = 2 ; i <= n ; i += 3 )
            if( i + 2 <= n ) Y += A[i] * 100 + A[i+1] * 10 + A[i+2];
            else
            { for( int t = n ; t >= i ; -- t ) Y += A[t]; i = n; }
        for( int i = 3 ; i <= n ; i += 3 )
            if( i + 2 <= n ) Z += A[i] * 100 + A[i+1] * 10 + A[i+2];
            else
            { for( int t = n ; t >= i ; -- t ) Z += A[t]; i = n; }
        mx = max( X , max( Y , Z ) );
        if( X == mx ) {
            int tmp = f , tt = (int)log10( f ) + 1 , i;
            for( i = 1 ; i <= n ; i += 3 )
                if( ( tmp + A[i]*99 + A[i+1]*9 ) / tp[tt] )
                    break;
                else { printf("%d%d%d+",A[i],A[i+1],A[i+2]) , tmp += A[i]*99 + A[i+1]*9; }
            for( ; i <= n ; i += 3 )
                if( ( tmp + A[i]*9 ) / tp[tt] )
                    break;
                else { printf("%d%d+%d+",A[i],A[i+1],A[i+2]) , tmp += A[i] * 9;}
            printf("%d%d+",A[i],A[i+1]);
            tmp += A[i] * 9;
            for( int j = i + 2 ; j < n ; ++ j ) printf("%d+",A[j]);
            printf("%d\n",A[n]);
            ni( ni( tmp ) );
        } else if( Y == mx ) {
            int tmp = f , tt = (int)log10( f ) + 1 , i;
            printf("%d+",A[1]);
            for( i = 2 ; i <= n ; i += 3 )
                if( ( tmp + A[i]*99 + A[i+1]*9 ) / tp[tt] )
                    break;
                else tmp += A[i]*99 + A[i+1]*9 , printf("%d%d%d+",A[i],A[i+1],A[i+2]);
            for( ; i <= n ; i += 3 )
                if( ( tmp + A[i]*9 ) / tp[tt] )
                    break;
                else tmp += A[i] * 9 , printf("%d%d+%d+",A[i],A[i+1],A[i+2]);
            tmp += A[i] * 9;
            printf("%d%d+",A[i],A[i+1]);
            for( int j = i + 2 ; j < n ; ++ j ) printf("%d+",A[j]);
            printf("%d\n",A[n]);
            ni( ni( tmp ) );
        } else if( Z == mx ) {
            int tmp = f , tt = (int)log10( f ) + 1 , i;
            printf("%d+%d+",A[1],A[2]);
            for( i = 3 ; i <= n ; i += 3 )
                if( ( tmp + A[i]*99 + A[i+1]*9 ) / tp[tt] )
                    break;
                else tmp += A[i]*99 + A[i+1]*9 , printf("%d%d%d+",A[i],A[i+1],A[i+2]);
            for( ; i <= n ; i += 3 )
                if( ( tmp + A[i]*9 ) / tp[tt] )
                    break;
                else tmp += A[i] * 9 , printf("%d%d+%d+",A[i],A[i+1],A[i+2]);
            tmp += A[i] * 9;
            printf("%d%d+",A[i],A[i+1]);
            for( int j = i + 2 ; j < n ; ++ j ) printf("%d+",A[j]);
            printf("%d\n",A[n]);
            ni( ni( tmp ) );
        }
    }
}
```



