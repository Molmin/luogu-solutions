#### 默默悲哀一下：我的第一篇题解居然没过o(╥﹏╥)o
# 这是我的第二篇题解，也希望它能成为我的第一篇通过的题解。恳求!
这个题实际上很简单，先解释一下题干：
输入四个整数 p, e, i 和 d，求最小的x值，使它**大于d，且x%23==p%23&&x%28==e%28&&x%33==i%33**
### 个人感觉这个题是入门难度的
我看大家有用**中国剩余定理**的，不过我想用枚举，因为这个题枚举也能过。
## 强调：介于上一篇题解被认为算法重复，本题解将采用一种特殊的枚举方法，可以稍微降低一下时间复杂度
我们可以先将x的初值定义为i%33,每一次枚举x都增大33，这样便保证了**x%33==i%33**，之后，只要保证**x%23==p%23&&x%28==e%28&&x>d**，就可以求出结果了。x从每次增加1到每次增加33，**时间复杂度自然减少**了。
代码如下（AC）：
``` cpp
#include<cstdio>
using namespace std;
int p,e,i,d,k=1,x;
int main()
{
	for(;;)
	{
		scanf("%d%d%d%d",&p,&e,&i,&d);
		if(p==-1&&e==-1&&i==-1&&d==-1)
		{
			break;
		}
		i%=33;
		for(x=i;;x+=33)
		{
			if(x%28==e%28&&x%23==p%23&&x>d)
			{
				printf("Case %d: the next triple peak occurs in %d days.\n",k,x-d);
				k++;
				break;
			}
		}
	}
	return 0;
}
```
# 望通过