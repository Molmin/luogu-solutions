>[P3986 斐波那契数列](https://www.luogu.org/problem/P3986)
>
>[更好的阅读体验](https://blog.csdn.net/qq_44765711/article/details/102688064)  


### 题目描述

定义一个数列：$f(1)=a,f(2)=b,f(n\:(n>1)\:)=f(n-1)+f(n-2)$，其中$a,b$均为正整数，问有多少种$(a,b)$使得$K$出现在数列中且不是前两项. 输出需要$mod \:1e9+7$.

### 题目分析


我们由题目条件可以得到若干个等式

$$f_j+f_{j+1}=K(j>=0)$$

我们要求的就是使得上面这个等式被满足的$f_0,f_1$的数量，这是一个**计数问题**.

--------

**1.斐波那契数列**：

由斐波那契数列的矩阵形式我们可以知道，斐波那契数列的第$i$项可以如是表示

$$\begin{bmatrix}
f_n\ f_{n-1}\ 
\end{bmatrix}*\begin{bmatrix}
1 & 1\\ 
1 & 0
\end{bmatrix}=\begin{bmatrix}
f_{n+1}\ f_n\ 
\end{bmatrix}$$

也就是

$$\begin{bmatrix}
f_1\ f_{0}\ 
\end{bmatrix}*\begin{bmatrix}
1 & 1\\ 
1 & 0
\end{bmatrix}^{n-1}=\begin{bmatrix}
f_{n}\ f_{n-1}\ 
\end{bmatrix}$$

也就是说，**斐波那契数列的第$i$项只与第0项和第1项有关**，设$f_0=1,f_1=1$的斐波那契数列第$i$项为$f_i$，$f_0=a,f_1=b$的斐波那契数列第$i$项为$g_i$，那么我们可以得到

$$g_i=f_{i-2}*a+f_{i-1}*b$$

现在，问题就转化成了求满足不定方程$K=f_{i-2}*a+f_{i-1}*b$的方案数.

首先发现$f_{i-1},f_{i-2}$发现这个东西显然可以**枚举**，因为斐波那契数列小于等于$1e9$的项只有大约$40$项左右. 那么我们就枚举斐波那契数列的第$i(i<=40)$项，然后对于构成的不定方程分别求合法方案数即可.

------

**2.求不定方程的特殊解**：

要求不定方程的合法解，首先要求出不定方程的一组通解. 我们有一个结论：**斐波那契数列的任相邻两项都是互质的**（窝不会证）. 所以对于每一个不定方程$K=f_{i-2}*a+f_{i-1}*b$，都一定能求出特殊解$(a_1,b_1)$.

~~实际上就算不知道这个结论，在程序里多写一个特判同样没有问题.~~ 

不定方程的特殊解怎么求？当然是用拓展欧几里得.

设$A=f_{i-2},B=f_{i-1},X=a,Y=b$ ，我们要做的就是**先求出不定方程$1=AX+BY$的一组解$(X,Y)$，那么$a,b$的一组特殊解$(a_1,b_1)=(K*X,K*Y)$**

>关于不定方程的一组解：假设我们求出了不定方程$ax+by=gcd(a,b)$的一组解$(x_1,y_1)$，
>那么对于一个不定方程$ax+by=K,K|gcd(a,b)$，设$w=K/gcd(a,b)$，那么这个不定方程同样有一组解$(x_1*w,x_2*w)$

-------

**3.求不定方程通解&通解数量**：

求出了一组解之后，我们要做的就是求出通解的表示方式. 而要求这个表示方式，自然就要先求通解间隔.

由上面的分析，我们现在已经求出了不定方程$ax+by=k$的一组特殊解$(x_1,y_1)$. 设对于这个不定方程中的$x$，通解间隔为$p$，对于$y$的通解间隔为$q$，那么我们显然有

$$a(x_1+p)+b(y_1+q)=k$$

联立$ax_1+by_1=k$得

$$ap=-bq$$

也就是

$$p=-\frac{b}{a}*q$$

由于$p,q$都是整数，$gcd(a,b)=1$，所以对于$y$的最小通解间隔为$q=a$. 同理对于$x$的最小通解间隔为$p=b$. 也就是对于以上的不定方程，$(x_1+bn,y_1-an)$也是一组解（**简记为“一减一加”**）.

对应题目的不定方程，$(K*X+f_{n-2}*n,K*Y-f_{n-1}*n)$也是一组解. 而根据题目意思，对于一组可行解$(x,y)$，$x,y$都要大于0（题目要求的正整数的条件）. 我们只需要求出满足$(x,y)$大于0的解的数量即可.

----------

到这里整道题就做完了. 不要忘记取模.

另外，有没有可能出现同样的解$(a,b)$出现了两次的情况呢？答案是否定的，因为这需要

$$af_i+bf_{i-1}=af_j+bf_{j-1},i!=j$$

由于斐波那契数列任两项不相等，所以以上式子是不成立的.

### 程序实现

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const ll mod=1e9+7;
ll n,gcd,x,y,f[60],ans;
ll exgcd(ll a,ll b){
	if(!b){
		x=1,y=0;
		return a;
	}
	ll ret=exgcd(b,a%b);
	ll z=x;x=y;y=z-a/b*y;
	return ret;
}//求对于每个不定方程的特殊解
int main(){
	scanf("%lld",&n);
	f[0]=1,f[1]=1;
	for(int i=2;i<=50;i++){
		f[i]=f[i-1]+f[i-2];
	} //K不会超过斐波那契数列第40项
	for(int i=1;f[i]<n;i++){
		gcd=exgcd(f[i-1],f[i]);
		x*=n,y*=n;
		if(x<=0){
			ll dex=-x/f[i]+1;
			x+=dex*f[i],y-=dex*f[i-1];//(x,y)要一起进退
		}//如果x<=0,把它加到大于0为止
		if(y<=0){
			ll dex=-y/f[i-1]+1;
			y+=dex*f[i-1],x-=dex*f[i];
		}//同理
		if(x<=0||y<=0)continue;//如果处理之后仍然找不到解，说明无解
		ans+=(y%f[i-1]==0)?y/f[i-1]:y/f[i-1]+1;
		//加上最多能取的数量（减多少减到0，由于这边减，另外一边是加，所以另外一边不用管）
		ans%=mod;
		ans+=(x%f[i]==0)?x/f[i]-1:x/f[i];//注意判断整除的情况
		ans%=mod;
	}
	printf("%lld\n",ans);
	return 0;
} 
```

