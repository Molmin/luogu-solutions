题目简短，相信大家看懂了题目的意思了，那么我们切入正题。

## 思路分析
题目问我们有多少种 $a, b$ ，那么我们可以来枚举一下，发现一下它们中的规律。

$f(0)=a,f(1)=b,f(2)=a+b, f(3)=a+2b, f(4)=2a+3b……$

那么我们再整理一下这些数列的系数特点：

![](https://cdn.luogu.com.cn/upload/image_hosting/o6138862.png)

啊，这些系数不正好又能构成斐波那契数列吗？

那么我们就可以用两个数组， $dp1, dp2$ 来存储了。

找到系数特点，我们再来往后想。

设当 $f(j)$ 时 $dp1_j=n, dp2_j=m$ 。

我们假设当 $f(j)$ 等于 $k$ 时，那么我们可以发现我们可以写出如下式子：

$$
na+mb=k
$$

这个我们就更熟悉了，这个很明显能联想到裴蜀定理和扩展欧几里得。

所以我们再用扩展欧几里得分别求一下 $a, b$ 就大功告成啦。

综合一下我们的思路，就是：
1. 先求出系数，存储起来。
2. 运用扩展欧几里得，求出 $a, b$ ，然后判断两个解是否为正整数，然后更新计数器，如果不是正整数，那就啥也不干就可以啦。

那么根据上述内容我们就能写出代码了：
```cpp
#include <iostream>
#include <cmath>

using namespace std;
typedef long long ll;
ll dp[55];
const int M = 1e9 + 7;
void exgcd(ll a, ll b, ll &x, ll &y)
{
	if (b == 0)
	{
		x = 1;
		y = 0;
		return;
	}
	exgcd(b, a % b, x, y);
	ll tmp = x;
	x = y;
	y = tmp - a / b * y;
	return;
}
int main()
{
	ll n, k;
	cin >> k;
	n = 0;
	dp[1] = 1;
	dp[2] = 1;
	for (ll i = 3;; ++i, ++n)
	{
		dp[i] = dp[i - 1] + dp[i - 2];//为了节省空间，我将两个数组压为了一个数组，不过操作过程也是一样的。
		if (dp[i] > M)
		{
			break;
		}
	}
	ll cnt = 0;
	ll x, y;
	for (ll i = 2; i <= n; ++i)
	{
		ll a = dp[i - 1], b = dp[i];//根据表格可以得到，不过写两个数组是比较好想的，看个人喜好
		exgcd(a, b, x, y);
		x *= k;
		y *= k;
		x = (x % b + b) % b;//要转换成正整数
		if (x == 0)
		{
			x = b;//注意一定要为正整数，即便是0也不行，因为0不是正整数
		}
		y = (k - a * x) / b;
		if (y < 0)//如果另一个解不是正整数，那么我们就不能让计数器加一
		{
			continue;
		}
		cnt = (cnt + ceil(1.0 * y / a));//因为这里解的x,y只是系数为dp1[j],dp2[j]中的其中一个解，我们不能忘记其他的解
		cnt %= M;//别忘了取余
	}
	cout << cnt << endl;
	return 0;
}
```
这道题考查了大家对扩展欧几里得的灵活应用，希望大家看完题解后在纸上再次模拟一遍再写程序。

12月26日：抱歉各位，第一版发现一个问题，现在修复了，重新交了一遍，真是不好意思，下一次注意。