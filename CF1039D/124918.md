审核大大求过

考虑 $dp$ ，设 $dp_i$ 为从 $i$ 的子树里延伸到 $i$ 的最长的链的长度。

对于每个节点，记下子节点里 $dp$ 值的最大值和次大值，如果这两个值合并后 大于等于我们需要的长度 $k$ ，就将其合并，并将 $dp_i$ 清零（因为记录的是一端为 $i$ 的链的长度）可以证明这一定是最优的。

性感的证明：

发现如果在一个地方能够合并的一定会立刻合并，因此还保留在 $dp_i$ 里的一定是还不可以合并的，因此在第一个可以合并的点马上合并一定是最优的。

~~证明了和没证明一样~~

然后我们有两条路子：

1. 根号分治

首先把 $k \le \sqrt{n}$ 的直接 $O(n)$ 处理掉，发现之后 $k$ 大于 $\sqrt{n}$ 的部分答案都小于 $\sqrt{n}$， 因此通过二分找出答案相同的一段区间直接赋值，复杂度为 $O(n\sqrt{n}\log n)$

2. 整体二分

发现随着 $k$ 的增大答案减小，因此对于一个询问区间，先求出区间中点 $mid$ 的答案 $tot$ ，然后左半边的答案范围就在 $tot \sim n$ ，右半边的答案范围就在 $0 \sim tot$ ，当答案范围缩小到一个数后直接赋值即可。

但这玩意的复杂度好像是假的（我证不出来，如果有大佬证出来可以评论一下打脸我），因此复杂度正确的做法还是和前一种一样，先暴力算出 $k \le \sqrt{n}$ 的答案，然后在 $\sqrt{n}+1$ 到 $n$ 的部分整体二分，因为答案只有 $\sqrt{n}$ 个，分治树只有 $log n$ 层，所以复杂度还是 $O(n\sqrt{n}\log n)$ 。 ~~本质相同~~

大概就是这么多，算是很典的题了。