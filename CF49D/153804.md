天若有情天亦老，人生正道是题解。小学生又来发题解了！

题号：CF49D

难度：★

算法：暴力

这题是非常简单的，只需要把两个相邻的“1”或“0”给整成不一样就好了，通俗的说就是拆CP（偷笑.jpg）

听我这么说，可能99%的小伙伴都想到了模拟，这说明你们已经形成了对算法判断的惯性思维，这很好，能够很快的判断出算法，但在这道题，不需要。

这道题其实我们研究一下就可以发现，最终的串无非是两种，以n=6为例，最终的串要么是“010101”，要么是“101010”，因此我们只需要比对一下这两个串与原串有多少个不同，然后拆CP（注意，不需要手动拆，只要算出来，用公式拆就行了），最后输出这两个串与原串的不同个数中较小的一个就可以了。

说着是晦涩难懂，那么我们来看一下代码⑧：

```c
#include<bits/stdc++.h>

using namespace std;
int n,ans1,ans2;//ans1和ans2分别储存两个串与原串的不同个数
string st;
//看完了定义，你们一定好奇，这两个串在哪呢？不要心急，先往下看
int main()
{
	cin>>n>>st;
	for(int i=0; i<n; i++)
	{
		if(st[i]==i%2+48)ans1++;//我们可以看到，这两个串在某个位置上必然是一个串是'1'，另一个串是'0'，因此，我只需要判断原串在该位置上是1还是0，就可以算出来，假如说第一个位置是0，那就是与“1010101010...”的串有不一样，因此ans1++，反之则自然是与“010101010101...”的串不一样，所以ans2++
		else ans2++;
	}
	cout<<min(ans1,ans2);//输出较小的一个




    return 0;
}
```

温馨提示，代码千万条，AC第一条，若要抄代码，棕名两行泪

那么今天的题解就到这里了，喜欢的朋友们希望多点赞，评论，三连！有不懂的可以评论区提问嗷