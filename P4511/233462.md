### 问题转化

最直观的做法显然是维护每个时刻执行的任务的价值，可惜我不会。因此考虑转化维护的信息。

首先，我们考虑一个问题：

> 如果已知若干个任务必须完成，怎样判断是否无解？

显然，如果对于任意 $t$，必须在 $t$ 之前完成的任务个数 $\le t$ 即可。

因此我们可以用线段树在每个 $t$ 上维护 $t-[\text{必须在}t\text{之前完成的任务个数}]$。如果线段树的最小值非负，则目前决策是合法的。

那么，我们如果要在 $t$ 插入一个任务，就让 $[t,n]$ 区间 $-1$。

---

### 插入一个任务 $(t,p)$

#### 可以直接插入

当 $[t,n]$ 的最小值 $>0$ 的时候，这个任务是可以完成的，我们直接累加答案，然后在线段树上更改。

#### 不能直接插入

当 $[t,n]$ 的最小值 $=0$ 的时候（由于前面的决策必定都合法，因此不会 $<0$），我们考虑找出**可以替代的**价值最小的任务，并让这个任务被当前任务替代掉。当然，如果这个任务的价值比当前任务的大，那就不用替换了。

哪些任务是可以替代的呢？假设 $t_1$ 是 $[t,n]$ 中最小的 $=0$ 的值。那么，截止时间为 $t_2\le t_1$ 的任务都是可以被当前任务替换掉的。

所以我们再开一棵线段树，维护区间内价值最小的任务即可。

### 删除一个任务 $(t,p)$

#### 这个任务没被用到

那就直接删除完事。

#### 这个任务被用到了

首先在上文提到的两棵线段树中删除此任务。删除之后，我们可能需要在没有用到的任务中选出一个加入（容易证明必然只有一个）。

哪些任务是可以加入的呢？假设 $t_1$ 是第一棵线段树上 $[1,n]$ 中最大的 $=0$ 的位置（若没有则 $t_1=0$）。截止时间在 $[t_1+1,n]$ 中的没有用到的任务就是可以加入的，我们找到最大值加进来就可以了。

---

怎么维护没有用到的任务？再开第三棵线段树即可。

我们发现任务的截止时间可能是相同的，因此需要在线段树的叶子节点维护一个 `multiset`。

代码比较长，而且无甚要点，就不放了。