## 题意

$t$ 组数据，每组数据给定一个字符串，问你至少删去几个字母后可以使原字符串变成符合以下要求的字符串：设这个字符串为 $s$，字母个数为偶数 $n$，那么对于任意奇数 $i(1\le i\le n)$，有 $s_i=s_{i+1}$。 

## 思路

**贪心**最容易想到，也是本题最简单的思路。

怎么贪心呢？就是用一个数组 $nl$ 来统计当前字母出现的次数，每当发现有一个字母出现次数为两次时，这个字母就被保留下来，其他统计表里统计到的字母全部都应该删去，然后统计表清空，注意是清空！可以用 $ans$ 记录答案，初始为字符串的长度，每次统计表清空时 $ans-=2$，到最后 $ans$ 就是答案了。

我们来证明以下这种算法的正确性：假如有一个区间里，你没有让那两个字母配对，那么当你继续往下找时，你肯定会让另一个和这个区间内的一个原来是要被删去的字母进行配对，然而你也只能配成一对，不会让可以配成的对数增多，而且你还有可能破坏了后面所要配成的一对，因此反而可能减少对数的个数，因此原方法最优。

## 代码

接下来贴我的代码，很简单的一个贪心的实现。

```cpp
#include<bits/stdc++.h>
using namespace std;
int t;
int main(){
    cin>>t;
    while(t--){
        string s;
        cin>>s;
        int ans=s.size(),nl[30];
        //ans为答案，nl数组用来统计字母个数
        for(int i=0;i<30;i++)nl[i]=0;
        for(int i=0;i<s.size();i++){
            nl[s[i]-'a']++;
            if(nl[s[i]-'a']==2){
                ans-=2;
                for(int i=0;i<30;i++)nl[i]=0;
                //注意此处为清空整张统计表，而非清空这个字母在表里的个数
            }
        }
        cout<<ans<<endl;
    }
}
```
