# 动态规划
这道题还是简单的吧(连我都推出状态转移方程，~~龟速逃~~)
### 进入正题：
既然是DP题，自然少不了状态转移方程啦，那么怎样可以维护题目的限制呢？

首先，get到题面中树的高度只有三种(10,20,30)，那么可以用一维表示第i位的树高是多少(用0/1/2表示)，那么前一棵与后一棵高度怎么维护呢？

~~让我们充分发挥人类智慧~~…… 自然，前一棵树也可表示成一维：同理也用0/1/2表示，那下一棵咧？

别急，让我们把已经设好的方程写下来：f[i][0/1/2][0/1/2]:表示枚举到第i棵树，此时第i棵树高度为[0/1/2],上个树为[0/1/2];

那下一个状态为f[i+1][0/1/2][0/1/2],发现此状态的本树高就是上个状态的下棵树高。~~完结撒花~~

等等，那么他是个环怎么办？

我先开是从1跑到n+1，结果只有70分，发现最后统计答案时出现点瑕疵~~大怒~~

干脆从2跑到n，在从n转移到1(特殊搞) ~~过了~~

### 最后，放上(整齐优美)代码：
```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
#define N 200500
using namespace std;

int n;
int a[N][5];
int f[N][4][4];
int ans;

int main() {
	scanf("%d",&n);
	for(int i = 1;i <= n;i ++) 
		scanf("%d%d%d",&a[i][0],&a[i][1],&a[i][2]);
	for(int i = 2;i <= n;i ++) {
		f[i][0][1] = max(f[i - 1][2][0],f[i - 1][1][0]) + a[i][0];
		f[i][0][2] = max(f[i - 1][2][0],f[i - 1][1][0]) + a[i][0];
		f[i][1][2] = max(f[i][1][2],f[i - 1][2][1] + a[i][1]);
		f[i][1][0] = max(f[i][1][0],f[i - 1][0][1] + a[i][1]);
		f[i][2][0] = max(f[i - 1][0][2],f[i - 1][1][2]) + a[i][2];
		f[i][2][1] = max(f[i - 1][0][2],f[i - 1][1][2]) + a[i][2];
	}
	f[1][0][1] = max(f[n][2][0],f[n][1][0]) + a[1][0];
	f[1][0][2] = max(f[n][2][0],f[n][1][0]) + a[1][0];
	f[1][1][2] = max(f[1][1][2],f[n][2][1] + a[1][1]);
	f[1][1][0] = max(f[1][1][0],f[n][0][1] + a[1][1]);
	f[1][2][0] = max(f[n][0][2],f[n][1][2]) + a[1][2];
	f[1][2][1] = max(f[n][0][2],f[n][1][2]) + a[1][2];
	ans = max(ans,max(f[1][0][1],f[1][0][2]));
	ans = max(ans,max(f[1][1][2],f[1][1][0]));
	ans = max(ans,max(f[1][2][1],f[1][2][0]));
	cout << ans << endl;
}
```