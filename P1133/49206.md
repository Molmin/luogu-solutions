用四维数组储存

一维存第几个位置，二维存树的种类，三维存是向上趋势还是向下趋势（1表示向上，2表示向下），四维存第一棵树的种类

如果选第1种树，趋势肯定是向上的

如果选第2种树，要分情况讨论

如果选第3种树，趋势肯定是向下的

递推式（状态转移方程）：



```cpp
for(int i=2;i<=n;i++)
for(int j=1;j<=3;j++)
    {
        f[i][1][1][j]=max(f[i-1][2][0][j],f[i-1][3][0][j])+c[i][0];
        f[i][2][0][j]=f[i-1][1][1][j]+c[i][1];
        f[i][2][1][j]=f[i-1][3][0][j]+c[i][1];
        f[i][3][0][j]=max(f[i-1][2][1][j],f[i-1][1][1][j])+c[i][2];
    }
```
最后输出第n个位置（选1时第1棵树为2，第1棵树为2；选2时第1棵树为1，第1棵树为3；选3时第1棵树为1，第1棵树为2）中的最大值
```cpp
# include<iostream>
using namespace std;
int c[200001][3];
int n,maxn;
int ans[4];
int f[200001][4][2][4];
int main()
{
    cin>>n;
    for(int i=1;i<=n;i++)
      cin>>c[i][0]>>c[i][1]>>c[i][2];
    f[1][1][1][1]=c[1][0],f[1][2][0][2]=c[1][1],f[1][2][1][2]=c[1][1],f[1][3][0][3]=c[1][2];
    for(int i=2;i<=n;i++)
      for(int j=1;j<=3;j++)
        {
            f[i][1][1][j]=max(f[i-1][2][0][j],f[i-1][3][0][j])+c[i][0];
            f[i][2][0][j]=f[i-1][1][1][j]+c[i][1];
            f[i][2][1][j]=f[i-1][3][0][j]+c[i][1];
            f[i][3][0][j]=max(f[i-1][2][1][j],f[i-1][1][1][j])+c[i][2];
        }
    ans[1]=max(f[n][3][0][2],f[n][3][0][1]);
    ans[2]=max(f[n][2][0][1],f[n][2][1][3]);
    ans[3]=max(f[n][1][1][2],f[n][1][1][3]);
    cout<<max(ans[1],max(ans[2],ans[3]));
    return 0;
}

```