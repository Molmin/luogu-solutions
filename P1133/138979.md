**题目描述**

教主有着一个环形的花园，他想在花园周围均匀地种上$n$棵树，但是教主花园的土壤很特别，每个位置适合种的树都不一样，一些树可能会因为不适合这个位置的土壤而损失观赏价值。

教主最喜欢$3$种树，这$3$种树的高度分别为$10,20,30$。教主希望这一圈树种得有层次感，所以任何一个位置的树要比它相邻的两棵树的高度都高或者都低，并且在此条件下，教主想要你设计出一套方案，使得观赏价值之和最高。

**分析**

这道题是一个环形花园，麻烦就在这里，但我们可以分别考虑1号位置种树的情况，得出下面的动规参数：
```
用f[i,j,flag,firsttree]表示（从1号位置开始考虑），
i号位置种植j号树(j=0/1/2)，
两边相邻位置种植的树比它低（flag=0）或高（flag=1），
而位置1种了firsttree这种树时能够获得的最大观赏价值
```

**初始化**
```cpp
f[1][0][1][0]=a[1][0]; 
f[1][1][0][1]=a[1][1]; 
f[1][1][1][1]=a[1][1];
f[1][2][0][2]=a[1][2];
```

**转移方程**
```cpp
f[i][0][1][j]=max(f[i-1][1][0][j],f[i-1][2][0][j])+a[i][0];
//种第0种时要求两边高于它（f[i][0][1][j]），两边可以选择种1（f[i-1][1][0][j]）或2（f[i-1][2][0][j]）
f[i][1][0][j]=f[i-1][0][1][j]+a[i][1];
//种第1种时要求两边低于它（f[i][1][0][j]），两边只能选择0（f[i-1][0][1][j]）
f[i][1][1][j]=f[i-1][2][0][j]+a[i][1];
//种第1种时要求两边高于它（f[i][1][1][j]），两边只能选择2（f[i-1][2][0][j]）
f[i][2][0][j]=max(f[i-1][0][1][j],f[i-1][1][1][j])+a[i][2];
//种第2种时要求两边低于它（f[i][2][0][j]），两边可以选择种0（f[i-1][0][1][j]）或1（f[i-1][1][1][j]）
```

**答案**
```cpp
ans=max(f[n][0][1][1],f[n][0][1][2]);
//第n棵树种第0种要求两边高于他，第一棵树可选择1（f[n][0][1][1]）或2（f[n][0][1][2]）
ans=max(ans,max(f[n][1][1][2],f[n][1][0][0]));
//第n棵树种第1种要求两边高于他，第一棵树只能选择2（f[n][1][1][2]）
//第n棵树种第1种要求两边低于他，第一棵树只能选择0（f[n][1][0][0]）	
ans=max(ans,max(f[n][2][0][0],f[n][2][0][1]));
//第n棵树种第2种要求两边低于他，第一棵树可选择0（f[n][2][0][0]）或1（f[n][2][0][1]）
```

**完整代码**
```cpp
#include<iostream>
#include<cstdio>
using namespace std;
const int N=100001;
int n,a[N][3],f[N][3][2][3],ans;
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
		scanf("%d%d%d",&a[i][0],&a[i][1],&a[i][2]);
	f[1][0][1][0]=a[1][0]; 
	f[1][1][0][1]=a[1][1];
	f[1][1][1][1]=a[1][1];
	f[1][2][0][2]=a[1][2];
	for(int i=2;i<=n;i++)
		for(int j=0;j<=2;j++)
		{
			f[i][0][1][j]=max(f[i-1][1][0][j],f[i-1][2][0][j])+a[i][0];
			f[i][1][0][j]=f[i-1][0][1][j]+a[i][1];
			f[i][1][1][j]=f[i-1][2][0][j]+a[i][1];
			f[i][2][0][j]=max(f[i-1][0][1][j],f[i-1][1][1][j])+a[i][2];
		}
	ans=max(f[n][0][1][1],f[n][0][1][2]);
	ans=max(ans,max(f[n][1][1][2],f[n][1][0][0]));
	ans=max(ans,max(f[n][2][0][0],f[n][2][0][1]));
	printf("%d",ans);
	return 0;
}


```
```