~~调试了一下午QAQ 推荐一篇[思路相似(tong)的博客](https://www.luogu.org/blog/Roy/solution-p1133)~~

### ~~显然~~这是一道~~看似简单的~~DP题，审题是关键~~之一~~

- 教主希望这一圈树种得有层次感，所以任何一个位置的树要比它相邻的两棵树的高度**都高或者都低**

~~都高或都低啊，我一开始还以为是只要高或者低都行的QAQ~~

- 第i个位置的树与第i+1个位置的树相邻，**特别地，第1个位置的树与第n个位置的树相邻。**

相当于在一个环上种树，第1个和第n个树的高度也要和谐。

- 那么，怎么处理呢？

首先，肯定要用一个维度处理**当前是那棵树(i)**~~废话~~

还要用一个维度处理**当前树的高度(j)**(我用1代表10,2代表20，以此类推，开1~3就行了)

然后得用一个维度记录**当前的树是比两边的树高还是低(k)**(0和1就行了)

最后一个维度用来**记录第一棵树的高度(l)**（蒟蒻想不出更好的方法处理了QAQ， 个人感觉有些题解的三维DP正确性有点迷，因为DP到了n如果不特殊记录的话就不知道每个状态是从哪里转移来的了）

### DP方程

撇去处理第一颗树的l，三维的DP方程很好推
(f[i][j][k],k==0代表i树比左右两棵树低，k==1反之)

f[i][1][0]=max(f[i-1][2][1],f[i-1][3][1])+a[i];

//高度20、30的树都比高度为10的树高，该树只可能比左右的树都低，k==0。继承的同时加上i的美观值

f[i][2][0]=f[i-1][3][1]+b[i];

//只有高度30的树比20的高，此处k要标记为0，因为（这里假设）比两边都低，不可低于一边的同时高于另一边

f[i][2][1]=f[i-1][1][0]+b[i]

//高度为10的树低于高度的20树，此时**注意**k==1，比两边的树都高

f[i][3][1]=max(f[i-1][1][0],f[i-1][2][0])+c[i];

//只可能高于两边的树

l呢？~~不管？~~ 对，不到1或n真的不用管，直接丢在后面，不过要多一遍for(1~3)

### 特殊处理

- 1要特殊处理，l记录的是第一棵树唉，肯定要记录的辣

- n...... 之前闲置的 l ~~终于~~有用了，到了第n个点,**树与k、l都要和谐:要么比k、l都高，要么都低。**

### 细节

~~好像没什么细节~~ 我在代码里i、j、k、l的顺序有所变动，a、b、c数组被我合并成了a数组，a[1]=>a数组;a[2]=>b数组;a[3]=>c数组。

数据范围**不可能**爆出int，~~但是保险起见~~我还是加了long long

~~其他详见代码~~

### CODE:

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
typedef long long ll;
inline ll mymax(ll x,ll y){return x>y?x:y;}
int n;
ll a[4][110000];
ll f[4][4][2][110000];//f[i][j][k][l]:
/*i表示第一棵树是哪种高度的(要继承);j当前是哪种高度的;k比周围的高(0)还是低(1)
当前的树gao度是 /10/20/30 
比左右的树都低/高
*/

int main()
{
//	freopen("testdata (1).in","r",stdin);
//	freopen("my_opt.out","w",stdout);
	scanf("%d",&n);
	for(int i=1;i<=n;i++)for(int j=1;j<=3;j++)scanf("%lld",&a[j][i]);
	
	memset(f,0,sizeof(f));
	f[1][1][0][1]=a[1][1];//初始化 
	f[2][2][0][1]=a[2][1];
	f[2][2][1][1]=a[2][1];
	f[3][3][1][1]=a[3][1];
	
	for(int i=2;i<n;i++)
	{
		for(int j=1;j<=3;j++)
		{//除了以下四种状态以外，其他状态都是无意义的
			f[j][1][0][i]=mymax(f[j][2][1][i-1],f[j][3][1][i-1])+a[1][i];
			f[j][2][0][i]=f[j][3][1][i-1]+a[2][i];
			f[j][2][1][i]=f[j][1][0][i-1]+a[2][i];
			f[j][3][1][i]=mymax(f[j][1][0][i-1],f[j][2][0][i-1])+a[3][i];
		}
	}
	
	ll ans=0;
	for(int i=1;i<=3;i++)//实推式子原码 
		for(int k=1;k<=3;k++)
		{
			if(i>1 && k>1)f[i][1][0][n]=mymax(f[i][1][0][n],f[i][k][1][n-1]+a[1][n]);
			if(i>2 && k>2)f[i][2][0][n]=mymax(f[i][2][0][n],f[i][k][1][n-1]+a[2][n]);
			if(i<2 && k<2)f[i][2][1][n]=mymax(f[i][2][1][n],f[i][k][0][n-1]+a[2][n]);
			if(i<3 && k<3)f[i][3][1][n]=mymax(f[i][3][1][n],f[i][k][0][n-1]+a[3][n]);
		}
	for(int i=1;i<=3;i++)//暴力找最大值 
		for(int j=1;j<=3;j++)
			for(int k=0;k<=1;k++)
				ans=mymax(ans,f[i][j][k][n]);
	printf("%lld\n",ans);
	return 0;
}
```
