ε=(´ο｀*)))唉，这道题为什么弄成一个环啊？

链上的我会，这个换好难办啊！！

而且，这题偏偏是DP题。

要是深搜题的话，就可以在递归的时候多传一个参数，记下第一棵的高度，方便进行到第n位的时候进行比较啊！这DP的话可怎么知道之前的状态啊？？

哎！既然我深搜可以多传一个参数表示第一棵，那我DP为什么就不能多一个维度，表示第一棵树的高度呢。

上代码

```cpp
#include<cstdio>
using namespace std;
inline int read()
{
	int X=0,W=1;char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')W=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){X=(X<<1)+(X<<3)+ch-48;ch=getchar();}
	return X*W;
}
int max(int a,int b)
{
	return a>b?a:b;
}
int a[100001][3];
int dp[100001][3][3][2];
int main()
{
	int n=read();
	for(int i=1;i<=n;i++)a[i][0]=read(),a[i][1]=read(),a[i][2]=read();
	dp[1][0][0][0]=a[1][0];
	dp[1][1][1][1]=dp[1][1][1][0]=a[1][1];
	dp[1][2][2][1]=a[1][2];
	for(int i=2;i<=n;i++){
		for(int j=0;j<=2;j++){
			dp[i][j][2][1]=max(dp[i-1][j][1][0],dp[i-1][j][0][0])+a[i][2];
			dp[i][j][0][0]=max(dp[i-1][j][1][1],dp[i-1][j][2][1])+a[i][0];
			dp[i][j][1][1]=dp[i-1][j][0][0]+a[i][1];
			dp[i][j][1][0]=dp[i-1][j][2][1]+a[i][1];
		}
	}
	int ans=max(max(max(dp[n][0][1][1],dp[n][0][2][1]),max(dp[n][1][2][1],dp[n][1][0][0])),max(dp[n][2][0][0],dp[n][2][1][0]));
	printf("%d\n",ans);
	return 0;
}
```
虽然好理解了，但是代价却是常数扩大了3倍……

而且我们发现后两个维度中，有一些状态是永远不会有的，比如dp[i][j][0][1]。

因此，我们可以将后两个状态压缩，以达到省空间的目的……

ps：本题解仅提供一种思路，由于这种方法会使常数扩大，除非实在缕不清思路，否则尽量不要用。