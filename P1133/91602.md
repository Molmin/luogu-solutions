```cpp
/*
f[i][1][0]=max(f[i-1][2][1],f[i-1][3][1])+a[i][1];
f[i][2][0]=f[i-1][3][1]+a[i][2];
f[i][2][1]=f[i-1][1][0]+a[i][2];
f[i][3][1]=max(f[i-1][2][0],f[i-1][1][0])+a[i][3];
*/
//思考过程： 
/*先想到方程中应有位置i，再想到枚举树要种那颗，结合这两个状态信息
和题中的‘高矮高’、‘矮高矮’的要求，发现两维是不够的，还需 
一维来记录树的高矮：1代表本位置上的树比旁边两树高，0表示矮 ； 
发现，种树1没有1状态，3没有0状态，2全有； 
由于dp是递推关系，我们只用考虑当前位置的树与上一棵树的高矮关系； 
方程如上； 
又发现：此题为环，不分开情况考虑，会有后效性
所谓后效性，是指从1递推到n，发现n树和1树的高度关系不满足本题所述关系； 
解决方法：枚举第一个位置的状态（种树的情况），分别dp，取max（符合你枚举情况关系的max）； 
*/ 
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
int n;
int const MAXN=100000+10;
int f[MAXN][4][2];
int a[MAXN][4];
int main(){
    cin>>n;
    for(int i=1;i<=n;i++){
        scanf("%d%d%d",&a[i][1],&a[i][2],&a[i][3]);
    }
    int maxx=-1;
    for(int j=1;j<=4;j++){//枚举种树状态 
        memset(f,0,sizeof(f));
        if(j==1)f[1][1][0]=a[1][1];//种树1且比旁边两树矮（只能矮） 
        if(j==2)f[1][2][0]=a[1][2];//种树2且比旁边两树矮 
        if(j==3)f[1][3][1]=a[1][3];//种树3且比旁边两树高（只能高） 
        if(j==4)f[1][2][1]=a[1][2];//种树2且比旁边两树高 
        for(int i=2;i<=n;i++){
            f[i][1][0]=max(f[i-1][2][1],f[i-1][3][1])+a[i][1];
            f[i][2][0]=f[i-1][3][1]+a[i][2];
            f[i][2][1]=f[i-1][1][0]+a[i][2];
            f[i][3][1]=max(f[i-1][2][0],f[i-1][1][0])+a[i][3];
        }
        if(j==1)maxx=max(maxx,max(f[n][2][1],f[n][3][1]));
        if(j==2)maxx=max(maxx,f[n][3][1]);
        if(j==3)maxx=max(maxx,max(f[n][1][0],f[n][2][0]));
        if(j==4)maxx=max(maxx,f[n][1][0]);
    }
    cout<<maxx<<endl;
    return 0;
}
```