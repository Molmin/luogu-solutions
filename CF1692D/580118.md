相信前面几位大佬已经将题意和暴力枚举的方法解释的很清楚了。

本蒟蒻便来贡献一个更短的解法。

------------

首先，一天内的“回文时间”是有限的，只有16个。所以我们可以将这十六个时间转成分钟后保存起来，方便判断。

根据输入的 $h,m,x$ 来判断某个“回文时间” $p_i$ 是否满足条件，满足则答案$s$自增。

那么如何判断 $p_i$ 是否满足条件呢？明显，若 $p_i$ 满足条件：

$$
{\text{令} \hspace{1em} t = h*60+m}\\
{\text{则有} \hspace{1em} (nx+t) \bmod 1440 = p_i \hspace{1em} (n \in N^*)}\\
{\text{即} \hspace{1em}nx+t= p_i + m*1440 \hspace{1em} (n,m \in N^*)}\\
$$

若取 $x$,$y$ 为自变量，则

$$
{ax+t=1440y+p_i}\\
{1440y-ax=t-p_i}\\
$$

而一元二次方程 $ax+by=c$ 有解的条件是: $c \bmod gcd(a,b) = 0$ 。

所以若 $p_i$ 为条件 $h,m,x$ 下的“回文时间”，则
$$
{(h*60+m-p_i) \bmod gcd(1440,x) = 0}\\
$$

------------

AC代码如下：

```cpp
# include <bits/stdc++.h>

const int p[16] = {0, 70, 140, 210, 280, 350, 601, 671, 741, 811, 881, 951, 1202, 1272, 1342, 1412};

int main() {
    int _;
    scanf("%d", &_);
    while (_--) {
        int h, m, x, s = 0;
        scanf("%d:%d %d", &h, &m, &x);
        for (auto i: p) if (!((h * 60 + m - i) % (std::__gcd(1440, x)))) s++;
        printf("%d\n", s);
    }
    return 0;
}

```
