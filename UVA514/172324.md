好多代码和紫书上的有点眼熟啊......那我上一个比较精简的代码吧

这道题早上没事的时候在纸上推了推，发现模拟出入栈的顺序就可以了。


比如说现在有1-5号车要进栈，处理的策略是**逐辆车进栈**，然后定义一个变量（你可以理解为指针，指向out首元素）【ps：out是记录出栈顺序的数组】，看看当前指针指向的的值是否和栈顶值一致，**一致的话就栈顶元素出栈且指针下移**；不一致的话什么都不要做。

举个栗子：现在待进的是： 1 2 3 4 5 6

问出栈顺序为： 1 2 4 3 5 6  符不符合出入顺序？

过程：

**1） 1号车入栈，out【1】为1，可以出栈，指针下移**

**2） 2号车入栈，out【2】为2，可以出栈，指针下移**

**3） 3号车入栈，out【3】为4，暂时不可以出栈，指针值也不要动**

**4） 4号车入栈，out【3】为4，可以出栈，指针下移**

	    4号车出栈完毕后，out【4】为3，可以出栈，指针下移
    
**5） 5号车入栈，out【5】为5，可以出栈，指针下移**

**6） 6号车入栈，out【6】为6，可以出栈**

栈为空，火车全走了，所以ok，输出yes！



上代码理解一下：

```cpp
#include <iostream>
#include<stack>
using namespace std;
int main()
{
    int n;
    while(cin>>n&&n)
    {
        int out[n+1];			//定义出栈顺序数组
        while(1)
        {
            cin>>out[1];
            if(!out[1]) break;
            stack<int> v;
            for(int i=2;i<=n;i++)
                cin>>out[i];
            int pos=1;			//“指针”，指向出栈顺序数组首元素
            for(int i=1;i<=n;i++)//逐辆车进栈
            {
                v.push(i);		//不管怎样，先进站再说
                while(v.top()==out[pos]&&!v.empty()) //如果栈顶元素和当前指针值一致，持续出栈
                {
                    v.pop();	//逐辆车出栈
                    pos++;		//指针下移
                    if(v.empty())   break;//万一栈空了，那么回到循环条件判断的时候会内存段错误，所以这里需要加上一个小判断
                }
            }
            if(v.empty())   cout<<"Yes"<<endl;//全弹出去了，yes
            else            cout<<"No"<<endl;//还有火车没能出栈，no
        }
        cout<<endl;//注意换行
    }
    return 0;
}
```
