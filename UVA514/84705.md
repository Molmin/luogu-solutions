## [~~传送门~~](https://www.luogu.org/problem/UVA514)

### 题目大意：

意思很简单，就是说有一个｛1，2，3， ...，N｝的队列依次进栈，问出栈的顺序是否可能是题目给出的数列，如果是，输出$Yes$，如果不是，输出$No$.

### 分析&方法：

这是一道比较简单的模拟题。

通过题目，我们仔细看一看，就能分析出来：

- $A$：未入栈的数

- $Station$：如其名“站”——栈

- $B$：已出栈的数

众所周知，栈是后进先出的。

所以我们不难得出，对于第$i$个出栈的数$a_i$，我们必然有$1$~$a_i$已经进栈，且$a_i$处于当前的栈顶。那么我们就可以从$a_1$开始模拟，如果栈顶元素小于$a_i$，则将$a_i$之前的元素都压入栈，如果栈顶元素大于$a_i$则输出$No$，如果栈顶元素为$a_i$则直接出栈。

不难得出 效率为$O(NT)$（T为问题数）

上关于栈的$Byte$（实在不懂可以看注解）

```cpp
bool check()
{
	int z[N]/*栈*/,cnt=0/*栈的大小*/,k=1/*此时到了第k个数*/;
	for (int i=1;i<=n;i++)
	{
		if (i==a[k])//可以直接弹出的
		{
			k++;//直接跳过，不用进栈
			for (;z[cnt]==a[k]&&cnt&&k<=n;) cnt--,k++;//判断栈顶的每一个数能否出栈
		}
		else z[++cnt]=i;//否则就进栈
	}
	for (;z[cnt]==a[k]&&cnt&&k<=n;) cnt--,k++;//同样：判断栈顶的每一个数能否出栈
	if (k==n+1) return 1;//如果所有的数都搞定了，证明方案可行 
	else return 0;
}
```