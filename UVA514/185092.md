## 在做题之前，先得了解一下一种数据结构——栈
# 栈
### 栈的定义
栈(stack)是限定仅在表尾进行插入和删除操作的线性表
### 栈的逻辑结构
1. 栈：限定仅在表的一端进行插入和删除操作的线性表。
2. 允许插入和删除的一端称为栈顶，另一端称为栈底。
3. 空栈：不含任何数据元素的栈。
（a<sub>1</sub>,a<sub>2</sub>,……,a<sub>n</sub>)
## 栈的特点
1. 栈又称为后进先出(Last In First Out)的线性表,简称LIFO结构。
2. 首先它是一个线性表，即有前驱后继关系。
3. 特殊之处：插入和删除元素只能在栈顶进行，栈底是固定的，最先进栈的只能在栈底。
4. 插入操作：进栈。删除操作：出栈。
### 进栈出栈变化形式
最先进栈的元素，是不是只能最后出栈呢？

当然不是！

**栈对线性表插入和删除位置进行了限制，但并没有对进出时间进行限制**

有3个整型数字元素：1，2，3，依次进栈，列举所有可能的出栈次序
1. 1、2、3进，3、2、1出—>次序321。
2. 1进，1出，2进，2出，3进，3出—>次序123。
3. 1进，2进，2出，1出，3进，3出—>次序213。
4. 1进，1出，2进，3进，2出，3出—>次序132。
5. 1进，2进，2出，3出，3出，1出—>次序231。

思考讨论：“3 1 2”次序可能吗？

**3个元素就有5种变化形式，元素越多，变化将会更多，当然也会有不可能出现的次序，要注意！**

#### *栈的存储结构(了解即可)
顺序栈——栈的顺序存储结构

链栈：栈的链接存储结构
### *顺序栈和链栈的比较(了解即可)
**时间性能**：相同，都是常数时间O(1)。

**空间性能：**

顺序栈：有元素个数的限制和空间浪费的问题。

链栈：没有栈满的问题，只有当内存没有可用空间时才会出现栈满，但是每个元素都需要一个指针域，从而产生了结构性开销。

总之，当栈的使用过程中元素**个数变化**较大时，用链栈是适宜的，反之，应该采用顺序栈。
## 前缀表达式
前缀表达式又称波兰式，**前缀表达式的运算符位于操作数之前**
### 前缀表达式的计算机求值
从右至左扫描表达式，遇到数字时，将数字压入堆栈，遇到运算符时，弹出栈顶的两个数，用运算符对它们做相应的计算（栈顶元素op 次顶元素），并将结果入栈；重复上述过程直到表达式最左端，最后运算得出的值即为表达式的结果

例如:-×+ 3 4 5 6

1. 从右至左扫描，将6、5、4、3压入堆栈
2. 遇到+运算符，因此弹出3和4（3为栈顶元素，4为次顶元素，注意与后缀表达式做比较），计算出3+4的值，得7，再将7入栈
3. 接下来是×运算符，因此弹出7和5，计算出7×5=35，将35入栈
4. 最后是-运算符，计算出35-6的值，即29，由此得出最终结果
#### *中缀表达式转换为前缀表达式(了解即可)
**转换步骤如下**:
1. 初始化两个栈:运算符栈s1，储存中间结果的栈s2
2. 从右至左扫描中缀表达式
3. 遇到操作数时，将其压入s2
4. 遇到运算符时，比较其与s1栈顶运算符的优先级
- 如果s1为空，或栈顶运算符为右括号“)”，则直接将此运算符入栈
- 否则，若优先级比栈顶运算符的较高或相等，也将运算符压入s1
- 否则，将s1栈顶的运算符弹出并压入到s2中，再次转到(4-1)与s1中新的栈顶运算符相比较
5. 遇到括号时
- 如果是右括号“)”，则直接压入s1
- 如果是左括号“(”，则依次弹出S1栈顶的运算符，并压入S2，直到遇到右括号为止，此时将这一对括号丢弃
6. 重复步骤2至5，直到表达式的最左边
7. 将s1中剩余的运算符依次弹出并压入s2
8. 依次弹出s2中的元素并输出，结果即为中缀表达式对应的前缀表达式

例如:1+((2+3)×4)-5具体过程，如下表：
![*中缀表达式转换为前缀表达式(了解即可)](C:\Users\lenvoo\Desktop\wuwu)

结果为“-+ 1 ×+ 2 3 4 5”

### 后缀表达式
前后缀表达式又称逆波兰式，**后缀表达式的运算符位于操作数之后**

## 后缀表达式的计算机求值
与前缀表达式类似，只是顺序是从左至右：
从左至右扫描表达式，遇到数字时，将数字压入堆栈，遇到运算符时，弹出栈顶的两个数，用运算符对它们做相应的计算（次顶元素op 栈顶元素），并将结果入栈；重复上述过程直到表达式最右端，最后运算得出的值即为表达式的结果

例如:3 4 + 5 ×6 -

1. 从左至右扫描，将3和4压入堆栈；
2. 遇到+运算符，因此弹出4和3（4为栈顶元素，3为次顶元素，注意与前缀表达式做比较），计算出3+4的值，得7，再将7入栈；
3. 将5入栈；
4. 接下来是×运算符，因此弹出5和7，计算出7×5=35，将35入栈；
5. 将6入栈；
6. 最后是-运算符，计算出35-6的值，即29，由此得出最终结果。
#### *中缀表达式转换为后缀表达式(了解即可)
**转换步骤如下:**
1. 初始化两个栈：运算符栈s1和储存中间结果的栈s2；
2. 从左至右扫描中缀表达式；
3. 遇到操作数时，将其压s2；
4. 遇到运算符时，比较其与s1栈顶运算符的优先级：
- 如果s1为空，或栈顶运算符为左括号“(”，则直接将此运算符入栈；
- 否则，若优先级比栈顶运算符的高，也将运算符压入s1（注意转换为前缀表达式时是优先级较高或相同，而这里则不包括相同的情况）；
- 否则，将s1栈顶的运算符弹出并压入到s2中，再次转到(4-1)与s1中新的栈顶运算符相比较；
5. 遇到括号时：
- 如果是左括号“(”，则直接压入s1；
- 如果是右括号“)”，则依次弹出s1栈顶的运算符，并压入s2，直到遇到左括号为止，此时将这一对括号丢弃；
6. 重复步骤2至5，直到表达式的最右边；
7. 将s1中剩余的运算符依次弹出并压入s2；
8. 依次弹出s2中的元素并输出，结果的逆序即为中缀表达式对应的后缀表达式（转换为前缀表达式时不用逆序）

例如，将中缀表达式“1+((2+3)×4)-5”转换为后缀表达式的过程如下：
![*中缀表达式转换为后缀表达式(了解即可)](C:\Users\lenvoo\Desktop\kuku)

栈了解完了，就可以愉快的写代码啦！
```cpp
#include<bits/stdc++.h>
using namespace std;
int n;bool ans=true;
stack<int>s;
int main(){
	scanf("%d",&n);
	for(int i=1,cur=1,a;i<=n&&ans;i++){
		scanf("%d",&a);
		for(;cur<=a;s.push(cur++));
		if(s.top()!=a)ans=0;s.pop();
	}
	printf(ans?"Yes\n":"No\n");
	return 0;
}
```
这是测试单独的一组数据的代码

AC源代码因为**篇幅问题**，这里我就不发了，敬请谅解！

# 最后，祝大家AC！