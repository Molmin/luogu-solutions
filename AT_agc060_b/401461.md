# [AGC060B] Unique XOR Path题解

## 题意

- 给定一个 $N\times M$ 的方格地图，并且给定一条路径从左上到右下的路径 $S$。
- 要求在地图上填任意数量的，在 $[0,2^k-1]$ 之间的数字，使得有且仅有 $S$ 一条路径经过的方格的数字的异或和为 $0$。
- 问是否有合法方案。

## 做法

我们考虑求出数字最大值的最小的方案，并且将这个最大值与 $k$ 比较。如果比 $k$ 大，那么无解，输出`No`，否则输出`Yes`。

考虑使其它路径上的异或和全不为 $0$。

我们发现题目中选数的范围是 $[0,2^k-1]$，又因为异或和，显然出题人是想让我们从二进制考虑（~~废话~~）。

要使得某一条路径上的异或和不为 $0$ 只要让这条路径经过的点上有至少一个位置的 $1$ 只会被访问一次。

因此，我们认为在路径上填的数应该是 $2^i(0\le i< l)$，$l$ 表示使数字最大值的最小值小于等于 $2^l$ 的最小的 $l$。

我们要考虑求出 $l$，然后判断 $l$ 和 $k$ 的大小关系即可。

容易发现，问题容易出现在拐角处。我们只要考虑再拐角处放置数字即可。

让我们来看一张图。

![例子](https://cdn.luogu.com.cn/upload/image_hosting/m0uwivns.png)

在这里，红色是 $S$，绿色和粉色是另外两条路径。我们要想办法拦截掉这两条路径。

要拦截粉色的，显然，在 $(2,2)$ 放一个 $1$ 即可。然鹅绿色路径会绕开这个“路障”。我们就在 $(3,1)$ 放一个和  $(2,2)$ 一样的 $1$。然后我们就往左下一直放，一直放，一直放到地图边界，全放一样的 $1$。这是向下的转弯。向右的转弯在右上放即可。

但是这样会错。

我们发现，如果有两个连续的转弯，可以放同一个数。就省了不少。

那三个转弯呢？四个呢？五个呢？

我们手动模拟，发现，对于连续的转弯，设数量为 $a$，那么他会使 $l$ 加上 $\lceil \frac a2\rceil$。

对于单个的转弯，因为 $\lceil \frac12\rceil=1$，所以显然。

## $\text{Code}$

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,k;
char s[100];
int tot=0,ans=0;
void real_main(){
	scanf("%d%d%d",&n,&m,&k);
	scanf("%s",s);
	tot=ans=0;
	for(int i=1;i<n+m-2;i++){
		if(s[i]!=s[i-1])++tot;
		else{
			ans+=(tot+1)/2;
			tot=0;
		}
	}
	ans+=(tot+1)/2;
	if(ans<=k)puts("Yes");
	else puts("No");
}
int main(){
	int T;
	scanf("%d",&T);
	while(T--){
		real_main();
	}
	return 0;
}
```