这是一道字符串模拟题。

首先，我们需要理解字典序是什么？

>设想一本英语字典里的单词，何者在前何者在后？

>显然的做法是先按照第一个字母、以 a、b、c……z 的顺序排列；如果第一个字母一样，那么比较第二个、第三个乃至后面的字母。如果比到最后两个单词不一样长，那么把短者排在前。

字典序，是用于比较字符串"大小"的方法，它类似我们平常使用的字典：从第一个字母开始一个一个比较。A在B前，X在Y前；如果第一个字母相同，则比较第二个……以此类推。

本题只需要考虑一种简单的情况：对于长度为L的字符串S1和S2，先比较S1(0)和S2(0)的编码(例如ASCII或UNICODE等，此处比较的是ASCII编码)，若相等则比较S1(1)和S2(1)，若依旧相等则比较S1(2)和S2(2)……，以此类推。如果S1(0..L-1)和S2(0..L-1)均相等，则S1=S2；如果如果S1(0..D-1)和S2(0..D-1)均相等但是S1(D)和S2(D)不等(0<=D<=L-1)，那么对应位置编码较小的字符串的字典序小。

注意：一旦发现第一个不等的S1(D)和S2(D)，字典序就已经唯一确定，比较过程旋即终止，也就是说"AC"的字典必定大于"WA"的字典序。不严格地说，对于等长字符串，越靠前的字符，决定字典序的权重越高。

对于本题需要从后往前遍历字符串，处理两种情况:

1. 读取到字符'z'，此时需要将此位设为'a'，这是因为在26个英文字母中'z'没有后继字符，考虑字典序的比较方法，为了使字符串尽可能小，将此位置为'a'。

2. 如果发现非'z'的字符，则将该字符设为其后继字符，设置"找到"标志并退出循环，此时已经找到了第一个比第一个字符串大的字串。

循环结束后，如果"找到"标志没有被设置或者第一个比第一个字符串大的字串已经大于第二个字符串，这说明没有找到，否则已找到并输出。

代码:
```
#include <iostream>
#include <string>
using namespace std;
int main(){
	ios::sync_with_stdio(false); //输入输出加速
	string sInputMin, sInputMax; //输入的两个字符串，类似上下界
	int iLength; //长度
	register int i; //循环计数器
	bool IsFound = false; //"找到"标志，默认未找到
	cin >> sInputMin >> sInputMax; //读入
	iLength = sInputMin.length(); //保存长度
	for (i = iLength - 1; i >= 0; --i){ //倒序遍历下界字符串
		if (sInputMin[i] != 'z'){ //如果发现非'z'的字符，则将该字符设为其后继字符，设置"找到"标志并退出循环，此时已经找到了第一个比第一个字符串大的字串。
			IsFound = true; //设置"找到"标志
			++sInputMin[i]; //该字符设为其后继字符
			break; //退出循环
		}
		else{ //读取到字符'z'，此时需要将此位设为'a'，这是因为在26个英文字母中'z'没有后继字符，考虑字典序的比较方法，为了使字符串尽可能小，将此位置为'a'。
			sInputMin[i] = 'a'; //对应位置设为'a'
		}
	}
	if (!IsFound || sInputMax <= sInputMin) //如果"找到"标志没有被设置或者第一个比第一个字符串大的字串已经大于第二个字符串，这说明没有找到
		cout << "No such string"; //提示未找到
	else //否则
		cout << sInputMin; //输出
	return 0; //结束
}
```