## 构造数+判断几重

### 1.判断几重

用$yes[k]$表示十进制为k的数再规定进制内波浪的重数

### 2.构造

依据波浪数的定义,所以我们可以枚举那两个交替转换的数(如$121212$中的$12$),然后就循环构造,每次循环再转换为十进制,假设为$m$,则$yes[m]++$,而且我们发现如果那个数为$12$那么它的长度一定为偶数,但是为奇数时也可以,所以每循环构造一次时去掉第一位所生成的数也为这次循环所构造的数(如$1212$时,$212$也是它构造出来的波浪数)

转化十进制

1.$k$进制的第$i$位的数$j$转化为十进制所表示的数就是$j*k^{i-1}$
,如三进制的121212的第3位转化为十进制就是$2*3^{3-1}$,即18

2.整个k进制数转化为十进制就是把每一位转化的数加起来

### 3.判断输出

循环从范围开始到范围结束如果重数是题目要求的就输出

注意转化位其他进制是波浪数的十进制数不一定是波浪数(如题目中的300)

主要还是放在代码里讲

```cpp
#include<bits/stdc++.h>
using namespace std;
#define j1 jjj//j1是关键字
int j1,j2,st,ed,num;//前两个数表示进制的范围，第三与第四个数表示指定的范围，第五个数表示要找的波浪数的重数
int yes[10000001];//上面讲了
bool b[10000001]; //这是为了防止同一进制构造的数重复
int main()
{
	cin>>j1>>j2>>st>>ed>>num;//输入
	for(int p=j1;p<=j2;p++)
	{
		memset(b,0,sizeof(b));//不同的进制可以构造不同的数
		for(int i=0;i<=p-1;i++)//枚举第一个数
		{
			for(int j=0;j<=p-1;j++)//枚举第二个数
			{
				if(i==j) continue;//两数不能相等
				int tot=0;//记录构造出的数转化为十进制表示的数
				for(int l=1;l<=10;l++)
				{
					if(tot+j*pow(p,2*l-2)<=ed/*要小于范围最大值*/&&l>1) //去掉,注意去掉时,不需要更新tot的值,因为构造好只有一个数去掉就不能再构造了(如121212去掉1为21212,是波浪数,但对于12它不能继续构造了),所以不需要记录(记录是为了下一次构造直接加上新增加的两个数构成新构造的数所对应的十进制数,如121212,只要讲第5,6位的1,2转化位十进制再加上前面表示1212对应的十进制的tot就表示了121212对应的十进制),第一次循环时不能去第一位,因为一个数不是波浪数
					{
					if(!b[tot+(int)(j*pow(p,2*l-2))]) yes[tot+int(j*pow(p,2*l-2))]++;//如果没有重复,对应的十进制波浪重数加1
					b[tot+(int)(j*pow(p,2*l-2))]=1;//构造过了,记录,防止重复
				    }
					if(tot+i*pow(p,2*l-1)+j*pow(p,2*l-2)<=ed)//两个数都加上去,且要小于范围最大值
					{
					 tot+=i*pow(p,2*l-1)+j*pow(p,2*l-2);//tot的用处上面有讲
					 if(!b[tot])yes[tot]++;//没有重复,对应十进制波浪的重数+1
					 b[tot]=1;//记录
				    }
					else break;//大于范围,结束
				}
			}
		}
	}
	for(int p=st;p<=ed;p++) if(yes[p]==num) cout<<p<<endl;//找到合适的输出
		return 0;
}
```
