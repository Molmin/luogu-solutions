upd：补充了 `-` 不连续的情况。

_______

> 给你一个字符串 $s$，你可以将连续的两个 `-` 合并成一个 `+`，求多少子串在合并若干次后，可以使得 `+` 与 `-` 的个数相同。

设在一个子串中 `+` 的个数为 $A$，`-` 的个数为 $B$，进行 $t$ 次合并后 `+` 和 `-` 的个数相同。那么显然 $t$ 次合并后 `+` 的个数为 $A + t$，`-` 的个数为 $B - 2t$，所以 

$$ A + t = B - 2t $$

移项可得

$$ B - A = 3t $$

因为 $t \ge 0$，所以 $3t \ge 0$，所以 $B - A \ge 0$。

也就是说，在一个子串中，当 `-` 的个数减去 `+` 的次数是 $3$ 的倍数，且是非负数，那么就说明这个子串是可行的，所以直接枚举一下就做完了。

对于「`-` 不连续」情况的说明：如果 `-` 的个数减去 `+` 的次数是 $3$ 的倍数，而且没有连续的 `-`，不难发现他一定是 `+-+-+-...` 这样的，此时不难发现 `-` 和 `+` 的个数仍是相同的。

```cpp
void solve() {
  string s;
  int ans = 0;
  iocin >> s >> s;
  // cout << s << ' ';
  rep (i, 0, s.size() - 1) {
    int curr = 0;
    rep (j, i, s.size() - 1) {
      curr += (s[j] == '-' ? 1 : -1);
      if (curr >= 0 && curr % 3 == 0) {
        ++ans;
      }
    }
  }

  cout << ans << endl;
}
```