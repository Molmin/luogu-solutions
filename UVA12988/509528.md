# UVA12988 Sudoku   Solution

[题目](https://www.luogu.com.cn/problem/UVA12988)

一道很好的搜索题，和[P1784 数独](https://www.luogu.com.cn/problem/P1784)很相似，建议大家去看一看。

## 1.题目

题目大意：给你多组数据，每组数据包含一个 $4*4$ 数独，让你输出数独的解。

## 2.思路

看到题目，第一思路是爆搜，对于这道题来说，爆搜是可以过的，所以考虑dfs。

## 3.dfs是什么

dfs的定义如下：

深度优先搜索（depth-first-search）简称 dfs，应该算是应用得最广泛的搜索算法，也是竞赛中经常考察的一个难点。dfs 按照深度优先的方式搜索，通俗的说就是一条路走到黑。dfs 是一种穷举的手段，实际上就是把所有的可行方案列举出来，不断去试探，直到找到问题的解，其过程是对每一个可能的分支路径深入到不能再深入为止，而且每个节点只能访问一次。

首先把dfs模板给大家：

```cpp
inline void dfs(int x,int y)
{
   if(x==4&&y==4) return;
   for(j=1;j<=4;j++)
   {
      if(/*符合数独的条件*/)
      {
        //标记行列，以及格子
        if(y==4) dfs(x+1,y);
        else dfs(x,y+1);//进入下一层递归
        //取消标记
      }
   }
}
```

有了思路和模板，该怎么用呢？

## 4.方法

### 4.1 规律

在上图的模板中，有“符合数独的条件”和“标记行列，以及格子”这两个注释，那么，该如何判断和标记呢？

#### 4.1.1 行

用 $a[x][y]$ 表示第 $x$ 行为 $y$ 的数是否被占领。如为 $1$ ，则被占领，否则没有。

#### 4.1.2 列

思路同行。

#### 4.1.3 格子

这个可能就有点复杂了，我们举几个例子，找找规律。

##### 1

行为 $3$ ，列为 $4$ ，应在第 $4$ 个格子里。

##### 2

行为 $2$ ，列为 $1$ ，应在第 $1$ 个格子里。

##### 3

行为 $4$ ，列为 $2$ ，应在第 $3$ 个格子里。

通过这三个样例，逻辑好的同学们应该发现了，规律是： $(x-1)/2*2+(y-1)/2+1$ 。

### 4.2 dfs

有了规律，就可以开心的dfs了！

首先，有的格子是有点值的。遇到这些点，该怎么办？

答：直接进入下一层递归，无需再考虑。

这个Part的代码：

```cpp
if(a[x][y]!=0)//有点值
{
	if(x==4&&y==4) //判断是否dfs满了
	{
		print();
		return;
	}
	else
	{
		if(y==4) dfs(x+1,1);//判断是否行列达到了极限
		else dfs(x,y+1);
	}
}
```

其次，有的点没有点值，对于这些点，我们就枚举每一种这个点可能出现的状态，分别进行dfs。

这个Part的代码：

```cpp
for(int i=1;i<=4;i++)
{
	if(line[x][i]==1&&col[y][i]==1&&grid[(x-1)/2*2+(y-1)/2+1][i]==1)//若没被占领
	{
		line[x][i]=0;//进行标记
		col[y][i]=0;
		grid[(x-1)/2*2+(y-1)/2+1][i]=0;
		a[x][y]=i;
		if(x==4&&y==4)//判断是否dfs满了
		{
			print();
			return;
		}
		if(y==4) dfs(x+1,1);//判断是否行列达到了极限
		else dfs(x,y+1);//取消标记
		line[x][i]=1;
		col[y][i]=1;
		grid[(x-1)/2*2+(y-1)/2+1][i]=1;
		a[x][y]=0;
	}
}
```

最后，给大家附上print函数的代码：

```cpp
inline void print()
{
	cout<<"Case #"<<++k<<":\n";
	for(int i=1;i<=4;i++)
	{
		for(int j=1;j<=4;j++)
			cout<<a[i][j];	
		cout<<"\n";	
	}
	return;
}
```

主函数我就不给出了，大家可以自行补充完整。