# DP  
首先设定**状态**。有**两个矿井**，生产煤数与最近吃的**食物品种**有关。  
  
数组也一定是要**滚动**的，此题空间只有$17.58MB$

我们就设$f[i][a][b][c][d]$为第$i$辆车时，**第一个**矿井送了$a$、$b$两种食物。**第二个**矿井送了$c$、$d$两种食物。  
  
现在就有**两种情况**，一是送到$1$号矿井，二是送到$2$号矿井。  
  
### 可以据此列出方程：

$f$[$i$&$1$][$a$][$b$][$d$][$x$]=$max$(f[($i+1$)&1][$a$][$b$][$c$][$d$]+$Mining$($c$,$d$,$x$),$f$[$i$&$1$][$a$][$b$][$d$][$x$])

$f$[$i$&$1$][$b$][$x$][$c$][$d$]=$max$($f$[($i$+$1$)&$1$][$a$][$b$][$c$][$d$]+$Mining$($a$,$b$,$x$),$f$[$i$&$1$][$b$][$x$][$c$][$d$]);  

解释一下，$Mining$是求煤数的函数，$i$&$1$是**滚动数组**（$i$&$1$等效于$i$%$1$）

### $Mining$里该写什么，怎么求煤数？  
## $3$种**普通情况**    

1. 几次食品车**都是同一类型**的食品，产**一个**单位煤。  

2. 几次食品车中有**两种不同类型**的食品，产出**两个单位**的煤。  

3. 几次食品车中有**三种不同类型**的食品，产出**三个单位**的煤。   

**伪代码**：  
```
int Mining(int q,int w,int e){
	if(q==w && w==e){//第一种情况
		return 1;
	}
	if(q!=w && w!=e && q!=e){//第三种情况
		return 3;
	}
	return 2;//第二种情况	
}
``` 

## $2$种**特殊情况**  

当是**第一次送餐**时，先前的情况**无法判断**。但是是$1$个单位的煤  

因为有**两个**矿井，当**前一次餐车送的不是自己所处的矿井**，也要**特判**。  
如果有两种则产$2$个单位煤，如果有一种则产$1$个单位煤。  
  
**判断**代码：  
```
if(q==0 && w==0){//第一次送餐
	return 1;
}

if(q==0){//前面一次没送到
	if(w!=e){
		return 2;
	}
	else{
		return 1;
	}
}
```  

就没了。**总代码**：  
```
#include <bits/stdc++.h>
using namespace std;
long long n,f[3][4][4][4][4],ans=-1,x; 
string s;
int change(char op){//转成数字方便操作 
	if(op=='M'){
		return 1;
	}
	if(op=='F'){
		return 2;
	}
	if(op=='B'){
		return 3;
	}
}
int Mining(int q,int w,int e){
	if(q==0 && w==0){//第一次送餐
		return 1;
	}
	if(q==0){//前面一次没送到
		if(w!=e){//2种食物 
			return 2;
		}
		else{//1种食物 
			return 1;
		}
	}
	
	if(q==w && w==e){//第一种情况
		return 1;
	}
	if(q!=w && w!=e && q!=e){//第三种情况
		return 3;
	}
	return 2;//第二种情况
}
int main(){
	cin>>n>>s;
	//不要忘了初始化 
	memset(f,-1,sizeof(f));
	f[0][0][0][0][0]=0;
	for(int i=1; i<=n; i++){
		x=change(s[i-1]);
		//0是有不送这个矿井的情况 
		for(int a=0; a<=3; a++){
			for(int b=0; b<=3; b++){
				for(int c=0; c<=3; c++){				
					for(int d=0; d<=3; d++){
						if(f[(i+1)&1][a][b][c][d]==-1){
							continue;
						}
						f[i&1][a][b][d][x]=max(f[(i+1)&1][a][b][c][d]+Mining(c,d,x),f[i&1][a][b][d][x]);
						f[i&1][b][x][c][d]=max(f[(i+1)&1][a][b][c][d]+Mining(a,b,x),f[i&1][b][x][c][d]);			
					}
				}
			}
		}
	}
	
	for(int a=0; a<=3; a++){
		for(int b=0; b<=3; b++){
			for(int c=0; c<=3; c++){				
				for(int d=0; d<=3; d++){
					ans=max(ans,f[n&1][a][b][c][d]);
				}
			}
		}
	}
	cout<<ans;
	return 0;
}
```
