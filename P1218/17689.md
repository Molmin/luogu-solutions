直接枚举法

预处理求出长度1~8所有符合条件的质数,方法很简单,而且效率极高. N=1的时候,只有2,3,5,7，N>1的时候,每一位只能是1,3,7,9.所以先求出N=1的素数,再用N=1的素数加上1,3,7,9，符合条件的数形成N=2的素数.再用N=2的用同样办法求出N=3的,以此类推. 动态规划法

设primes[i][\*]保存位长为i的所有质数，size[i]表示位长为i的质数的个数。那么我们可以根据primes[i][\*]的内容很快求出primes[i+1][\*]的内容。

对所有的primes[i][j],因为个位上只可能是tail[4]={1,3,7，9}，对k=0 to 3,所以检查primes[i][j]\*10+tail[k]是否是质数，若是，保存在primes[i][size[i]++]中；伪代码如下：

[/color][codep ]

```cpp
for i 1 to n-1
  for j 0 to size[i-1]-1
      for k 0 to 3
          if(isPrime(primes[i-1][j]*10+tail[k])) 
              primes[i][size[i]++]=primes[i-1][j]*10+tail[k];
```
[/codep ]
当然，可以打表，程序如下。

[/color][codec ]

```cpp
#include <iostream>
using namespace std;
const char lut[9][200]=
{
```
"",
"2\n3\n5\n7\n",

"23\n29\n31\n37\n53\n59\n71\n73\n79\n",

"233\n239\n293\n311\n313\n317\n373\n379\n593\n599\n719\n733\n739\n797\n",

"2333\n2339\n2393\n2399\n2939\n3119\n3137\n3733\n3739\n3793\n3797\n5939\n7193\n7331\n7333\n7393\n",

"23333\n23339\n23399\n23993\n29399\n31193\n31379\n37337\n37339\n37397\n59393\n59399\n71933\n73331\n73939\n",

"233993\n239933\n293999\n373379\n373393\n593933\n593993\n719333\n739391\n739393\n739397\n739399\n",

"2339933\n2399333\n2939999\n3733799\n5939333\n7393913\n7393931\n7393933\n",

"23399339\n29399999\n37337999\n59393339\n73939133\n"

};
int n;
int main(){cin>>n;cout<<lut[n];return 0;};

[/codec ]
