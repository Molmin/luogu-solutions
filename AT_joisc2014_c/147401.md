嗯。。很明显的一道莫队题

当然我们会发现，对于这道题，添加元素很容易维护，但是删除的话。。。

所以我们需要一种可以更加强大的数据结构（算是吧） 

# 回滚莫队

首先我们按照块长为  $ \sqrt n$ 排序（但是要去掉奇偶优化）

这是我们就会惊奇的发现，你的询问的左端点所在的块的编号是单调递增的。 而对于左端点属于同一个块的询问，它们的右端点的编号也是单调递增的。

所以我们可以考虑将询问分成两大类

### 左端点和右端点位于同一块内

这个直接暴力解决就可以，因为一块最大 $ \sqrt n$ ，即使全部暴力时间复杂度也只是 $ O(n\sqrt n)$

暴力部分代码

```cpp
int force(int l,int r)
  {
      int res=0;
      int tcnt[N];
      for(int i=l;i<=r;i++) tcnt[typ[i]]=0;
      for(int i=l;i<=r;i++)
        {
            tcnt[typ[i]]++;
            res=max(tcnt[typ[i]]*a[i],res);
        }
      return res;
  }
```

### 左端点和右端点不位于同一块内

这个就有点麻烦了，考虑将区间分为两个部分，左块内和左块外。

对于左块内的部分：

每次询问前将操作指针 $ql$ 移至左端点所在块的下一个块的第一个元素处，然后我们就会惊奇的发现： 我们可以在左区间一直加元素而不必删除元素了（每次回复 $ql$ 的时候只需要保存一下就行了）

对于左块外的部分：

由于对于左端点属于同一个块的询问，它们的右端点是单调递增的。 所以我们只需要每次询问的左端点处于一个“新块” 的时候，将操作指针 $qr$ 移至左端点所在的块的最后一个元素。然后我们同样惊奇的发现，对于在左端点在同一个块内的所有操作，我们的 $qr$ 根本不需要往回走，也就是不需要删除


非暴力部分代码
```cpp
for(int k=1;k<=t;k++)//k代表左端点块的编号
    {
     l=br[k]+1,r=br[k];
     memset(cnt,0,sizeof(cnt));
     res=0;
     for(;belong[q[i].l]==k;i++)
       {
           if(belong[q[i].l]==belong[q[i].r])
             {
                 ans[q[i].id]=force(q[i].l,q[i].r);
                 continue;
             }
            while(r<q[i].r)
              {
                  r++;
                  cnt[typ[r]]++;
                  res=max(res,cnt[typ[r]]*a[r]);
              }
            int nowres=res;//每次对左块操作前先保存
            while(l>q[i].l)
              {
                 l--;
                 cnt[typ[l]]++;
                 res=max(res,cnt[typ[l]]*a[l]);
              }
            ans[q[i].id]=res;
            while(l<br[k]+1)
              {
                  cnt[typ[l]]--;
                  l++;
              }
            res=nowres;
       }
    }
```

时间复杂度为$ O(n\sqrt n)$

对了本题数据较大记得离散化
