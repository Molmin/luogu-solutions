## [SP7579 YOKOF - Power Calculus](https://www.luogu.org/problem/SP7579)

## 迭代加深搜索

- DFS每次选定一个分支，不断深入，直至到达递归边界才回溯。这种策略带有一定的缺陷。试想以下情况：**搜索树每个节点的分支数目非常多，并且问题的答案在某个较浅的节点上。如果深搜在一开始选错了分支，就很可能在不包含答案的深层子树上浪费许多时间**

- 此时，我们可以**从小到大限制搜索的深度**，如果在当前深度限制下搜不到答案，就把深度限制增加，重新进行一次搜索，这就是迭代加深思想。

- 虽然该过程在深度限制为d时，会重复搜索第1~d-1层的节点，但是当搜索树节点分支数目较多时，随着层数的深入，每层节点数会呈指数级增长（这样时间主要取决于最后一次搜索的时间），这点重复搜素与深层子树的规模相比，实在是小巫见大巫了。

- 总而言之，**当搜索树规模随着层次的深入增长很快，并且我们能够确保答案在一个较浅层的节点时**，就可以采用迭代加深的深度优先搜索算法来解决问题。

## 分析

显然有解，连续乘n次x总是能得到x^n的，只是可能不是最优解。

操作次数最小时有搜索深度最小，而理论上搜索深度可以是无穷的，这种情况下就可以使用迭代加深了。

（以上by Chelly）

```cpp
#include<cstdio>
using namespace std;
int n,ans,a[15];
inline bool dfs(int step,int x) {//x为当前构造的指数
	if (step>ans || x<=0 || x<<(ans-step)<n) return 0;
    //当step超过限定步数，指数为非正数，或者x自乘（ans-step）次仍小于n（可行性剪枝），则直接返回
	if (x==n || x<<(ans-step)==n) return 1;
	a[step]=x;
	for (register int i=0; i<=step; i++)
		if (dfs(step+1,x+a[i]) || dfs(step+1,x-a[i]))//乘或除以一个构造过的数
			return 1;
	return 0;
}
int main() {
	while(scanf("%d",&n) && n) {
        //用x乘除构造x^n，相当于从1加减构造出指数n
		for (ans=0; !dfs(0,1); ans++);//迭代加深搜索
		printf("%d\n",ans);
	}
}
```

（以下by ZAGER）

## 迭代加深搜索使用范围:

1.在有一定的限制条件时使用（例如本题中“如果能在1515步以内（包括1515步）到达目标状态，则输出步数，否则输出-1−1。“）。

2.题目中说输出所以解中的任何一组解。

为什么能够降低时间复杂度：

我们可能会在一个没有解（或解很深的地方无限递归然而题目中要求输出任何的一组解），所以我们限制一个深度，让它去遍历更多的分支，去更广泛地求解，(其实和BFSBFS有异曲同工之妙)。