# [**[JOI Open 2016] 摩天大楼**](https://www.luogu.com.cn/problem/P9197)

## **初探题面**

首先，看到绝对值想到分类讨论，即为：
$$
\operatorname{g}(i,i+1) = \begin{cases} f_i-f_{i+1} & f_i \ge f_{i+1} \\ f_{i+1}-f_i & f_i < f_{i+1} \end{cases}
$$

那么又是根据大小关系来决定权值大小了，所以考虑插入 DP。  

## **状态推导**

因为这里的状态因为没有段长的硬性要求，所以 $W,V,A,M$ 形状的段都是可以的，因此也减少了初始和结尾字符的特判（尽管题目也不需要特判）。

设 $dp_{i,j,k}$ 表示 $1\sim i$ 这些数所代表的数值插入进去之后有 $j$ 段当前权值总和为 $k$ 的情况总数。

注意到最开始是不用 $f_1-f_0$ 或者 $f_0-f_1$，结尾同理，所以依旧需要特判。

再发现，如果我们不记录开始和结尾数值的话，很难维护，所以我们要 **用尽可能小的空间传递更多的信息**。

- 如果我们能够确定第一个位置是否已经被填了，那么就不存在其它特判情况了，即在填的时候特判一下就可以了。（结尾同理）

根据上面那一条发现的性质，我们对 DP 状态进行修改，设 $dp_{i,j,k,0/1,0/1}$ 表示 $1\sim i$ 这些数所代表的数值插入进去之后有 $j$ 段当前权值总和为 $k$ 且开头结尾有没有被确定的情况总数。

这个转移方程一确定，那么事情就简单多了。

## **转移方程**
首先，明确一下状态的后效性如何去除（因为 $\operatorname{g}(i,i+1)$ 与两个元素有关）。

看下面这幅图：
![](https://cdn.luogu.com.cn/upload/image_hosting/4t9nejw4.png)

（其中横轴为元素的位置，纵轴为元素的值）

容易看出这样的总的权值和是：$\left\vert 5-1\right\vert +\left\vert1-6\right\vert+\left\vert6-4\right\vert+\left\vert4-3\right\vert+\left\vert3-2\right\vert+\left\vert2-7\right\vert+\left\vert7-8\right\vert$ 的。

在我们按照大小顺序插入的前提下考虑分开：$5-1+6-1+6-4+4-3+3-2+7-2+8-7$，消项得：$5-1+6-1+6-2+8-2$。

这样我们就可以得知，每个**极小值**会被减去两次（但是如果是在序列开头或末尾只会被减一次），每个**极大值**会被加两次（但是如果是在序列开头或末尾只会被加一次）。

即遇到极大值看它是不是在开头或者末尾，如果在，贡献就会一份，否则为两份，极小值同理。

综上，我们就把 $i,i+1$ 的贡献分开了，而且也利用到了我们知晓元素之间大小关系的性质，DP 转移就可以开始执行了。

**以下状态设计均为从大往小插入考虑**

然后，熟悉的分类讨论：
- 对于 $i$，它合并了两个段，段数少 $1$  

因为 $i$ 合并两个段，所以它不能在最左边或者最右边，而且它两端都是比它小的数，那么它便是这个区间的极小值，对全局的贡献是负的两倍。即：
$$
dp_{i,j,k,p,l} = jdp_{i-1,j+1,k+2a_i,p,l}
$$

（为什么是加 $2a_i$，是因为，它插入之后贡献为 $k$，插入之前肯定就是加上）

- 对于 $i$，它新开了一个段，段数多 $1$

因为 $i$ 新开了一个段，之后合并它和其它段的数一定比它小，所以它是区间极大值，对全局的贡献是正两倍，注意，它如果是在最左边，它的贡献就只有一倍，在最右边同理。特别注意，如果左右两边已经确定了，那么它能够新开段的位置会少 $1\sim 2$ 个。即：

$$
\begin{aligned}
dp_{i,j,k,0,0} &= jdp_{i-1,j-1,k-2a_i,0,0} \\
dp_{i,j,k,0,1} &= (j-1)dp_{i-1,j-1,k-2a_i,0,1}+dp_{i-1,j-1,k-a_i,0,0} \\
dp_{i,j,k,1,0} &= (j-1)dp_{i-1,j-1,k-2a_i,1,0}+dp_{i-1,j-1,k-a_i,0,0} \\
dp_{i,j,k,1,1} &= (j-2)dp_{i-1,j-1,k-2a_i,1,1}+dp_{i-1,j-1,k-a_i,1,0}+dp_{i-1,j-1,k-a_i,0,1}  
\end{aligned}
$$

- 对于 $i$，它延续了某个段，并接在该段的左/右边，段数不变

我们以左边为例，因为 $i$ 在普通情况下一边会有比它小的，一边会有比它大的，所以 $i$ 对总的值没有贡献，但是当 $i$ 在左边或者右边时，它是区间极小值，贡献是负一倍。即：

$$
\begin{aligned}
dp_{i,j,k,0,0} &= jdp_{i-1,j,k,0,0} \\
dp_{i,j,k,0,1} &= jdp_{i-1,j,k,0,1} \\
dp_{i,j,k,1,0} &= (j-1)dp_{i-1,j,k,1,0}+dp_{i-1,j,k+a_i,0,0} \\
dp_{i,j,k,1,1} &= (j-1)dp_{i-1,j,k,1,1}+dp_{i-1,j,k+a_i,0,1}
\end{aligned}
$$

加在右边同理，由此我们推导完了整个 DP，但是实现过程中还要注意一下转移时的细节：左右端点固定后权值是多少？有多少个段可以插入等。

这种方法常数很大，同时不利于优化，但是更好想一些。

## 代码
```cpp
#include<bits/stdc++.h>
#define ll long long
#define mod 1000000007
using namespace std;
ll n,i,j,k,l,a[105],dp[2][105][8005][2][2],ans;
bool cmp(ll a,ll b){return a>b;}
void add(ll &a,ll b){
	a += b;
	a %= mod;
}
int main(){
	ios::sync_with_stdio(false);
	cin>>n>>l;
	for(i=1;i<=n;i++) cin>>a[i];
	if(n==1){
		cout<<1<<endl;
		return 0;
	} 
	sort(a+1,a+n+1,cmp);
	dp[0][0][0][0][0] = 1;
	for(i=1;i<=n;i++){
		for(j=0;j<=i;j++) for(k=0;k<=6000;k++) dp[i&1][j][k][0][0]=dp[i&1][j][k][1][0]=dp[i&1][j][k][0][1]=dp[i&1][j][k][1][1]=0;
		for(j=1;j<=i;j++){
			for(k=0;k<=6000;k++){
				//MERGE
				add(dp[i&1][j][k][0][0],j*dp[(i-1)&1][j+1][k+2*a[i]][0][0]);
				add(dp[i&1][j][k][0][1],j*dp[(i-1)&1][j+1][k+2*a[i]][0][1]);
				add(dp[i&1][j][k][1][0],j*dp[(i-1)&1][j+1][k+2*a[i]][1][0]);
				add(dp[i&1][j][k][1][1],j*dp[(i-1)&1][j+1][k+2*a[i]][1][1]);
				if(k>=2*a[i]){
					//NEW
					add(dp[i&1][j][k][0][0],j*dp[(i-1)&1][j-1][k-2*a[i]][0][0]);
					add(dp[i&1][j][k][1][0],(j-1)*dp[(i-1)&1][j-1][k-2*a[i]][1][0]);
					add(dp[i&1][j][k][0][1],(j-1)*dp[(i-1)&1][j-1][k-2*a[i]][0][1]);
					if(j-1>1) add(dp[i&1][j][k][1][1],(j-2)*dp[(i-1)&1][j-1][k-2*a[i]][1][1]);
				}
				if(k>=a[i]){
					//NEW
					add(dp[i&1][j][k][1][0],dp[(i-1)&1][j-1][k-a[i]][0][0]);
					add(dp[i&1][j][k][0][1],dp[(i-1)&1][j-1][k-a[i]][0][0]);
					add(dp[i&1][j][k][1][1],dp[(i-1)&1][j-1][k-a[i]][0][1]+dp[(i-1)&1][j-1][k-a[i]][1][0]);
				}
				//LEFT
				add(dp[i&1][j][k][0][0],j*dp[(i-1)&1][j][k][0][0]);
				if(j>1) add(dp[i&1][j][k][1][0],(j-1)*dp[(i-1)&1][j][k][1][0]);
				add(dp[i&1][j][k][1][0],dp[(i-1)&1][j][k+a[i]][0][0]);
				add(dp[i&1][j][k][0][1],j*dp[(i-1)&1][j][k][0][1]);
				if(j>1) add(dp[i&1][j][k][1][1],(j-1)*dp[(i-1)&1][j][k][1][1]+dp[(i-1)&1][j][k+a[i]][0][1]);
				else add(dp[i&1][j][k][1][1],dp[(i-1)&1][j][k+a[i]][0][1]);
				//RIGHT
				add(dp[i&1][j][k][0][0],j*dp[(i-1)&1][j][k][0][0]);
				add(dp[i&1][j][k][1][0],j*dp[(i-1)&1][j][k][1][0]);
				if(j>1) add(dp[i&1][j][k][0][1],(j-1)*dp[(i-1)&1][j][k][0][1]);
				add(dp[i&1][j][k][0][1],dp[(i-1)&1][j][k+a[i]][0][0]);
				if(j>1) add(dp[i&1][j][k][1][1],(j-1)*dp[(i-1)&1][j][k][1][1]+dp[(i-1)&1][j][k+a[i]][1][0]);
				else add(dp[i&1][j][k][1][1],dp[(i-1)&1][j][k+a[i]][1][0]);
			}
		}
	}
	for(i=0;i<=l;i++) ans=(ans+dp[n&1][1][i][1][1])%mod;
	cout<<ans<<endl;
}
```