## 题面


将互不相同的 $N$ 个整数 $A_1, A_2, \cdots, A_N$ 按照一定顺序排列。

假设排列为 $f_1, f_2, \cdots, f_N$，要求： $| f_1 - f_2| + | f_2 - f_3| + \cdots + | f_{N-1} - f_N| \leq L$。

求满足题意的排列的方案数对 $10^9+7$ 取模后的结果。

$1\le N\le 100$，$1\le L\le 1000$，$1\le A_i\le 1000$。

## Solution

先考虑去绝对值，若从小到大依次插入，就能把绝对值符号去掉。

要求出序列的形状显然不行，且填入的数字在序列内的位置未知，考虑插入DP。

一般而言，记 $f_{i,j,k}$ 为当前有 $i$ 个数字 $j$ 个连通块权值为 $k$ 的方案数，但这样设状态显然无法做，因为无法确定填入的数字是否为总序列的端点，端点要特殊考虑。

于是乎，记 $f_{i,j,k,t}$ 为当前有 $i$ 个数字 $j$ 个连通块权值为 $k$ 找到了 $t$ 个总序列的端点的方案数，其中 $t\in[0,2]$。

那么，由于是依次插入的，每插入一个数，前面的数字旁边相邻的数字便会相应增加，总贡献会增加若干倍 $x=a_i-a_{i-1}$。举个例子，现在有两个连通块 $K_1= \{a_1,a_2\}$ ，$K_2=\{a_3,a_4\}$。现在把 $a_5$ 填入，无论填入哪一个块，都会有 $a_5-a_4$ 的贡献，接着填入 $a_6$ 时，又会产生 $a_6-a_5$ 的贡献，相当于依次填入$a_5,a_6$ 的贡献 $a_6-a_5-(a_5-a_4)$。以此类推，根据这种差分思想，过程被极大简化了。

现在考虑转移。

插入一个块的两段，不能插入 $t$ 个顶点，有 $(2\times j-t)$ 种可能。

$f_{i,j,(2\times j -t)\times x +k,t}+=f_{i-1,j,k,t}\times (2\times j -t)$。

合并两个块，选择两个块之间的空位。

$f_{i,j,(2\times (j+1)-t)\times x +k,t}+=f_{i-1,j+1,k,t}\times j$。

单独成段，可以选择在任意一块的块头块尾，注意不能在已经闭口的首尾段。

$f_{i,j,(2\times (j-1)-t)\times x+k,t}+=f_{i-1,j-1,k,t}\times (j-t)$。

单独成闭口的边界段。

$f_{i,j,(2 \times (j-1)-(t-1))\times x+k,t}+=f_{i-1,j-1,k,t-1}\times(2-(t-1))$。

将当前数字连接到边界段上。

$f_{i,j,(2 \times j-(t-1))\times x +k,t}+=f_{i-1,j,k,t-1}\times (2-(t-1))$。

最后 $ans=\sum\limits_{i=0}^{l}f_{n,1,i,2}$。

注意，转移不一样，状态不一样，这里采用人人为我的转移，$k$ 的值由 $j$ 决定。

## code
```cpp
int main() {
	scanf("%lld%lld",&n,&l);
	for(LL i=1;i<=n;i++)scanf("%lld",&a[i]);
	sort(a+1,a+1+n);
	if(n==1) {
		printf("1");
		return 0;
	}
	f[0][0][0][0]=1;
	for(LL i=1;i<=n;i++) {
		for(LL j=1;j<=i;j++) {
			for(LL k=0;k<=l;k++) {
				for(LL t=0;t<=2;t++) {
					LL x=a[i]-a[i-1];
					//插入一段 
					if((2*j-t)*x+k<=l)
						(f[i][j][(2*j-t)*x+k][t]+=f[i-1][j  ][k][t]*(2*j-t))%=mod;
					//合并两段 
					if((2*(j+1)-t)*x+k<=l)
						(f[i][j][(2*(j+1)-t)*x+k][t]+=f[i-1][j+1][k][t]*j)%=mod;
					//单独成段 
					if((2*(j-1)-t)*x+k<=l)
						(f[i][j][(2*(j-1)-t)*x+k][t]+=f[i-1][j-1][k][t]*(j-t))%=mod;
					//单独成靠边界段
					if(t!=0)
					if((2*(j-1)-t+1)*x+k<=l)
						(f[i][j][(2*(j-1)-t+1)*x+k][t]+=f[i-1][j-1][k][t-1]*(3-t))%=mod;
					//将一段连到边界上
					if(t!=0)
					if((2*j-t+1)*x+k<=l)
						(f[i][j][(2*j-t+1)*x+k][t]+=f[i-1][j  ][k][t-1]*(3-t))%=mod; 
				}
			}
		}
	}	
	for(LL i=0;i<=l;i++)
		(ans+=f[n][1][i][2])%=mod;
	printf("%lld",ans);
	return 0;
}
```