[题目传送门](https://www.luogu.com.cn/problem/CF135A)

题意：将 $n$ 个**正整数**中任意一个替换成**除本身之外**的，$1$ 至 $10^9$ 之间的整数（含 $1$ 和 $10^9$）。求替换后第 $k$ （$k=1\cdots n$）小的数的最小值。

假定原来的 $n$ 个数已经**排好序**，存在数组 $a$ 中（$a_1,a_2,\cdots a_n$）。排序是为了便于判断更改之后，第 $k$ 小的数是什么。

考虑将第 $x$ 小的数 $a_x$ 更改为 $y$ 。那么我们分类讨论：

1. $a_{x-1}<y<a_{x+1}$ 且 $y\neq a_x$。那么此时第 $x$ 小的数是 $y$。
1. $y\leq a_{x-1}$。那么此时第 $x$ 小的数是 $a_{x-1}$。
1. $y\geq a_{x+1}$。那么此时第 $x$ 小的数是 $a_{x+1}$。

又因为 $a_{x-1}\leq a_{x+1}$，所以情况 $2$ 显然是最优的，即 $a_{x-1}$ 是最小的 $y$。

那么当 $a_x=a_{x-1}=1$ 的时候怎么办呢？$a_x$ 不能改成它自己，也不能比 $1$ 还小。对于这种情况，将 $a_{x+1}$ 改成一个大于 $1$ 的数即可，还是能保证 $a_{x-1}$ 是最小的 $y$。

针对上面情况，还有一点要注意：当$a_x=a_{x-1}=1$ 且 $x=n$ 时 $a_{x+1}$ 不存在，因为必须改一个数，所以只能把 $a_n$改成 $2$。

因为全 $1$ 数列的特殊性，所以代码中分成 $n>1$ 和 $n=1$ 两种情况:
```cpp
#include<iostream>
#include<algorithm>
using namespace std;
int n,i,a[100002];
int main()
{
    cin>>n;
    for(i=1;i<=n;i++)cin>>a[i];
    sort(a+1,a+n+1);
    if(n>1)
    {
        cout<<1<<" ";//易得最小数一定是1
        for(i=1;i<n-1;i++)cout<<a[i]<<" ";
        if(a[n]==a[n-1]&&a[n]==1)cout<<2;
        else cout<<a[n-1];
    }
    else
    {
        if(a[n]==1)cout<<2;
        else cout<<1;
    }
    return 0;
}

```