既然没有人写pascal的题解，那么我来~~（组成头部）~~献一篇拙作……

首先考虑排好序的N(N<=31)位二进制数。

你会发现，这很有趣。因为他们是排列好的，而且包含所有可能的长度为N且含有1的个数小于等于L(L<=N)的数。
你的任务是输出第I（1<=I<=长度为N的二进制数的个数）大的，长度为N，且含有1的个数小于等于L的那个二进制数。
共一行，用空格分开的三个整数N，L，I。

这道题很难，构思巧妙,先用dp求出所要求f[i,j]前i位1的个数不大于j的方案数，然后便是print了。

那么问题来了，~~（挖掘机技术哪家强）~~如何计算f[i,j]。

f[i,j]表示前i位，1的个数不大于j的方案数。

显然：f[i,j]=f[i-1,j]+f[i-1,j-1]

f[i-1,j]表示当前第i位以0开头所得到的方案数,f[i-1,j-1]表示当前第i位以1开头得到的方案数。


如何根据得到的f[i,j]来print呢？如果当前我要确定第i位，那么肯定要看f[i-1]集合中的值判断，例如我当前确定第5位，前4位不超过3个1的方案数为15，而我现在要求第19位，则第5为1，因为19>15，为什么呢？因为第5位可能为0,1，而为0的占了15个，为1的开头也是占15个，显然19属于为1开头的数，所以输出1。

注意：如果答案当前的一位是1，那么有些值也应当改变。1的个数要减一。当前的答案在接下来的01串的序数要减去第一位为0的01串个数。至于为什么请自行考虑。

以此类推...

代码：
```pascal
var
        f:array[0..31,0..31] of longint;
        n,l,i,j:longint;
        k:int64;
procedure print;
begin
        for i:=n-1 downto 0 do
                if f[i,l]<k then
                begin
                        write(1);
                        dec(k,f[i,l]);
                        dec(l);
                end
                else
                write(0);
        writeln;
end;
 
begin
        readln(n,l,k);
        fillchar(f,sizeof(f),0);
        for i:=0 to n do
                f[i,0]:=1;
        for i:=0 to L do
                f[0,i]:=1;
        for i:=1 to n do
            for j:=1 to n do
                f[i,j]:=f[i-1,j]+f[i-1,j-1];
        print;
end.

```