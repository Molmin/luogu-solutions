这道题虽然~~看起来~~并不是非常难，但作为DP蒟蒻，着实费了极大的脑筋……（QAQ）权当对其他题解更详细的说明与补充，也为了纪念与提醒自己，本蒟蒻决定写一篇题解（或者说心得感悟吧）

**首先**  我思考能不能用f[n][L][i][0or1]通过f[n][L][i/2][0or1]<<1或<<1+1的方法直接推出所要答案（emmm我试了将近一个小时），但是始终发现连样例也过不了。什么原因呢？我发现由于L的限制，末尾为1与末尾为0的数个数未必相同，那么也就没有办法通过假想的对半分来推出答案了……（~~看不懂也无所谓，这是一个蒟蒻的自我嘲讽~~）

**那么怎么办呢？**

我们发现，换个思路就能使题目变得很简单。既然第i大的数具体是几很难求，那么长度为n，1的个数为L的数的方案数总是很好求了吧！那我们就先求出方案数。

设f[n][l]表示长度为n，1的个数为l的方案数（注意，这里不是小于等于，而是确切地等于，所有小于等于的方案数是用下面的sum变量存放的）可以用DP，即f[n][l]=f[n-1][l]+f[n-1][l-1]，意思就是可以由已经具有l个1的长为n-1的数<<1而来，也可由已经具有l-1个1的长为n-1的数<<1+1而来；

此外，要是DP理解有困难~~比如我~~，还可以用**组合数**来理解，因为所有的方案数就相当于在n个0中取l个变成1，然后用**杨辉三角形**求解，反正递推式都是一样的。

**OK**，我们已经求出了方案数，那么下面我们应该怎么做呢？我们可以for k=0~n（从0开始，因为0算第一个数，1是第二个数），用sum记下f[k][0~l]的和，用last记下f[k-1][0~l]的和，当sum>=k时，说明此时第i大的数一定大于第last大的数，小于第sum大的数。因此，从右往左数第k位一定为1，否则无法做到恰在中间的某个位置。此时我们用掉了一个1，将l减1，可用的位数也少了1，将n减1。至于i，将其减去当第k位为0的方案数，此时i就等于除去第k位不看，其它符合条件的数的方案数，然后继续做下去即可。最终得到一个ans数组，再将它依次输出即可。

**注意两个坑点**，第一个是要求二进制数的长度为n，最高位是0也没有关系，第二个是注意一下0也算一个（这么说就是有可能爆int的。。）

下面是代码

```cpp
#include<bits/stdc++.h>
using namespace std;
long long f[40][40];
int ans[40];
int N,L;
long long I;
void work(int n,int l,long long p){
    if(l==0) return;
    long long last=0;
    for(int i=0;i<=n;i++){
        long long sum=0;
        for(int j=0;j<=l;j++) sum=sum+f[i][j];
        if(sum>=p){
            ans[i]=1;
            work(n-1,l-1,p-last);
            return;
        }
        last=sum;
    }
}
int main(){
    cin>>N>>L>>I;
    f[0][0]=1;
    for(int i=1;i<=N;i++){
        f[i][0]=1;
        f[i][i]=1;
        for(
		int j=1;j<i;j++){
            f[i][j]=f[i-1][j-1]+f[i-1][j];
        }
    }
    work(N,L,I);
    for(int i=N;i>=1;i--) cout<<ans[i];
    cout<<endl;
    return 0;
}

```
第一次写题解，难免疏漏，请大佬们批评指正！