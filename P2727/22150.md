d[i][j]表示长度为i，1的个数至多为j的二进制数量

边界：d[i][0]=1;(任何位没有至多0个1的情况只有一种0000000....)d[0][i]=1;(主要是为了在递推的过程中,长度为1,1个数至多j的二进制转移正确。（长度为1的情况下，只有0,1两种）)

d[i][j]=d[i-1][j]+d[i-1][j-1]分别有第i位为1，0两种情况。//前者是第i位为0的情况下，后者为第i位为1的情况

打印解得原理：

有转移方程可以知道，I>d[i-1][L]的情况时候，必定存在d[i-1][j-1]的情况，此时我们确定第i位必定为1，所以减去第i位为0,长度为i的情况 剩下的就是第i位为1的情况

 
比如找3位，1个数不超过3个，的第7个二进制 数

000
001
010
011
减掉上面的 ，第三位为0的情况 剩下的是：

100
101
110
111
减去的上面部分  7-4=3；剩下4种第3位为1的情况，则下面讨论的其实是：

00
01
10
11
转移到这了 重复这样的步骤（求2位，1个数不超过3-1=2个，第3位二进制数），就能确定第2位第1位了

看了各种题解，不详细┭┮﹏┭┮没想到自己模拟下就想通了，把原本题解翻译成人能听懂的话，(逃

/\*
ID:luojiny1

LANG:C++

TASK:kimbits

\*/
  

    

```cpp
#include<cstdio>
int d[35][35] = { 0 }, ans[35];
int main()
{
    freopen("kimbits.in","r",stdin);
    freopen("kimbits.out","w",stdout); 
    int N, L;
    long long I;
    scanf("%d%d%lld", &N, &L, &I);
    for (int i = 0; i <= N; i++)d[i][0] =d[0][i]=1;
    for (int i = 1; i<=N; i++)
        for (int j = 1; j <= N; j++)
            if(j<=i)
            d[i][j] = d[i - 1][j - 1] + d[i - 1][j];
            else d[i][j] = d[i][i];
    for (int i = N; i >= 1; i--) {
        if (I > d[i - 1][L]) {
            putchar('1');
            I -= d[i - 1][L];
            L--;
        }
        else putchar('0');
    }
    putchar('\n');
    return 0;
}
```