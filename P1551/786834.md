**大家第一眼看到这道题，一定都能很快发现，用并查集做这道题是很好的选择。但是，实际上用 bfs 就可以让程序的复杂度摘掉一级 $\log n$，轻松解决这个问题。**

为了理清思路，我们可以换个角度理解题意：给出一个含有 $n$ 个点，$m$ 条边的无向图，有 $p$ 次询问，每次询问 $2$ 个整数 $P_i,P_j$，你需要判断两点间是否连通。

想到这一步，你很自然地便可以想到图的一种操作——遍历。既然是求两点间的连通性，那么，我们何不用一个简单的 bfs 遍历算法，将所有点连接的编号最小点（若一个点没有连接编号小于自己的点，应填自己的编号）记录起来呢？如果这么做，待询问时就可以以 $O(1)$ 的时间复杂度查询（若两点记录的连通点相同则两点连通，否则不连通），并快速得知答案了。这样算法的空间复杂度为 $n+m$，时间复杂度则为 $O(n+m+p)$，可以轻松过掉 $5000$ 以内的数据。
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[5001],u[5000];
vector<int>p[5001];
int main(){
	int n,m,q;//为防止变量重复，将原题中 p 改为 q
	scanf("%d%d%d",&n,&m,&q);
	while(m--){
		int x,y;
		scanf("%d%d",&x,&y);
		p[x].push_back(y),p[y].push_back(x);//记录每一条边
	}
	for(int i=1;i<=n;i++)
		if(!a[i]){//只要标记过了，就一定是最小的，且其连通点也全被标记过了
			a[i]=i;
			int h=0,t=1;u[0]=i;//h 为队头，t 为队尾，u 为队列
			while(h<t){
			int k=p[u[h]].size();
			for(int j=0;j<k;j++)if(!a[p[u[h]][j]]){//有标记连通点，说明这个点一定被遍历过
				a[p[u[h]][j]]=i;
				u[t]=p[u[h]][j],t++;
			}
			h++;
		}
	}
	while(q--){
		int x,y;
		scanf("%d%d",&x,&y);
		if(a[x]^a[y])puts("No");
		else puts("Yes");
	}
}
```
当然，你如果对 dfs 和链式前向星比较熟悉的话，用那两种方法也没问题（使用链式前项星可以比 `vector` 更快）。不过，**对于 $u,v(u<v)$ 这条边，切记不要只在 $p_u$ 这一容器里记录 $v$ 这个直接连接的点**，因为如果这样记，那么万一存在点 $w(u<w<v)$ 也与 $v$ 连通，那么 $w$ 及其连通的一部分点可能就没法及时得到 $u$ 这一与自己连通的点，从而只能记录编号更大的点，导致查询出错。例如在此种遍历方式下，对于 $1,3$ 这条边，$a_3$ 可以正确地设为 $1$，但此时如果再来 $2,3$ 这条边，那么由于 bfs 遍历在此时的单调递增特性，$a_2$ 只能为 $2$，而不是 $1$（此时 $3$ 这个中转点就被视而不见了）。更严重的错误是，在此之后，$2$ 也肯定会遍历到 $3$ 这个点，$a_3$ 便被设为了 $2$，这更影响了程序的正确性。

看到这里，好奇的你可能要问了：本题考察的是并查集，但为什么恰好能通过图的遍历来做呢？其实，这与查询机制有关。这题的所有询问都是在图的所有边都输入完后进行的，所以，我们可以通过线性级复杂度的遍历预处理，应付每一次询问。但是，如果程序在中途就要询问 $P_i,P_j$ 的连通性的话，最好的方法也只能是在询问时立即遍历 $P_i$ 连接的所有点，此时的时间复杂度可以达到 $O(m^2)$，效率并不高于并查集。但是，即使是在动态询问时，用并查集做，仍能保证平均为 $O(m\log n)$ 的效率，最坏也只是 $O(mn)$，这样至少比暴力遍历来得好。

**总而言之，在静态查询时，某些并查集的题目是可以通过遍历来做的，但并查集也是需要掌握的，因为它在动态查询时可以有非凡的平均效率。**