### 关于这道题：

看到好多神仙级的巨佬根本无视w这种小蒟蒻直接引入并查集，所以w打算通过这篇题解给各位刚入坑的OIer们讲讲并查集这个东西qwq

------

根据题目的意思，因为是一个“亲戚关系图”，因此w们先创造一个图$G(V, E)$，因此n, m就分别是指$G$的n个点，m条边，这里w们可以采用样例的6，5，然后再根据样例中给出的“亲戚关系”去在点之间建边，于是就得到了下面这个图：

![qwq](https://cdn.luogu.com.cn/upload/pic/73123.png "没错就是w！")

~~有点小没办法qwq~~

很显然w们可以看出，这是一个无向图，而且很显然这个并不是一个联通图（当然也有是连通图的时候，那种特殊情况待会讨论）

那么显而易见，现在除了6之外的所有点都是亲戚，也就是说无6的那个子图是一个无向联通子图，所以说可以得出结论，**在任意联通子图中的两个点必为亲戚关系，为亲戚关系的两个点在同一联通子图中**

所以根据这个性质，w们就把问题转化为：在一个无向图中，查询两点是否在同一联通子图中

那么很显然，w们肯定是开一个vis数组，用邻接表存，然后走到一个点就更新vis，如果无路可走那么就去遍历下一个联通子图

这种方法的话存在两种非常极限的情况，第一种是在$G$中根本没有边相连，则需要遍历的次数就退化成了$O(n)$，也就是每一个点都需要遍历一次

第二种极限的情况就是当所有点都相连的时候，遍历查找整个邻接表的复杂度就退化为$O(m)$甚至更高

很显然这种方法面对小数据是能够过的
~~（其实这道题也能这么水）~~，不过很显然如果遇到了大数据还没$n^2$就过百万了。。。

众所周知，在利用邻接表存储的时候，w们是用了一个类似hash表的样子的一个东西对于图进行存储的一个东西，所以在w们存储的时候本质就是给它存成了一堆链表，而链表的查询复杂度在特殊情况其实是比较高的，再加上可能会出现毒瘤数据，所以有的时候甚至会卡出接近$O(nm)$的复杂度

但是，请思考一个问题：

**w们真的需要去遍历每个子图嘛？**

很显然并不是，因为w们只需要知道需要查询的元素和已知与需要查询的元素有关联的一个点与另外一个需要查询的元素是否有关系即可，而对于这种关系，w们可以在处理的时候就让一些点同时处于一个集合中，而在该集合要在集合中任取一个元素作为该集合的代表元素，然后可能会出现一个集合中有一个元素是另一个集合的代表元素的情况，很显然这就让w们想起了另外一个数据结构：

**树**

那么每一个联通子图就变成了一个个的树，而整个图就变成了一个森林

那么w们有必要按照树的存储方式来存图嘛？很显然w们并不需要，因为w们其实只是对于一个集合进行了抽象而已，也就是说w们只需要存下标为i的点所在集合的代表元素即可

这就是基础的并查集

可是这仅仅是基础，因为w们还有可能会遇到一些更加极限的情况

举个栗子，当$n = 5, m = 4$时，存在有$1 - 2, 2 - 3, 4 - 5, 3 - 4$的边集，根据上面所讲的并查集思路，大概就是能画出来这样一个图：

![qwq](https://cdn.luogu.com.cn/upload/pic/73134.png "就是w")

泥可能会惊讶，蛤这不是个链表嘛qwq?

珂这真的是按照w们刚刚的思路建的一个森林，w们可以叫他一叉森林（大雾）

咳咳

这种就是w所说的极限情况，每个集合确实是有代表元素，但是他们本质还是属于同一个大的集合，而退化成链表后的复杂度也就变成了$O(n)$，很显然A了本题是完全够得，可是遇到$1e9$这样的大数据就会$\large\color{red}\text{TLE}$

所以w们就要思考为什么会退化，很显然在储存的时候w们只考虑最近的集合，但是很显然如果直接归并到祖先集合中其实也是完全OK的

所以w们需要对并查集进行路径压缩，但是很显然如果w们在读入的时候就进行路径压缩其实对于最后的结果还是有一定影响的，因此w们只能在查找的过程中对于并查集进行路径压缩

------

咳咳咳上面讲了这么多，下面是本题的代码qwq

```cpp
#include<cstdio>
#define r(i,a,b) for(int i=a;i<=b;i++)
using namespace std;
int father[5001],n,m,p,a,b,u,v;
int find(int x)//查找+路径压缩
{
    return x==father[x]?x:father[x]=find(father[x]);
}
int main()
{
    r(i,0,5000) father[i]=i;
    scanf("%d %d %d",&n,&m,&p);
    r(i,1,m)
     {
        scanf("%d %d",&a,&b);
        u=find(a);v=find(b);//查找
        if(u!=v) father[u]=v;//合并
     }
    r(i,1,p)
    {
        scanf("%d %d",&a,&b);
        u=find(a);v=find(b);
        if(u!=v) puts("No");else puts("Yes");//判断，输出
    }
}
```

上面代码转自[这里](https://blog.csdn.net/xuxiayang/article/details/79231149)，因为某Null_Cat实在懒得再敲代码喏qwq