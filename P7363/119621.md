eJOI 官方题解写的都是什么东西，看都看不懂/px

经过几小时的思考终于肝出来了/kk

补一篇题解来造福一下后人吧qwq。

首先先去感性理解一下这个游戏的过程。

题目限制每个格子边上只能有 $0$ 或 $2$ 个已经选择的边。先考虑令 $w_{i,j}$ 表示 $(i,j)$ 这个格子四周有几条未选的边。显然 $w_{i,j}=0$ 的格子没有任何用。

考虑剩下的 $w_{i,j}=2$ 的格子。

现在去选一条边，则会将 $1$ 个或 $2$ 个 $w_{i,j}$ 变为 $1$。这时候轮到另外一个人了，他可以将这个连通块里的格子选走任意多个之后再选一条边。

这里连通块指不穿过已选的边，按照四联通规则所能走到的所有格子组成的集合。

上面只是感性部分，可以结合样例手玩一下，应该比较容易理解。

如果这个图里只有一个连通块，那么先手选第一条边之后直接就把这个连通块白给了，游戏结束。

连通块只有两种：链和环。先考虑只有链的情况。

如果有两个连通块，假设大小为 $x,y$，不妨 $x\le y$。两个人所要争取的一定是 $y$ 而不是 $x$。所以先手不能直接把 $y$ 白给了，而是一定先白给 $x$。此时就有两种情况了。

- 如果 $x\ge 3$，那么后手可以先连续获取 $x-2$ 个方格并在 $x$ 中选择一条边使得它不与其它边形成方格。这样做会把 $2$ 个格子送给先手但是逼迫先手把 $y$ 白给了。容易证明这一定能做到。

- 如果 $x<3$，那么后手只能获取 $x$ 中所有格子并白给 $y$。

环中的第一种操作与链有差异，它需要 $x\ge 4$，并且要送 $4$ 个格子给对手。

有了这样的基础，我们考虑扩展到多个连通块的情况。

将环和链分开，并分别从小到大排序。每次如果被迫白给一定只会白给链中最小的一个或者环中最小的一个。令 $dp_{i,j}$，表示当前链还剩下 $i$ 及 $i$ 之后，环还剩下 $j$ 及 $j$ 之后的答案。

根据上面的推理，具体转移已经比较容易推出了，如果不懂可以看代码，应该还是比较清晰的。

代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
#define N 25
#define M 405
const int INF=1e9;
int n,m,cnt,st[2][M],dp[M][M];
bool fl,vs[N][N];char a1[N][N],a2[N][N];
void W(int &x,int y) {x=max(x,y);}
void dfs(int x,int y)
{
	if(!x || !y || x>n || y>m) {fl=0;return;}
	if(vs[x][y]) return;bool fl1=0;vs[x][y]=1;
	if(a1[x][y]=='0') fl1=1,dfs(x-1,y);
	if(a1[x+1][y]=='0') fl1=1,dfs(x+1,y);
	if(a2[x][y]=='0') fl1=1,dfs(x,y-1);
	if(a2[x][y+1]=='0') fl1=1,dfs(x,y+1);cnt+=fl1;
}
int main()
{
	scanf("%d %d",&n,&m);
	for(int i=1;i<=n+1;++i) scanf("%s",a1[i]+1);
	for(int i=1;i<=n;++i) scanf("%s",a2[i]+1);
	for(int i=1;i<=n;++i) for(int j=1;j<=m;++j)
	{cnt=0;fl=1;dfs(i,j);if(cnt) st[fl][++st[fl][0]]=cnt;}
	sort(st[0]+1,st[0]+st[0][0]+1);
	sort(st[1]+1,st[1]+st[1][0]+1);
	for(int i=st[0][0]+1,t;i;--i) for(int j=st[1][0]+1;j;--j)
	{
		if(i>st[0][0] && j>st[1][0]) continue;dp[i][j]=-INF;
		if(i<=st[0][0])
		{
			t=-INF;W(t,st[0][i]+dp[i+1][j]);
			if(st[0][i]>2) W(t,st[0][i]-4-dp[i+1][j]);
			W(dp[i][j],-t);
		}
		if(j<=st[1][0])
		{
			t=-INF;W(t,st[1][j]+dp[i][j+1]);
			if(st[1][j]>3) W(t,st[1][j]-8-dp[i][j+1]);
			W(dp[i][j],-t);
		}
	}printf("%d\n",dp[1][1]);return 0;
}
```