看了各位犇犇的做法  
我发现大多用了栈  
（其实栈更简单一些  
这道题作为一道橙题  
对一些刚入门的比我强的OIer不太友好  
所以
## 我选择用数组
###### 顺便加个时间优化
某OI教练如是说：  
斐波那契数列在92项就爆了long long  
所以我们先把斐波那契数列处理一下
```
unsigned long long fib[92];
void fi() {
	fib[1]=fib[0]=1;
	for(int i=2; i<92; i++) {
		fib[i]=fib[i-1]+fib[i-2];
	}
	return;
}
```
但是看了这题范围  
貌似。。。。int就够了  
~~没事，你这么蒻没人会说你（逃~~  
接下来就是我们的拆分部分  
这里是一种时间复杂度稍微高一点的做法  
```
maxx=92;
for(int j=maxx; j>0; j--) {
	if(temp>=fib[j]) {
		temp-=fib[j];
		k++;
		ans[k]=fib[j];
	}
	if(temp==0){
		j=0;
	} 
}
```
这个代码，你会发现在每一次减完了之后会再从92在重新找一遍，各位犇犇由于开的是int有45项不用担心，但是我们要考虑出现pow(2,64)-1（详见2019 CSP-S D1 T1）的情况，所以我们要考虑大一点的解。  
### 一次被卡unsigned long long 十年怕unsigned long long  
接下来是优化了一下的做法
```
for(int j=maxx; j>0; j--) {
	if(temp>=fib[j]) {
		temp-=fib[j];
		maxx=j;//这里就是优化
		k++;
		ans[k]=fib[j];
	}
	if(temp==0){
		j=0;
	} 
}
```
我们可以看到由于斐波那契的特性  
后一项一定是前一项的二倍小   
所以一项不会出现两遍  
直接记录下来这个位置就可以继续向前面继续搜比他小的  
由于我们已经记录下来了有k项  
可以直接sort排序  
之后直接按照格式输出  
什么？  你输出总是在后面又有一个+号？  
直接把他判掉
```
	if(i==k) {
		continue;
	}
	cout<<"+";
```
你以为这样就结束了？  
不！  
因为你用的是数组，又有多组数据。  
所以你需要memset一下  
当然你也需要更新k  
还要输出换行  
否则50分
##### 通过率的教训
```
	cout<<endl;
	memset(ans,0,sizeof(ans));
	k=0;
```   
##### 避免50分三件套，多组数据必备每次养成好习惯  
原代码就不需要放这了吧  
相信各位看了本蒻筠的题解之后也有思路了吧  
祝各位RP++