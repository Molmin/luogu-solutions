# 前言。
题意不再赘述。

这道题主要是注意精度问题。
# 分析。
由 $ c_i = 1000(\dfrac{a_i}{A}+\dfrac{b_i}{B})$ 可得，可以设 $A=400$ 且 $B=600$ 的值，这样在对 $a_i$ 和 $b_i$ 细微调整后，精度的准确值是比较高的。

根据乘法分配律，原式可以化为 $c_i = \dfrac{5}{2}a_i + \dfrac{5}{3}b_i = \dfrac{15}{6}a_i + \dfrac{10}{6}b_i = \dfrac{15a_i + 10b_i}{6}$ 的形式。

因为要四舍五入，所以可得 $c_i - \dfrac{1}{2} \leq \dfrac{15a_i + 10b_i}{6} < c_i + \dfrac{1}{2}$ 的不等式。

去分母得 $6c_i - 3 \leq 15a_i + 10b_i < 6c_i +3$。

所以我们可以使用在 $0$ 到 $400$ 中枚举 $a_i$ 并在 $0$ 到 $600$ 中枚举 $b_i$ 的方法。如果不等式成立，则输出这个解即可。

但是这样朴素地枚举时间复杂度较高，无法通过本题，考虑优化。

实际上我们每次枚举时，对于某些方案进行了多次重复计算，浪费了运行时间。所以我们可以预处理出所有 $c_i \in [10,1990]$ 的答案，然后每次询问直接输出即可。

复杂度可以通过本题。

代码如下，仅供参考：
```
#include<iostream>
using namespace std;
int n,c,ans[10005],ans2[10005];
int main(){
    cin>>n;
    for(int i=0;i<=400;i++){
        for(int j=0;j<=600;j++){
            ans[(15*i+10*j+3)/6]=i;
            ans2[(15*i+10*j+3)/6]=j;
        }
    }
    while(n--){
        cin>>c;
        cout<<ans[c]<<" "<<ans2[c]<<"\n";
    }
    return 0;
}
```
# 后记。
大家如有疑问，可以在评论区提出，我会尽力解答的。