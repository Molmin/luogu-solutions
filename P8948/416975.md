这道题数据范围实际上可以达到 $10^6$ 而有不超时的做法，而且用不到数组，也超不过绿。我看到这道题时，一下就觉得有常数不超过 $100$ 的 $O(n)$ 的解法，经过长达一个小时的思考，我发现：当第一名同学两次考试的成绩分别为 $200$,$500$ 时，接下来 $a_i$ 每增加 $1$ , $c_i$ 增加 $1\div200\times1000=5$ ， $b_i$ 每增加 $1$ , $c_i$ 增加 $1\div500\times1000=2$ ，当然，它们都有上限，我们就要证明 $10\sim1990$ 的数都可以有不超过 $200$ 个 $5$ 和不超过 $500$ 个 $2$ 构成，我们发现，由于不是 $0\sim 2000$ ，所以构成时有一定空隙，所以或许都能构成，那我们就要思考构成方式：当这个数为奇数时，我们可以先用一个 $5$ ,使得剩下的数为偶数，之后我们在将其变为若干个 $2$ ，若不超过 $500$ ，程序就可以结束了。否则，我们将多出来的数拿出来，一直凑 $5$ ，一直到凑不出来，接着，如果凑完还有余数，我们就将那 $500$ 个 $2$ 拿出来放到余数里，直到余数为 $5$ 的倍数。

## 代码：
```
#include<bits/stdc++.h>
using namespace std;
int main(){
	int n,a;
	cin>>n;
	cin>>a;
	cout<<"200 500"<<endl;
	n--;
	while(n--){
		cin>>a;
		int x,y;//x为5的个数，y为2的个数
		x=0;
		y=0;
		if(a%2){//如果是奇数
			a-=5;
			x++;//先凑一个5
		}
		y+=a/2;//尽量凑2
		if(y>500){//如果2太多
			int z;
			z=(y-500)*2;//把多出来的拿出来
			x+=z/5;//拿出来的尽量凑5
			y=500;//多出来的已经拿出来了，只剩500了
			z-=z/5*5;//把已经凑出来的删去，剩下的就是余数
			while(z%5){//别看这是一重循环，但数学证明超不过 $5$ 次。
				y--;
				z+=2;//把2慢慢拿出来，直到余数为5的倍数
			}
			x+=z/5;//凑5
		}
			cout<<x<<" "<<y<<endl;
	}
	return 0;
}
```