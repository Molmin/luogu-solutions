稍微动脑就能做出来的结论题。当做比赛第一题也挺友好的。

跟后缀树有什么关系吗……

---------

### 题意简述

给定长度 $n$，求出有多少种方案，能使得 $S$ 只由小写字母组成，且不存在一种将这个串分成两段的方式，使得前面一段是后面一段的子串。

### 解题思路

**前置知识：**

- 排列组合基础知识。
- 快速幂。

直接讲正解思路吧。

其实样例解释已经给出了正解暗示。我们从这里出发。

首先，我们能确定，第一个字符一定能填 $26$ 个字符任意一个。因为分割不能从第一个前面分。

当 $|S|=2$ 时，分割只能从中间分，也就是当两个字符不同时，就是合法方案。

当 $|S|=3$ 时，分割只能从第一位后面分。因为从第二位分，前面的长度已经大于后面，不可能是其子串。那么，只要第一个字母（前面子串）不与后面的字母（后面子串）相同即可。

推广到一般情况，直接考虑**最极端的情况**，也就是最容易非法的情况。显然能想到，在第一位后面分，**使第一个字母单独成子串**。

那么后面的每一个字母都有机会与它重复，成为非法方案。

所以最终的答案就是，**第一个字母任取，后面的字母不与第一个重复**就可以，也就是从剩下的 $25$ 个字母里去。

根据**乘法原理**，答案为：

$$26\times25^{n-1}$$

记得取模。

---------

可惜的是，对于乘方，

- C++ 自带的`pow()`虽然时间复杂度为 $O(\log n)$，但并不能取模。
- 朴素乘方需要 $O(n)$，会超时。
- 只能用快速幂。

快速幂不会的同学请点击[这里](https://www.luogu.com.cn/problemnew/solution/P1226)。

时间复杂度为 $O(\log n)$。

### 实现细节

- 最好开`long long`，避免中途乘爆`int`。
- 没了。这题没什么坑点。


### 参考代码

```cpp
#include <iostream>
#include <cstdio>
using namespace std;

typedef long long ll;
const ll MOD=998244353;
ll n;

ll fpow(ll n,ll k)
{
	ll base=n,res=1;
	while(k)
	{
		if(k&1)
		 res=res*base%MOD;
		base=base*base%MOD;
		k>>=1;
	}
	return res;
}

int main()
{
	cin>>n;
	cout<<(fpow(25LL,n-1)*26LL)%MOD<<endl;
	return 0;
}
```