当读入一个新的预约时，不断查找已经存在的预约中end值大等于新预约start值，并且最接近该start值的预约，找到一个删除一个，直到不能删除为止。因为不冲突的预约都是不相互覆盖的，所以它们的start值与end值必然是递增序列，所以一旦一个预约不能删除，后面的预约也不能删除。

这样，问题就转换成了：寻找最小的比给定的数x大的数。该问题解法非常多，这里写得非常不错：http://www.cnblogs.com/wuyiqi/archive/2011/12/25/2301071.html

当然，这个问题除了用树状数组以及平衡树，线段树也是可以做的。思想仍然是二分。本题可以做为k大数的模版题。
