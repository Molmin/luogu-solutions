## CF306B 题解

### 题目大意

给你一个长为 $n$，初始都为 $0$ 的数组。有 $m$ 次操作，每次操作将从 $a$ 开始，长度为 $l$ 的区间覆盖（即使区间上的所有数变为 $1$），为了方便，我们把这样的操作记为 $(a,l)$ 。你需要求出 $m$ 次操作中的所有“多余操作”。我们定义“多余操作”是指取消该次操作后使最终操作结果不变的操作。输出时，输出“多余操作”的数量及它们的编号，要求升序输出。

具体来讲，假设有以下操作：$ (3,3)\ (3,1)\ (4,1)\ (6,4)$。

![](https://cdn.luogu.com.cn/upload/image_hosting/b3rlmg80.png)

从图中我们可以看出，操作二和操作三是“多余操作”。首先，由操作一和操作二可以看出，有两次操作 $x$ 和 $y$， **如果 $a_x=a_y$ 并且 $l_x<l_y$**，那么操作 $x$ 是多余操作。或者说，如果一个操作完全覆盖了其他若干个操作，那么其他的所有操作都是“多余操作”。

### 解题思路

首先考虑暴力一下。对于每一次操作，看其是否被其他操作中的某一次操作完全覆盖。这种做法的复杂度肯定不能接受。我们考虑优化。

这里我介绍一种复杂度为 $ \text{O(n)} $ 的算法。

我们令 $a_i$ 为操作 $i$ 覆盖区间的左端点，$b_i$ 是右端点右边的第一个点，$l_i$ 是区间长度。由于我们读入的是 $a$ 和 $l$，所以 $b$ 的值需要计算：$b_i=a_i+l_i$。

设 $mx_i$ 是以 $i$ 为起点，最远等到达的 $b_j, j\in \{ j|a_j=i \}$。什么意思呢？举个例子。有三个操作：$ (3,3)\ (3,1)\ (4,1)$，那么 $mx_3=6, mx_4=5$。

我们考虑依次枚举区间的左端点，记为 $i$。如果没有以这个点为左端点的操作区间，则直接跳过。如果有，我们把这个点标记为“已使用”，然后枚举从 $i+1$ 枚举到 $maxs$（初始为 $mx_i$，意为可以覆盖到的最远节点的右边的第一个点），把枚举的点记为 $j$，如果 $j$ 满足以下两个条件：

- 存在以点 $j$ 为左端点的操作区间。
- $mx_j>maxs$

我们就将 $maxs$ 更新为 $mx_j$，继续向右扩展。同时，我们记录一个点 $k=j$，表示接下来我们应该去到的左端点的后面第一个点是 $k$。这样就用一个贪心的逻辑，不去使用中间“多余操作”区间的左端点了。

如果 $j$ 已经被枚举完了，但是依然没有出现更新操作，那么说明所有以 $i$ 为左端点的操作区间均没有完全覆盖其他任何区间，那么就莫得想法，继续枚举。

枚举完所有左端点后，我们得到了所有左端点是否被使用的情况，接下来，我们枚举每一次操作。如果操作 $i$ 的左端点被使用过，有两种可能：

- 如果 $b_i\neq mx_{a_i}$，说明这次操作的操作区间被完全覆盖了，即此操作为“多余操作”，我们直接输出。
- 如果 $b_i \neq mx_{a_i}$，则说明这次操作区间并没有被完全覆盖。接下来就是我个人认为全题最坑的点：有可能会有**重复操作**。显然，重复的操作只需要留下一次，其他的操作都可以删去。为了避免这种错误，我们在第一次遇到“必要操作”时将标记在端点 $a_i$ 上的标记去除。这样一来，下次扫描到一模一样的操作时，程序就会判断它是“多余操作”了。

如果操作 $i$ 的左端点没有被使用过，那么它一定就是“多余操作”，直接输出即可。

更多细节实现请看完整代码。

### 完整代码：

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
using namespace std;

const int N=2e6+1,M=2e5+1;
int n,m,cnt,hav,a[M],b[M],l[M],used[N],siz[N],mx[N];

inline int rint()
{
	int x=0,f=1; char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-') f=-1; ch=getchar();}
	while(ch>='0'&&ch<='9'){x=(x<<3)+(x<<1)+(ch^48); ch=getchar();}
	return x*f;
}

int main()
{
	n=rint(),m=rint();
	for(int i=1;i<=m;i++)
	{
		a[i]=rint(),l[i]=rint();
		b[i]=a[i]+l[i];
		siz[a[i]]++;  //这个记录的是以a[i]为左端点的操作的个数，如果siz=0，则代表没有操作 
		mx[a[i]]=max(mx[a[i]],a[i]+l[i]);
	}
		
	for(int i=1;i<=n;i++)
	{
		if(!hav) 
		{
			while(!siz[i])
				i++;
			hav=1;
		}//找到第一个有操作的左端点 
		
		used[i]=1;
		cnt++;  //做标记，记录“必要操作”的个数 
		
		int r,k=0,flg=0;
		r=mx[i];  //最远能扩展到的点最初是以i为左端点最远能覆盖到的点 
		for(int j=i+1;j<=mx[i]&&j<=n;j++)  //我们还要防止越界 
			if(siz[j]&&mx[j]>r)  //有操作且能更新右端点 
			{
				k=j;
				r=mx[j];
				flg=1;  //记录已被更新过 
			}
		
		if(flg)  //如果被更新过 
			i=k-1;  //由于存的是右端点右边的第一个点，需要-1得到新的左端点 
		else
		{
			i=mx[i]+1;
			while(!siz[i]&&i<=n+1)  //这里也是跳过没有操作的节点 
				i++;
			i--;  //+1-1的理由同上述 
		}
	}
	
	printf("%d\n",m-cnt);  //多余操作=总操作-必要操作 
	for(int i=1;i<=m;i++)
	{
		if(used[a[i]])
		{
			if(b[i]!=mx[a[i]])
				printf("%d ",i);
			else
				used[a[i]]=0;
		}
		else
			printf("%d ",i);
	}
	
	return 0;
}
```

------------

感谢阅读。