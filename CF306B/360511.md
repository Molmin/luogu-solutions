题解做法是真麻烦啊。

我们对于每个左端点，保存这个点对应的最大右端点 $mx_l$。

从小到大考虑每个左端点，左端点相同优先考虑右端点较大者。

那么显然，第一条线段肯定会被保留，不妨这条线段的右端点为 $R$，那么考虑 $R$ 之后第一个被线段覆盖的点 $i$，那么我们就需要保留一条覆盖 $i$ 的线段，由于 $(R,i)$ 之间都是没有被覆盖的，那么贪心考虑，我们只需要让这条线段右端点尽量大即可。

这个就非常好实现了，我们不去枚举线段，而是枚举每个端点，在枚举端点 $i$ 的过程中，记录 $mx_i$ 的最大值 $maxr$，当遇到第一个 $i>R$ 并且 $i$ 被线段覆盖过，那么我们就保留 $maxr$ 对应的端点即可，那么显然，我们只需要继续考虑第一个大于 $i$ 的被覆盖过的端点即可，这个和上面是一样，直接将 $R$ 改成 $maxr$ 即可。

那么我们将选的线段打上标记之后，没打过标记的线段就是要剔除的。

复杂度 $O(n+m)$。

```cpp
int main()
{
	n=read(),m=read();
	rep(i,1,m)
	{
		int l=read(),x=read();
		int r=x+l-1;
		if(mx[l]<r) mx[l]=r,id[l]=i; 
		d[l]++,d[r+1]--;
	}
	rep(i,1,n) d[i]+=d[i-1];
	int maxr=0,R=0,p=0;
	rep(i,1,n)
	{
		if(maxr<mx[i]) maxr=mx[i],p=id[i];
		if(d[i]&&i>R) flag[p]=true,R=maxr;
	}
	rep(i,1,m) if(!flag[i]) G.push_back(i);
	printf("%d\n",(int)G.size());
	for(auto x:G) printf("%d ",x);
	return 0;
}
```
