##为什么你们都这么暴力呢？？？

###结果我还是活生生地把暴力写成全部0ms。。。

好吧我必须得说这道题数据范围太小了。。。

我还如此煞费苦心地搞了优化。。。

```cpp
#include<bits/stdc++.h>

using namespace std;

int main(){
    int x;
    scanf("%d", &x);
    int i = 100; // 前三位 
    bool emp = 0;
    while(i % x != 0) i++; // 找到第一个能够被x整除的3位数 
    int qe, es; // qe代表2-3两位，es代表3-4两位（为了方便都在后面加了个0） 
    for( ; i < 300; i += x){ // 穷举前三位 
        qe = (i % 100) * 10; // 生成qe 
        for(int j = 0; j < 10; j++){ // 穷举第四位 
            if((qe + j) % x != 0) continue; // 看看2-4位能不能被x整除 
            es = (qe % 100 + j) * 10; // 生成es 
            for(int u = 0; u < 10; u++){ // 穷举最后一位 
                if((es + u) % x != 0) continue; // 和前面那个差不多的整除判定 
                printf("%d%d%d\n", i, j, u); // 输出 
                emp = 1; // 打个标记 
            }
        }
    }
    if(300 % x == 0){ // 注意！注意！这里我特判了一下30000 （30000是只用判定前三位因为它后面都是0）因为，如果前面那个改成<=的话，那么会把30000~30999都给穷举进去 
        emp = 1;
        printf("30000");
    }
    if(!emp) printf("No"); // 如果一个都没有 
}
```