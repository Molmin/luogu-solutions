需要一定理解的DP，其他题解中一般只讲了一种，这一把两种结合起来看。

------------
解题思路：

一眼看出是 DP 。

然后考虑状态，用 $f[i][j]$ 来表示跑了 $i$ 圈，其中最后一次跑了 $j$ 圈的方案数。这一种状态的转移很好想，直接枚举一个 $k$ ，然后加上可行的方案即可，即 $f[i+k][k]+=f[i][j]$ 。

这种方法是最容易想到的，也是非常好写的的一种。

然后就过了。。。

连优化都没有。。。

------------

但如果我们加强一下数据呢？

将 $n$ 的范围扩大至 $10^4$ ，此时 $n^2$ 的复杂度并没有超过 $1s$ 限制，而空间出了问题，$10^8$ 的空间是肯定开不下的。

（当然如果真这样改可能会加一个取模，不然就要高精了）

考虑优化，可以通过改变枚举的顺序的方式来将空间复杂度压缩至线性。


------------

先不要往下看，自主思考一下
------------

其实在上一种做法中，枚举的 j 是需要每一次从之前的可行解中转移过来，如果换一种枚举方式将枚举的i直接作为答案就好了。

那么我们就可以将枚举的单次跑步圈数改为对于每一个总圈数都是递增的，也就是对于当前的 $i$ ，拓展到 $i$ 的所有值都是最大圈数比 $i$ 小的。这一种方式的实现比较简单的是先枚举跑的圈数然后在通过从后往前枚举要跑的总圈数来实现转移。

具体的方程为：$f[j]+=f[j-i]$，其中 $i$ 为当前跑的圈数，$j$ （好像说过了 $QAQ$ ）。

------------
代码

```cpp
#include<cstdio>
using namespace std;
long long n,f[505];
int main(){
    scanf("%lld",&n);
    f[0]=1;
    for(int i=1;i<=n;i++)
    for(int j=n;j>=i;j--)
	f[j]+=f[j-i];
    printf("%d",f[n]-1);
    return 0;
}
```
------------

如前，首先枚举跑的圈数 $i$ ，然后对于每一个圈数进行转移，其中，因为跑的圈数线性递增，所以所有可能的解都是满足跑的圈数递增的。

最后注意一点，j是要从后往前枚举的。
