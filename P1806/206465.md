## 做法1：暴力 DFS -- 50分
在比赛中，会做的题当然要尽可能拿到满分，而对于其他题目，尽量拿到部分分也是一种应试技巧。并且，很多时候部分分的解经过一定的分析和优化后就能成为正解。

该题只需用模拟的思想，在保证每一次跑步的长度都大于前一次的基础上，穷举所有可能的跑法即可。

主要DFS 函数如下：
```cpp
void dfs(int step,int sum)
{
	if(sum==n)
	{
		ans++;
		return;
	}
	if(step+sum>n)
		return;
	for(int i=step+1;i<=n-step;i++)
	{
		dfs(i,sum+i);
	}
}
```
这里的 
```cpp
for(int i=step+1;i<=n-step;i++)

```
实际上还渗透了一些剪枝的思想：题目中要求每一次圈数不少于上一次，所以若现在的圈数比剩下的圈数还多，就没必要继续搜索下去了。这样的剪枝操作一般不会改变算法复杂度，但是能使运行时间得到一定减小。

但是提交上去之后，你会发现~~意料之中地~~只得了 50pts。

注意到题目的数据范围为 $5 \leq n \leq 500$ ，而我们的 DFS 算法复杂度为 $O(n^n)$ ，并且递归调用函数还会造成额外的时空消耗，对于这个数据范围来说还是太慢了。
## 做法2：DP -- AC
再次仔细思考跑步的过程，其实模拟的过程可以不必用 DFS 这么暴力的做法。

**可以每一次模拟后，用一个数组储存 到第 $n$ 圈的所有可能跑法有 $dp(n)$ 种**，这样每一次模拟都可以在上一次的基础上进行操作。问题规模逐步缩小，复杂度被降为了 $O(n^2)$ ，并且没有使用时间成本较高的函数递归，所以通过本题自然就十分轻松。

核心代码：
```cpp
dp[0]=1;
for(int i=1;i<=n;i++)
{
	for(int j=n;j>=i;j--)
	{
		dp[j]+=dp[j-i];
	}
}
cout << dp[n]-1;
```
这里出现了一个本题的小坑点：按照题目要求，存储状态的数组应被初始化为 $dp(0) = 0$ ,然而，如果真的这么做，就会发现不论你输入什么，输出都会是 0。自己手动算两个循环就会发现 $dp(0) = 0$ 会使 $dp(j) = dp(j) + dp(j-i)$ 这个式子没有计算意义。

正确的方法是初始化时采用 $dp(0)=1$ ，保证式子可以正常计算。计算完成输出结果时输出 $dp(n)-1$ 即可。

~~答案算出来会很大，记得开 ```long long```~~

### 备注：
> 做法1的 DFS 算法复杂度分析参考了 @zhangbinsai 题解中的结论：[传送门](https://www.luogu.com.cn/blog/wgyangzhuhezuoshe/solution-p1806)

~~第一篇题解祭~~