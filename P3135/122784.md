#### 题目
[P3135 [USACO16JAN]Fort Moo P](https://www.luogu.com.cn/problem/P3135)   
>观前提示：**贪心的暴力可过此题**，且速度或比正解更快，但正解思想更加优秀。  
  
#### 前置内容  
[更好的阅读体验](https://www.luogu.com.cn/blog/bluecyw/solution-p3135)    

本题是 [最大子段和](https://www.luogu.com.cn/problem/P1115) 的一个**扩展**。  
#### 思路  
**先看数据范围。**  
$$1\le n,m\le200 $$  
可以想到 ${O(N^{3})}$ 的时间复杂度可以通过此题。  
>注：贪心的暴力可以通过此题的原因是**较难造出能让贪心跑满的数据**，而正解却是跑满了 ${O(N^{3})}$ 。 
  
联想到**最大子段和**的做法：  
>从第一个数开始选择，每加入一个数都记录最大值，若当前数和小于零，则将数和清零。   

通过这样的做法，我们避免了枚举左端和枚举右端的 ${O(N^{2})}$ 的低效做法，我们需要思考的是，这样**为何更优**？   

我们这里不从 DP 的角度来分析。   

考虑这样一个有穷数列：  
```cpp
i= 1 2 3 4 5  6
   2 3 1 5 2 -20
```
假如我们使用**暴力的解法**：   
- 从第一个数开始，遇上 ${-20}$ 时数和为零，该子段和对于后面的字段和无用，清零。  
- 从第二个数开始，遇上 ${-20}$ 时数和为零，该子段和对于后面的字段和无用，清零。  
- ……   

可以发现，从第 ${1}$ 个数加到第 ${5}$ 数的过程中，数和都不为零。  
这样一来，以 ${2—5}$ 中的任何数作为起点都**无法对答案产生贡献**。  
那么我们将这一段操作删去，便优化了时间复杂度。   

---
回到本题  

考虑这样一个情况：  
我们确定了**子矩形的上边和下边**（没有具体确定长度）。  
>注，红色表示平地，黄色表示沼泽。  
  
  
![](https://cdn.luogu.com.cn/upload/image_hosting/1totypsy.png)
- 通过查询**上下点的地图情况**，判断是否能作为矩形的上下边的一部分。  
- 通过判断**每个点向上延伸的最大距离**，判断是否能作为矩形的左边框或右边框。    

例如上图，我们确定了上边和下边，发现第一列和第三，四列可以构成一个矩形。  
>那么还有无第三列作为从左边向右寻找的必要呢？  
>**没有必要**，因为第一列转移到第三列的过程中**没有发生阻断**，所以以第一列为左端点必然比第三列优。  

于是优秀的解法产生了。~~虽然跑不过贪心~~  

#### 解法  
>两层循环枚举起始行和中止行，预处理列的连通性。
>一层循环做dp:

>如果这两行中间的某一列是连通的，说明它有成为一堵纵向墙的资格。

>如果随着列的枚举，这两行的连通性被破坏(之间建不成横向墙)，那么前面的纵向墙就作废。

>如果一堵纵向墙前面还有另一堵未被作废的纵向墙，那么可用来更新答案。  
>--[潜翎](https://www.luogu.com.cn/user/101526)    
  
  
#### Code  
```cpp
#include <bits/stdc++.h>
using namespace std;
int n,m;
int a[205][205];
int d[205][205];
int ans;
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++){
		char s[205];scanf("%s",s+1);
		for(int j=1;j<=m;j++){
			if(s[j]=='.')
				d[i][j]=d[i-1][j]+1; //记录向上延伸的平地数量 
			else 
				a[i][j]=1;//标记该点为沼泽 
		}
	}
	for(int i=1;i<n;i++)//枚举上边 
	
		for(int j=i+1;j<=n;j++){//枚举下边 
		
			int res=0;//记录但前选择了的列数（连续的） 
			int h=j-i+1;//表示当前矩阵的高 
			
			for(int k=1;k<=m;k++){//从左到右枚举每一列
			
				if(a[i][k]||a[j][k]) {
					/*
					此时上下至少有一点为沼泽，连通性被破坏
					那么无论我们当前是否找到左边框，res都要清零
					*/
					res=0; 
					continue;
				}
				
				/*
				不连通的情况已经continue，处理到这里的都连通的情况 
				那么无论如何选择的列数都会加一
				*/ 
				res++;
				if(res==1){//之前没有找到左边框，尝试当前列 
					if(d[j][k]>=h)  
						continue;//上下连通，可以作为边框
					else 
						res=0;//没有左边框，无法开始选择 
				}
				else{//已经找到了左边框，寻找右边框 
					if(d[j][k]>=h)
						//找到一个可能的右边框（不一定最优
						ans=max(ans,res*h); 
					else
						continue;
				}
			}
		}
		
	printf("%d\n",ans); 
} 
```