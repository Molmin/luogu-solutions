我该说什么呢，好好的一道题你偏把模数弄到炸 `long long` ……

这题还真的是，我在洛谷这里交了，一直在 Waiting 。后来我跑到 spoj 上，才发现是因为代码过长，这题有个码量的限制在 $500$ 个字节？？？

所以 C++ 的高精度应该是没法评测了，但我还是想介绍一下**如何用较简单的高精度写出这道题**。

---

首先，因为 $\sum \limits_{i=0}^n 2^i$ 可以理解为一个 $n$ 位的每一位都是 $1$ 的二进制数，也就是再加一就进位到下一位了，所以答案即为 $2^{n+1}-1$ 。可以用快速幂算，没有问题。

然后看到模数， $1298074214633706835075030044377087$ ，第 $14$ 个卡罗尔质数，很大很大，大到 `unsigned long long` 都装不下。

好家伙，谁想写高精模高精啊。

那么考虑不用快速幂了，我每次就乘一个 $2$ ，反正它超时不了。 $100$ 毫秒就 $100$ 毫秒， $500*50$ 怕什么（注：$50$是指运算时的位数，只是一个大概的值，往大估了，事实上应该最多 $36$ 位左右）。后来我用 Python 3 亲测不会超时，而且毕竟 C++ 常数比 python 小，没有道理超时。

**因为每次只是 $\times2$ 的话，结果会严格小于模数的两倍，所以只用判断如果大于等于模数就减去模数即可。（不用写高精除啦！）**

那么剩下的就是高精减法和高精乘单精，就比较简单啦。

---

代码毕竟提交不了就不贴了，再次吐槽这什么鬼东西还有代码长度限制。