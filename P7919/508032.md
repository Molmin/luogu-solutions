# 前言
月赛时没想，现在才发现这题其实不难。

没错，这又是一道让人误以为是动态规划的贪心绿题。

这次题解不是很好讲，如果没看懂，可以先看看代码。
# Solution
### 1、关于 $pA$、$pB$、$pC$
题目中说它们可以相等，然而，我们发现：

如果 $pA$、$pB$、$pC$ 有相等，不仅无法使任何一组相邻的两个字母变得不同，反而可能让本来不同的相邻字母变得相同。

**所以我们就让 $pA$、$pB$、$pC$ 都互不相同。**

### 2、最短操作次数
即使 $pA$、$pB$、$pC$ 都互不相同，对 $[l,r]$ 区间的相邻字母，相同与否情况也不会有任何改变。只能改变 $(l-1,l)$ 和 $(r,r+1)$。

**所以每次能减少两个相邻相同对。**
### 3、解决方法
根据前文的推导，我们的每次改变都可以设为 $pA=\text{B}$、$pB=\text{C}$、$pC=\text{A}$。

再说 $l$ 和 $r$：

先整体循环，在每次循环中用两个 $\text{for}$ 或者 $\text{while}$ 来寻找相邻相同对，一前一后。$l$ 和 $r$ 就设在这两个地方。

如果 $l$ 到达结尾，就可以退出大循环输出答案了。

# AC代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,i,j=-1,ans,a[2][5006];char s[5003];
int main()
{
	cin>>n;
	scanf("%s",s);
	for(;;)
	{
		i=j+1;
		while(s[i]!=s[i+1]&&i<n-1) {i++;} //寻找l的位置
		if(i>=n-1) break; //到底了,退出循环
		j=i+1;
		while(s[j]!=s[j+1]&&j<n-1) {j++;} //寻找r的位置                         
		ans++;a[0][ans]=i+2;a[1][ans]=j+1;
	}
	cout<<ans<<endl;
	for(i=1;i<=ans;i++) cout<<a[0][i]<<" "<<a[1][i]<<" BCA\n";
	return 0;
} 
```
# 后记
输入时千万不要连用 $\text{getchar()}$，最好也不要用字符串 $\text{cin}$。