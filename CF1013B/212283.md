先简单说明一个引理：$a\text{ and }b=a\text{ and }b\text{ and }b$。

对于两者中存在一个 $0$ 的情况，进行无数次与运算结果都不会变成 $1$，同理，如果两者都是 $1$，则运算结果恒为 $1$。对于每一个位考虑如此，对于整个数而言便也是如此，由此可以得出结论，$a$ 与上 $b$ 无论运算多少次，答案都和与一次一样。

那么将 $a_i$ 中的数每个都和 $x$ 进行依次与运算，之后判断是否存在相同数即可。

考虑运算个数。

- 若原数组本来就有重复，则无需操作，输出 $0$。
- 若某个数操作过后与原数组中另一个数重复，则只需要操作一次输出 $1$。
- 若某两个数在操作过后有相等，则需要将这两个数分别操作，输出 $2$。
- 否则输出 $-1$。

有什么值得注意的呢？

首先显然，如果某个数**操作过后没有变化，那这个数肯定是没有用的**，否则在第一轮筛查的时候就会发现了。我们来思考如果没有进行这样的判断会出现怎样的情况：“我”进行与运算之后和“我”相同，于是输出了 $1$——而这显然是不符合条件的。

你或许会想到通过排序进行计数，这样有两个问题：

- 操作过后的数组和原数组不方便进行比对。
- 时间复杂度 $O(n\log n)$ 不够优秀。

显然，$a_i\le 10^5$ 的数量级足够我们开一个桶进行记录，不过需要注意的是，在进行操作后数组比对之前，要重新清空桶。

这里给出代码实现：

```cpp
#include<bits/stdc++.h>
#define N 100005 
using namespace std;
int n,x,a[N],axor[N],t[N];
signed main(){
	scanf("%d%d",&n,&x);
	for(int i=1;i<=n;i++){
		scanf("%d",&a[i]);t[a[i]]++;
		if(t[a[i]]>1){puts("0");return 0;}
	}for(int i=1;i<=n;i++){
		axor[i]=a[i]&x;
		if(axor[i]!=a[i]&&t[axor[i]]){puts("1");return 0;}
	}memset(t,0,sizeof t);
	for(int i=1;i<=n;i++){
		t[axor[i]]++;
		if(t[axor[i]]>1){puts("2");return 0;}
	}puts("-1");return 0;
} 
```
