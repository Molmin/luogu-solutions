没有什么想法，先考虑想最优化问题来观察性质，最优的会是最左边的 $1$ 去换最右边的 $0$，虽然这并没有什么鬼用，但是我们发现，有一些 $1$ 和 $0$ 是交换是对最优方案做负贡献的，进一步的，我们发现，令全局有 $a$ 个 $0$，那么，只有移动前 $a$ 个里面的 $1$ 和后面 $n-a$ 个 $1$ 里面的 $0$，才有用，而移动这两边内部的 $1$ 和 $0$ 改变前 $a$ 个里面 $1$ 的个数，换句话说即使交换了内部的 $1$ 和 $0$ 之后，对最优策略的交换次数没用作用。

这启发我们只关注前面 $a$ 个中 $1$ 的个数，进一步的，容易发现前 $a$ 个中的 $1$ 是独立的，所以我们可以由此来得到答案的式子，前面还有 $i$ 个 $1$ 时，取有效操作的概率为 $\dfrac{i^2}{\binom{n}{2}}$，期望即为 $\dfrac{\binom{n}{2}}{i^2}$，故答案即为 $\sum\limits_{i=1}^{a}{\dfrac{\binom{n}{2}}{i^2}}$，不计求逆元时间复杂度为 $\mathcal{O}(n)$。

```cpp
int main() {
	read(n);
	int cnt = 0;ans = 0;
	for (int i = 1;i <= n;++i)read(a[i]),cnt += (a[i] == 0);
	int c = 0;
	for (int i = 1;i <= cnt;++i)if (a[i] == 1)++c;
	for (int i = 1;i <= c;++i)ans = (ans+1ll*n*(n-1)/2%mod*power(1ll*i*i%mod,mod-2)%mod)%mod;
	printf("%d\n",ans);
	return 0;
}
```