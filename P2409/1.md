解法1

令f[i][j]为前i行，总和为j的方案数。

f[i]可以由f[i-1]递推得到。由于很难说明，我们用一个例子代替说明。

```cpp
j     1  2  3  4  5  6  7  8  9  10 11 12 13 14
f[1]  1     1  1  1
-----------------------------------------------
f[1]往右移7格              1     1  1  1
f[1]往右移9格                    1     1  1  1
f[2]为上面两行加起来       1     2  1  2  1  1
```
依此类推。

由于最多100盒，每个最大100，所以j最多10000。

当然，我们没有必要设置f[100][100000]这么大，使用滚动数组就可以了。

算法复杂度O(sum\*n\*m)

可能有点大。但是考虑到，最大值每次最多增加100，所以可以做常数优化。实际上就算不用也可以ac。


如果数据范围是k比较小而每个数字比较大，那么可以用堆维护前k个最小和。得到的教训是，不同的算法，应用在不同的数据范围上。


Claris提供了一种二分sum值，然后搜索剪枝，虽然玄学复杂度不过也可以通过这道题。
