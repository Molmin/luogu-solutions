## 题意描述
给定一个带有不定字符 $?$ 的字符串 $s$，和一个匹配串 $t$，可以将 $?$ 替换为任何字符。要求给出一种替换方案，使得在所有替换方案中，将字符串 $s$ 进行一定的排列后，该方案得到的**不相交子串** $t$ 数量最多。
## 题目分析
这道题目肯定是要贪心考虑，在所有的替换方案中，最后字符串 $s$ 中含有的字符比例越接近字符串 $t$ 中含有的字符比例，得到的子串 $t$ 的数量越多。

分别统计 $s,t$ 中含有的字符的出现次数 $nums,numt$。对于每次填完后，$s$ 中子串 $t$ 出现的次数最多为：令字符 $c$ 为出现在 $t$ 中的字符中，$\frac{nums_c}{numt_c}$ 最小的字符，此时只需将 $?$ 改为字符 $c$ 即可。
## Code
```cpp
string s,t;
int numt[26],nums[26];//如前文所示，nums表示字符在s中出现次数，numt表示字符在t中出现次数
signed main(){
    cin>>s;
    cin>>t;
    for(int i=0;i<t.size();i++){//先统计字符在t中出现次数
        numt[t[i]-'a']++;
    }
    for(int i=0;i<s.size();i++){//统计非?字符在s中出现次数
        if(s[i]=='?'){
            continue;
        }
        nums[s[i]-'a']++;
    }
    for(int i=0;i<s.size();i++){//依次修改每个?字符
        if(s[i]!='?'){
            continue;
        }
        int mn=1e9,num=0;
        for(int j=0;j<26;j++){
            if(mn*numt[j]>nums[j]){
            //因为为了防止出现除0的情况，将除法变为乘法，这样就不会出现修改numt[j]为0的字符
                num=j;
                mn=nums[j]/numt[j];
            }
        }//寻找nums[j]：numt[j]最小的字符
        s[i]=num+'a';
        nums[num]++;
    }
    cout<<s<<endl;
    return 0;
}
```
## 扩展
若将题目中不相交的字符串 $t$ 改为可以相交的字符串 $t$，该怎么办呢？

令 $t'$ 为字符串 $t$ 进行 `kmp` 匹配后的 `border` ，$T$ 为 $t$ 尾部去掉 $t;$ 后的字符串，那么 $s$ 排列后的字符串 $s'$ 必然为 $T+T+...+T+t'+other$。所以可以先做一遍 `kmp`，求出 $t'$，先填满一个 $t'$，随后在 $t'$ 从 $t$ 中去掉，将新字符串作为上文的 $t$，贪心跑即可。