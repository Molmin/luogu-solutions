## 贪心


------------
读题，抽象出来就是：

给定一个正整数$n$，

求**至少**需要多少个斐波那契数才能使其和等于$n$

斐波那契数**可以重复使用**

------------
我们一开始想到的方法应该是完全背包

但是，转念一想，能不能贪心呢？

事实上，能！

贪心的方法：

**尽可能多的选最大的数，再考虑次大的数**

直到无法再选

------------
为什么呢？

考虑一下斐波那契数列的性质，有这么一条：

**对于数列中的任意一项$F(i)$，$F(i)$总能由其余项求和或求差得到**

那假如现在有$F(i)$<$n$ 
             
我们要不要改为选$F(i-1)$呢？

换句话说，选$F(i-1)$会不会得到优于$F(i)$的解呢？

不会。因为如果我们改为选$F(i-1)$，那还差$F(i)$-$F(i-1)$

这意味着我们至少又要选一个数来“弥补”空缺

**显然$k$的值会更大**


------------
故本题可以用贪心解决

首先用递推预处理出斐波那契数列

然后贪心**从大到小**选数（也就是**逆序遍历**）

能选就ans++

------------
代码如下：
```cpp
#include<iostream> 
#include<cstdio>
#define maxn 1001
#define ll long long//宏定义ll 省事
using namespace std;
ll a[maxn];//存储斐波那契数列
int main(){
	ll n,x=2,t,ans=0;//注意数据范围要用long long
	a[0]=0;//递推初始化
	a[1]=1;//
	cin>>n;
	while(1){//递推
		a[x]=a[x-1]+a[x-2];
		if(a[x]>n) break;//大于n就不用再推了
		++x;
	}
	t=n;//代替n作为循环条件
	for(register ll i=x-1;i>0;--i){//逆序遍历斐波那契数列
		while(n-a[i]>=0){//只要还能选就可着劲的选
			ans++;
			n-=a[i];
		}
	}
	cout<<ans<<endl;//千万要输出换行！！！否则会爆
	return 0;
}
```
