[题目传送门](https://www.luogu.org/problem/CF1207B)

题目大意：给出一个n行m列的01矩阵（即目标矩阵），原始矩阵也为n行m列的01矩阵且所有元素都为0，每次可以选择一个点(x,y)，$1\le x\le n-1,1\le y\le m-1$，将点(x,y),(x+1,y),(x,y+1),(x+1,y+1)变为1，问是否可以通过若干次操作到达目标矩阵，若不能，输出-1，若可以，则输出到达目标矩阵的步数k和每步进行操作的点的坐标，注意，k不需要最小，k不应超过2500。

因为n,m小于等于50，而k最大为2500，所以我们可以给每个点都进行一次操作，~~也就是可以乱搞~~。我们用一个变量s记录原始矩阵应变为1但还没变为1的元素的数量，二位数组a记录目标矩阵，b记录原始矩阵的每个点是否被操作过，c记录原始矩阵当前的状态。

只要s大于0，就扫一遍原始矩阵，若找到一个点没被操作过，并且该点进行操作后和目标矩阵吻合（就是会被改动的点在目标矩阵中都为1），就进行操作并记录，若找不到这样一个点就输出-1，最后输出即可。

代码：
```
#include<bits/stdc++.h>
using namespace std;
int n,m,a[55][55],b[55][55],c[55][55],k,x[2505],y[2505],s;//x,y记录每次操作的点的坐标
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)for(int j=1;j<=m;j++){scanf("%d",&a[i][j]);if(a[i][j]==1){s++;}}//记录s
	while(s)
	{
		k++;
		bool bb=0;
		for(int i=1;i<n;i++)
		{
			for(int j=1;j<m;j++)
			{
				if(a[i][j] && a[i+1][j] && a[i][j+1] && a[i+1][j+1] && b[i][j]==0)//如果该点可以进行操作就操作
				{
					x[k]=i;//记录该点坐标
					y[k]=j;
					b[i][j]=1;
					if(c[i][j]==0)s--;//如果被改动的点原来是零就将s--
					if(c[i+1][j]==0)s--;
					if(c[i][j+1]==0)s--;
					if(c[i+1][j+1]==0)s--;
					c[i][j]=c[i+1][j]=c[i][j+1]=c[i+1][j+1]=1;//全部改成1
					bb=1;
					break;
				}
			}
			if(bb)break;
		}
		if(!bb){printf("-1");return 0;}//如果无法进行操作就输出-1
	}
	printf("%d\n",k);//输出
	for(int i=1;i<=k;i++)printf("%d %d\n",x[i],y[i]);
}
```
![](https://www.luogu.org/images/congratulation.png)