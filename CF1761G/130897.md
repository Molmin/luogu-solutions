注：该题解源自 https://codeforces.com/blog/entry/109256?#comment-974593。

利用询问，我们希望还原出结点间的一部分位置关系，继而求出重心的标号。

考虑某一条链 $S\sim T$ 和一个结点 $u$。通过询问 $\text{dis}(S,T),\text{dis}(S,u)$ 以及 $\text{dis}(u,T)$，我们可以得知 $u$ 相对于 $S\sim T$ 的位置关系。具体地，我们可以知道 $u$ 在 $S\sim T$ 链上的投影。我们将 $S\sim T$ 链上的结点依次用 $0,1,\cdots,\text{dis}(S,T)$ 编号，那么 $u$ 在 $S\sim T$ 上的投影编号就是 $\dfrac{\text{dis}(S,T)+\text{dis}(S,u)-\text{dis}(u,T)}2$。根据投影的编号，可以将 $u$ 划分为 $\text{dis}(S,T)+1$ 类。

注意到如果我们掌握了任意一条重心所在的链 $S\sim T$，我们就可以在 $2n$ 次询问内确切地求出重心：利用刚才的方法，将所有结点划分为 $\text{dis}(S,T)+1$ 类。以类别的大小为权值，重心就是这条链的带权中位数。对于一个 $u$ 来说，若 $\text{dis}(S,u)+\text{dis}(u,T)=\text{dis}(S,T)$ 则说明 $u$ 就在 $S\sim T$ 上。返回带权中位数那个链上结点即可。

因此我们需要用 $\leq5\times10^4$ 次询问确定一条重心所在的链 $S\sim T$。若重心不在 $S\sim T$ 上，我们硬要对 $S\sim T$ 跑刚才的算法，会发现有一个类特别地大。具体地，由于重心所在的子树至少有 $\dfrac n2$ 个结点，因此重心所在的类将至少包含 $\dfrac n2+1$ 个结点。从该类中随机挑出一个结点 $u$，则 $u$ 有 $\geq\dfrac12$ 概率处在重心的子树里。这说明 $S\sim u$ 包含重心的概率 $\geq\dfrac12$。因此，将 $S\sim T$ 调整成 $S\sim u$，有 $\geq\dfrac12$ 概率得到一条重心所在的链。

我们希望重复以上流程，直到找到一条符合要求的链为止。然而上述过程太过昂贵了！利用随机化，我们可以将上述过程变得更便宜。具体地，我们可以随机采样 $157$ 个点并确定其分类，留意包含 $\geq79$（而不是原先的 $\dfrac n2+1$）个采样点的类。若重心不在 $S\sim T$ 上，这样的类有 $\geq\dfrac12$ 概率会出现。只要出现，就从该类中随机挑出一个采样点 $u$，则 $u$ 有 $\geq\dfrac12$ 概率处在重心的子树里。那么，将 $S\sim T$ 调整成 $S\sim u$，有 $\geq\dfrac14$ 概率得到一条重心所在的链。多次重复以上流程，几乎一定能够得到一条重心所在的链。

然而该流程的前提是重心不在 $S\sim T$ 上。若重心本就在 $S\sim T$ 上，上述流程可能会将好端端的 $S\sim T$ 给丢掉！所幸这个问题有办法解决。解决方案是利用将 $S\sim T$ 替换为 $S\sim u$ 还是 $u\sim T$ 的自由度。为了尽可能地留住重心，我们考察 $u$ 的投影左侧和右侧的采样点哪个更多。若左侧更多就将 $S\sim T$ 替换为 $S\sim u$，右侧则是 $u\sim T$。这样一来，只要重心所在的子树里有 $\geq40$ 个采样点就一定能被留住（这大约有 $1-\dfrac1{5\times10^9}$ 的概率）。

综上所述，以任意 $S\sim T$ 为初值重复以上流程 $157$ 次，经过迭代之后几乎一定能够得到一条重心所在的链。

设允许的错误率为 $\varepsilon$，则该算法所需要的询问次数是 $2n+\mathcal{O}(\log^2\dfrac1\varepsilon)$。

附代码：https://www.luogu.com.cn/paste/5sg8vyoi。