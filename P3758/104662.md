首先看到这个题，感觉非常不可做……

然后尝试写了个暴力。

由于这个题的$n$不是很大，所以我们采用邻接矩阵来存储图的关系。

而且对于停在原地可以将它看成自环；对于自爆可以虚拟出一个节点$0$，使每个节点都向它连有边，而它只向自己连有边。

对于第$i$秒之后到达$j$节点的方案数$dp[i][j]$，有状态转移方程$dp[i][j]=\sum\limits_{k=0}^ndp[i-1][k]*mp[k][j]$。

然鹅这样复杂度为$O(t*n^2)$，理论上来讲可能会被卡掉，那我们想想有没有更优的做法呢？

其实这题的主要卡点在于，$t$太大了，只要复杂度里带上了$t$，就有可能被卡掉。

那有没有比$O(t)$更快的复杂度呢？

$O(\log t)$！

于是我们来想想带$\log$的算法。

树状数组？线段树？平衡树？~~显然不是~~

二分查找？二分答案？堆？~~那更不可能了~~

于是我们想到了分治！

然后我们可以令$mdp[i][j][k]$为经过$i$秒从$j$走到$k$的方案数。

则$mdp[i][j][k]=\sum\limits_{l=0}^nmdp[i-x][j][l]*mdp[x][l][k]$（其中$x$为任意常数）。

且$mdp[1][i][j]=mp[i][j]$。

所求结果就是$\sum\limits_{i=0}^nmdp[t][1][i]$。

然后我们就可以利用分治求解了。

具体代码我就不上了，毕竟这题不难实现，而且这里主要讲思想。