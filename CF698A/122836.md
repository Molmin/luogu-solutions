题解区怎么清一色的 $\verb!DP!$……

提供一种分类讨论的做法。

我们令 $\verb!lday!(0/1/2)$ 为我们上一天在做什么（$0$ 为休息，$1$ 为比赛，$2$ 为健身）。

1. 如果这一天无事可做。  
显然直接令 $\verb!lday!$ 为 $0$ 并增加答案。
2. 如果这一天可以做一件事情。  
如果这一天和上一天的状态不同，那么更新状态，否则强制令这一天休息。  
为什么这样类似于贪心的策略是对的？  
如果相邻两天的状态相同，显然我们只能取其中一天，而如果我们让前面一天做事情而后面一天休息，对更加后面的日子而言，可以做的事情更多。
3. 如果这一天两件事情都可以做。  
这种情况我们继续分类讨论。  
3.1. 如果上一天做了事情，这一天直接和上一天做的不一样就可以了。  
3.2. 如果上一天没有做事情，我们假装这一天也没有做事情。  
第一条很好理解，但为什么第二条是对的？  
考虑第二种情况只可能发生在这样的区间中：  
`...0 3 3 3 3 3 3.... ` （注意第一个 $0$ 并不是原序列中的 $0$，而是指在那一天休息)。  
在这种情况下，我们可以任意钦定第一个 $3$ 做的事情，那么最后一个 $3$ 做的事情也是可以由我们决定的。  
因此这种情况下后面要做什么事情不会影响答案，因为我可以任意指定我要最后一个 $3$ 所做的事情——相当于我们在“休息”。

可能有点抽象，可以结合代码理解：
```cpp
#include<bits/stdc++.h>
using namespace std;
int lday,n,a[100005],res;
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>a[i];
	}
	for(int i=1;i<=n;i++)
	{
		if(a[i]==0)
		{
			res++;
			lday=0;
		}
		if(a[i]==1)
		{
			if(lday==1)
			{
				res++;
				lday=0;
			}
			else
			{
				lday=1;
			}
		}
		if(a[i]==2)
		{
			if(lday==2)
			{
				res++;
				lday=0;
			}
			else
			{
				lday=2;
			}
		}
		if(a[i]==3)
		{
			if(lday!=0)
			{
				lday=lday==1?2:1;// 原先是0不用动，否则切换状态
			}
		}
	}
	cout<<res;
}
```
