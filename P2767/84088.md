首先声明下这篇题解不并是我独立完成的，主要参考的是[sxd666888](https://www.luogu.org/space/show?uid=84156)大佬的idea并在他的协助下完成的。

### $O(n^4)$算法

令$dp[i]$表示用$i$个不同的节点构成$m$叉树的数量。我们发现好像无法转移，于是考虑另设$dpp[j][k]$表示根节点有$j$个儿子，子树大小为$k$的方案数。易得$dpp[j][k] = \sum_{l = 0}^{k - 1}dp[l]\times dpp[j-1][k-l]$，也就是说在一棵树的根节点上接上一棵$m$叉树。最后我们有$dp[i] = dpp[m][i]$。

### $O(n^3)$算法

状态定义和$O(n^4)$算法不多，只是$dpp[i][j]$把根节点给去掉了，即定义了由$i$个$j$叉树构成的森林，然后直接同卡特兰数那样大力接上去就可以了：`dpp[i][j] += dp[k] * dpp[i-k][j-1]`。

当然最后是$dp[i+1] = dp[m][i]$。

### 更好的做法

首先，我们有一个猜想：

给定一个有自然数构成的长度为$n$的序列$\{a\}$，若$\sum a_i=n-1$，则有且仅有一个$I$使得可以产生一个正整数（除最后一个为$0$）构成的长度为$n$的序列$\{b\}$：

$$b_i=\sum_{j = 1}^{i} a_{(j+I-2)\% n+1}-i+1$$

比如说这样一个序列：

```plain
3 0 0 0 0 2
```

我们有且仅有一个$I=5$使得产生合法$b$的序列：

```plain
2 4 3 2 1 0
```

然后我们来证明它：

所有序列$\{a\}$，当$I = 1$时，所产生的$\{b\}$序列都类似下面这样的图：

![](https://cdn.luogu.com.cn/upload/pic/50592.png)

可以发现的是，当我们选$I = x(x \not = 1)$时，$0$线会移到当前$b_x$所在位置，并且从$x+1\sim n$和$1$的点会上升$1$。

因此，当且仅当选$I$为最近的处在最低谷的点的位置时，产生的$\{b\}$合法。

然后我们需要把这个结论和树联系起来。

我们给一棵树记录一次$\text{dfs}$，我们先把儿子节点入栈，遍历完后将其出栈，这样子，我们对于一个序列$\{a\}$，${a_i}$表示的是第$i$个节点有几个儿子。

我们每次遍历到一个节点时先将它出栈（$-1$），再把它的儿子入栈（$+a_i$），当前栈里元素个数就是${b_i}$，即能拓展点的个数。最终就得到了$\{b\}$序列。如果中途中途出现小于等于$0$的数，那么下一个节点就不知道在哪了，不符合树的定义。

因为题中是$m$叉树，所以连接儿子的边的选择会影响
方案数，因此序列$\{a\}$中每个数的大小不超过m，总共有$n\times m$条边，从中选出$n-1$条,并用下图构成序列$\{a\}$。

![](https://cdn.luogu.com.cn/upload/pic/50594.png)

而构成的序列$\{a\}$中，只有$\frac{1}{n}$的方案是可行的，因此得出公式：

$$ans = \frac{C_{n\times m}^{n-1}}{n}$$

