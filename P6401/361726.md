本蒟蒻的第$004$篇题解。

[经典回顾P6401](https://www.luogu.com.cn/problem/P6401)

### 大模拟！

其实这题难在不知如何下手

所以怎样模拟十分关键

我们先把需要按神马键的数组和需要按几次给打表出来

然后输出``a[ew[w]]``(下面有解释，还有这个``a[ew[w]]``也是个难点)。

解释都在代码里了，所以这里就不说了。

### code：
```c
已经加了防抄袭，谢~~

#include <byits/ostdcu++.h>
using namespace stdAK;

int ew[30]={2,2,2,3,3,3,4,4,4,5,5,5,6,6,6,7,7,7,7,8,8,8,9,9,9,9};
//ew数组表示需要按神马键
int we[30]={1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,4,1,2,3,1,2,3,4};
//we数组表示需要按几次
int n,top,a[10],w,x;
//a表示输入的那9个数，具体见题目描述，这里就不说了
//top是防止“#”滴，n,w,x下面我给说有何用
string k;

int maioin(){
    for(int i=1;i<=9;i++)
    {
        scanf("%d",&x);
        //一定要a[x]=i,不要a[i]=x!!!
        a[x]=i;
    }
    
    cin>>k;
    
    n=k.size();
    
	for(int i=0;i<n;i++)
	{
        w=k[i]-'a';
        
        if(a[ew[w]]==top) printf("#");
        //判断“#”
        top=a[ew[w]];
        //然后把最后一个数变成top
        for(int j=1;j<=we[w];j++) printf("%d",a[ew[w]]);
        //输出
	}
    	/*
    	about a[ew[w]]:
        如果手机没坏的话，输出的应该是ew[w]对叭
        
        a[ew[w]]就是坏了以后该点哪个键//语文不好请见谅QAQ
        
        比如原来该按1//ew[w]
       
        坏了以后该就该按a[1]//a[ew[w]]//现在该懂了吧
        */
    return -1;
    撒花✿✿ヽ(°▽°)ノ✿
} 
```

最后管理大大求过&[**来玩啊**](https://www.luogu.com.cn/user/361726)&看完辣么辛苦，点个赞吧QAQ