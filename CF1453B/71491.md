说句闲话，好久没有看到过这么难的div2B题了(个人感觉这题比D难)

首先，有个~~显而易见~~的结论：所需要的操作次数为最终序列中两个相邻的数的差的绝对值之和

证(shuo)明(li)：  
  - 首先操作必须从左向右进行  
  - 考虑对于 $a_i$，必须使它与 $a_{i-1}$ 相等，这必须要花费 $|a_i- a_{i-1} |$ 步  
  - 而这步操作之后，$a_{i+1}-a_i$ 的值不变  
  - 由此类推可得出结论

因此，我们只需改变一个数的值，使结果最小即可

对于$\forall i \in [2,i-1]$，$a_i$ 对结果的贡献是 $|a_i-a_{i-1}|+|a_i-a_{i+1}|$，而如果我们改变 $a_i$，可以将贡献额减小到 $|a_{i+1}-a_{i-1}|$

而对于 $i=1\ or\ n$，$a_i$ 的贡献值就是与旁边相邻的数的差的绝对值，而我们只要使它和旁边的数相等就可以把贡献值减到 $0$

因为我们要求结果最小，所以只要让贡献减小额最大化即可，具体实现可以看代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,a[200010],ans,mx,T;
int main()
{
	cin>>T;
	while(T--)
	{
		cin>>n;
		ans=mx=0;//多测别忘清零
		for(int i=1;i<=n;i++) scanf("%lld",&a[i]);
		for(int i=2;i<=n;i++) ans+=abs(a[i]-a[i-1]);//统计原来答案
		for(int i=2;i<n;i++) mx=max(mx,abs(a[i]-a[i-1])+abs(a[i+1]-a[i])-abs(a[i+1]-a[i-1]));//统计2~n-1中的最大贡献减小额
		mx=max(mx,max(abs(a[n]-a[n-1]),abs(a[2]-a[1])));//统计1和n的贡献减小额
		ans-=mx;//将原答案减去最大的贡献减小额
		cout<<ans<<'\n';
	}
    return 0;
}
```