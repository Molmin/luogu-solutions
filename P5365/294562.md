这一道题作为一个背包题还是很值得用来练手的。

***

### 思路：

可以看出，这是一道多重背包题。

但是，普通的多重背包题要我们求的是用一定的背包容量，选到更有价值的东西，询问最多能得到多少价值的东西。

可这道题不同，它让我们求的是**最少花多少钱（Q币）才能得到m种选皮肤方式。**

选皮肤方式的计算方法是乘法，所以我们得略改一点转移方程——把加价值改为乘以当前枚举的皮肤数量。

原方程：

```cpp
dp[j] = max(dp[j],dp[j - a[i]] + w[i])
```

加入枚举皮肤数量与新的计算价值（秀皮肤种数）的方程如下：

```cpp
dp[j] = max(dp[j],dp[j - k * a[i]] * k)
```
这样一来，我们既可以处理多重背包，又可以处理新的价值计算方式，非常方便。

但是这会超时吗？

如果这么计算，就得套三层循环，有点恐怖。

一看数据范围，计算可得知，n大约为100这个数量级的，于是我们完全不怂。

***

### 代码细节讲解：

仅讲解细节部分。

首先，这道题虽然是个背包，但是仍然需要初始化，不然乘出来全是0。

然后便开始三层循环。第一层如普通背包，从1到n循环。第二层就不一样了，我们需要从**所有物品钱数之和**开始循环。

为何？

你想想，对于普通背包，我们是从m开始的，也就是背包容量，因为我们仅需要得到背包容量那么多的容量。

而这一题不同，我们定义的$dp[m]$为用m元能得到的最多秀皮肤种数。

而我们背包处理完之后，必须从头开始循环判断哪一个能得到足够的秀皮肤种数。所以我们得循环到总价格。

而第三层循环便是枚举物品数量了。我们用一个数组存储物品数量，直接从1开始枚举即可。

***

### 注意事项：

$M <= 10^9 \times 10^8$，所以不开$long long$肯定会见祖宗。

第二层循环要从价格总数循环到0，而不是背包模板的a[i]。

这道题大概不能用二进制优化，也没有必要。

***

### 代码：

```cpp
#include<bits/stdc++.h>

#define int long long

using namespace std;

int read(){
   int s = 0,w = 1;
   char ch = getchar();
   while(ch < '0' || ch > '9'){if(ch == '-')w = -1;ch = getchar();}
   while(ch >= '0' && ch <= '9')s = s * 10 + ch - '0',ch = getchar();
   return s * w;
}

int n,m;
int a[100010];
int dp[100010];
int num[100010];
int ans;
int all;

signed main(){
	cin>>n>>m;
	for(int i = 1;i <= n;i ++)num[i] = read();
	for(int i = 1;i <= n;i ++)a[i] = read(),all += a[i] * num[i];
	dp[0] = 1;
	for(int i = 1;i <= n;i ++){
		for(int j = all;j >= 0;j --){
			for(int k = 1;k <= num[i];k ++){
				dp[j] = max(dp[j],dp[j - k * a[i]] * k);
			}
		}
	}
	while(1){
		if(ans > all)break;
		if(dp[ans] >= m)break;
		ans ++;
	}
	cout<<ans;
	return 0;
}
```