一个无向带权图，给定两条长度相等的路径，开始时可以决定以后每一步时是否申请切换路径（不一定成功），最多申请次数给定，求期望的花费最小值。

期望=成功概率\*成功时花费+失败概率\*失败时花费


算法思路：

最短路+概率DP

先Floyd求出两两间的最短路，记为d[i][j]，方便之后计算。

f[i][j][0], f[i][j][1]表示当前在第i个时间段，申请了j个教室，0表示申请不通过，1表示申请通过，最小耗费体力的期望值。

a[]表示原来时间段的教室，b[]表示更换后的教室，c[]是申请成功的概率。

f[i][j][0] = min(f[i-1][j][0] + d[a[i-1]][a[i]], f[i-1][j][1] + d[a[i-1]][a[i]] (1 - c[i-1]) + d[b[i-1]][a[i]] c[i-1]);

f[i][j][1] = min(f[i-1][j-1][0] + d[a[i-1]][a[i]] (1.0-c[i]) +

d[a[i-1]][b[i]] c[i], f[i-1][j-1][1] + d[a[i-1]][a[i]] (1.0-c[i-1]) (1.0-c[i])

d[b[i-1]][a[i]]c[i-1] (1.0-c[i]) + d[a[i-1]][b[i]] (1.0-c[i-1]) c[i] +


d[b[i-1]][b[i]] c[i-1] c[i]);

动态转移方程意义：（根据概率恒为一推方程最为科学）

[每条路径的概率是恒定的，到达一个点的概率不恒定]

当前时间段不申请：

（1）上个时间段未申请，只有一条路径

（2）上个时间段申请了，根据上个时间段申请成败概率决定此时路径（2条）

当前时段申请：

（1）上个时间段未申请，根据这个时间段申请成败概率决定此时路径（2条）

（2）上个时间段申请了，分别根据两个时间段的成败概率决定此时路径（4条）

初始化：

每个时间段0次申请的期望就是跟着初始规定路径累加

最后的答案在是所有时间段中(f[n][?][?])的最小值


代码：

```cpp
#include<iostream>
#include<iomanip>
usingnamespacestd; 
double k[2001],f[2001][2001][2];
int c[2001],d[2001],a[301][301];
int n,m,v,e; 
intmain()
{ int i,j; 
cin>>n>>m>>v>>e; 
for(i=1;i<=v;i++)
for(j=1;j<=v;j++) 
if (i==j)a[i][j]=0;else a[i][j]=2147483647;//初始化1
for(i=1;i<=n;i++) 
for(j=0;j<n;j++) 
{f[i][j][0]=2147483647;f[i][j][1]=2147483647;} 
f[1][0][0]=0; 
f[1][1][1]=0; //初始化2
int x,y,z;
for(i=1;i<=n;i++) cin>>c[i];
for(i=1;i<=n;i++) cin>>d[i];
for(i=1;i<=n;i++) cin>>k[i];
for(i=1;i<=e;i++) 
{ 
cin>>x>>y>>z; 
if(a[x][y]>z){a[x][y]=z;a[y][x]=z;}
 } 
for(int o=1;o<=v;o++)
for(i=1;i<=v;i++) 
for(j=1;j<=v;j++) if((a[i][j]>a[i][o]+a[o][j])&&(a[i][o]!=2147483647)&&(a[o][j]!=2147483647)) 
a[i][j]=a[i][o]+a[o][j]; 
for(i=2;i<=n;i++) f[i][0][0]=f[i-1][0][0]+a[c[i-1]][c[i]]; //初始化3
for(i=2;i<=n;i++) 
for(j=1;j<=min(m,i);j++) { f[i][j][0]=min(f[i-1][j][0]+a[c[i-1]][c[i]],f[i-1][j][1]+a[c[i-1]][c[i]]*(1.0-k[i-1])+a[d[i-1]][c[i]]*k[i-1]); f[i][j][1]=min(f[i-1][j-1][0]+a[c[i-1]][c[i]]*(1.0-k[i])+a[c[i-1]][d[i]]*k[i],f[i-1][j-1][1]+a[c[i-1]][c[i]]*(1.0-k[i])*(1.0-k[i-1])+a[d[i-1]][c[i]]*k[i-1]*(1.0-k[i])+a[c[i-1]][d[i]]*(1.0-k[i-1])*(k[i])+a[d[i-1]][d[i]]*k[i-1]*k[i]); }//核心动规
double ans=f[n][0][0]; 
for(i=1;i<=m;i++) 
{ 
if(f[n][i][0]<ans) ans=f[n][i][0];
if(f[n][i][1]<ans) ans=f[n][i][1]; }//最后一层找答案
cout<<setprecision(2)<<fixed<<ans; //场宽
return0; 
}

```