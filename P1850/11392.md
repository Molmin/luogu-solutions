第一次通过较为复杂的概率期望dp，发片题解纪念一下

首先，我们观察数据，发现只有两三千，所以我们可以来一发nmdp

我们设dp[i][j][2]:前i个时间段包括这次有j次申请，是否申请（1是,0否）的min期望

dp[i][j][0]=min

{

dp[i-1][j][0]+f[ci-1][ci] //两次都不申请，无疑问，就是前一个阶段的值+两个教室的距离

dp[i-1][j][1]+f[di-1][ci]*p[i-1]  +f[ci-1][ci]*(1-p[i-1])/
/前一次申请，这次不，有pi-1的概率从di-1到ci（上一次成功），1-p[i-1]的概率从ci-1到ci（上一次失败）

}

**注意：这里由于没有申请，所以都是从j转移过来的不是j-1**

dp[i][j][1]=min

{

dp[i-1,j-1][0]+f[ci-1][di]*pi+f[ci-1][ci]*(1-pi) //前一次不申请，这次申请，有pi概率成功，1-pi概率失败，相加就是从上一次转来的期望

dp[i-1][j-1][1]+

f[di-1][di]*p[i-1]*pi+//这次和上次都成功

f[ci-1][di]*(1-p[i-1])*pi //上次失败，这次成功

f[di-1][ci]*p[i-1]*(1-pi) //上次成功这次失败

f[ci-1][ci]*(1-p[i-1])*(1-pi) //上次和这次都失败

}

**注意：这里已经申请了，所以无论上次是否申请，都是从j-1转移**

然后注意一下边界条件即可，为了防止从一些不合法的状态转移，初始将所有置为1e9

然后dp[1][1][1]=0//你开始就申请不用花费体力

dp[0][0][0]=0 //啥都没干也是0

但这两个状态不能置0，因为他们本身不合法：

dp[1][1][0] //你又没有申请过，怎么会有1次申请

dp[1][0][1] //你都申请了，怎么一次申请都没有

由上面可以注意到，dp[i][j][1]的j不能为0

所以我们先预处理一遍dp[i][0][0]，后面的循环直接从1开始

边界：

```cpp
for(int i=1;i<=n;i++) for(int j=0;j<=m;j++) dp[i][j][0]=dp[i][j][1]=1e9;//防止不合法，置为1e9
dp[1][1][1]=0;//边界
for(int i=1;i<=n;i++)	dp[i][0][0]=dp[i-1][0][0]+f[c[i-1]][c[i]]; //预处理
```
然后，也可以发现j不可能大于i所以循环边界注意一下

dp转移：
```cpp
	for(int i=2;i<=n;i++) for(int j=1;j<=min(i,m);j++) //1我们已经处理过来，所以我们i从2开始    j，不能大于i，注意一下边界 
		{
			dp[i][j][0]=min(dp[i-1][j][0]+f[c[i-1]][c[i]],dp[i-1][j][1]+f[d[i-1]][c[i]]*p[i-1]+f[c[i-1]][c[i]]*(1-p[i-1]));
			dp[i][j][1]=min(dp[i-1][j-1][0]+f[c[i-1]][d[i]]*p[i]+f[c[i-1]][c[i]]*(1-p[i]),dp[i-1][j-1][1]+f[d[i-1]][d[i]]*p[i-1]*p[i]+f[c[i-1]][d[i]]*(1-p[i-1])*p[i] + f[d[i-1]][c[i]]*p[i-1]*(1-p[i])+f[c[i-1]][c[i]]*(1-p[i-1])*(1-p[i]));
		}
```
然后发现：WA了！！！

因为他可以不申请，所以要遍历所有dp[n]取min

```cpp
ans=dp[n][0][0];for(int j=1;j<=m;j++) ans=min(ans,min(dp[n][j][0],dp[n][j][1]));//可能他不申请比申请更优 ，所以要选最小值
```
然后就可以AC了

其实这道题想清楚也还好

代码不长，但转移方程挺长的

```cpp
#include <bits/stdc++.h>
using namespace std;
int n,m,v,e,f[333][333],c[2222],d[2222];
double p[2222],dp[2222][2222][2],ans=1e9;
int main()
{
	cin>>n>>m>>v>>e;
	for(int i=1;i<=v;i++) for(int j=1;j<=v;j++) f[i][j]=9e6;
	for(int i=1;i<=n;i++) for(int j=0;j<=m;j++) dp[i][j][0]=dp[i][j][1]=1e9; //为防止不合法置为0 
	for(int i=1;i<=n;i++) scanf("%d",c+i);
	for(int i=1;i<=n;i++) scanf("%d",d+i);
	for(int i=1;i<=n;i++) scanf("%lf",p+i);
	for(int i=1;i<=v;i++) f[i][i]=f[0][i]=f[i][0]=0; //自己到自己，0到任何地方都是0 
	for(int i=1;i<=e;i++)
	{
		int a,b,w;
		scanf("%d%d%d",&a,&b,&w);
		f[a][b]=min(f[a][b],w);
		f[b][a]=min(f[b][a],w); //由于可能有重边所以要取min 
	}
	for(int k=1;k<=v;k++)
		for(int i=1;i<=v;i++)
			for(int j=1;j<=v;j++)
				f[i][j]=min(f[i][j],f[i][k]+f[k][j]);	//flory求最短路 
	dp[1][1][1]=0; //边界 
	for(int i=1;i<=n;i++)	dp[i][0][0]=dp[i-1][0][0]+f[c[i-1]][c[i]]; //预处理 
	for(int i=2;i<=n;i++) for(int j=1;j<=min(i,m);j++) //1我们已经处理过来，所以我们i从2开始    j，不能大于i，注意一下边界 
		{
			dp[i][j][0]=min(dp[i-1][j][0]+f[c[i-1]][c[i]],dp[i-1][j][1]+f[d[i-1]][c[i]]*p[i-1]+f[c[i-1]][c[i]]*(1-p[i-1]));
			dp[i][j][1]=min(dp[i-1][j-1][0]+f[c[i-1]][d[i]]*p[i]+f[c[i-1]][c[i]]*(1-p[i]),dp[i-1][j-1][1]+f[d[i-1]][d[i]]*p[i-1]*p[i]+f[c[i-1]][d[i]]*(1-p[i-1])*p[i] + f[d[i-1]][c[i]]*p[i-1]*(1-p[i])+f[c[i-1]][c[i]]*(1-p[i-1])*(1-p[i]));
		}
	ans=dp[n][0][0];for(int j=1;j<=m;j++) ans=min(ans,min(dp[n][j][0],dp[n][j][1]));//可能他不申请比申请更优 ，所以要选最小值 
	printf("%.2lf\n",ans);
	return 0;
}
```
