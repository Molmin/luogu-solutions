相较于 div2 C 我还是觉得这题更好写/kk

一眼就知道是个对序列操作的数据结构题。有两种操作，一种修改，一种查询。

考虑**从性质入手**，本题的性质是序列**单调不递增**，并且修改后也显然满足该性质。那么有序序列就可以想到**二分**。

于是显而易见操作 $1$ 需要二分出最大的小于 $y$ 的数在哪，操作 $2$ 需要二分出一个位置 $s$，使得 $\sum_{i=x}^sa_i\leq y$ 且 $\sum_{i=x}^{s+1}a_i> y$，或者 $\sum_{i=x}^na_i\leq y$。

做法有很多种实现方式，有的写不好就带上了 3log 从而 gg。考虑线段树的优美性质于是直接在它上面二分即可。

对于操作 $1$ 维护区间最小值，若左儿子最小值大于等于 $y$ 就到右儿子里面找，否则递归左儿子。这部分显然是 $O(logn)$ 的。

对于操作 $2$ 维护区间和，先给出代码。
```cpp
inline int query(int id,int l,int r,int lbor,int &y){
    if(r<lbor||y<mn[id]) return 0;
    if(l>=lbor&&y>=sum[id]){
        y-=sum[id];
        return min(n,r)-l+1;
    }
    pushdown(id,l,r);
    int mid=(l+r)>>1,ans=0;
    if(mid>=lbor) ans+=query(id<<1,l,mid,lbor,y);
    ans+=query(id<<1|1,mid+1,r,lbor,y);
    return ans;
}
```


若该区间右端点小于 $x$ 或区间最小值大于当前 $y$，那么显然是 $0$；若区间合法且区间和小于当前 $y$ 则直接算上这段长度，否则递归左右儿子。

在此对 $y$ 采取引用可以实时减去已经成为答案的段，同时先遍历左儿子再遍历右儿子也满足了从左到右进行遍历。

可以证明，这个过程中被记入答案的节点数量为 $log_2y$ 级别。首先定义一个节点的深度为其在线段树中的深度。

可以发现，若一个被选节点是其父节点的左儿子，那么接下来选的节点必然不会是右节点，**否则答案不连续**；并且只能选**深度比它更深**的左节点，直到叶子节点。

若一个被选节点是其父节点的右儿子，那么接下来它有**两种选择**：选深度不小于它的左儿子，随后深度逐渐加深，一直到叶子节点；选深度小于它的一个右儿子（它父亲的兄弟）。

所以所选从左到右节点的深度应当是**先递减后递增**，假定一开始在叶子结点递增，最后递减到另外一个叶子节点，中间经过的点数也只有 $2log_2y$。而抵达一个节点所经过的节点数不超过 $log_2n$，故这步操作复杂度不大于 $O(logylogn)$。

[code](https://www.luogu.com.cn/paste/yktubhwc)