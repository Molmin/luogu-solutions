## 题目分析

~~这道题好像没人做嘛！~~

这道题一开始读时很难想到办法，$N$ 的范围是 $1000000$，$Q$ 的范围是 $75$，乘起来是 $75000000$，因此算法只能是 $O(n)$。

对于每次查询，字符串是必须要遍历一遍的，这一遍遍历，是必须要完成 $(D,M,C)$ 的配对的。

$k$ 的限制导致我们循环遍历时，像滑动窗口一样，会有 $D$ 离开这个窗口，而因此导致数量减少。

既然这样，那么这次遍历，我们可以找到所有的 $D$，由于 $k$ 的限制，而要找到 $M$，只能再次遍历，为了省掉这次遍历，我们很快就能想到使用前缀和！

至此，对于每个循环 $i$ 值时的 $(D,M)$ 配对的个数就可以知道了， 每次 $i$ 加一时要注意离开窗口的 $D$ 的判断！这时就要用到预处理的前缀和。

然后每当窗口内进入 $C$ 时，$ans$ 就要增加窗口内的 $(D,M)$ 配对个数。

这样，这道难题就能被我们成功解决了！

## 代码

接下来贴代码，希望大家能掌握思路，不要抄袭！

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,q,k[100];
int m[1000005];//m数组做前缀和用
string s;
int main(){
    ios::sync_with_stdio(0);
    cin.tie(0);
    cin>>n>>s>>q;
    for(int i=0;i<q;i++)cin>>k[i];
    for(int i=1;i<=n;i++)m[i]=m[i-1]+(s[i-1]=='M');//预处理做'M'数量的前缀和
    for(int i=0;i<q;i++){
	long long sumD=0,sumpair=0,ans=0;
        //sumD是D的数量
        //sumpair是窗口内满足条件的(D,M)的组数
	for(int j=0;j<n;j++){
	    if(j-k[i]>=0&&s[j-k[i]]=='D'){//这里注意要判断离开窗口的D
		sumD--;//离开一个D，于是sumD的值减去1
		sumpair-=(m[j]-m[j-k[i]]);//同时sumpair的值也要减去由离开的D产生的(D,M)组合
	    }
	    if(s[j]=='D')sumD++;//出现D时，sumD加1
	    if(s[j]=='M')sumpair+=sumD;//出现M时，(D,M)组合要增加sumD的值，因为这个M可以和窗口内的所有D产生组合
 	    if(s[j]=='C')ans+=sumpair;//出现C时，结果ans要增加sumpair的值，因为这个C可以和窗口内的所有(D,M)产生组合
	}
	cout<<ans<<"\n";
    }
    return 0;
}

```