
题解滴滴 ：


~~这场CF 窝咕咕了1.5h 出了A题便没做了 rating掉的很惨~~

题意
```
According to Polycarp
a positive integer is beautiful if it consists of only one digit repeated one or more times. 
For example,:
the following numbers are beautiful: 11 , 7777 , 777777.
```
简单来说就是指 给出一个 $n$ 求 $ 1 - n $ 之间 各个位数相同的数

如 ： 11， 88 ， 9999999 ； 而 23123， 32，45 则不是

##### 注 ： 1，2，3，4.....这些个位数也是！

且 来看看数据范围  ：$n\le 10^9$ ；非常良心的是 出题人吧大数据已经给在样例上了
```
1000000000 输出 81
```
所以最多只有81个$beautiful$  $number $ 不难想到 -----
打表警告⚠

----

首先 将着$81$个数 全部枚举出来 代码如下：
```
#include <bits/stdc++.h
>
using namespace std;

int n = 1e9, i1, ans = 0;
int main()
{
    for (int i = 1; i <= n; i++)
    {
        i1 = i;
        int tot = i % 10;
        for (int j = 0; i1; j++, i1 /= 10)//经典数位分离
        {
            if (tot == i1 % 10)
            {
                tot = i1 % 10;//一位一位判断 因为只有81个数 所以 不用考虑时间问题
            }
            else
            {
                ans++;
            }
        }
        if (ans == 0)
        {
            cout << i << ",";
        }
        ans = 0;
    }
}
```
##### 通俗易懂 时间在 $20s$ 内就可以全部枚举出来

得到如下数
```
1, 2, 3, 4, 5, 6, 7, 8, 9, 11,
22, 33, 44, 55, 66, 77, 88, 99,
111, 222, 333, 444, 555, 666, 777, 888, 999,
1111, 2222, 3333, 4444, 5555, 6666, 7777, 8888, 9999,
11111, 22222, 33333, 44444, 55555, 66666, 77777, 88888, 99999,
111111, 222222, 333333, 444444, 555555, 666666, 777777, 888888, 999999,
1111111, 2222222, 3333333, 4444444, 5555555, 6666666, 7777777, 8888888, 9999999, 
11111111, 22222222, 33333333, 44444444, 55555555, 66666666, 77777777, 88888888, 99999999, 
111111111, 222222222, 333333333, 444444444, 555555555, 666666666, 777777777, 888888888, 999999999

```
当然 这道题就非常简单了 只需统计 $total[i]$ 中比 $n$ 小的数即可
时间也非常快

代码如下
 ```
 #include <bits/stdc++.h>
 
using namespace std;//别学我---太懒了。。

int b[82] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 11,
                    22, 33, 44, 55, 66, 77, 88, 99,
                    111, 222, 333, 444, 555, 666, 777, 888, 999,
                    1111, 2222, 3333, 4444, 5555, 6666, 7777, 8888, 9999,
                    11111, 22222, 33333, 44444, 55555, 66666, 77777, 88888, 99999,
                    111111, 222222, 333333, 444444, 555555, 666666, 777777, 888888, 999999,
                    1111111, 2222222, 3333333, 4444444, 5555555, 6666666, 7777777, 8888888, 9999999, 
                    11111111, 22222222, 33333333, 44444444, 55555555, 66666666, 77777777, 88888888, 99999999, 
                    111111111, 222222222, 333333333, 444444444, 555555555, 666666666, 777777777, 888888888, 999999999};
///以上是打表内容
long long  n;
long long a;
long long ans = 0;
int main()
{
    cin >> n;
    while (n--)//注意多组数据输入！！！！！
    {
        long long i = 0;
        cin >> a;
        if(a >= 888888888 && a < 999999999)
        {
            cout << "80" << endl;
            continue;
        }
        if(a >= 999999999)
        {
            cout << "81" << endl;
            continue;
        }//以上是特判， 因为可能会爆掉 导致无输出
        while(a >= b[i]){//判断大小
            ans++;
            i++;
        }
        cout << ans << endl;
        ans = 0;//注意清零
}
```
~~打表很快，为什么不去试试呢 ？ 唔呣~~

好啦 以上是本篇题解的全部内容 去A了这道题把