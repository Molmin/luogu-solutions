这道题毕竟是提高-，并没有那么难。

# 正文

首先，我们来举个例子：（样例）
```cpp
8 3
2
2
4
```

我们有一个比较简单的做法。首先，让我们把这一串珠子进行排序，变成 `33332211`。这样，我们就能进行这样的操作：

Step 0: 建造 $N/2$ 个组合，2行：

|1|2|3|4|
|:-:|:-:|:-:|:-:|
|||||
|| |||

Step 1: 选出个数最多的珠子，堆到第一行：

|1|2|3|4|
|:-:|:-:|:-:|:-:|
|3|3|3|3|
||| | |

Step 2: 仿照前面的操作，把目前最多的珠子放到空间最大的行。第一行空间0，第二行空间4，所以把2号珠子全部放到第二行：

|1|2|3|4|
|:-:|:-:|:-:|:-:|
|3|3|3|3|
|2|2| | |

同理，最后填满：

|1|2|3|4|
|:-:|:-:|:-:|:-:|
|3|3|3|3|
|2|2| 1| 1|

Over。

**但是还有一个小问题。**

看一下这一组：

```
8 3
3
3
2
```

按照前面的操作，我们可以做到这一步：

|1|2|3|4|
|:-:|:-:|:-:|:-:|
|1|1|1||
|2|2|2 | |

接下来把两个 3 放进去就悲剧了。

怎么解决呢？

我们不妨把这两个3先放进去。

|1|2|3|4|
|:-:|:-:|:-:|:-:|
|1|1|1|3|
|2|2|2 | 3|

~~似乎没有想出办法~~

我们发现，把第一行翻转一下，变成 `3 1 1 1` 就不会产生问题了。

如何证明这样永远不会发生问题呢？

可能发生问题的只有最后多出来的k个3。显然 $k\le N/2$，那么最多只有k组里面会出现3。把3均摊放到这几组里面，没有问题。

这样，我们最终构造的数列可能是这种形式：

```
A a a b b c c d d e e e f f f 
g g g g h h h h i i i j j j A
```
简单来说，就是

**第一行从右向左加元素，第二行从左到右加元素，多出来的在两边补空荡**

~~希望能通过~~
