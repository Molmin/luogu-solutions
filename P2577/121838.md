比较麻烦的一道DP

想了很长时间，结合题解才勉强写出来

在这里分享一下解题报告，对DP的每个细节都有详细的注释,还没有弄明白的同学可以参考这一篇对状态转移的解释来解题

/*
【午餐】 解题报告

DP
关键是如何设计状态

性质1：贪心
这个比较容易证明
吃饭时间短的先打饭

但有一个地方很烦人

那就是**排队完成的时间与最终吃饭完成时间不一定是相同的**

考虑这么设计状态方程： 

f[i][j]表示前i个人，在队1一共花费了j的时间打饭所需要的时间

注意到**有两个时间**，第一个是**队1排队用的时间(状态)**

第二个是f[i][j]的值，也就是**总共需要的时间 (结果)**


性质2：每个人**在且仅在**一个队

注意到我们f内记录的j为当前排队使用的时间

而前i个人排队需要的总时间是不变的！！

所以说**知道了在队1排队的总时间，就相当于知道了在队2排队的总时间** 

这就是为什么可以优化一维，把队2的时间优化掉，从而保证空间不会爆炸

然后我们考虑转移

①：先枚举i还是先枚举j？
按照dp的基本思路，先枚举i
然后后续转移f[i][...]时用f[i-1][...]更新 

②：正着枚举还是反着枚举？
如果使用滚动数组优化的话，建议时间倒序枚举
因为每个人只可以使用一次
如果是f[i][j]就不需要考虑，因为每次都是在i-1上操作的 

③：初始化
f[0][0] = 0;其他的memset 0x3f

④：转移方程

（a[i]为打饭时间，b[i]为吃饭时间）

分为两种情况：扔进1队/扔进2队

如果这个i是由加入1队得到的，那么

**f[i][j] = min(f[i][j] ,  max(j+b[i],f[i-1][j-a[i]] ) ) ;** 

这个方程的意思：

min：在所有可以转移的值中取最小

max：计算时间，向队伍后面加入一个人，**总时间有两种情况**：

1.这个人的排队+吃饭时间加起来还没有之前 i-1 个人总共需要的时间长
(因为吃饭时间长的在前面，所以这种情况的很容易发生的)

2.与1相反，那么就用排队时间j和这个人吃饭的时间b[i]来更新ans 

扔进2队：

**f[i][j] = min(f[i][j] , max( (sum[i]-j)+b[i] , f[i-1][j] )**

大体上同1，但要注意**放进2队是对1队的时间没有影响的**

所以除了时间又j变成了（sum[i]-j) ,取max时的转移也又f[i-1][j-a[i]] 变为了 f[i-1][j]; 


*/


结合代码：

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#define il inline
#define rg register
#define N 210
using namespace std;

int f[N][N*N];

struct p{
	int x,y;
}a[N];

il bool cmp(p a,p b){
	return a.y>b.y;
}

int n;
int ans = 99999999;

int sum[N];

int main(){
	cin>>n;
	
	for(rg int i=1;i<=n;++i){
		scanf("%d%d",&a[i].x,&a[i].y);
	}
	
	sort(a+1,a+n+1,cmp);
	
	for(rg int i=1;i<=n;++i){
		sum[i] = sum[i-1]+a[i].x;
	}
	
	memset(f,0x3f,sizeof(f));
	
	f[0][0] = 0;
	
	for(rg int i=1;i<=n;++i){
		for(rg int j=1;j<=sum[i];++j){
			if( j >= a[i].x)
			f[i][j] = min(f[i][j] , max( j+a[i].y, f[i-1][j-a[i].x] ) ) ; 
			f[i][j] = min(f[i][j] , max( (sum[i]-j)+a[i].y , f[i-1][j] ) ) ;
		}
	}
	
	for(rg int i=1;i<=sum[n];++i){
		ans = min(ans,f[n][i]);
	}
	
	cout<<ans<<endl;
	
	return 0;
}
```

希望能帮到大家

如果还有什么细节不清楚可以直接在旁边留言或者私信交流

看见了一定会回复。