# 思路
## 一个队伍
```	
    首先来考虑只有一个队伍的情况
	思路1：
		当只有一个队伍的时候
		因为所有人都一定要打饭
		所以总的打饭时间是一样的
		所以我们就需要尽量把吃饭时间长的往前放
		因为迟早要吃，吃饭时间长的往后放肯定不会更优
	思路2：	
		刘汝佳 蓝书第2页的《突击战》便是一个非常好的例子
		对于两个相邻两个人XY不难发现交换之后对其它任务完成时间无影响
		因为两个人的吃饭时间总和是一定的
		那么我们就可以进行分类讨论
		假设X的吃饭时间比Y长,交换之前X在Y前
		#case1：交换前Y比X先结束
			那么此时交换无疑是把X结束的时间往后再延长
		#case2：交换前X比Y先结束
			交换前的总时间=XY打饭总时间+Y吃饭时间
			交换后的总时间=XY打饭总时间+X吃饭时间
			根据假设，得出交换前的总时间<交换后的总时间
	所以，只有一个队伍的问题用贪心解决
```
## 两个队伍
```
	有两个队伍的问题可以由只有一个队伍的问题衍生而来
	我们限制一下两队打饭时间即可
	f[i][j] 表示到了第i个人，第1个队打饭时间为j,两队 用时最长的那个人 的用时 的最小值
	每一个人有两种选择
	1.加入到第一队
		因为到他的时候第一队已经打了j分钟饭了
		所以他总时间就是 j+吃饭时间+打饭时间
		如果这个时间比 第一队用时最长的人晚就可以更新答案了
	2.加入到第二队
		因为加到第二队，所以对第一队没有影响
		所以j是不要变化的
		因为第一队的打饭时间为j 所以第二队的打饭时间为当前所有人的打饭时间-第一队打饭时间
		然后就跟加入到第一队是一样的
```
# 代码
```cpp
	f[0][0]=0;
    for(int i=0; i<n; i++) {
        for(int j=0; j<=sum[i]; j++) {
            if(f[i][j]==inf)continue;
            f[i+1][j+a[i+1].w]=min(f[i+1][j+a[i+1].w],max(j+a[i+1].w+a[i+1].val,f[i][j])); // 加到第一队
            f[i+1][j]=min(f[i+1][j],max(f[i][j],a[i+1].val+sum[i]-j+a[i+1].w));  // 加到第二队
        }
    }
	```	