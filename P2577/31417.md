[题目传送门](https://www.luogu.org/problem/P2577)

首先很明显这是一道 $dp$ 题 ，但同时我们还要用到**贪心**的思想

看了看各位大佬的题解 ，都说是**吃得慢的人先打饭会更省时间** ，但是证明本蒟蒻没看懂 $($我太菜啦$QAQ)$ ，于是本蒟蒻在这里给出一个应该挺好懂的贪心证明

在看到这题时 ，我首先想到了[国王游戏](https://www.luogu.org/problem/P1080) ，我们完全可以用相同的思想进行证明

## 贪心证明

假设现在有**前后**两个人 $A_1,A_2$ ，我们要给他们两个排序使得总时间最小 ，设 $A_1$ 的打饭时间为 $a_1$， 吃饭时间为 $b_1$ ，$A_2$ 的打饭时间为 $a_2$， 吃饭时间为 $b_2$ ，当然这两个人前面可能还有人 ，设他们的总打饭时间为 $x$

当 $A_1$ 在前面时 ，$A_1$ 离开的时间为 $x+a_1+b_1$ ，$A_2$  离开的时间为 $x+a_1+a_2+b_2$ $($注意 $A_1,A_2$ 是前后两个人$)$ ，所以总时间为 $max(x+a_1+b_1,x+a_1+a_2+b_2)$

同理我们可以得到当 $A_2$ 在前面时总时间为  $max(x+a_2+b_2,x+a_2+a_1+b_1)$

若 $A_1$ 在前面更优 ，则有
$$max(x+a_1+b_1,x+a_1+a_2+b_2) \le max(x+a_2+b_2,x+a_2+a_1+b_1)$$

首先消掉左右都有的 $x$ ，得到

$$max(a_1+b_1,a_1+a_2+b_2) \le max(a_2+b_2,a_2+a_1+b_1)$$

由于不知道 $a_1,b_1,a_2,b_2$ 之间的大小关系 ，我们进行**分类讨论**

$1. \ b_1 \ge a_2+b_2$ ，则有 $a_1+b_1 \le a_2+a_1+b_1$ ，又得到 $0 \le a_2$ ，成立

$2. \ b_2 \le b_1 \le a_2+b_2$ ，则有 $a_1+a_2+b_2 \le a_2+a_1+b_1$ ，又得到 $b_2 \le b_1$ ，成立

$3. \ b_1 \le b_2 \le a_1+b_1$ ，则有 $a_1+a_2+b_2 \le a_2+a_1+b_1$ ，又得到 $b_2 \le b_1$ ，与条件矛盾 ，不成立

$4. \ b_2 \ge a_1+b_1$ ，则有 $a_1+a_2+b_2 \le a_2+b_2$ ，又得到 $a_1 \le 0$ ，显然不成立

根据分类讨论 ，我们发现原式成立时**总有** $b_1 \ge b_2$ ，所以  $max(a_1+b_1,a_1+a_2+b_2) \le max(a_2+b_2,a_2+a_1+b_1)$ 等价于 
 $b_1 \ge b_2$ 

$Q.E.D$

## $DP$ 实现

首先考虑怎么表示状态

第一维肯定是表示第几个人 ，再看看题目中有两个窗口 ，于是我们用 **$f[i][j][k]$ 表示前 $i$ 个人 ，在 $1$ 号窗口打饭的总时间为 $j$ ，在 $2$ 号窗口打饭的总时间为 $k$ 时 ，需要的最小的总时间**

~~状态可能有些复杂 ，多看几次就懂了~~

接着想状态怎么转移 ，显然每次状态转移有两种情况 ，第 $i$ 个人去 $1$ 号窗口打饭 ，或者第 $i$ 个人去 $2$ 号窗口打饭

**若第 $i$ 个人去 $1$ 号窗口打饭**

我一开始想到的转移方程是这个：

$$f[i][j][k]=min(f[i][j][k],f[i-1][j-a_i][k])$$

后来发现这是错的 ，因为不一定在 $f[i-1][j-a_i][k]$ 的时间内第 $i$ 个人也能吃完饭 ，稍加思索~~看题解~~后 ，我们得到新的转移方程:

$$f[i][j][k]=min(f[i][j][k],max(f[i-1][j-a_i][k],j+b_i))$$

这个方程的意思就是：如果在 $f[i-1][j-a_i][k]$ 的时间内第 $i$ 个人也能吃完饭 $(j+b_i$ 就是第 $i$ 个人吃完饭的时间$)$ ，那么就没有影响 ，否则总时间就要延长使得第 $i$ 个人也能吃完饭

**若第 $i$ 个人去 $2$ 号窗口打饭**

同理我们可以得到：

$$f[i][j][k]=min(f[i][j][k],max(f[i-1][j][k-a_i],k+b_i))$$

到这里 $dp$ 基本就设计完了 ，但我们又发现开三维的数组会 $MLE$ ，所以还得要把状态压成二维的

看看我们之前的状态设计 ，我们发现 ，**在 $1$ 号窗口打饭的总时间加上在 $2$ 号窗口打饭的总时间 ，恰好等于前 $i$ 个人打饭的总时间** ，所以就有 $j+k=\sum\limits_{x=1}^{i} a_x$

所以我们就可以把 $f[i][j][k]$ 给压成 $f[i][j]$ ，用 $f[i][j]$ **表示前 $i$ 个人 ，在 $1$ 号窗口打饭的总时间为 $j$ 时 ，需要的最小的总时间**

上面的状态转移方程也就变成了

$$f[i][j]=min(f[i][j],max(f[i-1][j-a_i],j+b_i))$$

$$f[i][j]=min(f[i][j],max(f[i-1][j],sum[i]-j+b_i))$$

至此 ，本题就被解决了 ，**完结撒花**

还有一些小细节见代码

$Talk \ is \ cheap.\ Show \ you \ the \ code.$

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=205;
int ans=1<<30,n,s[maxn],f[maxn][maxn*maxn];
inline int read(){
	int x=0; char c=getchar();
	while(c<'0' || c>'9') c=getchar();
	while(c>='0' && c<='9') x=x*10+c-48, c=getchar();
	return x;
}
struct person{
	int a,b;//a为打饭时间，b为吃饭时间 
	bool operator < (const person &x) const {return b>x.b;}
} p[maxn];
int main(){
	n=read();
	for(int i=1;i<=n;i++) p[i].a=read(), p[i].b=read();
	sort(p+1,p+n+1);
	for(int i=1;i<=n;i++) s[i]=s[i-1]+p[i].a;//维护一个打饭时间的前缀和 
	memset(f,0x3f,sizeof(f));//把f数组初始化为最大值 
	f[0][0]=0;//记得把f[0][0]设为0，不然后面就全炸了 
	for(int i=1;i<=n;i++)
		for(int j=0;j<=s[i];j++){
			if(j>=p[i].a) f[i][j]=min(f[i][j],max(f[i-1][j-p[i].a],j+p[i].b));//这里转移的时候要注意满足 j>=p[i].a
			f[i][j]=min(f[i][j],max(f[i-1][j],s[i]-j+p[i].b));//这里的 s[i]-j就是k 
		}
	for(int i=0;i<=s[n];i++) ans=min(ans,f[n][i]);
	cout<<ans<<endl;
	return 0;
}
```
