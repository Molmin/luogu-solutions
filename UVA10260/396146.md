# 神奇地用 MAP 解题
[进入博客查看](https://except.blog.luogu.org/)
## 题意简述：
+ 给你一个字符串和每个字母转换数字的方式，请将字符串中的字母转换。且 A,E,I,O,U,H,W,Y 没有对应数字，直接忽略。
+ 如果前后两个字符**的对应数字**相同，只输出一个。

## 分析：
 1. 去重操作比较简单，当前字符不为第一位且当前字符**的对应数字**和上个字符**的对应数字**相同，就 `continue` 跳过。
 2. 至于如何逐字母转换成数字，没有必要每一次都判断，可以使用 C++ 里 STL 的 *MAP* 进行预处理，预处理直接把单个字符当关键字，对应数字为值存在 *MAP* 里。使用时判断到的字符寻找对应值，~~无脑~~输出就行。
 3. 没有对应数字的字母需要忽略，同样判断+ `continue` 跳过。

**注：C++ 中的 map 是 STL 的一个关联容器**，第一个元素称为关键字，第二个称为关键字的值，关键字不可以重复。map 内部是红黑树实现的，插入、查询等操作的时间复杂度都近似为 $O( \log{n})$。


## 完整代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
map<char,int>c;
string s;
void pre(){//预处理，后面直接使用
	c['A']=c['E']=c['I']=c['O']=c['U']=c['H']=c['W']=c['Y']=-1;
	c['R']=6;
	c['M']=c['N']=5;
	c['L']=4;
	c['D']=c['T']=3;
	c['C']=c['G']=c['J']=c['K']=c['Q']=c['S']=c['X']=c['Z']=2;
	c['B']=c['F']=c['P']=c['V']=1;
}
int main()
{
	pre();
	while(cin>>s)//输入未说明数量，所以放入循环
   //cin读入失败返回0，就可以跳出循环
   //手动输入数据测试时，按ctrl+z作为结束标志
	{
		for(int i=0;i<s.size();i++)//循环访问单个字符
		{
			if(i!=0&&c[s[i-1]]==c[s[i]])continue;//去重  i!=0判断防止越界 
			if(c[s[i]]==-1)continue;//不包含的，跳过
			printf("%d",c[s[i]]);//直接输出不必存储 
		}
		printf("\n");
	}
	return 0;
}
```
