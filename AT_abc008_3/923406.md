#### 前言
一道很标准的期望题。

题目：[[ABC008C] コイン](https://www.luogu.com.cn/problem/AT_abc008_3)\
#### 思路
既然能够明显地看出是期望题，不妨先去复习一下期望公式：

- $X$ 离散随机变量，输出值为 $X_1,X_2,X_3……X_N$ 对应概率为  $p_1,p_2,p_3……p_N$,则期望值为：

$$E(X)=\sum_{i=1}^N {p_i \times X_i}$$

好的，我们已经成功一半了。

根据题目条件，$X_i$ 的值应均为 $1$，而 $p_i$ 的值应当为第 $i$ 枚硬币正面朝上的概率。问题是，这个概率应当怎么去求？

根据题目条件，一个硬币能对后面所有数值是当前硬币的倍数的硬币产生影响，也就是能够让所有这些硬币翻面。反过来，一个硬币只能被数字是其约数的硬币影响。那么，每个硬币朝上的概率是多少呢？

我们令所有数值是给定硬币 $c$ 的约数的硬币的名字为 $divisor$，那么一个硬币 $c$ 朝上，当且仅当其左边有偶数个 $divisor$。这很好理解，因为只有当前硬币 $c$ 翻了偶数次，这个硬币才能保持当前的状态。因而假若硬币 $c$ 有 $v$ 个 $divisor$，硬币 $c$ 朝上的概率就可以转换为：偶数个 $divisor$ 在 $c$ 左边的概率。如果此时仍不明确，还可以将其转化为：硬币 $c$ 位于所有 $divisor$ 构成的序列中的奇数位置的概率。那么此时就容易计算其概率为：

```cpp
(double)((divisor-1)/2+1)/(divisor);
```
这就是最为核心的代码。注意：以上的 $divisor$ 相当于 $v$，是约数的数量；以上的代码是用来计算期望的，但由于乘数 $X_i$ 均为 $1$ 所以忽略掉了，剩下的部分便也可以来代表概率；以上中的 $divisor$ 包括本身。

这就是处理一个硬币时候的思路，只要重复这个过程就可以了。

#### 代码实现

代码很短，因此建议先不看题解，自己按照思路实现。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
int N, a[110];
signed main () {
	scanf("%lld", &N);
	double sum=0;
	for(int i=1;i<=N;i++)scanf("%lld", &a[i]);
	for(int i=1;i<=N;i++) {
		int divisor=0;
		for(int j=1;j<=N;j++) {
			if(a[i]%a[j]==0) {
				divisor++;
			}
		}
		sum+=(double)((divisor-1)/2+1)/(divisor);
	}
	printf("%.12lf\n", sum);
	return 0;
}
```

#### 最后
感谢大家的观看，有问题或建议欢迎指正！


