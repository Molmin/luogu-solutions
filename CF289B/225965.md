## 【题意】
给一个 $n$ 行 $m$ 列的矩阵，给一个 $d$ 值，要求将矩阵里的每个数字变成一个相等的数字，每次操作可以将任意一个数 $+d$ 或 $-d$ 。若能实现，输出最小操作次数；反之输出$-1$。
## 【思路】
存储数据时，将二维矩阵压成一维来存储，比较方便排序。

判断能否实现时，因为任意两个数 $x$ ， $y$ ，都要保证 $(x-y)\bmod d=0$ ，即 $x\bmod d=y\bmod d$ 。用 $mod$ 数组记录每一个数对$d$取余的值。比较相邻的两个值是否相同，一旦不相同输出 $-1$ 并退出程序。

**算法：贪心**

要解决所有的数变成哪一个数的问题，不妨设几个数字模拟一下。

设 $a=k\times t-d,b=k\times t,c=k\times t+d$

变为$a$和$c$都要$3$次，变成$b$需要$2$次。

严格的证明楼上已经写出，这里只是举一个例子更加清晰地说明结论，以及证实贪心的正确性。

所以要使所有的数通过最少操作数变成同一个数，应该变为它们的中位数，即排序后数组中第 $(n\times m+1)/2$ 个数。

那么为什么是第 $(n\times m+1)/2$ 个数呢？这里**分类讨论**：

①当 $n\times m$ 为奇数时，中位数显然只存在一个。

②当 $n\times m$ 为偶数时，中位数存在两个，取任意一个都行，可以把它看作对称，选择哪个不会对结果有影响。我选的是前一个数，并不会向楼上所说的那样中位数是第$0$个，$(1\times 1+1)/2=1$ 。

设当前数为 $xi$ ，中位数为 $mid$ ，操作数为 $ti$ 。再次**分类讨论**：

①当$xi<mid$时，$ti=(mid-xi)/d$ ；

②当 $xi=mid$ 时, $ti=0$ ；

③当 $xi>mid$ 时， $ti=(xi-mid)/d$ 。

综合一下, $ti=abs(mid-xi)/d$，$ans=\sum\limits_{i=1}^{n\times m}ti$ 。
## 【代码】
```cpp
#include <bits/stdc++.h>
using namespace std;
int n,m,d,ans,a[10005],mod[10005];
int main()
{
	scanf("%d%d%d",&n,&m,&d);
	for(int i=1;i<=n*m;i++)
	{
		scanf("%d",&a[i]);
		mod[i]=a[i]%d;
	}
	for(int i=2;i<=n*m;i++) if(mod[i]!=mod[i-1]){printf("-1");return 0;}  //无法通过加减d的操作使数字相同
	sort(a+1,a+n*m+1);
	for(int i=1;i<=n*m;i++) ans+=abs((a[i]-a[(n*m+1)/2])/d);
	printf("%d",ans);
	return 0;
}
```