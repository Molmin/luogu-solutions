~~第一篇紫题解好激动~~

[更好的阅读体验](https://www.luogu.com.cn/blog/WhiteSunflower/solution-p4133)
### 分析
- 首先我们知道任意自然数都可以表示为 $n$ 个不相同斐波那契数的和。

具体的可以参考
[知乎：是否任意自然数都能被不相同的斐波那契数之和表示?](https://www.zhihu.com/question/68360587/answer/262536718)

~~通过打表得知~~，对于一个正整数 $n$ ，每次减去小于 $n$ 的第一个斐波那契数，按照此方法分解 $n$ 可以保证把 $n$ 表示为数量尽可能少的斐波那契数的和。即为我们接下来操作的基础。

### 核心内容
根据斐波那契的定义： 
 $F_1=1 , F_2=1 , F_n=F_{n-1}+F_{n-2}$

我们发现：如果我们新开一个数组 $B$ ,用 $0/1$ 来表示 $F_i$ 有没有被选用，那么
![](https://cdn.luogu.com.cn/upload/image_hosting/1eohgvah.png)

上表中的 $(1)$ 和 $(2)$ 方案所表示的数是一样的，于是我们就可以得到一个思路：

求所有 

 $B_i=1,B_{i-1}=B_{i-2}=0 \rightarrow B_i=0,B_{i-1}=B_{i-2}=1$

的方案数。

简单找找规律，我们可以发现：对于 B 中的每一个形如 $00…1$ 的块：

![](https://cdn.luogu.com.cn/upload/image_hosting/xai6o7ly.png)

假设前面共有 $N$ 个 $0$，那么共计 $N/2$ 种方案，而且 $B_i$ 被分解后  $B_{i-1}$ 不可分解，即 $B$ 中每个$1$  对答案的贡献仅和前面 $0$ 的数量有关系。要注意的是，假如一个 $1$ 被分解了，那么他原本的位置就会空出一个 $0$ 来，对下一个 $1$ 的分解方案数产生影响。

综上，我们设置状态： 
>$dp [i][0]$ 表示 $B$ 中第 $i$ 个 $1$ 不分解的方案数。

>$dp [i][1]$ 表示 $B$ 中第 $i$ 个 $1$ 分解的方案数。

我们用 $A_i$ 表示第 $i$ 个 $1$ 和第 $i-1$ 个 $1$ 之间 $0$ 的数量（ $i=1$ 则为第一个 $1$ 前面 $0$ 的数量，注意 $F_1=F_2$ ，所以实际上从 $F$ 的第二个 $1$ 开始计数）。

#### 真正的核心
初始化：

```cpp
dp[1][0]=1,dp[1][1]=a[1]/2; 
```
状态转移：

```cpp
dp[i][0]=dp[i-1][0]+dp[i-1][1];
```
>注： $0$ 为不分解，故等于第 $i-1$ 个 $1$ 的方案数。


```cpp
dp[i][1]=dp[i-1][0]*(a[i]>>1)+dp[i-1][1]*((a[i]+1)>>1);
```
>注：第 $i-1$ 个不分解, $0$ 的数量为 $a[i]$ ，方案数乘 $(a[i]/2)$ ；$i-1$ 个分解，$0$ 的数量为 $a[i]+1$ ,方案数乘 $((a[i]+1)/2)$ 。

最后输出 $dp[a\_len][0] + dp[a\_len][1]$ 就好辣！

---
#### $AC$ $Code$：

```cpp
#define WhiteSunflower int main()
#include <bits/stdc++.h>
#define ll long long
using namespace std;

ll f[100];//打标得知 10^18 分解最多约为 88 个
void init(){//斐波那契数打表预处理 
	f[1]=f[2]=1;
	for(int i=3;i<=90;i++)
		f[i]=f[i-1]+f[i-2];
}

ll t,n,a[100],dp[100][2],al;
bool b[100];

WhiteSunflower{
	init();
	cin >> n;
	int i=90;
	while(n&&i--)if(n>=f[i])n-=f[i],b[i]=1;
   //从大往小分解可以保证不重复 
   
	int cnt=0;
	for(int i=2;i<=90;++i){
		if(b[i]) a[++al]=cnt,cnt=0;
      //统计 b 数组中每段连续 0 的长度 
		else ++cnt;
	}
    
	dp[1][0]=1,dp[1][1]=a[1]>>1; 
	for(int i=2;i<=al;++i){
		dp[i][0]=dp[i-1][0]+dp[i-1][1];
		dp[i][1]=dp[i-1][0]*(a[i]>>1)+dp[i-1][1]*((a[i]+1)>>1);
	}
    
	cout << dp[al][0]+dp[al][1] << '\n';
	return 0;
}
```

