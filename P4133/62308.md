# 题意

给定正整数 $n (1\le n\le 10^{18})$，定义斐波那契数列 $F_1=1, F_2=2, F_n=F_{n-1}+F_{n-2} (n\ge 3)$，请求出满足如下条件的集合 $A=\{a_1,a_2,\cdots,a_m\} (a_1<a_2<\cdots<a_m)$ 的个数：

$$ \sum_{i=1}^m F_{a_i}=n $$

# 简述题解

首先借助样例分析，我们先把一个集合写成二进制形式，比如 $16=F_3+F_6$ 就写成 100100。

我们看看 $16$ 的四种表示：100100，011100，100011，011011。我们能够发现两件事：

- 除去 100100，其它的表示都会有相邻的 1。
- 11100，100011，011011 这些都是由 100100 做如下操作得到：选一个 1，变成 0，并将它右边两个数变成 1。也即 $F_i\rightarrow F_{i-1}+F_{i-2}$。

因此我们猜测：所有的表示法都是由 100100 这种没有相邻 1 的方案做上面的操作得到的。

我们先求出一个表示法吧。结合一些关于二进制的知识，我们可以这样求出首位最大的表示法：

```cpp
for (int i = MAX; i >= 1; --i)
    if (F[i] <= N) S.push_back(i), N -= F[i];
```

每次找到最大的，然后加进去。

幸运的是，我们碰巧找到了没有相邻 1 的方案！解释很简单，如果 $i, i+1$ 都在 $A$ 中，那么加入之前， $F_i+F_{i+1}=F_{i+2}\le n$ 肯定是成立的，这说明我们会先加入 $i+2$，$i,i+1$ 同时加入是不可能的！

我们用它来生成所有的方案，首先我们会尝试这样分段：对方案 100100，分成``[100][100]``，每个段有两种分别是 100 和 011，乘起来是 4。更扩展一些，若分成 ``[10000][100][1000]`` 这样的段，一段的长度是 $l$，则对答案贡献 $\lfloor \frac{l+1}{2}\rfloor$（乘在答案上）。

这对样例是正确的，但会遇到一个问题：``10100->01111``，这是因为后面的会给前面的”让位“。有了”让位“的情况，计算变得稍微棘手，因此我们采用 dp 解决。

设 $f_{i,0/1}$ 表示我们考虑到了第 $i$ 位（也就是 $F_i$），是否对它进行操作。若上一个 1 是 $j$ 位，我们很容易写出如下方程：

$$ \left\{ \begin{aligned} & f_{i,0}=f_{j,0}+f_{j,1} \\ & f_{i,1}=\lfloor\frac{i-j-1}{2}\rfloor f_{j,0}+\lfloor \frac{i-j}{2}\rfloor f_{j,1} \end{aligned} \right. $$

意义明显，若不操作，$f_{i,0}$ 直接由上一个操作/不操作转移，若 $i$ 操作，当 $j$ 不操作时，这一段长度为 $i-j$，贡献是 $\lfloor \frac{i-j+1}{2}\rfloor-1=\lfloor \frac{i-j-1}{2}\rfloor$。若 $j$ 操作同理。

这样就能以 $O(\log n)$ 的复杂度求出答案了。

# 严谨题解

### 定义

称满足题目条件的集合 $A=\{a_1,a_2,\cdots,a_m\} (a_1<a_2<\cdots<a_m) $ 为 $n$ 的 "Fib表示"，若 $\forall i\in [2,n], a_i-a_{i-1}>1$，则称其为 $n$ 的 "Fib真表示"，也可以称为一个 "Fib真表示"。

我们主要研究如下问题：

- 一个 $n$ 有几个 "Fib真表示"？
- "Fib表示" 和 "Fib真表示" 的关系？
- 题目解法

### Theorem 1

设 $S_n (n\in \mathtt{N}^*)$ 为所有 $a_m=n$ 的 "Fib真表示" 构成的集合，我们证明映射法则 $f(A)=\sum\limits_{i=1}^m F_{a_i}$ 是从 $S_n$ 到 $[F_n,F_{n+1}-1]$ 的双射。

首先由如下算法：（$x\in [F_n,F_{n+1}-1]$）

1. 找到最大的 $F_i$ 满足 $F_i\le x$。

2. 将 $F_i$ 加入 $A$。

3. 将 $x$ 减去 $F_i$，并回到第 1 步，直到 $x=0$。

可以得到一个 $x$ 的 "Fib真表示" $A$，且 $A\in S_n$，证明：

- 首先这个算法是可以结束的，因为不能结束当且仅当第一步找不到，考虑到 $F_1=1$ 是最小的正整数，这是不可能的。
- 下面证明 $A$ 应该是一个集合，假设不是（$A$ 是可重集），则找到最大的 $i$ 在 $A$ 中出现 $k(k>1)$ 次，考虑到在加入它们之前的 $x$ 满足 $\lfloor \frac{k}{2}\rfloor F_{i+1}<kF_i\le x$，因此算法会先减去 $\lfloor \frac{k}{2}\rfloor$ 个 $F_{i+1}$，这一定会使 $i$ 出现的次数减少，矛盾。我们证明了 $A$ 是一个 “Fib表示"。
- 下面证明 $A$ 是一个 "Fib真表示"，假设不是，找到最大的 $i$ 满足 $i,i+1\in A$，则 $i+2\not\in A$ （$i$ 的最大性），而在加入 $i,i+1$ 之前算法会优先选择 $i+2$，矛盾。
- 最后证明 $A\in S_n$，这很显然啊，因为 $x\in [F_n,F_{n+1}-1]$。

因此 $f$ 是一个满射。

其次，考虑若存在 $A_1,A_2$ 都是 $x$ 的 "Fib真表示"，找到最大的 $p$ 使得 $[p\in A_1]\not= [p\in A_2]$，不妨设 $p\in A_1$ 且 $p\not\in A_2$，易证 $\sum_{i=1}^{p-1} [i\in A_2]F_i<F_1+F_3+\cdots+F_{2\lfloor \frac{p}{2}\rfloor-1}=F_{2\lfloor \frac p2\rfloor}-1<F_p-1$，这说明 $f(A_1)=f(A_2)$ 是不可能成立的。

因此 $f$ 是一个单射，结合其是满射的事实，证毕。

因此，所有 "Fib真表示" 和所有正整数都是 “一一对应” 的。

### Theorem 2

$n$ 的所有 "Fib表示" 都是由其 "Fib真表示" $A$ 通过如下操作得到的：随便找一个 $i$ 满足 $i\in A, i-2\not\in A$，删掉 $i$，将 $i-1,i-2$ 加入到 $A$ 中。

证明很简单，通过一个 "Fib表示" $B$，一定可以找到一个 "Fib真表示" $C$ 进行若干次操作得到它，具体操作就是每次找到一个 $i$ 满足 $i, i+1\in B, i+2\not\in B$，将 $i,i+1$ 删了把 $i+2$ 放进去。考虑到 $C=A$，因此证毕。

### 题目解法

找到 $n$ 的 "Fib真表示" $A$，设 $f_{i,0/1}$ 表示对 $a_1,a_2,\cdots,a_i$ 操作能够有多少方案，并钦定 选择/不选择 $a_i$。

转移方程十分简单：

$$ \left\{ \begin{aligned} & f_{i,0}=f_{i-1,0}+f_{i-1,1} \\ & f_{i,1}=\lfloor\frac{a_i-a_{i-1}-1}{2}\rfloor f_{i-1,0}+\lfloor \frac{a_i-a_{i-1}}{2}\rfloor f_{i-1,1} \end{aligned} \right. $$

时间复杂度 $O(\log n)$。

# 代码

```cpp
#include <cstdio>

typedef long long ll;
ll read()
{
    ll ret = 0; char c = getchar();
    while (c < '0' || c > '9') c = getchar();
    while (c >= '0' && c <= '9') ret = ret * 10 + c - '0', c = getchar();
    return ret;
}

ll F[100], N, dp[100][2];
int a[100];

int main()
{
    scanf("%lld", &N);
    F[1] = 1, F[2] = 2; int i, j;
    for (i = 3; i <= 86; ++i) F[i] = F[i - 1] + F[i - 2];
    ll NN = N;
    for (i = 86; i >= 1; --i)
    {
        if (F[i] <= NN) a[i] = 1, NN -= F[i];
        else a[i] = 0;
    }
    j = 0; dp[0][0] = 1;
    for (i = 1; i <= 86; ++i)
    {
        if (!a[i]) { dp[i][0] = dp[i][1] = 0; continue; }
        dp[i][0] += dp[j][0] + dp[j][1];
        dp[i][1] += dp[j][0] * ((i - j - 1) / 2) + dp[j][1] * ((i - j) / 2);
        if (a[i]) j = i;
    }
    printf("%lld\n", dp[j][0] + dp[j][1]);
    return 0;
}
```



