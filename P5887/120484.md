（大概是~~去世的~~NOIP.PJ T1难度


------------


由题意可知，兔子爬过的格子是一个环，**移动方式是（当前位置+k）%n**。

由此可见每一只兔子的移动方式都是同样的，所以**当一只兔子跳到一个曾经跳过的位置，便意味着接下来的位置也都被之前跳跃过了**。
。
所以我们可以~~口胡~~发现，当移动到的位置被经过时，就不需往下进行下去了。

在这里，我们用一个bool数组进行标记是否走过该位置，设定一个总数ans=n,每走过一个没有经过的格子，ans--，最后的结果自然便是不可能走过的格子数。

# Code：
```cpp
#include <cstdio>
int n,m,k,ans;
bool v[1000010];
int main()
{
	scanf("%d%d%d",&n,&m,&k);
	ans=n;
	for(int i=1;i<=m;i++)
	{
		int a;
		scanf("%d",&a);
		while(!v[a])
		{
			v[a]=1;
			ans--;
			a=(a+k)%n;
		}
	}
	printf("%d\n",ans);
	return 0;
}
```
~~口胡完成！~~