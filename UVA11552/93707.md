做题背景：在英语课上颓蓝书，看到了这题然后花十几分钟搞出了正解，然后就在机房调了快一个小时……

来个详细点的解题报告，这题还是挺注重思路的。



------------

### 题意

给你一个长度 $k$ ，一个字符串 $S$ ，保证 $S$ 的长度为 $k$ 的整数倍。

将 $S$ 按顺序分为 $S/k$ 组，每组组内字符可在组内自由换位。

称一段连续的、各字符相等的字符段为 “ 块 ” （如 " aaa " ），

求换位后的字符串最少的 “ 块 ” 数。


------------

### 思路

首先，在每一个组内**将相同的所有字符合并为一个块一定是最优的**。

证明：

- 如果不考虑这一组的前后情况，那么拆散一个块相当于在无任何贡献的情况下让答案加一，显然更劣。

换言之，在 $k$ 等于 $S$ 长度的情况下，把所有相同的字符合并会使得答案达到下界，也就是 “  $S$  中出现了多少个不同的字符 ”，这一定是一个组内最小的答案。

但你肯定会想：“ 可是这题里又不止一个组，我就不能**把一个块拆成两个，一个放组头一个放组尾**吗？虽然答案加一了，但可以造福后面的组啊？ ”

然而，这么做并不会使答案更优，理由是：

- 将一个块拆成两个的代价为 1 ，但最好情况下只能 “ 造福 ” 其后面的一个组，贡献也为 1 ，所以不会比完全不拆更优。

综上，我们就可以把一个字符串组抽象为一个简单的最小代价，以及其另一个影响答案的元素——首尾部分。

（ 敲黑板 ）

现在在我们眼里，一个字符串组其实由这些组成：

- 一个集合 $A$ ，为这个组内不同的字符。
- 代价 $v$ ，数值上等于 $A$ 的大小。
- 首字符 $l$ 与尾字符 $r$ 。

对于两个相邻的字符串组，其代价减一当且仅当 $r_i=l_{i+1}$ 。

……那这就是个很裸的动态规划了是吧。

设 $f_{i,j}$ 为第 $i$ 组以字符 $j$ 结尾时最小的代价，则有：

1. 若存在字符 $u$ 同时存在于第 $i-1$ 与第 $i$ 组中，则可以更新第 $i$ 组中所有除 $u$ 之外的字符作为结尾时的代价，即

$f_{i,x}=min(f_{i,x} , f_{i-1,u}+v_i-1),x \neq u$

当然这种情况要特判 $v=1$ ，此时组内只有一个块，所以这个块被迫同时担上了 $l,r$ 的大任。

2. 若存在字符 $u$ 仅存在于第 $i-1$ 组中，则更新第 $i$ 组中所有存在的字符作为结尾时的代价，即

$f_{i,x}=min(f_{i,x} , f_{i-1,u}+v_i)$

设组数为 $n$ ，则时间复杂度为 $O(26^2n)$，而 $n=length(S)/k$，最坏是 $1000$ ；而 $26^2=676$ ，所以总的数据范围在 $1e3$ 内，而我们的算法的时间复杂度在这种情况下与 $O(n^2)$ 同阶，足够优秀。



------------

### 代码

```cpp
#include<bits/stdc++.h>
#define ll long long
#define R read()
#define file(a) freopen(#a".in","r",stdin),freopen(#a".out","w",stdout)
using namespace std;
inline ll read() {
	ll s=0,f=1;
	char ch=getchar();
	while(ch<'0'||ch>'9') {
		if(ch=='-')f*=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9') {
		s=s*10+ch-'0';
		ch=getchar();
	}
	return s*f;
}//快读
inline char readle(){
	char ch=getchar();
	if(ch>='a'&&ch<='z')return ch;
	else return '!';
}//在本题中读入字符串用
inline void write(ll x) {
	if(x<0) putchar('-'),x=-x;
	if(x>9) write(x/10),x%=10;
	putchar('0'+x);
}//Don't use it for CF.
inline void wk(ll x){write(x);putchar(' ');}
inline void we(ll x){write(x);putchar('\n');}
ll T;
signed main(){
	T=R;
	while(T--){
		ll k=R,tot=0;//R是快读，见上
		bool a[1005][30];//为了防止多测不清空惨案，将数组开在主函数内，其他题别这么干
		ll f[1005][30],b[1005],cnt=1;//f的前一维为组数，后一维为结尾的字符(大小只有26)
		char c[1005],ch=readle();
		while(ch!='!')c[++tot]=ch,ch=readle();//读入，见上面的函数
		memset(a,0,sizeof(a));
		memset(b,0,sizeof(b));
		memset(f,0x3f3f3f3f,sizeof(f));//将动规函数全部置为INF
		for(ll i=1;i<=tot/k;i++){
			for(ll j=1;j<=k;j++){//处理字符组
				if(!a[i][c[cnt]-'a'+1]){
					a[i][c[cnt]-'a'+1]=1;//标记该组内有这个字符
					b[i]++;//该组内之前未出现过该字符，代价加一
				}
				cnt++;
			}
		}
		for(ll i=1;i<=26;i++)a[0][i]=1,f[0][i]=1;//初始化，我们设第0组的开头“啥都能接”，且自带1代价，这是为了处理第1组的连接
		for(ll i=1;i<=tot/k;i++){//枚举组数
			for(ll j=1;j<=26;j++){//枚举字符j
				if(a[i-1][j]&&a[i][j]){//j存在于前后两组中
					for(ll u=1;u<=26;u++){//更新结尾
						if(a[i][u]&&(j!=u||b[i]==1)){//更新所有非j结尾的代价，但该组只有一个块时除外
							f[i][u]=min(f[i][u],f[i-1][j]+b[i]-1);
						}
					}
				}
				else if(a[i-1][j]){//j仅存在于前一组中
					for(ll u=1;u<=26;u++){
						if(a[i][u]){//更新所有代价
							f[i][u]=min(f[i][u],f[i-1][j]+b[i]);
						}
					}
				}
			}
		}
		ll ans=0x3f3f3f3f;
		for(ll i=0;i<=27;i++)ans=min(ans,f[tot/k][i]);//在最后一组里找答案
		we(ans);//换行输出，见上
	}
	return 0;
}
```
