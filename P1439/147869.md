前台查看
|
H1
H2
H3
H4
H5
H6
|
|
|
|

1
# 这道题虽然是道模板题,but
2
## 异常套路！！！！！！
3
#### 先见说一说刚拿到这道题时候的想法吧，因为这是学校训练时候的老师发的题，做这道题之前做过一道类似的求最长公共子序列的题
4
###### 有想法的和我一样的蒟蒻可以先看一看```
5
## 最长公共子序列
6
## 【问题描述】
7
## 一个给定序列的子序列是在该序列中删去若干元素后得到的序列。确切地说，若给定序列X=<x1, x2,…, xm>，则另一序列Z=<z1, z2,…, zk>是X的子序列是指存在一个严格递增的下标序列 <i1, i2,…, ik>
8
 
9
### 例如，序列Z=<B,C,D,B>是序列X=<A,B,C,B,D,A,B>的子序列，相应的递增下标序列为<2,3,5,7>。给定两个序列X和Y，当另一序列Z既是X的子序列又是Y的子序列时，称Z是序列X和Y的公共子序列。例如，若X=<A, B, C, B, D, A, B>和Y=<B, D, C, A, B, A>，则序列<B, C, A>是X和Y的一个公共子序列，序列<B, C, B, A>也是X和Y的一个公共子序列。而且，后者是X和Y的一个最长公共子序列，因为X和Y没有长度大于4的公共子序列。
10
### 给定两个序列X=<x1, x2, …, xm>和Y=<y1, y2, … , yn>，要求找出X和Y的一个最长公共子序列。
11
### 【输入】
12
### 输入文件共有两行，每行为一个由大写字母构成的长度不超过200的字符串，表示序列X和Y。
13
### 【输出】
14
### 输出文件仅一行为一个非负整数，表示所求得的最长公共子序列的长度，若不存在公共子序列，则输出文件仅有一行输出一个整数0
15
### 【样例】
16
### 输入：
17
### abcdefghijklmn
18
### kxmdyfliju
19
### 输出：
20
### 4
21
​
22
```
23
```
24
## 如果你已经很轻松的解决了上面的题，那么恭喜你！！！
25
# 你可能会被它误导！
26
### 本蒟蒻就是如此，对这道题我进行了四次修正，我称之为基准无优化版，转字符无优化版，空间优化版，以及最终版本！
27
#### 话不多说，上代码，通过在四段代码中插入的讲述，我想作为蒟蒻，应该能成为一名小小牛……
28
## 基准无优化版……
29
###这道题虽然是道模板题,but
####异常套路！！！！！！
####先见说一说刚拿到这道题时候的想法吧，因为这是学校训练时候的老师发的题，做这道题之前做过一道类似的求最长公共子序列的题

####有想法的和我一样的蒟蒻可以先看一看```

####最长公共子序列
#####【问题描述】
###一个给定序列的子序列是在该序列中删去若干元素后得到的序列。确切地说，若给定序列X=<x1, x2,…, xm>，则另一序列Z=<z1, z2,…, zk>是X的子序列是指存在一个严格递增的下标序列 <i1, i2,…, ik>
###例如，序列Z=<B,C,D,B>是序列X=<A,B,C,B,D,A,B>的子序列，相应的递增下标序列为<2,3,5,7>。给定两个序列X和Y，当另一序列Z既是X的子序列又是Y的子序列时，称Z是序列X和Y的公共子序列。例如，若X=<A, B, C, B, D, A, B>和Y=<B, D, C, A, B, A>，则序列<B, C, A>是X和Y的一个公共子序列，序列<B, C, B, A>也是X和Y的一个公共子序列。而且，后者是X和Y的一个最长公共子序列，因为X和Y没有长度大于4的公共子序列。
###给定两个序列X=<x1, x2, …, xm>和Y=<y1, y2, … , yn>，要求找出X和Y的一个最长公共子序列。
###【输入】
###输入文件共有两行，每行为一个由大写字母构成的长度不超过200的字符串，表示序列X和Y。
###【输出】
###输出文件仅一行为一个非负整数，表示所求得的最长公共子序列的长度，若不存在公共子序列，则输出文件仅有一行输出一个整数0
###【样例】
###输入：
###abcdefghijklmn
###kxmdyfliju
###输出：
###4
###如果你已经很轻松的解决了上面的题，那么恭喜你！！！
###你可能会被它误导！
###本蒟蒻就是如此，对这道题我进行了四次修正，我称之为基准无优化版，转字符无优化版，空间优化版，以及最终版本！
###话不多说，上代码，通过在四段代码中插入的讲述，我想作为蒟蒻，应该能成为一名小小牛……

##基准无优化版……
```cpp
#include<iostream>
#include<cmath>
#include<cstring>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
const int maxn=8000;
string x,y; 
int a[maxn],b[maxn];//利用上面那道题的思路.
int f[maxn][maxn];//存储i位X字符串和j位Y字符串的公共最长子序列的长度
int main()
{
    //freopen("numlcs.in","r",stdin);
    //freopen("numlcs.out","w",stdout);
    int n;
    cin>>n;
    for(int i=1;i<=n;i++)
      cin>>a[i];
    for(int i=1;i<=n;i++)
      cin>>b[i];
    //简单的读入
    for(int i=0;i<=n;i++)
      f[i][0]=0;
    for(int j=0;j<=n;j++)
      f[0][j]=0;
    //当x,y任意一个字符串的长度为零时候，那么公共子序列即为零。
    for(int i=1;i<=n;i++)
      for(int j=1;j<=n;j++)
      {
        if(a[i]==b[j])//若此时俩字符串的末尾字符相同，则冻柜方程容易写出
          f[i][j]=f[i-1][j-1]+1;
        else
          f[i][j]=max(f[i-1][j],f[i][j-1]);
          //如果不相等，那么分为两种情况，1字符串前移一位，2号不变时候的公共子序列长度和反之的长度比较，取长者。
      }
      printf("%d",f[n][n]);//结果就出现在了f[n][n]啦！果断输出
      //system("pause");
      return 0;
}
```

###上面代码看着没什么毛病，但是为什么说是不成熟的呢？

##问题在于冻柜方程以及对问题的分析。
#至于第二种做法转字符版本，，，，只是对输入进行了处理，就不再赘述了
```cpp

    int n;
    cin>>n;
    for(int i=1;i<=n;i++)
      cin>>a[i];
    for(int i=1;i<=n;i++)
      cin>>b[i];
    for(int i=1;i<=n;i++)
    {  
      x+=(a[i]+'0');
      y+=(b[i]+'0');
    }
    string c,v;
    c=x;
    v=y;       
    int len1=c.length()-1;
    int len2=v.length()-1;
    for(int i=0;i<=len1;i++)
      f[i][0]=0;
    for(int j=0;j<=len2;j++)
      f[0][j]=0;
    for(int i=1;i<=len1;i++)
      for(int j=1;j<=len2;j++)
      {
        if(c[i]==v[j])
          f[i][j]=f[i-1][j-1]+1;
        else
          f[i][j]=max(f[i-1][j],f[i][j-1]);
      }
      printf("%d",f[len1][len2]);
##下面才是大场面的开始……
cin>>n;
    for(int i=1;i<=n;i++)
      cin>>a[i];
    for(int i=1;i<=n;i++)
      cin>>b[i];
    for(int i=0;i<=n;i++)
      f[i%2][0]=0;
    for(int j=0;j<=n;j++)
      f[0][j]=0;
    for(int i=1;i<=n;i++)
      for(int j=1;j<=n;j++)
      {
        if(a[i]==b[j])
          f[i%2][j]=f[(i+1)%2][j-1]+1;
        else
          f[i%2][j]=max(f[(i+1)%2][j],f[i%2][j-1]);
      }
      printf("%d",f[n%2][n]);
      ```
###在这段代码中对冻柜转移方程虽然没有进行调整，但是对空间进行了一定程度的压缩，对本题n<=100000的大数据有了一战之力

###那么真正的地方begin！
#先来举一个栗子吧:
#[思路讲解]
##在读入第一行数据时候，我们使用一个数组A[i]记录读入的第X个数据i的位置，记录其是X，那么对于第一行数据A[i]的值是单调递增的。说到这里，有些人应该也已经有一些思路了，如果你走到了这里似懂非懂，我建议你最好先自己思考，不妨去做一做洛谷的友好城市这道题，相信你会开放你的思路。
##ok，下面，在读入第二行数据时候，根据所读入的数字，在A数组中找到其在第一行数据中的位置，进行记录，
##用样例数据来讲：
##5
##第一行数据    3	2	1	4	5
##第二行数据	1	2	3	4	5
##A数组分别这样记录：A[3]=1,A[2]=2,A[1]=3,A[4]=4,A[5]=5;
##那么在第二行数据读入时,根据其数字可以在A数组中得到这样一个序列：
##3 2 1 4 5 注意！这个3 2 1 4 5并非是上方数据，仅仅是数据设计的巧合罢了，
##对于这个新的数列，我们在其中求最长上升序，其长度就是我们的目标。
##之所以能这么说，大家应该注意题中告诉我们的一个看似不重要又极其重要的条件：每行为n个数，为自然数1-n的一个排列。
##这说明，上下两行数字数量相等，且每行数据不存在重复数据，因此说我们上面的思路是可行的
##说了这么多，是时候上AC代码啦（蒟蒻哭泣）
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
const int maxn=300000;
int f[maxn],a[maxn];
int n;
int find(int l,int r,int x)
{
    int ans=0;
    while(l<=r)
    {
       int mid=(l+r)/2;
       if(x<f[mid])
         ans=mid,r=mid-1;
       else
          l=mid+1;
    }
    return ans;
}
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
    {
       int x;
       scanf("%d",&x);
       a[x]=i;
    }
    memset(f,0x3f,sizeof(f));
    int len=0;
    for(int i=1;i<=n;i++)
    {
        int x;
        scanf("%d",&x);
        int y=a[x];
        int k=find(1,len+1,y);
        f[k]=y;
        if(k>len)
           len++;
    }
    printf("%d",len);
    return 0;
}
```
最后留下一个极棒的建议

一定要写好二分！！！！！
飘过链接博客