观察此题的数据范围，如果使用最长公共子序列的传统DP算法（时间复杂度为O(N^2)）肯定会超时，所以，我们需要另寻他路。

考虑此题的另一个条件，两个序列都为1...n的一个排列，考虑特殊情况：

如果其中一个排列为(1,2,...,n)，另一个排列为(a1,a2,...,an)，那么对于两者的任意公共子序列(a[b1],a[b2],...,a[bk])，必有a[b1]<a[b2]<...<a[bk]，则两序列的最长公共子序列为排列(a1,a2,...,an)的最长上升子序列。

那么，对于两个一般的排列(a1,a2,...,an)和(b1,b2,...,bn)的最长公共子序列怎么求？

我们定义映射f(ai)=i，那么两个排列可以转换为(f(a1),f(a2),...,f(an))=(1,2,...,n)和(f(b1),f(b2),...,f(bn))，我们进行这样的转换之后，就把本题转换为求最长上升子序列的长度的题目了。

最长上升子序列存在O(N log N)时间复杂度的算法，概述如下：

考虑两个数a[x]和a[y]，若x<y且g[x]==g[y]，那么在转移的过程中，选择a[x]更有潜力（证明是显而易见的，可以自己设计几组数据加深理解），可以获得最优的值，所以当g数组的值一样时，应选择最小的数。

按照g[i]==k分类，记录g[i]==k的所有i的最小值，g有两个特点：

1)f[i]在计算过程中单调不升

2)f数组是有序的，g[i]<=g[i+1]

根据这些性质，可以方便地求解：

1)设当前求出的LIS（最长上升子序列的简称，以后同此）长度为ans（初始值为1），当前元素为a[x]

2)如果a[x]>g[ans]，直接加入f数组的末尾，且ans++；否则在f数组中二分查找，找到第一个比a[x]小的数字g[k]（使用二分查找实现），g[k+1]=a[x]，这样做保证a[x]<=g[k+1]（根据性质1，2）

3)最后的ans即为答案

总的时间复杂度为处理映射O(N)，求LIS长度为O(N log N)，总的时间复杂度为O(N log N)，如果常数不是特别大的话可以通过此题。

代码：

```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
const int maxn=100010;
int n,a[maxn],f[maxn],g[maxn],ans=1,cur;
inline int bs(int k,int l,int r)//二分查找
{
    while(l<r)
    {
        int mid=(l+r)>>1;
        if(k>=g[mid])l=mid+1;
        else r=mid;
    }
    return l;
}
int main()
{
    scanf("%d",&n);
    for(register int i=1;i<=n;i++)scanf("%d",a),f[a[0]]=i;//建立映射关系
    for(register int i=0;i<n;i++)scanf("%d",a+i),a[i]=f[a[i]];//输入并同时处理映射
    g[1]=a[0];
    for(register int i=1;i<n;i++)
    {
        if(g[ans]<a[i])cur=++ans;
        else cur=bs(a[i],1,ans+1);
        g[cur]=a[i];
    }
    printf("%d\n",ans);
    return 0;
}
```
最后我们来总结一下解决此类题目（有现成的算法，但是时间复杂度较高，需要通过限制较为严格的特殊条件，需要转化数学模型求解，类似题目为无序字母对）的思路：

1)观察题目的数据范围，看传统思路算法能否通过

2)从题目给出的特殊条件入手，转化数学模型（从一个经典模型转化为另一个经典模型，常用方法为映射和图论中的点化边），降低求解算法的时间复杂度
