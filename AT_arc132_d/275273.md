提供一个 dp 思路。

下文设串长为 $n$，串中 $1$ 个数为 $m$。

考虑如何求 $d(s, t)$。设 $s$ 的 $1$ 位置分别为 $a_1, a_2, ..., a_m$，$t$ 的 $1$ 位置分别为 $b_1, b_2, ..., b_m$。那么 $d(s, t) = \sum\limits_{i=1}^m |a_i - b_i|$。

更进一步地，对于串 $s'$，设 $s'$ 的 $1$ 位置分别为 $c_1, c_2, ..., c_m$，那么 $\forall i \in [1, m], c_i \in [\min(a_i, b_i), \max(a_i, b_i)]$ 是 $d(s, s') = d(s', t)$ 的充要条件。设 $l_i = \min(a_i, b_i), r_i = \max(a_i, b_i)$。

考虑转化题中的 "beauty"，相当于最小化极长同字符连续段个数。

考虑 dp。设 $f_i$ 表示填完前 $i$ 个 $1$ 的最小极长连续段个数。枚举 $j$ 表示第 $j \sim i$ 个 $1$ 放一起，合法当且仅当 $l_i - r_j + 1 \le i - j + 1 \le r_i - l_j + 1$，此时有转移 $f_i = f_{j-1} + 2$，表示先加一段 $0$ 再加一段 $1$。

注意处理开头一段是 $1$ 和末尾一段是 $1$ 的情况。

感性理解，对于每个 $i$，合法的 $j$ 一定形成一个区间，因为不可能 $j_1 \sim i$ 能放一起但是 $j_2 \sim i$ 不能（$j_1 < j_2$）。可以二分得出左端点，然后使用线段树优化。可以做到 $O(n \log n)$，已经可以通过。

更进一步，发现对于每个 $i$，最左合法转移点单调不降。并且由于这个性质，$f_i$ 单调不降。可以双指针维护每个 $i$ 的最左合法转移点，然后 $O(1)$ 转移。总时间复杂度降至 $O(n)$。

[$O(n \log n)$ 的 code](https://atcoder.jp/contests/arc132/submissions/41626274)

[$O(n)$ 的 code](https://atcoder.jp/contests/arc132/submissions/41627023)