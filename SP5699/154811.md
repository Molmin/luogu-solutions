**~~这绝对是我目前为止见过最坑的题~~**

------------
 _**题意：**_ 

给定两个数a(a的长度$\leq1000$)、b(b$\leq 922*$10^15$ $)，要你找出$a^b$的最后一位数字。输入共t组数据。

------------
 _**思路：**_ 

------------

其实就是小学奥数。我们可以发现：

如果a的最后一位为0，那么$a^b$的最后一位数一定是0。

如果a的最后一位为1，那么$a^b$的最后一位数一定是1。

如果a的最后一位数为2，那么$a^b$的最后一位数一定在2、4、8、6中。

如果a的最后一位数是3，那么$a^b$的最后一位数一定在3、9、7、1中。

如果a的最后一位数是4，那么$a^b$的最后一位数一定在4、6中。

如果a的最后一位数是5，那么$a^b$的最后一位数一定是5。

如果a的最后一位数是6，那么$a^b$的最后一位数一定是6.

如果a的最后一位数是7，那么$a^b$的最后一位数一定在7、9、3、1中。

如果a的最后一位数是8，那么$a^b$的最后一位数一定在8、4、2、6中。

如果a的最后一位数是9，那么$a^b$的最后一位数一定在9、1中。

知道了以上的规律，我们就可以**把每个尾数的周期的每个数储存起来**，这时候就只要看b的值了。

以a的尾数为2为例，当b mod 4的值为1（4为a的最后一位数的周期数的数量），那么$a^b$的最后一位数就是2，b mod 4为2，则尾数为4，依次循环。需要注意的是，**当b mod某个数的值为0时，这时的尾数也就是这个周期中的最后一个数**。

------------
需要注意的是，a的长度是小于等于1000的，所以我们要用字符串来读入，这时的最后一位数**就是a[strlen(a)-1]-'0'（字符转数字）**。（本蒟蒻竟然开始没想到这一点，还用了一个高精度求余2333~~）

------------
## ~~坑点大集锦~~

坑点1：

b的值肯定是int装不下的，要开long long啊！

坑点2：

为什么有些人把代码提交上去是UKE？因为SPOJ规定这道题的源文件大小（也就是长度）必须小于等于700字节，如果超过了限制，在洛谷提交是交不上去的，肯定会UKE啊！（害得我压缩到了极致）

------------
```cpp
#include<bits/stdc++.h>
using namespace std;
int i,t,f1,a2[5]={0,2,4,8,6},a3[5]={0,3,9,7,1},a4[3]={0,4,6},a7[5]={0,7,9,3,1},a8[5]={0,8,4,2,6},a9[3]={0,9,1};
char a[1001];long long b;
int main() {
    cin>>t;
    while(t--){
        cin>>a>>b;int f=a[strlen(a)-1]-'0',t1=b%4,t2=b%2;
        if(b==0||f==1)cout<<1;
        else if(f==0)cout<<0;
        else if(f==2)cout<<a2[t1?t1:4];
        else if(f==3)cout<<a3[t1?t1:4];
        else if(f==4)cout<<a4[t2?t2:2];
        else if(f==5)cout<<5;else if(f==6)cout<<6;
        else if(f==7)cout<<a7[t1?t1:4];
        else if(f==8)cout<<a8[t1?t1:4];
        else cout<<a9[t2?t2:2];cout<<endl;
    }
    return 0;
}
```


