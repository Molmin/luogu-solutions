### 这种题竟然没有题解？自己来一发。

这道题的意思就是有一段$0,1$数列$s$，要求每次翻转$>=k$个数字使得所有数全为$0$，求最大的$k$。

~~有没有小学翻杯子问题的既视感~~

这道题其实最后到底是$0$还是$1$不重要，因为最后全部翻一次就好了。所以我们要考虑的是尽量**把所有数改成相同的，而不是把所有数都尽量往0去改**，也就是说只要把所有数都变成相同的就行了。

我们先考虑这种情况，$0011111$怎么翻转？当然直接把$11111$翻转啊。

$1111100$怎么翻转？很简单也是把前$5$位翻转。

推广下，若第$0$~$k$位数字都已经一样了，但是第$k-1$位和第$k$位不一样。那么这时候我们就有两种选择，**要么改0~k-1位，要么改k~n位，对于题目来说这两种操作的效果是等价的**   
题目问的是最大，所以每次操作到第$i$个数直接取$max(i,$长度$-i)$。

大家可以来体会一下

![](https://i.loli.net/2019/03/08/5c814b8f56c69.jpg)

我们每一次操作都保证了前k个数的一致，所以在对第$k+1$个数进行操作完成后可以保证前$k+1$个数是一致的，并且没有改变其他数的**相对情况**。所以这种操作一定可以满足要求。

如果从中间挑一段数$（l,r）$进行修改，那么改的数一定没有$（0，r）,（l，n）$改的数多，虽然修改的次数会少，但不是题目的要求。

所以下面就很简单了，代码很短，不知道为什么是紫题

```
#include <bits/stdc++.h>
using namespace std;
string s;
int ans=1<<30; 
int main()
{
	cin>>s;
	for(int i=1;i<s.length();i++) //一位一位枚举
		if(s[i]!=s[i-1]) //若第i-1位和第i位不一样
			ans=min(ans,max(i,int(s.length())-i)); 
            //因为每次要改动更多的，所以取max,因为所有操作都要>=k所以ans取最小。
	cout<<min(ans,int(s.length()))<<endl; //ans不大于s的长度
	return 0;
}


```

