### 1.题目思路

首先根据 $ \text{mex}(l,r) $ 的定义，可以发现一个很显然的性质。

> 对于一个不包含 $ 0 $ 的连续串，其 $ \text{mex} $ 一定为 $ 0 $。
>>因为在该连续串中最小的未出现的非负整数一定为 $ 0 $。

那么是不是就意味着我们只需要统计不包含 $ 0 $ 的不可扩展的连续串的个数呢？

考虑同时存在多个非零连续串的情况，如下：

$$ 0\;10\;2\;3\;4\;0\;2\;0\;1\;2\;6 $$

根据之前的思路，我们需要进行三次操作才能把序列变为全 $ 0 $。

$$ \text{opt}(2,5) : 0\;0\;0\;0\;0\;0\;2\;0\;1\;2\;6 $$

$$ \text{opt}(7,7) : 0\;0\;0\;0\;0\;0\;0\;0\;1\;2\;6 $$

$$ \text{opt}(9,11) : 0\;0\;0\;0\;0\;0\;0\;0\;0\;0\;0 $$

但最开始想操作性质的时候，我们只考虑了区间 $ \text{mex} $ 为 $ 0 $ 的情况，那区间 $ \text{mex} $ 不为 $ 0 $ 的情况呢？

这样考虑后，我们可以发现对某一个包含 $ 0 $ 的区间执行操作后，整个区间会变成**单独一个**不包含 $ 0 $ 的区间，我们再对这个区间进行一次操作，区间就会变为一个全部为 $ 0 $ 的区间。例子如下：

$$ 0\;10\;2\;3\;4\;0\;2\;0\;1\;2\;6 $$

$$ \text{opt}(1,11) : 5\;5\;5\;5\;5\;5\;5\;5\;5\;5\;5 $$

$$ \text{opt}(1,11) : 0\;0\;0\;0\;0\;0\;0\;0\;0\;0\;0 $$

那么对**整个序列**(同样满足上述性质)执行该操作，最多两次即可完成。

我们就可以完美的解决本题了。

### 2.代码

```cpp
#include<map>
#include<cmath>
#include<queue>
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;
const int N=300005;
int a[N];
void solve()
{
	int n,ans=0;
	scanf("%d",&n);
	for(int i=1;i<=n;i++) scanf("%d",a+i);
	int l=1,r=n;
	while(l<=n && a[l]==0) l++;
	while(r>=1 && a[r]==0) r--;
	if(l>r) return void(puts("0"));
	for(int i=l;i<=r;i++) if(a[i]==0) ans++;
	cout<<min(2,ans+1)<<endl;
}
int main()
{
	int _test__Case;
	scanf("%d",&_test__Case);
	while(_test__Case--)
	{
		solve();
	}
}
```

