对于这道题，我们有一个很显然错误的贪心做法：

- 每次选择一段尽可能长的包含 $0$ 的区间，对这个区间进行一次操作。显然的，这个区间内的所有数字都会变成 $0$。

我们拿可爱的样例举个例子：

`0 2 3 0 1 2 0`

1. 对 $[2,3]$ 区间进行一次操作，$w=\operatorname{mex}(\{2,3\})=0$，所以 $a_2 \to 0,a_3 \to 0$，序列变成 `0 0 0 0 1 2 0`。

1. 对 $[5,6]$ 区间进行一次操作，$w=\operatorname{mex}(\{1,2\})=0$，所以 $a_5 \to 0,a_6 \to 0$，序列变成 `0 0 0 0 0 0 0`。

总共需要 $2$ 次操作。

容易发现，如果按照这种贪心做法，那么答案应该是数组中出现的 $0$ 的数量 $-$ 开头出现的 $0$ 的数量 $-$ 结尾出现的 $0$ 的数量 $+1$。

在上面那个例子中，答案就是 $3-1-1+1=2$。

既然这个贪心做法是错的，那么我们就要举出一个反例：

`1 0 2 0 3`

根据上面那个贪心做法，答案应该是 $2-0-0+1=3$，但实际上，我们可以通过如下操作使操作次数只有两次：

1. 对 $[1,5]$ 区间进行一次操作，$w=\operatorname{mex}(\{1,0,2,0,3\})=4$，所以 $a_1 \to 4,a_2 \to 4,a_3 \to 4,a_4 \to 4,a_5 \to 4$，序列变成 `4 4 4 4 4`。

1. 对 $[1,5]$ 区间进行一次操作，$w=\operatorname{mex}(\{4,4,4,4,4\})=0$，所以 $a_1 \to 0,a_2 \to 0,a_3 \to 0,a_4 \to 0,a_5 \to 0$，序列变成 `0 0 0 0 0`。

于是我们考虑对这个贪心算法进行修正：我们发现，不管是什么样的数组，我们都可以通过对 $[1,n]$ 操作两次使得所有元素归零，于是我们只需要把贪心算法的答案对 $2$ 取个 $\min$ 即可。

代码：

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int read(){
	int x=0,f=1;
	char c=getchar();
	while(c<'0'||c>'9'){
		if(c=='-') f=-1;
		c=getchar();
	}
	while(c>='0'&&c<='9'){
		x=(x<<1)+(x<<3)+c-'0';
		c=getchar();
	}
	return x*f;
}
int b[100005];
void cf(){
	int n=read();
	int a[n+1];
	for(int i=1;i<=n;i++)
		a[i]=read();
	int cnt=0;
	for(int i=1;i<=n;i++)
		b[i]=0;
	for(int i=1;i<=n;i++){ //这里我的实现方法稍微有一点不一样，大家理解即可
		if((a[i]==0&&b[cnt]==0)||(a[i]!=0&&b[cnt]!=0)) continue;
		cnt++;
		b[cnt]=a[i];
	}
	if(b[cnt]==0) cnt--;
	if(b[1]==0) cnt--;
	printf("%d\n",min(2,(cnt+1)/2));
	return;
}
int main(){
	int t=read();
	for(int i=1;i<=t;i++)
		cf();
	return 0;
}
```
