## 题意

$n$ 个人排成一排，你排在第 $m$ 个。

每轮队首的人投一次骰子。

- 若掷到 $1$，则队首的人获胜。
- 若掷到 $2,4,6$，则队首的人排到队尾。
- 若掷到 $3,5$，则队首的人出队。

若队列中仅剩一人，则该人获胜，求你获胜的概率。

## 解法

一道套着期望 DP 题的方程题（

为方便理解，接下来的 $f_{i,j}$ 均记作 $f(i,j)$，我们用它表示队列中有 $i$ 个人时第 $j$ 个人获胜的几率，这时候就考虑边界条件，也就是 $f(1,1)=1$——当只有一个人的时候，他一定会胜利，不难发现一定有 $j\le i$。接着我们要考虑状态转移方程。

- 如果投掷出 $1$ 了，就有 $\tfrac{1}{6}$ 的概率会输掉这场游戏。
- 如果投掷到 $2,4,6$，则有 $\frac{1}{2}$ 的概率会转移到队尾，也就是 $f(i,j-1)$。
- 如果投掷到 $3,5$，则有 $\frac{1}{3}$ 的概率会队头出队，向前走一步，转移到 $f(i-1,j-1)$。

由于我们只考虑胜率，所以第一种情况不计入 DP。同时我们注意到这个 DP 序列可能形成环，所以不能直接上手操作，应该怎么办呢？按照题目要求有 $n$ 个人，我排在第 $m$ 个，此时我们要求 $f(n,m)$，然后我们知道他有  $\frac{1}{2}$ 的概率转移到 $f(n,m-1)$，有 $\frac{1}{3}$ 的概率转移到 $f(n-1,m-1)$，所以可以推导出：

$$f(n,m)=\frac{1}{2}f(n,m-1)+\frac{1}{3}f(n-1,m-1)$$

这样循环往复，最后会找到 $f(n,1)$ 的情况，这种情况下我们会有 $\frac{1}{6}$ 的情况胜利，有 $\frac{1}{2}$ 的机会转移到队尾 $f(n,n)$，另有 $\frac{1}{3}$ 的机会输掉，所以 $f(n,1)=\frac{1}{6}+\frac{1}{2}f(n,n)$。在之后类似的推到可以推广到 $n-1,n-2,\cdots,1$ 的所有情况——我们就会建立这么多个循环往复的等式，这是一个连续的多元一次方程组，是容易解决的，考虑观察一下系数，然后就可以用代入消元法解决了。

## 代码

```cpp
#include<bits/stdc++.h> 
using namespace std;
int n,m;
double f[1005][1005];
int main(){
	cin>>n>>m;
	f[1][1]=1;
	for(int i=2;i<=n;i++){
		double s=0.5,t=1.0/6.0;
		for(int j=2;j<=i;j++){
			s=s/2;
			t=t/2+f[i-1][j-1]/3;
		}
		f[i][i]=t/(1-s);
		f[i][1]=f[i][i]/2+1.0/6.0;
		for(int j=2;j<i;j++)
			f[i][j]=f[i][j-1]/2+f[i-1][j-1]/3;
	}printf("%.9lf",f[n][m]);
	return 0;
} 
```