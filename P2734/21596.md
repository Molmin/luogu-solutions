序列 sl[] 4 7 2 9 5 2

考虑用f[i][j]来表示在i,j这段区间内先手能获得的最大分数;

那么后手在先手最优方案走法下,按最优方案走的最大分数就是

i,j这个区间总分数减去f[i][j].

那么,我们可以先处理出长度为一的区间,再处理长度为二的,

再三,再四......以此类推,

怎么处理呢? 想,对于先手，他每次可以从左端取数,也可以从右端取数

这里只分析左端的情况, 右端的大家脑补一下233和左端一样

当我们要求f[k][l]的时候,且此时我们先手要取的是sl[k],那么,

用k,l中后手的分加sl[k],就是现在先手的分,这里要注意为什么是后手;

因为我们在这里总把正要进行操作的人看为先手,所以每走一步,先后手互换

左端右端都这样操作,取MAX就好了
例:

| 4 | 7 | 2 | 9 | 5 | 2 |
| -----------: | -----------: | -----------: | -----------: | -----------: | -----------: |
|  |  | k | k+1 | l |  |


    f[k+1][l]=7->f[k][l]=2+9+5-7+7=16



------------


```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
using namespace std;
int n,sum=0;
int sl[1010];
int f[1001][1010];
void ini()
{
    for(int i=1;i<=n;i++)
    {
        f[i][i]=sl[i]-sl[i-1];   //一点初始化，对于长度为一的区间先手得分自然就是这样啦； 
    }
}
void dp()
{
    for(int i=2;i<=n;i++)
    {
        int l;
        for(int k=1;k<=n-i+1;k++)
        {
            l=k+i-1;
            f[k][l]=max(sl[l]-sl[k]-f[k+1][l]+sl[k]-sl[k-1],sl[l-1]-sl[k-1]-f[k][l-1]+sl[l]-sl[l-1]);
		}//求值过程，上面讲了，自己在领悟一霎233
    }
}
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
    {
        scanf("%d",&sl[i]);
        sl[i]+=sl[i-1]; //求了个前缀和，方便计算一点 
    }
    ini();
    dp();
    printf("%d %d",f[1][n],sl[n]-f[1][n]);
    return 0;
}
```


------------

rp++