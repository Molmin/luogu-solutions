这题居然长得和[我的题目](https://www.luogu.org/problemnew/show/U73314)如此的相似，我太厉害了！

题解里都是区间DP，而且状态定义雷同，我就发一个状态定义不同的方法。

---
这种定义方法是，f[i][j]=起点为i，长度为j时，先手分数-后手分数的最大值。(请注意这里的长度=终点-起点，也就意味着终点在i+j）

那么就有2种情况：
- 从左边取，f[i][j]=a[i]-f[i+1][j-1]
- 从右边取，f[i][j]=a[i+j]-f[i][j-1]

因此我们就可以写了。

---
所以这样的改变有什么用吗？

我们发现，如果我们采用这样的状态定义，每次只会用到上一级的结果，于是我们就可以进行滚动数组优化。

这点优化在本题中是看不出来的，但是在我出的题目里就有明显的表现。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,dp[205][2],a[205],tot=0;
int main()
{
    cin>>n;
    for(int i=1;i<=n;i++)
    {
        scanf("%d",&a[i]);
        dp[i][0]=a[i];
        tot+=a[i];//tot记录和
    }
    for(int i=1;i<n;i++)//长度枚举
    {
        for(int j=1;j+i<=n;j++)//起点枚举
        {
            dp[j][i&1]=max(a[j+i]-dp[j][1-(i&1)],a[j]-dp[j+1][1-(i&1)]);
        }
    }
    printf("%d %d",(tot+dp[1][1-(n&1)])>>1,(tot-dp[1][1-n&1])>>1);//小学奥数的和差问题
    return 0;
}
```