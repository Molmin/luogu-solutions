~~为什么我的动态转移方程和各位大佬都不大一样呢QAQ~~

## [传送门](https://www.luogu.org/problem/P2734)

## 一点思路
### 思路一：min-max博弈树
~~其实是因为博弈论才刷这道题的Orz~~

因为在玩家2的回合，玩家2取什么数字，玩家1是拿不到分的，所以从下往上，第1，3，5......奇数个标上分，偶数标0分

从上往下递归，刚开始是分成左右两边，分别表示取左边和右边，同时标上num数组的数值

上一步完成后，从下往上，偶数个（从1开始算层数）都标成0

然后用min-max的标准程序完美的AC这道题

![这课博弈树像这样](https://cdn.luogu.com.cn/upload/image_hosting/8gx3wdzd.png)

......直到你看了一眼数据（这么小的数据应该DFS都能过）

这样的时间复杂度就是 O($2^{n-1}$)，我甚至都能够想象看到这道题的同学对我TLE的嘲讽之情
### 思路二（正解）在博弈树基础上的~~毒~~(d)~~品~~(p)
很明显，根据博弈论的思想，你的对手想给你更少的分，这样他就可以拿到更多的分数了（因为分数总和就那么多，给你少了给他就多了）

这题我就运用了min-max的想法

另外，这道题显然要用区间DP来保证答案的最优性

#### 1. 确定状态

我们用```dp[i][j]```来表示在区间```{i,j}```内玩家1能取到的最大值

#### 2. 状态转移方程
根据我们上边的结论，玩家2肯定选玩家1得分最小的方案，因为这样在区间内在总是相等的情况下玩家2能够拿到的分数就更高

所以这个方程应该写成

```cpp
dp[i][j]=max(
  ????+上一个状态区间玩家2执行完最优策略的结果,
  ????+上一个状态区间玩家2执行完最优策略的结果
);
```
我们知道，这个区间最后取的要么是```i```，要么是```j```

玩家1选```i```时，获得分数```num[i]```

玩家2原来走完后的区间为```:{i+1,j}```

玩家1选```j```时，获得分数```num[j]```

玩家2原来走完后的区间为```:{i,j-1}```

玩家2最优策略是，他在区间```{p,q}```当中，取走第```p```个或者第```q```个，让你的得分尽量少，所以，他肯定选最小的值（指上个状态）

玩家2取走第```p```个，则上一个状态为区间```{p+1,q}```

同理，取走第```q```个，则上一个状态为区间```{p,q-1}```

注意，因为这里玩家2无论选什么你都是拿不到分的，所以，对于玩家二的区间，应有

```cpp
对于玩家2：
dp[p][q]=min(dp[p+1][q],dp[p][q-1]);
```

所以我们把转移方程补全，就需要为玩家2执行最优策略，把上边的区间```{p,q}```换成```{i+1,j}```和```{i,j-1}```，填入上边的式子

得到完整的转移方程：

```cpp
dp[i][j]=max(
  num[i]+min(dp[i+1][j-1],dp[i+2][j]),
  num[j]+min(dp[i+1][j-1],dp[i][j-1])
 );
```
#### 3. 边界条件与初始化
我们有区间dp一贯的初始化：
```dp[i][i]=num[i];```

#### 4. 你以为这就完了吗？？

通过观察状态转方程我们不难发现：
有```i+2```项，要想让```i+2```已知，我们需要用到一些~~玄学方法~~技巧

1. ```i```倒着跑：这样```i+2```就是已知的了，另外，因为```i```倒着跑了，所以```j```是要跟他反方向跑的，所以```j```应该正着跑
2. 初始化：看到那个```'+2'```了吗？我们需要手动模拟一层！！！这样```'+2'```才会是已知的

   对于这个，因为```i```是要倒着跑的，所以最开始打出来的表应该是这样的（显然是玩家1选，因为这是第一轮，所以取大）：
   ```cpp
   1 3 0 0 0
   0 3 5 0 0
   0 0 5 5 0
   0 0 0 2 7
   0 0 0 0 7
   ```
   初始化程序段：
   ```cpp
   for(int i = 1; i < n + 1; i++) {
     dp[i][i] = num[i];
     sum += num[i];
   }
   for(int i = 2; i < n + 1; i++) {
     dp[i-1][i] = max(dp[i][i], dp[i-1][i-1]);
   }
   ```
3. 十分特别无比重要的东西：因为是对手先走，你在为对手执行最优策略，最后除了输出```dp[1][n]```以外，还要输出```sum-dp[1][n]```

## 丑陋的程序

（居然一遍AC了？？？！！！）

说一句，这是用emacs写的，缩进可能跟Dev和GUIDE有点区别

```cpp
#include <iostream>
#include <fstream>

using namespace std;

int dp[110][110];
int n;
int num[110];
int sum;

void ParseIn() {
  cin >> n;
  for(int i = 1; i < n + 1; i++) {
    cin >> num[i];
  }
}

void DP() {
  for(int i = 1; i < n + 1; i++) {
  	//初始化
    dp[i][i] = num[i];
    sum += num[i];
  }
  for(int i = 2; i < n + 1; i++) {
    //手动模拟第二层dp矩阵 
    dp[i-1][i] = max(dp[i][i], dp[i-1][i-1]);
  }
  for(int i = n - 2; i > 0; i--) {
  	//i要倒着跑 
    for(int j = i; j < n + 1; j++) {
   	  //j要正着跑 
      dp[i][j] = max(
        num[i] + min(dp[i+1][j-1], dp[i+2][j]), 
        num[j] + min(dp[i][j-2], dp[i+1][j-1])
      );//转移方程 
    }
  }
}

void Core() {
  DP();
}

void WriteOut() {
  cout << dp[1][n] << ' ' << sum - dp[1][n] << endl;
}

int main() {
  ParseIn();
  Core();
  WriteOut();
  return 0;
}
```
弱弱的说一句，为什么大佬们都在用前缀和啊。。

还有管理员。。。

蒟蒻表示害怕

还有，这篇已经十天了还没消息