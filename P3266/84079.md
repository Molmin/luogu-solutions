# 〇 · 前言
由于本人菜的很，所以这题杠了好久

可能中间会很多有口胡的地方，还请指出纠正，万分感谢

这里感谢一位dalao的[博客](https://blog.csdn.net/xyz32768/article/details/86750297)，讲的非常好，给我提供了很多的帮助

# Ⅰ· 朴素dp做法
~~朴素？看来还是我太菜了~~ 

**状态表示**：$f[i][j]$， 指第$i$行，不填数字$j$的方案总数

$\because \forall x_{i, j} \in [0, m]$

（这里可能是洛谷的题面有锅，疑似LaTeX写炸了）

$\therefore$每一行总有$j \in [0, m]$不被使用，$j$有且仅有一个

**转移方程**：$f[i][j] = f[i][j - 1] + f[i - 1][j + 1]$

其中$f[i][j - 1]$，指的是这行不填$j - 1$的方案数，不填$j$与不填$j - 1$等价；

$f[i - 1][j + 1]$即在满足$x_{i, j} < x_{i + 1, j - 1}$的方案数

（其实楼上的dp讲的真的挺不错的，比我这个dp菜鸡bb的强多了）

**目标**： $f[n][m + 1]$

如果考虑为$f[n][m]$的话，最后一个数在统计答案时不确定是否填$m$，影响最后数量的计算

多算一个数，保证不会漏掉最后一个数**不选**$m$的种类数

**边界**： $f[0][0] = 0$
# Ⅱ · dp转换为组合数学问题

OI Wiki上有这样一句话

![](https://cdn.luogu.com.cn/upload/image_hosting/dndhexrj.png)

~~我一直在想，这得是个啥玩意毒瘤题，给写这个页面的人留下了这么深的心理阴影， 然后我就看到了这道题...~~

我们把dp方程的转移表示在平面直角坐标系上，并进行平移

楼上dalao已经讲的很详细了，这里不再赘述 ~~（其实就是懒得画图）~~

然后就变成了一个走格子计数的问题了，一看是计数，先考虑组合数学
# Ⅲ · 初步计算

上面提到，他是一个走格子的问题，但存在约束， 只能在一个平行四边形的方阵上走

我们考虑把这个平行四边形补全为矩形， 然后减去那些不合法的方案

即从$(0,0)$走到$P(n + m, n)$的路径，且路径不穿过$y = x - 1$和$y = x + m + 1$的方案总数

设直线$A,B$， 分别为$y = x - 1$和$y = x + m + 1$


------------

然后我们引进**对称**的做法

则$(x ,y)$关于$A$对称点为$(y + 1, x - 1)$, 关于$B$的对称点为$(y - m - 2, x + m + 2)$

这里先考虑$A$

$P(n + m, n)$关于$A$的对称点$P_1(n + 1, n + m - 1)$

则到$P_1$的方案数就等于穿过$A$到$P$的方案数，可以将各个方案关于$A$对称，则一一映射到$(0, 0)$到$P$的一种方案路径上

同理，$B$也是这样

------------

因为从$(0, 0)$到$(x ,y)$的方案数等于$\binom{x + y}{x}$

所以我们用$\binom{2n + m + 1}{n} - \binom{2n + m + 1}{n + m + 2} - \binom{2n + m + 1}{n - 1}$来表示答案

然后，**炸了**。
# Ⅳ · 容斥

在爆炸之后，我们考虑， 其路线不只是能够穿过$A$或$B$， 可以多次穿过，我们把它表示为一个$AB$串， 例如：$ABABA$

我们设$AB$串$X$，

当$X$以$A$开头时， 我们可以在最前面添加一次$B$，以$B$开头路线就会被计算多次($X$，$BX$....)

那么我们就应该减去重复计算的数量，必然**容斥**

我们把我们所使用的对称做法推广到多次对称

------------
把第$i$次对称产生的点在第$i + 1$次对称时， 视作未对称的点

根据之前单次对称的正确， 那么本次对称也是可行的

所以这个对称做法可以推广到多次

------------

又因为$AB$串中$A,B$相间分布（连续的话可以视为一次，~~强行相间~~）

所以一次关于$A$对称的方案应当减去先前关于$B$对称的方案， 同理， 关于$B$对称的方案应当减去先前关于$A$对称的方案

当产生的新点$P'$不在第一象限的时候， 则之间的路径无法在被映射回去， 也就是说， $(0, 0)$和$(n + m, n)$之间无法通过此路径联通，此时应当停止容斥

最后把答案统计一下， 用递归实现容斥， 用费马小定理+公式计算组合数，不要忘记容斥减数取模的先加上个模数，实现即可
# Ⅴ · Code
```cpp
#include <cstdio>
#include <algorithm>
#include <cstring>
using namespace std;
const int N = 3000005;
const int mod = 1e9 + 7;
typedef long long lld;
lld n, m, ans;
lld fac[N];

lld qpow(lld a, lld b) {
	lld base = 1ll;
	while (b) {
		if (b & 1)  base = (base * a) % mod;
		a = (a * a) % mod;
		b >>= 1;
	}
	return base;
}
lld Comb(lld x, lld y) {
	return fac[x] * qpow(fac[y], mod - 2) % mod * qpow(fac[x - y], mod - 2) % mod;
}

lld A(lld, lld);
lld B(lld, lld);

lld A(lld x, lld y) {
	if (x < 0 || y < 0)  return 0;
	return (Comb(x + y, y) - B(y + 1, x - 1) + mod) % mod;
}

lld B(lld x, lld y) {
	if (x < 0 || y < 0)  return 0;
	return (Comb(x + y, y) - A(y - m - 2, x + m + 2) + mod) % mod;
}

int main() {
	scanf("%lld%lld", &n, &m);
	fac[0] = 1;
	for (int i = 1; i <= (n << 1) + m + 1; ++i)  fac[i] = fac[i - 1] * i % mod;
	ans = Comb((n << 1) + m + 1, n);
	ans = (ans - A(n - 1, n + m + 2) + mod) % mod;
	ans = (ans - B(n + m + 2, n - 1) + mod) % mod;
	printf("%lld\n", ans);
	return 0;
}
```
