小蒟蒻的第二篇题解~

[博客](https://www.luogu.com.cn/blog/int1024/) 食用效果更佳~

### 题目大意：

有 $ n $ 个画家，$ m $ 幅画，要先让编号小的画家作画，每个画家都必须按编号从小到大来作画。求每幅画的最短完成时间。

### 思路：

这道题其实是有 （简单的） DP 的思想的，当然也可以用模拟做（如第一篇题解），但这篇题解主要讲 DP 的思想。

我们用 $ dp[i][j] $ 表示第 $ i $ 幅画第 $ j $ 个画家完成的最短时间，用 $ a[i][j] $ 表示已知**第 $ j $ 个画家画第 $ i $ 幅画**（坑点）需要的时间。

那么动态转移方程呢？

可以发现：我们首先必须加上第 $ j $ 个画家自身画第 $ i $ 幅画需要的时间，也就是先加 $ a[i][j] $。

这位画家作画前要等多久呢？

他需要先等自己画完第 $ i-1 $ 幅画，也就是 $ dp[i-1][j] $。他也需要先等第 $ j-1 $ 画家画完第 $ i $ 幅画，也就是 $ dp[i][j-1] $。

∴ 他需要等 $ max(dp[i][j-1],dp[i-1][j]) $ 的时间。

这样动态转移方程就有啦—— $ dp[i][j]=\max(dp[i][j-1],dp[i-1][j])+a[i][j] $。

接下来的代码就很简单了。

### code

```cpp
#include<bits/stdc++.h>
using namespace std;
int m,n,a[50001][7],dp[50001][7];
int main()
{
	cin>>m>>n;
	for(int i=1;i<=m;i++)
		for(int j=1;j<=n;j++) cin>>a[i][j];
	for(int i=1;i<=m;i++)
		for(int j=1;j<=n;j++) dp[i][j]=max(dp[i][j-1],dp[i-1][j])+a[i][j];
	for(int i=1;i<=m;i++) cout<<dp[i][n]<<" ";
	return 0;
} 
```
 留个赞再走呗~