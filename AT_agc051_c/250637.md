首先，让我们试图从题目所给的变化中找到一些不变量。

考虑到每一次变化都是一个二乘三的矩形，出现变化的列一定同时变了两个格子。于是，设 $p_j$ 是第 $j$ 列黑格个数的奇偶性，这是一个不变量。

那么行呢？我们发现，涉及到变化的行一定是连续的三个一起变，可以想到在一行内按列模三分组并统计每组内黑格个数的奇偶性，这样我们就能用三个二进制位刻画一行，它们每次操作都必然被同时反转。譬如，原来的状态是 `010`，那么操作一次之后一定变成 `101`，考虑到相邻的三个格子必然各自贡献到一个二进制位上。我们记第 $i$ 行这样的三个二进制位构成的 01 串为 $s_i$。如果我们认定 $s_i$ 和它每一位 01 取反构成的串是相同的，那这也是一个不变量。

那么还有更多的“不变量”吗？实际上，我们已经可以证明，以上两组不变量相同的状态一定都可以两两互达。记 $A=10^9$ 也就是原网格边长，那我们逐格变化一定能至少把初始状态的一个 $A-1$ 行 $A-2$ 列固定下来。由于列黑格奇偶性已经确定，最后一行是唯一的。由于行每个模 3 余数列的奇偶性也都已经确定（由于只剩两个没填，三个二进制位中一定有一个已经确定，进而另两个也唯一了），最后两列也都确定了。因此，题目中变化的网格已经被我们转换为了两组不变量。而原题给出的网格已经足以帮我们唯一确定这两组不变量的值，因此，我们要做的实际上就是给定不变量状态后确定它能对应到的所有棋盘中黑格最少的那一个。

$p_j$ 实际上可以通过题目给定的状态唯一确定，但 $s_i$ 不一定——可以有 01 翻转的两种状态。但我们这里先不妨考虑 $s_i$ 确定之后的做法。由于每一列实际上只限定了一个奇偶性，相对而言比较好处理，我们选择考虑行这个模 3 的情况。容易发现，我们应当把模 3 相同的列归在一起处理。考虑这些列中 $p$ 的状态有多少个 1（奇数），记为 $t$（注意到 $t$ 是固定不变的），那这些列中至少要有 $t$ 个黑格。考虑每一行中这个模 3 状态有多少个 1，记为 $S$（注意 $S$ 是随着 $s$ 变化的），那这些列中至少也要有这么多个黑格。那我们猜测，最终的答案就是这两者取 $\max$。

实际上，我们不妨假设 $t\ge S$。我们可以随便找 $S$ 个 $p$ 是 1 且符合模 3 约束的列出来，和每一个 $s$ 是 1 的行的交点涂黑。我们发现 $t$ 和 $S$ 都与全场黑格数量的奇偶性相同，因此 $t-S$ 一定是偶数。我们把剩下的列两两分组，每组随便找一行和这两列的交点染黑。我们发现，我们已经构造出了答案是 $t$ 的网格。对于 $t\lt S$，同理。

接下来我们整理一下我们转化过后的问题：

+ 给定若干三维向量，每一个形如 $(0,0,0)(0,0,1)(0,1,0)(0,1,1)$ 四者之一。

+ 可以进行不限次操作，每次可以选择一个向量并把它的每一维 01 翻转。

+ 给定三个常数 $X,Y,Z$。设最后得到的所有向量和为 $x,y,z$，那么需要在满足 $x,y,z$ 与 $X,Y,Z$ 顺次模 2 同余的前提下最小化 $\sum_{cyc}\min\{x,X\}$。

我们首先对于给出的原向量集算出 $x,y,z$，随后考虑每一种向量 01 反转对 $x,y,z$ 的影响（由于对同一个向量反转两次没有意义，这里只考虑原向量的反转情况）：

+ $x,y,z$ 各增加一；

+ $z$ 减少一，$x,y$ 各增加一；

+ $y$ 减少一，$x,z$ 各增加一；

+ $x$ 减少一，$y,z$ 各增加一；

我们发现，进行反转的目的是为了让答案变小。但如果同时进行了两种不同的反转，譬如第二种和第三种，$x,y,z$ 三个变量都会增大，同时它们的奇偶性也不会发生改变，是没有意义的。因此我们实际上只需要考虑进行其中一种反转即可。注意到奇偶性约束，如果需要我们进行奇数次反转，我们大可以预先进行一次反转再作考虑。

首先第一种情况是最为特殊的。它被反转一次的唯一意义就是凑奇偶，本身至多进行一次，不会再多了。然后剩下三种情况以最后一种为例，我们发现答案减小唯一的希望就是 $x$ 减少一之后 $\max\{x,X\}$ 减少一，且另外两项不变。那么我们可以列出 $x$ 操作有意义的条件：$x\gt X,y\lt Y,z\lt Z$。注意到三个变量和三个常数奇偶性顺次相同，于是大于小于号代表的差至少是 2，不会出现接连两次操作中只有第一次有意义。那么我们就可以通过上面三个条件把最优反转次数算出来（不需要考虑原向量个数的约束，因为原向量用完的时候 $x$ 一定已经归零了），同时注意到如果一开始条件就不满足，那就是零次。

然后根据以上所说的模拟一遍就可以了。

```cpp
#include <bits/stdc++.h>
using namespace std;
constexpr int A = 3;
int n, t[A], xyz[A];
map<int, bool> p;
map<int, unsigned char> s;
signed main() {
  cin.tie(nullptr)->sync_with_stdio(false);
  for (cin >> n; n; --n) {
    int x, y;
    cin >> x >> y;
    p[y] ^= true, s[x] ^= 1 << (y % A);
  }
  for (auto [y, w] : p) t[y % A] += w;
  for (auto& [x, w] : s) {
    if (__builtin_popcount(w) > 1) w ^= (1 << A) - 1;
    if (w) ++xyz[__lg(w)];
  }
  auto calc = []() {
    int ans = 0;
    for (int i = 0; i < A; ++i) ans += max(t[i], xyz[i]);
    return ans;
  };
  bool par = (t[0] ^ xyz[0]) & 1;
  for (int i = 0; i < A; ++i) xyz[i] += par;
  int ans = calc();
  for (int i = 0; i < A; ++i) xyz[i] -= par;
  for (int i = 0; i < A; ++i)
    if (xyz[i]) {
      xyz[i] -= par;
      for (int j = 0; j < A; ++j)
        if (j != i) xyz[j] += par;
      int d = xyz[i] - t[i];
      for (int j = 0; j < A; ++j)
        if (j != i) d = min(d, t[j] - xyz[j]);
      d = max(d, 0);
      xyz[i] -= d;
      for (int j = 0; j < A; ++j)
        if (j != i) xyz[j] += d;
      ans = min(ans, calc());
      xyz[i] += d + par;
      for (int j = 0; j < A; ++j)
        if (j != i) xyz[j] -= d + par;
    }
  return cout << ans << endl, 0;
}
```