这道题还算简单的。

#### 题目大意：
这个问题是确定比赛中超车的最低次数。

测试用例的第一行包含一个整数 $N$，表示竞争对手的数量。每个竞争者都有一个号码从1到 $N$。第二行按起始网格的顺序包含 $N$ 个竞争者。第三条线每种情况都有相同的竞争对手，但现在按他们完成比赛的顺序。（百度翻译）

简化一下就是：原来的比赛成绩，到最后的结果，每个选手超出原来在自己前面的人的个数，把所有人超过别人的次数加起来输出就行了。
#### 思路：
思路就是首先找到他原本的位置，再看超过了原本在前面多少人，再把总和加起来输出就可以了。

好了，既然都讲完了，就直接上代码吧：
```cpp
#include<bits/stdc++.h>
const int MAX=30;
using namespace std;
int a[MAX],b[MAX],k,ans=0;//a[MAX]表示起始网格的顺序，b[MAX]表示完成比赛的顺序。
int main(){
	int i,j,o,n;
	while(scanf("%d",&n)!=EOF){
		ans=0;
		for(i=1;i<=n;i++) scanf("%d",&a[i]);
		for(i=1;i<=n;i++) scanf("%d",&b[i]);
		for(i=1;i<=n;i++){
			for(j=1;j<=n;j++)//寻找a[i]在完成比赛的顺序的位置
				if(b[j]==a[i]){
					k=j;
					break;
				}
			for(j=1;j<i;j++)
				for(o=k+1;o<=n;o++)
					if(b[o]==a[j]) ans++; 
		}
		printf("%d\n",ans);
	}
	return 0;
}
```
//不用说谢谢，不因客套，只因能见您的笑容，以及您电脑上的 AC，您已经回报。

//祝大家信息学越来越棒哦！