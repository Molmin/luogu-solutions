[My blog](https://imyangty.com/oi/1324)

### 题意
给定一个 $n\times m$ 矩阵，里面含有字符 `.` 和 `X`。保证所有 `X` 之间无公共点（即不联通），请将一部分 `.` 替换成 `X` 使得这些 `X` 形成一棵树（要求四联通，即两个 `X` 之间有一公共边，不能有环）

### 题解
一道构造题。

首先**所有 `X` 之间无公共点**是一个特别好的性质，这保证了下面填充列的方法的正确性。

具体地，考虑 $3\mid m$ 的情况，不妨直接将 $2,5,8,\cdots$ 列全部填成 `X`，不难发现这样**隔两列填一列的方式是不会出现环的**，然后再将 $3, 6, 9, \cdots$ 和 $4,7,10,\cdots$ 等列构造成联通的就可以了，最简单的方法就是只考虑第一行和第二行，如果合法就直接连。

如果 $3\not| m$，那么只需要变一下，把 $1, 4, 7,\cdots$ 填成 `X`，剩余操作类似。至于为什么填的列改变了则可以考虑画一下图自己模拟一下，会发现如果选 $2, 5, 8,\cdots$ 的话在 $m = 3k + 1$ 的时候会多出一个需要单独考虑的列，所以不如简化问题。

代码如下：

```cpp
#include <cstdio>
#define FOR(i, a, b) for (int i = a; i <= b; ++i)

const int maxn = 505;
char s[maxn][maxn];
int n, m;

int main()
{
    int T;
    scanf("%d", &T);
    while (T--)
    {
        scanf("%d %d", &n, &m);
        FOR(i, 1, n)
            scanf("%s", s[i] + 1);
        for (int j = 1 + (m % 3 == 0); j <= m;)
        {
            FOR(i, 1, n)
                s[i][j] = 'X';//直接全部赋值
            j += 3;
            if (j > m) break;
            int p = 2;//进行操作的行号
            if (n == 1 || (s[2][j - 1] != 'X' && s[2][j - 2] != 'X'))//如果第二不可以操作
                p = 1;//那就操作第一行
            s[p][j - 1] = s[p][j - 2] = 'X';//联通
        }
        FOR(i, 1, n)
            puts(s[i] + 1);
    }
    return 0;
}
```