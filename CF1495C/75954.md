好玩的构造

# 题意

给你一个矩阵，要求在其中加入任意数量的`X`使所有`X`联通且不形成环。

题目保证给出的矩阵中没有相邻的`X`，“相邻”包括公共顶点和公共边

# 题解

挺好玩的一道构造题

~~要不是我回家只剩下 15 分钟做 1C 怎么可能才 2 切![ruo](https://cdn.luogu.com.cn/upload/pic/62238.png)~~

题目没有限制`X`的个数，所以考虑强制让他们连通。

显然最暴力的思想肯定是全变成`X`，但是显然环太多了

考虑隔一行染一次，但是还是会出现环:

```
XXXXXX
..X.X.
XXXXXX

```

再拉开一行，隔两行染一次，这次一定不会出现环，但是不一定联通（~~自行感性理解一下~~）

```
XXXXXX
..X...
X.....
XXXXXX
......
..X.X.
XXXXXX
```

于是下面的事就是让它联通。

显然的，在空着的两行任意连一条线，就会变得联通。

假设我们将所有行数$\mod3=2$的行全部染成`X`，那么所有空行的**上行连接着上一行，下行连接着下一行**，如果将所有这种连通块都连在一起，则整张图就会连通。

问题是如何合法的连上。

第一种方法是把第一列也全部染成`X`，但是在第二列出现`X`时就会出现环，不合法：

```
XXXXXX
X...X.
XX....
XXXXXX
```

题目中保证没有初始的`X`相邻，也就是说如果某行第二个位置出现`X`，则代表这一行和上下两行的第一个位置到第三个位置都不可能有`X`，这个时候直接将第二列连上即可

否则我们连第一列不会不合法，连第一列就行。

于是这题就做完了……

# 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
char a[505][505];
int main()
{
	int T;
	cin >> T;
	while(T--)
	{
		int n, m;
		cin >> n >> m;
		for(int i = 1; i <= n; i++)
		{
			cin >> (a[i] + 1);
		}
		if(n == 1)
		{
			for(int i = 1; i <= m; i++) cout << 'X';
			cout << endl;
			continue;
		}
		for(int i = 2; i <= n; i++)
		{
			if(i % 3 == 2)
			{
				for(int j = 1; j <= m; j++) a[i][j] = 'X';
			}
			else if(i % 3 == 1 && a[i][2] != 'X' && a[i - 1][2] != 'X') a[i][1] = a[i - 1][1] = 'X';
			else if(i % 3 == 1)a[i][2] = a[i - 1][2] = 'X';
		}
		if(n % 3 == 1) for(int i = 1; i <= m; i++) if(a[n][i] == 'X' && a[n][i - 1] != 'X')a[n - 1][i] = 'X';
		for(int i = 1; i <= n; i++) printf("%s\n", a[i] + 1);
	}
}

```