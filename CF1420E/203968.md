比赛的时候切了这道题，但是代码好像写的有点仓促，后来重新修了一下。

讲下做这题的历程吧

拿道这道题最初的思想是感觉花的步数不会太多，然后到最优的时候我们变化的dat会越来越小，感觉可以用个bfs来模拟这个过程，然后我们只需要记录最优的就可以了，然后花了20min写了个bfs，发现跑的很慢，但是这个代码有助于我们后面测试小数据的调试。

于是看到80的范围，觉得还是可以有些其他的做法的，写了个感觉复杂度不对的dp，想着先写个暴力，然后用一些类似于单调性或者斜率优化的方法优化一下，但是后来加了几个剪枝，然后跑了下极限数据，发现飞快，于是就能过这题了，大概一共花了45min。

来讲下怎么dp：

我们就假设v是题目中要求的对数，方便后面的表述。

首先我们记录dp[i][j][k]代表当前dp到第i为，然后选了j个1，当前移动了k步的能使题目中要求的v的max值

然后由于我们发现1是不能交叉移动的，我们很快的算出需要移动的次数，就是我们把tot个1一一对应，然后算一下绝对值。

因为我们已经记录了当前选到第j个1，所以这部分的转移我们可以直接算出，转移了以后我们发现转移之间的v会发生什么的变化?

我们考虑算贡献，就是当前dp到第j个1的贡献，我们算下左右的0个个数相乘就可以，这个因为我们的1的个数已经有了，0的个数减一下也知道了，这样我们就成功处理了转移的方式，以及转移之间的v如何转移。

最后我们更新答案的时候取个前缀的max。

这个dp的状态是O(n^4)的，我们因为前两维i,j是O(n)，然后最后一维的距离是O(n^2)的，但是我们转移还要枚举，所以也是O(n)的，总复杂度理论是O(n^5)，最坏情况下的。

但是我们发现严重跑不满，我们当且仅当这个状态出现才会往下转移，并且本来dp的状态就会有很多距离是不可能出现的，因此我们可以测一下极限数据（全0，全1，一半0一半1），非常快，实际的时间复杂度应该还没有O(n^4)，所以O(~~玄学->能过~~) 

代码：
```cpp
#include<bits/stdc++.h>
#define LL long long
using namespace std;
const int N=85,S=4e3+5;
int n,a[N],lv[N],tot,dp[N][N][S],ans;
void rel(int &x,int y){x=x>y?x:y;}
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		scanf("%d",&a[i]);
		if(a[i])tot++,lv[tot]=i;
	}
	memset(dp,-0x3f,sizeof(dp));
	dp[0][0][0]=0;
	for(int i=0,lim;i<n;i++){
		lim=min(i,tot-1);
		for(int j=0;j<=lim;j++)for(int k=0;k<S;k++)if(dp[i][j][k]>=0){
			for(int p=i+1;p<=n;p++)rel(dp[p][j+1][k+abs(p-lv[j+1])],dp[i][j][k]+(i-j)*(p-i-1));
		}
	}
	int len=(n*(n-1))>>1;
	for(int t=0;t<=len;t++){
		for(int i=1;i<=n;i++)rel(ans,dp[i][tot][t]+(i-tot)*(n-i));
		printf("%d%c",ans," \n"[t==len]);
	}
	return 0;
}
```


