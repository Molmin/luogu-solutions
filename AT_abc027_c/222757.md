实际上就是每次对 $X$ 左移 1 并考虑是否把最后一位变成 1

(1). 若 $X$ 的最高位 1 比 $N$ 的最高位 1 小，那么 $X$ 一定小于 $N$；

(2). 若 $X$ 的最高位 1 比 $N$ 的最高位 1 大，那么 $X$ 一定大于 $N$；

(3). 若 $X$ 的最高位 1 和 $N$ 的最高位 1 相等，则需要特判；

现在称使 $X$ 的最高位 1 与 $N$ 的最高位 1 相等的最后的这次左移操作称作**对齐**，**执行该操作的为甲**。

因为(1)，在对齐前，游戏肯定不会结束。因为(2)，若对齐操作没有使游戏结束，那么下一步操作一定使游戏结束。换句话说，若甲进行的这次对齐使 $X$ 大于 $N$ ,那么甲输掉比赛，否则乙输掉比赛，所以我们的重点放在这次对齐操作上。

两人都尽最大努力，甲希望对齐时 $X$ 尽可能小，乙希望对齐时 $X$ 尽可能大，所以甲每次都会使 $X\times 2$ ，而乙每次会使 $X\times 2 + 1$ ，这样就会构建出一个在对齐时最优的 $X$ ，它的二进制为 1010......1010 或是 11010......1010 ，最高位 1 与 $N$ 的最高位 1 相等，且显然当最高位在偶数位时是前者，最高位在奇数位时是后者，所以我们只需要构造出一个二进制长这样的数和 $N$ 比大小，判断甲会不会输，再判断一下甲是谁就可以了。

 _code:_ 
 ```cpp
#include<stdio.h>
unsigned long long n,o;int s; //s表示n的最高位1在第几位，o则是一个前s位都是1的数，为了取出一个数的前s位 
int main(void)
{
	scanf("%lld",&n);
	for(;n>>s;s++,o=o<<1|1);
	if((((0xaaaaaaaaaaaaaaaallu&o)|(1llu<<(s-1)))>n)^(!(s&1))) printf("Takahashi\n");
	else printf("Aoki\n");
 } 
```
样例解释：

样例2， $N = 5$ ，二进制为 101 ，我们构造出来的 $X$ 为 110，故 $X > N$ ，甲会输，而最后进行对齐操作的甲是Aoki，所以赢的是Takahashi

样例5，$N$ 的二进制为 110110110100110110100101110101100110100000101111100010101，共57位，我们构造出的 $X$ 为110101010...1010 ，故 $X < N$ ,所以甲会赢，而最后进行对齐的是Aoki，所以赢的是Aoki