上个月交了半天都不对，某天又翻到就做了一遍，把之前代码改成位运算就A了……
## 进入正题
看题先看数据范围，$N<1e18$,嗯,$log_N$算法.

看完题我们来看一下怎么做.

通过摸(xia)索(cai)可以发现，当一个数能变换到的两个点均是必胜态(说白了就是肯定赢)时,这个数就是必败态(说白了就是肯定输),否则这个点就是必胜态.

由于$N<1e18$,所以我们不能递推，否则TLE+MLE.

正确做法是记录每变换一个状态的最大值.

(下面是分析过程,L表示必败态,W表示必胜态)
***
```cpp
 W L···L
N/2    N(N%2==0)

 W L···L
N/2    N(N%2==1)

 L W···W
N/2    N(N%2==1)

 L W···W L
  N/2  N(N%2==0)
```
***
可以看出,除了当N%2==0并且当前状态是必胜态时,要将N多减去1,其他情况将N/2,状态变换一下即可.

代码:
***
```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
	long long int N;bool x=0;
	string a[2]={"Takahashi\n","Aoki\n"};
	cin>>N;
	while(N)
	{
		if(!(N&1)&&x)N=(N>>1)-1;
		else N>>=1;
		x=!x;
	}
	cout<<a[x];
	return 0;
}
```
***