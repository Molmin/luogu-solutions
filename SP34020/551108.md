### 前言
开始看了眼题，一看不就是字符串长度乘 $k$ 嘛，但一想不对！这是道绿题，其实还有一种情况例如： `abca`，这种情况下如 $k = 2$ 则答案是 $7$ 而不是 $4 \times 2 = 8$ 因为 `abcabca` 中包含两个 `abca`。
### 解法一：
判断字符串结尾有多少与字符串开头重合的，$ans = k \times$ 字符串长度 $ + $ 字符串开头结尾重合长度。

由于解法一非最优解，这里就不放代码了。

### 解法二：
对于解法一，我们可以算得时间复杂度是 $O(T \times n^2)$。

我们用了 $n^2$ 的时间效率来查找字符串开头结尾重合长度，我觉得还有点慢，这里来介绍一下 DP 算法。

我们令 $f[i]$ 表示到 $s[i]$ 为止，$s[i]$ 及以前字符与开头重合的字符串长度，递推公式为：当 `s[i] == s[f[i-1]]` 时 `f[i] = f[i-1] + 1`。

意思就是已知到 $s[i-1]$ 已有 $f[i-1]$ 个连续字符与开头重合，所以如果 `s[i] == s[f[i-1]]`，那么就意味着 $s[i]$ 可以接在 $s[i-1]$ 所在的连续字符串后面，并且它及之前的 $f[i-1]+1$ 个字符仍与字符串开头重合。

本算法的时间复杂度为 $O(T \times n)$，相比于解法一，时间减少了 $n$ 倍。

### code:
```cpp
#include <iostream>
#include <cstdio> 
using namespace std;
string s;
int f[500005], k, T;
int main()
{
	cin >> T;
	while(T--)
	{
		cin >> s >> k;
		for(int i = 1;i < s.size();i++)
		{
			if(s[i] == s[f[i-1]])
				f[i] = f[i-1] + 1;
			else
				f[i] = 0;
		}
		cout << k * s.size() - (k - 1) * f[s.size() - 1] << endl;
	}
	return 0;
}
```