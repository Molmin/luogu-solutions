我看没人用pascal做，我就发篇pascal题解吧（本人PC党）

这题采用单调队列，先解释一下样例：7 8 1 4 3 2

1.第 1 个位置之前没有值所以是 0，现在有了一个数 7；

2.第 2 个位置之前只有一个数 7，故最小值为 7，现在有一两个数 7 8；

3.第 3 个位置之前两个数为 7 8，最小值为 7；现在有三个数 7 8 1，当然由于只要前面两个数，所以可以把 7 去掉，剩下 8 1，而由于求的是最小值，显然只需要保留 1， 8 不可能是最小值了；

4.第 4 个位置之前的最小值为 1，现在又加进来一个数 4，所以又有两个数 1和4；

5.第 5 个位置之前两个数 1 4，最小值为 7，现在又加进来一个数 3，当前由于 1 已经不在范围内，所以去掉，处理 4 3，由于 3 比 4 小，则只保留最小值 3；

6.第 6 个位置之前最小值为 3，又加进来 2，即为 3 2，由于 2 比 3 小，所以只需要保留 2 就可以了。

解释完样例，上代码：

```pascal
var n,m,i,t,w,x:longint;//t是头指针，w是尾指针
a:array[0..2000001,0..1] of longint;//a[x,0]代表值，a[x,1]代表位置
begin
readln(n,m);
read(a[w,0]);inc(w);//第一个数进队列
writeln(0);//第一个数一定是输出0的
for i:=1 to n-1 do
  begin
  if i-a[t,1]>m then inc(t);
  writeln(a[t,0]);//输出最小数
  read(x);//继续读入
  while (t<w) and (x<a[w-1,0]) do dec(w);//尾指针向前移
  a[w,0]:=x;a[w,1]:=i;inc(w);//第（i+1）个数进队列
  end;
end.

```
