刚好今天学了RMQ，然后来洛谷切题，就找到了这道题，结果一测，MLE+TLE，哈哈哈

正解是单调队列，这种区间最值而且区间不修改，大小不变，只是移动，大都可以用单调队列维护，单调队列的时间复杂度很优，但是不能修改而且于堆相比应用面就比较的小，主要还是应用于dp优化中，一下附上ac代码，rmq有需要可以私聊。

```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
int n,m,a[2000000+10],q[2000000+10],h,t;//注意q存的是编号，方便出队比较，但注意比较大小的时候要用a[q[h]]；
int main(){
    scanf("%d%d",&n,&m);
    for (int i=1;i<=n;i++){
        scanf("%d",&a[i]);
    }
    printf("0\n");//以上常规部分
    h=1; t=1;
    q[1]=1; //0先输出了，然后把a[1]压入队
    for (int i=2;i<=n;i++){
        while (q[h]<i-m) h++;//每当你进一个数，要判断超出边界的，出队，写if应该也可以，不过while保险。
        printf("%d\n",a[q[h]]);//由于单调队列的单调性，队首即为区间最小值。
        while (a[i]<a[q[t]]&&t>=h) t--;//维护单调性，注意是t>=h而不是t>h，因为你有可能把队手也打掉了。理论上a[i]<=a[q[t]]更优，因为如果数值相等，越靠后的越有用，常数优化吧。
        q[++t]=i;//把这个数压进去，由于查询的区间不包括它，所以查询完毕后压队。
    }
    return 0;
}
//所以可见单调队列的代码很简短，但是理解起来也还是有一定的难度，希望这个小题目让大家入个门，dp的单调队列优化在这儿不展开讲，主要作者也不会，百度一下，你就知道
```