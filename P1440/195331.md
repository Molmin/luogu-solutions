新学了单调队列，就来做一下。这题是一道单调队列的入门题吧，一般讲单调队列都是以这题引入的吧……

先讲一下什么是单调队列。首先，它得是个队列(~~废话~~)，然后，它要满足单调性。什么是单调性呢？就是这个队列里的元素，必须是单调递增或单调递减的，而此时，队头的元素就是答案。说道这里，相信有很多人都知道该怎么做了。如果还不知道，那么继续往下看。我们在每次操作里，加入一个元素。但是加入之后它有可能会破坏单调性。那我们要维护这个单调队列，就得把前面那些比他大（这题是要找大的，其他的题目根据题意改变）都弹出队列。这样，就维护了这个单调队列，而无形之中就找到了答案。但是我们要注意，如果这个数不在范围内（因为它的范围只有一个数前的m个数，如果再往前，那么就超了），那么我们还要把他去掉。但是我们以什么为标准呢？这时，我们就要附带一个元素。这个元素就是它压入队列的时间。如果它的时间和当前这个数的时间之差大于m，那么这个数就不在范围内，就要弹出。

如果你记不住的话，你就记一句话：**如果一个人比你小，还比你强，那么你就打不过他了……** 首先申明，和CZ没有半毛钱关系。这句话就像单调队列，如果一个数在另一个数之后加入（比你小），它的值还比你小（比你强），那么他在的时候他比你强，他不在的时候你早就退役了，所以你永远都没有出头之日了（坏笑），记住这个，也能把单调队列推出来了。

上代码吧
```cpp
#include<bits/stdc++.h>
using namespace std;
int x,k,n,m;
deque<pair<int,int> >q;
inline int r()
{
    int x=0;int f=1;char c=getchar();
    while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}
    while(c>='0'&&c<='9'){x=(x<<3)+(x<<1)+(c^48);c=getchar();}
    return x*f;
}
int main()
{
	n=r(),m=r();
	for(register int i=1;i<=n;i++)
	{
		x=r();
		while(!q.empty()&&q.back().second>k) q.pop_back();
		if(!q.empty()&&i-q.front().first>m) q.pop_front();
		if(i!=1) q.push_back(make_pair(i-1,k));
		if(!q.empty()) printf("%d\n",q.front().second);
		else printf("0\n");
		k=x;
	}
	return 0;
}
```