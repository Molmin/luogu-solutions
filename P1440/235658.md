## 二元组小根堆
  先来看一下题目。~~嗯，题目这么短一定很水~~10分钟后打了一遍递推，样例没过，才发现我求的是从第一个到现在的最小值。
  
  然后又想用一个队列去做，删除是方便了，但怎么查询最小值呢？在想了10分钟后又放弃了这个方案。
  
  接着又想到了查询最小值，那么是不是可以用一个小根堆维护；那么怎么更新呢？
  经过思考，我们可以发现堆顶被更改只有两种可能
  
  1. 有一个更小的值加入，堆顶被更换
  1. 堆顶在当前位置i的m个之前，不能再用，需删去
  
  那么我们就可以用一个二元组的小根堆，
  第一元储存该点大小，第二元存它在序列中的位置。那么我们每次只要看堆顶的第二元x是否在当前位置i的m个之前，即 if(i-m>x) 那么删去堆顶
  ```cpp
priority_queue< pair< int , int > > q;
```
↑二元组大根堆定义，剩下的细节在代码注释中

  ~~又短又快♂~~的AC代码
  ```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,a[2000002];
priority_queue< pair< int , int > > q;//二元组二叉堆 
int main()
{
    cin>>n>>m>>a[1];//先把a[1]读入并放入堆中 
    q.push(make_pair(-a[1],1));//每次放入相反数（取出当然也要反一下），让其变成小根堆 
    printf("%d\n",0);//第一个永远输出0 
    for(int i=2;i<=n;i++){\
    	cin>>a[i];//读入 
    	int x=q.top().second;//去除堆中过时的堆顶 
    	while(i-m>x){
    		q.pop();
    		x=q.top().second;
		} 
		printf("%d\n",-q.top().first);//去相反数输出现在的堆顶 
		q.push(make_pair(-a[i],i));//最后再将当前值放入堆中（因为前m个值中是不包括当前值的） 
	}
	return 0;
}
	

```
