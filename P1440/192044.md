首先，这道题有三种解法：

1. 暴力
2. 线段树
3. 单调队列
- - -
方法1：暴力 $O(nm)$ 不用说了，超时妥妥的。
- - -
方法2：线段树 $O(n\log n)$ 。

这道题显然是一道求区间最小值的问题，所以考虑到线段树。

虽然说这个数据规模可以使用线段树，但是，考虑到码量以及其他各种因素，我们还是选择更快的方法比较好。（~~不会线段树就直说嘛~~）
- - -
方法3：单调队列$O(n)$。

先看一张图：![image.png](https://i.loli.net/2020/02/24/bTR9ZFEP7wtOWaQ.png)

看到了吗，其中子序列`7 8 1`的最小值为1，不管这个窗口怎么移动，7和8一定不可能再次成为该序列的最小值，所以7和8我们就根本不用管，直接弹出即可。

所以我们可以用一个**单调递增**的队列来维护窗口。

代码如下：

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int a[2000009],i,j,n,m;
int q[2000009],t=0,w=0;//单调队列，队列中存储的是下标
int main()
{
	scanf("%d%d",&n,&m);
	scanf("%d",&a[1]);//首先输入第一个数。
	printf("0\n");//第一个数之前没有数，所以可以很愉快地输出0。
	q[w]=1;//往队列里插入第一个元素。
	for(i=2;i<=n;i++)
	{
		scanf("%d",&a[i]);
		while(t<=w&&i-q[t]>m) t++;//如果队首的数已经不再范围里了，出队。
		printf("%d\n",a[q[t]]);
		while(t<=w&&a[q[w]]>a[i]) w--;//维护队列。
		q[++w]=i;//插入元素。
	}
	return 0;
}
```