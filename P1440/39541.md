## 前言

8月28号我用老师讲的方法做这道$RMQ$，样例一次就过哎！兴奋地交上去，结果$50$分……（$5×TLE+5×AC$）我这才重视题目里的$m≤n≤2000000$，我没想到会$TLE$……$QAQ$，然后我想想想……（省略$∞$个想）想不出应该如何优化……………于是翻题解，看到@一扶苏一 写的题解，恍然大悟！！！~~然后我$get$到了新的套路~~


------------
## 正题
## 这道题用二分即可完美AC!
**我最初做这道题就是用的这个方法，也就是老师讲的那个方法。自认为那天认真听了课**


### 怎么“二分”?
假设要找$[1,6]$区间的最**小**值
这些数是$7,8,1,4,3,2$

- 把$[1,6]$分成两半，分成$[1,3]$和$[4,6]$

- $[1,3]$又可以分成$[1,2]$和$[3,3]$ 此时$[1,2]$里的数有两个数$7$和$8$，最小的数是$7$，$[3,3]$里的数只有$1$，最小的是$1$

- 这时合并$[1,2]$和$[3,3]$，把$7$和$1$比较，**可以得到$[1,3]$里最小的数是$1$**

- 同样的，$[4,6]$可以分成$[4,5]$和$[6,6]$ 此时$[4,5]$里的数有$4$和$3$，最小的是$3$，$[6,6]$里的数只有$2$，最小的是$2$

- 合并$[4,5]$和$[6,6]$，把$3$和$2$比较，**可以得到$[4,6]$里最小的数是$2$**

- 合并$[1,3]$和$[4,6]$，把$1$和$2$比较，最小的是$1$，**可以得到$[1,6]$区间的最小值是$1$，结束。**

**“二分”是不是很简单呢？**

```cpp
int search(int l,int r)
{
    int mid=(l+r)/2;
    if(l>r)
        return 0;
    if(l==r)
        return s[l];
    if(r-l==1)
        return min(s[l],s[r]);
    return min(search(l,mid),search(mid+1,r));
}
```
~~至于$min$是什么都知道吧……就是一个取两个数之间比较小的数的函数~~

------------

## 现在问题来了
### 没错就是$5×TLE+5×AC$
怎么优化呢？这里我参考了@一扶苏一 的优化方案（我没想出来如何优化$QAQ$，借鉴别人的方法也不是坏事）

~~其实我觉得@一扶苏一 写的不是很到位……（我是这么觉得。你可以说我是在做补充说明）然后~~我认真研究了这位$dalao$的代码，明白了！！！

------------
## 我的理解
**我那$50$分的代码每次循环都会用“二分”计算，这样计算量大，极端一点的数据会不通过，就是$TLE$。**其实在前面的数达到$m$项之前一个个**比较**就好了，完全不需要二分。达到或者超过$m$项时，看上一个区间内的第一个数是不是那区间内最小的数，如果不是就可以直接看下一个区间，大大的减少了计算量！！！当然，不管怎样，**每次循环都要存储区间里最小的数**。

------------

```
6 2
7 8 1 4 3 2
```
- 在上面的数据中，$n=6,m=2$

- 一开始$i=1$，就是$s[1]$，前面没有数，输出$0$
- 现在$i=2$，就是$s[2]$，前面有一个数。那么$a[1]$和$s[1]$比较，$s[1]$更小，那么$a[2]$就更新成$s[1]$，输出$a[2]$
**（$a[1]$要设成一个很大的数，否则会出错）**

- 现在$i=3$，就是$s[3]$，前面有两个数，已经达到$m$项，那么看$a[2]$是否等于$s[i-m-1]$。条件不成立（$s[i-m-1]=s[0]=0,a[2]=7$），那么$a[2]$和$s[2]$比较（$a[2]=7,s[2]=8$），$a[2]$更小，那么$a[3]$更新成$a[2]$。这时$a[3]$表示区间$[1,2]$最小数是$7$。输出$a[3]$

- 现在$i=4$，就是$s[4]$，前面有三个数，已经超过$m$项，那么看$a[3]$是否等于$s[i-m-1]$。条件成立（$s[i-m-1]=s[1]=7,a[3]=7$），那么调用上文的$search$函数，寻找区间$[i-m,i-1]$的最小值，把结果存入$a[4]$，输出$a[4]$

- ……

输入：
```
6 2
7 8 1 4 3 2
```
答案：$0$ $7$ $7$ $1$ $1$ $3$


------------
~~华丽的~~$AC$代码
```cpp
#include<cstdio>
const int maxn=2e6+1;
int s[maxn],ans[maxn],n,m;
int min(int x,int y)
{
    if(x<y)
        return x;
    return y;
}
int search(int l,int r)
{
    int mid=(l+r)/2;
    if(l>r)
        return 0;
    if(l==r)
        return s[l];
    if(r-l==1)
        return min(s[l],s[r]);
    return min(search(l,mid),search(mid+1,r));
}
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++)
        scanf("%d",&s[i]);
    printf("0\n");
    ans[1]=1e9;
    for(int i=2;i<=n;i++)
    {
        int a=i-m,b=i-1;
        if(a<1)
            ans[i]=min(ans[i-1],s[i-1]);
        else if(ans[i-1]!=s[a-1])
            ans[i]=min(ans[i-1],s[i-1]);
        else
            ans[i]=search(a,b);
        printf("%d",ans[i]);
        if(i!=n)
            printf("\n");
    }
    return 0;
}
```
$2e6=2×10^6$