# 胆子要大一点，要敢于实验

### ——邓小平

## 1.算法：~~显然是~~ 期望DP

## 2.状态：
**这个状态的设计是非常考验胆量的**

$dp[g[1]][g[2]][g[3]][g[4]][g[5]][g[6]][g[7]][g[8]][g[9]]$表示第$i,(i\in [1,9])$堆成功取了$g[i]$张的概率

ovo

## 3.转移：

先统计有几对相同的，然后找到它们，转移概率。

不过这里有点坑，下面会讲。

方程太长这里就不写了具体看代码吧

## 4.边界

$dp[0][0][0][0][0][0][0][0][0]=1$(什么都不取一定行，概率为1)

$ans=dp[4][4][4][4][4][4][4][4][4]$ (取完了)

## 5.坑点

输入顺序是由堆底到堆顶给出，注意输入顺序

统计相同的时候注意不要重复

转移的时候边界不能大于4

~~我会出这些问题一定因为我太菜了~~

## 6.~~喜闻乐见的~~ 代码

```cpp
#include<bits/stdc++.h>
#define For(x,i,j) for (x=i;x<=j;x++)
using namespace std;

double dp[5][5][5][5][5][5][5][5][5]={1},tmp;
int g[10];
char a[10][5];
string s;

int main()
{
	for (int i=1;i<=9;i++)
	{
		for (int j=4;j>=1;j--)
		{
			cin>>s;a[i][j]=s[0];
//			cout<<a[i][j]<<' '; 
		}
//		cout<<endl;
	}
		
		
	For(g[1],0,4) For(g[2],0,4) For(g[3],0,4) 
	For(g[4],0,4) For(g[5],0,4) For(g[6],0,4) 
	For(g[7],0,4) For(g[8],0,4) For(g[9],0,4)
	if (dp[g[1]][g[2]][g[3]][g[4]][g[5]][g[6]][g[7]][g[8]][g[9]])
	{
		tmp=dp[g[1]][g[2]][g[3]][g[4]][g[5]][g[6]][g[7]][g[8]][g[9]];
		int cnt=0;
		for (int i=1;i<=9;i++)
			for (int j=i+1;j<=9;j++)
				if (g[i]+1<=4&&g[j]+1<=4&&a[i][g[i]+1]==a[j][g[j]+1]) cnt++;
		if (cnt>0)
			for (int i=1;i<=9;i++)
				for (int j=i+1;j<=9;j++)
					if (g[i]+1<=4&&g[j]+1<=4&&a[i][g[i]+1]==a[j][g[j]+1])
					{
						g[i]++;g[j]++;
						dp[g[1]][g[2]][g[3]][g[4]][g[5]][g[6]][g[7]][g[8]][g[9]]+=tmp/(double(cnt));
						g[i]--;g[j]--;
					}
					
	}
	printf("%.6lf",dp[4][4][4][4][4][4][4][4][4]);
	return 0;
} 
```
