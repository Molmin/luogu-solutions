# 奇奇怪怪的方法。。。
首先我们观察数据范围，不是特别大，那我们可以考虑数组：

具体思路如下：

1. **从尾到头查找，如果该位置还没有出现过数，该位置记录出现过，并且记录位置。**
1. 对位置进行排序
1. 如果发现出现过，输出。
下面奉上AC代码：
```cpp
#include <iostream>
#include <algorithm>
using namespace std;
int a[100001],b[100001];//数组尽可能定大点
int main(){
	int i,j,k,n,sum=0;
	cin>>n;
	for(i=1;i<=n;i++)cin>>a[i];
	for(i=n;i>=1;i--)if(b[a[i]]==0){//判断：如果该位置没有出现过，记录该位置
	    b[a[i]]=i;//巧妙之处：因为不可能会出现位置为0的情况，所以顺便记录是否出现过的同时记录位置
	    sum++;//总数++
	}
	sort(b+1,b+1001);//注意b数组的指针是数字！！！因为元素范围为1<=a<=1000，所以从1排到1000
	cout<<sum<<endl;
	for(i=1;i<=1001;i++)
	if(b[i]>0)cout<<a[b[i]]<<" ";//如果发现出现过，输出该位置对应的数
	return 0;
}
```

