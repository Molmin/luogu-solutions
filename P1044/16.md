这里我给一下hongweixin同学的方法的思想：

我们假设从开始到所有元素都出栈为止，第一个出栈的元素是j（j可以是1~n）。对于每一个大于1的序列，都可以从j拆分成两个序列：

假设从1..j-1是第一个序列，第j+1..n是第二个序列，那么第一个序列就有j-1个元素，第二个序列就有n-j个元素（j-1为0或者n=j时就默认第一个序列或者第二个序列为空，而空序列只有一个可能）。

再假设a(n)是有n个元素的所有出栈序列数目，那么再基于乘法原理，得出a(n)=a(j-1)\*a(n-j)；而j可以从1枚举到n，再依据加法原理，最终的a(n)就是把每一个枚举的a(j-1)\*a(n-j)相加了（a(n)=a(n)+a(j-1)\*a(n-j)）。

这时只要预处理a(0)=1,a(1)=1，再算出a(2..n)（n>=2），打出a(n)就可以了~

[color=green]话说我怎么看这方法怎么像合并类动规......是不是我动规写多了......[/color]

附我自己的程序：

```delphi

program ex1231;
var
  i,j,k,m,n,s,t:longint;
  a:array[0..18] of longint;
begin
  readln(n);
  a[0]:=1;
  a[1]:=1;
  for i:=2 to n do
    for j:=1 to i do
      a[i]:=a[j-1]*a[i-j]+a[i];
  writeln(a[n]);
end.

```