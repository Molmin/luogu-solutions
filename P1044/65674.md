/\*
想了半天，有点暴力的想到了这个方法

比如 3的情况有5种，分别为

1 2 3
3 2 1
2 1 3
2 3 1
1 3 2
那么，4的次数在3的基础上增加的第一种情况，就是在每个数字后面加上4，即

1 2 3 4

3 2 1 4

2 1 3 4

2 3 1 4

1 3 2 4

然后，讲4向前移动，变成

1 2 4 3

3 2 4 1

2 1 4 3

2 3 4 1

1 3 4 2

此时继续前移时，只有3种情况，因为需要对4后面的数进行排序

即
1 4 3 2

2 4 3 1

3 4 2 1

最后还有一种

4 3 2 1

那么，显而易见，这个规律就是

1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0

1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0

2 2 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0

5 5 3 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0

14 14 9 4 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0

42 42 28 14 5 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0

132 132 90 48 20 6 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0

429 429 297 165 75 27 7 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0

1430 1430 （1001） 572 275 110 35 8 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0

4862 4862 3432 2002 1001 429 154 44 9 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0

每一排的总数即为情况数

1001=429+297+165+75+....+0

下面贴代码\*/




```cpp
#include<iostream>
using namespace std;
int main(){
    int n;
    cin>>n;
    int work[n+100][n+100];
    for(int i=0;i<=n+10;i++)
    for(int j=0;j<=n+10;j++)
    work[i][j]=0;
    work[1][1]=1;
    work[1][2]=0;
    for(int i=2;i<=n;i++)
    {
        for(int j=1;j<=i;j++)
        {
            for(int m=i;m>=j-1;m--)
            work[i][j]+=work[i-1][m];
            work[i][i+1]=0;
        }
    }
    int ans=0;
    for(int i=1;i<=n;i++)
    ans+=work[n][i];
    cout<<ans;
}

```