看到大家的题解都写到了卡特兰数，但是没有细细的讲讲这跟本题有什么关系

本题的描述十分简单。n个数依次进栈，可随机出栈。求有几种可能。

dfs可以解，但是递推仿佛好像如同看上去貌似更简单一些。

解释一下原理：

建立数组f。f[i]表示i个数的全部可能性。

f[0] = 1, f[1] = 1;  //当然只有一个

设 x 为当前出栈序列的最后一个，则x有n种取值

由于x是最后一个出栈的，所以可以将已经出栈的数分成两部分

1. 比x小

2. 比x大

比x小的数有x-1个，所以这些数的全部出栈可能为f[x-1]

比x大的数有n-x个，所以这些数的全部出栈可能为f[n-x]

这两部分互相影响，所以一个x的取值能够得到的所有可能性为f[x-1] \* f[n-x]

另外，由于x有n个取值，所以

ans = f[0]\*f[n-1] + f[1]\*f[n-2] + ... + f[n-1]\*f[0];

这，就是传说中的卡特兰数


附上代码：

```cpp
//This program is written by QiXingZhi 

#include <cstdio>

int n, f[30];
int main()
{
    //递推实现卡特兰数 
    scanf("%d", &n);
    f[0] = 1, f[1] = 1;
    for(int i=2; i<=n; i++)              
        for(int j=0; j<i; j++) 
            f[i] += f[j] * f[i-j-1];     //递推公式 
    printf("%d", f[n]);
    return 0;
}
```