题目分析：

考虑贪心。

当发现有一组灯泡，不妨设其为 $A$ 组灯泡，比另一组的价值高的时候，那么再去取 $A$ 组的灯泡并不能增加其收益，所以一定要取另一组，也就是 $B$ 组的灯泡。

而无论对于哪一组灯泡，优先取价值更高的灯泡一定是没有问题的，否则将一个价值不高的灯泡更换成一个价值更高的灯泡一定答案不会更劣，只有可能相等或更优，那么也就是意味着所有的灯泡一定是从排好序的灯泡组的第一个一直取到当前的那一个的。

------------

这时本题的做法就很清楚了，现将两组灯泡分别按价值从大到小排序，然后分别维护两组灯泡从前到后一共取了多少个灯泡。

对于每一次决策，从当前总价值小的那一组灯泡里取一个价值最大的，更新答案即可。

------------
本题的另一种做法：三分法，思路是这样的（参考了metaphysis大佬的题解，自己所做的时候由于太菜没有想到）：先确定 $A$ 中取得灯泡，然后再用三分法求解此时 $B$ 中灯泡的最大价值。

但蒟蒻认为这种做法不是最优的。

这时因为三分法利用到的性质只有“优先取价值更大灯泡”，而没有利用到一组灯泡价值已经比另一组灯泡更高时直到另一组灯泡价值反超前一定不再次取价值更高的一组灯泡。

------------
二分斜率的 wqs二分 算法思路和三分法差不多，这里不再赘述。

------------
代码（贪心算法）：
```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
int n;
double a[100005],b[100005],ans,tota,totb;
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		scanf("%lf%lf",&a[i],&b[i]);
		a[i]=-a[i];b[i]=-b[i];
	}
	sort(a+1,a+n+1);
	sort(b+1,b+n+1);
	int j=0;
	for(int i=1;i<=n;i++){
		tota-=a[i];
		ans=max(ans,min(tota-i-j,totb-i-j));
		while(totb<tota&&j<n){
			j++;totb-=b[j];
			ans=max(ans,min(tota-i-j,totb-i-j));
		}
	}
	printf("%.4f",ans);
	return 0;
}
```

