# Solution

还是那句话，如果看到一个很奇怪的定义在区间上的函数 $f(l,r)$，还让你求 $\sum \sum f(i,j)$ 之类的和，你要干的第一件事实弄清楚 $f(l,r)$ 怎么算。

假设你拿到了一个 $b$ 数组。很显然，$b$ 的最后一个数不能拆，因为拆了反而会更劣（凭空多出了一次操作，而且可能使前面要拆更多次）。再考虑对倒数第二个数 $v$ 进行拆分，假设最后一个数为 $u$。

为了让每个数都小于等于 $u$，那么至少要拆成 $\lceil \frac{v}{u} \rceil$ 段。再由贪心的思想，如果我们拆了 $x$ 段，应该通过某种手段让第一个数为 $\lfloor \frac{v}{x} \rfloor$，这样可以使前面拆的段尽可能少。很显然这是能做到的。（先搞出 $x$ 段 $\lfloor \frac{v}{x} \rfloor$，再把余数加到后面几段上来。）

所以说，如果上一个数为 $u$，那么这一轮结束之后第一个数为 $\lfloor \frac{v}{\lceil \frac{v}{u} \rceil} \rfloor$。不断往前迭代，就处理了计算 $f$ 这个问题。

然后你注意到 $\lfloor \frac{v}{\lceil \frac{v}{u} \rceil} \rfloor$ 在 $v$ 一定 $u$ 不同的时候可能取值的种类只有 $O(\sqrt v)$ 量级。所以我们从不同的 $r$ 出发，扫描到某个点 $h$ 的时候只有 $O(\sqrt {a_h})$ 种拆分可能，把相同的情况进行压缩。一 一枚举它们。这时候每一种长度为 $x$ 的拆分都会对答案产生 $h(x-1)$ 的贡献。

因此从 $n$ 开始往前迭代可以做到 $O(n \sqrt V)$ 的复杂度。

[代码](https://codeforces.com/contest/1603/submission/212325196)