### 思路

此题是一道非常基础的动态规划入门题。我们很容易想到状态，如果设 $f_{i}$ 表示走到第 $i$ 层楼最少得时间，这样有一个很大的缺陷：无法知道上一次是走楼梯还是坐电梯，所以无法确定是否要加上等电梯时间。那么我们将状态改进，设 $f_{i,j}$ 表示走到第 $i$ 层楼的最少时间，同时从 $i-1$ 到达 $i$ 是通过方法 $j$ 来的，其中 $j=0$ 表示是走楼梯，$j=1$ 是坐电梯。

如果 $a0_i$ 表示从 $i-1$ 到 $i$ 走楼梯的时间，$a1_i$ 表示表示从 $i-1$ 到 $i$ 走电梯的最小时间，那么如果上一次上楼是通过楼梯，状态转移方程为：

$$
f_{i,0}=\min\{f_{i-1,0},f_{i-1,1}\}+a0_i
$$

因为走楼梯不需要等电梯的时间，所以直接走上来即可，相信方程不难推出。同理，若上一次上楼是电梯，状态转移方程为：

$$
f_{i,1}=\min\{f_{i-1,0}+c,f_{i-1,1}\}+a1_i
$$

因为乘坐电梯是需要等待时间的，因此走楼梯需要额外加上 $c$。但是如果你原本就是乘坐电梯的，那么你就无需再等待。接下来注意初始状态：

$$
f_{1,0}=0,f_{1,1}=c
$$

走楼梯可以直接上楼，设置为 $0$ 即可。乘坐电梯的话一开始也要等待，所以设置为 $c$。再来看终止状态，因为每一次上楼到第 $i$ 层是独立的，因此你无需在意本次最小值是走楼梯还是电梯对后面的影响。因此，对于第 $i$ 层楼的结束状态为：

$$
\min\{f_{i,0},f_{i,1}\}
$$

好了，接下来看看简短的代码吧。

### 代码


```cpp
#include<bits/stdc++.h>
using namespace std;;
int f[200005][2],a0[200005],a2[200005];
int main()
{
  int n,c;
  cin>>n>>c;
  for(int i=2;i<=n;i++)
  {
    cin>>a0[i];
  }
  for(int i=2;i<=n;i++)
  {
    cin>>a1[i];
  }
  // 输入部分。

  f[1][1]=c;       // 因为全局变量默认赋值为 0，所以无需再加上 f[1][0]=0; 这条语句。
  cout<<0<<" ";    // 走到第一层消耗时间必然为 0，直接输出即可。
  for(int i=2;i<=n;i++)
  {
    f[i][0]=min(f[i-1][0],f[i-1][1])+a0[i];
    f[i][1]=min(f[i-1][0]+c,f[i-1][1])+a1[i];
    cout<<min(f[i][0],f[i][1])<<' ';    // 状态转移部分和输出部分，思路部分已经讲得很详细，这里就不多赘述了。
  }
	return 0;
}
```