这道题非常妙啊...虽然看上去是线性dp，但还要加一个维度来记录状态。

思路：贪心+dp。

1. 首先找出最下面一行是Y的砖块，可以免费打掉。

2. 对于Y与N交叉的地方，将一个N上面全部的连续的Y的总分累加进N所在位置，用数组now储存。每一列前缀和用res储存，最后now要加上res，表示将该点下面所有的点都选了，而且把该点上面的连续的y砖块也打了。还要预处理出来在第j列，打掉前i个砖块所需的子弹，用ci数组储存。

3. 这时候用到分组背包的思想。dp[j][i][0]表示前j列总共耗费i个子弹，且之后不用"借"子弹，dp[i][j][1]表示之后还要”借“子弹，所能得到的最大分数（“借”的意思：比如第一列是 2 Y 2 N 且N必须先打掉，那么dp[1][1][0]=2,dp[1][1][1]=4），答案即为dp[m][k][0]。


状态转移方程： dp[j][k][0]=max(dp[j][k][0],max(dp[j-1][k-ci[j][i]][1],dp[j-1][k-ci[j][i]][0])+res[j][i]);

dp[j][k][0]=max(dp[j][k][0],dp[j-1][k-ci[j][i]][0]+now[j][i]);

dp[j][k][1]=max(dp[j][k][1],dp[j-1][k-ci[j][i]][1]+now[j][i]);

初始化： for(j=0;j<=m;j++) dp[j][0][0]=-inf;
