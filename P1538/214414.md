第一次写题解，也是为了把自己的思路整理记录下来,解题思路很好理解。
## 解题思路：
1. 将0-9的字符表达基元存储在二维字符串表中
2. 按照一定格式输出并对齐(横线与竖线处理方式不同)


### 1.构造表达数字的基本元素
由于需要一行一行输出，所以将数字0-9拆分为5行，随便举个栗子,0,5,9分别表示如下：
	
     -    -    -
    | |  |    | |
          -    -
    | |    |    |
     -    -    -
可以拆分为:

	elemofzero={"-","||"," ","||","-"}
    elemoffive={"-","| ","-"," |","-"}
    elemofnine={"-","||","-"," |","-"}
    
1.空格与横线做相同处理，为了方便，统一称为**横线**,**横线**只需存储长度为1的字符;

2.凡是涉及到竖线,"||"、"| "、" |",即字符串表的1、3行(0起始)，均存储长度为2的string，以便判断并对齐。

---
### 2.输出并对齐
还是举个栗子，假设此时k=2，输入字符串仅为"0"。通过上面分析可知，按照基本元素分为5行(并不是输出只有5行)输出。

判断当前行是横线(情况1)还是竖线(情况2)方式很简单：

* 按照行判断:设i表示当前行号，同样从0起始，则i=1和3时为竖线，进行竖线处理。其他时按照横线处理；
* 按照当前元素字符串长度判断，长度大于1则为竖线，否则为横线。

#### 针对情况1：

首先输出一个空格，连续输出k个**横线**,再输出一个空格;

#### 针对情况2：
定义计数变量cnt，记录还需输出多少次竖线。
每次输出完一行后，判断是否达到输出个数k，没有则行迭代变量i减一，重新输出当前竖线行,更新计数变量循环即可。

---
## AC代码
### 代码与上述思路大体相同，系列略有出入，~~不要在意这些细节~~
```cpp
#include<iostream>
#include<cstdio>
#include<math.h>
#include<string>
#include<algorithm>
#include<vector>
#include<cstring>
using namespace std;

//P1538

string baseElem[10][5] = {
{"-","||"," ","||","-"},
{" "," |"," "," |"," "},
{"-"," |","-","| ","-"},
{"-"," |","-"," |","-"},
{" ","||","-"," |"," "},
{"-","| ","-"," |","-"},
{"-","| ","-","||","-"},
{"-"," |"," "," |"," "},
{"-","||","-","||","-"},
{"-","||","-"," |","-"},
};
string strIn;
int main(int argc, const char* argv[])
{
	int i, j, n;//注释
	int k;
	int cnt;
	cin >> k;
	cin >> strIn;
	cnt = k - 1;
	for (i = 0; i < 5; i++)
	{
		for (j = 0; j < strIn.length(); j++)
		{
			
			if (baseElem[strIn[j]-'0'][i].length() > 1)
			{
				cout << baseElem[strIn[j] - '0'][i][0];
				for (n = 0; n < k; n++)
				{
					cout << " ";
				}
				cout << baseElem[strIn[j] - '0'][i][1];
			}
			else
			{
				cout << " ";
				for (n = 0; n < k; n++)
				{
					cout << baseElem[strIn[j] - '0'][i];
				}
				cout << " ";
			}
			cout << " ";
		}
		cout << endl;

		if (cnt > 0 && (i == 1 || i == 3)) {
			i -= 1;
			cnt -= 1;
		} else {
			cnt = k - 1;
		}
	}
	return 0;
}



```