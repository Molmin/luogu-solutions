这个题需要我们**仔细观察样例，寻找k与输出内容的规律**，然后就AC了

------------

那么通过观察**k=1时的样例**，我们可以发现什么呢？？？

```
 -       -   -       -   -   -   -   -
| |   |   |   | | | |   |     | | | | |
         -   -   -   -   -       -   -
| |   | |     |   |   | | |   | | |   |
 -       -   -       -   -       -   -
```
1. 每个方格数字有**5行**，且按照“**横竖横竖横**”排列.
1. **横的**有两种情况：要么**有一横**（如0、2、3等的第一行），要么**啥也没有（空格）**（如1、4等的第一行）.
1. 竖的有三种情况：要么**左边有一竖**（如5的第二行），要么**右边有一竖**（如5的第四行），要么**左右两边都有一竖**（如0的第二、四行），在这里**左边有一竖，右边就是空格；右边有一竖，左边就是空格**.


------------
接下来咱们就可以根据以上规律优雅地**把表打出来了**，这里我懒得打横线竖线，就设置了一大坨**const常量**。
```cpp
//h——横线   s——竖线
const string h1="-";//横线
const string h2=" ";//空格
const string s1="| ";//左边竖线右边空格
const string s2=" |";//左边空格右边竖线
const string s3="||";//左右两边都是竖线
//这里我们用一个二维数组来保存数据，map[i][j]表示数字i的第j（0~4）行
string map[10][5]={{h1,s3,h2,s3,h1},            //0
	             {h2,s2,h2,s2,h2},	        //1
                   {h1,s2,h1,s1,h1},	        //2
                   {h1,s2,h1,s2,h1},	        //3
                   {h2,s3,h1,s2,h2},		//4	
                   {h1,s1,h1,s2,h1},		//5
                   {h1,s1,h1,s3,h1},		//6
                   {h1,s2,h2,s2,h2},		//7
                   {h1,s3,h1,s3,h1},		//8
                   {h1,s3,h1,s2,h1}};           //9
```
有了k=1时的状态，接下来还是要找规律！来，翻翻**k=1和k=2时的第一行**（map[i][0]），看看**有什么联系**！（为了方便看得清，空格我用s表示，每个数字之间用斜杠隔开）
```
k=1:
 0   1   2   3   4   5   6   7   8   9
s-ss/ssss/s-ss/s-ss/ssss/s-ss/s-ss/s-ss/s-ss/s-ss
k=2:
 0    1    2    3    4    5    6    7    8    9
s--ss/sssss/s--ss/s--ss/sssss/s--ss/s--ss/s--ss/s--ss/s--ss

```
发现没有？每个数字之间都是**一个空格→k个字符（该数字的横线或空格）→两个空格**的形式输出的。每个**偶数行**（因为**从0开始存**，所以**偶数行是横的**）都满足这个规律，代码自然也就不难写啦！
```cpp
if(i%2==0){        //i代表行数，因为是偶数行，所以...
   for(int j=0;s[j]!='\0';j++){
        //字符串的每个字符都要这么操作，j来遍历字符串
   	cout<<" ";//先输出一个空格
    for(int x=1;x<=k;x++)     //再输出k个相应数字的字符   
      cout<<map[s[j]-'0'][i];   //s[j]中第i行的数据       
	    cout<<"  ";//最后输出两个空格
    }
	    cout<<endl;//下一行
}
```
搞定了横的，下面我们来看竖的！这次**看k=1和k=2的第二行**（map[i][1]）,s和斜杠的意思还是老规矩
```
k=1:
  0   1   2   3   4   5   6   7   8   9 
|s|s/ss|s/ss|s/ss|s/|s|s/|sss/|sss/ss|s/|s|s/|s|s
k=2:
  0    1   2    3    4    5    6    7    8    9
|ss|s/sss|s/sss|s/sss|s/|ss|s/|ssss/|ssss/sss|s/|ss|s/|ss|s
|ss|s/sss|s/sss|s/sss|s/|ss|s/|ssss/|ssss/sss|s/|ss|s/|ss|s
```
这次也不难发现，就是**左边的字符→k个空格→右边的字符→空格**，如此**连续输出k行**就没毛病了。放代码！（这里我用了一个字符串cnt来存储k个空格）用这个也可以解决所有**奇数行**（从0开始）的问题。
```cpp
	else{  //不是偶数，就是奇数嘛
		for(int j=1;j<=k;j++){  //连续输出k行
		   for(int x=0;s[x]!='\0';x++)  //遍历字符串
		   	cout<<map[s[x]-'0'][i][0]<<cnt<<map[s[x]-'0'][i][1]<<" ";
                        //左边的字符（下标0）—k个空格（cnt）—右边的字符（下标1）
			cout<<endl;//换行
		}
	}
```
至此，核心部分就讲完了，关键就是**找规律，找规律，找规律，重要的事情说三遍**，小伙伴们都学会了吗？now，你们最喜欢的完整代码：
```cpp
#include<iostream>
#include<cstring>//字符串的题这俩东西不能少啊
using namespace std;
const string h1="-";//打表记录0~9的形状
const string h2=" ";
const string s1="| ";
const string s2=" |";
const string s3="||";
string map[10][5]={{h1,s3,h2,s3,h1},{h2,s2,h2,s2,h2},{h1,s2,h1,s1,h1},{h1,s2,h1,s2,h1},{h2,s3,h1,s2,h2},{h1,s1,h1,s2,h1},{h1,s1,h1,s3,h1},{h1,s2,h2,s2,h2},{h1,s3,h1,s3,h1},{h1,s3,h1,s2,h1}};
int main(){
   string s;
   int k;
   cin>>k>>s;//输入
   string cnt (k,' ');//这个意思是把k个空格赋给cnt
   for(int i=0;i<5;i++){//一共有5行
   	if(i%2==0){//偶数横行：1个空格→k个字符→两个空格
   		for(int j=0;s[j]!='\0';j++){
   			cout<<" ";
		   for(int x=1;x<=k;x++){
		   	 cout<<map[s[j]-'0'][i];
		   }
		   cout<<"  ";
	      }
	    cout<<endl;
		}
	else{//奇数竖行：左边字符→k个空格→右边字符，输出k行
		for(int j=1;j<=k;j++){
		   for(int x=0;s[x]!='\0';x++){
		   	cout<<map[s[x]-'0'][i][0]<<cnt<<map[s[x]-'0'][i][1]<<" ";
			}
			cout<<endl;
		}
	}
   } 
   return 0;//Perfect!!! 
}      
```
The end~~~~~~~~~~~~~~~~~
