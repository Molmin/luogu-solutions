首先吐槽一下这个翻译，这是什么鬼。

其实题意很简单，就是说岛国人民搞了个新政策，他们现在有 $n$ 个节日，也有双休日（「土曜日」「日曜日」就是人家的周六日），然后还有「补休日」，跟调休正好相反，就是「公休日」是双休日的话，就设下面第一个非节日的工作日为「补休日」。

~~你要这样我乐开花了，中秋五一好几年全是涵盖周末，如果我没记错的话。~~

下面我来说一下坑。

1. 本题是 $2012$（$2011$？）年的题，$2012$ 是个闰年，有 $366$ 天。
2. 简单去看一下万年历，$2012.1.1$ 是个周日。

代码大致分为三个部分。

1. 预处理。为了方便我们求 $x$ 月 $y$ 日是一年第多少天（即前 $x-1$ 个月的天数和再加 $y$ 天），我们需要计算月的前缀和。我们还要定义一个布尔数组标记休假日。
2. “日式调休”，如果这个节日是双休日，则设置补休（利用循环），否则设为休假日。
3. 统计，使用擂台法。

下面看代码：（可以自行过滤很多注释）

```cpp
#include <bits/stdc++.h>
using namespace std;

int n;
bool rest[114514];
int mouth[13]={0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}, month[13];
// 奶奶的，2012年是个闰年，草
void meow(){
    cin>>n;
    // 前缀和，不然不好算，这样计算是一年第多少天只需要加上前面那些月的和再加日期即可
    for (int i=1; i<=12; i++) month[i]=month[i-1]+mouth[i]; // 都懒得换一个容易区分的变量名，就是玩

    // 标记双休日
    for (int i=1; i<=366; i++)
        if (!(i%7) || i%7==1) rest[i]=true; // 366，366，闰年天数366！
}

void woof(){
    while (n--){
        int m, d;
        scanf("%d/%d", &m, &d); // 都一样
        int kth_date=month[m-1]+d; // 一年第多少天，计算方法在上一个函数的注释中
    
        if (rest[kth_date]){ // 如果是节假日也是双休日，往下找到第一个非节假日改为节假日
            for (int i=kth_date+1; i<=366; i++)
                if (!rest[i]){ rest[i]=true; break; }
        }
        else rest[kth_date]=true; // 否则改成节假日
    }
}

void oink(){
    int maxd=0, real=0; // 擂台计数器，最终输出的数
    for (int i=1; i<=366; i++){ // 最长连休日（超大型連休）
        if (rest[i]) maxd++; // 是节假日，最长连续计数加一
        else real=max(real, maxd), maxd=0; // 不是了，计算目前的最长连休
    }
    cout<<max(maxd, real)<<endl; // 把最后可能落下的连休记录下来
}

int main(){
    meow(); // 预处理
    woof(); // 调休？日式调休（确信
    oink(); // 统计
    return 0;
}
/*
Este es el zoo!
*/
```

就是这样，谢谢大家。