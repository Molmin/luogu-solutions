显然用 `DP`，当可以从 $i$ 连到 $j$ 时 $dp_i=\max\{dp_j+1\}$.

问题来了：怎么判断是否可以从 $i$ 连到 $j$？

画一张图理解一下：

![](https://z3.ax1x.com/2021/06/25/R1Fl3d.png)

> Q:为什么 $4$ 可以到达 $2$？

> A:因为绿斜线与蓝直线（此处指垂直于地面的线段）不相交。

> Q:为什么不可以到达？

> A:因为红斜线与绿直线相交。

为什么红斜线与绿直线相交呢？因为绿斜线在红斜线上方，也就是说绿斜线在红斜线的顺时针方向。

如何判断两条线的顺逆时针方向？没错：斜率。

定义点 $i$ 到点 $j$ 的斜率为 $\dfrac{h_i-h_j}{i-j}$

如图。

![](https://z3.ax1x.com/2021/06/25/R1EBgH.png)

当然斜率可能为负，但此时斜率和顺逆时针的关系仍然成立。

~~不信你自己画一张图我懒得画了~~

说了这么多，究竟如何判断 $i$ 是否可以连到 $j$？

设 $t$ 为当前以 $i$ 为起点斜率最大的终点，则 $i$ 到 $j$ 的斜率大于**等于**从 $i$ 到 $t$ 的斜率，即

$$\dfrac{h_i-h_j}{i-j} \geqslant \dfrac{h_i-h_t}{i-t}$$

即

$$(h_i-h_j)(i-t) \geqslant (h_i-h_t)(i-j)$$

（这样可以避免浮点运算的误差）

时可以从 $i$ 连到 $j$。

此时由于 $i$ 到 $j$ 的斜率变成了最大，所以需要将 $j$ 赋给 $t$。

关键部分的伪代码如下：

```latex
if ((i-j)(h_i-h_t)>=(i-t)(h_i-h_j)) then
	min(dp_i, dp_j +1) → dp_i
	j → t

```

注意了：先将 $j = i-1$ 的情况的 $dp_j$ 的值算出来，循环中 $j$ 从 $i-2$ 开始枚举。因为 $j = i-1$ 时难以给 $t$ 赋值，同时两者之间没有第三者阻拦，必然可以连起来。

还有：如果像我这样做，那么两数相乘可能会爆 `int`！直接在前面乘个 `1ll` 就行了。（间接的类型转换）

上代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
int n, k, h[5010], dp[5010], t;
int main() {
	cin >> n >> k;
	for (int i = 1; i <= n; i++) {
		cin >> h[i];
		dp[i] = dp[t = i - 1] + 1;
		for (int j = i-2; j >= 1 && i - j <= k; j--) 
			if (1ll*(i-j)*(h[i]-h[t]) >= 1ll*(i-t)*(h[i]-h[j])) 
				dp[i] = min(dp[i], dp[t = j] + 1);
	}
	cout << dp[n] << endl;
	return 0;
}
```