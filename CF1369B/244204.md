#### 题意
有一个长度为n的0/1字符串 $s$，若 $s_i = 1,s_{i+1} = 0$ 则可以删除其中一个字符。输出经过若干次删除后长度最短，且字典序尽可能小的字符串。

#### 思路
题目中说对于字串 `10`，可以删除其中一个字符，不难发现对于形如 `11...100...0` 和形如 `1010...10` 的字符串可以被删成 `10`。

进一步往下推，发现任何一个从1开始，以0结束的字符串都可以被删成 `10`。因为任意一个这种字符串都是由若干个连续的  `11...100...0` 组成，则该字符串，可以被删成 `1010...10`，也就可以被删成 `10`。

对于题目给定的字符串 $s$，如果我们能找到 $l$ 和 $r$ 使得 $l < r, s_l = 1, s_i = 0(i < l), s_r = 0, s_j = 1(j > r)$。我们把字串 $s_{l..r}$ 化成 `10`，再化成 `0`（这样使得字典序尽可能小），此时的字符串已经被删成 `00...011...1`，不能再删了，直接输出。

如果找不到 $l$ 和 $r$，说明该字符串已经成为 `00..011...1`，直接输出原字符串。

#### AC代码
```cpp
#include <cstdio>
#include <cstring>
const int N = 100005;
int t, n;
char str[N];
int main(void)
{
    scanf("%d", &t);
    while(t--)
    {
        scanf("%d%s", &n, str+1);//字符串从1开始存，方便操作
        int l = 1, r = n;
        while(str[l] == '0')
            ++l;
        while(str[r] == '1')
            --r;
        if(l > r) //如果找到的l r不满足条件，输出原字符串
            printf("%s\n", str+1);
        else//输出删除后的字符串
        {
            for(int i = 1;i < l;++i)
                putchar(str[i]);
            putchar('0');
            for(int i = r+1;i <= n;++i)
                putchar(str[i]);
            putchar('\n');
        }
    }
    return 0;
}
```