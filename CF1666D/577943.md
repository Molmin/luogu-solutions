## 题意简述

------------
- 给定 $n$ 组数据，每组数据包括两个字符串，原串 $s$ 和目标串 $t$。

- 每次操作可指定原串中任意一个字母，将原串中第一次出现的该字母删去。

- 询问是否可以将原串转化为目标串。

- $1 \leq n \leq 10^4$，$1 \leq \left| t \right| \leq \left| s \right| \leq 30$。

## 题目分析

------------
本题考查知识点：**字符串** 以及 **贪心**。

### 思路

------------
我一开始没发现字母 **可重**，结果写假了，后来我想出了一个易懂但是跑得挺慢的做法。

首先用一个数组倒序记录目标串中每个字母 **从后往前** 是第几次出现的，再用一个数组，以相同的方式处理原串中与目标串有关字母。接着，用一个指针标记当前指向的目标串的字母（从下标 $0$ 开始）。遍历一遍原串，如果当前原串字母是指向的目标串的字母，且两者出现次序相同，说明发现了可能的情况，指向变量后移。

最后，如果指针将目标串的每个字母都指过了，说明 **完全匹配** ，可以做到转化。

该写法的贪心之处在于匹配过程之中，必须两者出现次序相同才能成功匹配这一个字母。如果出现次序不同，说明后面还有需要消除的该字母。而每次操作是删去最前面的该字母，会破坏这一状态，不合法。

### 细节

------------
注意清空数组，同时我的程序跑得慢大概就是清空的这一部分。

## 代码

------------
```cpp
#include<bits/stdc++.h>
#define mx 30
using namespace std;
int n,a[mx],b[mx],f1[mx],f2[mx];
string s1,s2;
int main(){
	cin>>n;
	while(n--){
		cin>>s1>>s2;
		memset(a,0,sizeof(a));
		memset(b,0,sizeof(b));
		memset(f1,0,sizeof(f1));
		memset(f2,0,sizeof(f2));//清空 awa 
		int l1=s1.length(),l2=s2.length();
		for(int i=l2-1;i>=0;i--){
			int tmp=s2[i]-'A';
			a[i]=++f1[tmp];
		}
		for(int i=l1-1;i>=0;i--){
			int tmp=s1[i]-'A';
			if(f1[tmp]){
				b[i]=++f2[tmp];
			}
		}//倒序预处理 
		int cnt=0;//指向 
		for(int i=0;i<l1;i++){
			if(b[i]==a[cnt]&&s1[i]==s2[cnt]){
				cnt++;//当前原串字母是指向的目标串字母
			}//且两者出现次序相同
		}
		if(cnt==l2){//全部匹配 
			puts("YES");
		}else{
			puts("NO");
		}
	}
	return 0;
}
```

### 其他的话
------------
有神犇能优化本蒟蒻这种做法的欢迎在评论区指出，谢谢 awa