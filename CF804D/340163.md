标题是因为写这道题的时候在听。

首先根据树的性质，一个点到树中最远的距离可以通过直径得出。具体的，如果直径为 $(u,v)$ 这条链，那么点 $c$ 到树中的最远距离即为 $\max(\operatorname{dis}(u,c),\operatorname{dis}(v,c))$。这个性质的实际运用是两次 DFS 找到树的直径，当然在这题中有更直接的运用。

那么对于每一棵树都线性求出它们中的所有点到树中最远的距离，记为 $p_1,p_2,\cdots ,p_n$。现在连接两棵树，假设连接到了 $u,v$，那么直径即为 $\max(d_1,d_2,p_u+p_v+1)$（其中 $d_1$ 表示第一棵树原来的直径，$d_2$ 同理）。

这个取 $\max$ 不太合理。先考虑一次查询，将子树里的点按 $p$ 值从小到大排序，这样就可以用双指针解决问题，贡献拆算比较简单，不再赘述。

但是总共有 $q$ 次询问。加上两个简单的优化就可以做到 $O(n \sqrt n \log n + q \sqrt n \log n)$：

1. 记忆化，即对相同的两棵子树，算出答案并记录（使用 `map`）；   
2. 双指针的时候指针暴力移动树大小小的那个，另外一个指针应该使用二分查找。

具体的复杂度分析可以这样考虑：树大小不小于 $O(\sqrt n)$ 的总共只有 $O(\sqrt n)$ 个，这样就只有 $O(n)$ 对本质不同的询问，暴力做并记忆化就是 $O(n \sqrt n)$ 或者 $O(n \sqrt n \log n)$；对于两个小于 $O(\sqrt n)$ 的树，暴力做就是 $O(q \sqrt n)$ 或者 $O(q \sqrt n \log n)$ 的；小块对大块可能产生很多组不同的询问，注意到小块大小只有 $O(\sqrt n)$，那么另外一个树可以二分处理来平衡复杂度。

可是 emu 在写这个题的时候忘记二分平衡复杂度了！可是还是过了，可见这个常数之小 ×

那么，只有一份复杂度错误的参考实现。改成二分并不困难，那就不改了。[评测链接](https://codeforces.com/contest/804/submission/176147268)，可见实际上代码并不长。