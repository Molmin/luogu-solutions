### [算法]
#### 【算法介绍】
暴力枚举会TLE，如果是打标会MLE，看大家都写的是分治，这里介绍一种利用深度优先遍历的做法。
#### 【算法实现】
1、我们首先对1至50号的字符串的长度进行预处理。

2、然后我们找到第一个长度大于询问的位置N的字符串。

3、开始进行深度优先搜索：
#### 【搜索策略】
(1)首先，我们知道任意一个字符串s[i]都是由s[i-1]接上中间的一部分内容再接上s[i-1]得到，我们将这三部分分别成为开头、中间、结尾，通过分析，可以算出开头的最后一个字符的位置和结尾的第一个字符的位置，我们将其成为左指针和右指针。

(2)分类讨论：

如果待求解的位置位于左指针和右指针的中间，即位于一个由一个m和多个o组成的字符串中时，若待求解的位置位于该字符串的第一位，则直接输出m，否则输出o。

如果待求解的位置位于左指针及其左边，则直接到s[i-1]中寻找当前位置。

如果待求解的位置位于右指针及其右边，则再s[i-1]中搜索待求解的位置在结尾字符串中的位置。

具体实现方法见程序
### 【代码】
```cpp
#include <bits/stdc++.h>
using namespace std;

long long len[51];

void dfs(int weizhi,int num){
	int mid=len[num]/2,k=num/2+2,left,right;//通过找规律找到字符串中点字符的编号与开头字符串最后一个字符的编号之差的规律 
	if(num%2==0)
		k--;
	left=mid-k;								//分别找到开头字符串的最后一个字符和结尾字符串的第一个字符的位置 
	right=len[num]-left+1;
	if(weizhi>left && weizhi<right){		//如果查找的位置位于中间，则可以得出答案 
		if(weizhi==left+1)
			printf("m");
		else
			printf("o");
		exit(0);							//找到答案，直接退出程序 
	}else									//否则，在前后两个字符串中继续搜索 
	if(weizhi<=left){
		dfs(weizhi,num-1);
	}else{
		dfs(weizhi-right+1,num-1);			//weight-right+1为询问的位置在结尾字符串中的位置 
	}
}

int main(){
	int i,j,k,m,n;
	len[0]=3;
	for(i=1;i<=50;i=-~i)				//预处理1到50号字符串的长度 
		len[i]=2*len[i-1]+i+3;
	scanf("%d",&n);
	for(i=1;i<=50;i=-~i)				//找到第一个长度大于询问的位置N的字符串的编号 
		if(len[i]>=n)
			break;
	dfs(n,i);							//在找到的字符串中进行搜索 
	return 0;
}
```