## 题目描述

有一个无向图，顶点标号 $1 \sim N$，最初没有边。

给定 $Q$ 个操作，每次操作完后输出孤立点的数量。

- `1 u v`：连接点 $u$ 和点 $v$；
- `2 v`：删掉所有与 $v$ 相连的边。

$2 \le N \le 3 \times 10^5,\ 1 \le Q \le 3 \times 10^5$

## 分析

这道题可以直接根据题意模拟。

定义答案变量  `res​` 表示当前孤立点的数量，显然最初 `res = n`。

由于接下来会有删除这种操作，这样使用 `vector` 或邻接表存图比较困难，因此使用 `set` 存图。

接下来分别处理两种操作。

- `1 u v`：连接点 $u$ 和点 $v$；
  
  如果连边前 $u$ 是孤立点，那么连边后孤立点的数量就会少 $1$，因此 `res​ -- `。$v$ 同理。然后连一条无向边。
  
  ```cpp
  if (g[u].empty()) res -- ;
  if (g[v].empty()) res -- ;
  g[u].insert(v);
  g[v].insert(u);
  ```
- `2 v`：删掉所有与 $v$ 相连的边。
  
  如果 $v$ 本身就是一个孤立点，那么删完边后没有发生变化，所以不做考虑。以下讨论的都是 $v$ 不是孤立点时的情况。
  
  首先找到所有与 $v$ 相邻的点，并在这个点所能到达的点的集合里将 $v$ 删除，然后判断删除后这个点是不是孤立点。若是则 `res ++ `。
  
  由于删完边后就没有了与 $v$ 连接的点，所以 $v$ 就变成了一个孤立点，因此再次 `res ++ `，然后删除所有与 $v$ 相连的边。
  
  ```cpp
  if (!g[u].empty())
  {
      res ++ ;
      for (int i : g[u])
      {
          g[i].erase(u);
          if (g[i].empty()) res ++ ;
      }
      g[u].clear();
  }
  ```

最后输出答案即可。

[Code](https://atcoder.jp/contests/abc302/submissions/41583636)
