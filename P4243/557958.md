
[题目传送门](https://www.luogu.com.cn/problem/P4243)

[更好的阅读体验](https://www.luogu.com.cn/blog/d-a-n-n-y-1-0-1/solution-p4243)

#### 题目大意：

给定一个序列，支持两种操作：

- 区间加上一个等差数列

- 求区间最少能被分成几个等差数列

#### 大致思路：

首先，一看区间修改区间查询，肯定是线段树跑不了。但是等差数列不好处理，怎么办呢？那就要用上经典的套路了——差分。比如原数列为：

```
1 1 2 3 4 5 2 5 8 
```

差分后就是

```
1 0 1 1 1 1 -3 3 3
```

可以明显的看出，原数列中的所有等差数列都变成了差分数列中相等的一小段，这样就方便多啦！

接下来该处理两种操作了。

首先是简单的修改，我们可以观察一下规律，还是用上面的例子：

```
1 1 2 3 4 5 2 5 8 
```
差分后为：

```
1 0 1 1 1 1 -3 3 3
```

将 $[2,7]$ 区间加上首项为 $3$，公差为 $2$ 的等差数列，变化后的原数列和等差数列如下：

```
1 4 7 10 13 16 15 5 8
```

```
1 3 3 3 3 3 -1 -10 3
```

可以发现，在差分数列中只需将第一个数增加首项（$a$），以后的每一个数增加公差（$d$），最后一个数减少 $a+(r-l)\times d$ 即可。

接下来就到魔鬼的查询环节了！

接下来维护的就是原数列的差分序列了。注意到，在差分数列中，原数列中的等差数列表现为相等的一段，所以只需要找出区间能被划分成几个相等的序列即可。

首先，每个节点需要维护四个值（下面用 $s1,s2,s3,s4$ 来表示），设 $l,r$ 为当前节点维护的区间的左右端点，则 $s1,s2,s3,s4$ 分别代表 $(l,r),(l,r],[l,r),[l,r]$ 这四个区间的最少划分段数。

接下来，记 $a,b$ 分别为区间的左右端点的值。可以开始合并了！以 $s1$ 的合并为例：

```cpp
tmp.s1=sg[p<<1].s2+sg[p<<1|1].s3-(sg[p<<1].b==sg[p<<1|1].a);
tmp.s1=min(tmp.s1,min(sg[p<<1].s1+sg[p<<1|1].s3,sg[p<<1].s2+sg[p<<1|1].s1));
```

即：双开区间划分的段数就是左子区间的左开右闭区间划分的段数加上右子区间划分的段数。

如果左子区间最后一个数和右子区间第一个数相等，那么可以合并左边的最后一段和右边的第一段，就可以少划分一段。

另外，还要对零散值进行判断，也即上方的第二行。因为还有可能一个双开区间和一个一开一闭区间的组成方式划分段数最小。

四个合并都是类似的，我就直接上核心代码了：

```cpp
struct seg{
    int a,b,s1,s2,s3,s4;
}sg[400001];
//...
void pushup(int p){
    sg[p].a=sg[p<<1].a;
    sg[p].b=sg[p<<1|1].b;
    sg[p].s1=sg[p<<1].s2+sg[p<<1|1].s3-(sg[p<<1].b==sg[p<<1|1].a);
    sg[p].s1=min(sg[p].s1,min(sg[p<<1].s1+sg[p<<1|1].s3,sg[p<<1].s2+sg[p<<1|1].s1));
    sg[p].s2=sg[p<<1].s2+sg[p<<1|1].s4-(sg[p<<1].b==sg[p<<1|1].a);
    sg[p].s2=min(sg[p].s2,min(sg[p<<1].s1+sg[p<<1|1].s4,sg[p<<1].s2+sg[p<<1|1].s2));
    sg[p].s3=sg[p<<1].s4+sg[p<<1|1].s3-(sg[p<<1].b==sg[p<<1|1].a);
    sg[p].s3=min(sg[p].s3,min(sg[p<<1].s3+sg[p<<1|1].s3,sg[p<<1].s4+sg[p<<1|1].s1));
    sg[p].s4=sg[p<<1].s4+sg[p<<1|1].s4-(sg[p<<1].b==sg[p<<1|1].a);
    sg[p].s4=min(sg[p].s4,min(sg[p<<1].s3+sg[p<<1|1].s4,sg[p<<1].s4+sg[p<<1|1].s2));
}
```