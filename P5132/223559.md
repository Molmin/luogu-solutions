首先你好几次都不过的原因可能是数据问题。

这题只能用
```cpp
if(i>j)ans+=min(a[j],a[i])*x;
```
这一写法，其他的非等价写法如
```
printf("%d",ans/2);
//全取最后除以二
```
等其他写法都是不行的（数据问题，别问我怎么知道的）。


------------
解题思路：

先说结论：对于每一个关联值，只需要将其与两关联法器中法力值较小的相乘的和即为答案。

然后给出一个不大严谨的证明：

原题中是要求求出一个排列顺序，使得其法力值与顺序在这个法器之后的所有法器的关联值乘积和最小。

那么，对于一个已经排好序的当前最优方案，考虑在其中塞进一个法器使得其还是下一个状态的最优排列。

这里很容易想到将所有的法力值比他大的法器放到这个的后面，这样一定能使对应的法器和关联值乘积最小。

因此，之前的所有状态也都一定是按照法力值排序的，故不会出现冲突的情况。


------------
代码：

```cpp
#include<cstdio>
#include<iostream>
using namespace std;
long long n,a[1005],x;
long long ans;
int main(){
	scanf("%lld",&n);
	for(int i=1;i<=n;i++)
	scanf("%lld",&a[i]);
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			scanf("%lld",&x);
			if(i>j)
			ans+=min(a[j],a[i])*x;
		}
	}
	printf("%lld\n",ans);
	return 0;
}
```
