看楼下的大佬写的代码这么短，蒟蒻我十分佩服。但我还有一个比较好理解的思路，想拿来分享一下

### 观察题目：如果要移动盘子有三个条件

1.含义：移动的两个盘子之间不能再有盘子，那么如果我们剔除所有没有盘子的柱子，就只能把盘子移动到与它相邻的柱子上了

2.含义：你取出盘子的柱子上必须只有一个盘子，取出后该柱子将没有盘子 （这意味不得使用中转的柱子，必须把所有柱子上的盘子一次性移到一个柱子上）

注：的确，你可以把空柱子用来中转，但是既然是空柱子，直接跳过就可以了，所以这完全是多此一举。（如果一个柱子为空柱子，直接剔除就可以啦）

3.含义：大盘子在下面，小盘子在上面。所以我们应该把所有盘子往有最大盘子的柱子上面移动

## 综上，我们要干以下几件事：

1.找到含有最大盘子的柱子

2.把和它相邻的柱子上最大的盘子叠上去（如果先叠了小的，大的就没法叠了，所以一定要先叠大的），如果发现柱子最上面的盘子没它相邻的柱子上最大的盘子大，输出"NO"

3.叠上去后，该柱子变为空柱子，剔除出考虑范围，如果所有柱子（除了原先还有最大盘子的柱子）都被剔除了，输出“YES”

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[200005];
int main()
{
	int n,i=1,maxn=-1,t;
	cin>>n;
	while(i<=n)
	{
		cin>>a[i];
		if (maxn<a[i])
		{
			maxn=a[i];
			t=i;
		}
		i++;
	}//步骤1
	int l=t-1,r=t+1,now=maxn;
	while(l>=1||r<=n)
	{
		if (l<1)
		{
			if (a[r]>=now)
			{
				cout<<"NO"<<endl;
				return 0;
			}
			now=a[r];//记录
			r++;//移动光标
		}
		else if (r>n)
		{
			if (a[l]>=now)
			{
				cout<<"NO"<<endl;
				return 0;
			}
			now=a[l];//记录
			l--;//移动光标
		}
		else
		{
			bool flag=0;
			if (a[l]>a[r]) flag=1;
			if (max(a[l],a[r])>=now)
			{
				cout<<"NO"<<endl;
				return 0;
			}
			if (flag)
			{
				now=a[l];
				l--;
			}
			else
			{
				now=a[r];
				r++;
			}//判断左右两边哪个大，再进行处理
		}
	}
	cout<<"YES"<<endl; //移动完毕，未发现问题
	return 0;
}
```
