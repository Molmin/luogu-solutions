[题目链接](/problem/P2152)

题意：求 $\gcd(a,b)$，其中 $a,b\le10^{10000}$。

在 OI 中，常见的、较为高效的求 $\gcd$ 的方式无非就 $3$ 种：

$1)$ **更相减损术：**

出自《九章算术》。

原理：当 $a>b$ 时，$\gcd(a,b)=\gcd(a,a-b)$。

证明：

> 设 $c$ 为 $a,b$ 的公约数，则设 $a=pc,b=qc$，其中 $p,q$ 为整数。
>
> 那么有 $a-b=(p-q)c$，即 $c$ 是 $a-b$ 的约数。
>
> 所以 $c$ 是 $a,a-b$ 的公约数。也就是说，$a,b$ 的公约数集合和 $a,a-b$ 的公约数集合是一样的。那么其中最大的那个也是一样的。
>
> 因此 $\gcd(a,b)=\gcd(a,a-b)$。得证。

代码也很好写（无高精）：
```cpp
inline int gcd(int a, int b)
{
	if ( a < b ) swap(a, b);
	if ( !b ) return a;     // gcd(a, 0) = a
	return gcd(a, a - b);
}
```
时间复杂度最坏是 $O(n)$ 的，例如当 $a$ 很大，$b=1$ 时需要迭代 $a-1$ 轮。显然无法通过本题。

$2)$ **欧几里得算法：**

原理：$\gcd(a,b)=\gcd(b,a\bmod b)$。

证明：

> 设 $c$ 为 $a,b$ 的公约数，则设 $a=pc,b=qc$，其中 $p,q$ 为整数。
>
> 再记 $a=kb+r$，其中 $k=\left\lfloor\dfrac ab\right\rfloor,r=a\bmod b$，则 $pc=kqc+r$，转化得 $r=(p-kq)c$，即 $c$ 是 $a\bmod b$ 的约数。
>
> 所以 $c$ 是 $b,a\bmod b$ 的公约数。也就是说，$a,b$ 的公约数集合和 $b,a\bmod b$ 的公约数集合是一样的。那么其中最大的那个也是一样的。
>
> 因此 $\gcd(a,b)=\gcd(b,a\bmod b)$。得证。

跟上面的很像对吧。

事实上，取模可以看成连续减很多次，因此二者近乎一样。

代码也同样很好写（无高精）：
```cpp
inline int gcd(int a, int b)
{
	if ( !b ) return a;     // gcd(a, 0) = a
	return gcd(b, a % b);
}
```
时间复杂度是 $O(\log n)$ 的，因为每次取模都会让大的数至少减半。最坏情况下是求斐波那契数列的相邻两项的 $\gcd$，达到最大复杂度。

理论上这题可以使用，但写高精除高精和高精对高精取余两个操作过于繁琐了。那有没有更好的方法呢？

$3)$ **更相减损术，但“可半者半之”：**

“可半者半之”这句话是在《九章算术》中“更相减损术”的第一句。

原理：当 $a>b$ 时，$\gcd(a,b)=\begin{cases}2\gcd(\dfrac a2,\dfrac b2)&2\mid a,2\mid b&(1)\\\gcd(\dfrac a2,b)&2\mid a,2\nmid b&(2)\\\gcd(a,\dfrac b2)&2\nmid a,2\mid b&(3)\\\gcd(a,a-b)&2\nmid a,2\nmid b&(4)\end{cases}$。

证明：

> $(1)$：若 $a,b$ 都有 $2$ 因子，那么它们的 $\gcd$ 必然含有 $2$ 因子。将 $2$ 除去各自计算即可；
>
> $(2),(3)$：若 $a,b$ 仅有一个有 $2$ 因子，则这个 $2$ 因子一定不会产生任何贡献，直接除掉即可；
>
> $(4)$ 的证明见上。

代码略微繁琐一点（无高精）：
```cpp
inline int gcd(int a, int b)
{
	if ( a < b ) swap(a, b);
	if ( !b ) return a;     // gcd(a, 0) = a
	if ( ( a & 1 ) && ( b & 1 ) ) return gcd(a, a - b);
	if ( a & 1 ) return gcd(a, b >> 1);
	if ( b & 1 ) return gcd(a >> 1, b);
	return gcd(a >> 1, b >> 1) << 1;
}
```
因为大多数操作都是除以 $2$ 和对 $2$ 取模，可以使用位运算，高精写起来也方便一些。

因为 $(1),(2),(3)$ 情况都会使一个数 $\div2$，即让规模变成原来的一半。$(4)$ 操作当且仅当二者都为奇数的时候才会触发，但二者相减后又会出现偶数，又可以 $\div2$。因此时间复杂度是 $O(\log n)$ 的。

简单加一手高精就行了。高精自己写，完整代码不贴。