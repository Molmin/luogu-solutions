区间加不好直接搞，考虑先对原数组进行差分。

记 $b_i=a_i-a_{i-1}\left(1\leq i\leq n+1,a_0=a_{n+1}=0\right)$。那么对于每次的操作，相当于令 $b_i$ 加上 $x\left(x\in \mathbb Z\right)$，并让 $b_j\left(j>i\right)$ 减去 $x$。最后的目标相当于 $\forall 2\leq i\leq n,b_i=0$。

显然存在一种方案，每次对 $b_1$（或 $b_{n+1}$）和 $b_i(2\leq i\leq n)$ 进行一次操作，此时操作次数为 $n-1$。

发现对于下标集合 $S\subset \left[2,n\right]$，如果 $\sum\limits_{i\in S}b_i=0$，那么我们可以通过在这个集合内部进行操作，从而使操作次数减少 $1$。

所以最小操作次数就是 $n-d-1$，其中 $d$ 为最多能分出的**互不相交**的集合 $S$ 的个数。

设 $f_T$ 表示集合 $T$ 最多能划分出的集合 $S$ 的个数，其中**要求 $T$ 满足 $\sum\limits_{i\in T}b_i=0$**。可以 预处理+状压dp 在 $O(3^{n-1})$ 内求出所有的 $f_T$，最后 $k$ 即为所有 $f_T$ 的最大值。

```cpp
	//代码中的f其实是对应元素的总和，ff才是上文中的f
	zt=1<<(n-1);
	for(int i=1;i<zt;i++)
	{
		int j=i&-i,xj=2;
		while(j!=(1<<(xj-2)))++xj;
		nn[i]=nn[i^j]+1,f[i]=f[i^j]+a[xj];
	}
	for(int i=1;i<zt;i++)if(f[i]==0)
	{
		for(int j=i;j;j=i&(j-1))if(f[j]==0)ff[i]=maxx(ff[i],ff[i^j]+1);
		d=maxx(d,ff[i]);
	}
```

现在考虑计算方案数，考虑先将操作从有序转为无序，最后乘上排列数（因为在操作次数最少的情况下必不可能出现相同的操作）。

假设对于每次操作 $(i,j,x)$，我们想象成在点 $i$ 和点 $j$ 之间连一条边权为 $x$ 的边。可以发现对于**所有我们划分出的集合 $S$**，其所表示的点集最后一定**连成了一棵树**。而对于其他**没有被划进任何一个集合**的点，一定**和点 $1$ 和点 $n+1$ 连成两棵树**，其中点 $1$ 和点 $n+1$ **分别在两棵树内**（这里的树都是有标号**无根树**）。

通过递归证明可以发现，只要连边方案确定，每条边的边权也唯一确定。

每个集合 $S$ 内连边的方案数显然为 $k^{k-2}$（其中 $k$ 为 $S$ 的元素个数）。设 $g_T$ 表示集合 $T$ 的连边方案数（$T$ 要求如上），用和上面类似的方法也可以在 $O(3^{n-1})$ 内推出。

```cpp
	//fff即为上文的g，初始化fff[0]=1
	for(int i=1;i<=n;i++)kk[i]=P(i,max(i-2,0))
	for(int i=1;i<zt;i++)if(f[i]==0)
	{
		//固定某位枚举子集，以防计算重复
		int ti=i&-i,es=i^ti;
		if(f[ti]==0&&ff[i]==ff[es]+1)fff[i]=fff[es];
		for(int j=es;j;j=es&(j-1))
		{
			int tj=j^ti;
			if(f[tj]==0&&ff[i]==ff[i^tj]+1)fff[i]=(fff[i]+1ll*fff[i^tj]*kk[nn[tj]])%p;
		}
	}
```

对于最后部分，可以考虑在点 $1$ 和点 $n+1$ 之间连边后计算连边方案数。如果考场上临时想不到或者忘了怎么算也可以去掉点 $1$ 和点 $n+1$ 来划分成若干棵**有根树**，计算出每部分的方案数相乘后再 $\times 2^t$（$t$ 为树的个数），也可以做到 $O(3^{n-1})$。
```cpp
	//ffff即为上文所述的东西，计算方式和fff基本一致，同样要初始化ffff[0]=1
	for(int i=1;i<=n;i++)kkk[i]=2ll*P(i,i-1)%p;
	for(int i=1;i<zt;i++)
	{
		int ti=i&-i,es=i^ti;
		ffff[i]=2ll*ffff[es]%p;
		for(int j=es;j;j=es&(j-1))
		{
			int tj=j^ti;
			ffff[i]=(ffff[i]+1ll*ffff[i^tj]*kkk[nn[tj]])%p;
		}
	}
```
最后枚举所有 $f_T=d$ 的 $T$，将两部分结果相乘累加即可得到操作无序时的方案数，乘上 $(n-d-1)!$即为答案。

复杂度 $O(3^{n-1})$。