# 一道题意转换加贪心题

## 思路

- 因为雷达要扫描到尽可能多的小岛,所以雷达放在海岸线(即x轴上)是最优的

- 因为雷达的横坐标与小岛的坐标都是实数所以不能用枚举雷达的坐标来得到雷达最多可以扫描到多少个,于是可以找出能扫描到某一个小岛的雷达横坐标坐标的范围(在范围内都可以找到)

- 得到所有小岛对应的区间(区间[a,b]表示从a到b的一个范围(包括a,b),在这里都表示能扫描到这个小岛的雷达的横坐标的取值范围(纵坐标为0)),让每个区间内都有雷达,因为每个区间都有雷达那么每个区间对应的小岛才都可以被扫描到,用贪心得到雷达数最小值

### 做法(嫌字多可以直接看下面的总结)

#### 一.怎么求区间

###### 注:
###### 1.以下如果横坐标取值范围为一个数时,不需在意,因为只是表达上不一样,其他都是可以用同一种方法表示出来的(如:横坐标范围为1.0~1.0,最大值为1.0,最小值为1.0,其他同理)

###### 2.一个岛的区间表示能扫描到这个小岛的雷达的横坐标的取值范围(纵坐标为0) ~~(复读机)~~

因为如果一个雷达可以扫描到一个小岛(即小岛在以雷达坐标为圆心,半径d的圆的范围内),那么如果做一个以小岛为圆心半径d的圆,那个雷达也一定在其范围内

图片

![](https://cdn.luogu.com.cn/upload/pic/75361.png)

由此我们可以推出只要雷达在以小岛为圆心半径d的圆上都是可以扫描到小岛的,因为雷达一定在x轴上(看思路)所以圆与x轴的两个交点就是可以扫描到这个小岛的雷达的区间(见上一张图)(左边的交点为区间的最小值,右边为最大值,在区间内必须有雷达),在这个区间内的雷达都可以扫描到它

#### 求每个小岛的区间方法:

- #### 方法1:

已知圆心(m,n),半径d,所以圆可以表示为$(x-m)^2+(y-n)^2=d^2$ ([圆的标准方程](https://baike.baidu.com/item/%E5%9C%86/54084?fr=kg_qa))

将y=0代入(在x轴上)化简得$ x^2-2mx+m^2+n^2-d^2=0 $

如果 ${4m^2-4*(m^2+n^2-d^2)}<0 $说明圆与x轴没有交点即这个小岛不可能被扫描到,输出-1,结束程序

如果大于等于,解得$x=\frac{2m±\sqrt{4m^2-4*(m^2+n^2-d^2)}}{2}$ (求根公式)

化简得 $x=m± \sqrt{d^2-n^2}$

所以左边的交点坐标为$(m- \sqrt{d^2-n^2},0)$,右边的交点为$(m+ \sqrt{d^2-n^2},0)$

所以小岛的区间是$[m- \sqrt{d^2-n^2},m+ \sqrt{d^2-n^2}]$

- #### 方法2:

如图

![](https://cdn.luogu.com.cn/upload/pic/75330.png)

~~(图片不能用Latex,没办法)~~

如果纵坐标大于d(即图中三角形直角边大于斜边),这个小岛不可能被扫描到,输出-1,结束程序

如果小于等于,小岛的区间是$[m- \sqrt{d^2-n^2},m+ \sqrt{d^2-n^2}]$


#### 二.贪心

 //可以参考 [P1250](https://www.luogu.org/problem/P1250) 种树

依题意,我们要让所有区间里都有雷达,因为这样所有区间对应的小岛才能都被搜到(贪心就是要一个雷达尽的在多个区间内,比如区间[1,3][2,4],在3放雷达这两个区间就都有了)

可以将区间看做线段(区间[a,b]等于开始坐标(a,0)结束坐标(b,0)的线段)

先将所有线段的结束坐标从小到大排序

定义di=-12345678(先初始化为一个很小的数,肯定不在线段上),为最右边的雷达位置

然后遍历所有的线段,如果di不在(在的话就直接下一个)线段上(表示线段上没有雷达),总雷达数+1,再将di等于线段的结束坐标,因为在结束坐标之前的线段(指整个线段都在结束坐标之前)上是一定有雷达的,所以放在结束坐标上才最有可能同时在其他没有雷达的线段上

为什么只用di判断线段上是否有雷达:因为如果di都不在线段上那么前面的雷达也不可能在线段上

上个图解释一下,其中雷达数最少为2

![](https://cdn.luogu.com.cn/upload/pic/75363.png)

## 总结

### 1.求出所有小岛能扫描到它的雷达的横坐标的取值范围

### 2.贪心用最少的雷达数使每个取值范围内都有雷达



------------


#### 完整代码(前面还没看明白可以看看注释,理解一下)

```cpp
#include<bits/stdc++.h>
using namespace std;
#define db double//方便打double(用db表示double)
db d,x,y,di=-213654789;//d为扫描半径,其它变量等一下会用到
int n,ans;//n小岛数,ans雷达数
struct xdd
{
	db st,ed;
}k[1001];//存储区间(线段)
int cmp(xdd s1,xdd s2)//结束坐标从小到大排序
{
	return s1.ed<s2.ed;
}
int main()
{
	cin>>n>>d;//输入
	for(int p=1;p<=n;p++)
	{
	 cin>>x>>y;//输入小岛坐标
	 if((d*d-y*y
	 )>=0)
	 {
	 	k[p].st=x-sqrt(d*d-y*y);
	 	k[p].ed=x+sqrt(d*d-y*y);
	 	//计算区间,注意加减的顺序,先减后加
	 }
	 else//扫描不到
	 {
	 	cout<<-1;
	 	return 0;
	 }
    }
    sort(k+1,k+n+1,cmp);//排序
	for(int p=1;p<=n;p++)
	{
		if(di>=k[p].st&&di<=k[p].ed)/*可以加上continue;*/;//如果di在线段上,没有东西执行(直接下一个)
		else
		{
			ans++;
			di=k[p].ed;
         //如做法中说的
		}
	}
    cout<<ans;//输出
    return 0;
}
```