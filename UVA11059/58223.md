## **题意**

给一串整数S，你需要找到其连续子序列中乘积最大的那个，输出其乘积。如果找到的答案不是正数，那么输出0，表示无解。

另外注意：每组输入后面都有一行空格，每组输出后面也应该有一行空格。输入以EOF结束。

然后，按照UVa中的数据范围，它不是很大，差不多就是：
1<=n<=18,-10<=s[i]<=10;

本人思路：

因为是最大乘积+连续子序列，所以这就是一个连乘题目
当然首先的一个思路就是暴力如下：

那么在这么小的数据范围内，一个longlong即可，因为数内有负数，所以我们可以先搜索一遍是否拥有负数，若没有，就把整个S数组乘起来，或者负数的个数共有偶数个也可以乘起来

### such as this：```ans*=s[i]```

若有负数且不为偶数个，那么就暴力搜索子序列中乘积最大的值，然后输出正解即可，这里的这个你可以认为是~~前缀和变成前缀乘~~

~~（那啥，这个代码我没写我用的是另一种思路，上面这个比较好理解）~~
 
 另一种思路：
 
 直接暴力（~~本人走暴力流~~）      
 连续子序列的两种要素：起点和终点。
 
 这里和上面的第二部有些类似，需要枚举起点和终点的位置即所有连续子序列。对于其中元素来说，只需要枚举出全部连续子序列然后计算乘积比较就行。
 
 对于其中的乘积不会超过10^18，所以爆搜加一个longlong就可以解决问题
 
 释放代码（~~蠢蠢欲动的代码~~）
 
 ```
#include<iostream>
#include<cstdio>
#include<algorithm> 

using namespace std;

long long s[105];//数组，来存的 

int main(){
	int n;
	int cnt=0;//这个是用来计算第几个解的 
	while(cin>>n){	
		long long ans=0;
		for (int i=0;i<n;++i)
			cin>>s[i];
		for (int i=1;i<=n;++i){
			for (int j=0;j+i<=n;++j){
			//这里的j是子序列的起点，从0开始找 
				long long jishu=1;//这个计数器是用来比较连续子序列乘积与ans原数的大小 
				//相当于计算器里的 M+ （笑） 
				for (int k=j;k<j+i;++k){
				//确定不同的终点 
					jishu*=s[k];//连乘 
					//尝试输出jishu，你就可以知道运行多少次
					//cout<<jishu<<endl;(不用谢) 
				}
				ans=max(ans,jishu);//开始比较，并且换上较大的数到ans中 
			}
		}
		printf("Case #%d: The maximum product is %lld.\n\n",++cnt,ans);//我认为这个输出比较麻烦
		//不要忘记\n 
	}
	return 0;
}
```