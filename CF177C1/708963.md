[CF177C1 Party](https://www.luogu.com.cn/problem/CF177C1)。

这一题与 [CF177C2 Party](https://www.luogu.com.cn/problem/CF177C2) 完全相等。

首先，读题。


Beaver 有 $n$ 个熟人，这些人之间有若干个朋友关系与讨厌关系。现在，Beaver 想邀请他们去一个派对。

当然，对于去派对的人是有要求的。

对于每一个去派对的人：

- 他的所有朋友的应该在派对中，不管是直接朋友还是间接朋友。
- 派对里不应该有他讨厌的人。

你的任务是求出 Beaver 可以邀请的最多的人数。


然后仔细阅读题后需要判断使用的算法。

通过阅读题目中的第一条判断条件：他的所有朋友的应该在派对中，不管是直接朋友还是间接朋友，和题目的第一句：Beaver 有 $n$ 个熟人，这些人之间有若干个朋友关系与讨厌关系，可以判断出这一道题可以用并查集的做法。

再思考算法的细节。

题目给出了一张图片很好的提示了我们。
![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF177C2/2a1afae751aa0d8fbeb2d7b54cbbe0f7e8bfc3ce.png)

这张图片表示了样例中的朋友关系。

不看红色的线条，可以看出这些人组成了三个连通块，可以说这几个连通块指朋友圈。我们可以代入并查集的模版维护每一个朋友圈。

然后加入红色的线条。我们以第 $6$,$7$,$8$,$9$ 个人组成的朋友圈提出问题：这一个朋友圈是否可以参加派对？再一次阅读题目。


对于每一个去派对的人：

- 他的所有朋友的应该在派对中，不管是直接朋友还是间接朋友。
- 派对里不应该有他讨厌的人。


可以得出答案为否。因为如果要所有成员都在派对里，那么中间就有两个人出现了矛盾，不符合第二点，所以不可以。

由此得出如果朋友圈中有一对讨厌的关系的人是不能参加派对的，因为一定会与规则矛盾。我们可以在维护并查集后，用一个数组记录每一个出现讨厌关系的朋友圈。

然后再看另外两个朋友圈。依次判断他们是否合法，得出答案：都是合法的。那么就挑选比较优的一点（疑问：翻译好像有误，第二点应该是：派对里不应该有他讨厌的人或非朋友的人）。是否更优的条件是什么呢？当然是人数多的更优啦！那么我们可以再用一个数组记录每一个合法的朋友圈的人数，再用变量判断最大值就可以了。

到了这里，所有核心部分都讲解完了。下面贴出代码：
```
#include<bits/stdc++.h>
using namespace std;
long long n,k,m,a[100005],ans,A[100005];
bool bj[10005];
long long find(long long x)//寻找朋友圈代表。
{
	if(x==a[x]) return x;//如果就是x，那么就返回x。
	return a[x]=find(a[x]);并查集的一个优化，将自己的上级直接等于自己所在的朋友圈代表。
}
int main()
{
	cin>>n>>k;
	for(int i=1;i<=n;i++) a[i]=i;//一开始每一个人的朋友圈只有自己，代表也是自己。
	for(int i=1;i<=k;i++)
	{
		long long x,y;
		cin>>x>>y;
		if(find(x)!=find(y)) a[find(y)]=find(x);//如果本来就不是同一个朋友圈的那么就将其中一个的代表的代表记录为另一个的代表。		
	}
	cin>>m;
	for(int i=1;i<=m;i++)
	{
		long long x,y;
		cin>>x>>y;
		if(find(x)!=find(y)) continue;//如果不是同一个朋友圈则不用进行下面的步骤。
		bj[find(x)]=1;//将自己的朋友圈记录为不合法。
	}
	for(int i=1;i<=n;i++) A[find(i)]++;//将每一个朋友圈的人数记录。
	for(int i=1;i<=n;i++)
		if(a[i]==i&&!bj[i]) ans=max(ans,A[i]);//如果合法那么就择优。
	cout<<ans;/
    return 0;
}
```

致管理员：如果有错误，请一次性将错误指出，让我更快的改正错误，谢谢。