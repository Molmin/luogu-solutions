# 这道题是一道玄学题
刚开始我一看

###### 定义一组数的权值为该组内所有数的异或和。请求出一种分组方案，使得分出的所有组数的权值之和最小，输出权值之和的最小值。

然后我就打了暴力，很好80分拿到手


------------

但是在打暴力的途中我阴差阳错的将所有输入的数都xor了一下

emmm刚好等于答案

于是我就过了，草率的过掉了这道题qwq


```cpp
#include<bits/stdc++.h>
using namespace std;
int n, a, ans;
int main(){
	scanf("%d", &n);
	scanf("%d", &ans);
	for(int i = 1; i < n; i++){
		scanf("%d", &a);
		ans ^= a;
	}
	printf("%d", ans);
	return 0;
} 
```

关于证明:

显而易见：

因为两个数的XOR一定小于两个数中较大的那个数，所以要求最小，只需要把所有的数全都XOR在一起就好了

qwq华丽丽的结束（蒟蒻发题解求轻喷）