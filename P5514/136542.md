# 前言：
这道题作为比赛的T1，显然难度不高，但是要避免进行复杂的思考，我已开始就犯了这个错误，但幸运的我看了看样例之后盲猜猜出了做法。这其实是一道不错的数论题。
# 瞎想
### 瞎想做法1
爆搜，暴力枚举放置，良心的出题人竟然给了80$pts$，太意外了。
### 瞎想做法2
看了一下样例，盲猜是异或一下，再加上数据达到了$10^6$，必然是$O(n)$的复杂度，于是打了个代码直接过了样例，上去一交就满分了。

关于这样子为什么可以过，我想出来一个一句话的解释：

**两个数相加或者异或，对于它们答案的二进制下每一位的结果是一样的（不考虑加法进位），但加法需要进位，所以两个数异或的结果必然小于相加。**

# $AC$ $Code$
### $Pascal$ $AC$ $Code$
```pascal
var
  n,i,ans,k:longint;
begin
  readln(n);
  for i:=1 to n do
  begin
    read(k);
    ans:=ans xor k;//异或一下
  end;
  writeln(ans);
end.
//pascal IO较慢，比c++慢很多，再加上不能优读，不推荐使用
```
### $C++$ $AC$ $Code$
```
#include<bits/stdc++.h>
using namespace std;
int n,k,ans;
int main()
{
  scanf("%d",&n);
  while (n--)
  {
  scanf("%d",&k);
  ans^=k;
  }
  printf("%d",ans);
}
//建议写快读+氧气，我很懒，就不写了
```
# 总结：
这是一道不错的数论题，和这道题代码一样的题其实是有的。比如给出n个数，求这n个数中唯一出现奇数次的数（保证只有一个），这道题的代码完全可以迁移运用，异或操作其实是很有意思的，感兴趣的同学可以自己去理解
