每一位其实只有$3$种决策，分别是： 

- 两个数字的这一位都是 0。
- $a$ 的这一位是 0，$b$ 的这一位是 1。
- $b$ 的这一位是 0，$a$ 的这一位是 1。

大家可能还想到了一个决策：两个数字的这一位都是 1，但是这样不对。

因为题面要求 $a+b=a \oplus b$，那么每一位的计算结果都应该是一样的。

如果两个都是 1，异或操作结果为 0，和操作却会进位，导致结果不一样。

在知道了这一点后，寻找两种操作的值相同的数字就不难了,接下来考虑大小限制。

对于最高位，我们有三种决策，也就是上面说的三种，我们来看一下每种对应个方案数是多少。

两个数字的这一位都是 0。那么，无论后面是什么，和绝对小于 $L$，原因显然，异或不会进位。

所以方案数就是 $3^{len-1}$，$len$ 表示 $L$ 的二进制位数。

两个数字一个这一位是 1，一个这一位是 0。那么，后面就不能随心所欲了，在后面的一段决策是固定的。

这一段就是这一位距离下一位 1 中间的一段 0。在这一段我们的决策一定是两个数字都是 0，否则显然会大于 $L$。

遇到下一个 1 的时候，我们又要做与最高位相同的选择了。

所以，我们将所有的 1 作为一个决策点，做 DP，从低位向高位转移。

设 $f_i$ 表示从高位往低位数第 $i$ 个 1,，往后有多少种方案。

$$
f_i=3^{n-x}+2\times f_{i+1};
$$


```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,pw3[100005],len,f[100005];
const long long mod=1e9+7;
char c[100005];
vector<long long>v;
int main()
{
	scanf("%s",c+1);
	n=strlen(c+1);
	pw3[0]=1;
	for(int i=1;i<=n;i++)
	{
		pw3[i]=pw3[i-1]*3;
		pw3[i]%=mod;
		if(c[i]=='1')v.push_back(i);
	}
	len=v.size();
	f[len]=1;
	for(int i=len-1;i>=0;i--)
	{
		long long x=v[i];
		f[i]=pw3[n-x]+2*f[i+1];
		f[i]%=mod;
	}
	printf("%lld",f[0]);
}
```