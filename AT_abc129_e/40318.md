## 题意

以二进制形式给出一个整数 $L$ ，问有多少个非负整数对 $(a, b)$ 满足：$a+b = a \oplus b \le L$。答案对 $10^9+7$ 取模。

## 题解

首先，因为异或相比加法只能让两个一变成零，而不能产生新的一，所以不可以产生进位。

另 $f[i][1]$ 表示 $a+b$ 二进制前 $i$ 个刚好是 $L$ 的前 $i$ 位的方案数，$f[i][0]$ 是严格小于 $L$ 的方案数。

若 $L$ 当前位为 $1$, 那么恰好等于 $L$ 时， $a,b$ 可以分别填 $0, 1$ 或 $1, 0$， 所以 $f[i][1] = f[i-1][1] \times 2$。当前位为 $0$ 时 $f[i][1] = f[i-1][1]$ 。

考虑不严格小于的情况，若前面已经严格小于了，那么这一位可以随便填，不进位就行，有 $a,b$ 当前位为 $0,1|1,0 | 0,0$ 的三种情况，$f[i][0] = f[i-1][0] \times 3$, 还有一种情况是前面都相等，刚刚从这一位开始不相等，仅在 $L$ 当前位是 $1$ 时有这种情况，只能填 $0,0$, 所以此时 $f[i][0] = f[i-1][0] \times 3 + f[i-1][1]$

## 代码

代码很短，**只有 $9$ 行**。

```cpp
#include <cstdio>
long long f0 = 0, f1 = 1, p = 1000000007, s;
signed main() {
	while(scanf("%c", &s) != EOF && (s == '0' || s == '1')) {
		f0 = f0 * 3 % p;
		if(s == '1') f0 = (f0 + f1) % p, f1 = f1 * 2 % p;
	}
	printf("%lld", (f0+f1) % p);
}
```

~~我不会告诉你把 s 定义成 long long 仅仅是为了美观的。~~