算法一

首先是暴力算法。 第一种是完全按照题意模拟，枚举首尾，然后累加中间一段，取最大值。如果你愿意把累加中间段的这一重循环省略掉，加上前缀和优化即可。不过意义不大。 时间效率O(N^4)//完全朴素 O(N^3)//加上前缀和优化 空间效率O(N)

算法二 做题量稍大的同学估计读完题就能发现这是个（几乎是裸的）最大子段和问题。对于最大子段和问题，我们有O(N)的算法。 具体的做法是这样的：当前要求第I位及之前的最大子段和，如果第（I-1）位及之前的最大子段和大于0，则显然这一位取了也未尝不可（不会减少），也就是当前这一位和前面一段连接起来。否则的话，就新开一段——把前面的最大子段和改成0以后继续往下扫描。，

DP方程为 f[i]=max{a[i],f[i-1]+a[i]}

其中f[i]表示前i个数的最大子段和。

上述算法能拿到80分。关键在于算到后来已经超出了int64的范围。怎么办呢？你可以写个高精度，不过要分正负讨论，比较麻烦，这里不再赘述。 有一个方法可以较好解决这个问题。想一想，除了第1个小朋友以外，后面的小朋友的分数值肯定是单调不递减的。那么我们不用把值都记录下来，可以一边处理，一边mod。如果碰到可以更新的（当前这个小朋友的分数值大于0），根本不用考虑是否比Max要大。（肯定比Max要大）因此直接用这个小朋友分数值modP的值更新Max即可。至于第1个小朋友，再分类讨论一下即可。

这个思路有一个需要注意的地方，分数值+特征值会超过longint、int64（高精度可以解决），这里采用计算max时执行mod p操作，于是就产生了如下问题：

输入：

5 981
-409 -401 97 -96 -301

特征值：-409 -409 -312  97  97

分数值：-409 -818 -818 -721 -624

max  ：-818 不变 -721 -624

最终max停留在了-624，但明显-409才是最大的分数值，这个问题其实就是max初值两个-409惹的祸，必须要在后面所有特征值中判断有没有绝对值大于409的，否则max需要考虑第一个分数值，以免出现这样的错误。

附上代码：

```cpp
var
    i,n,p:longint;
    a:array[0..1000000] of longint;
    f,b:array[0..1000000] of int64;
    max,temp:int64;
        flag:boolean;
begin
```
输入部分和求特征值部分省略
   
```cpp
   //f[i]表示分数,  b[i]代表特征值
        f[1]:=b[1];max:=f[1]+b[1];if b[1]<0 then flag:=false;
    for i:=2 to n-1 do begin
      f[i]:=max;
          if b[i]>0 then begin
             if not flag and (b[i]>-b[1]) then flag:=true;
             max:=(f[i]+b[i]) mod p;
          end;
        end;
        if not flag and (max<f[1]) then max:=f[1];
        writeln(max);
end.

```