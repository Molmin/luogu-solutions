## 另一种做法

##### 注意要开long long(我这里是用unsigned long long)

假设输入的数为

3

$x_1 ~~y_1$(题目说$y1≤x1$,但如果$x1=y1$,则$y1=0$(如果$x1=y1$,那么这$y1$头猪可以分配到$x1$个猪圈中,所以分配完$y1=0$),所以最后$y1<x1$,下同)

$x_2 ~~y_2$

$x_3 ~~y_3$

设答案为ans

下面的$mod$与$\%$是[求余运算](https://baike.baidu.com/item/MOD%E8%BF%90%E7%AE%97/7885553?fr=aladdin)

#### 先看第一组(即$x1,y1$)

因为$ans\%x1=y1$(依题意得)

所以可以先设$ans$为 $x1*n+y1$(n为非负整数,下文同)

正确性

$x1*n+y1\%x1$=$(x1*n~~mod~~x1$+$y1~~mod~~x1)\%k=(0+y1)\%k=y1\%k=y1$,所以可以将$ans$设成这个(注:$(a+b)\%k=(a\%k+b\%k$,$x1)\%k,x1$为$x1$的一倍数(一个数的倍数求余这个数为0),乘$n$后还是$x1$的倍数,$mod$后为$0,y1≤x1,mod$后为$y1$)

#### 看第二组

我们发现n为某一个值时$(x1*n+y1)\%x2=y2$(就是满足第二组的值),设这时的$n$值为$n_1$

#### 设$y1\%x2=m$

### 为了求出$n_1$,先要已知$x1,x2,y1,y2$求$(x1*n_1) \% x2$的值

##### 分三种情况(怎么判断情况在后面)

#### 当$y1\%x2+(x1*n_1)\%x2<x2$时

因为$y2=(x1*n_1+y1)\%x2=(y1\%x2+(x1*n_1)\%x2)\%x2=y1\%x2+(x1*n_1)\%x2($因为$y1\%x2+(x1*n_1)\%x2<x2$,求余$x2$
后不变$)$,所以$(x1*n_1)\%x2=y2-y1\%x2=y2-m$,所以$(x1*n_1)\%x2$为$y2-m$

#### 当$y1\%x2+(x1*n_1)\%x2=x2$时

$y2=(x1*n_1+y1)\%x2=(y1\%x2+(x1*n_1)\%x2)\%x2=0($因为$y1\%x2+(x1*n_1)\%x2=x2$,求余$x2$
为0$)$

因为$(x1*n_1+y1)\%x2=0$,所以$x1*n_1+y1$为$x2$的倍数,即$x1*n_1+y1=w*x2$($w$为正整数,即是$x2$的$w$倍),所以$x1*n_1=w*x2-y1$,
所以

$(x1*n1)\%x2$

$=(w*x2-y1)\%x2$

$=((w*x2)\%x2+(-y1)\%x2)\%x2$

$=((w*x2)\%x2-(y1\%x2))\%x2$

$=-(y1\%x2)\%x2$

$=-((y1\%x2)\%x2)$

$=-(y1\%x2)$

$=-m$($y1\%x2<x2$,所以求余后不变)

因为$y2=0$,所以$-m=0-m=y2-m$,所以$(x1*n1)\%x2=-m=y2-m$与第一种情况相等,所以可以直接认为是第一种情况

#### 当$y1\%x2+(x1*n_1)\%x2>x2$时

$y2=(x1*n_1+y1)\%x2=(y1\%x2+(x1*n_1)\%x2)\%x2$

因为$y1\%x2+(x1*n_1)\%x2>x2$,所以可以减去几个$x2$(当然式子中还要加回去保证得出的值相等),直到它小于$x2$,得$y1\%x2+(x1*n_1)\%x2-w*x2$($w$为正整数)

所以

$y2$

$=(y1\%x2+(x1*n_1)\%x2)\%x2$

$=((y1\%x2+(x1*n_1)\%x2-w*x2)+w*x2)\%x2$

$=((y1\%x2+(x1*n_1)\%x2-w*x2)\%x2-w*x2\%x2)\%x2$

$=((y1\%x2+(x1*n_1)\%x2-w*x2)+0)\%x2$

$=y1\%x2+(x1*n_1)\%x2-w*x2$

所以$y2=y1\%x2+(x1*n_1)\%x2-w*x2$,移项得$(x1*n_1)\%x2=y2-y1\%x2+w*x2$,所以$(x1*n_1)\%x2$的值为$y2-m+w*x2$



w的取值,因为$(x1*n)\%x2<x2,y1\%x2<x2$,所以$(x1*n)\%x2+y1\%x2<2*x2$,所以$(x1*n)\%x2+y1\%x2-x2<x2$,因为前面$y1\%x2+(x1*n_1)\%x2-w*x2<x2$,这里减一个$x2$就小于了,所以$w=1$

所以$(x1*n_1)\%x2$的值为$y2-m+x2$

#### 怎么判断为哪一种情况

先默认为第一种情况,如果得出的%y2-m%为正数(因为满足第三种的值用第一种求会为负数),那么值就是满足第一种(满足第二组同样认为是第一种),$(x1*n_1)\%x2$的值为$y2-m$,如果为负数就用第三种,即$(x1*n_1)\%x2$的值为$y2-m+x2$

#### 求$n_1$的值

现在已经$x1*n_1~~mod~~x2$的值了,设这个值为$q$(所以q为$(y2-k)+x2$或$y2-k$)

所以可以得出关于$n_1$的方程$x1*n_1~~mod~~x2=q$

得出$n_1$的最小解(用枚举来解方程就可以了)

现在$n_1$已知了,所以$x1*n_1+y1~~mod~~x2$也已知,且满足前两组数据(因为求$x1*n_1\%x2$的值时就是当它满足第二组数据的值(就是通过第二组数据得出的),所以满足第二组,$x1*n_1+y1$的格式还是$x1*n+y1$,所以还是满足第一组)

同时除了这个数以外,$((x1*n_1+y1)+lcd(x1,x2)*m)$($m为正整数$)也满足前两组(lcd(a,b)为a与b的最小公倍数,求法在代码里,且这个式子里求到后面lcd里不止两个数,如lcd(a,b,c))

因为$lcd(x1,x2)*m$求余$x1,x2$为0,所以不影响最后结果(lcd(x1,x2)为x2的倍数,乘m后还是x2的倍数,mod后为0,同时对于x1,也不影响,所以满足前两组数据)

所以对于前两组数据$ans=(x1*n_1+y1)+lcd(x1,x2)*m$时是可以的(其中只有m为未知数,其他都已知)

#### 结论

我们发现第一组和第二组处理完的式子都是(已知数1$*$未知数+已知数2),所以第三组的做法也都是和第二组一样的,最后一个数的式子求完,输出已知数2就可以了(因为已知数1$*$未知数实际上时求后面的数用的,后面没数就不需要了)

#### 最后给三个公式一个算法

$gcd(a,b,c)=gcd(gcd(a,b),c)$(gcd(a,b)的意思是a,b的最大公因数)

$lcd(a,b)=(a*b)/gcd(a,b)$(lcd为最小公倍数)

$lcd(a,b,c,d)=lcd(lcd(a,b,c),d)$

#### 求最大公因数的[辗转相除法](https://baike.baidu.com/item/%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95?fromtitle=%E8%BE%97%E8%BD%AC%E7%9B%B8%E9%99%A4%E6%B3%95&fromid=4625352)

```cpp
ll gcd(ll q1,ll q2)//求q1,q2公因数
{
	if(q2==0) return q1;
    else return gcd(q2,q1%q2);//注意顺序
}
```

实际例子(选自百度百科[中国剩余定理](https://baike.baidu.com/item/%E5%AD%99%E5%AD%90%E5%AE%9A%E7%90%86/2841597?fromtitle=%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86&fromid=11200132&fr=aladdin))

例四：有1个数，除以7余2．除以8余4，除以9余3，这个数至少是多少？

除以7余2的数可以写成7n+2。

7n+2这样的数除以8余4，由于2除以8余2，所以要求7n除以8余2。

7n除以8余2，7除以8余7，要求n除以8余6（乘数之余等于余数之乘），则n最小取6。

所以满足“除以7余2，除以8余4”的最小的数是7×6+2=44，

所有满足“除以7余2，除以8余4”的数都可以写成44+56×m。

要求44+56×m除以9余3，由于44除以9余8，所以要求56×m除以9余4。（加数之余等于余数之加）

56×m除以9余4，由于56除以9余2，所以要求m除以9余2（乘数之余等于余数之乘），则m最小取2。

所以满足“除以7余2，除以8余4，除以9余3”的最小的数是44+56×2=156。

## 代码(其他没讲的都在这里了)

```cpp
#include<bits/stdc++.h>
using namespace std;
#define ll unsigned long long//等一下直接用ll代替unsigned long long
ll a,b,s[10001],k[1025],n,x[101];//a代表前面正文式子中的未知数的系数,b为已知数2,s[]存储正文的x,k[]存储正文的y,n为数据组数,x[i]为前s[1-i]的最小公倍数
ll gcd(ll q1,ll q2)//求最大公因数
{
	if(q2==0) return q1;
    else return gcd(q2,q1%q2);
}
ll lcd(ll kk)
{
	return (x[kk-1]*s[kk])/gcd(x[kk-1],s[kk]);//实际上就是求lcd(lcd(前kk-1个s[]),s[kk])
}
ll qy(ll m,ll bc,ll y)//枚举求正文讲的n(其实就是式子中的未知数)
{
	for(int i=0;i<=1000000;i++)//枚举n
	{
		if((i*m)%bc==y) return i*m;//直接返回已知数1*未知数
	}
}
int main()
{
	cin>>n;
	for(int p=1;p<=n;p++) cin>>s[p]>>k[p];
	x[1]=s[1];//第一个数的最小公倍数为本身
	for(int i=2;i<=n;i++) x[i]=lcd(i);//初始化最小公倍数
	a=s[1];//第一个未知数的系数为s[1]
	b=k[1];//第一个已知数为k[1]
	for(int i=2;i<=n;i++)//从第二组开始一组一组求
	{
		ll y=b%s[i];//按前面方法的求q
		y=k[i]-y;
		if(y>k[i]) y=s[i]+y;//如果为负
		ll a1=x[i];//前面m的系数(需要为前面所有数的最小公倍数)
		b=qy(a,s[i],y)+b;//更新b,注意要加上原来的b(看正文最后ans的式子加了y1)
		a=a1;//更新a
	}
	cout<<b;//最后输出已知数2
}
```

