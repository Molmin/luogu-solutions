很显然，这就是**大名鼎鼎**的
### 中国剩余定理！


------------
可惜蒟蒻不会

好在这一题的数据没有那么可怕，因此我们可以使用**枚举**来A掉这道~~水题~~，因此~~只需要小学五年级的水平~~


------------


##### 枚举什么呢？怎样枚举呢？不慌，我们先来看几个例子：
3 1、5 1

一看便知答案为3*5+1=16

3 1、5 2

稍加思考也能得到答案为7

3 1、17 15

这个口算就有一点难度了，最终答案为49

3 1、103 66

不用算了 为169


------------
##### 总结一下，前三个样例在寻找答案时有什么规律吗？
#### 事实上，不难发现对于两组同余式，我们解它的时候总是先满足其中一个同余式，然后不断加上该同余式所对应的ai，当累加的结果满足另一个同余式时即为我们所求的最小值
#### 比如说第一个例子3 1、5 1，满足第一个同余式的最小数为1，然后不断加3，加五次后得到数16，满足第二个同余式，答案即为16
#### 同样，对于第二个例子，满足第一个同余式的最小数为1，然后不断加3，加两次后得到数7，满足第二个同余式，答案即为7
#### 以此类推......
#### 而这一过程用while循环就可以实现


------------
#### 得到了两组同余式的解法，我们推广一下即可，n组同余式可从前往后，每次取前一次得到的最小数与本同余式进行运算，循环n-1次便可得出答案

#### 比如，对于题目中给出的样例：
3

3 1

5 1

7 2
#### 首先取前两组3 1、5 1，根据上文所述的过程得到满足前两组同余式的最小值为16，再用这个最小值与7 2进行运算，每次增加3和5的最小公倍数15，由于16已经满足第三个同余式，不需要累加。得到答案为16
------------
### ok，你们最期待的代码来了
```
#include<iostream>
#include<algorithm>
using namespace std;
struct pig{
	int a1,b1;
}a[11];//定义结构体存储a与b
int gcd(int x,int y){//公约数函数，用来求每一次循环累加的值
	if(x%y==0) return y;
	else return gcd(y,x%y);
}
int main(){
	long long n,ans,sum=1;//数据较大用longlong
	cin>>n;
	for(int i=1;i<=n;++i){
		cin>>a[i].a1>>a[i].b1;
	}
	ans=a[1].b1;//初始化最小值
	for(int i=1;i<n;++i){//开始循环
		sum=sum*a[i].a1/gcd(sum,a[i].a1);//sum为累加的值
		while(ans%a[i+1].a1!=a[i+1].b1){//循环条件
			ans+=sum;
		}
	}
	cout<<ans;
	return 0;
}

```


------------
### 祝愿大家AC，RP++


