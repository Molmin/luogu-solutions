# CF1725B
## 题意
这道题的意思是给定一个长度为 $N$ 的数组和 $D$，现在你可以把数组的任意的几个数改为数组里的另外的一个数，问修改完后最多可以组成多少组总和大于 $D$ 的组。
## 思路
一道贪心水题，我们先看数据：
```cpp
in:
6 180
90 80 70 60 50 100

out:
2

```
我们可以让一个大的带几个小的，这样就可以把较小的变为这几个数中最大的（原因见题目），比如这个样例就可以如下分组：
1. $100,50$ 一组，改为 $100,100$，$100 + 100 = 200,200 > 180$
2. $90, 80, 70$ 一组（有人会问为啥不能 $90, 70$ 一组，$90 + 90 = 180,180 \ge 180$ 但注意题目要求**严格大于**，所以不行），$90 + 90 + 90 = 270, 270 > 180$

那么实现就很简单了，具体步骤如下：

- 输入；排序。
- 设置变量 $Count, sum$，一个用来计数，一个看有没有超；倒序遍历数组；贪心，让 $sum + (\lfloor \frac{D} {P_i} \rfloor + 1)$（注意因为是**严格大于** $D$，所以要$+1$。
- 检查有没有超如果 $sum > N$ 那就超了，如果超了，退出循环；计数器加 $1$。
- 输出。

## 代码
```cpp
/*

 problem : https://www.luogu.com.cn/problem/CF1725B
 by : ztrztr(luogu 602124)
 date : 2022/10/16
 update : 2022/10/16
 
*/
#include<bits/stdc++.h>
using namespace std;
int N, D, P[100005];
int main() {
	cin >> N >> D;
	for (int i = 1; i <= N; i ++) {
		cin >> P[i]; //这是输入，不用说了 
	}
	sort (P + 1, P + N + 1); //排序，贪心是从大的开始往小的贪
	int Count = 0, sum = 0; //计数器 
	for (int i = N; i >= 1; i --) { //注意，因为我们是从大到小排序的，所以循环是倒着 
		sum += D / P[i] + 1; //注意，要加一，文中已说明
		if (sum > N) break;//如果严格大于N，直接结束循环 
		Count ++; //计数器 ++ 
	} 
	cout << Count;
}
```