## 简要题意
Pak Chanek 将从 $N$ 名候选球员中组成零支或多支球队，条件是每个候选球员最多只能加入一支球队。Pak Chanek 的每一支球队都将被派去与拥有 $D$ 力量的敌方球队进行一次比赛。在每一场比赛中，如果阵型球员的力量之和严格大于 $D$，则被派去的球队将被称为击败敌方球队。

Pak Chanek 的一项技能是，当一支已经组建的球队在比赛中比赛时，他可以改变球队中每个球员的力量，使之等于球队中最大的球员力量。


给定两个整数 $N$ 和 $D$，候选球员的数量和敌方球队的实力。

再给定 $N$ 个整数 $P_1$、$P_2$、$\ldots$、$P_ N$（$1≤P_i≤10^9$），所有候选球员的能力。


------------

### 贪心
显然，对于 Pak Chanek 的能力，要最大利用就必然是挑选能力最大的一个和最小的几个进行组队，只要能够击败对方，不再挑人，总人数减去这一组的人数作为下一轮可供挑选的人数。

排序使数组有序，运用手写 `cmp` 函数进行降序排列。循环枚举最大可能值。


------------

### 计算
对于每一次挑选，有总能力值等于能力值最大的球员的能力乘所选球员的个数。

设最大球员的能力为 $p_i$，对手能力值为 $d$。

则有个数 $ans= \lceil d/p_i \rceil $ 个 ，因为是严格大于，所以运用语言优势，舍去小数位后再加一，即最终个数为 $ans=d/p_i+1$。

判断人数是可能的情况（为非负整数），如果不是，则退出循环，否则答案就增加一。

最后输出答案即可。


------------

代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,d,p[1000005],ans;
bool cmp(int a,int b){
	return a>b;//降序排列 
}
int main(){
	scanf("%d%d",&n,&d);
	for(int i=1;i<=n;i++){
		scanf("%d",&p[i]);
	}
	sort(p+1,p+n+1,cmp);
	int n1=n;
	for(int i=1;i<=n;i++){
		n1-=d/p[i]+1;//对于每一次要击败对手，就要付出这么多的人数
		if(n1<0){
			break;//不符合就退出 
		}
		ans++;//未退出的话就表示有一种可能，累计答案 
	}
	printf("%d",ans);//把答案输出即可 
	return 0;
}
```