。。。果然是CF一道愚人节的题目。。。

还好本人没恶评，评了个普及-（谁敢恶评偶去找TA）

好吧其实这题完全可以转化为另一个问题：
```
给你一个n层的汉诺塔，问把它复原的第k步移动的是哪个圆片？
```
不需要递归，什么都不需要，你只要会一点点汉诺塔就可以AC。

如果你不知道，你可以去玩一玩。

玩越久你就会会发现一个规律：
```
举例：当n=4；
移动圆片1（最小）的次数：8；
移动圆片2的次数：4；
移动圆片3的次数：2；
移动圆片4的次数：1；
```
而且你还会发现：
```
第1、3、5、7、9、11、13、15次移动的是圆片1；
第2、6、10、14次移动的是圆片2；
第4、12次移动的是圆片3；
第8次移动的是圆片4；
```
相信大家看到这里，应该知道怎么做了。

贴代码：
```
#include <bits/stdc++.h>
using namespace std;
int main()
{
    long long n,m;//注意2^50-1已经爆int
    cin>>n>>m;
    int s=1;
    for(int i=1;i<=n;i++)
    	if(m%2==0)
    		m/=2,s++;//这规律不难找吧。。。
    cout<<s<<endl;
    return 0;
}
```
CF的愚人节题还是很水的。。。。。