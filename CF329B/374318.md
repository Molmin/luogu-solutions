## 本题主要算法：广度优先搜索
[博客食用更佳哟！](https://www.luogu.com.cn/blog/374318/solution-cf329b1)
### 题意简述：
有一个 n\*m 的地图，$S$ 是我的起点，$T$ 是树木，也就是障碍，$E$ 是出口,0到9之间的数字代表该点上有人，并且数字就是该点上的人数，问我到终点前有多少人也能到终点。
### 思路：
不难看出，如果其他人要先于我或与我同时到达终点，那么他们离终点的距离就应小于等于我到出口的距离。所以我们可以用广搜，以出口作为起点（这样可以提高算法效率），记录下每个点到出口的距离并且记录下我到出口的距离，最后用循环嵌套扫一遍，发现有到达出口距离小于等于我到出口距离的就加上该点的人数。
### 说一下注意事项：
 
- 最好是从出口开始搜到每个点的距离而不是从每个点搜到出口的距离，这样可以提升搜索效率
- 其他人到达出口的距离等于我到达出口的距离的也应算在内
- 已搜过的点需要标记，防止再次搜索
- 距离应初始化为无限大，防止误判，加上不该加的人数

知道这些之后，本题思路就很明确了，个人认为注释比较详细，读懂代码应该不难，贴上代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
struct node{
    int x,y,step,sum;//step变量储存该点到出口的距离，sum变量储存该点的人数
}q[1000001];
int a[4001][4001],k,n,m,xx,yy;
void Bfs(int X,int Y){
    int head=0,tail=1,rx,ry,i;
    int dx[5]={0,0,0,1,-1};
    int dy[5]={0,1,-1,0,0};//定义向四个方向扩展的方向数组
    q[1].x=X;
    q[1].y=Y;
    q[1].step=0;
    q[1].sum=a[X][Y];
    while(head<tail){
        head++;
        for(i=1;i<=4;i++){
            rx=q[head].x+dx[i];
            ry=q[head].y+dy[i];
            if(a[rx][ry]<10&&a[rx][ry]>=0&&rx<=n&&rx>=1&&ry<=m&&ry>=1){//如果这里有人并且没有越界
                tail++;
                q[tail].step=q[head].step+1;//记录下这个点到出口的距离
                q[tail].sum=a[rx][ry];//记录下这个点的人数
                a[rx][ry]=10;//把这个点标记为已走过
                q[tail].x=rx;
                q[tail].y=ry;
                if(q[tail].x==xx&&q[tail].y==yy)
                k=q[tail].step;//如果是我所在的位置，就记录下这个点到出口的距离
            }
        }
    }
}
int main(){ 
    int i,j,xx1,yy1,sum=0;
    cin>>n>>m;
    char c;
    for(i=1;i<=1000000;i++)
    q[i].step=99999999;//先把距离标记为无穷大，以免误加
    for(i=1;i<=n;i++)
        for(j=1;j<=m;j++){
            cin>>c;
            if(c=='S'){
                xx=i;yy=j;
                a[i][j]=0;//如果是我的出发位置，就将该点的坐标记录下来
            }
            if(c=='E'){
                xx1=i;yy1=j;
                a[i][j]=0;//如果是出口，记录下坐标，作为起点用bfs遍历
            }
            if(c>='0'&&c<='9')
            a[i][j]=c-'0';//如果是有人的格子记录下人数
            if(c=='T')
            a[i][j]=10;//如果是障碍标记为10
        } 
    Bfs(xx1,yy1);//从出口坐标开始遍历
    for(i=1;i<=n*m;i++)
    if(q[i].step<=k){//如果这个点离出口的距离小于我到出口的距离就加上这个点的人数
    sum+=q[i].sum;
    }
    cout<<sum;
}
```
最后，如果觉得我的题解对你们有帮助的话，请挪动你们的鼠标为我点赞，你们的支持就是对我最大的鼓励！