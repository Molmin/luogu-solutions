~~将树上黑白连通块染色拓展至链和子树意义尽头过后竟然觉得QTree7是小清新DS。（~~

考虑到 set 的一个 $\log$ 并不能够均摊使得 LCT 的复杂度单 $\log$ 我们考虑如何优化这样一种维护方式。

-----
### 方法一：Top Tree
- 我们精细实现维护虚儿子的平衡树，使得对虚儿子信息维护的数据结构能够均摊进入 LCT 的单 $\log$ 当中，其中一个例子就是 Self-Adjusting Top Tree。
- 我们将虚儿子信息用一个单旋平衡树维护。每次单点修改直接 expose 根节点到修改节点的路径，直接更新信息即可。
- 同样的，剩下的维护方式和 LCT 一样，开两颗树，白树上只存在白到白边和黑到白边。黑树上只存在黑到黑边和白到黑边。
- 每次直接查询一个子结构的子树信息即可。
- 更详细的复杂度分析和实现方式具体可以移步 [my blog](https://www.luogu.com.cn/blog/user27338/subtreedynamictree)。

### 方法二：splay 维护括号序
- 考虑到树的结构其实是确定的，即根不会变，而且每次连边断边对象都是一条父子边，所以我们考虑在维护静态树功能强大、方便实现的括号序对其进行维护。
- 此时有两种实现方法。
- 第一种：按照经典方法一样，考虑开两颗树，每次的连边和断边都是连向父亲，容易实现。注意这里的子树信息查询就是一个区间。
- 第二种：
	- 我们发现括号序有一个优秀的性质就是他可以把一些“兄弟”节点收尾相接串起来，这样他仍然是一个合法的括号序，并且我们可以直接对这个集合操作。我们考虑把所有同色的兄弟节点先串起来，与父亲同色的插入父亲的子树区间，被父亲带着继续往上走，异色的就先记录父亲这个地方。
   - 考虑反转一个节点的颜色，对于儿子，直接交换子树区间和原来记录的异色儿子串联组成的序列即可。对于父亲，判断颜色异同直接删除/插入到相应的同色/异色的集合当中。
   - 这些操作都能够用 splay 进行维护，总复杂度 $\mathcal O(n\log n)$。
   - 具体实现可以移步至 [another blog](https://www.luogu.com.cn/blog/user27338/subtreedynamictree)

### 方法三：线段树
- 我们发现，如果将一个树上的连通块差分为 DFS 序，他会形成 $\mathcal O(n)$ 段序列。
- 但是我们可以发现，这其实相当于将一个节点的子树区间提取出来，然后再挖去异色节点的子树区间。我们考虑如何维护这个东西。
- 我们称一个树的子树区间为当前节点及其子树节点在 DFS 序上的区间。
- 我们首先考虑只维护白点，黑点信息为空。之后在反过来维护就行了。
- 我们考虑线段树节点区间 $[L,R]$，和两个黑点子树区间 $[l_{1},r_{1}],[l_{2},r_{2}]$，两个点之间没有黑点，但可能有白点。
	- 当 $[L,R] \subset [l_{1},r_{1}] \subset [l_{2},r_{2}]$ 时，我们如果对 $(l_{1},r_{1})$ 之间的点进行块修改，那么修改的值是一定不会影响当前的线段树区间 $[L,R]$ 。
  - 我们称一个节点的 **管辖点** 表示 **深度最深，完全包含改点子树区间的黑点** ，定义同样适用于线段树节点的维护区间。
  - 那么可以发现，一次块修改所造成的影响就是当前节点的管辖点往下找一个儿子，用线段树节点拟合这个儿子的子树区间的线段树节点及子树与所有管辖节点是这个儿子的父亲的线段树节点的交。
  - 我们便可以对于每一个线段树节点开一个 set 维护所有包含它的黑点，取 rbegin 就是管辖点的 DFS 序。
  - 但是数据非随机情况下，每一个线段树节点的管辖节点是 $O(n)$ 的，铁定出问题。但是我们发现，一个线段树节点父亲被包含，它一定被包含。故我们想到标记永久化，即只在每个恰好被包含的地方的 set 插入，取得时候到根带着一个值走就行了。这样空间复杂度就被降到了 $O(\log n)$ 。在这里，这个 set 其实已经可以理解成一个父子关系的线段树边的标记，它会限制块加标记的下放与信息上传。
  - **此处开始，所有未指代信息均为线段树节点。**
  - 我们称管辖节点不同的线段树点之间有限制标记，那么回到本题，对于黑白树分开考虑限制标记。注意管辖点和信息点颜色相反。
  - 翻转颜色会设计到限制标记的修改，但是我们翻转的时候已经会遍历拟合子树区间的线段树节点，所以会修改的线段树节点到根路径上是没有标记的，信息已经完全正确的下放。
  - 继续深入考虑优化空间。我们发现可以直接维护每个线段树节点的管辖节点的个数。因为儿子的管辖节点一定包含父亲的管辖节点，那么，如果儿子比父亲的管辖节点多了，就必定存在管线节点卡再来父子转移边之间，即当前线段树父子边有“限制标记”。
  - 故线段树部分优化至 $\mathcal O(n\log n)$，维护不同连通块的信息和。
- 剩下部分用树剖和 set 精细实现同样能够做到 $\mathcal O(\log n)$。
- [code](https://www.luogu.com.cn/record/61800482)

### 后记

剩下的维护方法还有很多（真的巨多，利用线段树维护不交线段的区间只是树上黑白连通块染色题目的一个方法。从 LCT 开始，到各种拓展、利用信息，ETT、线段树、LCM，到最终又回到 LCT 维护链与子树尽头问题（LCT还是强啊）。如果继续深入，那估计就得等到哪天“ k - 毛毛虫”染色了。/mgx