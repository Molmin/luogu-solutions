关于最下面的并查集解法，其实有一个小问题

2
1 45
2 100
这个样例跑出来是1 ，但显然，ans=2

这个题的并查集证明其实不难，自己推推也能推出来： 环上的属性值不会被装备限制住，而链上的可以任选一个点，即一个属性

显然，对于n个装备，我们最多打到n次

也就是说，对于大于n的情况，我们是可以不去考虑的

因此，可以选择舍弃这个点，来让链上任意一个点都可以使用

因此如果有一个装备的某个属性>n，可以舍弃它，使这个链成为环，又或者像楼下那样直接连到0上

（因为那个a或是b太大了，找并查集的父亲直接找到了0）

楼下的问题也正在这里，他的初始化里并没有把0的num赋为1

这导致了上面的样例没有出来

尽管我申诉了好几次，但都.....

所以，这是修改的代码：

（贴出来是不是涉嫌抄袭？只把改的那句话放出来好了）

第21行：    for (int i=0; i<=n+1; ++i) num[i]=1;

事实上我在博客上见过和楼下一毛一样的题解，不知道是不是一个人
