借着这道题，给大家讲一讲**滚动数组**的用法。

### 滚动数组可以优化空间，当DP内存存不下时，我们可以用它来优化空间。

首先我们来推一下本题式子：由于一个数前既能放加号又能放减号，所以它的正负其实并没有关系，因为**加上一个数等于减去它的相反数**

据此，我们可以容易推出DP转移式:

$$f[i][j]=f[i-1][(j+x)\% k]\ ||\ f[i-1][(j-x+k)\%k]$$

设f[i][j]表示到第i个数余数为j是否可行。

但如果此题n很大(比如十万甚至上百万），数组存不下怎么办？

我们观察DP转移式，发现这一项的f[i][j2]至于f[i-1][j1]有关，那么是否我们能只存上一次的DP结果呢？

结果是肯定的，而且我们可以利用i的奇偶来方便的存储，具体在代码中理解吧：

```cpp
memset (f, 0, sizeof (f));
f[0][0] = 1; //前0个数余数自然为0
int P = i & 1, L = P ^ 1;
memset (f[P], 0, sizeof (f[P])); //f[P]为当前这一维
for (j = 0; j < k; ++j) {
	if (i != 1)
		f[P][j] = f[L][(j - x + k) % k] || f[L][(j + x) % k];
	else
		f[P][j] = f[L][(j - x + k) % k];	
}
puts (f[n & 1][0] ? "Divisible" : "Not divisible");

```
