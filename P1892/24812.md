PS：似乎与上面大佬们的思路大致相同，但是我还是想发一下，毕竟我还是在下方的题解中手动操作了一下反集这个思想的具体体现，比较易于理解吧（蒟蒻的我光看代码看不懂=-=）

------------
这种题目当然我们应该需要用**并查集**来解决。

我们用一个集合代表一个团伙

然后如果根节点为自己就说明有一个新的集合产生，那么就说明多了一个团伙

那么我们也就只用处理以下两句话了


> 我朋友的朋友是我的朋友


这个我们只需要判断是否两个点在一个集合，在一个集合就说明几个肯定都是朋友


> 我敌人的敌人也是我的朋友


但是这里我们怎么解决呢？

我们可以使用一种新的思想叫做：反集

若某A和某B两个人

那么我们设定 

**A代表的是相对当前人是团伙 A1代表的相对当前人是敌人**

**B代表的是团伙当前人是团伙 B1代表的相对当前人是敌人**

**……**

如果

某A与某C是朋友关系

则生成集合 {A,C} 

某C与某B是敌人关系

生成集合 {B1,C} {C1,B}

某D与某B是敌人关系

生成集合{D1,B} **{C,B1,D}**

这个时候就可以找到 

C和D在一个集合里了，他们现在就是一个团伙的了

A1 B1 C1这种我们怎么表示呢？其实有很多种形式，我们可以重新定义A1 B1 C1或者直接A+N B+N C+N

~~这种反集的思想蒟蒻表示真的蛮神奇的~~ 

但是很多要注意的，这道题目的输入让我彻底知道了cin的好处，空格换行是scanf字符输入难受一批的....

另外，在合并的过程中，如果我们要合并A1 B这种情况，我们一定要把A1接到B的后面，不能把B接到A1的后面，这样会影响答案，因为如果我们最后出现以A1 B1这种的为根节点就麻烦了。

代码：

```cpp
#include <cstdio>
#include <iostream>
using namespace std;
int n,m,fa[1000001],total;
int find(int x)
{
	if (fa[x]==x)
	return x;
	fa[x]=find(fa[x]);
	return fa[x];
}  //并查集路径压缩
void he(int x,int y)
{
	int x1=find(x),y1=find(y);
	if (x1!=y1)
	fa[x1]=y1;
}  //合并操作
int main()
{
	scanf("%d%d",&n,&m);
	 for (int i=1;i<=2*n;i++)
	 fa[i]=i;  //我这里使用了 A B C和A+N b+N这种形式来定义相对的朋友和敌人关系
	 for (int i=1;i<=m;i++)
	 {
	 	int x,y;
	 	char ch;
	 	cin>>ch>>x>>y;
	 	if (ch=='F')
	 		he(x,y);
		else
		{
	 he(x+n,y);
	 he(y+n,x);  //反集思想具体体现
	 }
}
	 for (int i=1;i<=n;i++)
	 if (fa[i]==i)  //有几个根节点是自己的就说明有几个子树，也就是有几个集合（团伙）
	 total++;
	 printf("%d",total);
	return 0;
 } 
```
