  初看题目，毫无思路。
 
  然后想到一个奇怪的方法，因为众数共有总数一半以上，如果我们进行排序，必然n/2的位置是这个众数，但是由于丧心病狂的~~出题人~~空间限制，这样会炸。
  
  上40分代码。

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
int a[2000010];
int main(){
    int n;
    scanf("%d",&n);
    for(int i=1;i<=n;i++) scanf("%d",&a[i]);
    sort(a+1,a+1+n);
    if(n%2==0) printf("%d",a[n/2]);
    if(n%2==1) printf("%d",a[n/2+1]);//因为n为奇数的时候n/2下取整，所以n/2+1为中间值
    return 0;
}
```

  仔细思索一番正解，依然没有。遂看题解。发现了一种叫做摩尔投票法的神奇方法。
  
  通过浏览博客得到一些想法。因为众数出现次数超过一半，所以这个众数必然会只有1个。
  
  **下面就是思想了。**
  
  摩尔投票法的基本思想很简单，**在每一轮投票过程中，从数组中找出一对不同的元素，将其从数组中删除。这样不断的删除直到无法再进行投票，如果数组为空，则没有任何元素出现的次数超过该数组长度的一半。如果只存在一种元素，那么这个元素则可能为目标元素。**
  
  为了便于理解，我们想象一个情景，有一堆人在打架，**我们假设每一个人的战斗力都是1换1。也就是A打死B，A也会死**。
  
  **假设只有2波人**（我们把不是众数的数字看作一个数）且各占二分之一，显然继续打下去两边人都会死光。
  
  但是我们现在有2波人,其中一波人特别多（一半以上），显然这波人必然是赢家，虽然不知道打完还剩几个，但一定会有剩下的。因为一换一。**若第二波人有x个，则第一波人有（n-x）个且n-x>x**。那么最后剩下的人就是n-2x个。假设这2波人头上顶着2个不同的数字，这个剩下的人的数字就是众数。
 
 **以上用于帮助理解代码。**
  
  所以我们可以把摩尔投票法看作一种抵消的思想，当前数字进场，然后和上一个判断，如果**是同一个数计数器（js）++**，**如果不是计数器--**。

  当计数器等于0时，ans重新登记为新输入的数，进行抵消的操作，最后剩下的一定是众数**（但众数必须满足大于总数的一半）**
  
  好了上代码。
  
  ```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
int main(){
    int n,ls;
    int ans,js=0;//计数器与答案
    scanf("%d",&n);
    for(int i=1;i<=n;i++){
        scanf("%d",&ls);//输入当前的数
        if(js==0) ans=ls;//如果计数器为0即之前均被抵消或现在是第一个输入，记录ans为当前数
        if(ans==ls) js++; //如果记录的数与新输入的数相等，计数器++
        if(ans!=ls) js--; //反之--
    } 
    printf("%d",ans);//最后剩下的就是众数
    return 0;//收尾，告辞
}
```