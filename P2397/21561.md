这个。。。

其实用到一个叫做摩尔投票法的东西。因为前面的题解都没有说这个所以本蒟蒻就来说一说qwq。

这个就是用O1的内存来求一组数据中的众数（貌似是存在一个数的出现次数大于总数据的一半的时候用的）

转化一下问题，我们拥有一个不能排序的数组a[N]。怎么样才能只扫一遍这个数组就能判断出仅有的一个众数呢？

设置一个内部变量cnt，以及一个输出ans。

cnt的初始值为0；ans用来存放我们的答案。

因为合理的答案只有一个：

遍历的时候，我们看到是我们这个群体的，cnt+1；不然cnt就减一。如果cnt=0那么就假定我们找到的群体就是人数最多的群体。

那么到了最后，计数器ans记录的那个群体必定是人最多的那个群体。

于是这就是一个看谁人多谁说了算的投票算法。


可能光这么说大家理解不了，那么我们就可以根据我们上面的思路写出代码然后跑一遍看看它的正确性。

下面附上代码：



```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<algorithm>
#include<cmath>
#include<queue>
#include<stack>
#include<vector>
using namespace std;
//const int N = 1;
int n;
int l;
int main()
{
    scanf("%d",&n);
    int cnt=0;
    int mina;
    for(int i=1;i<=n;i++)
    {
        scanf("%d",&l);
        if(cnt==0)
        {
            mina=l;
            cnt=1;    
        }
        else cnt+=(l==mina)?1:-1;
    }
    printf("%d",mina);
    return 0;
}
//因为个人对mina有怨念所以输出变量就是mina不要在意这些细节mina就是ans。
```
看完代码之后就很明确了，我们用读入来模拟遍历这么一个数组。
我们举一个样例就能很好的解释这个算法的正确性了。

比如说

7
2 5 3 5 5 4 5

那么开始遍历。

首先我们找到了2

那么cnt=1 mina=2

然后找到了5 cnt=0 mina=2

接下来3 cnt=1 mina=3

然后5 cnt=0 mina=3

然后还是5 cnt=1 mina=5

然后4 cnt=0 mina=5

然后仍然是5 cnt=1 mina=5 所以我们输出mina答案就是5

跑这么一遍你们就很显然发现。

即使对于我们的众数元素，经过多次打乱总会有那么一种情况在cnt为0的时候有两个相邻的众数元素

这两个相邻的众数元素就一定会被记录下来成为最终的答案。

这几行代码只能针对众数的个数大于n/2的情况。其实还有对于大于n/3的处理方法这里就不写出来了，原理差不多不过可能的答案会有2个/3个/1个，注意讨论就行咯。

如果众数的个数再少呢。。。那么摩尔投票法就不能保证正确性了，这个时候你还是只能用数组来进行On的空间复杂度。。

qwq就这样了求上题解qwq
