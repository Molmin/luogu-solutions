**首先，这是一道简单~~但是输出恶心~~的初中数学题。**

### 前置知识

- 两点之间距离公式 ： $ \sqrt[]{(x_1-x_2)^2-(y_1-y_2)^2} $

- 中点公式 ： $ (\frac{x_1+x_2}{2},\frac{y_1+y_2}{2}) $

- 直线斜率公式 ： $ \frac{y_1-y_2}{x_1-x_2} $

- 垂线的斜率 ： $ -\frac{1}{k} $

- 斜截式 $ y=kx+b $ 变形为 $ b=y-kx $

- 两直线交点横坐标 ： $ -\frac{b_1-b_2}{k_1-k_2} $

~~都是些初中知识啊~~

### 思路

**一个圆的解析式需要它的半径和圆心。**

1. 把三个点连成一个三角形

2. 求出1中三角形的三条边的解析式 (只求斜率)

3. 求出2中三条线段的垂直平分线 (解析式)

4. 求出3中三条垂直平分线的交点 **圆心get**

5. 求出给出的三个点中任意一点到圆心的距离 **半径get**

到这里，一个圆就解出来了！

### 坑点：

1. 如果不判断三角形的三条边是否与坐标轴平行，就会出现0作为除数的情况，从而输出```nan```。

**example:**
```cpp
4 3 -4 3 3 4
```
2. 在1的基础上，如果不判断直角三角形，出现了两条边都平行于坐标轴的情况，仍然输出```nan```。~~不过其他写法可能不需要~~

**exanple:**
```cpp
4 3 -4 3 4 -3
```
3. 输出的时候必须仔细判断，如果某个值是0则不输出~~等号右边除外~~。

4. 正负号必须结合圆的解析式中的正负号，在合适的位置取相反数。

### 实现

细节都在注释里:

```cpp
#include<bits/stdc++.h> // 万能头 
using namespace std;

signed main()
{
	double x1,y1,x2,y2,x3,y3;
	while(cin>>x1>>y1>>x2>>y2>>x3>>y3) // 读入,这也可以写成 scanf(...)!=EOF 
	{
		double l12=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2); // l12 -> 1号点和2号点的距离的 平方 
		double l13=(x1-x3)*(x1-x3)+(y1-y3)*(y1-y3); // l13 -> 1号点和3号点的距离的 平方 
		double l23=(x3-x2)*(x3-x2)+(y3-y2)*(y3-y2); // l23 -> 2号点和3号点的距离的 平方 
		double m12x=(x1+x2)/2,m23x=(x2+x3)/2,m13x=(x1+x3)/2; // m12x -> 1号点和2号点的中点 的横坐标,其他同理 
		double m12y=(y1+y2)/2,m23y=(y2+y3)/2,m13y=(y1+y3)/2; // m12x -> 1号点和2号点的中点 的纵坐标,其他同理 
		double f12=(y2-y1)/(x2-x1),f23=(y3-y2)/(x3-x2),f13=(y3-y1)/(x3-x1); //f12 -> 通过1号点和2号点的直线的斜率,其他同理 
		double k12=-1/f12,k23=-1/f23,k13=-1/f13; //k12 -> 通过1号点和2号点的直线的 垂直平分线 的斜率,其他同理 
		double b12=m12y-k12*m12x,b23=m23y-k23*m23x,b13=m13y-k13*m13x; //k12 -> 通过1号点和2号点的直线的 垂直平分线 的b值(y=kx+b),其他同理 
		double ox=(b12-b23)/(k23-k12),oy=((k12+k23)*ox+(b12+b23))/2; //ox -> 圆心的横坐标 ; oy -> 圆心的纵坐标 
		if(x2==x1||y2==y1) // 这里判断:连接1号点和2号点的直线是否与坐标轴平行 
			ox=(b23-b13)/(k13-k23),oy=((k13+k23)*ox+(b13+b23))/2;// 如果平行,那通过1号点和2号点的直线不能用,需要换用其他点 
		if(x2==x3||y2==y3) //同上 
			ox=(b12-b13)/(k13-k12),oy=((k13+k12)*ox+(b13+b12))/2; //同上 
		if(x1==x3||y1==y3) //同上 
			ox=(b12-b23)/(k23-k12),oy=((k23+k12)*ox+(b23+b12))/2; //同上 
		double r=sqrt((ox-x1)*(ox-x1)+(oy-y1)*(oy-y1)); // 圆心和圆上任意一点的距离是半径  
		if(l12+l13==l23) // 这里判断:1、2、3三点构成的三角形是否为直角三角形 
		{
			ox=m23x; // 如果是直角三角形,圆心也就是斜边的中点 
			oy=m23y;
			r=sqrt(l23)/2; // 如果是直角三角形,半径也就是斜边的一半 
		}
		if(l23+l13==l12) // 同上 
		{
			ox=m12x;
			oy=m12y;
			r=sqrt(l12)/2;
		}
		if(l12+l23==l13) // 同上 
		{
			ox=m13x;
			oy=m13y;
			r=sqrt(l13)/2;
		}
/*-----------以下为恶心的输出部分-----------*/ 
		if(ox==0) cout<<"x"; //如果圆心在y轴上,不输出0 
		else
		{
			cout<<"(x "; // ↓以下为正负的判断,注意符号前后有空格 
			if(ox>0) cout<<"- "<<fixed<<setprecision(3)<<ox<<")";
			else cout<<"+ "<<fixed<<setprecision(3)<<-ox<<")";
		}
		cout<<"^2 + ";
		if(oy==0) cout<<"y"; //如果圆心在x轴上,不输出0 
		else
		{
			cout<<"(y ";
			if(oy>0) cout<<"- "<<fixed<<setprecision(3)<<oy<<")";
			else cout<<"+ "<<fixed<<setprecision(3)<<-oy<<")";
		}
		cout<<"^2 = "<<fixed<<setprecision(3)<<r<<"^2\n";
		cout<<"x^2 + y^2 "; // 二次项系数永远为1,所以直接输出 
		if(ox!=0) // 如果一次项系数为0,则不输出 
		{
			if(ox>0) cout<<"- "<<fixed<<setprecision(3)<<ox*2<<"x";
			else cout<<"+ "<<fixed<<setprecision(3)<<-ox*2<<"x";
			cout<<" ";
		}
		if(oy!=0)
		{
			if(oy>0) cout<<"- "<<fixed<<setprecision(3)<<oy*2<<"y";
			else cout<<"+ "<<fixed<<setprecision(3)<<-oy*2<<"y"; // 这里的"*2"参考(x+n)^2==x^2+2*n*x+n^2 
			cout<<" ";
		}
		double k=ox*ox+oy*oy-r*r; // 统计常数项 
		if(k>0) cout<<"+ "<<fixed<<setprecision(3)<<k;
		else cout<<"- "<<fixed<<setprecision(3)<<-k;
		cout<<" = 0\n\n";// UVA日常输出空行 
	}
	return 0; // return 114514;
}
```

~~Ctrl C Ctrl V的同学先别走！~~

先点个大拇指~

[AC-code](https://www.luogu.com.cn/record/61540212)