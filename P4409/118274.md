### [$ \large{}\color {#6495ED} \mathcal{MyBlog} $](https://xjx885.coding-pages.com/)

---

本题是我一次考试的T1...

事实上，本题与刘汝佳《算法竞赛入门经典(~~脑细胞惊魂511面~~)》中的一道例题雷同了...

请参见[UVA1335 Beijing Guards](https://www.luogu.org/problem/UVA1335)

（~~一题双经验，开心每一天~~）

于是我侥幸的A掉了此题...

并且参考蓝皮书，写下了此篇题解

---

### 正文如下：

首先，膜一膜样例，很容易可以得出一种错误的贪心做法...

**answ=max(a[i]+a[i+1])  (i=1,2,...,n)**

即答案是 任意相邻两人需要勋章数目的和 的最大值

什么意思？

我们设n个人组成集合P...

∀相邻两人p,q∈P

我们让answ个勋章组成集合U...

p拿出的勋章记为A,q拿出的勋章记为B

则size(A)+size(B)<= size(U)  （因为answ是最大值）

且A包含于U,B包含于U

所以一定存在一种情况，使得A∩B=∅

故answ块勋章一定可以满足条件，**它是答案的下限**

事实上，如果n为偶数，我们甚至可以推出一种answ勋章下的一定可行的方案：

	若k为奇数，则向k发礼物1~r
	若k为偶数，则向k发礼物answ-r+1~answ
    
但是当你这么敲上去时，你会发现你只有52分...

因为n为奇数时，这种贪心是不行的...（为什么不行？自己多试几组数据就知道了）

那么我们应该怎么贪心呢？

我们先二分枚举最终答案...

假设第一个人取了前a[1]个勋章...

若是我们用第一个人推第二个人，那么第二个人就可以去“捡漏”...

何谓捡漏？就是拿第一个人没有拿的勋章（我们不需要往后保证与第三个人拿的勋章没有重复，因为推到第三个人时，第三个人会捡第二个人的漏，不会出现重复）

如果说勋章不够怎么办？也就是a[i]+a[i-1]>二分枚举的勋章数

那么就只能说明勋章少了，二分枚举的l应该变大

以此类推....直到我们枚举到最后一个人时，都应该是没有问题的...

如果这n个人不是成环，而是成链的话，程序就已经可以结束了...

但是他们成了环，所以我们要考虑第n个人与第1个人冲不冲突...

在勋章数目一定的情况下，如何尽量让他们不冲突？

注意，在我们的递推过程中，只确定了每个人拿多少勋章，而没有确定一个人拿哪些勋章

所以我们可以让第n个人尽量拿靠后的勋章，从而保证与拿前面a[1]个勋章的小1不冲突...

如何让第n（奇数）个人拿到靠后的勋章？我们要让第n-1（偶数）个人拿靠前的勋章...

往回推回去...我们可以看出...我们的最优解一定存在于这么一种情况：

**编号为偶数的人尽量往前取，编号为奇数的人尽量往后取**

所以说...我们只需要在从前往后推时，考虑最优的这种情况就可以了

---

### 具体实现是：

我们先二分枚举勋章数目ans...

把ans个勋章分为两份，一份是1~a[1]（我们叫它左区间）,一份是a[1]+1~ans（我们叫它右区间）...

再从前往后递推...

第一个人把左区间拿全了，所以我们要让第n个人不拿左区间。

所以我们记录最优情况（贪心情况）下，每个人拿的左区间勋章数和右区间勋章数就可以了

这个人是奇数时...

如果上一个人拿了之后，右区间里还有勋章可以拿，我就把它们全拿了，剩下的拿左区间（如果右区间勋章够，就全部拿右区间）

这个人是偶数时...

如果上一个人拿了之后，左区间里还有勋章可以拿，我就把它们全拿了，剩下的拿右区间（如果左区间勋章够，就全部拿左区间）

以此从前向后推，保证最后推出来的是贪心最优解...

最后判一下n拿没拿左区间就好...

---

### 代码（自己码风太蒟...有一些语句就照搬刘汝佳的了）：

```cpp
#include <bits/stdc++.h>
using namespace std;

const int N=20010;
int a[N],n;//每人希望得到的勋章种数，人数 
int f_l[N],f_r[N];//f_l表示第i个人拿到的“左边的勋章”的总数，f_r类似 
int answ;//最终答案 

// 测试ans个勋章是否足够 
bool check(int ans)
{
	memset(f_l,0,sizeof(f_l));
	memset(f_r,0,sizeof(f_r));
	f_l[1]=a[1];
	int x=a[1],y=ans-a[1];//左块区间的大小为x，右块区间的大小为y 
	//初始化 
	
	for(int k=2; k<=n; k++)
	{
		if(ans<a[k]+a[k-1])//在只有ans个勋章的情况下，k和k-1没有办法拿到完全不同的勋章，那么这个方案肯定不行 
			return false;
		if(k%2==1)//如果是奇数 
		{
			f_r[k]=min(y-f_r[k-1],a[k]);//如果可以拿，尽量拿右边的  
			//当右区间剩下的勋章足够时，k人拿的就全部都是右区间的勋章
			//否则，就把右区间剩下的所有勋章都拿了，并拿一些左区间的勋章 
			f_l[k]=a[k]-f_r[k]; 
		}
		else
		{
			f_l[k]=min(x-f_l[k-1],a[k]);
			f_r[k]=a[k]-f_l[k]; 
		}
	}
	
	return !f_l[n];
}

int main()
{
	scanf("%d",&n);
	for(int k=1; k<=n; k++)
		scanf("%d",&a[k]);
		
	//先确定底线（n为偶数时，底线即是输出） 
	for(int k=1; k<n; k++)
		answ=max(answ,a[k]+a[k+1]);
	answ=max(answ,a[1]+a[n]);
	
	if(n%2==1)
	{
		int l=1,r=1000000000;
		while(l<r)
		{
			int mid=(r+l)>>1;
			if(check(mid))
				r=mid;
			else
				l=mid+1;
		}
		answ=l;
	}
	//奇数时处理，二分+贪心寻找更优解 
	
	printf("%d",answ);
	return 0;
}
```

---

如果本题解有错误...那么...那么...那么...(~~随意了~~)还请私信作者....

#### END