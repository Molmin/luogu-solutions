更新说明：根据评论区提醒，修改了代码，并增添了针对评论的一些说明。


------------

看到这题，就容易想到一种瞎搞的办法，那就是把相邻两个数起来，求个$max$.时间复杂度$o(n)$.   
很容易找到反例$n=3$时，$a[i]$分别为$5,5,5$；按瞎搞做法是10，实际上应该是$15$.   
下面是~~严格的~~求证过程：   
先延续我们一开始的想法，可以随机取$x,y$为相邻两个数(设为$a[i],a[i+1],i+1≤n$)，然后若$a[i]<a[(i+2)%n]$,则将$x$调整为$a[(i+2)%n]$，依次调整后，总可以取到$x,y$使得$x+y$是相邻两个数中和最大的。看起来而任意的另外的将军则只需要与模二同余的$x$或$y$中取$a[i]$个勋章，即可保证题设条件。    
但是问题在于如反例中3号将军理论上应该从1号将军的$a[1]$个勋章中选，但是3号将军和1号将军相邻，于是出了锅。   
换个角度，每个勋章最多给$n/2$个将军，所以实际还需要确保勋章数大于上$=\sum_{i=1}^n(a[i])/(n/2)$的勋章，才足以满足题设条件，当然不可能有1.5个勋章，所以需要向上取整。   
另外,切记n=1，是要直接输出的。    
最后我们需要将两种情况的答案进行比较取最大值。取最大值的原因是因为这里并非是严格意义上的两种情况，而是一种类似于算两遍取最值的方法
时间复杂度还是o(n)。   
code如下：
```cpp
#include<stdio.h>
#include<math.h>
int ans;
int a[20001],m,n,i,j;
int main()
{
    scanf("%d",&n);
    for(i=1;i<=n;++i)
     scanf("%d",&a[i]);
    if(n==1) return printf("%d\n",n)&0;
    ans=a[1]+a[n]; 
    for(i=1;i<n;++i)
     if(a[i]+a[i+1]>ans)
       ans=a[i]+a[i+1];
    for(i=1;i<=n;++i) 
     m+=a[i];

    double mm=m,nn=n,tem;
    tem=ceil(mm/((int)(nn/2)));
    if ((int)tem>ans) ans=(int)tem;
    printf("%d",ans);
    return 0;
}

```