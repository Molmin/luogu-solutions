~~一道恶评题就一篇 Python 题解，泥萌 C++ 党 && C 党的难道不感到愧疚吗？~~（逃

于是本蒟蒻又来水题解啦 ~~其实是贡献分快掉光了~~

另补：样例输出#3应为$0$，洛谷上面挂了……

显然这道题目可以用插空法解决。

[插空法](https://baike.baidu.com/item/%E6%8F%92%E7%A9%BA%E6%B3%95/4862293?fr=aladdin)

首先，显然$N$与$M$之差不可能大于$1$，否则必有两只动物属于同一类且相邻。

此时，只要保证$N$只狗或$M$只猴不相邻，另一类也必然不相邻了。

设初始时把所有的狗全部牵走，此时只剩下$M$只猴，这$M$只猴有$A_M^M$种不同排法，此时再把狗牵回来有以下几种情况：

1. $N=M$  
此时，$M$只猴中有$M+1$个空当，而只有$M$（此时$N=M$）只狗，故只有 $12121212$ 和 $21212121$ 两种排法（$1$代表狗，$2$代表猴），所有的狗有$A_N^N$种排法。  
故此时共有$2*N! * M!$种排列方式。

2. $N\not=M$  
此时不妨设$N>M$，故此时只有 $1212121$ 这样的排法，共有$N! * M!$种排列方式。

综上所述，$|N-M|>1$时，答案为$0$；$N=M$时，答案为$2*N! * M!$；否则为$N!*M!$。

注意别忘了取模。

$Code:$

```cpp
#include <bits/stdc++.h>
const int M = 1e9 + 7;
using namespace std;
int main() {
    long long n, m, ans = 1; cin >> n >> m; //注意ans要开long long，否则会爆；并且还要赋初值为1，否则下面乘法会全部乘0
    if (abs(m - n) > 1) {cout << "0\n"; return 0;}
    for (int i = 1; i <= n; i++) ans = ans * i % M; //算N!
    for (int i = 1; i <= m; i++) ans = ans * i % M; //算M!
    cout << (n != m ? ans : ans * 2 % M) << endl;
}
```

十行代码，碾压 Python。