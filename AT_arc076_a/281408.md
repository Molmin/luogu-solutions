# 思路

其实这就是数论中的排列组合，不会排列组合的可以百度第一条 QWQ 。

首先题目说了有 $n$ 只狗与 $m$ 只猴，我们确定只有两个状态，那是排列还是用组合呢，当然是排列啦，因为假设有 $3$ 只狗 $2$ 只猴，分别用字母表示，那么有 $AaBbC$ 的方案，也有 $CaBbA$ 的方案，所以它是有顺序的，因此我们是有组合来做，例子中，大写字母表示狗，小写字母表示猴。

那我们的排列公式是什么呢？我们可以单独的把狗与猴看成一坨，然后分开求排列，答案肯定分别为 $A^n_n$ 与 $A^m_m$ ，实现起来就分别可以看成： $n!$ 与 $m!$ ，然后我们在把它们结合在一起，以程序的角度说，就是把这两种解相乘。

可是单单这么做连第一个样例都过不了，为什么呢？其实我们可以先分开讨论一下：

如果 $n=m$ 的情况下，如图：

![](https://cdn.luogu.com.cn/upload/image_hosting/z8f0ys30.png)

假设 $n=m=3$ 那我们的总答案就需要 $\times 2$ 因为它们两个整体可以互换位置嘛，而且它们数量相等。

如果 $n\ne m$ 的情况下，如图：

![](https://cdn.luogu.com.cn/upload/image_hosting/m71s65ej.png)

假设 $n=3,m=2$ 那如果红蓝互换位置的话，肯定会有两个红色挨在一起，所以我们得出结论：只有当 $n=m$ 是，我们的答案才需要 $\times 2$ 否则直接输出即可。

还有一种情况我们没有判断，就是 $n$ 与 $m$ 的绝对值 $\ge 2$ 时，无论数量少的那一方如何插空，数量多的那一方肯定会有两个挨在一起，直接在输入是特判掉即可。

**注意事项：** 要开 long long 以及需要取模。

# 代码

```cpp
#include <bits/stdc++.h>
#define ll long long  //开long long
using namespace std;
const ll mod = 1e9 + 7;
ll n, m;
ll ans = 1;
int main() {
  cin >> n >> m;
  if (abs(n - m) >= 2) {  //特判
    cout << 0;
    return 0;
  }
  for (ll i = 1; i <= n; i++) {  //单独判断狗
    ans *= i;
    ans %= mod;
  }
  for (ll i = 1; i <= m; i++) {  //单独判断猴
    ans *= i;
    ans %= mod;
  }
  cout << (n == m ? ans * 2 % mod : ans);  //分开讨论
  return 0;
}
//记得取模哦
```

**看在我写的这么详细的份上 ~~自己觉得~~ ，管理员大大们给个过吧，另外祝愿洛谷越办越好 QWQ 。**