**~~本文同步发表于窝的个人博客~~和那边文章结构差别太大了(因为那边会有单独一篇讲拟阵)所以只放一个[到主页的链接](http://39.107.58.77/)就是了.**

## 定义

### 拟阵

定义一个拟阵是二元组$(S,L)$满足

- $S$是一个**有限集**;
- $L$是一个**非空有限集**,其元素是$S$的部分子集;
- 遗传性:$\forall A\subseteq B\in L$一定有$A\in L$;
- 交换性:$\forall A,B\in L,|A|<|B|$都有$\exists x\in B-A$(即存在$x\in B$但$x\not\in A$)满足$A\cup\{x\}\in L$.

#### 举例

比如,$(\{1,2,3,4\},\{\varnothing,\{1\},\{1,2\},\{1,2,3\},\{1,3\},\{2\},\{2,3\},\{3\}\})$是一个拟阵,因为

- 显然满足前两条性质;
- 观察发现满足遗传性,比如对于$\{1,3\}\in L$的子集$\varnothing$和$\{1\}$和$\{3\}$也都在$L$中;
- 观察发现满足交换性,比如对于$A=\{1,3\}$且$B=\{1,2,3\}$显然可以找到$x=2$满足$x\in B-A$且$A\cup\{x\}=\{1,2,3\}\in L$.

加深一下理解,$L$是$S$子集的集合(也就是元素是集合的集合),在遗传性中的$A$和$B$也都是$S$子集的集合;而在交换性中$A$和$B$是$S$的子集(也就是其中的元素就是$S$中的元素).所以注意观察大括号数量.

### 独立集

- 对于集合$U\subseteq S$且$U\in L$称$U$为**独立集**;
- 对于独立集$U$存在$x\in S$满足$x\not\in U$且$U\cup\{x\}\in L$则称$U$是**可扩展的**,称$x$是$U$的一个扩展;
- 称一个不可扩展的独立集$U$为最大独立集;

可知拟阵最大独立集大小相同.证明:设$A$与$B$是两个最大独立集,不妨设$|A|<|B|$由拟阵的交换性有$A$一定是可扩展的,不是最大独立集,与假设矛盾.

### 加权拟阵

加入一个权重函数$w(a)>0$表示$a$元素的权重,定义集合权重为$w(A)=\sum_{a\in A}w(a)$.现在我们希望对于这样的加权拟阵求出一个独立集$A$满足$w(A)$最大化,称$A$为最优子集.

容易发现$A$一定是最大独立集(因为$w(a)$是正数,故显然能多加进来一个会更优).sh

## 拟阵贪心

拟阵贪心就是要求出最优子集.

### 策略

```
/*这个函数返回一个最优子集*/
function set solve(M,w) /*拟阵和权重函数*/
	A←空集
	将M.S按权重排序
	for x属于M.S do
		if A并上{x}属于M.L
			A←A并上{x}
		end if
	end for
	return A
end function
```

### 正确性证明

对于拟阵$M=(S,L)$若$A$为其最优子集$T$的子集,元素$a$是集合$\{x|A\cup\{x\}\in L\}$中的权重最大元素,则$A'=A\cup\{a\}\subseteq T$.

证明:假设$A'\not\in T$则令$T'=T$.由矩阵的交换性知若$|T|>|T'|$一定存在$t\in T-T'$满足$T'\cup\{t\}\in L$.所以不断令$T'\leftarrow T'\cup\{t\}$直到$|T|=|T'|$且此时应有$T=(T'-\{a\})\cup\{t\}$.但是由条件$w(a)\ge w(t)$推出$w(T)=w(T')-w(a)+w(t)\le w(T')$说明$T$不是最优子集,与假设矛盾.

这样就证明了每一次并上剩下元素中最大的一定是最优解,并且最开始$A=\varnothing$显然属于$T$,故贪心策略正确.

### 复杂度分析

假设总共有$n$个元素,一个排序$n\lg n$,一个贪心$n$,判断独立集$t$,加起来就是$\Theta(n\lg n+nt)$,具体到这道题就是$n^3$(向量维度同阶).

## 构造拟阵

接下来就是要针对这道题构造一个拟阵来进行贪心.

设$S$为全部装备的集合,$L$为满足条件的子集(其中装备全部向量无关)的集合.证明$(S,L)$是一个拟阵因为其满足

- 前两条性质,显然;
- 遗传性:如果更多的装备向量无关,则从中去掉一部分剩下的显然仍然向量无关;
- 交换性:对于$A,B\in L$且$|A|<|B|$假设不存在$x\in B-A$则表示$B$中的元素都可以用$A$中的元素表示出来,但又因为$|A|<|B|$且$A$和$B$当中元素分别线性无关,推出矛盾.

构造权重函数$w(i)=x-c_i$,其中$x$满足$x>\max\{c_i\}$.这个$w$是一个合法的权重函数因为显然为正,最后得到的最优子集$A$的权重$w(A)=|A|x-\sum_{a\in A}w(a)$.最大化$w(A)$就是要最小化$\sum_{a\in A}c_a$,符合题设.

这样就证明了贪心的正确性,至于具体实现其它题解已经说得很清楚了这里就不再赘述,仅给出代码以供参考.

## Code

```cpp
#include <algorithm>
#include <cstdio>
using namespace std;

const double eps=0.0001;
struct bxt {
	int c; double a[505];
	bool operator <(const bxt &op) const {
		return c<op.c;
	}
};

int main() {
	static int b[505];
	static bxt z[505];
	int n,m,p=0,q=0; double w;
	scanf("%d%d",&n,&m);
	for (int i=0;i<n;++i) for (int j=0;j<m;++j)
		scanf("%lf",&z[i].a[j]);
	for (int i=0;i<n;++i) scanf("%d",&z[i].c);
	sort(z,z+n);
	for (int i=0;i<n;++i) for (int j=0;j<m;++j) {
		if (z[i].a[j]>-eps&&z[i].a[j]<eps) continue;
		else if (!b[j]) {b[j]=i+1; ++p; q+=z[i].c; break;}
		else {
			w=z[i].a[j]/z[b[j]-1].a[j];
			for (int k=j;k<m;++k)
				z[i].a[k]-=w*z[b[j]-1].a[k];
		}
	}
	printf("%d %d",p,q);
	return 0;
}
```