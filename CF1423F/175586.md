# CF1423F Coins

注意下文中的 $b$ 长度为 $n$，其中 $b_i$ 表示这 $n$ 个人中第 $i$ 个人拥有的硬币数量。

设 $s=\sum_{i=1}^n b_i$。

当 $s>n$ 时游戏显然不可能结束，因为硬币总数是不变的，而游戏结束时每个人手中的硬币数量小于等于 $1$。

我们定义一个 **$k$-连通块** 为硬币数量的极长子串，满足其中每一项都大于等于 $k$。

我们观察一个序列 `0 1 1 2 1 1 1 1 0` 的变化情况。

```
0 1 1 2 1 1 1 1 0
0 1 2 0 2 1 1 1 0
0 2 0 2 0 2 1 1 0
1 0 2 0 2 0 2 1 0
1 1 0 2 0 2 0 2 0
1 1 1 0 2 0 2 0 1
1 1 1 1 0 2 0 1 1
1 1 1 1 1 0 1 1 1
```

我们发现，这个**操作**相当于，中间的 $1$-连通块往两边扩展了一个 $1$，然后那个 $2$ 所在的位置减少了 $1$，与它在原来的连通块里左右对称的那个位置也减少了 $1$。

观察到上面图案中间 $0$ 与 $2$ 组成的块形状非常有规律，然后证明就很简单了。以下是一个比较感性的解释：

```
...1 1 1 2 1 1 1...
...1 1 2 0 2 1 1...
...1 2 0 2 0 2 1...
```

首先，中间的包含 $0$，$2$ 的块以每次左右各一个位置的速度扩张，并且每个位置不断在 $0$，和 $2$ 间切换。与旁边的 $1$ 相邻的位置总是 $2$。

```
0 1 2 0...
0 2 0 2...
1 0 2 0...
```

当中间包含 $0$，$2$ 的块扩张到边界时，最外面的 $2$ 会往它所在的这边放一个 $1$。

两边出现这个情况的时间可能不相同，但一定会出现，且出现的时间等于一开始这边 $1$ 的个数。

```
1 0 2 0...
1 1 0 2...
1 1 1 0...
```

然后，由于边上变为了 $1$，较靠里面的数无法再维持原来的变换，于是中间包含 $0$，$2$ 的块以每次一个位置的速度缩小，并不断往旁边填充 $1$。与外面的 $1$ 相邻的位置总是 $0$。

```
...1 0 2 0 2 0 1...
...1 1 0 2 0 1 1...
...1 1 1 0 1 1 1...
```

最后，当中间包含 $0$，$2$ 的块缩小为只剩一个 $0$ 时（由于其扩张和缩小的速度都是每次一个位置，最后 $0$ 的位置应与原来 $2$ 的位置左右对称），操作结束。

所以，对于一个有至少一个硬币数量大于 $k$ 的 $k$-连通块，我们可以从中选取一个大于 $k$ 的硬币数量 $b_x$，把它作为上述操作中的 $2$，其他位置上的数作为 $1$，进行上面的操作（此连通块中其他硬币不参与此次操作）。于是我们就可以将 $b_x$ 减少 $1$，此 $k$-连通块中另一个数也减少 $1$，然后把连通块左右的数各加上 $1$。（此时这个连通块可能会被分为两个连通块，也可能与两边的一些硬币数量拼起来成为新的连通块。）

于是我们得到了一个**做法**：每次选择一个最大的硬币数量 $b_m = \max b$，找到它所在的 $(b_m-1)$-连通块，然后对其执行上述操作。操作后 $b_m$ 至少减少 $1$，且一般不会新生成一个大于等于与原来的 $b_m$ 的硬币数量。

注意到上面所说的「一般」。事实上，唯一的**反例**是当选择的 $b_m$ 等于 $2$ 且此连通块左右两边的位置是同一个位置时，此时两边扩展的硬币加在了同一个位置，导致这个位置又出现了一个 $2$，与操作前情况等价。因为硬币数量最多为 $n$，所以上述情况等价于所有硬币数量中，有且仅有一个 $2$，也相当于有且只有一个 $0$。此连通块硬币数量恰好为 $n$，因此此时不存在其他连通块。

我们不断执行上面的做法，如果每个人手中的硬币数量都小于等于 $1$ 则结束。当有至少两个连通块时，由于此时每个连通块左右两边的位置必定不相同，所以我们必定可以执行至少一次做法。

所以，当 $s<n$ 时，由于无法构成上面的反例，游戏必定会结束。

只剩下 $s=n$ 的情况了。我们需要较为快速地判断，什么时候会形成上面反例中的情况。

我们发现，当 $s=n$ 时要么形成上面反例中的情况，要么硬币数量最后全是 $1$（否则必然能继续执行上面的做法）。

我们设 $f=\left( \sum_{i=1}^n b_i \right) \bmod n$。我们发现当我们第 $i$ 个人向左右的人分硬币时，$f \gets [f-2i+(i-1)+(i+1)] \bmod n=f$。所以无论怎么操作，$f$ 都是不变的。

对于硬币数量全是 $1$ 的情况，可以发现 $f=\frac{n(n+1)}{2} \bmod n$。对于上面的反例中的情况，若设 $a$，$b$（$a \neq b$）分别表示 $2$ 与 $0$ 的位置，可以发现 $f=\left[\frac{n(n+1)}{2}+a-b\right] \bmod n \neq \frac{n(n+1)}{2} \bmod n$。

所以我们就得到了最终的做法：

+ 对于 $s>n$，游戏必不能结束。
+ 对于 $s<n$，游戏必然能结束。
+ 对于 $s=n$，若 $f=\frac{n(n+1)}{2} \bmod n$，则游戏必能结束，否则游戏必然不能结束。

总时间复杂度为 $O(k)$，可以通过本题。

代码非常简单：

```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
	int n,k;
	cin>>n>>k;
	int s=0,f=0;
	for(int i=1;i<=k;i++)
	{
		int p,v;
		cin>>p>>v;
		s+=v,f=(f+1LL*p*v)%n;
	}
	if(s>n)
		cout<<-1<<endl;
	else if(s<n)
		cout<<1<<endl;
	else
		cout<<(((1LL*n*(n+1)/2)%n)==f?1:-1)<<endl;
}
```



