- 给你一个 $n\times m$ 的方格表，其中一些格子已经被染色了，你可以将一些无色格子染色，问有多少种不同的染色方法使得染完后的方格表满足“如果 $(i,j)$ 被染色，那么 $(i+1,j)$ 和 $(i+1,j+1)$ 也要被染色”。

赛时没做出来。后来想了一下，不算难。

```cpp
...#......
...##.....
.#.###..#.
.######.##
.#########
.#########
```

我们不妨手膜一组“美丽的方格表”（如上图），看到这些在“左上-右下”方向的平滑切面，我们陷入了沉思。

我们将这些“左上-右下”方向的每一排分开考虑。我们令 $a_{c}(1\le c\le n+m-1)$ 代表满足 $i-j=c-m$ 的格子里最终染色的个数，$b_c$ 代表第 $c$ 排一开始给定的最左上的被染色格子右下方有多少个格子（包括自己）。容易发现并证明第 $c$ 排的所有 $a_c$ 个被染色的格子都挤在右下方向。那么我们总的染色方法等同于合法的 $a$ 序列的个数。

现在我们要定义这个合法。首先，假设 $d_c$ 代表第 $c$ 排的格子个数，那么我们有 $b_c\le a_c\le d_c$。同时，要满足题目条件，我们发现，因为 $(i,j)$ 染色对应 $(i+1,j)$ 染色，所以有 $a_c\ge a_{c-1}(2\le c\le n)$。同时，因为在 $n+1\le c\le n+m-1$ 时依然有以上对应，只是最后的一个会不存在，所以此时有 $a_c\ge a_{c-1}-1$。

于是我们要求满足以上这些条件的 $a$ 序列的个数。因为 $a_c$ 仅与它本身限制和 $a_{c-1}$ 有关，尝试用动态规划。假设 $f_{i,j}$ 代表 $a_i=j$ 时第 $1\sim m$ 排到第 $i$ 排的 $a$ 序列总个数。我们有 $f_{i,j}=\sum\limits_{1\le k\le j+[i>n]}f_{i-1,k}$。这样一看就是 $O(n^3)$ 的。考虑前缀和优化，变为 $O(n^2)$，可以通过此题。使用滚动数组，空间复杂度 $O(n)$。

```cpp
#include<bits/stdc++.h>
#define w(x) (x>=mod?x-mod:x)
using namespace std;
typedef long long ll;
const ll mod=998244353,_=4010;
ll n,m,b[_],d[_],f[2][_];
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);cout.tie(0);
	cin>>n>>m;f[0][0]=1;
	for(ll i=1;i<n+m;i++)b[i]=min(n,i)+1;
	for(ll i=1;i<=n;i++){
		string g;cin>>g;
		for(ll j=1;j<=m;j++){
			d[i-j+m]++;
			if(g[j-1]=='#')b[i-j+m]=min(b[i-j+m],i);
		}
	}
	for(ll i=1,p=0,q=1;i<n+m;i++,swap(p,q)){
		for(ll j=1;j<=d[i]+1;j++)f[p][j]=w(f[p][j]+f[p][j-1]);
		for(ll j=min(n,i)-b[i]+1;j<=d[i];j++)f[q][j]=f[p][j+(i>n)];
		memset(f[p],0,sizeof(f[p]));
	} 
	cout<<w(f[(n+m-1)&1][0]+f[(n+m-1)&1][1])<<'\n';
	return 0;
}
```