不难发现，这道题目是涉及到字典序最小的序列问题。这种情况下，我们可以考虑使用排序：如果我们把这个序列从小到大排序，那么这种情况下的字典序一定是最小的。

但是，由于题干中给了一个限制条件（和为奇数的一对数才可以交换），我们似乎并不能把每一个元素放在一个位置，也就不一定能实现排序了。

我们可以先从特殊情况入手：

**如果这个序列中所有数字奇偶性相同**（即任意两数之和一定为偶数），我们**无法进行任何的交换**。因此，我们需要把序列按原样输出。


**如果这个序列中既出现了奇数，又出现了偶数**（即存在至少一对数之和为奇数），该怎么做呢？**事实上，我们可以对任意两个数进行交换。**

证明：对于一对和为奇数的数，能够直接交换。

对于一对和为偶数的数，一定能够找到一个和这两个数奇偶性都不相同的数，三者进行轮换。

例如:

[a,b,c]，a和b都为偶数，c为奇数

[c,b,a]，此时交换了c和a

[b,c,a]，此时交换了b和c

[b,a,c]，此时交换了a和c。可以看到，我们完成了两者之间的交换。

可以看到，在这种情况下，由于我们可以对于任何一对数进行交换，我们可以直接对于这个序列进行排序，也就能得到字典序最小的序列了。

下面附上代码：


```cpp
#include <bits/stdc++.h>
//本题目的解题思路：
// 如果一个数组中所有的元素的奇偶性相同，就不能进行任何替换
// 如果一个数组中两种奇偶性都出现过，那么可以交换任意两个数
// 证明：对于任意的两个数a,b，如果奇偶性不同，可以直接交换
// 如果奇偶性相同，则找到一个奇偶性和它们都不同的c，a,b,c轮换
using namespace std;
const int MAXN=1e5+10;
int n;
int arr[MAXN];
bool hasOdd=false,hasEven=false;//是否出现奇数，是否出现偶数 
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>arr[i];
		if(arr[i]%2==0)hasEven=true;
		else hasOdd=true;
	}
	if(hasOdd^hasEven){//如果只出现了一个，就按照原样输出 
		for(int i=1;i<=n;i++){
			cout<<arr[i]<<" ";
		}
	}else{//否则排序后输出 
		sort(arr+1,arr+n+1);
		for(int i=1;i<=n;i++){
			cout<<arr[i]<<" "; 
		}
	}
	return 0;
}
```



一点感悟：这道题的题面很具有迷惑性，有一定的思维难度，但是想清楚了以后代码难度并不高。个人认为做这种题目，多猜想或许是个不错的方法（比如这题，可以想想能不能把数换到任意位置）。
