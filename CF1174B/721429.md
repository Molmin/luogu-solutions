这是 $\verb!CF!$ 不能交题以来我的第一份题解。

# 思路

做这道题之前，我们需要了解一些小学学习的关奇偶数的知识，即

- 奇数 $+$ 奇数 $=$ 偶数。

- 偶数 $+$ 偶数 $=$ 偶数。

- 奇数 $+$ 偶数 $=$ 奇数。

而且题目说明了相邻两个数相加为奇数才能进行交换，而两个数相加为奇数的只有奇数 $+$ 偶数 $=$ 奇数这一种方法，所以我们就可以来判断这个序列里面是否存在奇数和偶数就可以了，因为不管只有偶数还是只有奇数，怎么都找不出来相加为奇数的两个数，所以这种情况只能输出原序列，而同时出现偶数和奇数的时候，就可以交换这两个数，交换一次又一次，最后得到的序列的字典序肯定最小，输出一下就可以了。

# 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
    int odd,even,i,n,a[10001];
    cin>>n;
    odd = even = 0;//初始都没有出现奇数和偶数
    for(i=1;i<=n;i++)
    {
        cin>>a[i];
        if(a[i]%2)
            odd = 1;//找到奇数了。
        else
            even = 1;//找到偶数了。
    }
    if(odd^even)//用异或的方法判断有没有出现奇数和偶数，大家都知道在异或中，相同为 0，不同为 1，所以这里假设的就是没有出现偶数和奇数的一种方案。
    {
        for(i=1;i<=n;i++)//因为不能交换，所以输出一下原序列就可以了。
            printf("%d ",a[i]);
        return 0;
    }
    //否则就是出现了奇数和偶数。
    sort(a+1,a+1+n);//先给序列排个序。
    for(i=1;i<=n;i++)//从小到大输出。
        printf("%d ",a[i]);
    return 0;
}
```
