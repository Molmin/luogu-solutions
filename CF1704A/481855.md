# CF1704A Editorial

这道题是 CF Div.1+Div.2 的一道题。总体来说这套比赛的题都挺不错，个人认为对选手的代码能力及思维能力都可以有很大的提升。

好了，进入正题吧。题意不多说了，题面说的挺清楚了。

首先，题目给出的两种操作方式就很有意思。

我们看对于 $01$ 串的前两个字符，对它们是 $0$ 或 $1$ 的情况讨论：

第 $1$ 种情况：第 $1$ 个与第 $2$ 个字符都是 $0$，此时无论删最大的和删最小的都会删掉一个 $0$。

第 $2$ 种情况：第 $1$ 个与第 $2$ 个字符都是 $1$，与前面一种类似，无论删最大的和删最小的都会删掉一个 $1$。

第 $3$ 种情况：第 $1$ 个字符是 $0$，第 $2$ 个字符是 $1$，此时可以删去 $0$ 与 $1$ 中的一个。

第 $3$ 种情况：第 $1$ 个字符是 $1$，第 $2$ 个字符是 $0$，此时也可以删去 $0$ 与 $1$ 中的一个。

所以我们可发现其实题目就在说我们每次可以删去第 $1$ 个与第 $2$ 个字符中的任意一个。

题目就转换为了按照上面说的方法问能否将一个 $01$ 串转换为另一个 $01$ 串。

我们接下来这么想：要想把一个 $01$ 串转换为另一个 $01$ 串，就得把中间的一段或几段子串删掉。

可是一旦在一个子串的前面有超过 $1$ 个字符时，就不能操作了。

所以我们得出：一个 $01$ 串（称为初始串）可以转换为另一个 $01$ 串（称为结束串）的充分必要条件是：结束串的除去其第一个字符的子串在初始串的末尾存在，且结束串的首字符在除去上述初始串的子串的子串中存在。

开始读起来会有点绕，但是多回味回味就能理解了。

对于代码实现部分：在初始串长度小于结束串长度时要特判，否则会出问题。

附上代码实现：
```cpp
//CF1704A Two 0-1 sequences
#include<bits/stdc++.h>
#define int long long
#define elif else if
#define rd(i) fixed<<setprecision(i)
using namespace std;
void func(){
	int n,m;cin>>n>>m;
	string a,b;cin>>a>>b;
	if(n<m){//特判
		cout<<"NO\n";
		return;
	}
	int p,q;
	for(p=n-1,q=m-1;q>0;--p,--q){
		if(a[p]!=b[q]){//如果出现字符不匹配就输出 NO
			cout<<"NO\n";
			return;
		}
	}
	for(int i=0;i<=p;++i){
		if(a[i]==b[0]){//如果存在就输出 YES
			cout<<"YES\n";
			return;
		}
	}
	cout<<"NO\n";
	return;
}
signed main(){
	ios::sync_with_stdio(false);
	int n;cin>>n;
	for(int i=1;i<=n;++i) func();
	return 0;
}
```