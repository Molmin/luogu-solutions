数据结构有风险，倒序开题需谨慎。
![](https://cdn.luogu.com.cn/upload/image_hosting/l1g25h7n.png)

-----

首先一定可以发现，每一次询问的连通块一定是由边权大于询问给定限定值的边集组成。所以直接想到将所有询问离线，按边权排序，每次直接查询连通块即可。

对于每次查询，我们要找到
- 连通块的最大值。
- 当前节点到多个最大值节点中，路径上边的花费最大值最大的一条路径。

这需要我们写一个数据结构支持维护连边，与维护连通块内的最大节点与最大节点上的权值。

考虑使用 LCT，连通块的最大值可以通过 LCT 的常见子树维护方式得到，那么路径上的最大值：
- 我们令一个 pair 存储，第一位为 最大节点，第二位为最大边花费。
- 考虑在 pushup 的时候进行对路径最大值的讨论。
	- 如果 pair 第一位由 splay 上左儿子继承，则将其路径最大值直接置于当前第二位。
   - 如果 pair 第一位接受了来自虚儿子或者右儿子的信息，则第二位需要与当前节点的花费取 max。（拆边为点，原树点“花费”为空）
- 同时用 set 进行对于子树的维护。那么就能够得到一个 $\mathcal O(n\log^{2} n)$ 的大常数算法。
![](https://cdn.luogu.com.cn/upload/image_hosting/vf7bs9qx.png)

多次卡常也不行，我们需要从复杂度的根本上对进行优化。我们考虑瓶颈在于虚儿子转移边的 set 中存储了虚儿子的所有信息，插入与删除的时间。

由于我们只取子树中最大节点的信息，这样的虚儿子一定只有一个。发现在实链 splay 上，左右儿子也可能成为最大值。最重要的，本题在询问离线后只有连边操作。那么当 set 的大小大于 3 时，直接弹出最小元素。这样，set 维护虚儿子信息的时间可视为常数。得到一个 $\mathcal O(n\log n)$ 的算法。

[code](https://codeforces.ml/contest/1583/submission/132588024)