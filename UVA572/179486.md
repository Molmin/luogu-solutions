# 裸裸的DFS
最近迷上了**刷DFS**，这道题也是典型的**DFS求连通块**问题，就是输入有点~~小麻烦~~。

------------
值得的是油田扩张的方向有八个：

------------

```cpp
int dir[8][2]={{1,1},{-1,-1},{1,-1},{-1,1},{1,0},{-1,0},{0,1},{0,-1}};
//这样可能会好理解一些，一个大括号内，存储一次扩展方向对下x,y坐标产生的影响;
```

------------

然后就处理搜索，感觉没有必要开bool数组存搜索状态，其实在满足条件的同时，只要是搜过的油田，直接填充成 **土** 就好了：

------------

```cpp
if(tx>=1&&tx<=n&&ty>=1&&ty<=m&&a[tx][ty]=='@')//满足搜索条件;
		{
			a[tx][ty]='.';//填充操作;
			dfs(tx,ty);//继续搜索;
		}
```
------------
Ps：因为是求连通块，所以不存在有结束搜索的条件，填充完了，自然停止;


贴一手代码：

------------

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m;
int dir[8][2]={{1,1},{-1,-1},{1,-1},{-1,1},{1,0},{-1,0},{0,1},{0,-1}};
int sum[1001];
char a[1001][1001];
void dfs(int x,int y)
{
	for(int i=0;i<8;i++)
	{
		int tx=x+dir[i][0];
		int ty=y+dir[i][1];
		if(tx>=1&&tx<=n&&ty>=1&&ty<=m&&a[tx][ty]=='@')
		{
			a[tx][ty]='.';
			dfs(tx,ty);
		}
	}
}
int main()
{
	int v=1;
	while(cin>>n>>m,n!=0)//处理输入不为0，否则停止;
	{
		int ans=0;//处理答案用的;
		for(int i=1;i<=n;i++)
		    for(int j=1;j<=m;j++)
		    {
		    	cin>>a[i][j];
			}
		for(int i=1;i<=n;i++)
		    for(int j=1;j<=m;j++)
			{
				if(a[i][j]=='@')
				{
					dfs(i,j);
					a[i][j]='.';//填充自己;
					ans++;//因为求连通块，每搜索到的都已经处理了连通块，所以每次搜到油田，则ans++;
				}
			} 
		sum[v]=ans;//存进数组，不过好像没用，可以直接输出的;
		v++;//
	}
	for(int i=1;i<v;i++)
	{
		cout<<sum[i]<<endl;
	}
	return 0;
} 
```
------------

### 其实这道题就这么~~简单~~
