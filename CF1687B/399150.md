诈骗题。$n$ 是无用的，复杂度瓶颈在于输出。

此外 $n,m$ 开这么小其实是为了交互器的复杂度正确，与正解关联不大。

## 思路

首先考虑用 $m$ 次询问来得到每一条边的边权。

首先我们考虑对边权从大到小排序，然后从大到小删边。

注意到当我减少一条边，假如最大生成森林的总权值并没有减少这条边的边权，那么相当于是原图为了保持连通性不变换上了一条更小的边。

那么类似的我们可以想到当减少一条边，最大生成森林的总权值减少了这条边的边权，说明原图不得不放弃维持连通性，那么这条边是为了连通某两个“砍掉这条边就不连通了的”点所需要的最小的边。

然后想一想 Kruskal 的行为，当我选到这样的一条边时这一条边的两端一定没有被连过，那么这条边一定会被加入。所以这就说明这条边一定在最小生成森林上。

因此实现时先用 `000100` 这样的询问 $m$ 次得到边权。

然后按照从大到小边权排序，一开始放满 `111111`，然后抠掉最大的边，得到 `111011`，将两次的答案作差得到最大生成森林的总权值减少量，和这条边的边权比较并且处理就好了。然后继续抠成 `110011`，以此类推。

## 代码

$n$ 是没有作用的。复杂度 $\mathcal O(m^2)$，瓶颈在于输出。

```cpp
int n,m;
string s;
pii a[N];
bool cmp(pii x,pii y){
	return x.fi>y.fi;
}
int main(){
	cin>>n>>m;
	fr1(i,1,m){
		string s="";
		fr1(j,1,m){
			s+='0';//这里写的比较 naive
		}
		s[i-1]='1';
		cout<<"? "<<s<<endl;
		int x;
		cin>>x;
		a[i].fi=x;
		a[i].se=i;
	}//查询边权
	sort(a+1,a+m+1,cmp);//按边权排序
	fr1(i,1,m){
		s+='1';
	}
	int ans=0;
	int x=0,res=0;
	fr1(i,1,m){
		cout<<"? "<<s<<endl;
		cin>>x;
		if(!res){//第一次没有res要特判
			s[a[i].se-1]='0';
			res=x;
			continue;
		}
		if(res-x==a[i-1].fi){//砍掉上一条边影响连通性
			ans+=a[i-1].fi;//一定在最小森林上
		}
		s[a[i].se-1]='0';//抠掉边权最大的边
		res=x;
	}
	cout<<"! "<<ans+x<<endl;//最后一条边一定是影响连通性的边，因此在最小森林上
	ET;
}
```

[AC 记录](https://www.luogu.com.cn/record/101876109)