大力O(n)dp，这题n只给开到100的原因是防止方案数爆longlong

________________________________

简单说一下并不好懂的题意，给定一个只有A和B的环形字符串，定义一次变换是将字符串中所有的“AB”(方向是顺时针方向开始读)替换成“BA”，现在输入一个目标串，问有多少种字符串可以在一次变换之后变成目标串

## 本题题解

首先众所周知环形字符串是没法dp的，所以想dp就得破环为链

那么我们随便找一个位置开始断开，但是我们发现断开之后会发现一件事情是第一个字符可以和最后一个字符发生交换……这就相当的不妙了

那么我们把开头的字符复制到最后一个字符上同时钦定这两个字符必须相同，我们就完成了破环为链的工作了

此时我们要做的就是大力dp，设$dp_{i,j},j\in \{0,1\}$表示决策到了第i位并且第i位填了A/B这个字符时合法的字符串方案数

那么我们现在开始大力的转移就是说枚举下一位填什么字符了

那么我们开始大力分情况讨论一波

### case1:求$dp_{i+1,0}$

由于我们填了一个0，所以说明一件事是$i+1$和$i$永远不可能发生转向关系

所以我们显然只需要判断一下目标字符串的第i位是“A”还是“B”

如果是"A"的话那么$dp_{i,0}$和$dp_{i,1}$都有机会转移到$dp_{i+1,0}$上

但是如果是"B"的话由于i和i+1并没有发生转身，因此仅仅$dp_{i,1}$可以转移到$dp_{i+1,0}$上

### case2:求$dp_{i+1,1}$

这个部分的情况相对辣手，因为我们填了一个1所以导致我们的$i+1$和$i$之间可以交换了

那么此时我们就需要看目标字符串的第$i+1$位是"A"还是"B"了

#### case2.1:是"A"

那么我们发现此时发生了转向

我们此时需要看字符串的第i位是什么来判断i之前的方向

如果是A的话说明原来i的方向是”B“问题来了"BB"间不可能发生交换的

所以这种情况下$dp_{i+1,1}$是0

如果是B的话说明原来i的方向是”A“因此$dp_{i,0}$可以转移到$dp_{i+1,1}$上

#### case2.2:是"B"

那么此时我们并未发生转向

因此$dp_{i,0}$和$dp_{i,1}$都可以转移到$dp_{i+1,1}$上了

好了现在最后的问题是dp初始条件是什么呢？

~~我们枚举一下开头是选A还是选B分别跑一个dp二者相加就行了~~

记得满足破环为链的限制条件，就是说我们的开头和结尾必须是同一个字符

上代码~

```C
#include<cstdio>
#include<algorithm>
using namespace std;const int N=1e3+10;typedef long long ll;
ll res;ll dp[N][2];char mde[N];int n;
inline void dypr()
{
    for(int i=1;i<=n;i++)
    {
        dp[i+1][0]=(mde[i]=='A')?dp[i][0]+dp[i][1]:dp[i][1];
        if(mde[i+1]=='A'){if(mde[i]=='B')dp[i+1][1]=dp[i][0];}
        else {dp[i+1][1]=dp[i][1];}
    }
}
int main()
{
    scanf("%s",mde+1);for(n=1;mde[n+1]!='\0';n++);mde[n+1]=mde[1];
    dp[1][0]=1;dypr();res+=dp[n+1][0];
    for(int i=1;i<=n+1;i++)dp[i][0]=dp[i][1]=0;
    dp[1][1]=1;dypr();res+=dp[n+1][1];
    printf("%I64d",res);
}
```
