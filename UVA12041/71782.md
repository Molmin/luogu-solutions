我们都熟悉斐波那契数列（1,1,2,3,5,8，...),那如果我们定义一种相似的字符串数列呢？听起来很有趣？我们一起来看看。

我们定义下列序列
 
 BFS(0)=0 BFS(1)=1(这里"0"和"1"都是字符串，不是通常意义的数字0或1）
对于所有的(n>1)BFS(n)=BFS(n-2)+BFS(n-1)（此处‘+’表示字符串联结）（例如：第n个字符串是第n-2个和第n-1个字符串连接后的结果）

 所以，可以得到这样一个字符串序列：0,1,01,101,01101...

你的任务是找出序列中第n个字符串并输出第i位-第j位的子串

输入格式

第一行输入文件包含一个整数T（T<=100)表示事件总数，每一个事件的描述如下：
三个整数：N，i，j (0 ≤ N, i, j ≤ 2^31 − 1) and (i ≤ j)and (j − i ≤ 10000)
保证i,j是有效数字（0<=i,j<=length(BFS(N)))

输出格式

对于每个子串，输出BFS（N）的第i位-第j位（一行）

这是一个很常规很简单的字符串，代码如下：


------------
```pascal
var
 s,s1,s2,ans:ansistring;
 n,i,j,k,m:longint; g,t:integer;
begin
 read(T);
 for g:=1 to T do begin
  s:=s+'0'; s1:=s1+'1';
  read(n,i,j);
  for m:=2 to n do begin
   s2:=s+s1; s:=s1; s1:=s2;
  end;
  if n=0 then s2:=s; if n=1 then s2:=s1;
  ans:=copy(s2,i+1,j-i+1);
  writeln(ans);
  s2:=''; s1:=''; s:='';
 end;
end.
```

