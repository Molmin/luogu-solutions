相对于其他题解，加入了更多思路推导并对贪心给出证明。

**题意**

给你一个长度为 $N(1 \le N \le 10^6)$ 的**随机生成**的 `01` 字符串。你需要找到他的 $2$ 个可以相交的连续子段，将这两个字段按位或，求结果最大值（用二进制）。

**分析**

先要搞清楚两个二进制数谁大。我们发现：

1. 先比较两个数的**长度**。长的大。

2. 从**最高位**开始往后比，当在某一位出现一个数是 $1$ 而一个数是 $0$ 时，有 $1$ 的大。

这是一个贪心的策略。因此本题也可以贪心的完成。

我们设结果的两个字段所形成的二进制数分别是 $A$ 和 $B$ ,且 $A \ge B$。

首先需要满足长度尽可能大。显然，**原字符串的第一个 `1` 一定出现在 $A$ 中**。证明：如果没有出现，那么这时的 $A_1$ 可以向高位继续扩大直到包含最高的 `1`。这是**不劣**的。

那么我们的 $A$ 其实已经确定了：设原字符串的第一个 `1` 的下标是 $head$，则 $A$ 是 $[head,N]$。

我们来找 $B$。因为 $B$ 存在的意义是填补 $A$ 的 `0` 位的空缺，又结合上文二进制数比较的步骤 $2$，可以得到结论：**$B$ 的最高位一定是 `1`，且这个 `1` 是用来填补 $A$ 的第一个 `0` 的位置的**。 也可以类似地证明：如果 $B$ 的最高位的 `1` 没有用于填补 $A$ 的第一个 `0`，那么这时最终结果会更劣。而且，$B$ 一定时以 `1` 开头的，因为 $B$ 的首要任务是填补 $A$ 的第一个 `0`，如果说填补那个 `0` 的那个 `1` 不是 $B$ 的开头，那么这个 `1` 前面的元素都是毫无意义的，这是不优的。

所以，$B$ 应该符合以下条件：以 `1` 开头；假设 $A$ 的第一个 `0` 出现在原字符串的第 `zero` 个，则 $B$ 的长度是 $|B|=N-zero+1$。如果更长，则会造成浪费，是不优的。

**现在需要对 $B$ 进行枚举**。其实只需要暴力枚举就可以：先枚举 $i \in [1,N-|B|+1]$，对于每个 $i$，枚举 $j \in [1,|B|]$，进行判断。**最劣复杂度是 $O(N^2)$ 没错，但是因为数据随机生成，所以说 $zero$ 会出现得很早，那么 $N-|B|+1$ 会非常小，因此时间复杂度近似于 $O(N)$。**

代码不太好写：**AC CODE**
```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAXN=1e6+5;
int N;
int a[MAXN];
string f,ans;
//文本题解中的变量名与代码中的变量名基本相同，可以一一核对理解
int main()
{
	scanf("%d",&N);
	int head=0,lena=0;
	int zero=0,lenb=0;
//	puts(",,");
	for(int i=1;i<=N;i++) 
	{
		scanf("%1d",&a[i]);
		if(a[i]==1&&head==0) head=i;
		if(a[i]==0&&head&&zero==0)  zero=i;
	}
//	puts("--");
	lena=N-head+1;
	lenb=N-zero+1;
	if(head==0)
	{
		puts("0");
		return 0;
	}
	if(zero==0)
	{
		for(int i=1;i<=lena;i++) putchar('1');
		return 0;
	}//两个特判
//	puts("!!");
	f.resize(N),ans.resize(N);
	for(int i=head;i<zero;i++) putchar('1');//因为这里肯定是要匹配上的，所以先输出了
	for(int i=1;i<=N-lenb+1;i++)
	{
		f.clear();
		if(a[i]==0) continue;
		for(int j=1;j<=lenb;j++)
		{
			f+=((a[i+j-1]||a[zero+j-1])?'1':'0');
		}
		ans=max(ans,f);
	}
	cout<<ans<<'\n';
	return 0;
}
```
