## 其实，这道题并不需要判断是否越界
只需要一个**小小的**函数就行了：
```cpp
int f(int x)
{
	if(x>0)return x;
	return 0;
}
```
如果x>0，就返回x，否则，就返回0（最后在统计时不统计i,j是0的情况）。

另外，这个增量数组特别**烦人**，我弄了几乎15分钟！！
|  |i-2  |i-1  |i  | i+1 | i+2 |
| -----------: | -----------: | -----------: | -----------: | -----------: | -----------: |
|j-2  |  |  | y |  |  |
|j-1  |  | y |y  | y |  |
| j   | y | y |  | y |  y|
|  j+1|  | y | y | y |  |
|  j+2|  |  | y |  |  |

|  | i-2 |i-1  |i  | i+1 | i+2 |
| -----------: | -----------: | -----------: | -----------: | -----------: | -----------: |
| j-2 | y |y  |y  | y |y  |
| j-1 | y | y | y | y | y |
|  j| y |  y|  | y | y |
|  j+1| y | y | y |y  | y |
|  j+2| y | y |y  | y |y  |

这两张表就是我当时编增量数组时的草图，不懂的话可以看看（题目上的莹石真TMD坑）。

代码如下：
```cpp
#include<cstdio>
#include<iostream>//cmath中y1函数和程序中冲突了，所以没用万能头
using namespace std;
int n,m,k,x,y,a[1005][1005],ans;
const int x1[15]={0,2,0,-2,0,1,1,1,0,0,-1,-1,-1};
const int y1[15]={0,0,2,0,-2,0,1,-1,1,-1,0,1,-1};
const int x2[30]={0,-2,-2,-2,-2,-2,-1,-1,-1,-1,-1,0,0,0,0,1,1,1,1,1,2,2,2,2,2};
const int y2[30]={0,-2,-1,0,1,2,-2,-1,0,1,2,-2,-1,1,2,-2,-1,0,1,2,-2,-1,0,1,2};//四个增量数组
int f(int x)
{
	if(x>0)return x;
	return 0;
}//防越界函数
int main()
{
	cin>>n>>m>>k;
	for(int i=1;i<=m;i++){
		scanf("%d%d",&x,&y);
		a[x][y]=1;
		for(int j=1;j<=12;j++)
			a[f(x+x1[j])][f(y+y1[j])]=1;
	}
	for(int i=1;i<=k;i++){
		scanf("%d%d",&x,&y);
		a[x][y]=1;
		for(int j=1;j<=25;j++)
			a[f(x+x2[j])][f(y+y2[j])]=1;
	}
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
			ans+=a[i][j];//加上已经标记的数
	cout<<n*n-ans;//所有方阵减去已经标记的，当然，也可以直接统计未标的数。
}
```