### 这道题是一个很经典的模拟题所以发了个题解
这道题其实并不难

看了看前面几个题解主要分为几种:

1.非常精简无暴力的

2.纯暴力的

3.打表的

............... 

总结一下:要么你需要想，要么要很大的代码量（50行左右）

但你要是你不愿意去想并且你也不愿意写很长的代码

~~天下哪有那么好的事~~

所以才有了今天这个题解

代码量：30行

思路：定义一个坐标类似于

```cpp
int a[100+5][100+5]
```

接下来该输入什么输入什么

#### 现在是本代码的重点（也是和别的题解不太一样的地方）

首先我们看一下火把照亮的区域（1代表不刷怪区域）

```cpp
00100
01110
11111
01110
00100 
```

我们可以简单的分成2部分

```cpp
1.
00100
0   0
1   1
0   0
00100 
2.
 
 111
 111
 111
```

我们可以发现，第二部分其实就是一个正方形，我们只需要用一个二重循环就可以直接完成，只需要单独枚举第一部分就行了

而萤石是个3x3的方阵所以同理

代码（由于已经有思路所以代码不做太多解释）：

```cpp
#include <iostream>
#include <cmath>
#include <string>
#include <algorithm>
using namespace std;
int a[100+5][100+5];//定义一个坐标 
int main()
{
	int n,m,k,x,y,ans=0;
	cin>>n>>m>>k;
	for(int i=1;i<=m;i++)
	{
		cin>>x>>y;//输入火把的坐标 
		for(int j=x-1;j<=x+1;j++)
			for(int k=y-1;k<=y+1;k++)
				a[j][k]=1;
		a[x-2][y]=1,a[x+2][y]=1,a[x][y-2]=1,a[x][y+2]=1;
	}
	for(int i=1;i<=k;i++)
	{
		cin>>x>>y;//输入萤石的坐标 
		for(int j=x-2;j<=x+2;j++)
			for(int k=y-2;k<=y+2;k++)
				a[j][k]=1;
	}
	//搜索如果有没亮的格子答案+1 
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++)
			if(a[i][j]==0)	ans++;
	cout<<ans<<endl;
	return 0;
}

```

# 祝大家顺利通过！！！

