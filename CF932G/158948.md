#### 题意：

给定一个串，把串分为偶数段。

假设分为了 $s1,s2,s3....sk$ 。

求，满足 $s_1=s_k,s_2=s_{k-1}......$ 的方案数。

#### 分析：

先举个例子，一个长为8的串 $S$ 用下标表示： ${12345678}$ 。

如果划分为： ${1|2|3|4|5|6|7|8}$ ，那么要求： $1=8,2=7,3=6,4=5$ 。

如果划分为： ${12|34|56|78}$ ，那么要求： $12=78,34=56$ 。

我们尝试用这个例子再观察一点东西。

若划分为 $123|4|5|678$ ，则需判断是否有 $123=678$ ,也即 $1=6,2=7,3=8$ 。

这样并不方便，若划分为 $1234|5678$ ，则需判断是否有 $1234=5678$ ，与上面的判断相比，相当于在中间多了个 $4,5$ 。

而且判断相等这种东西只好用 $\texttt{Hash}$ 做，但这样就需要枚举，显然不适用于这道题。

那么我们将 $678$ 反着放，即 $123<=>876$ ，然后分别按从左往右和从右往左判断，这样放的好处在于长度加一后为 $1234<=>8765$ ，是在后面添加一个得到的。

并且可以显然发现拼在一起后判定方式为判定回文串。

但是如果这样做还是需要在中间加字符。

于是考虑将前段下标小的和后段下标大的放在前面，就可以将两种优势结合在一起了。

即**前段从小到大放在奇数位置，后段从大到小放在偶数位置**，即 $182,736$ ，添加一个为 $1827,3645$ 。

本质上利用了判定的下标和为定值的性质： $1+8=2+7=3+6=9=4+5$ 。

那么对于一个长为 $|S|$ 的串 $S$ ，我们将其按上述方式放置，然后~~震惊地发现~~划分方式就由原来的划分为偶数段分别判相等，变为了划分为长为偶数的回文串的方案数。

然后，回文串划分就是套路了。

先建 $\texttt{PAM}$ ，设 $dlt[x]=len[x]-len[fail[x]]$ ，将 $fail$ 链上的节点都取出来，可以证明 $dlt$ 要么不变，否则必定比上一个 $dlt$ 的一半小。

~~我有个很好的证明可惜这里写不下。~~

简单地说，对于 $\texttt{PAM}$ 上的一个节点 $x$ ，令 $y=fail[x],z=fail[y]$ ，有 $len[x]-len[y]>=len[y]-len[z]$ ，表达的就是 $dlt[x]>=dlt[y]$ ，且有，当 $dlt[x]>dlt[y]$ 时， $len[x]-len[y]>len[z]$ ，可以严谨证明，但相信感性理解一下也不难看出。

再设 $jup[x]$ (我会告诉你这是jump的简称吗)为 $x$ 的 $fail$ 链上第一个 $p$ 使得 $dlt[p] \neq dlt[x]$ 。

那么我们每次跳 $jup$ 而不是 $fail$ ，就可以做到 $O(log)$ 遍历 $fail$ 链了。

容易知道 $jup[x]$ 都为一条 $dlt$ 相同的链中 $len$ 最大的位置(简称 $dlt$ 链首)，将整条 $dlt$ 链 $dp$ 值之和存在这个位置即可。

在 $\texttt{PAM}$ 上边走边更新 $dp$ 值，每次 $O(log)$ 跳上去更新即可。

具体地说，对于每个 $dlt$ 链首 $x$ 处更新 $dp$ 值，由于回文串的对称性，可以由 $fail[x]$ 的 $dp$ 值快速得到。(盗了一张图的某个部分，侵~~改~~删)

![](https://cdn.luogu.com.cn/upload/image_hosting/cqgaw0e8.png)

你可以明显地看到只多了一个位置的 $dp$ 值，易得位置为 $pos-len[jup[x]]-dlt[x]$ ( $pos$ 表示当前位置)。

显然地，由于 $x$ 位于 $dlt$ 链首， $fail[x]$ 也位于 $dlt$ 链首，所以 $fail[x]$ 在上一次也必定被更新过，可以保证正确性。

于是这道题就在 $O(|S|log|S|)$ 的时间复杂度内解决了，空间复杂度为 $\texttt{PAM}$ 与 $dp$ 数组优秀的 $O(|S|)$ 。

#### 核心代码：

```cpp
	//震惊，某CF-G题核心代码仅两行。
	for(p=lst;p;p=jup[p])
	{//tot = pos
		G[p]=Ad(jup[p]^fil[p]?G[fil[p]]:0,F[tot-len[jup[p]]-dlt[p]]);
	}//G:dlt链的dp值之和 F:某位置的dp值
```

Upd:修正了小笔误。