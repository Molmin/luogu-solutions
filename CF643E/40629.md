评分`2700`,**看**了题解

额，dp本来就会，但看了正解关键在**无视误差**

> 维护一棵初始为空的树支持维护
>
> - 加入一个点并以$x$为父亲
> - 询问以$x$为根的子树内最深点深度的期望
>
> 其中每条边断掉概率为$\frac{1}{2}$
>
> 注明一下:所谓子树内最深点是和根相连接联通块中深度最大的点

因为$E(\max)\neq\max(E)$所以直接一维做很吃力，你发现不可能只依赖点来转化

不如把期望拆成概率

第一个技巧：问题求最大，并且每一步都要取到，设的时候不应设刚好

$f_{x,d}$表示$x$子树内最大深度$\leqslant d$的概率

则
$$
f_{x,d}=\frac{\sum_{y}f_{y,d-1}+1}{2}
$$
最大刚好为$d$的概率就是$f_{x,d}-f_{x,d-1}$

发现增加一个点只会影响到根链上的点

于是$\mathcal O(n\max{D})$

然后轻轻松松炸掉

第二个技巧：方程中隔得越远贡献越小时，并且输出浮点数时可以考虑计算误差极限

事实上对于$x$贡献其$K$级祖先量级是$\frac{1}{2^K}$级别的，在本题精度要求下$K=50$即可

```cpp
if(opt==1){
    fa[++tot]=x;
    for(i=0;i<lim;++i)f[tot][i]=1;
    pre=f[x][0];f[x][0]*=0.5;
    for(i=1;i<lim&&x;++i,x=fa[x])now=f[fa[x]][i],f[fa[x]][i]*=(0.5+0.5*f[x][i-1])/(0.5+0.5*pre),pre=now;
}
if(opt==2){for(i=ans=0;i<lim;++i)ans+=i*(f[x][i]-f[x][i-1]);printf("%.10lf\n",ans);}
```