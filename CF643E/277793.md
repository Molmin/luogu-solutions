无视误差的思路确实非常厉害，但是对于我这样的蒟蒻来说，这道题的难点在于 DP 方程（捂脸）。在经过 n 个小时的挣扎后，我终于搞懂了所有疑问，特意发一篇题解来帮助和我一样的 xd。    

我们首先来看 DP 方程：  

$$
f[u][i]=\prod (\frac {1}{2} \times f[son][i-1] + \frac {1}{2}) $$

**问题一：DP 方程的含义。**  

答 ：$f[u][i]$ 表示以 $u$ 为根，深度 $\leq i$ 的概率。  

对于 $u$ 的每一条指向自己儿子的边，有二分之一的概率不断，那么我们需要让这个儿子的深度 $\leq i-1$，所以需要 $\frac {1}{2} \times f[son][i-1]$。

有二分之一的概率断掉，此时更新 $f[u][i]$ 就不需要再考虑这个断掉的儿子，直接加上二分之一即可。

**问题二：为什么加入一个新点 $x$ 后不需要把 $60$ 个祖先，从深度 $1$ 到 $60$ 挨个更新一遍**。  

答：设 $u$ 为 $x$ 的 $k$ 级祖先（$fa[x]$ 为一级，设 $y = fa[x]$，我们更新 u 只更新 $f[u][k]$ 即可。 

因为 $f[y][i] (i \geq 2)$ 相比加入 $x$ 之前，多乘了一个 $(\frac {1}{2} \times f[x][i-1] + \frac {1}{2})$，而 $f[x][i-1]$ 又都为  $1$，所以 $f[y][i]$ 不变，自然就不需要往上更新了。而 $f[x][0] = 0$，所以需要往上更新。  

**问题三：如何统计答案。**  

答：正常期望的答案统计就是概率乘事件贡献，这道题就是 $\sum _{i\leq60} (f[x][i] - f[x][i-1]) \times i$。而有些题解写的很奇怪。如下面这一段代码，其实就是将式子化简了一下，建议自己化一下式子。

**还有一个非常重要的问题，直接看代码注释吧。**

```cpp
	db ans = h-1;
    //这里减 1 ，是因为题目求的最大深度与我们DP设的最大深度不太一样，题目求的是子树最大深度，需要减 1。
	for(int i = 1 ; i <= h-1 ; i++)ans -= dp[x][i];
	printf("%.10lf\n",ans);
```
