# 1.题意
有 $m$ 个频道, $n$ 个老人，每个老人有最喜欢的频道和最讨厌的频道，若当前频道是某个老人最讨厌的，他就会把频道换成最喜欢的，如果多个老人讨厌同一个频道，最年轻的老人会切换频道，给定初始频道 $p$ ，输出切换几次频道才能停止，若无法停止，输出 $-1$ 
# 2.思路
若有一个老人喜欢 $a$ 频道，讨厌 $b$ 频道，那么当前频道是 $b$ 的话，就会被这个老人换成 $a$

根据上面的分析，我们可以将 $m$ 个频道抽象成 $m$ 个点，每一个老人抽象成从 $b$ 到 $a$ 的有向边，从 $p$ 开始搜索，若找到一个点没有边连向其他点，说明这个点所有老人都不讨厌，输出路径长度即可，若找到环，说明这几个老人会不停切换频道，输出 $-1$ 即可

但是题目中给了这么两句话
```
如果有多个老人讨厌现在的频道，他们中最年轻的会站起来，把频道换成他最喜欢的，其余的人都会坐着。
老人的输入顺序是按年龄从小到大排列的。
```
说明如果有一个点连出去多条边，只会走输入时最早的那条边，也就是**每个点只有一条边或没有边**，这样我们直接用一个数组 $to$ 来表示这个点连向哪个点就可以了，然后从 $p$ 开始遍历，遍历到哪个点就打上标记，若遍历到一个已经打了标记的点，说明有环，输出 $-1$没有边连出去，输出路径长度即可

# 3.代码
~~~cpp
#include<bits/stdc++.h>
using namespace std;
int n, m, p;
bool vis[100005];
int to[100005];

int work(int x, int tot)
{
	if(vis[x] == true)//遍历到之前访问过的点了，说明有环
		return -1;
	if(to[x] == 0)//这个点没有边连出去，说明找到了解，返回路径长度
		return tot;
	
	vis[x] = true;//上面两个情况都不符合就打上标记继续递归
	return work(to[x], tot+1);//这样写可以在找到解时直接一路返回到main()
}

int main()
{
	scanf("%d%d%d", &n, &m, &p);
	for(int i = 1; i <= n; i++)
	{
		int v, u;
		scanf("%d%d", &v, &u);//注意题目输入顺序
		
		if(to[u] == 0)//如果u之前没有边，即当前为时间最早的边
			to[u] = v;
	}
	printf("%d", work(p, 0));//用work函数递归解题
	return 0;
}
~~~