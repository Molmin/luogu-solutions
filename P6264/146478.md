## 思路
$$\texttt{Solution 1}$$
$$\text{60 pts}$$
很容易想到，按照题目模拟即可。从 $p$ 开始，记录一下当前的步骤，然后对于每一轮，从前往后搜，如果有人讨厌这个频道就直接变换，并进入下一个步骤。

时间复杂度 $O(n^2)$，肯定过不了 $n\le 10^5$ 的数据。而且，如果操作可以无限进行，那么程序就会持续不断地进行，肯定超时了。

我们先考虑一下如何处理死循环的情况。如果整个操作的步骤中出现了两个相同的频道，并在不同时间中出现，那么可以说就构成了**循环**，操作就会无限进行。如果没有这样的情况呢？很简单，操作会在 $m$ 轮之内截止。

所以我们可以想到用 ```vis[]``` 数组来判断这个频道是否在之前出现过，初始化 $\text{vis}_p$ 为 $1$。如果出现相同，直接退出并输出 ```-1```。

还有一种判断方法，就是**仅枚举前 $m$ 轮**，如果仍然没有结束，那么根据抽屉原理，必定存在两个数相同。进而会死循环。

$$\texttt{Solution 2}$$
$$\text{100 pts}$$

我们再看一眼样例。

```
3 4 2
1 2
2 3
3 2
```

对于样例 $1$，注意到第三个人是**不可能换频道的**。因为即使现在是频道 $2$，比他年龄小的人也会率先调转频道。

所以，可以调换频道的人最多只有 $m$ 个。那么我们自然想到记录一个 ```to[i]``` 数组，表示在电视上播放 $i$ 频道时，会调换到哪个频道。

这样，每次操作就变成了 $O(1)$ 的效率，总体复杂度变为 $O(n)$。优秀！

## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=100005;
int n,m,p;
int to[N];
int main(){
	scanf("%d%d%d",&n,&m,&p);
	for(int i=1;i<=n;i++){
		int x,y;
		scanf("%d%d",&x,&y);
		if(!to[y]) to[y]=x;//更新to数组
	} 
	if(!to[p]){//如果没人讨厌p频道，那么就不会调换。
    	printf("0\n");
		exit(0);
	}
	for(int i=1;i<=m;i++){//枚举前m轮
		p=to[p];//变换频道
		if(!to[p]){//如果下一步没人换频道，输出当前步数。
			printf("%d\n",i);
			exit(0);
		}
	}
	printf("-1\n");//如果仍没有结束，根据Solution1的介绍，应该输出-1。
	exit(0);
} 
```

记得点个赞再走哦~