本题是一道很基础的图论练习题。

但大家的思路也不要被题目标签所局限。

因为本题还可以用模拟解决。

## 思路

首先，我设置了一个桶 $flag$。

这个桶的作用就是统计某个频道有没有人讨厌。

如果这 $m$ 个频道都有人讨厌，那老人们一定会不断地循环切换频道，就要输出 $-1$。

反之，我们就将桶二次循环利用（节省空间）。

因为题目中的老人是按年龄输入的，所以我们也不用进行排序。

那桶要如何二次使用呢？

第一，我在判断每个桶是否为空时，将每个桶都置回初始值。

第二，我们在往桶里扔值时，判断条件就是该桶是否为空。

当桶 $b[i]$ 为空时，就将配套的 $a[i]$ 装进桶中，这样就保证一定会是最年轻的老人去调频道。

接下来我们思考：既然已经判断过一遍是否会产生循环了，那接下来的模拟岂不是用单重循环就行了？

事实就是如此，我们只需要执行一个循环次数不超过 $m$ 的循环，就可以得到答案。

第一，当 $p$ 频道本身就没人讨厌时，直接输出 $0$。

第二，如何模拟？

```
for(int i=1;i<=m;i++){
		if(flag[p]==0){//如果没人讨厌，就直接输出
			cout<<s;
			return 0;
		}
		else{
			p=flag[p];//将此时的频道置为讨厌本频道的人喜欢的频道
			s++;//计数器累加
		}
	}
	cout<<-1;//如果跑完m个频道又回到了原位，就说明形成了循环
```

了解模拟过程后，我们直接贴代码：

## Code
```
#include<bits/stdc++.h>
using namespace std;
int a[100011],b[100011],flag[100011],biaozhi[100011];
int main(){
	int n,m,p;
	cin>>n>>m>>p;
	for(int i=1;i<=n;i++){
		scanf("%d%d",&a[i],&b[i]);
		flag[b[i]]=1;//进行第一轮桶处理
	}
	int ll=0;
	for(int i=m;i>=1;i--){
		if(flag[i]==0){//判断桶是否都有值
			ll=1;
		}
		flag[i]=0;//将桶置为初始值
	}
	for(int i=1;i<=n;i++){
		if(flag[b[i]]==0){
			flag[b[i]]=a[i];//标志每个频道会被切换到的下一个频道
		}
	}
	if(ll==0){//会产生循环，直接输出
		cout<<-1;
		return 0;
	}
	int i=1,s=0;
   //上面讲过模拟过程了，这里不再赘述
	for(int i=1;i<=m;i++){
		if(flag[p]==0){
			cout<<s;
			return 0;
		}
		else{
			p=flag[p];
			s++;
		}
	}
	cout<<-1;
	return 0;
}
```
