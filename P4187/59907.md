珂能是我比较弱小,这道题不简单...康过几篇题解发现最终部分的说明缺失或是不严谨,这里会着重说明.

当n块每一块可以涂上任意颜色时视为所有情况也就是n^m.
现在就需要剔除不合法情况也就是**没有一个连续段长度为k且同一颜色**（这个可以简单证明）.

接下来是剔除不合法状态所使用的dp.我们设计二维状态f i j 表示第i位时相同颜色的后缀长度为j的方案数.转移方式就是f[i][j]=f[i-1][j-1],f[i][1]=sig{f[i-1][1 to k-1]*(m-1)}.**注意这在实际代码上也是有严格的顺序的.**
现在是nk的复杂度.

我们尝试在这个基础上进行优化。直接设计一维状态f[i]=长度为i时的所有不合法方案总数.

二维意义下的f[i][1]转移已经能轻易替换为f[i]+=f[i-1] * (m-1)了.
但是前者比较麻烦.我们发现所有原本二维的f[i][j]都是对应着现在的f[i-j] * (m-1),于是合并成现在一维状态意义为f[i]+=sig{f[i-k+1] to f[i-2]}*(m-1).

综上所述,最终转移成为f[i]={sig(f[i-k+1] to f[i-1])*(m-1)},然后自己随便前缀和优化就行了,**以及我再也不相信易证了！！**

于是说明到此结束,不知道易证的大佬们是有更好的理解方式还是我太蒻.枯了.

以下是代码
```cpp
#include<bits/stdc++.h>
#define fer(x,y,z) for(int x=y;x<=z;x++)
#define mod 1000000007
using namespace std;
long long n,m,p,a[1<<20],c=1,s;
main(){
	cin>>n>>m>>p;fer(i,1,n)c=c*m%mod;
	a[0]=1;fer(i,1,p-1)a[i]=a[i-1]*m%mod,s=(s+a[i])%mod;
	fer(i,p,n)a[i]=s*(m-1)%mod,s=(s+a[i]-a[i-p+1])%mod;
	 cout<<(c-a[n]+mod)%mod;
}
```
此题思维难度和代码难度不成正比,谢谢.

