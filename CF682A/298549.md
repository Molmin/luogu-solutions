今天把这道题AC了，自认为自己的做法很好玩，跟大家分享一下。    
闲话少说，切入正题——

------------
首先这题乍一看好像很简单，不就是 $O(nm)$ 暴力嘛~  
然后再定睛一看数据范围，好了炸了……  
那么我们改怎么做呢？这就是这道题的重头戏了——


------------
众所周知，$5$ 的倍数末尾一定是 $5$ 或者是 $0$（废话，这不是常识吗）。  
那么怎么判断两数相加是不是 $5$ 呢？  
根据小学数学列竖式，我们可以轻易的知道，当
$ 0\equiv[(x\mod10+y\mod10)\mod10]\pmod5$  
时，$x+y$ 必然是5的倍数。   

~~然后下面画风逐渐走向诡异了~~  

那么我们要怎么办呢？简单，打表！  

我们现在要做的事情就是寻找在 $0$~$9$ 之间哪两个数相加取余 $5$ 等于 $0$，这里我们用 $10$ 来代替 $0$，在后面会说明这样做的原因。  

献上打表的程序：  
```cpp
for(int p=0;p<=9;p++)
	for(int i=0;i<=9;i++)
		if((p+i)%5==0)
			cout<<p<<',';
cout<<endl;
for(int p=0;p<=9;p++)
	for(int i=0;i<=9;i++)
		if((p+i)%5==0)
			cout<<i<<',';
```  
为了更加直观这里直接枚举 $0$~$9$之间的，得到表后要把表里的 $0$ 换成 $10$。  

然后我们要统计 $1$~$n$ 和 $1$~$m$ 之间以 $0$~$9$ 做个位数的个数，这里就要用 $10$ 代替 $0$（这很好想吧），统计还是很简单的，就不细讲了。  

统计过后我们挨个枚举已经得到的两个数的组合，然后得出这两个数做个位数的次数的乘积，也就是以这两个数字做个位数能得到的相加是 $5$ 的倍数的数量，累加起来就能得到结果。  

上代码！
```cpp
#include<iostream>
#define int long long //防炸利器/xyx
using namespace std;
int nmod[100],mmod[100];
//nmod存储n以内每个数字做个位出现的次数
//mmod存储m以内每个数字做个位出现的次数
int ch1[30]={0,10,10,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9};
int ch2[30]={0,10,5,4,9,3,8,2,7,1,6,10,5,4,9,3,8,2,7,1,6};
//上面是刚才说的表
signed main()
{
	int n,m,ans=0;
	cin>>n>>m;
   //下面是统计
	for(int p=1;p<=10;p++)
		if(n%10>=p)nmod[p]=n/10+1;//当个位数还能有一个要记得+1
		else nmod[p]=n/10;//否则就除以10
	for(int p=1;p<=10;p++)
		if(m%10>=p)mmod[p]=m/10+1;
		else mmod[p]=m/10;
   //m的操作和上面同理
	for(int p=1;p<=20;p++)
		ans=ans+nmod[ch1[p]]*mmod[ch2[p]];//计算
	cout<<ans<<endl;	
}
```
统计要花 $O(20)$，更新要花 $O(20)$，一共 $O(40)$，已经很快惹。    