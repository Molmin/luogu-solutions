## 刚学OI三天的蒟蒻又来~~水社区~~写题解啦QWQ!
- 先看一眼数据范围 嗯~n~~只有~~10000位啊，很显然是数位DP（~~废话~~）
- 如果没有学过数位DP的小伙伴建议拿这道~~模板~~题练手：[P2657 [SCOI2009]windy数](https://www.luogu.org/problem/P2657)
- 不过这两道题总体来说类似，感觉本题还简单一些（~~不知道怎么上紫的qwq~~）


------------
## ~~闲聊结束，开始讲题~~
- 根据数位DP的套路，再加上此题的d（d为要求倍数的数，详见题面）很小（d≤100），所以考虑设f[i][j][k]表示——总共i位的数，最高位为j时（注意设状态时j可以为0），%d==k的数一共有多少（都说了d很小，所以数组只需开到10000 * 10 * 100）
- 状态转移方程
- f[i][j][k]=∑f[i-1][p][q] (其中p=0~9,(q+j)%d==k)(此处的q需要读者好好理解~~感性~~一波，~~其实也不难~~，根据设的状态~~很好~~推出来)
- 这是预处理~

```
int Mod(int x)//处理状态，也就是算出q
{
	return x<0?(x%d+d)%d:x;
}

void prework()//预处理
{
	for (int i=0;i<=9;i++)//只有一位的情况下特判
		f[1][i][i%d]=1;
	for (int i=2;i<=n;i++)
		for (int j=0;j<=9;j++)
			for (int k=0;k<d;k++)
				for (int l=0;l<=9;l++)
					f[i][j][k]=add(f[i][j][k],f[i-1][l][Mod(k-j)]);
}
```
- ~~现在到了精彩的累加答案的环节了~~
- 这里讲一下数位DP的精髓——分类讨论的累加答案
- 为什么要分类讨论：题目要我们求出1~n的所有满足条件的数的个数，但我们枚举时用的却是每位上的数字，这就使我们枚举的数可能大于n(这是绝不允许累加进答案的)
#### 分类讨论：
1. 位数小于题目给定数（也就是n）的数（不含前导0）
2. 位数等于n而且前i位等于n的数（i=0~n的位数），这里要注意在i=0也就是枚举的最高位小于n的数时，要单独拎出来处理，因为只有这一位不能为0（毕竟不含前导0）

**注意的地方：**
1. 以下我的代码中，n和题面中给出的n完全没有关系，我的代码中的n表示的是题面给的n（也就是原数）的位数
2. 因为运用了读入的小技巧，我直接从高位开始读入，所以下面work()中看似从低位开始枚举实则是从高位开始枚举（顺序问题很好理解吧）
3. 在分类讨论第二种情况时，累加答案时千万不能忘了前面相同的i位兄嘚对答案产生的影响，所以要在边做的时候边累加
4. 这些都是细节，~~不重要~~，对数位DP的基本思想没有太大影响，每个题目有每个题目的不同点，我们学习主要还是了解思想嘛qwq

上完整代码，细节看注释好啦，~~自以为~~注释写的很详细

```
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<iostream>

using namespace std;

const int M=1000000007;
typedef long long LL;
int d,a[10009],f[10009][10][109],n;

int Mod(int x)//处理状态，也就是算出q
{
	return x<0?(x%d+d)%d:x;
}

LL add(LL x,int y)//加完再取余(%%%)
{
	return x+y>=M?x+y-M:x+y;
}

void prework()//预处理
{
	for (int i=0;i<=9;i++)//只有一位的情况下特判
		f[1][i][i%d]=1;
	for (int i=2;i<=n;i++)
		for (int j=0;j<=9;j++)
			for (int k=0;k<d;k++)
				for (int l=0;l<=9;l++)
					f[i][j][k]=add(f[i][j][k],f[i-1][l][Mod(k-j)]);
}

void init()
{
	scanf("%d",&d);
	while(scanf("%1d",&a[++n])!=EOF);//读入小技巧：限制宽度
	n--;//因为++n的时候多加了一次，所以要给他减掉
}

void work()
{
	prework();//预处理qwq
	LL ans=0;
	for (int i=n-1;i>=1;i--)//先把答案加上不足n位的情况
		for (int j=9;j>=1;j--)
			ans=add(ans,f[i][j][0]);
	for (int i=a[1]-1;i>=1;i--)//单独处理第n位也就是最高位(由于之前读入的原因，所以a[1]就是最高位)
		ans=add(ans,f[n][i][0]);
	int k=a[1];//记录等于原数的情况时最高位到当前位的数字之和
	for (int i=2;i<=n;i++)//从次高位到最低位(顺序问题和上文相同)
	{
		for (int j=0;j<a[i];j++)//这一位小于原数的情况
			ans=add(ans,f[n-i+1][j][Mod(d-k)]);//后面的数位随便，所以放心大胆的把所有预处理的情况加上，其中的Mod(d-k)类似上文处理q的过程
		k+=a[i];//累加
	}
	//其实按道理来讲自始至终没有累加原数对模d的贡献，最后还要特判一下
	//但数据好像比较水，没加竟然也过了(才不是我忘了QWQ)
	//懒得加了，写一波伪代码
	//if(原数%d==0)
	//    ans++;
	printf("%lld\n",ans);
}

int main()
{
	//freopen("AT681.in","r",stdin);
	//freopen("AT681.out","w",stdout);
	init();
	work();
	return 0;
}

```

蒟蒻的第一篇紫题题解，写的不好但希望尽可能给大家带来帮助QWQ。最后，祝奋斗在前线的所有OIer们：
# 2019 CSP-J/S RP++！！！