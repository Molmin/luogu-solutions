这道题题目看似比较复杂，实际上可以理解为检查是否有前后两个数差为 1 的情况。有则输出 "2" ，反之输出 "1" 即可。这里我给大家讲一种奇怪的方法，它速度极快，是最优解。

普通的方法是先排序一下再从头检查，但是这种方法不需要第二步。我们可以直接将检查的任务放在排序中。只需定义一个排序的策略即可。这些我们可以节省 $\tfrac{1}{2}$ 到 $\tfrac{1}{3}$ 的时间。

```cpp
#include<stdio.h>
#include<algorithm>
int num[1005],n,t,ans;	//数据范围：n<100，我们开到 105。
bool cmp(int m,int n)	//我们定义一个新的排序策略。
{
	if(abs(m-n)==1)	//如果参与排序的两个数 m n 的差是 1，则将 ans 赋值成 2 。其中 abs() 是绝对值的意思。这里需要注意：要把变量 ans 定义在策略 cmp 之前。
		ans=2;
	return m<n;	//返回 m<n ,正常排序就是这样的。
}
int main()
{
	scanf("%d",&n); //我们不用管次数，把它读入变量 n 即可。
 	while(scanf("%d",&n)+1) //因为当scanf读到文件结尾时返回值为 -1 ，我们加 1 ，在该情况下循环不再继续运行。普通情况下读入变量 n 。
	{
		ans=1; //注意这里要把 ans 赋值成 1 ，因为如果没有两个差为 1 的数要输出 1 。
		for(t=0;t<n;t++)
			scanf("%d",num+t); //读入 num[t] 。
		std::sort(num,num+n,cmp); //排序，注意使用策略 cmp 。
        printf("%d\n",ans); //输出变量 ans 。
	}
	return 0; //Don't forget this.
}
```



蒟蒻橙后第 4 篇题解。