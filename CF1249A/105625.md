### CF1249A
有一个长度为n的序列$a_1$,$a_2$...$a_n$，将他们分为若干组，使得每一组没有两个数的差为$1$，使分的组数尽可能少。

我们可以发现，如果读入的数据是连续的，像这样：
```
10
1 2 3 4 5 6 7 8 9 10
```
那么应该分两组，分完后两组一组是奇数，一组是偶数。其实只要按奇数和偶数分组，此题就能解决，~~这也是显然易证的~~，最终分组数只能是一组或者两组。但要求最小组数，我们会发现即使有偶数有奇数，但不连续，仍然是可以分一组的，所以问题转化为判断有没有两个数相连。

代码如何实现呢？

先将读入的数排序，然后从头扫一遍，如果有两个数连续则输出$2$，否则输出$1$。

#### code:
```cpp
#include<bits/stdc++.h>
using namespace std;
int main ()
{
    int t,n,a[110],vis;
    scanf("%d",&t);
    while(t--)
    {
        vis=1;//初始化，vis记录要输出的组数
        scanf("%d",&n);
        for(int i=1;i<=n;i++)
            scanf("%d",&a[i]);
        sort(a+1,a+1+n);//排序
        for(int i=2;i<=n;i++)
            if(a[i]-a[i-1]==1)//判断
                vis=2;//连续，赋值为2
        printf("%d\n",vis);
    }
    return 0;
}
```
有同学可能会问了，那如果$n=1$怎么办呢，是不是就进入不了循环了，循环是无法进入，但是输出的仍然是初始化的$1$，发现正好与要输出的结果一致，本题解决。

##### The End--2019/10/23 20:23