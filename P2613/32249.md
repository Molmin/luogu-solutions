潘承洞 潘承彪 在《初等数论》书中序言写到

#####  _"初等数论是研究整数最基本的性质，是一门十分重要的数学基础课。"_ 

那么本题中怎么不是整数？？？有理数?？？？于是我最开始作为一个数竞学的不是甚好的人便在此纠结良久。

首先，这里我们想求的即将a/b对19260817取模。**我们希望可以将问题化归到熟知的整数范围内**。不过从严谨一点的角度，我们甚至连有理数取余是否有意义我们也未讨论。但我们可以这样去想，一个实数与其倒数的积等于1，则其积对任意正整数取模也等于1。而无理数取模显然是偏离主题的（其实也没什么意义）。

对于有理数，则p×(1/p)≡1(mod q)，(q∈**N***)。于是1/p就同余于p^(-1)，即p的逆元。注意这里并不是直接的等于（不然还有啥可解释的），因为**这里的p^(-1)和(1/p)是两回事，p的逆元是整数，而(1/p)是一个分数**。于是我们通过这样的方法，便将整数的同余推广到了有理数范围内。

所以，a/b对19260817取模就是a×b^(-1)对19260817取模。所以问题的重点便在于如何求出b的逆元。这里要说的便是适用范围较广且较为实用的**扩展欧几里得算法**。

### 预备知识

1. 最大公约数

对于两个整数a、b，若整数d满足d|a且d|b，则d为a和b的公约数。在所有满足条件的d中，我们将最大的叫为**最大公约数，记为(a,b)**。

性质：(a,b)=(a,a-b)。将b不断减直到小于b则(a,b)=(a,a%b)。

2. 裴蜀定理

若ax+by=z， (a,b,x,y∈**Z**)，则z是(a,b)的倍数。裴蜀定理可以用带余除法证明，这里不详细介绍。

3. 乘法逆元

若ax≡1(mod q)，(q∈**N***)，则称x为a关于q的逆元。

### 于是

bx≡1(mod p)，由裴蜀定理，等价于bx+py=1。若b=0，则本题无解（因分数本身也无意义）。

先对一般情况即bx+py=(b,p)，由裴蜀定理可设

bx1+py1=(b,p);

px2+(b%p)y2=(b,b%p);

特别的，当p=0时，有(b,p)=b，得一组特解x0=1,y0=0;

而(b,p)=(b,b%p)，于是bx1+py1=px2+(b%p)y2，即bx1+py1=px2+(b-[b/p]×p)y2，即bx1+py1=px2+by2-([b/p]×y2)p（这里[t]代表不大于t的最大整数）。

对比b和p的系数，得x1=y2，y1=x2-[b/p]×y2。这里我们就得到了一个递推式。而由特解x0、y0，我们便可递归得出答案。

```
  #include <iostream>
  #include <cstdio>
  #include <cstring>
  #include <algorithm>
  #define mod 19260817
  using namespace std;
  long long a,b,x,y;
  inline long long readi()//读入优化，目的在于可以不停取模避免高精度
  {
      char c=getchar();
      long long t=0;
      while(c<'0' || c>'9') c=getchar();
      while(c>='0' && c<='9')
      {
          t=(t*10+c-'0')%mod;
          c=getchar();
      }
      return t;
  }
  void exgcd(long long x,long long y)//扩欧算法，类似辗转相除，用了全局变量代替函数里的&
  {
      if(!y)//那组特解
      {
          a=1;
          b=0;
          return;
      }
      exgcd(y,x%y);//递归求解
      long long k=a;
      a=b;
      b=k-(x/y)*b;
      return;
  }
  int main(){
      x=readi();
      y=readi();
      if(y==0)
      {
          printf("Angry!");
          return 0;
      }
      exgcd(y,mod);
      y=(a+mod)%mod;//避免负值
      printf("%lld",(x%mod*y%mod)%mod);//疯狂取模
      return 0;
  }

```
