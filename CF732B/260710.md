一道贪心题

# 思路：

首先我们可以知道，要想让相邻两个数的和不小于 `k`，而又要求增加数值之和最小，

那么最优的方案当然是是每相邻两个数的和正好等于 `k` 。

做到这一点的最简单的方法当然是贪心了。

我们可以把两个数的和加起来，然后与 `k` 比较：

* 如果比 `k` 小，那么在两个数中的第二个数加上和与 `k` 的差。

* 如果比 `k` 大，那么就不做任何改变。

可以用 `ans` 来记录需要增加数值之和，用 `d` 来记录两个数之和与 `k` 的差。

## 贪心思路解释：

#### 考虑当前情况：

两个数的和必须要大于等于 `k` ，增加数值之和要最小；

最优的方案是相邻两个数恰好等于 `k` 。

在为两数加和时，加上的数为两个数之和与 `k` 的差，

* 如果为第一个数加和，那么这个数的值改变后不对下一对数的和有任何改变（无贡献）。

* 如果为第二个数加和，那么这个数将作为下一对数的第一个数（有贡献）。

显然，为第二个数加和可以使下一对数增加的数值更小，

故为第二个数加和最优。

# 几点注意：

1. 如果 `d` 为负数，说明两个数的和已经超过了 `k`，此时不需要再讲这个负数加入 `ans` 。

2. 如果 `d` 为负数，那这两个数的值就不必改变，不要把这个负值加到第二个数中。

## 代码：

```
#include <iostream>
#include <cstdio>
#include <cstring>
#define MAXN 501
#define F1(i, a, b) for (int i = a; i <= b; ++i) // 懒人必备。
#define F2(i, a, b) for (int i = a; i >= b; --i)
using namespace std;

int f[MAXN]; // f 数组用来存数列的各个数。

int main() {
	int n, k, d, ans = 0;
	scanf("%d %d", &n, &k);
	F1(i, 1, n) scanf("%d", &f[i]);
	F1(i, 2, n) { // 因为从第二个数加起（第一对数的第二个数），所以从 2 开始循环。
		d = k - f[i - 1] - f[i];
		if (d >= 0) ans += d; // 注意第一条。
		if (d >= 0) f[i] += d; // 注意第二条。
	}
	printf("%d\n", ans);
	F1(i, 1, n) printf("%d ", f[i]);
	return 0;
}
```