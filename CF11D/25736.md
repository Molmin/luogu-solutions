# A Simple Task

## 1.题目描述：

​	给定一个包含$n (n \leq 19)$个点的**简单图**，求这个图中包含的 **简单环（重边构成的二元环不算）**的个数。

- 限制： 2$s$ + 256$MB$.

## 2.解法：

​	考虑状压DP.

​	$f[k][i]$表示当前点为$i$，前面经过的点的状态为$k$的简单路径的条数。

​	注意到**环1，2，3**和**环3，1，2**是同一个环。为了防止这种情况的重复计算，我们重新规定，$f[k][i]$表示当前点为$i$，前面经过的点得状态为$k$，**且经过的的第一个点是经过的所有点中编号最小的一个**的简单路径的条数。

​	我们枚举$i$直接相连的点$j$，如果$j$的编号比前面经过的最小的编号还要小，那么这个$j$是非法的，因为在我们的规定中，$j$不是第一个经过的点，那么它的编号就不能是最小的。

​	如果点$j$是一个还没有经过过的点，那么就可以直接状态转移，往前推一步：
$$
f[k | (1 << j)] = f[k|(1 << j)] + f[k][i]
$$
​	如果点$j$是一个已经经过过的点，那么就会有两种情况：

- $j$是状态$k$中第一个经过的点：

  那么这种情况下就构成了一个环，直接将$ans$加上$f[k][i]$.

- $j$不是状态$k$中第一个经过的点：

  这个时候我们什么操作都不做。因为当前环对答案的贡献会在第一种情况中处理，如果我们现在再加，就会出现一个环重复产生贡献的错误。

​    **最后注意**，我们的这种做法会把重边构成的二元环算进去，同时会把二元以上的环的贡献算两次（顺时针一次，逆时针一次），所以最后需要对答案进行处理。



## 3.代码

```cpp
#include<iostream>
#include<cstdio>

using namespace std;

const int maxn = 1e2 + 5;
int n,m,x,y;
int first[maxn],last[maxn],dx[maxn << 1],nxt[maxn << 1],xb;
long long f[1 << 20][20],cnt; //注意答案很大，这里要用long long.

void build(int x,int y) {
	dx[++xb] = y;
	if (!first[x])
		first[x] = xb; else
		nxt[last[x]] = xb;
	last[x] = xb;	
}

int main() {
	scanf("%d%d",&n,&m);
	for (int i=1; i<=m; i++) {
		scanf("%d%d",&x,&y);
		x--;
		y--;
		build(x,y);
		build(y,x);
	}
	for (int i=0; i<n; i++)
		f[1 << i][i] = 1;   //初始化
		
	for (int k=1; k < (1 << n); ++k)
		for (int i=0; i<n; ++i) {
			if (!f[k][i])
				continue;        //如果这种状态不存在，就跳过。
			for (int j=first[i]; j; j = nxt[j]) {
				int y = dx[j];   //枚举与i直接相连的点y
				if ((k & (-k)) > (1 << y))
					continue;   //枚举到的y不合法
				if (k & (1 << y)) {    //如果点y是一个经过过的点
					if ((k & (-k)) == (1 << y))  
						cnt += f[k][i];  //第一种情况，y是第一个经过的点
				} else
					f[k | (1 << y)][y] += f[k][i]; //y没有经过过，直接转移
			}
		}
	printf("%lld\n",(cnt - m) / 2); //最后对答案的处理
	return 0;
}
```



  
