## P7472 [NOI Online 2021 入门组] 吃豆人（民间数据）

### 题目

传送门：https://www.luogu.com.cn/problem/P7472

### 题意分析

给定一个 $n \times n$ 的矩阵，需要在这个矩阵中找到两个斜向的矩阵使得它们边上的权值和最大。

### 分析

其实我一开始看到这道题就想到了做法，可惜当时手慢了点，没交上去，所以……

首先分析题目，需要找到两个矩阵边上的数字和最大，所以我们可以用很多办法。

#### [Way1] 暴力判断（期望得分：30pts）

$ n \le 3 $ 的数据规模并不大，所以我们可以挨个枚举 $n = 1$ ， $n = 2$ ， $n=3$ 的时候的所有情况，仅需要在草稿纸上将每一个情况画出来进行小的比较而已。

此种做法很简单，基本人人都会，所以在想不出什么思路的时候，可以优先将这种思路的代码写出来，拿到30pts。

#### [Way2] 暴力模拟（期望得分：60pts）

可能只需要稍微一想，我们就可以知道一种比较简单的方法，依次枚举吃豆人的位置 $(i,j)$ ，然后按题目模拟行走的过程，过程中可以使用一个 $flag_{i,j}$ 数组进行标记走过的路，以达到去重的目的。

当然，依次枚举每一个点的话每一个吃豆人都有 $n^2$ 个出发点，所以时间复杂度大约是 $O(n^4)$ ，所以我们还可以对此办法进行一个小优化。

观察一下就可以发现，对于在同一斜线上的点，吃豆人所走的路线都是相同的，所以我们可以在此基础上进行优化，对于每一个吃豆人我们都有 $n$ 种路线来走，然后模拟走过的路线，时间复杂度大约是 $O(n^3)$。但是也不能达到100pts的标准。

#### [Way3] 提前计算最后枚举每一种情况（期望得分：100pts）

在刚刚的[Way2]中已经提到，对于一条斜线上的出发点，吃豆人走过的路线是相同的，所以说我们可以在输入的时候就进行计算，将每一种路线可以得到的豆子总数记录下来，最后再枚举进行比较。计算需要枚举每一种可能的路径，时间复杂度为 $O(n)$ ，枚举两个吃豆人的出发点，对于每个吃豆人，都有 $n$ 种出发的位置，所以时间复杂度为 $O(n^2)$ ，足以胜任题目所要求的 $n \le 1000$ 的数据量。

为了计算矩阵的总和，我采用了一种方法，就是在输入时就将每一个斜线上的值的和计算出来，在计算矩阵边上权值和的时候就可以将构成边的四条斜线的和加起来减去重叠的 $4$ 个顶点的值。

问题来了，我们计算出了每一个矩阵的总和，但是两个矩阵难免会有交点，所以我们还需要计算交点，减去交点的值，才能得到我们想要的值。

但是怎么样求到这最多四个的交点呢？

我采用了平面直角坐标系的思想。

假设有一个平面直角坐标系，将这个矩阵放置在其中，我们将这个矩阵的第一行定义为 $x=1$ ，第一列定义为 $y=1$ ，所以我们就可以将矩阵中每个点的坐标都表示出来。

![](https://cdn.luogu.com.cn/upload/image_hosting/1axaad1b.png)

首先看第一个点， 也就是图中 $(2,2)$ 的那个交点，我们应该怎么求到它呢？

我们已知两个矩阵在第一行的顶点坐标分别为 $(1,1)$ 和 $(1,3)$ ，所以我们可以推导出，这个交点的 $x$ 坐标与这两个顶点的中点坐标相同。根据中点坐标公式 $(\frac{x_1+x_2}{2},\frac{y_1+y_2}{2})$ 我们就可以知道交点的 $x$ 坐标为 $\frac{x_1+x_2}{2}=\frac{1+3}{2}=2$ ，然后再来推 $y$ 坐标，不难发现， $y$ 坐标的值就等于 $1$ 加上顶点的中点与其中一个顶点的距离，也就是 $1+(2-1)=2$ ，就这样得到了第一个交点的坐标为 $(\frac{x_1+x_2}{2},\frac{x_2-x_1}{2}+1)$ ，同理，即可求出其它交点坐标的值。

当然，也可以利用交点之间的对称性来求得其余的交点坐标。当我们求出交点坐标时，基本这道题也没什么难度了。还需要注意一点就是，当 $x_2-x_1$ 为奇数的时候，这是两个矩形没有交点，我们就不需要减去重叠部分。对于 $x_2-x_1$ 为偶数的时候，也得进行分类，分别判断当哪些交点重合时，应该减去多少重叠的部分，以免减去过多的重叠，导致计算值变小。


### Code[Way3]

~~~c++
#include<cstdio>
#include<iostream>
#include<cstring>
#include<cmath>
#include<algorithm>
using namespace std;
int n,a[1005][1005],sum1[1005][1005],sum2[1005][1005],sum3[1005];
//n为这个矩阵的边长，a表示每个点上的权值，sum1为自左上向右下斜线的权值和，sum2为自右上向左下斜线的权值和，sum3表示计算出的每个矩阵边上的权值和
int main()
{
    scanf("%d",&n);
    for (int i=1;i<=n;i++)
    {
        for (int j=1;j<=n;j++)
        {
            scanf("%d",&a[i][j]);
            sum1[i][j]=sum1[i-1][j-1]+a[i][j];//计算斜线的权值和，计算方法类似前缀和
            sum2[i][j]=sum2[i-1][j+1]+a[i][j];
        }
    }
    //输入
    for (int i=1;i<=n;i++)
    {
        if (i==1 || i==n)//判断为对角线的情况
        {
            if (i==1)
                sum3[i]=sum1[n][n];
            else
                sum3[i]=sum2[n][1];
        }
        else
            sum3[i]=sum1[n][n-i+1]+sum1[n-i+1][n]+sum2[i][1]+sum2[n][n-i+1]-a[1][i]-a[i][1]-a[n-i+1][n]-a[n][n-i+1];//找到矩阵四条边的权值和加起来减去重叠部分计算矩阵边上的权值和
    }
    //计算矩阵
    int ans=-1;//准备寻找答案，因为答案一定为正整数所以将ans初值赋为-1
    for (int i=1;i<=n;i++)//枚举第一个吃豆人的起点
    {
        for (int j=i+1;j<=n;j++)//枚举第二个吃豆人的起点，避免重复所以从i+1开始枚举
        {
            int t;//暂时存放计算结果
            if ((j-i)%2==0)//当顶点横坐标差为偶数的时候
            {
                int x1=1+(j-i)/2,y1=(i+j)/2;//第一个交点
                int x2=y1,y2=x1;//第二个交点（利用对称性）
                int x3=n-y1+1,y3=n-x1+1;//第三个交点
                int x4=y3,y4=x3;//第四个
                if (x1==x2 && x2==x3 && x3==x4)
                    //当两个都是对角线的情况，也就是四个交点都重合的时候
                    t=sum3[i]+sum3[j]-a[x1][y1];//只需减去唯一一个交点
                else if (x1==x2 && x3==x4 && x1!=x3)
                    //当有两个交点时，分别判断是x1与x2相同还是x1与x3相同
                    t=sum3[i]+sum3[j]-a[x1][y1]-a[x3][y3];//减去两个交点
                else if (x1==x3 && x2==x4 && x1!=x2)
                    //x1与x3相同
                    t=sum3[i]+sum3[j]-a[x1][y1]-a[x2][y2];//减去两个交点
                else
                    //四个交点都不重合的时候
                    t=sum3[i]+sum3[j]-a[x1][y1]-a[x2][y2]-a[x3][y3]-a[x4][y4];//减去四个交点
            }
            else
            {
                //当顶点横坐标差为奇数时，两个矩形没有交点，这点可以通过画图得出
                t=sum3[i]+sum3[j];//直接加和，不需要去除重叠部分
            }
            ans=max(ans,t);//与已有的最大值比较，找出最大值
        }
    }
    printf("%d\n",ans);//输出
    return 0;//结束
}
~~~

第一次写题解，包容一下…… :D