//很劣质的模拟型解法，对数学好的初学者友善

//做了错误化处理，以防抄袭（但不影响理解）




```cpp
#include<cstdio>
char a[20000],fbi[20000];//a存二进制，fbi存结果，开大点没坏处
void h(int y,int x)//后序输出，这里不会百度“后序遍历”吧
{
    if(y*2<=x)
        h(y*2,x);
    if(y*2+1<=x)
        h(y*2+1,x);
    printf("%c",fbi[y]);
    return;
}
int main()
{
    int n;
    scanf("%d%s",&n,&a);
    int i,m=1,j,k,p,l;//开足变量，后面介绍
    bool y,e;//用于判断01存在
    for(i=0;i<=n;i++) m*=2;//m存fbi树长度2^(n+1)-1，之所以不减一偷懒写法
    j=m/2;//j存当前fbi节点对应二进制树长度，这里预设值2^n全长
    k=1;//k存对应长为j的fbi节点个数，长为全长自然预设1个
    l=0;//l存位置，用于写入fbi树
    n=j;//n存二进制树长度
    for(i=1;i<=k;i++)//处理对应长为j二进制数的fbi节点
    {
        y=0;
        e=0;//标记归零
        l++;//处理下一个节点，l递增
        p=i-1;
        for(p*=j;p<i*j;p++)//对该二进制数遍历，确定0,1存在性
        {
            if(a[p]=='0')    y=1;
            if(a[p]=='1')    e=1;
            if(y&&e)    break;//防止大数tle，实际上从子节点反向推直接避免这一问题
```
/\*即
子节点为I,I->父节点I

等共九种情况\*/

```cpp
        }
        if(y&&e)//根据遍历结果写入
            fbi[l]='F';
        if(y&&!e)
            fbi[l]='B';
        if(!y&&e)
            fbi[l]='I';
        if(l<m)//处理完毕对应长为j二进制数的fbi节点，若j可以更短处理下一j的值
                    //这里判断语句有多种写法，读者不妨一一尝试
        {
            k*=2;
            j/=2;
            i=0;
        }
    }
    h(1,m);
    return 0;
}
```