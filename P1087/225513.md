#### 题解区的一股~~泥石流~~清流
看着dalao们的递归算法，本蒟蒻瑟瑟发抖。于是我决定另辟蹊径（其实是用不来递归），用萌新们喜闻乐见的暴力加二维矩阵来解。却卡在了后续遍历,在同机房dalao的指点下，~~与无数头发的祭献~~，我成功模拟了树的后序遍历。

------------
总结一下我的思路，就是暴力的在二维矩阵中建立出树，然后模拟后序遍历。

------------
暴力建树
```
for(int i=0;i<n1;i++)
	{
		k=0;
		for(int j=0;j<n;j+=2)
		{
			if(a[j][i]!=a[j+1][i])
			{
				a[k][i+1]='F';
				k++;
			}
			if(a[j][i]=='B'&&a[j+1][i]=='B')
			{
				a[k][i+1]='B';
				k++;
			}
			if(a[j][i]=='I'&&a[j+1][i]=='I')
			{
				a[k][i+1]='I';
				k++;
			}
			if(a[j][i]=='F'&&a[j+1][i]=='F')
			{
				a[k][i+1]='F';
				k++;
			}
		}
		n/=2;
	}
```
n1为输入的n，n为2的n1次方。大家应该发现‘B’与‘B’结合还是‘B’，‘I’与'I结合还是‘I’，两个不同或有一个是‘F’结合后是‘F’。因此，我的思路为，先将输入的数字转换为‘B’和‘I’，然后将第一层两两分开，暴力求出下一层，然后存入矩阵。

------------
本思路的难点在模拟后序遍历输出。
```
for(int i=0;i<n2;i++)
	{
		cout<<a[i][0];
		g[0]++;
		for(int j=0;j<n1;j++)
		{
			if(g[j]%2==0&&g[j]!=0&&v[g[j]/2-1][j+1]==0)
			{
				g[j+1]++;
				cout<<a[g[j]/2-1][j+1];
				v[g[j]/2-1][j+1]=1;
			}
		}
	}
```
从第一层起一个个输出，用g数组存模拟每一层处理到的数。第一层每输出一个，就扫描每一层有没有处理到逢二的元素，有的话下一层处理的数加1，并输出与这个元素对应的下一层的元素。注意一定要用v数组来记录已经输出的数，不然会重复输出，这非常重要（我才不会告诉你我是在吃午饭时恍然大悟的）。

------------
接下来上完整代码
```
#include<bits/stdc++.h>
using namespace std;
int n1,n=1,k=0;
string a1;
char a[1050][15];
bool v[1050][15];
int g[15];
int main()
{
	cin>>n1;
	cin>>a1;
	for(int i=0;i<n1;i++)n*=2;
	for(int i=0;i<n;i++)
	{
		if(a1[i]=='1')a[i][0]='I';
		if(a1[i]=='0')a[i][0]='B';
	}
	int n2=n;
	for(int i=0;i<n1;i++)
	{
		k=0;
		for(int j=0;j<n;j+=2)
		{
			if(a[j][i]!=a[j+1][i])
			{
				a[k][i+1]='F';
				k++;
			}
			if(a[j][i]=='B'&&a[j+1][i]=='B')
			{
				a[k][i+1]='B';
				k++;
			}
			if(a[j][i]=='I'&&a[j+1][i]=='I')
			{
				a[k][i+1]='I';
				k++;
			}
			if(a[j][i]=='F'&&a[j+1][i]=='F')
			{
				a[k][i+1]='F';
				k++;
			}
		}
		n/=2;
	}
	k=0;
	for(int i=0;i<n2;i++)
	{
		cout<<a[i][0];
		g[0]++;
		for(int j=0;j<n1;j++)
		{
			if(g[j]%2==0&&g[j]!=0&&v[g[j]/2-1][j+1]==0)
			{
				g[j+1]++;
				cout<<a[g[j]/2-1][j+1];
				v[g[j]/2-1][j+1]=1;
			}
		}
	}
}
```
