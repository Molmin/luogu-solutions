好多大佬都是边算边输出，然而我太弱了，只好分开做。

**我这个思路有点像——**

## 线段树

~~是不是很奇葩？~~

方法：

1.定义一个数组(a)记录每个节点的状态，0表示B，1表示I，2表示F；

2.读入应该读数组最底层 $2^{n}$到$2^{n+1}-1$，然后从$2^n-1$到$0$依次一层一层遍历；

3.输出从1往后遍历，到最底层就输出，左右子节点都遍历完了也输出。

提示：位运算节省大量时间，代码中1<<n相当于$2^{n}$，i<<1相当于2i，i<<1|1相当于2i+1

如果还没懂，请看下面的超短代码：

```cpp
#include<cstdio>
using namespace std;
int a[5000],n,s[3]={'B','I','F'};//打表输出
char c;//下面输入用
void dfs(int fa){//递归输出，建议先看main函数
	if(fa>=(1<<n)){//边界条件：如果到底层
		printf("%c",s[a[fa]]);//输出
		return;//直接返回
	}
	dfs(fa<<1);//遍历左子节点
	dfs(fa<<1|1);//遍历右子节点
	printf("%c",s[a[fa]]);//输出此节点
}
int main(){
	scanf("%d\n",&n);
	for(int i=(1<<n);i<(1<<(n+1));i++){
		scanf("%c",&c);//必须用字符输入
		a[i]=c-'0';//转换成树并存进数组
	}
	for(int i=(1<<n)-1;i>0;i--){//往根节点遍历
	    if(a[i<<1]==a[i<<1|1]) a[i]=a[i<<1];//只有都为0或1时不是2
		else a[i]=2;//否则都是2
	}
	dfs(1);//输出
	return 0;//华丽结束
}
```