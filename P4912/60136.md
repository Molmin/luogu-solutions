昨天被这道题吓到了，于是就没有做，今天仔细看看发现确实昨天想的不对，因为数据中会有负数，我们先考虑没有负数的情况

很容易想出来一个 DP 的方案，大概是 $(n^2m)$ 的复杂度。

$f[i][j]$ 表示长度为 $j$ 并且最后一个魔法为 $i$ 的最大威力。

因为只能按照顺序释放魔法，可以得出下面的转移过程

```cpp
	for(int i=1;i<=n;i++){
    	for(int j=0;j<i;j++){
        	for(int k=0;k<=m;k++){
            	//balabala一顿转移
            }
		}
    }
```

但是这道题坑啊，它有负数啊

最最最起码数组是可能会负的啊

所以我们将数组整体移一个数

然后我们发现枚举长度的时候似乎有那么一点点问题

我们预处理出来最长可能长度和最短可能长度进行转移

然后似乎我们就把做法口胡出来了

其实把跟上面差不多，就是加上了我说的那些东西

还有就是数组赋值的时候小一点，因为答案可能会负啊

转移方程大概是这样的

```cpp
	memset(f,0x8f,sizeof(f));
	f[0][p]=0;//p是整体移动的那个数
	for(int i=1;i<=n;i++){//接下来释放哪个法术
		for(int j=0;j<i;j++){//由哪一个法术释放过来
			for(int k=minn;k<=maxn;k++){//minn,maxn是最短，最长的可能长度
				if(f[j][k]!=inf) f[i][k+a[i]]=max(f[i][k+a[i]],f[j][k]+b[i]+w[j][i]);//转移
			}
		}
	}
```

统计答案的时候枚举最后释放的法术，就好了。

还是注意 $ans$ 初始化要小一点





























