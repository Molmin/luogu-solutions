[题目传送门](https://www.luogu.com.cn/problem/CF569B)

题意
-
~~这题是真的水~~，题目给你从 $1$ 到 $n$ 共 $n$ 个不重复的编号（推理得），要求以最小的修改次数使其成为一个从 $1$ 到 $n$ 的排列，并输出这个排列。

**思路**
-
重要的事情说三遍:大模拟！大模拟！大模拟！显然，对于 $1$ 到 $n$ 中哪些只出现了 $1$ 次的数，可以直接输出。所以可以用一个数组存储编号，再用布尔数组标记编号是否出现过。而对于超过 $1$ 次的哪些，应当只输出 $1$ 次。如有不符合的标记为 $0$。代码里有说

剩下的看代码和注释吧！

**CODE**
```cpp
#include <bits/stdc++.h>
using namespace std;
int n,a[100001],pos=0;//pos为编号
bool b[100001];
//如上所说两个数组
int main(){
    cin>>n;
    for(int i=1;i<=n;++i){
        cin>>a[i];//输入
        if(b[a[i]]||a[i]>n)//判定条件，左边为出现过的，右边为编号大于n的，即不符合的
            a[i] = 0;//全部标记为0
        if(a[i]<=n)
            b[a[i]]=true;//枚举满足条件
    }
    for(int i=1;i<=n;++i){
        while(b[pos])
            ++pos;
        if(!a[i]) 
            a[i]=pos,b[pos]=1;//核心部分
    }
    for(int i=1;i<=n;++i) 
        cout<<a[i]<<' ';
    return 0;
}
```
求过！