### 题目意思
给你一个长度为 $n$ 的数组 $a$，满足数组 $1 \le a_i \le n$，要求使数组的数成为 $1$ 到 $n$ 的数中的一个并且两两不相同，输出修改后的数组（每个数中间用空格隔开。）。

满足 $1 \le n \le 10^5$ 且 $1 \le a_i \le 100000$。
### 题目思路
PS：
+ 我们输出一个最简单的解即可。
+ 这道题似乎没有用 set 的题解，我来发一篇。
+ 在洛谷上提交老是 UKE，这里我发一下 CodeForces 上的记录。

进入正题，可以看到数据范围比较小，所以可以用数组记录当前的数是否出现过，在根据题目要求对原数组进行赋值即可。可以将不符合要求的数进行特殊标记，最后将没有出现过的数赋值给不符合要求的数，就解决了。

这道题如果直接做的话会超时，所以我们可以用 STL 优化，很多大佬都用了队列，我这里用一下 set，完全不会超时。

具体操作是：第一步，我们将所有数插入 set，方便我们赋值操作。第二步，我们遍历一次数组，对于每个数，用数组计数判断这个数是否是第一个出现。如果已经出现，就在 set 里面删除掉这个数，并对这个数进行特殊的标记。最后一步，我们把特殊标记的数变成没有出现过的数，我们的答案就好了。
### 细节
+ 我们需要用快读函数进行优化，否则数据会让你超时。
+ 在使用 set 时，访问具体的数要在前面加上星号，这样才能访问到具体的数，而不是访问到地址，从而导致程序错误。

[保证代码正确](https://codeforces.com/problemset/submission/569/198892998)
### AC的代码
```cpp
#include<bits/stdc++.h>
using namespace std;
long long n;
int a[100005],b[100005];
set<int>se;
int main()
{
	scanf("%lld",&n);
	for(int i=1; i<=n; i++)se.insert(i);
	for(int i=1; i<=n; i++)
	{
		scanf("%d",&a[i]);
		if(b[a[i]]==0&&a[i]<=n&&a[i]>=1)
		{
			b[a[i]]=1;
			se.erase(a[i]);
			continue;
		}
		a[i]=-1;
	}
	for(int i=1; i<=n; i++)
	{
		if(a[i]==-1)
		{
			a[i]=(*se.begin());
			se.erase(*se.begin());
		}
	}
	for(int i=1; i<=n; i++)printf("%d ",a[i]);
	return 0;
}
```