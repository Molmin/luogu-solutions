这是本蒟蒻第三十次写的题解，如有错误点请好心指出！

## 问题简述

有一个长度为 $n$ 的序列 $a$，你可以给数 $a_i(1 \le i \le n)$ 加或减一次 $1$，问最少要加或减多少次 $1$ 使得至少有 $m$ 个 $i(3 \le i \le n)$ 满足 $a_1 \le a_i \le a_n$。

## 解法综述

根据题意，很容易就想到贪心，要想让尽可能多的数的值在 $a_1$ 到 $a_2$ 之间，就一定要让 $a_1$ 尽可能小或让 $a_2$ 尽可能大，即让 $a_1$ 到 $a_2$ 之间的范围变得更大以便容纳更多的数。

根据上述贪心策略，将 $a_3$ 至 $a_n$ 从小到大排序，对于长度为 $m$ 的区间 $[i,i+m-1]$，发现有以下四种情况：

1. 若 $a_1 \le a_i$ 且 $a_2 \ge a_{i+m-1}$，说明目前已经有 $m$ 个数在 $a_1$ 至 $a_2$ 范围内，则不需要做加或减。

2. 否则，若 $a_1 \le a_i$，说明目前 $a_2$ 的值不够大，最少需要让 $a_2$ 加上 $a_{i+m-1}-a_2$ 次 $1$ 才能满足题目要求。

3. 否则，若 $a_2 \ge a_{i+m-1}$，说明目前 $a_1$ 的值不够小，最少需要让 $a_1$ 减去 $a_1-a_i$ 次 $1$ 才能满足题目要求。

4. 若上述情况都不符合，说明要同时改变 $a_1$ 和 $a_2$ 的值，即让 $a_1$ 减去 $a_1-a_i$ 且让 $a_2$ 加上 $a_{i+m-1}-a_2$ 才能满足题目要求。

根据上述情况输出最少次数即可。

## 代码描述
```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
long long n,m,a[200005],ll,rr,ans=1e18;
int main()
{
	scanf("%lld%lld",&n,&m);
	for(int i=1;i<=n;i++) scanf("%lld",&a[i]);
	stable_sort(a+3,a+n+1);//从小到大排序
	for(int i=3;i<=n-m+1;i++)
	if(a[1]<=a[i]&&a[2]>=a[i+m-1]) ans=0;//说明目前已经有m个数在范围内，不需要做加或减
	else if(a[1]<=a[i]) ans=min(ans,a[i+m-1]-a[2]);//说明目前a[2]的值不够大，最少需要让a[2]加上a[i+m-1]-a[2]才能满足题目要求
	else if(a[2]>=a[i+m-1]) ans=min(ans,a[1]-a[i]);//说明目前a[1]的值不够小，最少需要让a[1]减去a[1]-a[i]才能满足题目要求
	else ans=min(ans,a[1]-a[i]+a[i+m-1]-a[2]);//说明要同时改变a[1]和a[2]的值，即让a[1]减去a[1]-a[i]且让a[2]加上a[i+m-1]-a[2]才能满足题目要求
	printf("%lld",ans);
	return 0;
}
```