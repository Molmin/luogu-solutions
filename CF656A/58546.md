~~打表是我们应该做的吗？~~

~~肯定是公式啊~~

因为题目说了算到$13$的时候进位错了，所以从$13$开始每个数都比原来的数少了$2^{n-13}\times100$。这个算一下就可以知道的了

所以我们就可以推出公式了

代码：
```
#include<bits/stdc++.h>
main(long long n){std::cin>>n;std::cout<<(long long)pow(2,n)-(1<<n-11)*25*(n>12);}
```
当然这是压过行的（废话），下面说一下公式的作用
```
#include<bits/stdc++.h>//包含输入输出流和pow函数 
main(long long n){//把变量定在这里可以少一个分号，对于C++11可以把main前的int省掉，但是会开警告 
	std::cin>>n;//这个比scanf短 
	std::cout<<(long long)pow(2,n)-(1<<n-11)*25*(n>12);
	/*
	先看(long long)pow(2,n)这部分
	你可能会问我为什么不用(1<<n)来代替呢
	因为如果n大于31，就会变成0(这返回应该是int类型的)
	所以用这个可以先算出2的n次方
	
	再看(1<<n-11)*25*(n>12)
	其实原本应该是(1<<n-13)*100*(n>12)的（看上面的公式 
	但是这样会短一点
	这个式子的意思就是算出2的n-13次方（代码中的(1<<n-13)，而且他是不会超过int的
	然后乘上100
	减号后面有一个(n>12)，意为当n>12时为1，否则为0
	也就是说这个式子要当n>=13时才有效
	然后100=5*5*2*2
	所以就可以变成(1<<n-13)*2*2*25*(n>12)
	也就是(1<<n-11)*25*(n>12) 
	*/
}
```

再来一波打表的$Python2$：
```
print[1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8092,16184,32368,64736,129472,258944,517888,1035776,2071552,4143104,8286208,16572416,33144832,66289664,132579328,265158656,530317312,1060634624,2121269248,4242538496,8485076992,16970153984,33940307968][input()]#input一个数，输出表里第n个，注意表是从零开始的
```