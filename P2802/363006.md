## dfs 不懂怎么过的看这

本题解乃是用 dfs 做的时间复杂度最低的题解，时间复杂度： $O(n^4)$。

基础模板大家应该都会写，这里主讲优化。

## 优化

楼上的题解都是用的三维的数组来优化，而我是用的四维，具体请看：

定义 bool 数组 vis，四个维度分别为当前的行坐标，当前的列坐标，当前的血量，以及当前的步数。

为什么怎么定，因为不管在哪种情况下，这个 vis 数组的每个位置都是唯一的，一旦重复出现，后面就会做一样的情况，这点可以自己思考。

那么，它需要回溯吗？不需要，因为同一种情况只能出现一次，如果有重复出现，可以直接 return 掉，因为后面做过的操作，前面已经做过了。

下一步，第四个维度：步数。为什么说步数难，因为这道题题目说明可以走回头路，而以上题解都说的不够准确，因为步数**不一定**小于格子数量。但是，由于数据小，步数肯定在 $100$ 步以内，所以，第四个维度的大小要设为 $105$ 不然就会数组越界。

另外，个人建议把血量和步数当个参数，会更方便。

## 代码

理清思路，代码就出来了：

```cpp
#include<bits/stdc++.h>
using namespace std;

bool vis[15][15][7][105];     //搞懂它是什么意思
int n, m, a[15][15], sx, sy, fx, fy, mini = 1e9;
int dx[10] = {0, 0, -1, 1};
int dy[10] = {-1, 1, 0, 0};

void dfs(int x, int y, int xue, int ans){    //个人建议传参
	if(x < 1 || x > n || y < 1 || y > m || a[x][y] == 0 || xue == 0 || ans > 100 || vis[x][y][xue][ans]){     //如果当前这一步不行
		return ;
	}
	vis[x][y][xue][ans] = true;    //此次状态标记为true
	if(a[x][y] == 4){     //回满血
		xue = 6;
	}
	if(x == fx && y == fy){     //到达终点
		mini = min(mini, ans);
		return ;
	}
	for(int i = 0; i < 4; i++){     //4个方向
		dfs(x + dx[i], y + dy[i], xue - 1, ans + 1);
	}
}

int main(){
	cin >> n >> m;
	for(int i = 1; i <= n; i++){
		for(int j = 1; j <= m; j++){
			cin >> a[i][j];
			if(a[i][j] == 2){    //记录起点和终点
				sx = i;
				sy = j;
			}
			if(a[i][j] == 3){
				fx = i;
				fy = j;
			}
		}
	}
	dfs(sx, sy, 6, 0);
	cout << (mini == 1e9 ? -1 : mini);   //三目运算符，如果mini为1e9，输出-1，否则，输出mini 
	return 0;
}
```

## 最后提醒

1. 用此方法可以 AC 此题，[提交记录](https://www.luogu.com.cn/record/58400680)

2. 此方法名为**状态图遍历**。

3. 模板不会打的看上面几位大佬的代码

4. 证明时间复杂度为： $O(n^4)$，可以证明，此处不过多解释。