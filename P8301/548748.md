# P8301 题解

月赛的题目，可以一眼秒，但有许多值得思考的地方。

### Step 1

此时，我们刚看到题目，想到模拟字符串修改的情况。但是这样非常复杂，我们需要对其进行优化。

### Step 2

我们发现，可以任意排列 $a$。

这也就说明，只要 $a$ 和 $b$ 中的 $0$ 和 $1$ 个数分别相同，这个数列就能不用取反，直接拼凑得成。

我们通过这个理论，进一步推出，只要计算 $a$ 和 $b$ 中的 $0$ 和 $1$ 个数，然后再操作即可。最终答案为 $max(a_0-b_0,a_1-b_1)$，其中 $a_x$ 表示 $a$ 的数位中含有多少个 $x$，$b_x$ 也具有相同意义。对于 $max(a_0-b_0,a_1-b_1)$，是为了避免出现负数的情况。

### Step 3

接着，我们回顾以下刚刚的思路，发现一个有趣的性质：$a_0=n-a_1$ 且 $b_0=n-b_1$，也就是说，我们只需要知道 $a_0$ 和 $b_0$ 即可。最后取 $abs(a_0-b_0)$ 就可以了。

### Step 4

在 Step 3 中，我们知道最终答案为 $abs(a_0-b_0)$，我们再对其进行思考，发现 $a_0-b_0$ 其实可以只用一个变量表示出来。此时，我们记 $s=a_0-b_0$。在读入时，如果遇上 $a$ 串中的 $0$，那么 $s+1$，如果遇上 $b$ 串中的 $0$，那么 $s-1$，最后取 $abs(s)$ 即可。

### Step 5

此时，我们计算时间复杂度：为 $O(n)$，空间复杂度为 $O(1)$ ，可以通过本题。于是，我们可以开始敲代码了。

### Step 6

构造代码。

首先，定义并读入 $n$ 和 $s$，在此不赘述。

其次，我们可以读入两个字符串预处理 $s$。

```
	for(int i=1;i<=n;i++)
	{
		char c;
		cin>>c;
		if(c=='0') s++;
	}
	for(int i=1;i<=n;i++)
	{
		char c;
		cin>>c;
		if(c=='0') s--;
	}
```

最后，我们输出 $abs(s)$ 并返回 $0$ 即可。

### Step 7

我们在构造代码的时候发现，两个部分的读入是非常类似的。我们便可以考虑对其简化：当 $c=0$ 并且 $1 \leq i \leq n$ 的时候，在读入 $a$ 字符串中的 $0$，$s+1$。当 $c=0$ 并且 $n+1 \leq i \leq 2 \times n$ 的时候，在读入 $b$ 字符串中的 $0$,$s-1$。

代码如下：

```
	for(int i=1;i<=2*n;i++)
	{
		char c;
		cin>>c;
		if(c=='0')
			if(i<=n) s++;
			else s--;
	}
```

### Step 8

根据以上提示构造出完整代码并提交即可。