不会 LCT。

子串问题先把 SAM 建出来。

一种很显然的想法是离线下来扫描线，将 $r$ 往右扫，维护每个 $l$ 当前的答案。同时需要维护每个子串最后出现的位置，也就是目前最大的 endpos。

把子串对应到后缀树的结点上。$r$ 往右移相当于在树上加入一个它对应的结点，并把所有的祖先的 endpos 都更新。但是算贡献我们需要先把祖先的贡献减掉，然后把它们的 endpos 更新以后再重新加上。

到根的路径图方便考虑直接树剖。然后考虑怎么算贡献。 

事实上如果我们把每个 endpos 看成一种颜色，每次相当于把当前点到根路径上所有点染成同一种新的颜色，就会形成一个颜色段。

对于每条重链，我们维护其形成的所有颜色段，每次更新的时候，我们暴力把所有经过的颜色段逐个贡献删掉即可，复杂度只和颜色段个数有关。

问题转化为对于某条链上当前 endpos 一样的一段点，算他们对 $l$ 的贡献。但是由于 $minlen_{u}=maxlen_{fa_{u}}+1$，所以显然一条链的贡献是一个大的区间，这样我们每一段的更新都是一个区间加，然后查询是区间求和。

由于每个 $r$ 只会贡献 $O(\log n)$ 个颜色段，所以删除和添加颜色段的复杂度均摊是 $O(\log n)$ 的，每次更新区间加要一个 $\log$，查询要一个 $\log$，所以复杂度为 $O(n\log^2n+m\log n)$。

