### 解题思路

标准 DP 题，统一把**左手**看成**单向边**，就转换成多环计数了（环大小 $\geqslant 3$），有点错排问题的味道。

直接用 $f_{i,\,j}$ 表示已选 $i$ 个点，构成 $j$ 个环的方案数。

怎么构成一个新环呢？要先有个小目标——构造三个点的。转移来的状态是 $f_{i-3,\,j-1}$，新加进去了 $i$ ，$i-1$ 和 $i-2$ 号点，钦定 $i$ 号点是这个环中的“头儿”，也就是说 $i-1$ 和 $i-2$ 号点可以跟之前使用的点交换，所以转移贡献是 $f_{i-3,\,j-1}\times(i-1)\times(i-2)$ 。

但大小为 $3$ 远远不够，我们也可以钦点 $i$ 号点是用来扩充的。转移来的状态是 $f_{i-1,j}$，因为其可以接在前 $i-1$ 个点的任何一个点的后面，所以转移贡献是 $f_{i-1,j}\times(i-1)$ 。

综上，$f_{i,\,j} = f_{i-3,\,j-1}\times(i-1)\times(i-2)+f_{i-1,j}\times(i-1)$ ，设定边界 $f_{0,\,0} = 1$ ，答案状态 $f_{n,\,m}$ 。

---

### 代码实现

真的很短呢 qaq

```cpp
#include <cstdio>

const int maxN = 3005;

int n, m, p, f[maxN][maxN];

int main() {
    scanf("%d%d%d", &n, &m, &p); f[0][0] = 1;
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) { f[i][j] = ((i >= 3 ? f[i - 3][j - 1] * (i - 1ll) % p * (i - 2) % p : 0) + f[i - 1][j] * (i - 1ll)) % p; }
    }
    printf("%d\n", f[n][m]);
    return 0;
}
```