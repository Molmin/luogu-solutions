这一题我的思路如下：

（1）首先把纪念品价格非降序排序；

（2）再找出第一对相邻可以合为一组的纪念品（从最大的开始搜索），将找到的两个纪念品标记；

（3）再向左右两边同时开始搜索，如果可以合为一组，就从继续搜索，否则将左边标记的纪念品和它左边的相邻的纪念品分为一组，左边标记前移，右侧标记不动，如此反复至左边的纪念品没有可用的，剩下的纪念品可以单独成组；（因为想组尽可能少，那么每组的价格尽可能大，那么就使只能单独成组的为数组靠后的较大的纪念品。故一旦左右的标记所指的纪念品不能合为一组时，将左边前面两个合为一组。）

代码如下：

```cpp
#include"stdio.h"
#include"algorithm"
using namespace std;
int a[30001],N,Max;
int main()
{
  int i,j,k = 0; 
  scanf("%d%d",&Max,&N);
  for(i = 0;i < N;i++)
  scanf("%d",&a[i]);
  sort(a,a+N);//操作（1）
  for(i = N-2;i >= 0;i--)//操作(2)
    if(a[i]+a[i+1]<=Max)
     break;
  j = i+1;
   while(i>=0||j<=N-1)//操作（3）
  {
  if(a[i]+a[j]<=Max){i--;j++;k++;}//可以合为一组
   else if(i>=0){i-=2;k++;}//左右两个不能合为一组
   else {k+=N-j;j = N;}//单独成组的 
   }
printf("%d",k);
return 0;
} 
```
