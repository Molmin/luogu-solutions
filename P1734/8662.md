楼下的所有题解都在“吐槽”这道题很水！但是他们忽略（也许是dalao不屑于解释）了题目中一个问题：

数字不允许重复！起先蒟蒻还很奇怪楼下的01背包并没有处理这个问题。

本来以为数据有误，想了想，发现题目中说“不包含它本身”，这意味着，如果选择了两个相同的数字，

设这两个相同的数字为x，那么把这两个数替换成2x更优。

证明如下：由唯一分解定理，不妨设x=(2^k)\*(a1^p1)\*(a2^p2)\*...\*(an^pn)。

其中，对于任意1<=i<j<=n，ai≠aj，且对于任意1<=i<=n，由ai!=2且ai为质数，pi为正整数。k为非负整数。

用F(x)表示x的因数（不包括x）之和。则：

根据公式，有F(x)=(1+2+4+..+2^k)(1+a1+a1^2+...+a1^p1)(1+a2+a2^2+...+a2^p2)...(1+an+an^2+...+an^pn)-x

方便起见，记u=1+2+4+...+2^k，v=(1+a1+a1^2+...+a1^p1)(1+a2+a2^2+...+a2^p2)...(1+an+an^2+...+an^pn).

则F(x)=2uv-2x。因此，2F(x)=uv-2x。

由设，2x=(2^(k+1))\*(a1^p1)\*(a2^p2)\*...\*(an^pn)。

则依定义及公式，有F(2x)=(u+2^(k+1))v-2x=uv+2^(k+1)v-2x。

则F(2x)-2F(x)=[uv+2^(k+1)v-2x]-[2uv-2x]=2^(k+1)v-uv=v[2^(k+1)-u]。

有根据等比数列求和公式，可知u=1+2+4+...+2^k=[2^(k+1)-1]/(2-1)=2^(k+1)-1。

代入上式，得F(2x)-2F(x)=v{2^(k+1)-[2^(k+1)-1]}=v>0；

综上得证：F(2x)>2F(x)；即：若选择选相同的两个数字，将他们替换成他们的和，结果更优（而且是严格更优）。

因此DP的决策中保证了不会选择相同的数字。

然后据说不贴代码会被……所以贴上代码：

还有，一开始写了一个O(n^3)的dp，加了位运算优化min/max后神奇的拯救了我200ms+：

```cpp
#include<iostream>
#include<cstdio>
#define min(x,y) ((y)^(((x)^(y))&(-((x)<(y)))))
#define max(x,y) ((x)^(((x)^(y))&(-((x)<(y)))))
using namespace std;
int dp[1010];
//dp[s]=max{dp[s-k]+sol[k]}
//1<=k<=s<=S
int sol[1010];
int main()
{
    int S;scanf("%d",&S);
    for(int i=1;i<=S;i++)
        for(int j=i*2;j<=S;j+=i)
            sol[j]+=i;
    for(int s=2;s<=S;s++)
        for(int k=1;k<=s;k++)
            dp[s]=max(dp[s-k]+sol[k],dp[s]);
    printf("%d\n",dp[S]);return 0;
}
```