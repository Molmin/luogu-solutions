### 运用线性筛的原理+背包一遍就ok了，通过分析题目可以看出，给出的n就是背包容量，因为不能大于n嘛。第i个数的约数和就是第i个数的价值，第i个数的约数和，就是第i个数的大小，标准的01背包~~，具体看代码：
---
```cpp

#include <iostream>
#include <cstdio>
//头文件
using namespace std;

int n,a[10005],f[10005],x;

int main(){

	scanf("%d",&n);
	for(int i = 1; i <= n; ++i){
		//约数和最多到n
		x = i * 2;
        //找出当前i的最小倍数，当前的i，*2后一定是i的最小倍数
---
### 看到楼下很多大佬都是暴力求当前数的约数和，那我就换一种方式，把在i的倍数的约数和（还没求出的约数和）加上i（因为i肯定是它倍数的因子），一遍一遍的找i的倍数，然后在那个位置上加上i就行了，一次更新一遍数组。~~（然而时间看上去好像也差不多...）~~具体见代码：
		while(x <= n){
			a[x] += i;
			x += i; 
		}
---
		x = 0;
	}
	for(int i = 1; i <= n; ++i)
		for(int j = n; j >= i; --j){
        //说是01背包模板，但是循环还是得注意一下的（n既是“物品”个数，也是容积大小）
			if(j - i >= 0)
			f[j] = max(f[j],f[j - i] + a[i]);
            //01背包的状态转移方程
		}
	printf("%d",f[n]);
    //输出最后一个，必定是最优解
	return 0;
}

//最后祝大家AC愉快~