### 题意简述

给定 $N$ 个数的数列 $A$ 和一个整数 $K$。

对于所有长度为 $K$，值域为 $[1,N]$ 的数列 $p$，求出 $\sum _{i=1}^{K} a_{p_i}$ 的异或和。

- $ 1\ \leq\ N\ \leq\ 1000 $
- $ 1\ \leq\ K\ \leq\ 10^{12} $
- $ 0\ \leq\ a_i\ \leq\ 1000 $

### 思路分析
借助生成函数描述题意，即我们需要求出 $\bigoplus S$ ，其中 $[x^S](x^{a_1}+x^{a_2}+…+x^{a_n})^K \bmod 2=1$。设 $K$ 在二进制下分解为 $M$ 位，即 $K=\sum_{i=1}^{M} 2^{k_i}$，我们可以将式子改写成：
$$
[x^S]\prod_{m=1}^{M} (x^{a_1}+x^{a_2}+…+x^{a_n})^{2^{k_m}} \bmod 2 =1
$$

再考虑一个经典式子：
$$
(x_1+x_2+…+x_n)^2\equiv x_1^2+x_2^2+…+x_n^2 (\bmod 2)
$$

反复套用这一式子，我们得到：

$$
(x_1+x_2+…+x_n)^{2^t} \equiv x_1^{2^t}+x_2^{2^t}+…+x_n^{2^t} (\bmod 2)
$$

所以，我们可以将上述式子化为：

$$[x^S]\prod_{m=1}^{M} (x^{a_1 2^{k_m}}+x^{a_2 2^{k_m}}+…+x^{a_n 2^{k_m}}) \bmod 2 =1$$

再将这一式子的含义进行翻译，这相当于我们进行 $M$ 次选择，每次选择 $a$ 中的一个数，设第 $i$ 次选择 $a_{X_i}$，那么我们需要保证有奇数种选择序列使得 $\sum_{m=1}^M a_{X_m}2^{k_m}=S$，此时 $S$ 是一个有效的结果，再将所有的有效答案异或起来即为答案。

考虑怎么完成有效答案异或的过程，我们考察对于每一位，有多少种选择序列使得其最终的 $S$ 在这一位为 $1$。那么，如果有奇数种，那么最终答案在这一位上就是 $1$。我们从小到大考察每一位 $i$，动态统计对于哪些 $S$，构成它们的选择序列种数在这一位上是 $1$。我们直接将 $S$ 抹去后 $i$ 位的结果存在一个集合中，每挪动一位将集合内所有数右移一位，对于每一次选择，我们直接暴力枚举对于每一个存在于集合中的 $S$，其在这一轮选择了哪一个数，然后更新集合。在这里，如果某个 $S$ 的选择序列种数为偶数，显然我们可以直接视为这一个 $S$ 完全没有出现过，这是因为它们对于后续答案产生的贡献一定为 $0$。同时还要注意的是，如果在考察到某一次选择之后，某一位上是 $1$，虽然后续选择都不会改变每一个操作序列导出的 $S$ 在这一位上的值，但是不能忘记每一个操作序列都还会分裂成许许多多个不同的操作序列。设还需经过 $T$ 轮，那么最后它会变成 $N^T$ 种选择序列。因此，答案某一位是 $1$ 的充要条件其实包含两点：1）有奇数种选择序列使得其当前 $S$ 在这一位为 $1$。2） $N^T$ 是奇数。

关于集合大小，容易发现每次更新时只会将集合内已经存在的元素加上一个 $a_i$，而每挪动一位，集合里所有数都会减半。这个过程保证集合内最大值不会超过 $a$ 中最大值的两倍。因此，集合大小与 $N$ 同阶。

时间复杂度 $O(N^2\log K)$，借助 bitset 优化可以降低常数。

### 代码

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
bitset<3000>A,S,T;
signed main(){
	int n,k,a;
	cin>>n>>k;
	for(int i=1;i<=n;i++){
		scanf("%lld",&a);
		A.flip(a);
	}
	int ans=0;
	S[0]=1;
	for(int i=0;i<=60;i++){
		T.reset();
		for(int j=0;j<=2000;j++) if(S[j]) T.flip(j>>1); 
		S=T;
		if(k&1){
			T.reset();
			for(int j=0;j<=2000;j++) if(S[j]) T^=A<<j;
			S=T;
		}
		k>>=1;
		int c=0;
		for(int j=1;j<=2000;j+=2) if(S[j]) c^=1;
		if(c&&((n&1)||(!k))) ans^=1ll<<i;
	}
	cout<<ans;
	return 0;
}

```