为了方便，先将 $p_i$ 排序。

先考虑单次询问怎么做，显然有个状压的 $O(n2^m)$ 的做法，但是我的能力范围内没什么前途，所以正难则反。

考虑容斥，对于一个集合 $S$，钦定这个集合内的特殊点没有被照亮，令 $g(S)$ 表示方案，那么答案为 $(d+1)^n-\sum (-1)^{|S|+1}g(S)$。

考虑怎么求 $g(S)$，发现其实相当于对于 $S$ 内相邻的特殊点，这两个特殊点之间的所有灯不能照到它们，相当于限制了这些灯的最大值，这样就有了一个 $O(n2^m)$ 的做法。进一步地，预处理一个 $mul_{l,r}$ 表示 $[p_l,p_r]$ 的所有灯碰不到特殊点 $p_l$ 和 $p_r$ 的方案数，然后求 $g(S)$ 的时候直接调用即可。复杂度 $O(m^2n+m2^m)$。

考虑多次询问，一种显然的思路是枚举新增的灯的值，但是不需要 $[0,d]$ 逐个枚举，因为它所能影响的本质不同的状态显然只有 $m$ 个。

考虑枚举这个状态，那么相当于需要初始的灯去照亮剩下的特殊点，所以预处理一个 $f_S$ 表示照亮集合内的特殊点的方案数即可，求法和单次询问一样。

复杂度要枚举子集，看似是 $O(3^m)$ 的，但是会发现关心的集合永远是一段前缀和一段后缀，所以关心的集合数也只有 $m^2$ 个，子集暴力枚举都可以了，复杂度 $O(m^22^m)$。

总复杂度为 $O(m^2n+m^22^m+qm)$。

https://codeforces.com/contest/1728/submission/171470230