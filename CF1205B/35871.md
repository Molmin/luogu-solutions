本文同步于[CF1206总题解](https://www.luogu.org/blog/zhouzikai/cf1206round-580-div2-post)，欢迎各路神仙来踩。

## D Shortest Cycle
### 题意
给定长度为$n$的序列$a$，若有$i,j\in [1,n],a_i\ and\ a_j\ne0$，则$i,j$连边，求建出的图的最小环大小，注意，最小环大小至少为3。
### 解法
1. Part 1 优化建图

$n\le 10^5$，我们显然不能直接建图，那么我们有一个大胆的猜测：是不是$n$比较大的时候答案一定是一个定值？

这个猜测先放在这里，我们来考虑位运算的本质：若$x\ and \ y \ne 0$，则一定存在某一个二进制位$k$，满足$x$的第$k$位和$y$的第$k$位都为$1$。

因此我们把建图的过程分解一下，枚举每一个二进制位$k$，设二进制下这一位为$1$的数属于一个可重集合$S$，那么$S$集合中的数**对应的位置**应该**两两**连边。如果这个集合中的数字个数$\ge 3$，则这一个集合的连边中一定出现大小为$3$的环，显然这应该是本题有解情况下的**最小答案，不会再被更新**，因此我们可以确定答案为3。

如果集合中数字个数$\le 1$，这也不需要连边。

如果集合中数字个数$=2$，只需要将这两个点连一条边即可。

因为$a_i\le 10^{18}$，所以讨论的位数应该不超过$64$，每讨论一位，只有集合大小为2的时候要连$1$条无向边，因此最多连$64$条无向边，这个图最多有$128$个结点。

回到我们的猜测，如果$n>128$，我们可以断定必定存在一个集合的数字个数$\ge 3$，因此这时答案一定是3。

2. Part 2 求解最小环

我们建出来的图的规模是$n\le 128,m\le 64$，因此基本上$O(n^3)$或者更优的求最小环的算法都可以过。

无向图上最小环算法大多数基于最短路（主要是我太菜了不会其他的算法），这里做一个小总结，以纪念我的第一次$FST$。

1.  `Floyd`判最小环

算法原理：讨论每两个点$i,j$，求出$i,j$两个点为端点的不同路径长度之和，即为最小环大小，取最小值即可。

因为我们只确定$i,j$还不能确定它们之间的不同路径，所以我们要再引入一个$k$，让一条路径定死了（必须经过$k$），然后找到一条**不经过k**的路径，这两条路径一定构成一个至少有三个点的环。

答案更新应该是$a[i][k]+a[k][j]+dis[k-1][i][j]$（这里$k-1$表示当前的最短路没有被$k$更新，一般写的时候把统计答案放在更新前面即可省去$k-1$这一维，下面同理）

不过蒟蒻的我有一点疑问：为什么不是用$dis[i][k]+dis[k][j]+dis[i][j]$更新答案呢？$dis[i][k]\le a[i][k]$，虽然说用$a[i][k]$更新不会漏掉最优解，但是用$dis[i][k]$更新会出现答案偏小（错误）的情况吗？请各路神仙在评论区发表高见。

2. 基于~~已死的~~`SPFA`求最小环

这里用`dfs`实现比较好理解。
```cpp
void dfs(int x,int fa,int w){
    vis[x]=1;//已求解联通块标记
    dis[x]=dis[fa]+w;
    for(){//枚举边
    	int y=//边的出点
        int w=//边的长度
        if(y==fa)continue;//两个点不构成环
        if(dis[y])ans=min(ans,dis[x]-dis[y]);//有些求最小环需要有微小修改
        else dfs(y,x,w);
    }
    dis[x]=0;//可以重新走到这个节点来更新最小环
}
```

3. 基于`Dijkstra`求最小环

因为笔者太菜了，暂时不会。