（这题的输入格式有误，应该是输入一个正整数 $N$）

首先我们假设 $S<T$，为了不尽量减少步数消耗即不浪费步数，我们应该在向右位移的同时上下移动。于是乎我们可以进行一个初始化操作，使得只要一直想右上方走就可以越过最高障碍。

可以得出初始化的高度应该为 $\max(H_i-(H_S+(i-S)))$，也就是 $\max((H_i-i)-(H_S-S))$。

于是乎我们只需要维护 $H_i-i$ 的最大值就 OK 了。如果是向左移动，只需要把 $S$ 换成 $T$ 即可，维护 $H_j+j$ 的最大值即可。

除此之外，我们还需要统计一下最高点。这里可以使用解决 RMQ 问题的 ST 表，当到达最高点的时候我们就不需要再增加行了。已知水平位移，利用 $T$ 维护从右至左（即向左移动）的 $\max(H_j+j)$，就可以得到答案了。

主体代码如下：

（ST 表部分）

```cpp
for(int i=1;i<=N;i++) cin>>H[i],f[i][0]=H[i],f1[i][0]=H[i]-i,f2[i][0]=H[i]+i;
logg[0]=-1;
for(int i=1;i<=N;i++) logg[i]=logg[i/2]+1;
for(int j=1;j<=20;++j)
	for(int i=1;i+(1<<j)-1<=N;++i)
		f[i][j]=max(f[i][j-1],f[i+(1<<(j-1))][j-1]),f1[i][j]=max(f1[i][j-1],f1[i+(1<<(j-1))][j-1]),f2[i][j]=max(f2[i][j-1],f2[i+(1<<(j-1))][j-1]);
```

（处理部分）

```cpp
maxh=max(f[l][len],f[r-(1<<len)+1][len]);
maxs=max(f1[l][len],f1[r-(1<<len)+1][len]);
maxt=max(f2[l][len],f2[r-(1<<len)+1][len]);
maxs-=H[l]-l;
maxt-=H[r]+r;
if(S>T) swap(maxs,maxt);
```