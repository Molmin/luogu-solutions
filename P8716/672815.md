### 这题一眼看上去，有两种解法

1. 枚举合法日期，判断是否为回文数以及属于哪种回文数。
2. 枚举合法回文数，判断是否为合法日期以及属于哪种回文数。

我们先估算一下时间复杂度：

第一种方案，需要枚举年月日+判断回文数，时间复杂度为  $O(n^3)$。  
注：其实真正的复杂度大约是 $(12 \times 31) n$。

第二种方案，枚举回文数可以枚举一半，另一半转换一下便出来了，只需要判断是否为合法日期。时间复杂度 $O(n)$。

比较一下两种方法的时间复杂度，不难发现第二种方法更快一点，所以我的思路即是第二种思路。

在这一题中，我用变量 $a$ 枚举每一个年份，构造出相对应的年月日（ $y,m,d$ ），判断合法日期不多赘述。通过数字转字符串判断是哪种回文日期，下面给出代码。
________
```cpp
#include<iostream>
using namespace std;
int month[]={
	0,31,28,31,30,31,30,31,31,30,31,30,31
};
string n;
int yr,yr2;
bool run(int n){//判断闰年
	if(n%100==0){
		if(n%400==0)return 1;
	}else if(n%4==0)return 1;
	return 0;
}
int main(){
	cin>>n;
	int a=atoi(n.substr(0,4).c_str());//把前四位字符转为数字
	a++;
	while(1){
		int y=a,m=(((a%10)*10)+a%100/10),d=(((a%1000)/100*10)+(a/1000));//推出年月日
		string A=to_string(a);
		if(m==2){//特判二月
			if(d<=(28+run(y))){//判断日期是否合法
				if(yr==0)printf("%d%.02d%.02d\n",y,m,d),yr=1;//标记已出现并输出，%.02d 自动在不足2位的数前填充 0 以达到二位
				if(yr2==0&&A[0]==A[2]&&A[1]==A[3]&&A[0]!=A[1])printf("%d%.02d%.02d\n",y,m,d),yr2=1; //判断是否属于特殊回文日期，标记已出现并输出
			}
		}else if(m<=12&&m>0){//普通月份，其余同上
			if(d<=month[m]){
				if(yr==0)printf("%d%.02d%.02d\n",y,m,d),yr=1;
				if(yr2==0&&A[0]==A[2]&&A[1]==A[3]&&A[0]!=A[1])printf("%d%.02d%.02d\n",y,m,d),yr2=1;
			}
		}
		a++;//年份++
		if(a>9999||yr&&yr2)return 0;//输出完了就结束程序
	}
}
```

