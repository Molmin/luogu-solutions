方案一：

既然要两个，那就枚举两个，剩下一个随便选，需要 $n^2$ 次，可以得 $30$ 分。

方案二：

显然，分为 $3$ 种情况，$(a,b,?),(a,?,c),(?,b,c)$。

通过对上一个方法进行优化。

假如前两位都填 $a$，那么假如前两位都对了，那么一定可以。

然后用 $(a,a,c)$ 调用 $n$ 次即可，然后再暴力。

假设枚举了 $k$ 次，那么调用次数为 $nk+(n-k)^2$。

展开，得调用次数为：

$$nk+n^2-2nk+k^2$$

$$=n^2-nk+k^2$$

当 $k=\dfrac{n}{2}$ 时该式取最小值 $0.75n^2$。

假如我们讨论情况改成 $(a,b,c)$ 的方式讨论，一次可以避开更多，调用次数进化为 $0.5n^2$ 次，可以 AC 了。

但是能不能更优呢？

某两个三元组之多排除 $n$ 个，而总共需要排除 $n^3$ 个，所以令次数为 $t$，则：

$$\dfrac{2t}{n}\ge n^3$$

$$2t\ge n^2$$

$$t\ge 0.5n^2$$

所以至少 $0.5n^2$ 次。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int main() {
    int n; cin >> n; cout << n * n / 2 << '\n';
    for(int i = 1; i <= n / 2; i++) for(int j = 1; j <= n / 2; j++) printf("%d %d %d\n", i, j, (i + j - 2) % (n / 2) + 1);
    for(int i = 1; i <= n / 2; i++) for(int j = 1; j <= n / 2; j++) printf("%d %d %d\n", i + n / 2, j + n / 2, (i + j - 2) % (n / 2) + 1 + n / 2);
    return 0;
}
```