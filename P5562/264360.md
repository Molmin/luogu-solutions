## 前言

该题使用构造解决，本题解只给出一种理解，构造部分在理解了思考过程变得较为容易，留给读者自行思考。

## 分析

- 对于该题，由于只要求任意两位相同，所以可以用 $n^2$ 次枚举前两位得到部分分。不过显然有三位时，这样做一定不是最优的（见下）。

先给出这样的理解：对于三元组 $(a,b,c)$ 可以覆盖 $(a,b)$，$(a,c)$，$(b,c)$ 的情况。

  由此，给出本题的想法：目标为尽可能不重，一定不漏地利用三元组的性质枚举完所有的二元组。

  这要求对于每个没有询问三元组有 $(i,j_1,k)$，$(i_1,j,k)$ 之中 $\{i_1\} \cup \{j_1\}=[1..n]$。

  此时考虑如上的所有 $\{i_1\}$ 和 $\{j_1\}$ 之中长度最小的一个，不妨是某个 $\{i\}$，其元素个数为 $siz$。

  很容易找到分界 $\frac{n}{2}$:

  若 $siz\geq\frac{n}{2}$，则有枚举次数 $res \geq \frac{n}{2} \cdot n$（这样的 $\{i\}$ 有 $n$ 个）。

  若 $siz \leq \frac{n}{2}$，则考虑其对应的 $\{j\}$，其大小至少为  $n-siz$。若 $\{i\}$ 验证出了 $x$ 个元素，则有 $x \cdot siz + (n-siz)(n-x) = x \cdot n + (n-2x)(n-2siz)$，在 $s=a=\frac{n}{2}$ 时有 $min=\frac{n^2}{2}$。

- 由上便可以得到构造方法，留给读者自行思考（注意取等条件即可）。

- 更容易理解的版本：[官方解答](https://www.luogu.com.cn/blog/137-345-2814/center-of-the-earth-solution)。

## Code

```cpp
#include<cstdio>
int n;
int main(){
    scanf("%d",&n);
    printf("%d\n",n*n/2);
    for(int i=1;i<=n/2;i++)
        for(int j=1;j<=n/2;j++)
            printf("%d %d %d\n",i,j,(i+j-2)%(n/2)+1);
    for(int i=1;i<=n/2;i++)
        for(int j=1;j<=n/2;j++)
            printf("%d %d %d\n",i+n/2,j+n/2,(i+j-2)%(n/2)+1+n/2);
    return 0;
}
```
