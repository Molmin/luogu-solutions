首先这完全是一道白给题，本人使用了归纳法

那么说一下思路

首先定义深度：根节点到叶节点的路径长。

随便画一棵树，观察最深度最深的叶节点，发现好像对于这条路径上的边都不需要修改，因为我们的目标是让其他叶节点深度与它一样，而修改最深叶子节点感觉上不会比不修改结果更优，所以先不动它。

对于比较浅的叶节点，我们需要修改它到根节点的某些边，让它的深度更深。那么改越接近根节点的边越好。因为对于这一个叶节点来说，修改任意一条边或者多条边效果等价；但是对于其他叶节点，如果本次修改顺便修改了它到根节点的路径，那么对于答案的贡献会比分别修改两个叶节点的路径少。

说白了就是如果有一个节点，它有两个子树，那么修改这一个节点上方的边效果等价于修改两个子树的叶节点的深度（使叶节点的深度加大到最大深度），且答案必然比分别改两个子树上的边要好。

所以这时候对于每个节点node定义一个量f(node)，表示这个节点的子树的叶节点的深度与整个树的最大深度的差值的最小值。显然这玩意可以继承。

即
f(node) = min(f(node), f(son(node)));

为什要这个量？
答：归纳法。你画一颗树就明白了，真的。

好吧原因是这个量就是刚刚说的对于一个节点上方修改的最大值。
因为如果超过这个值，对节点上方的边加上后，就会有一些叶节点深度超过最大值，这显然不是我们想要的。

所以既然可以修改了，那么要不要继续传递这个f(node)呢？
答：要。因为修改越靠近根节点越优。

具体什么时候修改呢？
答：不能继承了就修改

这时候假如节点node有两个子节点son1， son2

f(son1) = 3
f(son2) = 5

那么此时f(node) = 3

这里只继承了3，表示未来可能在上面的某条边加3。但观察son2，如果上面加了3，显然不能满足它的需求，因为它需要整体加5才能让深度达到最大深度。

那咋办？

答：在node节点与父节点的连边加2。
为什么这么做？画个图，一目了然。

好了所以我又定义了一个量s，表示一个节点到它父节点的连边所需要的增加的值。

dfs计算s，然后累加每一个节点的s

完事。

唯一注意根节点的s没有意义，因为根节点没有父节点，所以根节点单独处理。