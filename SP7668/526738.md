原题目：

- 给定一个只有 $0$ 和 $1$ 的字符串。可以进行“翻转”操作：对任意一个数位，翻转此数位与后面的所有数位（$0$ 变成 $1$，$1$ 变成 $0$）。求使字符串所有数位全为 $0$ 的最小“翻转”次数。

建议难度：橙。

此题可用贪心解决，策略：从前向后，遇到 $1$ 就翻转。

[贪心证明过程在这。](https://www.luogu.com.cn/paste/cxekou8o)

如：对于字符串 $0100101$。

- 第一位是 $0$，不翻转。字符串：$0100101$；

- 第二位是 $1$，翻转。字符串：$0011010$；

- 第三位**变成了** $1$，翻转。字符串：$0000101$；

继续进行如上操作：

- $0000010$（翻转）；

- $0000001$（翻转）；

- $0000000$（翻转）；

共计翻转了 $5$ 次，答案为 $5$。

以下为 [AC](https://www.luogu.com.cn/record/108331189) 代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
    string a;
    int T=0;
    while(cin>>a){
        T++;
        int ans=0;
        for(int i=0;i<a.length();i++){
            if(a[i]=='1'){
                ans++;
                for(int j=i;j<a.length();j++)
                    a[j]=(a[j]=='1'?'0':'1');//“翻转”操作
            }
        }
        printf("Game #%d: %d\n",T,ans);
    }
    return 0;
}
```

时限只有 250ms，本来以为这代码过不了，结果 AC 了。~~可能是数据有点水？~~

时间复杂度：$\mathcal O(n^2)$。

如果只想 AC，到这就可以走了，不过还有 $\mathcal O(n)$ 的解法。

继续以 $0100101$ 为例。

先将其分段，即可得到 $\red0\blue1\red{00}\blue1\red0\blue1$。

以贪心策略，可以忽略前导 $\red0$。

每次翻转可以将一段 $\blue1$ 变为 $\red0$，如：

- 对第一**段** $\blue1$ 翻转，这一段 $\blue1$ 全部变为了 $\red0$，即得到 $\red{00}\blue{11}\red0\blue1\red0$；

- 再将第二**段** $\blue1$ 翻转，得到 $\red{0000}\blue1\red0\blue1$；

以此类推：

- $\red{00000}\blue1\red0$；

- $\red{000000}\blue1$；

- $\red{0000000}$；

会发现与贪心策略一样，也是进行了 $5$ 次操作。

仔细观察，会发现对每一段都进行了一次“翻转”操作，即**可以将“翻转”操作的次数转移成数字的段数**。

所以题目可以简化为：

- 给定一个只有 $0$ 和 $1$ 的字符串，忽略前导 $0$，求有多少段连续数字。

代码就不贴了，时间复杂度为 $\mathcal O(n)$。