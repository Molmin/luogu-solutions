_捞一下蒟蒻[Blog](https://www.luogu.com.cn/blog/quest233/#)_

_这篇文章重在讲解在切这道题时是如何想到正解的。_

记得有一位巨佬说过，每一道题都是板子套板子套板子套$\cdots \cdots$ ，也就是 $({\color{black}\colorbox{white}{板子}})^K$。

有了这一基础理论，我们就想想什么板子是可以套上这题的。

先来看题意，稍加简化便是这样：

```
有一无向图。
要求加一些边，使得每两个点之间至少有两条边相连。
求最少加边数。
```
`至少有两条边相连`？容易看出这是一道图论题，甚至可以看出是一道**图的连通性专题的图论题**。

说到图的连通性，就必然会想到一个令人膜拜的人物，$\mathbf{Tarjan}$ 。几乎所有的图的连通性题目都和他发明的算法，借助于时间戳的跑强连通分量/桥/割点等等的神仙操作有关。那我们如何运用这些神仙操作完成任务呢？

至少有两条边相连，也就是说，**删去任意两点之间的一条路径后，这两点依然联通**。

删去任意两点之间的一条路径后，这两点依然联通？

我们想起桥的定义：删去两点之间的一条路径后，这两点不再联通。

实在很难不把他们俩想到一块去。

如果把原图中的所有桥都删掉，会留下一些联通块。这些联通块就满足题中说的：两点间至少有两条边相连。

而这种联通块，学名称作**边双联通分量**，可以发现一个规律：边双联通分量中两点之间**不会因为加边而减少整幅图中原有的桥**。

毕竟他们可是在拆桥运动后仍然存活的 ${\color{red}\colorbox{white}{牢不可破的联盟}}$ ，已经没有再加固联盟的必要了。

所以我们要加固的，实则是那些在拆桥运动后，支离破碎的结点。

这一步骤，一样可以用Tarjan算法完成，用类似**Tarjan求强连通分量**的染色法。在同一个边双联通分量中的点会被染上同一个颜色。同一种颜色的结点，又可以用**Tarjan缩点**的思想。把一个边双联通分量缩成一个结点。

 _（注：这里说一下，我们做这道题时只需要用到桥的概念和强连通分量的一种操作思想，这两个东西是不用敲的，所以不用慌\fad。）_ 

又因为删完桥后，桥的两端点会分到两个不同的联通块里。所以一个桥的两端**必然是不同的颜色**，也就不能被缩到一起。

所以缩点后的图会必然成为一棵树的形状，如图～

![](https://cdn.luogu.com.cn/upload/image_hosting/nlek31o2.png)

可以看到将边双联通分量缩成一点后，图变成了树。

这时候我们就会参悟到，我们的加边实则是要把这整棵树边变成一个边双连通分量。

我们要找的是支离破碎的点，支离破碎是删完桥之后的事情了。拆桥之前，这种点仅仅依靠一座可怜的桥与其他部分保持联系。

这样可怜的情况体现在缩点后的树上，就是**从一个点开始遍历，一个支离破碎的点被跑到的次数只有一次**。

那我们就在跑树上遍历的时候记录这个点的入度 $in$ 。**入度为1**的点就是支离破碎点。

现在要加边连接这些支离破碎点了。这里我们打算 $O(1)$ 得出。可以想出，每次我们的加边行为都得连接两个破碎点。

 如果有两个破碎点，加一条边连接他们，这两个点就不再仅有一座桥与外界联通了。

那如果有三个呢，最最简单的图就是一个根下面仨儿子，这种情况下，我们只需连两条边即可加固所有的破碎点。（不妨YY一波）

以三个点**呈三角形互相连边**（~~稳定的三角关系~~ $\bigtriangleup$ ）应该是最最简单的边双联通分量单位。

而每两个破碎点在树上与他们的公共祖先的关系一定是呈大小不定的 $\bigwedge$ 字形状，要形成三角关系只需要**再加一笔**。即**一笔至多加固两个破碎点**。

- 所以破碎点为偶数个时，加边数为 $\dfrac{N}{2}$ 。

- 而奇数个时，总是会剩一个不能组成三角关系，那就需要多加一条边，让剩下的这个点随便和一个三角关系连接，加边数为 $\dfrac{N}{2}+1$ 。

这两个式子我们又可以合二为一，即加边数 $\left\lfloor\dfrac{(N+1)}{2}\right\rfloor$ 。

至此我们有了正解。

~~无非无向图缩点板子~~。（首尾呼应）

实现如下：

```cpp
#include <iostream>
#include <stack>
using namespace std;
const int MAX = 2e4 + 7;
int N, M;

/*前向星组件*/
struct edge
{
     int to;
     int next;
} e[MAX << 2];
int head[MAX], eid = 0;
void adde(int x, int y)
{
     e[++eid].to = y;
     e[eid].next = head[x];
     head[x] = eid;
}

/*Tarjan缩点组件（贺板子就完事）*/
int low[MAX], dfn[MAX], t = 0, cnt = 0, id[MAX], in[MAX];
stack<int> st;
void tarjan(int u, int lst_e)
{
	
     low[u] = dfn[u] = ++t;
     st.push(u);
     //tarjan特色
     for (int i = head[u]; i; i = e[i].next)
     {
          int v = e[i].to;
          if (!dfn[v])
          {
               tarjan(v, i);
               low[u] = min(low[u], low[v]);//更新
          }
          else if (i != (lst_e ^ 1))
          //这里因为是无向图，输入一条无向边我们会存入两条有向边
          //但这样会在tarjan时导致二人转（雾
          //故还要判这是不是上一条边的反边
          //用异或表示反边的骚操作属实秀
          //但注意边的id要从1开始计数
          //否则就用不了骚操作
          {
               low[u] = min(low[u], dfn[v]);//更新
          }
     }
     if (low[u] == dfn[u])//若这一联通块结束了
     {
          int k;
          ++cnt;
          while (k != u)
          {
               k = st.top();
               st.pop();
               id[k] = cnt;//染色
          }
     }
}
int main()
{
     cin >> N >> M;
     eid = 1;
     //谨记！！！！！
     for (int i = 1; i <= M; i++)
     {
          int fr, to;
          cin >> fr >> to;
          adde(fr, to);
          adde(to, fr);
     }
     for (int i = 1; i <= N; i++)
     {
          if (!dfn[i])
          {
               tarjan(i, -1);//Tarjan基操
          }
     }
     for (int u = 1; u <= N; u++)
     {
          for (int i = head[u]; i; i = e[i].next)
          {
               int v = e[i].to;//前向星遍历
               
               if (id[u] == id[v])
                    continue;
                    //这里就看出缩点的意味了
                    //同一联通块的在这里默认缩成一点
                    //不会遍历过去
                    
               in[id[v]]++;//记录入度
          }
     }
     int res = 0;
     for (int i = 1; i <= cnt; i++)
     {
          if (in[i] == 1)
          {
               res++;//统计破碎点
          }
     }
     cout << (res + 1) / 2 << endl;//出解
}
```

那位大佬说的没错，无非一道板子题（~~再 放 送~~）。