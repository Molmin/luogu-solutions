[更好的阅读体验](https://www.cnblogs.com/LaoMang-no-blog/p/16496538.html)

---

[**你谷 link**](https://www.luogu.com.cn/problem/P2603)

一道蛮模版的字符串题，只需要一步非常显然的转化。

首先思考如果无视四种操作该怎么做，如果将每一个点看成是一个**字符**，那么就是给定一个文本串，多个模式串，求每个模式串在文本串里出现几次，这显然是一个字符串的模板题，可以使用 AC 自动机，也可以使用诸如后缀数组、后缀树、后缀自动机之类的后缀数据结构维护，这里不多做赘述，可以转到你谷模板题自行学习。

那么就是转化四种操作，考虑平移和旋转就是无视了绝对位置，缩放就是不关心绝对距离，翻转我们最后处理。

既然不关心绝对距离和绝对位置，我们就可以考虑现将相邻两点连线，然后存向量，转化为向量，发现再绝对的数值失去作用后，我们只能将相邻两向量的关系存下来，显然我们需要存长度的比值和夹角，如果用 `double` 存精度肯定没有保证，我们可以选择使用整数存下来，长度的比值我们可以直接以分数形式记录，夹角我们知道任意一个角都可以用**一组正弦和余弦值**唯一确定，而再向量中，我们知道点积和叉积是与正余弦相关的，但是我们只关心夹角，同理我们将正弦和余弦约分，即同时除以它们的最大公因数，正确性证明显然。

那么我们对于相邻的三个点求出两个向量，再对两个向量求出长度的比值和点叉积的比值，以四元组形式存下来作为“字符”，可以用 c++ 内置的 `tuple` 存储，各种自动机的转移边可以利用 `map` 来实现。

这里我选择用符合思维惯性的后缀自动机实现，在翻转方面，直接将**给定的模式串原串**翻转后重新求四元组序列，如果和原串的四元组序列相同（这种情况即给定的所有点共线），则不需要再管翻转，否则再跑一边，将两次的答案加起来，显然不会有重，注意特判只给了两个点的情况。

[c++ 代码](https://www.cnblogs.com/LaoMang-no-blog/p/16496538.html)