### 安利博客 $\Longrightarrow\Longrightarrow\Longrightarrow$[更好的阅读体验](https://www.cnblogs.com/y2823774827y/p/10294798.html)

做$SDOI$有种想评黑的感觉，果然还是太弱了

##做法
独立写(调)代码三个小时祭

简化题目：求二维最长不上升子序列及每个点出现在最长不上升子序列概率

我们的限制条件：$t_j<t_i,h_j \geqslant h_i,v_j\geqslant v_i$，求长度随便套个$cdq$随便就做出来了嘛

毒瘤的出题人怎么可能这么简单就让我们切了这道题，那怎么求概率呢？

设$L_i$为以$i$结尾的最长长度(不包括$i$)，那包含$i$的最长长度为$L_i+1+R_i$

设$Lnum_i$为以$i$结尾的最长长度(不包括$i$)的个数，
那包含$i$的最长长度为$L_i+1+R_i$的总个数为：$Lnum_i×Rnum_i$。特殊地，长度为$0$是，个数为$1$

那总个数呢？$\sum\limits_{i=1}^n(Lnum_i×Rnum_i)$然后发现全$WA$了，我们重复统计，因为同一子序列会在所以点里算一遍
正确的做法，枚举每一个右端点，即$R_i==0$&&$L_i+1==ans$，满足这个条件再统计方案就不会重复计算了

抱着能shi做shi出kan来的心态打了一遍[冗长的代码](https://www.luogu.org/paste/gspznpc3)，发现只有7分，想*的心都有了，然后造出一组数据拍掉了

```cpp
6
4 25
4 30
4 35
4 40
4 45
4 50
```

因为长度为$0$时，查询后相加方案数会变成$2$，所以在每次查询后暴力加个判断改回$1$，然后惊奇的发现$85$分了

剩下是由于long long爆了，那我们就把方案数换double，撒花撒花！！

### [code](https://www.cnblogs.com/y2823774827y/p/10294798.html)
