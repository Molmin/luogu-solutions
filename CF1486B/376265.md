## 一道 ~~初中数学题~~ 数论题
### 我们先尝试将二维转换为一维来理解：
![](https://cdn.luogu.com.cn/upload/image_hosting/dfnijmz4.png)

#### 如图：

在一个数轴上，存在 $a_1$ 和 $a_2$ 两点，问如何取一点 $x$ ，使 $x$ 到 $a_1$ 和 $a_2$ 的距离和最小？

由初中平面几何知识可知，当 $x$ 位于 $a_1$ 和 $a_2$ 之间时，任取一点都可使距离和最小。距离和最小值为 $|a_2 - a_1|$ 。

#### 简单说明一下结论的正确性：

如图的 $x_1$ 点，位于 $a_1$ 点的左侧。它与 $a_1$ 和 $a_2$ 两点的最小距离和为 $2|a_1 - x_1| + |a_2 - a_1|$ 。由于 $2|a_1 - x_1|$ 大于零，故 $x_1$ 点一定是比 $x$  劣的点。$x_2$ 点同理。

### 如果存在更多限制的点呢？

![](https://cdn.luogu.com.cn/upload/image_hosting/34ggf60l.png)

#### 当存在偶数个的点的时候：

如图所示，我们就可以利用化归思想，两两分组。

将 $a_1$ 与 $a_4$ 分为一组，则最优的点应在 $a_1$ 与 $a_4$ 之间；

将 $a_2$ 与 $a_3$ 分为一组，则最优的点应在 $a_2$ 与 $a_3$ 之间。

两者取交集，则 $a_2$ 与 $a_3$ 之间为整体的最优解。

#### 当存在奇数个的点的时候：

可看作 $a_2$ 与 $a_3$ 点重合，则最优解即取最中间的点。

### 回到二维中理解：

#### 思路：

由于是求曼哈顿距离，所以横坐标与纵坐标是两个独立的区块，互不影响。所以我们选择将横坐标和纵坐标分别用数组记下，用一维的方式，求出它的最优区间。再用两变量记录每个坐标轴的答案，两答案相乘即可。

若该轴为偶数个数：则最优区间大小为 最中间两个数之差加一，即 $ans = x_{\frac{n}{2}+1} - x_{\frac{n}{2}} + 1$。

若该轴为奇数个数：则最优区间大小为 $1$ ，即 $ans = 1$。

#### 代码：

```cpp
#include <iostream>
#include <algorithm>
#include <cstdio>
#define ll long long
using namespace std;

int T,n;
ll x[1010],y[1010],ans1,ans2,a,b;

int main(){
	cin>>T;
	while(T--){
		scanf("%d",&n);
		for(int i=1;i<=n;i++){
			scanf("%lld%lld",&a,&b);
			x[i] = a;
			y[i] = b;
            //记录所有横坐标与纵坐标的位置
		}
		if(n & 1 == 1){  //如果n为奇数，则直接输出1
			cout<<1<<endl;
			continue;
		}
        //如果n为偶数，则分别计算两坐标轴答案，再相乘
		sort(x + 1,x + 1 + n);
		sort(y + 1,y + 1 + n);
		ans1 = x[n/2+1] - x[n/2] + 1;
		ans2 = y[n/2+1] - y[n/2] + 1;
		cout<<ans1 * ans2<<endl;
	}
	return 0;
}
```
