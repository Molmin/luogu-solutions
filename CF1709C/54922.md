## 题目分析

我们从前往后扫一遍，使用两个计数器，一个 $s_1$ 记录左括号数量减右括号数量，一个 $s_2$ 记录还不能确定的问号数量。

当 $s_1$ 为零且当前遇到问号，说明之前无需再考虑，且当前必为左括号，直接记录当前为左括号并继续。

除此之外，遇到左括号 $s_1$ 加一，遇到右括号 $s_1$ 减一，遇到问号 $s_2$ 加一。

$s_0$ 小于零时，说明前面有问号必为左括号，$s_1$ 加一，$s_2$ 减一。

特别要注意的是，若 $s_1$ 为零且 $s_2$ 为奇数，说明前面左右括号数量相同，且问号不能自己组成合法序列，为使左括号不少于右括号，必有一个为问号为左括号，$s_1$ 加一，$s_2$ 减一。

最后结尾时判断一下， 如果 $s_2 >s_1$，说明还不能判断的问号数量大于当前失配的左括号数量，则不存在单一匹配，否则则可以找到。

## 代码

```pascal
#include<iostream>
using namespace std;
int main()
{
    ios::sync_with_stdio(false);
    cin.tie(0);
    int t,i,s1,s2;
    string a;
    cin>>t;
    while(t--)
    {
        cin>>a;
        s1=0;
        s2=0;
        for(i=0;i<a.size();i++)
        {
            if(s1==0&&a[i]=='?')
            {
                s1++;
                continue;
            }
            if(a[i]=='(')
                s1++;
            else if(a[i]==')')
                s1--;
            else
                s2++;
            if(s1<0)
            {
                s2--;
                s1++;
            }
            if(s1==0&&s2%2==1)
            {
                s2--;
                s1++;
            }
        }
        if(s2>s1)
            cout<<"NO\n";
        else
            cout<<"YES\n";
    }
    return 0;
}
```
