一道位运算好题

题面长得很像二分，~~不过细看就可以发现并不是~~

既然是位运算，肯定要考虑按位。

我们从高位向低位枚举，假设枚举到了第 $i$ 位

（$a_i$ 指正在处理的可乐标识的第 $i$ 位的值）

显然，如果之前存在位 $j$，使 $a_j \oplus x_j > k_j$，那么后面再怎么取也一定不合法；如果存在位 $j$ 使 $a_j \oplus x_j < k_j$，那么后面也一定合法。因此一旦出现这两种情况，都不必继续枚举了。所以当我们枚举到第 $i$ 位时，对之前的所有位，一定有 $a_j \oplus x_j = k_j$。

- 若 $k_i=1$

如果 $x_i=a_i$，那么后面不论取什么，结果一定会小于 $k$；也就是说，我们得到了一段聪明值区间，在这个区间内的都是合法的。

如果 $x_i\not=a_i$，前面的位仍然相同，需继续枚举。

- 若 $k_i=0$

如果 $x_i=a_i$，理由同上，仍需继续枚举。否则一定不合法，舍去。

最后我们要统计区间的最大重叠数量。~~当然可以用线段树~~记录时差分一下，统计时做前缀和就可以了。

注意位运算的优先级。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 1000010;
int n, k, a[N], c[(1<<20)];
int main() {
	scanf("%d%d", &n, &k);
	for(int i=1; i<=n; ++i) scanf("%d", a+i);
	for(int i=1; i<=n; ++i) {
		int sum=0;
		for(int j=20; j>=0; --j) {
			if((k>>j) & 1) {
				if((a[i]>>j) & 1) {
					c[sum + (1<<j)]++;
					c[sum + (1<<j+1)]--;					
				} else {
					c[sum]++;
					c[sum + (1<<j)]--;
					sum += 1<<j;
				}
			} else {
				sum = sum + ((a[i]>>j & 1) << j);
			}
		}
	}
	int ans = c[0];
	for(int i=1; i<(1<<20); ++i) {
		c[i] += c[i-1];
		ans = max(ans, c[i]);
	}
	printf("%d", ans);
	return 0;
}
```