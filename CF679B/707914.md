运行时间：$60ms$。

### 题意（自己的理解）：

首先，有一个正整数 $X \in [1,m]$ ，表示这个塔的总体积。然后，他每次总是尽可能地添加最大的木块，也就是第一层要放体积最大不超过 $X$ 的正方体。然后再选一个当前最大的正方体做第二层，也就是这个正方体的体积不超过 $(X-$ 第一层的体积 $)$。然后再选一个当前最大的正方体做第三层，也就是这个正方体的体积不超过 $(X-$ 第一，二层的总体积 $)$。

你所做的，是要使块的个数尽可能多，在这个条件下，$X$ 尽量大。

---

这道题可以对操作进行枚举，来求出最大的 $h$，和与其对应的最大的 $X$。

我们定义剩余体积为 $X$ 减去已搭建的正方体的总体积。

1. 每次搭正方体可以用一个当前最大的正方体，设此边长为 $L$。
2. 另外一种是：将剩余体积变为 $L^3-1$，再用一个边长是 $L-1$ 的正方体（当前最大的正方体）。原理：它要求总块数最多，所以我们可以尽可能放小正方体，使得体积分配更多，块数也更多。
3. 如果将剩余体积变得更小，用一个边长是 $L-2$ 的正方体，那样就会浪费很多的体积，使得块数变少。所以这种方法不可行。
4. 因为只有两种操作方案，所以可以dfs搜索，每次更新答案（$24-31$ 行，详见注释）。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
long long m;
long long h,v;
long long fp(long long a,long long b){//快速幂
	long long ans=1;
	while(b>0){
		if(b&1){
			ans=ans*a;
		}
		a=a*a;
		b>>=1;
	}
	return ans;
}
void dfs(long long a/*剩余体积*/,long long nh/*当前高度（块数）*/,long long nv/*已搭建的正方体的总体积*/){
    if(a<=0){//如果剩余体积<=0,那么说明搭建完成。
        if(nh>h){h=nh;v=nv;}
        else if(nh==h){
            if(nv>v){v=nv;}
        }
        //(更新数据)
        return;
    }
    long long l=1,r=100001;//cbrt(10^15)=100000 二分查找当前体积下最大可用的边长。
    while(l<=r){
        long long mid=l+r>>1;
        if(fp(mid,3)<=a)l=mid+1;
        else r=mid-1;
    }
    long long L=l-1;//二分答案-1
    
    ////1.搭建一个最大正方体：
    
    dfs(a-fp(L,3),nh+1,nv+fp(L,3));
    //剩余体积：原剩余体积-L^3
    //高度：原高度+1
    //总体积：原体积+L^3
    
    ////2.搭建一个边长为L-1的正方体
    if(!(L<=1)){//L==1时，正方体边长为0，不计算。
        dfs(fp(L,3)-1-fp(L-1,3),nh+1,nv+fp(L-1,3));
        //剩余体积：最大的剩余体积必须小于L^3,不然上面这一种方法更优，
        //为了总体积更大，剩余体积应等于L^3-1。
        //再减去这个边长为（L-1)^3的正方体，得到剩余体积=fp(L,3)-1-fp(L-1,3)。
        //高度：原高度+1
    	  //总体积：原体积+(L-1)^3
    }
}
int main(){
    cin>>m;
    dfs(m,0,0);//搜索，m为剩余体积，0为块数，第二个0为已搭建的体积
    cout<<h<<' '<<v<<endl;
}
```
