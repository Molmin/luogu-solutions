## 题意
给定长度为 $N$ 的 $01$ 串 $A$，求 $\sum^{n}_{1 \le i \le j \le N}      (((A_i ⊼A_{i+1})⊼ A_{i+2})⊼ \cdots⊼A_j)$。


其中 $⊼$ 为双目逻辑运算符， $0 ⊼ 0=1,1⊼0=1,0⊼1=1,1⊼1=0$。
## 做法
这题的 NAND 运算不满足结合律，我好像只想到能用 dp 做......

题目要求的其实是有多少个 ${i,j}(i \le j)$ 满足 $(((A_i ⊼A_{i+1})⊼ A_{i+2})⊼ \cdots⊼A_j)=1$，把问题转化成计数问题。我们又发现，一段运算的值只能是 $0$ 或 $1$，乘上 $A$ 的长度也不会爆掉，就能想到 dp。
### 定义
$dp_{i,j}$ 表示以结尾为 $i$，值为 $j$ 的 $(((A_x ⊼A_{x+1})⊼ A_{x+2})⊼ \cdots⊼A_i)$ 有多少个。
### 转移
- 当 $A_i=0 \space\space\space dp_{i,0}=1 \space\space\space$ 因为一段运算里只要有 $0$，结果就为 $1$，除非这个 $0$ 没有与其他任何数做运算。
- 当 $A_i=1 \space\space\space dp_{i,0}=dp_{i-1,1}\space\space\space$ 因为 $1$ 只有和 $1$ 做运算才是 $0$。
 
- 当 $ A_i=0\space\space\space dp_{i,1}=dp_{i-1,0}+dp_{i-1,1}\space\space\space$ 因为 $0$ 只要和别的数做运算，结果一定是 $1$。
- 当 $A_i=1\space\space\space dp_{i,1}=dp_{i-1,0}+1 \space\space\space$ 因为 $1$ 只有和 $0$ 做运算时才得 $1$，或不与任何数做计算也是 $1$。

### 初始化
将 $dp_{0,0}$ 和 $dp_{0,1}$ 初始化为 $0$。乘法算式得初始值为 $1$ 因为 $1$ 乘上任何数都为另一个乘数，但 $⊼$ 运算没有这个性质，因此两种值的初始个数都为 $0$。
### 统计答案
由于 $dp_{i,1}$ 的定义是以第 $i$ 位结尾的结果为 $1$ 的式子 $\sum_{i=0}^{n} dp_{i,1}$ 即可。
## 代码核心部分
```cpp
	for(int i=1;i<=n;i++){
		dp[i][0]=(b[i]?dp[i-1][1]:1ll);
		dp[i][1]=(b[i]?dp[i-1][0]+1:dp[i-1][0]+dp[i-1][1]);		
	}
	for(int i=1;i<=n;i++)ans+=dp[i][1];
```
