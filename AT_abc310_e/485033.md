$\qquad$[原题面](https://atcoder.jp/contests/abc310/tasks/abc310_e)

$\qquad$一眼看上去：好麻烦啊，要统计每个子区间的答案，这个运算还是新运算，还有运算顺序的问题……但仔细分析后，我们发现，若一次只统计以某一个位置为右端点的所有区间的答案，最后将所有位置的答案累加，是一个可行的思路。那么该怎么统计以某一个位置为右端点的所有区间的答案呢？

$\qquad$我们来进行一波分类讨论：首先，我们观察这个新运算，发现若两个数只要有一个是 $0$，那么最终的结果一定是 $1$。所以，第一种情况就是：第 $i$ 个位置为 $0$，最终的答案为 $(i-1)$。

$\qquad$剩下的情况就是第 $i$ 个位置为 $1$ 了。在这个情况下，又要包含三个小情况：

1. $[1,i]$ 全为 $1$，此时，不难发现，每增加一个 $1$，区间的值就要异或一个 $1$，所以最终的答案就是 $(i+1)/2$；
2. $[2,i]$ 为 $1$，$a[1]$ 为 $0$，这时，左端点在 $[2,i]$ 的答案跟上一情况一样，为 $((i-2+1)+1)/2$，此时，最前方的 $0$ 对答案不会造成任何贡献，所以 $[1,i]$ 的值等于 $[2,i]$ 的值。所以若 $[2,i]$ 长度为奇，答案加一，否则不变；
3. $[k,i]$ 为 $1$，$a[k-1]$ 为 $0$，$k\geq2$。这时，左端点在 $[k-1,i]$ 的答案跟上一情况一样，此时，我们发现，从 $[k-2,i]$ 到 $[1,i]$ 的值都为 $[k-1,i]$ 的值异或 $1$，所以答案再加上 $[k-2,i]$ 的值乘 $(k-2)$。

$\qquad$在代码实现时，我们可以记录下后缀最长连续 $1$ 的长度和最后一个 $0$ 的位置，便于计算。

```cpp
#include <bits/stdc++.h>
using namespace std;

typedef long long LL;
const int maxn = 1e6 + 5;
int n;
int a[maxn];
char ch[maxn];
LL f[maxn];

int main() {
    scanf("%d", &n);
    scanf("%s", ch + 1);
    for(int i = 1; i <= n; i ++) a[i] = (int)(ch[i] - '0');
    int lst = 0, fir = 0;//lst:后缀最长连续1，fir:最后一个0的位置
    for(int i = 1; i <= n; i ++) {
        if(a[i]) {
            lst ++;//连续1长度++
            if(fir == 0) f[i] = (lst + 1) / 2;//[1,i]全为1，第一种情况
            else if(fir == 1) f[i] = (lst + 1) / 2 + (lst & 1);//[2,i]为1，a[1]为0，第二种情况
            else f[i] = (lst + 1) / 2 + (lst & 1) + ((lst + 1) & 1) * (fir - 1);//第三种情况
        }
        else f[i] = 1LL * (i - 1), lst = 0, fir = i;//0的情况
        f[i] += f[i - 1];//求个前缀，便于输出
    }
    printf("%lld\n", f[n]);
    return 0;
}
```
