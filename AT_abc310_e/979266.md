### 题意：
给出一个长度为 $ N $ 的，仅包含 $ 0 $ 和 $ 1 $ 的字符串 $ S $ ，其中， $ S $ 的第 $ i $ 位表示 $ A_i $ 的值。

请求出以下式子的值：

$$\displaystyle \sum_{ 1 \leq i \leq j \leq N } (\cdots((A_i\barwedge A_{i+1})\barwedge A_{i+2})\barwedge\cdots\barwedge A_j)$$

### 思路：

直接按照题意 $f_{i,j}$ 暴力的话时间复杂度是 $O(N^2)$ 的，但是因为 $N$ 的最大值为一百万，只能考虑 $O(N)$ 或者 $O(N \log N)$ 的做法。

考虑以第 $i$ 个数结尾的贡献，发现，如果 $A_i$ 是 $0$ 的话，前面的无论怎么算过来，和 $0$ 进行 $\barwedge$ 运算结果都是 $1$，所以对于以 $0$ 结尾的第 $i$ 个数，所产生的答案是 $i-1$（因为如果 $i=j$，贡献为 $A_i$）。

那么如果 $A_i$ 是 $1$ 呢？我们先观察一下，对于第一个 $1$，他的前面全部都是 $0$，计算到 $i-1$ 的结果肯定是 $1$，而 $1 \barwedge 1=1$，然后发现如果从 $i-1$ 开始算的话 $1\barwedge0=1$，又有一个贡献，所以对于第一个 $1$ 他的答案是 $2$（还有自己本身）。

如果不是第一个 $1$，但是 $i-1$ 的位置是 $0$，到达 $i-1$ 的时候计算到的结果只有 $1$，加上 $i-1$ 和自己进行的 $\barwedge$，所以答案也是 $2$。

若是对于多个连着的 $1$ 呢？发现对于连着的 $1$，最前面的 $1$ 的前面肯定是 $0$，所以对于第一个连着的 $1$，答案是 $2$，这是我们前面推出来的结论。

那么第二个 $1$ 呢？发现在和第一个 $1$ 进行 $\barwedge$ 肯定变成了 $0$，然后和自己 $\barwedge$，贡献为 $1$，总共产生的答案为 $i-2$，为什么不是 $i-1$ 呢？因为 $A_i \barwedge A_{i-1}=0$，所以要减少一个贡献。

对于第三个 $1$ 呢？我们发现，对于连着的 $1$，我们都需要用前面的答案和自己做 $\barwedge$ 运算，发现前面是 $0$，和自己做 $\barwedge$ 运算是 $1$，前面是 $1$，做 $\barwedge$ 运算的答案是 $0$。

诶，这不就取反了吗？所以对于连着的 $1$，除了第一个以外，其他的都等于 $i-k$，$k$ 为上一个数的答案，这样我们可以写出简短的代码。
### 完整代码：
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,a,sum; 
string s;
signed main(){
	cin>>n;
	cin>>s;
	for(int i=0;i<n;i++){
		int x=i,y=s[i]-'0';
		if(y){
			a=x-a;
//			cout<<a<<' '<<y<<' '<<a+y<<'\n';
			sum+=a+y;
			a+=y;
		}
		else{
			a=x;
//			cout<<a<<' '<<y<<' '<<a+y<<'\n';
			sum+=a+y;
		}
	}
	cout<<sum<<endl;
    return 0;
}
```
