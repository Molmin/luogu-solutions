## 1. 编程思路。

用 $M$ 位二进制数来表示所购买糖果中 $M$ 种口味的组合情况。二进制数中 $b_i$ 位等于 $1$，表示有第 $i+1$ 种口味的糖果；若 $b_i$ 等于 $0$，表示没有第 $i+1$ 种口味的糖果。若 $M$ 种口味的糖果都有，则对应的 $M$ 位二进制数各位全为 $1$，用十进制整数表示为 $2^M-1$。

在输入数据时进行预处理，用 $a_i$ 保存第 $i$ 包糖果的口味组合情况。以题目中的输入输出样例为例，输入的 $6$ 包糖果的口味组合情况可以依次表示为 $3,7,5,22,26,19$。

之后就可以采用 0/1 背包进行求解。

设 $F_i$ 表示糖果的口味组合情况为 $i$ 时需要购买的最少的糖果包数。

初始时，$2^M$ 种口味组合情况的 $F_i(0\le i\le 2^M-1)$ 的值均可以设置为一个大于 $100$ 的整数，表示口味组合 $i$ 无法品尝到。

定义 $F_0=0$，什么口味也没有，显然什么糖果也不需要购买。

状态转移方程为 $F_{j \  or \  a_i}=\min(F_{j \  or \  a_i},F_j+1)$。

其中， $1\le i \le N$，$0\le j\le 2^M-1$。

最后的答案为 $F_{2^M-1}$。

## 2. 源程序。

```c
#include <stdio.h>
#include <string.h>
int f[1<<20],a[105]={0};
int main()
{
	int n,m,k;
	scanf("%d%d%d",&n,&m,&k);
    int num=(1<<m);    // m种口味的各种组合总的状态数
	int i,j;
	for (i=0;i<num;i++)
    {
		f[i]=105;
	}
	for (i = 0;i<n;i++)
	{
		for (j = 0;j<k;j++)
		{
			int t;
			scanf("%d",&t);
			a[i] = a[i]|(1<<(t-1));
		}
	}
	f[0]=0;
	for (i=0;i<n;i++)
	   for (j=0;j<1<<m;j++)
	   {
		   if (f[j]>100) continue;
		   f[j|a[i]]= (f[j|a[i]]<f[j]+1)? f[j|a[i]] : f[j]+1;
	   }
	if (f[num - 1]==105) printf("-1");
	else printf("%d",f[num - 1]);
	return 0;
}
```
