### 思路
首先会情不自禁向dp去想，但是仔细想想，贪心好像也有一定道理，因为想要转化得到的十进制数最小，因为转进制数的方式是这样的，如样例所示：5=1⋅13^1+2⋅13^0

因此转换成n进制的数，所以当最小是当然有每一位最大，这样这个n进制的数的位数可以尽可能短qwq,所以应该没有什么问题，然后就试着写了一份贪心，然后就AC了つ﹏⊂。

### 灰常重要的东西！！！(╯▔皿▔)╯

本题是一道细节题，需要处理大量的细节问题，有以下细节：

1.因为一般的做法是从后向前扫描字符串，并将其转换成十进制数，比较和n的大小，也就是能不能选到这一位，选不到就从这里分隔开，然后继续计算n进制数的下一位，但是是这样会出现一个问题，如一个50进制数：100000000000000000001，如果从字符串的最后一位开始，边选边算，当算到第一位的1的时候，发现已经大于n，这时候不能直接把1作为开头继续计算，因为如果这样的话，后面选的n进制数的一位就是00000000000000000001，显然这样的数是不存在的qwq，所以每次找到比n更大的十进制数时，一定要向回找，直到没有0或者当前十进制数的第一位，**注意**，千万不能一直顺着0向回找，而不管当前选的十进制数有多少位，不然像上面的例子，选了最后一位的1后再从倒数第二位的0开始向前选，然后选到第一位发现不行，向后一直退到倒数第二位，又等于没选，其实向后推到倒数第三位的十进制数位数已经变成了1，就不能再往后推了，否则会陷入死循环23333


2.有些极端数据会导致当前的十进制数溢出，要特殊判断！！

#### 极其优美の代码
```cpp
#include<iostream>
#include<cstring>
using namespace std;
int n;
string s;
int main(){
	cin>>n;    cin>>s;
	long long ans=0,fcheng=1;
	for(register int i=s.size()-1;i>=0;){
		long long now=0,cheng=1,wei=0,flag=1;
		for(register int j=i;j>=0;){
			if(now+(s[j]-'0')*cheng<n&&now+(s[j]-'0')*cheng>=0){
				now+=(s[j]-'0')*cheng,cheng*=10,j--,wei++;
				if(j<0){
					ans+=fcheng*now;
					cout<<ans<<endl;
					return 0;
				}
			}
			else if(now+(s[j]-'0')*cheng>=n||now+(s[j]-'0')*cheng<0){   
				while(s[j+1]=='0'&&wei!=1)j++,cheng/=10,wei--;     //当超出时，循环向回选，注意选的位数不能退回0位
				i=j,flag=0;
			}
			if(flag==0)break;
		}
		ans+=now*fcheng,fcheng*=n;
	}
	cout<<ans<<endl;
}
```