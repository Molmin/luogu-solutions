[题目](https://www.luogu.com.cn/problem/CF245H)

### 分析
1.数据范围中，$n\leq 5000$，因此可以考虑 $O(n^2)$ 的算法。

2.要求回文串的个数，可以先预处理出对于这个字符串的每个子串，它们是不是回文串。代码如下：
```cpp
for (int len = 1; len <= n; ++len) {//枚举子串长度
	for (int i = 1; i <= n - len + 1; ++i) {//枚举左端点
		int j = i + len - 1;//计算右端点，此时判断[i,j]是否是回文串
		if (a[i] != a[j]) continue;//如果左右两边不等，一定不是
		if (j - i <= 1 || b[i + 1][j - 1]) b[i][j] = 1;
		//有以下的情况：
		//1.i=j，此时就是回文串
		//2.i+1=j，此时因为已经去除两端不同的情况，所以此时也是
		//3.b[i+1][j-1]=true,此时因为去掉两边后是回文串，所以两边各
		//加上相同的字符也是回文串。如:bcb是回文串，abcba也是回文串
	}
}
```

3.要求出一段区间内的方案数，很容易想到区间 $dp$，定义 $dp_{ij}$ 表示 $[i,j]$ 这个区间内有多少回文串。但区间 $dp$ 的时间复杂度高达 $O(n^3)$，显然不能通过。区间的两端肯定要枚举，因此可以尝试把断点那一维去掉。怎么不枚举断点呢？先看一个区间 $[i,j]$：

| $[i]\ $ | $[i+1]\ $ |  $[...]\ $  | $[j-1]\ $ | $[j]\ $ |
| :----------: | :----------: | :----------: | :----------: | :----------: |

想要得到 $[i,j]$ 中的回文串个数，我们可以先把 $[i,j-1]$ 的个数加上，再进行推导。此时还缺少区间内包含 $j$ 的回文串个数，再把 $[i+1,j]$ 加上：

| $[i]\ $ | $[i+1]\ $ |  $[...]\ $  | $[j-1]\ $ | $[j]\ $ |
| :----------: | :----------: | :----------: | :----------: | :----------: |

| $[i]\ $ | $[i+1]\ $ |  $[...]\ $  | $[j-1]\ $ | $\ $ |
| :----------: | :----------: | :----------: | :----------: | :----------: |

| $\ \ \ \ $ | $[i+1]\ \ $ |  $[...]\ $  | $[j-1]\ $ | $[j]\ $ |
| :----------: | :----------: | :----------: | :----------: | :----------: |

可以发现，$[i+1,j-1]$ 部分被加了两次，再减去即可。
由于 $[i,j]$ 自身也有可能是回文串，如果 $[i,j]$ 是回文串，还要加 $1$。

那么 $dp$ 的转移方程就是：
$dp_{i,j}=dp_{i+1,j}+dp_{i,j-1}-dp_{i+1,j-1}\ (s_i=s_j,!b_{i,j})$

$dp_{i,j}=dp_{i+1,j}+dp_{i,j-1}-dp_{i+1,j-1} + 1\ (s_i=s_j,b_{i,j})$

($b_{i,j}$ 表示 $[i,j]$ 是否为回文串)

于是，我们成功地预处理出了每个区间内的回文串数量：
```cpp
for (int i = 1; i <= n; ++i) dp[i][i] = 1;//初始化!!!
for (int len = 2; len <= n; ++len) {//枚举长度
	for (int i = 1; i <= n - len + 1; ++i) {//枚举左端点
		int j = i + len - 1;//计算右端点
		dp[i][j] = dp[i + 1][j] + dp[i][j - 1] - dp[i + 1][j - 1] 
		+ b[i][j];//转移方程
	}
}
```

4.对于每组询问 $[l,r]$，输出 $dp_{l,r}$：

```cpp
while (q--) {
	scanf("%d%d", &l, &r);
	printf("%d\n", dp[l][r]);
}
```
