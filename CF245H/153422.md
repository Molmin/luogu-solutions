题意就是输入一个字符串并询问其区间中回文子串的数量。

我们发现 $q$ 很大，于是猜测每一次询问是 $\mathcal{O}(1)$ 的。

又由于 $|s|$ 的范围为 $5000$，可以支持 $\mathcal{O}(n^2)$ 的算法，于是猜测需要 $\mathcal{O}(n^2)$ 预处理所有区间中的回文子串的数量。

首先需要知道每一个串是否回文。

暴力肯定是不行的，我们可以尝试通过已经求出的部分来求没有求出的部分。

如果一个串是回文的，那么显然其首尾字符相同，而将其去掉首尾以后仍为回文。

那么边界条件是怎样的呢？

显然长度为 $1$ 的串必然是回文的，长度为 $2$ 的串如果两个字符相同则为回文。（此处不考虑空串）

于是有递推式：

$$isP_{l, r} = \begin{cases}1&r=l\\ [str_l = str_r]&r=l+1\\ [str_l=str_r\land isP_{l+1,r-1}]&r>l+1\end{cases}$$

其中的 $\land$ 是逻辑与运算。

然后知道了每一个串是否为回文，如何求出区间内回文子串的数量？

可以使用容斥原理。

$[l,r]$ 中的子串的左端点要么是 $l$，要么不是 $l$。

右端点要么是 $r$，要么不是 $r$。

这不废话吗？

把他们合并一下：

1. 左端点为 $l$，右端点为 $r$。
1. 左端点为 $l$，右端点不为 $r$。
1. 左端点不为 $l$，右端点为 $r$。
1. 左端点不为 $l$，右端点不为 $r$。

第一种情况如果 $[l, r]$ 是回文串则为 $1$，否则为 $0$。

第二种情况把左端点定为有一定难度，把他拆成“左端点随意，右端点不为 $r$”减去“左端点不为 $l$，右端点不为 $r$”。

右端点不为 $r$ 就是到 $r-1$ 为止。

左端点随意就是从 $l$ 开始，不为就是从 $l+1$ 开始。

所以第二种情况的答案为 $cnt_{l, r-1}-cnt_{l+1, r-1}$。。

同理第三种情况的答案为 $cnt_{l+1, r}-cnt_{l+1, r-1}$。

第四种显然就是 $cnt_{l+1, r-1}$。

四种情况加一加，得到：

$$cnt_{l,r}=isP_{l,r}+(cnt_{l, r-1}-cnt_{l+1, r-1})+(cnt_{l+1, r}-cnt_{l+1, r-1})+cnt_{l+1, r-1}$$

$$=isP_{l,r}+cnt_{l,r-1}+cnt_{l+1,r}-cnt_{l+1,r-1}$$

如果还不能理解，想想二维前缀和。

加上边界的情况就是：

$$cnt_{l, r}=\begin{cases}1&r=l\\isP_{l,r}+2&r=l+1\\isP_{l,r}+cnt_{l,r-1}+cnt_{l+1,r}-cnt_{l+1,r-1}&r>l+1\end{cases}$$

另外注意枚举时不能先枚举左端点再枚举右端点，应当先枚举区间大小再枚举区间位置，保证递推时所需要的内容已经求过了。

还有由于读入量比较大，请使用 `scanf` 和 `printf` 谢谢。

（我才不会告诉你我不会打快读）

```cpp
#include <bits/stdc++.h>
#define r (l+len-1)
using namespace std;
int T, n, L, R;
char ch[5010];
bool isP[5010][5010];
int cnt[5010][5010];
int main() {
	cin >> (ch+1);
	n = strlen(ch+1);
	for (int i = 1; i <= n; i++) {
		cnt[i][i] = isP[i][i] = 1;
	}
	for (int i = 1; i < n; i++) {
		if (ch[i] == ch[i+1]) {
			isP[i][i+1] = 1;
			cnt[i][i+1] = 3;
		} else {
			isP[i][i+1] = 0;
			cnt[i][i+1] = 2;
		}
	}
	for (int len = 3; len <= n; len++) {
		for (int l = 1; r <= n; l++) {
			if (ch[l] == ch[r] && isP[l+1][r-1]) {
				isP[l][r] = 1;
				cnt[l][r] = cnt[l][r-1] + cnt[l+1][r] - cnt[l+1][r-1] + 1;
			} else {
				isP[l][r] = 0;
				cnt[l][r] = cnt[l][r-1] + cnt[l+1][r] - cnt[l+1][r-1];
			}
		}
	}
	cin >> T;
	while (T--) {
		scanf("%d%d", &L, &R);
		printf("%d\n", cnt[L][R]);
	}
	return 0;
}
```

$$\huge{\texttt{\color{white}{求过，求赞}}}$$