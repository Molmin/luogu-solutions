分块 

单点修改，如果一次向上跳若干步，怎么做。

常数较大的长剖能做到单次$O(1)$，但是实际上我们可以用重剖。

因为每个点只会向上跳，只会切log次的重链，复杂度$O(NlogN)$并不是瓶颈 

那全局修改呢？

有一个很显然的结论：如果一个点的祖先已经被遍历过，那么这个点就没用了。

因为大家一起跳的时候，肯定已经有比他更小的答案了。

那么我们记一下这个点是否被遍历过，暴力跳就是优秀的$O(n)$。

回到这题，我们想对于整块记录两个信息：

一是块内的深度最小值；二是所有可能成为答案的下标；

整块暴力修改，如果已经有点跳到根就不管，否则每个点都暴力向上跳，把有用的点放到信息二中。

显然我们还要记一手每一个块内树上每个点是否被遍历过，bitset存储即可。

边角暴力修改。由于它向上跳了一步，那么它又有可能成为答案，也把他加到信息二里，同时更新信息一。

整块询问时，直接调用信息一即可。

现在我们现在维护的不足以支持查询单点的深度，不过这玩意就随便做了，修改的时候记一个tag。

注意向上跳的时候要把块标记抵消，不然每次向上跳就要带个log了。

那么，你已经完全明白了！！！快把这题写了吧。

如果您的常数足够优秀，那么普通的实现是可以过这题的。

但是如果过不了的话，就把点按dfs序重新编号，那么每次跳链的时候是值直接相减，指针速度会快很多。

代码不难写，就不献丑挂自己的拖拉机了。

#### 思路版权归mrsrz所有，卡常小技巧归skip2004所有。