### 题目大意

现在有一个数字 $n$ ，你有三种操作：

1. 使该数字$+1$，代价为 $a$ 。
2. 使该数字$+2$，代价为 $b$ 。
3. 使该数字$+3$，代价为 $c$ 。

你要用最小的代价使得 $n$ 能被 $4$ 整除。
### 大体思路

显然我们要先处理出 $n/4$ 的余数，然后再进行判断。

当余数为$1$时，也就是差$3$,那么我们有三种凑法是可能最优的：

1. 进行三个 $1$ 操作。
2. 进行一个 $1$ 操作和一个 $2 $操作。
3. 进行一个 $3$ 操作。

其余凑法都或多或少会有无用的操作。

进行比较即可

当余数为 $2$ 时，也就是差 $2$，很明显，我们用操作 $1$ 和操作 $2$ 是能够凑出来的。但是我们很容易忽略只用操作 $3$ 也是能凑出来的（进行两次操作 $3$ ）。

当余数为 $3$ 时同理，我们可以用一个 $1$ 。同样，很容易被忽略的是 $011$ （操作 $1$ 进行 $0$ 次，操作二 $1$ 次，操作三 $1$ 次）和 $003$ （同上解释）这两种凑法。

了解了以上的思路，代码就很简单了。

Code：
```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
#define ll long long
using namespace std;
ll n,a,b,c;//注意，范围达到了10^9，开longlong比较稳妥
int main()
{
    cin>>n>>a>>b>>c;
    if(n%4==0) return cout<<0,0;
    if(n%4==1) return cout<<min(min(a*3,a+b),c),0;
    if(n%4==2) return cout<<min(min(a*2,b),c*2),0;
    if(n%4==3) return cout<<min(min(a,b+c),c*3),0;
}

```
