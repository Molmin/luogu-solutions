##**这是一道裸的完全背包问题**

看到没有dalao用完全背包来做这道题，我就~~忍不住~~发一篇。

我一开始还丧心病狂的用深搜来做这道题，结果只过了四个点。再看一下n的范围，n<=10^6，这道题无疑就是动态规划了。动态规划有两种做法，一种是大佬们用数学的方法分析求得状态转移方程，而我的方法就是直接上完全背包（不会数学分析o(╥﹏╥)o）。

这道题可以看成背包容量为n，而每个物品是$2^k$的求方案数的完全背包问题,时间复杂度为O(nlogn),不会超时。

那么状态，转移方程就是我们熟悉的：
```
dp[j]+=dp[j-a[i]];
```
最后别忘了方案数对10^9取模。~~本蒟蒻第一次忘了才得了50分~~

最后上AC代码：
```cpp
#include<iostream>
using namespace std;
int a[25];
long long dp[1000005];
int main(){
	int n;
	cin>>n;
	int p=1;
	int cnt=0;//物品数量
	for(int i=0;p<=n;i++){//求物品
		cnt++;
		a[i]=p;
		p*=2;
	}
	dp[0]=1;//预处理
	for(int i=0;i<cnt;i++){//注意是i<cnt
		for(int j=a[i];j<=n;j++){//完全背包正着循环
			dp[j]+=dp[j-a[i]];
			dp[j]%=1000000000;//取模
		}
	} 
	cout<<dp[n]<<endl;//输出
	return 0; //华丽的结束
} 
```
