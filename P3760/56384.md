相信你的信仰……

都是logN，各种logN的常数可是千差万别的

再次重申一边，O(NlogN)的**渐进**复杂度是指，随着输入的增长，耗时的**增长**和NlogN同阶。因此和实际耗时完全没联系啊……(只是大部分时候常数差不多才有了那个把数据范围代进去，算出来不超过5\*10^8/3\*10^8/10^9就能过的说法的)

# 要开longlong

首先我们发现这道题让我们求异或和，对于这种位运算的东西我们没有任何办法，只有两条路可走，1，拆位2，找规律

首先题目中让我们求所有的子区间和，因此我们可以考虑做个前缀和什么的就可以O(1)求出,令sum(i)表示i为结尾的前缀和

那么题目中其实是让我们求

# $⊕\sum_{i=1}^{n}\sum_{j=0}^{i-1}sum(i)-sum(j)$

一个非常直白的想法就是枚举i，之后再枚举j，然后如果我们nc再拆一下位我们就有了一个O(N^2logM)的优秀做法

但是我们想一下啊，既然我们都拆位了，此时的减法运算和异或运算都会变的非常简单我们要好好研究下有什么性质

因为我们拆了位，所以sum(i)-sum(j)的第k位不是0就是1，而且我们发现，异或运算在只有一位的情况下等价于%2下的运算，因此我们对于这第k位来讲，我们统计出这一位到底有多少个1就好了，最后%2再乘上一个(1<<k)就好了，所以现在答案被我们折腾成了这个式子

#### $\sum_{k=0}^{(1<<k)<sum(n)}(1<<k)(\sum_{i=1}^{n}\sum_{j=0}^{i-1}((sum(i)-sum(j))>>k\&1)mod2$

尽管这个式子很鬼畜吧但是我们总算不用见到异或了

我们发现外层的k肯定是省不了的，内层的i其实也不是很能省，所以我们的精力主要放在如何处理j的循环上

我们发现不就是给定了sum(i)和k，求有**多少个sum(j)**和sum(i)做个差之后第k位值为1吗……

那么我们发现此时如果sum(i)第k位是1，那么我们希望减了sum(j)之后还是1

那么只有两种可能

1.没有发生借位，并且sum(j)的第k位是0，这样才可以保证sum(i)的1不会被减掉

2.发生了借位，并且sum(j)的第k位是1，这样我们会发现sum(i)被减了1之后，这一位会变成0，我们借一下位0就变成1了

若sum(i)第k位是0呢？必须发生且仅发生了1次借位才可以变成1

1.这个借位来源于sum(j)的第k位是1，导致的借位，并且此时不可以再发生第二次借位

2.这个借位来源于sum(j)的前k-1位，所以此时sum(j)第k位必须是0

如何判定会不会发生借位呢？我们可以这样想，如果sum(j)的前k-1位的值大于sum(i)前k-1位的值，就会发生借位，否则不发生

那么我们发现好像sum(i)和sum(j)的值不会太大，而且吧，这是个值的大于小于问题，我们自然就想到了用区间求和的形式来处理这个问题，我们把大于和小于的限制**变成值域的限制**(讲道理就算大了我们也可以离散化)

另外，我们要求在j必须小于i,此时我们需要按顺序将这些值插入数据结构之中，这样就满足了i>j的限制关系

这个数据结构支持单点修改区间求和，所以我们选择树状数组，开两个，位置就代表值，一个树状数组记录当前位为0的，另一个记录1

然后我们就可以大力算了~，如果每部%2可以不开longlong，但是如果像我一样的话……还是开longlong吧

这个算法的复杂度是 O(NlogM^2)如果有离散化的话复杂度会降到O(NlogNlogM)但是很不推荐(离散化常数大……)

代码超级短~

上代码~

```c
#include<cstdio>
#include<algorithm>
using namespace std;
typedef long long ll;//不每次膜的话就要开longlong 
const int N=1e5+10;const int M=1e6+10;
int n;int lim;int sum[N];ll res;
struct treearray//这里注意一个坑，我们对于第0个前缀和也要处理，这里树状数组整体右移1 
{
	ll ta[2*M];
	inline void c(int x,ll t){x+=1;for(;x<=lim+1;x+=x&(-x)){ta[x]+=t;}}
	inline ll q(int x){x+=1;ll r=0;for(;x>0;x-=x&(-x)){r+=ta[x];}return r;}
	inline ll s(int l,int r){return q(r)-q(l);}
	inline void clear(){for(int i=0;i<=lim+1;i++){ta[i]=0;}}
}ta1,ta0;
int main()
{
	scanf("%d",&n);for(int i=1;i<=n;i++){scanf("%d",&sum[i]);sum[i]+=sum[i-1];}
	for(int k=0;(1<<k)<=sum[n];k++)
	{
		lim=(1<<k)-1;ll ret=0;
		for(int i=0;i<=n;i++)//计算个数并统计 
		{
			int nb=(sum[i]>>k)&1;int lst=sum[i]&lim;
			if(nb){ret+=ta0.s(-1,lst)+ta1.s(lst,lim);ta1.c(lst,1);}//如果是1 
			else {ret+=ta1.s(-1,lst)+ta0.s(lst,lim);ta0.c(lst,1);}//如果是0 
		}res+=(1<<k)*(ret%2);ta1.clear();ta0.clear();
	}printf("%lld",res);return 0;//拜拜程序~ 
}

```
