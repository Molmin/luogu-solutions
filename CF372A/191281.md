## CF372A 数袋鼠很有趣 题解

### STEP1：理解题目

~~(CF的题真让人搞不懂）~~

翻译用了非常严谨的语言精确的描述了题目要求的意思（然而蒟蒻看不太懂，我太菜了），所以我撇开360难看的翻译读了一遍题，还真挺有意思的（啊哈？

题目讲的是（~~一个无聊的人数袋鼠~~）有$n$只袋鼠，它们有袋子。

袋子的大小与它们自身的大小成正比(自身大小=$self$，袋子大小=$bag$)$\frac{self}{bag}=\frac{2}{1}$

它们的袋子可以装下比袋子小的其它袋鼠，（参考俄罗斯套娃）。

但每一只袋鼠都只能装一只袋鼠在袋子里。

而且袋子里的袋鼠不能装其它袋鼠（可以想象为一个只允许套一层的俄罗斯套娃）。

现在想让我们求最多能让多少只袋鼠在外面（即宁需要把更多的袋鼠塞进别人的袋子里~~谔谔~~）

（如果宁逻辑思维比较强建议看前台大佬的翻译）

### STEP2：如何实现

我们知道想要匹配更多的袋鼠，就应该尽可能的把更大的袋鼠塞进更小的袋子里（即使ai尽可能大而aj尽可能小）

这里我想到的是类似归并中一个子段的排序，使一个指针从中间开始搜，另一个从末尾开始搜。

因为我们把一只袋鼠塞到另一个袋鼠里这两只袋鼠都会废掉，所以也就是说最少还是会有$\frac{n}{2}$ 个组合。

所以从中间搜可以实现无错（因为最优的情况也就是$\frac{n}{2}$ ，搜索时也肯定找的是最优解（因为排过序），所以无论如何这种搜索都能找出答案。）

在这样的条件下从中间搜索无疑是个很好的选择，只要保持右指针在右半段而左指针在左半段且指针均不越界即可。

### STEP3：遍历过程

此处方便还在晕圈中的童鞋理解：

下面上图：

![遍历过程图](https://cdn.luogu.com.cn/upload/image_hosting/qk9f3m9g.png?x-oss-process=image)

### STEP4：上代码啦

下面直接上代码（受到某篇的启发觉得还是解释代码最管用）

如果宁已经有思路却缺乏实现的可以看看（附解释）：

```cpp
#include<bits/stdc++.h>//万能头
using namespace std;//std命名空间
int a[500001];//定义数组，别开小了（我第一次交就RE了）
int main()
{
	int n;cin>>n; 
	ufor(int i=1;i<=n;++i)
	{
		cin>>a[i];
	}//很简单的输入，应该不用说了
	sort(a+1,a+n+1);//sort是个好东西，小到大排序
	int mid=(1+n)>>1;//位运算，即(1+n)/2，二分常用，+1为了防奇偶性的问题
	int l=mid,r=n;//两个指针，0<l<=mid,mid<r<=n
	int ans=0;//一个关于答案的变量
	while(r>mid&&l>0)//实现r始终在右边，l始终在左边，越界则停止。
	{
		if((a[l]<<1)>a[r])//位运算+比较（真快
		{
			l--;//如果前面的数较小，则用更小的数比（即l往左移）
		}
		else
		{
			a[l]=0;//将塞进别人袋子里的袋鼠标记
			l--;r--;//此时两个指针所在的数都废了，于是都往左移，继续比较小一点的数
		}
	}
	for(int i=1;i<=n;++i)
	{
		if(a[i]!=0)
		{
			ans++;
		}
	}//最后看看还剩多少没塞进袋子里的袋鼠，即为答案
    //其实还可以简化，但这更好懂
	cout<<ans;//输出
	return 0;//return
}
```
