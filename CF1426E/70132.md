update：远古题解一大堆格式错误，试图一个个修复。  

~~你们巨佬的代码怎么都这么长啊，让我来水一发短的代码~~


**题意**  
两个人玩石头剪刀布。A 出了 $a_1$ 个石头，$a_2$ 个剪刀，$a_3$ 个布。B 出了 $b_1$ 个石头，$b_2$ 个剪刀，$b_3$ 个布。  
求 A 最少赢的次数和最多赢的次数。
（题目中还给了一个无用信息 $n=a_1+a_2+a_3=b_1+b_2+b_3$，不过可以使代码更简洁）  

**题解**  
考场上随便乱搞就整出来的题目为什么被你们搞的这么复杂？（逃

显然是两个独立的~~水~~问题。其中第二个更水。   

先考虑第 $2$ 个问题。  
A 出石头 $(a_1)$ 只有对应 B 出剪刀 $(b_2)$ 才能赢。   
那么赢的次数最多是 $\min(a_1,b_2)$。  
显然出石头、剪刀、布赢的次数相互独立，那么答案即为  $\min(a_1,b_2)+\min(a_2,b_3)+\min(a_3,b_1)$。  

再考虑第 $1$ 个问题。  
$a_1$ 对应不是 $b_2$ 的要尽量多。那么不赢的次数最多是 $\min(a1,n-b2)$。   
注意这一问和上一问不一样，出石头、剪刀、布不赢的次数并不相互独立。  
如果没有 $a_1+a_2+a_3=b_1+b_2+b_3 $ 这个条件就会错。     
那么在题目这个条件下，我们可以~~根据样例猜到~~证明答案就是 $n-\min(a_1,n-b_2)-\min(a_2,n-b_3)-\min(a3,n-b_1)$。

**~~口胡~~证明**

我们考虑出石头和出剪刀互相影响的情况应该是说，如果  $a_1>b_3 $ 且 $ a_2>b_2$ 此时剩余的石头和剩余的剪刀都要放在 B 出石头这个情况下，可能会溢出。  
但是由于 $a_1+a_2 \leq b_1+b_2+b_3$ 所以这样的情况并不会发生。  
证明有不严谨的地方请评论告诉我然后我会更新。


**代码**
```
#include<bits/stdc++.h>
using namespace std;
int n,a1,a2,a3,b1,b2,b3;
signed main()
{
	cin>>n>>a1>>a2>>a3>>b1>>b2>>b3;
	cout<<n-min(a1,n-b2)-min(a2,n-b3)-min(a3,n-b1)<<" "<<min(a1,b2)+min(a2,b3)+min(a3,b1);
}
```