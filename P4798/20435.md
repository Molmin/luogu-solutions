看到这道题没有题解我就写一下哈~

这道题是求给定数列的排名，也就是比给定数列字典序小的合法序列方案数$+1$，

所以我们可以想到一个很水的数位dp：

我们可以用$f[i][j][k]$表示前$i$位中最大值为$j$，且当前序列和给定序列的前$i$位的字典序关系为$k$的方案数，其中$k=1$时当前序列的前$i$位与给定序列相同，$k=0$时当前序列前$i$位的字典序小于给定序列前$i$位的字典序。

那么我们可以考虑从$i$转移,考虑当前状态为$k$时,枚举所有的$j$,

当$k=0$时，有

$f[i+1][j][0]+=f[i][j][0] \times j;$

$f[i+1][j+1][0]+=f[i][j][0];$

当$k=1$时，有

$f[i+1][j][0]+=f[i][j][1] \times (a_{i+1}-1);$

$([a_{i+1}=j+1]?f[i+1][j+1][1]:f[i+1][j][1])+=f[i][j][1];$

这四种转移，可以通过爆推/模拟的方式来求出这些转移式子。

因为dp数组中间结果会较大，记得开long long，我就是这样被卡在66分了几分钟>_<

当然这样写比较暴力，空间比较大，所以我们可以把第一维滚动掉，就能通过此题了。

时间复杂度：常数不大的$O(n^2)$，足以通过此题。

代码如下：

```cpp
#include<cstdio>
#include<iostream>
#define b i&1^1
#define c i&1
using namespace std;
const int p=1000007;
long long f[2][10005][2];int a[10005],s=1;
int main()
{
	int n;scanf("%d",&n);f[1][1][1]=1;
	for(int i=1;i<=n;++i) scanf("%d",&a[i]);
	for(int i=1;i<n;++i)
	{
		for(int j=1;j<=i;++j)
		{
			f[c][j][0]%=p,f[c][j][1]%=p;
			f[b][j][0]+=f[c][j][0]*j;
			f[b][j+1][0]+=f[c][j][0];
			f[b][j][0]+=f[c][j][1]*(a[i+1]-1);
			(a[i+1]==j+1?f[b][j+1][1]:f[b][j][1])+=f[c][j][1];
			f[c][j][0]=f[c][j][1]=0;
		}
	}
	for(int i=n,j=1;j<=n;++j){f[c][j][0]%=p;s+=f[c][j][0];if(s>p) s-=p;}
	return !printf("%d\n",s);
}
```