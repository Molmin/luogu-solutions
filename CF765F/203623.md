没有实现过，若本文有误请指出。

感谢 abruce 提供的一些启发。

考虑离线扫右端点 $r$，并且只解决 $i<j,a_i\le a_j$ 的情况。解决原问题显然把数组翻转做两次即可。

#### Lemma：若 $j=r$，那么 $i$ 必然满足存在一个自然数 $d$ 使得 $i$ 是 $[1,r]$ 中最大的数满足，$a_i\ge a_j -2^d$ 且 $a_i \le a_j$ 或者 $a_i=a_j$。

若 $i$ 不满足上述条件，显然 $a_j-1\le a_i\le a_j$ 的情况平凡。那么设 $a_j-2^{d+1}\le a_i < a_j-2^d$，则存在 $a_k$ 使得 $a_j-2^{d+1}\le a_k < a_j-2^d$，显然 $|a_k-a_j|<2^d$，$a_j-a_i>2^d$。且 $k>i$，所以 $(i,j)$ 的匹配包含了 $(k,j)$，那么包含 $(i,j)$ 的区间一定包含 $(k,j)$，$(i,j)$ 的匹配总是不优的。

问题就是求出前缀中所有在 $[a_r-2^d,a_r]$ 中下标最大的数。$a_i=a_j$ 的情况是平凡的。

对序列 $n\to 1$ 做扫描线，对值域离散化后维护猫树结构。每次扫到一个位置 $p$ 就在猫树上做扫描，对每个节点维护 veb，这样可以快速找到 $p$ 产生贡献的区间。然后把所有的 $[a_p-2^d,a_p]$ 加入猫树中。注意到值域经过离散化，所以实际上要用 veb 维护 $a_p-2^d$ 的离散化值。

然后需要支持 $O(n\log v)$ 次单点修改与后缀查询，这显然可以维护后缀最小值。维护单调栈状结构，用 veb 支持插入与均摊的删除。

设序列长度为 $n$，查询次数为 $m$，总时间复杂度 $O(n\log v\log \log v+m\log \log v)$。