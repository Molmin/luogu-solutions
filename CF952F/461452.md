这道题作为蓝题实在简单了点……

这道题并没有中文翻译，提供自行翻译：
```
题目描述
一位经验丰富的出决定为愚人节竞赛准备一道题。任务非常简单——给定一个算术表达式，返回计算该表达式的结果。但是，参考解决方案中似乎存在错误。

输入格式
输入数据的唯一一行包含算术表达式。表达式将包含2到10个操作数，用算术符号加号或减号分隔。每个操作数都将是一个介于0和255（含0和255）之间的整数。

输出格式
如样例运算算法，计算对于输入而言的该算法运算结果
```
其中提到了“**错误**”二字，且根据标题可以看出，该运算与普通运算不同。

那么这个算法是怎么进行的呢？只能通过找样例规律得出结论：  
1. 样例1：看着跟正常计算一模一样，暂时跳过。
2. 样例2：正常情况2+2=4，比样例多50。
1. 样例3：正常情况112-37=75，比样例少300。

不难发现，末尾0的个数取决于后面数的位数，除开0又发现：
1. **3**+**字符‘+’的ASCII码值**=**字符‘0’的ASCII码值**
2. **5**+**字符‘-’的ASCII码值**=**字符‘0’的ASCII码值**

所以运算符号是被看作与下一个数一起运算的！  
如：（等号后为正常的符号）  
2+2=2+(-5)\*10+2=46  
112-37=112-(-3)\*10-37=375

注意：**加法就是符号算得减号，后面的数算得加号；减法完全相反。** 另外，综合算式计算时每个符号只关联到下一个数，而不是后面的所有数。

附上完整注释代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
string a;
int quan=1,ans,ans1;//quan是权值，如231中，1权值为1，3权值为10，2权值为100 
int main()
{
	cin>>a;
	for(int i=a.size()-1;i>=0;i--)//逆序循环是因为可以让每个数从个位开始操作，能直接确定一个数某一位的权值 
	{
		if(a[i]!='+' && a[i]!='-')//数字 
		{
			ans1+=quan*(a[i]-'0');//暂时不确定正负，先用ans1累加
			quan*=10;//下一位 
		}
		else if(a[i]=='+')
		{
			ans+=quan*(-5)+ans1;//一负一正 
			quan=1;//下一个数 
			ans1=0;
		}
		else
		{
			ans+=quan*3-ans1;//一正一负 
			quan=1;
			ans1=0;
		}
		
	}
	ans+=ans1;//第一个数前没有符号，但肯定要加 
	cout<<ans;
	return 0;
}

```
