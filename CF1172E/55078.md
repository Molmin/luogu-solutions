提供一个点分治做法。

感谢出题人把时限开成 7.5s，再少 0.1s 就过不去了。

![](https://cdn.luogu.com.cn/upload/image_hosting/w5jf4ql5.png)

---

这是一道路径问题。首先考虑用点分树去维护。

容易发现，每种颜色之间是独立的。于是就可以转为对于每种颜色计算包含其的路径条数。

运用正难则反式容斥，再转为计算不包含其的路径条数。

设当前颜色为 $i$。定义颜色为 $i$ 的点为“黑点”。则将某个点染黑相当于子树 $+1$。这里的贡献可以使用维护区间最小值和最小值个数的线段树维护出。其中值为 $0$ 的点就是未被覆盖的点，也就是可以作为经过当前点分根的路径端点的点。

稍加分析可得到该做法的时间复杂度是 $O(n\log^2 n)$。

直接在线实现可以得到一个巨大常数的空间 $O(n\log n)$ 做法，需要使用动态开点线段树。也就是上方最下面五发提交，轻松 M+T。

稍稍精细离线可以得到一个常数较小的空间 $O(n\log n)$ 做法。方法是每次询问的时候跳爹挂上去，然后最后遍历整颗点分树处理询问。也就是中间偏下的若干发 TLE on 11 和 Wa on 11 的测速。

观察到空间非常巨大，访问大数组会很慢，可以想到不要跳爹，而由爹来找你。得到一个常数较小的空间 $O(n)$ 做法，但是仍 TLE on 11。

运用非常精细的实现（如 zkw 线段树，基数排序）等可以通过此题。成功垫底。

代码太多，可以去翻提交记录按需取用.jpg。



