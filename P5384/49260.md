## 吐槽

~~关于倍增，它终于死了。~~

这好像是我做的第一道放过树剖卡掉倍增的题……

## 50pts做法

原题等价于询问$x$的$k$级祖先的子树中$dep=dep[x]$的节点个数。

一看到$k$级祖先显然会想到用倍增求。

再用线段树合并维护每个节点的子树中$dep=i$的节点个数。

时间复杂度$O(nlogn)$，空间复杂度也是$O(nlogn)$还多好几倍常数。显然会$TLE+MLE$。。。

## 70pts做法？

先求出$DFS$序，则询问相当于询问$DFS$序从$dfn[x]$到$dfn[x]+sz[x]-1$中的$dep=x$的节点个数。

离线所有询问，把每个询问拆成两个事件：减去小于$dfn[x]$的答案和加上$dfn[x]+sz[x]-1$的答案。

按$dfn$序枚举，维护当前$dep=i$的节点个数$sum$。枚举到$i$的时候把$dfn$序为$i$的节点统计到$sum$中。同时处理所有$i$处的事件。

由于需要倍增，时间和空间复杂度都是$O(nlogn)$。本来算起来这个复杂度是足够的。但是由于我们还需要很多$10^6$的数组，所以空间还是炸了（手算大约需要$140$到$150MB$）。而且$10^6$的树用倍增……时间也不太行。

随机树的点或许能过？

## 100pts做法

现在复杂度的瓶颈就在于倍增了。考虑把倍增的这个空间上的$log$给优化掉。

$k$级祖先，不用倍增，我只能想到树剖了。。。

沿着$x$到根的重链不断向上跳。

当重链长度$>k$时，说明所求的$k$级祖先就在这条重链上，直接返回$dfn$序为$dfn[x]-k$的点即可。

否则跳过这条重链，注意同时要更新$k$。

时间复杂度$O(nlogn)$，空间复杂度$O(n)$。必须开$O2$才能过。。。

## 细节

$x$的$k$级祖先可能不存在，此时输出$0$。

## 代码

由于别的都是板子，就不粘了。

只粘主程序，~~抄代码的自己看着办~~

```cpp
int main(){
	n=read(),m=read();
	for(int i=2;i<=n;++i)fa[i]=read(),adde(fa[i],i);
	dep[1]=1,dfs1(1),dfs2(1,1);
	for(int i=1;i<=m;++i){
		x=read(),k=read(),f=up(x,k);
		if(f){
			q[++tot].pos=dfn[f]      -1,q[tot].val=dep[x],q[tot].id=i,q[tot].op=-1;
			q[++tot].pos=dfn[f]+sz[f]-1,q[tot].val=dep[x],q[tot].id=i,q[tot].op=1;
		}else ans[i]=1;
	}
	sort(q+1,q+tot+1);
	for(int i=0,j=1;i<=n&&j<=tot;++i){
		++sum[dep[num[i]]];
		while(j<=tot&&q[j].pos==i)ans[q[j].id]+=q[j].op*sum[q[j].val],++j;
	}
	for(int i=1;i<=m;++i)space(ans[i]-1);
}

```

$UPD$：

倍增把$fa$数组开成$N*15$可过？？？

数据不够强啊。。。如果造一个链的或者$\frac n2$的链挂一些点的数据倍增应该就彻底凉凉了？