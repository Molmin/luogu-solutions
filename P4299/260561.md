- 介绍一种不用 LCT，但空间复杂度为 $O(n \log n)$，时间复杂度为 $O(m \log^2 n)$ 的**离线**做法。

题目要求支持的操作有 $3$ 种：

1. 加边合并两棵树
2. 查询一棵树的重心编号
3. 查询所有树重心编号的异或和

- 发现每次加边操作会让原本两棵树的重心编号失去贡献，添加一个重心编号产生贡献，所以在进行操作 $3$ 的时候我们只需要先查出原本两棵树的重心，再查出合并后树的重心就可以维护所有树重心编号的异或和。

- 这样问题就转化成了动态维护多棵树的重心。
- 在树上找到一个点 $x$，满足 $size_{root} \leq size_x \times 2 $，且 $x$ 最深， $x$ 即为树的重心。（所有符合条件的点都在同一条从叶子到根的路径上）

- 因为所有满足 $size_{root} \leq size_x \times 2 $ 的点都在同一条链上，所以对于任意满足 $dfn_x \leq dfn_y$ 的 $x,y$，都有 $dep_x \leq dep_y $。

- 所以对于每一棵树，我们开一个动态开点线段树进行维护，每个节点维护区间  $[l,r]$，维护了所有满足 $l \leq dfn_x \leq r$ 的 $x$ 的 $size_x$ 的最大值，这样可以进行线段树二分，求出这棵树的重心。

- 这个题不要求强制在线，而且操作只有加边没有删边，所以可以考虑先离线把森林建出来，后续加边操作便可以看做是一棵树的根成为了另一棵树的一个叶子节点的儿子。（这里和 P4219 [BJOI2014]大融合 很像）

- 再考虑连边操作所造成的影响。假设一条边的两个端点为 $u$ 和 $v$，且 $dep_u<dep_v$，那么在我们预先建出的森林上来看，一定有节点 $v$ 的父亲是节点 $u$。这条边连好以后，从节点 $u$ 到包含节点 $u$ 的树的根的 $size$ 都会增加 $size_v$，且用来维护两棵树重心的线段树需要合并。这样我们可以把连边操作看作是进行一次链加和一次线段树合并。为了实现链加操作，我们需要在一开始的时候把森林进行重链剖分。然后就做完了。
- 谢谢 Alan_Zhao 对做法的一些建议。

[代码云剪贴板](https://www.luogu.com.cn/paste/j1z7nidz) 

实现细节：
- 我写的时候没用标记永久化，所以 `down` 操作写的比较玄学，没有在下放的时候新建节点，但是正确性也能保证： 
每次对于一棵树的链加操作，我们一定是在给存在于这棵树上的一些节点加 $x$，而这些节点一定在线段树上有其对应的叶子。所以对于一次有效的 `down` （$x \neq 0$）来说，不可能会给一些不存在于这棵树上的节点对应的位置加 $x$，也就不可能在下放的时候访问原本没有的节点。

- 线段树合并的时候也要 `down`。

- 一棵树可能会有 $2$ 个重心，需要取编号较小的那个，当你找到的重心 $g$ 满足 $size_g \times 2 = size_{root}$ 时，意味着 $g$ 的父亲也是重心，需要特判一下。



