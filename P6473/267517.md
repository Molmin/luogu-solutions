#### NOI Online没来得及报名QAQ
只好看着洛谷的题面做了……

这道题的人物背景（摘自百度）：[Sisyphus](https://baike.baidu.com/item/%E8%A5%BF%E8%A5%BF%E5%BC%97%E6%96%AF/6690210?fromtitle=Sisyphus&fromid=5322905)

###### 他也认为自己是幸福的。这个从此没有主宰的世界对他来讲既不是荒漠，也不是沃土。这块巨石上的每一颗粒，这黑黝黝的高山上的每一矿砂唯有对西西弗斯才形成一个世界。他爬上山顶所要进行的斗争本身就足以使一个人心里感到充实——加缪《西西弗的神话》
看完这段百度，我也唏嘘不已。其实，我们的OI之路也是如此。有可能我们曾无限接近于成功，接近胜利，也有可能因为那一丝疏忽而前功尽弃，只能卷土重来。但我们并不后悔，因为我们是**幸福的**，**我们有自己的目标，有自己的梦想，为之奋斗，不留遗憾。**

~~不行这不是语文阅读~~

### 正题
题目虽然长，但仔细看看还是很好懂的。
这里只讲思路~~代码错了别怪我，lz住校初中生，平时也没有时间上洛谷~~

这道题的主要思路就是：

- 在什么魔法都不用放的情况下，直接$cout0$,然后$q-- $   $ continue$
- 在用一次魔法就可以解决问题的情况下，直接用离山顶最近的魔法点施法，
然后$cout0$ ,$q-- $  , $ continue$
- 在上述两种情况都不满足的情况下，我们就一步一步来：
	1. 首先用两个施法点，分别为最远和第二远，先计算到第二远的点时的时间T，再累加最远；在循环外判断$T$和是否大于$Ti$。
    
   2. 如果不行，再用三个施法点，分别为最远、第二远和第三远，先计算第三远的点所需时间……以此类推。
   3. 一旦符合，马上输出＋标记+跳出循环；最后如果标记的$bool$变量没有改变，则输出$-1$。 
   
   **P.S**解决此题的关键是把施法点从大到小排序，所以用$sort$的童鞋们，要加$cmp$哦~
   
  下面$code$(仅供参考+启发思路，不保证对)

```cpp
#include<bits/stdc++.h>
using namespace std;
double a[200001];
int t[200001];
bool cmp(double a,double b){
    return a>b;
}
int main (){
	double l,v;//double是为了求T是避免取整
	int n,i;
	cin>>n>>l>>v; 
	for(i=1;i<=n;++i){
		cin>>a[i];
	}
	sort(a+1,a+n+1,cmp);
	int q;
	cin>>q;
	while(q!=0){//多组测试数据
		int ans(0);
		int ti;
		cin>>ti;
		if(l/v>ti){//特判情况1
			cout<<0<<endl;
			q--;
			continue;
		}
		else if(l/v+a[1]/v>ti){//特判情况2
			cout<<1<<endl;
			q--;
			continue;
		}
		else{
			bool f=true;//判断是否符合题意
			for(i=2;i<=n;i++){
				double t1=0;
				for(int j=i;j>=1;j--){
					t1+=a[j]/v;//到达施法点所需时间累加
					ans++;//魔法次数
				}t1+=l/v;//加上最后一次到山顶
				if(t1>ti){
					cout<<ans<<endl;
					f=false;
					break;//判断
				}	
			}if(f==true){//无解
				cout<<"-1"<<endl;
			}q--;	
		}	
	}
	return 0;
}
```