[CF825B](https://www.luogu.com.cn/problem/CF825B)
### 题目大意
这题其实很简单，就是纯暴力，对每一给点进行判断。就是跟你一个棋盘，上面已经下了一些子了，问你X能否直接取胜。
### 分析
能否直接取胜，就是问你联在一起的五个格子中，是否有四个 $X$ 并且没有 $O$   。

而五子棋可以横着，竖着，或斜着。

那么总共有四种方法。我们可以用一个二维数组储存，第一维表示横竖那种方法，第二维表示第几个数。可以减少很多的代码。即：
```cpp
int x[5][6]{{0},{0,-2,-1,0,1,2},{0,0},{0,-2,-1,0,1,2},{0,-2,-1,0,1,2}},y[5][10]{{0},{0,0},{0,-2,-1,0,1,2},{0,-2,-1,0,1,2},{0,2,1,0,-1,-2}}；
```

#### 最后，给出总代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int i,j,n,m,t,x[5][6]{{0},{0,-2,-1,0,1,2},{0,0},{0,-2,-1,0,1,2},{0,-2,-1,0,1,2}},y[5][10]{{0},{0,0},{0,-2,-1,0,1,2},{0,-2,-1,0,1,2},{0,2,1,0,-1,-2}},tx,ty;
int ans1=0,ans2=0;
char a[11][11];
int main(){
	for(i=1;i<=10;i++)//输入
		for(j=1;j<=10;j++){
			cin>>a[i][j];
		}
	for(i=1;i<=10;i++)
		for(j=1;j<=10;j++){
			for(t=1;t<=4;t++){
				for(int p=1;p<=5;p++){//进行判断
					tx=i+x[t][p];
					ty=j+y[t][p];
					if(tx<1||tx>10||ty<1||ty>10)break;
					if(a[tx][ty]=='X')ans1++;
					if(a[tx][ty]=='.')ans2++;
				}
				if((ans1==4&&ans2==1)||ans1==5){
						cout<<"YES";
						return 0;//直接结束程序，防止多输出
					}
				ans1=0;
				ans2=0;
			}
		}
	cout<<"NO";
	return 0;//完结撒花！！！
}
```


