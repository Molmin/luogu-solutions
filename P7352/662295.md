### 状态压缩动态规划

------------

#### 分析

卡牌只有 $0$ 和 $1$，$n$ 最大是 $16$，除了状压和爆搜以外想不到其他做法了。

虽然卡牌的状态是固定的，但由于每个人都不知道其左右邻居的状态，他会猜测 $4$ 种情况，直接搜索没什么思路，因此采用状态压缩动态规划。

------------

#### 实现

状态压缩每个人的卡牌（$0$ 或 $1$），称题目中给出的真实卡牌集合为 $X$。

定义 $dp_{i,S}$ 为状态 $S$ 在第 $i$ 轮信息公布后喊出 Meltdown 的人的集合，这样最后过一遍 $dp_{i,X}$ 就可以得到答案了。

怎么得到 $dp$？题目中已经说明了会喊出 Meltdown 的情况只有两种，分析一下就可以得到人们大喊大叫的原因了：

- 卡牌上数字为 $0$ 且猜测的所有情况中，**所有合法情况**中左右邻居卡牌上数字的逻辑或值相等。
- 卡牌上数字为 $1$ 且猜测的所有情况中，**所有合法情况**中左右邻居卡牌上数字的逻辑异或值相等。

为什么会有合法情况之说？因为有的情况和题目中给出的信息不符，这时候它就不再会被考虑了。

定义 $on_S$ 为集合 $S$ 的合法性，随着游戏轮数的增加，集合只会从合法变成不合法，所以不用加一维记录轮数。

每轮游戏都检查所有合法的集合，然后在**每一个合法集合**中枚举每一个人将要猜测的情况，符合上文中大喊大叫的条件就把对应的二进制位设为 $1$。**无论该集合对于那个人合不合法都需要枚举**，其他人会利用这一点排除他们猜测的集合。（样例二中，第一回合没人喊说明每个人手里都不是 $0$，在第二回合没有给出任何信息的情况下他们都喊了 Meltdown）

题目要每个人第一次喊出 Meltdown 的轮编号，没有喊过则输出 $-1$。因为和 $dp$ 的定义有差别，每一轮都需要统计答案。

然而照这个思路写出来的代码并不正确，为什么？因为如果 $dp_{i,S}$ 和 $dp_{i,X}$ 不相等，说明集合 $S$ 非法，会被排除。**因为真实卡牌集合确定，每轮给出的信息确定，游戏进程也是唯一确定的，这场游戏的一切已经在开始时就注定了。**

现在思路完全正确，接下来是代码实现，注意此题的空间限制为 16MB，需要滚动数组。笔者的实现并不精细，不开 O2 无法通过。可以使用链表或并查集维护所有合法集合以大幅减少遍历次数。

实现中 $dp$ 并没有滚动数组，由于对于每种合法状态会喊出 Meltdown 的人数不减，可以直接继承之前的值。

时间复杂度 $O(2^nnm+2^n\sum k)$。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,X,ans[16],dp[1<<16];
bool on[1<<16];
inline int ex(int x){return ~x ? (x==n ? 0:x):n-1;}
inline bool check(int x,int S){//检查第x个人在状态S中是否会喊出 Meltdown
    int ret=-1,ima=S;
    ima|=1<<ex(x-1),ima|=1<<ex(x+1);
    if(on[ima]) ret=S>>x&1 ? 0:1;//只有左右全1的or和xor结果不同
    ima^=1<<ex(x-1);
    if(on[ima]){//左0右1
        if(ret==0) return 0;
        ret=1;
    }
    ima|=1<<ex(x-1),ima^=1<<ex(x+1);
    if(on[ima]){//左1右0
        if(ret==0) return 0;
        ret=1;
    }
    ima^=1<<ex(x-1);
    if(on[ima]){//左右全0
        if(ret==1) return 0;
        ret=0;
    }
    return 1;
}
int main(){
    scanf("%d%d",&n,&m);
    for(int i=0;i<n;i++){
        static int x;
        scanf("%d",&x);
        X|=x<<i;
    }
    const int lim=(1<<n)-1;
    for(int i=0;i<=lim;i++) on[i]=1;
    for(int R=1;R<=m;R++){
        static int T,k,c,aim;
        scanf("%d",&T);
        while(T--){//每轮 T 条信息 每条信息 k 个目标 存在卡牌 c
            scanf("%d",&k);
            aim=0;//指定集合内元素设为 1 用以检查合法性
            for(int i=0;i<k;i++){
                static int x;
                scanf("%d",&x);
                aim|=1<<x;
            }
            scanf("%d",&c);
            for(int i=0;i<=lim;i++) if(on[i]){
                if(c&&!(i&aim)) on[i]=0;//指定集合中存在1但是i没有
                if(!c&&(i&aim)==aim) on[i]=0;//集合存在0但是i没有
            }
        }
        for(int i=0;i<=lim;i++) if(on[i])
            for(int j=0;j<n;j++) if(!(dp[i]>>j&1)&&check(j,i)) dp[i]|=1<<j;
        for(int i=0;i<=lim;i++) if(on[i]&&dp[i]!=dp[X]) on[i]=0;
        for(int i=0;i<n;i++) if((dp[X]>>i&1)&&!ans[i]) ans[i]=R;
    }
    for(int i=0;i<n;i++) if(!ans[i]) ans[i]=-1;
    for(int i=0;i<n;i++) printf("%d ",ans[i]);
    return 0;
}
```

------------

#### [闲话](https://www.luogu.com.cn/paste/4iykeva8)

博弈游戏类似问题的过程大多是唯一确定的。绝顶聪明的玩家们按照最优策略博弈，即使过程不唯一，结果也全部都是唯一确定的。

有一种悲剧美感。