这题我想了很久
___
思路：先把分数化简

然后我想：化简后分母必定是答案，但满不满足最小呢？

不满足！$\frac{1}{8}$可以用2进制和4进制表示

那么我又想：只要这个进制是分母的因数即可？

又被否定了，按上述来说$\frac{7}{10}$可用2进制表示，可是不能

**最后：**我想到6进制能否表示$\frac{8}{9}$？

十分位表示的是$\frac{1}{6}$，百分位表示的是$\frac{1}{36}$

36是9的倍数，$4*\frac{1}{36}$=$\frac{1}{9}$

所以我总结了一下：若 分数的分母包含的质因数**的集合** 与 c包含的质因数**的集合**
相等，那么c即为答案之一，从1往∞找，找到的第一个即为题目的答案

**注：在集合内，相同的元素是要去除的；同时化简后不用考虑分子，若**$\frac{1}{n}$**都可以用有限小数表示出来，那么**$a*\frac{1}{n}$，**不就是$\frac{1}{n}$的倍数吗？也就是说也能用有限小数表示出来**

但时间复杂度超标，我就反过来想：**把化简后的分母 质因数分解，然后去重，最后把去重后的乘起来即为答案！**

但仍然超时了，时间复杂度是O(N) ；N即化简后的分母，但是若N太大也会超时

于是掏出我的杀手锏：任何一个质数可用6n+1或6n-1表示（除了2和3）

所以用了它分解质因数的速度快了三倍！没TLE！
```
#include<bits/stdc++.h>
using namespace std;
int a,b,c,d,q[50000],now=2,ans=1;
int main()
{
    cin>>a>>b;
    d=b/__gcd(a,b);//化简，分子没用，所以没用变量存起来
    while(d%now==0)q[c++]=now,d/=now;now++;//now当前=2，即考虑d现在是否是2的因数，是就加入数组
    while(d%now==0)q[c++]=now,d/=now;now++;//now当前=3，即考虑d现在是否是3的因数，是就加入数组
    now=5;//初始值
    while(d!=1)
    {
        if(d%(now+2)==0)
        {
            q[c++]=now+2,d/=(now+2);
        }
        else
        {
            if(d%now==0)
            {
                q[c++]=now,d/=now;
            }
            else now+=6;
        }
        
    }
    ans*=q[0];
    for(int s=1;s<c;s++)//去重
    {
        if(q[s]!=q[s-1])
        {
            ans*=q[s];
        }
    }
    cout<<ans<<endl;//输出
    return 0;
}
```