## 题目大意

给出长度为 $n$ 的数字串，每次操作可有两种：

+ 把这个数字串代表的数字减一。

+ 任选两位交换位置。

求最少几次操作可以使全部数字变为 $0$。

## 解决问题

显然，若最右一位非零，把最右边的一位减为 $0$。否则从左边移过来一个非零数字，重复操作直至全部为零。我们假设最右边一位是第 $0$ 位，位数向左逐一递增。若此时第 $i$ （$i>0$）位上有一个非零数字 $k$，为了消掉这个数字：

若采取每次减一，需要 $10^ik$ 次操作，很明显这个数的最小值为 $10k$。

若先移到最右边再逐次减一，需要 $1+k$ 次操作。

作差比较大小：

$$
10k-(1+k)=9k-1
$$
$$
9k-1>0
$$

这就意味着无论 $i$ 等于几，第二种方案一定更优。

其实这么说可能很麻烦，比赛时这种题看一眼直接就懂了。

## 代码
```
#include<bits/stdc++.h>
using namespace std;
int main(){
	int T;
	cin>>T;
	while(T--){
		int n;
		int tot=0;//记录最终答案 
		cin>>n;
		for(int i=1;i<=n;i++){
			int a;
			char c;
			cin>>c;
			a=c-'0';
			if(a!=0&&i!=n)//当前位为0或当前位是最后一位，无需移动，否则加一下移动代价 
				tot++;
			tot+=a;//移到最右边后再减a个1 
		}
		cout<<tot<<endl;
	}
	return 0;
}
```












