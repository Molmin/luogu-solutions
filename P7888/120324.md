考虑每个子序列能作为多少个子序列的第一个本质不同非空子序列。

我们钦点第一个子序列为贪心地匹配，即遇到一个要求的字符就加入（即子序列自动机的顺序）。那么，对于子序列 $s$ 中 $s_j=s_i$ 且 $[j+1,i-1]$ 中不存在 $s_i$：我们要求**包含它的子序列**中，该段中间也没有 $s_i$，以此避免算重。

设 $f(i)$ 表示以 $i$ 结尾的子序列能作为**原序列的本质不同序列**。要求中间相同的 $c$ 不能被选入原串的本质不同子序列，可以得到 $f(i)=\sum 2^{i-j-cnt(s_i)}f(j)$，其中 $cnt(c)$ 代表 $[j+1,i-1]$ 中 $s_i$ 的个数。

用前缀和优化。令 $\text{sum}_{c}(i)$ 表示以 $i$ 结尾字符 $c$ 的个数。即可以用前缀和优化：不妨设 $g(c)=\sum_j2^{-j+cnt_c(j)}f(j)$，则 $f(i)=2^{i-cnt_{s_i}(i)}g(s_i)$。时间复杂度 $O(n\Sigma)$。 

```cpp
const int N = 1000006;
const ll P = 1000000007, INV2 = (P + 1) / 2;
char s[N]; int n;
ll p2[N * 2], i2[N * 2];
ll g[26], sum[N][26];

int main() {
	p2[0] = i2[0] = 1;
	scanf("%s", s + 1); n = strlen(s + 1);
	U (i, 1, n) {
		U (c, 0, 25) sum[i][c] = sum[i - 1][c];
		++sum[i][s[i] - 'a'];
	}
	
	U (i, 1, n * 2)
		p2[i] = p2[i - 1] * 2 % P,
		i2[i] = i2[i - 1] * INV2 % P;
	
	U (c, 0, 25) g[c] = 1;
	ll ans = 0, f = 0;
	U (i, 1, n) { int c = s[i] - 'a';
		f = p2[i - sum[i][c]] * g[c] % P;
		(ans += f * p2[n - i]) %= P;
		U (x, 0, 25)
			(g[x] += f * i2[-sum[i][x] + i]) %= P;
	}
	printf("%lld", ans);
}
```