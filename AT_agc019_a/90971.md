## 目前最为详细的题解（不是标题党）

### 1、理解题目

有四个杯子，分别可以装0.25升、0.5升、1升、2升那么多的饮料，而每种杯子各自有单价，然后给你饮料总升数，让你求装完它需要的最小价钱。

注意:所有的数据均为整数。

### 2、突破点&明确思路

突破点：注意注意！所有的数均为整数，也就是说，要装的饮料也是整升整升的。而我们那些0.25升、0.5升的饮料瓶的单价全部可以化为1升的。

- 0.25升的：四个顶一个一升的杯子，故如果把它看做一升的杯子，单价应乘4。

- 0.5升的：两个顶一个一升的杯子，故如果把它看做一升的杯子，单价应乘2。

**接着，我们便可以把所有的单价排序，（两升那个不要急，接着看）然后尽可能地多用单价最便宜的去装即可。**

那两升的那个怎么办？没事，先用一个变量把它存下来，接着除以2加进去排序即可。

- 如果最便宜的是两升的那个，那我们就先用n/2去乘上原价（两升原来的单价）然后再加上（n mod 2）乘第二便宜的。

- 否则就直接用第一便宜的单价乘n即可。

### 3、注意事项

1、岛国题输出末尾要换行！！！

2、由于变量很“感人”，所以要用long long。

### 4、构建代码

就知道你们想看~~

```cpp
#include<iostream>
#include<algorithm>
#include<cmath>
#include<cstdio>
#include<string>
#include<cstring>
#include<cstdlib>
using namespace std;
long long a[5];
long long f[5],n,ss;
int main()
{
  cin>>a[1]>>a[2]>>a[3]>>a[4]>>n;
  f[4]=1;
  ss=a[4];
  a[1]*=4,a[2]*=2,a[4]/=2;
  for(int i=1;i<4;i++)
    for(int j=i;j<=4;j++)
      if(a[j]<a[i]){swap(a[i],a[j]);swap(f[i],f[j]);}
  if(f[1]==1)
    cout<<ss*(n/2)+(n%2)*a[2]<<endl;
  else
    cout<<a[1]*n<<endl;
  return 0;
}//写法不是太好，大佬们勿喷QWQ

```

### 5、本题收获

无论遇到什么样例，都不要怕，微笑的面对它，战胜样例的最好办法就是开long long，坚持才是胜利，加油，奥利给！

【滑稽