**Update: 2020/1/15 ，稍微修改了一下格式和一些小细节**

这题看起来很难，其实是一道结论题

题目要求求出初始边权为 $0$，能否通过操作变为边权为任意值的任何组合  
如果可以，那么我们可以形象的把它当成 先把所有边权变为 $0$，再把边权变为任意值的操作

具体操作如下：

令点 $x$ 的度数为 $d[x]$

若 $d[x]=1$，无限制随便加减，因为只有一条边

若 $d[x]=2$，两条边只能同加同减。虽然可以都变为 $0$，但不能变为任意组合值

若 $d[x]=3$，分两种情况考虑：  
设连接点$x$的三条边权为 $i,j,k$

若 $i+j \le k$：将 $i$ 和 $k$ 同时减去 $i$，再将 $j$和 $k$ 同时减去 $j$，这时 $i=j=0,k=k-i-j$  
我们将剩下的 $k$ 平均分给 $i$ 和 $j$，这时 $k=0,i=j=-\frac{k}{2}$，最后把 $i$ 和 $j$ 同时加上 $\frac{k}{2}$，则 $i=j=k=0$，全部为0后就可以加任意值了

若 $i+j>k$：将 $i,j,k$ 同时减去 $min(i,j)$，我们假设 $j<i$，那么这时 $i=i-j,j=0,k=k-j$  
再把 $i$ 和 $k$ 同时减去 $i$，这时除了 $k$ 其他都为 $0$，最后就跟上面一样的平均分来处理就可以全部为 $0$ 了

若 $d[x]>3$ ，与 $d[x]=3$ 同理  
首先可以三个三个分为一组，每组都不需要其他组的帮助就可以都变为$0$。最后只能剩下两个或一个（若没有剩下说明已经全部为$0$）。这时，我们可以借助已经化为 $0$ 的边来凑成三条边，再用上面的方法继续处理

当边权全部为 $0$ 时，达到任意组合的方法与上同理

代码就很简单啦，直接判断有没有度数为 $2$ 的节点就可以了

```cpp
#include<cstdio>
#include<iostream>
const int Maxn=100000+20,inf=0x3f3f3f3f;
int d[Maxn],n;
inline int read()
{
	int s=0,w=1;
	char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}
	while(ch>='0' && ch<='9')s=(s<<3)+(s<<1)+(ch^48),ch=getchar();
	return s*w;
}
bool check()
{
	for(int i=1;i<=n;++i)
	if(d[i]==2)return 0;
	return 1;
}
int main()
{
	//freopen("in.txt","r",stdin);
	n=read();
	for(int i=1;i<n;++i)
	{
		int x=read(),y=read();
		d[x]++,d[y]++;
	}
	if(check())puts("YES");
	else puts("NO");
	return 0;
}
```