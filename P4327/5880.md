想法：先处理非3倍数的框架，再处理3倍数的框架（覆盖）、

拿第三组样例做个解释

```cpp
对于每一个字母
确定其中心位置并构造框架
.....   .....   ..#..    ..*..
.....   .....   .#.#.    .*.*.
.....==>..A..==>#.A.# 或 *.A.* 
.....   .....   .#.#.    .*.*.
.....   .....   ..#..    ..*..
因为温迪框架必定覆盖在彼得·潘框架上
所以只需先处理彼得·潘框架 
如： 
..#...#.......#..
.#.#.#.#.....#.#.
#.A.#.B.#...#.D.#
.#.#.#.#.....#.#.
..#...#.......#..
再处理温迪框架，原来有#的地方会被*覆盖 
..#...#...*...#..
.#.#.#.#.*.*.#.#.
#.A.#.B.*.C.*.D.#
.#.#.#.#.*.*.#.#.
..#...#...*...#..
解毕（逃 
```

```cpp
#include<iostream>
#include<cstring>
using namespace std;
char a[6][62];string s;
void frame(char c,int y,int x)
{
	a[3][y]=c;
	a[1][y]=a[2][y+1]=a[3][y+2]=a[4][y+1]=a[5][y]=a[4][y-1]=a[3][y-2]=a[2][y-1]=(x?'#':'*');
}
int main()
{
	memset(a,'.',sizeof(a));
	cin>>s;
	for(int i=0;i<s.size();i++)
	{
		if(i%3==2)continue;
		frame(s[i],4*i+3,1);
	}
	for(int i=2;i<s.size();i+=3)
	{
		frame(s[i],4*i+3,0);
	}
	for(int i=1;i<6;i++)
	{
		for(int j=1;j<4*s.size()+2;j++)
		{
			cout<<a[i][j];
		}
		cout<<endl;
	}
}
```