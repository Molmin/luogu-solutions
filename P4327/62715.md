### 争做最简洁最好懂题解！全部代码27行！

看了题解，不少用宏的，这对新手不够友好，还有不少用大量点位操作的，显得很复杂。

实际上，使用string的拼接操作，以每一行作为操作视角，可显著降低模拟复杂度。

观察可知，除第1个字符转换后是5行5列外，其他字符转换后其实都是4列，交界的列是共用的，这也是本题的难点。另外，也不能边转换边打印，因为这样很难形成最终的5行。

分析样例ABCD，可按5-4-4-4划分，正因为最终是5行，并且每次生成的一行字符串基本相同，比如第1行的后续4个字符一直是“.#..”，所以可将每行都视为一个字符串，用整体的string来依次连接。由于第1行与第5行相同，第2行与第4行相同，所以只要考虑前3行就可以了。

当然不同点要注意，有两处。一是逢3个字符的温迪框架下#要改为*，二是在第3行逢3的倍数进行温迪框架转换时，要先把之前末尾的#替换为*，如样例中B的后两位要改#为*，再进行连接。

为降低编程复杂度，直接把每行普通的彼得潘框架和每行特殊的温迪框架存储为对应的string类字符串u和v，在转换时直接调用，而具体的目标字符，则先更新，再拼接。

综上，总体思路是，先把第1个字符转换，并给第1~3行的答案字符串s1~s3赋初值，后续每生成一行4个字符的字符串，就连接到对应行的答案字符串s1~s3上去。进行到特殊的温迪框架时，调用相应的字符串v1~v3；进行到具体的字符转换时，通过点位上的变量赋值直接更新u3或v3，再连接到s3，最终形成5行并打印。

注意防止几个坑：一是第1个字符要5行5列，防止只出现1个字符。二是检查长度是3的倍数，即以温迪框架结尾时是否正常。三是为防止下标调用出错，将源串的首位0位补一个字符。


```cpp
#include <iostream>
#include <cstring>
using namespace std;
int main()
{
    string s, s1, s2, s3, u1, u2, u3, v1, v2, v3;
    s1 = "..#..", s2 = ".#.#.", s3 = "#.A.#"; //第1个字符转换要用的3行
    u1 = ".#..", u2 = "#.#.", u3=".A.#";    //彼得潘框架的后续3行，4字符
    v1 = ".*..", v2 = "*.*.", v3 = ".A.*";  //温迪框架的后续3行，4字符
    cin >> s;//输入待转换字符串
    s = "+" + s; //整体后移1位，下标从1开始
    s3[2] = s[1]; //替换A为待转换字母，到此第1个字符转换完成
    for (int i = 2; s[i]; ++i)//从源串第2个字符开始遍历
        if (i % 3)//下标不是3的倍数，彼得潘框架
        {
            s1 += u1, s2 += u2; //第1~2行
            u3[1] = s[i], s3 += u3; //第3行中间目标字符更新
        }
        else//下标是3的倍数，温迪框架
        {
            s3[s3.size() - 1] = '*';//进行中的第3行目标串末位先改为*
            s1 += v1, s2 += v2; //第1~2行
            v3[1] = s[i], s3 += v3; //第3行中间目标字符更新后再连接
        }
    cout << s1 << endl << s2 << endl << s3 << endl << s2 << endl << s1 << endl;//5行输出
    return 0;
}

```
