此题其实就是一个模拟

但是不好写

我个人的想法是分组

如下图:
```
..#.. .#.. .*.. .#..
.#.#. #.#. *.*. #.#.
#.X.# .X.* .X.* .X.#
.#.#. #.#. *.*. #.#.
..#.. .#.. .*.. .#..
```

第一组有5个字符,之后的每一组都只有4个

很显然,对于第一组,可以用赋初值的方法解决

之后的组,可以分为%3==2的和%3!=2的

然后就是加上了

具体见代码
```cpp
#include <bits/stdc++.h>
using namespace std;
string a[5]={"..#..",".#.#.","#...#",".#.#.","..#.."},c;
//初值,输出如下:
/*
..#..
.#.#.
#...#
.#.#.
..#..
*/
//中间等会填
int main(){
//    freopen("P4327.in","r",stdin);
//    freopen("P4327.out","w",stdout);
	cin>>c;
	a[2][2]=c[0];
    //第一个框架填好
	for (int i=1;i<c.size();i++){
    //c[0]已经填过,所以从1开始
		if (i%3!=2){
			a[0]+=".#..",a[1]+="#.#.";
            //1和2行没有特殊情况,只要是#框架就行
			if (a[2][a[2].size()-1]=='#')a[2]+=".",a[2]+=c[i],a[2]+=".*";//特殊:如果上一个是#框架,那么这一个的下一个一定是*的,所以第3行最后一个字符填*
			else a[2]+=".",a[2]+=c[i],a[2]+=".#";//不然填#
			a[3]+="#.#.",a[4]+=".#..";//3和4行也没有什么特殊的
		}else{
			a[0]+=".*..",a[1]+="*.*.",a[2]+=".",a[2]+=c[i],a[2]+=".*";
			a[3]+="*.*.",a[4]+=".*..";
            //很像填#的,只不过改了一下字符,由于*的优先级高,所以没有任何问题
		}
	}
	if (c.size()%3==2)a[2][c.size()*4]='#';
    //注意!这里是此题的一个坑!如果最后字符个数%3=2,那么我的切片方法就会使得第3行最后一个字符是*!一定要注意!
    //注意!这里是此题的一个坑!如果最后字符个数%3=2,那么我的切片方法就会使得第3行最后一个字符是*!一定要注意!
    //注意!这里是此题的一个坑!如果最后字符个数%3=2,那么我的切片方法就会使得第3行最后一个字符是*!一定要注意!
    //重要的事情说3遍
    //一开始因为这个被卡了2次50 T-T
	for (int i=0;i<5;i++)cout<<a[i]<<endl;//模拟完了,愉快地输出
	return 0;
}/*
理论上如下切片方式也是可行的:
..#. ..#. ..*. ..#..
.#.# .#.# .*.* .#.#.
#.X. #.X. *.X. *.X.#
.#.# .#.# .*.* .#.#.
..#. ..#. ..*. ..#..
但是好像没有我这种方便
*/```