    *********华丽的分割线**************
    这题我们需要找一下规律。
    一个的时候，宽1*3+0+2
    ..*..
    .*.*.
    *.X.*
    .*.*.
    ..*.. 
    2个的时候，宽2*3+1+2
    ..*...*..
    .*.*.*.*.
    *.X.*.X.*
    .*.*.*.*.
    ..*...*..
    3个的时候，宽3*3+2+2
    ..*...*...*..
    .*.*.*.*.*.*.
    *.X.*.X.*.X.*
    .*.*.*.*.*.*.
    ..*...*...*..
    i个的时候，宽i*3+i-1+2
    那么，计算字母的列很简单
    第几个字母*3+2，这里不用加2
    因为最后两列不是字母
    字母行永远是3
    具体见代码  
    
    var a:array[0..1000,0..1000]of char;
    s:string;i,x,j:longint;c:char;
    begin
    readln(s);
    fillchar(a,sizeof(a),'?');  //假设没有放好，全部是？
    for i:=1 to length(s) do
       begin
       x:=i*3+(i-1);     //求出字母的位置
       if i mod 3=0 then c:='*'    //如果是每3个的第3个，要填的框架是温迪框架
       else c:='#';//否则是彼得·潘框架
      a[3,x]:=s[i];//把字母放好
      a[3,x-1]:='.';
      a[3,x+1]:='.';
      a[2,x]:='.';
      a[2,x-2]:='.';
      a[2,x+2]:='.';
      a[4,x]:='.';
      a[4,x-2]:='.';
      a[4,x+2]:='.';
      a[1,x-2]:='.';
      a[1,x-1]:='.';
      a[1,x+1]:='.';
      a[1,x+2]:='.';      //把‘.’的位置解决了
      a[5,x-2]:='.';
      a[5,x-1]:='.';
      a[5,x+1]:='.';
      a[5,x+2]:='.';//如果是没放过，或者是彼得·潘框架，那么就要放，有时要覆盖
      if(a[1,x]='?')or(a[1,x]='#') then a[1,x]:=c;
      if(a[2,x-1]='?')or(a[2,x-1]='#') then a[2,x-1]:=c;
      if(a[2,x+1]='?')or(a[2,x+1]='#') then a[2,x+1]:=c;
      if(a[3,x-2]='?')or(a[3,x-2]='#') then a[3,x-2]:=c;
      if(a[3,x+2]='?')or(a[3,x+2]='#') then a[3,x+2]:=c;
      if(a[5,x]='?')or(a[5,x]='#') then a[5,x]:=c;
      if(a[4,x-1]='?')or(a[4,x-1]='#') then a[4,x-1]:=c;
      if(a[4,x+1]='?')or(a[4,x+1]='#') then a[4,x+1]:=c;
      end;
    for i:=1 to 5 do
      begin         //输出
      for j:=1 to length(s)*3+length(s)-1+2 do
        write(a[i,j]);         //计算有几列
      if i<>5 then writeln;    //换行，最后一行不能在换行了
      end;
    end.