## $ \texttt{CF949B} $  

---

### 题意：  

有一个长度为 $ 2n $ 的数组，第 $ 2i-1 $ 个位置上有数 $ i,1\le i\le n $  

每次将数组中最后一个数向前移动到第一个空位，询问 $ q $ 次最终数组第 $ x $ 位的值  

---

### 思路：  

发现每个数都要等到后面全是空位时才会移动位置，所以数组的前 $ n $ 位会保留初始状态  

那么我们就只需要考虑后面的数跳到前 $ n $ 位中的空位上的顺序  

看看 $ n=6 $ 的情况：  

$ 1\ 4\ 2\ 6\ 3\ 5\ 4\ 6\ 5\ 6\ 6 $  

上面的数组显示了整个移动的过程  

去除掉初始位置上的数：  

$ .\ 4\ .\ 6\ .\ 5\ .\ 6\ .\ 6\ . $  

我们看三个 $ 6 $ 之间的距离分别是 $ 4,2 $，不妨猜想每次间隔距离减半  

很容易发现这个结论是正确的，因为从后面往前移，每次移动会把最后面的 $ y $ 个数塞到这 $ y $ 个数前面的 $ y $ 个数中间，形成一段 $ 2y $ 个数，所以对应数的移动距离也是每次变为两倍  

那么问题就解决了，对于询问的位置，如果是奇数位，直接输出，否则每次向后跳跃，直到跳跃长度为奇数为止  

由于跳跃距离每次除以 $ 2 $，所以单次询问最劣复杂度为 $ O(\log n) $  

总复杂度 $ O(q\log n) $，可以通过  

---

### 代码：  

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;//1e18开long long
ll n, x;
int q;
int main() {
	ll T1, T2;
	scanf("%lld%d", &n, &q);
	while (q--) {
		scanf("%lld", &x);
		if (x % 2 == 1) {
			printf("%lld\n", (x + 1) / 2);//奇数位是没有移动的
			continue;
		}
		T1 = x;
		T2 = n + x / 2 - x;//第一次跳跃距离可以直接求出
		while (T2 % 2 == 0) {//跳到跳跃距离为奇数
			T1 += T2;
			T2 /= 2;//每次跳跃距离除以2
		}
		T1 += T2;//别忘了跳最后一次
		printf("%lld\n", (T1 + 1) / 2);//跳到对应位置后即可求出答案
	}
	return 0;
}
```
