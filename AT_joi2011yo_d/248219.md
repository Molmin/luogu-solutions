题目中没有样例 （~~其实点到AT2486里面就能看到了~~），那就给一个吧。
```
Input

11
8 3 2 4 8 7 2 4 0 8 8

Output

10
```
对于这个样例，有以下10种方法使等式成立
```
    8+3−2−4+8−7−2−4−0+8=8
    8+3−2−4+8−7−2−4+0+8=8
    8+3+2+4−8−7+2−4−0+8=8
    8+3+2+4−8−7+2−4+0+8=8
    8+3+2−4+8−7+2+4−0−8=8
    8+3+2−4+8−7+2+4+0−8=8
    8−3+2+4−8+7+2+4−0−8=8
    8−3+2+4−8+7+2+4+0−8=8
    8−3+2−4+8+7+2−4−0−8=8
    8−3+2−4+8+7+2−4+0−8=8
```
看到时间限制的时候想的是递归，结果还是TLE（~~是我太蒻了~~）。所以还是老老实实用DP吧。

dp[i][j] 转移前i个数得到结果j方案数

可以得到转移式(这里将输入数据记为a[i])

```cpp
	dp[i][j-a[i]]+=dp[i-1][j]
	dp[i][j+a[i]]+=dp[i-1][j]
```
最后输出 dp[n-1][a[n]]即可

上代码

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long int ll;

ll dp[110][21];

int main(){
	int n; cin >> n;
	vector<int> a(n+1);
	for(int i=1;i<=n;i++){
		cin >> a[i];
	}
	dp[1][a[1]]=1;
	for(int i=1;i<n-1;i++){
		for(int j=0;j<=20;j++){
			if(dp[i][j]==0)continue;
			if(j+a[i+1]<=20){
				dp[i+1][j+a[i+1]]+=dp[i][j];
			}
			if(j-a[i+1]>=0){
				dp[i+1][j-a[i+1]]+=dp[i][j];
			}
		}
	}
	cout << dp[n-1][a[n]] << endl;
}
```
