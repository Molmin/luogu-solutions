历经一下午+一晚上+半个上午终于切掉。。。

一道LCT好题，重点是维护什么信息和各种细节的处理。

一开始是想用LCT维护一下三个儿子，用类似于虚子树的东西更新自己。不过这样会出现一个问题：

![](https://cdn.luogu.com.cn/upload/pic/51666.png)

比如说这是x、x所在的实链的splay、x的两个虚儿子，z是x的实儿子。注意在本题中，每个点必须**直接**由它的三个儿子更新。但是z的信息先经过了y才进一步更新了x，就会导致信息不准确。

换一种思路。先想一种暴力些的做法：

修改一个点，它的权值变了，它的父节点就有可能改变，那就向上走看一下它的父节点是否需要更新。如果父节点权值会变，那么它的祖父就有可能会变。如此一直走，直到走到根或某个祖先不会改变权值，停止。

不过，这种做法会被构造的树给卡掉（比如把非叶子节点排成一条链，复杂度就会退化成$O(mn)$）。它的瓶颈就在于向上走的过程，复杂度直接由树高决定。那么如果知道每个点走到哪会停就好了。

考虑走到哪里会停，即什么样的节点不会被修改。

首先容易想到三个儿子都是同样的颜色的节点不会被更新。于是~~愉快地~~去敲代码，然而写了对拍始终不过。

还少情况。上图直观来看：

![](https://cdn.luogu.com.cn/upload/pic/51668.png)

比如我要改点x，同样对k无影响。也就是说：

假设我要改一个本来为0的点，那么它的祖先中为1的点就不会被改（改0点只会让1更多，则为1的点就不可能被改了）

造个LCT，每个点维护一下深度最大的权值为0的点、为1的点、儿子是同一种权值的点，修改时打通到x的实链，根据x的权值取一下深度最大的点（假设为y），对x到y进行修改。

在维护第三种情况时我用的方法是：把0看作-1，dfs预处理好每个点权值之和（儿子为负就-1，为正就+1）。这样权值为3/-3的就是满足这个条件的点。修改链时用加法修改即可。

最后是注意细节，维护的东西比较神奇，注意好每个地方对这三个值的影响，及时修改。

时间复杂度：$O(nlog{n})*\text{LCT巨大的常数}$

（仅提供思路，就不放我~~丑陋无比、常数巨大、极其复杂、连我自己都看不懂~~的代码了）