印象中好像是唯一一道自己做对的除背包以外的线性DP题（~~我太菜了QAQ~~），因此想写篇题解纪念一下

# 题目大意

[题目传送门](https://www.luogu.com.cn/problem/CF163A)

翻译有点问题，我这里重新翻一下

大概意思就是说，给你两个字符串$s$和$t$，求出有多少对字符串$x$和$y$，满足$x$是$s$的子串且$y$是$t$的子序列，答案对$1000000007(10^9+7)$取模

关于子串和子序列的区别，可以理解为子串是一段连续的区间，而子序列则不一定是连续的

# 思路

这道题乍一看其实很像最长公共子序列，唯一不同的在于对于$s$要取它的子串，我们类比一下最长公共子序列的状态转移方程

$$dp[i,j]=\begin{cases}0\ (i=0 \text{ or }j=0)\\dp[i-1,j-1]+1\ (s[i]=t[j])\\\max(dp[i-1,j],dp[i,j-1])\ (s[i]\not =t[j])\end{cases}$$

$dp[i,j]$表示的是在$s$的前$i$个字符和$t$的前$j$个字符中的最长公共子序列的长度，因此，对于这道题，我们不妨设$dp[i,j]$为**以**$s$**的第**$i$**个字符为结尾的子串与**$t$**的前**$j$**个字符中的子序列相同的个数**，同样，我们分成两种情况来讨论，一种是$s[i]=t[j]$，一种是$s[i]\not =t[j]$

如果$s[i]=t[j]$，那么当前状态首先应该包括了$dp[i-1,j-1]$的所有情况，因为这两个字符是相同的，那么我们相当于是可以在$dp[i-1,j-1]$的所有情况后面加上一个相同的字符，结果一定还是成立的，然后还应该包括$dp[i,j-1]$的所有情况，因为不管当前两个字符是否相同，$dp[i,j-1]$的所有情况肯定都适用于$dp[i,j]$，最后，$dp[i,j]$还应该包括$s[i]$和$t[j]$这对组合，因为很明显前面两种情况都没有把$t[j]$算进去，所以最后的状态转移方程应该是这样的

$$dp[i,j]=dp[i,j-1]+dp[i-1,j-1]+1$$

如果$s[i]\not = t[j]$，那么上面所说的$dp[i-1,j-1]$的情况就不适用于当前情况，也没有$s[i]$和$t[j]$这对组合，所以状态转移方程就是这样的

$$dp[i,j]=dp[i,j-1]$$

最后，由于$dp[i,j]$只统计了以$s[i]$为结尾的子串，所以最终答案应该把所有的$dp[i,|s|]$加起来，另外，不要忘记取模

# 参考代码

```cpp
#include<bits/stdc++.h>
#define mod 1000000007
using namespace std;
string a,b;
int n,m,ans,dp[5001][5001];
int main()
{
	getline(cin,a);
	getline(cin,b);
	n=a.length();
	m=b.length();
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			if(a[i-1]==b[j-1])
				dp[i][j]=(dp[i][j-1]+dp[i-1][j-1]+1)%mod;//取模！！
			else
				dp[i][j]=dp[i][j-1];
	for(int i=1;i<=n;i++)
		ans=(ans+dp[i][m])%mod;
	printf("%d",ans);
	return 0;
}
```

