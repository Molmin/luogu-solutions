## UVA10813 Traditional BINGO
[原题链接](https://www.luogu.com.cn/problem/UVA10813)
首个通过，首篇题解。
## 题意
在 $5\times 5$ 的矩阵里填入 $1\sim 75$ 的数字，中间一格为空，给出一组数字的排序，在矩阵里做标记，出现某行、某列、某对角线全被标记结束，询问取第几个数字时结束。

多组数据，首行输入数据总数，接下来的五行中，第三行包含 $4$ 个数字；其余包含 $5$ 个，接下来一行或多行，表示 $75$ 个数字的排序。所有的数字都是 $1$ 到 $75$ 之间的整数。

输出每组数据中，在取第几个数字时结束。

## 分析
一个桶记录矩阵中出现的数字，用到了一个二维数组，将其元素全部置为 $-1$，```x[a[i][j]][0]``` 用来记录当前矩阵中数字所在行，```x[a[i][j]][1]``` 用来记录当前矩阵中数字所在列。由于存在多组数据，需要对数组初始化操作。

输入数字的排序后依次判断桶中值是否为 $-1$，如果不是则该数字在矩阵中出现过，在矩阵中标记为零。一个函数判断每行、每列、两条对角线是否被标记，如果满足任意一个条件输出取第几个数字时结束，跳出标记和判断的循环，读入下一组数据。

读入前应将矩阵中间一格数字置为 $0$，读入时跳过中间数字。

## Code
```cpp
#include<iostream>
#include<cstdio> 
#include<string.h>
using namespace std;
int a[6][6],x[80][2],b[80];
bool right(){
	for(int i=0;i<5;i++){
		if(!a[i][0]&&!a[i][1]&&!a[i][2]&&!a[i][3]&&!a[i][4]||
		   !a[0][i]&&!a[1][i]&&!a[2][i]&&!a[3][i]&&!a[4][i]){
		   	return 1; //判断每行每列是否被标记 
		}
	}
    	if(!a[0][0]&&!a[1][1]&&!a[3][3]&&!a[4][4]||
	       !a[0][4]&&!a[1][3]&&!a[3][1]&&!a[4][0]){
		    return 1;  //判断两条对角线是否被标记
	}
    return 0;
}
int main(){ 
    int n;cin>>n;
    while(n--){
    	memset(x,-1,sizeof(x)); //初始化 
    	a[2][2]=0; //中间一格为空 
        for(int i=0;i<5;i++){
            for(int j=0;j<5;j++){
            	if(i==2&&j==2) j++; //跳过中间一格 
                cin>>a[i][j];
                x[a[i][j]][0]=i; //入桶，记录行 
                x[a[i][j]][1]=j; //入桶，记录列 
			}
		}
		for(int i=0;i<75;i++) cin>>b[i];
		for(int i=0;i<75;i++){
            if(x[b[i]][0]!=-1&&x[b[i]][1]!=-1) //b[i]在矩阵中出现过 
				a[x[b[i]][0]][x[b[i]][1]]=0; //在矩阵中标记 
			if(right()){ //满足任意一个条件 
            	printf("BINGO after %d numbers announced\n",i+1);
                break;
            }
        }
    }
    return 0;
}
```
