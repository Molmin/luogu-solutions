**题目：**
- 某AI石头剪刀布软件，按照你输入的顺序出手势，但你不确定它从顺序哪里开始（例如输入 ```RPRPRP```
，可能从第 $2$ 个字符 $P$ 开始，也可能从第 $1$ 个字符 $R$ 开始），让你确定一种方案**保证**能赢的把数最多。

**分析：**

- 题目要求保证胜场最多，就要考虑变换顺序的情况。

- 输入字符串为 ```RSP```，如果假定AI按此方法出手势，那么最优招为 ```PRS```，结果为 $0:3$，但如果AI的顺序是 ```SPR```，那么再用 ```PRS``` 的招数，将会 $3:0$，**爆零，变为更差的结果**，而……
- 还有另外一种可以**保证**胜率的策略！——全出一样的！不过这时，我们还需要验证……

- 如果每一次出的拳都一样，那么即使怎样变换顺序，都不会对结果有任何影响。

- 这样，只要找到AI的顺序里面出现次数最多的手势，再输出能打败他的手势就可以啦（能保证的胜率最高，至少 $33.3\%$）,回过头来看，如果是对于某一特定AI顺序制定策略，虽然这种顺序下可以达到 $100\%$ 的胜率，但如果它变换一下顺序，就一定会让你的某一步的对阵发生变化，从而降低胜率；而此胜率，正好是全出一样时的保证胜率。
 
证明结束~~~
（先把代码贴上）

[神奇的AC](https://www.luogu.com.cn/record/78489148) code：
```
#include<bits/stdc++.h>
using namespace std;
inline int maxx(int a,int b,int c){
    return max(a,max(b,c));
}
int main(){
    int T;
    cin>>T;
    while(T--){
        char c[200005];
        cin>>c;
        int a1=0,a2=0,a3=0,a4=strlen(c);
        for(int i=0;i<strlen(c);i++){
            if(c[i]=='R')a1++;
            if(c[i]=='S')a2++;
            if(c[i]=='P')a3++;
            if(i==strlen(c)-1){
                if (a1==maxx(a1,a2,a3)){
                    while(a4--)cout<<'P';
                }
                else if (a2==maxx(a1,a2,a3)){
                    while(a4--)cout<<'R';
                }
                else if (a3==maxx(a1,a2,a3)){
                    while(a4--)cout<<'S';
                }
            }
        }
        cout<<endl;
    }
}
```

本蒟蒻的第二篇题解啦~~~