# 题面

[题目传送门](https://www.luogu.com.cn/problem/P9355)

**题目大意：**

有一个 $n$ 行 $m$ 列的棋盘，每次放一个棋子，分数就加上它相邻四周没有放棋子的个数，问怎么在每一步都最优的情况下使分数最大。

# 思路

首先捏一组样例，设 $n=m=3$，我们先来看看我们脑海中第一个想到的最优解：先填中间，然后填四个顶点，最后把剩下的填了，因为这样似乎每一步都走到了最多分数的点，也就是贪心思想，总和为 $4+2+2+2+2+0+0+0+0=12$，我们再来看看直接一个一个从左上到右下填又会是怎样的：$2+2+1+2+2+1+1+1+0=12$。

等等，这咋一样的叻？

我们在填的过程中可以发现：第一个方法是把互不相干的点都填上，可最后其他的点被迫放在四个点之间，没分；第二个方法是只一个一个地填，虽然加的分少，但点多。好像这两个方法刚好对立但又似乎一样。再从式子里面看：第二个方法单独加的只有一口气的点刚好可以组成一个四口气的点，其它两口气的点又是一模一样的。假如我们只考虑两个相邻的点，我们发现无论先填哪个点最后的分数都是一样的，也就是说填的方法和最终的结果是互不影响的！也就是说，只要把所有的点都填一遍便能得出最终答案了。

利用第二种方法，我们知道除了最后一行及最后一列，其它所有的格子加的分都是 $2$，而最后一行除了最后一个及最后一列除了最后一个加的分都是 $1$，最右下角的 $0$ 不用管，得出 $n$ 行 $m$ 列的棋盘的答案为：
$$2(n-1)(m-1)+(n-1)+(m-1)$$

# 代码

```cpp
#include<bits/stdc++.h>
#define int long long//10^8需要相乘记得开long long
using namespace std;
int t,n,m;
signed main(){
    scanf("%lld",&t);
    while(t--){
        scanf("%lld%lld",&n,&m);
        printf("%lld\n",2*(n-1)*(m-1)+(n-1)+(m-1));//套公式
    }
    return 0;
}
```