此题是一个博弈游戏，所以我们从最优策略的角度分析。

------------

## 题目分析

此题不同于一般的博弈，因为双方的游戏目标不同。那我们是要分析先手还是后手呢？

作为后手，需要考虑先手后面的操作序列能造成哪些影响，不能贪心地往棋盘中间走。

```
2 5 4
2 2
URRR
RUDU
```

这组数据中，后手如果贪心走到第三列，那么先手往右走三次就能获胜；但第一回合选择不走，先手就移不出棋盘。

而先手就好考虑了，我们先给出结论 : **先手不会向两个相反方向都进行过移动。**

如果这样移动了，那么相反方向移动互相抵消，带来的移动效果不如只朝一个方向，而为了移出棋盘，朝一个方向走得越多，就越有利。因此我们枚举先手始终走哪两个方向，就能确定每一回合是否进行移动。这四种方向的选择中一定有最优策略。

在先手这样的最优操作下，后手就应尽力走与先手相反的方向，例如先手只走 U 和 R，后手就只走 D 和 L。尽量抵消先手的影响，当然，是在不走出棋盘的条件下。

### hack:

```
10000 7 10
5000 4
UUULRRRRRR
LLLDDDDDDD
```

答案应为 `NO`，这是为什么呢？

第三回合若后手往左移动，下一步先手能移出棋盘，所以在上述策略下，第三回合不能移动。因此，我们维护序列每个方向先手与后手抵消后效果的前缀和，若移动后接下来可能的效果能让先手移出棋盘，则后手不移动。

## 代码实现

枚举四个方向，按照上述的策略模拟每次移动，若有一种方向组合能移出棋盘，输出 `YES`，否则输出 `NO`。AtCoder 上的所有题记得换行。
## Code:
```
#include<cstdio>
#include<cstring>
#define N 200010
int n,m,k,x,y,xn,yn,c1[N][4],c2[N][4];//用这类变量名就不要用cmath
char s1[N],s2[N],d[]={'U','D','L','R'};
int main(){
	scanf("%d%d%d",&n,&m,&k);
	scanf("%d%d",&x,&y);
	scanf("%s%s",s1+1,s2+1);
	for(int i=1;i<=k;i++){
		for(int j=0;j<4;j++){
			c2[i][j]=c2[i-1][j];
			if(s2[i]==d[j])c2[i][j]++;//记录移动序列前缀和
			if(s1[i]==d[j^1])c2[i][j]--;
		}
	}
	xn=x,yn=y;//模拟每种方向组合的操作
	for(int i=1;i<=k;i++){
		if(s1[i]=='U')xn--;
		if(s1[i]=='L')yn--;
		if(xn<1||yn<1){
			printf("NO\n");
			return 0;
		}
		if(s2[i]=='D'&&xn+1+c2[k][1]-c2[i+1][1]<=n)xn++;//确保后面不被先手往同一方向移出
		if(s2[i]=='R'&&yn+1+c2[k][3]-c2[i+1][3]<=m)yn++;
	}
	xn=x,yn=y;
	for(int i=1;i<=k;i++){
		if(s1[i]=='D')xn++;
		if(s1[i]=='L')yn--;
		if(xn>n||yn<1){
			printf("NO\n");
			return 0;
		}
		if(s2[i]=='U'&&xn-1+c2[k][0]-c2[i+1][0]>=1)xn--;
		if(s2[i]=='R'&&yn+1+c2[k][3]-c2[i+1][3]<=m)yn++;
	}
	xn=x,yn=y;
	for(int i=1;i<=k;i++){
		if(s1[i]=='U')xn--;
		if(s1[i]=='R')yn++;
		if(xn<1||yn>m){
			printf("NO\n");
			return 0;
		}
		if(s2[i]=='D'&&xn+1+c2[k][1]-c2[i+1][1]<=n)xn++;
		if(s2[i]=='L'&&yn-1+c2[k][2]-c2[i+1][2]>=1)yn--;
	}
	xn=x,yn=y;
	for(int i=1;i<=k;i++){
		if(s1[i]=='D')xn++;
		if(s1[i]=='R')yn++;
		if(xn>n||yn>m){
			printf("NO\n");
			return 0;
		}
		if(s2[i]=='U'&&xn-1+c2[k][0]-c2[i+1][0]>=1)xn--;
		if(s2[i]=='L'&&yn-1+c2[k][2]-c2[i+1][2]>=1)yn--;
	}
	printf("YES\n");
	return 0;
}
```