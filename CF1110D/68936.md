## 状态定义

作为一个dp初学者，费了不少力气才定义出状态来。

讲一下过程:

定义$dp[i]$为到位置$i$为止，最多能够形成多少个triplet。

显然这点信息是不够的。因为对于dp而言，有一个重要的性质:

**只要我们对于每一个状态记录它是从哪个状态转移来的，我们就能从最终状态步步向前，推出整个最优解。**

*一道加深对这个性质的理解的[题目](https://atcoder.jp/contests/dp/tasks/dp_f)*

也就是说，如果从$dp[n]$向前，对于每一个$i$，我们都知道组成了多少个$[i, i + 1, i + 2]$，多少个$[i, i, i]$。

为了知道我们对于每个$i$组成了多少$[i, i + 1, i + 2]$，显然我们需要把这个参数包含进我们的状态，也就是说我们的状态至少是$dp[i][t_i]$，其中$t_i$指的是$[i, i + 1, i + 2]$的数量。

那么$[i, i, i]$的数量呢?

显然不需要，因为在已经知道了$[i, i + 1, i + 2]$的情况下为了尽可能的多的形成triplet，肯定是能组成多少个triplet就组成多少个。

观察到$3$个$[i, i + 1, i + 2]$等同于$[i, i, i], [i + 1, i + 1, i + 1], [i + 2, i + 2, i + 2]$。因此$\forall t_i, t_i \in [0, 2]$。

那么$dp[i][t_i] = \max(dp[i - 1][t_{i - 1}] + l + \frac{cnt[i] - l}{3})$，$l$代表我们取$l$个$i + 2$，与剩下的$i$和$i + 1$结合。

**可是这样还需要知道剩下多少$i$和$i+1$才行啊。**

也就是说$dp[i - 1][t_{i-1}]$还应该包括$[i - 1, i, i + 1]$的个数。

于是，将状态定义为$dp[i][t_i][t_{i-1}]$。

为什么不多加别的状态了呢?

因为我们只需要用到$i, i + 1, i + 2$的个数。

有$t_{i - 1}$已经足够确定剩下多少$i$和$i + 1$了。

关于$t_{i - 2}$，它确实会影响$i$的个数。

但是考虑到递推式一定是形如$dp[t_i][t_{i - 1}] = \max(dp[t_{i - 1}][t_{i - 2}])$的形式，显然$t_{i - 2}$一定会影响$t_i$的上限，所以不需要将它列为状态中的变量。

### 关于\[i, i, i]

组成了$t_{i-1}$个$[i-1, i, i+1]$之后，还剩下$cnt[i] - t_{i-1}$个$i$，$cnt[i + 1]-t_{i-1}$个$i+1$。

于是我们最多可以取$\min(cnt[i] - t_{i-1}, cnt[i + 1] - t_{i - 1}, cnt[i + 2])$个$[i, i + 1, i + 2]$。

然后下一个问题，$[i, i, i]$要怎么统计有多少个?

这个貌似还挺简单的。只要在递推式里取完当前项的$[i, i, i]$之后，之后的部分就不用再考虑$[i-1, i-1, i-1]$之类的了。

既然是尽可能的多，那么取完$[i, i + 1, i + 2]$后，就只有一个选择了: 全部取走，拿去做$[i, i, i]$。

为什么这个贪心是正确的呢? 万一不全部取走可能有更好的方案呢?

考虑到我们可以枚举我们取了多少个$t_i$和$t_{i-1}$，显然所有情况都被包含了。

不全部取走显然就是等着给以后的triplet让位。那只要我们少取一点$t_i$和$t_{i-1}$，就可以达到同样的目标。

于是我们就可以不用考虑$[i, i, i]$了。

## 递推式

最后，根据上述讨论来推出递推式:

$dp[i][t_i][t_{i-1}] = \max\limits_{0 \le t_i \le \min(2, cnt[i] - t_{i-1} - t_{i-2}, cnt[i+1]-t_{i-1}, cnt[i+2])}(dp[i][t_i][t_{i-1}], dp[i - 1][t_{i-1}][t_{i-2}] + t_i + \frac{cnt[i]-t_i-t_{i-1}-t_{i-2}}{3})$

接下来考虑*初始化*。

因为这是从$i$推到$i + 1$，所以应该是在$dp[1]$做初始化。

对于$dp[1][0][0]$，它会访问$dp[0][t_0][t_{-1}]$，这些都应该是$0$。

因为全局数组默认全为$0$，所以可以省略初始化了。

然后考虑怎么*获取答案*。

对于$dp[m]$，一共$3 \times 3$个子状态全部跑一遍，提取最大值，应该就可以了。

好，已经有了这些之后，就开始写代码吧。

在写之前，把递推式的变量名改得好写点:

$dp[i][c][b] = \max\limits_{0 \le c \le \min(2, cnt[i] - b - a, cnt[i+1] - b, cnt[i+2])}(dp[i][c][b], dp[i - 1][b][a] + c + \frac{cnt[i]-c-b-a}{3})$

实际上在代码里面，$\min(2, cnt[i] - b - a, cnt[i + 1] - b, cnt[i + 2])$可以写成如下形式:

```c++
for (int a = 0; a < 3; ++a) {
    if (a + b + c > cnt[i]) continue;
	if (b + c > cnt[i + 1]) continue;
	if (c > cnt[i + 2]) continue;
    // ...
}
```
## AC代码

```c++
#include <cstdio>
#include <algorithm>
using namespace std;

int cnt[1000010];
int dp[1000010][3][3];
int n, m, temp;

void solve() {
    for (int i = 1; i <= m; ++i) {
        for (int c = 0; c < 3; ++c) {
            for (int b = 0; b < 3; ++b) {
                for (int a = 0; a < 3; ++a) {
                    if (a + b + c > cnt[i]) continue;
                    if (b + c > cnt[i + 1]) continue;
                    if (c > cnt[i + 2]) continue;
                    dp[i][c][b] = max(dp[i][c][b], dp[i - 1][b][a] + c + (cnt[i] - c - b - a) / 3);
                }
            }
        }
    }
}

int main() {
    scanf("%d%d", &n, &m);
    for (int i = 0; i < n; ++i) {
        scanf("%d", &temp);
        ++cnt[temp];
    }

    solve();

    printf("%d\n", dp[m][0][0]);
    return 0;
}
```
