**作为一个蒟蒻，本人在看这道题的其他题解时有一些我不理解的地方。在理解了之后，希望其他和我有一样问题的同学可以明白**
### （弱弱地在这里推荐大家先看__DICS 的题解 大佬NB！）
首先对于这道题大部分人最基本的动规想法应该是用F[i]
表示前i个数的三元组的个数最大值。但我们可以想到这并不满足最优子结构的特性。
那么对于f[i]以第i个数为结尾的三元组的个数最大值，我们只需要考虑它的第i-1与第i-2的数能否满足最优

于是
## 一 解决‘三元组中的元素是相同的’
那么观察到3个[i, i + 1, i + 2][i,i+1,i+2]等同于[i, i, i], [i + 1, i + 1, i + 1], [i + 2, i + 2, i + 2][i,i,i],[i+1,i+1,i+1],[i+2,i+2,i+2]

也就是说我们只需要在满足连续三元组尽可能大的前提下（直到有一个数为0）最后计算即可。
## 二 确定状态转移方程
刚才已经说了我们只需要考虑它的第i-1与第i-2的数能否满足最优。

那么首先dp数组再开一维f[i][j],其中j 指的是[i, i + 1, i + 2]的数量。

但是对于尾序列[i,i+1,i+2],我们在知道i+2数量的同时，这样还需要知道剩下多少i和i+1才行。

所以（重点）就需要把我们的dp数组再开一维将状态转为f[i][j][k] k表示[i-1,i,i+1]三元组的个数（爆不了+好想）

为什么不多加别的状态了呢?

因为我们只需要用到i, i + 1, i + 2的个数。

f[i][j][k]中的k已经足够确定剩下多少i和i+1了。

对于第i-2个数它确实会影响i的个数。

但是考虑到递推式一定是形如dp[t_i][t_{i - 1}] = max(dp[t_{i - 1}][t_{i - 2}])的形式，显然t{i - 2}一定会影响ti  的上限，所以不需要将它列为状态中的变量。

（本段引自__DICS的题解）[传送门](https://www.luogu.org/blog/dics/solution-cf1110d)

最后列出状态转移方程

f[a][c][d]=max(f[a][c][d],f[a-1][b][c]+d+(num[a]-b-c-d)/3);

这里a表示循环到了第i个数

b表示尾序列[i,i+1,i+2]中的i；

c表示尾序列[i,i+1,i+2]中的i+1;

d表示尾序列[i,i+1,i+2]中的i+2;

其实循环顺序并不重要，就是3*3状态扫一遍，怎么写都能AC

最后输出f[m][0][0] 表示我们在以M为结尾的序列中没有以i为非尾元素的三元组（i+1与i+2没有了啊)

最后AC代码



```cpp
#include<cstdio>
#include<iostream>
using namespace std;
int n,m,num[1000001],k,f[1000001][3][3];
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++){
	scanf("%d",&k);
	num[k]++;	
	}
	for(int a=1;a<=m;a++)
		for(int b=0;b<3;b++)
			for(int c=0;c<3;c++)
				for(int d=0;d<3;d++){
					if(num[a]<b+c+d)
					continue;
					else{
						f[a][c][d]=max(f[a][c][d],f[a-1][b][c]+d+(num[a]-b-c-d)/3);
					}
				}
	printf("%d",f[m][0][0]);
	return 0;
}
```



