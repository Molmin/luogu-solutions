## [题 目 传 送 门](https://www.luogu.com.cn/problem/CF276B)

### [题意解析]
有**两**个玩家，一个字符串 $s$，玩家可以轮流从字符串 $s$ 中删去一个字符。如果某个玩家在他的回合可以将字符串 $s$ 重新排列成一个回文串，那么这个人就赢了。两位玩家用的都是最优策略，问第一位玩家是否有必胜策略。

### [思路分析]
回文有两种情况：

1. 例如一个回文字符串 $\verb!abcba!$，它的字符个数是**奇数**个，所以总是会有一个只出现 $1$ 次字母。

2. 例如一个回文字符串 $\verb!abccba!$，它的字符个数就是**偶数**个，所以所有出现过的字符，都会出现偶数次，不会出现奇数次。

结合以上两种情况，我们能发现：

+ 如字符串长度为偶数，且其中一个字母出现了奇数次，输出 $\verb!Second!$。
+ 否则输出 $\verb!First!$。

### **[贴上代码]**
```cpp
#include<bits/stdc++.h>
using namespace std;
char s[10010];
map<char,int>mp;
/*见好像没人用 STL 那就我来用吧*/
int main()
{
	cin>>(s+1);
	int n=strlen(s+1);
	/*求出字符串长度*/
	for(int i=1; i<=n; i++)mp[s[i]]++;
	/*以字符作为下表*/
	for(char i='a'; i<='z'; i++){/*所以 i 是 char 类型，从 a 到 z*/
		if(mp[i]%2==1&&n%2==0){cout<<"Second";return 0;}
		/*如字符串长度为偶数,且其中一个字母出现了奇数次*/
	}
	cout<<"First";
	return 0;
}
```
