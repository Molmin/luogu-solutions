本题做法：**博弈论**。

## 题目描述

给定一个只包含小写字母的字符串 $s$，两个人轮流从中删去一个字母，如果某个人在他的回合前可以将字符串 $s$ 重新排列成一个回文串，那么这个人就赢了。如果两个人都采取最优策略，问最先开始的人是否有必胜策略。

## 题解

如果一个回文串只有最多一个字母出现了奇数次，那么这个回文串就可以重新排列成一个回文串。譬如，字符串 `aabbbcc` 可以重新排列成回文串 `abcabc`。

如果有两个及以上的字母出现了奇数次，那么无论如何都不能重新排列成回文串。例如，字符串 `aabbcc` 不可能成为回文串。

我们可以用一个桶来统计每个字母出现的次数，然后统计出现奇数次的字母数量，设其为 $odd$。

如果 $odd=0$，则说明每个字母都出现了偶数次，则说明第一个人获胜；如果 $odd$ 为奇数，则说明有奇数个字母出现了奇数次。此时最后一个删去字母的人胜利，即后手必胜；否则最先开始的人胜利，即先手必胜。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
string s;
int cnt[26];
int odd;
int main()
{
    cin>>s;
    for (int i=0;i<s.size();i++) cnt[s[i] - 'a'] ++ ;

    for (int i=0;i<26;i++)
        if (cnt[i] % 2) odd++; 
    if (!odd||odd%2) cout<<"First";
    else cout<<"Second";
}

```
