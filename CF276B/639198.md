# 题面

[题目传送门](https://www.luogu.com.cn/problem/CF276B)

**题目大意：**

给定一个字符串，两个人轮流删字符，如果到某一方时用字符串里的所有字符可以构成回文串的话，那个人就赢了。给定初始字符串，若双方都采用最优方案，问最后谁会胜利？

# 思路

我们先得知道一个字符串能构成回文串的特征。能构成回文串只有两种可能：

第一种是**最中间有单独一个字符，与它形成回文的另一个字符是自己**。例如 $\verb!abcba!$ 最中间的那个字符是 $\verb!c!$。

第二种则是**所有出现过的字符都是偶数个的**。例如 $\verb!cadccdac!$ 就属于这种。

那么知道了这两个特征就能很容易地写出代码了。用一个桶统计每个字符出现的个数，如果所有字符都出现偶数个的话（属于第二种特征回文），那么初始字符串就是能构成回文，先手赢。如果出现奇数次字符有奇数个的话，那么先手也必赢。为什么？因为每次双方都采用最优策略，先手只要把所有奇数个的字符都删掉一个，就能构成第二种特征回文，就算后手一直捣乱删偶数个数的字符，先手也永远比他快一步，所以一直能赶在他前面抢到能构成回文的字符串。如果这两个条件都不符合的话，则是后手必赢了。

# 代码

``` cpp
#include<bits/stdc++.h>
using namespace std;
int b[255],ans=0;//统计次数的桶和统计奇数个字符的计数器
int main(){
    memset(b,0,sizeof(b));
    for(char c;cin>>c;)//这样可以避免字符串或字符数组带来的巨大空间
        b[c]++;
    for(int i='a';i<='z';i++)
        if(b[i]%2==1)//统计每个字符，如果出现的次数是奇数就+1
            ans++;
    if(ans==0||ans%2)//如果本身是第一种特征或先手永远赶在后手前面
        cout<<"First";//先手胜
    else
        cout<<"Second";//后手胜
    return 0;
}
```