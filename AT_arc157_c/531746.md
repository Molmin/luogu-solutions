$$\text{思路}$$

题目要求我们算所有路径的值之和，每条路径可以看作路径上值之和的平方（题面中地图 $S$ 要求连续的 $\texttt{Y}$，我们可以把它看作一个新的地图 $T$）。此题第一眼看上去很难，但不妨我们可以想一想弱化的题意。

可以考虑，弱化题意为线性的的而不是平方的。对于地图 $T$ 中的每个点 $(x,y)$，走到该点有 $X$ 种方法（$X$ 可以用杨辉三角预处理），那么对于到该点做出的值之和为： $T_{x,y} \times X$。对于点 $(x,y)$，他的答案可以推到 $(x + 1, y)$ 和 $(x, y + 1)$。这样我们就能用类 DP 的方法处理这个问题。注意，我们并不需要知道每一条路径的值，取而代之的是值之和。

回到原问题。不同于弱化问题的的地方在于，每有一个 $T_{x,y}=1$，所做出的贡献是不一样的。若目前一条路径上有 $N$ 个 $T_{i, j}=1$，那么新增的一个会是答案从 $N^2$ 变为 $(N + 1)^2$，贡献为 $2N + 1$。然后我们就会惊奇的发现，因为同样的只要处理和，而这个 $N$ 的和正是我们考虑到的弱化问题！

由此，只要维护零次答案（即组合数）、一次答案和二次答案，这个问题就被解决了。回顾这道题，它并没有用到很难的 OI 或 MO 知识，但却能巧妙地将这道题升级。此题质量很高，值得一做。

------------

$$\text{代码}$$

- 杨辉三角要开两倍，因为是会访问到两倍的

```
#include <bits/stdc++.h>
using namespace std;
#define int long long
const int N = 2010, mod = 998244353;
int n, m, sum[N][N], sqa[N][N], c[4010][4010];
char mp[N][N];
signed main()
{
	c[0][0] = 1;
	for (int i = 1; i <= 4000; ++i)
		for (int j = 0; j <= i; ++j)
			c[i][j] = ((j == 0? 0 : c[i - 1][j - 1]) + c[i - 1][j]) % mod;
	cin >> n >> m;
	for (int i = 1; i <= n; ++i)
		for (int j = 1; j <= m; ++j)
			cin >> mp[i][j];
	for (int i = 1; i <= n; ++i)
		for (int j = 1; j <= m; ++j) {
			if (i == 1 && j == 1) continue;
			int b1 = (mp[i - 1][j] == 'Y');
			int b2 = (mp[i][j - 1] == 'Y');
			int b3 = (mp[i][j] == 'Y');
			sum[i][j] = (sum[i - 1][j] + (b1 * b3) * (i == 1? 0 : c[i + j - 3][i - 2]) + sum[i][j - 1] + (b2 * b3) * (j == 1? 0 : c[i + j - 3][j - 2]) + mod) % mod;
			sqa[i][j] = (sqa[i - 1][j] + (2 * sum[i - 1][j] + (i == 1? 0 : c[i + j - 3][i - 2]) + mod) % mod * (b1 * b3) + sqa[i][j - 1] + (2 * sum[i][j - 1] + (j == 1? 0 : c[i + j - 3][j - 2]) + mod) % mod * (b2 * b3) + mod) % mod;
		}
	cout << sqa[n][m] << endl;
	return 0;
} 
```

------------

完结！

~~说句题外话，这是这只蒟蒻第一次打 ARC，只做了 A 和 C。。。~~