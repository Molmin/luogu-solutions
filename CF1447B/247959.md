## 题目描述

给你一个$n\times m$的矩阵，你可以进行任意次操作，每次操作可以将矩阵中两个相邻的数分别乘 -$1$，也就是取反，问，矩阵的和能达到的最大值是多少？

## 题目思路

简单贪心，思路点在于判断负数数量的奇偶性，这里简单证明一下：

首先，很明显的，不管原来有多少个负数，你都可以通过取反最小化负数的数量

ps:给看不出来的（就算负数不相邻，你也可以通过直接给一个负数及其相邻的数取反来达到“跳一格”，从而让两个负数相邻，最后消掉）


所以剩下一个还是零个，就取决于负数的数量了

然后我们将这些数的绝对值排序，如果最后剩一个负数，那就让绝对值最小的那个成为负数！

有人可能会有这样的疑问，如果我负数数量是奇数，但是我有一个0，给他取反不就所有数都大于等于0了？

其实这种思路不需要处理0，如果有0的话，因为我们将原序列的绝对值排序了，就算后来再反悔取反，取的也是最小的0


所以前面处理负数数量的时候不用管0，因为如果：负数数量是

举个例子好理解：

$-1\ -1$

$-2\ \ \ \ \ \ 2$

此时为负数数量为奇数，我们无法操作使所有负数消失，所以就贪心，让绝对值最小的变为负数（对最后的和影响小）

所以最后的和为$-1+1+2+2=4$

**总结：计算负数数量，如果是偶数，直接输出所有数的绝对值的和就行，如果是奇数，那就让最小的那个是负数，其他还是绝对值，累加即可**

## 代码
```c++
#include<bits/stdc++.h>
using namespace std;
int a[15][15];
struct xxx{
	int num,sum;
}b[1005];
bool cmp(xxx x,xxx y){
	return x.sum<y.sum;
} 
int main(){
	int t;
	cin>>t;
	while(t--){
		int n,m;
		cin>>n>>m;
		int suma=0,sumb=0;
		long long ans=0;
		for(int i=1;i<=n;i++){
			for(int j=1;j<=m;j++){
				cin>>a[i][j];
				b[++suma].sum=abs(a[i][j]);
				if(a[i][j]<0){
					b[suma].num=0;
					sumb++;
				}
				else
					b[suma].num=1; 
			}
		}
		if(sumb%2)
			sumb=1;
		else
			sumb=0;
		sort(b+1,b+1+suma,cmp);
		for(int i=1;i<=suma;i++){
			if(sumb>=1){
				ans+=-b[i].sum;
				sumb=0;
			}
			else
				ans+=b[i].sum;
		}
		cout<<ans<<endl;
		//for(int i=1;i<=suma;i++)
		//	cout<<b[i].sum<<" ";
	}
}
```