Border 这种东西一看就很难直接搞区间，考虑转化成比较好处理的形式。

注意到当 $[l, i]$ 为其 Border，则 $[l, i] = [r - (i - l), r]$。再换个形式表示，则 $[1, i]$ 和 $[1, r]$ 的 LCS 长度 $\geq i - l + 1$，我们记作 $lcs(i, r) \geq i - l + 1$。

看到 LCS，考虑建出 SAM 的 fail 树，则 $len_{lca(pos_i, pos_r)} \geq i - l + 1$。

然后就有一个~~简单的~~暴力了：

- 可持久化线段树合并预处理每个子树内所有 $pos_i$ 的信息。
- 枚举 $pos_r$ 的祖先 $u$ 作为 $lca(pos_i, pos_r)$，则 $l \leq i \leq \min(l + len_u - 1, r - 1)$。在 $u$ 的可持久化线段树中二分查询该区间内的最大 $i$ 即可。

这里看上去似乎是要去重的，但因为越往祖先走 $i$ 的限制越紧，所以没影响。

时间复杂度为 $O(qn \log n)$，只有 $50 \operatorname{pts}$。

考虑树剖。现在我们将 $pos_r$ 到根的路径划分为 $O(\log n)$ 条重链的前缀，比如说我们要考虑其中一条 $x \to top_x$。

既然树剖了，我们就来考虑一下轻重子树分别的贡献。

1. 轻子树

- $x \to top_x$ 上的点（不包括 $x$）的轻子树带来的贡献。考虑离线下来 DSU on tree，把询问挂到 $x$ 的位置，对于每条重链从上往下依次处理，每次我们相当于知道 $lca(pos_i, pos_r) = u$（$u$ 为当前处理的点），则移项可知 $l \leq i < r$ 且 $i - len_u + 1 \leq l$。找出轻子树中作为原串前缀的 $[1, i]$ 并把 $i - len_u + 1$ 插入线段树 $i$ 的位置，然后线段树上二分即可。
- 这个前缀底部 $x$ 的子树带来的贡献。进行一次可持久化线段树查询即可。

2. 重子树

- $x \to top_x$ 上的点带来的贡献。在 DSU on tree 时一起加入这些位置的贡献即可。
- 这个前缀底部 $x$ 的子树带来的贡献（在轻子树的部分已经一起处理过了）。

综上，时间复杂度为 $O((|S| + q) \log^2 |S|)$。

代码有点长，应管理员要求放在[剪贴板](https://www.luogu.com.cn/paste/8gkbh4no)里。