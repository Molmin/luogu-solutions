这个题大概确实算比较困难的后缀字符串题目了。链分治这种方法以前没见过真的想不出来。~~反正我是贺的题解。~~

**个人评价：写出了做题思考的心路历程，逐渐导向正解，可能对像我一样的字符串萌新更友好一些。**

题意：给定字符串 $s$，$q$ 次询问某一子串的最长 Border 长度。

考虑怎么把题意转化成 SAM 的语言。对 $s$ 建 SAM ，每次询问找到子串 $[1,r]$ 的位置 $x$，那么我们知道，答案肯定是 $x$ 往上跳转后缀链接若干次所到的节点 $y$，$y$ 所代表的等价类中的某一子串（不一定是最长的）。假设答案所代表的 Border 是 $s_{l,l+1,...i}$，则需要满足的要求是：$lcs(i,r)\geq i-l+1,l\leq i \leq r - 1$，且 $i$ 最大。

先用线段树合并求出每个节点所代表的 endpos 集合，那么暴力的做法就是在 link 树上往上爬，并分别在每个节点 $y$ 上求出区间 $[l,l-1+len_y]$ 的最大值就能得出我们要的 $i$。

这个复杂度是有问题的，因为 link 树的深度没有保证。如何做出一定优化呢？

让我们来看一下另外一种做法。首先把每个询问挂在插入 $s_r$ 时的结点上（即这个节点包括了 $s_{1,2,...r}$ 这个前缀）。然后考虑对于每个结点，$lcs(i,r)$ 肯定是它的某个祖先（不能是自身，不过这是不重要的细节）那么我们直接深度优先搜索 link 树，在从结点 $x$ 往儿子结点 $v$ 下搜索的过程中，考虑 $x$ 作为这个 $lcs(i,r)$ 的时候，有用的 $i$ 就是 $x$ 除了 $v$ 子树以外所有子树的信息。于是，我们可以在刚进入 $x$ 的时候，将 $x$ 子树中的结点搜索一遍全部加入一颗维护区间内 $i-lcs(i,r)$ 最大值的线段树，进入儿子时再临时删去这个儿子中的所有结点，回溯时再加入，就可以在遇到每个询问时，在线段树上二分做出这道题目了。

很遗憾，这种做法的复杂度是 $O(\log n\cdot \sum)$， $\sum$ 是所有子树的大小之和，可以达到 $n^2$ 级别，所以按道理来说也是错误的。

但是，可以用第一种方法 $+$ 轻重链剖分优化第二种方法。

首先，对 link 树进行轻重链剖分。我们先证明轻子树的大小之和不超过 $n\log n$，原因是每个点的对总和的贡献即为它到根节点的路径上经过的轻边数量，这显然是 $\log n$ 的，所以轻子树的大小之和就有保证。

这有什么用处呢？对于一个询问，子串 $[1,r]$ 的位置预处理出来是 $x$，然后将它到根节点的路径进行剖分，剖成若干重链，并把询问挂在每一条重链第一次被到达的位置。

这时候，离线后从上往下搜索每条重链，将重链上的每个点和它的所有轻子树的信息暴力搜索，加入线段树，套用第二种方法解决：对于每条零散的重链，非底端的点作为 $lcs(i,r)$ 的话， $i$ 只能是重链上的点或轻子树中的点，已经被考虑掉了；唯一漏掉的是底端的点作为 $lcs(i,r)$ 的情况，每个询问中这种情况只会出现 $O(\log n)$ 次，所有只需要直接对 link 树跑一遍线段树合并，显式地维护出每个点所代表的 endpos 集合，查询区间最大值并判断合法性即可。所以这个地方用平衡树的启发式合并好像也可以。

由于轻子树大小之和有保证，而每个询问特殊处理的点也很有限，所以总时间复杂度是 $O((n+q)\log^2n)$，用一些线段树合并方面的技巧，空间复杂度可以做到线性。

代码：

[差点突破码长记录](https://www.luogu.com.cn/paste/7famymq9)