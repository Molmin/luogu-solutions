## 首先先翻译一下题目：
给定一个非负整数 $n$，求有多少个非负整数 $x$，$y$，$z$，满足 $x+2y+2z=n$。

## 思路：
我们已经知道 $x+2y+2z=n$,所以可以得到 $2y+2z=n-x$。

所以就可以知道 $2y+2z$ 的范围应在 $[0,n]$ 内，那么 $y+z$ 的范围应在 $[0,n/2]$ 之间。那么枚举 $y$ 和 $z$，然后 $x$ 自然也能确定了。

接下来就对每个枚举出来的数据处理就可以了。
## 普通优化：
只要把 $y+z$ 的范围内的数量求出来， $[0,n/2]$ 一共会有 $n/2+1$ 中枚举，每个枚举都会出现 $1$ 种方案，也就是将问题转化为求 $1+2+...+(n/2+1)$。

故此，先让 ``n=n/2+1``。

根据高斯公式（即等差数列求和公式）可以得$1+2+...+x=x\cdot(x+1)/2$，所以可以直接输出 ``n*(n+1)/2``。

高斯公式（等差数列求和公式）是什么？[不懂就点我！！！](https://baike.so.com/doc/1322911-1398582.html)

## 二进制小优化：
~~试过了，用不用二进制其实结果都是对的。~~

其实就是把原本的 ``n=n/2+1`` 改成右移的写法 ``n=(n>>1)+1``。

再把 ``n*(n+1)/2`` 改成 ``n*(n+1)>>1``。

虽然说不能优化多快。
## 优化后代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
long long n;
int main()
{
    while(scanf("%lld",&n)!=EOF)
	{
        n=(n>>1)+1;
        printf("%lld\n",n*(n+1)>>1);
    }
    return 0;
}
```