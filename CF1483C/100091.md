# CF1483C 题解

一.题意简述

给一个序列 $a$，要求将序列分成若干段，并最大化每一段最小值的和。

首先，我们可以写出一个暴力的DP方程：

设 $f_i$ 表示将前 $i$ 个数分成若干段，最后一段的结尾元素是 $a_i$ 的答案。

那么我们有一个转移方程，是：

$f_i = max_{j \in [1,i - 1]}(f_j+min_{k \in [j + 1, i]}(a_k))$ .

我们发现，这样算是 $O(n^3)$ 的，

加上一个静态查询区间最大值的数据结构也是 $O(n^2)$ 的。

那么，我们考虑优化这个转移。

我们考虑，上面转移式中的 $min_{k \in [j + 1, i]}(a_k)$ 在什么地方取到。

我们对每一个 $i$，维护一个单调递增的序列 $b$，

这个序列是序列 $a$ 中前 $i$ 个数的子序列，

且在序列 $b$ 中任意一个不为结尾的位置 $j$ ，都有：

$b_{j}$ 是在序列 $a$ 中第一个小于 $b_{j+1}$ 的元素。

当然，序列 $b$ 的最后一个元素必须是 $a_i$.

实际上，这个序列 $b$ 就是以序列 $a$ 的前 $i$ 个元素建立的单调栈。

那么，我们可以发现，$min_{k \in [j + 1, i]}(a_k)$ 的值就只能在序列 $b$ 中出现，且：

对于某个 $b$ 中的两个相邻元素 $b_x,b_{x+1}$，

我们找到它们在序列 $a$ 中的下标 $p_x,p_{x+1}$，那么：

 $\forall j \in [p_x + 1,p_{x+1}]$，$min_{k \in [j + 1, i]}(a_k) = b_{x + 1}$.

那么，我们定义： $w_i(j) = min_{k \in [j + 1, i]}(a_k)$，我们就可以发现：

对于每个 $i$，我们将原序列 $a[1...i]$ 分成了若干段小区间，

其中每一段小区间的 $w_i$ 值都等于这段小区间的末尾元素。

为了方便下文叙述，我们说这个末尾元素与这段小区间相互对应。

当然，将这些小区间对应的末尾元素抽出来，就可以组成序列 $b$.

这又有什么用呢？

我们发现，我们只需要动态的维护这个序列 $b$ 中 $f_j + w_i(j)$ 的最大值，即：

我们用线段树维护，当考虑到第 $i$ 个数时，线段树上第 $j$ 个位置的值为 $f_j + w_i(j)$ ，

那么我们考虑在前 $i - 1$ 个数对应的线段树上进行一些修改。

我们可以先维护序列 $b$：

把前 $i - 1$ 个数对应的序列 $b$ 的最后若干个大于 $a_i$ 的数删掉，

再把 $a_i$ 加进 $b$ 的末尾。

我们注意到，删掉的所有数对应的小区间，

在线段树上的 $f$ 值不会改变，但 $w_i$ 值会一起改变。

所以我们就可以轻松的维护线段树了：

每从 $b$ 中删掉一个元素 $x$，我们就把线段树上的这个区间整体加上 $a_i - x$，

最后在 $b$ 中放入 $a_i$ 时，

我们在线段树上查询区间 $[1,i - 1]$ 的最大值，作为 $f_i$ 的值。

最后，我们再将 $f_i + a_i$ 插到线段树上的第 $i$ 个位置即可。

因为序列 $b$ 总共只会放入 $n$ 个数，故也最多删除 $n$ 次，那么总复杂度也就是 $O(nlogn)$.