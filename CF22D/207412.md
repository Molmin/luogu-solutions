### Problem
在坐标轴上给定 $n$ 条线段，有 $k$ 个点，使这 $n$ 条线段都至少有一个点在其上面（恰在端点也行）。

求 $k$ 的最小值，并给出一个 $k$ 最小时的方案。

### Solution
ABC230D 的弱化版（然鹅其实区别不大）

很明显是贪心，先假设每条线段都已经按结尾点排好序。

如果一条线段在这以前没有被覆盖，那么一定会在这条线段上增加一个点。

那么这个点放在那里最合适呢？

很明显是这条线段的结尾处，因为如果加在线段中间，就会浪费这个点的功能，在按结尾点排好序后，放在线段结尾一定小于等于下一个没有覆盖的线段的结尾，不会出现新加的点在线段中间覆盖的线段比在结尾少。

举个栗子（样例 2 ）：

![](https://cdn.luogu.com.cn/upload/image_hosting/02nqe9hp.png?x-oss-process=image/resize,m_lfit,h_500,w_1000)

首先发现第 $1$ 条线段没有被覆盖，于是在它的结尾 $3$ 处放一个点。

这个点也可以盖住第 $2$ 条边，然后发现第 $3$ 条线段没有被覆盖，再在它的结尾 $7$ 处放一个点。

这个点同样也可以盖住第 $4$ 条边，最后只有第 $5$ 条线段没有被覆盖，在它的结尾 $10$ 处放一个点。

然后具体实现的话先结构体排序一下，然后每次找到没有覆盖的点就答案加一，再往后跳直到再找到这个点覆盖不了的点。
### Code
```cpp
void solve()
{
	int n,ans=0;
	scanf("%lld",&n);
	for(int i=1;i<=n;i++)
	{
		scanf("%lld%lld",&id[i].x,&id[i].y);
		if(id[i].x>id[i].y)swap(id[i].x,id[i].y);//差点被坑到~
	}
	sort(id+1,id+n+1,cmp);//按结束点排序
	for(int i=1;i<=n;i++)
	{
		int k=id[i].y;i++;
		//cout<<id[i].y<<" ";
		while(id[i].x<=k&&i<=n)i++;i--;//往后跳直到找到没有覆盖的点
		ans++;
	}cout<<ans<<endl;
	for(int i=1;i<=n;i++)
	{
		int k=id[i].y;//再做一次找到方案
		cout<<id[i].y<<" ";i++;//这条线段没有覆盖
		while(id[i].x<=k&&i<=n)i++;i--;
	}
	
}
```
