因为是一个排列,所以我们可以考虑把排列划分成两个部分:

1:属于排列p的前缀最大值集合的元素;

2:不属于排列p的前缀最大值集合的元素;

注意到,对于一个满足条件的01串s,按照题目给出的分配规则划分成排列x,y之后,x,y中的前缀最大值个数一定是小于等于排列p的前缀最大值个数的;

证明:

我们考虑原排列的前缀最大值集合中元素的去向

假如全部放入其中一个排列中,那么对于所有满足情况的s串,
另一个排列的前缀最大值个数一定等于原排列的前缀最大值个数.

假如将它们分开放入两个序列中,设当前取出的元素为k

无论我们把它放入哪一个排列,后面能更新该集合前缀最大值的元素一定属于[k+1,n];

而后面能更新这个最大值的元素,假如全部加入当前排列,这个排列的前缀最大值个数也必然小于等于原排列的前缀最大值个数.

这启发着我们如果排列满足s串,那么其中一个排列的前缀最大值一定可以由原排列的前缀最大值集合的元素替换而得到.

换句话说,就是其中一个排列的前缀最大值集合一定可以是原排列的前缀最大值集合的一个子集.

有了这个性质,我们就可以考虑去用贪心来解决这个问题.

自然,为了满足字典序最小,我们应当尽可能的让s前面的元素为0

假设当前处理到了第i位,前i-1位已经处理完毕,
 
 对于第i位,我们令 cx  表示序列x中前缀最大值个数,cy表示序列y中前缀最大值的个数,c表示原排列中前缀最大值个数,
  后面填的数中会有 k个旧前缀最大值、m个新前缀最大值,
  
 那么对于满足条件的排列,我们有等式:
 
 cx+c-k=cy+m+k
 
 也就是说
 
 2k+m=cx-cy+c
 
 等号右边是一个常数,因此我们考虑如何处理左边就好啦.
 
 左边的处理我们可以考虑处理奇偶性来处理..
 
 然后就是比较简单的dp过程了,方程也比较显然,这里不再给出了.
 
 直接dp转移复杂度会炸,可以考虑通过线段树求区间最大值来优化转移策略就好了.
 
 复杂度:O(nlogn)
 
 
 //话说为什么洛谷不能题交AT的题了.
 求过,谢谢.
