看到题的第一反应：完蛋，又是括号序列！

再一看：简单模拟。

题意：给出一个括号序列，每次删除**最短的**“好的前缀”。“好的前缀”定义为一段合法的前缀括号序列或者是长度不小于 $2$ 的回文前缀。求出操作次数和剩余字符数。

考虑你删除的前缀可能会长什么样：

+ `((`

+ `))`

+ `()`

+ 两个 `)` 中间夹着一段连续的 `(`。

这包含了全部情况。可以自行举例，某些看似复杂的情况经过上述判断就根本不可能出现。

比如 `()(()())((())`，我们来模拟一下删除过程。

第一次删除：`(()())((())`。删掉了`()`。

第二次删除：`)())((())`。删掉了 `((`。

第三次删除：`)((())`。删掉了 `)()`。

第四次删除：`)`。删掉了 `)((()`。

答案为 `4 1`

那么我们逐个读入字符，依据刚才讨论的前缀形式，归结出以下操作：

+ 串为空，剩余字符数计数变量加一。

+ 读入字符和字符串剩余部分的开头相同，剩余字符数计数变量清空。

+ 读入字符为 `)` 且开头字符为 `(`，剩余字符数计数变量清空。

+ 都不满足，则剩余字符数计数变量加一。

代码：

```
#include<bits/stdc++.h>
using namespace std;
int main(){
	int T;
	cin>>T;
	while(T--){
		int n;
		cin>>n;
		char head;
		cin>>head;
		int ans=0;
		int rem=1;
		for(int i=2;i<=n;i++){
			char c;
			cin>>c;
			if(!rem){//串空了，更新首位字符 
				rem++;
				head=c;
				continue;
			}
			if(head==c){//开头字符和当前字符相等，那么这一段前缀可以清空 
				rem=0;
				ans++;
				continue;
			}
			if(head=='('&&c==')'){//匹配成了（） 
				rem=0;
				ans++;
				continue;
			}
			rem++;
		}
		cout<<ans<<' ';
		cout<<rem<<endl;
	}
	return 0;
}
```




