####  这道题本蒟蒻想了好久才做出来,希望题解可以审核通过
#### 思路如下：
- 首先，要找到最优的一列（使移动步数最少的一列），其实就是要找一条平行于x轴的直线，设此直线为x=k，那么，每个点到这条距离为|yi-k|，不难发现，当k是所有点纵坐标的中位数时，距离之和最小。
- 找到了这条直线之后，又该把每个点移到哪个位置才能使结果最优呢？可以设最左边的点（第一个点）移动后的位置为b,因为所有点必须排在一条线段上，那么第二个点的移动后的位置即为b+1，第三个移动后的位置为b+2......以此类推，第n个点移动后的位置为b+n-1。那么横向移动的步数之和为|x1-b|+|x2-b-1|+|x3-b-2|+......+|xn-b-n+1|，所以，要使步数之和最小，只需要再找一次中位数即可。
##### 代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
int x[10001];
int y[10001];
int main()
{
	int n,i,ans=0,fx,fy;
	cin>>n;
	for(i=1;i<=n;i++)
	{
		scanf("%d%d",&x[i],&y[i]);
	}
	sort(y+1,y+n+1);
	sort(x+1,x+n+1);
	if(n%2==0)
	{
		fy=(y[n/2]+y[n/2+1])/2;
	}
	else
	{
		fy=y[n/2+1];
	}
	for(i=1;i<=n;i++)
	{
		ans+=abs(fy-y[i]);
	}
	for(i=1;i<=n;i++)
	{
		x[i]-=i;
	}
	sort(x+1,x+n+1);
	if(n%2==0)
	{
		fx=(x[n/2]+x[n/2+1])/2;
	}
	else
	{
		fx=x[n/2+1];
	}
	for(i=1;i<=n;i++)
	{
		ans+=abs(x[i]-fx);
	}
	cout<<ans;
}
```