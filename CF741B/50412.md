思想很简单啊，并查集和背包（就如标签一样）

~~我亲眼见证了这题从蓝题变成紫题（世纪性的一幕）~~

~~别误会，我就写了不到半小时，毕竟我只是个蒟蒻，不会刚省选题的，真的是它突然变了~~

介绍一下思想

首先，我们要把所有的朋友放在一个并查集内，这很简单，只要会打并查集模板就好了

然后，我们想一下，只能找一个朋友或者找全部或者不找，是不是很眼熟啊？没错，就是我们的分组背包！

只要把同一个并查集内的元素放到一个组内，然后载把这个并查集中所有元素的总和作为该组中的一个元素就好了（想一下是不是要么找一个，要么不找，要么找全部）

还有一个注意点（虽然我从一开始就没被坑），但是还是提醒一下，注意如果一个并查集内只有一个元素，那么就不要把该并查集内所有元素总和加入分组背包了（克隆人类是违法的！）

下面放代码
```
#include <bits/stdc++.h>
using namespace std;
int n,m,wt,w[1007],b[1007],a[1007],num[1007],totw[1007],totb[1007],cnt;//解释一下
//n：初始人数 m：关系数 wt:weight tot 最高体重和
//w，b数组：初始体重及魅力 a数组：记录每一个并查集标志数（即该组内所有人的father）所属于的组数，由此来将一个并查集中的元素放入一个组 num数组：记录每一个组内元素个数（不含所有元素和，这个后面加） totw，totb数组：记录每一个组的w及b之和 cnt：记录组数
int fa[1007],d[1007][1007],x,y,f[1007];
//fa数组：并查集 d数组：记录每一个组别内的每一个元素的编号（是编号哦！！） x，y ： 读入工具 f数组：记录最大魅力和，即背包
int find(int x){
	if(x==fa[x]) return x;
	return fa[x]=find(fa[x]);//并查集+路径压缩
}
int main(){
	scanf("%d%d%d",&n,&m,&wt);
	for(int i=1;i<=n;i++) scanf("%d",&w[i]);
	for(int i=1;i<=n;i++) scanf("%d",&b[i]);
	for(int i=1;i<=n;i++) fa[i]=i;//读入初始化
	for(int i=1;i<=m;i++){
		scanf("%d%d",&x,&y);
		int p=find(x);
		int q=find(y);
		if(p!=q) fa[p]=q;//构造并查集
	} 
	for(int i=1;i<=n;i++){
		int p=find(i);
		if(a[p]==0) a[p]=++cnt;//新建组别，通过标志数帮每一个元素找到自己的组别
		d[a[p]][++num[a[p]]]=i;//为组别内加元素
		totw[a[p]]+=w[i];totb[a[p]]+=b[i];//更新该组别总重，总魅力
	}
	for(int i=1;i<=cnt;i++){
		if(!(totw[i]==w[d[i][1]]&&totb[i]==b[d[i][1]])){//上面的注意点
			d[i][++num[i]]=n+1;//将组别的总和作为最后一个元素加入组别
			w[n+1]=totw[i];b[n+1]=totb[i];
		}
		for(int v=wt;v>=0;v--)
			for(int j=1;j<=num[i];j++)
				if(v>=w[d[i][j]])
					f[v]=max(f[v],f[v-w[d[i][j]]]+b[d[i][j]]);//熟悉的背包
	}
	printf("%d",f[wt]);
	return 0;
}
```

希望大家都AC，但是代码不要复制哦