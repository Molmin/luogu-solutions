------------
题目描述：

**Pablo被指派用大理石在五边形内建造五边形，但他不知道他需要多少弹珠。 他知道，对于第一个五边形，他需要5个弹珠**

（注意：此处题目上有一张图片没显示出来，请管理员附上）

**他知道插入第二个五边形的唯一方法是在每个部分的中间放置一个大理石并绘制三条线，如图所示。 他将一块大理石放在相交的线上并将它们移除。 为了在内部插入第三个五边形，他首先将所有段分成两个，包括不需要的段，并重复该过程。 绘制两个五边形将需要12个弹珠，三个五边形将需要22个弹珠。 给出要绘制的五边形的个数，编写一个程序来计算所需的弹珠数量。**

输入：

**输入包含多个数据。 每个数据包含一个整数n，表示要创建的五边形的数量（1 <= n <= 1000）。读到0停止。**

输出：

**对于输入中的每个数据都要打印一行，每一行包含一个整数，即绘制n个五边形所需的弹珠数。**

------------
看完题面，我们不难发现有一定的规律。

![题面](https://cdn.luogu.com.cn/upload/pic/58144.png)

如上图，我们可以发现几条规律：

1.每多绘制一个五边形，最大的五边形（即第一个五边形）的每一条边上都会增加一颗弹珠，即如果要绘制n个五边形则最大的五边形（即第一个五边形）的每一条边上会有n个弹珠，则五条边上共有n*5个弹珠。

2.处理完边上的弹珠，接下来要处理最大的五边形（即第一个五边形）以内的弹珠。通过~~一定的数学~~可以发现，其以内的弹珠总数为：n*(n-1)+k。找规律发现k的变化规律如下图：

![](https://cdn.luogu.com.cn/upload/pic/58149.png)

由此，我们可以把每一个数的k先储存起来，这样就可以直接相加辽。

总结规律：n*(n-1)+5n+k。


------------
AC代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[1001];//将每一个数的k储存起来
int main(){
	int s=0,t=1;
	for(int i=3;i<=1000;i++){
		a[i]=s+t;
		s+=t;//s代表每一个数的k
		t++;//t代表k每次改变要相加的值
	}
	while(1){
		int n;
		cin>>n;
		if(n==0)return 0;//如果读到0就停止
		cout<<n*(n-1)+n*5+a[n]<<endl;//套公式
	}
	return 0;
}
```
