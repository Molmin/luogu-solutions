## 题目简介：

给定一个含 $n$ 个数的数组，你每次可以将一个区间 $[l,r]$ 正序排列并且所要花的代价为 $r - l + 1$，问将这个数组正序排列所要花的代价最小是多少。

## 分析：

我们可以运用转换的思路，想要花的代价越少那么必须要得出那些不需要被排列的数有几个，然后我们可以得出这些数得具有以下特性：

> 1. 所在的位置和全数组正序排列后的位置相同。

> 2. 在原数组中在这个数之前的数不能再排列后跑到这个数后面。

根据这两个特性，我们可以想出一种方法：

遍历原数组，遇到某一个数与排列后的位置不同且未被标记（指在排列后的数组的这个位置之前没有出现过），继续从这个位置的排列后的数组中遍历，找到这个数在排列后的数组中的位置，并将沿途的数都标记一遍，表示其已经出现过。

于是找到这个数之后，我们可以知道在这个数的原位置和现在这个位置之中是绝不会有具有上述特性的数的，故将原指针拖到现在这个位置继续遍历，重复上述操作。

并且在原数组中遍历时，如果遇到某数与同位置的排列后的数组一样并且没有被标记过，那么可以认定这个数就是我们要找的数，并且将这种数的数量记录下来，最后只要输出总数 $n$ 和这种数的数量之差即可。

没看懂的看代码吧：

```cpp
#include <bits/stdc++.h>
using namespace std;
int T,n,a[1000005],b[1000005],c[1000005],sum;
//a数组是原数组，b数组是排列后的数组，c数组是标记。 
signed main()
{
	cin >> T;
	while(T--)
	{
		cin >> n;
		sum = n;
		for (int i = 1; i <= n; i++)
			{
				cin >> a[i];
				b[i] = a[i];
				c[i] = 0;//别忘了初始化。 
			}
		sort(b + 1,b + 1 + n);
		for (int i = 1; i <= n; i++)
			{
				if (a[i] != b[i] && c[a[i]] == 0)//遇到某一个数与排列后的位置不同且未被标记时的操作。 
					{
						for (int j = i; j; j++)
							{
								c[b[j]] = 1;//标记。 
								if (b[j] == a[i]) break;
							}
					} else
				if (a[i] == b[i] && c[a[i]] == 0) {sum--;continue;}	//记录所需数。 
			}
		cout << sum << endl;	
	}
	return 0;
}

```

没看懂的可以在评论区问，~~也可以来喷我。~~

希望对大家有帮助。