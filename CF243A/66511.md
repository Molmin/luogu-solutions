似乎所有题解都没有给出关于复杂度的说明，这里简单说明一下。

## 【思路】

首先我们考虑一个 $O(n^2)$ 的做法。

显然我们可以考虑在 $r$ 处计算贡献，即 **暴力枚举** $r$ ，然后 **暴力向左扩展** $l$。

这样就可以算出所有区间的值。

但由于本题数据范围 $10^5$ ，考虑优化。

首先区间很容易让我们想到前缀和或者后缀和（本题中为或），显然我们在枚举 $r$ 的时候，算出的是 $[1,r]$ 区间的一段后缀或。

那么我们假设 $s[i]$ 表示 $a[i]~|~a[i+1]~|~\dots~|~a[r]$ 。

那么显然在更新 $r$ 为 $r+1$ 时，所有 $s[i]$ 都会发生 $s[i] \leftarrow s[i]~|~ a[r]$ 。

然后我们就可以从后往前暴力扫直到 $s[i]~|~a[r]=s[i]$ ，然后就可以直接 `break` 跳出了。

首先说明这是正确的。

一种解释是，我们显然在任意时候都要保证 $s[i-1]=s[i]~|~a[i-1]$ ，这里这个式子是与 $r$ 无关的。

那么若 $s[i]$ 不改变，显然 $\forall j \le i$ ，$s[j]$ 也不需要改变。

另一种解释是，我们假设 $S(x)$ 为 $x$ 在 **二进制** 下所有为 $1$ 的 **位置** 的集合，即设 $x=2^{k_1}+2^{k_2}+\dots+2^{k_{|S(x)|}}$ ，那么 $S(x)=\{k_1,k_2,k_3,\dots,k_{|S(x)|}\}$

不难发现一个性质： $S(s[i])\subseteq S(s[i-1])$ 。

而 $S(x) \subseteq S(y)$ 等价于 $x~|~y=y$ 。

所以当 $s[i]~|~a[r]=s[i]$ 时，$S(a[r])\subseteq S(s[i])$ ，故 $\forall j\le i$ ，$S(a[r])\subseteq S(s[j])$ ，故有 $s[j]~|~a[r]=s[j]$ ，不需要改变。

然后说明这复杂度是正确的。

显然若 $s[i]~|~a[r]\ne s[i]$ 时， $s[i]$ 会变为 $s[i]~|~a[r]$ ，这种情况下 $|S(s[i])|\le |S(s[i]~|~a[r])|$ 显然成立，可以理解为 $s[i]$ 的二进制位上多了一个 $1$ 。

而由于 $a_i \le 10^6$ ，那么每一个数最多被修改 $\log 10^6$ 即 $20$ 次，并且在无法修改之后不会被继续修改，故复杂度正确。

## 【代码】
只放关键部分。
```cpp
int n;
bool vis[1 << 20 | 5];
int a[100005], ans;
int main(){
    read(n);
    for (register int i = 1;i <= n;i ++){
        read(a[i]);
        if(!vis[a[i]]) {
            vis[a[i]] = 1;
            ++ ans;
        }
        for (register int j = i - 1;j;-- j){
            if((a[j] | a[i]) == a[j]) break;
            a[j] |= a[i];
            if(!vis[a[j]]) {
                vis[a[j]] = 1;
                ++ ans;
            }
        }
    }
    fprint(ans, 10);
}
```