注：本题作者使用贪心算法。

### 题目大意：
$T$ 组数据，每组数据给出 $n$，以及长度为 $n$ 的数组 $a_i$，$c_i$，分别代表有 $n$ 块地板、第 $i$ 块地板的积灰程度和类型。每次操作你可以：

- 选择两个下标 $i,j$ 满足 $1 \le i \le j \le n$ 且 $c_i=c_j$ 且地板 $i,j$ 均未清理过；

- 花费 $a_i+a_j$ 的能量清理地板 $[i,j]$ 的灰尘。

求最小需要多少能量可以清理完所有地板。

### 分析：

首先，两个端点地板的 $a_i$ 必须要取，因为左端点地板的左边和右端点地板的右边都没有地板可取。

然后我们来介绍这题的贪心算法：

1. 若 $c_1=c_n$，则直接取区间 $[1,n]$ 最优，证明：因为若不这么做，则总能量为 $a_1+\cdots+a_n$，又 $a_i \ge 1$，所以 $a_1+\cdots+a_n > a_1+a_n$。

2. 若 $c_1=0,c_n=1$，则取区间 $[1,i]$ 和 $[i+1,n]$ 且 $i$ 满足 $c_1=c_i$、$c_{i+1}=c_n$ 且 $a_i+a_{i+1}$ 最小时最优。证明：设取 $3$ 个区间，则会在原来最优答案的两个区间中的某一个再细分一个区间，此时根据贪心法 $1$ 的证明可得这样一定不优。同理得区间数 $\ge 3$ 时一定不优。

3. 若 $c_1=1,c_n=0$，则取区间 $[1,i]$ 和 $[i+1,n]$ 且 $i$ 满足 $c_1=c_i$、$c_{i+1}=c_n$ 且 $a_i+a_{i+1}$ 最小时最优。证明过程与贪心法 $2$ 的过程相似。

综上，贪心法 $1$ 的时间复杂度为 $O(1)$，贪心法 $2$ 和 $3$ 要查找满足条件的 $i$，时间复杂度为 $O(n)$，总时间复杂度为 $O(\sum n)$，可以通过本题。

注意：贪心法 $2$ 和 $3$ 的最优答案有可能会达到 $4 \times 10^9$，因此要开 `long long`，最优答案的初始化也要适当开大一点，不能开 `INT_MAX`。

代码如下：

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int t,n,a[2000001]={0};
bool c[2000001]={0};
signed main() {
    cin>>t;
    while(t--){
    	cin>>n;
    	for(int i=1;i<=n;i++)cin>>a[i];
    	for(int i=1;i<=n;i++)cin>>c[i];
    	if(c[1]==c[n])cout<<a[1]+a[n]<<endl;
    	else if(c[1]){
    		int ans=1e15;
    		for(int i=1;i<n;i++){
    			if(c[i]&&!c[i+1])ans=min(ans,a[1]+a[i]+a[i+1]+a[n]);
			}
			cout<<ans<<endl;
		}
		else{
    		int ans=1e15;
    		for(int i=1;i<n;i++){
    			if(!c[i]&&c[i+1])ans=min(ans,a[1]+a[i]+a[i+1]+a[n]);
			}
			cout<<ans<<endl;
		}
	}
    return 0;
}
```

其实本题还可以用动态规划去写，请读者们自行思考。