[题目传送门](https://www.luogu.com.cn/problem/CF333A)

题外话：~~建议评黑，题意极毒。~~

## 题目描述

有一位旅行者去找商人买了一个价值 $n$ 元的东西。在结账时，他突然尴尬地发现自己身上只有硬币了，并且他无法付给商人刚好 $n$ 元钱。旅行者随身带着的硬币的面值都是 $3$ 的整数次幂，这样的硬币面值可以很大，旅行者身上也有非常多，多到自己都数不清呢。

这个商人不喜欢找零，所以旅行者试图用数量尽可能少的硬币给他一笔大于等于 $n$ 的钱，并且额外付出的部分要最小。可是作为旅行者的忠实粉丝，商人好像认出了旅行者，并要求在上述情况下得到尽可能多的硬币用于收藏。

聪明的你可以帮帮他吗？请求出商人最多可以得到的硬币数量。

- $1 \leq n \leq 10^{17} $

## 题目解析

首先分析题目，我们把硬币的面值表示为 $x=3^k \ (k \geq 0)$ 的形式。

旅行者既然**无法付给**商人刚好 $n$ 元，也就是说他选的硬币面值 $x$ 并不能被 $n$ 整除，即 $n \mod x \neq 0$。

综上，我们可以通过枚举 $3$ 的整数次幂来直接枚举每个面值的硬币，直到找出第一个不能被 $n$ 整除的面值 $x$。

此时，我们直接用物品的价值 $n$ 来除以硬币面值 $x$ 得到的并不是最终的硬币数量。因为本身除不尽，$C++$ 会进行强制向下取整。比如当你的钱的面值 $x=3$，你买的东西价格 $n=16$ 时，向下取整得到的结果是 $\lfloor \frac{16}{3} \rfloor = 5$。~~你敢给老板 5 张三块钱试试？~~ 

所以最后结果还要加 $1$。

上述过程也可以使用 `<cmath>` 库里的向上取整函数 `ceil()` 来进行处理。但是要注意使用这个函数的运算必须是**浮点类型数据**的运算，不然就会像[这篇题解](https://bywyr.blog.luogu.org/solution-cf333a)一样错掉。

- 坑点：$10^{17}$ 要开 `long long`！

## AC Code

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
long long n,ans; //一定记得开long long! 
int main() 
{
	scanf("%lld",&n);//输入，使用scanf时别忘了&地址符:) 
	ans=1;//这是硬币面值 
	while(n%ans==0) ans*=3;//每次扩大3倍，相当于指数加1 
	printf("%lld\n",n/ans+1);//除法运算一直是下取整的，所以要加1 
	return 0;//好习惯 
}
```

[AC记录](https://www.luogu.com.cn/record/98199988)

❤ 今天疯狂星期四 ❤

❤ 给我点赞请你吃 ❤