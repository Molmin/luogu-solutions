我校模拟赛一场搬了这个题，非常高兴赛时过了。

非常优美的点分治做法。

先想个暴力，我们枚举每个点，统计包含每个点 $u$ 的颜色数量最少的连通块。一个很朴素的做法就是以这个点为根搜一次，建立一个颜色队列，首先把该点的颜色入队，每次弹出一个颜色，把所有是这个颜色的点遍历一次，每次从这个点往父亲跳，如果出现新颜色就把它入队，如果出现已经遍历过的点说明它网上的点都遍历过了，就直接跳。

分析复杂度每次是 $O(n)$ 的，总时间是 $O(n^2)$ 的。

我们可以放到点分治上维护这个操作，每次以当前分治中心为枚举的点，不过如果在枚举过程中出现当前连通块外的点就直接结束，因为如果经过外面的点，那么相当于经过了某一级分治祖先，那么那级的颜色队列一定会被当前的遍历包含，要么相同，要么更劣，所以直接不用考虑。

发现每一次统计答案的时间复杂度最劣是 $O(点数)$ 的，总时间复杂度 $O(n\log n)$。

统计答案部分的代码：

```cpp
void get_ans(int u){
	if(!c[u])return;
	dep[u]=1,fa[u]=0;
	get_fa(u,u);
	st[tp=1]=c[u],vic[c[u]]=u;
	for(int k=1;k<=tp;k++){
//		printf("Col:%d\n",st[k]);
		for(int i=0;i<g[st[k]].size();i++){
			int v=g[st[k]][i];
			if(Vis[v]!=u)return;
			while(dep[v]){
				if(!c[v])return;
				if(vic[c[v]]!=u)vic[c[v]]=u,st[++tp]=c[v];
//				printf("Find:%d\n",v);
				dep[v]=0,v=fa[v];
			}
		}
	}
	ans=min(ans,tp-1);
//	printf("%d\n",tp-1);
}
```
