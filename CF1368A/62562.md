题意：$T$组数据，每组$a,b,n$三个数，每次操作可以将$(a,b)$变成$(a+b,b)$或者$(a,a+b)$,问在经过多少次操作后可以使得两个数中的某一个数严格大于给定的$n$

既然是第一题，难度应该不大吧？照本宣科，打个暴力先：

```cpp
#include<bits/stdc++.h>
using namespace std;

int ans,T,a,b,k;

void dfs(int a,int b,int k,int cnt){
//	printf("%d %d %d %d\n",a,b,k,cnt);
	if(cnt>=ans) return;
	if(a>k || b>k) {
		ans=min(ans,cnt);
		return;
	}
	dfs(a+b,b,k,cnt+1);
	dfs(a,a+b,k,cnt+1);
}

int main(){
	scanf("%d",&T);
	while(T--){
		scanf("%d%d%d",&a,&b,&k);
		ans=1<<30;
		dfs(a,b,k,0);
		printf("%d\n",ans);
	}
} 
```

然后……光荣的PreTest 2 TLE……

考虑到$a,b,n\leq 10^9$，如果取$a,b=1,n=10^9$这种极限数据，光是加十亿次的计算量，都意味着不可避免的爆栈……

考虑优化吧！

我们研究我们之前的算法，根据这个算法，最终应该会在$10^9$次操作后产生满足条件的数对$(10^9+1,1)$。~~容易发现~~，如果我们将$b+=a$和$a+=b$两个操作轮流进行，将可以产生以下数列：

```cpp
a b n cnt//cnt for the amount of operations done
1 1 1000000000 0
2 1 1000000000 1
2 3 1000000000 2
5 3 1000000000 3
5 8 1000000000 4
13 8 1000000000 5
13 21 1000000000 6
34 21 1000000000 7
34 55 1000000000 8
89 55 1000000000 9
89 144 1000000000 10
233 144 1000000000 11
233 377 1000000000 12
610 377 1000000000 13
610 987 1000000000 14
1597 987 1000000000 15
1597 2584 1000000000 16
4181 2584 1000000000 17
4181 6765 1000000000 18
10946 6765 1000000000 19
10946 17711 1000000000 20
28657 17711 1000000000 21
28657 46368 1000000000 22
75025 46368 1000000000 23
75025 121393 1000000000 24
196418 121393 1000000000 25
196418 317811 1000000000 26
514229 317811 1000000000 27
514229 832040 1000000000 28
1346269 832040 1000000000 29
1346269 2178309 1000000000 30
3524578 2178309 1000000000 31
3524578 5702887 1000000000 32
9227465 5702887 1000000000 33
9227465 14930352 1000000000 34
24157817 14930352 1000000000 35
24157817 39088169 1000000000 36
63245986 39088169 1000000000 37
63245986 102334155 1000000000 38
165580141 102334155 1000000000 39
165580141 267914296 1000000000 40
433494437 267914296 1000000000 41
433494437 701408733 1000000000 42
1134903170 701408733 1000000000 43
```
容易发现，这么做使得我们得到一个$a,b=f_{0,1}$的斐波那契数列。也就是说，如果我们采取“轮流相加”的策略，就有望将搜索的深度控制在极小的范围之内，也能取得极小的答案！

于是，结合这个思想，我们能写出这个程序：

```cpp
#include<bits/stdc++.h>
using namespace std;

int ans,T,a,b,k;

void dfs(int a,int b,int k,int cnt,int fl){
	printf("%d %d %d %d\n",a,b,k,cnt,fl);
	if(cnt>=ans) return;
	if(a>k || b>k) {
		ans=min(ans,cnt);
		return;
	}
	if(fl==-1){//为了保险，我选择两次轮流计算
		dfs(a+b,b,k,cnt+1,0);
		dfs(a,a+b,k,cnt+1,1);
	}
	else{
		if(fl){
			dfs(a+b,b,k,cnt+1,0);
		}
		else dfs(a,a+b,k,cnt+1,1);
	}
}

int main(){
	scanf("%d",&T);
	while(T--){
		scanf("%d%d%d",&a,&b,&k);
		ans=1<<30;
		dfs(a,b,k,0,-1);
		printf("%d\n",ans);
	}
} 
```
交上去，不出所料，AC了！

感谢大佬阅读，求点赞qwq