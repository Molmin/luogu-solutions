为了简化，将两种牛分成01。

状态表示：f[i]f[i]表示有i个数，最后一位是1的方案总数。

划分转移：倒数第二个1的位置。

因为两个1之间必须有k个0隔开，所以上一个1只能从$f[i-k-1]$转移过来

状态计算：

$ f [ i ] = f [ i − k − 1 ] + f [ i − k − 2 ] + … + f [ 0 ]$

状态划分：求的是所有方案，将所有方案以最后一个1所在位置划分为：

第0位(没有1)、第一位、第二位、… ，即$f[0]+f[1]+f[2]+…+f[n]$也就是f[]数组的前缀和，同时发现$f[i]$也

就等于$s[i-k+1]$，于是我们可以维护一个前缀和$s$，这样可把时间复杂度由$O(n^2)$变成$O(n)$

代码

```c++
#include <bits/stdc++.h>
using namespace std;
const int N = 100010 , mod = 5000011 ;
int f[N] , s[N];
int main()
{
    int n , k;
    cin >> n >> k;
    f[0] = s[0] = 1;//当i-k-1<0时，因为在i是1前面全是0的方案是可行的，所以为了加上这个方案，需要把f[0]设置为0
    for(int i = 1 ; i <= n ; i++)
    {
        f[i] = s[max(i - k - 1 , 0)];
        s[i] = (s[i - 1] + f[i]) % mod;
    }

    cout << s[n] << endl;
    return 0;
}

```



