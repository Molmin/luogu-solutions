用 $f_{i,0/1}$ 表示第 $i$ 位是/不是公牛的方案数，0代表不是，1代表是。

如果当前位不是公牛，则前一位是或不是都无所谓，则 $f_{i,0}=f_{i-1,0}+f_{i-1,1}$ 

如果当前位是公牛，那上一头公牛只能是第 $i-k-1$ 头牛或之前的某一头牛。由于我们是顺推，上一头公牛在前面的方案数已经包含在第 $i-k-1$ 头牛的方案数中。所以 $f_{i,1}=f_{i-k-1,0}+f_{i-k-1,1}$ 

递推式已经出来了，还有考虑一下初始化。最开始的 $i\;(i \leq k+1)$ 头牛里最多只有1头公牛，因此 $f_{i,1}=1;$ 在考虑 $f_{i,0}$ ，如果放一头公牛，这一头公牛有 $i-1$ 种可能的位置，加上没有公牛的一种情况，$f_{i,0}=i-1+1=i.$ 

然后就搞定啦awa

```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
const int mod=5000011;
int n,k,i,j,f[100010][2];
int main()
{
	scanf("%d %d",&n,&k);
	for(i=1;i<=k+1;i++) f[i][1]=1,f[i][0]=i;//初始化
	for(i=k+2;i<=n;i++)
	{
		f[i][1]+=(f[i-k-1][0]+f[i-k-1][1])%mod;
		f[i][0]+=(f[i-1][0]+f[i-1][1])%mod;//递推
	}
	printf("%d",(f[n][0]+f[n][1])%mod);//输出最后一位放与不放的总方案数
	return 0;//完结awa
}
```
