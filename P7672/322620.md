我们可以先直接把整一个字符串以及其反转的字符都记录在一个数组内，这样，就直接用一个双重循环，先从 $1$ 至 $N$ 循环，读入每一个字符串，然后从字符串长度减 $1$ 至 $0$ 循环，记录反转的字符，把其加到反转字符串的最后面。

然后，就有了两个字符串。这样我们可以暴力枚举每一种可能，如果找到，则输出，并且结束。

需要注意的是，即使是**同一个字符串**，也需要判断进去，如样例 2。

Code：
```cpp
#include <bits/stdc++.h>
using namespace std;
string st[1001], zh[1001];
//分别存储字符串与反转字符串
int n;
int main() {
	cin >> n;
	for (int i = 1; i <= n; i++) {
		cin >> st[i];
		for (int j = st[i].size() - 1; j >= 0; j--) zh[i] += st[i][j];
        //反转字符
	}
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= n; j++)
			if (st[i] == zh[j]) {
				cout << st[i].size() << ' ' << st[i][st[i].size() / 2];
				//输出长度和中间字符
				//要注意，字符串是从0至长度减1存储，所以不用再在st[i].size() / 2后面加1
				return 0;
			}
} 
```