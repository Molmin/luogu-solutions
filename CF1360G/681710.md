### 题解

**1.`YES` 与 `NO` 的判定**

首先，是判断 `YES` 和 `NO` 的问题。我们只要仔细读题，就能发现，因为每排有 $a$ 个 $1$，并且有 $n$ 排，那么很显然一共有 $n\times a$ 个 $1$；因为每列有 $b$ 个 $1$,并且有 $m$ 列，那么很显然一共有 $m\times b$ 个 $1$。那个只有当 $n\times a$ 与 $m\times b$ 不相同时，才无法构造，则输出 `NO`。

**2.对于矩阵的构造**

其次，是对于矩阵的构造。而具体的思路，楼下很多大佬是对于 $1$ 进行的构造，那我们反其道而行，对 $0$ 进行构造。

因为一排有 $m$ 个数字，而其中 $1$ 占了 $a$ 个，那么可以得到一排中的 $0$ 的个数为 $(m-a)$ 个。

在明确了个数之后，就是怎么摆放的问题。假设这排需要放 $s$ 个 $0$，那么我们把这 $s$ 个 $0$ 放在一起，相当于是构成一个由 $0$ 组成的序列，我们将这个序列放在开头（放在哪里其实都可以）。这样，首先就满足了一排有 $(m-a)$ 个 $0$，同时也隐含着这排有 $m$ 个 $1$ 的条件。接着，我们来到下一排，我们就直接把这一排的 $0$ 放在上一排的末尾的后一位。

比如说，当 $n=2,m=4,a=2,b=1$ 时，因为 $2\times2=4\times1$ 所以首先就满足了 $n\times a=m\times b$ 的条件。然后我们按照上面的构造方法，就可以构造出这样的一个矩阵：         
                                                                                      $\begin{bmatrix}0&0&1&1\\1&1&0&0\end{bmatrix}$

在这里，可能有的人就要问了：为什么这样做一定不会错呢？

这个问题，简单地说，就是这样可以让数字更平均的分布在矩阵中，因为除了输出 `NO` 的情况外，其它都是可构造的（保证有解）。

**3.具体做法**

因为上面我们已经讲了，将这排的 $(m-a)$ 个 $0$ 放在一起，构成一个序列，那么我们便用一个 $st$ 这个序列的开头给记录下来，用一个 $en$ 把这个序列的结尾给记录下来。我们让 $st$ 的初始值为 $1$，$en$ 的初始值为 $a$，那么到了第 $i$ 行，$st$ 的值就为 $(i-1)\times (m-a)+1$，$en$ 的值就为 $i\times (m-a)$。但是，还没完，如果当 $st$ 或 $en$ 的值超出了 $m$ 的范围，那么可以直接对 $m$ 进行取模。特别的，如果 $st$ 或 $en$ 的值为 $m$ 得倍数，即 $st\div m=0$ 或 $en\div m=0$ ，那么可以直接令 $st$ 或 $en$ 的值为 $m$。

把 $st$ 和 $en$ 的范围确定好之后，就简单了，即当一个数的下标 $st≤i≤en$，直接输出 $0$ 即可。特别的，当 $en≤st$ 时，即当一个数的下标 $st≤j$ 或 $j≤en$ 时，才输出 $0$。其余全都输出 $1$ 即可。

**4.AC Code**

```c++
#include<bits/stdc++.h>
using namespace std;
long long t,n,m,a,b,en,st,s;
int main(){
	scanf("%lld",&t);
	while(t--){
		scanf("%lld%lld%lld%lld",&n,&m,&a,&b);
		if(m==a&&n==b){//特判m=a并且n=b的情况
			printf("YES\n");
			for(int i=1;i<=n;i++){
				for(int j=1;j<=m;j++){
					printf("1");
				}
				puts(" ");//换行
			}
			continue;
		}
		if(n*a!=b*m){//判断是否可以构造出矩阵
			printf("NO\n");
			continue;
		}else{
			printf("YES\n");
			s=m-a;
			for(int i=1;i<=n;i++){
				st=((i-1)*s+1)%m;
				en=(i*s)%m;
				if(st==0) st=m;//特别判断当st为m的倍数的情况
				if(en==0) en=m;//特别判断当en为m的倍数的情况
				for(int j=1;j<=m;j++){
					if(st>en){//特别判断当en超过m，但st还未超过m的情况
						if(j<=en||j>=st){
							printf("0");
							continue;
						}else{
							printf("1");
						}
					}else{
						if(j>=st&&j<=en){
							printf("0");
							continue;
						}else{
							printf("1");
						}
					}
				}
				puts(" ");//换行
			}
		}
	}
	return 0;
} 
```