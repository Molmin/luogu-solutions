### 题目大意

给定一个非常大的奇数，让你交换它的两位，使得得到的数为偶数并且最大。

### 做法

比较容易想到，我们肯定要拿最高位的偶数来交换，这样增加的最多。

但是这里有一个问题。比如下面这个数字： $85321$ 。如果我们用上面的做法交换，那么就会得到 $15328$ 这个数字，很显然，最佳的答案是 $85312$ 。

所以我们把上面的做法修改一下：**把最高位并且小于最后一位的偶数来交换，如果没有则把最低位的偶数与最后一位交换。**

如果都没有，这说明比最后一位大的偶数没有，比最后一位小的偶数也没有，那么它就没有偶数，直接输出无解。

代码：
```cpp
#include<cstdio>
#include<iostream>
#define ll long long
using namespace std;
string ch;
bool temp=1;
int fir,las=-1;
int main()
{
    cin>>ch;
    for(int i=0;i<ch.size();i++)
    {
    	if((ch[i]-'0')%2==0&&ch[i]<ch[ch.size()-1]) //如果有比他小的偶数，因为我们是从前往后筛的，直接交换 
		{
			swap(ch[i],ch[ch.size()-1]);
			cout<<ch;
			return 0;
		}
	}
	for(int i=ch.size()-1;i>=0;i--)//如果没有比他小的偶数，那只能尽可能减少损失了 
	{
		if((ch[i]-'0')%2==0) 
		{
			swap(ch[i],ch[ch.size()-1]);
			cout<<ch;
			return 0;
		}
	}
	//此时我们把比最后那个奇数大的偶数和小的偶数都筛完了，发现都没有 
	cout<<-1;//上述两种情况都没发生，说明一个偶数没有 
	return 0;
}

```
