## 题意
定义模糊排列是指无法与它的翻转排列区分开来的排列。问一串数字是否构成。是输出 `ambiguous`，否则输出 `not ambiguous`。
## 思路
原题问的就是给你一串数字 （$b$），让你用 $c$ 的 $b_i$ 项等于 $i$ 构建数组 $c$，问 $b$ 是否等于 $c$。直接按照题意模拟即可。
## 解释题意
我们以数组 `2 3 4 5 1` 为例：

| B | 2|  4|  5|3 |1  |
| -----------: | -----------: | -----------: | -----------: | -----------: | -----------: |
| C |  |  |  |  |  |

我们观察到数组 $b$ 的第一个数字是 $2$，我们就将 $c$ 数组第二个数填上 $1$。

| B | 2|  4|  5|3 |1  |
| -----------: | -----------: | -----------: | -----------: | -----------: | -----------: |
| C |  |1  |  |  |  |

此时 $b$ 的第二个数字是 $4$，我们就将 $c$ 数组第四个数填上 $2$。

| B | 2|  4|  5|3 |1  |
| -----------: | -----------: | -----------: | -----------: | -----------: | -----------: |
| C |  |1  |  | 2 |  |

以此类推：

| B | 2|  4|  5|3 |1  |
| -----------: | -----------: | -----------: | -----------: | -----------: | -----------: |
| C | 5 |1  | 4 | 2 | 3 |

我们很容易发现这两个数组不一样，所以输出 `not ambiguous`。
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std; 
int main() {
	int a;
	while(scanf("%d",&a),a) {
		int b[100005],c[100005];
		for(int i = 1;i <= a;i++) {
			scanf("%d",&b[i]);
			c[b[i]] = i;
		}
		bool d = 1;
		for(int i = 1;i <= a;i++) {
			if(b[i] != c[i]) {
				printf("not ambiguous\n");
				d = 0;
				break;
			}
		}
		if(d) printf("ambiguous\n");
	} 
}

```
