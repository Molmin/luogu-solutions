# 题目大意

求一个数字的新旧位置互换(**即是数组的下标是所谓旧位置，而这个数列本身的数字又代表一种新的位置**)后,与之前的串是否相同。

相同时输出 `ambiguous`  ,否则输出 `not ambiguous` 。

---

**原序列**

| 数组编号 | 1 | 2 | 3 | 4 | 5 |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| 值 | 2 | 3 | 4 | 5 | 1 |

**经过变换之后**
| 数组编号 | 1 | 2 | 3 | 4 | 5 |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| 值 | 5 | 1 | 2 | 3 | 4 |

---

进过整理可得，要得到新的序列，只需要把原序列的数值编号。

# 分析

看到此题，莫名感觉很难。。。

但仔细审题之后，发现此题异常水。。。

设序列为 $A$ 的第 $i$ 位为 $A_i$, 那么我们只需要比较 $A_{A_i}$ 是否等于 $i$ 。

如果等于，输出 `ambiguous` , 否则输出 `ambiguous`。

# Code
```cpp
#include <bits/stdc++.h>
using namespace std;

int a[100005];

int main()
{
	int n;
	while(cin>>n && n)
	{
		for(int i=1;i<=n;i++) cin>>a[i];
		
		bool flag=0;
		for(int i=1;i<=n;i++)
			if(a[a[i]]!=i) 
			{
				flag=1;
				break;
			}
		
		if(!flag) cout<<"ambiguous"<<endl;
		else cout<<"not ambiguous"<<endl; 
	}
	
	return 0;
}
```

