楼下两个题解都要先模拟建树，但是模拟建树是会退化到O(N^2)的，例如插入顺序是1, 2, 3, ..., N。所以我们需要用一个有复杂度保证的方法建树。

设P[i]表示数字i是第几个被插入的，也就是P[ki]=i。因为插入的数字是1...N，那么每一个子树必然是连续的一段自然数（假设为[x, y]），且这个子树的根节点是 x ~ y 中最早被插入的，也就是求 P[x...y] 的最小值。求出最小值之后，假设为 z，我们将 z 设为当前子树的根节点，然后将区间 [x, y] 分成 [x, z-1] 和 [z+1, y] 递归处理，这样就可以在 O(n log n) 时间内将树建出来。

```cpp
int build_tree(int x, int y) { // 传入区间，返回根节点。
  int z = find_min(x, y);
  if (x < z) tree[z].l = build_tree(x, z-1);
  if (z < y) tree[z].r = build_tree(z+1, y);
  return z;
}
```
建完树之后，那么就是直接输出这棵树的先序遍历即可。
