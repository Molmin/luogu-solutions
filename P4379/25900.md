# 这道题真的很水

### 不是我骄傲，而是我的代码是真的一句废话都没有

因为题目说要求尽可能少，所以我们就推出了一个简单的贪心思想，言归正传，言简意赅：

首先，把数组用sort函数排个序（如果连sort都不知道，就不要做普及组的题了）。

然后，再从后往前看，如果目前人（牛）数比这头牛的底线数量还多，就跳出这个循环。否则就把目前人（牛）数++。下面是思路，已经懂了的人可以跳过。

## 思路

为什么要从后往前呢？因为我们要保证牛的数量尽可能少，后面的牛底限会比前面
    
的大，如果把它放在了前面，那么牛的数量会变多，那些更不愿意排队的牛就会离     
去。在第一头牛离去之后，我们就可以不管后面的了，因为我们是倒着看的，所以
    
后面的牛更懒得排队，前面的牛都走了，后面的还留着干嘛？
    
以下是标程：

	#include <bits/stdc++.h>

	using namespace std;

	int main(){
	
    	int n;
	
    	cin >> n;
	
    	int a[n+1], sum=0;
	
    	for(int i=1; i<=n; i++) cin >> a[i];
	
    	sort(a+1, a+n+1);
	
    	for(int i=n; i>=1; i--){
	
    		if(a[i]>=sum)
		
        		sum++;
		
        	else break;
	
    	}
	
    	cout<<sum<<endl;
	
    	return 0;

	}

# 点个赞再走吧！