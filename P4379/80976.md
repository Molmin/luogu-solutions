# P4379 【[USACO18OPEN]Lemonade Line】
### 蒟蒻的题解，很好理解，但不一定是最优解，也不一定是最简便的做法


------------

~~简单地~~，根据题面，我们可以得出，这道题就是奶牛~~发脾气~~，每一只奶牛都不愿自己前面有$w[i]$只奶牛，而农夫$John$想要给出最少的饮料——就是要让排队的牛最少

要使得排队的牛最少,果断$sort$，将~~脾气最好~~（$w[i]$最大）的奶牛排在最前面，把其他奶牛都气走。。。由于每头奶牛都是一头一头来的，我们可以~~抽象成~~：一只奶牛来，先走进队伍，看到前面牛太多了，走回去，把下一只牛叫来，下一只牛走进队伍，看了看牛，如果牛太多就走，不多就留着。这一过程。。。

~~具体的~~，我们来看**注释**

------------

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,w[100010];
bool cmp(int x,int y){
	return x>y;//从大到小排
}
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		scanf("%d",&w[i]);//输入每头牛前面允许排的牛的个数
	}
	sort(w+1,w+1+n,cmp);//sort啦
	int wait=n,still=0;//wait代表最后在排的牛，我们把wait设置成最大，没气走一头就wait--。still为当前队伍里在排队的牛，初始为0
	for(int i=1;i<=n;i++){//从w[i]最大的牛开始枚举
		if(w[i]<still){//如果有牛已经等不下去了（在它前面排队的牛太多了）
			wait--;//它就被气走了，最后排队的牛的个数--
			still--;//还在排队的牛的个数--
		}
		still++;//如果它没有被气走，它就入队，如果他被气走了，仍然在排队的牛的数量不变
	}
	printf("%d",wait);
	return 0;
}
```
