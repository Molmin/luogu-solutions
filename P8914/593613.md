### Solution 1
爆搜，因为每个点怪物最多只会访问一次，所以暴力枚举怪物的游荡路线，期望通过 $\text{subtask}1$。
### Solution 2
对于特殊性质 $\text{B}$，给定图为一条链，两种情况：
- 在终点的异侧：
	
	此时怪物只有朝小 A 的方向走才有机会抓到小 A，相遇问题，判一下谁先到 $F$，之后转换成在终点同侧处理。

- 在终点的同侧：

	仍需怪物朝小 A 的方向游荡，然后再细分为两种情况：

	如果怪物距离点 $F$ 更近则是相遇问题，答案为点 $B$ 到点 $S$ 的距离除以 $5$。

	而如果小 A 距离点 $F$ 更近则是追击问题，$\text{小 A 到怪物的距离} \times 2 \le \text{小 A 到终点的距离}$ 则为 `NO`，否则为 `YES`。

第二行答案也不难计算，期望通过$\text{substask}3$。
### Solution 3
对于特殊性质 $\text{A}$，给定图为一棵树，不难想象这棵树的有贡献节点只有小 A 到 $F$ 最短路上的每个点与怪物到「怪物与小 A 的最近公共祖先」最短路上的每一个点，其他点是没有贡献的（如果怪物走了其他点就不可能再捉到小 A 了），所以我们可以直接忽略其他点。

首先排除怪物是小 A 的一个祖先，因为这样可以直接当作链来处理。

除去上面的情况，考虑怪物抓小 A 时会先到达「怪物与小 A 的最近公共祖先」，之后小 A 有两种位置可能：在 $S$ 与公共祖先之间，在公共祖先与 $F$ 之间，此时可以当作链处理，前者相遇问题，后者追击问题，容易解决，期望通过 $\text{subtask}3 \sim 4$。
### Solution 4 
再去细想一下，怪物想要尽快抓到小 A 的话，就需要按照当前怪物的位置到小 A 的最短路路径去走（也就是实时最短路），直到怪物走到小 A 之前走过的路径后，就可以看成怪物严格按照小 A 走过的路径去追赶，（因为小 A 走过的路径是最短路，怪物要沿着到小 A 的最短路去走）。

所以可以通过 Floyd 跑出全源最短路，同时在小 A 到 $F$ 的路上暴力枚举路径上的每一个中间点，直到怪物走到小 A 走过的路上（或可能直接抓到小 A），然后就可以按照链来处理了，期望通过数据点 $\text{subtask}1 \sim 3$。不过如果细节处理过于麻烦的话可能会退化到 $\text{subtask}1 \sim 2$。
### Solution 5
考虑小 A 的移动路线是固定的，在 Solution 4 的基础上进一步思考，发现怪物在前半段的移动路线可以看成是某一时刻小 A 所处的位置为终点的最短路（相当于怪物学会了预判）。

那么也就是说我们并不需要让怪物走实时最短路，只需要暴力枚举小 A 移动路线上的每个点作为怪物的目标点，当怪物走到目标点之后变成链的情况处理即可，最后对所有情况得到的答案取最小值即可，期望通过所有测试点。
### 后记
因为感觉这题太简单所以留了个小数处理的部分。对于这部分我们可以在读入的时候将边权乘二，因为追击问题的速度是 $1$，相遇问题的速度是 $5$，所以乘 $2$ 之后只会出现 $0.2$、$0.4$、$0.6$、$0.8$ 的小数情况，可以直接对 $5$ 取模分类讨论。

而得到答案之后可能需要把 $2$ 除回来，只会出现 $0.5$ 的小数情况，同样可以取模讨论。

直接转换成 double 用 printf 保留小数位输出可能会出现 $x.0$ 的情况（不过可以直接判一下有没有小数位），cout 不加其他限制输出 double 时是自动保留 6 位有效数字的（可能出现精度损失）。

---
除此之外对于小 A 移动路径问题需要找字典序最小的最短路，注意不要从点 $S$ 跑最短路找小 A 最短路上每个点的字典序最小的前驱（正确性错误），而是要从点 $F$ 跑最短路找每个点字典序最小的后继（找的时候注意要确定是最短路上的点）。

前者可以举例子轻易卡掉：

从点 $1$ 到点 $4$ 分别有两条最短路径 $1 \rightarrow 2 \rightarrow 3 \rightarrow 4$ 和 $1 \rightarrow 3 \rightarrow 4$，若按照前者方法去跑的话对于点 $3$ 的前驱为 $1$，会导致小 A 的移动路径变为错误的 $1,3,4$，而真正的字典序最小应该为 $1,2,3,4$。