发现各位大佬的代码很不美观！

满代码的$if$，~~真是又臭又长~~

蒟蒻这里提供一种思路，~~思路比较清奇独特~~：

先打出函数$f(x)$，返回：
- 当$x>0$返回$1$
- $x=0$时返回$0$
- $x<0$时返回$-1$

相信这个是很简单的，代码：
```C++
int f(int x){
	if(x<0)return -1;
	if(x>0)return 1;
	return 0;
}
```

因为玩的是最终看哪个队赢了，所以我们可以用一个$ans$代表TEAM 1的总得分，当他们每胜利一局得$1$分，失败扣$1$分，平局得$0$分。

很容易看出当$ans$为负数时TEAM 2胜利，$0$是平局，正数就是TEAM 1胜利。

我们可以设计出剪刀，石头和布的对应数字，使他们满足TEAM 1出的$-$TEAM 2出的$=$分数

例如TEAM 1出剪刀，TEAM 2出的是石头，那么照理说TEAM 1输了所以就是$-1$。也就是剪刀$-$石头$=-1$。

照理列出不等式组（设剪刀为$a$，石头为$b$，布为$c$）：

 $\begin{cases}a-b<0\\b-c<0\\a-c>0\end{cases}$
 
 乍一看，似乎这根本没有解，但是，你还记得这么一个笑话吗？
 
 > $a>0,a+1<0$
 
 > $a=2147483647$
 
 没错，我们可以利用这个性质，来求出$a,b,c$。得出$a=80000000_{(16)},b=0,c=1$。
 
楼上有很多大佬已经说了：判断字符串时只需要读第一个字符。

所以我们构造出$D(c)$：
```C++
int D(char c){
	if(c==56)return 0x80000000;//56相当于'8'
	if(c-91)return 0;//如果不是布
	return 1;//石头
}
```
那么只需要循环，$ans=ans+f(D(s[i])-D(v[i]))$，最后判断$ans$即可。