~~随机跳到这道题，简单看了一下题面，然后直接点开题解。~~

言归正传，看了这里面好几篇题解，都是 $n^3$ 复杂度的，不过我思考了一下这道题完全可以 $n^2$ 通过。

我们设状态 $dp[i]$ 意义为我们走到点 $i$ 的时候穿的最小编号的鞋子的编号，如果为 $0$ 就意味着走不到这里，我们设初值 $dp[1] = 1$ ，理由应该是比较显然。

我们考虑转移，考虑朴素的想法，我们现在穿着第 $i$ 双鞋子，要考虑能不能走到第 $j$ 块砖上。思考上一步在哪里，一定是第 $i$ 双鞋子可以走到的地方，也就是  $f_k <= s_i$ 的地方，同时我们还必须保证上一步的地方我们能走到，也就是 $dp[k] \neq 0$ ，以及需要我们能一步走过来，既 $i - k \leq d_i$ 。当这些条件都满足的时候，我们可以从 $k$ 走到 $i$ 。

整理一下，对于同一个 $i$ ，我们可以找出一些砖 $k$ 满足 `k<=i && dp[k] && f[k]<= s[i]` 这些条件，我们可以将他们标记上。那么我们如何求在 $i$ 前 $d_i$ 个砖里面有没有标记的点呢？我们可以用类似滑动窗口的方法来进行处理。

综上，我们需要枚举每一双鞋子，还要枚举出每一块砖，复杂度是 $O(NB)$ 。

具体细节可以看代码来理解，相信大家都能读懂不到 $500B$ 的代码的！
```cpp
int n,b,f[N],dp[N];
int main()
{
	n = read(),b = read();dp[1] = 1;
	for(int i = 1;i <= n;i ++) f[i] = read();
	for(int i = 1;i <= b;i ++) {
		int s = read(),d = read();
		for(int j = 1,p = 1,tmp=0;j <= n;j ++) {
			while(j-p > d) {
				if(dp[p] && f[p] <= s) tmp --;
				++p;
			}
			if(tmp && !dp[j] && f[j] <= s) dp[j] = i;
			if(dp[j]&&f[j]<=s) ++tmp;
		}
		if(dp[n]) {printf("%d",dp[n]-1);return 0;}
	}
	printf("%d ",dp[n]-1);
	return 0;
}
```