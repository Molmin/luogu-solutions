[ P4265 【[USACO18FEB]Snow Boots S】](https://www.luogu.com.cn/problem/P4265)

### 前言：

今天上午的考试中，考了这道题。开始没想出来，后来用贪心乱搞竟然也有70分，后来才在同学的讲解中明白了，来写篇题解整理思路。

## 1.审题

题目大意：

给定一些地砖，以及上面积的雪，有一些靴子，可以在地砖上通过，但是要求踏在地砖上时靴子的耐受度 $s_i$ 要比雪的厚度 $f_i$ 要大，并且要使跨过去的长度小于 $t_i$。

注意：**一双靴子可以跨很多步。**

## 2.解题

### 2.1方法确定

思路一（错误）：贪心，将每一双靴子走到不能再走了才换。

这种思路看起来很对，但实际上会出现错误，**如果出现在一个地方换，可能会有其他地方换，而可以跳过这个地方而不换的，就会有错**。

思路二：动态规划，由刚刚的错误思想，现在就可以明确方向了。

### 2.2状态设计

题解区已经有了很多的状态，这里给出一种。

我们令 $f_i$ 为到达第 $i$ 个地砖的**最少用鞋数**

则答案是很明确的：$f_N-1$ 。最后的一双是穿在脚上的。

### 2.3递推方程

$f_i=\min{k}$ 要求：$1$ 与 $i$ 中有一个 $j$，表示从第 $j$ 个跳到第 $i$ 个上，$k$ 要在 $f_j$ 和 $B$ 中选一个，保证距离和不会陷进去就行了。

### 2.4边界

$f_1=0$，不用换鞋。

## 3.实现

```cpp
#include<bits/stdc++.h>
using namespace std;
int N,B,ans=0;
int f[255];
int s[255],t[255];
int F[255];
int main()
{
	scanf("%d%d",&N,&B);
	for(int i=1;i<=N;i++)scanf("%d",&f[i]);
	for(int i=1;i<=B;i++)scanf("%d%d",&s[i],&t[i]);
	for(int i=1;i<=N;i++)F[i]=1e9;
	F[1]=0;
	for(int i=2;i<=N;i++)
	for(int j=1;j<i;j++)
	for(int k=F[j];k<=B;k++)
	{
		if(s[k]>=f[i]&&s[k]>=f[j]&&t[k]>=i-j)
		{
		   F[i]=min(F[i],k);
		   break;
		}
	}
	cout<<F[N]-1;
	return 0;
}
```




