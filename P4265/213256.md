## 题意归纳：

有 $N$ 块格子，每块格子上有一个雪的深度 $f_i$ ，要从 $1$ 号格子走到 $N$

号格子，还有 $B$ 双靴子，每双靴子有两个限制，表示最多能在雪深为 $s_i$ 的

格子中行走，每次最多走 $d_i$ 格，而且靴子是按照输入顺序依次使用，如果要

更换靴子，那么换掉的就不能继续用第二次，求最小的靴子更换次数，另外还要注

意的是，每次由于可以走多个格子，只需要考虑开头和结尾的格子即可，这是题意

易错点。

## Solution：

本题可以 $DP$ ，可以记忆化搜索，二者的本质是一样的，不过记忆化搜索的实现

方式在本题显然更加简便，于是我们使用记忆化搜索。

用一个函数 $dfs(k,wz)$ 表示当前的一种状态，表示当前已经用到了第 $k$ 双靴

子，走到了位置 $wz$ 的最小更换次数，考虑如何进入接下来的状态。

总的来谈，这类题目的经典考虑方式是换与不换。

如果不换，每次可以走的最多步数是 $d_k$。

每次在 $dfs$ 内枚举走的步数，更新到 $dfs(k,wz+i)$ 即可。

如果要换，那么考虑换到哪一双靴子，从当前 $k$ 开始枚举换到某双靴子 $i$ 

即可，下一个状态是 $dfs(i,wz)$ 。

既然是记忆化搜索，那么我们用一个数组 $r$ 记录某个状态 $dfs(k,wz)$ 是否

可以达到，如果在搜索过程中发现已经可以达到了，则不需要再次重复做无用

功，直接返回即可。

另外还有一个剪枝，如果当前算出来的最小靴子数比已经求出来的答案还要大

了，那正在枚举的方案一定不是最优的，返回即可。

```cpp
#include<bits/stdc++.h>
using namespace std;
int r[300][300],n,b,f[300],s[300],d[300],change,ans=9999999;
void dfs(int k,int wz)
{
    if(change>=ans) return;
    if(r[k][wz]==1) return;
    r[k][wz]=1;
	if(wz==n)
	{
		if(change<ans) ans=change;
		return;
	}
	else
	{
		for(int i=1;i<=d[k];i++)
		{
			if(f[wz+i]<=s[k])
			{
				dfs(k,wz+i);
			}
		}
		for(int i=k+1;i<=b;i++)
		{
			if(f[wz]<=s[i])
			{
				change=change+i-k;
				dfs(i,wz);
				change=change-i+k;
			}
		}
	}
}
int main()
{
	cin>>n>>b;
	for(int i=1;i<=n;i++) cin>>f[i];
	for(int i=1;i<=b;i++) cin>>s[i]>>d[i];
	dfs(1,1);
	cout<<ans;
	return 0;
}
```






