一共三个点，从贪心的角度出发，中间点不动，分别移动两端的点，要比移动中间的点要节约。
证明：若中间点B发生了移动，则AB间距离与BC间距离都会发生改变(一个变大，一个变小)，容易导致原本合法的点不合法了，还得在移动另一个点。
综上所述，只需要将两端的点分别向两端移动，中间点保持不变，大体为这个样子：![](https://cdn.luogu.com.cn/upload/image_hosting/3nvwlej4.png)

------------
代码的实现也很容易，利用数组存三点坐标，利用sort排序后，轻易得出中间点,则两端分别移动的大小为“d-abs(a[1]-a[2])”，“d-abs(a[2]-a[3])”。
核心代码如下
~~~cpp
for(int i=1;i<=3;i++){
	a[i]=read();
}
sort(a+1,a+4);
d=read();
int ans=0;
if(abs(a[1]-a[2])<d)
	ans+=d-abs(a[1]-a[2]);
if(abs(a[2]-a[3])<d)
	ans+=d-abs(a[2]-a[3]);
printf("%d",ans);
~~~