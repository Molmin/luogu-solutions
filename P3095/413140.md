## [题意](https://www.luogu.com.cn/problem/P3095)
给定一个 $M$ 的置换，初始有一个 $1$ 到 $N$ 的排列，不断对前 $M$ 个数进行置换，然后取出第一个数，不足 $M$ 时不置换只取出。

然后进行 $Q$ 次询问，每次求出取出的第 $x$ 个数。

## 题解
### 算法 1
在普通置换问题中，每个位置经过置换后都会到达一个互不相同的位置，而本题中，所有数置换后还会向前移一位，第 $1$ 个数被取出，有一个数被补到最后。仔细分析置换的过程，可以发现任意时刻在第 $M$ 个位置上的数，经过多次置换和向前移动的操作后，必然都会被取出，因为不会有一个已经出现过的数被替换到位置 $M$ 形成环。

所以我们可以将 $M$ 个位置分成两类，其中有一条从入口位置 $0$ 到位置 $M$ 的路径，这条路径不断的取出新的数并补充新的数进来。另一类就是各种大小不一的环，里面的数置换后就是环中不断变换的位置。

基于上述分析，我们可以将取数流程分为三段，假定从 $0$ 到 $M$ 的路径长度为 $t$。首先是 $N - M + 1$ 次置换后取出的数，其中又可以细分为两段，前 $t$ 个数时路径中已有的数，之后是从 $M + 1$ 开始的补充进来的数。最后一段是所有置换完成后剩下的 $M - 1$ 个数。

对于最后的 $M - 1$ 个数，路径的位留下的是最后进入路径的 $t - 1$ 个数，位置 $M$ 没有数，因为此时已经没有新的数补充进来。其他位置就是环，我们可以一次找一个环，用同余求出每个位置上的数。

我们可以求出整个取数序列，然后每次询问就可以直接求解了。

注意，有可能置换的操作次数很少，导致最初在路径中的数都没取出来，此时路径中可能会有一些最初就在路径中，但是位置变化的数，还有一些是新补充进来的数。

时间复杂度 $\mathcal O\left(N\right)$

### 算法 2
预处理出每个位置置换 $2^i$ 次时的倍增数组。

每次询问暴力跳倍增即可。

注意走到 $0$ 时应及时终止，因为已经离开了队列。

时间复杂度 $\mathcal O\left(N \log N\right)$

### 算法 3
倒推。**从后往前** 模拟每次置换，求出当前牌在本轮置换以前的位置。这样单次询问的复杂度就是 $\mathcal O\left(N\right)$。总时间复杂度 $\mathcal O(N \cdot Q)$，2013 年的老机器过不了。

代码写的是 算法 2。

## 代码
```cpp
constexpr tp Hat_LM = 30, Hat_M = 1e5 + 3;
tp n = ra, m = ra, q = ra;
array<array<tp, Hat_M>, Hat_LM> p;
for (tp i = m; i; --i) {
  p[0][m - ra + 1] = i - 1;
}
for (tp i = 1; i < Hat_LM; ++i) {
  for (tp j = 1; j <= m; ++j) {
    p[i][j] = p[i - 1][p[i - 1][j]];
  }
}
while (q--) {
  tp q = ra, t = q < m ? m : q, l = n - t + 1, ql = 0;
  q = q < m ? q : m;
  for (tp i = Hat_LM - 1; ~i; --i) {
    if (tp loc = ql + (1ll << i); loc <= l && p[i][q]) {
      ql = loc;
      q = p[i][q];
      t += 1ll << i;
    }
  }
  printf("%lld\n", n - t + m - (ql != l ? p[0][q] : q - 1));
}
```