看到题目，第一个想到的方法是枚举i和j，时间复杂度是O(n²)，子任务4时间复杂度就是4000000²,显然会超时。

这里介绍一种方法——尺取法。两个指针l和r，分别表示左端下标和右端下标。变量h表示左指针到右指针的和。

改变指针的条件：

(1)l>r，即左指针在右指针后，则r++,即将右指针加一，同时还要把h-=a[r]。

(2)h超过m，则l++,即将左指针加一，同时还要把h-=a[l]。

(3)其他情况，将r++,即将左指针加一，同时还要把h+=a[r]。

运用这种方法要注意，在循环结束后的值不会统计进去，还要再次判断更新。

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[4000005];
int main()
{
    ios::sync_with_stdio(false);
    int n,m,l,r,x,y;
    int h=0,d=0;
    cin>>n>>m;
    for(register int i=1;i<=n;i++)    //输入
    	cin>>a[i];
    l=r=1;     //一开始左右指针均为1
    x=y=0;     //一开始结果下标均为1
    h=a[1];    //一开始左指针到右指针的和为a[1]
    while(r<=n)     //循环
    {
    	if(l>r)    //第一种情况
	{
		h-=a[r];
		r++;
	}else if(h>m){    //第二种情况
   	 	h-=a[l];
 	  	l++;
	}else{    //第三种情况
		if(h>d)    //判断是否大于原来最大值
		{
			d=h;
			x=l;
			y=r;    //更新结果
		}
		r++;
		h+=a[r];
	}
    }
    if(h>d && h<=m)    //再次判断更新
    {
	d=h;
	x=l;
	y=r;
    }
    cout<<x<<' '<<y<<' '<<d<<endl;   //输出
	return 0; 
}
```