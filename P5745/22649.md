### **2019/12/23 UPD：更正了部分叙述不合理的内容。**

------------

本次比赛里最难的一道题，其实也不是很难，自打题库有这道题就想做了，~~当时还好奇为什么不能查看，现在才明白是比赛试题~~。


------------
## **以下是正文：**
题目要求求出不超过M的最大子序列和，~~作为一个OI选手的本分~~首先我们考虑暴力。

------------

$\Large 30pts$

很容易想到 $\large n^2$ 的暴力做法，即将系列先前缀和一下，然后再用两个 $for$ 循环把系列从头到尾扫一遍，在 $sum_j-sum_i$ 中取一个不超过 M 的 $max$ 即可，可以拿到30分的好成绩（然而 $ACM$ 赛制不 $AC$ 就没有分数）。

代码就不放了。

------------

$\Large 100pts$

运用大眼观察法，发现对于一个已知最大子序列和为其后缀的序列，在其后面插入一个 $k$ 时有两种情况：

当 $max+k\leq M$ 时，新的 $max_{new}$ 必然等同于 $max+k$ 。

当 $max+k>M$ 时，先前的最大子序列和 $max$ 已经不可能再对答案做出贡献了，考虑到 $k$ 可能对区间起点后移的子序列和做出贡献，我们持续后移子序列的区间起点直至后移 $s$ 个元素后 $max_{s}+k\leq M$，更新 $max_{new}=max_{s}+k$。

对于不超过M的最大子序列和，在所有 $max$ 中取一个最大值即可。

得出了这个结论后，我们便可以用  $dp$ 解决本题了。

**代码：**
```cpp
#include<iostream>
#include<cstdio>
#include<string>
#include<cstring>
#include<cmath>
#include<algorithm>
using namespace std;
int n,m,dp[2],a[8101919],s=1,ms,me,maxn,k;//n,m,a[]与题面描述相同，dp为递推数组。 
int main()//ms,me为不超过M的最大子序列和区间的最小左端点、右端点，maxn为不超过M的最大子序列和，k用于滚动数组优化空间。
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&a[i]);//读入部分。 
		while(dp[k]+a[i]>m)//对不能对答案做出贡献的最大子序列和进行更新。 
		{
			dp[k]-=a[s];
			s++;
		}
		dp[!k]=dp[k]+a[i];
		k=!k;//滚动数组优化。 
		if(dp[k]>maxn)//更新答案。 
		{
			maxn=dp[k];
			ms=s;
			me=i;
		}
	}
	printf("%d %d %d",ms,me,maxn);//输出部分。 
	return 0;
}
```


------------
$postscript:$本人对本次比赛F题出锅却不重测代码表示强烈谴责。