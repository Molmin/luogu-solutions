# CF1261E Not Same

[题目链接](https://codeforces.com/contest/1261/problem/E)

---

把问题稍微转化一下，变成要求构造一个 $n+1$ 行 $n$ 列的 $01$ 矩阵，每一列的和给定，并且要求任意两行互不相同。

记 $b(i, j)$ 表示答案矩阵第 $i$ 行第 $j$ 列上的数。

---

**法一**：

> 首先将所有数**从大到小**排好序。
>
> 对第 $i$ 个数，相当于要在第 $i$ 列填 $a_i$ 个 $1$。我们从第 $i$ 行开始向下走，依次把经过的前 $a_i$ 个格子填上 $1$（如果到底了就返回第 $1$ 行）。

下面证明这种做法的正确性。

> 首先，如果我们对排好序的 $a$ 序列构造出答案后，再把答案的矩阵列按照原顺序交换，显然结果仍是正确的。故以下讨论的 $b$ 矩阵，均为对排好序的 $a$ 序列构造的答案。
>
> 我们要证明，按上述方法构造出的 $b$ 矩阵，不存在完全相同的两行。
>
> 反证法：考虑两行 $i, j$ （$i < j$），假设这两行相同。
>
> 简单分类讨论一下：
>
> - 情况一：$1\leq i < j\leq n$。
>
> 因为 $a_{i + 1}\leq n$，所以 $b(i, i + 1) = 0$。又因为第 $i$ 行与第 $j$ 行相同，所以 $b(j, i + 1) = 0$。所以 $a_{i + 1}\leq j - i - 1$。
>
> 如果 $i + 2\leq j$，考虑第 $i + 2$ 列。要么 $b(i,i + 2) = b(j, i + 2) = 1$，要么 $b(i, i + 2) = b(j, i + 2) = 0$。如果 $b(i,i + 2) = b(j, i + 2) = 1$，那么 $a_{i + 2}\geq j - i + 1$。然而，由于 $a_{i + 2}\leq a_{i + 1}\leq j - i - 1$，所以这种情况不存在，所以只可能 $b(i, i + 2) = b(j, i + 2) = 0$。所以 $a_{i + 2}\leq j - i - 2$。
>
> 同理，可以推出，$\forall k \in[1, j - i]:a_{i + k}\leq j - i - k$。所以 $a_{j}\leq 0$。与题意矛盾。
>
> - 情况二：$1\leq i\leq n$，$j = n + 1$。
>
> 因为 $a_{i}\geq 1$，所以 $b(i, i) = 1$。又因为第 $i$ 行与第 $j = n + 1$ 行相同，所以 $b(n + 1, i) = 1$。所以 $a_{i}\geq n + 2 - i\geq 2$。
>
> 如果 $i > 1$，考虑第 $i - 1$ 列。因为 $a_{i}\geq 2$，所以 $a_{i - 1}\geq a_{i}\geq 2$。所以 $b(i, i - 1) = 1$。所以 $b(n + 1, i - 1) = 1$。所以 $a_{i - 1}\geq n + 3 - i$。
>
> 同理，可以推出，$\forall k \in[0, i - 1]: a_{i - k} \geq n + k + 2 - i$。所以 $a_{1} \geq n + 1$，与题意矛盾。

顺便一提，我们原本的想法是把 $a$ 序列按**从小到大**排序。这样也能得到一个“似乎正确”的做法。但是该做法可能导致第 $n$ 行和第 $n + 1$ 行相同。这给我们的启示是：

1. 在证明时，注意考虑 $i\leq n$，$j = n + 1$ 的特殊情况，是至关重要的。
2. 如果从小到大排序不行，可以尝试反过来。

[参考代码-在CF查看](https://codeforces.com/contest/1261/submission/107536774)

---

**法二**：

> 不需要排序。
>
> 我们从 $1$ 到 $n$，依次考虑每一列。
>
> 假设当前考虑到底 $i$ 列，我们看看前 $i - 1$ 列里（$(n + 1)\times(i - 1)$ 的矩阵里）有哪些相同的行（初始时所有行都是相同的）。
>
> - 如果没有相同的行，那么后面无论怎么填，都不会再出现相同的行。所以可以随便填。
> - 否则找出相同的两行 $r_1, r_2$，令 $b(r_1, i) = 1$，$b(r_2, i) = 0$。剩下的 $a_i - 1$ 个 $1$ 随便填。

下面证明这种做法的正确性。

> 把相同的行视为一组，记录每组的大小，得到一个可重集。
>
> 例如，初始时所有行都是相同的，那么可重集就是 $\{n + 1\}$。加入了 $a_1$ 后，可重集变成：$\{a_1, n + 1 - a_1\}$。
>
> 如果所有行都不同，那么可重集是 $\{1, 1, \dots, 1\}$（$n + 1$ 个 $1$）。
>
> 否则我们每次操作的效果，相当于至少会拆掉可重集里的一个 $> 1$ 的数。即，从可重集里选择一个 $x > 1$，删掉它，再加入两个数 $x_1, x_2$，满足 $x_1 + x_2 = x$，$x_1, x_2 > 0$。
>
> 原可重集 $\{n + 1\}$，在变为 $\{1, 1, \dots, 1\}$ 前，**最多**可以被操作 $n$ 次。
>
> 所以经过 $n$ 次操作后，可重集一定会变为 $\{1, 1, \dots, 1\}$，即所有行都不相同。

朴素实现是 $\mathcal{O}(n^4)$ 的（即每次暴力枚举两行，再暴力判断它们是否相同）。

对行哈希，用哈希来判断是否相同，可以做到 $\mathcal{O}(n^2\log n)$ 或者 $\mathcal{O}(n^2)$。

[参考代码-在CF查看](https://codeforces.com/contest/1261/submission/107588423)


