## $Problems$
在一个长度为 $n$ 的一个矩形内，一共有 $a$ 艘船，每只船长度为 $b$ ，其中有 $k$ 个已经轰炸过的位子 （$0$ 表示这个位置没被轰炸过， $1$ 表示这个位置已经被轰炸过了），保证这些轰炸过的位子一定不是船的某部分（即被轰炸的是整一艘船）。

现在问你最少再轰炸多少次，就能轰炸到一艘船。
## $Answer$
每连续的 $b$ 个 $0$ 就要炸一次，不然不知道有没有可能刚好就有一艘船在 $b$ 这个位置上面。我们利用贪心可知发现炸这 $b$ 个的最后一个最划算。

因为只要炸到一艘即可，所以答案减去 $a-1$，即有 $a-1$ 艘可以不管它。
## $Code$
```cpp
#include<bits/stdc++.h>
int a,b,n,k,d,ans,p[200010];
char s[200010];//开大一点总是保险的
int main()
{
    scanf("%d%d%d%d%s",&n,&a,&b,&k,s);
    for(int i=0;i<n;i++)
    {
        if(s[i]=='0')
        {
            d++;
            if(d==b)
            {
                d=0;
                ans++;
                p[ans]=i+1;
            }
        }
        if(s[i]=='1')d=0;
    }//去寻找b个0
    ans-=a-1;//把a-1个位置去除掉
    printf("%d\n",ans);
    for(int i=1;i<=ans;i++)printf("%d ",p[i]);//输出存着的位置
    return 0;//好习惯，记得return
}
```