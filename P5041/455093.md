# P5041 [HAOI2009]求回文串 题解

多看多学多练。贪心好题。现有题解思路上叙述比较简单，现对此题贪心正确性做系统证明。

## 题意简述

给定一个字符串 $S$，求出将其变为回文串所需要的最小邻位交换次数。

 $\vert S\vert\leq 10^6$。

## 思路分析

~~没思路~~

题面看起来很人畜无害，但是考虑复杂度要求过于严苛，大概率是一道贪心题。

咋贪呢？

首先，我们可以感知到我们可以以从外向内的顺序完成每一个目标字符的归位，即将其移动到最优解时它应当处在的位置。另外，我们也可以感知到我们只需要保证令每一位成为回文串是最优解，就可以保证全局是最优解。因此，贪心策略如下：

- 从外向内逐位完成回文串匹配。
- 对于每一位的匹配过程，我们有两种方案：
  - 固定区间左端，让最靠右的相同字符匹配区间右端。
  - 挑选一个字符，使其未匹配的且处于最左和最右的两个字符移动到当前需要匹配的位置，挑选所有字符的移动值取最小值，即可保证答案最优。

## 贪心正确性证明

这个贪心一眼看漏洞百出。为什么这样的方案能保证局部最优？为什么不会产生后效性？为什么从外至内匹配是合理的？让我们逐步完成这一结论的证明。

### 引理1

从外至内匹配是合理的。

#### 证明

~~证明想一年~~

考虑对于初始状态。设在最优解当中我们将 $AA$ 移动至左右端点。无论如何，它们一定会在最终到达左右端点，且不会有其他字符从次端点移动至端点。因此，不考虑 $AA$ 在字符串中的移动，剩余部分的匹配不涉及 $AA$以及左右端点，是一个完整的子问题。将 $AA$ 想象成”幽灵结点“，其他结点跨过幽灵结点不会发生移动，而会消耗 $1$ 的代价。而幽灵节点一定要到达两端，定义左边的 $A$ 到左端点距离与右边的 $A$ 到右端点距离为 $x$，即其至少会消耗代价 $x$ ，而如果不优先移动 $AA$ ，则幽灵节点可能会发生与目标方向相反的移动，则意味着幽灵节点造成的额外贡献会增加，造成的代价一定要大于等于 $x$ 。证毕。

### 引理2

贪心策略确实是局部最优解，且不会产生后效性。

#### 证明

基于**引理1**，我们考虑假设当前应该从外向内数匹配第 $l$ 位。考虑从外向内匹配的过程其实是删去一个一个的字符对的过程。考虑对于字符对 $AA$ 和 $BB$ ，它们分别应匹配至 $l$ 和 $l+1$ ；那么它们的匹配顺序不影响剩下的字符串，即不会产生后效性。它们的位置关系有以下几种情况：

对于下图第一种情况，显然应该先匹配 $AA$；此时 $A1,A2$ 到两端的距离和显然小于 $B1,B2$。

对于下图第二种情况，先匹配 $AA$ 或 $BB$ 都会使另一对的匹配减少两步，所以都一样。

对于下图第三种情况，先匹配 $AA$ 或 $BB$ 都会使另一对的匹配减少一步，所以都一样。

![](https://cdn.luogu.com.cn/upload/image_hosting/764stsih.png)

注意到有区别的情况仅限图一。目前的两种主流贪心方案为：

- 固定区间左端，让最靠右的相同字符匹配区间右端；

- 求出到两端距离最小的字符。

注意到它们都能识别出图一的情况并进行正确的操作，因此，我们可以论证两种主流贪心方案都能够保证答案的正确性。

## 实现

实现上来说就相对比较简单了。我们按照第一种贪心方案，使用双端队列将每一个字符的位置存储起来，可以方便求出每一个字符最右端，这样就可以用 $O(n)$ 的复杂度完成原字符串的排序，接下来通过树状数组用 $O(n\log n)$ 的复杂度求一遍逆序对即可。

## 代码

```c++
#include<bits/stdc++.h>
using namespace std;
#define int long long
int rnk[1000005]={0},cnt[1000005]={0},s[1000005]={0},t[1000005]={0};
bool vis[1000005]={0};
char S[1000005];
deque<int>q[30];
int n;
int lowbit(int x) {return x&-x;}
void add(int x,int k){
	while(x<=n){
		t[x]+=k;
		x+=lowbit(x);
	}
}
int sum(int x){
	int ret=0;
	while(x>=1){
		ret+=t[x];
		x-=lowbit(x);
	}
	return ret;
}
signed main(){
	scanf("%s",S+1);
	n=strlen(S+1);
	int cntj=0;
	for(int i=1;i<=n;i++){
		s[i]=S[i]-'A'+1;
		q[s[i]].push_back(i);
		cnt[s[i]]++;
		if(cnt[s[i]]%2==0) cntj--;
		else cntj++;
	}
	if(cntj>=2){
		cout<<"-1";
		return 0; 
	}
	int tot=0,ii=0;
	while(tot<n/2){
		ii++;
		if(vis[ii]) continue;
		if(q[s[ii]].size()==1) continue; 
		vis[ii]=1;
		vis[q[s[ii]].back()]=1;
		rnk[ii]=++tot;
		rnk[q[s[ii]].back()]=n-tot+1;
		q[s[ii]].pop_front();
		q[s[ii]].pop_back();
		
	}
	for(int i=1;i<=26;i++){
		if(!q[i].empty()){
			rnk[q[i].front()]=++tot;
			break;
		}
	}
	int ans=0;
	for(int i=1;i<=n;i++){
		add(rnk[i],1);
		ans+=i-sum(rnk[i]);
	}
	cout<<ans;
	return 0;
} 
```

