upd : 修改了代码中的错误，原 `tr[x].st.end()` 应改成 `tr[x].st.rbegin()`。

## Description

定义三种操作:

1. `add x y` : 在坐标系上添加一个点 $(x,y)$。

2. `remove x y` : 移除点 $(x,y)$。

3. `find x y` : 找到所有已标记并在 $(x,y)$ 右上方的点中，最左边的点。

$m \le 2 \times 10^5$，$0 \le x,y \le 10^9$。

## Solution

可以先将所有点**按横坐标离散化**一遍，使用数据结构维护在某个 $x$ 坐标上的**所有点的纵坐标**。

我们思考一下我们需要维护什么，由于查询需要 $y_{ans}>y$，于是我们可以记录每个 $x$ 坐标**对应的所有点的 $y$ 坐标的最大值**，可以使用线段树，查询时在线段树上二分即可。

二分到第一个存在一个点，使得纵坐标大于给定 $y$ 的横坐标之后，我们需要求出这个横坐标对应的、纵坐标大于 $y$ 的最下面的点。由于一共不超过 $2\times 10^5$ 个点，我们离散化后可以对每个横坐标开一个 `set`，存储横坐标对应点的所有纵坐标，查询二分即可。

复杂度大概是 $O(n\log^2 n)$ 的，不用卡常。

[AC 记录](https://codeforces.com/contest/19/submission/174303857)