问题简述：

给你N个数，它们是1或2，要求分出最少集合，使每个集合中要么只有1或只有2，要么1和2的个数之差不超过M。

算法分析：

每个集合里的数在原数串中都是连续的一段，采用类似区间动态规划的思想，将[1,i]区间分成[1，j]区间与合法[j+1,i]集合组成，则要使[1,i]区间满足条件的集合数最小，显然[1，j]区间满足条件的集合数为最小，即每一段的最小值都可以从前面的某一段的最小值转移过来。

每次考虑对于[1,i]这段数，决策是从前面的所有数段[1,j](j<i)中找一个段。满足：1、第J+1个数到第I个满足组成一个集合的条件；

2、第1个到第J个数所组成的集合总数最少。

则段[1,i]的最小集合数为：第1个到第J个数所组成的集合总数的基础上加1。

分析组成一个集合的条件，题目已经告诉我们，一个集合中要么只有1或只有2，要么1和2的个数之差不超过M。

预处理，设 s1[i]，s2[i]分别表示区间[1,I]中1的个数与2的个数。用O(N)的代价求得。

区间[i,j]中：

1的个数S1＝s1[j]-s1[i-1]；

2的个数S2＝s2[j]-s2[i-1]；

这样，只要S1=0 或S2=0或ABS（S1-S2）<=M，就能组成集合。

设F[i]表示第1个到第I个数所组成的最少集合数量。

转移方程为：

F[I]=MIN{F[J]}+1{S1[J+1,I]=0 or S2[J+1,I]=0 or ABS(S1[J+1,I]-S2[J+1,I])<=M}


```cpp
procedure main;
var i,j:longint;
begin
for i:=1 to n do 
   for j:=1 to i do
      if (abs(s1[j,i]-s2[j,i])<=m) or (s1[j,i]=0) or (s2[j,i]=0) then {满足条件}
     f[i]:=min(f[i],f[j-1]+1); {进行转移}
end;

```