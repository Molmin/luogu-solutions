### 思路：

发现 $k$ 是最没有用的变量，因为等价于在 $[0,1]$  中选一个实数的答案扩大 $k$ 倍，因为策略总是相同的。

先手玩 $n=1$ 的答案，发现当 $m=0$ 时 Alice  一定会选 $0$，$m=1$ 时 Alice  会蹬鼻子上脸选 $1$，因为他怎么选 Bob 都得加上去。

设 $f_{i,j}$ 表示 $n=i,m=j$ 时的答案，那么 $f_{i,0}=0$，$f_{i,i}=i$。

手玩 $n=2,m=1$ 时发现不是那么显然，假设 Alice 给出了 $p$ 这个实数，那么 Bob 可以选择加或不加，也就是 $f_{2,1}=\min(f_{1,0}+p,f_{1,1}-p)$，当然 Alice 是**足够聪明**的，自然会让 $\min(f_{1,0}+p,f_{1,1}-p)$ 尽量大，也就是使得 $f_{1,0}+p=f_{1,1}-p$，即取 $p=\frac{f_{1,1}-f_{1,0}}{2}$，带入 $p$ 得到 $f_{2,1}=\frac{f_{1,1}+f_{1,0}}{2}$。

因此得到一般情况下 $f_{i,j}=\frac{f_{i-1,j-1}+f_{i-1,j}}{2}$。

考虑到最后是在模 $10^9+7$ 意义下的分数，直接求 $2$ 的逆元乘起来即可，当然也可以模拟分数。

### 代码：

```cpp
int t,n,m,k;
signed main()
{
	int inv=ksm(2,mod-2)%mod;//求 2 的逆元
	for(int i=1;i<=2000;i++) dp[i][i]=i,dp[i][0]=0;
	for(int i=1;i<=2000;i++)
	{
		for(int j=1;j<=2000;j++)
		{
			if(!dp[i][j])
			{
				dp[i][j]=((dp[i-1][j-1]+dp[i-1][j])%mod*inv%mod)%mod;
			}
		}
	}
	cin>>t;
	while(t--)
	{
		cin>>n>>m>>k;
		cout<<(dp[n][m]*k)%mod<<"\n";
	}
	system("pause > null");
}
```



