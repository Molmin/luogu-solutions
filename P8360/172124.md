怎么会这样...

$O(n\sqrt{n})$ 竟被我 $O(n\sqrt{n}\log{n})$ 爆踩（大雾）

这里提供一种好想好写的 DS 做法。

首先，我们看到有多种颜色，容易联想到类似于树的虚树，那我们可以考虑对每种颜色开一颗动态开点线段树，然后一操作就是简单的 split 和 merge 了。

对于二操作，我们只需要在线段树上区间加就好了。

然而，三操作，我们的复杂度一下就崩到了缓慢的 $O(c\log n)$，这启发我们可以对个数根号分治。

如果一种颜色的个数不小于 $B$，那么就像上述一样维护；如果小于 $B$，那么暴力。（下文称两者为大树和小树）

具体到操作上，我们还是维护 $C$ 棵线段树，序列用树状数组维护，线段树只维护区间增量。如果修改操作打到了小树上，那直接 pia 地一下下放到底层直接打到序列上（就直接打到树状数组上）；否则如果是大树，就把标记留到线段树上。这里瓶颈是小树的 $O(B \log{n})$。

对于询问，我们 Q 一下树状数组，再把所有大树上的增量询问一遍求和就是答案。这一步复杂度是 $O(\frac{n}{B}\log{n})$。

(P.S.大树的集合用一个 set 维护就行。)

那么把 $\log{n}$ 提出来，就可以知道 $B$ 取 $\sqrt{n}$ 时复杂度最优。

本来的话，就应该到代码环节了，可是悲惨的笔者不会线段树分裂（

所以就用的是之前的一个小柯基（[科技](https://www.luogu.com.cn/blog/hello--world/ti-xie-p2697-mu-ban-xian-duan-shu-fen-lie-post)）就是 treap 值域可交分裂合并。理论上复杂度崩成了 $O(n\sqrt{n}\log^{1.5}{n})$，但是离谱的是跑得飞快，只跑了 10s 多一点点，最慢的点也就 1.79s。（建议时限缩到 2s。（bushi

而且没调 $B$ 的系数还是目前最优解就离谱。

这里放一下 [代码](https://www.luogu.com.cn/paste/bn7p92pa):

[代码](https://www.bilibili.com/video/BV1GJ411x7h7)

不要看看上去代码很长，但是如果手熟的话，打起来其实很顺很爽的。（但是 debug 很难受（