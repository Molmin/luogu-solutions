# 应该比较通俗易懂

### 思路 

[高斯求和公式](https://www.luogu.org/blog/127520/cf1095a-ti-xie)已经在这里讲了，代码里就直接用了

用计数器m表示已经使用的砖块数，然后枚举层数i，直到i层符合要求但i+1层不符合时输出即可，注意i每次增加都要加上对应层数的砖块数i*(i+1)/2

根据思路，贴出代码：

```
#include <bits/stdc++.h>
using namespace std;
int m,i,n; 
int main(){
cin>>n;
for(i=1;;i++){  //这里面保证有解所以不用退出
	if((i+1)*i/2+m<=n&&(i+2)*(i+1)/2+m+(i+1)*i/2>n){    
    	
        //(i+1)*i/2+m<=n表示第i层需要的砖块
       
       //(i+2)*(i+1)/2+m+(i+1)*i/2表示i+1层（第i层加上第i+1层新增的）。
		cout<<i;   //如果满足则输出
		return 0;
	}
m+=(i+1)*i/2;  //不满足则加上第i层策砖块数
}
return 0;
}
```
