## 题意
给定一个长度为 $n$ 的 $01$ 串，定义“好的 $01$ 串”为每一个连续的 $0$ 子段或 $1$ 子段的长度都是偶数的 $01$ 串，求把给定的 $01$ 串变为“好的 $01$ 串”的最小操作次数。保证 $n$ 是偶数。

## 思路
经过分析题意之后不难发现，对于一个 $01$ 串 $S$ ，如果 $S$ 是一个“好的 $01$ 串”，那 $S00$ 和 $S11$ 也是“好的 $01$ 串”。

因此，我们两个两个元素遍历，若相邻的两个元素不同则把它们变为相同的，记录操作次数输出就可以了。由于题目保证了 $n$ 是偶数，所以不用担心会越界。

## AC 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int t,n;
char a[300001];
int main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	cin>>t;
	while(t--)
	{
		cin>>n;
		cin>>a;
		int ans=0;
		for(int i=1;i<n;i+=2)//两个两个遍历
		{
			if(a[i]!=a[i-1])
			{
				a[i-1]=a[i];
				ans++;
			}
		}
		printf("%d\n",ans);
	}
	return 0; 
}
```
