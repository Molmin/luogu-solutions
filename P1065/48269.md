- ### NOIP 2006 提高组 第三题

## 题目描述

我们现在要利用 $m$ 台机器加工 $n$ 个工件，每个工件都有 $m$ 道工序，每道工序都在不同的指定的机器上完成。每个工件的每道工序都有指定的加工时间。

每个工件的每个工序称为一个操作，我们用记号 $j-k$ 表示一个操作，其中 $j$ 为 $1$ 到 $n$ 中的某个数字，为工件号；$k$ 为 $1$ 到 $m$ 中的某个数字，为工序号，例如 $2-4$ 表示第 $2$ 个工件第 $4$ 道工序的这个操作。在本题中，我们还给定对于各操作的一个安排顺序。

例如，当 $n=3,m=2$ 时，“``1-1,1-2,2-1,3-1,3-2,2-2``”就是一个给定的安排顺序，即先安排第 $1$ 个工件的第 $1$ 个工序，再安排第 $1$ 个工件的第 $2$ 个工序，然后再安排第 $2$ 个工件的第 $1$ 个工序，等等。

一方面，每个操作的安排都要满足以下的两个约束条件。

$(1)$ 对同一个工件，每道工序必须在它前面的工序完成后才能开始；

$(2)$ 同一时刻每一台机器至多只能加工一个工件。

另一方面，在安排后面的操作时，不能改动前面已安排的操作的工作状态。

由于同一工件都是按工序的顺序安排的，因此，只按原顺序给出工件号，仍可得到同样的安排顺序，于是，在输入数据中，我们将这个安排顺序简写为“``1 1 2 3 3 2``”。

还要注意，“安排顺序”只要求按照给定的顺序安排每个操作。不一定是各机器上的实际操作顺序。在具体实施时，有可能排在后面的某个操作比前面的某个操作先完成。

例如，取 $n=3,m=2$，已知数据如下：

![](https://i.loli.net/2018/12/22/5c1dee2c0af78.jpg)

则对于安排顺序“``1 1 2 3 3 2``”，下图中的两个实施方案都是正确的。但所需要的总时间分别是 $10$ 与 $12$ 。

![](http://pic002.cnblogs.com/images/2010/133181/2010102423271740.jpg)

当一个操作插入到某台机器的某个空档时（机器上最后的尚未安排操作的部分也可以看作一个空档），可以靠前插入，也可以靠后或居中插入。为了使问题简单一些，我们约定：在保证约束条件$(1)(2)$的条件下，尽量靠前插入。并且，我们还约定，如果有多个空档可以插入，就在保证约束条件$(1)(2)$的条件下，插入到最前面的一个空档。于是，在这些约定下，上例中的方案一是正确的，而方案二是不正确的。

显然，在这些约定下，对于给定的安排顺序，符合该安排顺序的实施方案是唯一的，请你计算出该方案完成全部任务所需的总时间。

## 输入输出格式

### 输入格式

第 $1$ 行为两个正整数，用一个空格隔开：

$m,n$（其中 $m(<20)$ 表示机器数， $n(<20)$ 表示工件数）

第 $2$ 行： $n \times m$ 个用空格隔开的数，为给定的安排顺序。

接下来的 $2n$ 行，每行都是用空格隔开的 $m$ 个正整数，每个数不超过 $20$ 。

其中前 $n$ 行依次表示每个工件的每个工序所使用的机器号，第  $1$ 个数为第 $1$ 个工序的机器号，第 $2$ 个数为第 $2$ 个工序机器号，等等。

后 $n$ 行依次表示每个工件的每个工序的加工时间。

可以保证，以上各数据都是正确的，不必检验。

### 输出格式

$1$ 个正整数，为最少的加工时间。

## 输入输出样例

- 输入样例#1
```
2 3
1 1 2 3 3 2
1 2 
1 2 
2 1
3 2 
2 5 
2 4
```
- 输出样例#1
```
10
```

## 题解

这是一道语文题啊qwq。表示看了好久才看懂题面的意思。

然后发现数据范围那么小，肯定是乱搞啊。

### 一些定义

$sjz_{i,j}$ 表示目前第 $i$ 个机器在第 $j$ 秒是否有空位，有则为 $0$ ，无则为 $1$ 。

$jq_{i,j}$ 表示第 $i$ 个物件做第 $j$ 道工序时用的是那个机器。

$ti_{i,j}$ 表示第 $i$ 个物件做第 $j$ 道工序的用时。

$a_i$ 表示读入的顺序序列中的第 $i$ 个数，即第 $i$ 个操作的物件的编号。

$dq_i$ 表示的是第 $i$ 个物件现在要做第几道工序。

$dqt_i$ 表示的是第 $i$ 个物件在完成上一道工序后的时间。

### 具体实现

现在您已经了解了我们将用到的每一个数组的含义啦！

对于第 $x$ 个操作，我们可以知道 $a_x$ 现在做的是哪一道工序。并且知道这一道工序最早什么时候开始。因此我们就可以枚举一下这个最早的时间，为了方便，不妨设其为 $i$ ，并且现在在 $z$ 号机器上完成第 $y$ 道工序。

对于一个时间 $t$ ，如果 $\sum_{j=t}^{t+ti_{x,y}-1}=0$，那么这就是一个合法的时间 $t$ ，然后暴力一下就可以啦！

最终答案 $ans=max\{i+ti_{x,y}\}$ 。

建议大家在写的时候打打注释，会更容易理解qwq。

```
//Code by zzj.
#include <cstdio>
int sjz[21][100001];
int jq[101][101],ti[101][101];
int dq[1000001],dqt[1000001];
int a[1000001];
int ans=0;
void doit(int cz)
{
	int x=a[cz]; 
	int y=dq[x];
	int z=jq[x][y];
	int sj=ti[x][y];
	for(int i=dqt[x]; ;i++)
	{
		bool flag=true;
		for(int j=i;j<=i+sj-1;j++)
		{
			if(sjz[z][j]==1)
			{
				flag=false;
				break;
			}
		}
		if(flag==true)
		{
			dqt[x]=i+sj;
			dq[x]++;
//			printf("物品 %d 在 %d 号机器上做第 %d 个工序，在第 %d ~ %d 秒。\n",x,z,y,i,i+sj);
			if(i+sj>ans)
			{
				ans=i+sj;
			}
			for(int j=i;j<=i+sj-1;j++)
			{
				sjz[z][j]=1;
			}
			break;
		}
	}
}
int main()
{
	int m=0,n=0;
	scanf("%d %d",&m,&n);
	for(int i=1;i<=n*m;i++)
	{
		scanf("%d",&a[i]);
	}
	for(int i=1;i<=n;i++)
	{
		dq[i]=1;
		for(int j=1;j<=m;j++)
		{
			scanf("%d",&jq[i][j]);
		}
	}
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			scanf("%d",&ti[i][j]);
		}
	}
	for(int i=1;i<=n*m;i++)
	{
		doit(i);
	}
	printf("%d",ans);
	return 0;
}
```