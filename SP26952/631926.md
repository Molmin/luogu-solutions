### 题目大意

求所有的 $N$ 位二进制数中，首位为 $1$ 的数的个数和所有的 $N$ 位二进制数中的 $1$ 的总个数。

### 大致思路

#### Part 1 第一个问题

显然，首位为 $1$ 的数去掉首位后正好构成所有 $N-1$ 位二进制数（不管有没有前导 $0$）。每一位的取值可以是 $0,1$ 两种，所以总共有 $2^{N-1}$ 种。

在 C++ 位运算中有一个操作叫做**左移**（`<<`），可以将一个整数的二进制位向左移动任意位数，即将这个数乘上 $2^{k}$，但效率比乘方高，因此求 $2^{N-1}$ 可以写作 `1ll << (N - 1)`。

**注意：本题要开 `long long`。左移运算符类型与左侧类型相同，因此需写成 `1ll << (N - 1)`。**

#### Part 2 第二个问题

不妨将所有的情况用树状图列出来：

$$\Large1^{1^{1^{1}_{0}\cdots}_{0^{1}_{0}\cdots}}_{0^{1^{1}_{0}\cdots}_{0^{1}_{0}\cdots}}$$


设 $N$ 位的二进制数中首位为 $1$ 的数的个数为 $S$，则显然所有 $1$ 的个数为：

$$S+\dfrac{S}{2}(N-1)$$

化简、代入得：

$$(N-1)2^{N-2}$$

### AC Code

将这两部分结合起来。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
int n, x;

signed main() {
	cin >> n;
	while (n--) {
		cin >> x;
		if (x == 1) {
			cout << 1 << ' ' << 1 << endl;
			continue;
		}
		cout << (1ll << (x - 1)) << ' ' << (1ll << (x - 2)) * (x + 1) << endl;
	}
	return 0;
}
```

SPOJ 运行编号：31536310。

运行时间：0.01s。