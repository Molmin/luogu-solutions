### 思路分析
```
其实这题并没有想象中的那么困难，题中给的速度什么的都没用（只是当一个杯子满了后多出来的部分会平均分配给下两个杯子），而t也可以看做第一个杯子里面有t杯酒。所以核心思路就是模拟，从第一层扫到最后一层，如果a[i][j]>1，那么ans++，再分给下面的杯子
```
### 代码如下
```cpp
#include<bits/stdc++.h>
using namespace std;
double a[11][11];
//n超级良心，可以开的很小。注意这里是double，因为整形在除的时候可能为0
int n,t,ans;
int main(){
	cin>>n>>t;
    //读入n和t
	a[1][1]=t;
    //因为一共有t秒，所以第一层第一个会装有t杯酒
	for (int i=1;i<=n;i++)
		for (int j=1;j<=i;j++)
        //从第一层一直扫，因为第i层有i个酒杯所以j要扫到i
			if (a[i][j]>=1){
            //如果某个酒杯中的酒大于一杯也就是会溢出
				ans++;
                //答案总数加一
				a[i+1][j]+=(a[i][j]-1)/ 2.0;
				a[i+1][j+1]+=(a[i][j]-1)/ 2.0;
                //下面一层的两个对应酒杯分别分到一半（就算下面没有也不会影响最终结果，因为不会被扫到）
			}
	cout<<ans;
    //最后输出就好
	return 0;
}
```
