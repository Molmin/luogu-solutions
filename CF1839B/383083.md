# CF1839B Lamps 题解
## 写在最前

**请一定一定把题意读明白！！！**

~~蒟蒻~~因为没有读明白题意，犯了很多错误。

## 题意注意点

当一个灯点完之后正好坏了，我们可以得到其分值，当目前所有亮着的灯的数量 $x \ge a_i$ 时，所有和该灯 $a$ 值一样的灯都会坏掉。

还有就是对于一盏灯，如果点亮它时，正好它坏了，那么 $x - 1$ 且给答案加上该灯的贡献值。

## 分析

那么显然可以想到，我们对于所有的灯，以 $a$ 值为第一关键字从小到大排序，把所有 $a$ 相同分成多段，我们可以在每一段中，挑选其中贡献值最大的一个，作为答案的一部分，加入 $ans$ 中。

**对于上面的解释：**

因为我们每次点亮的话，当前点亮的灯数量 $x$ 会 $+1$ 所以我们考虑在每段挑选出最大的贡献值，并加入到 $ans$ 当中。其实就是贪心，我们把每一层最大的贡献值选中，那么最终答案一定是最大的。

还要考虑分完段后，会出现 $a$ 值不连续的情况，参考一下样例：

```
1 1
1 2
3 3
3 4
```

其中就没有 $a = 2$ 的情况，对于这样的，我们可以考虑把原本要在 $a=2$ 这一段选的，放到 $a=3$ 中去选。

**对于上面的解释：**

其实就是，原本我是每一层都选一个最大的，但是我这样的断层情况里没法选 $a=2$ 的那一层，所以我们就给 $a=3$ 那一层多选一个灯（你没法在 $a=1$ 里面多选，所以给 $a=3$ 里多选）。

**分析一个样例看看**

原数据：

```
5
3 4
3 1
2 5
3 2
3 3
```

排序后：

```
5
2 5
3 4
3 1
3 2
3 3
```

那么我们可以分成俩部分，如下用 $---$ 划分：

```
5
2 5
----
3 4
3 1
3 2
3 3
```
先选 $2 \space \space 5$ 然后再在剩余一部分中选择 $3$ 个，这里为什么要选 $3$ 个呢？

因为当我们点亮第 $2$ 盏灯时，第一次选择的 $2 \space \space 5$ 这盏灯会灭掉，所以我们要再点 $3$ 盏灯。

## 具体实现：

我们考虑随便用个容器装好 $a$ 值和 $b$ 值，然后排序、分层，最后在每一层里模拟上述**分析**部分的过程，每一层里挑个最大的，遇到断层情况就把本属于这一层的加到下一层里去，最终累加得到答案。

## 代码实现

分析完毕，我们来看看代码。

~~马蜂清奇，不喜勿喷~~。

```C++
#include <bits/stdc++.h>
#define int long long
using namespace std;
void sol() { 
    int n;
    cin >> n;
    vector <pair <int, int> > val(n);
    for (int i = 0; i < n; i++) cin >> val[i].first >> val[i].second;
    map <int, vector <int> >mp;
    int ans = 0;
    set <int> st;
    for (int i = 0; i < n; i++) {
        st.insert(val[i].first);
        mp[val[i].first].push_back(val[i].second);
    }
    for (auto c : st) {
    	sort(mp[c].begin(), mp[c].end());
    	reverse(mp[c].begin(), mp[c].end());
    }
    for (auto c : mp) {
        for (int i = 0; i < min((int)c.first, (int)c.second.size()); i++) {
            ans += c.second[i];
        }
    }
    cout << ans << '\n';

}
signed main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    int t;
    cin >> t;
    while (t--) {
         sol();
    }
    return 0; 
}
```