# 真蒟蒻弱发题解
#### ~~这是真的一道大水题~~
为撒子嘞，因为优秀的作者给了我们这段话：

### 提示：你可能需要用到的定理——伯特兰-切比雪夫定理。
那这个伯特兰-切比雪夫定理啥子的四撒子累？

虽然大家都不知道这是撒玩意，但是有万能的度娘啊！

~~**——作者还很棒的给了链接——**~~

以下是这什么鬼定理的定义：**伯特兰—切比雪夫定理说明：若整数n > 3，则至少存在一个质数p，符合n < p < 2n − 2。另一个稍弱说法是：对于所有大于1的整数n，存在一个质数p，符合n < p < 2n。**

但是，你会发现，这个定理一直没什么卵用……
再看看题目中的数据范围：2≤ n ≤ 10^14 2≤n≤10^14，循环一遍那就完了。对于我这个菜鸡，首先想到的就是暴力枚举一哈子。很巧的发现一个个神奇的答案们：所有数据的答案，不是1就是2！【一度怀疑是不是算错了】

### 不多废话，以下是分析

#### 为什么会出现上述的情况呢？

## 我们分两种情况：质数和合数
1. **质数**

   		I. 显然，对于一个质数而言，它与所有不是它的倍数的数互质，于是我们可以得到一个显而易见的结论：当(n/2)<k<n且k为质数时易可得只需1次就可以完成
        原理：没有数是它的倍数！又由于它是个质数，所以它自然与所有小于n的数互质
		II.当且k为质数时,由于有数是它的倍数，显然他们不互质，所以不可能一次完成，由于伯特兰-切比雪夫定理可知，一定有一个质数n<p<2n，这两个质数一定互质，所以最后又回到了第一种情况，所以一共需要1+1=2次鸭。
2. **合数**
		
        对于一个合数，显然一开始不与所有数互质，由伯特兰-切比雪夫定理可知一定有(n/2)<p<n，p为质数,显然这个合数不是p的倍数，与p互质，这是第一步，然后再由质数的第一种情况得出一共需要 1+1=2次。
        
# AC CODE
```cpp
#include <bits/stdc++.h>
using namespace std;
long long n,k;
bool prime (long x)
{
	if(x==1)
	{
		return 0;
	}
	if(x==2)
	{
		return 1;
	}
	for(int i=2;i<=sqrt(x);i++)
	{
		if(x%i==0)
		{
			return 0;
		}
	}
	return 1;
} 
int main ()
{
	cin>>n>>k;
	if(prime(k + 1) && 2 * k >= n)
	{
		cout<<1;	
	}
	else
	{
		cout<<2;
	}
	return 0;
}
```
## 对了，找质数那段里i<=一定是sqrt(x)，不然会崩！！