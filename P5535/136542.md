# 前言
这是一道签到级别的数论好题，不过出题人着实良心，把伯特兰-切比雪夫定理都告诉你了，这道题就送分了
# 思路
### 对于伯特兰-切比雪夫定理

若整数$n$ $>$ $3$，则至少存在一个质数$p$，符合$n$ < $p$  <$2n$ − $2$。另一个稍弱说法是：对于所有大于$1$的整数$n$，存在一个质数$p$，符合$n$ < $p$ <$2n$。(摘自百度百科)

我们只需要知道稍弱的说法就可以过掉这道题
## 分析
我们分两种情况：质数和合数

下文中的$n$,$k$与题目中的含义一致
### 质数
#### 第一种情况
显然，对于一个质数而言，它与所有不是它的倍数的数互质，于是我们可以得到一个显而易见的结论：当
$$[\frac{n}{2}]<k<n$$ 
且$k$为质数时可得只需要$1$次就可以完成任务，因为没有数是它的倍数，由于它自身是质数，所以它必然与所有小于$n$的数互质
#### 第二种情况
我们再考虑第二种情况，当
$$k\leq[\frac{n}{2}]$$ 
且$k$为质数时,由于有数为它的倍数，显然不互质，所以不可能一次完成，由于伯特兰-切比雪夫定理可知，一定有一个质数$n$ $<$ $p$ $<$ $2n$，两个质数一定互质，所以最后又回到了第一种情况，所以一共需要 $1$+$1$=$2$ 次。
### 合数
对于一个合数，显然一开始不与所有数互质，由伯特兰-切比雪夫定理可知一定有
$$[\frac{n}{2}]<p<n$$
$p$为质数,显然这个合数不是$p$的倍数，与$p$互质，这是第一步，然后再由质数的第一种情况得出一共需要 $1$+$1$=$2$次。
# AC Code
```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,k;
bool prime(long long x)
{
	long long i;
	for (i=2;i<=sqrt(x);i++)
	if (x%i==0) return false;
	return true;
}//判断素数
int main()
{
	cin>>n>>k;
	if (prime(k+1))
	{
		if ((n+1)/(k+1)==1) puts("1");//对应质数的情况1
		else puts("2");//对应质数的情况2
	}
	else puts("2");//合数就是两步
}
```
# 复杂度
#### 时间复杂度
$$O(\sqrt{k+1})$$
#### 空间复杂度
$$O(1)$$
# Tips
两年$OI$一场空，一场$long$ $long$见祖宗

题目中说了$n$和$k$要加$1$再运算