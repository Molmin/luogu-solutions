我又双叒叕被包菜辣！

[P5535 【XR-3】小道消息](https://www.luogu.org/problem/P5535)（~~这道题是个大水题~~

在题干中这位良心的作者就提醒了我们：

你可能需要用到的定理——伯特兰-切比雪夫定理。

那么什么是伯特兰-切比雪夫定理？

我也不知道，但~~无所不知的度娘知道就行了~~：

若整数n > 3，则至少存在一个质数p，符合n < p < 2n − 2。另一个稍弱说法是：对于所有大于1的整数n，存在一个质数p，符合n < p < 2n。

那么这个定理有什么用？

因为是从n中选一个数k，所以k + 1一定大于1

是不是刚好和伯特兰-切比雪夫定理的条件相吻合？

没错，我们想一下，分两种情况：

1.如果k + 1为质数，再分两种：

I.1~n中不含k+1的倍数，那么很明显第一天就可以了

II.1~n中含k+1的倍数，那么需要几天？

两天，为什么？因为在第一天，所有除去k + 1倍数的数都知道了，那么gcd((2 * (k + 1)), (2 * (k + 1)) + 1) = 1是一定的。所以只需要两天。

2.如果k + 1不是质数：

也是两天，告诉拥有k+1的质数编号的人，然后通过伯特兰-切比雪夫定理n > 3，存在p 符合n < p < 2 * n；

蒟蒻可能讲的不是很清楚，大家多多包涵，自己可以感性理解一下。

```cpp
#include<bits/stdc++.h>
using namespace std;

#define int long long //一定要开long long，不开long long 见祖先 

int n, k;

bool prime(int x)//很清晰的质数筛 
{
	if(x == 1)//特判一下1 
		return 0;
	if(x == 2)//特判一下2 
		return 1;
	for(int i = 2; i <= sqrt(x); ++ i)//就是枚举每个数，看看它是否是它的约数 
		if(x % i == 0)//如果不是的话 
			return 0;//直接return false 
	return 1;
}

signed main()
{
	scanf("%lld%lld", &n, &k);
	if(prime(k + 1) && 2 * k >= n)//其实，也很好理解，想一想，如果一个数是质数那么是不是除去它的倍数的数都与它互质？所以prime(k + 1)是判断它是不是质数，后面就是找有没有它的倍数（因为是连续的所以只有比一下大小即可 
		printf("1");
	else//除去1的答案就是二了（会有解释 
		printf("2");
	return 0;
}
```

PS：~~请看懂再抄~~