### 题意

计算一个整数被分解成若干个各不相等的 Fibonacci 数列中的数的方案 , $T \le 10^5,n \le 10^{18}$.


### Sol

只是存一份档，放在洛谷上给自己看，管理看不顺眼可以不过审。

首先有一个假方法，绕了我很久，方法很暴力，就是直接记 $\text{dp}_n$（用 map 存）表示 $n$ 的拆分方案，然后记忆化搜索转移，很不幸，它连 1e8 都跑不出来。

然后要想着优化对吧，所以我们先预处理出 $5 \times 10^5$ 的 dp 值，然后感觉上 1e18 的范围应该几步也能跑下来，但是又 G 了，因为 1e18 还是要减去二三十个斐波那契数才能到 $5\times 10^5$ ，还是没有大优化。

事实上这个方法是个死胡同，那我们先不想 dp ，先想我们最直观的感受是什么，我们先把问题特殊化（常用 trick ），如果我们要求使用斐波那契数最少的方案呢？这就是个经典题了，我们直接贪心。

那么，推广到原题，我们可不可以使用贪心+调整的思路呢？很遗憾，不可以，我们有一个不可忽略的限制就是使用的斐波那契数不能重复，你如果把一个大数调成了若干个小数之和相当于又对后面造成了影响，G 了；那么我们可不可以找到这个问题的“阶段”把它分拆成若干个子问题呢？很容易想到的是每个斐波那契数的拆分方案处理出来然后乘一乘，可这样又有刚才同样的问题了。

然后走投无路的我们又回到了 dp 上，很自然的一个思路是将 dp 与那个最原始的贪心（直接简单粗暴地定义为使用斐波那契数最少）结合起来，事实上这是别无选择的，为什么呢？因为我想了这么久我已经注意到了 dp 的缺点就是他只是把斐波那契数看成一个普通的数列，对这个数列背包，而没有利用 $\text{fib}_i=\text{fib}_{i-1}+\text{fib}_{i-2}$ 这个性质（单纯的背包自然无法处理这种线性递推）；而贪心的缺点在于它只注意到了斐波那契数列，却没有注意到斐波那契数列以外的限制（数不能相同，求的是方案数而不是最小）。

**所以，两种方法都太片面了，我们必须对它们取其精华去其糟粕**，不然没得玩。

于是我们设计了这样一个充满人类智慧的 dp （这就是积累吗…凭自己独立想只想出了一半就是 $f_i$ ，没想到那个 0/1 ）：我们考虑设贪心存储的那个最优斐波那契数序列为 $v_1,v_2...v_k$ 且 $v_1+v_2+…+v_k=n$ ， 且 $f_{i,0/1}$表示对 $v_1,v_2…v_i$ 表示出的数拆分的方案数，0/1 表示选/不选第 $i$ 项，设计这个 0/1是因为我如果不选 $v_i$ 但是这一位又要有其他位来管就会有不一样的情况。然后怎么转移呢？我们发现难点在不选第 $i$ 项时其他位如何表示出第 $i$ 项，这个时候斐波那契数列终于不再是个普普通通的数列了，他有 $\text{fib}_i=\text{fib}_{i-1}+\text{fib}_{i-2}=\text{fib}_{i-1}+\text{fib}_{i-3}+\text{fib}_{i-4}=...$，即每次能移动的位向低位移动两位。

这样就好办了，只需注意注意我移着移着不能和下一个1碰起来，我们就可以有转移式 

$$f_{i,0}=f_{i-1,0}\times \dfrac{v_i-v_{i-1}}{2}+f_{i-1,1}*\dfrac{v_{i}-v_{i-1}-1}{2}$$
（默认下取整），以及 $f_{i,1}=f_{i-1,0}+f_{i-1,1}$。

这样完了吗？其实还是有可探寻的地方，我们能保证上面那个式子一定是不重不漏的吗？**这不是显然的**，重点还是在 $f_{i,0}$ 的计算上，我们可不可以有一种方法使得 $\text{fib}_{i-1}$ 不取而依然表示出 $\text{fib}_i$ 呢？答案是不可以的，这样要用到重复的元素。

终于做完了。

所以，这种题看的不是代码是思维，真的，如果自己没有真心用心想过，一定会质疑为什么他是 `*2300` 而不是 `*1300` …

而只有那些喜欢做无用功的人，那些傻子，那些如我一般智力平平的 蒟蒻 OIer 们，才会知道这题的难啊。

可是，有谁关心过他们想东西时走的那许多弯路呢？

我曾经也以为，*3000 也不要用什么高深的知识，但是却渐渐明白 ，那些禀赋极高的人终究是极少数，我们没有看到大多数平平无奇的人为了那些看起来轻飘飘的文字与代码消耗了多少个日日夜夜，如果只是以轻松的表象来取悦自己的内心，将那些题解肆意玩弄，抄袭，何必呢？

如果您觉得我 naive ，您大可以把这个标签页关闭，那是您的自由。但我想，每一个如我一般，卑微、渺小、羸弱，而又渴望刺破苍穹的 OIer ，在第一次，第二次独立面对这些时，心中，都会有些许感触吧。

凡事得失兼备，万物圆缺常存。而走过的这些弯道，这些思考，这些难过，这些执着，又未尝不会在未来的某一时刻，凝聚成胸中风云，激荡万千？愿你，也愿我，能够在以后漫漫长路风雨兼程时，尚能有一份思考的冲动。让那不灭的激情，似光，似火，似萤，点亮黑暗，冲破囹圄。

我们，一起共勉，愿向着彼岸，手牵手走向明天。

衷心感谢您，在我最迷茫的时刻，读完了这篇文章，我已经感受到了那份隔着屏幕的慰藉与期许，也希望您的未来，将会大放异彩。

唱出你的热情，伸出你的双手，让我们期待明天会更好！

```cpp
#include<bits/stdc++.h>
#define int long long
#define pb push_back
using namespace std;
int T,n,s[101],f[101][2]; 
vector<int>vi;
signed main(){
	scanf("%lld",&T); s[0]=s[1]=1;
	for(int i=2;i<=90;i++) 
		s[i]=s[i-1]+s[i-2]; s[0]=0;
	while(T--){
		scanf("%lld",&n); vi.clear(); 
		for(int i=90;i;i--){
			if(n>=s[i]) n-=s[i],vi.pb(i);
			f[i][0]=f[i][1]=0;
		}reverse(vi.begin(),vi.end()); int ln=(int)vi.size();
		f[0][0]=(vi[0]-1)/2,f[0][1]=1;
		for(int i=1;i<ln;i++){
			f[i][1]=f[i-1][0]+f[i-1][1];//this indicates that fib[v[i]] has already been obtained and as a result the previous bits dont need change
			f[i][0]=f[i-1][0]*((vi[i]-vi[i-1])/2)+f[i-1][1]*((vi[i]-vi[i-1]-1)/2);
		}printf("%lld\n",f[ln-1][0]+f[ln-1][1]);
	}return 0;
}
```
