[题目](https://www.luogu.com.cn/problem/CF126D)

题意：$T$次询问，询问将$n$分解成斐波那契数列中互不相同的数的方案

这里的斐波那契数列第一项为$1$,第二项为$2$

$T\leq 10^5\quad n\leq 10^{18}$

~~又一道奇奇怪怪的题~~

首先求出$10^{18}$以内有$88$项，因为题目要求不能选取数列中同一个数，不妨把$n$先表示成一个$01$串，串上第$i$位表示是否取第$i$项

先不管怎么得到这个串，考虑如何从这个串推出其他合法的串串

如果这个串的某一位为$1$,并且它前两位为$0$,那么可以通过让前两位为$1$,这一位为$0$得到一个新的方案

考虑当前这一位的$1$和上一个$1$之间有$cnt$个$0$,那么当前这一位的$1$有$\frac{cnt}{2}+1$种方案。加$1$是不变化的方案，除以$2$是因为，每次变化后下一个能变化的$1$的位置往前偏移两位

并且每一个可拆分的$1$，如果将其拆分它上一位一定为$1$，原因和上面一样：每次变化后下一个能变化的$1$的位置往前偏移两位

记$v[i]$表示串串中第$i$个$1$的位是哪一位

设$f[i][0/1]$表示串串中第$i$个$1$是否取的合法方案数

$\displaystyle f[i][1]=f[i-1][0]+f[i-1][1]\quad$  

当前这一个取，上一个可以取/不取

$\displaystyle f[i][0]=f[i-1][0]\times \frac{v[i]-v[i-1]}{2}+f[i-1][1]\times \frac{v[i]-v[i-1]-1}{2}$

当前这一个不取，上一个不取，中间就有$v[i]-v[i-1]$个$0$（上一个的上一位一定是$1$）；上一个取，中间就有$v[i]-v[i-1]-1$个$0$

最后一个问题：如何得到这个串串？

为了保证答案没有遗漏，这个串所包含的项数应该是最少的，这样才能推出所有的方案

>首先证明：任何一个数都能表示成不同的斐波那契数的和

>采用数学归纳法证明：首先对于$n=1$时成立

>假定对于任意$k<n$都成立，如果$n$本身是一个斐波那契数显然成立

>如果不是，那么一定存在$fib_m<n<fib_{m+1}$

>即$0<n-fib_m<fib_{m-1}$

>根据归纳法：$n-fib_m$能表示成不同的菲波那切数数之和，并且因为它小于$fib_m$，所以这里面没有包含$fib_m$，所以给它加上$fib_m$就得到了$n$

根据上面这个结论，知道了我们需要的串串一定存在，并且还可以依据上述结论贪心地找出项数最小的表示方法

因为要项数最小，所以要让取的数尽可能地大，所以每次不断找到一个最大的$fib_m<n$，$n$减掉它，就得到了这个串串

时间复杂度$O(T\times 88)$

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>
#include <string>
#define ll long long
using namespace std;
int v[100];
ll fib[100],f[100][2];
int main()
{
	fib[1]=1,fib[2]=2;
	for(int i=3;i<=88;i++)
		fib[i]=fib[i-1]+fib[i-2];
	int T;
	scanf("%d",&T);
	while(T--)
	{
		int cnt=0; ll n;
		scanf("%lld",&n);
		for(int i=88;i>=1;i--)
			if(n>=fib[i]) v[++cnt]=i,n-=fib[i];
		reverse(v+1,v+cnt+1);
		f[1][0]=(v[1]-1)/2,f[1][1]=1;//第一如果取方案就是1，如果不取就是前面0的个数除以2 
		for(int i=2;i<=cnt;i++)
		{
			f[i][1]=f[i-1][0]+f[i-1][1];
			f[i][0]=f[i-1][0]*((v[i]-v[i-1])/2)+f[i-1][1]*((v[i]-v[i-1]-1)/2);
		}
		printf("%lld\n",f[cnt][0]+f[cnt][1]);
	}
	return 0;
}
```
