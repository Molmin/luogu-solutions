### 前置知识

乘法原理,补集转化.

### 朴素算法

先计算总和 $s$ ,再枚举所有子序列,判断其和是否为$s$.

时间复杂度 $\mathrm{O}(n \cdot 2^n)$,显然会超时.

### 对值域的算法

考虑维护一个桶, $B_i$ 表示和为 $i$ 的子序列的个数,每次添加一个数到桶里.

$a_i \le 10^9$,显然桶开不下.

### 正解

考虑补集转化,从 $a$ 中取出一个和为 $s - 1$ 的子序列后,剩下的所有元素和为 $1$ ,问题转化为求和为 $1$ 的子序列个数.

再看 $a$ 的值域 : $0 \le a_i \le 10^9$

发现其中不包含负数,于是和为 $1$ 的子序列形态为 $0,0,0,0 \cdots ,0,1$,最多只包含一个 $1$,此时这样的子序列个数只与序列中  $0$ 和 $1$ 的个数有关.

输入时统计序列中 $0$ 和 $1$ 的个数,记为 $x_0,x_1$

每个 $0$ 可以取或者不取,取出 $0$ 的方案数为 $2^{x_0}$.

只能取一个 $1$,取出 $1$ 的方案数为 $x_1$.

结果为 $2^{x_0} \cdot x_1$.

一定要记得开 ``long long`` !

### 代码

```cpp
#include<cstdio>
void solve() {
    int n;
    long long buc0 = 0,buc1 = 0;
    scanf("%d",&n);
    for(int i = 1;i <= n;++i) {
        int p;
        scanf("%d",&p);
        if(!p) ++buc0;
        else if(p == 1) ++buc1;
    }
    printf("%lld\n",(1ll << buc0) * buc1);// 这里不用1ll就会爆int
}

int main() {
    int T;
    scanf("%d",&T);
    while(T--) solve();
    return 0;
}
```