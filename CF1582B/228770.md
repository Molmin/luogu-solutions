### 题目大意

给定一个长度为 $n$ 的序列 $a$，令数列 $a$ 中所有元素的和为 $s$，请你求出有多少种删数方案，可以使得操作后的序列 $a$ 的和为 $s-1$。

### 思路分析

很显然，因为输入的数都是非负整数，所以只有删去数列中的 $0$ 和 $1$ 才能符合要求。如果一个数列中既不包含 $0$ 也不包含 $1$，那么我们就输出 $0$，因为无论怎么操作也无法符合要求。 

对于 $0$，我们可以删除任意多个，而对于 $1$，我们只能删除一个。

记数列中 $0$ 的个数为 $b_0$，数列中 $1$ 的个数为 $b_1$。

对于 $1$ 的选择，我们有 $b_1$ 种选法，而对于 $0$，每一个 $0$ 有两种状态：删了或没删。所以 $b_0$ 个 $0$ 共有 $2^{b_0}$ 中选法。最终利用乘法原理可得最终答案为：$b_1 ·2^{b_0}$。

### 代码实现

**注意：一定要开 long long！！**

```cpp
#include <iostream>
#include <cmath>
using namespace std;

int main()
{
    int t;
    cin >> t;
    while (t--)
    {
        int n;
        cin >> n;
        long long cnt0 = 0;
        long long cnt1 = 0;
        for (int i = 1; i <= n; i++)
        {
            long long x;
            cin >> x;
            if (x == 0)
            {
                cnt0++;
            }
            if (x == 1)
            {
                cnt1++;
            }
        }
        if (cnt0 == 0 && cnt1 == 0)
        {
            cout << 0 << endl;
        }
        else
        {
            cout << cnt1 * pow(2, cnt0) << endl;
        }
    }
    return 0;
}

```