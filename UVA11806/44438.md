**题意：**在一个m行n列的矩形网格里放k个相同的石子，问有多少种方法？每个格子最多放一个，第一行，最后一行，第一列，最后一列都要有石子。

**思路：**第一行，最后一行，第一列，最后一列都要有石子，直接求方案数不方便，考虑把问题转换一下。先求总方案数，然后减去不合法的方案数，即先算出C(n*m,k)，不合法的方案怎么算呢？

四个集合表示：A{第一行没有放}，B{最后一行没有放}，C{第一列没有放}，D{最后一列没有放}，然后用容斥原理即可

**代码：**
```cpp
#include<bits/stdc++.h>
using namespace std;
const int p=1000007;
int n,m,k,r,c,b,f[510][510],sum,i;
void zz()  //预处理组合数
{
    for(int i=0;i<500;i++)
    {
        f[i][0]=f[i][i]=1;
        for(int j=1;j<i;j++)
            f[i][j]=(f[i-1][j]+f[i-1][j-1])%p;
    }
}
int main()
{
    zz();
    int t;
    scanf("%d",&t);
    for(int i=1;i<=t;i++)
    {
        scanf("%d%d%d",&n,&m,&k); 
        sum=0;   //记录答案
        for(int s=0;s<16;s++) //枚举不合法的方案数的搭配方式
        {
            r=n;c=m;b=0; //b表示几个不合法集合搭配
            if(s&1) r--,b++; //第一行不放
            if(s&2) r--,b++; //最后一行不放
            if(s&4) c--,b++; //第一列不放
            if(s&8) c--,b++; //最后一列不放
            if(b%2==1) sum=(sum+p-f[r*c][k])%p;//奇数种不合法情况搭配，由容斥原理，减去
            else sum=(sum+f[r*c][k])%p; //偶数种，加上
        }
        printf("Case %d: %d\n",i,sum);
    }
}
```