思路1：$O(N^2)$算法

首先必须要考虑到，这题转化后就是求在$N$个数每$K+1$个数删去一个数，并求最大值

一种非常容易想到的思路就是DP，从1到N枚举，第二维从i到N枚举，然后 前缀和+DP 乱搞就好了

显然，这种算法度复杂度是$O(N^2)$的，~~N方过百万~~，我们普遍认为计算机1s能够计算$10^9$次（luogu神机也许更多，CCF老爷机也许更少）

再看数据范围，$N\le 100000$，显然，这种算法虽然正确，但是并不怎么符合我们的时限要求

考虑优化：

如果一头奶牛比当前枚举到的奶牛小，还比他弱，那么这头奶牛就没有用了，我们可以用这个方法来维护一个单调上升的序列，即我们的单调队列!

单调队列涉及去头，删尾两个操作

什么时候去头呢？

当头位置的已经没法再给当前位置做贡献的时候（即已经超出K+1的限制的时候），我们去头，因为他已经没有用了

什么时候删尾呢？

当尾部的位置不如当前位置的时候，我们把尾部位置的牛替换为当前牛，以获得最大收益

很明显，我们这道题必须使用这种方法求解，最优情况下，复杂度是可以降到$O(N)$的，差一点的估计就是$O(KN)$(K为3-5之间的一个常数)

$O(NlogN)$也是常见的复杂度，往往出现在限制与单调性难以统一的情况下，不过也能过

那么，这道题的复杂度不就降下来了?

实现方法，本人使用队列进行模拟，似乎C++的deque也是不错的选择，只不过我不怎么会用QwQ

有会用deque的dalao教教我呗2333

详见代码(似乎单调队列不是pj组考的内容。。。不过ZJ哪有什么pj，tg之分2333)

```
#include<bits/stdc++.h>//万能头不解释
#define ll long long //宏定义long long秀一脸
using namespace std;//调用命名空间
ll sum[111111],f[111111],d[111111],q[111111];//sum数组维护前缀和，用以查询区间内奶牛的收益总和
//f数组用来转移状态
//d数组用来存储k头牛前的状态
//q数组用来维护单调上升的序列
int n,k,head,tail;//n,k如题意，head，tail分别指向队列的头、尾
void put(int j){
    d[j]=f[j-1]-sum[j];//储存状态，后面的去头工作可能要用到
    if(j>=k+1&&d[j-k-1]==q[head])
        head++;//去头
    while(head<tail&&d[j]>q[tail-1])
        tail--;//删尾，当尾部的牛不如自己时，把他们弹(zhu)出(le)去(chi)
    q[tail++]=d[j];//把状态储存进队列尾部，维护起一个单调上升并且始终最优的序列
}
int main(){
    head=0,tail=1;//初始化头指针和尾指针
    scanf("%d%d",&n,&k);//输入N，K
    for(int i=1;i<=n;i++){
        ll x;
        scanf("%lld",&x);
        sum[i]=sum[i-1]+x;//维护前缀和
    }
    for(int i=1;i<=n;i++){
        put(i);//操♂作，考虑i这头牛的最优位置
        f[i]=q[head]+sum[i];//更新答案
    }
    printf("%lld\n",f[n]);//输出结果
    return 0;//再见各位QWQ
}
```

~~我觉得虽然思路差不多，但是我讲的会不会稍微详细辣么一点点呢QWQ~~