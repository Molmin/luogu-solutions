首先要想到转化为删去k个内效率最低的奶牛

由于相邻不能超k,所以很容易想到用f(i-k -> i-1)的数来dp求f(i)

然而O(n^2)算法可能会崩

因此，用单调队列来维护i-k -> i-1区间最小值

前一句更通俗的说法(i的自述):你在我前面还比我大,留你何用？

最后只要用总数减去最小删去效率就行了

这样虽然还是O(n^2),但是有极大的优化,只要不是出题人故意坑你卡数据就没问题。。。

注意单调队列头的更新(不能超k）

~~御坂御坂耐心地讲解道~~

附上代码和注释(代码有点冗长，请见谅，毕竟蒟蒻水平有限)
```
#include<stdio.h>
#include<iostream>
using namespace std;
long long line[100001],x,total;  //line存单调队列,x临时变量存输入，total存效率总数(long long注意!不然后果自负)
int NO[100001];     //NO存单调队列的编号,就是1~k,用于更新队列头
int main(){
	int n,k,head=0,tail=1;
	scanf("%d%d",&n,&k);
	for(int i=1;i<=n;i++){
		scanf("%ld",&x);    //来一个搞一个
		total+=x;     //更新效率总数
		if(NO[head]<i-k-1) head++;   //把头控制在k个以内,不然更新头。
		x+=line[head];   //由于是单调队列,所以第一个一定最小,用它来更新f(i)
		while(line[tail-1]>x) tail--; //踢人模式,被我完爆的家伙们，你们不属于这里!(因为后面几项不但靠前且值还较大，所以不能还会用它们更新)
		line[tail]=x; //将刚来的f(i)存入队列
		NO[tail]=i;  //将它的序号存入队列
		tail++;  //尾指针记得加一哦~~(御坂御坂肯定地说到)~~
	}
	if(NO[head]<n-k) head++;   //这里注意,由于最后尾指针更新,所以头可能不在k的范围内
	cout<<total-line[head];  //由于单调队列头最小,所以可以直接用总数减去头
}
```