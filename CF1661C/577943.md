## 题意简述

------------
- 给定 $t$ 组数据，每组数据包括 $n$ 和 $n$ 个数。

- 每天可以使任意一个数加 $1$（天数为奇数时）或加 $2$（天数为偶数时），或者跳过这一天。

- 求最少使所有数都一样的天数，并输出。

- $1 \leq t \leq 2 \times 10^4$，$1 \leq n \leq 3 \times 10^5$，$1 \leq h_i \leq 10^9$。

## 题目分析

------------
本题可以用 **二分** 或者 **贪心** 来做，我选择了贪心。

### 思路

------------
首先观察，所需的目标高度为最大数或最大数加 $1$（如果考虑最大数加 $2$ 或以上，我们肯定有多余的操作）。而如果需加 $1$ 的次数比需加 $2$ 的次数多很多，我们就需要使目标高度为最大高度加 $1$（这样可以使需加 $1$ 的次数比需加 $2$ 的次数少（易证）），这就是程序最后的 取两种情况 的原因。

接着，先用两个变量分别保存加 $1$ 的次数和加 $2$ 的次数，然后可以考虑一个明显的贪心：肯定每次加 $2$ 能最快使数都趋向于最大的数，当该数与最大数差 $1$ 时用 $1$ 来解决。然而根据题意，只有偶数日能加 $2$，如果太贪心（加 $2$ 次数比加 $1$ 的次数多超过 $1$）会使奇数日跳过，肯定是浪费的。所以我们加上第二层贪心：使加 $1$ 的次数和加 $2$ 的次数趋于相同（使两个变量之差不超过 $1$），可以减少跳过日的浪费。

## 代码

------------
```cpp
#include<bits/stdc++.h>
#define int long long
#define mx 300010
using namespace std;
int t,n,maxx,a[mx];
int wk(int x){
	int ct1=0,ct2=0;
	for(int i=1;i<=n;i++){
		ct1+=(x-a[i])%2;//所需 1 的个数 
		ct2+=(x-a[i])/2;//2 的个数 
	}
	int tmp=ct2-ct1;
	if(tmp>=2){//如果差值过多 
		ct1+=(tmp+1)/3*2;
		ct2-=(tmp+1)/3;
	}
	if(ct1>ct2){//次数
		return ct1*2-1;
	}else{
		return ct2*2;
	}
}
signed main(){
	cin>>t;
	while(t--){
		cin>>n;
		maxx=0;
		for(int i=1;i<=n;i++){
			cin>>a[i];
			if(a[i]>maxx){
				maxx=a[i];
			}
		}
		cout<<min(wk(maxx),wk(maxx+1))<<endl;
	}
	return 0;
}
```


### 其他的话
------------
没加优化会一头冲进最劣解 awa