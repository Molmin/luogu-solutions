### 题目翻译

给你一个正整数 $n$，让你改变其中任意位的值使得它不含前导 $0$ 且可被 $7$ 整除，同时需要让改变的位数最少。输出改变后的数字。

可以输出任意答案。如果给定数已经能被 $7$ 整除，则不需要对原数执行任何操作。

多组数据，$10\leq n \leq 999$。

### 思路

#### 流程

注意到 $n$ 的范围很小，允许我们用枚举法解答，所以直接枚举即可。

枚举 $i$，判断 $i$ 是否能被 $7$ 整除，如果是，则暴力拆位算两数不同处的个数并更新答案。

#### 特判

对于给定数能被 $7$ 整除不需要变化这个特判，我们在进行上述操作的过程中已经有体现了（不同处为 $0$ 当且仅当两数相等），所以不需要额外再写。

但是在拆位的过程中需要注意**没有前导 $0$**，也就是说，前导 $0$ 在答案的统计中是会有影响的（而且本身不合法）。所以可以通过适当改变循环边界来实现特判。

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int t,n,l,r;
int check(int x,int y)//因为位数很小，所以不必写循环拆位。
{
	int ans=0;
	if(x%10!=y%10) ans++;
	if(x%100/10!=y%100/10) ans++;
	if(x/100!=y/100) ans++;
	return ans;
}
signed main()
{
	cin>>t;
	while(t--)
	{
		cin>>n;
		int Min=999,ans=-1;
		if(n>=10 && n<=99) l=10,r=99;//根据位数改变循环边界来排除前导0对答案的影响
		else l=100,r=999;
		for(int i=l;i<=r;i++)
		{
			if(i%7==0 && Min>=check(i,n))
				Min=check(i,n),ans=i;
		}
		cout<<ans<<'\n';//输出任意一个答案即可。
	}
    return 0;
}

```