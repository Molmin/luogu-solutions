### 前置技能 :
- 线段树
- 前缀和
- 树状数组
- ~~一双打上百行代码不抖的手~~

>对一些名词的解释：

>权值线段树 : 一种线段树,其叶子节点代表了一个数组中的权值.

>主席树&可持久化权值线段树 : 关于名称的问题详见[「主席树」和「可持久化线段树」有什么区别？](https://www.zhihu.com/question/59195374). ~~顾名思义~~蒟蒻看来 , 这是一种可以支持访问权值线段树历史版本的数据结构 , 其中每一个历史版本在搜索过程中都是一棵**完整的权值线段树** . 每一个历史版本的区别在于一些权值(叶子节点)所在的路径上的一些数据可能改变.

## 例 1[Luogu P3834 【模板】可持久化线段树 （主席树）](https://www.luogu.org/problemnew/show/P3834):

>题目大意 : 给定N个整数构成的序列 , 将对于指定的M个闭区间查询其区间内的第K小值。查询以(l,r,k)的形式给出 , 其意义是**闭区间**`[l,r]`的第k大的权值 . 所给的序列可能重复 , a∈`[-1e9,1e9]`.n,m<=2e5.

### 变量预警:
 - tot : 表示新建的点的序号(避免重复)
 - T[i] : 表示第i个版本的**根节点**的点序号(便于存储,只存T[i]一个值就可以从整棵树上搜索)
 - ls[i]/rs[i] : 表示i号点的左/右儿子(**Warning** : 叶子节点的左右儿子无意义)
 - sum[i] : 表示一个非叶子节点的子树权值和.(便于询问时决定去左子树还是右子树)
 - a[i] : 初始序列数组
 - b[i] : 离散&去重后的数组
 - po : b数组的元素个数[1,po]
 
这是一道经典的主席树板子题(静态区间第k小) , 通常的做法是先将所给序列进行离散后建权值线段树 . 因为权值线段树的叶子节点数一般是离散化后的值域 , 所以最坏的情况下可以达到n . 

在离散之后 , 从1到n遍历 , **把a[i]在离散&去重 数组b中的位置`pos`算出来** , 此时的`pos`就对应了一个权值线段树的一个叶子节点 . 利用线段树的二分性 , 即由于有`pos`的限制 , 当前节点的只需要新建左右儿子中的一个 , 所以我们可以在 **O(log n)** 的时间内到达目标位置**并在其路径上**进行修改 . 修改时要把所有`sum[当前节点]`改为`sum[上一版本相同位置]+1` , 这里`sum[i]`的意义是以i为根的子树的大小(权值和).

现在的问题在于如何建树/修改 , 以达到节省空间、时间的目的 ? 感性地思考 , 我们可以把(1->n)所有的T[i]从空树上进行修改 , 这样我们只需要新开空间复杂度为 **O(log n)** 的空间 , 空间大大宽裕 ,不必担心爆空间的现象 . 然而 , 对于查询操作 , 我们需要将`[l,r]`中的T[i]代表的树中的sum全部相加才能得到其对应的sum状态 , 而这个时间复杂度是 **O(n log n)** 的 , 导致总时间复杂度 **O(n^2 log n)** 爆了时限.

换一种方法 , 我们可以将T[i]在T[i-1]的基础上新建 , 而T[i]代表的这一棵树在T[i-1]上的变动也仅仅是在搜索 pos 的一整条路径上 , 就像上面一样只需要新开 空间复杂度为 **O(log n)** 的空间 . 不同的是此时我们建成了一个**前缀和**的结构 , 只需要用`T[r]-T[l-1]`就可以表示出`[l,r]`的`sum`状态.

对于查询 , 我们可以从T[r]和T[l-1]开始(对于版本的定义,T[i]所代表的是**版本i的树的树根**) , 计算当前同步下传的节点的**左子树**的`sum`差值x , 每次比较 x 和 k , 决定向左子树走还是右子树走.

## 详细Code解释:
### 关于建树:
```cpp
int build(int l,int r)
{
    int now=++tot,mid=(l+r)>>1;
    if(l^r)//如果当前的区间左右端点不同
    {
        lc[now]=build(l,mid);
        rc[now]=build(mid+1,r);
    }
    return now;//本人喜欢这种返回值的流派,不过也有引用的写法.
}
T[0]=build(1,n1);
```

### 关于修改:
```cpp
int modify(int root,int l,int r)
{
    int now=++tot,mid=(l+r)>>1;
    lc[now]=lc[root];rc[now]=rc[root];sum[now]=sum[root]+1;
    //为了压行,先行给lc和rc赋值,避免繁琐的if 
    if(!(l^r))return now;//如果l==r,"建"好就收 
    if(pos<=mid)lc[now]=modify(lc[root],l,mid);
    //pos只会向一边走,保证了时间&空间复杂度 
    /*
	注意:在这里有dalao写"lc[now]=modify(lc[now],l,mid)",
		两种写法的结果相同,但从本质出发,我觉得还是我的
		符合定义. 
	*/ 
    else rc[now]=modify(rc[root],mid+1,r);
    return now;
}

for(int i=1;i<=n;++i)
{
    pos=lower_bound(b+1,b+po+1,a[i])-b;
    //这一句话的意思是找到a[i]在b数组中的位置
    T[i]=modify(T[i-1],1,po);
    //以T[i-1]为蓝本修改T[i]
}
```
不懂`lower_bound`的来这里:[关于lower_bound( )](https://blog.csdn.net/qq_40160605/article/details/80150252)

### 关于查询:
```cpp
int query(int u,int v,int l,int r,int k)
{
    int mid=(l+r)>>1,x=sum[lc[v]]-sum[lc[u]];
    //x表示当前两节点左子树的sum差 
    if(!(l^r))return l;//如果l==r说明已经搜到了结果 
    if(k<=x)return query(lc[u],lc[v],l,mid,k);
    //用x的值确定k走的方向 
    else return query(rc[u],rc[v],mid+1,r,k-x);
    //注意:这里应该是"k-x",意思是如果在左边找不到, 
	//就在右边找 k-x小的数
}
```
### 总复杂度分析 : 
- 查询: 空间    `--`      时间 `O(log n)`
- 修改: 空间 `O(log n)`   时间 `O(log n)`
- 建树: 空间 `O(n*log n)` 时间 `O(n*log n)`
- 总时间 : `O((n+m)*log n)`
- 总空间 : `O((n+m)*log n)`

## 例 2[Luogu P2617 Dynamic Rankings](https://www.luogu.org/problemnew/show/P2617):

>题目大意 : 给定N个整数构成的序列 , 将给出M个操作,操作1: 查询一个区间内的第K小值。查询以(l,r,k)的形式给出 , 其意义是**闭区间**`[l,r]`的第k大的权值 . 操作2: 将 a[i]替换成另一个值 . 所给的序列可能重复 , a∈`[-1e9,1e9]`.n,m<=1e5.

观察题意 , 我们发现这就是要我们打一个可以支持修改的主席树(动态区间第k大) . 同上所述 , 我们静态区间保证 时&空复杂度 用了一种 **前缀和** 的方式 , 即将`T[i]`所代表的权值线段树视为一种**区间装态** , 用处理数组的办法进行一些操作. 我们学习过 **前缀和** , 所以明白朴素的前缀和是一个 **查询O(1),修改O(n)** 的操作 , 在静态区间第k大中表现良好 , 但对于一次修改 , 我们需要将其后的所有版本全部修改一遍 , 造成的时间复杂度达到 `O(n*log n)` , 对于m次的修改 , 这一复杂度可能达到 `O(n*m*log n)` 的级别 . 此时 , 我们可以使用另一种数据结构来维护这种状态序列 : **树状数组** . 朴素的树状数组有 **查询O(log n),修改O(log n)** 的良好性质 , 在应用树状数组处理状态时可以把复杂度降低到一个可以接受的程度.
### 总复杂度分析 : `O(n*log n*log n)`