#### 可持久化线段树，又叫主席树，在对线段树做了一定修改以后，还可以同时保留修改前的线段树的模样。是用来维护区间第K小的一种数据结构。
![PwY3b4.png](https://s1.ax1x.com/2018/08/01/PwY3b4.png)
**下面介绍一下基本思想**

------------
#### 0.0 离散化（一会再讲，与思想无关）
**1.1 维护一个权值线段树，具体而言就是将一个连续的（1~m）区间不断二分，最终每一个数代表一个节点（也就是说，我们可以在这棵树上找的区间内的每一个数）。**
**1.2 这样就很好办了，对于每一个节点我们都可以维护以他为根的子树的sum表示这个区间已有多少数，这样再将给定区间的每一个点加入权值线段树，并在线段树的相应叶子点sum+1 *（有点像计数排序）。* 然后update（）一下将每个sum求出来，表示在每个二分区间内有多少个数。**
![PwYTaj.png](https://s1.ax1x.com/2018/08/01/PwYTaj.png)

------------


### QAQ
#### Q：
**1 现在我们有了一个看似非常nb的线段树，可它该怎么用，和可持久化数据结构有什么关系？^？
2 想一想现在建起的线段树是一个1~m的，可该怎么求出l~r的呢？？？**
#### A：
**1.先不考虑lr区间时，我们要求1~m的第K小，而一个权值线段树拥有优秀的单调性，我们知道每个区间有多少个数，那从从左往右找到第K个不就行了。
举个例子，找1~m第2小，1~mid的sum=3，mid+1~m的sum=7，由单调性可知，第2小的一定在左儿子区间内，然后再重复上面的过程直到找到树上标号。这就是为什么要用权值线段树的原因。：）**
**2.考虑比较暴力的做法，当我们求l~r区间时，不过是将l~r区间的数加进我们刚刚的线段树，那岂不是可以对每一次询问都建一个刚刚的树加入区间内的数。可是…………这也太暴力了，甚至不如sort一下快。想一想权值线段树的一些性质，加入一个点后只是在部分上sum+1。那利用一下 *前!缀!和!* 的思想，l~r区间不过是1~r的树减去1~l-1的树（这里的减是指各个节点sum值相减，想一想为什么）。**

------------


#### 至此我们已经完成了大半，但这和可持久化有什么关系呢？
**2.1 考虑一下复杂度，要建m个线段树（这个我们可以先建空树，在需要时在继续建），难道每次建树都需要重新for一遍吗？第1个树和第2个树只是多了一个数，相当于做了一个单点修改，而原树和新树有很大一部分完全一样，这时候就可持久化就登场了o(*≧▽≦)ツ**
**2.2 在建新树是可以从原树的基础上建，这样就极大的减小了重复的运算。建树过程如下图**
![PwYGVJ.png](https://s1.ax1x.com/2018/08/01/PwYGVJ.png)
#### 复杂度O(nlogn)

------------


#### 0.0  离散化介绍
> #### 离散化，就是把无限空间中有限的个体映射到有限的空间中去，以此提高算法的时空效率。

>**首先将数字排序：32434234，32434234，43324556，8384733，98998988
去重后给予其对应的索引：0,0,1,2,3分别对应每个数，就可以简化很多操作，减少了很多不必要的资源开销。
除了对于较大整数需要使用离散化之外，对于一些需要使用整型数据结构，但给出的数据却是小数的也可以使用离散化，将其索引为整数就可以了。
那么可以总结出离散化的步骤：
1、排序
2、去重
3、索引
为了简化代码，我们采用STL算法离散化：**
```cpp
int a[n], b[n], sub[n]; //a[n]是即将被离散化的数组，b[n]是a[n]的副本，sub用于排序去重后提供离散化后的值
sort(sub, sub + n);
int size = unique(sub, sub + n) - sub;
for(int i = 0; i < n; i++)
    a[i] = lower_bound(sub, sub + size, a[i]) - sub; //即a[i]为b[i]离散化后对应的值
```
##### 转自
[http://www.cnblogs.com/kevince/p/3893531.html ](http://www.cnblogs.com/kevince/p/3893531.html )
——By Kevince。
###### 0.1
**在维护主席树时，对于每一个数，我们不一定要建最大值个，通过离散化，可以将数量大大缩小，只用维护1~去重后的点数 个，我们可以把输入数组里的每一个数都通过排序映射到一个较小的序列上，比如引用中举的例子32434234，32434234，43324556，8384733，98998988，去重后给予其对应的索引：0,0,1,2,3分别对应每个数。**
**通过离散化我们在query（）是找到第K小的点时，可以返回在区间的那一个点上，那么对应的点就是在排序后的原序列里。**

------------




~~结稿于2018-08-01 10:57.~~
# ：）
#### 转载请注明出处： 谢谢
[http://tch.drifts.ml/%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0/195/](http://tch.drifts.ml/%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0/195/) ——[tch学习笔记]
