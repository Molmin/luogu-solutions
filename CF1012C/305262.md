## 分析
先来分析状态的定义，首先输出的时候跟$k$有关，所以$k$一定要先占一个状态，山的数目也要占一个状态，因为不枚举每座山峰，就无法知道山峰的高度，那么状态可不可以只有$i$和$j$呢？显然也不可以，建房子的时候有高度限制。于是状态大致就有了，是一个三维的状态，$dp[i][k][\ \ \ ]$，那么剩下的那个状态怎么选呢，因为我们转移的时候只考虑了前边的$i$个，所以第$i$个建不建，只与第$i-1$个有关，$i$与$i-1$建房的情况有三种，都不建，$i$建，$i-1$建，$i$和$i-1$都建呢？请回去读题。所以定义$dp[i][j][0/1/2]$，表示前$i$个山，建$j$个房子，$0:i$和$i-1$都不建，$1:i$建，$2:i-1$建时最小花费。

接下来考虑状态转移，对于$0$的情况，就是$dp[i-1][j][0]$和$dp[i-1][j][2]$的情况，前者是$i-1$和$i-2$都不建，后者是$i-1$不建，$i-2$建。这两种情况都是满足我们这个状态并且合起来正好能够填满这个状态。

对于$1$的情况，$i$建了，那么$i-1$一定不能建，考虑$i-2$建还是不建，如果$i-2$建了，那么$i-1$的山峰就要满足比$i-2$和$i$都小，如果$i-1$比$i-2$要高，那么$i-1$就至少要被砍到$i-2$的高度$-1$的位置，即$min(a[i-1],a[i-2]-1)$，如果这个数还比$i$高，那么它还要被砍，于是额外的代价就是$h-(a[i]-1)$,所以总代价就是$dp[i-1][j-1][2]+max(0,min(a[i-1],a[i-2]-1)-a[i]+1)$，再考虑$i-2$不建的情况，就是看$i-1$需不需要砍一刀，所以这个状态最后的转移方程就是：
$$
dp[i][j][1]=min(dp[i-1][j-1][0]+max(0,a[i-1]-a[i]+1),dp[i-1][j-1][2]+max(0,min(a[i-1],a[i-2]-1)-a[i]+1))
$$
虽然有点长但是好好理解一下还是挺好懂得，最后就是$2$的情况了，如果$i-1$建了，那么就要保证$i$的高度低于$i-1$于是取$a[i]-a[i-1]+1$和$0$的最大值就行。最后可以小小的优化一下，状态转移的时候，$i$能且只能由$i-1$转移过来，所以第一维状态可以省略。

最后就是初始化了，由于要求最小，所以最开始全部初始化为$INF$，初态$dp[0][0],dp[1][1]$均为$0$，稍微解释一下，建$0$座房子，显然叭，不花钱，建一个，也不花。

　　tips：：压维的话注意一点，转移的时候，要考虑转移顺序，先转移$0$，因为$0$受$2$的影响，再转移$2$，$2$受$1$的影响，最后是$1$，这样就可以避免用现阶段的东西来转移现阶段的东西，从而保证了转移的正确性。
  
  ```
#include<iostream>
#include<cstring>
using namespace std;
const int N=2501;
int dp[N][3],a[N<<1];
int main(){
    int n;
    cin>>n;
    for(int i=1;i<=n;i++)
        cin>>a[i];
    memset(dp,0x3f,sizeof(dp));
    dp[0][0]=dp[1][1]=0;
    for(int i=2;i<=n;i++)
        for(int j=i+1>>1;j;j--){
            dp[j][0]=min(dp[j][0],dp[j][2]);
            dp[j][2]=dp[j][1]+max(0,a[i]-a[i-1]+1);
            dp[j][1]=min(dp[j-1][0]+max(0,a[i-1]-a[i]+1),dp[j-1][2]+max(0,min(a[i-1],a[i-2]-1)-a[i]+1));
        }
    for(int j=1;j<=n+1>>1;j++)
        cout<<min(dp[j][0],min(dp[j][1],dp[j][2]))<<" ";
}
  ```