### 题目大意：

有n座山，在山上建房子，需要保证有房子的山的高度比它两边的山的高度都要高，否则，就把比它高的山挖到比它低。每分钟可以令一座山的高度减一，分别求建$1$~$n/2$幢房子花费的最短时间

## 思路分析：

* 又是一个线性$DP$，一步一步往后推就行了

* 题目不是很难理解，但是最后让求的这个东西就比较有意思了，$1$~$n/2$，为什么是 $n/2$ 而不是 $n$ ？——显然，两座相邻的山没法同时建房子，要不你就挖去吧，地心挖穿也建不成（开个玩笑）。注意：这里得到一个很关键的性质——所建的房子必须相间，相间，相间！！！

* 常规思路，从 $1$ 到 $n$ ，当做终点进行处理，那我们就只需考虑这个终点前面的山的高度，但是这道题不一样在哪里了呢？——每个点有两点状态，即建房子或不建房子，那么怎么处理呢？数组多开一维不就得了，ｂ(￣▽￣)ｄ

* 每个点的两种状态各需要一个转移方程，**一个建房子的**，**一个不建房子的**。
  * 第 $i$ 座山建房子的：（划重点）第 $i$ 座山如果建房子的话，那么第 $i-1$ 座山肯定不能建，经过这座山时也不会增加时间，那我们就直接蹦到 $i-2$ 去考虑。$i-2$ 同样也有两种情况，建或不建——如果不建，那就拿第 $i$ 座和第 $i-1$ 座比较，看看要不要挖；如果建了，那就拿 $i-2$ 和 $n$ 共同与 $i-1$ 进行比较，因为 $i-1$ 要满足比它们两个都要低。

  * 第 $i$ 座山不建房子的：那这个时候 $i-1$ 就可以考虑建房子了，这个情况就比较简单了
  
`代码更详细哦`
## $\textcolor{green}{Code}$

```c++
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<cmath>
using namespace std;
const int maxn = 5000+10;
int h[5050];
int dp[5050][5050][2];
int main(){
    memset(dp,0x3f,sizeof(dp));
    dp[0][0][0]= dp[1][1][1] = dp[1][0][0] =0; //初始化，这里其实省了一个循环，把dp[i][0][0]放到下面的dp循环里了
    h[0]=0x3f3f3f3f; //设为无限大，是为了不干扰后面的操作，而且h[0]一定会出现
    int n;scanf("%d",&n);
    for(int i=1;i<=n;++i){
        scanf("%d",&h[i]);
    }
    for(int i=2;i<=n;++i){
        dp[i][0][0]=dp[i-1][0][0];  //前面省的初始化化放到这里了
        for(int j=1;j<=(i+1)/2;++j){  //这个括号可能有点长，但其实并不太复杂
            dp[i][j][1]=min(dp[i-2][j-1][0]+max(0,h[i-1]-h[i]+1),   //max函数，其实是代替了if，如果h[i-1]-h[i]+1小于0，说明i-1更矮，就不用挖掉了
                           dp[i-2][j-1][1]+max(0,h[i-1]-min(h[i],h[i-2])+1));  //h[i]和h[i-2]，哪个高出来得更多，就挖哪个，这样另一个就也比i-1矮了
            dp[i][j][0]=min(dp[i-1][j][0],
                           dp[i-1][j][1]+max(0,h[i]-h[i-1]+1)); //上面那个理解了这个就没问题了
        }
    }
    for(int i=1;i<=(n+1)/2;++i){
        printf("%d ", min(dp[n][i][0],dp[n][i][1]));
    }
    return 0;
}

```