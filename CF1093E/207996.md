- 记 $i$ 在 $a$ 中的下标为 $P(i)$，则 $1$ 操作转化为：给出 $l,r,L,R$，求满足 $l \le i \le r, L \le P(b_i) \le R$ 的点个数。可以发现是个动态二维数点问题。
- $2$ 操作相当于单点修改，或者说加一个点然后删一个点。

通常来讲我们可以同通过树套树解决，但是听说这题好像卡空间？就写了分块套 `bitset`，分块维护序列维，`bitset` 维护值域维。对于每个块记录第一个块到当前块所有 $a_i$ 以及 $b_i$ 的并集，用 `bitset` 的或运算维护之。直接预处理整块的前缀或，预处理复杂度就是 $O(n\sqrt n)$ 的。

- 对于 $1$ 操作，直接把右端点所在块对应的 `bitset` 和左端点所在对应的 `bitset` 异或差分一下，然后暴力统计散块贡献。时间复杂度 $O(n\sqrt n +\dfrac{n^2} w)$。
- 对于 $2$ 操作，发现最多会让 $O(\sqrt n)$ 个 `bitset` 中的值修改，遍历整块修改即可，每块都只会修改 $O(1)$ 个元素。时间复杂度 $O(n\sqrt n)$。

至此，我们以 $O(n \sqrt n + \dfrac{n^2} w)$ 的时间复杂度通过了该题。

[代码参考](https://codeforces.com/contest/1093/submission/148106655)。