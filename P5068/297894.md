[末日三问点灯记录](https://www.luogu.com.cn/blog/NaOH-Ftoh/mo-ri-san-wen-dian-deng-ji-lu)，内含所有代码。

考虑操作 $2$ 的本质，其实就是求 $d$ 取遍 $[L,R]$ 时的亵渎次数总和。

考虑一次亵渎实际做的事情，其实就是看 $[1,d]$ 区间有没有任何一个随从，如果有那就继续看 $[d+1,2d]$ 有没有任何一个随从，以此类推，直到没有为止，后面的区间我们不关心。

我们发现，这道题只有加随从的操作，没有删除，所以对于一个固定的 $d$，答案单调递增。那么我们可以对于 $[1,n]$ 中的所有 $d$ 维护一个指针表示当前答案是什么，容易发现这些指针加起来最多跳 $O(n\ln n)$ 次。

那么问题来到了怎么最快的求出对于每一个更新，我们要修改哪些指针的答案。到这里就有了一个 naive 的做法，我们建出线段树，在每个节点上维护一个 set 表示覆盖当前区间的 $d$ 集合，如果父节点已经加入则子节点不加入，类似 lazytag。（这里我们考虑在当前时刻没有任何一个随从的区间，如果每个区间都有则这个 $d$ 不会在任何节点出现。）查询时直接查找哪些要改，然后删除对应区间，暴力移动指针，重新加入对应区间即可。

这种做法复杂度为 $O(n\log^3 n+m\log n)$，肯定被卡掉了，具体可以看我那几发 84 分提交。/qd

那么我们考虑优化，可以采取一种类似记忆化的技巧，一开始将所有可能出现的区间全部加入线段树，然后每加入一个随从就将该随从能遍历到的线段树节点对应的区间全部打上标记，并且再把这些遍历到的节点打上标记。这样，每个区间最多遍历到一次，总时间复杂度变成 $O(n\log^2 n+m\log n)$。本题完全不卡常，复杂度正确的情况下常数飞起也能通过。