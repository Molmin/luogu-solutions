有点套路，对思维连贯性要求不是很高。                   

------------------------------

考虑形式化查询问题：

定义 $S(i)$ 为将大小为 $n$ 的值域以 $[1,i],[i+1,2i]......[ki+1,n]$ 的方式进行分段后，从前往后数第一个段内没有出现数的段的编号。

则查询问题变为：$\sum_{i = L} ^ R S(i)$。

考虑这个分段的形式，不难发现对于所有的 $i \in [1,n]$，分出来的段的总数量为 $O(\sum_{i=1} ^ n \lfloor \frac{n}{i} \rfloor) = O(nw)$，其中 $w$ 表示调和级数。

我们不妨在线维护每个段何时内部出现数，不难想到由于每个段只要出现了数那么之后的状态下一直都会出现数，所以一共只会对 $nw$ 个段执行一次出现了数的标记，即标记 $nw$ 次。

考虑每次插入一个 $h$ 时如何更新每个段。对每个段按照左端点 $l$ 排序后开线段树，维护区间内还未标记的最大 $r$，这样就只用看 $h$ 是否在一个区间的 $l,r$ 内就知道是否需要继续往下跑。         

这样的时间复杂度显然是可以得到保证的。因为按照 $l$ 排好了序，所以等价于按照 $l$ 向下支付单次 $O(\log nw)$ 的代价找到了一个去掉 $l$ 限制的子树，继续往下的时间复杂度贡献就被摊到了每个被修改的段上。         

于是我们在 $O(m \log nw + nw \log nw)$ 的时间复杂度解决了标记的问题。

解决了这个后面就很轻松了。判断每个段所属的类 $i$，即以 $i$ 为公差进行划分的。对每个 $i$ 开一个虚点表示第一次施法，这样除了 $[1,i]$ 对应的段在被标记后需要被合并到虚点上，其余的段都向它的前一个段合并，最后每个 $i$ 上开的虚点的大小就是每个 $i$ 在当前状态时施法的次数，这个可以并查集维护。

然后就是单点修改，区间查询，树状数组解决。

这一块的时间复杂度是 $O(nw \alpha(nw) + nw \log n)$ 的。

总的时间复杂度 $O(m \log nw + nw \log nw)$，空间复杂度 $O(nw)$，常数比较优秀稳定在最优解最后一页。