~~这题翻译十分感人，推荐看大视野的翻译~~

因为一条边只能经过两次，所以我们去往一个子节点就必须遍历完该子节点的子树。

所以我们可以发现，当来到一个节点x后，设f[x]表示该节点子树内的最大答案，siz[x]表示遍历完该子树所花的时间（不是大小）。显然f[x]只能被子节点y的选择顺序所影响。

所以我们就可以用贪心的思想来做这道题了。

假设遍历顺序中第i，i+1位为a，b，a在前面更优，因为1到i-1遍历总时间不会受影响，交换第i，i+1位也不会对到达第i+2个子节点的时间产生影响，所以我们可以考虑它的最优子结构。

之前遍历所花的时间为当前的siz[x]，先去a节点对f[x]的更新值为siz[x]+max（f[a]+1，f[b]+1+siz[a]+2）；先去b节点对f[x]的更新值为siz[x]+max（f[b]+1，f[a]+1+siz[b]+2）；

很明显答案不可能被f[b]+1或f[a]+1影响，因为a更优，所以以f[b]+siz[a]<f[a]+siz[b]作为排序条件对子节点进行排序。每计算完一个节点就对siz[x]进行更新。

~~我把cnt定义成全局坑了我好久。~~

