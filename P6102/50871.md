这道题一大堆求和符号实际上是用来吓人的。其实只要我们按二进制转化题意即可得到很简单的规律。

下面我们列举所有某一位的计算结果：

|$A\;$|$B\;$|$C\;$|$D\;$|$A\; {\rm or}\; B\;$|$C\; {\rm and}\; D\;$|$\rm xor$|
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
|1|1|1|1|1|1|0|
|1|1|1|0|1|0|1|
|1|1|0|1|1|0|1|
|1|1|0|0|1|0|1|
|1|0|1|1|1|1|0|
|1|0|1|0|1|0|1|
|1|0|0|1|1|0|1|
|1|0|0|0|1|0|1|
|0|1|1|1|1|1|0|
|0|1|1|0|1|0|1|
|0|1|0|1|1|0|1|
|0|1|0|0|1|0|1|
|0|0|1|1|0|1|1|
|0|0|1|0|0|0|0|
|0|0|0|1|0|0|0|
|0|0|0|0|0|0|0|

不难发现：

1. 这四个数如果某一位全为 $1$ 或 $0$，则这一位求和结果为 $0$；
2. 其中有一个 $1$ 或 $0$，则这一位求和结果为 $2$；
3. 其中有两个 $1$、$0$，则这一位求和结果为 $6$；

那么最终答案就很显然了（要注意每个数可以重复选）。假如第 $i$ 位有 $n_i$ 个 $1$，有 $m_i$ 个 $0$，那么这一位对答案的贡献就是 $2^i\times (2n_i^3m_i+2n_im_i^3+6n_i^2m_i^2)$。

因此，我们只需要在一开始就把 $a_i$ 的二进制中每一位的 $1$ 的个数统计出来，之后再对每一位用上面那个式子统计答案就可以了。取模操作直接用自然溢出即可。

代码如下：

```cpp
#include <cstdio>

unsigned int a, N, sum[35], j, ans;

int main()
{
    scanf("%u", &N);
    for(register int i = 1; i <= N; i += 1)
    {
        scanf("%u", &a);
        j = 0;
        while(a)
        {
            j += 1;
            if(a&1)
                sum[j] += 1;
            a >>= 1;
        }
    }
    int r, s;
    unsigned int f = 1;
    for(register int i = 1; i <= 32; i += 1)
    {
        r = sum[i];
        s = N - sum[i];
        ans = ans + (unsigned int)r*s*(2*(r*r+s*s) + 6*r*s)*f;
        f <<= 1;
    }
    printf("%u", ans);
    return 0;
}
```