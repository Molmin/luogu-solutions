来写一篇比较好懂的题解。

## Part-1

首先拿到这题可能并没有太大感觉，甚至只会爆搜，但是一想到这是 kals 的题肯定是多项式和生成函数来优化一个什么东西，于是可以想到 dp。

令 $dp_{i,j}$ 表示 $1\sim i$ 的排列中有 $j$ 对逆序对的 $val_{\pi}$ 的权值和。

考虑怎么转移，发现插入 $i+1$ 后多出的逆序对只与插入的位置有关，因为插进去的这个数是比原来 $1\sim i$ 都大的，于是就很好转移了。

$$
dp_{i,j}=\sum_{k=0}^{\min(i-1,j)}dp_{i-1,j-k}\times i^k
$$

然后直接转移就行，时间复杂度 $\mathcal{O}(nk^2)$，可以获得 13pts。

## Part-2
考虑优化一下这个 dp，发现是一个卷积的形式，NTT 优化即可，但是还是 13pts，没啥用。

考虑一下这个 dp 的实际意义，相当于就是现在 $1\sim n$ 这 $n$ 个数，要给每个数分配一个权值 $b_i(b_i\le i-1)$，每种方案的权值为 $\prod_{i=1}^n i^{b_i}$，求所有方案的权值之和。

这个问题看起来比较简单，很容易可以用生成函数求解。

相当于现在有 $n$ 条多项式，其中第 $i$ 条多项式为：

$$
f_i(x)=1+ix+i^2x^2+...+i^{i-1}x^{i-1}
$$

于是 $ans_k=[x^k]\prod_{i=1}^n f_i(x)$。

挨着乘还是只有 13pts，但是发现 $f_i(x)$ 是一个等比数列的形式，然后就可以得到 $f_i(x)=\dfrac{1-i^ix^i}{1-ix}$。

现在 $ans_k=[x^k]\prod_{i=1}^n \dfrac{1-i^ix^i}{1-ix}$

直接做不太好做，考虑分成分子和分母来计算。

## Part-3-分子

要求 $\prod_{i=1}^n (1-i^ix^i)$。

直接做不好做，考虑取对数最后在 exp 回来，变成 
$$
\sum_{i=1}^n \ln(1-i^ix^i)
$$

后面这一坨很熟悉啊，不是 付公主的背包？

$$
\ln(1-i^ix^i)=\sum_{j=1}\dfrac{i^{i^j}x^{ij}}{j}
$$

具体证明可以直接用复合函数的求导和泰勒展开。

然后就很简单了，直接 $\mathcal{O}(\min(n,k)\log k)$ 跑一边调和级数，然后 exp 回去就行了。

## Part-4-分母

这是最恶心的部分。

要求 $\prod_{i=1}^n (1-ix)$ ，然后求逆回去。

这东西就不能直接套用刚才的做法了，因为直接预处理会 T 掉，当然也不是不能做，可以推柿子，具体见 GuidingStar 聚聚的题解。

不能去对数，那怎么办呢？**我们要求的只是求逆回去的东西**，于是考虑求逆回去的多项式第 $i$ 项的系数，说一下我比赛时的做法：

那就是找规律 ~~（找规律 txdy）~~。

当 $n=2$ 的时候，$(1-x)(1-2x)=2x^2-3x+1$，复制一下求逆的板子，可以得到系数为 `1 3 7 15 31`，就是 $2^n-1$，不过现在还不能下结论，继续找。

当 $n=3$ 的时候，$(2x^2-3x+1)(1-3x)=-6x^3+11x^2-6x+1$，可以得到系数为 `1 6 25 90 301`，自己发现不了啥规律，于是上 oeis，可以得到这么一句话 `	Stirling numbers of second kind S(n,3).`，第二类斯特林数中的第三列！！

于是猜测 $n=k$ 时，求逆后的系数为第 $k$ 列的第二类斯特林数（从 $1$ 开始），但是这题 $n$ 这么大怎么求？

发现第 $k$ 列第二类斯特林数的 EGF 为 $k!\sum_{i=0}\dfrac{S(i,k)x^i}{i!}=(e^x-1)^k$。

考虑多项式快速幂，但是 $e^x-1$ 的常数项为 $0$，多项式快速幂后会出现 $k-1$ 个零，这题的 $n$ 贼大，根本就存不下，于是不要这个常数项来多项式快速幂，最后除以 $k!$，但是因为是 EGF,还要乘上 $i!$，最后求出的东西就是从 $S(n,n)$ 开始的第二类斯特林数，但是你会发现这个 $k$（这个 $k$ 不是给出的那个 $k$，是给出的 $n$，要求第 $n$ 列的斯特林数） 贼大，别急，我不是还要乘上 $i!$，然后一抵消差就只有给出的 $k$ 的级别了。（可能会有点绕，不懂的可以看代码）。

最后两个多项式一乘，这个题就做完了。

时间复杂度 $\mathcal{O}(k\log k)$，但是常数极大，要跑两次 exp 和一次 ln。

为了防止直接 copy，这里给出部分代码：

```cpp
signed main(){
	init();
	scanf("%d %d",&n,&k);
	fac[0]=ifac[0]=1;
	for(int i=1;i<=k+1;i++)fac[i]=mul(fac[i-1],i);
	ifac[k+1]=qkpow(fac[k+1],mod-2);
	for(int i=k;i>=1;i--)ifac[i]=mul(ifac[i+1],i+1);
	for(int i=0;i<=k;i++)A[i]=ifac[i+1];
	Polyqkpow(A,B,n,k+1);
	int now=1; 
	for(int i=0;i<=k;i++){
		B[i]=mul(B[i],now);
		now=mul(now,n+i+1);
	}
	for(int i=1;i<=min(n,k);i++){
		int res=qkpow(i,i),fuck=res;
		for(int j=1;i*j<=k;j++,fuck=mul(fuck,res)){
			AA[i*j]=dec(AA[i*j],mul(Inv[j],fuck));
		}
	}
	PolyExp(AA,BB,k+1);
	int M=((k+1)<<1),N=1,l=0;
	for(;N<=M;N<<=1,l++);
	for(int i=0;i<N;i++)rev[i]=(rev[i>>1]>>1)|((i&1)<<(l-1));
	NTT(B,1,N),NTT(BB,1,N);
	for(int i=0;i<N;i++)B[i]=mul(B[i],BB[i]);
	NTT(B,-1,N);
	for(int i=0;i<=k;i++)write((B[i]+mod)%mod),printf(" ");
    return 0;
} 
```

最后说几句，一定要一个常数小的多项式板子，不然你会 T 到怀疑人生，我还是在被卡哭了后发的帖子不要脸的让 kals 开到了 900ms，然后擦线过了（（（。

**The End**。