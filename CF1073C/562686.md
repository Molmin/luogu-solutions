## 题意
给你机器人的操作序列及终点。要求修改这个序列使机器人最终移动到终点。其修改的花费为**修改的操作的下标的最大值减修改的操作的下标的最小值加一。如果没有修改，则花费为 $0$。** 问：最小化的花费是多少，**如果最后不能够移动到终点，输出 $-1$。**
## 思路：二分答案+前缀和
若修改花费为 $l$ 可行，则修改花费大于 $l$ 一定可以实现。因为修改花费大于 $l$ 只要包含**可行的**修改花费为 $l$ 的区间就行了。因此，本题具有**单调性**，可以二分答案。

于是，我们可以直接套上二分模板。
```cpp
	l=0;r=n; 
	ans=-1;//初始化默认无法到达 
	while(l<=r){
		mid=(l+r)>>1;
		if(check(mid))r=mid-1,ans=mid;
		else l=mid+1;
	}
	cout<<ans;
```
**二分的判断**：判断修改花费为 $l$：枚举修改的长度为 $l$ 的区间的头、尾，然后求出除去这段区间会移动到的位置，然后判断加上任意的 $l$ 次操作，能否到达终点。

可以到达终点的情况：

第一种：可修改的操作数等于差的步数可以。

第二种：可修改的操作数如果有多且是偶数也可以（因为多余操作数走出去还得走回来，所以必须是偶数）。

**但是，如何求出除去某段区间会移动到的位置？**

每次都直接模拟显然会超时，因此，我们可以用前缀和进行预处理，将每次求出除去某段区间会移动到的位置的时间复杂度降到 $O\left(1\right)$。
```cpp
	for(i=1;i<=n;i++){//预处理前缀和，x数组为行，y数组为列
		x[i]=x[i-1];y[i]=y[i-1];
		switch(s[i]){
			case 'U':y[i]++;break;
			case 'D':y[i]--;break;
			case 'L':x[i]--;break;
			case 'R':x[i]++;break;
		}
	}
```
于是，我们就可以愉快打出二分的判断了。
```cpp
bool check(int l){
	int i,j,n2,m2,p;
	for(i=1,j=i+l-1;j<=n;i++,j++){
		n2=x[n]-x[j]+x[i-1];//行的位置 
		m2=y[n]-y[j]+y[i-1];//列的位置
		p=abs(n1-n2)+abs(m1-m2);//还差几步 
		if(l==p)return true; 
		else if(l>p&&(l-p)%2==0)return true;
	}
	return false;
}
```
## The End.