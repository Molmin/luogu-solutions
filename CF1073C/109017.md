[【题目传送门】](https://www.luogu.org/problemnew/show/CF1073C)

标签：二分

**分析题目**，首先思考一个问题：这里修改的代价是什么？看到$max-min+1$感到有些熟悉，很像我们已知区间右端点和左端点后求区间长度的式子。实际上正是这样的，考虑到修改代价仅仅取决于你修改的点的最大下标与最小下标，那么是不是说：在这两个操作之间修改任何操作都是免费的？所以我只需要考虑修改某一个区间就可以了（区间内可以存在不改变的点）。

那这样的话我们就将“修改哪些操作让代价最小”转化成了“修改一个区间且要让区间尽量小”，似乎更容易做了。

**特殊情况**：接着我们考虑另一个问题，什么情况下无解。

显然有一种情况一定无解。既然每一个操作只能移动一个单位长度，那么n个操作最多能让小机器人移动n个单位长度，对不对？（也就是小机器人不往回走）所以说，如果我需要的位移 _（这里指曼哈顿距离，之后出现“位移”与这里同义）_ $dis(x,y)$大于了总操作次数，那么肯定无解。

还有一种情况，就是我操作次数的奇偶性必须和位移的奇偶性一致。因为移动奇数次不可能移动到偶数点上，移动偶数次同理。注意，这里的“奇偶性”指的同样是曼哈顿距离，而不是x坐标或y坐标。

**check函数**：如何判断修改一个区间是不是满足条件？![我画画真好看啊](https://cdn.luogu.com.cn/upload/pic/40708.png)

我们可以设灰色区域以外的x方向的位移（注：这里的位移是有方向的，也就是有正负性的）是△$x$，$y$方向的位移是△$y$，那么我距离目标点$(x,y)$在x方向还需要$abs(x-$△$x)$的位移，$y$方向还需要$abs(y-$△$y)$的位移，总共需要$abs(x-$△$x)+abs(y-$△$y)$的位移，如果我当前的修改区间长度（最大修改次数）不小于我还需要的位移，就说明这种修改方案是成立的。

可以看下这部分的代码：

```cpp
bool check(int sta,int len){
//sta表示区间左端点，len表示长度
    int xx=sumx[sta-1]+sumx[n]-sumx[sta+len-1]; 
    //设前区间（0~sta-1）的x和后区间的（sta+len-1~n)x之和为△x 
    int yy=sumy[sta-1]+sumy[n]-sumy[sta+len-1];//同上 
    int c=abs(xx-x)+abs(yy-y);//还需要的移动距离
    if(len>=c)return 1; 
    return 0;
}
```

**代码实现**：最朴素的想法是直接枚举区间的左端点和右端点，每次检查这样的区间修改后能不能到达终点，检查的时候需要再挨个计算区间内位移，计算时遍历整个区间，所以这样做的时间复杂度是$O(n^3)$

当然有一个比较常用的优化是前缀和。我们把初始操作指令看成x方向和y方向的+1/-1，就可以预处理出前缀和，实现$O(1)$区间查询时间复杂度。于是时间复杂度被优化为$O(n^2)$

这样好像还是过不了，怎么办呢。答曰二分。

这个优化~~最强~~有点难想到，主要是因为二分需要满足单调性，而这道题的单调性有点抽象。

因为，我修改次数多了以后，能进行的位移也就多了，那么我比起修改次数少的位移肯定更容易到终点。换句话说，如果修改次数多的到不了，那么修改次数少的肯定到不了；而如果我修改次数少的能到终点，那么修改次数多的必定能到终点（大不了让其中某些操作不变）。从这个层面讲，我们以能不能到达终点作为目的：

**更长的区间一定优于更短的区间**。

在这一结论的基础上就可以二分区间长度，找到最短的满足条件的区间长度。再具体地说，如果当前长度满足条件，那么我找更短的，如果不满足条件，那么我找更长的。这样就把内层循环时间复杂度降到了$O(logn)$。可以AC了。

最后提醒一下，如果把枚举左端点放在二分外面，需要在所有可能答案（mid）中取最小值。

**附上代码**

```cpp
#include <iostream>
#include <cstdio>
#include <cmath>
using namespace std;

char s[500005];
int x,y,n,sumx[500005],sumy[500005];
int l,r,mid,dis,ans=2147483647;

bool check(int sta,int len){//如图示，需要满足条件：
    int xx=sumx[sta-1]+sumx[n]-sumx[sta+len-1]; //设前区间的x和后区间的x之和为△x 
    int yy=sumy[sta-1]+sumy[n]-sumy[sta+len-1]; //设前区间的y与后区间的y之和为△y
    int c=abs(xx-x)+abs(yy-y);
    if(len>=c&&c%2==len%2)return 1; 
    return 0;
}

int main() {
    scanf("%d",&n);
    getchar();
    for (int i=1;i<=n;i++){
        s[i]=getchar();
        sumx[i]=sumx[i-1];
        sumy[i]=sumy[i-1];//之前前缀和写错了orz 
        if(s[i]=='U')sumy[i]=sumy[i-1]+1;
        if(s[i]=='D')sumy[i]=sumy[i-1]-1;
        if(s[i]=='R')sumx[i]=sumx[i-1]+1;
        if(s[i]=='L')sumx[i]=sumx[i-1]-1;             //前缀和优化，减小求区间内x、y的时间复杂度 O(n)->O(1) 
    }
    scanf("%d%d",&x,&y);
    dis=abs(x)+abs(y);
    if (n<dis){//特判：1.整个字符串操作次数总和小于至少需要的操作次数（曼哈顿距离/每次操作的单位长度） 
        printf("-1\n"); //2.操作次数的奇偶性和“能到达终点”的操作次数的奇偶性不同 
        return 0;
    }
    for (int i=1;i<=n;i++){//O(nlogn) 
        l=0,r=n-i+1;
        while(l<=r){//更长序列一定更优（操作次数多，比更短的更容易到达终点），不会更劣（大不了我序列中的某个字母不动就是了） 
            mid=(l+r)>>1;
            if (check(i,mid)){
            r=mid-1;ans=min(ans,mid);}//二分长度，这个长度太短那就向更长的挪一挪 
            else l=mid+1;//够长那我就找还有没有更短的 
        }
    }
    if(ans==2147483647)ans=-1;
    printf("%d",ans);
    return 0;
}
```