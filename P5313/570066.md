看到桶里面固定差找数，立马想到 bitset，又是静态询问，那么肯定使用 bitset 优化莫队。

考虑如下做法：将当前的 bitset 桶分成 $\frac{n}{b}$ 个长度为 $b$ 的块，然后将所有块按顺序一个一个按位与起来，第一次按位与出 $0$ 时，当前块编号即为 $x$。

上述做法的复杂度是 $\mathcal O(n\sqrt m + m\frac{V}{\min(w,b)})$。

发现当 $b < w$ 时，我们的 bitset 优化就没有作用了。于是考虑根号分治，设阈值为 $w$，当 $b\ge w$ 时，使用上述做法，当 $b < w$ 时，使用如下做法：

开 $b$ 个长度为 $\frac{n}{b}$ 的 bitset，再做 $w$ 次莫队。外层循环按 $1$ 到 $w$ 枚举 $b$。对于在 bitset 中加入一个数 $a$，我们将 $a$ 加入到第 $x\ \textrm{mod}\ b$ 个 bitset 的第 $\frac{x}{b}$ 位中。答案即为所有 bitset 中第一次出现 $0$ 的位置下标的最大值。

总复杂度是 $\mathcal O(n\sqrt m + \frac{mV}w)$。

STL 中的 bitset 不支持分裂操作，需要手写。

代码有点乱，等我封装一下 bitset 再改改再贴上来。

小技巧：

- 对于 $b < w$ 的做法，每次莫队前都修改块长为 $\frac{n}{\sqrt m_i}$。

- 每次清空桶只需按顺序一个一个撤销之前的操作，没必要 memset。

- 相信神奇块长，例如我用的是 $\frac{2n}{\sqrt m_i}$。

最慢点 1.45s，人傻常数大。