一道超有意思的交互题。

令 $x_i$ 为一开始第 $i$ 种麻将个数。

当我们第一次为第 $i$ 种麻将个数增加 $1$ 的时候，不妨考虑刻子和顺子的增加量。

显然，刻子的增加量为 $\frac{x_i(x_i-1)}{2}$，而顺子的增加量则是 $x_{i-2}x_{i-1}+x_{i-1}x_{i+1}+x_{i+1}x_{i+2}$，可以发现，若一种牌在塞这张牌前的张数为 $1$ 及以上，那么这种牌的数量就确定了。

观察顺子增加量的式子。对于一种牌 $i$，如果我们同时知道了 $x_{i+1},x_{i+2},x_{i-1}$，那就能方便地推出 $x_{i-2}$。

考虑用某种方法算出 $x_n,x_{n-1},x_{n-2},x_{n-3}$，如此我们就能够依次倒推算出每一个元素。

由于计算 $x_{i-2}$ 需要向 $i$ 塞牌时候的顺子增加量，不妨先从 $3$ 到 $n-2$ 为每一个位置塞一张牌。

在第 $i$ 个位置塞牌的时候顺子的增加量就是 $(x_{i-2}+1)(x_{i-1}+1)+(x_{i-1}+1)x_{i+1}+x_{i+1}x_{i+2}$。

此时我们已经用掉了 $n-4$ 次塞牌。

不难发现，这时候我们再对 $n$ 塞两次牌可以确定下来 $x_n$。

不妨先对 $x_n$ 塞一次牌，这样我们确定了 $x_{n-1}(x_{n-2}+1)$。

我们想要确定下 $x_{n-1}$，$x_{n-2}$，$x_{n-3}$，但看起来这些值很不好确定。

观察到如果我们对 $x_{n-1}$ 塞一次牌，那么假如我们知道了 $x_{n}$ 与 $x_{n-2}$，我们就能算出 $x_{n-3}$。

发现我们需要向 $x_n$ 塞两次牌（这是我们规划好的），我们还有两次塞牌的盈余，不妨利用这个 "塞两次牌" 之间的间隔确定 $x_{n-1}$ 和 $x_{n-2}$。

如何确定呢？因为我们要计算 $x_{n-3}$，不妨在此时对 $n-1$ 塞一张牌。观察到此时如果我们给 $n-1$ 塞一张牌，我们再次塞 $n$ 时顺子的增加量就变成了 $(x_{n-1}+1)(x_{n-2}+1)$，两式相减就可以解出 $x_{n-2}$，进而解出 $x_{n-1}$。

因此，接着我们对 $x_{n-1}$ 塞一次牌，我们得到了 $(x_{n-2}+1)(x_n+1)+(x_{n-3}+1)(x_{n-2}+1)$

最后再次对 $x_n$ 塞牌，现在我们确定了 $x_n$ 和 $(x_{n-1}+1)(x_{n-2}+1)$。

如此一来，我们得出了 $x_{n-2}+1$ 的值，因此确定 $x_{n-2}$ 是简单的；根据对 $(x_{n-1}+1)(x_{n-2}+1)$ 的值，确定出 $x_{n-1}$ 也是简单的。

现在我们知道了 $x_n$ 和 $x_{n-1}$，稍微推一下就能解出 $x_{n-3}$ 了。

类似地，我们可以从为 $n-2$ 塞牌推出 $x_{n-4}$，……，依次推出 $x_1$。

以上就是 $n>4$ 的情况。对于 $n=4$，我们需要额外对 $2$ 号位置进行一次塞牌，因为 $n-2=2$，而若 $x_2$ 等于 $0$，则按照上式方法无法计算出 $x_3$。

既然还有一次剩余的次数，为了减少讨论，可以对 $2$ 统一塞一张牌，然后你就不用讨论了。

最终塞牌次数为 $n$ 或 $n-1$ （取决于 $n$ 的大小和你想不想要讨论），我的代码为 $n$。

```cpp
#include <bits/stdc++.h>

using namespace std;

int ud[105],vd[105];
int t1,t2;

void ask(int pos,int &u,int &v)
{
	printf("+ %d\n",pos);
	fflush(stdout);
	int nt1,nt2; scanf("%d%d",&nt1,&nt2);
	u = nt1 - t1; v = nt2 - t2;
	t1 = nt1; t2 = nt2;
}

int x[105];

int calc(int v)
{
	for(int i = 1;;i ++) if(i * (i - 1) / 2 == v) return i;
}

int main()
{
	int n; scanf("%d",&n);
	scanf("%d%d",&t1,&t2);
	for(int i = 2;i <= n - 2; ++ i)
		ask(i,ud[i],vd[i]);
	int u1,v1,u2,v2,u3,v3;
	ask(n,u1,v1);
	ask(n - 1,u2,v2);
	ask(n,u3,v3);
	x[n - 2] = (v3 - v1) - 1;
	x[n] = calc(u3) - 1;
	x[n - 1] = v3 / (x[n - 2] + 1) - 1;
	x[n - 3] = (v2 - (x[n] + 1) * 1ll * (x[n - 2] + 1)) / (x[n - 2] + 1) - 1;
	for(int i = n - 4;i >= 1; -- i)
		x[i] = (vd[i + 2] - (x[i + 3]) * 1ll * (x[i + 1] + 1) - (x[i + 3]) * x[i + 4]) / (x[i + 1] + 1) - 1;
	x[1] ++;
	printf("! ");
	for(int i = 1;i <= n; ++ i) printf("%d ",x[i]);
	printf("\n");
	fflush(stdout);
	return 0; 
}
```