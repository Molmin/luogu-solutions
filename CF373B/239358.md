简单模拟。

首先我们通过大眼观察法可得如下题意：

>你有 $w/k$ 元钱，每次添加一个数的代价为该数的位数，问从第 $m$ 个数开始最多可连续添加多少个数？

考虑一位一位往上跳。

显然，对于数位相同的数，它们的代价（即数位）是相同的，可以直接用乘法累加代价。

所以我们可以在最开始时先跳到比 $m$ 高一位，然后检测能不能跳到下一位，如果能的话就减去这一段代价并让 $m$ 往上跳直至跳不动为止。

具体实现看下代码。

记得开 long long !

### Code

```
#include<bits/stdc++.h>
using namespace std;
int main()
{
	long long w,m,k,x=1,y=0,z=0;
	//x是当前预计跳到的数，y是这一段数的位数，z是当前已经跳到的数
	cin>>w>>m>>k;
	z=m;
	w/=k;
	while(x<m)x*=10,y+=1;
	while(w>=x*y-z*y)//检测是否可以跳
	{
		w-=x*y-z*y;
		z=x;
		x*=10;
		y+=1;
	}
	//此时的z还需要加上w/y（即最后剩下的代价还能跳多少个数）才是最后跳到的数，并要减去最开始的m
	cout<<z+w/y-m;
}
```
