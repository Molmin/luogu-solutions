## 思路

乍一看没啥思路，但是我们可以考虑最坏情况。

假设 $i-1$ 和 $i+1$ 都是 ```YES``` 而 $i$ 是 ```NO```。这个时候怎么办呢？我们发现只需要把 $i$ 和 $i+k-1$ 这两个位置设置成相同的就可以了。这种方法只对 $i$ 有影响，是无后效性的。所以最后的思路就是，对于 $1$ 到 $n$ 每个位置 $i$ 先放上一个数 $i$，然后判断所有的 ```YES```，将 $i$ 赋值给 $i+k-1$。最后对于每个不同的数，我们直接随便输出一个不同的单词即可。这样做不仅效率高的一匹，而且容易实现。

但是作为萌新，我不会随机输出怎么办？

其实很简单。只需要对于每个单词，把它转化成 ```a~z``` 的 26 进制即可。注意首字母大写 qwq！

## 代码

可能是整数的常数小，跑得飞快，不开 O2 不卡常坐稳最优解！

```cpp
#include <bits/stdc++.h>
using namespace std;
int a[200005];
string turn(int x)
{
	string s="";
	while(x) s+=(char)(x%26+'a'),x/=26; // 整数转化成 26 进制
	s[0]=s[0]-'a'+'A'; //首字母大写
	return s;
}
int main()
{
	int n,k; cin>>n>>k;
	for(int i=1;i<=n;i++) a[i]=i;
	for(int i=1;i<=n-k+1;i++)
	{
		string x; cin>>x;
		if(x=="YES") continue;
		a[i+k-1]=a[i]; // 处理 'NO' 的情况
	}
	for(int i=1;i<=n;i++)
		cout<<turn(a[i])<<" "; // 把数字转化成字符输出
	return 0;
}
```