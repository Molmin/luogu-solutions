（本毒瘤又一次深刻讨论了一下假如我们是死活想不出来正解的蒟蒻，如何在考场上用暴力得到更多的分...）

蛮有意思一道题，思想很经典，卡人的点也很少。就一个难度大概在**普及+/提高**的思维难点，想明白之后就可以秒题了。

大眼睛一看$n<=200$，哦豁，老弟，$Floyd$在微笑着向你招手呢！

但是怎么做呢，由于$Floyd$算法是直接在询问前处理出任意两点之前的最短路，所以很容易让人想歪，想去把每个时刻的当前状态下的整张图的最短路处理出来。

如果这么做，很显然，我们需要一个$dis[i][j][t]$，表示在$t$时刻，$(i,j)$的最短路，如果路没修好，就是$inf$（无穷大），然后维护$t$遍$Floyd$就可以了。但是虽然空间上好像没啥问题，时间上瞬间变成了$n^3*t_n$，而$t_n$虽然没告诉你范围但是也是$>=n$的，这个复杂度炸了。

考虑优化？$n^3$的$Floyd$可以用$n^2*logm$的$dijkstra$代替，那么我们的复杂度就在$O(t_n*n^2*logm)$，而$t$可以离散化变成$n$，那么就可以变成$O(n^3*logm)$了，$n<=200$的话，是$1e8+2e7$多...超过了$1e8$，感觉。。。。

~~（**虽然过不去但是我们水个大半的分还是极好的**）~~

#### 但是
这个离散化不好写，因为在$Q$次询问里，每次的时间也必须跟着$t$进行一个离散化，比如，$t_i=1,4,6,7$，$Q_i=1,3,5,8$（只指每次询问的时间），那么，把$t$离散化之后变成$1,2,3,4$，$Qi$就必须跟着变成$1,1,2,4$才能保证像原来一样严格遵守了只看当前查询的时间之前的那些$t_i$，比如这个3，原来的话是$3>1$，1号修好了，但是$3<4$，2号没修好，那么现在离散化之后就是，$1$表示，1号修好了，没到2，2号没修好。

~~**这个离散化好麻烦啊....**~~ 这个离散化很显然复杂度可以用时间的单调性$O(Q)$处理完。

所以，当我们在考场上对正解绝望时，我们就可以用码力去弥补了。。。

### 来来来我们来说说正解。。。。。
不要离线了，在线多好，我们可以在每次查询的时候，把到当前时间修好的城市都选出来去更新$Floyd$，然后，就可以得到当前答案了。

而由于每次询问的时间单调递增，所以，之前维护的$Floyd$的$dis$数组直接拿来接着用就好了。

**~~正解怎么这么简单。。。~~**

### $code:$
```cpp
#include<bits/stdc++.h>
using namespace std;
inline void update(int k);
int dis[210][210],rep[210];
int n,m,q;
int main(){
    memset(dis,0x3f,sizeof(dis));
    cin>>n>>m;
    for(int i=0;i<=n-1;i++){
        cin>>rep[i];
    }
    for(int i=1,u,v,w;i<=m;i++){
        cin>>u>>v>>w;
        dis[u][v]=w,dis[v][u]=w;
    }
    cin>>q;
    int poi=0;
    while(q--){
        int u,v,t;
        cin>>u>>v>>t;
        while(poi<n && rep[poi]<=t){
            update(poi);
            poi++;
        }
        if(dis[u][v]>=0x3f3f3f3f || rep[u]>t || rep[v]>t){
            printf("-1\n");
        }
        else printf("%d\n",dis[u][v]);
    }
    return 0;
}
inline void update(int k){
    for(int i=0;i<n;i++){
        if(i==k) continue;
        for(int j=0;j<n;j++){
            if(j==i || j==k) continue;
            if(dis[i][j]>dis[i][k]+dis[k][j]){
                dis[i][j]=dis[i][k]+dis[k][j];
            }
        }
    }
}
```