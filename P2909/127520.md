这道题不算难吧（刚模拟赛做的）：

先sort一遍，然后从小的开始扫，如果可以就让他开车  ~~别想歪了~~。因为越小条件越苛刻。越大越容易上路。用循环指针k表示轮到开哪条路开个数组表示路上已经有多少车。扫一遍即可。

根据思路贴出代码

```
#include <bits/stdc++.h>
using namespace std;
int v[50001],i,j,k,l,m,n,d,lu[50001],ans;//v表示车速..lu表示每条路上的车数，原谅变量有点多 
int ys(int x){//表示当x大于0时返回原数否则返回0 
	return (x+abs(x))/2;//简单数学 
}
int main(){
cin>>n>>m>>d>>l;
for(i=1;i<=n;i++) cin>>v[i];   //输入 
sort(v+1,v+n+1);  //排序一下 
k=1;   //从道路1开始 
for(i=1;i<=n;i++){
	if(ys(v[i]-lu[k]*d)>=l) lu[k]++,ans++,k=k%m+1; //如果可以上路那么答案++,那条路的车++,然后换下一条路（如果是最后一条路那么返回第一条） 
}
cout<<ans;  //输出即可 
return 0;  //养成好习惯 
}

```
我的题解就到此结束了，求通过qwq ~~话说奶牛怎么这么多~~