## 0. 题意简述

生成一个以`'a' 'b' 'c'`组成的长度为 $n$ 的字符串，使字符串的每个**回文子串**的长度均 $<k$。

## 1. 题目分析

这道题起初看起来会有些复杂，但仔细读题，发现题目中“保证所有测试点都有生成方案”，就把难度削减了一些。再观察样例第二组数据，发现当 $k$ 为 $1$ 时有解，就可以断定，总有一种生成方式使整个字符串中没有长度达到 $2$ 的回文子串。稍加思考，我们可以想到以下方案：

1. 全部用`'A'`，马上就会被否认，因为`'AAA'`就是回文串；
2. 用`'AB'`交替，反例为`'ABA'`；
3. 用`'ABB'`交替，反例很难找到，是`'ABBA'`；
4. 在试验大量`'AB'`组成的串后，得出结论：仅用`'AB'`组成字符串，总会有长度达到 $2$ 的回文子串。
5. 那么开始尝试`'ABC'`串：`'ABC'`交替，可以使用。

## 2. 代码

已经知道如何生成了，那么下一步就是告诉机器如何生成。

要注意的是，题目给出的长度 $n$ 不一定是 $3$ 的倍数，所以要判定一下末尾！

两种做法：

第一种做法，首先输出整 $3$ 的部分，即（$a$ 代表 $n$，$b$ 为临时变量）：

```cpp
b=a/3;//由于受我码风的影响，循环结束条件必须是变量/常数比较，不进行逻辑以外的运算，所以提前保存循环次数
for(int j=0;j<b;j++){
    cout<<"abc";
}
```
之后输出剩余部分：
```cpp
b*=3;
b=a-b;//同上
char s[4]="abc";//记得保留'\0'的空间
for(int j=0;j<b;j++){
    cout<<s[j];
}
cout<<endl;
```

第二种做法：一直生成到超出 $n$，之后截取前 $n$ 字符：
```cpp
b=a;
string s;
while(b>0){
    s+="abc";
    b-=3;
}
cout<<s.substring(0,n)<<endl;
```

完整代码如下，第二种做法自行改变循环体：
```cpp
#include<iostream>
using namespace std;
int main(){
    ios::sync_with_stdio(false);//加速
    int n;
    cin>>n;
    for(int i=0;i<n;i++){
        int a,b;
        cin>>a>>b;
        //改变部分
        b=a/3;
        for(int j=0;j<b;j++){
            cout<<"abc";
        }
        b*=3;
        b=a-b;
        char s[]="abc";
        for(int j=0;j<b;j++){
            cout<<s[j];
        }
        cout<<endl;
        //改变部分结束
    }
    return 0;
}
```