我们发现n的数据范围很大,无法进行状态压缩(还没等你MLE,你先TLE了)。于是我们要寻找突破口。

仔细观看题目,发现了这样一句话

> 每个小朋友站在大围栏圈的外面，可以看到连续的 5 个围栏。

这个连续的5个围栏,就可以作为突破口。

对这5个围栏进行状态压缩。具体解释在代码里。
```cpp
#include<iostream>
using namespace std;
int w[100005][155],zyl[100005][155]; //w表示权值,即移走或不移走这5个动物获得的贡献。用状态压缩表示5个动物的状态。
int main(){
	int n,c,i,j,k,e,f,l,x,y,like,hate,Max=0; //like表示喜欢的状态压缩,hate表示害怕的状态压缩。
	cin>>n>>c;
	for(i=0;i<c;++i){
		cin>>e>>f>>l;
		like=hate=0;
		for(j=0;j<f;++j){
			cin>>x;
			if(x<e){
				x+=n;
			}
			like=(like|(1<<x-e))&31; //或运算可以写成加法,但或运算更快。&31时过滤掉超出5个围栏的动物。
		}
		for(j=0;j<l;++j){
			cin>>y;
			if(y<e){
				y+=n;
			}
			hate=(hate|(1<<y-e))&31; //注释同计算like。
		}
		for(j=0;j<32;++j){
			w[e][j]+=(bool)((j&hate)||((~j)&like)); //移走了他害怕的或没移走他喜欢的。
		}
	}
	for(k=0;k<32;++k){
		for(i=0;i<32;++i){
			zyl[0][i]=-2147483647; //一开始初始化为极小值。-2147483647=-(2³¹-1) 即int的下限。
		}
		zyl[0][k]=0;
		for(i=1;i<=n;++i){
			for(j=0;j<32;++j){
				zyl[i][j]=max(zyl[i-1][(j&15)<<1],zyl[i-1][((j&15)<<1)|1])+w[i][j]; //这是dp的状态转移方程。左移时避免影响结果,先舍去第一位。左移后枚举选不选当前这个。
			}
		}
		Max=max(Max,zyl[n][k]); //取最大值。
	}
	cout<<Max;
	return 0;
}
```