## 【题意】
给定一个序列

每次操作翻转一个区间 $[l,r]$

求**每次**翻转后**整个序列**逆序对的奇偶性

## 【思路分析】

首先看到翻转区间我们可以想到Splay可以胜任

看到逆序对可以想到归并排序

但是根据 ~~（CF的题目都是思维题）~~ **时间复杂度**可以很轻易地判断出这显然是不行的

**考虑这道题目让我们求什么**

显然，我们并不需要求出逆序对的数目，而只需要求它的**奇偶性**

对于一个要被翻转的区间 $[l,r]$

显然长度 $len=r-l+1$

其**全部数对**的数目是：$num=\frac{len(len-1)}{2}$

**对于这个区间：**

- **其全部的正序对在翻转后会变成逆序对**

- **其全部的逆序对在翻转后会变成正序对**

### 重点来了

如果 $num$ 是一个偶数，分类讨论其逆序对的奇偶性的两种情况

- **奇数**，那么其正序对的数目也是**奇数**，翻转后奇偶性**不变**

- 偶数，显然翻转后奇偶性不变

如果 $num$ 是一个奇数，其逆序对的奇偶性也有两种情况

- **奇数**，那么其正序对的数目是**偶数**，翻转后奇偶性**改变**

- **偶数**，那么其正序对的数目是**奇数**，翻转后奇偶性**改变**

## 【总结】
**如果 $num$ 是偶数，那么不管怎样奇偶性都不变，如果是奇数，那么不管怎么样奇偶性都会改变**

## 【代码实现】

```
#include<iostream>
#include<algorithm>
using namespace std;
int a[500001],r[500001],len,ans,e,L,R,t,num;
void msort(int s,int e){
	if(s==e) return;
	long long int mid=(s+e)/2;
	msort(s,mid);msort(mid+1,e);
	int i=s,j=mid+1,k=s;
	while(i<=mid&&j<=e){
		if(a[i]<=a[j]){
			r[k]=a[i];
			k+=1;i+=1;
		}
		else{
			r[k]=a[j];
			k+=1;j+=1;
			ans+=mid-i+1;
		}
	}
	while(i<=mid){
		r[k]=a[i];
		k+=1;i+=1;
	}
	while(j<=e){
		r[k]=a[j];
		k+=1;j+=1;
	}
	for(int i=s;i<=e;i++)
		a[i]=r[i];
}
int main(){
	cin>>num;
	for(int i=1;i<=num;i++){
		cin>>a[i];
	}
	msort(1,num);
	if(ans%2==0) e=1;
	cin>>t;
	while(t--){
		cin>>L>>R;
		len=R-L+1;
		if(len*(len-1)/2%2){
			e=!e;
		}
		cout<<(e?"even\n":"odd\n");
	}
}
```

~~**为什么我的归并排序时间复杂度假了QAQ**~~