这道题其实还是挺偏思维题的，我看网上有很多很多的大佬写了超级超级长的并且有点冗杂代码 ~~我是不会告诉你我看不懂的~~ 。

所以我在这放上我自己的代码以及一些思路

首先我们会发现这道题的数据范围是很大的，直接暴力会轻轻松松的T掉~~我T了两发~~再一看这个题目的难度分类，貌似不用打那些平衡树等等高深的算法~~反正我也不会~~，再一想答案只需要输出奇偶性，于是想出了答案。

题意是将一段区间翻转，我们会非常轻易地发现 **原先是正序的翻转后变成了逆序的，并且翻转的部分只对该区间起作用** ，所以翻转后逆序对数量的奇偶性也就是翻转前正序对的数量的奇偶性，但他们两者的奇偶性是不好求的 ~~其实也可以直接判断他们两者的奇偶性，但我不是这么做的~~ ，所以我尝试了另一种方法

我们先设该给定区间的长度为**lenth**，则该区间内所有数对数量为

**lenth(lenth-1)/2** 这里需要注意一下是所有数对数量而不是什么逆序对数量

我们再设翻转后的逆序对数量为**part** 所以翻转前的正序对数量也为part，这个前面提到过了，不懂的往前找，所以翻转前的逆序对数量就为

**lenth(lenth-1)/2-part**

然后现在是最重要的一步：**翻转前的逆序对数量减去翻转前后逆序对数量差就是翻转后逆序对的数量，所以如果要判断翻转后逆序对数量的奇偶性只需要判断反转前后逆序对数量差的奇偶性即可**

这一部感觉还是挺难理解的，各位有不懂的可以私信我

这个数量差可以表示为：

**lenth(lenth-1)/2-part-part**

也就是：

**lenth(lenth-1)/2-part*2**

其中**part*2**一定是偶数，所以我们判断**lenth(lenth-1)/2**就可以了，而这个太简单不过了

直接上代码，代码里也会有一些解释：

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <cmath>
#include <algorithm>
int n,m;
int lenth,part;
int l,r;
int f;
int a[1550];
int main()
{
	while(~scanf("%d",&n))
	{
		for(int i=1;i<=n;i++)
            scanf("%d",&a[i]);
		scanf("%d",&m);
		lenth=0;
		for(int i=1;i<n;i++)
			for(int j=i+1;j<=n;j++)
				if(a[i]>a[j]) lenth++;//暴力求这个区间的逆序对数量，本人不会更高级的算法了，不过这个也可以过
		if(lenth%2==0) f=1;
		else f=0;//这两行是求原来区间所有数对的数量也就是lenth的奇偶性
		while(m--)
		{
			scanf("%d%d",&l,&r);
			part=r-l+1;
			if((part*(part-1)/2)%2==1)
			    f=!f;
			if(f)
			   printf("even\n");
			else
			    printf("odd\n");//输出答案
		}
	}
	return 0;
}

```
撒个花结束，请管理员大大让我通过，第一篇题解，写得可认真了。

各位大佬要是有不懂得可以私信问我呀