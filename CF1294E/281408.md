**写在最前：如果有不懂，欢迎私信。如果有小错误，欢迎指出。**

### 思路

看完题之后，我们知道了这一题支持两种操作：

1. 把某一列统一向上挪一格，第一行挪到最后一行。

2. 把某一个数改成 $1$ 到 $n \times m$ 中的任意一个数字。

显然，列于列之间互相不影响，所以我们可以一列一列地算出最小次数，然后累加即可。

那么怎么计算每一列的最小值呢？

一开始我想到了直接暴力来计算每一列往上挪的次数，但是，这样很明显会超时。

那怎么来优化呢？

其实，我们只用记录每一个点到它应该到的位置的距离即可，比如，我们现在有一个 $3 \times 3$ 的矩阵：

```cpp
3 3
3 2 1
1 2 3
4 5 6
```

其中，数字 $1$ 应该到 $(1, 1)$ 这个位置，但是， $1$ 现在在 $(2, 1)$ ，所以它到目标位置要挪 $1$ 次。

同理，数字 $4$ 应该到 $(2, 1)$ 这个位置，但是， $4$ 现在在 $(3, 1)$ ，所以它到目标位置要挪 $1$ 次 。

我们用一个桶数组 $s$ 来记录。

为什么要用桶数组呢，因为 $s_i$ 表示的是把某一列向上挪 $i$ 此后，有 $s_i$ 个数字已经到了目标位置，剩下就有 $n - s_i$ 个数，这样的话，要想求出每一列的最小次数，我们就只用从 $s_i$ 中取出最大值，然后剩下的数字单独执行操作二即可，最小次数就是 $i + n - s_i$ 。

可能有细心的童鞋发现了，数字 $3$ 在 $(1, 1)$ ，但是它应该去 $(1, 3)$ ，不在同一列了怎么办？

其实很简单，既然不在同一列了，那肯定怎么往上挪也挪不到目标位置了，所以它要执行操作 $2$ 。

在程序里，我把它和超过 $n \times m$ 的数字单独拿出来计算了。

那怎么清空 $s$ 数组呢？

如果直接清空的话，最坏情况复杂度会达到 $2e5$ 的平方，会超时，所以我们只能在取最大值时清空 $s$ 数组。

~~那怎么读入呢？~~

直接开二维数组肯定不行，所以要使用 ~~人见人爱~~ 的 $vector$ 。

### $code$

```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 2e5 + 10;

int n, m, ans;  // n和m为题目输入，ans负责累加答案

int s[N];

vector<int> a[N];

int main() {
  cin >> n >> m;
  for (int i = 1; i <= n; i++) {    //行
    a[i].push_back(0);              //因为vector是从0开始的，我们习惯从1开始，所以先加入一个0
    for (int j = 1; j <= m; j++) {  //列
      int x;
      cin >> x;
      a[i].push_back(x);  //读入
    }
  }
  for (int i = 1; i <= m; i++) {  //我们一列一列地枚举处理
    int sum = 0;                  //记录特殊的数，比如目标位置不在该列或者超过n*m的数字个数，这些特殊数字只能执行第二种操作，所以最后要单独累加
    for (int j = 1; j <= n; j++) {
      int x = (a[j][i] % m == 0 ? a[j][i] / m : a[j][i] / m + 1), y = (a[j][i] % m ? a[j][i] % m : m);  //计算目标的x,y位置
      if (y != i || a[j][i] > n * m) {                                                                  //发现特殊的数
        sum++;                                                                                          //累加
        continue;
      }
      if (x == j && y == i) {  //如果不需要移动，那就是移动0次
        s[0]++;
      } else if (x < j) {  //如果目标位置在现在位置的上面
        s[j - x]++;
      } else {  //在下面
        s[n - x + j]++;
      }
    }
    int minx = 1e9;
    for (int j = 0; j < n; j++) {
      minx = min(minx, j + n - s[j] - sum);  //取最小操作次数，在上文里讲过
      s[j] = 0;                              //清空
    }
    ans += minx + sum;  //累加每一列的最小值
  }
  cout << ans;  //输出
  return 0;
}
```

**RP++!**