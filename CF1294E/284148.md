首先让我们来看题目中给的两种操作：  
- 选择矩阵中任意一个元素进行变换
- 选择矩阵中任意一列进行周期上移  
  
这两种操作都只会对矩阵的列有影响。因此，在对矩阵的操作过程中，其实是以列为基本单位进行操作的。我们可以依次对每一列进行操作，计算出每一列所需操作的最小值，累加起来的和就是最终答案。  
  
我们取出矩阵的某一列进行上移操作后，没有归位的元素需要用操作一变换为对应元素。矩阵上移的格数最多为 $n$ (超过 $n$ 就转回来了，没有意义)，因此，对于每一种上移的情况都有与之对应的变换情况。我们对每一种情况进行枚举，就能得出最小的操作次数。  
  
如果采用模拟的方式，时间复杂度将为 $O(mn^2)$，显然会超时。  
  
由于题目要求的目标矩阵形式是给定的，所以我们可以求出矩阵中任意某个数所在的位置，并与现在矩阵中该数的位置进行比较，得出上移的格数。然后，另开一个数组记录上移某个格数时归位元素的个数。对上移的格数进行枚举， 最终得出上移操作 $x$ 格能够获得的最大归位元素个数 $max$， 则该行复位需要的最小操作数为 $n-max+x$。此时，时间复杂度被优化到 $O(nm)$。  
  
至于求某个元素应在格的公式，其实题目的图已经给出了,在此不再赘述。如果不好理解，如下代码可供参考。  
  
值得注意的点：  
- 题目中 $n$ 和 $m$ 都可能达到 $10^5$ 级别，因此不能直接开二维数组。由于题目对 $nm$ 进行了限定，因此可以直接开一维数组，再从中取数。当然也可以通过动态数组解决。  
- 题目中只说明了所给矩阵中的元素小于 $2·10^5$，并没有说明元素小于 $nm$，因此必须进行判断，谨防数组越界。(惨痛的教训$QAQ$)  
  
为您奉上代码：
```c
#include<stdio.h>
#include<stdlib.h>
int mat[200005]={}, row[200005]={}, cnt[200005]={};
int read()
{
	int x=0;
	char ch = getchar();
	while( ch<'0' || ch>'9' ) ch = getchar();
	while( ch>='0' && ch<='9' ){
		x = (x<<3) + (x<<1) + ch - 48;
		ch = getchar();
	}
	return x;
}
int cmp( int n, int m, int j )
{
	int move, realN, min=2<<29;
	for( int i=1; i<=n; i++ ){
		if( row[i] % m != j%m ) continue; //如果该元素不应该在该列在必须通过变换的方式解决
		if( row[i]<1 || row[i]>n*m ) continue; //谨防越界
		realN = (row[i]-j) / m + 1; //应该放在的位置
		move = i - realN; //向上移动的格数
		if( move<0 ) move += n; //周期性移动
		cnt[ move ]++; //移动move个单位归位元素个数
	}
	for( int i=0; i<n; i++ )
		min = min < n-cnt[i]+i ? min : n-cnt[i]+i;
	return min;
}
int main()
{
	int n, m, ans=0;
	scanf("%d %d", &n, &m);
	for( int i=1; i<=n*m; i++ )
		mat[i] = read();
	for( int j=1; j<=m; j++ ){ //操作只对列有影响 枚举列
		for( int i=0; i<n; i++ )
			cnt[i] = 0; //初始化
		for( int i=0; i<n; i++ )
			row[ i+1 ] = mat[ j + i*m ];
		ans += cmp( n, m, j );
	}
	printf("%d\n", ans);
	system("pause");
	return 0;
}
```
