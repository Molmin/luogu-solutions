考点：状态压缩动态规划

首先看一眼数据范围，$2 \leq M \leq 23$，$2 \leq N \leq 10^5$，$1 \leq k \leq 100$，可以考虑一下对 $M$ 进行状态压缩。动态规划时从左往右依次讨论这个位置放置几号信号站，状态 $S$ 的第 $i - 1$ 位为 $1$ 则说明第 $i$ 个信号站已经被决定了，$f[S]$ 记录一下已有集合 $S$ 时可决定的最小传递，每次递推时讨论将一个不属于 $S$ 的信号站放在右侧。最终答案为 $f[(1 << m) - 1]$。

接下来讲述如何将 $f[S]$ 递推至 $f[S \cup p]$。

当在第 $|S| + 1$ 位安排信号站 $p$ 时，需要加上 $S$ 中需要向 $p$ 发送信号的信号站产生的代价，还需要加上 $p$ 需要向 $S$ 中的信号站发送信号产生的代价（当然这种传递是需要经过控制塔中转的）。然而我们并没有记录 $S$ 中各个信号站的具体位置。

这时我们可以考虑拆分每一次发送信号，$p$ 向右发送信号到 $q$ 用的时间可以视作一个虚构的左侧信号站（以下假设这个虚构的信号站处于控制塔的位置，即 $0$）向 $q$ 发信号的时间减去这个虚构信号站向 $p$ 发信号的时间；向左发信号则更好理解，可以视作先向左发信号到控制塔再由控制塔向右发信号到目标信号站。~~题目不是本来就这个意思吗~~

因此我们将信号站 $p$ 加入集合 $S$ 时可以这样操作：先减去 $p$ 向右发信号的数量乘以 $p$ 到虚拟信号站的距离，再加上 $p$ 从左接受信号的数量乘以 $p$ 到虚拟信号站的距离，再加上由 $p$ 发出或接收的向左信号数量乘以 $p$ 到控制塔的距离再乘上 $k$。

于是我们可以写出动规代码如下：

```cpp
for (int now = 0; now < (1 << m); now++) {//当前状态为now
    int w = init(now) + 1;//init的作用是求出now的二进制位里有多少个1，w为下一个信号站该放的位置
    long long step = 0;
    for (int p = 1; p <= m; p++) {//依次讨论这里放哪个信号站
        if (now & (1 << p - 1))//如果已经被now包含直接过
            continue;
        step = 0;
        for (int q = 1; q <= m; q++) {
            if (((now & (1 << q - 1)) == 0) && q != p) {//q不属于now，即q在p右侧
                step -= nxt[p][q] * w;//减去 p 向右发信号的数量乘以 p 到虚拟信号站的距离
                step += nxt[q][p] * w * k;//加上由 q 向左发信号的数量乘上 p 到控制塔的距离再乘上 k
            }
        }
        for (int q = 1; q <= m; q++) {
            if ((now & (1 << q - 1)) && q != p) {//q属于now，即q在p左侧
                step += nxt[q][p] * w;//加上 p 从左接受信号的数量乘以 p 到虚拟信号站的距离
                step += nxt[p][q] * w * k;//加上 p 从右侧接收信号的数量乘上 p 到控制塔的距离再乘上 k
            }
        }
        if (f[now | (1 << p - 1)] > f[now] + step)//如果更优则更新答案
            f[now | (1 << p - 1)] = f[now] + step;
    }
}
```

写出来一交，TLE30。

稍微数一下循环就可以得知，这个动归时间复杂度为 $O(m ^2 2 ^ m)$，只能过30%的数据。

怎么办呢？我们可以考虑预处理每个 p 对于之前的状态 S 递推时需要增减的数量，但是预处理时间复杂度依然是 $O(m ^2 2 ^ m)$。这时将状态 S 拆成前后两段预处理存在两个数组里，这时就只需要 $O(m ^ 2 2 ^ {\frac{m}{2}})$ 的时间就好了。

$pro[t][S_t][p]$ 存储的是 $p$ 对于之前的状态 $S_t$ 递推时需要增减的数量， $t$ 为 $0$ 则表示存的是前半段，$1$ 就是后半段，调用时只需要将 $pro[0][S_0][p]$ 和 $pro[1][S_1][p]$ 加起来乘上 $p$ 被放的位置 $w$ 即可替换掉上面那份代码的枚举 $q$ 的两个循环。

预处理代码如下：
```cpp
int len = m >> 1;//后半段长度
for (int p = 1; p <= m; p++)
    for (int S = 0; S < (1 << len); S++)
        for (int q = 1; q <= len; q++) {
            if (((S & (1 << q - 1)) == 0) && q != p)//把先前动规的枚举循环放到这就好，w 动规的时候再去乘
                pro[0][S][p] += nxt[q][p] * k - nxt[p][q];
            if ((S & (1 << q - 1)) && q != p)
                pro[0][S][p] += nxt[q][p] + nxt[p][q] * k;
        }
for (int p = 1; p <= m; p++)
    for (int S = 0; S < (1 << n); S += 1 << len)
        for (int q = len + 1; q <= m; q++) {
            if (((S & (1 << q - 1)) == 0) && q != p)
                pro[1][S >> len][p] += nxt[q][p] * k - nxt[p][q];
            if ((S & (1 << q - 1)) && q != p)
                pro[1][S >> len][p] += nxt[q][p] + nxt[p][q] * k;
        }
```

动规代码如下：
```cpp
memset(f, 0x3f, sizeof(f));
f[0] = 0;
for (int now = 0; now < (1 << n); now++) {
    int w = init(now) + 1;
    long long step = 0;
    for (int p = 1; p <= n; p++) {
        if (now & (1 << p - 1))
            continue;
        step = (pro[0][now & ((1 << len) - 1)][p] + pro[1][now >> len][p]) * w;//替换掉那两个循环就好，w拿到这里来乘
        if (f[now | (1 << p - 1)] > f[now] + step)
            f[now | (1 << p - 1)] = f[now] + step;
    }
}
```

~~我太菜了没去打省选，这题硬是在机房想了大半天~~