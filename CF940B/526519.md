## 基本思路

明显的贪心。

遇到这种情况要分类讨论：

1. 当前的 $n$ 值小于 $k$ 值，只能一直减一到 $1$。

2. 当前的 $n$ 大于 $k$ 值，此时我们有两种选择，一是减一到下一个 $n-n/k$，代价为 $(n/k)\times a$，二是直接除以 $k$，代价为 $b$。

很显然在第二种情况要选花费更少的，但如果直接交上去的话会 TLE。

考虑如何优化。从上面的第二种情况可以看出如果当前的除以 $k$ 的代价 $b$ 一旦大于直接减到 $n=1$ 的花费时，后面无论如何都是减一的策略更优，因为当前的 $n$ 值肯定除以 $k$ 减少的值比后面的 $n$ 值除以 $k$ 减少的值是要多的，如果前面的除以 $k$ 的策略已经不如减一的策略优的话就说明以后也不会比减一的策略要优，所以我们此时可以直接把他给减到一输出花费，这样就不会 TLE 了。

## code

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,k,a,b,ans;
signed main()
{
	cin>>n>>k>>a>>b;
	if(n<k)//第一种情况，n不能被k整除 
	{
		cout<<(n-1)*a<<endl;//只能一直减一到1为止 
		return 0;//好习惯 
	}
	while(n!=1)//只要n不等于1就一直循环 
	{
		ans+=n%k*a;//先减到能被k整除的情况 
		n-=n%k;//n减去已经减去的值 
		if(b<(n-n/k)*a)//如果当前整除比之间减去n/k的花费少 
		{
			ans+=b;//那就除以k 
			n/=k;//更新n的值 
		}
		else
		{
			ans+=(n-1)*a;//否则就直接减到1 
			cout<<ans<<endl;//输出答案 
			return 0;//好习惯 
		}
	}
	cout<<ans<<endl;//输出答案 
	return 0;//好习惯 
}

```
