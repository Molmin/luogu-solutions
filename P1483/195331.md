[在我的博客中看效果更佳](https://www.luogu.com.cn/blog/195331/)

这题，首先最容易想到的是按照题目要求去暴力，然后又是最容易想到的是这样肯定过不了。那么我们思考：让所有$a_{kx}$加上$y$，就是让所有的$z \% x == 0$加上$y$，那么我们就很容易地想到在遇到操作$1$时，记录每对$x$和$y$，然后在遇到操作$2$时枚举所有他们，当$j \% x == 0$时把计数器加上$y$。但是这样还是很慢啊！！！这时，我们注意到，遇到操作$2$时我们是要判断约数的……那我们是不是可以枚举约数？答案是可以的。那就用$w_i$表示要让所有的$ki$加上$w_i$，操作$1$就是$w_x += y$，而操作$2$就是枚举所有数，若是他的因数，则加上$w_i$。等等，这样不还是很慢吗？这说明还能再优化：约数都是成双成对出现的（完全平方数例外），那我们在他得到一个约数$z$时，就可以得到他的另一个约数$x \div z$，那我们就只要枚举前$\sqrt{x}$个就可以了，然后再特判一下完全平方数，就可以让每次查询的时间为$O(\sqrt{x})$了！

讲了这么多，下面来看代码吧。
```cpp
#include<cstdio>
using namespace std;
int n,m,a[1000005];
int w[1000005];//同题解中所述
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++) scanf("%d",&a[i]);
	for(int i=1,x,y,opt;i<=m;i++)
	{
		scanf("%d",&opt);
		if(opt==1)//操作1
		{
			scanf("%d%d",&x,&y);
			w[x]+=y;//同题解中所述
		}
		else
		{
			scanf("%d",&x);
			y=0;//用来记录要加多少数
			for(int j=1;j*j<=x;j++)
				if(x%j==0)//是x的约数
				{
					y+=w[j];//加上w[j]
					if(x/j!=j) y+=w[x/j];//x的另一个约数，注意判断完全平方数的情况（完全平方数的话会出现i*i=x的情况）
				}
			printf("%d\n",y+a[x]);//输出时记得加上初始的数哦
		}
	}
	return 0;
}
```