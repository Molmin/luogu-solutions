~~**仔细观察你会发现这是一道大水题**~~

### 一.先看操作一

"输入格式“$1~x ~y$”，表示把所有$a[kx] $（$k$为正整数，$kx≤n$）都加上$y$。"

根据数据范围可知,直接操作肯定是不行的(当x都等于1,设操作1进行$m_1$次,时间复杂度$O(nm_1)$,当场爆炸),我们再观察$a[kx]$ ($k$为正整数),发现要加上$y$的数的下标都是$x$的[倍数](https://baike.baidu.com/item/%E5%80%8D%E6%95%B0/7827981?fr=aladdin),所以我们可以存$y$于数组$bf[x]$中,等一下操作2但凡是x的倍数都加上$bf[x]$(相当于$y$).

### 二.看操作二

"输入格式“$2 ~j$”，表示输出$a[j]$"

操作二就是输入下标$j$然后输出$a[j]$,根据前面所述,这里的$a[j]$还是一开始输入的值,并没有通过操作1加过$y$,因此我们在现在加
(因为要保证$a[j]$还是一开始输入的值,所以这里只要定义一个变量$num$,初始值为$a[j]$,然后再用$num$加就可以了)
,前面已经存了bf数组,我们现在要找出数组中$j$为其倍数的下标,首先肯定不能从1找到$j$(时间复杂度爆炸),根据倍数的定义,我们知道"$x$如果是$y$的倍数,那么$y$是$x$的[因数](https://baike.baidu.com/item/%E5%9B%A0%E6%95%B0)",所以我们只要找出$j$的每个因数(设第i个为$j_i$),然后将$num$加上$bf[j_i]$就可以了

### 三.关于求因数

可能第一反应是预处理因数(也就是先算出来存好,然后再用),但是由于数据范围,会爆空间(如果存入数组yin[n][n的第i个因数],[计算](https://blog.csdn.net/qq_21208843/article/details/70173777)可得其远远超出内存限制),因此我们只能进行操作二时求因数就可以了,我们知道如果$a$是数$b$的因数,那么$\frac{b}{a}$也是$b$的因数($b$除以$\frac{b}{a}$等于$a$(正整数)),所以当我们求出一个因数时,也求出了另一个因数,那么我们就可以只找一半因数,我们发现当$a<\sqrt{b}$时$\frac{b}{a}>a$($∵a>0,b>0∴a<\sqrt{b}∴a^2<b∴a<\frac{b}{a}$),同理当$a=\sqrt{b}$时$\frac{b}{a}=a$,当$a>\sqrt{b}$时$\frac{b}{a}>a$,由此我们发现两半因数都关于$\sqrt{b}$对称分布(一个小于$\sqrt{b}$的数都可以推出一个大于$\sqrt{b}$的数,一个等于$\sqrt{b}$的数推出等于$\sqrt{b}$(程序中要舍去),所以对称),所以我们只要找所有小于等于$\sqrt{b}$的因数,因此只要循环$\sqrt{b}$次,因为操作2的的次数为$m$,所以时间复杂度是$O(m\sqrt{j})$(这里求$j$的因数),最大为100000*1000刚好为一亿(且一般达不到),可以ac

#### 小结:先初始化$num$为$a[j]$,循环$i$从1到$\sqrt{j}$,发现是因数(即j%i==0)后,求出另一个因数$\frac{j}{i}$(如果$\frac{j}{i}=i$要舍去(即后面只要加一次)),然后$num$加上$bf[i]$和$bf[\frac{j}{i}]$,循环完后输出$num$

## 上代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1000001;
int bf[N],n,m,a[N];//变量意义上面有提到
int main()
{
    cin>>n>>m;
    for(int p=1;p<=n;p++) scanf("%d",&a[p]);//输入
    for(int p=1;p<=m;p++)
    {
        int x,y,opt,j;
        scanf("%d",&opt);//输入'1'或'2'
        if(opt==1)//操作1
        {
            scanf("%d%d",&x,&y);//输入
            bf[x]+=y;//见上文一部分
        }
        else//操作2
        {
            scanf("%d",&j);//输入
            int num=a[j];//为了不影响a[x]的
            for(int i=1;i<=sqrt(j)/*可换为i*i<=j,更高效*/;i++)//见二三部分
            {
                if(j%i==0)//是因数
                {
                    num+=bf[i];//见二部分
                    if(i!=(j/i))/*如果相等要舍去*/num+=bf[j/i];
                }
            }
            printf("%d\n",num);//输出
        }
    }
    return 0;
}
```
