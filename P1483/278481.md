首先看到这道题就是一股浓浓的线段树的味道,但是当你卖力打出线段树然后自信满满交上去的时候你就会发现事情并不是那么简单，所以我们再思考一下其它的做法。很容易就可以想到，如果一个数以及他的倍数永远不会被查询的话，那我们的操作1干了也是白干，所以我们可以直接先把操作1存起来，当询问的数需要用到时再直接加起来，而再看数据范围，保证数小于1e6,可以直接用数组下标装下，所以我们此时只需要等到询问到一个数时，用他本身就有的值再加上他应该加的就是他现在的值了，而如何加上他应该加的值呢？只需要把他所有的约数的操作1加上的数加到他的身上就可以了，而我们还可以得到如果x是n的约数，那么n/x也一定是n的约数，所以我们在枚举约数时只需要枚举到$\sqrt{n}$即可，注意特判一下$x=\sqrt{n}$的情况，只需要加一个即可。以下是代码。

```cpp
#include<iostream>
using namespace std;
int a[10000000];
int sum[1000000];
int p;
int r1;
int r2;
int r;
int main()
{
	int n,m;
	cin>>n>>m;
	for(int i=1;i<=n;i++)
	{
		cin>>a[i];
	}
	int cnt=0;
	for(int i=1;i<=m;i++)
	{
		cin>>p;
		if(p==1)
		{
			cin>>r1>>r2;
			sum[r1]+=r2;//操作1累加
		}
		else if(p==2)
		{
			cin>>r;
			int ans=a[r];//初始值为原始的值
			for(int i=1;i*i<=r;i++)
			{
				if(r%i==0)
				{
					ans+=sum[i];//加上约数的累计的加数
					if(i*i!=r)//特判
						ans+=sum[r/i];//加上该约数对应的另外一个约数的累计的加数
				}
			}
			cout<<ans<<endl;
		}
	}
	return 0;
}
```
