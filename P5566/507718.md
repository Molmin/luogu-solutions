# [SDOI2008] 红黑树

## DP解法

设 $f[i,j,0/1]$ 表示在有 $i$ 个节点，黑高度为 $j$ ，当前树是红/黑根树的最小值(最大值同理)

则有：

$$f[i,j,0]=\min_{1\le k<i-1}\min_{1\le j \le 2\log_2 n}(f[i-k-1,j,1]+f[k,j,1])+1$$

$$f[i,j,1]=\min_{1\le k<i-1}\min_{1\le j \le 2\log_2 n}(f[i-k-1,j-1,0/1]+f[k,j-1,0/1])$$

最大值同理，只是将 $\min$ 换为 $\max$
说明：对于黑高度的限制可以自行百度红黑树的性质，这个复杂度是$O(n^2\log_2n)$,可以过
## 贪心解法

**引理1**：任意含有 $n$ 个节点的树必定含有 $n+1$ 个前端节点

*证明*  首先若树是一条链显然成立。我们考虑将这个树在某个节点处旋转过来，也即将链中某个节点作为新的节点，两边的链作为儿子节点，此时这个节点原来有的一个前端节点没了，但是旋转前链顶在旋转后便拥有了2个前端节点，以此类推归纳可证
![](https://cdn.luogu.com.cn/upload/image_hosting/q7ssdep4.png)


我们可以看作用 $n+1$ 个节点，两两合并成新的节点并拼在一起，最终合并出根节点，此时就启发我们探索合并过程中所产生的红节点的最少与最多的策略了

因为节点两两合并，我们考虑将黑点的合并抽象出来，考虑黑点合并的基本模型

1. 两两合并成一黑
2. 三个合并成一红两黑
3. 四个合并成两红一黑
![](https://cdn.luogu.com.cn/upload/image_hosting/xir45snb.png)

因为这三种情况包括了黑点产生和红点产生的所有情况(黑高相同且扩展1)，所以说我们只需要这三种情况就可以拼出其他情况（因为红黑树的性质4，会导致最底层一定是这三种之一，层层上推即可得证）

那么分析一下，很明显情况3用来求最大值，情况1用来求最小值
### 最小值
需要注意的是，为了黑高度的合法，我们必须一层一层的往上构造
那么先说求最小值，我们可以先用黑点数量除以二就等同于整体向上用情况1构造一层，前提条件是黑点数量是偶数，当黑点数量是奇数的时候，先拿出两个合并成一个红点，因为这样不会影响黑高，并且会使得点的数量重新变为偶数，再除以2，直到黑点数量为1

通过这个想法，我们可以进行优化，会发现，我们实际上的红点个数就是在不断除以二的过程中除到奇数的情况(1除外)，所以一个节点数量为$n$的红黑树，它的最小红节点数量就是$n+1$在2进制状态下1的个数减1
### 最大值
然后再来看最大值，想想，最优策略应该是什么，应该是一层层的用4个节点往上构造2层，不够4个节点的，如果只有1个，需要拿出1个4，构成"2+3"。否则就是"3"/"2"

那么此时我们应该对黑节点数量的情况分类讨论，假设现在有$k$个黑节点数量

1. $k\bmod 4 \equiv 0$ ，此时我们选择整体向上构造两层，那么答案累加上 $\frac{k}{2}$，黑点数量变为 $\frac{k}{4}$
2. $k\bmod 4 \equiv 1$ ，此时我们选择构成“2+3”此时答案应该是累加上： $\frac{k-3}{2}$,此时 $k$ 变成 $\frac{k-5}{4}+2=\frac{k+3}{4}$
3. $k\bmod 4 \equiv 2$ ，此时我们选择构造"2"，答案应该是累加上 $\frac{k-2}{2}$，然后 $k$ 变为 $\frac{k-2}{4}+1=\frac{k+2}{4}$
4. $k\bmod 4 \equiv 3$ ，此时我们选择构造"3"，答案应该是累加上 $\frac{k-3}{2}+1=\frac{k-1}{2}$ ，然后 $k$ 变成 $\frac{k-3}{4}+1=\frac{k+1}{4}$


特别的，当 $k=2$ 时，直接令 $k=1$ ,答案加上1，因为两黑自动合成红

一些在操作过程中可能比较迷惑的地方
1. 随时，我们留下的 $k$ 个点都是黑点，红点是我们选择以上三种基本构造模型的时候搞出来的

2. 我们合并过程中并不是强制要求剩下的 $k$ 个点一定在同一深度

3. 可能有人会说，如果我们把 $k\bmod 4 \equiv 1$ 的情况那个1直接不动会更好，因为它在同样贡献的情况下还多出来了黑色节点，这个错误的原因是我们必须使用上面三个模型进行合并，否则黑高有问题，导致这棵树建立出来有问题

注意：**代码中/2,/4必须使用">>"不能用除号**，原因是二者运算机制的区别，用/的只有60分
下面贴上代码

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int k,n,mn,mx;
int main(){
	scanf("%d",&n);
	k=n+1;
	while(k>1){
		if(k&1)mn++;
		k>>=1;
	}
	k=n+1;
	while(k>1){
		if(k==2)mx++,k--;
		else if(k%4==0){
			mx+=k>>1;
			k>>=2;
		}
		else if(k%4==1){
			mx+=(k-3)>>1;
			k=(k+3)>>2;
		}
		else if(k%4==2){
			mx+=(k-2)>>1;
			k=(k+2)>>2;
		}
		else {
			mx+=(k-1)>>1;
			k=(k+1)>>2;
		}
	}
	printf("%d\n%d",mn,mx);
}
```