题目简述
 
舞会上有 $N$ 个男孩和 $N$ 个女孩，我们知道他们的身高。规定每个人最多只能和一个舞伴跳舞。

每个男孩要么想和比他高的女孩跳舞，要么想和比他矮的女孩跳舞。类似地，每个女孩要么想和比她高的男孩跳舞，要么想和比她矮的男孩跳舞。没有同样高的男孩和女孩想和对方跳舞。

### 怎样贪心

既然规定要么和比他矮的人跳舞，要么和比他高的人跳舞
那么我们可以想到：如果一个人想跟比他矮的人跳舞，那么能和他跳舞的人一定想和比他高的人跳舞。反之，如果一个人想跟比他高的人跳舞，那么能和他跳舞的人一定想和比他矮的人跳舞。

所以我们可以将男生中想和比他高的人跳舞的人与女生中想和比他矮的人跳舞的人分为一个整体。

再将女生中想和比他高的人跳舞的人与男生中想和比他矮的人跳舞的人分为一个整体。

但我们发现 $1≤N≤100000$ 如果直接暴枚会超时，所以我想到~~想了好久~~：可以先将统计出来的四类数全部排序，然后比如：

男生中想和比他高的人跳舞 $a_i$ $1800$ $1500$ $1300$。

女生中想和比他矮的人跳舞 $b_i$ $1900$ $1600$ $1200$。

排完序男生 $1300$ $1500$ $1800$。

排完序女生 $1200$ $1600$ $1900$。

再定一个变量$x=1$，与一个$y=1$ 。

如果$b_x$大于$a_y$则可以跳舞$ans$++ $x$++ $y$++。

否则$y$++，因为排过序，$a_{x+1}$绝对比$a_x$大，所以可以节省不少时间。

 

### 代码

 首先将各类人分开:
``` cpp
    cin>>n;
    for(int i=1; i<=n; i++){
        scanf("%d",&s);
    if(s<0)nx[++d]=abs(s);
        else nd[++d2]=s;}
    sort(nx+1,nx+1+d);
    sort(nd+1,nd+1+d2);
    for(int i=1; i<=n; i++){
        scanf("%d",&s);
    if(s<0)ux[++d3]=abs(s);
	else ud[++d4]=s;}
    sort(ux+1,ux+1+d3);
    sort(ud+1,ud+1+d4);
```
再判断:
```cpp
    x=1,y=1;
    while(x<=d&&y<=d4)
    {
	if(nx[x]>ud[y])ans++,x++,y++;
	else x++;
    }
    x=1,y=1;
    while(x<=d3&&y<=d2)
    {
	if(ux[x]>nd[y])ans++,x++,y++;
	else x++;
    }
```
合起来程序为:
```cpp
#include<bits/stdc++.h>

using namespace std;

int n,nd[100005],nx[100005],ud[100005],ux[100005];

int s,d,d2,x,y,d3,d4,ans;

int main()
{

    cin>>n;
    for(int i=1; i<=n; i++){
        scanf("%d",&s);
    if(s<0)nx[++d]=abs(s);
        else nd[++d2]=s;}
    sort(nx+1,nx+1+d);
    sort(nd+1,nd+1+d2);
    for(int i=1; i<=n; i++){
        scanf("%d",&s);
    if(s<0)ux[++d3]=abs(s);
	else ud[++d4]=s;}
    sort(ux+1,ux+1+d3);
    sort(ud+1,ud+1+d4);
    x=1,y=1;
    while(x<=d&&y<=d4)
    {
        if(nx[x]>ud[y])ans++,x++,y++;
	else x++;
    }
    x=1,y=1;
    while(x<=d3&&y<=d2)
    {
        if(ux[x]>nd[y])ans++,x++,y++;
        else x++;
    }
    cout<<ans;
    return 0;
}
```


 

