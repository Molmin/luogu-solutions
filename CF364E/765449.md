# CF364E Empty Rectangles 题解

前往[博客](https://www.luogu.com.cn/blog/wwwjy4612code/solution-cf364e)食用效果更佳。

------------


## 二维分治


------------


### 题目大意 
- 给定一个 $n \times m$ 的 $01$ 矩阵和一个数 $k$，求出有多少个子矩阵中含有 $k$ 个 $1$。

- $ n,m \le 2500$，$0 \le k \le 6$。

### 题意分析

- 显然地，我们不能直接枚举，要不然直接 T 得见祖宗。

- 尝试着想一想能不能把给定矩阵分成两部分，分别把两部分求出来，再放在一起统计。

- 很显然应该是可以的，而且我们容易得到：

	> > __当前矩阵答案 $=$ 两个矩阵答案之和 $+$ 跨越两个矩阵分界线的答案。__
    
    也就是，我们不仅要统计拆出来的独立矩阵的答案，还要统计介于两个矩阵之间的也满足题意的矩阵（也就是一条边在分界线上（左）边，一条边在分界线下（右）边的满足题意的矩阵），把两部分加起来就是拆之前的矩阵的答案。很明显可以用分治递归了。
    
- 接下来考虑各个部分都怎么求出来。

- 独立矩阵很好说，不难想到直接在递归边界情况下统计即可。

- 考虑怎样统计跨越分界线的满足题意的矩阵个数。

	直接枚举肯定还是不行。
    
   这个时候我们可以自己画画图看看：
   
   （该图及以下的推导过程都是把原矩阵分成上下两个矩阵的说明，分成左右两个矩阵其实同理。）
   
   ![1](https://cdn.luogu.com.cn/upload/image_hosting/lmfg8xwd.png)
   
   图中的紫线及其名称先不用管，这个我们待会儿说。
   
   我们分析一下图中矩阵的构成：
   
   > 黄色矩阵 $=$ 黄色上边界到分界线的矩阵（$4$ 个 $1$） $+$ 分界线到黄色下边界的矩阵（$0$ 个 $1$）；
   
   > 绿色矩阵 $=$ 绿色上边界到分界线的矩阵（$3$ 个 $1$） $+$ 分界线到绿色下边界的矩阵（$1$ 个 $1$）；
   
   > 蓝色矩阵 $=$ 蓝色上边界到分界线的矩阵（$2$ 个 $1$） $+$ 分界线到蓝色下边界的矩阵（$2$ 个 $1$）。
   
   好像有点儿规律对吧，把它们综合起来，我们发现，紫线为左右界这一条中：
   
   > > __满足有 $k$ 个 $1$ 的矩阵 $=$ 上边界到分界线的有 $i$ 个 $1$ 的矩阵 $+$ 边界线到下边界的有 $k - i$ 个 $1$ 的矩阵，$i \in [0,k]$。__

   现在我们说一下这个紫线是什么。
   
   这玩意其实就是左右边界线（在上图中），两条紫线均可以通过枚举实现，这也就是为啥叫 $y_{i}$ 和 $y_{j}$ 的原因。
   
   像这样（我放一个伪代码）：
   
   ```cpp
	for(int i = y1; i < y2; ++ i)//枚举左分界线
		for(int j = i + 1; j <= y2; ++ j)//枚举右分界线
        ......
	```
	大概就是这样枚举，能枚举到所有位置的左右分界线。
    
    这个时候上面满足 $k$ 个 $1$ 矩阵的求解公式中，就差怎样求出上边界到分界线（以及分界线到下边界）的含有 $i$ 个 $1$ 的矩阵个数了。
    
    我们可以考虑维护一个 $up[0/1][k]$ 数组，$up[0][k]$ 用来存当前左右分界线确定的情况下，从上边界到分界线所围成的矩阵中 $1$ 的个数 $< k$ 的条件下，上边界坐标（$x_{?}$，下同）的最大值，$up[1][k]$ 用来存当前左右分界线确定的情况下，分界线到下边界所围成的矩阵中 $1$ 的个数 $< k$ 的条件下，下边界坐标的最小值。
    
    这样的话，求出上面的问题实际上只需要一个小小的差分了：
   
    > > __上边界到分界线含有 $i$ 个 $1$ 的矩阵个数 $= up[0][i] - up[0][i + 1].$__
    
    > > __分界线到下边界含有 $i$ 个 $1$ 的矩阵个数 $= up[1][i + 1] - up[1][i].$__

    这一步非常关键，看不懂的同学可以自己动手写写。
    
    ~~好了，你大抵是懂了罢~~，那么我们继续。
    
    如何维护这个 $up$ 数组呢？
    
    具体的方法应该是先把 $up[0]$ 的每一个数赋成上边界坐标，把 $up[1]$ 的每一个数赋成下边界坐标，然后根据 $up$ 数组的定义求解即可。
    
    我们当然可以在每一个 $i,j$ 循环中写出这样的代码：
    
    ```cpp
	for(int k = 1; k <= K + 1; ++ k) up[0][k] = x1, up[1][k] = x2;
    //由上面的差分推导公式我们可以看出只枚举到 k 是不够的，需要多枚举 1
	for(int k = 1; k <= K + 1; ++ k)
	{
    //下面的 Sum 函数就是前缀和求出当前矩阵中 1 的个数
		while(Sum(up[0][k], i, mid, j) >= k) ++ up[0][k];
		while(Sum(mid, i, up[1][k], j) >= k) -- up[1][k];
	}
	 ```
    请相信我，这样写的话，你还会 T 得见祖宗。这样写常数大得离谱。
    
    我们需要考虑一下优化这种写法。
    
    以 $up[0]$ 为例，我们把左右边界线分别枚举到 $y_{i},y_{j}(y_{i} < y_{j})$ 时，上边界到分界线围成矩阵中 $1$ 的个数 $< k$ 的条件下，上边界坐标最大值写作 $up_{i,j}[0][k]$，当 枚举的 $y_{j}$ 变为 $y_{j+1}$，因为左边界不变右边界右移，我们围成的矩阵面积肯定会变大，多出的面积中可能会有 $1$ 也可能没有。如果没有 $1$，那么 $up_{i,j}[0][k] = up_{i,j + 1}[0][k]$；如果有 $1$ 的话，那么一定会有 $up_{i,j}[0][k] \le up_{i,j + 1}[0][k]$。综合两种情况，我们得到了无论什么情况，一定有 $up_{i,j}[0][k] \le up_{i,j + 1}[0][k]$，也就是其具有单调不下降性。同理可证，$up[1]$ 则具有单调不上升性。
    
    知道这个之后，我们实际上就可以在原有 $up_{i,j}[0/1][k]$ 的基础上对 $up_{i,j + 1}[0/1][k]$ 进行更新，这样可以快很多。
    
    于是代码就变成了这样：
    
    ```cpp
	for(int i = y1; i < y2; ++ i)
	{
		up[0][0] = up[1][0] = mid;
		for(int k = 1; k <= K + 1; ++ k) up[0][k] = x1, up[1][k] = x2;
		for(int j = i + 1; j <= y2; ++ j)
		{
			for(int k = 1; k <= K + 1; ++ k)
			{
				while(Sum(up[0][k], i, mid, j) >= k) ++ up[0][k];
				while(Sum(mid, i, up[1][k], j) >= k) -- up[1][k];
			}
			......
		}
	}
	```
	这样就好啦。
   
   最后，对于每条左右分界线，我们在双重循环的最后用上面的差分推导公式求解即可：
   
   ```cpp
	for(int k = 0; k <= K; ++ k)
		ans += 1ll * (up[0][k] - up[0][k + 1]) * (up[1][K - k + 1] - up[1][K - k]);
	```
- 那么这个题到这里就已经快结束了。

	跑下来时间复杂度为 $O(knm \log n)$。

	接下来我们只需要写出二维分治的函数就行啦。
    
    关于二维分治，我们可以有两种写法都可以：
    
    一种是水平分割和竖直分割交替，还有一种就是按照判断待分矩阵的边长的关系来分（这种当然是将长边分成两个短边）。
    
    感觉两种情况都差不多吧。
    
- 下面我把两种写法的代码放在下面：

	1. 水平竖直交替分治
    
	```cpp
	#include<cstdio>
	using namespace std;
	const int N = 2510;
	int n, m, K, s[N][N], up[2][10]; long long ans;
	int Sum(int x1, int y1, int x2, int y2) { return s[x2][y2] - s[x2][y1] - s[x1][y2] + s[x1][y1]; }
	void work(int x1, int y1, int x2, int y2, int f)
	{
		if(x1 == x2 || y1 == y2) return;
		if(x1 + 1 == x2 && y1 + 1 == y2) return (void) (ans += Sum(x1, y1, x2, y2) == K);
		if(f == 1)
		{
			int mid = (x1 + x2) >> 1;
			work(x1, y1, mid, y2, 0);
			work(mid, y1, x2, y2, 0);
			for(int i = y1; i < y2; ++ i)
			{
				up[0][0] = up[1][0] = mid;
				for(int k = 1; k <= K + 1; ++ k) up[0][k] = x1, up[1][k] = x2;
				for(int j = i + 1; j <= y2; ++ j)
				{
					for(int k = 1; k <= K + 1; ++ k)
					{
						while(Sum(up[0][k], i, mid, j) >= k) ++ up[0][k];
						while(Sum(mid, i, up[1][k], j) >= k) -- up[1][k];
					}
					for(int k = 0; k <= K; ++ k)
						ans += 1ll * (up[0][k] - up[0][k + 1]) * (up[1][K - k + 1] - up[1][K - k]);
				}
			}
		}
		else 
		{
			int mid = (y1 + y2) >> 1;
			work(x1, y1, x2, mid, 1);
			work(x1, mid, x2, y2, 1);
			for(int i = x1; i < x2; ++ i)
			{
				up[0][0] = up[1][0] = mid;
				for(int k = 1; k <= K + 1; ++ k) up[0][k] = y1, up[1][k] = y2;
				for(int j = i + 1; j <= x2; ++ j)
				{
					for(int k = 1; k <= K + 1; ++ k)
					{
						while(Sum(i, up[0][k], j, mid) >= k) ++ up[0][k];
						while(Sum(i, mid, j, up[1][k]) >= k) -- up[1][k];
				}
					for(int k = 0; k <= K; ++ k)
						ans += 1ll * (up[0][k] - up[0][k + 1]) * (up[1][K - k + 1] - up[1][K - k]);
				}
			}
		}
	}
	int main()
	{
		scanf("%d%d%d", &n, &m, &K);
		for(int i = 1; i <= n; ++ i)
			for(int j = 1; j <= m; ++ j) 
				scanf("%1d", &s[i][j]), s[i][j] +=s[i][j - 1] + s[i - 1][j] - s[i - 1][j - 1];
		work(0, 0, n, m, 0);
		printf("%I64d\n", ans);
		return 0;
	}
	```
	2. 按边长分治
    
    ```cpp
    #include<cstdio>
	using namespace std;
	const int N = 2510;
	int n, m, K, s[N][N], up[2][10]; long long ans;
	int Sum(int x1, int y1, int x2, int y2) { return s[x2][y2] - s[x2][y1] - s[x1][y2] + s[x1][y1]; }
	void work(int x1, int y1, int x2, int y2)
	{
		if(x1 == x2 || y1 == y2) return;
		if(x1 + 1 == x2 && y1 + 1 == y2) return (void) (ans += Sum(x1, y1, x2, y2) == K);
		if(y2 - y1 < x2 - x1)
		{
			int mid = (x1 + x2) >> 1;
			work(x1, y1, mid, y2);
			work(mid, y1, x2, y2);
			for(int i = y1; i < y2; ++ i)
			{
				up[0][0] = up[1][0] = mid;
				for(int k = 1; k <= K + 1; ++ k) up[0][k] = x1, up[1][k] = x2;
				for(int j = i + 1; j <= y2; ++ j)
				{
					for(int k = 1; k <= K + 1; ++ k)
					{
						while(Sum(up[0][k], i, mid, j) >= k) ++ up[0][k];
						while(Sum(mid, i, up[1][k], j) >= k) -- up[1][k];
					}
					for(int k = 0; k <= K; ++ k)
						ans += 1ll * (up[0][k] - up[0][k + 1]) * (up[1][K - k + 1] - up[1][K - k]);
				}
			}
		}
		else 
		{
			int mid = (y1 + y2) >> 1;
			work(x1, y1, x2, mid);
			work(x1, mid, x2, y2);
			for(int i = x1; i < x2; ++ i)
			{
				up[0][0] = up[1][0] = mid;
				for(int k = 1; k <= K + 1; ++ k) up[0][k] = y1, up[1][k] = y2;
				for(int j = i + 1; j <= x2; ++ j)
				{
					for(int k = 1; k <= K + 1; ++ k)
					{
						while(Sum(i, up[0][k], j, mid) >= k) ++ up[0][k];
						while(Sum(i, mid, j, up[1][k]) >= k) -- up[1][k];
				}
					for(int k = 0; k <= K; ++ k)
						ans += 1ll * (up[0][k] - up[0][k + 1]) * (up[1][K - k + 1] - up[1][K - k]);
				}
			}
		}
	}
	int main()
	{
		scanf("%d%d%d", &n, &m, &K);
		for(int i = 1; i <= n; ++ i)
			for(int j = 1; j <= m; ++ j) 
				scanf("%1d", &s[i][j]), s[i][j] +=s[i][j - 1] + s[i - 1][j] - s[i - 1][j - 1];//输入使用 char 并关掉流同步感觉会更快，但我懒得写了 QaQ
		work(0, 0, n, m);
		printf("%I64d\n", ans);
		return 0;
	}
	```
	注意上面的代码我在写分治递归函数的时候把实际的 $x_{1},y_{1}$ 写成了 $x_{1} - 1,y_{1} - 1$ 的形式，这么写感觉递归边界的时候比较好处理，代码也比较好写。
    
 这样这个黑题我们就可以拿下啦。
    
**完结撒花~**