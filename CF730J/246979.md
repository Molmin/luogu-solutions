**题意概述**

- $n$ 个瓶子，第 $i$ 个瓶子原有水 $a_i$，容量为 $b_i$；
- 倒 $1$ 单位水需要花 $1$ 单位时间，求用最少的瓶子装下所有水的瓶子个数 $x$，以及将所有水倒入 $x$ 个瓶中所花的最小时间；
- $1\leq n\leq 100$

**问题转化与解决**

第一问很简单罢，给所有的瓶子排序，然后从大到小选就行了。

考虑第二问。比较显然的是求倒水时间就是求倒水的量。而总的水量是不变的，所以最小化倒的水量就是最大化不倒的水量。

略加思考可以想到，不倒的水量就是最重要倒入的那 $x$ 个瓶子原本就有的水量。因此问题就转化为了 _选取 $x$ 个瓶子，需要使瓶子原有的水最多，同时满足这些瓶子容量总和大于总水量_ 。

这就是一个裸的 $01$ 背包了。因为我们关心选取的瓶子个数，一次你增加一维 $k$ 来表示。定义 $f[i][j][k]$ 表示前 $i$ 个瓶子中，总容量为 $j$，选取 $k$ 个瓶子的最大原有水量。转移方程

$$
f[i][j][k]=\max(f[i-1][j][k],f[i-1][j-b_i][k-1]+a_i)
$$

然后按照 $01$ 背包的惯常方法倒序循环，去掉 $i$ 这维。边界条件 $f[0][0]=0$。

```cpp
f[0][0]=0;
for(int i=1;i<=n;i++)
	for(int j=s2;j>=c[i].b;j--)
		for(int k=tot;k>0;k--)
			f[j][k]=max(f[j][k],f[j-c[i].b][k-1]+c[i].a);
```

最终我们的目标状态是能够装下所有水并且瓶子数为 $x$ 的方案中最大的不移动水量。设总水量为 $V_w$，容量前 $x$ 大的瓶子容量和 $V_b$，则目标状态即 $\min\limits_{V_w\leq k\leq V_b}\big\{f[k][x]\big\}$。

记 $ans$ 为上面得出的最打原有水量，则最终答案为 $V_w-ans$。

这样我们这题就做完了。