这道题由于数据较小，可用冒泡排序做出来

这里介绍一种数据较大时的解法

##归并排序

其思想就是把一段数分成两段，把分好的接着分，，，分到不能分，

然后把分的两段合并，

**由于两段是有序的**，所以我们可以只要用两个指针指向两段开头，然后比较指针指向的数字，

如果要从大到小排序，就比较两个变量，大的放在新开数组里，同时指针往后指。如果指完了，就把没指完的那一段

全部放在数组后面，最后把排好的数组赋值给原数组即可。


对于这道题，因为要求逆序对，在排序时只要加一句就行：


如果数列右端的放入新数组，计数器加上左边剩余数字个数


假设有数组 1 5 3 6 4 2从大到小排序，分治后会得到 1 3 5   2 4 6 两段


首先，比较 1 2，1放入新数组，由于1在左边，所以没有逆序对


然后，比较 3 2，2放入新数组，但由于2在右边，所以产生了逆序对，数量为 左边剩余数字个数（**因为数字排列好了，这个数和最小的数都是逆序对，那和后面的大数也会构成逆序对**）


，，，


最后得到有序的数组


代码如下


```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
#include<algorithm>
using namespace std;
long long n,a[200010],rr[200010];
unsigned long long ans;
void jj(int l,int r)   //归并过程 l,r为当前处理的数字段的左右边界
{
    if(l==r) return;  //如果只有一个数就不要排序
    int x=(l+r)/2;   //去中间的下标
    jj(l,x);
    jj(x+1,r);   //分成左右两段排序
    int t1=l,t2=x+1,xx=0;  //t1 左数组下标 t2 右数组下标 xx 新数组下标
    while(t1<=x&&t2<=r)  //排序，直到某个指针到达边界
       {
        if(a[t1]<=a[t2]) //如果左端小于等于右段
           {
            xx++;
            rr[xx]=a[t1];  //插入新数组，下标移动，没有产生逆序对
            t1++;
        }
        else  //否则
        {
            xx++;
            rr[xx]=a[t2];
            t2++;   //插入新数组，下标移动
            ans+=x-t1+1;  //产生了逆序对，计数器加上左边剩余数字个数
        }
    }
    while(t1<=x) //如果左边有数字没排进去，就放进去
    {
        xx++;
        rr[xx]=a[t1];
        t1++;
    }
    while(t2<=r) //右边同理
    {
        xx++;
        rr[xx]=a[t2];
        t2++;
    }
    for(int i=1;i<=xx;i++) a[l+i-1]=rr[i]; //把原数组覆盖为新数组
}
int main()
{
    cin>>n;
    for(int i=1;i<=n;i++) scanf("%lld",&a[i]);
    jj(1,n); //左右边界1，数组数字个数
    cout<<ans; //输出逆序对个数
    return 0;
}
```

此题为P1980的数据缩小版
