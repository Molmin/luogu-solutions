居然在我之前所有的题解都是 $O(n^3)!$ ，那么由我来补充一个 $O(n^2)$ 的算法吧、

之前所有题解的思路都是：
- 暴力枚举起点、终点
- 暴力的 $\text{check}$ 一遍枚举出来的子序列是否合法。

那么究竟暴力算法的“效率低”是怎么造成的呢？

我们来模拟一下样例 $3$

在你程序中，你计算了一下两个子序列：

- `RL`（1~2个字符） 此时 $R$ 有 $1$ 个，$L$ 有 $1$ 个，$U/D$ 都是 $0$ 个。
- `RLRLRL` （1~6个字符），你会发现你的程序重复计算了1~2个字符 $R/L/U/D$ 的个数！

那怎么解决这个重复计算呢？我们考虑边枚举终点边加，算法流程如下：
- 暴力枚举起点，并开启 $4$ 个计数器，分别来计算 $R/L/U/D$ 的个数。
- 开始枚举终点，更新计数器，若 $R/L/U/D$ 个数都为 $0$ ，则答案加一。

我们发现我们不用暴力 $\text{check}$ 了！于是，成功从 $O(n^3)$ 优化到 $O(n^2)$.

下是程序：
```
for(int i=1;i<=n-1;i++){//起点
    int Su=0,Sd=0,Sl=0,Sr=0;//开计数器
    for(int j=i;j<=n;j++){//终点
        if(str[j]=='U') Su++;
        if(str[j]=='D') Sd++;
        if(str[j]=='L') Sl++;
        if(str[j]=='R') Sr++;
        if(Su==Sd && Sl==Sr) ans++;//满足条件
    }
}
```