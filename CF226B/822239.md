为什么现在的题解都要建树啊，不懂诶，哭哭。

所以就有了这样一篇浅显易懂的题解 qwq。

初见这道题，想过用 DP 搞一搞，但是后来发现，可以用贪心诶！要求在对于每一对石子有一定的合并次数限制下，合并若干堆石子的最小花费。

考虑对于每一组石子 的大小 $a_i$，在满足移动次数不超过 $k$ 次的前提下，我们应该尽量让石子堆大小小小的移动次数更多，让石子堆大小大的移动次数更少；还有一个比较好想的贪心策略，对于其中的一个石子堆，我们应该尽量让当前状态下，石子堆大小比较大的尽量不移动，而是让石子堆大小更小的石子堆向大石子堆移动。

模拟一下移动的过程，我们先从一种最简单的情况入手：$k=1$，显然每一堆石子都只能合并一次，于是显然我们只需要让第一堆石子不断按序向后合并，这样我们就可以得到一个最优解了。

对于 $k$ 次移动，我们先对石子堆排序，由于前面提到的贪心策略，肯定是要让所有石子堆都合并到最后一大堆最优。我们考虑先把排好序的第 $n-1$ 堆到第 $n-k$ 堆进行进行移动，因为越往后移动的石子堆合并所需要的移动次数显然更多，所以让大小大的先移动，可以知道每一堆需要移动 $1$ 次，第 $n-k-1$ 堆到第 $n-k^2-1$ 堆移动 $2$ 次，不断进行这个过程直到合并成一堆即可。为什么？考虑对于石子堆，它可以合并的次数增加了，那么每一次被合并的堆数显然也在增加。试一试 $k=2$ 和 $k=3$ 的情况，发现 $k=2$ 时每一次可以合并两堆，即两堆、四堆、八堆……；$k=3$ 同理。以此类推，对于 $k$ 的情况，每次合并产生的贡献就是 $k$，对于某一堆石子上面我们可以合并 $k$ 个，而这 $k$ 个又可以由 $k$ 次合并推来。

对于计算每一次合并的代价，我们可以考虑用前缀和维护。为了防止超时，我们可以先预处理一下 $k=1$ 的解。

代码如下：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long

const int maxn=1e5+5;
int a[maxn],sum[maxn];

signed main()
{
	ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
	int n;cin>>n;
	int ans1=0;
	for(int i=1;i<=n;i++) cin>>a[i];
	sort(a+1,a+n+1);
	sum[0]=0;
	for(int i=1;i<=n;i++)
	{
		sum[i]=sum[i-1]+a[i];
		if(i!=n) ans1+=sum[i];
	}
	int q;cin>>q;
	while(q--)
	{
		int k;cin>>k;
		if(k==1) {cout<<ans1<<' ';continue;}
		int ans=0,kk=k,nn=n-1,cnt=1;
		while(nn>=kk)
		{
			ans+=(sum[nn]-sum[nn-kk])*cnt;
			nn-=kk,kk*=k,cnt++;
		}
		ans+=sum[nn]*cnt;
		cout<<ans<<' ';
	}
	return 0;
}
```

[通过记录](https://codeforces.com/contest/226/submission/197060491)