这道题虽然是 nim游戏 的改版，但它比 nim游戏 简单多了，我们知道第一位选手必须要尽可能地获得主动权，所以每堆石子它必须要取到就剩 $1$ 颗或一颗不剩（这是每堆石子最终的情况）。如果他取到就剩 $1$ 颗，那么下一堆石子的主动权还在他手中，如果一颗不剩，那么主动权就要转赠给第二位选手。但是有一种特殊的情况，如果一堆石子只有 $1$ 颗的话，主动权一定会被改变。如果这堆石子前面有堆石子多于 $1$ 颗的话，那么第一位选手还可以通过改变主动权来应对接下来的这堆石子。但如果这堆石子恰好前面没有一堆石子多于 $1$ 颗的话。那么第一位选手就无法改变主动权了。只能到一堆多于 $1$ 颗的石子才能改变，但如果前面多堆数量均为 $1$ 的石子全部取完且主动权在第一位选手手中，那么接下来他就有必胜策略，因为在下一堆种它有两种取石子的方式，这些方式都会影响主动权在谁手中且影响的结果不同，而它只要保证最后一堆石子主动权在他手中就行。（后面有若干堆连续的且只有一颗的石子也不要紧，只要在若干堆石子之前改变主动权使得若干堆石子取完之后主动权还在他手中就可以），所以第一位选手一定有必胜策略。反之，就是第二位选手有必胜策略。

所以，就是看最前面有多少堆连续的数量为 $1$ 颗的石子。如果是奇数堆，就是第二位选手获胜，如果是偶数堆，就是第一位选手获胜。但如果所有堆石子都是 $1$ 颗的话，那么如果是奇数堆，第一位选手获胜，如果是偶数堆，第二位选手获胜。

# code:
```cpp
#include<cstdio>
using namespace std;
int a[100005];
int main(){
	int t;
	scanf("%d",&t);
	while(t--){
		int n,ans=0,i,xian=1;
		bool yes=0;
		scanf("%d",&n);
		for(i=1;i<=n;i++){
			scanf("%d",&a[i]);
			if(a[i]==1&&!yes){
				xian+=1;
				xian%=2;
			}
			else{
			    yes=1;	
			}
		}
		if(!yes){
			if(n%2==0){
				printf("Second\n");
			}
			else{
				printf("First\n");
			}
		}
		else{
			if(!xian){
			    printf("Second\n");
		    }
		    else{
			    printf("First\n");
		    }
		}
	}
	return 0;
}
```