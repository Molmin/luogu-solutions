**题目大意**：有 $n$ 堆石子，两个人轮流取石子，每个人可以取序号最小的堆的任意个石子，谁没有石子可以取，谁就输了。

这个题目刚看时没有什么思路，可以从样例入手分析。

看完样例之后，可以发现，有些样例有 $1$，有些样例全是 $1$，有些样例没有 $1$。

这可以给我们启发：**本题的关键就是只有 $1$ 个石子的堆**。

**首先，如果每一堆都只有 $1$ 个石子，那么每个人每次都只能取一个，所以如果有奇数堆，那么先手赢。如果有偶数堆，那么后手赢。**

**其次，如果没有只有 $1$ 个石子的堆，那么先手一定赢。**

分析：假如有一堆有 $a$ 个石子，那么先手可以拿 $a-1$ 个，那么后手就只能拿 $1$ 个。下一堆依然是先手拿。

这样，先手一直这么拿，拿到只剩一堆时，把最后一堆全部拿走就可以获胜。

**然后，在分析开头没有只有 $1$ 个石子的堆的情况。这样依然是先手必胜。**

假设有 $10$ 个堆，每个堆的石子数为 $a,b,c,1,1,1,1,d,e,f$。

那么，先手想要赢，就和上一种情况一样，使自己先拿到 $d$ 堆石子即可。

所以，只要控制 $d$ 堆前面 $1$ 的个数，使 $d$ 前面有奇数个 $1$ 即可。

如果 $d$ 堆前面本来就有奇数个 $1$，那么就用第二种情况的方法拿到 $1$ 前面的那一堆石子。

如果 $d$ 堆前面有偶数个 $1$，那么就用第二种方法，使 $1$ 前面的那一堆只剩 $1$ 个石子，那么就相当于有奇数个 $1$ 了。

**最后，分析开头有 $1$ 的情况。**

假设有 $10$ 个堆，每个堆的石子数为 $1,1,1,a,b,c,d,1,1,1$。

通过上一种情况的分析，可以得出：先拿到第 $a$ 堆的必胜。

也就是，先拿到非 $1$ 的堆的人必胜。

所以，如果第一个非 $1$ 的堆前有奇数个堆，那么后手必胜；否则，先手必胜。

将上面的四种情况结合一下，就可以发现本题的正解：

**如果所有的堆都只有 $1$ 个石子，那么输赢与堆数有关；**

**否则，输赢与前缀 $1$ 的个数有关。**

之后，就可以写出代码了。

**代码：**
```cpp
#include<cstdio>
#include<iostream>
const int N=100000;
int a[N+1];
int main()
{
	register int i,n,t;
	scanf("%d",&t);
	while(t--)
	{
		scanf("%d",&n);
		for(i=1; i<=n; ++i)
			scanf("%d",&a[i]);
		for(i=1; i<=n; ++i)
			if(a[i]!=1)
				break;//找到第一个不是1的位置
		--i;//前缀1的个数是i-1
		if(i<n)//如果不是全是1，输赢与前缀1的个数有关
			if(i%2)
				puts("Second");
			else
				puts("First");
		else//如果全是1，输赢与堆数有关
			if(n%2)
				puts("First");
			else
				puts("Second");
	}
	return 0;
}
```