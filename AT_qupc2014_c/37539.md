题目给定一张地图，其中的字母就是建筑物，其它的地方就是 "\*"，也就是空地，然后给出 Q 个问题，输入为一个字母，需要在地图中查找这个地方，有就输出坐标，否则输出“NA”。

地图不大于1000\*1000，问题少于3000个，时限有2000ms，暴力完全没有问题。

先把整个地图存下来，然后依次输入问题，遍历一遍地图，找到了就输出并跳出查找的循环，如果循环到最后还没有找到就输出NA。

```cpp
#include <bits/stdc++.h>
using namespace std;
char mp[1010][1010], x;//地图和问题
int n, m, q;//地图大小和问题数量
int main() {
    cin >> n >> m >> q;
    for (int i = 0; i < n; ++i) {
        cin >> mp[i];
    }
    for (int i = 0; i < q; ++i) {
        cin >> x;
        //下面就是查找x这个地方的循环
        for (int j = 0; j < n; ++j) {
            for (int k = 0; k < m; ++k) {
                if (mp[j][k] == x) {//如果找到对应位置
                    cout << j + 1 << " " << k + 1 << endl;
                    //把位置信息输出（数组下标0开始，要+1）
                    goto exit;
                    //直接跳到下面exit:;这一行
                    //goto语句在遇到多重循环需要跳出时很方便
                }
            }
        }
        //已经找完整个地图，但是没有到goto语句，说明没找到
        cout << "NA" <<endl;
        //上面就是跳到这里，所以找到了就不会输出NA
        exit:;
        //goto之后执行这里的代码，但这里没什么事需要做，继续循环
    }
    return 0;
}
```

如果想要追求更加高速的方法，这里提供一种思路：

可以用两个有26个元素的数组，存每个建筑的x和y坐标信息

因为题目限制建筑名字都为大写字母，如果担心可以开到500，肯定够用

输入地图时一个个输入，碰到不是空地（"\*"）的地方就把这里字母对应的x，y坐标存进数组。

搞了一下伪代码

```cpp
	int x[500], y[500];为x，y坐标
	这里省略循环部分：
		输入c（字符）
        	如果是大写字母（不是*）
            	x[c - 'A'] = i + 1;
                y[c - 'B'] = j + 1;
                /*
                如果把数组开得比较大也可以如下存储
                x[c] = i + 1;
                y[c] = j + 1;
                */
```

最后查找时会方便很多，速度也比暴力快了不止一点点

```cpp
	循环Q次：
		输入c（要查找的地方）
    	输出x[c - 'A']，y[c - 'B']
        /*
        另一种：
        输出x[c]，y[c]
        */
```