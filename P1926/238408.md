## 动规做作业，贪心来刷题


------------
读题，我们可以把小A的整个练习过程分为两部分：

先做作业，后刷题


------------
作业有两个参数：时间和分值

要求也能看出有两个：**在及格的基础上做到时间最少**

首先，及格的条件是什么？是总分值达到$k$及以上

分值需要通过做作业得到

作业有$m$项，每项作业只能做一次

这就是个**01背包**啊！

我们把每项作业当成物品，所需时间作为体积，分值作为重量

这和[采药](https://www.luogu.com.cn/problem/P1048)类似

然后求出在1~r秒内能拿到的最大分值是多少

并用一个一维数组存储最终答案（压维）

最后从下标1开始遍历数组，**找出最先满足及格分值的元素**

总结：**先满足及格，再找出及格所需的最少时间**

------------
再来看刷题

每道题只有一个参数：时间

而要求是做最多的题

很明显，**贪心**！

每次都挑**花费时间最少**的题做

直到时间耗尽或无法再刷


------------
代码来了~
```cpp
#include<iostream>
#include<algorithm>
using namespace std;
const int maxn=151;//定义常量作为背包的最大容量 
int dp[maxn],n,m,k,r,p[11],t[11],c[11],ans;
//n,m,k,r如题 
//p数组储存每道题所需的时间，t数组储存每项作业的时间 
//c数组储存每项作业的分值，ans储存答案
int max1(int a,int b){//定义求两者最大值的函数
	if(a>b) return a;
	else return b;
}
int main(){
	cin>>n>>m>>k>>r;
	for(int i=1;i<=n;++i){
		cin>>p[i];//每道题所需的时间
	}
	sort(p+1,p+1+n);
    //排序，把花费时间最少的题放在前面 
	for(int i=1;i<=m;++i){
		cin>>t[i];
	}
	for(int i=1;i<=m;++i){
		cin>>c[i];
	}
	for(int i=1;i<=m;++i){//01背包的板子，一点不变 
		for(int j=r;j>=t[i];--j){
			dp[j]=max1(dp[j],dp[j-t[i]]+c[i]);
		}
	}
	for(int i=1;i<=r;++i){//遍历 
		if(dp[i]>=k){//用这些时间就及格了 
			r-=i;//时间耗费需减掉 
			break;
//不用再找了，因为后面的肯定比这一个花的时间长 
		}
	}
	for(int i=1;i<=n;++i){//开始刷题 
		r-=p[i];//先减去所需时间 
		if(r<0) break;//时间不够啊，不能做了 
		else ans++;//时间足够，那就刷！ 
	}
	cout<<ans;//输出，搞定！ 
	return 0;
} 
```
