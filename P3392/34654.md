这题第一眼看到数据：n,m<=50，想到了搜索。但在我想了很久以后，发现不用搜索，直接枚举暴力，评测两次，AC！（第一次忘记输出了）发现好简单，于是点击题解，看有没有相同做法，发现没有后决定发题解、赚贡献


言归正传，开讲思路：


1.输入（没什么好讲的）


2.枚举染白色的长度和染蓝色的长度（剩下的就是染红色的)


每个颜色都得有！！！每个颜色都得有！！！每个颜色都得有！！！（重要的事情说三遍）


3输出ans.


代码如下：


```cpp
include<bits/stdc++.h>//万能头
using namespace std;//输入输出流
int main()//主函数
{
    int n,m,ans=2501;//n,m<=50，就算都要染色的话，要染50*50=2500，这里把ans的初值定为2501
    cin>>n>>m;//输入n和m
    char a[51][51];
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=m;j++)
        {
            cin>>a[i][j];//输入初始国旗情况
        }
    }
    for(int w=1;w<=n-2（这里只能到n-2行，因为每个颜色都得有）;w++)//白色从第1行染到第w行
    {
        int rw=0;//要染rw次白色
        for(int i=1;i<=w;i++)
        {
            for(int j=1;j<=m;j++)//从第一行到第w行都染成白色
            {
                if(a[i][j]!='W')//如果原来不是白色
                {
                    rw++;//染白色次数++
                }
            }
        }
        for(int b=w+1;b<=n-1;b++)//染蓝色从染白色的下一行开始染，最大染到n-1行，因为每个颜色都得有，即w+1行到n-1行
        {
            int rb=0； // 要染rb次蓝色
            for(int i=w+1;i<=b;i++)
            {
                for(int j=1;j<=m;j++)//从第w+1行到第b行都染成蓝色
                {
                    if(a[i][j]!='B')/ /如果原来不是蓝色
                    {
                        rb++;//染蓝色次数++
                    }
                }
            }
rr=0;//要染rr次红色
            for(int i=b+1;i<=n;i++)
            {
                for(int j=1;j<=m;j++)////染蓝色从染蓝色的下一行开始染，最大染到n行，即从第b+1行到第n行都染成红色
                {
                    if(a[i][j]!='R') / /如果原来不是红色
                    {
                        rr++;//染红色次数++
                    }
                }
            }
            ans=min(ans,rw+rb+rr);//ans为ans和这次染白色次数+这次染蓝色次数+这次染红色次数的最小值
        }
    }
    cout<<ans;//输出答案
    return 0;//结束程序
}
```