********************************************************

# 这道题数据很小（小于50）所以可以用暴力枚举

********************************************************

先做一下预处理，求出每行每个色块的个数

让后两个嵌套的for循环分别模拟白色行数（顶部）和红色行数（底部）

进而求出用这种方法涂制国旗所需次数，再来个很简单的判断，就可以得出最少次数

废话不多说，贴代码

```cpp
#include<iostream>
using namespace std;
char map[60][60];            //map用来存储所有的颜色
int line[60][7]={{0}};            //line用来存储每一行特定色块的个数 
int main()
{
    int n,m;
    cin>>n>>m;
    for(int i=1;i<=n;i++)    //开始预处理和读入程序 
    {
        for(int h=1;h<=m;h++)
        {
            cin>>map[i][h];
            
            if(map[i][h]=='W')
            {
                line[i][1]++;  //1代表白色 
                
             } 
            if(map[i][h]=='B')
            {
                line[i][2]++;  //2代表蓝色 
                
            }
            if(map[i][h]=='R')
            {
                line[i][3]++;//3代表红色 
                
            }
        } 
    }
        
    int mi;//代表最小需要吐多少块 
    mi=9999999;//注意！！！min在c++中为一个自带函数名，不能当作变量名！！！
    int z;//用z临时储存每次生成的结果 
    z=0;
    for(int i=1;i<=n-2;i++)//i代表最上方（白色）的格子有多少条
    {
        for(int h=1;h<=n-2;h++)//h代表最下方（红色）的格子有多少条
        {
            z=0;
            if(i+h>n-1)//白色，红色格子和超过限度（蓝色格子和不得为0）
            {
                continue;//不满足条件的直接忽略 
            } 
            for(int t=1;t<=i;t++)//计算i行白色要涂多少块 
            {
                z=z+line[t][2]+line[t][3];//红蓝加起来就是白色；
                 
            }
            for(int t=i+1;t<=n-h;t++)//算蓝色 
            {
            
                z=z+line[t][1]+line[t][3]; 
            }
            for(int t=n-h+1;t<=n;t++)
            {
                z=z+line[t][2]+line[t][1]; 
            }
            if(z<mi)
            {
                mi=z;
            }
            z=0;
        } 
    }
    cout<<mi;
    return 0;
}
```
