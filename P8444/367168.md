# P8444 不等价交换法则 题解

[原题传送门](https://www.luogu.com.cn/problem/P8444)

## 题意理解

有 $n$ 个商品，第 $i$ 个商品的价格为 $a_i$。你有 $w$ 元，需要先购买一件商品，再用此商品与其他商品交换，要求交换获得的商品的价值和必须小于等于你用于交换的商品价值和。

求最多能获得多少件商品。

**数据范围**

- $1 \le n \le 10^6$
- $0 \le a_i \le 10^9$
- $1 \le w \le 2 \times 10^9$

## 题目分析

因为要求的是最多个数，这个题可以看做商品价值全部为 $1$ 的 背包问题。而针对这种问题，可以用贪心求得结果。

具体做法：先买所有能购买的商品（指价值不超过 $w$ 的商品）中价值最大的一个，再从价值最小的商品开始选择，直到所选择的商品的总价值大于最初购买的商品的价值，输出所选择的商品数量减一（因为最后一个不能选）即可。

证明（设所购买的商品的价值为 $a_w$，假设已排好序）：

1. 证明第一次购买 $a_w$ 最优

>因为 $a_w$ 是可购买商品中价值最大的，所以无法购买 $a_{w+1}$，若购买 $a_{w-1}$ 则可交换得到的商品总价值 $w_e\le a_{w-1} \lt a_{w}$，所以第一次购买 $a_w$ 是最优的。

2. 证明每次选择价值最小的商品最优

> 当 $n = 2$ 时，显然只能选择价值最小的商品（也是唯一的商品）。

> 当 $n = 3$ 时，因为 $a_1 \le a_2$，所以选择 $a_2$ 不会比 $a_1$ 更优，因此选择 $a_1$（即价值最小的商品）最优。

> 其他情况都可以由 $n = 2$ 和 $n = 3$ 的情况推得。

注意有个坑点：如果一个商品也买不了，应输出 $0$，需要特判。

## AC Code

放出核心代码：

```cpp
// read() -> 快读；write() -> 快写
int n, w;
read(n);
ll *a = new ll[n + 5]; // 这是动态数组，如果不习惯也可定义成 ll a[1000005];
a[0] = 0;
for (int i = 1; i <= n; ++i)
    read(a[i]);
sort(a + 1, a + n + 1);
read(w);

// 特判如果一件商品也购买不了
if (a[1] > w)
{
    push(48), push(10);
    return 0;
}

for (int i = 1; i <= n; ++i)
{
    if (a[i] > w) // 因为数组已经有序，所以只要这个商品无法购买，其后面的所有商品都无法购买
    {
        n = i - 1; // 直接改变数组末尾指针，忽略后面全部的数据
        break;
    }
    a[i] += a[i - 1]; // 前缀和预处理
}

w = a[n] - a[n - 1]; // 购买最后一件商品（最贵的商品）

// 这里 i <= n 的原因：
// 如果设为 n - 1：如果这个商品可以交换所有的商品，那么程序会运行到结尾，输出 n，显然不对。
// 如果将循环末的特判输出语句改为 "write(n - 1, 10)"，当 n == 1 的时候，也会得到错误答案
a[n + 1] = a[n] + 1;
for (int i = 1; i <= n; ++i)
{
    // 若 n == 1，会执行后面的输出语句，其他情况至多到 i == n 就会输出
    if (a[i] > w) // 无法交换更多商品
    {
        write(i - 1, 10);
        return 0;
    }
}
write(n, 10); // 相当于小特判，特判 n == 1
```

[效果及全部代码](https://www.luogu.com.cn/record/80968600)