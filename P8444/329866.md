## 获取信息

由题可得，我们有两种方式获得商品。

**1** 通过直接购买商品（但只能购买一个）

**2** 以物换物，以当前所拥有的的商品换取总价格$\le$当前商品价格的商品（数目不限，仅需要满足价格即可）

尽可能买的多，且没有空间的限制。我们就很容易的想到**贪心**的做法。因为数据范围$n\le 10^6$，所以我们可以直接模拟。

## 贪心

那么我的贪心策略应该怎么制定呢？根据上面我们的两种获取商品的方式，我们知道，如果采取以物换物的方式，换取价格越小的商品，所能获得商品总数就越多，所以我们需要将商品从小到大排序。

```cpp
sort(a+1,a+1+n);
```

我们知道假定排序后我们所能购买的最大的商品能换取$m$件商品($2\le m$),那么是一定会去换的。我们的换取是由价格从小到大不断累积，也就意味着，当我们手上拥有第$i$个物品时，理论来说，用$i$去换比$i$价值更小的商品答案更优。但是我们已经排过序，所以在$i$前面的商品其实已经被选取。所以我们只需要**换取一次即可**。

在代码实现中我们需要注意一下几点：

**1** 考虑当前手里的钱买不了任何一个商品

**2** 能购买的商品不一定处于商品序列的最后

**3** 购买了最大值的商品后，无法换取其他商品

代码如下：

```cpp
#include <bits/stdc++.h> 
#define ll long long
#define N 1000010
using namespace std;
ll n;
ll a[N],w,cnt,maxpos,tp;
bool vis[N],fl;
int main(){
	cin>>n;
	for(ll i=1;i<=n;i++){
		cin>>a[i];
	}
	cin>>w;
	sort(a+1,a+1+n);
	for(ll i=n;i>=1;i--){
		if(w>=a[i]){
			w=a[i];
			cnt++;
			maxpos=i;
			break;
		}
	}
	for(ll i=1;i<maxpos;i++){
		if(w>=a[i]){
			if(i==1) cnt--;
			cnt++;
			w-=a[i];
		}
	}
	cout<<cnt;
	return 0;
}
```
