## 序
Q：你这道题都没 AC 还有脸来写题解？

A：生活所迫...
## 题意
给你一个长度为 $n$ 的序列 $a$，以及一个数 $k$。

你可以在 $a$ 里先选一个数 $a_i$，满足 $a_i \leq k$。

之后将这个数换作 $a$ 里更多的数，但要满足这些数之和 $sum \leq a_i$。

问你最后最多能**获得几个数**。
## 思路
对于这种贪心题，直觉告诉我们，先排序！

排完之后呢？

根据贪心思想，我们肯定会选最大的那一个满足 $a_i \leq k$ 的 $a_i$，设它为 $w$。

之后，因为我们已经从小到大排了序，所以再执行 $\sum_{i=1}a_i$，直到这个和大于了 $w$ 为止。

此时 $i-1$ 就是最多能换的数量啦~

至此，万事大吉，可以...

得到 90 分...

本着 AC 至上的目的，究竟是哪儿出现了 bug？

让我们将目光转向问题：

_你最多能获得多少个数。_

能获得...能获得...

恍然大悟，如果我们只能选最小的那个数，它一个数都换不了，**但我们仍然可以获得这个数！**

直接上特判！

至此，万事大吉，可以 AC！

## 正确代码
```cpp
#include<bits/stdc++.h>
using namespace std;
long long a[1000001];
long long n,m,i,k,s;
int main()
{
	scanf("%lld",&n);
	for(i=1;i<=n;i++) scanf("%lld",&a[i]);
	sort(a+1,a+n+1);
	scanf("%lld",&m);
	for(i=n;i>0;i--)
		if(a[i]<=m){ k=i;break; }//a[k]就是最初选的那个数
	if(!k)
	{puts("0");return 0;
	}//特判一个数都选不到
	for(i=1;i<k;i++)
	{
		s+=a[i];
		if(s>a[k])break;
	}
	printf("%lld",(i==1 ? i:i-1));//特判一个数都换不到
	return 0;
}
```
