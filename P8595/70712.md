## 写在前面

本人在赛时把`void`写成了`int`，本地没报错，交上去炸了，直接100->5。
```cpp
inline int add(int u,int v)
{
	to[++tot]=v;
	nex[tot]=hd[u];
	hd[u]=tot;
}
```
大概就是这种效果。

提醒大家（主要是我自己）要避免这种错误（虽然大家可能都很细心）。

## 大体思路


题目给出了一个森林，若其中有$x$棵树，我们在将所有的树都变成链后，再进行$x-1$次操作就可以让图变为一条链。

我们考虑如何计算一棵树需要的操作次数。

我们考虑树形DP。

## 状态转移

设 $f[i][0/1][0/1]$ ，下面是每一维的含义。
* 第一维中的 $i$ 代表编号为 $i$ 的节点。
* 第二维如果为 $0$ ，代表以 $i$ 为根节点的子树被变成了一条链， $1$ 代表   $i$ 有两个儿子，且以那两个儿子为根节点的子树是一条链。
* 第三维如果为 $0$ ，代表我们没有炸毁 $i$ 向外联接的所有道路，如果为 $1$ ，代表我们炸毁了 $i$ 向外联接的所有道路。

接下来是怎么转移。

我们设 $i$ 为当前的节点， $u$ 为其子节点。

* 如果 $i$ 是叶节点，那么 $f[i][0][0]$ 和$ f[i][1][0]$ 为 $0$ ， $f[i][0][1]$ 和 $f[i][1][1]$ 为 $1$ 。
* 如果 $i$ 是非叶节点， $f[i][0][1]$ 和 $f[i][1][1]$ 都等于 $f[u][0][0]+1$ 、 $f[u][0][1]+1$ 、 $f[u][1][0]+1$ 、 $f[u][1][1]+1$ 中的最小值的和。这个转移比较直观， $+1$ 是因为 $i$ 到其子节点的路被切断了，所以要重建。
* 对于 $f[i][0][0]$ ，至多存在一个子节点， $i$ 与其之间的边未被切断。我们可以先认为 $i$ 与其所有子节点之间的边都被切断， $f[i][0][0]$ 的值**暂时**等于 $f[u][0][1]+1$ 和 $f[u][1][1]+1$ 中的最小值的和。同时我们记录   $1+min(f[u]][0][1],f[u][1][1])-f[u][0][0]$ 的最大值 $mx1$ ，这个式子的含义是保证以 $u$ 为根节点的子树是一条链，保留 $i$ 与 $u$ 之间的通路，与断开 $i$ 与 $u$ 之间的通路相比，能节省的操作次数。我们将 $f[i][0][0]-mx1$ 即为最少的操作次数。
* 对于 $f[i][1][0]$ ，转移与上一条相似，我们记录 $1+min(f[u]][0][1],f[u][1][1])-f[u][0][0]$ 的次最大值 $mx2$ ，其他步骤不变，将 $f[i][1][0]-mx1-mx2$ 即可。

以上保证 $mx1$ 与 $mx2$ 不小于 $0$ 。

## 计算答案

对于每一棵树，我们设树根为 $root$ ，这棵树的操作次数就是 $f[root][0][0]$ ， $f[root][1][0]$ ， $f[root][0][1]$ ， $f[root][1][1]$ 中的最小值。

找出森林中有多少棵树相对简单，我是每次以一个为访问的点为根进行树形DP，每一个点被访问后进行标记。

答案就是每棵树的次数的和加树的数量减1。

每个点仅被访问一次，没有使用STL，复杂度为 $O(n)$ 。

```cpp
#include<bits/stdc++.h>
#define rint register int
#define LL long long int
using namespace std;
inline int read()
{
	int x = 0, ff = 1; char s = getchar();
	while (s < '0' || s > '9') { if (s == '-') ff = -ff; s = getchar(); }
	while (s >= '0' && s <= '9') { x = x * 10 + s - '0'; s = getchar(); }
	return x * ff;
}
int hd[2000005],nex[4000005],to[4000005],tot,vis[2000005];
inline void add(int u,int v)
{
	to[++tot]=v;
	nex[tot]=hd[u];
	hd[u]=tot;
}
int n,m,f[2000005][2][2];//编号为i的点，形态(0-链)(1-二叉树)，是否爆炸(0-不炸)(1-爆炸) 
void solve(int u,int pre)
{
	if(vis[u]==1)return ;
	f[u][0][0]=f[u][1][0]=0;
	f[u][0][1]=f[u][1][1]=1;
	vis[u]=1;
	int i,ok=0;
	int dx=0,ddx=0,nw;
	for(i=hd[u];i;i=nex[i])
	{
		if(to[i]!=pre)
		{
			ok=1;	
			solve(to[i],u);
			f[u][0][1]+=1+min(min(f[to[i]][0][0],f[to[i]][0][1]),min(f[to[i]][1][0],f[to[i]][1][1]));
			f[u][1][1]+=1+min(min(f[to[i]][0][0],f[to[i]][0][1]),min(f[to[i]][1][0],f[to[i]][1][1]));
			f[u][0][0]+=1+min(f[to[i]][0][1],f[to[i]][1][1]);
			f[u][1][0]+=1+min(f[to[i]][0][1],f[to[i]][1][1]);
			nw=1+min(f[to[i]][0][1],f[to[i]][1][1])-f[to[i]][0][0];
			if(nw>dx)
			{
				ddx=dx;
				dx=nw;
			}
			else if(nw>ddx)
			{
				ddx=nw;
			}
		}	
	} 
	if(ok==0)
	{
		return ;
	}
	f[u][0][0]-=dx;
	f[u][1][0]-=dx+ddx;
}
int main()
{
	//freopen("traffic3.in","r",stdin);
	rint i,j,u,v,cnt=0,ans=0;
	cin>>n>>m;
	for(i=1;i<=m;i++)
	{
		u=read();v=read();
		add(u,v);
		add(v,u);
	}
	for(i=1;i<=n;i++)
	{
		if(vis[i]==0)
		{
			solve(i,0);
			ans+=min(min(f[i][0][0],f[i][0][1]),min(f[i][1][0],f[i][1][1]));
			cnt++;
		}
	}
	//cout<<cnt<<endl;
	cout<<ans+cnt-1<<endl;
	return 0;
}

```
