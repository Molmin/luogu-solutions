#### 闲话

(在打模拟赛的过程中， A 掉了 T1 ，极度兴奋，揪住T3就一顿胡搞……结果喜提 20pts ，回来好好读了一下题……用了不到一个小时思路加代码都出来了然后就 A 掉了……)

------------

#### 关于题意

~~本题最大难点~~注意这个是删除**每一个点上的所有边**而不是其中一条

#### 解题思路

树型 DP ，**线性**时间复杂度，注意该题**卡常**，需要优化读入。

每次找一个**没有访问过的节点**当做根节点进行 DP 。

具体方法就是对当前节点（只考虑**当前节点子树的贡献**不需要考虑和父亲的关系）分 4 种情况进行分类讨论：

1. $f[x][0]$ 自己炸掉；

2. $f[x][1]$ 自己不炸但是与儿子无连边；

3. $f[x][2]$ 自己不炸只与一个儿子有连边；

4. $f[x][3]$ 自己不炸与两个儿子有连边。

不会有再多了，再多就**不可能成链**了。

其中:

$f[x][0]=(\sum\limits_{u∈son[x]}^{}\min(f[u][0],f[u][1],f[u][2],f[u][3])+1)+1$

$f[x][1]=\sum\limits_{u∈son[x]}^{}f[u][0]+1$

情况 $0$ ：节点不会与儿子的 $4$ 种情况发生冲突。对每一个儿子 $+1$ 的原因是炸掉之后每一个儿子都需要再次连边。最后 $+1$ 是爆炸当前点的贡献 。

情况 $1$ : 只能将每一个儿子的第一种情况 $+1$ 作为贡献。该情况**与儿子没有连边**而且**自己没炸掉**则必然儿子都被炸掉了。

情况 $2$ : 在 $1$ 的基础上，保留 $1$ 个儿子即可。这时，我们只需要计算出每一个儿子的 $\min(f[son][1],f[son][2])-f[son][0]-1$ （**计算保留哪一个儿子最合算**）选取最大的再加上 $f[x][1]$ 即可。该情况下，因为要与那个儿子有连边，所以该儿子不能是情况 $0$ （炸掉就没边了）和情况 $3$ （无法成链），其它情况不冲突。 

情况 $3$ : 同情况 $2$ ，比情况 $2$ 要多选一个**次大值**计入贡献。

最后记录 $ans$ 为 $\min(f[rt][0],f[rt][1],f[rt][2],f[rt][3])$ 的和。

答案就是 $ans+n-m-1$ (上面是对**单棵树**计算，最后需要把森林连成一棵树)。

```cpp
#include<iostream>
#include<cstdio>
#define N 2000006
using namespace std;
int n,m,to[2*N],last[2*N],nx[2*N],tot,f[N][4],ans;
bool opt[N];
void add(int x,int y){
	to[++tot]=y;
	nx[tot]=last[x];
	last[x]=tot;
}
void dp(int x,int fa){
	opt[x]=1;
	int son=0,mi=N,mi2;
	for(int i=last[x];i;i=nx[i]){
		if(to[i]==fa)continue;
		son++;
		dp(to[i],x);
		f[x][0]+=min(min(f[to[i]][0]+1,f[to[i]][1]+1),min(f[to[i]][2]+1,f[to[i]][3]+1));
		f[x][1]+=f[to[i]][0]+1;
		if(min(f[to[i]][1],f[to[i]][2])-f[to[i]][0]-1<mi){
			mi2=mi;
			mi=min(f[to[i]][1],f[to[i]][2])-f[to[i]][0]-1;
		}
		else if(min(f[to[i]][1],f[to[i]][2])-f[to[i]][0]-1<mi2)mi2=min(f[to[i]][1],f[to[i]][2])-f[to[i]][0]-1;
		f[x][3]=f[x][2]=f[x][1];
		f[x][2]+=mi;
		f[x][3]+=mi+mi2;
	}
	f[x][0]++;
	if(!son)f[x][2]=f[x][3]=N;
	else if(son==1)f[x][3]=N;
}
int main(){
	cin>>n>>m;
	for(int i=1,x,y;i<=m;i++){
		scanf("%d%d",&x,&y);
		add(x,y);
		add(y,x);
	}
	for(int i=1;i<=n;i++)
		if(!opt[i]){
			dp(i,0);
			ans+=min(min(f[i][0],f[i][1]),min(f[i][2],f[i][3]));
		}
	cout<<ans+n-m-1;
	return 0;
}
//无向图，记得开2倍空间
```

### 祝 CSP 大捷！ rp++