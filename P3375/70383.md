## 欢迎访问[juruo的博客](https://rec.ac.cn/?p=325)查看
状态一直很差 甚至连这么基础的算法都不会了 整理复习一下
### 介绍
KMP算法是一种改进的字符串匹配算法，由D.E.Knuth，J.H.Morris和V.R.Pratt同时发现，因此人们称它为克努特——莫里斯——普拉特操作（简称KMP算法）。KMP算法的关键是利用匹配失败后的信息，尽量减少模式串与主串的匹配次数以达到快速匹配的目的。具体实现就是实现一个next()函数，函数本身包含了模式串的局部匹配信息。时间复杂度O(m+n)。
### 原理
百科上的介绍已经非常清楚了 就是“利用匹配失败后的信息尽量减少的模式串与主串的匹配次数以达到快速匹配的目的”    
简单来说就是在当前匹配失败之后不完全回退到初始状态而是跳到下一个符合的状态   
举一个例子   
主串是 bbaabcdfabcabc    
模式串 abcdabc   
我们先看一下暴力匹配的过程   
我们用‘q’暂时代替一下空格    
//好像还是有些问题 对付一下啦qwq    
我们先将主串固定 第几位代指模式串第几位    
1     
bbaabcdfabcabc    
abcdabc    
我们发现第一位匹配失败 模式串向后移动一位    
2    
bbaabcdfabcabc    
qabcdabc    
我们发现第一位匹配失败 模式串向后移动一位    
3   
bbaabcdfabcabc    
qqabcdabc    
我们发现第二位匹配失败 模式串向后移动一位    
4   
bbaabcdfabcabc    
qqqabcdabc    
我们发现第五位匹配失败 模式串向后移动一位   
5   
bbaabcdfabcabc   
qqqqabcdabc   
我们发现第五位匹配失败 模式串向后移动一位   
。。。。。。。//此处省略一些   
end    
bbaabcdfabcabc  
qqqqqqqabcdabc   
匹配成功   

很复杂也有很多浪浪费 考虑如何优化这一过程呢？   
不难想到的~~为什么不从后向前匹配呢？~~   
我们不论在第几个位置匹配失败 都是整体后移一位重新进行匹配 这一定是可以进行优化的   
不妨试试如果失去匹配 我们直接向后跳模式串已匹配到的长度（下文简写）个位置会有怎样的影响 显然有些情况下是错的  这就很好 我们只解决这些错误的情况就好了   
我们无法确定在已匹配到的后面一段中 是否包含正确匹配的前一段   
//这里自己想一下可能会更有效果 写个例子试试就好了   
什么时候会有这种影响呢？ 即已经匹配到的部分前面的与后一部分有相同的地方    
比如模式串abeabf 我们在第六位‘f’失去匹配了  向后跳转五位 就相当于在主串中的第二个ab 只与模式串的第二个ab匹配后就被跨了过去 我们还需要让模式串第一个ab再次与它匹配 所以这里的跳转应该是     
5（已匹配到的长度） - 2（最长公共长度） = 3   
可以相见 跳转后主串中的第二个“ab”将会与模式串中的第一个“ab”重新重合    
如此 我们就轻松解决了这一问题    
那我们唯一会出现错误的情况也找到了解决方法     
在其他情况下最长公共长度是0 减一下不会影响答案正确性    
我们只需要预处理出     
模式串每一位置的前缀和后缀的最长公共元素的长度   
把这个存进一个数组里   
匹配时就可以用它来加速就可以了   
### 代码
[模板](https://www.luogu.org/problemnew/show/P3375 "模板")~~当时大概orz了先辈代码~~
//数组kmp就是那个值
```cpp
#include <cstdio>
#include <cstring>
using namespace std;
char a[1000010], b[1000010];
int kmp[1000010], k, lena, lenb;
int main(){
	scanf("%s%s", a, b);
	lena = strlen(a), lenb = strlen(b);
	kmp[0] = kmp[1] = 0;
	for(int i = 1; i < lenb; ++ i){
		while(k && b[i] != b[k]) k = kmp[k];
		kmp[i + 1] = b[i] == b[k] ? ++ k : 0;
	}
	k = 0;
	for(int i = 0; i < lena; ++ i){
		while(k && a[i] != b[k]) k = kmp[k];
		k += a[i] == b[k] ? 1 : 0;
		if(k == lenb) printf("%d\n", i - lenb + 2);
	}
	for(int i = 1; i <= lenb; ++ i) printf("%d ", kmp[i]);
	return 0;
}

```

