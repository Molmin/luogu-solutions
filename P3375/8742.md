#代码是最清晰的语言

```cpp
%:pragma GCC optimize(3)
#include<cstdio>
#include<cstring>
using namespace std;
int i,j,len1,len2,ne[1001];
char s1[1000001],s2[1001];
void findnext()
{
    for (i=2,j=0; i<=len2; i++)//i不从1（开头）开始是为了防止后缀最大长度等于前缀最大长度等于整串长，至于j那是已经匹配的前缀最大长和后缀最大长 
    {    
        while (s2[i]!=s2[j+1]&&j>0) j=ne[j];//如果当前位与前缀已匹配后一位不相等，就递归找最大公共前后缀，否则最优跳出******************************label 1;
        if (s2[i]==s2[j+1]) ne[i]=++j;//如果尽可能地匹配后，还是不能使当前位与之前匹配的后一位相等，就把ne赋为0（不赋值）否则在已匹配位+1 
    }
}
void kmp()
{
    for (i=1,j=0; i<=len1; i++)//这里i指要努力匹配的，j指已经匹配的； 
    {
        while (s1[i]!=s2[j+1]&&j>0) j=ne[j];//label1（手比较懒） 
        if (s1[i]==s2[j+1]) ++j;//如果尽可能匹配后还是不匹配，理论上应该j清零，{可我为什么没写呢？因为j在上一句话就清0了}，否则增加已匹配位数 （大括号表示层次） 
        if (j==len2) {printf("%d\n",i-len2+1); j=ne[len2];}//如果全部匹配输出，然后由于我们已经知道j的最大公共前后缀了，可以直接将j设为他的最大公共前后缀用以加速 
    }
}
int main()
{
    scanf("%s%s",s1+1,s2+1);//从字符串第一位开始读，需要特殊处理 
    len1=strlen(s1+1); len2=strlen(s2+1);//扫到/0（结束符）之前扫了几位，也是字符串最后一有效位的位置 
    findnext();//初始化ne数组 
    kmp();//进行kmp 
    for (i=1; i<=len2; i++) printf("%d ",ne[i]);//叔叔叔叔叔叔叔叔叔初初初初初初初初 
    return 0; 
}//经过实测洛谷的数据为 12ms还是比较快的^_^；
```