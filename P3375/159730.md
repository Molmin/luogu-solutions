看了很多讲KMP的，全都没看懂（太菜了），直到看了lyd大佬的蓝书

&emsp;&emsp;两个字符串$\;A[1\sim N]\;$和$\;B[1\sim M]\;$，目标是判断$\;A\;$是不是$\;B\;$的子串。显然，最暴力的办法是，枚举$\;B\;$中每一个位置$\;i\;$, 把$\;A[\,1\,]\;$与$\;B[\,i\,]\;$对齐，然后逐一向后比较$A[\,2\,]$和$\;B[i+1]\;...\;$是否相等。这种办法虽然简单易行，但复杂度高达$O(MN)$, 无法接受。下面尝试优化它。  
&emsp;&emsp;下图是尝试在$\;B[1+j-i]\;$处匹配$\,B\,$串的情形，如果$\;B[1+j-1\sim j]\;$与$\;A[1\sim j]\;$匹配，而$\;B[j+1]\;$与$\;A[i+1]\;$失配，按照暴力做法，之后需要回溯，尝试对齐$\;B[2+j-i]\;$和$\;A[\,1\,]\;$, 重新从头匹配。仔细观察可以发现，**这一趟匹配和上一趟是有重合部分的**，这一趟的$\;A[1\sim i-1]\;$和上一趟的$\;A[2\sim i]\;$都在和$\;B[2+j-i\sim j]\;$进行着匹配。所以，如果我们预先知道$\;A[1\sim i-1]\neq A[2\sim i]\;$，那么就可以断定这一趟肯定失配，因为上一趟$\;A[2\sim i]=B[2+j-i\sim j]\;$。同理，再下一趟也可以进行这样的分析。于是，如果预先知道了**A串中以i结尾的非前缀子串和A的前缀匹配的最长长度$k$**，（如下图第三条A所示），就可以直接去判断$\;B[j+1]\;$和$\;A[k+1]\;$是否相等。  

![](https://i.loli.net/2019/07/25/5d39662d0f44522912.png)

&emsp;&emsp;所以，接下来的目标就是，预处理$\;A\;$串中以$\;i\;$结尾的非前缀子串和$\;A\;$的前缀匹配的最长长度$\;k\;$，用数组$\;next[\,]\;$保存一对 $(i, k)$. 即：
$$next[i]=max(k),\qquad k<i\quad and \quad A[i-k+1\sim i]=A[1\sim k]$$  

&emsp;&emsp;为了叙述方便，下面称满足$\;k<i\;$且$\;A[i-k+1\sim i]=A[1\sim k]$的$k$ ”具有$\;i\;$性质“。

&emsp;&emsp;显然暴力地按照定义求next数组复杂度过大，需要寻求优化。
此时，KMP算法的发明者发现了一个神奇的规律：

**引理**  
&emsp;&emsp;若$j_0$满足$\;i\;$性质，即$\;j_0<i\;$且$\;A[i-j_0+1\sim i]=A[1\sim j_0]$, 那么小于$\,j_0\,$的最大的满足$\;i\;$性质的数是$\;next[j_0]\;$。

**证明**（不喜掠过~~）  
&emsp;&emsp;反证。假设存在$\;next[j_0]<j_1<j_0\;$,其中$\,j_1\,$满足$\,i\,$性质, 即$\;j_1<i\;$且$\;A[i-j_1+1\sim i]=A[1\sim j_1]$。如下图所示：  
![](https://i.loli.net/2019/07/26/5d3a767adcf9a69841.png)

图中不是黑色的部分若颜色相同则表示字符串相同。其中第二段和第三段存在共同部分（黄+绿），即$\;A[j_0-j_1+1\sim j_0]=A[1\sim j_1]\;$, 这表明$\;j_1\;$具有$\;j_0\;$性质，而根据定义，$\;next[j_0]\;$才是具有$\;j_0\;$性质中最大的一个，但现在$\;j_1>next[j_0]\;$，矛盾。   
&emsp;&emsp;证毕。     
    
                   
&emsp;&emsp;所以，根据引理，当$\;next[i-1]\;$计算完之后，我们立即就能知道，所有具有$\;i-1\;$性质的所有数从大到小为：   
$\;next[i-1]\;,next[next[i-1]]\;,next[next[next[i-1]]]\;...$  
又因为，如果$\;j\;$具有$\;i\;$性质，那么$\;j-1\;$也一定具有$\;i-1\;$性质，（字符串$\;A[i-j+1\sim i]\;$和$\;A[1\sim j]\;$相同的前提是$\;A[i-j+1\sim i-1]\;$和$\;A[1\sim j-1]\;$相同）。因此$\;next[i]\;$最终的值一定在$\;next[i-1]+1\;,next[next[i-1]]+1\;,next[next[next[i-1]]]+1\;...$ 中。所以在计算$\;next[i]\;$的时候，只需从大到小一个一个验证即可。

&emsp;&emsp;所以，$\;next[\,]\;$求法过程为：   

&emsp;&emsp;1. 初始$\;next[1]=j=0\;$, 假设$next[1\sim i-1]\;$已经求出，下求$\;next[i]\;$  
&emsp;&emsp;2. 不断尝试扩展当前的匹配长度$\;j\;$,如果失败，即下一个字符不相等，令$\;j=next[j]\;$, 直到$\;j=0\;$为止  
&emsp;&emsp;3. 如果成功，$\;j=j+1\;$, $\;next[i]\;$值即为$\;j\;$.

```cpp
next[1] = 0;
for (int i = 2, j = 0; i <= n; i++)
{
	//每次进while时j为上次next[i-1]
	while (j > 0 && a[i] != a[j + 1])
	{
		j = next[j];//next[next[...next[i-1]]
	}
	if (a[i] == a[j + 1])//排除最后一次仍然不匹配，j=0否则j加一
	{
		j++;
	}
    next[i] = j;
}
```
求完$\;next[\,]\;$之后，~~为了借用刚刚的思路方便偷懒~~，定义$\;f[\,]$为$\,B\,$中以$\,i\,$结尾的子串和$\;A\;$的前缀能够匹配的最长长度，即：
$$next[i]=max(k),\qquad k<=i\quad and \quad B[i-k+1\sim i]=A[1\sim k]$$   
于是求$\;f[\,]\;$的方法与$\;next[\,]\;$基本相同
```cpp
for (int i = 1, j = 0; i <= m; i++)
{
	while (j > 0 && (j == n || b[i] != a[j + 1]))
	{
		j = next[j];
	}
	if (b[i] == a[j + 1])
	{
		j++;
	}
    f[i] = j;
	//if(f[i]==n),A在B中出现
}
```