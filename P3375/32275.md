kmp算法虽然是一个非常老的算法了，各界OI比赛最近也很少碰过。但是，作为一个很经典的算法，且在2016GDOI中专门出了kmp模板题（当时还是个蒟蒻，暴力只拿了30分……）。所以，今天又打了一遍kmp且写了题解，既是帮大家理解kmp，也是对我自己知识的一个梳理。

首先，我们要了解相较于普通字符串匹配快在哪。普通匹配是一位一位往前推，再一次次从选定的开头往后对比，时间复杂度近似于O(N^2)。而kmp快就快在它不用一位一位的选定开头，而是动态以最优的开头作比较，比朴素算法效率提高了不少。看不懂这段话的人也不用着急，往后看就对了。

首先，让我们来谈谈此算法的思路。针对于每一位，kmp算法已经预处理出了一个对应kmp数组的单元，映射着如果此位失配，它可能的最靠后的一个重新开头是哪一个。让我们举一个例子：假如让aaab与aab匹配。一开始，aab的aa与aaab的开始的aa成功匹配，但到了第三位失配了。此时，朴素算法会跳出，找到下一个开头进行比对。然而kmp算法用kmp数组得知，这位失配后应该可能却可以与第二位匹配成功，而又成功，于是又继续往后匹配，然后就匹配成功了，只比较了5次，比O（n^2）好了不少。

而kmp函数又是怎么算出来的呢？其实，只要自己与自己匹配即可。

kmp[i]的基本定义是：在第1-第i-1位中前缀与后缀相同的部分最长是多长。这样，即可以理解为，若第i位失配了，则至少要往前跳多少步，才可能重新匹配得上。这样便可以解释前面的例子了。

而具体实现放在代码里，大家若是刚接触kmp，可以看一看。

```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
#include<string>
#include<cstring>
#include<cmath>
using namespace std;
char a1[2000000],a2[2000000];
int kmp[2000000];
int main()
{
    scanf("%s%s",a1,a2);
    kmp[0]=kmp[1]=0;//前一位，两位失配了，都只可能将第一位作为新的开头
    int len1=strlen(a1),len2=strlen(a2);
    int k;
    k=0;
    for(int i=1;i<len2;i++)//自己匹配自己
    {
        while(k&&a2[i]!=a2[k])k=kmp[k];//找到最长的前后缀重叠长度
        kmp[i+1]=a2[i]==a2[k]?++k:0;//不相等的情况，即无前缀能与后缀重叠，直接赋值位0（注意是给下一位，因为匹配的是下一位适失配的情况）
    }
    k=0;
    for(int i=0;i<len1;i++)
    {
        while(k&&a1[i]!=a2[k])k=kmp[k];//如果不匹配，则将利用kmp数组往回跳
        k+=a1[i]==a2[k]?1:0;//如果相等了，则匹配下一位
        if(k==len2)printf("%d\n",i-len2+2);//如果已经全部匹配完毕，则输出初始位置
    }
    for(int i=1;i<=len2;i++)printf("%d ",kmp[i]);//输出f数组
    return 0;
}
```