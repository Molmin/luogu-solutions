# 看见楼下的题解都比较复杂，为大家奉上一个简单易懂的题解

- ## 先说说具体思路

- **题目看似是高精，其实不然，解题步骤如下：**

- 1.用筛法找出 N 以内的所有素数，因为所有的质因子都是素数；

- 2.用三重循环枚举 2 ~ N 所有数，逐个判断计数；

- 3.输出每个质因子以及它们的数量。

# 代码及解释如下：

```cpp
#include <iostream>
#include <cstdio>
using namespace std;
int n , prime[10001] , c = 1 , t[10001] , x;// n 表示输入的数，prime 数组用来存 N 以内的所有素数，c 用来计 prime 数组边界值，t 数组用来计每个质因子的数量，x 为临时变量。
bool f[10001];//用布尔型数组筛选素数。
int main()
{
    scanf ( "%d", &n );//输入 n 。
    for ( int i = 2 ; i <= n ; i++ )//阶乘中 1 可以不用考虑。
    {
        x = i;// x 用来存 i 的值。
        if ( ! f[i] )
        {
            for ( int j = i * 2 ; j <= n ; j += i )
            f[j] = true;
            prime[c++] = i;
        }//筛法求素数。主要原则：默认所有数为 0 (false) ，如果碰到一个数是 0 ，就把它 N 以内的所有倍数标记成 1 ，并将这个数存进 prime 数组。
        for ( int j = 1 ; j < c ; j++ )//枚举 N 以内的所有素数，注意是 j < c 。
        {
            while ( x % prime[j] == 0 )//当 x 可以整除某个质因子时，
            {
                t[j]++;//该质因子的数量增加 1 。
                x /= prime[j];// x 变为整除该质因子后的数。如果还能整除该质因子，则继续；不能就退出。这就是 while 循环相比 for 循环的优点。
            }
        }
    }
    for ( int i = 1 ; i < c ; i++ )
    cout << prime[i] << " " << t[i] << endl;//输出每个质因子以及它们的数量。
    return 0;
//其实还可以优化，后一半质因子的数量肯定为 1 ，但是由于 n 范围较小和数据较水，完全不用考虑，毕竟这只是道入门难度的题。
}
```
# 码字不易，希望此题解对大家有帮助！
