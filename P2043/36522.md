C++程序闪亮登场！！！

当当当！！！

好吧，这道题虽说是入门难度，我认为可能还是有普及-的

因为如果用普通判质数的话最后一个点会超时

# 所以这题我用的是质数的线性筛法

具体代码如下

其实是C党的肯定都看得懂，所以我下面也不加注释了

```cpp
#include <cstdio>
#include <cstdlib>
#include <iostream>
#include <algorithm>
using namespace std;     //呵呵，习惯没事干开这么多库
int a[20010],s;     //a和s在这道题中起辅助作用，其中a既参与了筛法，也参与了最后的输出
int ans[20010]={1,1};     //ans在这道题中是判断数i或j是不是质数的一个数组，如果是，ans[i]=0，否则=1
int n;     //呵呵，n就不用说了吧，n就是输入的那个数
int main()
{
    for (int i=2;i<20005;i++) {     //素数线性筛法
        if (!ans[i])     //如果这个数是质数
            a[s++]=i;
        for (int j=0;j<s && i*a[j]<20005;j++) {     //将这个数之后的所有的是该数的倍数的数全都标记为合数，因为这个合数有这个数做因子
            ans[i*a[j]]=1;     //标记为合数
            if (!(i%a[j])) break;     //这个是一个非常重要的句子，它将普通晒法的时间复杂度降低了很多，具体降低了多少，我也不太记得了，但是普通晒法合快速筛法的唯一区别就是这一句话。这句话是说，如果a[j]是i的因数，那就退出循环，不再标记
        } 
    } 
    cin>>n;     //输入n
    for (int i=1;i<=n;i++)
        a[i]=0;     //将a[i]清零，因为之前已经用过a[i]来扶衬ans，现在还需要一个数组，就懒得再开一个，于是把它清零继续凑合着用。现在的a是用来统计有几个质数j的因子
    for (int i=2;i<=n;i++)     //i从2到n循环，因为1什么都不会输出（1是打酱油的）所以就跳过1，从2开始循环到n
        for (int j=2;j<=i;j++) {     //做i的阶乘，同样，1也是打酱油的
            int s=i;     //找个替身代替i
            if (!ans[j] && s%j==0)     //如果j是质数而且j是i的倍数
                while (1) {     //循环，每次把a[j]+1，并且令s除以j，一直到除不了为止
                    a[j]++; s/=j;
                    if (s%j!=0) break;
                }
        }
    for (int i=2;i<=n;i++)     //输出
        if (!ans[i] && a[i]!=0) cout<<i<<" "<<a[i]<<endl; 
    return 0;
}
```