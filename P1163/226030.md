
刚开始想用暴力枚举的方法，一个for循环，像这样
```
for (double j = 0.001; j < 1000; j += 0.001) {
        double w = a;
        for (int i = 0; i < c; ++i) 
            w = w - b + w * (j / 100);
        if (minn > abs(w)) {
            minn = abs(w);
            ans = j;
        } else break;
    }
```
每次循环后找出绝对值最小的未还的钱(w)所在的利率(j)就是答案。

而且没有超时，可是这题的数据利率竟然大于1，这样的过不了。

后来就想到了二分法，上代码。
```
#include <bits/stdc++.h>

using namespace std;
typedef long long ll;

int main() {
    double a, b, c;
    cin >> a >> b >> c;
    //l和r分别表示利率的最小值和最大值，也就是初始范围。
    double l = 0, r = 1000, mid = 0;
    //double数据类型，相差小于0.0001结束循环，避免多次循环
    while (l < r - 0.0001) {
        mid = (l + r) / 2;//mid为范围的中间值。
        double w = a;//w为未还的总钱数。
        for (int i = 0; i < c; ++i)//模拟还钱过程。
            w = w - b + w * (mid / 100);
        if (w > 0.0001)//检验在这个利率下，是否将钱还完。
            r = mid;//钱未还完，利率偏大，将范围最大值设置为中间值。
        else l = mid;//钱还多了，利率偏小，将范围最小值设置为中间值。
    }
    printf("%0.1f\n", round(l * 10) / 10);
    return 0;
}
```

结束。
