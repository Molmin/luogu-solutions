摘自我的[贪心 & 构造 & DP 杂题选做](https://www.cnblogs.com/ET2006/p/greedy-construction-dp2.html)，第 $30$ 道题

一道非常妙的拓扑排序好题，能出出这道题的人怕不是神仙/bx

首先我们考虑求出矩形 $A$ 中的每一行在进行这些操作后会对应到矩形 $B$ 中的哪一行——显然如果矩形 $A$ 中每行都不相同，那直接相同的行配对即可，如果矩形 $A$ 出现了相同的行，那显然它们的相对位置顺序是不会改变的，直接按照它们在原矩阵中的顺序编号即可。这样我们可以新增一个 $m+1$ 列，$A$ 矩形第 $i$ 行第 $m+1$ 列的元素就是 $i$，而 $B$ 矩形第 $i$ 行第 $m+1$ 列的元素则是 $B$ 矩形第 $i$ 行在 $A$ 矩形中对应的行的编号。当然如果无法对应我们就直接输出 `NO`。

接下来考虑如何求出操作序列，我们倒着考虑操作序列，那么可以发现，我们最后一步可能操作的列，在 $B$ 矩形中都是单调不降的，也就是说对于**任意相邻两行 $i,i+1$**，必须要有 $b_{i,j}\le b_{i+1,j}$ 后，最后一次才有可能操作第 $j$ 列，考虑完了最后一次操作，再考虑倒数第二次操作的列有什么限制，还是必须单调不降吗？非也，不难发现，加入最后一次操作的列为 $x$，倒数第二次操作的列为 $y$，那么如果 $b_{i,y}>b_{i+1,y}$ 但 $b_{i,x}<b_{i+1,x}$，这种情况还是有可能合法的，因为虽然排 $y$ 之后会导致 $i,i+1$ 顺序颠倒，但是下一次排序我们又把它搬回来了，因此这种情况是不影响的，但是如果出现 $b_{i,y}>b_{i+1,y}$ 且 $b_{i,x}=b_{i+1,x}$ 就 GG 了，因为我们的排序是 stable 的，你前一次把 $i,i+1$ 的顺序搞反了，后一次两行的关键字相同，它们的顺序还是反的。

那么我们应该从什么角度思考这个过程呢？不难发现，我们倒着考虑每一次操作 $x$，那么我们考虑完 $x$ 之后，相当于把所有 $a_{i,x}\ne a_{i+1,x}$ 的 $(i,i+1)$ 都“解锁了”，而如果考虑到某一步操作时，第 $y$ 列存在一个 $i$ 使得 $a_{i,y}>a_{i+1,y}$，且 $(i,i+1)$ 没有被“解锁”，那么上一步操作的就不可能是 $y$，因此我们可以考虑拓扑排序的过程，将相邻两行和每一列看作一个点，对于每对 $(a_{i,x},a_{i+1,x})$，如果 $a_{i,x}<a_{i+1,x}$，那么我们连一条第 $x$ 列向第 $i$ 行的边，表示操作完第 $x$ 列后 $(i,i+1)$ 就被解锁了，如果 $a_{i,x}>a_{i+1,x}$，那么我们连一条第 $i$ 行指向第 $x$ 列的边，表示第 $i$ 行被解锁，是第 $x$ 列能够被操作的必要条件，然后跑一遍类似拓扑排序的东西即可。只不过这里与一般的拓扑排序不同的一点是，如果一个点对应的是某一行表示的点，那么只要连向它的点中至少一个被选择，那它就可以设为被访问。

那么怎样统计答案呢？不难发现，初始局面相当于我们强制对 $m+1$ 行排了个序，因此我们只需检验 $m+1$ 列对应的点是否被访问即可，如果被访问了则倒着输出拓扑序列，否则输出 `NO`。

时间复杂度 $\Theta(nm)$。