这道题目的 $n\le 10^7$，用堆来做显然凉凉，而这一道题不用堆但也需要排序，直接 sort？吸氧都过不了。这一道题的正解是先用桶排 $(a_i\le10^5)$，然后用一个辅助的队列，每一次取两个数 $x,y$，然后在队尾加入 $x+y$，每次取数比较原数组未取的数中的第一个与队头，若原数组中的数较小，则原数组的指针 $k$ 往后移一位，否则，队头往后一位。这样，正解就出来了。

不过，虽然桶排实现相对容易，且效率极高，但不易拓展，所以我介绍一种效率略低，但易拓展的排序——基数排序。它是以一个数为基数 $b$，然后第 $k$ 次按照在 $b$ 进制下的第 $k$ 位来排序，从而实现在较低复杂度内排序的。举个例子，有 $12$ 个数：  
`13 23 34 27 19 37 43 22 11 9 21 40`  
取 $b=10$，也就是十进制，当 $k=1$ 时，排序结果如下：  
`40 11 21 22 13 23 43 34 27 37 19 9`  
现在这些数已经按照个位排好序了，接下来，当 $k=2$ 时，排序结果如下：  
`9 11 13 19 21 22 23 27 34 37 40 43`  
这时候，由于最大的数只有两位，所以现在已经排好序了，时间复杂度为 $O((n+b)\log_bn)$，空间复杂度为 $O(n+b)$，看上去不是线性，但是非常接近线性。事实上，在实际中，$b$ 不会取 $10$，因为模运算的效率极低，$b$ 通常取 $256$，这样在 $2^{32}$ 的数以内，只需要排4次。$b$ 不取 $65536$ 的原因是为了卡进一级缓存，效率更高。这道题目的 $a_i\le10^5$，所以排3次即可，码长也只有1.37k（包括前面0.5k的模板）。
```cpp
#include<bits/stdc++.h>
#define int long long//不开LL见祖宗
using namespace std;
const int N = 10000000 + 10;
FILE *fin, *fout;
inline int read(int &x) {//快读和快写，否则10^7忍受不了
	char c = 0; int f = x = 0;
	while (c < 48 || c > 57) {
		if (c == -1) return 0;
		if (c == '-') f = 1; c = fgetc(fin);
	}
	while (c > 47 && c < 58) x = (x << 3) + (x << 1) + (c & 15), c = fgetc(fin);
	if (f) x = -x; return 1;
}
inline void write(int x) {
	if (x < 0) return fputc('-', fout), write(-x);
	if (x > 9) write(x / 10);
	fputc((x % 10) | 48, fout);
}
int n, h, t, k, ans, cnt[256], a[N], b[N];
inline void radix_sort(int a[], int n) {//基数排序
	for (int i = 0; i < 17; i += 8) {//排3次即可
		for (int j = 0; j < 256; ++j) cnt[j] = 0;//每次都要清零
		for (int j = 0; j < n; ++j) ++cnt[(a[j] >> i) & 255];//位与上255，相当于对256取余，优化常数
		for (int j = 1; j < 256; ++j) cnt[j] += cnt[j - 1];//求前缀和
		for (int j = n - 1; ~j; --j) b[--cnt[(a[j] >> i) & 255]] = a[j];//为了优化常数（++x比x++快），下标从0开始
		for (int j = 0; j < n; ++j) a[j] = b[j];//别忘记复制回来
	}
}
signed main() {
	#ifdef ONLINE_JUDGE//在评测机上使用标准输入输出，在本机上使用文件输入输出，方便本机调试
	fin = stdin;
	fout = stdout;
	#else
	fin = fopen("P6038.in", "rb");
	fout = fopen("P6038.out", "wb");
	#endif
	read(n); for (int i = 0; i < n; ++i) read(a[i]);
	radix_sort(a, n);
	for (int i = 1; i < n; ++i) {
		int x, y;
		if ((h == t) || (k < n && a[k] < b[h])) x = a[k++]; else x = b[h++];//这里无法继续常数优化，只能用h++,k++,t++。若a[k]<b[h]，则取a[k]并且k++，否则取b[h]并且h++，下同
		if ((h == t) || (k < n && a[k] < b[h])) y = a[k++]; else y = b[h++];
		b[t++] = x + y, ans += x + y;
	}write(ans);
	return 0;
}
```
当输入的 $n=10^7$，且 $a_i=10^5$ 时，最终的答案为 $23322278400000$，所以即使当 $a_i\le 10^9$ 时，也不会爆LL，所以，可以把 $a_i$ 的范围改为 $a_i\le10^9$，卡掉桶排。  
当 $n=10^7,a_i=10^5$ 时，三种方法的运行时间如下（本机跑得很慢）：

| 使用方法 | 运行时间(s) | 码长(KB) |
| :----------: | :----------: | :----------: |
| 暴力 | $62.17$ | $0.90$ |
| 桶排 | $10.22$ | $1.26$ |
| 基排 | $10.97$ | $1.37$ |
可以看到，基排的效率也是很高的（侧面突出洛谷评测机的速度快，在洛谷上基排最慢的点仅0.54s），且码长也较短。