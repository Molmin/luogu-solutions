### 这道题我们可以用枚举的思路来做
### 先来理一理我的思路
#### 1.用通排把这些数按顺序排列
#### 2.枚举出合并果子最小值的方案数
#### ·有三种可能
#### 一是两堆果子都没有被合并过
#### 二是两堆果子都被合并过
#### 三是一堆果子被合并过，一堆果子没被合并过
### 只要看看这三种可能哪一种最小，就简单了
### 看了这些还不懂的话，就继续看下面的代码吧


------------

```
#include<bits/stdc++.h>
using namespace std;
long long n,a[10000005],s,b[1000005];
//a,b数组都是用来通排的
long long w[10000005],ans;
//w数组表示已经被合并过的果子，ans表示答案

int main(){
	cin>>n;//果子的堆数
	for(int i=1;i<=n;i++){
	    int o;
	    scanf("%d",&o);
	    b[o]++;
	}
   	//把输入的数统计，通排序的步骤一
	for(int i=1;i<=100000;i++){
    	    //数据最大100000
	    while(b[i]>0){
		s++;
		a[s]=i;
		b[i]--;
	    }
	}
   	//把那些数都存进a数组，桶排序的步骤二
	a[s+1]=10000000000000000ll;
        //让a[s+1]设置成无限大，以免被选中
	for(int i=1;i<=n;i++)
	    w[i]=10000000000000000ll;
        //一样的道理
	long long l=1,r=1;
    	//l表示a数组的指针
        //r表示w数组的指针
	long long p=1;
    	//p表示最终答案w的指针
	for(int i=1;i<s;i++){
    	    //以下就如上面所说的
	    long long x=a[l]+a[l+1];
       	    //两堆果子都没有被合并过
	    long long y=w[r]+w[r+1];
            //两堆果子都被合并过
	    long long z=a[l]+w[r];
            //一堆果子被合并过，一堆果子没被合并过    
	if(x<y&&x<z){
	    l+=2;
            //让指针前进两格，因为a[l]和a[l+1]已经被用过了
	    w[p++]=x;//自加一，且把两堆果子合并成一堆
	}
	else if(y<x&&y<z){
	    r+=2;
	    w[p++]=y;
	}
    	//一样的道理
	else {
	    l++;
	    r++;
            //各用了一个的话就各加一
	    w[p++]=z;
	}
	ans+=w[p-1];
	}
	printf("%lld",ans);
        //一定要用"%lld",不然会被视为int类型
	
	return 0;
}
```
### ~~求过~~
