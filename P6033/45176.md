貌似楼下的解法都说的比较含糊，FCBM71来详细地谈谈这道题的思路。

P1090原题的一般解法是 $O(nlogn)$ 的优先队列（堆）。但是这样做的效率略低，原因是没有利用好答案的单调性。我们也可以利用这一性质将复杂度降低至 $O(n)$。另外，**不开LL见祖宗**   

## 思路分析

我们需要维护两个队列，第一个队列 $q1$ 初始是每堆果子的数（从小到大排序），第二个队列 $q2$ 初始为空。至于它们的作用下面会谈。  

我们都知道本题的贪心策略是，从当前所有果子堆中选择**果子数量最少**两堆合并，成新的一堆。由于样例太弱，所以接下来我们不妨以下面这组数据为例
```
5
3 2 5 6 4 （排序之后就是 2 3 4 5 6）
```

对于第一次合并，我们很显然应该选择最少的两堆合并，即 $q1$ 的队首两个元素 `2` 和 `3`。合并之后得到 `5`。由于我们随时需要维护 $q1$ 队列是单调递增的，所以原来的堆排序的思路（大致）就是二分找 `5` 的位置，将其放回 $q1$。而我们不这样做，我们把 `5` 插入 `q2` 队列队尾。对于以后的每次操作，都把合并之后的数放入 $q2$ 的**末尾**。  

但现在我们有两个队列，那么合并的时候应该选择哪两个数呢？由于排了序，$q1$ 队列始终是**单调不下降**的。那么 $q2$ 队列是否也有这样的性质呢？答案是有的。证明很容易，由于 $q2$ 中的所有数一定是若干的 $a_i$ 相加得到的，而先得到的元素一定是通过较小的 $a_i$ 相加得到的，后得到的元素一定是通过较大的 $a_i$ 相加得到的。  

现在我们知道了它们都有单调性，那么合并时选择的数就很显然了。从 $q1,q2$ **队头**各选择两个数出来，从这四个数中选择较小的两个数合并，将合并得到的数插入到 $q2$ 的**队尾**。如此循环，直到 $q1$ 为空，$q2$ 只剩一个元素。

## 代码实现

为了维护序列的单调，我们需要排序。由于 sort 的复杂度已经达到了 $O(nlogn)$，故需要使用更优化的方式。我们注意到 $a_i\leq 10^5$，故可以用桶排序

```
	for(rg int i=1;i<=n;++i)
	  read(a),++mp[a];
	for(rg LL i=1;i<=1e5+5;++i)
	  for(rg int j=1;j<=mp[i];++j)
	    q1.push_back(i);
 ```
 
接下来就是程序的核心，选择合并与插入。我们每次选择插入有三种策略：`q1[1]+q1[2]` ，`q1[1]+q2[1]` 和 `q2[1]+q2[2]`。我们需要从这三种之中取最优的一种。

```
	rg int n1=n,n2=0;  //n1表示q1长度,n2表示q2长度
    rg LL t[4],c1,c2,c3;  //不开LL见祖宗
	for(rg int i=1;i<n;++i){
		if(n1)t[0]=q1.front(),q1.pop_front(),--n1;   //重要：如果有才取出
		 else t[0]=0;
		if(n1)t[1]=q1.front(),q1.pop_front(),--n1;
		 else t[1]=0;
		if(n2)t[2]=q2.front(),q2.pop_front(),--n2;
		 else t[2]=0;
		if(n2)t[3]=q2.front(),q2.pop_front(),--n2;
		 else t[3]=0;
		if(t[0]&&t[1])c1=t[0]+t[1];else c1=inf;   //枚举三种情况
		if(t[2]&&t[3])c2=t[2]+t[3];else c2=inf;
		if(t[0]&&t[2])c3=t[0]+t[2];else c3=inf;
		if(c1<=c2){    //判断最优情况
			if(c1<=c3){
				ans+=c1;
				if(t[3])q2.push_front(t[3]),++n2;  //重要：将没有用到的放回去
				if(t[2])q2.push_front(t[2]),++n2;
				q2.push_back(c1);++n2;
			}else{
				ans+=c3;
				if(t[1])q1.push_front(t[1]),++n1;
				if(t[3])q2.push_front(t[3]),++n2;
				q2.push_back(c3);++n2;
			}
		}else{
			if(c2<=c3){
				ans+=c2;
				if(t[1])q1.push_front(t[1]),++n1;
				if(t[0])q1.push_front(t[0]),++n1;
				q2.push_back(c2);++n2;
			}else{
				ans+=c3;
				if(t[1])q1.push_front(t[1]),++n1;
				if(t[3])q2.push_front(t[3]),++n2;
				q2.push_back(c3);++n2;
			}
		}
	}
```

最后输出 ans 就结束啦！