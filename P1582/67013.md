 ~~蒟蒻开始瞎写题解划水~~
 
### - 思路
读题之后发现说明了每个瓶子开始有水1升，也就是说最开始瓶子的数量就是水的总量。

因为任意有相同量的水的瓶子可以合并成一个瓶子，所以**2$^n$**个瓶子可以合并为一个瓶子。在减少瓶子到需求值之前，需要先对瓶子进行初步的合并再进行操作。

例如题目中的瓶子数量为3时，可以把3视作**2$^1$+2$^0$**，所以可以合并为两个瓶子；瓶子数量为13的时候可以视作**2$^3$+2$^2$+2$^0$**，所以可以合并为3个瓶子。

因此可以得出初步合并的瓶子数量计算的代码：
```cpp
while(n)
{
	if(n&1)
		now++;
	n>>=1;
}
```


------------

知道了如何初步合并，就应该想办法减少瓶子。

比如样例里的13**（2$^3$+2$^2$+2$^0$）**，想要减少一个瓶子，需要通过增加瓶子来使两个已经瓶子再合并，有两个方法：

一个是增加**2$^2$**个瓶子，让原来装水**2$^2$**升与**2$^3$**升的两个瓶子合并为一个**2$^4$**的瓶子，消耗4个瓶子。

另一个是先增加**2$^0$**个瓶子让**2$^0$**的瓶子变成**2$^1$**的，再增加**2$^1$**个瓶子使**2$^1$**的瓶子与**2$^2$**的合并为**2$^3$**的（实际上会直接会与原来的**2$^3$**的合成一个**2$^4$**的......不过已经达到**now<=k**的目的就没必要继续管了......），消耗3个瓶子。

再考虑一下其他情况，显然从小开始向上加是最优的减少瓶子的方案。

------------

### - 代码实现方式

我是建立一个queue来安照从小到大记录所有合并成的瓶子的大小，然后就可以开始疯狂合并直到达到**now<=k**,因为数据里**k**一定大于等于**1**（不然没法做到合并成0个瓶子），所以一定可以合并完成。

### - 代码
```cpp
#include<cstdio>
#include<queue>
std::queue<int> que;
int n,k,now,x=1,ans;
int main()
{
	scanf("%d%d",&n,&k);
	while(n)
	{
		if(n&1)
		{
			now++;
			que.push(x);//直接就是按顺序存了，非常移动 
		}
		x<<=1;
		n>>=1;
	}
	int a=que.front();
	que.pop();
	while(now>k)
	{
		while(que.front()!=a)//暂时无法与已经有的其他瓶子合并 
		{
			ans+=a;//买a个瓶子 
			a<<=1;//向上组成一个新的 
		}
		while(que.front()==a)//可以继续合并就合并 
		{
			a<<=1; 
			que.pop();//已经合并了，所以就直接变成一个更大的了 
			now--;
		}
	}
	printf("%d",ans);
	return 0;
}
```

~~简单易懂的题解......~~