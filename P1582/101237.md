**本人的第一反应：~~经典的~~进制题**

正如前几位dalao所说，每个瓶子中装的水一定是2^i(i∈N),并且每一个符合题意的解中水的总量转化为二进制后含有的“1”的数量一定不大于k。

看了前几位dalao的分析，本人忽然有了一个~~新~~想法：题目要求满足题意的最小值，也就是说，
### 假设ans为所求，那么ans应满足以下性质：

1、ans转化为二进数后含有的“1”的数量不大于k；

2、ans>=n；

3、∀ans'满足性质1、2，ans<=ans'；

## 那么我们怎么去求这个ans呢？

直接枚举太慢，~~肯定T到飞起~~

我们不妨从二进制的角度考虑这个问题（以下分析均为二进制）。我们要让ans最小但仍大于n，应该使ans的字典序大于n但最接近n。如果此时ans中含有的“1”超过了k，那么只好进位，也只可能进一位。

接下来我们来具体实现。∀m，我们要求字典序大于m且最接近m的数我们应当吧m的最后一个“1”往前推，后面的位清空~~（这个证明不难，相信大家都有这个能力）~~。若前一位为1，直接进位就好。注意，若出现进位，就是两个“1”合并，数字中“1”的数两要-1.一旦出现满足题意的解，结果就呼之欲出了。好了，话不多说，AC代码奉上，详细见注释！

```
#include<bits/stdc++.h>
using namespace std;
string bgn;//本人喜欢字符串，该字符串当然可以用数组替换 
long long n,k;//如题面
long long m;//n的副本 
int l;//二进数长度，
int cnt;//二进数中“1”的个数 
long long ans;//结果（不是最终结果，而是满足题意的最小的数） 
int main()
{
	cin>>n>>k;
	m=n;
	/////////////////////////////////////////////////////////////////十进数转二进数 
	while(m)
	{
		bgn+=(m%2+'0');
		m/=2;
	}
	l=bgn.length();
	bgn+='0';//如果结果进位，这是提前为它准备的 
	for(int i=0;i<l;i++) swap(bgn[i],bgn[l-1-i]);//下标从低位开始 
	//////////////////////////////////////////////////////////////////
	for(int i=l-1;i>=0;i--) if(bgn[i]=='1') cnt++;
	if(cnt<=k)//如果直接可以达到目标，输出0结束 
	{
		cout<<0;
		return 0;
	}
	//////////////////////////////////////////////////////////////////向高位推数 
	cnt++;//推数预处理 
	bgn[0]++;
	for(int i=0;i<l;i++)//从低向高走 
	{
		if(bgn[i]=='2')//进位情况 
		{
			cnt--;//两个“1”合并，“1”的个数-1 
			bgn[i]='0';//本位清空 
			bgn[i+1]++;//前一位+1 
			goto A;
		}
		////////////////本位复原，前一位+1，吧“1”向前推 
		bgn[i+1]++;
		bgn[i]--;
		A:if(cnt<=k) goto B;
	}
	B:;
	////////////////////////////////进位特判 
	if(bgn[l]=='1') l++;
	if(bgn[l-1]=='2')
	{
		bgn[l-1]='0';
		bgn[l]='1';
		l++;
	}
	////////////////////////////////
	////////////////////////////////////////////////二进数转十进数 
	for(int i=l-1;i>=0;i--) 
	{
		ans*=2;
		ans+=bgn[i]-'0';//秦九韶算法 
	}
	//得到最小的瓶子总数（空瓶都没扔）
	cout<<ans-n;
	return 0;
}
```

~~蒟蒻~~第一篇题解，写得不好，大家见谅，谢谢！