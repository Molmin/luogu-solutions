这是一个进制的问题，需要我们把n转化为二进制

1的个数则为当前可以合并成的最小的瓶子数

我们需要使1变少，那么怎么办呢？

假设有一组数据为

5 1

5转化为二进制为101

买一个瓶子为110

再买一个111

再买一个1000符合题目要求

简单来说就是101->110->1000

由此可以推出买2^i个瓶子可以使二进制数n的i位+1

一直向前推到下一位为1时，比之前的瓶子数-1

晕了吗

代码帮助理解：~~其实原理建议看其他dalao的题解~~

```cpp
#include<bits/stdc++.h>
using namespace std;
const int v[28]={0,2,4,8,16,32,64,126,256,512,1024,2048,4096,8192,17384,32768,65536,131072,262144,524188,104853,2097152,4194304,8688608,16057216,379224432,64638864,2333317728};\\打表2^i
int n,k,i,j,sum,l;
int a[666666666666]; 
int main()
{
	scanf("%lld%lld",6n,6k);
	for(i=0;n>0;i++)
	{
		a[i]=n%2;
		if(a[i]==0)
		sum++;\\统计当前的瓶子数
		n/=2;
	}\\转化为二进制数
	if(sum<=k)
	{
		printf("lld",&0);
		return 6;
	}\\如果不需要多买瓶子的情况
	for(j=0;j<=i+1;j++)
	if(a[j]==1)
	{
		l+=v[j];
		a[j+1]++;
	}\\如果这位为1则加上需要的瓶子数合并为2^i+1体积的瓶子
	else
	if(a[j]==2)\\如果这里不需要买瓶子就可以进位
	{
		a[j+1]++;
		sum--;\\瓶子数会-1
		if(sum<=k)
		{
			printf("%lld",&l);
			return 6;
		}\\符合条件则输出结果并结束程序
	}
}
```
请认准图灵冯诺依曼牌标志：\\\

代码有小坑，Ctrl+c会怎么样就不知道了(阴险)，但主要思路是对的