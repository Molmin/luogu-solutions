#这题特别简单，就是二进制模拟，我就不知道为什么要提高省选-难度。

#题目分析：

这道题其实就是二进制，让我们先来看第一个样例：

n=3 m=1

我们先把n转化为二进制，得11。

这就说明n个瓶子能合并成2个瓶子，但由于不满足题意，所以应该再减少一个瓶子。

二进制11想要将它变成只含有一个1的，那么就+1，得100，所以答案就是1。也就是说先从右往左数第一个1的位置+1，再加上其二的方幂，然后继续找，直至满足题意。

再看第二个样例：

n=13 m=2

还是将n转化为二进制，得1101

说明n个瓶子能合并成3个瓶子。

按第一题得到的规律，先从右往左数第一个1的位置+1，再加上其二的方幂，然后继续找，直至满足题意。

第三个样例也是如此：

n=1000000 m=5

将n转化为二进制，得1111 0010 0100 0000

仍按第一题得到的规律，先从右往左数第一个1的位置+1，再加上其二的方幂，然后继续找，直至满足题意。


##代码如下：







```cpp
#include <ctime>
#include <cmath>
#include <cstdio>
#include <string>
#include <cstring>
#include <cstdlib>
#include <iostream>
#include <algorithm>//头文件准备
using namespace std;
int t,n,m;
long long b[70];//定义二进制数组，用于打表
void bit(){//这就是传说中的打表
    b[0]=1;//注意：一定要将b[0]赋为1，要不然按我这种打表法会全部为0
    for (int i=1;i<=62;i++){//好吧，其实不用穷举这么多的，不过怕错，就这样了
        b[i]=b[i-1]*2;
    }
}
void work(){
    int bi[70];//二进制数组
    int x=n,ans=0;
    int k=-1;
    while (x){//将十进制转为二进制，这个直接就是从右往左的
        bi[++k]=x%2;
        x/=2;
    }
    int t=0;
    for (int i=0;i<=k;i++){
        if (bi[i])t++;//穷举它已经合并为多少个瓶子了
    }
    if (t<=m){printf ("0\n");return;}//如果合并的瓶子已经少于或者等于需要的瓶子，那么一个都不要买
    for (int i=0;t>m;i++){
        if (bi[i]>1){bi[i]=0;bi[i+1]++;t--;}//如果b[i]>1（也就是b[i]==2），那么就将它的下一位+1，并且因为两个合并为一个瓶子，所以t--
        if (bi[i]){ans+=b[i];bi[i+1]++;}//如果b[i]==1，那么也将它的下一位+1，但是由于还要买其二的方幂，所以ans要增加，虽然买了一个后是两个合并为一个了，但是增加了一个又减少了一个，所以没变
    }  
    printf ("%d\n",ans);//最后输出ans
}
int main(){
    bit();//二的方幂打表大法
    scanf ("%d %d",&n,&m);
    work();
    return 0;
}
```
完成^\_^

#珍爱生命，拒绝抄袭！
