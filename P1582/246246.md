[P1582 倒水](https://www.luogu.org/problem/P1582)
因为每次都是两个体积一样的瓶子合并，所以k个瓶子里每个瓶子装的都是2的次方的数。而每个2次方的数的二进制都是左边第一位是1，右边的数都是0。

所以**用k个瓶子装的时候就要保证瓶子的数量化成2进制的时候有不大于k个1**.
如k为3的时候可以为装的数量为111,1110,11001以及1的个数小于3的时候。
再看n，**n化成2进制的数的1的数量就要不大于k数量才能刚好装完**。
以样例2位例:
13的2进制是1101，1101有3个1，就需要3个瓶子，而k为2，所以需要加瓶子。
要怎么加呢？一个一个的加太慢了，可以从n的2进制最末尾的1加起，2进制1+1进1取0.
如13的2进制为1101，末位为1，加1为1110，然后加上二进值10，就是10000，1的数量不大于k，符合条件，一共加了3个瓶子，结束。
放代码，剩下的就好理解了：
```c
#include<stdio.h>
#include<math.h>
int lowbit(int n){
	int c=0;
	while(n){
		n-=n&(-n);//计算n的2进制中从左到右最后一位1及后面的0值
		c++;	  //循环相减就可以求得n中1的个数了
	}
	return c;
}
int main(void)
{ 
   int i,n,k,j,ans=0;
   scanf("%d %d",&n,&k);
   while(lowbit(n)>k){
    	ans+=n&(-n);
    	n+=n&(-n);
	}
	printf("%d",ans);
  return 0;
} 
```
