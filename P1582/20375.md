### 二进制下的枚举


若一些瓶子能合并成一个，那么一定有2^x个瓶子


二进制下：


2^1 - 10


2^2 - 100


2^3 - 1000


..

可以推出：X个瓶子，能最少合并成几个瓶子就是二进制1的个数


比如10，二进制为 1010


1010 = 1000 + 10，就是说把10分成8和2，8个可以合成1瓶，2个合成1瓶，所以10最少合成2瓶


所以从N开始枚举，若i二进制1的个数小于等于K，得到解，结束


不过这样枚举会超时


.

### 优化

因为枚举目的是让1的个数尽可能少，所以每次i不要+1了，改为进位


比如当前枚举到1100，下一步应该+100进位，然后就变成10000，少了一个1


总结进位方法：+2^k,k是末尾0的个数


（这不就是树状数组BIT里的lowbit函数嘛！）


所以是 + x&(-x)


再推一下为什么x&(-x)


计算机里用的是补码，-x就是位 取反 再+1


假如一个数...10000,取反之后，应该是....01111


这时候再+1，进位，....10000


此时，与原数比起来，1之前的所有位都取反了，而末尾都是0，但有个进位出来的1是相同的


按位与(&)一下，就得到了那个1.


.

### 技巧





1 1<<i 表示2的i次方

2 (1<<i) & j 表示j的二进制第i+1位

3 C++ 中的 1LL 等同于 (long long)1

.

### 参考代码（0ms）

```cpp
#include <iostream>
#include <cstdio>
using namespace std;

int main() {
    long long N, K, i, j, CNT;
    cin >> N >> K;
    for(i=N; ; i+=(i & -i)) {
        CNT = 0;
        for(j=0; j<64; j++) //long long 是 64位的 
            if(i&(1LL<<j)) CNT ++; //统计1的个数
        if(CNT <= K) break; //满足要求
    }
    cout << i - N << endl;
    return 0;
}

```