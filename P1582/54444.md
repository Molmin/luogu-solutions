很痛苦，看了题解一堆大佬我才发现原来我就是一个只会用蠢方法的小蒟蒻。。。
不管怎么说这个算法也是我自己想出来的。

思路：
首先明确一点，每个瓶中的水量都是2的幂，这个不难证明。
其次，想要瓶子更少，则要尽可能把瓶子合并，这是什么意思呢？
举个例子，输入N=13，K=2，先不考虑购买新瓶子和K，给出13个瓶子的两种合并方案，4 4 4 1和8 4 1。不废话，后者显然更好。
其实也不难证明上面这条的最优性质，总之，我们总是希望尽可能把多的瓶子合并。
实际算法不难，首先把瓶子先进行合并，最后总会得到一个无法再合并的结果，比如上面的8 4 1，但是这时候我们仍有三个瓶子，而数据要求我们最多剩下2个瓶子，所以我们第二步就是对最后两个瓶子进行合并，这时候直接4-1=3，即所求需要购买的瓶子数，于是最后两个瓶子可以合并为一个蓄水量为8的瓶子。

算法设计也比较简单，我这里用的是递归来实现。

func1(n,r):
返回将n个瓶子存入数组f之后，所使用的数组长度，r传入1。
我们在这个函数中找到小于n的最大的2的幂y，这个数字填充数组当前位置，然后再递归调用func1(n-y,r+1)，返回其返回值。
边界条件为n==0，此时直接返回r-1。

func2(n,r):
合并数组f中下标为r~n的瓶子，通常r<=n。
两个边界条件：1.n<r+1，直接返回0，因为n绝对小于r，不需要合并。2.n==r+1，说明要合并的瓶子是相邻的两个，直接将他们合并，然后返回就好了。
如果需要合并且合并的不是相邻两个瓶子，那么我们可以递归地调用func2(n,r+1)，这样会把编号为r+1到n的瓶子合并，于是我们就可以直接再把编号为r和r+1的瓶子合并，注意要计算结果。


```cpp
#include <iostream>
#include <algorithm>
using namespace std;

#define ll long long

ll f[1000];
ll n,k;

ll func1(ll n,ll r)
{
	if(!n)
		return r-1;
	ll y=1;
	while(1)
	{
		ll t=y*2;
		if(t>n)
			break;
		y=t;
	}
	f[r]=y;
	return func1(n-y,r+1);
}

ll func2(ll n,ll r)
{
	if(n<r+1)
		return 0;
	if(n==r+1)
	{
		ll y=f[r]-f[n];
		f[r]*=2;
		return y;
	}
	ll u=func2(n,r+1);
	ll e=f[r]-f[r+1];
	f[r]*=2;
	return u+e;
}


int main()
{
	cin>>n>>k;
	int t=func1(n,1);
	int y=func2(t,k);
	cout<<y<<endl;
	
	return 0;
}
```