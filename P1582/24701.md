
这个绿题好烧脑QAQ，
按照题意1和1可以合并成2,2和2合并成4,4和4合并成8，这不就是游戏[2048](http://2048game.com)吗。我们先让方块尽量合并，如果剩下的比k多，那就新产生一些1，使其合并成为值等于已有的最小的方块，这样那个方块的值×2，如果正好有是它2倍的方块，那就合并，拥有方块数减一，再看有没有它4倍的......，如果没有它2倍的方块，就继续产生1，合并，直到它足够大能与第二小的方块合并。


------------
用二进制表示的话比想象中的简洁，n的二进制为有几个1就代表有几个不同的格子，如（0001001）代表一个1，一个8两个格子。。
t & -t是[二进制表达式中最低位的1所对应的值](https://blog.csdn.net/qq853674765/article/details/70050306)，即最小的格子。
。合并成一个格子所需的1的个数就是格子的值。
我是用go写的，学c++应该能看懂。

------------



```go
package main

import "fmt"

func main() {
	var n, k, ans int
	ans = 0
	fmt.Scanf("%d%d", &n, &k)
	for true {
		var s, t = 0, n
		for t != 0 {
			s++
			t ^= t & -t
		}
		if s <= k {
			break
		}
		ans += n & -n
		n += n & -n
	}
	fmt.Println(ans)
}


```