显而易见的打表题
=

因为$n≤25$，所以直接手算就好惹。

```cpp
int a[26]={0,0,0,0,0,1,1,1,1,3,3,3,6,6,10,10,15,21,21,28,28,35,30,30,27,12}
```

不瞒你说，蒟蒻貌似发现了不像规律的规律。

![](https://cdn.luogu.com.cn/upload/image_hosting/txlhzer1.png)

如图$1$，棋盘上要构成一行、一列或一条对角线，必须要有$5$颗棋子。

所以$n≤4$时，$k=0$。

如图$2$，在已有的基础上，如果要有两条线，则至少需要$9$个棋子。

所以$n≥5$时，$k=0+1=1$。

如图$3$，在已有的基础上，如果要再多一条线，则至少需要$12$颗棋子。

所以，$n≥9$时，$k=0+1+2=3$。

如图$4$，在已有的基础上，如果要再多一条线，则至少需要$15$颗棋子。

所以，$n≥12$时，$k=0+1+2+3=6$。

以此类推……

但是这个规律不能用于所有的数据。

比如答案为$35$时，$35!=28+8$，这一点要注意哦~

最后上代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[26]= {0,0,0,0,0,1,1,1,1,3,3,3,6,6,10,10,15,21,21,28,28,35,30,30,27,12},n;
inline int read() {
	int x=0,f=1;
	char ch=getchar();
	while(ch<'0'||ch>'9') {
		if(ch=='-')
			f=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9') {
		x=(x<<1)+(x<<3)+(ch^48);
		ch=getchar();
	}
	return x*f;
}//快读
int main() {
	n=read();
	printf("%d\n",a[n]);
	return 0;
}
```
