# CF1707B 题解
## 题意
你有一个初始长度为 $n$ 的单调递增序列 $a$。设 $a$ 当前长度为 $l$，你要对 $a$ 作差分，即令 $b_i = a_{i+1} - a_i(1\le i < l)$，然后使 $b$ 序列保持单调递增，接着让 $a_i = b_i(1 \le i < l)$，并继续执行上述操作，直到 $a$ 中只剩下一个元素，输出这个元素。
## 分析
首先想到纯暴力模拟。

但是看到数据范围，$2 \le n \le 2\cdot 10^5$，肯定是会 T 的。

那么会发现，在做差分的过程中，会有 $0$ 的产生。这些 $0$ 显然没有用处，但会影响速度，因此我们可以排除掉这些 $0$ 的存在。

但是单单是这样无法保证答案正确性，想一想是为什么？

我们看到样例中最典型的第三组数据：
```
5
0 0 0 8 13
```
如果我们暴力地去做，会发现过程是

---
`0 0 5 8`

`0 3 5`

`2 3`

`1`

---
答案是 $1$。

但是如果直接排除掉 $0$，就会直接得出了一个错误的答案 $5$。

显然，原因是 $8$ 前面的 $0$ 其实对差分的过程是有影响的。

如果我们保留这个 $0$，仅仅删去前面的 $0$ 的话，过程就是：

---
`0 5 8`

`3 5`

`2`

---
答案仍然是错的。

哦，原来是因为所有的 $0$ 都是对差分有着贡献的！

但是，为了提高效率，我们必须要删去它们。

因此，我们可以定义一个变量 $cnt$，用于记录删去的 $0$。

每次差分前，如果 $cnt > 0$，则说明之前删去过 $0$。

此时，我们可以先将 $a$ 中的第一个元素加入 $b$ 中，这样下次差分的时候，就会产生出一个 $0$ 来。这时我们可以将 $cnt$ 减 $1$，因为如果一直加反而会导致结果的错误。

这时，我们就保证了每次差分之后，如果之前出现过 $0$，则现在 $b$ 的开头一定有一个 $0$。

这样就成功地保证了结果的准确性。
## 实现
建议使用 vector，好用、方便，当然手写数组也可以。

按照上面进行模拟即可。