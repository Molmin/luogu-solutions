提供思路，不一定正确，欢迎各大佬hack

该思路时间复杂度为 $\Theta(n \log n)$（$n,m$ 同阶）。

首先有以下结论：

- 一张卡不能翻 $2$ 次或更多次
  - 显然
- 翻的卡必定是最左侧或最右侧连续的一段
  - 如果没有翻两端的卡而直接翻中间的卡，则显然不会使答案更优

那么有一个显然的 $\Theta(m^2)$ 做法，枚举其中一段翻的卡，然后暴力更新答案。首先要处理`b`数组的前后缀 $\max / \min$（前缀 $\max$ 记为 $L_1$，$\min$ 记为 $L_2$，后缀记为 $R_1$ 和 $R_2$，同理），之后单独处理只有一端翻了卡的情况，然后对于其它情况暴力。

处理其它情况的伪代码如下：

$$\begin{aligned}
&for(i:1 \to m-1)\\
&\quad for(j:n-m+i+1 \to n)\\
&\quad\quad ans\leftarrow\min(ans,\max(a_{j-1},L_{1,i},R_{1,j})-\min(a_{i+1},L_{2,i},R_{2,j}))
\end{aligned}$$

应该不难理解，以下默认已经理解了这种方法。

那么首先把 $\max$ 和 $\min$ 中的 $i$ 和 $j$ 分离出来，就像这样：

$$\max(L_{1,i},\max(a_{j-1},R_{1,j}))-\min(\min(a_{i+1},L_{2,i}),R_{2,j})$$

我们可以设 $l_1=\max(a_{i+1},L_{1,i})$ 和 $l_2=\min(a_{i+1},L_{2,i})$，以及关于 $j$ 的函数 $f_1(j)=\max(a_{j-1},R_{1,j})$ 和 $f_2(j)=\min(a_{j-1},R_{2,j})$。

之后我们把整个过程分成两部分，一个部分处理 $l_1$ 与 $f_1$ 不相交的情况，另一部分处理相交的情况。

对于不相交的情况，对于所有 $l_2$ 按其值**从大到小**排序，然后用一个指针 $p$，初始 $p=n$，然后枚举 $i$ 的同时 $p$ 左移至**第一个**满足 $l_2 \le f_2(p)$ 的位置并更新答案。答案更新方式同暴力。

对于相交的情况，观察到 $l_1$ 与 $f_1(j)$ 的图像大致满足：  
![](https://cdn.luogu.com.cn/upload/image_hosting/svi9rl3g.png)  
那么对于所有 $l_1$ **从小到大**排序（因为€€£的数据水所以也许可以不用排），然后每一次 $l_1$ 上移的时候统计紫色部分（如图）对于的 $j$ 即可。  
![](https://cdn.luogu.com.cn/upload/image_hosting/1jpqo39o.png)  
同样按照暴力的方案更新答案即可。

~~代码太丑就不贴了~~