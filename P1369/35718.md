【这个题显然不是让泥萌N^4跑过去吧.....】

利用前缀和暴力来达到o(n^3)

由于坐标小于100，所以可以统计两个前缀和，一个横向累和，一个纵向累和

（注意，此处定义矩阵为坐标系矩阵，即左下为（1,1），相当于列为x轴）【虽然没差不过说一下大概方便理解吧.......】

这样我们可以暴力枚举一个左边界，一个右边界

|                 |
|                 |
|                 |

（就像这样脑补两条线在矩阵里扫来扫去）

确定左右边界之后，我们要找到一上一下两个线段来封闭，使之成为矩形

枚举一个上方横线

这时，

| . . . . |
|        |
|        |
如果我们可以确定一个下边界，就可以用前缀和来求出边界点数了

下边界可以贪心的维护

如果当前这个线段，其点数，要比两侧的点数加上原下边界点数多，那么让这个线段来做下边界（.....感觉说的不清楚，可以直接看看代码）

代码
    
```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int n;
int s[110][110];
int s1[110][110];
int tmp[110],ans;
int main()
{
    scanf("%d",&n);
    for(int i=1;i<=n;++i)
    {
        int x,y;scanf("%d%d",&x,&y);
        s[x][y]++;
        s1[x][y]++;
    }
    for(int i=1;i<=100;++i)
    for(int j=1;j<=100;++j) s[i][j]+=s[i-1][j],s1[i][j]+=s1[i][j-1];
    for(int l=1;l<=100;++l)
    {
        for(int r=l;r<=100;++r)
        {
            for(int i=1;i<=100;++i) tmp[i]=s[r-1][i]-s[l][i];
            int d=1;
            for(int t=1;t<=100;++t)
            {
                int get=tmp[t]+tmp[d]+s1[l][t]-s1[l][d-1]+s1[r][t]-s1[r][d-1];
                ans=max(ans,get);
                if(tmp[t]>tmp[d]+s1[l][t-1]-s1[l][d-1]+s1[r][t-1]-s1[r][d-1]) d=t;
            }
        }
    }
    cout<<ans<<endl;
    return 0;
}
//我永远喜欢柚子.jpg
//~~~~w~~~~~

```