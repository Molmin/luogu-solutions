### 第一部分：题意简述

一共有 $t$ 组数据。

对于每一组数据，给定两个字符串 $S$，$T$，其中 $S$ 的长度为 $n$ 并且每一个字符都是 `0`，`1` 或者 `-` 这三个字符中的一个。

还有一个初始为空的字符串 $R$。

现在要进行 $n$ 次操作，每一次操作取出 $S$ 的第一个字符 $c$，然后将其在 $S$ 中删除。如果 $c$ 是字符 `-`，那么删除 $R$ 的开头字符或者结尾字符，否则将 $c$ 插入到字符串 $R$ 的结尾。

问有多少种方式让 $R = T$。答案对 $10^9 + 7$ 取模。

$1\le |S|, |T|\le 400$，$1\le t\le 5$。

### 第二部分：Subtask #2 搜索

这一类求总方案数的题，第一眼看上去比较像搜索，但是答案对 $10^9+7$ 取模证明了答案很大，不能直接使用普通的搜索，会超时，可以得到 $30$ 分。时间复杂度为 $O(N\times N!)$。

### 第三部分：Subtask #3 动态规划

那么考虑动态规划。

可以发现序列以下的性质：当 $c$ 为字符 `-` 的时候，要么删除字符串的开头，要么删除字符串的结尾。所以字符串 $R$ 的删除方式一定是在前面连续地删除 $d_1$ 个，后面连续地删除 $d_2$ 个的。

那么可以考虑开一个这样的动态规划数组：$dp[i][j][k][h]$ 代表现在字符串 $S$ 判断到了 $i$ 这个位置，$j$ 是字符串 $R$ 实际有用的字符的数量，$k$ 是 $R$ 现在开头需要删的字符的数量，$h$ 是 $R$ 现在结尾需要删的字符的数量。

由于当 $c$ 是字符 `-` 的时候，$f[i][j][k][h]$ 可以删除开头字符转移到 $f[i + 1][j][k - 1][h]$，也可以删除结尾的字符转移到 $f[i + 1][j][k][h - 1]$。

否则，也就是 $c$ 是字符 `0` 或者是字符 `1` 的时候，就要将字符 $c$ 插入到字符串 $R$ 的结尾，$f[i][j][k][h]$ 可以转移到 $f[i + 1][j][k][h + 1]$。

如果在满足 $c$ 是字符 `0` 或者是字符 `1` 的前提下，有当前 $S$ 字符串枚举到的字符 $c$ 和当前 $T$ 字符串枚举到的字符 $T_j$ 是一样的，并且最后需要删除的字符数量 $h$ 为 $0$，也就是这个字符 $c$ 和答案串的字符 $T_j$ 相同，并且结尾没有需要删除的字符，那么 $f[i][j][k][h]$ 可以转移到 $f[i + 1][j +1][k][h]$ 这个状态。

因此可以发现这是一个区间动态规划类的题。

答案状态：$f[n+1][m][0][0]$。

但是时间复杂度和空间复杂度都是 $O(N^3\times M)$ 的，既会超时又会超空。

### 第四部分：满分算法 状态的优化

由于上面的四维动态规划状态数组会超时超空，所以考虑优化最后一位 $h$ 的状态。

容易发现 $h = i - k - j - 1$，因为删掉不删除的字符，删掉开头的字符，剩下的字符就是结尾的字符的数量 $h$ 了。

那么可以推出一个三维的动态规划状态数组：$f[i][j][k]$。

那么当字符 $c$ 是字符 `-` 的时候，要么删除字符串的开头要么删除字符串的结尾，$f[i + 1][j][k - 1] = f[i + 1][j][k - 1] + f[i][j][k]$，$f[i + 1][j][k] = f[i + 1][j][k] + f[i][j][k]$。

否则，将字符 $c$ 插入到字符串 $R$ 的结尾。$f[i + 1][j][k] = f[i + 1][j][k] + f[i][j][k]$。

如果字符 $c$ 和字符 $T_j$ 相同，并且结尾没有要删除的字符，那么 $f[i + 1][j + 1][k] = f[i + 1][j + 1][k] + f[i][j][k]$。

最后的答案状态：$f[n + 1][m][0]$。

时间和空间复杂度都是 $O(N^2\times M)$ 的，就可以通过这个题了。

友情提示：

>   数据千万条，清空第一条。
>
>   多测不清空，爆零两行泪。
>
>   多测假清空，爆零三行泪。
>
>   卡常反写挂，爆零四行泪。
>   

**Code**

```cpp
#include <bits/stdc++.h>
#define size(s) s.size()

using namespace std;

string S, T;

const int N = 410;
int s_[N];
int f[N][N][N];

void ClearAll() {
    // 多测不清空，爆零两行泪。
    memset (f, 0, sizeof f);
    memset (s_, 0, sizeof s_);
    S.clear(), T.clear();
}

const int mod = (int) 1e9 + 7;

inline int ksm(int a, int b, int c) { // 快速幂
    if (! b)
        return 1;
    int ans = ksm(a, b >> 1, c);
    ans = 1LL * ans * ans % c;
    if (b & 1)
        ans = 1LL * ans * a % c;
    return ans;
}

signed main() {
    int t;
    cin >> t;
    while (t--) {
        int n, m;
        ClearAll();
        cin >> n >> m >> S >> T;
        for (int i = 0; i < size(S); i ++)
            if (S[i] == '-')
                s_[i + 1] = s_[i + 1] + s_[i] + 1;
            else
                s_[i + 1] = s_[i + 1] + s_[i];
        for (int i = 1; i <= n; i ++)
            for (int j = 0; j <= min(i, m); j ++)
                for (int k = 0; k < i; k ++) {
                    int h = i - 1 - j - k - s_[i - 1] * 2;
                    if (h >= 0) {
                        if (i - 1 - s_[i - 1] * 2 == k)
                            if (j == 0)
                                f[i][0][i - s_[i - 1] * 2 - 1] = ksm(2, s_[i - 1], mod); // 初始化
                        if (S[i - 1] ^ '-') {
                            f[i + 1][j][k] = f[i + 1][j][k] + f[i][j][k], f[i + 1][j][k] %= mod;
                            if (j != m && S[i - 1] == T[j])
                                if (h == 0)
                                    f[i + 1][j + 1][k] = f[i + 1][j + 1][k] + f[i][j][k], f[i + 1][j + 1][k] %= mod;
                        } else {
                            if (k)
                                f[i + 1][j][k - 1] = f[i + 1][j][k - 1] + f[i][j][k], f[i + 1][j][k - 1] %= mod;
                            if (h > 0) 
                                f[i + 1][j][k] = f[i + 1][j][k] + f[i][j][k], f[i + 1][j][k] %= mod;
                        }
                    }
                    // cout << i << ' ' << j << ' ' << k << ' ' << f[i][j][k] << '\n';
                }
        cout << f[n + 1][m][0] << '\n';
    }
    return 0;
}

```

