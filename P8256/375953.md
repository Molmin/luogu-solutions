题意：有一个字符串 $S$，$|S|=n$，然后重复 $n$ 次操作：

1. 取出 $c=S_1$，删除 $S_1$。

2. 如果 $c=$‘$-$’，那么删除字符串 $R$ 的第一个字符 $R_1$ 或最后一个字符 $R_{|R|}$。

3. 如果 $c$ 是 $0/1$，那么把 $c$ 插入到 $R$ 的结尾。

4. 保证删除时 $R$ 非空。

最终你需要使得 $R=T$，给出 $S,T$，问有多少种操作方案。

分析：

个人认为正面推理十分低困难，因为难以维护删除开头的操作（自己推一下就知道了）。

不妨反面思考，倒序处理。

如果 $S_i$ 为 ‘$-$’，要么需要删除前面最近的字符，要么删除最开头的字符。

如果 $S_i$ 为 $0/1$，要么被后面的操作删除，要么和 $T$ 匹配。

设 $f(i,j,k)$ 表示假设已经把 $S_1...S_i$ 和 $T_1...T_j$ 匹配，并且已经提前删除了最近的 $k$ 个字符，最终达到 $T$ 的方案数。

类似的 DP 也可以正序直接弄完。当然，如果从反面思考，干脆直接倒着推！

对于当前状态 $(i,j,k)$，思考对哪些状态有贡献。

1. 当 $S_i=-$ 时

删除结尾：$f(i-1,j,k+1)$

删除开头，这时可以考虑不计状态，等到最后匹配完之后，再一一删除：$f(i-1,j,k)$

2. 当 $S_i=0/1$ 时

如果 $k≠0$，必须删除（不删除的话自己可以画几张图，发现删除的不是结尾，而是中间！）：$f(i-1,j,k-1)$

否则，如果还能匹配（$j≠0$），判断是否可以匹配（$S_i=T_j$）：$f(i-1,j-1,0)$

否则说明匹配完了，接下来可以删除开头：$f(i-1,0,0)$

**注意！这样的 DP 还要判断删完后长度是否一致！（如果不信自己可以调一调）否则会被民间数据卡！**

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=410,mod=1e9+7;
int T,n,m,cnt,f[maxn][maxn][maxn];
char s[maxn],t[maxn];
int main()
{
	scanf("%d",&T);
	while(T--)
	{
		scanf("%d%d%s%s",&n,&m,s+1,t+1);
		cnt=0;
		for(int i=1;i<=n;i++)
		{
			if(s[i]=='-') --cnt;
			else ++cnt;
		}
		if(cnt!=m) //判断删除后长度是否一致
		{
			printf("0\n");
			continue;
		}
		cnt=0;
		memset(f,0,sizeof f);
		f[n][m][0]=1;
		for(int i=n;i>=1;i--)
		{
			for(int j=m;j>=0;j--)
			{
				for(int k=0;k<=cnt;k++)
				{
					if(s[i]=='-')
					{
						f[i-1][j][k+1]=(f[i-1][j][k+1]+f[i][j][k])%mod;
						f[i-1][j][k]=(f[i-1][j][k]+f[i][j][k])%mod;
					}
					else
					{
						if(k) f[i-1][j][k-1]=(f[i-1][j][k-1]+f[i][j][k])%mod;
						else if(j)
						{
							if(s[i]==t[j]) f[i-1][j-1][k]=(f[i-1][j-1][k]+f[i][j][k])%mod;
						}
						else f[i-1][j][k]=(f[i-1][j][k]+f[i][j][k])%mod;
					}
				}
			}
			cnt+=(s[i]=='-');
		}
		printf("%d\n",f[0][0][0]);
	}
	return 0;
}
```