### Update
2022.4.7 更改了一个笔误
> 十年 OI 一场空

> 不开 long long 见祖宗

因为 `long long` 的问题，没掉了 QWQ。

本题重点是状态的定义，设 $dfs(i,j,k,l)$ 表示当前执行第 $i$ 个操作，已经匹配了 $j$ 个 字符，左边需要删除 $k$ 个，右边需要删除 $l$ 个。

这里分两种情况讨论：

1. `s[i]=='-'`

此时我们可以减少一次左边或右边的需求，注意需求量不能变成负数。

如果 $k\ne0$，可以从左边满足一个，那么就是 $dfs(i+1,j,k-1,l)$。

同理，如果 $l\ne0$，就可以从右边满足一个，那么就是 $dfs(i+1,j,k,l-1)$。

2. `s[i]!='-'`

此时我们可以直接从末尾把 $s_i$ 删除，即 $dfs(i+1,j,k,l+1)$。

也可以用 $s_i$ 来匹配：此时 $s_i$ 不能被删掉，那么 $y=0$，并且如果要匹配，还有满足匹配的条件：$s_i=t_{j+1}$。那么就是 $dfs(i+1,j+1,k,l)$。

也可以从前面删：因为有可能匹配 $t_1$ 的在后面，此时先满足 $t_1$，那么就一直删前面，所以后面没得删，即 $l=0$。此时要保证前面没有匹配，即 $j=0$，此时就是 $dfs(i+1,0,k+1,0)$。

我们可以知道，$l+k$ 是一个常数，那么我们可以用 $k$ 表示 $l$，那么记忆化只需要三维，即 $dp_{i,j,k}$。

这里给出记搜的代码，用了时间戳后民间和官方数据共计 $2.11$ 秒。
```cpp
int dfs(int i,int j,int k,int l){
	if(i>n)
		return j==m&&!k&&!l;
	if(tag[i][j][k]==tot)//时间戳，注意此处不能开 long long
		return dp[i][j][k];
	tag[i][j][k]=tot;
	long long val=0;
	if(s[i]=='-'){
		if(k)
			val=dfs(i+1,j,k-1,l);
		if(l)
			val+=dfs(i+1,j,k,l-1);
	} else{
		val=dfs(i+1,j,k,l+1);
		if(!j&&!l)
			val+=dfs(i+1,0,k+1,0);
		if(s[i]==t[j+1]&&!l)
			val+=dfs(i+1,j+1,k,l);
	}
	return dp[i][j][k]=val%mod;
}
```