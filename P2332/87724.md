这么好的题就两篇题解……补充一篇新方法。

看到现有的两篇题解都用了~~高深莫测的~~容斥，蒟蒻只想默默地说：我不会容斥，但我会更简单的做法！

后面统计答案就不说了，大家可以参考参考另外两篇很好的题解。我主要分享高维前缀和不用容斥的做法。

我们先看看代码。


```
	for(int i=1;i<=n;++i)
		for(int j=1;j<=n;++j)
			for(int k=1;k<=n;++k)
				mo(a[i][j][k],a[i-1][j][k]); 
	for(int i=1;i<=n;++i)
		for(int j=1;j<=n;++j)
			for(int k=1;k<=n;++k)
				mo(a[i][j][k],a[i][j-1][k]);
	for(int i=1;i<=n;++i)
		for(int j=1;j<=n;++j)
			for(int k=1;k<=n;++k)
				mo(a[i][j][k],a[i][j][k-1]); 
```
其中$mo$函数代表手动取模（为了加速），可以直接理解成：$mo(a,b)=(a+b)$%$mod$

看起来是不是很简单呢？这样我们就避开容斥了！减少了错误的发生~~和思考~~，而且很好记。

但是为什么可以这样写呢？

首先我们知道高维前缀和大部分都是利用容斥原理解决的。

然后呢，三维的我们可以轻松容斥，但是如果有五维的就很容易错了。

但我们知道前缀和的主要思想是后面累加前面的，那么我们可以对每一维进行类似一维前缀和的累加。

所以我们可以用n次循环嵌套，每次统计一维的前缀和。

这样就避免了很麻烦的容斥。因为容斥枚举子集是$2^n$的，四维五维六维的很难不写错。

这样大家应该都懂了吧……已经很详细了。

