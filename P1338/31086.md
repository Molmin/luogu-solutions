#不看题解自己研究得虽然慢，但真正收获的却是自己。
如何让逆序对数为m的序列字典序最小呢？
假设位置p是第一个非原始序列的位置，那这个点应该尽量靠右，才能使得字典序最小。而为了保证有m个逆序对，要求p后面的逆序对数尽量大。怎么才能尽量大呢？当然是降序排列。

这样问题就转成找点p，同时在找到p时还需要知道m-后面所有逆序对数剩余的值，这个值要在点p身上修改。

则我们现在可以直接输出序列。
1）p之前的部分按照顺序输出
2）输出p，如果后面逆序对不够，则需要修改p点再输出。
3）逆序输出p之后的部分，注意如果p之前改点了，需要多判断一下。

```
#include <iostream>
using namespace std;
int main() {
	int n,m;
	cin>>n>>m;
	int p=n,c=0;
	for (int s=1; m>0 ;s++,p--) {
		m-=c=min(s,m);
	}
	for(int i=1;i<p;i++){
		cout<<i<<' ';
	}
	cout<<p+c<<' ';
	for(int i=n;i>=p;i--){
		if(i!=p+c){
			cout<<i<<' ';
		}
	}
	return 0;
}
```