# _~~**滑稽题解第三弹**~~_
大家好，我是一个入门一年还在入门的蒟蒻。

今天我决定不去新手村了，去一下普及练习（虐心）场。

简单数学？看起来貌似不难……

看完这个题我后悔了……简单数学真的不简单……

但是在历经千辛万苦后我还是最终把它调出来了……

说实话这还是我第一次写数学方面的题解，早就听说数学题解难写，我今天就是要尝试一下我到底能不能把数学讲明白（讲不明白预定）

———————————————————————————————————————

### 往期链接：
第一弹：一个红题带你了解绿（黄）题知识点 ([传送门](https://www.luogu.org/blog/funny-talk/funny-solution-p1427))

第二弹：从搜索到贪心——求解算法的优化（[传送门](https://www.luogu.org/blog/funny-talk/funny-solution-p1478)）

———————————————————————————————————————


------------
## 1.基本知识
### （1）逆序对
逆序对是啥？这东西说难不难，说简单也不简单。逆序对就是在一个数列当中，满足$i<j$且$a_i>a_j$($i>j$且$a_i<a_j$)的数对的个数。

逆序对最常见的求法就是归并排序求逆序对个数。（归并排序这里先不普及了）为什么归并排序能够做到这一点呢？因为逆序对的个数是可以递归地求解的：

$[l,r]$中的逆序对可以分为三类：

1. 数对的两个数都在$[l,mid]$中的逆序对
2. 数对的两个数都在$[mid+1,r]$中的逆序对
3. 数对中的两个数一个在$[l,mid]$中，一个在	$[mid+1,r]$中的逆序对

前两种好说，递归求解就是了，递归终点就是$l==r$（长度等于1的数列不可能有逆序对的，连两个数都没有）。第三种就不能再把锅甩给递归了。但是归并排序有个美妙的性质：合并有序数列的时候，如果在前面的数列未空时先插入后面的数列的数的话，就意味着前面的数列中所有还未插入的数都依次和这个后面数列的正在插入的数构成逆序对（因为前面的数排位比这个数靠前但是比这个数大）。

因为这不是本题的重点，就不细讲了。下面给大家一段归并排序求逆序对的代码，大家自行学习一下吧。

~~PS：下面的代码可以AC P1908（我相信你不会道德败坏到直接抄过去的）~~
```cpp
#include<iostream>
#include<queue>
using namespace std;
int n,a[500005];
queue<int> cup;
long long guibing(int l,int r){
    if(l==r) return 0;
    int mid=(l+r)/2;
    long long ans=0;
    ans+=guibing(l,mid);
    //求解数对的两个数都在[l,mid]中的逆序对
    ans+=guibing(mid+1,r);
    //求解数对的两个数都在[mid，r]中的逆序对
    int l_now=l,r_now=mid+1;
    //下面开始求解数对中的两个数一个在[l,mid]中，一个在[mid+1,r]中的逆序对
    while(l_now<=mid&&r_now<=r){
    //其实归并排序用for循环来写最简单也最不容易出错，这里为了便于理解使用while写法
        while(l_now<=mid&&a[l_now]<=a[r_now]){
            cup.push(a[l_now++]);
        }
        while(r_now<=r&&a[r_now]<a[l_now]){
            cup.push(a[r_now++]);
            ans+=(mid-l_now+1);
            //前面数列中所有没插入的数都和当前插入的数构成逆序对
        }
    }
    if(l_now<=mid)
    while(l_now<=mid){
        cup.push(a[l_now++]);
    }
    if(r_now<=r)
    while(r_now<=r){
        cup.push(a[r_now++]);
    }
    for(int i=l;i<=r;i++){
        a[i]=cup.front();
        cup.pop();
    }
    return ans;
}
int main(){
    cin>>n;
    for(int i=1;i<=n;i++){
        cin>>a[i];
    }
    cout<<guibing(1,n);
    return 0;
} 
```

### （2）全排列
给定一个1~$n$的数列，求这个数列打乱后的所有可能的组成方式，就是全排列。比如1~3的全排列就有6种：123，132，213，231，312，321。

一个长度为$n$的数列的全排列有多少种呢？这也很好想，我们使用给各个位置依次确定数的方式来求解。对于第一位，我们有$n$种选择，因为此时所有的数都没有被确定到某个位置上；对于第二位，我们有$n-1$种选择，因为这时候有一个数已经被确定到第一位上了，所以还剩$n-1$种选择；那么这样类推的话，第i位就有$n-i+1$种选择，每个数位的选择数乘起来（因为每位的选择数是基于前一位的基础上求出来的），就是$n!$种结果了。

全排列的所有情况可以按照将这个数列的每一个数都按顺序对应转换为$n+1$进制数的一个数位后得到的数的大小来进行排序（简而言之就是将数列中的每个数都想成一个ASCII码（这个数很可能大于127）后将各数列按字典序排序）。基于这种排序方式的全排列推导非常之麻烦，我也没有去研究，因为没有必要，美妙的<algorithm>库已经给我们准备好了一个高效实用的函数：next_permutation()。

next_permutation()的参量有两个，前一个是进行求解的数组的第一位的指针，后一个是进行求解的数组的最后一位的后一位的指针（也就是一个前闭后开的区间）。对于数组要格外注意你是从0开始存储的还是从1开始存储的，但对于STL就没有这么多麻烦，如果你要求解下一个排列的数组是整个vector（或者其他支持单点查询的STL数据结构），那你只需要第一个参量传入$.begin()$，第二个参量传入$.end()$就完事了。

更智能的是当你的待处理数列已经是最大的全排列（即已经是一个单调递减的数列）时，这个函数就不会再对数列进行处理了，并返回**false**。而如果你的数列还可以进一步求下一全排列的话，就会进行排列并返回**true**。

当然了，如果你想将当前数列转换为前一排列，用prev_permutation()就好了。

------------
## 2.题目解法
### （1）monkey solve
不知道大家有没有听说过一种排序叫猴子排序（monkey sort，时间复杂度是$O(n!)$的）……

最简单易懂的做法，也是最容易的想法，就是模拟这个日历的演进方式了。从一个1~$n$顺次增大的序列开始，每过一天就判断一下逆序对的个数是不是$m$，就可以了。那不就简单了，把上面给的求逆序对模板的main函数魔改一下，不就是这题的代码了吗？
```cpp
#include<iostream>
#include<algorithm>
#include<queue>
using namespace std;
int n,m,a[50001],b[50001];
queue<int> cup;
long long guibing(int l,int r){
//原封不动的求逆序对模板
    if(l==r) return 0;
    int mid=(l+r)/2;
    long long ans=0;
    ans+=guibing(l,mid);
    ans+=guibing(mid+1,r);
    int l_now=l,r_now=mid+1;
    while(l_now<=mid&&r_now<=r){
        while(l_now<=mid&&a[l_now]<=a[r_now]){
            cup.push(a[l_now++]);
        }
        while(r_now<=r&&a[r_now]<a[l_now]){
            cup.push(a[r_now++]);
            ans+=(mid-l_now+1);
        }
    }
    if(l_now<=mid)
    while(l_now<=mid){
        cup.push(a[l_now++]);
    }
    if(r_now<=r)
    while(r_now<=r){
        cup.push(a[r_now++]);
    }
    for(int i=l;i<=r;i++){
        a[i]=cup.front();
        cup.pop();
    }
    return ans;
}
int main(){
    cin>>n>>m;
    for(int i=1;i<=n;i++){
        b[i]=i;
    }
    while(guibing(1,n)!=m){
    //模拟日历一天天的进程
    	next_permutation(b+1,b+n+1);
        //下一天
    	for(int i=1;i<=n;i++) a[i]=b[i];
        //求逆序对不能把原数组排序
    }
    for(int i=1;i<=n;i++){
    	cout<<b[i]<<" ";
    }
    return 0;
}
```

但是这样子的话，如果题目卡你一波极限数据（也就是日历的最后一天逆序对个数达到最大时的个数），那你这个算法的时间复杂度就会原地直线起飞，变成$O(n!~log~n)$的复杂度。因为我们前面讲过，全排列一共有$n!$种，每次求逆序对的复杂度是$O(n~log~n)$的，乘起来就是$(n!+1)~log~n$次运算，也就是$O(n!~log~n)$的时间复杂度。事实就是，上面的代码交上后TLE了八个数据点。
### （2）正解
~~_我知道你们读了这么久一直在期待这个。_~~

有人会问，你之前讲了那么多东西，什么逆序对，全排列，有什么用吗，我们自己去查不就好了？但其实上面讲的基础知识并非毫无用处，正解就在其中：

我们每将一个无逆序对的数列（即所有数都单调递增）中两个数交换时，就会使得数列不再单调递增，也就产生了逆序对。而求下一排列的本质不就是将数的顺序交换吗？

所以这题的正解不是让你模拟日历，然后每天求逆序对，而是让你根据数学原理来造题目所要的数列。

那怎么造呢？这个地方就有点难想了。想一下我们之前讲过的求全排列个数的思想：按位确定数的位置。这题的关键也和之前讲过的归并排序求逆序对的个数的方法类似：如果我们按照所求数列的位置从前向后的顺序确定了一个数$a_i$的位置,那么所有还未确定的数中所有小于$a_i$的数都和$a_i$构成了逆序对（$a_i$比这些数都大，但是却排在这些数的前面）。简单来说，如果我们在一个从0开始存放的数组$a$里存放所有还未确定位置的数的话，那么在某个位置放置$a[i]$的话，就意味着会和数组里排在$a[i]$前的$i$个数产生$i$个逆序对。

但是这还没结束，因为我们还没定下来给各个位置安放数的标准。其实接下来就很简单了，只要你能明白上面讲的关键部分，下面其实就很好想了。按照上面的理论，我们很容易知道一个长度为$n$的数列最多可以产生$\sum_{i=1}^{n-1}$（即1 ~ $n-1$的所有自然数的和）个逆序对。这个题要求我们在产生$m$个逆序对的同时使得数列的字典序最小，但是字典序小的数列逆序对又不一定多，所以这就要求我们贪心地来安放：我们设在当前位置$i$还未产生的逆序对个数为$k$：如果剩下的长度为$l$的数列能够产生的逆序对个数也就是$\sum_{i=1}^{l-1}$（也就是$\frac{l(l-1)}{2}$）比$k$大的话，我们就可以把当前最小的数也就是$a[i]$放到当前位置上（接下来的$l$个数足够产生）；否则就将$a[k-\frac{l(l-1)}{2}]$放到当前位置上，来产生$k-\frac{l(l-1)}{2}$个逆序对（在当前位置放置$a[k-\frac{l(l-1)}{2}]$可以使字典序最小）（如果还是放最小的数的话接下来无论如何也不可能产生$k$个逆序对了），这样子再继续解决下一个位置就好了。

所以这题就是要我们维护一个数组，来存放所有未确定位置的数，然后从前向后贪心地确定所求数列各位置的数就好了。

维护也不难，C++自带的STL库里有种数据结构叫vector就支持单点删除，复杂度是$O(n)$的，叫$.erase()$，括号里传入的是要删除的数据点的迭代器（相当于指针）。

我的代码如下：
```cpp
#include<cstdio>
#include<vector>
using namespace std;
long long n,m,s,now;
//因为n*(n-1)很可能大于int范围，所以用long long 
vector<int> v;
int main(){
    scanf("%lld %lld",&n,&m);
    for(int i=1;i<=n;i++) v.push_back(i);
    s=(n*(n-1))>>1;
    //计算能够产生逆序对的个数
    for(int i=n-1;i>=0;i--){
        s-=i;
        //计算接下来的数列最多能产生逆序对的个数
        if(m>s){
        //如果接下来的数列产生的逆序对个数不够用的话
            now=m-s;
            m=s;
        }else now=0;
        printf("%d ",v[now]);
        v.erase(v.begin()+now);
        //这个数既然用过了，那就将它从未安排的数组中删除
    }
    return 0;
}
```
### （3）优化
如果你仔细阅读上面的题解的话，你就会发现，这个数列可以分为三部分：

1. 从1到某个数的连续自然数上升序列
2. $m-\frac{l(l-1)}{2}$
3. 剩余数组成的单调递减序列。

这也很好解释：首先我们贪心，使得字典序尽可能小，那么必然得到第一部分；之后开始出现剩余数能构成的逆序对个数不够的情况，这时必然还有m个逆序对未产生，所以得到第二部分；剩下的数为了构成$\frac{l(l-1)}{2}$个逆序对，必然要单调递减，于是得到第三部分。

上面的标程用了400多毫秒，下面的优化算法只用了40多毫秒
```cpp
#include<cstdio>
#include<vector>
using namespace std;
long long n,m,s,i,j,k;
bool use[50005];
int main(){
    scanf("%lld %lld",&n,&m);
    s=(n*(n-1))>>1;
    for(i=1;i<=n;i++){
    //打印第一部分
        s-=(n-i);
        if(m>s){
        //终止第一部分的打印，打印第二部分
            printf("%lld ",i+m-s);
            use[i+m-s]=true;
            break;
        }
        printf("%lld ",i);
        use[i]=true;
    }
    for(j=n,k=n;j>i;j--,k--){
    //打印第三部分
    	if(use[k]){
    		j++;
    		continue;
        }
        printf("%lld ",k);
    }
    return 0;
}
```


------------
看完这篇题解，你有没有对数学有更好的理解了呢？好的，本期的_~~**滑稽题解**~~_到这里就结束了。让我们下期再见吧！