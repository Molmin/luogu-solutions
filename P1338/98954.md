这道题需要对排列有深刻的理解和认识

给出逆序对的个数，求改逆序对个数的字典序最小的排列

那么既然是最小，那么一开始一段肯定是升序，一直到某个数后才开始改变

即$1$ $2$ $3$$……$ $n-1$ $n$ $a$ $b$ $c$ $d$$……$

类似这样

那么我们要求出这个$n$在哪里

要字典序最小，就需要$1$到$n$这一段最长

也就是说在$a,b,c,d$后面有尽量多的逆序对

当数列为$n$ $n-1$ $n-2$$……$$1$时逆序对最多

逆序对个数就是$n-1+n-2……+1$

那么我们就可以从小到大枚举$a$ $b$ $c$$……$的长度，算出最多逆序对的个数

找到一个临界值，即第一次逆序对个数第一次大于$m$的时候
这个时候就可以根据长度求出$n$了

所以$1$到$n-1$直接输出

为什么不输出$n$呢

因为不一定后面的逆序对刚好为$m$

所以需要对$n$这个位置做调整，使得逆序对为$m$

设从$n+1$开始往后的长度逆序对个数为$len$(注意不包括$n$)
那么假设$m-len=x$

那么n的位置就输出$n+x$

因为后面的序列是$n+1n+3……$

比$n+x$小的有$n+1,n+2……n+x-1$刚好$x$个数

就把差值补上来了。

然后后面就逆序输出就行了。

具体看代码
```cpp
#include<cstdio>
#include<algorithm>
#define REP(i, a, b) for(int i = (a); i < (b); i++)
#define _for(i, a, b) for(int i = (a); i <= (b); i++)
using namespace std;
const int MAXN=51234;
int a[MAXN],n,m;
int main()
{
    scanf("%d%d",&n,&m);
    int p=n,c;
    for(int s=1;m;p--,s++)
    {
        if(m>s) m-=s;
        else {c=m;m=0;}
    }
    REP(i,1,p) printf("%d ",i);
    printf("%d ",p+c);
    for(int i=n;i>=p;i--)
        if(i!=p+c)
            printf("%d ",i);
    puts("");
    return 0;
}
```