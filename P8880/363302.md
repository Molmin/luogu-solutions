写一篇题解纪念一下我赛时写的 $O(n)$ 乱搞做法。~~官方题解竟然是 $O(玄学)$ 的模拟退火，差评。~~

首先，可以证明，当 $n$ 是偶数时必然无解。[官方题解](https://www.luogu.com.cn/blog/zhouyuhang/wu-zhi-shi-di-hui-yuan-shen-ti-xie)已经写得够详细了，不再赘述。

接着我们发现，因为 $c$ 是一个确定各元素但不确定顺序的排列，我们只要放在输出时处理就好了。

现在要考虑的就是如何利用取模来造出一个 $1$ 到 $n$ 的排列。

接着我们尝试手造几组小奇数数据：当 $n=3$，可以参照样例构造。而当 $n=5$，我造出了这样的一组解：

```
a = {0, 1, 2, 3, 4}
b = {1, 2, 3, 4, 0}
c = {1, 3, 0, 2, 4}
```

发现 $a, b$ 两个数组可以通过错开 $1$ 位的方式来构造出 $n$ 个不同的数。接下来我们证明对于任何奇数都可以通过这种方式构造出一组合法解。

我们钦定 $a_i=i-1$，$b_i=i\bmod5$，$n\geq3$。则 $c_1=0+1=1$。显然，前 $\dfrac{n-1}{2}$ 项构成了一个公差为 $2$ 的等差数列。由于小于 $n$ 的奇数共有 $\dfrac{n-1}{2}$ 个，我们就可以不重不漏地构造出所有符合条件的奇数。

接下来我们考虑第 $\dfrac{n+1}{2}$ 项。则 $c_i=(a_i+b_i)\bmod n=\dfrac{(n+1)+(n-1)}{2} \bmod n = 0$。通过这种方式，我们构造出了 $0$。

与上面同理，后 $\dfrac{n+1}{2}$ 项是一个等差数列，包含小于 $n$ 的所有偶数。这样，我们就构造出了所有小于 $n$ 的非负整数。

接下来就是输入并定位每一个 $c_i$ 在原数组中的位置。我的实现方式是把 $c$ 的每个元素的位置计算出来并存入新的 $c$ 数组。这非常容易实现，见代码。

```cpp
# include <iostream>
using namespace std;
int a[100001], b[100001], c[100001];
int n;

int cal(int x){
    if(x & 1)
        return (x >> 1) + 1;
    return ((x + n) >> 1) + 1;
}

int main(){
    cin >> n;
    if (n % 2 == 0){
        cout << -1;
        return 0;
    }
    for (int i = 1; i <= n; i++){
        a[i] = i;
        b[i] = i - 1;
        cin >> c[i];
        c[i] = cal(c[i]);
    }
    a[n] = 0;
    for (int i=1; i <= n; i++)
        cout << a[c[i]] << ' ';
    cout << endl;
    for (int i = 1; i <= n; i++)
        cout << b[c[i]] << ' ';
    return 0;
}
```