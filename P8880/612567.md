这是一道有趣的题目（~~且很水~~）。

首先让我们来看一下这道题最大的特点：每组 $abc$ 之间相互独立。（比如题目中给出的例子，第二行究竟是 $2 1 0$ 还是 $0 1 2$ 不影响我们求解的速度，因为反正都是把 $0$、$1$、$2$ 对应的 $a$ 和 $b$ 求出来。）

那么弄清楚这一点，我们就可以暂时先抛开第二行输入的顺序，根据第一行输入的 $n$ 计算从 $0$ 到 $n-1$ 的对应 $a$ 和 $b$。

首先，非常清晰的一点在于，当 $n$ 是偶数时，直接输出 $-1$ 即可。从数学上很容易证明这一点：集合 $a$ 和集合 $b$ 的元素和加在一起为 $n\times(n-1)$ ，其对 $n$ 取模为 $0$ ；然而 $c$ 集合中的元素和为 $\dfrac{n\times(n-1)}{2}$ ，当 $n$ 为偶数时模 $n$ 余 $\dfrac{n}{2}$ ，当 $n$ 为奇数时模 $n$ 余 $0$ 。也就是说我们只需要考虑 $n$ 为奇数的情况。

这种情况下有一种思路变得合适了起来：即以下标为 $0$ 的位置作为起点，设 $a_{0}$ 为 $0$ ，$b_{0}$ 为 $0$ ，并在循环时，每当 $i$ 加 $1$，就让 $a$ 数组的值加 $2$，$b$ 数组的值减 $1$。如此循环，即可得到两个合适的数组。这种数组的生成方法必然成立，因为 $+2-1$ 与 $+1$ 并没有任何区别。

最后放代码。
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=1e5+5;
long long n;
long long a[N],b[N],c[N];
int main()
{
	ios::sync_with_stdio(false);
	cin >> n;
	if(!(n&1))//相当于对2取模，这样速度快于直接写%
	{
		cout << -1;
		return 0;
	}
	for(int i=0;i<n;i++) cin >> c[i];
	a[0]=1;
	b[0]=n-1;
	for(int i=1;i<n;i++)
	{
		a[i]=a[i-1]-1;
		if(a[i]<0) a[i]+=n;
		b[i]=b[i-1]+2;
		if(b[i]>=n) b[i]-=n;
	}
	for(int i=0;i<n;i++) cout << a[c[i]] << " ";//输出时对输入顺序简单处理即可
	cout << endl;
	for(int i=0;i<n;i++) cout << b[c[i]] << " ";
	return 0;
}
```
------------
本蒟蒻的第一篇题解，求过求过！！