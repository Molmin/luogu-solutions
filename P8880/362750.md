做这题首先要搞清楚一点：**这个排列给了和没给是一样的，因为你把它和答案同时随意打乱顺序都满足条件。**

于是我们考虑什么时候输出 `-1`。

这个 `-1` 不可能是由排列而来的，所以我们想到通过 $n$ 判断。判断什么呢？判断其奇偶性。

当 $n$ 为偶数时，原排列可以重组为 $0\sim n-1$ 依次排列。也就意味着我们构造出的 $a,b$ 排列之和需要满足其奇偶性为 `偶 奇 偶 奇……`。而奇数能等于偶数加奇数，偶数等于偶数加偶数或奇数加奇数，所以简单手玩一下就能发现，我们无法使得奇偶性满足，也就意味着 $n$ 为偶数时输出 `-1`。

当 $n$ 为奇数时，非常显然的，我们对 $0\sim n-1$ 内每个数对 $2$ 做模 $n$ 意义下除法，即可得到一个新排列。新排列的两倍即为原排列，于是我们得到答案。

代码：

```cpp
#include <bits/stdc++.h>

using namespace std;

const int maxn = 1e5 + 1;

int n;
int a[maxn];

int main() {
    cin >> n;
    for (int i = 1; i <= n; i++) {
        cin >> a[i];
    }
    if (!(n & 1)) return (puts("-1"), 0);
    for (int i = 1; i <= n; i++) {
        cout << (a[i] & 1 ? a[i] + n >> 1 : a[i] >> 1) << " ";
    }
    cout << endl;
    for (int i = 1; i <= n; i++) {
        cout << (a[i] & 1 ? a[i] + n >> 1 : a[i] >> 1) << " ";
    }
    cout << endl;
    return 0;
}
```