## 前言 & 前置芝士

~~这是我 A 的最快的蓝题。~~

菊花图：除了根节点外所有点最多都只有一个儿子的树。听起来很玄学是吧，上图。

![](https://cdn.luogu.com.cn/upload/image_hosting/02ms435x.png)

## 题目描述

树是一个没有环的无向连通图，**注意**，在本题中，我们讨论的是无根树。

现有四个整数 $ n, d_{12}, d_{23} $ 和 $ d_{31} $。 构建一颗满足以下条件的树:

- 包含从 $ 1 $ 到 $ n $ 的 $n$ 个节点。
- 从节点 $ 1 $ 到节点 $ 2 $ 的距离（最短路的长度）为 $ d_{12} $，
- 从节点 $ 2 $ 到节点 $ 3 $ 的距离为 $ d_{23} $。
- 从节点 $ 3 $ 到节点 $ 1 $ 的距离为 $ d_{31} $。

输出满足条件的任意一棵树；若不存在，请~~证明~~。

## 分析

看到一棵树，而且还限制最短路的长度，不难想到菊花图。因为在此图中，对于任意点 $x$ 和 $y$ 满足 $LCA(x,y)=rt$，它们的最短路长度就是 $d_x+d_y$，其中 $d$ 表示当前点距离菊花中心 $rt$ 的距离。通俗来说，就是不在同一条枝上的两点的最短路，必定经过中心 $rt$。

考虑构造出的树就是菊花图，那么可以得出一个显然的结论：

$\left\{\begin{matrix} d_{12} = d_1 + d_2\\ d_{13} = d_1 + d_3\\ d_{23} = d_2 + d_3\\ \end{matrix}\right.$

~~由小学数学~~，我们可以轻易算出 $d_1,d_2,d_3$，于是我们就可以初步画一个图。

![](https://cdn.luogu.com.cn/upload/image_hosting/nqckq8y2.png)

那么，我们如何求出 $rt$ 的值呢？显然，当存在 $d_i=0$ 时，点 $i$ 即为中心；否则我们任取一点，如 $n$ 作为 $rt$ 即可。

接下来问题就很简单了，我们只要把每一个 $d_i$ 遍历一遍，往里面塞一些点即可。具体在实现时，我们可以记录当前未用点为 $cnt$，初始为 4，遍历 $d_i$ 过程中累加即可。注意最后一步需要特判，即最后连向 $rt$ 的那条边，要保证 $i$ 不是 $rt$。

但是，我们现在只用了 $cnt-1$ 个点，剩下的点怎么办呢？为了保证最短路，我们只需要把它们直接连至 $rt$ 即可。

最后还有一个问题，那就是对无解的判断。不难发现，当 $d_i$ 不是非负整数时，就是无解。考虑当前构所需造总点数，可以算出是 $d_1+d_2+d_3+1$ 个，特判是否 $\le n$ 即可。

## Code
```
#include<bits/stdc++.h>
using namespace std;
int T,a[10];
void solve(){
	int n,x,y,z;
	scanf("%d%d%d%d",&n,&x,&y,&z);
	int rt=n,cnt=4;//初始化
	a[1]=(x+z-y)/2;
	a[2]=(x+y-z)/2;
	a[3]=(y+z-x)/2;//求解d数组
	if((x+y+z)%2!=0||a[1]<0||a[2]<0||a[3]<0||a[1]+a[2]+a[3]+1>n)
	 return void(puts("NO"));//特判无解
	puts("YES");
	for(int i=1;i<=3;i++) if(!a[i]) rt=i;//记录rt
	for(int i=1;i<=3;i++){
		int p=i;
		for(int j=1;j<a[i];j++)
		 printf("%d %d\n",p,cnt),p=cnt++;//先塞中间的点
		if(a[i]) printf("%d %d\n",p,rt);//特判末位
	}
	while(cnt<=n)//处理余下的点
	 if(cnt==rt) cnt++;//注意对子环的判断
	 else printf("%d %d\n",cnt++,rt);
}
int main(){
	scanf("%d",&T);
	while(T--) solve();
	return 0;
}
```