### $\Theta\left( n\right)$复杂度 

看样子，是一道模拟，实际想一想就可以推出公式。（实际好像还是模拟）

#### 简化题意：
有一张 $ M * N $ 的图，初始全为**0**，每次操作对一行或一列进行**取反**，求进行任意次操作后能否有 $ K $ 个点为**1**。

#### 解法：

先明确一下，如果对某一行（列）操作两次就等于没操作，所以以下不考虑对同一行或列重复操作。

如果先对一行进行操作，那么就一共有 $ M $ 个点。
同理对 $ X $ 行进行操作，就有 $ X*M $ 个点（不考虑列）。
在这个基础上，对一列进行操作会增加 $ N-X $ 个点，但在这同时却破坏了每一行的一个点。

根据这个就可以推导出一共有 $ (M-y)\times x+(N-x)\times y $ 个点.

（ $ M $ 是总行数， $ N $ 是总列数， $ x $ 是对 $ x $ 行进行操作， $ y $ 是对 $ y $ 行进行操作）。

化简为 $ X*M+Y*N-2XY $。

那么我们只需要枚举 $ X $ 和 $ Y $ 便可以判断。

代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
	int m,n,k;
	bool ans=0;
	cin>>m>>n>>k;
	for(int x=0;x<=n;x++)//枚举x
		for(int y=0;y<=m;y++)//枚举y
		{
			if(x*m+y*n-2*x*y==k)//判断
			{
				x=m+2;y=n+2;//一次跳出两层循环
				ans=1;//成立
			}
		}
	if(ans)cout<<"Yes";
	else cout<<"No";
	return 0;//圆满收工
}
```