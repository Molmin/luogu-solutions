
莫队算法用于处理一些只有询问不用修改的区间问题，这时候我们就有疑问了，区间问题？线段树啊，这不是很好嘛。但是有些情况下，线段树的复杂度我们也接受不了；

比如：给出m个询问[L,R],求区间内出现次数大于等于3的个数？

用线段树的话我们还是要暴力合并左右儿子：

这样就不能直接o（1）从左右儿子转移到父亲，甚至是o(左儿子长度+右儿子长度)

这样用线段树就凉了。

由于只有查询，不用修改，那我们可以尝试离线处理；

如果我们知道了区间[L,R]，那么我们只需要把a[R+1]的出现次数更新，就能更新[L,R+1]的答案；

这样好像我们也能更新[L+1,R],[L-1,R],[L,R-1]；

叮~

您的莫队算法已上线：

莫队算法相对于线段树有更优秀的复杂度：

我们已知区间[L,R],求[L',R']的话，只需要一步步转移，是O(|L-L'|+|R-R'|)

如果我们把每一个区间看成一个二维平面的坐标，那么每次询问的复杂度就是两个点的曼哈顿距离；

我们知道连接n个点的最优策略是一个树，那么我们操作的复杂度就是树上点的曼哈顿距离之和；

最优复杂度就是曼哈顿距离最小生成树；

这样打肯定会特别麻烦，转移的时候还要处理分支情况，还要化为坐标，建边；

那我们还有别的方法在代码量少的情况下又能保证我们的复杂度呢？（不知道你们，反正我是因为懒……）

尝试分块：以左端点为第一关键字，右端点为第二关键字；

分块相同时，右端点递增是O(N)的，分块共有O(sqrt(N))个，复杂度为O(N1.5 )

分块转移时，右端点最多变化N，分块共有O(sqrt(N))个，复杂度为O(N1.5)

分块相同时，左端点最多变化sqrt(N) ，分块转移时，左端点最多变化2sqrt(N)，共有N个询问，复杂度为O(N1.5)
（来自学长的芝士[SiriusRen](https://www.cnblogs.com/SiriusRen/p/6910362.html)）

其实分块的作用就是加速而已，好像也没啥用；

做几道题?

1、[小B的询问（传送门）](https://www.luogu.org/problemnew/show/P2709)

```cpp

题目描述

小B有一个序列，包含N个1~K之间的整数。他一共有M个询问，每个询问给定一个区间[L..R]，求Sigma(c(i)^2)的值,其中i的值从1到K，其中c(i)表示数字i在[L..R]中的重复次数。小B请你帮助他回答询问。
输入输出格式
输入格式：

第一行，三个整数N、M、K。

第二行，N个整数，表示小B的序列。

接下来的M行，每行两个整数L、R。

输出格式：

M行，每行一个整数，其中第i行的整数表示第i个询问的答案。

输入输出样例
输入样例#1： 复制

6 4 3
1 3 2 1 1 3
1 4
2 6
3 5
5 6

输出样例#1： 复制

6
9
5
2

说明

对于全部的数据，1<=N、M、K<=50000

```
直接上莫队，裸题；
记得分块，这样会快很多；

用一个t数组记录当前每个数字出现次数即可，然后每次增加一个点即增加2*t[i]+1;（减小也一样）

但是边界条件要考虑，从区间外向区间里更新时，先更新当前点再++或--；而从区间内部向外部更新就要先++或--；

蒟蒻的码风比较奇特↓

```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
#include<cmath>
using namespace std;
int b[50050],t[50050];
long long ans[50050];
int n,m,k,len;
long long temp;
struct node
{
	int l;
	int r;
	int id;
	int d;
}a[50500];
inline bool cmp(node a,node b)
{
	if(a.id==b.id)
		return a.r<b.r;
	else 
		return a.id<b.id;
}
int main()
{
	scanf("%d%d%d",&n,&m,&k);
	len=sqrt(n);
	for(int i=1;i<=n;i++)
		scanf("%d",&b[i]);
	for(int i=1;i<=m;i++)
	{
		scanf("%d%d",&a[i].l,&a[i].r);
		a[i].id=(a[i].l+len-1)/len;
		a[i].d=i;
	}
 	sort(a+1,a+m+1,cmp);
 	int l=a[1].l;
 	int r=a[1].l-1;
 	for(int i=1;i<=m;i++)
 	{
 		while(l<a[i].l) temp-=2*--t[b[l++]]+1;
 		while(l>a[i].l) temp+=2*++t[b[--l]]-1;
 		while(r>a[i].r) temp-=2*--t[b[r--]]+1;
 		while(r<a[i].r) temp+=2*++t[b[++r]]-1;
 		ans[a[i].d]=temp;
	}
	for(int i=1;i<=m;i++)
		printf("%lld\n",ans[i]);
	return 0; 
 } 
```

2、[小z的袜子（传送门）](https://www.luogu.org/problemnew/show/P1494)


```cpp

题目描述

作为一个生活散漫的人，小Z每天早上都要耗费很久从一堆五颜六色的袜子中找出一双来穿。终于有一天，小Z再也无法忍受这恼人的找袜子过程，于是他决定听天由命……

具体来说，小Z把这N只袜子从1到N编号，然后从编号L到R(L 尽管小Z并不在意两只袜子是不是完整的一双，甚至不在意两只袜子是否一左一右，他却很在意袜子的颜色，毕竟穿两只不同色的袜子会很尴尬。

你的任务便是告诉小Z，他有多大的概率抽到两只颜色相同的袜子。当然，小Z希望这个概率尽量高，所以他可能会询问多个(L,R)以方便自己选择。

然而数据中有L=R的情况，请特判这种情况，输出0/1。
输入输出格式
输入格式：

输入文件第一行包含两个正整数N和M。N为袜子的数量，M为小Z所提的询问的数量。接下来一行包含N个正整数Ci，其中Ci表示第i只袜子的颜色，相同的颜色用相同的数字表示。再接下来M行，每行两个正整数L，R表示一个询问。

输出格式：

包含M行，对于每个询问在一行中输出分数A/B表示从该询问的区间[L,R]中随机抽出两只袜子颜色相同的概率。若该概率为0则输出0/1，否则输出的A/B必须为最简分数。（详见样例）

输入输出样例
输入样例#1： 复制

6 4
1 2 3 3 3 2
2 6
1 3
3 5
1 6

输出样例#1： 复制

2/5
0/1
1/1
4/15

说明

30%的数据中 N,M ≤ 5000；

60%的数据中 N,M ≤ 25000；

100%的数据中 N,M ≤ 50000，1 ≤ L < R ≤ N，Ci ≤ N。

```

这个题一看没啥思路啊，概率题emm……，为啥我想到了生物……；
那我们先写写式子？
设 a,b,c……为每种颜色出现的次数；
答案是：

**(a∗(a−1)/2+b∗(b−1)/2+c∗(c−1)/2....)/((R−L+1)∗(R−L)/2)**

化简一下:

***(a^2+b^2+c^2+……-(a+b+c+……))/(R-L+1)*(R-L)**

那么就是

***(a^2+b^2+c^2+……-(R-L+1))/(R-L+1)*(R-L)**

我们愉快的这个题变成了上一个题；
不一样的地方就是统计答案时，不能用一个数组了，要再开一个结构体，一个存分子，一个存分母；再化简，特判，long long
就差不多了；

很稳

代码就不放了，根据上一个可以自己写出来；

I hope this blog can help you ;







