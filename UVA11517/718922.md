这道题是一道 `dp` 的模板题，就是让我们来凑钱买东西（买东西的钱数可能比要求数大因为可能要找钱，刚开始我没考虑到）。

我们来看样例：
```cpp
1

1400

3

500

1000

2000
```
样例要求我们凑出 $1400$ 元给了我们 $3$ 种钱 $500$ $1000$ $2000$ 此时我是有点疑惑的，这根本凑不出 $1400$ 元来，但看样例输出是 $1500$ 就真相大白了，这就是题目的一个坑点了，并不用刚刚凑出指定数，只要等于或大于指定数就可以了，这就是这道题目的~~特别之处~~。

接下来看思路：

首先范围是小于 $10000$ 我们程序中可以把循环做 $10005$ 次接下来求状态转移方程式：定义状态 $dp(i,j)$ 表示前 $i$ 张钞票凑成 $j$ 元需要的最少钞票张数。则状态转移方程为 $dp(i,j)=\min(dp(i-1,j),dp(i-1,j-a(i))+1)$ 化简一下就是：

$dp[j]=\min(dp[j],dp[j-a[i]]+1)$。

得出方程就可以写代码了。

### 代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
int dp[25000],a[25000],k,n,zsy,t;
int main()
{
    cin>>t;//输入
    while(t--)
    {
        memset(dp,0x3f3f3f3f,sizeof dp);
        dp[0]=0;
        cin>>k>>n;//输入
        for(int i=0;i<n;i++)
            cin>>a[i];
        for(int i=0;i<n;i++)
            for(int j=10004;j>=a[i];j--)//根据数据范围来
                dp[j]=min(dp[j],dp[j-a[i]]+1);
        for(int i=k;i<10005;i++)//跟上一个循环一样
            if(dp[i]!=0x3f3f3f3f)//判断
            {
		zsy=i;
		break;//退出
	    }
        cout<<zsy<<" "<<dp[zsy]<<endl;//输出
    }
    return 0;//结束
}
```
```