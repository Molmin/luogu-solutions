## 【构造】【CF1329A】Dreamoon Likes Coloring

### Analysis

减号写成加号导致 fst，嘤嘤嘤。

首先如果所有颜色都平铺开也不能铺满这 $n$ 个格子，那么显然无解。

考虑由于最后要求所有颜色都至少“露出”一个格子来，那么不妨首先保证所有颜色都有对应的格子，然后进行调整。方法是对于每一个颜色，都尽可能地贴着右侧放。也即第 $i$ 种颜色的右端点放在 $(n - i + 1)$ 格，这样对于每种颜色，都至少露出了最右侧的一个格子。在这个过程中，如果某一个颜色的左端点比 $1$ 小，那么无解（因为第 $i$ 个颜色至少要空出 $(i - 1)$ 个格子给之前的颜色，而在这种构造方式也恰好空出了 $(i - 1)$ 个格子，因此如果这种方式无法构造，那么不会有更优的选择，一定无解）。

先把所有颜色都尽可能往右放以后，发现左侧可能会空出来一部分位置。对于这些位置，我们从后往前用颜色铺满这些位置即可。也即先把编号为 $m$ 的颜色放到 $[1, l_m]$ 去，如果还没有铺满，就把 $(m - 1)$ 号的左端点放到 $(l_m + 1)$ 位置去，以此类推。之前已经判过铺不满了，所以这样一定能铺满。而需要把第 $i$ 个颜色这么处理一定意味着前 $i$ 个颜色的最靠左的左端点比后面几个颜色达到的右端点至少大 $2$。也就是说颜色 $i$ 一定是向左移动的，不会盖住比 $i$ 小的颜色露出的位置。

考虑如何判断是否铺满：在第一个过程中（也即尽可能往右放）维护前 $i$ 个颜色的左端点的最小值 $p_i$，在进行第二个过程时，设当前考虑到第 $i$ 个颜色，如果 $\sum_{k = i + 1}^k l_k < p_i - 1$，那么意味着至少 $p_i - 1$ 这个位置是空着的，需要把第 $i$ 个颜色向左移动。

时间复杂度 $O(n)$。

### Code

```cpp
const int maxn = 100005;

int n, m;
int a[maxn], l[maxn], r[maxn], pl[maxn];

int main() {
  freopen("1.in", "r", stdin);
  qr(n); qr(m);
  qra(a + 1, m);
  ll sum = 0;
  pl[0] = n;
  for (int i = 1; i <= m; ++i) {
    sum += a[i];
    r[i] = n - i + 1;
    l[i] = r[i] - a[i] + 1;
    if (l[i] <= 0) return puts("-1") & 0;
    pl[i] = std::min(l[i], pl[i - 1]);
  }
  if (sum < n) return puts("-1") & 0;
  if (pl[m] != 1) {
    sum = 0;
    for (int i = m; i; --i) {
      l[i] = sum + 1;
      sum += a[i];
      if (sum >= pl[i - 1]) {
        break;
      }
    }
  }
  qwa(l + 1, m, ' ', '\n');
  return 0;
}
```

