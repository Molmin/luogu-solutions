**OI 生涯中的第二十篇题解！！！请多多关照！！！**

这道题有三个限制条件：

$1$、每个格子都要涂上色

$2$、每种颜色都要在全部颜色涂完之后出现

$3$、必须按照给定顺序涂色

很明显这道题是个构造题，我们首先要先判断无解的情况，如果涂色的总个数都凑不齐整个格子数，那么很明显无解，特判掉，对于每一个颜色，一定要有至少一个颜色在每一次之后的涂色都要有所保留，不被覆盖，所以到第 $i$ 次涂色之后你需要留下 $i-1$ 种颜色不被覆盖，每种颜色至少需要留下一个格子，这样你就需要留下至少 $i-1$ 个格子，再加上你第 $i$ 次涂色涂完之后第 $i$ 种颜色肯定是全部出现，所以如果这两种所需格子的总数需要比总格子数还要多的数量的话，那也就无解。

特判完两种无解情况之后，剩下的肯定就是有解的啦，这下你就可以放心地去构造了。。。

可能我们一次构造无法满足三个条件，我们可以先满足 $1$~$2$ 个条件，然后根据这个构造的来进行修改就可以啦！！！

我们可以先满足第 $2$ 个条件（第 $3$ 个条件必须满足，这里不再赘述），而且我们可以先走极端，我们将所有涂的颜色尽量地往右涂，但又得保证这些颜色能全部出现，因为按顺序涂色比较难构造，所以我们可以逆序构造，当第 $i$ 种颜色涂色完毕时，将会进行第 $i-1$ 种颜色地涂色，因为保证它不被覆盖，还得保证它尽可能往右，而且第 $i$ 种颜色已经尽可能地往右了，所以我们可以把它左边的开头设成第 $i$ 种颜色的左边的开头的往左边一个。但是可能会出现第 $i-1$ 种颜色所占格子数太多，开头可能还得往左，这时我们对它们俩的编号取最小值即可。

好了，我们已经构造好一个满足第 $2$ 个条件的涂色方案了，下面我们要让它又同时满足第 $1$ 个条件，就是涂满，因为之前我们是走极端来涂色，所以修改起来变得非常简单，我们先将第 $1$ 种颜色的开头移到第 $1$ 格的位置，然后从第 $2$ 种颜色开始，我们也可以通过走极端的方式，将第 $i$ 种颜色的开头放到第 $i-1$ 种颜色的结尾还要往后一个格子的位置，这样就变成了首尾相连的形态，即一种颜色的涂色到了结尾了之后，下一个格子立马是另一种颜色的开头。这样就能保证都能涂满，而且还能维护之前满足的第 $2$ 个条件的涂色方案，简直是一举两得！！！直到第 $i$ 种颜色的开头在第 $i-1$ 种颜色的结尾或还要往左的位置，这说明已经将格子涂满啦！！！你就可以提前退出循环，然后输出就结束啦！！！

时间复杂度：$O(m)$

**温馨提示**：这个计算涂色的总格子数最大值为 $10^5 \times 10^5=10^{10}>2147483647$ 所以你需要开 **long long**。不然会在第 $6$ 个测试点上 WA 掉。。。

# code：
```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
int a[100005],b[100005];
int main(){
	int n,m,i;
	long long sum=0;
	scanf("%d%d",&n,&m);
	b[m+1]=2147483647; 
	for(i=1;i<=m;i++){
		scanf("%d",&a[i]);
		sum+=a[i];
		if(a[i]+i>n+1){
			printf("-1");
			return 0;
		}
	}
	if(sum<n){
		printf("-1");
		return 0;
	}
	for(i=m;i;i--){
		b[i]=min(n-a[i]+1,b[i+1]-1);
	}
	b[1]=1;
	for(i=2;i<=m;i++){
		if(b[i-1]+a[i-1]>=b[i]){
			break;
		}
		b[i]=b[i-1]+a[i-1];
	}
	for(i=1;i<=m;i++){
		printf("%d ",b[i]);
	}
	return 0;
}
```
