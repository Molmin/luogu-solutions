这题还有个~~脍炙人口的~~名字，叫时代的眼泪


考虑这玩意儿严格难于区间逆序对，因此直接想分块就完事儿了

首先无论哪种做法都要对序列分块，因此我们也这么干

但是发现这里不能直接二离，答案维护不得

因此考虑直接在分块上算

首先每一次询问显然传统艺能五部分贡献：整间、散间、整散、散内、整内

考虑散块都好处理，直接利用二离那套理论把散块往对应位置上挂就行了

详细一点，考虑需要处理的其实就这几部分：

左散块内部+左散块与整块-右散块内部-右散块与整块-两个散块之间

其中前两部分可以合并处理，后三部分也可以合并处理

至于 $[1, i-1]\to i$ 的贡献怎么一一处理，考虑用 `std::vector` 存询问，然后每处理一个弹出然后不断向后跳就行了

然后考虑整块内部，考虑逐块处理，然后最后每个块 $O(m)$ 扫一遍所有询问得出答案

这需要我们 $O(1)$ 查询一些东西，因此要 $O(n)$ 处理出该块所有值域区间的全局答案

考虑先离散化，然后设一个数组 $f[i][j]$ 表示值域离散化后在 $[i, j]$ 间的该块答案

可以用类似二维前缀和的方法 $O(\sqrt{n}^2)=O(n)$ 求出

最后考虑整块间

我们要求的贡献可以看做 $[l, r] \times [l, r]$ 也就是 $([1, r]- [1, l - 1]) \times ([1, r]- [1, l - 1])$

拆开来，就是 $[1, r] \times [1, r] - [1, r] \times [1, l - 1] - [1, l - 1] \times [1, r] + [1, l - 1] \times [1, l - 1]$

再把第二、三项拆成 $([l, r] + [1, l - 1]) \times [1, l - 1] + [1, l - 1] \times ([l, r] + [1, l - 1])$

拆开带回，发现某一项是 $0$ ，因此最后要求的就是 $[1, r] \times [1, r] - [1, l - 1] \times [1, l - 1] - [1, l - 1] \times [l, r]$

前两部分显然是一种求法，后面的是另一种求法

不难发现最后一项由于两个区间不交，显然只与出现次数有关，因此可以在上面求整块内时顺带求出

那么现在相当于要求 $O(n)$ 组形如 $[1, x] \times [1, x]$ 的东西

相当于降了一维了

那么考虑扫描线，从小到大枚举 $x$ 这一维

发现由于是顺序对，只有 $x$ 所在块以及其前面的块会发生答案的改变

我们假设 $g[i][j]$ 表示块 $i$ **与** 块 $j$ 此时的答案

那么，每一次修改相当于 $g[1\dots i-1][i]$ 进行修改

然后查询形如 $\sum_i\sum_j g[i][j]$ 的一个东西

考虑这东西是可以前缀和优化的

于是 $O(n\sqrt{n})$ 做完了

代码可以私信找我要或者上 loj 看