lxlorz

考虑我们把询问矩形分开来成若干行区间和列区间，怎么计算答案？

| (R1C1) | (R1C2) | (R1C3) |
| - | - | - |
| (R2C1) | (R2C2) | (R2C3) |
| (R3C1) | (R3C2) | (R3C3) |

贡献的对可以分为几类。

 1. 对在一个子矩形内，对每一个矩形预处理答案。
 2. 对在同一个行区间或者列区间，在这个行区间或者列区间上面求区间逆序对。
 3. 对在不同的行区间和列区间，可以做一个二维前缀和统计。

注意第一类会在第二类包含，并且第二类会统计第一类两次，所以需要容斥出来。

写成数学公式：

$$S((1,1)\cup\dots\cup(n,m)) = -\sum_{i=1}^n\sum_{j=1}^mS((i,j))$$
$$+\sum_{i=1}^nS((i,1)\cup\dots\cup(i,m))+\sum_{j=1}^mS((1,j)\cup\dots\cup(n,j))$$
$$+\sum_{i=1}^n\sum_{j=1}^m|(i,j)|\sum_{k=i+1}^n\sum_{l=j+1}^m|(k,l)|$$

如果我们按照树套树的子矩形来维护答案的话，可以做到 $O(n\sqrt n)$ 时间复杂度，$O(n\log^2 n)$ 空间复杂度（假设 $q=O(n)$）但是时间复杂度里还藏着一个初始化树套树的巨大 $O(n\log^2 n)$。

这么简洁就好了么？代码细节有一大堆。

 - 内层树套树需要用动态开点线段树实现。
 - 更方便来让外层标号为值域，内层标号为位置。
 - 内层的每一个树都会对应一个值域区间。对这个值域区间先建立完动态开点线段树的形态以及子树大小，然后再dfs初始化逆序对个数。后者用归并排序。
 - 区间逆序对用常数最小的方法，莫队二次离线。
 - 1 贡献直接按照初始化的东西求。
 - 2 贡献全部离线求。对外层树套树对应的值域区间放上位置区间的询问；对内层树套树对应的位置区间放上值域区间的询问。
 - 3 的贡献维护一个子树大小后缀和数组。

这样就好了么？NOI 版 TLE，Ynoi 版 MLE。

先考虑过 NOI 版的卡常方法：

 - 减少数组询问次数，也就是对 3 时候不要开二维数组，而滚动的维护一个以为数组。
 - 减少访问区间逆序对的常数，扔掉长度为 0 或者 1 的逆序对询问区间。
 - 重复提（x（w）i（x）n（q））交（y（ak）a（i）n（o）g（i））

NOI 版愉快过了，交上这里 MLE 21 分。发现我们现在内存复杂度是 $O(n\log^2 n)$，但是正解是 $O(n\log n)$。瓶颈在于内层树套树。考虑将 1 和 2 都离线到对应的外层线段树节点上，然后 dfs 外层线段树。1 和 2 之间保留状态大小是 $O(\log n)$，所以对每一个询问都开一个数组没问题。

dfs 到一个外层线段树节点上，建立内层线段树，用完然后把内层线段树的所有关键节点都清零。最重要是现在都不需要动态开点了，大大减少时空常数。最后需要注意我们离线的方法。不应该在每一个线段树节点上方 $(l,r,i)$ 形式的信息，而直接放离线的询问编号，直接把内存应用除以 3.

TLE 69，实测只是 TLE ~0.1s。继续卡常：

 - 整数排序用《P4604 [WC2017]挑战》的基数排序，然后只需要三轮。
 - 区间逆序对里的离散化不要用二分，而直接用数组即可，毕竟值域是 $O(n)$。不离散化也不行，区间逆序对需要是 $O(|A|)$ 才能保证整体时间复杂度。

然后就擦边 3.49s 过，写了 12KB 的 s***，不想放代码了。