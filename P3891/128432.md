**题目描述**

魔兽争霸3中，战略资源的采集通过使用农民、苦工、小精灵以及寺僧来进行。

在魔兽争霸4的开发中，玻璃渣觉得这种模式太过单一，于是他们想添加更多的单位来使采集的模式更加丰富。

在新的模式中，玩家可以建造更多种类的“苦工”，不同的“苦工”的工作效率不同，同时，建造不同的“苦工”所需要的资源也是不一样的。

玻璃渣出品的游戏以追求平衡著称，所以为了测试这种新的模式的平衡性，他们设计了一套检测的方法：在各种族的起始资源相同时，测量达到某一资源数量的时间，如果相同则可以认为设计是平衡的。

他们将数据给你，希望你能测试出设计是否平衡。


------------

**输入格式**

第一行三个数，N, M, T, 表示苦工的种类、开始时拥有的资源数量以及需要达到的资源的数量。

接下来N行，每行2个数A, B, 表示生产这种苦工所需要的资源，以及这个苦工的效率，效率即为单位时间内产生的资源的数量。


------------

**输出格式**

一个数字，表示资源数量达到T时的最少时间。

注意：与魔兽争霸3不同，魔兽争霸4中，生产苦工不需要时间。并且资源的采集并不连续，亦即如果一个苦工的效率为2，他会在时间为1的时候收获2点资源，而并不会在时间为0.5的时候收获1点资源。




------------


因为这道题的标签是dp，所以我就写了一个dp的代码

首先，我们可以定义f1[i]为在单位时间内拥有i个资源所能达到的最大生产量。

由于苦工有无限个，所以就可以用完全背包做这道题。

```
for(int i=0;i<=t;i++)f1[i]=-1;
f1[0]=0;
for(int i=1;i<=n;i++){//枚举苦工的种类
	for(int j=1;j<=t;j++){
		if(j-r[i]<0)continue;
		if(f1[j-r[i]]==-1)continue;
		f1[j]=max(f1[j],f1[j-r[i]]+f[i]);
	}
}
```


------------

接下来，我们可以定义一个f2[i][j]为在第i个单位时间里拥有j个资源所能达到的最大生产量。

所以，第一个循环可以枚举当前的时间，第二个循环枚举当前的资源，第三个循环枚举花费多少个资源去购买苦工
最后再判断一下目前资源超过t了没有，有就立刻输出，不然会超时。


------------

代码君：
```cpp
#include<iostream>
using namespace std;
int n,m,t;
int f1[1010],f2[1010][1010];
int r[110],f[110];
int main(){
	cin>>n>>m>>t;
	if(m>=t){
		cout<<0<<endl;
		return 0;
	}
	for(int i=1;i<=n;i++){
		cin>>r[i]>>f[i];
	}
    //初始化
	for(int i=1;i<=t;i++){
		f1[i]=-1;
	}
	for(int i=0;i<=t;i++){
		for(int j=0;j<=t;j++){
			f2[i][j]=-1;
		}
	}
	f2[0][m]=0;
    //计算f1数组
	for(int i=1;i<=n;i++){
		for(int j=1;j<=t;j++){
			if(j-r[i]<0)continue;
			if(f1[j-r[i]]==-1)continue;
			f1[j]=max(f1[j],f1[j-r[i]]+f[i]);
		}
	}
	for(int i=0;i<=1000;i++){
		if(f2[i][t]!=-1){
			cout<<i<<endl;
			return 0;
		}
		for(int j=0;j<=t;j++){
			if(f2[i][j]==-1)continue;
			for(int k=0;k<=j;k++){
				if(f1[k]==-1)continue;
                		//因为下一个单位时间的生产量为j-k+f[1]+f2[i][j]
				if(j-k+f1[k]+f2[i][j]>=t){
					cout<<i+1<<endl;
					return 0;
				}
                		//更新f2数组
				f2[i+1][j-k+f1[k]+f2[i][j]]=max(f2[i+1][j-k+f1[k]+f2[i][j]],f2[i][j]+f1[k]);
			}
		}
	}
	return 0;
}
```

