本题主要思路是贪心，这里不再分析题意~~如果你像我一样一开始看翻译没看懂那么建议你去看一下样例解释~~。

直接分析。对于两个橘子皮 $x$ 和 $y$，要满足 $ 2x \lt y $，我们可以通过分割的方法使得一方的大小下降（也就是分割成两个小块）。这里并没有规定 $x$ 和 $y$ 的大小，但是显然，我们把小的那方作为 $x$ 大的那方 $y$ 是最好的，那么对于一堆数 $ a_1,a_2,\ldots,a_n $ 显而易见将最小的数也就是 $a_1$ 作为所有比较中的 $x$ 最好（题目中有说是有序数列）。

那么对于每一次比较，如果 $ 2x \ge y $，就需要考虑分割了。

对于每次分割，我们可以分割出一个严格符合要求的数，即分割为 $b=2x-1$ 和 $c=a-b$（此处 $a$ 表示原本大小，$b$ 表示第一个被分割后的数，$c$ 表示第二个被分割后的数）。那么这么一来每次就要分割 $\lfloor \frac{a_i}{2x} -1 \rfloor$ 次。

只不过需要注意当 $a_i$ 能被 $2x-1$ 整除时，会少分一次。**这是里因为我们向下取整之后算的是包含最后剩下的一段 $c$ 的段数减一，最后一段的 $c$ 是一个大于零的数，但是当能被整除时最后一段的 $c$ 刚好没有**，所以要减一。

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	int T;
	scanf("%d",&T);
	while(T--){
		int n;
		scanf("%d",&n);
		int data[105];
		for(int i=0;i<n;i++){
			scanf("%d",&data[i]);
		}//输入
		
		const int should=data[0]*2-1;//我们要的每段长度
		int ans=0;
		for(int i=1;i<n;i++){
			int ttmp=0;
			if(data[i]%should==0){
				ttmp=1;
			}//如果能被整除记得减一
			ans+=data[i]/should-ttmp;//+ttmp;
		}
		printf("%d\n",ans);
	}
	return 0;
}
```
