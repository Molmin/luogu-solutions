来发题解


这道题刚开始的时候就想到用 动态规划 的方法来做，以为只是两次动态规划，第二次动态规划排除掉第一次走过的点而已。


但实现了单条道路的最大好感度和的计算之后，却发现远远没这么简单，两条道路如何不交叉是一个问题。


最后用四维数组来动态规划解决了这倒题。


设f[i][j][k][l]为从 (0, 0) 位置由两条不交叉的线路走到 (i, j)，(k, l) 位置时的最大好感度和，则它的上一步可能有四种情况：


第一个点由上走来，第二个点也由上走来，此时的好感度和为f[i - 1][j][k - 1][l] + a[i][j] + a[k][l]

第一个点由上走来，第二个点则由左走来，此时的好感度和为f[i - 1][j][k][l - 1] + a[i][j] + a[k][l]，但此时应考虑第一个点的上方的点是否会与第二个点的左方的点重合，如果重合则不可取

第一个点由左走来，第二个点则由上走来，此时的好感度和为f[i][j - 1][k - 1][l] + a[i][j] + a[k][l]，但此时应考虑第一个点的左方的点是否会与第二个点的上方的点重合，如果重合则不可取

第一个点由左走来，第二个点也由左走来，此时的好感度和为f[i][j - 1][k][l - 1] + a[i][j] + a[k][l]

取四种情况中的最大者即可。


代码如下：


（减少代码复制，共创美好洛谷）


```cpp
#include <iostream>
#include <cstdio>
using namespace std;
int f[51][51][51][51];// f[i][j][k][l] 表示从 (0, 0) 位置由两条不交叉的线路走到 (i, j)，(k, l) 位置时的最大好感度和
int a[51][51];// 好感度数组
int n,m;
main()
{
    scanf("%d%d",&m,&n);
    for (int i=1;i<=m;i++)
        for (int j=1;j<=n;j++)
            scanf("%d",&a[i][j]);
    for(int i = 1; i <= m; ++i)
        {
            for(int j = 1; j <= n; ++j)
                {
                    for(int k = 1; k <= m; ++k)
                        {
                            for(int l = 1; l <= n; ++l)
                                {
                                    // 还没到终点前不能走到同一个点，因此(i, j)不能等于(k, l)
                                    // 加上小于判断是因为当(i, j)跟(k, l)互换时，最大好感度值必定一样，不必重复计算
                                    if((i < m || j < n) && i <= k && j <= l)
                                    {
                                        continue;
                                    }
                                    int num = 0;
                                    // 两个点都由上走来的好感度
                                    num = max(num, f[i - 1][j][k - 1][l]);
                                    // 第一个点由上走来，第二个点从左走来，并且两个来源点不重合时的好感度
                                    if(i - 1 != k && j != l - 1)
                                    {
                                        num = max(num, f[i - 1][j][k][l - 1]);
                                    }
                                    // 第一个点由左走来，第二个点从上走来，并且两个来源点不重合时的好感度
                                    if(i != k - 1 && j - 1 != l)
                                    {
                                        num = max(num, f[i][j - 1][k - 1][l]);
                                    }
                                    // 两个点都由左走来的好感度
                                    num = max(num, f[i][j - 1][k][l - 1]);
                                    // 加上当前两点的好感度，即为走到这两点时的最大好感度和
                                    f[i][j][k][l] = num + a[i][j] + a[k][l];
                                }
                        }
                }
        }
    printf("%d\n", f[m][n][m][n]);
    return 0;
}
```