题目要求是从左上角到右下角，过去一趟过来一趟，这样想起来就有些麻烦，不如看成同时从左上角往右下角走，然后控制走的步数相同，从而来避免相交的情况。

我们定义f[x1][x2][step]为小渊传到横坐标为x1的点，小轩传到横坐标为x2的点，传了step次时的最大好心程度。

然后转移的话，分为四类：

小渊从左边传来，小轩也从左边传来。

小渊从上边传来，小轩也从上边传来。

小渊从左边传来，小轩从上边传来。

小渊从上边传来，小轩从左边传来。

详细看代码（附详细注释）：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m;//n行m列 
int a[55][55];//存矩阵 
int f[110][55][55];//f[i][j][k]表示小渊传到i，小轩传到j，传了k次的最大好心程度 
//前两维存的都是横坐标x1,x2。 
int main()
{
	cin>>m>>n;//输入行列 
	for(int i=0;i<m;i++)
		for(int j=0;j<n;j++)
			cin>>a[i][j];//输入矩阵 
	f[0][0][0]=0;//假巴意思初始化一下 
	for(int step=1;step<=n+m-2;step++)//枚举步数，把步数的枚举放在第一层，方便排除走到一起的情况//注意是n+m-2步 
		for(int x1=0;x1<m;x1++)//枚举小渊纸条的横坐标 
			for(int x2=0;x2<m;x2++)//枚举小轩纸条的横坐标 
			{
				int y1=step-x1;
				int y2=step-x2;//通过步数和横坐标求得纵坐标 
				if(y1<0||y2<0)
					continue;//如果越界了跳过 
				if((x1==m-1&&x2==m-1&&step==n+m-2)||x1!=x2)//如果到了最后一步（必须走到一起）或者在路径不交叉的情况下 
				{
					if(x1&&x2)
						f[step][x1][x2]=f[step-1][x1-1][x2-1];//小渊小轩都从上面传下来 
					if(x1) 
						f[step][x1][x2]=max(f[step][x1][x2],f[step-1][x1-1][x2]);//小渊从上边传过来，小轩从左边传下来 
					if(x2)
						f[step][x1][x2]=max(f[step][x1][x2],f[step-1][x1][x2-1]);//小渊从左边传过来，小轩从上边传下来
					f[step][x1][x2]=max(f[step][x1][x2],f[step-1][x1][x2]);//都从左边传过来 
					f[step][x1][x2]+=a[x1][y1]+a[x2][y2];//最后加上传到的这两个点的好心程度 
				}
			}
	cout<<f[n+m-2][m-1][m-1];//输出答案//注意只有n+m-2步 
	return 0;
}
```