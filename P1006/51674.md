因为多线程dp问题的a[i][0]和a[0][j]必须为0，所以初始点从a[1][1]开始。 
题目要求从1,1到m,n两条不相交的路径(因为每个同学最多只帮一次忙，所以两条路径不会相交)的权值和最大值。我们可以把问题转化为有两个人同时从1,1向m,n走，两人不相交。由于两人可以走所有的格子，我们分别用，x1,y1,x2,y2来表示某一时刻两人的位置。所以我们要用一个四维数组来表示出所有的状态。 
这里写图片描述
![](https://cdn.luogu.com.cn/upload/pic/22787.png)
如图所示：由于只能向下或者向右走，所以(x1,y1),(x2,y2)分别可以有图中黄色部分走一步得到，从上一步到这一步总共有4种情况。所以状态转移方程为：(a[][]存权值) 
dp[x1][y1][x2][y2]=max(dp[x1][y1-1][x2][y2-1],dp[x1][y1-1][x2-1][y2],dp[x1-1][y1][x2][y2-1],dp[x1-1][y1][x2-1][y2])+a[x1][y1]+a[x2][y2];

又因为，每个同学最多只能帮忙一次，所以当两人走到同一点时，只能给一个人加这个点的权值，代码可以这么来写： 
这里写图片描述
![](https://cdn.luogu.com.cn/upload/pic/22788.png)
时间复杂度为O(n^4)； 
优化: 
这里写图片描述 
![](https://cdn.luogu.com.cn/upload/pic/22789.png)
从(1,1)出发走恰好需要5步能到达的点 
他们都在一条45度的斜线上，且满足x+y=7。 
更普遍的，对于所有步数为s可以到达的坐标，x+y=s+2。所以，我们可以用走的步数来划分阶段，通过不同的步数，把这个题目划分成若干个不同的阶段。最后一个阶段有且仅有一个点:(n,m)。 
通过简化假设所走步数k,k=x1+y1=x2+y2 
优化方案有两种:

可知x1+y1=x2+y2,所以y2=x1+y1-x2;因此我们可以把dp[x1][y1][x2][y2]压缩成dp[x1][y1][x2],最后的y2通过可以得出，能够使时间复杂度将为O(n^3)；
我们令k表示走过的步数，所以有x1+y1=k,x2+y2=k(初始时k=1+1);知道了k,x1,x2,那么我们就可以知道y1,y2了。所以状态可以降低为3维，状态转移方程： 
dp[k][x1][x2]=max(dp[k-1][x1-1][x2],dp[k-1][x1-1][x2-1],dp[k-1][x1][x2],dp[k-1][x1][x2-1])+a[x1][k-x1]+a[x2][k-x2];
下面是代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=55;
int f[maxn][maxn][maxn][maxn];
int a[maxn][maxn];
int MAX(int a,int b,int c,int d)
{
	return max(max(a,b),max(c,d));
}
int main() {
	int m,n;
	cin>>m>>n;
	for(int i=1; i<=m; i++)
		for(int j=1; j<=n; j++)
		{
			scanf("%d",&a[i][j]);
		}
	int x1,y1,x2,y2;
	for(int x1=1;x1<=m;x1++)
	    for(int y1=1;y1<=n;y1++)
		    for(int x2=1;x2<=m;x2++)
			    {
			    	y2=x1+y1-x2;
			    	if(y2<=0)
			    	continue;
			    	f[x1][y1][x2][y2]=MAX(f[x1-1][y1][x2-1][y2],f[x1-1][y1][x2][y2-1],f[x1][y1-1][x2][y2-1],f[x1][y1-1][x2-1][y2])+a[x1][y1]+a[x2][y2];
			    	if(x1==x2&&y1==y2)
			    	f[x1][y1][x2][y2]-=a[x1][y1];
					}
	cout<<f[m][n][m][n];	
}
```