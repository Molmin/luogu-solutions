其实这题最纠结的地方在于：**什么时候留得青山在，不怕没柴烧，什么时候不要一步扯到蛋（一步跨太远）。**

首先是合法性判断，也是较为简单的一个部分，满足两个条件即可：$s>k$与$s<=(n-1)k$。前面一个判断容易被忽视掉，但是如果不考虑第五个点会错。不过只是个小错误，比较容易发现。

考虑到$s=k*(s/k)$，因此可以有以下两种安排方法：

第一，以k为主导，每步步长灵活机动。能跨大的尽量跨大的$(n-1)$，然后出一些小步子，最后一步一步的踱步。我一开始并没有意识到这个小步子的存在，以为就直接先$n-1$走，走到走不下去了就直接走1，最后剩多少一步走完，结果被

```cpp
10 9 45
```
 这个样例教训了……这样算最后一步要走7，到的位置是4，结果向前走不是向后走不是，崩掉。所以引入了这个小步子，介于$(n-1)$与$1$之间，用于填补剩的一步太少而一个最大步太多的情况。所以可以这样安排：先能走$(n-1)$就走，最后如果$(n-1)(i+1)>s$跳出这一循环，假设这一阶段总步数为sum，走了i步，开始一步一步踱步，直到$(s-sum)$%$(k-i)==0$，这个时候就可以全走小步子$(s-sum)/(k-i)$了。
 
 第二，以$s/k$为主导，每步尽量走这个长度，多余者拿最开始几步填坑。这个是第一篇题解的做法，先处理余数，每步都在$s/k$的基础上多走$1$格，先把$s-s*(s/k)$处理掉，剩下的步数直接在上个阶段的基础上步长$s/k$左右横跳。
 
 方法如果清楚了之后代码就是大模拟了，就不放我那丑陋的代码了。