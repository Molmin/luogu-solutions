## 题意：

给定一个 $H\times W$ 的矩形，求把这个矩形分割成 $A$ 个 $2\times 1$ 的小矩形和 $B$ 个 $1\times 1$ 的小矩形的方案数。


------------
## 思路：
先建函数：

```cpp 
void dfs(int i,int bit,int a,int b) ;
```

> 其中，$i$ 表示当前搜索到的格子编号，从 $0$ 开始；$bit$ 表示当前状态，第 $i$ 位为 $1$ 表示第 $i$ 个格子已经被覆盖，为 $0$ 表示未被覆盖；$a$ 表示还剩下多少个 $2\times 1$ 的矩形可以放置；$b$ 表示还剩下多少个 $1\times 1$ 的矩形可以放置。

------------

```cpp
if(i==h*w){ans++;return;}
```
- 如果 $i=h\times w$，则说明当前状态是可行的，将 $ans$ 加 $1$，然后直接返回。

------------
```cpp
if(b)dfs(i+1,bit|(1<<i),a,b-1); 
```

- 考虑放置一个 $1\times 1$ 的矩形。如果可以，那么将当前格子和下一个格子都标记为已覆盖，接着继续搜索下一个格子。

-------------
```cpp
if(a){
        if(i%w!=w-1&&!(bit&(1<<(i+1))))dfs(i+2,bit|(1<<i)|(1<<(i+1)),a-1,b);
        if(i+w<=h*w&&!(bit&(1<<(i+w))))dfs(i+1,bit|(1<<i)|(1<<(i+w)),a-1,b);
}
```
- 接着放置一个 $2\times 1$ 的矩形的情况。判断是否横向放置还是纵向放置，接着标记，继续搜索。

------------

## Code：

```cpp
void dfs(int i,int bit,int a,int b){
    if(i==h*w){ans++;return;}
    if(bit&(1<<i))dfs(i+1,bit,a,b);
    if(b)dfs(i+1,bit|(1<<i),a,b-1);
    if(a){
        if(i%w!=w-1&&!(bit&(1<<(i+1))))dfs(i+2,bit|(1<<i)|(1<<(i+1)),a-1,b);
        if(i+w<=h*w&&!(bit&(1<<(i+w))))dfs(i+1,bit|(1<<i)|(1<<(i+w)),a-1,b);
    }
}
```

