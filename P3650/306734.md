## 因为我是**蒟蒻**，所以发一个蒟蒻能看得懂的代码

### 思路：简单DFS

暴力枚举所有可能的标准（这题不会超时的）

- 把所有高于标准的都削去

- 低于标准-17的都加上（直到加到标准-17）

基本每行都有注释了
```cpp
#include <bits/stdc++.h> 
using namespace std;
int a[10000]; //存每座山峰的高度 
int n;	//山峰总共的个数 
int mi=0x7ffffff;//这里0x7ffffff是一个很大的数，也就是int的最大值 
void dfs(int k){
	int sum=0;  //当前以k为标准，当前的所有花费 
	//大于k的都减去，小于k的都加去 
	for(int i=1;i<=n;i++){
		if(a[i]>k+17){
			//这个山峰大于标准，减去
			sum+=pow(a[i]-k-17,2); //费用是减去的高度 的平方（仔细读题） 
		}
		if(a[i]<k){
			//这个山峰小于标准，加上
			sum+=pow(k-a[i],2);//费用是增加的高度 的平方（仔细读题） 
		}
	} 
	//这里我们不能让老实人农民约翰多花钱，所有就要更新最小的费用 
	mi=min(mi,sum);
	return ; 
}
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i];//华丽的输入了每一个山峰的高度 
	}  
	sort(a+1,a+1+n);//快速排序（这里下标是从1开始的，可以学习一下写法） 
	for(int i=a[1];i<=a[n];i++){//因为这题本来就是水题（划掉）可以暴力，从最小山峰高度到最大山峰的高度之间的所有设为标准的话都不会爆
		//这里挺好想的，你要设标准总不可能比最小的还小，最大的还大吧？另外这之间的所有（注意是所有）都可能成为标准
		//不一定只有山峰的高度才会是标准 
		dfs(i);
	}
	cout<<mi;
	return 0;
} 
```
再次感谢管理大大能够通过
