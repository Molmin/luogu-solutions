#### Part 1 思路
  首先，这道题是一道动态规划的简单题目，我们可以用三个步骤来解决这类动态规划题目，主要听思路，思路懂了其他题都可以类推。
#### 定义数组元素含义
  其实这道题比较简单，大多数动态规划就是问什么设什么，这道题就可以设
  $dp i,j$ 为第 $i$ 个时间单位，还剩 $j$ 个体力的总方案数，读题目发现最终一定要体力全部用完，所以 $t,0$ 就是最终答案。
####  找数组与元素之间的关系式
  那以这道题为例，这个人可以在这个时间点耗费一点体力划船，或者不划船，所以动态转移方程式就是
  ``` 
dp[i][j]=(dp[i-1][j]+dp[i-1][j+1])%mod;
```
#### 找出初始值
  根据我们的定义数组的含义不难看出 $0 ,m$ 等于 $1$。其实只要数组的含义不同初始化和转移方程就可能会不同，只要自圆其说即可。
#### 总结
  那这三步就是做动态规划的三步，只要每一步都做到了，就可以过掉所有动态规划题目，只是有些题目在某一个部分会加强难度，例如数组很难定义或者关系式很难推导，那就需要另外思考了。
#### Part 2 代码
```cpp
#include<bits/stdc++.h>
const int mod=1e9+7;
using namespace std;
int t, d, m, dp[3005][1505];
int main()
{
	cin>>d>>t>>m;
	dp[0][m]=1;//初始化
	for(int i=1;i<=t;i++)
	{
		for(int j=0;j<=m;j++)
		{
			int shenxia=m-j;//剩下的体力
			if(d-i+shenxia*2<=0)//特殊判断，不管怎样都死掉了
			{
				continue;	
			}
			dp[i][j]=(dp[i-1][j]+dp[i-1][j+1])%mod;//转移式
		}	
	}	
	cout<<dp[t][0]<<endl;
} 
```
