### 前言：

挺水的一道 dp 题目，最近老师在复习 dp,就来写一篇题解来复习一下吧。

ps：[题目](https://www.luogu.com.cn/problem/P8725)。

### 思路：

老师重新强调了三步法：

### \#1：

定义数组。

我们怎么定义数组呢？老师说过数组的值最好是答案，就把数组的值设为方案数，但还有体力和时间两个变量不好消掉，就看数据，明显可以用二维数组，这数组的定义就简单出来了！

$dp_{i,j}$ 是第 $i$ 个时间单位，**还剩** $j$ 个体力的总方案数，注意到题目中要我们求**用完所有体力**达到救援的方案数，显然是 $dp_{t,0}$，因为 $dp_{t,0}$ 表示在 $t$ 个时间单位**没有剩余体力**的方案总数，符合题目条件。


### \#2：

设置状态转移方程。

这道题目的状态转移方程较为好想，就是：

$dp_{i,j}=dp_{i-1,j}+dp_{i-1,j+1}$。

解释一下，其中我们直到到达 $dp_{i,j}$ 这种状态方法只有两种：一种是划船，消耗一个体力；一种是不划船，不消耗体力。将这两种加起来即可。

$dp_{i-1,j}$ 是前一个时间点，体力不变的情况，位不划船总数。

$dp_{i-1,j+1}$ 是前一个时间点，体力比现在多一个的情况，显然消耗了一个体力，为划船情况。

### \#3：

初始化那些不在状态转移方程内的东西。

我们把所有数组先圈定义成 $0$，这是没有方案。

还有 $dp_{0,m}$ 是包含不进去，需要先初始化为 $1$，$1$ 的值显然。

---
现在基本上做完了，但还有些需要注意：

1. 小心直接死了，需要在状态转移前判断活着没有。

2. 不要忘记取模。

### 代码：

```
#include<bits/stdc++.h>
const int Mod=1e9+7;
using namespace std;
int d,t,m,dp[3005][1501];
int main()
{
	cin.tie(0);cout.tie(0);
	cin>>d>>t>>m;//输入啦 
	dp[0][m]=1;
	for(int i=1;i<=t;i++)
	{
		for(int j=0;j<=m;j++)
		{
			int Xia=(m-j);
			if(d-i+Xia*2<=0)continue;//特判死掉了，continue 
			dp[i][j]=(dp[i-1][j]+dp[i-1][j+1])%Mod;//状态转移 
		}
	}
	cout<<dp[t][0]<<'\n';//结束！ 
}
```

完美撒花！