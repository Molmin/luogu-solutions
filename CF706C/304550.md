
这一道题真的很水。

----

题面已经不用说了。

从这种求最优价的类型和数据范围来看，很明显可以想到DP。

正常情况下我们对于这种线性DP一般都直接设 $f[i]$ 表示考虑第 $i$ 个元素（这里是字符串）时的最优价值。

但是这里很明显不够（会有后效性）。

结合题面的“翻转”操作可以发现，这是属于`0/1` 类型的决策，所以不难想到：可以在后面加一维。

所以设 $f[i][0/1]$ 表示考虑第 $i$ 个字符串的时候翻转或者不翻转的最优价值（`0`表示不动它，`1`表示翻转）

我们又假设 $revs[i]$ 表示 第 $i$ 个字符串翻转后的字符串（借鉴了一下楼上的做法，开始的时候因为用了太多次 `reverse` 被卡了……）。

所以我们可以考虑以下的四种情况：

+ 第 $i-1$ 个字符串的字典序小于等于第 $i$ 个字符串的字典序，此时不用翻转。

+ 第 $i-1$ 个字符串翻转之后的字符串的字典序小于等于第 $i$ 个字符串的字典序，此时只需要翻转前一个 （$i-1$）字符串就行了（这里不用加体力值，因为我们需要在后面更新）

+ 第 $i-1$ 个字符串的字典序小于等于第 $i$ 个字符串翻转之后的字符串的字典序，此时把第 $i$ 个字符串翻转。（这里要加上体力值）

+ 第 $i-1$ 个字符串翻转后的字符串的字典序小于等于第 $i$ 个字符串翻转之后的字符串的字典序，此时把第 $i$ 个字符串和第 $i-1$ 个字符串翻转。（这里也要加上体力值）

---
可能会有点绕，所以：

用代码（方程）描述如下（所有与字符串相关的变量我全部用结构体储存了）：

~~~cpp

    for(register long long i=2;i<=n;++i){
        if(a[i-1].s<=a[i].s){
            f[i][0]=min(f[i-1][0],f[i][0]);
        }
        if(a[i-1].revs<=a[i].s){
            f[i][0]=min(f[i][0],f[i-1][1]);
        }
        if(a[i-1].s<=a[i].revs){
            f[i][1]=min(f[i][1],f[i-1][0]+a[i].val);//val就是体力值
        }
        if(a[i-1].revs<=a[i].revs){
            f[i][1]=min(f[i][1],f[i-1][1]+a[i].val);
        }
    }
~~~

不过在初始化的时候记得让 $f[1][0]=0$ ，$f[1][1]=a[1].val$

对于无解的判断，我们只需要看 $\min(f[n][0],f[n][1])$ 是不是等于开始赋的超级大的值（`inf`）就行了，如果是，那么就是无解，输出 `-1` 。

----

核心代码已经给出来了，所以就不放完整代码了。