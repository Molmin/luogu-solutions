### 想了想还是来写一发题解吧

首先说一下思路，一开始我觉得这题用搜索+回溯再配个记忆化直接就能A，毕竟题目中有要求 “每张卡片只能使用一次”，每次搜索需要用哪一张卡片就可以解决。

结果事实证明我还是太天真了，如果用搜索的话，就算不WA也会T。

~~所以说乖乖动规吧这题的状态转移方程还算好推~~

**对于如何写题，我也就不多说了，前面已经有很多dalao把动规和另一种递归求解的方法发了，我就主要说一下状态转移方程怎么推吧，毕竟这种dp题最重要的部分就是要会推出状态转移方程**


首先，我们要弄懂题目，想清楚求解过程 ~~(废话题目都不懂拿头写吗~~

看完题目后，我们注意以下几个关键点：

### ①：从起点走到终点，每次只会前进不会后退

### ②：所有卡片一定用完且用完后正好到达终点

### ③：卡片只有四种，且数量最多也只有40

### ④：知道使用哪几张卡片后，我们就能推出现在到了哪一个位置

好，把这几个关键地方注意到了，就可以向下推方程了

首先第一个条件：它告诉我们是在用前面的条件推后面，也就是说你写for循环时，是从1到n而不是从n到1，每次状态转移也是类似f[i]=max(f[i-1],f[i])的形式而不是f[i+w[i]]+=f[i]的形式

然后第二个条件，告诉你推到最后，直接输出f[n]就可以了，某些问题没有这个条件你可能还要在f[1~n]中找一个最大值输出

第三个条件和第四个条件一起用，推出解此问题的核心：四维dp。因为卡片都是相同的，所以题中

#### “每张卡片仅能使用一次”

这个~~让人以为是搜索回溯的毒瘤~~条件就可以转化为

#### “每种卡片最多使用k次”

这样的与动态规划相接近的条件

毕竟对于一种只需要统计次数就可以了，而对于单独的一张你需要每次都开一个bool数组


（注：虽然这题是个四维dp，初学者可能会有些害怕，觉得维度上升到了四层一定非常难，其实这题的难度和某些一维dp是很接近的 ）

如果上面的都理解了，那下面我们就可以一步步写代码

首先，准备和框架

```cpp
/*
全局变量：
int f[50][50][50][50];
用来储存各种牌用到某个张数时得到的最大分数
*/

//然后用s1,s2,s3,s4(个人习惯)存各个牌的数目
for(int i=0;i<m;i++)
{...}

//根据第一条，开始写框架
	for(int i1=0;i1<=s1;i1++){
		for(int i2=0;i2<=s2;i2++){
			for(int i3=0;i3<=s3;i3++){
				for(int i4=0;i4<=s4;i4++){
                	...//下一步写主要内容
				}
			}
		}
	}
//每种状态都要涉及到，所以应该为四重循环
```
这里就体现到了①，③，④，使用四维dp并依次从前向后推

下一步，写核心：转移方程

由于有四个维度，所以每一个维度都要向前推

因为当前的状态可以由四个状态转移而来，这里就要用到一些逆推的思想：

### 平时我们都是想从这个状态可以变成什么，而在dp里却要想从什么状态可以变成这个状态

简单的推理可以得到，从每种张牌少一个的情况就加一张牌可以得到当前情况，所以我们来用前四个状态中最大的那一个来更新

得到中间代码：

```
if(i1==0&&i2==0&&i3==0&&i4==0)continue;
maxx=0;now=1+i1+2*i2+3*i3+4*i4;
if(i1!=0)maxx=max(maxx,f[i1-1][i2][i3][i4]+a[now]);
if(i2!=0)maxx=max(maxx,f[i1][i2-1][i3][i4]+a[now]);
if(i3!=0)maxx=max(maxx,f[i1][i2][i3-1][i4]+a[now]);
if(i4!=0)maxx=max(maxx,f[i1][i2][i3][i4-1]+a[now]);
f[i1][i2][i3][i4]=max(maxx,f[i1][i2][i3][i4]);
```

这样，这题也就差不多了

但还要最后的一个细节要处理一下，就是边界的问题

题目中明确地说了，一开始默认在第一格，获得第一格的分数

所以要加上 

f[0][0][0][0]=a[1];

并跳过零张牌的情况，因为对于零张牌到达它的状态是会改变的

（这一点在上面的代码中已经有体现了，注意观察）

关于目前格子的求法吗...想一下也就能写出式子了吧

### 最后，希望大家看完这篇题解并不只是会写这道题了，而是对于动态规划题状态方程的求解步骤有了新的理解，进而在其他的题目中也可以通过题意准确地退出状态转移方程，我认为这才是我写这篇题解的目的。

最后扔下AC代码，可以结合整个代码再想想过程

~~已经尽力让它看起来不丑了...~~
```
#include<iostream>
#include<cstdio>
#define il inline 
#define rg register
#define N 130
using namespace std;
int n,m;
int f[N][N][N][N];
int a[400];
int s[6];
int main(){
	scanf("%d%d",&n,&m);
	for(rg int i=1;i<=n;i++)
	scanf("%d",a+i);
	int xx;
	for(rg int i=1;i<=m;i++)
	scanf("%d",&xx);s[xx]++;
	f[0][0][0][0]=a[1];
	int maxx;
	int now;
	for(int i1=0;i1<=s[1];i1++){
		for(int i2=0;i2<=s[2];i2++){
			for(int i3=0;i3<=s[3];i3++){
				for(int i4=0;i4<=s[4];i4++){
					if(i1==0&&i2==0&&i3==0&&i4==0)continue;
					maxx=0;now=1+i1+2*i2+3*i3+4*i4;
					if(i1!=0)maxx=max(maxx,f[i1-1][i2][i3][i4]+a[now]);
					if(i2!=0)maxx=max(maxx,f[i1][i2-1][i3][i4]+a[now]);
					if(i3!=0)maxx=max(maxx,f[i1][i2][i3-1][i4]+a[now]);
					if(i4!=0)maxx=max(maxx,f[i1][i2][i3][i4-1]+a[now]);
					f[i1][i2][i3][i4]=max(maxx,f[i1][i2][i3][i4]);
				}
			}
		}
	}
	cout<<f[s[1]][s[2]][s[3]][s[4]]<<endl;
	return 0;
}
```