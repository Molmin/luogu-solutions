## 思路

**一共有四张卡片，代表所能走的不同的步数，也就是当前数的取得，有可能是在前一个数的基础上，走了一步/两步/三步/四步而来，因而考虑用一个四维的状态数组f[i][j][k][h]分别表示卡片的张数，DP列出所有可能的状态即可。**

### 要注意的细节：

1. **第一格是唯一的起点，所以f[0][0][0][0]=a[1]，也就是一张卡片都没有用的时候，取得的初值。**
2. **如果用了第一张卡片，则用f[1][0][0][0]表示，有f[1][0][0][0]=f[0][0][0][0]+a[2]，也就是从第一格开始，走了一格，实际上要取的数是a[2]，也就是a[t+1]，其中t为卡片所规定的步数。**
3. **每张卡片只能用一次，但每一种卡片不只一张，因此在输入的时候，需要做个统计。**
4. **注意动规的初值，循环要从0开始，表示没有用到相应的卡片。**
```cpp
#include<cstdio>
#include<algorithm>
#define N 360
#define M 130
using namespace std;
int n,m,x,a[N],b[5];
int f[M][M][M][M];
int main()
{
		scanf("%d%d",&n,&m);
		for(int i=1;i<=n;i++)
	  		scanf("%d",&a[i]);
		for(int i=1;i<=m;i++)
		{
			scanf("%d",&x);
			b[x]++;
		}
		f[0][0][0][0]=a[1];
		for(int i=0;i<=b[1];i++)
		for(int j=0;j<=b[2];j++)
		for(int k=0;k<=b[3];k++)
		for(int h=0;h<=b[4];h++)
		{
			x=i+j*2+k*3+h*4;
			if(i) f[i][j][k][h]=max(f[i][j][k][h],f[i-1][j][k][h]+a[x+1]);
			if(j) f[i][j][k][h]=max(f[i][j][k][h],f[i][j-1][k][h]+a[x+1]);
			if(k) f[i][j][k][h]=max(f[i][j][k][h],f[i][j][k-1][h]+a[x+1]);
			if(h) f[i][j][k][h]=max(f[i][j][k][h],f[i][j][k][h-1]+a[x+1]);
		}
		printf("%d\n",f[b[1]][b[2]][b[3]][b[4]]);
		return 0;
}
```