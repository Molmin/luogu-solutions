 _**P1541 乌龟棋**_ 

------------

题目背景
小明过生日的时候，爸爸送给他一副乌龟棋当作礼物。

题目描述
乌龟棋的棋盘是一行NN个格子，每个格子上一个分数（非负整数）。棋盘第1格是唯一的起点，第NN格是终点，游戏要求玩家控制一个乌龟棋子从起点出发走到终点。

乌龟棋中MM张爬行卡片，分成4种不同的类型（MM张卡片中不一定包含所有44种类型的卡片，见样例），每种类型的卡片上分别标有1,2,3,41,2,3,4四个数字之一，表示使用这种卡片后，乌龟棋子将向前爬行相应的格子数。游戏中，玩家每次需要从所有的爬行卡片中选择一张之前没有使用过的爬行卡片，控制乌龟棋子前进相应的格子数，每张卡片只能使用一次。

游戏中，乌龟棋子自动获得起点格子的分数，并且在后续的爬行中每到达一个格子，就得到该格子相应的分数。玩家最终游戏得分就是乌龟棋子从起点到终点过程中到过的所有格子的分数总和。

很明显，用不同的爬行卡片使用顺序会使得最终游戏的得分不同，小明想要找到一种卡片使用顺序使得最终游戏得分最多。

现在，告诉你棋盘上每个格子的分数和所有的爬行卡片，你能告诉小明，他最多能得到多少分吗？

输入输出格式
输入格式：
每行中两个数之间用一个空格隔开。

第11行22个正整数N,MN,M，分别表示棋盘格子数和爬行卡片数。

第22行NN个非负整数，a_1,a_2,…,a_Na 
1
​	 ,a 
2
​	 ,…,a 
N
​	 ，其中a_ia 
i
​	 表示棋盘第ii个格子上的分数。

第33行MM个整数，b_1,b_2,…,b_Mb 
1
​	 ,b 
2
​	 ,…,b 
M
​	 ，表示M张爬行卡片上的数字。

输入数据保证到达终点时刚好用光MM张爬行卡片。

输出格式：
11个整数，表示小明最多能得到的分数。

输入输出样例

------------

输入样例#1： 
9 5
6 10 14 2 8 8 18 5 17
1 3 1 2 1

------------

输出样例#1： 
73

------------

说明
每个测试点1s1s
小明使用爬行卡片顺序为1,1,3,1,21,1,3,1,2,得到的分数为6+10+14+8+18+17=736+10+14+8+18+17=73。注意，由于起点是11，所以自动获得第11格的分数66。

对于30\%30%的数据有1≤N≤30,1≤M≤121≤N≤30,1≤M≤12。

对于50\%50%的数据有1≤N≤120,1≤M≤501≤N≤120,1≤M≤50，且44种爬行卡片，每种卡片的张数不会超过2020。

对于100\%100%的数据有1≤N≤350,1≤M≤1201≤N≤350,1≤M≤120，且44种爬行卡片，每种卡片的张数不会超过4040；0≤a_i≤100,1≤i≤N,1≤b_i≤4,1≤i≤M0≤a 
i
​	 ≤100,1≤i≤N,1≤b 
i
​	 ≤4,1≤i≤M。

------------

[turtle](https://www.luogu.org/problem/show?pid=P1541)


------------
```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int n,m,k,a;
int score[351],card[5];
int f[42][42][42][42];
int readint(){
    int i=0,f=1;
    char ch;
    for(ch=getchar();(ch<'0'||ch>'9') && ch!='-';ch=getchar());
    if(ch=='-')    {
        f=-1; 
        ch=getchar();
    }
    for(;ch>='0' && ch<='9';ch=getchar())
        i=(i<<3)+(i<<1)+ch-'0';
    return i*f;
}
int main(){ 
	n=readint();
	m=readint();
	for(int i=1;i<=n;i++) score[i]=readint();
	for(int i=1;i<=m;i++){k=readint();card[k]++;}
	f[0][0][0][0]=score[1];	
	for(int i=0;i<=card[1];i++)
	for(int j=0;j<=card[2];j++)
	for(int k=0;k<=card[3];k++)
	for(int p=0;p<=card[4];p++)
	{
		a=1+i+2*j+3*k+4*p;
		if(i) f[i][j][k][p]=max(f[i][j][k][p],f[i-1][j][k][p]+score[a]);
		if(j) f[i][j][k][p]=max(f[i][j][k][p],f[i][j-1][k][p]+score[a]);
		if(k) f[i][j][k][p]=max(f[i][j][k][p],f[i][j][k-1][p]+score[a]);
		if(p) f[i][j][k][p]=max(f[i][j][k][p],f[i][j][k][p-1]+score[a]);
	}
	cout<<f[card[1]][card[2]][card[3]][card[4]];
	return 0;
}
```


------------
