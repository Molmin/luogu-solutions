[博客里食用更佳](https://www.luogu.org/blog/xzlhxc/solution-p1541)   
[题目链接（洛谷1541）](https://www.luogu.org/problem/P1541)   
（如本题解有错或不理解的地方请评论或私信笔者！）  
**前置cheese：线性dp基础**    
$upd:2019.10.27$更新了滚动数组的内容。

------------
## ①题意
一个$n(0<n \le 350) $个格子的长条形棋盘，你在第1格，当你跳到第$i$个格子上就能获得大小为$a_i$的分数（你自动获得第1格的分数）。你有$m$张牌，每张牌上的数字$q$表示使用了这张牌可以跳$q$格（$1\le q \le 4$），每张牌只能使用一次，每种牌最多40张，保证能跳到第$n$格，求此过程中能得到的最大分数。

## ②动态规划思路
这种题一看很像搜索题，但搜索又太慢了，要用dp，从下面几点来考虑原因：  

1. 始终从左向右跳，你**当前许多选择跳的步数不会影响到过去的答案**。  （反过来想，如果可以往回跳，则可能存在一种打牌方法使得在某几个格子上来回跳，答案就不断增加，这就会对过去的答案产生影响） **所以满足无后效性。**

1. **跳到当前最优解的方案一定包容先前的最优解。**    
反证法：在使用相同的牌的情况下，如果存在另外一种方案跳到当前格子的分数更大，那么采用这种方法就会使答案变大，与“最优解”矛盾。   
**故满足最优子结构性质**


## ③状态转移方程
首先我们可以把所有的状态都扔进状态转移方程里去，得到：

$f(x,i,j,k,l)=max\{ f(x+1,i-1,j,k,l),f(x+2,i,j-1,k,l),f(x+3,i,j,k-1,l),f(x+4,i,j,k,l-1) \}$

其中$f(x,i,j,k,l)$表示（不考虑边界）跳到第$x$个格子，剩下$i$张走1格牌，$j$张走2格牌，$k$张走3格牌，$l$张走4格牌能得到的最大分数。

然而这样子，数组大小为$size=350*40*40*40*40>10^9$，$MLE+TLE$

所以我们要**消除冗余状态！**

由于$x$的大小可以由 $i+j*2+k*3+l*4$推出，所以没必要保存。这样的话，数组大小就变成了$40^4$，可以接受。

**枚举顺序以及边界条件由状态定义方式而定。**  需参考（第一个方程）$x$的大小变化，以及你定义的$i,j,k,l$为“剩余的卡牌数”还是“已用的卡牌数”。综合这2点，结合自己定义的状态，推一推当前状态需要从哪些状态转移过来即可得到枚举顺序。

## ④滚动数组优化
滚动数组是递推或者动态规划中的一个很常用的技巧。    

由于递推顺序固定，如果某一个状态的信息只会被使用“一轮”（不是一次），且在下一轮乃至之后都不会用到，那么**存储这个信息的内存则可能可以被再次利用，达到节省空间的目的**。   

 _以上是笔者对滚动数组的理解。_ 
 
在本题中，$f(i,j,k,l)$可以由每一维减一转移来，那么我们可以用滚动数组压掉一维。    

如果你要压掉的一维是第一维，在实现中，你可以定义为：
```cpp
int f[2][41][41][41],now=0,pre=1;
```
然后**将方程里的所有$i$替换成$now$，所有的$i-1$替换成$pre$**。    

最后在枚举$i$的循环的最后加上```swap(now,pre);```**把$now$与$pre$交换，接下来使用的就是刚才$pre$代表的空间了**。    

观察代码可得，由于```f[i-1][...][...][...]```在之后都用不到了，所以**将它覆盖掉不会影响答案**。
## ⑤AC！  
觉得好就点个赞呗！