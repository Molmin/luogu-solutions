一眼根分，我们来考虑考虑这类根分问题该如何理清杂乱无章的操作。

我们考虑一开始令操作集合为空，然后慢慢把四种操作依次加入，看需要增添哪些动作。

一开始：【】

加入「小查」：那显然直接跑是根号的。于是：

1. 小查：直接跑。

加入「小修」：那显然直接跑是根号的。于是：

1. 小查：直接跑；
1. 小修：直接跑。

加入「大查」：大集合需要依赖小集合修改对它的贡献（目前还没有大修），而不能自己跑。于是在每次小修的时候对每个大集合贡献一波即可，贡献的值显然是增加的值乘以它们之间重合的数量，复杂度根号。所有集合与所有大集合重合的数量显然可以线根预处理，要用 `int` 存不然空间开不下。于是：

1. 小查：直接跑；
1. 小修：直接跑 + 对大集合贡献；
1. 大查：原来的和 + 小修对大集合的贡献；

加入「大修」：它自己什么都做不了，只能打个标记，然后让别的操作（小查、大查）来枚举大集合打下的标记。枚举到的时候的贡献显然是当前大集合的标记乘以重合数量，这个预处理过了。

于是：

1. 小查：直接跑 + 大修的标记；
1. 小修：直接跑 + 对大集合贡献；
1. 大查：原来的和 + 小修对大集合的贡献 + 大修的标记；
1. 大修：打标记。

直接做就可以了，复杂度线根。