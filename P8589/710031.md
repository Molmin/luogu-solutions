upd on 2022.10.28：

修改了一个错误：当 $n = 1$ 时也无解。

---

### 题意简要描述

给定一个长度为 $n$ 的 $01$ 串，使得串中长度为 $2$ 的子串 $01,00,10,11$ 出现的次数相等，或报告无解。

### 思路：

我们知道，一个长度为 $n$ 的字符串中，长度为 $2$ 的子串数量为 $n - 1$。

而要使 $01, 00, 10, 11$ 这些长度为 $2$ 的字符串出现的次数相等，就要使它们的出现次数总和为 $4$ 的倍数（否则总有几个子串的出现次数与其他的不相等），即 $(n - 1) \bmod 4 = 0$，也就是 $n \bmod 4 = 1$。

所以，我们在读入 $n$ 时，如果 $n \bmod 4 \ne 1$，那么就可以直接输出 `-1`。**特殊地，当 $n = 1$ 时，也无法构造满足条件的字符串，也要输出 `-1`。**

如果 $n \bmod 4 = 1$ 且 $n \ne 1$，那该怎么输出字符串呢？

我们来分析样例 $2$。此时输入 $n = 5$，满足有解的条件。

输出构造了一个满足条件的 $01$ 串 $00110$，我们通过这个样例来寻找规律，可以通过字符串拼接的方式来得出可行解。

分析这个样例，它的长度为 $2$ 的子串的出现顺序为 $00, 01, 11, 10$。我们可以将 $0110$ 继续插入这个字符串后面，例如 $001100110$ 就满足条件（各出现 $2$ 次）。

于是，有解输出的做法就出来了：在输出最初的 $0$ 后，再输出 $\lfloor \frac{n}{4} \rfloor$ 个字符串 $0110$，就可以得到一个可行解。

### Code

```cpp
#include <bits/stdc++.h>
using namespace std;
int n;
int main(){
	scanf("%d", &n);
	if(n % 4 != 1 || n == 1){ // n % 4 不等于 1 或 n = 1，报告无解
		printf("-1");
		return 0;
	}
	printf("0");
	for(int i = 1;i <= n / 4;i++){ // 直接输出
		printf("0110");
	}
	return 0;
}
```

---

~~说句闲话：为什么赛时我T2过了T1没过啊。~~