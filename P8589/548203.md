## 题目大意

已知一个字符串中包含 $01$，$11$，$10$，$00$ 的数量一样，给出字符串长度，求是否可行及可行情况

## 思路

看到这道题，我们先要想到满足条件的字符串最短情况与常见样子

我们发现：$01$ 与 $00$ 可以“粘”成 $001$，$001$ 与 $10$ 可以“粘”成 $1001$，$11$ 与 $1001$ 可以粘成 $11001$ 或 $10011$。

不妨另 $10011$ 为最短情况，此时四个子串各出现了 $1$ 次，我们看看各出现 $2$ 次时它长什么样子。

其实就是两个 $10011$ 粘在一起，可以粘成 $100110011$，经检验，确实是最短的一种情况。

到了这里，其实已经有规律了，为了验证思想，再看看各出现 $3$ 次的情况。那就再粘一个 $10011$，就变成了 $1001100110011$。

到了这里，规律已经很明显了。

规律为：$1001100110011$...$0011$，实际上就是前面一个 $1$，后面一堆 $0011$ 的情况。

有人问了，这是唯一情况吗？会发现是的。如果减去了任意一个数字，就会有两项的数量减去 $1$，剩下两项仅一个重叠，为保证条件，必须再删掉 $3$ 个数字。归根结底，还是回到了规律表示的那种形式。

所以，判断 $n$ 是否可行，是需要看看 $(n-1) \bmod\text{ } 4$ 的余数是否为 $0$，为 $0$ 就可行，按照规律输出就行了。

## AC Code

```cpp
#include<bits/stdc++.h>
using namespace std;

int main()
{
    int n;
    cin >> n;
    if (n % 4 != 1) cout << -1 << endl;
    else
    {
        cout << 1; // 前面一个 1
        for (int i = 1; i <= (n - 1) / 4; i++) cout << "0011"; // 后面一堆 0011
    }
    return 0;
}
```