题目：[P1743 矩阵 III](https://www.luogu.com.cn/problem/P1743)

这其实是道很简单的数论题，主要考察排列组合和优化。

刚看到题时，原本想打暴力的标数法，但是 $n$ 到了 $100000000$ ,肯定会超时，我们需要一种更快的算法。

首先，从矩阵的左上角走到右上角，需要 $n+m$ 步，而这些步中有 $n$ 步是往右走的（也可以说有 $m$ 步往下走），那么就会有 $C(n+m,n)$ 种走法，意为从 $n+m$ 步中选 $n$ 步出来往右走，代码就比较简单了。

我们要写两个循环分别来算分子和分母,比较坑的是要开 $long$ $double$ ,这些代码实现起来比较容易。

接下来是两个优化：

我们知道， $C(n+m,n)$ 和 $C(n+m,m)$ 是一样的，而题目中 $m$ 最大为 $4$ ，用 $C(n+m,m)$ 肯定会快的多，否则会超时。

另外，本题的答案很大，末尾会有多个 $0$ ，我们就可以拿个变量来记末尾有多少个 $0$ ，答案只记前面的非 $0$ 部分，最后再输出这么多个 $0$ 即可。

上代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	int n,m,cnt=0;
	long double ans=1;//注意是long double
	scanf("%d%d",&n,&m);
	if(n>m) swap(n,m); //取最小值
	for(int i=n+m;i>=m+1;i--) ans*=i;//分子
	for(int i=n;i>=1;i--) ans/=i;//分母
	while(ans>=100000000000000000){//去除超过范围的末尾的0
		ans/=10;
		cnt++;
	}
	printf("%0.0LF",ans);//输出在范围内的部分
	for(int i=cnt;i>=1;i--) printf("0");//输出超出范围的一些0
	return 0 ;
}
```
