[获得更好的阅读体验](http://shenyouran.github.io/P1743/)

在一个 $n \times m$ 的矩阵中，我们要求出从左上角到 右下角的方案种数。目前将点视为方格。

根据加法原理可知，对于每一个在矩阵中的点 $(i,j)$，它如果不是从上方而来，就必定从左侧来。因而点 $(i,j)$ 的路径总数就等于 $(i-1,j)$ 的路径总数和 $(i,j-1)$ 的路径总数之和。

当 $n=3,m=2$ 时，若用红色数字表示前往该点的方案种数，则有：

|坐标|$1$|$2$|$3$|
| :----------: | :----------: | :----------: | :----------: |
|$1$|$\red 1$|$\red 1$|$\red 1$|
|$2$|$\red 1$|$\red 2$|$\red 3$|

我们不难发现，每一个格子的值实质上是左上角和左侧的数字之和：

|坐标|$1$|$2$|$3$|
| :----------: | :----------: | :----------: | :----------: |
|$1$|$\red 1$|$\red 1$|$\red 1$|
|$2$|$\red 1$|$\red {1+1=2}$|$\red {2+1=3}$|

如果用 $f_{i,j}$ 来表示从 $(1,1)$ 到 $(i,j)$ 的方案种数，则有状态转移方程：

$$f_{i,j}=
\begin{cases}
1 & i=1 \text{ or } j=1 \cr
f_{i-1,j}+f_{i,j-1} & i \neq 1 \text{ and } j \neq 1 \cr
\end{cases}$$

我们考虑 $n=4,m=4$ 的情况：

|坐标|$1$|$2$|$3$|$4$|
| :----------: | :----------: | :----------: | :----------: | :----------: |
|$1$|$\red 1$|$\red 1$|$\red 1$|$\red 1$|
|$2$|$\red 1$|$\red 2$|$\red 3$|$\red 4$|
|$3$|$\red 1$|$\red 3$|$\red 6$|$\red {10}$|
|$4$|$\red 1$|$\red 4$|$\red {10}$|$\red {20}$|

我们不妨将上述的图表围绕左上角的点顺时针旋转 $45^{\circ}$，得到类似这样的图：（本图为某数学竞赛试题的解析图）

![](https://cdn.luogu.com.cn/upload/image_hosting/4b4esd9u.png)

我们可以很容易地判断出这个图形是杨辉三角。这也解释了先前所提到的状态转移方程为什么只和前面两个值的和有关。

然而，因为 $n \le 10^8$，因而数组是开不下的，我们必须得寻找规律。突破口就是 $m \le 4$ 的这个限制条件。

实际上，点的总个数 $\neq n \times m$，因为点在外围，而每一个小格在内部。每一排的点的个数为 $n+1$，故以下所提及到的 $n$ 均比输入的要大 $1$，而 $m$ 已经进行了考虑，与输入保持不变。

因此，当 $m=0$ 时，任何一个点 $(1,x)$ 的路径总数只能从其左侧拓展而来（只有一整行的点），故值都为 $1$。

当 $m=1$ 时，答案必定为 $n$。

当 $m=2$ 时，不难发现，答案为 $\dfrac{n(n+1)}{2}$。

当 $m=3$ 时，$f_{3,i}$ 与 $f_{3,i-1}$ 之差为 $\dfrac{i(i+1)}{2}$，即：

|**项数**|$1$|$2$|$3$|$4$|$...$|
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: 
|**数值**|$\dfrac{1 \times 2}{2}$|$\dfrac{1 \times 2}{2}+\dfrac{2 \times 3}{2}$|$\dfrac{1 \times 2}{2}+\dfrac{2 \times 3}{2}+\dfrac{3 \times 4}{2}$|$\dfrac{1 \times 2}{2}+\dfrac{2 \times 3}{2}+\dfrac{3 \times 4}{2}+\dfrac{4 \times 5}{2}$|$...$|

那么：

$$f_{3,n}=\dfrac{1}{2} \sum_{i=1}^{n}i(i+1)$$

$$=\dfrac{1}{2}(\sum_{i=1}^{n}{i^2}+\sum_{i=1}^{n}i)$$

$$=\dfrac{1}{2}[\dfrac{n(n+1)(2n+1)}{6}+\dfrac{n(n+1)}{2}]$$

$$=\dfrac{n(n+1)(2n+1)+3n(n+1)}{12}$$

$$=\dfrac{n(n+1)(2n+4)}{12}$$

$$=\dfrac{n(n+1)(n+2)}{6}$$

当 $m=4$ 时，$f_{4,i}$ 与 $f_{4,i-1}$ 之差为 $\dfrac{i(i+1)(i+2)}{6}$，因此：

$$f_{4,n}=\dfrac{1}{6} \sum_{i=1}^{n}i(i+1)(i+2)$$

$$=\dfrac{1}{6} (\sum_{i=1}^{n}{i^3}+\sum_{i=1}^{n}{3i^2}+\sum_{i=1}^{n}{2i})$$

$$=\dfrac{1}{6} [(\sum_{i=1}^{n}{i})^2+\dfrac{n(n+1)(2n+1)}{2}+n(n+1)]$$

$$=\dfrac{1}{6} \{[\dfrac{n(n+1)}{2}]^2+\dfrac{n(n+1)(2n+1)}{2}+n(n+1)\}$$

$$=\dfrac{1}{6} [\dfrac{n^2(n+1)^2}{4}+\dfrac{n(n+1)(2n+1)}{2}+n(n+1)]$$

$$=\dfrac{1}{6} [\dfrac{n^2(n+1)^2+2n(n+1)(2n+1)+4n(n+1)}{4}]$$

$$=\dfrac{1}{24}n(n+1) [n(n+1)+2(2n+1)+4]$$

$$=\dfrac{1}{24}n(n+1) (n^2+5n+6)$$

$$=\dfrac{n(n+1)(n+2)(n+3)}{24}$$

综上可得：

$$\text{ans}=
\begin{cases}
1 & m=0 \cr
n & m=1 \cr
\dfrac{n(n+1)}{2} & m=2 \cr
\dfrac{n(n+1)(n+2)}{6} & m=3 \cr
\dfrac{n(n+1)(n+2)(n+3)}{24} & m=4 \cr
\end{cases}$$

进一步观察可知，这其实与排列组合有着密切关系，我们不难发现，答案可以用 $C^{m}_{n+m-1}$ （即$\dfrac{(n+m-1)!}{m!(n-1)!}$）来表示。这也就是杨辉三角的精髓所在。

当 $n=10^8$ 时，答案最大可以达到 $10^{31}$ 的数量级，这显然要大于 $2^{100}$，因此我们可以使用浮点数类型或者 `__int128_t`（正规竞赛可能无法使用）。

`C/C++` 使用浮点类型（组合意义）：

```cpp
#include<stdio.h>
int n,m;
long double x=1;
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=n+m;i>=n+1;i--)x*=i;
    for(int i=m;i;i--)x/=i;
    printf("%.0Lf",x);
    return 0;
}
```

`C/C++` 使用浮点类型（通项公式）：

```cpp
#include<stdio.h>
int n,m;
int main()
{
    scanf("%d%d",&n,&m);
    n++;//预先将 n 的值加 1，方便计算
    if(m==1)printf("%d",n);
    else if(m==2)printf("%.0Lf",0.5L*n*(n+1));//在没有小数点的情况下，一个数后加 L 表示 long 类型；而如果有小数点，则代表 long double 类型
    else if(m==3)printf("%.0Lf",1.0L*n*(n+1)*(n+2)/6.0L);
    else printf("%.0Lf",1.0L*n*(n+1)*(n+2)*(n+3)/24.0L);
    return 0;
}
```

`C/C++` 使用 `__int128_t` 类型（组合意义）：

```cpp
#include<stdio.h>
int n,m;
__int128_t x=1;
void print(__int128_t x)//__int128_t 类型不提供标准输入输出，需要手写输出函数
{
    if(x>9)print(x/10);
    putchar(x%10+'0');
}
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=n+m;i>=n+1;i--)x*=i;
    for(int i=m;i;i--)x/=i;
    print(x);
    return 0;
}
```

然而，由于题目本身和数据的原因，我们得知只需要输出前 $17$ 个数位，后面全部输出 $0$。

结合 `C++` 的 `string` 可以保存所有数位，并按要求输出：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m;
__int128_t x=1;
string s;
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=n+m;i>=n+1;i--)x*=i;
    for(int i=m;i;i--)x/=i;
    while(x)
    {
        s+=x%10+48;//将末位字符拼接在字符串之后
        x/=10;
    }
    reverse(s.begin(),s.end());//将字符串倒置
    for(int i=0;i<17&&s[i];i++)putchar(s[i]);//先输出前 17 个字符
    for(int i=17;s[i];i++)putchar('0');//如果字符串第 17 位（下标从 0 开始）不为空，就继续输出直到对应字符为空
}
```

利用 `C/C++` 的 `char` 数组依然也可以完成：

```cpp
#include<stdio.h>
int n,m,len,i,j;
__int128_t x=1;
char s[51];
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=n+m;i>=n+1;i--)x*=i;
    for(int i=m;i;i--)x/=i;
    while(x)
    {
        s[len++]+=x%10+48;//方法与前者类似，只需改动下标，并同时将其用作保存字符数组长度的变量
        x/=10;
    }
    for(i=len-1,j=0;i>=0&&j<17;i--,j++)putchar(s[i]);//同时控制字符数组没有输出完+只输出前 17 位
    for(;i>=0;i--)putchar('0');//由于 i 为全局变量，因而可以沿用上次的值，如果 i >= 0 则说明输出尚未结束，应当输出直到下标 0 为止
    return 0;
}
```