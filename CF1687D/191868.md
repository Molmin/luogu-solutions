注意，这个做法复杂度为 $O(n+v\sqrt v)$，其中 $v$ 是值域，但是常数极小，且极难卡满，在实际运行中甚至快于不少正解。

首先观察一下这个所谓“好”的数有什么特点，大概长这样：

$1,2,4,5,6,9,10,11,12,16,17,18,19,20$，发现“好”的数连续出现，不是“好”的数也是连续出现，出现次数为 $2,1,3,2,4,3,5,4\cdots$。

先把 $k=0$ 判掉（这里出了两个巨大的错误竟然过了 pretest）

接下来首先发现一个简单的结论：对于答案 $k$，至少存在一个 $a_i$ 使得 $a_i+k$ 是完全平方数，设平方根为 $l$。

证明：若不存在某个 $a_i+k$ 是完全平方数，由于所有好数连续段都以完全平方数开头，所以将 $k$ 减一必然也满足条件。

接下来考虑枚举 $i,l$，注意到由于 $a_i+k$ 前面有长为 $l-1$ 的不好数的连续段，那么 $l-1\le a_i-a_{i-1}-1$，可以发现对于所有 $i\ge 2$，$l$ 的个数的总和是 $O(v)$ 级别的，对于 $i=1$，由于当 $l$ 过大时其后面必然存在极长的好数的连续段，必然满足条件，所以也是 $O(v)$ 的，接下来只需要考虑如何快速判断某个 $k$ 是否符合条件。

这个判断实际上只需要判断不好数连续段中有没有原序列中的数，这个实际上可以暴力，每次算出不好数连续段的左右界，预处理值域上的前缀和即可，这里的时间复杂度可以分析出来是 $O(\sqrt v)$ 的。

总复杂度 $O(n+v\sqrt v)$，进行一些简单的剪枝之后跑得飞快。