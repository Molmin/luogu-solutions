这是 Nathan312 的第一篇题解吖（点赞支持一下呗，我想让更多人看到这种解法 qwq）。

我看了一下其他大佬的题解，几乎都用到结构体 sort 排序，我有一种代码很简短，时间复杂度上又有优化的解法。其实这题可以用**桶排**。

## 题目大意：
给出需要的**牛奶总量** $n$，$m$ **个农民**。每个农民给出**牛奶单价**，和**一天能卖出的牛奶量**。问你用**最少**多少钱能拿到总量 $n$ 的牛奶？

## 思路：
贪心，优先取**价值低**的，因为这样可以尽可能地降低最后总共需要的价值，所以要排序，然后依次从价值低的往后取，到取不下为止。

## 实现步骤:
1. **预处理**：定义一个 $ans$ 记录最后总共需要的价值，还需要 $p$ 数组记录每个价值的牛奶有多少份，$p_i$ 的上限是 $1000$，所以定义一个大小为 $1001$ 的 $p$ 数组。然后对于每一个农民读入 $a$ 单价，$b$ 份数，在 $p$ 数组对应的单价增加对应的份数。

1. **算法实现**：首先枚举每一个价值，从 $0$ 开始枚举到 $1000$。如果**存在这么一个价值，且用得完**：用 $n$ 减去对应份数，$ans$ 加上价值（单价$\times$份数，也就是 $i \times p[i]$ ）。如果**存在这么一个价值，但用不完**：和上面一样，用 $n$ 减去对应份数，$ans$ 加上价值（也就是 $i \times n$ ），到这里已经达到了需要的数量，所以 break 退出循环。

1. 输出最后总共需要的最小价值 $ans$。


## 数据范围：
$0 \leq n, a_i \leq 2 \times 10^6, 0 \leq m \leq 5000, 0 \leq p_i \leq 1000$

从数据范围你看出了什么，是不是 $p_i$ 的范围比较小，也就是**值域小**，立马想到的就是**桶排**。

## CODE：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n, m, ans, p[1001];
int main() {
	scanf("%d%d", &n, &m);
	int a, b;
	for (int i = 1; i <= m; i++) {
		scanf("%d%d", &a, &b);// a 是单价，b 是份数
		p[a] += b;
	}
	for (int i = 0; i <= 1000; i++) { // 注意起点是 0
		if (p[i] != 0 && n - p[i] >= 0) {// 如果存在这么一个价值，且用得完
			n -= p[i];
			ans += (i * p[i]);
		} else if (p[i] != 0 && n - p[i] < 0) {// 如果存在这么一个价值，但用不完
			ans += (i * n);
			break; // 此时 n 用完了，退出循环
		}
	}
	cout << ans;
	return 0;
}


```
管理员辛苦了，感谢管理员的审核！（~~管理员最帅了，这篇题解给个通过嘛，第一次写不容易 qwq~~）
