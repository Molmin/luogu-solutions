很荣幸被dalao邀请来做这道~~省选~~题

区间并问题，想到了之前看过的一道模板题，题意大概是：
给定若干个闭区间，求最少多少个闭区间能够刚好囊括所有给出的闭区间

跟这题真的是像得不能再像了

思路大致是：先把所有区间按起点排序，然后将最左边的区间的两端设为答案区间的两端。接下来顺次查找剩下的区间，如果 **答案区间** 的右端小于当前查找到的区间的左端，输出区间，并将区间的左右值替换为当前查找区间的左右值。否则，更新答案区间右端

虽然是模板贪心，还是有几点需要强调的：

1.答案区间加粗，是因为这里不能设为上一个区间右端（亲测爆0）。

2.更新答案区间最右端，不要直接更新，而是要取一个最大值（二次爆0）。

3.最后的最后，在退出查找前，输出一次区间左右端（WA1个点）。

1、2点有时候可以实测，3点想必刷扫描/查找题的都应该有感触吧。。。

不多说，贴上代码：


```
#include<iostream>
#include<algorithm>
using namespace std;
int n,st,ov;
struct node //结构体存区间 
{
	int lo,hi;
}a[50000+10];
bool cmp(node a,node b) //排序 
{
	return a.lo<b.lo;
}
int main()
{
	cin>>n;
	for(int i=1;i<=n;i++) cin>>a[i].lo>>a[i].hi;
	sort(a+1,a+n+1,cmp);
	st=a[1].lo;
	ov=a[1].hi; //答案区间初始化 
	for(int i=2;i<=n;i++)
	{
		if(a[i].lo>ov) //开新区间 
		{
			cout<<st<<" "<<ov<<endl;
			st=a[i].lo;
			ov=max(ov,a[i].hi);
		}
		else ov=max(ov,a[i].hi); //扩展原有区间 
		if(i==n) cout<<st<<" "<<ov<<endl; //注意点3 
	}
	return 0;
 } 

```

感觉是老题了

~~不是很难啊还是蛮水的~~

虽然还是WA了3次





