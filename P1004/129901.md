### 这题其实有一种非常简单的方法，但是似乎没有多少人写qwq。

### 对，它就是DFS！


------------

我用DFS成功20msAC，没有加记忆化，并没有比正解DP慢多少。

事实上，程序时间复杂度很吓人。但由于数据过水，运行起来没有问题。（所以这题难度最多普及/提高-）

------------

下面先说基本思路。

两条路径，实际上可以看成从$A$到$B$，再从$B$回来。

然后我们把取走的数都标为$0$以防止重复，像这样搜索，就可以得到正解了。

——我当时是这么想的。于是直接爆搜打上去。


------------

#### "#2 TLE 1.20s"

#### Too Young Too Simple。qaq

------------

那么如何剪枝呢？

我们设从$A$搜到$B$为第一阶段，从B搜到A为第二阶段。

首先发现，取第一阶段的最大值，接着再取第二阶段的最大值。是可以得到最优解的。

于是，便可以使用**最优性剪枝**了：保存当前从A搜到B（即第一条路径）的最大值MAX，之后从A搜到B取得的值若小于MAX，那么直接剪掉；如果大于MAX，那么更新MAX即可。

下面给出代码实现。

------------

```
#include<iostream>
using namespace std;

const int dx[]={0, 1, 0, -1},
		  dy[]={1, 0, -1, 0};

int map[10][10], n, ans, tmp; //ans为最终结果，tmp为第一阶段最大值

inline void search(int x, int y, int z, int f) //x、y为当前坐标
{											   //z为当前取到的值，f表示当前处在第几阶段
	if (x<1 || y<1 || x>n || y>n) return; //边界
	
	if (x==n && y==n) //第一阶段终止条件
	{
		f=1; //标记
		z-=map[n][n]; //为了防止在(n, n)重复计算
		
		if (z>tmp) //更新&&剪枝
			tmp=max(tmp, z);
		else
			return;
	}
		
	if (x==1 && y==1 && f==1) //第二阶段终止条件
		ans=max(ans, z);
	
	if (!f) //第一阶段进程
	{
		for (int i=0; i<2; i++)
		{
			int nx=x+dx[i], ny=y+dy[i], t=map[nx][ny];
			
			map[nx][ny]=0;
			search(nx, ny, z+t, f);
			map[nx][ny]=t;
		}
	}
	else //第二阶段进程
	{
		for (int i=2; i<4; i++)
		{
			int nx=x+dx[i], ny=y+dy[i], t=map[nx][ny];
			
			map[nx][ny]=0;
			search(nx, ny, z+t, f);
			map[nx][ny]=t;
		}
	}
}

int main()
{
	cin>>n;
	
	for (;;)//输入
	{
		int x, y, z;
		cin>>x>>y>>z;
		
		if (x==0 && y==0 && z==0)
			break;
		
		map[x][y]=z;
	}
	
	search(1, 1, 0, 0); //最初的位置是(1, 1)，取到的值为0，处于第一阶段
	
	cout<<ans;
	return 0;
}
```

------------


看起来十分zz吧？

然而为什么会有这样的效果呢？

显然在$n\times n$的图中，第一阶段和第二阶段的解答树为大小相等的满二叉树，因此其叶子节点数为$2^{2(n-1)}$。由于边界问题，实际有效的节点为${\frac{2^{2(n-1)}}2}=4^{(n-2)}$。

设$t=n-2$，之后我们发现，在未剪枝时，第一阶段解答树的叶子节点数就是第二阶段的运行次数。单独提出第二阶段，则构成包含$4^t$个解答树的森林。

那么总复杂度为$O(4^t+4^t\times4^t)=O(16^t)$，显然不可能过。

然而剪枝过后，第二阶段只运行一次，总复杂度为$O(2\times4^t)=O(4^t)$，结合$t=n-2$，可知在本题允许范围内。

（刚刚发现有一处打错 感谢管理员qwq）