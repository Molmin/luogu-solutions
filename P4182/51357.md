来自http://blog.csdn.net/iceprincess_1968/article/details/79146028

将所有的区间按左端点从小到大排序

我们处理那些被完全包含的区间，这些区间即使删除也不会使答案变坏

这样先删一波，如果发现这种小区间的个数多于k，就可以直接算答案了

否则我们要dp

设dp[i][j]为考虑到第i个区间，已经删除了j个区间，且第i个区间没有被删除的情况下最大的覆盖长度

显然有状态转移方程dp[i][j]=max(dp[k][j-i-k-1]+第i个区间贡献的覆盖)

这个方程相当于枚举上一个没有被删除的区间k,然后将k+1~i-1全部删除

但我们看到这个转移是O(n)的，所以总复杂度为O(n*n*k)，不能接受

考虑优化dp转移

对于第i个区间，设其左端点为l

我们先看一看方程，会发现对dp[i][j]产生贡献的i'-j'=i-1-j

1. 对于i之前的那些右端点<=l的区间，它们与i没有重叠部分，所以只要在它们当中取max，再加上第i个区间的长度即可

2. 对于那些与i有重叠部分的区间，在当前区间右移的时候，这些dp的贡献会变，但相对大小不会变，所以可以维护一个单调队列，dp[i][j]对应的单调队列的编号为i-1-j，每次先把队头的那些已经跑到左边的区间弹出去（算成1的贡献），然后取队头就是当前的有重叠的状态中的最大答案

然后当前dp值算出来以后要插进对应的单调队列中（编号为i-j的单调队列），如果队尾状态加上与当前状态的右端点差还没有当前状态的dp值大的话，就把它从队尾弹出

这样总复杂度O(n*k)