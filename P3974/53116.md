这题蒟蒻看了好几遍题解还没懂，于是去网上搜集各大神题解在此作补充

参考~~抄自~~：U54194 yihhhhhhh 的题解
[](https://blog.csdn.net/popoqqq/article/details/45171469)https://blog.csdn.net/popoqqq/article/details/45171469
[](https://blog.csdn.net/lych_cys/article/details/50268211)https://blog.csdn.net/lych_cys/article/details/50268211
[](https://blog.csdn.net/ziqian2000/article/details/55684200)https://blog.csdn.net/ziqian2000/article/details/55684200
[](https://www.cnblogs.com/gjc1124646822/p/8481081.html)https://www.cnblogs.com/gjc1124646822/p/8481081.html

------------

结论性题解：

**Dilworth定理** DAG的最小链覆盖=最大点独立集 

**最小链覆盖** 指选出最少的链(可以重复)使得每个点都在至少一条链中 

**最大点独立集** 指最大的集合使集合中任意两点不可达 

此题中最大点独立集显然是一个集合满足集合中任意两点都是左下-右上的关系 


------------

伟大的证明：

①

求一条从左下到右上的最长路径，大概可以证明这就是最少的次数。

简单的证明如下：

- **必要性** 显然成立，这几个点之间不能互相到达，至少需要走这几个点才能全部取完。

- **充分性** 反证法，假设有几个点没有被取完。那么对于每一个点，以这个点为右下角的一个矩形中所有最长路径上的点，他们走的路径都已经满了（语文不好只能这样表达了），否则肯定可以走下来。那么吧这个点加入最长路径，加上这个点左上角走下来碰到的一下点，是更长的路径。只能大概这么表达一下了，讲不清楚啊。

- 或者直接用网络流解释，这道题目就是给出流量下界求最小流，那么对应的就是最大割了。

②

答案就是在图中选出一些点，使得两两不可达且权值和最大。

然而并没有找到证明，于是只好自己脑补。大概是会证(口)明(胡)了吧……现给出我的证明如下：

先分析出行进的策略：走到第一行最右的一个非零格子，向下走一行进入第二行，走到右边最右的一个非零格子(若无则不走)，向下走一行进入第三行，走到右边最右的一个非零格子(若无则不走) ……走到右下角。

**证明**：易知选出的点集中最右上的(称作x)那个一定在第一遍的行进路上。只需证明当x的权值减完之后，点集S中除x以外的最右上的点(称作y)在接下来的行进路上，即可说明存在这样一种方案。

首先，显然x，y围成的矩形内(不含边界)中不可能有点，否则加入点集更优。假设y无法进入当前行进路，即y的右上角还有点，设为u。易知这个点不会在x的右上方，否则就不会轮到x。这个点只能在[y的右上]与[x的左上或右下] 的交集之中。此时用u替换x，点集S权值更优。但可能导致u和x的前一个点集中的右上的点无法衔接，即变得可达。设x的前一个点集中的右上点为z。如果z一直都在消u，则把z也丢掉即可。如果z消u之前在消v(即v,u不可达,v不属于点集S)，则用v,u共同替换x,z答案更优，此时继续递归寻找z的右上点，变成子问题。点集S中最右上的点没有右上点，因此子问题可以结束，即可以找到最优解。

可能你看不懂我在说什么，建议把图画出来比一比，那样应该就知道了QAQ

------------

还有这种似乎比较易懂：

设f[i][j]，代表从(1,m)到(i,j)不能同一次取的有多少，

我们知道(i,j)和右上(i-1,j)是不能同时取的，

所以f[i][j]=f[i-1][j+1]+a[i][j]，

我们同时考虑到(i,j)可以从(i-1,j)和(i,j+1)转移过来

------------

最后得出DP状态转移方程
```cpp
f[i][j] = max( f[i-1][j], f[i][j+1]), f[i-1][j+1]+a[i][j] );
```
                               

------------


```cpp
#include <iostream>
#include <cstring>
#include <cstdio>

using namespace std;

const int Maxn = 1e3+7;

int T, n, m;
int a[Maxn][Maxn];
long long f[Maxn][Maxn];

int main()
{
    scanf("%d", &T);
    while(T--)
    {
        memset(f, 0, sizeof f);
        scanf("%d%d", &n, &m);
        for(int i = 1; i <= n; ++i)
            for(int j = 1; j <= m; ++j)
                scanf("%d", &a[i][j]);
        for(int i = 1; i <= n; ++i)
            for(int j = m; j >= 1; --j)
                f[i][j] = max( max(f[i-1][j], f[i][j+1]), 
                               f[i-1][j+1]+a[i][j] );
        printf("%lld\n", f[n][1]);
    }
    return 0;
}
```


------------
最后……蒟蒻我好像还是不很清楚……