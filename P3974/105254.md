看大部分题解都对这个 $Dilworth$ 定理讲的不够清楚...这个定理其实是可以推广到更广泛的情况的（~~貌似有一位大佬有提到广义的定义...只是有点简短（~~。

于是我就来给出一个具体的定义QWQ

## $Dilworth$ 定理

首先讲**偏序集**的定义：

对集合 $A$ 给定一个关系 $R$（表达元素间的这个关系可以记做 $aRb$），若 $R$ 满足（默认元素均 $\in A$）：

1. $aRa$（自反性）
2. 若 $aRb, bRa$，则有 $a=b$（反对称性）
3. 若 $aRb, bRc$，则有 $aRc$（传递性）

则 $R$ 是 $A$ 上的偏序关系，$R$ 和 $A$ 一起被称为一个偏序集。

（全序集其实就是对于任意两个属于 $A$ 的元素均有关系 $R$）

再回到 $Dilworth$ 定理。首先定义：

1. 链，指一个集合 $S\subseteq A$，它的任意两个元素都可比。
2. 反链，指一个集合 $S'\subseteq A$，它的任意两个元素都不可比。

而 $Dilworth$ 定理其实就是指：

1. 对于一个偏序集，其最少反链划分数等于其最大链的大小。
2. 对于一个偏序集，其最少链划分数等于其最大反链的大小。

现在讲讲证明：

首先第二条显然可以通过 "反向" 定义偏序集从而得到。我们只尝试证明第一条。

定义最少反链划分数 $p$，最大链大小 $r$，偏序集 $X$。

$\text{Lemma 1. }p\geqslant r$

$\text{Proof. }$由于链中元素都两两可比，所以它们之间都不会被划分到同一个反链中，显然得证。

 _--定义极小元：在偏序集 $X$ 中，对于某元素 $a$，如果对于任意元素 $b$，都有 $aRb$，则称 $a$ 为 $X$ 中的极小元。_ 

$\text{Lemma 2. }r\geqslant q$

$\text{Proof. }$设 $X_1=X$，令 $A_1$ 是 $X_1$ 中极小元的集合，从 $X_1$ 中删除 $A_1$ 得到 $X_2$；令 $A_2$ 是 $X_2$ 中极小元的集合，从 $X_2$ 中删除 $A_2$ 得到 $X_3$...并如此循环定义，最终一定会有一个 $X_k$ 非空而 $X_{k+1}$ 为空。

显然 $A_1,A_2,...,A_k$ 就是 $X$ 反链的**一种**划分（根据定义，每个极小元集合中的元素除非相等，否则**不可比**），因此至少有$k\geqslant q$；且注意到对于 $X_i(i>1)$ 中任意元素 $a_i$，必存在 $X_{i-1}$ 中的元素 $a_{i-1}$，使得 $a_{i-1}Ra_i$。因此易得存在链 $S=\{a_1, a_2, ..., a_k, R\}$（根据传递性）。由于 $r$ 是最长链大小，因此至少有 $r\geqslant k$。引理于是得证。

## 本题解析

我们将每个格子拆为其财宝个数个元素，并定义关系 $aRb$ 为在网格图中 $a$ 可以到达 $b$，注意同一个格子的元素是**相互不可到达的**（一次只能拿一个财宝）。

显然这样的关系是满足偏序关系要求的。那么题目要求我们求的实际上就是这个偏序集的最少链划分数，也就是最大反链大小。

但由于这个偏序关系和网格图密切相关，我们可以不在转化后的偏序集上做，而是直接在网格图上做 "dp"。

考虑一个格子位置 $(i,j)$（$(\text{行, 列})$，编号从左到右或从上到下递增）。所属格子位置在该格子右上角且 "**相邻**" 的，且上面元素和该格子上面元素没有偏序关系的，一定是格子 $(i-1, j+1)$；有偏序关系的，一定是格子 $(i, j+1)$ 和 $(i-1, j)$。

这样的关系也可以递推，从而知道对于一个格子位置，和它有偏序关系的一定是行列**均大于它**或**均小于它**的格子；无偏序关系的一定是行列一**个大于它一个小于它**或相反的格子。

然后显然可以设状态 `[i][j]`，表示从网格图右上角至格子 $(i, j)$ 最大的反链大小，dp 一下就可以了。

（这段 dp 分析写的有点烂...~~感性理解下~~）

## CODE

~~（话说代码和直接考虑 dp 一模一样（~~

```cpp
#include <cstdio>
#include <cstring>
#include <iostream>
using std::max;

int map[1010][1010];
long long dp[1010][1010];

inline int read(){
	int x =0; char c =getchar();
	while(c < '0' || c > '9') c =getchar();
	while(c >= '0' && c <= '9') x = (x<<3) + (x<<1) + (48^c), c =getchar();
	return x;
}

int main(){
	for(int t =0, T =read(); t < T; ++t){
		memset(map, 0, sizeof(map)), memset(dp, 0, sizeof(dp));
		int n =read(), m =read();
		for(int i =1; i <= n; ++i) for(int j =1; j <= m; ++j) map[i][j] =read();
		for(int i =1; i <= n; ++i) for(int j =m; j > 0; --j)
			dp[i][j] =max(dp[i-1][j+1]+map[i][j], max(dp[i][j+1], dp[i-1][j]));
		printf("%lld\n", dp[n][1]);
	}
}
```
