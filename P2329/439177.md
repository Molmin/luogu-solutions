这是一道比较水的紫题。

首先是排序内容，我们将提供的木板从大到小排序，优先选择大的，然后将需要的木板从小到大排序，优先解决最小的，这样可以实现最优解。

据我了解到很多人喜欢用简单的数组做，但其实用前缀和统计计算才是比较好的方式，因为这样才能减小耗时，也就是避免超时风险。

对于这种题目呢，我们直接来一个二分答案，相信只要读了题的人都会。但是要注意二分左区间必须为 $0$ ，因为有可能一个符合条件的木板都切不出来。

上述内容均为橙题难度，下面才是重头戏。

我们肯定需要用到一个函数来判断第 $i$ 个木板能否将剩下的木板做出来。

如果剩下没有木板了，那就返回 $1$ 。为了达到剪枝的效果，如果能提供的总木板量减已经扔掉的木板总量小于当前的前缀数组里的值,那么就返回 $0$ 。

接下来我们从第 $i$ 个木板开始遍历，如果这个木板足够，就切下来，此时有可能会剩下一点木板，由于已经排好了序，所以如果剩下的连当前最小的木板都切不出来，就把它记为扔掉的木板。假如这个需要得到的木板和它之前一个需要得到的木板相等，在没找到解的情况下，就只从现在节点开始搜索，达到了回溯的效果。

在没有特殊情况时还是没找到解，那我们就从提供的第1个木板重新搜索，并且让剩余的木板数量减一，即 $flag=check(1,num-1)$ 。

完成了函数之后，我们代入进二分当中，如果中间节点可以被切割，就更改左区间，否则更改右区间。如果两端点重合，输出左端点。如果两端点只相差了一个单位，我们就根据 $check(1,r)$ 判断是输出右端点还是左端点。

上述内容均为蓝题难度，蓝色加橙色等于紫色，没毛病。

参考代码内容：

函数：

    bool check(int x,int num)
    {
        if(num==0)	return true;
        if(sum-out<h[num])	return false;
        if(x>m)		return false;
        bool flag=false;
        for(int i=x;i<=m;i++)
        {
            if(a[i]-b[num]>=0)
            {
                a[i]-=b[num];
                if(a[i]<b[1])	out+=a[i];
                if(b[num-1]==b[num]&&!flag)	flag=check(i,num-1);
                else
                {
                    if(!flag)	flag=check(1,num-1);
                }
                if(a[i]<b[1])	out-=a[i];
                a[i]+=b[num];
            }
        }
        return flag;
    }
    
重点代码：

      while(l<=r)
      {
          if(l==r)
          { 
              cout<<l;
              break;
          }
          if(l+1==r)
          {
              if(check(1,r))	cout<<r;
              else cout<<l;
              break;
          }
          int mid=(l+r)/2;
          if(check(1,mid))	l=mid;
          else r=mid-1;
      }
      
请看完解析之后完善全部代码，抄袭者请根据文章拼接代码。

看完了就不能给这个初一党点个赞吗？