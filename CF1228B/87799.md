这道题数据范围较小,可以暴力。比赛时为了节约时间,提高正确率,就没写快速幂了。

标记每一个方格必须涂黑,严禁涂黑,可涂可不涂。(涂黑表示满格)

然后找可涂可不涂的方格,然后每次×2

用样例1来说一下我的方法吧。
```
3 4
0 3 1
0 2 3 0
```
首先,0 3 1表示行,先判断0,如果0,0选了,连续涂黑的格子就不会是0了,所以标记为不能涂黑

3:1,0 1,1 1,2必须涂,如果不涂就不会是3。1,3严禁涂,不然就是4以上了

重复步骤,得到这个涂完的方格
```
+--+--+--+--+
|0 |  |  |  |
+--+--+--+--+
|1 |1 |1 |0 |
+--+--+--+--+
|1 |0 |  |  |
+--+--+--+--+
```
其中1表示必须涂,0表示严禁涂。

接下来看列,重复行的步骤,得到

```
+--+--+--+--+
|0 |1 |1 |0 |
+--+--+--+--+
|1 |1 |1 |0 |
+--+--+--+--+
|1 |0 |1 |  |
+--+--+--+--+
```

只剩下一个格子可以 可选可不选了,答案就是2¹=2了。

注意特判既必须选,又严禁选的格子(样例2)此时就没有方案,输出0。
```cpp
//这里1表示涂,2表示不涂,0表示可涂可不涂。
#include<iostream>
using namespace std;
long long mark[1005][1005]={0},a[1005],b[1005];
int main(){
	long long n,m,i,j,sum=1;
	cin>>n>>m;
	for(i=0;i<n;i++){
		cin>>a[i];
		for(j=0;j<a[i];j++){
			mark[i][j]=1;
		}
		mark[i][j]=2;
	}
	for(i=0;i<m;i++){
		cin>>b[i];
		for(j=0;j<b[i];j++){
			if(mark[j][i]==2){ //现在要标记为1,可是已经标记为2了,所以遇到了既必须选,又严禁选的格子。
				cout<<0;
				return 0;
			}
			mark[j][i]=1;
		}
		if(mark[j][i]==1){ //没方案,与上面注释一样。
			cout<<0;
			return 0;
		}
		mark[j][i]=2;
	}
	for(i=0;i<n;i++){
		for(j=0;j<m;j++){
			if(mark[i][j]==0){ //可选可不选,就是没有标记过的格子。
				sum<<=1; //×2的快速版。
				sum%=1000000007;
			}
		}
	}
	cout<<sum;
	return 0;
}
```
我太弱了,讲得不怎么好,如果有哪个地方有疑问,可以在评论区回复。