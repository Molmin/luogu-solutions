这本来是 MO 课（并不是 $2021$ 新星冲刺营）讲义上的一个题，据说是美国国家队的考试题（其实不怎么难= =），老师（也不是 ayh）讲得非常复杂又玄学，根本不是具体可操作的感觉。现在这个解法是我用我自己当时做的时候的解法整理出来的，如果有人有更优美的解法可以私信告诉我（

建议下文我没有给出证明（尤其是写了“易证”）的小结论大家都自己征一下，都非常简单且证明后有助于理解。

首先直接枚举定向方案，暴力判断就可以通过 Sub1。时间复杂度 $O(2^mm)$，期望得分 $7$ 分。

开始讲特殊性质的做法（这些部分分是 zly 提出的方案，个人感觉很优美且对解决此题很有提示意义）。在讲之前先说明一下：这个题的命题人之一是 IMO2005 金牌、MIT 助理教授赵宇飞大神，它的来源是这样一道题：

> 将任意一个无向图的边进行定向，使得每个点入度和出度之差的绝对值 $\le 1$。

性质 A 就是上面这题的树版本，可以说是此题的基础中的基础（

下面讲 A 的做法。我们考虑简化问题。我们发现如果相邻两条边的定向后首尾相接，那么它们对公共点的度数贡献为 $0$。类推可得一条链上的边首尾相接地定向，则其贡献与连接两个链端点的一条单独的边没有区别。因此，我们可以把树剖成一条条链，在题目的条件（所有点度数都是奇数）下，容易证明最终可以使得每个点恰为一条链的端点。这样我们就把一棵树简化成了一个匹配，随意对匹配中的边定向后转化回原图中的方向，容易发现此时已经满足要求。具体实现在正解部分讲解。

再讲性质 B 的做法。性质 B 对图进行了极度的简化，我们已经有了一个很强的条件：图中不存在边权相同且长度 $>1$ 的链。事实上有了 A 的解法作铺垫，也许你已经能够想到，这就是此题经过简化后的最终形态，因为权为 $1$ 的边显然构成一个匹配。对于这个问题，我们首先注意到一个最简单的事实：$1+1=2$。换句话说，就是 $2-1=1$。由这个最基本的等式（之一）我们容易发现一件事情：只要边权分别为 $1,2$ 的边各一条是首尾相接的，那么它们对公共点的度数贡献的绝对值为 $1$。由性质 B 的条件知此时该公共点没有其他边相连，已满足要求。

又由性质 B 的条件和奇度数限制易证原图可以拆成若干个顶点互不相交的链和环。其中环上的边权为 $1,2$ 交替（故显然边数为偶数），链上的边权 $1,2$ 交替，且两端均为 $1$（故显然长度为奇数）。我们只要找到这样的分拆方法，对环和链上的边分别首尾相接地定向，容易证明此时所有点已满足要求。

然后进入讲正解环节。Sub2 的解法在以下所有结论基础之上，只是实现更简单暴力。在下面讲具体实现时会讲到。

为了方便，我们先除掉重边（边权也相同）和自环。事实上在下面的去环步骤中可以一样地处理，没有必要单独讨论，但是它们更加特殊，其无实际贡献的性质也更显然。

接下来我们首先考虑简化整个问题，使得我们能借用前面的结论来处理。容易发现特殊性质的条件里都没有边同权值的环。所以我们首先考虑把同权环处理掉。显然由性质 A 的做法中提到的结论进行简单的推广，我们可以得知图中有同权环的时候我们把环上的边首尾相接地定向时对每个点的度数贡献均为 $0$。因此我们可以把整个图消到无同权环。

然后由性质 A 解法中的结论，我们知道对于一条同权链，我们对它的边首尾相接地定向后和连接两个链端点的一条边等价。这个性质对边权为 $2$ 显然也成立。

于是我们可以运用性质 A 的做法把图进一步转化为性质 B 的形式，进而解决整个问题。完整的解法大概分以下 $3$ 步：

1. 去环
2. 剖链（参考性质 A 解法，具体实现稍后讲解）
3. 链定向（参考性质 B 解法，对应回原图的方法稍后讲解，这步在性质 A 的解法中也要用到）

当然，我们的前两步要对权为 $1$ 的边构成的图和权为 $2$ 的边构成的图分别做一遍。下面讲这 $3$ 步各自的具体处理方法。

Sub2 的具体实现就是对每个点暴力 $O(m)$ 找环，然后对每棵树暴力剖链，然后对链暴力搜索定向，总时间复杂度 $O(nm)$，大概率跑不满，因为我没写过所以我不知道具体情况。期望得分 $27 \sim 67$，因为在性质 A 和 B 的条件下这个暴力只需要进行后两步操作，而后两步的暴力其实是容易做到 $O(n+m)$ 的。

剩下的就是正解了。

首先讲第 $1$ 步。直接 `dfs`，找到环时立即回溯，然后记录每个点扫到了哪条边，下次继续从这条边接着扫（每次从 `head` 开始扫可以卡）。这样做的过程中，易证若一条边直到回溯时都没被定向，则它必然不在任何没有被破坏的环中了（当然也可能是原来在环中但是环上有边在去掉另一个环时已经被定向了，所以说不在“没有被破坏的”环中），这样就保证了这一步的正确性。同时每条边都至多被访问两次（两个端点各一次），因此这一步的时间复杂度是 $O(n+m)$。对应代码里的 `dfs1`。

然后是第 $2$ 步。直接树上 `dfs`，我们对于每个点将它的子树（包括它连向父节点的边，不包括它的父节点）剖成若干条链，其中有一条是从它子树中某个点连向它的父节点的。对于叶子直接返回它连向它父亲的边，对于其他节点先把其子节点的子树内连上来的边每次选两个配成一条链，如果最后剩余一棵子树则直接将它返回的链连上去，否则返回它向它父亲连的边。这一步的复杂度是遍历森林的复杂度 $O(n)$。对应代码里的 `dfs2`，我们用一个三元组 $(x,y,lca)$ 形容一条链，表示其两个端点与两端点在树上的最近公共祖先。同时记录下每个点连向其父亲的边的编号与方向（对应题目输入是正向或反向），方便最后进行定向。

最后是第 $3$ 步。我们在第 $2$ 步中处理了 $(x,y,lca)$，在这里我们首先将其看作一条边 $x,y$。我们每次从一条权为 $2$ 的边开始进行搜索，这样每条边至多被搜索到一次，因此时间复杂度是边数 $O(n)$，对应代码 `main()` 函数中注释 `stp2-2` 与 `stp3` 之间部分。我们对链定向后回到原图处理每条链，从 $x$ 往上跳，一直跳到 $lca$ 为止，这一路上的方向是相同的，与链从 $x$ 到 $y$ 的方向相同；再从 $y$ 往上跳，一直跳到 $lca$ 为止，这一路上的方向也是相同的，但和跳 $x$ 时反向。这样我们就做到了每一条链上边的定向，总时间复杂度是第 $2$ 步中森林所有边数，即 $O(n)$，对应代码中 `stp3` 与 `stp4-2` 之间部分。

这样我们就解决了这个问题，总时间复杂度 $O(n+m)$。

由于 `std` 有丶长，并且写了奇怪的指针，所以加注释有丶复杂，如果需要注释可以在评论区说，我会有（gu）空（gu）时（gu）补（gu）的。

另外，由于代码能力不足，我当时调 `std` 用了好久，`main()` 里面的注释原来是调试信息，现在感觉也有帮助大家更清晰地理解代码~~以及凑 $173$ 行~~的作用，于是就没删了（

Code(std):
```cpp
#include<bitset>
#include<cstdio>
#define rg register
using std::bitset;
inline char gc()
{
	static char buf[1048576],*pn=buf,*pe=buf;
	return (pn==pe)&&(pe=(pn=buf)+fread(buf,1,1048576,stdin),pn==pe)?EOF:*pn++;
}
inline int read()
{
	int x=0;
	char c=gc();
	while(c<'0'||c>'9')c=gc();
	while(c>='0'&&c<='9')x=x*10+(c^48),c=gc();
	return x;
}
int *head,*cnt;
int hd1[1000003],c1=1;
int hd2[1000003],c2=1;
struct edge
{
	int nxt,to,id;
}e1[6000007],e2[6000007],*e,ed;
inline void add(int x,int y,int w,int i)
{
	(w==1)?(head=hd1,cnt=(&c1),e=e1):(head=hd2,cnt=(&c2),e=e2);
	e[++(*cnt)].nxt=head[x],e[*cnt].to=y,e[*cnt].id=i,head[x]=*cnt;
	e[++(*cnt)].nxt=head[y],e[*cnt].to=x,e[*cnt].id=i,head[y]=*cnt;
}
int flag=0,psv;
int ti[1000003];
char dr[3000007];
bitset<1000003>vis;
bitset<3000007>tem;
void dfs1(int u,int pi)
{
	vis.set(u);
	for(rg int i=ti[u];i;i=ti[u])
	{
		ti[u]=e[ti[u]].nxt;
		if(e[i].id==pi)continue;
		if(tem[e[i].id])continue;
		int v=e[i].to,si=e[i].id;
		if(vis[v])
		{
			flag=1,psv=v,dr[si]=(i&1)^48;
			tem.set(si),vis.reset(u);
			return;
		}
		dfs1(v,si);
		if(flag)
		{
			dr[si]=(i&1)^48,tem.set(si);
			if(u==psv)flag=0;
			else {vis.reset(u);return;}
		}
	}
	vis.reset(u);
	return;
}
struct line
{
	int x,y,lca,dir;
}l1[500003],l2[500003],*ln;
int n1[1000003],n2[1000003],*nm;
int f1[1000003],f2[1000003],*fa;
int dfs2(int u,int pi)
{
	rg int pv=0,sv;
	vis.set(u),fa[u]=pi;
	for(rg int i=head[u];i;i=e[i].nxt)
	{
		if(i==pi)continue;
		if(tem[e[i].id])continue;
		int v=e[i].to;
		sv=dfs2(v,i^1);
		if(!pv)pv=sv;
		else
		{
			ln[++(*cnt)].lca=u;
			ln[*cnt].x=pv,ln[*cnt].y=sv;
			nm[pv]=nm[sv]=*cnt,pv=0;
		}
	}
	return (pv)?pv:u;
}
int n,m,x,y,w;
int main()
{
	n=read(),m=read();
	for(rg int i=0;i<m;++i)
	{
		x=read(),y=read(),w=read();
		(x!=y)&&(add(x,y,w,i),1);
	}
//	puts("stp0");
	head=hd1,e=e1,c1=0,ln=l1,cnt=(&c1),nm=n1,fa=f1;
	for(rg int i=1;i<=n;++i)ti[i]=head[i];
	for(rg int i=1;i<=n;++i)if(ti[i])dfs1(i,-1);
//	puts("stp1-1"); 权1图去环 完成
	for(rg int i=1,j;i<=n;++i)
	{
		if(!vis[i])
		{
			j=dfs2(i,-1);
			nm[i]=nm[j]=++(*cnt),ln[*cnt].x=j;
			ln[*cnt].y=ln[*cnt].lca=i;
		}
	}
//	puts("stp1-2"); 权1图剖链 完成
	head=hd2,e=e2,c2=0,ln=l2,cnt=(&c2),nm=n2,fa=f2,vis.reset();
	for(rg int i=1;i<=n;++i)ti[i]=head[i];
	for(rg int i=1;i<=n;++i)if(ti[i])dfs1(i,-1);
//	puts("stp2-1"); 权2图去环 完成
	for(rg int i=1,j;i<=n;++i)
	{
		if(!vis[i])
		{
			j=dfs2(i,-1);
			if(j!=i)
			{
				nm[i]=nm[j]=++(*cnt),ln[*cnt].x=j;
				ln[*cnt].y=ln[*cnt].lca=i;
			}
		}
	}
//	puts("stp2-2"); 权2图剖链 完成
	for(rg int u=1,v,t,nm1,nm2;u<=n;u=t+1)
	{
		nm1=nm2=n2[u],t=u;
		while(nm1)
		{
			(u==l2[nm1].x)?\
			(v=l2[nm1].y,l2[nm1].dir=0):\
			(v=l2[nm1].x,l2[nm1].dir=1);
			n2[u]=n2[v]=0,nm1=n1[v];
			(v==l1[nm1].x)?\
			(u=l1[nm1].y,l1[nm1].dir=0):\
			(u=l1[nm1].x,l1[nm1].dir=1);
			n1[u]=n1[v]=0,nm1=n2[u];
		}
		v=l2[nm2].x^l2[nm2].y^t;
		while(nm2)
		{
			(v==l2[nm2].x)?\
			(u=l2[nm2].y,l2[nm2].dir=1):\
			(u=l2[nm2].x,l2[nm2].dir=0);
			n2[u]=n2[v]=0,nm2=n1[u];
			(u==l1[nm2].x)?\
			(v=l1[nm2].y,l1[nm2].dir=1):\
			(v=l1[nm2].x,l1[nm2].dir=0);
			n1[u]=n1[v]=0,nm2=n2[v];
		}
	}
//	puts("stp3"); 链定向 完成
	for(rg int i=1,u,v,p,d;i<=c1;++i)
	{
		u=l1[i].x,v=l1[i].y,p=l1[i].lca,d=l1[i].dir;
		while(u!=p)dr[e1[f1[u]].id]=(f1[u]&1)^d^48,u=e1[f1[u]].to;
		while(v!=p)dr[e1[f1[v]].id]=(f1[v]&1)^d^49,v=e1[f1[v]].to;
	}
//	puts("stp4-1"); 权1图边定向 完成
	for(rg int i=1,u,v,p,d;i<=c2;++i)
	{
		u=l2[i].x,v=l2[i].y,p=l2[i].lca,d=l2[i].dir;
		while(u!=p)dr[e2[f2[u]].id]=(f2[u]&1)^d^48,u=e2[f2[u]].to;
		while(v!=p)dr[e2[f2[v]].id]=(f2[v]&1)^d^49,v=e2[f2[v]].to;
	}
//	puts("stp4-2"); 权2图边定向 完成
	puts(dr);
	return 0;
}
```