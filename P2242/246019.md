## 贪心
本蒟蒻的第一篇题解，写得不好的地方恳请大家~~理解~~指出。

题目传送门：https://www.luogu.com.cn/problem/P2242

这道题是一道很显然的贪心，但是本蒟蒻感觉有些题解看不懂，还有些题解没有说明贪心正确性的，所以本蒟蒻就自己写了一篇。（~~虽然没有其他的题解写得好~~

题目要求实施交通管制的路段总长度最短，我们就必须使管制的路段中被浪费的长度尽量小。因为只有坑所在的点才需要被维护，这里“被浪费的长度”，其实就是**坑与坑之间的距离**
，即没有被管制的路段。

显然可以得出结论：
**所有被管制路段的的开头和结尾一定都在坑上，**
才能使浪费达到最小。所以我们需要考虑的其实是从第一个坑到第$n$个坑的范围，道路的头尾两端都可以省略。

那么问题就来了，在怎么在第一个坑和最后一个坑之间管制$m$个路段，使总浪费最小呢？

我们可以注意到，根据刚才得出的结论，在这$m$条路段中，第一条的开头一定是第一个坑，而第$m$条路段的结尾一定是第$n$个坑。每两个管制路段之间会有一个没有被管制的路段，所以，在第一个坑和第$n$个坑之间，一共会有$m-1$个没有被管制的路段，即**会有$m-1$个“坑与坑之间的距离”会被浪费。**

为了使浪费最短，我们就可以用sort对每两个坑之间的距离进行排序，然后用第一个坑到第$n$个坑之间的距离依次减去前$m-1$个最短的浪费长度（两个坑之间的距离），就可以求出答案了。（~~这题太水了qwq~~

## CODE 

```cpp
#include <algorithm>
#include <cstdio>
using namespace std;

const int MAXN = 100005;
int n, m;
int a[MAXN], large[MAXN];//a数组存储每个坑的位置，large数组存储每两个坑之间的距离

int main() {
    scanf("%d%d", &n, &m);
    for (int i=0;i<n;i++)
        scanf("%d", &a[i]);//输入，不解释
                          
    for (int i=0;i<n-1;i++)//n个坑之间只会出现n-1个距离，这里记得是到n-1
   		large[i] = a[i + 1]-a[i]-1;//两端的两个坑不算，这里记得-1
  
    sort(large, large+n-1);//排序，不解释
  
    int ans = a[n - 1]-a[0]+1;//将管制路段总长初始化为第1个坑到第n个坑之间的距离。和前面不一样，由于两端的坑都要算，所以要+1
    for (int i=1;i<=m-1;i++)//m个路段有m-1个间隙，这里-1;
        ans -= large[n-1-i];//依次减去第1到第n-1小的两坑之间距离
                        
    printf("%d\n", ans);//输出，完美AC~
}
```

~~码风恶臭，不喜勿喷）~~

最后，祝所有看到这篇题解的大佬们：**AKIOI！**

本蒟蒻的第一篇题解，求管理大大通过~~