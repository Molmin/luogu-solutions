~~您正在收看的是蒟蒻 jch 的题解~~

[题目传送门](https://www.luogu.com.cn/problem/P2242)

[本文在博客中食用更佳](https://www.luogu.com.cn/blog/jch2008/solution-p2242)

 _**进入正题！**_ 
 
------------

**【前置知识】**

贪心、快速排序

------------
**【推导过程】**

看到这题，窝的第一反应不是贪心，而是分组dp：模板题啊！但是明显 $n^3$ 的复杂度是过不去的，加上斜优同样会 $\text{T}$。这其实是 dp 的优点：不需要想。很多人觉得 dp,bfs,dfs 难，实际上它们是最容易想到的解法。

一般来说，如果是 $O(n)$ 复杂度的解法，$n$ 肯定是要飙升至十万百万的，$n \leq 15000$ 的数据，大概率就是 $n \log n$的解法。这个复杂度的 dp，一般有两种可能：

- 可以用单调队列之类的玩意优化；
- 状态定义上满足单调性，比如最长上升子序列的 $f(i)$ 表示长度为 $i$ 的最长上升子序列的结尾，这样 $f(i)$ 就是单调递增的，可以二分。

但是显然答案并不满足单调性，即 $x$ 个单位距离是可行的，不代表 $x-1$ 个单位距离一定可行，因此无法 dp，更不能二分。

既然不能 dp，能不能靠同样是 $\log$ 级别的排序来解决呢？既然想到了排序，那排序什么呢？既然输入的数据是有序的，就很容易想到将两个点的距离排序了。

------------
**【中心思想】**

其实我们可以把题意简化，变成在一条一维数轴上有 $n$ 个点，现在要让 $m$ 个区间覆盖所有的点，要求这 $m$ 个区间长度之和的最小值。

显然，区间的左端点和右端点都在数轴的点上。因为有多段区间，显然区间不会覆盖整条数轴，会有 $m-1$ 段两点之间的线段不会被覆盖。

想让距离最小，我们不需要取每一条线段，有 $m-1$ 条线段不会被取到。我们肯定是会不取那些距离最长的线段，这样才会使总距离最小。

 _因此，本题的做法就出来了：_ 首先处理出相邻两点之间的距离，对距离从大到小排序，再用总长度减去 $m-1$ 段最长的长度即可。

------------
**【注意事项】**

你以为这就完了？其实模拟一遍样例就可以知道，我们算出来的答案会是21，而不是25。这是为什么呢？原来，一个 $\left[l,r\right]$ 的区间长度应为 $r-l+1$，而非 $r-l$。就算样例的 $m$ 改成18，答案也应该是18而非0。也就是说，对于每一个区间，我们都少算了一个单位长度，$m$ 个区间少了 $m$ 个单位长度，因此在输出答案时需要把 $m$ 加回来。

------------
**【代码实现】**
```cpp
#include<bits/stdc++.h>
#define MAXN 15010
using namespace std;
int n,m;
int arr[MAXN],dis[MAXN]; //分别表示每个点的位置和相邻两点的距离 
bool cmp(int x,int y) //sort的排序标准 
{
	return x>y; //从大到小排 
}
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;++i)
	{
		scanf("%d",&arr[i]); //读入每个坑的位置（其实arr数组可以优化掉，但这里会影响阅读体验，可以自行思考 
		if (i>1) dis[i-1]=arr[i]-arr[i-1]; //处理出相邻两点间的距离 
	}
	sort(dis+1,dis+n,cmp); //排序 
	int res=arr[n]-arr[1]; //一开始答案赋值为区间的总长度 
	for(int i=1;i<m;++i) res-=dis[i]; //可以不用取m-1段区间的长度 
	printf("%d\n",res+m); //少算了m个单位长度，输出时加上m 
	return 0; //程序结束记得return（20071007 
}
```
[record](https://www.luogu.com.cn/record/36654895)

切勿复制！

------------
$\mathcal{The}$ $\mathcal{end.}$