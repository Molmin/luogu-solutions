[原题](https://www.luogu.com.cn/problem/CF1667A)
## 题意
首先有一个初始化为 $0$ 的数组 $b$，现在给你一个长度为 $n$ 的数组 $a$，对于数组 $b$，每次操作可以使 $b_i$ 加上或者减去 $a_i$。要求：求使得数列 $b$ **严格递增**最小的操作次数。
## 分析思路
看样例解释并仔细分析题目，发现最后得到的序列中一定有一个 $b_i$ 值仍为 $0$。以该元素为分界点，序列左半边的 $b_i$ 值为负数，右半边的 $b_i$ 为正数。即从分界点往两边的绝对值越来越大。

因此我们可以遍历数组 $a$，枚举这个 $0$ 的位置，以此为分界点向前和向后遍历数组，分别减掉和加上 $a_i$。其实质是两边的绝对值不断加 $a_i$。因此在这里就直接用绝对值代替加减的区别了。

此时用变量 $k$ 来记录这个元素操作最少次数后这个元素的值。再用一个累加器记录最少操作数并输出就可以了。详情见代码。
## 代码
```cpp
#include <bits/stdc++.h>
#define ll long long//一定要看数据范围，记得开long long!! 
using namespace std;
ll n,a[5005],ans=0x7fffffff;
int main()
{
    cin>>n;
    for(ll i=1;i<=n;i++) cin>>a[i];
    for(ll i=1;i<=n;i++)//即枚举0所在的位置 
	{ 
    	ll k=0,sum=0;//k记录每次操作后的值 
		for(ll j=i-1;j>=1;j--)//向前操作 
		{
    		sum+=k/a[j]+1;//记操作数，达到上一次的值后多一次操作 
    		k=(k/a[j]+1)*a[j];//更新 
		}
		k=0;//一定要记得清空！ 
    	for(ll j=i+1;j<=n;j++)//同上，向后操作 
		{
    		sum+=k/a[j]+1;
    		k=(k/a[j]+1)*a[j];
		}
		ans=min(ans,sum);
	}
	cout<<ans;
}
```

本题的讲解到这里就结束了。但还是想稍稍总结一下从本题中学到的问题。

$1.$ 做题时一定要仔细读题，一个字都不要落，提取关键信息。比如本题，如果你能看到样例解释的话，应该能很快有思路。另外一定要看数据范围！像平时的比赛都很喜欢卡你 `long long`。

$2.$ 读完题之后要清楚的理解题意再开始做题。读懂了之后自然就很好做了，不然半懵的状态下是很困难的！

$3.$ 做完一道要注意积累总结方法经验，做到类似的题目时就很快有思路了。

## 完。