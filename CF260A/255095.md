考虑到每一次延长都要被 b 整除，所以，如果我们可以让一次延长后每次添加在末尾的数都不会改变整除性，这道题就迎刃而解了。

于是，我们把目光看向了 0 。

在数的末尾加上一个 0，其实就相当于将这个数$\times 10$，而这是不会改变整除性的。并且，因为 0 是最小的数字，所以这个数一定是“最小的”，也就是唯一的。

这样，我们就只需要考虑第一次延长的数是多少，之后在末尾一直加上 0 直到延长 $n$ 次。

如果它连一次都延长不了，那么直接输出 -1 就好了。

```cpp
#include <bits/stdc++.h>
using namespace std;
int a, b, n;
int main()
{
    scanf("%d%d%d", &a, &b, &n);
    for (int i = 0; i <= 9; i++) //从小到大枚举每一个“数字”
    {
        int x = 10 * a + i;
        if (x % b == 0) //被整除了！
        {
            printf("%d", x);                 //先把延长后的数输出
            for (int j = 1; j <= n - 1; j++) //把剩下的0全部写出来
                printf("0");                 //神奇的是，这里如果不加引号会出锅
            return 0;                        //可以结束程序了
        }
    }
    printf("-1"); //连一次都延长不了，直接输出-1
}
```