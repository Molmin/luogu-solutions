> 在一个仿真网络中传输一个 $n$ 比特的非负整数 $k$。各比特从左到右传输，第 $i$ 个比特的发送时刻为 $i$ 。每个比特的网络延迟总是为 $0\sim d$ 之间的整数(因此从左到右第 $i$ 个比特的到达时刻为 $i\sim i+d$ 之间)。若同时有多个比特到达，实际收到的顺序任意。
>
> 求实际收到的整数有多少种 ，以及它们的最小值和最大值。
>
> 例如，$n=3$，$d=1$，$k=2$ (二进制为`010`)实际收到的整数的二进制可能是 `001`(1)，`010`(2) 和 `100`(4)。
>
> $1\leq n\leq 64,0\leq d\leq n,0\leq k\leq 2^n $。
>

最小值和最大值都显然可以贪心。考虑求方案数。比较直接的想法就是设 $f_{i,j}$ 表示考虑前 $i$ 个 $0$ 和前 $j$ 个 $1$ 后，组成整数的方案数。但是转移并不知道要怎么转移，因为可能上一个 $0/1$ 的出现时间不确定，导致无法判定当前在整个数最右边插入 $0/1$ 是否合法。

然后就需要洞见一个比较深刻的性质了。考虑如果希望凑出某个数 $w$ ，那么对于任意时刻，最右边那位(指被收到的最右边那一位)必然可以**没有延迟** 。因为即使延迟了，结果也不会更优（即也不会存在没延迟拼不出来，只有延迟才能拼出来的情况）。证明的话比较简单，因为「若同时有多个比特到达，实际收到的顺序任意」，所以如果某个比特延后至 $>$ 最右边的数接收的时间，就可以调整成等于然后重排。

于是就可以知道，假设第 $i$ 位的发送时间是 $t_i$，那么考虑如何从 $f_{i,j}$ 转移到 $f_{i+1,j}$ 和 $f_{i,j+1}$ 。观察到本质上是要求插入一个新的 $1$ 或者新的 $0$ 。那么考虑假设第 $i+1$ 个 $0$ 的发送时间是 $t_0$ ，第 $j+1$ 个 $1$ 的发送时间是 $t_1$ ，那么如果为了让 $0$ 能够被尽早接收到，就需要满足 $t_0\leq t_1+d$ ，同理如果是想要 $1$ 能够尽量早到，就需要 $t_1\leq t_0+d$ 。于是转移时判断一下即可。复杂度 $O(n^2)$ 。

代码就不给出了，毕竟知道了这个性质之后就变成 xxs 转移了。