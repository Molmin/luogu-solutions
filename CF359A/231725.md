### 乍一看，这题好像很难欸……
但其实仔细思考一下，~~这题还是很水的。~~

其实，这道题目只要特判一下就好了。

### 首先：

因为每个“好”的单元格可以重复使用，而且每次都是一直把颜色画到矩形的一个顶点上。

那么，我们就可以一直从一个单元格开始直接把到任意一个顶点的大致是 $\frac{1}{4}$ 的单元格全部涂满。

有了以上发现，也就不难看出我们不需要再考虑有缝隙之类的复杂情况了。

所以可以得我们只需要判定一个单元格。

### 其次：

我们可以分析一下有几种可能的情况：

**第一：** 也就是最多的情况，需要 4 次，对于这个“好”的单元格没有要求。

**第二：** 3 次，也就是说有两个顶点可以一起画掉。那么也就是说这个“好”的单元格要在边上。

**第三：** 2 次，就是三个单元格可以一起画。但是这种情况并不存在，因为我们画的是矩形。也就是说想要两次画完，只能两个两个地画。那么就需要“好”的单元格要在边上。

**第四：** 1次，此时我们需要“好”的单元格在角上，但是题目中说明了“已知四个角落的单元格都是不好的单元格”，所以这种情况并不存在。

那么我们又可以发现：第二种和第三种情况是一样的。

**也就是说**，总共只有两种情况：“好”的单元点在边上；“好”的单元点不在边上。

### 最后：

主要做法也就是：在输入时，若此点是“好”的单元点，就判断其是否在边上。若在边上，就可以直接输出 2 ，然后退出了。反之就继续循环找满足条件三的点。

**以下是AC代码：**

------------

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m;
bool f;//因为只有0,1两种情况,所以此处使用了bool类型,可以节省空间 
int main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			cin>>f;
			if(f&&(i==1||i==n||j==1||j==m)){//判断此“好”的单位点是否在边上 
				cout<<2;
				return 0;//直接结束 
			}
		}
	}
	cout<<4;
	return 0;
}
```
###### ~~好像和楼上做法一样欸。~~