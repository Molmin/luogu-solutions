### 算法分析

我觉得这是选择行和列的问题。选择行和列时的得分为“行中所包含的数之和 $+$ 列中所包含的数之和 $-$ 行和列交点的数”。

实际上，如果按照“行中数之和 $+$ 列中数之和”从大到小的顺序检查  $N+1$  个的话，其中一定包含“行中所含 数之和 $+$ 列中所含数之和 $-$ 行和列交点的数量”是最大的。

假设第  $i$  行的总和为  $S_{i}$，第  $j$  列的总和为  $T_{j}$，第  $i$  行和第  $j$  列交点处的数为  $A_{i,j}$  我们需要求出  $\max \left(S_{i}+T_{j}-A_{i, j}\right) $。

注意到  $S_{i}+T_{j}-A_{i ,j}=S_{i}+\left(T_{j}-A_{i,j}\right)  $，那么  $\max _{j}\left(S_{i}+T_{j}-A_{i,j}\right)=S_{i}+\max _{j}\left(T_{j}-A_{i,j}\right)$。

对于  $\max _{j}\left(T_{j}-A_{i, j}\right)$  这一部分，我们可以用 `std: :multiset` 来维护  $N$  列的数字总和来查询。
特别地，对于交点是 $0$ 的情况，可以将当前行所在的每一列的数字总和都从集合中移除，然后在剩下的集合 中找数字总和最大的那一列即可。