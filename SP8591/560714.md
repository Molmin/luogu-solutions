## 思路

首先在这道题目中有两个需要处理的部分：

1. 质数。因为要求是不是质数，一次次的判断又太过麻烦，我们可以通过**欧拉筛**提前预处理好所有数据范围内的质数，最后直接判断即可。

	模板：
	```cpp
	for(int i=2;i<=n;i++)
	{
		if(f[i]==0) p[++cnt]=i;
		for(int j=1;j<=cnt,i*p[j]<=n;j++)
		{
			f[i*p[j]]=1;
			if(i%p[j]==0) break;
		}
	}
	```

2. 全排列。我们可以使用 C++ 内部的一个函数 `next_permutation`。

	`next_permutation`：将当前排列更改为**全排列中的下一个排列**。如果当前排列已经是**全排列中的最后一个排列**（元素完全从大到小排列），函数返回 `false` 并将排列更改为**全排列中的第一个排列**（元素完全从小到大排列）；否则，函数返回 `true`。`next_permutation(v.begin(), v.end())` 或 `next_permutation(v + begin, v + end)`。
   
   这是 OI wiki 中的解释，可以通俗的理解为每次更新一个全排列，没了，就返回 `false`。

就此这道题就可以 AC 了。