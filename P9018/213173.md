### Preface  
非常玄妙的组合数学思维题，需要善用部分分思维，本蒟蒻赛时读错题做到最后。  
### Problem  
给你一个从 0 到 $n$ 的数轴，一头奶牛会在上面走路，每次可以向左或向右移动一格，对于每个 $i$ 给定从 $i$ 到 $i+1$ 与从 $i+1$ 到 $i$ 的次数和 $a_i$，开始奶牛在点 0，最后需要回到点 0，问你转向次数最小的方案数一共有多少。

$n\leq 10^5$，$\sum a_i\leq10^6$。  

### Solution  
首先发现从 0 出发，回到 0，根据这个条件，我们可知任何一次从 $i$ 到 $i+1$，肯定会有一次对应的从 $i+1$ 到 $i$。这意味着对于任何 $i$，$a_i\bmod 2=0$。  

然后让我们先研究一下部分分，即 $n\leq 2$ 的情况。  
发现题目要求转向次数最少，这个条件十分可疑，于是我们先对于 $n\leq 2$ 的情况先手玩一下，做个分讨。   
由于接下来的操作并非单向移动而是往返，我们先将 $a$ 全部除以 2，然后做接下来的操作。

对于 $a_1\geq a_2$：  
我们肯定要做 $a_1$ 次的 $(0,1)$ 往返，在这个过程中需要带上 $a_2$ 次 $(1,2)$ 往返。  
然后我们发现我们可以做 $a_2$ 次 $(0,2)$ 往返，$a_1-a_2$ 次 $(0,1)$ 往返。  
容易发现，这个操作使得 $a_1-a_2$ 次的从向左变成向右的转向被合并了，达到了下限，其它都不优。  
那么这样的操作的总个数即为 $ \binom{a_1}{a_2}$。  

对于 $a_1\leq a_2$：  
同理，我们需要做 $a_1$ 次的 $(0,2)$ 往返，在其中做 $a_2-a_1$ 次的 $(1,2)$ 往返，同理也是最优的。  
应用插板法，操作总个数为 $\binom{a_2-1}{a_1-1}$。  

然后让我们扩展到 $n\leq 10^5$。  
我们将这 $n$ 个数的情况拆成 $n-1$ 个 2 个数的情况，可以发现他们是可以首尾相接的。  
  
对于子任务 $(a_i,a_{i+1})$，我们会经过 $a_{i+1}$ 对应边 $a_{i+1}$ 次，然后这样就跟下一个子任务 $(a_{i+1},a_{i+2})$ 相接上了，这样可以保证总体转向次数最小，换句话说就是第几次经过目前子任务的最后边后就相当于第几次通过下一子任务的第一条边，这样就把每一次到右端点之后向左转的转向与下一个子任务合并了，并且也把下一个子任务到达左端点后向左转的转向和这个子任务合并了。

那么这样的话答案就是所有子任务答案的乘积。

然后代码就很简单了：  
```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int N=1e6+10;
const int M=1e6;
const int mod=1e9+7;
int n,a[N],f[N],inv[N];int x,y;
void exgcd(int a,int b){
  	if(!b){x=1,y=0;return;}
  	exgcd(b,a%b);int t=x;
  	x=y,y=t-a/b*y;
}
int C(int x,int y){
	if(x==y||y==0)return 1;
	return (f[x]*inv[y]%mod*inv[x-y]%mod)%mod;
}
signed main(){
	ios::sync_with_stdio(0);cin.tie(0);cout.tie(0); 
	f[0]=1;
	for(int i=1;i<=M;i++){
		f[i]=f[i-1]*i;f[i]%=mod;
		exgcd(f[i],mod);
		inv[i]=(x%mod+mod)%mod;
	}
	cin>>n;int res=1;
	for(int i=1;i<=n;i++)cin>>a[i],a[i]/=2;
	for(int i=2;i<=n;i++){
		if(a[i-1]>=a[i]){
			res*=C(a[i-1],a[i]);res%=mod;
		}else{
			res*=C(a[i]-1,a[i-1]-1);res%=mod;
		}
	}cout<<res;
	return 0;
}
```
