本题的正解是记忆化搜索（但是有些写法我看不懂），我来发一个更加简单的写法。

#### 2020.10.18 upd：修正了一个锅，并修改了一些表述和排版

------------


首先先考虑暴搜的方法。

1. 定义 $ans$ 记录每一轮答案，$answer$ 记录最终答案；
2. 枚举每个点开始搜索，如果这个点珂以往下，那么令``ans++``；
3. 回溯的时候令``ans--``；
4. 如果四个方向都没有路了，令 $answer=\max(answer,ans)$。

但是这样会非常暴力。因此考虑优化。

------------


重新定义$ans$，**使用 $ans_{i,j}$ 表示到达位置 $(i,j)$ 的时候的最优解**。那么如果从当前位置能向四个方向走，那么令 

$$
ans_{i+dir1_k,j+dir2_k}=\max(ans_{i+dir1_k,j+dir2_k},ans_{i,j}+1)\quad(k=1,2,3,4)
$$

因此这个问题转化为了类似于求解二维的最长下降子序列的问题。

使用 $ans_{i,j}$ 记录之后，我们发现其实当从一个位置像四个方向搜索的时候，**如果当前位置的最优解$+1$小于等于要搜索的下一个位置的值，就没必要搜索了，执行最优性剪枝**。

有了这个优化，就可以AC此题了。（在滑雪那题里记搜和这个都写过，此方法稍微慢一些）

------------


总体过程如下：
1. 初始化$ans$数组为全1
2. 枚举所有位置，假设现在的位置为$(i,j)$，开始搜索：
   - 向四个方向搜索，如果$ans_{i+dir1_k,j+dir2_k}<ans_{i,j}+1$，则向那个方向搜索并更新那个方向的$ans$；
   - 其他有2种情况：一种是那个方向无法向下滑；另一种是向那个方向划没有比原先的路径更优。这两种情况都不用搜索，剪枝。
3. 搜索完成之后，令最终答案为
   $$
   \max\limits_{1\leq i\leq n,1\leq j\leq m}(ans_{i,j})
   $$
   
然后就好了。

有动态规划思想。

```cpp
int r,c,a[105][105],ans[105][105],i,j,maxn,n;
int dir1[5]={0,-1,1,0,0},dir2[5]={0,0,0,1,-1};
//表示当前搜索到了第x行第j列 
void search(int x,int y)
{
	for(int i=1;i<=4;i++)
		//第一个条件判断能否往下滑，第二个判断为剪枝 
		if(a[x+dir1[i]][y+dir2[i]]<a[x][y]&&ans[x][y]+1>ans[x+dir1[i]][y+dir2[i]])
		{
	        ans[x+dir1[i]][y+dir2[i]]=ans[x][y]+1;
	        search(x+dir1[i],y+dir2[i]);
	    }    
}
int main()
{
	cin>>n;
	while(n--)
	{
		char nam[105];
	    for(i=0;i<105;i++)
	        for(j=0;j<105;j++)
	            ans[i][j]=0,a[i][j]=99999;
	            //初始化ans和a数组 
	    maxn=0;
	    cin>>nam;
    	cin>>r>>c;
	    for(i=1;i<=r;i++)
	        for(j=1;j<=c;j++)
			{
	            cin>>a[i][j];
	            ans[i][j]=1;
	        }
	    for(i=1;i<=r;i++)
	        for(j=1;j<=c;j++)
	            search(i,j);
	            //所有起点都搜索一遍 
	    for(i=1;i<=r;i++)
	        for(j=1;j<=c;j++)
	            if(maxn<ans[i][j])
					maxn=ans[i][j];
					//所有终点都判断一遍 
	    cout<<nam<<": "<<maxn<<endl;
	}
    return 0;
}
```