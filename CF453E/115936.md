对一个上限取 $\min$ 感觉很恶心，所以拿最暴力的分块去搞。

散块暴力搞就行。

整块的话，我们可以把每个东西到达的上限的时间算出来，然后放到块里排序。假设块里上次的接触时间是统一的，那么这次查询会是排序后一段前缀的上限的和，和一段后缀的增长速度的和。由于这些东西是不会变的所以我们预处理即可。然后二分。

不统一怎么办？我们考虑还是直接暴力遍历整个块。因为每次询问至多只会贡献 $O(1)$ 个不整的块。所以这样的复杂度是正确的。

总复杂度是 $O(n\sqrt n\log n)$。可以通过。

https://codeforces.com/contest/453/submission/190186598

发现复杂度瓶颈在二分。

我们发现每次新增的时间如果 $\ge 10^5$，那其实和 $10^5$ 没啥区别。这启发我们对每个块预处理。

直接记录一个 $pre_{p,i}$ 和 $suf_{p,i}$ 表示在块 $p$ 里查询 $i$ 时查询到的前缀和后缀的值即可。

这样理论复杂度为 $O(n\sqrt n)$。但是由于空间问题所以要适当调大块长，最终效率不如 $O(n\sqrt n\log n)$。

https://codeforces.com/contest/453/submission/190189004