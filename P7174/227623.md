题目要求我们用若干已知数字构造一个最大的 $30$ 的倍数。

那么我们需要解决的问题有 $2$ 个：

1. 如何判断一个数是否是 $30$ 的倍数？
2. 如何用已知数字构造最大的数？

---

- ### 首先说 1：

我们知道，$30=10\times3$ 且 $\gcd(10,3)=1$，那么如果一个数 $a$ 满足 $3\mid a$ 且 $10\mid a$，那么 $a$ 肯定也满足 $30\mid a$。

首先是 $3$ 的整除特征。~~根据小学4年级课本~~，如果一个数各个数位上的数字之和能被 $3$ 整除，那么这个数就能被 $3$ 整除。又因为题目中每个数字均要用到，所以数字和是固定的，因此我们首先判断数字和是否为 $3$ 的倍数，若不是，则无法构造出能被 $3$ 整除的数，直接输出 $-1$。

$10$ 的整除特征就更简单了。若一个数末位为 $0$，则这个数能被 $10$ 整除。所以我们再判断一下给定数中有无 $0$，若没有，则无法构造出能被 $10$ 整除的数，直接输出 $-1$。

---

- ### 然后是 2：

要满足构造的数最大，只需要将每个数位上的数字按降序排序一遍就好了。

你可能会问：这样做能保证满足 1 吗？

答案是肯定的。数字和必然不用考虑，那么就剩末位的 $0$ 了。因为我们是按降序排列，所以如果给定数中有 $0$，那么某一个 $0$ 必然会被排到最后，自然满足了能被 $10$ 整除。这也就是题目的巧妙之处。

---

- ### $Tips:$

给定数的位数不超过 $1e5$，需要用数组or字符串存储。

---

代码：
```cpp
#include <bits/stdc++.h>
using namespace std;

const int MAXN = 1e5 + 5;
int a[MAXN];

bool cmp(int one, int two) {
	return one > two;
}

int main() {
	char c;
	int cnt=0, sum=0;
	bool flag=false;//flag表示给定数中有无0
	
	while(cin>>c) {
		a[++cnt] = c-'0';
		sum += a[cnt];
		if(!a[cnt]) flag=true;
	}	
	
	if(sum%3 || !flag) {//若数字和不能被3整除或者给定数中无0，则不存在合法的构造方案
		cout<<-1<<endl;
		return 0;
	}
	
	sort(a+1, a+1+cnt, cmp);
	for(int i=1;i<=cnt;i++) {
		cout<<a[i];
	}
	
	cout<<endl;
	return 0;
}
```
