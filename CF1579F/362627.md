## 思路

首先，如果所有位置都为 $0$ 直接输出 $0$。~~废话~~

其次，如果所有位置都为 $1$ 直接输出 $-1$。~~废话~~

那么，为什么所有位置都为 $1$ 就直接输出 $-1$ 呢。

显然这是因为这些 $1$ 无论如何都无法 $\&0 $ 。

那么我们就可以想到：如果这个序列中存在一个 $1$ 永远都不能 $\&0$ ，那么这个序列无解。

由题意，每个位置每次操作且的对象都是相同的（即 $a_i$ 每次都是 $\&$  同一个位置的数），我们设当前位置的对象为 $x$。

假设当前位置值为 $1$ ，那么当前位置变为 $0$ 当且仅当  $x$ 在上一次操作的时候变成了 $0$。假设 $x$ 为 $1$ ，那么当前位置变为 $0$ 当且仅当  $x$ 的对象在上上一次操作的时候变成了 $0$ 。这样依次类推下去，直到一个位置初始值就为 $0$ 。

显然如果一个 $1$ 他对象的对象的对象的对象 $\ldots$ 都为 $0$ 那么无解。

那么这道题就做完了。

## 代码

当我们遇到一个 $0$ 的时候，我们就从它的位置开始不断减 $d$，同时记录一个 $cnt$ 表示距上一个 $0$ 有多少步，遇到 $0$ 就将 $cnt$ 清 $0$ 
遇到 $1$ 就拿 $cnt$ 更新答案，同时经过的所有点标记访问，最后如果有没有访问到的点就输出 $-1$, 复杂度为 $\mathcal{O}({n})$。

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int t,n,d;
int a[1000005];
bool vis[1000005];
int main(){
	scanf("%d",&t);
	while(t--){
		for(int i=1;i<=n;i++)
			vis[i]=0;
		scanf("%d%d",&n,&d);
		for(int i=1;i<=n;i++)
			scanf("%d",&a[i]);
		int ans=0;
		for(int i=1;i<=n;i++)
			if(!a[i]&&!vis[i]){
				int cnt=0,st=i;
				while(!vis[st]){
					vis[st]=1;
					if(a[st])
						ans=max(ans,cnt);
					else
						cnt=0;
					st=(st-d+n-1)%n+1;
					++cnt;
				}
			}
		bool flag=0;
		for(int i=1;i<=n;i++)
			if(!vis[i])
				flag=1;
		if(flag)
			puts("-1");
		else
			printf("%d\n",ans);
	}
	return 0;
}
```

