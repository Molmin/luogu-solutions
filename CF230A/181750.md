这就是道排序的裸题啊
这道题相信只要学过排序的人都能做出来，因此在这里只讲排序的方法：

1.冒泡排序

冒泡排序的基本思想是：对相邻的元素进行两两比较，顺序相反则进行交换，这样，
每一趟会将最小或最大的元素“浮”到顶端，最终达到完全有序。
例如：我们要将身高不等的十个人站在一排，要求他们按照身高由低到高排队，设将 10
个人编号为 0~9 ，相邻的两个人依次比较，如果左边的比右边的人高，则交换两个人的位
置，否则不交换，直到最后两个人，即此时完成了一趟排序。一趟排序后，最高的人已经在
最右边了。

上代码，注意：不是本题的代码！！！
```cpp
#include <bits/stdc++.h>
using namespace std;
int a[1001], n;
int main ()
{
	cin>>n;
	for(int i=1;i<=n;i++)
		cin>>a[i];
	
	for(int i=1;i<n;i++)   //进行n-1轮冒泡 
		for(int j=1;j<=n-i;j++)   //每次进行n-i次比较 
			if(a[j]>a[j+1]) swap(a[j],a[j+1]);   //相邻元素进行比较，如果大的元素在前面，则交换 
			
	for(int i=1;i<=n;i++)
		cout<<a[i]<<" "; 
	return 0;   
}
```
可是冒泡排序的时间复杂度太高，以至于很有可能TLE，因此，我们引进桶排

3.桶排

桶排序是一种排序算法，实际上并没有进行比较排序，而是借助了数组。
假定有 1-100 个编号的桶（也就是定义一个长度为 100 的整型一维数组），每输入一个
数字·就在对应的桶上插一个小旗（也就是对应下标的桶加 1 次），如果这个数字出现了 n
次就在对应桶上插 n 个小旗，当所有数输入完毕时，只需要从下标 1 开始找那些数字是 1，
如果是 1 就打印 1 次，是 2 就打印 2 次，是多少就打印多少次。

为什么我们没有比较大小就排序出来了呢？因为数组下标本身就是已经排好了，只出现一次数就在对应下标上+1，然后遍历数组中那些大于 0 就行。

缺点：
使用桶排序占用内存很大，如果需要排序的数字是 1，10000 这两个数，也要定10000 个桶。因为必须在 10000 这个桶上插小旗嘛；由于桶的标号只能是整数（数组下只有整数），所以它并不能排序小数，只能排序整数。

优点：
相比冒泡排序，桶排序程序实现更加简单，而且效率也高了很多
继续上代码，也不是本题的代码
```
#include <bits/stdc++.h>
using namespace std;
int a[10001];
int main()
{
    int n, x;
    cin >> n;
    for (int i = 1; i <= n; i++)
    {
        cin >> x;
        a[x]++; // 记录 x 出现的次数
    }
    for (int i = 1; i <= 10000; i++) // 从头到尾扫一遍
        for (int j = 1; j <= a[i]; j++) //a[i] 表示 i 出现的次数
            cout << i << ' ' ;
    return 0;
}
```

3.STL快排
要说C++比别的语言好在哪，自然是它拥有丰富的STL库（标准模板库）。STL里有队列，栈，映射等很好用的函数，在此，我介绍sort函数
使用sort其实非常简单，只需sort(a,a+n)就行了，当然，如果数组下标从1开始，得用sort(a+1,a+n+1)。具体解释参考百度[sort函数](https://baike.baidu.com/item/sort函数/11042699?fr=aladdin)
上代码
```cpp
#include <bits/stdc++.h>
using namespace std;
int a[1001], n;
int main ()
{
	cin>>n;
	for(int i=1;i<=n;i++)
		cin>>a[i];
	
	sort(a+1,a+n+1);
	
	for(int i=1;i<=n;i++)
		cout<<a[i]<<" ";
	return 0;   
}
```
好啦，懂得了以上几种排序方法后，做这道题是不是很简单呢？
#### 看我写得那么认真，不留个赞再走吗？