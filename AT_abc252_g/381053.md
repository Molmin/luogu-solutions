# 思路
很显然啊，是个区间 dp，那么我们就来搞懂动态规划的四要素即可。首先是状态定义，我们定义 $f_{i,j}$ 以 $p_i$ 为根，区间 $p_i\sim p_j$ 满足条件的方案数。然后，递归起点就是当 $i$ 等于 $j$ 时方案数为 $1$ 了。那么就到最难的状态转移方程了我们先打一个区间 dp 的模板，求出 $i$ 和 $j$ 还有 $l$ 长度（这个就不讲了），然后在 $i\sim j$ 之间枚举一个中间点为 $k$，那么我们就要用到乘法原理了，我们发现若 $j$ 等于 $k$ 或 $p_{i+1}\leq p_{k+1}$ 我们都可以分成两部分，然后将他们的方案数相乘在累加，所以 $f_{i,j}=f_{i,j}+f_{i+1,k}\times f_{k,j}$ 这里有一个难点就是为什么后面是 $f_{k,j}$ 而不是 $f_{k+1,j}$ 其实这里是因为我们不能确定后面有多少棵子树，那么就有可能一些树不是以 $p_{k+1}$ 为根的，所以我们这里回到定义就能明白为什么是虚拟根了吧！其实就是用 $p_{k}$ 将另一边的所有子树给综合在一起求方案数，因为根节点确定了所以就没有影响了。最后输出 $f_{1,n}$ 即可。
# 代码
```
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int mod=998244353;
const int N=510;
int n, p[N];
int f[N][N]; //1.状态函数f[i][j]:即以p[i]为根，区间p[i, j]满足条件的树的方案数
signed main() {
	cin>>n;
	for(int i=1; i<=n; i++)
		cin>>p[i];
	for(int i=1; i<=n; i++)//2.递推起点
		f[i][i]=1;
	for(int l=2; l<=n; l++)//3.递推关系
		for(int i=1; i+l-1<=n; i++) {
			int j=i+l-1;//先序遍历:即深度优先搜索，以p[i]为根，画图
			for(int k=i+1; k<=n; k++) //先搜索p[i]的编号最小的第一棵子树p[i+1, k]
				if(k==j || p[i+1]<p[k+1])//再搜索p[i]的后面的子树p[k+1, ..不知道棵数]
					f[i][j]=(f[i][j]+f[i+1][k]*f[k][j])%mod;//搜索后面的子树，方法等价于以p[k]为根,即f[k][j]
		}
	cout<<f[1][n]<<endl;//4.答案
	return 0;
}
```