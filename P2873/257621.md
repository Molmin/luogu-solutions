**一道很普通的广搜题**

[题目传送门](https://www.luogu.com.cn/problem/P2873)

[更好的阅读体验？](https://www.luogu.com.cn/blog/5y2d1n/solution-p2873)

------------
### STEP 1 审题&&提取条件

1.给你一张地图（虽然没有边界）；

2.已知起始点$(0,0)$和终止点$(x,y)$；

3.地图上有$n$个点不能走；

4.求最短行走距离


------------
### STEP 2 分析题意&&提炼方法

- 有起始点~有终止点~有地图~还让求最短行走距离——**广度优先搜索**无疑啊！

- 所以我们要构造队列，并且用一个$visit$数组记录是否走过该点，用一个$ans$数组记录每个点的最短距离，然后用广搜的经典做法就好啦（稍后会有详细代码及注释）

- 但是这个地图**没有边界**啊？没关系，自己造一个足够大但又不是特别大的范围就好啦（当然应该可以不管边界，不过为了体现一般性，还是设个边界吧）

- 怎么处理**负数下标**呢？观察题目数据范围可知，每个点都在$-500$~$500$之间，所以我们可以将所以的点的坐标都加上1000，取相对位置就好啦


------------
### STEP 3 AC代码及完整注释
```
#include<bits/stdc++.h>//万能头文件
using namespace std;
int x,y,n,ma[2000][2000],v[2000][2000],ans[2000][2000];//x,y,n如题，ma为该点是否可以走（可以开成bool），v,ans如上所述
int dx[4]={0,0,-1,1};
int dy[4]={1,-1,0,0};//移动数组，每个下标相对应，代表四个方向
struct node{
	int x,y;
};//每个点的结构体
queue <node> q;//结构体队列
int main(){
    scanf("%d %d %d",&x,&y,&n);//输入
    x+=1000,y+=1000;//处理
    while (n--){//输入不能走的点
    	int x1,y1;
		scanf("%d %d",&x1,&y1);
		ma[x1+1000][y1+1000]=1;//标记	
	}
	node s;
	s.x=1000;s.y=1000;
	q.push(s);//放入初始点
	v[1000][1000]=1;//标记
	while (!q.empty()){//队列不为空时
		node w=q.front();//取出首位
		q.pop();//删除
		int s=ans[w.x][w.y]+1;//该变量为此次循环时所要标记的点的最短距离
		if (w.x==x&&w.y==y){
			printf("%d\n",s-1);//符合条件即输出
			return 0;
		}
		for (int i=0;i<4;i++){//四个方向
			node ww;
			ww.x=w.x+dx[i],ww.y=w.y+dy[i];//下一个点
			if (ww.x>=0&&ww.x<=2000&&ww.y>=0&&ww.y<=2000&&v[ww.x][ww.y]==0&&ma[ww.x][ww.y]==0){//在范围内并且该点没有走过而且可以走
				q.push(ww);//放入该点
				v[ww.x][ww.y]=1;//标记
				ans[ww.x][ww.y]=s;//记录
			}
		}
	}
    return 0;//虽然我相信它运行不到这里……
}
```


------------
### STEP 4 完结撒花！

本次题解就这么愉快地结束啦！如果还有什么不懂的问题，评论区恭候您的到来！我会第一时间回复哒！

如果都看懂了，就点个赞纪念一下你的成长吧！
