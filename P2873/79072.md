#### 宽搜入门题
[P2873泥水坑](https://www.luogu.org/problemnew/show/P2873)
####  题意转述：
清早6：00，Farmer John就离开了他的屋子，开始了他的例行工作：为贝茜挤奶。前一天晚上，整个农场刚经受过一场瓢泼大雨的洗礼，于是不难想见，FJ 现在面对的是一大片泥泞的土地。FJ的屋子在平面坐标(0, 0)的位置，贝茜所在的牛棚则位于坐标(X,Y) (-500 <= X <= 500; -500 <= Y <= 500)处。当然咯， FJ也看到了地上的所有N(1 <= N <= 10,000)个泥塘，第i个泥塘的坐标为 (A_i, B_i) (-500 <= A_i <= 500；-500 <= B_i <= 500)。每个泥塘都只占据了它所在的那个格子。 Farmer John自然不愿意弄脏他新买的靴子，但他同时想**尽快**到达贝茜所在的位置。为了数那些讨厌的泥塘，他已经耽搁了一些时间了。如果Farmer John 只能平行于坐标轴移动，并且只在x、y均为整数的坐标处转弯，那么他从屋子门口出发，最少要走多少路才能到贝茜所在的牛棚呢？你可以认为从FJ的屋子到牛棚**总是存在至少一条不经过任何泥塘的路径**。
#### 思路：
  根据“尽快”以及数据范围可以想出用BFS解答。但坐标可能为负数，故将泥坑坐标，原点坐标和终点坐标加500是个不错的选择；
  
小提醒：
  1：洛谷评测机最近不能有move，用```move[4][2]  ```
来移动的请改为``` mv[4][2]   ```
 
  2:初始化时不要忘记把原点定义为500,500,0,~~（我因此WA了一次）~~

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
struct node{
    int x;
    int y;
    int step;
};//结构体，用于储存
int mv[4][2]={{1,0},{-1,0},{0,-1},{0,1}};//移动方向
int n,nx,ny;
bool mark[1010][1010]={false},vis[1010][1010]={false};//mark数组用于记录泥坑位置，vis用于记录是否走过这个点
int BFS()//广搜
{
    int i,j;
    node a,b,c;
    a.x=500;
    a.y=500;
    a.step=0;//原点初始化
    queue<node>que;//定义队列，貌似可以用数组模拟
    que.push(a);//将原点压入队列
    while(!que.empty())
    {
     b=que.front();
     que.pop();//取出原点
     if(vis[b.x][b.y])
      continue;//当这个点走过时可以跳过这次寻找，因为要找最短路径
     if(b.x==nx+500 && b.y==ny+500)
      return b.step;//当到达终点时结束循环，并将步数返回至主函数
     vis[b.x][b.y]=true;//标记这个点
     for(i=0;i<4;i++)
     {
      c.x=b.x+mv[i][0];
      c.y=b.y+mv[i][1];//寻找下一个点，其实下面的c.step一句可以放到这里
      if(c.x>=0 && c.x<=1000 && c.y>=0 && c.y<=1000 && !mark[c.x][c.y])
      {
       c.step=b.step+1;
       que.push(c);
      }//判断扩展的点是否在边界内，若是，则将其压入队列
     }
    }
}
int main()
{
    int i,x,y;
    cin>>nx>>ny>>n;//输入原点坐标及泥坑个数
    for(i=1;i<=n;i++)
    {
     cin>>x>>y;
     mark[x+500][y+500]=true;
    }//预处理
    printf("%d\n",BFS());//调用BFS函数并输出
    return 0;
}
```
