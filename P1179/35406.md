这题大多数题解都是暴力，即判断每个数中2的个数再累加

时间是 r log r的，通过这题完全没问题

code:
```cpp
    #include<iostream>
    using namespace std;
    int l,r,t,s;
    int main(){
        cin>>l>>r;
        for(int i=l;i<=r;i++){
            t=i;
            while(t){//等同于t!=0
                if(t%10==2)++s;//t%10就是取最后一位
                t/=10;//t/=10就是删去最后一位
```
}//这就是分解数每一位的方法
        }

        cout<<s;

    }
可如果l,r<=10^18怎么办呢？

设1~x中2的个数为f(x)，答案就是f(r)-f(l-1)，类似前缀和

这个函数可以log时间求出

可以分别计算2在这个数个位，十位，百位...出现次数，再加起来

如51206

算个位：答案是1~51200中2在个位出现次数+51201~51206中2在个位出现次数

5120×1+1

算十位：答案是1~51200中2在十位出现次数+51201~51206中2在十位出现次数

512×10+0

算百位：答案是1~51000中2在百位出现次数+51001~51206中2在百位出现次数

51×100+7

算千位：答案是1~50000中2在千位出现次数+50001~51206中2在千位出现次数

5×1000+0

算万位：答案是1~51206中2在万位出现次数

10000
code:
```cpp
    #include<iostream>
    using namespace std;
    int l,r;
    int f(int x){
        int a=x,t=1,s=0;//t是这一位的权值(个位是1，十位是10……)，s是答案
        while(x){
            s+=x/10*t;//第一部分(1~XXX00)大块的部分
            if(x%10>2)s+=t;
            if(x%10==2)s+=a%t+1;//第二部分(XXX01~XXXXX)零头
            x/=10;//删掉最后一位
            t*=10;
        }
        return s;
    }
    int main(){
        cin>>l>>r;
        cout<<f(r)-f(l-1);
}
```