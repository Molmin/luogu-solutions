### 随手写一篇数位DP的题解好了。
先打个表看看2在1位，2位，3位数中出现的情况：

设$f(x)$为第$x$位数中2出现的次数，那么显然有$f(1)=1$。
接下来考虑$f(2)$，100是由10，20，$\dots$组成的，那么$0-10$里面有1个2，$30-40$里面也只有一个2，唯一不同的是$20-30$之间2的数目需要特殊计算。

假设$20-30$全部占满了那么2的数量会是$11$个，我们可以把$22$多出来的那一个$2$也看做上面的规律，那么$20-30$其实只是比原规律多了10个2，而10恰好是一位数的所有取值，也就是$10^1$。那么我们可以发现$f(2)= f(1)*10 + 10^{1}$。

由此可得一个规律$f(x)=10f(x - 1)+10^{x-1}$，对着数据验证了一下发现是正确的。

怎么利用这个公式呢？那么我们假设有一个三位整数数$abc$，如果$c \geq 2$那么我们可以保证$c$这个个位数一定向总数贡献了$f(1)$个2。如果小于2就没有贡献了。

接下来我们看$b$，如果$b > 2$那么它一定向总数贡献了$10,20,\dots,b0$所代表的2个数，也就是$bf(2)+10^1$个。如果小于2那么就是$bf(2)$个。

但是如果$b$刚好等于$2$那就比较麻烦了，我们需要先统计$b$这个位数之前的数，在这里是c。那么它一定还贡献了$c+1$个2（包括20的情况）。把这几种情况理清楚以后，a位上的贡献也就很容易求了。那么把这个规律扩展一下可得：

设数字为$a_n, a_{n-1},\dots, a_0$，那么$a_i$对于总数的贡献为

$$\begin{cases}a_i*f(i - 1)+10^{i-1}\ (a_i>2)\\
a_i*f(i - 1)+ \{a_{i-1}\dots a_0\}+1\ (a_i==2)\\
a_i*f(i - 1)\ (a_i<2)\end{cases}$$

设$R>L$答案即为$Num(R)-Num(L-1)$

下面是代码：


```cpp
int n, m, k;
int CASE = 1;
int tens[7];
int f[7];

int getV(int b) {
    if (!b) return 0;
    int i = 1;
    int sum = 0;
    int inv = 0;
    while (b) {
        int r = b % 10;
        if (i > 1 && r < 2) {
            sum += r * f[i - 1];
        } else if (i > 1 && r > 2) {
            sum += r * f[i - 1] + tens[i - 1];
        } else if (i > 1 && r == 2) {
            sum += r * f[i - 1] + inv + 1;
        } else if (i == 1 && r >= 2) {
            sum++;
        }
        inv += (b % 10) * tens[i - 1];
        b /= 10;
        i++;
    }
    return sum;
}

int main() {
#ifdef LOCALLL
    freopen("in", "r", stdin);
    freopen("out", "w", stdout);
#endif
    tens[0] = 1;
    for (int i = 1; i <= 6; i++) {
        tens[i] = tens[i - 1] * 10;
    }
    f[1] = 1;
    for (int i = 2; i <= 6; i++) {
        f[i] = tens[i - 1] + 10 * f[i - 1];
    }
    scanf("%d %d", &n, &m);
    printf("%d\n", getV(m) - getV(n - 1));
    return 0;
}
```
