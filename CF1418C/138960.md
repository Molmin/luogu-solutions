## 分析
注意到这题要按照顺序来取 $1$ ，而且在取的过程中是没有**后效性**的，故考虑采取DP来解决。

$f[i][1]$ 表示取完前 $i$ 个数后，且**最后一次抽取者是先手**，先手所能取到 $1$ 最少的个数。

$f[i][0]$ 表示取完前 $i$ 个数后，且**最后一次抽取者是后手**，先手所能取到 $1$ 最少的个数。

从而得到状态转移方程：
$$f[i][1]=\min(f[i-1][0]+w[i],f[i-2][0]+w[i-1]+w[i])$$

$$f[i][0]=\min(f[i-1][1],f[i-2][1])$$

至此基本解决了问题，不过，这题的初始化值得注意。

当 $i=0$ 时，应当是**认定为轮到后手取**才符合题意，初始化为 $f[0][0]=0$ 。

当 $i=1$ 时，状态只能由 $f[1][1]$ 向后续情况转移，因而  $f[1][1]=w[1]$ 。

因为是求 $\min$ ，因此首先应该全部初始化为`INF`。

```cpp
#include<bits/stdc++.h>
using namespace std;

const int N=2e5+5;
int f[N][2],w[N];

int main(){
	int T; cin>>T;
	while(T--){
		memset(f,0x3f,sizeof f); //初始化为INF
		int n; cin>>n;
		for(int i=1;i<=n;i++) cin>>w[i];
		
		f[0][0]=0; 
		f[1][1]=w[1];
		for(int i=2;i<=n;i++){
			f[i][1]=min(f[i-1][0]+w[i],f[i-2][0]+w[i-1]+w[i]);
			f[i][0]=min(f[i-1][1],f[i-2][1]);
		}
		
		cout<<min(f[n][1],f[n][0])<<endl;
	}
	return 0;
}
```