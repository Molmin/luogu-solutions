设 $f_i$ 为先手取到 $i$ 并且取 $a_i$ 时的最小代价，则 $f_i$ 可以从以下几种状态转移而来

先手取一个，后手在先手前面取了一个（也就是中间跳过一个数来取）: $f_{i-2}+a_i$

先手取一个，后手在先手前面取了两个: $f_{i-3}+a_i$

先手连续取两个的第二个: $\min(f_{i-3}, f_{i-4})+a_i+a_{i-1}$

$f_i$ 即为以上三种状态之一的最小值。

因为 $n$ 可能不取，所以状态转移到 $f_{n+1}$，$f_{n+1}$ 即为答案。（注意初始化 $a_{n+1}=0$）

因为最小是从 $f_{i-4}$ 开始转移，所以要初始化 $f_1,f_2,f_3,f_4$ 的值。

其中 $f_1=a_1$（只有取 $a_1$ 这个方案）

$f_2=a_1+a_2$（只有取 $a_1,a_2$ 这个方案）

$f_3=a_1+a_3$（只有取 $a_1,a_3$ 这个方案）

$f_4=a_1+a_4$（有取 $a_1,a_2,a_4$ 和 $a_1,a_4$ 两种方案，后者大于等于前者）

特判 $n\leq4$ 的各个情况:

当 $n\leq3$ 时，答案为 $a_1$ (必须取 $a_1$ 并且可以只取 $a_1$)

当 $n=4$ 时，答案为 $\min(f_2,f_3,f_4)$（后手可以在最后替先手取 $2,1,0$ 个的方案的最小值）

### $\mathcal{Code}$
```cpp
void solve() {
	n = read();
	for(int i = 1; i <= n; ++i)
		a[i] = read(), f[i] = 0x3f3f3f3f;
	a[n + 1] = 0;
	f[1] = a[1];
	f[2] = a[1] + a[2];
	f[3] = a[1] + a[3];
	f[4] = a[1] + a[4];
	f[n + 1] = 0x3f3f3f3f;
	for(int i = 5; i <= n + 1; ++i)
		f[i] = Min(Min(f[i - 2], a[i - 1] + Min(f[i - 3], f[i - 4])), f[i - 3]) + a[i];
	if(n <= 3) printf("%d\n", f[1]);
	else if(n == 4) printf("%d\n", Min(Min(f[2], f[3]), f[4]));
	else printf("%d\n", f[n + 1]);
}
````