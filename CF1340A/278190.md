## 题目大意

一个数字排序生成器[1~n的数字都只出现一次]，遵循以下规则：

1）生成一个数组$r$，$r_i$表示从位置$i$往后（包括$i$），第一个还没塞入数字的位置下标。

譬如要生成5个数字，目前生成结果为：$[1,x,x,2,x]$，则r数组为$[2,2,3,5,5]$。

2）生成一个count数组，$count_i$=r数组中等于i的元素个数。

以上面例子的r数组为例，$count=[0,2,1,0,2]$。

3）找到count数组里值最大的元素下标。若有多个则任取一个，然后将本次要放入的数字放入该下标中。

4）直到所有数字全部放入。

现在给你一个数字的排序，问你可不可能通过上面这种方式生成这种排序。

## 解题思路

我们很快可以发现，若本轮生成数字时，将数字放在了下标i上，则下一轮生成数字时，必须放在下标i+1上。

为什么？我们来模拟一遍。

第一轮生成数字，$r=[1,2,3,4,5],count=[1,1,1,1,1]$。可以随便放，假如我们放在3的位置。

第二轮生成数字，由于位置3已有数字，所以$r=[1,2,4,4,5],count=[1,1,0,2,1]$。

则此时只能放在位置4.

注意还要特判：若本轮放在了空数组的最后一位，则下一轮可以随便放。


## 参考代码
```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
int p[100005];
int vis[1000005];
int main()
{
    ios::sync_with_stdio(false);
    int t;
    cin>>t;
    while(t--)
    {
        int n;
        cin>>n;
        for(int i=1;i<=n;i++) cin>>p[i];
        for(int i=1;i<=n;i++) vis[p[i]]=i;//每个数字生成的下标
        int last=n,f=1;
        p[0]=1e8;
        for(int i=1;i<=n;i++)
        {
            while(p[last]<i) last--;//确定目前最后一位在哪里
            if(vis[i]==last)//如果这个数字放在最后一位，则满足算法
            {
                last--;
                continue;
            }
            else//否则
            {
                if(vis[i+1]==vis[i]+1)//如果下一轮生成位置在本轮后面，则满足
                {
                    continue;
                }
                else//否则不满足
                {
                    f=0;
                    break;
                }
            }
        }
        if(f) puts("Yes");
        else puts("No");
    }
    return 0;
}
```



