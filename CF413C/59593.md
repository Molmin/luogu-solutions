[CF413C](https://www.luogu.org/problemnew/show/CF413C)：

这道题是可以贪心通过的一道题，具体思路是将可以翻倍关卡放在后面，且按从大到小排序，依次贪心。

因为自己可以安排关卡的通过顺序，所以我们要把不能翻倍的关卡分数先拿到，然后再处理可以翻倍的关卡。对于可以翻倍的关卡，如果通过关卡所得到的分数比翻倍之前的得分所得分大，则应选择
得到关卡的对应分数，否则应选择翻倍，这样处理最优。

那么此处存在一种特殊情况：n==m，即每个关卡均可以翻倍，对于这种情况，先对关卡得分降序排序，再进行处理。最大分数的关卡要选择得分而不翻倍，后面的关卡选择翻倍而不得分，这样处理最优。因为无论之后的关卡得分最多与此关卡得分相同而不会比它大（因为已经排序过），所以应选择翻倍而不得分，这样得分最大，处理最优。

那么综合以上的两种情况，得到的程序最优。

由于要排序，为了方便我们进行后期处理，所以我们用结构体存放数据。

对于其中处理排序的方法，可以写一个以不可翻倍的关卡放在可翻倍的关卡之前为首要条件，关卡对应分数降序为次要条件的自定义比较函数。

那么综上所述以后写成的AC代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m;
long long ans=0;//答案在64位带符号整型范围内所以开ll足够。
struct numbe
{
	int a;
	bool b;
}num[105];//存数用结构体
bool cmp(numbe a,numbe b)
{
	if(a.b==b.b)//如果两者皆可翻倍或皆可不翻倍，则应按得分降序排列。
		return a.a>b.a;
	else//不可翻倍的关卡应放在最前以便于后面翻倍
		return a.b<b.b;
}//自定义排序比较函数
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&num[i].a);
	}
	for(int i=1,w;i<=m;i++)
	{
		scanf("%d",&w);
		num[w].b=1;
	}
	sort(num+1,num+n+1,cmp);
	if(n!=m)//一般情况
		for(int i=1;i<=n;i++)
		{
			if(!num[i].b)ans+=num[i].a;//不翻倍则得分
			else ans+=max((long long)num[i].a,ans);//若翻倍得分比不翻倍而得关卡分得分小，则得题目分，否则得翻倍分。
		}
	else//n==m的特殊情况
	{
		ans=num[1].a;//在排序后，最大分数的关卡得分而不翻倍，后面的关卡选择翻倍最优。因为无论怎么翻倍都不会比此关卡得分翻倍得分大。
		for(int i=1;i<n;i++)
		{
			ans*=2;
		}
	}
	printf("%lld\n",ans);
    return 0;
}
```