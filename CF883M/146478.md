## 思路
首先很容易想到，走过的路线围成的图形最好是**长方形**。

如果图形向内凹陷，那么可以让其变成一个最小的外接长方形，这样周长不增，并且面积增加了。

考虑完这个之后，题目就变成了求最小的长和最小的宽。

如果 $(x_1,y_1),(x_2,y_2)$ 是两个**不同且不共线的点**，不妨设 $x_1<x_2,y_1<y_2$，那么显然我们可以从 $(x_1,y_1)$ 走到 $(x_2+1,y_1)$，再走到 $(x_2+1,y_2+1)$，再走回来即可。这样的答案是 $2\times (|x_1-x_2|+|y_1-y_2|+2)$。

那么如果这两个点共线呢？比如说，$x_1=x_2$。那么之前的策略还可行吗？显然，不可行。因为在从 $(x_1,y_1)$ 走到 $(x_2+1,y_1)$ 时，并没有包含 $(x_2,y_2)$。所以说长方形的宽还需增加 $1$，也即答案增加 $2$。

如果这两个点相同，那么经过尝试可以知道最好的方式答案是 $10$。但是题目中并没有这样的样例。

就是这样了，总结一下，需要考虑三种不同的情况，对于每种情况进行求解。

$$\text{Talk is cheap, show you the code.}$$
## Code
```cpp
#include<bits/stdc++.h>
using namespace std;
struct Node{
	int x,y;
}a,b;
int main(){
	scanf("%d%d%d%d",&a.x,&a.y,&b.x,&b.y);
    if(a.x==b.x&&a.y==b.y) printf("10\n");
    //如果共点，直接输出结论
	else if(a.x==b.x) printf("%d\n",2*abs(a.y-b.y)+6);
    //如果共线，则同思路输出答案。
	else if(a.y==b.y) printf("%d\n",2*abs(a.x-b.x)+6);
	else printf("%d\n",2*abs(a.y-b.y)+2*abs(a.x-b.x)+4);
    //否则就是一般的情况。
    return 0;
}
```