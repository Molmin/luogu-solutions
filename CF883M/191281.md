$$\Large\text{一道非常水的橙题}$$

## 1.如何求最短路径

显而易见，最短路线就是使起点与旗子在一个矩形的对角线上：

![](https://cdn.luogu.com.cn/upload/vjudge_pic/CF883M/386c66ca9620cccfa6fb068c3cb9fb65984ca527.png)

譬如题目中的这个图，我们可以知道想要走最短路必须在到达旗子之前始终朝向旗子，而绕完旗子之后始终朝向起点。那么学过小学数学的同学肯定都知道这些线段都是可以平移的。将图中弯弯曲曲的飞行路线平移成为一个矩形以后，我们很容易发现这个矩形就是```以```起点$(1,5)$```和```旗子的左下角$(6,1)$```为对角线```的矩形，飞行路线的长度就是这个矩形的周长。

## 2.如何确定矩形长和宽

矩形的其中一个顶点很好求，就是起点的坐标$(x_1,y_1)$

对于另外一个顶点我们可以分类讨论，按照旗子与起点的位置关系来分$4$种情况来分别算出另一个顶点从而算出长和宽。

不过，这里给出一个更好的算法：

因为我们需要绕旗子一圈，所以如果我们以旗子坐标$(x_2,y_2)$为矩形的另一个顶点的话，那么我们要的答案实质上就是使这个矩形的长宽各$+1$而算出的那一个矩形的周长，因此我们就得出了公式：

$$ans=(|x1-x2|+1+|y1-y2|+1)\times 2$$

## 3.坑点

事实上，如果只是将上面的公式代进去，是得不出正确答案的，甚至连样例都过不了。

因为我们还需要讨论几种情况：

1. 顶点与旗子的连线与坐标轴平行（即 $x_1=x_2$ 或 $y_1=y_2$ ）:

这种情况下我们可以理解为：必须要让飞行路线宽一点才能把旗子包括进去。

那么因为矩形的宽度至少也是$2$，宽度只有$1$，那么很明显我们要向两边飞一点才能把旗子包括进去。而这个多飞的宽度明显是$1$。

那么也就是说如果发生了这种情况，我们只需要将原先求得的答案$+2$即可！

2. 顶点与旗子重：

虽然我不知道数据中有没有这种情况，但还是要预防万一:

这种情况无论怎么说都能很容易看出需要的步数是$10$（离开起点绕旗子一圈再回到起点，共需要$10$步）

那么我们特判输出$10$即可。

## 代码

双手奉上$AC$代码：

```cpp
#include<iostream>
#include<cmath>
#include<cstring>
using namespace std;
int main()
{
	int x1,y1,x2,y2,ans;
	cin>>x1>>y1>>x2>>y2;
	if(x1==x2&&y1==y2)
	{
		cout<<10;
		return 0;
	}
	ans=((abs(x1-x2)+abs(y1-y2)+2)*2);
	if(x1==x2||y1==y2)ans+=2;
	cout<<ans;
	return 0;
}
```

$$\Large\text{祝您好运！}$$