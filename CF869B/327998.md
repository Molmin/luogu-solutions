读完题目，我们可以发现这题实质上就是让我们求两个数的阶乘的商模 $10$ 的余数。但题目中给的数据是 $0\leq a\leq b\leq 10^{18}$ ，显然直接使用阶乘会直接炸掉（用` python` 也会 `TLE`），因此这种方法直接否决。

但是，经过一番观察，我们发现这里 $a!$ 和 $b!(a\leq b)$ 有很大一部分是“重叠”的，即：

$$\dfrac{b!}{a!}=\dfrac{b\cdot (b-1)\cdot\ldots\cdot1}{a\cdot(a-1)\cdot\ldots\cdot1}=b\cdot(b-1)\cdot\ldots\cdot(a+1)$$

因此可以利用这个方法大大减缓计算量。

**但这样还是不行的**。注意在这种情况下，我们并没有对差距特别大的数做出**实际的优化**。比如说我们输入 $1$ 和 $100000000000$ ，用上面的公式还是需要将$100000000000$个数相乘，没有减少计算量。因此还需要发掘其它的性质。

- 这里我们注意到模 $10$ 计算的优点：碰到一个 $5$ 和一个 $2$ 个位基本就是 $0$ 了。
- 进一步看，也即当两个数满足$b-a>5$时，$\dfrac{b!}{a!}$ 的末位一定是 $0$（这里用到了“任何连续 $n$ 个数的乘积一定被 $n$ 整除”这个性质）

- 这样计算就大大优化了。比如说我们输入 $1$ 和 $100000000000$ ，根据上面的算法，无需计算就可以直接得出答案是 $0$ 。因此可以看到，用适当的数学知识可以减轻计算机的工作量！

上代码：
```cpp
#include <iostream>
using namespace std;

int main()
{
	long long a, b, al, bl;
	int ans = 1;
	cin >> a >> b;
	if (b - a > 5)
		cout << 0;
	else
	{
		for (long long i = a + 1; i <= b; i++)
		{
			ans = (ans % 10) * (i % 10);
		}
		cout << ans % 10;
	}	

	return 0;
}
```

（留个赞再走吧