## 算法 一

这个问题可以使用动态规划来解决。

首先，我们定义一个二维数组 $dp$，其中 $dp_{i,j}$ 表示前 $i$ 位数字被划分成 $j$ 个区间的方法数。初始化时，$dp_{0,0} = 1$，表示没有数字且没有区间的情况下有一种划分方法。

然后，我们遍历数字的每一位，并根据当前位能否被 $M$ 整除来更新 $dp$ 数组。具体更新的方式是：

- 若当前数字可以被 $M$ 整除，则对应的区间数等于上一位划分的区间数   $dp_{i - 1,j}$。

- 若当前数字不可以被 $M$ 整除，则对应的区间数等于上一位划分的区间数与前一位划分的区间数之和 $dp_{i - 1,j} + dp_{i - 1,j - 1}$。

最后，输出 $dp_{N,N}$ 即为所求的答案。



## 算法 二

我们可以用搜索解决。

时间复杂度：$O\left(2^n \right)$。

先将问题简化，假设我们已经求出了数列的前 $i$ 位的方案数 $f_{i}$，现在要求出数列的前 $i + 1$ 位的方案数 $f_{i + 1}$，那么可以分为两种情况。

- 将 $i + 1$ 位归入前一段，这时候前 $i$ 位被划分为 $k$ 段，且第 $k$ 段的数可以被 $m$ 整除。这样前 $i + 1$ 位的方案数为 $f_{i + 1} \leftarrow f_{i + 1} + f_{k}$。

- 将  $i + 1$  位作为一段，那么前  $i + 1$  位的方案数为  $f_{i + 1} \leftarrow f_{i + 1} + f_{i}$。

最终得到的 $f_n$ 就是答案。

-----------------------------------------------------------------

代码自己写吧。