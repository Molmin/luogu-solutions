首先，你想要AC此题，就必须搞懂这个三角形的本质究竟是神马。

大家可以算一算，设一个较小的数，模拟一下。

比如偶设n=5，按照题目中的要求一步步模拟：
```
a     b     c     d      e
  a+b   b+c   c+d     d+e
   a+2b+c b+2c+d  c+2d+e
    a+3b+3c+d b+3c+3d+e
        a+4b+6c+4d+e
```
好，最终我们通过一步步的模拟，算出当n=5时，1~5位上对应的权值应该是：
```
位数 1 2 3 4 5
权值 1 4 6 4 1
```
想必各位萌新看到这很激动——这不就是杨辉三角的第五行么！！！

别急，我们再来验证一个,设n=8，我们再来模拟一遍：
```
a       b      c       d       e        f        g       h
 a+b      b+c      c+d      d+e      e+f       f+g     g+h
  a+2b+c    b+2c+d    c+2d+e    d+2e+f    e+2f+g   f+2g+h
   a+3b+3c+d  b+3c+3d+e  c+3d+3e+f  d+3e+3f+g  e+3f+3g+h
    a+4b+6c+4d+e b+4c+6d+4e+f c+4d+6e+4f+g d+4e+6f+4g+h
     a+5b+10c+10d+5e+f b+5c+10d+10e+5f+g c+5d+10e+10f+5g+h
      a+6b+15c+20d+15e+6f+g b+6c+15d+20e+15f+6g+h
       		a+7b+21c+35d+35e+21f+7g+h
```
经过一番激动人心的验算，我们算出了当n=8时，1~8位对应的权值：
```
位数  1  2  3  4  5  6  7  8
权值  1  7  21 35 35 21 7  1
```
。。。算到这里，结论已经很明确了。。。

#最终答案=该位杨辉三角中的数*该数#

所以，本题的第一步，你需要先算出第n行杨辉三角的值是多少。
```
c[1][1]=1;//最左上角的数初始化为1
for(int i=2;i<=n;i++)//由于这里数组的记录是从1开始记的，所以不用担心越界
	for(int j=1;j<=i;j++)
		c[i][j]=c[i-1][j]+c[i-1][j-1];//每个数都等于它肩上两数之和
```
#至此，辉煌的第一步完成了#

接下来，就是④字：

#暴力深搜！#

注意，在深搜的过程中要好好剪枝，不然你会_TLE_嘻嘻

由于本人是萌新，代码不难看懂吧：）
```
#include <bits/stdc++.h>//万能头文件
using namespace std;
int n,p;//输入必备
int a[13];//输出必备
int c[13][13];//杨辉三角必备
bool b[13];//判重必备
void dfs(int dep,int s)
{
	if(s>p)//如果现在累加的数已经超过了给定的数，就返回
		return;
	if(dep>n)//如果已经搜完了n个数，就返回
	{
		if(s==p)//如果答案跟给定的数相等
		{
			cout<<a[1];
			for(int i=2;i<=n;i++)
				cout<<" "<<a[i];//输出
			exit(0);//终止程序
		}
		return;//如果没有输出答案，就返回
	}
	for(int i=1;i<=n;i++)
	{
		if(b[i]==false)//如果当前这个数没有用过
		{
			b[i]=true;//标记成用过
			a[dep]=i;//保存第dep个取的数
			dfs(dep+1,s+i*c[n][dep]);
			b[i]=false;//注意这里要将状态回归，不然TLE
		}
	}
}
int main()
{
	cin>>n>>p;//输入
	c[1][1]=1;
	for(int i=2;i<=n;i++)
		for(int j=1;j<=i;j++)
			c[i][j]=c[i-1][j]+c[i-1][j-1];//生成杨辉三角
	dfs(1,0);//开启深搜之旅
	return 0;
}
```
本弱弱的第二篇题解。

#感谢大佬欣赏#