此题的思路还是很简单的，可以直接打印杨辉三角，然后使用dfs枚举，遇到第一个解就输出并终止。（dfs正序枚举可以保证第一个解的字典序最小）~~当然你也可以直接枚举全排列~~

dfs过程就近乎是一个模板，这里就不赘述了。但是，我看了题解之后却发现了一个问题——好像杨辉三角大部分使用二维存储。

## 这样，我就发现我打出了一个空间优化。

就是在双重循环的条件下使用一维数组存储杨辉三角，递推式很长，直接上代码吧——

```cpp
for(register int i=1;i<=m;i++)//外循环是层数
    {
        for(register int j=i*(i-1)/2+1;j<=i*(i-1)/2+i;j++)//内循环是当前这一层的个数
        {
            if(j==i*(i-1)/2+1||j==i*(i-1)/2+i)//如果在最边上，就赋值成一
            b[j]=1;
            else b[j]=b[(i-2)*(i-1)/2+j-i*(i-1)/2-1]+b[(i-2)*(i-1)/2+j-i*(i-1)/2];//如果不在边上就根据上一层递推出当前数（杨辉三角基本性质都知道吧）
        }
    }
```

于是乎，这样我们就把空间从二维优化到了一维，虽然因为此题数据小，二维根本不会爆掉，但有优化肯定是好事啊。（集思广益嘛）

最后，来抬上代码——

```cpp
#include<iostream>
#include<stdlib.h>
using namespace std;
int n,m,k,ans[100000],vis[10000];
short b[1234567],a[10000];
void dfs(int i,int s)
{
    if(i>n)
    {
        if(s==0)
        {
            for(int j=1;j<=n;j++)
            cout<<ans[j]<<" ";
            exit(0);//必须用stdlib.h头文件
        }
    } else {
        for(int j=1;j<=min(s/a[i],n);j++)//其实上界还可以优化到n和还放得下的最大值这两个数中的较小数
        {
            if(vis[j]==0)
            {
            	ans[i]=j;
        	    vis[j]=1;
         		dfs(i+1,s-j*a[i]);
         	    vis[j]=0;
            }
        }
    }
}
int main()
{
    cin>>n>>m;
    int j1=0;
    for(register int i=1;i<=n;i++)//打印杨辉三角
    {
        for(register int j=i*(i-1)/2+1;j<=i*(i-1)/2+i;j++)
        {
            if(j==i*(i-1)/2+1||j==i*(i-1)/2+i)
            b[j]=1;
            else b[j]=b[(i-2)*(i-1)/2+j-i*(i-1)/2-1]+b[(i-2)*(i-1)/2+j-i*(i-1)/2];
            if(i==n)//保存目标层数
            {
                j1++;
                a[j1]=b[j];
            }
        }
    }
    dfs(1,m);
}
```
