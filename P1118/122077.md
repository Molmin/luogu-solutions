正如前辈所说此题正是杨辉三角与深搜，但我与别人不一样，杨辉三角我打表！！！
不废话 上代码
```cpp
#include <iostream>
#include <cstdlib>
#include <cstring>
using namespace std;
int db[13][13]={
{0,0,0,0,0,0,0,0,0,0,0,0,0},
{0,1,0,0,0,0,0,0,0,0,0,0,0},
{0,1,1,0,0,0,0,0,0,0,0,0,0},
{0,1,2,1,0,0,0,0,0,0,0,0,0},
{0,1,3,3,1,0,0,0,0,0,0,0,0},
{0,1,4,6,4,1,0,0,0,0,0,0,0},
{0,1,5,10,10,5,1,0,0,0,0,0,0},
{0,1,6,15,20,15,6,1,0,0,0,0,0},
{0,1,7,21,35,35,21,7,1,0,0,0,0},
{0,1,8,28,56,70,56,28,8,1,0,0,0},
{0,1,9,36,84,126,126,84,36,9,1,0,0},
{0,1,10,45,120,210,252,210,120,45,10,1,0},
{0,1,11,55,165,330,462,462,330,165,55,11,1},
};//杨辉三角 
int a[20];//存储数 
int n,sum;
int su=0;//当前的和 
bool b[20];//判断一个数有没有被用过 
void dfs(int x){
	if (x==n+1){//深搜边界 
		if (su==sum){
			for (int i=1;i<=n;i++){
				cout<<a[i]<<' ';
			}
			exit(0);
		}
		return;
	}
	if (su>sum) return;//剪枝（过了边界就回去）（不剪枝两个TLE） 
	for (int i=1;i<=n;i++){//深搜模板（从1到n枚举数） 
		if (b[i]==false){
			b[i]=true;
			a[x]=i;
			su+=i*db[n][x];
			dfs(x+1);
			su-=i*db[n][x];
			b[i]=false;
		}
	}
}
int main(){
	cin>>n>>sum;
	memset(b,0,sizeof(b));
	dfs(1);
}
```