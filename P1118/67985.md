~~（我被这题目坑的好惨）~~

咳咳，首先非常明显的一个杨辉三角大家应该都可以看出来，楼上有一群大佬讲过我也就不多说了。

（~~看到数字三角不应该第一个想到杨辉么？）~~

实际上我第一次看到这题的时候手推一遍答案是1119来着。所以说要好好看题啊，这种排列个叫（~~叫什么来着？~~），题目要求的是全排列，这意味着第一行N以内的整数必须全部出现且仅有一次出现。

废话不多说了（~~好像已经说了很多废话~~）我本人本来学的是pascal,由于举办方将残忍的废除pascal的参赛资格我才不得不转C++，所以我的代码几乎没有做过压缩（~~不然我自己都看不懂~~），所以我相信你们是可以看得懂代码和注释的,

（~~代码好丑~~）

```cpp
#include<bits/stdc++.h> 
using std::cin;
using std::cout;
using std::endl;
int a[15][15],num[15],n,m;//a数组存放杨辉三角，num放原始数据
bool b[15]={false};//b数组用于判断数字是否已经用过
void work(int dep,int sum)
{
	if (sum>m) return; //这里有一个小剪枝，作用不是太大，聊胜于无，去了也能AC
	if (dep>n&&sum==m){
		cout<<num[1];
		for (int j=2;j<=n;j++)
	    	cout<<' '<<num[j];//由于是DFS，第一个一定是最小的，直接输出推出就好了
	    cout<<endl;
	    exit(0);
	}
	else {
		for (int i=1;i<=n;i++)
		{
			if (b[i]==false){
				b[i]=true;
				num[dep]=i;
				work(dep+1,sum+a[n][dep]*i);//后面那个是计算结果
				b[i]=false;//要记得重置，不然会出问题
			}
		}
    }
 } 
int main(){
	cin>>n>>m;
	for (int i=1;i<=n;i++) 
	{
		a[i][1]=1;
		a[i][i]=1;
	}
	for (int i=3;i<=n;i++)
		for (int j=2;j<=i-1;j++)
		{
			a[i][j]=a[i-1][j]+a[i-1][j-1];
		}//上面全部在构建杨辉三角
	work(1,0);
	return 0;
}
```
好多巨佬在构建杨辉的时候都好有想法，我这个蒟蒻嫌麻烦（~~其实是不会~~）就写了一个水水的杨辉糊弄一下拉。

orz

第一次发题解，不喜勿喷。