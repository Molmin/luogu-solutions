首先是这道题的评分，个人认为只要找到了递推公式，其实是很简单的。

个人评分：$\textbf{\small\colorbox{Yellow}{\color{white}{普及/提高—}}}$

### 开始正题

我们注意到，这是一道数论题。

题目简化一下就是：在$[1,1e6]$的范围内找出一个数用$2$或$3$的和表示的结果。

乍眼一看这就是求一个递推式。

如果用暴力做，肯定会TLE。

在这里推荐三种方法：

- 1.使用OEIS（雾

$OEIS$的确是个很好的平台。用暴力打出前几位，然后search。

不过问题是：没法在考场上使用和受限性很大（要么有很多个，要么没有）

个人评价：不推荐。

- 2.和其他数列对比。

我们有很多耳熟能详的基本数列，如等差数列，等比数列，斐波那契数列等等很多。

这里我们选的是斐波那契数列。

观察这幅图：（求有多少种方案使$2\times 1$的骨牌铺满$2\times n$的方阵）

我们可以发现：每个竖列要么是有两个横着的骨牌，要么是由一个竖着的骨牌组成的。

也就是一个数用$1$与$2$的和表示的结果。

和这道题有异曲同工之妙。

因为斐波那契数列的递推公式是：$$f(n)=f(n-1)+f(n-2)$$

类比此题，我们也可类比出，此题的递推公式是：$$f(n)=f(n-2)+f(n-3)$$

个人评价：不错。

- 3.直接推递推公式。

观察知对于最后一次加法，加数只有$2\;,\;3$两种可能。于是得出递推公式：
$$f(n)=f(n-2)+f(n-3)$$

个人评价：视情况而定。有时很方便（如此题），有时很难。

---------

代码如下：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a,f[1000010];
int main(){
	f[2]=f[3]=1;
	for(int i=4;i<=1000000;i++)f[i]=(f[i-2]+f[i-3])%1000000007;
	scanf("%d",&n);
	while(n--)scanf("%d",&a),printf("%d\n",f[a]);
}
```
主要要注意两点：

1. 得数需要对$1000000007$取模，别忘了。

2. 数据范围是${n\in [1,1000000]}$。
