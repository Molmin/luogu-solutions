## 思路

- 如果是 $n$ 个矩形相交，那么我们只需要找到 $\max x_1, \max y_1, \min x_2 $ 以及 $\min y_2$ 这四个值组成的矩形。

	如果您无法理解，可以参考下图：
    
    ![](https://cdn.luogu.com.cn/upload/image_hosting/ykodhpfm.png)
    其中，红色的边 $y$ 坐标为 $\min y_2$ ，绿色的边 $x$ 坐标为 $\min x_2$ ，黄色的边 $y$ 坐标为 $\max y_1$ ，蓝色的边 $x$ 坐标为 $\max x_1$ 。
    
    它们将会围成一个**可能存在**的矩形。我们只需要判断矩形存不存在即可知道是否有符合要求的点。

- 现在是 $n - 1$ 个矩形相交，怎么办呢？

	其实，如果含有最大值或最小值的矩形被删去，那么我们**使用 次大/小值 代替 最大/小值 进行计算即可**。
    
   所以，对于每一个坐标，我们只需要维护一个最大/小值和一个次大/小值即可。至于判断，我们需要记录最大值包含在哪个矩形里。最后枚举一遍删去哪一个矩形，判断该矩形是否会影响到最大/小值的使用即可。
   
   我的代码里用了四个一维数组代替变量，因为变量太麻烦了。代码里，$a_1,b_1,c_1,d_1$ 存储最大/小值，$a_2,b_2,c_2,d_2$ 存储次大/小值，$a_4,b_4,c_4,d_4$ 存储每个最大/小值包含在哪一个矩形中（编号）。

这样的话，预处理 $O(n)$，枚举+计算 $O(n)$ ，总复杂度为 $O(n)$ ，$n \leq 132674$ （什么奇怪的数字），可以通过本题。

那么，这道题就算是做完啦~

## 代码

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
int a[6],b[6],c[6],d[6];
signed main()
{
	int n,e,f,g,h; scanf("%lld",&n);
	for(int i=1;i<=2;i++) a[i]=b[i]=-1e9-1,c[i]=d[i]=1e9+1; //记得赋初值！
	for(int i=1;i<=n;i++)
	{
		scanf("%lld%lld%lld%lld",&e,&f,&g,&h);
		if(e>=a[2])
			if(e>=a[1]) a[2]=a[1],a[1]=e,a[4]=i;
			else a[2]=e;
		if(f>=b[2])
			if(f>=b[1]) b[2]=b[1],b[1]=f,b[4]=i;
			else b[2]=f;
		if(g<=c[2])
			if(g<=c[1]) c[2]=c[1],c[1]=g,c[4]=i;
			else c[2]=g;
		if(h<=d[2])
			if(h<=d[1]) d[2]=d[1],d[1]=h,d[4]=i;
			else d[2]=h;
		//以上为预处理最大和次大值。
	}
	
	for(int i=1;i<=n;i++)
	{
		int A,B,C,D;
		A=(i==a[4])?a[2]:a[1]; //判断用最大还是次大；
		B=(i==b[4])?b[2]:b[1];
		C=(i==c[4])?c[2]:c[1];
		D=(i==d[4])?d[2]:d[1];
		if(C>=A && D>=B) //判断矩形是否存在
		{
			printf("%lld %lld",A,B);
			return 0;
		}
	}
	return 0;
}
```

$$\text{-------------- The End --------------}$$

$$\text{thx for reading}$$