思路：
------------
注意遮挡关系

前遮后 右遮左 上遮下

我们可以从后向前，从下向上，从左向右覆盖。

重点！！！
计算每一给块的左上角（待会说为什么）
规定左上角为#
------------
```cpp
#.+---+
./   /|
+---+ |
|   | +
|   |/.
+---+..
```
```cpp
样例图
0 	......+---+---+...+---+
1 	..+---+  /   /|../   /|
2 	./   /|-+---+ |.+---+ |
3 	+---+ |/   /| +-|   | +		//仔细观察
4 	|   | +---+ |/+---+ |/|		
5 	|   |/   /| +/   /|-+ |		//发现第i行，第j列，第k个的左上角（从后向前，从左向右，从下到上）
6 	+---+---+ |/+---+ |/| +		//上：13-6-(k-1)*4-(m-i-1)*2 
7 	|   |   | +-|   | + |/.		//左：j*4+(m-i-1)*2
8 	|   |   |/  |   |/| +..
9 	+---+---+---+---+ |/...
10	|   |   |   |   | +....
11	|   |   |   |   |/.....
12	+---+---+---+---+......
    
```
源代码如下：
------------
```cpp
#include <iostream>
using namespace std;
char a[7][8]={"..+---+",	//立体图
			  "./   /|",
			  "+---+ |",
			  "|   | +",
			  "|   |/.",
		      "+---+.."
			   };
int mapc[51][51];			//输入使用
char map[1001][1001];		//输出使用
void drew(int h,int w)	   //绘制立体图（h 上，w 左）
{
	int i,j;
	for(i=0;i<6;++i)
	{
		for(j=0;j<7;++j)
		{
			if(a[i][j]=='.')
				continue;
			else
				map[h+i][w+j]=a[i][j];
		}
	}
}
int main()
{
	int m,n,i,j,k;
	int maxh=0,maxw=0;
	cin>>m>>n;
	for(i=0;i<m;++i)
	{
		for(j=0;j<n;++j)
		{
			cin>>mapc[i][j];
			maxh=max(maxh,6+(mapc[i][j]-1)*3+(m-i-1)*2);	//至高点
			maxw=max(maxw,7+j*4+(m-i-1)*2);					//至宽点
		}
	}
	for(i=0;i<maxh;++i)		//初值
	{
		for(j=0;j<maxw;++j)
			map[i][j]='\0';
	}
	for(i=0;i<m;++i)		//绘制
	{
		for(j=0;j<n;++j)
		{
			for(k=1;k<=mapc[i][j];++k)
			{
				drew(maxh-6-(k-1)*3-(m-i-1)*2,j*4+(m-i-1)*2);	//计算
			}
		}
	}
	for(i=0;i<maxh;++i)		输出
	{
		for(j=0;j<maxw;++j)
		{
			if(map[i][j]==0)
				cout<<char(46);
			else
				cout<<char(map[i][j]);
		}
		cout<<endl;
	}
	return 0;
}

```
