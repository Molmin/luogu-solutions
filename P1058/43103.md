~~一道毒瘤题~~这道题我看到以后就立刻懵了，但仔细思考，把一个个小难题都慢慢攻克下来其实也没有什么，只是步骤多，但深度没有。

1. 这么多的符号，好烦啊！

	我们可以把单个的正方体先生成，接下来只是不断叠加。
    
1. 这些正方体会重叠啊（前后左右遮挡）！

	先把这个图案都赋为'.'，然后我们依照从上到下，从前往后，从右往左的顺序（其实就是因为他能看见上正右这三个面），如果仍然是'.'就把它变了。
    
1. 对于每个正方体怎么搞出他的位置啊！

	只要知道它的左下或左上（代码中是这样）的位置就可以了，然后只要把单个正方体的符号赋值就可以了。

1. 最后的输出好复杂啊！

	对于输出的行数和列数，列数很好求，即为m*4+n*2+1，而行数不一定，有可能前面的立方体层数很多，顶到天上去了，所以我们在print函数中某一坐标把'.'改为其它东西时，取这个点列的最大值。
    
    还有我们是把左下角的点设为(1,1)，而实际上它是(输出行的个数,1)，所以还要把整个图翻转。

1. 剩下的只有自己找规律了，还有不断地调试，从输出的图案中找到自己的错误，想得头昏脑涨时还要动动草稿纸。不过我还WA了一次，因为初始的图案没有完全赋为'.'，以后最好在时间复杂度允许的条件下还是要用memset()。

最后，因自己这次以较快的速度AC一道毒瘤模拟题，
预祝自己NOIP2018——RP++！！！
--------
```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
char bit[9][9]={
	"..+---+",
	"./   /|",
	"+---+ |",
	"|   | +",
	"|   |/.",
	"+---+..",
};
int r,c,n,m,a[62][62];
char p[512][512];
inline void print(int x,int y)//涂色
{
	for (int i=0; i<6; i++)
		for (int j=0; j<7; j++)
		{
			c=max(c,x-i);
			if (p[x-i][y+j]=='.') p[x-i][y+j]=bit[i][j];
		}
}
inline void solve(int y,int x)//枚举层数并得出该立方体的坐标
{
	for (int k=a[y][x]; k>=1; k--)
		print((n-y+1)*2+k*3+1,x*4-3+(n-y)*2);
}
int main()
{
	scanf("%d%d",&n,&m);
	for (int i=1; i<=n; i++)
		for (int j=1; j<=m; j++) scanf("%d",&a[i][j]);
	r=m*4+n*2+1;
	for (int i=1; i<=500; i++)//WA掉的地方
		for (int j=1; j<=r; j++) p[i][j]='.';
	for (int i=n; i>=1; i--)
		for (int j=m; j>=1; j--)
			solve(i,j);
	for (int i=c; i>=1; i--)
	{
		for (int j=1; j<=r; j++) putchar(p[i][j]);
		puts("");
	}
	return 0;
}
```