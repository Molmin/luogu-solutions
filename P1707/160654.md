首先感谢**叶璃caco3**dalao为我指出错误，让我终于A了这恶心了我一晚上的题

显然，这是个矩乘，需要我们推元矩阵，我们要维护的信息如下：

$a_{k+2},a_{k+1},b_{k+2},b_{k+1},c_{k+2},c_{k+1},k^{2},k,w^{k},$
$z^{k},$常数，没错，总共11个！

那接下来就让我们开始推吧（如果你不造啥是矩阵乘法请自觉问度娘）

把刚刚的11个信息塞到一个矩阵里，就有

| $a_{k+2}$ |$a_{k+1}$  |$b_{k+2}$  |$b_{k+1}$  |$c_{k+2}$  |$c_{k+1}$  |$k^{2}$  |$k$  |$w^{k}$  |$z^{k}$  |$1$  |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
根据题意，让以上矩阵放在乘号右边，左边是元矩阵，这可以得到以下矩阵

【$p,1,1,0,1,0,0,0,0,0,0$】

【$q,0,0,0,0,0,0,0,0,0,0$】

【$1,0,u,1,1,0,0,0,0,0,0$】

【$0,0,v,0,0,0,0,0,0,0,0$】

【$1,0,1,0,x,1,0,0,0,0,0$】

【$0,0,0,0,y,0,0,0,0,0,0$】

【$r,0,0,0,0,0,1,0,0,0,0$】

【$t,0,0,0,1,0,2,1,0,0,0$】

【$0,0,1,0,0,0,0,0,w,0,0$】

【$0,0,0,0,1,0,0,0,0,z,0$】

【$1,0,0,0,2,0,1,1,0,0,1$】

~~是不是非常恶心~~

那接下来就是正常的矩阵快速幂了。

## **注意以下几点：**

①我调了一晚上的原因，$k$变$k+1$的时候没有乘那个1（555555），包括

平方项也是，一定要注意是$k+1$以及$k^{2}+2*k+1$

②矩阵又结合性但不具有交换性，如果你的矩阵一直乘错，试试把两个矩阵

的顺序交换一下（~~说不定就A了~~）

③注意这玩意非常大，需要龟速乘，不然ULL也可以

当然初始矩阵就是{$3,1,3,1,3,1,1,1,w,z,1$}啦

最后我们的答案就是$f$矩阵的1,3,5,项啦，到了愉快的代码时间

## code
```cpp
#include<bits/stdc++.h>
#define R register

using namespace std;
typedef long long LL;
LL n, k;
int p, q, r, t;
int u, v, w;
int x, y, z;
struct JU {
	LL v[12][12];
}f, base;

inline LL sxsy(LL a, LL b) {//龟速乘
	LL res = 0;
	for(; b ;b >>= 1, a = (a << 1) % k)
		if(b & 1)
			res = (res + a) % k;
	return res;
}

JU operator * (JU a, JU b) {重载*号
	JU c;
	memset(c.v, 0, sizeof(c.v));
	for(R int i = 1;i <= 11;++ i) {
		for(R int j = 1;j <= 11;++ j) {
			for(R int l = 1;l <= 11;++ l) {
				c.v[i][j] = (c.v[i][j] + sxsy(a.v[i][l], b.v[l][j])) % k;
			}
		}
	}
	return c;
}

inline JU qxsy(JU a, LL b) {矩阵快速幂
	JU res;
	memset(res.v, 0, sizeof(res.v));
	for(R int i = 1;i <= 11;++ i) res.v[i][i] = 1;
	for(; b ;b >>= 1, a = a * a)
		if(b & 1)
			res = res * a;
	return res;
}

int main() {
	scanf("%lld%lld",&n, &k);
	scanf("%d%d%d%d",&p, &q, &r, &t);
	scanf("%d%d%d",&u, &v, &w);
	scanf("%d%d%d",&x, &y, &z);
	
	f.v[1][1] = f.v[1][3] = f.v[1][5] = 3初始矩阵;
	f.v[1][2] = f.v[1][4] = f.v[1][6] = 1;
	f.v[1][7] = f.v[1][8] = f.v[1][11] = 1;
	f.v[1][9] = w, f.v[1][10] = z;
	//最恶心的元矩阵
	base.v[1][1] = p, base.v[1][2] = 1, base.v[1][3] = 1;
	base.v[1][5] = 1, base.v[2][1] = q, base.v[3][1] = 1;
	base.v[3][3] = u, base.v[3][4] = 1, base.v[3][5] = 1;
	base.v[4][3] = v, base.v[5][1] = 1, base.v[5][3] = 1;
	base.v[5][5] = x, base.v[5][6] = 1, base.v[6][5] = y;
	base.v[7][1] = r, base.v[7][7] = 1, base.v[8][1] = t;
	base.v[8][5] = 1, base.v[8][7] = 2, base.v[8][8] = 1;
	base.v[9][3] = 1, base.v[9][9] = w, base.v[10][5] = 1;
	base.v[10][10] = z, base.v[11][1] = 1, base.v[11][5] = 2;
	base.v[11][7] = base.v[11][8] = base.v[11][11] = 1;
	
	f = f * qxsy(base, n - 2);
	printf("nodgd %lld\n",f.v[1][1]);
	printf("Ciocio %lld\n",f.v[1][3]);
	printf("Nicole %lld\n",f.v[1][5]);
	return 0;
}
```
完结撒花