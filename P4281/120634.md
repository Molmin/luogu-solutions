### Tarjan多好用啊，虽然我不知道为什么有的Tarjan会被卡掉

但是我交了一发就A了，$(O2$ $ $ $ $ $954ms)$

去掉 $O2$ 跑了$1.09s$，最慢的点$400$多$ms$

快读，$inline$，$register$ 都没加，难道你谷评测机变快了？

好了，我们回到正题

本人刷《算法进阶》碰到这题，下面内容或许会和书里的差不多

但是模版不是，因为比较容易~~觉悟~~，所以听同学讲几下就懂了，

自己打了个板子，常数好像比模版更优秀，因为我先预处理出欧拉序

所以我对于询问$LCA(x,y)$我可以直接判断哪个点的访问顺序在后面

### 前置芝士（不看请跳过）

首先来了解下**向上标记法**

我们要求 $x$，$y$ 的$LCA$

我们从$x$向上走到根节点，把沿途的点标一下

再从$y$向上走到根节点，碰到的第一个标记点就是$lca(x,y)$

这样一看就是暴力对吧

然后我们用并查集对这样的暴力优化

$Tarjan$是一种**离线**求$LCA$的算法，因为$Tarjan$ ~~only~~ 会**缩点**

我们按一种后序遍历的方式来记录点的顺序（其实是**欧拉序**啦）

然后把所有的询问读进来，再按照后序遍历的顺序枚举$n$个点

每个点扫一遍相关询问，$O($常数$)$出答案

至于怎么出，这里要用点数学小知识

我们先作规定，让后序遍历顺序后面的点去找与前面点的$LCA$

也就是说，访问到右孩子的时候去求与左孩子的$LCA$（这里指相对位置）

好的我们来画颗树

![](https://cdn.luogu.com.cn/upload/image_hosting/str3pb5x.png)

如果我们按照后序遍历的顺序敲代码，是不是红$-$绿$-$白的顺序啊

是不是对于绿的相关询问，另一个点在红里面啊（当然和自己重叠也行）

还记得我们规定了 "让后序遍历顺序后面的点去找与前面点的$LCA$"

你会发现，对于根的最左边的子树，和剩下的白绿点求$LCA$，$LCA$绝不在那个全 $red$ 的子树里

那么是不是剩下的点和那个子树求$LCA$都等价与那个子树最上面的红点求$LCA$啊

$why?$

要是有两个点的$LCA$在"全红树里"，那这两个点就一定是在红树里面，（但这棵树的询问已经处理完了，所以成立咯）

我们可以再跳一下，跳到红树的$fa$，即：绿白点和那颗红树求$LCA$等价于和红树最高点的父亲求$LCA$

那么**整颗红树都**可以**缩成一个点**，我们就用**并查集缩点**，所以说$Tarjan$ ~~only~~ 会缩点

再稍加思索就得到结论，扫完自己的所有孩子后，求自己与自己相关的点的$LCA$

再把自己的整颗树用并查集并到父亲

因为孩子并到了自己，所以不用扫自己的孩子一个一个并向父亲，并查集会解决路径压缩的

那怎么具体求$LCA?$ 发现绿点往上是一条链了吗，把白点和红点分成了两个集合

所有的红点都并到了绿点的父亲，所以$findfa$那个红点就是$LCA$（注意绿点往上是一条类似白色的链）

复杂度是$O($并查集$)$，代码很好打的，记住几个重点就行

1.~~后序遍历~~(欧拉序)

2.绿点到根，左孩子都是红的，红点和不红点的$LCA$ 等价 红点最高点的父亲与不红点的$LCA$

3.整颗子树包括自己求完了，把自己并到父亲，因为递归甩锅，所以整颗树会并上去

~~似乎到这里和 向上标记法 好像看不出来有什么关联了~~

### 搞定了求$LCA$就来看题吧

我们根据经验来想，**两个人汇合了，剩下那个就要自己跑过来**

然后设三个点$x$，$y$，$z$

则$x$到$y$最短总和在他们之间的路径上

则$x$到$z$最短总和在他们之间的路径上

则$y$到$z$最短总和在他们之间的路径上

三个路径交一点嘛！（~~真精彩~~）

至于为什么交一点，我们还是$x$，$y$，$z$三点，设$d(x,y)$为路径集合

把$x$看作树根

$d(y,x)=d(y,LCA(y,z))+d(LCA(y,z),x)$

$d(z,x)=d(z,LCA(y,z))+d(LCA(y,z),x)$

由两条式子得两条路径的交集为 $d(LCA(y,z),x)$

$LCA(y,z)$是$d(LCA(y,z),x)$中深度最大的点，

$LCA(y,z)$是$d(y,z)$中深度最小的点，

所以不看$LCA(y,z)$，$maxdep-d(LCA(y,z),x)<mindep-d(y,z)$

所以三条路径交一点

然后$x$，$y$，$z$到这点的距离和为$\dfrac{dis(x,y)+dis(x,z)+dis(y,z)}{2}$

用类似上面的方法即可证明（把$x$看作树根）

现在来证明到这点最短

我们知道，一但两个人汇合，那么剩下那个人就要自己过来，因为再改变汇合点，这两人就要一起走，就会浪费

还是$x$，$y$，$z$

**如果汇合点不在$d(x,y)$上，那么$x$，$y$就会一起走上一段路程**

**如果汇合点不在$d(x,z)$上，那么$x$，$z$就会一起走上一段路程**

**如果汇合点不在$d(y,z)$上，那么$y$，$z$就会一起走上一段路程**

**所以汇合点要在$d(x,y)$上，也要在$d(x,z)$上，也要在$d(y,z)$上**

这个汇合点是**唯一**的，就是三条路径交的那一点

我们用$Tarjan$求$LCA$从而得到点的距离（$dis(x,y)=dep[x]+dep[y]-2\times dep[LCA(x,y)]$）

三个点两两之间的距离和再除以$2$就是第二部分答案

$Then$我们来求这个交汇点

我直接告诉你答案是$LCA(x,y)$，$LCA(x,z)$，$LCA(y,z)$三个点中深度最大的点

~~完结撒花~~

### $why?$

首先解释下为什么是$LCA($某个点，某个点$)$

一句话解释，两个人汇合，剩下那个要自己过来，那么两个人的汇合点就是他们的$LCA$

我们又双叒叕设$x$，$y$，$z$

$x$和$y$有$LCA(x,y)$，$y$和$z$有$LCA(y,z)$

设$dep[LCA(x,y)]<dep[LCA(y,z)]$

那么$LCA(y,z)$是$LCA(x,y)$的某个孩子

如果选$LCA(x,y)$作为汇合点，那么$y$和$z$要先在$LCA(y,z)$汇合，再向上走

这显然违反了**汇合后不能再行进**的规定

所以深度大的$LCA$更优，我们就珂以愉快地敲代码了

### 下面代码和《算法进阶》里面的模版不同，慎抄

```cpp
#include<cstdio>
using namespace std;
int _;void swap(int &x,int &y){_=x;x=y;y=_;}
const int N=500005;
struct edge
{
	int x,y,next;
}a[N<<1],b[N*3];
int len=0,last[N];
int cnt=0,less[N],d[N],dep[N],ans[N],pos[N];
void ins(int x,int y){a[++len]=(edge){x,y,last[x]};last[x]=len;}
void ins2(int x,int y){b[++cnt]=(edge){x,y,less[x]};less[x]=cnt;}
void dfs(int x,int fa)
{
	for(int k=last[x];k;k=a[k].next)
	{
		int y=a[k].y;
		if(y!=fa)
		{
			dep[y]=dep[x]+1;
			dfs(y,x);
		}
	}
	d[x]=++cnt;//欧拉序(类似后序遍历) 
}
int ma[N];//变量名不够用了... 
int findfa(int x){return x==ma[x]?x:ma[x]=findfa(ma[x]);}
void dfs2(int x,int fa)
{
	for(int k=last[x];k;k=a[k].next)//先遍历孩子 
	{
		int y=a[k].y;
		if(y!=fa)dfs2(y,x);
	}
	for(int k=less[x];k;k=b[k].next)//扫描相关询问 
	{
		int y=b[k].y,ty=findfa(y),p=(k+2)/3;
		ans[p]+=dep[x]+dep[y]-dep[ty]*2;
		if(dep[pos[p]]<dep[ty])pos[p]=ty;
	}
	ma[x]=fa;
}
int main()
{
	int n,m;scanf("%d%d",&n,&m);
	for(int i=1,x,y;i<n;i++)
	{
		scanf("%d%d",&x,&y);
		ins(x,y);ins(y,x);
	}
	dep[1]=1;dfs(1,0);cnt=0;//求欧拉序 
	for(int i=1,x,y,z;i<=m;i++)
	{
		scanf("%d%d%d",&x,&y,&z);
		if(d[x]>d[y])swap(x,y);
		if(d[x]>d[z])swap(x,z);
		if(d[y]>d[z])swap(y,z);
		ins2(y,x);ins2(z,x);ins2(z,y);
	}
	for(int i=1;i<=n;i++)ma[i]=i;//并查集 
	dfs2(1,0);//solve
	for(int i=1;i<=m;i++)printf("%d %d\n",pos[i],ans[i]>>1);
	return 0;
}
```
下面来口胡一下为什么$Tarjan$会被卡

$Tarjan$的复杂度建立在并查集上

很多人认为并查集是$O(N)$的

其实并查集分很多种，比如$CSP-S(2019)$初赛那个并查集是$O(N^2)$的

那个并查集就没有加路径压缩

目前并查集有两个优化，一个就是**路径压缩**，另一个是**按秩合并**

一般我们是不用**按秩合并**的，只有做**可持久化并查集**那题才用到

为什么一般不用呢，因为我们认为**路径压缩**的优化已经足够

且**路径压缩**更易拓展，像$(USACO)$城市的地平线就可以用并查集做

我们可以用路径压缩的并查集加基数排序乱搞，那道题就$O(N)$了

当然，在数据随机的情况下，**路径压缩**并查集才能达到$O(N)$的复杂度

只加**路径压缩**优化的并查集可以卡到$O(NlogN)$，这也可能是$Tarjan$被卡的原因之一

再加上**按秩合并**，可以使并查集优化到最坏$O($反阿克曼函数$\times N)$，这点在一篇大佬的博客里有写

但是这样返回的父亲就不是原来那样了

我们在别的地方优化好了

《算法进阶》里的模版是一次递归，但是每次询问要拆成两次，因为你不知道欧拉序是怎样的

这题里套那啥板子会变成$6\times M$个询问，可能空间爆炸，带着TLE

所以我就先跑欧拉序咯，空间砍一半多好啊

~~话说一道$LCA$怎么就变成并查集了~~