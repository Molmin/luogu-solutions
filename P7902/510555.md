# 解析
很明显，我们可以运用到贪心思想，将偶数尽可能地挨在一起，而奇数尽可能地放远一点。比如 $n = 5$ 时，可以这样构造：
```
1 3 5 2 2 4 4 1 3 5
```
然后，题目已经说了：

$$1 \leq \frac{d}{2}$$

不等式两边 $\times 2$，便可以得到：

$$2 \leq d$$

即：

$$d \ge 2$$

而我们的构造方法就算在 $d = 1$ 时也合法，所以我们并不需要判断 $d$ 是否太小。

那么究竟在什么条件下，程序需要输出 $-1$ 呢？

我们再来看一下 $n = 5$ 的情况：
```
1 3 5 2 2 4 4 1 3 5
```
可以发现：$n = 5$ 时，两个相等奇数之间的距离为 $7$，任意两个相等奇数之间夹了 $4$ 个偶数，$2$ 个奇数（但是不包括这个奇数自己）。

而 $1,2,3,4,5$ 中，有 $2$ 个偶数，$3$ 个奇数，$2 \times 2 + 3$ 刚好等于 $7$！

同时，对于任意正整数 $n$，$1$ 到 $n$ 之间有 $\frac{n}{2} + n \mod 2$ 个奇数，所以，如果程序输出了 $-1$，那么一定要满足（公式中，$k = \frac{n}{2} + n \mod 2$）：

$$d \ge 2(n - k) + k$$

至于构造过程就看代码吧……

## AC code
```c++
#include<bits/stdc++.h>
using namespace std;
int n,d,i,a[2000005],k,l,s;
int main(){
	cin >> n >> d;
	k = n / 2 + n % 2;
	if(d >= 2 * (n - k) + k){
		cout<< -1 << endl;
		return 0;
	}
	for(i = 1; i <= k; i++){//前面 k 个数以及最后 k 个数为奇数。
		a[i] = a[(n - k) + n + i] = i * 2 - 1;
	}
	l = 2 * n - k + 1;
	s = 2;
	for(i = k + 1; i < l; i += 2){//剩下的数就是偶数
		a[i] = a[i + 1] = s;
		s += 2;
	}
	for(i = 1; i <= 2 * n; i++){
		cout<< a[i] << " " ;
	}
	cout<< endl;
	return 0;
}
```