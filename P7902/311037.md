## [题目传送门](https://www.luogu.com.cn/problem/P7902)
题目大意就是构造一个长为 $2n$ 且满足题目条件的一个序列，如果不能构造成，则输出 $-1$。

## 思路
这里讲一下最优解的做法。

偶数放里面，奇数放外面。

对于偶数，题目中给出对于数字 $i$，若 $i$ 为偶数，则数字 $i$ 两次出现位置之差不能超过 $d$。因为给出的 $d$ 的数据范围是 $d$ 最小等于 $2$，所以我们让两个相同的偶数靠在一起是最优的，并且不会影响奇数的最优解。

对于奇数，题目中给出对于数字 $i$，若 $i$ 为奇数，则数字 $i$ 两次出现位置之差必须超过 $d$。考虑是整体最优的方案，我们可以在偶数都在里面的前提下，让任意相同两个奇数的距离一样，这样的话，可以成为最优解。否则，就会出现某两个奇数距离近，某两个奇数距离远的情况，显然，距离近的那两个奇数的距离是小于这个定值的，故这种情况并不是最优解。

对于偶数，我们直接输出，对于奇数，我们判断这个定值与 $d$ 的大小关系，然后再输出。

举个例子：

- 对于长度为 $4$ 的排列，最优排列为：
	```cpp
	1 3 2 2 4 4 1 3
	```
- 对于长度为 $5$ 的排列，最优排列为：
	```cpp
	1 3 5 2 2 4 4 1 3 5
	```

知道了这些，代码也就应该可以写出来了。

## Code
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
int n,d;
int j,o;
int a[2000100],aa,b[2000100],bb;
void pre()
{
	for(int i=1;i<=n;i++)
		if(i%2==1)
			a[++aa]=i;
		else
			b[++bb]=i;
}
int main()
{
	scanf("%d%d",&n,&d);
	pre();
	//o表示1~n中偶数数量乘2,便于一起输出
	//j表示1~n中奇数数量,便于分两次输出 
	//o,j根据n的奇偶性变化 
	if(n%2==1){
		o=(n-1);
		j=(n-1)/2+1;
	}
	else{
		o=n;
		j=n/2;
	}
	//cout<<o<<' '<<j<<endl;
	if(j+o-1>=d){
		//偶数不管怎样都符合条件 
		//j+o即为这个定值,j+o-1>=d即j+o>=d+1,奇数符合条件 
		for(int i=1;i<=aa;i++)
			printf("%d ",a[i]);
		for(int i=1;i<=bb;i++)
			printf("%d %d ",b[i],b[i]);
		for(int i=1;i<=aa;i++)
			printf("%d ",a[i]);
		//输出 
	}
	else//不符合 
		cout<<-1;
	return 0;
	//完结撒花~~ 
}
```
### [AC记录](https://www.luogu.com.cn/record/60108496)