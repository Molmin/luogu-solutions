## 前言
这个题太高了！!1
## Part 1
考虑如果树是 $1\sim n$ 的链，$[l,r]$ 一定在一个连通块内，这就是一个区间数颜色问题，我们可以轻松解决。

考虑为什么可能有些点和 $x$ 不在一个连通块里，显然那是它和 $x$ 的路径上有 $<l$ 或者 $>r$ 的点。

换个更简洁的形式：我们要求的即所有和 $x$ 路径上点权 $l\leq\min,\max\leq r$ 的点的颜色数。

然后我们显然可以倍增往上跳跳到这个连通块最顶上的点，因为这样只需要统计子树的点即可。

然而子树的大小是 $O(n)$ 的啊……有没有什么能让树**均衡**一点的操作呢？
## Part 2
想到均衡，我啪的一下就贺了个点分树，很快啊！

* Conclusion：一个树上连通块中必然存在一个点，使得其余所有点都在它点分树上的子树中。

这个结论其实很好证明，因为如果所有点的 LCA 不在这个连通块里面，则两棵子树里的点是无法接上的。

于是我们还是可以暴力跳到这个连通块在点分树上最顶上的点（注意这里要跳完，反正深度是 $O(\log n)$ 的），统计子树的点即可。此时，虽然子树大小还是 $O(n)$ 的，但是我们可以对于每个点分别处理，子树大小就是均摊 $O(n\log n)$ 的。

对于每个询问我们要跳 $O(\log)$ 次，判定每个点可以使用树链剖分加 st 表，总复杂度为 $O(q\log^2 n)$。
## Another implementation
事实上暴力跳 $O(\log n)$ 次写起来很麻烦，因为你要多写一个树剖和 st 表。

我们可以考虑将询问挂在 $x$ 上，直接进行一次点分治，每次能取到的点打上标记，这部分的时间复杂度就是 $O(n\log n+q)$ 的。
## Part 3
于是问题变为了给 $N$ 个点，每个点有 $\min,\max$ 和颜色，有 $Q$ 个询问，每个询问叫你算出 $l\leq\min,\max\leq r$ 的点的颜色数。

于是套路扫描线扫 $\max$ 维护所有 $r\leq\max$ 的 $l$，对于每种颜色维护最小的 $l$ 即可，单次时间复杂度为 $(N+Q)\log N$。

由于 $\sum N\leq n\log n,\sum Q\leq q$，总复杂度为 $O(n\log^2n+q\log n)$。