## 题目描述

[题目传送门](https://www.luogu.com.cn/problem/P5311)

## 思路简述

在线是困难的，我们可以考虑离线，把每次询问放在给定的 $x$ 上。

求将树中编号在 $[l,r]$ 内的所有节点保留，$x$ 所在连通块中颜色种类数。

可以转化为路径上的点的编号必须在 $[l,r]$ 之间，$x$ 所能到达的所有点的颜色种数。

---

先想一个暴力：以每次询问给定的 $x$ 作为树根遍历全树，如果一个点到 $x$ 的路径满足条件，给答案贡献 $1$。

有一个简单的结论：如果对于询问给定的 $x$ 能在满足询问要求的情况下到达点 $y$，那么询问 $(l,r,x)$ 等价于 $(l,r,y)$。

---

于是我们可以想到点分治。

令 $R$ 表示当前点分治中心。

访问到一个点，如果 $R$ 到该点的路径满足询问的要求。

那么我们可以在这次答案统计中算出该个询问的答案，然后将这个询问 delete。

然后就可以把询问 $(l,r,x)\rightarrow (l,r,R)$。

然后就对于当前分治的整棵树的每个点，维护 $(min,max,color)$ 这个三元组。

$max$ 表示 $R$ 到该点的路径上编号的最大值。

$min$ 表示 $R$ 到该点的路径上编号的最小值。

$color$ 表示该点的颜色。

---

那么就变成这样的一个问题：

给定 $n$ 个集合。

有一些修改操作，在 $[min,max]$ 的集合中加入 $color$。

修改后有一些询问，求 $[l,r]$ 的所有集合的并集的大小。

联想到 [HH的项链](https://www.luogu.com.cn/problem/P1972)，发现不过是把加入颜色的操作从单点改成了区间。

套路地，我们可以将它按照右端点排序，这样就少了右端点的限制。

然后维护一下每个颜色的修改区间的左端点的最大值。

每次处理修改时单点修，处理询问时区间查询。使用树状数组维护即可。

## 丑陋の代码

代码比我清楚。
[click here](https://www.luogu.com.cn/paste/gj63d84u)
