首先分析一下，最多 $n-1$ 次可以将数组变成有序的（指定一个数，将比这个数小的数按降序依次放到左边，将比这个数大的数按升序依次放到右边）

那么，在什么情况下，不需要 $n-1$ 次调整呢？

如果在原数组中有一段本身就是一个一个递增的话，那么这几个数就不要做任何处理。比方说样例 2（$n=6$ ）的序列：

这时我们发现， $5,6$ 就是一个每次递增一个的子序列，而且这也是最长的一个子序列。那么，除去 $5,6$ 不动，其它的按照上面的方法进行排序，总共进行 4 次移动，就可以把原序列变得有序。

所以，我们就只需要求出原序列中最长的每次严格递增一个的子序列，用原序列长度 $n$ 减去最长子序列长度 $ans$ 即可。

那么，我们如何求出这个 $ans$ 呢？

我们定义一个数组 $k$，表示在原数组中每个数的出现位置。

还是用样例 2 的栗子： 3 2 5 1 4 6

3 的出现位置是 1，所以 $k[3]=1$ ；

4 的出现位置是 5，所以 $k[4]=5$；

以此类推。

可以得知，$k$ 数组的连续最长上升子序列长度就是 $ans$。

code：
```cpp
#include<iostream>
using namespace std;
int n,k,s=1,ans,p[200005];
int main(){
    cin>>n;
    for(int i=1;i<=n;i++){
        cin>>k;
        p[k]=i;
    }
    for(int i=1;i<n;i++){
	if(p[i+1]>p[i])s++;
    	    else{
	        ans=max(ans,s);
	        s=1;
	    }
    }
    ans=max(ans,s);
    cout<<n-ans;
    return 0;
}
```
看完之后，如果觉得有帮助，点个赞呗。

管理员大大求过qwq