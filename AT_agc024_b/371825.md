### 题目描述

给定一个 $1$ 到 $N$ 的排列，通过不断选择该序列中的元素，并将其放到序列的开头或末尾来对其进行排序

求最少需要几次这样的操作才能使得序列有序

其中 $1\le N\le 2\times 10^5$

注意这里 ⌈ 有序 ⌋ 指的是 $1,2,...,N$ 这样单调递增哈

----

### 解题思路

首先最为暴力的，我们会想到将每一个数分别放到两端之一，这样要 $n$ 次，虽然这样可能出现放了之后跟原来一样的愚蠢情况 qwq

我们可以发现，其实这么做一般而言有点多余

因为原来的序列可能存在不断 $+1$ 的子序列，对于这部分我们可以移动走插在其中的其它数，然后就不用对其中的数进行操作，这样无疑为我们省下了很多步骤

比如 $1,5,2,4,3$，我们分别将 $4,5$ 放到最后面即可

这样省下来的次数正好是这个不断 $+1$ 的子序列长度哦

事实上，我们只能让一个这种不断 $+1$ 的子序列保持不动，两个的话就不可能啦，因为其中的数肯定存在逆序，必须要移动！

那么我们自然选择贡献最好的也就是最长的这种不断 $+1$ 的子序列

那么最长不断 $+1$ 的子序列怎么求呢？注意到是 $1$ 到 $N$ 的一个 排列，我们可以考虑设 $f[x]$ 表示以数值 $x$ 结尾的最长不断 $+1$ 的子序列长度最大值，如果在之前出现过 $x-1$，显然 $f[x]=f[x-1]$，否则 $f[x]=1$

具体实现的时候我们可以初始化 $f[k]=0$ 然后直接递推，结果是一样的

复杂度那当然是 $O(N)$ 啦

----

### 代码实现

代码超级短哦

```cpp
#include<bits/stdc++.h>
#define MN 201000

using namespace std;

int n, a[MN];
int f[MN], qwq;

int main() {
	scanf("%d", &n);
	for(int i=1; i<=n; ++i) {
		scanf("%d", a+i);
		f[a[i]]=f[a[i]-1]+1;
		qwq=max(f[a[i]],qwq);
	}
	printf("%d\n", n-qwq);
	return 0;
}
```
