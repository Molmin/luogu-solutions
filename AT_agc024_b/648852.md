## 用线性复杂度切掉这道题。

## 题意
有一个 $\text{1}$ 到 $n$ 的排列，每次操作从排列中任选一个数放在排列的最前或最后，求使排列有序的最少操作次数。

## 分析
首先，长度为  $ n $  的数列一定能够在至多  $ n $ 次操作内排好序。

并不严谨的证明：先在下标 $\text{1}$ 到 $n$ 中找出最大的数提到前面，接着在 $\text{2}$  到  $n$ 中找到最大的数提到前面，以此类推，一定能够在  $ n $ 次内完成排序。并且，如果想要一直移动到队尾，那么只需找最小的数即可。

那么怎么找到最小步数呢？

注意到数列是一个  $\text{1}$  到   $n$  的排列。假设在数组中可以找到一个连续递增的子序列（下标不一定连续），那么将其他数分成三类：

$\text{1：}$ 比这个连续的子序列中最小的数小。

$\text{2：}$ 在这个连续的子序列中。

$\text{3：}$ 比这个连续的子序列中最大的数大。

我们只需要保证 $\text{2}$ 不变，把所有的 $\text{1}$ 用上述证明的方法往前面提，把所有的 $\text{3}$ 用同样的方法往后面提，用 $\text{1}$ 和 $\text{3}$ 数个数总和的次数就可以使原序列有序。

于是原问题转化为求最长连续递增的子序列。设 $f[x]$ 为以数值 $x$ 所在下标结尾的连续递增子序列的长度，我们只需要在读入数列时，判断比当前读入的数小 $\text{1}$ 的数是否出现过，若出现过则 $f[x]=f[x-1]+1$，没有出现过则赋为  $\text{1} $。

时间复杂度 $O(n)$。

## $ \text{Code}$
```
#include<bits/stdc++.h>

#define youhua ios::sync_with_stdio(0);cin.tie(0), cout.tie(0);

using namespace std;

const int maxn=2e5+5;
int f[maxn];
int n, ans = 0;

int main()
{
	youhua//输入输出优化
	
	cin >> n;
	for(int i = 1;i <= n;i ++) {
		int x;
		cin >> x;
		f[x] = f[x - 1] + 1;
		ans = max(ans, f[x]);
	}
	cout << n - ans; 
	return 0;
}
```