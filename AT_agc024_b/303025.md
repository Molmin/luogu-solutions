### AT3959 [AGC024B] Backfront题解
Pascal题解来一发！！！


------------
#### 解题思路

观察此题，注意到 $n<=2 \times 10^5$，也就是 $200000$,考虑 $O(n)$。

通过证明~~瞎搞~~可得，此数列最多只需 $n$ 次操作。

具体操作：将 $n$~$1$ 各个数分别放到最前，便可得到。

略加思索，不难发现只要从序列中任选一数 $x$ 作为基准，将比他小的数按 $x-1$ 到 $1$ 的顺序放到 $x$ 前面，将比他大的数按 $x+1$ 到 $n$ 的顺序放到 $x$ 后面，这样一来 $x$ 便无需移动，整个序列只需 $n$-$1$ 次移动。

既能使一个数不动，那也能使一个序列不动。哪些序列可以像一个数一样可以不动呢？我们来举一个例子。

 样例#1
```
4
1
3
2
4
```
此样例我们来试一下。

第0次```1324```

第1次```2134```

第2次```1234```

这种方法用了2次将序列排好了，分别把 $2$、$1$ 按顺序放到队首。

这里 $3$、$4$ 都没有动啊！！！

我们再自己试一下，可以得出一个结论：

 当一段数字为单调的，且这段数字的位置也是按数字单调顺序（上升或下降）时，这一坨数字便可以抱团组在一起，不需要移动。

现在，我们只要用 $O(n)$ 循环跑一遍，读入数字，用桶记录下标，再跑一遍循环，找到可以抱团的最长序列，记录长度，最后输出 $n$ 减去长度就可以了。

本人蒟蒻，如果有没讲明白的，请多画图，多模拟。再不理解……参考我的程序！

#### AC code
```pascal
uses math;//使用max函数，需要用到的库。
var
n,i,x,t,ans:longint;
a:array[0..200005]of longint;//定义部分，由于输入序列为1~n的序列，所以下标只要根据n就好了。
 begin
  readln(n);
  for i:=1 to n do
   begin
    readln(x);//原数字不需要保存，用x代替。
    a[x]:=i;
   end;
  t:=1;ans:=1;//注意！！！这里要赋初值，这个数列个数至少为一。
  for i:=2 to n do
   if a[i]>a[i-1]then
    begin
     t:=t+1;
     ans:=max(ans,t);
    end//找我们想要的最长序列序列。
   else t:=1;
  write(n-ans);//输出即可！！！
 end.
```
