# CF1422E Minlexes 解题报告

## 题目大意

给定一条由小写字母组成的字符串 $s$，对于 $s$ 的每一个后缀（包括 $s$），删除若干组相邻的相同字母，使得最后把剩余部分拼接在起来的字典序最小，输出字符串长度和结果串，若结果串长度大于 $10$，依次输出输出前五个字符，省略号，以及最后两个字符。

## 解法分析

令 $n=|s|$。

首先：$1 \le n \le 10^5$。如果不是什么奇怪的东西，那么正解复杂度应该是 $O(n)$ 或 $O(n \log n)$ 了。带 $\log$ 估计很难，$O(n)$ 的话基本就是 $dp$ 了。

我们将原串中连续相同字母分成几个块，方便接下来的理解。举个例子，可以将字符串 `aabcdddeea` 分为 `aa`,`b`,`c`,`ddd`,`ee`,`a` 六个块。

由于 $O(n)$ 和 $O(n^2)$ 大致思路一样，所以先考虑 $O(n^2)$ 的做法：

令 $dp_i$ 为长度为后缀 $[i,n]$ 的结果串（注意，$dp$ 是 string 类型！），设 $i$ 在所处块中从后往前数是第 $k$ 个，由于从 $s_{i+k}$ 是另一个块的开始位置，所以答案肯定为 $[i,i+k-1]$ 的某个子序列与 $dp_{i+k}$ 相连，而 $[i,j+k-1]$ 中全是一样的字母，所以子序列之间的区别只有长度。那么选哪个子序列呢？我们发现 $k$ 的奇偶性在这里也很关键，所以对 $k$ 的奇偶性分类讨论。

若 $k$ 为奇数：此时子序列合法长度的集合为 $\{1,3,\cdots,k-1\}$，我们发现这不就是把 $dp_{i+1}$ 接上了 $S_i$ 嘛！所以 $dp_i$ 等于 $S_i+dp_{i+1}$（同 string 类型加法）。

若 $k$ 为偶数：此时子序列合法长度的集合为 $\{0,2,\cdots,k\}$，同样可以看作是把 $dp_{i+1}$ 接上了 $S_i$。**但是**，这还多了个 $0$，难不成子序列长度可以为 $-1$ 吗？所以 $dp_i$ 应该等于 $S_i+\min(dp_{i+1},dp_{i+k})$（同 string 类型 $\min$ 函数）。

至此，$O(n^2)$ 的解法就结束了，然而我们发现这个做法却并不能优化。

但是出题人他帮我们优化了啊！当字符串长度大于 $10$ 的时候我们只需输出前五个字符与后两个字符，所以我们的 $dp$ 只表示结果串的前 $10$ 个字符不就行了吗！此时时间复杂度为 $O(10 \times n)$。

你可能会有困惑，都给人家省略了，还怎么比较字符串大小啊？

一点儿都不用怕，只需要~~四种分类讨乱~~正常判断 $dp_{i+1}$ 与 $dp_{i+k}$ 就行啦，相信你在纸上推一推就能顿悟了！

当然了，输出的时候还要输出最后结果串长度与最后两个字符，额外开数组在转移时顺便记录就行啦，合理运用 STL 会让代码更好写哦。

## 参考代码
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 100010;
int n, k, sz[N];
string s, dp1[N], dp2[N];
char p[N];
int main(){
	cin >> s, n = s.size();
	s = ' ' + s;
	//初值 
	dp1[n + 1] = dp2[n + 1] = "";
	dp1[n] = s[n], dp2[n] = "";
	sz[n] = k = 1;
	//dp
	for (int i = n - 1; i >= 1; i--){
		if (sz[i + 1] < 10)
			dp1[i] = s[i] + dp1[i + 1];
		else if (sz[i + 1] == 10){
			dp1[i] = s[i] + dp1[i + 1].substr(0, 9);
			dp2[i] = dp1[i + 1].substr(8, 2);
		}
		else{
			dp1[i] = s[i] + dp1[i + 1].substr(0, 9);
			dp2[i] = dp2[i + 1];
		}
		sz[i] = sz[i + 1] + 1;
		if (s[i] == s[i + 1]){
			k++;
			if (k % 2 == 0 && dp1[i + k] < dp1[i])
				sz[i] = sz[i + k], dp1[i] = dp1[i + k], dp2[i] = dp2[i + k];
		}
		else
			k = 1;
	}
	//答案 
	for (int i = 1; i <= n; i++){
		cout << sz[i] << ' ';
		if (sz[i] <= 10)
			cout << dp1[i] << endl;
		else
			cout << dp1[i].substr(0, 5) << "..." << dp2[i] << endl; 
	}
	return 0;
}
```