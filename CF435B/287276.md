### 首先看看题目吧:

一个 $n$ 位的数字，每次可以交换相邻的两位，但只能交换 $k$ 次（不一定要用完），求可以得到的最大的数。

***

非常的明显，这是一道贪心，肯定是把较大的数提到前面啊。

比如说样例 1：`1990 1`，因为 $1<9$，所以把 $1$ 和 $9$ 调换，得 $9190$。

我们就可以得出：每次判断相邻的两位，如果后者大于前者就交换，但事实真的如此吗？我们再看看一个数据：`451462 5`

如果我们按上面的方法，则：

1. $4<5$，交换，得 $541462$；
2. $1<4$，交换，得 $544162$；
3. $1<6$，交换，得 $544612$；
4. $4<6$，交换，得 $546412$；
5. $4<6$，交换，得 $564412$。

但这个答案是错的，正解:

1. 交换 $4$ 和 $6$，得 $451642$；
2. 交换 $1$ 和 $6$，得 $456142$；
3. 交换 $5$ 和 $6$，得 $465142$；
4. 交换 $4$ 和 $6$，得 $645142$；
5. 交换 $4$ 和 $5$，得 $654142$。

我们可以发现正解中先把 $6$ 提前到最高位，然后把 $5$ 提前到次高位，那如果 $k$ 更大呢？是不是把 $4$ 提前呢？

***

所以，我们又可以得出一个方法：将最高为替换成尽量大的数。照这种方法，我们来看看样例 3：`1034 2`

因为最大数是 $4$ ，但只能交换 $2$ 次，发现次大的 $3$ 正好交换 $2$ 次，于是把 $3$ 提前，得 $3104$，也就是答案。

***

所以，这种方法是正确的，那接下来就是代码实现了。

```cpp
#include<bits/stdc++.h>
using namespace std;

int k,n,a[25];

int f(int x,int xx)                    //寻找可以替换到当前位的最大数
{
	int maxn=x-1;
	if(xx==0)
		return 0;
	for(int i=x;i<=n;i++)
		if(xx>a[i])
			if(a[maxn]<a[i])
				maxn=i;
	if(maxn-x+1>k)
		return f(x,a[maxn]);
	else
		return maxn;
}

int main()
{
	string nn;
	int x;
	cin>>nn>>k;                     //字符串处理更方便(自认为)
	n=nn.length();
	for(int i=1;i<=n;i++)           //转成数组(也可以用字符串直接做)
		a[i]=(int)nn[i-1]-48;
	for(int i=1;i<n;i++)
	{
		if(k==0)
			break;          //如果次数用完了就可以跳出循环
		x=0;
		x=f(i+1,10);
		k=k-(x-i);
		if(x!=0)                //如果找到这个数的话就提前
		{
			a[22]=a[x];
			for(int j=x;j>i;j--)
				a[j]=a[j-1];
			a[i]=a[22];
		}
	}
	for(int i=1;i<=n;i++)           //输出
		cout<<a[i];
	return 0;
}
```
