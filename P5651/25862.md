[博客内食用更佳](https://www.luogu.org/blog/xzlhxc/p5651-report)/
[题目链接](https://www.luogu.org/problem/P5651?contestId=23456)    
**前置芝士：LCA，并查集**   
**觉得题解有问题或者看不懂的请私信笔者！**

------------
这场，咕咕月赛真的是信心赛啊，部分分给得特别良心，然而还是掩盖不了我菜的事实。

------------

## ①题意
给你一个带权无向图，边权非负，每个环的所有边权值异或的结果为0，定义经过一条路径的费用为路径上所有的边权异或后的值，有$q$个询问，询问$x ---> y$的最小费用。$ ( 0 < n,q \leq 10^5;0 < m \leq 2*n )$   

~~没有负权边？最短路？dijkstra，上！~~   
可以发现，本题中的路径没有最有子结构，由于异或的性质，2个很大的数$xor$后有可能会变小，所以$x --->y$最短路径上的子路径不一定是最短路径。不能用$dijkstra$。    

## ②解法    
- 40$pts$    

由于本题部分分给得很足，暴力就能拿40$pts$，所以果断先打个暴力。   
怎么暴力？dfs！   
```cpp
void dfs(int x,int len)
{
	if(x==goal)//到达目标点，更新结果
	{
		ans=min(ans,len);
		return;
	}
	for(int i=hd[x];i;i=nx[i])//邻接表存图
	 if(!vis[to[i]])//求简单路径，所以一个点最多走一次
	 {
		vis[to[i]]=true;
		dfs(to[i],len^val[i]);
	 	vis[to[i]]=false;//回溯
	 }
	return;
}
```
- 60$pts$   

由于有20分的数据是一棵树，所以2个点的路径就唯一了，码个倍增LCA求出2个点的路径费用就可以了。   

设```w[x][i]```为$x$到它的$2^i$辈祖先的路径费用，异或满足结合律，在求```f[x][i]```，即$x$的第$2^i$辈祖先的时候可以顺便求出来。   

下面是在dfs中求解$f,w$的核心代码：
```cpp
for(int i=1;i<=lo[dep[x]];i++)
 w[x][i]=w[x][i-1]^w[f[x][i-1]][i-1],f[x][i]=f[f[x][i-1]][i-1];
```
求完后，在求2个点的$LCA$的时候顺便累计答案就可以了
```cpp
inline int lca(int x,int y)
{
	int ans=0;
	if(dep[x]<dep[y])swap(x,y);
	while(dep[x]!=dep[y])
	 ans^=w[x][lo[dep[x]-dep[y]]],x=f[x][lo[dep[x]-dep[y]]];//1
	if(x==y)return ans;//2
	for(int i=lo[dep[x]];i>=0;i--)
	 if(f[x][i]!=f[y][i])
	  ans^=w[x][i]^w[y][i],x=f[x][i],y=f[y][i];//3
	ans^=w[x][0]^w[y][0];//4
	return ans;
}
```
码风清奇，各位重点看看有注释的那几行，就是答案的求解方式。剩下的代码，就都是模板了……    

- 80$pts$ 我不会。（逃   

- 100$pts$   

对于每一个环，如果一条路径没有经过这个环上的边，那么删去环上某条边对环没有影响；如果经过环上的某一条边，由于题意，**它不可能经过这一整个环**，所以这条路径在环上至少有2种走法。   

又因为每个环边权异或和为0，所以将这个环的所有边任意分成2个集合，这**2个集合的内部的边的异或和相等**，这意味着只走环上的边，不论怎么走，环上的任意2点的路径**费用**不变。（仔细思考一下呗）    

所以，当一条路径经过一个环，无论在这个环上怎么走，费用不变。所以我们可以删掉环上任意一条边。**让图变成一颗树！**

然后，就套用60$pts$做法的$LCA$就能过了。     

**读入边的时候用个并查集判断2个点是否联通，如果非联通就把这条边加入，否则不加入。**

## ③AC！
题目评价：这个部分分还能起到引发思路的作用，很不错。   
喜欢就点个赞呗$Orz$