一句话题意：在$S$中找到一个既是前缀，又是后缀，并且还出现过至少$3$次的子串。

提到`前缀`、`后缀`这样敏感的词语，我们一定会想到那个$Z$算法，这个算法可以在线性的时间（均摊的）内递推出$z$数组，即每个位置开始的最长的与某个前缀相同的子串的长度。~~（很绕对吧？我也这么觉得……）~~

看个例子：

$S$="abaab"

显然，$z_0$就是这个串本身的长度，我们便不做讨论。$z_1$是$0$，因为$S[1]$是'b'，而$S$没有以$b$开头的前缀；$z_2$是$1$，因为$S[2]==S[0]$但是，$S[3]\ne S[1]$所以长度为$1$；$z_3$是$2$，因为$S[3]==S[0],S[4]==S[1]$，所以长度为$2$；显然，$z_4$就是$0$了。

那么我们先看代码（注释在代码里有）：

```
#include<bits/stdc++.h>
#define F(i,l,r) for(register int i=l;i<=r;i++)
#define ll long long
#define mem(a,b) memset(a,b,sizeof(a))
#define p_b push_back
#define m_p make_pair
#define il inline
using namespace std;
const int N=1e6+5;
int z[N],n;
char s1[N];
il void get_z(char *s1){//获得串s1的z数组
	int L=0,R=0;//这个L，R最后是用来看当前开始的最大匹配长度的
	F(i,1,n-1) {
		if(i>R) {//如果i>R，那么说明这个区间的信息一点点都没有被刚刚的递推所更新到，那么怎么办呢？只能一个一个区匹配咯。
			L=i,R=i;
			while(R<n&&s1[R-L]==s1[R]) R++;//这里的一个一个匹配看上去最劣的复杂度是O(n)的，那么整个算法不就是O(n^2)了么？
            //但是你想，我们这里的递推是因为当前的点i是没有被之前的递推所覆盖到的，也就是说我们不知道这里到底是个什么情况。但是当我们此处递推了很多，那后面（看后面else的第一个if）是不是不用递推，直接O(1)获得答案了？
			z[i]=--R-L+1;//最后的R多加了一个，手动模拟就想清楚了
		}
		else {
			int k=i-L;//那么此处就是Z算法的精华了，它利用了L，R单调不减的特性求出了i这个位置一定是在哪里被求过z了的
			if(z[k]<R-i+1) z[i]=z[k];//如果i这个位置的z全部都被求过了，那么直接更新（应该是z[k]+i-1<R，这样应该更好理解）
			else {//不然就说明我们只有一部分被更新了，那么把剩下的烂摊子继续一个个匹配完即珂
				L=i;
				while(R<n&&s1[R-L]==s1[R]) R++;
				z[i]=--R-L+1;
			}
		}
	}
}
int maxn=-10,pos;//maxn是本题的另一个核心
//maxn是来看当前最大的z[i]的，如果说我们已经找到了一个后缀前缀，并且在i前面的最大的z[i]是要比n-i长的，说明在中间至少也出现了一个相同的子串（举个栗子就能懂啦！）
int main() {
	scanf("%s",s1);
	n=strlen(s1);
	get_z(s1);
	F(i,1,n-1) {
		if(z[i]+i==n&&maxn>=n-i) {//显然,z[i]+i==n就说明了这个串既是前缀又是后缀，因为i+与从i开始与总串的前缀匹配长度的最大值一旦等于了n，那么说明这个串从i开始一直接到了最后。
			pos=i;//如果符合条件就记录一下合法的位置
            //此处没有判断最大长度是因为我枚举的循环就已经保证了长度是由大向小递减的了
			break;//break;
		}
		maxn=max(maxn,z[i]);//寻找最大的z[i]
	}
	if(!pos) puts("Just a legend");//没有就输出这个
	else F(i,0,n-pos-1) printf("%c",s1[i]);//有就输出呗
	return 0;
}
```