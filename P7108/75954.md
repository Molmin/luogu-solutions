大数学题……


### 本题解中ksm指“快速幂”（

```
int ksm(int x, int mi)
{
	int ret = 1;
	while(mi)
	{
		if(mi & 1) ret = ret * x % mo;
		x = x * x % mo;
		mi >>= 1;
	}
	return ret;
}
```

## h==0

显然只要把第一层所有都剪掉就好

```
if(h == 0) printf("%lld\n", a % mo);
```
## a==b

第h+1层多余的砍掉即可，总数$a^{h+1}$

```
else if(a == b)
{
	printf("%lld\n", ksm(a, h + 1));
}
```

## a==1

这是从链->b叉树的过程

考虑按顺序给每一层都加上没加上的边

（画图好难QAQ

拿字符画吧（

```
O          O         
|         /|\
O        O O O
|  +2   /  |  \    +6
O  ->  O   O   O   ->   
|               \
.              ...
.
.
```
```
      O 
     /|\
   /  |  \    +1 
  O   O   O   ->
 /|\ /|\ /|\
 OOO OOO OOO
 |
 .
 .
 .
```

```
      O 
     /|\
   /  |  \
  O   O   O 
 /|\ /|\ /|\
 OOO OOO OOO
```
共：9次

~~猜测：$ans=b^h$，好耶~~


推一波柿子：

第一层补齐了b-1个分支

第二层补齐了b*b-1个分支

...

以此类推，第N层补齐了$b^{N-1}(b-1)$个分支

所以总补齐数量=$\sum_{i=1}^{N} b^i(b-1)$

再加上最后的砍去多余的1，总数为

$$\sum_{i=0}^{N} b^i(b-1) + 1$$
$$=(b-1+b^2-b+b^3-b^2+...+b^n-b^{n-1})+1$$
$$=b^n-1+1$$
$$=b^n$$

代码：

```
else if(a == 1)
{
	printf("%lld\n", ksm(b, h));
}
```
## b==1

这回是a叉树到链

同样考虑每一层把没用的删掉

因为只保留一个节点所以每层删除的均为（a-1）条

~~不想画图了QAQ~~

```
      O 
     /|\
   /  |  \   +2
  O   O   O  ->
 /|\ /|\ /|\
 OOO OOO OOO
 .......
 
 
     O
     |   +2
     O   ->
   / | \ 
  O  O  O
 /|\/|\/|\
 ...

O
|
O   +3
|   ->
O
/|\
.
.
.

O
|
O
|
O
```

总数：7

对于每一层都删除了a-1个多余的枝条，剩下的第h+1层剪掉了所有枝条，共a个

所以答案是$(a-1)\times h+a$

(这里程序里写的是$(a-1)\times (h+1) + 1$,本质相同)

```
else if(b == 1)
{
	printf("%lld\n", (a - 1) * (h + 1) % mo + 1);
}
```

## 无特殊限制

~~BOSS来了（~~

根据前面的启发，我们可以知道a,b的大小关系是对答案有很大影响的，所以进行分类讨论：

### $a<b$

还是考虑接好每一层再减去多余部分：

~~图真的画不下去了QAQ~~

**以下较为抽象**

```
     O
    / \    +1
   O   O   ->
  /\   /\
  O O  O O
 /\ /\ /\ /\
  .........
      O
    / | \    +3*1
   O  O  O   --->
  /\  /\  /\
 O O O O  O O  注意：这里在最下层标*的地方拿了一支来填空
 /\/\/\/\/\/ *
 
 .......
 
         O
    /    |    \    +14 
   O     O     O   -->
  /|\   /|\   /|\
 O O O O O O O O O 同样的，这里拿了标*的3支来填空
 /\/\/\/\/\/\**/\*
 .........
 
 
      O 
     /|\
   /  |  \  
  O   O   O
 /|\ /|\ /|\
 OOO OOO OOO
```
继续推柿子：

对于第1层，我们补了b-a个分支；

对于第2层，我们在此基础上补了b*(b-a)个分支

...

对于第N层，我们补了$b^{n-1}\times (b-a)$个分支

为了方便，设我们共补齐了$T$支

### 重点：

**我们最后去掉了一堆东西**

这堆东西就是我们最后一层多余的枝杈

而这堆多余的枝杈个数=原枝杈个数-向上补齐时用到的枝杈个数

$$del=a\times b^h - T$$

而

$$ans=del+add$$
$$=T+a\times b^h-T$$
$$=a\times b^h$$

~~妙啊~~

代码：

```
if(a < b)
{
	printf("%lld\n", a * ksm(b, h) % mo);
}
```

### $a>b$

```
      O 
     /|\      +1
   /  |  \    ->
  O   O   O
 /|\ /|\ /|\
 OOO OOO OOO
 ......
 
    O 
    /\
   /  \   +2
  O    O  ->
 /|\  /|\
 OOO  OOO
/|\/|\/|\....

      O
     /  \
    O    O   +12
   /\    /\  -->
  O O   O  O
 /|\/|\/|\/|\
........
 
      O
     /  \
    O    O 
   /\    /\ 
  O O   O  O
```
继续推柿子

和b=1时类似，考虑推广：

第一层删除了(a-b)个

第二层删除了b*(a-b)个

...

第N层删除了$b^{N-1}*(a-b)$个

最下面删除了$b^{h}*a$个

所以有：

$$ans=\sum_{i=0}^{h-1}(b^i\times (a-b)) + b^h\times a$$

$$=(a-b)\times \sum_{i=0}^{h-1}b^i + b^h\times a$$

然后发现$h<=10^9$，恐怕会T飞

发现中间那个玩意是等比数列的和，套一下公式得：

$$ans=(a-b)\times \frac{b^{h}-1}{b-1}+ b^h\times a$$

其中分数部分求一下逆元，拿费马小定理就可以了

代码：

```
else if(a > b)
{
	int ans = (ksm(b, h) - 1 + mo) % mo * ksm(b - 1, mo - 2) % mo * (a - b) % mo;
	ans = (ans + ksm(b, h) * a) % mo;
	printf("%lld\n", ans);
}
```

### a==b
这个之前讨论过了（

完结撒花~芜湖~

完整代码就不贴了/fad

~~（看在画了那么多图的份上留个赞再走吧QAQ~~