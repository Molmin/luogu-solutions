### 前置芝士：快速幂，逆元，等比数列求和

题意：一棵无穷高的满 $a$ 叉树，可以给一个节点换父亲（接木），也可以给弄死某一个节点的某一个儿子，及这个儿子的所有后代（移花），以上两种都算一次操作，问至少几次能把这棵树变成高度恰好为 $h$ （根节点高度为 $0$）的满 $b$ 叉树。

大致思路即分以下两种情况讨论：

一、 $a \ge b$

显然此时只需“移花”，我们先取 $a=3,b=2,h=2$ 的情况如下图（有些丑 ~~，但还能看~~）：

![](https://cdn.luogu.com.cn/upload/image_hosting/ilyt1fs4.png)

然后进行删边（一条用红色圈圈出的边表示一次删除的所有点的最近公共祖先与其父亲的连边）：

![](https://cdn.luogu.com.cn/upload/image_hosting/mxyfuadm.png)

考虑第 $x$ 层与第 $x+1$ 层之间所删的边，发现是 $(a-b)b^x$，第 $h$ 层以下显然需进行 $ab^h$ 次操作。

得到操作次数总和为：

$$[(a-b)b^0+(a-b)b^1+ \cdots +(a-b)b^{h-1}]+ab^h$$

$$=(a-b)(b^0+b^1+ \cdots +b^{h-1})+ab^h$$

$$=\frac{(a-b)(b^h-1)}{b-1}+ab^h$$

快速幂 $+$ 逆元即可算出

二、$a < b$

给图：



此时既需“接木”也需“移花”，其实就是除第 $h$ 层外每一层另接上 $a-b$ 个儿子，第 $h$ 层节点的所有儿子砍掉，为了使操作数最少，我们可以把砍掉的儿子接在所需的地方，合并成“接木”，又因为要砍掉的儿子有无穷多，所以只用 $ab^h$ 次操作（即第 $h$ 层的所有有儿子的节点数量）。

--------------------------

核心代码：
```
inline ll ny(ll x){//逆元
    return qpow(x,mod-2);
}
inline ll db(ll x,ll y){//等比数列求和，即求x^0+x^1+⋯+x^y
	if(x==1)return y+1;//特判
	return (x*(qpow(x,y)-1)%mod*ny(x-1)%mod+1)%mod;
}

if(a>b)out((a*qpow(b,h)%mod+db(b,h-1)*(a-b)%mod)%mod);
else out(a*qpow(b,h)%mod);
```

再加上某一些 $h==0$、$a==1$、$a==b$ 之类的特判即可通过。

看到了就给一个赞吧qwq