[传送门](https://www.luogu.com.cn/problem/P9304)         
大家的做法好像都比我简洁啊。         
我们容易想出一个贪心做法：先走点多的路径，走到最后用特殊连接，其他都正常走。          
那么，我们只需要先用一遍 dfs 求出每条路径上的点数并找出所有叶子结点，然后再加入优先队列，一个一个计算答案即可。            
这里解释下为什么找叶子结点：每条路径上的点数很明显就是深度，而叶子结点在路径最后，是这条路径上深度最大的一个点，也就是这条路径上的点数。          
优先队列需要记录一个值：$dep$，即深度。    
我们设 $ans$ 是全局的答案，即单点上答案为 $ans$ 加额外的长度。        
我们还需设 $sum$ 为已经走过的深度总和。      
我们按深度从大到小排序，遍历优先队列，并设 $i$ 为本次的个数，如果 $dep+sum>i$，那么我们没到终点，如果可以用特殊连接就使用，即答案为 $ans+(i-sum)$，否则答案为 $ans+(i-sum)\times2$。        
如果 $dep+sum=i$，即正好走完，我们需要更新全局答案。如果可以用特殊连接，新的 $ans$ 就要加上 $dep$，否则要加上 $2\times dep$。我们还需更新 $sum$，需加上 $dep$。这里明显这一轮的答案就是这次的全局答案，即 $ans$。          
如果 $dep+sum<i$，更新 $ans$，方法同 $dep+sum=i$ 的方法，$sum$ 也用一样的方法更新，但是这里的 $i$ 不能更新。           
这里明显地，我们每次遍历的第 $1$ 个结果必然为 $0$，所以我们不用计算个数为 $1$ 的情况。        
由于我们一开始就在结点 $1$，所以我们的 $i$ 需要从 $1$ 开始，$dep+sum<i$ 也就可以不考虑。        
[CODE](https://www.luogu.com.cn/paste/f2ma1r3v)