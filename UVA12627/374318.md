一种与楼下题解完全不同的分治：
其实题目问的是从 $a$ 行到 $b$ 行的气球数的和，我们可以把行作为分治的对象，那么我们把每行的气球数看作一个序列，用类似线段树的思想分治，就 $k=3$ 时举例：

|  行数| 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 |
| -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: | -----------: |
| 气球数 | 8 | 4 | 4 | 2 | 4 | 2 | 2 | 1 |
把这个序列颠倒过来，我们发现了什么？

$1,2,2,4,2,2,4,8$

那么接下来是我发现的：**对于每一个长度为 $2^k$ 的区间，后 $2^{k-1}$ 个数的和，是前 $2^{k-1}$ 个数的和的两倍。**

那么我们可以抓住这点来分治，对于每次分治，我们设置一个变量 $dep$，代表当前区间的长度是 $2^{dep}$，再设置一个变量 $f$，代表当前区间数的和是 $1$ 到 $2^k$ 区间的前 $2^{dep}$ 数的和的几倍，这样就可以解决此题了。

代码：
```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
ll t,k,a,b,d[31];
ll ask(int l,int r,int L,int R,int dep,int f)
{
	if(L<=l&&r<=R)return d[dep]*f;
	ll mid=l+r>>1,val=0;
	if(L<=mid)val+=ask(l,mid,L,R,dep-1,f);
	if(R>mid)val+=ask(mid+1,r,L,R,dep-1,f<<1);//说明要查询的区间在右半区间，总和要乘上2
	return val;
}
int main()
{
	cin>>t;
	d[0]=1;
	for(int i=1;i<=30;i=-~i)//预处理出前pow(2,k)个数的和
		d[i]=(d[i-1]<<2)-d[i-1];
	for(int T=1;T<=t;T=-~T)
	{
		ll n=1;
		cin>>k>>a>>b;
		for(int i=1;i<=k;i=-~i)n<<=1;
		a=n-a+1;b=n-b+1;
		cout<<"Case "<<T<<": "<<ask(1,n,b,a,k,1)<<'\n';
	}
	return 0;
}
```