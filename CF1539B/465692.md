# 0x00 思路
先看题。
>给你一个长为 $n$ 的字符串和 $q$ 个区间 $[l,r]$ 。一个字符的**值定义为其在字母表中的序号**。对于每个区间，**输出这个区间字符的值的总和**。$1 \le n,t \le 100000,1 \le l \le r \le n$，保证字符串中都是**小写字母**。

暴力加一定会爆，算了，加优化吧。

那么怎么优化呢？由于我们所算的是某一个区间，那么我们只需要用以此区间 $r$ 为终点，以第 $1$ 个为起点的和减去以第 $l-1$ 个为终点，以第 $1$ 个为起点的和，剩下的就是区间 $[l,r]$ 的和了。上述操作初始化了 $[1,n]$ 的和，此方法结省了时间，叫作“**前缀和**”，这就是解题的关键。

那么这怎么办？
>一个字符的值定义为其在字母表中的序号。

很明显，由此字符减去 ' a ' 字符再加 $1$ 后值便得出了。（具体可见[ASCII码](https://baike.baidu.com/item/ASCII/309296?fromtitle=ascii%E7%A0%81&fromid=99077&fr=aladdin&ivk_sa=1024630g)。）

由于$n\le100000$，每一个字符值最大为 $26$，所以最大值为 $26000000$，小于 ```int``` 的最大值，因此可以放心大胆地用。
# 0x01 实现
```cpp
#include<bits/stdc++.h>
using namespace std;
char a[100005];
int main()
{
	int sum[100005]={},n,q,i,l,r;
	scanf("%d %d\n",&n,&q);∥过滤换行符！
	for(i=1;i<=n;i++)
	{
		scanf("%c",&a[i]);
		sum[i]=sum[i-1]+a[i]-'a'+1;//前已提过。
	}
	for(i=0;i<q;i++)
	{
		scanf("%d %d",&l,&r);
		printf("%d\n",sum[r]-sum[l-1]);
	}
	return 0;
} 
```