[点我看题](https://www.luogu.com.cn/problem/SP2715)

因为这道题比较棘手，没有什么可行的思路，只好枚举；但是普通的枚举又一定会超时，所以，我们想到了二分。

前置芝士：详见这篇[讲二分的文章](https://oi-wiki.org/basic/binary/)，此处就不再赘述。

思路：二分答案（传递时间），用贪心检验是否可行。

方法（以一次二分为例）：

- $1.$ 二分枚举答案的值；

- $2.$ 计算再此时间下消息是否能传递完；

- $3.$ 根据上一步结果修改区间，并记录答案。

细节：

- 这道题的一个坑点就是每个人不一定要跑整数米，所以答案才会保留三位小数点——dalao[@犇犇犇犇](https://www.luogu.com.cn/user/35998)

检验二分的函数（ $check$ ）的写法：

本题很容易便可想到二分，但 $check$ 函数却不是很好写。下面，我就来给大家仔细讲解一下：

设第 $i$ 个人此时已经得知了消息，正要向第 $i+1$ 个人传递。那么，这时共有两种情况：

- $1.$ 当声音当前所能传到最远的距离小于下一个人的跑动距离时，那声音不可能在目标时间内传递到，所以直接返回 $false$ ；

- $2.$ 反之，那声音就可以在目标时间内传递到。但这时，就出现了两个最远位置：声音的和下一个人的。选哪一个呢？——因为声音是要传播到人身上的，即声音和人的位置因处在同一位置上，所以这两个变量取最小值就是要求的当前最远距离啦！

代码：

```cpp
#include<bits/stdc++.h>
#define LL long long//个人习惯 
#define eps 1e-5//eps是设置好的精度 
using namespace std;
int t,n;//t和n如题意 
double d[100005],k;//d和k如题意 
int check(double x)//check函数是用来判断的 
{
	double p=d[1]+x;//p代表的是当前消息能传递到的最远位置 
	for(int i=2;i<=n;i++)
	{
		if(p+k<d[i]-x)return 0;//第一种情况，不满足，返回0 
		p=min(p+k,d[i]+x);//计算下一个人的最远位置 
	}
	return 1;//如果一直到最后一个人结束后仍然可行，则此方案可行，返回1 
}
int main()
{
	scanf("%d",&t);
	while(t--)
	{
		scanf("%lf%d",&k,&n);
		for(int i=1;i<=n;i++)
		{
			scanf("%lf",&d[i]);
		}
		double l=0,r=1e9,mid,ans;//l、r和mid都是标准的左右边界和中间值（随便设了一个右边界1e9），ans是答案 
		while(r-l>eps)//二分板子 
		{
			mid=(l+((r-l)/2));//加了防溢出操作（虽然应该没什么用） 
			if(check(mid))ans=mid,r=mid;//如果此时可行，记录答案，向左继续找更小值 
			else l=mid;//反之，向右找能符合的答案 
		}
		printf("%.3lf\n",ans);//输出答案 
	} 
	return 0;//结束程序 
}
```