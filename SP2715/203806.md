顺便宣传一下自己的[Blog](http://666dhg.github.io/)（有题解，还有福利~~比如说女装照片~~）

# 目录
1. 二分查找讲解
2. 本题讲解

## 1.二分查找讲解
大家好呀，今天又是本~~蒟蒻~~来给大家讲题啦^_^

首先，这道题~~一看就知道~~要枚举，但如果暴力枚举的话...

恭喜你！！！你收获了，

![](https://cdn.luogu.com.cn/upload/pic/75430.png)

~~诶话说这个[超时](https://www.luogu.org/problem/P3920)怎么那么熟悉？？？~~

虽然众所周知，暴力出奇迹，

### 但是，枚举也要**有技巧地**枚举

所以，我们就可以使用最常用的**二分查找**

二分查找，简单来说就是在**单调**的一段答案区间（**一般**都是从小到大）内**有技巧地猜答案**，然后再根据答案是否符合题意来不停地**缩小这个区间**，直到达到**最优解**

举一个简单的例子：

假如现在你知道了答案区间，并且答案具有单调性

![](https://cdn.luogu.com.cn/upload/pic/75440.png)

但是你并不知道答案，为了猜答案的次数越小，你决定从中间猜起

第一次，你猜了5 ，即$\text{ }\text{ }[\frac{1+9}{2}]$

![](https://cdn.luogu.com.cn/upload/pic/75441.png)

但是你猜小了，于是可以排除**5和5左边**的，因为这**一定不是**最优答案。第二次，你猜了7，即$\text{ }\text{ }[\frac{6+9}{2}]$

![](https://cdn.luogu.com.cn/upload/pic/75444.png)

但是你猜大了，于是可以排除**7和7右边**的，因为这**一定不是**最优答案。第三次，你猜了6，即$\text{ }\text{ }[\frac{6+6}{2}]$

![](https://cdn.luogu.com.cn/upload/pic/75445.png)
由于只剩下6了，所以$\text{ }ans=6$

让我们来看回题目：

```cpp
......
//求所有人都知道消息最少需要多少时间。
```

这时，我们注意到了，题目要求答案最小，所以我们的思路是：

1. ### 找出答案区间，并判断答案是否具有单调性（这一点很重要！！！因为假如答案没有单调性的话会得出错误的答案！！！）

2. ### 找出中间数并判断是否可行

- ### 如果这个答案符合题意，那么右边的答案也符合题意，排除，并在左边寻找最优答案

- ### 如果这个答案不符合题意，那么左边的答案也不符合题意，排除，并在右边寻找最优答案

3. ### 如此循环，直到找到最优答案

我们可以用三个变量来模拟：

$Left\text{ }\text{ }(LowerBound):\text{答案区间的最小值}$

$Right\text{ }\text{ }(UpperBound):\text{答案区间的最大值}$

$Middle\text{ }\text{ }:\text{答案区间的中间值}$

就可以得到以下模板：

```cpp
//二分查找求最大的最小值
int Left = x, Right = y, Middle; //定义答案区间的最小，最大与中间值并初始化
while (Left < Right)
  {
	Middle = (Left + Right) >> 1 ; //计算出当前答案区间的中间值。（此处使用了位运算，等价于 / 2） 
	if (check(Middle)) Right = Middle ; //如果中间值可行，说明右边的也行，那么排除右边的答案 
	else Left = Middle + 1 ; //如果中间值不可行，说明左边的也不行，那么排除左边的答案和中间值
  }
```

Update in 2019.8.29:由于每次判断都会减少一半，所以时间复杂度最差为$O(log_2n)$，普通暴力的时间复杂度为$O(n)$。所以，在普通暴力的情况下TLE时，可以使用二分查找来骗分。

## 2.本题讲解

有了模板，接下来的就是判断中间值是否可行了。

我们可以用一个$\text{ }check\text{ }(int \text{ }x)\text{ }$来判断

二分查找的$\text{ }check\text{ }(int \text{ }x)\text{ }$通常都可以用**贪心策略**

那么我们的策略就是：

1. ### 判断每个人在规定时间内（即判断的那个数）能走到哪里
2. ### 如果第$\text{ }i\text{ }$个人能往右走的最远距离加上传播距离（即$\text{ }a[i]\text{ }+time+k$）小于第$\text{ }i+1\text{ }$个人能往左走的最远距离（即$\text{ }a[i+1]\text{ }-time$），说明答案不可行
3. ### 如果能成功传到最后一个人，说明答案可行

Update in 2019.8.29:对于判断小数的情况，模板可以这样写：

```cpp
//二分查找求最大的最小值
double Left = x, Right = y, Middle; //定义答案区间的最小，最大与中间值并初始化
for (int i = 1 ; i <= 100 ; i ++)
  {
	Middle = (Left + Right) / 2 ;//当前答案区间的中间值。     
	if (check(Middle)) Right = Middle ; //如果中间值可行，说明右边的也行，那么排除右边的答案 
	else Left = Middle + 1 ; //如果中间值不可行，说明左边的也不行，那么排除左边的答案和中间值
  }
```

我们只需要```for```个100次，由于每次都会减少$\frac{1}{2}$的区间，所以```for```了一百次后，精度已经达到了$2^{-100}$次方，已经足够了。（Update at 11.15：精度打错了QAQ）

完整代码如下：

```cpp
#include <bits/stdc++.h>
using namespace std;

double k, a[100010];
int T, n;

bool check (double t) //二分核心 
  {
	double s = a[1] + t, x, y; //s 表示当前的坐标 
	for (int i = 2; i <= n; i ++)
	  {
		x = a[i] - t; //向左走的最远距离 
		y = a[i] + t; //向右走的最远距离 
		if (s + k < x) return false; //如果现在的距离加上传播距离还是小于第 i 个人向左走的最远距离，说明答案不可行 
		if (s + k > y) s = y; //如果现在的距离加上传播距离大于第 i 个人向右走的最远距离，那么现在的距离更新为第 i 个人向右走的最远距离 
		else s += k;
	  }
	return true; //传完了 n 个人，说明答案可行 
  }
  
int main()
  {
	scanf ("%d", &T) ; //有T组数据 
	while (T--)
	  {
		scanf("%lf%d", &k, &n) ; //读入传播距离 k 与人数 n 
		for (int i = 1; i <= n; i ++) scanf ("%lf", &a[i]) ; //读入第 i 个人的坐标 
		double l = 0, r = 99999999.0, mid;
		for (int i = 1; i <= 100; i ++)
		  {
			mid = (l + r) / 2.0;
			if (check(mid)) r = mid;
			else l = mid;
		  }
	    printf("%.3f\n", r); //输出最少的时间 
	  }
	return 0;
  }
```
制作不易，点个赞再走吧QwQ