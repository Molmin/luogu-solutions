## 竟然没有c++党的题解！自己来一发。

这道题的一个坑点就是每个人**不一定要跑整数米**，所以答案才会保留三位小数点。   

还有一个是人听完声音后可**以跑出上一个人的声音范围**再传给下一个人，而不一定要在上一个人声音范围内才可以传给下一个人。

这道题我们要求的是最小的时间$m$，也就是说每个人$a[i]$最多可以跑$m$米，也就是说每个人跑的范围是 $a[i]-m$到$a[i]+m$。

所以我们只要知道了最小时间$m$便可以对声音进行$O(n)$复杂度的模拟**判断是否可以**，所以可以~~自然地~~想到这道题可以**二分**来做

主要的$check$部分有三种情况

其中$X$表示第$i$秒所能达到**最远的距离**。

## 1.

![](https://i.loli.net/2019/04/07/5ca953031c06c.jpg)

如图所示，声音所能传到最远的距离为$X+k$，人跑动范围为图中半径为$mid$的园内部分$[a_i-mid,a_i+mid]$,所以人在$mid$的时间内**不可能听到声音**，故直接退出。

对应代码：

```
if(x+k<a[i]-mid) //若听不到声音
{
	f=false; //记录为了接下去的二分
	break; //直接退出
}
```
## 2.

![](https://i.loli.net/2019/04/07/5ca954a033f36.jpg)

如图所示，$X+k$在人的跑动范围内，因为要使当前声音传的距离**尽量远**，所以人就跑到X+k的地方去听声音而不是$a_i-mid$  
因为上面已经把听不到的情况排除掉了，所以这里代码很简单。

只有一行。。。

```
x=x+k
```

## 3.

![](https://i.loli.net/2019/04/07/5ca9564a07a4a.jpg)

如图所示，由于声音传播范围太大，而人做多只可以跑到$a_i+mid$的地方，所以只能在$a_i+mid$的地方听声音

代码还是只有一行：

```
if(a[i]+mid<x) x=a[i]+mid;

```

所以下面就可以愉快的二分了

```
if(f) r=mid; //如果mid可以
else l=mid; //如果mid不可以做到

```
这道题总图来说算法不难，但是坑点还是有些的。。。

## 完整程序：

```
#include <bits/stdc++.h>
using namespace std;
int n,T;
double k,a[100005],ans,x,mid,l,r;
bool f;
int main()
{
	cin>>T; //t组数据
	while(T--)
	{
		int i;
		cin>>k>>n;
		for(i=1;i<=n;i++)
			cin>>a[i];
		l=0;r=1000000000; //二分左右边界
		while(r-l>0.00001) //怕被卡精度打高了点
		{
			//cout<<l<<" "<<r<<endl; 
			mid=(l+r)/2;
			x=a[1]+mid; //第一秒声音传播的最远距离为第一个人最远的跑动距离
			f=true;
			for(i=2;i<=n;i++)
			{
				if(x+k<a[i]-mid)
				{
					f=false; 
					break;
				}
				x=x+k;
	    		if(a[i]+mid<x) x=a[i]+mid;
	    	}
	     	if(f) r=mid;
	        else l=mid;
		} //二分部分
		cout<<setprecision(3)<<fixed<<l<<endl;
	}
	return 0;
} 
```






