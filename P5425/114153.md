### 神仙结论题
___

一句话题意：

给你 $n,k$ ,求 将 1~n  $n$ 个数划分为 $k$ 组中，跨组的两数$i,j$中 

$Min[(2019201913i + 2019201949 j)mod2019201997]$的最大值

___

怎么办呢

大数看着烦，先令$X = 2019201997$

代回原式子

原式$= [(X-84)i+(X-48)j]mod \ X $(为美观先去掉$Min$)

$ = [Xi + Xj - 84i - 48j]mod \ X$

$ = [-84i -48j + X] mod \ X$(其实可以把外层mod去掉）

$ = -84i -48j + X$

使这个式子最小值最大

构造一个最小值

$j$ 肯定 $=n$(毕竟是最小值)

使 $i$ 在保证是全式最小值时最小

所以

就有策略了
___

将$1,2,3,4...k-1$分别分为一组，

$k,k+1...,n$为一组

$i$就可以尽量最小了（$i = k-1$）
___

$Ans = -84*(k-1)-48*N + 2019201997$

___
#### Code
```cpp
#include <cstdio>
using namespace std;
int n,k;
int main(){
	scanf("%d %d",&n,&k);
	printf("%lld",(long long)-84*(k-1)-48*n+2019201997);
	return 0;
}
```