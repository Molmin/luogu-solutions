来一个模拟赛时想出树剖的做法。

记 $d_u$ 表示根到 $u$ 的距离，$l$ 表示 $\operatorname{lca}(s,t)$，则代价可以转化为：
$$
-d_s+(z_t-d_t+2d_{l})
$$

那么就得到了一个暴力做法，每次从 $s$ 暴力向上跳枚举 $l$ ，并用 $z_t-d_t+2d_l$ 更新答案，这里要求 $t$ 在 $l$ 的子树中且不和 $s$ 来自同一棵子树。

这里 $t$ 的限制条件太复杂，考虑简化，注意到如果 $l$ 只是 $s,t$ 的公共祖先，而非最近公共祖先，只会把答案算小并不会影响最终答案，故我们对 $t$ 的限制条件就可以变为：$t$ 在 $l$ 的子树中。

还有一个问题，题目要求 $s\neq t$，我们只需要再记一下次大值即可，由于次大值是类似的，下面就只讲如何维护最大值。

考虑如何加速上面的过程。一种想法是对于每个节点 $u$ 直接维护 $2d_u+z_x-d_x$ 的最大值，其中 $x$ 是 $u$ 子树中的点。树剖后，把这个东西按照 dfs 序放在线段树上，就可以查询了。但问题是修改了点权或边权后，当前点或边到根路径上的所有点的这个值都要被修改，又因为是维护的最大值，所以不太能通过打标记的方式快速修改。

于是就应该想到一个经典套路：只维护轻子树中的节点。就是说，对于每个节点 $u$ 维护 $2d_u+z_x-d_x$ 的最大值，其中 $x$ 是 $u$ 轻子树中的点。

先考虑修改点权，那么每次修改后，只会有 $\log$ 个点会改变（因为包含 $u$ 的轻子树个数是 $\log$ 的）。为了计算这 $\log$ 个点新的最大值，我们需要能够支持查询子树中 $z_x-d_x$ 的最大值，于是还要开一棵线段树维护 $z_x-d_x$ 的区间最大值。

修改边权也是类似的。设这条边为 $(u,v)$ ，**变化量**为 $c$，其中 $v$ 的深度更深。
+ 对于 $v$ 子树中的所有点，$d$ 都会增加 $c$，而对于所有 $v$ 子树中的 $u$ ，$2d_u+z_x-d_x$ 的最大值也会恰好增加 $c$ ，维护一个区间加法标记即可。
+ 对于不在 $v$ 子树中的点，和前面类似，只有 $\log$ 个更改。

总结一下到底维护了什么：

+ 一个 `bit` ，维护 $d_u$，支持区间加，单点查询。
+ 一个 `seg` ，维护 $d_u-z_u$，支持区间加，区间查询 $\max$。
+ 一个 `seg` ，维护 $2d_u+z_x-d_x$（$x$ 是 $u$ 轻子树中的点），支持区间加，单点修改，区间查询 $\max$。

时间复杂度 $O(n\log^2 n)$ ，跑得很快。