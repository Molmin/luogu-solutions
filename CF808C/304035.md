      第一次发题解，写的不好请见谅。
      首先根据已知分析，如果要让每个酒杯倒上一半，那么至少
      需要让w的值大于等于每个酒杯容量一半的总和。
      
      不过大家都知道C++整形数/2的结果自动向下取整，如果容量
      是一个奇数，那么a[i]/2会小于a[i]的一半，所以要判定这
      个数是奇数或偶数并进行不同处理。
      
```cpp
#include<bits/stdc++.h>
#define N 1000010
#define LL long long
#define UNLL unsigned long long
using namespace std;
int n,w,a[N],b[N],mark[N];
int main(){
	cin>>n>>w;
	int cnt=0;//记录每个酒杯装一半总共要多少酒 
	for(int i=1;i<=n;i++){
		cin>>a[i];//记录每个酒杯的容量 
		if(a[i]&1){//一个数&1 &是按位与 结果为true为奇数，结果为false为偶数 
			cnt+=a[i]/2+1;
			b[i]=a[i]/2+1;//记录每个酒杯中现有的酒 
		}
		else{
			cnt+=a[i]/2;
			b[i]=a[i]/2;
		}
	}
	if(cnt>w){//如果至少装一半都不够，那么找不到题解，输出-1 
		cout<<-1;
		return 0;
	}
	w-=cnt;//如果装一半够了，把倒了一半的酒减掉 
```

      现在我们继续思考剩下的酒怎么处理。
      
      既然要把所有酒全部倒完，并且让所有人全部满意，那么就
      需要从容量最大的开始倒酒，一直到酒被倒完
      
      注意这里有一个误区，不可以把剩下的所有酒全部倒到一个
      人的杯子里，可能会满出来，并且一定要根据容量判定给谁
      倒，因为根据现在有多少酒会让有的样例不满意（我就这么
      错了一回）
      
      同时为了避免死循环，一定要让倒过酒的人标记一下，否则
      循环就会一直进行在一个倒过酒的人上
```cpp
	while(w){
		int big=-1,t;//big记录最大的容量，t为下标 
		for(int i=1;i<=n;i++){
			if(!mark[i]&&a[i]>big){//排除已经倒过酒的人 
				big=a[i];
				t=i;
			}
		}
		mark[t]=1;//这次是第t个杯子倒酒，标记防止下次继续点到这个杯子 
		if(w>a[t]-b[t]){//判定剩下的酒是倒满有多余或是不能倒满 
			w-=a[t]-b[t];
			b[t]=a[t];//直接倒满，并把剩余的酒酒减去倒入的量 
		}
		else{
			b[t]+=w;//倒不满只能把剩下所有的酒全部倒进去 
			w=0;//注意一定别忘记清空w，避免死循环 
		}
	}
	for(int i=1;i<=n;i++){
		cout<<b[i]<<' ';//注意一定要输出当前酒量的数组 
	}
	return 0;
}
```

      希望管理员大大让我通过 这是我想的最简单的代码了
      