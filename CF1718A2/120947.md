## Solution

有没有一种可能 , 我不配打 div 1 .

首先 , 操作的顺序没有影响 . 其次 , 我们看一看到底最优解是什么情况 .

比如一个端点 $r$ , 它现在有两个左端点与之对应 : $l_1$ 和 $l_2$ , 也就是说 $[l_1,r]$ 和 $[l_2,r]$ 被操作了 . 如果 $l_1=l_2$ , 那么显然合并到一起去 , 不然 , 我们会这样做 :

把这两个操作变成 $[l_1,l_2-1]$ 和 $[l_2,r]$ ( $l_1<l_2$ ) . 很容易发现 , 这样肯定更优 . 

对于左端点也可以做同样的操作 . 这样我们就知道 , 每个点最多作为左端点一次 , 最多作为右端点一次 .

我成功卡在这里了 . 进一步思考发现 , 如果两个区间的交长度大于等于 $2$ , 那么给分裂成三个区间肯定更优 . 所以 , 现在又多了一个条件 : 任何区间的交不会超过 $1$ .

然后我们发现 , 长度为 $k$ 的区间 , 拆成 $2,2,2,\dots,2(,1)$ 并不影响答案 , 所以 , 现在所有区间的长度又不超过 $2$ 了 .

是不是还是有点晕乎 ? 那么继续 : 如果一个长度为 $1$ 的区间包含在长度为 $2$ 的区间内 , 是不是拆成两个长度为 $1$ 的区间更优 ?

所以有多了个条件 : 任何长度为 $1$ 的区间都不和其它区间相交 .

现在画一画这个图 , 如果像图一样看待问题 , 你是不是就可以把区间的两个端点连起来 . 现在发现 , 一个合适的操作 , 化成图都是 点 + 链 的形式 !

考虑到一个链上 , 每次操作相邻两个数 . 仔细推敲一下可以发现 , 最后一个数肯定等于前面那些数的异或和 , 也就是说 , 这一段异或和等于 $0$ .

而我们知道 , 最劣答案肯定是 $n$ , 每个数操作一次 . 而一个链 , 可以减少一个贡献 .

所以 , 现在也就变成了 : 在一个序列上找最多的区间 , 使它们两两不交 , 且长度都大于等于 $2$ . 这是不是一个显然的 DP .

所以就写完了 !

code :

```cpp
#include<bits/stdc++.h>
#define ffor(i,a,b) for(int i=(a);i<=(b);i++)
#define roff(i,a,b) for(int i=(a);i>=(b);i--)
using namespace std;
const int MAXN=1e5+10;
int T,n,pre[MAXN],a[MAXN],dp[MAXN];
void work(void) {
	cin>>n; ffor(i,1,n) cin>>a[i];	
	ffor(i,1,n) pre[i]=a[i]^pre[i-1];
	dp[0]=0; map<int,int> mp;
	mp[0]=0;
	ffor(i,1,n) {
		dp[i]=dp[i-1];
		if(mp.find(pre[i])!=mp.end()) dp[i]=max(dp[i],dp[mp[pre[i]]]+1);
		mp[pre[i]]=i;	
	}
	cout<<n-dp[n]<<'\n';
}
int main() {
	ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
	cin>>T; while(T--) work();
	return 0;
}
```

本题难点在于贪心过程 . 下次多练贪心 .