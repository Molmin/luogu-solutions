### 解题思路

这里设 $E_x$ 等于 $work(x)$ 的期望返回值，按照题面中的程序，我们可以直接列出其递推式：

$$E_x = \frac{\sum_{i=1}^{x}E_i}{x} + 1$$

特别地，$E_1 = 0$。

然而我们想知道的是 $E_x$ 的通项式子，想要得到它还需作稍微复杂的变幻。

设 $D_x = E_x - E_{x-1}$，即 $E_x$ 的差分。不妨先求出 $D_x$ 的通项式，累加一下就可得 $E_x$ 的通项式了。既然是差分，我们主要关注 $E_x$ 和 $E_{x-1}$ 有什么有趣的关系，下面的推算保证 $x \geqslant 3$。

$$E_x = \frac{\sum_{i=1}^{x}E_i}{x} + 1,\ \ \ E_{x-1} = \frac{\sum_{i=1}^{x-1}E_i}{x-1} + 1$$

这分母一看就很不爽，乘掉：

$$xE_x = (\sum_{i=1}^{x}E_i)+x,\ \ \ (x-1)E_{x-1} = (\sum_{i=1}^{x-1}E_i) + (x-1)$$

看两边还是挺像的，而且现在的目标是差分的通项式，考虑左边减右边：

$$xE_x - (x-1)E_{x-1} = (\sum_{i=1}^{x}E_i) + x - (\sum_{i=1}^{x-1}E_i) - (x-1)$$

简化一下上式：

$$xE_x - xE_{x-1}+E_{x-1}=E_x+1$$

移项：

$$xE_x - E_x - xE_{x-1}+E_{x-1} = 1$$

再合并回来：

$$(x-1)(E_x - E_{x-1}) = 1$$

诶，这 $E_x - E_{x-1}$ 不就是我们要的 $D_x$ 吗！而且根据上式我们发现 $D_x = \frac{1}{x-1}$！

注意上面的讨论都是基于 $x \geqslant 3$ 的，因为 $x = 2$ 时$E_{x-1}$ 是特殊值。所以 $E_1 = 0$ ，$E_2 = 2$ 的值我们单独考虑，其他的直接 $E_x = E_2 + \sum\limits_{i=3}^{x}D_i = 1 + \sum\limits_{i=1}^{x-1} \frac 1 i$。

推到这儿爽得一比对不对！但一看数据范围 $n < 2^{31}$，即使是 $O(n)$ 也注定挂……

但重新看看通项式，这和调和级数非常相像！怎么快速计算 $n$ 以内的调和级数呢？对于较大的 $n$，我们可以直接用 $1 + \gamma + ln(n)$ 得到精确的答案（这里 $\gamma = 0.577...$）。较小的 $n$，上面神奇的式子反而不精确，因此还是使用暴力计算。

这里推荐大家去看 https://www.bilibili.com/video/av12542782 了解更多有关“神奇的式子”的姿势。

---

### 代码实现

c++ 里面 $log$ 好像就是 $ln$。另外不要忘了特判 $n = 1$ 哦！

```cpp
#include <cmath>
#include <cstdio>

const int limit = 19260817;
const double _gamma = 0.5772156649015328;

int n;
double ans;

int main() {
    scanf("%d", &n);
    if (n == 1) { printf("%.5lf\n", 0.0); return 0; } // 特判 n = 1.
    if (n <= limit) {
        for (int i = 1; i < n; i++) { ans += 1.0 / i; } // 一定范围内直接计算.
    } else { ans = log(n) + _gamma; } // 否则套这个神奇的式子.
    printf("%.5lf\n", ans + 1);
    return 0;
}
```