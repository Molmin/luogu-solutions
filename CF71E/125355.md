# 题目

[传送门](https://www.luogu.com.cn/problem/CF71E)

# 题解

~~这个原子序数是真的狗~~

首先，看一下那可怜的数据范围：$1\le k\le n\le 17$，那么小？考虑直接暴力...

考虑定义暴力函数 `dfs(const int now,const int s)` 为我们已经处理到目标原子 $now$，而剩下的元素情况为 $s$ 的局面，显然 $s$ 是一个小雨等于 $2^{17}$ 的二进制串，显然，我们选择的组成 $now$ 的原子一定是 $s$ 的子集，可以这样枚举子集：

```cpp
for(int t=s;t;t=(t-1)&s)
```

在这些子集中，找一个子集使得他们的和刚好为 $b[now]$ 的值，最后如果 $now=k+1$ 并且 $s=0$ 时，找到合法解并直接输出。

为了降低复杂度，我们可以定义一个记忆化数组 `bool failed[]` 表示 `dfs(now,s)` 是否失败过，如果曾经失败过就不用再找了

状态有 $17\times 2^{17}$，子集的枚举是 $2^{17}$，极限复杂度似乎为 $\mathcal O(17\times 2^{17}\times 2^{17})$，但是由于我们每一次枚举子集，都只会把 $1$ 变成 $0$，而 $0$ 再也变不回 $1$，所以之多只有 $17$ 层，时间复杂度为 $\mathcal O(17\times 17\times 2^{17})=\mathcal O(37879808)$

# 代码

```cpp
https://www.cnblogs.com/Arextre/p/13442435.html
```

