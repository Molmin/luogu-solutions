因为这个描述很有“二进制”的特征，因此我们可以通过观察然后~~找规律~~得出答案。

我们先观察这个顺序：

$1,5,3,7,2,6,4,8$

因为是“二进制”，就考虑将它折半：

$1,5,3,7\ |\ 2,6,4,8$

我们发现，折出的两半中，相同位置的差是$1$，即$2^0$。

继续折半：

$1,5|3,7$

相同位置的差是$2$，即$2^1$。

再来！

$1|5$

相同位置的差是$4$，即$2^2$，也即$2^{n-1}$。

似乎找到了什么规律？

再来观察$n=5$时的数列：

$1,17,9,25,5,21,13,29,3,19,\text{etc.}$

我们直接观察相邻两项的差（即最后一次折半的结果），发现都是$16$，是$2^4$，也即$2^{n-1}$。然后观察间隔一个数的差，发现都是$8$，是$2^3$……

因此我们可以想出这样的算法，即**从大到小**枚举这个折半的长度，即$2^i$。如果$k$比它小，就说明在折半的前一半里面，答案不变；否则，即在后一半里面，$k$减去$2^i$，答案加上$2^{n-i-1}$（即当前两半之差）。

**为了利用二进制的性质，$k$一读进来就应该减去$1$，并且输出时答案应该再加$1$（因为该算法默认位置从$0$开始）。**


------------

在这里简单说明一下这个顺序的来历：

首先第一个衣服肯定挂在$1$号位。

然后，在图上找一下，就会发现第二件只能挂在$2^{n-1}$的位置上；

然后现在因为只有左子树能大于右子树，因此第三件挂在$2^{n-2}$上；

继续枚举下去，第$4$件挂在$2^{n-1}+2^{n-2}$上；

第$5$件挂在$2^{n-3}$上；

第$6$件挂在$2^{n-1}+2^{n-3}$上

第$7$件挂在$2^{n-2}+2^{n-3}$上；

第$8$件挂在$2^{n-1}+2^{n-2}+2^{n-3}$上

……

实际上，第$k$件的位置**是$k-1$的二进制表达的逆序并加一**。

------------

最后是复杂度分析。因为$k\leq 10^{18}$，因此这个$i$只要从$\min(62,n)$开始枚举即可。如果用快速幂计算$2^{n-i-1}$的话，复杂度是$O(62\log n)$的；当然，图方便，直接$O(n)$预处理$2^i$也没什么不可以的。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
const int mod=1e9+7;
int n,m,bin[64],res,BIN[1001000];
signed main(){
	cin>>n>>m,m--,bin[0]=BIN[0]=1;
	for(int i=1;i<=62;i++)bin[i]=bin[i-1]<<1;
	for(int i=1;i<=n;i++)BIN[i]=(BIN[i-1]<<1)%mod;
	for(int i=62;i>=0;i--)if(m>=bin[i])m-=bin[i],(res+=BIN[n-i-1])%=mod;
	cout<<++res<<endl;
	return 0;
}
```
