Upd @2022.2.10 对题解中1处叙述不清，2处 $\LaTeX$ 和中文标点间的空格，一处 $\LaTeX$ 中大括号直接使用`{}`而不是`\{\}`，~~以及一个代码中严重影响蚂蜂的空格缺失~~进行了修正。  
Upd @2022.2.10 看了下管理的贴，完善一下对于极大和最大的说明（其实之前也有，但是没把重点放这里，写的不行），写的更棒棒了

[博客](https://www.luogu.com.cn/blog/fast-photon/ti-xie-p8109-post)食用更佳~  
[原题](https://www.luogu.com.cn/problem/P8109)  

**题目大意**  
给定两个数组 $\{a_n\}$ 和 $\{b_n\}$，元素个数均为 $n$ 个，对 $\{b_n\}$ 重新排列使得 $\sum_{i=1}^n{\min(a_i,b_i)}$ 最大化。数据保证 $\{a_n\}$ 和 $\{b_n\}$ 不降。  
注：也就是表示对于所有的 $i$，在 $a_i$ 和 $b_i$ 中取较小值，然后求和，让这个和最大。  

**简要分析**  
首先我们可以看出，在一个数组中，无论最后如何排列，都可以从不降的状态多次次交换一对前小后大的数据得到，也就是对于 $\{x_n\}$ 的一种排列方式 $\{y_n\}$，一定有一种方式，进行多次交换 $x_i$ 和 $x_j$ 得到 $\{y_n\}$  
其实这个不难证明，但是为了题解过审我交代一下。  
设序列 ${x_n}$ 不降，即对于 $1\le i<n$ 有 $x_i\le x_{i+1}$，则可以通过如下方式进行交换：  
交换 $x_k$,$x_n$（$x_k$ 和 $y_n$ 是一样的，并且显然 $x_k\le x_n$）  
这样的话 $x_n$ 和 $y_n$ 就一样了。然后对前 $n-1$ 个继续进行交换。  

因为好像没有这个词，我们定义“劣化”就是负优化。  
那么如果可以证明对于 $a_1\le a_2$ 以及 $b_1\le b_2$，无论如何都是最优情况即交换的话结果更劣，那么由上面的证明可以得到，任何一个非不降排列的排列都可以由不降排列进行多次劣化得到。  
该证明如下：  
假设交换的是 $b_i$ 和 $b_j$，如果 $b_i=b_j$ 或者 $a_i=a_j$，那么结果并不会变化，因为影响结果的只是每一对数的具体数值，而不是它们之间的顺序。

**推式子**  
设 $a_1<a_2$（因为 $a_1=a_2$ 没有交换的必要，所以不是 $a_1\le a_2$），$b_1<b_2$（同理），并进行分类讨论。 

**当 $\bm{a_1<b_1,a_2<b_2}$**  
即 $a_1<b_1<b_2,a_1<a_2<b_2$  
原本的结果为 $a_1+a_2$，交换后变为 $\min(a_1,b_2)+\min(a_2,b_1)$。  
不难发现 $\min(a_1,b_2)=a_1$，而 $\min(a_2,b_1)\le a_2$，也就是交换后要么变小要么不变。  
所以这种情况无需交换。  
**当 $\bm{a_1<b_1,a_2>b_2}$**  
即 $a_1<b_1<b_2<a_2$  
原本的结果为 $a_1+b_2$，交换后变为 $\min(a_1,b_2)+\min(a_2,b_1)$。  
不难发现 $\min(a_1,b_2)=a_1$，而 $\min(a_2,b_1)<a_2$，也就是交换后一定变小。  
所以这种情况也无需交换。  
**当 $\bm{a_1>b_1,a_2<b_2}$**  
即 $b_1<a_1<a_2<b_2$  
原本的结果为 $b_1+a_2$，交换后变为 $\min(a_1,b_2)+\min(a_2,b_1)$。  
不难发现 $\min(a_1,b_2)=a_1<a_2$，而 $\min(a_2,b_1)=b_1$，也就是交换后不可能变大。  
所以这种情况依然无需交换。  
**当 $\bm{a_1>b_1,a_2>b_2}$**  
即 $b_1<a_1<a_2,b_1<b_2<a_2$  
原本的结果为 $b_1+b_2$，交换后变为 $\min(a_1,b_2)+\min(a_2,b_1)$。  
不难发现 $\min(a_1,b_2)\le b_2$，而 $\min(a_2,b_1)=b_1$，也就是交换后不可能变大。  
**所以所有情况都不用交换。也就是说，出题人已经把最优排列方式送给我们了，我们只需要直接计算即可。**  

~~最令人期待的~~**代码**  
```cpp
#include<cstdio>
#include<algorithm>

using namespace std;

int n, a[100005], b[100005];
long long sum; //不开LL这题好像也能过，但我不信任出题人。

int main() {
	scanf("%d", &n);
	for(int i = 0; i < n; i++) {
		scanf("%d", &a[i]); 
	}
	for(int i = 0; i < n; i++) {
		scanf("%d", &b[i]);
		sum += min(a[i], b[i]);
	}
	printf("%lld", sum);
}
```