### 题意

给定两个单调不降的数组 $a$ ， $b$ ，求一种匹配方案使得 $ans= \sum_{i=1}^nmin(a_i,b_i)$ 最大。



------------


### 思路

> 另外我很想讨论一下本题的难度

> 本题的做题难度非常的低，可以标红-橙，但是解题难度比较高，我个人认为有绿

>    >选手A：读错题了，没看到可以重排，直接过了

>    >选手B：没读错题，想了想出题人为什么排序，于是直接写了一个正序交上去，过了

[以上](https://www.luogu.com.cn/discuss/407689) By [WYXkk](https://www.luogu.com.cn/user/130151) Orz

确实，这题作为月赛第一题做题难度确实不大， ~~多少咕值猎手下了月赛直接就开始码题解了~~ ，很容易就能凭各位的数感反应过来：直接正序比较每个下标对应的元素较小值就好了，把它们累加起来然后打印，满分到手。

而且还要感叹一句出题人真良心，排序都不用自己动手，直接保证了单调不降，感动你谷。

那么问题来了，为啥上面的方案是正确的？

有些同学开始了感性理解，“啊这里贪心一下让小的数物尽其用”，“大的数和小的数在一起不是浪费吗”，甚至还有“啊反正这么交全绿了能过就好”。

实际上，有这样的思维方式很容易在 OI 赛制的比赛中吃亏。如果对得出来的结论不加思考的话，那么考场上往往会得不偿失，被刻意构造的数据叉得连连失分。例子有很多，但不列举。

我们需要证明这个结论的正确性。

我们的结论是：将 $a$ 、 $b$ 序列排序后，有$ans_{max}= \sum_{i=1}^nmin(a_i,b_i)$

即累加排序后同一位置的较小值得到的和为最大答案。

首先，总共的方案共计 $n!$ 个，情况数有限，故一定有答案最大的方案。

假设我们的原方案不是这个最大方案，那么就一定有一个顺序异于原方案的匹配方式使得答案最大。即相对于排序后的数组 $a$ 或 $b$ （下面假设是 $a$ ）而言至少存在一组逆序对 $(i,j)$ （其中 $i<j$ ），使得 $a_i>a_j$ 。

接下来我们分类讨论这个逆序的过程：（已去掉其中矛盾的情况）

1. $a_i<b_i$ ， $a_j<b_j$ ，$a_j>b_i$

此时原答案为 $a_i+a_j$ ， 逆序后为 $b_i+a_i$ ，由于 $a_j>b_i$ 故新答案更小。

2. $a_i<b_i$ ， $a_j<b_j$ ，$a_j<b_i$

此时原答案为 $a_i+a_j$ ， 逆序后为 $a_j+a_i$ ，无差别，旧答案不会更小。

3. $a_i>b_i$ ， $a_j<b_j$ ，$a_j>b_i$

此时原答案为 $b_i+a_j$ ， 逆序后为 $b_i+a_i$ ，新答案更小。

4. $a_i<b_i$ ， $a_j>b_j$ ，$a_j>b_i$

此时原答案为 $a_i+b_j$ ， 逆序后为 $b_i+a_i$ ，新答案更小。


5. $a_i>b_i$ ， $a_j>b_j$ ，$a_i<b_j$

此时原答案为 $b_i+b_j$ ， 逆序后为 $b_i+a_i$ ，新答案更小。

6. $a_i>b_i$ ， $a_j>b_j$ ，$a_i>b_j$

此时原答案为 $b_i+b_j$ ， 逆序后为 $b_i+b_j$ ，无差别，旧答案不会更小。

由上可以看出，若逆序后答案更新，则答案一定由于 $(i,j)$ 位置上较小值变小导致更新，故新答案不会更大，假设不成立，原命题成立，原方案得到的答案最大。

简单来说，我们已知存在一个最优的方案，正序的方案是一个较优的方案且非正序的方案都不优于正序方案，那么正序就是最优。

~~我是第二没人能当第一，那么我就是第一！~~

------------

### 代码

```cpp
#include<bits/stdc++.h>
#define ll long long
#define R read()
#define file(a) freopen(#a".in","r",stdin),freopen(#a".out","w",stdout)
using namespace std;
inline ll read() {
	ll s=0,f=1;
	char ch=getchar();
	while(ch<'0'||ch>'9') {
		if(ch=='-')f*=-1;
		ch=getchar();
	}
	while(ch>='0'&&ch<='9') {
		s=s*10+ch-'0';
		ch=getchar();
	}
	return s*f;
}
inline void write(ll x) {
	if(x<0) putchar('-'),x=-x;
	if(x>9) write(x/10),x%=10;
	putchar('0'+x);
}//Don't use it for CF.
inline void wk(ll x){write(x);putchar(' ');}
inline void we(ll x){write(x);putchar('\n');}//以上为快读快写。
ll n,ans;
ll a[100005],b[100005];
signed main(){
	n=R;
	for(ll i=1;i<=n;i++)a[i]=R; 
	for(ll i=1;i<=n;i++)b[i]=R;//读入两个数组。
	for(ll i=1;i<=n;i++)ans+=(min(a[i],b[i]));//题目已经保证单调不降，那么我们直接比较即可。
	we(ans);//打印答案。
	return 0;
}
```
