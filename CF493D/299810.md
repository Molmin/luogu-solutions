$当n为奇数时,后手必胜$

$因为后手可以一直模仿先手走$

$比如白字从(1,1)走到(1,2),那么黑子就从(1,n)走到(1,n-1)$

$这样一直模仿先手走,知道先手走到第n/2+1列$

$由于之前后手都是对称走的,所以这一步可以直接吃掉它$

<br/>

$}当n是偶数时,先手必胜$

$因为先手第一步可以走到(2,1)位置$

$此时不论后手怎么走,先手都可以模仿后手走,就是上面的情况$

$注意到之后的步骤先手怎样都不会走到第一列去了,因为是对称走$

$所以减去这列,回到了n是奇数的情况,先手必胜$

```
#include <bits/stdc++.h>
using namespace std;
int main()
{
	int n;  cin >> n;
	cout << (n%2==0?"white\n1 2":"black");
}
```