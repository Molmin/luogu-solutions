### 题意

给定一个长度为 $n$ 的序列 $a$ ，询问 $m$ 次区间中有多少本质不同逆序对。

$1 \le n \le 10^5, \ 1 \le m \le 5 \times 10^5, \ 1 \le a_i \le 10^5$ 。

### 普通莫队怎么做？

>转移，即计算左、右端点的扩张、收缩： $[l, r] \to \ \begin{array}{l} [l - 1, r] \\ [l + 1, r] \\ [l, r - 1] \\ [l, r + 1]\end{array}$
>
>贡献，即转移为这次询问的答案增加了多少。（通常答案是个数字）
> 
> $(p, q)$ 与 $(x, y)$ 本质相同指的是 $a_p = a_x$ 且 $a_q = a_y$ 。 $(p, q)$ 和 $(x, y)$ 可以不是逆序对。下文默认对于任意数对 $(x, y)$ 都有 $x < y$ 。

我们发现这个问题用莫队解决。以右端点扩张为例，$[l, r - 1] \to [l, r]$ 。我们要找，有多少个 $i$ 在 $[l, r - 1]$ 中使得 $(i, r)$ 与其他逆序对本质不同。

1. 记 $r'$ 是从 $r$ 起从右往左数第一个值为 $a_r$ 的位置 ，也就是 $\begin{aligned} r' = \max_{x < r \text{且} a_x = a_r} \{x \} \end{aligned}$ 。对于任意一个 $i < r'$ ，$(i, r')$ 与 $(i, r)$ 组成的数对本质相同。也就是说能产生贡献的 $i$ 只能在 $[r', r]$ 中。
2. 在 $[l, r - 1]$ 中有若干个位置，它们的值相同，与 $r$ 只能组成一对本质不同的数对。规定 $a_l, a_{l + 1}, \ldots, a_{i - 1}$ 中没有一个跟 $a_i$ 相同。这样数能做到不重不漏。
3. 最后要满足 $(i, r)$ 是逆序对，也就是 $a_i > a_r$ 。

一三两个条件长得像二维偏序。我们把上述这些条件转换为平面上的单点修改、矩形数点（求和）。把 $[l, r - 1]$ 中，从左到右数，第一次出现值 $a_j$ 的位置 $j$ （也就是 $a_l, a_{l + 1}, \ldots, a_{j - 1}$ 没有一个跟 $a_j$ 相同），以一个点 $(j, a_j)$ 加入到平面中。点 $(i, a_i)$ 只能出现在


$$
\boxed{\begin{matrix}
  &  (r, \infty) \\\\\\
(r', a_{r} +1) & 
\end{matrix}}
$$

莫队每转移一次，我们需要动态维护平面上的点，并矩形求和。单点修改、矩形求和没法做到两个的时间复杂度都是 $O(1)$ 。为降低转移的时间复杂度，我们考虑莫队二次离线。

### 莫队二次离线

（这道题的贡献没法拆开算，即 $r$ 对 $[l, r - 1]$ 的贡献不等于 $r$ 对 $[1, r - 1]$ 的贡献减 $r$ 对 $[1, l - 1]$ 的贡献）

以左端点为 $l$ ，右端点扩张为例。把上一节所说满足条件 2 的 $i$ ，作为点全部加入到平面中。比如说 $[l, r - 1] \to [l, r]$ ，平面上 $x$ 坐标大于 $r$ 的点不会影响到计算的贡献。进行矩形求和就能求出贡献。

扫描线，从 $n$ 到 1 ，扫的过程中动态维护平面上的点。扫到 $l$ ，就处理左端点为 $l$ 的转移（注意到扩张和收缩的贡献只有符号不同，可以一起算）。

我们要进行 $\Theta(n)$ 次单点修改，$\Theta(n \sqrt{m})$ 次矩形求和。需要一个单点修改时间复杂度 $O(\sqrt{n})$ ，矩形求和时间复杂度 $O(1)$ 的数据结构。由这个复杂度不难想到分块。

### 只有 $\Theta(n)$ 种矩形求和

下面要讲的分块依赖于这个性质。观察这个矩形。

$$
\boxed{\begin{matrix}
  &  (r, \infty) \\\\\\
(r', a_{r} +1) & 
\end{matrix}}
$$

$\infty$ 就当做是 $n$ ，本题的值域上界。平面上 $x$ 坐标为 $r$ 的点顶多就一个，特判这个点，把 $r'$ 换成 $r' + 1$ ，并把 $a_r + 1$ 换成 $a_r$ 。

$$
\boxed{\begin{matrix}
  &  (r, \infty) \\\\\\
(r' + 1, a_{r}) & 
\end{matrix}}
$$

所有点（平面上的点，矩形的端点）的 $y$ 坐标翻转过来。翻转：记 $\operatorname{rev}(x) = n - x + 1$。

$$
\boxed{\begin{matrix}
  &  (r, \operatorname{rev}(a_{r})) \\\\\\
(r' + 1, 1) & 
\end{matrix}}
$$

并写成差分形式。

$$
\boxed{\begin{matrix}
  &  (r, \operatorname{rev}(a_{r})) \\\\\\
(1, 1) & 
\end{matrix}}
-
\boxed{\begin{matrix}
  &  (r', \operatorname{rev}(a_{r'})) \\\\\\
(1, 1) & 
\end{matrix}}
$$

我们发现 $\Theta(n\sqrt{m})$ 个矩形求和本质上只有 $\Theta(n)$ 种。

### “离散化”

下面要讲的分块也依赖于这个性质。平面上出现过的点 $x$ 坐标互不相同，$y$ 坐标有相同的。我们考虑把 $y$ 坐标“离散化”，使得平面上出现过的点的 $y$ 坐标互不相同。这么做，前面的矩形求和就有了细微的差别，请读者自行思考 $(r, a_r)$ 和 $(r', a_{r'})$ 会不会被差分后的两个矩形包含。

具体讲下怎么离散化。开一个数组 $cnt$ ，$cnt[i]$ 记录 $i$ 在 $a$ 中出现了多少次。我们规定相同的值，位置越靠左离散化后的值越大。记离散化后的序列是 $a'$ 。统计完 $cnt$ 后，对 $cnt$ 求前缀和并存回 $cnt$ 。从 $n$ 到 1 扫，扫到 $i$ ，让 $a'_i = cnt[a_i]$ ，然后 $cnt[a_i] = cnt[a_i] - 1$ 。

```cpp
for (int i = 1; i <= n; ++i) {
    cnt[a[i]]++;
}
partial_sum(cnt + 1, cnt + n + 1, cnt + 1);
for (int i = 1; i <= n; ++i) {
    a[i] = cnt[a[i]]--;
}
```

### [二维分块](https://www.luogu.com.cn/problem/U210802)

需要维护的平面是 $n \times n$ 的，我们按如下方式进行分块：
1. 将平面分成 $\sqrt{n}$ 个 $n^{0.75} \times n^{0.75}$ 的橙块。
2. 每个橙块内再分成 $\sqrt{n}$ 个 $n^{0.5} \times n^{0.5}$ 个蓝块。

![](https://cdn.jsdelivr.net/gh/Cat-shao/MyPic2@main/orange.svg)

以橙块为单位维护二维前缀和，每个橙块内分别以蓝块为单位维护二维前缀和。

同时将整个平面横着分为一个个 $n \times n^{0.75}$ 的区域，每个区域中分成 $\sqrt{n}$ 个 $n^{0.75} \times n^{0.5}$ 的黄块。每个区域分别以黄块为单位维护二维前缀和。

![](https://cdn.jsdelivr.net/gh/Cat-shao/MyPic2@main/yellow.svg)

竖着分为一个个 $n^{0.75} \times n$ 的区域，每个区域被分成 $\sqrt{n}$ 个 $n^{0.5} \times n^{0.75}$ 的绿块。每个区域分别以绿块为单位维护二维前缀和。

![](https://cdn.jsdelivr.net/gh/Cat-shao/MyPic2@main/green.svg)

加入一个点时，需要更新 $O(\sqrt{n})$ 个以橙块、蓝块、黄块、绿块为单位的二维前缀和（将包含新增点的二维前缀和都加 1），因而加入一个点时间复杂度 $O(\sqrt{n})$ 。

这样分块空间复杂度 $O(n)$ 。

-------------------

如下图，一次求和的矩形可分为整块部分和散块部分。显然整块部分将对应橙块、黄块、绿块、蓝块维护好的二维前缀和累加，时间复杂度 $O(1)$ 。散块部分点分布稀疏，不能通过进一步分块解决，因为进一步分块 $O(n^2)$ 的空间是绝对开不下来的。

![](https://cdn.jsdelivr.net/gh/Cat-shao/MyPic2@main/query.svg)

考虑反向维护。前面说过虽然共有 $O(n \sqrt{m})$ 次矩形求和，但本质只有 $O(n)$ **种**矩形求和。每新增一个点求出它在哪几种矩形求和的散块部分中。

![](https://cdn.jsdelivr.net/gh/Cat-shao/MyPic2@main/purple.svg)

以散块中横着的部分为例。将 $y$ 坐标分为 $\sqrt{n}$ 块。

![](https://cdn.jsdelivr.net/gh/Cat-shao/MyPic2@main/y.svg)

横着的散块高度 $< n^{0.5}$ ，只会被分到一个块中。一个点只会被分到一个块中。加入一个点，枚举这个点所在块中的散块哪些覆盖这个点。

看似这么做是 $\Theta(n^2)$ 的。然而加入的点 $y$ 坐标互不相同，一个块内只会有 $O(\sqrt{n})$ 个点，也就是说每种散块至多被枚举 $O(\sqrt{n})$ 次。共有 $\Theta(n)$ 种散块，因此这么做是 $O(n\sqrt{n})$ 的。

矩形求和时，散块中有多少个点已经在加点的时候求好了，自然是 $O(1)$ 。

对于竖着的散块就对 $x$ 坐标分为 $\sqrt{n}$ 块，与横着的散块几乎一样。

在写代码的时候，如果直接将橙块边长设为 $n^{0.75}$ 并取整，蓝块边长设为 $n^{0.5}$ 并取整，会出现一个蓝块一半在一个橙块一半在另一个橙块。为方便写代码，可以将 $n$ 调整为 $\left \lceil n^{0.25} \right \rceil ^ 4$ ，保证了 $n^{0.75}$ 、 $n^{0.5}$ 都是整数，每个蓝块只在一个橙块中。


### 实现

[代码](https://www.luogu.com.cn/paste/4sziu1vs) | [双倍经验](https://www.luogu.com.cn/problem/P7601) | [LOJ 题目链接](https://loj.ac/p/6762) | [同样是二维分块 rcn](https://www.luogu.com.cn/problem/P7721)

如有错误麻烦大家指出。谢谢大家。以及评论区禁止无意义。