### 首先，我们来解决第一问。

有的同学初拿到这道题的时候想到二分，但是他们想不到如何去判断这个数目，因此在这道题上卡了许久，然后放弃去做了下一道题。~~既然这样，那就别做这道题了吧。~~

但凡~~学过一些数学~~的同学们应该都见过那道天平与砝码称重的题，那道题目启示我们，使用 $ 2^{0} $ , $ 2^{1} $ , $ 2^2 $ 等质量的砝码，可以使从 $1$ 到上限的所有质量都能被表示出来，且使用最少的砝码。

这个结论也可以运用到这题中来。
取 $t=\log_2 n + 1 $ ，这就是第一问的答案。

### 下面使用  dp  来求解第二问的答案。

不妨令取的数目 $x_1$ , $x_2$ $...$ $x_n$ 满足单调递增性，显然这不会影响结果。

设 $f_{i,j,k}$ 表示取了 $i$ 个，上一个为 $j$ ，总数为 $k$ 的方案数。

因为数目互不相同，故下一个硬币的数目至少为 $j+1$ ，又因为要能表示所有的数目，故下一个硬币的数目最大不能超过 $k+1$ ，若超过则 $k+1$ 就将无法被表示。

则状态转移方程为 $f_{i+1,t,k+t}=\sum\limits^{k+1}_{t=j} f_{i,j,k} $ 。

还有一个需要注意的点，就是当 $k+t>n$ 时要把状态转移方程中的 $k+t$ 改成 $n$ , 因为硬币的总价可以超过 $n$，这样处理便于统计答案。

至此本题即计算完毕。

下面就到了人们**喜闻乐见**的放代码时间：


```
#include<bits/stdc++.h>
using namespace std;
int n,T,f[20][1009][1009];
long long ans;
int main(){
	cin>>n;
	T=log2(n)+1;
	printf("%d ",T);
	f[1][1][1]=1;
	for(int i=1;i<T;i++)
	for(int j=i;j<=(1<<(i-1));j++)
	for(int k=i*(i-1)/2;k<(1<<i);k++)
	for(int t=j+1;t<=k+1;t++){
		if(k+t<=n)f[i+1][t][k+t]+=f[i][j][k];
		else f[i+1][t][n]+=f[i][j][k];
	}
	for(int i=1;i<(1<<T);i++)ans+=f[T][i][n];
	printf("%lld",ans);
	return 0;
}
```
