------------
解题思路：

首先考虑第一问，求最少要多少种钱币。

读题可知，每种钱币只有一枚。然后就可以想到二进制，即将钱币的值设为 $2^n$ ，将要表示的数转换为二进制，每一位表示是否用这个钱币。

对于其正确性，首先可以得出二进制一定可以表示出任何数。然后就是证明没有任何一种方法可以用比二进制更少的钱币数来表示出所有的估价。

考虑拿走 $2^n$ 然后证明其一定不能在只修改而不添加数的前提下表示出 2 到 $2^{n+1}-1$ 。首先在拿走 $2^n$ 之后，不做任何修改，那么之前的数一定无法表示 $2^n$ 到 $2^{n+1}-1$ 那么就一定要有一个数扩大到能表示这一区间，这里如果能，那么一定只能扩大 $2^{n-1}$ ，因为如果扩大别的数那么一定会出现不能表示比 $2^{n-1}$ 还小的某一些数，而且还会有“断层”（感性理解，即有在区间中有一小部分数无法表示，可以由二进制的性质导出）。那么在扩大了$2^{n-1}$之后，一定又会出现无法表示 $2^{n-2}$ 到 $2^{n-1}-1$的问题。以此类推，最终得到无法去除任何一个数的结论。

补充说明一下，如果区间没有正好到 $2^{n+1}-1$ ,那么就把这个改成区间的最大值，同样可以推出结论，因为依旧有一段无法表示，所以一定要改。（文字证明，有些表述不太严谨，望指出。）

这一段证明不少题解没有提及，这里做一个补充。

------------

然后是第二问：求有多少种方案。

这一问方法很多（仿佛和二进制还是有一点干系，但我太弱了，想不出来），其中我认为比较简单的是用 DP 来完成。

设 $f[i][j][k]$ 表示取到第 $i$ 个数，上一个数是 $j$ ，能表示的 1 到 k 中的所有数的方案数。（这里强制规定所取序列是递增的）那么对于一个新取的数 $l$ ，一定能表示 $l$ 到 $l+k$ 的所有数。由之前的限制可得 $j$ 至少为 $i$ ，$k$ 至少为 $\dfrac{i\times(i-1)}{2}$ ， $l$ 在 $j+1$ 到 $k+1$ 之间。（因为要保证每一个数都能表示）
 
然后转移 $f[i][j][k]=\sum_{l=i-1}^{k} f[i-1][l][k-l]$
换一种写法就是 $f[i][l][k+l]+=f[i][j][k]$。

-------------

代码：

```cpp
#include<cstdio>
using namespace std;
int n,n2,len,f[20][1005][1005],tot;
int main(){
	scanf("%d",&n);
	n2=n;while(n2){n2>>=1;len++;}
	printf("%d ",len);
	f[1][1][1]=1;
	for(int i=1;i<len;i++)
	for(int j=i;j<=(1<<(i-1));j++)
	for(int k=i*(i-1)/2;k<=(1<<i);k++)
	for(int l=j+1;l<=k+1;l++)
	if(l+k<n)f[i+1][l][k+l]+=f[i][j][k];
	else f[i+1][l][n]+=f[i][j][k];
	for(int i=1;i<(1<<len);i++)tot+=f[len][i][n];
	printf("%d",tot);
	return 0;
}
```

