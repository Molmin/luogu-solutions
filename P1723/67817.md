#### 前言

貌似这就是一个模板题？而且貌似数据范围没有给清楚。。

看到就进来了，发现manacher有点生疏了.....

#### 思路

就是manacher算法模板，转化为了多组数据。

在这里就讲一下manacher算法:

### 字符回文串算法

好了扯谈结束.

ＯＩ中一直有一个经典的问题，求回文子串。

然后大概有三种算法来解决这个问题：

+ 中心扩展法
+ 动态规划法
+ *Manacher算法*

这里讲的就是Manacher算法.

为什么上面两个它们不行？

第一个不能处理偶回文(找不到中心!)而且时间复杂度O($n^2$)，

第二个时间复杂度O($n^2$)，显然也不大行的样子

但是我们的*Manacher算法*，它的时间复杂度为O(n),并且可以适应奇回文和偶回文！这个算法大大滴好！

所以我们用Manacher 来解决问题.

### Manacher 算法

#### 算法思想：

将偶回文串转化为奇回文串，同时利用已经处理过的信息，借助对称(回文串具有对称的性质)来对当前处理的点进行扩展。

### 规定算法概念:

**定义**$R$是**当前扩展到的所有回文串的最右边界**

**定义**$pos$ 是右边界为$R$且**第一次**扩展到$R$的时候对应的中心点

**定义**$L$是$R$关于$pos$的对称点(也就是以$pos$为对称中心的回文串的左端点),$L = 2* pos - R$

**定义**$x$的*回文半径*是我们求到的以$x$为中心的最长回文串的左边界到$x$的长度,规定为$p[x]$

**定义**$i$是当前处理到的，要求以*$i$为中心的回文半径*

#### 算法流程:

第一步，先把偶回文转化为奇回文,这个的处理就是在原串的基础上，每两个字符中间加上一个奇奇怪怪的字符

放张图片:

[![BnH0Ug.png](https://s1.ax1x.com/2020/10/26/BnH0Ug.png)](https://imgchr.com/i/BnH0Ug)

你数一数是不是偶回文就变成了奇回文了呀?

细心的小伙伴已经注意到了,第一个加入的字符和最后一个加入的字符不一样　！这个是为了处理边界，后面会用到

第二步,对于新串中的每一个点求它们的回文半径.

按照前面的规定，我们现在知道了*$R$以及$pos$*，还有当前我们*要求回文半径的点为$i$*，同时显然$i > pos$，而且我们已经知道了扩展后的字符串的$i$前面字符的所有$p[j]$,$(0 <= j < i)$

**我们规定$i$关于$pos$对称的点为$i'$ , $i' = 2 * pos - i$**

然后**分情况讨论**:

### 以下内容为算法核心!!

+ $i$ < $R$:

那么$i'$就会大于$L$小于$pos$

$1.$如果$p[i'] + i <= R$，这就告诉我们，以$i'$为中心的回文串被包含在回文串$[L,R]$(也就是当前右端点最右的回文串).

那么因为$[L,R]$是一个回文串，这个串$[L,R]$ 就具有对称性，那么$p[i] = p[i']$

$2.$ 如果$p[i'] + i > R$,这就告诉我们，以$i'$为中心的回文串 *一定不是* 完全包含在回文串$[L,R]$中。

但是至少我们可以知道，以$i'$为中心的回文串包含在回文串$[L,R]$中间的部分，根据对称性,以$i$为中心的回文串的长度一定大于等于这部分,然后我们再进行暴力扩展.

综合上面两种情况，我们可以得到一条核心~~伪~~代码:
```cpp      
p[i] = min(p[i'],R - i + 1);//前面是代表的被完全包含的情况，后面则是没有被完全包含的情况，两种情况因为是求可行情况，所以是求min
```
$i'$实际代码是写成$2 * pos - i$

+ $i$ >= $R$

这没办法，前面的信息已经用不上了，暴力修改，同时更新$R$以及 $pos$,此时初始化$p[i]等于1$

核心~~伪~~代码:
```cpp
      while(str[i + p[i]] == str[i - p[i]])p[i] ++;
       // 这里就是暴力扩展，然后前面的伏笔边界处理就在此用上了，因为边界字符不同，所以我们不会把边界算进去
```

### 算法核心到此结束

然后就算法至此完结撒花了,给出算法核心代码:
```cpp
int manacher()
{
	int R = 0 , pos = 0 ,maxlen = 0;
	for(int i = 1 ; i <= lenstr ; i ++)
	{
		if(i <= R)
			p[i] = min(p[2 * pos - i],R - i + 1);
		else p[i] = 1;
		while(str[i - p[i]] == str[i + p[i]])p[i] ++;//暴力枚举
		if(i + p[i] - 1 > R)
		{
			R = i + p[i] - 1;
			pos = i;//更新Ｒ以及pos
		}
		maxlen = max(maxlen,p[i] - 1);//更新maxlen
	}
	return maxlen;
}
```

严谨时间复杂度证明: [这篇博客](https://segmentfault.com/a/1190000008484167)  翻到最下面

### Code

最后还是贴一下这个题完整代码(居然是蓝题......)


```cpp
#include <bits/stdc++.h>
using namespace std;
int n;
char a[1000005];
char s[2000005];
int p[2000005];
int main()
{
	cin >> n;
	for(int i = 1 ; i <= n ; i ++)
	{
		cin >> a + 1;
		int len = strlen(a + 1);
        //与模板一样
		for(int j = 1 ; j <= 2 * len + 1; j ++)
		{
			if(j & 1)
			s[j] = '#';
			else s[j] = a[j / 2];
		}
		s[0] = '&';s[2 * len + 2] = '*';
		int R = 0 , mid = 0,maxlen = -1;
		for(int j = 1 ; j <= 2 * len + 1; j ++)
		{
			if(j <= R)p[j] = min(p[mid * 2 - j],R - j + 1);
			else p[j] = 1;
			while(s[j + p[j]] == s[j - p[j]])p[j] ++;
			if(j + p[j] - 1 > R)
			{
				mid = j;
				R = j + p[j] - 1;
			}
			maxlen = max(maxlen,p[j] - 1);
		}
		cout << maxlen << endl;//输出最长长度
	}
	return 0;
}
```