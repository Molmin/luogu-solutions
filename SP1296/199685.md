这道题当然可以套四个循环，但是嘿嘿嘿。。。可能连样例都过不了。~~我没试过~~。

因此，根据（~~题目上的标签~~）英明的判断，我们会想到二分搜索。

这里再介绍一下二分，我是蒟蒻，可能解释的不到位，欢迎大佬补充。

二分就像我们小时候玩过的猜数字。如果你心里想一个数字，比如35，让别人来猜，一般都会先猜50（二分）。接着你会告诉他：“猜大了”，那么他就会猜25（二分）。然后你会告诉他：“猜小了”，那么他可能猜（（50+25）/2）。~~懒得算~~。 一直循环，直到猜中为止。
二分也一样，大概像这样
```
int mid;

	while(l<=r)
	{
		mid=(l+r)/2;//取中间的
		if(c[mid]<k) l=mid+1;//在右面找
		else if(c[mid]>k) r=mid-1;//在左面找
		else if(c[mid]==k) break;//找到了
					
	}

```
这段代码意思是在c数组里找k。
当然，二分搜索要求在范围内是单调的（一直增加或一直减少）

这道题当然可以用传统二分，就像上面。但是还有一个问题，就是如果出现下面这种情况

1 3 3 3 5

二分只能找到一个3，再做修改当然可以，但我觉得太过繁琐。这里可以用STL中的lower_bound和upper_bound，找到数组里第一个不小于目标值的指针和第一个大于目标值的指针。

下面我说一下具体思路：
首先将A与B合起来为c，C与D合起来为d（都是数组），（便于二分）。
接着sort排序，（便于二分×2。）
然后在d数组里找c数组中每一个元素的负值（加起来为0）。

下面上代码
```cpp
#include <bits/stdc++.h>
using namespace std;
int n,A[100000],B[100000],C[100000],D[100000],c[100000000],d[100000000];
int t=0,s=0,w;
void search(int k)
{
        int *g=lower_bound(c,c+s,k);//第一个不小于，返回值是一个指针，用法和sort类似。
        int *h=upper_bound(c,c+s,k);//第一个大于
        int q=h-g;//中间的都是相同的值，也要加上
        t+=q;
}
int main()
{	
    cin>>n;
    for(int i=0;i<n;i++)
    {
        cin>>A[i];
        cin>>B[i];
        cin>>C[i];
        cin>>D[i];
        
    }
    for(int i=0;i<n;i++)
    {
        for(int j=0;j<n;j++)
        {
            c[s]=A[i]+B[j];
            d[s]=C[i]+D[j];
            s++;
        }
    }
    sort(c,c+s);
    sort(d,d+s);
    for(int i=0;i<s;i++)
    {
        w=-d[i];
        search(w);
    }
    cout<<t;
 
 
} 
```
题解就是这样了，这是我第一遍题解，看在本蒟蒻这么辛苦，你们不点个赞吗？