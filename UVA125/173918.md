## 本蒟蒻又来给大家发题解啦。
可是不知道是我语文太差还是怎么的，我看翻译怎么也看不懂题，后来看样例才理解的。

```
题意解释：给你一个有向图（不一定有环），
让你求出x节点到y节点的路径个数。
如果有无数条就输出-1(有环)。
```
### ~~菜鸡解释~~

然而本蒟蒻根本不知道啥是 $Floyd$ 。

话说本蒟蒻看起来有点像 $dp$ 。

### 别担心,让我们一步一步来。

首先定义一个数组$50\times 50$的 $dp$ 数组，也是答案数组。
先全部初始化为$0$。

读入时，将$d_{a,b}$初始化为$1$。

并同时获取路口总个数。

接着开始 $k,i,j$ 循环。

为什么是三层？因为如果要从 $i$ 到$j$ ,可以先从 $i$ 到$k$ ,再从 $k$ 到 $j$ .

比如， $swl3992$ 要从合肥到上海，他可以先从合肥到南京（有三条路），再从南京到上海（有五条路）。也可以直接从合肥到上海（有两条路）。

注意：有前提，就是南京无法到合肥，上海无法到南京，上海无法到合肥，不然会形成环。

那么，根据乘法原理，总共就是$3\times 5+2=17$条路。

所以，珍贵的状态转移方程就是：  $d_{i,j}=d_{i,j}+d_{i,k}\times d_{k,j}$ .

### 那么问题来了，怎样处理环？

别担心，让我们再次进行 $k,i,j$ 循环。

如果自己可以到自己，那么就是形成了环（绕了一圈又回来了），那么只要有路径经过了这个节点，答案都是-1。

示例代码：
```cpp
//UVA125 Numbering Paths
//By swl3992
#include <bits/stdc++.h>
using namespace std;
int d[50][50];	//dp数组
int main()
{
	ios::sync_with_stdio(0);	//加速不用管
	int n;
	int T=0;	//第几个样例
	while(cin>>n)
	{
		memset(d,0,sizeof(d));	//初始化为0
		int x=-1;	//总共几个道路
		for(int i=0;i<n;i++)
		{
			int a,b;
			cin>>a>>b;
			x=max(x,max(a,b));	//max
			d[a][b]=1;	//初始化为1
		}
		for(int k=0;k<=x;k++)	//开始状态转移
		{
			for(int i=0;i<=x;i++)
			{
				for(int j=0;j<=x;j++)
				{
					d[i][j]+=d[i][k]*d[k][j];//转移方程
				}
			}
		}
		for(int k=0;k<=x;k++)
		{
			if(d[k][k])	//自己到自己
			{
				for(int i=0;i<=x;i++)
				{
					for(int j=0;j<=x;j++)
					{
						if(d[i][k]&&d[k][j])	//从i到j经过了k
						{
							d[i][j]=-1;
						}
					}
				}
			}
		}
		cout<<"matrix for city "<<T++<<endl;//题目要求的格式化输出
		for(int i=0;i<=x;i++)
		{
			cout<<d[i][0];	//先输出第0个，之后先输出空格再输出数。
			for(int j=1;j<=x;j++)
			{
				cout<<" "<<d[i][j];
			}
			cout<<endl;
		}
	}
	return 0;
}
```

