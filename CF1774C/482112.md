简单题吧这个。首先我们注意到这个问题要求算前缀的所有答案，那么说明你是扫一遍的过程中可以动态的得到当前的答案的，或者就是类似于 $\tt dp$ 的思路。

我们考虑怎么根据 $S_1S_2\dots S_{i-1}$ 得到 $S_1S_2S_3\dots S_i$ 的答案，这里显然得要 $\mathcal O(1)$ 才能胜任。

这里是计数，感觉有点麻烦。考虑对于满足什么条件的选手编号可以赢得总决赛。如果最后一场是大的赢，那么 $1$ 无论怎么样，他即使苟活到最后一轮，仍然会被任意一个人击败。

那么同理的我们也可以往前推，如果最后连续 $k$ 场都是大的赢，那么假如 $i\leq k$，那么它即使苟活到最后 $k$ 轮，也不可能连赢 $k$ 场：要连赢 $k$ 场至少要是 $k+1$ 才能连续击败 $1,2,\dots,k$ 获得胜利。

如果连续小的赢也是同理，有 $k$ 个人永远不能捧杯。

但是怎么证明 $k+1$ 一定可以和 $1\sim k$ 的所有数留下来呢？其实非常简单：只要让赛程不安排到他们，让剩下的人自相残杀，最后一定会留下一个人，但是它比较大。而因为我们刚刚的结论是是最长相同后缀，所以它前面一定是小的赢（或者空，如果是空则平凡），那么任意一个 $1\sim k+1$ 的人都卡可以轻松击败。

反过来同理。

所以你会发现，无论最后连续的是什么，只要计算最长全 $1$ 或全 $0$ 后缀的长度 $k$，答案就是 $i-k$。

那么回到最开始，连续最长相同后缀是可以动态的计算前缀答案的，也就是单次询问 $\mathcal O(1)$，所以这题就做完了。

```cpp
int solve() {
	int n = getInt();
	string s; cin >> s;
	s = "  " + s;
	int k = 1;
	cout << 1 << ' ';
	for(int i = 3; i <= n; i++) {
		if(s[i] == s[i - 1]) k++;
		else k = 1;
		cout << i - k << ' ';
 	}
 	puts("");
	return 0;
}
```