```c
#include<bits/stdc++.h>
using namespace std;
int n;
struct myq {
	int t1,t2;
} a[1005*1005];//定义一个结构体 
inline  bool cmp(myq x,myq y) {
	return x.t2<y.t2;
	//最开始打的是return x.t1<y.t1
	//后来在发现，其实排序之取决与结束时间
	//想要参加越多的比赛
	//理想数据情况(已经人为排好序)的话就是1~2，2~3,3~4,4~5......
	//那么觉定能否参加得是a[i-1].t2能否与a[i].t1对接上
	//很抽象，所以我举个栗子 
	//假设按照x.t1<y.t1排序，如果如见这样的数据呢？见下面
	//2~4,4~5，1~99999(有点夸张，不过不管怎样，只要有一个不满足就假设不成立)
	//那么排出来就是, 1~99999，2~4,4~5
	//这还怎么玩，后面两个比赛都在第一个比赛期间,只能参加一个 
	//而如果是x.t2<y.t2排序就是
	// 2~4,4~5,1~99999很明显参加2个，比第一种多
	//举个栗子就很清楚了把
	//其实很多时候，贪心排序都要在两个数据中选择，这个时候脑袋疼的话
	//就假设其中一种情况，然后举出特殊栗子，再用这个栗子用第二张数据排序看一下
	//最后比较一下，就可以了，非常没有科学依据的方法，但是一般都是正确的
	//方法很辣鸡，但是很实用 
}
int sum=1;
int j=1;
int main() {
	scanf("%d",&n);
	for(int i=1; i<=n; i++)
		scanf("%d%d",&a[i].t1,&a[i].t2);//输入嘛 
	sort(a+1,a+1+n,cmp);//排序 
	int flag=a[1].t2;//flag用于比较a[i].t1是不是>=a[i-1].t2; 
	while(j<=n) {
		j++;//开始 
		if(a[j].t1>=flag) {//满足条件就刷新，并且计算个数sun++； 
			sum++;
			flag=a[j].t2;
		}
	}
	printf("%d",sum);//输出 
	return 0;
}
```
