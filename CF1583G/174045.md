暑假的时候就有个初中同学把石头门给补了然后一直在吹，我寻思我要不要抽个空也把这玩意补了。

一个显然的事实是：每个不同的“已完成任务集合”只会出现一次。因为，你完成一个集合里的任务之后处于的时间点是确定的，那么如果你完成了同一个集合超过一次，你就永远走不出去了。

这个事实的一个直接推论是：所有可能出现的集合（下简称“合法集合”）之间存在一个偏序关系。每次集合发生变化会发生一次跃迁，那么只需要找到第一个包含目标集合（不一定是一个合法集合）的合法集合前面有多少个合法集合即可。

考虑什么样的集合是合法的。如果两个任务 $i$ 和 $j$ 满足 $a_i<a_j$ 且 $b_i<b_j$，并且一个合法集合包含 $j$，那么它一定也包含 $i$。因为，我完成 $i$ 的时候会把 $j$ 给撤销掉，并且如果我在哪一次跃迁把 $i$ 给撤销了，那 $j$ 一定也被撤销了。

称满足这个条件的集合为“准合法集合”。我们将要证明，准合法集合与合法集合是同一个东西。

首先我们定义一个准合法集合的“标准表示”：只保留这样的任务 $i$，使得集合中不存在 $a$ 和 $b$ 都比 $i$ 大的任务。由于这是一个偏序关系，我们显然可以得到，每个集合的标准表示都不相同。又，如果我们用区间 $[a_i,b_i]$ 表示任务 $i$，一个标准表示是若干个嵌套包含的区间，并且每个这样的集合都是某个准合法集合的标准表示。

我们考虑如何用两个标准表示确定对应的两个准合法集合之间的偏序关系。我们找出两个标准表示中最大的两个区间，若他们不相同，则其中 $b$ 大的一个在后面。因为，如果我要撤销掉这个 $b$ 大一点的任务，我必须要完成一个 $a$ 比它小的任务，那么这个任务必然在另一个准合法集合中。

同样，若这两个区间相同，我们可以取出两个标准表示中次大的区间再进行比较，这样一直继续下去。特别地，如果一个标准表示是另一个的子集，那么这个子集在它前面。如果我们把标准表示中所有区间的 $b$ 从大到小写下来，那么即是比较这两个串的字典序。

回到“准合法集合等价于合法集合”的证明。我们已经知道了前者包含后者，那么我们也可以写出任意合法集合的标准表示。考虑一个合法集合被完成后，我们所在的时间点是其最大的一个 $a$——也即是标准表示中最大的 $a$。

这个合法集合的下一个集合即是从这个时间一直走，走到第一个不在当前合法集合中的 $b$，然后完成这个任务。容易发现，这个集合的标准表示也是当前集合的标准表示的下一个标准表示，具体证明留给读者。这也就是说，对于一个合法集合，其下一个合法集合也是下一个准合法集合。这样，我们就证明了准合法集合等价于合法集合。

仿照将一个合法集合写成标准表示的方法，去掉目标集合中的可以被其他任务导出的任务，得到一个标准表示，容易证明这个标准表示对应的合法集合即是第一个包含目标集合的合法集合。那么现在问题容易地多：我们只需要计算这个标准表示前面有多少个标准表示即可。

考虑从左往右扫，扫到一个 $b$ 时若这个区间在目标标准表示中，我们考虑若它是某个比目标标准表示小的标准表示与目标标准表示的 lcp 的下一个区间，那么前者的这个位置的区间必然 $b$ 比当前区间小，并且 $a$ 比 lcp 的最后一个区间即当前区间在目标标准表示中的上一个区间要大。

那么我们扫到一个 $b$ 时在 $a$ 处将有多少个以这个区间开头的标准表示——这可以通过类似的方法用数据结构优化 dp 求出——加入到数据结构内。在扫到目标标准表示的某个区间的 $b$ 时，我们只需要在这个数据结构内查询后缀和即可。容易发现，这样我们不会统计目标标准表示本身，但统计了本不应该被统计的空集，因此得出的答案是正确的。

至此，问题在 $O(n\log n)$ 时间内得到完整解决。
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
inline ll readint(){
	ll x=0;
	bool f=0;
	char c=getchar();
	while(!isdigit(c)&&c!='-') c=getchar();
	if(c=='-'){
		f=1;
		c=getchar();
	}
	while(isdigit(c)){
		x=x*10+c-'0';
		c=getchar();
	}
	return f?-x:x;
}
const int maxn=2e5+5;
int n,a[maxn*2],b[maxn],t;
bool v[maxn*2];
int lst[maxn*2];
const ll mod=1e9+7;
inline int lowbit(int x){
	return x&-x;
}
ll c[maxn*2];
void modify(int x,ll k){
	while(x){
		c[x]=(c[x]+k)%mod;
		x-=lowbit(x);
	}
}
ll query(int x){
	ll s=0;
	while(x<=n*2){
		s=(s+c[x])%mod;
		x+=lowbit(x);
	}
	return s;
}
ll f[maxn*2];
int main(){
	#ifdef LOCAL
	freopen("in.txt","r",stdin);
	freopen("out.txt","w",stdout);
	#endif
	n=readint();
	for(int i=1;i<=n;i++){
		int x=readint();
		b[i]=readint();
		a[b[i]]=x;
	}
	t=readint();
	for(int i=1;i<=t;i++) v[b[readint()]]=1;
	int l=0;
	for(int i=n*2;i>0;i--) if(v[i]){
		if(a[i]<l) v[i]=0;
		else{
			lst[i]=l;
			l=a[i];
		}
	}
	for(int i=1;i<=n*2;i++) if(a[i]){
		f[i]=(query(a[i])+1)%mod;
		modify(a[i],f[i]);
	}
	ll ans=0;
	memset(c,0,sizeof(c));
	for(int i=1;i<=n*2;i++) if(a[i]){
		if(v[i]) ans=(ans+query(lst[i]+1)+1)%mod;
		modify(a[i],f[i]);
	}
	printf("%lld\n",ans);
	#ifdef LOCAL
	fprintf(stderr,"%d\n",(int)clock());
	#endif
	return 0;
}
```