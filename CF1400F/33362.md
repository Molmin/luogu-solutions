官方题解看懂了，但是想不到一个高效的构造方法，所以放弃。（还是菜，~~虽然后来发现暴力就能过~~

翻了一下提交记录学到了另一个做法。

我们考虑 DP，设$f[i][mask]$表示当前已经到了第$i$个位置，前缀和表示为$mask$时向后的最小删除个数。

这样的转移方法就是枚举当前位置选或不选，然后往把一个位置的 DP 值拿过来即可。

然后判断前缀和是否合法也很简单，先判断前缀和中有没有$x$（大于$x$的前缀和已经全部可以删掉了），如果有再判断有没有前缀和是$x$的约数的。

但是很明显这种方法会有反例，但是我们发现其实如果出现$x$的约数的话，那么前缀和中比这个约数大的（也就是在前缀和中构成这个约数之前的数）可以全部删掉了，这样的话正确性得到了保证，还减少了状态数。

但是这样的话粗略上界是$O(n\cdot d)$（其中$d$为有效的状态数）的，看起来很不能过的样子。

但是本题的性质保证$d$不会很大（更加准确一些的说，是不会超过$5000$），所以这种做法能够通过。

存储状态的话直接用 unordered_map 就可以了。

代码：[My Blog](https://www.cnblogs.com/withhope/p/13574978.html)