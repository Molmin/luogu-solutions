估计是出题人觉得简单才放在 T2 的，但思路虽然明了很有可能想错。

赛时想法：

- 好像很不好做，但留一个空栈，钦定 $2(n-1)$ 个不同元素每个栈放两个，就能做 $k=2n-2$ 了。
- 发现 $k=2n-1$ 会有新的数加进来冲突。手玩发现有两种情况需要新的数必须放在某个栈顶或者新的数必须放在空栈，最后才能消空。
- 然后分类讨论怎样才能让若干轮后再消出一个空栈，这部分想的最久，最后还假了。

实际上要理清思路，尽量让新加的数**影响最小**的方向讨论。

设新的数是 $x$。如果新的数堵住了一个栈顶那么来一个这种栈顶就 GG 了。堵住了空栈那么来一个栈底的就 GG 了。

观察到**堵住空栈的影响更大**，于是考虑下一个出现的 $x$ 和下一个出现的某个栈底，如果下一个出现的是 $x$ 那么可以放空栈里，没影响到栈底。

如果某个栈底先出现，设这个栈底为 $u$，栈顶为 $v$。考虑到下一个 $u$ 出现时 $v$ 出现的次数：

如果 $v$ 出现了偶数次，把 $x$ 丢在栈顶，后面来的 $v$ 都丢在空栈里，最后空栈会空出来。

如果 $v$ 出现了奇数次，把 $x$ 丢在空栈，后面来的 $v$ 丢在栈顶，这样栈底来的时候 $v$ 已经被奇数个 $v$ 干掉了，可以直接丢进栈里面。

模拟上述过程即可，可以做到 $O(n+m)$。