首先操作次数的限制 $2m$ 可以完全不用管，因为 $1$ 操作只会进行 $m$ 次，而 $2$ 操作只要不进行无效的最多 $m\over2$ 次。

当卡牌种类 $k= 2n-2 =2(n-1)$ 时，可以把所有卡牌两两分组，让前 $n-1$ 个栈各属于两种卡牌，最后一个栈空着，称为特殊栈。

这样对于某个栈，来一个属于该栈的卡牌时，若和底部卡牌相同就利用特殊栈进行 $2$ 操作，否则就直接放上去。这样可以保证每时每刻，前 $n-1$ 个栈的卡牌个数不超过 $2$ 。

当 $k=2n-1$  时，此时会出现一种情况：$n-1$ 个栈都包含 $2$ 个卡牌了，此时又来最后一种卡牌。

设该卡牌为 $w$，找到 $n-1$ 个放满的栈中底部卡牌之后最先出现的栈 $x$ ，$x$ 栈底设为 $u$，栈顶设为 $v$，分下面三种情况讨论：

- 若 $w$ 的下一次出现时间早于 $u$ ，那么可以 $w$ 直接放到特殊栈（因为特殊栈的作用是消除底部，在 $u$ 下次出现之前都不会用到特殊栈）
- 若 $u$ 下次出现时间早于 $v$ ，那么可以把 $w$ 放到 $x$ 顶部（虽然此时栈内会有 $3$ 个卡牌导致中间的 $v$ 无法消除，但是 $u$ 会早于 $v$ 离开）
- 剩下的情况意味着下次出现的时间是 $v<u<w$ ，那么可以把 $w$ 放到特殊栈，然后规定接下来的特殊栈改为 $x$ （很明显在 $x$ 清空之前，都不会存在 $2$ 操作，所以没影响）

实现起来有很多细节，最开始写的 $O(mn)$ 的暴力版本跑了官方数据居然也能拿 $95$ 分，只会有一组数据超时。

优化成 $O(m)$ 要注意几个点：

- 需要一个数组维护每个卡牌当前所在栈的编号

- 需要一个队列来分配每个新来的卡牌属于哪个普通栈的，初始每个普通栈能提供两个空位，卡牌出栈会归还空位
- 查找下一个最先出现底部元素的栈，可以暴力往后找，因为下一次再出现放满栈的局面一定在底部元素出栈后（若是第一种情况 $w$ 先出，就循环到下个 $w$ 结束）。这样所有暴力找的部分不会有交叉，总循环次数不超过 $m$


[采用完全 STL 实现，写了 $90$ 多行，点我查看](https://www.luogu.com.cn/paste/p9kp120t)