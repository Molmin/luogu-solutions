### **题目简述**

给定 $n$ 对照片， $Alice$ 与 $Bonnie$ 轮流取照片，每对照片只有取了第一张才能取第二张。

同时每对照片有四个权值 $a_1$ $b_1$ $a_2$ $b_2$，分别表示第一张照片对 $Alice$ 与 $Bonnie$ 的价值与第二张照片对上述二人的价值。

两人都以最优策略行动，且每回合可取可不取，两人都不取游戏结束。
求 $Alice$ 能得到的价值与 $Bonnie$ 能得到的价值的差的最大值。

### **思路简述**

考虑每一对照片：

①
若 $a_1 + b_1 >= a_2 + b_2$

显而易见 $a_1 - b_2 >= a_2 - b_1$

此时显然 $Alice$ 取照片 1 比取照片 2 优秀，因为若 $Alice$ 取了照片 1，则 $Bonnie$ 只能取照片 2，此时权值之差大于 $Alice$ 取照片 2 的情况。

对于 $Bonnie$ 而言 $b_1 - a_2 >= b_2 - a_1$ ，因此 $Bonnie$ 的最优策略也是先取照片 1.

②
若 $a_1 + b_1 < a_2 + b_2$ 并且 $a_1 > b_2$

我们得到 $a_1 - b_2 < a_2 - b_1$ 与 $b_1 - a_2 < b_2 - a_1$

对于这种情况显然两人不会先取照片 1。

然而若游戏进行到某一时刻，当双方都没有最优情况可取， $Alice$ 仍然会选择取照片 1，因为 $a_1 - b_2 > 0$ 这样取能使差值变大。

考虑 $Bonnie$ ，变式得到 $b_2 - a_1 > b_1 - a_2$

我们知道 $a_1 > b_2$ 因此右边的值为负数，所以如果 $Bonnie$ 取了照片 1，则差值一定变大，因此 $Bonnie$ 不论如何都不会取照片 1.

因此这种情况对答案的贡献为 $a_1 - b_2$

③
若 $a_1 + b_1 < a_2 + b_2$ 并且 $b_1 > a_2$

分析同上，对答案的贡献为 $a_2 - b_1$

④
若 $a_1 + b_1 < a_2 + b_2$ 并且 $a_1 <= b_2, b_1 <= a_2$
经过分析可以知道：

$a_1 - b_2$ 与 $b_1 - a_2$ 均 $<=0$，因此这对照片可以直接忽略。

现在我们把情况简化到了只有一种。

考虑如何处理情况 1

对于一张照片 $i$ ，若 $Alice$ 取了这张照片，那么对答案的贡献为 $a_i$

反之对答案的贡献为 $-b_i$

考虑怎么综合这两种情况。

我们把一张照片的权值变为 $((a_i + b_i) / 2,(a_i + b_i) / 2)$，并且给一开始的答案加上 $(a_i - b_i) / 2$

这样处理，显而易见，若 $Alice$ 取了这张照片，贡献为 $(a_i + b_i) / 2 + (a_i - b_i) / 2 = a_i$
若 $Bonnie$ 取了，贡献为 $(a_i - b_i) / 2 - (a_i + b_i) / 2 = -b_i$

这样一来，每一张照片对于 $Alice$ 与 $Bonnie$ 就是等价的。

考虑对所有照片进行排序，由于我们按照 $(a_i + b_i) / 2$ 进行排序 与 按照 $a_i + b_i$ 进行排序结果是相同的，因此我们可以省掉除去的 2 ，节省可能的浮点运算。

因为 $a_1 + b_1 >= a_2 + b_2$，所以我们如果按从大到小排列好的照片序列取照片，一定满足先取了某一对照片中的第 1 张再取第 2 张。因此我们可以直接贪心地选取，让 $Alice$ 取最大的， $Bonnie$ 取次大的，一直这样取下去。如此一来，我们在累积答案的时候就可以忽略浮点数，让答案直接加上符合第 1 种情况照片对上每张照片的 $a_i$ ，当 $Alice$ 取的时候答案不加上 $a_i + b_i$ , $Bonnie$ 取的时候减去 $a_i + b_i$ 即可.

标程为从小到大排序，由于照片成对出现，所以把第奇数张都给 $Bonnie$ ，偶数张都给 $Alice$ (由于权值最大的照片排序后是第偶数张)

### **AC代码**
```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <iostream>
#include <cmath>

using namespace std;

int seq[200050];
int cnt,n;

int main()
{
	int a1,b1,a2,b2;
	scanf("%d",&n);
	long long ans = 0;
	for(int i = 1;i <= n; ++ i)
	{
		scanf("%d%d%d%d",&a1,&b1,&a2,&b2);
		if(a1 + b1 >= a2 + b2)
		{
			seq[++cnt] = a1 + b1;
			seq[++cnt] = a2 + b2;
			ans += a1 + a2;
		}
		else if(a1 > b2)
			ans += a1 - b2;
		else if(b1 > a2)
			ans += a2 - b1;
	}
	sort(seq + 1,seq + 1 + cnt);
	for(int i = 1;i <= cnt;i += 2)
		ans -= seq[i];
	printf("%lld\n",ans);
}
```



  [1]: https://cn.vjudge.net/problem/CodeForces-725F