
[AGC019D](https://www.luogu.com.cn/problem/AT_agc019_d)

## 思路

分讨是好习惯。观察到 $n \le 2000$，所以直接大力分讨再进行一个枚举即可。

假设串 $B$ 没有 ``1``，进行特判即可，那么接下来我们就可以直接讨论串 $B$ 至少有一个 ``1`` 的情况了。

前两个操作可以把串 $A$ 左右移动，则设 $A$ 最终的状态为向右移动 $k$ 位。（当 $k$ 为负时，即向左运动）

考虑最坏的情况，就是串 $A$ 的每一位都与串 $B$ 不同，需要进行 $n$ 次取反操作，然后再把取反后的串 $A$ 移到串 $B$ 对应的位置。这是基于移动的，所以可以证明 $k\in\begin{bmatrix}1-2n,2n-1\end{bmatrix}$。这样就可以对 $k$ 进行枚举了。

对于取反操作的限制条件，可以预处理出 $2$ 个值：至少要右移 $r_i$ 位才能在到串 $B$ 中找到一个满足 $B_i = 1$ 的和至少要左移 $l_i$ 位才能在到串 $B$ 中找到一个满足 $B_i = 1$ 的。

设走过的区间端点 $L,R$，若 $L \le l_i$ 或 $r_i \le R$，那么处理 $A_i$ 时在移位过程中就可以取反，不需要格外的移位。(即：多一次操作)

不满足条件的点需要额外的移位操作，记录下 $\left| L-l_i \right|$ 和 $\left| r_i-R \right|$。因为要最小的移动又要包含所有的区间，所以要取最大的区间边界，为了方便统计，我们先对 $\left| L-l_i \right|$ 这一维排序，使得对于每个 $i$ 的前缀最大，再处理一个后缀最大的 $\left| r_i-R \right|$，合起来就是所求的，取最小值即可。

这里答案要 $\times 2$ 的，因为一来一回嘛……

最终时间复杂度 $\mathcal{O(n^2 \log n)}$。

此外，需要注意的是，在判断 $A_i$ 和 $B_i$ 是否相同时要注意，由于 $k$ 可能是负数，所以在取模的时候要小心出现负下标。

代码可读性差就不放了。