如果T小一点点的话,我们可以轻易想到DP方程

DPN[p][b][t]代表走到p上一步在d走了t步的方案数

DPN[p][b][t]=sum(DPN[b][\*][t-1]) 其中$*\neq p$且存在边$b\rightarrow p$

对于边界我们要额外加一个虚点Ws,其中DPN[B][Ws][0]=1

我们发现t是一个天然的时间轴，DPN[\*][\*][t]都能从DPN[\*][\*][t-1]推导而来

所以可以把原式当成t次递推式，然后就可以想办法用矩阵乘法优化啦

根据递推式可以得到一个$N^2$长宽的矩阵，很明显不现实

我们发现边很少，所以可以把不存在边的二元组去掉，就等价于楼下把一个边切割成两个状态,分别表示刚刚经过这个边到起点或到终点的状态

以及还需要一个虚点$Ws\rightarrow B$的虚边，并把起始矩阵这个状态设为1

最后矩阵乘完统计答案时，对于每个到A的状态都会对答案有贡献

还有注意，如果A=B的话那个Ws到B的虚边也要加上

总复杂度是 $O((2M+1)^2*log_2T)$

完全没必要加读入优化，复杂度不算低 最后一个点卡常，矩乘函数加一个inline才勉强A掉

代码就不直接贴上，上[链接](http://pastebin.ubuntu.com/25387000/)吧
