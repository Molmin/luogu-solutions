萌新的第一篇题解qwq

我们先看题目哦

## 题目描述

定义一个函数 $\operatorname{f}(x,y)=(x|y)-y$。

给定一个长度为 $n$ 数列 $a$，定义 
$$\operatorname{f}(\operatorname{f}..\operatorname{f}(\operatorname{f}(a_1,a_2),a_3),...a_{n-1}),a_n)$$

为这个数列的值。

现在，请你将数列改变一种顺序，使得最后的值最大。
输出你改变后的数列。

translate by @[ShineEternal](https://www.luogu.com.cn/user/45475)。

## 题解

这题打眼一看，好嘛，又是烦人的位运算。该咋整呢？

看看样例先。

### 样例

#### 输入1

```
4
4 0 11 6
```

#### 输出1

```
11 6 4 0
```

### 分析

既然是位运算，我们就把这些烦人的数字变成二进制再来看吧～

输入为： `100 0 1011 110`

如果我们直接对这个序列进行操作会变成什么样呢？

$$
\begin{aligned}
f(100, 0) &= (100 | 0) - 0 &=& 100 - 0 &=& 100\\
f(100, 1011) &= (100 | 1011) - 1011 &=& 1111 - 1011 &=& 100\\
f(100, 110) &= (100 | 110) - 110 &=& 110 - 110 &=& 0
\end{aligned}
$$

最后的结果是 `0`。

那对输出的结果进行操作会怎么样呢？

$$
\begin{aligned}
f(1011, 110) &= (1011 | 110) - 110 &=& 1111 - 110 &=& 1001\\
f(1001, 100) &= (1001 | 100) - 100 &=& 1101 - 100 &=& 1001\\
f(1001, 0) &= (1001 | 0) - 0 &=& 1001 - 0 &=& 1001
\end{aligned}
$$

我们可以发现！其实这个 `f(x,y)` 就是把 `x` 的二进制里面，抠掉 `y` 的二进制！

比如，`f(11,6) => f(1011,110)`，从 `1011` 里面抠掉一个 `110` ，最后就得到了 `1001`！

其实 `f(x,y)` 就相当于 `x & ~y`，当然这都是后话了。

---

好了，函数的本质了解了，那么对整个序列的操作其实也就是

$$
\operatorname{f}(\operatorname{f}..\operatorname{f}(\operatorname{f}(a_1,a_2),a_3),...a_{n-1}),a_n) = \operatorname{f}(a_1,(a_2|a_3|\dots|a_n))
$$

即从第一个数字的二进制中抠掉后面所有数字的二进制。

也容易得知，最后的结果跟 除第一个数字外 其它数字的顺序是无关的。

那么，我们只需要让第一个数字最大（**含有最高二进制位的**）就好了嘛？

（其实这样子是不对的

如果样例是 `2 4 5` 呢？

把 `5` 放到前面的话，

`f(f(5,2),4)->f(f(101,10),100)=f(101,100)=1`

但是最大值其实是

`f(f(2,4),5)->f(f(10,100),101)=f(10,101)=10`

为什么，为什么会变成这样子呢？

因为`4`和`5`有共同的最高位啊！这个最高位会被抠掉的啊！

那么该怎么办呢？

答案是：让**含有最高且唯一的二进制位**的数字到最前面就好啦。

上代码。

### 代码

```cpp
#include <iostream>
#include <algorithm>
const int maxn = 1e+5 + 5;

int main()
{
	int n, a[maxn];
	std::cin >> n;
	for (int i=0; i<n; i++) std::cin >> a[i];
	for (int i=30; i>=0; i--)	// 从第31位开始向下搜索
	{
		int t = 1 << i, count = 0, idx=0;
		for (int j=0; j<n; j++)
			if (a[j] & t)	// 判断数字是否含有这一位
			{
				idx = j;
				count++;	// 统计含有该位的数字个数
			}
		if (count == 1)		// 如果只有一个，跟第一个数字交换，break
		{
			std::swap(a[0], a[idx]);
			break;
		}
	}
	std::cout << a[0];
	for (int i=1; i<n; i++) std::cout << ' ' << a[i];
	return 0;
}
```

就酱啦～