 模拟水题。。

题意：呃呃，就不说了，自己翻译（~~什么？叫我来翻译，好吧~~）

一个小而骄傲的公司的名字由N小写的英文字母组成。该公司已决定尝试重新品牌化-一个积极的营销策略，其中包括一系列措施来改变品牌（无论是对公司和其生产的产品）或其组成部分：名称，标志，口号。他们决定以这个名字开头。

为此，公司先后聘请了M设计人员。一旦一个公司雇佣了第i个设计师，他立即为创建一个新的公司名称做出贡献：他取名字的最新版本并替换所有的字母x【i】变为y【i】,y【i】变为x【i】

…在最后一个设计师的工作之后，名字的版本变成了公司的新名称。

Arkady经理最近在这家公司找到了一份工作，但是他已经沉浸在团队合作精神中，并且非常担心品牌重塑的成功。自然而然地，他迫不及待地想知道公司会收到什么新名称。

满足Arkady的好奇心，告诉他名字的最终版本。

（~~大概就是这样了，翻译过后，吐了一口老血~~）

------------

 是不是很简单，很轻松，想着暴力模拟做出来

 那你就昏头了，看数据范围没有？(1<=n,m<=200000) 
**如果你纯模拟的话，要用好多好多（~~我不是算不来，给你们点机会，自己算~~）的时间**

 所以我们的优化就来了

**反正都是换，你一直换，和最后换没什么区别，是不是听起来很有道理 **

**所以，干脆创一个数组来存贮每个字母最后的变化 **

**这样就把O（n*m）的算法，变成了O（n+m），是不是很神奇？**

最后，贴代码

```cpp
#include<cstdio>
#include<iostream>
#include<algorithm>
using namespace std;
int n,m;
char f1[27],f2[27],s[200000],a,b;
int main()
{
    scanf("%d%d",&n,&m);
    scanf("%s",s);//读入
    for(int i=0;i<26;i++)
        f1[i]=i+'a';
    while(m--)
    {
        scanf(" %c %c",&a,&b);
        swap(f1[a-'a'],f1[b-'a']);//交换交换字母的值
    }
    for(int i=0;i<26;i++)
        f2[f1[i]-'a']=i+'a';//替换
    for(int i=0;i<n;i++)
        printf("%c",f2[s[i]-'a']);//输出
    return 0;//完美的结束
}
```
**(~~短小精干对不对？~~）**