努力努力再努力的䒛夢他又来了，

今天的我依旧在写题解
 
 # 题意
 给你 $n$ 个顾客，你一天一共是 $l$ 小时，每次休息是连续 $a$ 个小时不能停，停了就废了，每个顾客再 $ti$ 来，待 $li$ 小时,求一下能休息几次。
 # 思路
 首先看到这题的时候吧，我是第一时间以为是贪心的
 做完发现不对，$ti+li<=ti+1$ 已经保证了我们的数据范围不会卡重，就与贪心并没有任何关系。
 
 我们就是只要把区间空隙留出来就行。
 
 **例如第一个样例**
 
 0表示空闲，1表示顾客来了
 
 0 1 1 0 0 0 0 0 0 0 0 0
 
 可以看出来，从第二秒之后就有大把的时间用来休息，
 一共有九秒时间用来休息，$9/a=3$ 所以输出了3。
 
 在中间一部分空闲时间判断能否休息，在判断最开始和最后能否休息，能就增加次数。
 
 # 代码附上
 ```
 #include<iostream>
#include<cstdio>
using namespace std;
int l,a,n,ans=0;
struct node{
	int t,l;
}v[100100];
int main()
{
	scanf("%d%d%d",&n,&l,&a);
	for(int i=1 ; i<=n ; ++i)
		scanf("%d%d",&v[i].t,&v[i].l);
	v[0].t=0;//将开始时间设为0
	v[0].l=0;
	for(int i=1 ; i<=n ; ++i)
		ans=ans+(v[i].t-v[i-1].t-v[i-1].l)/a;//判断每一次能否休息
	ans+=(l-v[n].t-v[n].l)/a;最后再加一遍结尾的时间
	printf("%d",ans);
	return 0;
}
 ```
 完结撒花