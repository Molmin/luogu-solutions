同样是暴力全排列做法，不过自认为比楼上的更加简洁易懂。

在全排列的时候，可以不必将使用顺序用字符串存储，而可以用数组代替，其中数组的值为 $1$ 时，则代表使用 $a$，值为 $0$，使用 $b$，同时，也可以以此作为判断时寻找 $a$、$b$ 长度的指针，代码参考如下：


```cpp
int a[2],x[6] = {0,0,1,1,1,1}
//其中a[0]为题目输入中的a，a[1]为b
//a[x[i]]即为当前循环到的需用长度
```

这样就可以直接使用 STL 中的 `next_permutation`，而不必自己再重新写一个函数代替了。

还要再提一下的是判断全排列结束的方法，全排列结束时 $x$ 数组必为 `111100`，所以若 $x$ 数组最后两位都是 $0$时，全排列结束；或是通过计算得出共有 $15$ 种全排列，直接通过 $1$ 到 $15$ 的循环结束也行。

代码：

```
#include <bits/stdc++.h>
using namespace std;
int n,a[2],x[6] = {0,0,1,1,1,1},ans = 7,T = 15;
int main()
{
	cin >> n >> a[1] >> a[0];
	while(!(x[4] == 0 && x[5] == 0))
    //这里还能写while(T--) 
	{
		int sum = 1,cnt = 0;
		for (int i = 0; i < 6; i++)
			{
				if (cnt + a[x[i]] > n) cnt = a[x[i]],sum++;
				else cnt += a[x[i]];
			}
		ans = min(sum,ans);	
		next_permutation(x,x + 6);
	}	
	cout << ans;
	return 0;
}
```

若有问题可在评论区中提出或是私信。