出题人就不会取模吗？

虽然但是，这不影响这是一道好题。

## 题目简述

> - 询问有多少长度为 $n$ 的**自然数**数列 $a_1,a_2,\dots a_n$ 满足一下条件：
> - - 对任意的 $i$ 都有 $0\leq a_i\leq b_i$。
>   - $a_1 ⊕a_2⊕a_3⊕\dots⊕a_{n-1}⊕a_n=0$。
>   - $a$ 不全为 $0$。
> - 原题 $n\leq 50$。实际上可以做到 $n\leq 10^6$，只要取个模即可。

## 解题思路

首先条件 $3$ 只要满足前两个条件后输出 $ans-1$ 即可。

然后注意到 $a_i\leq b_i$ 这个条件，很自然的可以想到数位 dp。但是我们要记录每一位的是否顶到，时间复杂度是大于 $O(2^n)$，连原题都过不去。

注意到数位 dp 的过程，不难发现对于一个二进制下是 $\texttt{101110}$ 的数，数位 dp 会把它拆成 $\texttt{0?????},\texttt{100???},\texttt{1010??},\texttt{10110?},\texttt{101110}$。其中 $\texttt ?$ 表示随便选取的位。

观察一个例子，我们对  $\texttt{10???},\texttt{001??},\texttt{111??},\texttt{0100?}$ 当中的 $\texttt ?$ 随便选取使得其异或为 $0$ 的方案数，我们不难想到固定 $\texttt{10???}$ 为**自由元**，对于其他三个数**随意选取**当中的 $\texttt ?$ 即可。因为 $\texttt{10???}$ 后缀的 $\texttt ?$ 很多，所以我们总能调整它使得整体的异或为 $0$。

这启示我们，对上面这类型的问题，我们只需要取后缀 $\texttt ?$ 最多的元素作为自由元即可，其他元素就可以自由选取了。

本题是类似的，原题的数据范围很小，甚至可以直接把每个数拆成数位 dp 的形式，然后枚举每个数作为自由元的贡献，时间复杂度是 $O((n\log V)^2)$ 的。显然还可以枚举自由元的长度再去跑一遍 dp，可以做到 $O(n\log V)$。

## 具体实现

枚举自由元的长度 $i$，维护 dp 数组 $f[i][j][k]$ 表示前 $i$ 个数当中，是否有自由元，并且第 $i$ 位当前的异或。 

那么每个数 $a_j$ 有两种情况：

- $a_j$ 在第 $i$ 位是 $0$：那么它肯定不是自由元，它只有 $a\ \text{and}\  (2^n-1)$ 的贡献给 $f[j][k][t]$ 自己转自己。
- $a_j$ 在第 $i$ 位是 $1$：那么它可以是自由元，枚举两种情况，第一是 $a_j$ 是自由元，那么他是没有贡献的，只能把 $f[j-1][0][]$ 转移到 $f[j][1][]$，第二是 $a_j$ 不是自由元，那么我们只要枚举 $a_j$ 第 $i$ 位的选取情况即可。

需要注意的是可能超过 $i$ 位的部分本身异或就不是 $0$，这样子不能加入答案。

上面的 $f$ 的转移都比较长，具体的可以见代码：

```cpp
const int MAXN=55;
int n;ull a[MAXN];
ull f[MAXN][2][2],ans;
int main(){
	cin>>n;
	for(int i=1;i<=n;i++) cin>>a[i];
	for(int i=31;i>=0;i--){
		memset(f,0,sizeof(f));
		f[0][0][0]=1;int flag=0;
		for(int j=1;j<=n;j++){
			flag^=(a[j]>>i+1);
			if(a[j]>>i&1){
				f[j][0][1]=f[j-1][0][0]*((a[j]&((1<<i)-1))+1);
				f[j][0][0]=f[j-1][0][1]*((a[j]&((1<<i)-1))+1);
				f[j][1][0]=f[j-1][0][0]+f[j-1][1][1]*((a[j]&((1<<i)-1))+1)+f[j-1][1][0]*((1<<i));
				f[j][1][1]=f[j-1][0][1]+f[j-1][1][0]*((a[j]&((1<<i)-1))+1)+f[j-1][1][1]*((1<<i));
			}else{
				f[j][0][1]=f[j-1][0][1]*((a[j]&((1<<i)-1))+1);
				f[j][0][0]=f[j-1][0][0]*((a[j]&((1<<i)-1))+1);
				f[j][1][0]=f[j-1][1][0]*((a[j]&((1<<i)-1))+1);
				f[j][1][1]=f[j-1][1][1]*((a[j]&((1<<i)-1))+1);
			}
		} 
		if(!flag) ans+=f[n][1][0];
		if(!flag&&i==0) ans+=f[n][0][0];
	}
	cout<<ans-1;
	return 0;
}
```

 