## 前言

本题的所有做法均在将区间端点坐标离散化至 $O(n)$ 级别后进行，并在复杂度分析中认为 $n,m,l_i,r_i$ 同阶．

## 做法 $\textbf 1$

我会暴力！

分析题意，可以发现 $2$ 操作就是在判断有向图两点可达性，而 $1$ 操作是加边．

我们只要暴力加 $O(n^2)$ 条边，然后查询操作的时候暴力 DFS 判断是否连通就可以了！

时空复杂度：$O(n^2)$，显然不能通过此题．

## 做法 $\textbf 2$

观察一下这个题的性质．我们发现，两个区间 $R_1=(l_1,r_1)$ 和 $R_2=(l_2,r_2)$，我们可以把它们及它们的并集之间的关系分为三种：

- $R_1 \cap R_2=R_1$ 或者 $R_1 \cap R_2=R_2$；
- $R_1 \cap R_2=\varnothing$；
- $R_1 \cap R_2 \notin \{R_1, R_2, \varnothing\}$．

对于第一种关系，我们从长度小的区间对应的点向长度大的区间对应的点连一条单向边；对于第三种关系，我们在这两个区间对应的点之间连双向边．

**结论** $\mathbf 1$：若 $i\to j$ 可达，则存在一条 $i\to j$ 的路径，满足路径上至多经过一条单向边，其它的边全是双向边．且若经过单向边，则单向边一定是路径上的第一条边．

> 证明：若有存在有向边 $i\to k, k \to j$，则有向边 $i\to j$ 必然存在，直接跳 $i\to j$ 即可．

**结论** $\mathbf 2$：对于图的每一个强连通子图 $S$，设 $L=\min_{(l',r') \in S} l', R=\max_{(l',r') \in S} r'$，$(l,r)$ 是图中一个不在 $S$ 中的点 $p$ 所属的一个区间，则：

$$
(L<l<R) \lor (L<r<R) \Leftrightarrow p\textsf{ 可达 } S.
$$

> 证明：考虑一个强连通子图一定不重不漏的覆盖了这个区间，那么考虑跨到区间的点 $k$，一定有一个区间覆盖了 $k$．那么就能跳到那个区间，即跳到强连通子图的所有区间了．

考虑数据结构维护从点 $i$ 所在的强连通分量 $S_i$ 及该强连通分量在**结论** $\mathbf 2$ 中对应的区间 $[L_i,R_i]$．假设要判断 $p$ 是否可达 $i$，则：

- 若 $p \in S_i$，即 $i,p$ 在同一强连通分量，则显然可达．
- 若 $(L_i<l<R_i) \lor (L_i<r<R_i)$，根据结论 $2$，$p$ 可达 $i$．
- 其余情况不可达．

考虑把每个 $1$ 操作加入的区间看作一个三维空间内的点 $(T_i,l_i,r_i)$，$T_i$ 表示该区间被加入的时间．问题转化为：$1$ 操作将 $i$ 向满足 $T_j < T_i, l_j < l_i, l_i < r_j < r_i$ 或 $T_j < T_i, l_i < l_j < r_i.r_i<r_j$ 的所有 $j$ 连一条无向边．这相当于一个点向一个三维矩形内的所有点加边，同时维护 $S_i,L_i,R_i$．

- 如果使用三维线段树和并查集来维护之，我们得到了一个复杂度和常数都巨大的 $O(n\log^3 n \alpha (n))$ 做法，显然无法通过此题．
- 如果使用 3-D Tree 和并查集维护之，我们得到了一个 $O(n^{5/3} \alpha(n))$ 的做法，具体表现未测试，如果有人使用了这个做法 AC 了请私信我．

## 做法 $\mathbf 3$

可以发现，题目中给出了一个性质：保证加入的区间长度严格单调递增，即新区间一定不会被旧区间包含．我们的**做法** $\textbf 2$ 并没有利用这个性质．

考虑把每个区间放到线段树上，线段树每个区间开一个 `std::vector`，每加入一个区间 $R=(l,r)$，就在线段树上对应的 $O(\log n)$ 个节点的 `std::vector` 里加入该区间的编号．

这样的话，若需要检查另外一个区间 $R'=(l',r')$ 是否满足 $R \cap R' \notin \{R, R', \varnothing\}$，只需要检查线段树上所有包含 $l'$ 或 $r'$ 的区间中的 `std::vector` 中有没有 $R$ 即可．

我们只需在每次 $1$ 操作加入区间 $R$ 时，首先检查所有满足上述条件的 $R'$，将 $R$ 和 $R'$ 在并查集上并起来，然后将 $R$ 加入线段树即可．

查询操作和**做法** $\textbf 2$ 类似，这里不再重复讲述．

时间复杂度 $O(n \log n \alpha(n))$，可以通过此题．

## 代码参考

见 [原始 OJ 提交](https://codeforces.com/contest/319/submission/212773508)．
