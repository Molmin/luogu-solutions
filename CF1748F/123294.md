先进行一些探索：考虑 $i < j$，执行 $j - 1\to i$ 可以对 $a_i\sim a_j$ 做后缀和。然后再执行 $i + 1\to j - 1$ 还原 $a_{i + 1}\sim a_j$。这样，我们花了 $2(j - i)$ 的代价将 $a_i$ 变成了 $a_i\sim a_j$ 的异或和。

进一步地，再将 $a_i$ 变成 $a_i\sim a_{j - 1}$ 的异或和，我们可以花 $4(j - i)$ 的代价执行 $a_i\gets a_i\oplus a_j$ 的操作。将其表述为 $f(i, j)$。当 $i > j$ 时，也可以类似操作，代价为 $4(n + j - i)$。

为实现目标，只需交换 $a_i$ 和 $a_{n - 1 - i}$。关于交换，有一个非常经典的异或实现：`a ^= b ^= a ^= b`。因此，交换 $a_i$ 和 $a_j$ 可以表述为 $f(i, j), f(j, i), f(i, j)$。单次交换的平均次数为 $6n$，总操作次数为 $3n ^ 2$，无法接受。

进一步观察，我们发现在执行 $f(i, j)$ 的第三步时，相当于恰好执行了 $f(i + 1, j - 1)$ 的第一步。因此，常数砍半，总操作次数 $1.5 n ^ 2$，可以通过，[代码](https://codeforces.com/contest/1748/submission/184881118)。

在朴素做法中，我们执行了两次 $f(i, j)$。如果 $f(j, i)$ 的代价小于 $f(i, j)$ 的代价，我们可以考虑执行 $f(j, i), f(i, j), f(j, i)$ 达到相同的效果。这样，总操作次数为 $2.5n ^ 2$，类似优化后容易做到 $1.25 n ^ 2$。