$3000$ 的高级构造题。

我们一步一步地解这道题。  
为方便，下面自动认为所有下标相关的元素均在模 $n$ 意义下计算。  
同时注意本题有关下标的计算细节不少，一定想清楚。  
下面用符号 $\oplus$ 表示异或。  
设 $\text{Dist}(i,j)=(j-i+n)\bmod n$，即对 $a_{i},a_{i+1},\cdots,a_{j-1}$ 操作所需的操作次数。

---

1. 我们有操作 $a_i\leftarrow a_i\oplus a_{i+1}$，如何扩展出操作 $a_i\leftarrow a_i\oplus a_j(0\leq i,j<n;i\not=j)$ ？  

操作本身足够简单，因此手玩一下就会有一些方案。

- 考虑下列步骤：  
	- 将 $a_i$ 先变成 $\bigoplus_{k=i}^{j-1}a_k$，所需操作次数为 $\text{Dist}(i,j)-1$。
	- 将 $a_{i+1}\sim a_{j-2}$ 复原，所需操作次数为 $\text{Dist}(i,j)-2$。
	- 将 $a_{i+1}$ 变成 $\bigoplus_{k=i+1}^{j}a_k$，所需操作次数为 $\text{Dist}(i,j)-1$。
	- 对 $a_i$ 操作，所需操作次数为 $1$。
	- 将 $a_{i+1}\sim a_{j-1}$ 复原，所需操作次数为 $\text{Dist}(i,j)-1$。
	- 此时我们达成了将 $a_i\leftarrow a_i\oplus a_j$，并使用了 $4\times\text{Dist}(i,j)-4$ 次操作。

2. 上述操作的问题在于对中间 $a_{i+1}\sim a_{j-1}$ 的操作似乎存在大量冗余。   
于是考虑把若干个上述扩展过的操作压缩在一起。  
如果我们希望对任意非负整数 $k(i+k<j-k)$，使 $a_{i+k}\leftarrow a_{i+k}\oplus a_{j-k}$，有没有什么更优秀的方法？

我们最终要得到的东西大概长这样：
```plain
0 1 2 3 4 5 6 7 8 | (position)-i

1 0 0 0 0 0 0 0 1
0 1 0 0 0 0 0 1 0
0 0 1 0 0 0 1 0 0
0 0 0 1 0 1 0 0 0
0 0 0 0 1 0 0 0 0
0 0 0 1 0 0 0 0 0
0 0 1 0 0 0 0 0 0
0 1 0 0 0 0 0 0 0
1 0 0 0 0 0 0 0 0
```
这个东西长得非常特别。  
倒着思考，考虑我们得到这么一个东西前一些操作大概长什么样，于是有下面的猜测：
```plain
0 1 2 3 4 5 6 7 8 | (position)-i

1 0 0 0 0 0 0 0 1
1 1 0 0 0 0 0 1 0
1 1 1 0 0 0 1 0 0
1 1 1 1 0 1 0 0 0
1 1 1 1 1 0 0 0 0
1 1 1 1 0 0 0 0 0
1 1 1 0 0 0 0 0 0
1 1 0 0 0 0 0 0 0
1 0 0 0 0 0 0 0 0
```
这个东西经过按照 $k=0,1\cdots$ 的顺序对 $a_{i+k}$ 进行操作即可得到更上面的那个矩阵。  
然后我们发现此时我们有简单的构造出前面这些数的方法，因此我们有了一种方案。

- 考虑下列步骤：  
	- 对每个非负整数 $k(i+k<j-k)$，用 $2\times(\text{Dist}(i,j)-k)-1$ 次操作执行以下步骤：  
    	- 将 $a_{i+k}$ 变成 $\bigoplus_{l=i}^{j-k}a_l$。
        - 复原 $a_{i+k+1}\sim a_{j-k-1}$。
    - 对每个非负整数 $k(i+k<j-k)$，用 $1$ 次操作执行以下步骤：
    	- 对 $a_{i+k}$ 操作。
- 通过计算，这总计需要约 $\dfrac{\text{Dist}(i,j)\times(\text{Dist}(i,j)+2)}{2}$ 次操作。

3. 各位应该都熟悉一种“自作多情”的用 $\color{red}3$ 次异或维护 `swap` 函数的方法，不过可以在这题中尝试用一下。  
4. 根据操作上限，我们一定可以进行步骤 2 中的操作至少 $\color{red}3$ 次。  

我们知道在一些情况下有 `swap(a,b)` 和 `a^=b,b^=a,a^=b` 等价，这给我们的最终的思考提供了思路。  
定义函数 $F(i,j)$ 表示选择 $i,j$ 并进行步骤 2 中的操作。  
我们的大体思路是：
```plain
original:
a[0] a[1] a[2] ... a[n-3] a[n-2] a[n-1]
step 1:
a[0]^a[n-1] a[1]^a[n-2] a[2]^a[n-3] ... a[n-3] a[n-2] a[n-1]
step 2:
a[0]^a[n-1] a[1]^a[n-2] a[2]^a[n-3] ... a[2] a[1] a[0]
step 3:
a[n-1] a[n-2] a[n-3] ... a[2] a[1] a[0]
```
于是分奇偶性讨论，考虑下列步骤：

- 如果 $n$ 是偶数，依次进行 $F(0,n-1),F\bigg(\dfrac{n}{2},\dfrac{n}{2}-1\bigg),F(0,n-1)$。
- 如果 $n$ 是奇数，依次进行 $F(0,n-1),F\bigg(\dfrac{n+1}{2},\dfrac{n-3}{2}\bigg),F(0,n-1)$。

至此，我们用约 $1.5\times n^2$ 次的操作次数解决了这个问题。  
下面的程序采用该方法，在 $n=400$ 时达到最大操作次数 $239997$ 次，可以通过。

```plain
#include<bits/stdc++.h>
using namespace std;
#define int long long
template<typename T> void read(T &x) {
	x=0;int f=1;
	char c=getchar();
	for(;!isdigit(c);c=getchar()) if(c=='-') f=-1;
	for(;isdigit(c);c=getchar()) x=x*10+c-'0';
	x=x*f;
}
const int N=250020;
int n,op[N],p[N],cnt=0,s1,s2,s3,s4;
void upd(int x){
	cnt++,op[cnt]=x%n;
}
void solve(int l,int r){
	s1=(r-l+n)%n;
	for(int i=0;i<=(s1+1)/2-1;i++){
		for(int j=(r-1-i+n)%n;j!=l+i;j=(j-1+n)%n) upd(j);
		for(int j=l+i;j!=r-i;j=(j+1)%n) upd(j);
	}
	for(int i=0;i<=s1/2-1;i++) upd(l+i);
}

signed main(){
	read(n);
	solve(0,n-1);
	if(n%2==0) solve(n/2,n/2-1);
	else solve(n/2+1,n/2-1);
	solve(0,n-1);
	cout<<cnt<<endl;
	for(int i=1;i<=cnt;i++) cout<<op[i]<<' ';
	return 0;
}
```

---

小 upd。  
在题解的讨论区找到了更优的操作次数约为 $1.25\times n^2$ 的做法，  
有兴趣的就去看一看 [这位大佬](https://www.luogu.com.cn/blog/TOBapNw-cjn/solution-cf1748f) 的题解，毕竟人家先给出来。  
不过我还是在这里简述一下。

5. 我们对步骤 2 的利用似乎还是不好，表现在我们千里迢迢把 $a_{n-1}$ 一个一个移动到了 $a_0$。  
还总是移动了两次，而显然我们有将 $a_0$ 一步变到 $a_{n-1}$ 的操作。  

考虑将序列划分为两段 $[i;j],[j+1;i-1]$ 分别翻转（分三段或以上一定不优，因为翻转一个序列至少要 $\dfrac{n^2}{2}$ 级别的操作）。  
我们发现虽然直接做还是 $1.5\times n^2$ 次，但有 $0.25\times n^2$ 次操作可以覆盖，这样就优化到 $1.25\times n^2$ 次了。  
下面是图解，没看懂的可以对着理解一下。  
```plain
original:
0 1|2 3 4 5|6 7 - position 

0 0 0 0 0 0 0 1
0 0 0 0 0 0 1 0
0 0 0 0 0 1 0 0
0 0 0 0 1 0 0 0
0 0 0 1 0 0 0 0
0 0 1 0 0 0 0 0
0 1 0 0 0 0 0 0
1 0 0 0 0 0 0 0

step 1 - f(2,5):
0 1|2 3 4 5|6 7 - position

0 0 0 0 0 0 0 1
0 0 0 0 0 0 1 0
0 0 1 0 0 1 0 0
0 0 0 1 1 0 0 0
0 0 0 1 0 0 0 0
0 0 1 0 0 0 0 0
0 1 0 0 0 0 0 0
1 0 0 0 0 0 0 0

step 2 - f(4,3), which contains f(6,1):
0 1|2 3 4 5|6 7 - position

0 0 0 0 0 0 0 1
0 0 0 0 0 0 1 0
0 0 1 0 0 0 0 0
0 0 0 1 0 0 0 0
0 0 0 1 1 0 0 0
0 0 1 0 0 1 0 0
0 1 0 0 0 0 1 0
1 0 0 0 0 0 0 1

step 3 - f(0,7), which contains f(2,5):
0 1|2 3 4 5|6 7 - position

1 0 0 0 0 0 0 1
0 1 0 0 0 0 1 0
0 0 1 0 0 0 0 0
0 0 0 1 0 0 0 0
0 0 0 0 1 0 0 0
0 0 0 0 0 1 0 0
0 0 0 0 0 0 1 0
0 0 0 0 0 0 0 1

step 4 - f(6,1):
0 1|2 3 4 5|6 7 - position

1 0 0 0 0 0 0 0
0 1 0 0 0 0 0 0
0 0 1 0 0 0 0 0
0 0 0 1 0 0 0 0
0 0 0 0 1 0 0 0
0 0 0 0 0 1 0 0
0 0 0 0 0 0 1 0
0 0 0 0 0 0 0 1
```
代码就不整了，没上述做法好写。