神奇构造题
______________

我们接下来要证明的是只要构造一条链就可以构造出我们想要的树了，如果构造链仍然没法满足的话，那就是无解了

## 本题题解

首先题目中每条边都是相互独立的，不是一条边一条切掉之后两边的联通块剩下的点最大值，而是对于每一条边来讲，假设这条边没有了，左右两侧点的最大值

所以我们可以看出来如果我们想构造出一个合法的树的话所有的$b_{i}$必须是$n$因为$n$这个点要么被分到左边要么被分到右边

所以现在让我们集中经历考虑所有的$b_{i}=n$的情况，此时我们需要考虑的是满足$a_{i}$的限制条件

那么我们可以先想一种简单粗暴无脑但是好用的构造方案，就是构造一条链，并且$n$在长链的一端

那么我们可以把这个长链看成一个数组，我们题目中输入的$a$数组相当于一个前缀$max$数组,也就是说，我们的问题变成了给你一个数组的前缀max数组，反着构造原数组

这个问题其实还是比较可做的，具体的构造方法就是我们会发现前缀max数组是单调递增的所以我们把所有的$a$值都排一个序,然后在前缀max变成$a$的位置放一个$a$，后边放若干个比$a$小的数字就可以了

现在我们要证明的是为什么当我们无法构造出一条链的时候我们同样构造不出一个树的解

考虑一下什么时候我们上述的构造算法会失效

那就是对于某一个数字k,小于等于k的前缀max比k还要多，根据抽屉原理前k个数字的前缀max值一定是大于等于k的，所以剩下的前缀max我们就放不下了，构造就失败了

那么问题来这种情况就算你是颗树我们还是构造不出来的

具体来讲我们反证法证明，假设我们构造了一个合法的树，然后我们钦定了n为根，那么另一端点的最大值就是子树内的最大值那么问题来了根据抽屉原理在k条边中最大值的最小值一定是大于等于k的(因为在这时候子树的根节点就会出现一个大于等于k的点了)，因此我们可以证明这种情况就算是个树我们也构造不出来解

所以这题就很好写了，我们尝试构造一条链出来，如果失败了就输出no，然后就是记得判一下有些b不是n的情况了

上代码~

```C
#include<cstdio>
#include<algorithm>
using namespace std;const int N=1e3+10;int mx[N];int a[N];int n;
bool book[N];
inline void cfil(){printf("NO\n");return;}
inline void csuc(){printf("YES\n");return;}
int main()
{
    scanf("%d",&n);
    for(int i=1,u,v;i<n;i++)
    {scanf("%d%d",&u,&v);if(u<v)swap(u,v);if(u!=n){cfil();return 0;}mx[i]=v;}
    sort(mx+1,mx+n);
    for(int i=1;i<=n;i++)
    {
        if(mx[i]!=mx[i-1])a[i]=mx[i],book[a[i]]=true;
        else
        {
            for(int j=1;j<=mx[i];j++)
            if(!book[j]){a[i]=j,book[j]=true;goto ed;}cfil();return 0;ed:;
        } 
    }
    csuc();a[n]=n;
    for(int i=1;i<n;i++)printf("%d %d\n",a[i],a[i+1]);
}
```