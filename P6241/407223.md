首先答案的下界肯定是 $\left\lfloor\log_2q\right\rfloor+1$。
如果 $\log_2q$ 为整数，那么下界是取得到的。但是如果不为整数，那么 $\left\lfloor\log_2q\right\rfloor+1$ 次操作后的最大值还是小于 $q$。那么我们要考虑的下界变成了 $\left\lfloor\log_2q\right\rfloor+2$。

实际上这个下界是取得到的，方法是，从 $q$ 的二进制最高位开始一位一位地往下扫，若这位为 $1$，则输出 `1 tot`，否则输出 `2 tot`。其中 `tot` 表示这是第几个操作。最后再输出 `2 tot`。这就是本题的解。

这为什么是对的呢？

记第 $i$ 次操作后的塔顶为 $f_i$，那么：

若上一次是 `1 tot`，这次是 `1 tot`：$f_i=2f_{i-1}$。

若上一次是 `1 tot`，这次是 `2 tot`：$f_i=2f_{i-1}-1$。

若上一次是 `2 tot`，这次是 `1 tot`：$f_i=2f_{i-1}+1$。

若上一次是 `2 tot`，这次是 `2 tot`：$f_i=2f_{i-1}$。

我们以 $53$ 举例看看，写成二进制就是 $110101$，前缀为 $p$。

$f_1=1,f_2=2,f_3=3,f_4=7,f_5=13,f_6=27,f_7=53$。

写成二进制是：

$$f_1=000001$$

$$f_2=000010$$

$$f_3=000011$$

$$f_4=000111$$

$$f_5=001101$$

$$f_6=011011$$

$$f_7=110110$$

对于每一个连续的 `1` 块，当它后面的 `0` 执行完一次操作后。刚好是它前面的答案，那么后面的 `0` 执行后也都是一致的。即 $f_3$ 为 $p_2$。而在下一个连续的 `1` 块出现前，$f_i=p_{i-1}$。

而这个连续块的第一个执行后，直到这个连续块结束，这个连续块实际上是在连续块的前一位为 $1$，后面为 $0$。即($f_4=111$，抛开相同的前两个 $11$ 不谈，比较 $1$ 与 $01$)。在执行完后面的 $0$ 后，因为是乘二减一，所以开始的 $1$ 没了，后面的 $0$ 全变成了 $0$。但是这样最后还差一位。分类讨论发现最后一个 `2 tot` 的操作能满足末位是 $0$ 或 $1$ 的情况。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int T;
long long x;
int main() {
    scanf("%d",&T);
    while (T--) {
        scanf("%lld",&x);
        int res=__lg(x);//用log2可能有精度误差
        if (x==1) puts("0");//特判1
        else if (x==1ll<<res) {//注意是1ll
            printf("%d\n",res+1);
            for (int i=1;i<=res+1;i++) printf("1 %d\n",i);
        }
        else {
            printf("%d\n",res+2);
            int cnt=0;
            for (int i=res+1;i>=1;i--) {
                if (x>>(i-1)&1) printf("1 %d\n",++cnt);
                else printf("2 %d\n",++cnt);
            }
            printf("2 %d\n",++cnt);
        }
    }
    return 0;
}
```