- 评：思维难度适中；代码难度不高
- 注意点：1.long long 的左（右）移运算**必须**用`1ll<<k`而非`1<<k`；2.慎用、不用`ceil(k)`，你会发现它会错！！

### 题解
仔细观察可以发现，我们需要在每一步采取一些特定措施——只加当前塔的一段而非全部，从而在最后的时候恰好得出要求的答案。观察样例，我们猜想最小步数为 $\log_2 q+1$（事实证明这是对的）。那么显然第一步是 `1 1`。也就是说我们要用 $\log_2 q$ 步从初始的 $[1\ 1]$ 得到最后的 $[1\ 1\ \cdots\ q]$。

**考虑“特定措施”为在某些步只加当前塔的一个后缀**。思考如何通过此得到答案。

我们以 $q=107$ 为例。那么不做任何变动地进行 $\log_2 q$ 步最后会得到 $128$。$107=128-21$，这个 $21$ 很重要，它就是我们所有“特定措施”对答案的影响之和。经过一番推导和尝试，我们想到一个可行的办法：

由于 $(21)_{10}=(10101)_2$，所以我们可以把“影响之和”分解成 $1_2+(100)_2+(10000)_2=2^0\times 2^0+2^1\times 2^1+2^2\times 2^2$，策略就是在倒数第四步、倒数第三步、倒数第二步分别不选 $[1\ 1\ 2]$、$[1\ 1]$、$[1]$。你会发现在第 $t$ 步“不选”的序列的数字之和为 $x$，则第 $t,t+1,t+2,\cdots$ 步由它导致的“影响”就是 $x,x,2^1x,2^2x,\cdots$。所以上面 $2^2\times 2^2$ 就是说最后一步恰好是第 $t+3$ 步，那么 $t$ 就是 $8-3=5$，这是第一个 $2^2$ 的含义，第二个的含义就是 $x=2^2$，那不就是 $[1\ 1\ 2]$ 这个前缀吗？其它的同理。

所以现在就要解决如何得到 $21$ 的分解。我们目标是把他分解成 $2^0\times 2^{m1}+2^1\times2^{m2}+\cdots$ 的形式，那么它的二进制分解中的每一个二的指数我们依次将它减去 $0,1,\cdots$ 就能得到 $m1,m2,\cdots$ 了。

这个是 $107$ 的详细方案过程：

```
1 1 2 4 8 12 26 53 107
```

下面是代码：

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
int s[100];
void solve(){
	int n;
	cin>>n;
	if(n==1){puts("0");return;}
	int l=log2(n);
	if((1ll<<l)<n)l++;
	int c=1ll<<l;
	cout<<l+1<<endl;
	puts("1 1");
	int dt=c-n;
	memset(s,0,sizeof(s));
	for(int i=0,j=0;dt;i++,dt>>=1ll)
		if(dt&1ll){//2^j*2^(i-j)
			s[j+2]=i-j+1;
			j++;
		}
	for(int i=1;i<=l;i++)
		printf("%lld %lld\n",s[l-i+1]+1,i+1);
}
signed main(){
	int T;
	cin>>T;
	while(T--)solve();
}
```