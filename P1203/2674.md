题解by:redbag

- 思路：先拉直（把字符串复制一遍，然后每局每个空去模拟。细节部分见代码

- /\*
- ID: ylx14274

- PROG: beads

- LANG: C++

- 防超代码。

- \*/
```cpp
- #include<set>
- #include<map>
- #include<list>
- #include<queue>
- #include<stack>
- #include<string>
- #include<math.h>
- #include<time.h>
- #include<vector>
- #include<bitset>
- #include<memory>
- #include<utility>
- #include<stdio.h>
- #include<sstream>
- #include<iostream>
- #include<stdlib.h>
- #include<string.h>
- #include<algorithm>
- #define LL unsigned long long
- int n,i,j,maxx;
- long long ll,rr,o;
- char s[4000],l,r;
- using namespace std;
- int main()
- {
- freopen("beads.in","r",stdin);//抄代码的记得删掉
- freopen("beads.out","w",stdout);
- cin>>n;
- cin>>s;//rbw
- for (i=0;i<=n-1;i++)
- {
- s[n+i]=s[i];
- } //拉直----------------没错
- for (i=1;i<=n;i++)//枚举每个切断的位置
- {
- l='a';r='a';//初始化
- ll=0;rr=0;
- for (j=i-1;j>=1;j--)//往左边取珠子
- {
- if (s[j]=='w') {ll++;}//如果是白色就任意
- else//否则
- {
- if (l=='a')//这是第一个非白的珠子
- {
- l=s[j];//标记
- ll++;//计数
- } else//否则
- {
- if (s[j]==l)//是相同颜色的珠子
- {ll++;} //计数
- else break;//否则退出。
- }
- }
- }
- for (j=i;j<=i+n;j++)//往右边取珠子
- {
- if (s[j]=='w') rr++;//如果是白色就任意
- else//否则
- {
- if (r=='a')//这是第一个非白的珠子
- {
- r=s[j];//标记
- rr++;//计数
- } else//否则
- {
- if (s[j]==r)//是相同颜色的珠子
- rr++; //计数
- else break;//否则退出。
- }
- }
- }
- if (ll+rr>n)//如果超过了（这说明所有都可以取
- {
- ll=n;//其实这2个赋值语句就是使ll+rr=n；
- rr=0;
- }
- maxx=(ll+rr)>maxx?ll+rr:maxx;//求max
- }
- //cout<<s<<endl;
- cout<<maxx<<endl;
- return 0;
- }
```