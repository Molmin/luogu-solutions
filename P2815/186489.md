## 【思路】
模拟    
### 【题目大意】
将完整的的IPv6的显示方式压缩为macOS(Darwin)默认的IPv6地址显示方式    

### 【题目分析】
压缩方式即为：    
将每一组数 （每一组数是没有被:隔开的连续的4个数）的前导0去掉    
不过如果是0000那就只能压缩为0    
将最长的连续的0000这样的串可以压缩为::   
比如0000:0000:0000:0000就可以压缩为::   
如果有两个相同长度的那就替换前面的   

### 【核心思路】
先找出最长的连续0000串第一个数的位置    
到时输出输出完成::之后直接跳到这个串的最后一位就好了    
总的来说上面这个还是比较好处理的   
去除前导0才是最难的    


这个时候就会有人说了，这不就是一个while循环搞的定的嘛，哪里难了    
这个时候很容易会Wa掉第一个点   
本人就出在这个问题上面    
因为一般用while循环判断是不是这组数的最后一个一般会用下一个是不是:来判断    
但是！    
**想没想过最后一组数的最后一位怎么判断？这个后面可没有:**      
很容易被忽略的哦     
但是知道问题所在之后稍微特判一下就可以了      

### 【提供一组小数据】
关于第一个点错误的样例     
abcd:0000:0000:abcd:0012:0000:0001:0000    
正解： abcd::abcd:12:0:1:0    
错解： abcd::abcd:12:0:1:     
## 【完整代码】
```cpp
#include<iostream>
#include<cstdio>
#include<cstring>.
#include<string>

using namespace std;
string s;
int main()
{
	cin >> s;
	int l = s.length();
	int a = 0;
	int js = 0;//记录目前0串的长度 
	int M = 0;//记录最大的几组0的长度 
	int wz = -1;//最长0那一串中第一个0的位置 
	int last = -1;//上一个0串的位置 
	for(register int i = 0;i < l;i += 5)
	{
		if(s[i] == '0' && s[i + 1] == '0' && s[i + 2] == '0' && s[i + 3] == '0')//一组完整的0 
		{
			if(last == i - 5)
			{
				last = i;
			}
			else
			{
				js = 0;
				last = i;
				a = i;
			}
			js ++;
		}
		if(js > M)
		{
			M = js;
			wz = a;
		}
	}
	int jj = 0;
	while(jj < l)
	{
		if(jj == wz)
		{
			if(jj == 0)
				cout << ":";
			jj += M * 5 - 1;
			if(jj == l)
				cout << ":";
		}
		else
		{
			if(jj % 5 == 0)
			{
				if(jj >= 35)//如果是最后一组的话，那就不能根据下一个是不是:来判断这个0是不是这组数中最后一个数了 
				{
					while(s[jj] == '0' && jj + 1 != l)
					{
						jj ++;
					}
				}
				else
				{
					while(s[jj] == '0' && s[jj + 1] != ':')
					{
						jj ++;
					}
				}
			}
			cout << s[jj]; 
			jj ++;
		}
	}
	cout << endl;
	return 0;
}
/*
2001:0db8:0000:0000:0123:4567:89ab:cdef
012345678901234567890123456789012345678

abcd:0000:0000:abcd:0012:0000:0001:0000
*/
```