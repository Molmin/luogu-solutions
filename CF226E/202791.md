题意是求一条链上的第 $k$ 个在第 $t$ 个操作前没变黑的点。

显然需要可持久化，因此只能用主席树维护。

简单思考可以发现，只能先从 $a \to lca$ 找答案再 $lca \to b$ 找答案，注意这里 $a$ 和 $b$ 不能瞎换，然后需要注意 $a, b$ 没有贡献，同时 $lca$ 的贡献不要算两次。

那么我们可以这么做，先将剖出来的区间扔到一个 `vector` 里存着（放 `vector` 里是为了方便之后因为操作顺序需要 `reverse`，然后按照正确的顺序扫 `vector`，直到当前满足条件的点的数量超过了要求的数量，然后再把当前超的这个区间拎出来，在上面划分成整区间后也存到一个 `vector` 里（同样为了方便 `reverse`），然后再按照正确的顺序扫一遍直到超了要求的数量就可以直接在这个整区间上主席树二分了。

那怎么计算区间内满足要求的点的数量有多少个？我们先把所有城堡的值设为 $1$，然后如果有野蛮人入侵就把它的值设为 $0$。假设当前时间是 $t$，骑士出发时间是 $y$，那么答案就是 $t$ 版本的线段树上区间 $1$ 的数量 $+$ $y$ 版本的线段树区间 $0$ 的数量，这个也不难求。

主要就是选点顺序和重复贡献那里有一些代码实现细节，其实不是很难写。

代码就别看了，打了一堆补丁：[https://codeforces.com/problemset/submission/226/197171854](https://codeforces.com/problemset/submission/226/197171854)