### 题意简述：
给你一个序列，每次操作可以颠倒一个连续子序列，用最少次数把这个序列变得有序。

### 思路：
首先得弄懂样例，对比样例输入输出我们可以发现，样例输出中的插入位置 $i$，实际上是把 $1\to n-i+1$ 的整个子序列全部颠倒，如下表所示：

| 目标序列 | $1$| $2$| $3$ | $4$ | $5$|
| -----------: | -----------: | -----------: | -----------: | -----------: | -----------: |
| 原序列 | $5$ | $1$ | $2$ | $3$ | $4$ |
| 在位置 $1$ 插入后 | $4$ | $3$ | $2$ | $1$ | $5$ |
| 在位置 $2$ 插入后 | $1$ | $2$ | $3$ | $4$ | $5$ |

那么理解了题目之后，我们可以先把序列从小到大排序，我们首先把最大的数归位，再归位次大数，再归位第三大数，以此类推。为什么这样做呢？因为最大的数排在最后，当归位最大的数之后，后面的操作都不会影响到最大的数了，所有的数都是这样。

那么如何把一个数归位呢？我们可以按照选择排序的思想，对于每一个没有归位的数，我们先用一次翻转把这个数移到顶部，再用一次翻转把它移回正确的位置。因为前面已经确定了归位顺序，所以这个数后面的数都已归位，这样的策略是正确的。

这样说可能还是有点晦涩，参考一下代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int temp[50],a[50],b[50],n=1,cnt;
void fz(int p)//对煎饼的反转
{
	for(int i=1;i<=p;i=-~i)temp[p-i+1]=a[i];
	for(int i=1;i<=p;i=-~i)a[i]=temp[i];
}
void input()//因为没有指定煎饼的个数，但每组数据之间以空行分隔，所以读到空行是停止这组数据的读入
{
	char c=getchar();
	while(c!='\n')
	{
		if(c==' ')n++;
		if(c>='0'&&c<='9')a[n]=(a[n]<<1)+(a[n]<<3)+(c^48);
		c=getchar();	
	}
}
int main()
{
	while(cin>>a[n])
	{
		input();//读入
		for(int i=1;i<n;i=-~i)cout<<a[i]<<' ';
		cout<<a[n]<<'\n';
		memcpy(b,a,sizeof(a));
		sort(b+1,b+n+1);//对原序列排序，得到目标序列
		for(int i=n;i>=1;i--)//从 n 到 1，确保当前操作不会影响到已归位的数
		{
			if(a[i]==b[i])continue;//如果已归位，则无需操作
			for(int j=2;j<i;j=-~j)
				if(a[j]==b[i])//如果在位置 j 找到了当前要归位的数，则把它翻到顶部
				{
					fz(j);
					cout<<n-j+1<<' ';
					break;
				}
			fz(i);//再把它翻到正确的位置
			cout<<n-i+1<<' ';//因为是从右往左翻，所以是 n-i+1
		}
		cout<<0<<'\n';
		n=1;
		memset(a,0,sizeof(a));
	}0
	return 0;
}
```


