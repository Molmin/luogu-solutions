# 前言

~~没想到我也有写黑题题解的一天~~。

看了看 CF，这是 Div.2 的 C 题，但居然有 2500 分 。看看这个难度曲线，我感受到了当时打比赛的看到 C 题的绝望心情：

[![5rwKkd.png](https://z3.ax1x.com/2021/10/21/5rwKkd.png)](https://imgtu.com/i/5rwKkd)

（pass: D 题 1900 分，E 题 2600 分）

# 题面

## 题目描述

有 $n$ 个人站在数轴上。对于每个人，我们知道他的位置，最大速度以及前进方向（向左或向右）。这 $n$ 个人刚开始静止不动

其中这 $n$ 个人所在的位置 $x$ 均满足：$0<x<10^6$ 且 $x$ 为正整数。

你可以在数轴上任意一个非负整数上放置一个炸弹($0\le$ 炸弹位置 $\le 10^6$)。当你引爆他的时候，所有人都会开始用他的最大速度朝着对应的方向奔跑。另外，两条奇怪的光线将会从炸弹爆炸的位置处开始，朝着数轴两端（向左和向右）以最大速度 $s$ 传播。

**注意**：$s$ 严格大于所有人的速度。

当一个正在奔跑的人接触到了一条光线，且光线的方向与人的方向相同，那么他的速度为立刻增加 $s$。（只会增加一次）

请问，让你任意选择炸弹的位置，花最少的时间，使得至少有一个人穿过位置 $0$，至少有一个人穿过位置 $10^6$。并输出这个最小的时间。

## 输入格式

第一行包含两个数：$n$ 和 $s$，表示人数和光线的速度。

接下来有 $n$ 行，第 $i$ 行有三个数：$x_i$ ，$v_i$ 和 $t_i$。表示这个人所处的位置，最大速度以及方向。（$t_i=1$ 表示这个人向左，$t_i=2$表示这个人向右 ）

**注意** ：数据保证一定有解。

## 输出格式

输出满足条件的最小时间。设您的答案为 $a$，标准答案为 $b$。若他们满足以下条件：$\frac{|a-b|}{max(1,|b|)}\le 10^{-6}$，则认为您的答案正确

## 样例说明

在样例 $1$ 中，炸弹放在位置 $400000$ 上是最优的，此时在时间 $0$，第一个人的速度变为 $1000$,让他在时刻 $600$ 时到达位置 $10^6$。炸弹不会影响第二个人，他会在时刻 $500000$ 时到达 $0$ 点。

在样例 $2$ 中，炸弹放在位置 $500000$ 上是最优的，光线将在时刻 $200$ 时追上两个人，此时，第一个人位于位置 $300000$，第二个人位于位置 $700000$。他们的速度将变为 $1500$。当时刻 $400$ 时，他们讲同时到达 位置 $0$ 和 位置 $10^6$。

## 数据约定

$2\le n \le 10^5$，$2\le s \le 10^6$，$0\le$ 炸弹位置 $\le 10^6$

$0< x_i < 10^6$，$1 \le v_i \le s$，$1 \le t_i \le 2$

$n,s,x_i,v_i,t_i$，炸弹位置 $\in N^*$


# 题解

（需要简化题意的可以去 luogu 题面上康康。）

首先看到题目答案中有 "至少"，"最少" 的字眼，且题目限制比较多，第一时间考虑二分。

考虑答案是否有单调性质——这是显然的，若一个方案满足最小的时间，保持这个方案不变，那么时间增大仍然满足条件。

那么我们二分枚举最少时间，然后我们希望通过题目的限制条件来判定——有没有一种放炸弹的方案满足花费时间小于等于我们枚举的答案。

然而这样子二分不二分并没有什么区别。考虑我们需要判定可行性，那么就不需要精确求解，考虑有没有一些区间放炸弹满足条件即可。

那么分别考虑炸弹对每一个人的影响。为了方便说明，这里先探讨人向左的情况。

那么我们已知人到 $0$ 点的距离 $dis_1$，人的速度 $v$，人的方向（向左）以及限制时间 $t$。我们设炸弹距离 $0$ 点的距离为 $x$ ，人与光线接触时行走的距离为 $dis_2$，

若不加炸弹也能在限定时间内到达 $0$ 点，说明我们可以把炸弹放到任意一个点。

$$
\frac{dis_1}{v}\le t
$$

若即使把炸弹放在他那个位置，他依然不能到达，那么他不能对答案造成贡献。

$$
dis_1 - (v+s) \times t \ge 0
$$
否则，我们要开始愉快的推柿子了。

根据[追及问题](https://baike.baidu.com/item/%E8%BF%BD%E5%8F%8A%E9%97%AE%E9%A2%98/1039047?fr=aladdin)，我们可以推出 $dis_2$ 的值：

1.
$$
dis_2= \frac{(x-dis_1) \times v}{s-v}
$$

（时间等于路程除以速度，路程等于时间乘以速度）

那么根据题意，我们能列出以下限制条件：

2.
$$
\frac{dis_2}{v}+\frac{dis_1-dis_2}{s+v} \le t  
$$


（人与光线相遇的时间加上人相遇后到达 $0$ 点的时间，也就是到达 $0$ 点的时间必须小于限制时间）  

3.
$$
dis_1\le x
$$

（炸弹的位置必须在人的右边，否则起不了加速作用）

因为我们要限制炸弹位置 $x$，但第一个式子中没有 $x$，我们需要再来一个式子表示 $x$。

4.

$$
x = (dis_1-dis_2)+\frac{dis_2}{v} \times s
$$

(由追及问题可得当 $x$ 与光线相遇时，花费的时间为 $\frac{dis_2}{v} $，速度为 $s$，可以算出 $x$ 与 $dis_2$  之间的距离，再加上 $dis_2$ 离 $0$ 点的距离，就是 $x$ 与 $0$ 点的距离)

然后开始愉快的化式子后（过程在[云剪贴板](https://www.luogu.com.cn/paste/po5ye8m8)里）,我们得到了最终结果：

$$
dis_1 \le x \le \frac{t \times (s^2-v^2) +dis_1 \times v}{s}
$$

然后再考虑向右的情况（过程在[云剪贴板](https://www.luogu.com.cn/paste/ma0cqnsk)里，过程类似，定义相同）：

首先考虑能不能直接到达，若满足以下条件，则不用炸弹也能到达：

$$
dis_1 + v \times t \ge 10^6
$$

再考虑若炸弹放在他的位置依然不能到达，那么不能对答案造成贡献。

$$
dis_1 + (v+s) \times t \le 10^6
$$
否则，要满足以下条件：
$$
\frac{10^6 \times(s-v) + dis_1 \times v - t \times  (s^2-v^2)}{s} \le x \le dis_2
$$

那么对于一个方向相同的人，我们求出了使得他满足条件的炸弹的位置（令人高兴的是，他是一个连续的区间，使得我们可以用简单的差分维护），那么多个人方向相同呢？因为只需要 "至少"，所以我们只需要求区间并即可。

那么对于方向不同的人，我们需要求出一个炸弹位置，使得两个方向的人都满足——即求区间交。

那么整道题的思路就豁然开朗了。

那么就是写一个实数二分，每次求差分求两个区间并，判一下两个区间并有无交即可

# 代码实现
我之前代码求区间并使直接求左右端点的。显然这是错的，会被下面这种数据卡掉。

[![5ssags.png](https://z3.ax1x.com/2021/10/21/5ssags.png)](https://imgtu.com/i/5ssags)

但我居然 A 了，~~这就离谱~~。

那么下面具体讲讲几个要点：

* 判区间并与交要用前缀和

* 要特判一定满足，一定不满足以及区间的情况。

* double 和 int 不要搞混

* 注意炸弹位置必须是整数，要根据 $\le$ 和 $\ge$ 特殊判断。要满足取整后的区间是原区间的子集。（$\le$ 用 floor，$\ge$ 用 ceil）

具体详见代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e6+1e3,inf=1e6;//数组下标必须是正数，所以要用 int
const double eps=1e-9;
struct People
{
    int dir;
    double x,v;//取 double 就不用 * 1.0
}p[N];
int n;
double s;
int suml[N],sumr[N];

bool check(double t)
{
    for(int i=0;i<=inf+10;i++)suml[i]=sumr[i]=0;
    for(int i=1;i<=n;i++)
    {
        if(p[i].dir==1)
        {
            if(p[i].x-(p[i].v+s)*t>0)continue;
            if(p[i].x-p[i].v*t<=0)
            {
                suml[0]++;suml[inf+1]--;continue;
            }
            double x=floor((t*(s*s-p[i].v*p[i].v)+p[i].x*p[i].v)/s);
            //x 用 int 可能会爆
            suml[(int)p[i].x]++;suml[(int)min(x+1,inf*1.0+1)]--;
        }
        else  
        {
            if(p[i].x+(p[i].v+s)*t<inf)continue;
            if(p[i].x+p[i].v*t>=inf)
            {
                sumr[0]++;sumr[inf+1]--;continue;
            }
            double x=ceil((1.0*inf*(s-p[i].v)-t*(s*s-p[i].v*p[i].v)+p[i].x*p[i].v)/s);
            sumr[(int)max(x,0.0)]++;sumr[(int)p[i].x+1]--;
        }
    }
    for(int i=1;i<=inf;i++)
    {
        suml[i]+=suml[i-1],sumr[i]+=sumr[i-1];
        if(suml[i]&&sumr[i])return 1;
    }
    return suml[0]&&sumr[0];//特判不用炸弹也能到的点
}
int main()
{
    scanf("%d%lf",&n,&s);
    for(int i=1;i<=n;i++)scanf("%lf%lf%d",&p[i].x,&p[i].v,&p[i].dir);
    double l=0,r=1e6,mid;
    while(r-l>=eps)//实数二分
    {
        mid=(l+r)/2;
        if(check(mid))r=mid;
        else l=mid;
    }
    printf("%.12lf\n",l);
    return 0;
}
```

# 后记

感觉这题最多评个蓝，不过 CF 评分 2500，可能是式子过于冗长（向我这样的老年选手就推的很慢），精度要求高的原因吧。