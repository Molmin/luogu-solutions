### 作为CF比赛中Div.3的A题，这道题还算是比较简单的。

题目传送门：[CF1547A](https://www.luogu.com.cn/problem/CF1547A)

 
 
这道题其实没有想象的那么复杂，只需要判断 $F$ 在不在 $A$ 和 $B$ 之间的最短路径上即可。因为对于一次移动，只能从当前点移动到相邻的上下左右四个点，
所以没有什么对角线又是什么直角坐标系距离公式什么的，只是纯粹的曼哈顿距离。

#### 那么分两类讨论：
### 1.AB之间的最短距离没有障碍物。
简单地看成一个直角三角形：在 $AB$ 之间，横坐标大的点向y轴（纵轴）作垂线，纵坐标大的点向x轴（横轴）作垂线，两条垂线的交点就是直角三角形的直角顶点，设这个点为 $C$ ，那么最短距离就是 $AC+BC$ 。
### 2.AB之间的最短距离有障碍物。
如果 $AB$ 之间有障碍物，那么显然，他们只能在一条平行于坐标轴的直线上，也就是说第一种情况设的 $C$ 是与 $A$ 或 $B$ 重合的。


#### 为什么呢？很容易证明。我们用一个不严谨的反证法。

（此下内容用处不大，仅能帮助理解结论，大佬们可自行跳过）

假设如果 $AB$ 之间有障碍物，$C$ 不与 $A$ 或 $B$ 重合。那么我们就可以看到这还是第一种情况里的近似直角三角形的东西。那如果这样，障碍物必须在 $AC$ 或者 $BC$ 上。但是我们知道，一个长方形（正方形）恰好是由两个全等的三角形组成的，那么 $A$ 与 $B$ 之间的最短距离还有一种路可以选择，那么 $A$ 与 $B$ 之间就没有障碍物了，这与我们的假设相矛盾。

#### 所以得出结论，如果AB之间有障碍物，C与A或B重合。
接下来的很好实现了，因为在一条这样的直线上，经过一个障碍物就要多走两步，也就是横坐标或纵坐标一加一减。那这样最短距离是要比 $AC+BC$ （实际上就是AB）要多2的。


## Code：
```cpp
#include<iostream>
#include<algorithm>
#include<cstdio>
using namespace std;
int ax,ay,bx,by,fx,fy;
bool flag;
int main(){
	int t;
	cin>>t;
	while(t--){
		cin>>ax>>ay;
		cin>>bx>>by;
		cin>>fx>>fy;
		int smal=abs(ax-bx)+abs(ay-by);
		flag=0;
		if(ax==fx&&bx==fx&&((ay<fy&&by>fy)||(ay>fy&&by<fy)))flag=1;
		if(ay==fy&&by==fy&&((ax<fx&&bx>fx)||(ax>fx&&bx<fx)))flag=1;
		if(flag==1)	smal+=2;
		cout<<smal<<endl;
	}
	return 0;
}

```
已经很清楚了吧，注释不用加了吧。