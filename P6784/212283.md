先写一发题解，存着备用，看大家都在抢提交有点恐怖/fad

题意很简单，题目规范也做的很好，所以不多赘述。

## 解法分析 Analysis

由题目可知，$a$ 和 $b$ 类似于我们所说的“短板效应”，因为每一层对两个砖头所需的数量都是相同的，显然能盖的最高楼层是由其中较少的那一块决定的，所以我们要让较少的一类尽可能多，即考虑一个贪心策略，尽可能让 $|a-b|$ 小，这样我们就可以最大化地利用这些砖头来造房子了。

也就是说，我们要合理地分配这个 $c$，使得 $a$ 和 $b$ 尽可能接近，他们的差非 $1$ 即 $0$，这时候就要分情况考虑。

假设最后我们能做到使得 $\min(a,b)=s$，那么考虑 $s$ 的不同情况有：


- 普通情况：

因为我们可以将 $c$ 均匀分配，若将 $c$ 也视为一种砖头，可以任意变换的转呕吐，那么能得到的最优解就是“砖头总数”的一般，也就是：

$$s=\left\lfloor\dfrac{a+b+c}{2}\right\rfloor$$

- 特殊情况

但是上述方案有一个问题，如果用所有的 $c$ 都无法使得 $a$ 和 $b$ 的差满足最优的情况，也就是当 $c<|a-b|$ 的时候，我们就只能退而求其次，尝试用全部的 $c$ 来填补 $\min(a,b)$ 的空缺，也就是：

$$s=\min(a,b)+c$$

这时候我们就可以求出砖头数了。

接下来就需要模拟搬砖的过程，因为：

$$\sum\limits_{n=1}^{10^6}n=(1+10^6)\times10^6>10^{12}$$

所以简单的模拟运行次数不会超过 $10^6$，这样就可以简单的解决了，大体步骤如下：

- 循环变量 $i$ 每次加 $1$（`while` 和 `for` 皆可）。
- 用 $sum$ 累加。
- 判断，若 $sum>s$ 就输出 $i-1$。

当然如果你判断 $sum+i+1>s$ 输出 $i$ 也是可以的。

最后注意的是，范围到了 $10^{12}$，所以记得开 `long long`，同时使用到的 `abs` 要用到 `cmath` 库。

## 代码实现 Code

```cpp
#include<bits/stdc++.h>
using namespace std;
long long a,b,c,s,ans;
int main(){
	cin>>a>>b>>c;
	if(abs(a-b)>c)s=min(a,b)+c;
	else s=(a+b+c)/2;
	for(long long i=1;;i++){
		ans+=i;
		if(ans>s){
			cout<<i-1<<endl;
			return 0;
		}
	}
}
```

当然你完全可以对前 $\left\lfloor\sqrt{s}\right\rfloor$ 层楼用等差数列求和公式进行计算，然后再进行循环求解，这样可以大大优化原有程序的效率，改动部分代码如下：

```cpp
f=sqrt(s)-1;
ans+=(1+f)*f/2;
for(long long i=f+1;;i++){
	ans+=i;
	if(ans>s){
		cout<<i-1<<endl;
		return 0;
	}
}
```

[>> 点击查看 $\rm\color{lime}AC$ 记录 <<](https://www.luogu.com.cn/record/37637626 "浮窗提示：作者长期打开完全隐私保护，不可查询链接属正常情况")

求赞，感谢阅读。