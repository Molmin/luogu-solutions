写在前面的话：再看题解之前，请你确保你已经进行了足够的思考，如果你没有，那么还是请你在好好分析分析题目。如果你会最小生成树的话，那么这一道题应该得五十分还是比较容易的

好了，我们直入主题。

先看一下题，让所有的村子全部有水，这就是最小生成树的模板题啊！！！于是，我们有了以下的想法：对于整张图，跑一边最小生成树，再决定应该在哪个点打井，最后相加得到ans，输出。

于是，得到了五十分

这是我们要想一个问题，题目里并没有说只能打一口井。如果打井的花费要小于修路的花费，那么打井就可以了。请看一组hack数据

```cpp
3
1 1 1
0 10 10
10 0 10
10 10 0

```


在这个数据里，如果按照上面的想法，应该的答案是20（最小生成树）+1（打一口井），但是，在1，2，3每一个点都打一口井，花费为3，显然是要小于刚才那个值的。这怎么办呢？难道要爆搜所有可能的打井情况？

其实这个想法比较麻烦，而且显然不好实现。在OI竞赛里，如果你觉得一种想法有些难以实现或不切实际，千万不要一条路走到黑，一定要换一个角度想一想

比如这道题，让我们回到问题的本质：让每个村庄都有水。（前方高能）

我们可以假设，所有的经都和一处水源联通。那么，我们可以把所有的村庄都和这个水源连接起来，这样，我们只要把这个水源点也看成一个村庄，让他和所有的点都或直接或间接地联通，并且让每个点之间连通，问题就解决了

这样，这个问题就转化成了一个n+1个点的最小生成树，并且每个点和水源点连接的费用就是打井的费用。

于是，样例的情况就是1号点和水源点联通，其他点与一号店联通，而我的数据就是每个点都与水源点联通。

其实就是要让水源点和每个点联通，这样水就会走进每个村子

于是，我们在建点和点的边的基础上，在建和水源点的边，然后跑一边最小生成树就可以了。（prim和kruskal都可以，但我更喜欢kruskal）

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,w[1001]={0},f[1001]={0},p[1001][1001]={0},te=0,ans=0;
struct es{
	int from,to,value;
}a[100001];
void adde(int x,int y,int z){
	++te;
	a[te].to=y;
	a[te].from=x;
	a[te].value=z;
}
bool cmp(es a,es b){return a.value<b.value;}
int find(int x){
	if(x==f[x])return x;
	else return f[x]=find(f[x]);
}
int main(){
	cin>>n;
	for(int i=1;i<=n;i++)cin>>w[i],f[i]=i;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			cin>>p[i][j];
			if(i!=j)
			adde(i,j,p[i][j]);
		}
	}
	for(int i=1;i<=n;i++){
		adde(i,n+1,w[i]);
		adde(n+1,i,w[i]);
	}
	sort(a+1,a+te+1,cmp);
	for(int i=1;i<=te;i++){
		int x=find(a[i].to);
		int y=find(a[i].from);
		if(x==y)continue;
		else f[x]=y,ans+=a[i].value;
	}
	cout<<ans<<endl;
	return 0;
}
```

写在后面：这一道题我一开始也没有想到100分做法，只想到了50分，看了题解。所以如果你看了题解，那么请你一定理解透彻以后，再写一遍代码或者像我一样写一篇题解毕竟如果一味的看题解是无法取得能力上的提升的

~~您都看到这了，赞一个好吗QAQ~~