
## 题解：

[博客食用口味更佳](https://www.cnblogs.com/fusiwei/p/11808370.html)

~~2019.11.6模拟赛T1 爆蛋场~~

因为蒟蒻对状压不是很熟悉，所以一开始根本没往那边想，发现可以暴力生成全排列看看合不合法。然后持续更新答案。预计30$pts$~~但是写挂了~~

那么讲一下这个正解。（因为蒟蒻才学状压，所以很多地方都有初学者的痕迹，请大佬们海涵）

一开始迟迟无法理解这道题为啥能用$DP$，因为这道题对于每一个人来讲，他什么时候打饭既和他前面的人有关（能不能容忍他打饭），也跟后面的人有关（他能不能容忍他们打饭）。在我的印象中，这就叫后效性，是不符合$DP$的条件的。

~~所以需要用状态压缩解决~~

是的，状态压缩就是把状态化成二进制数存进数组中，然后保证当前状态下转移时是无后效性的。（多么妙啊）

那么我们考虑**状态**的设计思路：

首先，这个东西是一定要与枚举到的人有关的，所以开一维存当前枚举到哪个人。

其次，因为这个东西的转移边界是容忍后面的人吃没吃饭。那么就会有一维存状态：表示$i$和$i$后面$7$个人到底吃没吃饭。

最后，因为这个转移还和前面的人能不能忍你先吃饭有关。所以还需要开一维维护这个关系，存储上一个打饭的人到当前这个人的相对距离。

综上，设置：

$dp[i][st][k]$为：当第$1$到第$i-1$个人全部吃完饭后，$i$后$7$个人（把$i$也算上）吃没吃饭，$i$前面吃饭的人和$i$之间相对距离为$k$时的最小价值。（设$0$为没吃过，$1$为吃过）

那么答案就应该是$\min\{dp[n+1][0][k]\}\quad (k\in[0,8])$。这里的$k$的取值是因为数组不能开负数，所以把整个$k$的区间从$[-8,0]$挪到$[0,8]$了。

然后我们考虑怎么去转移。

（**注意：**这里的状态（是以十进制存储的）拆成二进制（有8位）后，最后面那位表示的不是最后的那个人，恰恰相反，是第一个人（即当前的那个$i$））

可以想到的是，对于每一个人，状态转移首先需要看这个人到底吃没吃，那么我们分两种情况讨论：

第一种：这个$i$已经吃了。这种情况下，$st\&1$应该为真。那么就可以直接去推下一个人，转移方程为：
$$
dp[i+1][j>>1][k+7]=\min(dp[i+1][j>>1][k+7],dp[i][j][k+8]);
$$
第二种：这个$i$还没有吃。这种情况下，是没有办法转移到$i+1$的，因为我们的状态设置的是前面的人都已经打完饭了（以排除后效性）。所以我们就要枚举状态来选择后面的7个人（当然包括自己）谁先打饭。

但是，这里需要细考虑一下：不是后面的7个人中的所有人都是可以打饭的。就比如后面的第$7$个人，如果后面的第一个人的忍耐度很小，一点都不能容忍自己后面的人先打，那么这个第$7$人就是选不了的。（没办法摊上暴躁同学就这样）

所以我们还需要在枚举的同时判断是否合法。

开一个变量$limit$储存目前可行的最大范围，随着枚举的继续，这个范围要么不动，要么缩小。所以如果当前枚举到的人超过了这个范围，那么他之后的所有人也都超出了这个范围，直接$break$掉就好。

这个时候的转移方程是：
$$
dp[i][j|(1<<h)][h+8]=\min(dp[i][j|(1<<h)][h+8],dp[i][j][k+8]+val[now])
$$
其中$val[now]$表示做这道菜的需要的时间。

（这里还有个性质：a|b-a&b==a^b）

所以就得出了完整的思路。

以及完整的代码：

```cpp
#include<stdio.h>
#include<string.h>
#define INF 0x3f3f3f3f
#define min(a,b) a<b?a:b
int n,ans,limit;
int t[1010],b[1010];
int dp[1010][1<<8][20];
//dp[i][st][k]表示当前为i人、其后状态为st、
//前一个吃饭的人离i距离为k时需要的最少时间。
//即上一个吃饭的人为i+k-8
char *p1,*p2,buf[100000];
#define nc() (p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++)
int read()
{
    int x=0,f=1;
    char ch=nc();
    while(ch<48){if(ch=='-')f=-1;ch=nc();}
    while(ch>47)    x=(((x<<2)+x)<<1)+ch-48,ch=nc();
    return x*f;
}
int main()
{
    int T;
    T=read();
    while(T--)
    {
        n=read();
        for(int i=1;i<=n;i++)
            t[i]=read(),b[i]=read();
        memset(dp,INF,sizeof(dp));
        dp[1][0][7]=0;
        for(int i=1;i<=n;i++)
            for(int j=0;j<(1<<8);j++)
                for(int k=-8;k<=7;k++)
                    if(dp[i][j][k+8]!=INF)
                    {
                        if(j&1)
                            dp[i+1][j>>1][k+7]=min(dp[i+1][j>>1][k+7],dp[i][j][k+8]);
                        else
                        {
                            limit=INF;
                            for(int h=0;h<=7;h++)
                                if(!((j>>h)&1))
                                {
                                    if(i+h>limit)
                                        break;
                                    limit=min(limit,i+h+b[i+h]);
                                    dp[i][j|(1<<h)][h+8]=min(dp[i][j|(1<<h)][h+8],dp[i][j][k+8]+(i+k?(t[i+k]^t[i+h]):0));
                                }
                        }
                    }
        ans=INF;
        for(int k=0;k<=8;k++)
            ans=min(ans,dp[n+1][0][k]);
        printf("%d\n",ans);
    }
    return 0;
}
```


