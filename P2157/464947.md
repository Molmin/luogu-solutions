思考到该题要用 DP 。

但是对于每个学生，他对答案的贡献与他后面连续几个学生有关（不是有那个容忍度嘛），那这就不满足 DP 的无后效性了（当前求解的子问题不受后续阶段的影响）。但由于 $B_i$ 非常小，所以考虑到用状压维护 $i$ 后面几个学生的买饭状态。

对于每个学生 $i$，影响其答案的还有上一个人 $j$，故我们还要加 上个人 这个状态。但又由于 $B_i$ 很小，而 $n$ 可能很大，若维护 $j$ 的编号，便会超空间，所以我们维护 $k$ 表示上个人与现在这个学生的距离差。$j$ 可能在 $i$ 前面，但是最多中间隔 $7$ 个人（$B_i$ 的最大限度），而 $j$ 也可能在 $i$ 后面，最多是 $i$ 后面的第七个（间隔六个），所以 $k$ 的范围 $-8\le k \le 7$。

综上，我们设计 DP 状态 ：

$dp[i][j][k]$ 表示编号在 $[1,i-1]$ 内的学生都买完了饭，$i$ 和其后面 $7$ 个人买饭的状态为 $j$ ，上个买饭的人与 $i$ 的距离（上个人的编号减去 $i$ 的编号）为 $k$ 时的最少时间。

其次，考虑转移。其实大部分的状压 DP 用刷表法更好，那我们也逝逝吧。

1. $i$ 已经买完饭了  
  此时有 $dp[i+1][j>>1][k-1]=\min(dp[i+1][j>>1][k-1],dp[i][j][k])$。这两个状态时等价的。首先要说明，$i$ 买没买饭在 $j$ 的二进制表示下是在第一位的（是从右往左数!）。所以将 $j$ 右移一位，$i$ 的状态就会被消掉。$k$ 就很好理解了，若 $i$ 的上一个人的编号比其小，则 $k<0$ ，$i+1$ 后, $k$ 明显要更小（绝对值更大）。另则同理。
  
2. $i$ 还没买饭。
  由于我们设计的状态要求，$[1,i-1]$ 都要买完了饭，所以此时不可以转移到 $i+1$ 。 那我们只好枚举先让 $i$ 及其后面 $7$ 个人中谁先买饭。这里要注意的是，我们要考虑到后面的人都能容忍的编号最大买饭者 $mx$。所以我们在枚举的过程中，对于每个人（编号为 $x$），每次求一下 $\min(mx,x+B_x)$ 。转移式 ：$dp[i][j|(1<<m)][m]=\min(dp[i][j|(1<<m)][m],dp[i][j][k]+cost(i+k,i+m))$ 。

然后有一个不那么有用的结论：
$(a\ or\ b) - (a\ and\ b)=(a\ xor\ b)$  
证明：将 $a$、$b$ 抽象为两个集合，$(a\ or\ b)$ 即为其并集，$(a\ and\ b)$则是交集，相减就是一个有一个没有的，化为二进制就是 $(a\ xor\ b)$

最后要注意的是，由于我们用的是刷表法，答案应该是在 $n+1$ 这一维里的。另外，$k$ 可能是负数，所以表示要集体加 $10$(当然大于等于 $8$ 的数都可以)。  

复杂度约为（最内层枚举谁先买饭极小，可视为常数） $O(2^{8}nΔk)$，$Δk=15$

代码：
```cpp
#include<cstdio>
#include<algorithm>
#include<cstring>
using namespace std;
typedef long long ll;
const ll inf=1e18;
ll T,n,t[1005],b[1005],dp[1005][1<<8][30],ans;
ll cost(ll x,ll y){return (!x)?0:(t[x]^t[y]);}
int main(){
	scanf("%lld",&T);
	while(T--){
		scanf("%lld",&n); ans=inf;
		for(int i=1;i<=n;i++) scanf("%lld%lld",&t[i],&b[i]);
		memset(dp,0x3f,sizeof dp); dp[1][0][-1+10]=0;
		ll maxn=(1<<8)-1;
		for(int i=1;i<=n;i++)
		  for(int j=0;j<=maxn;j++)
			for(int k=-8;k<=7;k++){
			  if(dp[i][j][k+10]==0x3f3f3f3f) continue; 
			  if(j&1) dp[i+1][j>>1][k-1+10]=min(dp[i+1][j>>1][k-1+10],dp[i][j][k+10]);
			  else{
			  	ll mx=inf;
				for(int m=0;m<=7;m++){
				  if((1<<m)&j) continue; //已经买过饭了 
				  if(i+m>mx) break; //剪枝，这里都忍受不了了，后面还可以吗 
				  mx=min(mx,m+i+b[m+i]);
				  dp[i][j|(1<<m)][m+10]=min(dp[i][j|(1<<m)][m+10],dp[i][j][k+10]+cost(i+k,i+m));
				}	
			  }
            }
		for(int k=-8;k<=0;k++) ans=min(ans,dp[n+1][0][k+10]);
		printf("%lld\n",ans);
	}
	return 0;
}
```
