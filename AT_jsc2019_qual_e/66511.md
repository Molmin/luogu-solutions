## 【翻译】
有$N$张卡片被放在一个$H$行$W$列的平面上，第$i$张卡上标有一个整数$A_i$，并被放在第$R_i$行第$C_i$列。

同一个格子上可能会有多张卡片。

现在你要先从每一行拿走一张卡，再从每一列拿走一张卡（也可以可以不拿），使得拿走的所有卡片上的数字和最大。

## 【思路（伪）】
我们考虑每一张卡片最多被拿一次，且这张卡片要么是在你从每一列中拿取时被拿走的，要么是在你从每一行中拿取时被拿走的，要么就没被拿走。

因此考虑建立网络流模型，对于每一个物品建立一个节点，并对于每一个出现的行、列**各**建立一个节点，然后每一个物品节点向它所**对应的**行、列各连一条容量无限，费用为物品价值的边。

然后建立一个超级源点$S$向每一个物品节点连一条费用为$0$，容量为$1$的点，建立一个超级汇点$T$，由每一个行、列节点出发向超级汇点连一条容量为$1$，费用为$0$的点。以保证每一个物品、每一行、每一列都最多只被选过一次。

然后对于建好的图跑最大费用最大流就可以得出能得到的最大权值了

吗？

很显然，$N\leq10^5$的数据范围不允许我们这么做。


因此考虑优化。

## 【思路（真）】
我们发现，我们建模好的网络流删去超级原点与超级汇点，会发现这是一个二分图。

然后跑二分图匹配就行了？答案是不行，还是跑太慢。

因此我们来看看这个图还有什么性质。

我们发现，我们最后匹配完时，左边（物品节点）的点数一定要等于右边（行列节点）的点数。也就是说不能这样
```
1 -- 2
    /
   /
  /
3
```
证明显然吧，你每一行每一列只能选一个啊，在此不赘述了

而且我们发现，对于我们得到的最终匹配的每一个子匹配（~~我不知道是不是这么叫~~），都满足这个性质（毕竟你每行每列最多选一个）。

因此我们考虑贪心，将左边节点的权值进行排序，然后将与这个节点有联系的行列节点加入一个集合，我们定义行列节点的一个集合的权值为这个集合还能承受的物品节点个数，因此每次选择最大的一个节点时，我们先判断目前的集合能不能承受这个最大的节点（因为这个集合一定是答案集合的子集，所以一定满足这个右边节点集合的大小大于我们在左边节点选过的点的集合大小），然后将这个集合的权值减一就行。如果与这个点有联系的行列节点已经在集合内了，只需减小集合权值（或不选）即可。

这个集合可以用并查集来维护，带个权就行。

下面简单说一下它的正确性（其实算是模拟一下过程）。

比如你有三个点
```
a[1] = 3 a[2] = 2 a[3] =1
```
它们分别在
```
(1, 2), (1, 1) (1, 1)
```

那么建出来的图就是
![](https://cdn.luogu.com.cn/upload/image_hosting/8up35uge.png)


我们先找到了权值为$3$的**一号节点**（图中序号为$1$，~~我不会告诉你是我一开始图画错了懒得改的~~）。

然后我们难道就直接让$1$对应$1$（行）了吗？

这样显然不是最优的，因此我们先把“1行”与“2列”存入同一个集合中，然后把整个集合的权值减一。

这样子一来，以后再用到这个集合时，我们可以自动默认**一号节点**匹配了“2列”。

就像上图，我们接下来跑**二号节点**时，把“1列”加入集合，然后再把集合权值减一即可。

最后加入**三号节点**时，我们仍然只是把集合权值减一，表明我们又选了一个**行列节点**。

这么写的好处及正确性就在于：

### 我们不直接确定每个点的匹配情况，只确定剩余可以被匹配的左边节点的个数

就是酱紫。

## 【p.s.】
我看网上很多其他的题解都用了$Hall$定理，我好像完全没用到啊。。。是我哪一步跳步了吗。。。（欢迎评论里指出）

## 【代码】（觉得我讲的不好的就来看看吧）
`其实很短`
```cpp
#include <algorithm>
#include <iostream>
#include <cstdio>
using namespace std;
typedef long long LL;
int n, h, w;
struct NODE{
	LL a;
	int r, c;
	inline bool operator < (const NODE &tmp) const
	{
		return a > tmp.a;
	}
}t[100010];
int fa[200010];
LL val[200010];

int find(int x)
{
	if(x == fa[x]) return x;
	return fa[x] = find(fa[x]);
}


int main()
{
	scanf("%d%d%d", &n, &h, &w);
	for (register int i = 1;i <= n;i ++) scanf("%d%d%lld", &t[i].r, &t[i].c, &t[i].a);
	sort(t + 1, t + n + 1);
	for (register int i = 1;i <= h + w;i ++)
	{
		fa[i] = i;
		val[i] = 1;//行列集合的原来每个节点都默认有1个物品节点的承受能力
	}
	LL ans = 0;
	for (register int i = 1;i <= n;i ++)
	{
		int xx = find(t[i].r), yy = find(t[i].c + h);
		if(xx == yy)
		{
			if(val[xx])
			{
				val[xx] --;
				ans += t[i].a;
			}
		}
		else
		{
			if(val[xx] + val[yy])
			{
				val[xx] += val[yy];
				val[xx] --;
				fa[yy] = xx;
				ans += t[i].a;
			}
		}
	}
	printf("%lld\n", ans);
}
```