题意：给定一个 $ 0/1 $ 的 $ n \times n $ 地图，要求至多反转两个格子使得在路径上只能全部经过 $ 1 $ 或全部经过 $ 0 $ 的情况下，不能从 $ (1, 1) $ 出发走到 $ (n, n) $。

考虑反转 $ (1, 2) (2, 1) (n - 1, n) (n, n - 1) $ 中的某些格子，使得 $ (1, 2) (2, 1) $ 相同，$ (n - 1, n) (n, n - 1) $ 相同，而这两者不同。

也就是最后成为类似

```
S0**
0***
***1
**1F
```

或者

```
S1**
1***
***0
**0F
```

的形式。

有了思路以后就是大力分类讨论的事情了。。。

我的方式比较复杂，是先比较若起点和终点有一边两个已经相同（前两个 `if`），就使另一边的两个与他们不同；否则就两边各反转一个。

具体见代码。（实现不是很优美 QAQ）

```cpp
#include <bits/stdc++.h>
using namespace std;
string s[201];
int main()
{
	int t;
	scanf("%d", &t);
	while(t--)
	{
		int n;
		scanf("%d", &n);
		for(int i = 0; i < n; i++)
			cin >> s[i];
		if(s[0][1] == s[1][0])
		{
			printf("%d\n", (s[0][1] == s[n - 1][n - 2]) + (s[0][1] == s[n - 2][n - 1]));
			if(s[n - 1][n - 2] == s[0][1])
				printf("%d %d\n", n, n - 1);
			if(s[n - 2][n - 1] == s[0][1])
				printf("%d %d\n", n - 1, n);
		}
		else if(s[n - 1][n - 2] == s[n - 2][n - 1])
		{
			printf("%d\n", (s[n - 1][n - 2] == s[0][1]) + (s[n - 1][n - 2] == s[1][0]));
			if (s[n - 1][n - 2] == s[0][1])
				printf("%d %d\n", 1, 2);
			if (s[n - 2][n - 1] == s[1][0])
				printf("%d %d\n", 2, 1);
		}
		else
		{
			printf("2\n");
			printf("1 2\n");
			if(s[n - 1][n - 2] == s[1][0])
				printf("%d %d\n", n, n - 1);
			if(s[n - 2][n - 1] == s[1][0])
				printf("%d %d\n", n - 1, n);
		}
	}
	return 0;
}

```