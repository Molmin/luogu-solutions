### 写在前面的闲话
~~这题翻译我写的~~

本文在博客食用更佳https://www.luogu.org/blog/jch2008/

第一篇题解，求支持qwq

声明：这篇题解很长，可能会占用您的时间，敬请谅解！

-----------------------------------------------------分割线---------------------------------------------------

咳咳，这题，如果直接暴力枚举每一个点是否擦掉，如果没成功就继续枚举，成功了就取min，时间复杂度就会十分难算，极不稳定~~虽然可能能卡过~~。因此，为了~~装逼~~锻炼思维，我们需要优化该算法。

聪明的你一看样例，发现输出都是2，而你也知道存在输出是1的情况，顿时来了灵感,：我们能否证明，最多删除两个，就能使这个图变得不连通呢？

### 华丽丽的证明过程：
现在，你拥有一个3*4的长方形，1表示涂色，0表示不涂色。
```
1111
1111
1111
```
那么， 请把目光聚焦在四个角落上， 只要有任意一个角落是1，我们就可以将他它相邻的两个点擦掉（这里选的是右下角），形成
```
1111
1110
1101
```
这样的局面，于是，整个图就变得不联通了。

很好，那么，要是4个角都没有涂色，该怎么办呢？

先画出图：
```
0110
1111
0110
```

于是，你又将目光聚焦在落单的，最边上的6个点上。我的表述可能不清楚，就是位于{1,2}、{1,3}、{2,1}、{2,4}、{3,2}、{3,2}这几个点。它们本有三个相邻点，但现在因为角上的被擦掉，只剩两个了。于是，我们又可以将这两个点擦掉，形成

```
0100
1011
0110
```

这样的局面，于是，整个图就又变得不联通了。

虽然在这个图里，最外面的边上点已经擦完了，但为了思维的严谨性，我们还需证明更大的图。稍微想一下便可得知，在更大的图里，如果我们把与角相邻的边上点擦去，最外面的边上，还会有靠边的点，本来有三个相邻。现在因角相邻的边上点被擦去了，只剩两个相邻了……于是，我们就可以“断绝它的后路”，使得图变得不联通。

Q:那么，如果把整一圈边都擦去呢？

A:那么，你就得到了一个更小的长方形。那么现在， 请把目光聚焦在小长方形的四个角落上，只要有任意一个角落是1，我们就可以将他它相邻的两个点擦掉……

**于是，我们得出了这道题的证明过程。**

看到这里，你瞬间想到了思路：只要求出每个点相邻的点数，然后求一个min，就可以保证把这个点封死，得到这题的正确答案了！于是，你迫不及待地开始敲了起来，边敲边想：不对呀，这种做法跟刚才的证明过程没关系呀，我白看了这么长的题解！写题解的一看就是个菜鸡！结果一交，听取WA声一片。。。

别急，让本蒟蒻造个数据。
```
5 5
11111
11111
00100
11111
11111

AC answer:
1
YOUR answer:
2
```

是不是崩溃了。。。

所以，有强迫症的同学（我绝对不会告诉你说的就是我）请注意了，装逼一时爽，一直装逼。。。两行泪。所以，请牺牲一些时间复杂度，写一个dfs。

此题dfs的思路很简单，就是枚举删掉的点，跑一遍dfs,看看能否使得只删掉这一个点，使图变得不连通。
 
但是，此题有一坑点，就是我翻译的输出部分那块。要输出-1的！当一共只有0个，1个，2个时，无论怎么删，也都不能成功！（ps:“根据定义，只有一个方格的集合或者不包含任何方格的集合也是联通的。”看到没！？）
 
 好，思路就讲到这儿，接下来是你们最喜欢的部分——~~求点赞关注~~上代码。
#  code:

=

```cpp
//建议的阅读程序顺序：头文件区（自己编的）->主程序->主程序顺序下的子函数 
#include<iostream>//鄙人不喜欢万能库，一个是map重定义的原因，另一个是窝有强迫症（捂嘴） ,另外，本菜鸡还喜欢用short鸭，register鸭，宏定义鸭，但为了水题解，还是删掉了 
#include<cstring>
using namespace std;
int n,m;
char map[51][51];//输入的图 
int dx[5]={0,-1,1,0,0},dy[5]={0,0,0,-1,1};//行走数组（窝取的名） 
bool vis[51][51];//标记数组 
void dfs(int x,int y)
{
	if (x<1||x>n||y<1||y>m) return;//判断出界，可有可无 
	vis[x][y]=true;//打标记 
	for(int w=1;w<=4;++w)//这个1到4还是0到3看个人喜好吧 
	{
		int xx=x+dx[w],yy=y+dy[w];//行走数组，模拟每种步数可能出现的情况，十分好用 
		if (map[xx][yy]=='#'&&!vis[xx][yy]) dfs(xx,yy);//如果符合，继续深搜 
	}
	return;
}
inline bool check(int x,int y)//inline优化，看看就好 
{
	memset(vis,false,sizeof(vis));//清空标记数组
	bool flag=false;//这货的用处往下看就知道了 
	vis[x][y]=true;//打上该点的标记 
	for(int i=1;i<=n;++i)
		for(int j=1;j<=m;++j)
		{
			if (map[i][j]=='#'&&!vis[i][j])//如果找到了未改变的点 
			{
				if (flag) return true;//第一次警告（试跑一遍删除该点后剩下的点，看能否一次性连光） 
				else flag=true;//第二次驱离（成功） 
				dfs(i,j);//跑dfs 
			}
		}
	return false;//如果没找到（依然全部连通），wasted 
}
int main(void)
{
	ios_base::sync_with_stdio(false);//cin优化，看看就好，适合窝这样的强迫症（再次捂嘴） 
	cin.tie(0);
	cin>>n>>m;//读入尺寸（废话） 
	int cnt=0;//涂色格子数 
	for(int i=1;i<=n;++i)
		for(int j=1;j<=m;++j)
		{
			cin>>map[i][j];//读图 
			if (map[i][j]=='#') ++cnt;//统计涂色格子数 
		}
	if (cnt<3) {cout<<"-1\n";return 0;}//本题坑点：个数<=2，要输出-1的！（看到这里感到意外的，说明您没有仔细阅读本题解，请翻到代码上方） 
	for(int i=1;i<=n;++i)
		for(int j=1;j<=m;++j)
			if(map[i][j]=='#')//枚举 
				if (check(i,j)) {cout<<"1\n";return 0;}//如果成功，立刻输出-1 
	cout<<"2\n";//没有成功过，输出 2
	return 0;
}
```
代码在此，切勿copy~

### 附录（虽然对于您们这些巨佬可能没什么用）：

dfs模板：

```
int dfs(int num)
{
    if(满足输出条件)
    {
        输出解或记录解；
    }
    else
    {
        for(int w=1;w<=尝试方法数;w++)
            if(满足进一步搜索条件)
            {
                为进一步搜索所需要的状态打上标记;
                dfs(t+1);
                恢复到打标记前的状态;//也就是说的{回溯一步}
            }
    }
}
```
ps:转载自@ybb756032937巨佬的P1605题解，如有不当之处请联系我删除


~~呼，终于看完了~~

~~呼，终于写完了~~

再次含泪声明，这是本蒟蒻第一次写题解，如有不当或可改进之处，请在此（或私信我）之处，谢谢大家的时间，再见！