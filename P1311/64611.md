这道题其实不用那么麻烦啊，还是很好拿分（满分）的。
在$O(kn)$的做法里，我看到的里面我这个是最简单的了。

毕竟直接想出来$O(n)$的正解思维难度有些太高，我这个$Code1$里的做法则更适合在考场上写出来。

首先，在考场上我们的目标是得分，一看数据范围，分的不是很细致，所以这个题的各个解法的复杂度应该差距比较大，所以大眼睛一看，最最没有智商的直接暴力的做法$O(n^3)$稳了，稍微优化一点点只枚举同色区间就$O(k*n^2)$了，50$pts$到手$???$，所以现在你心里应该稳了，这就是一道水题不用慌。

我们再想想，为什么每次我一定要去在一个区间里去找啊找，找到一个合法的才能知道这个区间能算入答案呢，中间有好多位置我需要访问好多遍，我能不能一遍完成呢。然后发现其实是可以的，可以从左往右依次扫过去的过程中记下在$i$位置之前已经出现了几个颜色一样的了，记为$num[i]$，然后再保存一下当前最后的一个够便宜的客栈的位置，记为last，每次遇到一个新的当前颜色的客栈，我就给答案加上最后一个够便宜的客栈之前的相同颜色的个数，即就是加上$num[last]$。然后扫一遍n一个颜色就讨论完了呐，我们去枚举一下每种颜色，答案就出来啦！

### $Code1:$
```
#include<bits/stdc++.h>
using namespace std;
const int maxn=2000010;
int col[maxn],cost[maxn];
int num[maxn];//在i位置前面有几个当前颜色 
int main(){
    int n,k,p;
    cin>>n>>k>>p;
    for(int i=1;i<=n;i++){
        scanf("%d%d",&col[i],&cost[i]); 
    }
    int ans=0;
    for(int t=0;t<=k-1;t++){
        int last=0;num[0]=0;
        for(int i=1;i<=n;i++){ 
        	if(cost[i]<=p) last=i;
        	num[i]=num[i-1]; 
            if(col[i]==t) ans+=num[last],num[i]++;
        }
    } 
    cout<<ans;
    return 0;
} 
```
虽然这个做法已经可以满分了。

但是其实做完我们就能发现，我们还是重复访问了好多遍，其实像这个“$if(cost[i]<=p)$”我们对一个点访问了$k$次，还是不够优秀，我们可以发现其实我们可以一次就把所有的颜色讨论完！

我们用一个$cnt[i]$表示$i$颜色出现了几次了。用一个$last[i]$记下上一次出现$i$颜色在哪个位置。对于$i$颜色（不是第$i$个颜色）只要最后一个满足价格的位置在$last[i]$之后，$cnt[i]$就可以全部计入答案；如果最后一个满足价格的位置如果在$last[i]$之前，就说明当前的$cnt[i]$还不能直接计入答案，但是我们还是可以把上一次的可行的$cnt[i]$计入答案的啊，所以我们用一个$can[i]$来保存上一次的$cnt[i]$（若是这次可行，就把$can[i]=cnt[i]$，下一次就用到的时候就保存下来了）。

### $Code2:$
```
#include<bits/stdc++.h>
using namespace std;
int last[52],cnt[52],can[52];
int main(){
    int n,k,p;
    cin>>n>>k>>p;
    int now=0,ans=0;
    for(int i=1,col,cost;i<=n;i++){
        scanf("%d%d",&col,&cost); 
        if(cost<=p) now=i;
        if(now>=last[col]) can[col]=cnt[col];
        ans+=can[col];
        cnt[col]++,last[col]=i;
    }
    printf("%d",ans);
    return 0;
}
```
这个第二个办法直接考场上打出来的都是大佬吧。。。至于我这个蒟蒻就追求一个用第一种优化暴力的方法$AC$就好。