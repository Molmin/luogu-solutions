题目描述

丽江河边有 n 家很有特色的客栈，客栈按照其位置顺序从 1 到 nn n 编号。每家客栈都按照某一种色调进行装饰（总共 k 种，用整数 0 ~ k−1 表示），且每家客栈都设有一家咖啡店，每家咖啡店均有各自的最低消费。

两位游客一起去丽江旅游，他们喜欢相同的色调，又想尝试两个不同的客栈，因此决定分别住在色调相同的两家客栈中。晚上，他们打算选择一家咖啡店喝咖啡，要求咖啡店位于两人住的两家客栈之间（包括他们住的客栈），且咖啡店的最低消费不超过 p 。

他们想知道总共有多少种选择住宿的方案，保证晚上可以找到一家最低消费不超过 p 元的咖啡店小聚。
输入输出格式
输入格式：

共n+1 行。

第一行三个整数 n,k,p，每两个整数之间用一个空格隔开，分别表示客栈的个数，色调的数目和能接受的最低消费的最高值；

接下来的 n 行，第 i+1 行两个整数，之间用一个空格隔开，分别表示 i 号客栈的装饰色调和 i 号客栈的咖啡店的最低消费。

输出格式：

一个整数，表示可选的住宿方案的总数。

## 思路：
虽然我跑的很慢（336ms），但这绝对是既好像有好写的思路

相信各位仁兄一定都会写这道题O(n^2)的暴力

然后有的人就开始写各种优化，比如说（线段树，st表）

但其实根本无需如此复杂（~~其实是我不会~~），我们只需要前缀和即可

怎么做呢？

在读入的时候，我们每读一个，就记录此时各种颜色已经有多少个，此时复杂度为O（nk）

然后我们开始跑一边暴力

但注意，这不是真正的暴力，因为这里我没有枚举右端点，我枚举的是咖啡馆

当有一家咖啡馆的消费已经满足要求时，我们记录下这家咖啡馆是哪家

此时左端点是个定值，而右端点个数可以通过前缀和完成O（1）的查询

答案就出来了

复杂度：O（nk+玄学）

## 代码：
```cpp
#include<iostream>
#include<cstdio>
#define rii register int i
#define rij register int j
using namespace std;
struct kz{
	int colour,cost;
}z[200005];
int n,k,p,ans,x[200005][55];
int main()
{
	scanf("%d%d%d",&n,&k,&p);
	for(rii=1;i<=n;i++)
	{
		int ltt,kkk;
		scanf("%d%d",&ltt,&kkk);
		z[i].colour=ltt;
		z[i].cost=kkk;
		for(rij=0;j<=k-1;j++)
		{
			x[i][j]=x[i-1][j];
		}
		x[i][z[i].colour]++;
	}
	for(rii=1;i<=n;i++)
	{
		int c=z[i].colour;
		int now=n+1;
		for(rij=i;j<=n;j++)
		{
			if(z[j].cost<=p)
			{
				now=j;
				if(now==i)
				{
					now++;//边界处理，如果满足条件的咖啡馆就是左端点，那么要+1（两个人不可能住同一个宾馆）
				}
				break;
			}
		}
		ans+=x[n][c]-x[now-1][c];
	}
	cout<<ans;
}
```