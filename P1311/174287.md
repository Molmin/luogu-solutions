# 洛谷 P 1311 选择客栈	

2019 11 14修改

这道题是初次看到只想到了打暴力，然而数据200000让我意识到这个想发是错误的。

通过读题我们看到，要选择合适的客栈其实是有两个条件的：1.色调一致;2.两客栈中有满足咖啡店的最低消费水平低于p。

那么这样我们不难先想到，先将客栈用数组分开存储，然后进行计算
 
然而分开存储是有一个问题的，在本题中，其决定性作用的仅是小于p的数，且小于p的数所决定的也不过是第二个条件而已，只用来判断方案，所以在这里用一个bool数组存储两个相同色调的旅馆之间（包括本身）是否存在小于p的值。为了操作方便，我们选择用前一个点记录从该客栈到下一相同色调的客栈是否有符合条件的咖啡厅。代码如下：
    
```cpp
for(int i = 1 ; i <= n ; i ++ )
	{
		scanf("%d%d",&a,&b);
		++pd[ a + 1 ];
		if(b <= p)
		{
			for(int j = 1 ; j <= k ; j ++ )
			pay[j][pd[j]] = 1;
            pay[a+1][pd[a+1]-1] = 1;
		}
	} 
 ```
 解释一下，在这里，pd数组作为指针，pay数组存储区间是否有符合条件的咖啡厅
 
 那么接下来就是对数据的处理了
 
### ~~不会画图就用文字代替了~~
对于如下1，2，3，4，5个相同色调的客栈其对应的bool值如图

1 2 3 4 5

0 0 1 0 0

45之间，没有符合条件的，所以f4、f5均为0，而3——4之间有符合条件的咖啡馆，那么f5 = 2（4和5）但到了2，3之间，并没有符合条件的咖啡馆，但由于3,所以2仍可以与4,5搭配，f2 = 2 = f3

所以我们就可以得到如下结论，设相同颜色旅馆有m个，第n个旅馆的bool值若为1,那么fn = m - n，若为0,那么 f（n+1），当然由于存储的是一个二维数组，形式会有些不同，见代码：
```cpp
for(int i = 1 ; i <= k ; i ++ )
	{
		for(int j = pd[i] - 1; j ; j -- )
		{
			if(pay[i][j])
                f[i][j]= pd[i] - j ;
            else
                f[i][j] = f[i][j+1];
            ans += f[i][j];
		}
	}
```
所以AC代码就可以写出来了！
AC代码：
```cpp
#include<iostream>
#include<cstdio>
#define MAXN 1000005
#define min(x,y) x<=y?x:y


using namespace std;

int n,k,p;
int ans = 0 ;//存储答案
bool pay[55][MAXN];//用来存储区间最小值;
int f[55][MAXN];//递推数组
int pd[55];//作指针;

int main()
{
	int a,b;
	scanf("%d%d%d",&n,&k,&p);
	for(int i = 1 ; i <= n ; i ++ )//输入并求区间是否有符合条件的
	{
		scanf("%d%d",&a,&b);
		++pd[ a + 1 ];
		if(b <= p)//若有
		{
			for(int j = 1 ; j <= k ; j ++ )
			pay[j][pd[j]] = 1;
            pay[a+1][pd[a+1]-1] = 1;//注意本身也要更新
		}
	} 
	for(int i = 1 ; i <= k ; i ++ )//递推
	{
		for(int j = pd[i] - 1; j ; j -- )//最后一个肯定不满足，可以不计算
		{
			if(pay[i][j])
                f[i][j]= pd[i] - j ;
            else
                f[i][j] = f[i][j+1];
            ans += f[i][j];
		}
	}
	printf("%d\n",ans);//输出答案
	return 0;
} 
```
最后希望可以对大家有所帮助