最暴力的O（$KN^2$） 算法由于太难实现，而且会 TLE 这里就不过多赘述  
来介绍一下我的O($KN$) 的算法 ~~（似乎也不是最优解，看楼上大佬，O($N$) 19行不压行代码解决的真是强）~~  

---

 我的做法是：从前往后扫，计算每一种颜色的一个区间`[l,r]`，这个区间可以为该区间后面的每一个该颜色的节点贡献一次，而该区间的前面一部分已经被之前的区间贡献过了  

说的通俗一点，就是去枚举每一个可以当作前面的节点所在的区间`[l,r]`  

---

更新 `ans`（答案）时我分三种情况讨论：  
**1**  ：   
当`l == r`的时候，即`cost[l] ` $\leq$ `p` 由该节点可以向后面的所有节点更新一次答案，并将该节点删除  
**2**  ：  
当`l ` $\ne$ ` r `的时候，`cost[r] `$\leq$ `p`时，可以以`r`为第二个点，`[l,r)`区间内同颜色的点为第一个点，更新一次答案，同时也可以以区间`[l,r]`内的每一个点作为第一个点，以后面剩下的所有点为第二个点在更新一次答案，并将该区间删除  
**3**  ：  
最后一种情况就是当`l ` $\ne$ ` r `的时候，`cost[r] `$\ne$ `p`时 ，但是区间`[l,r]`中有可以当做中点（喝咖啡）的点，这种情况比较普遍，也比较难调。这种情况下，可以将`[l,r)`内的点作为第一个点以`[r,n]`的点作为第二个点去更新答案，但是需要注意的是，**这个`r`节点不能删除**，该区间内的其余点可以删除了。  
注意：不能删除的原因是，我们枚举的是可以做第一个点的区间，但是这个`r`点并没有作为一次第一个点去参与更新答案，所有显然是不行的。  
举个例子：假设这个`r`与下一个开始的`l`之间存在着 小于等于 p的点，那么，这个`r`点是可以去更新答案的，但是删除了之后，谁去更新这个答案呢？

----

### Code：  
```
#include <algorithm>
#include <iostream>
#include <cstdio>
using namespace std;
const int maxn=2e5+7,maxk=57;

int n,k,p;
int cost[maxn],color[maxn];//cost改bool 
int siz[maxk];//还没有遍历的该颜色块的数量 
int mink[maxk];//当前搜索的区间中该颜色组之间的最小值 
int f[maxn];//当前遍历的区间长度区间
int ans;//统计答案 

int main()
{
	scanf("%d%d%d",&n,&k,&p);
	for(int i=1;i<=n;++i)
	{
		scanf("%d%d",&color[i],&cost[i]);
		++siz[color[i]];//颜色的房间数 
	}
	for(int i=0;i<k;++i) mink[i]=-1;//将起始值初始化为-1
	//如果没有处理过的话，对于K的循环要从0开始！！！
	//卡了我好15min QwQ 
	
	for(int i=1;i<=n;++i)
	{
		int x=color[i];
		f[x]++;
		//遍历到的当前区间长度 
		//----------以下为 判断是否区间长度为1，且满足条件 
		bool flag=0;//
		if(mink[x]==-1) mink[x]=cost[i],flag=1;
		//----------以上为 判断是否区间长度为1，且满足条件 
		//----------以下为 更新满足p的情况 
		for(int j=0;j<k;++j) if(mink[j] != -1)
			mink[j]=min(mink[j],cost[i]);
		//----------以上为 更新满足p的情况 
		//----------以下为 三种情况的分类讨论 
		if(cost[i] <= p && !flag)//第二种情况 
		{
			ans+=f[x]-1;
			siz[x]-=f[x];
			ans+=siz[x]*f[x]; 
			//--------以下为 删除区间 
			f[x]=0;
			mink[x]=-1;
			//--------以上为 删除区间 
		}
		else if(cost[i] <= p && flag)//第一种情况 
		{
			siz[x] -- ;
			ans+=siz[x];
			//--------以下为 删除节点 
			f[x]=0;
			mink[x]=-1;
			//--------以上为 删除节点 
		}
		else if(mink[x] <= p)//第三种情况 
		{
			ans+=(f[x]-1)*(siz[x]-f[x]+1);
			siz[x] -= f[x]-1;
			//---------不能删除r节点，保留了最后的r节点 
			mink[x]=p+1;
			f[x]=1;
		}
		//----------以下为 三种情况的分类讨论 
	}
	printf("%d\n",ans);//输出 
}
*/
```
发福利附带一组数据~~（最水的一组）~~  
```
in:
5 2 10
0 11
1 5
0 12
0 6
1 11

out:
4
```
---

~~祝愿每一个人都能和想要的人去浪漫的咖啡馆喝一杯咖啡~~