【背景】这道题是noip2011的day2 t1，然而拿到后我并没有很明显的思路，只想到了On^2的算法（果然我还是太弱了）。然而仔细观察数据之后我发现k的数值很小（只有50），根据以往的经验，要从小的数据找突破口，于是经过思考我终于想出了很暴力的Onk算法（貌似远不是最优复杂度）。


【解法】注意这个题只要找出住宿方案数，因此两个客栈之间只要有一个合法的咖啡店即可，即使有多个咖啡店合法方案数也不会改变。

首先对于每一个点，我们都记录在这个点之前（包括这个点）各种颜色出现的次数，再记录这个点之前（包括该点）第一个花费小于p的点，这个过程是Onk的。

完成预处理之后，我们枚举每一个点，根据预处理可以直接找到第一个合法点的位置，然后答案加上这个点之前同一颜色的数量即可，这个过程是On的。

注意，如果一个点之前的第一个合法点就是他自己，那么这样处理就会产生两个人住了一个客栈的情况，因此此时答案要减1。

结合代码理解一下。


【代码】（看不懂可以私信我）


```cpp
#include<cstdio>
#include<iostream>
using namespace std;
int n,k,p,b,ans;//b:客栈消费 
int a[200100],co[200100][55],jp[200100];
//a:客栈色调 ;co[]:记录颜色出现次数 ;jp[]:该点之前第一个合法的客栈 
inline int red()//读入优化 
{
    int X=0,w=1;
    char ch=getchar();
    while(ch<'0'||ch>'9')
    {
        w=(ch=='-' ? -1 :1);
        ch=getchar();
    }
    while(ch<='9'&&ch>='0')
    {
        X=X*10+ch-'0';
        ch=getchar();
    }
    return X*w;
}
int main()
{
//    freopen("hotel.in","r",stdin);freopen("hotel.out","w",stdout);
    n=red();k=red();p=red();
    int i=0,j=0;
    for(i=1;i<=n;i++)
    {
        a[i]=red();b=red();
        for(j=0;j<k;j++)
        {
            co[i][j]=co[i-1][j];//记录颜色出现次数 
        }
        co[i][a[i]]++;
        if(b<=p)
        {
            jp[i]=i;
        }
        else
        {
            jp[i]=jp[i-1];
        }
        //记录该点之前第一个合法客栈（目的:可以直接跳过去，节约时间） 
    }
    for(i=1;i<=n;i++)
    {
        ans+=co[jp[i]][a[i]];//更新答案 
        if(jp[i]==i) ans--;//如果两个人住同一客栈，答案减1； 
    }
    printf("%d\n",ans);
    return 0;
}
```