很容易想到枚举，枚举旅店1，旅店2，再枚举中间是否有符合最低消费的.复杂度O（n^3）.看数据范围：


（n为客栈数，k为色调数，p能接受的最低消费值）


对于 30%的数据，有 n≤100； 对于 50%的数据，有 n≤1,000； 对于 100%的数据，有 2≤n≤200,000，0<k≤50，0≤p≤100， 0≤最低消费≤100.


肯定不能枚举n了，算法应该从k和p入手，n作为外层循环，只循环一次.如果能实现这样的算法，一定不会超时，因为k和p都很小.


如果想省空间，可以一边输入一边处理，毕竟n只循环一次.


枚举两个客栈，再找其中间的符合要求的客栈很费时，应该枚举一个客栈，这样可以将n^2改为n.原理如下：


设可选的方案数是ans，当前扫描到底i个客栈的数据，且i的色调是ci.那么，应该从i往前枚举，枚举到第一个色调为ci的客栈为止，其中符合消费标准的客栈数加入ans.一直扫描到最后一个客栈，算法结束。


然而，如果直接枚举，则复杂度不会优化，因此，开一个数组sum[51]来记录i之前的和i色调相同的客栈数，为sum[ci].即一个人住在sum[ci]这么多客栈中的一个客栈里，另一个人住在i里.然而，这不能保证两个中间有符合消费要求的咖啡馆.所以，要再开一个数组ac[51].（ac代表actual，即实际可住的和i相同色调的客栈数.）ac和sum的区别在于，sum是i之前所有色调为ci的客栈总数，而ac是sum的这些客栈中，与i中间夹有合适的咖啡馆的客栈总数.所以，只要维护sum，进而维护ac，然后将每个ac[i]加入ans中，最后输出ans即可.

/\*


for(int i=1;i<=n;i++)

{
此处维护sum，维护ac；



    Sum+=ac[i];

}
输出ans;

\*/

对两个数组的维护：


维护sum很简单：当前客栈的颜色是ci，那么sum[ci]++;


对于ac的维护：如果当前客栈的最低消费<=p，说明这之前的所有客栈都和以后要枚举的客栈中间都夹有符合要求的咖啡馆，则ac[q]=sum[q].（q是枚举从1到k的所有整数）

```cpp
#include<cstdio>
#include<iostream>
#include<cstring>
#include<cmath>
using namespace std;
int sum[51]={0},ac[51]={0};
int n,k,p;
int ans;
int main(){
    cin>>n>>k>>p;
    int x,y;
    for(int t=1;t<=n;t++)
    {
        scanf("%d%d",&x,&y);
        sum[x]++;
        if(y<=p)
        {
            for(int i=0;i<=k;i++)
            {
                ac[i]=sum[i];
            }
        }
        ans+=ac[x];
        if(ac[x]==sum[x])ans--;
    }
    cout<<ans;
    return 0;
}
```