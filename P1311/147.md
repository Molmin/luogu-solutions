题解：

首先在此声明，本人所执笔的题解绝对优于黎同学所发的题解！

```delphi
var i,j,k,m,n,p,q,sum:longint;
    a,b,c:array[0..100] of longint;
begin
  read(n,k,p);
  for i:=1 to n do
  begin
    readln(k,q);
    if q<=p then m:=i;{如果咖啡店的最低消费地于标准，那么记录其位置}
    if (m>=a[k]) then c[k]:=b[k];{如果在当前颜色的酒店之前有出现过同样颜色的酒店那么记录当前同种颜色的酒店的出现次数}
    a[k]:=i;{记录同样颜色的酒店最后一次的出现位置}
    sum:=sum+c[k];{对应点原理（这里再做一个补充说明：应为每一个酒店都可以作为对应点，所以不需要再去加上任何的判断语句），记录住宿的方法}
    inc(b[k]);{记录出现次数的总数}
  end;
  write(sum);
end.
```

这里对于本题解的一些较难理解的地方做详细说明：

“09”这行肯定是令人费解的，不过他和“10,11,12”这三行起着牵制的作用，使得本体界无比简单。首先我们看，当找到一个旅店，在右边，若是其左边有一个符合要求的咖啡店，那么再往左边看，如果有一个颜色相同的旅店，那么就算是一种住宿方法了，那么如果以这个右边的旅店作为对应点，将所有在左边而且颜色与之相同的旅店数相加，就能得出很多种住宿方法了。那么用这个办法，用所有的对应点对应过去，就能最快的时间内找出所用的酒店了。

可思想说起来简单，程序想要写的精简也是不那么容易的。先对程序内的变量做些解释：

a数组是记录同一种颜色中的酒店所出现的最后一次的位置；b数组记录同一种颜色的酒店的出现次数，而c数组则是临时记录当前同样颜色的酒店出现的次数，也就是为找对应点而进行的临时记录。

那么，通过使用上述方法，仅仅需要一个for循环，即可解决问题，当时读入，立即处理，这才是此题解的精髓所在，远胜于其他题解
