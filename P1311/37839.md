## **高级的递推算法请看众神犇的代码。。。 **

## **我只是为像我这样的蒟蒻们提供一个暴力。。。(大犇勿喷...蒟蒻在颤抖) **

# ** 暴力 **

### 思路

用数学方法计算出所有(包括可行和不可行)方案数，然后再减去不可行的方案数，就得到了答案。

### 总方案数计算方法(知道等差数列前n项和公式的朋友就跳过吧...)

因为对于一个点 i ，其颜色为 k ，它只会与其它颜色为 k 的点配对(不考虑是否是可行解)

那么给这些颜色编号:1，2，3 ... n;

拿1和其它n个点配对，可产生(n-1)种不同的方案，于是答案加上(n-1)。

**再**拿2和其它点配对，除去已经用过的点1(因为(1,2)这个点对在上一步已经考虑到了)，还有(n-2)个点，于是答案再加上(n-2)。

**再**拿3和其它点配对，除去已经与3配对过的点1和2，还有(n-3)个点，于是答案再加(n-3)。

......
这样一直下去，我们发现，总的方案数就是(n-1)+(n-2)+...+2+1，由等差数列前n项和的公式得:

原式=(n-1+1)(n-1)/2;

** 所以我们只需要统计在整个客栈序列中，每种颜色出现的次数，然后就可以O(k)计算出总方案数(k为颜色种数)。 **

### 不可行方案的计算方法

** 先看看不可行的方案的特点 ***

用w[i]来表示编号为i的客栈的最低消费。

对于一对颜色相同的点i，j，若它们形成的方案是不可行的，那么显然这段区间中所有点的权值w[i...j]都大于p。

逆过来思考，** 对于一段区间i...j，使得w[i...j]都>p(我简单粗暴地称这样的区间为“大于p的区间”)，则其中若存在相同颜色的点对(x，y)，那么点对(x，y)一定为不可行方案。 **

而如果区间中存在某种颜色k的客栈n个，那么这种颜色在该区间内的不可行方案数为:(l[k]-1)\*l[k]/2;与上文的公式一样。。。其中l[k]为颜色k在该区间内出现的次数。

** 所以只需要找出所有“大于p的区间”，并用相同的公式计算出每个区间内每种颜色的不可行方案数即可。**

计算时有一些细节，需要注意;

1.每次计算完大于p的区间内的不可行方案数时，一定要将l[ ]数组清零，便于下次计算。

2.如果某“大于p的区间”长度为一，那这个区间怕是没什么用。。。

3.完全可以一个循环解决问题。。。先减去不可行方案数，再加上总方案数，显然也是可以的。。。

4.事实证明这个方法可以ac。

上代码:

(ll代表当前“大于p的区间”的总长度，last表示上一个客栈是否符合要求，用来判断大于p的区间的长度的，total[ ]用来记录整个区间中每种颜色出现的次数，用来计算总方案数)


```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<algorithm>
#include<cmath>
using namespace std;
int n,k,p;
long long sum;
int w[200005],color[200005],total[52],l[52],ll;
bool last;
int read()
{
    char c=getchar();
    int x=0;
    while(c<'0'||c>'9') c=getchar();
    while(c>='0'&&c<='9') x=x*10+c-'0',c=getchar();
    return x;
}
int main()
{
    n=read();k=read();p=read();
    for(int i=0;i<n;i++) {
        color[i]=read();w[i]=read();total[color[i]]++;
        if(w[i] <= p ) {
            if(last == 0) {
                if(ll <= 1) {
                    last = 1;ll = 0;l[color[i-1]] = 0;continue;
                }
                   if(ll > 1) { 
                       last = 1;
                      for(int j=0;j<k;j++) {
                          if(l[j] <=1) {l[j] = 0;continue;}
                           sum=sum-(l[j]-1)*l[j]/2;l[j]=0;
                     }
                   }
               }
        }
        else {
            last = 0;l[color[i]]++;ll++;
        }
    }
    for(int i=0;i<k;i++) {
        if(l[i] <= 1) {l[i] = 0;continue;}            
        sum=sum-(l[i]-1)*l[i]/2;l[i]=0;
    } 
    for(int i=0;i<k;i++) {
        sum=sum+(total[i]-1)*total[i]/2;
    }
    printf("%d",sum);
    return 0;
}
```