这题我认为其实并不是完全的多维动态规划。
其实只是一个矩形的数塔问题。
用一样的方法解不一样的题即可。

那么？怎么解？
动态规划三要素：阶段、状态、决策。
那么这题的三要素就是：
阶段：矩形中每一个点。
状态：到当前这个点的最大能量（最优解）。
决策：从三步中选一步走到下一个新状态。
三要素明确完毕，即可开始写题。

我的代码都注释很详细了，有些细节大家需注意。

```cpp
#include<iostream>

using namespace std;

int n,m;				//m行n列
int map[1001][1001];	//存图
int f[1001][1001];	  //设计状态f[i][j]表示在此坐标时的最大值
int ans=-1;			 //答案

int main()
{
	//freopen("temp.in","r",stdin);
	//freopen("temp.out","w",stdout);

	//1:输入并初始化
	cin>>m>>n;
	for(int i=1;i<=m;i++)
		for(int j=1;j<=n;j++)
		{
			cin>>map[i][j];
			f[i][j]=map[i][j];	//存图的时候就开始初始化f数组
		}
			
	//2:计算
	//状态转移方程f[i][j]=max(f[i][j],f[i+1][k]) (k为j-1到j+1 && 不越界)
	for(int i=1;i<=m;i++)
        for(int j=1;j<=n;j++)
			f[i][j]=max(f[i-1][j-1],max(f[i-1][j],f[i-1][j+1]))+map[i][j];	//这里一定要加上此位置的原值，否则更新将出错
		
	//3:输出
	for(int i=(n+1)/2-1;i<=(n+1)/2+1;i++)
		ans=max(ans,f[m][i]);	//因为大水牛在(最后一行+1)行中间位置的下方，所以只从最后一行的中间三个位置找最大值
	cout<<ans;
	return 0;
    
    /**
    	总体来说，很简单的一道dp。
        我就不再多做解释了。
    */
}

```