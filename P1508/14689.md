这道题是很基础的动态规划（我呸。。。这不就是个贪心）

这个人从最后一行的下方，也就是第n+1行的m/2+1开始（向上）走

定义f[i][j]为当前在i行j列，能取得的最大能量


当他（它？）在第i行j列的时候，能走到第i-1行的j、j-1、j+1的位置（这样思考可以正推）

这道题其实正推（枚举已知状态推出位置状态）比较方便（等下回说方便在哪），主要是不用考虑推出去的


状态是否存在——能推出去怎么会不存在呢？自己yy一下

所以在这种情况下，只要考虑边界就行

由此得出转移方程（说实话这种方法没试过。。。大家可以去尝试下）


f[i-1][j]=max(f[i][j]+a[i-1][j],f[i-1][j])

f[i-1][j+1]=max(f[i][j]+a[i-1][j+1],f[i-1][j+1])

f[i-1][j-1]=max(f[i][j]+a[i-1][j-1],f[i-1][j-1])

但是如果按照我们动规的一般思路，是枚举未知状态i，j然后由i+1行的已知状态来求（我用的是这种）

和上面的正推一样，当这个人在第i行j列的时候，能够从第i+1行的j、j-1，j+1的位置走过来

这个时候就要考虑一个问题，上一行的这三个状态是否存在呢？

T T T T T T T

F T T T T T F

F F T T T F F

S
比如像n=3，m=7时，T表示状态存在，F表示状态不存在，S是出发点

转移的时候一定要注意上一个状态是否存在，然后还要注意边界。。。

注意：判断状态是否存在的时候，你可以拿j与m/2+1的差的绝对值与n-i+1比较一下

如果比n-i+1大，就不存在了，但是这种方法在表示[i+1][j-1],[i+1][j+1]的时候就比较麻烦了

写起来很容易出错。。。

但是下面的这份代码就用简单粗暴的方法解决了这个问题（增加的时空复杂度倍数控制在很小的常数级别）


AC代码君，上吧！

```cpp
#include<stdio.h>
#include<algorithm>
#include<cstring>
#include<math.h>
using namespace std;
int i,j,k,n,m,ans;
int a[205][205],f[205][205];
bool p[205][205];
int dfs(int x,int y)
{
    p[x][y]=true;//标记为存在
    if(x==1) return 0;//到了第一行
    if((p[x-1][y-1]==false)&&(y>1)) dfs(x-1,y-1);//注意边界
    if(p[x-1][y]==false) dfs(x-1,y);
    if((p[x-1][y+1]==false)&&(y<m)) dfs(x-1,y+1);//注意边界
    return 0;
}
int main()
{
    scanf("%d %d",&n,&m);
    for(i=1;i<=n;i++)
        for(j=1;j<=m;j++)
            scanf("%d",&a[i][j]);
    k=m/2+1;
    memset(p,false,sizeof(p));//p数组表示了所有的状态是否存在,初始化
    dfs(n+1,k);//暴力灌水floodfill
    for(i=n;i>=1;i--)//从第n行推到第1行
        for(j=1;j<=m;j++)
        {
            if(p[i][j]==false) continue;//判断状态是否存在
            f[i][j]=max(f[i][j],f[i+1][j]);//这边不用判断。。为什么自己想
            if(p[i+1][j-1]==true) f[i][j]=max(f[i][j],f[i+1][j-1]);//判断状态是否存在
            if(p[i+1][j+1]==true) f[i][j]=max(f[i][j],f[i+1][j+1]);//判断状态是否存在
            f[i][j]+=a[i][j];
        }
    for(i=1;i<=m;i++)
        ans=max(ans,f[1][i]);//从第一行所有状态中取最大值
    printf("%d\n",ans);
    return 0;
}
```