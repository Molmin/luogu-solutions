> 这是一份**有代码**的单 log 做法。

二分答案 $x$，把边权大于等于 $x$ 的边的边权视为 $+1$，其余视为 $-1$。然后考虑长剖，因为处理拐点为 $i$ 的路径时，$i$ 每个儿子的子树内同样深度的链肯定和越大越好。这样就可以枚举每条短链的深度 $i$，然后去看看传上来的长链里深度介于 $[l-i,r-i]$ 的点的权值最大是多少，如果加起来大于等于 $0$ 就能判定可行。在枚举完之后还需要把当前短链的信息与长链合并，即取最大值。如果偷懒写棵线段树肯定能做，不过这样会多一个 log。仔细考量我们需要支持的操作：

* 前端插入一个元素。这是长剖要求支持的。

* 定长区间查询最大值，定长区间可能退化为前缀或后缀。这是判定要求支持的。
* 给定一个长度为 $m$ 的数组 $a$，令第 $i$ 个元素的值与 $a_i$ 取 $\max$。$\sum m\le n$。这是合并子树要求支持的。

定长区间是一个突破口，考虑**按定长分块**，那么我们只需要维护每块块内的前缀最大值和后缀最大值就能拼出任意一个定长区间（包括退化为前后缀时的情况）。我们暂时不管前端插入，先看看块内结构具体长啥样。

考虑前缀修改对于每一块的信息的影响，后缀最大值可以直接 $O(m)$ 暴力修改。前缀最大值呢？对于覆盖到的整块直接重构，问题只剩下处理探出来的那一段零散点。先把对应块单拎出来，相当于我们要写一个数据结构，支持：前缀对 $a$ 取 $\max$，查询前缀最小值。这个就底层 $\log(r-l+1)$ 分块，块间维护 st 表。修改前缀 $[1,m]$ 时，对于覆盖到的整块，直接重构以这个块为起点的 st 表，复杂度是 $O(\lfloor{\frac{m}{\log(r-l+1)}\rfloor\log (r-l+1)})=O(m)$。在重构整块对应 st 表之前先要更新零散点，考虑对每个小块维护一个**压位单调栈**，即状压所有前缀最大值的位置。某个位置变大时，先看看它自己是不是前缀最大值，然后把它后面的某些前缀最大值弹掉。每修改一个位置最多使单调栈的大小 $+1$，那么删除的总复杂度均摊 $O(1)$。查询块内前缀最大值只需要借助位运算定位到最靠右的前缀最大值的位置。

回头看看前端插入：外层分块和底层分块改为从右往左，预留出一个不完整的块放在首位，用于接收前端插入的元素。对于大块内的前两个小块，不维护 st 表，查询和修改时特殊处理，这是为了保证重构 st 表的复杂度能摊到 $m$ 里。如果随着这次前端插入这一块变完整了就 $O(\log(r-l+1))$ 建出 st 表，在前面新开一个空的块，那么这个复杂度可以摊到前端插入里，因为每插入 $\log(r-l+1)$ 次才会建一个 st 表。而如果说随着这次前端插入整个大块都变完整了，就在大块的前面新开一个大块。具体实现就是把分块所需要的所有数组按照长剖内存池那样开出来，在二分前先处理出分块结构。

代码太长了，可以去 [CF](https://codeforces.com/problemset/submission/150/187112684) 上看。底层分块的部分和[这里](https://www.cnblogs.com/vectorwyx/p/15382823.html)差不多。不知道为什么跑得这么慢，路过的卡常大手子能否指点一下QAQ。