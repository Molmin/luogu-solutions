（假了骂我哈哈）

听闻有 1log 做法，大受震撼。

想了一下发现好像可行。

二分答案 $O(n)$ 后求树上链长在 $[l,r]$ 内的链的和的最大值。

考虑长链剖分。每次从下往上扫一条长链，每次把短链求答案之后合并上来。

那么需要一个数据结构，支持：

* 全局加
* 定长区间最大值
* 往前段加一个数
* 将前缀的若干个数变大，“若干个数”数量总和 $O(n)$

显然全局加没用。定长区间最大值就直接按定长分块，每次查询分成块的前缀和后缀。前面在更新的非整块显然平凡。每次将前缀的若干个数变大可以说是对某个块的前缀操作。

发现对每个块的后缀维护也平凡。实际上只剩下：

* 将前缀的若干个数变大
* 求前缀最大值

按 $\log n$ 分块。对 $2\sim k$ 块维护 ST 表。那么对 $2\sim k$ 块的维护直接重构、在 ST 表上 $O(\log n)$ 修改均摊复杂度显然是对的。

考虑第一块，维护所有前缀最大值的位置。每次修改的时候加入一些前缀最大值，删掉一些值，均摊复杂度对的。然后用一个 word 维护所有前缀最大值的位置，查询求出这个前缀最后一个前缀最大值即可。

所以时间复杂度 $O(n\log n)$。