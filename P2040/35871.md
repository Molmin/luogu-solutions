估计还没有几个人像我这样做的……

----

### 这一题比较典型，可以说是板子题，不过实际上还是有一些细节要注意

### 题意简述
给你一个9位二进制数，通过特定的变换法则，将其改变为$111111111$的最少步数。

### 算法分析
显然，我们就是用二进制来存储每一个状态，将法则变为二进制数，然后通过异或运算进行操作。

举个例子：
```
111       001
111 --->  011
111       111
```
相当于异或$(110100000)_2,$ 即$(416)_{10}$。

同理，我们可以写出其他操作的二进制数。

$110100000,111010000,011001000,100110100,010111010,001011001,000100110,000010111,000001011$

即

$416,464,200,308,186,89,38,23,11$
### 代码实现
下面就打裸的宽搜模板了。
```cpp
inline void in()
{
	int a;
	for(register int i=1;i<=9;i++)
	{
		cin>>a;
		if(a)
			st^=(1<<(9-i));//至于这边的9-i，我是为了调试的时候方便，你也可以改成i-1，不过有坑。
	}
	q.push(st);
	q.push(0);
	ed=(1<<9)-1;
	vis[st]=1;
}
inline void Do()
{
	int a,s,na,ns;
	while(!q.empty())
	{
		a=q.front();q.pop();
		s=q.front();q.pop();
		ns=s+1;na=a;
		for(register int i=0;i<9;i++)
		{
			na=a^d[i];
			if(!vis[na])
			{
				q.push(na);
				q.push(ns);
				if(na==ed)
				{
					printf("%d\n",ns);
					return;
				}
			}
		}
	}
}
```