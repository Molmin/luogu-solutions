这题可以用一种~~奇怪的~~深搜来实现，首先可以知道每个点只能搜一遍，比如说样例：

------------
0 1 1

1 0 0

1 0 1

------------
按一下1,1后：

1 0 1

0 0 0

1 0 1

------------
若再按一次1,1就回去了。

------------
若按下1,2：

0 1 0

0 1 0

1 0 1

------------
再按一次1,1的话，发现：

1 0 0

1 1 0

1 0 1

------------
结果~~貌似~~和只按一次2没有区别（其实就是连续按两次1再按一次2）。

为了使搜索不重复，所以一个点不要搜两次，那么我们可以用两个 last 记录上一次的位置。

------------
所以输入和输出是这样滴：
```cpp
int main()
{
	for(int i=1;i<=3;i++) for(int j=1;j<=3;j++) cin>>hxt[i][j];
	dfs(0,1,1);//从1,1尝试按，按了0次
	cout<<ans<<endl;
	return 0;
}
```
------------
定义变量：
```cpp
#include<bits/stdc++.h>
using namespace std;

int hxt[5][5],ans=82420520;//地图（习惯这个变量），初值赋值为很大值
int dx[5]={0,-1,1,0,0};
int dy[5]={0,0,0,-1,1};//简化代码，上下左右自己五个方向
```
------------
判断代码：
```cpp
bool check()
{
	int js=0;
	for(int i=1;i<=3;i++) for(int j=1;j<=3;j++) if(hxt[i][j]==1) js++;//统计1的个数
	return js==9?true:false;//若为九，返回true，否则false
}
```
------------
最重要的（dfs）：
```cpp
void dfs(int dep,int last1,int last2)
{
	if(dep>ans) return;//如果比最优解还大，那就不用搜了
	if(check()==true) ans=min(dep,ans);//成功即可
	else
	{
		for(int i=last1;i<=3;i++)//从上次的下个点开始
		{
			for(int j=(i==last1?last2:1);j<=3;j++)//如果i停留在上一行，j从上一次开始，否则j从1开始
			{
				for(int k=0;k<5;k++) hxt[i+dx[k]][j+dy[k]]=(hxt[i+dx[k]][j+dy[k]]==0?1:0);//五个方向若0为1，若1为0
				dfs(dep+1,i,j+1);//下一步，下个点
				for(int k=0;k<5;k++) hxt[i+dx[k]][j+dy[k]]=(hxt[i+dx[k]][j+dy[k]]==0?1:0);//回溯
			}
		}
	}
}
```
------------
至此，这题就做出来了。