## 题目分析

首先想到不用研究游戏的 dfs 做法，这样需要搜索 $7$ 层，记录每个局面的最优转移，能 $O(1)$ 进行交互，但棋盘大，有用的落子位置也不少，$O(k^7)$ 的预处理很容易超时。


------------
不如，我们抛开信息学的传统，考虑不需要什么算法，用选择语句就能实现的解！qwq

下面用 $1$ 代表黑子，$2$ 代表白子，$0$ 代表空位置。

已知 `1222` 胜，不难发现 `10220` 必能下一步转移至胜局面（可能到 `11220` 后获胜），进而 `10200` 和 `10020` 能在下两步获胜。

尝试第一步下在 $(3,0)$，黑棋想不让你根据上述结论赢，不得不下成 `10120` 或 `10021` 的局面。然后~~神之一手~~出现了，在 $(2,2)$ 落子，就得到：
```
0 0 0 0 0
0 0 0 0 0
0 0 2 0 0
0 0 0 0 0
1 0(1)2(1)
```
无论如何，都能形成两个不同方向上的 `10200`！黑棋不能兼顾，我们就一定能下出一个 `10220` 的局面，轻松获胜，此过程恰好用 $4$ 步，可以 AC。

## 代码实现
用 `if else` 就行了，注意交互库可能有极为~~智熄~~的操作，此时用最轻松的获胜方式即可。
```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int x,y,T;
int main(){
	scanf("%d",&T);
	while(T--){
		cout<<3<<" "<<0<<endl;//缓冲区问题直接endl,这样最方便 
		scanf("%d%d",&x,&y);
		if(x==4&&y==0){
			cout<<2<<" "<<2<<endl;
			scanf("%d%d",&x,&y);
			if(x==y){
				cout<<1<<" "<<3<<endl;
				scanf("%d%d",&x,&y);
				if(x==3&&y==1)cout<<0<<" "<<4<<endl;
				else cout<<3<<" "<<1<<endl;
			}
			else{
				cout<<3<<" "<<3<<endl;
				scanf("%d%d",&x,&y);
				if(x==1&&y==1)cout<<4<<" "<<4<<endl;
				else cout<<1<<" "<<1<<endl;
			}
		}
		else if(x==2&&y==0){
			cout<<2<<" "<<2<<endl;
			scanf("%d%d",&x,&y);
			if(x==y){
				cout<<2<<" "<<3<<endl;
				scanf("%d%d",&x,&y);
				if(x==2&&y==1)cout<<2<<" "<<4<<endl;
				else cout<<2<<" "<<1<<endl;
			}
			else{
				cout<<3<<" "<<3<<endl;
				scanf("%d%d",&x,&y);
				if(x==1&&y==1)cout<<4<<" "<<4<<endl;
				else cout<<1<<" "<<1<<endl;
			}
		}
		else if(x==1&&y==0){
			cout<<4<<" "<<0<<endl;
			scanf("%d%d",&x,&y);
			if(x==2&&y==0)cout<<5<<" "<<0<<endl;
			else cout<<2<<" "<<0<<endl; 
		}
		//智熄操作，都有对应的三步胜 
		else{
			cout<<2<<" "<<0<<endl;
			scanf("%d%d",&x,&y);
			if(x==1&&y==0)cout<<4<<" "<<0<<endl;
			else cout<<1<<" "<<0<<endl;
		}
	}
	return 0;
}
```
