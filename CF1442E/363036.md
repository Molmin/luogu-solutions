## 题意
给定一棵染了灰、白、黑色的树，每次可以选择若干个可以相互连通的点，但不能同时含有黑白两色。一次操作定义为将选择的点全部删去。问最少几次可以删除全部的点。

## 做法
本题为一道树形 DP。

我们先不考虑灰点。若只有黑白两色，那最少删除次数必定为 $\lceil\frac{d}{2}\rceil +1$（$d$ 为树的直径）。

简单的证明：将同色的点视为一个极大的点（缩点）。这样，我们得到了一棵相邻节点必定异色的树。此时，我们不停地在直径上删掉与某一端同色的所有叶节点。
1. 如果 $d\equiv 1\pmod 2$，那么每次会将直径两端的点都删掉，删 $\lceil\frac{d}{2}\rceil +1$ 次就没点了（比直径小的必定在某次删除中被当成叶子节点删掉了）。
2. 如果 $d\equiv 0\pmod 2$，删掉一端就成了第一种情况，答案依然是 $\lceil\frac{d}{2}\rceil+1$。

关于树的直径，这里不再赘述，有需要的请自行学习树形 DP 求直径。

构造：**不需要缩点**，只需要将同色点边权设为 $0$，异色点边权设为 $1$，就可以求出缩点后树的直径。

现在，我们加入灰点。如果你真正理解了上面的思路，那灰点的处理并不难。所有的灰点，无非跟着黑、白一起删除。而这个删除的过程必定是当它成为了叶节点后与其他叶节点一起删除的。所以，我们只需要考虑灰点到底跟着哪种颜色一起删除，即它到底染上黑色还是白色。

想要在较低复杂度内求出这个问题，树形 DP 无疑是最好的选择。我们设 $f1_{u,1/2}$ 为若将 $u$ 染上白色、黑色后离其最远的节点到 $u$ 的距离（讲人话，$u$ 能到达的最远的地方）。这个是不一样的，因为染上黑白两色边权是会变的。但是，有了这个我们还不能求出答案，我们还需要求出经过 $u$ 的直径长，才能统计出最少删除次数。所以，我们加多一个 $f2_{u,1/2}$ 表示经过 $u$ 的最短直径长度。

接下来重点讲讲转移。

设 $u$ 的所有出边为 $v_1,v_2,\cdots,v_k$。$f$ 数组的转移很好求，
$f1_{u,i}=\max_{col=1}^{2}\{f1_{{v_j},col}+w_{u,v_j}\}$（$col$ 为 $v$ 的颜色）。讲人话，离 $u$ 最远的就是离 $v_i$ 最远的加上 $u\rightarrow v$ 这条边的权值。

因为我们希望次数尽量少，所以在 $v_j$ 中取**最小值**。

$f2$ 数组与求直径相似，即经过 $u$ 的最长路径加上经过 $v_i$ 的最长路径及 $u\rightarrow v$ 的权值。我们也得到了 $f2$ 的递推式：$f2_{u,i}=\max_{col=1}^{2}\{f1_{u,i}+f1_{v_j,col}+w_{u,v}\}$。

同样，我们求的是最小次数，所以在所有 $v_j$ 中取**最小值**。

最后的答案就是 $\lceil\dfrac{\max_{u=1}^{n}\{\min(f2_{u,1},f2_{u,2})\}}{2}\rceil+1$，即所有点染黑色或白色的答案 $\div 2$ 向上取整再 $+1$。

## 代码
实现还是有点难度的，给个代码。

```cpp
#include<bits/stdc++.h>
using namespace std;
 
const int N = 2e5 + 10;
int T, n, ans, col[N];
int f1[N][3], f2[N][3];
vector<int> g[N];
 
void dfs(int u, int fa){
	if(col[u])	f1[u][col[u] ^ 3] = f2[u][col[u] ^ 3] = 1e9, f1[u][col[u]] = 0, f2[u][col[u]] = -1e9;//初始化 
	else	f1[u][1] = f1[u][2] = 0, f2[u][1] = f2[u][2] = -1e9;//灰点
	for(int v: g[u]){
		if(v == fa)	continue;
		dfs(v, u);
		for(int i=1;i<=2;i++){//u 染成什么颜色 
			if(col[u] + i == 3)	continue;//黑白都出现了
			int mnf = 1e9, mng = 1e9;//u被染成了i，mnf求所有路径最小值，mng则记录最小直径
			for(int j=1;j<=2;j++){//v 染成什么颜色
				mnf = min(mnf, f1[v][j] + (i != j));//儿子染成了j，那就从它的状态加上边权转移过来 
				mng = min(mng, f1[u][i] + f1[v][j] + (i != j));
			}
			f1[u][i] = max(f1[u][i], mnf);//这个跟上面同理 
			f2[u][i] = max(f2[u][i], mng);//v这个儿子的最小直径不一定是整棵树的直径，所以取 max 才能求出真正直径 
		}
	}
	ans = max(ans, min(f2[u][1], f2[u][2]));//答案与两种颜色的较小值取最大值
}

int main(){
    scanf("%d", &T);
    while(T--){
    	ans = 0;//记得清零 
        for(int i=1;i<=n;i++)    g[i].clear();//记得清空 
        scanf("%d", &n);
        for(int i=1;i<=n;i++)    scanf("%d", &col[i]);
        for(int i=1;i<n;i++){
            int u, v;
            scanf("%d%d", &u, &v);
            g[u].push_back(v), g[v].push_back(u); 
        }
        dfs(1, 0);
        printf("%d\n", ((ans + 1) >> 1) + 1);//输出答案 
    }
    return 0;
}

```
