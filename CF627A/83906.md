不得不说和[dalao](https://www.luogu.org/space/show?uid=52356)探讨一番立刻就懂了..



------------
这道题是思路比较巧的位运算，总体思路是分类讨论,算法是简单枚举。

在切掉这道题前您得知道这几条性质（好像都知道吧qwq）:

+ $1$.$a$+$b$=($a$&$b$)*$2$+($a$^$b$)

【证明】：很好理解对吧，相当于把两个数的不同部分和相同部分的拆开，其中相同部分占了两份。

+ $2$.$a$&$1$用来判断一个数的所有位上1的个数

~~这道题就被您$1s$切掉了~~


------------

题目已知$a$+$b$和$a$^$b$，**我们不妨用$sum$表示$a$&$b$=($s$-$x$)/$2$.**
我们来看一下**a,b每一位上的**$a_i$和$b_i$。对于$ai$^$bi$和$a$^$b$各有两种情况，即$a_i$^$b_i$ $\in${0,1}，$a_i$&$b_i$ $\in${0,1}。

+ ### $Special$ $Judge$：不合法的$a$,$b$.
  + 1.$a$,$b$都为正整数,如果($s$-$x$)/$2$并不是整数直接$puts$($0$) 
  + 2.$s$<$x$的情况，不多赘述原因
  + 3.($a$^$b$)&($a$&$b$)！=0,显然如果不等于0肯定是不合法的，但是为什么会出现这种数据呢？
  
  
+ ### $Case$ $1$：$a_i$^$b_i$=$0$。
   + 易知$a_i$=$b_i$=$a_i$&$b_i$=$1$.这一位只有一种情况，直接被钦定了。此时我们发现如果**$a$完全等于$x$**或者**$b$完全等于$x$**，那么a,b都是$0$，是不符合的，$ans$要-=$2$.
+ ### $Case$ $2$: $a_i$^$b_i$=$1$。
   + 此时$a_i$&$b_i$=$0$，不符合的情况被踢进了$Special$ $Judge$的第三种情况了。所以我们可以大力枚举了。枚举每一位是否符合
$ai$^$bi$=$1$，即判断($x$&$1$)==$true$即可。而且由于是两种情况（$a_i$=$0$,$b_i$=$1$||$a_i$=$1$,$b_i$=$0$）,ans要*$2$.


------------


$AC$代码如下：
```
#include<cstdio>
#include<iostream>
#include<cstring>
#define ll long long
using namespace std;
ll s,x;
int main() {
    while (scanf("%lld%lld",&s,&x)==2) {
        ll sum=(s-x)/2;//sum=a&b
        if(x>s||sum*2+x!=s||(x&sum)!=0) {puts("0");continue;}
        ll cnt=0;
        while (x) {if (x&1)++cnt;x>>=1;}//枚举 
        ll ans=1LL<<cnt;if (!sum) ans-=2;//a==b==a&b
        printf("%lld\n",ans);
    }
    return 0;
}

```



------------

其实还有个小疑问：

为什么会出现($a$^$b$)&($a$&$b$)!=0的情况呢？

经过打表发现的数据好像都没有规律..望详解qwq