## 题意

这道题其实很容易理解，我们可以视为一个人从小到大来变大麦秆，另一个人从大到小来变小麦秆，进一步的说，可以轮流变换一部分相同的麦秆。

例如：$2$ $2$ $3$ $3$ $4$ $4$ $5$ $5$，可以理解为一个人将两个 $2$ 变为两个 $3$ ，另一个人将两个 $5$ 变为两个 $4$。

## 思路

如果我们一个一个进行加减，这样的时间复杂度是 $O(n^{2})$，根据数据来说一定会TLE，所以我们采用**前缀和**的思想，将麦秆的数量以前缀和的方式存储下来，随后只需要判断谁需要移动，然后移动相应的数量即可。

时间复杂度：$O(h_{max})$（严格来说为 $O(p)$，其中 $p$ 为不同高度的数量），在处理前缀和的时候相当于去重，实际上也起到了离散化的作用。

## 代码

```cpp
#include<iostream>
#include<algorithm>
using namespace std;
int a[100010],s[100010],p[100010];//a为高度的前缀和，s为一个存储高度的桶，p为初始输入的高度（并不需要）（阴间定义）
int main()
{
	int n,x,c;
	cin>>n;
	for(int i=1;i<=n;i++)
	{
		cin>>p[i];
		s[p[i]]++;
	}
	x=0;
	for(int i=1;i<=100000;i++)
	{
		if(s[i]) 
		{a[++x]=s[i];a[x]+=a[x-1];}//计算前缀和
	}
	int w=x,ts=0,ws=0,t=1,la=1;//w从大到小到了第几个，t从小到大到了第几个，ts，ws分别表示割了多少，la表示上一个操作的人。
	while(t+1<w)
	{
		if(ts+a[t]<=ws+a[x]-a[w-1])//从小到大的人需要割
		{
			la=0;ts+=a[t];t++;
		}
		else//从大到小的人需要割
		{
			la=1;ws+=a[x]-a[w-1];w--;
		}
	}
    /*根据题意输出*/
	if(!la) cout<<"Mirko"<<endl;
	else cout<<"Slavko"<<endl;
	int tot=0,fl=0;
	for(int i=1;i<=100000;i++)
	{
		if(s[i])tot++;
		if(tot==t&!fl) 
		{cout<<i<<" ";fl=1;}
		if(tot==w) 
		{cout<<i<<endl;return 0;}
	}
}
```


蒟蒻实力不足，如果有错误请私信本蒟蒻QAQ
