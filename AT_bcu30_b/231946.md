这个题没什么难度，我就来提供一种检查行列是否合法只用双重循环一次的思路（虽然这个只有 $9*9$ 的地图大小但是如果考试是的时候是一个很大的地图呢?）。

题目说合法的地图每一行每一列都是由不重复的 $1$ 到 $9$ 组成，那么他的总和一定是 $1+2+…+9=45$ ，所以我们输入的时候记录一下这一行这一列的数字和是多少，之后检查是马跳是否合法的时候顺带着检查就好了，如果正好等于 $45$ 就是合法的，反之就不合法。

那按照这种思路循环次数比正常枚举检查少了很多循环次数，大大提高了时间（~~虽然地图不大~~）。

### 小建议

考试的时候遇见这种题要毫不犹豫的写暴力，但是平常练习还是要想想我的代码怎么样才能写得更快一点，这样也能锻炼思维。

```
#include<bits/stdc++.h>
#define int long long
using namespace std;

int lie[10],hang[10];
char Map[10][10];//因为中间没有空格所以用char类型来存储 
int dx[8]={-2,-2,-1,-1,1,1,2,2},
	dy[8]={-1,1,-2,2,-2,2,-1,1};//马跳的方向 

signed main(){
	for(int i=1;i<=9;i++)
	{
		for(int j=1;j<=9;j++)
		{
			cin>>Map[i][j];
			lie[j]+=Map[i][j]-'0';
			hang[i]+=Map[i][j]-'0'; 
		}
	}
	for(int i=1;i<=9;i++)
	{
		if(hang[i]!=45 || lie[i]!=45)//如果当前这一行或这一列没到达45也就是说不合法 
		{
			cout<<"No";//输出 
			return 0;
		}
		for(int j=1;j<=9;j++)//检查马跳的方向上是否合法 
		{
			for(int k=0;k<8;k++)
			{
				int xx=i+dx[k],
					yy=j+dy[k];
				if(xx>=1 && xx<=8 && yy>=1 && yy<=8)
				{
					if(Map[xx][yy]==Map[i][j])
					{
						cout<<"No";
						return 0;
					}
				}
			}
		}
	}
	cout<<"Yes";
}

```
