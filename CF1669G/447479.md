## 题意
给你一个矩阵，里面有石子 ``*``，障碍物 ``o``，空格 ``.``。

现在让石子往下掉，直到碰到障碍物或者到了矩阵的最后一行，输出所有石子变化后的矩阵。

## 解法
我们看到 50 的数据范围，毫不犹豫选择 ~~暴戾~~ 暴力。

如果石子碰到了矩阵的最后一行，就不会继续往下掉，那么我们可以人为的在最下面加上一整行障碍物。这样 ~~应该~~ 可以避免数组越界。

可以一列一列考虑。很显然可以用障碍物来将每一列分成几组，每组内所有的石子会掉到障碍物上方。

这个时候只需要找到列中所有障碍物的位置，在中间统计石子的总数并将石子改成空格，最后将石子统一放在障碍物上方。

为了方便写代码，可以将整个矩阵倒过来（第 1 行变成最后一行，第 2 行变成倒数第二行，以此类推），这样统一放置石子的时候就可以更方便。

## 代码
```cpp
#define REP(i,a,n) for(int i=(a);i<(n);i++)
int n,m;
string s[1005];
void Main(){
    cin>>n>>m;
    REP(i,0,n)cin>>s[n-i-1];//将整个矩阵倒过来
    s[n]="";
    REP(i,0,m)s[n]+='o';//最后一行放满障碍物
    REP(i,0,m){//一列一列地考虑
        REP(j,0,n){
            int x=j;
            while(x<=n&&s[x][i]!='o')x++;//寻找下一个障碍物，区间[j,x)是障碍物之间的空间
            int y=0;
            REP(k,j,x)if(s[k][i]=='*'){
                y++;//记录有多少个石子
                s[k][i]='.';
            }
            REP(k,j,j+y)s[k][i]='*';//方便写代码的地方：将矩阵倒过来之后，相当于石子往上掉。从上往下将空格改成石子
            j=x;
        }
    }
    REP(i,0,n)cout<<s[n-i-1]<<endl;
}
```