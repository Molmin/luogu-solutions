题意简述：把k把钥匙分配给n个考察队，获得钥匙的考察队可以获得一些特权（如下表），求：保证 没有钥匙的考察队 回来时门是开启的前提下，门保持启开启的时间的最小值。

|  | 出门时 | 回来时 | 回来后 |
| :----------: | :----------: | :----------: | :----------: |
| 没有钥匙的考察队 | 门会打开 | 门必须处在开启的状态 | 可以把门关上 |
| 有钥匙的考察队| 可以把门关上 | 门的状态任意 | 可以把门关上 |

分析题目，我们可以得到门在一段时间内的状态只跟 上一个出发/回来的考察队 和 下一个出发/回来的考察队有关系。因此此题的主要思路是对所有考察队的出发时刻和回来时刻排序，依次处理每两个时刻之间的时段。

另外，对于一段时间，我们有时把钥匙分配给相关的考察队，可以增加门关闭的时间，使答案更优。因此我们可以计算出每个考察队获得钥匙的时候，能够给答案带来的贡献(门关闭的时间，因为：总时间-最长的门关闭时间=最短的门开启时间 ），然后再根据这些结果，来得出最优解。

具体来说，两时刻间的一段时间有这些情况：

### 1.前一个时刻和后一个时刻 都有考察队要出发

如果我们把一把钥匙分配给前一个考察队，那么这段时间门就会处在关闭状态。给前一个考察队钥匙给答案带来的贡献+=这段时间的长度（左闭右开）

### 2.前一个时刻和后一个时刻 都有考察队回来

前一个考察队回来后，可以把门关上，可是，后面的考察队可能没钥匙进来啊。所以要么前一个考察队把门打开，要么给后面的考察队钥匙。给后一个考察队钥匙给答案带来的贡献+=这段时间的长度（左闭右开）

### 3.前一个时刻有考察队回来 后一个时刻有考察队出发 

由于前一个考察队不管是开门还是关门，都不会影响下一个考察队出发，所以前一个考察队选择关门一定更优。答案+=这段时间的长度（左闭右开）。

### 4.前一个时刻考察队出发，后一个时刻考察队回来 

这两个时刻的考察队可能是同一个考察队，也可能是不同的考察队，这时就要分情况讨论了:

#### 1）同一个考察队

如果给这个考察队钥匙，那么出发时就能把门关上了，回来也不会受影响。给该考察队钥匙给答案带来的贡献+=这段时间的长度（左闭右开）

#### 2）不同的考察队

如果要让这段时间的门关上，不仅要给前一个考察队钥匙，后一个考察队也需要钥匙（因为回来的时候门是关的）。这就是本题的难点所在了。我们把两个考察队当做两个节点，在它们之间连接一条权值为答案贡献（依旧是这段时间的长度（左闭右开））的边，如果我们同时选择了这两个点，答案就会加上这条边的边权。另外，由于题目的性质，连接后的图只会是一条或多条链。

------------

建模过后，我们会得到一个由许多条链和孤立点构成的图，这时候只需要求出选点后最大的答案就可以了，这能够用O(n^2)的动态规划搞定，具体见代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=2000+10,INF=21e8;
struct Edge{
    int v,w,nxt;
}e[N*4];
int front[N],en,du[N];
void add(int u,int v,int w){
    e[++en].nxt=front[u];
    front[u]=en;
    e[en].v=v;
    e[en].w=w;
    du[u]++;    //记录出度 
}
struct Point{   //储存每个时刻的信息 
    int sit,    //时刻的位置 
        bel,    //属于的考察队 
        fel;    //为0时表示这个时刻考察队出发，为1时表示考察队回来 
    bool operator < (const Point &pl) {     //按照时刻的位置从小到大排序 
        return sit<pl.sit;
    }
}p[N*2];
int n,
    val[N], 
    k,      
    ans,    
    dpans,  //dp的最终值 
    sitl,   //最早时刻 
    sitr;   //最晚时刻 
int dp[N][N][2];    //dp[i][j][1/0]表示在前i考察队中分配j把钥匙，最长的关门时间 (1表示给该考察队分配钥匙，0则不分配)
int seq[N],         //动态规划的顺序 
    chs[N],         //chs[i]表示如果给i考察队钥匙并且选择了 i考察队在序列中的前一个考察队 的额外贡献 
    num;
bool vis[N];
void dfs(int u,int w){
    if(vis[u])return;
    chs[u]=w;
    seq[++num]=u;
    vis[u]=1;
    for(int i=front[u];i;i=e[i].nxt)
        dfs(e[i].v,e[i].w);
}
int main(){
    scanf("%d%d",&n,&k);
    sitl=INF;
    for(int i=1;i<=n;i++){
        scanf("%d",&p[i].sit);
        p[i].bel=i;
        p[i].fel=0;
        sitl=min(sitl,p[i].sit);
        scanf("%d",&p[i+n].sit);
        p[i+n].bel=i;
        p[i+n].fel=1;
        sitr=max(sitr,p[i+n].sit);
    }
    sort(p+1,p+1+2*n);
    for(int i=1;i<2*n;i++){             //依次考虑每两点之间的位置 
        int l=p[i].sit,r=p[i+1].sit,v=r-l;
        int lf=p[i].fel,rf=p[i+1].fel;
        if((!lf)&&rf){                  //前一个时刻考察队出发，后一个时刻考察队回来 
            if(p[i].bel!=p[i+1].bel)
                add(p[i].bel,p[i+1].bel,v), 
                add(p[i+1].bel,p[i].bel,v);
            else val[p[i].bel]+=v;
        }
        else if((!lf)&&(!rf))   val[p[i].bel]+=v;       //前一个时刻和后一个时刻 都有考察队要出发 
        else if(lf&(!rf))       ans+=v;                 //前一个时刻有考察队回来 后一个时刻有考察队出发 
        else if(lf&&rf)         val[p[i+1].bel]+=v;     //前一个时刻和后一个时刻 都有考察队回来 
    }
    for(int u=1;u<=n;u++)
        if(du[u]<2)dfs(u,0);
    for(int i=1;i<=n;i++)
        for(int j=0;j<=min(i,k);j++){
            dp[i][j][0]=max(dp[i-1][j][0],dp[i-1][j][1]);
            if(j>0)dp[i][j][1]=max(dp[i-1][j-1][0],dp[i-1][j-1][1]+chs[seq[i]])+val[seq[i]];
            else dp[i][j][1]=-INF;      //注意：如果 j==0 ，那么 该考察队被分配钥匙的状态是不存在的 
        }
    printf("%d\n",sitr-sitl-ans-max(dp[n][k][0],dp[n][k][1]));  //总时间-最长的门关闭时间=最短的门开启时间 
    return 0;
}
```

[提交记录](https://www.luogu.org/record/25780139)