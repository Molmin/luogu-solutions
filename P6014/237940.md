本题思路：

因为本题中获得的分数不是$0$就是他们的总和模$10$（$0$除外，算$10$），所以我们就可以利用这个性质，把$0$到$9$一个个判断过去。如果符合条件，那么就输出他们的总和模$10$（$0$除外，算$10$），否则输出$0$

因为牌的大小为$1$到$10$，且只要找两张牌，所以只要从$2$到$10$和$11$到$20$即可

$AC$ $Code$
```cpp
#include<bits/stdc++.h>
using namespace std;
long long a[1000001],ans,minx,x[11];
int n;
int main()
{
	cin>>n;
	for(int i=0;i<n;i++)cin>>a[i],ans+=a[i],++x[a[i]];
	bool y=0;
	switch(ans%10)
	{
		case 0:
			if((x[1]&&x[9])||(x[2]&&x[8])||(x[3]&&x[7])||(x[4]&&x[6])||(x[5]>=2)||(x[10]>=2))  //10=1+9=2+8=3+7=4+6=5+5,20=10+10
			minx=10,y=1;
			break;
		case 1:
			if((x[1]&&x[10])||(x[2]&&x[9])||(x[3]&&x[8])||(x[4]&&x[7])||(x[5]&&x[6]))  //11=5+6=4+7=3+8=2+9=1+10
			minx=1,y=1;
			break;
		case 2:
			if((x[2]&&x[10])||(x[3]&&x[9])||(x[4]&&x[8])||(x[5]&&x[7])||(x[6]>=2)||(x[1]>=2))  //12=6+6=5+7=4+8=3+9=2+10,2=1+1
			minx=2,y=1;
			break;
		case 3:
			if((x[3]&&x[10])||(x[4]&&x[9])||(x[5]&&x[8])||(x[6]&&x[7])||(x[1]&&x[2]))  //13=3+10=4+9=5+8=6+7,3=1+2
			minx=3,y=1;
			break;
		case 4:
			if((x[4]&&x[10])||(x[5]&&x[9])||(x[6]&&x[8])||(x[7]>=2)||(x[1]&&x[3])||(x[2]>=2))  //14=10+4=9+5=8+6=7+7,4=1+3=2+2
			minx=4,y=1;
			break;
		case 5:
			if((x[5]&&x[10])||(x[6]&&x[9])||(x[7]&&x[8])||(x[1]&&x[4])||(x[2]&&x[3]))  //15=7+8=6+9=5+10,5=1+4=2+3
			minx=5,y=1;
			break;
		case 6:
			if((x[6]&&x[10])||(x[7]&&x[9])||(x[8]>=2)||(x[1]&&x[5])||(x[2]&&x[4])||(x[3]>=2))  //16=8+8=7+9=6+10,6=1+5=2+4=3+3
			minx=6,y=1;
			break;
		case 7:
			if((x[7]&&x[10])||(x[8]&&x[9])||(x[1]&&x[6])||(x[2]&&x[5])||(x[3]&&x[4]))  //17=8+9=7+10,7=1+6=2+5=3+4
			minx=7,y=1;
			break;
		case 8:
			if((x[8]&&x[10])||(x[9]>=2)||(x[1]&&x[7])||(x[2]&&x[6])||(x[3]&&x[5])||(x[4]>=2))  //18=9+9=8+10,8=1+7=2+6=3+5=4+4
			minx=8,y=1;
			break;
		case 9:
			if((x[9]&&x[10])||(x[1]&&x[8])||(x[2]&&x[7])||(x[3]&&x[6])||(x[4]&&x[5]))  //19=9+10,9=4+5=3+6=2+7=1+8
			minx=9,y=1;
			break;
	}
	if(y!=0)
	cout<<minx<<endl;
	else
	cout<<"0\n";
	return 0;
}
```
