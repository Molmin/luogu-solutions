好坑的水题……~~顺便吐槽评测机影响比赛心情~~

-------

题面已经够清晰了~~虽然依然有坑~~，下面直接给出思路：

**请看完算法二再看算法三，因为算法三是算法二基础上的优化。**

### 解题思路

#### 算法一

考虑当 $n=5$，直接根据一般斗牛的游戏规则打几个`if`即可。

时间复杂度 $O(1)$，预计得分 $50\%$。

#### 算法二

按照题意暴力模拟，但**有技巧**的。

显然如果枚举那 $n-2$ 个数，操作难度极高，时间开销极大，数量还会变。

不如看剩下的 $2$ 个数，枚举数量不变，时间开销勉强能承受。故考虑枚举这 $2$ 个数，用总和减去再判断是否是 $10$ 的倍数即可。

那么只需开两个`for`枚举 $2$ 个数，再判断即可。

时间复杂度 $O(n^2)$，预计得分 $80\%$。

#### 算法三

当你打算用算法二尝试骗分时，你就应该能想到，能不能省去一个`for`呢？

当选定 $1$ 个数 $p$ 时，剩下 $n-1$ 个数的总和**不变**。

要再选出 $1$ 个数，使得总和减去这个数后，和的个位为 $0$。

设这个数为 $x$，那么 $x$ 也是**不变**的，因为总和不变。

设这个数列为 $a$。则：

$$x=[(\sum^n_{i=1}a_i)-p]\% 10$$

那就好办了！考虑二分查找，就省去了一个`for`。二分到 $x$ 存在，更新答案；否则，继续枚举 $p$。

注意，

至此，本题思路就结束了。

时间复杂度 $O(n\log n)$，预计得分 $100\%$，实际亦如此。

----------

### 实现细节

本题坑点多，这里才是重点。

1. 还记得那个关于 $x$ 的式子吗？受取模影响，$x$ 可能为 $0$，即包含 $x$ 的 $n-1$ 个数总和已经是 $10$ 的倍数了。那么**要查找的 $x$ 应该为 $10$ 而非 $0$**，这样总和个位数才依然为 $0$。

1. 可能出现**多个合法方案**，因此更新答案要**取最大值**，不能直接`return`。为什么呢？难道玩游戏时不是越大越好吗？

1. 二分到存在 $x$ 时，请判断$x$ 和 $p$ **是否为同一个数**。

1. 二分前别忘了排序数组 $a$。

1. 二分推荐使用STL里的`std::lower_bound()`，搭配`std::vector`使用更方便。一些使用细节代码里有。

1. 求数列区间总和可以使用`std::accumulate()`。详细用法见[这篇文章末尾](https://www.luogu.com.cn/blog/hyyyprtf06/solution-p2866)。

----------

### 参考代码

下面多处使用STL。建议O2优化。

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <numeric>
#include <vector>
using namespace std;
int n,sum,ans;
int output(const int& a,const int& b)//算两张牌的点数
{
	return ((a+b)%10==0?10:(a+b)%10);
}
int main()
{
	scanf("%d",&n);
	vector <int> a(n+5);//动态开数组，vector默认为0
	for(int i=1;i<=n;i++)//本文数组下标从1开始
	 scanf("%d",&a[i]);
	sort(a.begin()+1,a.begin()+1+n);//注意排序范围，不是begin()和end()
	sum=accumulate(a.begin(),a.end(),0);//求和。由于默认为0，故范围可以为begin()和end()
	for(vector<int>::iterator it=a.begin()+1;it!=a.begin()+1+n;it++)//注意范围
	{
		int x=(sum-*it)%10;
		if(!x)
		 x=10;//实现细节1
		const auto f=lower_bound(a.begin()+1,a.begin()+1+n,x);//二分
		if(f!=it && *f==x)//不是同一个数且符合数值，见实现细节3
		  ans=max(ans,output(*it,x));//实现细节2
	}
	cout<<ans<<endl;//ans本来为0，找不到合法方案不更新，依然为0
	return 0;
}
```