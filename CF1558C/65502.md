## CF1558C 题解

vp的时候有点口胡地过了这题，回来捋一下思路。

+ ### 题意

  给你一个长为奇数 $n$ 的排列，你可以选择一个长为奇数 $x$ 的前缀并将其翻转，你的目标是将序列升序排列，要求输出一种操作数 $\le \frac{5n} 2$ 的方案，$3 \le n \le 2021$.

+ ### 思路

  首先注意到 $\frac {5n} 2$.

  为什么有 $\frac {} 2$ 呢，我们猜测这是枚举每一个奇数位置；

  为什么有 $\frac {5n} {}$ 呢，我们猜测枚举每个位置时我们要进行五次操作。

  那我们就来尝试胡这五条操作。

  在此之前我们考虑一下各种限制：

  1. 由于 $n$ 是奇数，那么实际上我们并没有办法枚举所有奇数位置因为会超过 $\frac {5n} 2$。所以我们要在枚举$\frac {n-1} 2$ 个位置时归位其他所有 $n-1$ 个数。
  2. 那么每次操作就要还原当前奇数位以后的所有数，最后剩下 $1$，也就是每次要把 $pos$ 和 $pos-1$ 归位。
  3. 并且每次尽量不对其他位置造成影响。
  4. 关于 $-1$：注意到每次交换后奇数位置的还是在奇数位置上，所以奇数位置不能是偶数，偶数部分不能是奇数。

  我们倒序处理整个序列，这样序列后面有序的部分可以忽略。

  以下我们设 $find(i)$ 表示 $i$ 这个数当前在的位置。

  考虑当前枚举到奇数位置 $i$：

  第一个操作肯定是把 $i$ 这个数找到并移到前端：`rev(find(i))`；

  接下来应该是找 $i-1$，但是这个数必然在偶数位，所以我们只能移动它两侧的数：`rev(find(i-1)-1),rev(find(i-1)+1)`。

  我们想想序列是怎样变化的：

  $\{i \dots [已经排好序的部分] \}$

  $\to \{ \dots i,i-1 \dots [已经排好序的部分] \}$

  $\to \{ x,i-1,i \dots [已经排好序的部分] \}$

  那剩下两步自然呼之欲出了：

  $\to \{ i,i-1 \dots [已经排好序的部分] \}$

  $\to \{ \dots i-1,i,[已经排好序的部分] \}$

  其实这里思路上应该先填最后一条，这条启发我们要将目标移到首端后翻转到后面。

  但是不管怎样，我们磕磕绊绊地胡出了一个构造方法。

+ ### 代码

  有不懂的部分还是看看代码吧：

  ```cpp
  n=read();rep(i,1,n)a[i]=read(),fl[i]=(a[i]^i)&1;
  int num=0;rep(i,1,n)num+=fl[i];
  if(num){puts("-1");return;}
  ans.clear();
  for(int i=n;i>1;i-=2){
      int x=find(i);
      ans.push_back(x);rep(j,1,x/2)swap(a[j],a[x-j+1]);
      x=find(i-1)-1;
      ans.push_back(x);rep(j,1,x/2)swap(a[j],a[x-j+1]);
      x=find(i-1)+1;
      ans.push_back(x);rep(j,1,x/2)swap(a[j],a[x-j+1]);
      x=3;
      ans.push_back(x);rep(j,1,x/2)swap(a[j],a[x-j+1]);
      x=i;
      ans.push_back(x);rep(j,1,x/2)swap(a[j],a[x-j+1]);
      //		rep(i,1,n)printf("%d ",a[i]);puts("");
  }
  printf("%d\n",ans.size());
  for(int x:ans)printf("%d ",x);puts("");
  ```