最近在学递推，我便在洛谷上专门找递推标签的题目来做，然后发现好难啊=-=然后便一眼相中这道题哈哈【不要学我

看到样例6的结果为8，就感觉这道题目用斐波那契直接算出N的结果是可以的。

但是万事不能光靠直觉，还是需要我们来手算解决的。

我们从样例数据可以看到

6的结果为8

便可以暂时写一个计算器的程序来算N的值是多少。

也就是直接按照原题的那个复杂的公式来计算

```c
#include <stdio.h>
#include <math.h>
int main() 
{ 
    int n;
    scanf("%d",&n);
    printf("%.2f",(pow(((1+sqrt(5))/2),n)-pow(((1-sqrt(5))/2),n))/sqrt(5)); 
    return 0;
}
```
我们便可以从1开始找规律

输入：1      结果：1.00

输入：2      结果：1.00

输入：3      结果：2.00

输入：4      结果：3.00

输入：5      结果：5.00

哈哈！就是斐波那契！即当前第N项等于前两项之和

递归公式：

```c
f[0]=0;
f[1]=1;
f[2]=1;
f[i]=f[i-1]+f[i-2];
```
其实直接用上面程序的方法直接实现公式也是可以的，但是，自我感觉，如果是在正规比赛的情况下，不可能会数据这么小的，像这样的至少要1000以上吧....（蒟蒻自己想法，接受反驳，不要喷）

而如果用公式的话，输入到1475就炸了....

 ![](https://cdn.luogu.com.cn/upload/pic/7684.png) 

而递推就不会了。

AC代码附上：

```c
#include <stdio.h> //头文件
int main()
{
    double f[50];
    int n,i;
    f[0]=0;
    f[1]=1;
    f[2]=1;   //递归边界条件
    scanf("%d",&n);
    for (i=3;i<=n;i++)
    f[i]=f[i-1]+f[i-2];  //开始使用斐波那契数列
    printf("%0.2lf",f[n]); //输出，保留两位小数
    return 0;
}
```
虽然是入门难度，但是这也是一道递推的题目。

从这道题目，我也总结出来了一个选择算法的要点：

如果输入是一个数据，且题意是那种拥有前后相关联关系（即当前的目的是在之前的前提之下才形成的），那么直接采用一个一个数字来寻找规律，直接递推是再好不过的了。数学方法我感觉没有递推的方法靠谱，作为数学渣来说，也算是一个好的锦囊了吧！
