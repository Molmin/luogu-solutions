###看见楼下没有发高精度做的，我发一个，如果n>48，就可以这么做

原理还是一样，斐波拉契，发现一个以前写的程序，改了改，就好了

我用的是十亿高精，供高精的学习者学习

n到30000没问题

```cpp
#include<cstdio>
int a[30000]={0,1},b[30000]={0,1},f[30000],n,m,i,j,la,lb,lf,x;
int main()
{
    scanf("%d",&n);
    if(!n)//特判
    {
        printf("0.00");
        return 0;
    }
    n--;//因为我用的是以前的程序改了一下，他默认的是1,2,3,5,8....
    if(n<2)printf("1");//特判
    else
    {
        la=1;//a长度
        lb=1;//b长度
        for(i=1;i<n;i++)
        {
            lf=1;//f长度
            x=0;
            while(lf<=la||lf<=lb)
            {
                f[lf]=a[lf]+b[lf]+x;
                x=f[lf]/1000000000;//**十亿高精与普通高精不同在这，这里一个数组空间可以存10位，防止超时**
                f[lf]%=1000000000;//同样mod1000000000
                lf++;
            }
            for(j=1;j<=lb;j++)
            a[j]=b[j];
            for(j=1;j<=lf;j++)
            b[j]=f[j];
            la=lb;
            lb=lf;
        }
        while(f[lf]==0&&lf>1)lf--;
        for(i=lf;i>0;i--)
        {
            if(i==lf)printf("%d",f[i]);//**如果小于十亿（n<48）或者大于十亿的第一个数组单位（首位不能为0），直接输出**
            else//否则，防止首位有0，逐位输出
            {
                printf("%d",f[i]/100000000%10);//分解，有点难看，勿嘲讽
                printf("%d",f[i]/10000000%10);
                printf("%d",f[i]/1000000%10);
                printf("%d",f[i]/100000%10);
                printf("%d",f[i]/10000%10);
                printf("%d",f[i]/1000%10);
                printf("%d",f[i]/100%10);
                printf("%d",f[i]/10%10);
                printf("%d",f[i]/1%10);
            }
        }
    }
    printf(".00");//保留2位小数
    return 0;
}

```