**前言。**

- 题意：[题意传送门](https://www.luogu.com.cn/problem/P5991)。
- 方法：一是纯正式暴力，二是数学式暴力。

**分析。**

方法一：纯正式暴力枚举。

但是看到 $1 \le k,a,b \le 10^8$ 时，我们发现，如果数据够大，那么纯暴力是过不了的，但是如果优化一下，也许能卡过去，不过我也没有试过，毕竟此题需要更优的暴力。

代码就不放了。

方法二：数学式暴力枚举。

一个巧妙（？）的思路。  

众所周知，一个正整数，该正整数越大，那么其平方也就越大，表达为：  
如果 $a<b(0<a,b)$ 时，那么 $a^2<b^2$ 的式子成立。

分析其最大值，以减少枚举的数量。

可知 $n$ 可以为 $999999999999999999$ 的最大数。

因为 $9^2=18$ 且 $9$ 的数量为 $18$ 个，那么 $f(999999999999999999)=18 \times 81=1458$ 即 $f(n)$ 的最大值为 $1458$。

确定好枚举范围，就可以愉快地推式子了：  
又题意可知：  
数必须满足 $k \times f(n)=n$ 的关系。  
那么根据[等式的性质](https://baike.baidu.com/item/%E7%AD%89%E5%BC%8F/3517693)可以推出：  
$f(k \times f(n))=f(n)$。  
这样，我们就可以开始暴力枚举了！

代码如下，仅供参考：
```
#include<iostream>
#include<cstdio>
using namespace std;
long long k,a,b,sum,ans1,ans2;
long long f(long long x){//f(n)
    long long ans=0;//ans是它十进制下每一位数字的平方的和。
    while(x){
        ans+=(x%10)*(x%10);
        x/=10;//一直拆分。
    }
    return ans;//返回。
}
int main(){
    cin>>k>>a>>b;
    for(int i=1;i<=1458;i++){
        if(i*k>b){//已经超出了最大值b。
            break;
        }
        if(f(i*k)==i){//开始统计f(f(i)*k)=f(i)的数量。
            ans1++;//ans1代表从1到b的符合题意的n的数量。
        }
    }
    for(int i=1;i<=1458;i++){
        if(i*k>a-1){//已经超出了最大值。
            break;
        }
        if(f(i*k)==i){
            ans2++;//ans2代表从1到a-1的符合题意的n的数量。
        }
    }
    cout<<ans1-ans2<<"\n";//ans1-ans2代表从a到b中符合题意的n的数量。
    return 0;
}
```
**后记。**

大家如有疑问，可以在评论区提出，我会尽力解答的。