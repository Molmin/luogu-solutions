今天模拟赛题，懒得写高精用 `python` 打表，结果剪枝写错白丢 $80$，悲。

------------
高精题怎么能没有 `python` 题解呢！

啥？你说这题 `C++` 都得取对数才能卡过去？

咳咳，其实这篇题解讲的不是 `python`，而是一个很强力的剪枝。

暴搜的思路应该是不难想到的。~~因为我们今天模拟赛是三道搜索题。~~

根据唯一分解定理，如果 $m=\prod\limits_{i=1}^pp_i^{t_i}$，$p_i$ 为质数，那么 $m$ 有 $\prod\limits_{i=1}^p(t_i+1)$ 个因子。

对应到本题，每一个 $t_i+1$ 就是 $n$ 的一个因子。所以我们只需要枚举 $n$ 的每一种分解，然后将它们减去一作为不同质数的指数，乘起来就可以了。

然后我们来剪枝。

用哪几个质数呢？很显然，肯定是最小的那几个。

同时因为即使全分成二，因子也不会超过 $17$ 个，所以我们只需要提前算好前多少个质数。

那我们搜索的时候可以记一下当前用的是哪个质数。

同时，如果我们有同一种分解方式，我们把哪个数给哪个质数呢？肯定是把大数给小质数。

所以我们可以再记一下以前用过的最小数，然后以后再拆就只枚比它小的。

这样我们就可以用 `python`，并且不用取对数就可以通过此题啦！

如果还不清楚的话，看（超短）代码吧：
```
primes=(2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61)
def dfs(dep,x,mm):
    if x==1:
        return 1
    ans=-1
    for i in range(2,mm+1):
        if x%i==0:
            if ans<0:
                ans=(primes[dep]**(i-1))*dfs(dep+1,x//i,i)
            else:
                ans=min(ans,(primes[dep]**(i-1))*dfs(dep+1,x//i,i))
    return ans
n=int(input())
print(dfs(0,n,n))
```
