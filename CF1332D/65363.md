### Description

有这么一个问题：

> 有一个 $n \times m$ 的矩阵 $a_{n, m}$，矩阵的每个位置都有一个数，要求寻找一个每次只能向右或向下走的从 $(1, 1)$ 至 $(n, m)$ 的路径，最大化路径上的数的按位与之和。
>
> $1 \leq n, m \leq 500$，$0 \leq a_{i, j} \leq 3 \times 10^5$。

现在给出解决该问题的一个**错误** dp 算法（见题面图片），请构造一组数据，hack 掉这个算法，使得正确答案比错误的输出**恰好**大 $k$。

$0 \leq k \leq 10^5$。

### Solution

首先考虑这个 dp 为什么是错的，这是因为在 dp 的过程中没有保证**最优子结构**的成立，换句话说，在某个状态的最大值转移到下一个状态以后不一定是最大值。以下面的矩阵为例（方便起见，元素写成二进制形式）

```plain
11 01
10 11
00 01
```

注意到 $f_{2, 2}$ 按照给出的算法计算的话，应该从 $f_{2, 1}$ 转移，其值为 $10$，但是与 $01$ 按位与之后的值为 $0$，相反如果从 $(1, 2)$ 转移，则走到 $(2, 2)$ 的值为 $01$，与 $01$ 按位与后的值为 $01$，比上述结果优。

因此我们只需要在最高位上进行“诱导”，就可以让 dp 走入歧途。

考虑构造这个矩阵，不妨让 dp 输出 $0$，而正解输出 $k$。

可以让矩阵右下角的值为 $k$，然后将左下角格子设成 $0$，表示只能从上方转移下来。然后只需要在上方格子构造两条路径，一条是按位与的值为 $2^{\lfloor\log_2^k\rfloor + 1}$ 的路径，表示为二进制就是 $1000\dots$，其中 $1$ 的位数比 $k$ 的二进制最高位还要多 $1$；另一条是按位与的值恰好为 $k$ 的路径。 构造这个矩阵只需要四个格子：左上角全 1，右上角为 $k$，左下角为 $2^{\lfloor\log_2^k\rfloor + 1}$，右下角全 $1$。

拼上最下面的两行，共有三行两列。

考虑矩阵中的最大值是左上角的全 $1$ 位置，这个位置至少要是 $2^{\lfloor\log_2^k\rfloor + 2} - 1$。当 $k = 10^5$ 时，这个值是 $262143$，满足要求。

### Code

```cpp
#include <cmath>
#include <cstdio>
#include <iostream>

int main() {
  int k;
  std::cin >> k;
  int t = log2(k);
  puts("3 2");
  printf("%d %d\n", (1 << (t + 2)) - 1, k);
  printf("%d %d\n", 1 << (t + 1), (1 << (t + 2)) - 1);
  printf("0 %d\n", k);
  return 0;
}
```