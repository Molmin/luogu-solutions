这个贪心会从第二个开始贪，我们首先得满足有两行

然后在考虑列数，如果只有两列的话意味着贪心没用（我们相当于直接比较所有答案），所以得来三列

于是设出这个矩阵

$\begin{matrix}a&b&c\\d&e&f\end{matrix} $

然后模拟一下

$\begin{matrix}a& a\&b &c\\a\&d&e&f\end{matrix} $

模拟两下

$\begin{matrix}a& a\&b &a\&b\&c\\a\&d&max((a\&b\&e),(a\&d\&e))&f\end{matrix} $



此时可以看见f有三种取值（妈耶）

但是我们完全可以令$c=0$,此时$f$这个位置只有两种取值$(f=max(a\&b\&e\&f,a\&d\&e\&f))$，我们就来构造一组让贪心小$k$的数据

怎么构造呢？

我们看这两数据只有$b,d$有区别，我们就让$a=e=b~or~d$

这时候还要怎么办呢，注意到题目要求$k\leq10^5$

诶，也就是说这东西小于$2^{17}=131072$

题目要求小于$3*10^{5}$

那就是说还剩了一个二进制位

那就好办了，这样恰好可以让贪心贪这个大的（一个为k，一个为$2^{17}=131072>k$）

我们直接令$f=k$，那么这时候这两东西$\&$下来为$0$，而答案为$k$，刚好满足差为$k$


于是这东西就变得非常浅显易懂：

```cpp
#include<touwenjian.h>

using namespace std;

int k; 

int main()
{
	ios::sync_with_stdio(false);
	cin>>k; 
	cout<<2<<" "<<3<<endl;
	cout<<(1<<17)+k<<" "<<(1<<17)<<" "<<0<<endl;
	cout<<k<<" "<<(1<<17)+k<<" "<<k;
	return 0;
}

```

