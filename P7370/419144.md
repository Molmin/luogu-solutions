想了解背景的同学可以去[P7369](https://www.luogu.com.cn/problem/P7369)

## 分析

利用初中的**数形结合**思想，因为魔杖只有可能从**失败**的女巫传给**胜利**的女巫，所以她们之间的**关系**就可以用一条**有向边**来表示，如 ``2 1`` 可以转化为 ``1->2``，表示 $1$ 到 $2$ 有一条有向边，即魔杖可从 $1$ 传到 $2$。

这样问题就清晰可见了。如果编号为 $x$ 的女巫**最后拿到**魔杖，那么 $1$ 号女巫手中的魔杖一定**直接或间接**传给她，即**一定**有一条从 $1$ 号女巫到 $x$ 号女巫的路线。而对于其他的战斗，因为可以**随意调整顺序**，我们只要把失败者不是 $1$ 号女巫全部调到前面，把失败者是 $1$ 号女巫全部调到最后，就不会影响最后的结果，换句话说，其他的战斗对这条路径**没有任何影响**。

我们用**邻接表**来**存储**每条有向边，建立一个 ``bool b[N]`` 数组存储每个点**是否被走过**，然后从 $1$ 号节点开始，不断沿着他的每条边到达下一个**未被标记**的点，将那个点**标记**，并继续**搜索**下去，直到**无点可走**，**注意**开始时不要标记 $1$ 号节点，因为她是把魔杖传出去的，只有之后传回她时才能标记。而**能走到**的每个点就能说明她们和 $1$ 号节点**存在一条路径**，即她们是能**最后拿到魔杖**的女巫。

### 坑点

除了上面说的开始时不能标记 $1$ 号节点外，还要在全部搜索完后**特判**一次 $1$ 号节点，因为有一种可能情况： $1$ 号女巫**从来没有失败过**，即 $1$ 号节点的**出度为零**，这时最后魔杖只在 $1$ 号女巫手中，而我们之前的搜索中**没有标记**，这样就会 WA 一个点（~~我卡了好久QWQ~~），所以要特判一下 ``if(!a[1].size())b[1]=1;``，其中 $a_1$ 数组表示击败 $1$ 号女巫的人，即从 $1$ 号节点出发的有向边，而 $a_1.size()$ 表示她**失败的次数**，即**出度**。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+10;
int n,m,x,y;
bool b[N];//每个点是否走过 
vector<int>a[N];//邻接表存储有向边 
void dfs(int x)//搜索 
{
	int l=a[x].size();
	for(int i=0;i<l;i++)//遍历每个能走到的点 
	{
		if(!b[a[x][i]])//如果没走过就标记并继续搜索 
		{
			b[a[x][i]]=1;
			dfs(a[x][i]);
		}
	}
}
int main()
{
	cin>>n>>m;
	for(int i=1;i<=m;i++)
	{
		cin>>x>>y;
		a[y].push_back(x);//添加有向边 
	}
	dfs(1);//1号节点不标记 
	if(!a[1].size())b[1]=1;//特判别忘了 
	for(int i=1;i<=n;i++)
	{
		cout<<b[i];//能走到的点就有可能最后拿到魔杖 
	}
	return 0;
}
```
