题意：求满足 $1\le i\le n$ 且 $(i)_2$ 中 $1$ 个数少于 $k$ 个的 $i$ 的个数。

核心思想：数位 DP

解：

首先将 $n$ 二进制转写为 $2^0a_0+2^1a_1+...+2^la_l$ 。（下文中 $i$ 位数表示二进制意义下）

令 $f(i,j,0)$ 表示有 $j$ 个 $1$ 的 $i$ 位数的个数，易得 $f(i,j,0)=C_{i+1}^j$。（组合数定义）

令 $f(i,j,1)$ 表示小于等于 $n$ 的后 $i$ 位的有 $j$ 个 $1$ 的 $i$ 位数的个数，则若 $a_i=0$，$f(i,j,1)=f(i-1.j.1)$（第 $i$ 位只能取 $0$，且之后的位数不能大过 $n$),否则 $f(i,j,1)=f(i-1.j-1.1)+f(i-1,j,0)$（第 $i$ 位取 $0$ 之后可任意取，否则不能过大）。

答案即为 $f(l,k,1)$。

代码：
```
#include <bits/stdc++.h>
using namespace std;
long long n, k, a[61], b[61][61][2], l=-1;
int main()
{
	cin>>n>>k;
	while(n>0)
	{
		a[++l]=n%2;
		n/=2;
	}//转为二进制
	b[0][0][0]=1;
	b[0][1][0]=1;
	b[0][0][1]=1;
	if(a[0]==1)
		b[0][1][1]=1;//初始化
	for(int i=1; i<=l; i++)
		for(int j=0; j<=i+1; j++)
		{
			b[i][j][0]=b[i-1][j][0]+b[i-1][j-1][0];
			if(a[i]==0)
				b[i][j][1]=b[i-1][j][1];
			else
				b[i][j][1]=b[i-1][j-1][1]+b[i-1][j][0];
		}//转移
	cout<<b[l][k][1];
	return 0;
}
```