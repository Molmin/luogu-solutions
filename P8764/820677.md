### 题意
非常明确，求 ${1}$ $\sim$ ${n}$ 在二进制下含有 ${k}$ 个 ${1}$ 的数的个数。
### 思路
此题数据范围 ${n}$ $\leq$ ${1\times10^{18}}$，暴力显然超时 _~~(如果你只想拿 n<=1000000 的 30 分走人当我没说)~~_ 。因此考虑数位DP。

标题点明此题为二进制问题，题面也要求对二进制数进行统计，故我们考虑二进制下的数位DP。


首先预处理出 ${dp[i][j][t]}$，即首位为 ${t}$ 的含有 ${j}$ 个 ${1}$ 的 ${i}$ 位数的个数。


初始化：${dp[1][1][1]=1,dp[1][0][0]=1}$


状态转移方程:


 ${dp[i][j][1]=dp[i-1][j-1][0]+dp[i-1][j-1][1],}$

 ${dp[i][j][0]=dp[i-1][j][0]+dp[i-1][j][1].}$


然后就是统计环节。

首先将 ${n}$ 转化为二进制并用数组 ${num[]}$ 存储，设 ${n}$ 在二进制下的长度为 ${len}$。

显然 ${n}$ 的最高位为 ${1}$，故 ${1}$ $\sim$ ${len-1}$ 位的所有满足要求的数必定包含在其中。

然后求第 ${len}$ 位：从 ${len-1}$ 到 ${1}$ 倒着扫一遍,如果第 ${i}$ 位是  ${0}$ 则跳过，否则加上 ${dp[i][k-t][0]}$，${t}$ 为 ${i+1}$ $\sim$ ${len}$ 位为 ${1}$ 的个数，当 ${t}$ 大于 ${k}$ 时退出循环。

由于此方法统计的是 ${1}$ $\sim$ ${n-1}$，故开始时可将 ${n}$ 加 ${1}$，然后按照上面的方式统计即可。

最后不要忘了开 longlong 喔 qwq。

### 代码


------------

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;

int n,k,len;
int num[72];//存二进制下的n 
int dp[72][72][2];//默认初始值为0

inline void Init()//预处理 
{
	dp[1][1][1]=1;
	dp[1][0][0]=1;//初始化 
	for(int i=2;i<=72;i++)//状态转移(从第2位开始) 
	{
		for(int j=0;j<=i;j++)
		{
			if(j>0)dp[i][j][1]=dp[i-1][j-1][0]+dp[i-1][j-1][1];
			dp[i][j][0]=dp[i-1][j][0]+dp[i-1][j][1];
		}
		
	}
}

inline int solve(int len)//求1～(n+1)-1中满足条件的数 
{
	int sum=0;
	for(int i=k;i<len;i++)//统计1～len-1位所有满足的数 
	sum+=dp[i][k][1];
	int t=1;
	for(int i=len-1;i>=1;i--)//统计第len位中满足的数 
	{
		if(!num[i])continue;
		if(t>k)break;//剩下数字含1个数必定大于k,故退出循环。
		sum+=dp[i][k-t][0];
		t++;
	}
	return sum;
}

signed main()
{
	scanf("%lld%lld",&n,&k);
	n++;
	Init();
	while(n)//将n转为2进制 
	{
		num[++len]=n%2;
		n/=2;
	}
	if(k>len) puts("0");//此情况显然不可能有数字满足要求 
	else printf("%lld\n",solve(len));
	return 0;
} 
```


------------
萌新的第一篇题解，求通过(^-^)。



