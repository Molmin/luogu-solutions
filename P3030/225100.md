动态规划好题，真的好。

简化题意：已知 $n$ 个正方形的边长，把 $a_i$ 修改为 $b_i$ 需要 $(a_i-b_i)^2$，求最少花多少钱可以把这 $n$ 个正方形的面积变为 $m$。如果无解输出 $-1$。

乍一眼看，就看出这貌似是背包 。因为没有规定可以修改的次数，所以是完全背包。

根据背包模板，上代码

$Code:$
```cpp
#include<bits/stdc++.h>
#define inf 0x3f3f3f3f
using namespace std;
const int N=1e6;
int f[N],a[N],res;
int main()
{
	int i,j,k,l;
	int n,m;
	cin>>n>>m;
	for(i=1;i<=n;i++)
	{
		cin>>a[i];
		res+=a[i]*a[i];
	}
	memset(f,0x3f,sizeof(f));
	f[res]=0;//初始状态
	for(i=1;i<=n;i++)
	{
		for(j=0;j<=m+res;j++)//保证足够大
		{
			k=0;
			while(++k)
			if((k*k-a[i]*a[i])<=j) 
			f[j]=min(f[j],f[j-(k*k-a[i]*a[i])]+(k-a[i])*(k-a[i]));
		}
	}
	if(f[m]==inf) cout<<-1;
	else cout<<f[m];
	return 0;
}
```
貌似是对的，，，75分。

这是为什么呢？不是很符合背包吗？

我们来看一组数据
```cpp
3 99
5 1 1
```
初始状态是 $f[27]=0$ ，然后 $f[18]=1$ $($ $4$ $1$ $1$ $)$ ，此时根据循环的状态转移方程 $f[29]$ 却可以由 $f[29-11]+(6-5)×(6-5)$ 转移得到。但是这显然是不对的。也就是说，这个状态下的第一个正方形边长已经不是 $5$ 了，应该由 $4$ 转移，而状态转移方程却还是以 $5$ 进行转移。

好，现在找到了问题，就来研究研究为什么会有这个问题。状态下的正方形边长错误是直接原因，现在找根本原因 。 

现在回过头去看背包，你会发现，它的状态转移方程
```cpp
for(i=1;i<=n;i++)
	for(j=m;j>=a[i];j--)
		f[j]=max(f[j],f[j-a[i]]+b[i]);
```
我们可以发现它的体积都是正的，就是说 $f[j]$ 都是由 $f[k](k≤j)$ 转移得到的。

 如果把采药问题变成：存在药物体积为负，要求正好装满背包，那就跟这题一样了 

换句话说：就是这一题这么转移，存在 “后效性”（ 最近第二次提到这玩意了，而且都是在恶心了我好久的情况下 ）

那怎么改？

既然是在状态上出的错，就更改状态：$f[i][j]$ 表示前 $i$ 个正方形体积为 $j$ 所需的最少钱

状态转移方程
```cpp
初始化f[0][0]=0;其他为inf
	for(i=1;i<=n;i++)
		for(j=0;j<=m;j++)
			for(k=0;k*k<=j;k++)
				f[i][j]=min(f[i][j],f[i-1][j-k*k]+(k-a[i])*(k-a[i]));
```

此方程跟上面的进行比较，貌似就多了个维度。那我们把之前的再加上一个维度就可以吗？答：不可以

这时候就涉及到了第二个问题：滚动数组的设置。上面的 $dp$，的后效性是对于每一层每一个正方形的，本身就和其他正方形无关，所以还是会状态冲突。那么可以把此方程减一个维度吗？答：还是不可以，因为本层的答案，只跟本层的 $j$ 和上一层的 $j-k×k$ 相关，如果滚动，就变成了和上一层的 $j$ 和 $j-k×k$ 相关了。所以滚动数组也不是随便可以滚的

综上：一句话概括 “**这不仅仅是模板，这不仅仅是模板** ” 。不要说看着像背包就开始套模板，要思考，尽管真地很像，不要模板滚你就滚。不是什么都能滚的。
