这是一道模拟题。

## 题目大意.

输入一个带有 $*$ 或 $\ .\ $ 的矩阵，来求是否有一个位置的同行同列中有所有的 $*$ 。

## 做题思路。

先特判，我特判了 4 种情况。

- 当 n 为 1 或 m 为 1 ， 直接输出 YES , 位置为 $（1,1)$。

- 当 $*$ 数为 0 时， 代表没有一个点 ， 输出 YES ,位置为 $(1,1)$。

- 当 $*$ 数为 1 时， 代表只有 1 个点，输出 YES ,位置就在那个点。

- 当 $*$ 数为 2 是， 代表有 2 个点， 输出 YES ,位置在 第一个点的 x 轴和第二个点的 y 轴 或 第二个点的 x 轴和第一个点的 y 轴。

接下来就是一个枚举了，因为我们可以用二个桶在保存每个 x 轴 和 y 轴上有的点数。

每个点的每行每列的点数为这二个桶之和。

如果这个点也是个 $*$ , 要减一。

如果最后的值相加为 $*$ 数，输出 YES，位置为那个点，结束程序。

如果没有这个点，输出 NO 。

接下来就是代码了。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m;
int x[1001];//记录每行有多少 “*”。
int y[1001];//记录每列有多少 “*”。
struct point{
	int x,y;
}a[1000007];//每一个点的位置。
int main(){
	ios::sync_with_stdio(false);
	cin>>n>>m;
	char c[1001][1001];
	int p=0;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			cin>>c[i][j];
			if(c[i][j]=='*'){
				x[i]++;
				y[j]++;
  				//改变这二个桶。
				p++;//“*”的数量增加。
				a[p].x=i;
				a[p].y=j;
  				//储存每个“*”的位置。
			}
		} 
	}
	if(n==1||m==1){
		cout<<"YES"<<endl<<1<<' '<<1;
		return 0;
	}
	if(p==0){
		cout<<"YES"<<endl<<1<<' '<<1;
		return 0;
	}
	if(p==1){
		cout<<"YES"<<endl<<a[1].x<<' '<<a[1].y;
		return 0;
	} 
	if(p==2){
		cout<<"YES"<<endl<<a[1].x<<' '<<a[2].y;
		return 0;
	}
  	//以上为特判。
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			int xxx=x[i]+y[j];//来记录每行与每列的和。
			if(c[i][j]=='*') --xxx;
 			//当这个点为“*”时要减一。
			if(xxx==p){//如果为点数,输出 YES , 答案为 i , j。
				cout<<"YES"<<endl<<i<<' '<<j;
				return 0;//结束程序。
			}
		}
	} 
	cout<<"NO";//如果在上面的循环没有结束，代表无解，输出 NO。
}

```
