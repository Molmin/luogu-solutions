[题目传送门](https://www.luogu.com.cn/problem/CF690E1)

### 题目大意

给出一幅黑白图的灰色值，你需要判断它是否经过翻转，这里的翻转指的是把上半部分平移到下半部分（可以理解为一个经典的 splay 操作：把上半部分反转，把下半部分反转，再把整个反转）。

对于一个数据，只需要满足 $75\%$ 的询问能通过就可以了。

### 解题思路

我们逆向想，从“只需要满足 $75\%$ 的询问能通过就可以了”中能看出，没有程序能做到百分百通过，为什么呢？因为我们采用了一种不完全正确的判断方式，那就是判断图的合理性。

正常情况下，一张图是合理的，意味着它是渐变的，也就是说，图的大多数部分都是相邻的两个色块颜色（即题目中的灰色值）相近，一张图没那么合理时就意味着大多数的相邻色块灰色值相差较大。

但是，“较大”、“相近”如何定义？这就需要翻转图和原图的对比了。

所以我们可以把图翻转，判断前者和后者哪个相邻色块灰色值差总体更小。

这个思路还不是最简便的，这是因为后者仅仅相比前者多了最上面和最下面之间的相差，但是同时也少了中间两行之间的相差，所以我们可以直接判断哪个相差小，中间两行相差小，则没有翻转，否则有。

### 码码

```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
    static int q,n,m,a[2222][2222];
    cin>>q;
    while(q--)
    {
		cin>>n>>m;
		for(int i=1;i<=n;i++)
		{
			for(int j=1;j<=m;j++)scanf("%d",bitand a[i][j]);
		}
		int d1=0,d2=0;
		for(int j=1;j<=m;j++)
		{
			d1+=(a[1][j]-a[n][j])*(a[1][j]-a[n][j]);
			d2+=(a[n/2][j]-a[n/2+1][j])*(a[n/2][j]-a[n/2+1][j]);
		}
		if(d2<d1)puts("NO");
		else puts("YES");
	}
    return 0;
}
```
