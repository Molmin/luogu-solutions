对每列而言有四种情况：

1. 没封锁
2. 都封锁
3. 封锁上面
4. 封锁下面

如果只存在前两种情况，那肯定是能放下的，只要都竖着放就行了。也就是说，我们会尽可能地竖着放，直到遇到某个封锁 **单个格子** 的列。

一旦遇到 3、4 情况之一，显然就要横着放了，然后下一列也会受到影响必须横着放，下下列也是.....

这样，如果直到结束都没遇到下个有封锁的列，肯定是不合法的。

如果下一个有封锁的列是情况 2，也是不合法的。

记当前列封锁格子的 行号+列号 为 $T$，唯一合法的情况是下一个封锁列只封一个格子，并且该格子的 行号加列号 的奇偶性和 $T$ 不同。

然后这列以后又可以竖着放了........直到再次遇到3、4 情况之一。

用`map`写起来很简单，代码如下：

```c++
int main() {
    int _;
    cin >> _;
    while (_--) {
        int n, m;
        cin >> n >> m;
        map<int, int> mp;
        for (int i = 0; i < m; i++) {
            int x, y;
            cin >> x >> y;
            mp[y] += x;
        }
        int ok = 1, last = -1;
        for (auto t : mp) {
            if (last == -1) {
                if (t.second != 3)
                    last = t.first + t.second;
            } else {
                if (t.second == 3) {
                    ok = 0;
                    break;
                }
                if ((last + t.first + t.second) % 2 == 0) {
                    ok = 0;
                    break;
                }
                last = -1;
            }
        }
        if (last != -1) ok = 0;
        puts(ok ? "YES" : "NO");
    }
    return 0;
}
```

