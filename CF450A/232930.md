##### 楼下的各位大佬们好像都用了队列，

## 但本蒟蒻觉得此题拿来练习一下
### 循环&数组插入or弹出，
###### ~~比较好~~

废话不说，先双手呈上代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,x,a[110],b[110];
int main()
{
	cin>>n>>m;
	for(int i=1;i<=n;i++) {scanf("%d",&a[i]);b[i]=i;}
	x=n;
	while(1)
	{
		if(x==1) {cout<<b[1]<<"\n";break;}
		if(a[1]<=m) {for(int j=1;j<=x-1;j++) a[j]=a[j+1],b[j]=b[j+1];x--;}
		  else {a[1]-=m;a[x+1]=a[1];b[x+1]=b[1];for(int j=1;j<=x;j++) a[j]=a[j+1],b[j]=b[j+1];}
	}
	return 0;
}
```

然后，我们来逐步分析：

    1、输入n,m和a数组，并且将每个i标上编号：
```cpp
cin>>n>>m;
for(int i=1;i<=n;i++) {scanf("%d",&a[i]);b[i]=i;}
```


    2、然后，将n赋值给x，构造死循环：
```cpp
x=n;
while(1)
```

    3、死循环内部，首先写结束条件，
    便是题目中只剩最后一个孩子时，
    输出他的编号，接着跳出死循环：
```cpp
if(x==1) {cout<<b[1]<<"\n";break;}
```

    4、如果这个小朋友的满足欲望糖果数在m之下的话
    （看来这个小朋友并不贪心，害），
    就将他的位置挤掉，所有人上前一格，
    注意编号也要跟着上来哦，最后总数减一：
```cpp
if(a[1]<=m) 
{
    for(int j=1;j<=x-1;j++) 
       a[j]=a[j+1],b[j]=b[j+1];x--;
}
```
    5、否则的话，就将他的满足欲望减去m，表示他已经得到了剩下数量，
    将他的满足欲望数和编号排到队尾+1，
    然后用同上的办法，只不过这次要到x，
    将所有人都调前一格，注意总数这次不必减一，
    因为原来第一个小朋友并未满足，并未离开：
```cpp
else 
{
    a[1]-=m;
    a[x+1]=a[1];
    b[x+1]=b[1];
    for(int j=1;j<=x;j++) 
       a[j]=a[j+1],b[j]=b[j+1];
}
```
    6、输出在之前已经输过了，所以不必再次输出了。
    
# Code：
~~上面好像已经有了~~（逃……

# AC抱回家

