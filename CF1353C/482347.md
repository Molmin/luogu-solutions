### 引子
一定要开 long long 数组！不开 long long 见祖宗！
### 解题思路
这题不可能使用搜索！会T飞的！所以得用巧妙的方法解决。首先，我们要把数移到中间，才是最优的，证明：
![](https://cdn.luogu.com.cn/upload/image_hosting/auim1djm.png)

然后，我们来分析 $n$ 等于多少时，步数分别为多少。因为 $n$ 都是奇数，所以为了节约复杂度循环时只用循环奇数。因为 $n = 1$ 时不用移动，所以先要：

```cpp
a[1] = 0;
```

然后，在得到一串循环~~打表~~代码：

```cpp
for (long long i = 3; i <= 500005; i += 2) {
  a[i] = a[i - 2] + (4 * (i - 1) * (i / 2));  //已知，举证算周长点的个数公式是 (边长 - 1) * 4 ；
}
```

然后解析此串代码，每次的新矩阵总步数都相当于上一个矩阵又围上了一圈新周长，每次的新矩阵的边长就是 $i$，并且推出周长点的个数公式：$4 * (i - 1)$。而又因为无论如何周长上每个点到中点的距离都是 $(\dfrac{i}{2})$。所以，这个新矩阵的总步数就是 $a_i = a_{i-2} + (4 \times (i - 1) \times (i / 2))$。

### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
long long a[500005], t, n;
int main() {
  a[1] = 0;
  for (long long i = 3; i <= 500005; i += 2) {
    a[i] = a[i - 2] + (4 * (i - 1) * (i / 2));  //已知，举证算周长公式是 (边长 - 1) * 4 ；
  }
  cin >> t;
  while (t--) {
    cin >> n;
    cout << a[n] << endl;
  }
  return 0;
}
```