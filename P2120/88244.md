# 【ZJOI2007】仓库建设

### Description
L公司有N个工厂，由高到底分布在一座山上。如图所示，工厂1在山顶，工厂N在山脚。

![](https://cdn.luogu.com.cn/upload/pic/66109.png)

由于这座山处于高原内陆地区（干燥少雨），L公司一般把产品直接堆放在露天，以节省费用。突然有一天，L公司的总裁L先生接到气象部门的电话，被告知三天之后将有一场暴雨，于是L先生决定紧急在某些工厂建立一些仓库以免产品被淋坏。 

　　由于地形的不同，在不同工厂建立仓库的费用可能是不同的。
  
  第i个工厂目前已有成品Pi件，在第i个工厂位置建立仓库的费用是Ci。
  
  对于没有建立仓库的工厂，其产品应被运往其他的仓库进行储藏，而由于L公司产品的对外销售处设置在山脚的工厂N，故产品只能往山下运（即只能运往编号更大的工厂的仓库），当然运送产品也是需要费用的，假设一件产品运送1个单位距离的费用是1。假设建立的仓库容量都都是足够大的，可以容下所有的产品。
  
　　你将得到以下数据： 
  
1. 　　● 工厂i距离工厂1的距离Xi（其中X1=0）; 
2.     ● 工厂i目前已有成品数量Pi; 
3.     ● 工厂i目前已有成品数量Pi; 
　　　
   
　　 请你帮助L公司寻找一个仓库建设的方案，使得总的费用（建造费用+运输费用）最小。 

### Input

   　　第一行包含一个整数N，表示工厂的个数。
     
　　接下来N行每行包含两个整数Xi, Pi, Ci, 意义如题中所述。
  
###  Output

　　输出仅包含一个整数，为可以找到最优方案的费用。
  
###   【样例说明】 
　　　在工厂1和工厂3建立仓库，建立费用为10+10=20，运输费用为(9-5)*3 = 12，总费用32。 
   
　　　如果仅在工厂3建立仓库，建立费用为10，运输费用为(9-0)*5+(9-5)*3=57，总费用67，不如前者优。 
   
### 　【数据规模】 
　　　对于20%的数据，N ≤500； 
   
　　　对于40%的数据，N ≤10000； 
   
　　　对于100%的数据，N ≤1000000。 
   
　　　所有的Xi, Pi, Ci均在32位带符号整数以内，保证中间计算结果不超过64位带符号整数。 
   
## 题解

拿到这道题，我们可以立即想到显然这是一道~~搜索~~DP题

![](https://cdn.luogu.com.cn/upload/pic/66110.png)

辣我们假设f[i]表示在第i个工厂建仓库的最小费用

所以费用=在i建设仓库的费用加上运输的费用

所以我们可以得到：

![](https://cdn.luogu.com.cn/upload/pic/66114.png)

诶呀，但是这是O(n^3)的算法，不行啊

![](https://cdn.luogu.com.cn/upload/pic/66110.png)

我们扩以把求和符号拆开嘛！

于是我们可以用前缀和嘛！

(又)于是我们假设![](https://cdn.luogu.com.cn/upload/pic/66116.png)

(双)于是我们假设![](https://cdn.luogu.com.cn/upload/pic/66118.png)


（叒）于是我们得到![](https://cdn.luogu.com.cn/upload/pic/66121.png)

诶呀，但是这是O(n^2)的算法，不行啊

qio一眼数据范围：N ≤1000000

![](https://cdn.luogu.com.cn/upload/pic/66110.png)

仔细观察一下

诶呀他是个单调的嘛！

（运用套路）~~~~斜率优化~~（楼上全是写斜率优化d）~~

四边形不等式优化！

那么啥子是四边形不等式优化呢？

~~四边形不等式：
如果对于i≤i'< j≤j'，有w(i,j)+w(i',j')≤w(i',j)+w(i,j')，我们称函数w满足四边形不等式。~~
（及上次的决策最优一定比上一次的决策非最优在本次决策更优）

简单说就是记录上一次的最优决策来优化这一次的决策

所以上一次的最有决策就可以限制了这一次的决策，减少了许多的复杂度

这里是用的一维的四边形不等式优化

关于具体的证明和概念，可以看一看这一篇[奆佬的博客](https://prime.design.blog/2019/07/27/%E4%BA%8C%E7%BB%B4%E5%9B%9B%E8%BE%B9%E5%BD%A2%E4%B8%8D%E7%AD%89%E5%BC%8F%E4%BC%98%E5%8C%96dp/)

总的来说~~一般~~满足四边形不等式的性质，就可以进行四边形不等式优化

下面来帖一发代码

```cpp
#include<cstdio>
#include<iostream>
using namespace std;
long long n,x[1000010],c[1000010],p[1000010],sump[1000010],sumxp[1000010],f[1000010];
int last[1000010];
int main()
{
	scanf("%lld",&n);
	sump[0]=sumxp[0]=f[0]=0;
	for(int i=1; i<=n; i++)
	{
		scanf("%lld%lld%lld",&x[i],&p[i],&c[i]);
		sump[i]=sump[i-1]+p[i],sumxp[i]=sumxp[i-1]+x[i]*p[i];//前缀和优化 
	}
	f[0]=0;
	sumxp[0]=0;
	for(int i=1; i<=n; i++)
	{
		long long nowf=9223372036854775807;
		for(int j=last[i-1]; j<i; j++)//从上一次的最有决策开始，可以限制本次的决策 
		{
			if(f[j]+x[i]*(sump[i]-sump[j])-sumxp[i]+sumxp[j]+c[i]<nowf)
			{
				nowf=f[j]+x[i]*(sump[i]-sump[j])-sumxp[i]+sumxp[j]+c[i];//动态转移 
				last[i]=j;//记录上一次的最优决策 
			}
			f[i]=nowf;
		}
	}
	printf("%lld",f[n]);
}
```








