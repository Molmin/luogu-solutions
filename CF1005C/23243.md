这道题比较迷，我也不能确定我的做法是不是正解，但是既然 $A$ 了那就来讲一讲好了【逃】

----------
大致题意：

对于一个数列 $a_1, a_2...,a_n$ ，如果每个 $a_i$ 都可以找出一个对应的 $a_j$ $(i\neq j)$ 使 $a_i+a_j=2^d (d>0)$ ，则称该数列为“好数列”，给定一个数列，试求出需要删除多少个数列中的数，才能使该数列为“好数列”。

--------------
这题的数据范围很大，$n$ 足有 $12w$ 的大小，那么复杂度的范围只能是 $O(nlong)$ 或者 $O(n)$

我的程序复杂度是 $O(n)$ 级别的，利用了 **桶** 的思想

那么有人就要问了：$a_i$ 的范围足有 $10^9$ 之大，你怎么用桶呢？

兄弟，cpp有个东西叫**映射** $(map)$

【此处应有滑稽】

做法具体如下：

设定两个 $map$：$m$ 和 $tw$，其中 $m$ 记录数有没有出现过，$tw$ 记录数是否出现了两次

（这里注意使用 $<int, bool>$ 可以有效降低空间复杂度）

读入一个数 $a_i$，将 $m[a_i]$ 设为 $true$，如果 $m[a_i]$ 本来就为 $true$ 的话，将 $tw[a_i]$ 设为 $true$

接下来从 $a_1$ 到 $a_n$ 循环

对于每个 $a_i$，枚举 $j$ 使 $j=2^d$ $(d>0)$，判断 $j-a_i$ 是否出现，即 $m[j-a_i]$ 是否为 $true$，如果一直不为 $true$ 则该数需要删除，$ans+1$

但是如果你直接这么写，你会发现你会有 $WA$ 掉的点，这是为什么呢？

这里就需要用到上方提到的 $tw$ 数组了，举个栗子：

如果 $j=8$，$a_i=4$，可以发现 $m[j-a_i]=m[4]=true$，但是数列中可能只有一个 $4$，这代表着这个 $a_i$ 应该是要删去的，但因为 $m[4]=true$，所以程序并不会判断它删去

也就是说，如果 $j-a_i$ $==$ $a_i$ 的话，我们就需要判断 $tw[j-a_i]$ 是否为 $true$

核心代码如下：

预处理：

```
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&a[i]);
		if(m[a[i]]) tw[a[i]]=1;
		m[a[i]]=1;
	}
```

枚举 $j$：

```
	for(int j=1;j<=1073741824;j*=2)
	{
		if(j<0) break;
		if(j<=a[i]) continue;
		if(m[j-a[i]])
		{
			if((j-a[i]==a[i] && tw[j-a[i]]) || (j-a[i]!=a[i] && m[j-a[i]]))
			{
				flag=1;
				break;
			}
		}
		if(j==1073741824) break;
	}

```