这个题其实没那么nan，只要按照正常思路“模拟”一遍就可以了。

首先考虑一个问题：跑一圈都是跑的相同的一圈，为什么有的点开始就能跑完，有的点开始就跑不完呢。

比如第3个点跑不完，是“NIE”。第1个点能跑完，是“TAK”。

第3个点跑不完，一定是在半路上某两个点中间死掉了。如果我们给每个点设一个“濒死值”，表示刚到某个点，还没有拿这个点的油时，油的剩余量。死掉了就是中间有某个点的“濒死值”小于0了。

而从第1个点跑过来时汽油还有些剩余，正是这些“剩余”，帮它度过了那两个点之间的艰难岁月。

只要度过了最黑暗的一段，其他的就都不是问题了。

**因此，问题转化为了，每个点在初始没有结余的情况下，能否熬过以它开始的一圈中汽油最少的一段（濒死值最小的一个点）。**

所以可以从1开始暴力模拟一遍，求出以1为起点的每个点的“濒死值”。因为是环，所以可以在n后面再补一段1~n。把这段长为
2*n
的路走一遍。
看一下每个点走到自己对应的点的路上最小的濒死值的最小值是否大于这个点的剩余（也就是这个点的濒死值），就可以判断是否能从这个点开始走完一圈了。

**现在，唯一的问题变为了，如何在一个长为 $2n$ 的序列中，求出一些长为 $n$ 的段的最小值。**

是不是和某个题的题面出奇的相似，这不就是[滑动窗口](https://www.luogu.org/problemnew/show/P1886)（一道绿牌题，没做过的可以先去水了它）的题面么，而且这两道题连数据范围都一样，这个暗示.......

至此，这道题就被完美解决了。

思路：预处理+单调队列。还有一点，因为可以从两个方向走，所以还要做一遍反向的从 $2n$ 跑到 $1$ 。预处理也要反向预处理一遍，注意下标，容易懵　。

蒟蒻不会函数不会传参，只能傻傻的写两遍，又臭又长的。
### 代码
```
#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;
int n,h,t;
int v[2001000];//油量 
int d[2001000];//离下一个点的距离 
int a[2001000];//濒死值 
int b[2001000];//以它开始的n个数中濒死值最小的点 
int q[2001000];//队列 
bool ans[2001000];//答案 
int main(){//所有加了"//"的地方都是两遍做不一样的地方，要好好理解，理解不了就都输出出来看一下 
	cin>>n;
	for(int i=1;i<=n;i++)
	cin>>v[i]>>d[i],
	v[i+n]=v[i],d[i+n]=d[i];
	
	//正向 
	for(int i=1,s=0;i<=n+n;i++)//
		a[i]=s,s+=v[i]-d[i];//
	h=0,t=0;
	for(int i=1;i<=n+n;i++)//
	{
		while(h<t&&a[i]<=a[q[t-1]])
		t--;
		q[t++]=i;
		while(h<t&&q[t-1]-q[h]>=n)//
		h++;
		b[i-n]=a[q[h]];//
	}
	for(int i=1;i<=n;i++)
	ans[i]|=(b[i]-a[i]>=0);//
	
	//反向 
	for(int i=n+n,s=0;i>=1;i--)//
		a[i]=s,s+=v[i]-d[i-1];//
	h=0,t=0;
	for(int i=n+n;i>=1;i--)//
	{
		while(h<t&&a[i]<=a[q[t-1]])
		t--;
		q[t++]=i;
		while(h<t&&q[h]-q[t-1]>=n)//
		h++;
		b[i]=a[q[h]];//
	}
	for(int i=1;i<=n;i++)
	ans[i]|=(b[i]-a[i+n]>=0);//
	
	for(int i=1;i<=n;i++)
	cout<<(ans[i]?"TAK":"NIE")<<endl;
}
/*
9
5 1
6 8
4 4
9 9
9 8
3 1
2 1
3 1
3 8
*/
```