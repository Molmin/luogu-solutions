# P7771 【模板】欧拉路径 题解
题目大意：求出图中字典序最小的欧拉路径。

欧拉路径就是在不重复经过边的情况下走过每一条边，和一笔画问题很相似。

#### 首先，需要判断是否存在欧拉路径。

一个图存在欧拉路径有两个条件：

- 将有向边视为无向边后，整张图联通。如果不连通，那么不可能走完所有的边。（这个条件本题已经保证，但是有些题没有保证，需要自行判断）。

- 每个点的入度等于出度或者一个点的入度比出度大一，一个点的入度比出度小一，其他点入度等于出度。如果不满足这些条件，那么一个入度比出度大许多的点周围的边不可能都被经过。

#### 之后，就是确定起点。

如果每个点的入度等于出度，那么无论从哪个点开始走都可以，但是题目要求是字典序最小的，那么就从一开始。如果一个点的入度比出度大一，一个点的入度比出度小一，那么只有从入度比出度小一的点走到入度比出度大一的点才可以。

#### 确定了起点之后，就是求解了。

在建边的过程中，按照起点为第一关键字正序，终点为第二关键字倒序（因为链式前向星建边的时候枚举是从后往前枚举的），之后从起点开始搜索，每次走完一个边删去一个边，将一个点的所有边都搜索完之后将这个点入栈，之后从栈顶开始输出即可。

**为什么需要先入栈，直接输出不行吗？**

答案是不行的。会发现当一个点的所有出边都被搜索完之后，才会被入栈，这样，在栈中的点是无法继续往外走的，而栈外的点才可以往外走。所以，栈外的点在欧拉路径中的位置是在栈内的点之前的，否则，如果先走栈内的点，一些只有栈外的点可以到达而栈内的点无法到达的点是不会被走到的，这样就不能经过所有的边的，不符合要求。所以，当一个点的全部出边都经过之后，表示这一个点不能再到达其他点，为了可以到达其他点，只能让这个点位于其他点之后，所以要入栈。

之后，就可以将代码写出来了。

代码（90分）：
```cpp
#include<algorithm>
#include<cstdio>
#include<iostream>
using std::sort;
int c,T,b[100001],d[100001],h[100001],e[200001],f[200001],s[200001],t[200001];
//b[i]表示第i个点的出度
//d[i]表示第i个点的入度
//f[i]表示第i条边是否被删了
//s是栈
struct node
{
	int u,v;
} a[200001];//记录每一条边
void add(int u,int v)//加边
{
	e[++c]=h[u];
	h[u]=c;
	t[c]=v;
}
void dfs(int u)//求解
{
	int i;
	for(i=h[u]; i; i=e[i])
		if(!f[i])//如果这条边没有被删过
		{
			f[i]=1;//删掉这条边
			dfs(t[i]);
		}
	s[++T]=u;//入栈
}
bool cmp(node a,node b)
{
	if(a.u!=b.u)
		return a.u<b.u;
	return a.v>b.v;
}
int main()
{
	int i,j=0,k=0,n,m,u=1;
	//j记录出度比入度大1的点的个数
	//k记录入度比出度大1的点的个数
	//u表示起点，初始为1
	scanf("%d%d",&n,&m);
	for(i=1; i<=m; ++i)
	{
		scanf("%d%d",&a[i].u,&a[i].v);
		++b[a[i].u];
		++d[a[i].v];
	}//读入并求出入度和出度
	for(i=1; i<=n; ++i)
	{
		if(b[i]-d[i]>1||d[i]-b[i]>1)//如果入度与出度相差大于1，那么不存在欧拉路径
		{
			puts("No");
			return 0;
		}
		if(b[i]-d[i]==1)//出度比入度大1，作为起点
		{
			++j;
			u=i;
		}
		else if(d[i]-b[i]==1)//入度比出度大1
			++k;
	}
	if((j==0&&k==0)||(j==1&&k==1))//有解
	{
		sort(a+1,a+m+1,cmp);
		for(i=1; i<=m; ++i)
			add(a[i].u,a[i].v);//排序后建边
		dfs(u);//求解
		while(T)
		{
		    printf("%d ",s[T]);
		    --T;
		}
	}
	else//无解
		puts("No");
	return 0;
}
```
但是只能得到90分。

分析一下时间复杂度可以发现，排序时间复杂度 $O\left(m\log m\right)$，求解的时间复杂度期望是 $O\left(n+m\right)$ 的，但是如果从一个点连出许多边，那么每次到这个点都需要判断一下这些边是否被经过，如果一个点连的边是 $O\left(m\right)$ 级别的，那么求解的时间复杂度就变成了 $O\left(nm+m^2\right)$，总的时间复杂度就是 $O\left(m\log m+nm+m^2\right)$，很明显，当其中一个点连得边很多的时候就会超时。

这样，就要考虑记录每个点删到哪个边了，所以就需要每次走一条边时改变 $h$ 数组的值，让他记录下一个边即可。

因为只有 dfs 函数改变了，所以只附上 dfs 函数的代码：
```cpp
void dfs(int u)//求解
{
	int i;
	for(i=h[u]; i; i=h[u])
	//if(!f[i])//如果这条边没有被删过
	{
		//f[i]=1;//删掉这条边
		h[u]=e[i];
		//每次走完，将h[u]改为下一条边
		//这样，就不需要用f数组记录一条边是否被删过了
		dfs(t[i]);
	}
	s[++T]=u;//入栈
}
```
这样，求解的时间复杂度就是稳定的 $O\left(n+m\right)$ 了，总时间复杂度为 $n+m+m\log m$，可以过这道题了。

#### 你以为这就结束了？

~~建议在理解上述内容的基础上看。~~

在仔细分析代码发现，将边按照起点排序之后，就不需要建边了，因为每一个点的边都是连在一起的，这样只需要记录每一个点的边是属于哪个范围的即可，所以可以不用建边。优化了空间。

注意，因为不用链式前向星，所以排序时要以起点为第一关键字正序，终点为第二关键字正序，不用倒序了。

又因为已经记录了每个点的出度，所以不用遍历每一个边求每个点的边的范围，只需要枚举每一个点即可， $O\left(m\right)->O\left(n\right)$。

再分析可以发现，如果直接排序，时间复杂度是 $O\left(m\log m\right)$ 的，而在已经记录出每个点的出边的基础上，可以直接求出来每个点对应的边处于的位置，所以可以 $O\left(m\right)$ 的将边按照起点分好类，之后对于相同起点的边内部进行排序，这样在随机图中，每个点为起点大约有 $\frac{m}{n}$ 条边，对一个点排序的时间复杂度为 $O\left(\frac{m}{n}\log\frac{m}{n}\right)$，而总排序复杂度为 $O\left(m\log \frac{m}{n}\right)$。在 本题的极限数据中$\frac{m}{n}=2$，所以总排序的时间复杂度可以认为只有 $O\left(m\right)$ 。只有当 $m$ 很大 $n$ 很小的时候，该方法的时间复杂度为 $O\left(m\log m\right)$。

综上，总时间复杂度下界为 $O\left(n+m+m\log\frac{m}{n}\right)$，上界为 $O\left(m\log m\right)$，在随机图中时间复杂度优秀。

代码：
```cpp
#include<algorithm>
#include<cstdio>
#include<iostream>
using std::sort;
int t,b[100001],d[100001],e[100001],s[100001],a[200001],u[200001],v[200001],st[200002];
//b[i]表示第i个点的出度
//d[i]表示第i个点的入度
//s[i]表示第i个点连的第一条边
//e[i]表示第i个点连的最后一条边
//st是栈
void dfs(int u)//求解
{
	int i;
	for(i=s[u]; i<=e[u]; i=s[u])
	{
		++s[u];//相当于去掉当前的边
		dfs(a[i]);
	}
	st[++t]=u;
}
int main()
{
	int f=0,i,j=0,k=0,n,m,r=1;
	//f记录上一个点的最后一个边的位置（如果不明白可以往下看看）
	//j记录出度比入度大1的点的个数
	//k记录入度比出度大1的点的个数
	//r表示起点，初始为1
	scanf("%d%d",&n,&m);
	for(i=1; i<=m; ++i)
	{
		scanf("%d%d",&u[i],&v[i]);
		++b[u[i]];
		++d[v[i]];
	}//读入并求出入度和出度
	for(i=1; i<=n; ++i)
	{
		if(b[i]-d[i]>1||d[i]-b[i]>1)//如果入度与出度相差大于1，那么不存在欧拉路径
		{
			puts("No");
			return 0;
		}
		if(b[i]-d[i]==1)//出度比入度大1，作为起点
		{
			++j;
			r=i;
		}
		else if(d[i]-b[i]==1)//入度比出度大1
			++k;
	}
	if((j==0&&k==0)||(j==1&&k==1))//有解
	{
		for(i=1; i<=n; ++i)
		{
			d[i]=s[i]=f+1;
			//f是上一个点连的最后一个边，那么f+1就是这一个点的第一个边
			//d[i]作为临时变量，记录第i个点正在往数组里放第d[i]条边
			e[i]=f+b[i];//第i个点连的最后一个边
			f=e[i];//记录这一个点的最后一个位置
		}
		for(i=1; i<=m; ++i)
			a[d[u[i]]++]=v[i];//按照起点分类
		for(i=1; i<=n; ++i)
			sort(a+s[i],a+e[i]+1);//对相同起点的数进行排序
		dfs(r);
		while(t)
			printf("%d ",st[t--]);
	}
	else//无解
		puts("No");
	return 0;
}
```