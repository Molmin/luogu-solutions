~~考虑到做橙题还要看题解的都是萌新~~，本片题解将会讲述做题时的**思路**而非得到的**结论**。  

首先由于段和段之间没有影响，所以切分顺序没有影响。不妨从左边开始切。  

**1.暴力**  
时间复杂度：$O(n\times q\times \sum^{n}_{i=1}{a_i})$  
空间复杂度：$O(n\times \sum^{n}_{i=1}{a_i})$    
暴力还是很好想的。每当有一块数量为偶数，就把他除以 $2$，然后把他后面的全都向右一格，在空出来的地方加入除以 $2$ 的结果。  
然而明显会 TLE。  

**2.链表优化**  
实际上插入/删除数据的最高效方法就是链表了。**但是问题就在于暴力的时空复杂度瓶颈不在于切蛋糕而是询问，排除。**  

**3.叫不上来名字的优化**  
时间复杂度：$O(nq+nlog_2(a_i))$  
空间复杂度：$O(n)$  
**备注：为了方便，称呼未切分的一段蛋糕为“条”，切分过后成为“段”。**  
我们不难发现，对于长度为 $2^k\times x$ 的一段且 $x$ 为奇数，会切分出 $2^k$ 段长度为 $x$ 的。那我们不妨把原数组中这个元素的值改为 $x$ ，再开一个数组同样下标存储 $2^k$。  
询问的时候就看需要查询的下标会落在哪个位置。比如，前 $i$ 条蛋糕分别被切成了 $1,4,4,2$ 段，那么当查询的下标为 $10$ 或 $11$ 的时候答案就是第 $4$ 条蛋糕的切分后长度。 

**4.前缀和优化**  
时间复杂度：$O(nq+nlog_2(a_i))$  
空间复杂度：$O(n)$  
看似是一个常数级优化，但是实际上是终极优化的重要铺垫。
做法很简单，就是把存储切分后段数的数组求一个前缀和，然后对于要查询的下标 $j$，如果 $j>s_i$ 那么 `i++`，否则直接输出 $a_i$。  

**5.二分优化**  
时间复杂度：$O(qlog_2(n)+nlog_2(a_i))$  
空间复杂度：$O(n)$  
终极优化，在前缀和优化的基础上二分 $i$，使得最终 $s_{i-1}<j\le s_i$，输出 $i$ 即可。  

**6.~~最重要的~~ AC Code**  
```cpp
#include<cstdio>
#include<algorithm>
#define int long long //不开long long见祖宗
#define maxn 200005
#define getll(x) scanf("%lld", &x)

using namespace std;

int n, a[maxn], num[maxn], q, x, s[maxn];

signed main() {
	getll(n);
	for(int i = 1; i <= n; i++) {
		num[i] = 1;
		getll(a[i]);
		while(!(a[i] & 1)) { //循环求最终长度和数量
			a[i] >>= 1;
			num[i] <<= 1;
		}
		s[i] = s[i - 1] + num[i]; //求数量前缀和
	}
	getll(q);
	while(q--) {
		getll(x);
		int ans = a[(lower_bound(s + 1, s + 1 + n, x) - s)]; //lower_bound，C++库里内置的二分函数，返回区间中第一个大于等于 val 的数的地址，减去s就可以得到下标。
		printf("%lld\n", ans);
	}
}
```