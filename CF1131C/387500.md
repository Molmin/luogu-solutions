## CF1131C Birthday
[原题链接](https://www.luogu.com.cn/problem/CF1131C) 代码最短，时间最优解。

## 分析
先写一组长度为奇数的数据 $a_{1}\sim a_{5}$，其长度记为 $n$：
- 1 4 3 8 6

将这组数据排序，得到有序数列 $(1,3,4,6,8)$，将它们围成一个环，显然不是最优情况。那么何时情况最优呢？可以尝试用贪心思想找到局部最优解。

先找到最大值和最小值，当 $1$ 与 $3$，$4$ 相邻时差值最小，$8$ 与 $4$，$6$ 相邻时差值最小。这时发现，最大值和最小值都与中位数 $4$ 相邻。
得到两个数列 $(3,1,4)$ 和 $(4,8,6)$，合并得 $(3,1,4,8,6)$。由于得到的数列是一个环，故可以表示为 $(1,4,8,6,3)$，排列方式为 $(a_{1},a_{3},a_{5},a_{4},a_{2})$，即先顺序排列 $a$ 的奇数位置，再从 $n-1$ 位置开始倒序排列 $a$ 的偶数位置。

再写一组长度为偶数的数据 $a_{1}\sim a_{4}$，长度同样记为 $n$：
- 2 6 3 1

排序，得到有序数列 $(1,2,3,6)$，找到最大值和最小值，当 $1$ 与 $2$，$3$ 相邻时差值最小，$6$ 与 $2$，$3$ 相邻时差值最小。发现，最大值和最小值都与 $2$，$3$ 相邻。得到数列 $(2,1,3)$ 和 $(3,6,2)$，合并得 $(1,3,6,2)$。依然是先顺序排列 $a$ 的奇数位置，但后面变成了从 $n$ 位置开始倒序排列 $a$ 的偶数位置。

简单归纳一下，将数列排序后：

1. $n$ 为奇数时，先顺序输出 $a$ 的奇数位置，再从 $n-1$ 位置开始倒序输出 $a$ 的偶数位置。

2. $n$ 为偶数时，先顺序输出 $a$ 的奇数位置，再从 $n$ 位置开始倒序输出 $a$ 的偶数位置。

用 ```sort()``` 排一遍序，输出奇数位，判断 $n$ 的奇偶性，输出偶数位，结束。

## Code
```cpp
#include<iostream>
#include<algorithm>
using namespace std;
int a[105],n;
int main(){
    cin>>n;
    for(int i=1;i<=n;i++) cin>>a[i];
    sort(a+1,a+n+1);
    for(int i=1;i<=n;i+=2) cout<<a[i]<<" "; //输出奇数位置 
    if(n%2==0) for(int i=n;i>=2;i-=2) cout<<a[i]<<" "; //长度为偶，从n开始 
    else for(int i=n-1;i>=2;i-=2) cout<<a[i]<<" "; //长度为奇，从n-1开始 
    return 0; 
}
```
