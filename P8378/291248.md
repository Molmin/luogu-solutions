# P8378 [PFOI Round1] Two Sequences 题解

[P8378 [PFOI Round1] Two Sequences](https://www.luogu.com.cn/problem/P8378)

## 题意

这道题题面不怎么好理解，我们来分析一下：

> 调皮的小 x 见他不在机房，每天都在并查集上不断 merge。 注意到小 x 不喜欢 ==，他觉得这特别像他的眼睛，于是他不会使 merge 函数在第二行的条件语句中被 return，否则他会十分气愤。

这一句表示，操作序列中每一个操作的 `fx,fy` 都一定不同，也就是每一次 `merge` 均会发生一次合并。

>现在的已知信息就只有最终的 $fa$ 数组了。 而 syzf2222 希望还原小 x 的操作序列（即若干次按顺序进行的 `merge` 操作）。由于他名字里有很多个 2 而且本人也非常 2 ，他希望知道对于每一天，有多少个 $fa$ 数组恰好能被还原成两种操作序列，答案对 $998244353$ 取余数。

每一种操作序列一定会对应一个 $fa$ 数组，我们就需要求出有多少个 $fa$ 数组**有且仅能由两种操作序列得到**。

>两个操作序列不同，当且仅当某次 `merge` 时的变量 `fx,fy` 至少有一个不同。

这里表示两次 `merge`是否相同不取决于它所操作的点，**而是它所操作的连通块**。

注意！这里的 $fa$ 数组不是在最后对于每个数 `find` 得到的数组，也就是 $fa_i$ 数组**并不一定就是 $i$ 所在连通块的编号**，因为有可能 $fa_i$ 数组**没有更新**，$fa_i$ 应该保持最后一次 `find` 或 `merge` 的结果。

我们来看一下样例：$fa$ 为 $[1,1,1]$ 的时候，有 ` merge(2,1)`,`merge(3,1)` 和 `merge(3,1)`,`merge(2,1)` 两种。

肯定有人想问：`merge(2,1)`,`merge(3,2)` 为什么不行，因为它与第一种情况**所操作的连通块是相同**的，$fx,fy$ 分别是 (2,1),(3,1)。

肯定也有人想问：`merge(3,2)`,`merge(2,1)` 为什么不行,这种情况的 $fx,fy$ 虽然和之前不同，但是它得到的 $fa$ 数组是 $[1,1,2]$ ，因为 $fa_3$ 在第二次操作后**并没有更新**！

## 思路

我们把整个图分成许多连通块，显然，**总的情况数不少于所有连通块的情况数**，也就是说不能有任何一个连通块情况多于 $2$ 个。

对于每个连通块，我们先分一个类：$fa$ 数组为**最新的**和**不为最新的**两种情况

### $fa$ 为最新

在这种情况中，由于 $fa$ 数组是最新的，说明 $fa$ 内所有数都是相同的（注意，现在讨论的都只针对一个连通块）。显然，连通块中**点个数越多，情况越多**。社总共 $m$ 个点，显然，如果所有点都直接连到根节点所在连通块，就会有 $m-1$ 个 `merge`，而这些操作是没有顺序的，所以总情况就是 $(m-1)!$，因此，$m$ 多于 $3$ 时，总情况数一定多于 $2$。而我们可以验证 $m=2,3$ 均是合法的。

其中 $m=2$ 时有 $1$ 种操作序列，每个序列中均有 $1$ 个操作（称其为连通块 $1$）。

$m=3$ 时有两种操作序列 $2$ 种序列，每个操作序列中均有 $2$ 个操作（称其为连通块 $2$）。

### $fa$ 不为最新

首先，$m=2$ 是不可能，只有 $m \geqslant 3$ 时有可能。

如果要满足不为最新，一定有一条链长度不小于 $3$，也就是不少于 $2$ 个操作，而如果有多条链，情况数一定多于 $2$，不可能，因此整个连通块就是一条链。（称其为连通块 $3$）

### 合并

我们已经有 $3$ 中合法的连通块了，我们要把他们组合起来：

如果使用连通块 $1$，由于它已经有两种操作序列了，所以再添加任何一个连通块情况数一定增加，所以只能有 $1$ 个连通块 $1$。

如果使用连通块 $2$，显然它不能和连通块 $1$ 组合。如果用 $2$ 个连通块 $2$，由于我们只需要保证连通块内部操作的相对顺序不变，不同连通块的操作顺序可以改变、交叉，所以共有 $2$ 种情况，符合。而和连通块 $3$ 搭配，由于连通块 $3$ 操作数不少于 $2$，总序列数一定多于 $2$，不符。

如果使用连通块 $3$，由于它有不少于 $2$ 个操作，只添加 $1$ 个操作都有不少于 $3$ 种的情况，无法使用。

于是我们得到了两种图：$1$ 个连通块 $1$ 和 $2$ 个连通块 $2$。

## 计算

然后，我们运用~~小学~~数学知识，来计算总情况数：

首先计算第一种情况，首先要选出 $3$ 个点，情况数为

$$\frac{n(n-1)(n-2)}{6}$$

对于任意 $3$ 个点，要选出 $1$ 个作为根节点，其它 $2$ 均指向它，所以有 $3$ 种情况，总共就是

$$\frac{n(n-1)(n-2)}{2}$$

然后是第二种情况，首先选出 $4$ 个点

$$\frac{n(n-1)(n-2)(n-3)}{24}$$

然后选 $2$ 个根节点，共 $6$ 种

$$\frac{n(n-1)(n-2)(n-3)}{4}$$

剩下的点各选一个连通块加入

$$\frac{n(n-1)(n-2)(n-3)}{2}$$

总共的情况就是

$$\frac{n(n-1)(n-2)(n-3)+n(n-1)(n-2)}{2} $$

也就是

$$\frac{n(n-1)(n-2)^2}{2} $$

## code

```cpp
#include<cstdio>
#include<iostream>
typedef long long ll;
const ll P=998244353;
// #define getchar()(p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)
char buf[1<<21],*p1=buf,*p2=buf;
inline int read()
{
    char c=getchar();int x=0;bool f=0;
    for(;!isdigit(c);c=getchar())f^=!(c^45);
    for(;isdigit(c);c=getchar())x=(x<<1)+(x<<3)+(c^48);
    if(f)x=-x;return x;
}
int main()
{
    int T=read();
    while(T--)
    {
        ll n=read();
        printf("%lld\n",(n*(n-1)/2)%P*(n-2)%P*(n-2)%P);
    }
    return 0;
}
```