###### 蒟蒻第一次写题解，写的不好，见谅。

## Solution

~~看到这个题第一眼就知道这肯定不是并查集的题~~

把题意转化一下：```fa``` 数组进行**两次** ```merge``` 操作可以得到几种序列

更简单一点，可以看成把 ```fa``` 数组中的两个元素分别改变成另一个元素，由多少种不同的方案

把玩一下样例我们发现只有两种情况：


- 把两个元素改成一样的值

- 把两个元素改成两个不一样的值


讨论一下这两种情况


------------

第一种情况：

第一个被修改元素时有 $n$ 个位置可以选，修改的值不能选择该元素的值，所以有 $n - 1$ 个值可以修改。

第二个被修改元素不能选第一个元素，也不能选第一个元素被修改的那个值，所以有 $n - 2$ 个位置可以选，被修改的值和第一个元素被修改的值一样，只有一种情况。

有可能会出现重复情况，注意去重

根据乘法原理可得：

$$ \frac {n(n - 1)(n - 2)}{2} $$

------------

第二种情况

第一个被修改元素时有 $n$ 个位置可以选，修改的值不能选择该元素的值，所以有 $n - 1$ 个值可以修改。

第二个被修改元素不能选第一个元素，也不能选第一个元素被修改的那个值，所以有 $n - 2$ 个位置可以选，被修改的值不能选该元素、第一个被修改的元素，修改第一个元素的值，所以有 $n - 3$ 种情况。

根据乘法原理可得：

$$ \frac {n(n - 1)(n - 2)(n - 3)}{2} $$


最后把这两种情况的方案数加起来就是最终答案:

$$ \frac {n(n - 1)(n - 2)}{2} + \frac {n(n - 1)(n - 2)(n - 3)}{2} $$

化简得：

$$ \frac {n(n - 1)(n - 2)^{2}}{2} $$

代码注意一下精度就好了

## AC Code

```
#include <iostream>
#define ull unsigned long long

using namespace std;

const ull mod = 998244353;
ull T, n;

ull work(ull n){
	ull res = 0;
	res += n;
	res *= (n - 1);
	res /= 2;
	res %= mod;
	res *= (n - 2);
	res %= mod;
	res *= (n - 2);
	res %= mod;
	
	return res;
}

int main(){
	cin >> T;
	while(T--){
		cin >> n;
		cout << work(n) << endl;
	}
	
	
	return 0;
}
```