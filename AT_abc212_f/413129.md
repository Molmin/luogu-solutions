[题目传送门](https://www.luogu.com.cn/problem/AT_abc212_f)

考虑模拟，首先把每一趟巴士和每一个查询拆成两个部分：

- 巴士：上车部分 $($ 类型 $4)$ 和下车部分 $($ 类型 $3)$
- 查询：出发部分 $($ 类型 $1)$ 和结束部分 $($ 类型 $2)$

```cpp
rep1(i, 1, m) {
	int x, y; scanf("%d%d%d%d", l + i, r + i, &x, &y);
	p[++tot] = {l[i], x, i, 4}; p[++tot] = {r[i], y, i, 3};
}
rep1(i, 1, q) {
	int x, y, s; scanf("%d%d%d", &x, &s, &y);
	p[++tot] = {s, x, i, 1}; p[++tot] = {0, y, i, 2};
}
```

然后以时间为第一关键字，类型为第二关键字从小到大排序（因为查询是整点时刻，而巴士则是多了 $0.5$ 小时，所以对于同一个时刻，查询的类型应该在巴士的前面，其次，对于同一时刻的上车和下车，不可能是同一趟巴士，所以为了下车之后能立即上车，应该将下车的类型放在上车的前面）


```cpp
bool cmp(node x, node y) {return x.t == y.t ? x.op < y.op : x.t < y.t;}
```

---

这个时候我们会发现，如果直接模拟，每个查询会从各个城市出发并乘坐各个巴士，最坏情况会移动 $O(n)$ 次，对于 $Q$ 个查询，复杂度为 $O(nQ)$ ，显然会超时。这个时候可以发现一个性质，当有大于一个的行程**同时**处于**同一个**城市的时候，之后这几个行程的行动路线将会**一模一样**，所以，对于所有这样出现在一个城市的行程，我们可以用**并查集**把他们**并做一个行程**，从而避免**多个行程重复移动**的过程，当其中一个行程需要结束的时候，只需要访问祖先节点并记录当前状态，就是答案。具体处理如下：

- 类型一：对于行程 $id$ ，高桥会从 $t$ 时刻从城市 $s$ 出发，此时如果城市 $s$ 已有其他行程，则与这个行程进行合并，否则将此行程记录于城市 $s$ 当中，并更新城市 $s$ 当中的行程状态。

```cpp
if(op == 1) {
	int x = c[s]; if(!x) c[s] = id;
	if(x && fa(x) != fa(id)) hb(x, id);
	c[s] = fa(c[s]); tr[c[s]] = {0, s};
}
```

- 类型二：对于行程 $id$ ，高桥即将于 $t$ 时刻结束行程，访问祖先节点，记录此行程的答案为当前状态。（注意，此时不能删除该行程，因为可能有其他行程跟此行程合并但并未结束行程，所以应让该行程继续行动）

```cpp
if(op == 2) {int x = fa(id); ans[id] = tr[x];}
```

- 类型三：对于巴士 $id$ ，巴士会于 $t$ 时刻把车上的行程送到城市 $s$ ，如果城市 $s$ 已有行程，则进行合并，否则记录，并更新行程状态。（注意，如果巴士上没有行程，不能合并）

```cpp
if(op == 3) {
	int x = c[s]; if(!x) c[s] = b[id];
	if(x && b[id] && fa(x) != fa(b[id])) hb(x, b[id]);
	c[s] = fa(c[s]); tr[c[s]] = {0, s};
}
```

- 类型四：对于巴士 $id$ ，巴士将于 $t$ 时刻把位于城市 $s$ 的行程带往下一个城市，撤销城市 $s$ 当中的行程状态，添加巴士的行程状态，并更新此行程的状态。

```cpp
if(op == 4) {
	b[id] = c[s]; c[s] = 0;
	tr[b[id]] = {1, id};
}
```

最后根据状态输出答案

```cpp
rep1(i, 1, q) {
	if(ans[i].ft) printf("%d %d\n", l[ans[i].sd], r[ans[i].sd]);
	else printf("%d\n", ans[i].sd);
}
```