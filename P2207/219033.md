这道题是区间取点问题，一种贪心的思想

把所有区间按b从小到大排列（b相同时a从大到小排列），第一个区间取最后一个点。

当你每一次都选择区间的最右端，才能保证每一个选的点覆盖的范围都是最广泛的，也就是说选的点才是最少的。

和之前不相交区间的思考方法类似，把区间进行预处理，按照端点的大小排序（同样，按照右端点排序会好理解一点，但是左端点排序一样可以起到作用，初学者不必迷信右端点排序）。 
预处理过后，求解策略的思路和求不相交区间相似，如果下一个区间的左端点不被覆盖，则答案+1，如下：

```cpp

while(剩余区间的数目不为0)
{
    if（找到符合条件的下一个区间）
    {
        当前区间 = 下一个区间；
        答案数+1；
    }
 
    区间数--；
}
```
（这是伪代码）

然后就是这道题了qwq，原理是一模一样的