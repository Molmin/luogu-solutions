这是一篇很啰嗦、很细致的题解，补全了其他题解中说的不是那么清楚的地方。更欢迎大家提意见，我们一起修改完善。

## 题意简述
有一个数组 $a$，从中选出尽可能多的数，使得这些数的最小公倍数不超过一个给定的数 $m$。如果有多种选择，输出任意一种即可。输出格式为，在第一排输出最小公倍数和选出数的数量，在第二排递增地输出选出的数的下标。

## 解法分析
拿到这道题，我们可能束手无策。不妨想一想，对于一种选择，记这些数的最小公倍数为 $lcm$，那么所有选出的数应该都是 $lcm$ 的因数。我们可能会想，是不是暴力枚举 $lcm$ 的值，然后看一看数列中有多少个数能够被枚举到的 $lcm$ 整除，记为 $res$，最后对所有的 $res$ 取一个最大值得到最多可以选多少个数。其实这个复杂度是很高的，为 $O(n\cdot m)$。

对于我们可以转换一个方向，因为一个数被选中则是 $lcm$ 的因数，所以把每一个数都应该融入它的所有在 $m$ 以内的倍数的选数范围。因此对于序列中的每一个数我们只需要把他的所有倍数的答案都加上 $1$，也就是说如果记 $lcm=x$ 时最多可以选 $res_x$ 个数，那么对于 $\underset{1\le i\le n}{a_i}$，将所有满足 $k\times a_i\leq m$ 的 $res_{k\times a_i}\gets res_{k\times a_i}+1$。最后统计一下，哪一个 $res$ 最多。

我们发现这样写是会超时的。我们发现，如果一个数出现多次，那么每次都要大费周折去枚举他的所有倍数，所以我们可以一次性把 $res_{k\times a_i}$ 加 $cnt_{a_i}$，其中 $cnt_{a_i}$ 代表序列 $a$ 中 $a_i$ 的出现次数。然后把 $a_i$ 标记，以后不再管它。

可是有一个问题，就是 $a_i\leq 10^9$ 这个太大了。我们发现，既然 $lcm$ 都要小于 $m$ 那么那些大于 $m$ 的 $a_i$ 肯定是废物啦！对于这种我们直接装作没看见就完事了。 

于是我们愉快地用 $O(m\log m)$ 的复杂度通过了本题。（建议不要用 cin，太慢）

## 代码
```
#include <bits/stdc++.h>
using namespace std;
const int N=1e6+5;
int a[N],res[N],cnt[N],book[N];
//a:原数组 res:答案数组 cnt:出现次数 book:标记不用管的a[i]
int main()
{
	int n,m;
	scanf("%d %d",&n,&m);
	for(int i=1;i<=n;i++){
		scanf("%d",&a[i]);
		if(a[i]<=m) cnt[a[i]]++; //只管不大于m的数
	}
	for(int i=1;i<=n;i++){
		if(a[i]>m || book[a[i]]) continue;//大于m的或者已经处理过的
		for(int j=1;a[i]*j<=m;j++)//j枚举是a[i]的多少倍，lcm不能超过m
			res[a[i]*j]+=cnt[a[i]];
		book[a[i]]=1;
	}
	int lcm=1,ans=0;
	for(int i=1;i<=m;i++) 
		if(ans<res[i]) //取最大值，同时把lcm算一下
			ans=res[i],lcm=i;
	printf("%d %d\n",lcm,ans);
	for(int i=1;i<=n;i++)
		if(lcm%a[i]==0) //最终的lcm都已经算好了，那么所有可以被他整除的a[i]都应该要选
			printf("%d ",i);
	return 0;
} 
```