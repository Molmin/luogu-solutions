/\* floyd 算法


保存了之前的路径最短的路迹，不是单单的只转一点


利用o（n^3)的循环的结果哦表示，但是数字大就不行


比如相当于3->4的路中有1转折，


如果短就记下来，就数据变成了4->1->3,


在可以试试4->3的捷径


所以k的循环从一层开始


\*/


```cpp
#include <bits/stdc++.h>万能头文件
using namespace std;
int f[10000][10000];         //开创一个数组
int main() {
    int n;
    cin>>n;            //输入数据n
    for(int i=1; i<=n-1; i++)      //floyd 算法
        for(int j=i+1; j<=n; j++)
                    cin>>f[i][j];
    for(int i=1; i<=n; i++)
        for(int j=1; j<=i; j++)
            if(i!=j)           //如果不是i->i的情况，记为∞
                f[i][j]=99999;      //让9999记为无穷大
    for(int k=1; k<=n; k++)
        for(int i=1; i<=n; i++)//保存了之前的路径最短的路迹，不是单单的只转一点
```
利用o（n^3)的循环的结果哦表示，但是数字大就不行

比如相当于3->4的路中有1转折，


```cpp
            for(int j=1; j<=n; j++)//开始循环
                if(f[i][j]>f[i][k]+f[k][j])      //即最重要的转移方程，如果小就交换，如果看不懂就私信我，有文档
                    f[i][j]=f[i][k]+f[k][j];//交换数据
cout<<f[1][n];      //输出1->n
}
```