P1359题解

相信各位看过楼上dalao们的做法~~(SPFA,DP等等)~~后，已经对本题有了些感悟。

其实本题的做法有两种。

1、带权最短路~~(裸的)~~

由题意我们可以知晓我们需要求出从起点到起点以下的每个点的带权最短路。我们想当然的可以想到SPFA,Dijkstra,Floyd。

首先我们来谈谈SPFA和Dijkstra。学过最短路的人应该都知道。对于大数据，我们应该用SPFA或者Dijkstra，否则会超时。而这两种方法，有那么一点点小区别~~(一个用来做有稠密点的，一个做点稀疏一点的)~~。那么对于Floyd，则是针对于小数据的~~(毕竟是代码最好打的一种)~~，数据一大，就会超时。

然而我们看本题，n为正整数且n<=200。本蒟蒻一算，应该不会超时~~(后来数据证明最慢的点也只要20ms过)~~，所以便打了一份Floyd。

2、DP(动规)

由于没有后效性，所以我们可以再此题用DP来处理。

楼上dalao已经帮我们写出了状态转移方程：f[j]=min(f[j],f[i]+a[i,j])~~(帮你们copy一下，省的你们往下翻)~~

f[j]指的是当我们需要在j点上岸时所需要交的最少租金。很显然，我们可以通过不断地向后进行DP，从而得到从起点到最终点的路途中每个点上岸所需的最小租金。

那么由于本题数据较小，本蒟蒻便用Floyd~~(我才不会告诉你我懒得打SPFA和Dijkstra呢。。)~~



------------------------华丽丽的分割线------------------------

```
#include<iostream>
using namespace std;
int a[210][210];
int f[210][210];//用来存放个点的最小租金
int main()
{
    int n;
    cin >>n;
    for (int i=1;i<n;i++)
        for (int j=i+1;j<=n;j++)
            {
                cin >>a[i][j];
                f[i][j]=a[i][j];
                //建立一个初始最小租金。
            }
    for (int i=1;i<=n;i++)
        for (int j=1;j<=n;j++)
            if (f[i][j]==0) f[i][j]=9999999;
    //如果我们没有这两点最初的最小租金，那么就将其赋予一个hin大的量
    //这样可以使后面比较时不会出错..
    for (int i=1;i<=n;i++)
        for (int j=1;j<=n;j++)
            for (int k=1;k<=n;k++)  if (f[i][k]+f[k][j]<f[i][j]) f[i][j]=f[i][k]+f[k][j];
    //Floyd(裸的)
    cout <<f[1][n];//最后进行输出..
    return 0;
}
```
献上本蒟蒻冗长的代码..
望dalao勿喷..