//题目显而易见是要求最长上升序列，而且只要求输出最长上升序列的长度，所以用一个f数组，来存长度为i的最长上升序列的最优的情况。举一个例子。
   3 7 43 5 1 46
先将f数组附为极大值，然后开始改，从3开始，以3结尾的最长上升序列长度为1，所以f[1]=3,
然后到7，以7结尾的最长上升序列长度为2，所以f[2]=7,
然后是43，以43结尾的最长上升序列长度为3，所以f[3]=43,
到5，以5结尾的最长上升序列长度为2，而且5比7小，从而将f[2]改为5,而后同理将f[1]=1,将f[4]=46.这么一来f数组不为极大值的内容的长度就为最长的上升序列。

这就是这种思路的大概想法，那么如何将5放进数组呢？跑循环是一种较为简单的思路，但代码麻烦，
所以我用的是lower_bound()函数，返回一个 iterator 它指向在[first,last)标记的有序序列中可以插入value，而不会破坏容器顺序的第一个位置，而这个位置标记了一个不小于value 的值 [1]。该函数为C++ STL内的函数。 （这是百度说的，大家自行理解） emmmmmmmm其实我这个学的并不是很好，关于这个函数大家可以自己理解一下。大家直接看代码吧。



```
#include<iostream>
#include<cstring>
#include<algorithm>
#include<cstdio>
#include<vector>
using namespace std;     //前面这些应该没什么
const int maxn=1000000; //无脑开数组
int f[maxn];
int n;
int main()
{
    cin>>n;
    memset(f,0x3f,sizeof(f));
    for(int i=1;i<=n;i++)
    {
       int x;   
       cin>>x;    //因为每个数据只会用一次，所以不需要存数据，直接读入后跑，求出来他在f数组里的位置
       *lower_bound(f+1,f+n+1,x)=x; //如果这个数比之前的数小,用lower_bound()函数找到它适合的位置将这个数放进去
    }
    cout<<n-(lower_bound(f+1,f+n+1,f[0])-f-1);    //再用lower_bound()函数找出f数组里第几个没有被改变，减去1就是最长递增序列的长度。用n减去他就是要改变的数字的数目。
    //system("pause");
    return 0;
}  
      
      
      
//萌新的处女题解，大佬轻喷。      
      
```

