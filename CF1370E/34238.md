### Solution

首先先删去 $a,b$ 串相同的元素。

然后只保留 $a$ 的元素就可以求答案了，考虑一次可以使一串 $1010101\dots$ 或 $0101010\dots$（长度为偶数）符合条件。

先判断是否有解：若 $0,1$ 个数相等，则有解。

扫一遍数组，过程中存下当前位置有多少个 $0$ 结尾的串，有多少个 $1$ 结尾的串，每次把 $0$ 加入到 $1$ 结尾的串中，把 $1$ 加入到 $0$ 结尾的串中。如果没地方加，就新开个串。

这样构造出来的答案不一定合法，但是由于 $0,1$ 的个数相同，所以长度为奇数的末尾为 $0$ 的串和长度为奇数的末尾为 $1$ 的串的个数是相同的，把末尾的 $0$ 补过去就好了。

显然这样是最优的。

### Code

```cpp
int n, cnt[2], cnt_df; char a[kN], b[kN];
int main() { 
	scanf("%d%s%s", &n, a + 1, b + 1);
	for(int i = 1; i <= n; ++i) {
		if(a[i] != b[i]) {
			int cur = a[i] - '0';
			if(cur && cnt[0]) --cnt[0];
			if(!cur && cnt[1]) --cnt[1];
			if(cur) ++cnt[1], ++cnt_df;
			else ++cnt[0], --cnt_df;
		}
	}
	printf("%d\n", cnt_df ? -1 : cnt[0] + cnt[1]);
	return 0;
}
```