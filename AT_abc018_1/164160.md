# 这道题用桶排序即可。
[题目传送门](https://www.luogu.org/problemnew/show/AT1185)

我不知道这道题咋绿了，最多就普及难度。

为什么要选桶排序呢？

1.简单，容易打。

2.可以对付n比较大的。

3.省时。

4.本人对桶排序不熟。

桶排序不好的一点是：耗空间大。

变量提醒：**a[4]是3个人的得分，b[101]是桶，c[4]是来记排名的，s就是排名，s要从1开始，没有第0名这种说法**。

我来补充补充桶排序的介绍：

**桶排序(Bucket Sort)的原理很简单，它是将数组分到有限数量的桶子里。假设待排序的数组a中共有N个整数，并且已知数组a中数据的范围[0, MAX)。在桶排序时，创建容量为MAX的桶数组r，并将桶数组元素都初始化为0；将容量为MAX的桶数组中的每一个单元都看作一个"桶"。
在排序时，逐个遍历数组a，将数组a的值，作为"桶数组r"的下标。当a中数据被读取时，就将桶的值加1。例如，读取到数组a[3]=5，则将r[5]的值+1。**

[本段摘抄的网站](https://www.cnblogs.com/skywang12345/p/3602737.html)

代码如下：

```
#include<bits/stdc++.h>//万能头文件
using namespace std;//使用标准命名空间
int a[4],b[101],c[4],s=1;//前面变量说得很清楚了
int main()//也许可以直接main()，不用int 。
{
for(int i=0;i<3;i++)
cin>>a[i],b[a[i]]++;//输入得分，用桶来记
for(int i=100;i>0;i--)//开始了，注意要从最高分开始，没有0分，不用管它
{
if(b[i]!=0)//如果桶有记的话
{
for(int j=0;j<3;j++)//就找这个得分
if(i==a[j])c[j]=s;//找到要把排名记起来，不能直接break;因为有同分的可能，算是并列
s++;//排名要加！不要忘了！
}
}
for(int i=0;i<3;i++)
cout<<c[i]<<endl;//直接输出，注意还要换行！
return 0;//注意要return 0;
}
```

代码不长，只是20行而已。（本人自我安慰能力强）

**题解有问题，可以私信我。**