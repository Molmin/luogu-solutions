### Solution

这题看起来无从下手，但从“数位非严格单调递增”这个条件，我们能看出：
【例】
```cpp
11222333334789999999999999=:
11111111111111111111111111
  111111111111111111111111
     111111111111111111111
          1111111111111111
           111111111111111
           111111111111111
           111111111111111
            11111111111111
             1111111111111
```
就是可以把数拆成至多 $9$ 个 $111 \cdots 1$ 的数（记作 $a_i$）。
然后 $n \le 10^{18}$，怎么办呢？总不能枚举 $1$ 的个数吧。
注意到 $p \le 500$，又根据 [ABC258E](https://atcoder.jp/contests/abc258/tasks/abc258_e)
可以发现这一堆数的余数是循环的（$a_i = 10a_{i-1} + 1$）
这样我们暴力（把 $\texttt{floyd}$ 判圈算法扔到了火星上也能过）找到循环节，
就能把所有的 $a_i$ 分成组了。然后……就到了最开心的 $\texttt{dp}$ 环节啦！
`dp[i][j][k] := 余数小于等于 i，选了 j 个（注意始终 j<=9），一共的和是 k 的方案数。`
于是刷表，枚举下一个余数要几次就行了。

注意每次选余数的时候可能会有很多 $a_i$，所以问题变成了：

有 $x$ 个数，里面选 $y$ 个，可以不选，求方案数。

这不就很明显的插板吗？每边多放一个，答案为 $C^{x+y-1}_y$，所以转移式子出来了：

`dp[i+1][j1+j][k+j1*(i+1)%p] += dp[i][j][k] * C(cnt[i+1]+j1-1, j1)`，注意别忘取模。

代码有点丑，将就着看下吧。因为有可能有 $0$ 个选 $0$ 个的情况等，所以不能预处理所有的阶乘逆元，但每次暴力算的复杂度足够了。

[Code Link](/paste/1kj62kh4)