其实感觉这题正解不太算数位 dp（从UltiMadow 的题单来到这里qaq）...毕竟没有经典的按数位统计答案的部分，甚至也和数位搭不上边。不过如果考虑部分分的话还是有数位 dp 成分的X

## 解析

如果 $n$ 较小，其实有一种很简单数位 dp 思路：设 $dp(i, k, r)$ 为放到第 $i$ 为，该位为 $k$，已放的数位带权（数位权，例如从低到高第 $1$ 位带权 $10^0$）和模 $p$ 的余数；再预处理下数位权模 $p$ 的值（因为是会循环的），就可以做到 $O(1)$ 转移；总复杂度 $O(n)$

然而 $n\leq 10^{18}$，显然不能这样做

&nbsp;

首先要想出一个对这题很重要的推论（这个方向想对了这题就做出一半了）

先设 $f(x)=\sum\limits_{i=0}^{x-1}10^i$。$f(x)$ 的值实际上就是一个长度为 $x$，各数位都是 $1$ 的数字

考虑这样一个数字：它由 $f(n)$ 和不超过八个的 $f(x), 0\leq x\leq n$ 相加而得

很显然不超过八个是为了避免进位。只要 yy 一下就可以发现这样的数字是一定符合题目要求的（证明应该可以考虑归纳X）

接着我们又有一个很显然的递推式：$f(x)=10\cdot f(x-1)+1$（思考下 $f(x)$ 的定义很快就能推出来了）

由于我们只关心最后的和能否被 $p$ 整除，于是相加的每个 $f(x)$ 在相加前都可以先模 $p$，刚才那个递推式也可以在**模意义下**进行；而该递推式的后一项只取决于前一项，于是一旦它在某一刻取值重复，接下来的取值就会陷入**循环**。显然最多在递推 $p$ 次后它一定就会取值重复

这样我们就可以暴力模拟地找循环节。找到循环节后，我们就能预处理出模 $p$ 为 $r, 0\leq r < p$ 的 $f(x)$ 的数量

这样，题目就被转化为：从值为 $[0, p-1]$ 的一些元素中取 $9$ 个元素，有一个指定的元素必须取（$f(n)$），且要求取的元素的值的和模 $p$ 为 $0$，问有多少种方案

&nbsp;

接下来再考虑如何解决转化后的问题

其中指定取的元素其实是不用管的；我们只需知道该元素的值 $r$，并将要求的方案的条件变为 “和模 $p$ 为 $p-r$” 即可

首先可以类推背包想到一种 dp 的思路：设 $dp(k, r)$ 表示已经选了 $k$ 个元素，其和为 $r$ 的方案数。但在考虑转移时，由于我们并不清楚某一状态里究竟选了哪些 $f(x)$，因此没法计算出转移后的方案

一种例子是：$dp(k, 2r\mod p)$ 的方案包含两种方案 $\{f(a), f(b)\}, \{f(a), f(a)\}$，其中 $f(a)=f(b)=r\pmod p$，当我们转移至 $dp(k+1, 3r\mod p)$ 时，再往第一种方案加入一个 $f(a)$ 和再往第二种方案加入一个 $f(b)$ 得出的方案实际上是一样的，而我们在只记录方案数的情况下不可能得知这点

于是我们还需再加一维限制选取的元素集合。设 $dp(k, r, m)$ 表示已经选了 $k$ 个元素，其和为 $r$，选的元素的**种类编号**在 $[1, m]$ 范围内的方案数。这里的种类编号是对每模 $p$ 的余数 $r$ 相同的一组 “发放” 一个（因为在转移时我们只关心加入的元素对和的影响），顺序随意，从 $1$ 开始编号

这样我们的转移方程就为 $dp(k, r, m)=\sum\limits_{k'=0}^k\binom{cnt(m)+(k-k')-1}{cnt(m)-1}\cdot dp(k', (r-val(m)+p)\mod p, m-1)$

其中 $cnt(m)$ 指编号为 $m$ 的元素的个数，$val(m)$ 指编号为 $m$ 的元素模 $p$ 的值（在定义编号时，我们已经要求模 $p$ 的值相同的元素才能分到一种编号）

其中 $\binom{cnt(m)+(k-k')-1}{cnt(m)-1}$ 的组合意义为：从 $cnt(m)$ 种每种无穷多的元素中选 $(k-k')$ 个，问不同的选取方案数。证明可以考虑隔板法：我们有 $(cnt(m)+(k-k')-1)$ 个小球，用 $cnt(m)-1$ 个隔板成非空的 $cnt(m)$ 段，第 $i$ 段的个数 $x$ 即代表第 $i$ 种小球选了 $x-1$ 个

## CODE

注意在初始化时只需设 `dp[0][0][0] =1`

我在一开始还另外将最后一维（$m$）为每种可能的编号取值的 `dp` 数组都设为了 `1`，就像这样：

```cpp
for(int m =0; m <= tot; ++m)/*tot 就是编号总数*/
	dp[0][0][m] =1;
```

然而对于 `dp[0][0][m]`，$m\in[1, tot]$ 的这些状态，它们在 dp 时实际上又会被 `dp[0][0][0]` 再转移一次，导致贡献重复

当然也不能设 $m$ 这维表示 “...且每种至少一个”，那样的话答案就错了（可能有方案没选到某种标号）。这里主要的错误还是**初始化了在 dp 过程中会被递推出的方案**（且像这道题，递推时不是覆盖而是**相加**）

```cpp
#include <cstdio>
#define ll long long

const int M =999911659;

/*------------------------------Val------------------------------*/

ll n, p;
int val[501], tot;
ll cnt[501];/*模 p 为 r 的 f(x) 有多少*/

/*------------------------------C------------------------------*/

int inv[9];
int c_[501][9];

void pre(){
	inv[1] =1;
	for(int i =2; i <= 8; ++i)
		inv[i] =1ll*(M-M/i)*inv[M%i]%M;
	for(int m =1; m <= tot; ++m){
		c_[m][0] =1;
		for(int k =1; k <= 8; ++k){
			int tmp =1;
			for(int i =0; i < k; ++i)
				tmp =1ll*tmp*(cnt[m]%M+k-1-i)%M;
			for(int i =1; i <= k; ++i)
				tmp =1ll*tmp*inv[i]%M;
			c_[m][k] =tmp;
		}
	}
}

/*这里为了调用方便，m, k 不是原来的含义。原来的含义见下行*/
/*C(cnt[m]+k-1, k)*/
inline int C_(int m, int k){
	return c_[m][k];
}

/*------------------------------Main------------------------------*/

bool vis[500];
int pos[500];

/*已选 k 个 f(x)，它们的和模 p 为 r，当前选了标号为 [1, m] 的 f(x)，的方案*/
int dp[9][500][501];

int main(){
	scanf("%lld%lld", &n, &p);
	int rep =0, ii =1;
	for(int nw =1%p /*p == 1*/; !vis[nw] && ii <= n; nw =(nw*10+1)%p, ++ii, rep =nw){
		vis[nw] =1;
		pos[nw] =ii;
		val[++tot] =nw;
	}
	/*循环节小于 n 时，这一段算出来也是对的 ( 这时算法就相当于认为等于 n 了 X )*/
	int res =0;/*"1...1" ( n 个 1 ) 模 p 是多少，最后统计答案需要它 ( 因为这个串要强制选 )*/
	if(ii > n){
		for(int i =1; i <= n; ++i)
			cnt[i] =1;
		res =val[tot];
	}
	else{
		res =val[tot];
		rep =pos[rep];
		for(int i =1; i <= rep-1; ++i)
			cnt[i] =1;
		for(int i =rep; i <= tot; ++i)
			cnt[i] =(n-(rep-1))/(tot-rep+1);
		for(int i =rep; i <= (n-(rep-1))%(tot-rep+1); ++i)
			++cnt[i], res =val[i];
	}
	
	pre();
//	for(int m =0; m <= tot; ++m)
//		dp[0][0][m] =1;
	dp[0][0][0] =1;
	/*为了方便，这里的转移是倒着写的X*/
	for(int k =0; k <= 8; ++k)
		for(int m =0; m < tot; ++m)
			for(int r =0; r < p; ++r)
				for(int knet =k; knet <= 8; ++knet)
					(dp[knet][(r+val[m+1]*(knet-k))%p][m+1] +=1ll*C_(m+1, knet-k)*dp[k][r][m]%M) %=M;
	
	int ans =0;
	for(int i =0; i <= 8; ++i)
		(ans +=dp[i][(0-res+p)%p][tot]) %=M;
	printf("%d", ans);
}
```