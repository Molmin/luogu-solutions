## [洛谷传送门](https://www.luogu.com.cn/problem/P3385)
## 题意
有 $T$ 张有向图，问每张图中有没有负环。
## 思路
判定每一张图中有没有负环，可以使用 SPFA 算法进行求解。
## SPFA 算法
在任意图的**单源**最短路径问题中，边权**可以为负**。

此时状态不像正权图中一样，不再有可用的拓扑序，只能进行**搜索**。

但依然可以使用**最优性剪枝**。

### SPFA 算法：宽搜求每个点的最短路径长度
它是基于 Bellman-Ford 算法的一种优化。

优化了两点：

- 最优性剪枝：每个点只记录当前最短的路径长度。
- 入队优化：点的最短路径长度被更新时，如果该点还在队列中，则不重复入队。

### SPFA 算法实现思路
$1.$ 初始化所有点，起点入队。

$2.$ 按顺序处理队列中的每个点。

$2. 1.$ 标记当前点出队。

$2. 2.$ 枚举邻点，找到能够更新距离的点。

$2.2.1.$ 记录更新的距离。

$2.2.2.$ 如果邻点不在队中，则入队并标记。
### SPFA 算法示例

我们考虑这样的一张图，以 $1$ 为起点。

![](https://cdn.luogu.com.cn/upload/image_hosting/xlf6ysc7.png)

SPFA 算法流程如下：

1. 初始状态 $[1, 0]$ ，入队。
2. 处理状态 $[1, 0]$。 
3. 得到状态 $[2, 24]$，更新点 $2$，入队。
4. 得到状态 $[3, 8]$，更新点 $3$，入队。
5. 得到状态 $[4, 15]$，更新点 $4$，入队。
6. 处理状态 $[2, 24]$。
7. 得到状态 $[5, 30]$，更新点 $5$，入队。
8. 处理状态 $[3, 8]$。
9. 得到状态 $[5, 15]$，更新点 $5$，已在队中，不入队。
10. 得到状态 $[6, 11]$，更新点 $6$，入队。
11. 处理状态 $[4, 15]$。
12. 得到状态 $[7, 19]$，更新点 $7$，入队。
13. 处理状态 $[5, 15]$。
14. 得到状态 $[7, 24]$，没有更新点 $7$，舍弃。
15. 处理状态 $[6, 11]$。
16. 得到状态 $[4, 16]$，没有更新点 $4$，舍弃。
17. 得到状态 $[5, 13]$，更新点 $5$，入队。
18. 得到状态 $[7, 14]$，更新点 $7$，已在队中，不入队。
19. 处理状态 $[7, 14]$。
20. 得到状态 $[2, 17]$，更新点 $2$，入队。
21. 处理状态 $[5, 13]$。
22. 得到状态 $[7, 22]$，没有更新点 $7$，舍弃。
23. 处理状态 $[2, 17]$。
24. 得到状态 $[5, 23]$，没有更新点 $5$，舍弃。
25. 所有状态处理完毕，最终结果如下。

![](https://cdn.luogu.com.cn/upload/image_hosting/v09hs8gl.png)

### 复杂度分析
令点数为 $n$，边数为 $m$。

每个点最多入队 $O(n)$ 次，对于**随机图**，**期望**入队次数 $O(1)$。
#### 时间复杂度
遍历图一次 $O(n + m)$。

总时间复杂度为 $O((n + m)n)$，**期望**时间复杂度 $O(n + m)$。
#### 空间复杂度
队列中点数 $O(n)$。

存储图 $O(n + m)$。

总空间复杂度为 $O(n + m)$。
### SPFA 算法判定负环
SPFA 算法可以判断是否存在负环。

令图中点数为 $n$，如果没有负环，任意点的最短路径边数最多为 $n - 1$。

点是**按顺序**处理的，一个点在两次入队之间，**至少**有一个新点求出了最短距离。

所以，如果有点入队次数达到 $n$，必然存在负环。
## code
~~~cpp
#include <iostream>
#include <queue>
#include <vector>

using namespace std;
using PII = pair<int, int>;

const int kMaxN = 2e3 + 1, kInf = ~(1 << 31);

struct Edge {     // 点
  vector<PII> e;  // 边，记录指向节点和长度
  int d = kInf;   // 距离
  int vis;        // 入队次数
  bool b;         // 在队列中的标记
} edge[kMaxN];
queue<int> q;
int t, n, m;

bool Record(int x, int d) {  // 处理x点距离d的新状态
  if (d < edge[x].d) {       // 是更优状态
    edge[x].d = d;           // 记录
    if (!edge[x].b) {        // 点不在队中
      edge[x].b = 1;         // 标记入队
      edge[x].vis++;         // 入队次数增加
      q.push(x);             // 入队
    }
  }
  return edge[x].vis >= n;  // 判定负环
}

bool SPFA() {                                // SPFA求最短路&判定负环
  for (Record(1, 0); !q.empty(); q.pop()) {  // 记录起始状态，依次处理每个状态
    int x = q.front();
    edge[x].b = 0;                                  // 标记出队
    for (PII e : edge[x].e) {                       // 遍历邻边
      if (Record(e.first, edge[x].d + e.second)) {  // 处理新状态&判定负环
        return 1;                                   // 是负环，返回
      }
    }
  }
  return 0;  //求完所有点最短路后仍然没有出现负环
}

void Make() {  // 多测清空
  vector<PII> f;
  fill(&edge[0], &edge[kMaxN], (Edge){f, kInf, 0, 0});
  while (!q.empty()) {
    q.pop();
  }
}

int main() {
  cin >> t;
  while (t--) {
    Make();
    cin >> n >> m;
    for (int i = 1, u, v, w; i <= m; i++) {  //建边
      cin >> u >> v >> w;
      edge[u].e.push_back({v, w});
      if (w >= 0) {
        edge[v].e.push_back({u, w});
      }
    }
    cout << (SPFA() ? "YES" : "NO") << endl;
  }
  return 0;
}
~~~
### 注意：部分代码为 C++ 17 的语法，使用 C++ 11 或 C++ 14 等评测可能会编译错误