# 前言

本题解秉承一步一步走的观念，将先从模拟样例出发，根据样例的模拟得到此题的一种使用MST的解法，然后逐步修正细节得到正解，尽量能让思考过程变得自然一些。

# 样例模拟

这道题如果每次单独询问每个容器，不用动脑子就可以知道每个容器内的状态（滑稽）。但是这个题目设计的询问开销中单个容器询问开销有的很高，不划算，反而是通过一个大区间和一个小区间询问来推断单点询问更省资源。并且不难发现，至少需要$n$次才能知道$n$ 个容器的情况（可以理解成$n$个方程解出$n$个未知数）。

但是刚读完题，我还不太清楚该怎么询问才好，所以先看一下样例，看看能不能有什么发现。

```cpp
5
1 2 3 4 5
4 3 2 1
3 4 5
2 1
5
```

初始化总消耗$sum=0$ 。单点访问$1$号消耗很少，$sum=1$ ;单点访问$2$号要消耗$4$，太贵了，不过考虑访问$1-2$，只消耗$2$，$sum=3$，这样也能知道$2$有没有；单点访问$3$号，要消耗$3$，但是那个矩阵里面还有更小的数呢，感觉能更少，所以先不管；单点访问$4$，还行，消耗$2$，$sum=5$ ；单点访问$5$太贵，但是访问$4-5$很便宜，$sum=6$ ；考虑区间$2-5$，因为$2$和$4-5$都确定了，所以只要知道$2-4$的奇偶性，就能知道$3$是什么状态了，消耗$1$，$sum=7$ ，所以样例结果是$7$。

# 样例的启示

刚才整个模拟样例的过程有点贪心的意思：只要矩阵里面有更小的数，那么我可能就要优先考虑是不是可以通过访问相应的那个区间以减少损耗。当然，如果那个区间里面的元素已经确定了，那么我们就不用去选那个了。

根据上面的分析，您可能也想到了：$kruskal$ 算法和这个差不多，都是优先选小的，都是不能有一些“冗余”的选择。所以，这个问题很可能是最小生成树问题。

# 思路建立与修改完善

下面想怎么建图。最朴素的想法肯定是直接把矩阵里的数变成边，比如**对于区间**$[i,j]$**的询问消耗为**$k$，**就给**$i,j$**结点连一条长度是**$k$**的边**，这样就有$n$个自环，不是简单图，求MST的话，肯定不会有自环，然而自环代表单点询问，根据样例可以知道，单点询问是可能作为最优决策的一部分的，所以这种建图方式不可取。并且， MST只有$n-1$条边，求不出$n$个点的信息。

要想有$n$ 条边，必须是对$n+1$个结点建立图，也就是说我们可能需要建立一个辅助结点来做一些事情。辅助结点需要做的第一件事就是把自环处理掉，而怎么处理掉自环呢？我最开始考虑的是加入一个$0$ 号结点，并且定义第$i$个结点和$0$ 号结点连接的边代表**单点查询**$i$ **的消耗**，而其他边照常连。这样的话，这个$n+1$个结点的图至少就没有环了。然而这会带来一个问题：$n+1$个结点的最小生成树必然会有$0$ 和其他节点直接相连的情况，也就是说这样求出的MST一定包含单点查询的情况，但是我们的最优查询方案中可能一个单点查询都没有，所以这样也是不对的。

上面的建图仍然出现问题的原因是标准不统一，即有些边代表区间查询，而有些起点终点编号不连续的边却代表单点查询（比如0号和2号连边在上面居然定义成了查询单点2号点）。我们最开始分析过的，两个区间查询能够推出一个更小的区间甚至单点的情况，即两个区间的查询结果“作差”。如果做过一些数论和数据结构的题，大家可能能想到出现奇偶性的题目就可能考虑异或运算（感觉是套路），而异或运算是很有趣的，有前缀和的一些性质（其他题解提到了），这意味着可以用前缀和搞事情根据这个思想，我们考虑根据前缀和去建图，**定义**$i,j$**结点连接一条边的意思是区间查询**$[i+1,j]$**区间所需要消耗的资源**，那么0号和$i$连接是就是$[1,i]$区间查询的消耗了，单点查询的消耗也容易表示了，比如对于$3$号结点的单点查询的消耗就是连接$2$和$3$号结点。这样看来，自环问题解决了，加入的$0$号结点也没有影响结果，直接在这个上面求MST就能得出答案。

因为这个是稠密图，所以要用朴素的prim算法（虽然我们是根据$kruskal$的算法过程发现的这个题考察的是MST）。

# 代码实现

代码异常地简洁，注意建图别建错了，以及$prim$循环次数要写对（n+1个点的MST）。

```cpp
#include <bits/stdc++.h>
#define ll long long
#define INF 9999999999999
using namespace std;
const int N=2e3+9;
const int M=N*(N-1);
typedef struct{
	ll to,nxt,weight;
}Edge;
Edge edge[M];
ll head[N],cnt,n,dist[N],ans;
bool intree[N];
void prim();
void add(ll x,ll y,ll z);
int main(){
	ll w;
	scanf("%lld",&n);
	for(int i=0;i<=n;i++){
		head[i]=-1;
	}
	for(int i=1;i<=n;i++){
		for(int j=i;j<=n;j++){
			scanf("%lld",&w);
			add(i-1,j,w);
			add(j,i-1,w);
		}
	}
	prim();
	printf("%lld\n",ans);
	return 0;
}
inline void prim(){
	ll minlen,minpos;
	for(int i=0;i<=n;i++){
		dist[i]=INF;
	}
	dist[0]=0;
	for(int j=0;j<=n;j++){ //对n+1个结点进行kruskal
		minlen=INF;
		for(int i=0;i<=n;i++){
			if(minlen>dist[i] && !intree[i]){
				minlen=dist[i];
				minpos=i;
			}
		}
		intree[minpos]=true;
		ans+=dist[minpos]; 
		for(ll i=head[minpos];i>=0;i=edge[i].nxt){
			if(!intree[edge[i].to])
				dist[edge[i].to]=min(dist[edge[i].to],edge[i].weight);
		}
	}
}
inline void add(ll x,ll y,ll z){
	edge[cnt].to=y;
	edge[cnt].weight=z;
	edge[cnt].nxt=head[x];
	head[x]=cnt++;
}
```

