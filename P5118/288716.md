## DFS+模拟，给大家一个暴力的做法

### 题意：


两个挤奶棚里分别有$10$个奶桶、$1000$加仑的奶，给出各自的容积。

星期一挤奶棚一装满一个奶桶送往挤奶棚二；

星期二挤奶棚二装满一个奶桶送往挤奶棚一（可以是星期一运送过来的奶桶）

……

问星期五的时候挤奶棚一中的奶量有几种可能性。

---
这道题目里基本上都是小常数，$10$个奶桶、星期五……所以直接$DFS$。

### 如何搜索

要搜索相信大家都知道，但是如何进行DFS呢？

我们不要用$DFS$枚举奶量，因为这样$DFS$会写的很复杂且不好调试，所以我们在$DFS$的时候，只枚举序号就好了。

什么意思呢？

就是说，我们把每个桶都编一个号,然后枚举每一种编号的排列组合就好。如1—— 1—— 1—— 1——1。

### 如何模拟

在$DFS$的时候，我们为了简便，只枚举了序号，那么怎么模拟呢？一般我们都会循环五次求奶量，但是我这里是直接不用循环地模拟出每一天（很麻烦，但是很容易写）。

### 代码实现

对于这种暴力题目，我们还是结合代码一起来理解吧：
```
#include <bits/stdc++.h>
using namespace std;
int aa[10],bb[11],s[6],ans;
bool k[10000];
void moni()//模拟部分
{
  int a[10],b[11];
  for(int i=0; i<10; i++)
    a[i]=aa[i],b[i]=bb[i];//转移到另一个数组来操作
  //暴力模拟部分
  b[10]=a[s[1]];
  a[s[1]]=0;
  a[s[1]]=b[s[2]];
  b[s[2]]=0;
  b[s[2]]=a[s[3]];
  a[s[3]]=0;
  a[s[3]]=b[s[4]];
  b[s[4]]=0;
 if(!k[a[0]+a[1]+a[2]+a[3]+a[4]+a[5]+a[6]+a[7]+a[8]+a[9]])       
//判断这种奶量是否出现 
ans++,k[a[0]+a[1]+a[2]+a[3]+a[4]+a[5]+a[6]+a[7]+a[8]+a[9]]=1;
}
void dfs(int n)
{
  if(n==5)//若星期五枚举完毕
    moni();
  else
    for(int i=0; i<11; i++)
    {
      if(n%2==1&&i==10)
      //这是一个小细节
      //对于挤奶棚1来说，是不可能有第11个奶罐的
        break; 
      s[n]=i;
      dfs(n+1);//搜索
    }
}
int main()
{
  for(int i=0; i<10; i++) 
    cin>>aa[i];
  for(int i=0; i<10; i++) 
    cin>>bb[i];//读入
  dfs(1);
  cout<<ans;//输出
  return 0;
}

```

**建议**：

如果你对于$DFS$还没有到达滚瓜烂熟的地步（比如我），那么，枚举的事情尽量简单，因为$DFS$非常难调试。

### 祝大家AC愉快~
