[原题传送门](https://www.luogu.com.cn/problem/CF1090M)

先来看看题目：

- 有一长度为 $n$ 的数列 $a_{1},a_{2},a_{3},...,a_{n}$，其中每个数的值都小于等于 $k$。

- 现给定 $n$，$k$ 和这个数列，求其中最长连续的一段区间的长度，使区间中任意相邻两数不同。

- 数据范围：$1≤n,k≤100000$。

这题可以用动态规划去做。

设 $f(i)$ 为是以 $a_{i}$ 为结尾的最长区间长度，则易推出转移方程：

- 若 $a_{i}=a_{i-1}$，则 $f(i)=1$；

- 否则 $f(i)=f(i-1)+1$。

而答案即等于 $\max(f(1),f(2),f(3),...,f(n))$。

**综上，便可以写出代码：**

```cpp
#include<iostream>
using namespace std;
int n,k,a[100001],f[100001],ans; 
int main(){
	cin>>n>>k;
	for(int i=1;i<=n;i++){
		cin>>a[i];
		f[i]=1;                          //见下文 
	}
	for(int i=1;i<=n;i++){
		if(a[i]!=a[i-1])f[i]=f[i-1]+1;   //f[i-1]最少是1，所以f[i-1]+1肯定比f[i]的初始值1大 
		ans=max(ans,f[i]);              
	}
	cout<<ans;
	return 0;
}
```

### **Q&A**

Q：```f[i]=1```是什么意思？有什么作用？

A：这一句看似仅将 $f$ 数组初始化为1，实际上还是转移方程的第一条。如果没有这一句，下面的```if```语句本来应该是：

```cpp
if(a[i]!=a[i-1]){
	f[i]=f[i-1]+1;
}else{
	f[i]=1;
}
```

加上这条语句后便可省略```else```语句。