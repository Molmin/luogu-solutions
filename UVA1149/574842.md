可以感觉到此题为裸的**贪心**，
并且本题标签为贪心，考虑贪心。

------------

首先翻译题目(输入输出格式一定要注意）：
1. 有 $n$ 个物品，将物品放入包裹中，一个包裹中只能放 $2$ 个物品，每个包裹最多只能放 $w$的重量。
1. 输入一个 $y$ 代表多组数据。
1. 输入 $n$ 和 $w$ , 是需要装入箱子中的个数。
1. 接下来输入 $n$ 行 $v$ ,代表每个物品的重量。


------------

每组数据处理的大致思路如下：
1. 将物品按大小从小到大排序。
1. 尝试第一个和最后一个物品是否能放到同一个包裹中。
1. 如果最后一个物品过大，就把最后一个物品单独放。
1. 重复执行直到处理完全部物品。


------------
实现思路：考虑双指针算法，一个从队头向后移动，一个从队尾向前移动，
前提是队列为单调的，可以实现贪心。
对此有两个题目的思路类似:
1. [P1650](https://www.luogu.com.cn/problem/P1650)
1. [P3918](https://www.luogu.com.cn/problem/P3918)

### ACcode

```cpp
#include<bits/stdc++.h>
using namespace std;

int main(){
	int t, w, n, ans;
	int i, j;							//此处 i, j 为两个指针 
    int a[100005];
    scanf("%d", &t);					//读入测试数据组数
  
    for(int k = 0; k < t; k ++){		//多组数据的读入方式
        scanf("%d%d", &n, &w);
        for(i = 0; i < n; i ++)
            scanf("%d", &a[i]);
            
  		sort(a, a + n);					//排序函数，不会可以自学 
        ans = i = 0; 
        j=n - 1;						//排序及初始化
  										
        while(i <= j){					//循环条件为两个指针不相遇 
            while(a[j] + a[i] > w && i <= j){
                ans ++; j --;   		//两个放不下就单独放
            }							//j 指针左移 
            i ++; j --; ans ++;			//i 右移，j 左移 
        }	
        								//贪心过程
        printf("%d\n", ans);
        if(k != t - 1)
            printf("\n");  				//调整输出格式
    }									//对于 UVA 的题，格式比较重要 
	return 0;
}
```
希望能过呢，卖萌！