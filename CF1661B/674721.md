### 题意
给定 $n$ 个数，对于一个数 $v$，你有两种操作使它变为 $0$：

- $v \gets (v+1)\bmod 32768$
- $v \gets (2 \times v)\bmod 32768$

输出每一个数变为 $0$ 的最小操作数。
### 分析
~~显而易见，~~ $32768$ 是 $2^{15}$。所以，这道题我们可以从因子 $2$ 的数量来考虑。由于 $2^{15}|v$ 是 $v \equiv 0\pmod{32768}$ 的充分必要条件，所以这道题就变成了用两种操作使一个数的因子 $2$ 的数量达到 $15$ 个。

先考虑操作 $2$，显而易见，使用一次就可以增加一个因数 $2$。所以不论什么数字，它的最小操作数一定小于等于 $15$。

再考虑操作 $1$，只有当用操作 $1$ 可以更快的增长 $v$ 的因子 $2$ 的数量时才会用它，那么考虑打表。预处理出每一个小于 $32768$ 的数的因子 $2$ 的数量，然后相对于 $v$ 将增加的因子 $2$ 的数量与只用操作二达到此数量的次数进行比较。如果操作 $1$ 的操作次数更少，那么使用操作 $1$。

由于最小操作数不大于 $15$，所以枚举操作 $1$ 时只用枚举 $15$ 次即可。

码量不大，而且时间复杂度约为 $O(n)$，可以通过。
### 代码
```cpp
#include <iostream>
#include <cmath>
using namespace std;
const int mod=32768;
int a[mod+20];
void ready(){
	a[0]=15;
	for (int i=1;i<mod+20;++i)
		a[i]=log2(i&(-i));//用于计算a[i]含有因子2的数量
	return;
}
int main(){
	ready();
	int t,n;scanf("%d",&t);
	while (t--){
		scanf("%d",&n);n%=mod;//记得取模，WA了四发
		int f1=0,f2=0;
		for (int i=1;i<=15;++i)//枚举操作1的次数
			if (a[i+n]-i>a[f1+n]-f1) f1=i;
		f2=15-a[n+f1];//还差的因子2的数量用操作2补齐
		printf("%d ",f1+f2);//不是换行
	}
	putchar('\n');
	return 0;
} 
```