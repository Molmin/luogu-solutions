**题目大意**：给定一个长度为 $2n$ 的排序，判断这个排序是否可以由两个长度为 $n$ 的序列通过 $merge$ 操作结合而来。 $merge$ 就是归并排序中的 $merge$ 。

想要解决这一道题，暴力枚举肯定是不可以的，需要首先分析一下 题目。

假设有一个排序为 $3,2,6,1,5,7,8,4$ ，那么可以发现一些结论：

1.  $3$ 和 $2$ 在同一个序列中。否则， $2$ 一定在 $3$ 的前面，通过 $merge$ 操作不可能形成上述排列。

2.  $6$ 和 $1$ 和 $5$ 在一个序列中，否则， $1$ 和 $5$ 一定在 $6$ 的前面，通过 $merge$ 操作不可能形成上述排列。

3.  $8$ 和 $4$ 在一个序列中，否则， $4$ 一定在 $8$ 的前面，通过 $merge$ 操作不可能形成上述排列。

之后，就可以发现一个结论：**从数 $a$ 到下一个比 $a$ 大的数之前的数之前的数，和 $a$ 都在同一个序列中。**

所以，根据这个结论，上一个排序就可以分成4组： $（3,2）,（6,1,5）,（7）,（8,4）$ 。每一组的数量分别是 $2，3，1，2$。

此时，因为 $2+2=1+3=8\div2$ ，所以可以拆成两个序列。

而排序 $6，1，3，7，4，5，8，2$ ，可以分成3组： $（6，1，3），（7，4，5），（8， 2）$ ，每一组的数量分别是 $3，3，2$ 。

因为 $3，3，2$ 不能组成 $4$ ，所以这个排序不能拆成两组。

到这里，又可以发现一个结论：**如果一个排序可以拆成两个序列，那么将这个排序分组之后每一组的数量可以组成等于原序列长度一半的数。**

而判断能否组成一个数，可以使用动态规划（dp）。

  $a_i$ 表示原排序拆成几段之后第i段的长度， $d_j$ 表示这些数能不能组成j，能则 $d_j=1$ ，否则 $d_j=0$ 。
 
**状态转移方程**：$d_j|=d_{j-a_i}$ （竖线是异或）。

 解释：如果能组成 $d_{j-a_i}$ 或能组成 $d_j$ ，那么就可以组成 $d_j$ 。
 
 初始化： $d_0=1$ 。
 
 最后，只需要判断 $d_n$ 是否等于 $1$ 即可。如果 $d_n=1$，那么就可以拆成两个序列，否则不能拆成两个序列。
 
**代码：**
```cpp
#include<cstdio>
#include<cstring>
#include<iostream>
const int N=2000;
int a[N*2+1],d[N+1],p[N*2+1];//注意a和p数组大小为2n
int main()
{
	register int i,j,k,l,n,t;
	scanf("%d",&t);
	while(t)
	{
		scanf("%d",&n);
		for(i=1; i<=n*2; ++i)
			scanf("%d",&p[i]);
		//分组
		j=p[1];
		//j记录当前组中第一个数（最大的数）
		//如果有一个数比j大，那么那个数就是下一组的第一个数
		k=1;//k记录当前组中有多少数
		l=0;//l表示组数
		//第一个数一定在第一组
		for(i=2; i<=n*2; ++i)
		{
			if(j<p[i])//如果有一个数比j大，那么那个数就是下一组的第一个数
			{
				a[++l]=k;//记录上一个组的数量
				//更新j和k
				j=p[i];
				k=0;
			}
			++k;//当前组中数的数量加一
		}
		a[++l]=k;//将最后一组放进去
		memset(d,0,sizeof(d));//注意清空
		d[0]=1;//初始化
		for(i=1; i<=l; ++i)
			for(j=n; j>=a[i]; --j)
				d[j]|=d[j-a[i]];//dp
		if(d[n])//判断是否组成
			puts("YES");
		else
			puts("NO");
		--t;
	}
	return 0;
}
```