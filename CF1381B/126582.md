我好像和你们不太一样，我的思路是问题转化 + 简单 $01$ 背包。

先看最后一组样例：
```
6
4 3 2 5 1 11 9 12 8 6 10 7
```
可以发现 $12$ 在中间，所以 $12$ 和其后的数在同一个数组中，否则 $12$ 会先把它们挤出来。去掉这部分，再看看。
```
4 3 2 5 1 11 9 
```
这是我们发现 $11$ 及其后的数字在同一组中，理由一样，再去掉它们。
```
4 3 2 5 1
```
去掉 $5$ 及其后的数字。
```
4 3 2
```
剩下的三个数必定在一个数组中。

这样，我们把这组数分成了几块：
```
4 3 2 / 5 1 / 11 9 / 12 8 6 10 7
```
不难看出，无论我把这些块如何放到两个数组中，只要两个数组中的块是按顺序的，就一定会按样例的顺序排出，因为后一个块中的第一个数就比前一个块中的所有数都大。例如：
$$a = \{4, 3, 2, 11, 9\}, b = \{5, 1, 12, 8, 6, 10, 7\}$$
$$a = \{4, 3, 2, 5, 1, 11, 9\}, b = \{12, 8, 6, 10, 7\}$$
都是可行的方案。

那么我们需要解决的问题就是能否用这些块拼成一个长度为 $n$ 的数组，问题就被我们转换成了一个简单的 $01$ 背包，直接动态规划解决即可。

时间复杂度 $O(n ^ 2)$，可以通过。
```cpp
int tc;

int n, p[N << 1];
int tot, sz[N << 1];
bool vis[N << 1];

bool f[N];

int main() {
    
    tc = read(), f[0] = true;
    
    while (tc--) {
        n = read() << 1;
        Rep(i, 1, n) p[i] = read();
        int now = n, lst = n;
        Dep(i, n, 1) {
            vis[p[i]] = true;
            if (p[i] == now) {
                while (now && vis[now]) --now;
                sz[++tot] = lst - i + 1, lst = i - 1;
            }
        }
        Rep(i, 1, tot) {
        	Dep(j, n >> 1, sz[i]) f[j] |= f[j - sz[i]];
		}
        puts(f[n >> 1] ? "YES" : "NO");
        tot = 0;
        Rep(i, 1, n) f[i] = false, vis[i] = false;
    }
    
    return 0;
}
```