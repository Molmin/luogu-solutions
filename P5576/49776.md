感觉很多字符串问题转化完就变 DS 题了

先特判掉 $l = r$ 的情况，然后我们考虑把所有串拼在一起，中间加上彼此不同的分割符，然后对整个串建 SAM

然后我们可以转化一下问题，给串 $i$ 对应的所有终止节点染上颜色 $i$，这样问题转化为：

给定一颗有根树，每个节点有颜色和权值，$q$ 次询问，给出 $l,r$，让你找一个权值最大的节点，满足其子树内包含 $[l,r]$ 这些颜色

考虑扫描 $r$，动态维护所有节点的最小 $x$，满足其子树内包含 $[x,r]$ 的全部颜色

然后考虑加入 $r$ 的影响，可以发现，除了所有颜色为 $r$ 的节点到根的路径上节点的并以外，其他节点的 $x$ 都会变为 $r + 1$，其他不影响

然后我们考虑树剖一下，这样路径直接转化为区间，变为 $r+1$ 的就可以表示为若干个区间

这样问题又进一步转化为：

给定一个长度为 $n$ 的序列，每个位置有一个权值和一个时间，$n \log n$ 次把一个区间的时间修改为 $x$，$q$ 次查询时间 $\le l$ 的位置中，权值的最大值

看起来还是比较困难，但注意到全是区间推平，于是我们直接用颜色段均摊，显然一个同色段中只要保留权值最大的就可以了，然后我们再用一颗线段树去维护一下单点修改，区间 $\max$ 之类的，就做完了

时间复杂度是 $O(L \log^2 n + q \log n)$，$L$ 是字符串长度之和

写了份代码，但是因为滥用 STL 之类的被卡常了，就不放上来了（

总之就是说官方题解里的解法二可以做到 poly log