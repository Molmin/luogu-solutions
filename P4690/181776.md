调了三天的题，今天可算干出来了。

**树套树**，没错，就是树套树，在线做法，时间空间都过了。

~~虽然拿了一个你谷最劣解~~，但是这至少说明带毒瘤还没有太狠，不然给这题加强制在线了www。

附带本蒟蒻调题时拍到的曾经让我的代码卡 WA 的数据：[Link](https://www.luogu.com.cn/paste/oc4i9cyt)，希望对大家有帮助。

## 题意

[题目传送门](https://www.luogu.com.cn/problem/P4690)，大致题意如下：

> 维护一个序列：
>
> 1. 将区间 $[l,r]$ 染色。
> 2. 查寻区间 $[l,r]$ 有几种颜色。
>
> $n,m\leqslant 10^5$，空间限制 $\text{64MiB}$。

颜色编号不管多大，离散化即可，因此颜色数为 $n+m$ 级别。

## 分析

考虑这个问题的弱化版 [CF848C](https://www.luogu.com.cn/problem/CF848C)（可以转化为**类似**单点修改颜色，区间查询的问题）怎么做，设位置为 $i$ 的颜色上一次出现的位置为 $pre_i$，查寻时转化为查寻 $i\in[l,r],pre_i\in[0,l-1]$ 的 $i$ 的数量。将 $i,pre_i$ 看作横纵坐标，就可以转化为数点问题。于是可以：用 $n+m$ 个 `set` 分别维护每个颜色出现的位置，方便查寻前驱后继。单次修改时：

1. 这个位置原本的贡献，和它后继的贡献删除。

2. 更新它的后继的贡献。

3. 修改这个位置的颜色，更新新颜色带来的贡献和变化。

现在 **单点修改** 问题转化为了 **区间修改**。显然把 $i,pre_i$ 当成横纵坐标数点的思路仍然正确，考虑如何解决区间修改。发现本题的修改操作就是区间覆盖，可以用类似 ODT 的推平操作进行。

还是对于每个颜色维护一个 `set`，但是 `set` 内应该存区间，表示这一段区间内都是这个颜色，按左右端点排序无所谓，因为显然各个 `set` 的区间无交。单次修改时：

1. **细节**：左端点可能被一个区间完全包含，这时可以把这个区间裂成两个区间，右端点同理。使得要修改的范围内所有区间都严格被修改的范围 $[l,r]$ 包含。
2. 遍历 $[l,r]$ 内的每一个区间，对于任意一个区间，修改它的后继对这个区间造成的的贡献，删除本区间对 $pre$ 造成的贡献，然后把这个区间删除。
3. 把这个区间覆盖成新的颜色，更新新颜色带来的贡献和变化。

为什么这么做不会 T？考虑初始状态下有 $n$ 个区间，单次修改最坏产生三个区间（在一个区间内部覆盖），修改次数可以均摊地视为 $\operatorname{O}(n)$ 级别。

考虑查寻，发现一段区间内出了左端点其它所有点的 $pre_i=i-1$，因此只需要记录每个左端点产生的贡献。查询时，如果 $l$ 被一个区间包含，可以将 $l$ 直接拉到这个区间的左端点的位置再查寻，避免这个区间被查漏。

## 实现

根据上述分析本题的做法已经完形，剩下的就是如何实现，我见过的（不一定写过）的有以下几种：

1. 离线 cdq 查询。时间复杂度 $n\log n$，空间线性。可过。
2. 在线 KDTree 数点，时间复杂度 $n\sqrt{n}$，空间线性，不可过。参考我 [LOJ 上代码](https://loj.ac/s/1340282)。
3. 分块，时空复杂度 $n\sqrt n$，不可过。
4. 二维线段树等，时空复杂度 $n\log^2 n$，不可过。
5. 树套树，时间复杂度 $n\log^2n$，空间复杂度 $n\log n$，可过。

很多人认为树套树的空间复杂度是 $n\log^2 n$，事实上，考虑用树状数组套平衡树即可。因为树状数组的空间复杂度是单 $\log$，写平衡树的时候删除操作记个内存池回收即可。

本人用的树状数组套替罪羊，替罪羊树常数较小，推荐使用。

## 代码

本人代码较冗长，可以参考我在 [LOJ 上的提交记录](https://loj.ac/s/1340227)，这份代码在 luogu 已经同步 AC，空间基本压线。

