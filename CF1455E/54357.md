设移到最终正方形左上角的起始点为 $(x_0,y_0)$，右上角为 $(x_1,y_1)$，左下角为 $(x_2,y_2)$，右下角为 $(x_3,y_3)$。

因为读入的四个点和这四个起点对应关系不明确，但我们可以枚举这 $4!$ 种可能。

现在确定了对应关系后，可以把两个维度单独处理，他们之间唯一的联系是**正方形的边长**。

以横坐标为例，最终正方形的两个横坐标设为 $T_1,T_2$，那么很显然 $T_1$ 在 $x_0$ 和 $x_2$ 之间时移动距离最少，为 $|x_0-x_2|$。

如果不在 $x_0$ 和 $x_2$ 之间，每超过边界 $1$ 个单位距离，就会多移动两步。

同理，$T_2$ 在 $x_1$ 和 $x_3$ 之间是最优的。当同时满足在这两个范围内时，移动总步数为 $|x_0-x_2|+|x_1-x_3|$，此时正方形边长在一个区间 $[l_1,r_1]$ 内，可以算出来 $r_1=\max(x_1, x_3) - \min(x_0, x_2), l_1 = \min(x_1, x_3) - \max(x_0, x_2)$。

同样地考虑纵坐标，可以算出来边长在 $[l_2,r_2]$ 内可以达到最优。

若 $[l_1,r_1]$ 和 $[l_2,r_2]$ 有交集，那么最小步数就为 $|x_0-x_2|+|x_1-x_3|+|y_0-y_1|+|y_2-y_3|$，否则让其中一维迁就另外一维，也就是多出来 $2*(\max(l_1, l_2) - \min(r_1, r_2))$ 的步数。

代码如下：

```c++
int a[4], b[4], c[4];
int main() {
    int _;
    scanf("%d", &_);
    while (_--) {
        for (int i = 0; i < 4; i++) {
            scanf("%d%d", &a[i], &b[i]);
            c[i] = i;
        }
        LL ans = 1e18;
        while (1) {
            LL x0 = a[c[0]], y0 = b[c[0]];
            LL x1 = a[c[1]], y1 = b[c[1]];
            LL x2 = a[c[2]], y2 = b[c[2]];
            LL x3 = a[c[3]], y3 = b[c[3]];
            LL now = abs(x0 - x2) + abs(x1 - x3) + abs(y0 - y1) + abs(y2 - y3);
            LL r1 = max(x1, x3) - min(x0, x2), l1 = min(x1, x3) - max(x0, x2);
            LL r2 = max(y0, y1) - min(y2, y3), l2 = min(y0, y1) - max(y2, y3);
            now += 2 * max(0LL, max(l1, l2) - min(r1, r2));
            if (r1 >= 0 && r2 >= 0)
                ans = min(ans, now);
            if (next_permutation(c, c + 4) == 0) break;
        }
        cout << ans << endl;
    }
    return 0;
}
```

