~~没有dalao找规律啊,
这规律应该很明显吧~~

好吧,是因为我太弱了,连枚举搜索都不会打

观察一下样例

  1  2  3
  
  1  2  4
  
  1  2  5
  
  1  3  4
  
  1  3  5
  
  1  4  5
  
  2  3  4
  
  2  3  5
  
  2  4  5
  
  3  4  5
  
  
 ### 我们~~容易~~发现
  
 ### 每一次都是最后一位+1,然后倒数第k列不能超过n - k
 
### 如果超过了,那么k - 1列+ 1,k列 = k - 1列 + 1,(这个过程我们叫做进位吧).
### 不过这个规律只适用于进一位,观察一会后发现,在进位过程中如果进多位

### 则从k - (进的位数) 开始有a[i] = a[i - 1] + 1,如果第0列进位,那么所有情况已经写完

交代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[1001];
int main(int argc, char const *argv[])
{
	int n,m;
	cin>>n>>m;
	for (int i = 0; i <= n; ++i)//第一行永远是a[i] = i,a[0] 的话可以设也可以不设
	{
		a[i] = i;
		/* code */
	}
	while(a[0] == 0){//a[0] 如果进位了就结束
		for (int i = 1; i <= m; ++i)//打印
		{
			cout<<setw(3)<<a[i];//别忘了域宽,我被坑了2次
			/* code */
		}
		cout<<endl;
		a[m] ++;//开始进位
		if (a[m] > n)//这个if不要也行
		{
			int k = m;//k统计进到几位
			while(a[k] > n - (m - k)){//进位
				a[k - 1] ++;
				if (k - 1 == 0)//改变a[0]直接退出
				{
					return 0;
					/* code */
				}
				k --;
			}
			k ++;//每次都多－了一次,加上
			for (int i = k; i <= m; ++i)//进位
			{
				a[i] = a[i - 1] + 1;
				/* code */
			}
			/* code */
		}
	}
	return 0;
}
```

最后弱弱的问一句":这个找规律需要很多说明吗

可怜一下连搜索都不会的蒟蒻吧