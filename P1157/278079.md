逛了一圈应该不会有dalao和蛇皮猪做得一样

其实这道题可以看成n进制的加法配上一个不同寻常进位方式
~~似乎会麻烦不少，不过好歹也是一种别样的思维呢~~

所以请各位走过路过的dalao耐心康康以下的思路：
------------
这是样例：
n=5,r=3，所有组合为：

123,124,125,134,135,145,234,235,245,345

从样例来看，每个组合的最后一位会不断增加1，如果增到了n，就向前进一位，自身变为前一位加1

我们按照这样的进位规则，每增加一次就输出一次

于是就有了下面的分步代码

这题的最后一个点是坑，所以我们在输入后先特判：
```c
cin>>n>>m;
	if(m==0){//如果不抽元素的话 
		return 0;//不抽就不给你抽 
	}
```
然后为第一个组合赋值：
```c
for(i=1;i<=m;i++){
		ans[i]=i;//第一个组合 
	}
```
这就是内个不同寻常的进位方式（函数）：
```c
void shit(int j){
	ans[j-1]++;//前一位进一
	if(ans[j-1]>n){//如果这玩意膨胀了 
		k=j-1;//再向前一位 
		shit(k);//只有dalao会遵守题意（手动滑稽）
	} 
	ans[j]=ans[j-1]+1;//这一位变为前一位加一 
	if(ans[j]>n){//如果这玩意也得寸进尺 
		shit(j);//公正执法 
	}
}
```
进入代码的核心循环。

组合的最后一位在r进制下的每自增一次，就输出一次：
```c
while(ans[1]!=n-m+1){//当组合第一位等于n-m+1时，刹车 
		for(i=1;i<=m;i++){
			cout<<setw(3)<<ans[i];//输出组合的1到m位 
		}
		cout<<endl;//输出一个组合后换行 
		ans[m]++;//最后一位自增 
		if(ans[m]>n){//如果最后一位大于元素数
			j=m;
			shit(j);//堕入老夫的进位陷阱 
		}
	}
```
这样输出后，还要单独输出最后一个组合：
```c
for(i=1;i<=m;i++){
			cout<<setw(3)<<ans[i];//输出最后剩下的那个组合 
		}
```
现在我们把代码拼起来：
```c
#include<bits/stdc++.h>
#include<windows.h>
using namespace std;
int i,j,k,n,m,ans[105];
void shit(int j){
	ans[j-1]++;//前一位进一
	if(ans[j-1]>n){//如果这玩意膨胀了 
		k=j-1;//再向前一位 
		shit(k);//只有dalao会遵守题意（手动滑稽） 
	} 
	ans[j]=ans[j-1]+1;//这一位变为前一位加一 
	if(ans[j]>n){//如果这玩意也得寸进尺 
		shit(j);//公正执法 
	}
}
int main(){
	cin>>n>>m;
	if(m==0){//如果不抽元素的话 
		return 0;//不抽就不给你抽 
	}
	for(i=1;i<=m;i++){
		ans[i]=i;//第一个组合 
	}
	while(ans[1]!=n-m+1){//当组合第一位等于n-m+1时，刹车 
		for(i=1;i<=m;i++){
			cout<<setw(3)<<ans[i];//输出组合的1到m位 
		}
		cout<<endl;//输出一个组合后换行 
		ans[m]++;//最后一位自增 
		if(ans[m]>n){//如果最后一位大于元素数
			j=m;
			shit(j);//堕入老夫的进位陷阱 
		}
	}
	for(i=1;i<=m;i++){
			cout<<setw(3)<<ans[i];//输出最后剩下的那个组合 
		}
	return 0;
}
```
康懂了再copy哦~~误~~

这个办法很笨，蛇皮猪の代码也丑，如有雷同，让我删掉哦

可能会有不少可以优化的地方，各位dalao不喜请喷哦

求管理大大过，过了就是蛇皮猪の第一篇题解哦