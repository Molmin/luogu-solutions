题目中说`现要求你不用递归的方法输出所有组合`，那。。。本人偏偏就要用递归的方法输出所有组合。。。

~~淘气~~

这是一道很善良的题，一个是因为数据，另一个是因为这题除了一个DFS以外就没有其它坑人的东西了。

但是DFS依然很坑啊。。。

所以，下面让偶们来注意一下这题的几个坑点：
```
①组合的数字不能有重复！！！
②后面的数字要比前面大！！！
③输出时一定要带上场宽！！！
④输完后一定要记得换行！！！
⑤递归后一定要状态回溯！！！
```
~~似乎每个坑点都是十个字哦~~

所以，知道了这三个坑点，打起代码来还不是*行云流水*啦~

**其它注意事项，详见代码。**
```
#include <bits/stdc++.h>//万能头文件
using namespace std;
int n,p;//输入的两个数
int a[21];//输出必备
bool b[21];//判重必备
void dfs(int dep,int last)//核心DFS
{
	if(dep>p)//如果已经搜完了一种组合
	{
		for(int i=1;i<=dep-1;i++)//输出
		{
			cout.width(3);//可恶的场宽！！！
			cout<<a[i];
		}
		cout<<endl;//可恶的换行！！！
		return;//记住要返回。。。
	}
	for(int i=1;i<=n;i++)//生成组合
		if(b[i]==false&&i>last)//判断这个数是否被用过且比上一个数小
		{
			b[i]=true;//把该数标记成用过
			a[dep]=i;//记录
			dfs(dep+1,i);//递归
			b[i]=false;//可恶的状态回溯！！！
		}
}
int main()
{
	cin>>n>>p;//输入
	dfs(1,0);//开始深搜之旅
    return 0;
}