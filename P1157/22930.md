//看了题解一遍，发现dalao们全都是用的递归。那么，有没有非递归做法呢？

```cpp
#include<iostream>
#include<cstdio>
using namespace std;

int main()
{
    int n,m;
    cin>>n>>m; //读入
    int a[m+1];
    
    for(int i=0;i<=m;i++)
        a[i]=i;   //赋初始状态。注意a[0]也要赋，因为后面判断边界条件有用。
    
    while(a[0]==0)//边界条件，由于惯性会一直变到a[0]。最好和后面结合起来看。
    {
        for(int i=1;i<=m;i++)
            printf ("%3d",a[i]);//printf不是我的风格啊。。。但是这题输出条件限制，cout要写一大堆if，就只好这么写了。
        cout<<endl;  //换行
            
        int j=m;
        while(a[j]==n-m+j)j--;  //核心部分来了：n-m+j是每个数组元素在保证递增的情况下所取的最大值，可以简单证明。每次找第一个不是最大值的数，然后将其++，同时将它后面每一个数都设为按+1递增，也就是所谓初始状态。最后一次做完后就会因为惯性将a[0]++，就可以通过它来结束，既避免了下标越界，又减少了一些烦人的判断。通过简单的模拟，可以更好地理解。
        a[j]++;
        for(int i=j+1;i<=m;i++)
            a[i]=a[i-1]+1;
    }
    return 0;//一个循环结束后就可以结束了。需要注意m>n的情况，当题目没注明时需特判。
//以下是基础组合计数思想，不懂请看注释。

}