题意就是让你尽可能修改较少个 $1$ 变成 $0$ ，使得数列里面没有 $101$ 。

看样例先模拟一波：

我们先从下标 $2$ 开始遍历整个数组，判断**以当前下标对应数组的值与前后的值是否组成 $101$**：

你会发现 $i=3$ 时找到了一个 $101$  

```
ind 1 2 3 4 5 6 7 8 9 10
val 1 1 0 1 1 0 1 0 1 0
        i
```

由于要消灭掉这个 $101$ 并且要让后面的 $101$ 尽量少，我们发现**当修改 $s_{i+1}$ 的值时对于 $j=i+1$ 的 $s_{j-1},s_j,s_{j+1}$ 必定不是 $101$ ，而是 $00x(x=0$或$1)$** ；而如果修改 $s_{i-1}$ 的值的话并没有对后面的 $101$ 产生什么作用。所以我们就应该修改$s_{i+1}$，那么整个模拟过程应该是这样的：

```
ind 1 2 3 4 5 6 7 8 9 10
val 1 1 0 1 1 0 1 0 1 0 
        i                  ans=1 （发现第1个101）
val 1 1 0 0 1 0 1 0 1 0           （前面修改了第3+1=4位的值）
              i            ans=2 （发现第2个101）
val 1 1 0 0 1 0 0 0 1 0           （前面修改了第6+1=7位的值）
                    i （i跑到最后一位，发现没有101了，程序终止，直接输出修改次数，即ans）
```

整个算法复杂度 $O(n)$ 。

```cpp
#include <bits/stdc++.h>
using namespace std;

int n, ans, s[100001];

int main() {
	cin >> n;// 输入
	for (int i = 1; i <= n; i++) cin >> s[i];// 输入
	for (int i = 2; i <= n - 1; i++) {// 遍历数组
		if (s[i - 1] == 1 && s[i + 1] == 1 && s[i] == 0) {// 如果找到101
			s[i + 1] = 0, ans++;// 修改，次数++
		}
	}
	cout << ans;// 输出步骤
	return 0;
}
```

