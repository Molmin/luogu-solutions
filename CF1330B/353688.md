这道题完全可以用暴力的方法过。

## 题意

给很多个序列，每次求出来有多少个切分点，使它前面的子序列是一个排列，后面的子序列也是一个排列。也要输出方案。

## 思路

想一下最朴素的算法：枚举分割点，判断左右两边是否为某个排列（比如枚举分割点为 $i$，左边看 $a_1\sim a_i$ 是否为 $i$ 的一个排列；右边看 $a_{i+1} \sim a_n$ 是否为 $n-i$ 的一个排列）。

**先考虑左面的序列如何确定是否为一个排列：**

首先，枚举到一个分割点的时候，用一个 `bool` 数组记录一下当前数是否出现过。如果没有出现过，就把这个数标为 $1$，否则直接 pass 掉，因为一个序列的某个数出现了两次，这个序列是不可能成为一个排列的。

接下来，我们求出来这个序列的和，当这个和为长度为当前位置的排列的和时，这个序列就一定为一种排列；否则也不是。

求这个和，可以用前缀和预处理出来，也可以每次枚举时就加上这个数（详见代码）。

**再考虑右面的序列如何确定是否为一个排列：**

同样，和左面的序列的判断方法一样：

首先，先判断后面这个序列的和是否为排列的和，不是的话先 pass 掉，否则就继续判断。

接着，和上面一样，暴力判断是否这个区间的每一个数都只出现了一次。如果都只出现了一次，那么这个序列肯定是一种排列。

## 代码

代码里，算出左面的序列直接用一个数加上了，没有用前缀和，但是求右面的序列，还是要用后缀和的。

我使用了 `bitset` 替代了思路中的 `bool` 数组，使用时都差不多，将数组中所有数赋 `0` 使用 `xxx.reset()` 即可。

还有一点需要注意的，就是求区间和需要开 `long long`。

```cpp
#include<bits/stdc++.h>
using namespace std;

int a[200010];

long long hzh[200010]; // 后缀和数组

bitset<200010> vis,vis2;

int ans[200010];

int main()
{
	ios::sync_with_stdio(false),cin.tie(0);
	int t,n;
	cin>>t;
	while(t--)
	{
		// 后缀和由于是赋值操作，所以多测也不用清空
		int k=0; // 方案数
		vis.reset(); // vis 数组多测清空
		cin>>n;
		for(int i=1; i<=n; ++i)
		{
			cin>>a[i];
		}
		hzh[n+1]=0; // n+1 要清空为 0
		for(int i=n; i>=1; --i) // 求后缀数组
		{
			hzh[i]=hzh[i+1]+a[i];
		}
		long long qzh=0; // 前缀和直接扫一遍即可
		for(int i=1; i<n; ++i) // 枚举切分点
		{
		    qzh+=a[i]; // 前缀和加上当前数
			if(vis[a[i]]) break; // 如果左面的区间之前有这个数，就不是一个排列
			vis[a[i]]=1; // 标记出现了这个数
			if(qzh==(1ll*(i+1)*i>>1) /* 左面的区间，判断当前区间之和是否为排列的区间和 */ && hzh[i+1]==(1ll*(n-i+1)*(n-i)>>1) /* 右面的区间，同为判断是否和相等 */ )
			{
				// 如果到目前都满足要求，现在就来看右面的区间是否有重复的数
				vis2.reset(); // vis2 为标记右面的区间出现过的数，每次要清空
				bool flag=1; // 是否满足要求
				int j=n; // 从最右端点开始枚举，实际上从左面枚举也行，是个人习惯
				while(j>i)
				{
					if(vis2[a[j]]) // 是否之前有这个数，如果有，就不是一个排列
					{
						flag=0;
						break;
					}
					vis2[a[j]]=1; // 标记这个数
					--j;
				}
				if(flag) // 如果满足要求，加入答案数组
				{
					ans[++k]=i;
				}
			}
		}
		cout<<k<<endl; // 输出方案数
		for(int i=1; i<=k; ++i)
		{
			cout<<ans[i]<<' '<<n-ans[i]<<endl; // 输出两个序列的长度
		}
	}
	return 0;
}
```