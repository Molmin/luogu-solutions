我知道 cocoly 出的这题巨几把恶臭，但是标算真的不需要 `std::bitset`。

~~虽然被 `std::bitset` 吊打了。~~

## 算法 1

- 检验读题成果，暴力枚举计算即可。
- 时间复杂度 $\mathcal{O}(n^p)$。

## 算法 2

- 当 $p = 3$ 时，不难想到我们可以先对每一个 $i$ 预处理出所有满足条件的 $j$ 的个数，记为 $f_i$。然后对于那个三元组，枚举中间的那个数，不难发现每一个 $i$ 做为中间的那个数的贡献为 $f_i * (f_i - 1)$，且没有重复的情况，所以最终答案即为 $\sum^n_{i=1}{f_i * (f_i - 1)}$。
- 时间复杂度 $\mathcal{O}(n ^2)$。

## 算法 3

- 受算法 $2$ 启发，当 $p=4$ 时，我们也可以枚举 $2, 3$ 位置上的数，同时通过 $f$ 数组计算答案。
- 但由于题目要求 $p$ 元组的元素互异，所以 $1$ 位置与 $4$ 位置相同的情况会被多算一次。
- 记 $a, b, c$ 分别为 $2, 3, (1/4)$ 位置上的数，如果我们将 $i$ 向所有满足 $\operatorname{popcount}(i \oplus j) = k$ 的 $j$ 连边，多算的情况的个数其实就是这个有向图上三元环的个数。
- 由于 $n$ 只有 $1000$，不难想到直接用 `bitset` 优化暴力枚举的过程，枚举 $1, 3$ 两个点，然后通过 `bitset` 进行与操作得出 $2$ 点的个数，即可计算出三元环的个数。
- 时间复杂度 $\mathcal{O}(\dfrac{n^3}{\omega})$。

## 算法 4

- 受到算法 $2,3$ 的启发，当 $p=5$ 时，我们可以故技重施，枚举 $2,4$ 两个位置的值，然后通过 `bitset` 优化可以轻松求出位置 $3$ 满足的数的个数，同时 $1,5$ 位置的答案我们也可以通过容斥算出。
- 考虑一下哪几种情况我们需要容斥，记我们枚举的 $2,4$ 位置的数分别为 $a,b$，中间位置满足的数的个数为 $mid$。

> 1. $1,3,5$ 位置均无限制，这种情况的个数为 $f_{a} \times f_b \times mid$。
> 2. $1, 3$ 位置相等，$5$ 位置无限制，这种情况个数是 $mid \times f_b$。
> 3. $3,5$ 位置相等，$1$ 位置无限制，这种情况的个数是 $mid \times f_a$。
> 4. $1,5$ 位置相等，$3$ 位置无限制，这种情况的个数是 $mid \times mid$。
> 5. $1,3,5$ 位置相等，这种情况的个数是 $mid$。

- 不难发现情况 $2,3,4$ 其实是包含情况 $5$ 的，由于情况 $5$ 应该只能被算一次，所以我们只要将情况 $1$ 的个数减去情况 $2,3,4$ 的个数再加上两倍情况 $5$ 的个数就是 $p=5$ 时的答案了。

- 时间复杂度 $\mathcal{O}(\dfrac{n^3}{\omega })$。
- 综合算法 $1,2,3,4$ 即可获得本题的全部分数。

## 算法 5（如何优雅的抛弃掉 `std::bitset`）

注意到我们对 $\operatorname{popcount}(a_i\oplus a_{i+1})=k$ 的性质运用不够深，出题人为什么不给你一个 $0/1$ 矩阵或者其他的东西呢？

事实上，这个条件的感性含义是两个数二进制下不同的位数个数 $=k$。

注意到上述使用 `bitset` 的瓶颈是求两个数的邻域集合的交集的**大小**，考虑有没有不同的做法，能够不使用 `bitset`。

其实是有的，注意到每个数的邻域集合大小其实只有不超过 $\binom{10}{5}=252$ 个，我们可以枚举**交集**而非枚举两个数，然后枚举这个数的邻域，并统计到相应位置，这部分的复杂度 $1000\times 252\times 252$，略高于 $\frac{n^3}{\omega}$，但是可以通过。

可能说的比较抽象，给出参考代码：

```c++
for(int i = 1; i <= n; ++ i)
	for(auto j : b[i])
    	for(auto k : b[i])
            if(j != k) ++ m[j][k];
```

其中 $b_i$ 表示 $i$ 的邻域集合构成的 `vector`，最后的 $m_{i,j}$ 就表示 $i$ 和 $j$ 的邻域集合的交集的大小。
