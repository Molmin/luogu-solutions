自己在做这道题的时候并没有遇见时间的问题。这道题做法很明显，利用贪心思想，先求出各列的最大值，在一波循环带走即可，只需要稍微判断下数的正负，感觉并不是很复杂。

下面AC代码

    
    
    
    
            
            
        
```cpp
    #include<iostream>
    #include<cstdio>
    using namespace std;
    int a[200][23000]={0};//这个数组用来存道路的分值
    int main(){
    int m,n,x,y,f,ans=0,sum=0;
    cin>>m>>n;
    for(int i=1;i<=m;i++)
    for(int j=1;j<=n;j++)
    cin>>a[i][j];//读入数据
    for(int i=1;i<=n;i++)//循环开始
    {
        f=-1000000;//随手赋了一个绝对最小值
        for(int j=1;j<=m;j++)
        {
            f=max(a[j][i],f);//找到每一列的最大值
        }
        if(f<0){//如果是负数，需要特殊考虑
                ans=max(sum,ans);//但无论怎样，先比较已经得到的值
        //这里比较是有必要的，因为你不知道你接受了这个负数后后面
        //的数据能否挽回这次损失，比如这个负数的绝对值大于后面的
        //正数值，那样这个点就应该舍去
                if (sum+f>0) sum+=f;//如果加了这个负数之后不是零，带上
                //因为求最大值肯定要带上这个大于零的值
                else sum=0;//否则就不走前面
        }
        else {
            sum+=f;//如果不是负数，带上
        }
    }
    if(sum!=0) ans=max(ans,sum);//这里是把最后的数据记录
    cout<<ans;//输出
    return 0;//功德圆满
    }
```
只要处理好负数，应该不会有什么问题。
个人认为这段代码还比较粗糙，还可以加以改进，希望提出建议。
