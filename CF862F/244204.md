来点更优理论复杂度和数据结构奇趣蛋。

#### 题意

有一个长度为 $n$ 的字符串序列 $s$，定义 $f(l, r) = \mathrm{lcp}(s_l, s_{l + 1}, \dots, s_{r}) \cdot (r - l + 1)$，即一段区间的字符串 $\mathrm{lcp}$ 与区间长度的乘积。

有 $q$ 次操作，每次要么将某个 $s_x$ 改成一个新的字符串 $t$，要么给出 $l, r$，求 $\max\limits_{l \leq a \leq b \leq r} f(a, b)$。

令 $L$ 表示输入中所有字符串长度之和，$1 \leq n, q, L\leq 10^5$。

#### 题解

由于如果要区分 $n, q, L$ 的值那么复杂度里面的式子可能有点逆天，所以下文分析复杂度的部分都把 $q, L$ 视作与 $n$ 同阶。

首先有经典结论 $\mathrm{lcp}(s_1, s_2, \dots, s_k) = \min\limits_{1 \leq i < k} \mathrm{lcp}(s_i, s_{i+1})$。先用一个线段树特判掉 $a = b$ 的情况，剩下的部分就变成了：给定整数序列 $a$，其中 $a_i = \mathrm{lcp}(s_i, s_{i+1})$，单点修改，询问区间 $[l, r]$ 内 $\max\limits_{l \leq a < b \leq r} \{(b-a+2) \cdot \min\limits_{a \leq c \leq b} a_c\}$。注意转化后的一次询问 $[l, r]$ 其实是转化前的一次询问 $[l, r + 1]$。

但是发现转化后的这个问题有点过于困难了，即使不带修也需要 $O(n \log^2 n)$ 的复杂度（至少我只会这个复杂度，但是与本题关系不大，所以并不重要），所以需要挖掘题目中比较特殊的限制：$L \leq 10^5$。

在修改前，显然有 $\sum a_i \leq \sum |s_i|$，而每次修改时，把 $s_x$ 改成了 $t$，会让 $a_{x-1}$ 和 $a_x$ 分别变成一个新的不超过 $|t|$ 的值，即 $a_{x-1} + a_x \leq 2|t|$。也就是说，所有在 $a$ 数组中出现过的值之和不超过 $2L$，故不同的数至多有 $\sqrt{2 \cdot 2L} = 2\sqrt{L}$ 个。

因此可以考虑枚举子区间的最小值，假设子区间最小值为 $k$，令 $b_{k, i} = [a_k \geq k]$，只需要对于一次询问 $[l, r]$，找到最长的子区间 $[a, b]$ 满足 $\forall c \in [a, b] , b_{k, c} = 1$。单点修改 $a_x \gets y$ 时直接对于每个 $k$ 把 $b_{k, x}$ 重新计算更新。如果使用 $O(\sqrt n)$ 棵线段树对于每个 $k$ 维护最长连续段，可以做到 $O(n \sqrt n \log n)$，其实已经足以通过本题（而且拿下了最快解），但是仍可以进行优化。

再注意到，每次修改的时候，如果 $a_x$ 从 $y$ 改到 $z$，$b$ 的修改量是不超过 $y + z$ 的，而和上文一样，由于每次修改字符串时只会给 $a$ 带来两次值不超过字符串长度的单点修改，所以实际上 $b$ 的修改次数是 $O(n)$ 而非 $O(n \sqrt n)$ 的，所以这个算法的修改与查询量级并不一致，可以尝试平衡。

一种想法是直接对于每个 $k$ 对应的 $b_k$ 序列进行分块，块间使用猫树进行维护，修改时块内暴力改，并把猫树上所有包含这个块的节点的信息重新计算，就可以直接平衡掉，但是这看上去就不可写，所以我整出了另一种写法。

一段区间里的极长的全 $1$ 段有两种可能：要么是全局中一段完整的 $1$ 段，要么是顶着区间左右端点的一段 $1$。

对于顶着区间左右端点的情况，用分块维护序列中每个点往前 / 后的第一个 $0$，和每一个块往前 / 后的第一个有 $0$ 的块，就可以做到 $O(\sqrt n)$ 修改 $O(1)$ 查询。

而对于完全包含的情况，发现其实没必要枚举 $k$，对于一段在 $b_k$ 上的全 $1$ 区间 $[l, r]$，出现时间是 $[p, q]$，那么其权值是 $(r - l + 2) \cdot k$，对于第 $t$ 次操作给出的询问 $[a, b]$，这个区间能对该询问做出贡献当且仅当 $a \leq l, r \leq b, p \leq t \leq q$。找出 $l, r, p, q$ 可以用 `set`，而计算贡献的部分是一个三维偏序问题，使用树套树或 cdq 分治即可，复杂度 $O(n \log^2 n)$。我的代码里写的是 cdq。

还有关于 cdq 分治的一些小细节：注意到前两个限制都是一个前 / 后缀，只有第三个限制是一个区间，所以在做 cdq 的时候应该先排序第一维，再扫第二维，然后用线段树维护第三维。而且这个线段树可以复用一开始处理 $a = b$ 时的线段树。

最后的复杂度是 $O(n(\sqrt n + \log^2 n))$。

#### 代码

由于实在是过长了，所以直接放[链接](https://codeforces.com/contest/862/submission/211716433)好了。

不过这题数据好像很水，所以我也不保证这篇题解和给出的代码是否没有问题，如果发现了的话帮忙捉个虫捏。