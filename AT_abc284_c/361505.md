新年第一场 ``ABC``！~~但是我赛场上没 ``AC`` 这题......~~

[``ATC`` 上的原题](https://atcoder.jp/contests/abc284/tasks/abc284_c)

# 题意

给定一张 $n$ 个顶点 $m$ 条边的无向图，求其中有几张连通子图。

# 思路

并查集。如果需要的话可以看[ ``wiki`` 上的介绍](https://oi-wiki.org/ds/dsu/) 和 [模板题](https://www.luogu.com.cn/problem/P3367)。

在这里也简短介绍一下。假如你遇到了这样的一道题：

- 有 $n$ 个人和 $m$ 条关系，存在关系的人属于同一个团队。问有几个团队。

很容易想到用数组维护每个团队里的人，但是会遇到这种情况：

- 已有的信息表明 $1,2,3$ 号属于一个团队，$4,5$ 号属于一个团队，于是分别放入一个数组中

- 然而又有一条信息 $4,5$ 属于一个团队，然后就要被迫合并 $1,2,3$ 的数组和 $4,5$ 的数组。

这样高的复杂度显然是不能接受的，因此维护团队时要用一种更高效的结构——树结构。

## 并查集

并查集就是一种运用了树结构的数据结构，呈现为一个森林。

森林中的每一个树结构都表示一个团队，这棵树的根节点就是这个团队的队长。

初始时，由于没有任何关系，我们可以将每一个人都理解成一个团队。

**合并**

当要合并两个团队时，我们就找出两个团队的队长，然后将其中一位队长设为另外一位的“上级”。

那么为什么要找出队长再合并呢？

如果找出队长来合并，就仍然可以通过上级的关系找出队长。反之，就会出现一个人有两个上级的神奇情况。

因为每个人初始都是队长，因此上级关系是从头到尾都存在的。

**查询**

由于特殊的合并方法，属于同一个团队的人必然拥有同一个队长，而我们也可以通过上级关系找出队长。

所以如果需要查询两个人是不是同一个团队的，只需要判断他们有没有同一个队长就行。

----

回归本题。

题目是以图论的方式来呈现的。但是所谓的“边”其实就是一条关系，表明边的两个顶点属于同一个团队。

然后题目要求我们找有几张连通子图，其实就是找有几个团队。由于每个团队的队长是唯一的，所以只需要找有几个不同的队长就行。

# 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
 
int n,m,z,x,y,fa[10005]; //fa 存当前的队长
map<int,bool> MP;
struct Edge{ 
    int u,v;
} p[10005];//存边
int find(int x) {
    if (x == fa[x]) return x;
    return fa[x] = find(fa[x]);
}
int main(){
    cin>>n>>m;
    for(int i = 1;i <= n;i++) fa[i] = i;//初始队长
    for (int i = 1;i <= m;i++){ 
        cin>>p[i].v>>p[i].u;
        int a = find(p[i].v),b = find(p[i].u);//存队长
        fa[a] = b; //合并团队
    }
    int cnt = 0;
    for (int i = 1;i <= n;i++){ //找有几个不同的队长
        cnt += !(MP[find(i)]);
        MP[find(i)] = true;
    }
    cout<<cnt;
    return 0;
}
```
**补充**

细心的读者可能会发现，查询时 $fa$ 数组**未必**存的是队长，有时候仅仅是一个普通的并非队长的上级。

可以模拟一遍样例 $1$，就会发现最终 $fa_1$ 存储的是 $2$，而并非队长 $3$。

这是因为输入时我们仅仅改变了队长 $i$ 的 $fa_i$，而他的下级并没有被改变，就会出现一些滞后。

但是这其实并不影响查询。因为合并两个团队以后，成为了下级的队长的 $fa$ 就不会再改变了，因为不会再用于合并。

并非队长的 $fa$ 就只会在找队长时被访问，而找到的上级又会访问上级的上级，最终找到队长。

查询时不需要更新所有数据，这也是并查集比普通数组高效的原因之一。

---

讲的可能不太好，可以去看模板题的题解。