## CF1430F 解题报告

### 原题链接

http://codeforces.com/problemset/problem/1430/F

### 题目大意

你有一把枪，这把枪的弹夹量为 $k$ 发，并且刚开始弹夹是满的。每次换弹都需要 $1$ 单位时间，丢弃目前弹夹里的全部子弹并将弹夹装满。你的射击技术十分高超，可以不耗费任何时间射出 $1$ 发子弹并消灭一个敌人。现在有 $n$ 波攻势，第 $i$ 波有 $a_i$ 个敌人，出现时间为 $[l_i, r_i](r_i \le l_{i+1})$。你需要在保证消灭所有敌人的条件下，让使用的子弹最少（使用的子弹数 $=$ 消灭敌人的子弹数 $+$ 丢弃的子弹数）。注意，在最后一波攻势结束后，不丢弃弹夹中剩余的子弹。

### 解法分析

消灭敌人的子弹数是确定的，所以我们只需让丢弃的子弹数尽可能小。那么我们就可以得结论 $1$。

结论 $1$：当我们 **没必要** 换弹夹时，不换弹夹比换弹夹更优。

问题来了，"没必要"的含义是什么呢？

假设你在第 $i$ 波攻势开始时弹夹中有 $p$ 发子弹，并且可以在第 $i \sim n$ 波中消灭所有的敌人，那么就称这种情况为 **没必要换弹** 。

这时我们贪心算法的大致思路就出来了：用 $ans$ 记录已经使用的子弹，$now$ 记录现在弹夹里还有多少子弹。如果必须换弹就换弹，然后更新 $now$ 和 $ans$ 的值。到这里，我们只需解决在某个回合开始前是否必须换弹即可。

注意到在每个回合开始前都应该有一个对子弹数的最低要求。不妨设当第 $i$ 波攻势开始时，弹夹中要有至少 $dp_i$ 发子弹，才能消灭之后所有敌人。有一个很关键的条件：$r_i \le l_{i+1}$，接下来我们将围绕这个条件分类讨论。

若 $r_i < l_{i+1}$：则 $dp_i$ 与 $dp_{i+1}$ 无关（你可以在 $ (r_i,l_{i+1}]$ 内做好充分的准备）。那么根据 $a_i$ 就能算出 $dp_i$ 的值。

若 $r_i = l_{i+1}$：这时 $dp_i$ 就和 $dp_{i+1}$ 息息相关了。产生瓜葛的原因在于两个区间有重复的时间点 $r_i$。我们的获胜条件是 **每波敌人都必须在出现时间内被全部消灭**，这意味着我们两波敌人都不能放弃。如果第 $i$ 波敌人能在 $[l_i,r_i)$ 内消灭，那么问题就等价于上面的讨论。如果第 $i$ 波敌人必须到 $r_i$ 才能被全部消灭，由于这两波是连在一起的，所以没有任何准备时间，我们必须在 $r_i$ 消灭完第 $i$ 波敌人后弹夹中仍然留有 $dp_{i+1}$ 发子弹才能保证胜利。

由于 $dp_i$ 只可能与 $dp_{i+1}$ 的特性，我们从后到前 DP。然后再从前往后按照上面的方法贪心一遍，就可以求出答案。（注意刚开始弹夹是满的，但并不意味着需要全部使用，即样例 4）。

最后贴上代码。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
int n, K, l[2010], r[2010], a[2010], dp[2010], now, ans;
signed main(){
	cin >> n >> K;
	for (int i = 1; i <= n; i++)
		cin >> l[i] >> r[i] >> a[i];
	for (int i = n; i >= 1; i--){
		int need = a[i] + (r[i] == l[i + 1] ? dp[i + 1] : 0);
		if (K * (r[i] - l[i] + 1) < need){
			cout << "-1\n";
			return 0;
		}
		dp[i] = max(0ll, need - K * (r[i] - l[i]));
	}
	now = K, ans = 0;
	for (int i = 1; i <= n; i++){
		if (now < dp[i]){
			ans += now;
			now = K;
		}
		ans += a[i];
		now -= a[i] % K;
		if (now < 0)
			now += K;
	}
	cout << ans << "\n";
	return 0;
}
```