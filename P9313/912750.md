## [P9313 [EGOI2021] Shopping Fever](https://www.luogu.com.cn/problem/P9313)

**[Solution PDF](https://egoi.ch/files/solutions/A-shopping_fever.pdf)** 先摆出来。

为了某些像我一样~~看英文看到崩溃~~的人，就有了这篇题解。

虽然英文题解原地址摆出来了，但我个人觉得那篇还不够详细，不大适合像我一样的萌新。所以，这里将用一种**极度**通俗易懂的语言来讲解。

难度：约普及+提高-。

## 题解更新

2023 年 5 月 28 日：更改了两处笔误、一处英文大小写错误。据 @[hhoppitree](https://www.luogu.com.cn/user/183609) 的反馈，修改了测试点编号的错误。非常感谢。

## 题目大意

Heiti 要买 $n$ 件商品，每一件的价格为 $p_i$。刚好商场大促销，对于每笔账单都有以下两种促销活动：

1. 对于商品数 $\geq 3$ 的账单，少付其中最小值的价格；
2. 对于商品数 $\le 3$ 的账单 $x_1, \cdots$，少付**账单总价** $q\%$ 的价格，其中 $q(\in [0, 100])$ 为给定的常量。

假设 Heiti 可以把这 $n$ 件商品分成任意笔账单购买，求 Heiti 需要花的**最小总价**。

## 代码分析

首先我们可以明确「二不」，对于以后的做题有很大帮助。

此处 $k_i$ 指账单的第 $i$ 项商品。

1. **不要**在一笔账单内购买 $> 3$ 件商品，也就是说**不要**浪费任何一件商品可能的折扣。

	如果把第 $4$ 件商品 $k_4$ **单独**放到一笔账单内，显然 $k_4 \leq k_3$，则贡献（相当于 $\min(k_1 \sim k_4)$）**不增**。就算贡献**不变**，那么对于 $q = 0$（折扣 $0\%$），也与原先的折扣贡献不变相同；但如果 $q > 0$，那么折扣就有 $q\% \cdot k_4$，显然这个相对于 $0$ 更多。
    
    通俗易懂一句话：无论 $q$ 是多少，$a_4$ 提出来折扣不亏！


2. **不要**在一笔账单内购买 $2$ 件商品。

	这个不是说不可以，只是不要多考虑。小学数学就有乘法分配律 
    
    $$ a(b + c) = ab + ac $$
    
    那么同样 
    
    $$ q\% \cdot (k_1 + k_2) = q\% \cdot k_1 + q\% \cdot k_2 $$
    
    就相当于两笔单独账单。

### 思路一 贪心

看到「最大 / 最小值」，立马就能想到贪心。

这道题还真可以用贪心做，但会 WA 一些点，不是正确解法，您可以直接跳过。

首先先把 $p$ 从大到小排序，先解决大的。（还可以通过 $q$ 是否 $> \dfrac{100}{3}$ 来判断，如果这样用促销 $1$ 怎么样也不会比促销 $2$ 更便宜，直接特判。）

接下来，促销 $1$ 要付的钱就是 

$$ k_1 + k_2 + k_3 - \min(k_1 \sim k_3) $$

而促销 $2$ 就是

$$ q \lfloor k_1 / 100 \rfloor $$

所以可以 `while` 到促销 $1$ 的折扣贡献比促销 $2$ 还**少**时停止，然后接下来的所有商品通通用促销 $2$。

```cpp
int i = 0; // 购买到第 i 件商品
```

```cpp
#define a0 a[i]
#define a1 a[i + 1]
#define a2 a[i + 2]
// define 一下比较直观 + 比较省码（本人思想）。
while (n - i >= 3 && (a0 + a1 + a2) / 100 * q < min({a0, a1, a2}))
       ^- 剩下的够进行促销 1         ^- 促销 2 -^           ^- 促销 1 -^
    res -= min({a0, a1, a2}), i += 3; // 就进行促销
while (n - i > 0) // 剩下的通通用促销 2
    res -= a0 / 100 * q, i++;
cout << res;
```

Ok！喜滋滋地提交——$42 \text{pts}$，WA on #16、#18、#21、#23（~~珂恶的**捆绑测试** again~~）。

为什么？由于（版权原因？）没有测试数据下载，所以我就调了很久很久。

这边非常良心地给大家 $2$ 组能 Hack 掉我（或者跟我思路差不多的 $42 \text{pts}$）代码的测试数据：

---

### Hack 输入 #1

```plain
4 20
300 200 200 200
```

### 答案输出 #1

```plain
640
```

---

### Hack 输入 #2

```plain
5 30
100 900 100 100 1000
```

### 答案输出 #2

```plain
1530
```

---

### 思路一 贪心 部分错误分析

为什么？大家可以发现，这两组 Hack 数据都有一个显著的特点：

在排序后，前 $3$ 个商品价格相差很大！

例如 Hack 输入 #2，在排序后 $p_1 \sim p_3 = \{1000, 900, 100\}$，差值接近 $1000$，这样免掉了很小的 $100$，但两个**最大**的 $1000$ 和 $900$ 却被浪费了。要是这两个数用促销 $2$，可是有 $30\% \cdot (1000 + 900) = 570$ 的折扣，然后再把 $3$ 个 $100$ 拿去使用促销 $1$，还有 $100$ 折扣，总共就有 $670$ 单位，肯定比原来多。

但是要怎么做，才能考虑到**所有**的情况呢？毕竟不是单纯的加 or 减，还要逐个判断。$O(n^3)$ 肯定 TLE，但是——

Dp 可以做到！

### 思路二 动态规划

的确，「最大 / 最小值」也在动态规划的范畴内。

依题意模拟，dp 最重要的**动态转移方程**就很显著了。

首先从初始化 $f(0) = 0$ 开始。考虑促销 $2$，肯定对于所有的 $p_i$，都可以使用促销 $2$ 的

$$ f(i) = f(i - 1) + q \lfloor p_i / 100 \rfloor $$

而促销 $1$ 就要求 $i \geq 3$，为

$$ f(i) = f(i - 3) + p_{i - 2} + p_{i - 1} $$

结合一下，就可以推导出（$\TeX$ 公式复杂起来比较难读，但能理解就好）

$$
f(i) = \begin{cases}
0  & \text{if}~i = 0 \\
f(i - 1) + q \lfloor p_i / 100 \rfloor  & \text{else if}~i < 3 \\
\min(f(i) = f(i - 3) + p_{i - 2} + p_{i - 1}, f(i - 1) + q \lfloor p_i / 100 \rfloor)  & \text{otherwise}
\end{cases}
$$

假设对于 $f(i)$ 来说，促销 $1$ 折扣贡献比促销 $2$ **更大**，那么 $f(i - 1), f(i - 2)$ 就直接**废弃**不考虑，转而使用促销 $1$ 公式。

而这样就可以做到既能**多方面考虑**，也能**保持不 TLE**。时间复杂度 $O(n \log n)$，空间复杂度 $O(n)$。

代码就肥肠简单了，给出核心部分，请过脑而非直接 copy！

```cpp
for (int i = 1; i <= n; i++)
    f[i] = min(f[i - 1] + a[i] / 100 * (100 - q), 
        i < 3 ? 0x7fc0000000 : f[i - 3] + a[i - 2] + a[i - 1]); 
                  ^- 当 i < 3 时选一个足够大的数，相当于忽略掉这一项。
cout << f[n]; // 答案 f(n)
```

The End!