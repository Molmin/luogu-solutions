# 前言

十分钟就过了。

这大概是我过得最快的黄题~~之一~~。

我觉得可以降橙了。

# Solution

## 1、整体思路

看了看标签“枚举，暴力”，又看了看数据范围 $N,M≤500$，我们明白了一切。

只需要一个一个判断就行了。只要判断一个的复杂度是 $O(1)$，总复杂度就是 $O(N*M)$。

## 2、判断是否在矩形内

直接看点坐标来判断是有困难的，因为他给的两个点，既可能是左下右上，也可能是左上右下。

但是我们可以知道，如果一个点在一个矩形之内，它的横坐标和纵坐标值肯定是介于两个对角点的横坐标和纵坐标值之间的。

这样我们可以提前给给出的两点的横坐标、纵坐标比大小，小的放前面，大的放后面。这样就容易比对大小，看给出的点是不是在矩形内了。

## 3、判断是否在圆形内

需要用到平面直角坐标系中两点间的距离公式 $dis=\sqrt{(x1-x2)^2+(y1-y2)^2}$。

只需要看一下给出的点和圆心的距离是否小于该圆的半径，如果小于就说明在这个圆内。

## 4、注意逝项

1、题目中有说到，“当某点在一个图形的边界上时，我们认为该点**不在**这个图形的内部”。所以在出现等于情况的时候该点是在图形的边界上，而不是内部，不记入。

2、空间绝对是够的，建议开长双精度浮点。然后直接比大小就行了，~~否则容易翻车~~。

# AC代码

```
#include<bits/stdc++.h>
using namespace std;
long long n,m,i,j,rr,cc,ans;long double r[520][4],c[520][3],p[520][2];char a;  //当 场 表 白
int main()
{
	cin>>n>>m;
	for(i=1;i<=n;i++)
	{
		cin>>a;
		if(a=='r')
		{
			rr++;
			cin>>r[rr][0]>>r[rr][1]>>r[rr][2]>>r[rr][3];
			if(r[rr][0]>r[rr][2]) swap(r[rr][0],r[rr][2]);
			if(r[rr][1]>r[rr][3]) swap(r[rr][1],r[rr][3]);
		}
		if(a=='c')
		{
			cc++;
			cin>>c[cc][0]>>c[cc][1]>>c[cc][2];
		}
	}
	for(i=1;i<=m;i++)
	{
		cin>>p[i][0]>>p[i][1];
	}
	for(i=1;i<=m;i++)
	{
		ans=0;
		for(j=1;j<=rr;j++)
		{
			if(p[i][0]>r[j][0]&&p[i][1]>r[j][1]&&p[i][0]<r[j][2]&&p[i][1]<r[j][3]) ans++; 
		}
		for(j=1;j<=cc;j++)
		{
			if((p[i][0]-c[j][0])*(p[i][0]-c[j][0])+(p[i][1]-c[j][1])*(p[i][1]-c[j][1])<c[j][2]*c[j][2]) ans++; 
		}
		cout<<ans<<endl;
	}
	return 0;
}
```
