题目传送门：[P8756 [蓝桥杯 2021 省 AB2] 国际象棋](https://www.luogu.com.cn/problem/P8756)。
# 思路
这道题由于 $1 \le N \le 6$ 所以我们可以把每一列的状态用 $0$ 或 $1$ 表示，没放马或放马，于是我们就想到了**状态压缩 dp**。

**状态设计**:

$x$ 为这一列的情况，$y$ 为上一列的情况，$z$ 为上上列的情况，$get(x)$ 表示 $x$ 状态中马的个数，$f_{i,j,x,y} $ 表示第 $i$ 列放了 $j$ 个马且当前列的情况为 $x$ ，上一列为 $y$ 的方案数。

**状态初始化**：

$f_{0,0,0,0}=1$ 一开始就有一种情况。

**求马的个数**：

其实就是求二进制中 $1$ 的个数，随便怎么写都可以。
```cpp
int get(int x){
	int ans=0;
	while(x) ans++,x&=x-1;
	return ans;
}
```

**判断是否互相攻击**：

1. 这一列与上一列判断： 

```
*    *
2    *
*    *
*    1
*    *
2    *
*    *
```

如上图，标记为 $1$ 的是马的位置，标记为 $2$ 的是它的攻击范围，所以只要通过左移两位和右移两位来判断是否互相攻击。

所以判断方法为：

```cpp
if (x&(y<<2)||x&(y>>2)) continue;
```
2. 这一列与上上列判断：

```
*    *    *
*    *    *
2    *    *
*    *    1
2    *    *
*    *    *
*    *    *
```
如图，标记为 $1$ 的是马的位置，标记为 $2$ 的是它的攻击范围，所以只要通过左移一位和右移一位来判断是否互相攻击。

所以判断的方法为：
```cpp
if (x&(z<<1)||x&(z>>1)) continue;
```

**方程转移**：

首先我们需要枚举 $j$ ,范围就是 $get(x)+get(y)+get(z)$ 一直到 $K$。方程的转移就可以轻松写出来了，就是加上，上一列去掉这一列马的个数即 $f_{i-1,j-get(x),y,z}$。

所以最后的方程就是 $f_{i,j,x,y}=f_{i,j,x,y}+f_{i-1,j-get(x),y,z}$。

所以最后的答案为所有状态的总和，即：$ans=ans+f_{m,k,i,j}$。$i$ 和 $j$ 是所有状态。

**总体思路**：

先每一列枚举，再枚举这一列状态，上一列状态，判断是否互相攻击，之后再枚举上上列的状态，判断是否互相攻击，最后转移即可。

最后一定要记住**题目要取模**。
# 代码
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int mod=1000000007;
int f[101][21][1<<6][1<<6];
int get(int x){
	int ans=0;
	while(x) ans++,x&=x-1;
	return ans;
}
main(){
	int n,m,k;
	cin>>n>>m>>k;
	f[0][0][0][0]=1;
	for (int i=1;i<=m;i++)//枚举每一列
		for (int x=0;x<(1<<n);x++)//枚举这一列
			for (int y=0;y<(1<<n);y++){//枚举上一列
				if (x&(y<<2)||x&(y>>2)) continue;
				for (int z=0;z<(1<<n);z++){//枚举上上列
					if (y&(z<<2)||y&(z>>2)) continue;
					if (x&(z<<1)||x&(z>>1)) continue;
					int t=get(x)+get(y)+get(z);
					for (int j=t;j<=k;j++)//方程转移
						f[i][j][x][y]=(f[i][j][x][y]+f[i-1][j-get(x)][y][z])%mod;
				}
			}
	int ans=0;
	for (int i=0;i<(1<<n);i++)
		for (int j=0;j<(1<<n);j++)
			ans+=f[m][k][i][j],ans%=mod;
	cout <<ans;
    return 0;
}

```
