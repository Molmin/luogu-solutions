**简要题意：**

你有一个两位或以上的正整数。每次操作你必须交换任意不相同的两位，随后删除最后一位。当数只剩一位时操作结束，求剩下数位的最小值。

**解法：**

很明显，本题是一道**贪心和策略问题**，可以试着分两种情况讨论。

当 $10 \le n \le 99$ 时，需要进行操作的数是两位数，所以唯一可能的操作是将个位与十位交换后删除修改后的个位。故答案总是原数的个位。

否则，最终的答案恒为原数中最小的数位。操作方法可以考虑每次将最小的数位交换到最后第二位，这样可以保证下一次操作其不可能留在最后一位而被删除。

举一个例子，比如输入为 $12345$ 可以按照以下方式操作：

$12345 - 42315 - 4231 - 4213 - 421 - 412 - 41 - 14 - 1$

最后附上AC的代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
	int n;
	string s;
	cin>>n;
	for(int i=0;i<n;i++){
		cin>>s;
		if(s.length()<=2){
	    cout<<s[1]<<endl;
	    continue;
	}
		int ans=999;
		for(int j=0;j<s.length();j++)     ans=min(ans,int(s[j]));
		cout<<ans-48<<endl;
	}
	return 0;
} 
```
