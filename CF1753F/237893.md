国外题就是....妙啊？不用任何高级数据结构却把你整的要死要活。

看到这个题第一反应就想到了二维区间 $\text{mex}$。各种想可持久化线段树的魔改但想不出来于是点开题解--一片空白。于是乎不得不打开生草机然后步入了CF题解。

首先我们考虑如何枚举正方形。因为正方形的对角线十分的“端正”，我们不妨考虑用对角线去枚举正方形。同时由于 $\text{mex}$ 具有单调性，所以我们可以采用双指针的方法来维护最大的非法正方形（当然最小的合法正方形也可以）。具体而言，我们首先在外层枚举每一条对角线。对于每一条对角线在内层循环枚举正方形的右下角，同时依赖单调性维护左上角。

如何动态维护一个集合的 $\text{mex}$ 呢？**或许**我们可以使用线段树。

那么我们现在来粗略的估计一下复杂度：对角线有 $n+m$ 条，每条对角线要对 $nm$ 个单元格扫描，总共会加入 $k$ 个怒气值......这是要T飞啊。但是，但是，正方形的枚举其实有一个非常神妙的性质：在不优秀的实现下，每个点最多被执行加入操作 $\min(n,m)$ 次。简单的分析一下，对于一条对角线，它最劣情况是把以它为对角线的正方形内所有点都扫了一遍。在这种情况下的正方形边长是多少呢？$\min(n,m)$。那么对于每个点，最多会被多少个正方形覆盖呢？显然也是 $\min(n,m)$。

现在，我们的修改次数是 $k\cdot\min(n,m)$，查询次数是 $nm$。再带上线段树修改和查询的复杂度，最劣情况下大概是 $1e6\times200\times\log_21e6+4e4\times\log_21e6\approx4e9$，不太能过。我们的修改复杂度和查询复杂度并不是很均衡，不妨考虑使用一种修改复杂度更低，并适当放宽查询复杂度的，更加简单的方法去维护 $\text{mex}$：分块。修改 $O(1)$ 查询 $O(\sqrt k)$。这样，问题就解决了。