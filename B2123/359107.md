### update：

修复了一点点小错误。

感谢@[拿铁Yester](https://www.luogu.com.cn/user/420129)提出的建议

---

看了题解区这么多大佬的题解，本蒟蒻深感自愧不如。在这一道红题上本蒟蒻竟然卡了这么长时间，可谁知只需要最朴素的做法即可。

---

- 鄙人的思路是将字符串的每一位都与前一位相比较，如果相同就将个数累加，如果不相同就输出它前一个字符的个数与字符，再将个数变回一。注意这里，为什么要变回一而不是变回零？因为如果出现了不相同的数字，就要重新计数，而重新计数还包括了新出现的这个数它本身，其实就相当于将计数器归零，再自增。

- 还有一点，其他的大佬也都说了，这里鄙人再提一嘴，也就是遍历字符串时要对第一位进行一个特判，只将计数器自增，不做其他操作。因为第一位前面没有字符了，如果强行比较会导致越界。

---

其实这是很简单的一道题，直接上代码。

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>

using namespace std;

int main(){
    string s;
    int ans=0;  
    cin>>s;
    for(int i=0;i<s.size();i++){
        if(i==0||s[i]==s[i-1]){  // 对第一个进行特判以及对连续的字符进行计数
            ans++;
            continue;
        }
        if(s[i]!=s[i-1]){  // 如果变化了
            cout<<ans<<s[i-1];  //输出变化前的个数及字符
            ans=1;
        }
    }
    cout<<endl;
    return 0;
}
```

还有一点，大家看我的代码里第九行，为什么我将计数器赋值为零，不是说赋值为一吗？我在前文中说过，赋值为一就相当于先赋值为零，再自增，而你再看我代码里的第十三行，对第一个字符也进行了自增操作，这里就说明在遍历第一个字符时已经将计数器加一了，所以不用在一开始就赋值为一。