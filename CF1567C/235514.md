## C. Carrying Conundrum

看到 CF 的题解里是给出了一个结论的, BS 表示这个结论真的不是很明白.

然后是看到题解里面给出了一个 dp 的思路, 但是... ~~英语害人~~

只是大概意会了一下题解的意思, 在这里就给一个 dp 的思路和代码吧.

---

~~其实这个题看着就很数位 dp 的说~~

读完题目, 可以发现这是一个好像与数学有关系的题, 但是又没有什么好的数学方法解决, 而 $n$ 的范围又比较大, 这时可以按位进行考虑, 也就是数位 dp 了.

先提一句: 蒟蒻的数位 dp 只会记搜, 并没有写过循环类型的, 所以下面的东西也是在记搜的基础上来的.

先说一下在这个题目里面数位 dp 是干什么的.

以题中的 $10000$ 为例, 下文中对于从左向右也就是从高位到低位的第 $i$ 位简述为第 $i$ 位.

考虑按照题目中的方法相加可以得到该数的二元组的个数, 二元组是有序的, 所以只需要考虑第一项的所有取值即可.

$10000$ 的第一位上为 $1$ , 则选取的数字中第一位上只能为 $1$ 或 $0$ , 若为 $1$ , 由于这一位是不能产生进位的, 所以选取的另一个数中这一位上只能为 $0$ , 同时这样也限制了低位上是不能出现进位的, 所以这一二元组只能为 $(10000, 0)$ , 但这一情况是不合法的(出现了 $0$), 则选取的数字第一位上只能为 $0$ , 那么这一位上的 $1$ 是由第三位进上来的, 那么不能进位的第二位也只能为 $0$ 了, 对于第三位, 所能选取的数字为 $0 \sim 9$ , 不难发现, 当第五位上的数不会进位的时候, 第三位上的数可以取 $1 \sim 9$, 此时的二元组为 $(100, 900), (200, 800), \dots, (900, 100)$. 当第五位上的数字进位的时候, 这一位上的数可以取 $0 \sim 9$, 此时对于第五位上可以取的数字为 $1 \sim 9$ , 对应二元组太多了就不再罗列了.

这样可以算出可行的方案数为 $9 + 10 \times 9 = 99$ , 而数位 dp 即是模拟了这个过程, 统计可能的方案数.

数位 dp , 首先要维护的是当前的位数, 即第 $i$ 位, 由高位向低位 dp , 在每一位上处理进位情况.

这个题目要求的是在高两位的位置上进一, 其实对 dp 并没有什么影响, 一并记录下来处理就好了.

然后说一下怎么处理

在每一位上, 维护该位是否需要由低位进位, 这里解释一下, 假设给定的数中这一位上的数字为 $x$ , 如果这一位需要由低位进位, 则二元组中这一位上的两数相加的和应为 $x - 1$ , 或者 $x + 10 - 1$ , 即是两数相加再加上由低两位的位置进上来的 $1$ , 得到要求的数字.

然后处理这一位的时候还需要考虑这一位是否需要向高两位的位置进位, 这决定了这一位需要的结果是 $x$ , 还是 $x + 10$. 由于是从高位向低位处理的, 所以处理到当前位的时候, 高两位的位置上是否需要进位这一情况在当前状态下是确定的, 那么可以在处理那一位的时候将是否进位记录下来, 方便当前位的处理, 但是跨位记录不太方便, 所以相应的记录上一位, 以及上上位是否需要进位, 这样转移也比较容易了.

那么如何判断这一位上是否需要由低位进位呢?

在当前位上枚举这一位可能的数字, 记为 $y$ , 同时对应的计算出二元组中另一个在这一位上的数字, 记为 $z$ , $y + z$ 得到的就是这一位上要求的数字了, 那么这一位需要进位即为 $y + z = x + 1$ 或 $y + z = x + 1 + 10$ , 不需要进位即为 $y + z = x$ 或 $y + z = x + 10$ , 这里不再展开了.

这样就可以枚举当前位的数字进行转移了.

当成功找到一个可行的数时记录答案就好了.

具体的细节问题看代码吧, 感觉说的比较详细了...

---

补充一下: 

考虑的二元组是有序的, 即 $(x, y)$ 与 $(y, x)$ 在 $x \ne y$ 的时候是不同的, 所以只考虑对第一项计数就好了.

dp 的过程中对于 $(0, n)$ 和 $(n, 0)$ 这两个并没有特殊判断, 所以在最后的答案中要减掉.





---

代码

```cpp
/*
  Source: CF C. Carrying Conundrum
*/
#include<cstdio>
#include<cstring>
#define pn putchar('\n')
/*----------------------------------------------------------*/
int T, n, li[20], f[12][2][2];
/*----------------------------------------------------------*/
inline int read() {
	int x = 0, f = 1; char ch = getchar();
	while(ch < '0' || ch > '9') {if(ch == '-') f = -1; ch = getchar();}
	while(ch >= '0' && ch <= '9') {x = (x << 3) + (x << 1) + (ch ^ 48); ch = getchar();}
	return x * f;
}
void Print(int x) {if(x < 0) putchar('-'), x = -x; if(x > 9) Print(x / 10); putchar(x % 10 ^ 48);}
/*----------------------------------------------------------*/
int dfs(int i, int last2, int last1) {
	if(!i) return 1; int res = 0;
	if(~f[i][last2][last1]) return f[i][last2][last1];
	if(last2)
	{
		for(int j = 0; j ^ 10; ++j)
		{
			if(li[i] + 10 - j >= 1 && li[i] + 10 - j <= 9)
				res += dfs(i - 1, last1, 0);
			if(i > 2 && li[i] + 9 - j >= 0 && li[i] + 9 - j <= 9)
				res += dfs(i - 1, last1, 1);
		}
	}
	else
	{
		for(int j = 0; j ^ 10; ++j)
		{
			if(li[i] - j >= 0 && li[i] - j <= 9)
				res += dfs(i - 1, last1, 0);
			if(i > 2 && li[i] - j - 1 >= 0 && li[i] - j - 1 <= 9)
				res += dfs(i - 1, last1, 1);
		}
	}
	return f[i][last2][last1] = res;
}
int solve(int x) {
	int cnt = 0; memset(li, 0, sizeof li); memset(f, -1, sizeof f);
	while(x) li[++cnt] = x % 10, x /= 10;
	return dfs(cnt, 0, 0);
}
void work() {
	n = read();
	Print(solve(n) - 2); pn;
}
void Main() {
	T = read(); while(T--) work();
}
/*----------------------------------------------------------*/
signed main() {Main(); return 0;}

```



---