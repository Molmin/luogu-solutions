# 【数学】【CF1316C】Primitive Primes

## Description

- 给定两个序列 $a$ 和 $b$，其中序列 $a$ 的长度为 $n$，序列 $b$ 的长度为 $m$。
- 分别保证序列中所有数字的最大公约数为 $1$。即 $\gcd(a_0, a_1 \dots a_{n - 1}) = 1$，$\gcd(b_0, b_1, \dots b_{m - 1}) = 1$。
- 设 $a$ 与 $b$ 卷积的结果为序列 $c$。即 $c_k = \sum\limits_{0 \leq i \leq k \land i < n \land k - i < m } a_i \times b_{k - i}$。
- 给出一个 **质数** $p$，请你求出一个下标 $t$，满足 $c_t$ **不能**被 $p$ 整除。如果有多个满足要求的 $t$，请任意输出一个。
- $1 \leq n, m \leq 10^6$，$1 \leq p, a_i, b_i \leq 10^9$。

## Solution

~~事实证明做不出题的时候去个洗手间冷静一下有助于开拓思路~~。

为了简化叙述，约定一个数 $x$ “符合要求”指 $x$ 不是 $p$ 的倍数，即 $p \not\mid x$；而一个数 $x$ “不符合要求”指 $x$ 是 $p$ 的倍数，即 $p \mid x$。请注意符合要求是指符合**题目要求**的**不能**被 $p$ 整除。

首先考虑 $c_0$，若 $a_0$ 与 $b_0$ 均不是 $p$ 的倍数，由于 $p$ 是一个质数，所以 $a_0 \times b_0$ 一定不是 $p$ 的倍数。因此直接输出 $0$ 即可。

换句话说，若 $c_0$ 不符合要求，则 $a_0$ 与 $b_0$ 至少有一个数存在质因子 $p$。现在分情况讨论。

1. 两数中有且仅有一个数存在质因子 $p$，不妨设这个数为 $a_0$。现在考虑 $c_1 = a_0 \times b_1 + a_1 \times b_0$。若 $c_1$ 也不符合要求，由于 $a_0$ 是 $p$ 的倍数，则 $a_1 \times b_0$ 也需要是 $p$ 的倍数。又因为 $b_0$ 不是 $p$ 的倍数，所以 $a_1$ 一定也是 $p$ 的倍数。

   对 $a_i$ 进行数学归纳可以证明，这种情况下，若 $a_0$ 到 $a_{k - 1}$ 都是 $p$ 的倍数，且 $b_0$ 不是 $p$ 的倍数，则 $c_k$ 符合要求当且仅当 $a_k$ 不是 $p$ 的倍数。

   由于保证了 $a$ 序列中所有数字的最大公约数为 $1$，所以一定存在一个 $k$，满足 $a_k$ 不是 $p$ 的倍数，此时输出 $k$ 即可。

2. 两数均是 $p$ 的倍数。设答案为 $t$，这种情况下我们注意到 $a_0$ 会乘上 $b_t$，$a_t$ 会乘上 $b_0$，而这两项模 $p$ 的结果都是 $0$，即他们对 $c_k$ 是没有贡献的，因此我们不管这两项，从第 $1$ 项开始按照上述方法重新讨论即可。

更一般的，设 $a$ 与 $b$ 的前 $(i - 1)$ 项都是 $p$ 的倍数，分三种情况讨论：

1. 若第 $i$ 项均不是 $p$ 的倍数，则令 $a_i$ 与 $b_i$ 卷在一起的一项为答案即可，即输出 $i + i$。
2. 若有且仅有一个序列的第 $i$ 项是 $p$ 的倍数，不妨设为 $a$ 序列，则向后找到 $a$ 序列的第一个不是 $p$ 的倍数的位置 $j$，我们要令 $a_j$ 与 $b_i$ 卷在一起的一项为答案，因此输出 $i + j$ 即可。
3. 否则两序列的前 $i$ 项均为 $p$ 的倍数，迭代考虑第 $(i + 1)$ 项即可。

## Code

代码中数列下标是从 $1$ 开始的，因此输出时要 $-2$。

```cpp
const int maxn = 1000006;
 
int n, m, p;
int A[maxn], B[maxn];
 
int main() {
  freopen("1.in", "r", stdin);
  qr(n); qr(m); qr(p);
  for (int i = 1; i <= n; ++i) {
    qr(A[i]);
  }
  for (int j = 1; j <= m; ++j) {
    qr(B[j]);
  }
  int *a = A, *b = B;
  for (int i = 1; ; ++i) {
    if ((a[i] % p) > (b[i] % p)) std::swap(a, b);
    if ((a[i] % p) == 0) {
      if ((b[i] % p) != 0) {
        for (int j = i + 1; ;++j) if ((a[j] % p) != 0) {
          printf("%d\n", j + i - 2);
          return 0;
        }
      }
    } else {
      printf("%d\n", i + i - 2);
      return 0;
    }
  }
  return 0;
```



   