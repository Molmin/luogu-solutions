大佬们都太厉害了...公式推的很简洁。

不过由于我一开始看卡特兰数的证明就不是这个版本，所以就在这里分享另一个证明（不知是不是殊途同归）。

首先，我们去除那个有关前缀的条件。考虑将$n$个1和$m$个0随意放置的总方案数，我们只要在$n+m$个位置中选出$m$个放0，其余放1即可，所以总方案数为：
$$S_1=C_{n+m}^m$$
然后我们再统计出不符合要求的方案数，减一减就可以了。

首先思考不符合要求是什么情况，也就是存在某个前缀使得0的个数多与1的个数。而且因为0的个数在每一位只会增加1，所以一定存在这样一个临界位置$2p+1$，使得在区间$[1,2p+1]$中恰好有$p$个1和$p+1$个0，也就是0正好比1多一个。（似乎就是对应了大佬们题解里的那条直线）

下面就是重点，我们将$[2p+2,n+m]$这个区间（也就是后半部分）里的所有01全部取反，那么由于前半部分有$p$个1，所以后半部分就有$n-p$个1，取反后就变成了$n-p$个0，再加上前面的$p+1$个0，总共是$n+1$个0。

同样，前半部分有$p+1$个0，所以后半部分有$m-p-1$个0，取反后就变成了$m-p-1$个1，再加上前半部分的$p$个1，总共$m-1$个1。因此将后半部分取反后我们得到了一个含有$n+1$个0和$m-1$个1的序列。而这样的序列的个数是很容易算的，在$n+m$个位置中选$m-1$个放1，其余放0：
$$S_2=C_{n+m}^{m-1}$$
这是不符合要求的方案数，那么符合要求的就是：
$$S_1-S_2=C_{n+m}^m-C_{n+m}^{m-1}$$
注意求一下阶乘的乘法逆元，然后直接用结论计算即可。

```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
const int MAXN=2000010,P=20100403;
ll n,m,fac[MAXN],inv[MAXN];
ll qpow (ll a,ll b) {
    ll res=1;
    while (b) {
        if (b&1) {
            res=(res*a)%P;
        }
        a=(a*a)%P;
        b>>=1;
    }
    return res;
}
void init () {
    fac[0]=1;
    for (int i=1;i<=MAXN-10;i++) {
        fac[i]=(fac[i-1]*i)%P;
    }
    inv[MAXN-10]=qpow(fac[MAXN-10],P-2);
    for (int i=MAXN-11;i>=1;i--) {
        inv[i]=(inv[i+1]*(i+1))%P;
    }
    return;
}
ll solve (int n,int m) {
    return (((fac[n]*inv[m])%P)*inv[n-m])%P;
}
int main () {
    init();
    scanf("%d%d",&n,&m);
    printf("%d",(solve(n+m,m)-solve(n+m,m-1)+P)%P);
    return 0;
}
```
