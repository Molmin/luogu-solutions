##卡特兰数


###扩展(折线原理)


对于在n位的2进制中，有m个0，其余为1的catalan数为：C（n,m）-C(n,m-1)。证明可以参考标准catalan数的证明。


问题1


描述：有n个1和m个-1（n>m），共n+m个数排成一列，满足对所有0<=k<=n+m的前k个数的部分和Sk > 0的排列数。 问题等价为在一个格点阵列中，从（0，0）点走到（n，m）点且不经过对角线x==y的方法数（x > y）。


考虑情况I：第一步走到（0，1），这样从（0，1）走到（n，m）无论如何也要经过x==y的点，这样的方法数为(( n+m-1,m-1 ));


考虑情况II：第一步走到（1，0），又有两种可能：




a . 不经过x==y的点；（所要求的情况）

b . 经过x==y的点，我们构造情况II.b和情况I的一一映射，说明II.b和I的方法数是一样的。设第一次经过x==y的点是（x1，y1），将（0，0）到（x1，y1）的路径沿对角线翻折，于是唯一对应情况I的一种路径；对于情况I的一条路径，假设其与对角线的第一个焦点是（x2，y2），将（0，0）和（x2，y2）之间的路径沿对角线翻折，唯一对应情况II.b的一条路径。

问题的解就是总的路径数 ((n+m, m)) - 情况I的路径数 - 情况II.b的路径数。

\* ((n+m , m)) - 2((n+m-1, m-1)) 或： ((n+m-1 , m)) - ((n+m-1 , m-1))**


问题2


描述：有n个1和m个-1（n>=m），共n+m个数排成一列，满足对所有0<=k<=n+m的前k个数的部分和Sk >= 0的排列数。


（和问题1不同之处在于此处部分和可以为0，这也是更常见的情况）


问题等价为在一个格点阵列中，从（0，0）点走到（n，m）点且不穿过对角线x==y的方法数（可以走到x==y的点）。


把（n，m）点变换到（n+1，m）点，问题变成了问题1。


方法数为：

((n+m+1, m)) - 2\*((n+m+1-1, m-1)) 

或：((n+m+1-1, m)) - ((n+m+1-1, m-1))


从上述中，可知本题的求解。

建一个n\*m的二维坐标系 1为向右 0为向上 若折线的路径的总数为A=C（n+m，m）或A=C（n+m，n）。

其中经过了直线 y=x（不包括恰在线上）的路径为不合法的。

由折线原理问题1,2 。 可以以y=x+1为对称轴找（0,0）的对称点 （-1,1） 可知 从此点出发到（n,m）的路径为所有不合法的。

所以B=C（n+1+m-1，n+1）或B=C（n+1+m-1，m-1）；即为B=C（n+m，n+1）或B=C（n+m，m-1）。

则ans=（A-B）%20100403；


然而n，m范围很大，因为有分母 边乘边取模是不正确的。

设分母为fm 分子为fz，fm的逆元为ny p=20100403

则 （ny\*fm）%p==1

（fz/fm）%p==（fz\*（pow(fm,-1)））%p;

即（fz\*ny）%p；


所以，在分母求一个逆元即可；


```cpp
#include <iostream>
using namespace std;
#define p 20100403
#define ll long long
ll q,n,m;
ll ans,fz=1,fm=1;
ll gcd(ll a,ll b,ll &gd,ll &x,ll &y)
{
    if(!b)  x=1,y=0,gd=a;
    else    gcd(b,a%b,gd,y,x),y-=x*(a/b);
}
ll work(ll a,ll b)
{
    ll gd,x,y;
    gcd(a,b,gd,x,y);
    if(gd==1)
        return (x+b)%b;
    //else return -1;//某犇的写法  但注释掉没影响
}
int main()
{
    cin>>n>>m;
    fz=n-m+1;
    fm=n+1;
    for(int i=n+1;i<=n+m;i++)
        fz=((fz%p)*(i%p))%p;
    for(int i=2;i<=m;i++)
        fm=((fm%p)*(i%p))%p;
    ll ny=work(fm,p);
    ans=(ny*fz)%p;
    cout<<ans<<endl;
    return 0;
}
```