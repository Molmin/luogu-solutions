# 生成字符串解题报告

- ## 本题解为了讲的更加通俗，在叙述上可能会有些繁琐orz


首先我们分析一下题目要求：

- 用n个1和m和0组成字符串，且截至到任意位置，1的个数一定大于等于0的个数。

我们考虑建立一个平面直角坐标系，x坐标轴表示1和0的个数和，y坐标轴表示1和0的个数差。

因此只要选一个新的数字，就是向右走。

- 选择0就是向右下（1的个数减去0的个数变少了一个），

- 选择1就是向右上走（1的个数减去0的个数增加）。

由于直接求合法方案数比较困难，所以先求出全部方案数再减去不合法方案数。

- 全部方案数：从(0,0)点走到(n+m,n-m)点的个数。

	即选择了全部n+m个数字，1的个数比0的个数恰好多了n-m个。
	
    等同于从n+m个数中选择了n个1，方案数位C(n+m,n)或C(n+m,m)。

- 不合法方案数，

	任意一点的 1个数减0个数 小于零，即经过 y=-1 这条线的情况全部不合法。
    
    利用**等效替代法**：

	我们把不合法的情况在经过 y=-1 这条线之前的线以 y=-1 为对称轴向下翻折。
    
    起点就变成了 (0,-2)，终点仍然是 (n+m,n-m)。

	再沿y轴向上平移2个单位，即从(0,0)走到(n+m,n-m+2)，
    
	设选择x个1，y个0，那么x+y=n+m，x-y=n+m-2。两式相加解得x=n+1。
    
	即选择n+1个1，m-1个0。

　　故不合法方案数等于C(n+m,n+1)。

	答案即  C(n+m,n) - C(n+m,n+1)。

---
## 代码如下

```cpp
const int p=20100403;
int n,m;
const int N=1e6+5;
ll jc[N<<1];

inline ll ksm(ll a,ll b)
{
    ll ans=1;
    while(b)
    {
        if(b&1) ans=(ans*a)%p;
        a=(a*a)%p;
        b>>=1;
    }
    return ans;
}

inline ll C(int a,int b)
{
    return jc[a]*ksm(jc[a-b]*jc[b]%p,p-2)%p;
}

int main()
{
    scanf("%d%d",&n,&m);
    jc[1]=1;
    for(int i=2;i<=m+n;i++)
    {
        jc[i]=jc[i-1]*i%p;
    }
    cout<<(C(n+m,m)-C(n+m,m-1)+p)%p;
}
```