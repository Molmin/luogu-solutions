## 题目大意

有一个完整的圆形披萨，被分成了 $n$ 小块扇形，给定每一小块的圆心角度数。把整个披萨沿着切割线分成连续的两块，使得两个扇形圆心角度数之差最小，求这个最小值。


------------
## 解决问题

~~蓝题大恶评，建议降红！~~

题目说白了就是把有 $n$ 个数的环断成两截，使两截数字之和的差距最小。由于这 $n$ 个数之和一定是 $360$，我们只用设出其中一截数的和，就能表示另一截。设其中一截数的和为 $x$，则另一截的和为 $360-x$。两截的差距便是 $|360-2x|$，化简一下就是 $2\times|180-x|$。不难看出，要使这个值最小，我们要使其中一截数之和尽可能接近 $180$。问题转换成从这个环中取一段数，使这一段数的和尽可能接近 $180$。

首先是最暴力的做法：枚举断点，断环为链。对于每一种断法，找到权值和最接近 $180$ 的子段。太慢了！

受环形dp启发，我们把环看作是一条从 $1$ 到 $n$ 的链，再把这条链复制一遍接到后面，考虑这条长度为 $2n$ 的新链中所有长度不超过 $n$ 的子段即可。再加一个前缀和优化，跑得很快。


------------
## 上代码
```
#include<bits/stdc++.h>
using namespace std;
int a[1000];
int s[1000];
int main(){
	int n;
	cin>>n;
	int i,j;
	for(i=1;i<=n;i++){
		cin>>a[i];
		a[i+n]=a[i];
	}
	for(i=1;i<=2*n;i++)
		s[i]=s[i-1]+a[i];//预处理前缀和 
	int ans=99999;
	for(i=1;i<=n;i++)//枚举当前子段长度 
		for(j=1;j+i-1<=2*n;j++)//枚举当前长度下可能的起点，即子段的终点不超过2n
			ans=min(ans,abs(s[i+j-1]-s[j-1]-180));//两个前缀和做差，求得中间一段，再减去180，更新ans
	/*现在我们得到的ans便是题解中说的|180-x|的最小值*/
	/*由于要求的是|360-2x|,输出ans*2即可*/
	cout<<ans*2;
	return 0;
}
```
