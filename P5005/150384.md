让我们来用 35 行代码 A 掉此题。
# 题目分析
首先数据范围 $X \le 100,Y \le 6$ 提醒我们，这题用状压 dp。

然后又发现前两行摆马的状况会影响当前行的局面的合法性，所以我们要枚举前三行摆马的状况。

所以我们设计状态 $dp_{i,j,k}$ 表示第 $i$ 行局面为 $j$，第 $i-1$ 行局面为 $k$ 的方案数。

其中 $j,k$ 均是二进制的表示，比如下图：
![](https://cdn.luogu.com.cn/upload/image_hosting/jlv6naiu.png)
这一行就可以表示为二进制的 $101001$，即十进制的 $41$。

所以我们的状态转移方程就是：
$$ dp_{i,j,k}=sum(dp_{i-1,k,l})$$
其中 j,k,l 需要满足组成的局面中的马互不侵犯。

所以最后的答案就是

$$\sum^s_{i=0}\sum^s_{j=0}dp_{x,i,j}$$

其中 s 是这一行的所有方案。

然而我们空间只给了我们 1MB，而 dp 数组开满需要
$$100 \times 64 \times 64 \times 2B= 819200B = 800KB$$
其他所需的内存加起来就 MLE 了，所以就有了题目背景上的话。发现第 i 行的状态转移只需要 i-1 行的状态，所以用滚动数组优化就可以了。

打个不太恰当的比喻。就像你在机房里，发现电脑不够了，还正好有人在大摆，你就可以跟老师举报他把他赶出去，你就可以用他的电脑了，不过数据要清一下 ~~，否则就成JC了~~。

具体看代码：
```cpp#include<bits/stdc++.h>
using namespace std;
#define MOD 1000000007
int x,y,s,dp[3][65][65],ans;
int main()
{
	scanf("%d%d",&x,&y);
	if(x==1)//特判
	{
		printf("%d",1<<y);
		return 0;
	}
	for(int i=2;i<=x;++i)//枚举所有行
	{
		for(int j=0;j<(1<<y);++j)//枚举当前行
			for(int k=0;k<(1<<y);++k)//枚举上一行
			{
				dp[i&1][j][k]=0;//由于是滚动数组，在用前一定要清零
				if(#)//前两行是否合法
				{
					if(i==2)
						dp[0][j][k]=1;//只有两行且是我们枚举的两行
					else
						for(int l=0;l<(1<<y);++l)//枚举上上行
							if(#)//此行和上上行是否合法
								dp[i&1][j][k]=(dp[i&1][j][k]+dp[(i&1)^1][k][l])%MOD;//统计答案
				}
			}
	}
	for(int i=0;i<1<<y;++i)
		for(int j=0;j<1<<y;++j)
			ans=(ans+dp[x&1][i][j])%MOD;//统计答案
	printf("%d",ans);//输出解
	return 0;
}
```
到这里就结束了？

不。代码中有两段代码被用 # 代替了，这里是我用来判断合法性的，它们才是这篇题解的重点。
# 公式推导
由于我们的状态是用二进制表示的，所以先了解几个位运算符和逻辑运算符，以便公式表达：

（由于每行只有 y 个位置，所以我们的表示状态的数也只需 y 个二进制位。下面的例子中 y 为 5。0b 开头的数字表示二进制数。）

- & 按位与：双目运算符，若两个数中的对应二进制位均为 1，则答案中的对应二进制位为 1，否则为 0。如 `0b10011 & 0b10110 = 0b10010`。

- | 按位或：双目运算符，若两个数中的对应二进制位均为 0，则答案中的对应二进制位为 0，否则为 1。如 `0b10011 | 0b10110 = 0b10111`。

- ^ 按位异或：双目运算符，若两个数中的对应二进制位相同，则答案中的对应二进制位为 0，否则为 1。如 `0b10011 ^ 0b10110 = 0b00101`。

- ~ 按位取反：单目运算符，把每个二进制位中的 0 变成 1，1 变成 0。如 `~ 0b10011 = 0b01100`。

- \<< 左移：双目运算符，把全部二进制位左移，不够的补0。如 `0b10011 << 2 = 0b01100`。

- \>> 右移：双目运算符，把全部二进制位右移，不够的补0，如 `0b10011 >> 2 = 0b00100`。

- && 逻辑与：双目运算符，若两个数均为 `true`，则答案为 `true`，否则为 `false`。

- || 逻辑与：双目运算符，若两个数均为 false，则答案为 `true`，否则为 `false`。

- ! 逻辑非：单目运算符，若此数为 `true`，则答案为 `false`，否则为 `true`。

~~不懂就百度吧。~~

注意在 C++ 里，`true` 为 1，`false` 为 0，而所有非 0 数会被当成 `true`，0 则会被当成 `false`。

而位运算符和逻辑运算符的运算顺序十分玄学，所以建议在每个运算外面加上括号以防万一。~~打过线段树的应该知道吧。~~

---
先看第一个 #，即判断本行为 j，上一行为 k 表达的状态互相之间是否合法。

要是没有蹩马脚限制的话，我们可以将 k 分别左移和右移两位，与 j 做按位与，若得到答案非 0 则发生冲突。

但是此题有蹩马脚限制，所以我们要对 j 做预处理，把蹩了马脚的位变成 0。

怎么预处理呢？

以 k 右移时为例，发现每次蹩马脚的子总在 j 右边，所以把 j 右移一位来移动到每个子所蹩到的子的对应位置上。

让我们画一张真值表：
j|j>>1|~(j>>1)|ans
:-:|:-:|:-:|:-:
0|0|1|0
0|1|0|0
1|0|1|1
1|1|0|0
ans 是处理完的 j。

你应该发现了：`ans=j&(~(j>>1))`

所以 k 右移时的完整判断就是`((j&(~(j>>1)))&(k>>2))`。返回非 0 值则冲突。

k 左移时呢？预处理时把 j 左移就行了。

注意此判断对 j,k 来说不对称，所以还要把 j,k 互换再判断一次。

第一个 # 处完整代码：

`!(((j&(~(j>>1)))&(k>>2))||((j&(~(j<<1)))&(k<<2))||(((k&(~(k>>1)))&(j>>2)))||((k&(~(k<<1)))&(j<<2)))`

我这里用了一个衡等式：`((!a)&&(!b))=!(a||b)`，来让式子改起来更快。

---
第二个 # 处和用来判断此行为 j，上一行为 k，上上行为 l 的情况是否合法，即 j,l 是否冲突。
为什么不判断 k,l 是否冲突呢？因为 k,l 冲突时 $dp_{i,k,l}$ 为 0，统不统计到答案无所谓。

其实判断 j,l 是否冲突和判断 j,k 是否冲突差不多。较大的区别就是蹩 j 马脚的不是 `j<<1` 和 `j>>1` 了，而是 k。

第二个 # 处完整代码：

`!(((j&(~k))&(l>>1))||((j&(~k))&(l<<1))||((l&(~k))&(j>>1))||((l&(~k))&(j<<1)))`

# 最后
完整代码就是把两个 # 处填进去。~~简而言之我懒得放了。~~

相关的状压 dp 题目还有：[炮兵阵地](https://www.luogu.com.cn/problem/P2704)、[玉米田](https://www.luogu.com.cn/problem/P1879)、[互不侵犯](https://www.luogu.com.cn/problem/P1896)、[中国象棋](https://www.luogu.com.cn/problem/P2051)。想~~水经验~~练习状压的可以去练习一下。

完结撒花\\(^o^)/