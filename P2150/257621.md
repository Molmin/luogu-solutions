萌新刚学状压 DP，所写如有不足，还望指出勿喷qwq

------------

### 题目大意

给定 $n-1$ 个正整数 $2,3,4\dots n$ 和两个集合，要将数装进集合中，要求两个集合的元素必须两两互质，求集合装数的总方案数。

------------

### 算法选择

都说这道题是状压 DP，那么问题来了，为什么是状压 DP 呢？

~~标签上写了~~

第一点是因为要求总方案数，DP 显然是不二选择。


第二点肯定是由于数据范围。观察到数据范围中 $n\le 500$，好像并不大，$500$ 以内质数个数有限，状压 DP 貌似可做。

第三点是如果考虑将盒子内的质数压成一个二进制状态，那么判断盒子内元素是否冲突只需要运用逻辑与运算即可，简单便捷。

所以，我们就使用状压 DP 做本题啦！

-----------

### 做法浅谈

#### 设计 dp 数组

既然确定是状压 DP，并且是要求方案数，那么 dp 数组当然就很好想了。考虑采用一般状压 DP 【处理到的地方】+【状态】的状态设计方式，我们可以用 $dp_{i,S,T}$ 表示当处理到前 $i$ 个数时，第一个集合状态为 $S$，第二个集合状态为 $T$ 时的总方案数。

又由于当我们处理到第 $i$ 个数字时，关于前 $i-1$ 个数字的状态是没有用的，所以我们可以采用滚动数组的方式，省去第一维。所以最终的状态设计为：
$$dp_{S,T}$$

#### 考虑转移

由于我们已经决定将每一个集合表示成一个二进制状态，所以我们的第一个想法肯定是用这个二进制状态的第 $i$ 位来表示这个集合中是否存在第 $i$ 个质数。

但是当查到 $500$ 以内的质数有 $95$ 个的时候，我便放弃了这个念头。

那怎么办呢？

考虑到一个关于质因子的性质：一个数的质因子最多只能有一个大于自己的算术平方根。（废话，有两个乘积就不是它了）所以我们可以考虑将所有的数按照大于算数平方根质因子（以下简称大质因子）分组。

对于相同大质因子的数，我们将 $dp$ 数组分成两个，分别表示只放入第一个集合和只放入第二个集合，并且分别进行 DP，这样才能保证这些数要不进第一个集合，要不进第二个集合，要不都不进，不会存在两个集合含有同样大质因子的数的情况。如此以来，我们就只关心小质因子的放入情况了，所以每一个状态只需要 $8$ 位（$500$ 的算术平方根为 $22$，其中只有 $8$ 个质数）即可。

每一组的数 DP 完之后，我们将两个 $dp$ 数组合到一块即可。处理贡献是由于这两个数组都还有原式数组的答案，所以需要再减去一个原式数组的答案，即：

```cpp
for (ll j=0;j<=255;j++)
	for (ll k=0;k<=255;k++){//枚举两个集合的状态
		if (j&k) continue;//两个集合不能冲突
		dp[j][k]=(dp1[j][k]+dp2[j][k]-dp[j][k]+p)%p;//处理贡献
}
```


那么对于分开的每一个 $dp$ 数组具体怎么转移呢？

很简单，设我们用 $dp1$ 数组代表只放入第二个集合的 $dp$ 数组，那么只要当前的数的质因子状态不和第一个集合冲突，我们都可以将放入该数后的 $dp1$ 数组加上原数组所做的贡献。$dp2$ 数组同理。

#### 统计答案

最后我们将 $dp$ 数组所有的合法状态相加即为答案。

注意方案数过多，记得开 `long long`。



------------


### 无注释 AC 代码

本题代码部分参考了题解中的代码，如觉结构相似，请勿责怪，思路第一，代码次之。

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
#define N 505
ll n,p,dp[N][N],dp1[N][N],dp2[N][N],zhi[9]={2,3,5,7,11,13,17,19};
struct node{
	ll b,S,w;
}s[N];
ll read() {
	ll w=0,f=1;
	char c=getchar();
	while (c>'9'||c<'0') {
		if (c=='-') f=-1;
		c=getchar();
	}
	while (c>='0'&&c<='9') {
		w=(w<<3)+(w<<1)+(c^48);
		c=getchar();
	}
	return w*f;
}
void query(ll x){
	s[x].w=x;
	ll xx=x;
	for (int i=0;i<8;i++)
		if (xx%zhi[i]==0){
			s[x].S|=(1<<i);
			while (xx%zhi[i]==0) xx/=zhi[i];
		}
	if (xx^1) s[x].b=xx;
} 
bool tmp(node x,node y){
	return x.b<y.b;
}
int main() {
	n=read(),p=read();
	for (int i=2;i<=n;i++) query(i);
	sort(s+2,s+1+n,tmp);
	dp[0][0]=1;
	for (int i=2;i<=n;i++){
		if (s[i].b^s[i-1].b||!s[i].b){
			memcpy(dp1,dp,sizeof(dp));
			memcpy(dp2,dp,sizeof(dp));
		}
		for (ll x=255;x>=0;x--)
			for (ll y=255;y>=0;y--){
				if (x&y) continue;
				if ((s[i].S&x)==0) dp1[x][y|s[i].S]=(dp1[x][y|s[i].S]+dp1[x][y])%p;
				if ((s[i].S&y)==0) dp2[x|s[i].S][y]=(dp2[x|s[i].S][y]+dp2[x][y])%p;
			}
		if (i==n||s[i].b^s[i+1].b||!s[i].b)
			for (ll j=0;j<=255;j++)
				for (ll k=0;k<=255;k++){
					if (j&k) continue;
					dp[j][k]=(dp1[j][k]+dp2[j][k]-dp[j][k]+p)%p;
				}
	}
	ll ans=0;
	for (int i=0;i<=255;i++)
		for (int j=0;j<=255;j++){
			if (i&j) continue;
			ans=(ans+dp[i][j])%p;
		}
	printf("%lld\n",ans);
	return 0;
}
```

**如果对你有一定的帮助，请点个赞支持一下吧qwq**