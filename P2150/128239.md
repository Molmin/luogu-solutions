**UPD 2020/12/4**：看这篇题解好像有些同学在看欸，但是原来是我一年半之前写的博客，难以讲清楚这么难的题目，现在我已经把整篇文章重构了一遍，希望能对你们有所帮助。

## 一、题目

**题意：**

有$[2,n]$一共$n-1$个数，两个人分别取子集$S$和$T$，要求不存在$x\in S,y\in T$，使得$gcd(x,y)\not= 1$

**数据范围：**

对于$30\%$的数据，$2\leq n\leq30$

对于$100\%$的数据，$2\leq n\leq 500$

## 二、解法

**0x01 暴力**

$gcd$ 容易想到用所含的质数是否有交来判断，考虑用一个质数集合表示我们的数集，而且质数在 $n\leq 30$ 的时候也不是很多，那么状压质数集合，设 $dp[j][k]$ 为 $S$ 的质数集合是 $j$，$T$ 的质数集合是 $k$ 的方案数，转移需要保证 $j$ 和 $k$ 永远不交，先把每个数质因数分解以后再做转移。

设新加进来的数的质因数集合为 $s$，那么转移就不难写出了：

$$dp[j|s][k]=dp[j][k]\;\;\; k\&s=0$$

$$dp[j][k]=dp[j][k|s]\;\;\;j\&s=0$$

时间复杂度$O(n\times 2^{10})$，那么就拿到了 $30$ 分的高分！

**0x02 优化**

好，现在我们面对的数据范围是 $n\leq500$，看似这个数据范围是非常恐怖的，$500$ 以内的质数如何状压？

但是你会发现很多质数是特殊的，学过最普通的判断质数方法的同学就知道：大于 $\sqrt n$ （本题是 $22$）的质数至多有一个，这个部分和第一个部分的区别就在这里，不要怕，问题仅仅是__多了这一些特殊的质数__

如何利用这一性质，请记住：__当你发现有题（无关顺序，排序对其无影响）做不动时，排序永远是你最坚强的后盾（无论是 $dp$ 还是贪心，排序可以让 $dp$ 更快）__，现在我们来考虑能否排序？

其实是可以的，我们把这些数__按他们的大质数排序__，那么大质数相同的这些数就__不能放在一起__，而只能放在一边了。可能读者还没有特别激动，但这是一条多么美妙的性质啊！

利用那条性质，我们设 $f_1[j][k]$ 为大质数放 $j$ 一边的方案数，$f_2[j][k]$ 表示大质数放 $k$ 一遍的方案数，不难发现两者的转移是独自进行的，所以用 $\tt 0x01$ 的方法就可以了。但这个状态仅仅对于一段大质数相同的数，过了这一段大质数相同的数之后我们就要干一些事情。

其实就是把 $f_1$ 和 $f_2$ 合并嘛，因为过了这一段之后讨论的就不是这个大质数了，所以就不用管了，合起来进入后面的阶段。在进入这个阶段前假设我们得到的 $dp$ 数组是 $dp’[i][j]$ 那么这个阶段结束过后的 $dp[i][j]$ 就要用 $f_1[j][k]+f_2[j][k]-dp[j][k]$ 来表示了，减掉他不需要多说吧，毕竟他是惟一相同的部分。

总结一下，当你看出大质数时，知道排序是永远滴神就可以做出此题。

**0x03 代码**

以前是照着第一篇题解写的，现在懒得新写一遍了，我有自信我讲清楚了


```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;
#define LL long long
LL read()
{
	LL x=0,flag=1;char c;
	while((c=getchar())<'0' || c>'9') if(c=='-') flag=-1;
	while(c>='0' && c<='9') x=(x<<3)+(x<<1)+(c^48),c=getchar();
	return x*flag;
}
LL n,ans,mod;
LL dp[300][300],f1[300][300],f2[300][300];
int p[10]={0,2,3,5,7,11,13,17,19,0};
struct node
{
	LL val,big,S;
	bool operator < (const node &x) const {
		return big<x.big;
	}
	void init()
	{
		LL tmp=val;big=-1;
		for(LL i=1;i<=8;i++)
		{
			if(tmp%p[i]==0) S|=(1<<i-1);
			while(tmp%p[i]==0)
				tmp/=p[i];
		}
		if(tmp^1) big=tmp;
	}
}a[505];
int main()
{
	n=read();mod=read();
	for(LL i=2;i<=n;i++)
		a[i].val=i,a[i].init();//预处理每个数的质因数集合与它的大质数
	sort(a+2,a+1+n);//把大质数相同的放一起讨论
	dp[0][0]=1;
	for(LL i=2;i<=n;i++)
	{
		if(i==1 || a[i].big^a[i-1].big || a[i].big==-1)//如果都没有大质数或大质数不一样，就可以继承上一层合并的答案。（特判初始化） 
		{
			memcpy(f1,dp,sizeof dp);
			memcpy(f2,dp,sizeof dp);
		}
		for(LL j=255;j>=0;j--)//滚动数组 
			for(LL k=255;k>=0;k--)
			{
				if(j&k) continue;
				if((a[i].S&j)==0) f1[j][k|a[i].S]=(f1[j][k|a[i].S]+f1[j][k])%mod;
				if((a[i].S&k)==0) f2[j|a[i].S][k]=(f2[j|a[i].S][k]+f2[j][k])%mod;
			}
		if(i==n || a[i].big^a[i+1].big || a[i].big==-1)//如果都没有大质数或大质数不一样（跟下一层比较），则可以合并答案（特判结束） 
		{
			for(LL j=0;j<=255;j++)
				for(LL k=0;k<=255;k++)
				{
					if(j&k) continue;
					dp[j][k]=(f1[j][k]+f2[j][k]-dp[j][k]+mod)%mod;//减去重复的情况 
				}
		}
	}
	for(LL i=0;i<=255;i++)//统计答案 
		for(LL j=0;j<=255;j++)
		{
			if(i&j) continue;
			ans=(ans+dp[i][j])%mod;
		}
	printf("%lld\n",ans);
}
```