NO.17 这道题蒟蒻表示并没有想到好的做法（这是一个笨方法，不过十分好理解，有点分治的意思）

既然是要把每个深度不一坑填满，那么每次就选择最长的非零区间，填充这段区间内最小的深度，这样就可以保证至少有一个坑填满了（就是那个深度最小的坑），当然可能会有深度相同的坑同时被填满。

For Example：

 _**题目要求：在选择区间时，需要保证，区间内的每块区域在填充前下陷深度均不为 0**_ 

Step 1：**4 3 2 5 3 5**

选择最长非零区间，即序列本身，最小深度为2（第3个值），将这段区间都减去2，得到如下序列：

**2 1 0 3 1 3**

这时候出现0，以0为分界线，我们先处理左边这段：

Step 1.1：**2 1**

选择最长非零区间，即序列本身，最小深度为1（第2个值），将这段区间都减去1，得到如下序列：

**1 0**

再次出现0，处理**左边**这段——**1**，由于只有一个坑，那么返回值就是1

0**右边这段没有坑**，所以不用管。

Step 1.2:  **3 1 3**

然后再跳回 **3 1 3**这段，按照处理**2 1**同样的方式处理，最后把这些段的加起来即为所求。

通过以上分析，我们可以看出，只要把0存储起来，每次选择两个0之间的那段进行填补，最后就可以把所有的坑填满。

那么这些过程具体是怎么实现的呢？下面我将结合代码（核心函数）进行解释：

通过代码可以看到，我就是把上面的思路模拟了一下。

主函数中调用函数dfs，初始区间是1~n。

------------
首先判断区间是否满足要求

```cpp
if (l<1 || l>n || r<0 || r>n || l > r)
		return 0;
```
------------
然后判断是否只有一个坑（l==r），如果是，直接返回。
```cpp
if (l == r)
	return a[l];
```
------------

需要强调的一点是存储0的方法。这里我用的队列，一定要记得在队列的开始和结尾加上一个0的位置，这是为了处理区间两端出现0的情况。

```cpp
queue<int>Q;
Q.push(l - 1);
for (int j = l; j <= r; j++)
	if (a[j] == 0)
		Q.push(j);
Q.push(r + 1);
```
------------

#### _其余的请看代码~_

```cpp
#include<iostream>
#include<queue>
using namespace std;

int n;
int a[100003];

int dfs(int l,int r)
{
	int ans = 0;
	if (l<1 || l>n || r<0 || r>n || l > r)
		return 0;
	if (l == r)
		return a[l];
	int i = l;
	while (i <= r)
	{
		int min = a[i];
		while (a[i] != 0 && i <= r)
		{
			min = min > a[i] ? a[i] : min;
			i++;
		}
		ans += min;
		for (int j = l; j <= r; j++)
			a[j] -= min;
		queue<int>Q;
		Q.push(l - 1);
		for (int j = l; j <= r; j++)
			if (a[j] == 0)
				Q.push(j);
		Q.push(r + 1);
		while (Q.size() != 1)
		{
			int a = Q.front() + 1;
			Q.pop();
			int b = Q.front() - 1;
			ans += dfs(a, b);
		}
	}
	return ans;
}

int main()
{
	cin >> n;
	for (int i = 1; i <= n; i++)
		cin >> a[i];
	cout << dfs(1, n);
	return 0;
}
```
(◍°∇°◍)ﾉﾞ一次性AC有点激动~٩(๑>◡<๑)۶，ヾ
