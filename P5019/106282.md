春春之所以能做道路工程师，是因为他有一种神奇的水，能够在填满$1$个单位高度的坑后自动形成一段路面。而春春很懒，他只会在$[1]$的位置倒水，而且为了让水有足够的时间来转化，他每天只填一层。

但是，这种方法却是花费时间相对最少的方案，因为春春每次倒水时，水会立刻填满可以到达的最低区间$[L,R]$。

## 让我们借助样例来模拟一下这个过程。
```
1      2      3      4
...... ...... ...... ......
...... ...... ...... ......
..#... **#... **#... **#...
*##.#. *##.#. *##.#. *##*#.
###.#. ###.#. ###*#. ###*#.
```
```
5      6      7      8      9
...... ...... ...... ...... ******
...... ...... ...... ****** ******
**#... **#... **#*** **#*** **#***
*##*#. *##*#* *##*#* *##*#* *##*#*
###*#* ###*#* ###*#* ###*#* ###*#*
```
###### ~~（打字框居然对不齐，对着预览敲得我眼睛疼）~~

这张表里的$.$代表坑，$#$代表原来的路面，$*$代表水。

这样，路就平了。
### 物理知识即可解释这一现象
所以，水会先往低处流，流到比当前最低处高$c$个单位的地方，然后向上爬$c$个单位。当向上爬到顶端又开始下落时，又会跑到另一个坑里。

## 下面的c代码就是这样的模拟。
#### （可读性差，如果没有弄懂我的思路就别看了。直接抄的话识别率很高，请勿抄袭。）
```c
#include<stdio.h>
int read()//快读
{
	int re=0;
	char c=getchar();
	while(c>'9'||c<'0'&&c!='-')c=getchar();
	if(c=='-')
	{
		c=getchar();
		while(c<='9'&&c>='0')
		{
			re=(re<<1)+(re<<3)-'0'+c;
			c=getchar();
		}
		return -re;
	}
	while(c<='9'&&c>='0')
	{
		re=(re<<1)+(re<<3)-'0'+c;
		c=getchar();
	}
	return re;
}
int n,d,lst,c;
int sum,ans;
int main()
{
	n=read();
	while(n--)
	{
		d=read();
		if(d<lst)
		{
			ans+=c=lst-d;
			if(sum)if((sum-=c)<0)sum=0;
		}
		else sum+=d-lst;
		lst=d;
	}
	printf("%d\n",ans+sum);
	return 0;
}//程序结束，AC
```
此时就会有同学发现……
### 咋连个$d[]$数组都没有？？？
# 确实，$d[]$数组还真不需要。
在这样的方法中，对于每个$i$，我们只需要用到$d[i]$和$d[i-1]$即可，前面的一大堆$d[i]$就被我们浪费掉了。既然我们不需要再使用它，那我们就用$d$代替$d[i]$、用$lst$代替$d[i-1]$好了。于是对于热衷卡常的同学而言，就可以把所有变量设为$register$。

况且……
## 假如连个$n$都不给怎么办？
### 代码如下（别试，直接交没法A）
```c
#include<stdio.h>
int d,lst,c;
int sum,ans;
int main()
{
	while(scanf("%d",&d))//scanf()返回读入成功的变量的个数。
	{
		if(d<lst)
		{
			ans+=c=lst-d;
			if(sum)if((sum-=c)<0)sum=0;
		}
		else sum+=d-lst;
		lst=d;
	}
	printf("%d\n",ans+sum);
	return 0;
}
```
这时，舍弃数组的优势就体现得淋漓尽致了。

## 总结一下，这篇题解讲述了：
+ #### 基于递推的$c/cpp$代码实现
+ ### 对$d[]$数组实行降维打击（在我$P1802$的题解里也有）
+ ##### 抛弃$n$（次要）

# 下半年就要$NOIP$了，祝大家取得佳绩，也祝洛谷越办越好！