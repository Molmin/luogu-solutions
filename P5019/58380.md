### 由于这道题数据范围<=100000	所以很多人离线用nlogn的数据结构维护
#### 包括我考场上有是这木想的，虽然谢瓜了

### 其实当你一眼就可以看出来可以离线分块暴力的并且利用数据结构维护的时候为甚不想想在线解决会不会更简单呢？

### 很容易发现这道题你只用维护答案，不需要考虑方案，而且有同志可能在写暴力的时候发现要维护每个元素向左向右拓展的最长区间（你要贪心最优解，肯定要知道最小值是哪个区间的）

# 现在我们不妨先来考虑坑的深度单调递减的特殊情况
## 4 3 2
### 显然后来的只要比原先还小就不用管，因为处理最大值的时候一定可以把后面的坑都填满

## 5 3 来了

### 我们发现处理5的时候可以在处理2时处理深度2，剩下的5只用填5-2=3次

### 而2恰好就是前面已处理的最小的坑的深度 3在处理5是已经被处理了

## 最后的5只用加上5-3=2的费用

### 至此我们用单调栈来维护的轮廓已经出来了


#### 碰到单调递减的元素直接入栈，碰到元素比栈顶元素打大的就把比它小出栈并维护出栈元素的最小值；出栈完成后将该元素入栈并维护答案
### 还有一些细节，注意初始化和出栈时的越界问题

```cpp
#include<cstdio>
#include<iostream>
#define maxn 100010
#define WQD 1000010
using namespace std;
int a[maxn],s[maxn];
int p,_min;
long long ans;
int main()
{
	int n;
	scanf("%d",&n);
	for(int i=1;i<=n;++i) scanf("%d",&a[i]);
	s[++p]=a[1];ans=a[1];
	for(int i=2;i<=n;++i)
	{
		if(a[i]<=s[p])	s[++p]=a[i];
		else{
			_min=WQD;
			while(a[i]>s[p]&&p) {
				_min=min(s[p],_min),
				--p; 
			}
			s[++p]=a[i];
			ans-=_min,ans+=a[i];
		}
	}
	printf("%lld",ans);
	return 0;
} 
```