**题目翻译**：$\texttt{Malvika}$和$\texttt{Akshat}$玩游戏。给出$m$根横棒，$n$根竖棒，交叉摆出$n×m$个交点，两人轮流摆，每次选一个交点，拿走过这个交点的两个棒。最后没得选的人输。输出胜者。

------------
**题目思路**：只用考虑这两个数中较小的哪一个就可以了，因为要选则最优策略，所以如果横棒少，先手就拿横棒；如果竖棒少，先手就拿竖棒。如果少的那个数量是奇数，输出$\texttt{Malvika}$；如果少的那个数量是偶数，输出$\texttt{Akshat}$；

------------
**题目代码**：
```
#include<bits/stdc++.h>
using namespace std;
int main()
{
    int a,b;
    scanf("%d %d",&a,&b);
    printf(min(a,b)&1==1?"Akshat":"Malvika");
    return 0;
}
```
------------
**知识点**：
1. 三目运算符。在代码中，我用了三目运算符，介绍一下。格式：$\texttt{条件?结果A:结果B条件?结果A:结果B}$。   
例如：
```
int ans=a>b?a:b;
```
它等价于
```
int ans;
if(a>b)ans=a;
else if(b>=a) ans=b;
```
2. $\And$运算符。$\And$运算符是与运算符，和它类似的还有$\And$与运算符和$\oplus$异运算符。 

首先，我要澄清一点，那就是，在C++中，任何不是$0$得数都被认为是真的，任何等于$0$的数都是假的。对于这一点，部分人有误区，他们认为负数也是假的，但实际上，任何不等于$0$**都是真的，包括负数**。  
$a.$  $|$的运算规则是：$0|0=0,1|0=1,1|1=1$，其中$0$是指对应假的值，$1$是指对应真的值，但是，如果有负数参加$|$运算，需要先求出它的补码，再进行计算。  

$b.$  $\And$的运算规则是：$0\And0=0,1\And0=0,1\And1=1$，其中$0$是指对应假的值，$1$是指对应真的值。  

另：特殊用法：  

- 清零。  
方法：如果想将一个单元清零,只要与一个各位都为零的数值相与，结果为零。  
- 取一个数中指定位。  
方法：找一个数，对应$\text{X}$要取的位，该数的对应位为“$1$”，其余位为“$0$”，此数与$\text{X}$进行“与运算”可以得到$\text{X}$中的指定位。例如，设$\text{X}=10101110$，取$\text{X}$的低$4$位，用$\text{X}\And 00001111=00001110$即可得到。  

$c.$  $\oplus$的运算规则是：$0\oplus 0=0,1\oplus 0=1,1\oplus 1=0$，其中$0$是指对应假的值，$1$是指对应真的值。   
交换律：$A\oplus B=B\oplus A$  
结合律：$A\oplus B\oplus C=A\oplus (B\oplus C)=(A\oplus B)\oplus C$  
自反律：$A\oplus B\oplus B=A\oplus 0=A$  
另：$A\oplus A=0 ,A\oplus 0=A$  

另：特殊用法：  

- 相异或，保留原值。例如$X\oplus 00000000=10101110$。  
- 使特定位翻转。找一个数，对应$\text{X}$要翻转的各位，该数的对应位为“$1$”，其余位为“$0$”，此数与$\text{X}$对应位异或即可。例如，$\text{X}=10101110$，使$\text{X}$低$4$位翻转，用$\text{X}\oplus 00001111=10100001$即可得到。