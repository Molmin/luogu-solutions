### [区间 DP 的题目 QwQ](https://www.luogu.com.cn/problem/P3205)
  （浅浅的修改了下笔误~~好多~~）
  
  [~~无耻的推销一下我的动态规划笔记~~](https://www.luogu.com.cn/blog/zhuaigezhangzixuan/DP-shi-God)。
  
  本片题解将我的思考过程写了出来，可以帮您更好的学习动态规划的思路过程。
  
  这个题目我第一眼看上去毫无思路，看了题解发现还是很简单的。
  
  思考一下我当初为什么没有思路（大部分初学者都这样吧），因为刚做完板子题目，觉得区间动态规划的 $f_{i,j}$ 就是应该表示 $i$ 到 $j$ 合并的方案数，思维被模板禁锢，就一直在这个思路上去想，去尝试状态转移方程，但是这个题目真正的思路是这个吗？很明显并不是。
  
  思考一下这个题目的状态和什么有关系，当一个人进来的时候他在左或右是根据上一个人的身高来确定的，也就是说，上一个人的身高影响当前人的位置。所以状态数组之中一定要体现出上一个人的身高这一关键信息，如果按照合并石子的思想来做他并不可以表示上一个人的身高。就思考如何让状态方程去记录。
  
  下边一段思考当前人放在队列右边的情况（放在左边的情况是一样的，只不过翻过来，请读者自己思考）。
  
  这里注意，题目中的完美队列是已知固定的，当一个区间的一个人进去所排成的队列的方案数和一个人有关，就是最后进去的那个人，那个人（他的前一个人）有两个人选，一是当前队列最后边那个，二是当前队列最前边那个，所以只要当前人（注意断句，当前人而不是当 前人）比那两个人高新形成的队列的排列方式就是两者之和，如果有一个人（最后入队的那两个人）比他（当前人）高就把这个加数删掉就好了。
  
  思考到这里思路就明了了，想办法表示出从 $i$ 个人到第 $j$ 个人中 $i$ 先入队和 $j$ 先入队的数量，然后枚举区间就可以了。
  
  如何设计方程？
  
  设 $f_{i,j}$ 表示从 $i$ 到 $j$，$j$ 先入队的队列数量，这样就完成了状态数组的设置。状态转移方程呢？
  
  $f_{i,j}=f_{i,j-1} (a_{j-1} < a_j) + f_{j-1,i} (a_i < a_j)$
  
  $f_{j,i}$ 同理，和上边的一样（对于状态转移方程要看完题解之后自己写出来，这个你就自己写吧）。
  
  ~~真不是懒~~因为我觉得做动态规划如果只是单纯的比这题解打下来式子是没有意义的，要理解式子里每个值得意义然后自己推到，自己看着自己的推导打出来。
  
  **最后，做动态规划思路一定要灵活多变，根据题目的条件设置转移数组，之后推导方程。**
  
  ## 代码实现

  不要比着题解写啊，自己推出来然后自己实现。
  
  ```
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=1e3+1,mod=19650827;

int n,a[N],f[N][N];

signed main(){
	cin>>n;
	for(int i=1;i<=n;i++) cin>>a[i],f[i][i]=1;
	for(int len=2;len<=n;len++)
	{
		for(int i=1;i+len-1<=n;i++)
		{
			int j=i+len-1;
			if(a[j-1]<a[j]) f[i][j]+=f[i][j-1];
			if(a[i]<a[j] && len!=2) f[i][j]+=f[j-1][i];
			//为什么要len!=2因为当len==2的时候就是说第一个人从左进来或从右（这样就是两个方案了）但是第一个人明显只有一个方案啊。所以就特判一下，让第一个人只有一个方案 
			f[i][j]%=mod;f[j][i]%=mod;
			if(a[i]<a[i+1]) f[j][i]+=f[j][i+1];
			if(a[i]<a[j] && len!=2) f[j][i]+=f[i+1][j];
			f[i][j]%=mod;f[j][i]%=mod;
		}
	}
	cout<<(f[1][n]+f[n][1])%mod;
}

```

  