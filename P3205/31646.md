这题~~查看题解以后发现~~是区间$DP$

我们发现这个题要求的序列个数很不好求，所以可以做一个转换：求有多少种不同的插入顺序，使得得到理想队形（好像也不太能算是转换，只是换一种更好$DP$的方式表达）.

然后又发现队形的插入过程只能在最左边和最右边插入，所以想到设$f[i][j][0]$表示$i-j$这段区间（指的是在理想队形里的区间）最后进来的是$i$的不同方案数，$f[i][j][0]$表示$i-j$这段区间最后进来的是$j$的不同方案数。

转移特别好写就直接看代码好了，这里主要讲一下这个题的一个比较容易出错的问题——初始化问题。

可以发现在大多数情况下($i\not=j$)，通过$f[i][j][0]$和$f[i][j][1]$得到的队形的插入顺序是一定不同的（因为$f[i][j][0]$最后插入的是$i$，而$f[i][j][1]$最后插入的是$j$），所以可以保证不会重复计数。那么当$i=j$的时候呢？显然只有直接插$i$这一种方案，所以我们初始化$f[i][j][0]=1,f[i][j][1]=0$

最后的答案就是$f[1][n][1]+f[1][n][0]$（最后一个插进来的一定是$1$或者$n$）

代码如下：

```
#include<cstdio>
#include<iostream>
#include<cstring>
#include<algorithm>

using namespace std;

const int N=2009,M=19650827;
int n,f[N][N][2],a[N];

void init()
{
	scanf("%d",&n);
	for (int i=1;i<=n;i++)
		scanf("%d",&a[i]),f[i][i][0]=1;//初始化
}

void add(int &x,int y)
{
	x=(x+y)%M;
}

void work()
{
	for (int k=2;k<=n;k++)
		for (int i=1;i+k-1<=n;i++)
		{
			int j=i+k-1;
            //各种判断然后转移
			if(a[i]<a[i+1])
				add(f[i][j][0],f[i+1][j][0]);
			if(a[i]<a[j])
				add(f[i][j][0],f[i+1][j][1]);
			if(a[j]>a[j-1])
				add(f[i][j][1],f[i][j-1][1]);
			if(a[j]>a[i])
				add(f[i][j][1],f[i][j-1][0]);
		}
	printf("%d\n",(f[1][n][1]+f[1][n][0])%M);
}

int main()
{
	init();
	work();
	return 0;
}

```
