先来看数据范围，$n≤10^5$，显然不可能 $O(n^2)$。

已经有人讲过区间最值了，我来一个 DP 思路的（以下的 $a_i$，$a_j$，$a_k$ 全部取自题意）。

$f_{x,1}$ 表示前 $x$ 个数中 $p×a_i$ 的最大值；

$f_{x,2}$ 表示前 $x$ 个数中 $p×a_i+q×a_j$ 的最大值；

$f_{x,3}$ 表示前 $x$ 个数中 $p×a_i+q×a_j+r×a_k$ 的最大值。

可以推出状态转移方程：

$f_{i,1}=\max(f_{i-1,1},p×a_i)$

$f_{i,2}=\max(f_{i-1,2},f_{i,1}+q×a_i)$

$f_{i,3}=\max(f_{i-1,3},f_{i,2}+r×a_i)$

为什么成立？

拿 $f_{x,1}->f_{x,2}$ 举例，对于 $a_x$，如果不取，显然什么变化也没有；如果取，也就是取 $a_j$ 为 $a_x$，结合 $f_{i,1}$ 的定义此时一定有 $i≤j=x$，符合要求。$f_{x,2}->f_{x,3}$ 同理。

每次遍历一遍数组，复杂度是 $O(n)$。

有两个点提醒：

1.考虑有负数的情况，这时候如果不特判，最大值为 $0$。

2.不开 long long 见祖宗。

```cpp
#include<iostream>
using namespace std;
long long n,p,q,r,a[100001],f[100001][4];
int main(){
    cin>>n>>p>>q>>r;
    for(int i=1;i<=n;i++)cin>>a[i];
    f[1][1]=a[1]*p; //如果有负数 
    for(int i=2;i<=n;i++)
		f[i][1]=max(f[i-1][1],a[i]*p);
	f[1][2]=f[1][1]+a[1]*q; //如果有负数 
    for(int i=2;i<=n;i++)
    	f[i][2]=max(f[i-1][2],f[i][1]+a[i]*q);
    f[1][3]=f[1][2]+a[1]*r; //如果有负数 
	for(int i=2;i<=n;i++)
    	f[i][3]=max(f[i-1][3],f[i][2]+a[i]*r);
    cout<<f[n][3];
    return 0;
}
```
