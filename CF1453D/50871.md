### 题目大意

有若干个点，有的点有重生点，有的点没有。一到达某个重生点，这个点就是当前重生点。玩家从第一个点开始走走到最后一个点，每个点活与死的概率各一半。给定你期望走的点数，请你构造并输出这样的序列（$1$ 表示重生点， $0$ 表示普通点），没有则输出 $-1$。

### 解题思路

对于这种题目，我们可以考虑分而治之的思维。我们不难发现不论前面是怎样的序列，后面只要出现一个 $1$，那么就与前面的情况独立开来了。因此我们可以分两种情况讨论。

#### 单独的 $1$

对于这种情况，我们发现情况很容易想，要么就是活了离开这个点，要么就是总是死而复生。于是其期望走的点数为：

$$E_0 = \frac{1}{2}\times 1+\frac{1}{2^2}\times 2+\cdots +\frac{1}{2^n}\times n+\cdots$$

利用 $2E_1 - E_1$ 很容易得到：

$$E_0 = 1+\dfrac{\dfrac{1}{2}(1-\dfrac{1}{2^{+\infty}})}{\dfrac{1}{2}} = 2$$

这也验证了样例中的 $2$ 的情况。

#### $1$ 后跟 $0$

我们发现，如果 $1$ 后面跟着 $0$，这个事情就复杂了起来。这里我们用数列的眼光看这个序列。我们设 $E_k$ 表示 $1$ 后跟着 $k$ 个 $0$ 所得到的序列走的点数的期望。

假设我们知道了 $E_k$，对于新加入的第 $k+1$ 个 $0$，要么成功经过它，要么总是失败，回到前面的重生点，再走一遍 $k$ 个 $0$ 的情况，再经历一次第 $k+1$ 个 $0$（听起来很惨）。

因此不难想到：对于 $E_{k+1}$ 与 $E_{k}$ 有这样的关系：

$$E_{k+1} = \frac{1}{2}\times (E_k+1)+\frac{1}{2^2}\times 2(E_k+1)+\cdots +\frac{1}{2^n}\times n(E_k+1)+\cdots$$

类似上面操作一下，就得到通项：

$$E_{k+1} = E_k+1+\dfrac{\dfrac{1}{2}(1-\dfrac{1}{2^{+\infty}})}{\dfrac{1}{2}}\times(E_k+1) = 2(E_k+1)$$

因此，最终的构造可以看做是很多 $1$ 和很多 $100\cdots$ 的组合（当然，$1$ 也可以看作是 $1$ 加上 $0$ 个 $0$）。

这里注意，我们发现任意组合都是偶数，所以遇到奇数就可以直接判断不存在了。

#### 一个说明

学过数列的同学知道：我们其实能够求出 $E_k$ 通项。

上式化为：

$$E_{k}+2 = 2(E_{k-1}+2) = 2^k(E_0+2) = 2^{k+2}$$

所以：

$$E_k=2^{k+2}-2$$

但是对于程序设计，这个并做不到阶的优化，~~所以我们一切从懒~~。

不过这个可以帮我们检验，最终构造的序列一定不会超过 $2000$ 个，满足题目要求。

### 程序实现

我们要注意，我们不一定能够用单一的 $100\cdots$ 序列组成答案，所以这就需要迭代求解。也就是对于每次试着增加 $0$ 的操作，我们都判断当前期望是否超过当前值，超过了就退一个 $0$，当前值减去这个期望，结果作为下一次迭代的值继续求解。具体设计如下：

```cpp
#include <cstdio>
#include <iostream>
#include <string>
#include <algorithm>
#include <cmath>

using namespace std;
int ans[2005];
int main()
{
    int T;
    long long k, v, z;
    scanf("%d", &T);
    while(T--)
    {
        int tot = 2000, vas = 0;
        v = 0;
        scanf("%lld", &k);
        z = k;
        if(k & 1)
        {
            printf("-1\n");
            continue;
        }
        do
        {
            v = 0;
            while(z >= v)
            {
                if(v)
                    ans[tot+1] = 0;
                ans[tot] = 1;
                v = 2ll*(v+1ll);
                tot -= 1;
            }
            tot += 1;
            ans[tot]=0;
            ans[tot+1]=1;
            z -= v/2-1;
        }while(z > 0);
        printf("%d\n", 2000-tot);
        for(register int i = tot+1; i<=2000;i+=1)
            printf("%d ", ans[i]);
        puts("");
    }
    return 0;
}

```

### 一点话

经典比赛的时候推不出来，比赛一结束就知道了，哭唧唧，又掉分了。