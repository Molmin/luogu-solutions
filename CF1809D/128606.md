题意：给定一个 $01$ 串，一次可以交换相邻两个字符或删去一个字符。要求让所有 $0$ 在所有 $1$ 前面。最小化操作次数的前提下最小化删除操作的次数。

根据冒泡排序的流程可知，一次交换会使逆序对减一。

考虑每个 $0$，其交换次数为其产生的逆序对个数。那么一旦它产生逆序对大于 $1$，显然删除优于交换。对于 $1$ 也是一样的。

但另一个问题是，删除后可能会影响其它位置的逆序对，这时就可能会导致一个原本该被保留的位置因为操作顺序问题而被删除。

不妨先确定删除哪些元素，然后利用交换将其变为合法。

那么一个很重要的结论是，最优策略中，剩下的序列的逆序对个数至多为 $1$。否则至少会有一个位置产生逆序对大于 $1$，那么这个序列就相当于没删干净。

所以最后剩下的序列只能是两种，`0...0101...1` 或 `0...01...1`。

情况二直接暴力贪就行，接下来考虑情况一。

首先前半的 $0$ 和后半的 $1$ 一定是尽可能保留的，只需要考虑 `10` 是哪两个位置即可。

假设确定的 $1$ 后面有多个 $0$，那么选最近的一定最优。对于 $0$ 而言也一定是选前面最近的 $1$。

由此，这对 $10$ 在原序列中一定相邻，再扫一遍跑贪心就好了。

```
#include<cstdio>
#include<cstring>
#include<algorithm>
const long long inf=1e12;
using namespace std;
int n;
char s[300003];
int main(){
	int i,t;
	scanf("%d",&t);
	while(t--){
		int s0=0,s1=0;
		long long res=1e18;
		scanf("%s",s+1);n=strlen(s+1);
		s[n+1]='0';
		for(i=1;i<=n+1;i++)if(s[i]=='0')s0++;
		for(i=1;i<=n;i++){
			if(s[i]=='1'&&s[i+1]=='0'){
				long long d=0;
				if(i!=n)d+=inf;
				int pl=s1,pr=s0-1;
				if(pr)pr--;
				d+=(pl+pr)*(inf+1);
				if(d<res)res=d;
			}
			if(s[i]=='1')s1++;
			else s0--;
		}
		s1=s0=0;
		for(i=1;i<=n;i++)if(s[i]=='0')s0++;
		for(i=1;i<=n;i++){
			if(s[i]=='1'){
				res=min(res,(inf+1)*(s0+s1));
				s1++;
			}
			else s0--;
			res=min(res,(inf+1)*(s0+s1));
		}
		printf("%lld\n",res);
	}
}
```