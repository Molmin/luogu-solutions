先在 T1 中求出所有点到 $1$ 的距离 $\mathrm{dep1}_x$。用 ST 表预处理出 T1 的 LCA。

把 T2 点分治。求出每一个点到分治根的路径长度 $\mathrm{dep2}_x$。考虑经过当前根节点的路径。

把当前 T2 点分治到的子树的点在 T1 中建立虚树。然后对于 T2 点分治到的点 $x$，我们在虚树中给它拆出一个点 $x'$，从 $x'$ 向 $x$ 连一条长度为 $\mathrm{dep2}_x$ 的边。然后对于虚树上的一条边 $(x,y)$，连一条长度为 T1 中 $x,y$ 距离的边。事实上由于虚树中的相邻的点在 T1 中一定是祖孙关系，所以直接 $\mathrm{dep1}$ 减一下即可。

然后我们从所有拆出来的点 $x'$ 跑最短路，求出虚树上所有点到达最近的 $x'$ 的距离 $\mathrm{dis}$ 和最近的 $x'$ 的编号 $\mathrm{pre}$。接下来枚举虚树上的每一条边 $(x,y)$，向边集 $E$ 中扔一条连接 $\mathrm{pre}_x,\mathrm{pre}_y$，长度为 $\mathrm{dis_x}+\mathrm{dis_y}+d_{x,y}$，其中 $d_{x,y}$ 就是虚树中 $x,y$ 边的长度（也就是 T1 中 $x,y$ 的距离）。

显然我们扔进 $E$ 的边的长度一定不小于实际长度（也就是我们计算的两个点的距离不小于实际上它们在 T1 的距离加上 T2 的距离）。所以我们只需要证明所有最终在最小生成树上的边一定在 $E$ 中且长度一定等于实际长度即可。

考虑最终被连边的两个点 $x,y$，它们一定会同时在某一棵虚树中，且虚树上它们之间路径的 $\mathrm{pre}$ 一定是一段前缀为 $x$，另一段后缀为 $y$，否则假设其路径中有一个点的 $\mathrm{pre}$ 为点 $z$，显然最终的生成树中 $(x,y)$ 没有 $(x,z),(z,y)$ 优。

而且不难发现当分治到的根为 T2 中 $x$ 到 $y$ 的路径时，我们扔进 $E$ 的路径 $(x,y)$ 长度就是正确的。

由于一个大小为 $k$ 的点分树，我们扔进 $E$ 的边数是 $O(k)$ 的，所以最终 $E$ 中的边的数量就会是 $O(n\log n)$ 的，跑 Kruskal 即可。
时间复杂度 $O(n\log^2 n)$。

由于代码有一定长度，请到云剪切板查看：https://www.luogu.com.cn/paste/pawpljpq