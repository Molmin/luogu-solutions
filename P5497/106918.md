# P5497 龟速单项式变换
我一开始看到这道题的时候想到的思路是分类找规律。我把它分为了三类：n<m,n=m,n>m。
## n<m
很显然，这种情况很容易举反例。比如在这个数列a[1]~a[n]是1~n它的和就肯定不是m的倍数。
## n=m
根据等差数列求和公式，（首项+末项）×项数÷2。可以写出这个数列的和是：（a[1]+a[n]）×m÷2，这个式子可以转化为（a[1]+a[n]）÷2×m，这个式子说明在n=m的情况下任意一个数列的和一定是m的倍数。
## n>m
从a[m+1]~a[n]的和一定是m的倍数，从a[1]~a[m]也一定是m的倍数，所以在这种情况下任意一个数列的和一定是m的倍数。
             
综上所述，我们得出结论：在n<m的情况下输出"NO",其他情况输出"YES".
                       
代码如下：
```
#include <bits/stdc++.h>
using namespace std;
long long n,m;
int main()
{
	cin>>n>>m;
	if(n>=m) cout<<"YES"<<endl;
	else cout<<"NO"<<endl;
	return 0;
}
```
                      