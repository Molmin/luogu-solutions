~~好水的签到题~~

~~楼下XCY你发题解总是比我快一步~~

~~XCY你太巨了，我5年级才学的你4年级就学了~~

~~XCY你太巨了，我只能给你的题解作补充了~~

好吧，~~牢骚~~膜拜完了就进入正题吧！

这道题的情况分3类：$n<m$、$n=m$、$n>m$

1. $n<m$

反例很简单，$a_1 \equiv a_2 \equiv a_3 \equiv ... \equiv a_n \equiv 1 (mod\ m)$时，余数永远凑不出$m$，证毕。

2. $n=m$

在研究连续数列余数问题时，有一种很~~土~~有用的方法：$S$大法

什么是$S$大法？我们有一个$S$数列，$S_i=a_1+...+a_i(i=1,2,3...n)$ 。分析连续一段数的和$a_i+a_{i+1}+a_{i+2}+...+a_{j-1}+a_j$就可以直接分析$S_j-S_i$了，只用分析两个数，简单便捷。要知道暴力地在一个数列中分析一堆连续的个数不定的是极为麻烦的，时间还慢~~（复杂度$n^2$）~~，暴力是绝对跑不过去的。而$S$大法解决这件事是轻而易举的。

证明：

1）若$S_i(i=1,2,3...n) \equiv 0(mod\ m)$，即$a_1+...+a_i \equiv 0(mod\ m)$，证毕。

2）不存在1）的情况，余数：$1,2,3,...,m-1$。$\because n=m,m \div (m-1)=1......1$ $\therefore$ 必有$S_i \equiv S_j(mod\ m)$，不妨设$S_j > S_i$，则 $S_j-S_i \equiv 0 (mod\ m)$，证毕。

3. $n>m$

从中任取连续的$m$个数，情况同上。

综上所述，当$n<m$，答案是NO；当$n \geq m$，答案是YES。

# 接下来就是令人激动的代码实现了：

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,m;//不用高精，ll就够了
int main(){
	cin>>n>>m;
	if(n>=m){
		cout<<"YES";
	}
	else{
		cout<<"NO";
	}
	return 0;
}
```

谢谢各位哥老官们的观看，祝大家NOIp2019rp++！！！