一种乱搞做法。

如果有一种权值已经在原序列中出现相邻对了，直接忽略它并把它出现的所有位置设为 -1。

接下来，考察所有极长的全 0 段。假设某一段长度为 $L$，它两端的 0 都可以与两边接壤的非 0 数匹配（如果不是 -1 的话）。这引导我们，把问题看成是位置和权值匹配，用图的匹配算法解决该题。

如果某一段匹配了 $k\ (0\le k\le 2)$ 个端点，它内部对答案的贡献显然是 $\dfrac{L-k}{2}$ 下取整。分类讨论：

- $L$ 是奇数，则如果两个端点都配，自己的内部贡献会减少 1，否则不会减少。
- $L$ 是偶数，只要至少配了一个端点，内部贡献就会减少 1。

考虑把“内部贡献能不能**不**减少 1？”也放到图上来：如果可以不减少 1，我们就让图上多一个匹配。据此得出建图。

- 对每个颜色建点，对每个全 0 段的左右端点位置建点。
- 对每个全 0 段，假设左右接壤的颜色分别为 $x,y$，左右端点的位置分别为 $l,r$，在 $x,l$，$y,r$ 之间连边。
- 对每个长度为奇数的全 0 段，建虚点 $p$，在 $p,l$，$p,r$ 之间连边（只要 $l,r$ 有一个没匹配，这一段内部贡献就可以不减少）
- 对每个长度为偶数的全 0 段，在 $l,r$ 之间连边（只要 $l,r$ 存在一个匹配，这一段内部贡献就必须减少）

然而，这样建图有 $O(n)$ 条边、$O(n)$ 个点，带花树复杂度是 $O(nm)$，不能通过。

~~听说实际上随机匈牙利直接艹过去了~~

考虑一种乱搞，对于每种颜色，只保留与其接壤的全 0 偶段和全 0 奇段各 $B$ 个，因为如果每种颜色都与很多段接壤，那很多段都用不到，很难对答案造成贡献。

加入该剪枝后，设颜色数为 $c$，只剩下 $O(cB)$ 条边、$O(cB)$ 个点，时间复杂度 $O((cB)^2)$。

经过试验，取 $B=4$ 可以通过。

代码（代码里的 $B$ 是真实的 $B$ 减一）：https://codeforces.ml/problemset/submission/1615/150703648