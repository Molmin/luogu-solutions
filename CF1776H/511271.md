### 题意简要：

一个群有 $n$ 个人，早上看最晚登陆前后次序为 $a_i$，晚上看最晚登陆前后次序为 $b_i$，问在这一天内至少有多少人登陆这个群。

### 题目分析：

结论 $1$：一个人 $i$ 假如在早上存在比他晚登陆的人 $j$，但是晚上时显示登陆 $i$ 比 $j$ 晚，说明 $i$ 上线过。

显而易见，假如 $i$ 不上线，$j$ 不上线，那么 $i$ 与 $j$ 的相对登陆次序不变。如果 $i$ 不上线，$j$ 上线，那么 $j$ 应在 $i$ 前面。

有了这个结论，模拟一下，可以做到 $O(n^2)$。过不了此题。

既然枚举早上的人会超时，我们换个角度思考，从晚上的人开始枚举。

结论 $2$：序列 $a_i$ 存在一个**最长**长度为 $k$ 的子序列，满足是 $b_i$ 序列的一个后缀，那么答案就是 $n-k$。

显然，这个子序列的任意一个元素不满足结论 $1$。这个结论成立。

我们在 $b_i$ 上倒序枚举，在 $a_i$ 设立一个倒序指针，扫一遍就行了。

### 代码如下：

```
#include<bits/stdc++.h>
using namespace std;
int T;
int n;
int main(){
	cin>>T;
	while(T--){
		cin>>n;
		vector<int> a(n),b(n);
		for(int i=0;i<n;i++) cin>>a[i];
		for(int i=0;i<n;i++) cin>>b[i];
		int pos=n-1,wh=-1;
		for(int i=n-1;~i;i--){
			while(~pos&&b[i]!=a[pos]) pos--;
			if(pos<0){wh=i;break;}
		}printf("%lld\n",wh+1);
	}return 0;
}
```

时间复杂度：$O(n)$。
