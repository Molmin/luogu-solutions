这道题有一个简洁的外表，但却有一颗毒瘤的心/xyx（好吧最后发现我想多了）  
我做这道题断断续续花了一个月的时间，改方法 2 次，改方程 3 次，终于做了出来。
还是先来看部分分吧。  
### 8pts  
直接搜索一遍就出来了，统计连通块个数，应该没有难度。  
### 16pts  
由于图中所有边出现的概率都是 $0.5$，所以每一种图出现的概率都是相同的。计算一下每一种图出现了几个连通块就行了。（我不清楚过不过得了，因为我自己没试，应该是可以打表的）  
### 24pts  
暴力枚举每条边出现和不出现时的情况，然后就很好算连通块个数，就可以算出期望了。  
### 64pts  
篇幅较长，如果想看正解可以略过。  

首先，这道题数据范围很小，又是求连通块个数的期望，我们可以考虑把每个点属于哪一个连通块给状压，用 $0$ 表示还没选。但如果你直接暴力枚举状态是什么，既不好转移也容易超时。我们可以选择进行一些优化。  
1. 像 $25$ 这种状态是没有意义的，因为这表示第一个点属于 $2$ 号连通块，第 $2$ 个点属于 $5$ 号连通块。  
2. 像 $221$ 这种状态是没有意义的，因为它与 $112$ 等价，显然后者转移时要方便一些。
3. 像 $101$ 这种状态是没有意义的，因为中间有一个没选的点导致转移出问题。

所以我们得出合法状态的要求，如果这点选了，那它要么和前面某个连通块连在一起，要么自己单独成为一个连通块，且是之前选了多少连通块的数量 $+1$。  
由此，就可以得出如何搜索合法状态的函数了。

接下来我们思考哪些状态之间可以转移。  
经过我的总结，有四种情况不能选：  
1. $100$ 是不能转移到 $111$ 的，因为你无法一次填补两个空缺。  
2. $110$ 是不能转移到 $100$ 的，因为你不能删除一个点。  
3. $110$ 是不能转移到 $121$ 的，因为原来 $1$ 和 $2$ 在同一个连通块里，现在又不在同一个连通块里了。  
4. $1230$ 是不能转移到 $1221$ 的，因为新加入的 $4$ 号点没有与 $2,3$ 连边，而且 $2,3$ 在原来不属于同一个连通块，但现在又属于同一个连通块了。

除此之外，其它的都是可以转移的。  

但你也许会问为什么 $122340$ 会转移到 $122111$，但我可以向你解释，这是可以的。来看下面两张图：  
![](https://cdn.luogu.com.cn/upload/image_hosting/zi4vxr2a.png)  
这就是原图的状态，圆圈内的数表示所属的连通块。  
加入新点后，朝这几个点连边，可以得到：  
![](https://cdn.luogu.com.cn/upload/image_hosting/gziks366.png)  
红色为新点，红边为新边。然后原来的 $1,3,4$ 连通块就被新点连接在了一起，所以是合法的。  
看了上面这两张图，我们就知道怎么转移了。  
我们需要找出需要连接哪几个连通块，每个连通块内至少连一条边（即剪去都不连的情况），不在同一个连通块的一个都不能连，于是转移的代码就出来了。  


总的代码因为影响观感就不放了，如果要看可以到[这里](https://www.luogu.com.cn/record/51789834)  
附：这本来是我打的 std，后来被艹了才写了后面的内容。  
### 80pts  
这个图最后每一种状态（64pts 已提到）都会有若干个互相隔离的连通块，我们可以先求出每一个连通块出现的概率（即减去任意两个点不连通的概率），然后再将这些连通块之间互相隔离的概率乘起来得到最终答案。  
举个例子，假设这是原图（同一个连通块用同种颜色标出）：
![](https://cdn.luogu.com.cn/upload/image_hosting/y8w5t99i.png)  
那么我们可以每一个连通块分一层：  
![](https://cdn.luogu.com.cn/upload/image_hosting/pdj2koym.png)  
通过一个状压DP就可以很快计算出每一种连通块出现的概率，然后在乘上不同连通块没有相连概率就是答案。  
代码因为影响观感就不放了，要看可以在[这里](https://www.luogu.com.cn/record/51789564)   
附：这本来是我打的第二个 std，后来被艹了才写了后面的内容。  
## 100pts  
发现上面那个算法的瓶颈不在 dp 上，而是在搜索上，我们考虑如何优化掉这个不知道什么复杂度的搜索。  
我们现在已经求出一个连通块出现的概率了，考虑如何计算它对于答案的贡献。  
如果它对答案有贡献，那么必然是这个连通块存在且相对于其它连通块独立。所以每一个连通块计算进的答案就是它出现的概率乘上它与其它点都没有相连的概率。  
代码很短： 
```cpp
#include<bits/stdc++.h>
const int maxn=16;
double p[maxn][maxn],f[1<<maxn],ans;
int n;
int main() {
	scanf("%d",&n);
	for(register int i=0; i<n; i++)
		for(register int j=0; j<n; j++)
			scanf("%lf",&p[i][j]);
	f[0]=1;
	for(register int ii=1; ii<(1<<n); ii++) {
		int lst=ii&(-ii);
		f[ii]=1;
		for(register int jj=(ii-1)&ii; jj; jj=(jj-1)&ii) {
			if(!(jj&lst))continue;//我们把最后一个点钦定为新加的点
			double ps=f[jj];
			for(register int i=0; i<n; i++) {
				if(!((1<<i)&(ii^jj)))continue;
				for(register int j=0; j<n; j++)
					if((1<<j)&jj)ps*=1-p[i][j];//如果i在ii中出现且没有在jj出现，然后j在jj中出现，则不能连边 
			}
			f[ii]-=ps;//正难则反计算概率
		}
	}
	for(register int ii=1; ii<(1<<n); ii++) {
		double now=1;
		for(register int i=0; i<n; i++)
			for(register int j=0; j<n; j++)
				if(!((1<<j)&ii)&&((1<<i)&ii))now*=1-p[i][j];//必须相对于其它连通块独立
		ans+=f[ii]*now;
	}
	printf("%.6lf",ans);
	return 0;
}
```