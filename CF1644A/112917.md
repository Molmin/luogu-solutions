## Content
有一个骑士站在一条走廊的左端，在走廊的右端，一位公主正在等待他的到来。

在来到这里之前，骑士就了解到，这条走廊一共有三扇门：红门、绿门和蓝门。分别对应这三扇门的钥匙分别是红钥匙、绿钥匙和蓝钥匙。他还拥有一张这条走廊的地图，其可以转化成一个仅包含以下 $6$ 个字符的字符串：

- `R`、`G`、`B`：分别表示红门、绿门和蓝门。
- `r`、`g`、`b`：分别表示红钥匙、绿钥匙和蓝钥匙。

骑士能够经过一扇门，当且仅当骑士拥有与其对应的钥匙。由于公主不愿意等太久，因此骑士**只能一直向右端走，不能回头**。

请判断骑士能否走到走廊的右端和公主会合。

**数据范围：$t$ 组数据，$1\leqslant t\leqslant 720$。**
## Solution
我们注意到题面中这段内容：

> 骑士能够经过一扇门，当且仅当骑士拥有与其对应的钥匙。由于公主不愿意等太久，因此骑士**只能一直向右端走，不能回头**。

然后我们发现，骑士能够走到右端，当且仅当每扇门对应的钥匙都出现在门的左边。因此，我们直接记录每扇门和每把钥匙的位置，然后判断即可。

`find()` 函数可以很轻松的做到记录字符串中某个字符的位置，因为该函数在某个字符存在的时候，返回的就是该字符第一次出现的位置。
## Code
```cpp
namespace Solution {
	int Tnum;
	string s;
	
	void Main() {
		read(Tnum);
		while(Tnum--) {
			cin >> s;
			if(s.find("r") > s.find("R")
			|| s.find("b") > s.find("B")
			|| s.find("g") > s.find("G"))
				puts("NO");
			else
				puts("YES");
		}
		return;
	}
}
```