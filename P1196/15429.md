不用说肯定用并查集，貌似就是不进行路径压缩的无脑模拟？不对，500000个操作，30000艘船，不超时才怪！


那怎么办呢？一路径压缩战舰顺序就被改变，怎么才能在路径压缩的同时随时得知同一舰队中两艘战舰的位置？


输入是合并与询问两艘战舰之间的“距离”，遇到问题是路径压缩后“距离”（间隔战舰数量）变了，不压缩太慢了，那我们不就可以再开一个数组，存下需要的“距离”了吗？这个数组存的距离就是在路径压缩时变化了的那个：第i艘到第fa[i]艘之间的战舰数量，数组名就命名成front吧，因为路径压缩全部完成，即同一舰队中所有元素的fa[i]都等于这个舰队第一艘战舰时，front[i]=第i艘战舰前方有多少战舰（这么搞就像前缀和，路径压缩时可以一层一层地边压缩边修正下去）。


易知在还未进行路径压缩时对于同一舰队非第一艘战舰，front[i]=1，第一艘战舰front[i]=0(一个舰队的第一艘，不是编号为一的那艘)，路径压缩首先不断向fa[i]走fa[i]=find(fa[i])，走到队首，fa[i]==i，front[i]=0不变，返回队首的编号，回溯至递归上一层，把队首的编号那么第二艘的front增加0就是1，为何是增加呢？因为前面说过完成路径压缩即find函数跑完后front[i]的值就是编号i的战舰前方有几艘战舰，路径压缩前则是到fa[i]的距离，一路径压缩，就相当于fa[i]直接越过front[fa[i]]艘战舰，从i的前一艘指向队首，fa[i]前进那么多，front[i]自然也要增加那么多，修改之后继续回溯，同理第三层front[i]+=front[fa[i]]……路径压缩完成。


合并时怎么办呢，定义合并函数uni(x,y)表示将x所在那列移到y所在那列后面（千万别搞反了），那么我们就要先找到两列的队首(依然用x、y存)，像普通并查集那样fa[x]=y,然后维护front数组，这时遇到问题啦——front[y]要加多少呢？显然是x那列的战舰数，难道还要循环一遍统计一下吗？那太慢了，存下来吧，于是num[i]表示编号i这列的战舰总数（i是队首，不然每合并一次要修改的太多了，查询时num[i]时先find(i)找到队首吧），front[y]+=num[x]，num[x]+=num[y]，合并完成。


还有一个问题就是询问。对于一组询问ask(x,y)，先找到他们的队首fx=find(x);fy=find(y);（顺便把路径压缩进行完全了，不用担心front[i]被重复增加了，路径压缩完全时front[fa[i]]==0，因为fa[i]就是队首呀），然后判断fx!=fy就输出-1，否则就输出abs(front[x]-front[y])-1（到队首的距离之差减一就是他们间隔距离）。


代码就不贴了，楼下都有


[广告](http://www.cnblogs.com/wawcac-blog/p/6821770.html)
