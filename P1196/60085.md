### 加权并查集的典型题
**//如果并不是很懂并查集及其优化，建议先打个模板题**

知道并查集的基本操作，即可发现对于两列舰队的合并、询问两个战舰是否在同一列，就分别是并查集的并、查操作。每一列的列首战舰即为此列所有战舰的祖先，合并两列时，即把其中一列的列首的父亲改为另一列列首，查询在不在一列，即对于两个战舰，向上逐个寻找父亲，直到找到父亲为自身的祖先，若为同一祖先，即在同一列。

好，现在只剩下一个问题，若两个战舰在一列，他们之间布置有多少战舰？

让我们回想并查集的两个优化之一——按秩合并，记录并查集中每个树的深度，每次合并时将深度小的合并到深度大的上。这里的深度，也就是在并查集的操作过程中不断维护的信息，那么我们可不可以在操作中维护一个信息来记录两个战舰之间布置的战舰个数呢？

显然，若对于每两个战舰都记录一下他们之间布置的战舰的个数，时间空间开销都很大，这时我们想到前缀思想：**对于每个战舰i，记录pre[i]为i所在的那一列上在i之前有多少个战舰（即为他之前直到他所在列的列首战舰数）**。这样，对于同一列的战舰i与战舰j（设i在j之后），他们之间的战舰个数即为**pre[i]-pre[j]-1**。

那么接下来，该如何维护这个pre数组呢？考虑：只有在合并两列时才会增加接在后面的那一列所有战舰的pre数组，**这个增量，即为接在前面的那一列的总战舰数**。此时我们想到再维护一个数组num[i]，即为以i为列首的那一列一共有多少战舰（以i为祖先的树的大小）。对于每次合并，我们只需将后面那一列的列首pre值+=前面那一列列首的num值，而对于后面那一列列首之后的那些战舰的pre值，只需再执行并查集find操作递归的回溯时更改，具体方法见代码及注释。

```cpp
#include <cstdio>
#include <iostream>

using namespace std;

int t,fa[30010],pre[30010],num[30010],a,b;
char c;//fa[i]：i战舰的父亲，pre[i]：i战舰之前布置有多少战舰，num[i]：以i战舰为列首的一列共有多少战舰 

void re(int &x)//快速读入优化
{
	x=0;
	bool flag=0;
	char ch=getchar();
	while(ch<'0'||ch>'9') flag|=(ch=='-'),ch=getchar();
	while(ch>='0'&&ch<='9') x=(x<<1)+(x<<3)+(ch^48),ch=getchar();
	x=flag ? -x : x;
}

int find(int x)
{
	if(fa[x]==x) return x;//直到找到自己的父亲就是自己，即使祖先 
	int fx=find(fa[x]); //递归寻找祖先
	pre[x]+=pre[fa[x]];//在find递归时，已经更新了x的祖先的pre，此时再更新x的pre值 
	return fa[x]=fx;//将自己的父亲直接赋为祖先，路径压缩优化 
}

void mix(int x,int y)
{
	int fx=find(x),fy=find(y);//找到各自的列首 
	fa[fx]=fy;//将前一列接到后一列尾部 
	pre[fx]+=num[fy];//先更新前一列列首之前布置的战舰数，多了后一列总战舰数那么多个战舰 
	num[fy]+=num[fx];//后一列总战舰数加上前一列的战舰数 
	num[fx]=0;//前一列的队首目前已不是队首了，清零 
}

int main()
{
	re(t);
	int i;//初始化每个战舰的父亲即为他自身，当前以他为列首的一列当然只有他自己一个战舰 
	for(i=1;i<=30000;i++) fa[i]=i,num[i]=1;
	while(t--)
	{
		cin>>c; re(a); re(b);//自己写时不知道为什么，若是c=getchar();则会“Too many or too few lines” 
		if(c=='M')
			mix(a,b);//将a那一列接到b那一列后 
		else
			if(find(a)!=find(b)) printf("-1\n");//找他们各自的祖先即列首，若不是同一个，则不在同一列 
			else
				printf("%d\n",pre[a]-pre[b]>0 ? pre[a]-pre[b]-1 : pre[b]-pre[a]-1);//用三目运算符确保大数减小数，再减一，即其间的战舰数 
	}
	return 0;
}
```