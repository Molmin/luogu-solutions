必须提前学习 动态规划 算法。建议学习[求最大子序列](https://www.luogu.com.cn/problem/P1115)。

题意简述:寻找一个行至少为 $5$，列至少为 $4$ 的子矩阵。并把矩阵中间全部改成  $0$，边界改成 $1$，但四个角不用改。求最小修改次数。

不难想到暴力算法:枚举起始点 $(x0,y0)$，终点 $(x1,y1)$。

但是显然会超时，不难想到最大子矩阵的优化思路，首先枚举  $x0,x1$，然后再设计dp转移,dp转移类似最大子序列。

设 $f_k$ 为以编号为 $k$ 的元素结尾，**除去最右边一列**最优需要修改几次。(至于为什么除去，稍后会讲)

那么可以有以下两种转移方式:

沿用上一次的最小值。那么答案就是 第 $k$ 列 $[x0,x1]$ 修改成 $0$ 最少次数。(关于具体求法后面会讲)

为什么这样就是对的呢?因为无论如何都得加上 修改次数，所以上一次的最小值一定是这一次的最小值。

新开一个子序列。此时不可能再开一个长度超过 $4$ 的子序列。因为这样就变成了 沿用上一次的最小值 情况。所以这种情况需要将第 $k,k-1,k-2$ 列全部修改成两边 $1$ 中间 $0$，将 $k-3$ 列中间修改成 $1$(只针对 $[x0,x1]$ 行)。

状态转移方程的代码($q0(i,j,k)$ 表示第 $(i,j)$ 行 $k$ 列 全部改成中间 $0$ 两边 $1$ 的最小次数，$q1$ 则改成中间 $1$)(使用了滚动数组):
```cpp
for(k=3;k<m;k++){
  f[i]=min(q0(i,j,k)+q0(i,j,k-1)+q1(i,j,k-2),f[i-1]+q0(i,j,k));
}
```

接下来就看如何求 $q$。实际上可以枚举所有的 $i,j,k$，暴力预处理，本人赛后才想到这种暴力的方法，所以讲一下前缀和的做法，如果不想看可以跳过。

这种静态区间求和问题可以想到前缀和。对于第一种情况，只需求一次出区间和，而第二种情况只需求 $4$ 次，因此不需要二维前缀和。

那么可以分别设 $s0(i,j)$ 表示将第 $j$ 列 $[1,i]$ 行修改成 $0$ 的最小次数，$s1$ 表示修改成 $1$ 的最小次数。

预处理部分代码($a$ 表示输入给出的原矩阵)：
```cpp
for(i=1;i<=n;i++){
  for(j=1;j<=m;j++){
    s0[i][j]=s0[i-1][j]+a[i][j];
    s1[i][j]=s1[i-1][j]+!a[i][j];
  }
}
```
但是到这里还没有做完，因为我们把最右边一列给删掉了，现在要复原回来。那么就要加回来。如何加就简单了，不讲。最后把所有的 $f$ 取最小值就得到答案了。

为何要去掉右边?因为如果不去掉，那么前一个的最小值无法代表当前的最小值。

代码:
```cpp
#include<iostream>
using namespace std;
bool a[2005][2005];
int s0[2005][2005],s1[2005][2005];
int q(int l,int r,int y){
	return s0[r-1][y]-s0[l][y]+!a[l][y]+!a[r][y]; //两边都得是1,中间是0。
}
void Main(){
	int n,m,i,j,k,l,ykb,sum=0,Min=999999999;
	char A;
	cin>>n>>m;
	for(i=1;i<=n;i++){
		for(j=1;j<=m;j++){
			cin>>A;
			a[i][j]=(A=='1');
		}
	}
	for(i=1;i<=n;i++){
		for(j=1;j<=m;j++){
			s0[i][j]=s0[i-1][j]+a[i][j];
			s1[i][j]=s1[i-1][j]+!a[i][j];
		}
	}
	for(i=1;i<=n;i++){
		for(j=i+4;j<=n;j++){ //行至少为5。
			sum=999999999; //采用了滚动数组优化。于是初始值赋为无穷大。
			for(k=3;k<m;k++){
				sum=min(q(i,j,k)+q(i,j,k-1)+s1[j-1][k-2]-s1[i][k-2],sum+q(i,j,k)); //最左边两边不需要加,所以查询的区间是[i+1,j-1]。
				Min=min(Min,sum+s1[j-1][k+1]-s1[i][k+1]); //要把最右边加回来。
			}
		}
	}
	cout<<Min<<endl;
}
int main(){
	int t,i;
	cin>>t;
	for(i=0;i<t;i++){
		Main();
	}
}
```