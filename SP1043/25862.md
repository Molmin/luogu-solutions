
**[博客中食用更佳](https://www.luogu.org/blog/xzlhxc/solution-sp1043)**  
 _给读者：标题大字体是我的习惯，如果觉得不美观及有更好的建议请私信作者！_ 
 
------------

[题目链接（洛谷）](https://www.luogu.org/problemnew/show/SP1043)    

读懂这篇文章你可能要会：~~基础动归~~，[线段树0](https://www.luogu.org/problemnew/show/P3374)（单点修改区间求值），[最大子段和](https://www.luogu.org/problemnew/show/P1115) 的 $O(NlogN)$ 解法。
# ①题意简述
动态最大子段和。即询问一个序列的子序列的最大子段和。    
# ②维护信息
本题的数据范围为1e4级别，又只有230ms的~~毒瘤~~时限，明显暴力dp的$O(nm)$算法不够优秀，所以我们要考虑更优的算法。

根据**分治**的思想，我们把一段序列分成若干个子序列，**如果答案能从子序列中合并而得，就能得到$O(mlogn)$的优秀算法**。然而，如果仅根据子序列的最大子段和，是没办法合并的，因为**两个子序列的最大子段和不一定是整个序列的最大子段和**，即这个信息不满足结合律。  
 _这里举一个简单的例子：100 -1 | -2 100 （|为分界点）_ 

那要维护什么呢？

~~233~~从原本的静态最大子段和的$O(nlogn)$算法中，我们知道，一段序列的最大子段和，**要么在中点左侧，要么在中点右侧，要么横跨中点**（易证，请读者思考）。所以我们在每一个子序列中维护这样的信息：
```
struct node//暂时不用管这个名字
{
	int sum,maxx,lmax,rmax;
};
```
其中，maxx为该序列的最大子段和，lmax为以最左端为开头的最大子段和（后称为：前缀最大子段和），rmax为以最右端为结尾的最大子段和（后称为：后缀最大子段和）。于是，在计算时，我们可以这么做：
```
int lc=k<<1,rc=k<<1|1; //lc为左子序列，rc为右子序列
maxx[k]=max(max(maxx[lc],maxx[rc]),rmax[lc]+lmax[rc]);
```
![](https://cdn.luogu.com.cn/upload/pic/62280.png)
怎么理解呢？

这里用了一点**贪心**的思想。再次看一遍有着~~233~~标记的那段话，如果最大子段和横跨中点，那么就等于中点及为左的最大子段和（rmax[lc]，左子序列的后缀最大子段和）加上中点为右的最大子段和（lmax[rc]，右子序列的前缀最大子段和）。在横跨中点的情况下，没有比这样更优的最大子段和（易证，请读者思考）。

否则，如果不跨越中点，那就在左右子序列的最大子段和中找最大值就行。

等等，那sum是什么？有什么用？  

前面我们解决了maxx的计算，那lmax和rmax要怎么计算呢？  
假设求出了左右子序列的lmax与rmax值，**此时它们都没跨越中点**。到了父序列（与子序列相对）中，**如果跨越中点得到的lmax与rmax比原先的更大，那就跨越中点**！以lmax为例，现在求出了左子序列的lmax值，如果跨过中点，就更新为左子序列的区间和加上右子序列的rmax。rmax的更新类似。所以，**sum就是子序列的区间和**。
```
lmax[lc]=max(lmax[lc],sum[lc]+lmax[rc]);
rmax[rc]=max(rmax[rc],sum[rc]+rmax[lc]);
```
![](https://cdn.luogu.com.cn/upload/pic/62283.png)

**最后，用一个支持单点修改区间求和的数据结构（如线段树）来维护这些信息就可以啦！**
# ③AC!
做完这题可以做这题的进阶版：["Ray, Pass me the dishes!"](https://www.luogu.org/problemnew/show/UVA1400)，类似题：[好一个一中腰鼓！](https://www.luogu.org/problemnew/show/P2253)。  
# ④小结
做类似的线段树题，要从哪些内容开始考虑呢？  
1. 线段树每个节点代表的区间维护的信息；
1. 信息的更新（update函数，用于建树、修改及查询）。   
 _例如如果只是区间求和，那么父节点的信息就是2个子节点的和。当维护的信息较多，最好封装到一个函数中。_ 
1. 各个信息更新的顺序。
1. 修改时要修改的内容。
1. 需要用到的某些信息的$lazy$ $tag$（懒标记）。（区间修改）
1. $lazy$ $tag$ 之间的优先级。（区间修改）
1. $lazy$ $tag$ 下传及下传后信息的更新。（区间修改）

------------

“我想做一篇详略得当，清晰明了的题解。”   
喜欢就点个赞吧！