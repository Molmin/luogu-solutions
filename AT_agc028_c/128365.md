不是很难的题，但是挺有趣。提供一个比较清新的思路。

发现难以直接贪心。于是首先思考合法条件。

设 $(x,y)$ 表示一个点的 $a$ 和 $b$ 是否产生贡献。$x=1$ 则代表 $a$ 有贡献；$y$ 同理。显然 $1$ 的总数是 $n$。

手玩可以得到，$(1,0)$ 之间可以直接放一起，缩成一个 $(1,0)$；$(0,1)$ 也同理。剩下就需要 $(1,1)$ 来连接了。发现除了全 $(1,0)$ 或全 $(0,1)$ 的情况，至少要存在一个 $(1,1)$，且 $(1,1)$ 的个数需要不少于 $(0,0)$ 的个数。这就是合法的充要条件。

想构造证明的话，就只需要知道 $(0,1),(0,1),(0,0),(1,0),(1,0)$ 这样的结构等价于 $(0,0)$ 即可。

那么归纳整理一下：首先特殊做掉所有点都是 $(1,0)$ 和都是 $(0,1)$ 的情况。设 $u\ge 1$ 表示 $(1,1)$ 的个数。那么根据总共会选 $n$ 个 $1$ 可以得到 $(0,0)$ 的个数为 $n-u-(n-2\times u)=u$，换而言之，限制直接只剩下 $u\ge 1$ 了。

判掉特殊情况的问题就转换成了给你 $n$ 对 $(a,b)$。共选出 $n$ 个数，并且至少一对 $(a,b)$ 必须全选。求总和最小值。

这个问题可以考虑贪心。考虑按 $\max(a,b)$ 从排序。那么最小值一定优。

证明考虑两个点 $i,j$ 看谁钦定全选更优。如果是所有数都选那么无意义不考虑；如果只选 $3$ 个数，那么相当于比较 $-\max(a_i,b_i)$ 和 $-\max(a_j,b_j)$ 的大小，符合排序；如果只选 $2$ 个数，则可归于下面的特殊情况。

特殊情况：所有数对都有一个数在前一半小，一个数在后一半小。因为这样可能会让我们所排序的最小数对，两个数都可以不选（排名为 $n$ 和 $n+1$）。那么只需要再做一遍次小值即可。

实现代码时，可以直接枚举最小值，次小值，做两遍。

当然，利用一定选 $n$ 个数的鸽雀原理，能直接分讨特殊情况。
