## 解析

这里讲两种思路；前一种是我看完 std 的实现再结合赛时的思考得出的，后一种就是社论的思路

### 思路一

我们先思考下原图为 DAG 的情况时该怎么做；

可以想到对 DAG 做一次拓扑排序，按拓扑序贪心选一次即可。具体来说，选择前检查该结点是否已被访问，选择后将该结点以及该结点一步能到达的结点都设为已访问

不难发现这样构造出的答案 $Q$，图中所有不在 $Q$ 中的结点都是能被 $Q$ **一步到达**的

接着再考虑原图非 DAG 时该怎么做；

可以想到，先按任意顺序扫一遍，选择策略和刚才相同，这样构造出一张图 $G'$。于是原图 $G$ 中的每个结点都能被 $G'$ 一步到达，且能发现 $G'$ 是一个 **DAG**（若存在环，要么环可能被某个能一步到达环的结点的检查 “截断”；要么考虑环中第一个被检查的结点，一定会把环 “截断”）

于是再将 $G'$ 按拓扑序以同样的策略得到一个答案 $Q$。$G'$ 中的结点都能被 $Q$ 至多一步到达，而 $G$ 中的结点都能被 $Q$ 至多两步到达

### 思路二

先考虑归纳证明解一定存在

1. 首先仅有一个结点时，解显然存在
2. 若我们能找到至多 $k$ 个结点的图的解，考虑往图中再加入一个结点，是否还能找到解。首先我们把新加入结点 $u$ 一步能到达的节点都先从图 $G$ 中删除，再找到剩下的图 $G'$ 的一个解 $Q$。接着如果 $Q$ 能一步到达 $u$，那么 $Q$ 也是 $G$ 的一个解；否则就将 $u$ 加入 $Q$，就能得到 $G$ 的一个解

具体实现时，我们可以考虑先贪心地取 $\{u_i\}$——每个 $u_i$ 实际上就是该 $u_i$ 与它一步能到达的结点，的导出子图的解；接着我们再考虑一个个 “合并” 这些解（具体可以考虑按 $\{u_i\}$ 的拓扑序合并；直接地按任意顺序合并可能每次都要检查两个结点的所有出边，导致复杂度爆炸）。“合并” 的正确性证明和刚才的证明相似

## CODE

两种思路都可以解释这种实现

```cpp
#include <cstdio>
#include <vector>
using std::vector;

const int MAXN =1e6+20;

/*------------------------------IO------------------------------*/

int read(){
	int x =0; char c =getchar(); bool f =0;
	while(c < '0' || c > '9') (c == '-') ? f =1, c =getchar() : c =getchar();
	while(c >= '0' && c <= '9') x =(x<<1)+(x<<3)+(48^c), c =getchar();
	return (f) ? -x : x;
}

void write(const int &x){
	if(x/10)
		write(x/10);
	putchar('0'+x%10);
}

/*------------------------------Main------------------------------*/

vector<int> E[MAXN];

bool vis[MAXN], chosen[MAXN];

int main(){
	int n =read(), m =read();
	for(int i =0; i < m; ++i){
		int u =read(), v =read();
		E[u].push_back(v);
	}
	
	int cnt =0;
	for(int i =1; i <= n; ++i)
		if(!vis[i]){
			if(chosen[i] == 0)
				++cnt;
			chosen[i] =1;
			vis[i] =1;
			for(int j:E[i])
				vis[j] =1;
		}
	for(int i =n; i >= 1; --i)
		if(chosen[i])
			for(int j:E[i]){
				if(chosen[j] == 1)
					--cnt;
				chosen[j] =0;
			}
	
	write(cnt), putchar('\n');
	for(int i =1; i <= n; ++i)
		if(chosen[i])
			write(i), putchar(' ');
}
```