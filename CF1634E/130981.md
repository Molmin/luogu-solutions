给出一篇和官方题解不同的题解。

## 思路

### 铺垫

在编造样例试验的过程中，很容易有这样的想法：如果之前把一个数放在了 $L$ 中，就在下一次遇到这个数时把它放在 $R$ 中；如果一个数组里有很多个数已经放在 $L$ 了，剩下的数就尽量放在 $R$ 中。

由此可能生出各种贪心做法，不过都是错的。以下样例可能会卡掉很多人的贪心：

```
1 2
3 4
5 6
7 8
1 3 5 7
2 4 6 8
```

多进行几次尝试可能还能得到一些信息，比如确定一个数放在 $L$ 后，就会跟着确定一些数放进哪个集合，然后剩下的数又可以随意放，接着确定一个数，又能确定一些数……这似乎和连通块很像。

结合以上的思考，就能~~灵光乍现~~得出一种奇妙的思路了。

### 解法

把每个数想象成一个点，考虑如何**建边**，使得只要连边的两个点不在同一个集合内，这种划分就成立。

那么如何建边呢？这既需要考虑同样的数之间的关系，也需要考虑一个序列中的数之间的关系。最终建出来的图还需要每个连通块都是一个环（也就是说每个点的度数都为 $2$），并且每个环都有偶数个点。

于是想到，第 $1,2$ 个，第 $3,4$ 个等**相同的数之间连一条边**，序列中第 $1,2$ 个，第 $3,4$ 个等**相邻的数之间连一条边**。

连完后的样子大概是这样（担心没讲清楚）（红色的边是连的边）：

![](https://cdn.luogu.com.cn/upload/image_hosting/8kqd1krq.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/0yscyv1g.png)

（第 $1$ 个出现的 $1$ 和第 $2$ 个出现的 $1$ 连边，第 $3$ 个出现的 $1$ 和第 $4$ 个出现的 $1$ 连边……每个序列第 $1$ 个数和第 $2$ 个数连边，第 $3$ 个数和第 $4$ 个数连边……）

那么现在需要证明这样建图满足所有要求。

首先这显然能满足两个集合相等，且每个集合分给 $L,R$ 的个数相同。不过为什么这样每个点的度数都为 $2$，且每个环都是偶环呢？如果把连接同一个数的边看作“纵边”，连接一个序列中两个数的边看作“横边”，那么一个点一定连出去一条纵边和一条横边，所以度数为 $2$，而且在这个环内，这两种边交替出现，所以一定会有偶数条边。

于是，在建边之后，对每个环先确定一个点加入的集合，然后遍历整个环让每个点进入的集合与上一个不同即可。

然后在建边的时候需要存每个数上一个点的位置，不过 $a_i \le 10^9$，所以需要离散化或用 ```map```（个人认为 ```map``` 更好写）。

最后说一下什么情况下无解：无解当且仅当有一个点没有连“纵边”，其实也就是有一个数出现了奇数次。

时间复杂度 $O(n \log n)$。

## 代码

```cpp
#include<cstdio>
#include<map>
#include<vector>
using namespace std;
const int MAXN=2e5+10;
map<int,int> mp; //记录每个数上一个点的位置
vector<int> e[MAXN<<1]; //边
bool vis[MAXN];
int n[MAXN],ans[MAXN];
int read(){ //快读
	int num=0,sign=1; char ch=getchar();
	while(ch<'0'||ch>'9'){if(ch=='-')sign=-1;ch=getchar();}
	while(ch>='0'&&ch<='9'){num=num*10+ch-'0';ch=getchar();}
	return num*sign;
}
void dfs(int u,int num){ //对一个环进行划分，num 表示这个点进入哪个集合
	ans[u]=num,vis[u]=1; //记录答案、来过
	if(!vis[e[u][0]]) dfs(e[u][0],num^1);
	else if(!vis[e[u][1]]) dfs(e[u][1],num^1);
}
int main(){
	int m=read(),tot=0;
	for(int i=1;i<=m;i++){
		n[i]=read();
		for(int j=1;j<=n[i];j++){
			tot++;
			int x=read();
			if(j%2==0) e[tot].push_back(tot-1),
				e[tot-1].push_back(tot); //序列中的第偶数个点，与它左边的点连边
			if(mp[x]>0) e[tot].push_back(mp[x]),
				e[mp[x]].push_back(tot),mp.erase(x); //第偶数次出现这个数，与上一次出现这个数的位置连边
			else mp[x]=tot; //第奇数次出现这个数，记录位置，等待连边
		}
	}
	if(mp.size()){ //判断无解
		printf("NO\n");
		return 0;
	}
	for(int i=1;i<=tot;i++)
		if(!vis[i]) dfs(i,0); //对每个环划分
	int tott=0;
	printf("YES\n");
	for(int i=1;i<=m;i++){
		for(int j=1;j<=n[i];j++)
			tott++,printf("%c",ans[tott]?'L':'R');
		printf("\n");
	}
	return 0; //华丽结束
}
```

看完不要忘记点赞~