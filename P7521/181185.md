注意 本做法非正解，属于取巧行为。

只能说明数据太水了（这也能让我AC？）


感谢@[灵悟彷徨](https://www.luogu.com.cn/user/230270#main)和@[绅士的和善](https://www.luogu.com.cn/user/416457)两位大佬的帮助


------------

首先我们谈谈正常人30分的做法

很简单,就是**暴力三层枚举**，下面是本菜鸟的做法

#### 代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,a[200020],ans; 
int main()
{
	cin>>n;
	for(long long i=1;i<=n;++i)
	{
		cin>>a[i];
	}
	sort(a+1,a+1+n);
	for(long long k=1;k<=n;++k)
	{
		for(long long i=1;i<=n;++i)
		{
			if(i==k)
			{
					continue;
			}
			for(long long j=i+1;j<=n;++j)
			{
				if(j==k)
				{
					continue;
				}
				ans=max(ans,(a[i]+a[j])%a[k]);
			}
		}
	}
	cout<<ans;
	return 0;
 } 
```


------------
接下来我们来谈一谈骗分方法

首先感谢@[灵悟彷徨](https://www.luogu.com.cn/user/230270#main)提供的思路，说是考场上现想的方法,然后我加以改进了一下，接下来是思路：

首先代入考场样例数据2，发现两个考场数据k都是最大的一个数，然后我们要思考，是不是直接模最大的数，稍加思索后我们可以发现，这种思路并不对，我们可以**轻易地举出反例**

比如说 $3,4,5,6,3\dots $(诺干个$3$）
如果**模最大的 $6$ ，那答案是 $(4+5)\bmod 6=3$**
但是我们可以发现，$(6+3)\bmod 5=4,4>3$ 所以可以知道之前的思路是错误的
无论n是大是小，直接用刚才的思路，都存在较大的错误概率。所以我们只能另谋他路

但是考场上的大样例数据告诉我们, $k$ **在数据中可能很大，在我们不知道其他数据的情况下，选的 $k$ 越大，所求的余数可能会更大，答案也就越大**，于是我们可以猜想，在 $n$ 极大的时候，排序过后数组中最大的几个数作为 $i,j,k$ 的概率很大（其实就是玄学做法）

所以刚开始@[灵悟彷徨](https://www.luogu.com.cn/user/230270#main)想通过**提出数列中最大的 $3$ 个数**来通过 $100pts$ 的数据范围，所以最后赌了一把，在此题拿到了$90pts$（在其他小数据范围内用分治保证最低分数）

在考场后，@[灵悟彷徨](https://www.luogu.com.cn/user/230270#main)与我谈起此事，于是我灵机一动，优化了这个玄学的方法，让它变得更加玄学。
 于是，我先从小到大sort一遍，把**数列中最大的 $10$ 个数**提出来（可以取更大的范围，毕竟现在是考后，随便水了一水）
 
 **然后我在这 $10$ 个数中枚举 $i,j,k$ 取模结果的最大值 $ans$ 。**
 
结果就莫名其妙AC了（傻眼了）。**事实证明，数据太水了。**
我稍加改进一下，发现**只要扫最后 $6$ 个数就可以AC**
 

------------
#### 以下为代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,a[200020],ans; 
int main()
{
	cin>>n;
	for(long long i=1;i<=n;++i)
	{
		cin>>a[i];
	}
	sort(a+1,a+1+n);
	for(long long k=n-5;k<=n;++k)
	{
		for(long long i=n-5;i<=n;++i)
		{
			if(i==k)
			{
					continue;
			}
			for(long long j=i+1;j<=n;++j)
			{
				if(j==k)
				{
					continue;
				}
				ans=max(ans,(a[i]+a[j])%a[k]);
			}
		}
	}
	cout<<ans;
	return 0;
 } 
```
有一说一，这道题AC得莫名其妙
**如果在输入的时候就直接找出最大的五个数，那么说不定可以节省时间让这个代码逼近 $O(n)$ (虽然这代码是错误的）**

最后还是再说一句，考试能做正解还是尽力做正解，毕竟我这是菜逼的玄学方法，还是一个事后诸葛亮。