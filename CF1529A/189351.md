## 题意

有一个序列，每次可以选任意一个子序列，把这个子序列中**大于**这个子序列平均值的数删去，问最多删除几个数。

## 分析

思考什么情况时不能删去任何一个数，分析平均值的含义，如果当前序列中有多于两个的数那么这个平均值一点小于最大的数。换句话来说就是当这个序列只有一个数（这里指的是可以存在多个数但是都相等）的时候不能删去任何一个数。

然后可以想到因为每次删去的是大于平均值的数，所以最后保留下来的只有可能是序列最小值，然后找出不等于最小值的数的数量即可。

## 代码

```cpp
# include <bits/stdc++.h>
using namespace std;

int T;
int N, res;
int A[105], minn;

int main () {
    cin >> T;
    while (T--) {
        cin >> N >> A[1]; minn = A[1]; res = 0; // 这里把 minn 初值设好，比较方便吧
        for (int i = 2; i <= N; i++) {
            cin >> A[i]; minn = min (minn, A[i]);
            //刷最小值
        }
        for (int i = 1; i <= N; i++) if (A[i] != minn) res++;
        cout << res << endl; // 不等于最小的时候就把 res++
    }
    return 0;
}
```