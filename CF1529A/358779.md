## 题意

有一个序列，每次可以选任意一个子序列，把这个子序列中大于这个子序列平均值的数删去，问最多删除几个数。

## 思路

这题其实可以发现一些规律

我们先来看样例

```
3
6
1 1 1 2 2 3
6
9 9 9 9 9 9
6
6 4 1 1 4 1
```

可以发现，第一组数据的最小值是 $1$ ，与它不相同的数一共有三个，输出是 $3$ ，第二组数据最小值是 $1$ ，因为全相等，所以输出 $0$ ，第三组数据最小值是 $1$ ，与它不相等的数一共有三个，输出是 $3$ 

然后我凭着找到的规律打出了代码

```
#include<cstdio>
#include<iostream>
#include<cstring>
#include<bits/stdc++.h>
using namespace std;
int t,n,m[105],ans;
int main()
{
	cin>>t;
	while(t--)
	{
		memset(m,0,sizeof(m));ans=0;
		int minn=200;
		cin>>n;
		for(int i=1; i<=n;i++)
		{
			cin>>m[i];
			minn=min(minn,m[i]);
		}
		for(int i=1; i<=n;i++)
		{
			if(m[i]!=minn) ans++;
		}
		cout<<ans<<endl;
	}
	return 0;
}
```

居然AC了！

那么为什么答案是不等于最小值的数个数呢？我们重新回到题干分析

因为每次选的是子序列中大于子序列平均值的数删去，而如果知道平均数的定义，我们就会知道平均数是会小于最大值一点的，而当子序列只有一个数的时候，我们不考虑，因为根本删不了，还有是都相等的时候，这个时候平均值是子序列中任意一个数，也删不了，所以子序列中留下来的只可能是整个大序列中的最小值，我们就想一个极端情况，把大序列中所有等于最小值的数和第一个大于它的数相加求平均数，平均数只会是比最小值多一点，最后剩下的肯定是大序列中最小值的数，所以我们这种思路是正确的。
