考了这题，感到十分震撼，发篇题解纪念一下。

考虑朴素的 DP 怎么做，设 $f_{i,j}$ 表示第 $i$ 轮的结果是 $j$，答案是多少。容易得到转移 $f_{i,j}+(j\bmod a_{i+1})\to f_{i+1,j\bmod a_{i+1}}$。

这玩意状态数达到了 $O(na)$，考虑一个经典技巧。注意到最开始的 $f_{1,*}$ 呈现一个一次函数的形态（$f_{1,i}=i$），之后考虑转移中每个连续的部分（即对于区间 $[l,r]$，不存在 $i\in [l,r)$，满足 $(i\bmod a_i)=a_i-1,((i+1)\bmod a_i)=0$），它的贡献也是一个一次函数，且斜率均为 $1$。因此我们断言，对于 $f_{i,*}$，它呈现为若干个一次函数的分段函数形态，且各段斜率都为 $i$。

因此我们只需要维护这些函数就可以了。考虑填表法转移，即把 $f_{i,x}$ 分成若干个模 $a_{i+1}$ 的同余周期（即按照 $\lfloor x/a_{i+1}\rfloor$ 的值分类）把它们排到一起，然后取 $\max$。

![](https://cdn.luogu.com.cn/upload/image_hosting/42mlgmpu.png)

容易发现其实我们只要考虑两条直线：最上面一条短的和最上面一条满的。

然而如果我们真的取 $\max$ 的话函数会变得非常混乱，考虑保留这些函数，求答案的时候再取 $\max$。这样一条函数就变成了一个前缀，于是完全可以用二元组 $(b,r)$ 表示，其中 $b$ 表示截距，$r$ 表示右端点。

那么考虑一次操作新增的直线，一条是 $(b_1',r\bmod a_{i+1})$，一条是 $(b_2',a_{i+1}-1)$，只需要计算 $b_1',b_2'$ 的表达式即可，具体可以参考其它题解，这里不再赘述。

由于除了 $(b,a_i-1)$ 一类直线外，一条直线最终只会新增至多 $\log a_i$ 根直线，而上面那一类最多是 $O(n)$ 条的，因此复杂度是 $O(n\log a_i\log n)$。

https://codeforces.com/contest/889/submission/150452030

希望能够帮到大家。