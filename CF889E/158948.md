> 如果一道题看过但不会做，80%是之前看完都没理解，15%是忘了，3%是换了个壳子（题面），剩下的2%留给抽风。——《模拟赛后有感》

做的时候由于不会没看出来，下来发现这道题除了要求的东西，框架竟然和 [AGC003E](https://www.luogu.com.cn/problem/AT2005) 一模一样。（话说昨天还在说 AGC003E 难度虚高来着）

题目不太好看，看作 $x$ 从 $i:1\to n$，每次对 $a_i$ 取模并累加和，求和的最大值。

首先对于 $a_{i+1}\ge a_{i}$，去除 $a_{i+1}$，并将其权值（初始为 $v_i=1$）累加到 $v_i$ 上，随便做一下。

于是有了条件 $\forall a_{i+1}<a_{i}$，如果你问有什么用，我可以告诉你不这么做也不会错。

用处实际上应该是可以减少常数，~~我总不可能跟你说是从隔壁那道题贴过来的吧~~。

令 $b_i$ 为 $x\bmod a_1\bmod a_2\cdots\bmod a_i$ 后的值，自然的想到若 $\forall i,a_i-b_i>1$，那么将 $x\to x+1$，则 $b_i\to b_i+1$。

于是最优的 $x$ 一定满足 $\exists i,a_i-b_i=1$，~~然后一般的题解就可以直接把式子贺过来放代码了~~。

令 $c_k=a_k-b_k$，上面的 $a_i-b_i=1$ 即为 $c_i=1$，补充说明若有多个 $c_i=1$ 我们考察的 $i$ 是最小的那个。

为了自然过渡到下一步，我们需要一个显然的观察：

有 $\exists j<i,c_j=\min_{k<i}c_k$，则 $1<c_j<a_i$。

令 $dlt=c_j-1$，不一定自然的想到 $\forall k<i,c_k\to c_k+dlt$ 都不会溢出，那么由 $\forall k<i,c_k'=c_k+dlt\to c_k$ 也都是可行的！

此时有 $c_j'=1$，于是我们可以构想这样的一个过程：在 $j$ 处将 $x$ 取得 $c_j'=1$ 的最大，再在 $i$ 处调整至 $c_i=1,c_j'\to c_j$，以此来更新 $c_i=1$ 的最大。

这样的好处是调整的过程是平凡的，也就是说知道 $a_j,a_i$ 就可以简单计算得到调整 $c_j'=1\to c_j$ 的 $dlt$。

~~我觉得很显然的是~~这样就把所有可能的最优情况都考虑完了，同时这个过程也很好维护，后面会说。

再考虑 $c_i=1$ 后 $\forall p>i$ 的贡献，显然后面每个位置的 $b_p$ 都已经确定了，直接快速计算即可：

由于 $r=x\bmod a_i<a_i<r+k a_i=x$，而 $x\ge a_i$ 时才会被取模，则 $k\ge 1$，$x\ge r+a_i>2r$，故每次取模缩小两倍。

于是直接在 $a_i\le x$ 的最小的那个 $i$ 那里取模，总共只会取 $\log$ 次。

最后要做的就是实现转移和计算贡献，如果你想方便的实现，可以像其他题解那样：

将所有的 $c_i=1$ 对应的 $x$ 走到当前位置 $p$ 得到的 $b_p'$ 以及 $x$ 中最大贡献都维护着走，然后处理两种情况：

- $c_i=1$ 不变，继承并计算贡献，把 $b_p'\ge a_p$ 的变为 $b_p<a_p$ 并累加。

  由上文所说只会取 $\log$ 次模，复杂度是 $\log$。

- 改变为满足 $c_p=1$，调整 $c_i=1\to c_i=\max_{k<p}c_k$，改变的贡献就是一起减一个值。

  不难发现只有在 $b_p'\ge a_p$ 的才可能达到 $c_p=1$，也才可能需要改变为 $c_p=1$，即当 $b_p'=a_p-1$ 时虽然有 $c_p=1$，这种情况看作继承不当做改变。
  
  故和取模的那些 $b_p'$ 一起处理即可，多个两倍常数，复杂度不变。
  
~~更方便的~~，我们可以在一个确定的转折点（确定在这里会被取模）后才计算它之前的贡献，它之后的贡献先暂时不定，从而方便 $c_i=1\to c_p=1$ 的改动。
  
代码：

```cpp
	int i,s;LL x,y,v,nw,mx=0;n=read();
	for(stk[0]=LLONG_MAX;n;n--)
	{
		read(x);ckmx(mx,x);
		if(x<stk[top])stk[++top]=x,val[top]=1;
		else val[top]++;
	}
	F[stk[1]-1]=0;
	for(s=val[1],i=2;i<=top;s+=val[i++])
	{
		for(it=F.lower_bound(nw=stk[i]);it!=F.end();F.erase(it++))
		{
			x=f(*it);v=s(*it);y=x%nw;
			ckmx(F[y],v+s*(x-y));
			ckmx(F[nw-1],v+s*((x+1)/nw*nw-nw));
		}
	}
	for(pair<LL,LL> pr:F)ckmx(ans,f(pr)*s+s(pr));
```

~~没人点赞惹~~，个人认为这篇题解写的挺好，思路更自然，虽然准确度相较就差了点，但还是希望能有人看见/kel

补充一点东西，巧妙之处与 AGC003E 的相通之处：

其实都在一个点上，就是使用了每个 $(i,a_i-1)$ 来转移，发现 AGC003E 也是使用了 $(i,q_i)$，从而实现类似记忆化的方式一起转移。

这道题本身 $(i,a_i-1)$ 就是最优决策点，我们又发掘信息使得转移可以在这些决策点直接进行，从而这样合并 DP 信息，相较于另一题更为自然（应该是吧）。