更新于 2021 年 11 月 11 日：修正了笔误

首先，开了一枪是空枪，说明当前位是 $0$，对于直接开一枪的情况，我们判断当前的 $0$ 下一位是 $0$（没子弹）还是 $1$（有子弹）。此时我们是不知道当前的 $0$ 是哪一位，所有考虑整个串中的 $0$ 的下一位，它的下一位可能是 $0$ 或 $1$，则下一枪没子弹的概率为$\frac{\textsf{（所有0中后面是0的情况）}}{\text{所有情况（所有0中后面是0或1的情况）}}$ 所有情况的个数即为串中0的个数。

对于转一转的情况，没子弹的概率即为$\frac{\textsf{0的个数}}{\text{串的长度（0和1的个数和）}}$ 。求出来以后比一比大小即可。

__注意__ 

1.由于子弹序列是环形序列，所以要将串尾特殊考虑，常用的方法是让序列复制一遍（即加上它本身）：

```string a; cin>>a; a+=a;```

2.比大小的时候可以将分式比较通过交叉相乘化为整数比较，避免了精度问题。

代码：

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
string a;
int main()
{
    while(cin>>a)
    {
        int l=a.length(); a+=a;//复制一遍
        int s=0,s1=0;
        for(int i=0;i<l;i++)
        	if(a[i]=='0')
			{
				s++;//统计0的个数
				if(a[i+1]=='0') s1++;//统计"00"子串的个数
			}
        if(s1*l>s*s) puts("SHOOT");//交叉相乘
        else if(s1*l==s*s) puts("EQUAL");
        else puts("ROTATE");
    }
    return 0;
}//结束啦awa
```