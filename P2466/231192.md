 具体怎么做各种大佬都讲清楚了，本蒟蒻来补充一些细节

 首先，这道题为什么是区间dp。
 
 ~~题做多了自然就知道了~~
 
 首先dp很明显，**选择这个球会让其他球的价值都减少，当前决策会影响到后面决策**
 
 （也是大佬们说的影响未来，后面会提到这一点）
 
 以下是解释，适合我这种入门区间dp的蒟蒻看，大佬请跳过啊
 

------------

 1.**对于球i到球j**
 
 首先我们可以看出，你从i跑到j，可以把中间所有的球都射了
 
 而射下来最后一颗球时肯定停留在i或者j（假如不是的话，你就要多跑好多冤枉路）
 
 
 我们可以从i直接跑到j
 
 也可以从i+1跑到j再跑回来
 
 也可以从i+1跑到i+n，再跑到i，再跑到j...
 
 这样的选择很多，所以我们可以把他缩成一个东西，这个东西**代表着这个区间所有决策的最优值**。这个东西就是dp数组啦（石子合并也是如此，你不知道他这段区间是怎么合并的）
 
所以状态就出来了：  _**dp[i][j][0]代表着第i个球到第j个球都射下来并最终停留在i的最优值，dp[i][j][1]则是停留在j的最优值**_  

为什么不以横坐标为区间呢？因为太多没用状态了，又可能有一段区间里面一个球都没有，而我们用球当区间，球之间的距离也可以O（1）算出来

2.**对于一个区间[i,j]**

dp[i][j][0]它可以由走完区间[i+1,j]，停留在i+1，向左走到球i转移过来，也可以由走完区间[i+1,j]，停留在j，向左走到球i转移

反之，dp[i][j][1]也可以这样子推

所以，**这些区间可以由子区间转移过来**，符合区间dp的要求

综上，区间dp成立（可能很啰嗦，说了很多重复的，请大佬勿喷啊qwq）

所以，在我们推这道题的做法的时候，我们其实已经有了转移方程的模板：[i,j]由[i+1,j]和[i,j+1]转移过来

我们推一推，可以发现，最后的答案是所有球的y值之和减去ti * vi 之和，ti是从出发射到这个球的时间，vi是这颗球的速度

所有，我们要让ti * vi之和越小越好，我们就拿dp数组去维护他

dp方程也就自然而然推出来啦

代码里也有注释qwq 后面还有内容哦


```cpp
#include <bits/stdc++.h>
using namespace std;
const int maxn=1e3+5;
struct pyf{
	int x,y,llw;
	friend bool operator <(pyf l,pyf f){
		return l.x<f.x;
	}
}a[maxn];
int n,x0;
int dp[maxn][maxn][2],sum[maxn];
int main(){
	scanf("%d%d",&n,&x0);
	for(int i=1;i<=n;i++){
		scanf("%d",&a[i].x);
	}
	long long ans=0;
	for(int i=1;i<=n;i++){
		scanf("%d",&a[i].y);
		ans+=a[i].y;
	}
	for(int i=1;i<=n;i++){
		scanf("%d",&a[i].llw);
	}
	memset(dp,0x3f,sizeof(dp));
	sort(a+1,a+1+n);//保证相邻编号是相邻的球，好转移
	for(int i=1;i<=n;i++){//一定要先排序再求前缀和...血的教训 
		sum[i]=sum[i-1]+a[i].llw;
	} 
	int pos;
	if(a[1].x>=x0){
		dp[1][1][1]=dp[1][1][0]=(a[1].x-x0)*(sum[n]);
	} 
	else if(a[n].x<=x0){
		dp[n][n][1]=dp[n][n][0]=(x0-a[n].x)*(sum[n]);
	}
	else{
		for(int i=1;i<=n;++i){
			if(a[i].x<=x0&&a[i+1].x>=x0){
				pos=i;
				break;
			}
		}
		dp[pos][pos][0]=dp[pos][pos][1]=(x0-a[pos].x)*(sum[n]);
		dp[pos+1][pos+1][0]=dp[pos+1][pos+1][1]=(a[pos+1].x-x0)*(sum[n]);
	}//把离原来位置最近的球赋上初值	
	for(int len=2;len<=n;len++){//len从1开始的话，全是非法的（除了一开始可以走的最近的点） 
		for(int i=1;i+len-1<=n;i++){
			int j=i+len-1;
			dp[i][j][0]=min(dp[i+1][j][0]+(a[i+1].x-a[i].x)*(sum[i]+sum[n]-sum[j]),dp[i+1][j][1]+(a[j].x-a[i].x)*(sum[i]+sum[n]-sum[j]));
			dp[i][j][1]=min(dp[i][j-1][0]+(a[j].x-a[i].x)*(sum[i-1]+sum[n]-sum[j-1]),dp[i][j-1][1]+(a[j].x-a[j-1].x)*(sum[i-1]+sum[n]-sum[j-1]));
		}
	}
	printf("%.3f\n",(ans-min(dp[1][n][0],dp[1][n][1]))/1000.000);
	return 0;
}
/*
3 0
-4 -2 2
22 30 26
1 1 8
*/
```
还有就是，我们需要把离出发点最近的点的dp值初始化一下。

### 整个dp过程可以看成一个小区间从出发点向左右拓展，并覆盖完所有的球

对于一些明显不是最优区间，我们还是转移的一个巨大的0x3f，所以遍历到他还是不会影响答案。

比如有四个球，1，2，3，4编号，x1=-4，x2=-2，x3=2，x4=6，x0=4

对于dp[1,2]他是非法，因为不经过3号球就只打1，2号
很蠢，我们完全可以在途中把3号打了。

最后记得排下序，好转移，再对速度求个前缀和

（按球的横坐标排序，让相邻编号的球之间没有球，不然就会出现上述的很多没用区间的情况，转移方程也会失效）