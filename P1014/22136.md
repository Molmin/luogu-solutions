让我们见证一下O(1)算法的降临。。。。。。

具体思路呢大概就是最快的办法，输入n，找到1+2+3+...+i>=n的第一个数并且保存和s。

然后s-=i，这样就保证比n小了。

接下来就看看规律了：

当这个i是偶数的时候（比如输入7，i就等于4），是从右上到左下排列；而奇数的时候，是从左下到右上排列的。并且分子分母之和为i+1.

所以呢，就要分两种情况：

偶数时，分子上是读入的n减去已经处理过的和s，分母上就是用总和（i+1）减去这个数，即i+1-(n-s)。所以这个数就是(n-s)/(i+1-n+s).

奇数时，情况正好是偶数时的倒数，即(i+1-n+s)/(n-s).

这就是基本思路。如果你用循环做的话大概不到sqrt(n)就够了。算得精确点就是floor((sqrt(1+8n)-1)/2)+1次。

但是你知道我这结果怎么得出来的么。。。。。。

用一个一元二次方程来求解我们的i，即i(i+1)/2=n

化成一般形式得n^2+n-2s=0

然后无脑公式法。。。

就得到了(sqrt(1+8n)-1)/2.

并且我们知道误差不会超过1，所以直接用floor。

这样，就可以通过公式直接得到我们的i以及s。

完美啊。。。。。。

```cpp
#include<iostream>
#include<cmath>
#include<cstdio>
using namespace std;
int main()
{
    int n,s;
    cin>>n;
    int i=floor((sqrt(1+8*n)-1)/2);
    s=i*(i+1)/2;
    if (n==s)
        s-=i;
    else
        i++;
    if (i%2)
        cout<<i+1-n+s<<'/'<<n-s;
    else
        cout<<n-s<<'/'<<i+1-n+s;
} 
传说中的O(1)算法【注：这是指常数级别，即没有一个循环】
```