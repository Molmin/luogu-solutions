\_\_\_\_\_\_\_其实我们可以把这道题放到矩阵中去想\_\_\_\_\_\_\_

———————————————————————

1     2     3     4     5     6     ........  （X轴）

1  ①   ②   ④   ⑦    ...

2  ③   ⑤   ⑧    ...

3  ⑥   ⑨    ...

4  ⑩    ...

5   ...

......
（Y轴）

————————————————————————

上图可知，每走一步 X-1，Y+1；

当X=0时，为一轮，也就返回Y=1；X为上一轮X+1；

于是我们可以单独记一下每轮的X，再记一个每轮走的XX；

于是乎~~~~代码出现了~~~~

————————————————————————





```cpp
#include <iostream>
#include <cstdio>
using namespace std;
int x,z,tot=1,n,yy,xx;
int main() {
    scanf("%d",&n);
    x=1;                    // x记的是每一轮的X的数值；
    xx=x;                  
    yy=1;                  //      从1，1开始走第一步
    while(1){
        if(tot==n)      //   tot记的步数，当走够时跳出；
            break;        
        xx--;
        yy++;          //     每走一步的坐标；
        if(xx==0){
            x++;
            xx=x;
            yy=1;
        }                     ////         判断这一轮走完！！！！！！
        tot+=1;          //       记步数~~~~
    }
    cout<<xx<<"/"<<yy;    //   神奇的输出答案~~~~~
    return 0;      //完美结束~~~~~~
}

```