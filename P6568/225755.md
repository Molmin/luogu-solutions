- **题意简化：** 给定一个数列与区间长度，求数列中最大的区间和。

- **为什么我们可以这样想呢？**

我们可以贪心地想一下，为了喝掉最多的水，肯定是要把可以倒的水全部倒到自己的杯子里。而且题目说了每杯水只能倒到后一个杯子里面，所以就是一直连续倒到后一个杯子，自己喝最后一杯就是最多的。~~（说了一大堆还不要是求区间加）~~

- **暴力 $O (n^2) $**

我们就直接暴力枚举左端点，左端点加上 $k$ 就得到了右端点，然后再对于这个区间求和。（这么看上去貌似是   $O(nk)$ 的，但是鉴于 $k \leq n-1$ 就夸张点写成 $O(n^2)$ 吧）

但是我们一看数据 ， $n\leq 10^6$ ，肯定会爆 $qwq$



- **前缀和优化 $O (n)$**

看到求区间和，我们很容易可以想到可以 $O(1)$ 搞出区间和的好东西：**前缀和**！！！

我们还是枚举左端点，然后算出右端点 ，再用前缀和求区间加，记录一下区间加的最大值就好啦！

~~其实这个复杂度还有一个不小的常数 ，不过还是能 $AC$ 的就不管了~~ 

- **代码如下**：


```cpp
#include<cstdio>
#include<algorithm>
using namespace std;

int q[1000005],maxx=0;//不用开 long long ，根据题目最大前缀应该是 int 能存下的
int a[1000005];

int main()
{
	//freopen("kettle.in","r",stdin);
	//freopen("kettle.out","w",stdout);
	int n,k;
	scanf("%d%d",&n,&k);
	for(int i=1;i<=n;i++)//输入数据，初始化前缀和
	{
		scanf("%d",&a[i]);
		q[i]=q[i-1]+a[i];
	}
	for(int i=1;i<=n-k;i++)//前缀和找最大区间加
	{
		maxx=max(maxx,q[i+k]-q[i-1]);
	}
	printf("%d",maxx);//输出
	//fclose(stdin);fclose(stdout);
	return 0;
 } 
```
