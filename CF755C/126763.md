## 题目大意

对于一张有$n$个点的无向图，每个点都连接着另一个点，求这张无向图中的连通块个数。$(1$<=$n$<=$10^4)$

## 题目算法

看到无向图求连通块，很自然地想到并查集。

并查集$（Union-Find Set）$：一个维护点之间连通性的数据结构，每个连通块都有一个代表元素，可以是该连通块的任意元素。在一开始，每个点都是自己所在连通块的代表元素。并查集的基本操作有三个。

1. 寻找一个点所在连通块的代表元素。

一直寻找这个点的连通块代表，直到这个点的连通块代表是它自己。

```cpp
int find(int x){return f[x]==x?x:f[x]=find(f[x]);}
```

这里展示的是带有路径压缩的版本，即每次寻找时把中途经过的点直接连到连通块的代表上，以缩短下次寻找时的路径长度。

2. 判断两个点是否处于同一连通块。

判断两个点所在的连通块代表是否为一个即可。

```cpp
find(x)==find(y)
```
3. 合并两个点所在的连通块。

先判断两点是否本就在同一连通块中，是则忽略，否则将一个点的连通块代表的连通块代表设置为另一个点的连通块代表即可。

```cpp
void un(int x,int y){if(find(x)==find(y)) return;f[find(y)]=find(x);}
```

注意到每次合并后连通块个数会$-1$, 一开始的连通块个数为$n$，借此可以统计最终连通块的个数。

带路径压缩的并查集时间复杂度为$O(nα(n))($其中$α(n)$为反阿克曼函数，增长很慢，可以近似视为常数$)$，可以通过本题。

## $AC$代码$(C++)$

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
int f[10010],cnt;
int find(int x){return f[x]==x?x:f[x]=find(f[x]);}//寻找点的连通块代表元素
void un(int x,int y){if(find(x)==find(y)) return;f[find(y)]=find(x);cnt--;}//合并两点所在的连通块
//合并成功则连通块个数-1
int main()
{
	int n;
	cin>>n;
	cnt=n;//初始化连通块个数
	for(int i=1;i<=n;i++) f[i]=i;//初始化并查集
	for(int i=1;i<=n;i++)
	{
		int x;
		cin>>x;
		un(i,x);//尝试合并，成功则减少连通块个数
	}
	cout<<cnt<<endl;
	return 0;
}
```