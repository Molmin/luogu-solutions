$\ \ \ \ \ \ \ $[luogu](https://www.luogu.com.cn/problem/UVA1452)，同步于[动态规划100题](https://www.luogu.com.cn/blog/blog10086001/dong-tai-gui-hua-100-ti)第18题。

$\ \ \ \ \ \ \ $注：以上皆为 0 开头，代表队伍中的 1，$n-1$ 代表第 $n$ 人。

$\ \ \ \ \ \ \ $这实际上是一个约瑟夫问题的一个变形。首先回到约瑟夫问题，它的实质是：将 $n$ 个人的子问题化成 $n-1$ 个，在同时建立一个映射关系，也就是我们的递推数组。我们要求最后一个人，就要倒退回去推出 $n$ 个人的情况。得到了最后一个人是谁，在倒推倒数第二人，倒数第三人即可。

$\ \ \ \ \ \ \ $所以我们定义 $dp_i$ 为 $i-1$ 个人出列后，接下来应该让谁出列（同时调整队列顺序与编号）。我们最后一个出列的人因为在队头，所以编号一定为 0。因此 $dp_1=0$。题目定义得出递推方程：

$$dp_{i-1}=dp_i-k(\mod i)$$

$\ \ \ \ \ \ \ $即：

$$dp_i=dp_{i-1}+k(\mod i)$$

$\ \ \ \ \ \ \ $考虑到我们要求倒数三个人，所以分别令 $dp_1=0,dp_1=1,dp_2=2$ 就可以分别求出倒数第一个，倒数第二个和第三个了。

$\ \ \ \ \ \ \ $这里就直接把数组滚了，代码会有点奇怪。因为 0 是开头，所以答案注意加 1。

$\ \ \ \ \ \ \ $滚了数组之后代码可能有点怪，可以自行理解一下。

```cpp
#include<cstdio>
#include<algorithm>
#include<queue>
using namespace std;
int main(){
	int T;
	scanf("%d",&T);
	while(T-->0)
	{
		int n,k;
		scanf("%d %d",&n,&k);
		int a=0,b=(k-1)%2,c=(k-1)%3;
		for(int i=2;i<=n;++i)	a+=k,a%=i;
		for(int i=3;i<=n;++i)	b+=k,b%=i;
		for(int i=4;i<=n;++i)	c+=k,c%=i;
		printf("%d %d %d\n",c+1,b+1,a+1);
	}
	return 0;
}
```