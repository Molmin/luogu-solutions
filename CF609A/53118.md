这道题就是说，在一个 $N$ 个数数组中，选尽可能少的数，使得这几个数的和大于或等于 $M$。

明显就是贪心——先选大的数。那为什么这种贪心策略是对的呢？下面是一个粗略的证明（临时想出来的）：

首先，为了方便，我们把这个长度为 $N$ 的数组定义成 $a[]$

定义一个函数 $f(M)$ ，这个函数就是在 $a[]$ 中，选尽可能少的数，使得这几个数的和大于或等于 $M$，这个至少数量就是 $f(M)$。

去求 $f(M)$ 时，可以分类讨论：

1. 假设我们选了 $a[i]$，接下来就变成了求 $f(M-a[i])+1$ 的问题；

2. 再假设我们选了 $a[j]$（$i\neq j$），但 $a[i]>a[j]$，那么接下来就变成了求 $f(M-a[j])+1$ 的问题。

但如何比较 $f(M-a[i])+1$ 和 $f(M-a[j])+1$ 的大小（也就是两种方案的优劣）呢？

容易知道在函数 $f(M)$ 中，当 $M$ 越大，$f(M)$ 也越大，**所以 $f(m)$ 是一个增函数**。

因为 $a[i]>a[j]$

所以 $M-a[i]<M-a[j]$

根据增函数的定义，$f(M-a[i])<f(M-a[j])$

即 $f(M-a[i])+1<f(M-a[j])+1$

所以，选第一种方案，也就是优先选更大的数更优。

如果看不懂就算了。现在，你就只需知道这种贪心策略是正确的。（fstqwq：主要是你谷上有老下有小我也很难过呀

程序：

```
#include<bits/stdc++.h>
using namespace std;
int n,m,a[102];
bool cmp(int num1,int num2){
	return num1>num2;
}
int main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++)
		cin>>a[i];
	sort(a+1,a+1+n,cmp);//从大到小排序 
	for(int i=1;i<=n;i++){
		if(a[i]>=m){
			cout<<i;//输出个数 
			return 0;
		}
		m-=a[i];
	}
	return 0;
}
```