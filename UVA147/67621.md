这道题的思路可以说是很好想的了

一道很裸的完全背包：

## 状态转移推导：

从题意中我们可以知道只有11种货币

有5分,10分,20分，50分，100分，200分,500分,1000分,2000分,

5000分,10000分

为什么这里一定都要化成美分呢？

因为数组下标都为整数，这样方便查询

## 那么状态转移：

设DP[i][v]为v分钱，选了前i种钱的方法总数

其实对于第i种货币我们有选和不选两种状态

所以可以很轻松的得到状态转移方程：

dp[i][v]=dp[i-1][v]+dp[i][v-a[j]];
但是我们可以很轻松的注意到

i这一维是可以省去的

所以总的状态方程就为：

dp[v]=dp[v-a[j]];

那么就有人问了

### 一道裸的完全背包为什么会成为蓝题难度呢?

好的

注意一下题目中的这句话

```cpp
每组数据输出的第一行包括该组数据
（有两个小数位，在宽度为6的字段中右对齐），
下一行是可能组成该组数据的方法数，
在宽度为17的字段中右对齐
```
没错，这个输出格式十分的鬼畜

emmm

还有一个坑点就是对于乘100后的精度

## 以上差不多就是这个题的坑点所在了

上代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[15]={5,10,20,50,100,200,500,1000,2000,5000,10000};
long long dp[30005];
int main(){
  dp[0]=1;
  for(int i=0;i<11;i++){
    for(int j=a[i];j<=30000;j++){
      dp[j]+=dp[j-a[i]];
    }
  }
  double tep;
  while(scanf("%lf",&tep)){
    if(tep==0.00){return 0;}
    int t=(int)(tep*100+0.5);
    printf("%6.2lf%17lld\n",tep,dp[t]);
  }
  return 0;
}

```
哦，好像要开long long（当然也只是好像）（毕竟我也没试过）