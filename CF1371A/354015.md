### 题意简述
有$n$个数组成的集合 $1,2,3,...,n$ ,进行若干次操作，每次从集合中选择两个数，相加后放回集合。求集合中最多有多少个数相等。
### 算法简析
还记得等差数列求和公式$S=\frac{n(a_1+a_n)}{2}$吗？这个公式当时是这么求出来的：
>当时高斯正在计算$1+2+3+...+100$，他发现可以将首部1和尾部100作和，变成101；同时$2+99=3+98=...=50+51=101$。经发现，这些等式共计50组，即原式的值是5050。

由此，恍然大悟：我们可以用这种思路，将这些木棍首尾相接。当$n\ mod\ 2 = 0$时，答案即为$\frac{n}{2}$（所有的木棍都能配对）；  
否则，当$n$是奇数时，我们就配对第$1$根和第$n-1$根，第$n$根不变，答案即为$\frac{n-1}{2}+1=\frac{n+1}{2}$。

### demo of c/cpp
```c
#include<stdio.h>
#define in(x) scanf("%d",&x)
#define out(x) printf("%d\n",x)
/*为了保证运行速度，在这里用scanf/printf进行输入/输出。*/
/*同时保证程序可读性，用宏定义in(x)和out(x)作为输入输出函数。*/
int main(){
	int t,x;
	in(t);/*多组数据*/ 
	while(t--){
		in(x);
		out((x+1)/2);
		/*C/C++有个特点，就是整数作除自动舍弃小数*/ 
		/*又因为当x为非负偶数时，floor((x+1)/2)==floor(x/2)*/
		/*所以可以直接输出(x+1)/2*/
	}
	return 0;
}
```
