题意梗概：

给出n个木棒，每根的长度为1..n，现在要求出用这些木棒能最多拼接成多少根长度一样的木棒。

首先看到此题的思路就是枚举。由于要求最多，所以长度越短越好。那么最好只需拼接两次。其实复杂度也不高，小模拟，但是模拟一下就能找出规律了。

先来看n = 1，这个不用说，肯定是1根。

再来看n = 2，此时有两根木棒，长度分别为1和2，显然答案只能为1.

接着是n = 3，此时有三根木棒，长度分别为1、2和3，若答案长度为1，显然不是最优解；若答案长度为2，也不是最优解；发现答案为3时得到正确答案，即1 + 2 = 3， 和3本身，答案为2。

在此不对以下案例做详解：

| n | 分解方式 | 答案 |
| :----------: | :----------: | :----------: |
| 1 | 1 | 1 |
| 2 | 1 ; 2 | 1 |
| 3 | 1+ 2 = 3 ; 3 | 2 |
| 4 | 1 + 4 = 5 ; 2 + 3 = 5 | 2 |
| 5 | 1 + 4 = 5 ; 2 + 3 = 5 ; 5 | 3 |
| 6 | 1 + 6 = 7 ; 2 + 5 = 7 ; 3 + 4 = 7 | 3 |


此时发现，如果n为偶数，那么ans = n / 2；如果n为奇数，那么ans = ( n + 1 ) / 2。进一步地，不论n的奇偶性，ans = ( n + 1 ) / 2。因为如果n是奇数，那么程序会自动向下取整。

有了通项，程序就很好写了，比赛的时候我为了保险开了long long，但是1e9范围应该是够的^_^

$\color{blue}\text{my code}$：

```cpp
#include <iostream>
#include <cstdio>
#include <cmath>
#include <algorithm>
using namespace std;

long long n , m;

int main() {
	
	cin >> n;
	while ( n-- ) {
		cin >> m;
		cout << ( m + 1 ) / 2 << endl;
	}
	
	return 0;
}
```