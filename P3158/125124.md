我的思路跟楼下有点类似，不过没有用容斥直接~~暴力~~递推的。

首先如果我们同时将同一类棋子一股脑放进去，他们会占领一些行或者列，这些行或者列不能是以前放的棋子占领过的，后面放的棋子也不能占领这些行和列（显然）。

于是我们考虑把这个放到我们的$dp$状态里去。设$dp[i][j][k]$为放了前$i$类棋子，已经有$j$行$k$列被占领的方案数。我们在转移的时候套路的枚举这一类的棋子们占据多少行多少列，那么现在就只有$n-j$行与$m-k$列供我们使用，我们可以直接把这玩意看做一个$(n-j)×(m-k)$的矩阵。

那么现在问题就转化为：求在一个$a×b$的矩阵中，放$p$个棋子并且占据$h$行$l$列（这两个是我们在转移的时候枚举的）的方案数。

直接用组合数算这个非常困难，我们考虑把这玩意也递推出来。于是~~像我一样无脑的~~就会设$f[i][j][k][l][m]$为这个矩阵是$k×l$的，已经填了$i$行$j$列，并且用了$m$个棋子的方案数，但是我们可以想象一下，如果我们不去考虑填的是这$k$行中的哪$i$行，或者填的是这$l$列中的哪$j$列，仅仅考虑在这$i$行$j$列中怎么填才能让每一行每一列都有棋子，我们发现前者与后者是独立的，所以我们可以把$f$消掉两维，即$f[i][j][k]$为在$i×j$的矩阵中填$k$个棋子，并且$i$行$j$列每一行列都有棋子的方案数，最后乘个$C_a^iC_b^j$即可。

考虑$f$的逐行递推，我们要在第$i$行填一些数，这些数可能不会填到原来的$j$列中去，相当于开辟了新的一些列，那么我们枚举$h$为这一行填了几个数，$l$为这$h$个数有多少是填在原有的$j$列中的，那么我们现在就有$j+h-l$列，但是原来的状态$f[i-1][j][k]$是在有$j$列的状态的方案数，相当于我们把前$i-1$行的$j$列分散（这个可以想象一下）成$j+h-l$列，所以要乘个$C_{j+h-l}^j$即为分散开的方案数，然后这$h-l$个数相当于填到了原来不存在的的空列上，空列本来就是$h-l$个我们不用管他，但是这$l$个数是要填到原来的$j$列上的，到底填到哪我们不知道，或者说就是他随意的，那么就乘个$C_j^l$即可，哦对了填了$h$个数之后已经填了$k+h$个数，所以$f$的递推式（这个可以叫递推式吗我也不知道qaq）为：

$f[i][j+h-l][k+h]+=C_j^lC_{j+h-l}^jf[i-1][j][k]$

这里再多说几句，可能有的人会觉得“从$h$个数里拿出来$l$个放到原序列中这难道不要乘$C_h^l$吗？”，这显然不对啊，我们现在递推的这个$f$数组相当于放的棋子都是一样的，我们枚举$h$确实是相当于有$h$个棋子排成一排等着我们拿然后往矩阵里放，乘个$C_h^l$就相当于拿掉$l$个之后剩下的这排棋子长啥样的数量，但是这跟我们求的完全没有关系啊……剩下的这些棋子肯定也得放到矩阵里去，这是以什么方式放的并不会对答案造成影响，我们只关心他最终放到了哪有多少种方案。举个非常贴切的的现实例子，在盖楼的时候需要把沙子倒到工地上，我们把它堆的造型摆的好看一点，但是沙子最终是用来盖楼的，这个楼长得好不好看跟在工地上堆沙子的时候摆的造型有关系吗？没有。所以乘上$C_h^l$答案就乱了，我觉得这个可能是这种组合计数$dp$中的一个比较困难的坑。

于是把$f$数组递推出来后，$dp$数组就很容易就求出来了，我们枚举这类棋子占了$h$行$l$列，然后递推式长这样：

$dp[i][j+h][k+l]+=C_{n-j}^hC_{m-k}^lf[h][l][a_i]*dp[i-1][j][k]$

总结一下，对于这类组合计数$dp$，我们应该考虑的是能用的大致特征，比如有多少行多少列，而不应该过多的考虑特别具体的状态，~~所以在很多这样的题中状压$dp$都成了暴力~~

上代码~

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#define ll long long
#define p 1000000009
using namespace std;
int c[31][31],f[31][31][1001],dp[11][31][31];
int ints[11];
int main() {
	int n,m,C;
	cin>>n>>m>>C;
	int mx=0;
	for(register int i=1; i<=C; i++)cin>>ints[i],mx=max(mx,ints[i]);
	c[0][0]=1;//递推出组合数 
	for(register int i=1; i<=30; i++) {
		c[i][0]=1; 
		for(register int j=1; j<=i; j++)c[i][j]=(c[i-1][j]+c[i-1][j-1])%p;
	}
	f[0][0][0]=1;//对f的递推 
	for(register int i=1; i<=n; i++) {
		for(register int j=0; j<=m; j++) {
			for(register int k=0; k<mx; k++) {//枚举上一行的状态（我是顺推做的，感觉在这种题里顺推会比较好用） 
				if(!f[i-1][j][k])continue;
				for(register int h=1; h<=m; h++) {//枚举这行放多少个 
					for(register int l=0; l<=min(h,j); l++) {//枚举有多少个放到了原来列里 
						if(j+h-l>m)continue;
						ll cjr=f[i-1][j][k];//这个见递推式1 
						cjr*=c[j+h-l][j];
						cjr%=p;
						cjr*=c[j][l];
						cjr%=p;
						f[i][j+h-l][k+h]+=cjr;
						f[i][j+h-l][k+h]%=p;
					}
				}
			}
		}
	}
	dp[0][n][m]=1;//对dp的递推 
	for(register int o=1; o<=C; o++) {
		for(register int i=1; i<=n; i++) {
			for(register int j=1; j<=m; j++) {//枚举上一类棋子的状态 
				if(!dp[o-1][i][j])continue;
				for(register int h=1; h<=i; h++) {//枚举放了多少行 
					for(register int k=1; k<=j; k++) {//枚举放了多少列 
						ll cjr=dp[o-1][i][j];//这个见递推式2 
						cjr*=f[h][k][ints[o]];
						cjr%=p;
						cjr*=c[i][h];
						cjr%=p;
						cjr*=c[j][k];
						cjr%=p;
						dp[o][i-h][j-k]+=cjr;
						dp[o][i-h][j-k]%=p;
					}
				}
			}
		}
	}
	ll ans=0;
	for(register int i=0; i<=n; i++) {//统计答案 
		for(register int j=0; j<=m; j++) {
			ans+=dp[C][i][j];
			ans%=p;
		}
	}
	cout<<ans<<endl;
	return(0);
}
```