### Preface  
本篇文章是基于作者稀烂的数学功底，为了熟悉计数 dp 题型才写出来的，大佬轻喷。  
### Problem  
在一个 $m$ 行 $n$ 列的棋盘里放 $q$ 种颜色，第 $i$ 个颜色的棋子有 $c_i$ 个，一共 $w$ 个的棋子，使得每个格子最多放一个棋子，且不同颜色的棋子不能在同一行或者同一列，有多少种方法？  
其中 $n,m\leq 30,q\leq 10,w\leq \min(n \times m,250)$
### Solution  
首先看到如此之小的数据范围，肯定有些人第一时间想到状压，但是这道题的数据范围对于状压来说太大了，所以要考虑一种复杂度很大的多项式做法。  

我们似乎发现了一个性质：当前如果已经选完了一些颜色的棋子，被占领的行列数量相等的棋盘状态们的后续选择数目相等。具体为什么各位可以理解一下，其实还蛮简单的，我们把被杀掉的行列拿出来之后得到的空矩阵是完全相等的，在里面可以随便选择。    
于是我们搞出了一个无后效性的 dp 状态：$f_{i,j,k}$ 代表选择到第 $i$ 个颜色的棋子，占领了 $j$ 行 $k$ 列的选择数。  
按照一般的剧本，接下来我们要搞出一个转移方程，那么：  

$f_{i,j,k}=\sum_{l=0}^{j-1}\sum_{r=0}^{k-1}f_{i-1,l,r}\times g_{j-l,k-r}\times C_{n-l}^{j-l} \times C_{m-r}^{k-r}$  

其中，$g_{j,k}$ 为利用第 $i$ 种颜色的棋子数占领（全覆盖） $j$ 行 $k$ 列的空矩形的方案数，显然这样就可以占领 $j$ 行 $k$ 列，这两者等价。  

这个转移方程的大致意思是：首先通过前一种颜色转移没有问题，然后我们枚举前一种颜色占领的行列数，然后计算从那个行列数转移到现在行列数的方案数，然后由于现在有 $n-l$ 行和 $m-r$ 列可供占领，可以随便选而组成一个空矩形，所以我们还要乘上这两个的组合数。  

我们突然发现 $g$ 我们是不会算的，但是这个东西一脸可以直接 dp 的样子，这个玩意正着来算不太好算，我们正难则反，这样转移：  

$g_{j,k}=C_{j\times k}^{c_i}-(\sum_{l=1}^{j}\sum_{r=1}^{k}g_{l,r}\times C_j^l\times C_k^r\times[(l<j)|(r<k)])$  

我们再来解释一下这个东西是什么意思：首先我们要在 $j\times k$ 个格子中选 $c_i$ （该颜色棋子数）个。但是这个东西不能保证全覆盖，首先覆盖肯定为一个矩形，我们需要减掉不是全覆盖的情况，思考一下什么情况不会全覆盖？很显然如果矩阵中有点上下或左右没有棋子就不会全覆盖，这种情况所有的点的覆盖肯定会组成一个不等于该矩阵的其的子矩阵（可以非连续），而这个子矩阵是全覆盖的，于是我们枚举一下其的子矩阵的 $g$ 与其可能出现的位置个数（由于矩阵可以随意拆分，所以可以切成若干部分）。减掉就好了。从另一角度说，我们减掉的是我们枚举其中有子矩形全覆盖形态的所有不合法子矩形。  
（定义全覆盖是指矩阵内所有点的上或下与左或右都有棋子，覆盖是一个由满足上或下与左或右都有棋子的点组成的点集。）

最后，我们没要求棋盘要全覆盖，所以答案：  
$\sum_{i=1}^n \sum_{j=1}^m f_{q,i,j}$  
code：  
```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
const int N=35;
const int M=300;
const int mod=1e9+9;
ll n,m,q;ll c[M];
ll f[M][N][N];ll g[N][N];
ll C[1010][1010];ll cmax;
int main(){
	cin>>n>>m>>q;
	for(int i=1;i<=q;i++)cin>>c[i],cmax=max(cmax,c[i]);
	for(int i=0;i<=n*m;i++)C[i][0]=1;
	for(int i=1;i<=n*m;i++)
		for(int j=1;j<=i;j++)
			C[i][j]=(C[i-1][j]+C[i-1][j-1])%mod;
	f[0][0][0]=1;
	for(int i=1;i<=q;i++){
		memset(g,0,sizeof(g));
		for(int j=1;j<=n;j++){
			for(int k=1;k<=m;k++){
				if(j*k>=c[i]){
					g[j][k]=C[j*k][c[i]];
					for(int l=1;l<=j;l++){
						for(int r=1;r<=k;r++){
							if(l<j||r<k)
								g[j][k]=(g[j][k]-g[l][r]*C[j][l]%mod*C[k][r]%mod+mod)%mod;
						}
					}
				}
			}
		}
		for(int j=1;j<=n;j++){
			for(int k=1;k<=m;k++){
				for(int l=0;l<j;l++){
					for(int r=0;r<k;r++){
						if((j-l)*(k-r)>=c[i]){
							f[i][j][k]+=f[i-1][l][r]*g[(j-l)][(k-r)]%mod*C[n-l][(j-l)]%mod*C[m-r][(k-r)]%mod;
						}
						f[i][j][k]%=mod;
					}
				}
			}
		}
	}
	ll res=0;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			res+=f[q][i][j],res%=mod;
	cout<<res;
	return 0;
}
```

