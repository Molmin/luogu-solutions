一道数学题，有一点思维难度，代码难度为0。

思路：

每一次选的数都得相同，才可能打开所有的门。

观察题目可以发现，这个数列是单调不下降的，所以我们从后往前考虑。

先考虑 $i = n$ 的情况：站在 $1$ 号门前，移动 $n$ 步后，又回到了 $1$ 号门，死循环了，所以不考虑。

而在 $i = n-1$ 的情况下，可以走到所有的门。以此类推，前面的其实都可以。但是由于数列的单调性，最后一个可行的肯定是代价最小的，所以我们选择 $i = n-1$。一共要走 $n$ 次。

注意：刚开始你在 $1$ 号门，是不可以直接将他打开的，你要先走 $n$ 步将 $1$ 号门打开才可以继续走，不然 $1$ 号门就需要花费 $C_{n-1}$ 的代价来打开，而 $C_{n-1}$ 是有可能大于 $C_n$ 的，所以为了全部 AC，需要用 $C_n$ 的代价走，这样走 $n-1$ 步的次数就变成了 $(n-1)$ 次。不难写出代码：

```cpp
cout << C[n] + C[n-1] * (n-1) << endl;
```

小坑点：不开long long 见祖宗哦。