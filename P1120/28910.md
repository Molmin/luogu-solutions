## 答案可能的范围

首先，我们需要知道，答案的最小值肯定不会小于木棍长度的最大值。

其次，假设把所有小木棍全都拼成一根木棍，长度为所有木棍长度的和，答案肯定不会超过这个和。

---

## 什么样的答案可行

设第$i$根木棍的长度为$a_i$，则和$s=a_1+a_2+a_{...}+a_n$。

考虑枚举拼接后的每根木棍长度为$m$，当$m|s$时可行。

---

## 对数据的排序

在本题中，对木棍长度的排序可不仅起到优化搜索顺序的作用，这是程序一个重要剪枝的基础。

本题中需要对木棍的长度进行升序排序，具体原因将在下面解释。

---

## 避免不可能情况下的重复搜索

在本题的搜索过程中，我们有一个原则，即当$a_i=a_{i-1}$且第$i-1$根木棍没有被选取的情况下，第$i$根也不选取。

为什么呢，因为我们在尝试完成一根长度不超过所枚举的$m$的木棍时，是按照从$1$到$n$每一根考虑的，当在过程中放弃一根木棍时，放弃的是和这一根木棍所有相同长度的木棍。

---

## 满足条件后不再搜索

设当前考虑第$i$根木棍，这一根木棍已经拼接了$l$的长度，当$l+a_i=m$时，不再搜索第``i+1``到第``n``根木棍，因为他们肯定在这根木棍中不符合条件。

---

## 代码和细节

code:

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
#define maxn 67
int n,ans,h,a[maxn],m,ma,j=1;
bool vis[maxn],flag=0;
bool comp(int a,int b)
{
    return a>b;
}//用于sort的比较函数
void f(int u,int l,int c)//u代表已经使用的初始木棍数目，l代表当前拼的木棍的当前长度，c代表上一次选择木棍的位置+1，即现在选择木棍时的编号起始
{
    if(flag) return;//如果已经找到一个可行解，由于是从小到大枚举长度，所以一旦找到可行解，就一定是所求的最优解
    if(l==m)//如果当前拼的这根木棍已经正好为长度为m的木棍，即我们要拼的长度
    {
        if(u==n)//如果木棍已经使用完毕，即找到可行方案
        {
            flag=1;//作出标记
            return;//返回
        }
        else
        	l=0,c=1;//否则开启一根新的木棍，新的木棍当前长度为1，每一根新的木棍都从第一个开始
    }
    if(!l)//如果是新的木棍
    {
        int fff=0;
        while(vis[++fff]);
        vis[fff]=1;//找到编号最小且没有使用过的初始木棍，即当前还可用的最短的初始木棍，fff为这根木棍的编号
        f(u+1,l+a[fff],fff+1);//继续向下搜索
        vis[fff]=0;//回溯
        return;
    }
    for(int i=c;i<=n;i++)//从上一个选择的木棍下一个开始搜索，直到第n个
    {
        if(!vis[i]&&a[i]+l<=m)//如果这根木棍没有用过且在长度上可行
        {
            if(!vis[i-1]&&a[i]==a[i-1]) continue;//是否为不可能情况下的重复搜索，如果是，则不考虑这根木棍
            vis[i]=1;//符合条件，继续搜索
            f(u+1,a[i]+l,i+1);
            if(flag) return;//如果找到答案则直接返回
            vis[i]=0;//回溯
            if(l+a[i]==m) break;//如果这根初始木棍是当前形势下的可取的最长值，不考虑后面的木棍
        }
    }
}
int main()
{
        scanf("%d",&n);
        for(register int i=1;i<=n;i++)
        {
            scanf("%d",&a[j]);
            if(a[j]<=50)
            {
                h+=a[j],ma=max(ma,a[j]);
                j++;
            }
        }
        n=--j;//输入、忽略超过50的，求和
        sort(a+1,a+n+1,comp);
        for(register int i=ma;i<=h;i++)
        {
            if(h%i==0)//如果能够整除，则当前长度可能存在答案，开始搜索
            {
                m=i;
                f(0,0,1);
                if(flag)
                {
                    printf("%d\n",i);
                    break;
                }
            }
        }
}
```
