这道是一题经典的二维和数组。下面我们来讲一讲什么是二维和数组。

同一维和数组一样，分为预处理和计算两部分。我将对这两个部分进行详细讲解。

先说说预处理，一维和数组的 $b[i]$ 代表编号 $1$ 到编号 $i$ 的和，而二维和数组，变量是 $b[i][j]$ ,那么它代表什么呢？它代表左上角编号为 $(1,1)$ ,右下角编号为 $(i,j)$ 的矩阵的和。那怎么算呢？先上代码：

	for(i=1;i<=n;i++){
		for(j=1;j<=m;j++){
			b[i][j]=b[i-1][j]+b[i][j-1]-b[i-1][j-1]+a[i][j];//核心代码
		}
	}
    
我们来看看核心代码部分，b数组是前缀和，a数组是读入的。那为什么可以这么算呢，我们来用一个表表示一下（表中的数代表被加了或减了几次）（设 $i=3$ , $j=4$）：

| 1+1-1 | 1+1-1 | 1+1-1 | 1 | 0 | 
| :----------: | :----: | :----------: | :----------: | :----------:|
| 1+1-1 | 1+1-1 | 1+1-1 | 1 | 0 | 
| 1 | 1 | 1 | 1 | 0 | 
| 0 | 0 | 0 | 0 | 0 | 

化简，得：

| 1 | 1 | 1 | 1 | 0 | 
| :----------: | :----------: | :----------: | :----------: | :----------:|
| 1 | 1 | 1 | 1 | 0 | 
| 1 | 1 | 1 | 1 | 0 | 
| 0 | 0 | 0 | 0 | 0 | 

好神奇的嘞！用这种公式，可以正好算出 $b[i][j]$ 的值。

好我们再讲讲计算部分，先上代码：

	for(i=1;i<=n;i++){
		int k=i+c-1;
		if(k>n)break;
		for(j=1;j<=m;j++){
			int h=j+c-1;
			if(h>m)break;
			int sum=b[k][h]+b[i-1][j-1]-b[i-1][h]-b[k][j-1];//核心代码
			//if(sum>ans){//更新max
				//ans=sum;h1=i;h2=j;
			//}
		}
	}
有了上一题的经验，大家可以像我一样画个表把核心代码表示出来，我在这里就不多说了 ~~最主要是因为懒~~ 。

好上总代码：

	#include<stdio.h>
	using namespace std;
	int a[1005][1005],b[1005][1005];
	int main(){
		int n,m,c,i,j;
		scanf("%d%d%d",&n,&m,&c);//输入
		for(i=1;i<=n;i++){
			for(j=1;j<=m;j++){
				scanf("%d",&a[i][j]);
			}
		}
		for(i=1;i<=n;i++){
			for(j=1;j<=m;j++){
				b[i][j]=b[i-1][j]+b[i][j-1]-b[i-1][j-1]+a[i][j];//预处理核心代码
			}
		}
		int ans=-2147483648,h1=0,h2=0;
		for(i=1;i<=n;i++){//开始计算
			int k=i+c-1;
			if(k>n)break;//特判
			for(j=1;j<=m;j++){
				int h=j+c-1;//注意，(i,j)代表矩阵左上角,(k,h)代表矩阵右下角
				if(h>m)break;//特判
				int sum=b[k][h]+b[i-1][j-1]-b[i-1][h]-b[k][j-1];//计算核心代码
				if(sum>ans){//更新max
					ans=sum;h1=i;h2=j;
				}
			}
		}
		printf("%d %d",h1,h2);
		return 0;
	}
好了，题解到此结束，拜拜~~~~~

