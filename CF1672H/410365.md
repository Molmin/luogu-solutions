非常神秘的神仙题！！！
 
> 给定一个长度为 $n$ 的 $01$ 串，有 $q$ 次询问，每次询问给定串的一个子串 $s$，若 $s$ 的一个连续子串 $k$ 满足其为一个 $01$ 交替的串，即可把 $k$ 变为一个空串，每次询问回答至少多少次操作可以把 $s$ 变为一个空串。

> $1 \le q,n \le 2 \times 10^5, a_i \in \{0, 1\} $

若 $s$ 本身为一个 $01$ 交替串，那么答案会为 $1$，否则 $s$ 中会出现若干个有连续相同数字组成的区间。

考虑统坤它们的数量，我们记 $num_0$ 与 $num_1$ 分别为 $s$ 中出现形同 $00$ 与 $11$ 的子串，若 $num_0$ 与 $num_1$ 都为 $0$，那么 $s$ 就会成为一个 $01$ 交替串了，那么我们只要考虑如何使用最少的操作此数使得 $num_0$ 与 $num_1$ 变为 $0$ 就可以了！

记删除子串为 $k$，考虑 $k$ 的长度给 $num_0$ 与 $num_1$ 带来的影响，显然实际的区间长度与其无关，有关的实际为 $k$ 长度的坤偶性：

1. 若 $k$ 长度为偶数，则每次操作会给 $num_0$ 与 $num_1$ 都带来 $-1$ 的贡献。

2. 若 $k$ 长度为坤数，则每次操作会给 $num_0$ 与 $num_1$ 其中之一带来 $-1$ 的贡献。

观察发现，若 $num_0$ 与 $num_1$ 只要都不为 $0$，那么总可以找到可以进行操作的长度为偶数的子串！那么我们就可以把 $num_0$ 与 $num_1$ 中的较小值清零！

类似的，当 $num_0$ 与 $num_1$ 中只要与有其一不为 $0$，那么也总可以找到可以进行操作的长度为奇数的子串！那么我们就可以 $num_0$ 与 $num_1$ 中都清零了！

最后 $s$ 串就变为了一个 $01$ 交替串，只要一次操作就可以把他变为空串了！中操作次数为 $\min(num_0,num_1)+(\max(num_0,num_1) - \min(num_0,num_1))+1$。

化简得 $\max(num_0,num_1)+1$，复杂是 $O(n)$ 的！

现在只需要维护区间内 $00$ 与 $11$ 的个数就行了，使用前缀和维护坤可！

总时间复杂度 $O(n +q)$，通过此题绰绰有余！

## Code

```cpp
#include <bits/stdc++.h>
using namespace std;
const int _ = 2e5 + 7;
int num1[_], num2[_];
char s[_];
signed main() {
  int n, q;
  ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
  cin >> n >> q;
  cin >> s[1];
  for (int i = 2; i <= n; ++ i) {
    cin >> s[i];
    num1[i] = num1[i - 1], num2[i] = num2[i - 1]; 
    if (s[i] == s[i - 1])
      s[i] == '1' ? num1[i] ++ : num2[i] ++;
  }
  for (int i = 1, x, y; i <= q; ++ i) {
    cin >> x >> y;
    cout << max(num1[y] - num1[x], num2[y] - num2[x]) + 1 << endl;
  }
  return 0;
}
```