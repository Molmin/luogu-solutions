
[题目链接](https://www.luogu.com.cn/problem/SP28307)

## 思路 && 最优策略证明

一道简单模拟 $+$ 简单贪心题。对于每次得到的数，用 $\rm{while}$ 循环来模拟每次变化将某数位上的数加 $1$，次数用完后再进行总判断，输出结果。

那么，思路知道了，最优策略该怎么证明呢？我们都知道，让一个数变得更大，最好的办法就是在最高位加 $1$，但本题目明确说明，如果此位数为 $9$，在增加 $1$ 后将变成 $0$。那我们就可以用 $\rm{if}$ 语句从高位到低位进行判断，如果该位上的数小于 $9$，就增加 $1$，否则就判断下一位。如果一直判断到个位都是 $9$ （现在数已经是 $9999$），那么就将个位变成 $0$，这样损失最小。

------------

## 坑点：
- 更改后的数必须要大于原数，不可以等于。
- 每次更改都必须是当前的最优策略。

参考代码（请勿抄袭）：
```cpp
#include<bits/stdc++.h>
using namespace std;
int t,a[10],v[10],n;//用数组存储每位数，比较简便 
string s1;//一开始输入的用字符串输入，方便转换

void toint(){//将字符串转成数字放入数组中 
	for(int i=0;i<s1.size();i++){
		a[i+1]=s1[i]-'0';//转换必备知识 
	}
}
bool pan(){
	bool flag[5];//判断是否相同 
	memset(flag,true,sizeof(flag));//别忘了初始化 
	for(int i=0;i<4;i++){
		if(a[i+1]<(s1[i]-'0')) return false;//如果有一位小于原数，直接返回不成立 
		else if(a[i+1]==(s1[i]-'0')) flag[i+1]=false; //如果相等，将flag数组相应位数内的值定为false 
	}
	for(int i=1;i<=4;i++){
		if(flag[i]) return true;//如果有一位不相等，加上我们之前判断了，一定不会小于，就可以直接返回成立了 
	}
	return false;//如果都相等，不符合条件 
}
int main(){
	scanf("%d",&t);//输入t 
	for(int i=1;i<=t;i++){//每次判断并且输出 
		cin>>s1;//输入字符串（原数）
		scanf("%d",&n);//输入转换次数  
		toint();//转换成数字存入a数组内 
		while(n){//转换 
			n--;//记得减少n的值 
			//最优策略（详看题解说明） 
			if(a[1]<9) a[1]++;
			else if(a[2]<9) a[2]++;
			else if(a[3]<9) a[3]++;
			else{//也可以用while,因为如果都判断到这一步了，下一步就可以直接忽略前三次判断了 
				a[4]++;
				if(a[4]==10) a[4]=0;
			} 
		}//while循环结束 
		pan()?cout<<"Ada"<<endl:cout<<"Vinit"<<endl;//对于每次输入，操作结束后就应输出结果并换行 
		/*
		等同于：
		if(pan()){
			cout<<"Ada"<<endl;
		}
		else{
			cout<<"Vinit"<<endl;
		}
		*/
	}
	return 0;
}

```