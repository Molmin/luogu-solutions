首先肯定是要对品质 $q_i$ 进行排序。

朴素的暴力，枚举每一个人，然后依次考虑每件物品，能买则买。

但是注意到每个人的钱数会实时变化，而又要比较大小关系，所以很难维护。

换个角度，先枚举物品 $i$，然后考虑这个物品对每个人 $j$ 的贡献，若 $v_j\ge c_i$，那么就将 $v_j$ 减去 $c_i$，然后 $j$ 的答案加 $1$。

这个问题就好做多了，因为它是一个全局的减。具体的，我们可以抽象成这样一个问题：

> 给定 $m$ 个数 $v_1,v_2,\cdots,v_m$，$n$ 次操作，每次将 $\ge c_i$ 的数减去 $c_i$，问每个数你能被操作几次。

很容易想到平衡树维护 $v$ 数组，每次将 $\ge c_i$ 的部分进行 $\text{split}$，然后打标记并进行合并。

但是这样做会有问题。

考虑 $[0,c_i)$ 部分的值不会变，$[c_i,2c_i)$ 部分的值会变成 $[0,c_i)$ 部分的值。而如果将这两个平衡树进行合并，大小关系不确定，合并出来的东西可能就不是平衡树。而 $[2c_i,\infty)$ 部分的值不需要考虑值的大小关系，因为它们减去 $c_i$ 之后是必定不小于 $c_i$ 的。

我们考虑对 $[c_i,2c_i)$ 这个部分减去 $c_i$ 后暴力插入进 $[0,c_i)$ 的部分。

分析一下复杂度，这个很有意思，我们考虑每人钱数 $v_j$ 的变化。

如果 $v_i$ 需要被暴力插入，说明 $c_i\le v_j<2c_i$，得出，$c_i>\frac{v_j}{2}$，也就是说，每次 $v_j$ 减去的数至少是它的一半，最多会被暴力插入 $\log$ 次，算上平衡树一个 $\log$，最后复杂度俩老哥。