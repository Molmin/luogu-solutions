既然每头牛都要去另一头牛那里，我们就可以用一个图来表示这些情况。

那么，$N$ 个点 $N$ 条边是什么图呢？

因为 $N$ 个点 $N-1$ 条边是一棵树，那么树加一条边就是传说中的**基环树**。

所谓基环树，就是树上有了一个环（普通的树是双向边，在哪里加一条边都有环）。

不过，这个图不一定联通，我们就只能称其为**基环树森林**。

我们把它分成两个部分：主干部分（环）和分支部分（环外面的枝杈）。

因为每头牛只会想去一个地方，所以这个有向图的分支部分都是从外面连向环上的点。我们如果想要求出最大边权和，分支部分肯定是可以通过拓扑排序的方式全都得到，然后连到环上。

因为环是一个环，因此他必须会有一条边的边权无法获得。为了让我们的答案尽量大，肯定选边权最小的那一条不获得。

在实际计算过程中，在从一个节点访问时遇到一个访问过的节点时，会有两种情况：

1. 遇到了自己访问的路上的节点，说明这条路上有环，而且这个节点一定是环上的点
2. 遇到了别的路上的节点，就不用继续访问了

遇到有环的话，我们就从这个环上的点往回找，直到再找到他，这个过程中就可以找最小边权了。

代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[100005],v[100005],vis[100005];//vis为0表示没访问过，为1表示是现在路上的，为2表示是其他路上的
long long tot,ans;
int mn(int u){//在路上取最小边权
	int res=v[u];
	for(int i=a[u];i!=u;i=a[i]) res=min(res,v[i]);
	return res;
}
void end(int x){//把所有自己路上的都改成“别的路上的”，说明遍历结束
	while(vis[x]==1) vis[x]=2,x=a[x];
	return;
}
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>a[i]>>v[i];tot+=v[i];//计算总边权和
	}
	int x;
	for(int i=1;i<=n;i++){
		if(!vis[i]){//没有访问过
			x=i;
			while(!vis[x]){//一直往前找
				vis[x]=1;
				x=a[x];
			}
			if(vis[x]==1) ans+=mn(x);//ans表示要减去的所有边权
			end(i);//遍历结束
		}
	}
	cout<<tot-ans<<endl;//总的减去不能获得的，就是答案
	return 0;
}
```