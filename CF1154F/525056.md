# 题目分析

首先，读完题后我们可以明晰一个东西，这道题明显所求是最小花费，那么对于这一类最优解问题我们可以用到贪心或者是动态规划一类的算法解决，而用于这道题上，我的第一个想法就是结合贪心思想再使用 DP 进行解决

# 思路解析

那么题目中给出的问题是求买 $k$ 双鞋子所需要的最少的钱，那么~~傻子~~我们都知道要想钱最少，我们肯定在单价最少的前 $k$ 双鞋上做文章，也就是我们可以对原数据进行一个排序处理，这里就用到了贪心的思想；接着，我们可以对排好序的数组做一个前缀和的处理，从而可以通过简单计算得到区间和，方便我们之后的计算。

接下来是重点，有了我们预处理所得到的材料，那么我们怎么进行 DP 的转移呢？首先，我们考虑最基本的前 $k$ 双鞋子需要的钱，也就是不用任何优惠劵，那么就是前 $k$ 个数的前缀和，这里我们用 $pre_{k}$ 来表示，对于我们的状态数组可以定义为: $\mathit{dp}_{i}$ 表示前 $i$ 双鞋子我们利用优惠劵所得的最大优惠价格。那么有了这个状态，我们的答案无疑就存储在 $\mathit{pre}_{k} - dp_{k}$ 中。

有了最基本的状态，接下来我们需要解决的是如何进行状态转移，因为每一张优惠券可以重复使用，这里我们可以定义一个  $\mathit{buy}_{x} = y$ 的形式，表示买 $x$ 双鞋我们最多有 $y$ 双鞋可以不用付钱，其根本目的是过滤掉不是最优的优惠券，这样可以保证我们所取的优惠券都是 **当前状态下最优的**。

接下来我们的转移也就迎刃而解了，对于我们的 $\mathit{dp}_{i}$ 我们可以不断枚举 $j$ 来更新它，每一个 $\mathit{dp}_{j}$ 加上  $\mathit{pre}_{j + \mathit{buy}_{i - j}}$ 再减去 $pre_{j}$ 所得的值就是我们当前状态下的优惠值，那么为什么 $\mathit{pre}_{j + \mathit{buy}_{i - j}} - pre_{j}$ 就是我们这一 $i - j$ 段的所得优惠呢？我们可以明晰, $\mathit{buy}_{i - j}$ 的实际意义是买 $i - j$ 双鞋可得的最多不用付钱的鞋的数量，$i - j$ 也就是 $i$ 比 $j$ 多出来的那一段鞋的数量,那么对于本身的 $j$ ,加上这一段后再减去 $\mathit{pre}_{j}$ 所得及是多出来的那一部分不用付钱的鞋的钱的总数，再结合我们 DP 的状态，应该直接累加。

# AC CODE

```cpp
#include <bits/stdc++.h>
#define maxn 200005
using namespace std;
int dp[maxn], pre[maxn], buy[maxn], a[maxn];
int n, m, k;
int main() {
	//memset(buy, -0x3f3f3f3f, sizeof(buy));
	cin >> n >> m >> k;
	for (int i = 1, x; i <= n; i++)
		scanf("%d", &a[i]);
	sort(a + 1, a + n + 1);
	for (int i = 1; i <= k; i++)
		pre[i] = pre[i - 1] + a[i];
	for (int i = 1; i <= m; i++) {
		int x, y;
		scanf("%d %d", &x, &y);
		buy[x] = max(buy[x], y);
	}
	for (int i = 1; i <= k; i++) {
		for (int j = 0; j < i; j++) { // j不能比i大或者等于i
			dp[i] = max(dp[i], dp[j] + pre[j + buy[i - j]] - pre[j]); // 转移
		}
	}
	cout << pre[k] - dp[k] << endl;
}
```
