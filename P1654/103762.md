**本文中的^指的都是幂运算**

先申明一点，这个分数是这么计算的：连续的1有x个，那么分值为x^3

### 下面开始真_题解

我们先审题，发现一个个算出分值的出现几率再累加明显是不够简洁的，所以我们需要一个更优秀的算法

我们再次读题，发现连续的n个数不好维护，那么我们就来考虑每个点的贡献值，我们又可以发现对于每一个1，他的贡献值是由前面的值决定的，与后面的值无关，话句话说，就是没有后效性。那么，就可以考虑一下**动态规划**，那么就来看看他是否满足以下三个条件

- 相同子问题
- 无后效性
- 最优子结构

貌似都满足的样子，那么bingo，就愉快地开始dp吧

我们来观察每个点的贡献值：设前面有i个1那么这一个点的如果还是1的话，他的贡献就是

(p+1)^3-p^3->(数学运算)->3p^2+3p+p;

那么很明显的，我们只要知道p^2与p便可以求出它的贡献

那么我们分别来算出前p位都为1($x$数组)的期望与连续p个数的平方的期望($y$数组)…………

当前i位为1，这一位为0的时候，贡献为0~~废话~~

当前i位为1，这一位也为1时，他的期望就是(前i位都为1的期望+1)*成功的几率

同样，我们可以很快的算出p^2的期望为(前i位p^2的期望+前i位为1的期望+1)*成功的几率

这样，我们就可以在O(n)的复杂度内算出所有的期望值

这时，我们的答案也显而易见了($dis$数组)，
就是

```cpp
dis[i]=dis[i-1]+(3*x[i-1]+3*y[i-1]+1)*let;
```

然后我们只要输出dis[n]就可以啦

最后照例奉献一波AC代码

(28ms(不开O2),4.28MB)

```cpp
#include <bits/stdc++.h>

using namespace std;

int n;
double let;
double x[100010]={};
double y[100010]={};
double dis[100010]={};

int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
	    scanf("%lf",&let);
	    x[i]=(x[i-1]+1)*let;
	    y[i]=(y[i-1]+2*x[i-1]+1)*let;
	    dis[i]=dis[i-1]+(3*x[i-1]+3*y[i-1]+1)*let;
	}
	printf("%.1lf",dis[n]);
	return 0;
}
```