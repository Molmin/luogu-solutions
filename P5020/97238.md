## NOIP2018 D1T2 货币系统

从去年考完后一直对这题耿耿于怀，决定乘春节把这题回顾下

#### 题目大意

现有n个数，请输出其中“有效“的数字的总数

定义：如果某个数能被其他数字间接表示出，那么这个数就是“无效”的，反之就是有效的

（例：3，10，19中，19 = 10 * 1+3 * 3，那么 19 就是无效的，反之，3 和 10 是“有效”的

共有T组数据

T<=20，n<=100，每个数字都小于25000

#### 解析

这个题目很费脑，我们要慢慢思考

首先，小的数不可能被大的数字表示出，所以我们先把所有数排个序

n=2时，我们只要判断较大的数能不能整除较小数就行了

n=3时，前两个数容易判断，那么第三个数怎么办呢？

我们想到了**NOIP2017 D1T1** ，只不过数字最大可达int_max

这个题目是一道数学题，大多数人都是通过找规律的方法来做出来的

我们暂且用规律先把n=3解决了

我们再思考下，当时找规律要有数据，数据从哪来？

递推啊！

n=3时我们把它叫做递推，n更大时我们叫它什么？完全背包！

再通过集合论的相关知识，我们就可以愉快的得出结论和正确做法：

将n个数进行排序，对第 i 个数判断它是否能被前 i-1 个数表示出来（用完全背包的方法即可）

注意：这里要通过  ***数组递推***  的方式进行，每当某个数判断完毕后立即进入下一个数

***不要清空DP数组，接着用，不然会<font size=5>   T   L   E</font>   ！ ！！***

判断完毕后，输出计数结果即可

对于每组数据，记得清空数组，避免出现事故

> **数据千万条，清空第一条。**
>
> **多测不清空，爆零两行泪。**
>
> ——十二省联考命题组

代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=110;
int n,a[105],dp[25010];
int main()
{
	int T;
	cin>>T;
	while(T--){
		cin>>n;
		for(int i=1;i<=n;++i)cin>>a[i];
		sort(a+1,a+n+1);
		memset(dp,0,sizeof(int)*(a[n]+1));
		int cnt=n;
		dp[0]=dp[a[1]]=1;
		for(int i=2;i<=n;++i){
			for(int j=a[i-1];j<=a[i];++j)
				for(int k=1;k<i;++k)
					if(j>=a[k] && dp[j-a[k]]){
						dp[j]=1;break;
					}
			if(dp[a[i]])cnt--;
		}
		cout<<cnt<<endl;
	}
	return 0;
}
```



