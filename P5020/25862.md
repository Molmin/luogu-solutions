**[博客中食用更佳](https://www.luogu.org/blog/xzlhxc/solution-p5020)**  
**upd:博客地址变更，其余内容保持不变。**

------------
[题目链接（luogu）](https://www.luogu.org/problemnew/show/5020)   
预备知识：动态规划基础等。
# ①题意
给你n种货币的面值，成为A货币系统，让你求出一个货币系统B，使得B系统的货币种类不超过A系统，并且A系统能凑出的面值B系统也能凑出，A系统不能凑出的面值B系统也不能凑出。    

这道题初看感觉是一道数学题，但是如果手模一下数据的话可能会有这样的想法：货币系统B的大小既然不超过A，那么如果能用一些更小的面值代替A系统中一些更大的面值，或许就可以了。

那么B系统的面值要怎么求？

既然要保证A系统凑不出来的B系统也不行，那么最好的方法就是用A系统原有的一些货币来凑。所以我们可以猜出这样一个结论：

**在最佳决策中，必然有一种决策使得B中的面值都在A中出现过。**

前面的dalaos的证明太过强大，这里给一个比较蒟蒻的证明（如果错了请及时通知作者）。
# ②证明
尝试用数学归纳法证明。   
首先将A系统从小到大排序，设目前需要凑的数为A[i]，B系统共有j种面值并从小到大排列。  

当i=1时，直接令B[1]=A[1]即可，命题成立。

假设i=k-1时命题成立（即B[1~j]能凑出A[1~k-1]）则当i=k时

如果B系统的面值能凑出B[k]，命题成立。  

否则，假设B[j+1]>A[k]，则B系统仍然凑不出A[k]；若B[j]<B[j+1]<A[k]，那么B[j+1]必然不能由A[1~k-1]的面值凑出来（否则就没必要增加这个面值了），同时也不能被A[k]凑出来（A[k]比它大），那么这时B[j+1]不符题意。   

综上，B[j+1]=A[k]，符合命题。

因此命题成立。
# ③实现
得出以上结论后，接下来就是实现的问题了。  
将A系统数值排序后，每一个数仅可能被它前面的数凑成，然而如果一开始像作者一样使用bool变量保存状态的话，会发现转移比较困难，所以我们可以以方案数作为状态。

**f(i):用A系统的面值凑成面值i的方案数。**

转移方程：

**f(i)=sum{ f(i-A[j]) } 其中i<=A[j]。**

边界：

**f(0)=1;**

这里作者是用“刷表法”来做的，读者可以自行变通。

```cpp
sort(a+1,a+n+1);//排序
f[0]=1;//边界
for(int i=0;i<=a[n];i++)//排序后a[n]为最大面值
  for(int j=1;i+a[j]<=a[n]&&j<=n;j++)
     if(f[i])//如果是0就不用更新了
		f[i+a[j]]+=f[i];
     else break;
```
如果某个面值只存在1种组成方式（即用它本身凑成自己），就必须选这个面值。

当然，如果用这个核心代码来求方案数的话，会存在如果i是A系统里的面值，就会重复计数，当然，在本题中，不管有没有重复计数，只要某个面值存在除了自身以外的其它组成方式的话，就说明这个面值没必要选，所以对答案没有影响。  
最后，f数组记得开long long 。

# ④AC!
P.S. 自从上次题解排版爆炸后，就不敢滥用markdown了，阅读体验不佳请谅解。