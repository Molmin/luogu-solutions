NOIP2018提高组D1T2

考场上使用了一种奇怪的使用bitset的dp方式，需要一些卡常，写这篇题解的时候没有看到有其它做法类似的题解，于是就写了一发。

题目意思是让你简化一个货币系统，那么我们需要考虑有哪些货币应该留着，哪些货币不再需要。

这时候我们就有一个想法：一个简化的货币系统一定是由原来的货币系统中删除一些货币组成的。

那么删除哪些货币呢？

显然如果一种货币的面额可以用其他货币的面额表示出来，那么这种货币是可以被删除的。

那么对于那些不能用其他货币的面额表示出来的货币，一定会存在只能用这种货币来表示的金额，也就是说，这种货币一定要保留。

所以我们只需要判断哪些货币能被其它货币表示出来。

（正解为完全背包）

如果设$f[i]$代表金额$i$是否能被当前的货币表示出来，那么如果多使用一张面额为$x$的货币，对于所有当前能被表示出来的金额$y$，$x+y$也将能被表示出来，所以对于所有$f[i](i>=x)$，$f[i]|=f[i-x]$。

那么我们就只需要使用一个`bitset`作为$f$数组，对于一种面额为$x$的货币，更新的过程就是$dp|=dp<<x$（假设这个bitset叫做dp）。当然由于一张货币可以被使用多次，我们需要做足够多次的更新。~~为了减小常数~~，我们更新$max\{a[i]\}/x+1$遍即能保证更新完毕。

最后我们的解法就是：初始化$f[0]=True$将所有货币按面额排序，按从小到大判断当前的货币面额是否可以表示出，可以则删除它，不能就保留并且更新$f$。时间复杂度玄学。

~~至于为什么我没有用完全背包，因为考试前的一场模拟赛被bitset洗了脑~~

附上代码：（为考场代码，做了些许改动）

```cpp
#include <bits/stdc++.h>
using namespace std;

#define MAXN 1010

int n,a[MAXN];
bitset<25001> f;

int main()
{
    int T;
    scanf("%d",&T);
    while(T--)
    {
        int erased=0,maxn=0;
        f.reset();
        scanf("%d",&n);
        for(int i=1;i<=n;++i)
            scanf("%d",a+i),maxn=max(maxn,a[i]);
        sort(a+1,a+n+1);
        f[0]=1;
        for(int i=1;i<=n;++i)
        {
            if(f[a[i]])
                ++erased;
            else
                for(int cnt=1;cnt<=maxn/a[i]+1;++cnt)f|=f<<a[i];
        }
        printf("%d\n",n-erased);
    }
}
```