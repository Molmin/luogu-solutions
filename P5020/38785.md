## 思路

其实可以发现，保证$m$最小，只要**去掉可以用其它货币表示的货币**就可以了。

就用样例做例子吧：
```
2 
4 
3 19 10 6 
5 
11 29 13 19 17 
```

在第一组数据中，可以发现$6=3+3$，所以可以不用$6$这种货币；同理，$19=3+3+3+10$，所以也可以去掉。

继续观察，发现3和10都不能用其它货币进行表示，那么答案就是2。

在第二组数据中，**没有一个数可以用其它数表示**，所以一种都不能删去，答案就是5。

（本题的数据范围用这种方法可以AC，应该是比较简洁的方法了）

--------------

## 实现

有了思路之后，很容易发现这就是一个完全背包啊QAQ

然后注意数组开大点就可以了QAQ

--------------

$My$ $Code$

```
const
    inf=70000; 
    //开大点，虽然a[i]<=25000，但是开到6W也只有95分。。。
var
    f:array[0..100000] of qword; //空间充足，开大点没事
    a:array[0..110] of longint;
    t,x,i,j,s,n:longint;
begin
    read(t);
    for x:=1 to t do
    begin
        read(n);
        fillchar(f,sizeof(f),0); //表示出某个金额的方案总数
        f[0]:=1; //有1种方法表示金额0（什么货币都不用）
        for i:=1 to n do
        begin
            read(a[i]);
            for j:=0 to inf do f[j+a[i]]:=f[j+a[i]]+f[j];
            //完全背包
        end;
        s:=n; //表示答案
        for i:=1 to n do //去除多余的货币
            if f[a[i]]>1 then dec(s); //这里>1是为了排除用a[i]表示a[i]的方案
        writeln(s);
    end;
end.
```

----------

### 这里值得一提的是：

对于金额$a_i(1 \leq i \leq n)$，存在用$a_i$表示$a_i$的方案，但只能在最后统计时排除（见代码），因为**完全背包的过程中需要考虑这种情况**，所以不能简单粗暴地把$0$ $to$ $inf$改为$1$ $to$ $inf$。