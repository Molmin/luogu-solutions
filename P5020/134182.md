# 各位来砍一砍本蒟蒻的题解吧！

这道题我的思路是这样的：

首先，我们有一个集合，分别表示能够支付的基本金额。

我们需要找到一个和它等价的集合。


------------
看起来，这道题似乎毫无头绪，似乎无从下手，感觉可能连一个暴力都编不出来。

那么，这个时候我们就要仔细分析题目了。

## First
let's看一看，咦？题目下面怎么还有**说明/提示**呀！

赶紧看一看！

在第一组数据中，货币系统 (2, [3,10])和给出的货币系统 (n, a)(n,a) 等价，并可以验证不存在 m < 2m<2 的等价的货币系统，因此答案为 22。

那么我们发现了什么呢？

3，10又有什么特点？3，10和3 19 10 6 有什么关系呢？


------------
## 对了！
6是不是等于3*2？

19是不是等于10+3*3?

那么我们可以在这个结论中得出什么呢？


------------
## 啊哈！
在原来的集合中，如果某一个元素能被本集合中的元素表示，那么，这个元素就是无用的，因为每个币值都有无数个。


------------
## Next
现在就要考虑编程了。

我们考虑到时间复杂度。只好用DP

对于各位初中普及国一上提高组的童鞋们，你们这道题肯定是木有问题的。

对于各位高中尻提高组的神仙们，你们这道题肯定是木有问题的。

对于我这一垃圾地没有普及国一的人，这道题就有问题了！！！！

思路就是用本集合的数去表示本集合的数，如果能表示出一个，那么B集合就可以大小减去1（B集合大小初始为A集合大小）


------------
# 具体还是看程序吧！
```cpp
#include<bits/stdc++.h>
using namespace std;
int T,a[1005],n,dp[25005];
int main(){
	cin>>T;
	while(T--){
		scanf("%d",&n);
		memset(a,0,sizeof(a));
		memset(dp,0,sizeof(dp));
		for(int i=1;i<=n;i++)scanf("%d",&a[i]),dp[a[i]]=-1;
		sort(a+1,a+n+1);
		for(int i=a[1];i<=a[n];i++){
			for(int j=1;j<i;j++){
				if(a[j]>=i)break;
				if(dp[i-a[j]])dp[i]=1;
			}
		}
		int sum=0;
		for(int i=1;i<=n;i++)sum+=(dp[a[i]]==1);
		printf("%d\n",n-sum);
	}
	return 0;
}
```
首先，我们定义dp[i] 为i这个数字能否被A集合中的数表示。

然后吧A数组的数标记为-1。

然后排序。

接着穷举第一重循环，从最小数到最大数

然后穷举第二重循环从1开始，穷举每个比它小的A集合数

如果能表示就标记为1。

最后穷举如果有被表示出的，就n减掉它。



------------
# 就是这样了，蟹蟹大家的观看。
# Thank for reading!!