题目要求找到一个货币系统(m,b)，满足(m,b)与原来的货币系统
(n,a)等价，且m尽可能的小。

等价就是要筛去每组数据中可以通过其他数据的组合得到的所有数，
由于一个货币系统能组合出的最小值就是货币系统中的最小值，所
以不能用比其最小值更小的值来代替该货币系统。
所以按题目的意思，就是在已有货币中，删去货币系统可以表示的所有面额与货币系统中货币面额的交集。

关于这道题目，可使用筛的方法
用a[i]保存有序的货币值，b[i]记录面额i能否被表示，c[i]保存每一个小于当前货币值的可以被表示的面额，则对于每一个货币值a[i]，筛去面额为k*a[i]+c[i]的值就可以得出答案了。

具体到代码上，可以保存下每组数据的最大值，k的大小取决于最大值（循环到超过最大值时结束）。

下附代码(sieve函数为对每一个货币值的筛操作）

```
#include<cstdio>
#include<algorithm>
using namespace std;
int t,n,ax,sum;//ax储存每组数据最大值,sum储存结果
int a[101],c[50005];
bool b[50005];

void sieve(int x){
	if(b[x]){
		sum--;
		return;
	}//对于每个货币值,若可以由更小的货币值组合成,则删去这个值 
	int p=0;
	for(int i=1;i<ax;i++){
		if(b[i]) c[++p]=i;
		//保存每一个小于当前货币值的可以被表示的面额 
	}
	for(int i=1;x*i<=ax;i++){
		for(int j=0;j<=p;j++){
			b[c[j]+x*i]=1;
			//每个可以被表示的面额加上一定倍数的当前货币值
			//就是加上当前货币值之后可以表示的面额 
		}
	}
	return;
}

int main(){
	scanf("%d",&t);
	for(int q=1;q<=t;q++){
		for(int i=1;i<=ax*2+1;i++) b[i]=0;
        //初始化(保险起见初始化至ax*+1)
		scanf("%d",&n);
		ax=0,sum=n;
		for(int i=1;i<=n;i++){
			scanf("%d",&a[i]);
			if(a[i]>ax) ax=a[i];
			//找出每组数据中的最大值 
		}
		sort(a+1,a+n+1);//将数据从小到大排序 
		for(int i=1;i<=n;i++) sieve(a[i]);//筛 
		printf("%d\n",sum);//输出 
	}
	return 0;
}
```