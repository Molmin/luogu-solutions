第一次发题解的蒟蒻......请大家多多关照了QWQ。话不多说，以下讲解。

首先是证明，货币系统B一定是货币系统A的子集。因为如果B中有一种面值的货币A中没有的话，那么两个货币系统就不可能是等价的了。

解题思路：
看到好多大佬用的是背包，但是我考场上满脑子的线性筛素数QAQ（~~我也不知道为什么~~），所以我就来讲讲我考场上的思路吧。

输入货币系统A后把所有货币按面值从小到大排序，因为面值大的有可能被面值小的表示出来。把排好序的货币系统A扫一遍，每种面值的货币都要判断能否被表示出来（用一个bool数组标记一下就好），如果当前不能被表示出来，那么就把这种面值的货币加入到货币系统B中。加入的同时还要把这种面值的货币能表示出来的面值标记一下，用类似线性筛素数的思想。设当前加入的货币面值为x，for循环从1开始扫一遍，扫到货币系统A中最大的面值就停止，如果当前面值的货币能被表示出来，那么加上x后的面值一定也能被表示出来。最后把货币系统B种的货币种类数输出就行了。

我不会算时间复杂度啊QAQ，~~但是好像这种算法也不是很慢？（小声bb~~）总之考场上过了就是了。好了，接下来上代码。

------------

```
#include<bits/stdc++.h>
using namespace std;
int T,n,a[102],m,maxn;
bool used[25002];//used[i]=1表示面值为i的货币能被表示出来，used[i]=0表示面值为i的货币不能被表示出来
void cut(int x){
  used[x]=1;//先把当前面值标记一下
  for(int i=1;i+x<=a[n];i++){
    if(!used[i]) continue;//如果这个面值之前不能被表示出来就跳过
    used[i+x]=1;//面值为i的能被表示出来，那么i+x也一定能被表示出来
  }
  return;
}
int main(){
  scanf("%d",&T);
  while(T--){
    scanf("%d",&n);m=0;
    memset(used,0,sizeof(used));//记得清零，我考场上就差点忘了
    for(int i=1;i<=n;i++)
      scanf("%d",&a[i]);
    sort(a+1,a+1+n);//排序
    if(a[1]==1) {cout<<"1"<<endl;continue;}//如果最小面值为1的话就可以直接跳过了
    for(int i=1;i<=n;i++){
      if(used[a[i]]) continue;//能被表示出来就跳过
      cut(a[i]);//不能被表示出来就加入系统B，同时把加入后能表示出来的面值标记为1
      m++;//系统B中的货币种类数加1
    }
    printf("%d\n",m);
  }
  return 0;
}
```