

------------
~~第一次做感觉这题完全就是一个数论题啊~~。

好在数据规模比较小，暴力也能过、

首先分析一下暴力程序怎么写：

对于每一组数据，最小的一个数据是必选的。选数据的时候，小的数据优先级应高于大的数据。因此，我们可以将序列a[1...n]
从小到大排序，然后依次枚举每一个数，将所有他能表示出来的数打上标记。

因为我们的序列是从小到大排过序的，所以序列中较大的，能被比他小的数表示出来的数一定在枚举他之前就被打上过标记。思路的正确性得证、

此时牵扯到一个问题：比如样例中的19，这个数可以由3,10两个数组合成，但是我们在打标记的时候却把他忽略掉了、

因而，问题转变为对于这种由多个数组合而成的数，如何把他筛掉？



考虑一个性质，对于一个我们未打过标记的数，在他之前，比他小的，且能打上标记的数一定被打上过标记。对于每一个被打上过标记的数t,必然有t+k(k属于a[1..n])也应当被打上标记。反过来，对于每一个数t，t-k如过被打上过标记，那个t也应该被打上标记、（这里的t-k的值应该从0开始）、
因此我们可以由此推出打标记的方法：
```c
	sort(a+1,a+1+n);
		for(int i=1;i<=n;i++)
		
		{
			if(vis[a[i]])continue;
			vis[a[i]]=1,cnt++;
			for(int j=a[i];j<=25000;j++)
			{
				if(vis[j-a[i]])vis[j]=1;
			}
		}
```

看了看数据规模，这样的暴力程序是可以过的、

后来，学到了一种新的思路:

完全背包。

如果我们把每一个数a[i]看作背包容量，f[i]表示对于容量为i的背包，最多能由几个数装满、那么对于每一个f[a[i]]，他必然可以被自己（a[i]）装满。所以对于每一个a[i]，必有f[a[i]]>=1.

问题就转换成了对于每一种容量下的背包，求他在恰好装满的状态下，最多能“装几个数”。

关于恰好装满的情况下的初始化：（建议大家看一下这篇博客，对于初始化讲的很详细https://blog.csdn.net/stack_queue/article/details/53544109）
首先f[0]=0，其余的均设为-INF（因为在最开始的时候，只有0是符合要求的）、
如果是第一种问法，要求恰好装满背包，那么在初始化时除了f[0]为0其它f[1..V]均设为-∞，这样就可以保证最终得到的f[N]是一种恰好装满背包的最优解。

如果并没有要求必须把背包装满，而是只希望价格尽量大，初始化时应该将f[0..V]全部设为0。

为什么呢？可以这样理解：初始化的f数组事实上就是在没有任何物品可以放入背包时的合法状态。如果要求背包恰好装满，那么此时只有容量为0的背包可能被价值为0的nothing“恰好装满”，其它容量的背包均没有合法的解，属于未定义的状态，它们的值就都应该是-∞了。如果背包并非必须被装满，那么任何容量的背包都有一个合法解“什么都不装”，这个解的价值为0，所以初始时状态的值也就全部为0了。
                                    ___引自https://blog.csdn.net/stack_queue/article/details/53544109

最后对于结果的统计，就是枚举每一个a[i]，看f[a[i]]是否等于1、如果等于1，就说明这个数只能被他自己表示出来。自然，对于最终的结果要+1。


代码：

```c
while(t--)
	{	memset(a,0,sizeof(a));
		memset(f,INF,sizeof(f));
		cnt=0;
		cin>>n;
		for(int i=1;i<=n;i++)
		{
			cin>>a[i];
		}
		f[0]=0;
		for(int i=1;i<=n;i++)
			for(int j=a[i];j<=25000;j++)
				f[j]=max(f[j],f[j-a[i]]+1);
		for(int i=1;i<=n;i++)
		{
		if(f[a[i]]==1)cnt++;	
		
		}
		cout<<cnt<<endl;	
	}
```
如果大家学过完全背包，相信不难理解、
好了这篇题解就到这里咯~