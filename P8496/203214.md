- 前言

  考试中开了 $10^6$ 个 `std::deque`，然后获得了 $0$ 分的好成绩。

  但是洛谷的评测机却没有 $\tt MLE$，大受震撼。

- 题意

  给定 $n$ 个集合，支持下面四种操作：

  1. 在第 $i$ 个集合尾部加入数字 $x$。

  2. 删除第 $i$ 个集合的最后一个数字。

  3. 将一些集合拼在一起，求这些集合的众数。（这里的众数指出现次数大于集合大小一半的数字）

  4. 新建一个集合 $z$ 由 $x$ 与 $y$ 拼接而成。

- 题解

  直接考虑求众数，用了一种很玄妙的方法。（因为不会摩尔投票）

  对于集合 $i$，令数字 $x$ 的权值为 $w_{i,x}=2\times cnt_{i,x}-sz_i$，其中 $cnt_{i,x}$ 表示 $x$ 在集合 $i$ 中的出现次数，$sz_i$ 表示第 $i$ 个集合的大小。

  设询问序列为 $q$，则判断 $x$ 是否为众数就变成了判断 $\sum\limits_{i=1}^m w_{q_i,x}$ 的值是否大于 $0$。

  可以发现，对于一个集合 $i$，最多有一个数字的权值大于 $0$，令这个数字为 $x$，则集合 $i$ 的权值第二大小于等于 $-w_{i,x}$。

  每次询问维护二元组 $(i,val_i)$，表示数字 $i$ 的正权值和为 $val_i$，只有 $val_i$ 最大的数字才有可能作为众数。（因为其他的数字至少减去 $val_i$）

  整个过程中，需要支持维护集合出现次数最多的数字，支持查询一个集合的最后一个元素。

  用线段树维护每个集合的元素出现次数，操作 $4$ 直接线段树合并即可；用 `std::list` 维护集合，操作 $4$ 将 `std::list` 启发式合并。（就是将小的 `std::list` 拼接到大的上面去）

  线段树合并时间复杂度 $O(n\log{n})$，`std::list` 的启发式合并时间复杂度为 $O(n\log{n})$，每次查询时间复杂度为 $O(m\log{m})$，这里的 $m$ 为每次询问的集合个数。

  [代码](https://www.luogu.com.cn/paste/rkxsqtvd)

- 后记：

  最近运气不好，写题解来转运。