此题，可能有巨佬一眼就看出来了是二阶差分，反正蒟蒻我做不到。
还是老老实实一步步分析吧
### Step 1 有哪些数可能出现在第一个
此题怎么做呢？我最先想到的，就是暴力搜索，一个一个还原填数时选的矩形，进而推出哪些矩形可能是第一个填上去的。

等等，为什么样例输出里有这么多个数？

其实，这些就是我们本题可以第一个出现的数中的一类——没有出现在图上的数。

这类数，有可能是被后来填上来的数完全覆盖了，所以我们压根看不到它们。

那么，出现在图上的数又有哪些可能是第一个出现的数呢？

其实，这就抽象成了一个放矩阵的问题。如果两个矩阵之间有重叠部分，那么后来的数一定会覆盖先填上数，所以，矩阵重叠区域我们现在看到的数就一定不可能是第一个出现的。

### Step 2 暴力搜索
接下来的问题就是如何还原矩阵了。对此，我们可以枚举每个数出现的极端位置，由于不能选已经使用过的数，所以相同的数字一定属于同一个矩形。

求出每个数出现的极右上位置和极左下，我们就可以得知这个矩形的对角线，进而还原矩形了

我们新开一个矩阵B，对于每个矩阵，我们都将其范围内的B位置上的数++

最后，如果原图上有矩阵重叠区域，那么B矩阵对应位置的数就会>=2。

然后我们就可以得出答案了。

### Step 3 特殊数据
来看看下面这组数据

4

0 0 0 0

0 1 1 0

0 1 1 0

0 0 0 0

按照我们上面推的结论，该图答案应该为16

但是，我们肉眼目测答案很明显是15，因为1不可能出现在第一位。

对于这种图上除了0之外只有1个数的情况，我们需要特判，直接输出$N^2-1$即可

好了，到了这里我们已经可以喜提AC了（~~数据有点水~~）但如果你想了解优化，可以继续往下看。

### Step 4 二阶差分优化
对于一个矩阵实现快速区间修改，这让我们很自然地想到了二阶差分。

所以，我们上面在修改B矩阵的时候，可以加上二阶差分优化。

### Step 5 放码
```cpp
#include<stdio.h>
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
int a[1008][1008],Max[1000008][2],Min[1000008][2],n,ans,cnt,cnt1,f[1000008];
bool ff[1000008],fff[1000008];
int b[1008][1008];
char buf[1<<20],*p1,*p2;  
#define GC (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<20,stdin),p1==p2)?0:*p1++)  
inline ll read() { char t=GC; ll x=0; while(!isdigit(t)) t=GC; while(isdigit(t)) x=x*10+t-48,t=GC; return x; }
void init()
{
    for(int i=1;i<=n*n;i++)
    Min[i][0]=Min[i][1]=1e9+7;
}
int main()
{
    n=read();
    init();
    for(int i=1;i<=n;i++)
    for(int j=1;j<=n;j++)
    {
        a[i][j]=read();
        if(a[i][j]!=0)
        {
            Max[a[i][j]][0]=max((int)i,Max[a[i][j]][0]);
            Max[a[i][j]][1]=max((int)j,Max[a[i][j]][1]);
            Min[a[i][j]][0]=min((int)i,Min[a[i][j]][0]);
            Min[a[i][j]][1]=min((int)j,Min[a[i][j]][1]);
            if(!ff[a[i][j]])
            cnt++,f[cnt]=a[i][j];
            ff[a[i][j]]=true;
        }
    }
    if(cnt==1)
    {
        cout<<n*n-1;
        return 0;
    }
    for(int i=1;i<=cnt;i++)
    for(int j=Min[f[i]][0];j<=Max[f[i]][0];j++)
    for(int k=Min[f[i]][1];k<=Max[f[i]][1];k++)
    b[j][k]++;
    for(int i=1;i<=n;i++)
    for(int j=1;j<=n;j++)
    {
        if(b[i][j]>=2&&a[i][j]!=0)
        {
            if(!fff[a[i][j]])
            {
                fff[a[i][j]]=true;
                cnt1++;
                //cout<<i<<" "<<j<<" "<<a[i][j]<<endl;
            }
        }
    }   
    ans=n*n-cnt1;
    cout<<ans;
    return 0;
}
```

祝各位巨佬们早日AK