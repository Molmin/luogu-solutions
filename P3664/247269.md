## 知识点：差分  
这题挺毒瘤的，就单是题意都不是很好理解....  
题意：给你一个$n*n$的矩阵，有$n*n$个颜色来涂色，之中可能有覆盖，问其中有哪些颜色可以作为第一个涂色的  
题解：  
思考一下，如果直接找哪些作为第一个涂色的，是不是有点困难，所以我们容斥一下，把不可以作为第一个的颜色求出来，再用$n*n$的总数来减就可以了  

那么哪些颜色不能作为第一个呢：  
$1.$如果只有一个颜色则一定不为第一个  
$2.$和另一个矩阵有交集，且在上面  

好！特征已经明白了，接下来就是怎么找？怎么用代码实现？  
显而易见的方法是爆搜嘛，单是明显会挂掉，所以不考虑  
然后思考一下，什么东西可以满足求和还适用于矩阵？

## 二维差分！二维差分！二维差分！二维差分！  
好想到了这里就已经成功一半了  
接下来你需要去思考如何维护差分数组  

我们可以找出每个矩阵大概的轮廓（即上下左右四个点）  
参照一维差分的思想，我们可以在一个矩形的左上角$+1$，右下角$+1$，右边$-1$,下边$-1$  
这样处理了之后，一个点前缀和就是这个点被覆盖的次数  
需要注意的是如果只看得见一个颜色，怎么处理  
代码如下：
```
#include<bits/stdc++.h>
#define ll long long
using namespace std;
ll n,a[1010][1010],sum[1010][1010],f[1000010][8],v[1000010]; 
ll cnt,ans;
void insert(ll x,ll y,ll z)
{
	if(f[z][3]==0)cnt++;
	if(x<f[z][1])f[z][1]=x;
	if(y<f[z][2])f[z][2]=y;
	if(x+1>f[z][3])f[z][3]=x+1;
	if(y+1>f[z][4])f[z][4]=y+1;
}
void solve()
{
	for(int i=0;i<=n*n;i++)
	{
		f[i][1]=1e9;
		f[i][2]=1e9;
		f[i][3]=0;
		f[i][4]=0;
	}	
}
void sum_()
{
	for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=n;j++)sum[i][j]+=sum[i-1][j]+sum[i][j-1]-sum[i-1][j-1];
    }
}
int main()
{
	scanf("%lld",&n);
	solve();
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=n;j++)
		{
			scanf("%lld",&a[i][j]);
			if(a[i][j]!=0)insert(i,j,a[i][j]);
		}
	}
	for(int i=1;i<=n*n;i++)
	{
		if(f[i][1]==1e9||f[i][3]==0)continue;
		sum[f[i][1]][f[i][2]]++;
		sum[f[i][3]][f[i][4]]++;
		sum[f[i][1]][f[i][4]]--;
		sum[f[i][3]][f[i][2]]--;
	}
	sum_();
    for(int i=1;i<=n;i++)
    {
    	for(int j=1;j<=n;j++)
    	{
    		if(a[i][j]!=0&&sum[i][j]>1&&v[a[i][j]]==0)
    		{
    			ans++;
    			v[a[i][j]]=1;
			}
		}
	}
	if(n>1&&cnt==1)printf("%lld",n*n-1);
	else printf("%lld",n*n-ans);
}
```
