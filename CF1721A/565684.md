**题意：**

每次可以拿出**一个或两个**颜色相等的元素，转换为另一种颜色，求最少步骤。

转换颜色的操作没有规定必须相邻什么的，所以我们可以只看**颜色的种类**来判断。


------------
  

一张图片一共有以下几种情况：

```
aa  aa  aa  ab
aa  bb  bc  cd
```
也就是只有一种颜色、两种颜色、三种颜色和四种颜色，我们分别来看。

**一种颜色**：不用操作，也就是输出 $0$。

**两种颜色**：我们任取一种颜色，将它变为另一种颜色即可，输出 $1$。

**三种颜色**：我们将两个相同颜色的像素转换为另一种颜色，再按两种颜色的情况处理，输出 $2$。 

**四种颜色**：我们任取一种颜色转换为另一种颜色，再按三种颜色的情况处理，输出 $3$。 

不难发现规律，答案就是**颜色种类减一**。从另一个角度来想，每次操作能减少一种颜色，我们将除某种颜色以外的所有颜色操作一次，就达到了目的。

注意如何判断有多少种颜色：

```cpp
map<char,bool> mp;
int s=-1;mp.clear();//map一定要清空!
cin>>c[1][1]>>c[1][2];//读入
cin>>c[2][1]>>c[2][2];
for(int j=1;j<=2;++j){
    for(int k=1;k<=2;++k){
        if(mp[c[j][k]]==0) s++,mp[c[j][k]]=1;
        //如果没出现过，设为出现过，种类加一
    }
}
```

**完整代码**：

```cpp
#include<bits/stdc++.h>
using namespace std;
char c[3][3];
int T;
map<char,int> mp;
int main(){
    cin>>T;
    for(int i=1;i<=T;++i){
        int s=-1;mp.clear();
        cin>>c[1][1]>>c[1][2];
        cin>>c[2][1]>>c[2][2];
        for(int j=1;j<=2;++j){
            for(int k=1;k<=2;++k){
                if(mp[c[j][k]]==0) s++,mp[c[j][k]]=1;
            }
        }
        cout<<s<<endl;
    }
    return 0;
}

```

