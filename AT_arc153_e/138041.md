考虑从 $Y$ 逆推回 $X$。假设 $Y$ 的开头两个字符为 $x,y$，最后一个字符为 $z$，即 $Y=xy\dots z$。考虑最后一步插入的是 $x$ 还是 $z$。

- 若 $x\le y$，则可以是 $x$；否则，一定不可以是 $x$，不然把 $x$ 插入到末尾一定得到更小的 $Y$。

- 若 $z>x$，则可以是 $z$；否则，一定不可以是 $z$，不然把 $z$ 插入到开头一定有：如果整个串都是同一个字符，则与第一种情况等效，不应重复计数；否则可以归纳证明能得到更小的 $Y$。

据此已经可以 $O(n^2)$ 区间 DP 了。

考虑一个状态 $(L,R)$，表示 $Y[L:R]$ 的 DP。

- 由于转移 $(L,R)\leftarrow (L+1,R)$ 一定要满足 $Y_L\le Y_{L+1}$，并且我们只关心 $(1,n)$，所以取出 $Y$ 的极长不降前缀 $[1,p]$，则只有 $L\le p$ 的状态是有用的。所以可以按 $p\to 1$ 的顺序枚举 $L$，这样在 $Y_L$ 上就具有了单调性，这对下一步优化很有用。
- 对于 $R\in [p+1,n]$ 的状态，如果存在 $i\in [p+1, R]$ 满足 $Y_i\le Y_L$，则这个状态的 DP 值一定是 $0$。因为结合第二种转移的条件以及上一步得到的 $Y_L$ 的单调性，可以发现怎么走都走不到 $R$。
- 对于 $R\in [L,p]$ 的状态，只要 $Y_R>Y_L$ 即可以 $(L,R)\leftarrow (L,R-1)$。

于是，每次从 $L+1\to L$，相当于继承状态，然后把 $(L,L)$ 置为 $1$，再对一段区间进行前缀和。显然，对于 $Y_L$ 相同的 $L$，做前缀和的区间时一样的，而这样的 $L$ 又恰好构成一段区间，所以可以放在一起做。从生成函数的角度看，就是卷上一个组合数序列，可以使用 NTT 优化。总共只有 $|\Sigma|=9$ 段 $L$ 构成的区间，所以复杂度是 $O(|\Sigma|n\log n)$ 的，可以通过。

[代码](https://atcoder.jp/contests/arc153/submissions/38038051)

