[[题目传送门](https://www.luogu.org/problem/P2344)]

这道题本蒟蒻感觉不太好想，于是乎就发篇博客加深一下记忆，也方便以后查看

首先因为题目中说必须是连续的一段，很容易想到要用前缀和，并且看过数据范围后要离散化一下

然后会有一个dp的思想

具体讲一下
```cpp
add(s[0], 1);//因为 s[0] 此时记录的是相对大小，即表示理智度刚好为0时，方案数为1，先加入树状数组 
for (int i = 1; i <= n; i++) {
	ans = query(s[i]);//查询前面比自己小的前缀和
	add(s[i], ans);//累加上方案数 
}
```
很多人可能会有疑问，为什么这里只查询比自己小的就行了？难道不会有负值的情况吗？

请看这一句：
```cpp
add(s[0], 1);
```
因为你离散化之后 s[0] 就变成了相对大小，即记录下了理智度为0时的相对大小，此时方案数为1。在此后如果你加入比它小的值，也就是理智度小于0的一段时，其方案数依然为0，并不会影响上面的值。所以循环碰到 s[i] < 0 时，ans = 0,在加入时增加依然为0。

好我们来解决为什么加 比自己小的值 的问题

就是说，因为要dp将前面分成好几段来累加，所以当前一个值大于自己时，代表这之间一定出现了负值，再进行累加就不正确了，所以加比自己小的值。

另外因为是dp所以将当前方案数加到当前值上，然后加入树状数组

好了好了，看看代码就清楚了

~~其实自己讲的啥都不是qwq~~

**code:**

```cpp
#include <bits/stdc++.h>
using namespace std;
const int p = 1000000009;
int n, ans;
int c[100021], a[100021], s[100021];
void add(int x, int v) {//树状数组用来维护方案数 
	for (int i = x; i <= n + 1; i += i & -i) {
		c[i] += v;
		c[i] %= p;
	}
}
int query(int x) {
	int re = 0;
	for (int i = x; i > 0; i -= i & -i) {
		re += c[i];
		re %= p;
	}
	return re;
}
int main () {
	scanf("%d", &n);
	for (int i = 1; i <= n; i++) {
		scanf("%d", &s[i]);
		s[i] += s[i - 1];//记录前缀和 
		a[i] = s[i];//另开一个数组用于离散化 
	}
	sort(a, a + 1 + n);//排序 
	for (int i = 0; i <= n; i++) {//离散化 
		s[i] = lower_bound(a, a + 1 + n, s[i]) - a + 1;
	}
	add(s[0], 1);//因为 s[0] 此时记录的是相对大小，即表示理智度刚好为0时，方案数为1，先加入树状数组 
	for (int i = 1; i <= n; i++) {
		ans = query(s[i]);//查询前面比自己小的前缀和
		add(s[i], ans);//累加上方案数 
	}
	printf("%d\n", ans % p);
	return 0;
}
```
