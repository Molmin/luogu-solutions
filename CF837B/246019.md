## Descreption
Berland之旗是满足以下条件的 $n \times m$ 矩形区域：

- 旗中包含三种颜色，相应地以字母“R”, “G”和“B”表示。

- 旗中包含三个“长条”，他们的长度和宽度相等（长条1的长度等于长条2的长度，也等于长条3的长度，宽度类似），并且互相平行，同时还平行于旗子的边缘。每个“长条”仅有一种颜色。

- 每个颜色仅能在一个“长条”中出现。

现在给定由“R”, “G”和“B”构成的 $n \times m$ 矩形区域。请判断它是否是一个正确的Berland之旗，是则输出 "YES"，否则输出"NO"。

## Solution&Code

这题的难度不高，只需要注意一些细节就可以，可以当做基础练习。

几个小优化（可能没什么用，看数据的强度）：

- 如果$n$和$m$都无法三等分，那么无论如何都不可能是Berland之旗。代码如下：

	```cpp
	if(n%3 != 0 && m%3 != 0)
	{
		cout<<"NO"<<endl;
		return 0;
	}
	```
- 如果旗子根本没有三种颜色，那么也无论如何都不可能是Berland之旗。我们可以在输入的时候顺便统计颜色。代码如下：
	```cpp
	for(int i=0;i<n;i++)
		for(int j=0;j<m;j++)
		{
			cin>>map[i][j];
			if(map[i][j] == 'R') r++;
			if(map[i][j] == 'G') g++;
			if(map[i][j] == 'B') b++;
		}
		
		if(!r || !g || !b)
		{
			cout<<"NO"<<endl;
			return 0;
		}
	```
然后就是正常的部分了。两种情况：

- 如果$n$能三等分：即长条的形状是横向的。考虑把每一个长条的第一个颜色作为这个长条颜色的代表。写一个函数判断：
```cpp
	void row()
	{
		if(map[0][0] == map[n/3][0] || map[0][0] == map[n/3*2][0] || map[n/3][0] == map[n/3*2][0])//如果有其中两个长条的颜色一样
			return;
		
		for(int i=0;i<n;i++)
			for(int j=0;j<m;j++)
				if(map[i][j] != map[(i/(n/3))*(n/3)][0])//如果有颜色和这个长条应该有的颜色不一样
					return;
				
		cout<<"YES"<<endl;
		exit(0);//这里直接结束程序，以免之后多于输出
	}

```

- 如果$m$能三等分：长条形状是竖向的。思想同上，代码如下：
```cpp
	void col()
	{
		if(map[0][0] == map[0][m/3] || map[0][0] == map[0][m/3*2] || map[0][m/3] == map[0][m/3*2])
			return;
		
		for(int i=0;i<n;i++)
			for(int j=0;j<m;j++)
				if(map[i][j] != map[0][(j/(m/3))*(m/3)])
					return;
				
		cout<<"YES"<<endl;
		exit(0);
	}

```

如果两个函数都return了，即不能组成Berland之旗，就输出NO。

完整代码就不贴了，把上面的代码整合起来也不难嘛。（逃