[原题链接](https://www.luogu.com.cn/problem/P4119)

据 lxl 所述，这种算法貌似应该叫「望月悲叹的最初分块」。但我们一般称之为「最初分块」。

处理区间 $kth$ 问题，首先想到的基本就是值域分块。这道题我们对序列和值域都分块，设 $a_1[i][j]$ 表示前 $j$ 块中权值在 $i$ 块内的数的个数，$a_2[i][j]$ 表示前 $j$ 块中数 $i$ 的出现次数。

对于一次寻问 $[l_i, r_i]$：先将散块加入临时桶中，然后先 get 到答案位于哪块，确定位于哪块后再暴力枚举即可在 $O(\sqrt n)$ 的复杂度内求得区间 $kth$。

对于一次修改，从左端点的块一直修改到最后面的块，并记得更新 $a_1$、$a_2$ 两数组即可。接下来细讨：
- 对于零碎的两边两块，直接暴力重构。
- 对于中间的每个完整的块，如果某一块不含 $x$，可以不理会这块；否则，如果不含 $y$，那么把 $x$ 当成 $y$，即将 $x$ 映射为 $y$ 即可；还剩又有 $x$ 又有 $y$ 的情况，意味着此时 $y$ 的数量将增加，$x$ 的数量将减少，而这种情况需要处理的过多，不妨也直接重构该块。且由于我们有 $a_2$ 数组，可以在 $O(1)$ 时间内知道该块内是否含有 $x$、$y$。接下来分析重构的复杂度：

一开始长度为 $n$ 将会有 $O(n)$ 的复杂度用来合并，而每次修改都会对至少两边的散块进行重构，有 $O(m)$ 的复杂度，故合并即重构的次数不会超过 $O(n+m)$，这个复杂度是可以接受的。

而现在我们要在线解决这个问题，所以其实可以借鉴一下第二分块的想法，用第二分块的并查集维护“将所有 $x$ 修改为 $y$”的操作可以接受。

接下来你就可以实现代码了，这道题不怎么需要卡常，还是蛮清新的，注意以下细节：
- $a_2$ 其实是一个 $n\sqrt n$ 的数组，第一维可以开 $\sqrt n$，第二维开 $n$。这样比反过来有很大的常熟优化，不过具体的底层机制我并不了解。
- 并查集 merge，如果没有 $x$ 这个颜色的时候记得跳过，上面说过了。
- 更新 $a_1$、$a_2$ 的时候记得注意更新顺序。
