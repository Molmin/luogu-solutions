• 按位置分块，按权值分块。

• 每个块记录每个数的前缀出现次数和每个(权值)块的前缀出现次数。

• 查询k小先整块查询，然后再块内查询即可。O(sqrt(n))。

• 下面考虑这个修改操作。

• 我们对每个块的每个不同元素进行编号，记录id和反id。

• 对于边上的，直接暴力重构即可。

• 对于整块的：

• 若本身没有x，则跳过。

• 若本身没有y，则把相应的反id的值改一下即可。

• 若本身有y，则暴力重构。

• 然后需要记录一下每个位置对应的id，用于O(1)修改（在重构之前每个位置的id不会变）。

• 下面证复杂度：
每个块内最多有sqrt(n)种颜色，共有n个不同的id

每次修改，最多让块两边多出1种颜色，而中间显然不会变多。

若本身没有y，则修改是O(1)的，且没有改变颜色个数。

若本身没有y，则修改是O(sqrt n) 的，切会减少1种颜色。

由于总颜色个数是n+m级别的，所以修改总复杂度O((n+m)sqrt(n))