排序排的是数据？错了。排序排的是元素。这些元素有**两个属性：数据和下标**。

拆开完全平方、 $\sum$ 和求 $max\{a_ib_i\}$ 的正确性不再论述，这里谨在 **以墨** 大大的题解基础上，提供一种对归并排序解法的一种思考。

1. 归并排序可以解出只允许相邻元素交换时的最小交换次数（逆序对）。

2. 归并排序根据数据的**自然数大小顺序**作为排序的**依据**，而改变排序的依据（比如重新定义数据的大小顺序）并没有动摇归并排序的**基础**，定义改变后归并排序仍然成立，因此有一个显（変）然（態）的想法就是：定义一个判断两个元素大小的函数，代替原先的大于小于号，这样就可以十分麻烦地解决这个问题。

3. 对所谓的映射的理解（排序后的 ```c[b[i].loc] = a[i].loc``` ）：
在 2 中讨论的解法，是~~不负责任的瞎搞~~考虑改变**定义**，让**数据**在新的**定义**下用原有的**方法**解决问题。然而，大佬们早就想出了更负责任的方法：改变**数据**，让它符合原有的**方法**和**定义**。具体地说，**下标**不再仅仅作为**索引**，我们以 $a_i$ **的原位置**（下标）作为**数据**，以 $a_i$ **在** $b$ **中的对应下标**作为元素的**索引**。考虑到 **以墨** 大大提到的，**下标在始态其实保持升序**，新数组实际意味着**打乱了下标**的 $a$ 数组。我们将新数组进行排序，即等同**恢复下标的有序性**。换句话说，我们是在从 $a$ 数组的终态转换到 $a$ 数组的始态，而答案显然一致。```当然，要直接理解为 b_i 元素的排序更直接也可以，不过我觉得不太好证明 qaq```

```cpp
// P1966 AC 100
// 归并排序一开始打错了 qaq
#include <iostream>
#include <cstdio>
#include <algorithm>
using namespace std;

struct S{
	int id, num;
	bool operator < (const S &b) const{
		return num < b.num;
	}
};

S a[1000000], b[1000000];
int c[1000000];
int c_[1000000];

long long sum = 0;

void ms(int a[], int l, int r){
	if(l == r)
		return;
	
	int mid = (l+r) >> 1;
	ms(a, l, mid);
	ms(a, mid+1, r);
	
	int j = mid+1, c_n = 0;
	for(int i=l; i<=mid; i++){
		while(j<=r && a[i] > a[j]){
			c_[c_n++] = a[j];
			j++;
		}
		c_[c_n++] = a[i];
		sum += j-mid-1;
		sum %= 99999997;
	}
	for(int i=l; i<l+c_n; i++){
		a[i] = c_[i-l];
	}
	
}

int main(){
	int n;
	scanf("%d", &n);
	for(int i=0; i<n; i++){
		scanf("%d", &a[i].num);
		a[i].id = i;
	}
	for(int i=0; i<n; i++){
		scanf("%d", &b[i].num);
		b[i].id = i;
	}
	
	sort(a, a+n);
	sort(b, b+n);
	for(int i=0; i<n; i++){
		c[b[i].id] = a[i].id;
	}
	
	ms(c, 0, n-1);
	
	printf("%d\n", sum);
	
	return 0;
}
``