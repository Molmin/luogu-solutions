今日刷到好题p1966实在是好题

先看题目

涵涵有两盒火柴，每盒装有 nn 根火柴，每根火柴都有一个高度。 现在将每盒中的火柴各自排成一列， 同一列火柴的高度互不相同， 两列火柴之间的距离定义为： \sum (a_i-b_i)^2∑(a 
i
​	 −b 
i
​	 ) 
2
 
其中 a_ia 
i
​	  表示第一列火柴中第 i i个火柴的高度，b_ib 
i
​	 表示第二列火柴中第 ii 个火柴的高度。

每列火柴中相邻两根火柴的位置都可以交换，请你通过交换使得两列火柴之间的距离最小。请问得到这个最小的距离，最少需要交换多少次？如果这个数字太大，请输出这个最小交换次数对 99,999,997 99,999,997取模的结果。

输入输出格式
输入格式：
共三行，第一行包含一个整数 nn，表示每盒中火柴的数目。

第二行有 n n个整数，每两个整数之间用一个空格隔开，表示第一列火柴的高度。

第三行有 nn 个整数，每两个整数之间用一个空格隔开，表示第二列火柴的高度。

输出格式：
一个整数，表示最少交换次数对 99,999,99799,999,997 取模的结果


# **首先是没有思路的**
~~然后我们偷看了一下算法标签~~
# 树状数组和归并排序

树状数组大法好！！！！！！


∑(ai​−bi​)^2考虑将这个展开
得到的是ai^2+bi^2-2ai*bi

然后ai^2+bi^2是定值
可以从2ai*bi上走了

直接就可以往max上边想

话说这个的最大值该怎么求呢？？？？

## 接下来思路诞生 直接就是处理max

## 然后又走进了死循环

~~偷瞄一下大佬的题解~~

# 偷来的~~证明~~

如果a<b c<d
则猜测ac+bd为最大的
如果ac+bd不是最大的
那么一定有比他大的
只有ad+bc
ac+bd<ad+bc

ac-ad<bc-bd
            
a*(c-d)<b*(c-d)//c-d<0

a>b不成立
# 排序思路随即而出

同时题目要求的是求交换次数
这样我们就可以明明白白的写逆序对问题了


## 思路而出

数组开不出来
离散化出来帮忙

转头走向样例

A：2 3 1 4->1 2 3 4对应原编号为：3 1 2 4
B：3 2 1 4->1 2 3 4对应原编号为：3 2 1 4
于是发现二个顺序差一个
就是逆序对

于是用一个数组map映射的小东西
此map非彼map

即为
map[B[i]编号]=A[i]编号
若题目为例
则map[1]=2,map[2]=1,map[3]=3,map[4]=4;
共有一个逆序对，交换次数++


# 这样题目就转化成了逆序对的计算

## 有两种解法
### 一个是树状数组
### 一个是归并排序
~~反正我都不会~~

教学自行
https://www.cnblogs.com/chengxiao/p/6194356.html

树状数组求逆序对
https://blog.csdn.net/m0_38033475/article/details/80330157

代码就算了
emmmmmm
溜了溜了





