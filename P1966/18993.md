题目的意思：min{∑（ai-bi）^2 (1<=i<=n)}

展开：min{∑（ai^2+bi^2-2\*ai\*bi）}=min{∑ai^2+∑bi^2-∑2\*ai\*bi}

仔细观察，可以发现∑ai^2和∑bi^2的值是不会变的，所以只能在∑2\*ai\*bi上做文章。

为使得和最小，那么∑2\*ai\*bi要最大，本题的模型就转变为max{∑ai\*bi}。(2为常数，可省略)

----------------------------------------------------------------------------------------------------------------------------------------------

\_数学分析暂时告一段落，下面讲一讲我对本题的一句话的特殊看法\_

#c[b[i].loc]=a[i].loc

这句话很重要，但是楼下说的都不太准确。

这并不是映射，其实这里利用了下标的单调升序。

可以发现c数组下标都是1~n，b数组中每个数的顺序也都是1~n的正整数，a数组同样如此。

那么对c数组进行归并排序之后，可以发现c数组中的值就是：c[1]=1,c[2]=2......c[n]=n对吧？

那么也就是说，对c数组进行归并排序就是为了让**c[i]=i**，也就是说，让b数组中第i小的数和a数组中第i小的数在同一个位置。

证明为什么**让b数组中第i小的数和a数组中第i小的数在同一个位置**就一定最优?

----------------------------------------------------------------------------------------------------------------------------------------------

\_接着上面的数学证明\_

a<b c<d

根据以上猜测，则ac+bd一定是最大的。利用反证法。

若ac+bd不是最大的，那么一定有比它更大的，只有ad+bc

ac+bd<ad+bc

ac-ad<bc-bd

a\*(c-d)<b\*(c-d)//c-d<0

**a>b**（？？？）

得出矛盾。所以从最简单的情况推出\_b数组中第i小的数和a数组中第i小的数在同一个位置\_就是最优的。

----------------------------------------------------------------------------------------------------------------------------------------------





```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
const int N=100005;
const int mod=99999997;
int n,c[N],d[N],ans;
struct node
{
    int x,loc;
}a[N],b[N];
bool cmp(node p,node q)
{
    return p.x<q.x;
}
void ALICE(int l,int r)
{
    if(l>=r)
        return ;
    int m=(l+r)>>1;
    ALICE(l,m);ALICE(m+1,r);
    int i,j,k;
    for(i=l,j=m+1,k=l;i<=m&&j<=r;)
        if(c[i]>c[j])//这里我其实是降序排的，为什么升序排的不对我也不太清楚。反正我升序排的时候样例都没过，呵呵。如果哪位大神用升序排的过了，麻烦私信我，并告诉我是怎么做的，学学！！！
            ans=(ans+r-j+1)%mod,d[k]=c[i],i++,k++;
        else
            d[k]=c[j],k++,j++;
    for(;i<=m;i++,k++)
        d[k]=c[i];
    for(;j<=r;j++,k++)
        d[k]=c[j];
    for(i=l;i<=r;i++)
        c[i]=d[i];
}
int main()
{
    int i;
    scanf("%d",&n);
    for(i=1;i<=n;i++)
        scanf("%d",&a[i].x),a[i].loc=i;//记录原始位置
    for(i=1;i<=n;i++)
        scanf("%d",&b[i].x),b[i].loc=i;//同上
    sort(a+1,a+1+n,cmp);//按高度进行排序
    sort(b+1,b+1+n,cmp);//同上
    for(i=1;i<=n;i++)
        c[b[i].loc]=a[i].loc;
    ALICE(1,n);//从1到n的归并排序，归并排序我就不啰嗦了，楼下讲得太多了
    printf("%d\n",ans);
    return 0;
}
```