/\*
不妨把上下两个序列分别叫做a序列和b序列

每个元素分别叫做a[i],b[i]......

拿样例距离

          a = 1 3 4 2

          b = 1 7 2 4

首先对a序列进行排序，b序列相应的元素也要交换位置

于是，原序列变成了

          a = 1 2 3 4

          b = 1 4 7 2

如果要最小，则是Sum(a[i]-b[i])^2最小

根据排序不等式，可以很容易知道

当拍好序后的a序列升序放置

当b序列也是升序时Sum最小

所以，也就是交换若干次，使得b序列也变成升序

因此，使用归并排序求出逆序对的个数即是答案

       
排序不等式自己去搜索吧，不解释了

       
归并排序求逆序对因为比较长，就写在程序的最后了

没看懂就看看代码

\*/






          
       
       
          
```cpp
#include<iostream>
#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<cmath>
#include<algorithm>
using namespace std;
#define MAX 100010
#define INF 2147483647
int arr[MAX];
long long n,j,c,s,sum=0;
int L[MAX/2];//合并时存放左区间
int R[MAX/2];//合并时存放右区间 
struct Node
{
      int s,w;
}a[MAX],b[MAX];
bool cmp1(Node x,Node y)
{
       return x.s<y.s;
}
void mergesort(int l,int r)//归并排序求逆序对 
{
       if(l==r)      //只有一个元素，显然有序 
          return;
       int mid=(l+r)/2;
       mergesort(l,mid);
       mergesort(mid+1,r);
       int ln=mid-l+1;//左区间数字个数
       int hl=1,rl=1;//左区间和右区间的头标记
       memcpy(L+1,arr+l,(mid-l+1)*4);
       memcpy(R+1,arr+mid+1,(r-mid)*4);
           //上面这两句可以等效替换成下面的语句，时间上几乎没有区别 
```
/\*
```cpp
       for(int i=l;i<=mid;++i)
          L[i-l+1]=arr[i];
       for(int j=mid+1;j<=r;++j)
          R[j-mid]=arr[j];
```
\*/
       
L[mid+2-l]=R[r+1-mid]=INF; //最后置为极大值，防止下方合并时出现错误

           
for(int i=l;i<=r;++i) //合并左右两个已经有序的序列


      
      
      
      
          
      
      

```cpp
       {
                 if(L[hl]<R[rl])//如果左区间的头比右区间的头更小 
                 {
                         arr[i]=L[hl++];
                         ln--;
                 }
                 else           //反之，则存在逆序对 
                 {
                         arr[i]=R[rl++];
                         sum+=ln;
                         sum%=99999997;
                 }
       }
}
int main()
{
      cin>>n;
      for(int i=1;i<=n;++i)
      {
         cin>>a[i].s;
         a[i].w=i;
      }
      for(int i=1;i<=n;++i)
      {
         cin>>b[i].s;
         b[i].w=i;
      }
      sort(&a[1],&a[n+1],cmp1);//对a进行排序，方便算b的位置 
      sort(&b[1],&b[n+1],cmp1);//对b进行排序，方便求逆序对 
      for(int i=1;i<=n;++i)//把数字放好，准备求逆序对个数 
      {
               arr[a[i].w]=b[i].w;  //这步自己拿笔写一写更好理解 
      }
      mergesort(1,n);//归并排序 
      cout<<sum<<endl;//输出结果 
      return 0;
}
```
/\*
归并排序：

每次把当前序列分为左右两个有序序列，将其逐步合并

得到结果。

还是举样例

1 4 7 2

1.对于(1 4 7 2)

左区间(1 4) 右区间(7,2)

2.对于(1 4)

左区间(1) 右区间(4)

左右区间已经有序

合并两个区间，(1,4)

3.对于(7 2)

左区间(7) 右区间(2)

左右区间已经有序

合并两个区间，(2,7)

产生了逆序对1对

左右区间已经有序

合并结果为(1 2 4 7)

产生了逆序对1对

因此，在该过程中，总共产生了两对逆序对，所以答案为2

至于如何统计逆序对个数，方法如下：

就拿样例的最后一步合并

左区间(1 4)

右区间(2 7)

因为左右区间都是有序，因此每次比较两个区间的头元素

1.左边头元素(1)小于右边头元素(2)，

因为是升序排列，显然是正常的，不计算逆序对个数

同时左边元素个数-1，排序结果变为(1)

2.左边头元素(4)大于右边头元素(2)，

此时要将原位置靠后的右区间的元素放到前面，

每一次放置会和左区间中还没有放置的元素产生

一次交换，因此，产生了逆序对的个数就是当前

左区间的元素个数，对于这里也就是1对

同时右边元素个数-1，排序结果变为(1 2)

3.左边头元素(4)小于右边头元素(7)，

同1的操作，排序结果变为(1 2 4)

4.左边无元素了(被置为INF)，INF大于右边头元素(7)

同2的操作，但是此时左边元素个数为0

排序的结果就变为了(1 2 4 7)

5.排序结束

从这个合并的过程中很容易看出如何求出逆序对个数，

我们只需要在任意一步的合并之中都执行一边这样的

操作，并且将结果累加，就是最后的逆序对个数。

\*/