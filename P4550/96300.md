自认为这道题是一道比较简单的扩展题……？此处采用了和别的题解思路不同的，纯概率意义上的解法。

首先考虑一个简化版问题：

> 每次随机一个$[1,n]$的整数，问期望几次能凑出所有数 

这东西我写过一个blog，现在`copy`过来：

>考虑期望的线性性，就是$E=\sum E(i)$，其中$E$为所求，$E(i)$为在已经取出$i-1$个数字时，取到第$i$个数字的期望。根据之前整理过的内容，“发生概率为$p$的事件，在期望$\frac{1}{p}$次之后会发生”，我们可以得到如下：
$$
\begin{aligned}
P(i)& =\frac{n-(i-1)}{n} \\
E(i)& =\frac{1}{P(i)}=\frac{n}{n-i+1}
\end{aligned}
$$
>然后把他们加起来就是
$$
E=\sum\frac{n}{n-i+1}=\sum\frac{n}{i}
$$

思路是自然的。然后考虑本题，需要给每次操作附加一个权值。所以本质上我们可以分开计算，$g_i$表示已经取出$i-1$个数字时，取到第$i$个数字的期望步数，$f_i$表示期望步数的`cost`。

考虑如何计算$f_i$。假设从一开始到拿完$i$进行了$p$次操作，这一次拿$i$需要$q$次操作，那么这$q$次操作的$\rm \sum cost$就是
$$
(p-q)\cdot q+q^2=pq
$$

这个原理需要编一下233.

大概就是考虑前一半是不考虑这一次拿，之前拿的次数，是要算进当前ans里的。后半部分$q^2$则是这一次拿数对彼此产生的贡献。首先是进行了$q$个操作，那么每次的贡献呢？我们考虑$q$的意义，$q$是“拿数次数的期望”，而“期望”则是所有情况的平均拿数次数，[（平均次数$\times$个数）$=$ 总次数 ]，所以对彼此的贡献可以用$q^2$来刻画。

然后就递推一下就好：

```cpp
	for (i = 1 ; i <= N ; ++ i)
		n = 1.0 * N / (N - i + 1), 
		g[i] = g[i - 1] + n, f[i] = f[i - 1] + g[i] * n ; 
	printf("%.2f", f[N])  ; 
```

