这道题第一眼看似乎有点难度 ~~别说你看不懂英文~~

然而，这道题只要用两次排序就能过了，具体思路如下。

通过两次排序，将更改前与更改后的数按大小排序配对起来，这样就可以使得更改的差值尽可能的小，从而减少花费。


就拿数据3 1 1 为例子吧，我们要将他们变成1 2 2 。
（注意，这里并没有说明一定要按顺序，给不懂的小伙伴提个醒）。

如果我们将数据进行排列，那么他就变成1 1 3，
第二组就变成 1 2 2 。
1 - 1 = 0，
2 - 1 = 1，
3 - 2 = 1，
怎么样，是不是比原先的配对省钱多了？
以下是我的代码

```cpp
#include<bits/stdc++.h>
using namespace std;

int n,x,y,m[666666],b[666666];
long long ans = 0;
int main(){
	cin >> n >> x >> y;
	for(int i = 1; i <= n; i++){
		cin >> m[i] >> b[i];//常规输入不多说
	}
	sort(m + 1,m + n + 1);
	sort(b + 1, b + n + 1);//不喜欢用函数的朋友们可以自行敲排序
	
	for(int i = 1; i <= n; i++){
		if(m[i] > b[i])ans += (m[i] - b[i]) * y;
		else 
		ans += (b[i] - m[i]) * x;//注意x和y不要打反了，我在这吃了好几次亏 
	}
	cout << ans;//完美输出
	return 0;
}
```

