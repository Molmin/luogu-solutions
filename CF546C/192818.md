思路：用两个队列模拟。如果某个队列为空就输出并结束程序。在设置一个数pd，用来判断是否需要输出-1。题目里给出n的数据范围$2<=n<=10$，所以把pd设置为10000，如果i>pd就结束程序。

下面上代码：

```cpp
#include<iostream>
#include<queue>//队列头文件
using namespace std;
int n,a,b,k1=0,k2=0,pd=10000,j=1;//n和k1，k2不用说了，就是题目里的。a和b分别是第一个选手的牌和第二个选手的牌，后面要加进队列，所以不需要数组。pd就是思路中所说，j是现在出了几轮牌（后面要用到while循环，所以在这里定义，我一般喜欢全局变量）。
queue<int> q1,q2;//第一个选手的牌和第二个选手的牌，使用队列存储。
int main(){
	cin>>n;
	cin>>k1;//输入第一个选手有几张牌
	for(int i=1;i<=k1;i++){
		cin>>a;//输入每一张牌
		q1.push(a);//入队
	}
	cin>>k2;//输入第二个选手有几张牌
	for(int i=1;i<=k2;i++){
		cin>>b;//输入每一张牌
		q2.push(b);//入队
	}
	while(1){//while循环，可以先把它设为死循环。
		if(j>pd){//如果循环了10000次以上
			cout<<-1<<endl;//直接输出-1
			return 0;//结束程序
		}
		if(!q1.size()){//如果第一个选手没有牌了
			cout<<j-1<<" "<<2<<endl;//输出次数和谁赢，第一个选手没有牌了肯定是第二个选手赢，这里j要-1是因为开始循环时第一次循环结束时j就是2，但出牌次数是1，所以要-1。
			return 0;
		}
		if(!q2.size()){//如果第二个选手没有牌了
			cout<<j-1<<" "<<1<<endl;//输出次数和谁赢，第二个选手没有牌了肯定是第一个选手赢
			return 0;
		}
		int ak=0;//如果上面的都不符合，就开始出牌。
		int bk=0;//ak是第一个选手出的牌，bk第二个选手出的牌。
		ak=q1.front();//出牌
		q1.pop();//出队，因为这张牌已经出过了
		bk=q2.front();//同上
		q2.pop();
		if(ak>bk){//如果第一个选手的牌大
			q1.push(bk);//先把小的入队
			q1.push(ak);//再把大的入队
		}else{//如果第二个选手的牌大
			q2.push(ak);//先把小的入队
			q2.push(bk);//再把大的入队
		}
		j++;//次数+1
	}
	return 0;//拜拜！
}
```
