### 分析
输入第一行 $ n $ 为牌的总数 ($2 \le n \le 10$)；

输入第二行为第一个人的牌的数量及有什么牌；

输入第三行为第二个人的牌的数量及有什么牌；

$\because 2 \le n \le 10 $，根据题意，直接**模拟**即可。


### 思路
看楼下都是用**队列**做的，这里提供**数组**的写法。

首先需要两个数组 $ a[i] $ 和 $ b[i] $，分别用来存两个人的手牌。

然后一直循环，直到有一方手牌的数量为 $0$；
比较 $a_1$ 和 $b_1$，如果 $a_1$ 大，就先把 $b$ 数组的每一项都向前提一位（就是手牌给了对面，其他牌仍是原顺序）；
然后把 $a$ 数组的每一项都向前提一位，再把 $b_1$ 和 $a_1$ 依次放到最后（由题目的图可知，要把本次玩的牌放到最后，且先放别人的，再放自己的。这里先放 $b_1$ 后放 $a_1$）。

如果 $b_1$ 较大，则反之。

### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[1000],b[1000];
long long c; //c用来存玩了几轮牌
int main(){
	int z;//牌的总数（好像没什么用）
	cin>>z; 
	int n,m; //n是第一个人的牌，m是第二个
	cin>>n; 
	for(int i=1;i<=n;i++) cin>>a[i];
	cin>>m;
	for(int i=1;i<=m;i++) cin>>b[i]; 
	while(c<114514){ //如果打了太多轮，就是平局，退出循环。
		if(m==0) {
			cout<<c<<" "<<1;
			return 0;
		}
		if(n==0) {
			cout<<c<<" "<<2;
			return 0;
		}
		c++;
		int p=a[1],q=b[1]; //用p，q来代指 a[1]，b[1]
		if(p>q) {
			for(int i=2;i<=m;i++) b[i-1]=b[i];
			m--;
			for(int i=2;i<=n;i++) a[i-1]=a[i];
			a[n]=q;a[n+1]=p;
			n++;
		} else {
			for(int i=2;i<=n;i++) a[i-1]=a[i];
			n--;
			for(int i=2;i<=m;i++) b[i-1]=b[i];
			b[m]=p;b[m+1]=q;
			m++;
		}
	}
	cout<<-1;
	return 0;
} 
```
