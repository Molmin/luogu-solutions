本题是和 LCS 有关的，再细想，那就是算出 LCS 的长度，然后 a,b 两串长度之和减去LCS的长度。

我们可以模仿 LCS 的构建方法来思考这个问题， $c_{i,j}$ 表示 a 串前 i 个元素和 b 串前 j 个元素所能得到的方案数。

$l_{i,j}$ 表示 LCS 的长度。

若 $a_i=b_j$,那么 $c_{i,j}=c_{i-1,j-1}$ ,即 a 串前 i-1 个元素和 b 串前 j-1 个元素得到的组合串的末尾加上一个相同的元
素 $a_i$ ,那么得到的新的组合串的个数还是和之前的组合串的个数一样。

若 $a_i$ 不等于 $b_j$ ,  $l[i][j]=max${$l_{i-1,j}$,$l_{i,j-1}$}.

若 $l_{i-1,j}>l_{i,j-1}$ ,那说明 $c_{i,j}=c_{i-1,j}$ ,即在 a 串 i-1 个元素和 b 串 j 个元素组成的组合串的后面加上 $a_i$ ,那么得到的新的组合
串的个数和之前的组合串的个数是相同的。

若 $l_{i,j-1}>l_{i-1,j}$ ,道理和上面是一样的，所以 $c_{i,j}=c_{i,j-1}$ ,相当于在之前的组合串后面加上元素 $b_j$ ,得
到新的组合串的个数不变。

若 $l_{i,j-1}=l_{i-1,j}$ ,说明从两种状态都是能得到最终的LCS并且最终的组合串不会漏掉任何相同的公共元素，

所以 $c_{i,j}=c_{i-1,j}+c_{i,j-1}$ ,即用 a 串的 i-1 个元素和 b 串的 j 个元素组成的组合串的最后加上 $a_i$ ,得到新的
组合串和之前的组合串个数相同，另外用 a 串的 i 个元素和 b 串的的 j-1 个元素组成的组合串的最后加上 $b_j$ 
得到新的组合串和之前的组合串个数相同，那么就是两者之和。

示例代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
int c[1005][1005],l[1005][1005];	//dp 用数组
int main()
{
    int T;
    cin>>T;
    getchar();	//注意行末有多余回车
    for(int k=1;k<=T;k++)
    {
        string a,b;
        getline(cin,a);
        getline(cin,b);
        int la=a.size(),lb=b.size();
        for(int i=0;i<=la;i++)
        {
            l[i][0]=0;	//初始化
            c[i][0]=1;
        }
        for(int i=0;i<=lb;i++)
        {
            l[0][i]=0;	//同上，注意顺序
            c[0][i]=1;
        }
        for(int i=1;i<=la;i++)
        {
            for(int j=1;j<=lb;j++)
            {
                c[i][j]=0;	//注意清零！
                if(a[i-1]==b[j-1])	//加上 a[i]
                {
                    l[i][j]=l[i-1][j-1]+1;
                    c[i][j]=c[i-1][j-1];
                }
                else
                {
                    l[i][j]=max(l[i-1][j], l[i][j-1]);	//取最大值
                    if(l[i-1][j]==l[i][j]) c[i][j]+=c[i-1][j]; 	//加上 a[i]
                    if(l[i][j-1]==l[i][j]) c[i][j]+=c[i][j-1];	//加上 b[j]
                }
            }
        }
        cout<<"Case #"<<k<<": "<<la+lb-l[la][lb]<< " " <<c[la][lb]<<endl;	//输出答案
    }
    return 0;
}
```


