## 前言

~~一看到没有题解贺就浑身难受。~~

## 正解

（下面说的数 $i$ 一般指的是值为 $i$ 的数）

首先，凭直觉知道，一般这种求方案数的题目都是和 dp 有关。

然后，若直接 dp，没有目的地乱选，也就是说在操作一些数后，我们无法有效记录当前的状态——因为我们不知道序列的形状，我们觉得整个序列都有必要记录。因此肯定是按照一定规律进行移动。

经过手摸之后，我们发现对于一个值为 $i$ 的数，固定他最后一次操作的时间和位置（放在开头或者结尾）后，所有在这个时间之前的对这个数的操作都不会影响这个数的最终位置。因为对于在这个时间之前的所有操作，都不会改变其他数的相对位置和操作，只有最后一个操作会影响这个数的位置。

因此对于一个数，我们只关心他的最后一次操作的时间以及移动到开头还是结尾。依此，我们把所有数分成两类：被操作过和未被操作过。

我们先考虑未被操作过的数。发现若在序列上 $(1,2\dots n)$ 上固定了两个未被操作过的数（设为 $l$ 和 $r$），那么对于子区间 $[l,r]$ ，每次操作只可能会从这个区间中取一个数往外放，已经放在外面的数不可能再放进来。即：若假设这两个数在序列 $(a_1\dots a_n)$ 中的位置为 $p_l$ 和 $p_r$，那么 $\forall i\in [p_l,p_r]$，$a_i \in [l,r]$ 并且一定不会被操作。因为 $l$ 和 $r$ 已经固定，不可能往里填数，因此若 $a_i$ 一开始不在 $[l,r]$ 内就无法再移进来。若在 $[l,r]$ 内则一操作就会移动出去，不能移动。

然后大力不断归纳可以看出，未被操作的数在 $(a_1\dots a_n)$ 上的位置是一段连续的区间，并且满足值随着位置增加而增加。因此我们先考虑暴力 $O(n^2)$ 枚举这个区间 （设为 $[l,r]$）。

做完这个后，我们再来考虑已经被操作过的数。我们先只考虑有效操作，因为每个数只有一次有效操作，那么对于 $(a_1\dots a_{l-1})$，我们肯定是先放 $a_{l-1}$，再放 $a_{l-2}\dots $ 依此类推。也就是说我们对于放在开头的有效操作来说，放数的相对顺序是固定的。又因为他可以任意选择一个数放，因此对于我们重要的状态只有：

* 操作了几次

* 在开头已经有几次有效操作，在结尾已经有几次有效操作。

注意我们正着做无法判断当前的操作是不是有效操作，因此我们考虑按照操作顺序倒着做。

我们设 $dp[i][l][r]$ 表示后 $i$ 次操作中，开头有 $l$ 次有效操作，结尾有 $r$ 次有效操作的方案数。转移为：

* 当前这个操作是有效操作，可以选择放到开头或者结尾：$dp[i][l][r] \longrightarrow dp[i+1][l+1][r],dp[i+1][l][r+1] $ 

* 当前这个操作是无效操作，必须选择已经操作过有效操作的数，每次可以选择放到开头或者结尾：$dp[i][j][k] \stackrel{2\times (j+k)}\longrightarrow dp[i+1][j][k]$

然而这样 $dp$ 时间复杂度是 $O(n^3)$ 的，考虑优化。

我们发现 $dp$ 的转移系数为 $1$ 或者 $j+k$ ——与单独 $j$ 或 $k$ 的取值无关。这样启示我们把 $j,k$ 两维缩成一维。但怎么缩呢？

我们考虑我们为什么能压缩：按照通用套路，我们把 $dp$ 转移建成拓扑图：对每个状态 $dp[i][j][k]$ 建一个点 $(i,j,k)$。若两个点之间有转移，那么连一条有向边，边权为转移系数。我们定义一条路径的贡献为这条路径上的边权积。那么 $dp[i][j][k]$ 就为：从点 $(0,0,0)$ 到点 $(i,j,k)$ 的所有路径的贡献和。

三维的 $dp$ 转移就是把所有到 $(i,j,k)$ 点的路径缩成一个状态进行转移。因为有很多不同的边的边权相同，我们换一个角度：考虑有多少条路径依次经过的每条边权相
同，我们把它缩成一条路径考虑。

我们新创建一个拓扑图，对于每个状态 $(i,sum)$，我们创建一个点。然后我们对 $(i,sum)$ 向 $(i,sum+1)$ 连一条权值为 $1$ 的边，再对 $(i,sum)$  向 $(i+1,sum)$ 连一条权值为 $sum$ 的边。容易发现原图中的每条路径都可以映射在这个新图的一条路径上。

那么对于一个原图状态 $dp[i][j][k]$，与新图状态 $(i,j+k)$ 中的每条路径的贡献乘上相同的路径数量的和相等。分别对于每个路径考虑在原图中相等的路径数量。我们考虑对于新图的一条路径对应到原图，能够对应多少条合法的路径。

对于这条路径的每条边，我们把它拆分成往左走（$(i,j) \rightarrow (i+1,j)$） 和向上走（$(i,j) \rightarrow (i,j+1)$ ）。对于往左走的边，由于只改变了 $i$ 的取值，与我们缩的两维无关，因此并不会影响到路径的数量。对于向上走的边，在原图中每次能使 $j$ 或者 $k$ 自增 $1$。而显然在 $dp[i][j][k]$ 中 $j,k$ 的取值是固定的。也就是合法的路径数量为：我们对于每一条向上走的边，我们能使 $j$ 或 $k$ 自增 $1$，最终使得 $j$ 和 $k$ 为某一固定值的方案数。这显然是一个轻松的组合数问题。若最终状态为 $j=a,k=b$，那么方案数为 $C_{a+b}^{a}$。

而对于新图中的每条路径，由于向上走的边数相同，因此方案数也相同。那么可以把这个看做系数提出来。

那么对于新图中的状态 $(j,k)$ ，设 $f[j][k]$ 为从 $(0,0)$ 到 $(j,k)$ 的路径权值和。那么有： $dp[i][j][k]=C_{j+k}^{k}f[j][k]$。

~~好像说复杂了。。。~~

然后 $f$ 数组的转移是 $O(n^2)$ 的：

* $f[i][j] \rightarrow f[i][j+1]$

* $f[i][j] \stackrel{2\times j}\rightarrow f[i+1][j]$

那么总的复杂度就是：$O(n^2)$

## 代码


~~不会吧，不会吧，不会真的有人连只有 $30$ 行的代码都要贺吧。咦？是我，那没事了。~~

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const int N=3010,mod=998244353;
int n,m;
int a[N];
int f[N][N<<1],c[N][N];
signed main()
{
	scanf("%lld%lld",&n,&m);
	for(int i=1;i<=n;i++)scanf("%lld",&a[i]);
	for(int i=0;i<=m;i++)
	{
		c[i][0]=1;
		for(int j=1;j<=i;j++)c[i][j]=(c[i-1][j-1]+c[i-1][j])%mod;
	}
	f[0][0]=1;
	for(int i=1;i<=m;i++)
		for(int j=0;j<=n;j++)
		{
			if(j)f[i][j]=f[i-1][j-1];
			f[i][j]=(f[i][j]+f[i-1][j]*2*j)%mod;
		}
	int ans=0;
	for(int i=1;i<=n;i++)
		for(int j=i;j<=n;j++)	
		{
			ans=(ans+f[m][i-1+n-j]*c[i-1+n-j][i-1])%mod;
			if(a[j]>a[j+1])break;
		}
	for(int i=0;i<=n;i++)ans=(ans+f[m][n]*c[n][i])%mod;
	printf("%lld\n",ans);
	return 0;
}
```

## 后记

整个题目缩点最妙的还是把三维缩成两维。考场上能感性猜一个系数，但赛后还是这样~~可能应该也许~~理解为自然一点。