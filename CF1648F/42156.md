> 给定任意无向图，$n$ 个点 $m$ 条边，$q$ 对关键点 $(x,y)$。
>
> 你需要把恰好两条边标记为关键边，假设关键边边权为 $1$、普通边边权为 $0$，在这个图上求出 $\sum_{i=1}^q dis(x_i,y_i)$。
>
> 计算在任意选择两条关键边时，上式最大值。输出方案。
>
> $n,m,q\le 500000$

一道 Educational 的题，做完后学到了很多！！！

虽然本题没有直接用到边三连通分量的知识，但提前了解边三的 Hash 求法对理解本题很有帮助。可以去洛谷模板学习。

求出任意一棵 dfs 树。如果割的两条边都是非树边，显然答案是 $0$。

对于每对关键点，给 dfs 树上这两点之间路径的边的权值 $v(e)$ 加一。对于每个非树边赋 $[0,2^{64}-1]$ 的随机权值，给这条非树边在 dfs 树上 cover 的边的权值异或上这个权值，设某条边的权值为 $w(e)$。分类讨论（以下讨论其实都是基于边三求法中的几种情况）：

1. 割掉两条割边 $e_1,e_2$。答案是 $v(e_1)+v(e_2)$。
2. （是 1. 的特例）如果只有一条割边，可以割掉一条割边 $e_1$，另一条只要不是割边就不会对答案造成贡献，答案是 $v(e_1)$。
3. 割掉任意一条树边 $e$ 和某条非树边，根据经典结论（边三求法中有涉及），必须满足有且仅有一条非树边 cover 这条树边，答案是 $v(e)$。判一下这条树边的权值是否是某条非树边的权值即可。
4. 割掉两条树边 $e_1,e_2$，使得 $w(e_1)=w(e_2)$。（边三求法中有涉及）这时，答案是恰好覆盖了 $e_1,e_2$ 中的一条的关键点对之间的路径数。

难点在于情况 4。考虑从上往下 dfs 整个 dfs 树，以深度为下标维护线段树。在 dfs 到一个深度为 $d$ 的点 $x$（设其父边为 $e_1$）时，线段树上下标为 $i$ 的位置应该维护出 $x$ 深度为 $i$ 的祖先的父边作为 $e_2$ 时，的答案。 

假设没有 $w(e_1)=w(e_2)$ 的限制，如何维护出“恰好覆盖了 $e_1,e_2$ 中的一条的关键点对之间的路径数”？设 $A$ 为覆盖 $e_2$ 但未覆盖 $e_1$ 的路径数，容易推知答案是 $A+v(e_1)-(v(e_2)-A)=(2A+v(e_1))-v(e_2)$。如果能用线段树上区间加操作维护出 $A$，通过处理一下标记，上式的最大值也是可以维护的。

下面考虑加上 $w(e_1)=w(e_2)$ 的限制，注意到每种权值的边只会完全包含而不会相交（边三结论），所以这样做：假设 $E$ 是当前边（离开权值为 $w(e)$ 的边这条边），$E'$ 是权值为 $w(e)$ 最浅的边，则给 $[dep(E'),dep(E)]$ 加上 $-\infty$，回来的时候加回来。

接下来，重头戏来了：如何维护出 $A$？

注意到，$e_1,e_2$ 一定互为祖先关系（边三结论），所以可以认为关键点对 $(a,b)$ 之间的路径是两条互不相干的端点互为祖先关系路径 $(a,lca),(b,lca)$。

对一条端点为祖先关系的路径 $(a,b)$，在 $a$ 处给深度 $[1,d_a]$ 加一，在 $b$ 处减一即可维护出 $A$……吗？不对！如果整棵树都是一条链这样当然没问题，但是会出现这种情况：

![](https://cdn.luogu.com.cn/upload/image_hosting/do88s2cx.png)

如上左图，在 $p$ 时因为询问链的存在，给 $[1,d_p]$ 加了一。然而，从 $q$ dfs 到 $r$ 的过程中，询问链理应从我们的线段树上消失（因为它并没有覆盖 $q\to r$ 这条边），然而上面的求法没有管！

如果我们在每条链理应消失的时候都在线段树上真的执行区间减，这样的区间减操作又会有 $O(nk)$ 个，承受不起。

但注意到，如果 $(q,r)$ 这条边的哈希值并没有在 $q$ 的祖先中出现（也就是没有 $(p,fa_p)$ 这条边），那 $r$ 的子树内询问时也不会用到 $r$ 子树外的边（根据边三结论，哈希值出现区间互不相交）（当然，还可以有子树外比 $p$ 更浅的边造成贡献，即上图右，不过下面的算法也能考虑这种情况）。

注意到一个点至多只有一个儿子子树内部的边有可能和子树外的边配对，如果存在这样的儿子，就说这个儿子是重儿子。重儿子的判断是容易的，记录子树中所有边配上的最浅的边的深度，判断是否 $\le d_x$。其次注意到，每条询问链有可能像上图一样造成错误的贡献的情况只会出现至多一次（只会出现在配对的两条边一条在询问链上方，一条在询问链斜下方时；根据哈希值只包含不相交的性质容易证明），设某条链 $A$ 产生错误的边是 $e(A)$。

但官方题解并没有提到怎么找这条 $e(A)$。。。不过在与 fzjn 讨论后得到了一种方法。下面，我们给出一种对每条询问链找出其产生错误贡献的那条边的算法。（I credit this to fzjn）

- 从上往下 dfs 整棵树，对于一条询问链 $(x,y)$（$y$ 比 $x$ 深），把它挂在 $y$ 上。
- 对于每个点，如果有重儿子，就最后 dfs 重儿子。维护一个询问链的 set。
- dfs 完轻儿子之后、重儿子之前，不停找到深度最浅的上端点深度 $\ge d_z$（$z$ 是与 $x$ 重儿子配对的边）的询问链，如果这条链链顶深度 $\le d_x$ 说明它的 $e$ 就是 $(x,son_x)$，否则说明它不存在 $e$。
- 然后 dfs 重儿子。
- dfs 完之后，删掉所有不能留给父亲配对的链（即链顶深度 $>d_x$）的链。
- 然后把挂在 $x$ 上的链加进 set。

这个算法正确性很显然，如果不理解可以看代码。

综上所述，本题在 $O(m+(n+k)\log n)$ 时间内得到解决。

实现上有一些细节~~我调了 6h~~。我自己的代码实现中路径需要把 $lca$ 删掉，转而用 $x\to prev(lca)$（路径上 $lca$ 之前的点）和 $y\to prev(lca)$ 执行上面的算法。

代码（仅仅只有 6kb，实在是太小清新了！）：https://codeforces.ml/problemset/submission/1648/151414821