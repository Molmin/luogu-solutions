# AT4522 Frog 1

**题目分析**：

很明显的一道动态规划题，就是求青蛙到第 $n$ 块石头最少需要的力量。

**状态设计**：

显然对于第 $n$ 块石头，青蛙只能从第 $n-1$ 块石头或第 $n-2$ 块石头跳过来。

我们把到达第 n 块石头最少需要的力气称为 $f_n$，那么对于 $f_i$，我们可以写出以下代码：

```cpp
f[i] = min(f[i-1] + abs(h[i-1]-h[i]),f[i-2] + abs(h[i-2]-h[i]));
```
而我们要求的值就是 $f_n$。

**动规边界**：

青蛙本身就在第 $1$ 块石头上，所以 $f_1 = 0$，而青蛙只能从第 $1$ 块石头跳到第 $2$ 块，所以 $f_2=f_1+abs(h_2-h_1)$, 其实就是 $abs(h_2-h_1)$。

**参考代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;
int n,f[100010],h[100010];
int main()
{
 	cin>>n;
 	for(int i=1;i<=n;i++) cin>>h[i];
 	f[1] = 0,f[2] = abs(h[2] - h[1]);
 	for(int i=3;i<=n;i++){
 		f[i] = min(f[i-1] + abs(h[i-1]-h[i]),f[i-2] + abs(h[i-2]-h[i]));
	}
	cout<<f[n];
	return 0;
}
```
