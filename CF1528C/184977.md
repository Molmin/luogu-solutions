考场上没做出来亏大了。谨以此题解膜拜 @Reanap 和记录我的傻逼。

显然，我们选作为答案的点在第一棵树上的根到某一个叶子的链上。不妨先考虑第一棵树是一条链的做法。我们在考虑加入一个点的时候，有以下三种情况：

1. 在第二棵树上加入这个点，使得选的点的公共祖先发生改变且仍然满足条件；   
2. 在第二棵树上加入这个点，使得之前选的点的公共祖先是这个点的祖先；    
3. 在第二棵树上加入这个点，使得这个点是之前选的点的公共祖先的祖先。

分情况讨论。对于第一种情况，显然答案可以增加不要白不要；对于第二三种情况贪心考虑，显然答案无变化，那么让公共祖先的深度越深越好，即第二种情况不管，第三种情况将原来的公共祖先删去，将当前的公共祖先置为新加入的点。

注意到我们整个的讨论只跟选的点的公共祖先有关，我们没必要管哪些点实际在。

注意到链与链之间互不冲突可以合并，于是就可以做到 $O(n \log n)$ 了。完全不懂为什么有人会用树剖。

因为懒得写代码所以讲一下实现细节。我们在遍历第一棵树的时候将在第二棵树上的当前的公共祖先记下来。每次修改的时候比较深度即可。

我怎么这么傻逼啊？？