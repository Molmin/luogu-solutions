#### [题 目 传 送 门](https://www.luogu.com.cn/problem/CF1473B)

#### [题意解析]


如果字符串 $s$ 可以变为 $n$ 个 $s1$，那么 $ s$ 能被 $s1$ 整除。

定义两个字符串 $s1$，$s2$  的最短公倍串为：可以被 $s1$ 与 $s2$ 整除的最短的非空串。

#### [思路分析]

当不知道 $s1$ 与 $s2$ 的最短公倍串长度时，会比较难办，所以假设 $s1$ 与 $s2$ 的最短公倍串的长度为 $|s1|$ 与 $|s2|$ 的最小公倍数，设这个数为 $l$，证明：没有长度比 $l$ 更短的公倍串。当串长度小于 $l$ 时，不难想到，它的长度一定不能满足同时是 $|s1|$ 与 $|s2|$ 的倍数。证明：当没有长度为 $l$ 的公倍串时，没有长度比 $l$ 更长的公倍串。首先，当长度不为 $l$ 的倍数，一定不能满足同时为 $|s1|$ 与 $|s2|$ 的倍数。当长度为 $l$ 的倍数时，会将长度为 $l$ 的串复刻若干次，当长度为 $l$ 的串都不满足条件时，长度为 $l$ 的倍数的串也一定不满足条件。

综上所述，得证：$s1$ 与 $s2$ 的最短公倍串的长度一定为 $|s1|$ 与 $|s2|$ 的最小公倍数。所以我们只要循环判断长度为 $|s1|$ 与 $|s2|$ 的最小公倍数的串是否满足条件就好了。

#### [贴上码码]
```cpp
#include<bits/stdc++.h>
using namespace std;
int t;
string s1,s2;
int main()
{
	cin>>t;
	while(t--)
	{
		cin>>s1>>s2;
		int l1=s1.size();
		int l2=s2.size();
		int l=l1*l2/__gcd(l1,l2);
		string t1="",t2="";
		for(int i=1;i<=l/l1;i++)
			t1+=s1;
		for(int i=1;i<=l/l2;i++)
			t2+=s2;
		if(t1==t2)cout<<t1;
		else cout<<-1;
		cout<<"\n";
	}
	return 0;
}
```
