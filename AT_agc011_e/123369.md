[[AGC011E] Increasing Numbers](https://www.luogu.com.cn/problem/AT2341)

一种乍一看很对但是证明比较麻烦的解法。

------

首先显然可以套一个二分。

设当前二分的答案是 $K$。令 $s_i$ 表示第 $i$ 位上的元素（$0$ 为最高位，$n-1$ 为最低位），令 $t_i$ 表示选中的 $K$ 个数在第 $i$ 位上的元素和（不进位）。则，当前 $K$ 合法当且仅当存在一种填数方法使得：

- $t_{n-1}\leq9K$（最后一位就算全填 $9$ 也只能是 $9K$）。
- $t_i\leq t_{i+1}$（所有数都递增，所以该条件必须满足；且只要满足该条件就存在合适的填数方法）。
- 在考虑进位后有 $s=t$。

我们发现一个非常讨厌的地方，也即我们同时要满足 $t$ 的递增以及进位的信息。

从右往左扫，维护当前 $t_i$ 以及低位进位上来的东西。调小 $t_i$ 直到 $t_i$ 加上低位的进位恰好满足 $s_i$ 的限制，然后进入下一位（并同时维护进位）。假如直到最后都没有发生 $t_i$ 被调到负数，则我们声称当前 $K$ 合法。

乍一看上述算法是没有问题的，但是事实上最大的问题是，到最高位时还有若干进位没用掉，导致当前和与目标和虽然在低 $n$ 位均相同，但是更高位上还有若干进位。

这些进位可以被简单忽略掉吗？似乎不太行的样子，但是交上去就过了。

下面我们来证明一下其正确性。

首先我们考虑 $t$ 在进位中的变化。每进一位，$t$ 至多减小 $9$。

然后考虑对 $t$ 作一些变化使得进位减小。显然，我们可以对某个 $t_i$ 减 $10$ 并令 $t_{i-1}$ 加一。因为相邻两位间差不超过 $9$，所以该操作会使得 $t_{i-1}$ 立刻与 $t_{i-2}$ 变得不合法，我们需要将 $t_{i-1}$ 也减 $10$ 并将 $t_{i-2}$ 加一。两个合起来，$t_{i-1}$ 减小了 $9$ 而 $t_{i-2}$ 增大了 $1$，差仍然大于 $9$，会继续下去。直到 $t_0$ 减小了 $9$，此时理应要 $t_{-1}$ 增加 $1$；但是我们如果忽略这一步，就等价于进位减少了一。

换句话说，我们可以执行这样的操作：

- 对于一段前缀，令其中每个 $t$ 都减 $9$。令该前缀的下一个 $t$ 减 $10$。

每执行一次该操作，都会让进位的数减小 $1$。目标是把进位的数变成零。

我们考虑找到一组操作序列，使得在每次操作后均 **不改变相邻两个 $t$ 的差不超过九** 的性质。这样不断执行该操作，直到无法再进行。此时显然进位就被消成了零。

> 事实上，该操作只不过是把一个进位给它重新拆回每一位中。

找到最靠后的满足 $t_i<t_{i+1}$ 的位置 $i$，令 $t_{0\sim i}$ 减小 $9$、$t_{i+1}$ 减小 $10$。因为是最靠后的所以再往后的后缀必然全部相同，进而这一步必然不破坏差的性质。进而不断进行即可最终消掉进位。

这样，我们便证明了上述流程的正确性，也即只要上述流程得到了 $t_0\geq0$ 的一组解，就可以通过上述调整使得最终不会往前进位，换句话说就是得到了合法解。

不排除有省掉二分的可能性，但是我太懒不管了。

时间复杂度线性对数。

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
char s[500100];
int S;
bool che(int ip){
	int sum=9*ip,rem=0;
	for(int i=S-1;i>=0;i--){
		while(sum&&((sum+rem)%10)!=s[i]-'0')sum--;
		if(((sum+rem)%10)!=s[i]-'0')return false;
		rem+=sum;
		rem/=10;
	}
	return true;
}
int main(){
	scanf("%s",s),S=strlen(s);
	int l=1,r=S<<1;
	while(l<r){
		int mid=(l+r)>>1;
		if(che(mid))r=mid;else l=mid+1;
	}
	printf("%d\n",l);
	return 0;
}
```

