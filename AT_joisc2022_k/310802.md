题意：单点修，区间查询能吃完区间全部鱼的个数。

鱼 $x$ 能吃鱼 $y$ 当且仅当 $x,y$ 相邻并且 $a_x\ge a_y$，吃完后 $a_x$ 变成 $a_x+a_y$。

---

这种合并操作启发我们倍增值域分块，具体来讲，对于 $k\in[0,30]$，$a_i\in[2^k,2^{k+1})$ 的分成一层，这样我们总共分成了 $O(\log V)$ 层。

考虑如何查询整体答案，我们先把最高层的若干个点拉出来，假设是 $p_1,p_2,\dots p_k$，假设 $p_0=0,p_{k+1}=n+1$。

那么对于一个 $p_i$，显然可以把区间 $[p_{i-1}+1,p_{i+1}-1]$ 的鱼都吃掉，因为中间的鱼层数都比它低。然后只要它能吃掉 $p_{i-1}$ 或 $p_{i+1}$ 其中一条，它的层数就会加一，把这一层全部吃完，写成前缀和形式就是 $s_{p_{i+1}-1}-s_{p_{i-1}}\ge \min(a_{p_{i-1}},a_{p_{i+1}})$，注意特盘边界。

对于一段极大连续非本层点 $(p_i,p_{i+1})$，容易发现里面的鱼能吃完本层全部点的必要条件是独立把这一段的所有点吃完，然后同理，只要能吃掉 $p_i$ 或者 $p_{i+1}$，那么也可以吃掉本层所有店，问题转化为一个子问题。

连续段的维护启发我们用 `set`。查询外层只有 $O(\log V)$ 个散块要重新查询，中间的相当于单层区间求和，可以用树状数组之类的数据结构维护；单点修同理，每一层只会影响 $4$ 个东西的答案，具体是每一层左右两边的连续段和点。这是平凡的，但是较为麻烦。笔者较菜，并没有找到有没得实现方式，只会比较暴力的修改方式，具体就是先把包含修改位置的区间裂开，然后再合并上方的一些。注意到对于某一层的非本层段的贡献是基于下一层的，无论分裂还是合并都需要从下到上进行。

常数略大，复杂度 $O(n\log n\log V)$。

