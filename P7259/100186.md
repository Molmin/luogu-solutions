### 题意简述

- 按照数字出现的**频数从大到小**，对数字进行排序，若有相同则**第一次出现的位置**靠前的排在前面。
- 输出时每个数字输出的次数与其频数相同。

~~好像并没有简化。~~

### 思路

一开始想桶排，但是根据 $C$ 的范围，开十亿的数组显然不可行。否定了桶排，这是 $C$ 唯一的作用，接下来的解题过程只能说跟 $C$ 毫无关系。

要存的东西好像有点多啊。频数、数字和第一次出现的位置都要存。而且之后还要**排序**，分成好几个数组来存储不便于排序。而给**结构体**排序就方便多了。所以用**结构体**存储这些信息。

- $cnt$ 表示频数
- $num$ 表示数字
- $st$ 表示第一次出现的位置

已经想好怎么储存信息了。那么，开始读入数据。

将原序列中的数依次读入。如果读入的数已经出现过，那么就将其对应 $cnt$ 加 $1$；如果没有出现过，就新开一个结构体，记录 $st$（当前位置）、$num$（读入的数）和 $cnt$（没有出现过，所以这是第一次出现，即 $cnt = 1$）。

数据都读入完毕了。接下来给储存的信息排序。

排序当然用sort ~~，你看题目都告诉我们了~~。但是我们要对结构体排序，结构体有多个变量，所以我们得告诉机器，要用什么标准进行排序。

回顾题意。得出对两个结构体的判断顺序前后的方法。

- 如果出现的频数 $cnt$ 相同，那么第一次出现的位置 $st$ 靠前的排在前面。
- **否则**，出现频数 $cnt$ 大的排在前面。

根据上文写下代码：
```cpp
bool cmp(node x, node y){
	if(x.cnt == y.cnt)
		return x.st < y.st;
	return x.cnt > y.cnt;
}
```

最后就是输出。按照排序后的顺序输出，每个数字输出的次数与频数相同。

### 完整代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int n, c, a, fl, tot;
struct node{
	int num, cnt, st;
}t[1010];
bool cmp(node x, node y){
	if(x.cnt == y.cnt)
		return x.st < y.st;
	return x.cnt > y.cnt;
}//比较函数
int main()
{
	scanf("%d%d", &n, &c);
	for(int i = 1; i <= n; i ++)
	{
		scanf("%d", &a);
		fl = 0;//fl用来记录读入的数是否出现过
		for(int j = 1; j <= tot; j ++)
		{
			if(a == t[j].num)//读入的数已经出现过
			{
				t[j].cnt += 1;
				fl = 1;
				break;
			}
		}
		if(fl == 0)//读入的数没有出现过
		{
			t[++ tot].num = a;//tot用来记录目前结构体的数量
			t[tot].cnt = 1;
			t[tot].st = i;
		}
	}
	sort(t + 1, t + tot + 1, cmp);
	for(int i = 1; i <= tot; i ++)
		for(int j = 1; j <= t[i].cnt; j ++)
			printf("%d ", t[i].num);
	return 0;
}