 首先我们看题目可知，对于一个正整数 $n$，如果它的最高位与最低位相同，那么这个数就是合法的。现在让我们求的是一个范围内合法数的个数。
 
 如果我们将大于等于 $10$ 数字按每十位为一行列出来，可以发现，每一行合法的数有且仅有一个，所以只要我们在一行中判断出来一个合法数后就可以直接忽略掉这一排，直接进行下一排。
 
 知道了这个，由于我们是只需要求一个范围内的数量的，所以只需要让 $l$ 和 $r$ 的值是一个整十数就行了，将它们变成整十数以后，就可以求区间 $[l, r]$ 内所有合法的数了。因为每十个数中只有一个合法的数，所以在求这个区间的个数时，可以直接把它们的个位忽略掉，然后计算右边减去左边值。例如：当 $l = 30, r = 170$ 时，它们之间合法的数就是将它们的个位去除，然后计算 $17-3$ 的值，也就是 $14$。
 
 我们再考虑一下，因为我们输入的 $l$ 和 $r$ 不可能是整十数，它还有零数，那这怎么处理呢？其实也很好解决，首先，对于 $l$，如果它的个位比它的最高位小或相等，那么总个数必须加一个，因为我们是要求 $l$ 和 $r$ 之间合法的数，所以当 $l$ 的个位比最高位小时，说明该行往后存在合法的数；当然如果比最高位大，那么往后就不会有合法的数了。再来考虑 $r$，这时候我们要类比 $l$ 来思考，还是那句话，求的是 $l$ 和 $r$ 的范围，那么 $r$ 的处理思路必须和 $l$ 的处理思路反过来，所以当 $r$ 的个位大于等于最高位时，总个数需要加一个。最后，将 $l$ 变成不小于它本身的最小整十数，$r$ 变成不大于它的最大整十数即可，再按上一自然段的规律去比较。
 
 但是，如果在范围内存在只有一位的数，那么我们就需要特判。当 $l$ 小于 $10$ 时，将个位的合法数全部统计出来，然后直接让 $l$ 变成 $10$。如果在 $l$ 是一位数的同时 $r$ 也是一个一位数，那么最后的答案其实就是 $r - l + 1$。
 
 最终的 AC 代码：
 
 ```cpp
#include <iostream>
#include <cstdio>
#include <cmath>
using namespace std;
typedef long long ll;
ll l, r;
ll ans = 0;
ll pnum(ll n){ // 统计位数
	ll x = n, sum = 0;
	while(x > 0){
		x = x / 10;
		sum++;
	}
	return sum;
}
inline ll geth(ll n){ // 获取最高位
	return n / pow(10, pnum(n) - 1);
}
inline ll getl(ll n){ // 获取最低位
	return n % 10;
}
int main()
{
	scanf("%lld%lld", &l, &r);
	if(l == r){ // 这是一个特判，l和r相等的情况
		if(getl(l) == geth(l)){
			printf("1");
			return 0;
		}
		else{
			printf("0");
			return 0;
		}
	}
	if(l < 10){
		if(r < 10){
			ans = ans + r - l + 1;
			printf("%lld", ans);
			return 0;
		}
		ans = ans + 9 - l + 1;
		l = 10;
	}
	if(getl(l) <= geth(l)) ans++;
	if(getl(r) >= geth(r)) ans++;
	l = l + 10 - (l % 10);
	r = r - (r % 10);
	ans = ans + (r / 10 - l / 10);
	printf("%lld", ans);
	return 0;
}

```

 这是一位初二蒟蒻的第一篇题解，做的不好，轻喷。