其实个人认为自己的做法是数位$DP$与计数问题的杂糅，或者说以数位$DP$的形式进行小学生的统计。

首先令$f_{i,j}$表示数的长度为$i$位，最高位和最低位都等于$j$的数的个数，则$i \in [1,18],j\in [1,9]$。那么一旦位数和两端的数字确定，即可得到$f_{i,j}=10^{\max(i-2,0)}$（$\max(i-2,0)$的目的是避免一位数时出现错误）。

设$L$的位数为$x$，$R$的位数为$y$。$l_1,l_2$分别表示$L$的最高位和最低位，$r_1,r_2$分别表示$R$的最高位和最低位。

很显然，答案由三部分组成：位数为$x$的数，位数为$y$的数，位数在$[x+1,y-1]$的数。

最后一部分的数量比较好求，即$\sum\limits_{i=x+1}^{y-1}\sum\limits_{j=1}^{9}f_{i,j}$。

接下来考虑位数为$x$的情况。

如果$l_1 \leqslant l_2$，那么两端为$\min(l_1,l_2)+1$或更大的数一定大于$L$，因此答案的一部分是$\sum\limits_{i=\min(l_1,l_2)+1}^{9}f_{x,i}$。另外一部分就是两端的数字与$\min(l_1,l_2)$相等，此时将两端的数字去掉后中间剩下的那个数字必须要严格比$L$中间那个数字大（如果$l_1=l_2$则也可以相等），所以答案为$10^{x-2}$与中间那个数字之差再减去$1$。当$l_1=l_2$时，答案需要再自增。

如果$l_1>l_2$，那么两端为$\max(l_1,l_2)+1$或更大的数一定大于$L$，因此答案的一部分是$\sum\limits_{i=\max(l_1,l_2)+1}^{9}f_{x,i}$。另外一部分就是两端的数字与$\max(l_1,l_2)$相等，这时因为$l_1$已经严格大于$l_2$，去掉两端后中间剩下的那个数字只要大于等于$L$去掉两端后剩下的那个数即可。答案为$10^{x-2}$与中间那个数字之差。

例如$42356$，当两端的数字都是$4$的时候，显然$42354$是小于它的，从$42364$开始才符合要求，那么我们要统计的就是符合条件的诸如$236,237,...,999$这样的数字，数量为$1000-235-1=764$。

同理，位数为$y$时，也可以用相似的方法计算。

如果$r_1≥r_2$，则两端为$\max(r_1,r_2)-1$或更小的数字一定符合要求。若两端为$\max(r_1,r_2)$且去除两端后中间那个数字一定要严格小于$R$去掉两端后的那个数，答案就是$R$去掉两端后的数。如果$r_1=r_2$，则答案自增。

如果$r_1<r_2$，则两端为$\min(r_1,r_2)-1$或更小的数字一定符合要求。若两端为$\min(r_1,r_2)$，则去掉两端后中间的数字只需小于等于$R$去掉两端后的数即可，答案为$R$去掉两端后的数加$1$。

注意，如果是一位数，那么去掉两端后的数应被当作$0$来计算，而不是$10^{-1}$。

**需要注意的是，如果$x=y$，则不能用上面的方法求答案。** 但是上面的结果仍然可以利用，将位数为$x$时求得的答案记为$ans_1$，位数为$y$时求得的答案记为$ans_2$。说明$x$位数中大于等于$L$的合法答案有$ans_1$各，小于等于$R$的合法答案有$ans_2$个。可以利用容斥原理，先求出所有$x$位的答案数量$t=\sum\limits_{i=1}^{9}f_{x,i}$，则既大于等于$L$又小于等于$R$的答案数量就是$ans_1+ans_2-t$。

至于如何求出位数、求出去除两端后剩下的数字，实现方法很多，不再提及。

```cpp

#include<bits/stdc++.h>
using namespace std;
typedef long long LL;
typedef double DB;
const int MAXL=20;
const int MAXN=10;
LL L,R,pw[MAXL]; int x,y,l1,l2,r1,r2;
LL f[MAXL][MAXN],ans,ans1,ans2;
int main(){
	scanf("%lld%lld",&L,&R),pw[0]=1;
	x=floor(log10((DB)L))+1,y=floor(log10((DB)R))+1;
	for (int i=1;i<=18;i++) pw[i]=pw[i-1]*10LL;
	l1=floor((DB)L/(DB)pw[x-1]),r1=floor((DB)R/(DB)pw[y-1]);
	l2=L%10LL,r2=R%10LL;
	for (int i=1;i<=18;i++)
		for (int j=1;j<=9;j++)
			f[i][j]=pw[max(i-2,0)];
	if (l1<=l2){
		for (int i=min(l1,l2)+1;i<=9;i++) ans1+=f[x][i];
		ans1+=(pw[max(0,x-2)]-(L/10)%pw[max(0,x-2)]-1);
		if (l1==l2) ans1++;
	}
	else{
		for (int i=max(l1,l2)+1;i<=9;i++) ans1+=f[x][i];
		ans1+=(pw[max(0,x-2)]-(L/10)%pw[max(0,x-2)]);
	}
	if (r1>=r2){
		for (int i=1;i<=max(r1,r2)-1;i++) ans2+=f[y][i];
		ans2+=((R/10)%pw[max(y-2,0)]);
		if (r1==r2) ans2++;
	}
	else{
		for (int i=1;i<=min(r1,r2)-1;i++) ans2+=f[y][i];
		ans2+=((R/10)%pw[max(y-2,0)]+1);
	}
	for (int i=x+1;i<=y-1;i++)
		for (int j=1;j<=9;j++) ans+=f[i][j];
	ans+=(ans1+ans2);
	if (x==y){
		LL tmp=0;
		for (int i=1;i<=9;i++) tmp+=f[x][i];
		ans=ans1+ans2-tmp;
	}
	printf("%lld",ans);
	return 0;
}

```

愿你历遍山河，依然觉得人间值得。