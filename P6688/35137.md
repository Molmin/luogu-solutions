## 序：
这题其实不难，就是在线段树上用 hash 维护一个值。结果我比赛时光想到数组、`bitset`、`string` 都不能用，就是没想到用哈希。。。（wtcl）   

___

## 引言：   
考虑如何表示一个数在集合中出现了几次。最简单的方法是使用数组维护一个桶，即：   
```cpp
int i,tot[M];
for(i=1;i<=n;i++)
	++tot[a[i]];//这个数每出现一次，它的出现次数加一
for(i=0;i<=m;i++)
	printf("%d\n",tot[i]);
```    
其中 $n$ 表示数集大小， $m$ 表示数的范围上界，$tot_i$ 表示数 $i$ 的出现次数。    

但是使用一个数组表示显然太麻烦，我们考虑使用字符串的形式表示，如：   
```cpp
string s;
s.resize(M);
for(i=0;i<=m;i++)
	s[i]=tot[i];
```   
显然这样表示一个数集时空复杂度仍然是 $\mathbf O(M)$ ，且一个 `char` 也存不下 `int` ，仍然不可行。   

然而，我们可以就此从字符串哈希中得到灵感。我们可以 **把之前那个假想的字符串哈希成一个值**！在字符串哈希的正确率下，如果哈希值相等，则两字符串相同；**同理，如果我们对 $tot_i$ 数组哈希，哈希值相等的具有相同的 $tot_i$ 数组，即具有相同的数集**！ 

____

## 可行性证明：   
以下证明均建立在整数哈希完全正确的假设下：    
考虑一个数组 $a_0,a_1,a_2,\dots,a_m$ 取值范围在 $[0,n]\cap N$ 之内。我们用一个 **大于$n$** 的值 $base$ 为基数进行哈希。那么我们可以把哈希值（不取模）表示为一个 $base$ 进制数 $\overline{a_m\dots a_2a_1a_0}$，相当于 $a_0 + a_1 * base + a_2 * base^2 + \dots + a_m * base^m$。   
因为对于 $\forall i$ ，   
1. $base$ 进制下 $\forall X=\overline{x_{i-1}\dots x_2x_1x_0}$ 即 $x_0 + x_1 * base + x_2 * base^2 + \dots + x_{i-1} * base^{i-1}$ ，有 $X<1 * base^i$    
2. $base$ 进制下 $\forall X=\overline{x_m\dots x_{i+2}x_{i+1}0\dots 0}$ 即 $x_{i+1} * base^{i+1} + x_{i+2} * base^{i+2} + \dots + x_m * base^m$ ，有 $X> (base-1) * base^i $  

所以两哈希值相等任意两位上的数相同。   

简单理解一下，考虑对于数 $a_i$ ，$a_i * base^i$ 一定不等于任意另外一个 $a_j * base^j$ 因为 $base^i$ 和 $base^j$ 至少差了 $base$ 倍，而 $a_i$ 取值最大只有 $n<=base-1$ 。    
实在不明白可以参考字符串哈希基数为什么要取131，因为131比任何一个字符的ASCII值都大。   
由于以上已经证明本算法同整数哈希正确性相同，故正确率应为整数哈希或字符串哈希正确率。   

______

## 具体实现：   
以上，我们拥有了一个 $\mathbf O(N+M)$ 计算， $\mathbf O(1)$ 比较两数集是否相同的算法。我们首先可以得到一个 $\mathbf O(N)$ 计算哈希值的做法：   
（预处理出所有 $base^i$ 后，）为了计算 $tot_0 + tot_1 * base + tot_2 * base^2 + \dots + tot_m * base^m$，显然，对于一个数 $i$ 对答案的贡献是 $1 * base^i$ （考虑 $tot_i$ 个 $i$ 对答案的贡献为 $tot_i * base^i$）。    
于是：   
```cpp
for(i=1;i<=n;i++)
	hashnum+=base_pow[a[i]];
```   
同时，我们恰好可以容易地得到一个 $\mathbf O(1)$ 比较两个数集是否刚好对应项差 $k$ 的算法：因为
$$tot_0 * base^{0+k} + tot_1 * base^{1+k} + tot_2 * base^{2+k} + \dots + tot_m * base^{m+k}$$   
$$=(tot_0 + tot_1 * base + tot_2 * base^2 + \dots + tot_m * base^m) * base^k$$   
所以对应项差 $k$ 的两数集刚好差 $base^k$ 倍。  

到现在为止，一切预先准备结束了，我们终于可以开始考虑线段树了。考虑如果用线段树维护区间哈希值（区间合并时直接相加，~~想一想为什么qwq~~）和最值，单点修改，区间查询，询问时直接算最值相差的大小 $\Delta$，比较区间对应项差值是否刚好等于 $\Delta$ 即可。

___

## 代码：
使用双哈希以保证正确性，线段树维护区间，最慢点用时少于1s。   
[代码（有多处细节错误）](https://www.luogu.com.cn/paste/frimehgz)   
[正解（代码公开计划）](https://www.luogu.com.cn/record/35849961)   
你可以在最优解第5页（可能你们看到这篇题解时已经被各位dalao挤到第6页了qwq）看到我的AC记录。   

ps：~~谁说这题卡常的，我双哈希都没跑满1s。qwq~~（加了IO的不配说这句话）   
ps2：~~这题总时间算法咋这么毒瘤，竟然每个subtask选最快点求和。~~   
ps3：~~数据真的水，我第一次交忘了 `pushup`，竟然只是每个 `task` WA了一个点。~~     
ps4：出题人说基数用1145141（这数字，绝了），因为可能是原根，但这属于整数哈希算法正确性问题，不予讨论。~~（其实是我不会qwq）~~    

____

## HACK：
上述证明可以证明我的算法是正确的，相反，有些哈希方法则是错误的，以下举例进行hack。  
1. 维护区间和   
	显然错误，例
    ```plain
    10 1
    1 2 3 4 5 1 3 3 3 5
    1 1 5 6 10
    ```
    正解为 `NO` ，输出为 `YES` 。
2. 维护较小值的次方和（哈希基数过小）   
	会出现 $base * base^i = 1 * base^{i+1} $的情况，以基数（底数）为 $3$ 的为例
    ```plain
    12 1
	1 3 3 3 6 7 1 4 5 5 5 7
	1 1 6 7 12
    ```
    正解为 `NO` ，输出为 `YES` 。   
    这里提供一份能生成一组数据卡掉全部基数（底数）为 $[1,1e5]$ 的数据生成器：[这里](https://www.luogu.com.cn/paste/zhbf9ifw)   
3. 其他
	1. 乱七八糟的错误哈希法   
    	随便卡卡就好   
        例如维护了%2余数，%3余数以及区间和的做法：   
        ```plain
        10 1
        1 2 97 100 1 7 92 100
        1 1 5 6 10
        ```   
        正解为 `NO` ，输出为 `YES` 。  
        
        听说出题人还构造了一组数据卡掉了求次方和的做法Orz qwq   
        其实还有一种sincos的做法，应该也可以卡掉，但我懒得算实数。。。    
    2. 单哈希   
    	参考字符串哈希中卡单哈希的做法   
    3. 双哈希   
    	~~毒瘤出题人难道还想卡双哈希？？？qwq~~   

____

## THE END.