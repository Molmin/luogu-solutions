这道题简单的地方有两个：一是数据范围小，二是在不用管大小的情况下方程十分好想。但仍然有一些小细节让我错了两回。
分析过程：
### 1.问啥设啥。
 ......时的最大接苹果数；这里我们发现题目设定上有两个比较明显的变量：总数和移动次数。于是先无脑把他们设出来！于是得
####  f[落下多少个][移动几次]；
### 2.想转移方程，进行补充。
那么这个方程的上一种状态是什么呢？首先捡不捡不一定，但上种状态落下的果子肯定少一，所以第一维是i-1;那么他到底有没有移动呢？我们自然会想到会有以下情况：
①他从另一棵树移过来并且接到了果子；

②他从另一棵树移过来但没接到果子；

③他站着不动接到了一颗果子；

④他站着不动也没接到果子；

但他到底有没有接到果子呢？？？我们并不知道他现在在哪里，所以也不知道他有没有接到果子，于是我们决定多加一维来表示他所在的位置。于是得
#### f[落下多少个][移动次数][现在所处位置]

并得到状态转移方程：
```cpp
if(a[i]==1)
{
    f[i][j][1]=max(f[i-1][j-1][2],f[i-1][j][1])+1;
    f[i][j][2]=max(f[i-1][j][2],f[i-1][j-1][1]);
}
if(a[i]==2)
{
    f[i][j][2]=max(f[i-1][j-1][1],f[i-1][j][2])+1;
    f[i][j][1]=max(f[i-1][j][1],f[i-1][j-1][2]);
}

```
于是一号代码长这样：
```cpp
#include<bits/stdc++.h>
using namespace std;
int t,w;
int a[1009];
int f[1009][35][3];//落到第几个，移动几次，当前在哪棵树下 
///时的最大接苹果数 
int main()
{
	cin>>t>>w;
	for(int i=1;i<=t;i++){
		cin>>a[i];
	}
	for(int i=1;i<=t;i++){
		for(int j=0;j<=w;j++){
			if(a[i]==1)
			{
				f[i][j][1]=max(f[i-1][j-1][2],f[i-1][j][1])+1;
				f[i][j][2]=max(f[i-1][j][2],f[i-1][j-1][1]);
			}
			if(a[i]==2)
			{
				f[i][j][2]=max(f[i-1][j-1][1],f[i-1][j][2])+1;
				f[i][j][1]=max(f[i-1][j][1],f[i-1][j-1][2]);
			}
		}
	} 
	cout<<max(f[t][w][1],f[t][w][2]);
	return 0;
}
```
然后愉快的wa了一个点

#### 经过慎重思考（又读了一遍题）
我发现人刚开始在第一棵树下，那就意味着移动奇数次时人一定在二号树下，偶数次时人一定在一号树下!二者不能同时被修改！所以方程改为：

```cpp
if(a[i]==1)
{
    if(j%2==0)   f[i][j][1]=max(f[i-1][j-1][2],f[i-1][j][1])+1;
    else   f[i][j][2]=max(f[i-1][j][2],f[i-1][j-1][1]);
}           
if(a[i]==2)
{
    if(j%2==1）  f[i][j][2]=max(f[i-1][j-1][1],f[i-1][j][2])+1;
    else   f[i][j][1]=max(f[i-1][j][1],f[i-1][j-1][2]);
}
```
然后wa了另外一个点。。。
#### 再次慎重思考（下载数据）后
我发现移动次数最多不一定接到的就最多。比如数据（不是题里的）：
```cpp
7 100
1
1
1
1
1
1
1

```
这样就绝对对不了。于是改为遍历所有移动步数寻找最大值便AC啦！


AC代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int t,w;
int a[1009];
int f[1009][35][3];//落到第几个，移动几次，当前在哪棵树下 
///时的最大接苹果数 
int main()
{
    cin>>t>>w;
    for(int i=1;i<=t;i++){
        cin>>a[i];
    }
    for(int i=1;i<=t;i++){
        for(int j=0;j<=w;j++){
            if(a[i]==1)
            {
                if(j%2==0)//偶数 
                {
                    f[i][j][1]=max(f[i-1][j-1][2],f[i-1][j][1])+1;
                }
                else 
                f[i][j][2]=max(f[i-1][j][2],f[i-1][j-1][1]);
            }
            if(a[i]==2)
            {
                if(j%2==1)
                {
                    f[i][j][2]=max(f[i-1][j-1][1],f[i-1][j][2])+1;
                } 
                else 
                f[i][j][1]=max(f[i-1][j][1],f[i-1][j-1][2]);
            }
        }
    } 
    int ans=-1;
    for(int j=0;j<=w;j++)
    {
        ans=max(ans,max(f[t][j][1],f[t][j][2]));
    }
    cout<<ans;
    return 0;
}
```
