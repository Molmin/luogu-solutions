## **~~又刷完了一道DP水题！~~**
### 言归正传，其实这道题的站状态转移方程不难想到，我们设:
##  _f[i][j]_ 为第i分钟奶牛移动了j次接到苹果的最大值；
## **则f[i][j]=max(f[i-1][j],f[i-1][j-1]),同时要加上此时在当前接到的苹果数，即加一。**
### ~~是不是很easy？~~
## 上代码！
```cpp
#include<bits/stdc++.h>
using namespace std;
int t,w;
int a[1001];
int f[1001][31];//变量名,数组名本人自以为立意明确，相信大家都看得懂
int main()
{
	cin>>t>>w;//输入奶牛共有t分钟和最多移动w次
	for(int i=1;i<=t;i++)
		cin>>a[i];//输入，若a[i]为1，则第i分钟的苹果是从1号苹果树上掉下来的，a[i]为2则是从2号苹果树上掉下来的。
//下面进入核心代码：    
	for(int i=1;i<=t;i++)//i列举1到t分钟
	{
		f[i][0]=f[i-1][0];//f[i][0]先初始化为前一分钟移动0次的次数，大家一定都理解
		if(a[i]==1)
			f[i][0]++;//但是当前是有可能接住第i个苹果的，由于f[i][0]是没有移动过的，而奶牛的初始位置在1号苹果树，所以我们只要判断第i分钟的苹果是不是从1号苹果树上掉下来的，如果是，那么f[i][0]加一
		for(int j=1;j<=w;j++)//j从1到w列举奶牛移动了几次，由于前面没有移动的状态列过了，所以j从1开始
		{
			int f1,f2;
			if(j%2+1==a[i])
				f1=1,f2=0;//判断移动j次时苹果在不在当前位置
			else
				f1=0,f2=1;//否则移动j-1此时能接到当前苹果
			f[i][j]=max(f[i-1][j]+f1,f[i-1][j-1]+f2);//状态转移，要注意的是苹果不是在f[i-1][j]，就是在f[i-1][j-1]，所以f[i-1][j]要加上f1，f[i-1][j-1]要加上f2,有些难理解
		}
	}
	int ans=0;//定义答案变量ans
	for(int i=0;i<=w;i++)//i列举第t分钟移动0到w次
		ans=max(ans,f[t][i]);//ans找出最大值
	cout<<ans;//输出答案ans
	return 0;//程序完美谢幕啦
}
```
# 第一次写题解
# 各位大侠不喜勿喷!
# 各位大侠不喜勿喷!
# 各位大侠不喜勿喷!