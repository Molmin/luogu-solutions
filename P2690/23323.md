
/\*
题解：

先进一点的DP

虽然时间都是0Ms，但是如果数据扩大以下算法将有时间+空间优势

首先可以贪心发现，如果下一个苹果和当前的苹果在一棵树上

那么一定没有必要换到别的树下

所以我们可以将所有苹果归为几“波”

其中每一次1号树上和2号树上掉若干的苹果为1波

（总是1号树先，如果第一个是2则为0）

设数组A[1000]，第i位表示i/2+1波第(i+1)%2+1树上掉下的苹果

接下来设数组F[30][500]表示第i次更换位置，此时已经接住了第j波苹果

（虽然最多可能有1000组苹果，但是只有500波）

接下来开始循环：

F[I][J]由以下三种情况转来：

（1）不换，在这颗树下接下一波

（2）换，从1换2则接两波，从2换1则延续上一波（上一次已经抉择了接哪边）

输出F[W][K/2]，其中一共K/2波

代码：

\*/
```cpp
#include<cstdlib>
#include<cstdio>
#include<cstring>
#include<iostream>
#define r register 
using namespace std;
int a[1001],f[31][501];
//f[i][j] : 第i次更改的时候，接住第j波苹果 
//a[i] : i%2树的第i/2+1波苹果（贪心可得，没事不要瞎换） 
int w,t,k=0;
int main()
{
    memset(a,0,sizeof(a));
    scanf("%d%d",&t,&w);
    for(r int i=1;i<=t;i++)
    {
        r int c;
        scanf("%d",&c);
        if(c!=k%2+1) k++;//换树 
        a[k+1]++;//当前树+1 
    }
    k%2?k++:k+=2;//补满
    if((a[k]==0 and w>=k-2) or (a[k]!=0 and w>=k-1))
        return !printf("%d\n",t);//如果可以换很多次，一定可以接到所有
    f[0][0]=0;//初始化 
    for(r int i=0;i<=w;i++)
        f[i][1] = i%2==0 ? a[1] : a[1]+a[2] ;//第一波苹果 
    for(r int i=1;i<=k/2;i++)
        f[0][i] = f[0][i-1] + a[i*2-1] ;//第零次更改（不更改） 
    for(r int j=2;j<=k/2;j++)//枚举第j波苹果
        for(r int i=1;i<=w;i++)//枚举当前更换了i次
            f[i][j]=/*每一步的状态由上一步推出*/
            max(
            f[i][j-1]+a[j*2-(i+1)%2],/*不换*/
```
i%2?f[i-1][j-1]+a[j\*2]+a[j\*2-1]:f[i-1][j]/\*换\*/
            );

    return !printf("%d\n",f[w][k/2]);//输出最后一波并换最多次 

}