f[i][j][1]表示最多走i步，时刻j处于第1棵树下的最多苹果数

f[i][j][2]表示最多走i步，时刻j处于第2棵树下的最多苹果数

最后答案=max(f[w][t][1],f[w][t][2])

dp公式：

对当前时刻j的苹果进行判断：

如果从第1棵树掉下来，

f[i][j][1]=max(f[i][j-1][1]+1,f[i-1][j-1][2]+1); //dp公式分两种情况讨论，最后一次移动在时刻j，最后一次移动不在时刻j

f[i][j][2]=max(f[i][j-1][2],f[i-1][j-1][1]);

如果从第2棵树掉下来：

f[i][j][1]=max(f[i][j-1][1],f[i-1][j-1][2]);

f[i][j][2]=max(f[i][j-1][2]+1,f[i-1][j-1][1]+1);

dp初始，由于刚刚开始在第一棵树下，所以：

f[0][j][1]的 值等于输入序列中到j时刻为止出现的1的个数


AC代码：


        
```cpp
#include<bits/stdc++.h>
using namespace std;
int t,w;
int a[1001];
int f[31][1001][3];
int main()
{
    scanf("%d%d",&t,&w);
    for(int i=1;i<=t;i++)
    {
        scanf("%d",&a[i]);
        if(a[i]==1)
        {
            f[0][i][1]++;
        }
        f[0][i][1]+=f[0][i-1][1];
    }
    //f[0][0][1]=1;    
    for(int i=1;i<=w;i++)
        for(int j=i;j<=t;j++)
        {
            if(a[j]==1)
            {
                f[i][j][1]=max(f[i][j-1][1]+1,f[i-1][j-1][2]+1);
                f[i][j][2]=max(f[i][j-1][2],f[i-1][j-1][1]);
            }
            else
            {
                f[i][j][1]=max(f[i][j-1][1],f[i-1][j-1][2]);
                f[i][j][2]=max(f[i][j-1][2]+1,f[i-1][j-1][1]+1);
            }
        }
    printf("%d",max(f[w][t][1],f[w][t][2]));
}
```