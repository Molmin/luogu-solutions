刚刚读题的我天真的以为这是一道评分偏低的普通难题 ~~（我天真的打了段dp最长公共子序列想求加几个字符）~~

没想到~~这么水~~这么适合在座的各位新人（大佬就当没看见好了）


--------------------这里是神圣而不可侵犯的分界线 --------------------

那我们言归正传（强行正经），我先解释一下很~~看不懂~~言简意赅的题意：说白了很简单，就是给你一个只有iwi和()的字符串，然后叫你求一下改几个字符就变成了回文串（这里注意以中间为轴的两个字符不能均为同一侧的括号，如‘（’和‘（’在这两个位置不是回文串，必须成对出现！）

读懂了题，这题就很~~水~~容易浮现出思路了：
	
    1.将以中间为轴对称的两个字符作比较，看看该位置的两个字符是不是一样，一样则不动，不一样则改变，sum++
    2.输出？这么简单woc我还发啥题解（狗头）
    
下面是~~高清无码~~ ac代码

```cpp
#include<bits/stdc++.h>
using namespace std;
string iwi;	//定义字符串，不限长度
bool flag;
int len,sum;
int main(){
	cin>>iwi;//读入字符串，string类型可以直接cin
	len=iwi.size();//得到字符串长度
	for(int i=0;i<=(len-1)/2;i++){ //这个终止条件很重要，我第一次也不小心写成li<=len/2,我错的这个单单适用于奇数情况，偶数会多一个
		flag=false; //预设状态是要改
		if(iwi[i]==iwi[len-i-1]&&iwi[i]=='i')	flag=true;	//看看是不是对称，这两个是看是不是i或w的回文，是则改为不需改的状态；顺便说下有一条题解错就错在他没有判断相等是不是不是括号，这样ta用或的话就会bug
		else if(iwi[i]==iwi[len-i-1]&&iwi[i]=='w')	flag=true;
		else if(iwi[i]=='('&&iwi[len-i-1]==')')	flag=true;//这两个是判断是否是成对的括号，后一个也是，只不过是反过来而已
		else if(iwi[i]==')'&&iwi[len-i-1]=='(')	flag=true;
		if(!flag)	sum++;//如果不回文，动一下其中一个，不考虑全改，因为字符均不可能不在i，w和括号之间
	}
	cout<<sum<<"\n";//漂亮的输出有换行才完美
	return 0;
}

```
怎样，简单吗，点个赞，爱你哦（狗头保命）