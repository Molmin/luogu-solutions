### 题面

[P5290 春节十二响](https://www.luogu.com.cn/problem/P5290)

### 分析

题目的核心考点就是存在子孙关系的节点不能放在同一个内存条里，而每段内存的大小取决于这段中放进的最大的节点权值。那么我们贪心地想，**如果想让总的节点最少，就要在当前段用一个最大的尽可能多地把大东西遮盖掉，然后让下一段的最大值尽可能小**。

我们想这样一个问题，对于树上的一个节点x,考虑以x的子节点y为根的子树中有$p$个元素必须放进不同的内存段中，而节点x之前已经处理了部分子节点，有$q$个元素必须放进不同的内存段中。那么，由于以x的不同子节点为根构成的不同子树中元素不会发生冲突，根据上一段提到的贪心思想，就要把每次从$p$个和$q$个元素中分别取出最大值$pmax$和$qmax$，将$pmax$和$qmax$取最大值，作为某内存段的大小，更新x的那些元素。我们在树上dfs的过程中不断这样递归地做，最终1号节点还剩下的所有元素的和就是答案。

因为总是在取最大值，所以对每个树上节点维护一个堆，而每次x和y各取一个元素，那么我们必然是把size小的堆往size大的堆合并，这就叫启发式合并。万一上文提到的$p > q$，我们可以用C++11中的swap交换两个堆，继续进行合并。

代码写得不好就不粘了。