**题意**
- [链接](https://www.luogu.com.cn/problem/CF1523G)。
- 按顺序给出一些区间，对于每个 $x$，输出选出长度不小于 $x$ 的区间，顺次加入，最多可以让几个区间不重叠？


**分析**
- 首先与[这题](https://www.luogu.com.cn/blog/luo1gu1zui1bang1/hao-ti)类似，如果我们暴力枚举 $x$，被加入的区间总数目是 $O(n\log n)$ 的，所以我们尝试考虑对于每个 $x$ 如何处理。
- 对于每个 $x$，把能放入的最前的段优先放入，容易发现它分成了两个巨大的空段，分别统计即可，容易发现分治时查询最前的段的次数是 $O(n/x)$。
- 接下来咱们分析查询的复杂度，查询要求我们查在区间 $[l,r]$ 内，长度超过 $x$ 的，时间最前的段。
- 我们将 $x$ 从大到小枚举可以消掉其中的一个限制（当然，同时限制我们在线），如果我们把区间表示成 $(x,y)$ 的形式，那么我们要找的就是 $x\ge l$ 且 $y\le r$ 内的最小值，树套树满足这个要求。
- 所以我们就得到了时间复杂度 $O(n\log^3n+m\log^2n)$空间复杂度 $O(n\log^2 n)$ 的优秀（？）算法。
- 虽然这个信息不可差分，但是它是前缀查询的形式，所以我们可以快乐地用我们的树状数组减小常数和代码复杂度。
- [代码实现](https://www.luogu.com.cn/paste/gm0taf9i)。