### 题目描述

> 给定一个序列 $\{a_i\}$，请你将他划分成尽可能多的非空子段，每个子段的权值为这个这个字段中所有数的异或和，要求从中选出任意多个子段，其异或和不为 $0$。

### 算法思路

看到区间异或，设 $\{p_i\}$ 表示 $\{a_i\}$ 的前缀异或和，可以有如下转化：

$$
\oplus_{i=l}^r a_l=p_r\oplus p_{l-1}
$$

将原序列划分成一个子段，这个子段的异或和可以看做 $p_r\oplus p_{l-1}$。

而后，我们要求任意子段的异或和均不为 $0$，可以想到线性基。

首先考虑无解的情况。当所有元素的异或和为 $0$，即 $p_n=0$ 时，无论怎么划分，将所有的子段全选时一定异或和为 $0$，故无解。

对于有解的情况，可以尝试将 $\{p_i\}$ 中的每个数插入线性基，如果可以插入答案加一，否则证明如果选择在这里分段，与前面的某一段异或和为 $0$，与原题不符，故不能插入。

又由于线性基是唯一的，所以顺序不会影响答案。

故最终的答案即为线性基的大小。

### 代码实现

快读快写过长略去了，代码并不难写。

```
#define N 200005
int n,maxn=31,t[N],ans,lst;
inline void insert(int x){
	for(int i=maxn;~i;i--){
		if(!(x>>i&1)) continue;
		if(!t[i]) t[i]=x,ans++,i=0;
		else x^=t[i];
	}
}
int main(){
	read(n);
	for(int i=1,x;i<=n;i++) read(x),lst^=x,insert(lst);
	put('\n',!lst?-1:ans);
	return 0;
}

```
