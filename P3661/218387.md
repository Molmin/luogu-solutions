#### 第一眼我一看以为这是个橙题

恩没错，把牛和鸡都按左端点排序然后贪心一下就行

结果呢，我获得了~~50分的~~好成绩

思路：先按牛左端点排序并把鸡排序，然后将牛和鸡都从一开始记录，如果这只牛的左端点比鸡的时间要晚，那么继续遍历下一只鸡，否则遍历下一只牛。如果鸡和牛符合，都加一，都遍历下一个

但是$50tps$，为什么呢？

肯定是有某种情况，如果一只牛把另一只牛时间覆盖住了，如图

![](https://cdn.luogu.com.cn/upload/image_hosting/hmrn33m3.png)

因此我没了？那怎么办呢？

这题瞬间又变绿了（雾

那是遍历方式的问题啊，我看看暴力能不能过，诶，居然又是50分（AC后试的），这，排序方式还有问题诶，应该按右端点排序。

为什么呢？结束时间越早的牛也就越急着过马路（~~牛也不一定要过马路啊~~），那么将符合的鸡分配给更紧急的牛显然是更优的，因为剩下的那只牛还有更多的时间，也就可能有更多选择（~~你的可能无限~~）

然后呢就AC了，还没开氧气，有时候也不要多看题解，数据可能很水啊。

上代码

```cpp
#include<bits/stdc++.h>
using namespace std;
struct cow
{
	int left,right;//牛，左端点，右端点
};
bool cmp(cow a,cow b)
{
	return a.right<b.right;//按右端点排序
}
int main()
{
	int n,c;//rt
	cin>>c>>n;
	cow a[20001];//牛结构体数组
	int b[20001];//鸡数组
	for(int i=1;i<=c;i++)cin>>b[i];
	for(int i=1;i<=n;i++)cin>>a[i].left>>a[i].right;
	sort(a+1,a+n+1,cmp);//排序
	sort(b+1,b+c+1);
	int ans=0;
	for(int i=1;i<=n;i++)//遍历牛
	{
		for(int k=j;k<=c;k++)//遍历鸡
		{
			if(a[i].left<=b[k]&&a[i].right>=b[k])//如果满足题目条件就ans++
			{
				ans++;
				j=k+1;
				break;
			}
		}
	}
	cout<<ans;//输出
}
```
这个还是因为数据太水才能过，有没有更好一点的？

我太菜了，目前还没发现...

#### 题解千万条，理解第一条。直接抄题解，棕名两行泪


