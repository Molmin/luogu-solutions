# 前言
- [这是我的提交记录](https://www.luogu.com.cn/record/54661354) 。当时是最快的，复杂度严格$O(n)$。

# 思路
- 分为两个点。
- 第一，题目是让我们找一个区间 $[l,r]$ 的众数并加上区间外的 $c$ 的数量。进行一步转化，变成区间内众数减去 $c$ 的数量，再加上所有 $c$ 的数量。


- 这时候我们钦定区间最右端的数 $a[r]$ 为该区间的众数。因为若众数不是 $a[r]$ 而是 $a[j]$ 那么区间 $[l,j]$ 的答案一定不比 $[l,r]$ 劣。

- 第二，我们可以从左往右扫一遍 $r$。那么 $l$ 怎么办呢？注意到此时相当于是要求一个最大子段和，那么我们直接暴力维护一个当前的 $a[r]$（这里开个桶就行了）减去当前段的 $c$ 的数量，如果是负的那么就置成1（新开一段），否则直接加上。注意到这里的难点是怎样维护当前段 $c$ 的数量。我的做法是：维护一个变量表示当前总共几个 $c$，再维护一下上次遇到 $a[r]$ 这个数是 $c$ 的数量，两者相减即可。

- 到这里，这题就做完了。感觉难度其实并不高，主要是需想到第一步的转化，和第二步维护当前段 $c$ 的数量。

- 代码我放在 [云剪贴板](https://www.luogu.com.cn/paste/o840dulz) 里面了，本题实现并不难，代码也很短，希望大家尽量自己写，实在调不对可以参考我的代码。

-----
### 谢谢观看！