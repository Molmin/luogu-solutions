# AT3733 [ARC088C] Papple Sort

> 给定一个只有小写字母的字符串 $S$，请问最少经过多少次相邻两字母的交换，使得字符串变成回文？
>
> 如果不可以输出  $-1$
>
> $n\le 2e5$

逆序对。

~~其实挺水的而且这个思路应该是最好想的为啥没人写啊~~

---

看到了两两交换，容易想到冒泡排序。

也就是逆序对问题。

于是我们可以把字符串重新标号，变成一个数字序列，之后直接统计逆序对即可。

一条比较显然的小性质是我们需要尽量的满足配对的情况发生在最外侧。

交叉配对显然不优。

于是对于多次出现的字母，我们要找到两个最外侧的进行配对。

配对的具体做法是给两个位置分别赋一个顺序值。

并且两个顺序值满足一个从前面往后，一个从后面往前。

举个例子：

`ataatmma`

根据规则，应当赋值：

`1 2 3 6 7 4 5 8`

问题转化为在不高于 $\mathcal{O(n \log n)}$ 时间内完成对字符串的重标号。

事实上 $\mathcal{O(n)}$ 即可完成。

只需要记录一下每个位置的字母是什么，每种字母都在哪些位置出现。

每次扫到一个字母，将出现位置中最早的和最晚的配对。

这里使用了 `std::deque` 实现。

复杂度 $\mathcal{O(n \log n)}$ ，主要在于树状数组求逆序对。

代码太丑了扔剪切板好了

[代码](https://gitee.com/lawrencesivan/code-clipboard/blob/master/AT3733%20%5BARC088C%5D%20Papple%20Sort%EF%BC%88%E9%80%86%E5%BA%8F%E5%AF%B9%EF%BC%8C%E5%9B%9E%E6%96%87%EF%BC%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%89)