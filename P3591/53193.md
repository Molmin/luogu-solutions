SOL：

我们观察了一波局势，发现这道题有些眼熟。相比大家应该都做过这样一道题：给你一个静态的序列（所谓静态是指这个区间不会做任何的修改），M次给出X,L,K，让你求从X起的L个数的和，这L个数中间两两下表相间K（举个栗子：X=5，L=4，K=3，那么sum=a5+a8+a11+a14）。（N<=10W，M<=10W）


这道题我们的思想就是分块，我们发现当K很大时，我们暴力求和的速度是相当快的。因为我们发现 L<=N/K，我们的暴力复杂度是O(L)的。而K很小时，暴力就很慢了，接近于O(N)。我们又注意到K=1时便是前缀和，可以做到O（1）查询。那么我们不禁想当K很小时我们用前缀和优化（K>1有间距的前缀和相比大家都会）。


我们假设我们采取这样的策略，当K<S时我们用前缀和，K>S时我们采取暴力，那么我们就可以在最坏情况下O（n\*s+m\*n/s）下解决问题,那么我们解得S=sqrt N时最优。（实际上S取的稍微小一些会更快，因为我们刚刚计算的是最坏情况）


那么我们就可以做这一道题了，同样的思想，当K<sqrt N 时我们预处理，K > sqrt N 时我们便暴力向上跳。


case 1: K<sqrt N 我们预处理每个点 以K为间距向上跳的 答案，x的答案加上y的答案减去lca的答案就是了。


case 1: K>sqrt N 我们暴力做，我们每次用树上倍增的方法 log N 的方法向上跳，暴力统计答案，跳跳就好了。

代码见这里：http://www.cnblogs.com/rrsb/p/8127786.html
