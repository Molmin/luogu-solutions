#### 题意

给定$n$个区间，每一次把每个区间加$1$，求最后所有区间中最大的数。

#### 思路

在这里，我们要引入一个概念——$\color{black}差分$

那么，什么是差分？

我们先假设一个原序列，名为$A$。

若对于每一个$i$，都有$B[i]=A[i]-A[i-1](B[0]=A[0])$，我们就说序列$B$是序列$A$的差分序列。

我们可以发现什么？

$B[i]=A[i]-A[i]$

可以转化为

$A[i]=A[i-1]+B[i]$

也就是说，原序列$A$其实就是差分序列$B$的前缀和！

现在我们回到这题。

首先，我们设定一个差分序列$a$。

当我们输入左边界$x$以及右边界$y$时，就将$a[x]+1$,这样后面计算原序列时，前缀和会把这个$1$一直带入后面。

但达到$y+1$时，我们就不能再加了，为了和前面的抵消，我们就要将$a[y+1]-1$。

最后我们再跑一边循环，用前缀和计算出原序列就可以得到答案了。

上代码：


```
#include<bits/stdc++.h>
using namespace std;
int a[1000001],b[1000001],n,x,y,maxn=-1,flag;
int main() {
	scanf("%d",&n);
	for(int i=1;i<=n;i++) {
		scanf("%d%d",&x,&y);
		a[x]++;
		a[y+1]--;
		maxn=max(y,maxn);
	}
	b[0]=a[0];
	flag=b[0];
	for(int i=1;i<=maxn;i++) {
		b[i]=b[i-1]+a[i];
		flag=max(flag,b[i]);
	}
	printf("%d\n",flag);
	return 0;
}
```

完结撒花~