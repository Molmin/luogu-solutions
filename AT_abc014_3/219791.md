### Other Ver.

**中文**・[日本語](https://www.luogu.com.cn/paste/joa0on9y)・[English](https://www.luogu.com.cn/paste/kduh3ow4)

### Solution

差分。

那么，差分是什么？

首先你有一个可爱的 $a$ 数组，你还有一个可爱的 $b$ 数组。

那么如果说 $a_i = b_1 + b_2 + \cdots + b_i$，那么这个 $a$ 数组就是 $b$ 数组的 **前缀和数组**，反过来，我们称 $b$ 数组是 $a$ 的 **差分数组**。

那么 $b$ 数组大概是这个样子（$a_0 = 0$）：

- $b_1 = a_1 - a_0$；
- $b_2 = a_2 - a_1$；
- $b_3 = a_3 - a_2$；
- $b_4 = a_4 - a_3$；
- $\cdots$
- $b_n = a_n - a_{n - 1}$。

那么当我们有 $b$ 数组的时候，我们就可以用很快的时间（$O(n)$）得到 $a$ 数组。

那么显然，这题我们可以用差分解决。

因为 $a$ 是 $b$ 的前缀和数组，而如果我们改变 $b_i$ 的话，那么 $a_i$，$a_{i + 1}$，$\cdots$，$a_n$ 都会被改变。

假如我们要给 $[l, r]$ 这个区间加上 $k$，那么就可以用这些可爱的步骤来：

1. 让 $b$ 数组 $b_l$ 加上 $k$；
2. 让 $b$ 数组 $b_{r + 1}$ 减去 $k$；

通过第一次操作，$b$ 数组中第 $l$ 个元素之后都加上了 $k$；通过第二次操作，$b$ 数组中第 $r + 1$ 个元素之后都减去了 $k$，然后你就发现 $[l, r]$ 这个区间的数都加了 $k$，而对于第 $k$ 个元素之后的数都没有改变。

于是单次修改的时间复杂度是 $O(1)$。

这是一个差分的模板：

```cpp
for(int i = 1; i <= n; i++) {
  scanf("%d", &d[i]); // 原数组
}

for(int i = 1; i <= m; i++) {
  int l, r, k; // 将 d[l] ~ d[r] 元素值加上 k
  cin >> l >> r >> k; 
// 差分数组 b
  b[l] += k;
  b[r + 1] -= k;
}

// 前缀和数组 a
for (int i = 1; i <= n; i++) {
  a[i] = a[i - 1] + b[i];
}
// 累加结果
for (int i = 1; i <= n; i++) {
  s[i] = d[i] + a[i];
}
```

然后这个可可爱爱的 $s$ 数组就是答案。

好耶！你发现这题就是模板嘛，而且比模板还简单，$k = 1$，原数组的所有元素都是 $0$，然后就做完了 qwq。