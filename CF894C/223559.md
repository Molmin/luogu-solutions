### 解题思路：

由于这样的一个区间长度可以等于一，那么每一个在构造序列中出现的数都一定在最大公约数序列中出现过，否则一定会有其他的数出现在最大公约数中。

发现，这些最大公约数中最小的一个数一定是整个序列的最大公因数，也就是这个序列的每一个数都要被这个数整除。否则直接取所有的数取一个最大公约数就不符合题意了。

然后构造这样的一个序列，考虑直接在每一个数中间插一个最小的最大公约数。这样，由于每一个数都在序列中出现过，所以不会有遗漏的情况发生，而又因为每一个数中间都有一个最小数存在，也不可能出现别的数。所以这样的一种构造方法是一定可行的。

--------
### 代码：

```cpp
#include<cstdio>
using namespace std;
int n,a[1005];
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	scanf("%d",&a[i]);
	for(int i=2;i<=n;i++){
		if(a[i]%a[1]!=0){
			printf("-1");
			return 0;
		}
	}
	printf("%d\n" ,n*2);
	for(int i=1;i<=n;i++){
		printf("%d %d ",a[i],a[1]);
	}
	printf("\n");
	return 0;
}
```
