最小生成树无非就是两种写法：

1、**Prim算法**

2、**Kruskal算法**

然后放几个概念性的定义：


------------


**连通图：**在无向图中，若任意两个顶点vi与vj都有路径相通，则称该无向图为连通图。

**强连通图：**在有向图中，若任意两个顶点vi与vj都有路径相通，则称该有向图为强连通图。

**连通网：**在连通图中，若图的边具有一定的意义，每一条边都对应着一个数，称为权；权代表着连接连个顶点的代价，称这种连通图叫做连通网。

**生成树：**一个连通图的生成树是指一个连通子图，它含有图中全部n个顶点，但只有足以构成一棵树的n-1条边。一颗有n个顶点的生成树有且仅有n-1条边，如果生成树中再添加一条边，则必定成环。

**最小生成树：**在连通网的所有生成树中，所有边的代价和最小的生成树，称为最小生成树。 


------------

###### （由于篇幅限制，所以我就只讲Kruskal算法了）


------------

Kruskal算法可以称为“加边法”，初始最小生成树边数为0，每迭代一次就选择一条满足条件的最小代价边，加入到最小生成树的边集合里。 
1. 把图中的所有边按代价从小到大排序； 
2. 把图中的n个顶点看成独立的n棵树组成的森林； 
3. 按权值从小到大选择边，所选的边连接的两个顶点ui,vi,应属于两颗不同的树，则成为最小生成树的一条边，并将这两颗树合并作为一颗树。 
4. 重复(3),直到所有顶点都在一颗树内或者有n-1条边为止。



------------


然后接下来是代码：



------------


```cpp
#include <cstdio>
#include <algorithm>
using namespace std;
int f[2000002],n,x,pp,qq,xian,bian,ans,m;
struct node {		//结构体不多说
	int u,v,w;
} p[2000002];
bool cmp(node a,node b) {return a.w<b.w;}   //比较函数（sort）
int find(int x) {
	if(f[x]==0)return x;			//并查集模板
	else return f[x]=find(f[x]);
}
int main() {
	scanf("%d %d",&m,&n);
	for(int i=1; i<=n; i++) scanf("%d %d %d",&pp,&qq,&x),p[xian].u=pp,p[xian].v=qq,p[xian++].w=x;
	sort(p,p+xian,cmp);			//直接进行排序
	for(int i=0; i<xian; i++) {
		int u=p[i].u,v=p[i].v,w=p[i].w,t1=find(p[i].u),t2=find(p[i].v);
		if(t1!=t2)ans+=w,f[t1]=t2,bian++;
        //判断是否需要进行合并
		if(bian==n-1)break;
	}
	printf("%d",ans);
}
```
------------
