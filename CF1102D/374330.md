## 题意：

给一个由 '0'，'1'，'2' 组成的字符串（长度是3的倍数），可以修改任意位置上的字符，要求修改最少使得 '0'，'1'，'2' 个数相等，在此条件下输出字典序最小的串。

## 思路：

贪心。

最终结果的 '0', '1', '2' 数量一定都是 $n/3$。

其次因为要求改动次数最小，所以最初个数就小于等于 $n/3$ 的都要保留。

然后分别考虑这 3 个数的个数大于 $n/3$ 的情况：

1.当 '2' 的个数大于 $n/3$ 时：

$\ \ \ $从前往后换，**优先换 '0' ，其次换 '1'**。

2.当 '0' 的个数大于 $n/3$ 时：

$\ \ \ $从后往前换，**优先换 '2' ，其次换 '1'**。

3.当 '1' 的个数大于 $n/3$ 时：

$\ \ \ $维护两个指针 $l, r$， 分别从前往后 / 从后往前扫一遍，左指针 $l$ 扫到的 '1' **优$\ \ \ $先换 '0'**，右指针 $r$ 扫到的 '1' **优先换 '2'**。

根据此思路，即可使字典序最小。

## AC代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
string s;
int n, avg, cnt[105];
int main() {
    cin >> n >> s;
    avg = n / 3;
    for(int i = 0; i < n; i++)
        cnt[s[i] - '0']++;
    for(int i = 0; cnt[2] > avg && i < n; i++)
        if(s[i] == '2') {
            if(cnt[0] < avg)
                s[i] = '0', cnt[0]++, cnt[2]--;
            else if(cnt[1] < avg)
                s[i] = '1', cnt[1]++, cnt[2]--;
        }
    for(int i = n - 1; cnt[0] > avg && i >= 0; i--)
        if(s[i] == '0') {
            if(cnt[2] < avg)
                s[i] = '2', cnt[2]++, cnt[0]--;
            else if(cnt[1] < avg)
                s[i] = '1', cnt[1]++, cnt[0]--;
        }
    for(int l = 0, r = n - 1; cnt[1] > avg && r >= 0; l++, r--) {
        if(s[l] == '1' && cnt[0] < avg)
            s[l] = '0', cnt[0]++, cnt[1]--;
        if(s[r] == '1' && cnt[2] < avg)
            s[r] = '2', cnt[2]++, cnt[1]--;
    }
    cout << s;
    return 0;
}
```
