这是一道贪心题qwq

首先发现最终结果的`'0', '1', '2'`数量一定都是$n/3$。

其次因为要求改动次数最小，所以最初个数就小于等于$n/3$的都要保留。

然后分别考虑这3个数的个数大于$n/3$的情况：

1. 当`'2'`的个数大于$n/3$时，我们发现后面的`'2'`需要保留，于是从前往后换，优先换`'0'`，其次换`'1'`。
2. 当`'0'`的个数大于$n/3$时，我们发现前面的`'0'`需要保留，于是从后往前换，优先换`'2'`，其次换`'1'`。
3. 当`'1'`的个数大于$n/3$时，我们维护两个指针$l, r$， 分别从前往后/从后往前扫一遍，左指针$l$扫到的`'1'`优先换`'0'`，右指针$r$扫到的`'1'`优先换`'2'`。

这样就可以保证字典序最小。

下面放代码：
```
#include <cstdio>

int n, qui;
char s[300005];
int cnt[105];
// 注意每次修改元素后要及时修改 cnt 数组

int main() {
	scanf("%d", &n);
	qui = n/3;
	scanf("%s", s+1);
	for(int i = 1; i <= n; ++i)
		++cnt[(int)s[i]];
	for(int i = 1; cnt['2'] > qui && i <= n; ++i) {
		if(s[i] == '2') {
			if(cnt['0'] < qui) s[i] = '0', ++cnt['0'], --cnt['2'];
			else if(cnt['1'] < qui) s[i] = '1', ++cnt['1'], --cnt['2'];
		}
	}
	for(int i = n; cnt['0'] > qui && i; --i) {
		if(s[i] == '0') {
			if(cnt['2'] < qui) s[i] = '2', ++cnt['2'], --cnt['0'];
			else if(cnt['1'] < qui) s[i] = '1', ++cnt['1'], --cnt['0'];
		}
	}
	for(int l = 1, r = n; cnt['1'] > qui && r; ++l, --r) {
		if(s[l] == '1' && cnt['0'] < qui) s[l] = '0', ++cnt['0'], --cnt['1'];
		if(s[r] == '1' && cnt['2'] < qui) s[r] = '2', ++cnt['2'], --cnt['1'];
	}
	puts(s+1);
	return 0;
}
```