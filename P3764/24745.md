声明，这是一个未完成的题解，只是提供一种思路，希望好心人能接着我的思路补充下去。

因为原函数可能会死循环，所以我们不妨从结束状态考虑，看能不能推出所有开始状态。

定义rf(a,b)作为f(a,b)的逆函数，表示由(a,b)所能拓展出的所有起始状态。

很显然原来的函数是f(a,b) = f(max(a,b) - min(a,b), min(a,b) +min(a,b))，那rf就有两种操作，把a除以2加到b上，把b除以2加到a上，而且这些操作推出来的状态一定是能回到(a,b)的，因为如果较大的数被除2的话就变成较小的数了。

显然rf(a,b)的结束状态是a%2==1&&b%2==1.而且一定不会出现a%2==1，b%2==0的情况。

这样的话我们知道所有的结束状态一定是f(2^k\*p,2^k\*p),k=0,1,2,3,4,....,p是奇数。

想到这儿其实就有了一个奇葩的70做法了.。。。。我自己懒没写。。。。

我们暴力算出rf(2^k，2^k）然后枚举所有的奇数在表里统计f函数的值。

官方题解f(a,b)=p-1,gcd(a,b)==1&&a+b=2^p,这好像就是rf推推推推到最底层时的情况。

然后。。。

就直接猜了

```cpp
for (i=1;i<=n;i+=2) ans+=n/i*log2(i).........
```
希望好心人继续证qwq

