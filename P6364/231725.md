### 我咋觉得这篇题解过不了呢？
但还是要试试的对吧？

之前因为数据开太小WA了一个点，卡了老半天，所以先温馨提示一下：
### 一定要开long long！！！
接着咱们切入正题哈~~

首先，看到这样的题目，就知道要开结构体了啦~（当然，开俩数组也行的）

### 然后讲一下我的思路：
# 
我们就拿样例举个例子吧！

![样例图示](https://cdn.luogu.com.cn/upload/image_hosting/7bx7cp4h.png)

这样方便看出样例里人的座位顺序以及成绩

接着我们从第一个人开始枚举（应该算是枚举吧），第一个人一定要先标成1，从第二个人开始，若目前的人成绩比前一个人高，那么就将这个人的橘子数量标记为后一个的数量+1；若目前的人成绩比前一个人低，那么就先暂时把这个人的橘子数量标记为1；若一样，就标记成一样的个数。

### 第一次的标记大致如图：

![第一次标记](https://cdn.luogu.com.cn/upload/image_hosting/2vzmsv5b.png)

（注：因为成绩>=0所以第一个手动标成1）

第二次的标记和第一次相似。
### 但是第二次的标记注意一下，有几个易错点
记住要加max，不然就会出现标完之后第二次直接把第一次覆盖的情况。

第二次标完了之后应该是这样（这里为了直观一点所以还没有合并）：

![第二次标记](https://cdn.luogu.com.cn/upload/image_hosting/vseyabin.png)

所以要加一个max判断一下，橙子的个数取两次判断中多的一个。

合并了之后就是【1,2,3,2,1】

## 具体的代码如下：
```cpp
#include<bits/stdc++.h>//万能头 
using namespace std;
int n;
long long ans;//记住要定义long long 
struct node{//定义结构体 
	int s,t;
}a[1000005];
int main(){
	cin>>n;
	a[1].s=1;//a[1]要手动标记成 1 
	cin>>a[1].t;
	for(int i=2;i<=n;i++){
		cin>>a[i].t;//这里可以把输入放在一起，不影响 
		if(a[i].t>a[i-1].t)a[i].s=a[i-1].s+1;//成绩比前一个人高的情况 
		else if(a[i].t==a[i-1].t)a[i].s=a[i-1].s;//成绩相同的情况 
		else a[i].s=1;//剩下来就是成绩比前一个人低的情况了 
	}
	for(int i=n;i>=1;i--){
		if(a[i].t>a[i+1].t)a[i].s=max(a[i].s,a[i+1].s+1);//这里和下一个要用max判断 
		else if(a[i].t==a[i+1].t)a[i].s=max(a[i].s,a[i+1].s);
		ans+=a[i].s;//这里标完了可以直接加进总数了 
	}
	cout<<ans;
	return 0;//养成好习惯 
}
```
## 珍爱账号，远离抄袭

##### 看在本蒟蒻写的那么认真的份上……
##### ~~不点个赞再走么？~~