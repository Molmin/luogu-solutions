[题面传送门](https://www.luogu.com.cn/problem/AT2365)

第一篇黒题题解，希望能够用清晰明了的语言来讲这道~~毒瘤~~黒题
## 1.解法探索
#### 1.1 时间复杂度
由$2e5$可知复杂度约为$O(n)$或$O(nlogn)$
#### 1.2 初步暴力
如果我们进行暴力的话，我们会发现V的变化是$V,V/2,V/4,...,2,1,0$

也就是可以跳跃$logV$次

而且，在每个点，如果不进行跳跃，相应水量可以走的距离是固定的且连续的

那么可以尝试预处理在每个点，以相应的水量可以走到的最左和最右

（可以结合样例理解）
#### 1.3 推理思考
那么我们知道每个点可以走的范围是否有用呢？

首先我们的目标，是知道在一个点是否可以遍历所有点

也就是从一个点，使用若干个V，向左与向右走，是否可以到达1号点与n号点

那么应不应该强制只能够连续走呢？

设想在一个点，如果向左连续用了$V,V/2,V/4,V/8$的水，方案会最优吗？

显然不会

那么在上面的例子中，跳跃一直是向左的

那我们是不是也可以向左，向右，向左，向右……

只要最终不重复地使用了若干个连续的$V,V/2,V/4,V/8,...$即满足我们的要求

可是我们又如何知道向左与向右跳用了哪一些V呢？

考虑V的范围，能不能够把V记录下来

可以！！！

那就状压没跑了

那又回到原来的问题：应不应该强制只能够连续走呢？

如果连续走，并不能走到1或n号点，那跳跃起来走，也不可能达到要求

所以判断就变成了这样：

- 从一个点，使用若干个V，向左与向右连续走，是否可以到达1号点与n号点

换个角度，我们要求每个点到1与n，复杂度不小

那是不是可以直接在1与n计算即可

也就是求从1号点与n号点，向左或向右连续跳，使用若干个V，能够到达的最右和最左的距离

运用上述思路，使用状压是一个好选择，且复杂度不会过高

那么最后如何利用已知求出答案？

如果1可以到达i，n可以到达j，且$i>=j$，我们是不是就可以判断j到i这个区间是可行的？

如图

![](https://cdn.luogu.com.cn/upload/image_hosting/4ozjdkls.png)

在这里留一个点：控制V在两个线段的交集处使用

#### 1.4 整理思路
我们解题的顺序是什么呢？

- 求出所有的V

- 使用递推，求出每个点在每一个V时所能够走的范围

- 使用状压+dp，求出在点1与点n所能够向左与向右走最远的距离

- 判断交集，求出每个点是否能够遍历每一个点，得到答案

那么求解的部分就结束了，接下来是每一个部分的代码实现了

## 2.代码片段（详细注释）
#### 2.1 求出所有的V
```cpp
//一行搞定qwq
int V=m;while(V){V>>=1;v[cnt++]=V;}v[cnt]=m;
//注意这里要保证最后一个V是最大的V，才能够为1.3留下的问题的解决提供条件
```
#### 2.2 求出每个点在每一个V时所能够走的范围
```cpp
	for(int i=0;i<=cnt;i++)
	{
		l[i][1]=1;//向左，预处理是显然的
		r[i][n]=n;//向右
		for(int j=2;j<=n;j++) l[i][j]=(a[j]-a[j-1]<=v[i])?l[i][j-1]:j;//如果我们能够走到左边的点，那就可以走到左边的点所能够走到的最左，向右同理
		for(int j=n-1;j>=1;j--) r[i][j]=(a[j+1]-a[j]<=v[i])?r[i][j+1]:j;
	}
```
#### 2.3 求出在点1与点n所能够向左与向右走最远的距离
```cpp
	for(int i=0;i<(1<<cnt);i++) R[i]=n+1;//为了取min，先赋初值
	for(int i=0;i<(1<<cnt);i++)
		for(int j=0;j<=cnt;j++)
			if(((1<<j)&i)==0)//状压常规操作
				L[(1<<j)|i]=max(L[(1<<j)|i],r[j][L[i]+1]),
				R[(1<<j)|i]=min(R[(1<<j)|i],l[j][R[i]-1]);//由于我们要求连续走，那么我们就在现在的极限向左或右跳一步，然后再走即可
```
#### 2.4 得到答案
```cpp
	for(int i=1;i<=n;i++)//这里i是跳跃的，所以随机下是走不满的
	{
		bool flag=0;
		for(int j=0;j<(1<<cnt);j++)
		{
			int ss=((1<<cnt)-1)^j;//求补集，因为我们在1点用的V和在n点用的V不应该重复，那两个集合的并集就是V的全集，交集为空
            		//注意我们可能不需要用某一个V，这个时候你是可以浪费它的，比如跳两次等
			if(L[j]>=i-1&&R[ss]<=r[cnt][i]+1){flag=1;break;}//如果线段交集满足要求，注意这里我们是保证第一步从V开始跳，当然如果你不要也可以浪费掉，总之一点V不能够在别的地方出现
		}
		for(int j=i;j<=r[cnt][i];j++) ans[j]=flag;
		i=r[cnt][i];
	}
```
## 3.代码时间（无注释版）
时间复杂度约为$O(VlogV)$
```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
const int N=2e5+5;
int n,m,a[N],l[25][N],r[25][N],v[25],cnt=0,L[1<<25],R[1<<25],ans[N];
int main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++) scanf("%d",&a[i]);
	int V=m;
	while(V){V>>=1;v[cnt++]=V;}v[cnt]=m;
	for(int i=0;i<=cnt;i++)
	{
		l[i][1]=1;
		r[i][n]=n;
		for(int j=2;j<=n;j++) l[i][j]=(a[j]-a[j-1]<=v[i])?l[i][j-1]:j;
		for(int j=n-1;j>=1;j--) r[i][j]=(a[j+1]-a[j]<=v[i])?r[i][j+1]:j;
	}
	for(int i=0;i<(1<<cnt);i++) R[i]=n+1;
	for(int i=0;i<(1<<cnt);i++)
		for(int j=0;j<=cnt;j++)
			if(((1<<j)&i)==0)
				L[(1<<j)|i]=max(L[(1<<j)|i],r[j][L[i]+1]),
				R[(1<<j)|i]=min(R[(1<<j)|i],l[j][R[i]-1]);
	for(int i=1;i<=n;i++)
	{
		bool flag=0;
		for(int j=0;j<(1<<cnt);j++)
		{
			int ss=((1<<cnt)-1)^j;
			if(L[j]>=i-1&&R[ss]<=r[cnt][i]+1){flag=1;break;}
		}
		for(int j=i;j<=r[cnt][i];j++) ans[j]=flag;
		i=r[cnt][i];
	}
	for(int i=1;i<=n;i++) puts(ans[i]==0?"Impossible":"Possible");
	return 0;
}
```
**完结撒花！！！**