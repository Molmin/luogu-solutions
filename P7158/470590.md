## 题目描述：

题目要求构造 $n$ 位数，其中没有前导零（ $0$ 没有前导零而且是一位数）。这个数中含有偶数个 $k$ （ $0$ 是偶数）。求出符合要求的 $n$ 位数的数量。

## 思路：

本题我们考虑DP。

设 $f1[i]$ 为 $i$ 位数中满足要求的数的数量， $f2[i]$ 为 $i$ 位数中不满足要求的数的数量。

则转移方程为 $f1[i]=f1[i-1]*9+f2[i]$ 和 $f2[i]=f2[i-1]*9+f1[i]$ 。

看到这里，相信很多人就要问了：

#### 为什么呢？？

对于一个满足了要求的 $i$ 位数，是不是可以由一个满足要求的 $i-1$ 位数后加上一位0~9之中除了 $k$ 的任何一个数，或者由一个不满足要求的 $i-1$ 位数后加上一位 $k$ 构成。对于前者，0~9中十个数，去掉 $k$ 还剩九个，因此由原来满足要求的 $i-1$ 位数构成满足要求的 $i$ 位数就有 $f1[i-1]*9$ 个；对于后者，因为原来不满足要求，加上一位 $k$ 就可满足要求，因此由原来不满足要求的 $i-1$ 位数构成满足要求的 $i$ 位数就有 $f2[i-1]$ 个。

综上所述， $f1[i]=f1[i-1]*9+f2[i-1]$ 。

而对于一个不满足要求的 $i$ 位数，可以由一个不满足要求的 $i-1$ 位数后加上一位0~9之中除了 $k$ 的任何一个数，或者由一个满足要求的 $i-1$ 位数后加上一位 $k$ 构成。由原来不满足要求的 $i-1$ 位数构成不满足要求的 $i$ 位数就有 $f2[i-1]*9$ 个；由原来满足要求的 $i-1$ 位数构成不满足要求的 $i$ 位数就有 $f1[i-1]$ 个。

综上所述， $f2[i]=f2[i-1]*9+f1[i-1]$ 。

初始化： 

$f1[1]=8$ （因为数字中不能有前导零，所以转移时要把 $0$ 去掉，不能出现 $01$ 、 $02$ 等情况；同时要把 $k$ 去掉，因为奇数个 $k$ 是不满足要求的）
    
$f2[1]=1$ （这一个数为 $k$ ）


### 但是！！

我们要特判 $1$ 位数的情况，满足要求的有0~9十个数中去除 $k$ 一个数就是9个数，因此当输入的 $n$ 为 $1$ 时，直接输出 $9$ 就可以了。

### 注意：

每次转移后都对 $998244353$ 取模。

先读入再进行DP的时间复杂度是 $O(tn)$ ，~~A不了~~。

所以我们要先处理出 $1e5$ 的数据，后面读入后直接输出就行了。

## 代码：
```cpp
#include <bits/stdc++.h>
using namespace std;

inline int read() {
	int x=0;
	int f=1;
	char c=getchar();
	while(c<'0' || c>'9') {
		if(c=='-') f=-1;
		c=getchar();
	}
	while(c>='0' && c<='9') {
		x=x*10+c-'0';
		c=getchar();
	}
	return x*f;
}//快读

const int maxn=1e5+5;
const int mod=998244353;//mod直接定义为常数
int n,k;
int t;
long long f1[maxn];
long long f2[maxn]; 

int main()
{
	t=read();
	f1[1]=8;f2[1]=1;//初始化
	for(int i=2;i<=100005;i++)//预处理
	{
		f1[i]=(f1[i-1]*9+f2[i-1])%mod;
		f2[i]=(f2[i-1]*9+f1[i-1])%mod;
	}
	for(int i=1;i<=t;i++)
	{
		n=read();k=read();
		if(n==1)//特判1的情况
		{
			cout << "9" << '\n';
			continue;
		}
		printf("%lld\n",f1[n]%mod);
	}
	return 0;
}

```

如有不足之处，请大家指出。
### 希望管理大大放行！！！