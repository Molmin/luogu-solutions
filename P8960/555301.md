不难发现，$s_n$ 不会影响最终的结果，进而可以推广到 $s_i$ 不会影响第 $i$ 次折叠后的结果。可以证明第 $i$ 次折叠产生的折痕是峰还是谷只与 $s_{i-1}$ 有关。

考虑第 $i-1$ 次折叠产生的折痕和第 $i$ 次折叠产生的折痕的关系，可以发现，第 $i$ 次折叠产生的折痕数恰好是第 $i-1$ 次折叠产生的折痕数的 $2$ 倍，而且对于每个第 $i-1$ 次折叠产生的折痕，都有 $2$ 个第 $i$ 次折叠产生的折痕与之对应，且恰好分布在该折痕的两侧（以下记为折痕 `l` 和折痕 `r`）。

探究 $s_{i-1}$ 对折痕 `l` 和 `r` 的影响，可以发现：若 $s_{i-1}$ 是 `0`，那么折痕 `l` 和 `r` 分别是峰和谷，若 $s_{i-1}$ 是 `1`，那么折痕 `l` 和 `r` 分别是谷和峰。

现在的问题就转化成对于输入的 $n$ 和 $k$，第 $k$ 次折痕是第几次折叠产生的折痕，以及第 $k$ 次折痕位于上次折叠产生的折痕的左侧还是右侧。

考虑二分，边二分边统计折叠的次数，不难发现之前二分的次数就是折叠的次数。二分时，若 $k<mid$，那么 $k$ 位于左侧，反之亦然。

代码：

```cpp
#include <bits/stdc++.h>
using namespace std;
#define LL long long
LL t, n, k, p, l, r, d;         //要开long long
string s;
int main() {
    cin >> t;
    while (t--) {
        cin >> n >> k >> s;
        p = 0;                  //代表当前的折痕是峰还是谷，峰1谷0，因为第1次折叠产生的折痕是谷，所以初始化为0
        l = 1;
        r = (1LL << n) - 1;
        d = 0;                  //代表当前折叠的次数，但是string的下标从0开始
        while (l <= r) {
            LL mid = (l + r) >> 1;
            if (mid == k) {       //找到了，输出答案
                cout << (p ? "Up\n" : "Down\n");
                break;
            }
            if (k < mid) {        //k<mid，在左侧
                if (s[d] - '0')   //等同于s[d]=='1'
                    p = 0;
                else
                    p = 1;
                d++;
                r = mid - 1;
            }
            else {                //k>mid，在右侧
                if (s[d] - '0')
                    p = 1;
                else
                    p = 0;
                d++;
                l = mid + 1;
            }
        }
    }
    return 0;
}
```