# P8960 「WHOI-4」A 折纸 题解

## 前面的话

这是一道有趣的模拟题。笔者赛后补题时发现了这个奇怪的做法，因此写出了这篇题解。题解可能比较长，但都是为了严谨地表达做法，请多包含；如有错误，感谢指出。

## 题意简述

* $T$ 次询问，给定整数 $n,k$ 和一个长为 $n$ 的 $\text{01}$ 串 $s$。

* 每次询问，将一张纸按照给定 $\text{01}$ 串的规则对折 $n$ 次。对于第 $i$ 次折叠：

    - 如果 $s_i=0$，将纸从左到右对折，使左边对齐右边；

    - 如果 $s_i=1$，将纸从右到左对折，使右边对齐左边。
    
    - 对折全部是从上方翻。

* 将纸展开，保留折痕。对于从左往右数第 $k$ 条折痕，若向上突起，输出 `Up`；否则输出 `Down`。

* $10 \le t \le 10^5$，$1 \le n \le 60$，$1\le k < 2^n$。

## 样例模拟

转变一下思考的方向，以样例一为例子，我们先来做一次模拟。

由于 $n$ 次对折必然会产生 $2^n - 1$ 条折痕，不妨先自左向右对折痕编号（从 $1$ 开始，即下图中颜色较浅的灰线）。

特别地，为叙述方便，纸条最左边为折痕 $0$，纸条最右边为折痕 $2^n$（即下图中颜色最深的两条黑线）。

![图 1](https://cdn.luogu.com.cn/upload/image_hosting/xjlc0fr7.png)

假设 $k = 3$，我们有：

1. $s_0 = 0$，将纸从左到右对折，使左边对齐右边。显然图上的中线（即这次对折应产生的折痕）为 $4$，由于 $3 < 4$，对折后，编号比 $4$ 大折痕所在的部分不再影响答案计算，直接将其撕去；编号比 $4$ 小的折痕所在的部分此时被翻转倒置，标有数字的一面朝下；

![图 2](https://cdn.luogu.com.cn/upload/image_hosting/4fz3exum.png)

2. $s_1 = 1$，将纸从右到左对折，使右边对齐左边。显然图上的中线（即这次对折应产生的折痕）为 $2$，由于 $3 > 2$，对折后，编号比 $2$ 小的折痕所在的部分不再影响答案计算，直接将其撕去；编号比 $2$ 大的折痕所在的部分此时不动，标有数字的一面仍朝下；

![图 3](https://cdn.luogu.com.cn/upload/image_hosting/50tkk1l9.png)

3. $s_2 = 0$，将纸从左到右对折，使左边对齐右边。显然图上的中线（即这次对折应产生的折痕）为 $3$，此次对折使得 $3$ 处**在展开前**有一条向下突起的折痕。由于每次对折折到的位置均不相同，且无论此次对折的规则为 $0$ 或为 $1$，这次对折应产生的折痕，**在展开纸条以前**，都可看作一条突起方向向下的折痕，**故某一个位置的折痕方向，只和这个位置恰当作折痕来进行对折（即位于这个位置的折痕恰好产生）时，它所在的纸条部分的朝向（向上或向下）有关**。回到这个例子，此时突起方向向下的折痕 $3$ 所在的部分朝下，所以翻转为朝向上时，折痕 $3$ 的突起方向变为向上突起。

据此，从左向右第 $3$ 条折痕向上突起，输出 `UP`。

## 分析归纳

我们从上面这个例子能够发现，只要我们能够判定第 $k$ 条折痕恰好被折（即这条折痕恰好产生）的时候，所在部分的纸面朝向是向上，或是向下，这个问题便迎刃而解。

对于撕去冗余部分的做法，这部分的情况和答案毫无关联，可以果断丢弃。每次处理都舍弃区间的一半，形似二分。

同时纸面的朝向，与以前若干次对折有一定关系，具体体现为：

* 某次对折所形成的折痕，其编号与 $k$ 的大小关系；

* 这次对折对应的 $s_i$；

* 这次对折前的纸面朝向。

在笔者对一张草稿纸进行若干次蹂躏以后，我们归纳如下：

记某次对折前，纸条上编号最小为 $l$，编号最大为 $r$，则中线为 $mid = \dfrac{l + r}{2}$，初始时，令 $l = 0$，$r = 2 ^ n$，做法如下：

* 当某次对折前的纸面朝向上方时（**可以理解为编号从左向右递增**）;

    * 若 $s_i = 0$，**将纸从左到右对折，使左边对齐右边**；
    
        * 若 $k$ 小于此时的中线的编号，即 $k < mid$，$k$ 所在的部分被翻折，**对折后这部分的朝向改变**。撕去冗余部分，令 $r \gets mid$；

        * 若 $k$ 大于此时的中线的编号，即 $k > mid$，$k$ 所在的部分未翻折，**对折后这部分的朝向不变**。撕去冗余部分，令 $l \gets mid$；

    * 若 $s_i = 1$，**将纸从右到左对折，使右边对齐左边**；

        * 若 $k$ 小于此时的中线的编号，即 $k < mid$，$k$ 所在的部分未翻折，**对折后这部分的朝向不变**。撕去冗余部分，令 $r \gets mid$；

        * 若 $k$ 大于此时的中线的编号，即 $k > mid$，$k$ 所在的部分被翻折，**对折后这部分的朝向改变**。撕去冗余部分，令 $l \gets mid$；

* 当某次对折前的纸面朝向下方时（**可以理解为编号从左向右递减**）;

  情况同理，直接归纳。

    * 若 $s_i = 0$；
        * $k < mid$，**朝向不变**。令 $r \gets mid$；
        * $k > mid$，**朝向改变**。令 $l \gets mid$；
    * 若 $s_i = 1$；
        * $k < mid$，**朝向改变**。令 $r \gets mid$；
        * $k > mid$，**朝向不变**。令 $l \gets mid$；

对于边界情况，纸面朝向上方时恰被折叠（$k = mid$），则折痕向下突起；反之，为向上突起。

## 程序实现

多个嵌套语句过于繁杂，考虑寻求简化的表达。

形式化地，记 $f$ 代表纸面朝向，向下为 $1$，向上为 $0$。每次要改变纸面朝向时，可以直接令 $f \gets f \space \textup{xor} \space 1$；记 $t$ 代表 $k$ 和 $mid$ 的大小关系，$k$ 较小时为 $1$，反之为 $0$。

当 $f = 0$ 时，要求 $t = 1,s_i = 0$ 或 $t = 0, s_i = 1$，即 $f \space \textup{xor} \space t \space \textup{xor} \space s_i = 1$ 时要改变 $f$；当 $f = 1$ 时，要求 $t = 0,s_i = 0$ 或 $t = 1, s_i = 1$，即 $f \space \textup{xor} \space t \space \textup{xor} \space s_i = 1$ 时要改变 $f$。

这样，我们摒弃了分类讨论，采用异或来直接实现代码，更为方便。

最坏时间复杂度 $\mathcal{O}(T \cdot \log 2^n)$ 近似为 $\mathcal{O}(T \cdot n)$，可以通过本题。

```cpp
#include <bits/stdc++.h>
using namespace std;
int n, T;
unsigned long long k, l, r, mid;
string s;
bool f;
int main()
{
    ios::sync_with_stdio(0);
    cin.tie(0);
    cin >> T;
    while(T--)
    {
        cin >> n >> k;
        cin >> s;
        l = 0, r = (1ll << n);
        f = 0;
        for(int i = 0; i < n; i++)
        {
            mid = (l + r) >> 1;
            if(k == mid)
            {
                if(f)
                    cout << "Up" << endl;
                else
                    cout << "Down" << endl;
                break;
            }
            if(f ^ (k < mid) ^ (s[i] == '1'))
                f ^= 1;
            else
                ;
            if(k > mid)
                l = mid;
            else
                r = mid;
        }
    }
    return 0;
}
```

## 后面的话

这篇题解到这里就结束了。我们从样例的模拟中发现了决定突起方向的几个因素，再对这些因素进行分类讨论，最后用逻辑运算进行简化，从而解决本题。如有勘误，敬请指出。