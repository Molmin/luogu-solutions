# 题解 P8960 「WHOI-4」A 折纸

### Part1 题意

[原题传送门](https://www.luogu.com.cn/problem/P8960)

把纸按照一个给定 $01$ 串 $s$ 的规则折叠，求第 $k$ 个折痕的凸起方向。

$10\le t \le 10^5,1\le n \le 60,1\le k \le 2^n$。

### Part2 思路

我们可以一次一次地探索规律。

第一次很显然会有一个谷折，无论左右（不信你拿张纸试试）。

接着我拿一张纸向左折了三次，结果：

![](https://cdn.luogu.com.cn/upload/image_hosting/r85q2eur.png)

仔细观察：

![](https://cdn.luogu.com.cn/upload/image_hosting/6950hk6o.png)

- 可以发现，第 $i$ 次折叠会产生 $2^{i-1}$ 个折痕，**分别位于之前的 $2^{i-1}-1$ 个折痕之间**（包括两边）**的 $2^{i-1}$ 个空当处**。

- 还有，**与中间折痕**（也就是第一次折出来的）**距离相等的两个折痕凸起方向相反。**

- 将四个黄色箭头连起来可以发现：第 $1$ 个和第 $3$ 个、第 $2$ 个和第 $4$ 个相同。如果折更多次，可以发现**同一次折出的所有折痕中，第奇数个折痕凸起方向都相同，第偶数个折痕凸起方向都相同。**

现在就差确定方向了，是吗？

- 刚才我往左折了三次，串 $s$ 应为 `111`，而每一次（除了第一次）折出的折痕都是第奇数个为谷，第偶数个为峰。
- 如果我们把 $s$ 变成 `000`，结果应该与上面相反：第奇数个均为峰，第偶数个均为谷。
- 如果你拿一张纸折一下的话，可以发现最后一次**对折的方向对结果没有影响**（都是那一道折痕有啥影响啊）。
- 于是我们猜测结论：第 $k$ 次对折折出的折痕凸起方向与 $s_{k-1}$ 有关，**当 $s_{k-1}=0$ 时，第奇数个均为峰，第偶数个均为谷；否则第奇数个均为谷，第偶数个均为峰**。代入样例也是对的。

但我们怎么知道这是这一次折出的第几个折痕呢？没关系，继续找规律。

还是这张图：

![](https://cdn.luogu.com.cn/upload/image_hosting/6950hk6o.png)

上面已经涉及一堆 $2$ 的幂了，我们就尝试把折痕的编号变成二进制试试吧。

```
(k = 第 k 次折出来的
001(3
010(2
011(3
100(1
101(3
110(2
111(3
```

把第一、二、三次的分别放一起：

```
(1
100
(2
010
110
(3
001
011
101
111
```

很明显，第一次折出来的二进制最后一个 $1$ 是左数第 $1$ 位，第二次折出来的最后一个 $1$ 都是左数第 $2$ 位，第三次折出来的最后一个 $1$ 都是左数第 $3$ 位。然后我们就只需要用 $\text{O}(\log n)$ 的复杂度把编号变成二进制找就好啦！

### Part3 代码

注意我这里没有转二进制，是直接从 $2^{60}$ 开始一个个减找最后一位。

注释比较粗略，但涉及的内容均可以在 Part2 找到。

```cpp
#include<iostream>
#include<string>
#define ll long long
#define ull unsigned long long
#define lf double
#define ld long double
using namespace std;
ll t,n,k;
string s;
ll f(ll x){//求二进制位最后一个 1 的位置，据此可得这个折痕是第几次对折而来的 
	for(ll i=61;i>=0;i--){
		if(x>=(1ll<<i)){
			x-=(1ll<<i);
		} 
		if(x==0){
			return i;
		}
	}
}
ll g(ll x,ll fx){//求是这一次里产生的第奇数个还是第偶数个折痕 
	ll tmp=0;
	for(ll i=61;i>=0;i--){
		if(x>=(1ll<<i)){
			x-=(1ll<<i);
			tmp+=(1ll<<(i-fx));
		} 
	}
	return (tmp/2+1)%2;
}
string out[2]={"Up","Down"};//压缩代码(doge) 
int main(){
	cin>>t;
	while(t--){
		cin>>n>>k>>s;
		if(k==(1ll<<n)/2){//第一次很显然是谷折 
			cout<<"Down\n";
		}
		else{
			if(s[s.length()-2-f(k)]=='0'){//这里规律见思路部分 
				cout<<out[!g(k,f(k))];
			}
			else{
				cout<<out[g(k,f(k))];
			}
			cout<<endl;
		}
	}
	return 0;
}
```