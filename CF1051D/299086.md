[传送门](https://www.luogu.com.cn/problem/CF1051D)

题目大概意思是：给出一个 $2 \times n$ 的矩形，每个格子可以填黑白两种颜色，会形成联通块（黑白都算）。问有多少种填色情况使得最后联通块个数为 $k$。答案对 $998244353$ 取模。

对这么大的数取模，说明暴力一定会爆时间，考虑用 DP 求解。

- 首先我们要知道，填色的每一列只会有四种填色情况，用二进制表示为：00，01，10，11。转化为十进制就是 0 ~ 3。

- 我们设 ```f[i][j][k]``` 为前 $i$ 列，联通块数量为 $j$，最后一列情况为 $k$ 的个数。

- 设定好状态，列状态转移方程，如下：

$$f[i + 1][j][k] += f[i][j][k] (0 \leq k \leq 3)$$
$$f[i + 1][j + 1][k] += f[i][j][0] (1 \leq k \leq 3)$$
$$f[i + 1][j + 1][k] += f[i][j][3] (1 \leq k \leq 2)$$
$$f[i + 1][j][3] += f[i][j][k] (1 \leq k \leq 2)$$
$$f[i + 1][j][0] += f[i][j][k] (1 \leq k \leq 2)$$
$$f[i + 1][j + 1][0] += f[i][j][3]$$
$$f[i + 1][j + 2][1] += f[i][j][2]$$
$$f[i + 1][j + 2][2] += f[i][j][1]$$

完整代码：

```cpp


#include <bits/stdc++.h>

using namespace std;

int n, k;
long long f[1009][2009][4];

int main () {
	scanf("%d%d", &n, &k);
	
	f[1][1][0] = 1;
	f[1][1][3] = 1;
	f[1][2][1] = 1;
	f[1][2][2] = 1;
	
	for (int i = 1; i < n; i++) {
		for (int j = 1; j <= (i << 1); j++) {
			for (int k = 0; k < 4; k++) {
				f[i + 1][j][k] = (f[i + 1][j][k] + f[i][j][k]) % 998244353;
			}
			
			for (int k = 1; k < 4; k++) {
				f[i + 1][j + 1][k] = (f[i + 1][j + 1][k] + f[i][j][0]) % 998244353;
			}
			
			for (int k = 1; k < 3; k++) {
				f[i + 1][j + 1][k] = (f[i + 1][j + 1][k] + f[i][j][3]) % 998244353;
				f[i + 1][j][3] = (f[i + 1][j][3] + f[i][j][k]) % 998244353;
				f[i + 1][j][0] = (f[i + 1][j][0] + f[i][j][k]) % 998244353;
			}
			
			f[i + 1][j + 1][0] = (f[i + 1][j + 1][0] + f[i][j][3]) % 998244353;
			f[i + 1][j + 2][1] = (f[i + 1][j + 2][1] + f[i][j][2]) % 998244353;
			f[i + 1][j + 2][2] = (f[i + 1][j + 2][2] + f[i][j][1]) % 998244353;
		}
	} 
	
	printf("%lld\n", (f[n][k][0] + f[n][k][1] + f[n][k][2] + f[n][k][3]) % 998244353);
	
	return 0;
}
```
