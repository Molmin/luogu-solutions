# 储存位置
首先这道题的答案一般来说不唯一，那我们可以这么想：**我们只需要得到每一个不同的字符的随即一个位置，然后进行排序，输出a[i]-a[i+1]-1的位置上的数即可！！**

举个例子：
| 1 | 2 | 3 | 4 | 5 |6  |
| -----------: | -----------: | -----------: | -----------: | -----------: | -----------: |
| a | a | a |  c|a  |s  |
那么我们取每一个字符第一次出现时的位置：
|  a|  c| s |
| -----------: | -----------: | -----------: |
|0  |3 |5  |
那么我们就可以分割成三个字符串：aaa,ca,s

但如果要求分割成n个字符串的话?

**我们就可以把这个数组的第[n+1]位变成字符串的长度-1，然后执行n次。**

下面奉上AC代码：
```cpp
#include <iostream>
#include <string>
#include <algorithm>
using namespace std;
int a[28];//数组不用开太大，只有26个字母
long long sum=0;
int main(){
	int i,j,k=0,n;
	string st;
	cin>>n;
	cin>>st;
	for(i=0;i<st.length();i++)
	if(a[st[i]-96]==0)a[st[i]-96]=i+1,sum++;//此处我用i+1,因为i的话，第0个位置就会出问题
	if(sum<n){//判断是否小于
		cout<<"NO"<<endl;
		return 0;
	}
	cout<<"YES"<<endl;
	sort(a+1,a+27);//进行排序
	for(i=1;i<=26&&k<n;i++)//此处加k<n是因为从查找到被赋值的第i个位置时执行n次
	if(a[i]>0){//注意：一定要加！不然会出问题，逻辑！
	    if(k==0)a[n+i]=st.length()+1;//这样的话就可以保证最后不会疏漏
		for(j=a[i]-1;j<a[i+1]-1;j++)cout<<st[j];//重在理解这一句：a[i]-a[i+1]-1
		cout<<endl;
		k++;
	}
	return 0;
}
```


