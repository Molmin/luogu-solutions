这题我们可以统计26个字母是否在一个单次内出现。

具体做法：对于每个字符串，用一个 `int` 类型的整数存储。如果字母 `a` 出现了，则对应整数二进制的第零位为$1$；如果字母 `b` 出现了，则对应整数二进制的第一位为$1$，以此类推至`z`。因为 `int` 类型能够存储 $32$ 位，所以不用担心存不下的情况。

然后就是选择了。我们可以写一个正常的搜索程序，包含待选区的起点和终点，以及当前选中的状态。对于状态，遵循上面每个字符串对应 `int` 类型整数存储的原则。而当我们要选择一个字符串时，我们只需将原有状态与当前字符串对应整数取或运算就行了。因为对于每个字母，只要出现在了原状态或者当前整数中，那么将这两个整数合并后，它一定会出现在里面的，这对应的正好是或运算。

起始状态是 $0$，因为一个字母没选；终止状态是 $2^{26}-1$，因为此时每个字母都被覆盖了。但是注意：如果搜到了终止状态，**不能返回！** 否则方案数会大打折扣。

另附：AC 代码（不要抄！）
```cpp
#include<bits/stdc++.h>
using namespace std;
const int err=-120712^7869^12174,uerr=0x3f3f3f3f,eps=1e-9,N=29,goal=(1<<26)-1;
int n,stat[N],ans=0;
void dfs(int b,int e,int now){
	if(now==goal) ans++;
	for(int i=b;i<e;++i){
		dfs(i+1,e,now|stat[i]);
	}
}
int main(){
	scanf("%d",&n);
	for(int i=0;i<n;++i){
		string st;
		cin>>st;
		for(int j=0;j<st.size();++j) stat[i]|=(1<<st[j]-'a'); 
	}
	dfs(0,n,0);
	printf("%d",ans);
	return 0;}

```