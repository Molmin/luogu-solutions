## 这是个O（n）的算法
## **这是篇对萌新友好的题解**
## 大佬直接跳过吧

------------
### 思路

这是一道操作数列的题

易发现下述题目具有的性质
1. 发现这个数列是没有任何修改的
1. 发现这个区间可行性是单调的（即扩展区间答案只可能由Yes变为No，并且一旦No就不可能Yes了）
1. 数列数值是很小的

一些本题解不需要的性质（在其他题里可能很有用的）

- 可以离线

- 数值比N小


### 分析
1. 没有修改说明**可以预处理答案**
1. 单调说明**可以从上个已经求出答案的区间拓展到下一个区间**（其实单调是个好用的性质，最常见的是二分）
1. 数值小**说明可以用桶直接存数值**

### 开切
关键是怎么预处理出答案

因为单调，我们可以确定：

对一个被作为右端点的位置，它的左端点 满足答案为Yes的位置 是有最小值的，在最小值右边都是Yes，左边都是No（二分？不需要）

可以用个数组lm[i]表示以第i个数为右端点时左端点的最小值，显然只要知道这个我们就可以回答所有询问，如果询问的l更小那就是No，否则为Yes


接下来求解所有位置的lm

从左往右求解（拓展区间一般是这样的，如果不行就换个方式）

假设当前处理到了第i个元素

这时我们知道lm[i-1]到i-1是合法的，如果当前位置的元素在之前的lm[i-1]到i-1都没出现过，那直接拓展lm[i]=lm[i-1]，否则就是第i个元素的值上次出现的位置+1

这时就求解完毕了

参考代码（实现略有不同）~~炒鸡短~~
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=100005;
int a[N],lm[N],n,q;
int main(){
	scanf("%d%d",&n,&q);
	int k,l,r;
	for(int i=1;i<=n;i++){
		scanf("%d",&k);
		lm[i]=max(lm[i-1],a[k]+1);
		a[k]=i;
	}
	for(int i=1;i<=q;i++){
		scanf("%d%d",&l,&r);
		if(lm[r]<=l)printf("Yes\n");
		else printf("No\n");
	}
	return 0;
} 
```

