其实这道题没必要用双指针，$3\times10^5$ 的数据范围让我们可以 $O(nlogn)$ 地yong $map$ 水过本题。

首先不难发现，无解当且仅当 $a$，$b$ 总和不同（不然完全可以考虑分成一段，总和相同）。

然后我们贪心的去想，发现当两个数列的某一位上的前缀和相同时，由于前缀和单调递增，把他们减掉对后面是没有影响的。

所以我们就尽可能的删去相同的前缀和即可，每遇到一段相同的前缀和就把答案加一。那么后面所有数的前缀和都要减去当前这个前缀和。

发现我们减去的两个前缀和大小相同，因此后面的所有前缀和的**大小关系**是不变的，因此可以不减（我们只考虑大小关系）。

那么问题就变成了：

给你两个序列，问这两个序列中有多少个数相同。

这个用 $map$ 维护一下就过去了。

核心代码如下：

```cpp
int n, m, ans;
LL a[300010], b[300010];
LL sa[300010], sb[300010];
map <LL, bool> h;
int main(){
    read(n);
    for (register int i = 1;i <= n;i ++) read(a[i]), sa[i] = sa[i - 1] + a[i];
    read(m);
    for (register int i = 1;i <= m;i ++) read(b[i]), sb[i] = sb[i - 1] + b[i];
    if(sa[n] ^ sb[m]) return printf("-1\n"), 0;//判无解
    for (register int i = 1;i <= n;i ++) h[sa[i]] = 1;
    for (register int i = 1;i <= m;i ++) ans += h[sb[i]];//判相同的数个数
    fprint(ans, 10);
}
```