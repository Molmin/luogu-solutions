###   已经有大佬发了反向思考的题解了，我来补一个正向思考的
首先，我们来看一下数据范围 $(3≤n≤40,1≤x≤5,1≤y≤7,1≤z≤5)$

$3≤x+y+z≤17$,是一个十分小的范围，对于这种$20$以下的范围，我们选择状压。

$i$表示我们当前的状态，当$i$从右往左数第$k+1$位为$1$时，表示当前所填的所有数的和可能为$k$。$ne[i][j]$表示当前状态为$i$，下一位填$k$时我们所能够得到的状态。为了防止溢出，当$ne[i][j]>(1<<x+y+z)$时，我们要把它降到$1<<x+y+z$；

动态转移方程$f[i][ne[j][k]]=(f[i][ne[j][k]]+f[i-1][j])$%$m$;
($f[i][j]$表示第$i$位状态为$k$时的方案数）

接下来，上代码！（程序冗杂，仅供参考，不要取笑）
```cpp
#include<bits/stdc++.h>
 using namespace std;
 int m=1000000007,n,x,y,z;
 unsigned long long f[41][131075],ne[131075][11],i,j,k;
 int main()
{
    scanf("%d%d%d%d",&n,&x,&y,&z);
    y+=x; z+=y;
    for(i=1;i<=1<<z;i++)
     for(j=1;j<=10;j++)
      {
        ne[i][j]=1;
        for(k=0;k+j<=z;k++)if(i&(1<<k))
         if(!(k<x&&k+j>x)&&!(k<y&&k+j>y))
         //如果原本小于x或小于x+y但加上j后超过了，那么数列就不是俳句，预处理ne数组的时候要特别注意一下
          ne[i][j]|=1<<(j+k);
        if((i==(1<<z))||ne[i][j]>=1<<z)ne[i][j]=1<<z;
      }
    f[0][1]=1;
    for(i=1;i<=n;i++)
     for(j=1;j<=1<<z;j++)
      for(k=1;k<=10;k++)
       f[i][ne[j][k]]=(f[i][ne[j][k]]+f[i-1][j])%m;
    cout<<f[n][1<<z];
    return 0;
}
```