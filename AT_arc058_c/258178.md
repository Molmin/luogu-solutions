>- 若 $a=\{a_1,a_2,\cdots a_n\}$ 存在 $1\le x<y<z<w\le n+1$ 满足 $\sum\limits_{i=x}^{y-1}a_i=X,\sum\limits_{i=y}^{z-1}a_i=Y,\sum\limits_{i=z}^{w-1}a_i=Z$ 时，则称数列 $a$ 是**好的**。
>- 求在所有长度为 $n$ 且 $a_i\in\mathbb{N}^{+}\cap[1,10]$ 的 $10^n$ 个序列 $a$ 中，有多少个序列是**好的**，答案对 $10^9+7$ 取模。
>- $3\le n\le40$，$1\le X\le5$，$1\le Y\le7$，$1\le Z\le5$。

编程兔有没有母亲啊，敢把这种东西放到山东普及补测来。

首先第一反应拆分数，然后我 `rush` 了一下发现过不了样例，因为这样一定会出现重复的问题，一个序列可能有多次匹配。

那接下来根据数据范围来猜算法了，不是搜索就是状压。

我们对于一个串被多次统计的问题，第一个想法就是找出一个代表的来统计，但是我们发现这是非常困难的。

这里我们统计不符合要求的串。

怎么统计呢，我们有一个废话的结论，我们枚举字符串的结束，对于一个有俳句的串，其一定有一个后缀符合要求。

如果直接枚举，判定很容易，但我们如果想一次统计多个串是否符合要求，那就需要进行分类。

我们发现，在上一个 `DP` 中，算重的原因是一个状态在判定为合法后会继续计算，我们如果想去掉这个问题只可能上容斥，但这个容斥过于不伦不类，无法实现，所以我们想到了**状压**。

我们先考虑对整个数组进行状压，考虑怎么把不是二进制的数压到二进制。

我们这么考虑，对于一个数 $i$，就把原来的状态左移 $i$ 位，然后再填上一个 1 就可以了，初始状态设为 1。

这样我们就可以判了，对于 $X,Y,Z$ 也这样构造出一个这样的串，称为基本串，同时对于每个串的每一个后缀，看一看两个与起来是不是还是基本串。

好的，这里的状压已经可以保证不重不漏了，接下来是优化复杂度。

假设我们枚举到了第 $i$ 位，那明显，每个状态只有最后的 $X+Y+Z+1$ 是有效的。

所以我们直接舍弃超出范围的位就可以了，这里的操作其实就是将一整个状态归入其末尾的状态。

这个题提醒了我们，状压是可以压正数的，同时状压的状态可以简化，可以归纳。

```
#include <bits/stdc++.h>
#define ll long long
#define ull unsigned long long
#define ld long double
#define inf 0x7ffffff
#define int ll

using namespace std;
const int mod=1e9+7;
int n,x,y,z;
int ed,f[50][(1<<17)+10];
int tot,ans;

signed main(){
	ios::sync_with_stdio(false);
	cin.tie(0),cout.tie(0); 
	cin >> n >> x >> y >> z;
	f[0][0]=1;
	tot=(1<<(x+y+z))-1;
	ed|=1<<(x-1);
	ed=((ed<<(y))|(1<<(y-1)));
	ed=((ed<<(z))|(1<<(z-1)));
	ans=1;
	for(int i=1;i<=n;++i){
		ans=(ans*10)%mod;
		for(int j=0;j<=tot;++j){
			if(f[i-1][j]==0) continue ;
			for(int k=1;k<=10;++k){
				int s=((j<<k)|(1<<(k-1)));
				s&=tot;
				if((s&ed)!=ed) {
					f[i][s]=(f[i][s]+f[i-1][j])%mod;
				}
			}
		}
	}
	for(int i=0;i<=tot;++i)
		ans=(ans-f[n][i]+mod)%mod;
	cout << ans<<endl;
	
	return 0;
} 
```