这道题直接用 Floyd 就能过(~~其实是因为我把 dijkstra 忘得差不多了~~)。

这么简单的一道题，为什么只有七百多人通过呢？

因为他太~~毒瘤~~水了，大佬们都不做……

**Floyd 算法是啥**

Floyd 算法是一款时间复杂度为 $O(n^3)$ 的算法(n 为点数)，它主要是用来求多源最短路(就是每个点到其他点的最短路)。

这种算法类似于 DP，我们用一个二维数组 d 来存最短路的长度，$d_{i,j}$ 表示点 i 到点 j 的最短路长度。那么我们只要再枚举一个中间点 k，判断 i 到 k 再到 j 的路径长度是不是比 i 直接到 j 短。如果是那就更新 $d_{i,j}$。写成大佬们口中的 "状态转移方程" 就是 $d_{i,j}=\max(d_{i,j},d_{i,k}+d_{k,j})$。

**本题一大坑点**

题目里说了:
```
输入数据不保证起点和终点不同，也不保证小道的起点和终点不同。
在读入过程中，如果两点之间有多条小道，那么它们间的距离为这些小道的最大值。
所以，如果读入一个小道起点和终点相同，那么这个点到它本身的距离不为0。
```
所以每条边都要取最大值，不然就错了（~~我在这里卡很久~~）。

**AC代码**
```cpp
#include <iostream>
#include <cstdio>
#include <cstring> 

using namespace std;

int n,k,d[105][105]; //d[i][j]表示i到j的最短路距离

int main()
{
	scanf("%d%d",&n,&k);
	memset(d,0x3f,sizeof(d));
	for(int i=1;i<=n;i++)
	{
		int t;
		scanf("%d",&t);
		if(d[i][i%n+1]!=d[104][104])//本题一大坑点 
		{
			t=max(t,d[i][i%n+1]);
		}
		d[i][i%n+1]=t;
		d[i%n+1][i]=t;
	}
	for(int i=1;i<=k;i++)
	{
		char s,e;
		int t;
		cin>>s>>e;
		scanf("%d",&t);
		s=s-'A'+1;//字符->数字转换
		e=e-'A'+1;//字符->数字转换
		if(d[s][e]!=d[104][104])//本题一大坑点 
		{
			t=max(t,d[s][e]);
		}
		d[s][e]=t;
		d[e][s]=t;
	}
	for(int k=1;k<=n;k++)//枚举中间点
	{
		for(int i=1;i<=n;i++)//枚举起点
		{
			for(int j=1;j<=n;j++)//枚举终点
			{
				d[i][j]=min(d[i][j],d[i][k]+d[k][j]);//更新
			}
		}
	}
	char s,e;
	cin>>s>>e;
	s=s-'A'+1;//字符->数字转换
	e=e-'A'+1;//字符->数字转换
	printf("%d\n",d[s][e]);
	return 0;
}
```
