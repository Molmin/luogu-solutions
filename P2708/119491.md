思路基本与楼上dalao相同：

比较相邻的字符，不同就++；

# 那么，为什么是这样呢？

__原因：__

首先：我们可以想一想，翻的顺序是无关的。也就是说，我们可以先翻前4个，再翻前3个，也可以先翻前3个，再翻前4个。原因很简单，因为正反只与次数有关，和顺序无关。

接着，我们的目标是111111......11111，

## 也就是说，相邻两个字符必须相同！

那么，当且只当翻转从1到这两个字符的中间才可以改变这两种字符的相对状况，也就是相不相同。

其次，在这种情况以外都不会影响相对情况。

然后，只要翻偶数次，效果是一样的。__或者说，一串要么翻，要么不翻__

所以，我们就可以推出这个结论：

---

首先，我们想要全都是1，而且顺序无关，且一串要么翻，要么不翻，所以我们可以把翻的过程想象成一个bool数组。因为只有在两个字符中间翻才可以改变状况，而我们想要让它们相同。所以，假如相同，那么就不翻。

而且，只要把前$n$个字符和第$n+1$个字符设成相同的，那么我们就可以把它们看成一个字符，这个字符的值=$a[n+1]$。

所以，我们可以在字符串的末尾再加一个‘1’，这样就不用特判，也保证了整个字符串的最终每一个字符的值都是‘1’。

代码奉上：
```cpp
#include <iostream>
using namespace std；

int main()
{
	string a;
	int ans = 0;
	cin >> a;
	a += '1'; // 增加一个‘1’，原因已经在上面讲过了。
	for (int i = 1; i < a.length(); i++)
		if (a[i] != a[i - 1])
			ans++;
	
	cout << ans << endl;
	return 0;
}
```

>欢迎来到[Blog](https://abs2333.blog.luogu.org/#)