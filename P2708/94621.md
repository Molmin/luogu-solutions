看到题目,第一反应就是模拟

但再仔细想想,其实还有更简便的解法

由于硬币翻转的规则是:
```
要求从这行的第一个硬币开始,将前若干个硬币一起翻面
```
那么我们来举两个例子,模拟一下翻转过程:
```
(1)1010010:
1010010
0010010
1110010
0000010
1111110
0000000
1111111

(2)10011:
10011
00011
11111

```
由此找到规律:

当这一个硬币与下一个硬币不同时,这一个硬币连同它之前的硬币一起翻转

翻转至与下一个硬币相同的一面

直到将所有硬币翻转到同一面

但这里还有一个点要注意:

题目要求所有硬币正面朝上,也就是所有面都是'1'的情况,才算完成

我们就再把全部硬币翻转一次

------------

那么这道题就好解决了

- 分析如下:

1. 输入硬币状态,用字符串存储
2. 从第一个字符开始,两两比较
3. 如果不一样就翻转(翻转次数+1)
4. 全部翻转(比较)后,如果最后一个硬币朝下,翻转次数还要+1(具体看前面的解释)
5. 输出翻转次数,结束运行

这道题的简短代码:

------------

```cpp
#include<cstdio>
#include<cstring>
using namespace std;
  char c[10005];
  int i,l,ans=0;
int main(){
  scanf("%s",c);l=strlen(c);//输入硬币状态,保存长度
  for(i=0;i<=l-2;i++){//从第1个开始循环,到l-1个时停止循环(由于字符串的下标从零开始,所以是(i=0;i<=l-2;i++))
    if(c[i]!=c[i+1]){ans++;}//比较第i个和第i+1个是否一样,若不一样,ans++
  }
  if(c[l-1]=='0'){ans++;}//翻转后硬币如果都反面朝上,就再翻转一次,ans++
  printf("%d",s);
return 0;
}
```
希望这篇题解能帮助到你.