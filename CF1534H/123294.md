*[CF1534H Lost Nodes](https://www.luogu.com.cn/problem/CF1534H)

因为第一问蕴含第二问，考虑先回答第二问。下文的 $r$ 表示题目的 $f$。

以 $r$ 为根，则 $a, b$ 位于 $r$ 的不同子树内，也可能等于 $r$，不过后者是平凡的。这样，我们将问题简化至在某个子树内确定一个端点。

设 $f_i$ 表示在 $i$ 的子树内确定一个端点的最小代价，然后考虑策略：在 $i$ 的某个儿子 $u$ 的子树内询问，若回答在 $u$ 的子树内，说明端点在 $u$ 的子树内，否则回答为 $i$，端点在 $i$ 的子树减去 $u$ 的子树的范围内。进一步地，我们发现没有必要先询问一次确定在 $u$ 的子树内，而是将 $u$ 子树的决策的第一次询问作为确定是否在 $u$ 的子树内的询问。这样一来，询问某子树的回答就有可能是 $i$ 的祖先 $t$，表示 $i$ 子树内也没有端点，需要回到 $t$。

假设我们按 $u_0, u_1, \cdots, u_{c - 1}$ 的顺序确定端点是否在这些子树内，则代价为 $\max\limits_{p = 0} ^ {c - 1} f_{u_p} + p$，因为在尝试确定是否在 $u_p$ 子树内时，在此之前我们花了 $p$ 次询问的代价排除了 $u_0 \sim u_{p - 1}$ 的可能。显然对 $u_p$ 按 $f_{u_p}$ 从大到小排序最优。

关于交互过程，我们按 $f_{u_p}$ 从大到小的顺序访问每个子树，并返回已经确定的端点或要返回到的祖先。遇到叶子节点时，直接返回向交互库询问它的返回值。对于 $i$ 和访问它的儿子 $u_p$ 的返回值 $s$，若 $s \neq i$，$s$ 要么在 $u_p$ 子树内表示已经确定的端点，要么为 $i$ 的祖先表示要返回到的祖先，因此直接返回 $s$，否则继续考虑 $u_{p + 1}$ 直到 $u_{p + 1}$ 不存在，此时端点在 $i$ 的子树内但不在 $i$ 的每个儿子子树内，端点只能为 $i$，返回 $i$。

对于根 $r$，若 $a, b$ 均不等于 $r$，则代价为 $\max\limits_{0\leq i < j < c} f_{u_i} + f_{u_j} + j - 1$，最坏情况下为 $f_{u_0} +\max\limits_{j = 1} ^ {c - 1} f_{u_j} + j - 1$。若 $a, b$ 有一个等于 $r$，则代价为 $\max\limits_{i = 0} ^ {c - 1} f_{u_i} + c - 1$ 最坏情况下为 $f_{u_0} + c - 1$。若 $a, b$ 均等于 $r$，则代价为 $c$。

容易换根 DP 对每个 $r$ 求答案。过程中需要动态插入删除查最值，`multiset` 维护即可。时间复杂度 $\mathcal{O}(n\log n)$。[代码](https://codeforces.com/contest/1534/submission/181253357)。