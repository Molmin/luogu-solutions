### 分析
先明确一下题面内容:

>我们可以每步可以做以下两种操作中的任意一种：

>1.把一个自由的套娃直接嵌入一个更大的没有被放入东西的套娃。

>2.选择一个不自由的套娃，将其从其父亲中取出。

其实更准确说题面应该是这个意思：

>我们可以每步可以做以下两种操作中的任意一种：

>1.把一个自由的套娃直接嵌入一个更大的没有被放入东西的自由套娃。

>2.选择一个不自由的套娃，将其从其是自由套娃的父亲中取出。

（与真实的套娃差不多）

为了方便理解，分析一下这组样例：
```
5
0 3 4 0 0
2 3 4 0 0
```
最优操作步骤（$a \rightarrow b$ 表示将 $a$ 放入 $b$ 中，特别的当 $b=0$ 时为将其拿出）：
```
3->0
2->0
1->2
2->3
3->4
```
所以答案应该是 $5$。

由于 $2$ 套娃开始时不是自由的，所以不能直接将其取出。

### 解法
这题可以用 dp 求解。

可以发现如果一个套娃即其内部结构在初始和末尾状态相同，它是不用拿出来其中的套娃的。

反之，如果一个套娃如果内部结构不同，一定要拿出其中的套娃（没有则不拿）。

（这里的内部结构相同指其内部每个套娃的儿子完全相同）

如果初末结构不同的一个套娃开始内部有套娃则需要操作拿出，如果初末结构不同的一个套娃结束内部有套娃则需要操作拿入。

于是就可以现处理开始状态和结束状态每个套娃的儿子。

然后 dp 出内部结构是否相同。

最后看每个套娃是否需要拆装

### 代码
```cpp
#include <bits/stdc++.h>
#define for1(i,n) for(i=1;i<=(n);i++)
using namespace std;
const int N=100005;
int n,a[N],c[N],ans,f[N],t[N];
bool b[N];
int main(){
	int i;
	scanf("%d",&n);
	for1(i,n) scanf("%d",&a[i]),f[a[i]]=i;
	for1(i,n) scanf("%d",&c[i]),t[c[i]]=i;
	b[0]=1;
	for1(i,n){
		b[i]=f[i]==t[i]&&b[f[i]];
		if(!b[i]&&f[i]) ans++;
		if(!b[i]&&t[i]) ans++;
	}
	printf("%d\n",ans);
	return 0;
}

```