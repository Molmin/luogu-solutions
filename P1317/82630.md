这题有一个坑：如果有平地，就不能单单判断左右了，但这样搜索我觉得会比较麻烦，所以平地的地方我都把它化为一个点，就只要判断是否左右的点都比它高即可，比较方便些，看代码吧：
	
    
    
    #include<iostream>
	using namespace std;
	int a[10001],b[10001],n,ans,x=1,i2=1; //b数组用来储存转化后的，i2用来存转化后的有几个点
	int main()
	{
		cin>>n;
		for (int i=1;i<=n;i++)
			cin>>a[i];   //输入
		for (int i=1;i<=n;i++)
			if (a[i]!=x) {x=a[i]; b[i2]=a[i]; i2++;} 
            //因为我们的x定义的是1，保证了a[1]！=x，后面就没有特殊情况了，（用x储存前一个，若此个与前一个不相同，则有效，否则不管他）
		for (int i=2;i<i2;i++)
			if (b[i]<b[i-1]&&b[i]<b[i+1]) ans++; 
            //判断，由于经过我们的转化，已经没有平地了，这样就只需要判断前一个与后一个，### 注意：是从2到i2-1，因为如果是从1到i2会越界，因为要与前面和后面判断，1没有前面，i2没有后面
		cout<<ans; //输出
	}