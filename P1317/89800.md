# STL大法好
### $STL$里头有去重函数

```
unique(ForwardIterator first, ForwardIterator last);
```
### 包含在头文件$algorithm$中

**这个函数的声明什么意思呢？**


首先，你要是想去除重复元素，就要指定一个数组，这里的`ForwardIterator first`就是需要你给他一个数组，把希望去重的数组的名字(这里用的不太恰当)给了它，就可以了。

`ForwardIterator last`是想要你告诉这个函数，你的去重截止到数组的哪个位置，具体的把下标给它。

其实它是一个伪去重，最后会把所有的元素都堆叠在数组的后面。
 
最后返回的值是去重以后的最后一个不重复元素的位置(地址)。


最后不重复的元素的数量是
```cpp
unique(n+1,n+m+1)-&n[1];
//n存储的是各个点的坐标，m是点的数量。
```
注意的是这里的一个`-&n[1]`  由于我们是从n[1]开始进行$unique$操作的，所以说最后返回的地址是去重以后的第一个重复的数的地址加上一个`int`型的大小，最后减去n[1]得到的才是去重以后的不重复的元素个数。
刚才下面一个同学问的很好，
```
与其-&n[1] 为什么不-n-1呢
```
关于这个问题的回答，我想说的是：

这样思路清晰。

~~我不会告诉你们我这么做的真实理由是因为这样子显得我是巨老~~

去重完之后我们就可以开始查找，有几处低洼地

只要数组的某一个数低于左右两个数，那么低洼地的`sum++;`

不难，很好理解。

最后代码：
```cpp
#include<iostream>
#include<algorithm>
using namespace std;
int n[10005];
int main(){
	int m,rp=0;
	cin>>m;
	for(int i=1;i<=m;i++){
		cin>>n[i];
	}
	m=unique(n+1,n+m+1)-&n[1];//去重
	for(int i=2;i<m;i++){
		if(n[i]<n[i-1]&&n[i]<n[i+1])rp++;
	}
	cout<<rp;
	return O;
}
```

代码很短，祝大家都可以AC(当然按照本人的习惯该代码直接交上去会$RE$10个点)