*趁着官方题解还还还还还还没有更新，跑来水一篇题解。*

方便起见，我们稍稍改动一下题目：假定输入器的指针的初始位置不固定在 $1$，而是可以由我们自行决定的。阅读完全文后读者会发现这个改动不太影响问题的实质。（显然最佳情况下指针的初始位置应该在密码的第一位字符对应的位置上。）

显然我们应该开一个数组 $c_{i,j}(1\leq i,j\leq k)$，记录在输入给定密码的时候，有多少次需要从字符 $i$ 转到字符 $j$。可以发现这也是我们应该从密码串上提取的唯一信息。

由于 $k\leq 16$，很自然会去考虑状压 DP。本题难点在于贡献的形式比较复杂，我们需要找到一种合适的处理贡献的方法。

可以发现站在每个字符的角度考虑和其他字符之间的贡献是比较困难的。我们不妨转换视角，从环上每条边的角度来考虑贡献。也就是说，对每一次字符之间的转移，我们把这两个字符环上对应点之间的劣弧上的每条边都放上一根棒子，那么最后所有代价总和就是每条边上的棒子数。接下来我们将从棒子的角度考虑问题。

可以发现，对于一条边，在状压的过程中维护它上面应有的棒子数也还是很困难的。但是，我们发现：当 $k$ 是偶数时，对径的两条边上的棒子数总和是容易维护的！注意到以下几个事实：

- 一条最短路径不会同时经过这两条边，否则其长度就超过了总长度的一半，这是不合理的。
- 假如把这两条对径边切去，圆环断裂成两个半圆。两个来自同侧半圆的点之间的最短路径不可能经过任意一条切掉的边；来自异侧半圆的点之间的最短路径必然经过某一条切掉的边。

也就是说，这两条边的棒子数总和只和两侧半圆的点集有关！这就有了 DP 的结构。

我们考虑从任意一组对径边开始。不妨先枚举确定这组边两边的点集是什么（以下称为 **初始分配方案**）。接下来，我们要在环上一步步移动这组对径边，每次都会改变对径边两边的点集分布，不如称为 **当前分配方案**。可以发现，每次移动的时候相当于两个集合各交换一个元素。我们可以枚举交换哪对元素，注意被交换的元素必须是还没有交换过的。根据初始分配方案和当前分配方案的信息，很容易辨别哪些元素是没有交换过的，故而可以采用 DP。

来分析一下复杂度。初始分配方案有 $\frac{1}{2}\binom{k}{k/2}$ 种，可以发现初始方案确定时当前分配方案总共也是 $\binom{k}{k/2}$ 种（利用熟知的恒等式 $\sum_{i=0}^n\binom{n}{i}^2=\binom{2n}{n}$），故状态总数 $O(\binom{k}{k/2}^2)$，可以承受。转移复杂度如果直接枚举一对元素的话是 $O(k^2)$ 的，这里我们考虑到其实可以拆开来枚举，可以先枚举左边要删哪一个并存进一个状态，下次再枚举右边要删哪一个，这样可以充分利用状态存储的信息。这样单次复杂度只有 $O(k)$ 了，足够通过本题 $k$ 为偶数的情况。

我们再来看看 $k$ 为奇数的情况。此时没有了对径边，但我们还是考虑延续上面的思路。称两条边是 **近对径** 的，如果将这两条边切去后，环上两边的点数只相差 $1$。可以发现，近对径的一对边有着类似对径边的性质：

- 一条最短路径不会同时经过这两条边，否则其长度就超过了总长度的一半，这是不合理的。
- 假如把这两条近对径边切去，圆环断裂成两个 **近半圆**。两个来自同侧半圆的点之间的最短路径不可能经过任意一条切掉的边；来自异侧半圆的点之间的最短路径必然经过某一条切掉的边。

考虑所有的近对径边对，注意到和对径边不同的是近对径边总共有 $k$ 对。我们把这 $k$ 对边上的棒子数总和加起来再除以 $2$，就是总代价了（因为每条边在两组近对径对里）。接下来我们考虑怎么方便地经过所有近对径对。下面给出一种方法：

![](https://cdn.luogu.com.cn/upload/image_hosting/c7rmujoz.png)

这里相邻的两组近对径边都只差一个元素，可以直接按前面提到过的方法 DP。时间复杂度也为 $O(k\times \binom{k}{\lfloor k/2\rfloor})$，可以通过本题。