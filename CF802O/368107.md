[【费用流】弱化版做法](https://www.luogu.com.cn/blog/_post/487050)。

备注：双倍经验 P4694。

结合这个要做 $x_0$ 道题的限制，考虑 $\tt wqs$ 二分。

---

我们设 $g(x)$ 为处理 $x$ 道题而非 $x_0$ 道的代价。

首先有 $g(0)=0$，然后它单调上升，它的导函数也是单调上升（下凸函数），这是 $\tt wqs$ 能使用的条件。

然后我们二分一个斜率 $k_0$，然后尝试计算 $f(x)=g(x)-k_0x$ 的最小值位置 $x_1$，然后看 $x_1$ 和 $x_0$ 的大小关系来判断答案会取在 $mid$ 的左还是右。

---

考虑 $f(x)=g(x)-k_0x$ 的意义是什么。做 $x$ 道题的代价减去 $x\times k_0$ 的代价，相当于做每道题的代价都减去 $k_0$。因为要 $f(x)$ 最大，相当于求“所有 $b_i\gets b_i-k_0$，最小代价是多少，此时做多少道题”。

因为要代价最小且减去 $k_0$ 后代价可能为负，我们自然而然认为把所有代价是负的题全都做了。

这个过程实现可以考虑贪心。我们制定这样一个策略：

1. 对于每一个 $b_i$ 找到 $\forall j\le i,\min\{a_j\}$。
2. 如果 $b_i+a_j\lt 0$，将其配对，并不允许“$a_j$ 再在后面的第 1 步中出现”。

当然实现可以考虑优先队列（小根堆），第一步就是 `top()`，第二步如果配对成功就是 `pop()`。

但是这种贪心存在不够优秀的情况。比如完成一组匹配时，为了达到最优抢走了另一组匹配唯一可选的点。

这种情况需要加一个反悔选项在优先队列里。考虑一组匹配带来 $a_j+b_i$ 的贡献，$a_j$ 此刻应该是有用的。我们考虑让 $a_j$ 和 $b_k$ 配，就等价于加上一个 $-b_i$ 和 $b_k$ 配的贡献。所以反悔的方法是在堆里加入 $-b_i$。

[评测链接](https://codeforces.com/problemset/submission/802/188556789)。