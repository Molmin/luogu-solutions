### 题目大意

一个 $w \times h$ 的矩形，给定 $n$ 个操作，每次给定参数 $a_i$ 、点     $x_i,y_i$ ，操作规则如下：

$1.a_i=1$ 时， $x<x_i$ 的区域将被涂黑；

$2.a_i=2$ 时， $x>x_i$ 的区域将被涂黑；

$3.a_i=3$ 时， $y<y_i$ 的区域将被涂黑；

$4.a_i=4$ 时， $y>y_i$ 的区域将被涂黑。

求没被涂黑的面积。

### 算法1

暴力枚举长方形并标记，最后统计一遍没被标记的点即可。

时间复杂度 $O(WHN)$ ，可以通过本题。

### 算法2

仔细思考一下，发现对于两次操作 $i,j$ ，如果 $a_i=a_j=1$ 且 $x_j<x_i$ ，则 $j$ 操作需要覆盖的面积已经被 $i$ 操作覆盖了，所以 $j$ 操作的时间完全可以省下来。

对于 $a_i=a_j$ 的其他三种情况也同理，所以我们就可以直接记录最大值和最小值即可。

#### 划重点！

因为去掉的是四周，所以最终的部分一定是一个在中间的长方形。

当 $a_i=1$ 时，覆盖的是 $x_i$ 左边，所以 $x_i$ 越大，覆盖的越多。也就是说，我们对于 $a_i=1$ 的情况，只需要取 $\max(x_i)$ 即可，这就是最终剩余长方形的左边界。

当 $a_i=2$ 时，覆盖的是 $x_i$ 右边，所以 $x_i$ 越小，覆盖的越多。也就是说，我们对于 $a_i=2$ 的情况，只需要取 $\min(x_i)$ 即可，这就是最终剩余长方形的右边界。

当 $a_i=3$ 时，覆盖的是 $y_i$ 上边，所以 $y_i$ 越大，覆盖的越多。也就是说，我们对于 $a_i=3$ 的情况，只需要取 $\max(y_i)$ 即可，这就是最终剩余长方形的上边界。

当 $a_i=4$ 时，覆盖的是 $y_i$ 下边，所以 $y_i$ 越小，覆盖的越多。也就是说，我们对于 $a_i=4$ 的情况，只需要取 $\min(y_i)$ 即可，这就是最终剩余长方形的下边界。

综上所述，最终长方形的长为 $\min(x_i)(a_i=2)-\max(x_i)(a_i=1)$ ,宽为     $\min(y_i)(a_i=4)-\max(y_i)(a_i=3)$ 。将两数相乘即为最终剩余长方形的面积。

#### 温馨提示

长和宽可能存在负数，要特判变为 $0$ ，因为题面的某些问题，样例输出为$0$时不显示。

**注意：$x_{min},y_{min}$ 必须初始化为 $w,h$ ，否则会 $WA$**。

最终时间复杂度 $O(n)$ 。

#### code

```cpp
#include<bits/stdc++.h>
using namespace std;
int w,h,n,a,x,y,xmax,xmin,ymax,ymin;
int main()
{
    cin>>w>>h>>n;
    xmin=w,ymin=h;
	for(int i=1;i<=n;i++)
	{
        cin>>x>>y>>a;
        if(a==1)
            xmax=max(xmax,x);
        if(a==2)
            xmin=min(xmin,x);
        if(a==3)
            ymax=max(ymax,y);
        if(a==4)
            ymin=min(ymin,y);
    }
    if(xmax>xmin || ymax>ymin)
		cout<<0;
    else
        cout<<(ymin-ymax)*(xmin-xmax);
    return 0;
}
```