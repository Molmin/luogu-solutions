~~自认为写的还好，应该能看懂。~~

### 题意：
求最小的把字符串$S$分割成若干个互不相交的回文子串的个数。



#### Step $1$：列状态转移方程。
考虑$DP$，设 $p[ i ]$ 为前$i$个字符中划分的最小回文子串的个数，对于每一个$i$，会出现两种情况：

$1.$ $s[ i ] $为一个单独的回文子串，此时 $p[ i ] = p[ i - 1 ] +1 $。因为新划分了一个回文子串，所以$ p[ i ]$ 为前 $i - 1$ 个字符的最优值$+1$。

$2.$ $s[ i ] $与其他字符组成了一个回文子串，此时 $p[ i ] = p[ j - 1 ] + 1$。$j $为这个回文子串的左端。那么~~显然~~ 前 $j - 1$ 个字符的最优值加上新划分的回文串就是$ p[ i ]$ 的值。


~~建议动手模拟一下。~~

理解上面这些，应该就能切掉这道题了。不过，我们还没有想好如何判断 $s[ i , j ]$是否回文呢！

#### Step $2$： 判断字串回文。

刘汝佳大神的紫书上已经介绍了中心扩展法，让我们试一下动态规划，那我们就用动态规划。

设 $f[ i ][ j ] $表示字串$ s[ i ][ j ] $是否回文，是为$true$，否则为$false$。那么这个方程该是比较好想的了，即

$f[i][j]=\left\{\begin{matrix}f[i+1][j-1] & (s[i]=s[j])\\ 0 & (s[i]\neq s[j])\end{matrix}\right.$

初始状态为 
$\left\{\begin{matrix}f[i][i]=1& \\ f[i-1][i]=1& (s[i-1]=s[i])\end{matrix}\right.$


### code

```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
    int t,n,p[1001];
    bool f[1001][1001];
    string s;
    cin>>t;
    while(t--)
    {
        cin>>s;
        n=s.size();
        s=' ' + s;
        memset(f,0,sizeof(f));//多测试数据时记得清空
        memset(p,0,sizeof(p));
        for(int i=1;i<=n;++i)
        {
            f[i][i]=true;
            f[i-1][i]=(s[i-1]==s[i]);
        }
        for(int j=2;j<=n;++j)
        {
            for(int i=1;i<j-1;++i)//枚举长度大于等于三的字串，还能防止下标越界
            {
                if(s[i]==s[j])//相同
                    f[i][j]=f[i+1][j-1];
                else f[i][j]=false;//不同
            }
        }
        for(int i=1;i<=n;++i)
        {
            p[i]=p[i-1]+1;//假设没有回文串与其匹配，可以理解为赋初值
            for(int j=1;j<i;++j)//枚举j，判断能不能让子串s[i,j]回文
                if(f[j][i])
                    p[i]=min(p[i],p[j-1]+1);                 
        }
        cout<<p[n]<<endl;
    }
    return 0;
}

```
时间复杂度与空间复杂度均为$O(N^{2})$~~吧~~

你以为到这就完了吗？~~确实~~不，你还没有点赞！

若有错误请多多指教。

UPD1:修改了部分笔误，丰富了代码注释。
