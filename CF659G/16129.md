$F[i][j]$表示前 i 列且第i 列保留 j 高度的方案数。

怎么转移？
我们可以发现保留 j 高度的木板，它上面的木板一定已经被砍掉了，所以可以只通过前 i-1 列转移过来。

那么第i-1列砍掉部分是否可以与第i列砍掉的部分相连？分类讨论：

 ①$h[i-1]<=j$ , 第i-1列的高度都达不到第i列被砍掉的高度，这种情况不能转移。 F[i][j]+=0;

②$h[i-1]>j$   第i-1列砍掉的高度将会大于第i列保留的高度。此时F[i][j]+=$\sum_{k=1}^{min(h[i-1]-1,h[i]-1)}F[i-1][k]$
 
初始化：$F[i][j]=1 (1<=i<=n,1<=j<h[i]) $表示仅砍掉这一列，且只保留j的木板时的方案数，显然是1。

那么用ans来记录最终答案，就是：

$ans=sigma(F[i][j]) (1<=i<=n,1<=j<h[i])$

显然$F[i-1][k]$可以用前缀和来记录，所以时间复杂度可以优化到$O（NH）$
又因为dp方程只有上一维更新过来，所以可以用滚动数组或者直接删除第一维，来优化空间

```cpp
for(register int i=1;i<=n;++i){
        for(register int j=1;j<=h[i]-1;++j){
            if(i==1) f[i][j]=1;
                else if(h[i-1]<=j) f[i][j]=1;
                    else {
                        f[i][j]=1;
                        f[i][j]=(f[i][j]+g[i-1][min(h[i-1]-1,h[i]-1)])%mod;
                    }
            g[i][j]=(g[i][j-1]+f[i][j])%mod;
            ans=(ans+f[i][j])%mod;
        }
    }
    printf("%d",ans%mod)
```


但是这样写只能过3个点。

考虑一下特殊情况，每个木板高度相等时，记为H。
只取走第i列的方案数为 （H-1）

取一个区间 L 到 R ，强制其中每块木板都要有部分被砍，则方案数为$(H-1)^{(R-L+1)}$  ，因为其中每一列都有$（H-1）$的方案数，且共有$(R-L+1)$列。

所以总方案数就是枚举区间长度k，并且求和就可以了，用ans记录最终答案：

ans=$\sum_{k=1}^{n}((H-1)^{k}*(n-k+1))$

特判hi相同的情况，可以用快速幂处理一下，发现多AC了7个点，也就是说有7个点是这种特殊情况......（好水）

现在来看一般情况

因为题目要求至少保留1的高度，那么我们将所有的hi减一

根据上面的特殊情况，我们来枚举区间。取区间L到R，求这个区间每一列都必须有被砍的部分的方案数。第L列（左端点）被砍的话要与第L+1列连接起来，则其方案数为min($h\tiny{L}$ , $h\tiny{L+1}$ )

L<i<R 时，第i列被砍的要与第i-1列和第i+1列连接起来，则其方案数为min($h\tiny{i-1}$ , $h\tiny{i}$ , $h\tiny{i+1}$)

所以区间L到R方案数为$(\prod_{i=L+1}^{R-1}min(h\tiny{i-1}$ , $h\tiny{i}$ , $h\tiny{i+1}$))+$min($$h\tiny{L}$ , $h\tiny{L+1}$ )+$min($$h\tiny{R}$ , $h\tiny{R-1}$ )

同样我们可以枚举所有区间来求得总方案数，时间复杂度为O($n^{2}$)，显然会TLE

看了看数据范围，$hi$<=1e9。直觉告诉我们hi不能加入dp维度。这要么是一个O(N)的dp要么是个矩阵优化。

首先排除矩阵优化，F[i]表示前i列且强制第i列要有被砍的部分的方案数。

归纳上述公式，可得$F[i]=min(h[i],h[i-1])*F[i-1]+h[i]$
 
其中加上$h[i]$是表示前$i-1$列不被砍，只有第i列被砍的方案数。

想一想，这个转移方程是不是有不妥之处？

显然，我们并不知道$h[i+1]$的情况，也就是说$F[i+1]$T 中记录的方案数，可能包含了第i列只砍了第i+1列的高度的以上的部分，两列砍的部分不能连接，这样会多记不合法方案数。换句话说，这个dp方程$F[i]$不能用来直接更新$F[i+1]$

要想获得$F[i+1]$正确值，只需要知道在计算$F[i]$时，第$i+1$列是否有被砍的部分。并不需要获得第$i+1$列被砍的具体情况,如果有被砍的部分，第$i$列必须与第$i+1$列连接，而如果没有，就只要与第$i-1$列连接起来就行了。

那么我们可以再加一维，以添加转移的限制。$F[i][0/1]$ , 0表示第$i+1$列不砍，1表示第$i+1$列必须砍，这个dp状态同样表示了前$i$列且第$i$列必须砍的方案数，只不过添加了第$i+1$列的状态。

	初始化：F[1][1]=min(h[1],h[2]);F[1][0]=h[1];

	转移：F[i][1]=min(h[i],h[i+1])+min(h[i],h[i+1],h[i-1])*F[i-1][1]

	其中min(h[i],h[i+1])表示只砍第i列的方案数

	F[i][0]=h[i]+min(h[i],h[i-1])*F[i-1][1]

	其中h[i]表示只砍第i列的方案数

	ans=sum(F[i][0]) 1<=i<=n

```cpp
#include<iostream>
#include<cstdio>
using namespace std;
const long long mod=1e9+7;
long long n,ans;
long long h[1000100];
long long f[1000100][2];
int main(){
    scanf("%lld",&n);
    for(register int i=1;i<=n;++i){
        scanf("%lld",&h[i]);
        h[i]--;
    }
    f[1][1]=min(h[1],h[2]);
    f[1][0]=h[1];
    ans=(ans+f[1][0])%mod;
    for(register int i=2;i<=n;++i){
        f[i][1]=((min(h[i],min(h[i-1],h[i+1]))*f[i-1][1])%mod+min(h[i],h[i+1]))%mod;
        f[i][0]=(min(h[i],h[i-1])*f[i-1][1]+h[i])%mod;
        ans=(ans+f[i][0])%mod;
    }
    printf("%lld",ans);
    return 0;
}
```
