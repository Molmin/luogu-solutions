# CF1618A Polycarp and Sums of Subsequences 题解
[题目传送门](https://www.luogu.com.cn/problem/CF1618A)
## 题意简述
现在有 $3$ 个数 $a$、$b$ 和 $c$，已知序列 $A$ 中存了 $\{a,b,c,a+b,a+c,b+c,a+b+c\}$ 共 $7$ 个数，但是顺序可能是乱的，求 $a$、$b$ 和 $c$ 三个数分别是多少。
## 题目分析
实际上解法非常简单。不过不要想着输出前三小的数就行了，因为样例里的第 $4$ 个测试数据会卡掉这个想法。

首先我们看题目要问的第一个数。假设它是题目要问的三个数中最小的（实际上输出的时候按照怎样的顺序输出三个数都行）。如果这个数不是 $A$ 中最小的，就不可能有另外两个正整数的和或另外一个数比它更小，否则这些数是无法被 $a$、$b$ 和 $c$ 表示出来的。因为 $1\leq A_i\leq10^9$，而 $a$、$b$ 和 $c$ 三个数也在其中，所以这三个数也满足这个限制。所以说，**第一个数一定是 $A$ 中最小的数**。

然后再看题目要问的第二个数。假设它是题目要问的三个数中第二小的。如果这个数不是 $A$ 中第二小的，那么依然无法找到另外两个数的和或另外一个数比它更小（最小的数除外）。所以**第二个数一定是 $A$ 中第二小的数**。

最后看第三个数。我们会发现，在样例里的第 $4$ 个测试数据说明，前面两个数之和有可能依然小于题目需要求的 $c$。但是没有办法使第三个数成为第五小的数。所以**第三个数一定是 $A$ 中第三或第四小的数**。所以我们可以判断一下，到底第三个数是不是 $A$ 中第三小的数。
## 代码实现
```cpp
#include<algorithm>
#include<cstdio>
using namespace std;
int t,a[10];
int main(){
	scanf("%d",&t);
	while(t--){
		for(int i=1;i<=7;++i) scanf("%d",&a[i]);
		sort(a+1,a+1+7);
		if(a[1]+a[2]==a[3]) printf("%d %d %d\n",a[1],a[2],a[4]);
		else printf("%d %d %d\n",a[1],a[2],a[3]);
	}
	return 0;
}
```