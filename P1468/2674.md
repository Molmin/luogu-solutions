/\*
ID: ylx14274

PROG: lamps

LANG: C++

\*/

```cpp
#include<set>  
#include<map>  
#include<list>  
#include<queue>  
#include<stack>  
#include<string>  
#include<math.h>  
#include<time.h>  
#include<vector>  
#include<bitset>    
#include<utility>  
#include<stdio.h>  
#include<sstream>  
#include<iostream>   
#include<string.h>  
#include<algorithm> 
#define LL unsigned long long   
using namespace std;
int n,c,i,j;//c：计数器君，n：灯的盏数
int l[101];//最后灯的状态,-1为不作要求，1为亮，0为灭 
int f;//标记有没有解，无解为0 
int b[9][7]=//华丽的表 
{0,0,0,0,0,0,0,  
    0,0,0,0,0,0,0,//按1  
    0,0,0,1,1,1,0,//按1按4  
    0,0,1,0,1,0,1,//按3  
    0,0,1,1,0,1,1,//按1按4  
    0,1,0,0,1,0,0,//按4  
    0,1,0,1,0,1,0,//按2  
    0,1,1,0,0,0,1,//按2按4  
    0,1,1,1,1,1,1,};//不按  注意顺序！ 
//int s[9]={0,1,1,1,1,2,2,2,0};//达到对应的某种状态最少需要按的次数 
int main() 
{
    scanf("%d%d",&n,&c);
    i=0;
    int x;
    for (i=1;i<=6;i++) l[i]=-1;
    scanf("%d",&x);//读入
    while (x!=-1)
    {
        if ((x%6)==0) l[6]=1;//标记
        else l[x%6]=1;//标记 ，全部映射到1~6中 
        scanf("%d",&x);//读入 
    }
    scanf("%d",&x);//读入
    while (x!=-1) 
    {
        if ((x%6)==0) l[6]=0;//标记
        else l[x%6]=0;//标记 ，全部映射到1~6中 
        scanf("%d",&x);//读入 
    }
    //-------------------读入完毕-------------------//
    if (c>=4) c=3;//反正3以上所有方法都可行 
    switch (c)
    {
        case 0://什么都不按 ,别忽略，有2个点 
        {
            for (i=8;i<=8;i++)//只有不按 
                {    
                    int ah=1;//标记用 
                    for (j=1;j<=6;j++)
                    {
                        if (l[j]!=-1)//对这一位有做要求 
                            if (b[i][j]!=l[j])
                            {
                                ah=0;//标记
                                break; 
                            }
                    }
                    if (ah==1)//这种情况符合条件 
                    {
                        f=1;//标记 
                        for (j=1;j<=n;j++)
                            printf("%d",b[i][(j-1)%6+1]);
                        printf("\n");
                    }
                }
                break;
        }
        case 1:
            {
                for (i=1;i<=8;i++)//前四种都可以有 
                {    
                    if (i!=1||i!=3||i!=5||i!=6) continue; 
                    int ah=1;//标记用 
                    for (j=1;j<=6;j++)
                    {
                        if (l[j]!=-1)//对这一位有做要求 
                            if (b[i][j]!=l[j])
                            {
                                ah=0;//标记
                                break; 
                            }
                    }
                    if (ah==1)//这种情况符合条件 
                    {
                        f=1;//标记 
                        for (j=1;j<=n;j++)
                            printf("%d",b[i][(j-1)%6+1]);
                        printf("\n");
                    }
                }
                break;
            }
        case 2:
            {
                for (i=1;i<=8;i++)//除开4都可以 
                {    
                    if (i==5) continue; 
                    int ah=1;//标记用 
                    for (j=1;j<=6;j++)
                    {
                        if (l[j]!=-1)//对这一位有做要求 
                            if (b[i][j]!=l[j])
                            {
                                ah=0;//标记
                                break; 
                            }
                    }
                    if (ah==1)//这种情况符合条件 
                    {
                        f=1;//标记 
                        for (j=1;j<=n;j++)
                            printf("%d",b[i][(j-1)%6+1]);
                        printf("\n");
                    }
                }
                break;
            }
        case 3:
            {
                for (i=1;i<=8;i++)//都可以 
                {    
                    int ah=1;//标记用 
                    for (j=1;j<=6;j++)
                    {
                        if (l[j]!=-1)//对这一位有做要求 
                            if (b[i][j]!=l[j])
                            {
                                ah=0;//标记
                                break; 
                            }
                    }
                    if (ah==1)//这种情况符合条件 
                    {
                        f=1;//标记 
                        for (j=1;j<=n;j++)
                            printf("%d",b[i][(j-1)%6+1]);
                        printf("\n");
                    }
                }
                break;
            }
    } 
    if (f==0) printf("IMPOSSIBLE\n");//无解 
    return 0; 
}
```
以下分析来自NOCOW.//我觉得这个分析比我自己描述得好多了

分析

每个按钮按2次和没按效果是一样的。所以每个按钮或者按或者不按，一共有2^4=16种状态。枚举每个按钮是否按下，然后生成结果，排序输出即可（注意判重）。


另外灯1和灯7,2和8,3和9…是一样的因此当N>=6时只需处理前6个,排序时转换为10进制数, 输出时反复输出前6个的状态.


深究：


我们现在记不按按钮，以及按下1，2，3，4按钮分别O，①，②，③，④， 那么，按下3，4，可以记为③④，以此类推， 我们发现一个问题，那就是①，②，③之间微妙的关系， ①②=③，而②③=①，①③=②（可以自己试试），于是我们知道，①②③也相当与不按，即相差3的倍数也可互相转换；

所以，所谓前四个的16种按法其实只有8种， 分别为：O,①，②，③，④，①④，②④，③④；

然后讨论c， 由于当c>4时，均可化为当c<=4的情况， 所以我们先讨论当c<=4的情况，


当c=0时，只有一种O；


当c=1时，四种：①，②，③，④；


当c=2时，除了④均可（可以自己想想）；


当c=3时，由于3-1=2，所以c=1的情况都满足，而在c=2中，把所有有前三类的展开，如①④变为②③④， 可知满足c=2的同时满足c=3，所以c=3其实是c=2和c=1的并集，即所有按法均可。


当c=4时，由于4-1=3（①②③相当于不按），且4-2=2，由上，c=4也是所有按法均可。

当c>4时，我先有一个引理：对于任意的正整数n>1，均可写成n=2\*p+3\*q(p,q为非负整数）的形式， 证明如下：若n为偶数，必然成立，若n为奇数，必然大于2，则n-3必为非负偶数，得证。 由这个引理我们可以知道，任意c>4均可写成，c=2\*p+3\*q+3(p,q为非负整数）的形式，而可知， 对于两个相同的按键，以及情况①②③（按键三次），均相当于不按，所以任意c>4均可化归为c=3的情况， 即当c>4时，所有按法均可。


综上所述，


当c=0时，只有一种O；


当c=1时，四种：①，②，③，④；


当c=2时，除了④均可；


当c>2时，所有按法均可。


好了，这样一来就非常简单了， 只有四种情况，8种按法。


于是我们就可以打个表了。打表也要注意下顺序。
