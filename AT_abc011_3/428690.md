[题目传送门](https://www.luogu.com.cn/problem/AT916)

### 思路

**$dp$ 问题**

题目大意就是给定一个数字 $n$ 你可以对他减去 $1,2,3$ 里面的任意一个数字，只需要满足在操作过程中 $n$ 不等于题目中说明的三个数,最后如果可以使得 $n$ 等于 $0$ 就输出 `YES`，如果不能使得 $n$ 等于 $0$ 就输出 `NO`。

读完题目之后，我想到了 $dp$ 的做法。

**我们先定义状态** 令 $dp[i][j]$ 表示第 $i$ 个数至多操作 $j$ 次能否等于 $0$。如果能，$dp[i][j]=1$，如果不能，$dp[i][j]=0$。

**接着确定初始值** 很显然，我们可以确定当 $i$ 在 $3$ 以下，且保证题目中给定的三个数不等于 $i$ 的时候，$dp[i][j]=1,0<i<4$ 且 $0<j<100$，
且 $dp[0][0]=1$。

**接着就是状态转移** 先枚举 $i$ 从 $4$ 枚举到 $n$ (因为已经确定了 4 以前的状态转移了)。

如果 $i$ 等于题目中给定的三个数，则我们就不执行 $j$ 这一层循还。

如果不等于题目中给定的三个数，我们就执行 $j$ 这一层循环 从 $1$ 枚举到 $100$ (他之多可以操作 100 次)。

则对于 $dp[i][j]$ 共有四种情况:

**$1.$** 即 $i$ 运用 $j-1$ 次操作就可以等于 0 了。

状态转移为: $dp[i][j]\gets dp[i][j]|dp[i][j-1]$

**$2.$** 即 $i$ 通过 $-1$ 这个操作来接近 0。

状态转移为: $dp[i][j]\gets dp[i][j]|dp[i-1][j-1]$

**$3.$** 即 $i$ 通过 $-2$ 这个操作来接近 0。

状态转移为: $dp[i][j]\gets dp[i][j]|dp[i-2][j-1]$

**$4.$** 即 $i$ 通过 $-3$ 这个操作来接近 0。

状态转移为: $dp[i][j]\gets dp[i][j]|dp[i-3][j-1]$

**最后就是输出答案** 只要最终的 $n$ 至多操作 $100$ 次可以等于 0 就输出 `YES`。

即如果 $dp[n][100]=1$ 输出 `YES`。

如果 $dp[n][100]=0$ 输出 `NO`


### 代码

```cpp
#include<iostream>
using namespace std;
int n,p1,p2,p3;
int dp[305][305];
int main()
{
    cin>>n>>p1>>p2>>p3;
    if(n==p1||n==p2||n==p3)
    {
        cout<<"NO"<<endl;//如果n等于三个数中的一个,输出NO
        return 0;
    }
    //初始值
    dp[0][0]=1;
    for(int j=1;j<=100;++j)
    {
        dp[0][j]=1;
        dp[1][j]=1;
        dp[2][j]=1;
        dp[3][j]=1;
    }
    for(int i=4;i<=n;++i)
    {
        if(i==p1||i==p2||i==p3)//如果i等于三个数中的其中一个,则不执行j这一层循环
            continue;
        for(int j=2;j<=100;++j)
        {
            //状态转移
            dp[i][j]|=dp[i][j-1];
            dp[i][j]|=dp[i-1][j-1];
            dp[i][j]|=dp[i-2][j-1];
            dp[i][j]|=dp[i-3][j-1];
        }
    }
    //判断是否可行
    if(dp[n][100]==1)
    {
        cout<<"YES"<<endl;
    }
    else
    {
        cout<<"NO"<<endl;
    }
}

```