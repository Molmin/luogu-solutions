## 题解 [P1185 绘制二叉树](https://www.luogu.com.cn/problem/P1185)
~~优化初始化后居然勉强挤到了最优解第一~~刚好来写篇题解。

### 思路分析
----
由题目可以知道所需要的二叉树是在满二叉树的基础上删除子树的，因此我们可以考虑满二叉树的性质，无需任何额外工序建树，并使用类似写堆时候的`p<<1`和`p<<1|1`表示左右子树，通过数值运算达到$O(1)$删树。

再由样例我们可以知道，题目要求输出多余空格，而数据范围也不是很大，因此可以基本确定下来绘制时是在空格基础上替换字符。

最后再通过一遍$\text{dfs}$遍历绘制图形，再输出即可。（数据稍微再大一点的话或许可以考虑$\text{bfs}$，边绘边输出）

### 具体实现
----
首先要确定画布大小，考虑满二叉树时的最底下一行。观察样例及由题意，当树有$m$层时，如果我们把最下方两层节点$3$个节点的子树分离出来，看作这些树构成的森林，则共有$2^{m-2}$棵树（即第$m-1$层节点数），每棵宽度$5$个字符，再加上$2^{m-2}-1$个分隔的空格，一共$5\times(2^{m-2})+(2^{m-2}-1)$即$6\times2^{m-2}-1$个字符，即为画布宽度。同时克制最上一行树根的位置为画布宽度的一半，在字符串中刚好是$line[6\times2^{m-2}-1]$。再由第$m$行第$1$个节点的路径（正方形对角线），我们可以知道画布高度是宽度加一的一半，即$3\times2^{m-2}$。

![手残作图见谅](https://cdn.luogu.com.cn/upload/image_hosting/dlyusdq6.png)

然后在删树时考虑标记节点的左/右儿子为删除（当然直接标记节点，调整遍历时绘制顺序也可以）。画个图可知题目所给表示方法中第$a$行$b$个节点对应直接标记的$2^{a-1}+\left\lfloor\frac{b-1}2\right\rfloor$号节点（前$a-2$层$2^{a-1}-1$个，父亲所在层连父亲$\left\lceil\frac{b-1}2\right\rceil$个），$b$为奇数的作为父亲的左儿子，$b$为偶数的作为父亲的右儿子，可直接标记。

最后遍历时，要确定边的长度，同理上面提到“正方形对角线”的思路（或者将边平移成竖直的线），易知其长度是画布高度减去子树画布高度。考虑到每层子树所在部分画布中$y$位置唯一确定，再从每层第一个节点（最左边一条树链）的特殊情况出发，可以根据上面的关系最终将其转化为总画布高度减去子树根节点$y$坐标整体的一半（详见代码）。然后直接遍历绘出、输出即可，不过需要注意、容易写出问题的是还是边界的确定。

### 代码
----
（其实这段代码忽略了符合题意的删树根的情况（会RE），但居然过了emmmm，不过也只需加个特判就行（或者上文提到的遍历绘制顺序））
```cpp
#include<iostream>
#include<cstring>
using namespace std;
int m,n,len,lend2;//n、m、画布宽度及宽度除以二
char line[3*(1<<9)][6*(1<<9)];//保险起见以及字符串终止\0标记，大一点
bool del[(1<<9)+1][2];
void dfs(int y,int x,int p)
{
	//cout<<y<<' '<<x<<endl;
	line[y][x]='o';
	if(y+1>=lend2)
		return;
	int t=(lend2-y)/2+1;
	if(!del[p][0])
	{
		for(int i=1;i<t;i++)
			line[y+i][x-i]='/';
		dfs(y+t,x-t,p<<1);
	}
	if(!del[p][1])
	{
		for(int i=1;i<t;i++)
			line[y+i][x+i]='\\';
		dfs(y+t,x+t,p<<1|1);
	}
}
int mian()
{
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);
	cin>>m>>n;
	len=(1<<(m-2))*6-1;
	lend2=len/2;
	for(int i=0,a,b;i<n;i++)
		cin>>a>>b,
		del[((1<<(a-2))+(b-1)/2)][(b&1)^1]=1;
	memset(line,' ',sizeof(line));//可优化为按需初始化
	dfs(0,lend2,1);
	for(int i=0;i<=lend2;i++)
		line[i][len]=0,//截断字符串
		cout<<line[i]<<'\n';
	return 0;
}
```

終わり