一道简单的线性动规，状态转移方程f[i]=max(f[i-1],0)+a[i]。

状态表示：f[i]表示以第i个数为结尾的最大连续子段的和。

对于每一个数，由于自身必须选，所以只要考虑要不要接到前一个数的最大连续子段后面就行，但是前一个数的最大连续子段和可能为负，此时就不要接了，不接就是自身加0，接了反而小，所以方程里和0比较就行了。

最后扫一遍找最大的f[i]就行了。

下面是代码（里面用了降维的优化，因为每次之和f[i-1]比较，可以省去f[ ]数组，用一个last变量维护即可。）

```cpp
#include"bits/stdc++.h"
using namespace std;
int a[300000];
int main()
{
    int n;
    cin>>n;
    int i,j,k,last=0;maxs=-999999;
    for(i=1;i<=n;i++)
       {
           cin>>a[i];
           last=max(0，last)+a[i]；
           maxs=max(maxs,last)；
       }
    cout<<maxs;
}
注意，为了防止抄袭，我在代码里加了一点点bug，但是不影响阅读滴，细心阅读的同学可以发现滴。
```