#思路：DP（其实好像是贪心QWQ）

这道题其实是练习DP的入门题（本蒟蒻也才刚刚学DP）

首先，通过题意，我们可以了解到：

**f[i]=max(f[i-1]+n[i],n[i])**

**但是！**

**f[n]的值并不一定是最终结果**

比如这个输入：

5
233 233 -666 1 1

如果直接输出f[n]的值，结果会是2，但是答案应该为466！

为什么？

因为若f[i]的值为负数，则f[i+1]的值就是n[i],而n[i]的值不一定比前面的最大字段和数大！

（或者n[i]为负数，则f[i]小于f[i-1]!)

所以，我们还要再用一个数从1到n再查找一次，才能找出最大数！！！

代码（时间复杂度大概是O(n）？算了，反正我也不晓得）：

```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
    int n[200001],p,ans[200001]={0};
    int sum=-9999999;//|x|<=10000   QWQ
    cin>>p;
    for(int i=1;i<=p;i++)
    {
        cin>>n[i];//输入
        ans[i]=max(ans[i-1]+n[i],n[i]);//DP
        sum=max(sum,ans[i]);//取最大值也同时进行，节约时间
    }
    cout<<sum;//直接输出
    return 0;
}
```