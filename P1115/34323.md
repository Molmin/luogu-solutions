忙人请跳过分割线内的内容

--------------------------------------------------------（完美的分割线~）

交了三次，一次在机房没做完存储……

搞了半天才发现c++自带min和max函数QAQ

吃完饭才写完的程序和题解，超困的  = =

（中午没来得及写完，实际是下午自习写的~）

所以……题解求过~~

--------------------------------------------------------（下方正文~）

不知道会不会有一样的思路（似乎是有的……）

但是我还是……要（zuo）！写（si）！题！解！

a数组是储存输入的数值~

c[i]表示的是a数组从头加到i的和~

b[i]表示的是从头到i包括i的的最大子段和~（必须包括i！！！）

minn储存最小的前缀和（因为要减去所以要尽量小，详情见下一行）~

动态转移方程式：b[i]=c[i]-minn（总和减去前缀和）~

mann是最后输出b数组最大的值（题目求最大的子段和）~

--------------------------------------------------------（划重点！！！）

minn一定要初始化成0！！！

如果设成a[1]会死……（如果是正数会减去正数，正解是不减，就是没有减去的子段和）

相反mann要设成很小的值！！！（废话）

--------------------------------------------------------（代码分割线）

```cpp
#include<iostream>
using namespace std;
int n,a[200001]={0},b[200001]={0},c[200001]={0},minn=0,mann=-99999;
int main()
{
    cin>>n;
    for(int i=1;i<=n;i++)
    {
        cin>>a[i];
        c[i]=c[i-1]+a[i];
    }
    b[1]=a[1];minn=min(0,c[1]);
    for(int i=2;i<=n;i++)
    {
        b[i]=c[i]-minn;
        minn=min(minn,c[i]);
    }
    for(int i=1;i<=n;i++) mann=max(mann,b[i]);
    cout<<mann<<endl;
}
```