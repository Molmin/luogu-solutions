/\*
P1115 题解

动态规划的应用


思路：

如何进行动态规划？

好的，我们先看一下样例：

$input:$

2 -4 3 -1 2 -4 3

$output:$

4

很显然，取3 -1 2这一段是最优解。

那么，我们假设$f[i]$为结尾在第$i$个格子的最优解，用$a$数组来表示这些数（即$a[i]$表示这个集合中的第$i$个数），那么很显然，答案就是$f[n]$。


不难发现，如果我们在第$i$个格子，那么我们可以选择在第$i-1$个格子的最优解+第$i$个格子的值，或第$i$个格子的值或$0$。

那么得到结论：

$f[1]=a[1]$，并且如果$a[i]>=0$，那么：$f[i]=f[i-1]+a[i];$

否则：$f[i]=max(0,f[i-1]+a[i]);$

（$i>=2$）。

将其简化后得到：

$f[i]=max(0,max(f[i-1]+a[i],a[i]));$

（$i>=1$）。

但是如果输入的数据全是负数怎么办呢？

所以我们还要再加上一个特判，就是当输入的数据全是负数的时候输出最小的那个负数（因为选的区域不能够为$0$）。

所以特判部分如下：

```cpp
for(int i=1;i<=n;i++)
{
    scanf("%d",&a[i]);
    jl=max(jl,a[i]);
    dq=max(dq,a[i]);
}
if(jl==-1)
{
    printf("%d",dq);
    return 0;
}
```
那么，我们现在再整理一下结论：
那么得到结论：

$f[1]=a[1]$，并且如果$a[i]>=0$，那么：$f[i]=f[i-1]+a[i];$

否则：$f[i]=max(0,f[i-1]+a[i]);$

（$i>=2$，且当$a$数组内至少有一个正整数或$0$时成立）。

将其简化后得到：

$f[i]=max(0,max(f[i-1]+a[i],a[i]));$

（$i>=1$，且当$a$数组内至少有一个正整数或$0$时成立）。


下面上AC代码：

\*/
```cpp
#include <cstdio>
int f[1000001],a[1000001];
int max(int x,int y)
{
    return x>y?x:y;
}
int main()
{
    int dq=-999999999,jl=-1,ans=0,n=0;
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
    {
        scanf("%d",&a[i]);
        jl=max(jl,a[i]);
        dq=max(dq,a[i]);
    }
    if(jl==-1)
    {
        printf("%d",dq);
        return 0;
    }
    for(int i=1;i<=n;i++)
    {
        f[i]=max(0,max(f[i-1]+a[i],a[i]));
    }
    for(int i=1;i<=n;i++)
    {
        ans=max(ans,f[i]);
    }
    printf("%d",ans);
    return 0;
}
```