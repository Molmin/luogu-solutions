两个方法

方法1：贪心

可以发现必须是正数才有的赚，如果是负数还死皮赖脸加那肯定不如舍弃负数来得赚

途中如果发现累加的和超过了最大值就更新

框架
for i in range(1,n)

如果是负数那么舍弃负数（因为舍弃掉两端的负数最大值只会加而不会减）

累加（将当前值加入累加器）

如果累加器中的值超过了目前所知的最大值那么更新维护最大值

贴贪心代码






```cpp
#include<cstdio>
const int maxn=200000+50;
using namespace std;
int a[maxn],n,sum,max;
void init()
{
    scanf("%d",&n);
    for(int i=1;i<=n;++i)
        scanf("%d",&a[i]);//读入 
}
void solve()
{
    sum=0; max=-1000000;
    for(int i=1;i<=n;++i)//1到n扫一遍 
    {
        if (sum<0) sum=0;//如果是负数舍弃负数
        sum+=a[i];//累加 
        if (sum>max) max=sum;//迭代更新最大值 
    }
}
void print()
{
    printf("%d",max);//输出 
}
int main()
{
    init();
    solve();
    print();
    return 0;
}
```
/\*
这个代码的结构值得借鉴，听说dalao们都是这么写的，我也这么写一次

\*/

方法2：DP

仔细一想这题还有DP的算法，dp[i]是到i为止的最大值

决策：

1.累加

2.舍弃掉前面的

有了阶段和决策，我们就可以开始写状态方程了

f[i]=max(a[i],f[i-1]+a[i])//前者是舍弃掉前面的，后者是累加

代码不贴，提示：边界条件f[1]=a[1]


拓展：分治算法（本段参考百度百科）

本人也是偶然听说，在此做个简单分析

设a[1:n]为1到n的最大子序列和，考虑它的两个子问题a[1:n/2]以及a[n/2+1:n]，有三种情况

1.a[1:n]的最优解是前面半段的最优解

2.a[1:n]的最优解是后面半段的最优解

3.a[1,n]的最优解横跨两个半段

首先确定递归的边界，也就是子问题足够小（一个数字），如果是正数，取了一定赚，如果是负数，取了一定亏

如果问题还不够小，那么我们要进行分治，先计算两半的最优解，然后进入“治”阶段，将两段的解和在一起

前两种情况可以递归，第三种情况就分别求，这种方法我只是在这里说一下，详情请询百度百科-最大子段和

喵，就是这样
