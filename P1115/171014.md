**单调队列入门题**（虽然标签里没有$\colorbox{red}{\color{white}\text{单调队列}}$）
***
>单调队列是就有单调性的队列，有单调递增和单调递减两种，一般来讲，队列的队首是整个队列的最大值或最小值(~~废话~~)  
>作用：
>>可以求出一段数列内第一个大于等于一个数x的数,也可以通过维护单调性，解决一些区间内最小或最大的问题  

>实现：
>>可以用$STL$的$deque$，也可以手写数组（个人比较喜欢用手写数组，用$STL$的话有好多‘.’啊，‘()’啊）

***
栗子

7  
7 6 8 12 9 10 3   
求最大值

$i=0$，队列初始化0，队列为{0}  
$i=1$，因为$7>0$，所以7入队，0出队（要维护这个队列单调递减），队列为{7}  
$i=2$，因为$6<7$，所以6入队，队列为{7，6}  
$i=3$，因为$8>6$，所以6出队，$8>7$，所以7出队，8入队，队列为{8}  
$i=4$，因为$12>8$，所以8出队，12入队，队列为{12}  
$i=5$，因为$9<12$，所以9入队，队列为{12，9}  
$i=6$，因为$10>9$，所以9出队，$10<12$，所以10入队，队列为{12，10}  
$i=7$，因为$3<10$，所以3入队，队列为{12，10，3}，但是，因为12的位置为4，不在$(i-3,i]$，这个范围内，所以出队，队列为{10，3}

这时就有人奇怪了，队列里剩下的不是最大值呀

其实不难发现，每个队列的队头就是当前的最大值，所以只要每次更新完队列后让更新前的最大值与更新后的最大值比较就行

最小值同理
***
对于这题，要维护的是一个区间段的最大值，这就要用到前缀和，怎么用呢，看代码
```cpp
#include<bits/stdc++.h>
#define RI register int
#define LL long long
using namespace std;

int in()
{
    int qwq=0,qaq=1;char cc=getchar();
    for(;!isdigit(cc);cc=getchar())if(cc=='-')qaq=-1;
    for(;isdigit(cc);cc=getchar()) qwq=(qwq<<1)+(qwq<<3)+(cc&15);
    return qwq*qaq;
}

const int N=5e5+5;
const int INF=987654321;

int n,m,l,r;
int a[N],q[N],ans;

int main()
{
    n=in();
    
    ans=-INF,l=1,r=1;//初始化
    for(RI i=1;i<=n;++i)
    {
		a[i]=a[i-1]+in();//前缀和
		
		//while(l<=r && q[l]+m<i) ++l;//这里是用来把不在区间的数进行出队操作，由于这题的范围就是n，所以可以不用
		
		ans=max(ans,a[i]-a[q[l]]);//更新最大值
		
		while(l<=r && a[i]<=a[q[r]]) --r;//维护队列单调性
		
		q[++r]=i;//储存位置
	}
	
	cout<<ans<<endl;
	
    return 0;
}
```
***
单调队列强化题：  
[P1440 求m区间内的最小值](https://www.luogu.org/problem/P1440)  
[P1714 切蛋糕](https://www.luogu.org/problem/P1714)（这题跟这题（笑）一样，只要把注释去掉）  
[P1725 琪露诺](https://www.luogu.org/problem/P1725)（似乎是升级版？）  
[P1886 滑动窗口](https://www.luogu.org/problem/P1886)  
[P2032 扫描](https://www.luogu.org/problem/P2032) 
***
~~如果这篇题解过了，那就有67篇题解了，多么吉利的数字啊~~

**最后：~~NOIP2019~~$CSP2019-RP^{+^{+^{+^{+^{+^{+^{+^{+^{+}}}}}}}}}$**