# 思路

总思路：首先对于每个i求出以i结尾的所有子段中最大的子段和，再比较这些子段和中最大的值，这个值就是问题的解。

## 对于每个i求出以i结尾的所有子段中最大的子段和

乍一看这需要逐个枚举，但其实此部分可以用动态规划。

当i=1的时候，由于以1结尾的所有子段只有一个，所以以i结尾最大的子段和就是区间第一个元素。

当i>1的时候，需要满足子段和以i结尾和子段连续的性质，我们于是就只有两种选择：
1. 将前面的子段与第i个元素相接，求子段和。
2. 另起炉灶，以单个元素（也就是第i个元素）作为子段和。

然后我们稍微研究一下就能发现，当选择1时可以将以i-1为结尾的最大子段和子段与第i个元素相接，以得到最大的子段和。

于是选择1就可以改成“将前面的最大子段和子段与第i个元素相接，求子段和”。

这两种选择中最大的结果就是以i结尾所有子段和中最大的子段和。

根据上述分析，我们就能很轻易地列出状态转移方程求解。

# 代码（可通过本题，请勿抄袭）
```cpp
#include <bits/stdc++.h>

using namespace std;
const int MAXN = 233333;
int a[MAXN], dp[MAXN];

int main()
{
    int n; cin >> n;
    for(int i = 0; i < n; ++i) cin >> a[i];
    for(int i = 0; i < n; ++i)
    {
        if(i == 0) dp[0] = a[0];
        dp[i] = max(dp[i-1] + a[i], a[i]);
    }
    int ans = -233333333;
    for(int i = 0; i < n; ++i)
        if(dp[i] > ans) ans = dp[i];
    cout << ans << endl;
}
```