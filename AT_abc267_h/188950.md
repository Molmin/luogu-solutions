一个很显然的思路就是设 $f[i][j][o]$ 表示目前到了第 $i$ 个数，和为 $j$、选了 $o$ 个数的方案数然后 dp。$o$ 是用来判断奇偶性的，取值只需要是 $1$ 或 $0$。时间复杂度是 $\mathcal O(nm)$ 的。


0-1 背包组合问题是有多项式意义的。记第 $i$ 个数 $a_i$，则 $\prod _{i=1}^{n}(1+x^{a_i})$ 的 $x^v$ 项的系数就是凑成 $v$ 的方案数。**这是个结论**。

给个简单的证明。找规律：

- $2$ 个物品能凑出的方案数为 $\{0,a_1,a_2,a_1+a_2\}$；
- $3$ 个物品能凑出的方案数为 $\{0,a_1,a_2,a_3,a_1+a_2,a_1+a_3,a_2+a_3,a_1+a_2+a_3\}$；
- ……

非常像子集枚举。但是要把**值相同**的项合并起来，不太好处理。其实加法可以通过指数转化成乘法，即进行 $a_1+a_2 \rightarrow x^{a_1+a_2}$ 的转化。而这可以化成多个多项式相乘的形式：即 $\prod _{i=1}^{n}(1+x^{a_i})$。

因为限制的是奇数个，思考怎么容斥掉选了偶数个的方案数。需要找到某个数，乘以奇数次和乘以偶数次的结果不同。很显然 $-1$ 就满足要求。

因此，$a_i$ 项的系数就是 $-1$。$\prod _{i=1}^{n}(1-x^{a_i})$ 就是符合要求的多项式。感性理解下，奇数个 $x^{a_i}$ 乘起来是负数，而偶数个乘起来是正数。严格证明也不难，就不写了。

令 $F=\prod _{i=1}^{n}(1+x^{a_i}),G=\prod _{i=1}^{n}(1-x^{a_i})$。记 $P[i]$ 表示 $x^i$ 的系数，那么 $F[m]$ 就是**不考虑奇偶**的方案数，$G[m]$ 就是**偶数方案数减去奇数方案数**。

最终答案就是 $\frac{F[m]-G[m]}{2}$。记得除以二，因为奇数被算了两次。时间复杂度 $\mathcal(m\log m \log n)$，能过。关键代码如下：

```cpp
const int mod=998244353,maxn=500000+5;
poly F[maxn],G[maxn];//poly 板子就不放了
int main(){
    int n,m;cin>>n>>m;
    for(int i=1;i<=n;i++)cin>>a[i];
    for(int i=1;i<=n;i++)F[i][0]=G[i][0]=1,F[i][a[i]]=1,G[i][a[i]]=mod-1;
    for(int i=2;i<=n;i++)F[i]=F[i-1]*F[i],G[i]=G[i-1]*G[i];
    cout<<1ll*((1ll*F[n][m]-G[n][m])%mod+mod)%mod*qpow(2,mod-2)%mod;
}
```

Lingfunny 有更优的[解法](https://280800.blog.luogu.org/solution-at-abc267-h)，是 $\mathcal O(m\log mV)$ 的。

~~但是没我快~~

