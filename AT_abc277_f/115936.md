想投 Ex 题解的发现做法就一句话，交上去肯定过不了审。

早上起来有人问 F 咋做，然后看了一眼。

咋听到的做法都是建图阿，不理解，这里提供一个直接在原矩阵上做的确定性做法。

首先显然只要满足非 0 的数之间满足排序即可，然后 0 是一定有合法填法的。

然后一个最重要的性质是，原本在同一行的数，交换后依然在同一行。列同理。

那么我们可以把行和列分开考虑。

先考虑行。我们对每个行求出非 0 的数中的最大值和最小值，那么排序后要求前一行的最大值 $\le$ 下一行的最小值。直接 sort 即可。

考虑列。我们考虑模拟选择排序的过程，每次选择最小的列放在最前面。为了方便，这里我们将选了的列都视作被删掉了。

那么一个列满足当前条件，它上面的数要么是 0，要么是所在行中未被删掉的数中的最小值。

这启发我们对每个列维护一个数组 $sum_j$，表示第 $j$ 列上有多少个数当前是满足条件的，每次取一个 $sum_j=n$ 的列删掉即可。

然后我们考虑动态的去维护这个过程，类似双指针的形式。

具体地，我们将每个行内部按照权值排序，然后每行维护一个指针 $now_i$ 表示第 $i$ 行的最小值对应的下标。

注意到因为我们要判断某一行当前的最小值是否已经全被删了，来判断是否走到下一个最小值，所以我们需要知道具体删掉了哪些列，所以我们拿一个容器存下未被删的满足 $sum_j=n$ 的列的编号即可。

容器选择栈，队列等等都可以，但是因为我早上有点犯浑所以直接 set 了，栈和队列的复杂度是 $O(nm)$，set 会多一个 $\log$。

https://atcoder.jp/contests/abc277/submissions/36462900