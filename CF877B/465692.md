# 0x00 思路
首先，我们先来看一下题目描述来理清思路。
>Nikita发现了一个**只含 ' $a$ ' 与 ' $b$ ' 的字符串**。Nikita认为，如果一个字符串可以分为三段，**第 $1$ 、$3$ 段只含' $a$ '，第 $2$ 段只含' $b$ '（每段都能为空）**，则这个字符串是美丽的。Nikita想删除（**不是改变**）某些字符，把输入的字符串变成美丽的。（可以不改变原串）

我们可以发现每两个字符中间都可以成为第一、二个或第二、三个字符串分开的地方。又因为前面所做的决定(将前一个字符分在哪一个字符串里)不会影响到后一个的决策，因此我们可以想到思路：dp。

# 0x01 定义状态
很明显，因为三个串都可以为空，因此当前字符可以放在任意字符串里，所以我们需要定义一个二维数组 `dp[i][j]` 来表示将第 `i` 个字符放在第 `j` 个字符串中**最多**能留下的字符。

# 0x02 状态转移方程
状态定义完毕就应该转移状态了。那么如何转移呢？情况有三：

**1. 字符 `i` 在第一个字符串**

如果这个字符在第 $1$ 个字符串，那么它的前一个字符**一定**在第 $1$ 个字符串(除非它是第 $1$ 个字符或者前一个被删了。但是不用管，因为被删了的话 `dp[i][1] = dp[i-1][1]`,所以不需要考虑）。

**2. 字符 `i` 在第二个字符串**

如果这个字符在第 $2$ 个字符串，那么前一个字符可能放在第 $1$ 个或第 $2$ 个字符串。又因为我们保存的是第 `i` 个字符放在第 `j` 个字符串中前 `i` 个字符**最多**有多少个能留下来。所以直接取 `dp[i-1][1]` 和 `dp[i-1][2]` 的最大值。

**3.字符 `i` 在第三个字符串**

与第 $2$ 点基本同理，所以这里就不再过多赘述了，只是相较第 $2$ 点而言三又多了前一个字符在第三个字符串的情况，仍取最大值。

# 0x03 注意细节！

>第 $1$ 、$3$ 段只含' $a$ '，第 $2$ 段只含' $b$ '（每段都能为空）。

所以一个字符在一或三字符串保留下来的条件是它是 ' $a$ '，在第二个字符串保留下来的条件是它是 ' $b$ '。

所以在三个字符串中保存下来的条件是这样：
```c
'b'-a[i]//在第1、3个字符串中
a[i]-'a'//在第2个字符串中
```

**Code:**

```c
#include<bits/stdc++.h>
using namespace std;
int d[5005][5];
char a[5005];
int main()
{
	int n,m,t,i,j;
	cin>>a;
	n=strlen(a);
	for(i=1;i<=n;i++)
	{
		d[i][1]=d[i-1][1]+'b'-a[i-1];//更新第i-1个字符在第1个字符的情况
        d[i][2]=max(d[i-1][1],d[i-1][2])+a[i-1]-'a';//更新第i-1个字符在第2个字符的情况
        d[i][3]=max(d[i-1][1],max(d[i-1][2],d[i-1][3]))+'b'-a[i-1];//更新第i-1个字符在第3个字符的情况
	}
	printf("%d",max(d[n][1],max(d[n][2],d[n][3])));
	return 0; 
}
```
# 0x04 优化
这道题的时间复杂度和空间复杂度分别是 $O(n)$ 、$O(3n)$，由于这道题我们只用了一重循环，而且数据范围也保证没有（~~谁知道有没有超~~）超过 $5000$，所以时间复杂度肯定优化不了了，那么看空间：由于此题只用到了前一个字符（即 `i-1`），所以我们不需要保留物品的编号。

代码如下:
```c
#include<bits/stdc++.h>
using namespace std;
int d[5];//比较:d[5005][5],d[5]
char a[5005];
int main()
{
	int n,m,t,i,j;
	cin>>a;
	n=strlen(a);
	for(i=1;i<=n;i++)
	{
		d[1]=d[1]+'b'-a[i-1];
		d[2]=max(d[1],d[2])+a[i-1]-'a';
		d[3]=max(d[1],max(d[2],d[3]))+'b'-a[i-1];
	}
	printf("%d",max(d[1],max(d[2],d[3])));
	return 0; 
}
```
但是这是错误代码！

接着我请出了我们机房的同学来帮我查错。我们发现 `d[2]` 需要用到 `d[1]` 未更新的值， `d[3]` 需要用到 `d[1]` 和 `d[2]` 未更新的值。

所以需要把顺序反一下。

**code:**
```c
#include<bits/stdc++.h>
using namespace std;
int d[5];
char a[5005];
int main()
{
	int n,m,t,i,j;
	cin>>a;
	n=strlen(a);
	for(i=1;i<=n;i++)
	{
	   	d[3]=max(d[1],max(d[2],d[3]))+'b'-a[i-1];
		d[2]=max(d[1],d[2])+a[i-1]-'a';
		d[1]=d[1]+'b'-a[i-1];
	}
	printf("%d",max(d[1],max(d[2],d[3])));
	return 0; 
}
```
这是优化后的代码，时间复杂度 $O(n)$ ,空间复杂度 $O(3)$ 。