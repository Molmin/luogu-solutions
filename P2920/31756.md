##其实还有一种乱搞快排方法，先快排再直接顺序模拟

cmp比较两个结构体时，返回把a放在前面好还是b放在前面好

放个核心比较代码：

```cpp
inline bool TaskPriorit(Task a,Task b){
    return min(a.s-a.t,b.s-a.t-b.t)>min(b.s-b.t,a.s-a.t-b.t);
    //s表示最迟完成时间，t表示任务需要的时间。
}
```
这里不考虑其他元素，只考虑a，b的先后。所以其实两个min()算出的值没有任何实际的意义，只是两种方法的**相对优劣程度**。

PS:相对优劣程度表示仅考虑a，b时能休息的时间。

前一个min表示把a放在前面的优劣程度，后一个表示把b放在前面的优劣程度。

前一个min中`a.s-a.t`表示只做放在前面的任务可以休息的时间，`b.s-a.t-b.t`表示把两个任务都做完可以休息的时间，后一个min以此类推。两种方法如果a放前能多休息，那就把a放前，否则就把b放前。

###所以这题方法：

###1.按照上述方法快排一遍

###2.模拟扫一遍

模拟的代码：

```cpp
for(int i=1;i<=n;i++){
        now+=a[i].t;     //先不间断的把所有事做完并记录时间
        if(now>a[i].s){  //不能完成
            puts("-1");
            return 0;
        }
        ans=min(ans,a[i].s-now); //能睡的时间就是所有差的最小值
    }
```