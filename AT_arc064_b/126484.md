算不上是博弈论吧……跟机房隔壁同学玩了几发（人肉打表），发现了事情似乎很~~不~~简单：

```cpp
现在定义事件A和B
A.字符串的两端字符相同
B.字符串的长度为奇数
发现如果AB同时成立或不成立，那么玩家2会胜出；
如果这俩事件中仅一个成立，那么玩家1会胜出。
（这貌似是一个公平游戏）
```

那么我们就想到了如何表示这样一对有趣的事件了：`A xor B`，（xor即异或，AB不同时该位上记1）

> ## `A xor B`为真的时候，显然两件事只发生一件，玩家1胜出，为假的时候，玩家2胜出。

那么我们就得到了本题的（目前）最精简代码:

```cpp
#include <bits/stdc++.h>
using namespace std;
int main()
{
	string s;
	cin>>s;
	return 0&(int)printf("%s",((s[0]==s[s.length()-1])^(s.length()%2))?"First":"Second");
}
```

其中可以观察到，前者为A事件，后者为B事件，运用xor和三目搞定。