~~又来水估值了。~~

## 题意简述
题目翻译很清楚，故不再提供。

## 做法
观察样例，易得只需要减到是一个等差数列就行了。

简单证明：假设最后集合 $S$ 从小到大依次为 $a_1,a_2,\cdots,a_n$。

则 $a_2-a_1$ 在集合中。因为 $a_2-a_1<a_2$，所以 $a_2-a_1$ 只能为 $a_1$。

此时 $a_3-a_2$ 也必定在集合中，由上述过程可以得 $a_3-a_2=a_1$ 或 $a_3-a_2=a_2$。

仔细推敲，你会惊人地发现，$a_3-a_2$ 不可能等于 $a_2$。因为这样，$a_2=2a_1,a_3=2a_2$，进而 $a_3=4a_1$。

有什么问题呢？$a_3-a_1=3a_1$，就不在集合中了（因为是从小到大排列的，$a_2$ 与 $a_3$ 之间不可能再有值存在）。

所以 $a_3-a_2=a_1$。推广一下，$a_i-a_{i-1}=a_1$，就是等差数列啦！

并且我们通过证明，还能发现要求的就是给定的数能凑出的最小值。并且因为 $a_1$ 是公差，所以用 $a_n\div a_1$ 就能得到项数（第 $i$ 项是 $a_1$ 的 $i$ 倍）。

也就是说，我们要先做差，再做差，又双叒叕作差，一直到减出来等于较小数（即 $x-y=y$ 的形式）。

你不觉得这有点熟悉吗？对，辗转相除！

因此，我们要求的是所有差中的最大公因数 $d$，这同时也是 $a_1$。

看到这里，你就去打代码了，交上去之后就 WA 了。

为什么呢？不妨看个例子：

$S=\{3,5,7,9\}$，您的程序输出多少呢？

显然答案是 $9$，因为我们可以凑出 $1,2$，进而凑出其他的数。

造成差异的，就是公差 $2$ 出来之后，与 $3$ 的差不为 $2$（即它们的公差已不满足）。

如你所见，光算差还不行，因为减出来之后想保证公差与原数列仍保持等差，所以数列中的每个数都得是公差的倍数。

所以统计所有数和相邻差的最大公因数就行了。

为什么相隔的不用考虑呢？因为求最大长度，求的就是最小公差。相隔的差显然不是最小的，且一定是最小公差的倍数，故不用考虑。

时间复杂度 $O(n\log n)$。

```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;

const int N = 2e5 + 10;
int T, n;
ll a[N];

int main(){
	scanf("%d", &T);
	while(T--){
		scanf("%d", &n);
		ll d = 0;
		for(int i=1;i<=n;i++){
			scanf("%lld", &a[i]);
			if(!d)
				d = a[i];//初始化 
			else
				d = __gcd(d, a[i]);
		}
		sort(a + 1, a + 1 + n);//从小到大排序 
		for(int i=2;i<=n;i++)
			d = __gcd(d, a[i] - a[i - 1]);//算差 
		printf("%lld\n", a[n] / d);//这是项数 
	}
	return 0;
}
```
