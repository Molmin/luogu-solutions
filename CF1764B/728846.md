# CF1764B Doremy's Perfect Math Class 题解

题意简述就省去吧，题目翻译已经很简洁了。

## 思路分析

对于整数集合 $\mathbf{S}$，我们可以通过分析数据来找一下规律：

对于第一组样例：由于是一个只有两个元素的 $\mathbf{S} = \{ 1, 2 \}$，由于 $2 - 1 = 1$，而 $1$ 已在集合中，那么只能输出其长度 $2$。

对于第二组样例：$\mathbf{S} = \{ 5, 10, 25 \}$，选择 $25 - 10 = 15$ 并加入集合中，得到新集合 $\mathbf{S} = \{ 5, 10, 15, 25 \}$，再选择 $25 - 5 = 20$ 并加入集合中，得到 $\mathbf{S} = \{ 5, 10, 15, 20, 25 \}$，可以发现当前集合已无法继续操作，所以输出长度 $5$。

易得，我们需要将集合 $\mathbf{S}$ 减成一个 **等差数列**。

---

接下来我们给出数学证明：

因为集合 $\mathbf{S}$ 是一个等差数列，意味着其元素从小到大依次为 $\mathbf{S} = \{ s_1, s_2, s_3, s_4, s_5 \cdots \}$。

所以 $s_2 - s_1$ 一定在集合中。

$\because s_2 - s_1 < s_2 \ \therefore s_2 - s_1 = s_1$。

同理可得 $s_3 - s_2 = s_2$ 或者 $s_3 - s_2 = s_1$。而我们可以发现 $s_3 - s_2 = s_1$ 是不可能存在的，如果这样，那么 $s_2 = 2 \times s_1, s_3 = 2 \times s_2 = 4 \times s_1$。

那么 $s_3 - s_1 = 3 \times s_1$，因为 $s_2 < s_3$ 且集合具有非负性，所以 $s_2$ 和 $s_3$ 之间不可能还有一个 $3 \times s_1$ 的值存在。

将发现推广一下，可以发现 $s_i - s_{i - 1} = s_1$，这就是我们要找的等差数列。

---

有思路了，但是代码的实现呢？

我们可以从每次新加的数 $x - y$ 来找思路。难道不觉得 [眼熟](https://oi-wiki.org/math/number-theory/gcd/) 吗？可以发现，集合序列中数字的公差正是它们的 **最大公约数**，那么每个数我们都可以表示成 $a \times gcd$，最小值则是 $1 \times gcd$，最大值就是 $\max \times gcd$，那么我们输出的答案就是 $\dfrac{s_i}{gcd}$。

## 代码

```cpp
#include <bits/stdc++.h>

using namespace std;

int t, n, p, gcd;

int main() {
	scanf("%d", &t);
	while (t--) {
		scanf("%d", &n);
		scanf("%d", &p);
		gcd = p;
		for (int i = 1; i <= n - 1; i++) {
			scanf("%d", &p);
			gcd = __gcd(gcd, p);
		}
		printf("%d\n", p / gcd);
	}
	return 0;
}

```

代码小注：

* 由于有现成的 `__gcd`，便直接引用来求最大公约数。
* 数据范围是 $2 \times 10^5$，所以完全不需要开 `long long`。
* 先读入第一个元素 $p$，并设置当前 $gcd$ 为 $p$ 的原因是，之后我们每次读入新 $p$，只需统计新 $p$ 的 $gcd$ 并在输出时直接使用上述公式 $\dfrac{s_i}{gcd}$，这可以省去一个数组的空间。

写完题解才发现有相同思路，所以改了一下思路分析。~~感觉很详细了~~
