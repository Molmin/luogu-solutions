回滚莫队。。其实不算啥很牛逼的黑科技吧。   

本文的宗旨是用简洁的语言将回滚莫队讲的透彻，希望大家看完这篇题解能搞明白回滚莫队。   

和普通的莫队一样，回滚莫队的第一步自然就是排序。  

我们对所有询问按照一下规则排序：    

- 若左端点所属块的编号不相同，则按左端点所属块的编号较小的排在前面。   

- 若左端点所属块的编号相通，则让右端点小的排在前面。 

接着就是回滚莫队算法的核心：  

我们枚举当前处理的询问的左端点的块的编号，

如果现在的询问的右端点也在这个块内，直接暴力做就好了。 

否则我们设当前询问是 $[l1,r1]$，下一个询问是$[l2,r2]$，当前块的左端点是 $bl$，右端点是 $br$。 

因为经过了排序，所以就是这样的情况。  

```
|..|..|....bl l1, l2（l2 不一定在 l1 后面） br ...  r1 ... r2 |...|...... 
```
我们设一个莫队指针 $p$，$p$ 的初始值是 $br$，因为保证了右端点升序，所以到第二个询问的时候一定包含了 $[br,r1]$ 这段信息，$p$ 指针直接往右移直到 $r2$ 就好了。   

同时还有前半段信息就是 $[l,br]$ 这一段，我们每次设一个指针 $p1$，初始值为 $br$，一直移动到 $l$，接着把这段贡献加上，再重新移动回 $br$ 把这段贡献撤销掉就好了。  

如果块长是 $\sqrt{n}$ 的话整个算法的复杂的是 $O(n\sqrt{n})$，这里简要证明一下：  

因为有 $\sqrt{n}$ 个块，所以枚举左端点是 $O\sqrt{n}$ 的。    

然后一直走相当于 $O(n)$, 从 $br$ 走回询问左端点在一个块内，是 $O(\sqrt{n})$ 的。  

综合一下就是 $O(n \sqrt{n})$。 

另外此题轻微卡常，有一个小技巧就是把所有出现过的数单独用一个数组存下来，清空的时候清空这个数组里的数就行了，实测飞快。  

