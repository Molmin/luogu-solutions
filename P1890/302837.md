### 前置芝士

最大公约数及其性质，DP 基础。

### $1$ 最大公约数

最大公约数，又称 $\gcd$，即两个数共有的约数中最大的一个，下面是 $\gcd$ 的求法。

#### $1.1$ 枚举法

我们可以从大到小枚举，找到了就退出循环，因为 $\gcd(i,j) \le \min(i,j)$，所以从 $\min(i,j)$ 开始枚举就行了。

```cpp
int gcd(int x,int y)
{
	if(x>y) swap(x,y);
	for(int i=x;i>=1;i--) 
		if(x%i==0&&y%i==0) return i;
} 
```
但是这种求法的复杂度很高，这题是过不了的。

#### $1.2$ 欧几里得算法

该算法又称“辗转相除法”，是求 $\gcd$ 的一种比较高效的算法。

假设我们要求 $\gcd(i,j)$，如果 $i \% j = 0$，那么 $j$ 就是最大公约数，否则最大公约数是 $\gcd(j,i \% j)$，所以我们可以用递归实现。

如果 $i$ 小于 $j$ 也没关系，因为第一次递归可以把两个数交换，详见下表求 $\gcd(15,39)$ 的过程。

| 递归层数 | $i$ | $j$ | $i \% j$ | 目前的结果 |
| :-----------: | :-----------: | :-----------: | :-----------: | :-----------: |
| $1$ | $15$ | $39$ | $15$ | $\gcd(39,15)$ |
| $2$ | $39$ | $15$ | $9$ | $\gcd(15,9)$ |
| $3$ | $15$ | $9$ | $6$ | $\gcd(9,6)$ |
| $4$ | $9$ | $6$ | $3$ | $\gcd(6,3)$ |
| $5$ | $6$ | $3$ | $0$ | $3$ |

上代码！

```cpp
int gcd(int x,int y)
{
	if(x%y==0) return y;
	else return gcd(y,x%y);
} 
```
#### $1.3$ 编译器内置 $\gcd$

`__gcd(i,j)` 返回的就是 $\gcd(i,j)$，注意有两个 `_` ，包括 `__int128` 也是。

**最最最最最最重要的一点，NOIP 尽量不要用以下划线开头的内置函数！！！**

### $2$ DP基础

DP 是动态规划，具体有如下几个步骤，我们以本题为例：

- 设立状态，这里我们让 $dp_{i,j}$ 表示区间 $i,j$ 的最大公约数。

- 找转移方程：

因为 $a_1,a_2,a_3,.....,a_n$ 的 $\gcd$ 等于 $\gcd(a_1,a_2,a_3,.....,a_{n-1},a_n)$。

所以 $dp_{i,j}=\gcd(dp_{i,j-1},a_j)$。

- 实现代码，具体见下面。

### $3$ 代码实现

$ans$ 数组表示 $dp$，其余变量和数组的名称同题面。

一个小小的数学知识：$\gcd(1,x)$ $(x \le 1)$ $=$ $1$。

所以在找到 $1$ 时直接 `break` 就行啦，否则会 TLE。

因为 c++ 全局变量初始值为 $0$ 所以输出时要进行特判。

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,a[1234],ans[1234][1234];
signed main()
{
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++) scanf("%d",&a[i]);
	for(int i=1;i<=n;i++)
	{
		ans[i][i]=a[i];
		for(int j=i+1;j<=n;j++)
		{
			ans[i][j]=__gcd(ans[i][j-1],a[j]);
			if(ans[i][j]==1) break;
		}
	}
	for(int i=1;i<=m;i++)
	{
		int l,r;
		scanf("%d%d",&l,&r);
		printf("%d\n",ans[l][r]==0?1:ans[l][r]);
	}
	return 0;
}
```
