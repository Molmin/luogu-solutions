首先关于快速求 LCP 的问题，一般可以转化到反串的后缀链接树上（这样前缀就会变成后缀，方便统计）。

然后后缀链接树有一个性质，就是该节点到父节点的有一些子串（状态）会被压缩，我们这时候要统计树上问题就要考虑到。

我们有一个结论:

$$lcp(i,j)=dis(lca(i,j))$$

每个节点到其父节点的权值，要设置为他和他的父节点所对应的的串的长度差。

我很菜，不会证明，但是看图感觉是对的。

显然，观察下图可以得到，当然对于正串说求的是最长公共后缀。

图片来自OI-wiki：

![](https://oi-wiki.org/string/images/SAM/SA_suffix_links.svg)

很自然的就码出来后缀自动机。

然后就是树上的统计了。

我们要求一对节点的最近公共祖先的深度，对于小数据，一般会暴力 LCA 。

但是碰到大数据那就未必了。

我们冷静下来分析，首先可以肯定的是，每个节点到其父节点的权值，要设置为他和他的父节点所对应的的串的长度差。

如果不能理解观察上面 OI-wiki 的那张图，也许就可以理解。

于是这时候问题就变成了，给你两组节点，点带权，求 $\sum dis(root,lca(u,v))$

惊喜的是，这个柿子可以用 LCT 求解。

具体如何实现呢？

我们先将第一组作为起点的点向根节点的路径上加一（中间压缩的节点就乘一下），然后从第二组出发，依次累加每个终点到根节点的答案，这样，两个点一来一去，正好算清楚了 $dis(root,lca(u,v))$。

有人就会问了，这样会算上 $dis(v,kca(u,v))$ 呀。

显然的是 $dis(v,kca(u,v))$ 的路径产生的贡献属于与另一个第一组节点产生的贡献，不影响结果。

因此我们只需要使用 LCT 维护节点值，链和，节点原来的权值，和链原来的权值即可。

于是我们可以愉快的使用 LCT 维护了。

代码太丑了，就不展示了。
