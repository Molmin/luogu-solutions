**树形dp**
------------
当我看到这道题的题面的时候，发现他是一个树形结构，刚好又要在节点上面放置士兵，瞬间就觉得八九不离十就是树形dp了。

这道题要求我们放置士兵，士兵可以监视相邻的节点，这里我们就把它当做子节点，（其实也无所谓），使得士兵可以监视整个树。了解题目要干嘛了以后，我们就开始推方程。

这里设一个二维数组f，第一维表示当前节点x，第二维表示x节点是否放置士兵，**f[x][]表示根节点为x的子树放置士兵个数**。由题意“监视相邻的节点”，得：**当前节点x，子节点y，要么x监视y，要么y监视x，要么x、y相互监视**。那么可以根据这一点，分类讨论：
1. y监视x，即为x节点没士兵，y节点有士兵，此时f[x]就是其子节点的士兵和（**条件：子节点放置士兵**）
1. x节点有士兵，此时，**对于y节点是否放置士兵没有要求**，那么f[x]就是子节点的士兵和的最小值再加上**自身的1**


------------
由以上讨论，整理，得出转移方程：
```cpp
f[x][0] += f[y][1];
f[x][1] += min(f[y][0], f[y][1]);
```
其余的嘛，就是注意多组数据，别忘了**初始化**什么的了。

下面是代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 2e3 + 50;

int n;
int f[N][2];//f[x][0]x节点不方 f[x][1]x节点放
vector <int> e[N];//vector存边

void dfs(int x) {
	f[x][1] = 1;//x节点放置士兵，自身加1
	for(int i = 0; i < e[x].size(); i ++) {
		int y = e[x][i];//子节点
		dfs(y);
		f[x][0] += f[y][1];//x节点不放
		f[x][1] += min(f[y][0], f[y][1]);//x节点放，取子节点的最小值
	}
}

int main() {
	while(scanf("%d", &n) != EOF) {//多组数据
		int st = 0;//起点
		memset(f, 0, sizeof(f));//初始化
		for(int i = 1; i <= n; i ++) {
			int x, k;
			scanf("%d:(%d)", &x, &k);
			e[x].clear();//初始化
			while(k --) {
				int y;  scanf("%d", &y);
				e[x].push_back(y);//存边
			}
			if(i == 1) st = x;//记录根节点
		}
		dfs(st);//dp
		printf("%d\n", min(f[st][0], f[st][1]));//输出
	}
	return 0;
}
```
