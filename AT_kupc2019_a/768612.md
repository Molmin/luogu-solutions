[传送门](/problem/AT_kupc2019_a)


#### 题目翻译提供在这：

现有 $N$ 个人参与投票，第 $i$ 个人有 $a_i$ 票，还有 $X$ 票未投。请问 $X$ 票投完后，有多少人票数可能最多？

输入数据：两行，第一行两个数，$N$ 和 $K$；第二行 $N$ 个数，$a_i\sim a_N$。

输出数据：一行一个数，问题的答案。

数据范围：$1\le N,X,a_i\le1000$。

***

这题很简单，思路和代码都不难。难度建议：入门（红）或普及-（橙）

前置芝士：贪心算法（~~虽然不会也行~~）

贪心的关键在于，要怎么贪？这其实也是一个难点，很多题目想不到该怎么贪心就做不出来，像我这种蒟蒻就这样栽在了很多并不难的题上。

在这道题中，第 $i$ 个人在剩下的 $X$ 票都投完后能达到的最大票数，显然是 $a_i+X$，容易想到，此时如果 $a_i+X\ge a_j(1\le j\le n\land i\ne j)$，那么答案就要加 $1$。

现在我们有了初步代码：

```cpp
for(int i=1;i<=n;i++)
    for(int j=1;j<=n;j++)
        if(a[i]+x>=a[j]&&i!=j)
            ans++;
```

理论上来说，这份代码是可以通过本题的，但再水再简单的题目都可以优化，这是个很好的习惯。下面考虑优化

实际上，我们只要在开头预处理出 $a$ 的最大值，再判断有多少个 $a_i+X$ 大于或等于最大值就行了。$O(n^2)$ 的时间复杂度优化到 $O(n)$。

完整AC代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,x,ans,a[1005],maxn;
int main(){
    scanf("%d%d",&n,&x);
    for(int i=1;i<=n;i++)
        scanf("%d",&a[i]);
    for(int i=1;i<=n;i++)
        maxn=max(maxn,a[i]);
    for(int i=1;i<=n;i++)
        if(a[i]+x>=maxn)
            ans++;
    printf("%d",ans);
    return 0;
}
```