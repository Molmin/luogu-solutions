#### ~~又发现一道水题~~

#### ~~12行就灭了(无压行)~~

这题在洛谷上的界面看起来不是很清楚，建议还是到SPOJ [https://www.spoj.com/problems/M3TILE/] 上看（~~主要是观察样例~~）
#### 3*12的样例大概长这样


------------
![](<https://i.loli.net/2019/10/25/28Ib1mrLo3sSZCH.png>)

通过观察我们不难发现：在样例中，这个$3*12$的矩形被分成了$3*2$,$3*4$,$3*2$,$3*4$四块

------------

![](<https://i.loli.net/2019/10/25/J7TwkjbnsgF36OL.png>)

于是我们可以想到dp：   
$3*2m$的矩形可以由$3*2k (0<=k<=2n-2)$转移而来
现在我们的问题转化为求只由$3*2k（1<=k<=n)$(即不能由若干个更小的$3*2m$的矩形拼接而成)的矩形个数（显然任何$3*(2m+1)$的种数就是0）

------------

$n=2$时不难发现有三种

$n=4$时经尝试也只有两种

![](https://i.loli.net/2019/10/25/UWXnr3DcOqI4lJt.png)


![](https://i.loli.net/2019/10/25/8qeLCJ2Z9QnIScR.png)

再尝试$n=6$发现还是两种，于是我们猜测$n>=4$时都是两种

~~证明其实不难~~


------------

如果最上方一行（最下方同理）中间有空出两个，那么必然是
这两个向下作$2*1$的矩形，那么最下方那一行，为了让两边不出现奇数，只能在这两格的最下方放上一个$1*2$ 那么就出现了一个$3*2$ ~~于是就炸了~~  
所以最上方或最下方一定会铺上一整层$1*2$ ，铺完一层后不难知道只有一种 所以一共就是上方铺满和下方铺满两种

------------
于是我们就得到了dp方程

```cpp
dp[0]=1,dp[2]=3;
for(int i=4;i<=30;i+=2)
		for(int j=i-2;j>=0;j--)
		dp[i]+=(dp[j]*(j==i-2?3:2));
```


------------
$Code$:
```cpp
#include<bits/stdc++.h>
using namespace std;
int dp[31]={1,0,3},n;
int main()
{
	for(int i=4;i<=30;i+=2)
		for(int j=i-2;j>=0;j--)
		dp[i]+=(dp[j]*(j==i-2?3:2));
	while(scanf("%d",&n)&&n!=-1)
		printf("%d\n",dp[n]);
	return 0;
}
```
