大致的看了下题解

感觉大家都把这道题想难了

其实是~~十分简单~~的

↓讲一下我是怎么想的↓

~~看到题目后我先去翻了下小学五年级的课本~~

~~明白了如何解一元一次方程：~~

- 1.去分母：在方程两边都乘以各分母的最小公倍数； （这个不需要）

- 2.去括号：先去小括号，再去中括号，最后去大括号； （这个也不需要）

- 3.**移项**：把含有未知数的项都移到方程的一边，其他项都移到方程的另一边；

- 4.**合并同类项**：把方程化成ax=b(a≠0)的形式；

- 5.**系数化成1**：在方程两边都除以未知数的系数a，得到方程的解


看完了步骤，我相信大家能想出一点东西了把

我看到这想到了**可以把未知数的系数储存起来，把数字也储存起来，最后再相÷**

然后就开始打代码了↓

这是代码：：

`
```cpp
#include<cstdio>
#include<cstring>
using namespace std;
double num=0,x=0;//num是数字之和，x为系数之和 
char c,p;//c被用作读入每一个字符，p用来储存未知数是啥 
int a[100],l=1,mid,pd;//a[]储存每一个出现的数,l记录数组长度,mid分开等号两边,pd为判断此数字是正是负 
int main()
{
    memset(a,0,sizeof(a));//数组清0，因为第一个有可能是又前置符号的数，这样不好解决判断问题，索性全为0，最后加起来也没啥影响 
    pd=1;//默认开头第一个数为正 
    while(c!='=')//读入等号左边 
    {
        c=getchar();
        if(c=='-')
            ++l,pd=-1;//只要判断是-数，切换到下一个数,设置这个数为负数 
        if(c=='+')
            ++l,pd=1;//判断为正，切换下一个数，设置这个数为正数 
        if(c>='0'&&c<='9')//读入的是数字 
        {
            if(!a[l])//这个数字字符是数字中的第一个 
                a[l]=(c-'0')*pd;//赋值（记得乘上判断的数） 
            else
                a[l]=a[l]*10+(c-'0')*pd;//数字中已经有数了，为了加上这个数，向前移一位再塞进去 （记得乘上判断的数） 
        }
        if(c>='a'&&c<='z')//发现未知数！ 
        {
            p=c;
            if(a[l]!=0)
                x+=a[l],a[l]=0;//如果有前面的系数，则存入系数集合，把塞在数字数组中的系数去掉 
            else
                x+=pd;//判断特殊情况如-x/+x 
            --l; //减去这一位数 
        }
    }
    mid=l,++l,pd=1;//存储mid，数组位数进一位，pd=1与上面同理 
    while(c!='\n')//同上 
    {
        c=getchar();
        if(c=='-')
            ++l,pd=-1;
        if(c=='+')
            ++l,pd=1;
        if(c>='0'&&c<='9')
        {
            if(!a[l])
                a[l]=(c-'0')*pd;
            else
                a[l]=a[l]*10+(c-'0')*pd;
        }
        if(c>='a'&&c<='z')//这里有点不一样，因为未知数要放在等号左边所以这里要减去系数 
        {
            p=c;
            if(a[l]!=0)
                x-=a[l],a[l]=0;
            else
                x-=pd; 
            --l; 
        }
    }
    for(int i=1;i<=l;++i)//叠加数字 
    {
        if(i<=mid)//在等号左边要减去 
            num-=a[i];
        else//在等号右边的要加上 
            num+=a[i]; 
    }
    if(!(num/x))//这里要加个特判断，因为会出现-0，虽然-0和0等效，但评测机并不吃这一套 
        printf("%c=0.000",p);
    else
        printf("%c=%.3lf",p,num/x);//输出 
    return 0; 
}
```
`
至于那个特判断我问了下老师和机房的大佬

得出了

> > 浮点数的表示里会有负零，负零被表示为指数为编码内任意合法数值、所有系数均为零、符号比特为一的数。和正零等效

也希望这个题解能给大家提供点帮助把




