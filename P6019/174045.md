还记得这题是当时给全湖北选手送了一个月赛讲评，结果我完全没听懂。现在想想我搞不好就是因为这题 ~~觉醒某些奇怪的 M 体质~~ 开始喜欢上分块的。

~~现在看这题其实还算简单的。~~

------------
不弱于小 z 的袜子，考虑分块。区间赋值操作，考虑颜色段均摊。区间数对数的贡献，考虑使用前缀贡献相减再减去前缀对区间的贡献。

如果直接考虑如何把一段同色区间改成另一种颜色，这个思想和分块的相性不是很好。不妨考虑让每个颜色段都出现在同一块内。那么，考虑如果一个块是同一种颜色（称这样的块为“纯色块”，否则称为“杂色块”），可以直接单独计算它的贡献。如果一个块里有多种颜色，那么维护块内的颜色段情况。

对于一次修改：对散块直接插入和删除颜色段，若是纯色块则需要先插入一个段转化成杂色段；对整块，若是纯色块直接 $O(1)$ 修改掉颜色，否则先删除掉所有颜色段，然后标记为纯色块。

插入和删除颜色段的事件会发生多少次呢？默认序列长度和操作数同阶，那么只有在修改的散块处才会插入颜色段，于是插入的颜色段是 $O(n)$ 的，那么删除自然也只有这么多。于是一次插入只需要做到 $O(\sqrt n)$ 时间即可。

考虑维护 $f_i$ 为前 $i$ 个块的贡献，$g_{i,j}$ 表示前 $i$ 个块对后 $j$ 个块的贡献，$sum_{i,j}$ 表示前 $j$ 个块中 $i$ 的出现次数。这几个量都只计算杂色块的贡献。

考虑插入一个颜色段会对这些量造成什么影响。对 $sum$ 和 $f$ 的影响是一段后缀，可以简单地直接计算。对 $g$ 的影响会涉及到 $O(n)$ 项，似乎不好直接维护。但发现某一个位置会受到影响的条件是其所代表的前缀或后缀其中之一包含修改的这个块，对这两类位置的影响分别可以表示为行和列的区间。又发现我们一共只有 $O(n)$ 次对 $g$ 的单点查询，每次查询可以接受 $O(\sqrt n)$ 的时间。那么我们考虑分开维护两种修改。维护行与列的两个差分，那么查询时求两次前缀和，加起来即可。

提一句，查询可以接受 $O(\sqrt n)$ 的复杂度可能会误导人设出前缀对单块的贡献，但是这样就无法维护了（至少我现在还没有想到什么好办法）。所以在设贡献上虽然有清晰的方向，但试错也还是不可避免的。另外有一些与这个本质相同的 $g$ 的设法，可能更加好写，不过这里不做介绍了。

查询时首先考虑整块中的杂色块。这就是用两个前缀相减再减去前缀对区间的贡献，具体地，第 $l$ 到第 $r$ 个块中杂色块的贡献是 $f_r-f_{l-1}-g_{l-1,l}+g_{l-1,r+1}$。考虑散块和纯色块，它们对杂色块的贡献可以直接用 $sum$ 计算，而它们之间的贡献可以直接开桶计算。综上，我们已经 $O(n\sqrt n)$ 解决了此题。

实（ka）现（chang）上，这题可以不像平常一样用 `set` 显式维护出颜色段，而是每次临时计算出有哪些颜色段，修改只关心颜色和长度。~~不过这玩意好像没啥优化效果。~~ 最重要的是 $sum$ 要把颜色这一维放在前面，然后要调块长。

应 lxl 要求只保留核心部分，需要完整版的可以联系我拿。
```cpp
int n,m,a[maxn];
int S,B,L[maxb],R[maxb];
int c[maxb],sum[maxn][maxb];
ll f[maxb],g1[maxb][maxb],g2[maxb][maxb];
int Sum(int x,int l,int r){
	return sum[x][r]-sum[x][l-1];
}
void insert(int x,int k,int v){
	for(int i=x;i<=B;i++) f[i]+=1ll*sum[v][i]*k+k*(k-1)/2;
	for(int i=x+1;i<=B;i++) g1[x][i]+=1ll*Sum(v,i,B)*k;
	for(int i=1;i<x;i++) g2[i][x]+=1ll*sum[v][i]*k;
	for(int i=x;i<=B;i++) sum[v][i]+=k;
}
void erase(int x,int k,int v){
	for(int i=x;i<=B;i++) sum[v][i]-=k;
	for(int i=x;i<=B;i++) f[i]-=1ll*sum[v][i]*k+k*(k-1)/2;
	for(int i=x+1;i<=B;i++) g1[x][i]-=1ll*Sum(v,i,B)*k;
	for(int i=1;i<x;i++) g2[i][x]-=1ll*sum[v][i]*k;
}
int buf[maxn];
void modify(int l,int r,int k){
	int x=(r-1)/S+1;
	if(c[x]){
		insert(x,R[x]-L[x]-r+l,c[x]);
		insert(x,r-l+1,k);
		for(int i=L[x];i<l;i++) a[i]=c[x];
		for(int i=l;i<=r;i++) a[i]=k;
		for(int i=r+1;i<=R[x];i++) a[i]=c[x];
		c[x]=0;
		return;
	}
	for(int i=l;i<=r;i++) buf[a[i]]++;
	for(int i=l;i<=r;i++) if(buf[a[i]]){
		erase(x,buf[a[i]],a[i]);
		buf[a[i]]=0;
	}
	for(int i=l;i<=r;i++) a[i]=k;
	insert(x,r-l+1,k);
}
```