这题可能是我写过最毒瘤的分块之一。

希望没有人用我这种实现方法。

这个题的静态版本已经矩乘规约了，所以考虑分块。

先考虑静态问题：是平凡的。

并且带上修改之后，除了整块-整块的贡献之外，其他的计算（散块-散块，散块内部，散块-整块）仍然是相似而平凡的，就不赘述了。

设 $f_{i,j}(i\le j)$ 为块 $i$ 到块 $j$ 的贡献。那么求和就是 $f$ 的一个矩形和。

考虑颜色段均摊（ODT），只需要考虑加入和删除一段颜色的贡献。他们是相似的。

考虑到实现问题，我们将二元组变为 $i\le j$ 最后减去区间长度。

分类讨论：我们分为左边没有被修改的块 $a$，左散块 $b$，整块 $c$，右散块 $d$ 和右边没有被修改的块 $e$：

1. $a-b$：加上块 $a$ 中的 $x$ 的数量乘上 $b$ 中新加 $x$ 的数量。
2. $a-c$：加上块 $a$ 中的 $x$ 的数量乘上块长。
3. $a-d$：同 $1$。
4. $b-b$：这个直接算出新加的贡献，用新的 $x$ 数量算出的贡献减去原本的贡献。你可能想说为什么不能直接赋值，因为对于后面的数据结构不方便。
5. $b-c$：加上块 $a$ 中新加的 $x$ 的数量乘上块长。
6. $b-d$：容斥一下，就是 $b$ 中新加的乘上 $d$ 中 $x$ 的数量加上 $d$ 中新加的乘上 $b$ 中 $x$ 的数量，$b,d$ 中新加的贡献被算了两次，所以还要减去 $b$ 中新加的数量乘上 $d$ 中新加的数量。
7. $b-e$：同 $1$。
8. $c-c$：加上块内的贡献。注意不是块长的平方。
9. $c-d$：同 $5$。
10. $c-e$：同 $2$。
11. $d-d$：同 $4$。
12. $d-e$：同 $1$。

仔细分析操作，会发现一个重要性质：所有的整块的块长都是相同的！

这就意味着上面的操作都可以得到形式化的操作：

1. 单点加。
2. 行的一个区间加 。
3. 列的一个区间加。
4. 矩形求和。

矩形大小 $\sqrt n\times \sqrt n$，要求 $1,2,3$ 操作 $O(1)$，$4$ 操作 $O(\sqrt n)$。

直接每行或者每列维护一个 $O(1)-O(\sqrt n)$ 分块是 naive 的 $O(n^{0.75})$ 复杂度。

其实用一些简单的根号平衡技巧：以行加为例，将行按 $\Theta(n^{0.25})$ 分块，每块维护一个 $O(1)-O(\sqrt n)$ 分块，就可以做到 $O(n^{0.25}\times \sqrt{\sqrt n})=O(\sqrt n)$ 的复杂度。

然后问题来了：卡常。

这个方法太臭了以至于常数过大。

1. 再写一个维护单点加矩形求和的数据结构，这非常有用，因为大部分的操作是单点加。
2. 块长 $1000\sim 1500$。
3. 行、列间分块 $n^{0.25}$ 调成 $2^x$ 的形式。将 `belong` 数组替换为位运算可以在瓶颈（修改）出减少数组调用次数。
4. 把二维数组的行列调对。
5. ~~随手卡卡。~~

然后就过了。

[放一个没卡常的代码。](https://www.luogu.com.cn/paste/4qfu7h9w)