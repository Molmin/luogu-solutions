这一题难度其实不大，我一开始是用的$O(N^2)$暴力枚举,枚举每两根竹竿是否倒下来能重合，但是只有30分。

之后我想出了$O(N)$算法：输入完数据后，扫一遍，定义一个$l$数组，$l[i]$代表有几根竹竿倒下来能倒在$i$点。但是竹竿可以往左倒啊，有一些竹竿就倒在负的点上了，所以我们把它加上$m$。每一根竹竿还没倒的时候先统计一下它倒到的这个点之前有几根竹竿倒下来也可以砸到，这一根竹竿倒下去之后可以和之前的每一根组成“优秀的竹竿”，所以把它累加到答案。但是$m$太大会爆空间，所以只有60分。

再后来，我把$l$数组改为$map$，满分过。

贴上代码：

---

```
#include<iostream>
#include<cstdio>
#include<map>//各种头文件
using namespace std;
long long sum=0;//有多少对竹竿可以重合
int a[200010];//竹竿长度
map<int,int> l;//统计每一个点有多少根竹竿倒下来可以砸到
int main()
{
    int n,m;
    scanf("%d %d",&n,&m);//这里的m可以不要，因为map好像支持负数下标
    for(int i=1;i<=n;i++){//读入
        scanf("%d",&a[i]);
    }
    for(int i=1;i<=n;i++){//从头到尾扫一遍
        sum+=l[i+a[i]];//右边累加答案
        			   //记住要先累加，再倒，因为如果先倒再累加的话
                       //那么自己和自己会多算一次
        l[i+a[i]]++;//往右倒
        sum+=l[i-a[i]];//左边累加
        l[i-a[i]]++;//往左倒
    }
    printf("%ld",sum);//输出
    return 0;//结束
}
```

---

~~第一次写月赛+绿题题解，求过~~