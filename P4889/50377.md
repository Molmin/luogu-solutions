（**如果你~~不会~~不想用任何高级数据结构·····**）


看了两位MAP**julao**的题解；

本蒟蒻表示；

真的不需要map；

 **思路：**
 
 每根竹竿可以向左倒也可以向右倒，要求有多少对竹竿倒下后顶端可以重合；
 
 考虑维护每一个点可以有几根竹竿落下；
 
 看了一眼m：

**1e9**；

很好；

我们只要开到（1e9+2e5）*2就好了；

继续观察；

我们发现；

只有200000根竹竿；

所以最多只有400000个点可以有竹竿落下；

而我们开了（1e9+2e5）*2；

怎么办；

怎么办；

hash？；

map？；

本蒟蒻并不会。。。。。；

**所以**

我们这样做：

建立一个大小为4e5的数组；

记录竹竿可以落在哪儿；

显然；

若竹竿的位置为i，高度为h；

那么它就可以落在**i+h**和**i-h**；

所以；

（**~~前方高能~~**）

我们将每个i-h和i+h记录之后sort一遍；

看每个数有几个；

答案就加上（n-1）+（n-2）+···+1；

所以；

没有hash 没# 有map 没有线段树；
 没有图 没有堆 **没有 任何高级数据结构**；

我们 通过了这道题；

（**~~记得开longlong 我是不会告诉你们我是因为没开longlong才95分的~~**）；

（**~~不许嘲笑我的代码~~**）；

```cpp
#include<iostream>
#include<algorithm>
using namespace std;
long long n,m,cu,uu,a[400010],b[400010];
int main()
{
	cin>>n>>m;
	for(long long i=1;i<=n;i++)
	{
		cin>>uu;
		a[++cu]=i+uu;
		a[++cu]=i-uu;
	}
	for(long long  i=2;i<=400004;i++)	b[i]=i-1+b[i-1];
	sort(a+1,a+n*2+1);
	n*=2;
	long long ans1=1,ans=0;
	for(long long i=2;i<=n;i++)
	{
		if(a[i]==a[i-1])
		  ans1+=1;
		if(a[i]!=a[i-1]||i==n) 
		{
			ans+=b[ans1];
			ans1=1;
		}
	}
	cout<<ans<<endl;
	return 0;
}
```




