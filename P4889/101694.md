简单的题目，我也不知道为什么会标上提高+难度的标签。

我没有使用传说中的STL——map  ~~反正我也不懂呀…~~

于是我就采用了一种小学生级别的办法，叫做STL——sort

首先，每个flag都可以向左倒或者向右，我们把这2种情况都统计入一个数组，再进行排序，然后找出重复的数量。

换句话说，我们把所有的端点记录下来，然后如果有倒在同一个端点的，那么一定是来自不同的竹竿，那么它们就产生了一对“优秀的竹竿”。

举个栗子，对于这个数据：
```
6 5
2 3 4 2 2 1
```
那么储存的结果就是这样的：
- $-1,-1,-1,2,3,5$ //向左倒
- $3,5,7,6,7,7$ //向右倒
- $-1,-1,-1,2,3,3,5,5,6,7,7,7$ //合起来排个序

于是，答案很明显了：
- 3个-1 3对$C^2_3=3$
- 2个3  1对$C^2_2=1$
- 2个5  1对$C^2_2=1$
- 3个7  1对$C^2_3=1$
- 合计  6对

感觉不是很好讲，希望你们能理解

速度根本不是一个数量级啊！

[我的代码](https://www.luogu.org/record/show?rid=11077511)

[和某题解的对比](https://www.luogu.org/recordnew/show/11086196)

因此，难度=PJ-

接下来，上代码：
```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
using namespace std;
long long n,m,t=0;
int a[400005];//a数组用于记录所有端点
int main()
{
    cin>>n>>m;
    for(int i=1;i<=n;i++)
    {
        int p;
        cin>>p;
        a[i]=i+p;//right!
        a[i+n]=i-p;//left!
    }
    sort(a+1,a+2*n+1);//找重复的
    int j=1;
    for(int i=2;i<=2*n;i++)//统计
        if(a[i]==a[i-1])
        {
            t+=j;
            j++;
        }
        else
            j=1;
    cout<<t;
    return 0;
}
```