## [题目链接](https://www.luogu.com.cn/problem/P8707)

典型的 dp 题（当然你也可以 dfs）。

每个格子能走到的方案数为其上、左两个格子方案数之和。因为只有这两个格子能走到它。

此题的唯一限制是“如果行号和列数都是偶数，就不能走入这一格中”。对于这一限制，解决方法其实并不难。可以在循环时进行判断，若能走就计算方法数，不能走就设置为 $0$。

但在处理 $[1,1]$ 时，会直接赋值为前两个格子的方案数。而这两个格子都默认为 $0$，所以应该把其中一个初值设为 $1$。

参考代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,_[33][33];
int main()
{
	scanf("%d%d",&n,&m);
	_[0][1]=1;
	for(int i=1;i<=n;i++)for(int j=1;j<=m;j++)if(i%2||j%2)_[i][j]=_[i-1][j]+_[i][j-1];
	printf("%d",_[n][m]);
	return 0;
}
```
感谢阅读！