### 题意简述

一个 $n$ 行 $m$ 列的图，除行与列皆为偶数的节点外的各个节点均连通，在只能够向下或向右的情况下，求从 $(1,1)$ 到 $(n,m)$ 的方案数。

### 思路简述

我们可以采用动态规划的方法，定义二维数组 $dp_{i,j}$ 表示从 $(1,1)$ 到 $(i,j)$ 点的方案数。

据题意只能够向下或向右走，可得每一个点 $(i,j)$ 只能够从 $(i-1,j)$ 或 $(i,j-1)$ 走过来，故方案数 $dp_{i,j}=dp_{i-1,j}+dp_{i,j-1}$。

另外，因为当行和列皆为偶数时，该节点不可用，所以 $dp_{2p,2q}=0$ $(p,q \in N*$ 且 $2p \le n,2q \le m)$。当然在实际程序中，我们枚举到行和列皆为偶数的点时，可以在置零后跳过该点。

接下来确定初始状态，显然从 $(1,1)$ 到 $(1,1)$ 有一种方案，故 $dp_{1,1}=1$。

最后输出答案，即 $(1,1)$ 到 $(n,m)$ 的方案数 $dp_{n,m}$。

### 代码

为排版美观，已将头文件及快读快写删去。

```cpp
// Author:zymooll
int n,m;
int dp[40][40];
signed main(){
	n=read(),m=read();
	dp[1][1]=1;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			if(i%2==0&&j%2==0)continue;
			dp[i][j]+=dp[i-1][j]+dp[i][j-1];
		}
	}
	cout<<dp[n][m];
	return 0;
}

```

### 备注

参考时间复杂度 $O(nm)$