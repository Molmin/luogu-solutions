### 题意简述

在一个矩阵中，每次可以向下或向右走，不能走到行数和列数都为偶数的格子上，问从 $(1,1)$ 走到 $(n,m)$ 有多少种方案。

***

### 解法

不知道搜索能不能过，最好考虑**动态规划**。

定义 $dp_{i,j}$ 为走到第 $i$ 行第 $j$ 列时的方案总数。

下面推状态转移方程。

只能向下或右走，说明某个格子，只能从上面或者左面走过来，这个格子的方案数，就是上面和左面两个格子的方案数之和，即 $dp_{i,j}=dp_{i-1,j}+dp_{i,j-1}$。

注意到不能走向行数和列数都为偶数的格子，于是把它的方案数当作 $0$ 处理，即 $dp_{i,j}=0$。

显然，初始格子只有 $1$ 种方案。

综上，状态转移方程为 $dp_{i,j}=\begin{cases}
1 & (i=1)\land(j=1) \\
0 & (2\mid i)\vee(2\mid j)\\
dp_{i-1,j}+dp_{i,j-1} & otherwise
\end{cases}$，（这里 $dp$ 数组初始都为 $0$）。

***

### 代码


```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,dp[31][31];
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++){
			if(i==1&&j==1)
				dp[i][j]=1;
			else if(i%2==1||j%2==1)
				dp[i][j]=dp[i-1][j]+dp[i][j-1];
		}
	printf("%d",dp[n][m]);
	return 0;
}

```
***

~~奇怪的是，我之前已经 AC 了这题，写这篇题解前又重写了一遍，还交了三次才过。~~