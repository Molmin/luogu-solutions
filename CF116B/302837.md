我有个疑问：这题要跑 Dinic 吗？

其实不要的，因为每一只猪的旁边只有一只狼，所以不用考虑两头狼“抢食物”那种情况，如下面的例子：

```
3 3
WpP
.W.
..W
```

我特地将一个 `P` 小写了，这是让大家很容易看出这头猪很“无助”，因为它会被两头狼“抢”着吃，123456zmy 大佬的代码是可以处理这种情况的。

我们再看一眼题目：there will be at most one wolf adjacent to each little pig，翻译过来就是一只猪的旁边（上下左右）只有一只狼，所以开数组统计就行啦！

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,ans;
char g[15][15];
int main()
{
	cin>>n>>m;
	for(int i=1;i<=n;i++) 
		for(int j=1;j<=m;j++)
			cin>>g[i][j];
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			if(g[i][j]!='W') continue;
			if(g[i+1][j]=='P'||g[i-1][j]=='P'||
			g[i][j+1]=='P'||g[i][j-1]=='P') ans++;
		}
	}
	cout<<ans;
	return 0;
}
```

一个问题的解答（如果不想看的话可以跳过）：

Q：网络流算法怎么解决？

A：我们新增一个源点 $S$ 和汇点 $T$，将 $S$ 与每只狼连边，将每一只狼与每一只与其相邻的猪连边，将每一只猪与 $T$ 连边，所有边的流量为 $1$ 且为有向边，然后跑最大流（EK 和 Dinic 均可），此时每一只猪只能被一只狼吃，因为每只猪猪和汇点通过的流量最大为 $1$，如果有两只狼去吃的话，那么流量为 $2$，此时就可以把这种“吃法”舍去，所以这个最大流算法是正确的。