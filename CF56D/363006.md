## 题解

所以这道题到底为了啥啊，不就是编辑距离板子题加上输出吗？

你考虑设状态 $f_{i, j}$ 为 $a$ 的前 $i$ 位，$b$ 的前 $j$ 位要匹配最少需要的步数，那么我们的初始化显然如下：

- $f_{0, i} = i$，意思是 $a$ 的前 $0$ 位和 $b$ 的前 $i$ 位匹配，只能插入 $i$ 个字符。

- $f_{i, 0} = i$，同理，只是只能删除 $i$ 个字符。

然后我们考虑转移，显然有删除，插入，替换三种转移：

- 删除：$f_{i, j} = \min(f_{i - 1, j})$，表示将当前 $a$ 的第 $i$ 位删掉，也就是把匹配字符串的第 $j + 1$ 位给删掉。

- 插入：$f_{i, j} = \min(f_{i, j - 1})$，表示当前匹配字符串的第 $j$ 位需要插入一个字符才能使得两个字符串匹配。

- 替换，分两种情况，当 $a_i = b_j$ 时：$f_{i, j} = \min (f_{i - 1, j - 1})$，当 $a_i \ne b_j$ 时：$f_{i, j} = \min (f_{i - 1, j - 1} + 1)$，这个很好理解，如果是相同的就不需要替换，如果是不同的，那么就都替换。

然后考虑输出怎么输出，我们可以使用搜索输出，考虑输出时的位置就是上述讲的匹配字符串的操作位置。

输出的代码放上来：

```cpp
void dfs ( int i, int j ) {
	if ( !i && !j ) {
		return ;
	}
	if ( i > 0 && f[i][j] == f[i - 1][j] + 1 ) {  // 需要删除
		dfs ( i - 1, j );
		cout << "DELETE " << j + 1 << '\n';
	}
	else if ( j > 0 && f[i][j] == f[i][j - 1] + 1 ) {  // 需要插入
		dfs ( i, j - 1 );
		cout << "INSERT " << j << " " << b[j] << '\n';
	}
	else if ( f[i][j] == f[i - 1][j - 1] + 1 ) {  // 需要替换
		dfs ( i - 1, j - 1 );
		cout << "REPLACE " << j << " " << b[j] << '\n';
	}
	else {  // 不需要任何操作
		dfs ( i - 1, j - 1 );
	}
}
```

然后你 DP 完之后就直接输出就可以了，这里就不放完整代码了。