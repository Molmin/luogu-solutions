计算对数，一开始降智直接写了个

```
a[++cnt] = { 1, x, q, 0 };
a[++cnt] = { 2, x - r, q, -1, i };
a[++cnt] = { 2, x + r, q, 1, i };
```
这样的东西，然后统计答案，结果Wrong answer on test 2

这样显然是不对的，因为有些对数会被统计两遍！

我们换一种方法：考虑两个点会产生关系，能互相看到

也就是我们按r从大到小排序，小的可以看到大的，那么大的一定可以看到小的

此时我们已经有了一种偏序关系，也就是r的偏序关系

然后我们考虑还有两个条件需要满足，一个就是能互相看见，还有一个就是他们的q要

满足相差不超过k

于是我们可以用cdq分治，因为cdq分治里面的关系我们可以自行调换里外

所以我们可以把不相差k放在外层，然后里层直接有个树状数组维护一下（要离散化）

具体的我们内层归并然后单调队列维护一下即可！

CDQ核心代码：

```cpp
while (L <= mid || R <= r) {
	if (R > r || (L <= mid && c[L].q <= c[R].q + K)) {
		Q[++qr] = mp(Get(c[L].x), c[L].q); Modify(Get(c[L].x), 1); L++;
	} else {
		while (ql <= qr && Q[ql].snd < c[R].q - K) Modify(Q[ql++].fst, -1);
		ans += Query(Get(c[R].x + c[R].rl)) - Query(Get(c[R].x - c[R].rl) - 1); R++;
	}
}
while (ql <= qr) Modify(Q[ql++].fst, -1);
```

主要要总结2点吧！

1 首先cdq的前提是找到偏序关系，我们可以根据题目找到偏序关系！

2 cdq里面往往有两层或者三层（既在cdq里面做的是二维或三维偏序）

这个层与层之间我们可以自己调换，然后找最简单的维护方法！！！