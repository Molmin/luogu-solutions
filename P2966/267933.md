[题面传送门](https://www.luogu.com.cn/problem/P2966)   
我的第一篇题解，有不对的地方请指正。
### 本篇题解的目的
- 这题使我陷入了多个误区，花了很久的时间，值得用我的第一篇题解来纪念。同时练习 Markdown 与 Latex 。
- 不像其他题解所说的，“点权和边权不能混在一起”，其实是有办法处理的。
- “为什么要对中转点按点权从小到大排序”其他题解讲的似乎不是很清楚。 ~~说得好像我能讲清楚一样~~   

### 思路
注意到数据范围：$ N \leq 250 $，$K \leq 10000 $。点数较小，询问数较多，可以使用 Floyd 算法将每对草地间的距离算出来。   
设路径 i -> j 的费用（同题意）为 $ f(i,j) $，那么每次询问回答的答案就是 $ f(s,t) $。由于路径中包含一个最大的草地过路费（点权），我们还需要记费用最少的 i -> j 路径上，最大的点权为 $ pm(i,j) $（包括 i, j ）。   
考虑路径 i -> h -> j，怎么通过中转点 h 更新 $ f(i,j) $ 呢？可以知道路径上最大的点权为 $ \max(pm(i,h),pm(h,j)) $。先在两边路径的费用中减去最大的点权并求和，然后加上连起来路径上最大点权，得到新路径   
$ l=f(i,h)+f(h,j)-pm(i,h)-pm(h,j)+\max(pm(i,h),pm(h,j)) $
如果 l 比 $ f(i,j) $ 小，则更新 f 和 pm。   
初始化：如果存在一条道路 (a, b) 过路费为 l，那么路径 a -> b 上的最大点权为 $ \max(c_a,c_b) $，费用为 l 加上最大点权。
### 代码（WA，30分）

```cpp
#include <bits/stdc++.h>
using namespace std;

int n,m,k,c[251],a,b,l,s,t,f[251][251],pm[251][251];
// 变量的含义与题目或题解中的相同

int main() {
	scanf("%d%d%d",&n,&m,&k);
	memset(f,0x3f,sizeof f);
	// 将 f 数组所有值初始化为0x3f3f3f3f，使得它近似无穷大，而两个这样大的数相加后又不会超过 int 范围 
	// 读入所有点权
	for(int i=1; i<=n; i++)
		scanf("%d",&c[i]);
	// 读入所有道路及其过路费（边权）并初始化
	for(int i=1; i<=m; i++) {
		scanf("%d%d%d",&a,&b,&l);
		pm[b][a]=pm[a][b]=max(c[a],c[b]);
		f[b][a]=f[a][b]=min(f[a][b],l+pm[a][b]);
		// 注意会有重边。我在这里卡了很久，也是看了其他题解才改过来的。有重边时要取边权最小的边。
	}
	// 下面是 Floyd 算法
	for(int h=1; h<=n; h++) // 枚举中转点
		for(int j=1; j<=n; j++)
			if(j!=h) for(int i=1; i<=n; i++) {
				if(i==j||i==h) continue;
				l=f[j][h] + f[h][i] - pm[j][h] - pm[h][i] + max(pm[j][h],pm[h][i]);
				if(l<=f[j][i])
					f[j][i]=l,
					pm[j][i]=max(pm[j][h],pm[h][i]);
			}
	// 读入每个询问并回答 
	for(int i=1; i<=k; i++) {
		scanf("%d%d",&s,&t);
		printf("%d\n",f[s][t]);
	}
	return 0;
}
```

### 改进
然而会发现这样的代码只有30分。  
参考其他大佬的题解，发现需要对中转点 _按点权_ **从小到大**排序。  
由于我 ~~懒，~~ 希望改动最少，于是   
- 用优先队列来确定中转点的顺序。在 main 函数前面加入如下代码：
```cpp
typedef pair<int,int> node; // first: c, second: i
// STL之pair真好用。使用时建议将first，second代表的意义记录在旁边以免忘记。
priority_queue<node,vector<node>,greater<node> > q;
```
- 读入每点点权时顺便将其加入优先队列。
```
		q.push(node(c[i],i));
```
- 将枚举中转点的循环改为如下while循环，并将接下来枚举 j 的循环放入```*|*```处

```cpp
	while(!q.empty()) {
		int h=q.top().second; q.pop();
		*|*
	}

```

### 疑问
为什么要对中转点 _按点权_ **从小到大**排序？为了帮助理解这个问题，我设法画出了这幅图：
[![](https://cdn.luogu.com.cn/upload/image_hosting/3w7tlhjx.png)](https://www.luogu.com.cn/paste/kpeywhum)   
转折点按点权从小到大遍历：   
通过h=3（点权为3），$ f(1,2)=7+8=15,\;f(1,4)=14+6=20 $   
通过h=2（点权为8），$ f(1,4)=f(1,2)+11-8-8+8=18 $   
转折点从1到n：   
通过h=2，$ l=8+4=12>11=3+8=f(3,4) $ 于是不通过 2；   
通过h=3，$ f(1,4)=f(1,3)-6+f(3,4)-3+6=20 $   
30分代码：？？？   

---
其他题解有的说玄学，多跑几遍就过了；有的解释了方便性（这样就能知道一条路径的最大点权是三个点的max）。目前我也不能严谨地说清楚它的正确性，于是去看了[USACO官网的Analysis](https://contest.usaco.org/TESTDATA/DEC09.toll.htm)。大意是，因为总费用分为边权和和最大点权，不妨先限定点权为某一特定值，求经过所有点的点权不超过一特定值的最优路径的费用。对于所有N个顶点，可以每次用 $O(n^3)$ 的算法求经过所有的点不超过该顶点权值的最优路径，然后取得到的N个费用的最小值作为答案。   
然而这样的算法时间复杂度为 $O(n^4)$，可以在 Floyd 的基础上优化。因为 Floyd 的是基于中转点的松弛操作的，算法算到中途时，每对点的费用就是只通过那些已枚举过的中转点的路径的最小费用。因此将中转的顺序按点权排序后，与上面的算法效果等同：第i次循环算出了每对点只经过那些点权不超过 _点权第i小的点_ 的点的路径的最小费用。（以上为翻译）   
值得注意的是，Floyd 算法是基于动态规划的思想的，数组 $ f(i,j) $ 隐藏了中转点（动规阶段）那一维，变为了滚动数组。如果不排序，那么这一维度是否还有意义？违背了动态规划的哪条适用条件？使30分代码不通过的某些图的共同性质能否用一些不等式关系描述？可以试着从这些角度否定30分的代码。然而我太菜了，想了一整天也想不出怎样严谨地说明这个的正确性，那个的错误。If someone could give me better explanations, I would appreciate it very much.