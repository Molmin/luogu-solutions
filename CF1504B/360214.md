## 题意简述

有一个操作：找到 $a$ 中一个前缀，使得它满足其中`0`和`1`的个数相等，将这个前缀中所有数翻转（`0`变成`1`，`1`变成`0`）。

求能否通过若干次操作使 $a$ 变成 $b$。

## 做法分析

Q：如何判断一个前缀中`0`和`1`的个数是否一样多？

A：我们可以提前把这个字符串的前缀和求出来，如果这个前缀中`1`的个数刚好是这个前缀长度的**一半**，那么就可以

Q：如何判断 $a$ 经过若干次翻转前缀可否变成 $b$？

A：因为同一个前缀反转偶数次都相当于没动，反转奇数次相当于翻转1次。我们定义 $pre_i$ 表示 $[0,i]$ 这个前缀。显然，我们翻转 $pre_i,pre_j\ (i<j)$ 那么 $pre_i$ 是没有变化的，相当于被翻转0次。

所以，我们这样考虑：

我们令 $flg_i$ 表示当前 $pre_i$ 是否被翻转了（**结果意义上**）。比如现在 $pre_3,pre_1$ 各翻转1次，那么我们发现 $pre_1$ 是没有变化的，因此 $flg_1=\tt{false}$。我们可以发现 $flg_i$ 亦可以表示 $a_i$ 有没有被翻转（**结果意义上**）。

然后，我们**从后往前**枚举 $a_i,b_i$，如果此时 $a_i=b_i$ 并且 $flg_i=\tt{false}$，那么正好不用给它翻转，$a_i\not=b_i$ 并且 $flg_i=\tt{true}$ 时同样，不用我们给它做过多操作，这一位已经被翻转过来，满足我们的要求了。

但是，如果此时 $a_i=b_i$ 而且 $flg_i=\tt{true}$ 了，意味着本不用翻转，但现在你给它反转了，此时就要**翻回来**，$flg_i\Leftarrow\tt{false}$。**但是**，不要忘记，能够给 $pre_i$ 翻转的前提是 $pre_i$ 中`1`和`0`的个数一样多。所以，一旦不满足，我们就直接跳出循环大胆地输出`No`。

同理，如果 $a_i\not=b_i$ 并且 $flg_i=\tt{false}$ 了，意味着需要反转，但是此时你并没有给它翻转，此时就要**给它翻**，$flg_i\Leftarrow\tt{true}$，并且检查 $pre_i$ 是否满足翻的要求。

一直这么遍历，直到结束。输出`Yes`。

## 我的代码

```C++
#include<iostream>
#define N 300000
using namespace std;

int pa[N]; // 前缀和
int main() {
    string a, b; bool flg;
    int t, n; cin >> t;
    while (t--) {
        cin >> n >> a >> b, pa[0] = a[0] == '1', flg = false;
        for (int i=1; i<n; i++) // 求前缀和
            pa[i] = pa[i-1] + a[i] - '0';
        for (int i=n-1; i>=0; i--) { // 倒序遍历
            // 不用再翻转了
            if (a[i] - '0' ^ b[i] - '0' == flg) continue; // 直接走
            // 需要翻转，但是不满足条件
            if (pa[i] * 2 != i + 1) goto DIE; // 直接死
            // 没死，那么大胆翻转
            flg = !flg;
        }
        cout << "YES\n"; continue; // 没死，说明可行，输出完直接走
        DIE: cout << "NO\n"; // 竟然死了，不可行
    }
    return 0;
}
```