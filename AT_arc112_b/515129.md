考虑将数轴分为正半轴和负半轴讨论（正半轴的数字大于 $0$，负半轴则小于 $0$），$B$ 变换得来的区间一个主要处于正半轴，一个处于负半轴，我们分别计算他们的左右边界：

对于与 $B$ 处于相同半轴的区间来说，向左扩展十分便捷，只需要一直重复 $2$ 操作即可，而向右扩展需要先进行一次 $1$ 操作，然后进行任意次 $2$ 操作后在用 $1$ 操作变换回来。设左右边界为 $L,R$，则：

$$L = B - \frac{C}{2},R = B + \frac{C-2}{2}$$

对于与 $B$ 处于不同半轴的区间，需要进行一次 $1$ 操作来保证区间主要处于不同半轴，如果将 $2$ 操作置于 $1$ 操作前，则得到的数字更大（因为 $2$ 操作的减法被乘上了 $-1$，使得最终答案增加），反之则更小。不需要两次以上的 $1$ 操作，因为可以通过安排 $2$ 操作的次序达到相同的效果。设左右边界为 $L,R$，则：

$$L = -B - \frac{C-1}{2},R = -B + \frac{C-1}{2}$$

如果区间有重复，需要在统计答案的时候去除重复区间。

将上述思路实现，得到代码：

```cpp
#include<bits/stdc++.h>
using namespace std;

long long B,C,ans;
long long l1,r1; //正数轴区间 
long long l2,r2; //负数轴区间 

int main() {
	cin >> B >> C;
	//初始认为 B>0 
	l1=B - (C / 2),r1=B + ((C - 2) / 2); 
	l2=(-B) - ((C - 1) / 2),r2=(-B) + ((C - 1) / 2);
	if(B<0) { //如果 B<0,正数轴和负数轴的情况就会反过来 
		swap(l1,l2);
		swap(r1,r2);
	}
	if(l1<=r2) l1=r2+1; //去除重复区间 
	ans+=(r1-l1+1)+(r2-l2+1); //计算结果
	cout << ans << endl;
	return 0;
}

```

一切似乎都很完美，但是这个代码过不去第三个样例，当 $B = 0$ 时，它并不在正数轴和负数轴上，加上特判即可。

AC 代码：

```cpp
#include<bits/stdc++.h>
using namespace std;

long long B,C,ans;
long long l1,r1; //正数轴区间 
long long l2,r2; //负数轴区间 

int main() {
	cin >> B >> C;
	//初始认为 B>0 
	l1=B - (C / 2),r1=B + ((C - 2) / 2); 
	l2=(-B) - ((C - 1) / 2),r2=(-B) + ((C - 1) / 2);
	if(B<0) { //如果 B<0,正数轴和负数轴的情况就会反过来 
		swap(l1,l2);
		swap(r1,r2);
	}
	if(B==0) l2=l1,r2=r1;//如果 B == 0,不在正数也不在负数轴上需要特判 
	if(l1<=r2) l1=r2+1; //去除重复区间 
	ans+=(r1-l1+1)+(r2-l2+1); //计算结果
	cout << ans << endl;
	return 0;
}

```
