首先可以肯定，Gregor 的棋子在最后 $n-2$ 行的所有格子都只能向前走，所以我们假设 Gregor 的棋子一开始就在第二行。按照题意，它们现在有三种选择：

- 如果左前方有敌人棋子，可以走到左前方
- 如果右前方有敌人棋子，可以走到右前方
- 如果正前方无敌人棋子，可以走到正前方

我们考虑贪心。从左往右枚举每颗 Gregor 的棋子，能往左前方走就往左前方走，否则能往正前方走就往正前方走，实在不行才往右前方走。

我们发现有这么一个事实，如果一个棋子可以往前走，那么只有它可以到达它前面的位置。

至于证明贪心的正确性，我们得从贪心的条件**无后效性**入手。我们采用类似数学归纳法的思路：

考虑左边第一颗棋子，易得按照这种方法走，肯定能达到当前的局部最优。

考虑其他情况，我们假设它左边所有的棋子都能够通过这种走法达到最优，那么这颗棋子分两种情况:

1. 它有地可走，那么全局肯定是最优的
2. 它无地可走。如果它本来就无地可走，那无关紧要。否则的话，只能是因为自己正前方和右前方都走不了，左前方还被棋子占了。而占领这格的棋子一定是“迫不得已”才向右前方走来到这里的，因此，如果这颗棋子不走这里，那么必定会有一颗棋子不能到达。所以此时依然是全局最优解。

代码：

```C++
#include<iostream>
#include<cstring>
#define N 200000
using namespace std;

bool mch[N];
int main() {
    int t, n, cnt; string a, b; cin >> t;
    while (t--) {
        cin >> n >> a >> b, memset(mch, cnt=0, sizeof(mch));
        for (int i=0; i<n; i++) if (b[i] - 48) {
            if (i && !mch[i-1] && a[i-1] == '1') mch[i-1] = true, cnt++;
            else if (!mch[i] && a[i] == '0') mch[i] = true, cnt++;
            else if (!mch[i+1] && a[i+1] == '1') mch[i+1] = true, cnt++;
        }
        cout << cnt << '\n';
    }
    return 0;
}
```

