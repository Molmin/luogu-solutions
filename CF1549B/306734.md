## 2021.8.1 CodeForces Div.2 B题

#### 题目大意:
给定一个 $N\times N$ 的棋盘，第一行有若干个敌方棋子，第 $N$ 行有若干个己方的棋子，敌方棋子**不可移动**，己方棋子有两种前进方式，求最多能有多少个己方棋子到达第一行。


### 对于一个坐标为 $(i,j)$ 的己方棋子，前进规则如下：

- 如果正上方上一格 $(i+1,j)$ **没有棋子**，则可以直接向正上方前进一格。

- 如果**左上方**一格 $(i+1,j-1)$ 或**右上方**一格 $(i+1,j+1)$ 有**对方**的棋子，则可以跳到左上方或右上方并**吃掉**对手的棋子。



## Solution

- **模拟**即可

- 首先我们可以直接**忽略**第 $2$ 行至 $n-1$ 行，因为敌方棋子不可移动且都在第 $1$ 行，中间这些部分都只能向上走一格，所以**只需要开两个一维数组**即可。


- 如果第 $i$ 列**没有敌方棋子**，则第 $i$ 列的己方棋子可以一路北上到第 $1$ 行。

- 如果第 $i-1$ 列**有敌方棋子**，则第 $i$ 列的己方棋子可以一路北上到第 $2$ 行再跳到左上方并吃掉敌方棋子。

- 如果第 $i+1$ 列**有敌方棋子**，则第 $i$ 列的己方棋子可以一路北上到第 $2$ 行再跳到右上方并吃掉敌方棋子。

- 计数器累加即可。

- 注意:
	1. 只有第 $i$ 列**有己方棋子**才可以进行上面这三种操作。
   2. 一枚棋子只可以到 $i-1$ ，$i$ ，$ i+1$ 这三处的其中之一，**不要重复计算**。
   3. 多次询问，数组不要忘了**初始化**。

## Node
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=2e5+10;
bool a[N],b[N];
int main(){
	int T;
	cin>>T;
	int n;
	char x;
	int ans=0;
	while(T--){
		memset(a,0,sizeof a);
		memset(b,0,sizeof b);
		ans=0;
		cin>>n;
		for(int i=1;i<=n;i++){
			cin>>x;
			a[i]=x-'0';
		}
		for(int i=1;i<=n;i++){
			cin>>x;
			b[i]=x-'0';
		}
		for(int i=1;i<=n;i++){
			if(a[i]==0&&b[i]==1){
				ans++;
			}else if(b[i]==1){
				if(a[i-1]==1){
					a[i-1]=0;
					ans++;
				}else if(a[i+1]==1){
					a[i+1]=0;
					ans++;
				}
			}
		}
		cout<<ans<<endl;
	}
	return 0;
}
```

