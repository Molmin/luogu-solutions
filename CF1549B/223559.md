### 解题思路：

考虑贪心，从左向右枚举棋子，对于当前的一个棋子若能向前移动到顶就移动到顶，否则若左边有敌方棋子就向左，最后考虑右边有敌方棋子则向右移动。

----
然后考虑如何保证这样的一个贪心的正确性：

对于第一种情况，当前行的空地只有当前行的能利用，所以直接考虑向前移动。

第二种，由于是从左往右枚举，则一旦过了这一格就再也没有棋子能利用这一格了，所以也直接利用。

第三种，这一种情况有可能占用到右边的第二个棋子的向左移动方案。但我们发现，假如向右移动不进行，若这时右边有棋子，那么这样的一个位置也只能提供 1 的价值，和直接向右移动无异，但如果右边没有棋子就不是最优方案了，考虑到以一定不会比不移劣，所以在贪心的时候可以直接选择移动。

----------
### 代码：

```cpp
#include<cstdio>
#include<cstring>
using namespace std;
int T,n,a[200005],b[200005],ans;
int main(){
	scanf("%d",&T);
	while(T--){
		ans=0;
		scanf("%d",&n);
		a[0]=b[0]=a[n+1]=b[n+1]=0;
		for(int i=1;i<=n;i++)scanf("%1d",&a[i]);
		for(int i=1;i<=n;i++)scanf("%1d",&b[i]);
		for(int i=1;i<=n;i++)
		if(b[i]){
			if(a[i]==0)ans++;
			else
			if(a[i-1]==1)a[i-1]=2,ans++;
			else
			if(a[i+1]==1)a[i+1]=2,ans++;
		}
		printf("%d\n",ans);
	}
	return 0;
}
```
