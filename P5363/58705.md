**题意** ： 有一条长度为 $n$ 的纸带，上面有 $m$ 个棋子。

每次操作可以将一枚棋子向右移动若干格，但不能跨过其他棋子，棋子不能重叠。

现在有两人轮流操作，不能操作者负。

求在所有的 $\binom{n}{m}$ 种初始状态中，有多少种先手必胜。

答案对 $10^9+9$ 取模。

$n\leq 1.5\times 10^5,m\leq 50$ ，时限$\texttt{1s}$。

------------

首先分析这个游戏先手必胜的充要条件。

将每个棋子后面的空位看作一堆石子，移动棋子时，相当于把自己的石子给了上一个棋子。

不难发现这等价于阶梯 $\rm Nim$ 问题，结论是 ： 若奇数阶梯上石子数的异或和非 $0$ ，则先手必胜。

问题转化成 ： 将 $n-m$ 个石子分成 $m+1$ 堆（最左侧有一堆不属于任何棋子），问有多少种情况使得偶数堆石子异或和非 $0$。

非 $0$ 不太好统计，取个补集变成 $=0$。

考虑 $\rm DP$，设 $f[i][j][k]$ 表示已经分出 $i$ 堆，使用了 $j$ 个棋子，目前偶数堆异或和为 $k$ 的方案数。

转移时枚举下一堆放多少，复杂度为 $O(mn^3)$，无法通过。

我们最终只关心 $k=0$ 的情况，上述方法记录了大量无用状态。

根据位运算的性质，逐位考虑，设 $f[t][i][j][0/1]$ 表示考虑到第 $t$ 位，保证此时偶数堆已确定的前 $t-1$ 位异或和为 $0$ ，正在安排第 $i$ 堆石子的第 $t$ 位，目前该位异或值为 $0/1$，且用了 $j$ 个棋子。

转移显然是 $O(1)$ 的，复杂度为 $O(nm\log n)$。已经可以通过。

然而注意到最终只关心 $j=n-m$ 的情况，于是可以进一步化简 ：

记 $N=n-m$ ，考虑 $N$ 的某一位，有两种来源，一是在某一轮种放置了这样的一位，二是进位而得。

设 $g[t][i][s][0/1]$ 表示已经**从高到低**考虑到了第 $t$ 位，保证此时偶数堆已确定的高位异或和为 $0$ ，正在安排第 $i$ 堆石子的第 $t$ 位，目前该位异或值为 $0/1$，欠下的进位和为 $s$。

看起来似乎和原来的 $f$ 没什么区别，但是能够发现，显然有 $2^t|s$ ，而且，若 $s/2^t>m+1$ 则不可能补完进位。

所以，第三位改为记录 $s/2^t\leq m+1$ ，复杂度改进为 $O(m^2\log n)$。

还可以进一步优化，注意到每一堆的地位是相同的，没必要将堆数写进状态中。于是记 $g[t][s]$ 表示处理完 $t$ 及以上的所有位，欠下的进位和为 $2^ts$ 的方案数。

转移时枚举第 $t$ 位填写的 $1$ 的个数 $k$ ，有

$g[t][2s-k]\leftarrow g[t+1][s]*p(k,m+1)$

其中 $p(k,m)$ 指将 $k$ 个 $1$ 分给 $m$ 堆，满足偶数堆有偶数个 $1$ 的方案数。容易预处理。

不难发现这是个加法卷积，使用 FFT 即可做到 $O(m\log m\log n)$。

代码 ：上述做法暴力卷积， $O(m^2\log n)$

```cpp
#include<algorithm>
#include<cstdio>
#define ll long long
using namespace std;
const int mod=1000000009;
ll powM(ll a,int t=mod-2){
  ll ret=1;
  while(t){
    if (t&1)ret=ret*a%mod;
    a=a*a%mod;t>>=1;
  }return ret;
}
ll fac[55],ifac[55],p[55];
ll C(int n,int m)
{return fac[n]*ifac[m]%mod*ifac[n-m]%mod;}
void Init(int n)
{
  fac[0]=1;
  for (int i=1;i<=n;i++)
    fac[i]=fac[i-1]*i%mod;
  ifac[n]=powM(fac[n]);
  for (int i=n;i;i--)
    ifac[i-1]=ifac[i]*i%mod;
  int a=n/2,b=(n+1)/2;
  for (int k=0;k<=n;k++)
    for (int i=0;i<=a;i+=2)
      if (0<=k-i&&k-i<=b)
        p[k]=(p[k]+C(a,i)*C(b,k-i))%mod;
}
ll g[20][55];
int n,m;
int main()
{
  scanf("%d%d",&n,&m);
  Init(m+1);
  g[18][0]=1;
  for (int t=17;t>=0;t--){
    int fl=(((n-m)>>t)&1);
    for (int s=0;s<=m+1;s++)
      for (int k=0;k<=m+1;k++){
        int u=2*s-k+fl;
        if (0<=u&&u<=m+1)
          g[t][u]=(g[t][u]+g[t+1][s]*p[k])%mod;
      }
  }
  ll buf=ifac[m];
  for (int i=1;i<=m;i++)buf=buf*(n-i+1)%mod;
  printf("%lld",(buf+mod-g[0][0])%mod);
  return 0;
}
```