# 花匠
真的没有看明白DP是什么情况……而且我觉得好像不一定要用DP吧_(:з」∠)_ 

我使用了贪心的方法(〃'▽'〃)

之前的大佬不少使用了这样的方法，但是我还是稍作了修改，改动了一部分我觉得不太对的地方并且准备对部分内容做一下解释ヾ(๑╹◡╹)ﾉ"


------------

首先主要的想法就是：先根据前2个（不包括相等情况详见注释1）确定方向，然后，我们根据题意判断：**答案想要这样的波浪线~~~~，就是 _高矮高矮高矮_ 。**
机智的我们决定创造这种美丽的波浪线。所以确定了方向以后——

如果一开始是下降的，就找第一个突然开始上升的，ans++，把方向改掉，反之同理。我们用o表示方向。
0是现在上升，1是下降

我想了想……决定用文言文注释的方法解决具体的内容qwq

-----( • ̀ω•́ )✧---------阔耐的分割-------------------------------------------------
1. 首先我们考虑一种比较烦人的情况，比如输入3 1 1 1，比较遗憾的是， 前面几位大佬的题解答案是2…… 然而emmm当输入1 1，答案也是2……

	我认为问题在于只考虑了前两个，然前两个可能是一样的，这个时候就无法确定方向了。所以我选择用while循环找**第一盆**与第一盆花**不一样**的花，根据她判断方向。如果没有 这种花，就是全是一样的，就只能留一盆了 真是个悲伤的故事嘤TAT。
1. 处理完开头，结尾也需要处理~~写了好久嘤~~。如果是这样的数据10 1 83 31 100 68 53 40 81 66 0~~为什么是这一个呢，因为我在这里wa了~~处理到81时，因为目前上升而且66<81,ans++,方向变成下降，然后到66,0<66所以不能选，到0,（下一位还是0）0=0,也不行！！！TAT所以如果到n是下降，那么要加一，因为n+1位是初始值0，也是下降，会少选一个，华丽的wa出新天地

	那么如果是上升呢？8 1 83 31 100 68 53 40 81 ，程序运行到81时，是上升状态，需要下降，n+1是0，正正好好小于81~就不需要判断啦，会加一的(￣^￣)


------------

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<algorithm>
#include<cstring>
#include<queue>
using namespace std;
int n;
int ans;
int o;
int f[100010];
int main()
{
    cin>>n;
    for(int i=1;i<=n;i++)
    {
        cin>>f[i];
    }
    if(f[1]>f[2])//1
    {
        o=1;
        ans++;
    }
    if(f[1]<f[2])//1
    {
        o=0;ans++;
    }
    if(f[1]==f[2])//1
    {
        int b=2;
        while(f[1]==f[b]&&b<=n)
        {
            b++;
        }
        if(b>n)
        {
            cout<<1;
            return 0;
        }
        if(f[1]<f[b])
        {
            o=0;ans++;
        }
        if(f[1]>f[b])
        {
            o=1;ans++;
        }
    }//以上注释1
    for(int i=1;i<=n;i++)
    {
        if(o==1&&i==n)
        {
            ans++;
            break;
        }//2
        if(o==0&&f[i]>f[i+1])
        {
            o=1;ans++;
            continue;
        }
        if(o==1&&f[i]<f[i+1])
        {
            o=0;ans++;
            continue;
        }
    }
    cout<<ans;
}
```