# 贪心法
#### Greedy Algorithm
贪心法直观地做出

局部性最优决策

试图找到全局性最优解

### 贪心法思维框架
“依次找最@#$%的...就把它...”

“每次发现有*&^%特点的...就把它

(**题意**) 花的整数高度h1,h2,...,hn 移走一部分花后，剩下花的高度

依次为g1,g2,...,gm ，以下两个条件中至少要满足一个：

条件A ：对于所有g2i>g2i−1, g2i>g2i+1

条件B ：对于所有g2i<g2i−1, g2i<g2i+1

请问，最多能将多少株花留在原地。m可以为1

1≤n≤105, 0≤hi≤10^6

**除了两边端点以外**

**每次发现高度拐点，就保留下来**

# 花匠：错误代码
```cpp
#include<iostream>
using namespace std;
int n,cnt=0,x[100005];
int main(){
	cin>>n; 
	for(int i=0;i<n;i++)cin>>x[i];
	for(int i=1;i<n-1;i++){
		int a=x[i]-x[i-1];
		int b=x[i]-x[i+1];
		if(a*b>0)cnt++;
	}
	cout<<cnt+2<<endl;
	return 0;
}



```
思考：**错在哪里？**

**如何修改？**

# 花匠：构造数据
```
输入样例
5
5 3 1 1 2
输出样例
3
```
**（相邻数相同）**
```
输入样例
3
6 6 6
输出样例
1
```
**（全部数相同）**
```
输入样例
3
1 1000000 1
输出样例
3
```
**（数值差很大）**
# 花匠
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,cnt=0,x[100005];
int main(){
	cin>>n; 
	n=1; cin>>x[0];
	while(cin>>x[n])
		if(x[n]!=x[n-1])n++;//去重
	for(int i=1;i<n-1;i++){
		int a=x[i]-x[i-1];
		int b=x[i]-x[i+1];
		if(a>0&&b>0||a<0&&b<0)//找拐点
			cnt++;
	}
	if(n==1)cout<<1;//判特例
	else cout<<cnt+2<<endl;
	return 0;
}
```
# 贪心法总结

把解答拆成多个步骤，每步依次执行

每一步都找局部最优解

**（有时排序操作能启发算法）**

“依次都找最@#$%的...就把它...”

“每次发现有*&^%特点的...就把它...”

### 从边边角角入手最容易确定局部最优解

# 后记
虽然对于有些最优化问题

贪心法并不是正确解法

但贪心法的解可能是近似解

也可以作为启发式搜索的参照

一般情况，贪心法复杂度都不高