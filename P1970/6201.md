代码和楼下有一位的方法是一样的，但我自认为楼下关于转移讲的不是很详细，这里主要讲一下方程的转移

dp1和dp2的作用已经在代码中打上注释，这里直接进入转移


读懂题目会发现留下的根据高度来看会是一个锯齿的形状，所以很容易得出当h[i] == h[i - 1]时两个dp数组都不加改动

而这个方法最精髓的敌方在于两个dp数组要互相转移，至于为什么是互相转移而不是单独转移，这里给出说明：


首先需要明确就是每个锯齿的长度(找不到很好的形容词)一定是1，例如1  2  0  2  1就是符合要求的

而为什么不可能长度大于1呢，我们随便举出一个例子 0   1   2   3   2   1   0，这样如果2处于偶数为，则它不符合要求，如果2处于奇数位，则

1便不符合要求，有的朋友可能会问如果把两个0去掉不就可以组成一个长度大于1的锯齿了吗，但是要注意如果1前面的数大于1，则锯齿的长度就有变回了1，如果1前面的数小于1，则就会像例子一样不合要求，当锯齿长度更大时也是如此，所以锯齿长度最大为1


得出了这个结论，我们可以知道假设最后留下的花是符合要求的，那么如果h[i] > h[i - 1] 则h[i - 1]必然小于h[i - 2]所以如果h[i] > h[i - 1]则这一步的转移必须上一步在i-1时是在下降的序列转移过来的，而当h[i] < h[i - 1]的时候同理，必须由上一步在i - 1时是上升的序列转移过来，这也是为什么两个dp数组要互相转移的原因


理解了为什么要这样转移，那么循环中的方程就很好理解了，下面是代码

[codec]




    
        
    
    
    
```cpp
#include <fstream>
#include <iostream>
using namespace std;
ifstream fin("flower.in");
ofstream fout("flower.out");
inline int max(int a, int b){
    if(a > b)
        return a;
    else
        return b;
}
int main(){
    int dp1[100005], dp2[100005], n, h[100005];//dp1[i]表示当扫到i是序列正在上升的最长序列, dp2[i]表是当扫到i是序列正在下降的最长序列, h[i]表示高度
    fin>>n;
    dp1[0] = dp2[0] = 1;
    for(int i = 0;i < n;i++)
        fin>>h[i];
    for(int i = 1;i < n;i++){
        if(h[i] > h[i - 1]){
            dp1[i] = dp1[i - 1];
            dp2[i] = max(dp2[i - 1], dp1[i - 1] + 1);
        }
        if(h[i] == h[i - 1]){
            dp1[i] = dp1[i - 1];
            dp2[i] = dp2[i - 1];
        }
        if(h[i] < h[i - 1]){
            dp1[i] = max(dp1[i - 1], dp2[i - 1] + 1);
            dp2[i] = dp2[i - 1];
        }
    } 
    fout<<max(dp1[n - 1], dp2[n - 1])<<endl;
    fin.close();
    fout.close();
    return 0;
}
```
[/codec]
祝大家愉快地AC
