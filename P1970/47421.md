```cpp
//假设花是按如下高度和方式排序的:
// 0      0    0      0
//   0  0  0      0    0
//     0      0  0  0
//不难发现，我们要找的花其实就是
// 1      1    1      1
//   0  0  0      1    1
//     1      1  1  1
//也就是每次上升或下降的转折点上
//而这些转折点再加上首尾的两盆花就是我们要求的结果
//如果花的位置较为特殊，没有具体的一个转折点，如:
// 0            0 我们就将它变为 0            0 即可得到具体唯一的转折点 
//   0        0                            0 0 0  0
//     0 0 0                                     0
//这样做还有最后一个问题(但数据太水没有这种情况，我就懒得判断了):
//如果所有花的高度都一样，只能放一朵，但我将首尾都加了，导致输出变为2(可惜数据没有)
//时间复杂度O(n)
#include <bits/stdc++.h>
using namespace std;
int a[100100] = {0};
int main(void)
{
    int ans = 0;
    int n;
    cin >> n;
    for (int i = 1; i <= n; i++) cin >> a[i];
    for (int i = 2; i < n; i++) {
        if (a[i] == a[i+1]) a[i] = a[i-1]; //如果第i盆花与第i+1盆花一样高，就将第i盆花变为第i-1盆花的高度
        if (a[i] > a[i-1] && a[i] > a[i+1] || a[i] < a[i-1] && a[i] < a[i+1]) ans++; //判断是否在转折点上
    }
    cout << ans+2; //最后加上首尾
    return 0;
}
```