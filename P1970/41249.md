嗯……其实我不会正解，严格来讲我只会70分dp，剩下的30分是骗出来的

好吧这道题我确实有点“面向数据编程”了

70分dp的原理很简单，规定dp[i][1]或者dp[i][0]（\_1表示该找下降的花朵了，0表示该找上升的花朵了\_）是**以i为结尾的**，应该寻找上升或者下降的花朵的时候最大能保留的花朵数。

以dp[i][0]为例，寻找上升花朵的前一步应该是寻找的下降的花朵，因为正解有点类似于波浪嘛，转移的时候应该是寻找前面的下降的花朵，同时一个状态可能由多种状态转译而来，所以我们还是维护一个最大值比较好（保险起见嘛~）

dp[i][0]=max(dp[i][1]+1,dp[i][0]);

dp[i][1]=max(dp[i][0]+1,dp[i][1]);

我在转移的时候维护了一个ans值，因为正解不一定是以最后一朵花结尾的，这点要注意。

还有就是转移方程的时候一定记得加一，要不然半天白折腾了。

只剩下一朵花肯定是满足条件的，故dp[1][1]和dp[1][0]都是1。

70分dp的好处就在于5分钟拿到70分，性价比还是比较高的。

剩下的30分原理和70分dp原理相同，但是数据上不是说hi不基本上都是均匀分布的吗？所以正解来讲的话应该不会让前一朵花距离自己太远，那么我就随便选取了一个数（100，非常好）往前找，太久远的花朵就不找了，节约时间。


```cpp
#include<iostream>
#include<cstdio>
using namespace std;
int n;
int w[100007];//花朵的高度
int dp[100007][2];//转移数组，0上升，1下降 
int main(){
    //freopen("flower.in","r",stdin);
    //freopen("flower.out","w",stdout);
    int ans=0;
    cin>>n;
    if(n<=1000)//特判n的大小，使用不同的算法，方便骗分，“面向数据编程”
    {
        for(int i=1;i<=n;i++)
        {
            cin>>w[i];
        }
        dp[1][0]=1;
        dp[1][1]=1;
        for(int i=2;i<=n;i++)
        {
            for(int l=1;l<i;l++)
            {
                if(w[l]<w[i])
                {
                    dp[i][1]=max(dp[i][1],dp[l][0]+1);
                    ans=max(dp[i][1],ans);
                }
                else if(w[l]>w[i])//注意如果前面的花等于自己的高度的时候**不能参与转移！！**（论70分算法得了60分）
                {
                    dp[i][0]=max(dp[i][0],dp[l][1]+1);
                    ans=max(dp[i][0],ans);
                }
            }
        }
               cout<<ans;
    }
    else
    {
        for(int i=1;i<=n;i++)
        {
            cin>>w[i];
        }
        dp[1][0]=1;
        dp[1][1]=1;
        for(int i=2;i<=n;i++)
        {
            for(int l=max(1,i-100);l<i;l++)
            {
                if(w[l]<w[i])
                {
                    dp[i][1]=max(dp[i][1],dp[l][0]+1);
                    ans=max(dp[i][1],ans);
                }
                else if(w[l]>w[i])
                {
                    dp[i][0]=max(dp[i][0],dp[l][1]+1);
                    ans=max(dp[i][0],ans);
                }
            }
        }
                cout<<ans;
    }
    return 0;
}
```