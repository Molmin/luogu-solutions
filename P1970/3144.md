看到没有C/C++的题解，就来写一份（p党也能看懂，其实只有70%的cpp程序，100%的只讲思路233） 。


首先，我们可以发现满足条件A或B的都是数据上升下降交替出现的。我们设F(i)表示以第i个数结尾的，且最后一段是上升的上升下降交替出现的序列的最长长度；G(i)表示以第i个数结尾的，且最后一段是下降的上升下降交替出现的序列的最长长度。

可以很容易的发现：F(i) = max{G(j) + 1}(1 <= j < i且H(i) > H(j))， G(i) = max{F(j) + 1}(1 <= j < i且H(i) < H(j))

ans = max{max{F(i)}, max{G(i)}}

那么可以很容易写出如下程序段：


```cpp
for(i = 2; i <= N; i++) {
    F[i] = 1, G[i] = 1;
    for(j = 1; j < i; j++) {
        if(H[i] > H[j])
            F[i] = max(F[i], G[j] + 1);
        if(H[i] < H[j])
            G[i] = max(G[i], F[j] + 1);
    }
        Ans = max(Ans, max(F[i], G[i]));
}
```

很显然O(n^2)的算法只能过70%的数据，我们再考虑优化。


我们换一种设法。

设F(i)表示前i个数中，最后一段是上升的上升下降交替出现的序列的最长长度；G(i)表示前i个数中，最后一段是下降的上升下降交替出现的序列的最长长度。

我们可以得到：

①若H(i) > H(i - 1)，则F(i) = max{F(i - 1), G(i - 1) + 1}， G(i) = G(i - 1)

②若H(i) = H(i - 1)，则F(i) = F(i - 1)， G(i) = G(i - 1)

③若H(i) < H(i - 1)，则F(i) = F(i - 1)， G(i) = max{G(i - 1), F(i - 1) + 1}

ans = max{F(n), G(n)}

这样也就很好写出代码了（代码略，就当看懂了自己再练习一下代码能力吧233）。


顺便一提，这样F数组和G数组可以优化成滚动数组甚至两个变量。

再顺便一提，其实还可以把连续的单调数据缩成一个，只记录拐点进行处理（未测试）。
