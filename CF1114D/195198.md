## 题意

首先，定义一串数如果这串数字全部相同，那么这串数被称为“联通串”。现在给定一个串，每次可以把一个联通串中每一个数变成任意数字，求最少把整个串变成联通串的次数。

## 算法

首先这显然是在区间里面操作（~~搞事情~~），所以我们要使用区间DP解决此题。

定义 $dp[i][j]$ 表示从 $i$ 到 $j$ 变成联通串的最小刷的次数。那么分成两种情况：

- $a[i] = a[j]$：我们可以把 $[i + 1, j - 1]$ 的数刷成联通串，再刷一次。所以得到：$dp[i][j] = dp[i + 1][j - 1] + 1$。

- $a[i] \ne a[j]$：我们选择把 $[i, j - 1]$ 刷成联通串再刷一次 $a[j]$，或者把 $[i + 1, j]$ 刷成联通串，再刷一次 $a[i]$。

所以我们得到转移方程。

### 但是！

有可能会出现这种情况：```1 1 1 1 1```，这时我们-从 $dp[2][3]$ 转移到 $dp[1][4]$ 时其实是不需要 $+ 1$ 的，但是我们的程序不能做到。所以我们要把一开始的联通串变成一个数，这样就可以有效的避免这种情况。

那么我们就解决了这道题。代码不是很复杂，但是各种情况要考虑全。

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
int dp[5005][5005],a[5005],tot; //tot记录非联通串的数字个数
signed main()
{
	int n; cin>>n>>a[++tot];
	for(int i=2;i<=n;i++)
	{
		int x; cin>>x;
		if(x==a[tot]) continue; //如果能和上一个数组成联通串那么不选
		else a[++tot]=x;
	}
	//普通区间DP
	for(int i=2;i<=tot;i++)
	{
		for(int l=1;l+i-1<=tot;l++)
		{
			int r=l+i-1;
			if(a[l]==a[r]) dp[l][r]=dp[l+1][r-1]+1;
			else dp[l][r]=min(dp[l+1][r],dp[l][r-1])+1;
		}
	}
	cout<<dp[1][tot]; //输出从 1 到 tot 的最小次数
	return 0;
}
```