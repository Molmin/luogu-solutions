为什么 CF 有这么多板题啊，我十五分钟内轻松搞定，结果一看 dalao 写的题解竟然跟我写的这么像还比我简洁，我真的直接给大佬 orz 了，但是总觉得我做题时碰到的一些小障碍楼下好像并没有解释特别详细，所以我就再发一个题解让后来人能清楚一点吧（~~主要是来水题解~~）

### 一、预处理：

预处理的有无无疑是这个题 TLE 或 AC 的关键之一。判断与一个位置 $p$ 的颜色连通块的朴素方法显然是从左右分别向前走到第一个不同的颜色，但是复杂度极端情况就是 $O(N)$，简直就在 TLE 的边缘上疯狂试探啊。所以，我们可以在输入时把每个连通块都缩成一格，不仅可以为 $O(N^2)$ 的算法打基础，而且等状态转移的时候你就会直呼真香。

### 二、关于连通块
预处理过后是没有连通块的，即当且仅当区间 $[l,r]$ 有 $l = r$ 时是连通块。通过数学归纳法可以证明如下结论：

- 若 $c_l=c_r$，那么把 $[l,r]$ 涂色所需步数就是把 $[l+1,r-1]$ 涂色所需步数加一。

证：

设结论对 $l + k=r$ 成立。对于预处理之后的方块，当 $k = 2$ 时显然是成立的，即染成 $l+1$ 上的颜色。

同理，当 $k = 3$ 时，$[l,l+2]$ 已被证明是连通的，所以此时只用把 $l+3$ 染上色。

由此我们可以得出，$[l,l+k-1]$ 是连通的，只需要把 $l+k$ 染成相同色。

证毕。

- 若 $c_l≠c_r$，那么把 $[l,r]$ 涂色所需步数就是把 $[l+1,r]$ 涂色所需和 $[l,r-1]$ 涂色所需的最小值加一。

证明与上个结论相同，但是因为 $c_l≠c_r$，所以就会有两种染色决策。

### 三、初始化和目标
根据二的结论，初始化之后就满足合并的合法，所以不用像石子合并那道题一样分别初始化为 $0$ 和无穷。目标是把 $1$ 到 $N$ 合并，即：$d_{1,N}$。

### 四、代码
这是带注释版的，为了方便大家~~复制~~学习，这还有[无注释版](https://www.luogu.com.cn/paste/db8vhjap)
```cpp
#include <cstdio>
#include <iostream>
using namespace std;
int r, n, c[5001], idx = 0, a, d[5001][5001];
void DP(int l, int r){
	if (c[l] == c[r]){//因为已经有预处理和顺推，所以[l,r]的最大子区间[l+1,r-1]是颜色联通块(但是与c[l]和c[r]不同)，这时只需要染一次色。 
		d[l][r] = d[l + 1][r - 1] + 1; 
	}else{//如果不同，那么根据前面的推测，[l,r-1]和[l+1,r]也是颜色联通块，取最小代价再加一即可 
		d[l][r] = min(d[l][r - 1], d[l + 1][r]) + 1; 
	}
}
int main(){
	scanf("%d", &n);
	//预处理，因为判断颜色联通块在极端情况下是O(N)，所以提前把一个联通块缩成一个格 
	for (int i = 1; i <= n; i++){
		scanf("%d", &a);
		if (a != c[idx]){
			idx++;
			c[idx] = a;
		}
	}
	n = idx;
	//开始套路
	for (int i = 1; i < n; i++){ //枚举合并的跨度
		for (int l = 1; l <= n - i; l++){ //左端点 
			r = l + i;//右端点
			DP(l, r); 
		} 
	}
	printf("%d", d[1][n]);
	return 0;
}
```
题目不难，蒟蒻也没有什么创新，但是看在我写得~~这么多~~还算多份上管理员给过吧 QAQ