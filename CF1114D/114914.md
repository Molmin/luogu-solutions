这个数据是不是有点水，我 dp 执行的时候不小心把去重后的 cnt 写成了去重前的 $n$ 还过了。。

#### Description

> 给定一个长为 $n$ 的序列 $a_i$，每次可以将一个数相同的区间改为同一个数，求至少需要多少步能使得这 $n$ 个数相等。

#### Solution

定义 $dp_{l,r}$ 为区间 $[l,r]$ 满足要求的最小步数，考虑区间 dp，对于两个数 $i,j$（$i<j$）有：

- 如果 $a_i=a_j$，那么可以先让区间 $[i+1,j-1]$ 满足要求再转移过来，从 $dp_{i+1,j-1}+1$ 转移过来。
- 如果 $a_i \ne a_j$，那么一种情况是让区间 $[i,j-1]$ 满足要求再让 $j$ 跟他们统一，另一种是让区间 $[i+1,j]$ 满足要求再让 $i$ 跟他们统一，从 $\min\{dp_{i,j-1},dp_{i+1,j}\}+1$ 转移过来。

为了方便计算，考虑去重，即将一个区间缩为一个点，方式简单，不多赘述。

（但好像不去重也能过？没试）

#### Code

```cpp
for (int i = 1; i <= n; i++)
	if (a[i] != a[i - 1]) {
		cnt++;
		c[cnt] = a[i];
	}
for (int len = 1; len < cnt; len++)
	for (int i = 1; i + len <= cnt; i++) {
		int j = i + len;
		if (c[i] == c[j]) dp[i][j] = dp[i + 1][j - 1] + 1;
		else dp[i][j] = min(dp[i][j - 1], dp[i + 1][j]) + 1;
	}
```