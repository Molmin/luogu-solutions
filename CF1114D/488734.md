## 题意
给定一行 $n$ 个方块与它们的颜色，规定连续且颜色相同的方块属于一个连通分量，每次操作可以将一个连通分量内的方块改成同一颜色，问至少需要几次操作才能将所有方块改成同一颜色。
## 思路
由题意我们可知这道题我们只需要在输入时把每个连通分量的颜色记录下来，由短到长计算出依次计算出每个区间的最小更改次数，用区间DP即可。 $dp_{i,j}$ 表示从第 $i$ 个连通分量到第 $j$ 个连通分量改成同一颜色的最小更改数量。如果首尾的连通分量相同，即 $c_i = c_j$ ， $dp_{i,j}$ 就可以从 $dp_{i+1,j-1}$ 转移，为它的值加$1$。如果首尾两个连通分量颜色不相同，即 $c_i \ne c_j$ ，就需要从 $dp_{i+1,j}$ 或 $dp_{i,j-1}$ 来转移，为它们的较小值加$1$。
## 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
int n,c[5005],dp[5005][5005]; //dp[i][j]表示从第i个连通分量到第j个连通分量改成同一颜色的最小更改数量
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	{
		scanf("%d",&c[i]);
		if(c[i]==c[i-1])
		{
			n--;
			i--; //把相同相连的方块记录在同一个连通分量里
		}
	}
	for(int len=1;len<n;len++) //枚举区间长度
	{
		for(int i=1;i+len<=n;i++)
		{
			int j=i+len;
			if(c[i]!=c[j]) dp[i][j]=min(dp[i+1][j],dp[i][j-1])+1; //若首尾连通分量不同,从dp[i+1][j]或dp[i][j-1]转移
			else dp[i][j]=dp[i+1][j-1]+1; //首尾相同,直接从dp[i+1][j-1]转移
		}
	}
	printf("%d",dp[1][n]); //输出全部改成一样颜色需要的代价
	return 0;
}
```