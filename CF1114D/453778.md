# Solution for CF114D

## Step1：分析题意

题意：给定一个 $int$ 类型的序列，可以一次由 $i$ 到 $j$ 一次变换成一种数字。现在问至少要多少次操作，使得序列变成一种数字。

## Step2：思路

Hmm...看看题，是从 $i$ 到 $j$ 能进行批次变化，那么这...应该是...区间 dp 吧！这样子，除了区间 dp 还有什么呢？

## Step3：转移方程

既然选择了 $dp$ ，那么就来搞一下转移方程吧！

先贴为敬：

```
dp[i][j]=dp[i+1][j-1]+1;//当a[i]与a[j]相等的时候
dp[i][j]=min(dp[i+1][j],dp[i][j-1])+1;//其他情况
```
那么，屏幕前 ~~帅气的~~ 做过一些区间dp的小盆友就会问了：啊，为什么不先从 $i$ 到 $k$ ，再从 $k+1$ 到 $j$ 这么不断将大区间变成小区间这么枚举呢？比如说典型的石子合并呢？

枚举分割点的做法一定是对的，但是没有必要的。我们可以发现，将相同的序列合并成为`1`个之后，也就是剩下的序列中每一个元素都是相同的时候，我们就可以发现方案数只用一个个加`1`就行了。也便没有必要去将 $O(n^2)$ 变成 $O(n^3)$ 了。

## Step4：话不多说上代码

```cpp
//区间dp模板题目 
//dp[i][j]表示使i到j的颜色都一样的次数 
#include<bits/stdc++.h>
using namespace std;
const int N=5050;
int a[N]={0};
int dp[N][N];
int ans=0;
int n;
signed main()
{
	cin>>n;
	int cnt=0;
	int x;
	for(int i=1;i<=n;i++)
	{
		cin>>x;
		if(a[cnt]==x)
		{
			continue;
		}
		a[++cnt]=x;
	}
	//上面的循环是剔除那些完全相等的方块 ，至于为什么，那就看下面的转移方程。 
	for(int i=cnt;i>=1;i--)//去枚举停止的点 
	{
		for(int j=i+1;j<=cnt;j++)//枚举起始点 
		{
			if(a[i]==a[j])//如果发现有两个相同 
			{
				dp[i][j]=dp[i+1][j-1]+1;//那么就将从i+1，j-1继续转移。这里解答一个问题；为什么不从i~k,k+1~j这么枚举。因为其中在上面的循环里面剔除了连续相同的项，所以就不用将大区间分成两个小区间
				 
			}
			else
			{
				dp[i][j]=min(dp[i+1][j],dp[i][j-1])+1;//其他就不用说了，就是在从i+1~j的方案和i~j-1之间取min值再+1 
			}
		}
	}
	cout<<dp[1][cnt]<<endl;//输出 
}
//感谢seantheone(ZSH)给予的思路 

```

鸣谢：感谢seantheone提供的初始思路

























-+

