### 题意：
给定一些颜色的方块，可以一次从一个位置变颜色，问多少次能把这列方块变成一个颜色。
### 分析：
这道题中的表示都在疯狂暗示区间 `dp` ，所以我们考虑 $dp[i][j]$ 表示从 `i`到`j`变成相同的颜色的最小步数。那么分为两种情况：1.扩大的区间的两个颜色相同。2.不相同。继而我们又有了转移方程：
```cpp
if (a[i] == a[j]) dp[i][j] = dp[i + 1][j - 1] = 1;       //相同，那么就是将里面的全刷成a[i]的颜色 
dp[i][j] = min(dp[i + 1][j] + 1, min(dp[i][j - 1] + 1, dp[i][j]));       //不相同，那么将小区间都刷成a[i]或a[j]的颜色 
```
发现问题了！为什么这次不用像以前的合并石子一样枚举分割点，而是一次区间增加 `1` 呢？不仅仅是因为不支持 $O(n^3)$吧！

我们可以想一想，枚举分割点的做法一定是对的，因为这题正解的增长方式也是包含在分割点的一种情况里的，但是真的有必要吗？我们很容易发现只要序列的颜色各不相同，那么就一定可以每次增长`1`。所以我们前面判断颜色就起了另一个作用：把不能增长`1`的情况先解决了。
### 代码：
```cpp
# include <bits/stdc++.h>
using namespace std;
const int NR = 5050;
int a[NR];
int dp[NR][NR];
int main()
{
	int n;
	cin >> n;
	for (int i = 1; i <= n; i++)
	{
		cin >> a[i];
		if (!i) continue;
		if (a[i] == a[i - 1])        //初始化a的情况 
		{
			i--;
			n--;
		}
	}
	memset(dp, 0x7f, sizeof(dp));       //取最小值 
	for (int i = 1; i <= n; i++) 
	{
		dp[i][i] = 0;      //如果i到i合并，就一个数字，一种颜色，方案数为0 
	}
	for (int len = 2; len <= n; len++)       //区间长度 
	{
		for (int i = 1; i + len - 1 <= n; i++)      //枚举起点 
		{
			int j = i + len - 1;     //终点 
			if (a[i] == a[j]) dp[i][j] = dp[i + 1][j - 1] + 1;
			dp[i][j] = min(dp[i + 1][j] + 1, min(dp[i][j - 1] + 1, dp[i][j]));  //转移 
		}
	}
	cout << dp[1][n] << endl;
	return 0;
}
```
