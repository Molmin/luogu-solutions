### **关于单调栈：**
相信对于栈大家应该很了解，就是一个先进后出的线性数据结构，可以在栈顶进行压入和弹出操作，在这里不过多陈述。

至于单调栈，可以很好地从字面意思上看出这是一个自栈底至栈顶增减性单调的一个栈，在这里简单讲一下代码的实现：

如果要在栈顶压入一个常数$x$，若压入$x$不会对栈的单调性造成改变，那么就直接将$x$按普通栈的方法压入，否则便在栈顶持续弹出栈内元素直至压入$x$符合栈的单调性。

**代码：**
```cpp
//向一个单调递增的栈内压入n个元素。 
//stack为单调栈，t为栈顶。
int stack[3333333],t,x,n;
for(int i=1;i<=n;i++)
{
	scanf("%d",&x);
	while(sta[t]>x)
	t--;
	stack[++t]=x;
}
```

------------

### **关于本题：**
题意要求分别求出数列中第$i$个元素之后第一个大于$a_i$的元素的下标，根据标题可以联想到将数列元素压入单调栈，第一个在压入时将$i$弹出的元素就是第$i$个元素之后第一个大于$a_i$的元素。

所以很明显可以用单调栈来解决本题。

但题意要求按**下标顺序**输出答案，而单调栈弹出的元素是无序的，下标小的也可能后弹出，如何解决下标问题？

我们可以再开一个标记数组来记录栈底至栈顶元素的下标，在弹出时取出标记数组内对应元素的下标，按下标顺序将答案存入答案数组中。

如果说还有什么问题的话，就是这道题它~~卡常~~曾经卡常。

**代码：**
```cpp
#include<cstdio>
using namespace std;
int sta[3333333],t,n,a,ans[3333333],num[3333333];//sta为单调栈，t为栈顶，ans为答案数组，num为标记数组，a,n如题意所述。 
int read()
{
	int res=0;
	char c;
	c=getchar();
	while(c<'0'||c>'9')
	c=getchar();
	while(c>='0'&&c<='9')
	{
		res=res*10+c-48;
		c=getchar();
	}
	return res;
}
void write(int x)
{
	if(x>9)
	write(x/10);
	putchar(x%10+48);
}//快读快输，但因为本题现在不卡常了，所以也没什么用了，略过即可。 
int main()
{
	n=read();
	sta[0]=1234567890;//因为是单调递减的栈，所以要在栈底压入一个极大值，以确保栈为空时一定能压入元素。 
	for(int i=1;i<=n;i++)
	{
		a=read();
		while(sta[t]<a)//将所有不符合单调性的元素弹出栈。 
		{
			ans[num[t]]=i;//按照被弹出元素的下标将第一个大于a[i]的元素的下标记入答案数组。 
			t--;
		}
		sta[++t]=a;//入栈。 
		num[t]=i;//记录栈内元素的下标。 
	}
	for(int i=1;i<=n;i++)//因为答案数组的初始值为零，所以留在栈内的元素，即不存在大于a[i]的元素的答案一定为零。 
	{
		write(ans[i]);
		putchar(' ');
	}
	return 0;
}
```


------------
### **关于更多例题：**
[[USACO06NOV]糟糕的一天Bad Hair Day](https://www.luogu.com.cn/problem/P2866)，即P2866。

很模板化的USACO题，只需要在计数方面做一点小改动即可。

~~甚么？你还是不会做？那边有题解，不要来问我~~~~
