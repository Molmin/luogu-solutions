# 伪单调栈

~~因为看了题解后发现小蒟蒻的栈和其他dalao的单调栈不太一样qwq~~

~~但竟能AC！~~

注：这种做法应该并不能保证出栈顺序的单调性。

## 思路

保持栈内元素单调不升，从前往后依次将元素（这里元素不是指下标）与栈中元素比较，弹出更小的元素的同时更新该元素的f，即该元素之后第一个大于该元素的元素的下标，直到遇见更大的元素为止，然后入栈，也就确保了栈中元素的单调不升的性质。

~~好绕~~

我们跟踪一个元素，此时栈中元素单调不升，也就是说每个元素还没有找到更大的元素，而它们如果找到了的话说明在我们跟踪的这个元素之前就有元素干掉了这些小元素，而这些小元素的f也就定了。

我们依次让跟踪的这个元素与栈顶元素比较，当然，栈中元素在数列中是在前面的，如果跟踪的这个元素更大，说明这个栈顶元素可以退役了，于是更新它的f并抛弃它，以此类推，直到接下来遇到更为强大的元素，说明栈中下面的元素可能一个比一个强，不屑于与自己配对，于是安歇下来，入栈。

如果这个元素是在过于强大，打败了栈中所有元素，弹出栈中元素后要把它入栈（谁知道接下来有没有更强大的）。

## 代码

```cpp
#include<bits/stdc++.h>

using namespace std;

#define N 3000005

struct element{
	int v,id;
	//v存元素大小，id存元素下标 
};

int n,f[N];
stack<element>s; 

int main()
{
	cin>>n;
	for(int i=1;i<=n;i++)//i也可以看作下标
	{
		int a;
		scanf("%d",&a);//下一个元素
		while(!s.empty())//需要特判，如果为空，取top要有问题
		{
			element p=s.top();
			if(a>p.v)//如果大于，抛弃它
			{
				f[p.id]=i;
				s.pop();
			}
			else//遇到更强大的，就跳出循环，入栈
			{
				break;
                //超强元素则不会进入这里
			}
		}
        
        //入栈操作
		element k;
		k.v=a;
		k.id=i;
		s.push(k);
        //第一个元素，或者超强元素使栈中变空，也是要入栈的
	}
	for(int i=1;i<=n;i++)
	{
		printf("%d ",f[i]);
        //output
	}
	return 0;
}
```