## 题目描述
给定一个长度为n的整数序列，要求从中选出两个连续子序列，使得这两个连续子序列的序列和之和最大，最终只需输出最大和。一个连续子序列的和为该子序列中所有数之和。每个连续子序列的最小长度为1，并且两个连续子序列之间至少间隔一个数。

## 输入输出格式
#### 输入格式：
第一行是一个整数表示n。

第二行是n个整数表示整数序列。

#### 输出格式：
一个数，两个连续子序列的序列和之和。

## 输入输出样例
#### 输入样例#1： 
>5
83 223 -13 1331 -935

#### 输出样例#1： 
>1637

#### 输入样例#2： 
>3
83 223 -13

#### 输出样例#2：
>70

## 说明

对于30%的数据N<=100。

对于60%的数据有N<=10000。

对于100%的数据有N<=1000000。

数据保证运算过程不会超过long long（int64）。

---------------------------------------------------------------------------------------------------------------------
-


## 解题思路

首先根据Luogu《P1115 最大子段和》可以知道我们可以求出一直到第i为的当前连续子串和和当前连续子串的最大和，只不过对于这道题我们必须记录每一个点之前（或之后）当前连续子串的最大长度。
我们分别把从左到右的以及从右到左的当前子串和和当前最大子串和求出，以下是方法：

 - 从左到右

```
long long f[];//表示当前的子串和
long long ansl[];//表示当前从左到右的最大值 
for(int i = 1; i <= n; ++i) {
	f[i] = max(f[i - 1] + x[i], x[i]);
	ansl[i] = max(ansl[i - 1], f[i]);
}
```

 - 从右到左

```
long long g[];//表示当前的子串和
long long ansr[];//表示当前从右到左的最大值 
for(int i = n; i >= 1; --i) {//倒序遍历 
	g[i] = max(g[i + 1] + x[i], x[i]);
	ansr[i] = max(ansr[i + 1], g[i]);
}
```

 - 枚举断点
 

```
for(int i = 2; i <= n - 1; ++i) {//因为至少要有一个间隔，而且子串长度至少为1 
	ans = max(ansl[i - 1] + ansr[i + 1], ans);
} 
```



## 完整代码

```
#include <cstdio>
#include <iostream>
using namespace std;
int n;
typedef long long ll;
const int N = 1e6 + 100;
ll a[N];
ll f[N], g[N];
const ll INF = 999999999999;
ll ansl[N], ansr[N]; 
ll ans = 0;
int main() {
	scanf("%lld", &n);
	ans = -INF;
	ansl[0] = -INF;
	ansr[n + 1] = -INF;
	for(int i = 1; i <= n; ++i) {
		ll x;
		scanf("%lld", &x);
		a[i] = x;
		f[i] = max(f[i - 1] + x, x);
		ansl[i] = max(ansl[i - 1], f[i]);
	}
	for(int i = n; i >= 1; --i) {
		g[i] = max(g[i + 1] + a[i], a[i]);
		ansr[i] = max(ansr[i + 1], g[i]);
	}
	for(int i = 2; i <= n - 1; ++i) {
		ans = max(ansl[i - 1] + ansr[i + 1], ans);
	}
	printf("%lld\n", ans);
	return 0;
}
```

------------
# 然后你会发现你WA了!!!???
### 最后一波处理
因为区间的最前面和最后面都会出现负数
如果`ansl[0]`和`ansr[n+1]`的值为0的话就会出现一个神奇的现象， 队首的和变成了0，而不是正确的一个负数，炸！
所以

```
	ansl[0] = -INF;
	ansr[n + 1] = -INF;//为了防止负数的影响 
```
---------------------------------------------------------------**这下就可以完美AC了**---------------------------------------------------------------------