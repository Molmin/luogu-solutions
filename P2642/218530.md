每次枚举一个 $i$，将序列分成 $[1,i-1]$ 和 $[i+1,n]$ 两个区间，再对两个区间的最大连续子序列和相加，复杂度是 $O(n)$，再来看数据范围 $n≤10^6$，所以必须保证每次查询都是 $O(1)$，这里需要预处理。

定义 $f_i$ 表示以 $a_i$ 结尾的最大连续子序列和，$f1_i$ 表示以 $a_i$ 开头的最大连续子序列和。那么可以推出状态转移方程：

$f_i=\max(a_i,f_{i-1}+a_i)$

这里我们稍稍拐个弯，求出 $f_i$ 之后，再对每个 $f_i$ 进行与 $f_{i-1}$ 的比较，也就是不再限制结尾是谁，现在 $f_i$ 表示的是区间 $[1,i]$ 内的最大连续子序列和。

$f1_i$ 同理。


然后要提醒的是一个比较微妙的点，看下面这份 $50$ 分的代码：
```cpp
#include<iostream>
using namespace std;
long long n,a[1000010],f[1000010],f1[1000010];
long long ans=-9223372036854775808;
int main(){
	cin>>n;
	for(int i=1;i<=n;i++)cin>>a[i];
	f[1]=a[1];f1[n]=a[n];
	for(int i=2;i<=n;i++){
		f[i]=max(a[i],f[i-1]+a[i]);
		f[i]=max(f[i],f[i-1]);
	}
	for(int i=n-1;i>=1;i--){
		f1[i]=max(a[i],f1[i+1]+a[i]);
		f1[i]=max(f1[i],f1[i+1]);
	}
	for(int i=2;i<n;i++)
		ans=max(ans,f[i-1]+f1[i+1]);
	cout<<ans;
	return 0;
}
```
这份代码对 $f_i$ 的定义是，区间 $[1,i]$ 内的最大子序列和。也就是说，它并不是连续的。为什么这样说呢？如果选了 $f_{i-1}+a_i$，但事实上 $f_{i-1}$ 并不保证以 $a_{i-1}$ 结尾。

为了证实这一点，我们出一组数据：


$5$

$1$ $-2$ $3$ $-4$ $5$

输出是 $9$，但正确答案应该是 $8$。它选择了以 $-4$ 为分界线， 左边是 $1+3$，右边是 $5$，但 $1+3$ 并不能构成一个连续子序列，错误原因是它在进行 $f_2$ 的赋值时选择了 $1$，又在 $f_3$ 选择了 $1+3$ ，但中间隔了一个 $-2$。

还有一个可能错误的地方：

>每个连续子序列的最小长度为 $1$

也就是说，当全都是负数的时候，你起码也要选一个最大的负数，而不是 $0$。

最后一份 $AC$ 的代码：
```cpp
#include<iostream>
using namespace std;
long long n,a[1000010],f[1000010],f1[1000010];
long long ans=-9223372036854775808;
int main(){
	cin>>n;
	for(int i=1;i<=n;i++)cin>>a[i];
	f[1]=a[1];f1[n]=a[n];
	for(int i=2;i<=n;i++)f[i]=max(a[i],f[i-1]+a[i]);
	for(int i=2;i<=n;i++)f[i]=max(f[i],f[i-1]);
	for(int i=n-1;i>=1;i--)f1[i]=max(a[i],f1[i+1]+a[i]);
	for(int i=n-1;i>=1;i--)f1[i]=max(f1[i],f1[i+1]);
	for(int i=2;i<n;i++)ans=max(ans,f[i-1]+f1[i+1]);
	cout<<ans;
	return 0;
}
```