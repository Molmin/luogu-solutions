提供一个只能过 Easy Version 的方法。

考虑一下 $r-l$ 怎样最小：很明显，对于一个区间 $[L,R]$，其分成所有段的 $r-l$ 之和（在这里，单独的一个数也算作一段，虽然其 $r-l=0$），就是 $R-L+1-S_{L,R}$，其中 $S_{L,R}$ 表示操作的次数。

显然我们需要让操作次数尽量多，而且显然所有操作区间肯定不交。考虑一个序列 $a$，记其从小到大排序后的序列为 $b$。那么对 $a$ 序列的 $[l,r]$ 操作，当且仅当对 $a[l,r]$ 排序后的 $a'[l,r]=b[l,r]$。那么就有一个贪心：记上一次操作的右端点为 $[l,r]$，当前遍历到 $i$，如果 $a[r+1,i]$ 排序后和 $b[r+1,i]$ 相等，那么代价加上 $i-r-1,r \gets i$。根据上面的推导，这样肯定是最优的。

举个例子：$a=[1,3,2]$，$b=[1,2,3]$。首先，$a[1,1]=b[1,1]$，那么对它操作，代价加 $0$；下一次，$a[2,3]$ 排序后和 $b[2,3]$ 相等，那对 $a[2,3]$ 进行操作，代价为 $1$。

~~这个时候我就想到了一个用哈希判断同构的 $O(n^3)$ 解法，当时很好奇这题怎么 $O(n^2)$~~。显然需要做到 $O(n^2)$，我们需要考虑插入一个数对答案会有什么影响。

考虑一些性质。设两个操作区间为 $[l_1,r_1],[r_1+1,r_2]$，那么显然有：

$$\max_{i=l_1}^{r_1}a_i \le \max_{i=r_{1}+1}^{r_2}a_i,\max_{i=l_1}^{r_1}a_i \le \min_{i=r_{1}+1}^{r_2}a_i,$$

不然它们肯定无法在值域上连成一段。那么到了这里，思路就清晰了：对于一个序列，$a_i$ 可以作为一段的开头，当且仅当 $a_i \ge \max_{j=1}^{i-1} a_j$。

同时，如果当前数 $a_j$ 小于上一段的最大值，那么我们就暴力往回跳，看跳到哪一段满足 $a_j$ 大于等于前一段的最大值，然后把中间跳的这些段合并起来就好了，这个答案贡献是容易统计的。同时，左端点固定，往回跳的次数是 $O(n)$ 的，总时间复杂度就是 $O(n^2)$。不过这么想似乎很难上数据结构做到更优的复杂度。

举个例子，对于 $a=[1,3,2,4]$，考虑在末尾插入 $1$。

对于原序列 $a$，其操作区间分别是 $[1],[3,2],[4]$。插入 $1$ 之后：

- $1<3$，也就是小于上一段的最大值，合并 $[3,2,4]$；

- $1 \ge 1$，也就是大于等于上一段最大值，符合条件。此时操作区间更换为 $[1],[3,2,4,1]$。答案也是容易维护的。

### Code：

```c++
#include <bits/stdc++.h>
using namespace std;
int t, n, m, ans, a[5010], l[5010], mx[5010];
long long tot;
int main(){
	scanf ("%d", &t);
	while (t --){
		tot = 0;
		scanf ("%d", &n);
		for (int i=1; i<=n; i++){
			scanf ("%d", &a[i]);
		}
		for (int i=1; i<=n; i++){
			ans = m = 0;
			for (int j=i; j<=n; j++){
				if (a[j] >= mx[m]){
					l[++m] = j, mx[m] = a[j];
				}
				else if (a[j] < mx[m-1]){
					int pos = m-1;
					ans -= j - l[m];
					ans ++;
					while (a[j] < mx[pos]){
						ans -= l[pos+1] - l[pos] - 1;
						pos --;
					}
					pos ++;
					ans += j - l[pos];
					mx[pos] = mx[m], m = pos;
				}
				else{
					ans ++;
					mx[m] = max(mx[m], a[j]);
				}
				tot += ans;
			}
		}
		printf ("%lld\n", tot);
	}
	return 0;
}
```