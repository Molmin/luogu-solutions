### 分析

我们需要把数列 $a$ 分成若干段，使得每一段中的数按位与起来的值之和尽可能小，并使段数尽可能多。

我们知道，一堆数按位与起来只会让结果越来越小。我们设 $a_1\  \texttt{\&}\  a_2\  \texttt{\&}\  \cdots\  \texttt{\&} \ a_n=x$，那么如果把数列 $a$ 分成若干段，每一段中的数按位与起来的值一定不小于 $x$。

只有 $0$ 加若干个 $0$ 才等于 $0$，所以如果 $x \neq 0$，那么 $a$ 只能作为一大段，因为如果将 $a$ 分成了多段，每一段中的数按位与起来都不小于 $x$，总和至少是 $x$ 与段数的乘积，显然是大于 $x$ 的。于是我们可以得到，如果 $x \neq 0$，那么段数就一定为 $1$。

接下来，我们考虑 $x=0$ 时的情况。我们知道我们要把 $a$ 分成若干段，使得每一段中的数按位与起来的值都为 $0$，那我们把 $a$ 从前往后扫，记录当前段的按位与的值，当某一瞬间按位与的值为 $0$，新开一段并记录段的数量即可。

要注意若最后多出来的几个数按位与的值不为 $0$，需要将它们合并到上一段中。

### 代码

```c++
const int N=2e5+5;
int a[N];
void solve(){
	int ans=0,n=read(),x,k=-1;
	for(int i=1;i<=n;i++) a[i]=read();
	x=a[1];
	for(int i=2;i<=n;i++) x=x&a[i];
	if(x!=0){
		cout<<1<<endl;
		return;
	}
	for(int i=1;i<=n;i++){
		if(k==-1) k=a[i],ans++;
		k=a[i]&k;
		if(k==0) k=-1;
	}
	if(k!=-1) ans--;
	cout<<ans<<endl;
}
```