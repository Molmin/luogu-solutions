分析：

考虑一个贪心，我们每次都把鼹鼠送到离它最近的还可以居住的洞里。但是，有一个显然问题是我们没法处理之前的鼹鼠对后续的影响。我们可以这样考虑：每当一名鼹鼠经过一条树边，我们就将其设置一条反方向的权为 -1 的边，表示如果有鼹鼠反向经过，则会抵消其影响。

那么我们先扫一遍整棵树，用 $f(i)$ 表示在 $i$ 的字数中距离 $i$ 最近的点到 $i$ 的距离，$g[i]$ 表示在 $i$ 的子树中距离 $i$ 最近的点的位置，这两个数组的维护我们都可以直接利用他们的子树信息得到： 

```
f[i]=min{f[v]|v∈i的儿子点集}
g[i]=f转移用到的那个v
```

查询最短路的时候，可以从 $p[i]$ 向上遍历 $p[i]$ 的所有祖先，同时维护经过的距离，不断用当前节点的 $f$ 值加上爬上来的距离更新最短路答案，最后，利用上面提到的转移式重构路径上的所有结点的 $f$ 和 $g$ 值，并且为沿途的路径打上标记。由于对于任意的 $i>1$，第 $i$ 个洞都会和第 $\lfloor \frac{i}{2} \rfloor$ 个洞间有一条隧道的题设条件保证了这棵树是一个完全二叉树，也就是树高最多为 $\log_2n$，且每个点至多有 2 个儿子，所以这个贪心加上暴力复杂度是 $O(n\log n)$。

代码：

```cpp
for(int i=n;i>=1;i--){
		if(c[i]) f[i]=0,g[i]=i;
		if(f[i>>1]>f[i]+1) f[i>>1]=f[i]+1,g[i>>1]=g[i]; 
	}
	for(int i=1;i<=m;i++){
		cin>>p[i];
		minn=1<<30,sum=0;
		for(int j=p[i];j;j>>=1){
			if(f[j]+sum<minn) minn=f[j]+sum,pos=g[j],lca=j;
			sum+=(v[j][0]>0)?(-1):1;
		}
		ans+=minn;
		cout<<ans;
		if(i!=m) cout<<' ';
		c[pos]--;
		for(int j=p[i];j!=lca;j>>=1) v[j][0]?v[j][0]--:v[j][1]++;
		for(int j=pos;j!=lca;j>>=1) v[j][1]?v[j][1]--:v[j][0]++;
		for(int j=p[i];j!=lca;j>>=1){
			f[j]=1<<30;
			if(c[j]&&0<f[j]) f[j]=0,g[j]=j;
			if((j<<1)<=n&&f[j<<1|1]+(v[j<<1][1]?-1:1)<f[j]){
				f[j]=f[j<<1]+(v[j<<1][1]?-1:1);
				g[j]=g[j<<1];
			} 
			if((j<<1|1)<=n&&f[j<<1|1]+(v[j<<1|1][1]?-1:1)<f[j]){
				f[j]=f[j<<1|1]+(v[j<<1|1][1]?-1:1);
				g[j]=g[j<<1|1];
			}
		}
		for(int j=pos;j;j>>=1){
			f[j]=1<<30;
			if(c[j]&&0<f[j]) f[j]=0,g[j]=j;
			if((j<<1)<=n&&f[j<<1]+(v[j<<1][1]?-1:1)<f[j]){
				f[j]=f[j<<1]+(v[j<<1][1]?-1:1);
				g[j]=g[j<<1];
			}
			if((j<<1|1)<=n&&f[j<<1|1]+(v[j<<1|1][1]?-1:1)<f[j]){
				f[j]=f[j<<1|1]+(v[j<<1|1][1]?-1:1);
				g[j]=g[j<<1|1];
			}
		}
	}
```
