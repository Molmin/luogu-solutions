## 写了个暴力然后绿了！！！QAQ

~~暴风哭泣呜呜呜~~

---
首先，

每次找下一个更大的序列，找到第一个前面是0的1，（最高位1的前面也是0）

然后把这个0与1的位置互换，再让这个零后面的1全部在最后。

(这样说可能有点抽象，，我们来看下样例！！

111

1011

1101

1110

10011

10101

10110

应该很好懂叭！比如1110到10011的时候，就是把最高位一和前面的0互换位置，再将后面最后几位全部改为0。

直接记录二进制每位并不方便，但可以考虑来记录每个1的所在位置。

如果当前1的位置+1不等于下一位1的位置，就说明前面是空的。那么我们互换这两个。

至于如何把前面的1弄到最前面，我们只需要在遍历的时候在前面让1的位置等于数组下标即可。如果找到了可互换的就break掉。

最高复杂度O(n*k)，

---
## 代码如下：

```cpp
#include <bits/stdc++.h>
using namespace std;
int n,k,rec[15];
int main()
{
	scanf("%d%d",&n,&k);
	for(int i=1;i<=k;i++) rec[i]=i;
	for(int i=2;i<=n;i++)
	{
		for(int j=1;j<=k;j++)
		{
			if(rec[j]+1!=rec[j+1]) {++rec[j];break;}
			else rec[j]=j;
		}
	}
	for(int i=rec[k];i;i--)
	{
		if(rec[k]==i) { cout<<"1";--k; }
		else cout<<"0";
	}
}
```