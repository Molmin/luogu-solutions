#### 本来是为了练习位运算才找到此题的，但我发现这跟位运算关系并不大，不过练一练组合数学也并非不好。

这样一道题，一看就知道要找规律，容易发现本题向后递推的第一个规律，就是`0的个数是按顺序排列的`，比如说3个0的所有情况遍历完后，才会找4个0的情况。

答案是10110，所以需要直接去掉没有0和一个0的情况，然后从两个0的情况开始递推，那么如何使用组合数呢？这里用样例“7 3”来分析。我们把每个1后面的0的个数看做这个1”盘子“的苹果数。（因为1的个数是固定的）

1. `K=3, cnt=0`代表0个相同苹果放入3个不同盘子中，有1种方案。我们把`N-=1`，把`cnt++`;

2. `K=3, cnt=1`代表1个相同苹果放入3个不同盘子中，有3种方案。我们把`N-=3`，把`cnt++`;

3.  `K=3， cnt=2`代表2个相同苹果放入3个不同盘子中，有6种方案。但是`N=6`，已经不够减了，退出。

   如何计算方案综述，我在~~忘了哪一节~~课上，找到规律`f(K,cnt)=C(K+cnt-1,cnt-1)`，我也不知道这叫什么数，有兴趣的同学可以自行推导。

此时`K=3,N=3,cnt=2`代表我们需要把2个相同苹果放入3个不同盘子中，降序排列的第3种方案。

我们枚举排列：(这里的降序只从前往后比较)

```
2 0 0
1 1 0
1 0 1
0 2 0
0 1 1
0 0 2
```

第三个是`1 0 1`，代表第1个1和第3个1后面各有一个0，输出10110，`return 0;`

那么如何枚举排列呢？经过一节化学课的摸索，我找到规律：

**1.若最后一位(第K位)不为0，则把最靠后的一个数-1，它的下一个数变为1，如"4 2 2 0 0"→"4 2 1 1 0"**

**2.否则进行如下变换(太难说了，参见样例和代码)，如"2 0 1"→"1 2 0"，"4 2 2 0 3"→"4 2 1 4 0"**

我们可以使用`cnt`记录当前最后非0位的位置，节省时间空间。

至此，本题已经完美解决，代码如下：

```cpp
//时间比较紧，常数较大，代码不美观见谅。
#include <bits/stdc++.h>
using namespace std;

int N,K,cnt,ans[11],acnt;

int C(int n,int m)
//组合数计算
{
    int ans=1,div=2;
    for (register int i=n-m+1; i<=n; i++)
    {
        ans*=i;
        if (!(ans%div)&&div<=m) {ans/=div;div++;}
    }
    return ans;
}

int main()
{
    scanf("%d%d",&N,&K);
    while (N>C(K+cnt-1,K-1))
        N-=C(K+cnt-1,K-1),cnt++;
    //执行第一步操作
    ans[1]=cnt; cnt=1;
    while (--N)
    {
        if (cnt>=K)
        {
            for (int i=K-1;i>=1; i--)
                if (ans[i]>0)
                {
                    cnt=i+1;
                    ans[i]--;
                    ans[i+1]=1+ans[K];
                    if (i!=K-1) ans[K]=0;
                    //递推情况1
                    break;
                }
        }
        else ans[cnt]--, ans[++cnt]++;
        //递推情况2
    }
    for (int i=1; i<=K; i++)
    {//玄学输出
        putchar('1');
        while (ans[i]--) putchar('0');
    }
    return 0;
}
```



