这个数字三角形，算是一道老题了，应该有很多奆佬都看见过。鄙人不才，在这里给大家介绍两种方法：

### **DP and 深搜！**

先说深搜，这一部分是给蒟蒻看的，奆佬直接看下面的DP，为何？因为这道题目，行列数最高达到了1000，按照深搜的做法，大概率超时。不信？本人以身试险，最后凄凄惨惨的，拿个55分……


虽然下场惨了点，但只要数据范围少个零，还是可以解决的，思想可以学习。话不多说，上代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[1001][1001],n;
int solve(int x,int y)
{
	if(x==n) return a[x][y];             //1
	int u=solve(x+1,y),v=solve(x+1,y+1);
	return max(u,v)+a[x][y];
}
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	for(int j=1;j<=i;j++) cin>>a[i][j];   //2
	
	cout<<solve(1,1);
	return 0;
}
```

1:这里是深搜函数，递归的终止条件是：如果坐标在最后一行，则直接返回这个坐标的数（下面已经没有数了）。递归方法：在左下方的和右下方的两个和中取最大的，再加上该坐标的数。

2:注意第二层循环，条件是j<=i,因为输入是三角形的，第i行输入i个。



DP部分：
众所周知，虽然DP的空间，时间不像深搜那样庞大，但是二维数组的空间，两层循环的时间，也有可能超，不过这题还好，空间大约是1001^2 *2 *4B（两个int二维数组），时间也不会超。
于是我放心的叫了代码，果不其然，AK……
```cpp
#include<bits/stdc++.h>
using namespace std;
int a[1001][1001],n,f[1001][1001];
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
	for(int j=1;j<=i;j++) cin>>a[i][j];
	
	for(int j=1;j<=n;j++) f[n][j]=a[n][j];    //1
	for(int i=n-1;i>=1;i--)
	for(int j=i;j>=1;j--)    //2
	{                                                            
		f[i][j]=max(f[i+1][j],f[i+1][j+1])+a[i][j];
	}
	
	cout<<f[1][1];
	return 0;
}
```
1:初始化。在最底下一列，最大和就是这个数字自己，因为它下面已经没有数了。

2：动态规划核心部分。从右下至左上，不然得到的答案全是零，因为下面还没初始化。max函数里的是左下的最大和以及右下的最大和，之后再加上这个位置的数。

综上，推荐大家还是用动态规划，毕竟深搜数据一超，什么RE,TLE,MLE……错误一大堆，dp就两个二维数组，不占太大地方。最后祝大家满屏AC，刷通动归！！


