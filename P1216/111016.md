这是动态规划·DP的一道经典题
------------

具体做法：1.分析问题的最优解，找出最优解的性质，并刻画其结构特征：问题的最优解：所有走法中最大的权值是多少？最优解的性质和结构特征：只能向正下或者右下走，每走一行的最大权值等于前面一行的最大权值加上这一行的走的两个方向中的最大值2.递归的定义最优值：要找到从0行出发的最优值，就要找到从第1行出发的最优值要找到从1行出发的最优值，就要找到从第2行出发的最优值……………要找到第3行出发的最优值，就要找到从最后一行出发的最优值为什么是这样呢？我们分析一下题目要你求从0行出发的最优值，那么我们就是要找到从第一行出发的最优值，加上第0行到第1行的最优值但是，很重要的一点，我们需要递归求解，要先求解从倒数第一行出发的最优值，然后根据从倒数第一行出发的最优值求出从倒数第二行出发的最优值3.采用自底向上的方式计算问题的最优值：这个就是我上面说的，要先求解从倒数第一行出发的最优值，然后根据从倒数第一行出发的最优值求出从倒数第二行出发的最优值，自底向上的计算，迭代的方式求解子问题4.根据计算最优值时间得到的信息，构造最优解这个就是问你具体是怎么走的，我们需要在求解子问题的时候保存一些信息，采用构造出最优解（最优值和最优解是不同的，最优值在本问题中是一个走法中权值之和最大的那一个，而最优解是具体的走法），这里题目没有要求就是不用去构造最优解，构造起来也挺麻烦的。。。。解法：dp[i][j]：代表从第i行第j列出发得到的最优值dp[i][j]=max（dp[i+1][j]，dp[i+1][j+1]）+a[i][j]表示从第i行第j列出发的最优值等于到i+1行的两种走法中最大的那一个加上出发点的权值！

--------------------- 
~~咳咳以上其实是百度的QwQ除了那个状态转移方程~~

接下来！！！
上代码
------------


```
#include<bits/stdc++.h>//万能头~~懒得打其他的头文件了~~
using namespace std;
int main()
{
    int n;
    scanf("%d",&n);//n行
    int a[n][n];
    memset(a,0,sizeof(a));
    for(int i=0;i<n;i++)
    {
        for(int j=0;j<=i;j++)
        {
            scanf("%d",&a[i][j]);//输入不用多说
        }
    }
    int dp[n][n];
    memset(dp,0,sizeof(dp));
    for(int j=0;j<n;j++)
    {
        dp[n-1][j]=a[n-1][j];//因为dp是自下而上的一种解题思想，所以QwQ
    }
    for(int i=n-2;i>=0;i--)
    {
        for(int j=0;j<=i;j++)
        {
            dp[i][j]=max(dp[i+1][j],dp[i+1][j+1])+a[i][j];//推出的
        }
    }
    printf("%d\n",dp[0][0]);//输出
    return 0;
}
```