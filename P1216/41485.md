看到楼下的各位都用了二维的数组，那么我就来说说怎么用一维数组做吧。算法的思路我就不再讲了，下面说一下如何实现。

首先肯定是边读边做，第一层循环i从n到1，第二层循环j从i到n（为了每次都能取到上次的值）,每次读入一个变量p，

状态转移方程：a[j]=max{a[j],a[j+1]}+p（a[j]表示走到第i层第j个时的最大值）。最后输出a数组的最大值即可。

下面我来用测试数据模拟一下](注意：要开1002的数组，不然会越界)：

a[1] a[2] a[3] a[4] a[5] a[6]

初始化：  0    0     0     0     0    0

第一次：  0    0     0     0     7    0

第二次：  0    0     0   10    15   0

第三次：  0    0   18   16    15   0

第四次：  0   20  25   20    19   0

第五次： 24  30  27   26    24   0

代码（c/c++）：

```cpp
#include<cstdio>
int n,a[1002],i,j,ans,p;
int max(int &x,int &y){return x>y?x:y;}
int main(){
    scanf("%d",&n);
        for(i=n;i;i--)
                for(j=i;j<=n;j++)
                        scanf("%d",&p),a[j]=max(a[j],a[j+1])+p;
        for(i=1;i<=n;i++)
        ans=max(ans,a[i]);
        printf("%d",ans);
        return 0;
}
```