题目描述


考虑在下面被显示的数字金字塔。
写一个程序来计算从最高点开始在底部任意处结束的路径经过数字的和的最大。
每一步可以走到左下方的点也可以到达右下方的点。

7

3 8

8 1 0

2 7 4 4

4 5 2 6 5

在上面的样例中,从7 到 3 到 8 到 7 到 5 的路径产生了最大和:30

输入

第一个行包含 R(1<= R<=1000) ,表示行的数目。

后面每行为这个数字金字塔特定行包含的整数。

所有的被供应的整数是非负的且不大于100。

输出

单独的一行包含那个可能得到的最大的和。

样例输入

5

7

3 8

8 1 0

2 7 4 4

4 5 2 6 5

样例输出

30

---

显然dp啊

这一道题是很多教材上的dp入门提，思想是就是裸的dp。

设f[i][j]表示从(1,1)到(i,j)的最大和，则f[i][j]=max(f[i-1][j],f[i-1][j-1])+a[i][j] 因为(i,j)这个点只能从(i-1,j)和(i-1,j-1)两个点走来，所以取他们两个的最大值+这一个点上的数。

其实这一道题的dp数组f可以优化成O(n)，不过意义不大：第一反正不会超内存，第二a数组已经必须是二维了。其实a数组也可以优化为一维，但反正不会超内存，就不管了。


---


```cpp
#include<iostream>
#include<cmath>
#include<cstdio>
#include<cstring>
#include<algorithm>
#define l long long
#define N 1000001
using namespace std;
l r,n,i,j,a[1005][1005],k,t,s;
int main()
{
	cin>>n;
	for(i=1;i<=n;i++)
	for(j=1;j<=i;j++)
	cin>>a[i][j];
	for(i=n-1;i>=1;i--)
	for(j=1;j<=i;j++)
	a[i][j]+=max(a[i+1][j],a[i+1][j+1]);
	cout<<a[1][1]<<endl;
	return 0;
}
```






