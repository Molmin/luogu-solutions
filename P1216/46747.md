###由于此题并不是特别难，所以就不发代码了，但是思路是~~肯定会讲清楚的。

不敢相信，这道题出自IOI1999。但如果我在那个时代，我肯定也做不出来。

蒟蒻一来看到这题，大叫：“哇，这题真简单！贪心~~就行啦~~！”

但是贪心法的缺点在此题中一览无余的展现了出来：目光短浅。

如果按照贪心法思路，则：7-8-1-7-5，其和为28；

但是存在着另外一条路：7-3-8-7-5，其和为30。

所以贪心法就OUT了。。。

然后蒟蒻又想：贪心法不行，那搜索总行了吧！

结果这次蒟蒻又想错了……

在本题中，R<=1000，要是用搜索，无论是DFS还是BFS，无论怎样剪枝，只有一种结果：TLE。

所以！！！

本题最简算法就是：递推！

递推共有两种方法可以选择：顺推法和逆推法，两种方法皆可。

顺推法和逆推法实际上很好区别，顺推法是从已知条件出发，向结果推导，而逆推法则是从结果出发，一步一步地往前推导。在本题中，顺推法就是从数塔的上方出发，一直推到最底层。而逆推法就是从最底层出发，往顶层前进。

我是用顺推法的。直接就写了个两重循环。

```cpp
for(int i=2; i<=n; i++)
        for(int j=1; j<=i; j++)
            if(b[i-1][j-1]>b[i-1][j]) //因为我们要求最大值，所以要将数塔上一层最大的数加上去。
                b[i][j]=b[i][j]+b[i-1][j-1];
            else b[i][j]=b[i][j]+b[i-1][j];
上面是主要部分，剩下就是什么输入输出之类的了。
```