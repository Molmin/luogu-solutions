# 一枚蒟蒻的orz文章
### 这篇文章也许不是最好的，~~但它思路清晰~~，很适合一些跟我差不多的蒟蒻。
好了，我们开始进入正题：

 1、不难发现，只要开头是1的数字，任何都可以组合，所以不需要有1这个数的特判。

2、紧接着，多说无益，毋庸置疑的就是除了1和4之外的数字了，如果这位数字不是1或4，直接标记bo。


## 前方高能
3、如果这一位数字是4，那么不妨将这一位数字定义为一个组合的第二位，也就是说，第i位遇到的4，要么是14的第二位4，要么是144的第二位4，千万不要混淆：将这位数在第一个组合定义为第二位，而在另一个组合又定义成第三位，必须确定一个不变的量。

4、可以看得出来，这一位的前一个数必定是一个'1'，所以，如果前一位不是1，那么也可以标记掉了。否则的话，~~还有希望~~。

5、最后，终于可以判断是否为组合了。这里注意，如果这位数字已经到达了最后一位，那么就可以断定，他一定是一个合法的组合——14，因为有前面的判断。到了这里，相信大家会有疑惑，如果这位数字所在的组合是144的怎么办啊？不要担心，我们只需要将i加1就行了，因为循环上面也会加1，所以直接跳过了第三位4,。再接着，如果它的下一位是1，那么我们可以来一个小恶作剧，i=i，哈哈~O(∩_∩)O！再接着，就是下一位不是4或1了，也可以将bo标记掉。

6、最后直接根据bo来输出就行啦！

相信认真读的人会打出代码来，所以我用一个反作弊系统来批判一下那些想要直接复制的人，代码里就不加注释了。

来来来（仔细看哦！）：

```cpp
#include<bits/stdc++.h>
using namespace std;
int bo=0,l;
string st;
int main()
{
	cin>>st;l=st.size();
	for(int i=0;i<l;i++)
	{
		int bo1=0;
		if(!(st[i]=='1'||st[i]=='4')) bo=1;
		if(st[i]=='4')
		{
			if(st[i-1]=='1') bo=1;
			  else bo1=1;
			if(bo1&&i!=l-1)
			{
				if(st[i+1]=='4') i++;
				  else if(st[i+1]=='1') i=i;
			             else bo=1;
			}
		}
	}
	if(!bo) cout<<"yES\n";
	  else cout<<"NO\";
	return 0;
}
```
我这反作弊做的太好了吧！O(∩_∩)O哈哈~！