本篇题解可能和官方题解做法不太一样，做法可能存在问题，一个结论也不会证明

由于考场上没想到$m=n-2$的处理，加之是同步赛，所以就懒得写代码了

其余题解多是从$m=n-1$下手，但这里尝试从$m=n$入手

我们将$n$个食谱想象成$n$根高度为$d_i$的柱子，如果$m=n$，那么我们的目标是变成$n$根高度为$k$的柱子，并且最终每根柱子最多由两根原来的柱子拼成。

结论：如果当前有一根比$k$小的柱子，很多根比$k$大的柱子。假设分别设为$k-a$, $k+x_1, k+x_2, k+x_3……, k+x_n$，满足$a\le\sum x_i,a>max_{j=1}^n(\sum_{i\ne j}x_i)$，那么我们一定存在一种方案，让他们变成$n$根高度为$k$的柱子，和一根比$k$大的柱子

证明：我们可以将$k+x_1$中分出$a$的高度给$k-a$，这样$k-a$这跟柱子的高度就变成了$k$，而$k+x_1$的高度就变成了$k+x_1-a$，显然是比$k$小的。

不难发现这变成了一个新的子问题，我们可以类似递归地处理即可。

也就是说，我们任意找到一个小于$k$的数和一些大于$k$的数，我们可以将其合并。

由于满足$\sum d_i=m\times k$，所以除非全部变成$k$，每次我们一定可以找到一个小于$k$的数和一些大于$k$的数，不难看出一定有解。

那么如果$m>n$怎么做呢？这个很简单，直接再初始的时候补充一些高度为$0$的柱子即可。复杂度$O(M)$

现在问题来了，怎么做$m=n-1$和$m=n-2$呢？

先来看下$m=n-1$的情况。发现我们有一根柱子是需要把他拆开，填入其余柱子的。

如果我们忽略一根柱子，将其他的$m$根柱子跑$n=m$情况的做法，那么我们会剩下很多高度为$k$的柱子和一些高度小于$k$的柱子，并且每根小于$k$的柱子的组成一定是他本身，即别的柱子没有分给他高度。

考虑我们上述的实现过程，每一次操作都是将自己的部分高度给别的柱子，让别的柱子恰好为$k$。相对的，对于最后高度不为$k$的柱子，一定没有被别的柱子给自己高度。

所以我们只需要让任意$n-1$根柱子去跑$n=m$的部分。对于剩下的小于$k$的柱子直接用多出来的那根去填即可。不难发现仍然一定合法。复杂度$O(M)$

再来看$m=n-2$的情况。这时候就会多出两根柱子和一些小于$k$的数了，但由于每根小于$k$的柱子最多只能由两根多出来的柱子之一拼成，所以很有可能会存在不能分割的情况。

这个地方不太会处理，但根据正解来看，我们只需要把他拆分成两个$n=m-1$的集合即可。但是用这种方法笔者并不太会证明为什么不能分成两个集合就一定无解。

如果知道结论，问题就转化成了，怎么将这些数分成两个集合，使得他们的和为$(|S|-1)\times k$，这个问题只需要将每个数减去$k$，也就转化成选择一些数，使得和为$-k$。这就变成了$01$背包的经典题目，由于只需要知道是否可行，$bitset$优化即可

代码太丑了，三个部分拆开写的，所以看上去很长，在$loj$上过了：[Code](https://loj.ac/submission/913183)