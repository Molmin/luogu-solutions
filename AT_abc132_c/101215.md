题目要让我们求出 $k$ 的取值个数，实际上等于求 $k$ 上下限制的范围。

知道了范围，我们就可以知道 $k$ 的取值个数，同样，知道了 $k$ 的取值个数，我们也可以知道 $k$ 的范围。

所以问题等价于求 $k$ 能取到的一个范围。

那么如何求这样一个范围？我们来仔细分析一下题目！

- 在 ARC 中， $k$ 一定是小于等于其中的最低分数的
- 在 ABC 中， $k$ 则一定是大于等于其中的最高分数的

啊！这里有最大和最小的问题！

有人说，涉及了最大值最小值的问题， $99\%$ 都是二分，所以我们来考虑一下能不能进行二分呢？

二分依赖的一个重要性质就是单调性。~~看我的主页，没有人比我更懂单调~~，单调是什么意思？单调就是一个东西，只是朝单一的方向变化，比如一直增加，一直减少。

那么这里有没有单调性？

有的！看，$k$ 增加，ARC 的题目是不是少，$k$ 减少，ARC 的题目是不是多？单调啊！单调！单调啊！单调！

所以我们就考虑进行二分，但是这里的条件有些不一样啊！不是一下子就能判断是否可以的。

我们仔细阅读题目，发现题目让我们求的是 ARC 和 ABC 题目数相同。这个便是条件了。

但这又有些不同，因为求最大最小值比较难控制，感觉比较像 [SHOI2015 自动刷题机](https://www.luogu.com.cn/problem/P4343), 那里也是要控制范围。

其实就是把普通的二分改一下，多增加一种判断，在条件完全符合的时候如果求解右端点就把左端点往右，求左端点就把右端点往左。

核心代码(二分左边界，右边同理):

```cpp
while(l<=r){
	int mid=(l+r)/2;
	if(check(mid)>k) l=mid+1;
	else if(check(mid)<k) r=mid-1;
	else ans=mid,r=mid-1;
}
```

现在来总结一下这道题。

这题考查了我们对于二分是否真正理解，如果不理解，肯定是想不到这样修改的，只有真正理解了，才能想到这样魔改一个二分，这真是一道练习二分的好题目啊！都有一点省选题的风范了。

但是，二分需要我们很好的理解，那我们没有很好的理解怎么办？

那就不二分了，换种正常的做法:

```cpp
 std::sort(a, a + n);
 printf("%d\n", a[n/2] - a[n/2-1]);
```

这样好想也好写。