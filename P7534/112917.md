## Content
火车站里头有一个售票机，其键盘可以看作是一个 $4\times 8$ 的矩阵，其中第一行的前面三个键和最后一行的最后三个键都是 `*`，剩余的键按照从上到下，从左到右的顺序依次按照 A~Z 的顺序排列。售票机可以买去往 $n$ 个城市的票。

现在你向售票机里面输入了一个长度为 $k$ 的字符串，售票机会将以这个字符串为前缀且长度 $\geqslant k+1$ 的所有城市的名字中的第 $k+1$ 个字母显示在键盘中这个字母原来所在的位置上，其余的键则用 `*` 代替，求最终键盘上的情况（按照前文所述的 $4\times 8$ 矩阵的格式输出）。

**数据范围：$1\leqslant n\leqslant 50$。**
## Solution
先给大家推荐一个和这题完全一样的题目：[P4470](https://www.luogu.com.cn/problem/P4470)，按照年份来看的话应该是 BJWC 蒯了 COCI 的。

然后话回正题。我们先比对一下看这个字符串是否包含这个前缀且长度 $\geqslant k+1$，这题目中完全可以暴力一个一个字符比对，然后将所有满足要求的字符串的第 $k+1$ 个字母保存，最后直接输出显示了所有保存的字母的键盘即可。
## Code
这份代码原封不动地蒯过去可以直接过 P4470。

```cpp
int n, vis[57], ans[27];
string s[57];

int main() {
	n = Rint;
	F(i, 1, n) {cin >> s[i]; vis[i] = 1;}
	cin >> s[n + 1]; int len = s[n + 1].size();
	F(i, 1, n) F(j, 0, len - 1)
		if(s[n + 1][j] != s[i][j]) {vis[i] = 0; break;}
	F(i, 1, n) if(vis[i] && len != s[i].size() && !ans[s[i][len] - 'A']) ans[s[i][len] - 'A'] = 1;
	printf("***");
	F(i, 0, 25) {
		putchar(ans[i] ? i + 'A' : '*');
		if(i == 4 || i == 12 || i == 20) puts("");
	}
	return printf("***"), 0;
}
```