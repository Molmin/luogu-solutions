## 思路：排序+贪心

#### 首先理解题意

>$B$有$n$个年份需要去，有$k$次穿越机会，但只能从一个$12$的整数倍年份传送到另一个$12$的整数倍年份,否则只能向前走一个年份，今年是$12$的整数倍年份（即第$0$年），问需最少多少年才能去所有要去的年份,$1≤k≤n$

-----
#### 分析题目

毫无疑问，我们先去最后一个需要去的年份之前最近的一个$12$整数倍的年份，因为如果先去了靠前的年份，我们还是需要再次回去，造成传送次数的浪费，且若$k=1$时，根本不可能完成任务。

那么如何求这个年份呢？我们用二分方法求解$O(\log m)$，代码如下

```cpp
int tf(int m,int l,int r)//二分查找早于m的12倍数的年份除以12的值 
{
	if(l==r-1)return r;
	int mid=(l+r)/2;
	if(mid*12<m)return tf(m,mid,r);
	else return tf(m,l,mid);	
}
```

取$l$和$r$两个数的平均值，看这个$m$区间在哪边，然后继续进行递归。

这里为什么判断语句是`if(l==r-1)`呢？因为当开始$l≠r$的时候，按照这个算法，$l$永远不可能等于$r$（~~想一想,为什么~~），因为$int$类型的除法是向下取整的，所以二分到$l=r-1$时$mid$的值永远只会是$r$了。

那么接下来我们该如何使用穿越次数呢？

我们知道，只有$12$的整数倍年份才能进行穿越，因此，每个有需要去的年份的$12$年都是不可避免的，而如果有一些年份在同一个$12$年的话，只需度过一个即可。

所以我们可以先去重，然后逐个求解相邻两个需要去的年份差(这里是指进行了$tf$函数后的差，当然，也可以把$12$乘回去再减)接着减一(植树问题)，接着放入优先队列再出队前$k$个即可，总复杂度大约$O(n\log m+k)$。

上代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[70000],b[70000];
int tf(int m,int l,int r)//二分查找早于m的12倍数的年份除以12的值 
{
	if(l==r-1)return r;
	int mid=(l+r)/2;
	if(mid*12<m)return tf(m,mid,r);
	else return tf(m,l,mid);	
}
priority_queue<int>q;
int main()
{
	int n,k;
	cin>>n>>k;
	for(int i=0;i<n;i++)
	{
		cin>>a[i];
	}
	sort(a,a+n);
	int ans=tf(a[n-1],0,10000000)*12;//首先要穿越到最后一年之前的某一年 
	int now=0;
	for(int i=0;i<n;i++)//去掉在相同12年中重复的，顺带排序 
	{
		int x=tf(a[i],0,10000000);
		if(now!=0&&b[now-1]==x)now--;//避免在同一个12年中的年重复计算
		b[now]=x;
		now++; 
	}
	now--;
	q.push(b[0]-1);//第一个需要去的年份只用减1
	for(int i=1;i<=now;i++)
	{
		q.push(b[i]-b[i-1]-1);
	}
	while((k-1)&&(!q.empty()))//将每次跳跃所减少的年数除以12取前k个，这里是判断k-1是否为0而不是k，因为while循环时只要满足条件就将一次循环进行完，而到第二次再判断，即这里如果写k就会从k循环到0，共k-1次跳跃
	{
		ans-=q.top()*12;
		q.pop();
		k--;
	}
	cout<<ans;
	return 0;
}
```

### 代码仅供参考，请自行编写代码