# 题意

## 题目描述

有一个有$n$位的密码锁，给出两个序列，求最少拨动密码锁多少次可以使得第一个序列变为第二个序列。

## 题面源代码

```
## 题目描述

有一个有$n$密码锁，给出两个序列，求最少拨动密码锁多少次可以使得第一个序列变为第二个序列。
```

# 思路

针对这个问题，我们只需要**求出第一个序列每一位变化为第二个序列的拨动次数**，再进行**累加**即可。

关于**求出第一个序列每一位变化为第二个序列的拨动次数**，我们可以**~~打表~~**经过精密的计算得出以下代码。

```cpp
const int ans[10][10]={
/*    0 1 2 3 4 5 6 7 8 9*/
/*0*/{0,1,2,3,4,5,4,3,2,1},
/*1*/{1,0,1,2,3,4,5,4,3,2},
/*2*/{2,1,0,1,2,3,4,5,4,3},
/*3*/{3,2,1,0,1,2,3,4,5,4},
/*4*/{4,3,2,1,0,1,2,3,4,5},
/*5*/{5,4,3,2,1,0,1,2,3,4},
/*6*/{4,5,4,3,2,1,0,1,2,3},
/*7*/{3,4,5,4,3,2,1,0,1,2},
/*8*/{2,3,4,5,4,3,2,1,0,1},
/*9*/{1,2,3,4,5,4,3,2,1,0}
};
```

其中```ans[i][j]```表示从$i$拨动到$j$需要```ans[i][j]```步。

特别地，```ans[i][i]=0```。

# 代码

代码如下。

```cpp
#include<stdio.h>

const int ans[10][10]={
/*    0 1 2 3 4 5 6 7 8 9*/
/*0*/{0,1,2,3,4,5,4,3,2,1},
/*1*/{1,0,1,2,3,4,5,4,3,2},
/*2*/{2,1,0,1,2,3,4,5,4,3},
/*3*/{3,2,1,0,1,2,3,4,5,4},
/*4*/{4,3,2,1,0,1,2,3,4,5},
/*5*/{5,4,3,2,1,0,1,2,3,4},
/*6*/{4,5,4,3,2,1,0,1,2,3},
/*7*/{3,4,5,4,3,2,1,0,1,2},
/*8*/{2,3,4,5,4,3,2,1,0,1},
/*9*/{1,2,3,4,5,4,3,2,1,0}
};//打表

char str1[1024],str2[1024];//两个序列
int n;

int main(void){
	register int i,sum=0;//寄存器更快些，sum应初始化为0
	scanf("%d%s%s",&n,str1,str2);//读入
	for(i=0;i<n;i++)
		sum+=ans[str1[i]-'0'][str2[i]-'0'];//累加
	printf("%d\n",sum);//输出
	return 0;//结束
}
```

## [我的测评记录](https://www.luogu.org/record/show?rid=9540062)