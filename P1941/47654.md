看楼下没有写滚动数组的，这里还是献个丑，略讲一下。

一般而言这类DP题目只要开二维数组就可以直接过了，不过存在一个问题，就是DP只需要运用到上一个状态的数据而我们却把所有数据都存下来了，所以说我们可以用滚动数组优化空间复杂度，把O(n^2)简化成O(2n)。当然有时候（比如说这里）不写滚动数组也不会炸空间，不过个人认为还是掌握一下比较好。

不多说我们来看这道题。自然想到F[i][j]表示到达点(i,j)所需的最小点击次数，赋初值为极大值（但不要赋2147483647以防溢出），然后就是状态转移方程，就是每个点可能由哪些点转移过来。

这里说几个点：1、正解的时间复杂度是O(nm)，由于每个点可以连跳很多次，要是去打循环不知不觉就变成O(n\*m^2)了，所以说会炸时间（可能是最后一两个点）。其实可以当做是一个完全背包问题，在容量允许范围内（这里是不超过M高度限制的范围内）可以任意选取该种物品（跳任意次），所以说我们就可以用F[i][j-up[i]]+1去推知F[i][j]（具体详见完全背包问题）。

2、接着1讲。从下方的点推知上方的点，问题是如果下方的点不是向上跳得来的，而是向下掉得来的怎么办呢？这个问题我想了很久，后来改了一下顺序，就想通了——我们只要先处理向上跳的情况，再处理向下掉的情况就可以了。

3、到达M高度时特殊处理：因为所有高度大于M-up[i]的点都可以跳到M高度，所以在M高度时要循环一遍找最优解。

4、初值的问题。首先F[0]要全部是0，因为可以从第0列的任意一个位置开始（(0,0)除外），之后每一次处理前赋极大值就好了，高度为0的情况其实可以不用处理，直接从1开始循环就好了。

5、其实剩下的问题就好办了，每个i循环完我们就对F数组进行一次判断，如果答案都是极大值就说明已经没有办法跳过来了，就直接输出0和管道数然后return 0；如果循环到了N都没有上述情况就说明可以跳出来，输出1和最佳方案。

上代码吧。




    
        
        
```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
#define oo 1e9 //不要打2147483647 会溢出的 
using namespace std;
struct guandao{
    int bot;
    int top;
    bool exist;//判断一下该位置上管道是否存在 
}k[10001];
struct weiyi{
    int up;
    int dw;
}a[10001];
int N,M,K,p,Min,sum;
int F[2][1001];//达到点(i,j)的最小点击次数 滚动数组 
int gi()//非负数读入优化
{
    int x=0;
    char ch=getchar();
    while (ch<'0'||ch>'9') ch=getchar();
    while (ch>='0'&&ch<='9')
    {
        x=x*10+ch-'0';
        ch=getchar();
    }
    return x;
}
int main()
{
    freopen("bird.in","r",stdin);
    N=gi();M=gi();K=gi();
    for (int i=1;i<=N;i++)//题目叙述略显麻烦, 改了一下,可以当做第i列上升下降的高度就是up[i] dw[i]
    {
        a[i].up=gi();
        a[i].dw=gi();
    }
    for (int i=0;i<=N;i++)//管道初始化，默认上下界，默认不存在
    {
        k[i].bot=0;
        k[i].top=M+1;
        k[i].exist=false;
    }
    for (int i=1;i<=K;i++)
    {
        p=gi();
        k[p].bot=gi();
        k[p].top=gi();
        k[p].exist=true;
    }
    //i%2 、(i-1)%2正是滚动数组的技巧
    for (int i=1;i<=N;i++)//模拟游戏过程 
    {
        for (int j=1;j<=M;j++)
          F[i%2][j]=oo;
        //枚举这一列可以通行的点 
        for (int j=1;j<=M;j++)//上升 可连跳 形如完全背包问题 
        {
            if (j-a[i].up>0)
            {
                F[i%2][j]=min( F[i%2][j] , min( F[(i-1)%2][j-a[i].up],F[i%2][j-a[i].up] )+1 );
            }
        }    
        //为避免上升由下降推得 直接把上升写在下降前面不就好了么 
        for (int j=1;j<=M;j++)
        {
            if (j+a[i].dw<=M) 
              F[i%2][j]=min( F[i%2][j] , F[(i-1)%2][j+a[i].dw] );
        }    
        //高度M的特殊处理
        if (k[i].top==M+1)
        {
            for (int j=M;j>=max(1,M-a[i].up);j--)
            {
                F[i%2][M]=min(F[i%2][M],min(F[(i-1)%2][j],F[i%2][j])+1);
            }
        }
        for (int j=1;j<=M;j++)
          if (j<=k[i].bot||j>=k[i].top) F[i%2][j]=oo;//被管道拦住的地方不能通行 
        if (k[i].exist==true) sum++;//通过的管道数 
        Min=oo;
        for (int j=1;j<=M;j++)
          Min=min(Min,F[i%2][j]);
        if (Min==oo)
        {
            printf("0\n%d",sum-1);//当前的管道不能通过，所以要减1
            return 0;
        }
    }
    printf("1\n%d",Min);
    return 0; 
}
```