# **高斯消元法**

------------


# 概念分析

#### 高斯消元法是一个用来求解线性方程组的算法

那么什么是线性方程组呢？

- 简而言之就是有多个未知数，并且每个未知数的次数均为一次，这样多个未知数组成的方程组为线性方程组。
- 或者我们也可以说是多元一次方程组

我们给一个例子吧：

$\begin{cases} 2x+y+z=1\\6x+2y+z=-1\\-2x+2y+z=7\end{cases}$

这就是一个适用于高斯消元的方程组（是不是很熟悉呢？）

高斯消元主要是运用两种消元方法：**加减消元法**和**代入消元法**

~~Antys说初中介绍过加减消元和代入消元法，那我们这里就不详细介绍这两个的定义了。~~

高斯消元的目的是，先进行加减消元（关于加减消元的详细步骤会在下面给出），然后我们可以先求得一个未知数的值，然后可以逐层往回代（代入消元法），依次可以得到定第$2$个、第$3$个未知数的值······

最终解出方程组中各个$x$的值，结束算法

## 以上就是高斯消元的整体思路

------------


# 算法分析

如果给定一个形如以下式子的多元方程式

$\begin{cases} 2x+y-z=8\\ -3x-y+2z=11\\-2x+y+2z=-1\end{cases}$

### 我们要首先提出各项的系数
-  因为我们知道，高斯消元其实只跟系数有关

我们可以写成以下的矩阵形式

其中左边是各项的系数，分隔线之后的是等式右边的常数列

$\begin{bmatrix}2&1&-1&|&8 \\ -3&-1&2&|&-11\\-2&1&2&|&-3\end{bmatrix}$

$\quad\qquad\Downarrow$ 经过r行和第i行交换

$\begin{bmatrix}-3&-1&2&|&-11 \\ 2&1&-1&|&8\\-2&1&2&|&-3\end{bmatrix}$

此时就可以开始加减消元了

首先我们要用第$i$个方程的来消去第$k$个方程的第$k$列，那么第$k$行的所有元素
$A[k][j]$都应该减去$A[i][j]$的$A[k][i]/A[i][i]$倍。

**（我们这里约定，A[a][b]指的是第$a$行第$b$列的系数）**

我们用实例讲解一下：
- 这是一个已经经过第一步处理的矩阵（我承认就是从上面copy过来的）：

$\begin{bmatrix}-3&-1&2&|&-11 \\ 2&1&-1&|&8\\-2&1&2&|&-3\end{bmatrix}$

$\quad\qquad\Downarrow$ 经过加减消元

$\begin{bmatrix}-3&-1&2&|&-11 \\&&&|\\ &\dfrac{1}{3}&\dfrac{1}{3}&|&\dfrac{2}{3}\\&&&|\\&\dfrac{5}{3}&\dfrac{2}{3}&|&\dfrac{13}{3}\end{bmatrix}$

（这就是加减消元的第一步）

#### 还不理解？没关系（我再解释一下）

- 请看这里

	1、第二行相当于是$L_1*\dfrac{2}{3}+L_2$
    
    2、同理，第三行相当于是$L_1*(-\dfrac{2}{3})+L_2$
   
   （这里的$L_k$指的是矩阵中的第$k$行）
    
#### 现在应该明白了吧
 
 接下来要做什么呢？ $\qquad$——代入！
 
 根据我们的算法，可以直接从最后一行推出$X_n$的值，然后倒数第二行可以推出$X_{n-1}$的值，· · ·以此类推。
 
 最后我们可以求出所有$X$的唯一解
 
 ### 然后？. . . . . . 然后就没有然后了呀
 
 # **至此，对于高斯消元的理论分析已全部结束，接下来给代码。**

------------


# **·** 这里给出各部分代码的详解
### 1. 经过$r$行和第$i$行交换 && 加减消元 （因为这是在一个循环里的所以就写在一起了）
```cpp
    for(int i = 0; i < n; i ++) {
        r = i;
        for(int j = i + 1; j < n; j ++)
            if(fabs(A[j][i]) > fabs(A[r][i])) r = j; //fabs()表示计算浮点数的绝对值
        if(r != i) for(int j = 0; j <= n; j ++) std :: swap(A[r][j], A[i][j]);
       				/*↑↑      经过r行和第i行交换      ↑↑*/
                    
        for(int k = i + 1; k < n; k ++) {
			double f = A[k][i] / A[i][i];
			for(int j = i; j <= n; j ++) A[k][j] -= f * A[i][j];
		}            
        				/*↑↑     加减消元（低精度）    ↑↑*/
        
        for(int j = n; j >= i; j --) {
            for(int k = i + 1; k < n; k ++)
                A[k][j] -= A[k][i] / A[i][i] * A[i][j];
        }
        				/*↑↑     加减消元（保证精度）    ↑↑*/
    }
```

### 2.回代过程
```cpp
	for(int i = n - 1; i >= 0; i --) {
		for(int j = i + 1; j < n; j ++)
			A[i][n] -= A[j][n] * A[i][j];
		A[i][n] /= A[i][i];
	}
```

#### PS.这里解释一下精度和低精度的差别，低精度问题主要是引进中间变量 $double\quad f$ ，$double$ 值在进行运算时会损失一定的精度，那么我们可以逆序枚举，从下往上减，这样就可以避免中间变量的使用，从而保证算法的精度。

# 总代码如下
```cpp
void Gauss() {
	for(int i = 0; i < n; i ++) {
		r = i;
		for(int j = i + 1; j < n; j ++)
			if(fabs(A[j][i]) > fabs(A[r][i])) r = j;
		if(r != i) for(int j = 0; j <= n; j ++) std :: swap(A[r][j], A[i][j]);

		for(int j = n; j >= i; j --) {
			for(int k = i + 1; k < n; k ++)
				A[k][j] -= A[k][i] / A[i][i] * A[i][j];
		}
	}

	for(int i = n - 1; i >= 0; i --) {
		for(int j = i + 1; j < n; j ++)
			A[i][n] -= A[j][n] * A[i][j];
		A[i][n] /= A[i][i];
	}
}
```

$\quad$

$\quad$

## 主要参考来源：

1. [cppreference](https://zh.cppreference.com/w/cpp)
1. 刘汝佳 《算法竞赛入门经典——训练指南》