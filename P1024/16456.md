①枚举法

根据根的值域和根与根之间的间距要求（≥1），根的范围在-100到100之间，结果只要保留两位小数，我们不妨将根的值域扩大100倍（-10000≤x≤10000），依次枚举该区间的每一个整数值 x，并在题目要求的精度内设定区间：若区间端点的函数值 f’(x1)和 f’(x2)异号或者在区间端点x1 的函数值f’(x1)=0，则确定 为f’(x)=0 的一个根。

有的同学在比赛中是这样做:

```cpp
var k:integer;
    a,b,c,d,x :real;
begin
  read(a,b,c,d);
  for k:=-10000 to 10000 do begin
    x:=k/100;
    if a*x*x*x+b*x*x+c*x+d=0 then write(x:0:2,' ');
  end;
end.
```
用这种方法，很快就可以把程序编出来，再将样例数据代入测试也是对的，等成绩下来才发现这题没有全对，只得了一半的分。
这种解法为什么是错的呢？错在哪里？前面的分析好象也没错啊，难道这题不能用枚举法做吗？看到这里大家可能有点迷惑了。


在上面的解法中，枚举范围和枚举对象都没有错，而是在验证枚举结果时，判定条件用错了。因为要保留二位小数，所以求出来的解不一定是方程的精确根，再代入ax3+bx2+cx+d中，所得的结果也就不一定等于0，因此用原方程ax3+bx2+cx+d=0作为判断条件是不准确的。

为了使精度更高，所以要把循环变量k为-1000000 到1000000

而x=k/10000是可以AC的。

```cpp
var a,b,c,d:real; 
     k:real;
     i:longint;
function f(x:real):real;
begin
 exit(a*x*x*x+b*x*x+c*x+d);
end;
begin
 readln(a,b,c,d);
 for i:=-1000000 to 1000000 do begin
  k:=i/10000;
  if abs(f(k))<=0.0001 then write(k:0:2,' ');
 end;
end.
```
②分治法
由题意知（i,i+1）中若有根，则只有一个根，我们枚举根的值域中的每一个整数x(-100≤x≤100),设定搜索区间[x1，x2]，其中x1=x，x2=x+1。若：

⑴f(x1)=0，则确定x1为f(x)的根；

⑵f(x1)\*f(x2)<0，则确定根x在区间[x1，x2]内。

⑶f(x1)\*f(x2)>0，则确定根x不在区间[x1，x2]内，设定[x2，x2+1]为下一个搜索区间；

若确定根x在区间[x1，x2]内，采用二分法，将区间[x1，x2]分成左右两个子区间：左子区间[x1，x]和右子区间[x，x2]（其中x=（x1+x2）/2）。如果f(x1)\*f(x)≤0，则确定根在左区间[x1，x]内，将x设为该区间的右界值（x2=x），继续对左区间进行对分；否则确定根在右区间[x，x2]内，将x设为该区间的左界值（x1=x），继续对右区间进行对分；

上述对分过程一直进行到区间的间距满足精度要求为止（即x2-x1<0.005）。此时确定x1为f(x)的根。
