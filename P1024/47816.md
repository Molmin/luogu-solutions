这题数据实在太水了，直接枚举都能过。。。

不过作为一名OIer，我们要追求的就是算法的效率，不然会被各种毒瘤数据卡死掉。


------------
上面都是**~~废话~~**前言；

那么这题存在一下几种做法：暴力枚举，分治（二分），和牛顿法求零点。接下来讲我的做法（可能对初中学生不大友好，因为要用到求导）：

对于任意一个函数f（x），设初始选定x，x1为其逼近零点的下一个点，则可以用牛顿法：

$x1=x-f(x)/f'(x)$ （$f'(x)$为$f(x)$的一阶导数）

我们不断递推就可以得到一个零点。把100和-100分别作为两个初始值，求得一个大和  一个小的零点x1,x3，然后把(x1+x3)/2作为一个初始值求出中间的零点x2。
比二分法快到不知道到哪里去了。

（注：三次函数$f(x)=ax^3+bx^2+cx+d$的一阶导数是$f'(x)=3ax^2+2bx+c$，可以用公式得出，主要是为那些没学这些的人考虑的）

个人认为我的代码还算比较好看的：

```cpp

#include <bits/stdc++.h>
using namespace std;
double a,b,c,d,a1,b1,c1,x1=-100,x2,x3=100;
double abs(double x)
{
return x<0?-x:x;
}
void search(double &x)
{
while(abs(a*x*x*x+b*x*x+c*x+d)>0.01)
x-=(a*x*x*x+b*x*x+c*x+d)/(a1*x*x+b1*x+c1);
}
int main()
{
scanf("%lf%lf%lf%lf",&a,&b,&c,&d),
a1=3*a,b1=2*b,c1=c,
search(x3),search(x1),
x2=(x1+x3)/2,search(x2),
printf("%.2lf %.2lf %.2lf",x1,x2,x3);
}
```