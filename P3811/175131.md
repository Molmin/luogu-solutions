## ~~非常~~比较全的数论—同余大礼包

需要更好的阅读体验请戳本蒟蒻博客：

[浅谈欧拉定理及乘法逆元](https://www.cnblogs.com/fusiwei/p/12013269.html)

# 浅谈欧拉定理

本篇随笔简单讲解一下信息学奥林匹克竞赛数论部分**欧拉定理**这一知识点。介绍的内容大致分为这么几个部分：**“同余的基本概念、费马小定理、欧拉定理及其推论、乘法逆元”**。

## 同余的基本概念

同余的概念啊非常简单啦：如果两个整数$a,b$除以一个数$m$的余数相等的话，那么就叫做$a,b$在模$m$的意义上同余。

记作：
$$
a\equiv b\,\,\,(mod\,\,m)
$$
那么根据同余的这个定义，我们很容易能推导出一个性质：如果两个数$a,b$在模$m$的意义下同余，那么$a-b$就是$m$的倍数，这是显然的。

以及，如果$a\%m=1$，那么就可以被改写成这样的式子：
$$
a\equiv 1\,\,\,(mod\,\,m)
$$
这个转化的正确性也是显然的。

## 费马小定理

费马小定理也非常简单啦！用语言描述就是，如果一个数$p$是质数，那么对于一个不为$p$的倍数的整数$a$，有$a^{p-1}\equiv 1\,\,\,(mod\,\,p)$。那么把这个结论两边同时乘上一个$a$，即可得出：对于任意的整数$a$，$a$的$p$次幂与$a$在模$p$的意义上同余。

即：
$$
a^p\equiv a\,\,\,(mod\,\,p)
$$
证明过程由于笔者水平有限，请参阅百度百科：

引理1．
　　若a,b,c为任意3个整数,m为正整数，且(m,c)=1，则当a·c≡b·c(mod m)时，有a≡b(mod m)。
　　证明：a·c≡b·c(mod m)可得ac–bc≡0(mod m)可得(a-b)·c≡0(mod m)。因为(m,c)=1即m,c互质，c可以约去，a– b≡0(mod m)可得a≡b(mod m)。 [2] 

引理2．
　　设m是一个[整数](https://baike.baidu.com/item/整数)且m>1，b是一个[整数](https://baike.baidu.com/item/整数)且(m,b)=1。如果a[1],a[2],a[3],a[4],…a[m]是模m的一个完全剩余系，则b·a[1],b·a[2],b·a[3],b·a[4],…b·a[m]也构成模m的一个完全剩余系。
　　证明:若存在2个整数b·a[i]和b·a[j]同余即b·a[i]≡b·a[j](mod m)..(i>=1 && j>=1)，根据引理1则有a[i]≡a[j](mod m)。根据完全剩余系的[定义](https://baike.baidu.com/item/定义)可知这是不可能的，因此不存在2个[整数](https://baike.baidu.com/item/整数)b·a[i]和b·a[j]同余。

所以b·a[1],b·a[2],b·a[3],b·a[4],…b·a[m]构成模m的一个完全剩余系。

构造素数

![img](https://gss1.bdstatic.com/-vo3dSag_xI4khGkpoWK1HF6hhy/baike/pic/item/f603918fa0ec08faec6557995bee3d6d55fbdaa3.jpg)

 的完全

![img](https://gss1.bdstatic.com/9vo3dSag_xI4khGkpoWK1HF6hhy/baike/pic/item/9e3df8dcd100baa13c70ba174c10b912c8fc2e3a.jpg)

因为

![img](https://gss1.bdstatic.com/-vo3dSag_xI4khGkpoWK1HF6hhy/baike/pic/item/ac345982b2b7d0a2f13640a3c9ef76094b369a15.jpg)

 ，由引理2可得

![img](https://gss2.bdstatic.com/-fo3dSag_xI4khGkpoWK1HF6hhy/baike/pic/item/0824ab18972bd4073bdc2e5170899e510fb30906.jpg)

也是p的一个完全[剩余系](https://baike.baidu.com/item/剩余系)。由完全剩余系的性质，

![img](https://gss3.bdstatic.com/7Po3dSag_xI4khGkpoWK1HF6hhy/baike/pic/item/83025aafa40f4bfbe4ad63f8084f78f0f7361818.jpg)

即

![img](https://gss1.bdstatic.com/-vo3dSag_xI4khGkpoWK1HF6hhy/baike/pic/item/cc11728b4710b9123dbd0b52c8fdfc039245221a.jpg)

易知

![img](https://gss0.bdstatic.com/94o3dSag_xI4khGkpoWK1HF6hhy/baike/pic/item/d01373f082025aafdc613df5f9edab64034f1ab8.jpg)

 ，两边可约去 

![img](https://gss1.bdstatic.com/9vo3dSag_xI4khGkpoWK1HF6hhy/baike/pic/item/0dd7912397dda144345f911eb9b7d0a20df486cc.jpg)

这样就证明了费马小定理。

**（结论必须要记住）**：
$$
a^p\equiv a\,\,\,(mod\,\,p)
$$

## 欧拉定理

在学习欧拉定理之前，需要先学习一下欧拉函数。推荐本蒟蒻的这篇博客：

[欧拉函数详解]( https://www.cnblogs.com/fusiwei/p/11726768.html )

那么有了这个知识做铺垫，我们就可以得出欧拉定理的式子：
$$
a^{\phi(p)}\equiv1\,\,\,(mod\,\,p)
$$
也就是说，如果$a,p$为整数且$a,p$互质，那么$a$的$p$的欧拉函数次幂与$1$在模$p$意义下同余。

（以下证明摘自百度百科。）

### 证明

将1~n中与n互质的数按顺序排布：x1,x2……xφ(n) （显然，共有φ(n)个数）

我们考虑这么一些数：

m1=a*x1;m2=a*x2;m3=a*x3……mφ(n)=a*xφ(n)

1）这些数中的任意两个都不模n同余，因为如果有mS≡mR (mod n) （这里假定mS更大一些），就有：

mS-mR=a(xS-xR)=qn，即n能整除a(xS-xR)。但是a与n互质，a与n的最大公因子是1，而xS-xR<n，因而左式不可能被n整除。也就是说这些数中的任意两个都不模n同余，φ(n)个数有φ(n)种余数。

2）这些数除n的余数都与n互质，因为如果余数与n有公因子r，那么a*xi=pn+qr=r(……)，a*xi与n不互质，而这是不可能的。(因为a*xi=pn+qr=r(……)，说明a*xi含有因子r，又因为前面假设n含有因子r，所以a*xi和n含有公因子r，因此a*xi与n不互质)那么这些数除n的余数，都在x1,x2,x3……xφ(n)中，因为这是1~n中与n互质的所有数，而余数又小于n.

由1）和2）可知，数m1,m2,m3……mφ(n)（如果将其次序重新排列）必须相应地同余于x1,x2,x3……xφ(n).

故得出：m1*m2*m3……mφ(n)≡x1*x2*x3……xφ(n) (mod n)

或者说a^[φ(n)]*(x1*x2*x3……xφ(n))≡x1*x2*x3……xφ(n)(mod n)

或者为了方便：K{a^[φ(n)]-1}≡0 ( mod n ) 这里K=x1*x2*x3……xφ(n)。

可知K{a^[φ(n)]-1}被n整除。但K中的因子x1,x2……都与n互质，所以K与n互质。那么a^[φ(n)]-1必须能被n整除，即a^[φ(n)]-1≡0 （mod n），即a^[φ(n)]≡1 （mod n），得证。

## 欧拉定理的推论

欧拉定理能干什么呢？

比如，简化幂的模运算。

例题：计算$7^{222}$的个位数。（也就是计算$7^{222}mod\,\,10$）。

那么，根据欧拉定理，$a^{\phi(p)}\equiv1\,\,\,(mod\,\,p)$，我们可以有以下的推导：

首先，因为$7,10$互质，且$\phi (10)=4$，所以有：$7^4\equiv 1\,\,\,(mod\,\,10)$。

那么，根据取余的性质，因为$7^4mod\,\,10=1$，所以$7^4$的$n$次幂模10还等于1.

那么就可以有：

$7^{222}=7^{4\times55+2}$，把1全部约去，得到：

$7^2\equiv7^{222}\,\,\,(mod\,\,10)$

这样就简单多了。

所以我们得出了这样的一个结论：
$$
a^n\,\,mod\,\,p=a^{n\%\phi(p)}\,\,mod\,\,p
$$
也就是说：
$$
a^n\equiv a^{n\%\phi(p)}\,\,\,(mod\,\,p)
$$
这个结论也叫做：**欧拉定理的推论**，极其重要。

对于线性计算的式子（这里**指四则基本运算中除了除法之外的三种运算**），如果要求我们对于$a+b,a-b,a\times b$的结果取模，那么我们完全可以在进行运算之前先对$a,b$取模，对结果不会造成任何影响。

但是如果要求我们对$a^b$这样的式子取模呢？

这就用到了欧拉定理的推论：我们可以把底数对$p$取模（这个操作的正确性就是由前面说的四则混合运算的正确性推导出来的，别忘了乘方运算的实质是一堆连乘）。指数对$\phi(p)$取模，再进行运算即可（快速幂走起）。

## 求乘法逆元

#### 乘法逆元的概念

其实是一个介绍定义的过程：

如果$ax\equiv1\,\,\,(mod\,\,p)$，并且$a,p$互质，则称$a$关于模$p$的乘法逆元为$x$。

还是比较容易记住的。

#### 乘法逆元的求解

举个例子：

如果需要我们求解$4$关于模$7$的乘法逆元。那么也就是说，对于这个需要去求解的乘法逆元$x$，我们只需要找到一个$k$，使得下式成立：
$$
4x=7k+1
$$
（这个式子是由于乘法逆元的定义：$4x\equiv 1\,\,\,(mod\,\,7)$以及同余的定义得到的）。

关于乘法逆元的求解，我们首先要对其进行分类。

首先，我们需要明白的是，对于$a$关于模$p$的乘法逆元的求解，只有在$a,p$互质的时候才有解，否则就是无解。这不仅是定义规定的，更是满足大前提的首要条件（大家只需要牢牢记住就好）。

那么，现在，$a,p$已经互质了。那么又有两种情况：模数$p$是否为素数。

**假如$p$为素数。**那么我们可以使用**费马小定理**来求解乘法逆元。

根据费马小定理，有：$a^{p-1}\equiv1\,\,\,(mod\,\,p)$，那么结合乘法逆元的定义，如果$a,p$互质，那么原式可以拆成$a\times a^{p-2}\equiv1\,\,\,(mod\,\,p)$。也就是说，这个时候的乘法逆元就是$a^{p-2}$。



假如$p$不是素数，就需要我们使用**扩展欧几里得算法求解**，对于扩展GCD还有不明白的小伙伴，请移步本蒟蒻的这篇博客：

[浅谈扩展GCD]( https://www.cnblogs.com/fusiwei/p/11775503.html )

对于扩展欧几里得算法，我们知道它可以被用于求解同余方程。

那么就和乘法逆元的求解很匹配了，因为乘法逆元的求解本质上就是在求解这么一个同余方程：
$$
ax\equiv 1\,\,\,(mod\,\,p)
$$
但是，扩展GCD解决的是形如$ax+by=\gcd(a,b)$的东西，和这个同余式子有什么关系呢？

如果像我一开始一样不太会变通的话，请看下面的证明过程。

最裸最裸，我们会求解形如：$ax+by=\gcd(a,b)$，这样的方程。

那么，我们只需要把这个$ax\equiv1\,\,\,(mod\,\,p)$转换成这样的形式进行求解即可。

假设我们可以把这个同余方程转换成$ax+by=\gcd(a,b)$的形式，那么当$a,b$互质时，$\gcd(a,b)=1$，咦？我们发现这个东西和乘法逆元的定义：$a,p$互质好像啊！那就让$b=p$吧！

那么，有$ax+by=1$。

两侧同时对$b$取模（因为这个时候$b=p$了），有$ax\%b+by\%b=1\%b=1$。

因为$by\%b=0$，所以原式就变成了：

$ax\equiv1\,\,\,(mod\,\,p)$，得证。

也就是说，如果要求一个数$a$关于$p$的乘法逆元，直接向扩展GCD算法的模板里传$(a,p,x,y)$，最后的$x$就是我们要求的乘法逆元。

这样的话有一道~~经典裸题~~例题：[NOIP2012同余方程]( https://www.luogu.com.cn/problem/P1082 )

然后我们就可以**求出一个数的乘法逆元**。

## 线性求逆元

其实我认为，前面的“求一个数的逆元”的部分最终还是为这个“线性求逆元”做铺垫（理论知识大于天嘛！）。我们在学数论的时候可能都会发现，我们在探究的过程中都是一个“由局部到整体”的概念：由判断一个数是否为质数到判断一群数是否为质数，由求一个数的约数集合到筛选一群数的约数集......同样，在学会了求一个数的逆元之后，我们要学习线性筛逆元。

求一个数的逆元的复杂度是$O(\log N)$的。如果我们要求很多数的逆元的时候，如无意外它的复杂度会是$O(N\log N)$的，这显然不符合我们的需求。所以，我们要开发一个$O(n)$的线性求逆元的算法。

线性筛逆元其实是一个递推的过程，我们在这里着重讲其递推式的建立与证明。

首先我们有：
$$
1^{-1}\equiv 1\,\,\,(mod\,\,p)
$$
我们把$p$拆开，拆成这样的形式：$p=k\times m+n$，这是可以成立的，因为任意一个正整数都可以被拆成这样的形式。

所以我们有：
$$
k\times m+n\equiv 0\,\,\,(mod\,\,p)
$$
（这个同余式其实表示的意义就是整除）

那么，两边同时除以$m,n$（即同时乘$m^{-1},n^{-1}$），则有
$$
\frac{k}{n}+\frac{1}{m}\equiv0\,\,\,(mod\,\,p)
$$
移项有：
$$
\frac{1}{m}\equiv-\frac{k}{n}\,\,\,(mod\,\,p)
$$
因为$k$就是$\lfloor\frac{p}{m}\rfloor$，$n$就是$p\,\,\,mod\,\,\,m$，所以原式就变成了：
$$
m^{-1}\equiv-\lfloor\frac{p}{m}\rfloor\times(p\,\,\,mod\,\,\,m)^{-1}\,\,\,(mod\,\,p)
$$
根据乘法逆元的定义，对于一对互质的数$a,p$，有它的一个乘法逆元$x$满足：$ax\equiv1\,\,\,(mod\,\,p)$，那么$x\equiv a^{-1}\,\,\,(mod\,\,p)$，那么，根据上面的这个式子，我们就求出了数$m$关于模$p$意义下的逆元。

递推式如下（用$inv[i]$数组表示一个数的逆元）：
$$
inv[i]=-(p/i)\times inv[p\%i]
$$
为了不让乘法逆元出现一堆负数，我们需要对这个递推式稍做处理：
$$
inv[i]=((p-p/i)*inv[p\%i])\%p
$$
如果能看明白并且记住这个证明过程的话当然是极好的，如果看不明白，直接记结论也是完全可以的，但是，请做好考场上秒忘自己又一点不会推的准备（别怪我没告诉你）。

---

## 总结：

这篇总结是我耗时将近一周盘完这篇博客之后的附加之作

（本来认为乘法逆元这一块一天就能学完，但是我好像高估了自己的能力、低估了数学的魅力（呵呵），加之快期末了，各种文化课以及个人烂事层出不穷，导致更博和巩固的速度都极为地缓慢）。

本来以为学完了应该就会了，但是在学最后的线性求逆元的过程中惊喜地发现前面的东西大多又不会了（结论也就差不多记住，至于推导过程就全部忘光光了），于是才真正领略了什么是数论，以及为何数论这一块让一些数竞大佬都由衷地感觉困难。于是又刹下心来重新看了一下，顺便归纳出来了一些重点，这样的话，每次复习的时候就不用通篇浏览，只核对这些重要的知识点到底会不会就可以了。

那么，**学完这一课，你需要会的——**

### 1、同余的基本概念

你总不能对别人讲，我学完同余了，但是连式子也看不懂...

### 2、费马小定理

结论：
$$
a^{p-1}\equiv 1\,\,\,(mod\,\,p)
$$
即：
$$
a^p\equiv a\,\,\,(mod\,\,p)
$$
这个**定理的适用条件**一定要记住：$p$为质数，并且$a$不为$p$的倍数。

### 3、欧拉定理

结论：
$$
a^{\phi(p)}\equiv 1\,\,\,(mod\,\,p)
$$
它的**适用条件**是：$a,p$互质。

推论：
$$
a^{n}\equiv a^{n\%\phi(p)}\,\,\,(mod\,\,p)
$$
当然，这个定理不是供人显摆用的，知道了，还得会用：

欧拉定理的推论可以用来解决形如这样的式子的求解的问题：
$$
a^n\,\,\,mod\,\,p
$$

### 4、乘法逆元的概念

### 5、求单个数的乘法逆元的两种方式

知道求单个数的乘法逆元的两种方式及其使用条件：

对于求$ax\equiv 1\,\,\,(mod\,\,p)$中的$x$，（大前提当然是$a,p$互质）如果：

**$p$为质数**，那么可以使用费马小定理。

**$p$不为质数**，那么需要使用扩展GCD将同余式转换成形如$ax+by=\gcd(a,b)$的同余方程来求解。

### 6、线性筛逆元

结论（递推式）：
$$
inv[i]=((p-p/i)\times inv[p\%i])\%p
$$

---

那么代码：
```cpp
#include<cstdio>
#define int long long
using namespace std;
const int maxn=3*1e6+10;
int n,p;
int inv[maxn];
signed main()
{
    scanf("%lld%lld",&n,&p);
    inv[1]=1;
    printf("1\n");
    for(int i=2;i<=n;i++)
    {
        inv[i]=((p-p/i)*inv[p%i])%p;
        printf("%lld\n",inv[i]);
    }
    return 0;
}
```