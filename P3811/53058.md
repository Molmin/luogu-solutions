前面的大佬们似乎对于逆元的作用讲的不是很清楚。我便寻思着。。写一篇方便像我这种大菜鸡理解的题解。dalao请自行移步~

# 1.乘法逆元是什么？

“乘法逆元，是指数学领域群G中任意一个元素a，都在G中有唯一的逆元a'，具有性质a×a'=a'×a=e，其中e为该群的单位元。”--X度百科

没事，我知道你看不懂。(反正我是看不懂)

用现代汉语表述，便是我们需要找到一个数，让它可以把$a*b(mod\ p)$的$b$抵消。

无法理解？没事，让我们先看两个故事。

## 1.1.关于乘法逆元的类比

**[搬运&改编自这里](https://www.jianshu.com/p/e9e1c52bf6c9)**

### 1.1.1.加法

首先，想像一下，你在数学世界的加法王国里。你是那位德高望重的国王$a$。你在数轴的坐标$a$上。

有一天，你被一股神秘力量往数轴正方向怼了$b$个单位长度！你现在不再是国王$a$，而是不知名的$a+b$！

你很生气，想要重回宝座，怎么办？

怎么来的，怎么回去呗！

没错，你只需要往负方向走$b$个单位长度，你就重回了宝座$a$，你又可以指点江山。

如果那股神秘力量叫做加法。

没错，你重回宝座的方法叫做减法。

那让我们用数学公式把上述过程表述出来吧！

$$(a+b)-b=a$$


------------


### 1.1.2.乘法

请再想像一下，你还是在数学世界，只不过这一次是在乘法王国。

你是国王$a(a\in N^*)$。这回，那股神秘力量叫做乘法，把你往数轴正方向怼了$(b-1)(b\in N^*)$倍。也就是你现在在$a*b$的位置上。

你重回宝座的方法便是除法。你只需要找到从原点到现在所在位置的最靠近数轴的$b$等分点就完事儿了。

公式如下：

$$(a*b)/b=a\ \ \  (a,b \in N^*) $$



------------
### 1.1.小结：

其实不难发现，加法的逆操作叫作减法，乘法的逆操作叫作除法。

但是如果你仔细读过题，你就会发现“乘法逆元”的乘法好像和普通乘法不太一样——没错，所有算式是在$(mod p)$条件下的。

那我们该怎么办呢？

------------

## 1.2 乘法逆元的性质

我们先假设在$(mod\ p)$条件下，正整数i的逆元为$inv[i]$。其中inv是英语逆元(Inverse)的缩写。

对于任意大于等于1，小于(注意没有等于)$p$的正整数$a$，都有$a*inv[a] \equiv 1 (mod \ p)$

$e.g.\ \ a=2,b=3,p=5,inv[a]=3,inv[b]=2.$

### 1.2.1 让故事继续？

现在，你在$(mod p)$意义下的乘法王国。你是国王$a(a\in N^*)$。那股神秘力量把你往数轴正方向怼了$(b-1)(b\in N^*)$倍。

这还没完！由于现在是在$(mod\ p)$意义下的乘法王国，你的位置被$(mod\ p)$了
。

也就是你现在在$(a*b)mod\ p$的位置上。

这个时候，显然我们不能再做除法了。举一个很简单的例子:

$$a=2,b=3,p=5$$

乘法的答案是$6$，$(mod\ 5)$后答案是$1$.我们总不能计算(1/3)得到一个小数作为答案吧？

此时乘法逆元就十分有用了。

我们只需要把$1$乘上$inv[b]$就可以得到$2$,便是a的初始值。

为什么？

我们来推导一下公式：

$$\because b*inv[b]\equiv 1(mod\ p)$$

$$\therefore a*b*inv[b]\equiv a(mod\ p)$$

是不是十分简单易懂？

乘法逆元的本质，便是将在$mod\ p$条件下不方便操作的除法，聪明地转化成“抵消乘法带来的影响”。

# 2.代码实现

模板的代码也十分简短。

由于本文以解释为主，所以证明不作赘述。若需要证明，请大家移步dalao们的题解。

这里是一个线性解法。公式入下：


$$inv[i]=((p-p/i)*inv[p\ mod\ i])\ mod\ p;$$

代码如下：

```
#include<bits/stdc++.h>
using namespace std;
long long inv[3000005],n,p;
int main(){
	inv[1]=1;
    cin>>n>>p;
	for(int i=2;i<=n;++i)
        inv[i]=(long long)((p-p/i)*inv[p%i])%p;
    for(int i=1;i<=n;++i)
        printf("%lld\n",inv[i]);
}
```