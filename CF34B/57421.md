**2020年2月14日更新：修复题解排版问题**

----------

读题，发现要求的是能赚到的钱的**最大值**，采用**贪心策略**。

因为题目要求**能赚到的钱**，所以**要尽可能的去买价格为负数的电视**。

但是题目又有限制买的个数（只能买 $n$ ），怎么办？

我们拿一个例子来看看：

假如有三台电视，价格分别为 $a_1,a_2,a_3$，且 $a_1<a_2<a_3<0$。

如果**只能买一台**，选择哪台？

肯定是选择价格为 $a_1$ 的电视，因为**它能赚的钱最多**。

如果**再让你选一台**，选择哪台？

选择价格为 $a_2$ 的电视，因为在剩下的两台电视中，**它能赚的钱相对较多**。

好，总结一下：

**我们在所有价格为负的电视中，优先选择价格更低的电视，使每一步决策后都能赚尽量多的钱。** _这就是此题的贪心策略。_ 

----------

### 程序实现流程（本人采用二叉堆实现）

1. 建小根堆；
2. 读入数据，筛出全部负数；
3. 循环将堆顶**累减**（ _使负数转成正数_ ），直到数量超过 $n$ 或堆空；
4. 输出答案。

 _二叉堆的堆顶就是当前的最小价格。_ 

代码如下：

```cpp
#include<iostream>
#include<queue>
using namespace std;
priority_queue< int, vector<int>, greater<int> >q;
//建小根堆
int main()
{
    int n,m,ans=0,a;
    cin>>m>>n;  //读入m与n
    for(int i=0;i<m;i++){
        cin>>a;  //读入每个价格a
        if(a<0)
            q.push(a);  //筛出负数入堆
    }
    //数据读入&预处理
                
    while(!q.empty()){  //在堆不空情况下一直循环
        if(n==0) break;  //数量超过n，跳出循环
        ans-=q.top();    //统计堆顶（注意这里是减，因为要转成正的）
        n--;  //计数
        q.pop();  //删掉堆顶
    }
    cout<<ans;
    //计算&输出
              
    return 0;
}
```
