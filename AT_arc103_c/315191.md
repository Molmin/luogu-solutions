做完这道题后感觉自己可能是灵感爆发，竟然只花了10min就AC了。看了看题解发现题解的做法挺难想也挺复杂的，这里介绍自己的比较简单的构造方法。

首先把要求的东西变成一个有根树，根是谁不重要，重要的是这能方便我们的思考。

转成有根树后，题目的要求就是，如果对一个 $i$ 有 $s_i=1$，那么就是要求存在大小为 $i$ 或 $n-i$ 的子树，否则就是不存在大小为 $i$ 或 $n-i$ 的子树。

这样看来，只要 $s_i=1$，那么必有 $s_{n-i}=1$。实际上 $s_i=s_{n-i}$ 就是有解的必要条件之一。

我们来看一看样例：$\mathtt{1111}$ 无解，为什么？观察发现是因为 $s_4=1$，而在删去一条边后是不可能有大小为 $n$ 的连通块的，那么 $s_n=0$ 也是有解的必要条件之一。

另外，由于一棵树必须有叶子，那么有解的另一个必要条件就是 $s_1=1$。

总结一下我们现在得到的性质，其实也就只是有解的必要条件：

- 对于任意的 $1 \le i \le n-1$，有$s_i=s_{n-i}$
- $s_1=1$
- $s_n=0$

接下来我们考虑给定的01串 $s$ 在满足了上述三个条件之后能否构造出符合条件的树，如果构造出来了，我们就顺便证明了上面三个条件是有解的充要条件。

由于树具有递归的性质，因此我们考虑一种类似归纳的构造方法，这样会比较自然。

首先，由于我们知道树一定有叶子，于是我们在草稿纸上画上一个神秘的圈圈：

![](https://cdn.luogu.com.cn/upload/image_hosting/g0203o1m.png)

接下来的事情就比较奇妙了，~~我也不知道自己是怎么想到的反正脑子里瞬间就冒出了这个想法~~对于一个之后的每一个 $s_i$，总是新建一个点，**如果 $s_i=1$ 就把它作为当前所有没有父亲的点的父亲，否则就让它孤零零地待着**（从左到右扫一遍给定的01串）。

上面那段话有点绕，我们根据样例 $\mathtt{1010}$ 模拟一下：

$s_1=1$：直接画个圈

$s_2=0$：再画个圈

![](https://cdn.luogu.com.cn/upload/image_hosting/6ccf544w.png)

$s_3=1$：再画个圈并且把它和之前的点连起来

![](https://cdn.luogu.com.cn/upload/image_hosting/pkq2f0vi.png)

对于最后一个点，我们发现它需要特殊处理，其实很简单，直接把它挂到前面一个点的上面就好了：

![](https://cdn.luogu.com.cn/upload/image_hosting/9nl1ky80.png)

直觉上来讲，这个构造方法是可行的（可以手造一些数据模拟一下），我们来稍微分析一下它的正确性。每当我们遇到一个 $s_i$，若 $s_i=1$ 则上述方法可以**保证存在一个大小为 $i$ 的子树**，否则不存在大小为 $i$ 的子树，又由于已经有 $s_i=s_{n-i}$，则对于任意的 $s_i=0$ 一定**既不存在大小为 $i$ 的子树又不存在大小为 $n-i$ 的子树**，因此该算法正确。另外由于 $s_{n-1}=s_1=1$，所以最后一定只剩一个没有父亲的节点，一定可以把第 $n$ 个节点只用一条边连上去。

如果没有看懂我的兜圈子描述可以结合代码理解：

```cpp
#include<cstdio>
#include<cstring>

const int N=1e5+5;
char s[N];
int n;
int tot,t[N];//t[]存储当前没有父亲的节点，tot存储当前没有父亲的节点个数
int u[N],v[N],e;

int main()
{
    scanf("%s",s+1);
    n=strlen(s+1);
    if(s[1]=='0'||s[n]=='1')//无解情况2,3
    {
        printf("-1\n");
        return 0;
    }
    for(int i=1;i<n;++i)//无解情况1
        if(s[i]!=s[n-i])
        {
            printf("-1\n");
            return 0;
        }
    for(int i=1;i<n;++i)
    {
        if(s[i]=='1')
        {
            for(int j=1;j<=tot;++j)//把没有父亲的节点全部连到当前节点上
            {
                ++e;
                u[e]=i;
                v[e]=t[j];
            }
            tot=1;
            t[1]=i;
        }
        else t[++tot]=i;//当前节点没有儿子
    }
    u[++e]=n;//连最后一个点
    v[e]=t[1];
    for(int i=1;i<=e;++i)
        printf("%d %d\n",u[i],v[i]);
    
    return 0;
}
```
