------------
这题题意理解很难，但真不用从前往后一个一个模拟。

简略一下题意：

**寻找一个由 01 组成的字符串中 0/1 最后的位置，之后两者再求最小值。**
    
为什么可以这么理解？

因为既然是开门，那么不管开了多少门，只有开了最后一个门之后，通道才会开启。

那么我们只要寻找最后一个门所在的位置即可。

*~~你看这题理解题意后多简单呀~~*

$code$
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=200005;
char s[N];
int n;
int min_1,min_0;
/*min_1—1 的最后位置*/ 
/*min_0—0 的最后位置*/ 
int main ()
{
	scanf("%d",&n);
	scanf("%s",s);
	/*字符串加速读入*/ 
	for(int i=n,j=1;i>=1;i--,j++){
		/*从后往前数*/ 
        if(s[i]=='1' && min_1==0)
		/*因为是从后往前数的,需要判断这个字符*/ 
		/*是不是第一个遇到的*/ 
        {
        	min_1=n-j+1;
		}
		if(s[i]=='0' && min_0==0)
		/*同上*/ 
		{
			min_0=n-j+1;
		}
		if(min_1 && min_0)
		/*都找到了就跳出*/ 
		{
			break;
		}
    }
    printf("%d",min(min_1,min_0));
    /*求最小*/ 
    return 0;
 } 
```
