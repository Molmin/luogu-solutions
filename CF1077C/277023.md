别看这题是提高+的难度就怕了。

其实就是一个简简单单的想法题。

我们可以这样理解题目，有一个序列，每次操作我们删去其中一个元素，然后得到一个新的序列。

这个新序列的元素，我们可以分为一个元素x和其他元素，如果其他元素的和恰好等于元素x的值，那么这个新序列就是完美序列。

之后恢复成删除前的原序列。

题目需要我们记录下有多少次操作可以得到完美序列，并且记录下删除元素的下标。

**思路**：

1.这道题的重点是求和。求和得到的值才是需要我们记录的。所以我们可以先记录原序列的元素总和sum。

2.接着我们遍历序列，用sum-第i个元素的值得到的就是新序列的元素总和了。

3.新序列的特点是：如果其他元素的和恰好等于元素x的值，那么这个新序列就是完美序列。所以，新序列的和必然是元素x的两倍。

简单来说，如果这个新序列是一个完美序列，那么新序列元素和的一半sum/2，必然是新序列中的某个元素。

没错，至此判断条件已经得到了，所以你也会写了吧？

**特别注意**：这题的sum/2最高可以达到10^11的数量级，所以我们用map或者对sum/2进行特判。

好了，直接上代码。

```
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
ll a[200005];
map<ll,ll>mp;
vector<int>ve;
int main()
{
    int i,j,n;
    cin>>n;
    ll summ=0;
    for(i=1;i<=n;i++)
    {
        cin>>a[i];
        mp[a[i]]++;//记录元素x
        summ+=a[i];//求和
    }
    for(i=1;i<=n;i++)
    {
      ll sum=summ-a[i];
      /*
      也可以在这里写：
      if(sum/2>1000000)continue;
      这样子就可以不用map而用普通数组了。
      如果不特判就用普通数组的话，在下面是会有数组越界的！
      */
      mp[a[i]]--;
      if(sum%2==0&&mp[sum/2]>0)//新序列元素总和必然是x的两倍
            ve.push_back(i);
      mp[a[i]]++;
    }
    n=ve.size();
    cout<<n<<'\n';
    for(i=0;i<n;i++)
        printf("%d ",ve[i]);
    return 0;
}
```