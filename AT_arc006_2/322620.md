我们可以从原本`o`的这一个位置，顺着往上推。这样，就可以直接模拟了。

我们先用 $ans$ 记录`o`是在第几个竖线，用 $d$ 记录`o`是在第几列。然后，从下往上推，如果 $d$ 这一列左边有一个横线，那么就意味着要往左边走，$ans$ 就减去 $1$，$d$ 就减去 $2$（因为每一个竖线**中间**都会有一列空着或者一个横线，而不是竖线）反之，如果 $d$ 右边有一个横线，就意味着往右边走。$ans$ 就加上 $1$，$d$ 就加上 $2$。

最后的 $ans$ 即为所求的答案。

Code：
```cpp
#include <cstdio>
#include <iostream>
char a[25][22];
int main() {
	int n, l;
	scanf ("%d%d", &n, &l);
	for (int i = 1; i <= l + 1; i++) {//本人把“o”这个地方放到最后面，即第l+1行了。
		getchar();
		for (int j = 1; j <= n * 2 - 1; j++) {
			a[i][j] = getchar();
		}
	}
	int ans = 0, d = 0;
	for (int i = 1; i <= n * 2 - 1; i++) {
		if (a[l + 1][i] == 'o') {
			ans = i / 2 + 1;//容易看出，第i列是在i/2+1这个竖线的（即中间有i-1个空格或横线）
			d = i;
			break;
		}
	}
	for (int i = l; i >= 1; i--) {
		if (a[i][d - 1] == '-') {//横线在左边
			ans--;
			d -= 2;
		} else if (a[i][d + 1] == '-') {//横线在右边
			ans++;
			d += 2;
		}
	}
	printf ("%d\n", ans);
} 
```