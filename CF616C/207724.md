[题目链接](https://www.luogu.com.cn/problem/CF616C)
### 题意解释：
给定一张n\*m的图，其中 '.' 代表空地，'\*' 代表墙，求把当前位置的墙改为空地，包含当前块的连通块有多少个（包含当前块的周围联通的空地共有多少个），注意如果当前位置是 '.' 就直接输出 '.' 。
### 思路 & 方法：
一个个遍历 '\*' 肯定会超时，于是我们便不从 '\*' 入手，转而从 '.' 入手，先用dfs计算连通块有多少部分，并把每一部分标上号，计算其连通块的个数，储存在ans数组里。然后遍历每一个 '\*' ，看它的四周（上下左右）的标记的那一部分连通块的个数，然后把它们累加（注意是同一部分的只要加一次），最后加上本身的1就是答案。
### 举个例子：如下图：
红色块为当前遍历到的墙，空地连通块共被分为三部分：  
①：1块；  
②：5块；  
③：5块；  
（1）当前块的上方是②号连通块，答案加上5；  
（2）当前块的左方和下方都是三号连通块，只加一次，答案加上5；  
（3）当前块的右方是墙，答案加上0；  
（4）最后加上本身的1；  
所以红色块的答案为5+5+1=11。  
![](https://cdn.luogu.com.cn/upload/image_hosting/pjsm6096.png)
#### PS：具体细节见代码注释。
------------
### Code:
```
#include <iostream>
#include <cstdio>
#include <cstring>
#include <string>
using namespace std;
int n, m, cnt, res, sum, x, y, i, j, k, f[4], ans[5100000], vis[1100][1100], lx[4] = {-1, 0, 1, 0}, ly[4] = {0, 1, 0, -1};
//vis数组存储连通块的部分的编号，ans数组存储每一部分连通块的个数
char s[1100][1100];
void dfs(int x, int y) { //本次dfs遍历到的所有符合条件的块在vis中均为同一个编号
	int nx, ny, i;
	vis[x][y] = cnt; //把当前块标上号
	res++; //累加器加1
	for (i = 0; i < 4; i++) {
		nx = x + lx[i];
		ny = y + ly[i]; //向四周移动
		if (nx > 0 && nx <= n && ny > 0 && ny <= m && s[nx][ny] == '.' && !vis[nx][ny]) //判断是否不越界，是空地且没有访问过
			dfs(nx, ny); //dfs递归回溯
	}
}
int main() {
	ios::sync_with_stdio(false);
	cin.tie(0); cout.tie(0); //加速命令
	cin >> n >> m;
	for (i = 1; i <= n; i++)
        for (j = 1; j <= m; j++)
            cin >> s[i][j]; //输入
	for (i = 1; i <= n; i++) {
		for (j = 1; j <= m; j++) {
			if (s[i][j] == '.' && !vis[i][j]) { //如果当前块是 '.' ，并且还没有被访问过，说明找到了一个新的连通块部分
				res = 0; //res存储当前部分连通块个数
				cnt++; //cnt表示这一部分连通块的编号
				dfs(i, j); //dfs搜索，把与当前块联通的 '.' 全部标记
				ans[cnt] = res; //第cnt部分连通块的个数是res
			}
		}
	}
	for (i = 1; i <= n; i++) {
		for (j = 1; j <= m; j++) { //遍历每一个格子
			f[0] = f[1] = f[2] = f[3] = 0; //f[0..3]分别用来存储四周连通块的编号，防止重复计算同一个编号的连通块
			sum = 0; //当前块的答案
			if (s[i][j] == '*') { //如果当前块是墙才计算
				for (k = 0; k < 4; k++) { //遍历当前块的四个方向
					x = i + lx[k];
					y = j + ly[k];
					if (s[x][y] == '#') continue; //如果得到的这个格子是墙的话就无需计算
					if (vis[x][y] == f[0] || vis[x][y] == f[1] || vis[x][y] == f[2] || vis[x][y] == f[3]) continue; //如果得到的这个连通块的编号之前已经出现过，就无需计算
					f[k] = vis[x][y]; //标记编号
					sum += ans[vis[x][y]]; //答案加上这个连通块编号的连通块个数
				}
				cout << (sum + 1) % 10; //模10输出（要记得加上本身）
			}
			else cout << '.'; //如果是空地就直接输出 '.'
		}
		cout << '\n'; //记得输出完一行要换行
	}
	return 0;
}
```
### 结束~Over~