### 一丢丢题外话
当我看到这道题时，我就认为我自己不太会做，然后去看题解——  
mmp这一大串algorithm是什么鬼！！  
然后就来写题解了。  
## 正题
首先我们靠人脑求全排列的时候，是怎么求的呢？  
比如1234，让我们看看思考过程：  
```cpp
第一位为1：
	1234
    1243
    1324
    1342
    1423
    1432
第一位为2：
	……
……
```
  以此类推。  
  我们可以看见，当我们分别枚举每一位时，都是从小到大，然后枚举后面的位数。因此，如果我们枚举前k位是xxxxxx（任意k个在1~n内的不同的数），那么第一个排列，它的第k+1位~第n位必定是从小到大排列的。  
  那么是否可以认为，当我们获得一个（不是第一个排列的）排列，它的前几位肯定会和与前面一个排列一样，如果没有，那么它就是第一位为x的第一个排列。
那么在这个排列前面，就必定有一个第一位比x小的最大排列（比如1324和1243）。
  所以，我们只需要从最后一位开始枚举一下，看哪一位比前面一位小，得到k，然后寻找第k到第n位的前一个排列（如果找不到比前面小的，就是第一个排列，输出ERROR）。  
  那么我们怎么求第k~第n位（不是k~n，是a[k]到a[n]）的上一个排列呢？  
  很明显，要求的排列的第一位一定比a[k]小，那么最大的排列的的第一位就是a[k+1]到a[n]中比a[k]小的最大的数。同时，它是以这个比a[k]小的数为第k位的最大排列，也就是a[k+1]到a[n]都比前一位小的排列。要解决这一点，只需要一个排序。
  接下来看代码：
```cpp
#include<algorithm>  //头文件 
#include<iostream>
using namespace std;
int n,a[10];  //数组 
bool cmp(const int & a,const int & b){ //从大到小排序要用的函数 
	return a>b;
}
void q(int x){  //求a[x]到a[n]的前一个排列，然后直接赋值 
	int maxn=0,maxp;
	for(int i=x+1;i<=n;i++){
		if(a[i]<a[x]&&a[i]>maxn){
			maxn=a[i];  //寻找a[x]到a[n]中比a[x]小的最大的数 
			maxp=i;  //记录它的位置 
		}
	}
	swap(a[x],a[maxp]);  //把a[x]和比x小的最大值交换位置，方便排序
	/*
	这里的意思是：
	上一个排列的第x位比a[x]小，所以是a[maxp]，
	那么上一个排列的a[x+1]到a[n]就是去掉a[maxp]之后a[x]到a[n]的最大排列。 
	*/
	sort(a+x+1,a+n+1,cmp);
}
int main(){
	cin>>n;  //输入不解释 
	for(int i=1;i<=n;i++){
		cin>>a[i];
	}
	for(int i=n;i>=2;i--){
		if(a[i]<a[i-1]){  //找到了x，也就是之前说的k 
			q(i-1);  //注意这里是包括了第i-1位 
			for(int j=1;j<=n;j++){  //直接输出然后结束程序 
				cout<<a[j]<<" ";
			}
			return 0;
		}
	}
	cout<<"ERROR";  //如果没有跳出，那就是第一个排列，输出ERROR 
}
```