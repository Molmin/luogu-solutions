先致敬万谔之源：

> 我们充分发扬人类智慧：  
> 将所有点全部绕原点旋转同一个角度，然后按 $x$ 坐标排序  
> 根据数学直觉，在随机旋转后，答案中的两个点在数组中肯定不会离得太远  
> 所以我们只取每个点向后的 $5$ 个点来计算答案  
这样速度快得飞起，在 $n=1000000$ 时都可以在 1s 内卡过

~~当然，这是错的~~

我们充分发扬 Hack 智慧：

将这篇题解看上几遍，然后按照题解说的在脑子里模拟。

根据数学直觉，在经过他的操作后，数据中 $x$ 坐标很近的点有可能离得很远。

所以我们不能只单独拿一个坐标做关键字。

这样速度快得飞起，在 $n=10000$ 时都可以在 10ms 内 WA 掉。

考虑到尽可能要让排序很均匀，我们充分发扬初中数学智慧：

在讲方差这一课时，也许老师问过大家如何判断数据的离散程度。

显然我们不能将两个坐标相减开方，或者将他们的绝对值相加。

根据数学直觉，由于原点不参与运算，把方差的计算公式展开后删去横纵坐标的平方，留下了两坐标乘积的二倍。

所以我们只取两坐标的乘积作为排序关键字。

这样大部分测试点不会被卡，在 $n \leq 4 \times 10^5$ 时都可以拿 $140pts$ 以上。

~~我充分发扬题解智慧，在智慧解法里看到我竟然蒙对了排序关键字~~

有的数据还是过不去。这是因为，可能会有在坐标轴上的点，他的乘积为 $0$。

我们充分发扬人类智慧：	

将所有的坐标加上一个玄学数字，然后把新坐标乘起来再排序。	

根据数学直觉，在玄学相乘后，答案中的两个点在数组中几乎不会离得太远

所以我们只取每个点向后的在时间允许范围之内的玄学个点来计算答案	 

这样速度快得飞起，在 $n=4 \times 10^5$ 时都可以在 160ms 内卡过	

乱搞代码：

```cpp
#include <cstdio>
#include <iostream>
#include <algorithm>
#include <cmath>
using namespace std;
const int maxn = 4e5 + 1;
long long ans = 4611686018427387904ll;
int n; 
struct node{
	long long x, y;
	bool operator<(const node&t)const{
		return (x + 3333) * (y + 3333) > (t.x + 3333) * (t.y + 3333);
	}
}a[maxn];
int main(){
	scanf("%d", &n);
	for (int i = 1; i <= n; i++){
		scanf("%lld%lld", &a[i].x, &a[i].y);
	}
	sort(a + 1, a + 1 + n);
	for (int i = 1; i <= n; i++){
		for (int j = i + 1; j <= min(i + 233, n); j++){
			ans = min(ans, (a[i].x - a[j].x) * (a[i].x - a[j].x) + (a[i].y - a[j].y) * (a[i].y - a[j].y));
		}
	}
	for (int i = 1; i <= 50; i++){
	    for (int j = n; j >= max(i + 1, n - 50); j--){
	        ans = min(ans, (a[i].x - a[j].x) * (a[i].x - a[j].x) + (a[i].y - a[j].y) * (a[i].y - a[j].y));
	    }
	}
	printf("%lld", ans);
	return 0;
}
```

> 数据永远无法打败智慧！！！
