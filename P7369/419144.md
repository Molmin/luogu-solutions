## 题意

一开始一个魔杖在一个巫师手中，接下来 $N$ 轮战斗，每轮下来如果拿着魔杖的巫师被打败，就把魔杖传给下一个巫师。

求：

$1.$ 最后拿着魔杖的巫师。

$2.$ 拿过魔杖的巫师的个数。

## 分析

对于第一个问题：我们可以把被老魔杖效忠的巫师抽象成一个**变量**，一开始先赋值成老魔杖的原主人，接下来每轮如果被老魔杖效忠的巫师被打败，就把胜利的巫师**覆盖**在原来的上面，最后变量的值就是最后效忠的巫师。

对于第二个问题：我们建立一个 ``bool`` 型的 $b$ 数组，表示某个巫师是否被效忠过，因为表示巫师的都是**大写字母**，所以只要 ``bool b[26]`` 就行了，若某个巫师的大写字母用 $c$ 来表示，则他对应的下标为 $c-'A\ '$。我们在解决第一个问题的同时，可以不断把每个覆盖的巫师对应的 $b_{c-'A\ '}$ 赋值为 $ture$，最后**统计**一下就行了。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,sum;
char c,winner,loser;
bool b[26];
int main()
{
    cin>>c;
	cin>>n;
    b[c-'A']=1;//第一次效忠的主人也要算上 
    for(int i=1;i<=n;i++)
    {
    	cin>>winner>>loser;
    	if(c==loser)//如果目前效忠的主人失败了 
    	{
    		c=winner;//改变当前的主人 
    		b[c-'A']=1;//效忠新主人 
		}
	}
	for(int i=0;i<26;i++)
	if(b[i])sum++;//如果这个主人效忠过就加1 
	cout<<c<<endl;
	cout<<sum<<endl;
	return 0;
}
```
