题面就不重复了。

我们发现，当一个图是沙漠的时候，那么它的子图一定是一个沙漠。

这使得我们可以使用双指针解决这个问题。

我们考虑对每一个 $l$ ，求出一个最大的 $r$ ，使得当只保留 $[l,r]$ 中的边时，图是一个沙漠。

我们需要一个数据结构去维护这个沙漠。

这个数据结构需要支持： 1. 插入/删除一条边 2. 判断一条边插入后图是否为沙漠。

显然可以想到用 LCT 去维护。

用 LCT 去维护沙漠中每一个仙人掌的生成树构成的森林。

#### （尝试并）插入边

当我们插入一条边 $(x,y)$ 的时候，如果 $x$ 和 $y$ 已经联通了，那么会产生一个环。

由于是沙漠，这就要求环上不能有边已经存在环中。

由于 LCT 只能维护节点的信息，我们把边看作点。为了和原先的点加以区分，我们把这样的节点类型记作 1 。

这样我们就可以通过查询 $x$ 到 $y$ 的链上是否有被打上标记的 1 类型的节点来判断是否可以连结 $(x,y)$ 这条边了。

如果 $(x,y)$ 能连结，那么我们把 $x$ 到 $y$ 的链上打一个值为 $(x,y)$ 边的编号的标记。

如果 $x$ 和 $y$ 没有联通，那么直接 link 就可以了，不需要打标记。

#### 删除边

如果这条边 $(x,y)$ 在沙漠中，但是不在 LCT 上，那么说明它是非树边，把 $x$ 到 $y$ 的链上的标记清空。

如果 $(x,y)$ 在 LCT 上，并且这条边不存在任何一个环内（即标记是空的），直接断开，不会有任何影响。

否则 $(x,y)$ 存在在一个环上。

我们将 $(x,y)$ 的标记所对应的非树边记作 $(u,v)$ 。

由于我们要删除边 $(x,y)$ ，那么 $(u,v)$ 就会成为树边。

所以先将链 $(u,v)$ 的标记清空，再断开 $(x,y)$ ，连结 $(u,v)$ 。

## 关于代码实现

这里给出一种相对好写的一种实现。

我们用 `val[]` 记录当前节点的值。

若为 -1 那么是原先的节点，否则若 >=0 则是由边变成的，同时具有非树边的编号的意义。

`tg[]` 的意义就是标记。

`mx[]` 表示的是当前节点在它的 splay 的子树中 `val[]` 的最大值。

这样当你把 $x$ 到 $y$ 的链分离成一棵 splay 的时候，你就可以直接通过 splay 根的 `mx[]` 值去判断是否有标记和标记对应的边是哪条。

当你下传标记的时候，如果 `val[]` 的值为 -1 ，我们就不需要改变 `val[]` 的值，否则直接把 `val[]` 改成标记的值。

然后...就没有然后了。

[**code**](https://codeforces.com/problemset/submission/1599/139636652)