别的题解都是套公式生成“完美数”的，这里介绍一种递推构造“完美数”的做法。

首先，根据题目描述，“完美数”是指在 $\bold{2}$ **进制**下由连续 $k+1$ 个 $1$ 和连续 $k$ 个 $0$ 组成的数。设 $a_i$ 表示第 $i$ 个完美数，那我们想想，$a_i$ 和 $a_{i+1}$ 之间有什么关系呢？

随便选 $2$ 个完美数，就 $a_4=120$ 和$a_5=496$ 吧。我们把它们的二进制形式写出来：

$$
\begin{cases}
1111000 &(120)\cr
111110000 &(496)\cr
\end{cases}
$$

不难发现，$a_{i+1}$ 的位数比 $a_i$ 的多 $2$ 位。那我们把刚才的 $1111000$ 左移 $2$ 位试试：（左移`<<`，就是在一个数的末尾添上 $n$ 个 $0$）

$$
\begin{cases}
111100000 &(120 << 2)\cr
111110000 &(496)\cr
\end{cases}
$$

这两个数已经很接近了，唯一的区别就是**从右往左数**第 $5$个数字不同。将 $n$ 的第 $k$ 位改为 $1$ 可以使用位运算“或”（或`|`，逐位进行类似逻辑或的运算），即 $n|(1<<(k-1))$，为什么这样写呢？设 $n=20,k=2$，列竖式验证一下。

$$
\begin{aligned}
&20_{10}=10100_2\cr
&1_{10}<<(2_{10}-1_{10})=1_2<<1_{10}=10_2\cr
\end{aligned}
$$
$$
\begin{aligned}
10100&\cr
|\quad 10&\cr
----&\cr
10110&\cr
\end{aligned}
$$
（如果不理解，可以根据算式理解一下）

所以，我们得出以下结论：

$$
a_i=\begin{cases}
1&i=1\cr
a_{i-1}<<2|(1<<(i-1))&i>1\cr
\end{cases}
$$

有了这个结论，我们就可以递推构造“完美数”了，其实不开数组记录也可以。程序如下：
```cpp
#include <cstdio>
using namespace std;
int n,ans;
int main(){
    scanf("%d",&n);
    for(int i=1,j=1;i<=n;j++){
    //i为递推的“完美数”，j为这是第几个“完美数”。
        if(n%i==0&&i>ans) ans=i;
        //由于是递推，只能从小到大，所以需要存最大的答案。
        i=(i<<2)|(1<<j);
        //结论的C++版本，前面一对括号是为了改变优先级，防止出错。
        //之所以j不用-1，是因为例如算a_2时j为1，不需要额外-1。
    }
    printf("%d",ans);
    return 0;
}
```
本题解若有不足之处，请多多指教。