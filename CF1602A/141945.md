### 题目大意
给定字符串 $S$ ，你需要将其拆解成两个**子串** $a,b$，满足对于 $S$ 中的任意一位上字符，只出现在 $a,b$ 中的**恰好**一个。

对于字符串 $a$，要求其字典序在**所有可能**的 $a$ 中最小；对 $b$ 无任何额外要求。输出任意的可行解。

保证 $1 \leqslant t \leqslant 1000 $，$ 2 \leqslant |S| \leqslant 100 $， $S$ 仅由小写字母组成。

---
### 解析
题目要求 $a$ 的字典序最小，那么什么是字典序呢？

---
先按照第一个字母、以 $\texttt{a,b,c...z}$ 的顺序排列；如果第一个字母一样，那么比较第二个、第三个乃至后面的字母。如果比到最后两个单词不一样长（比如，sigh 和 sight，那么把短者排在前。

---
引自百度百科。

**言归正传**，显然对于一个字符串，若要让它的字典序最小，需要从**顺序**和**长度**两方面考虑。

- 对于顺序，先不考虑长度，显然当 $a_0 = \texttt{a}$ 时，a的字典序在顺序上时最小的，如果 $S$ 中不存在字符 $\texttt{a}$，显然 $a$ 字典序最小的情况是 $a_0 = c$，$c$ 为 $S$ 中字典序最小的字符时 。

- 考虑长度，当 $a$ 的组成字符确定时，因为字典序的规则：”**短者在前**“， $a$ 的长度越短，$a$ 的字典序就越小。所以显然 $a$ 的长度应当为 $1$。

结合起来来看，我们应当使 $a$ 的长度为 $1$，同时那个唯一的字符应当是 $S$ 中字典序最小的字符。

这样，我们的思路就明确了，对于字符串 $S$，我们先找到它字典序最小的字符，将其作为 $a$ 本身，然后把剩下的所有字符当作 $b$，输出。

---
#### 代码：
```cpp
#include <iostream>
#include <string>
using namespace std;
int n, t;
string s;
int main()
{
    cin >> t;
    while (t--)
    {
        cin >> s;
        n = s.size();       //s的长度，注意string的下标从0开始，所以要从0循环到n-1
        char c = 'z' + 1;   //先设置字符c为极大值，注意字符可以直接按字典序比较
        int num = 0;        //c的下标
        for (int i = 0; i < n; i++)
        {
            if(s[i] < c)    //如果当前字符比c更小，则将c更新为新的最小值
                c = s[i], num = i;  //同时更新c的下标
        }
        putchar(c);     //输出字符串a
        putchar(' ');
        for (int i = 0; i < n;i++)
        {
            if(num == i)    //跳过字符c
                continue;
            putchar(s[i]);  //一个一个输出字符串b
        }
        putchar('\n');  //换行
    }
    return 0;
}
```
