题目链接：https://www.luogu.com.cn/problem/P2080

这道题目的数据非常强大！是一道dfs的经典题目。

乍一看，这道题似乎和一个普通的全排列有点相似：全排列（https://www.luogu.com.cn/problem/P1706） 要求枚举出1~n个数的所有排列可能，而这道题就是要让两个数组：a（小明对小红的好感）和b（小红对小明的好感）进行全排列，但是很明显这样一定会超时！看看数据范围！冗杂的计算会大大拖慢程序的速度！

我们慢慢来说。


------------
**一、初步的dfs**

初步建立一个状态：如果小明的所有事情都做完了，那么搜索也就要开始从栈顶部回溯了，即return。如果还没有做完所有的事情，那么就继续搜索。定义一个for循环，循环变量从i到n，对a和b数组进行全排列，初步的dfs函数如下：

```cpp
void dfs(int step)
{
	if(step>n)  ///小明的事情做完了 
		return; ///返回 
	if(m+h>v)
		together=true;  ///在一起了，在main里只用判断together的真假性就可以了  
	minn=min(abs(m-h),minn); 
	else
	{
		for(int i=0;i<n;i++)
		{
			if(visited==0)  ///visited[i]表示第i件事情有没有被做 ，1表示做了，0表示没做 
			{
				visited[i]=1;  ///标记为已做 
				m+=a[i];
				h+=b[i];  ///小明(m)和小红(h)双方的亲密值增加 
				dfs(step+1);  ///继续就当前状态搜索 
				visited[i]=0;  ///回溯 dfs的经典步骤 可以在全排列中见到 
				m-=a[i];
				h-=b[i]; 
			} 
		}
	} 
}
```


很明显这样的算法消耗时间很长，会TLE很多，这时候需要进行剪枝。

**二、剪枝**

剪枝分为可行性剪枝和最优性剪枝，其目的都是为了减少不必要的搜索，我们一个一个来讲。

**1、可行性剪枝**

可行性剪枝是一种常见的剪枝方法，他的主要目的是为了减去不可行的方法，从而达到节省时间的目的。比如：你有10块钱吃早餐，早餐有很多种，每一种早餐有不同的价格，假设你需要吃3份早餐，那么需要对所有的早餐情况进行搜索，如果还只吃了一份早餐钱就不够了，那么就剪枝，即退出此次搜索，这样由一个父节点延伸出来的搜索方案都将会被剪掉，因为这种方案不可行。

**2、最优性剪枝**

最优性剪枝在很多程序的某些地方~~神出鬼没~~，嗯，我是指出现的非常隐蔽，以至于你识别不出这是一种剪枝。这种剪枝的主要目的是减去不优的方案，比如：你仍然有10块钱吃早餐，早餐的情况和上面的一样，但是假设你可以吃∞份早餐，要在不超过总钱数的情况下吃更多的早餐，如果此时已经找出一种最好的方案，在另外一个父节点延伸出来的搜索树上发现用相同的钱数买的早餐数量更少，那么这整个树都不需要搜索了，因为这棵树没有比最有解更优。

那么我们如何进行剪枝呢？

**方案一**

仔细观察程序不难发现：我们的for循环的循环变量i每次都是从0重新开始排列的，然而在step以前的位置已经计算过了，没有必要再算第二次，并且这些地方已经在visited里面标为了true，不能再排列了。

我们可以把循环变量i的初值定位step，让i直接从step开始接着上一次的继续进行搜索，是可行性剪枝。

```cpp
else
{
	for(int i=step;i<n;i++) //让 i 从step开始是可行性剪枝 
	{///因为step以前的事做了之后的结果已经算出来了，不会可能会can==0  
		if(can[i]==0)  ///这件事还没有被做 
		{
			can[i]=1;  ///将第can[i]件事变为 true 表示这件事已经做了  
			m+=a[i];
			h+=b[i]; ///将双方的亲密值进行增长  	
			dfs(step+1); ///进行下一步搜索 
			m-=a[i];
			h-=b[i];  
			can[i]=0;  ///回溯 dfs的经典步骤
		} 
	}
} 
```
但是效果很明显，这个剪枝的力度并不是很强！

**方案二**

在方案一的基础上我们来考虑一下能否进行最优性剪枝。不难看出：只有在大于v的时候才有可能出现最优解，所以可以考虑把计算minn值放到if(m+h>v)的里面。

与此同时，我们还可以考虑去掉together。因为在程序的开头定义的minn值是比较大的，如果两人的亲密值没有超过v，minn的值是不会发生改变的，所以可以去掉together这个值。

**方案三**

方案二其实是在为方案三做铺垫，minn的值在进行最优的计算，那么这个最优值最大是多少呢？是0，即当minn值为0时进行return或直接输出，节省时间。此时minn==0就是一种新的结束状态，可以把一开始的step>n的判断去掉了。修改的代码见终结程序。



------------
终结程序：

```cpp
#include<iostream>
#include<cmath>
using namespace std;
int n,v,a[30],b[30],minn=100000,m,h; ///minn一开始要设定一个很大的值，不然就会产生永久的cout<<"-1"<<endl; 导致程序结果错误 
bool visited[30];//判断是否做过这件事
void dfs(int step)
{
	if(m+h>v) ///当亲密值到达v的时候，就到了一起 
		minn=min(abs(m-h),minn); ///计算差值 这个差值计算得有个限制，把计算放在这个if里面是最优性剪枝 
	if(minn==0) ///如果已经好到了极点，那么绝对值只差应该为 0，这个就是最终的状态
		return;
        for(int i=step;i<n;i++)
	{
    	        if(visited[i]==0)
		{
    		      visited[i]=1;
    		      m+=a[i];
    		      h+=b[i];
    		      dfs(i+1);
		         visited[i]=0;
    		      m-=a[i];
    		      h-=b[i];	
		}
	}
}
int main()
{
	cin>>n>>v;
	for(int i=0;i<n;i++)
		cin>>a[i]>>b[i];
	dfs(0);
	if(minn==100000)
	{///亲密值未发生改变 没有在一起   
		cout<<"-1";
		return 0;
	}
	cout<<minn;
	return 0;
}
```



------------
**结语**

这种数据范围很小但是数据点却很刚强的题目告诉我们要养成随时剪枝的习惯，在考试的时候只有一次机会，样例只是题目的冰山一角，想要让程序抵得过任何数据的冲击，就要学会剪枝，运用剪枝！

祝好！