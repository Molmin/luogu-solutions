## 【荒芜的海洋】 C++题解
### 题意简述

- 可以至多雇佣 $a$ 个人，去寻找 $b$ 个宝藏。
- 宝藏分布在 $n$ 个岛，岛与岛之间共有 $m$ 座桥相连。
- 通过每个岛，需要一定代价 $x_i$ （对应到岛上的野兽数量）。
- 通过每座桥，需要一定代价 $w_i$ （对应到桥的长度）。
- 雇佣每个人，需要一定代价 $q_i$ （对应到雇佣的价格）。
- 每个人一开始都在特定的岛 $p_i$ 上，且只能带一个宝藏离开。
- 每个宝藏都在特定的岛 $q_i$ 上，都有特定的价值 $k_i$。
- 问，能否获取全部宝藏？能，则输出最终收益；不能，则输出获取的宝藏数。

最终收益是 $\sum\limits_{i=1}^{b} k_i$ 减去全部代价。

### 题意分析

这是一个费用流的题目，需要用到拆点、超级源汇。因为有点权，所以需要拆成两个点操作；因为起点、终点都有多个，所以需要将所有起点与超级源相接，所有终点与超级汇相接。因此，建图方式如下：

|对象|连接方式|容量|费用|
|:-:|:-|:-:|:-:|
|岛|拆成两点，连有向边|$\inf$|$x_i$|
|桥|连无向边|$\inf$|$w_i$|
|人|超级源指向 $p_i$|$1$|$q_i$|
|宝藏|$q_i$ 指向超级汇|$1$|$0$|

进行一遍费用流，得到流和费用，按要求输出即可。

### 代码

这里给出费用流的模板，[链接](https://www.luogu.com.cn/paste/4lg5ijl3)。

这份模板可以应对绝大多数费用流的题目，通常不需要修改。调用 `.link(a,b,c,d)` 建图，调用 `.MCMF(a,b)` 可以得到一个 `pair<int,int>` 类型的结果，分别是最大流和最小费用。

除了模板以外的代码如下：

```
graph G;
int main()
{
	int n,m,a,b,sum=0;
	scanf("%d%d%d%d",&n,&m,&a,&b);
	int S=n*2+1,T=n*2+2;	//超级源汇
	for(int i=1;i<=n;i++)	//岛
	{  
	    int x;
	    scanf("%d",&x);
	    G.link(i,i+n,2147483647,x);
	}
	for(int i=1;i<=m;i++)	//桥
	{
	    int u,v,w;
	    scanf("%d%d%d",&u,&v,&w);
	    G.link(u+n,v,2147483647,w);
        G.link(v+n,u,2147483647,w);
	}
	for(int i=1;i<=a;i++)	//人
	{
	    int q,p;
	    scanf("%d%d",&q,&p);
	    G.link(S,p,1,q);
	}
	for(int i=1;i<=b;i++)	//宝藏
	{
	    int k,q;
	    scanf("%d%d",&k,&q);
	    sum+=k;
	    G.link(q+n,T,1,0);
	}
	pair<int,int>ans=G.MCMF(S,T);
	if(ans.first<b)
	    printf("No\n%d",ans.first);
	else
	    printf("Yes\n%d",sum-ans.second);
	return 0;
}
```

