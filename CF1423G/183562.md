[更好的阅读体验](https://reclouds.github.io/post/%E3%80%90%E9%A2%98%E8%A7%A3%E3%80%91CF1423G%20Growing%20Flowers%20%E9%A2%98%E8%A7%A3.html)

### 题意

给定一个序列，每个位置存在一种颜色，要求支持下列两种操作：

1. 给定子段 $[l, r]$ 和颜色 $x$, 将该子段全部变为颜色 $x$；

2. 给定 $k$，求所有长度为 $k$ 的子段内不同颜色的数量的和。

### 题解

以下称一个颜色相同的连续极长子段为颜色段。

首先需要知道一个定理：如果我们能够 $\mathcal{O}(1)$ 地加入或删除一个颜色段，那么 $m$ 次 $1$ 操作的时间复杂度是 $\mathcal{O}(n + m)$ 的。

证明：

实际上是证明总共加入或删除的颜色段数量是 $\mathcal{O}(n + m)$ 的。

每一次 $1$ 操作，我们假设可以 $\mathcal{O}(1)$ 找出左端点和右端点分别所在的颜色段 $L$ 和 $R$，那么我们将会把 $L$ 到 $R$ 之间包括这两者的所有颜色段全部删除，然后加入颜色段 $[l, r]$，再补齐一开始删除多了的部分。

也就是说，每一次操作至多会增加 $3$ 个颜色段，而显然显然初始时的颜色段数是 $\mathcal{O}(n)$，所以总共存在过的颜色段数量 $\mathcal{O}(n + m)$ 的。

而每一个颜色段最多被删除一次，因此删除掉的颜色段数量也是 $\mathcal{O}(n + m)$ 的。

证毕。

也就是说，如果我们非常直接地维护颜色段，那么时间复杂度是可以接受的。

然而 $\mathcal{O}(1)$ 做到颜色段的插入和删除是很难的（至少笔者并没有想到方法），因此我们可以考虑用 ```set``` 维护。维护的时间复杂度是 $\mathcal{O}((n + m) \log_2 n)$ 的，并且这个 $\log$ 不会与其它部分（特指下文维护答案的部分）冲突。

------

那么现在的问题是：求出一个颜色段对答案的贡献。

乍一看，我们似乎要维护每个位置对每一种 $k$ 的贡献，时间复杂度似乎不太可以接受。

但实际上我们通过分析，可以发现贡献要么呈一段相等的数的形式，要么呈等差数列形式，并且我们仅需支持单点查询，所以我们把贡献差分一下，询问时求前缀和即可。

接下来就是具体分析的环节。

我们钦定在段中，每种颜色第一次出现的位置才会造成实质性的贡献。

那么对于第一个位置 $pos$，我们考虑计算它对 $k$ 的贡献：

在包含 $pos$ 的所有长度为 $k$ 的子段中，右端点最右会延伸到 $\min(n, pos + k - 1)$，因为极限情况就是左端点为 $pos$ 的情况，但是右端点又不能超过 $n$。

假设我们现在已经维护好了 $pos$ 的颜色在 $pos$ 之前的最后一次出现的位置 $pre$（没有则记为 $0$)，那么在包含 $pos$ 的所有长度为 $k$ 的子段中，右端点最左会延伸到 $\max(pos, pre + k)$，因为极限情况就是右端点为 $pos$ 的情况，但是左端点又必须在 $pre$ 右侧（否则 $pos$ 的颜色的实质性贡献不会由 $pos$ 提供）。

(注意 $pre$ 在上面维护颜色段时可以维护。)

综上，$pos$ 的贡献即为 $\min(n, pos + k - 1) - max(pos, pre + k) + 1$。注意 $k$ 的范围为 $[1, n - pos]$，否则 $pos$ 会有负贡献，这是不存在的。

把贡献拆开，可以发现 $\min$ 和 $\max$ 的部分由于 $k$ 递增，所以贡献是呈一段等差数列和一段相等数列的形式的，差分后可以很方便地用线段树维护。

那么我们还需要对颜色段中 $pos$ 以后的位置做同样的分析吗？当然不需要。

我们发现，颜色段中 $pos$ 以后的位置 $pos'$ 的贡献十分简单，因为包含它的子段的左端点必须在 $pos'$ 这个位置上，所以它对所有 $k \in [1, n - pos' + 1]$ 的贡献均为 $1$。

稍作分析，可以发现颜色段中 $pos$ 以后的位置对 $k \in [1, n - pos]$ 的总贡献为 $\min(n - pos - k + 1, len - 1)$（其中 $len$ 表示颜色段长度）。由于 $k$ 递增，因此这个部分的贡献仍然呈一段等差数列和一段相等数列的形式，可以继续差分后用线段树维护。

于是这题就做完了，不过写起来细节还挺多。