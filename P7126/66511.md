纪念一道完美踩中我所有数据结构知识盲区的 Ynoi 。

首先对于这种离线的、数个数的问题大概率是使得每一个类只会产生一次贡献，然后用扫描线解决。

考虑如何让一个 “C块” 只产生一次贡献。

我们有一个十分平凡的思路，就是给所有元素一个比较策略，然后每一个类只有最优的那一个产生贡献。

假如我们已经设计出了这个策略，那么我们就可以考虑对于一个元素，如果区间内存在比它更优的元素，那么它就不产生贡献，可以记录最左边比它更优和最右边比它更优的元素分别为 $L_i, R_i$ ，那么就转化成了扫描线的经典问题：“数一个区间 $\[l, r\]$ 内有多少个元素 $i$ 满足 $L_i < l$ 且 $R_i > r$ ” 。

这个有一个比较简单的解决办法就是把所有询问按右端点排序，然后在序列上维护一个指针从左往右扫。每次扫到一个 $i$ 说明这个 $i$ 可以产生贡献，但是这个贡献会被 $L_i$ 抵消，然后扫到 $R_i$ 时说明对应的 $i$ 再也无法产生贡献。这些显然可以转化为单点修改区间求和，用树状数组就可以解决。

那么接下来考虑如何设计这个比较策略。

首先一个思路是一个 “C块” 中只有最浅的那些点产生贡献，故我们设一个第一关键字为 $dep_i$ 即在原树上的深度，而且这样的一个好处就是如果对于某一个点，没有深度比它更小的与它 “C连通” 的点，那么它一定是当前 “C块” 中深度最小的。

但是这样不一定唯一，于是我们把每一个点的编号当作第二关键字，即我们可以设计一个如下的比较函数：

```cpp
inline bool cmp(int u, int v) {
  return dep[u] < dep[v] || (dep[u] == dep[v] && u < v);
}
```

考虑为什么不能直接把编号当作第一关键字，这是因为编号这个东西，可能有一个离当前的很远的点更优，但当前点周围的点都更劣，会导致统计多次。

而在只有最浅的一层产生贡献时，不难发现这些点互相 “C连通” ，故这些点中编号最小的点一定是唯一确定的。

最后考虑怎么统计这个东西。

由于我们讨论的是和 “距离为C” 有关的事情，那么我们大可以考虑采用点分治这一类的东西。

我们考虑点分，每一次首先对所有范围内的点排序，然后动态维护一棵平衡树，每一次在平衡树上查询合法的前驱后继即可。

复杂度 $O(n\log^2 n + m\log n)$ 。

另外据说这道题有什么 Top Tree 分治的单 $\log$ 做法，反正我不会。

代码不放了，这道题不卡常。