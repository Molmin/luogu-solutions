我们有个 naive 的想法，预处理出和每个节点编号最接近的距离在 $C$ 以内的两个（一个大于 $x$，一个小于 $x$）节点，然后莫队并查集，于是你写了，过样例了，交了，WA 了。

冷静思考一下可以发现这种做法是显然错误的，我们注意到我们 $2n$ 个信息中有重复的，有用的信息没有记录下来，为了获取尽可能多的信息，我们对于编号为 $x$ 的点，记录编号最接近的两个距离在 $C$ 以内且满足 $dep_i<dep_x\lor(dep_i=dep_x\land i<x)$ 的点，记为 $l_i,r_i$。

我们可以把询问从数连通块变为数 $l_i<l\land r_i>r$ 的点数量，为什么这么做是正确的？

因为 $dep_i<dep_x$，所以每个连通块只有深度最浅的一层点可以满足 $l_i<l\land r_i>r$ 的性质；因为 $dep_i=dep_x\land i$，同层点只有一个满足 $l_i<l\land r_i>r$ 的性质。

我们注意数据范围，猜想正解复杂度为 $O(n\log^2 n+m\log n)$。

首先，预处理出上面说的这个东西可以用点分治，对于每一个分治中心，我们把点按 $dep$ 排序插入平衡树内，平衡树节点维护到分治中心的 $dis$ 最小值，查询时直接平衡树上二分就可以了。

问题转化为每个点有两个属性 $l_i,r_i$，当 $l_i<l\land r_i>r$ 时，$i$ 对询问区间 $[l,r]$ 产生 $1$ 的贡献，直接把询问离线下来用树状数组维护答案就可以了，不会的可以去做 HH 的项链。

代码就不给了。