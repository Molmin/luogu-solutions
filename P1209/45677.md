### 做题的第一步当然是读题  
有些牛棚里是没有牛的  
木板是**没有长度限制**的，但是**有数量限制**。  
约翰这个小妖精偏偏想买**长度总和最短**的木板，把所有的牛都拦起来。

给出:   
可能买到的木板最大的数目**M**   
牛棚的总数**S**    
牛棚里牛的总数**C**  
和牛所在的牛棚的编号**stall_number**

###  思路
要用最短的木板，就是在M的限制下，留出最多的空牛棚。这样就可以机智的转化问题。把**最短的木板-->去掉最多的空牛棚**。  
不可以让任何一只牛牛吹风受冻，牛与前一只牛之间空的牛棚，就是可以去掉的空牛棚。  
从中找到M-1个空牛棚组合成的 **最多的空牛棚组合**，忽略他们，不栏他们，就可以解决问题了。

####  最短的木板=第一只牛到最后一只牛的距离-最多的空牛棚组合
第一只牛前的牛棚和最后一只牛以后的牛棚都不用拦起来啦。

### 实现
```
#include<iostream>
using namespace std;
int main()
{
    int c,m,s,N[1000],fb[1000];
    cin>>m>>s>>c;
    for(int i=1;i<=c;i++)
        cin>>N[i];
    for(int i=1;i<=c;i++)//牛的编号并没有按顺序给出，细心读题
     for(int j=i+1;j<=c;j++)
     	{
            if(N[j]<N[i]) 
            {
                int t=N[j];
                N[j]=N[i];
                N[i]=t;
            }
        }
    
    for(int i=2;i<=c;i++)
    {
        fb[i]=N[i]-N[i-1]-1;//求牛与上一只牛的空牛棚数	
    }
    for(int i=2;i<=c;i++)
     for(int j=i+1;j<=c;j++)
     	{
            if(fb[j]>fb[i]) 
            {
                int t=fb[j];
                fb[j]=fb[i];
                fb[i]=t;
            }
        }
    int x=0;//最多空牛棚组合
    for(int i=1;i<=m-1;i++)//m个木板把牛分成m个部分，m的部分有m-1个空
    {
        x=fb[i+1]+x;//因为之前按照降序排列，所以直接可以计算
    }

    int sum=N[c]-N[1]+1-x;
    cout<<sum<<endl;
}
```
