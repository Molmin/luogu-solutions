看到用#DP#的童鞋这么少，呵呵......

楼下的DP都是二维数组，可能和我的不太一样，我就没看了~

**初始形态**

用f(i,j)表示前i个牛棚用j块木板的最优解

显然f(i,j)=min{f(i-1,j)+a[i]-a[i-1],f(i-1,j-1)+1}

a(i)表示第i个牛棚的位置。

说明一下吧~

第一个式子表示在前i-1头牛已经用了j块木板，说明第i个牛棚只能和前一个牛棚连起来，作为一个木板使用，所以要加上距离；

第二个式子表示在前i-1头牛已经用了j-1块木板，说明第i个牛棚是单独的一块木板，最少就用长度为1的呗。

最后输出就是f[c][m]

**一级进化**

如果可以细心观察的话，你能发现每一次计算，更新值只和上一个阶段(i-1)有关。

所以这里可以用滚动数组来优化。只记录i与2的余数就可以了。

这样来说可以降低一点空间复杂度。//虽然来说空间复杂度不要钱，但是能省点尽量省省吧~~~

这时空间复杂度由原来的O(cm)降低到O(m)级别//常数暂且省略

******终极形态******

如果对01背包有深入了解的话，一定能发现，如果将第二层循环从大到小，这时的j-1和j都是上一个阶段的值，连滚动数组都不需要了~~



```cpp
#include<cstdio>
#include<algorithm>
using namespace std;
int f[52],a[202],n,k,m,i,j;
int main()
{
    scanf("%d%d%d",&m,&k,&n);
    if(m>=n)//我觉得可以先特判，木板数>=牛棚数，直接就输出牛棚数
    {
        printf("%d\n",n);
        return 0;
    }
    for(i=1;i<=n;i++)
        scanf("%d",&a[i]);
    sort(a+1,a+1+n);//**对牛棚位置进行排序**
    for(i=1;i<=n;i++)
    {
        for(j=m;j>=1;j--)//从大到小
            f[j]=min(f[j]+a[i]-a[i-1],f[j-1]+1);
        f[0]=1<<30;//注意！由于f[0]不参与计算，所以如果没有把它在每一个阶段后赋值为很大的数，结果必然是1
    }
    printf("%d\n",f[m]);//最后一定要输出f[m]，因为无论怎样，木板数越多，需要盖住的和就肯定会少。不能在f[1]~f[m]中取最小值
    return 0;
}
最后估算一下时间复杂度：两层循环O(cm)，比贪心的O(ClogC)略慢。但是说实话，DP比贪心更稳一点。
```