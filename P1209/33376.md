看了这道题，我发现牛棚的总数好像并没有什么用？！我们可以先假设所有的牛棚被一块木板盖住，那么此时木板长度就是有牛的牛棚中最大编号-最小编号+1（在下面写作F）。而题目中又说要用m个木板，所以说只需要从现在这块木板中“断开”m-1个地方，既可以满足题目要求。

然后可以用贪心算法，先算出每两个相邻的有牛的牛棚的编号差，然后把这些编号差从大到小进行排序（因为题目要求求最短木板总长度），接着用F减去排序后的前m-1个编号差减掉（就是使这两个牛棚之间假设的木板断开），剩下的F即为答案。

至于贪心的成立性，显然吧？你去“切”距离小的肯定不如去“切”距离大的。

代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
int m,s,c,a[201],b[201],f;//a用来存储牛所在牛棚的编号，b用来储存相邻牛棚的编号差。
int main()
{
    cin>>m>>s>>c;
    for(int i=1;i<=c;i++)
    cin>>a[i];//读入
    if(m>=c)//这里需要一个特判，如果说木板数比牛的数量还多，那肯定就是每个有牛的牛棚面前盖一个，直接输出牛数。
    {
        cout<<c;
        return 0;
    }
    sort(a+1,a+c+1);//把有牛的牛棚编号排序，不要被样例迷惑了，数据不一定按编号从小到大读。
    f=a[c]-a[1]+1;//先假设用一块木板，别忘了+1，如题。
    for(int i=1;i<=c-1;i++)
    b[i]=a[i+1]-a[i];//把每两个相邻的有牛的牛棚编号差求出来。（排了序，可以保证a[i]和a[i+1]是相邻的两个有牛的牛棚）
    sort(b+1,b+c);//排序
    for(int i=c-1;i>=c-m+1;i--)//把相邻编号差最大的m-1个减掉，即为最后的答案
    {
        f-=b[i];
        f++;//+1，如题
    }
    cout<<f;//输出
    return 0;
}
```