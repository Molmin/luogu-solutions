---
title: CF1495D BFS Trees
---

### 题目描述

定义一个图的生成树是以节点 ```s``` 为根的 ```BFS``` 树，当且仅当对任意节点 ```t```，图中 ```s``` 到 ```t``` 的最短路径长度等于树上 ```s``` 到 ```t``` 的最短路径长度。

对于一个图，定义 ```f(x, y)``` 为该图满足「同时是以节点 ```x``` 为根的 ```BFS``` 树和以节点 ```y``` 为根的 ```BFS``` 树」的生成树数量。

给出一个 ```n``` 个节点 ```m``` 条边的无向连通图，请对每对 ```i, j``` 计算 ```f(i, j)``` 对 ```998244353``` 取模的值。

### 题目解答

首先我们思考如果已经确定了这```s```树的，那么他有多少棵 ```BFS``` 生成树，我们考虑对这张图利用每一个点到 ```s``` 的距离进行分层，例如```dis(s,i)==3``` 那么我们就把 ```i``` 放在第三层，那我们假设 ```i``` 在第```k ```层，那么定义 ```c(i)``` 为 ```i``` 向第```k-1```层的点有多少条，直接相连的边。那么生成树的个树就是 $\prod_{i!=s}{c_i}$ 。

现在我们考虑什么时候点```x,y```可以有相同的生成树，首先这个生成树上的点可能会有两种，第一种是被夹在了```x,y```中也就是```dis(x,y)==dis(x,i)+dis(y,i)```，还有一种是这个点有一条连出去的边，使得这条边既可以成为```x```的```BFS```树中的边，又可以成为```y```的```BFS```树中的边。

我们现来考虑第一种点，如果第一类点和```x,y```连成的不是一条链，那么就会出现一些不好的情况，如下图，```1,3```是根，那么我们考虑```2```这个点，为了使```1,3```到```2```都是最短路，我们就必须同时连接 ```(3,2)(1,2)```这两条边，```4```也是同理，那么图中的边就不再是一棵树了。所以我们还得出了一条结论，就是第一种点都只有唯一的连接方式。

![](https://cdn.luogu.com.cn/upload/image_hosting/j8nymk43.png)

再来考虑第二种点，我们考虑分别以```x,y```进行分层那么只有可以同时出现在两棵```BFS```树的边才是合法的，那么再用相同的方式定义```c(i)```，答案就是  $\prod_{i!=x \land i!=y}{c_i}$。

这样我们就很顺畅的解决了这道题，代码还是很短的。QAQ

```cpp
int n, m, d[N][N];
vector <int> G[N];

modint Calc(int x, int y) {
	int cnt = 0;
	for (int i = 1; i <= n; i++)
		if (d[x][y] == d[x][i] + d[y][i])
			cnt++;
	if (cnt != d[x][y] + 1)
		return 0;
	modint Ans = 1;
	for (int i = 1; i <= n; i++) if (d[x][y] != d[x][i] + d[y][i]) {
		int c = 0;
		for (int j : G[i]) {
			if (d[x][i] != d[x][j] + 1) continue;
			if (d[y][i] != d[y][j] + 1) continue;
			c++;
		}
		Ans *= c;
	}
	return Ans;
}

int main() {
	Build_Mod(998244353), read(n), read(m), mset(d, 0x3f);
	for (int i = 1; i <= n; i++) d[i][i] = 0;
	for (int i = 1, a, b; i <= m; i++) {
		read(a), read(b);
		d[a][b] = d[b][a] = 1;
		G[a].pb(b), G[b].pb(a);
	}
	for (int k = 1; k <= n; k++) for (int i = 1; i <= n; i++)
		for (int j = 1; j <= n; j++) d[i][j] = min(d[i][j], d[i][k] + d[k][j]);
	for (int i = 1; i <= n; i++) for (int j = 1; j <= n; j++)
		print(Calc(i, j), " \n"[j == n]);
	return 0;
}
```

