## 入手

- 这道题数据范围 $ 1\le N ,M \le 50000 $，时间复杂度 $ O(nm) $ 但是时限 $2s$ 优化一下可过。


## 实现优化


* **自定义排序**（重点）

 1. 将每个公司的各种信息存在一个结构体变量中。（应该都会吧）

 1. 因为题目中要求每个人得到最大工资如果打暴力，需要遍历所有公司，所以把公司按照工资由大到小排序，即可在每个人遇到的第一个能接受自己的公司时便是最大工资，然后停止循环，即可剪枝。（即使是最坏情况也和暴力一样）
 
 2. 再对 $a$，$b$，$c$ 依次从小到大排序，即可在相同工资时，找到最容易公司就马上进行加入，减小循环次数。
 
 举个栗子：
 
1. 不排序时
 
 | 公司 | $a$ | $b$ | $c$ | 马内 |
| :----------: | :----------: | :----------: | :----------: | :----------: |
| $1$ | $2$ | $2$ | $2$ | $100$
| $2$ | $5$ | $4$ | $6$ | $100$
| $3$ | $11$ | $45$ | $14$ |$114514$
| $4$ | $0$ | $0$ | $0$ | $0$



 | 人 | $a$ | $b$ | $c$ | 要判断的次数 |公司
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| $1$ | $114514$ | $114514$ | $114514$ | $4$ |$3$
| $2$ | $3$ | $10$ | $5$ | $4$|$1$
| $3$ | $1$ | $1$ | $1$ | $4$|$4$
| $4$ | $0$ | $0$ | $0$ | $4$|$4$

总共判断次数：$16$

2. 排序时

 | 公司 | $a$ | $b$ | $c$ | 马内 |
| :----------: | :----------: | :----------: | :----------: | :----------: |
| $1$ | $11$ | $45$ | $14$ | $114514$
| $2$ | $2$ | $2$ | $2$ | $100$
| $3$ | $5$ | $4$ | $6$ |$100$
| $4$ | $0$ | $0$ | $0$ | $0$



 | 人 | $a$ | $b$ | $c$ | 要判断的次数 |公司
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| $1$ | $114514$ | $114514$ | $114514$ | $1$ |$1$
| $2$ | $3$ | $10$ | $5$ | $2$|$2$
| $3$ | $1$ | $1$ | $1$ | $4$|$4$
| $4$ | $0$ | $0$ | $0$ | $4$|$4$

总共判断次数：$11$

明显可以看出两个的区别。
 
```cpp
bool cmp(gongsi a,gongsi b){
	if(a.sum!=b.sum)
		return a.sum>b.sum;//先排工资。
	if(a.a!=b.a)
		return a.a<b.a;
	if(a.b!=b.b)
		return a.b<b.b;
	else
		return a.c<b.c;//再排标准低。
}
```

* 主函数内处理


上面说过，因为排序时是按照工资由高到低进行的，所以找到第一个满足条件的公司直接加入。

```cpp

int x,y,z;
bool f=1;
scanf("%d%d%d",&x,&y,&z);
for(int j=1;j<=n;j++){
    if(x>=ng[j].a&&y>=ng[j].b&&z>=ng[j].c){
    	 printf("%d\n",ng[j].sum);
    	 f=0;
    	 break;
    }
 }
 if(f) printf("0\n");
        
```
## 提醒

1. 不能用普通 ```cin``` 不然超时。

2. 还有一个公司都加入不进去的人记得特判。

## AcCode
```cpp
#include<bits/stdc++.h>
using namespace std;
struct gongsi{
	int a,b,c,sum;
}ng[50005];
bool cmp(gongsi a,gongsi b){
	if(a.sum!=b.sum)
		return a.sum>b.sum;
	if(a.a!=b.a)
		return a.a<b.a;
	if(a.b!=b.b)
		return a.b<b.b;
	else
		return a.c<b.c;
}
int main(){
    int n,m;
    cin>>n>>m;
    for(int i=1;i<=n;i++)
        scanf("%d%d%d%d",&ng[i].a,&ng[i].b,&ng[i].c,&ng[i].sum);
    sort(ng+1,ng+1+n,cmp);
    for(int i=1;i<=m;i++){
    	int x,y,z;
    	bool f=1;
    	scanf("%d%d%d",&x,&y,&z);
    	for(int j=1;j<=n;j++){
    		if(x>=ng[j].a&&y>=ng[j].b&&z>=ng[j].c){
    		    printf("%d\n",ng[j].sum);
    			f=0;
    			break;
    		}
    	}
    	if(f) printf("0\n");
    }
    return 0;
}
```



