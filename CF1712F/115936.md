非独立做出，自己大概就把前面的式子啥的搞了出来？然后后面关于长剖以及复杂度证明找 @LJC00118 问了十几分钟才搞明白。

先考虑对于两个点 $u$ 和 $v$，他们在新图上的距离可以表示成什么。

首先一个肯定就是原本树上的的距离，也就是 $dep_u+dep_v-2dep_{lca}$。

然后考虑走新加的路线。因为叶子结点两两都有连边，所以边权为 $x$ 的边只会走一次，不然一定不优。那么相当于从 $u$ 走到一个叶子结点，然后走一条 $x$ 的边到另一个叶子结点，再沿着树边走到 $v$。因此我们可以预处理一个 $g_u$ 表示 $u$ 和它最近的叶子结点的距离是多少。那么这一条路径就是 $g_u+g_v+x$。

值得注意的是 $g_u$ 对应的叶子结点不一定在 $u$ 的子树内，避免低级错误。

然后整个式子就是 $ans=\max\{\min(dep_u+dep_v-2dep_{lca},g_u+g_v+x)\}$。

发现 $q$ 非常小，所以我们大胆猜测每次询问的复杂度是 $O(n)$ 或 $O(n\log n)$ 的。

显然加入新边后，直径只小不大，所以有 $ans\le n$。这启发我们去考虑答案增长的过程。

因为每次询问我们都有看上去比较充裕的复杂度，所以我们可以直接在树上 DFS 一遍，然后去做树形 dp。

在同一子树内，对于 $g_u$ 相同的两个点，显然我们只需要 $dep_u$ 较大的一个点。这对我们状态的设计有所启发。设 $f_{u,i}$ 表示 $u$ 的子树内，对于 $g_v=i$ 的所有 $v$，$dep_v$ 的最大值。

然后，对于任意的 $i$ 都一定满足 $f_{u,i}>f_{u,i+1}$。这个是因为 $f_{u,i}$ 至少可以选 $f_{u,i+1}$ 对应的点的儿子。这个可以扩展到 $i<j$，有 $f_{u,i}>f_{u,j}$，也就是说 $f_u$ 是单调下降的。

我们考虑把 $f_{v,i}$ 逐个插入 $f_u$ 内，同时我们来考虑 $f_{v,i}$ 对答案增长的影响。

相当于我们要判断对于 $f_{v,i}$ 对应的点以及 $f_u$ 里的某个点，是否它们的距离能 $>ans$，如果能，那么就 $ans+1$。

考虑对于一个 $f_{v,i}$ 如何判断它的距离 $>ans$。首先要求 $g_u+g_v+x>ans$，那么 $g_v\ge ans-x-g_u+1$。也就是说，我们只需要判断 $\max_{j\ge ans-x-g_u+1}\{f_{u,j}+f_{v,i}\}>ans$ 即可。又因为 $f_u$ 单调下降，所以实际上我们只需要考虑 $j=\max(0,ans-x-g_u+1)$。

最后记得还要把 $u$ 自己合并到 $f_u$ 里面。

这个复杂度似乎不太对，考虑怎么优化？

采用树链剖分的思想，这里采用长链剖分。

具体地，每个点 $u$，先搜它的长儿子，然后直接将长儿子的 $f_{son}$ 整个弄到 $f_u$。然后其他儿子的 $f_v$ 暴力合并到 $f_u$ 即可。

实现上，我们可以对每个 $f_u$ 开一个 vector，然后用 algorithm 库的 swap 函数，因为 swap 两个 STL 容器是 $O(1)$ 的，所以我们可以直接 $swap(f_u,f_{son})$。

考虑这个复杂度怎么证明。

首先 $ans\le n$，且每次判断 $ans$ 增长的式子都是 $O(1)$ 的，所以这部分的复杂度是 $O(n)$ 的。

问题在于合并的复杂度，容易分现复杂度是每个轻子树里所有点相对于子树的根的最深深度的和。实际上每个点只会在它第一个轻子树的祖先被合并一次。因为再往上的轻子树，它这个深度可以算到第一个祖先的长儿子的子树内相同深度的某个点。

所以每个点实质上只会被算一次，总的复杂度 $O(n)$。

综上总的复杂度为 $O(nq)$，但是我跑得非常慢，跑了 3.6s，大概这就是人傻常数大吧。

https://codeforces.com/contest/1712/submission/181306731