# [题目の传送](https://www.luogu.com.cn/problem/P7411)

# 题目大意

大概就是说，如果 一头牛 在 **上下左右** 四个方向中，**恰好**在三个方向有牛和它相邻，就称它为 “舒适的”。此时就需要在它唯一一个 没有相邻牛的方向上添加一头牛，使它 “不舒适”。

# 解析

## 开始之前

为了方便描述，我们称在输入中的牛为 “**主动添加**” 的牛，称为了打破其他牛的 “舒适” 而添加的牛为 “**被动添加**” 的牛

## 算法选用

如题，当需要被动添加一头牛的时候，这头牛也可能使自己以及自己四个方向的牛变得 “舒适”，然后又需要被动添加更多的牛使他们都 “不舒适”

于是，明显的，这道题要么用  _BFS_  要么用  _DFS_ 

>输出 $N$ 行，对于 $1 \ldots N$ 中的每个 $i$，输出一行，为 Farmer Nhoj 需要加入的奶牛数量。

同时，根据题目描述，需要动态地加牛，处理答案

## 一个性质

一头牛被被动添加后，不会因为之后添加了更多的牛而又变得不需要添加

**原因**：很明显,每一头被被动添加的牛都是基于 **在它之前**就 **已主动添加** 或 **已被动添加** 的牛的基础之上的，于是它们也做不到 “破坏” 它们的基础，因为如果没有它们的基础，它们就不可能存在。
    
基于这个性质，我们便无需在每次处理答案地时候都再次全局地遍历需要被动添加的牛。

我们只需在每次被动添加牛的时候给它打一个特殊标记，并使  _**被动添加牛数**_  加一。若某次输入操作（即主动添加牛）使一头牛从**被动**转为**主动**，则使 _**被动添加牛数**_ 减一即可。

## 一个细节

被额外添加的牛的坐标可能超出 $0\ldots1000$ 的范围，于是它们的坐标可能就成为了负数

很明显，数组并不喜欢负数下标

于是我们在输入时就需要将每一头牛的下标都加一个常数

那么到底需要加多少呢？

当然，随便加个 $1000$ 之类的不会错

但我就是想知道最少具体需要加多少

如题，想要使被动添加的牛尽可能地向范围外延申，我们需要尽可能地组成这样地图形：

```
* ~ *  ~:舒适地牛
  *    *:包围舒适的牛的牛
  
图形一
```

这样我们就需要被动添加一头牛以使所有牛都不舒适
```
  @    @:需要被额外添加的牛
* ~ *  ~:舒适的牛
  *    *:包围舒适的牛的牛

图形二
```

我们只有尽可能地组成图形一，才可以尽可能地使被动添加的牛尽可能地向区域外延申

```
      @        ¥:舒适的牛，但同时也是需要被额外添加的牛     
    @ ¥ @
  @ ¥ ¥ ¥ @
* ~ ~ ~ ~ ~ *  <= 图形一的组合
  * * * * *
```

我们看到，明显的，牛会组成一个直角等腰三角形（当然还有多出来的一排牛），而这个等腰直角三角形的最长边最长又是 $1000-0=1000$ 的（因为范围）。

明显的，以该直角等腰三角形的最长边为底的高 向外延伸得最远。求得该高最长为 $1000/2=500$ ，又因为每头牛的坐标都为整数(即为格点），所以这条高最多包含 $500+1=501$ 头牛

综上，至少给下标加 $501$
![](https://cdn.luogu.com.cn/upload/image_hosting/ugwyw3n2.png)


## 代码~~（终于该上代码了）~~
解析里没提到的几乎都在代码注释里了

```cpp
#include<iostream>
#include<cstdio>
#include<cstring>
#include<queue>
using namespace std;
typedef pair<int,int> PII;
const int N=1e5+10;
const int M=2200;//注意四个方向都有可能扩展501，所以M要加上两个501
short cow[M][M];
short cnt[M][M];
int dx[]={0,0,1,0,-1};//BFS包括5个方位
int dy[]={0,1,0,-1,0};//分别是自己、上、下、左、右
int n;
int ans;//被动更新牛数

void update(int a,int b){
	for(int i=1;i<=4;i++){
		if(cow[a+dx[i]][b+dy[i]]){
			cnt[a][b]++;
			cnt[a+dx[i]][b+dy[i]]++;//记录一头牛附近的牛的数量
		}
	}
}

void add_cow(int a,int b){//bfs
	queue<PII> que;
	for(int i=0;i<=4;i++){
		if (cnt[a+dx[i]][b+dy[i]]==3) que.push({a+dx[i],b+dy[i]});
	}
	while(!que.empty()){
		PII t=que.front();que.pop();
		int x=t.first,y=t.second;
		if(cnt[x][y]!=3) continue;
		int xx,yy;
		for(int i=1;i<=4;i++){
			if(!cow[x+dx[i]][y+dy[i]]){
				xx=x+dx[i];
				yy=y+dy[i];
				cow[xx][yy]=2;
				update(xx,yy);
				ans++;
				for(int i=0;i<=4;i++){
					if (cnt[xx+dx[i]][yy+dy[i]]==3) que.push({xx+dx[i],yy+dy[i]});
				}
				break;
			}
		}
	}
}

int main(){
	//freopen("test.in","r",stdin);
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		int a,b;scanf("%d%d",&a,&b);
		a+=510,b+=510;
		if(cow[a][b]==2){
			cow[a][b]=1;//如果曾经是被动添加的牛，现在变为主动添加了
			ans--;//那也无需再遍历了，直接将 被动添加牛数减一
		}else{
			cow[a][b]=1;
			update(a,b);
			add_cow(a,b);
		}
		printf("%d\n",ans);
	}
	return 0;
}
```

# 完结撒花
（~~终于把我的第一篇题解写完了~~，写的很烂）

